
Hung_DTG01.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000c0  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0001d5c0  080000c0  080000c0  000100c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000555c  0801d680  0801d680  0002d680  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08022bdc  08022bdc  0004009c  2**0
                  CONTENTS
  4 .ARM          00000008  08022bdc  08022bdc  00032bdc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  08022be4  08022be4  0004009c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08022be4  08022be4  00032be4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08022be8  08022be8  00032be8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         0000009c  20000000  08022bec  00040000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00004130  2000009c  08022c88  0004009c  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  200041cc  08022c88  000441cc  2**0
                  ALLOC
 11 .ARM.attributes 00000028  00000000  00000000  0004009c  2**0
                  CONTENTS, READONLY
 12 .debug_info   00053dc8  00000000  00000000  000400c4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 00008cb5  00000000  00000000  00093e8c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00001b90  00000000  00000000  0009cb48  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_ranges 00001b88  00000000  00000000  0009e6d8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  000225b0  00000000  00000000  000a0260  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   0003314a  00000000  00000000  000c2810  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    00089cbe  00000000  00000000  000f595a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000053  00000000  00000000  0017f618  2**0
                  CONTENTS, READONLY
 20 .debug_frame  00006564  00000000  00000000  0017f66c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080000c0 <__do_global_dtors_aux>:
 80000c0:	b510      	push	{r4, lr}
 80000c2:	4c06      	ldr	r4, [pc, #24]	; (80000dc <__do_global_dtors_aux+0x1c>)
 80000c4:	7823      	ldrb	r3, [r4, #0]
 80000c6:	2b00      	cmp	r3, #0
 80000c8:	d107      	bne.n	80000da <__do_global_dtors_aux+0x1a>
 80000ca:	4b05      	ldr	r3, [pc, #20]	; (80000e0 <__do_global_dtors_aux+0x20>)
 80000cc:	2b00      	cmp	r3, #0
 80000ce:	d002      	beq.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d0:	4804      	ldr	r0, [pc, #16]	; (80000e4 <__do_global_dtors_aux+0x24>)
 80000d2:	e000      	b.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d4:	bf00      	nop
 80000d6:	2301      	movs	r3, #1
 80000d8:	7023      	strb	r3, [r4, #0]
 80000da:	bd10      	pop	{r4, pc}
 80000dc:	2000009c 	.word	0x2000009c
 80000e0:	00000000 	.word	0x00000000
 80000e4:	0801d668 	.word	0x0801d668

080000e8 <frame_dummy>:
 80000e8:	4b04      	ldr	r3, [pc, #16]	; (80000fc <frame_dummy+0x14>)
 80000ea:	b510      	push	{r4, lr}
 80000ec:	2b00      	cmp	r3, #0
 80000ee:	d003      	beq.n	80000f8 <frame_dummy+0x10>
 80000f0:	4903      	ldr	r1, [pc, #12]	; (8000100 <frame_dummy+0x18>)
 80000f2:	4804      	ldr	r0, [pc, #16]	; (8000104 <frame_dummy+0x1c>)
 80000f4:	e000      	b.n	80000f8 <frame_dummy+0x10>
 80000f6:	bf00      	nop
 80000f8:	bd10      	pop	{r4, pc}
 80000fa:	46c0      	nop			; (mov r8, r8)
 80000fc:	00000000 	.word	0x00000000
 8000100:	200000a0 	.word	0x200000a0
 8000104:	0801d668 	.word	0x0801d668

08000108 <strlen>:
 8000108:	2300      	movs	r3, #0
 800010a:	5cc2      	ldrb	r2, [r0, r3]
 800010c:	3301      	adds	r3, #1
 800010e:	2a00      	cmp	r2, #0
 8000110:	d1fb      	bne.n	800010a <strlen+0x2>
 8000112:	1e58      	subs	r0, r3, #1
 8000114:	4770      	bx	lr
	...

08000118 <__gnu_thumb1_case_shi>:
 8000118:	b403      	push	{r0, r1}
 800011a:	4671      	mov	r1, lr
 800011c:	0849      	lsrs	r1, r1, #1
 800011e:	0040      	lsls	r0, r0, #1
 8000120:	0049      	lsls	r1, r1, #1
 8000122:	5e09      	ldrsh	r1, [r1, r0]
 8000124:	0049      	lsls	r1, r1, #1
 8000126:	448e      	add	lr, r1
 8000128:	bc03      	pop	{r0, r1}
 800012a:	4770      	bx	lr

0800012c <__udivsi3>:
 800012c:	2200      	movs	r2, #0
 800012e:	0843      	lsrs	r3, r0, #1
 8000130:	428b      	cmp	r3, r1
 8000132:	d374      	bcc.n	800021e <__udivsi3+0xf2>
 8000134:	0903      	lsrs	r3, r0, #4
 8000136:	428b      	cmp	r3, r1
 8000138:	d35f      	bcc.n	80001fa <__udivsi3+0xce>
 800013a:	0a03      	lsrs	r3, r0, #8
 800013c:	428b      	cmp	r3, r1
 800013e:	d344      	bcc.n	80001ca <__udivsi3+0x9e>
 8000140:	0b03      	lsrs	r3, r0, #12
 8000142:	428b      	cmp	r3, r1
 8000144:	d328      	bcc.n	8000198 <__udivsi3+0x6c>
 8000146:	0c03      	lsrs	r3, r0, #16
 8000148:	428b      	cmp	r3, r1
 800014a:	d30d      	bcc.n	8000168 <__udivsi3+0x3c>
 800014c:	22ff      	movs	r2, #255	; 0xff
 800014e:	0209      	lsls	r1, r1, #8
 8000150:	ba12      	rev	r2, r2
 8000152:	0c03      	lsrs	r3, r0, #16
 8000154:	428b      	cmp	r3, r1
 8000156:	d302      	bcc.n	800015e <__udivsi3+0x32>
 8000158:	1212      	asrs	r2, r2, #8
 800015a:	0209      	lsls	r1, r1, #8
 800015c:	d065      	beq.n	800022a <__udivsi3+0xfe>
 800015e:	0b03      	lsrs	r3, r0, #12
 8000160:	428b      	cmp	r3, r1
 8000162:	d319      	bcc.n	8000198 <__udivsi3+0x6c>
 8000164:	e000      	b.n	8000168 <__udivsi3+0x3c>
 8000166:	0a09      	lsrs	r1, r1, #8
 8000168:	0bc3      	lsrs	r3, r0, #15
 800016a:	428b      	cmp	r3, r1
 800016c:	d301      	bcc.n	8000172 <__udivsi3+0x46>
 800016e:	03cb      	lsls	r3, r1, #15
 8000170:	1ac0      	subs	r0, r0, r3
 8000172:	4152      	adcs	r2, r2
 8000174:	0b83      	lsrs	r3, r0, #14
 8000176:	428b      	cmp	r3, r1
 8000178:	d301      	bcc.n	800017e <__udivsi3+0x52>
 800017a:	038b      	lsls	r3, r1, #14
 800017c:	1ac0      	subs	r0, r0, r3
 800017e:	4152      	adcs	r2, r2
 8000180:	0b43      	lsrs	r3, r0, #13
 8000182:	428b      	cmp	r3, r1
 8000184:	d301      	bcc.n	800018a <__udivsi3+0x5e>
 8000186:	034b      	lsls	r3, r1, #13
 8000188:	1ac0      	subs	r0, r0, r3
 800018a:	4152      	adcs	r2, r2
 800018c:	0b03      	lsrs	r3, r0, #12
 800018e:	428b      	cmp	r3, r1
 8000190:	d301      	bcc.n	8000196 <__udivsi3+0x6a>
 8000192:	030b      	lsls	r3, r1, #12
 8000194:	1ac0      	subs	r0, r0, r3
 8000196:	4152      	adcs	r2, r2
 8000198:	0ac3      	lsrs	r3, r0, #11
 800019a:	428b      	cmp	r3, r1
 800019c:	d301      	bcc.n	80001a2 <__udivsi3+0x76>
 800019e:	02cb      	lsls	r3, r1, #11
 80001a0:	1ac0      	subs	r0, r0, r3
 80001a2:	4152      	adcs	r2, r2
 80001a4:	0a83      	lsrs	r3, r0, #10
 80001a6:	428b      	cmp	r3, r1
 80001a8:	d301      	bcc.n	80001ae <__udivsi3+0x82>
 80001aa:	028b      	lsls	r3, r1, #10
 80001ac:	1ac0      	subs	r0, r0, r3
 80001ae:	4152      	adcs	r2, r2
 80001b0:	0a43      	lsrs	r3, r0, #9
 80001b2:	428b      	cmp	r3, r1
 80001b4:	d301      	bcc.n	80001ba <__udivsi3+0x8e>
 80001b6:	024b      	lsls	r3, r1, #9
 80001b8:	1ac0      	subs	r0, r0, r3
 80001ba:	4152      	adcs	r2, r2
 80001bc:	0a03      	lsrs	r3, r0, #8
 80001be:	428b      	cmp	r3, r1
 80001c0:	d301      	bcc.n	80001c6 <__udivsi3+0x9a>
 80001c2:	020b      	lsls	r3, r1, #8
 80001c4:	1ac0      	subs	r0, r0, r3
 80001c6:	4152      	adcs	r2, r2
 80001c8:	d2cd      	bcs.n	8000166 <__udivsi3+0x3a>
 80001ca:	09c3      	lsrs	r3, r0, #7
 80001cc:	428b      	cmp	r3, r1
 80001ce:	d301      	bcc.n	80001d4 <__udivsi3+0xa8>
 80001d0:	01cb      	lsls	r3, r1, #7
 80001d2:	1ac0      	subs	r0, r0, r3
 80001d4:	4152      	adcs	r2, r2
 80001d6:	0983      	lsrs	r3, r0, #6
 80001d8:	428b      	cmp	r3, r1
 80001da:	d301      	bcc.n	80001e0 <__udivsi3+0xb4>
 80001dc:	018b      	lsls	r3, r1, #6
 80001de:	1ac0      	subs	r0, r0, r3
 80001e0:	4152      	adcs	r2, r2
 80001e2:	0943      	lsrs	r3, r0, #5
 80001e4:	428b      	cmp	r3, r1
 80001e6:	d301      	bcc.n	80001ec <__udivsi3+0xc0>
 80001e8:	014b      	lsls	r3, r1, #5
 80001ea:	1ac0      	subs	r0, r0, r3
 80001ec:	4152      	adcs	r2, r2
 80001ee:	0903      	lsrs	r3, r0, #4
 80001f0:	428b      	cmp	r3, r1
 80001f2:	d301      	bcc.n	80001f8 <__udivsi3+0xcc>
 80001f4:	010b      	lsls	r3, r1, #4
 80001f6:	1ac0      	subs	r0, r0, r3
 80001f8:	4152      	adcs	r2, r2
 80001fa:	08c3      	lsrs	r3, r0, #3
 80001fc:	428b      	cmp	r3, r1
 80001fe:	d301      	bcc.n	8000204 <__udivsi3+0xd8>
 8000200:	00cb      	lsls	r3, r1, #3
 8000202:	1ac0      	subs	r0, r0, r3
 8000204:	4152      	adcs	r2, r2
 8000206:	0883      	lsrs	r3, r0, #2
 8000208:	428b      	cmp	r3, r1
 800020a:	d301      	bcc.n	8000210 <__udivsi3+0xe4>
 800020c:	008b      	lsls	r3, r1, #2
 800020e:	1ac0      	subs	r0, r0, r3
 8000210:	4152      	adcs	r2, r2
 8000212:	0843      	lsrs	r3, r0, #1
 8000214:	428b      	cmp	r3, r1
 8000216:	d301      	bcc.n	800021c <__udivsi3+0xf0>
 8000218:	004b      	lsls	r3, r1, #1
 800021a:	1ac0      	subs	r0, r0, r3
 800021c:	4152      	adcs	r2, r2
 800021e:	1a41      	subs	r1, r0, r1
 8000220:	d200      	bcs.n	8000224 <__udivsi3+0xf8>
 8000222:	4601      	mov	r1, r0
 8000224:	4152      	adcs	r2, r2
 8000226:	4610      	mov	r0, r2
 8000228:	4770      	bx	lr
 800022a:	e7ff      	b.n	800022c <__udivsi3+0x100>
 800022c:	b501      	push	{r0, lr}
 800022e:	2000      	movs	r0, #0
 8000230:	f000 f806 	bl	8000240 <__aeabi_idiv0>
 8000234:	bd02      	pop	{r1, pc}
 8000236:	46c0      	nop			; (mov r8, r8)

08000238 <__aeabi_uidivmod>:
 8000238:	2900      	cmp	r1, #0
 800023a:	d0f7      	beq.n	800022c <__udivsi3+0x100>
 800023c:	e776      	b.n	800012c <__udivsi3>
 800023e:	4770      	bx	lr

08000240 <__aeabi_idiv0>:
 8000240:	4770      	bx	lr
 8000242:	46c0      	nop			; (mov r8, r8)

08000244 <__aeabi_uldivmod>:
 8000244:	2b00      	cmp	r3, #0
 8000246:	d111      	bne.n	800026c <__aeabi_uldivmod+0x28>
 8000248:	2a00      	cmp	r2, #0
 800024a:	d10f      	bne.n	800026c <__aeabi_uldivmod+0x28>
 800024c:	2900      	cmp	r1, #0
 800024e:	d100      	bne.n	8000252 <__aeabi_uldivmod+0xe>
 8000250:	2800      	cmp	r0, #0
 8000252:	d002      	beq.n	800025a <__aeabi_uldivmod+0x16>
 8000254:	2100      	movs	r1, #0
 8000256:	43c9      	mvns	r1, r1
 8000258:	1c08      	adds	r0, r1, #0
 800025a:	b407      	push	{r0, r1, r2}
 800025c:	4802      	ldr	r0, [pc, #8]	; (8000268 <__aeabi_uldivmod+0x24>)
 800025e:	a102      	add	r1, pc, #8	; (adr r1, 8000268 <__aeabi_uldivmod+0x24>)
 8000260:	1840      	adds	r0, r0, r1
 8000262:	9002      	str	r0, [sp, #8]
 8000264:	bd03      	pop	{r0, r1, pc}
 8000266:	46c0      	nop			; (mov r8, r8)
 8000268:	ffffffd9 	.word	0xffffffd9
 800026c:	b403      	push	{r0, r1}
 800026e:	4668      	mov	r0, sp
 8000270:	b501      	push	{r0, lr}
 8000272:	9802      	ldr	r0, [sp, #8]
 8000274:	f000 f82e 	bl	80002d4 <__udivmoddi4>
 8000278:	9b01      	ldr	r3, [sp, #4]
 800027a:	469e      	mov	lr, r3
 800027c:	b002      	add	sp, #8
 800027e:	bc0c      	pop	{r2, r3}
 8000280:	4770      	bx	lr
 8000282:	46c0      	nop			; (mov r8, r8)

08000284 <__aeabi_lmul>:
 8000284:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000286:	0415      	lsls	r5, r2, #16
 8000288:	0c2d      	lsrs	r5, r5, #16
 800028a:	000f      	movs	r7, r1
 800028c:	0001      	movs	r1, r0
 800028e:	002e      	movs	r6, r5
 8000290:	46c6      	mov	lr, r8
 8000292:	4684      	mov	ip, r0
 8000294:	0400      	lsls	r0, r0, #16
 8000296:	0c14      	lsrs	r4, r2, #16
 8000298:	0c00      	lsrs	r0, r0, #16
 800029a:	0c09      	lsrs	r1, r1, #16
 800029c:	4346      	muls	r6, r0
 800029e:	434d      	muls	r5, r1
 80002a0:	4360      	muls	r0, r4
 80002a2:	4361      	muls	r1, r4
 80002a4:	1940      	adds	r0, r0, r5
 80002a6:	0c34      	lsrs	r4, r6, #16
 80002a8:	1824      	adds	r4, r4, r0
 80002aa:	b500      	push	{lr}
 80002ac:	42a5      	cmp	r5, r4
 80002ae:	d903      	bls.n	80002b8 <__aeabi_lmul+0x34>
 80002b0:	2080      	movs	r0, #128	; 0x80
 80002b2:	0240      	lsls	r0, r0, #9
 80002b4:	4680      	mov	r8, r0
 80002b6:	4441      	add	r1, r8
 80002b8:	0c25      	lsrs	r5, r4, #16
 80002ba:	186d      	adds	r5, r5, r1
 80002bc:	4661      	mov	r1, ip
 80002be:	4359      	muls	r1, r3
 80002c0:	437a      	muls	r2, r7
 80002c2:	0430      	lsls	r0, r6, #16
 80002c4:	1949      	adds	r1, r1, r5
 80002c6:	0424      	lsls	r4, r4, #16
 80002c8:	0c00      	lsrs	r0, r0, #16
 80002ca:	1820      	adds	r0, r4, r0
 80002cc:	1889      	adds	r1, r1, r2
 80002ce:	bc80      	pop	{r7}
 80002d0:	46b8      	mov	r8, r7
 80002d2:	bdf0      	pop	{r4, r5, r6, r7, pc}

080002d4 <__udivmoddi4>:
 80002d4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80002d6:	4657      	mov	r7, sl
 80002d8:	464e      	mov	r6, r9
 80002da:	4645      	mov	r5, r8
 80002dc:	46de      	mov	lr, fp
 80002de:	b5e0      	push	{r5, r6, r7, lr}
 80002e0:	0004      	movs	r4, r0
 80002e2:	000d      	movs	r5, r1
 80002e4:	4692      	mov	sl, r2
 80002e6:	4699      	mov	r9, r3
 80002e8:	b083      	sub	sp, #12
 80002ea:	428b      	cmp	r3, r1
 80002ec:	d830      	bhi.n	8000350 <__udivmoddi4+0x7c>
 80002ee:	d02d      	beq.n	800034c <__udivmoddi4+0x78>
 80002f0:	4649      	mov	r1, r9
 80002f2:	4650      	mov	r0, sl
 80002f4:	f000 f8ba 	bl	800046c <__clzdi2>
 80002f8:	0029      	movs	r1, r5
 80002fa:	0006      	movs	r6, r0
 80002fc:	0020      	movs	r0, r4
 80002fe:	f000 f8b5 	bl	800046c <__clzdi2>
 8000302:	1a33      	subs	r3, r6, r0
 8000304:	4698      	mov	r8, r3
 8000306:	3b20      	subs	r3, #32
 8000308:	469b      	mov	fp, r3
 800030a:	d433      	bmi.n	8000374 <__udivmoddi4+0xa0>
 800030c:	465a      	mov	r2, fp
 800030e:	4653      	mov	r3, sl
 8000310:	4093      	lsls	r3, r2
 8000312:	4642      	mov	r2, r8
 8000314:	001f      	movs	r7, r3
 8000316:	4653      	mov	r3, sl
 8000318:	4093      	lsls	r3, r2
 800031a:	001e      	movs	r6, r3
 800031c:	42af      	cmp	r7, r5
 800031e:	d83a      	bhi.n	8000396 <__udivmoddi4+0xc2>
 8000320:	42af      	cmp	r7, r5
 8000322:	d100      	bne.n	8000326 <__udivmoddi4+0x52>
 8000324:	e078      	b.n	8000418 <__udivmoddi4+0x144>
 8000326:	465b      	mov	r3, fp
 8000328:	1ba4      	subs	r4, r4, r6
 800032a:	41bd      	sbcs	r5, r7
 800032c:	2b00      	cmp	r3, #0
 800032e:	da00      	bge.n	8000332 <__udivmoddi4+0x5e>
 8000330:	e075      	b.n	800041e <__udivmoddi4+0x14a>
 8000332:	2200      	movs	r2, #0
 8000334:	2300      	movs	r3, #0
 8000336:	9200      	str	r2, [sp, #0]
 8000338:	9301      	str	r3, [sp, #4]
 800033a:	2301      	movs	r3, #1
 800033c:	465a      	mov	r2, fp
 800033e:	4093      	lsls	r3, r2
 8000340:	9301      	str	r3, [sp, #4]
 8000342:	2301      	movs	r3, #1
 8000344:	4642      	mov	r2, r8
 8000346:	4093      	lsls	r3, r2
 8000348:	9300      	str	r3, [sp, #0]
 800034a:	e028      	b.n	800039e <__udivmoddi4+0xca>
 800034c:	4282      	cmp	r2, r0
 800034e:	d9cf      	bls.n	80002f0 <__udivmoddi4+0x1c>
 8000350:	2200      	movs	r2, #0
 8000352:	2300      	movs	r3, #0
 8000354:	9200      	str	r2, [sp, #0]
 8000356:	9301      	str	r3, [sp, #4]
 8000358:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800035a:	2b00      	cmp	r3, #0
 800035c:	d001      	beq.n	8000362 <__udivmoddi4+0x8e>
 800035e:	601c      	str	r4, [r3, #0]
 8000360:	605d      	str	r5, [r3, #4]
 8000362:	9800      	ldr	r0, [sp, #0]
 8000364:	9901      	ldr	r1, [sp, #4]
 8000366:	b003      	add	sp, #12
 8000368:	bcf0      	pop	{r4, r5, r6, r7}
 800036a:	46bb      	mov	fp, r7
 800036c:	46b2      	mov	sl, r6
 800036e:	46a9      	mov	r9, r5
 8000370:	46a0      	mov	r8, r4
 8000372:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000374:	4642      	mov	r2, r8
 8000376:	2320      	movs	r3, #32
 8000378:	1a9b      	subs	r3, r3, r2
 800037a:	4652      	mov	r2, sl
 800037c:	40da      	lsrs	r2, r3
 800037e:	4641      	mov	r1, r8
 8000380:	0013      	movs	r3, r2
 8000382:	464a      	mov	r2, r9
 8000384:	408a      	lsls	r2, r1
 8000386:	0017      	movs	r7, r2
 8000388:	4642      	mov	r2, r8
 800038a:	431f      	orrs	r7, r3
 800038c:	4653      	mov	r3, sl
 800038e:	4093      	lsls	r3, r2
 8000390:	001e      	movs	r6, r3
 8000392:	42af      	cmp	r7, r5
 8000394:	d9c4      	bls.n	8000320 <__udivmoddi4+0x4c>
 8000396:	2200      	movs	r2, #0
 8000398:	2300      	movs	r3, #0
 800039a:	9200      	str	r2, [sp, #0]
 800039c:	9301      	str	r3, [sp, #4]
 800039e:	4643      	mov	r3, r8
 80003a0:	2b00      	cmp	r3, #0
 80003a2:	d0d9      	beq.n	8000358 <__udivmoddi4+0x84>
 80003a4:	07fb      	lsls	r3, r7, #31
 80003a6:	0872      	lsrs	r2, r6, #1
 80003a8:	431a      	orrs	r2, r3
 80003aa:	4646      	mov	r6, r8
 80003ac:	087b      	lsrs	r3, r7, #1
 80003ae:	e00e      	b.n	80003ce <__udivmoddi4+0xfa>
 80003b0:	42ab      	cmp	r3, r5
 80003b2:	d101      	bne.n	80003b8 <__udivmoddi4+0xe4>
 80003b4:	42a2      	cmp	r2, r4
 80003b6:	d80c      	bhi.n	80003d2 <__udivmoddi4+0xfe>
 80003b8:	1aa4      	subs	r4, r4, r2
 80003ba:	419d      	sbcs	r5, r3
 80003bc:	2001      	movs	r0, #1
 80003be:	1924      	adds	r4, r4, r4
 80003c0:	416d      	adcs	r5, r5
 80003c2:	2100      	movs	r1, #0
 80003c4:	3e01      	subs	r6, #1
 80003c6:	1824      	adds	r4, r4, r0
 80003c8:	414d      	adcs	r5, r1
 80003ca:	2e00      	cmp	r6, #0
 80003cc:	d006      	beq.n	80003dc <__udivmoddi4+0x108>
 80003ce:	42ab      	cmp	r3, r5
 80003d0:	d9ee      	bls.n	80003b0 <__udivmoddi4+0xdc>
 80003d2:	3e01      	subs	r6, #1
 80003d4:	1924      	adds	r4, r4, r4
 80003d6:	416d      	adcs	r5, r5
 80003d8:	2e00      	cmp	r6, #0
 80003da:	d1f8      	bne.n	80003ce <__udivmoddi4+0xfa>
 80003dc:	9800      	ldr	r0, [sp, #0]
 80003de:	9901      	ldr	r1, [sp, #4]
 80003e0:	465b      	mov	r3, fp
 80003e2:	1900      	adds	r0, r0, r4
 80003e4:	4169      	adcs	r1, r5
 80003e6:	2b00      	cmp	r3, #0
 80003e8:	db24      	blt.n	8000434 <__udivmoddi4+0x160>
 80003ea:	002b      	movs	r3, r5
 80003ec:	465a      	mov	r2, fp
 80003ee:	4644      	mov	r4, r8
 80003f0:	40d3      	lsrs	r3, r2
 80003f2:	002a      	movs	r2, r5
 80003f4:	40e2      	lsrs	r2, r4
 80003f6:	001c      	movs	r4, r3
 80003f8:	465b      	mov	r3, fp
 80003fa:	0015      	movs	r5, r2
 80003fc:	2b00      	cmp	r3, #0
 80003fe:	db2a      	blt.n	8000456 <__udivmoddi4+0x182>
 8000400:	0026      	movs	r6, r4
 8000402:	409e      	lsls	r6, r3
 8000404:	0033      	movs	r3, r6
 8000406:	0026      	movs	r6, r4
 8000408:	4647      	mov	r7, r8
 800040a:	40be      	lsls	r6, r7
 800040c:	0032      	movs	r2, r6
 800040e:	1a80      	subs	r0, r0, r2
 8000410:	4199      	sbcs	r1, r3
 8000412:	9000      	str	r0, [sp, #0]
 8000414:	9101      	str	r1, [sp, #4]
 8000416:	e79f      	b.n	8000358 <__udivmoddi4+0x84>
 8000418:	42a3      	cmp	r3, r4
 800041a:	d8bc      	bhi.n	8000396 <__udivmoddi4+0xc2>
 800041c:	e783      	b.n	8000326 <__udivmoddi4+0x52>
 800041e:	4642      	mov	r2, r8
 8000420:	2320      	movs	r3, #32
 8000422:	2100      	movs	r1, #0
 8000424:	1a9b      	subs	r3, r3, r2
 8000426:	2200      	movs	r2, #0
 8000428:	9100      	str	r1, [sp, #0]
 800042a:	9201      	str	r2, [sp, #4]
 800042c:	2201      	movs	r2, #1
 800042e:	40da      	lsrs	r2, r3
 8000430:	9201      	str	r2, [sp, #4]
 8000432:	e786      	b.n	8000342 <__udivmoddi4+0x6e>
 8000434:	4642      	mov	r2, r8
 8000436:	2320      	movs	r3, #32
 8000438:	1a9b      	subs	r3, r3, r2
 800043a:	002a      	movs	r2, r5
 800043c:	4646      	mov	r6, r8
 800043e:	409a      	lsls	r2, r3
 8000440:	0023      	movs	r3, r4
 8000442:	40f3      	lsrs	r3, r6
 8000444:	4644      	mov	r4, r8
 8000446:	4313      	orrs	r3, r2
 8000448:	002a      	movs	r2, r5
 800044a:	40e2      	lsrs	r2, r4
 800044c:	001c      	movs	r4, r3
 800044e:	465b      	mov	r3, fp
 8000450:	0015      	movs	r5, r2
 8000452:	2b00      	cmp	r3, #0
 8000454:	dad4      	bge.n	8000400 <__udivmoddi4+0x12c>
 8000456:	4642      	mov	r2, r8
 8000458:	002f      	movs	r7, r5
 800045a:	2320      	movs	r3, #32
 800045c:	0026      	movs	r6, r4
 800045e:	4097      	lsls	r7, r2
 8000460:	1a9b      	subs	r3, r3, r2
 8000462:	40de      	lsrs	r6, r3
 8000464:	003b      	movs	r3, r7
 8000466:	4333      	orrs	r3, r6
 8000468:	e7cd      	b.n	8000406 <__udivmoddi4+0x132>
 800046a:	46c0      	nop			; (mov r8, r8)

0800046c <__clzdi2>:
 800046c:	b510      	push	{r4, lr}
 800046e:	2900      	cmp	r1, #0
 8000470:	d103      	bne.n	800047a <__clzdi2+0xe>
 8000472:	f000 f807 	bl	8000484 <__clzsi2>
 8000476:	3020      	adds	r0, #32
 8000478:	e002      	b.n	8000480 <__clzdi2+0x14>
 800047a:	1c08      	adds	r0, r1, #0
 800047c:	f000 f802 	bl	8000484 <__clzsi2>
 8000480:	bd10      	pop	{r4, pc}
 8000482:	46c0      	nop			; (mov r8, r8)

08000484 <__clzsi2>:
 8000484:	211c      	movs	r1, #28
 8000486:	2301      	movs	r3, #1
 8000488:	041b      	lsls	r3, r3, #16
 800048a:	4298      	cmp	r0, r3
 800048c:	d301      	bcc.n	8000492 <__clzsi2+0xe>
 800048e:	0c00      	lsrs	r0, r0, #16
 8000490:	3910      	subs	r1, #16
 8000492:	0a1b      	lsrs	r3, r3, #8
 8000494:	4298      	cmp	r0, r3
 8000496:	d301      	bcc.n	800049c <__clzsi2+0x18>
 8000498:	0a00      	lsrs	r0, r0, #8
 800049a:	3908      	subs	r1, #8
 800049c:	091b      	lsrs	r3, r3, #4
 800049e:	4298      	cmp	r0, r3
 80004a0:	d301      	bcc.n	80004a6 <__clzsi2+0x22>
 80004a2:	0900      	lsrs	r0, r0, #4
 80004a4:	3904      	subs	r1, #4
 80004a6:	a202      	add	r2, pc, #8	; (adr r2, 80004b0 <__clzsi2+0x2c>)
 80004a8:	5c10      	ldrb	r0, [r2, r0]
 80004aa:	1840      	adds	r0, r0, r1
 80004ac:	4770      	bx	lr
 80004ae:	46c0      	nop			; (mov r8, r8)
 80004b0:	02020304 	.word	0x02020304
 80004b4:	01010101 	.word	0x01010101
	...

080004c0 <HAL_UART_RxCpltCallback>:
	"firmware",
	"abcd@1234",
	(uint32_t)21,
};
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
 80004c0:	b580      	push	{r7, lr}
 80004c2:	b082      	sub	sp, #8
 80004c4:	af00      	add	r7, sp, #0
 80004c6:	6078      	str	r0, [r7, #4]
//	m_rx_buff.data[m_rx_buff.index] = data ;
//	m_rx_buff.index++;

	RingBuffer_Push(&Rx_Buffer, data);
 80004c8:	4b08      	ldr	r3, [pc, #32]	; (80004ec <HAL_UART_RxCpltCallback+0x2c>)
 80004ca:	781a      	ldrb	r2, [r3, #0]
 80004cc:	4b08      	ldr	r3, [pc, #32]	; (80004f0 <HAL_UART_RxCpltCallback+0x30>)
 80004ce:	0011      	movs	r1, r2
 80004d0:	0018      	movs	r0, r3
 80004d2:	f002 fa4f 	bl	8002974 <RingBuffer_Push>
	HAL_UART_Receive_IT(&huart1, &data, 1);
 80004d6:	4905      	ldr	r1, [pc, #20]	; (80004ec <HAL_UART_RxCpltCallback+0x2c>)
 80004d8:	4b06      	ldr	r3, [pc, #24]	; (80004f4 <HAL_UART_RxCpltCallback+0x34>)
 80004da:	2201      	movs	r2, #1
 80004dc:	0018      	movs	r0, r3
 80004de:	f003 fe85 	bl	80041ec <HAL_UART_Receive_IT>
}
 80004e2:	46c0      	nop			; (mov r8, r8)
 80004e4:	46bd      	mov	sp, r7
 80004e6:	b002      	add	sp, #8
 80004e8:	bd80      	pop	{r7, pc}
 80004ea:	46c0      	nop			; (mov r8, r8)
 80004ec:	200000b8 	.word	0x200000b8
 80004f0:	20001c30 	.word	0x20001c30
 80004f4:	20001b98 	.word	0x20001b98

080004f8 <App_Main>:
static void dns_initialize(void);

void App_Main ()
{
 80004f8:	b580      	push	{r7, lr}
 80004fa:	af00      	add	r7, sp, #0
	// Note: Sá»­a NOPULL -> PULLUP:  GPIO_InitStruct.Pull = GPIO_PULLUP; de tranh loi nhan NULL truoc khi Power on EC200
	HAL_UART_Receive_IT(&huart1, &data, 1);
 80004fc:	490d      	ldr	r1, [pc, #52]	; (8000534 <App_Main+0x3c>)
 80004fe:	4b0e      	ldr	r3, [pc, #56]	; (8000538 <App_Main+0x40>)
 8000500:	2201      	movs	r2, #1
 8000502:	0018      	movs	r0, r3
 8000504:	f003 fe72 	bl	80041ec <HAL_UART_Receive_IT>

 	dns_initialize();
 8000508:	f000 f81e 	bl	8000548 <dns_initialize>
	//lwip_init();
	//MQTT_Client_Init(&MQTT_Cfg);
	//HTTP_Client_Init(&HTTP_Cfg);
	GSM_File_Handler_Init(&GSM_File_Handler_Cfg);
 800050c:	4b0b      	ldr	r3, [pc, #44]	; (800053c <App_Main+0x44>)
 800050e:	0018      	movs	r0, r3
 8000510:	f001 fc0c 	bl	8001d2c <GSM_File_Handler_Init>
	DEBUG_INFO("Application started\r\n");
 8000514:	f01c fb0a 	bl	801cb2c <sys_get_tick_ms>
 8000518:	0001      	movs	r1, r0
 800051a:	4a09      	ldr	r2, [pc, #36]	; (8000540 <App_Main+0x48>)
 800051c:	4b09      	ldr	r3, [pc, #36]	; (8000544 <App_Main+0x4c>)
 800051e:	0018      	movs	r0, r3
 8000520:	f002 f9dc 	bl	80028dc <app_debug_rtt_raw>
	GMS_Hardware_Init();
 8000524:	f000 ffac 	bl	8001480 <GMS_Hardware_Init>
	//UART_SendData(USART1, bf_send, sizeof(bf_send));
	while(1)
	{
		GSM_mnr_task();
 8000528:	f000 ff9e 	bl	8001468 <GSM_mnr_task>
		//MQTT_Client_Polling_Task(NULL);
		HTTP_Client_Polling_Task(NULL);
 800052c:	2000      	movs	r0, #0
 800052e:	f005 fa4f 	bl	80059d0 <HTTP_Client_Polling_Task>
		GSM_mnr_task();
 8000532:	e7f9      	b.n	8000528 <App_Main+0x30>
 8000534:	200000b8 	.word	0x200000b8
 8000538:	20001b98 	.word	0x20001b98
 800053c:	20000000 	.word	0x20000000
 8000540:	0801d708 	.word	0x0801d708
 8000544:	0801d70c 	.word	0x0801d70c

08000548 <dns_initialize>:
	}
}

static void dns_initialize(void)
{
 8000548:	b580      	push	{r7, lr}
 800054a:	b082      	sub	sp, #8
 800054c:	af00      	add	r7, sp, #0
    ip_addr_t dns_server_0 = IPADDR4_INIT_BYTES(8, 8, 8, 8);
 800054e:	4b0a      	ldr	r3, [pc, #40]	; (8000578 <dns_initialize+0x30>)
 8000550:	607b      	str	r3, [r7, #4]
    ip_addr_t dns_server_1 = IPADDR4_INIT_BYTES(1, 1, 1, 1);
 8000552:	4b0a      	ldr	r3, [pc, #40]	; (800057c <dns_initialize+0x34>)
 8000554:	603b      	str	r3, [r7, #0]
    dns_setserver(0, &dns_server_0);
 8000556:	1d3b      	adds	r3, r7, #4
 8000558:	0019      	movs	r1, r3
 800055a:	2000      	movs	r0, #0
 800055c:	f006 fbd4 	bl	8006d08 <dns_setserver>
    dns_setserver(1, &dns_server_1);
 8000560:	003b      	movs	r3, r7
 8000562:	0019      	movs	r1, r3
 8000564:	2001      	movs	r0, #1
 8000566:	f006 fbcf 	bl	8006d08 <dns_setserver>
    dns_init();
 800056a:	f006 fbc7 	bl	8006cfc <dns_init>
}
 800056e:	46c0      	nop			; (mov r8, r8)
 8000570:	46bd      	mov	sp, r7
 8000572:	b002      	add	sp, #8
 8000574:	bd80      	pop	{r7, pc}
 8000576:	46c0      	nop			; (mov r8, r8)
 8000578:	08080808 	.word	0x08080808
 800057c:	01010101 	.word	0x01010101

08000580 <MX_GPIO_Init>:
        * Output
        * EVENT_OUT
        * EXTI
*/
void MX_GPIO_Init(void)
{
 8000580:	b590      	push	{r4, r7, lr}
 8000582:	b08b      	sub	sp, #44	; 0x2c
 8000584:	af00      	add	r7, sp, #0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000586:	2414      	movs	r4, #20
 8000588:	193b      	adds	r3, r7, r4
 800058a:	0018      	movs	r0, r3
 800058c:	2314      	movs	r3, #20
 800058e:	001a      	movs	r2, r3
 8000590:	2100      	movs	r1, #0
 8000592:	f01c fb41 	bl	801cc18 <memset>

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8000596:	4b42      	ldr	r3, [pc, #264]	; (80006a0 <MX_GPIO_Init+0x120>)
 8000598:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800059a:	4b41      	ldr	r3, [pc, #260]	; (80006a0 <MX_GPIO_Init+0x120>)
 800059c:	2180      	movs	r1, #128	; 0x80
 800059e:	430a      	orrs	r2, r1
 80005a0:	62da      	str	r2, [r3, #44]	; 0x2c
 80005a2:	4b3f      	ldr	r3, [pc, #252]	; (80006a0 <MX_GPIO_Init+0x120>)
 80005a4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80005a6:	2280      	movs	r2, #128	; 0x80
 80005a8:	4013      	ands	r3, r2
 80005aa:	613b      	str	r3, [r7, #16]
 80005ac:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 80005ae:	4b3c      	ldr	r3, [pc, #240]	; (80006a0 <MX_GPIO_Init+0x120>)
 80005b0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80005b2:	4b3b      	ldr	r3, [pc, #236]	; (80006a0 <MX_GPIO_Init+0x120>)
 80005b4:	2104      	movs	r1, #4
 80005b6:	430a      	orrs	r2, r1
 80005b8:	62da      	str	r2, [r3, #44]	; 0x2c
 80005ba:	4b39      	ldr	r3, [pc, #228]	; (80006a0 <MX_GPIO_Init+0x120>)
 80005bc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80005be:	2204      	movs	r2, #4
 80005c0:	4013      	ands	r3, r2
 80005c2:	60fb      	str	r3, [r7, #12]
 80005c4:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80005c6:	4b36      	ldr	r3, [pc, #216]	; (80006a0 <MX_GPIO_Init+0x120>)
 80005c8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80005ca:	4b35      	ldr	r3, [pc, #212]	; (80006a0 <MX_GPIO_Init+0x120>)
 80005cc:	2101      	movs	r1, #1
 80005ce:	430a      	orrs	r2, r1
 80005d0:	62da      	str	r2, [r3, #44]	; 0x2c
 80005d2:	4b33      	ldr	r3, [pc, #204]	; (80006a0 <MX_GPIO_Init+0x120>)
 80005d4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80005d6:	2201      	movs	r2, #1
 80005d8:	4013      	ands	r3, r2
 80005da:	60bb      	str	r3, [r7, #8]
 80005dc:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 80005de:	4b30      	ldr	r3, [pc, #192]	; (80006a0 <MX_GPIO_Init+0x120>)
 80005e0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80005e2:	4b2f      	ldr	r3, [pc, #188]	; (80006a0 <MX_GPIO_Init+0x120>)
 80005e4:	2102      	movs	r1, #2
 80005e6:	430a      	orrs	r2, r1
 80005e8:	62da      	str	r2, [r3, #44]	; 0x2c
 80005ea:	4b2d      	ldr	r3, [pc, #180]	; (80006a0 <MX_GPIO_Init+0x120>)
 80005ec:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80005ee:	2202      	movs	r2, #2
 80005f0:	4013      	ands	r3, r2
 80005f2:	607b      	str	r3, [r7, #4]
 80005f4:	687b      	ldr	r3, [r7, #4]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOC, CHARGE_EN_Pin|EN_GSM_Pin, GPIO_PIN_RESET);
 80005f6:	4b2b      	ldr	r3, [pc, #172]	; (80006a4 <MX_GPIO_Init+0x124>)
 80005f8:	2200      	movs	r2, #0
 80005fa:	2150      	movs	r1, #80	; 0x50
 80005fc:	0018      	movs	r0, r3
 80005fe:	f002 fdf5 	bl	80031ec <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, GSM_PWKEY_Pin|GSM_EN_Pin, GPIO_PIN_RESET);
 8000602:	2381      	movs	r3, #129	; 0x81
 8000604:	0219      	lsls	r1, r3, #8
 8000606:	23a0      	movs	r3, #160	; 0xa0
 8000608:	05db      	lsls	r3, r3, #23
 800060a:	2200      	movs	r2, #0
 800060c:	0018      	movs	r0, r3
 800060e:	f002 fded 	bl	80031ec <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GSM_RESET_GPIO_Port, GSM_RESET_Pin, GPIO_PIN_RESET);
 8000612:	2380      	movs	r3, #128	; 0x80
 8000614:	009b      	lsls	r3, r3, #2
 8000616:	4824      	ldr	r0, [pc, #144]	; (80006a8 <MX_GPIO_Init+0x128>)
 8000618:	2200      	movs	r2, #0
 800061a:	0019      	movs	r1, r3
 800061c:	f002 fde6 	bl	80031ec <HAL_GPIO_WritePin>

  /*Configure GPIO pins : PCPin PCPin */
  GPIO_InitStruct.Pin = CHARGE_EN_Pin|EN_GSM_Pin;
 8000620:	193b      	adds	r3, r7, r4
 8000622:	2250      	movs	r2, #80	; 0x50
 8000624:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000626:	193b      	adds	r3, r7, r4
 8000628:	2201      	movs	r2, #1
 800062a:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800062c:	193b      	adds	r3, r7, r4
 800062e:	2200      	movs	r2, #0
 8000630:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000632:	193b      	adds	r3, r7, r4
 8000634:	2200      	movs	r2, #0
 8000636:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000638:	193b      	adds	r3, r7, r4
 800063a:	4a1a      	ldr	r2, [pc, #104]	; (80006a4 <MX_GPIO_Init+0x124>)
 800063c:	0019      	movs	r1, r3
 800063e:	0010      	movs	r0, r2
 8000640:	f002 fc56 	bl	8002ef0 <HAL_GPIO_Init>

  /*Configure GPIO pins : PAPin PAPin */
  GPIO_InitStruct.Pin = GSM_PWKEY_Pin|GSM_EN_Pin;
 8000644:	0021      	movs	r1, r4
 8000646:	187b      	adds	r3, r7, r1
 8000648:	2281      	movs	r2, #129	; 0x81
 800064a:	0212      	lsls	r2, r2, #8
 800064c:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800064e:	000c      	movs	r4, r1
 8000650:	193b      	adds	r3, r7, r4
 8000652:	2201      	movs	r2, #1
 8000654:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000656:	193b      	adds	r3, r7, r4
 8000658:	2200      	movs	r2, #0
 800065a:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800065c:	193b      	adds	r3, r7, r4
 800065e:	2200      	movs	r2, #0
 8000660:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000662:	193a      	adds	r2, r7, r4
 8000664:	23a0      	movs	r3, #160	; 0xa0
 8000666:	05db      	lsls	r3, r3, #23
 8000668:	0011      	movs	r1, r2
 800066a:	0018      	movs	r0, r3
 800066c:	f002 fc40 	bl	8002ef0 <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = GSM_RESET_Pin;
 8000670:	0021      	movs	r1, r4
 8000672:	187b      	adds	r3, r7, r1
 8000674:	2280      	movs	r2, #128	; 0x80
 8000676:	0092      	lsls	r2, r2, #2
 8000678:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800067a:	187b      	adds	r3, r7, r1
 800067c:	2201      	movs	r2, #1
 800067e:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000680:	187b      	adds	r3, r7, r1
 8000682:	2200      	movs	r2, #0
 8000684:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000686:	187b      	adds	r3, r7, r1
 8000688:	2200      	movs	r2, #0
 800068a:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(GSM_RESET_GPIO_Port, &GPIO_InitStruct);
 800068c:	187b      	adds	r3, r7, r1
 800068e:	4a06      	ldr	r2, [pc, #24]	; (80006a8 <MX_GPIO_Init+0x128>)
 8000690:	0019      	movs	r1, r3
 8000692:	0010      	movs	r0, r2
 8000694:	f002 fc2c 	bl	8002ef0 <HAL_GPIO_Init>

}
 8000698:	46c0      	nop			; (mov r8, r8)
 800069a:	46bd      	mov	sp, r7
 800069c:	b00b      	add	sp, #44	; 0x2c
 800069e:	bd90      	pop	{r4, r7, pc}
 80006a0:	40021000 	.word	0x40021000
 80006a4:	50000800 	.word	0x50000800
 80006a8:	50000400 	.word	0x50000400

080006ac <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 80006ac:	b580      	push	{r7, lr}
 80006ae:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 80006b0:	f002 fa24 	bl	8002afc <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 80006b4:	f000 f808 	bl	80006c8 <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 80006b8:	f7ff ff62 	bl	8000580 <MX_GPIO_Init>
  MX_USART1_UART_Init();
 80006bc:	f000 f8f0 	bl	80008a0 <MX_USART1_UART_Init>
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
	  App_Main();
 80006c0:	f7ff ff1a 	bl	80004f8 <App_Main>
 80006c4:	e7fc      	b.n	80006c0 <main+0x14>
	...

080006c8 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 80006c8:	b590      	push	{r4, r7, lr}
 80006ca:	b09b      	sub	sp, #108	; 0x6c
 80006cc:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 80006ce:	2434      	movs	r4, #52	; 0x34
 80006d0:	193b      	adds	r3, r7, r4
 80006d2:	0018      	movs	r0, r3
 80006d4:	2334      	movs	r3, #52	; 0x34
 80006d6:	001a      	movs	r2, r3
 80006d8:	2100      	movs	r1, #0
 80006da:	f01c fa9d 	bl	801cc18 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 80006de:	2320      	movs	r3, #32
 80006e0:	18fb      	adds	r3, r7, r3
 80006e2:	0018      	movs	r0, r3
 80006e4:	2314      	movs	r3, #20
 80006e6:	001a      	movs	r2, r3
 80006e8:	2100      	movs	r1, #0
 80006ea:	f01c fa95 	bl	801cc18 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 80006ee:	003b      	movs	r3, r7
 80006f0:	0018      	movs	r0, r3
 80006f2:	2320      	movs	r3, #32
 80006f4:	001a      	movs	r2, r3
 80006f6:	2100      	movs	r1, #0
 80006f8:	f01c fa8e 	bl	801cc18 <memset>

  /** Configure the main internal regulator output voltage
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 80006fc:	4b29      	ldr	r3, [pc, #164]	; (80007a4 <SystemClock_Config+0xdc>)
 80006fe:	681b      	ldr	r3, [r3, #0]
 8000700:	4a29      	ldr	r2, [pc, #164]	; (80007a8 <SystemClock_Config+0xe0>)
 8000702:	401a      	ands	r2, r3
 8000704:	4b27      	ldr	r3, [pc, #156]	; (80007a4 <SystemClock_Config+0xdc>)
 8000706:	2180      	movs	r1, #128	; 0x80
 8000708:	0109      	lsls	r1, r1, #4
 800070a:	430a      	orrs	r2, r1
 800070c:	601a      	str	r2, [r3, #0]
  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 800070e:	0021      	movs	r1, r4
 8000710:	187b      	adds	r3, r7, r1
 8000712:	2202      	movs	r2, #2
 8000714:	601a      	str	r2, [r3, #0]
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8000716:	187b      	adds	r3, r7, r1
 8000718:	2201      	movs	r2, #1
 800071a:	60da      	str	r2, [r3, #12]
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 800071c:	187b      	adds	r3, r7, r1
 800071e:	2210      	movs	r2, #16
 8000720:	611a      	str	r2, [r3, #16]
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8000722:	187b      	adds	r3, r7, r1
 8000724:	2202      	movs	r2, #2
 8000726:	625a      	str	r2, [r3, #36]	; 0x24
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
 8000728:	187b      	adds	r3, r7, r1
 800072a:	2200      	movs	r2, #0
 800072c:	629a      	str	r2, [r3, #40]	; 0x28
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLLMUL_4;
 800072e:	187b      	adds	r3, r7, r1
 8000730:	2280      	movs	r2, #128	; 0x80
 8000732:	02d2      	lsls	r2, r2, #11
 8000734:	62da      	str	r2, [r3, #44]	; 0x2c
  RCC_OscInitStruct.PLL.PLLDIV = RCC_PLLDIV_2;
 8000736:	187b      	adds	r3, r7, r1
 8000738:	2280      	movs	r2, #128	; 0x80
 800073a:	03d2      	lsls	r2, r2, #15
 800073c:	631a      	str	r2, [r3, #48]	; 0x30
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800073e:	187b      	adds	r3, r7, r1
 8000740:	0018      	movs	r0, r3
 8000742:	f002 fd71 	bl	8003228 <HAL_RCC_OscConfig>
 8000746:	1e03      	subs	r3, r0, #0
 8000748:	d001      	beq.n	800074e <SystemClock_Config+0x86>
  {
    Error_Handler();
 800074a:	f000 f82f 	bl	80007ac <Error_Handler>
  }
  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800074e:	2120      	movs	r1, #32
 8000750:	187b      	adds	r3, r7, r1
 8000752:	220f      	movs	r2, #15
 8000754:	601a      	str	r2, [r3, #0]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8000756:	187b      	adds	r3, r7, r1
 8000758:	2203      	movs	r2, #3
 800075a:	605a      	str	r2, [r3, #4]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 800075c:	187b      	adds	r3, r7, r1
 800075e:	2200      	movs	r2, #0
 8000760:	609a      	str	r2, [r3, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8000762:	187b      	adds	r3, r7, r1
 8000764:	2200      	movs	r2, #0
 8000766:	60da      	str	r2, [r3, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8000768:	187b      	adds	r3, r7, r1
 800076a:	2200      	movs	r2, #0
 800076c:	611a      	str	r2, [r3, #16]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 800076e:	187b      	adds	r3, r7, r1
 8000770:	2101      	movs	r1, #1
 8000772:	0018      	movs	r0, r3
 8000774:	f003 f8d4 	bl	8003920 <HAL_RCC_ClockConfig>
 8000778:	1e03      	subs	r3, r0, #0
 800077a:	d001      	beq.n	8000780 <SystemClock_Config+0xb8>
  {
    Error_Handler();
 800077c:	f000 f816 	bl	80007ac <Error_Handler>
  }
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1;
 8000780:	003b      	movs	r3, r7
 8000782:	2201      	movs	r2, #1
 8000784:	601a      	str	r2, [r3, #0]
  PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
 8000786:	003b      	movs	r3, r7
 8000788:	2200      	movs	r2, #0
 800078a:	609a      	str	r2, [r3, #8]
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 800078c:	003b      	movs	r3, r7
 800078e:	0018      	movs	r0, r3
 8000790:	f003 faea 	bl	8003d68 <HAL_RCCEx_PeriphCLKConfig>
 8000794:	1e03      	subs	r3, r0, #0
 8000796:	d001      	beq.n	800079c <SystemClock_Config+0xd4>
  {
    Error_Handler();
 8000798:	f000 f808 	bl	80007ac <Error_Handler>
  }
}
 800079c:	46c0      	nop			; (mov r8, r8)
 800079e:	46bd      	mov	sp, r7
 80007a0:	b01b      	add	sp, #108	; 0x6c
 80007a2:	bd90      	pop	{r4, r7, pc}
 80007a4:	40007000 	.word	0x40007000
 80007a8:	ffffe7ff 	.word	0xffffe7ff

080007ac <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 80007ac:	b580      	push	{r7, lr}
 80007ae:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80007b0:	b672      	cpsid	i
}
 80007b2:	46c0      	nop			; (mov r8, r8)
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 80007b4:	e7fe      	b.n	80007b4 <Error_Handler+0x8>
	...

080007b8 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80007b8:	b580      	push	{r7, lr}
 80007ba:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80007bc:	4b07      	ldr	r3, [pc, #28]	; (80007dc <HAL_MspInit+0x24>)
 80007be:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80007c0:	4b06      	ldr	r3, [pc, #24]	; (80007dc <HAL_MspInit+0x24>)
 80007c2:	2101      	movs	r1, #1
 80007c4:	430a      	orrs	r2, r1
 80007c6:	635a      	str	r2, [r3, #52]	; 0x34
  __HAL_RCC_PWR_CLK_ENABLE();
 80007c8:	4b04      	ldr	r3, [pc, #16]	; (80007dc <HAL_MspInit+0x24>)
 80007ca:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80007cc:	4b03      	ldr	r3, [pc, #12]	; (80007dc <HAL_MspInit+0x24>)
 80007ce:	2180      	movs	r1, #128	; 0x80
 80007d0:	0549      	lsls	r1, r1, #21
 80007d2:	430a      	orrs	r2, r1
 80007d4:	639a      	str	r2, [r3, #56]	; 0x38
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80007d6:	46c0      	nop			; (mov r8, r8)
 80007d8:	46bd      	mov	sp, r7
 80007da:	bd80      	pop	{r7, pc}
 80007dc:	40021000 	.word	0x40021000

080007e0 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable Interrupt.
  */
void NMI_Handler(void)
{
 80007e0:	b580      	push	{r7, lr}
 80007e2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 80007e4:	e7fe      	b.n	80007e4 <NMI_Handler+0x4>

080007e6 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 80007e6:	b580      	push	{r7, lr}
 80007e8:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 80007ea:	e7fe      	b.n	80007ea <HardFault_Handler+0x4>

080007ec <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 80007ec:	b580      	push	{r7, lr}
 80007ee:	af00      	add	r7, sp, #0

  /* USER CODE END SVC_IRQn 0 */
  /* USER CODE BEGIN SVC_IRQn 1 */

  /* USER CODE END SVC_IRQn 1 */
}
 80007f0:	46c0      	nop			; (mov r8, r8)
 80007f2:	46bd      	mov	sp, r7
 80007f4:	bd80      	pop	{r7, pc}

080007f6 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 80007f6:	b580      	push	{r7, lr}
 80007f8:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 80007fa:	46c0      	nop			; (mov r8, r8)
 80007fc:	46bd      	mov	sp, r7
 80007fe:	bd80      	pop	{r7, pc}

08000800 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8000800:	b580      	push	{r7, lr}
 8000802:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8000804:	f002 f9ce 	bl	8002ba4 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8000808:	46c0      	nop			; (mov r8, r8)
 800080a:	46bd      	mov	sp, r7
 800080c:	bd80      	pop	{r7, pc}
	...

08000810 <USART1_IRQHandler>:

/**
  * @brief This function handles USART1 global interrupt / USART1 wake-up interrupt through EXTI line 25.
  */
void USART1_IRQHandler(void)
{
 8000810:	b580      	push	{r7, lr}
 8000812:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN USART1_IRQn 0 */
	/* Check RXNE flag value in ISR register */

  /* USER CODE END USART1_IRQn 0 */
  HAL_UART_IRQHandler(&huart1);
 8000814:	4b03      	ldr	r3, [pc, #12]	; (8000824 <USART1_IRQHandler+0x14>)
 8000816:	0018      	movs	r0, r3
 8000818:	f003 fd50 	bl	80042bc <HAL_UART_IRQHandler>
  /* USER CODE BEGIN USART1_IRQn 1 */

  /* USER CODE END USART1_IRQn 1 */
}
 800081c:	46c0      	nop			; (mov r8, r8)
 800081e:	46bd      	mov	sp, r7
 8000820:	bd80      	pop	{r7, pc}
 8000822:	46c0      	nop			; (mov r8, r8)
 8000824:	20001b98 	.word	0x20001b98

08000828 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 8000828:	b580      	push	{r7, lr}
 800082a:	b086      	sub	sp, #24
 800082c:	af00      	add	r7, sp, #0
 800082e:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8000830:	4a13      	ldr	r2, [pc, #76]	; (8000880 <_sbrk+0x58>)
 8000832:	4b14      	ldr	r3, [pc, #80]	; (8000884 <_sbrk+0x5c>)
 8000834:	1ad3      	subs	r3, r2, r3
 8000836:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 8000838:	697b      	ldr	r3, [r7, #20]
 800083a:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 800083c:	4b12      	ldr	r3, [pc, #72]	; (8000888 <_sbrk+0x60>)
 800083e:	681b      	ldr	r3, [r3, #0]
 8000840:	2b00      	cmp	r3, #0
 8000842:	d102      	bne.n	800084a <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 8000844:	4b10      	ldr	r3, [pc, #64]	; (8000888 <_sbrk+0x60>)
 8000846:	4a11      	ldr	r2, [pc, #68]	; (800088c <_sbrk+0x64>)
 8000848:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 800084a:	4b0f      	ldr	r3, [pc, #60]	; (8000888 <_sbrk+0x60>)
 800084c:	681a      	ldr	r2, [r3, #0]
 800084e:	687b      	ldr	r3, [r7, #4]
 8000850:	18d3      	adds	r3, r2, r3
 8000852:	693a      	ldr	r2, [r7, #16]
 8000854:	429a      	cmp	r2, r3
 8000856:	d205      	bcs.n	8000864 <_sbrk+0x3c>
  {
    errno = ENOMEM;
 8000858:	4b0d      	ldr	r3, [pc, #52]	; (8000890 <_sbrk+0x68>)
 800085a:	220c      	movs	r2, #12
 800085c:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 800085e:	2301      	movs	r3, #1
 8000860:	425b      	negs	r3, r3
 8000862:	e009      	b.n	8000878 <_sbrk+0x50>
  }

  prev_heap_end = __sbrk_heap_end;
 8000864:	4b08      	ldr	r3, [pc, #32]	; (8000888 <_sbrk+0x60>)
 8000866:	681b      	ldr	r3, [r3, #0]
 8000868:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 800086a:	4b07      	ldr	r3, [pc, #28]	; (8000888 <_sbrk+0x60>)
 800086c:	681a      	ldr	r2, [r3, #0]
 800086e:	687b      	ldr	r3, [r7, #4]
 8000870:	18d2      	adds	r2, r2, r3
 8000872:	4b05      	ldr	r3, [pc, #20]	; (8000888 <_sbrk+0x60>)
 8000874:	601a      	str	r2, [r3, #0]

  return (void *)prev_heap_end;
 8000876:	68fb      	ldr	r3, [r7, #12]
}
 8000878:	0018      	movs	r0, r3
 800087a:	46bd      	mov	sp, r7
 800087c:	b006      	add	sp, #24
 800087e:	bd80      	pop	{r7, pc}
 8000880:	20005000 	.word	0x20005000
 8000884:	00000400 	.word	0x00000400
 8000888:	200000bc 	.word	0x200000bc
 800088c:	200041d0 	.word	0x200041d0
 8000890:	200041bc 	.word	0x200041bc

08000894 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 8000894:	b580      	push	{r7, lr}
 8000896:	af00      	add	r7, sp, #0
  /* Configure the Vector Table location add offset address ------------------*/
#if defined (USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 8000898:	46c0      	nop			; (mov r8, r8)
 800089a:	46bd      	mov	sp, r7
 800089c:	bd80      	pop	{r7, pc}
	...

080008a0 <MX_USART1_UART_Init>:
UART_HandleTypeDef huart1;

/* USART1 init function */

void MX_USART1_UART_Init(void)
{
 80008a0:	b580      	push	{r7, lr}
 80008a2:	af00      	add	r7, sp, #0
  /* USER CODE END USART1_Init 0 */

  /* USER CODE BEGIN USART1_Init 1 */

  /* USER CODE END USART1_Init 1 */
  huart1.Instance = USART1;
 80008a4:	4b14      	ldr	r3, [pc, #80]	; (80008f8 <MX_USART1_UART_Init+0x58>)
 80008a6:	4a15      	ldr	r2, [pc, #84]	; (80008fc <MX_USART1_UART_Init+0x5c>)
 80008a8:	601a      	str	r2, [r3, #0]
  huart1.Init.BaudRate = 115200;
 80008aa:	4b13      	ldr	r3, [pc, #76]	; (80008f8 <MX_USART1_UART_Init+0x58>)
 80008ac:	22e1      	movs	r2, #225	; 0xe1
 80008ae:	0252      	lsls	r2, r2, #9
 80008b0:	605a      	str	r2, [r3, #4]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 80008b2:	4b11      	ldr	r3, [pc, #68]	; (80008f8 <MX_USART1_UART_Init+0x58>)
 80008b4:	2200      	movs	r2, #0
 80008b6:	609a      	str	r2, [r3, #8]
  huart1.Init.StopBits = UART_STOPBITS_1;
 80008b8:	4b0f      	ldr	r3, [pc, #60]	; (80008f8 <MX_USART1_UART_Init+0x58>)
 80008ba:	2200      	movs	r2, #0
 80008bc:	60da      	str	r2, [r3, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
 80008be:	4b0e      	ldr	r3, [pc, #56]	; (80008f8 <MX_USART1_UART_Init+0x58>)
 80008c0:	2200      	movs	r2, #0
 80008c2:	611a      	str	r2, [r3, #16]
  huart1.Init.Mode = UART_MODE_TX_RX;
 80008c4:	4b0c      	ldr	r3, [pc, #48]	; (80008f8 <MX_USART1_UART_Init+0x58>)
 80008c6:	220c      	movs	r2, #12
 80008c8:	615a      	str	r2, [r3, #20]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 80008ca:	4b0b      	ldr	r3, [pc, #44]	; (80008f8 <MX_USART1_UART_Init+0x58>)
 80008cc:	2200      	movs	r2, #0
 80008ce:	619a      	str	r2, [r3, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 80008d0:	4b09      	ldr	r3, [pc, #36]	; (80008f8 <MX_USART1_UART_Init+0x58>)
 80008d2:	2200      	movs	r2, #0
 80008d4:	61da      	str	r2, [r3, #28]
  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 80008d6:	4b08      	ldr	r3, [pc, #32]	; (80008f8 <MX_USART1_UART_Init+0x58>)
 80008d8:	2200      	movs	r2, #0
 80008da:	621a      	str	r2, [r3, #32]
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 80008dc:	4b06      	ldr	r3, [pc, #24]	; (80008f8 <MX_USART1_UART_Init+0x58>)
 80008de:	2200      	movs	r2, #0
 80008e0:	625a      	str	r2, [r3, #36]	; 0x24
  if (HAL_UART_Init(&huart1) != HAL_OK)
 80008e2:	4b05      	ldr	r3, [pc, #20]	; (80008f8 <MX_USART1_UART_Init+0x58>)
 80008e4:	0018      	movs	r0, r3
 80008e6:	f003 fb85 	bl	8003ff4 <HAL_UART_Init>
 80008ea:	1e03      	subs	r3, r0, #0
 80008ec:	d001      	beq.n	80008f2 <MX_USART1_UART_Init+0x52>
  {
    Error_Handler();
 80008ee:	f7ff ff5d 	bl	80007ac <Error_Handler>
  }
  /* USER CODE BEGIN USART1_Init 2 */

  /* USER CODE END USART1_Init 2 */

}
 80008f2:	46c0      	nop			; (mov r8, r8)
 80008f4:	46bd      	mov	sp, r7
 80008f6:	bd80      	pop	{r7, pc}
 80008f8:	20001b98 	.word	0x20001b98
 80008fc:	40013800 	.word	0x40013800

08000900 <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 8000900:	b590      	push	{r4, r7, lr}
 8000902:	b089      	sub	sp, #36	; 0x24
 8000904:	af00      	add	r7, sp, #0
 8000906:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000908:	240c      	movs	r4, #12
 800090a:	193b      	adds	r3, r7, r4
 800090c:	0018      	movs	r0, r3
 800090e:	2314      	movs	r3, #20
 8000910:	001a      	movs	r2, r3
 8000912:	2100      	movs	r1, #0
 8000914:	f01c f980 	bl	801cc18 <memset>
  if(uartHandle->Instance==USART1)
 8000918:	687b      	ldr	r3, [r7, #4]
 800091a:	681b      	ldr	r3, [r3, #0]
 800091c:	4a1c      	ldr	r2, [pc, #112]	; (8000990 <HAL_UART_MspInit+0x90>)
 800091e:	4293      	cmp	r3, r2
 8000920:	d132      	bne.n	8000988 <HAL_UART_MspInit+0x88>
  {
  /* USER CODE BEGIN USART1_MspInit 0 */

  /* USER CODE END USART1_MspInit 0 */
    /* USART1 clock enable */
    __HAL_RCC_USART1_CLK_ENABLE();
 8000922:	4b1c      	ldr	r3, [pc, #112]	; (8000994 <HAL_UART_MspInit+0x94>)
 8000924:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000926:	4b1b      	ldr	r3, [pc, #108]	; (8000994 <HAL_UART_MspInit+0x94>)
 8000928:	2180      	movs	r1, #128	; 0x80
 800092a:	01c9      	lsls	r1, r1, #7
 800092c:	430a      	orrs	r2, r1
 800092e:	635a      	str	r2, [r3, #52]	; 0x34

    __HAL_RCC_GPIOA_CLK_ENABLE();
 8000930:	4b18      	ldr	r3, [pc, #96]	; (8000994 <HAL_UART_MspInit+0x94>)
 8000932:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000934:	4b17      	ldr	r3, [pc, #92]	; (8000994 <HAL_UART_MspInit+0x94>)
 8000936:	2101      	movs	r1, #1
 8000938:	430a      	orrs	r2, r1
 800093a:	62da      	str	r2, [r3, #44]	; 0x2c
 800093c:	4b15      	ldr	r3, [pc, #84]	; (8000994 <HAL_UART_MspInit+0x94>)
 800093e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000940:	2201      	movs	r2, #1
 8000942:	4013      	ands	r3, r2
 8000944:	60bb      	str	r3, [r7, #8]
 8000946:	68bb      	ldr	r3, [r7, #8]
    /**USART1 GPIO Configuration
    PA9     ------> USART1_TX
    PA10     ------> USART1_RX
    */
    GPIO_InitStruct.Pin = MCU_TX0_Pin|MCU_RX0_Pin;
 8000948:	193b      	adds	r3, r7, r4
 800094a:	22c0      	movs	r2, #192	; 0xc0
 800094c:	00d2      	lsls	r2, r2, #3
 800094e:	601a      	str	r2, [r3, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000950:	0021      	movs	r1, r4
 8000952:	187b      	adds	r3, r7, r1
 8000954:	2202      	movs	r2, #2
 8000956:	605a      	str	r2, [r3, #4]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000958:	187b      	adds	r3, r7, r1
 800095a:	2200      	movs	r2, #0
 800095c:	609a      	str	r2, [r3, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800095e:	187b      	adds	r3, r7, r1
 8000960:	2203      	movs	r2, #3
 8000962:	60da      	str	r2, [r3, #12]
    GPIO_InitStruct.Alternate = GPIO_AF4_USART1;
 8000964:	187b      	adds	r3, r7, r1
 8000966:	2204      	movs	r2, #4
 8000968:	611a      	str	r2, [r3, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800096a:	187a      	adds	r2, r7, r1
 800096c:	23a0      	movs	r3, #160	; 0xa0
 800096e:	05db      	lsls	r3, r3, #23
 8000970:	0011      	movs	r1, r2
 8000972:	0018      	movs	r0, r3
 8000974:	f002 fabc 	bl	8002ef0 <HAL_GPIO_Init>

    /* USART1 interrupt Init */
    HAL_NVIC_SetPriority(USART1_IRQn, 1, 0);
 8000978:	2200      	movs	r2, #0
 800097a:	2101      	movs	r1, #1
 800097c:	201b      	movs	r0, #27
 800097e:	f002 f9fd 	bl	8002d7c <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART1_IRQn);
 8000982:	201b      	movs	r0, #27
 8000984:	f002 fa0f 	bl	8002da6 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USART1_MspInit 1 */

  /* USER CODE END USART1_MspInit 1 */
  }
}
 8000988:	46c0      	nop			; (mov r8, r8)
 800098a:	46bd      	mov	sp, r7
 800098c:	b009      	add	sp, #36	; 0x24
 800098e:	bd90      	pop	{r4, r7, pc}
 8000990:	40013800 	.word	0x40013800
 8000994:	40021000 	.word	0x40021000

08000998 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
   ldr   r0, =_estack
 8000998:	480d      	ldr	r0, [pc, #52]	; (80009d0 <LoopForever+0x2>)
   mov   sp, r0          /* set stack pointer */
 800099a:	4685      	mov	sp, r0

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 800099c:	480d      	ldr	r0, [pc, #52]	; (80009d4 <LoopForever+0x6>)
  ldr r1, =_edata
 800099e:	490e      	ldr	r1, [pc, #56]	; (80009d8 <LoopForever+0xa>)
  ldr r2, =_sidata
 80009a0:	4a0e      	ldr	r2, [pc, #56]	; (80009dc <LoopForever+0xe>)
  movs r3, #0
 80009a2:	2300      	movs	r3, #0
  b LoopCopyDataInit
 80009a4:	e002      	b.n	80009ac <LoopCopyDataInit>

080009a6 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 80009a6:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 80009a8:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 80009aa:	3304      	adds	r3, #4

080009ac <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 80009ac:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 80009ae:	428c      	cmp	r4, r1
  bcc CopyDataInit
 80009b0:	d3f9      	bcc.n	80009a6 <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 80009b2:	4a0b      	ldr	r2, [pc, #44]	; (80009e0 <LoopForever+0x12>)
  ldr r4, =_ebss
 80009b4:	4c0b      	ldr	r4, [pc, #44]	; (80009e4 <LoopForever+0x16>)
  movs r3, #0
 80009b6:	2300      	movs	r3, #0
  b LoopFillZerobss
 80009b8:	e001      	b.n	80009be <LoopFillZerobss>

080009ba <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 80009ba:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 80009bc:	3204      	adds	r2, #4

080009be <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 80009be:	42a2      	cmp	r2, r4
  bcc FillZerobss
 80009c0:	d3fb      	bcc.n	80009ba <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit
 80009c2:	f7ff ff67 	bl	8000894 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 80009c6:	f01c f8cf 	bl	801cb68 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 80009ca:	f7ff fe6f 	bl	80006ac <main>

080009ce <LoopForever>:

LoopForever:
    b LoopForever
 80009ce:	e7fe      	b.n	80009ce <LoopForever>
   ldr   r0, =_estack
 80009d0:	20005000 	.word	0x20005000
  ldr r0, =_sdata
 80009d4:	20000000 	.word	0x20000000
  ldr r1, =_edata
 80009d8:	2000009c 	.word	0x2000009c
  ldr r2, =_sidata
 80009dc:	08022bec 	.word	0x08022bec
  ldr r2, =_sbss
 80009e0:	2000009c 	.word	0x2000009c
  ldr r4, =_ebss
 80009e4:	200041cc 	.word	0x200041cc

080009e8 <ADC1_COMP_IRQHandler>:
 * @retval : None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 80009e8:	e7fe      	b.n	80009e8 <ADC1_COMP_IRQHandler>
	...

080009ec <__NVIC_SystemReset>:
/**
  \brief   System Reset
  \details Initiates a system reset request to reset the MCU.
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
 80009ec:	b580      	push	{r7, lr}
 80009ee:	af00      	add	r7, sp, #0
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 80009f0:	f3bf 8f4f 	dsb	sy
}
 80009f4:	46c0      	nop			; (mov r8, r8)
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 80009f6:	4b04      	ldr	r3, [pc, #16]	; (8000a08 <__NVIC_SystemReset+0x1c>)
 80009f8:	4a04      	ldr	r2, [pc, #16]	; (8000a0c <__NVIC_SystemReset+0x20>)
 80009fa:	60da      	str	r2, [r3, #12]
  __ASM volatile ("dsb 0xF":::"memory");
 80009fc:	f3bf 8f4f 	dsb	sy
}
 8000a00:	46c0      	nop			; (mov r8, r8)
                 SCB_AIRCR_SYSRESETREQ_Msk);
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 8000a02:	46c0      	nop			; (mov r8, r8)
 8000a04:	e7fd      	b.n	8000a02 <__NVIC_SystemReset+0x16>
 8000a06:	46c0      	nop			; (mov r8, r8)
 8000a08:	e000ed00 	.word	0xe000ed00
 8000a0c:	05fa0004 	.word	0x05fa0004

08000a10 <GSM_Config_Module>:
    {"ATD*99***1#\r\n", "CONNECT", "", "", "", 1000, 10, open_ppp_stack}, // Open ppp stack
    
};

void GSM_Config_Module (GSM_Response_Event_TypDef event, void *Resp_Buffer)
{
 8000a10:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000a12:	b089      	sub	sp, #36	; 0x24
 8000a14:	af04      	add	r7, sp, #16
 8000a16:	0002      	movs	r2, r0
 8000a18:	6039      	str	r1, [r7, #0]
 8000a1a:	1dfb      	adds	r3, r7, #7
 8000a1c:	701a      	strb	r2, [r3, #0]
    uint8_t TableIndex = GSM_Manager.step;
 8000a1e:	210f      	movs	r1, #15
 8000a20:	187b      	adds	r3, r7, r1
 8000a22:	4a4a      	ldr	r2, [pc, #296]	; (8000b4c <GSM_Config_Module+0x13c>)
 8000a24:	7852      	ldrb	r2, [r2, #1]
 8000a26:	701a      	strb	r2, [r3, #0]
    const static uint8_t TableSize = sizeof(ATC_Table_Config_Module)/sizeof(ATC_Table_Config_Module[0]);
    if(TableIndex > TableSize)
 8000a28:	4b49      	ldr	r3, [pc, #292]	; (8000b50 <GSM_Config_Module+0x140>)
 8000a2a:	781b      	ldrb	r3, [r3, #0]
 8000a2c:	187a      	adds	r2, r7, r1
 8000a2e:	7812      	ldrb	r2, [r2, #0]
 8000a30:	429a      	cmp	r2, r3
 8000a32:	d900      	bls.n	8000a36 <GSM_Config_Module+0x26>
 8000a34:	e085      	b.n	8000b42 <GSM_Config_Module+0x132>
    {
        return;
    }
    DEBUG_PrintResult_ATC(ATC_Table_Config_Module[TableIndex-1].cmd, (event == GSM_EVENT_OK)?"[OK]":"[FAIL]");
 8000a36:	187b      	adds	r3, r7, r1
 8000a38:	781b      	ldrb	r3, [r3, #0]
 8000a3a:	1e5a      	subs	r2, r3, #1
 8000a3c:	4b45      	ldr	r3, [pc, #276]	; (8000b54 <GSM_Config_Module+0x144>)
 8000a3e:	0152      	lsls	r2, r2, #5
 8000a40:	58d2      	ldr	r2, [r2, r3]
 8000a42:	1dfb      	adds	r3, r7, #7
 8000a44:	781b      	ldrb	r3, [r3, #0]
 8000a46:	2b00      	cmp	r3, #0
 8000a48:	d101      	bne.n	8000a4e <GSM_Config_Module+0x3e>
 8000a4a:	4b43      	ldr	r3, [pc, #268]	; (8000b58 <GSM_Config_Module+0x148>)
 8000a4c:	e000      	b.n	8000a50 <GSM_Config_Module+0x40>
 8000a4e:	4b43      	ldr	r3, [pc, #268]	; (8000b5c <GSM_Config_Module+0x14c>)
 8000a50:	0019      	movs	r1, r3
 8000a52:	0010      	movs	r0, r2
 8000a54:	f001 fd72 	bl	800253c <DEBUG_PrintResult_ATC>
    if(event == GSM_EVENT_OK)
 8000a58:	1dfb      	adds	r3, r7, #7
 8000a5a:	781b      	ldrb	r3, [r3, #0]
 8000a5c:	2b00      	cmp	r3, #0
 8000a5e:	d16c      	bne.n	8000b3a <GSM_Config_Module+0x12a>
    {
        if(TableIndex < TableSize)
 8000a60:	4b3b      	ldr	r3, [pc, #236]	; (8000b50 <GSM_Config_Module+0x140>)
 8000a62:	781b      	ldrb	r3, [r3, #0]
 8000a64:	210f      	movs	r1, #15
 8000a66:	187a      	adds	r2, r7, r1
 8000a68:	7812      	ldrb	r2, [r2, #0]
 8000a6a:	429a      	cmp	r2, r3
 8000a6c:	d215      	bcs.n	8000a9a <GSM_Config_Module+0x8a>
        {
        	//HAL_Delay(2000);
            GSM_SendCommand_AT(ATC_Table_Config_Module[TableIndex]);
 8000a6e:	187b      	adds	r3, r7, r1
 8000a70:	781b      	ldrb	r3, [r3, #0]
 8000a72:	4c38      	ldr	r4, [pc, #224]	; (8000b54 <GSM_Config_Module+0x144>)
 8000a74:	015b      	lsls	r3, r3, #5
 8000a76:	2110      	movs	r1, #16
 8000a78:	18e2      	adds	r2, r4, r3
 8000a7a:	1851      	adds	r1, r2, r1
 8000a7c:	466a      	mov	r2, sp
 8000a7e:	c961      	ldmia	r1!, {r0, r5, r6}
 8000a80:	c261      	stmia	r2!, {r0, r5, r6}
 8000a82:	6809      	ldr	r1, [r1, #0]
 8000a84:	6011      	str	r1, [r2, #0]
 8000a86:	5918      	ldr	r0, [r3, r4]
 8000a88:	18e2      	adds	r2, r4, r3
 8000a8a:	6851      	ldr	r1, [r2, #4]
 8000a8c:	18e2      	adds	r2, r4, r3
 8000a8e:	6892      	ldr	r2, [r2, #8]
 8000a90:	18e3      	adds	r3, r4, r3
 8000a92:	68db      	ldr	r3, [r3, #12]
 8000a94:	f000 ff84 	bl	80019a0 <GSM_SendCommand_AT>
 8000a98:	e048      	b.n	8000b2c <GSM_Config_Module+0x11c>
        }
        else
        {
            // Da Config Module xong
            GSM_Manager.step = 0;
 8000a9a:	4b2c      	ldr	r3, [pc, #176]	; (8000b4c <GSM_Config_Module+0x13c>)
 8000a9c:	2200      	movs	r2, #0
 8000a9e:	705a      	strb	r2, [r3, #1]
            DEBUG_INFO("Config module DONE.\r\n");
 8000aa0:	f01c f844 	bl	801cb2c <sys_get_tick_ms>
 8000aa4:	0001      	movs	r1, r0
 8000aa6:	4a2e      	ldr	r2, [pc, #184]	; (8000b60 <GSM_Config_Module+0x150>)
 8000aa8:	4b2e      	ldr	r3, [pc, #184]	; (8000b64 <GSM_Config_Module+0x154>)
 8000aaa:	0018      	movs	r0, r3
 8000aac:	f001 ff16 	bl	80028dc <app_debug_rtt_raw>
            //GSM_SendCommand_AT(ATC_Table_open_ppp_stack[0]);
            /* Set up File Send*/
            Multi_FileSendCfg.NumberFile = 3;
 8000ab0:	4b2d      	ldr	r3, [pc, #180]	; (8000b68 <GSM_Config_Module+0x158>)
 8000ab2:	22c8      	movs	r2, #200	; 0xc8
 8000ab4:	2103      	movs	r1, #3
 8000ab6:	5499      	strb	r1, [r3, r2]
            Multi_FileSendCfg.File[0].Name = "test1.txt";
 8000ab8:	4b2b      	ldr	r3, [pc, #172]	; (8000b68 <GSM_Config_Module+0x158>)
 8000aba:	4a2c      	ldr	r2, [pc, #176]	; (8000b6c <GSM_Config_Module+0x15c>)
 8000abc:	609a      	str	r2, [r3, #8]
            Multi_FileSendCfg.File[0].Data = "\r\nHello World!!! File1\r\n";
 8000abe:	4b2a      	ldr	r3, [pc, #168]	; (8000b68 <GSM_Config_Module+0x158>)
 8000ac0:	4a2b      	ldr	r2, [pc, #172]	; (8000b70 <GSM_Config_Module+0x160>)
 8000ac2:	601a      	str	r2, [r3, #0]
            Multi_FileSendCfg.File[0].DataLength = strlen(Multi_FileSendCfg.File[0].Data);
 8000ac4:	4b28      	ldr	r3, [pc, #160]	; (8000b68 <GSM_Config_Module+0x158>)
 8000ac6:	681b      	ldr	r3, [r3, #0]
 8000ac8:	0018      	movs	r0, r3
 8000aca:	f7ff fb1d 	bl	8000108 <strlen>
 8000ace:	0003      	movs	r3, r0
 8000ad0:	b29a      	uxth	r2, r3
 8000ad2:	4b25      	ldr	r3, [pc, #148]	; (8000b68 <GSM_Config_Module+0x158>)
 8000ad4:	809a      	strh	r2, [r3, #4]
            Multi_FileSendCfg.File[0].Directory = "/Test/";
 8000ad6:	4b24      	ldr	r3, [pc, #144]	; (8000b68 <GSM_Config_Module+0x158>)
 8000ad8:	4a26      	ldr	r2, [pc, #152]	; (8000b74 <GSM_Config_Module+0x164>)
 8000ada:	60da      	str	r2, [r3, #12]

            Multi_FileSendCfg.File[1].Name = "test2.txt";
 8000adc:	4b22      	ldr	r3, [pc, #136]	; (8000b68 <GSM_Config_Module+0x158>)
 8000ade:	4a26      	ldr	r2, [pc, #152]	; (8000b78 <GSM_Config_Module+0x168>)
 8000ae0:	61da      	str	r2, [r3, #28]
            Multi_FileSendCfg.File[1].Data = "\r\nHello World!!! File2\r\n";
 8000ae2:	4b21      	ldr	r3, [pc, #132]	; (8000b68 <GSM_Config_Module+0x158>)
 8000ae4:	4a25      	ldr	r2, [pc, #148]	; (8000b7c <GSM_Config_Module+0x16c>)
 8000ae6:	615a      	str	r2, [r3, #20]
            Multi_FileSendCfg.File[1].DataLength = strlen(Multi_FileSendCfg.File[1].Data);
 8000ae8:	4b1f      	ldr	r3, [pc, #124]	; (8000b68 <GSM_Config_Module+0x158>)
 8000aea:	695b      	ldr	r3, [r3, #20]
 8000aec:	0018      	movs	r0, r3
 8000aee:	f7ff fb0b 	bl	8000108 <strlen>
 8000af2:	0003      	movs	r3, r0
 8000af4:	b29a      	uxth	r2, r3
 8000af6:	4b1c      	ldr	r3, [pc, #112]	; (8000b68 <GSM_Config_Module+0x158>)
 8000af8:	831a      	strh	r2, [r3, #24]
            Multi_FileSendCfg.File[1].Directory = "/Test/";
 8000afa:	4b1b      	ldr	r3, [pc, #108]	; (8000b68 <GSM_Config_Module+0x158>)
 8000afc:	4a1d      	ldr	r2, [pc, #116]	; (8000b74 <GSM_Config_Module+0x164>)
 8000afe:	621a      	str	r2, [r3, #32]

            Multi_FileSendCfg.File[2].Name = "test3.txt";
 8000b00:	4b19      	ldr	r3, [pc, #100]	; (8000b68 <GSM_Config_Module+0x158>)
 8000b02:	4a1f      	ldr	r2, [pc, #124]	; (8000b80 <GSM_Config_Module+0x170>)
 8000b04:	631a      	str	r2, [r3, #48]	; 0x30
            Multi_FileSendCfg.File[2].Data = "\r\nHello World!!! File3\r\n";
 8000b06:	4b18      	ldr	r3, [pc, #96]	; (8000b68 <GSM_Config_Module+0x158>)
 8000b08:	4a1e      	ldr	r2, [pc, #120]	; (8000b84 <GSM_Config_Module+0x174>)
 8000b0a:	629a      	str	r2, [r3, #40]	; 0x28
            Multi_FileSendCfg.File[2].DataLength = strlen(Multi_FileSendCfg.File[2].Data);
 8000b0c:	4b16      	ldr	r3, [pc, #88]	; (8000b68 <GSM_Config_Module+0x158>)
 8000b0e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8000b10:	0018      	movs	r0, r3
 8000b12:	f7ff faf9 	bl	8000108 <strlen>
 8000b16:	0003      	movs	r3, r0
 8000b18:	b29a      	uxth	r2, r3
 8000b1a:	4b13      	ldr	r3, [pc, #76]	; (8000b68 <GSM_Config_Module+0x158>)
 8000b1c:	859a      	strh	r2, [r3, #44]	; 0x2c
            Multi_FileSendCfg.File[2].Directory = "/Test/";
 8000b1e:	4b12      	ldr	r3, [pc, #72]	; (8000b68 <GSM_Config_Module+0x158>)
 8000b20:	4a14      	ldr	r2, [pc, #80]	; (8000b74 <GSM_Config_Module+0x164>)
 8000b22:	635a      	str	r2, [r3, #52]	; 0x34

            GSM_Send_File(&Multi_FileSendCfg);
 8000b24:	4b10      	ldr	r3, [pc, #64]	; (8000b68 <GSM_Config_Module+0x158>)
 8000b26:	0018      	movs	r0, r3
 8000b28:	f001 fbfe 	bl	8002328 <GSM_Send_File>
        }
        GSM_Manager.step++;
 8000b2c:	4b07      	ldr	r3, [pc, #28]	; (8000b4c <GSM_Config_Module+0x13c>)
 8000b2e:	785b      	ldrb	r3, [r3, #1]
 8000b30:	3301      	adds	r3, #1
 8000b32:	b2da      	uxtb	r2, r3
 8000b34:	4b05      	ldr	r3, [pc, #20]	; (8000b4c <GSM_Config_Module+0x13c>)
 8000b36:	705a      	strb	r2, [r3, #1]
 8000b38:	e004      	b.n	8000b44 <GSM_Config_Module+0x134>
    }
    else //if(event == GSM_EVENT_TIMEOUT)
    {
        GSM_Manager_ChangeState(GSM_STATE_RESET);
 8000b3a:	2001      	movs	r0, #1
 8000b3c:	f000 fbf6 	bl	800132c <GSM_Manager_ChangeState>
 8000b40:	e000      	b.n	8000b44 <GSM_Config_Module+0x134>
        return;
 8000b42:	46c0      	nop			; (mov r8, r8)
    }
}
 8000b44:	46bd      	mov	sp, r7
 8000b46:	b005      	add	sp, #20
 8000b48:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000b4a:	46c0      	nop			; (mov r8, r8)
 8000b4c:	20001c1c 	.word	0x20001c1c
 8000b50:	08022140 	.word	0x08022140
 8000b54:	08021d58 	.word	0x08021d58
 8000b58:	0801d8c0 	.word	0x0801d8c0
 8000b5c:	0801d8c8 	.word	0x0801d8c8
 8000b60:	0801d770 	.word	0x0801d770
 8000b64:	0801d8d0 	.word	0x0801d8d0
 8000b68:	200000d8 	.word	0x200000d8
 8000b6c:	0801d900 	.word	0x0801d900
 8000b70:	0801d90c 	.word	0x0801d90c
 8000b74:	0801d928 	.word	0x0801d928
 8000b78:	0801d930 	.word	0x0801d930
 8000b7c:	0801d93c 	.word	0x0801d93c
 8000b80:	0801d958 	.word	0x0801d958
 8000b84:	0801d964 	.word	0x0801d964

08000b88 <open_ppp_stack>:
void open_ppp_stack(GSM_Response_Event_TypDef event, void *Resp_Buffer)
{
 8000b88:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000b8a:	b089      	sub	sp, #36	; 0x24
 8000b8c:	af04      	add	r7, sp, #16
 8000b8e:	0002      	movs	r2, r0
 8000b90:	6039      	str	r1, [r7, #0]
 8000b92:	1dfb      	adds	r3, r7, #7
 8000b94:	701a      	strb	r2, [r3, #0]
    DEBUG_INFO("Open PPP stack step %d\r\n", GSM_Manager.step);
 8000b96:	f01b ffc9 	bl	801cb2c <sys_get_tick_ms>
 8000b9a:	0001      	movs	r1, r0
 8000b9c:	4b40      	ldr	r3, [pc, #256]	; (8000ca0 <open_ppp_stack+0x118>)
 8000b9e:	785b      	ldrb	r3, [r3, #1]
 8000ba0:	4a40      	ldr	r2, [pc, #256]	; (8000ca4 <open_ppp_stack+0x11c>)
 8000ba2:	4841      	ldr	r0, [pc, #260]	; (8000ca8 <open_ppp_stack+0x120>)
 8000ba4:	f001 fe9a 	bl	80028dc <app_debug_rtt_raw>
    uint8_t TableIndex = GSM_Manager.step;
 8000ba8:	210f      	movs	r1, #15
 8000baa:	187b      	adds	r3, r7, r1
 8000bac:	4a3c      	ldr	r2, [pc, #240]	; (8000ca0 <open_ppp_stack+0x118>)
 8000bae:	7852      	ldrb	r2, [r2, #1]
 8000bb0:	701a      	strb	r2, [r3, #0]
    const static uint8_t TableSize = sizeof(ATC_Table_open_ppp_stack)/sizeof(ATC_Table_open_ppp_stack[0]);
    if(TableIndex > TableSize)
 8000bb2:	4b3e      	ldr	r3, [pc, #248]	; (8000cac <open_ppp_stack+0x124>)
 8000bb4:	781b      	ldrb	r3, [r3, #0]
 8000bb6:	187a      	adds	r2, r7, r1
 8000bb8:	7812      	ldrb	r2, [r2, #0]
 8000bba:	429a      	cmp	r2, r3
 8000bbc:	d86c      	bhi.n	8000c98 <open_ppp_stack+0x110>
    {
        return;
    }
    DEBUG_PrintResult_ATC(ATC_Table_open_ppp_stack[TableIndex-1].cmd, (event == GSM_EVENT_OK)?"[OK]":"[FAIL]");
 8000bbe:	187b      	adds	r3, r7, r1
 8000bc0:	781b      	ldrb	r3, [r3, #0]
 8000bc2:	1e5a      	subs	r2, r3, #1
 8000bc4:	4b3a      	ldr	r3, [pc, #232]	; (8000cb0 <open_ppp_stack+0x128>)
 8000bc6:	0152      	lsls	r2, r2, #5
 8000bc8:	58d2      	ldr	r2, [r2, r3]
 8000bca:	1dfb      	adds	r3, r7, #7
 8000bcc:	781b      	ldrb	r3, [r3, #0]
 8000bce:	2b00      	cmp	r3, #0
 8000bd0:	d101      	bne.n	8000bd6 <open_ppp_stack+0x4e>
 8000bd2:	4b38      	ldr	r3, [pc, #224]	; (8000cb4 <open_ppp_stack+0x12c>)
 8000bd4:	e000      	b.n	8000bd8 <open_ppp_stack+0x50>
 8000bd6:	4b38      	ldr	r3, [pc, #224]	; (8000cb8 <open_ppp_stack+0x130>)
 8000bd8:	0019      	movs	r1, r3
 8000bda:	0010      	movs	r0, r2
 8000bdc:	f001 fcae 	bl	800253c <DEBUG_PrintResult_ATC>
    if(event == GSM_EVENT_OK)
 8000be0:	1dfb      	adds	r3, r7, #7
 8000be2:	781b      	ldrb	r3, [r3, #0]
 8000be4:	2b00      	cmp	r3, #0
 8000be6:	d153      	bne.n	8000c90 <open_ppp_stack+0x108>
    {
        if(TableIndex < TableSize)
 8000be8:	4b30      	ldr	r3, [pc, #192]	; (8000cac <open_ppp_stack+0x124>)
 8000bea:	781b      	ldrb	r3, [r3, #0]
 8000bec:	210f      	movs	r1, #15
 8000bee:	187a      	adds	r2, r7, r1
 8000bf0:	7812      	ldrb	r2, [r2, #0]
 8000bf2:	429a      	cmp	r2, r3
 8000bf4:	d215      	bcs.n	8000c22 <open_ppp_stack+0x9a>
        {
            GSM_SendCommand_AT(ATC_Table_open_ppp_stack[TableIndex]);
 8000bf6:	187b      	adds	r3, r7, r1
 8000bf8:	781b      	ldrb	r3, [r3, #0]
 8000bfa:	4c2d      	ldr	r4, [pc, #180]	; (8000cb0 <open_ppp_stack+0x128>)
 8000bfc:	015b      	lsls	r3, r3, #5
 8000bfe:	2110      	movs	r1, #16
 8000c00:	18e2      	adds	r2, r4, r3
 8000c02:	1851      	adds	r1, r2, r1
 8000c04:	466a      	mov	r2, sp
 8000c06:	c961      	ldmia	r1!, {r0, r5, r6}
 8000c08:	c261      	stmia	r2!, {r0, r5, r6}
 8000c0a:	6809      	ldr	r1, [r1, #0]
 8000c0c:	6011      	str	r1, [r2, #0]
 8000c0e:	5918      	ldr	r0, [r3, r4]
 8000c10:	18e2      	adds	r2, r4, r3
 8000c12:	6851      	ldr	r1, [r2, #4]
 8000c14:	18e2      	adds	r2, r4, r3
 8000c16:	6892      	ldr	r2, [r2, #8]
 8000c18:	18e3      	adds	r3, r4, r3
 8000c1a:	68db      	ldr	r3, [r3, #12]
 8000c1c:	f000 fec0 	bl	80019a0 <GSM_SendCommand_AT>
 8000c20:	e02f      	b.n	8000c82 <open_ppp_stack+0xfa>
        }
        else
        {
            GSM_Manager.mode = GSM_INTERNET_MODE_PPP_STACK;
 8000c22:	4b1f      	ldr	r3, [pc, #124]	; (8000ca0 <open_ppp_stack+0x118>)
 8000c24:	2201      	movs	r2, #1
 8000c26:	709a      	strb	r2, [r3, #2]
            // Da CONNECT PPP thanh cong
            GSM_Manager_ChangeState(GSM_STATE_OK);
 8000c28:	2002      	movs	r0, #2
 8000c2a:	f000 fb7f 	bl	800132c <GSM_Manager_ChangeState>

            //Create PPP connection
            m_ppp_control_block = pppos_create(&m_ppp_netif, ppp_output_callback, ppp_link_status_cb, NULL);
 8000c2e:	4a23      	ldr	r2, [pc, #140]	; (8000cbc <open_ppp_stack+0x134>)
 8000c30:	4923      	ldr	r1, [pc, #140]	; (8000cc0 <open_ppp_stack+0x138>)
 8000c32:	4824      	ldr	r0, [pc, #144]	; (8000cc4 <open_ppp_stack+0x13c>)
 8000c34:	2300      	movs	r3, #0
 8000c36:	f019 fb11 	bl	801a25c <pppos_create>
 8000c3a:	0002      	movs	r2, r0
 8000c3c:	4b22      	ldr	r3, [pc, #136]	; (8000cc8 <open_ppp_stack+0x140>)
 8000c3e:	601a      	str	r2, [r3, #0]
            if (m_ppp_control_block == NULL)
 8000c40:	4b21      	ldr	r3, [pc, #132]	; (8000cc8 <open_ppp_stack+0x140>)
 8000c42:	681b      	ldr	r3, [r3, #0]
 8000c44:	2b00      	cmp	r3, #0
 8000c46:	d109      	bne.n	8000c5c <open_ppp_stack+0xd4>
            {
                DEBUG_ERROR("Create PPP interface ERR!\r\n");
 8000c48:	f01b ff70 	bl	801cb2c <sys_get_tick_ms>
 8000c4c:	0001      	movs	r1, r0
 8000c4e:	4a15      	ldr	r2, [pc, #84]	; (8000ca4 <open_ppp_stack+0x11c>)
 8000c50:	4b1e      	ldr	r3, [pc, #120]	; (8000ccc <open_ppp_stack+0x144>)
 8000c52:	0018      	movs	r0, r3
 8000c54:	f001 fe42 	bl	80028dc <app_debug_rtt_raw>
                //assert(0);
                // TODO handle memory error
                NVIC_SystemReset();
 8000c58:	f7ff fec8 	bl	80009ec <__NVIC_SystemReset>
            }

            /* Set this interface as default route */
            ppp_set_default(m_ppp_control_block);
 8000c5c:	4b1a      	ldr	r3, [pc, #104]	; (8000cc8 <open_ppp_stack+0x140>)
 8000c5e:	681b      	ldr	r3, [r3, #0]
 8000c60:	6a1b      	ldr	r3, [r3, #32]
 8000c62:	0018      	movs	r0, r3
 8000c64:	f008 faf6 	bl	8009254 <netif_set_default>
            //ppp_set_auth(m_ppp_control_block, PPPAUTHTYPE_CHAP, "", "");
            ppp_set_notify_phase_callback(m_ppp_control_block, ppp_notify_phase_cb);
 8000c68:	4b17      	ldr	r3, [pc, #92]	; (8000cc8 <open_ppp_stack+0x140>)
 8000c6a:	681b      	ldr	r3, [r3, #0]
 8000c6c:	4a18      	ldr	r2, [pc, #96]	; (8000cd0 <open_ppp_stack+0x148>)
 8000c6e:	0011      	movs	r1, r2
 8000c70:	0018      	movs	r0, r3
 8000c72:	f018 fe4f 	bl	8019914 <ppp_set_notify_phase_callback>
            ppp_connect(m_ppp_control_block, 0);
 8000c76:	4b14      	ldr	r3, [pc, #80]	; (8000cc8 <open_ppp_stack+0x140>)
 8000c78:	681b      	ldr	r3, [r3, #0]
 8000c7a:	2100      	movs	r1, #0
 8000c7c:	0018      	movs	r0, r3
 8000c7e:	f018 fe5d 	bl	801993c <ppp_connect>
        }
        GSM_Manager.step++;
 8000c82:	4b07      	ldr	r3, [pc, #28]	; (8000ca0 <open_ppp_stack+0x118>)
 8000c84:	785b      	ldrb	r3, [r3, #1]
 8000c86:	3301      	adds	r3, #1
 8000c88:	b2da      	uxtb	r2, r3
 8000c8a:	4b05      	ldr	r3, [pc, #20]	; (8000ca0 <open_ppp_stack+0x118>)
 8000c8c:	705a      	strb	r2, [r3, #1]
 8000c8e:	e004      	b.n	8000c9a <open_ppp_stack+0x112>
    }
    else //if(event == GSM_EVENT_TIMEOUT)
    {
        // Handle ERROR
        GSM_Manager_ChangeState(GSM_STATE_RESET);
 8000c90:	2001      	movs	r0, #1
 8000c92:	f000 fb4b 	bl	800132c <GSM_Manager_ChangeState>
 8000c96:	e000      	b.n	8000c9a <open_ppp_stack+0x112>
        return;
 8000c98:	46c0      	nop			; (mov r8, r8)
    }
}
 8000c9a:	46bd      	mov	sp, r7
 8000c9c:	b005      	add	sp, #20
 8000c9e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000ca0:	20001c1c 	.word	0x20001c1c
 8000ca4:	0801d770 	.word	0x0801d770
 8000ca8:	0801d980 	.word	0x0801d980
 8000cac:	08022141 	.word	0x08022141
 8000cb0:	08022058 	.word	0x08022058
 8000cb4:	0801d8c0 	.word	0x0801d8c0
 8000cb8:	0801d8c8 	.word	0x0801d8c8
 8000cbc:	08000fdd 	.word	0x08000fdd
 8000cc0:	08000f05 	.word	0x08000f05
 8000cc4:	200001a4 	.word	0x200001a4
 8000cc8:	200001e0 	.word	0x200001e0
 8000ccc:	0801d9b4 	.word	0x0801d9b4
 8000cd0:	08000de1 	.word	0x08000de1

08000cd4 <GSM_GET_IMEI_Buffer>:
void GSM_GET_IMEI_Buffer(GSM_Response_Event_TypDef event, void *Resp_Buffer)
{
 8000cd4:	b580      	push	{r7, lr}
 8000cd6:	b082      	sub	sp, #8
 8000cd8:	af00      	add	r7, sp, #0
 8000cda:	0002      	movs	r2, r0
 8000cdc:	6039      	str	r1, [r7, #0]
 8000cde:	1dfb      	adds	r3, r7, #7
 8000ce0:	701a      	strb	r2, [r3, #0]
    if(event != GSM_EVENT_OK)
 8000ce2:	1dfb      	adds	r3, r7, #7
 8000ce4:	781b      	ldrb	r3, [r3, #0]
 8000ce6:	2b00      	cmp	r3, #0
 8000ce8:	d007      	beq.n	8000cfa <GSM_GET_IMEI_Buffer+0x26>
    {
        GSM_Config_Module(event, &Resp_Buffer);
 8000cea:	003a      	movs	r2, r7
 8000cec:	1dfb      	adds	r3, r7, #7
 8000cee:	781b      	ldrb	r3, [r3, #0]
 8000cf0:	0011      	movs	r1, r2
 8000cf2:	0018      	movs	r0, r3
 8000cf4:	f7ff fe8c 	bl	8000a10 <GSM_Config_Module>
 8000cf8:	e02e      	b.n	8000d58 <GSM_GET_IMEI_Buffer+0x84>
    }
    else
    {
        if(strlen((char*)GSM_IMEI_Buffer) < 14)
 8000cfa:	4b19      	ldr	r3, [pc, #100]	; (8000d60 <GSM_GET_IMEI_Buffer+0x8c>)
 8000cfc:	0018      	movs	r0, r3
 8000cfe:	f7ff fa03 	bl	8000108 <strlen>
 8000d02:	0003      	movs	r3, r0
 8000d04:	2b0d      	cmp	r3, #13
 8000d06:	d820      	bhi.n	8000d4a <GSM_GET_IMEI_Buffer+0x76>
        {
            GSM_Utilities_Get_IMEI(Resp_Buffer, GSM_IMEI_Buffer, 16);
 8000d08:	683b      	ldr	r3, [r7, #0]
 8000d0a:	4915      	ldr	r1, [pc, #84]	; (8000d60 <GSM_GET_IMEI_Buffer+0x8c>)
 8000d0c:	2210      	movs	r2, #16
 8000d0e:	0018      	movs	r0, r3
 8000d10:	f001 fb38 	bl	8002384 <GSM_Utilities_Get_IMEI>
            if(strlen((char*)GSM_IMEI_Buffer) < 15)
 8000d14:	4b12      	ldr	r3, [pc, #72]	; (8000d60 <GSM_GET_IMEI_Buffer+0x8c>)
 8000d16:	0018      	movs	r0, r3
 8000d18:	f7ff f9f6 	bl	8000108 <strlen>
 8000d1c:	0003      	movs	r3, r0
 8000d1e:	2b0e      	cmp	r3, #14
 8000d20:	d80b      	bhi.n	8000d3a <GSM_GET_IMEI_Buffer+0x66>
            {
                DEBUG_WARN("IMEI's invalid!\r\n");
 8000d22:	f01b ff03 	bl	801cb2c <sys_get_tick_ms>
 8000d26:	0001      	movs	r1, r0
 8000d28:	4a0e      	ldr	r2, [pc, #56]	; (8000d64 <GSM_GET_IMEI_Buffer+0x90>)
 8000d2a:	4b0f      	ldr	r3, [pc, #60]	; (8000d68 <GSM_GET_IMEI_Buffer+0x94>)
 8000d2c:	0018      	movs	r0, r3
 8000d2e:	f001 fdd5 	bl	80028dc <app_debug_rtt_raw>
                GSM_Manager_ChangeState(GSM_STATE_RESET); // Cant get GSM imei, maybe gsm module error =>> Restart module
 8000d32:	2001      	movs	r0, #1
 8000d34:	f000 fafa 	bl	800132c <GSM_Manager_ChangeState>
                return;
 8000d38:	e00e      	b.n	8000d58 <GSM_GET_IMEI_Buffer+0x84>
            }
            else
            {
                DEBUG_INFO("GSM IMEI: %s\r\n", GSM_IMEI_Buffer);
 8000d3a:	f01b fef7 	bl	801cb2c <sys_get_tick_ms>
 8000d3e:	0001      	movs	r1, r0
 8000d40:	4b07      	ldr	r3, [pc, #28]	; (8000d60 <GSM_GET_IMEI_Buffer+0x8c>)
 8000d42:	4a08      	ldr	r2, [pc, #32]	; (8000d64 <GSM_GET_IMEI_Buffer+0x90>)
 8000d44:	4809      	ldr	r0, [pc, #36]	; (8000d6c <GSM_GET_IMEI_Buffer+0x98>)
 8000d46:	f001 fdc9 	bl	80028dc <app_debug_rtt_raw>
            }
        }
        GSM_Config_Module(event, &Resp_Buffer);
 8000d4a:	003a      	movs	r2, r7
 8000d4c:	1dfb      	adds	r3, r7, #7
 8000d4e:	781b      	ldrb	r3, [r3, #0]
 8000d50:	0011      	movs	r1, r2
 8000d52:	0018      	movs	r0, r3
 8000d54:	f7ff fe5c 	bl	8000a10 <GSM_Config_Module>
    }
}
 8000d58:	46bd      	mov	sp, r7
 8000d5a:	b002      	add	sp, #8
 8000d5c:	bd80      	pop	{r7, pc}
 8000d5e:	46c0      	nop			; (mov r8, r8)
 8000d60:	200000c0 	.word	0x200000c0
 8000d64:	0801d770 	.word	0x0801d770
 8000d68:	0801d9ec 	.word	0x0801d9ec
 8000d6c:	0801da18 	.word	0x0801da18

08000d70 <GSM_GET_Signal_Strength>:
void GSM_GET_Signal_Strength(GSM_Response_Event_TypDef event, void *Resp_Buffer)
{
 8000d70:	b580      	push	{r7, lr}
 8000d72:	b082      	sub	sp, #8
 8000d74:	af00      	add	r7, sp, #0
 8000d76:	0002      	movs	r2, r0
 8000d78:	6039      	str	r1, [r7, #0]
 8000d7a:	1dfb      	adds	r3, r7, #7
 8000d7c:	701a      	strb	r2, [r3, #0]
    
    if(event != GSM_EVENT_OK)
 8000d7e:	1dfb      	adds	r3, r7, #7
 8000d80:	781b      	ldrb	r3, [r3, #0]
 8000d82:	2b00      	cmp	r3, #0
 8000d84:	d007      	beq.n	8000d96 <GSM_GET_Signal_Strength+0x26>
    {
        GSM_Config_Module(event, &Resp_Buffer);
 8000d86:	003a      	movs	r2, r7
 8000d88:	1dfb      	adds	r3, r7, #7
 8000d8a:	781b      	ldrb	r3, [r3, #0]
 8000d8c:	0011      	movs	r1, r2
 8000d8e:	0018      	movs	r0, r3
 8000d90:	f7ff fe3e 	bl	8000a10 <GSM_Config_Module>
            gsm_utilities_get_signal_strength_from_buffer(Resp_Buffer, &GSM_Signal_Strength);
            DEBUG_INFO("GSM Signal strength: %d\r\n", GSM_Signal_Strength);
        }
        GSM_Config_Module(event, &Resp_Buffer);
    }
}
 8000d94:	e019      	b.n	8000dca <GSM_GET_Signal_Strength+0x5a>
        if(GSM_Signal_Strength == 0)
 8000d96:	4b0f      	ldr	r3, [pc, #60]	; (8000dd4 <GSM_GET_Signal_Strength+0x64>)
 8000d98:	881b      	ldrh	r3, [r3, #0]
 8000d9a:	2b00      	cmp	r3, #0
 8000d9c:	d10e      	bne.n	8000dbc <GSM_GET_Signal_Strength+0x4c>
            gsm_utilities_get_signal_strength_from_buffer(Resp_Buffer, &GSM_Signal_Strength);
 8000d9e:	683b      	ldr	r3, [r7, #0]
 8000da0:	4a0c      	ldr	r2, [pc, #48]	; (8000dd4 <GSM_GET_Signal_Strength+0x64>)
 8000da2:	0011      	movs	r1, r2
 8000da4:	0018      	movs	r0, r3
 8000da6:	f001 fb31 	bl	800240c <gsm_utilities_get_signal_strength_from_buffer>
            DEBUG_INFO("GSM Signal strength: %d\r\n", GSM_Signal_Strength);
 8000daa:	f01b febf 	bl	801cb2c <sys_get_tick_ms>
 8000dae:	0001      	movs	r1, r0
 8000db0:	4b08      	ldr	r3, [pc, #32]	; (8000dd4 <GSM_GET_Signal_Strength+0x64>)
 8000db2:	881b      	ldrh	r3, [r3, #0]
 8000db4:	4a08      	ldr	r2, [pc, #32]	; (8000dd8 <GSM_GET_Signal_Strength+0x68>)
 8000db6:	4809      	ldr	r0, [pc, #36]	; (8000ddc <GSM_GET_Signal_Strength+0x6c>)
 8000db8:	f001 fd90 	bl	80028dc <app_debug_rtt_raw>
        GSM_Config_Module(event, &Resp_Buffer);
 8000dbc:	003a      	movs	r2, r7
 8000dbe:	1dfb      	adds	r3, r7, #7
 8000dc0:	781b      	ldrb	r3, [r3, #0]
 8000dc2:	0011      	movs	r1, r2
 8000dc4:	0018      	movs	r0, r3
 8000dc6:	f7ff fe23 	bl	8000a10 <GSM_Config_Module>
}
 8000dca:	46c0      	nop			; (mov r8, r8)
 8000dcc:	46bd      	mov	sp, r7
 8000dce:	b002      	add	sp, #8
 8000dd0:	bd80      	pop	{r7, pc}
 8000dd2:	46c0      	nop			; (mov r8, r8)
 8000dd4:	200000d4 	.word	0x200000d4
 8000dd8:	0801d770 	.word	0x0801d770
 8000ddc:	0801da40 	.word	0x0801da40

08000de0 <ppp_notify_phase_cb>:
static void ppp_notify_phase_cb(ppp_pcb *pcb, u8_t phase, void *ctx)
{
 8000de0:	b580      	push	{r7, lr}
 8000de2:	b084      	sub	sp, #16
 8000de4:	af00      	add	r7, sp, #0
 8000de6:	60f8      	str	r0, [r7, #12]
 8000de8:	607a      	str	r2, [r7, #4]
 8000dea:	200b      	movs	r0, #11
 8000dec:	183b      	adds	r3, r7, r0
 8000dee:	1c0a      	adds	r2, r1, #0
 8000df0:	701a      	strb	r2, [r3, #0]
    switch (phase)
 8000df2:	183b      	adds	r3, r7, r0
 8000df4:	781b      	ldrb	r3, [r3, #0]
 8000df6:	2b0c      	cmp	r3, #12
 8000df8:	d85b      	bhi.n	8000eb2 <ppp_notify_phase_cb+0xd2>
 8000dfa:	009a      	lsls	r2, r3, #2
 8000dfc:	4b34      	ldr	r3, [pc, #208]	; (8000ed0 <ppp_notify_phase_cb+0xf0>)
 8000dfe:	18d3      	adds	r3, r2, r3
 8000e00:	681b      	ldr	r3, [r3, #0]
 8000e02:	469f      	mov	pc, r3
    {
    /* Session is down (either permanently or briefly) */
    case PPP_PHASE_DEAD:
        DEBUG_INFO("PPP_PHASE_DEAD\r\n");
 8000e04:	f01b fe92 	bl	801cb2c <sys_get_tick_ms>
 8000e08:	0001      	movs	r1, r0
 8000e0a:	4a32      	ldr	r2, [pc, #200]	; (8000ed4 <ppp_notify_phase_cb+0xf4>)
 8000e0c:	4b32      	ldr	r3, [pc, #200]	; (8000ed8 <ppp_notify_phase_cb+0xf8>)
 8000e0e:	0018      	movs	r0, r3
 8000e10:	f001 fd64 	bl	80028dc <app_debug_rtt_raw>
        GSM_Manager.ppp_phase = PPP_PHASE_DEAD;
 8000e14:	4b31      	ldr	r3, [pc, #196]	; (8000edc <ppp_notify_phase_cb+0xfc>)
 8000e16:	2200      	movs	r2, #0
 8000e18:	70da      	strb	r2, [r3, #3]
        break;
 8000e1a:	e055      	b.n	8000ec8 <ppp_notify_phase_cb+0xe8>

    /* We are between two sessions */
    case PPP_PHASE_HOLDOFF:
        DEBUG_INFO("PPP_PHASE_HOLDOFF\r\n");
 8000e1c:	f01b fe86 	bl	801cb2c <sys_get_tick_ms>
 8000e20:	0001      	movs	r1, r0
 8000e22:	4a2c      	ldr	r2, [pc, #176]	; (8000ed4 <ppp_notify_phase_cb+0xf4>)
 8000e24:	4b2e      	ldr	r3, [pc, #184]	; (8000ee0 <ppp_notify_phase_cb+0x100>)
 8000e26:	0018      	movs	r0, r3
 8000e28:	f001 fd58 	bl	80028dc <app_debug_rtt_raw>
        GSM_Manager.ppp_phase = PPP_PHASE_HOLDOFF;
 8000e2c:	4b2b      	ldr	r3, [pc, #172]	; (8000edc <ppp_notify_phase_cb+0xfc>)
 8000e2e:	2202      	movs	r2, #2
 8000e30:	70da      	strb	r2, [r3, #3]
        break;
 8000e32:	e049      	b.n	8000ec8 <ppp_notify_phase_cb+0xe8>

    /* Session just started */
    case PPP_PHASE_INITIALIZE:
        DEBUG_INFO("PPP_PHASE_INITIALIZE\r\n");
 8000e34:	f01b fe7a 	bl	801cb2c <sys_get_tick_ms>
 8000e38:	0001      	movs	r1, r0
 8000e3a:	4a26      	ldr	r2, [pc, #152]	; (8000ed4 <ppp_notify_phase_cb+0xf4>)
 8000e3c:	4b29      	ldr	r3, [pc, #164]	; (8000ee4 <ppp_notify_phase_cb+0x104>)
 8000e3e:	0018      	movs	r0, r3
 8000e40:	f001 fd4c 	bl	80028dc <app_debug_rtt_raw>
        GSM_Manager.ppp_phase = PPP_PHASE_INITIALIZE;
 8000e44:	4b25      	ldr	r3, [pc, #148]	; (8000edc <ppp_notify_phase_cb+0xfc>)
 8000e46:	2203      	movs	r2, #3
 8000e48:	70da      	strb	r2, [r3, #3]
        break;
 8000e4a:	e03d      	b.n	8000ec8 <ppp_notify_phase_cb+0xe8>

    case PPP_PHASE_NETWORK:
        DEBUG_INFO("PPP_PHASE_NETWORK\r\n");
 8000e4c:	f01b fe6e 	bl	801cb2c <sys_get_tick_ms>
 8000e50:	0001      	movs	r1, r0
 8000e52:	4a20      	ldr	r2, [pc, #128]	; (8000ed4 <ppp_notify_phase_cb+0xf4>)
 8000e54:	4b24      	ldr	r3, [pc, #144]	; (8000ee8 <ppp_notify_phase_cb+0x108>)
 8000e56:	0018      	movs	r0, r3
 8000e58:	f001 fd40 	bl	80028dc <app_debug_rtt_raw>
        break;
 8000e5c:	e034      	b.n	8000ec8 <ppp_notify_phase_cb+0xe8>

    case PPP_PHASE_ESTABLISH:
        DEBUG_INFO("PPP_PHASE_ESTABLISH\r\n");
 8000e5e:	f01b fe65 	bl	801cb2c <sys_get_tick_ms>
 8000e62:	0001      	movs	r1, r0
 8000e64:	4a1b      	ldr	r2, [pc, #108]	; (8000ed4 <ppp_notify_phase_cb+0xf4>)
 8000e66:	4b21      	ldr	r3, [pc, #132]	; (8000eec <ppp_notify_phase_cb+0x10c>)
 8000e68:	0018      	movs	r0, r3
 8000e6a:	f001 fd37 	bl	80028dc <app_debug_rtt_raw>
        break;
 8000e6e:	e02b      	b.n	8000ec8 <ppp_notify_phase_cb+0xe8>

    /* Session is running */
    case PPP_PHASE_RUNNING:
        DEBUG_INFO("PPP_PHASE_RUNNING\r\n");
 8000e70:	f01b fe5c 	bl	801cb2c <sys_get_tick_ms>
 8000e74:	0001      	movs	r1, r0
 8000e76:	4a17      	ldr	r2, [pc, #92]	; (8000ed4 <ppp_notify_phase_cb+0xf4>)
 8000e78:	4b1d      	ldr	r3, [pc, #116]	; (8000ef0 <ppp_notify_phase_cb+0x110>)
 8000e7a:	0018      	movs	r0, r3
 8000e7c:	f001 fd2e 	bl	80028dc <app_debug_rtt_raw>
        GSM_Manager.ppp_phase = PPP_PHASE_RUNNING;
 8000e80:	4b16      	ldr	r3, [pc, #88]	; (8000edc <ppp_notify_phase_cb+0xfc>)
 8000e82:	220a      	movs	r2, #10
 8000e84:	70da      	strb	r2, [r3, #3]
        m_ppp_connected = true;
 8000e86:	4b1b      	ldr	r3, [pc, #108]	; (8000ef4 <ppp_notify_phase_cb+0x114>)
 8000e88:	2201      	movs	r2, #1
 8000e8a:	701a      	strb	r2, [r3, #0]
        break;
 8000e8c:	e01c      	b.n	8000ec8 <ppp_notify_phase_cb+0xe8>

    case PPP_PHASE_TERMINATE:
        DEBUG_INFO("PPP_PHASE_TERMINATE\r\n");
 8000e8e:	f01b fe4d 	bl	801cb2c <sys_get_tick_ms>
 8000e92:	0001      	movs	r1, r0
 8000e94:	4a0f      	ldr	r2, [pc, #60]	; (8000ed4 <ppp_notify_phase_cb+0xf4>)
 8000e96:	4b18      	ldr	r3, [pc, #96]	; (8000ef8 <ppp_notify_phase_cb+0x118>)
 8000e98:	0018      	movs	r0, r3
 8000e9a:	f001 fd1f 	bl	80028dc <app_debug_rtt_raw>
        break;
 8000e9e:	e013      	b.n	8000ec8 <ppp_notify_phase_cb+0xe8>

    case PPP_PHASE_DISCONNECT:
        DEBUG_INFO("PPP_PHASE_DISCONNECT\r\n");
 8000ea0:	f01b fe44 	bl	801cb2c <sys_get_tick_ms>
 8000ea4:	0001      	movs	r1, r0
 8000ea6:	4a0b      	ldr	r2, [pc, #44]	; (8000ed4 <ppp_notify_phase_cb+0xf4>)
 8000ea8:	4b14      	ldr	r3, [pc, #80]	; (8000efc <ppp_notify_phase_cb+0x11c>)
 8000eaa:	0018      	movs	r0, r3
 8000eac:	f001 fd16 	bl	80028dc <app_debug_rtt_raw>
        break;
 8000eb0:	e00a      	b.n	8000ec8 <ppp_notify_phase_cb+0xe8>

    default:
        DEBUG_INFO("Unknown PPP phase %d\r\n", phase);
 8000eb2:	f01b fe3b 	bl	801cb2c <sys_get_tick_ms>
 8000eb6:	0001      	movs	r1, r0
 8000eb8:	230b      	movs	r3, #11
 8000eba:	18fb      	adds	r3, r7, r3
 8000ebc:	781b      	ldrb	r3, [r3, #0]
 8000ebe:	4a05      	ldr	r2, [pc, #20]	; (8000ed4 <ppp_notify_phase_cb+0xf4>)
 8000ec0:	480f      	ldr	r0, [pc, #60]	; (8000f00 <ppp_notify_phase_cb+0x120>)
 8000ec2:	f001 fd0b 	bl	80028dc <app_debug_rtt_raw>
        break;
 8000ec6:	46c0      	nop			; (mov r8, r8)
    }
}
 8000ec8:	46c0      	nop			; (mov r8, r8)
 8000eca:	46bd      	mov	sp, r7
 8000ecc:	b004      	add	sp, #16
 8000ece:	bd80      	pop	{r7, pc}
 8000ed0:	080220d8 	.word	0x080220d8
 8000ed4:	0801d770 	.word	0x0801d770
 8000ed8:	0801da74 	.word	0x0801da74
 8000edc:	20001c1c 	.word	0x20001c1c
 8000ee0:	0801daa0 	.word	0x0801daa0
 8000ee4:	0801dad0 	.word	0x0801dad0
 8000ee8:	0801db00 	.word	0x0801db00
 8000eec:	0801db30 	.word	0x0801db30
 8000ef0:	0801db60 	.word	0x0801db60
 8000ef4:	200001e4 	.word	0x200001e4
 8000ef8:	0801db90 	.word	0x0801db90
 8000efc:	0801dbc0 	.word	0x0801dbc0
 8000f00:	0801dbf0 	.word	0x0801dbf0

08000f04 <ppp_output_callback>:
static uint32_t ppp_output_callback(ppp_pcb *pcb, u8_t *data, u32_t len, void *ctx)
{
 8000f04:	b580      	push	{r7, lr}
 8000f06:	b084      	sub	sp, #16
 8000f08:	af00      	add	r7, sp, #0
 8000f0a:	60f8      	str	r0, [r7, #12]
 8000f0c:	60b9      	str	r1, [r7, #8]
 8000f0e:	607a      	str	r2, [r7, #4]
 8000f10:	603b      	str	r3, [r7, #0]
    GSM_UART_TX( data, len, 1000);
 8000f12:	687b      	ldr	r3, [r7, #4]
 8000f14:	b29a      	uxth	r2, r3
 8000f16:	23fa      	movs	r3, #250	; 0xfa
 8000f18:	009b      	lsls	r3, r3, #2
 8000f1a:	68b9      	ldr	r1, [r7, #8]
 8000f1c:	4803      	ldr	r0, [pc, #12]	; (8000f2c <ppp_output_callback+0x28>)
 8000f1e:	f003 f8bd 	bl	800409c <HAL_UART_Transmit>
    return len;
 8000f22:	687b      	ldr	r3, [r7, #4]
}
 8000f24:	0018      	movs	r0, r3
 8000f26:	46bd      	mov	sp, r7
 8000f28:	b004      	add	sp, #16
 8000f2a:	bd80      	pop	{r7, pc}
 8000f2c:	20001b98 	.word	0x20001b98

08000f30 <gsm_data_layer_get_ppp_control_block>:
void *gsm_data_layer_get_ppp_control_block(void)
{
 8000f30:	b580      	push	{r7, lr}
 8000f32:	af00      	add	r7, sp, #0
    return m_ppp_control_block;
 8000f34:	4b02      	ldr	r3, [pc, #8]	; (8000f40 <gsm_data_layer_get_ppp_control_block+0x10>)
 8000f36:	681b      	ldr	r3, [r3, #0]
}
 8000f38:	0018      	movs	r0, r3
 8000f3a:	46bd      	mov	sp, r7
 8000f3c:	bd80      	pop	{r7, pc}
 8000f3e:	46c0      	nop			; (mov r8, r8)
 8000f40:	200001e0 	.word	0x200001e0

08000f44 <initialize_stnp>:
static void initialize_stnp(void)
{
 8000f44:	b580      	push	{r7, lr}
 8000f46:	af00      	add	r7, sp, #0
    static bool sntp_start = false;
    if (sntp_start == false)
 8000f48:	4b0f      	ldr	r3, [pc, #60]	; (8000f88 <initialize_stnp+0x44>)
 8000f4a:	781b      	ldrb	r3, [r3, #0]
 8000f4c:	2201      	movs	r2, #1
 8000f4e:	4053      	eors	r3, r2
 8000f50:	b2db      	uxtb	r3, r3
 8000f52:	2b00      	cmp	r3, #0
 8000f54:	d014      	beq.n	8000f80 <initialize_stnp+0x3c>
    {
        sntp_start = true;
 8000f56:	4b0c      	ldr	r3, [pc, #48]	; (8000f88 <initialize_stnp+0x44>)
 8000f58:	2201      	movs	r2, #1
 8000f5a:	701a      	strb	r2, [r3, #0]
        DEBUG_INFO("Initialize stnp\r\n");
 8000f5c:	f01b fde6 	bl	801cb2c <sys_get_tick_ms>
 8000f60:	0001      	movs	r1, r0
 8000f62:	4a0a      	ldr	r2, [pc, #40]	; (8000f8c <initialize_stnp+0x48>)
 8000f64:	4b0a      	ldr	r3, [pc, #40]	; (8000f90 <initialize_stnp+0x4c>)
 8000f66:	0018      	movs	r0, r3
 8000f68:	f001 fcb8 	bl	80028dc <app_debug_rtt_raw>
        sntp_setoperatingmode(SNTP_OPMODE_POLL);
 8000f6c:	2000      	movs	r0, #0
 8000f6e:	f005 fdff 	bl	8006b70 <sntp_setoperatingmode>
        sntp_setservername(0, "pool.ntp.org");
 8000f72:	4b08      	ldr	r3, [pc, #32]	; (8000f94 <initialize_stnp+0x50>)
 8000f74:	0019      	movs	r1, r3
 8000f76:	2000      	movs	r0, #0
 8000f78:	f005 fe2c 	bl	8006bd4 <sntp_setservername>
        sntp_init();
 8000f7c:	f005 fd92 	bl	8006aa4 <sntp_init>
    }
}
 8000f80:	46c0      	nop			; (mov r8, r8)
 8000f82:	46bd      	mov	sp, r7
 8000f84:	bd80      	pop	{r7, pc}
 8000f86:	46c0      	nop			; (mov r8, r8)
 8000f88:	200001e5 	.word	0x200001e5
 8000f8c:	0801d770 	.word	0x0801d770
 8000f90:	0801dc20 	.word	0x0801dc20
 8000f94:	0801dc4c 	.word	0x0801dc4c

08000f98 <lwip_sntp_recv_callback>:

void lwip_sntp_recv_callback(uint32_t time)
{
 8000f98:	b580      	push	{r7, lr}
 8000f9a:	b082      	sub	sp, #8
 8000f9c:	af00      	add	r7, sp, #0
 8000f9e:	6078      	str	r0, [r7, #4]
    if (time == 0)
 8000fa0:	687b      	ldr	r3, [r7, #4]
 8000fa2:	2b00      	cmp	r3, #0
 8000fa4:	d108      	bne.n	8000fb8 <lwip_sntp_recv_callback+0x20>
    {
        DEBUG_WARN("NTP: Error, server not responding or bad response\r\n");
 8000fa6:	f01b fdc1 	bl	801cb2c <sys_get_tick_ms>
 8000faa:	0001      	movs	r1, r0
 8000fac:	4a08      	ldr	r2, [pc, #32]	; (8000fd0 <lwip_sntp_recv_callback+0x38>)
 8000fae:	4b09      	ldr	r3, [pc, #36]	; (8000fd4 <lwip_sntp_recv_callback+0x3c>)
 8000fb0:	0018      	movs	r0, r3
 8000fb2:	f001 fc93 	bl	80028dc <app_debug_rtt_raw>
    }
    else
    {
        DEBUG_INFO("NTP: %u seconds elapsed since 1.1.1970\r\n", time);
    }
}
 8000fb6:	e007      	b.n	8000fc8 <lwip_sntp_recv_callback+0x30>
        DEBUG_INFO("NTP: %u seconds elapsed since 1.1.1970\r\n", time);
 8000fb8:	f01b fdb8 	bl	801cb2c <sys_get_tick_ms>
 8000fbc:	0001      	movs	r1, r0
 8000fbe:	687b      	ldr	r3, [r7, #4]
 8000fc0:	4a03      	ldr	r2, [pc, #12]	; (8000fd0 <lwip_sntp_recv_callback+0x38>)
 8000fc2:	4805      	ldr	r0, [pc, #20]	; (8000fd8 <lwip_sntp_recv_callback+0x40>)
 8000fc4:	f001 fc8a 	bl	80028dc <app_debug_rtt_raw>
}
 8000fc8:	46c0      	nop			; (mov r8, r8)
 8000fca:	46bd      	mov	sp, r7
 8000fcc:	b002      	add	sp, #8
 8000fce:	bd80      	pop	{r7, pc}
 8000fd0:	0801d770 	.word	0x0801d770
 8000fd4:	0801dc5c 	.word	0x0801dc5c
 8000fd8:	0801dcac 	.word	0x0801dcac

08000fdc <ppp_link_status_cb>:
 * ===================
 *
 * PPP status callback is called on PPP status change (up, down, ...) from lwIP core thread
 */
static void ppp_link_status_cb(ppp_pcb *pcb, int err_code, void *ctx)
{
 8000fdc:	b590      	push	{r4, r7, lr}
 8000fde:	b087      	sub	sp, #28
 8000fe0:	af00      	add	r7, sp, #0
 8000fe2:	60f8      	str	r0, [r7, #12]
 8000fe4:	60b9      	str	r1, [r7, #8]
 8000fe6:	607a      	str	r2, [r7, #4]
    struct netif *pppif = ppp_netif(pcb);
 8000fe8:	68fb      	ldr	r3, [r7, #12]
 8000fea:	6a1b      	ldr	r3, [r3, #32]
 8000fec:	617b      	str	r3, [r7, #20]
 8000fee:	68bb      	ldr	r3, [r7, #8]
 8000ff0:	2b0c      	cmp	r3, #12
 8000ff2:	d900      	bls.n	8000ff6 <ppp_link_status_cb+0x1a>
 8000ff4:	e0df      	b.n	80011b6 <ppp_link_status_cb+0x1da>
 8000ff6:	68bb      	ldr	r3, [r7, #8]
 8000ff8:	009a      	lsls	r2, r3, #2
 8000ffa:	4b7c      	ldr	r3, [pc, #496]	; (80011ec <ppp_link_status_cb+0x210>)
 8000ffc:	18d3      	adds	r3, r2, r3
 8000ffe:	681b      	ldr	r3, [r3, #0]
 8001000:	469f      	mov	pc, r3
    {
#if LWIP_DNS
        const ip_addr_t *ns;
#endif /* LWIP_DNS */

        DEBUG_INFO("PPP Connected\r\n");
 8001002:	f01b fd93 	bl	801cb2c <sys_get_tick_ms>
 8001006:	0001      	movs	r1, r0
 8001008:	4a79      	ldr	r2, [pc, #484]	; (80011f0 <ppp_link_status_cb+0x214>)
 800100a:	4b7a      	ldr	r3, [pc, #488]	; (80011f4 <ppp_link_status_cb+0x218>)
 800100c:	0018      	movs	r0, r3
 800100e:	f001 fc65 	bl	80028dc <app_debug_rtt_raw>

#if PPP_IPV4_SUPPORT

        DEBUG_INFO("\tour_ipaddr    = %s\r\n", ipaddr_ntoa(&pppif->ip_addr));
 8001012:	f01b fd8b 	bl	801cb2c <sys_get_tick_ms>
 8001016:	0004      	movs	r4, r0
 8001018:	697b      	ldr	r3, [r7, #20]
 800101a:	3304      	adds	r3, #4
 800101c:	0018      	movs	r0, r3
 800101e:	f012 ff1b 	bl	8013e58 <ip4addr_ntoa>
 8001022:	0003      	movs	r3, r0
 8001024:	4a72      	ldr	r2, [pc, #456]	; (80011f0 <ppp_link_status_cb+0x214>)
 8001026:	4874      	ldr	r0, [pc, #464]	; (80011f8 <ppp_link_status_cb+0x21c>)
 8001028:	0021      	movs	r1, r4
 800102a:	f001 fc57 	bl	80028dc <app_debug_rtt_raw>
        DEBUG_INFO("\this_ipaddr    = %s\r\n", ipaddr_ntoa(&pppif->gw));
 800102e:	f01b fd7d 	bl	801cb2c <sys_get_tick_ms>
 8001032:	0004      	movs	r4, r0
 8001034:	697b      	ldr	r3, [r7, #20]
 8001036:	330c      	adds	r3, #12
 8001038:	0018      	movs	r0, r3
 800103a:	f012 ff0d 	bl	8013e58 <ip4addr_ntoa>
 800103e:	0003      	movs	r3, r0
 8001040:	4a6b      	ldr	r2, [pc, #428]	; (80011f0 <ppp_link_status_cb+0x214>)
 8001042:	486e      	ldr	r0, [pc, #440]	; (80011fc <ppp_link_status_cb+0x220>)
 8001044:	0021      	movs	r1, r4
 8001046:	f001 fc49 	bl	80028dc <app_debug_rtt_raw>
        DEBUG_INFO("\tnetmask       = %s\r\n", ipaddr_ntoa(&pppif->netmask));
 800104a:	f01b fd6f 	bl	801cb2c <sys_get_tick_ms>
 800104e:	0004      	movs	r4, r0
 8001050:	697b      	ldr	r3, [r7, #20]
 8001052:	3308      	adds	r3, #8
 8001054:	0018      	movs	r0, r3
 8001056:	f012 feff 	bl	8013e58 <ip4addr_ntoa>
 800105a:	0003      	movs	r3, r0
 800105c:	4a64      	ldr	r2, [pc, #400]	; (80011f0 <ppp_link_status_cb+0x214>)
 800105e:	4868      	ldr	r0, [pc, #416]	; (8001200 <ppp_link_status_cb+0x224>)
 8001060:	0021      	movs	r1, r4
 8001062:	f001 fc3b 	bl	80028dc <app_debug_rtt_raw>
        HAL_Delay(1);
 8001066:	2001      	movs	r0, #1
 8001068:	f001 fdb8 	bl	8002bdc <HAL_Delay>

#if LWIP_DNS
        ns = dns_getserver(0);
 800106c:	2000      	movs	r0, #0
 800106e:	f005 fe71 	bl	8006d54 <dns_getserver>
 8001072:	0003      	movs	r3, r0
 8001074:	613b      	str	r3, [r7, #16]
        DEBUG_INFO("\tdns1          = %s\r\n", ipaddr_ntoa(ns));
 8001076:	f01b fd59 	bl	801cb2c <sys_get_tick_ms>
 800107a:	0004      	movs	r4, r0
 800107c:	693b      	ldr	r3, [r7, #16]
 800107e:	0018      	movs	r0, r3
 8001080:	f012 feea 	bl	8013e58 <ip4addr_ntoa>
 8001084:	0003      	movs	r3, r0
 8001086:	4a5a      	ldr	r2, [pc, #360]	; (80011f0 <ppp_link_status_cb+0x214>)
 8001088:	485e      	ldr	r0, [pc, #376]	; (8001204 <ppp_link_status_cb+0x228>)
 800108a:	0021      	movs	r1, r4
 800108c:	f001 fc26 	bl	80028dc <app_debug_rtt_raw>
        ns = dns_getserver(1);
 8001090:	2001      	movs	r0, #1
 8001092:	f005 fe5f 	bl	8006d54 <dns_getserver>
 8001096:	0003      	movs	r3, r0
 8001098:	613b      	str	r3, [r7, #16]
        DEBUG_INFO("\tdns2          = %s\r\n", ipaddr_ntoa(ns));
 800109a:	f01b fd47 	bl	801cb2c <sys_get_tick_ms>
 800109e:	0004      	movs	r4, r0
 80010a0:	693b      	ldr	r3, [r7, #16]
 80010a2:	0018      	movs	r0, r3
 80010a4:	f012 fed8 	bl	8013e58 <ip4addr_ntoa>
 80010a8:	0003      	movs	r3, r0
 80010aa:	4a51      	ldr	r2, [pc, #324]	; (80011f0 <ppp_link_status_cb+0x214>)
 80010ac:	4856      	ldr	r0, [pc, #344]	; (8001208 <ppp_link_status_cb+0x22c>)
 80010ae:	0021      	movs	r1, r4
 80010b0:	f001 fc14 	bl	80028dc <app_debug_rtt_raw>
        HAL_Delay(1);
 80010b4:	2001      	movs	r0, #1
 80010b6:	f001 fd91 	bl	8002bdc <HAL_Delay>
#endif /* PPP_IPV4_SUPPORT */

#if PPP_IPV6_SUPPORT
        DEBUG_INFO("\r   our6_ipaddr = %s\n", ip6addr_ntoa(netif_ip6_addr(pppif, 0)));
#endif /* PPP_IPV6_SUPPORT */
        break;
 80010ba:	e085      	b.n	80011c8 <ppp_link_status_cb+0x1ec>
    }

    case PPPERR_PARAM:
    {
        DEBUG_INFO("status_cb: Invalid parameter\r\n");
 80010bc:	f01b fd36 	bl	801cb2c <sys_get_tick_ms>
 80010c0:	0001      	movs	r1, r0
 80010c2:	4a4b      	ldr	r2, [pc, #300]	; (80011f0 <ppp_link_status_cb+0x214>)
 80010c4:	4b51      	ldr	r3, [pc, #324]	; (800120c <ppp_link_status_cb+0x230>)
 80010c6:	0018      	movs	r0, r3
 80010c8:	f001 fc08 	bl	80028dc <app_debug_rtt_raw>
        break;
 80010cc:	e07c      	b.n	80011c8 <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_OPEN:
    {
        DEBUG_INFO("status_cb: Unable to open PPP session\r\n");
 80010ce:	f01b fd2d 	bl	801cb2c <sys_get_tick_ms>
 80010d2:	0001      	movs	r1, r0
 80010d4:	4a46      	ldr	r2, [pc, #280]	; (80011f0 <ppp_link_status_cb+0x214>)
 80010d6:	4b4e      	ldr	r3, [pc, #312]	; (8001210 <ppp_link_status_cb+0x234>)
 80010d8:	0018      	movs	r0, r3
 80010da:	f001 fbff 	bl	80028dc <app_debug_rtt_raw>
        break;
 80010de:	e073      	b.n	80011c8 <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_DEVICE:
    {
        DEBUG_INFO("status_cb: Invalid I/O device for PPP\r\n");
 80010e0:	f01b fd24 	bl	801cb2c <sys_get_tick_ms>
 80010e4:	0001      	movs	r1, r0
 80010e6:	4a42      	ldr	r2, [pc, #264]	; (80011f0 <ppp_link_status_cb+0x214>)
 80010e8:	4b4a      	ldr	r3, [pc, #296]	; (8001214 <ppp_link_status_cb+0x238>)
 80010ea:	0018      	movs	r0, r3
 80010ec:	f001 fbf6 	bl	80028dc <app_debug_rtt_raw>
        break;
 80010f0:	e06a      	b.n	80011c8 <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_ALLOC:
    {
        DEBUG_INFO("status_cb: Unable to allocate resources\r\n");
 80010f2:	f01b fd1b 	bl	801cb2c <sys_get_tick_ms>
 80010f6:	0001      	movs	r1, r0
 80010f8:	4a3d      	ldr	r2, [pc, #244]	; (80011f0 <ppp_link_status_cb+0x214>)
 80010fa:	4b47      	ldr	r3, [pc, #284]	; (8001218 <ppp_link_status_cb+0x23c>)
 80010fc:	0018      	movs	r0, r3
 80010fe:	f001 fbed 	bl	80028dc <app_debug_rtt_raw>
        break;
 8001102:	e061      	b.n	80011c8 <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_USER: /* 5 */
    {
        /* ppp_close() was previously called, reconnect */
        DEBUG_INFO("status_cb: ppp is closed by user OK! Try to re-open...\r\n");
 8001104:	f01b fd12 	bl	801cb2c <sys_get_tick_ms>
 8001108:	0001      	movs	r1, r0
 800110a:	4a39      	ldr	r2, [pc, #228]	; (80011f0 <ppp_link_status_cb+0x214>)
 800110c:	4b43      	ldr	r3, [pc, #268]	; (800121c <ppp_link_status_cb+0x240>)
 800110e:	0018      	movs	r0, r3
 8001110:	f001 fbe4 	bl	80028dc <app_debug_rtt_raw>
        /* ppp_free(); -- can be called here */
        ppp_free(m_ppp_control_block);
 8001114:	4b42      	ldr	r3, [pc, #264]	; (8001220 <ppp_link_status_cb+0x244>)
 8001116:	681b      	ldr	r3, [r3, #0]
 8001118:	0018      	movs	r0, r3
 800111a:	f018 fcad 	bl	8019a78 <ppp_free>
        GSM_Manager_ChangeState(GSM_STATE_REOPEN_PPP);
 800111e:	2003      	movs	r0, #3
 8001120:	f000 f904 	bl	800132c <GSM_Manager_ChangeState>
        break;
 8001124:	e050      	b.n	80011c8 <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_CONNECT: /* 6 */
    {
        DEBUG_INFO("status_cb: Connection lost\r\n");
 8001126:	f01b fd01 	bl	801cb2c <sys_get_tick_ms>
 800112a:	0001      	movs	r1, r0
 800112c:	4a30      	ldr	r2, [pc, #192]	; (80011f0 <ppp_link_status_cb+0x214>)
 800112e:	4b3d      	ldr	r3, [pc, #244]	; (8001224 <ppp_link_status_cb+0x248>)
 8001130:	0018      	movs	r0, r3
 8001132:	f001 fbd3 	bl	80028dc <app_debug_rtt_raw>
        m_ppp_connected = false;
 8001136:	4b3c      	ldr	r3, [pc, #240]	; (8001228 <ppp_link_status_cb+0x24c>)
 8001138:	2200      	movs	r2, #0
 800113a:	701a      	strb	r2, [r3, #0]
        ppp_close(m_ppp_control_block, 1);
 800113c:	4b38      	ldr	r3, [pc, #224]	; (8001220 <ppp_link_status_cb+0x244>)
 800113e:	681b      	ldr	r3, [r3, #0]
 8001140:	2101      	movs	r1, #1
 8001142:	0018      	movs	r0, r3
 8001144:	f018 fc30 	bl	80199a8 <ppp_close>
        break;
 8001148:	e03e      	b.n	80011c8 <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_AUTHFAIL:
    {
        DEBUG_INFO("status_cb: Failed authentication challenge\r\n");
 800114a:	f01b fcef 	bl	801cb2c <sys_get_tick_ms>
 800114e:	0001      	movs	r1, r0
 8001150:	4a27      	ldr	r2, [pc, #156]	; (80011f0 <ppp_link_status_cb+0x214>)
 8001152:	4b36      	ldr	r3, [pc, #216]	; (800122c <ppp_link_status_cb+0x250>)
 8001154:	0018      	movs	r0, r3
 8001156:	f001 fbc1 	bl	80028dc <app_debug_rtt_raw>
        break;
 800115a:	e035      	b.n	80011c8 <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_PROTOCOL:
    {
        DEBUG_INFO("status_cb: Failed to meet protocol\n");
 800115c:	f01b fce6 	bl	801cb2c <sys_get_tick_ms>
 8001160:	0001      	movs	r1, r0
 8001162:	4a23      	ldr	r2, [pc, #140]	; (80011f0 <ppp_link_status_cb+0x214>)
 8001164:	4b32      	ldr	r3, [pc, #200]	; (8001230 <ppp_link_status_cb+0x254>)
 8001166:	0018      	movs	r0, r3
 8001168:	f001 fbb8 	bl	80028dc <app_debug_rtt_raw>
        break;
 800116c:	e02c      	b.n	80011c8 <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_PEERDEAD:
    {
        DEBUG_INFO("status_cb: Connection timeout\r\n");
 800116e:	f01b fcdd 	bl	801cb2c <sys_get_tick_ms>
 8001172:	0001      	movs	r1, r0
 8001174:	4a1e      	ldr	r2, [pc, #120]	; (80011f0 <ppp_link_status_cb+0x214>)
 8001176:	4b2f      	ldr	r3, [pc, #188]	; (8001234 <ppp_link_status_cb+0x258>)
 8001178:	0018      	movs	r0, r3
 800117a:	f001 fbaf 	bl	80028dc <app_debug_rtt_raw>
        break;
 800117e:	e023      	b.n	80011c8 <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_IDLETIMEOUT:
    {
        DEBUG_INFO("status_cb: Idle Timeout\r\n");
 8001180:	f01b fcd4 	bl	801cb2c <sys_get_tick_ms>
 8001184:	0001      	movs	r1, r0
 8001186:	4a1a      	ldr	r2, [pc, #104]	; (80011f0 <ppp_link_status_cb+0x214>)
 8001188:	4b2b      	ldr	r3, [pc, #172]	; (8001238 <ppp_link_status_cb+0x25c>)
 800118a:	0018      	movs	r0, r3
 800118c:	f001 fba6 	bl	80028dc <app_debug_rtt_raw>
        break;
 8001190:	e01a      	b.n	80011c8 <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_CONNECTTIME:
    {
        DEBUG_INFO("status_cb: Max connect time reached\r\n");
 8001192:	f01b fccb 	bl	801cb2c <sys_get_tick_ms>
 8001196:	0001      	movs	r1, r0
 8001198:	4a15      	ldr	r2, [pc, #84]	; (80011f0 <ppp_link_status_cb+0x214>)
 800119a:	4b28      	ldr	r3, [pc, #160]	; (800123c <ppp_link_status_cb+0x260>)
 800119c:	0018      	movs	r0, r3
 800119e:	f001 fb9d 	bl	80028dc <app_debug_rtt_raw>
        break;
 80011a2:	e011      	b.n	80011c8 <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_LOOPBACK:
    {
        DEBUG_INFO("status_cb: Loopback detected\r\n");
 80011a4:	f01b fcc2 	bl	801cb2c <sys_get_tick_ms>
 80011a8:	0001      	movs	r1, r0
 80011aa:	4a11      	ldr	r2, [pc, #68]	; (80011f0 <ppp_link_status_cb+0x214>)
 80011ac:	4b24      	ldr	r3, [pc, #144]	; (8001240 <ppp_link_status_cb+0x264>)
 80011ae:	0018      	movs	r0, r3
 80011b0:	f001 fb94 	bl	80028dc <app_debug_rtt_raw>
        break;
 80011b4:	e008      	b.n	80011c8 <ppp_link_status_cb+0x1ec>
    }
    default:
    {
        DEBUG_INFO("status_cb: Unknown error code %d\r\n", err_code);
 80011b6:	f01b fcb9 	bl	801cb2c <sys_get_tick_ms>
 80011ba:	0001      	movs	r1, r0
 80011bc:	68bb      	ldr	r3, [r7, #8]
 80011be:	4a0c      	ldr	r2, [pc, #48]	; (80011f0 <ppp_link_status_cb+0x214>)
 80011c0:	4820      	ldr	r0, [pc, #128]	; (8001244 <ppp_link_status_cb+0x268>)
 80011c2:	f001 fb8b 	bl	80028dc <app_debug_rtt_raw>
        break;
 80011c6:	46c0      	nop			; (mov r8, r8)
    /*
	* This should be in the switch case, this is put outside of the switch
	* case for example readability.
	*/

    if (err_code == PPPERR_NONE)
 80011c8:	68bb      	ldr	r3, [r7, #8]
 80011ca:	2b00      	cmp	r3, #0
 80011cc:	d10a      	bne.n	80011e4 <ppp_link_status_cb+0x208>
    {
        DEBUG_INFO("PPP is opened OK\r\n");
 80011ce:	f01b fcad 	bl	801cb2c <sys_get_tick_ms>
 80011d2:	0001      	movs	r1, r0
 80011d4:	4a06      	ldr	r2, [pc, #24]	; (80011f0 <ppp_link_status_cb+0x214>)
 80011d6:	4b1c      	ldr	r3, [pc, #112]	; (8001248 <ppp_link_status_cb+0x26c>)
 80011d8:	0018      	movs	r0, r3
 80011da:	f001 fb7f 	bl	80028dc <app_debug_rtt_raw>
        initialize_stnp();
 80011de:	f7ff feb1 	bl	8000f44 <initialize_stnp>
        return;
 80011e2:	46c0      	nop			; (mov r8, r8)
   * Try to reconnect in 30 seconds, if you need a modem chatscript you have
   * to do a much better signaling here ;-)
   */
    //  ppp_connect(pcb, 30);
    /* OR ppp_listen(pcb); */
}
 80011e4:	46bd      	mov	sp, r7
 80011e6:	b007      	add	sp, #28
 80011e8:	bd90      	pop	{r4, r7, pc}
 80011ea:	46c0      	nop			; (mov r8, r8)
 80011ec:	0802210c 	.word	0x0802210c
 80011f0:	0801d770 	.word	0x0801d770
 80011f4:	0801dcf0 	.word	0x0801dcf0
 80011f8:	0801dd1c 	.word	0x0801dd1c
 80011fc:	0801dd4c 	.word	0x0801dd4c
 8001200:	0801dd7c 	.word	0x0801dd7c
 8001204:	0801ddac 	.word	0x0801ddac
 8001208:	0801dddc 	.word	0x0801dddc
 800120c:	0801de0c 	.word	0x0801de0c
 8001210:	0801de44 	.word	0x0801de44
 8001214:	0801de88 	.word	0x0801de88
 8001218:	0801decc 	.word	0x0801decc
 800121c:	0801df10 	.word	0x0801df10
 8001220:	200001e0 	.word	0x200001e0
 8001224:	0801df64 	.word	0x0801df64
 8001228:	200001e4 	.word	0x200001e4
 800122c:	0801df9c 	.word	0x0801df9c
 8001230:	0801dfe4 	.word	0x0801dfe4
 8001234:	0801e024 	.word	0x0801e024
 8001238:	0801e060 	.word	0x0801e060
 800123c:	0801e094 	.word	0x0801e094
 8001240:	0801e0d4 	.word	0x0801e0d4
 8001244:	0801e10c 	.word	0x0801e10c
 8001248:	0801e148 	.word	0x0801e148

0800124c <Polling_GSM_StateMachine>:
void Polling_GSM_StateMachine (void)
{
 800124c:	b5b0      	push	{r4, r5, r7, lr}
 800124e:	b086      	sub	sp, #24
 8001250:	af04      	add	r7, sp, #16
    static uint32_t last_tick = 0;
    uint32_t current_tick = sys_get_tick_ms();
 8001252:	f01b fc6b 	bl	801cb2c <sys_get_tick_ms>
 8001256:	0003      	movs	r3, r0
 8001258:	607b      	str	r3, [r7, #4]
    if(current_tick - last_tick >= (uint32_t)1000)
 800125a:	4b23      	ldr	r3, [pc, #140]	; (80012e8 <Polling_GSM_StateMachine+0x9c>)
 800125c:	681b      	ldr	r3, [r3, #0]
 800125e:	687a      	ldr	r2, [r7, #4]
 8001260:	1ad2      	subs	r2, r2, r3
 8001262:	23fa      	movs	r3, #250	; 0xfa
 8001264:	009b      	lsls	r3, r3, #2
 8001266:	429a      	cmp	r2, r3
 8001268:	d332      	bcc.n	80012d0 <Polling_GSM_StateMachine+0x84>
    {
        last_tick = current_tick;
 800126a:	4b1f      	ldr	r3, [pc, #124]	; (80012e8 <Polling_GSM_StateMachine+0x9c>)
 800126c:	687a      	ldr	r2, [r7, #4]
 800126e:	601a      	str	r2, [r3, #0]
        switch (GSM_Manager.state)
 8001270:	4b1e      	ldr	r3, [pc, #120]	; (80012ec <Polling_GSM_StateMachine+0xa0>)
 8001272:	781b      	ldrb	r3, [r3, #0]
 8001274:	2b03      	cmp	r3, #3
 8001276:	d02d      	beq.n	80012d4 <Polling_GSM_StateMachine+0x88>
 8001278:	dc20      	bgt.n	80012bc <Polling_GSM_StateMachine+0x70>
 800127a:	2b02      	cmp	r3, #2
 800127c:	d02c      	beq.n	80012d8 <Polling_GSM_StateMachine+0x8c>
 800127e:	dc1d      	bgt.n	80012bc <Polling_GSM_StateMachine+0x70>
 8001280:	2b00      	cmp	r3, #0
 8001282:	d004      	beq.n	800128e <Polling_GSM_StateMachine+0x42>
 8001284:	2b01      	cmp	r3, #1
 8001286:	d119      	bne.n	80012bc <Polling_GSM_StateMachine+0x70>
        {
            case GSM_STATE_RESET:
                GSM_Turn_on_Power();
 8001288:	f000 face 	bl	8001828 <GSM_Turn_on_Power>
                break;
 800128c:	e027      	b.n	80012de <Polling_GSM_StateMachine+0x92>
            case GSM_STATE_POWER_ON:
                if(GSM_Manager.step == 0)
 800128e:	4b17      	ldr	r3, [pc, #92]	; (80012ec <Polling_GSM_StateMachine+0xa0>)
 8001290:	785b      	ldrb	r3, [r3, #1]
 8001292:	2b00      	cmp	r3, #0
 8001294:	d122      	bne.n	80012dc <Polling_GSM_StateMachine+0x90>
                {
                    GSM_Manager.step = 1;
 8001296:	4b15      	ldr	r3, [pc, #84]	; (80012ec <Polling_GSM_StateMachine+0xa0>)
 8001298:	2201      	movs	r2, #1
 800129a:	705a      	strb	r2, [r3, #1]
                    GSM_SendCommand_AT(ATC_Table_Config_Module[0]);
 800129c:	4b14      	ldr	r3, [pc, #80]	; (80012f0 <Polling_GSM_StateMachine+0xa4>)
 800129e:	466a      	mov	r2, sp
 80012a0:	0011      	movs	r1, r2
 80012a2:	001a      	movs	r2, r3
 80012a4:	3210      	adds	r2, #16
 80012a6:	ca31      	ldmia	r2!, {r0, r4, r5}
 80012a8:	c131      	stmia	r1!, {r0, r4, r5}
 80012aa:	6812      	ldr	r2, [r2, #0]
 80012ac:	600a      	str	r2, [r1, #0]
 80012ae:	6818      	ldr	r0, [r3, #0]
 80012b0:	6859      	ldr	r1, [r3, #4]
 80012b2:	689a      	ldr	r2, [r3, #8]
 80012b4:	68db      	ldr	r3, [r3, #12]
 80012b6:	f000 fb73 	bl	80019a0 <GSM_SendCommand_AT>
                }
                break;
 80012ba:	e00f      	b.n	80012dc <Polling_GSM_StateMachine+0x90>
                break;
            case GSM_STATE_REOPEN_PPP:

            	break;
            default:
                DEBUG_WARN("Unhandled state %d.\r\n", GSM_Manager.state);
 80012bc:	f01b fc36 	bl	801cb2c <sys_get_tick_ms>
 80012c0:	0001      	movs	r1, r0
 80012c2:	4b0a      	ldr	r3, [pc, #40]	; (80012ec <Polling_GSM_StateMachine+0xa0>)
 80012c4:	781b      	ldrb	r3, [r3, #0]
 80012c6:	4a0b      	ldr	r2, [pc, #44]	; (80012f4 <Polling_GSM_StateMachine+0xa8>)
 80012c8:	480b      	ldr	r0, [pc, #44]	; (80012f8 <Polling_GSM_StateMachine+0xac>)
 80012ca:	f001 fb07 	bl	80028dc <app_debug_rtt_raw>
                break;
 80012ce:	e006      	b.n	80012de <Polling_GSM_StateMachine+0x92>
        }
    }
 80012d0:	46c0      	nop			; (mov r8, r8)
 80012d2:	e004      	b.n	80012de <Polling_GSM_StateMachine+0x92>
            	break;
 80012d4:	46c0      	nop			; (mov r8, r8)
 80012d6:	e002      	b.n	80012de <Polling_GSM_StateMachine+0x92>
                break;
 80012d8:	46c0      	nop			; (mov r8, r8)
 80012da:	e000      	b.n	80012de <Polling_GSM_StateMachine+0x92>
                break;
 80012dc:	46c0      	nop			; (mov r8, r8)
}
 80012de:	46c0      	nop			; (mov r8, r8)
 80012e0:	46bd      	mov	sp, r7
 80012e2:	b002      	add	sp, #8
 80012e4:	bdb0      	pop	{r4, r5, r7, pc}
 80012e6:	46c0      	nop			; (mov r8, r8)
 80012e8:	200001e8 	.word	0x200001e8
 80012ec:	20001c1c 	.word	0x20001c1c
 80012f0:	08021d58 	.word	0x08021d58
 80012f4:	0801d770 	.word	0x0801d770
 80012f8:	0801e174 	.word	0x0801e174

080012fc <gsm_is_in_ppp_mode>:
bool gsm_is_in_ppp_mode(void)
{
 80012fc:	b580      	push	{r7, lr}
 80012fe:	af00      	add	r7, sp, #0
    return GSM_Manager.mode == GSM_INTERNET_MODE_PPP_STACK? true : false;
 8001300:	4b04      	ldr	r3, [pc, #16]	; (8001314 <gsm_is_in_ppp_mode+0x18>)
 8001302:	789b      	ldrb	r3, [r3, #2]
 8001304:	3b01      	subs	r3, #1
 8001306:	425a      	negs	r2, r3
 8001308:	4153      	adcs	r3, r2
 800130a:	b2db      	uxtb	r3, r3
}
 800130c:	0018      	movs	r0, r3
 800130e:	46bd      	mov	sp, r7
 8001310:	bd80      	pop	{r7, pc}
 8001312:	46c0      	nop			; (mov r8, r8)
 8001314:	20001c1c 	.word	0x20001c1c

08001318 <gsm_data_layer_is_ppp_connected>:
bool gsm_data_layer_is_ppp_connected(void)
{
 8001318:	b580      	push	{r7, lr}
 800131a:	af00      	add	r7, sp, #0
    return m_ppp_connected;
 800131c:	4b02      	ldr	r3, [pc, #8]	; (8001328 <gsm_data_layer_is_ppp_connected+0x10>)
 800131e:	781b      	ldrb	r3, [r3, #0]
}
 8001320:	0018      	movs	r0, r3
 8001322:	46bd      	mov	sp, r7
 8001324:	bd80      	pop	{r7, pc}
 8001326:	46c0      	nop			; (mov r8, r8)
 8001328:	200001e4 	.word	0x200001e4

0800132c <GSM_Manager_ChangeState>:


void GSM_Manager_ChangeState(Gsm_State_TypDef state)
{
 800132c:	b5b0      	push	{r4, r5, r7, lr}
 800132e:	b086      	sub	sp, #24
 8001330:	af04      	add	r7, sp, #16
 8001332:	0002      	movs	r2, r0
 8001334:	1dfb      	adds	r3, r7, #7
 8001336:	701a      	strb	r2, [r3, #0]
    GSM_Manager.state = state;
 8001338:	4b38      	ldr	r3, [pc, #224]	; (800141c <GSM_Manager_ChangeState+0xf0>)
 800133a:	1dfa      	adds	r2, r7, #7
 800133c:	7812      	ldrb	r2, [r2, #0]
 800133e:	701a      	strb	r2, [r3, #0]
    GSM_Manager.step = 0;
 8001340:	4b36      	ldr	r3, [pc, #216]	; (800141c <GSM_Manager_ChangeState+0xf0>)
 8001342:	2200      	movs	r2, #0
 8001344:	705a      	strb	r2, [r3, #1]
    DEBUG_INFO("Change GSM State to: ");
 8001346:	f01b fbf1 	bl	801cb2c <sys_get_tick_ms>
 800134a:	0001      	movs	r1, r0
 800134c:	4a34      	ldr	r2, [pc, #208]	; (8001420 <GSM_Manager_ChangeState+0xf4>)
 800134e:	4b35      	ldr	r3, [pc, #212]	; (8001424 <GSM_Manager_ChangeState+0xf8>)
 8001350:	0018      	movs	r0, r3
 8001352:	f001 fac3 	bl	80028dc <app_debug_rtt_raw>
    switch (state)
 8001356:	1dfb      	adds	r3, r7, #7
 8001358:	781b      	ldrb	r3, [r3, #0]
 800135a:	2b03      	cmp	r3, #3
 800135c:	d033      	beq.n	80013c6 <GSM_Manager_ChangeState+0x9a>
 800135e:	dc55      	bgt.n	800140c <GSM_Manager_ChangeState+0xe0>
 8001360:	2b02      	cmp	r3, #2
 8001362:	d005      	beq.n	8001370 <GSM_Manager_ChangeState+0x44>
 8001364:	dc52      	bgt.n	800140c <GSM_Manager_ChangeState+0xe0>
 8001366:	2b00      	cmp	r3, #0
 8001368:	d026      	beq.n	80013b8 <GSM_Manager_ChangeState+0x8c>
 800136a:	2b01      	cmp	r3, #1
 800136c:	d005      	beq.n	800137a <GSM_Manager_ChangeState+0x4e>
            GSM_HwLayer_Reset_Rx_Buffer(); // Reset USART RX buffer
            GSM_SendCommand_AT(ATC_Table_open_ppp_stack[0]);
        }
        break;
    default:
        break;
 800136e:	e04d      	b.n	800140c <GSM_Manager_ChangeState+0xe0>
        DEBUG_RAW("OK\r\n");
 8001370:	4b2d      	ldr	r3, [pc, #180]	; (8001428 <GSM_Manager_ChangeState+0xfc>)
 8001372:	0018      	movs	r0, r3
 8001374:	f001 fab2 	bl	80028dc <app_debug_rtt_raw>
        break;
 8001378:	e04b      	b.n	8001412 <GSM_Manager_ChangeState+0xe6>
    	DEBUG_RAW("RESET\r\n");
 800137a:	4b2c      	ldr	r3, [pc, #176]	; (800142c <GSM_Manager_ChangeState+0x100>)
 800137c:	0018      	movs	r0, r3
 800137e:	f001 faad 	bl	80028dc <app_debug_rtt_raw>
        GSM_HwLayer_Reset_Rx_Buffer(); // Reset USART RX buffer
 8001382:	f000 fbfd 	bl	8001b80 <GSM_HwLayer_Reset_Rx_Buffer>
        GSM_Manager_ChangeInternetMode(GSM_INTERNET_MODE_AT_STACK);
 8001386:	2000      	movs	r0, #0
 8001388:	f000 f85e 	bl	8001448 <GSM_Manager_ChangeInternetMode>
        HAL_GPIO_WritePin(EN_GSM_GPIO_Port,EN_GSM_Pin,0);    // Set GSM power en level to 0 = power off device
 800138c:	4b28      	ldr	r3, [pc, #160]	; (8001430 <GSM_Manager_ChangeState+0x104>)
 800138e:	2200      	movs	r2, #0
 8001390:	2140      	movs	r1, #64	; 0x40
 8001392:	0018      	movs	r0, r3
 8001394:	f001 ff2a 	bl	80031ec <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GSM_RESET_GPIO_Port,GSM_RESET_Pin,1);  // Set GSM Reset pin to high
 8001398:	2380      	movs	r3, #128	; 0x80
 800139a:	009b      	lsls	r3, r3, #2
 800139c:	4825      	ldr	r0, [pc, #148]	; (8001434 <GSM_Manager_ChangeState+0x108>)
 800139e:	2201      	movs	r2, #1
 80013a0:	0019      	movs	r1, r3
 80013a2:	f001 ff23 	bl	80031ec <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GSM_PWKEY_GPIO_Port,GSM_PWKEY_Pin,0);  // Reset GSM power key pin
 80013a6:	2380      	movs	r3, #128	; 0x80
 80013a8:	0059      	lsls	r1, r3, #1
 80013aa:	23a0      	movs	r3, #160	; 0xa0
 80013ac:	05db      	lsls	r3, r3, #23
 80013ae:	2200      	movs	r2, #0
 80013b0:	0018      	movs	r0, r3
 80013b2:	f001 ff1b 	bl	80031ec <HAL_GPIO_WritePin>
        break;
 80013b6:	e02c      	b.n	8001412 <GSM_Manager_ChangeState+0xe6>
    	DEBUG_RAW("POWER ON\r\n");
 80013b8:	4b1f      	ldr	r3, [pc, #124]	; (8001438 <GSM_Manager_ChangeState+0x10c>)
 80013ba:	0018      	movs	r0, r3
 80013bc:	f001 fa8e 	bl	80028dc <app_debug_rtt_raw>
        GSM_HwLayer_Reset_Rx_Buffer(); // Reset USART RX buffer
 80013c0:	f000 fbde 	bl	8001b80 <GSM_HwLayer_Reset_Rx_Buffer>
        break;
 80013c4:	e025      	b.n	8001412 <GSM_Manager_ChangeState+0xe6>
    	DEBUG_RAW("REOPEN PPP\r\n");
 80013c6:	4b1d      	ldr	r3, [pc, #116]	; (800143c <GSM_Manager_ChangeState+0x110>)
 80013c8:	0018      	movs	r0, r3
 80013ca:	f001 fa87 	bl	80028dc <app_debug_rtt_raw>
        if (GSM_Manager.step == 0)
 80013ce:	4b13      	ldr	r3, [pc, #76]	; (800141c <GSM_Manager_ChangeState+0xf0>)
 80013d0:	785b      	ldrb	r3, [r3, #1]
 80013d2:	2b00      	cmp	r3, #0
 80013d4:	d11c      	bne.n	8001410 <GSM_Manager_ChangeState+0xe4>
            GSM_Manager.step = 1;
 80013d6:	4b11      	ldr	r3, [pc, #68]	; (800141c <GSM_Manager_ChangeState+0xf0>)
 80013d8:	2201      	movs	r2, #1
 80013da:	705a      	strb	r2, [r3, #1]
            m_ppp_connected = false;
 80013dc:	4b18      	ldr	r3, [pc, #96]	; (8001440 <GSM_Manager_ChangeState+0x114>)
 80013de:	2200      	movs	r2, #0
 80013e0:	701a      	strb	r2, [r3, #0]
            GSM_Manager_ChangeInternetMode(GSM_INTERNET_MODE_AT_STACK);
 80013e2:	2000      	movs	r0, #0
 80013e4:	f000 f830 	bl	8001448 <GSM_Manager_ChangeInternetMode>
            GSM_HwLayer_Reset_Rx_Buffer(); // Reset USART RX buffer
 80013e8:	f000 fbca 	bl	8001b80 <GSM_HwLayer_Reset_Rx_Buffer>
            GSM_SendCommand_AT(ATC_Table_open_ppp_stack[0]);
 80013ec:	4b15      	ldr	r3, [pc, #84]	; (8001444 <GSM_Manager_ChangeState+0x118>)
 80013ee:	466a      	mov	r2, sp
 80013f0:	0011      	movs	r1, r2
 80013f2:	001a      	movs	r2, r3
 80013f4:	3210      	adds	r2, #16
 80013f6:	ca31      	ldmia	r2!, {r0, r4, r5}
 80013f8:	c131      	stmia	r1!, {r0, r4, r5}
 80013fa:	6812      	ldr	r2, [r2, #0]
 80013fc:	600a      	str	r2, [r1, #0]
 80013fe:	6818      	ldr	r0, [r3, #0]
 8001400:	6859      	ldr	r1, [r3, #4]
 8001402:	689a      	ldr	r2, [r3, #8]
 8001404:	68db      	ldr	r3, [r3, #12]
 8001406:	f000 facb 	bl	80019a0 <GSM_SendCommand_AT>
        break;
 800140a:	e001      	b.n	8001410 <GSM_Manager_ChangeState+0xe4>
        break;
 800140c:	46c0      	nop			; (mov r8, r8)
 800140e:	e000      	b.n	8001412 <GSM_Manager_ChangeState+0xe6>
        break;
 8001410:	46c0      	nop			; (mov r8, r8)
    }
}
 8001412:	46c0      	nop			; (mov r8, r8)
 8001414:	46bd      	mov	sp, r7
 8001416:	b002      	add	sp, #8
 8001418:	bdb0      	pop	{r4, r5, r7, pc}
 800141a:	46c0      	nop			; (mov r8, r8)
 800141c:	20001c1c 	.word	0x20001c1c
 8001420:	0801d770 	.word	0x0801d770
 8001424:	0801e1a4 	.word	0x0801e1a4
 8001428:	0801d760 	.word	0x0801d760
 800142c:	0801e1d4 	.word	0x0801e1d4
 8001430:	50000800 	.word	0x50000800
 8001434:	50000400 	.word	0x50000400
 8001438:	0801e1dc 	.word	0x0801e1dc
 800143c:	0801e1e8 	.word	0x0801e1e8
 8001440:	200001e4 	.word	0x200001e4
 8001444:	08022058 	.word	0x08022058

08001448 <GSM_Manager_ChangeInternetMode>:
void GSM_Manager_ChangeInternetMode(gsm_internet_mode_t mode)
{
 8001448:	b580      	push	{r7, lr}
 800144a:	b082      	sub	sp, #8
 800144c:	af00      	add	r7, sp, #0
 800144e:	0002      	movs	r2, r0
 8001450:	1dfb      	adds	r3, r7, #7
 8001452:	701a      	strb	r2, [r3, #0]
    GSM_Manager.mode = mode;
 8001454:	4b03      	ldr	r3, [pc, #12]	; (8001464 <GSM_Manager_ChangeInternetMode+0x1c>)
 8001456:	1dfa      	adds	r2, r7, #7
 8001458:	7812      	ldrb	r2, [r2, #0]
 800145a:	709a      	strb	r2, [r3, #2]
}
 800145c:	46c0      	nop			; (mov r8, r8)
 800145e:	46bd      	mov	sp, r7
 8001460:	b002      	add	sp, #8
 8001462:	bd80      	pop	{r7, pc}
 8001464:	20001c1c 	.word	0x20001c1c

08001468 <GSM_mnr_task>:
void GSM_mnr_task(void)
{
 8001468:	b580      	push	{r7, lr}
 800146a:	af00      	add	r7, sp, #0
    GSM_Hardware_Layer_Run();
 800146c:	f000 f832 	bl	80014d4 <GSM_Hardware_Layer_Run>
    Polling_GSM_StateMachine();
 8001470:	f7ff feec 	bl	800124c <Polling_GSM_StateMachine>
    GSM_Hardware_pppos_Polling();
 8001474:	f000 fb2c 	bl	8001ad0 <GSM_Hardware_pppos_Polling>
}
 8001478:	46c0      	nop			; (mov r8, r8)
 800147a:	46bd      	mov	sp, r7
 800147c:	bd80      	pop	{r7, pc}
	...

08001480 <GMS_Hardware_Init>:
static GSM_Hardware_atc_TypDef m_gsm_atc;
// Buffer for ppp
static GSM_Modem_Buffer_TypDef m_gsm_modem_buffer;

void GMS_Hardware_Init(void)
{
 8001480:	b580      	push	{r7, lr}
 8001482:	af00      	add	r7, sp, #0
	// Turn off power GSM
	HAL_GPIO_WritePin(EN_GSM_GPIO_Port,EN_GSM_Pin,0);
 8001484:	4b10      	ldr	r3, [pc, #64]	; (80014c8 <GMS_Hardware_Init+0x48>)
 8001486:	2200      	movs	r2, #0
 8001488:	2140      	movs	r1, #64	; 0x40
 800148a:	0018      	movs	r0, r3
 800148c:	f001 feae 	bl	80031ec <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GSM_RESET_GPIO_Port,GSM_RESET_Pin,1);
 8001490:	2380      	movs	r3, #128	; 0x80
 8001492:	009b      	lsls	r3, r3, #2
 8001494:	480d      	ldr	r0, [pc, #52]	; (80014cc <GMS_Hardware_Init+0x4c>)
 8001496:	2201      	movs	r2, #1
 8001498:	0019      	movs	r1, r3
 800149a:	f001 fea7 	bl	80031ec <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GSM_PWKEY_GPIO_Port,GSM_PWKEY_Pin,0);
 800149e:	2380      	movs	r3, #128	; 0x80
 80014a0:	0059      	lsls	r1, r3, #1
 80014a2:	23a0      	movs	r3, #160	; 0xa0
 80014a4:	05db      	lsls	r3, r3, #23
 80014a6:	2200      	movs	r2, #0
 80014a8:	0018      	movs	r0, r3
 80014aa:	f001 fe9f 	bl	80031ec <HAL_GPIO_WritePin>
	//Init SEGGER RTT Debug
	SEGGER_RTT_Init();
 80014ae:	f001 fa0d 	bl	80028cc <SEGGER_RTT_Init>
	// Cap phat bo nho cho RxRingBuffer
	RingBuffer_Init(&Rx_Buffer, 100);
 80014b2:	4b07      	ldr	r3, [pc, #28]	; (80014d0 <GMS_Hardware_Init+0x50>)
 80014b4:	2164      	movs	r1, #100	; 0x64
 80014b6:	0018      	movs	r0, r3
 80014b8:	f001 fa42 	bl	8002940 <RingBuffer_Init>
	// Set default GMS State to GMS_STATE_RESET
	GSM_Manager_ChangeState(GSM_STATE_RESET);
 80014bc:	2001      	movs	r0, #1
 80014be:	f7ff ff35 	bl	800132c <GSM_Manager_ChangeState>
}
 80014c2:	46c0      	nop			; (mov r8, r8)
 80014c4:	46bd      	mov	sp, r7
 80014c6:	bd80      	pop	{r7, pc}
 80014c8:	50000800 	.word	0x50000800
 80014cc:	50000400 	.word	0x50000400
 80014d0:	20001c30 	.word	0x20001c30

080014d4 <GSM_Hardware_Layer_Run>:
void GSM_Hardware_Layer_Run(void)
{
 80014d4:	b590      	push	{r4, r7, lr}
 80014d6:	b097      	sub	sp, #92	; 0x5c
 80014d8:	af02      	add	r7, sp, #8
	static uint32_t LastTick = 0;
	uint32_t Current_Tick = sys_get_tick_ms();
 80014da:	f01b fb27 	bl	801cb2c <sys_get_tick_ms>
 80014de:	0003      	movs	r3, r0
 80014e0:	64bb      	str	r3, [r7, #72]	; 0x48

	if(Current_Tick - LastTick < (uint32_t)5)
 80014e2:	4bc2      	ldr	r3, [pc, #776]	; (80017ec <GSM_Hardware_Layer_Run+0x318>)
 80014e4:	681b      	ldr	r3, [r3, #0]
 80014e6:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80014e8:	1ad3      	subs	r3, r2, r3
 80014ea:	2b04      	cmp	r3, #4
 80014ec:	d800      	bhi.n	80014f0 <GSM_Hardware_Layer_Run+0x1c>
 80014ee:	e178      	b.n	80017e2 <GSM_Hardware_Layer_Run+0x30e>
	{
		return;
	}
	uint32_t diff = sys_get_tick_ms() - m_gsm_atc.atc.Last_time_send_atc_ms;
 80014f0:	f01b fb1c 	bl	801cb2c <sys_get_tick_ms>
 80014f4:	0002      	movs	r2, r0
 80014f6:	4bbe      	ldr	r3, [pc, #760]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 80014f8:	699b      	ldr	r3, [r3, #24]
 80014fa:	1ad3      	subs	r3, r2, r3
 80014fc:	647b      	str	r3, [r7, #68]	; 0x44
	if(m_gsm_atc.atc.Timeout_atc_ms && diff >= m_gsm_atc.atc.Timeout_atc_ms)
 80014fe:	4bbc      	ldr	r3, [pc, #752]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 8001500:	695b      	ldr	r3, [r3, #20]
 8001502:	2b00      	cmp	r3, #0
 8001504:	d100      	bne.n	8001508 <GSM_Hardware_Layer_Run+0x34>
 8001506:	e07a      	b.n	80015fe <GSM_Hardware_Layer_Run+0x12a>
 8001508:	4bb9      	ldr	r3, [pc, #740]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 800150a:	695b      	ldr	r3, [r3, #20]
 800150c:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800150e:	429a      	cmp	r2, r3
 8001510:	d375      	bcc.n	80015fe <GSM_Hardware_Layer_Run+0x12a>
	{
		if(--m_gsm_atc.atc.Retry_Count_atc <= 0)
 8001512:	4bb7      	ldr	r3, [pc, #732]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 8001514:	7f1b      	ldrb	r3, [r3, #28]
 8001516:	3b01      	subs	r3, #1
 8001518:	b2da      	uxtb	r2, r3
 800151a:	4bb5      	ldr	r3, [pc, #724]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 800151c:	771a      	strb	r2, [r3, #28]
 800151e:	4bb4      	ldr	r3, [pc, #720]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 8001520:	7f1b      	ldrb	r3, [r3, #28]
 8001522:	2b00      	cmp	r3, #0
 8001524:	d11b      	bne.n	800155e <GSM_Hardware_Layer_Run+0x8a>
		{
			m_gsm_atc.atc.Timeout_atc_ms = 0;
 8001526:	4bb2      	ldr	r3, [pc, #712]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 8001528:	2200      	movs	r2, #0
 800152a:	615a      	str	r2, [r3, #20]
			if(m_gsm_atc.atc.Send_at_Callback != NULL)
 800152c:	4ab0      	ldr	r2, [pc, #704]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 800152e:	2384      	movs	r3, #132	; 0x84
 8001530:	00db      	lsls	r3, r3, #3
 8001532:	58d3      	ldr	r3, [r2, r3]
 8001534:	2b00      	cmp	r3, #0
 8001536:	d006      	beq.n	8001546 <GSM_Hardware_Layer_Run+0x72>
			{
				m_gsm_atc.atc.Send_at_Callback(GSM_EVENT_TIMEOUT,NULL);
 8001538:	4aad      	ldr	r2, [pc, #692]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 800153a:	2384      	movs	r3, #132	; 0x84
 800153c:	00db      	lsls	r3, r3, #3
 800153e:	58d3      	ldr	r3, [r2, r3]
 8001540:	2100      	movs	r1, #0
 8001542:	2001      	movs	r0, #1
 8001544:	4798      	blx	r3
			}
			memset(&m_gsm_atc.atc.Recv_Buffer.u8Buffer, 0, sizeof(m_gsm_atc.atc.Recv_Buffer.u8Buffer));
 8001546:	2380      	movs	r3, #128	; 0x80
 8001548:	00da      	lsls	r2, r3, #3
 800154a:	4baa      	ldr	r3, [pc, #680]	; (80017f4 <GSM_Hardware_Layer_Run+0x320>)
 800154c:	2100      	movs	r1, #0
 800154e:	0018      	movs	r0, r3
 8001550:	f01b fb62 	bl	801cc18 <memset>
			m_gsm_atc.atc.Recv_Buffer.index = 0;
 8001554:	4ba6      	ldr	r3, [pc, #664]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 8001556:	4aa8      	ldr	r2, [pc, #672]	; (80017f8 <GSM_Hardware_Layer_Run+0x324>)
 8001558:	2100      	movs	r1, #0
 800155a:	5299      	strh	r1, [r3, r2]
 800155c:	e04f      	b.n	80015fe <GSM_Hardware_Layer_Run+0x12a>
		}
		else
		{
			char sub_cmd[64] = "";
 800155e:	1d3b      	adds	r3, r7, #4
 8001560:	2200      	movs	r2, #0
 8001562:	601a      	str	r2, [r3, #0]
 8001564:	3304      	adds	r3, #4
 8001566:	223c      	movs	r2, #60	; 0x3c
 8001568:	2100      	movs	r1, #0
 800156a:	0018      	movs	r0, r3
 800156c:	f01b fb54 	bl	801cc18 <memset>
			strncpy(sub_cmd, m_gsm_atc.atc.cmd + 0, strlen(m_gsm_atc.atc.cmd) - 2);
 8001570:	4b9f      	ldr	r3, [pc, #636]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 8001572:	681c      	ldr	r4, [r3, #0]
 8001574:	4b9e      	ldr	r3, [pc, #632]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 8001576:	681b      	ldr	r3, [r3, #0]
 8001578:	0018      	movs	r0, r3
 800157a:	f7fe fdc5 	bl	8000108 <strlen>
 800157e:	0003      	movs	r3, r0
 8001580:	1e9a      	subs	r2, r3, #2
 8001582:	1d3b      	adds	r3, r7, #4
 8001584:	0021      	movs	r1, r4
 8001586:	0018      	movs	r0, r3
 8001588:	f01b fc3c 	bl	801ce04 <strncpy>
			DEBUG_WARN("Retry send [%s] %d.\r\n", sub_cmd, m_gsm_atc.atc.Retry_Count_atc);
 800158c:	f01b face 	bl	801cb2c <sys_get_tick_ms>
 8001590:	0001      	movs	r1, r0
 8001592:	4b97      	ldr	r3, [pc, #604]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 8001594:	7f1b      	ldrb	r3, [r3, #28]
 8001596:	001c      	movs	r4, r3
 8001598:	1d3b      	adds	r3, r7, #4
 800159a:	4a98      	ldr	r2, [pc, #608]	; (80017fc <GSM_Hardware_Layer_Run+0x328>)
 800159c:	4898      	ldr	r0, [pc, #608]	; (8001800 <GSM_Hardware_Layer_Run+0x32c>)
 800159e:	9400      	str	r4, [sp, #0]
 80015a0:	f001 f99c 	bl	80028dc <app_debug_rtt_raw>
			DEBUG_RAW("index = %d\r\n",m_gsm_atc.atc.Recv_Buffer.index);
 80015a4:	4b92      	ldr	r3, [pc, #584]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 80015a6:	4a94      	ldr	r2, [pc, #592]	; (80017f8 <GSM_Hardware_Layer_Run+0x324>)
 80015a8:	5a9b      	ldrh	r3, [r3, r2]
 80015aa:	001a      	movs	r2, r3
 80015ac:	4b95      	ldr	r3, [pc, #596]	; (8001804 <GSM_Hardware_Layer_Run+0x330>)
 80015ae:	0011      	movs	r1, r2
 80015b0:	0018      	movs	r0, r3
 80015b2:	f001 f993 	bl	80028dc <app_debug_rtt_raw>
			DEBUG_RAW("%s\r\n", (char*)m_gsm_atc.atc.Recv_Buffer.u8Buffer);
 80015b6:	4a8f      	ldr	r2, [pc, #572]	; (80017f4 <GSM_Hardware_Layer_Run+0x320>)
 80015b8:	4b93      	ldr	r3, [pc, #588]	; (8001808 <GSM_Hardware_Layer_Run+0x334>)
 80015ba:	0011      	movs	r1, r2
 80015bc:	0018      	movs	r0, r3
 80015be:	f001 f98d 	bl	80028dc <app_debug_rtt_raw>
			m_gsm_atc.atc.Last_time_send_atc_ms = sys_get_tick_ms();
 80015c2:	f01b fab3 	bl	801cb2c <sys_get_tick_ms>
 80015c6:	0002      	movs	r2, r0
 80015c8:	4b89      	ldr	r3, [pc, #548]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 80015ca:	619a      	str	r2, [r3, #24]
			memset(&m_gsm_atc.atc.Recv_Buffer.u8Buffer, 0, sizeof(m_gsm_atc.atc.Recv_Buffer.u8Buffer));
 80015cc:	2380      	movs	r3, #128	; 0x80
 80015ce:	00da      	lsls	r2, r3, #3
 80015d0:	4b88      	ldr	r3, [pc, #544]	; (80017f4 <GSM_Hardware_Layer_Run+0x320>)
 80015d2:	2100      	movs	r1, #0
 80015d4:	0018      	movs	r0, r3
 80015d6:	f01b fb1f 	bl	801cc18 <memset>
			m_gsm_atc.atc.Recv_Buffer.index = 0;
 80015da:	4b85      	ldr	r3, [pc, #532]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 80015dc:	4a86      	ldr	r2, [pc, #536]	; (80017f8 <GSM_Hardware_Layer_Run+0x324>)
 80015de:	2100      	movs	r1, #0
 80015e0:	5299      	strh	r1, [r3, r2]
			GSM_UART_TX((uint8_t*) m_gsm_atc.atc.cmd, strlen(m_gsm_atc.atc.cmd), 200);
 80015e2:	4b83      	ldr	r3, [pc, #524]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 80015e4:	681c      	ldr	r4, [r3, #0]
 80015e6:	4b82      	ldr	r3, [pc, #520]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 80015e8:	681b      	ldr	r3, [r3, #0]
 80015ea:	0018      	movs	r0, r3
 80015ec:	f7fe fd8c 	bl	8000108 <strlen>
 80015f0:	0003      	movs	r3, r0
 80015f2:	b29a      	uxth	r2, r3
 80015f4:	4885      	ldr	r0, [pc, #532]	; (800180c <GSM_Hardware_Layer_Run+0x338>)
 80015f6:	23c8      	movs	r3, #200	; 0xc8
 80015f8:	0021      	movs	r1, r4
 80015fa:	f002 fd4f 	bl	800409c <HAL_UART_Transmit>
		}
	}
	if(strlen(m_gsm_atc.atc.expect_resp) && strstr((char*)m_gsm_atc.atc.Recv_Buffer.u8Buffer, m_gsm_atc.atc.expect_resp))
 80015fe:	4b7c      	ldr	r3, [pc, #496]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 8001600:	685b      	ldr	r3, [r3, #4]
 8001602:	781b      	ldrb	r3, [r3, #0]
 8001604:	2b00      	cmp	r3, #0
 8001606:	d06e      	beq.n	80016e6 <GSM_Hardware_Layer_Run+0x212>
 8001608:	4b79      	ldr	r3, [pc, #484]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 800160a:	685a      	ldr	r2, [r3, #4]
 800160c:	4b79      	ldr	r3, [pc, #484]	; (80017f4 <GSM_Hardware_Layer_Run+0x320>)
 800160e:	0011      	movs	r1, r2
 8001610:	0018      	movs	r0, r3
 8001612:	f01b fc0b 	bl	801ce2c <strstr>
 8001616:	1e03      	subs	r3, r0, #0
 8001618:	d065      	beq.n	80016e6 <GSM_Hardware_Layer_Run+0x212>
	{
		bool do_callback = true;
 800161a:	244f      	movs	r4, #79	; 0x4f
 800161c:	193b      	adds	r3, r7, r4
 800161e:	2201      	movs	r2, #1
 8001620:	701a      	strb	r2, [r3, #0]
		if(m_gsm_atc.atc.expected_response_at_the_end && strlen(m_gsm_atc.atc.expected_response_at_the_end))
 8001622:	4b73      	ldr	r3, [pc, #460]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 8001624:	689b      	ldr	r3, [r3, #8]
 8001626:	2b00      	cmp	r3, #0
 8001628:	d03d      	beq.n	80016a6 <GSM_Hardware_Layer_Run+0x1d2>
 800162a:	4b71      	ldr	r3, [pc, #452]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 800162c:	689b      	ldr	r3, [r3, #8]
 800162e:	781b      	ldrb	r3, [r3, #0]
 8001630:	2b00      	cmp	r3, #0
 8001632:	d038      	beq.n	80016a6 <GSM_Hardware_Layer_Run+0x1d2>
		{
			Expect_len_compare = strlen(m_gsm_atc.atc.expected_response_at_the_end);
 8001634:	4b6e      	ldr	r3, [pc, #440]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 8001636:	689b      	ldr	r3, [r3, #8]
 8001638:	0018      	movs	r0, r3
 800163a:	f7fe fd65 	bl	8000108 <strlen>
 800163e:	0002      	movs	r2, r0
 8001640:	4b73      	ldr	r3, [pc, #460]	; (8001810 <GSM_Hardware_Layer_Run+0x33c>)
 8001642:	601a      	str	r2, [r3, #0]
			Current_Response_len = strlen((char*)m_gsm_atc.atc.Recv_Buffer.u8Buffer);
 8001644:	4b6b      	ldr	r3, [pc, #428]	; (80017f4 <GSM_Hardware_Layer_Run+0x320>)
 8001646:	0018      	movs	r0, r3
 8001648:	f7fe fd5e 	bl	8000108 <strlen>
 800164c:	0002      	movs	r2, r0
 800164e:	4b71      	ldr	r3, [pc, #452]	; (8001814 <GSM_Hardware_Layer_Run+0x340>)
 8001650:	601a      	str	r2, [r3, #0]
			if(Expect_len_compare < Current_Response_len)
 8001652:	4b6f      	ldr	r3, [pc, #444]	; (8001810 <GSM_Hardware_Layer_Run+0x33c>)
 8001654:	681a      	ldr	r2, [r3, #0]
 8001656:	4b6f      	ldr	r3, [pc, #444]	; (8001814 <GSM_Hardware_Layer_Run+0x340>)
 8001658:	681b      	ldr	r3, [r3, #0]
 800165a:	429a      	cmp	r2, r3
 800165c:	d21f      	bcs.n	800169e <GSM_Hardware_Layer_Run+0x1ca>
			{
				p_compare_end_str = &m_gsm_atc.atc.Recv_Buffer.u8Buffer[Current_Response_len - Expect_len_compare];
 800165e:	4b6d      	ldr	r3, [pc, #436]	; (8001814 <GSM_Hardware_Layer_Run+0x340>)
 8001660:	681a      	ldr	r2, [r3, #0]
 8001662:	4b6b      	ldr	r3, [pc, #428]	; (8001810 <GSM_Hardware_Layer_Run+0x33c>)
 8001664:	681b      	ldr	r3, [r3, #0]
 8001666:	1ad3      	subs	r3, r2, r3
 8001668:	3318      	adds	r3, #24
 800166a:	001a      	movs	r2, r3
 800166c:	4b60      	ldr	r3, [pc, #384]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 800166e:	18d3      	adds	r3, r2, r3
 8001670:	1d9a      	adds	r2, r3, #6
 8001672:	4b69      	ldr	r3, [pc, #420]	; (8001818 <GSM_Hardware_Layer_Run+0x344>)
 8001674:	601a      	str	r2, [r3, #0]
				if(memcmp(p_compare_end_str,m_gsm_atc.atc.expected_response_at_the_end,Expect_len_compare) == 0)
 8001676:	4b68      	ldr	r3, [pc, #416]	; (8001818 <GSM_Hardware_Layer_Run+0x344>)
 8001678:	6818      	ldr	r0, [r3, #0]
 800167a:	4b5d      	ldr	r3, [pc, #372]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 800167c:	6899      	ldr	r1, [r3, #8]
 800167e:	4b64      	ldr	r3, [pc, #400]	; (8001810 <GSM_Hardware_Layer_Run+0x33c>)
 8001680:	681b      	ldr	r3, [r3, #0]
 8001682:	001a      	movs	r2, r3
 8001684:	f01b fa9e 	bl	801cbc4 <memcmp>
 8001688:	1e03      	subs	r3, r0, #0
 800168a:	d103      	bne.n	8001694 <GSM_Hardware_Layer_Run+0x1c0>
				{
					// Compare thÃ nh cÃ´ng ÄuÃ´i Response
					do_callback = true;
 800168c:	193b      	adds	r3, r7, r4
 800168e:	2201      	movs	r2, #1
 8001690:	701a      	strb	r2, [r3, #0]
 8001692:	e008      	b.n	80016a6 <GSM_Hardware_Layer_Run+0x1d2>
				}
				else
				{
					do_callback = false;
 8001694:	234f      	movs	r3, #79	; 0x4f
 8001696:	18fb      	adds	r3, r7, r3
 8001698:	2200      	movs	r2, #0
 800169a:	701a      	strb	r2, [r3, #0]
 800169c:	e003      	b.n	80016a6 <GSM_Hardware_Layer_Run+0x1d2>
				}
			}
			else
			{
				do_callback = false;
 800169e:	234f      	movs	r3, #79	; 0x4f
 80016a0:	18fb      	adds	r3, r7, r3
 80016a2:	2200      	movs	r2, #0
 80016a4:	701a      	strb	r2, [r3, #0]
			}
		}
		if(do_callback == true)
 80016a6:	234f      	movs	r3, #79	; 0x4f
 80016a8:	18fb      	adds	r3, r7, r3
 80016aa:	781b      	ldrb	r3, [r3, #0]
 80016ac:	2b00      	cmp	r3, #0
 80016ae:	d100      	bne.n	80016b2 <GSM_Hardware_Layer_Run+0x1de>
 80016b0:	e090      	b.n	80017d4 <GSM_Hardware_Layer_Run+0x300>
		{
			m_gsm_atc.atc.Timeout_atc_ms = 0;
 80016b2:	4b4f      	ldr	r3, [pc, #316]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 80016b4:	2200      	movs	r2, #0
 80016b6:	615a      	str	r2, [r3, #20]
			m_gsm_atc.atc.Retry_Count_atc = 0;
 80016b8:	4b4d      	ldr	r3, [pc, #308]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 80016ba:	2200      	movs	r2, #0
 80016bc:	771a      	strb	r2, [r3, #28]
			m_gsm_atc.atc.Send_at_Callback(GSM_EVENT_OK,m_gsm_atc.atc.Recv_Buffer.u8Buffer);
 80016be:	4a4c      	ldr	r2, [pc, #304]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 80016c0:	2384      	movs	r3, #132	; 0x84
 80016c2:	00db      	lsls	r3, r3, #3
 80016c4:	58d3      	ldr	r3, [r2, r3]
 80016c6:	4a4b      	ldr	r2, [pc, #300]	; (80017f4 <GSM_Hardware_Layer_Run+0x320>)
 80016c8:	0011      	movs	r1, r2
 80016ca:	2000      	movs	r0, #0
 80016cc:	4798      	blx	r3
			memset(&m_gsm_atc.atc.Recv_Buffer.u8Buffer, 0, sizeof(m_gsm_atc.atc.Recv_Buffer.u8Buffer));
 80016ce:	2380      	movs	r3, #128	; 0x80
 80016d0:	00da      	lsls	r2, r3, #3
 80016d2:	4b48      	ldr	r3, [pc, #288]	; (80017f4 <GSM_Hardware_Layer_Run+0x320>)
 80016d4:	2100      	movs	r1, #0
 80016d6:	0018      	movs	r0, r3
 80016d8:	f01b fa9e 	bl	801cc18 <memset>
			m_gsm_atc.atc.Recv_Buffer.index = 0;
 80016dc:	4b44      	ldr	r3, [pc, #272]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 80016de:	4a46      	ldr	r2, [pc, #280]	; (80017f8 <GSM_Hardware_Layer_Run+0x324>)
 80016e0:	2100      	movs	r1, #0
 80016e2:	5299      	strh	r1, [r3, r2]
	{
 80016e4:	e076      	b.n	80017d4 <GSM_Hardware_Layer_Run+0x300>
		}

	}
	else if(strlen(m_gsm_atc.atc.expect_error) && strstr((char*)m_gsm_atc.atc.Recv_Buffer.u8Buffer, m_gsm_atc.atc.expect_error))
 80016e6:	4b42      	ldr	r3, [pc, #264]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 80016e8:	68db      	ldr	r3, [r3, #12]
 80016ea:	781b      	ldrb	r3, [r3, #0]
 80016ec:	2b00      	cmp	r3, #0
 80016ee:	d100      	bne.n	80016f2 <GSM_Hardware_Layer_Run+0x21e>
 80016f0:	e071      	b.n	80017d6 <GSM_Hardware_Layer_Run+0x302>
 80016f2:	4b3f      	ldr	r3, [pc, #252]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 80016f4:	68da      	ldr	r2, [r3, #12]
 80016f6:	4b3f      	ldr	r3, [pc, #252]	; (80017f4 <GSM_Hardware_Layer_Run+0x320>)
 80016f8:	0011      	movs	r1, r2
 80016fa:	0018      	movs	r0, r3
 80016fc:	f01b fb96 	bl	801ce2c <strstr>
 8001700:	1e03      	subs	r3, r0, #0
 8001702:	d068      	beq.n	80017d6 <GSM_Hardware_Layer_Run+0x302>
	{
		bool do_callback = true;
 8001704:	244e      	movs	r4, #78	; 0x4e
 8001706:	193b      	adds	r3, r7, r4
 8001708:	2201      	movs	r2, #1
 800170a:	701a      	strb	r2, [r3, #0]
		if(m_gsm_atc.atc.expect_error_at_the_end && strlen(m_gsm_atc.atc.expect_error_at_the_end))
 800170c:	4b38      	ldr	r3, [pc, #224]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 800170e:	691b      	ldr	r3, [r3, #16]
 8001710:	2b00      	cmp	r3, #0
 8001712:	d03d      	beq.n	8001790 <GSM_Hardware_Layer_Run+0x2bc>
 8001714:	4b36      	ldr	r3, [pc, #216]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 8001716:	691b      	ldr	r3, [r3, #16]
 8001718:	781b      	ldrb	r3, [r3, #0]
 800171a:	2b00      	cmp	r3, #0
 800171c:	d038      	beq.n	8001790 <GSM_Hardware_Layer_Run+0x2bc>
		{
			Expect_len_compare_error_handle = strlen(m_gsm_atc.atc.expect_error_at_the_end);
 800171e:	4b34      	ldr	r3, [pc, #208]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 8001720:	691b      	ldr	r3, [r3, #16]
 8001722:	0018      	movs	r0, r3
 8001724:	f7fe fcf0 	bl	8000108 <strlen>
 8001728:	0002      	movs	r2, r0
 800172a:	4b3c      	ldr	r3, [pc, #240]	; (800181c <GSM_Hardware_Layer_Run+0x348>)
 800172c:	601a      	str	r2, [r3, #0]
			Current_Response_len_error_handle = strlen((char*)m_gsm_atc.atc.Recv_Buffer.u8Buffer);
 800172e:	4b31      	ldr	r3, [pc, #196]	; (80017f4 <GSM_Hardware_Layer_Run+0x320>)
 8001730:	0018      	movs	r0, r3
 8001732:	f7fe fce9 	bl	8000108 <strlen>
 8001736:	0002      	movs	r2, r0
 8001738:	4b39      	ldr	r3, [pc, #228]	; (8001820 <GSM_Hardware_Layer_Run+0x34c>)
 800173a:	601a      	str	r2, [r3, #0]
			if(Expect_len_compare_error_handle < Current_Response_len_error_handle)
 800173c:	4b37      	ldr	r3, [pc, #220]	; (800181c <GSM_Hardware_Layer_Run+0x348>)
 800173e:	681a      	ldr	r2, [r3, #0]
 8001740:	4b37      	ldr	r3, [pc, #220]	; (8001820 <GSM_Hardware_Layer_Run+0x34c>)
 8001742:	681b      	ldr	r3, [r3, #0]
 8001744:	429a      	cmp	r2, r3
 8001746:	d21f      	bcs.n	8001788 <GSM_Hardware_Layer_Run+0x2b4>
			{
				p_compare_end_str_error_handle = &m_gsm_atc.atc.Recv_Buffer.u8Buffer[Current_Response_len_error_handle - Expect_len_compare_error_handle];
 8001748:	4b35      	ldr	r3, [pc, #212]	; (8001820 <GSM_Hardware_Layer_Run+0x34c>)
 800174a:	681a      	ldr	r2, [r3, #0]
 800174c:	4b33      	ldr	r3, [pc, #204]	; (800181c <GSM_Hardware_Layer_Run+0x348>)
 800174e:	681b      	ldr	r3, [r3, #0]
 8001750:	1ad3      	subs	r3, r2, r3
 8001752:	3318      	adds	r3, #24
 8001754:	001a      	movs	r2, r3
 8001756:	4b26      	ldr	r3, [pc, #152]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 8001758:	18d3      	adds	r3, r2, r3
 800175a:	1d9a      	adds	r2, r3, #6
 800175c:	4b31      	ldr	r3, [pc, #196]	; (8001824 <GSM_Hardware_Layer_Run+0x350>)
 800175e:	601a      	str	r2, [r3, #0]
				if(memcmp(p_compare_end_str_error_handle,m_gsm_atc.atc.expect_error_at_the_end,Expect_len_compare_error_handle))
 8001760:	4b30      	ldr	r3, [pc, #192]	; (8001824 <GSM_Hardware_Layer_Run+0x350>)
 8001762:	6818      	ldr	r0, [r3, #0]
 8001764:	4b22      	ldr	r3, [pc, #136]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 8001766:	6919      	ldr	r1, [r3, #16]
 8001768:	4b2c      	ldr	r3, [pc, #176]	; (800181c <GSM_Hardware_Layer_Run+0x348>)
 800176a:	681b      	ldr	r3, [r3, #0]
 800176c:	001a      	movs	r2, r3
 800176e:	f01b fa29 	bl	801cbc4 <memcmp>
 8001772:	1e03      	subs	r3, r0, #0
 8001774:	d003      	beq.n	800177e <GSM_Hardware_Layer_Run+0x2aa>
				{
					// Compare thÃ nh cÃ´ng ÄuÃ´i Response (trÆ°á»ng há»£p Response Error)
					do_callback = true;
 8001776:	193b      	adds	r3, r7, r4
 8001778:	2201      	movs	r2, #1
 800177a:	701a      	strb	r2, [r3, #0]
 800177c:	e008      	b.n	8001790 <GSM_Hardware_Layer_Run+0x2bc>
				}
				else
				{
					do_callback = false;
 800177e:	234e      	movs	r3, #78	; 0x4e
 8001780:	18fb      	adds	r3, r7, r3
 8001782:	2200      	movs	r2, #0
 8001784:	701a      	strb	r2, [r3, #0]
 8001786:	e003      	b.n	8001790 <GSM_Hardware_Layer_Run+0x2bc>
				}
			}
			else
			{
				do_callback = false;
 8001788:	234e      	movs	r3, #78	; 0x4e
 800178a:	18fb      	adds	r3, r7, r3
 800178c:	2200      	movs	r2, #0
 800178e:	701a      	strb	r2, [r3, #0]
			}
		}
		if(do_callback == true)
 8001790:	234e      	movs	r3, #78	; 0x4e
 8001792:	18fb      	adds	r3, r7, r3
 8001794:	781b      	ldrb	r3, [r3, #0]
 8001796:	2b00      	cmp	r3, #0
 8001798:	d01d      	beq.n	80017d6 <GSM_Hardware_Layer_Run+0x302>
		{
			m_gsm_atc.atc.Last_time_send_atc_ms = 0;
 800179a:	4b15      	ldr	r3, [pc, #84]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 800179c:	2200      	movs	r2, #0
 800179e:	619a      	str	r2, [r3, #24]
			m_gsm_atc.atc.Timeout_atc_ms = 0;
 80017a0:	4b13      	ldr	r3, [pc, #76]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 80017a2:	2200      	movs	r2, #0
 80017a4:	615a      	str	r2, [r3, #20]
			m_gsm_atc.atc.Retry_Count_atc = 0;
 80017a6:	4b12      	ldr	r3, [pc, #72]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 80017a8:	2200      	movs	r2, #0
 80017aa:	771a      	strb	r2, [r3, #28]
			m_gsm_atc.atc.Send_at_Callback(GSM_EVENT_ERROR,m_gsm_atc.atc.Recv_Buffer.u8Buffer);
 80017ac:	4a10      	ldr	r2, [pc, #64]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 80017ae:	2384      	movs	r3, #132	; 0x84
 80017b0:	00db      	lsls	r3, r3, #3
 80017b2:	58d3      	ldr	r3, [r2, r3]
 80017b4:	4a0f      	ldr	r2, [pc, #60]	; (80017f4 <GSM_Hardware_Layer_Run+0x320>)
 80017b6:	0011      	movs	r1, r2
 80017b8:	2002      	movs	r0, #2
 80017ba:	4798      	blx	r3
			memset(&m_gsm_atc.atc.Recv_Buffer.u8Buffer, 0, sizeof(m_gsm_atc.atc.Recv_Buffer.u8Buffer));
 80017bc:	2380      	movs	r3, #128	; 0x80
 80017be:	00da      	lsls	r2, r3, #3
 80017c0:	4b0c      	ldr	r3, [pc, #48]	; (80017f4 <GSM_Hardware_Layer_Run+0x320>)
 80017c2:	2100      	movs	r1, #0
 80017c4:	0018      	movs	r0, r3
 80017c6:	f01b fa27 	bl	801cc18 <memset>
			m_gsm_atc.atc.Recv_Buffer.index = 0;
 80017ca:	4b09      	ldr	r3, [pc, #36]	; (80017f0 <GSM_Hardware_Layer_Run+0x31c>)
 80017cc:	4a0a      	ldr	r2, [pc, #40]	; (80017f8 <GSM_Hardware_Layer_Run+0x324>)
 80017ce:	2100      	movs	r1, #0
 80017d0:	5299      	strh	r1, [r3, r2]
 80017d2:	e000      	b.n	80017d6 <GSM_Hardware_Layer_Run+0x302>
	{
 80017d4:	46c0      	nop			; (mov r8, r8)
		}
	}
	LastTick = sys_get_tick_ms();
 80017d6:	f01b f9a9 	bl	801cb2c <sys_get_tick_ms>
 80017da:	0002      	movs	r2, r0
 80017dc:	4b03      	ldr	r3, [pc, #12]	; (80017ec <GSM_Hardware_Layer_Run+0x318>)
 80017de:	601a      	str	r2, [r3, #0]
 80017e0:	e000      	b.n	80017e4 <GSM_Hardware_Layer_Run+0x310>
		return;
 80017e2:	46c0      	nop			; (mov r8, r8)
}
 80017e4:	46bd      	mov	sp, r7
 80017e6:	b015      	add	sp, #84	; 0x54
 80017e8:	bd90      	pop	{r4, r7, pc}
 80017ea:	46c0      	nop			; (mov r8, r8)
 80017ec:	20000c14 	.word	0x20000c14
 80017f0:	200001ec 	.word	0x200001ec
 80017f4:	2000020a 	.word	0x2000020a
 80017f8:	0000041e 	.word	0x0000041e
 80017fc:	0801e1f8 	.word	0x0801e1f8
 8001800:	0801e1fc 	.word	0x0801e1fc
 8001804:	0801e22c 	.word	0x0801e22c
 8001808:	0801e23c 	.word	0x0801e23c
 800180c:	20001b98 	.word	0x20001b98
 8001810:	20001c24 	.word	0x20001c24
 8001814:	20001c28 	.word	0x20001c28
 8001818:	20001c44 	.word	0x20001c44
 800181c:	20001c20 	.word	0x20001c20
 8001820:	20001c40 	.word	0x20001c40
 8001824:	20001c2c 	.word	0x20001c2c

08001828 <GSM_Turn_on_Power>:
void GSM_Turn_on_Power(void)
{
 8001828:	b580      	push	{r7, lr}
 800182a:	af00      	add	r7, sp, #0
	static uint8_t step;
	DEBUG_INFO("GSM Hard reset step %d.\r\n", step);
 800182c:	f01b f97e 	bl	801cb2c <sys_get_tick_ms>
 8001830:	0001      	movs	r1, r0
 8001832:	4b52      	ldr	r3, [pc, #328]	; (800197c <GSM_Turn_on_Power+0x154>)
 8001834:	781b      	ldrb	r3, [r3, #0]
 8001836:	4a52      	ldr	r2, [pc, #328]	; (8001980 <GSM_Turn_on_Power+0x158>)
 8001838:	4852      	ldr	r0, [pc, #328]	; (8001984 <GSM_Turn_on_Power+0x15c>)
 800183a:	f001 f84f 	bl	80028dc <app_debug_rtt_raw>
	switch (step)
 800183e:	4b4f      	ldr	r3, [pc, #316]	; (800197c <GSM_Turn_on_Power+0x154>)
 8001840:	781b      	ldrb	r3, [r3, #0]
 8001842:	2b07      	cmp	r3, #7
 8001844:	d900      	bls.n	8001848 <GSM_Turn_on_Power+0x20>
 8001846:	e094      	b.n	8001972 <GSM_Turn_on_Power+0x14a>
 8001848:	009a      	lsls	r2, r3, #2
 800184a:	4b4f      	ldr	r3, [pc, #316]	; (8001988 <GSM_Turn_on_Power+0x160>)
 800184c:	18d3      	adds	r3, r2, r3
 800184e:	681b      	ldr	r3, [r3, #0]
 8001850:	469f      	mov	pc, r3
	{
		case 0:
			HAL_GPIO_WritePin(EN_GSM_GPIO_Port,EN_GSM_Pin,0);
 8001852:	4b4e      	ldr	r3, [pc, #312]	; (800198c <GSM_Turn_on_Power+0x164>)
 8001854:	2200      	movs	r2, #0
 8001856:	2140      	movs	r1, #64	; 0x40
 8001858:	0018      	movs	r0, r3
 800185a:	f001 fcc7 	bl	80031ec <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(GSM_RESET_GPIO_Port,GSM_RESET_Pin,1);
 800185e:	2380      	movs	r3, #128	; 0x80
 8001860:	009b      	lsls	r3, r3, #2
 8001862:	484b      	ldr	r0, [pc, #300]	; (8001990 <GSM_Turn_on_Power+0x168>)
 8001864:	2201      	movs	r2, #1
 8001866:	0019      	movs	r1, r3
 8001868:	f001 fcc0 	bl	80031ec <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(GSM_PWKEY_GPIO_Port,GSM_PWKEY_Pin,0);
 800186c:	2380      	movs	r3, #128	; 0x80
 800186e:	0059      	lsls	r1, r3, #1
 8001870:	23a0      	movs	r3, #160	; 0xa0
 8001872:	05db      	lsls	r3, r3, #23
 8001874:	2200      	movs	r2, #0
 8001876:	0018      	movs	r0, r3
 8001878:	f001 fcb8 	bl	80031ec <HAL_GPIO_WritePin>
			step++;
 800187c:	4b3f      	ldr	r3, [pc, #252]	; (800197c <GSM_Turn_on_Power+0x154>)
 800187e:	781b      	ldrb	r3, [r3, #0]
 8001880:	3301      	adds	r3, #1
 8001882:	b2da      	uxtb	r2, r3
 8001884:	4b3d      	ldr	r3, [pc, #244]	; (800197c <GSM_Turn_on_Power+0x154>)
 8001886:	701a      	strb	r2, [r3, #0]
			break;
 8001888:	e074      	b.n	8001974 <GSM_Turn_on_Power+0x14c>
		case 1:
			HAL_GPIO_WritePin(GSM_RESET_GPIO_Port,GSM_RESET_Pin,0);
 800188a:	2380      	movs	r3, #128	; 0x80
 800188c:	009b      	lsls	r3, r3, #2
 800188e:	4840      	ldr	r0, [pc, #256]	; (8001990 <GSM_Turn_on_Power+0x168>)
 8001890:	2200      	movs	r2, #0
 8001892:	0019      	movs	r1, r3
 8001894:	f001 fcaa 	bl	80031ec <HAL_GPIO_WritePin>
			DEBUG_INFO("GSM power on.\r\n");
 8001898:	f01b f948 	bl	801cb2c <sys_get_tick_ms>
 800189c:	0001      	movs	r1, r0
 800189e:	4a38      	ldr	r2, [pc, #224]	; (8001980 <GSM_Turn_on_Power+0x158>)
 80018a0:	4b3c      	ldr	r3, [pc, #240]	; (8001994 <GSM_Turn_on_Power+0x16c>)
 80018a2:	0018      	movs	r0, r3
 80018a4:	f001 f81a 	bl	80028dc <app_debug_rtt_raw>
			HAL_GPIO_WritePin(EN_GSM_GPIO_Port,EN_GSM_Pin,1);
 80018a8:	4b38      	ldr	r3, [pc, #224]	; (800198c <GSM_Turn_on_Power+0x164>)
 80018aa:	2201      	movs	r2, #1
 80018ac:	2140      	movs	r1, #64	; 0x40
 80018ae:	0018      	movs	r0, r3
 80018b0:	f001 fc9c 	bl	80031ec <HAL_GPIO_WritePin>
			// Enable nguon 5V
			HAL_GPIO_WritePin(CHARGE_EN_GPIO_Port,CHARGE_EN_Pin,1);
 80018b4:	4b35      	ldr	r3, [pc, #212]	; (800198c <GSM_Turn_on_Power+0x164>)
 80018b6:	2201      	movs	r2, #1
 80018b8:	2110      	movs	r1, #16
 80018ba:	0018      	movs	r0, r3
 80018bc:	f001 fc96 	bl	80031ec <HAL_GPIO_WritePin>
			// Enable nguon 4.2V
			HAL_GPIO_WritePin(GSM_EN_GPIO_Port,GSM_EN_Pin,1);
 80018c0:	2380      	movs	r3, #128	; 0x80
 80018c2:	0219      	lsls	r1, r3, #8
 80018c4:	23a0      	movs	r3, #160	; 0xa0
 80018c6:	05db      	lsls	r3, r3, #23
 80018c8:	2201      	movs	r2, #1
 80018ca:	0018      	movs	r0, r3
 80018cc:	f001 fc8e 	bl	80031ec <HAL_GPIO_WritePin>
			step++;
 80018d0:	4b2a      	ldr	r3, [pc, #168]	; (800197c <GSM_Turn_on_Power+0x154>)
 80018d2:	781b      	ldrb	r3, [r3, #0]
 80018d4:	3301      	adds	r3, #1
 80018d6:	b2da      	uxtb	r2, r3
 80018d8:	4b28      	ldr	r3, [pc, #160]	; (800197c <GSM_Turn_on_Power+0x154>)
 80018da:	701a      	strb	r2, [r3, #0]
			break;
 80018dc:	e04a      	b.n	8001974 <GSM_Turn_on_Power+0x14c>
		case 2:
			step++;
 80018de:	4b27      	ldr	r3, [pc, #156]	; (800197c <GSM_Turn_on_Power+0x154>)
 80018e0:	781b      	ldrb	r3, [r3, #0]
 80018e2:	3301      	adds	r3, #1
 80018e4:	b2da      	uxtb	r2, r3
 80018e6:	4b25      	ldr	r3, [pc, #148]	; (800197c <GSM_Turn_on_Power+0x154>)
 80018e8:	701a      	strb	r2, [r3, #0]
			break;
 80018ea:	e043      	b.n	8001974 <GSM_Turn_on_Power+0x14c>
		case 3: 
			/* Generate pulse from (1-0-1) |_| to Power On module */
			DEBUG_INFO("Pulse power key.\r\n");
 80018ec:	f01b f91e 	bl	801cb2c <sys_get_tick_ms>
 80018f0:	0001      	movs	r1, r0
 80018f2:	4a23      	ldr	r2, [pc, #140]	; (8001980 <GSM_Turn_on_Power+0x158>)
 80018f4:	4b28      	ldr	r3, [pc, #160]	; (8001998 <GSM_Turn_on_Power+0x170>)
 80018f6:	0018      	movs	r0, r3
 80018f8:	f000 fff0 	bl	80028dc <app_debug_rtt_raw>
			HAL_GPIO_WritePin(GSM_PWKEY_GPIO_Port,GSM_PWKEY_Pin,1);
 80018fc:	2380      	movs	r3, #128	; 0x80
 80018fe:	0059      	lsls	r1, r3, #1
 8001900:	23a0      	movs	r3, #160	; 0xa0
 8001902:	05db      	lsls	r3, r3, #23
 8001904:	2201      	movs	r2, #1
 8001906:	0018      	movs	r0, r3
 8001908:	f001 fc70 	bl	80031ec <HAL_GPIO_WritePin>
			step++;
 800190c:	4b1b      	ldr	r3, [pc, #108]	; (800197c <GSM_Turn_on_Power+0x154>)
 800190e:	781b      	ldrb	r3, [r3, #0]
 8001910:	3301      	adds	r3, #1
 8001912:	b2da      	uxtb	r2, r3
 8001914:	4b19      	ldr	r3, [pc, #100]	; (800197c <GSM_Turn_on_Power+0x154>)
 8001916:	701a      	strb	r2, [r3, #0]
			break;
 8001918:	e02c      	b.n	8001974 <GSM_Turn_on_Power+0x14c>
		case 4:
			HAL_GPIO_WritePin(GSM_PWKEY_GPIO_Port,GSM_PWKEY_Pin,0);
 800191a:	2380      	movs	r3, #128	; 0x80
 800191c:	0059      	lsls	r1, r3, #1
 800191e:	23a0      	movs	r3, #160	; 0xa0
 8001920:	05db      	lsls	r3, r3, #23
 8001922:	2200      	movs	r2, #0
 8001924:	0018      	movs	r0, r3
 8001926:	f001 fc61 	bl	80031ec <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(GSM_RESET_GPIO_Port,GSM_RESET_Pin,0);
 800192a:	2380      	movs	r3, #128	; 0x80
 800192c:	009b      	lsls	r3, r3, #2
 800192e:	4818      	ldr	r0, [pc, #96]	; (8001990 <GSM_Turn_on_Power+0x168>)
 8001930:	2200      	movs	r2, #0
 8001932:	0019      	movs	r1, r3
 8001934:	f001 fc5a 	bl	80031ec <HAL_GPIO_WritePin>
			step++;
 8001938:	4b10      	ldr	r3, [pc, #64]	; (800197c <GSM_Turn_on_Power+0x154>)
 800193a:	781b      	ldrb	r3, [r3, #0]
 800193c:	3301      	adds	r3, #1
 800193e:	b2da      	uxtb	r2, r3
 8001940:	4b0e      	ldr	r3, [pc, #56]	; (800197c <GSM_Turn_on_Power+0x154>)
 8001942:	701a      	strb	r2, [r3, #0]
			break;
 8001944:	e016      	b.n	8001974 <GSM_Turn_on_Power+0x14c>
		case 5:
		case 6:
			step++;
 8001946:	4b0d      	ldr	r3, [pc, #52]	; (800197c <GSM_Turn_on_Power+0x154>)
 8001948:	781b      	ldrb	r3, [r3, #0]
 800194a:	3301      	adds	r3, #1
 800194c:	b2da      	uxtb	r2, r3
 800194e:	4b0b      	ldr	r3, [pc, #44]	; (800197c <GSM_Turn_on_Power+0x154>)
 8001950:	701a      	strb	r2, [r3, #0]
			break;
 8001952:	e00f      	b.n	8001974 <GSM_Turn_on_Power+0x14c>
		case 7:
			step = 0;
 8001954:	4b09      	ldr	r3, [pc, #36]	; (800197c <GSM_Turn_on_Power+0x154>)
 8001956:	2200      	movs	r2, #0
 8001958:	701a      	strb	r2, [r3, #0]
			DEBUG_INFO("GSM Hard reset DONE.\r\n");
 800195a:	f01b f8e7 	bl	801cb2c <sys_get_tick_ms>
 800195e:	0001      	movs	r1, r0
 8001960:	4a07      	ldr	r2, [pc, #28]	; (8001980 <GSM_Turn_on_Power+0x158>)
 8001962:	4b0e      	ldr	r3, [pc, #56]	; (800199c <GSM_Turn_on_Power+0x174>)
 8001964:	0018      	movs	r0, r3
 8001966:	f000 ffb9 	bl	80028dc <app_debug_rtt_raw>
			GSM_Manager_ChangeState(GSM_STATE_POWER_ON); // GSM turn on Power Finish-> active GSM by AT Cmd
 800196a:	2000      	movs	r0, #0
 800196c:	f7ff fcde 	bl	800132c <GSM_Manager_ChangeState>
			break;
 8001970:	e000      	b.n	8001974 <GSM_Turn_on_Power+0x14c>
		default:
		break;
 8001972:	46c0      	nop			; (mov r8, r8)
	}
}
 8001974:	46c0      	nop			; (mov r8, r8)
 8001976:	46bd      	mov	sp, r7
 8001978:	bd80      	pop	{r7, pc}
 800197a:	46c0      	nop			; (mov r8, r8)
 800197c:	20000c18 	.word	0x20000c18
 8001980:	0801e1f8 	.word	0x0801e1f8
 8001984:	0801e244 	.word	0x0801e244
 8001988:	08022144 	.word	0x08022144
 800198c:	50000800 	.word	0x50000800
 8001990:	50000400 	.word	0x50000400
 8001994:	0801e278 	.word	0x0801e278
 8001998:	0801e2a4 	.word	0x0801e2a4
 800199c:	0801e2d0 	.word	0x0801e2d0

080019a0 <GSM_SendCommand_AT>:
void GSM_SendCommand_AT (GSM_ATCommand_Table_TypDef AT_Cmd)
{
 80019a0:	b084      	sub	sp, #16
 80019a2:	b5b0      	push	{r4, r5, r7, lr}
 80019a4:	af00      	add	r7, sp, #0
 80019a6:	2510      	movs	r5, #16
 80019a8:	197c      	adds	r4, r7, r5
 80019aa:	6020      	str	r0, [r4, #0]
 80019ac:	6061      	str	r1, [r4, #4]
 80019ae:	60a2      	str	r2, [r4, #8]
 80019b0:	60e3      	str	r3, [r4, #12]
	if(AT_Cmd.Timeout_atc_ms == 0 || AT_Cmd.Send_at_Callback == NULL)
 80019b2:	002a      	movs	r2, r5
 80019b4:	18bb      	adds	r3, r7, r2
 80019b6:	695b      	ldr	r3, [r3, #20]
 80019b8:	2b00      	cmp	r3, #0
 80019ba:	d003      	beq.n	80019c4 <GSM_SendCommand_AT+0x24>
 80019bc:	18bb      	adds	r3, r7, r2
 80019be:	69db      	ldr	r3, [r3, #28]
 80019c0:	2b00      	cmp	r3, #0
 80019c2:	d11c      	bne.n	80019fe <GSM_SendCommand_AT+0x5e>
	{
		memset(&m_gsm_atc.atc.Recv_Buffer.u8Buffer, 0, sizeof(m_gsm_atc.atc.Recv_Buffer.u8Buffer));
 80019c4:	2380      	movs	r3, #128	; 0x80
 80019c6:	00da      	lsls	r2, r3, #3
 80019c8:	4b34      	ldr	r3, [pc, #208]	; (8001a9c <GSM_SendCommand_AT+0xfc>)
 80019ca:	2100      	movs	r1, #0
 80019cc:	0018      	movs	r0, r3
 80019ce:	f01b f923 	bl	801cc18 <memset>
		m_gsm_atc.atc.Recv_Buffer.index = 0;
 80019d2:	4b33      	ldr	r3, [pc, #204]	; (8001aa0 <GSM_SendCommand_AT+0x100>)
 80019d4:	4a33      	ldr	r2, [pc, #204]	; (8001aa4 <GSM_SendCommand_AT+0x104>)
 80019d6:	2100      	movs	r1, #0
 80019d8:	5299      	strh	r1, [r3, r2]
		GSM_HwLayer_Reset_Rx_Buffer();
 80019da:	f000 f8d1 	bl	8001b80 <GSM_HwLayer_Reset_Rx_Buffer>
		//HAL_UART_Transmit(&huart1, (uint8_t *)AT_Cmd.cmd, strlen(AT_Cmd.cmd), 200);
		GSM_UART_TX((uint8_t *)AT_Cmd.cmd, strlen(AT_Cmd.cmd), 200);
 80019de:	2210      	movs	r2, #16
 80019e0:	18bb      	adds	r3, r7, r2
 80019e2:	681c      	ldr	r4, [r3, #0]
 80019e4:	18bb      	adds	r3, r7, r2
 80019e6:	681b      	ldr	r3, [r3, #0]
 80019e8:	0018      	movs	r0, r3
 80019ea:	f7fe fb8d 	bl	8000108 <strlen>
 80019ee:	0003      	movs	r3, r0
 80019f0:	b29a      	uxth	r2, r3
 80019f2:	482d      	ldr	r0, [pc, #180]	; (8001aa8 <GSM_SendCommand_AT+0x108>)
 80019f4:	23c8      	movs	r3, #200	; 0xc8
 80019f6:	0021      	movs	r1, r4
 80019f8:	f002 fb50 	bl	800409c <HAL_UART_Transmit>
		return;
 80019fc:	e048      	b.n	8001a90 <GSM_SendCommand_AT+0xf0>
	}
	if(strlen(AT_Cmd.cmd) < 64)
 80019fe:	2410      	movs	r4, #16
 8001a00:	193b      	adds	r3, r7, r4
 8001a02:	681b      	ldr	r3, [r3, #0]
 8001a04:	0018      	movs	r0, r3
 8001a06:	f7fe fb7f 	bl	8000108 <strlen>
	{

	}
	m_gsm_atc.atc.cmd = AT_Cmd.cmd;
 8001a0a:	193b      	adds	r3, r7, r4
 8001a0c:	681a      	ldr	r2, [r3, #0]
 8001a0e:	4b24      	ldr	r3, [pc, #144]	; (8001aa0 <GSM_SendCommand_AT+0x100>)
 8001a10:	601a      	str	r2, [r3, #0]
	m_gsm_atc.atc.expect_resp = AT_Cmd.expect_resp;
 8001a12:	193b      	adds	r3, r7, r4
 8001a14:	685a      	ldr	r2, [r3, #4]
 8001a16:	4b22      	ldr	r3, [pc, #136]	; (8001aa0 <GSM_SendCommand_AT+0x100>)
 8001a18:	605a      	str	r2, [r3, #4]
	m_gsm_atc.atc.expected_response_at_the_end = AT_Cmd.expected_response_at_the_end;
 8001a1a:	193b      	adds	r3, r7, r4
 8001a1c:	689a      	ldr	r2, [r3, #8]
 8001a1e:	4b20      	ldr	r3, [pc, #128]	; (8001aa0 <GSM_SendCommand_AT+0x100>)
 8001a20:	609a      	str	r2, [r3, #8]
	m_gsm_atc.atc.expect_error = AT_Cmd.expect_error;
 8001a22:	193b      	adds	r3, r7, r4
 8001a24:	68da      	ldr	r2, [r3, #12]
 8001a26:	4b1e      	ldr	r3, [pc, #120]	; (8001aa0 <GSM_SendCommand_AT+0x100>)
 8001a28:	60da      	str	r2, [r3, #12]
	m_gsm_atc.atc.expect_error_at_the_end = AT_Cmd.expect_error_at_the_end;
 8001a2a:	193b      	adds	r3, r7, r4
 8001a2c:	691a      	ldr	r2, [r3, #16]
 8001a2e:	4b1c      	ldr	r3, [pc, #112]	; (8001aa0 <GSM_SendCommand_AT+0x100>)
 8001a30:	611a      	str	r2, [r3, #16]
	m_gsm_atc.atc.Timeout_atc_ms = AT_Cmd.Timeout_atc_ms;
 8001a32:	193b      	adds	r3, r7, r4
 8001a34:	695a      	ldr	r2, [r3, #20]
 8001a36:	4b1a      	ldr	r3, [pc, #104]	; (8001aa0 <GSM_SendCommand_AT+0x100>)
 8001a38:	615a      	str	r2, [r3, #20]
	m_gsm_atc.atc.Last_time_send_atc_ms = sys_get_tick_ms();
 8001a3a:	f01b f877 	bl	801cb2c <sys_get_tick_ms>
 8001a3e:	0002      	movs	r2, r0
 8001a40:	4b17      	ldr	r3, [pc, #92]	; (8001aa0 <GSM_SendCommand_AT+0x100>)
 8001a42:	619a      	str	r2, [r3, #24]
	m_gsm_atc.atc.Retry_Count_atc = AT_Cmd.Retry_Count_atc;
 8001a44:	193b      	adds	r3, r7, r4
 8001a46:	7e1a      	ldrb	r2, [r3, #24]
 8001a48:	4b15      	ldr	r3, [pc, #84]	; (8001aa0 <GSM_SendCommand_AT+0x100>)
 8001a4a:	771a      	strb	r2, [r3, #28]
	m_gsm_atc.atc.Send_at_Callback = AT_Cmd.Send_at_Callback;
 8001a4c:	193b      	adds	r3, r7, r4
 8001a4e:	69d9      	ldr	r1, [r3, #28]
 8001a50:	4a13      	ldr	r2, [pc, #76]	; (8001aa0 <GSM_SendCommand_AT+0x100>)
 8001a52:	2384      	movs	r3, #132	; 0x84
 8001a54:	00db      	lsls	r3, r3, #3
 8001a56:	50d1      	str	r1, [r2, r3]

	memset(&m_gsm_atc.atc.Recv_Buffer.u8Buffer, 0, sizeof(m_gsm_atc.atc.Recv_Buffer.u8Buffer));
 8001a58:	2380      	movs	r3, #128	; 0x80
 8001a5a:	00da      	lsls	r2, r3, #3
 8001a5c:	4b0f      	ldr	r3, [pc, #60]	; (8001a9c <GSM_SendCommand_AT+0xfc>)
 8001a5e:	2100      	movs	r1, #0
 8001a60:	0018      	movs	r0, r3
 8001a62:	f01b f8d9 	bl	801cc18 <memset>
	m_gsm_atc.atc.Recv_Buffer.index = 0;
 8001a66:	4b0e      	ldr	r3, [pc, #56]	; (8001aa0 <GSM_SendCommand_AT+0x100>)
 8001a68:	4a0e      	ldr	r2, [pc, #56]	; (8001aa4 <GSM_SendCommand_AT+0x104>)
 8001a6a:	2100      	movs	r1, #0
 8001a6c:	5299      	strh	r1, [r3, r2]
	GSM_HwLayer_Reset_Rx_Buffer();
 8001a6e:	f000 f887 	bl	8001b80 <GSM_HwLayer_Reset_Rx_Buffer>
	//HAL_UART_Transmit(&huart1, (uint8_t *)AT_Cmd.cmd, strlen(AT_Cmd.cmd), 200);
	GSM_UART_TX((uint8_t *)AT_Cmd.cmd, strlen(AT_Cmd.cmd), 200);
 8001a72:	0022      	movs	r2, r4
 8001a74:	18bb      	adds	r3, r7, r2
 8001a76:	681c      	ldr	r4, [r3, #0]
 8001a78:	18bb      	adds	r3, r7, r2
 8001a7a:	681b      	ldr	r3, [r3, #0]
 8001a7c:	0018      	movs	r0, r3
 8001a7e:	f7fe fb43 	bl	8000108 <strlen>
 8001a82:	0003      	movs	r3, r0
 8001a84:	b29a      	uxth	r2, r3
 8001a86:	4808      	ldr	r0, [pc, #32]	; (8001aa8 <GSM_SendCommand_AT+0x108>)
 8001a88:	23c8      	movs	r3, #200	; 0xc8
 8001a8a:	0021      	movs	r1, r4
 8001a8c:	f002 fb06 	bl	800409c <HAL_UART_Transmit>

}
 8001a90:	46bd      	mov	sp, r7
 8001a92:	bcb0      	pop	{r4, r5, r7}
 8001a94:	bc08      	pop	{r3}
 8001a96:	b004      	add	sp, #16
 8001a98:	4718      	bx	r3
 8001a9a:	46c0      	nop			; (mov r8, r8)
 8001a9c:	2000020a 	.word	0x2000020a
 8001aa0:	200001ec 	.word	0x200001ec
 8001aa4:	0000041e 	.word	0x0000041e
 8001aa8:	20001b98 	.word	0x20001b98

08001aac <sio_read>:
uint32_t sio_read(sio_fd_t fd, u8_t *data, u32_t len)
{
 8001aac:	b580      	push	{r7, lr}
 8001aae:	b084      	sub	sp, #16
 8001ab0:	af00      	add	r7, sp, #0
 8001ab2:	60f8      	str	r0, [r7, #12]
 8001ab4:	60b9      	str	r1, [r7, #8]
 8001ab6:	607a      	str	r2, [r7, #4]
    return GSM_Hardware_layer_Copy_ppp_Buffer(data, len);
 8001ab8:	687a      	ldr	r2, [r7, #4]
 8001aba:	68bb      	ldr	r3, [r7, #8]
 8001abc:	0011      	movs	r1, r2
 8001abe:	0018      	movs	r0, r3
 8001ac0:	f000 f8fa 	bl	8001cb8 <GSM_Hardware_layer_Copy_ppp_Buffer>
 8001ac4:	0003      	movs	r3, r0
}
 8001ac6:	0018      	movs	r0, r3
 8001ac8:	46bd      	mov	sp, r7
 8001aca:	b004      	add	sp, #16
 8001acc:	bd80      	pop	{r7, pc}
	...

08001ad0 <GSM_Hardware_pppos_Polling>:
static uint8_t m_ppp_rx_buffer[512];
void GSM_Hardware_pppos_Polling(void)
{
 8001ad0:	b590      	push	{r4, r7, lr}
 8001ad2:	4c26      	ldr	r4, [pc, #152]	; (8001b6c <GSM_Hardware_pppos_Polling+0x9c>)
 8001ad4:	44a5      	add	sp, r4
 8001ad6:	af00      	add	r7, sp, #0
    uint32_t sio_size;
    sys_check_timeouts();
 8001ad8:	f010 fb50 	bl	801217c <sys_check_timeouts>
	uint8_t buffer[512] = {0};
 8001adc:	4b24      	ldr	r3, [pc, #144]	; (8001b70 <GSM_Hardware_pppos_Polling+0xa0>)
 8001ade:	2282      	movs	r2, #130	; 0x82
 8001ae0:	0092      	lsls	r2, r2, #2
 8001ae2:	4694      	mov	ip, r2
 8001ae4:	44bc      	add	ip, r7
 8001ae6:	4463      	add	r3, ip
 8001ae8:	2200      	movs	r2, #0
 8001aea:	601a      	str	r2, [r3, #0]
 8001aec:	3304      	adds	r3, #4
 8001aee:	22fe      	movs	r2, #254	; 0xfe
 8001af0:	0052      	lsls	r2, r2, #1
 8001af2:	2100      	movs	r1, #0
 8001af4:	0018      	movs	r0, r3
 8001af6:	f01b f88f 	bl	801cc18 <memset>
	uint16_t dataLength = 0;
 8001afa:	4b1e      	ldr	r3, [pc, #120]	; (8001b74 <GSM_Hardware_pppos_Polling+0xa4>)
 8001afc:	2282      	movs	r2, #130	; 0x82
 8001afe:	0092      	lsls	r2, r2, #2
 8001b00:	4694      	mov	ip, r2
 8001b02:	44bc      	add	ip, r7
 8001b04:	4463      	add	r3, ip
 8001b06:	2200      	movs	r2, #0
 8001b08:	801a      	strh	r2, [r3, #0]

	RingBuffer_GetBuffer(buffer, &dataLength, &Rx_Buffer);
 8001b0a:	4a1b      	ldr	r2, [pc, #108]	; (8001b78 <GSM_Hardware_pppos_Polling+0xa8>)
 8001b0c:	1cb9      	adds	r1, r7, #2
 8001b0e:	1d3b      	adds	r3, r7, #4
 8001b10:	0018      	movs	r0, r3
 8001b12:	f000 ff9a 	bl	8002a4a <RingBuffer_GetBuffer>
	GSM_HwLayer_Fill_Rx_Buffer(buffer, dataLength);
 8001b16:	4b17      	ldr	r3, [pc, #92]	; (8001b74 <GSM_Hardware_pppos_Polling+0xa4>)
 8001b18:	2282      	movs	r2, #130	; 0x82
 8001b1a:	0092      	lsls	r2, r2, #2
 8001b1c:	4694      	mov	ip, r2
 8001b1e:	44bc      	add	ip, r7
 8001b20:	4463      	add	r3, ip
 8001b22:	881b      	ldrh	r3, [r3, #0]
 8001b24:	001a      	movs	r2, r3
 8001b26:	1d3b      	adds	r3, r7, #4
 8001b28:	0011      	movs	r1, r2
 8001b2a:	0018      	movs	r0, r3
 8001b2c:	f000 f84e 	bl	8001bcc <GSM_HwLayer_Fill_Rx_Buffer>

    sio_size = sio_read(0, m_ppp_rx_buffer, 512);
 8001b30:	2380      	movs	r3, #128	; 0x80
 8001b32:	009a      	lsls	r2, r3, #2
 8001b34:	4b11      	ldr	r3, [pc, #68]	; (8001b7c <GSM_Hardware_pppos_Polling+0xac>)
 8001b36:	0019      	movs	r1, r3
 8001b38:	2000      	movs	r0, #0
 8001b3a:	f7ff ffb7 	bl	8001aac <sio_read>
 8001b3e:	0003      	movs	r3, r0
 8001b40:	2481      	movs	r4, #129	; 0x81
 8001b42:	00a4      	lsls	r4, r4, #2
 8001b44:	193a      	adds	r2, r7, r4
 8001b46:	6013      	str	r3, [r2, #0]
	if(sio_size > 0)
 8001b48:	193b      	adds	r3, r7, r4
 8001b4a:	681b      	ldr	r3, [r3, #0]
 8001b4c:	2b00      	cmp	r3, #0
 8001b4e:	d007      	beq.n	8001b60 <GSM_Hardware_pppos_Polling+0x90>
	{
		// Bypass data into ppp stack
		pppos_input(gsm_data_layer_get_ppp_control_block(), m_ppp_rx_buffer, sio_size);
 8001b50:	f7ff f9ee 	bl	8000f30 <gsm_data_layer_get_ppp_control_block>
 8001b54:	193b      	adds	r3, r7, r4
 8001b56:	681a      	ldr	r2, [r3, #0]
 8001b58:	4b08      	ldr	r3, [pc, #32]	; (8001b7c <GSM_Hardware_pppos_Polling+0xac>)
 8001b5a:	0019      	movs	r1, r3
 8001b5c:	f018 fd6c 	bl	801a638 <pppos_input>
	}

}
 8001b60:	46c0      	nop			; (mov r8, r8)
 8001b62:	46bd      	mov	sp, r7
 8001b64:	2383      	movs	r3, #131	; 0x83
 8001b66:	009b      	lsls	r3, r3, #2
 8001b68:	449d      	add	sp, r3
 8001b6a:	bd90      	pop	{r4, r7, pc}
 8001b6c:	fffffdf4 	.word	0xfffffdf4
 8001b70:	fffffdfc 	.word	0xfffffdfc
 8001b74:	fffffdfa 	.word	0xfffffdfa
 8001b78:	20001c30 	.word	0x20001c30
 8001b7c:	20000a14 	.word	0x20000a14

08001b80 <GSM_HwLayer_Reset_Rx_Buffer>:
void GSM_HwLayer_Reset_Rx_Buffer(void)
{
 8001b80:	b580      	push	{r7, lr}
 8001b82:	af00      	add	r7, sp, #0
	memset(&m_gsm_atc.atc.Recv_Buffer.u8Buffer, 0, sizeof(m_gsm_atc.atc.Recv_Buffer.u8Buffer));
 8001b84:	2380      	movs	r3, #128	; 0x80
 8001b86:	00da      	lsls	r2, r3, #3
 8001b88:	4b0a      	ldr	r3, [pc, #40]	; (8001bb4 <GSM_HwLayer_Reset_Rx_Buffer+0x34>)
 8001b8a:	2100      	movs	r1, #0
 8001b8c:	0018      	movs	r0, r3
 8001b8e:	f01b f843 	bl	801cc18 <memset>
	m_gsm_atc.atc.Recv_Buffer.index = 0;
 8001b92:	4b09      	ldr	r3, [pc, #36]	; (8001bb8 <GSM_HwLayer_Reset_Rx_Buffer+0x38>)
 8001b94:	4a09      	ldr	r2, [pc, #36]	; (8001bbc <GSM_HwLayer_Reset_Rx_Buffer+0x3c>)
 8001b96:	2100      	movs	r1, #0
 8001b98:	5299      	strh	r1, [r3, r2]
	memset(&m_gsm_modem_buffer, 0, sizeof(m_gsm_modem_buffer));
 8001b9a:	4a09      	ldr	r2, [pc, #36]	; (8001bc0 <GSM_HwLayer_Reset_Rx_Buffer+0x40>)
 8001b9c:	4b09      	ldr	r3, [pc, #36]	; (8001bc4 <GSM_HwLayer_Reset_Rx_Buffer+0x44>)
 8001b9e:	2100      	movs	r1, #0
 8001ba0:	0018      	movs	r0, r3
 8001ba2:	f01b f839 	bl	801cc18 <memset>
	Erase_RingBuffer(&Rx_Buffer);
 8001ba6:	4b08      	ldr	r3, [pc, #32]	; (8001bc8 <GSM_HwLayer_Reset_Rx_Buffer+0x48>)
 8001ba8:	0018      	movs	r0, r3
 8001baa:	f000 ff9a 	bl	8002ae2 <Erase_RingBuffer>
}
 8001bae:	46c0      	nop			; (mov r8, r8)
 8001bb0:	46bd      	mov	sp, r7
 8001bb2:	bd80      	pop	{r7, pc}
 8001bb4:	2000020a 	.word	0x2000020a
 8001bb8:	200001ec 	.word	0x200001ec
 8001bbc:	0000041e 	.word	0x0000041e
 8001bc0:	00000404 	.word	0x00000404
 8001bc4:	20000610 	.word	0x20000610
 8001bc8:	20001c30 	.word	0x20001c30

08001bcc <GSM_HwLayer_Fill_Rx_Buffer>:
void GSM_HwLayer_Fill_Rx_Buffer(uint8_t* data, uint32_t length)
{
 8001bcc:	b580      	push	{r7, lr}
 8001bce:	b084      	sub	sp, #16
 8001bd0:	af00      	add	r7, sp, #0
 8001bd2:	6078      	str	r0, [r7, #4]
 8001bd4:	6039      	str	r1, [r7, #0]
	if(length)
 8001bd6:	683b      	ldr	r3, [r7, #0]
 8001bd8:	2b00      	cmp	r3, #0
 8001bda:	d060      	beq.n	8001c9e <GSM_HwLayer_Fill_Rx_Buffer+0xd2>
	{
		// Device do not enter AT mode =>> bypass data into PPP stack
		if(gsm_is_in_ppp_mode())
 8001bdc:	f7ff fb8e 	bl	80012fc <gsm_is_in_ppp_mode>
 8001be0:	1e03      	subs	r3, r0, #0
 8001be2:	d028      	beq.n	8001c36 <GSM_HwLayer_Fill_Rx_Buffer+0x6a>
		{
			for(int CountByte = 0; CountByte < length; CountByte ++)
 8001be4:	2300      	movs	r3, #0
 8001be6:	60fb      	str	r3, [r7, #12]
 8001be8:	e010      	b.n	8001c0c <GSM_HwLayer_Fill_Rx_Buffer+0x40>
			{
				m_gsm_modem_buffer.u8Buffer[m_gsm_modem_buffer.idx_in++] = data[CountByte];
 8001bea:	68fb      	ldr	r3, [r7, #12]
 8001bec:	687a      	ldr	r2, [r7, #4]
 8001bee:	18d2      	adds	r2, r2, r3
 8001bf0:	4b2c      	ldr	r3, [pc, #176]	; (8001ca4 <GSM_HwLayer_Fill_Rx_Buffer+0xd8>)
 8001bf2:	881b      	ldrh	r3, [r3, #0]
 8001bf4:	1c59      	adds	r1, r3, #1
 8001bf6:	b288      	uxth	r0, r1
 8001bf8:	492a      	ldr	r1, [pc, #168]	; (8001ca4 <GSM_HwLayer_Fill_Rx_Buffer+0xd8>)
 8001bfa:	8008      	strh	r0, [r1, #0]
 8001bfc:	0019      	movs	r1, r3
 8001bfe:	7812      	ldrb	r2, [r2, #0]
 8001c00:	4b28      	ldr	r3, [pc, #160]	; (8001ca4 <GSM_HwLayer_Fill_Rx_Buffer+0xd8>)
 8001c02:	185b      	adds	r3, r3, r1
 8001c04:	711a      	strb	r2, [r3, #4]
			for(int CountByte = 0; CountByte < length; CountByte ++)
 8001c06:	68fb      	ldr	r3, [r7, #12]
 8001c08:	3301      	adds	r3, #1
 8001c0a:	60fb      	str	r3, [r7, #12]
 8001c0c:	68fb      	ldr	r3, [r7, #12]
 8001c0e:	683a      	ldr	r2, [r7, #0]
 8001c10:	429a      	cmp	r2, r3
 8001c12:	d8ea      	bhi.n	8001bea <GSM_HwLayer_Fill_Rx_Buffer+0x1e>
			}
			if(m_gsm_modem_buffer.idx_in >= GSM_PPP_MODEM_BUFFER_SIZE)
 8001c14:	4b23      	ldr	r3, [pc, #140]	; (8001ca4 <GSM_HwLayer_Fill_Rx_Buffer+0xd8>)
 8001c16:	881a      	ldrh	r2, [r3, #0]
 8001c18:	2380      	movs	r3, #128	; 0x80
 8001c1a:	00db      	lsls	r3, r3, #3
 8001c1c:	429a      	cmp	r2, r3
 8001c1e:	d302      	bcc.n	8001c26 <GSM_HwLayer_Fill_Rx_Buffer+0x5a>
			{
				m_gsm_modem_buffer.idx_in = 0;
 8001c20:	4b20      	ldr	r3, [pc, #128]	; (8001ca4 <GSM_HwLayer_Fill_Rx_Buffer+0xd8>)
 8001c22:	2200      	movs	r2, #0
 8001c24:	801a      	strh	r2, [r3, #0]
			}
			m_gsm_modem_buffer.u8Buffer[m_gsm_modem_buffer.idx_in] = 0;
 8001c26:	4b1f      	ldr	r3, [pc, #124]	; (8001ca4 <GSM_HwLayer_Fill_Rx_Buffer+0xd8>)
 8001c28:	881b      	ldrh	r3, [r3, #0]
 8001c2a:	001a      	movs	r2, r3
 8001c2c:	4b1d      	ldr	r3, [pc, #116]	; (8001ca4 <GSM_HwLayer_Fill_Rx_Buffer+0xd8>)
 8001c2e:	189b      	adds	r3, r3, r2
 8001c30:	2200      	movs	r2, #0
 8001c32:	711a      	strb	r2, [r3, #4]
 8001c34:	e033      	b.n	8001c9e <GSM_HwLayer_Fill_Rx_Buffer+0xd2>
		}
		else
		{
			for(int CountByte = 0; CountByte < length; CountByte ++)
 8001c36:	2300      	movs	r3, #0
 8001c38:	60bb      	str	r3, [r7, #8]
 8001c3a:	e02c      	b.n	8001c96 <GSM_HwLayer_Fill_Rx_Buffer+0xca>
			{
				m_gsm_atc.atc.Recv_Buffer.u8Buffer[m_gsm_atc.atc.Recv_Buffer.index] = data[CountByte];
 8001c3c:	68bb      	ldr	r3, [r7, #8]
 8001c3e:	687a      	ldr	r2, [r7, #4]
 8001c40:	18d3      	adds	r3, r2, r3
 8001c42:	4a19      	ldr	r2, [pc, #100]	; (8001ca8 <GSM_HwLayer_Fill_Rx_Buffer+0xdc>)
 8001c44:	4919      	ldr	r1, [pc, #100]	; (8001cac <GSM_HwLayer_Fill_Rx_Buffer+0xe0>)
 8001c46:	5a52      	ldrh	r2, [r2, r1]
 8001c48:	0011      	movs	r1, r2
 8001c4a:	781a      	ldrb	r2, [r3, #0]
 8001c4c:	4b16      	ldr	r3, [pc, #88]	; (8001ca8 <GSM_HwLayer_Fill_Rx_Buffer+0xdc>)
 8001c4e:	185b      	adds	r3, r3, r1
 8001c50:	779a      	strb	r2, [r3, #30]
				m_gsm_atc.atc.Recv_Buffer.index ++;
 8001c52:	4b15      	ldr	r3, [pc, #84]	; (8001ca8 <GSM_HwLayer_Fill_Rx_Buffer+0xdc>)
 8001c54:	4a15      	ldr	r2, [pc, #84]	; (8001cac <GSM_HwLayer_Fill_Rx_Buffer+0xe0>)
 8001c56:	5a9b      	ldrh	r3, [r3, r2]
 8001c58:	3301      	adds	r3, #1
 8001c5a:	b299      	uxth	r1, r3
 8001c5c:	4b12      	ldr	r3, [pc, #72]	; (8001ca8 <GSM_HwLayer_Fill_Rx_Buffer+0xdc>)
 8001c5e:	4a13      	ldr	r2, [pc, #76]	; (8001cac <GSM_HwLayer_Fill_Rx_Buffer+0xe0>)
 8001c60:	5299      	strh	r1, [r3, r2]
				if(m_gsm_atc.atc.Recv_Buffer.index >= GSM_ATC_BUFFER_SIZE)
 8001c62:	4b11      	ldr	r3, [pc, #68]	; (8001ca8 <GSM_HwLayer_Fill_Rx_Buffer+0xdc>)
 8001c64:	4a11      	ldr	r2, [pc, #68]	; (8001cac <GSM_HwLayer_Fill_Rx_Buffer+0xe0>)
 8001c66:	5a9a      	ldrh	r2, [r3, r2]
 8001c68:	2380      	movs	r3, #128	; 0x80
 8001c6a:	00db      	lsls	r3, r3, #3
 8001c6c:	429a      	cmp	r2, r3
 8001c6e:	d30f      	bcc.n	8001c90 <GSM_HwLayer_Fill_Rx_Buffer+0xc4>
				{
					DEBUG_ERROR("GSM ATC RX Buffer out of range!\r\n");
 8001c70:	f01a ff5c 	bl	801cb2c <sys_get_tick_ms>
 8001c74:	0001      	movs	r1, r0
 8001c76:	4a0e      	ldr	r2, [pc, #56]	; (8001cb0 <GSM_HwLayer_Fill_Rx_Buffer+0xe4>)
 8001c78:	4b0e      	ldr	r3, [pc, #56]	; (8001cb4 <GSM_HwLayer_Fill_Rx_Buffer+0xe8>)
 8001c7a:	0018      	movs	r0, r3
 8001c7c:	f000 fe2e 	bl	80028dc <app_debug_rtt_raw>
                    m_gsm_atc.atc.Recv_Buffer.index = 0;
 8001c80:	4b09      	ldr	r3, [pc, #36]	; (8001ca8 <GSM_HwLayer_Fill_Rx_Buffer+0xdc>)
 8001c82:	4a0a      	ldr	r2, [pc, #40]	; (8001cac <GSM_HwLayer_Fill_Rx_Buffer+0xe0>)
 8001c84:	2100      	movs	r1, #0
 8001c86:	5299      	strh	r1, [r3, r2]
                    m_gsm_atc.atc.Recv_Buffer.u8Buffer[0] = 0;
 8001c88:	4b07      	ldr	r3, [pc, #28]	; (8001ca8 <GSM_HwLayer_Fill_Rx_Buffer+0xdc>)
 8001c8a:	2200      	movs	r2, #0
 8001c8c:	779a      	strb	r2, [r3, #30]
                    return;
 8001c8e:	e006      	b.n	8001c9e <GSM_HwLayer_Fill_Rx_Buffer+0xd2>
			for(int CountByte = 0; CountByte < length; CountByte ++)
 8001c90:	68bb      	ldr	r3, [r7, #8]
 8001c92:	3301      	adds	r3, #1
 8001c94:	60bb      	str	r3, [r7, #8]
 8001c96:	68bb      	ldr	r3, [r7, #8]
 8001c98:	683a      	ldr	r2, [r7, #0]
 8001c9a:	429a      	cmp	r2, r3
 8001c9c:	d8ce      	bhi.n	8001c3c <GSM_HwLayer_Fill_Rx_Buffer+0x70>
				}
			}
		}
	}
}
 8001c9e:	46bd      	mov	sp, r7
 8001ca0:	b004      	add	sp, #16
 8001ca2:	bd80      	pop	{r7, pc}
 8001ca4:	20000610 	.word	0x20000610
 8001ca8:	200001ec 	.word	0x200001ec
 8001cac:	0000041e 	.word	0x0000041e
 8001cb0:	0801e1f8 	.word	0x0801e1f8
 8001cb4:	0801e300 	.word	0x0801e300

08001cb8 <GSM_Hardware_layer_Copy_ppp_Buffer>:
uint32_t GSM_Hardware_layer_Copy_ppp_Buffer(uint8_t* data, uint32_t length)
{
 8001cb8:	b580      	push	{r7, lr}
 8001cba:	b084      	sub	sp, #16
 8001cbc:	af00      	add	r7, sp, #0
 8001cbe:	6078      	str	r0, [r7, #4]
 8001cc0:	6039      	str	r1, [r7, #0]
	int CountByte = 0;
 8001cc2:	2300      	movs	r3, #0
 8001cc4:	60fb      	str	r3, [r7, #12]
	for(CountByte = 0; CountByte < length; CountByte++)
 8001cc6:	2300      	movs	r3, #0
 8001cc8:	60fb      	str	r3, [r7, #12]
 8001cca:	e023      	b.n	8001d14 <GSM_Hardware_layer_Copy_ppp_Buffer+0x5c>
	{
		if(m_gsm_modem_buffer.idx_out == m_gsm_modem_buffer.idx_in)
 8001ccc:	4b16      	ldr	r3, [pc, #88]	; (8001d28 <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001cce:	885a      	ldrh	r2, [r3, #2]
 8001cd0:	4b15      	ldr	r3, [pc, #84]	; (8001d28 <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001cd2:	881b      	ldrh	r3, [r3, #0]
 8001cd4:	429a      	cmp	r2, r3
 8001cd6:	d101      	bne.n	8001cdc <GSM_Hardware_layer_Copy_ppp_Buffer+0x24>
		{
			return CountByte; // Da quet het Buffer Modem
 8001cd8:	68fb      	ldr	r3, [r7, #12]
 8001cda:	e020      	b.n	8001d1e <GSM_Hardware_layer_Copy_ppp_Buffer+0x66>
		}
		data[CountByte] = m_gsm_modem_buffer.u8Buffer[m_gsm_modem_buffer.idx_out];
 8001cdc:	4b12      	ldr	r3, [pc, #72]	; (8001d28 <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001cde:	885b      	ldrh	r3, [r3, #2]
 8001ce0:	0019      	movs	r1, r3
 8001ce2:	68fb      	ldr	r3, [r7, #12]
 8001ce4:	687a      	ldr	r2, [r7, #4]
 8001ce6:	18d3      	adds	r3, r2, r3
 8001ce8:	4a0f      	ldr	r2, [pc, #60]	; (8001d28 <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001cea:	1852      	adds	r2, r2, r1
 8001cec:	7912      	ldrb	r2, [r2, #4]
 8001cee:	701a      	strb	r2, [r3, #0]
		m_gsm_modem_buffer.idx_out ++;
 8001cf0:	4b0d      	ldr	r3, [pc, #52]	; (8001d28 <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001cf2:	885b      	ldrh	r3, [r3, #2]
 8001cf4:	3301      	adds	r3, #1
 8001cf6:	b29a      	uxth	r2, r3
 8001cf8:	4b0b      	ldr	r3, [pc, #44]	; (8001d28 <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001cfa:	805a      	strh	r2, [r3, #2]
		if(m_gsm_modem_buffer.idx_out >= GSM_PPP_MODEM_BUFFER_SIZE)
 8001cfc:	4b0a      	ldr	r3, [pc, #40]	; (8001d28 <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001cfe:	885a      	ldrh	r2, [r3, #2]
 8001d00:	2380      	movs	r3, #128	; 0x80
 8001d02:	00db      	lsls	r3, r3, #3
 8001d04:	429a      	cmp	r2, r3
 8001d06:	d302      	bcc.n	8001d0e <GSM_Hardware_layer_Copy_ppp_Buffer+0x56>
		{
			m_gsm_modem_buffer.idx_out = 0;
 8001d08:	4b07      	ldr	r3, [pc, #28]	; (8001d28 <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001d0a:	2200      	movs	r2, #0
 8001d0c:	805a      	strh	r2, [r3, #2]
	for(CountByte = 0; CountByte < length; CountByte++)
 8001d0e:	68fb      	ldr	r3, [r7, #12]
 8001d10:	3301      	adds	r3, #1
 8001d12:	60fb      	str	r3, [r7, #12]
 8001d14:	68fb      	ldr	r3, [r7, #12]
 8001d16:	683a      	ldr	r2, [r7, #0]
 8001d18:	429a      	cmp	r2, r3
 8001d1a:	d8d7      	bhi.n	8001ccc <GSM_Hardware_layer_Copy_ppp_Buffer+0x14>
		}
	}
	return CountByte;
 8001d1c:	68fb      	ldr	r3, [r7, #12]
}
 8001d1e:	0018      	movs	r0, r3
 8001d20:	46bd      	mov	sp, r7
 8001d22:	b004      	add	sp, #16
 8001d24:	bd80      	pop	{r7, pc}
 8001d26:	46c0      	nop			; (mov r8, r8)
 8001d28:	20000610 	.word	0x20000610

08001d2c <GSM_File_Handler_Init>:
    // Query the size of file on FTP server.
    {Get_File_Size_AT_Command, "+QFTPSIZE:", "", "ERROR", "", 6000, 3, GSM_File_Transfer_Seq},
};

void GSM_File_Handler_Init(FTP_Config_TypDef* cfg)
{
 8001d2c:	b5b0      	push	{r4, r5, r7, lr}
 8001d2e:	b086      	sub	sp, #24
 8001d30:	af04      	add	r7, sp, #16
 8001d32:	6078      	str	r0, [r7, #4]
    memcpy(&File_Handler_Config, cfg, sizeof(FTP_Config_TypDef));
 8001d34:	6879      	ldr	r1, [r7, #4]
 8001d36:	4b16      	ldr	r3, [pc, #88]	; (8001d90 <GSM_File_Handler_Init+0x64>)
 8001d38:	2210      	movs	r2, #16
 8001d3a:	0018      	movs	r0, r3
 8001d3c:	f01a ff50 	bl	801cbe0 <memcpy>
    snprintf(Account_Info_AT_Command, sizeof(Account_Info_AT_Command), "%s%s%s%s%s",
 8001d40:	4b13      	ldr	r3, [pc, #76]	; (8001d90 <GSM_File_Handler_Init+0x64>)
 8001d42:	685a      	ldr	r2, [r3, #4]
 8001d44:	4b12      	ldr	r3, [pc, #72]	; (8001d90 <GSM_File_Handler_Init+0x64>)
 8001d46:	689b      	ldr	r3, [r3, #8]
 8001d48:	4d12      	ldr	r5, [pc, #72]	; (8001d94 <GSM_File_Handler_Init+0x68>)
 8001d4a:	4c13      	ldr	r4, [pc, #76]	; (8001d98 <GSM_File_Handler_Init+0x6c>)
 8001d4c:	4813      	ldr	r0, [pc, #76]	; (8001d9c <GSM_File_Handler_Init+0x70>)
 8001d4e:	4914      	ldr	r1, [pc, #80]	; (8001da0 <GSM_File_Handler_Init+0x74>)
 8001d50:	9103      	str	r1, [sp, #12]
 8001d52:	9302      	str	r3, [sp, #8]
 8001d54:	4b13      	ldr	r3, [pc, #76]	; (8001da4 <GSM_File_Handler_Init+0x78>)
 8001d56:	9301      	str	r3, [sp, #4]
 8001d58:	9200      	str	r2, [sp, #0]
 8001d5a:	002b      	movs	r3, r5
 8001d5c:	0022      	movs	r2, r4
 8001d5e:	2146      	movs	r1, #70	; 0x46
 8001d60:	f01b f81c 	bl	801cd9c <sniprintf>
                                                                    "AT+QFTPCFG=\"account\",\"",
                                                                    File_Handler_Config.Username,
                                                                    "\",\"",
                                                                    File_Handler_Config.Password,
                                                                    "\"\r\n");
    snprintf(FTP_Server_Login_Info_AT_Command, sizeof(FTP_Server_Login_Info_AT_Command), "%s%s%s%lu%s",
 8001d64:	4b0a      	ldr	r3, [pc, #40]	; (8001d90 <GSM_File_Handler_Init+0x64>)
 8001d66:	681a      	ldr	r2, [r3, #0]
 8001d68:	4b09      	ldr	r3, [pc, #36]	; (8001d90 <GSM_File_Handler_Init+0x64>)
 8001d6a:	68db      	ldr	r3, [r3, #12]
 8001d6c:	4d0e      	ldr	r5, [pc, #56]	; (8001da8 <GSM_File_Handler_Init+0x7c>)
 8001d6e:	4c0f      	ldr	r4, [pc, #60]	; (8001dac <GSM_File_Handler_Init+0x80>)
 8001d70:	480f      	ldr	r0, [pc, #60]	; (8001db0 <GSM_File_Handler_Init+0x84>)
 8001d72:	4910      	ldr	r1, [pc, #64]	; (8001db4 <GSM_File_Handler_Init+0x88>)
 8001d74:	9103      	str	r1, [sp, #12]
 8001d76:	9302      	str	r3, [sp, #8]
 8001d78:	4b0f      	ldr	r3, [pc, #60]	; (8001db8 <GSM_File_Handler_Init+0x8c>)
 8001d7a:	9301      	str	r3, [sp, #4]
 8001d7c:	9200      	str	r2, [sp, #0]
 8001d7e:	002b      	movs	r3, r5
 8001d80:	0022      	movs	r2, r4
 8001d82:	2146      	movs	r1, #70	; 0x46
 8001d84:	f01b f80a 	bl	801cd9c <sniprintf>
                                                                    "AT+QFTPOPEN=\"",
                                                                    File_Handler_Config.Hostname,
                                                                    "\",",
                                                                    File_Handler_Config.Port,
                                                                    "\r\n");
}
 8001d88:	46c0      	nop			; (mov r8, r8)
 8001d8a:	46bd      	mov	sp, r7
 8001d8c:	b002      	add	sp, #8
 8001d8e:	bdb0      	pop	{r4, r5, r7, pc}
 8001d90:	20000db8 	.word	0x20000db8
 8001d94:	0801e490 	.word	0x0801e490
 8001d98:	0801e4a8 	.word	0x0801e4a8
 8001d9c:	20000c1c 	.word	0x20000c1c
 8001da0:	0801e4b4 	.word	0x0801e4b4
 8001da4:	0801e4b8 	.word	0x0801e4b8
 8001da8:	0801e4bc 	.word	0x0801e4bc
 8001dac:	0801e4cc 	.word	0x0801e4cc
 8001db0:	20000c64 	.word	0x20000c64
 8001db4:	0801e4d8 	.word	0x0801e4d8
 8001db8:	0801e4dc 	.word	0x0801e4dc

08001dbc <GSM_FileSend_Handler>:
// Xu ly File Send ( Neu File chua ton tai tren server-> tao moi, neu da ton tai -> append)
void GSM_FileSend_Handler(GSM_Response_Event_TypDef event, void *Resp_Buffer)
{
 8001dbc:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001dbe:	b091      	sub	sp, #68	; 0x44
 8001dc0:	af06      	add	r7, sp, #24
 8001dc2:	0002      	movs	r2, r0
 8001dc4:	6039      	str	r1, [r7, #0]
 8001dc6:	1dfb      	adds	r3, r7, #7
 8001dc8:	701a      	strb	r2, [r3, #0]
    static uint8_t step = 0;
    switch (step)
 8001dca:	4b6e      	ldr	r3, [pc, #440]	; (8001f84 <GSM_FileSend_Handler+0x1c8>)
 8001dcc:	781b      	ldrb	r3, [r3, #0]
 8001dce:	2b00      	cmp	r3, #0
 8001dd0:	d002      	beq.n	8001dd8 <GSM_FileSend_Handler+0x1c>
 8001dd2:	2b01      	cmp	r3, #1
 8001dd4:	d061      	beq.n	8001e9a <GSM_FileSend_Handler+0xde>
        {
            GSM_Manager_ChangeState(GSM_STATE_RESET);
        }
        break;
    default:
        break;
 8001dd6:	e0d0      	b.n	8001f7a <GSM_FileSend_Handler+0x1be>
        if(event != GSM_EVENT_OK)
 8001dd8:	1dfb      	adds	r3, r7, #7
 8001dda:	781b      	ldrb	r3, [r3, #0]
 8001ddc:	2b00      	cmp	r3, #0
 8001dde:	d007      	beq.n	8001df0 <GSM_FileSend_Handler+0x34>
            GSM_File_Transfer_Seq(event, &Resp_Buffer);
 8001de0:	003a      	movs	r2, r7
 8001de2:	1dfb      	adds	r3, r7, #7
 8001de4:	781b      	ldrb	r3, [r3, #0]
 8001de6:	0011      	movs	r1, r2
 8001de8:	0018      	movs	r0, r3
 8001dea:	f000 f97d 	bl	80020e8 <GSM_File_Transfer_Seq>
        break;
 8001dee:	e0c4      	b.n	8001f7a <GSM_FileSend_Handler+0x1be>
            DEBUG_RAW("%s\r\n", (char*)Resp_Buffer);
 8001df0:	683a      	ldr	r2, [r7, #0]
 8001df2:	4b65      	ldr	r3, [pc, #404]	; (8001f88 <GSM_FileSend_Handler+0x1cc>)
 8001df4:	0011      	movs	r1, r2
 8001df6:	0018      	movs	r0, r3
 8001df8:	f000 fd70 	bl	80028dc <app_debug_rtt_raw>
            if(gsm_utilities_is_file_exist(FileSend_Info.File[FileSend_Info.FileID].Name, (char*)Resp_Buffer))
 8001dfc:	4b63      	ldr	r3, [pc, #396]	; (8001f8c <GSM_FileSend_Handler+0x1d0>)
 8001dfe:	22c9      	movs	r2, #201	; 0xc9
 8001e00:	5c9b      	ldrb	r3, [r3, r2]
 8001e02:	0019      	movs	r1, r3
 8001e04:	4a61      	ldr	r2, [pc, #388]	; (8001f8c <GSM_FileSend_Handler+0x1d0>)
 8001e06:	000b      	movs	r3, r1
 8001e08:	009b      	lsls	r3, r3, #2
 8001e0a:	185b      	adds	r3, r3, r1
 8001e0c:	009b      	lsls	r3, r3, #2
 8001e0e:	18d3      	adds	r3, r2, r3
 8001e10:	3308      	adds	r3, #8
 8001e12:	681b      	ldr	r3, [r3, #0]
 8001e14:	683a      	ldr	r2, [r7, #0]
 8001e16:	0011      	movs	r1, r2
 8001e18:	0018      	movs	r0, r3
 8001e1a:	f000 fb6e 	bl	80024fa <gsm_utilities_is_file_exist>
 8001e1e:	1e03      	subs	r3, r0, #0
 8001e20:	d01e      	beq.n	8001e60 <GSM_FileSend_Handler+0xa4>
                GSM_ATCommand_Table_TypDef AT_Command = 
 8001e22:	2108      	movs	r1, #8
 8001e24:	187b      	adds	r3, r7, r1
 8001e26:	4a5a      	ldr	r2, [pc, #360]	; (8001f90 <GSM_FileSend_Handler+0x1d4>)
 8001e28:	ca31      	ldmia	r2!, {r0, r4, r5}
 8001e2a:	c331      	stmia	r3!, {r0, r4, r5}
 8001e2c:	ca31      	ldmia	r2!, {r0, r4, r5}
 8001e2e:	c331      	stmia	r3!, {r0, r4, r5}
 8001e30:	ca11      	ldmia	r2!, {r0, r4}
 8001e32:	c311      	stmia	r3!, {r0, r4}
                GSM_SendCommand_AT(AT_Command);
 8001e34:	187b      	adds	r3, r7, r1
 8001e36:	466a      	mov	r2, sp
 8001e38:	0011      	movs	r1, r2
 8001e3a:	001a      	movs	r2, r3
 8001e3c:	3210      	adds	r2, #16
 8001e3e:	ca31      	ldmia	r2!, {r0, r4, r5}
 8001e40:	c131      	stmia	r1!, {r0, r4, r5}
 8001e42:	6812      	ldr	r2, [r2, #0]
 8001e44:	600a      	str	r2, [r1, #0]
 8001e46:	6818      	ldr	r0, [r3, #0]
 8001e48:	6859      	ldr	r1, [r3, #4]
 8001e4a:	689a      	ldr	r2, [r3, #8]
 8001e4c:	68db      	ldr	r3, [r3, #12]
 8001e4e:	f7ff fda7 	bl	80019a0 <GSM_SendCommand_AT>
                step++;
 8001e52:	4b4c      	ldr	r3, [pc, #304]	; (8001f84 <GSM_FileSend_Handler+0x1c8>)
 8001e54:	781b      	ldrb	r3, [r3, #0]
 8001e56:	3301      	adds	r3, #1
 8001e58:	b2da      	uxtb	r2, r3
 8001e5a:	4b4a      	ldr	r3, [pc, #296]	; (8001f84 <GSM_FileSend_Handler+0x1c8>)
 8001e5c:	701a      	strb	r2, [r3, #0]
        break;
 8001e5e:	e08c      	b.n	8001f7a <GSM_FileSend_Handler+0x1be>
                FileSend_Info.File[FileSend_Info.FileID].Index = 0;
 8001e60:	4b4a      	ldr	r3, [pc, #296]	; (8001f8c <GSM_FileSend_Handler+0x1d0>)
 8001e62:	22c9      	movs	r2, #201	; 0xc9
 8001e64:	5c9b      	ldrb	r3, [r3, r2]
 8001e66:	0019      	movs	r1, r3
 8001e68:	4a48      	ldr	r2, [pc, #288]	; (8001f8c <GSM_FileSend_Handler+0x1d0>)
 8001e6a:	000b      	movs	r3, r1
 8001e6c:	009b      	lsls	r3, r3, #2
 8001e6e:	185b      	adds	r3, r3, r1
 8001e70:	009b      	lsls	r3, r3, #2
 8001e72:	18d3      	adds	r3, r2, r3
 8001e74:	3310      	adds	r3, #16
 8001e76:	2200      	movs	r2, #0
 8001e78:	801a      	strh	r2, [r3, #0]
                DEBUG_INFO("File does not exist -> Create new file!\r\n");
 8001e7a:	f01a fe57 	bl	801cb2c <sys_get_tick_ms>
 8001e7e:	0001      	movs	r1, r0
 8001e80:	4a44      	ldr	r2, [pc, #272]	; (8001f94 <GSM_FileSend_Handler+0x1d8>)
 8001e82:	4b45      	ldr	r3, [pc, #276]	; (8001f98 <GSM_FileSend_Handler+0x1dc>)
 8001e84:	0018      	movs	r0, r3
 8001e86:	f000 fd29 	bl	80028dc <app_debug_rtt_raw>
                GSM_File_Transfer_Seq(event, &Resp_Buffer);
 8001e8a:	003a      	movs	r2, r7
 8001e8c:	1dfb      	adds	r3, r7, #7
 8001e8e:	781b      	ldrb	r3, [r3, #0]
 8001e90:	0011      	movs	r1, r2
 8001e92:	0018      	movs	r0, r3
 8001e94:	f000 f928 	bl	80020e8 <GSM_File_Transfer_Seq>
        break;
 8001e98:	e06f      	b.n	8001f7a <GSM_FileSend_Handler+0x1be>
        if(event == GSM_EVENT_OK)
 8001e9a:	1dfb      	adds	r3, r7, #7
 8001e9c:	781b      	ldrb	r3, [r3, #0]
 8001e9e:	2b00      	cmp	r3, #0
 8001ea0:	d167      	bne.n	8001f72 <GSM_FileSend_Handler+0x1b6>
            step = 0;
 8001ea2:	4b38      	ldr	r3, [pc, #224]	; (8001f84 <GSM_FileSend_Handler+0x1c8>)
 8001ea4:	2200      	movs	r2, #0
 8001ea6:	701a      	strb	r2, [r3, #0]
            FileSend_Info.File[FileSend_Info.FileID].Index = gsm_utilities_get_number_from_string(21, (char*)Resp_Buffer);
 8001ea8:	683a      	ldr	r2, [r7, #0]
 8001eaa:	4b38      	ldr	r3, [pc, #224]	; (8001f8c <GSM_FileSend_Handler+0x1d0>)
 8001eac:	21c9      	movs	r1, #201	; 0xc9
 8001eae:	5c5b      	ldrb	r3, [r3, r1]
 8001eb0:	001c      	movs	r4, r3
 8001eb2:	0011      	movs	r1, r2
 8001eb4:	2015      	movs	r0, #21
 8001eb6:	f000 facb 	bl	8002450 <gsm_utilities_get_number_from_string>
 8001eba:	0003      	movs	r3, r0
 8001ebc:	0019      	movs	r1, r3
 8001ebe:	4a33      	ldr	r2, [pc, #204]	; (8001f8c <GSM_FileSend_Handler+0x1d0>)
 8001ec0:	0023      	movs	r3, r4
 8001ec2:	009b      	lsls	r3, r3, #2
 8001ec4:	191b      	adds	r3, r3, r4
 8001ec6:	009b      	lsls	r3, r3, #2
 8001ec8:	18d3      	adds	r3, r2, r3
 8001eca:	3310      	adds	r3, #16
 8001ecc:	1c0a      	adds	r2, r1, #0
 8001ece:	801a      	strh	r2, [r3, #0]
            DEBUG_INFO("File exist, size %d bytes.\r\n", FileSend_Info.File[FileSend_Info.FileID].Index);
 8001ed0:	f01a fe2c 	bl	801cb2c <sys_get_tick_ms>
 8001ed4:	0001      	movs	r1, r0
 8001ed6:	4b2d      	ldr	r3, [pc, #180]	; (8001f8c <GSM_FileSend_Handler+0x1d0>)
 8001ed8:	22c9      	movs	r2, #201	; 0xc9
 8001eda:	5c9b      	ldrb	r3, [r3, r2]
 8001edc:	0018      	movs	r0, r3
 8001ede:	4a2b      	ldr	r2, [pc, #172]	; (8001f8c <GSM_FileSend_Handler+0x1d0>)
 8001ee0:	0003      	movs	r3, r0
 8001ee2:	009b      	lsls	r3, r3, #2
 8001ee4:	181b      	adds	r3, r3, r0
 8001ee6:	009b      	lsls	r3, r3, #2
 8001ee8:	18d3      	adds	r3, r2, r3
 8001eea:	3310      	adds	r3, #16
 8001eec:	881b      	ldrh	r3, [r3, #0]
 8001eee:	4a29      	ldr	r2, [pc, #164]	; (8001f94 <GSM_FileSend_Handler+0x1d8>)
 8001ef0:	482a      	ldr	r0, [pc, #168]	; (8001f9c <GSM_FileSend_Handler+0x1e0>)
 8001ef2:	f000 fcf3 	bl	80028dc <app_debug_rtt_raw>
                                                        FileSend_Info.File[FileSend_Info.FileID].Name,
 8001ef6:	4b25      	ldr	r3, [pc, #148]	; (8001f8c <GSM_FileSend_Handler+0x1d0>)
 8001ef8:	22c9      	movs	r2, #201	; 0xc9
 8001efa:	5c9b      	ldrb	r3, [r3, r2]
 8001efc:	0019      	movs	r1, r3
            snprintf(Upload_File_AT_Command, sizeof(Upload_File_AT_Command), "%s%s%s%d%s%d%s",
 8001efe:	4a23      	ldr	r2, [pc, #140]	; (8001f8c <GSM_FileSend_Handler+0x1d0>)
 8001f00:	000b      	movs	r3, r1
 8001f02:	009b      	lsls	r3, r3, #2
 8001f04:	185b      	adds	r3, r3, r1
 8001f06:	009b      	lsls	r3, r3, #2
 8001f08:	18d3      	adds	r3, r2, r3
 8001f0a:	3308      	adds	r3, #8
 8001f0c:	681a      	ldr	r2, [r3, #0]
                                                        FileSend_Info.File[FileSend_Info.FileID].Index,
 8001f0e:	4b1f      	ldr	r3, [pc, #124]	; (8001f8c <GSM_FileSend_Handler+0x1d0>)
 8001f10:	21c9      	movs	r1, #201	; 0xc9
 8001f12:	5c5b      	ldrb	r3, [r3, r1]
 8001f14:	0018      	movs	r0, r3
 8001f16:	491d      	ldr	r1, [pc, #116]	; (8001f8c <GSM_FileSend_Handler+0x1d0>)
 8001f18:	0003      	movs	r3, r0
 8001f1a:	009b      	lsls	r3, r3, #2
 8001f1c:	181b      	adds	r3, r3, r0
 8001f1e:	009b      	lsls	r3, r3, #2
 8001f20:	18cb      	adds	r3, r1, r3
 8001f22:	3310      	adds	r3, #16
 8001f24:	881b      	ldrh	r3, [r3, #0]
            snprintf(Upload_File_AT_Command, sizeof(Upload_File_AT_Command), "%s%s%s%d%s%d%s",
 8001f26:	001d      	movs	r5, r3
                                                        FileSend_Info.File[FileSend_Info.FileID].DataLength,
 8001f28:	4b18      	ldr	r3, [pc, #96]	; (8001f8c <GSM_FileSend_Handler+0x1d0>)
 8001f2a:	21c9      	movs	r1, #201	; 0xc9
 8001f2c:	5c5b      	ldrb	r3, [r3, r1]
 8001f2e:	0018      	movs	r0, r3
 8001f30:	4916      	ldr	r1, [pc, #88]	; (8001f8c <GSM_FileSend_Handler+0x1d0>)
 8001f32:	0003      	movs	r3, r0
 8001f34:	009b      	lsls	r3, r3, #2
 8001f36:	181b      	adds	r3, r3, r0
 8001f38:	009b      	lsls	r3, r3, #2
 8001f3a:	18cb      	adds	r3, r1, r3
 8001f3c:	3304      	adds	r3, #4
 8001f3e:	881b      	ldrh	r3, [r3, #0]
            snprintf(Upload_File_AT_Command, sizeof(Upload_File_AT_Command), "%s%s%s%d%s%d%s",
 8001f40:	001e      	movs	r6, r3
 8001f42:	4c17      	ldr	r4, [pc, #92]	; (8001fa0 <GSM_FileSend_Handler+0x1e4>)
 8001f44:	4917      	ldr	r1, [pc, #92]	; (8001fa4 <GSM_FileSend_Handler+0x1e8>)
 8001f46:	4818      	ldr	r0, [pc, #96]	; (8001fa8 <GSM_FileSend_Handler+0x1ec>)
 8001f48:	4b18      	ldr	r3, [pc, #96]	; (8001fac <GSM_FileSend_Handler+0x1f0>)
 8001f4a:	9305      	str	r3, [sp, #20]
 8001f4c:	9604      	str	r6, [sp, #16]
 8001f4e:	4b18      	ldr	r3, [pc, #96]	; (8001fb0 <GSM_FileSend_Handler+0x1f4>)
 8001f50:	9303      	str	r3, [sp, #12]
 8001f52:	9502      	str	r5, [sp, #8]
 8001f54:	4b17      	ldr	r3, [pc, #92]	; (8001fb4 <GSM_FileSend_Handler+0x1f8>)
 8001f56:	9301      	str	r3, [sp, #4]
 8001f58:	9200      	str	r2, [sp, #0]
 8001f5a:	0023      	movs	r3, r4
 8001f5c:	000a      	movs	r2, r1
 8001f5e:	2146      	movs	r1, #70	; 0x46
 8001f60:	f01a ff1c 	bl	801cd9c <sniprintf>
            GSM_File_Transfer_Seq(event, NULL);
 8001f64:	1dfb      	adds	r3, r7, #7
 8001f66:	781b      	ldrb	r3, [r3, #0]
 8001f68:	2100      	movs	r1, #0
 8001f6a:	0018      	movs	r0, r3
 8001f6c:	f000 f8bc 	bl	80020e8 <GSM_File_Transfer_Seq>
        break;
 8001f70:	e002      	b.n	8001f78 <GSM_FileSend_Handler+0x1bc>
            GSM_Manager_ChangeState(GSM_STATE_RESET);
 8001f72:	2001      	movs	r0, #1
 8001f74:	f7ff f9da 	bl	800132c <GSM_Manager_ChangeState>
        break;
 8001f78:	46c0      	nop			; (mov r8, r8)
    } 
}
 8001f7a:	46c0      	nop			; (mov r8, r8)
 8001f7c:	46bd      	mov	sp, r7
 8001f7e:	b00b      	add	sp, #44	; 0x2c
 8001f80:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001f82:	46c0      	nop			; (mov r8, r8)
 8001f84:	20000e98 	.word	0x20000e98
 8001f88:	0801e4e0 	.word	0x0801e4e0
 8001f8c:	20000dcc 	.word	0x20000dcc
 8001f90:	0801e59c 	.word	0x0801e59c
 8001f94:	0801e348 	.word	0x0801e348
 8001f98:	0801e4e8 	.word	0x0801e4e8
 8001f9c:	0801e52c 	.word	0x0801e52c
 8001fa0:	0801e564 	.word	0x0801e564
 8001fa4:	0801e574 	.word	0x0801e574
 8001fa8:	20000cac 	.word	0x20000cac
 8001fac:	0801e584 	.word	0x0801e584
 8001fb0:	0801e58c 	.word	0x0801e58c
 8001fb4:	0801e590 	.word	0x0801e590

08001fb8 <GSM_Login_Server_Seq>:
void GSM_Login_Server_Seq(GSM_Response_Event_TypDef event, void *Resp_Buffer)
{
 8001fb8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001fba:	b089      	sub	sp, #36	; 0x24
 8001fbc:	af04      	add	r7, sp, #16
 8001fbe:	0002      	movs	r2, r0
 8001fc0:	6039      	str	r1, [r7, #0]
 8001fc2:	1dfb      	adds	r3, r7, #7
 8001fc4:	701a      	strb	r2, [r3, #0]
    uint8_t TableIndex = File_Handler_Manager.step;
 8001fc6:	210f      	movs	r1, #15
 8001fc8:	187b      	adds	r3, r7, r1
 8001fca:	4a3d      	ldr	r2, [pc, #244]	; (80020c0 <GSM_Login_Server_Seq+0x108>)
 8001fcc:	7852      	ldrb	r2, [r2, #1]
 8001fce:	701a      	strb	r2, [r3, #0]
    const static uint8_t TableSize = sizeof(ATC_Table_Login_Server)/sizeof(ATC_Table_Login_Server[0]);
    if(TableIndex > TableSize)
 8001fd0:	4b3c      	ldr	r3, [pc, #240]	; (80020c4 <GSM_Login_Server_Seq+0x10c>)
 8001fd2:	781b      	ldrb	r3, [r3, #0]
 8001fd4:	187a      	adds	r2, r7, r1
 8001fd6:	7812      	ldrb	r2, [r2, #0]
 8001fd8:	429a      	cmp	r2, r3
 8001fda:	d86d      	bhi.n	80020b8 <GSM_Login_Server_Seq+0x100>
    {
        return;
    }
    DEBUG_PrintResult_ATC(ATC_Table_Login_Server[TableIndex-1].cmd, (event == GSM_EVENT_OK)?"[OK]":"[FAIL]");
 8001fdc:	187b      	adds	r3, r7, r1
 8001fde:	781b      	ldrb	r3, [r3, #0]
 8001fe0:	1e5a      	subs	r2, r3, #1
 8001fe2:	4b39      	ldr	r3, [pc, #228]	; (80020c8 <GSM_Login_Server_Seq+0x110>)
 8001fe4:	0152      	lsls	r2, r2, #5
 8001fe6:	58d2      	ldr	r2, [r2, r3]
 8001fe8:	1dfb      	adds	r3, r7, #7
 8001fea:	781b      	ldrb	r3, [r3, #0]
 8001fec:	2b00      	cmp	r3, #0
 8001fee:	d101      	bne.n	8001ff4 <GSM_Login_Server_Seq+0x3c>
 8001ff0:	4b36      	ldr	r3, [pc, #216]	; (80020cc <GSM_Login_Server_Seq+0x114>)
 8001ff2:	e000      	b.n	8001ff6 <GSM_Login_Server_Seq+0x3e>
 8001ff4:	4b36      	ldr	r3, [pc, #216]	; (80020d0 <GSM_Login_Server_Seq+0x118>)
 8001ff6:	0019      	movs	r1, r3
 8001ff8:	0010      	movs	r0, r2
 8001ffa:	f000 fa9f 	bl	800253c <DEBUG_PrintResult_ATC>
    DEBUG_RAW("%s\r\n", (char*)Resp_Buffer);
 8001ffe:	683a      	ldr	r2, [r7, #0]
 8002000:	4b34      	ldr	r3, [pc, #208]	; (80020d4 <GSM_Login_Server_Seq+0x11c>)
 8002002:	0011      	movs	r1, r2
 8002004:	0018      	movs	r0, r3
 8002006:	f000 fc69 	bl	80028dc <app_debug_rtt_raw>
    if(event == GSM_EVENT_OK)
 800200a:	1dfb      	adds	r3, r7, #7
 800200c:	781b      	ldrb	r3, [r3, #0]
 800200e:	2b00      	cmp	r3, #0
 8002010:	d153      	bne.n	80020ba <GSM_Login_Server_Seq+0x102>
    {
        if(TableIndex < TableSize)
 8002012:	4b2c      	ldr	r3, [pc, #176]	; (80020c4 <GSM_Login_Server_Seq+0x10c>)
 8002014:	781b      	ldrb	r3, [r3, #0]
 8002016:	210f      	movs	r1, #15
 8002018:	187a      	adds	r2, r7, r1
 800201a:	7812      	ldrb	r2, [r2, #0]
 800201c:	429a      	cmp	r2, r3
 800201e:	d215      	bcs.n	800204c <GSM_Login_Server_Seq+0x94>
        {
            GSM_SendCommand_AT(ATC_Table_Login_Server[TableIndex]);
 8002020:	187b      	adds	r3, r7, r1
 8002022:	781b      	ldrb	r3, [r3, #0]
 8002024:	4c28      	ldr	r4, [pc, #160]	; (80020c8 <GSM_Login_Server_Seq+0x110>)
 8002026:	015b      	lsls	r3, r3, #5
 8002028:	2110      	movs	r1, #16
 800202a:	18e2      	adds	r2, r4, r3
 800202c:	1851      	adds	r1, r2, r1
 800202e:	466a      	mov	r2, sp
 8002030:	c961      	ldmia	r1!, {r0, r5, r6}
 8002032:	c261      	stmia	r2!, {r0, r5, r6}
 8002034:	6809      	ldr	r1, [r1, #0]
 8002036:	6011      	str	r1, [r2, #0]
 8002038:	5918      	ldr	r0, [r3, r4]
 800203a:	18e2      	adds	r2, r4, r3
 800203c:	6851      	ldr	r1, [r2, #4]
 800203e:	18e2      	adds	r2, r4, r3
 8002040:	6892      	ldr	r2, [r2, #8]
 8002042:	18e3      	adds	r3, r4, r3
 8002044:	68db      	ldr	r3, [r3, #12]
 8002046:	f7ff fcab 	bl	80019a0 <GSM_SendCommand_AT>
 800204a:	e02e      	b.n	80020aa <GSM_Login_Server_Seq+0xf2>
        }
        else
        {
            // Da Login Server xong
            File_Handler_Manager.step = 0;
 800204c:	4b1c      	ldr	r3, [pc, #112]	; (80020c0 <GSM_Login_Server_Seq+0x108>)
 800204e:	2200      	movs	r2, #0
 8002050:	705a      	strb	r2, [r3, #1]
            DEBUG_INFO("Log in server DONE.\r\n");
 8002052:	f01a fd6b 	bl	801cb2c <sys_get_tick_ms>
 8002056:	0001      	movs	r1, r0
 8002058:	4a1f      	ldr	r2, [pc, #124]	; (80020d8 <GSM_Login_Server_Seq+0x120>)
 800205a:	4b20      	ldr	r3, [pc, #128]	; (80020dc <GSM_Login_Server_Seq+0x124>)
 800205c:	0018      	movs	r0, r3
 800205e:	f000 fc3d 	bl	80028dc <app_debug_rtt_raw>
            if(File_Handler_Manager.mode == GSM_FILE_MODE_UPLOAD)
 8002062:	4b17      	ldr	r3, [pc, #92]	; (80020c0 <GSM_Login_Server_Seq+0x108>)
 8002064:	781b      	ldrb	r3, [r3, #0]
 8002066:	2b00      	cmp	r3, #0
 8002068:	d11f      	bne.n	80020aa <GSM_Login_Server_Seq+0xf2>
            {
                // Chuyen sang Mode Download
                FileSend_Info.FileID = 0;
 800206a:	4b1d      	ldr	r3, [pc, #116]	; (80020e0 <GSM_Login_Server_Seq+0x128>)
 800206c:	22c9      	movs	r2, #201	; 0xc9
 800206e:	2100      	movs	r1, #0
 8002070:	5499      	strb	r1, [r3, r2]
                GSM_Add_FileInfo_to_AT_Command(&FileSend_Info.File[FileSend_Info.FileID]);
 8002072:	4b1b      	ldr	r3, [pc, #108]	; (80020e0 <GSM_Login_Server_Seq+0x128>)
 8002074:	22c9      	movs	r2, #201	; 0xc9
 8002076:	5c9b      	ldrb	r3, [r3, r2]
 8002078:	001a      	movs	r2, r3
 800207a:	0013      	movs	r3, r2
 800207c:	009b      	lsls	r3, r3, #2
 800207e:	189b      	adds	r3, r3, r2
 8002080:	009b      	lsls	r3, r3, #2
 8002082:	4a17      	ldr	r2, [pc, #92]	; (80020e0 <GSM_Login_Server_Seq+0x128>)
 8002084:	189b      	adds	r3, r3, r2
 8002086:	0018      	movs	r0, r3
 8002088:	f000 f8ea 	bl	8002260 <GSM_Add_FileInfo_to_AT_Command>
                GSM_SendCommand_AT(ATC_Table_File_Tranfer[0]);
 800208c:	4b15      	ldr	r3, [pc, #84]	; (80020e4 <GSM_Login_Server_Seq+0x12c>)
 800208e:	466a      	mov	r2, sp
 8002090:	0011      	movs	r1, r2
 8002092:	001a      	movs	r2, r3
 8002094:	3210      	adds	r2, #16
 8002096:	ca31      	ldmia	r2!, {r0, r4, r5}
 8002098:	c131      	stmia	r1!, {r0, r4, r5}
 800209a:	6812      	ldr	r2, [r2, #0]
 800209c:	600a      	str	r2, [r1, #0]
 800209e:	6818      	ldr	r0, [r3, #0]
 80020a0:	6859      	ldr	r1, [r3, #4]
 80020a2:	689a      	ldr	r2, [r3, #8]
 80020a4:	68db      	ldr	r3, [r3, #12]
 80020a6:	f7ff fc7b 	bl	80019a0 <GSM_SendCommand_AT>
            }
        }
        File_Handler_Manager.step++;
 80020aa:	4b05      	ldr	r3, [pc, #20]	; (80020c0 <GSM_Login_Server_Seq+0x108>)
 80020ac:	785b      	ldrb	r3, [r3, #1]
 80020ae:	3301      	adds	r3, #1
 80020b0:	b2da      	uxtb	r2, r3
 80020b2:	4b03      	ldr	r3, [pc, #12]	; (80020c0 <GSM_Login_Server_Seq+0x108>)
 80020b4:	705a      	strb	r2, [r3, #1]
 80020b6:	e000      	b.n	80020ba <GSM_Login_Server_Seq+0x102>
        return;
 80020b8:	46c0      	nop			; (mov r8, r8)
    }
    else //if(event == GSM_EVENT_TIMEOUT)
    {
        //GSM_Manager_ChangeState(GSM_STATE_RESET);
    }
}
 80020ba:	46bd      	mov	sp, r7
 80020bc:	b005      	add	sp, #20
 80020be:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80020c0:	20000dc8 	.word	0x20000dc8
 80020c4:	08022344 	.word	0x08022344
 80020c8:	08022164 	.word	0x08022164
 80020cc:	0801e5bc 	.word	0x0801e5bc
 80020d0:	0801e5c4 	.word	0x0801e5c4
 80020d4:	0801e4e0 	.word	0x0801e4e0
 80020d8:	0801e348 	.word	0x0801e348
 80020dc:	0801e5cc 	.word	0x0801e5cc
 80020e0:	20000dcc 	.word	0x20000dcc
 80020e4:	08022264 	.word	0x08022264

080020e8 <GSM_File_Transfer_Seq>:
void GSM_File_Transfer_Seq(GSM_Response_Event_TypDef event, void *Resp_Buffer)
{
 80020e8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80020ea:	b089      	sub	sp, #36	; 0x24
 80020ec:	af04      	add	r7, sp, #16
 80020ee:	0002      	movs	r2, r0
 80020f0:	6039      	str	r1, [r7, #0]
 80020f2:	1dfb      	adds	r3, r7, #7
 80020f4:	701a      	strb	r2, [r3, #0]
    uint8_t TableIndex = File_Handler_Manager.step;
 80020f6:	210f      	movs	r1, #15
 80020f8:	187b      	adds	r3, r7, r1
 80020fa:	4a4f      	ldr	r2, [pc, #316]	; (8002238 <GSM_File_Transfer_Seq+0x150>)
 80020fc:	7852      	ldrb	r2, [r2, #1]
 80020fe:	701a      	strb	r2, [r3, #0]
    const static uint8_t TableSize = sizeof(ATC_Table_File_Tranfer)/sizeof(ATC_Table_File_Tranfer[0]);
    if(TableIndex > TableSize)
 8002100:	4b4e      	ldr	r3, [pc, #312]	; (800223c <GSM_File_Transfer_Seq+0x154>)
 8002102:	781b      	ldrb	r3, [r3, #0]
 8002104:	187a      	adds	r2, r7, r1
 8002106:	7812      	ldrb	r2, [r2, #0]
 8002108:	429a      	cmp	r2, r3
 800210a:	d900      	bls.n	800210e <GSM_File_Transfer_Seq+0x26>
 800210c:	e090      	b.n	8002230 <GSM_File_Transfer_Seq+0x148>
    {
        return;
    }
    DEBUG_PrintResult_ATC(ATC_Table_File_Tranfer[TableIndex-1].cmd, (event == GSM_EVENT_OK)?"[OK]":"[FAIL]");
 800210e:	187b      	adds	r3, r7, r1
 8002110:	781b      	ldrb	r3, [r3, #0]
 8002112:	1e5a      	subs	r2, r3, #1
 8002114:	4b4a      	ldr	r3, [pc, #296]	; (8002240 <GSM_File_Transfer_Seq+0x158>)
 8002116:	0152      	lsls	r2, r2, #5
 8002118:	58d2      	ldr	r2, [r2, r3]
 800211a:	1dfb      	adds	r3, r7, #7
 800211c:	781b      	ldrb	r3, [r3, #0]
 800211e:	2b00      	cmp	r3, #0
 8002120:	d101      	bne.n	8002126 <GSM_File_Transfer_Seq+0x3e>
 8002122:	4b48      	ldr	r3, [pc, #288]	; (8002244 <GSM_File_Transfer_Seq+0x15c>)
 8002124:	e000      	b.n	8002128 <GSM_File_Transfer_Seq+0x40>
 8002126:	4b48      	ldr	r3, [pc, #288]	; (8002248 <GSM_File_Transfer_Seq+0x160>)
 8002128:	0019      	movs	r1, r3
 800212a:	0010      	movs	r0, r2
 800212c:	f000 fa06 	bl	800253c <DEBUG_PrintResult_ATC>
    DEBUG_RAW("%s\r\n", (char*)Resp_Buffer);
 8002130:	683a      	ldr	r2, [r7, #0]
 8002132:	4b46      	ldr	r3, [pc, #280]	; (800224c <GSM_File_Transfer_Seq+0x164>)
 8002134:	0011      	movs	r1, r2
 8002136:	0018      	movs	r0, r3
 8002138:	f000 fbd0 	bl	80028dc <app_debug_rtt_raw>
    if(event == GSM_EVENT_OK)
 800213c:	1dfb      	adds	r3, r7, #7
 800213e:	781b      	ldrb	r3, [r3, #0]
 8002140:	2b00      	cmp	r3, #0
 8002142:	d176      	bne.n	8002232 <GSM_File_Transfer_Seq+0x14a>
    {
        if(TableIndex < TableSize)
 8002144:	4b3d      	ldr	r3, [pc, #244]	; (800223c <GSM_File_Transfer_Seq+0x154>)
 8002146:	781b      	ldrb	r3, [r3, #0]
 8002148:	210f      	movs	r1, #15
 800214a:	187a      	adds	r2, r7, r1
 800214c:	7812      	ldrb	r2, [r2, #0]
 800214e:	429a      	cmp	r2, r3
 8002150:	d215      	bcs.n	800217e <GSM_File_Transfer_Seq+0x96>
        {
            GSM_SendCommand_AT(ATC_Table_File_Tranfer[TableIndex]);
 8002152:	187b      	adds	r3, r7, r1
 8002154:	781b      	ldrb	r3, [r3, #0]
 8002156:	4c3a      	ldr	r4, [pc, #232]	; (8002240 <GSM_File_Transfer_Seq+0x158>)
 8002158:	015b      	lsls	r3, r3, #5
 800215a:	2110      	movs	r1, #16
 800215c:	18e2      	adds	r2, r4, r3
 800215e:	1851      	adds	r1, r2, r1
 8002160:	466a      	mov	r2, sp
 8002162:	c961      	ldmia	r1!, {r0, r5, r6}
 8002164:	c261      	stmia	r2!, {r0, r5, r6}
 8002166:	6809      	ldr	r1, [r1, #0]
 8002168:	6011      	str	r1, [r2, #0]
 800216a:	5918      	ldr	r0, [r3, r4]
 800216c:	18e2      	adds	r2, r4, r3
 800216e:	6851      	ldr	r1, [r2, #4]
 8002170:	18e2      	adds	r2, r4, r3
 8002172:	6892      	ldr	r2, [r2, #8]
 8002174:	18e3      	adds	r3, r4, r3
 8002176:	68db      	ldr	r3, [r3, #12]
 8002178:	f7ff fc12 	bl	80019a0 <GSM_SendCommand_AT>
 800217c:	e051      	b.n	8002222 <GSM_File_Transfer_Seq+0x13a>
        }
        else
        {
            // Da Transfer File xong
            File_Handler_Manager.step = 0;
 800217e:	4b2e      	ldr	r3, [pc, #184]	; (8002238 <GSM_File_Transfer_Seq+0x150>)
 8002180:	2200      	movs	r2, #0
 8002182:	705a      	strb	r2, [r3, #1]
            DEBUG_INFO("File %d: %s Transfer DONE.\r\n", FileSend_Info.FileID + 1,
 8002184:	f01a fcd2 	bl	801cb2c <sys_get_tick_ms>
 8002188:	0004      	movs	r4, r0
 800218a:	4b31      	ldr	r3, [pc, #196]	; (8002250 <GSM_File_Transfer_Seq+0x168>)
 800218c:	22c9      	movs	r2, #201	; 0xc9
 800218e:	5c9b      	ldrb	r3, [r3, r2]
 8002190:	1c59      	adds	r1, r3, #1
 8002192:	4b2f      	ldr	r3, [pc, #188]	; (8002250 <GSM_File_Transfer_Seq+0x168>)
 8002194:	22c9      	movs	r2, #201	; 0xc9
 8002196:	5c9b      	ldrb	r3, [r3, r2]
 8002198:	0018      	movs	r0, r3
 800219a:	4a2d      	ldr	r2, [pc, #180]	; (8002250 <GSM_File_Transfer_Seq+0x168>)
 800219c:	0003      	movs	r3, r0
 800219e:	009b      	lsls	r3, r3, #2
 80021a0:	181b      	adds	r3, r3, r0
 80021a2:	009b      	lsls	r3, r3, #2
 80021a4:	18d3      	adds	r3, r2, r3
 80021a6:	3308      	adds	r3, #8
 80021a8:	681b      	ldr	r3, [r3, #0]
 80021aa:	4a2a      	ldr	r2, [pc, #168]	; (8002254 <GSM_File_Transfer_Seq+0x16c>)
 80021ac:	482a      	ldr	r0, [pc, #168]	; (8002258 <GSM_File_Transfer_Seq+0x170>)
 80021ae:	9300      	str	r3, [sp, #0]
 80021b0:	000b      	movs	r3, r1
 80021b2:	0021      	movs	r1, r4
 80021b4:	f000 fb92 	bl	80028dc <app_debug_rtt_raw>
                                                         FileSend_Info.File[FileSend_Info.FileID].Name);
            // Bat dau chuyen file tiep theo
            if(++FileSend_Info.FileID >= FileSend_Info.NumberFile)
 80021b8:	4b25      	ldr	r3, [pc, #148]	; (8002250 <GSM_File_Transfer_Seq+0x168>)
 80021ba:	22c9      	movs	r2, #201	; 0xc9
 80021bc:	5c9b      	ldrb	r3, [r3, r2]
 80021be:	3301      	adds	r3, #1
 80021c0:	b2d9      	uxtb	r1, r3
 80021c2:	4b23      	ldr	r3, [pc, #140]	; (8002250 <GSM_File_Transfer_Seq+0x168>)
 80021c4:	22c9      	movs	r2, #201	; 0xc9
 80021c6:	5499      	strb	r1, [r3, r2]
 80021c8:	4b21      	ldr	r3, [pc, #132]	; (8002250 <GSM_File_Transfer_Seq+0x168>)
 80021ca:	22c9      	movs	r2, #201	; 0xc9
 80021cc:	5c9a      	ldrb	r2, [r3, r2]
 80021ce:	4b20      	ldr	r3, [pc, #128]	; (8002250 <GSM_File_Transfer_Seq+0x168>)
 80021d0:	21c8      	movs	r1, #200	; 0xc8
 80021d2:	5c5b      	ldrb	r3, [r3, r1]
 80021d4:	429a      	cmp	r2, r3
 80021d6:	d308      	bcc.n	80021ea <GSM_File_Transfer_Seq+0x102>
            {
                DEBUG_INFO("All File Transfer DONE.\r\n");
 80021d8:	f01a fca8 	bl	801cb2c <sys_get_tick_ms>
 80021dc:	0001      	movs	r1, r0
 80021de:	4a1d      	ldr	r2, [pc, #116]	; (8002254 <GSM_File_Transfer_Seq+0x16c>)
 80021e0:	4b1e      	ldr	r3, [pc, #120]	; (800225c <GSM_File_Transfer_Seq+0x174>)
 80021e2:	0018      	movs	r0, r3
 80021e4:	f000 fb7a 	bl	80028dc <app_debug_rtt_raw>
 80021e8:	e01b      	b.n	8002222 <GSM_File_Transfer_Seq+0x13a>
            }
            else
            {
                GSM_Add_FileInfo_to_AT_Command(&FileSend_Info.File[FileSend_Info.FileID]);
 80021ea:	4b19      	ldr	r3, [pc, #100]	; (8002250 <GSM_File_Transfer_Seq+0x168>)
 80021ec:	22c9      	movs	r2, #201	; 0xc9
 80021ee:	5c9b      	ldrb	r3, [r3, r2]
 80021f0:	001a      	movs	r2, r3
 80021f2:	0013      	movs	r3, r2
 80021f4:	009b      	lsls	r3, r3, #2
 80021f6:	189b      	adds	r3, r3, r2
 80021f8:	009b      	lsls	r3, r3, #2
 80021fa:	4a15      	ldr	r2, [pc, #84]	; (8002250 <GSM_File_Transfer_Seq+0x168>)
 80021fc:	189b      	adds	r3, r3, r2
 80021fe:	0018      	movs	r0, r3
 8002200:	f000 f82e 	bl	8002260 <GSM_Add_FileInfo_to_AT_Command>
                GSM_SendCommand_AT(ATC_Table_File_Tranfer[0]);
 8002204:	4b0e      	ldr	r3, [pc, #56]	; (8002240 <GSM_File_Transfer_Seq+0x158>)
 8002206:	466a      	mov	r2, sp
 8002208:	0011      	movs	r1, r2
 800220a:	001a      	movs	r2, r3
 800220c:	3210      	adds	r2, #16
 800220e:	ca31      	ldmia	r2!, {r0, r4, r5}
 8002210:	c131      	stmia	r1!, {r0, r4, r5}
 8002212:	6812      	ldr	r2, [r2, #0]
 8002214:	600a      	str	r2, [r1, #0]
 8002216:	6818      	ldr	r0, [r3, #0]
 8002218:	6859      	ldr	r1, [r3, #4]
 800221a:	689a      	ldr	r2, [r3, #8]
 800221c:	68db      	ldr	r3, [r3, #12]
 800221e:	f7ff fbbf 	bl	80019a0 <GSM_SendCommand_AT>
            }
        }
        File_Handler_Manager.step++;
 8002222:	4b05      	ldr	r3, [pc, #20]	; (8002238 <GSM_File_Transfer_Seq+0x150>)
 8002224:	785b      	ldrb	r3, [r3, #1]
 8002226:	3301      	adds	r3, #1
 8002228:	b2da      	uxtb	r2, r3
 800222a:	4b03      	ldr	r3, [pc, #12]	; (8002238 <GSM_File_Transfer_Seq+0x150>)
 800222c:	705a      	strb	r2, [r3, #1]
 800222e:	e000      	b.n	8002232 <GSM_File_Transfer_Seq+0x14a>
        return;
 8002230:	46c0      	nop			; (mov r8, r8)
    }
    else //if(event == GSM_EVENT_TIMEOUT)
    {
        //GSM_Manager_ChangeState(GSM_STATE_RESET);
    }
}
 8002232:	46bd      	mov	sp, r7
 8002234:	b005      	add	sp, #20
 8002236:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002238:	20000dc8 	.word	0x20000dc8
 800223c:	08022345 	.word	0x08022345
 8002240:	08022264 	.word	0x08022264
 8002244:	0801e5bc 	.word	0x0801e5bc
 8002248:	0801e5c4 	.word	0x0801e5c4
 800224c:	0801e4e0 	.word	0x0801e4e0
 8002250:	20000dcc 	.word	0x20000dcc
 8002254:	0801e348 	.word	0x0801e348
 8002258:	0801e5fc 	.word	0x0801e5fc
 800225c:	0801e634 	.word	0x0801e634

08002260 <GSM_Add_FileInfo_to_AT_Command>:
void GSM_Add_FileInfo_to_AT_Command(GSM_FileSend_Info_TypDef *File_Info)
{
 8002260:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002262:	b089      	sub	sp, #36	; 0x24
 8002264:	af06      	add	r7, sp, #24
 8002266:	6078      	str	r0, [r7, #4]
    // Set File Name
    snprintf(Upload_File_AT_Command, sizeof(Upload_File_AT_Command), "%s%s%s%d%s%d%s",
 8002268:	687b      	ldr	r3, [r7, #4]
 800226a:	689b      	ldr	r3, [r3, #8]
                                                                "AT+QFTPPUT=\"",
                                                                File_Info->Name,
                                                                "\",\"COM:\",",
                                                                File_Info->Index,
 800226c:	687a      	ldr	r2, [r7, #4]
 800226e:	8a12      	ldrh	r2, [r2, #16]
    snprintf(Upload_File_AT_Command, sizeof(Upload_File_AT_Command), "%s%s%s%d%s%d%s",
 8002270:	0015      	movs	r5, r2
                                                                ",",
                                                                File_Info->DataLength,
 8002272:	687a      	ldr	r2, [r7, #4]
 8002274:	8892      	ldrh	r2, [r2, #4]
    snprintf(Upload_File_AT_Command, sizeof(Upload_File_AT_Command), "%s%s%s%d%s%d%s",
 8002276:	0016      	movs	r6, r2
 8002278:	4c1c      	ldr	r4, [pc, #112]	; (80022ec <GSM_Add_FileInfo_to_AT_Command+0x8c>)
 800227a:	491d      	ldr	r1, [pc, #116]	; (80022f0 <GSM_Add_FileInfo_to_AT_Command+0x90>)
 800227c:	481d      	ldr	r0, [pc, #116]	; (80022f4 <GSM_Add_FileInfo_to_AT_Command+0x94>)
 800227e:	4a1e      	ldr	r2, [pc, #120]	; (80022f8 <GSM_Add_FileInfo_to_AT_Command+0x98>)
 8002280:	9205      	str	r2, [sp, #20]
 8002282:	9604      	str	r6, [sp, #16]
 8002284:	4a1d      	ldr	r2, [pc, #116]	; (80022fc <GSM_Add_FileInfo_to_AT_Command+0x9c>)
 8002286:	9203      	str	r2, [sp, #12]
 8002288:	9502      	str	r5, [sp, #8]
 800228a:	4a1d      	ldr	r2, [pc, #116]	; (8002300 <GSM_Add_FileInfo_to_AT_Command+0xa0>)
 800228c:	9201      	str	r2, [sp, #4]
 800228e:	9300      	str	r3, [sp, #0]
 8002290:	0023      	movs	r3, r4
 8002292:	000a      	movs	r2, r1
 8002294:	2146      	movs	r1, #70	; 0x46
 8002296:	f01a fd81 	bl	801cd9c <sniprintf>
    //                                                         "AT+QFTPPUT=\"",
    //                                                         FileSend_Info.Name,
    //                                                         "\",\"COM:\",",
    //                                                         "0,20,1\r\n");                                                     
    // Set File Data
    snprintf(Upload_File_Data, sizeof(Upload_File_Data), "%s%s", File_Info->Data, "\r\n");
 800229a:	687b      	ldr	r3, [r7, #4]
 800229c:	6819      	ldr	r1, [r3, #0]
 800229e:	4a19      	ldr	r2, [pc, #100]	; (8002304 <GSM_Add_FileInfo_to_AT_Command+0xa4>)
 80022a0:	4819      	ldr	r0, [pc, #100]	; (8002308 <GSM_Add_FileInfo_to_AT_Command+0xa8>)
 80022a2:	4b1a      	ldr	r3, [pc, #104]	; (800230c <GSM_Add_FileInfo_to_AT_Command+0xac>)
 80022a4:	9300      	str	r3, [sp, #0]
 80022a6:	000b      	movs	r3, r1
 80022a8:	2132      	movs	r1, #50	; 0x32
 80022aa:	f01a fd77 	bl	801cd9c <sniprintf>
    // Set Commamd Get File Size
    snprintf(Get_File_Size_AT_Command, sizeof(Get_File_Size_AT_Command), "%s%s%s",
 80022ae:	687b      	ldr	r3, [r7, #4]
 80022b0:	689b      	ldr	r3, [r3, #8]
 80022b2:	4c17      	ldr	r4, [pc, #92]	; (8002310 <GSM_Add_FileInfo_to_AT_Command+0xb0>)
 80022b4:	4917      	ldr	r1, [pc, #92]	; (8002314 <GSM_Add_FileInfo_to_AT_Command+0xb4>)
 80022b6:	4818      	ldr	r0, [pc, #96]	; (8002318 <GSM_Add_FileInfo_to_AT_Command+0xb8>)
 80022b8:	4a18      	ldr	r2, [pc, #96]	; (800231c <GSM_Add_FileInfo_to_AT_Command+0xbc>)
 80022ba:	9201      	str	r2, [sp, #4]
 80022bc:	9300      	str	r3, [sp, #0]
 80022be:	0023      	movs	r3, r4
 80022c0:	000a      	movs	r2, r1
 80022c2:	2146      	movs	r1, #70	; 0x46
 80022c4:	f01a fd6a 	bl	801cd9c <sniprintf>
                                                                "AT+QFTPSIZE=\"",
                                                                File_Info->Name,
                                                                "\"\r\n");
    // Set File Directory
    snprintf(Set_Directory_AT_Command, sizeof(Set_Directory_AT_Command), "%s%s%s",
 80022c8:	687b      	ldr	r3, [r7, #4]
 80022ca:	68db      	ldr	r3, [r3, #12]
 80022cc:	4c14      	ldr	r4, [pc, #80]	; (8002320 <GSM_Add_FileInfo_to_AT_Command+0xc0>)
 80022ce:	4911      	ldr	r1, [pc, #68]	; (8002314 <GSM_Add_FileInfo_to_AT_Command+0xb4>)
 80022d0:	4814      	ldr	r0, [pc, #80]	; (8002324 <GSM_Add_FileInfo_to_AT_Command+0xc4>)
 80022d2:	4a12      	ldr	r2, [pc, #72]	; (800231c <GSM_Add_FileInfo_to_AT_Command+0xbc>)
 80022d4:	9201      	str	r2, [sp, #4]
 80022d6:	9300      	str	r3, [sp, #0]
 80022d8:	0023      	movs	r3, r4
 80022da:	000a      	movs	r2, r1
 80022dc:	2146      	movs	r1, #70	; 0x46
 80022de:	f01a fd5d 	bl	801cd9c <sniprintf>
                                                                "AT+QFTPCWD=\"",
                                                                File_Info->Directory,
                                                                "\"\r\n");
}
 80022e2:	46c0      	nop			; (mov r8, r8)
 80022e4:	46bd      	mov	sp, r7
 80022e6:	b003      	add	sp, #12
 80022e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80022ea:	46c0      	nop			; (mov r8, r8)
 80022ec:	0801e564 	.word	0x0801e564
 80022f0:	0801e574 	.word	0x0801e574
 80022f4:	20000cac 	.word	0x20000cac
 80022f8:	0801e584 	.word	0x0801e584
 80022fc:	0801e58c 	.word	0x0801e58c
 8002300:	0801e590 	.word	0x0801e590
 8002304:	0801e668 	.word	0x0801e668
 8002308:	20000d84 	.word	0x20000d84
 800230c:	0801e4d8 	.word	0x0801e4d8
 8002310:	0801e670 	.word	0x0801e670
 8002314:	0801e680 	.word	0x0801e680
 8002318:	20000cf4 	.word	0x20000cf4
 800231c:	0801e4b4 	.word	0x0801e4b4
 8002320:	0801e688 	.word	0x0801e688
 8002324:	20000d3c 	.word	0x20000d3c

08002328 <GSM_Send_File>:
void GSM_Send_File(GSM_Multi_FileSend_Info_TypDef *File_Info)
{
 8002328:	b5b0      	push	{r4, r5, r7, lr}
 800232a:	b086      	sub	sp, #24
 800232c:	af04      	add	r7, sp, #16
 800232e:	6078      	str	r0, [r7, #4]
    memcpy(&FileSend_Info, File_Info, sizeof(GSM_Multi_FileSend_Info_TypDef));
 8002330:	6879      	ldr	r1, [r7, #4]
 8002332:	4b11      	ldr	r3, [pc, #68]	; (8002378 <GSM_Send_File+0x50>)
 8002334:	22cc      	movs	r2, #204	; 0xcc
 8002336:	0018      	movs	r0, r3
 8002338:	f01a fc52 	bl	801cbe0 <memcpy>
    if(File_Handler_Manager.step == 0)
 800233c:	4b0f      	ldr	r3, [pc, #60]	; (800237c <GSM_Send_File+0x54>)
 800233e:	785b      	ldrb	r3, [r3, #1]
 8002340:	2b00      	cmp	r3, #0
 8002342:	d114      	bne.n	800236e <GSM_Send_File+0x46>
    {
        File_Handler_Manager.step = 1;
 8002344:	4b0d      	ldr	r3, [pc, #52]	; (800237c <GSM_Send_File+0x54>)
 8002346:	2201      	movs	r2, #1
 8002348:	705a      	strb	r2, [r3, #1]
        GSM_SendCommand_AT(ATC_Table_Login_Server[0]);
 800234a:	4b0d      	ldr	r3, [pc, #52]	; (8002380 <GSM_Send_File+0x58>)
 800234c:	466a      	mov	r2, sp
 800234e:	0011      	movs	r1, r2
 8002350:	001a      	movs	r2, r3
 8002352:	3210      	adds	r2, #16
 8002354:	ca31      	ldmia	r2!, {r0, r4, r5}
 8002356:	c131      	stmia	r1!, {r0, r4, r5}
 8002358:	6812      	ldr	r2, [r2, #0]
 800235a:	600a      	str	r2, [r1, #0]
 800235c:	6818      	ldr	r0, [r3, #0]
 800235e:	6859      	ldr	r1, [r3, #4]
 8002360:	689a      	ldr	r2, [r3, #8]
 8002362:	68db      	ldr	r3, [r3, #12]
 8002364:	f7ff fb1c 	bl	80019a0 <GSM_SendCommand_AT>
        File_Handler_Manager.mode = GSM_FILE_MODE_UPLOAD;
 8002368:	4b04      	ldr	r3, [pc, #16]	; (800237c <GSM_Send_File+0x54>)
 800236a:	2200      	movs	r2, #0
 800236c:	701a      	strb	r2, [r3, #0]
    }
}
 800236e:	46c0      	nop			; (mov r8, r8)
 8002370:	46bd      	mov	sp, r7
 8002372:	b002      	add	sp, #8
 8002374:	bdb0      	pop	{r4, r5, r7, pc}
 8002376:	46c0      	nop			; (mov r8, r8)
 8002378:	20000dcc 	.word	0x20000dcc
 800237c:	20000dc8 	.word	0x20000dc8
 8002380:	08022164 	.word	0x08022164

08002384 <GSM_Utilities_Get_IMEI>:
#include "gsm_utilities.h"

void GSM_Utilities_Get_IMEI(uint8_t *recv_Buffer, uint8_t* IMEI_Buffer, uint8_t Max_IMEI_Length)
{
 8002384:	b580      	push	{r7, lr}
 8002386:	b086      	sub	sp, #24
 8002388:	af00      	add	r7, sp, #0
 800238a:	60f8      	str	r0, [r7, #12]
 800238c:	60b9      	str	r1, [r7, #8]
 800238e:	1dfb      	adds	r3, r7, #7
 8002390:	701a      	strb	r2, [r3, #0]
    int IMEI_Index = 0;
 8002392:	2300      	movs	r3, #0
 8002394:	617b      	str	r3, [r7, #20]
    for(int CountByte = 0; CountByte < strlen((char*)recv_Buffer); CountByte++)
 8002396:	2300      	movs	r3, #0
 8002398:	613b      	str	r3, [r7, #16]
 800239a:	e025      	b.n	80023e8 <GSM_Utilities_Get_IMEI+0x64>
    {
        if((recv_Buffer[CountByte] >= '0') && (recv_Buffer[CountByte] <= '9'))
 800239c:	693b      	ldr	r3, [r7, #16]
 800239e:	68fa      	ldr	r2, [r7, #12]
 80023a0:	18d3      	adds	r3, r2, r3
 80023a2:	781b      	ldrb	r3, [r3, #0]
 80023a4:	2b2f      	cmp	r3, #47	; 0x2f
 80023a6:	d91c      	bls.n	80023e2 <GSM_Utilities_Get_IMEI+0x5e>
 80023a8:	693b      	ldr	r3, [r7, #16]
 80023aa:	68fa      	ldr	r2, [r7, #12]
 80023ac:	18d3      	adds	r3, r2, r3
 80023ae:	781b      	ldrb	r3, [r3, #0]
 80023b0:	2b39      	cmp	r3, #57	; 0x39
 80023b2:	d816      	bhi.n	80023e2 <GSM_Utilities_Get_IMEI+0x5e>
        {
            if(IMEI_Index < Max_IMEI_Length)
 80023b4:	1dfb      	adds	r3, r7, #7
 80023b6:	781b      	ldrb	r3, [r3, #0]
 80023b8:	697a      	ldr	r2, [r7, #20]
 80023ba:	429a      	cmp	r2, r3
 80023bc:	da0b      	bge.n	80023d6 <GSM_Utilities_Get_IMEI+0x52>
            {
                IMEI_Buffer[IMEI_Index++] = recv_Buffer[CountByte];
 80023be:	693b      	ldr	r3, [r7, #16]
 80023c0:	68fa      	ldr	r2, [r7, #12]
 80023c2:	18d2      	adds	r2, r2, r3
 80023c4:	697b      	ldr	r3, [r7, #20]
 80023c6:	1c59      	adds	r1, r3, #1
 80023c8:	6179      	str	r1, [r7, #20]
 80023ca:	0019      	movs	r1, r3
 80023cc:	68bb      	ldr	r3, [r7, #8]
 80023ce:	185b      	adds	r3, r3, r1
 80023d0:	7812      	ldrb	r2, [r2, #0]
 80023d2:	701a      	strb	r2, [r3, #0]
 80023d4:	e005      	b.n	80023e2 <GSM_Utilities_Get_IMEI+0x5e>
            }
            else
            {
                IMEI_Buffer[IMEI_Index] = 0;
 80023d6:	697b      	ldr	r3, [r7, #20]
 80023d8:	68ba      	ldr	r2, [r7, #8]
 80023da:	18d3      	adds	r3, r2, r3
 80023dc:	2200      	movs	r2, #0
 80023de:	701a      	strb	r2, [r3, #0]
                break;
 80023e0:	e00a      	b.n	80023f8 <GSM_Utilities_Get_IMEI+0x74>
    for(int CountByte = 0; CountByte < strlen((char*)recv_Buffer); CountByte++)
 80023e2:	693b      	ldr	r3, [r7, #16]
 80023e4:	3301      	adds	r3, #1
 80023e6:	613b      	str	r3, [r7, #16]
 80023e8:	68fb      	ldr	r3, [r7, #12]
 80023ea:	0018      	movs	r0, r3
 80023ec:	f7fd fe8c 	bl	8000108 <strlen>
 80023f0:	0002      	movs	r2, r0
 80023f2:	693b      	ldr	r3, [r7, #16]
 80023f4:	429a      	cmp	r2, r3
 80023f6:	d8d1      	bhi.n	800239c <GSM_Utilities_Get_IMEI+0x18>
            }
        }
    }
    IMEI_Buffer[IMEI_Index] = 0;
 80023f8:	697b      	ldr	r3, [r7, #20]
 80023fa:	68ba      	ldr	r2, [r7, #8]
 80023fc:	18d3      	adds	r3, r2, r3
 80023fe:	2200      	movs	r2, #0
 8002400:	701a      	strb	r2, [r3, #0]
}
 8002402:	46c0      	nop			; (mov r8, r8)
 8002404:	46bd      	mov	sp, r7
 8002406:	b006      	add	sp, #24
 8002408:	bd80      	pop	{r7, pc}
	...

0800240c <gsm_utilities_get_signal_strength_from_buffer>:
bool gsm_utilities_get_signal_strength_from_buffer(uint8_t *buffer, uint16_t *csq)
{
 800240c:	b580      	push	{r7, lr}
 800240e:	b084      	sub	sp, #16
 8002410:	af00      	add	r7, sp, #0
 8002412:	6078      	str	r0, [r7, #4]
 8002414:	6039      	str	r1, [r7, #0]
    char *tmp_buff = strstr((char *)buffer, "+CSQ:");
 8002416:	4a0d      	ldr	r2, [pc, #52]	; (800244c <gsm_utilities_get_signal_strength_from_buffer+0x40>)
 8002418:	687b      	ldr	r3, [r7, #4]
 800241a:	0011      	movs	r1, r2
 800241c:	0018      	movs	r0, r3
 800241e:	f01a fd05 	bl	801ce2c <strstr>
 8002422:	0003      	movs	r3, r0
 8002424:	60fb      	str	r3, [r7, #12]

    if (tmp_buff == NULL)
 8002426:	68fb      	ldr	r3, [r7, #12]
 8002428:	2b00      	cmp	r3, #0
 800242a:	d101      	bne.n	8002430 <gsm_utilities_get_signal_strength_from_buffer+0x24>
    {
        return false;
 800242c:	2300      	movs	r3, #0
 800242e:	e009      	b.n	8002444 <gsm_utilities_get_signal_strength_from_buffer+0x38>
    }

    *csq = gsm_utilities_get_number_from_string((uint16_t)6, tmp_buff);
 8002430:	68fb      	ldr	r3, [r7, #12]
 8002432:	0019      	movs	r1, r3
 8002434:	2006      	movs	r0, #6
 8002436:	f000 f80b 	bl	8002450 <gsm_utilities_get_number_from_string>
 800243a:	0003      	movs	r3, r0
 800243c:	001a      	movs	r2, r3
 800243e:	683b      	ldr	r3, [r7, #0]
 8002440:	801a      	strh	r2, [r3, #0]
    return true;
 8002442:	2301      	movs	r3, #1
}
 8002444:	0018      	movs	r0, r3
 8002446:	46bd      	mov	sp, r7
 8002448:	b004      	add	sp, #16
 800244a:	bd80      	pop	{r7, pc}
 800244c:	0801e698 	.word	0x0801e698

08002450 <gsm_utilities_get_number_from_string>:
 * 	Ham doc mot so trong chuoi bat dau tu dia chi nao do.
 *	Buffer = abc124mff thi gsm_utilities_get_number_from_string(3,Buffer) = 123
 *
 */
uint16_t gsm_utilities_get_number_from_string(uint16_t begin_index, char *buffer)
{
 8002450:	b590      	push	{r4, r7, lr}
 8002452:	b085      	sub	sp, #20
 8002454:	af00      	add	r7, sp, #0
 8002456:	0002      	movs	r2, r0
 8002458:	6039      	str	r1, [r7, #0]
 800245a:	1dbb      	adds	r3, r7, #6
 800245c:	801a      	strh	r2, [r3, #0]
    // assert(buffer);

	uint16_t value = 0;
 800245e:	230e      	movs	r3, #14
 8002460:	18fb      	adds	r3, r7, r3
 8002462:	2200      	movs	r2, #0
 8002464:	801a      	strh	r2, [r3, #0]
    uint16_t tmp = begin_index;
 8002466:	230c      	movs	r3, #12
 8002468:	18fb      	adds	r3, r7, r3
 800246a:	1dba      	adds	r2, r7, #6
 800246c:	8812      	ldrh	r2, [r2, #0]
 800246e:	801a      	strh	r2, [r3, #0]
    uint32_t len = strlen(buffer);
 8002470:	683b      	ldr	r3, [r7, #0]
 8002472:	0018      	movs	r0, r3
 8002474:	f7fd fe48 	bl	8000108 <strlen>
 8002478:	0003      	movs	r3, r0
 800247a:	60bb      	str	r3, [r7, #8]
    while (buffer[tmp] && tmp < len)
 800247c:	e029      	b.n	80024d2 <gsm_utilities_get_number_from_string+0x82>
    {
        if (buffer[tmp] >= '0' && buffer[tmp] <= '9')
 800247e:	200c      	movs	r0, #12
 8002480:	183b      	adds	r3, r7, r0
 8002482:	881b      	ldrh	r3, [r3, #0]
 8002484:	683a      	ldr	r2, [r7, #0]
 8002486:	18d3      	adds	r3, r2, r3
 8002488:	781b      	ldrb	r3, [r3, #0]
 800248a:	2b2f      	cmp	r3, #47	; 0x2f
 800248c:	d92e      	bls.n	80024ec <gsm_utilities_get_number_from_string+0x9c>
 800248e:	183b      	adds	r3, r7, r0
 8002490:	881b      	ldrh	r3, [r3, #0]
 8002492:	683a      	ldr	r2, [r7, #0]
 8002494:	18d3      	adds	r3, r2, r3
 8002496:	781b      	ldrb	r3, [r3, #0]
 8002498:	2b39      	cmp	r3, #57	; 0x39
 800249a:	d827      	bhi.n	80024ec <gsm_utilities_get_number_from_string+0x9c>
        {
            value *= 10;
 800249c:	240e      	movs	r4, #14
 800249e:	193a      	adds	r2, r7, r4
 80024a0:	193b      	adds	r3, r7, r4
 80024a2:	881b      	ldrh	r3, [r3, #0]
 80024a4:	1c19      	adds	r1, r3, #0
 80024a6:	0089      	lsls	r1, r1, #2
 80024a8:	18cb      	adds	r3, r1, r3
 80024aa:	18db      	adds	r3, r3, r3
 80024ac:	8013      	strh	r3, [r2, #0]
            value += buffer[tmp] - 48;
 80024ae:	183b      	adds	r3, r7, r0
 80024b0:	881b      	ldrh	r3, [r3, #0]
 80024b2:	683a      	ldr	r2, [r7, #0]
 80024b4:	18d3      	adds	r3, r2, r3
 80024b6:	781b      	ldrb	r3, [r3, #0]
 80024b8:	b29a      	uxth	r2, r3
 80024ba:	193b      	adds	r3, r7, r4
 80024bc:	881b      	ldrh	r3, [r3, #0]
 80024be:	18d3      	adds	r3, r2, r3
 80024c0:	b29a      	uxth	r2, r3
 80024c2:	193b      	adds	r3, r7, r4
 80024c4:	3a30      	subs	r2, #48	; 0x30
 80024c6:	801a      	strh	r2, [r3, #0]
        }
        else
        {
            break;
        }
        tmp++;
 80024c8:	183b      	adds	r3, r7, r0
 80024ca:	881a      	ldrh	r2, [r3, #0]
 80024cc:	183b      	adds	r3, r7, r0
 80024ce:	3201      	adds	r2, #1
 80024d0:	801a      	strh	r2, [r3, #0]
    while (buffer[tmp] && tmp < len)
 80024d2:	210c      	movs	r1, #12
 80024d4:	187b      	adds	r3, r7, r1
 80024d6:	881b      	ldrh	r3, [r3, #0]
 80024d8:	683a      	ldr	r2, [r7, #0]
 80024da:	18d3      	adds	r3, r2, r3
 80024dc:	781b      	ldrb	r3, [r3, #0]
 80024de:	2b00      	cmp	r3, #0
 80024e0:	d004      	beq.n	80024ec <gsm_utilities_get_number_from_string+0x9c>
 80024e2:	187b      	adds	r3, r7, r1
 80024e4:	881b      	ldrh	r3, [r3, #0]
 80024e6:	68ba      	ldr	r2, [r7, #8]
 80024e8:	429a      	cmp	r2, r3
 80024ea:	d8c8      	bhi.n	800247e <gsm_utilities_get_number_from_string+0x2e>
    }

    return value;
 80024ec:	230e      	movs	r3, #14
 80024ee:	18fb      	adds	r3, r7, r3
 80024f0:	881b      	ldrh	r3, [r3, #0]
}
 80024f2:	0018      	movs	r0, r3
 80024f4:	46bd      	mov	sp, r7
 80024f6:	b005      	add	sp, #20
 80024f8:	bd90      	pop	{r4, r7, pc}

080024fa <gsm_utilities_is_file_exist>:
/*
 * 	Ham kiem tra xem ten file co ton tai trong RespBuffer hay khong
 *
 */
bool gsm_utilities_is_file_exist(char* FileName, char *buffer)
{
 80024fa:	b580      	push	{r7, lr}
 80024fc:	b082      	sub	sp, #8
 80024fe:	af00      	add	r7, sp, #0
 8002500:	6078      	str	r0, [r7, #4]
 8002502:	6039      	str	r1, [r7, #0]
    return (strlen(FileName) && strlen(buffer) && strstr(buffer, FileName));
 8002504:	687b      	ldr	r3, [r7, #4]
 8002506:	781b      	ldrb	r3, [r3, #0]
 8002508:	2b00      	cmp	r3, #0
 800250a:	d00d      	beq.n	8002528 <gsm_utilities_is_file_exist+0x2e>
 800250c:	683b      	ldr	r3, [r7, #0]
 800250e:	781b      	ldrb	r3, [r3, #0]
 8002510:	2b00      	cmp	r3, #0
 8002512:	d009      	beq.n	8002528 <gsm_utilities_is_file_exist+0x2e>
 8002514:	687a      	ldr	r2, [r7, #4]
 8002516:	683b      	ldr	r3, [r7, #0]
 8002518:	0011      	movs	r1, r2
 800251a:	0018      	movs	r0, r3
 800251c:	f01a fc86 	bl	801ce2c <strstr>
 8002520:	1e03      	subs	r3, r0, #0
 8002522:	d001      	beq.n	8002528 <gsm_utilities_is_file_exist+0x2e>
 8002524:	2301      	movs	r3, #1
 8002526:	e000      	b.n	800252a <gsm_utilities_is_file_exist+0x30>
 8002528:	2300      	movs	r3, #0
 800252a:	1c1a      	adds	r2, r3, #0
 800252c:	2301      	movs	r3, #1
 800252e:	4013      	ands	r3, r2
 8002530:	b2db      	uxtb	r3, r3
}
 8002532:	0018      	movs	r0, r3
 8002534:	46bd      	mov	sp, r7
 8002536:	b002      	add	sp, #8
 8002538:	bd80      	pop	{r7, pc}
	...

0800253c <DEBUG_PrintResult_ATC>:

void DEBUG_PrintResult_ATC(char* cmd, char* result)
{
 800253c:	b5b0      	push	{r4, r5, r7, lr}
 800253e:	b094      	sub	sp, #80	; 0x50
 8002540:	af02      	add	r7, sp, #8
 8002542:	6078      	str	r0, [r7, #4]
 8002544:	6039      	str	r1, [r7, #0]
    // In ket qua: "AT cmd: OK/FAIL " trong debug
    char sub_cmd[64] = "";
 8002546:	2408      	movs	r4, #8
 8002548:	193b      	adds	r3, r7, r4
 800254a:	2200      	movs	r2, #0
 800254c:	601a      	str	r2, [r3, #0]
 800254e:	3304      	adds	r3, #4
 8002550:	223c      	movs	r2, #60	; 0x3c
 8002552:	2100      	movs	r1, #0
 8002554:	0018      	movs	r0, r3
 8002556:	f01a fb5f 	bl	801cc18 <memset>
    strncpy(sub_cmd, cmd + 0, strlen(cmd) - 2);
 800255a:	687b      	ldr	r3, [r7, #4]
 800255c:	0018      	movs	r0, r3
 800255e:	f7fd fdd3 	bl	8000108 <strlen>
 8002562:	0003      	movs	r3, r0
 8002564:	1e9a      	subs	r2, r3, #2
 8002566:	6879      	ldr	r1, [r7, #4]
 8002568:	0025      	movs	r5, r4
 800256a:	193b      	adds	r3, r7, r4
 800256c:	0018      	movs	r0, r3
 800256e:	f01a fc49 	bl	801ce04 <strncpy>
    DEBUG_INFO("%s : %s\r\n", sub_cmd, result);
 8002572:	f01a fadb 	bl	801cb2c <sys_get_tick_ms>
 8002576:	0004      	movs	r4, r0
 8002578:	1979      	adds	r1, r7, r5
 800257a:	4a06      	ldr	r2, [pc, #24]	; (8002594 <DEBUG_PrintResult_ATC+0x58>)
 800257c:	4806      	ldr	r0, [pc, #24]	; (8002598 <DEBUG_PrintResult_ATC+0x5c>)
 800257e:	683b      	ldr	r3, [r7, #0]
 8002580:	9300      	str	r3, [sp, #0]
 8002582:	000b      	movs	r3, r1
 8002584:	0021      	movs	r1, r4
 8002586:	f000 f9a9 	bl	80028dc <app_debug_rtt_raw>
}
 800258a:	46c0      	nop			; (mov r8, r8)
 800258c:	46bd      	mov	sp, r7
 800258e:	b012      	add	sp, #72	; 0x48
 8002590:	bdb0      	pop	{r4, r5, r7, pc}
 8002592:	46c0      	nop			; (mov r8, r8)
 8002594:	0801e6a0 	.word	0x0801e6a0
 8002598:	0801e6a4 	.word	0x0801e6a4

0800259c <_DoInit>:
                      _DoInit();                                                                     \
                    }                                                                                \
                  } while (0);                                                                       \
                }

static void _DoInit(void) {
 800259c:	b580      	push	{r7, lr}
 800259e:	b082      	sub	sp, #8
 80025a0:	af00      	add	r7, sp, #0
  volatile SEGGER_RTT_CB* p;   // Volatile to make sure that compiler cannot change the order of accesses to the control block
  //
  // Initialize control block
  //
  p                     = (volatile SEGGER_RTT_CB*)((char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access control block uncached so that nothing in the cache ever becomes dirty and all changes are visible in HW directly
 80025a2:	4b22      	ldr	r3, [pc, #136]	; (800262c <_DoInit+0x90>)
 80025a4:	607b      	str	r3, [r7, #4]
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
 80025a6:	687b      	ldr	r3, [r7, #4]
 80025a8:	2201      	movs	r2, #1
 80025aa:	611a      	str	r2, [r3, #16]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
 80025ac:	687b      	ldr	r3, [r7, #4]
 80025ae:	2201      	movs	r2, #1
 80025b0:	615a      	str	r2, [r3, #20]
  //
  // Initialize up buffer 0
  //
  p->aUp[0].sName         = "Terminal";
 80025b2:	687b      	ldr	r3, [r7, #4]
 80025b4:	4a1e      	ldr	r2, [pc, #120]	; (8002630 <_DoInit+0x94>)
 80025b6:	619a      	str	r2, [r3, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
 80025b8:	687b      	ldr	r3, [r7, #4]
 80025ba:	4a1e      	ldr	r2, [pc, #120]	; (8002634 <_DoInit+0x98>)
 80025bc:	61da      	str	r2, [r3, #28]
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
 80025be:	687b      	ldr	r3, [r7, #4]
 80025c0:	2280      	movs	r2, #128	; 0x80
 80025c2:	00d2      	lsls	r2, r2, #3
 80025c4:	621a      	str	r2, [r3, #32]
  p->aUp[0].RdOff         = 0u;
 80025c6:	687b      	ldr	r3, [r7, #4]
 80025c8:	2200      	movs	r2, #0
 80025ca:	629a      	str	r2, [r3, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
 80025cc:	687b      	ldr	r3, [r7, #4]
 80025ce:	2200      	movs	r2, #0
 80025d0:	625a      	str	r2, [r3, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
 80025d2:	687b      	ldr	r3, [r7, #4]
 80025d4:	2200      	movs	r2, #0
 80025d6:	62da      	str	r2, [r3, #44]	; 0x2c
  //
  // Initialize down buffer 0
  //
  p->aDown[0].sName         = "Terminal";
 80025d8:	687b      	ldr	r3, [r7, #4]
 80025da:	4a15      	ldr	r2, [pc, #84]	; (8002630 <_DoInit+0x94>)
 80025dc:	631a      	str	r2, [r3, #48]	; 0x30
  p->aDown[0].pBuffer       = _acDownBuffer;
 80025de:	687b      	ldr	r3, [r7, #4]
 80025e0:	4a15      	ldr	r2, [pc, #84]	; (8002638 <_DoInit+0x9c>)
 80025e2:	635a      	str	r2, [r3, #52]	; 0x34
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
 80025e4:	687b      	ldr	r3, [r7, #4]
 80025e6:	2240      	movs	r2, #64	; 0x40
 80025e8:	639a      	str	r2, [r3, #56]	; 0x38
  p->aDown[0].RdOff         = 0u;
 80025ea:	687b      	ldr	r3, [r7, #4]
 80025ec:	2200      	movs	r2, #0
 80025ee:	641a      	str	r2, [r3, #64]	; 0x40
  p->aDown[0].WrOff         = 0u;
 80025f0:	687b      	ldr	r3, [r7, #4]
 80025f2:	2200      	movs	r2, #0
 80025f4:	63da      	str	r2, [r3, #60]	; 0x3c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
 80025f6:	687b      	ldr	r3, [r7, #4]
 80025f8:	2200      	movs	r2, #0
 80025fa:	645a      	str	r2, [r3, #68]	; 0x44
  //
  // Finish initialization of the control block.
  // Copy Id string in three steps to make sure "SEGGER RTT" is not found
  // in initializer memory (usually flash) by J-Link
  //
  STRCPY((char*)&p->acID[7], "RTT");
 80025fc:	687b      	ldr	r3, [r7, #4]
 80025fe:	1dda      	adds	r2, r3, #7
 8002600:	4b0e      	ldr	r3, [pc, #56]	; (800263c <_DoInit+0xa0>)
 8002602:	0010      	movs	r0, r2
 8002604:	0019      	movs	r1, r3
 8002606:	2304      	movs	r3, #4
 8002608:	001a      	movs	r2, r3
 800260a:	f01a fae9 	bl	801cbe0 <memcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
  STRCPY((char*)&p->acID[0], "SEGGER");
 800260e:	687a      	ldr	r2, [r7, #4]
 8002610:	4b0b      	ldr	r3, [pc, #44]	; (8002640 <_DoInit+0xa4>)
 8002612:	0010      	movs	r0, r2
 8002614:	0019      	movs	r1, r3
 8002616:	2307      	movs	r3, #7
 8002618:	001a      	movs	r2, r3
 800261a:	f01a fae1 	bl	801cbe0 <memcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
  p->acID[6] = ' ';
 800261e:	687b      	ldr	r3, [r7, #4]
 8002620:	2220      	movs	r2, #32
 8002622:	719a      	strb	r2, [r3, #6]
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
}
 8002624:	46c0      	nop			; (mov r8, r8)
 8002626:	46bd      	mov	sp, r7
 8002628:	b002      	add	sp, #8
 800262a:	bd80      	pop	{r7, pc}
 800262c:	20001c48 	.word	0x20001c48
 8002630:	0801e6c8 	.word	0x0801e6c8
 8002634:	20000e9c 	.word	0x20000e9c
 8002638:	2000129c 	.word	0x2000129c
 800263c:	0801e6d4 	.word	0x0801e6d4
 8002640:	0801e6d8 	.word	0x0801e6d8

08002644 <_WriteBlocking>:
*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
*
*  Return value
*    >= 0 - Number of bytes written into buffer.
*/
static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
 8002644:	b580      	push	{r7, lr}
 8002646:	b08a      	sub	sp, #40	; 0x28
 8002648:	af00      	add	r7, sp, #0
 800264a:	60f8      	str	r0, [r7, #12]
 800264c:	60b9      	str	r1, [r7, #8]
 800264e:	607a      	str	r2, [r7, #4]
  unsigned WrOff;
  volatile char* pDst;
  //
  // Write data to buffer and handle wrap-around if necessary
  //
  NumBytesWritten = 0u;
 8002650:	2300      	movs	r3, #0
 8002652:	623b      	str	r3, [r7, #32]
  WrOff = pRing->WrOff;
 8002654:	68fb      	ldr	r3, [r7, #12]
 8002656:	68db      	ldr	r3, [r3, #12]
 8002658:	61fb      	str	r3, [r7, #28]
  do {
    RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
 800265a:	68fb      	ldr	r3, [r7, #12]
 800265c:	691b      	ldr	r3, [r3, #16]
 800265e:	61bb      	str	r3, [r7, #24]
    if (RdOff > WrOff) {
 8002660:	69ba      	ldr	r2, [r7, #24]
 8002662:	69fb      	ldr	r3, [r7, #28]
 8002664:	429a      	cmp	r2, r3
 8002666:	d905      	bls.n	8002674 <_WriteBlocking+0x30>
      NumBytesToWrite = RdOff - WrOff - 1u;
 8002668:	69ba      	ldr	r2, [r7, #24]
 800266a:	69fb      	ldr	r3, [r7, #28]
 800266c:	1ad3      	subs	r3, r2, r3
 800266e:	3b01      	subs	r3, #1
 8002670:	627b      	str	r3, [r7, #36]	; 0x24
 8002672:	e007      	b.n	8002684 <_WriteBlocking+0x40>
    } else {
      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
 8002674:	68fb      	ldr	r3, [r7, #12]
 8002676:	689a      	ldr	r2, [r3, #8]
 8002678:	69b9      	ldr	r1, [r7, #24]
 800267a:	69fb      	ldr	r3, [r7, #28]
 800267c:	1acb      	subs	r3, r1, r3
 800267e:	18d3      	adds	r3, r2, r3
 8002680:	3b01      	subs	r3, #1
 8002682:	627b      	str	r3, [r7, #36]	; 0x24
    }
    NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
 8002684:	68fb      	ldr	r3, [r7, #12]
 8002686:	689a      	ldr	r2, [r3, #8]
 8002688:	69fb      	ldr	r3, [r7, #28]
 800268a:	1ad2      	subs	r2, r2, r3
 800268c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800268e:	4293      	cmp	r3, r2
 8002690:	d900      	bls.n	8002694 <_WriteBlocking+0x50>
 8002692:	0013      	movs	r3, r2
 8002694:	627b      	str	r3, [r7, #36]	; 0x24
    NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
 8002696:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8002698:	687b      	ldr	r3, [r7, #4]
 800269a:	4293      	cmp	r3, r2
 800269c:	d900      	bls.n	80026a0 <_WriteBlocking+0x5c>
 800269e:	0013      	movs	r3, r2
 80026a0:	627b      	str	r3, [r7, #36]	; 0x24
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
 80026a2:	68fb      	ldr	r3, [r7, #12]
 80026a4:	685a      	ldr	r2, [r3, #4]
 80026a6:	69fb      	ldr	r3, [r7, #28]
 80026a8:	18d3      	adds	r3, r2, r3
 80026aa:	617b      	str	r3, [r7, #20]
    WrOff           += NumBytesToWrite;
    while (NumBytesToWrite--) {
      *pDst++ = *pBuffer++;
    };
#else
    SEGGER_RTT_MEMCPY((void*)pDst, pBuffer, NumBytesToWrite);
 80026ac:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80026ae:	68b9      	ldr	r1, [r7, #8]
 80026b0:	697b      	ldr	r3, [r7, #20]
 80026b2:	0018      	movs	r0, r3
 80026b4:	f01a fa94 	bl	801cbe0 <memcpy>
    NumBytesWritten += NumBytesToWrite;
 80026b8:	6a3a      	ldr	r2, [r7, #32]
 80026ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80026bc:	18d3      	adds	r3, r2, r3
 80026be:	623b      	str	r3, [r7, #32]
    pBuffer         += NumBytesToWrite;
 80026c0:	68ba      	ldr	r2, [r7, #8]
 80026c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80026c4:	18d3      	adds	r3, r2, r3
 80026c6:	60bb      	str	r3, [r7, #8]
    NumBytes        -= NumBytesToWrite;
 80026c8:	687a      	ldr	r2, [r7, #4]
 80026ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80026cc:	1ad3      	subs	r3, r2, r3
 80026ce:	607b      	str	r3, [r7, #4]
    WrOff           += NumBytesToWrite;
 80026d0:	69fa      	ldr	r2, [r7, #28]
 80026d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80026d4:	18d3      	adds	r3, r2, r3
 80026d6:	61fb      	str	r3, [r7, #28]
#endif
    if (WrOff == pRing->SizeOfBuffer) {
 80026d8:	68fb      	ldr	r3, [r7, #12]
 80026da:	689b      	ldr	r3, [r3, #8]
 80026dc:	69fa      	ldr	r2, [r7, #28]
 80026de:	429a      	cmp	r2, r3
 80026e0:	d101      	bne.n	80026e6 <_WriteBlocking+0xa2>
      WrOff = 0u;
 80026e2:	2300      	movs	r3, #0
 80026e4:	61fb      	str	r3, [r7, #28]
    }
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    pRing->WrOff = WrOff;
 80026e6:	68fb      	ldr	r3, [r7, #12]
 80026e8:	69fa      	ldr	r2, [r7, #28]
 80026ea:	60da      	str	r2, [r3, #12]
  } while (NumBytes);
 80026ec:	687b      	ldr	r3, [r7, #4]
 80026ee:	2b00      	cmp	r3, #0
 80026f0:	d1b3      	bne.n	800265a <_WriteBlocking+0x16>
  return NumBytesWritten;
 80026f2:	6a3b      	ldr	r3, [r7, #32]
}
 80026f4:	0018      	movs	r0, r3
 80026f6:	46bd      	mov	sp, r7
 80026f8:	b00a      	add	sp, #40	; 0x28
 80026fa:	bd80      	pop	{r7, pc}

080026fc <_WriteNoCheck>:
*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
*
*  Notes
*    (1) If there might not be enough space in the "Up"-buffer, call _WriteBlocking
*/
static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
 80026fc:	b580      	push	{r7, lr}
 80026fe:	b088      	sub	sp, #32
 8002700:	af00      	add	r7, sp, #0
 8002702:	60f8      	str	r0, [r7, #12]
 8002704:	60b9      	str	r1, [r7, #8]
 8002706:	607a      	str	r2, [r7, #4]
  unsigned NumBytesAtOnce;
  unsigned WrOff;
  unsigned Rem;
  volatile char* pDst;

  WrOff = pRing->WrOff;
 8002708:	68fb      	ldr	r3, [r7, #12]
 800270a:	68db      	ldr	r3, [r3, #12]
 800270c:	61fb      	str	r3, [r7, #28]
  Rem = pRing->SizeOfBuffer - WrOff;
 800270e:	68fb      	ldr	r3, [r7, #12]
 8002710:	689a      	ldr	r2, [r3, #8]
 8002712:	69fb      	ldr	r3, [r7, #28]
 8002714:	1ad3      	subs	r3, r2, r3
 8002716:	61bb      	str	r3, [r7, #24]
  if (Rem > NumBytes) {
 8002718:	69ba      	ldr	r2, [r7, #24]
 800271a:	687b      	ldr	r3, [r7, #4]
 800271c:	429a      	cmp	r2, r3
 800271e:	d910      	bls.n	8002742 <_WriteNoCheck+0x46>
    //
    // All data fits before wrap around
    //
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
 8002720:	68fb      	ldr	r3, [r7, #12]
 8002722:	685a      	ldr	r2, [r3, #4]
 8002724:	69fb      	ldr	r3, [r7, #28]
 8002726:	18d3      	adds	r3, r2, r3
 8002728:	613b      	str	r3, [r7, #16]
      *pDst++ = *pData++;
    };
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    pRing->WrOff = WrOff;
#else
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytes);
 800272a:	687a      	ldr	r2, [r7, #4]
 800272c:	68b9      	ldr	r1, [r7, #8]
 800272e:	693b      	ldr	r3, [r7, #16]
 8002730:	0018      	movs	r0, r3
 8002732:	f01a fa55 	bl	801cbe0 <memcpy>
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    pRing->WrOff = WrOff + NumBytes;
 8002736:	69fa      	ldr	r2, [r7, #28]
 8002738:	687b      	ldr	r3, [r7, #4]
 800273a:	18d2      	adds	r2, r2, r3
 800273c:	68fb      	ldr	r3, [r7, #12]
 800273e:	60da      	str	r2, [r3, #12]
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    pRing->WrOff = NumBytesAtOnce;
#endif
  }
}
 8002740:	e01e      	b.n	8002780 <_WriteNoCheck+0x84>
    NumBytesAtOnce = Rem;
 8002742:	69bb      	ldr	r3, [r7, #24]
 8002744:	617b      	str	r3, [r7, #20]
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
 8002746:	68fb      	ldr	r3, [r7, #12]
 8002748:	685a      	ldr	r2, [r3, #4]
 800274a:	69fb      	ldr	r3, [r7, #28]
 800274c:	18d3      	adds	r3, r2, r3
 800274e:	613b      	str	r3, [r7, #16]
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytesAtOnce);
 8002750:	697a      	ldr	r2, [r7, #20]
 8002752:	68b9      	ldr	r1, [r7, #8]
 8002754:	693b      	ldr	r3, [r7, #16]
 8002756:	0018      	movs	r0, r3
 8002758:	f01a fa42 	bl	801cbe0 <memcpy>
    NumBytesAtOnce = NumBytes - Rem;
 800275c:	687a      	ldr	r2, [r7, #4]
 800275e:	69bb      	ldr	r3, [r7, #24]
 8002760:	1ad3      	subs	r3, r2, r3
 8002762:	617b      	str	r3, [r7, #20]
    pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
 8002764:	68fb      	ldr	r3, [r7, #12]
 8002766:	685b      	ldr	r3, [r3, #4]
 8002768:	613b      	str	r3, [r7, #16]
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
 800276a:	68ba      	ldr	r2, [r7, #8]
 800276c:	69bb      	ldr	r3, [r7, #24]
 800276e:	18d1      	adds	r1, r2, r3
 8002770:	697a      	ldr	r2, [r7, #20]
 8002772:	693b      	ldr	r3, [r7, #16]
 8002774:	0018      	movs	r0, r3
 8002776:	f01a fa33 	bl	801cbe0 <memcpy>
    pRing->WrOff = NumBytesAtOnce;
 800277a:	68fb      	ldr	r3, [r7, #12]
 800277c:	697a      	ldr	r2, [r7, #20]
 800277e:	60da      	str	r2, [r3, #12]
}
 8002780:	46c0      	nop			; (mov r8, r8)
 8002782:	46bd      	mov	sp, r7
 8002784:	b008      	add	sp, #32
 8002786:	bd80      	pop	{r7, pc}

08002788 <_GetAvailWriteSpace>:
*    pRing        Ring buffer to check.
*
*  Return value
*    Number of bytes that are free in the buffer.
*/
static unsigned _GetAvailWriteSpace(SEGGER_RTT_BUFFER_UP* pRing) {
 8002788:	b580      	push	{r7, lr}
 800278a:	b086      	sub	sp, #24
 800278c:	af00      	add	r7, sp, #0
 800278e:	6078      	str	r0, [r7, #4]
  unsigned r;
  //
  // Avoid warnings regarding volatile access order.  It's not a problem
  // in this case, but dampen compiler enthusiasm.
  //
  RdOff = pRing->RdOff;
 8002790:	687b      	ldr	r3, [r7, #4]
 8002792:	691b      	ldr	r3, [r3, #16]
 8002794:	613b      	str	r3, [r7, #16]
  WrOff = pRing->WrOff;
 8002796:	687b      	ldr	r3, [r7, #4]
 8002798:	68db      	ldr	r3, [r3, #12]
 800279a:	60fb      	str	r3, [r7, #12]
  if (RdOff <= WrOff) {
 800279c:	693a      	ldr	r2, [r7, #16]
 800279e:	68fb      	ldr	r3, [r7, #12]
 80027a0:	429a      	cmp	r2, r3
 80027a2:	d808      	bhi.n	80027b6 <_GetAvailWriteSpace+0x2e>
    r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
 80027a4:	687b      	ldr	r3, [r7, #4]
 80027a6:	689a      	ldr	r2, [r3, #8]
 80027a8:	68fb      	ldr	r3, [r7, #12]
 80027aa:	1ad2      	subs	r2, r2, r3
 80027ac:	693b      	ldr	r3, [r7, #16]
 80027ae:	18d3      	adds	r3, r2, r3
 80027b0:	3b01      	subs	r3, #1
 80027b2:	617b      	str	r3, [r7, #20]
 80027b4:	e004      	b.n	80027c0 <_GetAvailWriteSpace+0x38>
  } else {
    r = RdOff - WrOff - 1u;
 80027b6:	693a      	ldr	r2, [r7, #16]
 80027b8:	68fb      	ldr	r3, [r7, #12]
 80027ba:	1ad3      	subs	r3, r2, r3
 80027bc:	3b01      	subs	r3, #1
 80027be:	617b      	str	r3, [r7, #20]
  }
  return r;
 80027c0:	697b      	ldr	r3, [r7, #20]
}
 80027c2:	0018      	movs	r0, r3
 80027c4:	46bd      	mov	sp, r7
 80027c6:	b006      	add	sp, #24
 80027c8:	bd80      	pop	{r7, pc}
	...

080027cc <SEGGER_RTT_WriteNoLock>:
*    (1) Data is stored according to buffer flags.
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
 80027cc:	b580      	push	{r7, lr}
 80027ce:	b088      	sub	sp, #32
 80027d0:	af00      	add	r7, sp, #0
 80027d2:	60f8      	str	r0, [r7, #12]
 80027d4:	60b9      	str	r1, [r7, #8]
 80027d6:	607a      	str	r2, [r7, #4]
  const char*           pData;
  SEGGER_RTT_BUFFER_UP* pRing;
  //
  // Get "to-host" ring buffer.
  //
  pData = (const char *)pBuffer;
 80027d8:	68bb      	ldr	r3, [r7, #8]
 80027da:	61bb      	str	r3, [r7, #24]
  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
 80027dc:	68fb      	ldr	r3, [r7, #12]
 80027de:	1c5a      	adds	r2, r3, #1
 80027e0:	0013      	movs	r3, r2
 80027e2:	005b      	lsls	r3, r3, #1
 80027e4:	189b      	adds	r3, r3, r2
 80027e6:	00db      	lsls	r3, r3, #3
 80027e8:	4a23      	ldr	r2, [pc, #140]	; (8002878 <SEGGER_RTT_WriteNoLock+0xac>)
 80027ea:	189b      	adds	r3, r3, r2
 80027ec:	617b      	str	r3, [r7, #20]
  //
  // How we output depends upon the mode...
  //
  switch (pRing->Flags) {
 80027ee:	697b      	ldr	r3, [r7, #20]
 80027f0:	695b      	ldr	r3, [r3, #20]
 80027f2:	2b02      	cmp	r3, #2
 80027f4:	d02e      	beq.n	8002854 <SEGGER_RTT_WriteNoLock+0x88>
 80027f6:	d836      	bhi.n	8002866 <SEGGER_RTT_WriteNoLock+0x9a>
 80027f8:	2b00      	cmp	r3, #0
 80027fa:	d002      	beq.n	8002802 <SEGGER_RTT_WriteNoLock+0x36>
 80027fc:	2b01      	cmp	r3, #1
 80027fe:	d016      	beq.n	800282e <SEGGER_RTT_WriteNoLock+0x62>
 8002800:	e031      	b.n	8002866 <SEGGER_RTT_WriteNoLock+0x9a>
  case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
    //
    // If we are in skip mode and there is no space for the whole
    // of this output, don't bother.
    //
    Avail = _GetAvailWriteSpace(pRing);
 8002802:	697b      	ldr	r3, [r7, #20]
 8002804:	0018      	movs	r0, r3
 8002806:	f7ff ffbf 	bl	8002788 <_GetAvailWriteSpace>
 800280a:	0003      	movs	r3, r0
 800280c:	613b      	str	r3, [r7, #16]
    if (Avail < NumBytes) {
 800280e:	693a      	ldr	r2, [r7, #16]
 8002810:	687b      	ldr	r3, [r7, #4]
 8002812:	429a      	cmp	r2, r3
 8002814:	d202      	bcs.n	800281c <SEGGER_RTT_WriteNoLock+0x50>
      Status = 0u;
 8002816:	2300      	movs	r3, #0
 8002818:	61fb      	str	r3, [r7, #28]
    } else {
      Status = NumBytes;
      _WriteNoCheck(pRing, pData, NumBytes);
    }
    break;
 800281a:	e027      	b.n	800286c <SEGGER_RTT_WriteNoLock+0xa0>
      Status = NumBytes;
 800281c:	687b      	ldr	r3, [r7, #4]
 800281e:	61fb      	str	r3, [r7, #28]
      _WriteNoCheck(pRing, pData, NumBytes);
 8002820:	687a      	ldr	r2, [r7, #4]
 8002822:	69b9      	ldr	r1, [r7, #24]
 8002824:	697b      	ldr	r3, [r7, #20]
 8002826:	0018      	movs	r0, r3
 8002828:	f7ff ff68 	bl	80026fc <_WriteNoCheck>
    break;
 800282c:	e01e      	b.n	800286c <SEGGER_RTT_WriteNoLock+0xa0>
  case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
    //
    // If we are in trim mode, trim to what we can output without blocking.
    //
    Avail = _GetAvailWriteSpace(pRing);
 800282e:	697b      	ldr	r3, [r7, #20]
 8002830:	0018      	movs	r0, r3
 8002832:	f7ff ffa9 	bl	8002788 <_GetAvailWriteSpace>
 8002836:	0003      	movs	r3, r0
 8002838:	613b      	str	r3, [r7, #16]
    Status = Avail < NumBytes ? Avail : NumBytes;
 800283a:	693a      	ldr	r2, [r7, #16]
 800283c:	687b      	ldr	r3, [r7, #4]
 800283e:	4293      	cmp	r3, r2
 8002840:	d900      	bls.n	8002844 <SEGGER_RTT_WriteNoLock+0x78>
 8002842:	0013      	movs	r3, r2
 8002844:	61fb      	str	r3, [r7, #28]
    _WriteNoCheck(pRing, pData, Status);
 8002846:	69fa      	ldr	r2, [r7, #28]
 8002848:	69b9      	ldr	r1, [r7, #24]
 800284a:	697b      	ldr	r3, [r7, #20]
 800284c:	0018      	movs	r0, r3
 800284e:	f7ff ff55 	bl	80026fc <_WriteNoCheck>
    break;
 8002852:	e00b      	b.n	800286c <SEGGER_RTT_WriteNoLock+0xa0>
  case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
    //
    // If we are in blocking mode, output everything.
    //
    Status = _WriteBlocking(pRing, pData, NumBytes);
 8002854:	687a      	ldr	r2, [r7, #4]
 8002856:	69b9      	ldr	r1, [r7, #24]
 8002858:	697b      	ldr	r3, [r7, #20]
 800285a:	0018      	movs	r0, r3
 800285c:	f7ff fef2 	bl	8002644 <_WriteBlocking>
 8002860:	0003      	movs	r3, r0
 8002862:	61fb      	str	r3, [r7, #28]
    break;
 8002864:	e002      	b.n	800286c <SEGGER_RTT_WriteNoLock+0xa0>
  default:
    Status = 0u;
 8002866:	2300      	movs	r3, #0
 8002868:	61fb      	str	r3, [r7, #28]
    break;
 800286a:	46c0      	nop			; (mov r8, r8)
  }
  //
  // Finish up.
  //
  return Status;
 800286c:	69fb      	ldr	r3, [r7, #28]
}
 800286e:	0018      	movs	r0, r3
 8002870:	46bd      	mov	sp, r7
 8002872:	b008      	add	sp, #32
 8002874:	bd80      	pop	{r7, pc}
 8002876:	46c0      	nop			; (mov r8, r8)
 8002878:	20001c48 	.word	0x20001c48

0800287c <SEGGER_RTT_Write>:
*    Number of bytes which have been stored in the "Up"-buffer.
*
*  Notes
*    (1) Data is stored according to buffer flags.
*/
unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
 800287c:	b580      	push	{r7, lr}
 800287e:	b088      	sub	sp, #32
 8002880:	af00      	add	r7, sp, #0
 8002882:	60f8      	str	r0, [r7, #12]
 8002884:	60b9      	str	r1, [r7, #8]
 8002886:	607a      	str	r2, [r7, #4]
  unsigned Status;

  INIT();
 8002888:	4b0f      	ldr	r3, [pc, #60]	; (80028c8 <SEGGER_RTT_Write+0x4c>)
 800288a:	61fb      	str	r3, [r7, #28]
 800288c:	69fb      	ldr	r3, [r7, #28]
 800288e:	781b      	ldrb	r3, [r3, #0]
 8002890:	b2db      	uxtb	r3, r3
 8002892:	2b00      	cmp	r3, #0
 8002894:	d101      	bne.n	800289a <SEGGER_RTT_Write+0x1e>
 8002896:	f7ff fe81 	bl	800259c <_DoInit>
  SEGGER_RTT_LOCK();
 800289a:	f3ef 8310 	mrs	r3, PRIMASK
 800289e:	2101      	movs	r1, #1
 80028a0:	f381 8810 	msr	PRIMASK, r1
 80028a4:	61bb      	str	r3, [r7, #24]
  Status = SEGGER_RTT_WriteNoLock(BufferIndex, pBuffer, NumBytes);  // Call the non-locking write function
 80028a6:	687a      	ldr	r2, [r7, #4]
 80028a8:	68b9      	ldr	r1, [r7, #8]
 80028aa:	68fb      	ldr	r3, [r7, #12]
 80028ac:	0018      	movs	r0, r3
 80028ae:	f7ff ff8d 	bl	80027cc <SEGGER_RTT_WriteNoLock>
 80028b2:	0003      	movs	r3, r0
 80028b4:	617b      	str	r3, [r7, #20]
  SEGGER_RTT_UNLOCK();
 80028b6:	69bb      	ldr	r3, [r7, #24]
 80028b8:	f383 8810 	msr	PRIMASK, r3
  return Status;
 80028bc:	697b      	ldr	r3, [r7, #20]
}
 80028be:	0018      	movs	r0, r3
 80028c0:	46bd      	mov	sp, r7
 80028c2:	b008      	add	sp, #32
 80028c4:	bd80      	pop	{r7, pc}
 80028c6:	46c0      	nop			; (mov r8, r8)
 80028c8:	20001c48 	.word	0x20001c48

080028cc <SEGGER_RTT_Init>:
*  Function description
*    Initializes the RTT Control Block.
*    Should be used in RAM targets, at start of the application.
*
*/
void SEGGER_RTT_Init (void) {
 80028cc:	b580      	push	{r7, lr}
 80028ce:	af00      	add	r7, sp, #0
  _DoInit();
 80028d0:	f7ff fe64 	bl	800259c <_DoInit>
}
 80028d4:	46c0      	nop			; (mov r8, r8)
 80028d6:	46bd      	mov	sp, r7
 80028d8:	bd80      	pop	{r7, pc}
	...

080028dc <app_debug_rtt_raw>:
    
    return n;
}

int32_t app_debug_rtt_raw(const char *fmt,...)
{
 80028dc:	b40f      	push	{r0, r1, r2, r3}
 80028de:	b580      	push	{r7, lr}
 80028e0:	b084      	sub	sp, #16
 80028e2:	af00      	add	r7, sp, #0
    int32_t     n;

    char *p = &m_debug_buffer[0];
 80028e4:	4b15      	ldr	r3, [pc, #84]	; (800293c <app_debug_rtt_raw+0x60>)
 80028e6:	60fb      	str	r3, [r7, #12]
    int32_t size = SEGGER_RTT_PRINTF_BUFFER_SIZE;
 80028e8:	2380      	movs	r3, #128	; 0x80
 80028ea:	00db      	lsls	r3, r3, #3
 80028ec:	60bb      	str	r3, [r7, #8]
    va_list args;

    va_start (args, fmt);
 80028ee:	231c      	movs	r3, #28
 80028f0:	18fb      	adds	r3, r7, r3
 80028f2:	603b      	str	r3, [r7, #0]
    n = vsnprintf(p, size, fmt, args);
 80028f4:	68b9      	ldr	r1, [r7, #8]
 80028f6:	683b      	ldr	r3, [r7, #0]
 80028f8:	69ba      	ldr	r2, [r7, #24]
 80028fa:	68f8      	ldr	r0, [r7, #12]
 80028fc:	f01a fb72 	bl	801cfe4 <vsniprintf>
 8002900:	0003      	movs	r3, r0
 8002902:	607b      	str	r3, [r7, #4]
    if (n > (int)size) 
 8002904:	687a      	ldr	r2, [r7, #4]
 8002906:	68bb      	ldr	r3, [r7, #8]
 8002908:	429a      	cmp	r2, r3
 800290a:	dd06      	ble.n	800291a <app_debug_rtt_raw+0x3e>
    {
        SEGGER_RTT_Write(0, m_debug_buffer, size);
 800290c:	68ba      	ldr	r2, [r7, #8]
 800290e:	4b0b      	ldr	r3, [pc, #44]	; (800293c <app_debug_rtt_raw+0x60>)
 8002910:	0019      	movs	r1, r3
 8002912:	2000      	movs	r0, #0
 8002914:	f7ff ffb2 	bl	800287c <SEGGER_RTT_Write>
 8002918:	e008      	b.n	800292c <app_debug_rtt_raw+0x50>
    } 
    else if (n > 0) 
 800291a:	687b      	ldr	r3, [r7, #4]
 800291c:	2b00      	cmp	r3, #0
 800291e:	dd05      	ble.n	800292c <app_debug_rtt_raw+0x50>
    {
        SEGGER_RTT_Write(0, m_debug_buffer, n);
 8002920:	687a      	ldr	r2, [r7, #4]
 8002922:	4b06      	ldr	r3, [pc, #24]	; (800293c <app_debug_rtt_raw+0x60>)
 8002924:	0019      	movs	r1, r3
 8002926:	2000      	movs	r0, #0
 8002928:	f7ff ffa8 	bl	800287c <SEGGER_RTT_Write>
    }
    va_end(args);
    
    return n;
 800292c:	687b      	ldr	r3, [r7, #4]
}
 800292e:	0018      	movs	r0, r3
 8002930:	46bd      	mov	sp, r7
 8002932:	b004      	add	sp, #16
 8002934:	bc80      	pop	{r7}
 8002936:	bc08      	pop	{r3}
 8002938:	b004      	add	sp, #16
 800293a:	4718      	bx	r3
 800293c:	200012dc 	.word	0x200012dc

08002940 <RingBuffer_Init>:
#include "ringbuffer.h"


void RingBuffer_Init(RingBuffer_Types* ringbuffer, int BufferSize)
{
 8002940:	b580      	push	{r7, lr}
 8002942:	b082      	sub	sp, #8
 8002944:	af00      	add	r7, sp, #0
 8002946:	6078      	str	r0, [r7, #4]
 8002948:	6039      	str	r1, [r7, #0]
    ringbuffer->BufferSize = BufferSize;
 800294a:	687b      	ldr	r3, [r7, #4]
 800294c:	683a      	ldr	r2, [r7, #0]
 800294e:	601a      	str	r2, [r3, #0]
    ringbuffer->Head = 0;
 8002950:	687b      	ldr	r3, [r7, #4]
 8002952:	2200      	movs	r2, #0
 8002954:	605a      	str	r2, [r3, #4]
    ringbuffer->Tail = 0;
 8002956:	687b      	ldr	r3, [r7, #4]
 8002958:	2200      	movs	r2, #0
 800295a:	609a      	str	r2, [r3, #8]
    ringbuffer->u8Buffer = (uint8_t*)malloc(BufferSize*sizeof(uint8_t));
 800295c:	683b      	ldr	r3, [r7, #0]
 800295e:	0018      	movs	r0, r3
 8002960:	f01a f926 	bl	801cbb0 <malloc>
 8002964:	0003      	movs	r3, r0
 8002966:	001a      	movs	r2, r3
 8002968:	687b      	ldr	r3, [r7, #4]
 800296a:	60da      	str	r2, [r3, #12]
}
 800296c:	46c0      	nop			; (mov r8, r8)
 800296e:	46bd      	mov	sp, r7
 8002970:	b002      	add	sp, #8
 8002972:	bd80      	pop	{r7, pc}

08002974 <RingBuffer_Push>:

// Day 1 Byte vÃ o RingBuffer
uint8_t RingBuffer_Push(RingBuffer_Types* ringbuffer, uint8_t BytePush)
{
 8002974:	b580      	push	{r7, lr}
 8002976:	b082      	sub	sp, #8
 8002978:	af00      	add	r7, sp, #0
 800297a:	6078      	str	r0, [r7, #4]
 800297c:	000a      	movs	r2, r1
 800297e:	1cfb      	adds	r3, r7, #3
 8002980:	701a      	strb	r2, [r3, #0]
    if((ringbuffer->Head - ringbuffer->Tail == (ringbuffer->BufferSize - 1))
 8002982:	687b      	ldr	r3, [r7, #4]
 8002984:	685a      	ldr	r2, [r3, #4]
 8002986:	687b      	ldr	r3, [r7, #4]
 8002988:	689b      	ldr	r3, [r3, #8]
 800298a:	1ad2      	subs	r2, r2, r3
 800298c:	687b      	ldr	r3, [r7, #4]
 800298e:	681b      	ldr	r3, [r3, #0]
 8002990:	3b01      	subs	r3, #1
 8002992:	429a      	cmp	r2, r3
 8002994:	d009      	beq.n	80029aa <RingBuffer_Push+0x36>
       || (ringbuffer->Tail - ringbuffer->Head == (ringbuffer->BufferSize - 1)))
 8002996:	687b      	ldr	r3, [r7, #4]
 8002998:	689a      	ldr	r2, [r3, #8]
 800299a:	687b      	ldr	r3, [r7, #4]
 800299c:	685b      	ldr	r3, [r3, #4]
 800299e:	1ad2      	subs	r2, r2, r3
 80029a0:	687b      	ldr	r3, [r7, #4]
 80029a2:	681b      	ldr	r3, [r3, #0]
 80029a4:	3b01      	subs	r3, #1
 80029a6:	429a      	cmp	r2, r3
 80029a8:	d101      	bne.n	80029ae <RingBuffer_Push+0x3a>
       {
        return E_NOT_OK; // return E_NOT_OK khi bo nho Full
 80029aa:	2300      	movs	r3, #0
 80029ac:	e018      	b.n	80029e0 <RingBuffer_Push+0x6c>
       }
    ringbuffer->u8Buffer[ringbuffer->Head] = BytePush;
 80029ae:	687b      	ldr	r3, [r7, #4]
 80029b0:	68da      	ldr	r2, [r3, #12]
 80029b2:	687b      	ldr	r3, [r7, #4]
 80029b4:	685b      	ldr	r3, [r3, #4]
 80029b6:	18d3      	adds	r3, r2, r3
 80029b8:	1cfa      	adds	r2, r7, #3
 80029ba:	7812      	ldrb	r2, [r2, #0]
 80029bc:	701a      	strb	r2, [r3, #0]
    if(ringbuffer->Head == (ringbuffer->BufferSize - 1))
 80029be:	687b      	ldr	r3, [r7, #4]
 80029c0:	685a      	ldr	r2, [r3, #4]
 80029c2:	687b      	ldr	r3, [r7, #4]
 80029c4:	681b      	ldr	r3, [r3, #0]
 80029c6:	3b01      	subs	r3, #1
 80029c8:	429a      	cmp	r2, r3
 80029ca:	d103      	bne.n	80029d4 <RingBuffer_Push+0x60>
    {
        ringbuffer->Head = 0;
 80029cc:	687b      	ldr	r3, [r7, #4]
 80029ce:	2200      	movs	r2, #0
 80029d0:	605a      	str	r2, [r3, #4]
 80029d2:	e004      	b.n	80029de <RingBuffer_Push+0x6a>
    }
    else
    {
        ringbuffer->Head += 1;
 80029d4:	687b      	ldr	r3, [r7, #4]
 80029d6:	685b      	ldr	r3, [r3, #4]
 80029d8:	1c5a      	adds	r2, r3, #1
 80029da:	687b      	ldr	r3, [r7, #4]
 80029dc:	605a      	str	r2, [r3, #4]
    }
    return E_OK;
 80029de:	2301      	movs	r3, #1
}
 80029e0:	0018      	movs	r0, r3
 80029e2:	46bd      	mov	sp, r7
 80029e4:	b002      	add	sp, #8
 80029e6:	bd80      	pop	{r7, pc}

080029e8 <RingBuffer_Pop>:

// Doc 1 byte tÆ° RingBuffer
uint8_t RingBuffer_Pop(RingBuffer_Types* ringbuffer)
{
 80029e8:	b580      	push	{r7, lr}
 80029ea:	b084      	sub	sp, #16
 80029ec:	af00      	add	r7, sp, #0
 80029ee:	6078      	str	r0, [r7, #4]
    uint8_t BytePush = 0;
 80029f0:	210f      	movs	r1, #15
 80029f2:	187b      	adds	r3, r7, r1
 80029f4:	2200      	movs	r2, #0
 80029f6:	701a      	strb	r2, [r3, #0]
    if(ringbuffer->Head == ringbuffer->Tail)
 80029f8:	687b      	ldr	r3, [r7, #4]
 80029fa:	685a      	ldr	r2, [r3, #4]
 80029fc:	687b      	ldr	r3, [r7, #4]
 80029fe:	689b      	ldr	r3, [r3, #8]
 8002a00:	429a      	cmp	r2, r3
 8002a02:	d102      	bne.n	8002a0a <RingBuffer_Pop+0x22>
    {
        return BytePush; // Return Null khi bo nho Empty
 8002a04:	187b      	adds	r3, r7, r1
 8002a06:	781b      	ldrb	r3, [r3, #0]
 8002a08:	e01b      	b.n	8002a42 <RingBuffer_Pop+0x5a>
    }
    BytePush = ringbuffer->u8Buffer[ringbuffer->Tail];
 8002a0a:	687b      	ldr	r3, [r7, #4]
 8002a0c:	68da      	ldr	r2, [r3, #12]
 8002a0e:	687b      	ldr	r3, [r7, #4]
 8002a10:	689b      	ldr	r3, [r3, #8]
 8002a12:	18d2      	adds	r2, r2, r3
 8002a14:	230f      	movs	r3, #15
 8002a16:	18fb      	adds	r3, r7, r3
 8002a18:	7812      	ldrb	r2, [r2, #0]
 8002a1a:	701a      	strb	r2, [r3, #0]
    if(ringbuffer->Tail == (ringbuffer->BufferSize - 1))
 8002a1c:	687b      	ldr	r3, [r7, #4]
 8002a1e:	689a      	ldr	r2, [r3, #8]
 8002a20:	687b      	ldr	r3, [r7, #4]
 8002a22:	681b      	ldr	r3, [r3, #0]
 8002a24:	3b01      	subs	r3, #1
 8002a26:	429a      	cmp	r2, r3
 8002a28:	d103      	bne.n	8002a32 <RingBuffer_Pop+0x4a>
    {
        ringbuffer->Tail = 0;
 8002a2a:	687b      	ldr	r3, [r7, #4]
 8002a2c:	2200      	movs	r2, #0
 8002a2e:	609a      	str	r2, [r3, #8]
 8002a30:	e004      	b.n	8002a3c <RingBuffer_Pop+0x54>
    }
    else
    {
        ringbuffer->Tail += 1;
 8002a32:	687b      	ldr	r3, [r7, #4]
 8002a34:	689b      	ldr	r3, [r3, #8]
 8002a36:	1c5a      	adds	r2, r3, #1
 8002a38:	687b      	ldr	r3, [r7, #4]
 8002a3a:	609a      	str	r2, [r3, #8]
    }
    return BytePush;
 8002a3c:	230f      	movs	r3, #15
 8002a3e:	18fb      	adds	r3, r7, r3
 8002a40:	781b      	ldrb	r3, [r3, #0]
}
 8002a42:	0018      	movs	r0, r3
 8002a44:	46bd      	mov	sp, r7
 8002a46:	b004      	add	sp, #16
 8002a48:	bd80      	pop	{r7, pc}

08002a4a <RingBuffer_GetBuffer>:
// Doc toan bo du lieu trong RingBuffer gÃ¡n vÃ o return Buffer
void RingBuffer_GetBuffer(uint8_t* retBuffer, uint16_t* dataLength, RingBuffer_Types* ringbuffer)
{
 8002a4a:	b590      	push	{r4, r7, lr}
 8002a4c:	b087      	sub	sp, #28
 8002a4e:	af00      	add	r7, sp, #0
 8002a50:	60f8      	str	r0, [r7, #12]
 8002a52:	60b9      	str	r1, [r7, #8]
 8002a54:	607a      	str	r2, [r7, #4]
    int Num_Elements = RingBuffer_GetNumberElements(ringbuffer);
 8002a56:	687b      	ldr	r3, [r7, #4]
 8002a58:	0018      	movs	r0, r3
 8002a5a:	f000 f821 	bl	8002aa0 <RingBuffer_GetNumberElements>
 8002a5e:	0003      	movs	r3, r0
 8002a60:	613b      	str	r3, [r7, #16]
    if(Num_Elements == 0)
 8002a62:	693b      	ldr	r3, [r7, #16]
 8002a64:	2b00      	cmp	r3, #0
 8002a66:	d017      	beq.n	8002a98 <RingBuffer_GetBuffer+0x4e>
    {
    	return;
    }
    for(int CountByte = 0; CountByte < Num_Elements; CountByte ++)
 8002a68:	2300      	movs	r3, #0
 8002a6a:	617b      	str	r3, [r7, #20]
 8002a6c:	e00b      	b.n	8002a86 <RingBuffer_GetBuffer+0x3c>
    {
        retBuffer[CountByte] = RingBuffer_Pop(ringbuffer);
 8002a6e:	697b      	ldr	r3, [r7, #20]
 8002a70:	68fa      	ldr	r2, [r7, #12]
 8002a72:	18d4      	adds	r4, r2, r3
 8002a74:	687b      	ldr	r3, [r7, #4]
 8002a76:	0018      	movs	r0, r3
 8002a78:	f7ff ffb6 	bl	80029e8 <RingBuffer_Pop>
 8002a7c:	0003      	movs	r3, r0
 8002a7e:	7023      	strb	r3, [r4, #0]
    for(int CountByte = 0; CountByte < Num_Elements; CountByte ++)
 8002a80:	697b      	ldr	r3, [r7, #20]
 8002a82:	3301      	adds	r3, #1
 8002a84:	617b      	str	r3, [r7, #20]
 8002a86:	697a      	ldr	r2, [r7, #20]
 8002a88:	693b      	ldr	r3, [r7, #16]
 8002a8a:	429a      	cmp	r2, r3
 8002a8c:	dbef      	blt.n	8002a6e <RingBuffer_GetBuffer+0x24>
    }
    *dataLength = Num_Elements;
 8002a8e:	693b      	ldr	r3, [r7, #16]
 8002a90:	b29a      	uxth	r2, r3
 8002a92:	68bb      	ldr	r3, [r7, #8]
 8002a94:	801a      	strh	r2, [r3, #0]
 8002a96:	e000      	b.n	8002a9a <RingBuffer_GetBuffer+0x50>
    	return;
 8002a98:	46c0      	nop			; (mov r8, r8)
}
 8002a9a:	46bd      	mov	sp, r7
 8002a9c:	b007      	add	sp, #28
 8002a9e:	bd90      	pop	{r4, r7, pc}

08002aa0 <RingBuffer_GetNumberElements>:

// Lay tong so byte du lieu trong RingBuffer
int RingBuffer_GetNumberElements(RingBuffer_Types* ringbuffer)
{
 8002aa0:	b580      	push	{r7, lr}
 8002aa2:	b084      	sub	sp, #16
 8002aa4:	af00      	add	r7, sp, #0
 8002aa6:	6078      	str	r0, [r7, #4]
    int Num_Element = 0;
 8002aa8:	2300      	movs	r3, #0
 8002aaa:	60fb      	str	r3, [r7, #12]
    if (ringbuffer->Head >= ringbuffer->Tail)
 8002aac:	687b      	ldr	r3, [r7, #4]
 8002aae:	685a      	ldr	r2, [r3, #4]
 8002ab0:	687b      	ldr	r3, [r7, #4]
 8002ab2:	689b      	ldr	r3, [r3, #8]
 8002ab4:	429a      	cmp	r2, r3
 8002ab6:	db06      	blt.n	8002ac6 <RingBuffer_GetNumberElements+0x26>
    {
        Num_Element = ringbuffer->Head - ringbuffer->Tail;
 8002ab8:	687b      	ldr	r3, [r7, #4]
 8002aba:	685a      	ldr	r2, [r3, #4]
 8002abc:	687b      	ldr	r3, [r7, #4]
 8002abe:	689b      	ldr	r3, [r3, #8]
 8002ac0:	1ad3      	subs	r3, r2, r3
 8002ac2:	60fb      	str	r3, [r7, #12]
 8002ac4:	e008      	b.n	8002ad8 <RingBuffer_GetNumberElements+0x38>
    }
    else
    {
        Num_Element = ringbuffer->BufferSize - ringbuffer->Tail + ringbuffer->Head;
 8002ac6:	687b      	ldr	r3, [r7, #4]
 8002ac8:	681a      	ldr	r2, [r3, #0]
 8002aca:	687b      	ldr	r3, [r7, #4]
 8002acc:	689b      	ldr	r3, [r3, #8]
 8002ace:	1ad2      	subs	r2, r2, r3
 8002ad0:	687b      	ldr	r3, [r7, #4]
 8002ad2:	685b      	ldr	r3, [r3, #4]
 8002ad4:	18d3      	adds	r3, r2, r3
 8002ad6:	60fb      	str	r3, [r7, #12]
    }
    return Num_Element;
 8002ad8:	68fb      	ldr	r3, [r7, #12]
}
 8002ada:	0018      	movs	r0, r3
 8002adc:	46bd      	mov	sp, r7
 8002ade:	b004      	add	sp, #16
 8002ae0:	bd80      	pop	{r7, pc}

08002ae2 <Erase_RingBuffer>:
// Xoa toan bo RingBuffer
void Erase_RingBuffer(RingBuffer_Types* ringbuffer)
{
 8002ae2:	b580      	push	{r7, lr}
 8002ae4:	b082      	sub	sp, #8
 8002ae6:	af00      	add	r7, sp, #0
 8002ae8:	6078      	str	r0, [r7, #4]
    ringbuffer->Head = ringbuffer->Tail;
 8002aea:	687b      	ldr	r3, [r7, #4]
 8002aec:	689a      	ldr	r2, [r3, #8]
 8002aee:	687b      	ldr	r3, [r7, #4]
 8002af0:	605a      	str	r2, [r3, #4]
}
 8002af2:	46c0      	nop			; (mov r8, r8)
 8002af4:	46bd      	mov	sp, r7
 8002af6:	b002      	add	sp, #8
 8002af8:	bd80      	pop	{r7, pc}
	...

08002afc <HAL_Init>:
  *        In the default implementation,Systick is used as source of time base.
  *        the tick variable is incremented each 1ms in its ISR.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8002afc:	b580      	push	{r7, lr}
 8002afe:	b082      	sub	sp, #8
 8002b00:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
 8002b02:	1dfb      	adds	r3, r7, #7
 8002b04:	2200      	movs	r2, #0
 8002b06:	701a      	strb	r2, [r3, #0]
#if (BUFFER_CACHE_DISABLE != 0)
  __HAL_FLASH_BUFFER_CACHE_DISABLE();
#endif /* BUFFER_CACHE_DISABLE */

#if (PREREAD_ENABLE != 0)
  __HAL_FLASH_PREREAD_BUFFER_ENABLE();
 8002b08:	4b0b      	ldr	r3, [pc, #44]	; (8002b38 <HAL_Init+0x3c>)
 8002b0a:	681a      	ldr	r2, [r3, #0]
 8002b0c:	4b0a      	ldr	r3, [pc, #40]	; (8002b38 <HAL_Init+0x3c>)
 8002b0e:	2140      	movs	r1, #64	; 0x40
 8002b10:	430a      	orrs	r2, r1
 8002b12:	601a      	str	r2, [r3, #0]
#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif /* PREFETCH_ENABLE */

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8002b14:	2003      	movs	r0, #3
 8002b16:	f000 f811 	bl	8002b3c <HAL_InitTick>
 8002b1a:	1e03      	subs	r3, r0, #0
 8002b1c:	d003      	beq.n	8002b26 <HAL_Init+0x2a>
  {
    status = HAL_ERROR;
 8002b1e:	1dfb      	adds	r3, r7, #7
 8002b20:	2201      	movs	r2, #1
 8002b22:	701a      	strb	r2, [r3, #0]
 8002b24:	e001      	b.n	8002b2a <HAL_Init+0x2e>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
 8002b26:	f7fd fe47 	bl	80007b8 <HAL_MspInit>
  }

  /* Return function status */
  return status;
 8002b2a:	1dfb      	adds	r3, r7, #7
 8002b2c:	781b      	ldrb	r3, [r3, #0]
}
 8002b2e:	0018      	movs	r0, r3
 8002b30:	46bd      	mov	sp, r7
 8002b32:	b002      	add	sp, #8
 8002b34:	bd80      	pop	{r7, pc}
 8002b36:	46c0      	nop			; (mov r8, r8)
 8002b38:	40022000 	.word	0x40022000

08002b3c <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8002b3c:	b590      	push	{r4, r7, lr}
 8002b3e:	b083      	sub	sp, #12
 8002b40:	af00      	add	r7, sp, #0
 8002b42:	6078      	str	r0, [r7, #4]
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8002b44:	4b14      	ldr	r3, [pc, #80]	; (8002b98 <HAL_InitTick+0x5c>)
 8002b46:	681c      	ldr	r4, [r3, #0]
 8002b48:	4b14      	ldr	r3, [pc, #80]	; (8002b9c <HAL_InitTick+0x60>)
 8002b4a:	781b      	ldrb	r3, [r3, #0]
 8002b4c:	0019      	movs	r1, r3
 8002b4e:	23fa      	movs	r3, #250	; 0xfa
 8002b50:	0098      	lsls	r0, r3, #2
 8002b52:	f7fd faeb 	bl	800012c <__udivsi3>
 8002b56:	0003      	movs	r3, r0
 8002b58:	0019      	movs	r1, r3
 8002b5a:	0020      	movs	r0, r4
 8002b5c:	f7fd fae6 	bl	800012c <__udivsi3>
 8002b60:	0003      	movs	r3, r0
 8002b62:	0018      	movs	r0, r3
 8002b64:	f000 f92f 	bl	8002dc6 <HAL_SYSTICK_Config>
 8002b68:	1e03      	subs	r3, r0, #0
 8002b6a:	d001      	beq.n	8002b70 <HAL_InitTick+0x34>
  {
    return HAL_ERROR;
 8002b6c:	2301      	movs	r3, #1
 8002b6e:	e00f      	b.n	8002b90 <HAL_InitTick+0x54>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8002b70:	687b      	ldr	r3, [r7, #4]
 8002b72:	2b03      	cmp	r3, #3
 8002b74:	d80b      	bhi.n	8002b8e <HAL_InitTick+0x52>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8002b76:	6879      	ldr	r1, [r7, #4]
 8002b78:	2301      	movs	r3, #1
 8002b7a:	425b      	negs	r3, r3
 8002b7c:	2200      	movs	r2, #0
 8002b7e:	0018      	movs	r0, r3
 8002b80:	f000 f8fc 	bl	8002d7c <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 8002b84:	4b06      	ldr	r3, [pc, #24]	; (8002ba0 <HAL_InitTick+0x64>)
 8002b86:	687a      	ldr	r2, [r7, #4]
 8002b88:	601a      	str	r2, [r3, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
 8002b8a:	2300      	movs	r3, #0
 8002b8c:	e000      	b.n	8002b90 <HAL_InitTick+0x54>
    return HAL_ERROR;
 8002b8e:	2301      	movs	r3, #1
}
 8002b90:	0018      	movs	r0, r3
 8002b92:	46bd      	mov	sp, r7
 8002b94:	b003      	add	sp, #12
 8002b96:	bd90      	pop	{r4, r7, pc}
 8002b98:	20000010 	.word	0x20000010
 8002b9c:	20000018 	.word	0x20000018
 8002ba0:	20000014 	.word	0x20000014

08002ba4 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8002ba4:	b580      	push	{r7, lr}
 8002ba6:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 8002ba8:	4b05      	ldr	r3, [pc, #20]	; (8002bc0 <HAL_IncTick+0x1c>)
 8002baa:	781b      	ldrb	r3, [r3, #0]
 8002bac:	001a      	movs	r2, r3
 8002bae:	4b05      	ldr	r3, [pc, #20]	; (8002bc4 <HAL_IncTick+0x20>)
 8002bb0:	681b      	ldr	r3, [r3, #0]
 8002bb2:	18d2      	adds	r2, r2, r3
 8002bb4:	4b03      	ldr	r3, [pc, #12]	; (8002bc4 <HAL_IncTick+0x20>)
 8002bb6:	601a      	str	r2, [r3, #0]
}
 8002bb8:	46c0      	nop			; (mov r8, r8)
 8002bba:	46bd      	mov	sp, r7
 8002bbc:	bd80      	pop	{r7, pc}
 8002bbe:	46c0      	nop			; (mov r8, r8)
 8002bc0:	20000018 	.word	0x20000018
 8002bc4:	20001c90 	.word	0x20001c90

08002bc8 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 8002bc8:	b580      	push	{r7, lr}
 8002bca:	af00      	add	r7, sp, #0
  return uwTick;
 8002bcc:	4b02      	ldr	r3, [pc, #8]	; (8002bd8 <HAL_GetTick+0x10>)
 8002bce:	681b      	ldr	r3, [r3, #0]
}
 8002bd0:	0018      	movs	r0, r3
 8002bd2:	46bd      	mov	sp, r7
 8002bd4:	bd80      	pop	{r7, pc}
 8002bd6:	46c0      	nop			; (mov r8, r8)
 8002bd8:	20001c90 	.word	0x20001c90

08002bdc <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8002bdc:	b580      	push	{r7, lr}
 8002bde:	b084      	sub	sp, #16
 8002be0:	af00      	add	r7, sp, #0
 8002be2:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 8002be4:	f7ff fff0 	bl	8002bc8 <HAL_GetTick>
 8002be8:	0003      	movs	r3, r0
 8002bea:	60bb      	str	r3, [r7, #8]
  uint32_t wait = Delay;
 8002bec:	687b      	ldr	r3, [r7, #4]
 8002bee:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8002bf0:	68fb      	ldr	r3, [r7, #12]
 8002bf2:	3301      	adds	r3, #1
 8002bf4:	d005      	beq.n	8002c02 <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
 8002bf6:	4b0a      	ldr	r3, [pc, #40]	; (8002c20 <HAL_Delay+0x44>)
 8002bf8:	781b      	ldrb	r3, [r3, #0]
 8002bfa:	001a      	movs	r2, r3
 8002bfc:	68fb      	ldr	r3, [r7, #12]
 8002bfe:	189b      	adds	r3, r3, r2
 8002c00:	60fb      	str	r3, [r7, #12]
  }

  while((HAL_GetTick() - tickstart) < wait)
 8002c02:	46c0      	nop			; (mov r8, r8)
 8002c04:	f7ff ffe0 	bl	8002bc8 <HAL_GetTick>
 8002c08:	0002      	movs	r2, r0
 8002c0a:	68bb      	ldr	r3, [r7, #8]
 8002c0c:	1ad3      	subs	r3, r2, r3
 8002c0e:	68fa      	ldr	r2, [r7, #12]
 8002c10:	429a      	cmp	r2, r3
 8002c12:	d8f7      	bhi.n	8002c04 <HAL_Delay+0x28>
  {
  }
}
 8002c14:	46c0      	nop			; (mov r8, r8)
 8002c16:	46c0      	nop			; (mov r8, r8)
 8002c18:	46bd      	mov	sp, r7
 8002c1a:	b004      	add	sp, #16
 8002c1c:	bd80      	pop	{r7, pc}
 8002c1e:	46c0      	nop			; (mov r8, r8)
 8002c20:	20000018 	.word	0x20000018

08002c24 <__NVIC_EnableIRQ>:
{
 8002c24:	b580      	push	{r7, lr}
 8002c26:	b082      	sub	sp, #8
 8002c28:	af00      	add	r7, sp, #0
 8002c2a:	0002      	movs	r2, r0
 8002c2c:	1dfb      	adds	r3, r7, #7
 8002c2e:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
 8002c30:	1dfb      	adds	r3, r7, #7
 8002c32:	781b      	ldrb	r3, [r3, #0]
 8002c34:	2b7f      	cmp	r3, #127	; 0x7f
 8002c36:	d809      	bhi.n	8002c4c <__NVIC_EnableIRQ+0x28>
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8002c38:	1dfb      	adds	r3, r7, #7
 8002c3a:	781b      	ldrb	r3, [r3, #0]
 8002c3c:	001a      	movs	r2, r3
 8002c3e:	231f      	movs	r3, #31
 8002c40:	401a      	ands	r2, r3
 8002c42:	4b04      	ldr	r3, [pc, #16]	; (8002c54 <__NVIC_EnableIRQ+0x30>)
 8002c44:	2101      	movs	r1, #1
 8002c46:	4091      	lsls	r1, r2
 8002c48:	000a      	movs	r2, r1
 8002c4a:	601a      	str	r2, [r3, #0]
}
 8002c4c:	46c0      	nop			; (mov r8, r8)
 8002c4e:	46bd      	mov	sp, r7
 8002c50:	b002      	add	sp, #8
 8002c52:	bd80      	pop	{r7, pc}
 8002c54:	e000e100 	.word	0xe000e100

08002c58 <__NVIC_SetPriority>:
{
 8002c58:	b590      	push	{r4, r7, lr}
 8002c5a:	b083      	sub	sp, #12
 8002c5c:	af00      	add	r7, sp, #0
 8002c5e:	0002      	movs	r2, r0
 8002c60:	6039      	str	r1, [r7, #0]
 8002c62:	1dfb      	adds	r3, r7, #7
 8002c64:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
 8002c66:	1dfb      	adds	r3, r7, #7
 8002c68:	781b      	ldrb	r3, [r3, #0]
 8002c6a:	2b7f      	cmp	r3, #127	; 0x7f
 8002c6c:	d828      	bhi.n	8002cc0 <__NVIC_SetPriority+0x68>
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8002c6e:	4a2f      	ldr	r2, [pc, #188]	; (8002d2c <__NVIC_SetPriority+0xd4>)
 8002c70:	1dfb      	adds	r3, r7, #7
 8002c72:	781b      	ldrb	r3, [r3, #0]
 8002c74:	b25b      	sxtb	r3, r3
 8002c76:	089b      	lsrs	r3, r3, #2
 8002c78:	33c0      	adds	r3, #192	; 0xc0
 8002c7a:	009b      	lsls	r3, r3, #2
 8002c7c:	589b      	ldr	r3, [r3, r2]
 8002c7e:	1dfa      	adds	r2, r7, #7
 8002c80:	7812      	ldrb	r2, [r2, #0]
 8002c82:	0011      	movs	r1, r2
 8002c84:	2203      	movs	r2, #3
 8002c86:	400a      	ands	r2, r1
 8002c88:	00d2      	lsls	r2, r2, #3
 8002c8a:	21ff      	movs	r1, #255	; 0xff
 8002c8c:	4091      	lsls	r1, r2
 8002c8e:	000a      	movs	r2, r1
 8002c90:	43d2      	mvns	r2, r2
 8002c92:	401a      	ands	r2, r3
 8002c94:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 8002c96:	683b      	ldr	r3, [r7, #0]
 8002c98:	019b      	lsls	r3, r3, #6
 8002c9a:	22ff      	movs	r2, #255	; 0xff
 8002c9c:	401a      	ands	r2, r3
 8002c9e:	1dfb      	adds	r3, r7, #7
 8002ca0:	781b      	ldrb	r3, [r3, #0]
 8002ca2:	0018      	movs	r0, r3
 8002ca4:	2303      	movs	r3, #3
 8002ca6:	4003      	ands	r3, r0
 8002ca8:	00db      	lsls	r3, r3, #3
 8002caa:	409a      	lsls	r2, r3
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8002cac:	481f      	ldr	r0, [pc, #124]	; (8002d2c <__NVIC_SetPriority+0xd4>)
 8002cae:	1dfb      	adds	r3, r7, #7
 8002cb0:	781b      	ldrb	r3, [r3, #0]
 8002cb2:	b25b      	sxtb	r3, r3
 8002cb4:	089b      	lsrs	r3, r3, #2
 8002cb6:	430a      	orrs	r2, r1
 8002cb8:	33c0      	adds	r3, #192	; 0xc0
 8002cba:	009b      	lsls	r3, r3, #2
 8002cbc:	501a      	str	r2, [r3, r0]
}
 8002cbe:	e031      	b.n	8002d24 <__NVIC_SetPriority+0xcc>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8002cc0:	4a1b      	ldr	r2, [pc, #108]	; (8002d30 <__NVIC_SetPriority+0xd8>)
 8002cc2:	1dfb      	adds	r3, r7, #7
 8002cc4:	781b      	ldrb	r3, [r3, #0]
 8002cc6:	0019      	movs	r1, r3
 8002cc8:	230f      	movs	r3, #15
 8002cca:	400b      	ands	r3, r1
 8002ccc:	3b08      	subs	r3, #8
 8002cce:	089b      	lsrs	r3, r3, #2
 8002cd0:	3306      	adds	r3, #6
 8002cd2:	009b      	lsls	r3, r3, #2
 8002cd4:	18d3      	adds	r3, r2, r3
 8002cd6:	3304      	adds	r3, #4
 8002cd8:	681b      	ldr	r3, [r3, #0]
 8002cda:	1dfa      	adds	r2, r7, #7
 8002cdc:	7812      	ldrb	r2, [r2, #0]
 8002cde:	0011      	movs	r1, r2
 8002ce0:	2203      	movs	r2, #3
 8002ce2:	400a      	ands	r2, r1
 8002ce4:	00d2      	lsls	r2, r2, #3
 8002ce6:	21ff      	movs	r1, #255	; 0xff
 8002ce8:	4091      	lsls	r1, r2
 8002cea:	000a      	movs	r2, r1
 8002cec:	43d2      	mvns	r2, r2
 8002cee:	401a      	ands	r2, r3
 8002cf0:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 8002cf2:	683b      	ldr	r3, [r7, #0]
 8002cf4:	019b      	lsls	r3, r3, #6
 8002cf6:	22ff      	movs	r2, #255	; 0xff
 8002cf8:	401a      	ands	r2, r3
 8002cfa:	1dfb      	adds	r3, r7, #7
 8002cfc:	781b      	ldrb	r3, [r3, #0]
 8002cfe:	0018      	movs	r0, r3
 8002d00:	2303      	movs	r3, #3
 8002d02:	4003      	ands	r3, r0
 8002d04:	00db      	lsls	r3, r3, #3
 8002d06:	409a      	lsls	r2, r3
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8002d08:	4809      	ldr	r0, [pc, #36]	; (8002d30 <__NVIC_SetPriority+0xd8>)
 8002d0a:	1dfb      	adds	r3, r7, #7
 8002d0c:	781b      	ldrb	r3, [r3, #0]
 8002d0e:	001c      	movs	r4, r3
 8002d10:	230f      	movs	r3, #15
 8002d12:	4023      	ands	r3, r4
 8002d14:	3b08      	subs	r3, #8
 8002d16:	089b      	lsrs	r3, r3, #2
 8002d18:	430a      	orrs	r2, r1
 8002d1a:	3306      	adds	r3, #6
 8002d1c:	009b      	lsls	r3, r3, #2
 8002d1e:	18c3      	adds	r3, r0, r3
 8002d20:	3304      	adds	r3, #4
 8002d22:	601a      	str	r2, [r3, #0]
}
 8002d24:	46c0      	nop			; (mov r8, r8)
 8002d26:	46bd      	mov	sp, r7
 8002d28:	b003      	add	sp, #12
 8002d2a:	bd90      	pop	{r4, r7, pc}
 8002d2c:	e000e100 	.word	0xe000e100
 8002d30:	e000ed00 	.word	0xe000ed00

08002d34 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 8002d34:	b580      	push	{r7, lr}
 8002d36:	b082      	sub	sp, #8
 8002d38:	af00      	add	r7, sp, #0
 8002d3a:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8002d3c:	687b      	ldr	r3, [r7, #4]
 8002d3e:	1e5a      	subs	r2, r3, #1
 8002d40:	2380      	movs	r3, #128	; 0x80
 8002d42:	045b      	lsls	r3, r3, #17
 8002d44:	429a      	cmp	r2, r3
 8002d46:	d301      	bcc.n	8002d4c <SysTick_Config+0x18>
  {
    return (1UL);                                                   /* Reload value impossible */
 8002d48:	2301      	movs	r3, #1
 8002d4a:	e010      	b.n	8002d6e <SysTick_Config+0x3a>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8002d4c:	4b0a      	ldr	r3, [pc, #40]	; (8002d78 <SysTick_Config+0x44>)
 8002d4e:	687a      	ldr	r2, [r7, #4]
 8002d50:	3a01      	subs	r2, #1
 8002d52:	605a      	str	r2, [r3, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 8002d54:	2301      	movs	r3, #1
 8002d56:	425b      	negs	r3, r3
 8002d58:	2103      	movs	r1, #3
 8002d5a:	0018      	movs	r0, r3
 8002d5c:	f7ff ff7c 	bl	8002c58 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8002d60:	4b05      	ldr	r3, [pc, #20]	; (8002d78 <SysTick_Config+0x44>)
 8002d62:	2200      	movs	r2, #0
 8002d64:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8002d66:	4b04      	ldr	r3, [pc, #16]	; (8002d78 <SysTick_Config+0x44>)
 8002d68:	2207      	movs	r2, #7
 8002d6a:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8002d6c:	2300      	movs	r3, #0
}
 8002d6e:	0018      	movs	r0, r3
 8002d70:	46bd      	mov	sp, r7
 8002d72:	b002      	add	sp, #8
 8002d74:	bd80      	pop	{r7, pc}
 8002d76:	46c0      	nop			; (mov r8, r8)
 8002d78:	e000e010 	.word	0xe000e010

08002d7c <HAL_NVIC_SetPriority>:
  *         with stm32l0xx devices, this parameter is a dummy value and it is ignored, because 
  *         no subpriority supported in Cortex M0+ based products.   
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8002d7c:	b580      	push	{r7, lr}
 8002d7e:	b084      	sub	sp, #16
 8002d80:	af00      	add	r7, sp, #0
 8002d82:	60b9      	str	r1, [r7, #8]
 8002d84:	607a      	str	r2, [r7, #4]
 8002d86:	210f      	movs	r1, #15
 8002d88:	187b      	adds	r3, r7, r1
 8002d8a:	1c02      	adds	r2, r0, #0
 8002d8c:	701a      	strb	r2, [r3, #0]
    /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn,PreemptPriority);
 8002d8e:	68ba      	ldr	r2, [r7, #8]
 8002d90:	187b      	adds	r3, r7, r1
 8002d92:	781b      	ldrb	r3, [r3, #0]
 8002d94:	b25b      	sxtb	r3, r3
 8002d96:	0011      	movs	r1, r2
 8002d98:	0018      	movs	r0, r3
 8002d9a:	f7ff ff5d 	bl	8002c58 <__NVIC_SetPriority>
}
 8002d9e:	46c0      	nop			; (mov r8, r8)
 8002da0:	46bd      	mov	sp, r7
 8002da2:	b004      	add	sp, #16
 8002da4:	bd80      	pop	{r7, pc}

08002da6 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of  IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to stm32l0xx.h file)  
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8002da6:	b580      	push	{r7, lr}
 8002da8:	b082      	sub	sp, #8
 8002daa:	af00      	add	r7, sp, #0
 8002dac:	0002      	movs	r2, r0
 8002dae:	1dfb      	adds	r3, r7, #7
 8002db0:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 8002db2:	1dfb      	adds	r3, r7, #7
 8002db4:	781b      	ldrb	r3, [r3, #0]
 8002db6:	b25b      	sxtb	r3, r3
 8002db8:	0018      	movs	r0, r3
 8002dba:	f7ff ff33 	bl	8002c24 <__NVIC_EnableIRQ>
}
 8002dbe:	46c0      	nop			; (mov r8, r8)
 8002dc0:	46bd      	mov	sp, r7
 8002dc2:	b002      	add	sp, #8
 8002dc4:	bd80      	pop	{r7, pc}

08002dc6 <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 8002dc6:	b580      	push	{r7, lr}
 8002dc8:	b082      	sub	sp, #8
 8002dca:	af00      	add	r7, sp, #0
 8002dcc:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 8002dce:	687b      	ldr	r3, [r7, #4]
 8002dd0:	0018      	movs	r0, r3
 8002dd2:	f7ff ffaf 	bl	8002d34 <SysTick_Config>
 8002dd6:	0003      	movs	r3, r0
}
 8002dd8:	0018      	movs	r0, r3
 8002dda:	46bd      	mov	sp, r7
 8002ddc:	b002      	add	sp, #8
 8002dde:	bd80      	pop	{r7, pc}

08002de0 <HAL_DMA_Abort>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
    * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
{
 8002de0:	b580      	push	{r7, lr}
 8002de2:	b084      	sub	sp, #16
 8002de4:	af00      	add	r7, sp, #0
 8002de6:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8002de8:	230f      	movs	r3, #15
 8002dea:	18fb      	adds	r3, r7, r3
 8002dec:	2200      	movs	r2, #0
 8002dee:	701a      	strb	r2, [r3, #0]

  /* Check the DMA peripheral state */
  if(hdma->State != HAL_DMA_STATE_BUSY)
 8002df0:	687b      	ldr	r3, [r7, #4]
 8002df2:	2225      	movs	r2, #37	; 0x25
 8002df4:	5c9b      	ldrb	r3, [r3, r2]
 8002df6:	b2db      	uxtb	r3, r3
 8002df8:	2b02      	cmp	r3, #2
 8002dfa:	d008      	beq.n	8002e0e <HAL_DMA_Abort+0x2e>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8002dfc:	687b      	ldr	r3, [r7, #4]
 8002dfe:	2204      	movs	r2, #4
 8002e00:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 8002e02:	687b      	ldr	r3, [r7, #4]
 8002e04:	2224      	movs	r2, #36	; 0x24
 8002e06:	2100      	movs	r1, #0
 8002e08:	5499      	strb	r1, [r3, r2]

    return HAL_ERROR;
 8002e0a:	2301      	movs	r3, #1
 8002e0c:	e024      	b.n	8002e58 <HAL_DMA_Abort+0x78>
  }
  else
  {
    /* Disable DMA IT */
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8002e0e:	687b      	ldr	r3, [r7, #4]
 8002e10:	681b      	ldr	r3, [r3, #0]
 8002e12:	681a      	ldr	r2, [r3, #0]
 8002e14:	687b      	ldr	r3, [r7, #4]
 8002e16:	681b      	ldr	r3, [r3, #0]
 8002e18:	210e      	movs	r1, #14
 8002e1a:	438a      	bics	r2, r1
 8002e1c:	601a      	str	r2, [r3, #0]

    /* Disable the channel */
    __HAL_DMA_DISABLE(hdma);
 8002e1e:	687b      	ldr	r3, [r7, #4]
 8002e20:	681b      	ldr	r3, [r3, #0]
 8002e22:	681a      	ldr	r2, [r3, #0]
 8002e24:	687b      	ldr	r3, [r7, #4]
 8002e26:	681b      	ldr	r3, [r3, #0]
 8002e28:	2101      	movs	r1, #1
 8002e2a:	438a      	bics	r2, r1
 8002e2c:	601a      	str	r2, [r3, #0]

    /* Clear all flags */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
 8002e2e:	687b      	ldr	r3, [r7, #4]
 8002e30:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002e32:	221c      	movs	r2, #28
 8002e34:	401a      	ands	r2, r3
 8002e36:	687b      	ldr	r3, [r7, #4]
 8002e38:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002e3a:	2101      	movs	r1, #1
 8002e3c:	4091      	lsls	r1, r2
 8002e3e:	000a      	movs	r2, r1
 8002e40:	605a      	str	r2, [r3, #4]

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
 8002e42:	687b      	ldr	r3, [r7, #4]
 8002e44:	2225      	movs	r2, #37	; 0x25
 8002e46:	2101      	movs	r1, #1
 8002e48:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 8002e4a:	687b      	ldr	r3, [r7, #4]
 8002e4c:	2224      	movs	r2, #36	; 0x24
 8002e4e:	2100      	movs	r1, #0
 8002e50:	5499      	strb	r1, [r3, r2]

    return status;
 8002e52:	230f      	movs	r3, #15
 8002e54:	18fb      	adds	r3, r7, r3
 8002e56:	781b      	ldrb	r3, [r3, #0]
  }
}
 8002e58:	0018      	movs	r0, r3
 8002e5a:	46bd      	mov	sp, r7
 8002e5c:	b004      	add	sp, #16
 8002e5e:	bd80      	pop	{r7, pc}

08002e60 <HAL_DMA_Abort_IT>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
 8002e60:	b580      	push	{r7, lr}
 8002e62:	b084      	sub	sp, #16
 8002e64:	af00      	add	r7, sp, #0
 8002e66:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8002e68:	210f      	movs	r1, #15
 8002e6a:	187b      	adds	r3, r7, r1
 8002e6c:	2200      	movs	r2, #0
 8002e6e:	701a      	strb	r2, [r3, #0]

  if(HAL_DMA_STATE_BUSY != hdma->State)
 8002e70:	687b      	ldr	r3, [r7, #4]
 8002e72:	2225      	movs	r2, #37	; 0x25
 8002e74:	5c9b      	ldrb	r3, [r3, r2]
 8002e76:	b2db      	uxtb	r3, r3
 8002e78:	2b02      	cmp	r3, #2
 8002e7a:	d006      	beq.n	8002e8a <HAL_DMA_Abort_IT+0x2a>
  {
    /* no transfer ongoing */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8002e7c:	687b      	ldr	r3, [r7, #4]
 8002e7e:	2204      	movs	r2, #4
 8002e80:	63da      	str	r2, [r3, #60]	; 0x3c

    status = HAL_ERROR;
 8002e82:	187b      	adds	r3, r7, r1
 8002e84:	2201      	movs	r2, #1
 8002e86:	701a      	strb	r2, [r3, #0]
 8002e88:	e02a      	b.n	8002ee0 <HAL_DMA_Abort_IT+0x80>
  }
  else
  {
    /* Disable DMA IT */
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8002e8a:	687b      	ldr	r3, [r7, #4]
 8002e8c:	681b      	ldr	r3, [r3, #0]
 8002e8e:	681a      	ldr	r2, [r3, #0]
 8002e90:	687b      	ldr	r3, [r7, #4]
 8002e92:	681b      	ldr	r3, [r3, #0]
 8002e94:	210e      	movs	r1, #14
 8002e96:	438a      	bics	r2, r1
 8002e98:	601a      	str	r2, [r3, #0]

    /* Disable the channel */
    __HAL_DMA_DISABLE(hdma);
 8002e9a:	687b      	ldr	r3, [r7, #4]
 8002e9c:	681b      	ldr	r3, [r3, #0]
 8002e9e:	681a      	ldr	r2, [r3, #0]
 8002ea0:	687b      	ldr	r3, [r7, #4]
 8002ea2:	681b      	ldr	r3, [r3, #0]
 8002ea4:	2101      	movs	r1, #1
 8002ea6:	438a      	bics	r2, r1
 8002ea8:	601a      	str	r2, [r3, #0]

    /* Clear all flags */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
 8002eaa:	687b      	ldr	r3, [r7, #4]
 8002eac:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002eae:	221c      	movs	r2, #28
 8002eb0:	401a      	ands	r2, r3
 8002eb2:	687b      	ldr	r3, [r7, #4]
 8002eb4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002eb6:	2101      	movs	r1, #1
 8002eb8:	4091      	lsls	r1, r2
 8002eba:	000a      	movs	r2, r1
 8002ebc:	605a      	str	r2, [r3, #4]

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
 8002ebe:	687b      	ldr	r3, [r7, #4]
 8002ec0:	2225      	movs	r2, #37	; 0x25
 8002ec2:	2101      	movs	r1, #1
 8002ec4:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 8002ec6:	687b      	ldr	r3, [r7, #4]
 8002ec8:	2224      	movs	r2, #36	; 0x24
 8002eca:	2100      	movs	r1, #0
 8002ecc:	5499      	strb	r1, [r3, r2]

    /* Call User Abort callback */
    if(hdma->XferAbortCallback != NULL)
 8002ece:	687b      	ldr	r3, [r7, #4]
 8002ed0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002ed2:	2b00      	cmp	r3, #0
 8002ed4:	d004      	beq.n	8002ee0 <HAL_DMA_Abort_IT+0x80>
    {
      hdma->XferAbortCallback(hdma);
 8002ed6:	687b      	ldr	r3, [r7, #4]
 8002ed8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002eda:	687a      	ldr	r2, [r7, #4]
 8002edc:	0010      	movs	r0, r2
 8002ede:	4798      	blx	r3
    }
  }
  return status;
 8002ee0:	230f      	movs	r3, #15
 8002ee2:	18fb      	adds	r3, r7, r3
 8002ee4:	781b      	ldrb	r3, [r3, #0]
}
 8002ee6:	0018      	movs	r0, r3
 8002ee8:	46bd      	mov	sp, r7
 8002eea:	b004      	add	sp, #16
 8002eec:	bd80      	pop	{r7, pc}
	...

08002ef0 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *                    the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8002ef0:	b580      	push	{r7, lr}
 8002ef2:	b086      	sub	sp, #24
 8002ef4:	af00      	add	r7, sp, #0
 8002ef6:	6078      	str	r0, [r7, #4]
 8002ef8:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
 8002efa:	2300      	movs	r3, #0
 8002efc:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00U;
 8002efe:	2300      	movs	r3, #0
 8002f00:	60fb      	str	r3, [r7, #12]
  uint32_t temp = 0x00U;
 8002f02:	2300      	movs	r3, #0
 8002f04:	613b      	str	r3, [r7, #16]
  /* Check the parameters */
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx, (GPIO_Init->Pin)));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0)
 8002f06:	e155      	b.n	80031b4 <HAL_GPIO_Init+0x2c4>
  {
    /* Get the IO position */
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 8002f08:	683b      	ldr	r3, [r7, #0]
 8002f0a:	681b      	ldr	r3, [r3, #0]
 8002f0c:	2101      	movs	r1, #1
 8002f0e:	697a      	ldr	r2, [r7, #20]
 8002f10:	4091      	lsls	r1, r2
 8002f12:	000a      	movs	r2, r1
 8002f14:	4013      	ands	r3, r2
 8002f16:	60fb      	str	r3, [r7, #12]

    if (iocurrent)
 8002f18:	68fb      	ldr	r3, [r7, #12]
 8002f1a:	2b00      	cmp	r3, #0
 8002f1c:	d100      	bne.n	8002f20 <HAL_GPIO_Init+0x30>
 8002f1e:	e146      	b.n	80031ae <HAL_GPIO_Init+0x2be>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) ||
 8002f20:	683b      	ldr	r3, [r7, #0]
 8002f22:	685b      	ldr	r3, [r3, #4]
 8002f24:	2203      	movs	r2, #3
 8002f26:	4013      	ands	r3, r2
 8002f28:	2b01      	cmp	r3, #1
 8002f2a:	d005      	beq.n	8002f38 <HAL_GPIO_Init+0x48>
          ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 8002f2c:	683b      	ldr	r3, [r7, #0]
 8002f2e:	685b      	ldr	r3, [r3, #4]
 8002f30:	2203      	movs	r2, #3
 8002f32:	4013      	ands	r3, r2
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) ||
 8002f34:	2b02      	cmp	r3, #2
 8002f36:	d130      	bne.n	8002f9a <HAL_GPIO_Init+0xaa>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 8002f38:	687b      	ldr	r3, [r7, #4]
 8002f3a:	689b      	ldr	r3, [r3, #8]
 8002f3c:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDER_OSPEED0 << (position * 2U));
 8002f3e:	697b      	ldr	r3, [r7, #20]
 8002f40:	005b      	lsls	r3, r3, #1
 8002f42:	2203      	movs	r2, #3
 8002f44:	409a      	lsls	r2, r3
 8002f46:	0013      	movs	r3, r2
 8002f48:	43da      	mvns	r2, r3
 8002f4a:	693b      	ldr	r3, [r7, #16]
 8002f4c:	4013      	ands	r3, r2
 8002f4e:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * 2U));
 8002f50:	683b      	ldr	r3, [r7, #0]
 8002f52:	68da      	ldr	r2, [r3, #12]
 8002f54:	697b      	ldr	r3, [r7, #20]
 8002f56:	005b      	lsls	r3, r3, #1
 8002f58:	409a      	lsls	r2, r3
 8002f5a:	0013      	movs	r3, r2
 8002f5c:	693a      	ldr	r2, [r7, #16]
 8002f5e:	4313      	orrs	r3, r2
 8002f60:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
 8002f62:	687b      	ldr	r3, [r7, #4]
 8002f64:	693a      	ldr	r2, [r7, #16]
 8002f66:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8002f68:	687b      	ldr	r3, [r7, #4]
 8002f6a:	685b      	ldr	r3, [r3, #4]
 8002f6c:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8002f6e:	2201      	movs	r2, #1
 8002f70:	697b      	ldr	r3, [r7, #20]
 8002f72:	409a      	lsls	r2, r3
 8002f74:	0013      	movs	r3, r2
 8002f76:	43da      	mvns	r2, r3
 8002f78:	693b      	ldr	r3, [r7, #16]
 8002f7a:	4013      	ands	r3, r2
 8002f7c:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 8002f7e:	683b      	ldr	r3, [r7, #0]
 8002f80:	685b      	ldr	r3, [r3, #4]
 8002f82:	091b      	lsrs	r3, r3, #4
 8002f84:	2201      	movs	r2, #1
 8002f86:	401a      	ands	r2, r3
 8002f88:	697b      	ldr	r3, [r7, #20]
 8002f8a:	409a      	lsls	r2, r3
 8002f8c:	0013      	movs	r3, r2
 8002f8e:	693a      	ldr	r2, [r7, #16]
 8002f90:	4313      	orrs	r3, r2
 8002f92:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
 8002f94:	687b      	ldr	r3, [r7, #4]
 8002f96:	693a      	ldr	r2, [r7, #16]
 8002f98:	605a      	str	r2, [r3, #4]
      }

      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 8002f9a:	683b      	ldr	r3, [r7, #0]
 8002f9c:	685b      	ldr	r3, [r3, #4]
 8002f9e:	2203      	movs	r2, #3
 8002fa0:	4013      	ands	r3, r2
 8002fa2:	2b03      	cmp	r3, #3
 8002fa4:	d017      	beq.n	8002fd6 <HAL_GPIO_Init+0xe6>
      {
        /* Check the Pull parameter */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
 8002fa6:	687b      	ldr	r3, [r7, #4]
 8002fa8:	68db      	ldr	r3, [r3, #12]
 8002faa:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8002fac:	697b      	ldr	r3, [r7, #20]
 8002fae:	005b      	lsls	r3, r3, #1
 8002fb0:	2203      	movs	r2, #3
 8002fb2:	409a      	lsls	r2, r3
 8002fb4:	0013      	movs	r3, r2
 8002fb6:	43da      	mvns	r2, r3
 8002fb8:	693b      	ldr	r3, [r7, #16]
 8002fba:	4013      	ands	r3, r2
 8002fbc:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 8002fbe:	683b      	ldr	r3, [r7, #0]
 8002fc0:	689a      	ldr	r2, [r3, #8]
 8002fc2:	697b      	ldr	r3, [r7, #20]
 8002fc4:	005b      	lsls	r3, r3, #1
 8002fc6:	409a      	lsls	r2, r3
 8002fc8:	0013      	movs	r3, r2
 8002fca:	693a      	ldr	r2, [r7, #16]
 8002fcc:	4313      	orrs	r3, r2
 8002fce:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
 8002fd0:	687b      	ldr	r3, [r7, #4]
 8002fd2:	693a      	ldr	r2, [r7, #16]
 8002fd4:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8002fd6:	683b      	ldr	r3, [r7, #0]
 8002fd8:	685b      	ldr	r3, [r3, #4]
 8002fda:	2203      	movs	r2, #3
 8002fdc:	4013      	ands	r3, r2
 8002fde:	2b02      	cmp	r3, #2
 8002fe0:	d123      	bne.n	800302a <HAL_GPIO_Init+0x13a>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 8002fe2:	697b      	ldr	r3, [r7, #20]
 8002fe4:	08da      	lsrs	r2, r3, #3
 8002fe6:	687b      	ldr	r3, [r7, #4]
 8002fe8:	3208      	adds	r2, #8
 8002fea:	0092      	lsls	r2, r2, #2
 8002fec:	58d3      	ldr	r3, [r2, r3]
 8002fee:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFUL << ((uint32_t)(position & 0x07UL) * 4U));
 8002ff0:	697b      	ldr	r3, [r7, #20]
 8002ff2:	2207      	movs	r2, #7
 8002ff4:	4013      	ands	r3, r2
 8002ff6:	009b      	lsls	r3, r3, #2
 8002ff8:	220f      	movs	r2, #15
 8002ffa:	409a      	lsls	r2, r3
 8002ffc:	0013      	movs	r3, r2
 8002ffe:	43da      	mvns	r2, r3
 8003000:	693b      	ldr	r3, [r7, #16]
 8003002:	4013      	ands	r3, r2
 8003004:	613b      	str	r3, [r7, #16]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U));
 8003006:	683b      	ldr	r3, [r7, #0]
 8003008:	691a      	ldr	r2, [r3, #16]
 800300a:	697b      	ldr	r3, [r7, #20]
 800300c:	2107      	movs	r1, #7
 800300e:	400b      	ands	r3, r1
 8003010:	009b      	lsls	r3, r3, #2
 8003012:	409a      	lsls	r2, r3
 8003014:	0013      	movs	r3, r2
 8003016:	693a      	ldr	r2, [r7, #16]
 8003018:	4313      	orrs	r3, r2
 800301a:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3U] = temp;
 800301c:	697b      	ldr	r3, [r7, #20]
 800301e:	08da      	lsrs	r2, r3, #3
 8003020:	687b      	ldr	r3, [r7, #4]
 8003022:	3208      	adds	r2, #8
 8003024:	0092      	lsls	r2, r2, #2
 8003026:	6939      	ldr	r1, [r7, #16]
 8003028:	50d1      	str	r1, [r2, r3]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 800302a:	687b      	ldr	r3, [r7, #4]
 800302c:	681b      	ldr	r3, [r3, #0]
 800302e:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 8003030:	697b      	ldr	r3, [r7, #20]
 8003032:	005b      	lsls	r3, r3, #1
 8003034:	2203      	movs	r2, #3
 8003036:	409a      	lsls	r2, r3
 8003038:	0013      	movs	r3, r2
 800303a:	43da      	mvns	r2, r3
 800303c:	693b      	ldr	r3, [r7, #16]
 800303e:	4013      	ands	r3, r2
 8003040:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8003042:	683b      	ldr	r3, [r7, #0]
 8003044:	685b      	ldr	r3, [r3, #4]
 8003046:	2203      	movs	r2, #3
 8003048:	401a      	ands	r2, r3
 800304a:	697b      	ldr	r3, [r7, #20]
 800304c:	005b      	lsls	r3, r3, #1
 800304e:	409a      	lsls	r2, r3
 8003050:	0013      	movs	r3, r2
 8003052:	693a      	ldr	r2, [r7, #16]
 8003054:	4313      	orrs	r3, r2
 8003056:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
 8003058:	687b      	ldr	r3, [r7, #4]
 800305a:	693a      	ldr	r2, [r7, #16]
 800305c:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 800305e:	683b      	ldr	r3, [r7, #0]
 8003060:	685a      	ldr	r2, [r3, #4]
 8003062:	23c0      	movs	r3, #192	; 0xc0
 8003064:	029b      	lsls	r3, r3, #10
 8003066:	4013      	ands	r3, r2
 8003068:	d100      	bne.n	800306c <HAL_GPIO_Init+0x17c>
 800306a:	e0a0      	b.n	80031ae <HAL_GPIO_Init+0x2be>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800306c:	4b57      	ldr	r3, [pc, #348]	; (80031cc <HAL_GPIO_Init+0x2dc>)
 800306e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8003070:	4b56      	ldr	r3, [pc, #344]	; (80031cc <HAL_GPIO_Init+0x2dc>)
 8003072:	2101      	movs	r1, #1
 8003074:	430a      	orrs	r2, r1
 8003076:	635a      	str	r2, [r3, #52]	; 0x34

        temp = SYSCFG->EXTICR[position >> 2U];
 8003078:	4a55      	ldr	r2, [pc, #340]	; (80031d0 <HAL_GPIO_Init+0x2e0>)
 800307a:	697b      	ldr	r3, [r7, #20]
 800307c:	089b      	lsrs	r3, r3, #2
 800307e:	3302      	adds	r3, #2
 8003080:	009b      	lsls	r3, r3, #2
 8003082:	589b      	ldr	r3, [r3, r2]
 8003084:	613b      	str	r3, [r7, #16]
        CLEAR_BIT(temp, (0x0FUL) << (4U * (position & 0x03U)));
 8003086:	697b      	ldr	r3, [r7, #20]
 8003088:	2203      	movs	r2, #3
 800308a:	4013      	ands	r3, r2
 800308c:	009b      	lsls	r3, r3, #2
 800308e:	220f      	movs	r2, #15
 8003090:	409a      	lsls	r2, r3
 8003092:	0013      	movs	r3, r2
 8003094:	43da      	mvns	r2, r3
 8003096:	693b      	ldr	r3, [r7, #16]
 8003098:	4013      	ands	r3, r2
 800309a:	613b      	str	r3, [r7, #16]
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03U)));
 800309c:	687a      	ldr	r2, [r7, #4]
 800309e:	23a0      	movs	r3, #160	; 0xa0
 80030a0:	05db      	lsls	r3, r3, #23
 80030a2:	429a      	cmp	r2, r3
 80030a4:	d01f      	beq.n	80030e6 <HAL_GPIO_Init+0x1f6>
 80030a6:	687b      	ldr	r3, [r7, #4]
 80030a8:	4a4a      	ldr	r2, [pc, #296]	; (80031d4 <HAL_GPIO_Init+0x2e4>)
 80030aa:	4293      	cmp	r3, r2
 80030ac:	d019      	beq.n	80030e2 <HAL_GPIO_Init+0x1f2>
 80030ae:	687b      	ldr	r3, [r7, #4]
 80030b0:	4a49      	ldr	r2, [pc, #292]	; (80031d8 <HAL_GPIO_Init+0x2e8>)
 80030b2:	4293      	cmp	r3, r2
 80030b4:	d013      	beq.n	80030de <HAL_GPIO_Init+0x1ee>
 80030b6:	687b      	ldr	r3, [r7, #4]
 80030b8:	4a48      	ldr	r2, [pc, #288]	; (80031dc <HAL_GPIO_Init+0x2ec>)
 80030ba:	4293      	cmp	r3, r2
 80030bc:	d00d      	beq.n	80030da <HAL_GPIO_Init+0x1ea>
 80030be:	687b      	ldr	r3, [r7, #4]
 80030c0:	4a47      	ldr	r2, [pc, #284]	; (80031e0 <HAL_GPIO_Init+0x2f0>)
 80030c2:	4293      	cmp	r3, r2
 80030c4:	d007      	beq.n	80030d6 <HAL_GPIO_Init+0x1e6>
 80030c6:	687b      	ldr	r3, [r7, #4]
 80030c8:	4a46      	ldr	r2, [pc, #280]	; (80031e4 <HAL_GPIO_Init+0x2f4>)
 80030ca:	4293      	cmp	r3, r2
 80030cc:	d101      	bne.n	80030d2 <HAL_GPIO_Init+0x1e2>
 80030ce:	2305      	movs	r3, #5
 80030d0:	e00a      	b.n	80030e8 <HAL_GPIO_Init+0x1f8>
 80030d2:	2306      	movs	r3, #6
 80030d4:	e008      	b.n	80030e8 <HAL_GPIO_Init+0x1f8>
 80030d6:	2304      	movs	r3, #4
 80030d8:	e006      	b.n	80030e8 <HAL_GPIO_Init+0x1f8>
 80030da:	2303      	movs	r3, #3
 80030dc:	e004      	b.n	80030e8 <HAL_GPIO_Init+0x1f8>
 80030de:	2302      	movs	r3, #2
 80030e0:	e002      	b.n	80030e8 <HAL_GPIO_Init+0x1f8>
 80030e2:	2301      	movs	r3, #1
 80030e4:	e000      	b.n	80030e8 <HAL_GPIO_Init+0x1f8>
 80030e6:	2300      	movs	r3, #0
 80030e8:	697a      	ldr	r2, [r7, #20]
 80030ea:	2103      	movs	r1, #3
 80030ec:	400a      	ands	r2, r1
 80030ee:	0092      	lsls	r2, r2, #2
 80030f0:	4093      	lsls	r3, r2
 80030f2:	693a      	ldr	r2, [r7, #16]
 80030f4:	4313      	orrs	r3, r2
 80030f6:	613b      	str	r3, [r7, #16]
        SYSCFG->EXTICR[position >> 2U] = temp;
 80030f8:	4935      	ldr	r1, [pc, #212]	; (80031d0 <HAL_GPIO_Init+0x2e0>)
 80030fa:	697b      	ldr	r3, [r7, #20]
 80030fc:	089b      	lsrs	r3, r3, #2
 80030fe:	3302      	adds	r3, #2
 8003100:	009b      	lsls	r3, r3, #2
 8003102:	693a      	ldr	r2, [r7, #16]
 8003104:	505a      	str	r2, [r3, r1]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8003106:	4b38      	ldr	r3, [pc, #224]	; (80031e8 <HAL_GPIO_Init+0x2f8>)
 8003108:	681b      	ldr	r3, [r3, #0]
 800310a:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 800310c:	68fb      	ldr	r3, [r7, #12]
 800310e:	43da      	mvns	r2, r3
 8003110:	693b      	ldr	r3, [r7, #16]
 8003112:	4013      	ands	r3, r2
 8003114:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 8003116:	683b      	ldr	r3, [r7, #0]
 8003118:	685a      	ldr	r2, [r3, #4]
 800311a:	2380      	movs	r3, #128	; 0x80
 800311c:	025b      	lsls	r3, r3, #9
 800311e:	4013      	ands	r3, r2
 8003120:	d003      	beq.n	800312a <HAL_GPIO_Init+0x23a>
        {
          temp |= iocurrent;
 8003122:	693a      	ldr	r2, [r7, #16]
 8003124:	68fb      	ldr	r3, [r7, #12]
 8003126:	4313      	orrs	r3, r2
 8003128:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR = temp;
 800312a:	4b2f      	ldr	r3, [pc, #188]	; (80031e8 <HAL_GPIO_Init+0x2f8>)
 800312c:	693a      	ldr	r2, [r7, #16]
 800312e:	601a      	str	r2, [r3, #0]

        temp = EXTI->EMR;
 8003130:	4b2d      	ldr	r3, [pc, #180]	; (80031e8 <HAL_GPIO_Init+0x2f8>)
 8003132:	685b      	ldr	r3, [r3, #4]
 8003134:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 8003136:	68fb      	ldr	r3, [r7, #12]
 8003138:	43da      	mvns	r2, r3
 800313a:	693b      	ldr	r3, [r7, #16]
 800313c:	4013      	ands	r3, r2
 800313e:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 8003140:	683b      	ldr	r3, [r7, #0]
 8003142:	685a      	ldr	r2, [r3, #4]
 8003144:	2380      	movs	r3, #128	; 0x80
 8003146:	029b      	lsls	r3, r3, #10
 8003148:	4013      	ands	r3, r2
 800314a:	d003      	beq.n	8003154 <HAL_GPIO_Init+0x264>
        {
          temp |= iocurrent;
 800314c:	693a      	ldr	r2, [r7, #16]
 800314e:	68fb      	ldr	r3, [r7, #12]
 8003150:	4313      	orrs	r3, r2
 8003152:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR = temp;
 8003154:	4b24      	ldr	r3, [pc, #144]	; (80031e8 <HAL_GPIO_Init+0x2f8>)
 8003156:	693a      	ldr	r2, [r7, #16]
 8003158:	605a      	str	r2, [r3, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 800315a:	4b23      	ldr	r3, [pc, #140]	; (80031e8 <HAL_GPIO_Init+0x2f8>)
 800315c:	689b      	ldr	r3, [r3, #8]
 800315e:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 8003160:	68fb      	ldr	r3, [r7, #12]
 8003162:	43da      	mvns	r2, r3
 8003164:	693b      	ldr	r3, [r7, #16]
 8003166:	4013      	ands	r3, r2
 8003168:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 800316a:	683b      	ldr	r3, [r7, #0]
 800316c:	685a      	ldr	r2, [r3, #4]
 800316e:	2380      	movs	r3, #128	; 0x80
 8003170:	035b      	lsls	r3, r3, #13
 8003172:	4013      	ands	r3, r2
 8003174:	d003      	beq.n	800317e <HAL_GPIO_Init+0x28e>
        {
          temp |= iocurrent;
 8003176:	693a      	ldr	r2, [r7, #16]
 8003178:	68fb      	ldr	r3, [r7, #12]
 800317a:	4313      	orrs	r3, r2
 800317c:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR = temp;
 800317e:	4b1a      	ldr	r3, [pc, #104]	; (80031e8 <HAL_GPIO_Init+0x2f8>)
 8003180:	693a      	ldr	r2, [r7, #16]
 8003182:	609a      	str	r2, [r3, #8]

        temp = EXTI->FTSR;
 8003184:	4b18      	ldr	r3, [pc, #96]	; (80031e8 <HAL_GPIO_Init+0x2f8>)
 8003186:	68db      	ldr	r3, [r3, #12]
 8003188:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 800318a:	68fb      	ldr	r3, [r7, #12]
 800318c:	43da      	mvns	r2, r3
 800318e:	693b      	ldr	r3, [r7, #16]
 8003190:	4013      	ands	r3, r2
 8003192:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 8003194:	683b      	ldr	r3, [r7, #0]
 8003196:	685a      	ldr	r2, [r3, #4]
 8003198:	2380      	movs	r3, #128	; 0x80
 800319a:	039b      	lsls	r3, r3, #14
 800319c:	4013      	ands	r3, r2
 800319e:	d003      	beq.n	80031a8 <HAL_GPIO_Init+0x2b8>
        {
          temp |= iocurrent;
 80031a0:	693a      	ldr	r2, [r7, #16]
 80031a2:	68fb      	ldr	r3, [r7, #12]
 80031a4:	4313      	orrs	r3, r2
 80031a6:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR = temp;
 80031a8:	4b0f      	ldr	r3, [pc, #60]	; (80031e8 <HAL_GPIO_Init+0x2f8>)
 80031aa:	693a      	ldr	r2, [r7, #16]
 80031ac:	60da      	str	r2, [r3, #12]
      }
    }
    position++;
 80031ae:	697b      	ldr	r3, [r7, #20]
 80031b0:	3301      	adds	r3, #1
 80031b2:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0)
 80031b4:	683b      	ldr	r3, [r7, #0]
 80031b6:	681a      	ldr	r2, [r3, #0]
 80031b8:	697b      	ldr	r3, [r7, #20]
 80031ba:	40da      	lsrs	r2, r3
 80031bc:	1e13      	subs	r3, r2, #0
 80031be:	d000      	beq.n	80031c2 <HAL_GPIO_Init+0x2d2>
 80031c0:	e6a2      	b.n	8002f08 <HAL_GPIO_Init+0x18>
  }
}
 80031c2:	46c0      	nop			; (mov r8, r8)
 80031c4:	46c0      	nop			; (mov r8, r8)
 80031c6:	46bd      	mov	sp, r7
 80031c8:	b006      	add	sp, #24
 80031ca:	bd80      	pop	{r7, pc}
 80031cc:	40021000 	.word	0x40021000
 80031d0:	40010000 	.word	0x40010000
 80031d4:	50000400 	.word	0x50000400
 80031d8:	50000800 	.word	0x50000800
 80031dc:	50000c00 	.word	0x50000c00
 80031e0:	50001000 	.word	0x50001000
 80031e4:	50001c00 	.word	0x50001c00
 80031e8:	40010400 	.word	0x40010400

080031ec <HAL_GPIO_WritePin>:
  *                        GPIO_PIN_RESET: to clear the port pin
  *                        GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 80031ec:	b580      	push	{r7, lr}
 80031ee:	b082      	sub	sp, #8
 80031f0:	af00      	add	r7, sp, #0
 80031f2:	6078      	str	r0, [r7, #4]
 80031f4:	0008      	movs	r0, r1
 80031f6:	0011      	movs	r1, r2
 80031f8:	1cbb      	adds	r3, r7, #2
 80031fa:	1c02      	adds	r2, r0, #0
 80031fc:	801a      	strh	r2, [r3, #0]
 80031fe:	1c7b      	adds	r3, r7, #1
 8003200:	1c0a      	adds	r2, r1, #0
 8003202:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx, GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 8003204:	1c7b      	adds	r3, r7, #1
 8003206:	781b      	ldrb	r3, [r3, #0]
 8003208:	2b00      	cmp	r3, #0
 800320a:	d004      	beq.n	8003216 <HAL_GPIO_WritePin+0x2a>
  {
    GPIOx->BSRR = GPIO_Pin;
 800320c:	1cbb      	adds	r3, r7, #2
 800320e:	881a      	ldrh	r2, [r3, #0]
 8003210:	687b      	ldr	r3, [r7, #4]
 8003212:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = GPIO_Pin ;
  }
}
 8003214:	e003      	b.n	800321e <HAL_GPIO_WritePin+0x32>
    GPIOx->BRR = GPIO_Pin ;
 8003216:	1cbb      	adds	r3, r7, #2
 8003218:	881a      	ldrh	r2, [r3, #0]
 800321a:	687b      	ldr	r3, [r7, #4]
 800321c:	629a      	str	r2, [r3, #40]	; 0x28
}
 800321e:	46c0      	nop			; (mov r8, r8)
 8003220:	46bd      	mov	sp, r7
 8003222:	b002      	add	sp, #8
 8003224:	bd80      	pop	{r7, pc}
	...

08003228 <HAL_RCC_OscConfig>:
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8003228:	b5b0      	push	{r4, r5, r7, lr}
 800322a:	b08a      	sub	sp, #40	; 0x28
 800322c:	af00      	add	r7, sp, #0
 800322e:	6078      	str	r0, [r7, #4]
  uint32_t hsi_state;
  HAL_StatusTypeDef status;
  uint32_t sysclk_source, pll_config;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 8003230:	687b      	ldr	r3, [r7, #4]
 8003232:	2b00      	cmp	r3, #0
 8003234:	d102      	bne.n	800323c <HAL_RCC_OscConfig+0x14>
  {
    return HAL_ERROR;
 8003236:	2301      	movs	r3, #1
 8003238:	f000 fb6c 	bl	8003914 <HAL_RCC_OscConfig+0x6ec>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 800323c:	4bc8      	ldr	r3, [pc, #800]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 800323e:	68db      	ldr	r3, [r3, #12]
 8003240:	220c      	movs	r2, #12
 8003242:	4013      	ands	r3, r2
 8003244:	61fb      	str	r3, [r7, #28]
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 8003246:	4bc6      	ldr	r3, [pc, #792]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 8003248:	68da      	ldr	r2, [r3, #12]
 800324a:	2380      	movs	r3, #128	; 0x80
 800324c:	025b      	lsls	r3, r3, #9
 800324e:	4013      	ands	r3, r2
 8003250:	61bb      	str	r3, [r7, #24]

  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8003252:	687b      	ldr	r3, [r7, #4]
 8003254:	681b      	ldr	r3, [r3, #0]
 8003256:	2201      	movs	r2, #1
 8003258:	4013      	ands	r3, r2
 800325a:	d100      	bne.n	800325e <HAL_RCC_OscConfig+0x36>
 800325c:	e07d      	b.n	800335a <HAL_RCC_OscConfig+0x132>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 800325e:	69fb      	ldr	r3, [r7, #28]
 8003260:	2b08      	cmp	r3, #8
 8003262:	d007      	beq.n	8003274 <HAL_RCC_OscConfig+0x4c>
       || ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSE)))
 8003264:	69fb      	ldr	r3, [r7, #28]
 8003266:	2b0c      	cmp	r3, #12
 8003268:	d112      	bne.n	8003290 <HAL_RCC_OscConfig+0x68>
 800326a:	69ba      	ldr	r2, [r7, #24]
 800326c:	2380      	movs	r3, #128	; 0x80
 800326e:	025b      	lsls	r3, r3, #9
 8003270:	429a      	cmp	r2, r3
 8003272:	d10d      	bne.n	8003290 <HAL_RCC_OscConfig+0x68>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8003274:	4bba      	ldr	r3, [pc, #744]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 8003276:	681a      	ldr	r2, [r3, #0]
 8003278:	2380      	movs	r3, #128	; 0x80
 800327a:	029b      	lsls	r3, r3, #10
 800327c:	4013      	ands	r3, r2
 800327e:	d100      	bne.n	8003282 <HAL_RCC_OscConfig+0x5a>
 8003280:	e06a      	b.n	8003358 <HAL_RCC_OscConfig+0x130>
 8003282:	687b      	ldr	r3, [r7, #4]
 8003284:	685b      	ldr	r3, [r3, #4]
 8003286:	2b00      	cmp	r3, #0
 8003288:	d166      	bne.n	8003358 <HAL_RCC_OscConfig+0x130>
      {
        return HAL_ERROR;
 800328a:	2301      	movs	r3, #1
 800328c:	f000 fb42 	bl	8003914 <HAL_RCC_OscConfig+0x6ec>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8003290:	687b      	ldr	r3, [r7, #4]
 8003292:	685a      	ldr	r2, [r3, #4]
 8003294:	2380      	movs	r3, #128	; 0x80
 8003296:	025b      	lsls	r3, r3, #9
 8003298:	429a      	cmp	r2, r3
 800329a:	d107      	bne.n	80032ac <HAL_RCC_OscConfig+0x84>
 800329c:	4bb0      	ldr	r3, [pc, #704]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 800329e:	681a      	ldr	r2, [r3, #0]
 80032a0:	4baf      	ldr	r3, [pc, #700]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 80032a2:	2180      	movs	r1, #128	; 0x80
 80032a4:	0249      	lsls	r1, r1, #9
 80032a6:	430a      	orrs	r2, r1
 80032a8:	601a      	str	r2, [r3, #0]
 80032aa:	e027      	b.n	80032fc <HAL_RCC_OscConfig+0xd4>
 80032ac:	687b      	ldr	r3, [r7, #4]
 80032ae:	685a      	ldr	r2, [r3, #4]
 80032b0:	23a0      	movs	r3, #160	; 0xa0
 80032b2:	02db      	lsls	r3, r3, #11
 80032b4:	429a      	cmp	r2, r3
 80032b6:	d10e      	bne.n	80032d6 <HAL_RCC_OscConfig+0xae>
 80032b8:	4ba9      	ldr	r3, [pc, #676]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 80032ba:	681a      	ldr	r2, [r3, #0]
 80032bc:	4ba8      	ldr	r3, [pc, #672]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 80032be:	2180      	movs	r1, #128	; 0x80
 80032c0:	02c9      	lsls	r1, r1, #11
 80032c2:	430a      	orrs	r2, r1
 80032c4:	601a      	str	r2, [r3, #0]
 80032c6:	4ba6      	ldr	r3, [pc, #664]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 80032c8:	681a      	ldr	r2, [r3, #0]
 80032ca:	4ba5      	ldr	r3, [pc, #660]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 80032cc:	2180      	movs	r1, #128	; 0x80
 80032ce:	0249      	lsls	r1, r1, #9
 80032d0:	430a      	orrs	r2, r1
 80032d2:	601a      	str	r2, [r3, #0]
 80032d4:	e012      	b.n	80032fc <HAL_RCC_OscConfig+0xd4>
 80032d6:	4ba2      	ldr	r3, [pc, #648]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 80032d8:	681a      	ldr	r2, [r3, #0]
 80032da:	4ba1      	ldr	r3, [pc, #644]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 80032dc:	49a1      	ldr	r1, [pc, #644]	; (8003564 <HAL_RCC_OscConfig+0x33c>)
 80032de:	400a      	ands	r2, r1
 80032e0:	601a      	str	r2, [r3, #0]
 80032e2:	4b9f      	ldr	r3, [pc, #636]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 80032e4:	681a      	ldr	r2, [r3, #0]
 80032e6:	2380      	movs	r3, #128	; 0x80
 80032e8:	025b      	lsls	r3, r3, #9
 80032ea:	4013      	ands	r3, r2
 80032ec:	60fb      	str	r3, [r7, #12]
 80032ee:	68fb      	ldr	r3, [r7, #12]
 80032f0:	4b9b      	ldr	r3, [pc, #620]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 80032f2:	681a      	ldr	r2, [r3, #0]
 80032f4:	4b9a      	ldr	r3, [pc, #616]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 80032f6:	499c      	ldr	r1, [pc, #624]	; (8003568 <HAL_RCC_OscConfig+0x340>)
 80032f8:	400a      	ands	r2, r1
 80032fa:	601a      	str	r2, [r3, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 80032fc:	687b      	ldr	r3, [r7, #4]
 80032fe:	685b      	ldr	r3, [r3, #4]
 8003300:	2b00      	cmp	r3, #0
 8003302:	d014      	beq.n	800332e <HAL_RCC_OscConfig+0x106>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8003304:	f7ff fc60 	bl	8002bc8 <HAL_GetTick>
 8003308:	0003      	movs	r3, r0
 800330a:	617b      	str	r3, [r7, #20]

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 800330c:	e008      	b.n	8003320 <HAL_RCC_OscConfig+0xf8>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800330e:	f7ff fc5b 	bl	8002bc8 <HAL_GetTick>
 8003312:	0002      	movs	r2, r0
 8003314:	697b      	ldr	r3, [r7, #20]
 8003316:	1ad3      	subs	r3, r2, r3
 8003318:	2b64      	cmp	r3, #100	; 0x64
 800331a:	d901      	bls.n	8003320 <HAL_RCC_OscConfig+0xf8>
          {
            return HAL_TIMEOUT;
 800331c:	2303      	movs	r3, #3
 800331e:	e2f9      	b.n	8003914 <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 8003320:	4b8f      	ldr	r3, [pc, #572]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 8003322:	681a      	ldr	r2, [r3, #0]
 8003324:	2380      	movs	r3, #128	; 0x80
 8003326:	029b      	lsls	r3, r3, #10
 8003328:	4013      	ands	r3, r2
 800332a:	d0f0      	beq.n	800330e <HAL_RCC_OscConfig+0xe6>
 800332c:	e015      	b.n	800335a <HAL_RCC_OscConfig+0x132>
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800332e:	f7ff fc4b 	bl	8002bc8 <HAL_GetTick>
 8003332:	0003      	movs	r3, r0
 8003334:	617b      	str	r3, [r7, #20]

        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 8003336:	e008      	b.n	800334a <HAL_RCC_OscConfig+0x122>
        {
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8003338:	f7ff fc46 	bl	8002bc8 <HAL_GetTick>
 800333c:	0002      	movs	r2, r0
 800333e:	697b      	ldr	r3, [r7, #20]
 8003340:	1ad3      	subs	r3, r2, r3
 8003342:	2b64      	cmp	r3, #100	; 0x64
 8003344:	d901      	bls.n	800334a <HAL_RCC_OscConfig+0x122>
          {
            return HAL_TIMEOUT;
 8003346:	2303      	movs	r3, #3
 8003348:	e2e4      	b.n	8003914 <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 800334a:	4b85      	ldr	r3, [pc, #532]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 800334c:	681a      	ldr	r2, [r3, #0]
 800334e:	2380      	movs	r3, #128	; 0x80
 8003350:	029b      	lsls	r3, r3, #10
 8003352:	4013      	ands	r3, r2
 8003354:	d1f0      	bne.n	8003338 <HAL_RCC_OscConfig+0x110>
 8003356:	e000      	b.n	800335a <HAL_RCC_OscConfig+0x132>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8003358:	46c0      	nop			; (mov r8, r8)
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800335a:	687b      	ldr	r3, [r7, #4]
 800335c:	681b      	ldr	r3, [r3, #0]
 800335e:	2202      	movs	r2, #2
 8003360:	4013      	ands	r3, r2
 8003362:	d100      	bne.n	8003366 <HAL_RCC_OscConfig+0x13e>
 8003364:	e099      	b.n	800349a <HAL_RCC_OscConfig+0x272>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    hsi_state = RCC_OscInitStruct->HSIState;
 8003366:	687b      	ldr	r3, [r7, #4]
 8003368:	68db      	ldr	r3, [r3, #12]
 800336a:	627b      	str	r3, [r7, #36]	; 0x24

#if defined(RCC_CR_HSIOUTEN)
    if((hsi_state & RCC_HSI_OUTEN) != 0U)
 800336c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800336e:	2220      	movs	r2, #32
 8003370:	4013      	ands	r3, r2
 8003372:	d009      	beq.n	8003388 <HAL_RCC_OscConfig+0x160>
    {
      /* HSI Output enable for timer requested */
      SET_BIT(RCC->CR, RCC_CR_HSIOUTEN);
 8003374:	4b7a      	ldr	r3, [pc, #488]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 8003376:	681a      	ldr	r2, [r3, #0]
 8003378:	4b79      	ldr	r3, [pc, #484]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 800337a:	2120      	movs	r1, #32
 800337c:	430a      	orrs	r2, r1
 800337e:	601a      	str	r2, [r3, #0]

      hsi_state &= ~RCC_CR_HSIOUTEN;
 8003380:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003382:	2220      	movs	r2, #32
 8003384:	4393      	bics	r3, r2
 8003386:	627b      	str	r3, [r7, #36]	; 0x24
    }
#endif

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
 8003388:	69fb      	ldr	r3, [r7, #28]
 800338a:	2b04      	cmp	r3, #4
 800338c:	d005      	beq.n	800339a <HAL_RCC_OscConfig+0x172>
       || ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSI)))
 800338e:	69fb      	ldr	r3, [r7, #28]
 8003390:	2b0c      	cmp	r3, #12
 8003392:	d13e      	bne.n	8003412 <HAL_RCC_OscConfig+0x1ea>
 8003394:	69bb      	ldr	r3, [r7, #24]
 8003396:	2b00      	cmp	r3, #0
 8003398:	d13b      	bne.n	8003412 <HAL_RCC_OscConfig+0x1ea>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (hsi_state == RCC_HSI_OFF))
 800339a:	4b71      	ldr	r3, [pc, #452]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 800339c:	681b      	ldr	r3, [r3, #0]
 800339e:	2204      	movs	r2, #4
 80033a0:	4013      	ands	r3, r2
 80033a2:	d004      	beq.n	80033ae <HAL_RCC_OscConfig+0x186>
 80033a4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80033a6:	2b00      	cmp	r3, #0
 80033a8:	d101      	bne.n	80033ae <HAL_RCC_OscConfig+0x186>
      {
        return HAL_ERROR;
 80033aa:	2301      	movs	r3, #1
 80033ac:	e2b2      	b.n	8003914 <HAL_RCC_OscConfig+0x6ec>
      }
      /* Otherwise, just the calibration and HSI or HSIdiv4 are allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80033ae:	4b6c      	ldr	r3, [pc, #432]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 80033b0:	685b      	ldr	r3, [r3, #4]
 80033b2:	4a6e      	ldr	r2, [pc, #440]	; (800356c <HAL_RCC_OscConfig+0x344>)
 80033b4:	4013      	ands	r3, r2
 80033b6:	0019      	movs	r1, r3
 80033b8:	687b      	ldr	r3, [r7, #4]
 80033ba:	691b      	ldr	r3, [r3, #16]
 80033bc:	021a      	lsls	r2, r3, #8
 80033be:	4b68      	ldr	r3, [pc, #416]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 80033c0:	430a      	orrs	r2, r1
 80033c2:	605a      	str	r2, [r3, #4]

        /* Enable the Internal High Speed oscillator (HSI or HSIdiv4) */
        __HAL_RCC_HSI_CONFIG(hsi_state);
 80033c4:	4b66      	ldr	r3, [pc, #408]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 80033c6:	681b      	ldr	r3, [r3, #0]
 80033c8:	2209      	movs	r2, #9
 80033ca:	4393      	bics	r3, r2
 80033cc:	0019      	movs	r1, r3
 80033ce:	4b64      	ldr	r3, [pc, #400]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 80033d0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80033d2:	430a      	orrs	r2, r1
 80033d4:	601a      	str	r2, [r3, #0]
      }

      /* Update the SystemCoreClock global variable */
      SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 80033d6:	f000 fbeb 	bl	8003bb0 <HAL_RCC_GetSysClockFreq>
 80033da:	0001      	movs	r1, r0
 80033dc:	4b60      	ldr	r3, [pc, #384]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 80033de:	68db      	ldr	r3, [r3, #12]
 80033e0:	091b      	lsrs	r3, r3, #4
 80033e2:	220f      	movs	r2, #15
 80033e4:	4013      	ands	r3, r2
 80033e6:	4a62      	ldr	r2, [pc, #392]	; (8003570 <HAL_RCC_OscConfig+0x348>)
 80033e8:	5cd3      	ldrb	r3, [r2, r3]
 80033ea:	000a      	movs	r2, r1
 80033ec:	40da      	lsrs	r2, r3
 80033ee:	4b61      	ldr	r3, [pc, #388]	; (8003574 <HAL_RCC_OscConfig+0x34c>)
 80033f0:	601a      	str	r2, [r3, #0]

      /* Configure the source of time base considering new system clocks settings*/
      status = HAL_InitTick (uwTickPrio);
 80033f2:	4b61      	ldr	r3, [pc, #388]	; (8003578 <HAL_RCC_OscConfig+0x350>)
 80033f4:	681b      	ldr	r3, [r3, #0]
 80033f6:	2513      	movs	r5, #19
 80033f8:	197c      	adds	r4, r7, r5
 80033fa:	0018      	movs	r0, r3
 80033fc:	f7ff fb9e 	bl	8002b3c <HAL_InitTick>
 8003400:	0003      	movs	r3, r0
 8003402:	7023      	strb	r3, [r4, #0]
      if(status != HAL_OK)
 8003404:	197b      	adds	r3, r7, r5
 8003406:	781b      	ldrb	r3, [r3, #0]
 8003408:	2b00      	cmp	r3, #0
 800340a:	d046      	beq.n	800349a <HAL_RCC_OscConfig+0x272>
      {
        return status;
 800340c:	197b      	adds	r3, r7, r5
 800340e:	781b      	ldrb	r3, [r3, #0]
 8003410:	e280      	b.n	8003914 <HAL_RCC_OscConfig+0x6ec>
      }
    }
    else
    {
      /* Check the HSI State */
      if(hsi_state != RCC_HSI_OFF)
 8003412:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003414:	2b00      	cmp	r3, #0
 8003416:	d027      	beq.n	8003468 <HAL_RCC_OscConfig+0x240>
      {
        /* Enable the Internal High Speed oscillator (HSI or HSIdiv4) */
        __HAL_RCC_HSI_CONFIG(hsi_state);
 8003418:	4b51      	ldr	r3, [pc, #324]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 800341a:	681b      	ldr	r3, [r3, #0]
 800341c:	2209      	movs	r2, #9
 800341e:	4393      	bics	r3, r2
 8003420:	0019      	movs	r1, r3
 8003422:	4b4f      	ldr	r3, [pc, #316]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 8003424:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8003426:	430a      	orrs	r2, r1
 8003428:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800342a:	f7ff fbcd 	bl	8002bc8 <HAL_GetTick>
 800342e:	0003      	movs	r3, r0
 8003430:	617b      	str	r3, [r7, #20]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8003432:	e008      	b.n	8003446 <HAL_RCC_OscConfig+0x21e>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8003434:	f7ff fbc8 	bl	8002bc8 <HAL_GetTick>
 8003438:	0002      	movs	r2, r0
 800343a:	697b      	ldr	r3, [r7, #20]
 800343c:	1ad3      	subs	r3, r2, r3
 800343e:	2b02      	cmp	r3, #2
 8003440:	d901      	bls.n	8003446 <HAL_RCC_OscConfig+0x21e>
          {
            return HAL_TIMEOUT;
 8003442:	2303      	movs	r3, #3
 8003444:	e266      	b.n	8003914 <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8003446:	4b46      	ldr	r3, [pc, #280]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 8003448:	681b      	ldr	r3, [r3, #0]
 800344a:	2204      	movs	r2, #4
 800344c:	4013      	ands	r3, r2
 800344e:	d0f1      	beq.n	8003434 <HAL_RCC_OscConfig+0x20c>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8003450:	4b43      	ldr	r3, [pc, #268]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 8003452:	685b      	ldr	r3, [r3, #4]
 8003454:	4a45      	ldr	r2, [pc, #276]	; (800356c <HAL_RCC_OscConfig+0x344>)
 8003456:	4013      	ands	r3, r2
 8003458:	0019      	movs	r1, r3
 800345a:	687b      	ldr	r3, [r7, #4]
 800345c:	691b      	ldr	r3, [r3, #16]
 800345e:	021a      	lsls	r2, r3, #8
 8003460:	4b3f      	ldr	r3, [pc, #252]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 8003462:	430a      	orrs	r2, r1
 8003464:	605a      	str	r2, [r3, #4]
 8003466:	e018      	b.n	800349a <HAL_RCC_OscConfig+0x272>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8003468:	4b3d      	ldr	r3, [pc, #244]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 800346a:	681a      	ldr	r2, [r3, #0]
 800346c:	4b3c      	ldr	r3, [pc, #240]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 800346e:	2101      	movs	r1, #1
 8003470:	438a      	bics	r2, r1
 8003472:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8003474:	f7ff fba8 	bl	8002bc8 <HAL_GetTick>
 8003478:	0003      	movs	r3, r0
 800347a:	617b      	str	r3, [r7, #20]

        /* Wait till HSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 800347c:	e008      	b.n	8003490 <HAL_RCC_OscConfig+0x268>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800347e:	f7ff fba3 	bl	8002bc8 <HAL_GetTick>
 8003482:	0002      	movs	r2, r0
 8003484:	697b      	ldr	r3, [r7, #20]
 8003486:	1ad3      	subs	r3, r2, r3
 8003488:	2b02      	cmp	r3, #2
 800348a:	d901      	bls.n	8003490 <HAL_RCC_OscConfig+0x268>
          {
            return HAL_TIMEOUT;
 800348c:	2303      	movs	r3, #3
 800348e:	e241      	b.n	8003914 <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 8003490:	4b33      	ldr	r3, [pc, #204]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 8003492:	681b      	ldr	r3, [r3, #0]
 8003494:	2204      	movs	r2, #4
 8003496:	4013      	ands	r3, r2
 8003498:	d1f1      	bne.n	800347e <HAL_RCC_OscConfig+0x256>
        }
      }
    }
  }
  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 800349a:	687b      	ldr	r3, [r7, #4]
 800349c:	681b      	ldr	r3, [r3, #0]
 800349e:	2210      	movs	r2, #16
 80034a0:	4013      	ands	r3, r2
 80034a2:	d100      	bne.n	80034a6 <HAL_RCC_OscConfig+0x27e>
 80034a4:	e0a1      	b.n	80035ea <HAL_RCC_OscConfig+0x3c2>
  {
    /* When the MSI is used as system clock it will not be disabled */
    if(sysclk_source == RCC_CFGR_SWS_MSI)
 80034a6:	69fb      	ldr	r3, [r7, #28]
 80034a8:	2b00      	cmp	r3, #0
 80034aa:	d140      	bne.n	800352e <HAL_RCC_OscConfig+0x306>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 80034ac:	4b2c      	ldr	r3, [pc, #176]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 80034ae:	681a      	ldr	r2, [r3, #0]
 80034b0:	2380      	movs	r3, #128	; 0x80
 80034b2:	009b      	lsls	r3, r3, #2
 80034b4:	4013      	ands	r3, r2
 80034b6:	d005      	beq.n	80034c4 <HAL_RCC_OscConfig+0x29c>
 80034b8:	687b      	ldr	r3, [r7, #4]
 80034ba:	699b      	ldr	r3, [r3, #24]
 80034bc:	2b00      	cmp	r3, #0
 80034be:	d101      	bne.n	80034c4 <HAL_RCC_OscConfig+0x29c>
      {
        return HAL_ERROR;
 80034c0:	2301      	movs	r3, #1
 80034c2:	e227      	b.n	8003914 <HAL_RCC_OscConfig+0x6ec>
        /* Check MSICalibrationValue and MSIClockRange input parameters */
        assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
        assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

        /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 80034c4:	4b26      	ldr	r3, [pc, #152]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 80034c6:	685b      	ldr	r3, [r3, #4]
 80034c8:	4a2c      	ldr	r2, [pc, #176]	; (800357c <HAL_RCC_OscConfig+0x354>)
 80034ca:	4013      	ands	r3, r2
 80034cc:	0019      	movs	r1, r3
 80034ce:	687b      	ldr	r3, [r7, #4]
 80034d0:	6a1a      	ldr	r2, [r3, #32]
 80034d2:	4b23      	ldr	r3, [pc, #140]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 80034d4:	430a      	orrs	r2, r1
 80034d6:	605a      	str	r2, [r3, #4]
        /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80034d8:	4b21      	ldr	r3, [pc, #132]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 80034da:	685b      	ldr	r3, [r3, #4]
 80034dc:	021b      	lsls	r3, r3, #8
 80034de:	0a19      	lsrs	r1, r3, #8
 80034e0:	687b      	ldr	r3, [r7, #4]
 80034e2:	69db      	ldr	r3, [r3, #28]
 80034e4:	061a      	lsls	r2, r3, #24
 80034e6:	4b1e      	ldr	r3, [pc, #120]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 80034e8:	430a      	orrs	r2, r1
 80034ea:	605a      	str	r2, [r3, #4]


        /* Update the SystemCoreClock global variable */
        SystemCoreClock =  (32768U * (1UL << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_Pos) + 1U)))
 80034ec:	687b      	ldr	r3, [r7, #4]
 80034ee:	6a1b      	ldr	r3, [r3, #32]
 80034f0:	0b5b      	lsrs	r3, r3, #13
 80034f2:	3301      	adds	r3, #1
 80034f4:	2280      	movs	r2, #128	; 0x80
 80034f6:	0212      	lsls	r2, r2, #8
 80034f8:	409a      	lsls	r2, r3
                           >> AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos)];
 80034fa:	4b19      	ldr	r3, [pc, #100]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 80034fc:	68db      	ldr	r3, [r3, #12]
 80034fe:	091b      	lsrs	r3, r3, #4
 8003500:	210f      	movs	r1, #15
 8003502:	400b      	ands	r3, r1
 8003504:	491a      	ldr	r1, [pc, #104]	; (8003570 <HAL_RCC_OscConfig+0x348>)
 8003506:	5ccb      	ldrb	r3, [r1, r3]
 8003508:	40da      	lsrs	r2, r3
        SystemCoreClock =  (32768U * (1UL << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_Pos) + 1U)))
 800350a:	4b1a      	ldr	r3, [pc, #104]	; (8003574 <HAL_RCC_OscConfig+0x34c>)
 800350c:	601a      	str	r2, [r3, #0]

        /* Configure the source of time base considering new system clocks settings*/
        status = HAL_InitTick (uwTickPrio);
 800350e:	4b1a      	ldr	r3, [pc, #104]	; (8003578 <HAL_RCC_OscConfig+0x350>)
 8003510:	681b      	ldr	r3, [r3, #0]
 8003512:	2513      	movs	r5, #19
 8003514:	197c      	adds	r4, r7, r5
 8003516:	0018      	movs	r0, r3
 8003518:	f7ff fb10 	bl	8002b3c <HAL_InitTick>
 800351c:	0003      	movs	r3, r0
 800351e:	7023      	strb	r3, [r4, #0]
        if(status != HAL_OK)
 8003520:	197b      	adds	r3, r7, r5
 8003522:	781b      	ldrb	r3, [r3, #0]
 8003524:	2b00      	cmp	r3, #0
 8003526:	d060      	beq.n	80035ea <HAL_RCC_OscConfig+0x3c2>
        {
          return status;
 8003528:	197b      	adds	r3, r7, r5
 800352a:	781b      	ldrb	r3, [r3, #0]
 800352c:	e1f2      	b.n	8003914 <HAL_RCC_OscConfig+0x6ec>
    {
      /* Check MSI State */
      assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));

      /* Check the MSI State */
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 800352e:	687b      	ldr	r3, [r7, #4]
 8003530:	699b      	ldr	r3, [r3, #24]
 8003532:	2b00      	cmp	r3, #0
 8003534:	d03f      	beq.n	80035b6 <HAL_RCC_OscConfig+0x38e>
      {
        /* Enable the Multi Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
 8003536:	4b0a      	ldr	r3, [pc, #40]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 8003538:	681a      	ldr	r2, [r3, #0]
 800353a:	4b09      	ldr	r3, [pc, #36]	; (8003560 <HAL_RCC_OscConfig+0x338>)
 800353c:	2180      	movs	r1, #128	; 0x80
 800353e:	0049      	lsls	r1, r1, #1
 8003540:	430a      	orrs	r2, r1
 8003542:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8003544:	f7ff fb40 	bl	8002bc8 <HAL_GetTick>
 8003548:	0003      	movs	r3, r0
 800354a:	617b      	str	r3, [r7, #20]

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == 0U)
 800354c:	e018      	b.n	8003580 <HAL_RCC_OscConfig+0x358>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 800354e:	f7ff fb3b 	bl	8002bc8 <HAL_GetTick>
 8003552:	0002      	movs	r2, r0
 8003554:	697b      	ldr	r3, [r7, #20]
 8003556:	1ad3      	subs	r3, r2, r3
 8003558:	2b02      	cmp	r3, #2
 800355a:	d911      	bls.n	8003580 <HAL_RCC_OscConfig+0x358>
          {
            return HAL_TIMEOUT;
 800355c:	2303      	movs	r3, #3
 800355e:	e1d9      	b.n	8003914 <HAL_RCC_OscConfig+0x6ec>
 8003560:	40021000 	.word	0x40021000
 8003564:	fffeffff 	.word	0xfffeffff
 8003568:	fffbffff 	.word	0xfffbffff
 800356c:	ffffe0ff 	.word	0xffffe0ff
 8003570:	08021d34 	.word	0x08021d34
 8003574:	20000010 	.word	0x20000010
 8003578:	20000014 	.word	0x20000014
 800357c:	ffff1fff 	.word	0xffff1fff
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == 0U)
 8003580:	4bc9      	ldr	r3, [pc, #804]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 8003582:	681a      	ldr	r2, [r3, #0]
 8003584:	2380      	movs	r3, #128	; 0x80
 8003586:	009b      	lsls	r3, r3, #2
 8003588:	4013      	ands	r3, r2
 800358a:	d0e0      	beq.n	800354e <HAL_RCC_OscConfig+0x326>
        /* Check MSICalibrationValue and MSIClockRange input parameters */
        assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
        assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

        /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 800358c:	4bc6      	ldr	r3, [pc, #792]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 800358e:	685b      	ldr	r3, [r3, #4]
 8003590:	4ac6      	ldr	r2, [pc, #792]	; (80038ac <HAL_RCC_OscConfig+0x684>)
 8003592:	4013      	ands	r3, r2
 8003594:	0019      	movs	r1, r3
 8003596:	687b      	ldr	r3, [r7, #4]
 8003598:	6a1a      	ldr	r2, [r3, #32]
 800359a:	4bc3      	ldr	r3, [pc, #780]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 800359c:	430a      	orrs	r2, r1
 800359e:	605a      	str	r2, [r3, #4]
         /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80035a0:	4bc1      	ldr	r3, [pc, #772]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 80035a2:	685b      	ldr	r3, [r3, #4]
 80035a4:	021b      	lsls	r3, r3, #8
 80035a6:	0a19      	lsrs	r1, r3, #8
 80035a8:	687b      	ldr	r3, [r7, #4]
 80035aa:	69db      	ldr	r3, [r3, #28]
 80035ac:	061a      	lsls	r2, r3, #24
 80035ae:	4bbe      	ldr	r3, [pc, #760]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 80035b0:	430a      	orrs	r2, r1
 80035b2:	605a      	str	r2, [r3, #4]
 80035b4:	e019      	b.n	80035ea <HAL_RCC_OscConfig+0x3c2>
      }
      else
      {
        /* Disable the Multi Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
 80035b6:	4bbc      	ldr	r3, [pc, #752]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 80035b8:	681a      	ldr	r2, [r3, #0]
 80035ba:	4bbb      	ldr	r3, [pc, #748]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 80035bc:	49bc      	ldr	r1, [pc, #752]	; (80038b0 <HAL_RCC_OscConfig+0x688>)
 80035be:	400a      	ands	r2, r1
 80035c0:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80035c2:	f7ff fb01 	bl	8002bc8 <HAL_GetTick>
 80035c6:	0003      	movs	r3, r0
 80035c8:	617b      	str	r3, [r7, #20]

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != 0U)
 80035ca:	e008      	b.n	80035de <HAL_RCC_OscConfig+0x3b6>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 80035cc:	f7ff fafc 	bl	8002bc8 <HAL_GetTick>
 80035d0:	0002      	movs	r2, r0
 80035d2:	697b      	ldr	r3, [r7, #20]
 80035d4:	1ad3      	subs	r3, r2, r3
 80035d6:	2b02      	cmp	r3, #2
 80035d8:	d901      	bls.n	80035de <HAL_RCC_OscConfig+0x3b6>
          {
            return HAL_TIMEOUT;
 80035da:	2303      	movs	r3, #3
 80035dc:	e19a      	b.n	8003914 <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != 0U)
 80035de:	4bb2      	ldr	r3, [pc, #712]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 80035e0:	681a      	ldr	r2, [r3, #0]
 80035e2:	2380      	movs	r3, #128	; 0x80
 80035e4:	009b      	lsls	r3, r3, #2
 80035e6:	4013      	ands	r3, r2
 80035e8:	d1f0      	bne.n	80035cc <HAL_RCC_OscConfig+0x3a4>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80035ea:	687b      	ldr	r3, [r7, #4]
 80035ec:	681b      	ldr	r3, [r3, #0]
 80035ee:	2208      	movs	r2, #8
 80035f0:	4013      	ands	r3, r2
 80035f2:	d036      	beq.n	8003662 <HAL_RCC_OscConfig+0x43a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 80035f4:	687b      	ldr	r3, [r7, #4]
 80035f6:	695b      	ldr	r3, [r3, #20]
 80035f8:	2b00      	cmp	r3, #0
 80035fa:	d019      	beq.n	8003630 <HAL_RCC_OscConfig+0x408>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 80035fc:	4baa      	ldr	r3, [pc, #680]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 80035fe:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003600:	4ba9      	ldr	r3, [pc, #676]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 8003602:	2101      	movs	r1, #1
 8003604:	430a      	orrs	r2, r1
 8003606:	651a      	str	r2, [r3, #80]	; 0x50

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8003608:	f7ff fade 	bl	8002bc8 <HAL_GetTick>
 800360c:	0003      	movs	r3, r0
 800360e:	617b      	str	r3, [r7, #20]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 8003610:	e008      	b.n	8003624 <HAL_RCC_OscConfig+0x3fc>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8003612:	f7ff fad9 	bl	8002bc8 <HAL_GetTick>
 8003616:	0002      	movs	r2, r0
 8003618:	697b      	ldr	r3, [r7, #20]
 800361a:	1ad3      	subs	r3, r2, r3
 800361c:	2b02      	cmp	r3, #2
 800361e:	d901      	bls.n	8003624 <HAL_RCC_OscConfig+0x3fc>
        {
          return HAL_TIMEOUT;
 8003620:	2303      	movs	r3, #3
 8003622:	e177      	b.n	8003914 <HAL_RCC_OscConfig+0x6ec>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 8003624:	4ba0      	ldr	r3, [pc, #640]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 8003626:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8003628:	2202      	movs	r2, #2
 800362a:	4013      	ands	r3, r2
 800362c:	d0f1      	beq.n	8003612 <HAL_RCC_OscConfig+0x3ea>
 800362e:	e018      	b.n	8003662 <HAL_RCC_OscConfig+0x43a>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8003630:	4b9d      	ldr	r3, [pc, #628]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 8003632:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003634:	4b9c      	ldr	r3, [pc, #624]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 8003636:	2101      	movs	r1, #1
 8003638:	438a      	bics	r2, r1
 800363a:	651a      	str	r2, [r3, #80]	; 0x50

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800363c:	f7ff fac4 	bl	8002bc8 <HAL_GetTick>
 8003640:	0003      	movs	r3, r0
 8003642:	617b      	str	r3, [r7, #20]

      /* Wait till LSI is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 8003644:	e008      	b.n	8003658 <HAL_RCC_OscConfig+0x430>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8003646:	f7ff fabf 	bl	8002bc8 <HAL_GetTick>
 800364a:	0002      	movs	r2, r0
 800364c:	697b      	ldr	r3, [r7, #20]
 800364e:	1ad3      	subs	r3, r2, r3
 8003650:	2b02      	cmp	r3, #2
 8003652:	d901      	bls.n	8003658 <HAL_RCC_OscConfig+0x430>
        {
          return HAL_TIMEOUT;
 8003654:	2303      	movs	r3, #3
 8003656:	e15d      	b.n	8003914 <HAL_RCC_OscConfig+0x6ec>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 8003658:	4b93      	ldr	r3, [pc, #588]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 800365a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800365c:	2202      	movs	r2, #2
 800365e:	4013      	ands	r3, r2
 8003660:	d1f1      	bne.n	8003646 <HAL_RCC_OscConfig+0x41e>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8003662:	687b      	ldr	r3, [r7, #4]
 8003664:	681b      	ldr	r3, [r3, #0]
 8003666:	2204      	movs	r2, #4
 8003668:	4013      	ands	r3, r2
 800366a:	d100      	bne.n	800366e <HAL_RCC_OscConfig+0x446>
 800366c:	e0ae      	b.n	80037cc <HAL_RCC_OscConfig+0x5a4>
  {
    FlagStatus       pwrclkchanged = RESET;
 800366e:	2023      	movs	r0, #35	; 0x23
 8003670:	183b      	adds	r3, r7, r0
 8003672:	2200      	movs	r2, #0
 8003674:	701a      	strb	r2, [r3, #0]
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8003676:	4b8c      	ldr	r3, [pc, #560]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 8003678:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800367a:	2380      	movs	r3, #128	; 0x80
 800367c:	055b      	lsls	r3, r3, #21
 800367e:	4013      	ands	r3, r2
 8003680:	d109      	bne.n	8003696 <HAL_RCC_OscConfig+0x46e>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8003682:	4b89      	ldr	r3, [pc, #548]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 8003684:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8003686:	4b88      	ldr	r3, [pc, #544]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 8003688:	2180      	movs	r1, #128	; 0x80
 800368a:	0549      	lsls	r1, r1, #21
 800368c:	430a      	orrs	r2, r1
 800368e:	639a      	str	r2, [r3, #56]	; 0x38
      pwrclkchanged = SET;
 8003690:	183b      	adds	r3, r7, r0
 8003692:	2201      	movs	r2, #1
 8003694:	701a      	strb	r2, [r3, #0]
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8003696:	4b87      	ldr	r3, [pc, #540]	; (80038b4 <HAL_RCC_OscConfig+0x68c>)
 8003698:	681a      	ldr	r2, [r3, #0]
 800369a:	2380      	movs	r3, #128	; 0x80
 800369c:	005b      	lsls	r3, r3, #1
 800369e:	4013      	ands	r3, r2
 80036a0:	d11a      	bne.n	80036d8 <HAL_RCC_OscConfig+0x4b0>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 80036a2:	4b84      	ldr	r3, [pc, #528]	; (80038b4 <HAL_RCC_OscConfig+0x68c>)
 80036a4:	681a      	ldr	r2, [r3, #0]
 80036a6:	4b83      	ldr	r3, [pc, #524]	; (80038b4 <HAL_RCC_OscConfig+0x68c>)
 80036a8:	2180      	movs	r1, #128	; 0x80
 80036aa:	0049      	lsls	r1, r1, #1
 80036ac:	430a      	orrs	r2, r1
 80036ae:	601a      	str	r2, [r3, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 80036b0:	f7ff fa8a 	bl	8002bc8 <HAL_GetTick>
 80036b4:	0003      	movs	r3, r0
 80036b6:	617b      	str	r3, [r7, #20]

      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80036b8:	e008      	b.n	80036cc <HAL_RCC_OscConfig+0x4a4>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80036ba:	f7ff fa85 	bl	8002bc8 <HAL_GetTick>
 80036be:	0002      	movs	r2, r0
 80036c0:	697b      	ldr	r3, [r7, #20]
 80036c2:	1ad3      	subs	r3, r2, r3
 80036c4:	2b64      	cmp	r3, #100	; 0x64
 80036c6:	d901      	bls.n	80036cc <HAL_RCC_OscConfig+0x4a4>
        {
          return HAL_TIMEOUT;
 80036c8:	2303      	movs	r3, #3
 80036ca:	e123      	b.n	8003914 <HAL_RCC_OscConfig+0x6ec>
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80036cc:	4b79      	ldr	r3, [pc, #484]	; (80038b4 <HAL_RCC_OscConfig+0x68c>)
 80036ce:	681a      	ldr	r2, [r3, #0]
 80036d0:	2380      	movs	r3, #128	; 0x80
 80036d2:	005b      	lsls	r3, r3, #1
 80036d4:	4013      	ands	r3, r2
 80036d6:	d0f0      	beq.n	80036ba <HAL_RCC_OscConfig+0x492>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80036d8:	687b      	ldr	r3, [r7, #4]
 80036da:	689a      	ldr	r2, [r3, #8]
 80036dc:	2380      	movs	r3, #128	; 0x80
 80036de:	005b      	lsls	r3, r3, #1
 80036e0:	429a      	cmp	r2, r3
 80036e2:	d107      	bne.n	80036f4 <HAL_RCC_OscConfig+0x4cc>
 80036e4:	4b70      	ldr	r3, [pc, #448]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 80036e6:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80036e8:	4b6f      	ldr	r3, [pc, #444]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 80036ea:	2180      	movs	r1, #128	; 0x80
 80036ec:	0049      	lsls	r1, r1, #1
 80036ee:	430a      	orrs	r2, r1
 80036f0:	651a      	str	r2, [r3, #80]	; 0x50
 80036f2:	e031      	b.n	8003758 <HAL_RCC_OscConfig+0x530>
 80036f4:	687b      	ldr	r3, [r7, #4]
 80036f6:	689b      	ldr	r3, [r3, #8]
 80036f8:	2b00      	cmp	r3, #0
 80036fa:	d10c      	bne.n	8003716 <HAL_RCC_OscConfig+0x4ee>
 80036fc:	4b6a      	ldr	r3, [pc, #424]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 80036fe:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003700:	4b69      	ldr	r3, [pc, #420]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 8003702:	496b      	ldr	r1, [pc, #428]	; (80038b0 <HAL_RCC_OscConfig+0x688>)
 8003704:	400a      	ands	r2, r1
 8003706:	651a      	str	r2, [r3, #80]	; 0x50
 8003708:	4b67      	ldr	r3, [pc, #412]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 800370a:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800370c:	4b66      	ldr	r3, [pc, #408]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 800370e:	496a      	ldr	r1, [pc, #424]	; (80038b8 <HAL_RCC_OscConfig+0x690>)
 8003710:	400a      	ands	r2, r1
 8003712:	651a      	str	r2, [r3, #80]	; 0x50
 8003714:	e020      	b.n	8003758 <HAL_RCC_OscConfig+0x530>
 8003716:	687b      	ldr	r3, [r7, #4]
 8003718:	689a      	ldr	r2, [r3, #8]
 800371a:	23a0      	movs	r3, #160	; 0xa0
 800371c:	00db      	lsls	r3, r3, #3
 800371e:	429a      	cmp	r2, r3
 8003720:	d10e      	bne.n	8003740 <HAL_RCC_OscConfig+0x518>
 8003722:	4b61      	ldr	r3, [pc, #388]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 8003724:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003726:	4b60      	ldr	r3, [pc, #384]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 8003728:	2180      	movs	r1, #128	; 0x80
 800372a:	00c9      	lsls	r1, r1, #3
 800372c:	430a      	orrs	r2, r1
 800372e:	651a      	str	r2, [r3, #80]	; 0x50
 8003730:	4b5d      	ldr	r3, [pc, #372]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 8003732:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003734:	4b5c      	ldr	r3, [pc, #368]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 8003736:	2180      	movs	r1, #128	; 0x80
 8003738:	0049      	lsls	r1, r1, #1
 800373a:	430a      	orrs	r2, r1
 800373c:	651a      	str	r2, [r3, #80]	; 0x50
 800373e:	e00b      	b.n	8003758 <HAL_RCC_OscConfig+0x530>
 8003740:	4b59      	ldr	r3, [pc, #356]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 8003742:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003744:	4b58      	ldr	r3, [pc, #352]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 8003746:	495a      	ldr	r1, [pc, #360]	; (80038b0 <HAL_RCC_OscConfig+0x688>)
 8003748:	400a      	ands	r2, r1
 800374a:	651a      	str	r2, [r3, #80]	; 0x50
 800374c:	4b56      	ldr	r3, [pc, #344]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 800374e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003750:	4b55      	ldr	r3, [pc, #340]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 8003752:	4959      	ldr	r1, [pc, #356]	; (80038b8 <HAL_RCC_OscConfig+0x690>)
 8003754:	400a      	ands	r2, r1
 8003756:	651a      	str	r2, [r3, #80]	; 0x50

    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8003758:	687b      	ldr	r3, [r7, #4]
 800375a:	689b      	ldr	r3, [r3, #8]
 800375c:	2b00      	cmp	r3, #0
 800375e:	d015      	beq.n	800378c <HAL_RCC_OscConfig+0x564>
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8003760:	f7ff fa32 	bl	8002bc8 <HAL_GetTick>
 8003764:	0003      	movs	r3, r0
 8003766:	617b      	str	r3, [r7, #20]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8003768:	e009      	b.n	800377e <HAL_RCC_OscConfig+0x556>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800376a:	f7ff fa2d 	bl	8002bc8 <HAL_GetTick>
 800376e:	0002      	movs	r2, r0
 8003770:	697b      	ldr	r3, [r7, #20]
 8003772:	1ad3      	subs	r3, r2, r3
 8003774:	4a51      	ldr	r2, [pc, #324]	; (80038bc <HAL_RCC_OscConfig+0x694>)
 8003776:	4293      	cmp	r3, r2
 8003778:	d901      	bls.n	800377e <HAL_RCC_OscConfig+0x556>
        {
          return HAL_TIMEOUT;
 800377a:	2303      	movs	r3, #3
 800377c:	e0ca      	b.n	8003914 <HAL_RCC_OscConfig+0x6ec>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800377e:	4b4a      	ldr	r3, [pc, #296]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 8003780:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003782:	2380      	movs	r3, #128	; 0x80
 8003784:	009b      	lsls	r3, r3, #2
 8003786:	4013      	ands	r3, r2
 8003788:	d0ef      	beq.n	800376a <HAL_RCC_OscConfig+0x542>
 800378a:	e014      	b.n	80037b6 <HAL_RCC_OscConfig+0x58e>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800378c:	f7ff fa1c 	bl	8002bc8 <HAL_GetTick>
 8003790:	0003      	movs	r3, r0
 8003792:	617b      	str	r3, [r7, #20]

      /* Wait till LSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 8003794:	e009      	b.n	80037aa <HAL_RCC_OscConfig+0x582>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8003796:	f7ff fa17 	bl	8002bc8 <HAL_GetTick>
 800379a:	0002      	movs	r2, r0
 800379c:	697b      	ldr	r3, [r7, #20]
 800379e:	1ad3      	subs	r3, r2, r3
 80037a0:	4a46      	ldr	r2, [pc, #280]	; (80038bc <HAL_RCC_OscConfig+0x694>)
 80037a2:	4293      	cmp	r3, r2
 80037a4:	d901      	bls.n	80037aa <HAL_RCC_OscConfig+0x582>
        {
          return HAL_TIMEOUT;
 80037a6:	2303      	movs	r3, #3
 80037a8:	e0b4      	b.n	8003914 <HAL_RCC_OscConfig+0x6ec>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 80037aa:	4b3f      	ldr	r3, [pc, #252]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 80037ac:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80037ae:	2380      	movs	r3, #128	; 0x80
 80037b0:	009b      	lsls	r3, r3, #2
 80037b2:	4013      	ands	r3, r2
 80037b4:	d1ef      	bne.n	8003796 <HAL_RCC_OscConfig+0x56e>
        }
      }
    }

    /* Require to disable power clock if necessary */
    if(pwrclkchanged == SET)
 80037b6:	2323      	movs	r3, #35	; 0x23
 80037b8:	18fb      	adds	r3, r7, r3
 80037ba:	781b      	ldrb	r3, [r3, #0]
 80037bc:	2b01      	cmp	r3, #1
 80037be:	d105      	bne.n	80037cc <HAL_RCC_OscConfig+0x5a4>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 80037c0:	4b39      	ldr	r3, [pc, #228]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 80037c2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80037c4:	4b38      	ldr	r3, [pc, #224]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 80037c6:	493e      	ldr	r1, [pc, #248]	; (80038c0 <HAL_RCC_OscConfig+0x698>)
 80037c8:	400a      	ands	r2, r1
 80037ca:	639a      	str	r2, [r3, #56]	; 0x38
#endif /* RCC_HSI48_SUPPORT */

  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80037cc:	687b      	ldr	r3, [r7, #4]
 80037ce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80037d0:	2b00      	cmp	r3, #0
 80037d2:	d100      	bne.n	80037d6 <HAL_RCC_OscConfig+0x5ae>
 80037d4:	e09d      	b.n	8003912 <HAL_RCC_OscConfig+0x6ea>
  {
    /* Check if the PLL is used as system clock or not */
    if(sysclk_source != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80037d6:	69fb      	ldr	r3, [r7, #28]
 80037d8:	2b0c      	cmp	r3, #12
 80037da:	d100      	bne.n	80037de <HAL_RCC_OscConfig+0x5b6>
 80037dc:	e076      	b.n	80038cc <HAL_RCC_OscConfig+0x6a4>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80037de:	687b      	ldr	r3, [r7, #4]
 80037e0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80037e2:	2b02      	cmp	r3, #2
 80037e4:	d145      	bne.n	8003872 <HAL_RCC_OscConfig+0x64a>
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
        assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
        assert_param(IS_RCC_PLL_DIV(RCC_OscInitStruct->PLL.PLLDIV));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80037e6:	4b30      	ldr	r3, [pc, #192]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 80037e8:	681a      	ldr	r2, [r3, #0]
 80037ea:	4b2f      	ldr	r3, [pc, #188]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 80037ec:	4935      	ldr	r1, [pc, #212]	; (80038c4 <HAL_RCC_OscConfig+0x69c>)
 80037ee:	400a      	ands	r2, r1
 80037f0:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80037f2:	f7ff f9e9 	bl	8002bc8 <HAL_GetTick>
 80037f6:	0003      	movs	r3, r0
 80037f8:	617b      	str	r3, [r7, #20]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 80037fa:	e008      	b.n	800380e <HAL_RCC_OscConfig+0x5e6>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80037fc:	f7ff f9e4 	bl	8002bc8 <HAL_GetTick>
 8003800:	0002      	movs	r2, r0
 8003802:	697b      	ldr	r3, [r7, #20]
 8003804:	1ad3      	subs	r3, r2, r3
 8003806:	2b02      	cmp	r3, #2
 8003808:	d901      	bls.n	800380e <HAL_RCC_OscConfig+0x5e6>
          {
            return HAL_TIMEOUT;
 800380a:	2303      	movs	r3, #3
 800380c:	e082      	b.n	8003914 <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 800380e:	4b26      	ldr	r3, [pc, #152]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 8003810:	681a      	ldr	r2, [r3, #0]
 8003812:	2380      	movs	r3, #128	; 0x80
 8003814:	049b      	lsls	r3, r3, #18
 8003816:	4013      	ands	r3, r2
 8003818:	d1f0      	bne.n	80037fc <HAL_RCC_OscConfig+0x5d4>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800381a:	4b23      	ldr	r3, [pc, #140]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 800381c:	68db      	ldr	r3, [r3, #12]
 800381e:	4a2a      	ldr	r2, [pc, #168]	; (80038c8 <HAL_RCC_OscConfig+0x6a0>)
 8003820:	4013      	ands	r3, r2
 8003822:	0019      	movs	r1, r3
 8003824:	687b      	ldr	r3, [r7, #4]
 8003826:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8003828:	687b      	ldr	r3, [r7, #4]
 800382a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800382c:	431a      	orrs	r2, r3
 800382e:	687b      	ldr	r3, [r7, #4]
 8003830:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8003832:	431a      	orrs	r2, r3
 8003834:	4b1c      	ldr	r3, [pc, #112]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 8003836:	430a      	orrs	r2, r1
 8003838:	60da      	str	r2, [r3, #12]
                             RCC_OscInitStruct->PLL.PLLMUL,
                             RCC_OscInitStruct->PLL.PLLDIV);
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 800383a:	4b1b      	ldr	r3, [pc, #108]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 800383c:	681a      	ldr	r2, [r3, #0]
 800383e:	4b1a      	ldr	r3, [pc, #104]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 8003840:	2180      	movs	r1, #128	; 0x80
 8003842:	0449      	lsls	r1, r1, #17
 8003844:	430a      	orrs	r2, r1
 8003846:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8003848:	f7ff f9be 	bl	8002bc8 <HAL_GetTick>
 800384c:	0003      	movs	r3, r0
 800384e:	617b      	str	r3, [r7, #20]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == 0U)
 8003850:	e008      	b.n	8003864 <HAL_RCC_OscConfig+0x63c>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8003852:	f7ff f9b9 	bl	8002bc8 <HAL_GetTick>
 8003856:	0002      	movs	r2, r0
 8003858:	697b      	ldr	r3, [r7, #20]
 800385a:	1ad3      	subs	r3, r2, r3
 800385c:	2b02      	cmp	r3, #2
 800385e:	d901      	bls.n	8003864 <HAL_RCC_OscConfig+0x63c>
          {
            return HAL_TIMEOUT;
 8003860:	2303      	movs	r3, #3
 8003862:	e057      	b.n	8003914 <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == 0U)
 8003864:	4b10      	ldr	r3, [pc, #64]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 8003866:	681a      	ldr	r2, [r3, #0]
 8003868:	2380      	movs	r3, #128	; 0x80
 800386a:	049b      	lsls	r3, r3, #18
 800386c:	4013      	ands	r3, r2
 800386e:	d0f0      	beq.n	8003852 <HAL_RCC_OscConfig+0x62a>
 8003870:	e04f      	b.n	8003912 <HAL_RCC_OscConfig+0x6ea>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8003872:	4b0d      	ldr	r3, [pc, #52]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 8003874:	681a      	ldr	r2, [r3, #0]
 8003876:	4b0c      	ldr	r3, [pc, #48]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 8003878:	4912      	ldr	r1, [pc, #72]	; (80038c4 <HAL_RCC_OscConfig+0x69c>)
 800387a:	400a      	ands	r2, r1
 800387c:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800387e:	f7ff f9a3 	bl	8002bc8 <HAL_GetTick>
 8003882:	0003      	movs	r3, r0
 8003884:	617b      	str	r3, [r7, #20]

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 8003886:	e008      	b.n	800389a <HAL_RCC_OscConfig+0x672>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8003888:	f7ff f99e 	bl	8002bc8 <HAL_GetTick>
 800388c:	0002      	movs	r2, r0
 800388e:	697b      	ldr	r3, [r7, #20]
 8003890:	1ad3      	subs	r3, r2, r3
 8003892:	2b02      	cmp	r3, #2
 8003894:	d901      	bls.n	800389a <HAL_RCC_OscConfig+0x672>
          {
            return HAL_TIMEOUT;
 8003896:	2303      	movs	r3, #3
 8003898:	e03c      	b.n	8003914 <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 800389a:	4b03      	ldr	r3, [pc, #12]	; (80038a8 <HAL_RCC_OscConfig+0x680>)
 800389c:	681a      	ldr	r2, [r3, #0]
 800389e:	2380      	movs	r3, #128	; 0x80
 80038a0:	049b      	lsls	r3, r3, #18
 80038a2:	4013      	ands	r3, r2
 80038a4:	d1f0      	bne.n	8003888 <HAL_RCC_OscConfig+0x660>
 80038a6:	e034      	b.n	8003912 <HAL_RCC_OscConfig+0x6ea>
 80038a8:	40021000 	.word	0x40021000
 80038ac:	ffff1fff 	.word	0xffff1fff
 80038b0:	fffffeff 	.word	0xfffffeff
 80038b4:	40007000 	.word	0x40007000
 80038b8:	fffffbff 	.word	0xfffffbff
 80038bc:	00001388 	.word	0x00001388
 80038c0:	efffffff 	.word	0xefffffff
 80038c4:	feffffff 	.word	0xfeffffff
 80038c8:	ff02ffff 	.word	0xff02ffff
      }
    }
    else
    {
      /* Check if there is a request to disable the PLL used as System clock source */
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 80038cc:	687b      	ldr	r3, [r7, #4]
 80038ce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80038d0:	2b01      	cmp	r3, #1
 80038d2:	d101      	bne.n	80038d8 <HAL_RCC_OscConfig+0x6b0>
      {
        return HAL_ERROR;
 80038d4:	2301      	movs	r3, #1
 80038d6:	e01d      	b.n	8003914 <HAL_RCC_OscConfig+0x6ec>
      }
      else
      {
        /* Do not return HAL_ERROR if request repeats the current configuration */
        pll_config = RCC->CFGR;
 80038d8:	4b10      	ldr	r3, [pc, #64]	; (800391c <HAL_RCC_OscConfig+0x6f4>)
 80038da:	68db      	ldr	r3, [r3, #12]
 80038dc:	61bb      	str	r3, [r7, #24]
        if((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 80038de:	69ba      	ldr	r2, [r7, #24]
 80038e0:	2380      	movs	r3, #128	; 0x80
 80038e2:	025b      	lsls	r3, r3, #9
 80038e4:	401a      	ands	r2, r3
 80038e6:	687b      	ldr	r3, [r7, #4]
 80038e8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80038ea:	429a      	cmp	r2, r3
 80038ec:	d10f      	bne.n	800390e <HAL_RCC_OscConfig+0x6e6>
           (READ_BIT(pll_config, RCC_CFGR_PLLMUL) != RCC_OscInitStruct->PLL.PLLMUL) ||
 80038ee:	69ba      	ldr	r2, [r7, #24]
 80038f0:	23f0      	movs	r3, #240	; 0xf0
 80038f2:	039b      	lsls	r3, r3, #14
 80038f4:	401a      	ands	r2, r3
 80038f6:	687b      	ldr	r3, [r7, #4]
 80038f8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
        if((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 80038fa:	429a      	cmp	r2, r3
 80038fc:	d107      	bne.n	800390e <HAL_RCC_OscConfig+0x6e6>
           (READ_BIT(pll_config, RCC_CFGR_PLLDIV) != RCC_OscInitStruct->PLL.PLLDIV))
 80038fe:	69ba      	ldr	r2, [r7, #24]
 8003900:	23c0      	movs	r3, #192	; 0xc0
 8003902:	041b      	lsls	r3, r3, #16
 8003904:	401a      	ands	r2, r3
 8003906:	687b      	ldr	r3, [r7, #4]
 8003908:	6b1b      	ldr	r3, [r3, #48]	; 0x30
           (READ_BIT(pll_config, RCC_CFGR_PLLMUL) != RCC_OscInitStruct->PLL.PLLMUL) ||
 800390a:	429a      	cmp	r2, r3
 800390c:	d001      	beq.n	8003912 <HAL_RCC_OscConfig+0x6ea>
        {
          return HAL_ERROR;
 800390e:	2301      	movs	r3, #1
 8003910:	e000      	b.n	8003914 <HAL_RCC_OscConfig+0x6ec>
        }
      }
    }
  }
  return HAL_OK;
 8003912:	2300      	movs	r3, #0
}
 8003914:	0018      	movs	r0, r3
 8003916:	46bd      	mov	sp, r7
 8003918:	b00a      	add	sp, #40	; 0x28
 800391a:	bdb0      	pop	{r4, r5, r7, pc}
 800391c:	40021000 	.word	0x40021000

08003920 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8003920:	b5b0      	push	{r4, r5, r7, lr}
 8003922:	b084      	sub	sp, #16
 8003924:	af00      	add	r7, sp, #0
 8003926:	6078      	str	r0, [r7, #4]
 8003928:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  HAL_StatusTypeDef status;

  /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
 800392a:	687b      	ldr	r3, [r7, #4]
 800392c:	2b00      	cmp	r3, #0
 800392e:	d101      	bne.n	8003934 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 8003930:	2301      	movs	r3, #1
 8003932:	e128      	b.n	8003b86 <HAL_RCC_ClockConfig+0x266>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
  must be correctly programmed according to the frequency of the CPU clock
  (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8003934:	4b96      	ldr	r3, [pc, #600]	; (8003b90 <HAL_RCC_ClockConfig+0x270>)
 8003936:	681b      	ldr	r3, [r3, #0]
 8003938:	2201      	movs	r2, #1
 800393a:	4013      	ands	r3, r2
 800393c:	683a      	ldr	r2, [r7, #0]
 800393e:	429a      	cmp	r2, r3
 8003940:	d91e      	bls.n	8003980 <HAL_RCC_ClockConfig+0x60>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8003942:	4b93      	ldr	r3, [pc, #588]	; (8003b90 <HAL_RCC_ClockConfig+0x270>)
 8003944:	681b      	ldr	r3, [r3, #0]
 8003946:	2201      	movs	r2, #1
 8003948:	4393      	bics	r3, r2
 800394a:	0019      	movs	r1, r3
 800394c:	4b90      	ldr	r3, [pc, #576]	; (8003b90 <HAL_RCC_ClockConfig+0x270>)
 800394e:	683a      	ldr	r2, [r7, #0]
 8003950:	430a      	orrs	r2, r1
 8003952:	601a      	str	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by polling the FLASH_ACR register */
    tickstart = HAL_GetTick();
 8003954:	f7ff f938 	bl	8002bc8 <HAL_GetTick>
 8003958:	0003      	movs	r3, r0
 800395a:	60fb      	str	r3, [r7, #12]

    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 800395c:	e009      	b.n	8003972 <HAL_RCC_ClockConfig+0x52>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800395e:	f7ff f933 	bl	8002bc8 <HAL_GetTick>
 8003962:	0002      	movs	r2, r0
 8003964:	68fb      	ldr	r3, [r7, #12]
 8003966:	1ad3      	subs	r3, r2, r3
 8003968:	4a8a      	ldr	r2, [pc, #552]	; (8003b94 <HAL_RCC_ClockConfig+0x274>)
 800396a:	4293      	cmp	r3, r2
 800396c:	d901      	bls.n	8003972 <HAL_RCC_ClockConfig+0x52>
      {
        return HAL_TIMEOUT;
 800396e:	2303      	movs	r3, #3
 8003970:	e109      	b.n	8003b86 <HAL_RCC_ClockConfig+0x266>
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 8003972:	4b87      	ldr	r3, [pc, #540]	; (8003b90 <HAL_RCC_ClockConfig+0x270>)
 8003974:	681b      	ldr	r3, [r3, #0]
 8003976:	2201      	movs	r2, #1
 8003978:	4013      	ands	r3, r2
 800397a:	683a      	ldr	r2, [r7, #0]
 800397c:	429a      	cmp	r2, r3
 800397e:	d1ee      	bne.n	800395e <HAL_RCC_ClockConfig+0x3e>
      }
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8003980:	687b      	ldr	r3, [r7, #4]
 8003982:	681b      	ldr	r3, [r3, #0]
 8003984:	2202      	movs	r2, #2
 8003986:	4013      	ands	r3, r2
 8003988:	d009      	beq.n	800399e <HAL_RCC_ClockConfig+0x7e>
  {
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800398a:	4b83      	ldr	r3, [pc, #524]	; (8003b98 <HAL_RCC_ClockConfig+0x278>)
 800398c:	68db      	ldr	r3, [r3, #12]
 800398e:	22f0      	movs	r2, #240	; 0xf0
 8003990:	4393      	bics	r3, r2
 8003992:	0019      	movs	r1, r3
 8003994:	687b      	ldr	r3, [r7, #4]
 8003996:	689a      	ldr	r2, [r3, #8]
 8003998:	4b7f      	ldr	r3, [pc, #508]	; (8003b98 <HAL_RCC_ClockConfig+0x278>)
 800399a:	430a      	orrs	r2, r1
 800399c:	60da      	str	r2, [r3, #12]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800399e:	687b      	ldr	r3, [r7, #4]
 80039a0:	681b      	ldr	r3, [r3, #0]
 80039a2:	2201      	movs	r2, #1
 80039a4:	4013      	ands	r3, r2
 80039a6:	d100      	bne.n	80039aa <HAL_RCC_ClockConfig+0x8a>
 80039a8:	e089      	b.n	8003abe <HAL_RCC_ClockConfig+0x19e>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80039aa:	687b      	ldr	r3, [r7, #4]
 80039ac:	685b      	ldr	r3, [r3, #4]
 80039ae:	2b02      	cmp	r3, #2
 80039b0:	d107      	bne.n	80039c2 <HAL_RCC_ClockConfig+0xa2>
    {
      /* Check the HSE ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 80039b2:	4b79      	ldr	r3, [pc, #484]	; (8003b98 <HAL_RCC_ClockConfig+0x278>)
 80039b4:	681a      	ldr	r2, [r3, #0]
 80039b6:	2380      	movs	r3, #128	; 0x80
 80039b8:	029b      	lsls	r3, r3, #10
 80039ba:	4013      	ands	r3, r2
 80039bc:	d120      	bne.n	8003a00 <HAL_RCC_ClockConfig+0xe0>
      {
        return HAL_ERROR;
 80039be:	2301      	movs	r3, #1
 80039c0:	e0e1      	b.n	8003b86 <HAL_RCC_ClockConfig+0x266>
      }
    }
    /* PLL is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80039c2:	687b      	ldr	r3, [r7, #4]
 80039c4:	685b      	ldr	r3, [r3, #4]
 80039c6:	2b03      	cmp	r3, #3
 80039c8:	d107      	bne.n	80039da <HAL_RCC_ClockConfig+0xba>
    {
      /* Check the PLL ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 80039ca:	4b73      	ldr	r3, [pc, #460]	; (8003b98 <HAL_RCC_ClockConfig+0x278>)
 80039cc:	681a      	ldr	r2, [r3, #0]
 80039ce:	2380      	movs	r3, #128	; 0x80
 80039d0:	049b      	lsls	r3, r3, #18
 80039d2:	4013      	ands	r3, r2
 80039d4:	d114      	bne.n	8003a00 <HAL_RCC_ClockConfig+0xe0>
      {
        return HAL_ERROR;
 80039d6:	2301      	movs	r3, #1
 80039d8:	e0d5      	b.n	8003b86 <HAL_RCC_ClockConfig+0x266>
      }
    }
    /* HSI is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
 80039da:	687b      	ldr	r3, [r7, #4]
 80039dc:	685b      	ldr	r3, [r3, #4]
 80039de:	2b01      	cmp	r3, #1
 80039e0:	d106      	bne.n	80039f0 <HAL_RCC_ClockConfig+0xd0>
    {
      /* Check the HSI ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 80039e2:	4b6d      	ldr	r3, [pc, #436]	; (8003b98 <HAL_RCC_ClockConfig+0x278>)
 80039e4:	681b      	ldr	r3, [r3, #0]
 80039e6:	2204      	movs	r2, #4
 80039e8:	4013      	ands	r3, r2
 80039ea:	d109      	bne.n	8003a00 <HAL_RCC_ClockConfig+0xe0>
      {
        return HAL_ERROR;
 80039ec:	2301      	movs	r3, #1
 80039ee:	e0ca      	b.n	8003b86 <HAL_RCC_ClockConfig+0x266>
    }
    /* MSI is selected as System Clock Source */
    else
    {
      /* Check the MSI ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == 0U)
 80039f0:	4b69      	ldr	r3, [pc, #420]	; (8003b98 <HAL_RCC_ClockConfig+0x278>)
 80039f2:	681a      	ldr	r2, [r3, #0]
 80039f4:	2380      	movs	r3, #128	; 0x80
 80039f6:	009b      	lsls	r3, r3, #2
 80039f8:	4013      	ands	r3, r2
 80039fa:	d101      	bne.n	8003a00 <HAL_RCC_ClockConfig+0xe0>
      {
        return HAL_ERROR;
 80039fc:	2301      	movs	r3, #1
 80039fe:	e0c2      	b.n	8003b86 <HAL_RCC_ClockConfig+0x266>
      }
    }
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8003a00:	4b65      	ldr	r3, [pc, #404]	; (8003b98 <HAL_RCC_ClockConfig+0x278>)
 8003a02:	68db      	ldr	r3, [r3, #12]
 8003a04:	2203      	movs	r2, #3
 8003a06:	4393      	bics	r3, r2
 8003a08:	0019      	movs	r1, r3
 8003a0a:	687b      	ldr	r3, [r7, #4]
 8003a0c:	685a      	ldr	r2, [r3, #4]
 8003a0e:	4b62      	ldr	r3, [pc, #392]	; (8003b98 <HAL_RCC_ClockConfig+0x278>)
 8003a10:	430a      	orrs	r2, r1
 8003a12:	60da      	str	r2, [r3, #12]

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 8003a14:	f7ff f8d8 	bl	8002bc8 <HAL_GetTick>
 8003a18:	0003      	movs	r3, r0
 8003a1a:	60fb      	str	r3, [r7, #12]

    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8003a1c:	687b      	ldr	r3, [r7, #4]
 8003a1e:	685b      	ldr	r3, [r3, #4]
 8003a20:	2b02      	cmp	r3, #2
 8003a22:	d111      	bne.n	8003a48 <HAL_RCC_ClockConfig+0x128>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8003a24:	e009      	b.n	8003a3a <HAL_RCC_ClockConfig+0x11a>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8003a26:	f7ff f8cf 	bl	8002bc8 <HAL_GetTick>
 8003a2a:	0002      	movs	r2, r0
 8003a2c:	68fb      	ldr	r3, [r7, #12]
 8003a2e:	1ad3      	subs	r3, r2, r3
 8003a30:	4a58      	ldr	r2, [pc, #352]	; (8003b94 <HAL_RCC_ClockConfig+0x274>)
 8003a32:	4293      	cmp	r3, r2
 8003a34:	d901      	bls.n	8003a3a <HAL_RCC_ClockConfig+0x11a>
        {
          return HAL_TIMEOUT;
 8003a36:	2303      	movs	r3, #3
 8003a38:	e0a5      	b.n	8003b86 <HAL_RCC_ClockConfig+0x266>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8003a3a:	4b57      	ldr	r3, [pc, #348]	; (8003b98 <HAL_RCC_ClockConfig+0x278>)
 8003a3c:	68db      	ldr	r3, [r3, #12]
 8003a3e:	220c      	movs	r2, #12
 8003a40:	4013      	ands	r3, r2
 8003a42:	2b08      	cmp	r3, #8
 8003a44:	d1ef      	bne.n	8003a26 <HAL_RCC_ClockConfig+0x106>
 8003a46:	e03a      	b.n	8003abe <HAL_RCC_ClockConfig+0x19e>
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8003a48:	687b      	ldr	r3, [r7, #4]
 8003a4a:	685b      	ldr	r3, [r3, #4]
 8003a4c:	2b03      	cmp	r3, #3
 8003a4e:	d111      	bne.n	8003a74 <HAL_RCC_ClockConfig+0x154>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8003a50:	e009      	b.n	8003a66 <HAL_RCC_ClockConfig+0x146>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8003a52:	f7ff f8b9 	bl	8002bc8 <HAL_GetTick>
 8003a56:	0002      	movs	r2, r0
 8003a58:	68fb      	ldr	r3, [r7, #12]
 8003a5a:	1ad3      	subs	r3, r2, r3
 8003a5c:	4a4d      	ldr	r2, [pc, #308]	; (8003b94 <HAL_RCC_ClockConfig+0x274>)
 8003a5e:	4293      	cmp	r3, r2
 8003a60:	d901      	bls.n	8003a66 <HAL_RCC_ClockConfig+0x146>
        {
          return HAL_TIMEOUT;
 8003a62:	2303      	movs	r3, #3
 8003a64:	e08f      	b.n	8003b86 <HAL_RCC_ClockConfig+0x266>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8003a66:	4b4c      	ldr	r3, [pc, #304]	; (8003b98 <HAL_RCC_ClockConfig+0x278>)
 8003a68:	68db      	ldr	r3, [r3, #12]
 8003a6a:	220c      	movs	r2, #12
 8003a6c:	4013      	ands	r3, r2
 8003a6e:	2b0c      	cmp	r3, #12
 8003a70:	d1ef      	bne.n	8003a52 <HAL_RCC_ClockConfig+0x132>
 8003a72:	e024      	b.n	8003abe <HAL_RCC_ClockConfig+0x19e>
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
 8003a74:	687b      	ldr	r3, [r7, #4]
 8003a76:	685b      	ldr	r3, [r3, #4]
 8003a78:	2b01      	cmp	r3, #1
 8003a7a:	d11b      	bne.n	8003ab4 <HAL_RCC_ClockConfig+0x194>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 8003a7c:	e009      	b.n	8003a92 <HAL_RCC_ClockConfig+0x172>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8003a7e:	f7ff f8a3 	bl	8002bc8 <HAL_GetTick>
 8003a82:	0002      	movs	r2, r0
 8003a84:	68fb      	ldr	r3, [r7, #12]
 8003a86:	1ad3      	subs	r3, r2, r3
 8003a88:	4a42      	ldr	r2, [pc, #264]	; (8003b94 <HAL_RCC_ClockConfig+0x274>)
 8003a8a:	4293      	cmp	r3, r2
 8003a8c:	d901      	bls.n	8003a92 <HAL_RCC_ClockConfig+0x172>
        {
          return HAL_TIMEOUT;
 8003a8e:	2303      	movs	r3, #3
 8003a90:	e079      	b.n	8003b86 <HAL_RCC_ClockConfig+0x266>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 8003a92:	4b41      	ldr	r3, [pc, #260]	; (8003b98 <HAL_RCC_ClockConfig+0x278>)
 8003a94:	68db      	ldr	r3, [r3, #12]
 8003a96:	220c      	movs	r2, #12
 8003a98:	4013      	ands	r3, r2
 8003a9a:	2b04      	cmp	r3, #4
 8003a9c:	d1ef      	bne.n	8003a7e <HAL_RCC_ClockConfig+0x15e>
 8003a9e:	e00e      	b.n	8003abe <HAL_RCC_ClockConfig+0x19e>
    }
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8003aa0:	f7ff f892 	bl	8002bc8 <HAL_GetTick>
 8003aa4:	0002      	movs	r2, r0
 8003aa6:	68fb      	ldr	r3, [r7, #12]
 8003aa8:	1ad3      	subs	r3, r2, r3
 8003aaa:	4a3a      	ldr	r2, [pc, #232]	; (8003b94 <HAL_RCC_ClockConfig+0x274>)
 8003aac:	4293      	cmp	r3, r2
 8003aae:	d901      	bls.n	8003ab4 <HAL_RCC_ClockConfig+0x194>
        {
          return HAL_TIMEOUT;
 8003ab0:	2303      	movs	r3, #3
 8003ab2:	e068      	b.n	8003b86 <HAL_RCC_ClockConfig+0x266>
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
 8003ab4:	4b38      	ldr	r3, [pc, #224]	; (8003b98 <HAL_RCC_ClockConfig+0x278>)
 8003ab6:	68db      	ldr	r3, [r3, #12]
 8003ab8:	220c      	movs	r2, #12
 8003aba:	4013      	ands	r3, r2
 8003abc:	d1f0      	bne.n	8003aa0 <HAL_RCC_ClockConfig+0x180>
        }
      }
    }
  }
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8003abe:	4b34      	ldr	r3, [pc, #208]	; (8003b90 <HAL_RCC_ClockConfig+0x270>)
 8003ac0:	681b      	ldr	r3, [r3, #0]
 8003ac2:	2201      	movs	r2, #1
 8003ac4:	4013      	ands	r3, r2
 8003ac6:	683a      	ldr	r2, [r7, #0]
 8003ac8:	429a      	cmp	r2, r3
 8003aca:	d21e      	bcs.n	8003b0a <HAL_RCC_ClockConfig+0x1ea>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8003acc:	4b30      	ldr	r3, [pc, #192]	; (8003b90 <HAL_RCC_ClockConfig+0x270>)
 8003ace:	681b      	ldr	r3, [r3, #0]
 8003ad0:	2201      	movs	r2, #1
 8003ad2:	4393      	bics	r3, r2
 8003ad4:	0019      	movs	r1, r3
 8003ad6:	4b2e      	ldr	r3, [pc, #184]	; (8003b90 <HAL_RCC_ClockConfig+0x270>)
 8003ad8:	683a      	ldr	r2, [r7, #0]
 8003ada:	430a      	orrs	r2, r1
 8003adc:	601a      	str	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by polling the FLASH_ACR register */
    tickstart = HAL_GetTick();
 8003ade:	f7ff f873 	bl	8002bc8 <HAL_GetTick>
 8003ae2:	0003      	movs	r3, r0
 8003ae4:	60fb      	str	r3, [r7, #12]

    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 8003ae6:	e009      	b.n	8003afc <HAL_RCC_ClockConfig+0x1dc>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8003ae8:	f7ff f86e 	bl	8002bc8 <HAL_GetTick>
 8003aec:	0002      	movs	r2, r0
 8003aee:	68fb      	ldr	r3, [r7, #12]
 8003af0:	1ad3      	subs	r3, r2, r3
 8003af2:	4a28      	ldr	r2, [pc, #160]	; (8003b94 <HAL_RCC_ClockConfig+0x274>)
 8003af4:	4293      	cmp	r3, r2
 8003af6:	d901      	bls.n	8003afc <HAL_RCC_ClockConfig+0x1dc>
      {
        return HAL_TIMEOUT;
 8003af8:	2303      	movs	r3, #3
 8003afa:	e044      	b.n	8003b86 <HAL_RCC_ClockConfig+0x266>
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 8003afc:	4b24      	ldr	r3, [pc, #144]	; (8003b90 <HAL_RCC_ClockConfig+0x270>)
 8003afe:	681b      	ldr	r3, [r3, #0]
 8003b00:	2201      	movs	r2, #1
 8003b02:	4013      	ands	r3, r2
 8003b04:	683a      	ldr	r2, [r7, #0]
 8003b06:	429a      	cmp	r2, r3
 8003b08:	d1ee      	bne.n	8003ae8 <HAL_RCC_ClockConfig+0x1c8>
      }
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8003b0a:	687b      	ldr	r3, [r7, #4]
 8003b0c:	681b      	ldr	r3, [r3, #0]
 8003b0e:	2204      	movs	r2, #4
 8003b10:	4013      	ands	r3, r2
 8003b12:	d009      	beq.n	8003b28 <HAL_RCC_ClockConfig+0x208>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8003b14:	4b20      	ldr	r3, [pc, #128]	; (8003b98 <HAL_RCC_ClockConfig+0x278>)
 8003b16:	68db      	ldr	r3, [r3, #12]
 8003b18:	4a20      	ldr	r2, [pc, #128]	; (8003b9c <HAL_RCC_ClockConfig+0x27c>)
 8003b1a:	4013      	ands	r3, r2
 8003b1c:	0019      	movs	r1, r3
 8003b1e:	687b      	ldr	r3, [r7, #4]
 8003b20:	68da      	ldr	r2, [r3, #12]
 8003b22:	4b1d      	ldr	r3, [pc, #116]	; (8003b98 <HAL_RCC_ClockConfig+0x278>)
 8003b24:	430a      	orrs	r2, r1
 8003b26:	60da      	str	r2, [r3, #12]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8003b28:	687b      	ldr	r3, [r7, #4]
 8003b2a:	681b      	ldr	r3, [r3, #0]
 8003b2c:	2208      	movs	r2, #8
 8003b2e:	4013      	ands	r3, r2
 8003b30:	d00a      	beq.n	8003b48 <HAL_RCC_ClockConfig+0x228>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8003b32:	4b19      	ldr	r3, [pc, #100]	; (8003b98 <HAL_RCC_ClockConfig+0x278>)
 8003b34:	68db      	ldr	r3, [r3, #12]
 8003b36:	4a1a      	ldr	r2, [pc, #104]	; (8003ba0 <HAL_RCC_ClockConfig+0x280>)
 8003b38:	4013      	ands	r3, r2
 8003b3a:	0019      	movs	r1, r3
 8003b3c:	687b      	ldr	r3, [r7, #4]
 8003b3e:	691b      	ldr	r3, [r3, #16]
 8003b40:	00da      	lsls	r2, r3, #3
 8003b42:	4b15      	ldr	r3, [pc, #84]	; (8003b98 <HAL_RCC_ClockConfig+0x278>)
 8003b44:	430a      	orrs	r2, r1
 8003b46:	60da      	str	r2, [r3, #12]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 8003b48:	f000 f832 	bl	8003bb0 <HAL_RCC_GetSysClockFreq>
 8003b4c:	0001      	movs	r1, r0
 8003b4e:	4b12      	ldr	r3, [pc, #72]	; (8003b98 <HAL_RCC_ClockConfig+0x278>)
 8003b50:	68db      	ldr	r3, [r3, #12]
 8003b52:	091b      	lsrs	r3, r3, #4
 8003b54:	220f      	movs	r2, #15
 8003b56:	4013      	ands	r3, r2
 8003b58:	4a12      	ldr	r2, [pc, #72]	; (8003ba4 <HAL_RCC_ClockConfig+0x284>)
 8003b5a:	5cd3      	ldrb	r3, [r2, r3]
 8003b5c:	000a      	movs	r2, r1
 8003b5e:	40da      	lsrs	r2, r3
 8003b60:	4b11      	ldr	r3, [pc, #68]	; (8003ba8 <HAL_RCC_ClockConfig+0x288>)
 8003b62:	601a      	str	r2, [r3, #0]

  /* Configure the source of time base considering new system clocks settings*/
  status = HAL_InitTick(uwTickPrio);
 8003b64:	4b11      	ldr	r3, [pc, #68]	; (8003bac <HAL_RCC_ClockConfig+0x28c>)
 8003b66:	681b      	ldr	r3, [r3, #0]
 8003b68:	250b      	movs	r5, #11
 8003b6a:	197c      	adds	r4, r7, r5
 8003b6c:	0018      	movs	r0, r3
 8003b6e:	f7fe ffe5 	bl	8002b3c <HAL_InitTick>
 8003b72:	0003      	movs	r3, r0
 8003b74:	7023      	strb	r3, [r4, #0]
  if(status != HAL_OK)
 8003b76:	197b      	adds	r3, r7, r5
 8003b78:	781b      	ldrb	r3, [r3, #0]
 8003b7a:	2b00      	cmp	r3, #0
 8003b7c:	d002      	beq.n	8003b84 <HAL_RCC_ClockConfig+0x264>
  {
    return status;
 8003b7e:	197b      	adds	r3, r7, r5
 8003b80:	781b      	ldrb	r3, [r3, #0]
 8003b82:	e000      	b.n	8003b86 <HAL_RCC_ClockConfig+0x266>
  }

  return HAL_OK;
 8003b84:	2300      	movs	r3, #0
}
 8003b86:	0018      	movs	r0, r3
 8003b88:	46bd      	mov	sp, r7
 8003b8a:	b004      	add	sp, #16
 8003b8c:	bdb0      	pop	{r4, r5, r7, pc}
 8003b8e:	46c0      	nop			; (mov r8, r8)
 8003b90:	40022000 	.word	0x40022000
 8003b94:	00001388 	.word	0x00001388
 8003b98:	40021000 	.word	0x40021000
 8003b9c:	fffff8ff 	.word	0xfffff8ff
 8003ba0:	ffffc7ff 	.word	0xffffc7ff
 8003ba4:	08021d34 	.word	0x08021d34
 8003ba8:	20000010 	.word	0x20000010
 8003bac:	20000014 	.word	0x20000014

08003bb0 <HAL_RCC_GetSysClockFreq>:
  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8003bb0:	b5b0      	push	{r4, r5, r7, lr}
 8003bb2:	b08e      	sub	sp, #56	; 0x38
 8003bb4:	af00      	add	r7, sp, #0
  uint32_t tmpreg, pllm, plld, pllvco, msiclkrange;    /* no init needed */
  uint32_t sysclockfreq;

  tmpreg = RCC->CFGR;
 8003bb6:	4b4c      	ldr	r3, [pc, #304]	; (8003ce8 <HAL_RCC_GetSysClockFreq+0x138>)
 8003bb8:	68db      	ldr	r3, [r3, #12]
 8003bba:	62fb      	str	r3, [r7, #44]	; 0x2c

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
 8003bbc:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8003bbe:	230c      	movs	r3, #12
 8003bc0:	4013      	ands	r3, r2
 8003bc2:	2b0c      	cmp	r3, #12
 8003bc4:	d014      	beq.n	8003bf0 <HAL_RCC_GetSysClockFreq+0x40>
 8003bc6:	d900      	bls.n	8003bca <HAL_RCC_GetSysClockFreq+0x1a>
 8003bc8:	e07b      	b.n	8003cc2 <HAL_RCC_GetSysClockFreq+0x112>
 8003bca:	2b04      	cmp	r3, #4
 8003bcc:	d002      	beq.n	8003bd4 <HAL_RCC_GetSysClockFreq+0x24>
 8003bce:	2b08      	cmp	r3, #8
 8003bd0:	d00b      	beq.n	8003bea <HAL_RCC_GetSysClockFreq+0x3a>
 8003bd2:	e076      	b.n	8003cc2 <HAL_RCC_GetSysClockFreq+0x112>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    {
      if ((RCC->CR & RCC_CR_HSIDIVF) != 0U)
 8003bd4:	4b44      	ldr	r3, [pc, #272]	; (8003ce8 <HAL_RCC_GetSysClockFreq+0x138>)
 8003bd6:	681b      	ldr	r3, [r3, #0]
 8003bd8:	2210      	movs	r2, #16
 8003bda:	4013      	ands	r3, r2
 8003bdc:	d002      	beq.n	8003be4 <HAL_RCC_GetSysClockFreq+0x34>
      {
        sysclockfreq =  (HSI_VALUE >> 2);
 8003bde:	4b43      	ldr	r3, [pc, #268]	; (8003cec <HAL_RCC_GetSysClockFreq+0x13c>)
 8003be0:	633b      	str	r3, [r7, #48]	; 0x30
      }
      else
      {
        sysclockfreq =  HSI_VALUE;
      }
      break;
 8003be2:	e07c      	b.n	8003cde <HAL_RCC_GetSysClockFreq+0x12e>
        sysclockfreq =  HSI_VALUE;
 8003be4:	4b42      	ldr	r3, [pc, #264]	; (8003cf0 <HAL_RCC_GetSysClockFreq+0x140>)
 8003be6:	633b      	str	r3, [r7, #48]	; 0x30
      break;
 8003be8:	e079      	b.n	8003cde <HAL_RCC_GetSysClockFreq+0x12e>
    }
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
    {
      sysclockfreq = HSE_VALUE;
 8003bea:	4b42      	ldr	r3, [pc, #264]	; (8003cf4 <HAL_RCC_GetSysClockFreq+0x144>)
 8003bec:	633b      	str	r3, [r7, #48]	; 0x30
      break;
 8003bee:	e076      	b.n	8003cde <HAL_RCC_GetSysClockFreq+0x12e>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
    {
      pllm = PLLMulTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_Pos];
 8003bf0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003bf2:	0c9a      	lsrs	r2, r3, #18
 8003bf4:	230f      	movs	r3, #15
 8003bf6:	401a      	ands	r2, r3
 8003bf8:	4b3f      	ldr	r3, [pc, #252]	; (8003cf8 <HAL_RCC_GetSysClockFreq+0x148>)
 8003bfa:	5c9b      	ldrb	r3, [r3, r2]
 8003bfc:	62bb      	str	r3, [r7, #40]	; 0x28
      plld = ((uint32_t)(tmpreg & RCC_CFGR_PLLDIV) >> RCC_CFGR_PLLDIV_Pos) + 1U;
 8003bfe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003c00:	0d9a      	lsrs	r2, r3, #22
 8003c02:	2303      	movs	r3, #3
 8003c04:	4013      	ands	r3, r2
 8003c06:	3301      	adds	r3, #1
 8003c08:	627b      	str	r3, [r7, #36]	; 0x24
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8003c0a:	4b37      	ldr	r3, [pc, #220]	; (8003ce8 <HAL_RCC_GetSysClockFreq+0x138>)
 8003c0c:	68da      	ldr	r2, [r3, #12]
 8003c0e:	2380      	movs	r3, #128	; 0x80
 8003c10:	025b      	lsls	r3, r3, #9
 8003c12:	4013      	ands	r3, r2
 8003c14:	d01a      	beq.n	8003c4c <HAL_RCC_GetSysClockFreq+0x9c>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t)(((uint64_t)HSE_VALUE * (uint64_t)pllm) / (uint64_t)plld);
 8003c16:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003c18:	61bb      	str	r3, [r7, #24]
 8003c1a:	2300      	movs	r3, #0
 8003c1c:	61fb      	str	r3, [r7, #28]
 8003c1e:	4a35      	ldr	r2, [pc, #212]	; (8003cf4 <HAL_RCC_GetSysClockFreq+0x144>)
 8003c20:	2300      	movs	r3, #0
 8003c22:	69b8      	ldr	r0, [r7, #24]
 8003c24:	69f9      	ldr	r1, [r7, #28]
 8003c26:	f7fc fb2d 	bl	8000284 <__aeabi_lmul>
 8003c2a:	0002      	movs	r2, r0
 8003c2c:	000b      	movs	r3, r1
 8003c2e:	0010      	movs	r0, r2
 8003c30:	0019      	movs	r1, r3
 8003c32:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003c34:	613b      	str	r3, [r7, #16]
 8003c36:	2300      	movs	r3, #0
 8003c38:	617b      	str	r3, [r7, #20]
 8003c3a:	693a      	ldr	r2, [r7, #16]
 8003c3c:	697b      	ldr	r3, [r7, #20]
 8003c3e:	f7fc fb01 	bl	8000244 <__aeabi_uldivmod>
 8003c42:	0002      	movs	r2, r0
 8003c44:	000b      	movs	r3, r1
 8003c46:	0013      	movs	r3, r2
 8003c48:	637b      	str	r3, [r7, #52]	; 0x34
 8003c4a:	e037      	b.n	8003cbc <HAL_RCC_GetSysClockFreq+0x10c>
      }
      else
      {
        if ((RCC->CR & RCC_CR_HSIDIVF) != 0U)
 8003c4c:	4b26      	ldr	r3, [pc, #152]	; (8003ce8 <HAL_RCC_GetSysClockFreq+0x138>)
 8003c4e:	681b      	ldr	r3, [r3, #0]
 8003c50:	2210      	movs	r2, #16
 8003c52:	4013      	ands	r3, r2
 8003c54:	d01a      	beq.n	8003c8c <HAL_RCC_GetSysClockFreq+0xdc>
        {
          pllvco = (uint32_t)((((uint64_t)(HSI_VALUE >> 2)) * (uint64_t)pllm) / (uint64_t)plld);
 8003c56:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003c58:	60bb      	str	r3, [r7, #8]
 8003c5a:	2300      	movs	r3, #0
 8003c5c:	60fb      	str	r3, [r7, #12]
 8003c5e:	4a23      	ldr	r2, [pc, #140]	; (8003cec <HAL_RCC_GetSysClockFreq+0x13c>)
 8003c60:	2300      	movs	r3, #0
 8003c62:	68b8      	ldr	r0, [r7, #8]
 8003c64:	68f9      	ldr	r1, [r7, #12]
 8003c66:	f7fc fb0d 	bl	8000284 <__aeabi_lmul>
 8003c6a:	0002      	movs	r2, r0
 8003c6c:	000b      	movs	r3, r1
 8003c6e:	0010      	movs	r0, r2
 8003c70:	0019      	movs	r1, r3
 8003c72:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003c74:	603b      	str	r3, [r7, #0]
 8003c76:	2300      	movs	r3, #0
 8003c78:	607b      	str	r3, [r7, #4]
 8003c7a:	683a      	ldr	r2, [r7, #0]
 8003c7c:	687b      	ldr	r3, [r7, #4]
 8003c7e:	f7fc fae1 	bl	8000244 <__aeabi_uldivmod>
 8003c82:	0002      	movs	r2, r0
 8003c84:	000b      	movs	r3, r1
 8003c86:	0013      	movs	r3, r2
 8003c88:	637b      	str	r3, [r7, #52]	; 0x34
 8003c8a:	e017      	b.n	8003cbc <HAL_RCC_GetSysClockFreq+0x10c>
        }
        else
        {
         pllvco = (uint32_t)(((uint64_t)HSI_VALUE * (uint64_t)pllm) / (uint64_t)plld);
 8003c8c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003c8e:	0018      	movs	r0, r3
 8003c90:	2300      	movs	r3, #0
 8003c92:	0019      	movs	r1, r3
 8003c94:	4a16      	ldr	r2, [pc, #88]	; (8003cf0 <HAL_RCC_GetSysClockFreq+0x140>)
 8003c96:	2300      	movs	r3, #0
 8003c98:	f7fc faf4 	bl	8000284 <__aeabi_lmul>
 8003c9c:	0002      	movs	r2, r0
 8003c9e:	000b      	movs	r3, r1
 8003ca0:	0010      	movs	r0, r2
 8003ca2:	0019      	movs	r1, r3
 8003ca4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003ca6:	001c      	movs	r4, r3
 8003ca8:	2300      	movs	r3, #0
 8003caa:	001d      	movs	r5, r3
 8003cac:	0022      	movs	r2, r4
 8003cae:	002b      	movs	r3, r5
 8003cb0:	f7fc fac8 	bl	8000244 <__aeabi_uldivmod>
 8003cb4:	0002      	movs	r2, r0
 8003cb6:	000b      	movs	r3, r1
 8003cb8:	0013      	movs	r3, r2
 8003cba:	637b      	str	r3, [r7, #52]	; 0x34
        }
      }
      sysclockfreq = pllvco;
 8003cbc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003cbe:	633b      	str	r3, [r7, #48]	; 0x30
      break;
 8003cc0:	e00d      	b.n	8003cde <HAL_RCC_GetSysClockFreq+0x12e>
    }
    case RCC_SYSCLKSOURCE_STATUS_MSI:  /* MSI used as system clock source */
    default: /* MSI used as system clock */
    {
      msiclkrange = (RCC->ICSCR & RCC_ICSCR_MSIRANGE ) >> RCC_ICSCR_MSIRANGE_Pos;
 8003cc2:	4b09      	ldr	r3, [pc, #36]	; (8003ce8 <HAL_RCC_GetSysClockFreq+0x138>)
 8003cc4:	685b      	ldr	r3, [r3, #4]
 8003cc6:	0b5b      	lsrs	r3, r3, #13
 8003cc8:	2207      	movs	r2, #7
 8003cca:	4013      	ands	r3, r2
 8003ccc:	623b      	str	r3, [r7, #32]
      sysclockfreq = (32768U * (1UL << (msiclkrange + 1U)));
 8003cce:	6a3b      	ldr	r3, [r7, #32]
 8003cd0:	3301      	adds	r3, #1
 8003cd2:	2280      	movs	r2, #128	; 0x80
 8003cd4:	0212      	lsls	r2, r2, #8
 8003cd6:	409a      	lsls	r2, r3
 8003cd8:	0013      	movs	r3, r2
 8003cda:	633b      	str	r3, [r7, #48]	; 0x30
      break;
 8003cdc:	46c0      	nop			; (mov r8, r8)
    }
  }
  return sysclockfreq;
 8003cde:	6b3b      	ldr	r3, [r7, #48]	; 0x30
}
 8003ce0:	0018      	movs	r0, r3
 8003ce2:	46bd      	mov	sp, r7
 8003ce4:	b00e      	add	sp, #56	; 0x38
 8003ce6:	bdb0      	pop	{r4, r5, r7, pc}
 8003ce8:	40021000 	.word	0x40021000
 8003cec:	003d0900 	.word	0x003d0900
 8003cf0:	00f42400 	.word	0x00f42400
 8003cf4:	007a1200 	.word	0x007a1200
 8003cf8:	08021d4c 	.word	0x08021d4c

08003cfc <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8003cfc:	b580      	push	{r7, lr}
 8003cfe:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 8003d00:	4b02      	ldr	r3, [pc, #8]	; (8003d0c <HAL_RCC_GetHCLKFreq+0x10>)
 8003d02:	681b      	ldr	r3, [r3, #0]
}
 8003d04:	0018      	movs	r0, r3
 8003d06:	46bd      	mov	sp, r7
 8003d08:	bd80      	pop	{r7, pc}
 8003d0a:	46c0      	nop			; (mov r8, r8)
 8003d0c:	20000010 	.word	0x20000010

08003d10 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 8003d10:	b580      	push	{r7, lr}
 8003d12:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 8003d14:	f7ff fff2 	bl	8003cfc <HAL_RCC_GetHCLKFreq>
 8003d18:	0001      	movs	r1, r0
 8003d1a:	4b06      	ldr	r3, [pc, #24]	; (8003d34 <HAL_RCC_GetPCLK1Freq+0x24>)
 8003d1c:	68db      	ldr	r3, [r3, #12]
 8003d1e:	0a1b      	lsrs	r3, r3, #8
 8003d20:	2207      	movs	r2, #7
 8003d22:	4013      	ands	r3, r2
 8003d24:	4a04      	ldr	r2, [pc, #16]	; (8003d38 <HAL_RCC_GetPCLK1Freq+0x28>)
 8003d26:	5cd3      	ldrb	r3, [r2, r3]
 8003d28:	40d9      	lsrs	r1, r3
 8003d2a:	000b      	movs	r3, r1
}
 8003d2c:	0018      	movs	r0, r3
 8003d2e:	46bd      	mov	sp, r7
 8003d30:	bd80      	pop	{r7, pc}
 8003d32:	46c0      	nop			; (mov r8, r8)
 8003d34:	40021000 	.word	0x40021000
 8003d38:	08021d44 	.word	0x08021d44

08003d3c <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 8003d3c:	b580      	push	{r7, lr}
 8003d3e:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 8003d40:	f7ff ffdc 	bl	8003cfc <HAL_RCC_GetHCLKFreq>
 8003d44:	0001      	movs	r1, r0
 8003d46:	4b06      	ldr	r3, [pc, #24]	; (8003d60 <HAL_RCC_GetPCLK2Freq+0x24>)
 8003d48:	68db      	ldr	r3, [r3, #12]
 8003d4a:	0adb      	lsrs	r3, r3, #11
 8003d4c:	2207      	movs	r2, #7
 8003d4e:	4013      	ands	r3, r2
 8003d50:	4a04      	ldr	r2, [pc, #16]	; (8003d64 <HAL_RCC_GetPCLK2Freq+0x28>)
 8003d52:	5cd3      	ldrb	r3, [r2, r3]
 8003d54:	40d9      	lsrs	r1, r3
 8003d56:	000b      	movs	r3, r1
}
 8003d58:	0018      	movs	r0, r3
 8003d5a:	46bd      	mov	sp, r7
 8003d5c:	bd80      	pop	{r7, pc}
 8003d5e:	46c0      	nop			; (mov r8, r8)
 8003d60:	40021000 	.word	0x40021000
 8003d64:	08021d44 	.word	0x08021d44

08003d68 <HAL_RCCEx_PeriphCLKConfig>:
  * @retval HAL status
  * @note   If HAL_ERROR returned, first switch-OFF HSE clock oscillator with @ref HAL_RCC_OscConfig()
  *         to possibly update HSE divider.
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8003d68:	b580      	push	{r7, lr}
 8003d6a:	b086      	sub	sp, #24
 8003d6c:	af00      	add	r7, sp, #0
 8003d6e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  uint32_t temp_reg;
  FlagStatus       pwrclkchanged = RESET;
 8003d70:	2017      	movs	r0, #23
 8003d72:	183b      	adds	r3, r7, r0
 8003d74:	2200      	movs	r2, #0
 8003d76:	701a      	strb	r2, [r3, #0]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*------------------------------- RTC/LCD Configuration ------------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8003d78:	687b      	ldr	r3, [r7, #4]
 8003d7a:	681b      	ldr	r3, [r3, #0]
 8003d7c:	2220      	movs	r2, #32
 8003d7e:	4013      	ands	r3, r2
 8003d80:	d100      	bne.n	8003d84 <HAL_RCCEx_PeriphCLKConfig+0x1c>
 8003d82:	e0c2      	b.n	8003f0a <HAL_RCCEx_PeriphCLKConfig+0x1a2>
#endif /* LCD */

    /* As soon as function is called to change RTC clock source, activation of the
       power domain is done. */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8003d84:	4b91      	ldr	r3, [pc, #580]	; (8003fcc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003d86:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8003d88:	2380      	movs	r3, #128	; 0x80
 8003d8a:	055b      	lsls	r3, r3, #21
 8003d8c:	4013      	ands	r3, r2
 8003d8e:	d109      	bne.n	8003da4 <HAL_RCCEx_PeriphCLKConfig+0x3c>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8003d90:	4b8e      	ldr	r3, [pc, #568]	; (8003fcc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003d92:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8003d94:	4b8d      	ldr	r3, [pc, #564]	; (8003fcc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003d96:	2180      	movs	r1, #128	; 0x80
 8003d98:	0549      	lsls	r1, r1, #21
 8003d9a:	430a      	orrs	r2, r1
 8003d9c:	639a      	str	r2, [r3, #56]	; 0x38
      pwrclkchanged = SET;
 8003d9e:	183b      	adds	r3, r7, r0
 8003da0:	2201      	movs	r2, #1
 8003da2:	701a      	strb	r2, [r3, #0]
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8003da4:	4b8a      	ldr	r3, [pc, #552]	; (8003fd0 <HAL_RCCEx_PeriphCLKConfig+0x268>)
 8003da6:	681a      	ldr	r2, [r3, #0]
 8003da8:	2380      	movs	r3, #128	; 0x80
 8003daa:	005b      	lsls	r3, r3, #1
 8003dac:	4013      	ands	r3, r2
 8003dae:	d11a      	bne.n	8003de6 <HAL_RCCEx_PeriphCLKConfig+0x7e>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8003db0:	4b87      	ldr	r3, [pc, #540]	; (8003fd0 <HAL_RCCEx_PeriphCLKConfig+0x268>)
 8003db2:	681a      	ldr	r2, [r3, #0]
 8003db4:	4b86      	ldr	r3, [pc, #536]	; (8003fd0 <HAL_RCCEx_PeriphCLKConfig+0x268>)
 8003db6:	2180      	movs	r1, #128	; 0x80
 8003db8:	0049      	lsls	r1, r1, #1
 8003dba:	430a      	orrs	r2, r1
 8003dbc:	601a      	str	r2, [r3, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8003dbe:	f7fe ff03 	bl	8002bc8 <HAL_GetTick>
 8003dc2:	0003      	movs	r3, r0
 8003dc4:	613b      	str	r3, [r7, #16]

      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8003dc6:	e008      	b.n	8003dda <HAL_RCCEx_PeriphCLKConfig+0x72>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8003dc8:	f7fe fefe 	bl	8002bc8 <HAL_GetTick>
 8003dcc:	0002      	movs	r2, r0
 8003dce:	693b      	ldr	r3, [r7, #16]
 8003dd0:	1ad3      	subs	r3, r2, r3
 8003dd2:	2b64      	cmp	r3, #100	; 0x64
 8003dd4:	d901      	bls.n	8003dda <HAL_RCCEx_PeriphCLKConfig+0x72>
        {
          return HAL_TIMEOUT;
 8003dd6:	2303      	movs	r3, #3
 8003dd8:	e0f3      	b.n	8003fc2 <HAL_RCCEx_PeriphCLKConfig+0x25a>
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8003dda:	4b7d      	ldr	r3, [pc, #500]	; (8003fd0 <HAL_RCCEx_PeriphCLKConfig+0x268>)
 8003ddc:	681a      	ldr	r2, [r3, #0]
 8003dde:	2380      	movs	r3, #128	; 0x80
 8003de0:	005b      	lsls	r3, r3, #1
 8003de2:	4013      	ands	r3, r2
 8003de4:	d0f0      	beq.n	8003dc8 <HAL_RCCEx_PeriphCLKConfig+0x60>
        }
      }
    }

    /* Check if user wants to change HSE RTC prescaler whereas HSE is enabled */
    temp_reg = (RCC->CR & RCC_CR_RTCPRE);
 8003de6:	4b79      	ldr	r3, [pc, #484]	; (8003fcc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003de8:	681a      	ldr	r2, [r3, #0]
 8003dea:	23c0      	movs	r3, #192	; 0xc0
 8003dec:	039b      	lsls	r3, r3, #14
 8003dee:	4013      	ands	r3, r2
 8003df0:	60fb      	str	r3, [r7, #12]
    if ((temp_reg != (PeriphClkInit->RTCClockSelection & RCC_CR_RTCPRE))
 8003df2:	687b      	ldr	r3, [r7, #4]
 8003df4:	685a      	ldr	r2, [r3, #4]
 8003df6:	23c0      	movs	r3, #192	; 0xc0
 8003df8:	039b      	lsls	r3, r3, #14
 8003dfa:	4013      	ands	r3, r2
 8003dfc:	68fa      	ldr	r2, [r7, #12]
 8003dfe:	429a      	cmp	r2, r3
 8003e00:	d013      	beq.n	8003e2a <HAL_RCCEx_PeriphCLKConfig+0xc2>
#if defined (LCD)
     || (temp_reg != (PeriphClkInit->LCDClockSelection & RCC_CR_RTCPRE))
#endif /* LCD */
       )
    { /* Check HSE State */
      if ((PeriphClkInit->RTCClockSelection & RCC_CSR_RTCSEL) == RCC_CSR_RTCSEL_HSE)
 8003e02:	687b      	ldr	r3, [r7, #4]
 8003e04:	685a      	ldr	r2, [r3, #4]
 8003e06:	23c0      	movs	r3, #192	; 0xc0
 8003e08:	029b      	lsls	r3, r3, #10
 8003e0a:	401a      	ands	r2, r3
 8003e0c:	23c0      	movs	r3, #192	; 0xc0
 8003e0e:	029b      	lsls	r3, r3, #10
 8003e10:	429a      	cmp	r2, r3
 8003e12:	d10a      	bne.n	8003e2a <HAL_RCCEx_PeriphCLKConfig+0xc2>
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
 8003e14:	4b6d      	ldr	r3, [pc, #436]	; (8003fcc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003e16:	681a      	ldr	r2, [r3, #0]
 8003e18:	2380      	movs	r3, #128	; 0x80
 8003e1a:	029b      	lsls	r3, r3, #10
 8003e1c:	401a      	ands	r2, r3
 8003e1e:	2380      	movs	r3, #128	; 0x80
 8003e20:	029b      	lsls	r3, r3, #10
 8003e22:	429a      	cmp	r2, r3
 8003e24:	d101      	bne.n	8003e2a <HAL_RCCEx_PeriphCLKConfig+0xc2>
        {
          /* To update HSE divider, first switch-OFF HSE clock oscillator*/
          return HAL_ERROR;
 8003e26:	2301      	movs	r3, #1
 8003e28:	e0cb      	b.n	8003fc2 <HAL_RCCEx_PeriphCLKConfig+0x25a>
        }
      }
    }

    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */
    temp_reg = (RCC->CSR & RCC_CSR_RTCSEL);
 8003e2a:	4b68      	ldr	r3, [pc, #416]	; (8003fcc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003e2c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003e2e:	23c0      	movs	r3, #192	; 0xc0
 8003e30:	029b      	lsls	r3, r3, #10
 8003e32:	4013      	ands	r3, r2
 8003e34:	60fb      	str	r3, [r7, #12]

    if((temp_reg != 0x00000000U) && (((temp_reg != (PeriphClkInit->RTCClockSelection & RCC_CSR_RTCSEL)) \
 8003e36:	68fb      	ldr	r3, [r7, #12]
 8003e38:	2b00      	cmp	r3, #0
 8003e3a:	d03b      	beq.n	8003eb4 <HAL_RCCEx_PeriphCLKConfig+0x14c>
 8003e3c:	687b      	ldr	r3, [r7, #4]
 8003e3e:	685a      	ldr	r2, [r3, #4]
 8003e40:	23c0      	movs	r3, #192	; 0xc0
 8003e42:	029b      	lsls	r3, r3, #10
 8003e44:	4013      	ands	r3, r2
 8003e46:	68fa      	ldr	r2, [r7, #12]
 8003e48:	429a      	cmp	r2, r3
 8003e4a:	d033      	beq.n	8003eb4 <HAL_RCCEx_PeriphCLKConfig+0x14c>
      && (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
 8003e4c:	687b      	ldr	r3, [r7, #4]
 8003e4e:	681b      	ldr	r3, [r3, #0]
 8003e50:	2220      	movs	r2, #32
 8003e52:	4013      	ands	r3, r2
 8003e54:	d02e      	beq.n	8003eb4 <HAL_RCCEx_PeriphCLKConfig+0x14c>
       && (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LCD) == RCC_PERIPHCLK_LCD))
#endif /* LCD */
     ))
    {
      /* Store the content of CSR register before the reset of Backup Domain */
      temp_reg = (RCC->CSR & ~(RCC_CSR_RTCSEL));
 8003e56:	4b5d      	ldr	r3, [pc, #372]	; (8003fcc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003e58:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8003e5a:	4a5e      	ldr	r2, [pc, #376]	; (8003fd4 <HAL_RCCEx_PeriphCLKConfig+0x26c>)
 8003e5c:	4013      	ands	r3, r2
 8003e5e:	60fb      	str	r3, [r7, #12]

      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 8003e60:	4b5a      	ldr	r3, [pc, #360]	; (8003fcc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003e62:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003e64:	4b59      	ldr	r3, [pc, #356]	; (8003fcc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003e66:	2180      	movs	r1, #128	; 0x80
 8003e68:	0309      	lsls	r1, r1, #12
 8003e6a:	430a      	orrs	r2, r1
 8003e6c:	651a      	str	r2, [r3, #80]	; 0x50
      __HAL_RCC_BACKUPRESET_RELEASE();
 8003e6e:	4b57      	ldr	r3, [pc, #348]	; (8003fcc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003e70:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003e72:	4b56      	ldr	r3, [pc, #344]	; (8003fcc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003e74:	4958      	ldr	r1, [pc, #352]	; (8003fd8 <HAL_RCCEx_PeriphCLKConfig+0x270>)
 8003e76:	400a      	ands	r2, r1
 8003e78:	651a      	str	r2, [r3, #80]	; 0x50

      /* Restore the Content of CSR register */
      RCC->CSR = temp_reg;
 8003e7a:	4b54      	ldr	r3, [pc, #336]	; (8003fcc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003e7c:	68fa      	ldr	r2, [r7, #12]
 8003e7e:	651a      	str	r2, [r3, #80]	; 0x50

       /* Wait for LSERDY if LSE was enabled */
      if (HAL_IS_BIT_SET(temp_reg, RCC_CSR_LSEON))
 8003e80:	68fa      	ldr	r2, [r7, #12]
 8003e82:	2380      	movs	r3, #128	; 0x80
 8003e84:	005b      	lsls	r3, r3, #1
 8003e86:	4013      	ands	r3, r2
 8003e88:	d014      	beq.n	8003eb4 <HAL_RCCEx_PeriphCLKConfig+0x14c>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8003e8a:	f7fe fe9d 	bl	8002bc8 <HAL_GetTick>
 8003e8e:	0003      	movs	r3, r0
 8003e90:	613b      	str	r3, [r7, #16]

        /* Wait till LSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8003e92:	e009      	b.n	8003ea8 <HAL_RCCEx_PeriphCLKConfig+0x140>
        {
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8003e94:	f7fe fe98 	bl	8002bc8 <HAL_GetTick>
 8003e98:	0002      	movs	r2, r0
 8003e9a:	693b      	ldr	r3, [r7, #16]
 8003e9c:	1ad3      	subs	r3, r2, r3
 8003e9e:	4a4f      	ldr	r2, [pc, #316]	; (8003fdc <HAL_RCCEx_PeriphCLKConfig+0x274>)
 8003ea0:	4293      	cmp	r3, r2
 8003ea2:	d901      	bls.n	8003ea8 <HAL_RCCEx_PeriphCLKConfig+0x140>
          {
            return HAL_TIMEOUT;
 8003ea4:	2303      	movs	r3, #3
 8003ea6:	e08c      	b.n	8003fc2 <HAL_RCCEx_PeriphCLKConfig+0x25a>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8003ea8:	4b48      	ldr	r3, [pc, #288]	; (8003fcc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003eaa:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003eac:	2380      	movs	r3, #128	; 0x80
 8003eae:	009b      	lsls	r3, r3, #2
 8003eb0:	4013      	ands	r3, r2
 8003eb2:	d0ef      	beq.n	8003e94 <HAL_RCCEx_PeriphCLKConfig+0x12c>
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8003eb4:	687b      	ldr	r3, [r7, #4]
 8003eb6:	685a      	ldr	r2, [r3, #4]
 8003eb8:	23c0      	movs	r3, #192	; 0xc0
 8003eba:	029b      	lsls	r3, r3, #10
 8003ebc:	401a      	ands	r2, r3
 8003ebe:	23c0      	movs	r3, #192	; 0xc0
 8003ec0:	029b      	lsls	r3, r3, #10
 8003ec2:	429a      	cmp	r2, r3
 8003ec4:	d10c      	bne.n	8003ee0 <HAL_RCCEx_PeriphCLKConfig+0x178>
 8003ec6:	4b41      	ldr	r3, [pc, #260]	; (8003fcc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003ec8:	681b      	ldr	r3, [r3, #0]
 8003eca:	4a45      	ldr	r2, [pc, #276]	; (8003fe0 <HAL_RCCEx_PeriphCLKConfig+0x278>)
 8003ecc:	4013      	ands	r3, r2
 8003ece:	0019      	movs	r1, r3
 8003ed0:	687b      	ldr	r3, [r7, #4]
 8003ed2:	685a      	ldr	r2, [r3, #4]
 8003ed4:	23c0      	movs	r3, #192	; 0xc0
 8003ed6:	039b      	lsls	r3, r3, #14
 8003ed8:	401a      	ands	r2, r3
 8003eda:	4b3c      	ldr	r3, [pc, #240]	; (8003fcc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003edc:	430a      	orrs	r2, r1
 8003ede:	601a      	str	r2, [r3, #0]
 8003ee0:	4b3a      	ldr	r3, [pc, #232]	; (8003fcc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003ee2:	6d19      	ldr	r1, [r3, #80]	; 0x50
 8003ee4:	687b      	ldr	r3, [r7, #4]
 8003ee6:	685a      	ldr	r2, [r3, #4]
 8003ee8:	23c0      	movs	r3, #192	; 0xc0
 8003eea:	029b      	lsls	r3, r3, #10
 8003eec:	401a      	ands	r2, r3
 8003eee:	4b37      	ldr	r3, [pc, #220]	; (8003fcc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003ef0:	430a      	orrs	r2, r1
 8003ef2:	651a      	str	r2, [r3, #80]	; 0x50

    /* Require to disable power clock if necessary */
    if(pwrclkchanged == SET)
 8003ef4:	2317      	movs	r3, #23
 8003ef6:	18fb      	adds	r3, r7, r3
 8003ef8:	781b      	ldrb	r3, [r3, #0]
 8003efa:	2b01      	cmp	r3, #1
 8003efc:	d105      	bne.n	8003f0a <HAL_RCCEx_PeriphCLKConfig+0x1a2>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8003efe:	4b33      	ldr	r3, [pc, #204]	; (8003fcc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003f00:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8003f02:	4b32      	ldr	r3, [pc, #200]	; (8003fcc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003f04:	4937      	ldr	r1, [pc, #220]	; (8003fe4 <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8003f06:	400a      	ands	r2, r1
 8003f08:	639a      	str	r2, [r3, #56]	; 0x38
    }
  }

#if defined (RCC_CCIPR_USART1SEL)
  /*------------------------------- USART1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8003f0a:	687b      	ldr	r3, [r7, #4]
 8003f0c:	681b      	ldr	r3, [r3, #0]
 8003f0e:	2201      	movs	r2, #1
 8003f10:	4013      	ands	r3, r2
 8003f12:	d009      	beq.n	8003f28 <HAL_RCCEx_PeriphCLKConfig+0x1c0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8003f14:	4b2d      	ldr	r3, [pc, #180]	; (8003fcc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003f16:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8003f18:	2203      	movs	r2, #3
 8003f1a:	4393      	bics	r3, r2
 8003f1c:	0019      	movs	r1, r3
 8003f1e:	687b      	ldr	r3, [r7, #4]
 8003f20:	689a      	ldr	r2, [r3, #8]
 8003f22:	4b2a      	ldr	r3, [pc, #168]	; (8003fcc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003f24:	430a      	orrs	r2, r1
 8003f26:	64da      	str	r2, [r3, #76]	; 0x4c
  }
#endif /* RCC_CCIPR_USART1SEL */

  /*----------------------------- USART2 Configuration --------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8003f28:	687b      	ldr	r3, [r7, #4]
 8003f2a:	681b      	ldr	r3, [r3, #0]
 8003f2c:	2202      	movs	r2, #2
 8003f2e:	4013      	ands	r3, r2
 8003f30:	d009      	beq.n	8003f46 <HAL_RCCEx_PeriphCLKConfig+0x1de>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8003f32:	4b26      	ldr	r3, [pc, #152]	; (8003fcc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003f34:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8003f36:	220c      	movs	r2, #12
 8003f38:	4393      	bics	r3, r2
 8003f3a:	0019      	movs	r1, r3
 8003f3c:	687b      	ldr	r3, [r7, #4]
 8003f3e:	68da      	ldr	r2, [r3, #12]
 8003f40:	4b22      	ldr	r3, [pc, #136]	; (8003fcc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003f42:	430a      	orrs	r2, r1
 8003f44:	64da      	str	r2, [r3, #76]	; 0x4c
  }

  /*------------------------------ LPUART1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8003f46:	687b      	ldr	r3, [r7, #4]
 8003f48:	681b      	ldr	r3, [r3, #0]
 8003f4a:	2204      	movs	r2, #4
 8003f4c:	4013      	ands	r3, r2
 8003f4e:	d009      	beq.n	8003f64 <HAL_RCCEx_PeriphCLKConfig+0x1fc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 8003f50:	4b1e      	ldr	r3, [pc, #120]	; (8003fcc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003f52:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8003f54:	4a24      	ldr	r2, [pc, #144]	; (8003fe8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 8003f56:	4013      	ands	r3, r2
 8003f58:	0019      	movs	r1, r3
 8003f5a:	687b      	ldr	r3, [r7, #4]
 8003f5c:	691a      	ldr	r2, [r3, #16]
 8003f5e:	4b1b      	ldr	r3, [pc, #108]	; (8003fcc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003f60:	430a      	orrs	r2, r1
 8003f62:	64da      	str	r2, [r3, #76]	; 0x4c
  }

  /*------------------------------ I2C1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8003f64:	687b      	ldr	r3, [r7, #4]
 8003f66:	681b      	ldr	r3, [r3, #0]
 8003f68:	2208      	movs	r2, #8
 8003f6a:	4013      	ands	r3, r2
 8003f6c:	d009      	beq.n	8003f82 <HAL_RCCEx_PeriphCLKConfig+0x21a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8003f6e:	4b17      	ldr	r3, [pc, #92]	; (8003fcc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003f70:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8003f72:	4a1e      	ldr	r2, [pc, #120]	; (8003fec <HAL_RCCEx_PeriphCLKConfig+0x284>)
 8003f74:	4013      	ands	r3, r2
 8003f76:	0019      	movs	r1, r3
 8003f78:	687b      	ldr	r3, [r7, #4]
 8003f7a:	695a      	ldr	r2, [r3, #20]
 8003f7c:	4b13      	ldr	r3, [pc, #76]	; (8003fcc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003f7e:	430a      	orrs	r2, r1
 8003f80:	64da      	str	r2, [r3, #76]	; 0x4c
  }

#if defined (RCC_CCIPR_I2C3SEL)
    /*------------------------------ I2C3 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8003f82:	687b      	ldr	r3, [r7, #4]
 8003f84:	681a      	ldr	r2, [r3, #0]
 8003f86:	2380      	movs	r3, #128	; 0x80
 8003f88:	005b      	lsls	r3, r3, #1
 8003f8a:	4013      	ands	r3, r2
 8003f8c:	d009      	beq.n	8003fa2 <HAL_RCCEx_PeriphCLKConfig+0x23a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8003f8e:	4b0f      	ldr	r3, [pc, #60]	; (8003fcc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003f90:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8003f92:	4a10      	ldr	r2, [pc, #64]	; (8003fd4 <HAL_RCCEx_PeriphCLKConfig+0x26c>)
 8003f94:	4013      	ands	r3, r2
 8003f96:	0019      	movs	r1, r3
 8003f98:	687b      	ldr	r3, [r7, #4]
 8003f9a:	699a      	ldr	r2, [r3, #24]
 8003f9c:	4b0b      	ldr	r3, [pc, #44]	; (8003fcc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003f9e:	430a      	orrs	r2, r1
 8003fa0:	64da      	str	r2, [r3, #76]	; 0x4c
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
  }
#endif /* USB */

  /*---------------------------- LPTIM1 configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 8003fa2:	687b      	ldr	r3, [r7, #4]
 8003fa4:	681b      	ldr	r3, [r3, #0]
 8003fa6:	2280      	movs	r2, #128	; 0x80
 8003fa8:	4013      	ands	r3, r2
 8003faa:	d009      	beq.n	8003fc0 <HAL_RCCEx_PeriphCLKConfig+0x258>
  {
    assert_param(IS_RCC_LPTIMCLK(PeriphClkInit->LptimClockSelection));
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->LptimClockSelection);
 8003fac:	4b07      	ldr	r3, [pc, #28]	; (8003fcc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003fae:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8003fb0:	4a0f      	ldr	r2, [pc, #60]	; (8003ff0 <HAL_RCCEx_PeriphCLKConfig+0x288>)
 8003fb2:	4013      	ands	r3, r2
 8003fb4:	0019      	movs	r1, r3
 8003fb6:	687b      	ldr	r3, [r7, #4]
 8003fb8:	69da      	ldr	r2, [r3, #28]
 8003fba:	4b04      	ldr	r3, [pc, #16]	; (8003fcc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003fbc:	430a      	orrs	r2, r1
 8003fbe:	64da      	str	r2, [r3, #76]	; 0x4c
  }

  return HAL_OK;
 8003fc0:	2300      	movs	r3, #0
}
 8003fc2:	0018      	movs	r0, r3
 8003fc4:	46bd      	mov	sp, r7
 8003fc6:	b006      	add	sp, #24
 8003fc8:	bd80      	pop	{r7, pc}
 8003fca:	46c0      	nop			; (mov r8, r8)
 8003fcc:	40021000 	.word	0x40021000
 8003fd0:	40007000 	.word	0x40007000
 8003fd4:	fffcffff 	.word	0xfffcffff
 8003fd8:	fff7ffff 	.word	0xfff7ffff
 8003fdc:	00001388 	.word	0x00001388
 8003fe0:	ffcfffff 	.word	0xffcfffff
 8003fe4:	efffffff 	.word	0xefffffff
 8003fe8:	fffff3ff 	.word	0xfffff3ff
 8003fec:	ffffcfff 	.word	0xffffcfff
 8003ff0:	fff3ffff 	.word	0xfff3ffff

08003ff4 <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 8003ff4:	b580      	push	{r7, lr}
 8003ff6:	b082      	sub	sp, #8
 8003ff8:	af00      	add	r7, sp, #0
 8003ffa:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
 8003ffc:	687b      	ldr	r3, [r7, #4]
 8003ffe:	2b00      	cmp	r3, #0
 8004000:	d101      	bne.n	8004006 <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 8004002:	2301      	movs	r3, #1
 8004004:	e044      	b.n	8004090 <HAL_UART_Init+0x9c>
  {
    /* Check the parameters */
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
  }

  if (huart->gState == HAL_UART_STATE_RESET)
 8004006:	687b      	ldr	r3, [r7, #4]
 8004008:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800400a:	2b00      	cmp	r3, #0
 800400c:	d107      	bne.n	800401e <HAL_UART_Init+0x2a>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 800400e:	687b      	ldr	r3, [r7, #4]
 8004010:	2274      	movs	r2, #116	; 0x74
 8004012:	2100      	movs	r1, #0
 8004014:	5499      	strb	r1, [r3, r2]

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 8004016:	687b      	ldr	r3, [r7, #4]
 8004018:	0018      	movs	r0, r3
 800401a:	f7fc fc71 	bl	8000900 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
 800401e:	687b      	ldr	r3, [r7, #4]
 8004020:	2224      	movs	r2, #36	; 0x24
 8004022:	679a      	str	r2, [r3, #120]	; 0x78

  __HAL_UART_DISABLE(huart);
 8004024:	687b      	ldr	r3, [r7, #4]
 8004026:	681b      	ldr	r3, [r3, #0]
 8004028:	681a      	ldr	r2, [r3, #0]
 800402a:	687b      	ldr	r3, [r7, #4]
 800402c:	681b      	ldr	r3, [r3, #0]
 800402e:	2101      	movs	r1, #1
 8004030:	438a      	bics	r2, r1
 8004032:	601a      	str	r2, [r3, #0]

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
 8004034:	687b      	ldr	r3, [r7, #4]
 8004036:	0018      	movs	r0, r3
 8004038:	f000 fc36 	bl	80048a8 <UART_SetConfig>
 800403c:	0003      	movs	r3, r0
 800403e:	2b01      	cmp	r3, #1
 8004040:	d101      	bne.n	8004046 <HAL_UART_Init+0x52>
  {
    return HAL_ERROR;
 8004042:	2301      	movs	r3, #1
 8004044:	e024      	b.n	8004090 <HAL_UART_Init+0x9c>
  }

  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 8004046:	687b      	ldr	r3, [r7, #4]
 8004048:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800404a:	2b00      	cmp	r3, #0
 800404c:	d003      	beq.n	8004056 <HAL_UART_Init+0x62>
  {
    UART_AdvFeatureConfig(huart);
 800404e:	687b      	ldr	r3, [r7, #4]
 8004050:	0018      	movs	r0, r3
 8004052:	f000 fee7 	bl	8004e24 <UART_AdvFeatureConfig>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8004056:	687b      	ldr	r3, [r7, #4]
 8004058:	681b      	ldr	r3, [r3, #0]
 800405a:	685a      	ldr	r2, [r3, #4]
 800405c:	687b      	ldr	r3, [r7, #4]
 800405e:	681b      	ldr	r3, [r3, #0]
 8004060:	490d      	ldr	r1, [pc, #52]	; (8004098 <HAL_UART_Init+0xa4>)
 8004062:	400a      	ands	r2, r1
 8004064:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8004066:	687b      	ldr	r3, [r7, #4]
 8004068:	681b      	ldr	r3, [r3, #0]
 800406a:	689a      	ldr	r2, [r3, #8]
 800406c:	687b      	ldr	r3, [r7, #4]
 800406e:	681b      	ldr	r3, [r3, #0]
 8004070:	212a      	movs	r1, #42	; 0x2a
 8004072:	438a      	bics	r2, r1
 8004074:	609a      	str	r2, [r3, #8]

  __HAL_UART_ENABLE(huart);
 8004076:	687b      	ldr	r3, [r7, #4]
 8004078:	681b      	ldr	r3, [r3, #0]
 800407a:	681a      	ldr	r2, [r3, #0]
 800407c:	687b      	ldr	r3, [r7, #4]
 800407e:	681b      	ldr	r3, [r3, #0]
 8004080:	2101      	movs	r1, #1
 8004082:	430a      	orrs	r2, r1
 8004084:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
 8004086:	687b      	ldr	r3, [r7, #4]
 8004088:	0018      	movs	r0, r3
 800408a:	f000 ff7f 	bl	8004f8c <UART_CheckIdleState>
 800408e:	0003      	movs	r3, r0
}
 8004090:	0018      	movs	r0, r3
 8004092:	46bd      	mov	sp, r7
 8004094:	b002      	add	sp, #8
 8004096:	bd80      	pop	{r7, pc}
 8004098:	ffffb7ff 	.word	0xffffb7ff

0800409c <HAL_UART_Transmit>:
  * @param Size    Amount of data elements (u8 or u16) to be sent.
  * @param Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 800409c:	b580      	push	{r7, lr}
 800409e:	b08a      	sub	sp, #40	; 0x28
 80040a0:	af02      	add	r7, sp, #8
 80040a2:	60f8      	str	r0, [r7, #12]
 80040a4:	60b9      	str	r1, [r7, #8]
 80040a6:	603b      	str	r3, [r7, #0]
 80040a8:	1dbb      	adds	r3, r7, #6
 80040aa:	801a      	strh	r2, [r3, #0]
  uint8_t  *pdata8bits;
  uint16_t *pdata16bits;
  uint32_t tickstart;

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 80040ac:	68fb      	ldr	r3, [r7, #12]
 80040ae:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80040b0:	2b20      	cmp	r3, #32
 80040b2:	d000      	beq.n	80040b6 <HAL_UART_Transmit+0x1a>
 80040b4:	e095      	b.n	80041e2 <HAL_UART_Transmit+0x146>
  {
    if ((pData == NULL) || (Size == 0U))
 80040b6:	68bb      	ldr	r3, [r7, #8]
 80040b8:	2b00      	cmp	r3, #0
 80040ba:	d003      	beq.n	80040c4 <HAL_UART_Transmit+0x28>
 80040bc:	1dbb      	adds	r3, r7, #6
 80040be:	881b      	ldrh	r3, [r3, #0]
 80040c0:	2b00      	cmp	r3, #0
 80040c2:	d101      	bne.n	80040c8 <HAL_UART_Transmit+0x2c>
    {
      return  HAL_ERROR;
 80040c4:	2301      	movs	r3, #1
 80040c6:	e08d      	b.n	80041e4 <HAL_UART_Transmit+0x148>
    }

    /* In case of 9bits/No Parity transfer, pData buffer provided as input parameter
       should be aligned on a u16 frontier, as data to be filled into TDR will be
       handled through a u16 cast. */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80040c8:	68fb      	ldr	r3, [r7, #12]
 80040ca:	689a      	ldr	r2, [r3, #8]
 80040cc:	2380      	movs	r3, #128	; 0x80
 80040ce:	015b      	lsls	r3, r3, #5
 80040d0:	429a      	cmp	r2, r3
 80040d2:	d109      	bne.n	80040e8 <HAL_UART_Transmit+0x4c>
 80040d4:	68fb      	ldr	r3, [r7, #12]
 80040d6:	691b      	ldr	r3, [r3, #16]
 80040d8:	2b00      	cmp	r3, #0
 80040da:	d105      	bne.n	80040e8 <HAL_UART_Transmit+0x4c>
    {
      if ((((uint32_t)pData) & 1U) != 0U)
 80040dc:	68bb      	ldr	r3, [r7, #8]
 80040de:	2201      	movs	r2, #1
 80040e0:	4013      	ands	r3, r2
 80040e2:	d001      	beq.n	80040e8 <HAL_UART_Transmit+0x4c>
      {
        return  HAL_ERROR;
 80040e4:	2301      	movs	r3, #1
 80040e6:	e07d      	b.n	80041e4 <HAL_UART_Transmit+0x148>
      }
    }

    __HAL_LOCK(huart);
 80040e8:	68fb      	ldr	r3, [r7, #12]
 80040ea:	2274      	movs	r2, #116	; 0x74
 80040ec:	5c9b      	ldrb	r3, [r3, r2]
 80040ee:	2b01      	cmp	r3, #1
 80040f0:	d101      	bne.n	80040f6 <HAL_UART_Transmit+0x5a>
 80040f2:	2302      	movs	r3, #2
 80040f4:	e076      	b.n	80041e4 <HAL_UART_Transmit+0x148>
 80040f6:	68fb      	ldr	r3, [r7, #12]
 80040f8:	2274      	movs	r2, #116	; 0x74
 80040fa:	2101      	movs	r1, #1
 80040fc:	5499      	strb	r1, [r3, r2]

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 80040fe:	68fb      	ldr	r3, [r7, #12]
 8004100:	2280      	movs	r2, #128	; 0x80
 8004102:	2100      	movs	r1, #0
 8004104:	5099      	str	r1, [r3, r2]
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8004106:	68fb      	ldr	r3, [r7, #12]
 8004108:	2221      	movs	r2, #33	; 0x21
 800410a:	679a      	str	r2, [r3, #120]	; 0x78

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
 800410c:	f7fe fd5c 	bl	8002bc8 <HAL_GetTick>
 8004110:	0003      	movs	r3, r0
 8004112:	617b      	str	r3, [r7, #20]

    huart->TxXferSize  = Size;
 8004114:	68fb      	ldr	r3, [r7, #12]
 8004116:	1dba      	adds	r2, r7, #6
 8004118:	2150      	movs	r1, #80	; 0x50
 800411a:	8812      	ldrh	r2, [r2, #0]
 800411c:	525a      	strh	r2, [r3, r1]
    huart->TxXferCount = Size;
 800411e:	68fb      	ldr	r3, [r7, #12]
 8004120:	1dba      	adds	r2, r7, #6
 8004122:	2152      	movs	r1, #82	; 0x52
 8004124:	8812      	ldrh	r2, [r2, #0]
 8004126:	525a      	strh	r2, [r3, r1]

    /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8004128:	68fb      	ldr	r3, [r7, #12]
 800412a:	689a      	ldr	r2, [r3, #8]
 800412c:	2380      	movs	r3, #128	; 0x80
 800412e:	015b      	lsls	r3, r3, #5
 8004130:	429a      	cmp	r2, r3
 8004132:	d108      	bne.n	8004146 <HAL_UART_Transmit+0xaa>
 8004134:	68fb      	ldr	r3, [r7, #12]
 8004136:	691b      	ldr	r3, [r3, #16]
 8004138:	2b00      	cmp	r3, #0
 800413a:	d104      	bne.n	8004146 <HAL_UART_Transmit+0xaa>
    {
      pdata8bits  = NULL;
 800413c:	2300      	movs	r3, #0
 800413e:	61fb      	str	r3, [r7, #28]
      pdata16bits = (uint16_t *) pData;
 8004140:	68bb      	ldr	r3, [r7, #8]
 8004142:	61bb      	str	r3, [r7, #24]
 8004144:	e003      	b.n	800414e <HAL_UART_Transmit+0xb2>
    }
    else
    {
      pdata8bits  = pData;
 8004146:	68bb      	ldr	r3, [r7, #8]
 8004148:	61fb      	str	r3, [r7, #28]
      pdata16bits = NULL;
 800414a:	2300      	movs	r3, #0
 800414c:	61bb      	str	r3, [r7, #24]
    }

    __HAL_UNLOCK(huart);
 800414e:	68fb      	ldr	r3, [r7, #12]
 8004150:	2274      	movs	r2, #116	; 0x74
 8004152:	2100      	movs	r1, #0
 8004154:	5499      	strb	r1, [r3, r2]

    while (huart->TxXferCount > 0U)
 8004156:	e02c      	b.n	80041b2 <HAL_UART_Transmit+0x116>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 8004158:	697a      	ldr	r2, [r7, #20]
 800415a:	68f8      	ldr	r0, [r7, #12]
 800415c:	683b      	ldr	r3, [r7, #0]
 800415e:	9300      	str	r3, [sp, #0]
 8004160:	0013      	movs	r3, r2
 8004162:	2200      	movs	r2, #0
 8004164:	2180      	movs	r1, #128	; 0x80
 8004166:	f000 ff59 	bl	800501c <UART_WaitOnFlagUntilTimeout>
 800416a:	1e03      	subs	r3, r0, #0
 800416c:	d001      	beq.n	8004172 <HAL_UART_Transmit+0xd6>
      {
        return HAL_TIMEOUT;
 800416e:	2303      	movs	r3, #3
 8004170:	e038      	b.n	80041e4 <HAL_UART_Transmit+0x148>
      }
      if (pdata8bits == NULL)
 8004172:	69fb      	ldr	r3, [r7, #28]
 8004174:	2b00      	cmp	r3, #0
 8004176:	d10b      	bne.n	8004190 <HAL_UART_Transmit+0xf4>
      {
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 8004178:	69bb      	ldr	r3, [r7, #24]
 800417a:	881b      	ldrh	r3, [r3, #0]
 800417c:	001a      	movs	r2, r3
 800417e:	68fb      	ldr	r3, [r7, #12]
 8004180:	681b      	ldr	r3, [r3, #0]
 8004182:	05d2      	lsls	r2, r2, #23
 8004184:	0dd2      	lsrs	r2, r2, #23
 8004186:	629a      	str	r2, [r3, #40]	; 0x28
        pdata16bits++;
 8004188:	69bb      	ldr	r3, [r7, #24]
 800418a:	3302      	adds	r3, #2
 800418c:	61bb      	str	r3, [r7, #24]
 800418e:	e007      	b.n	80041a0 <HAL_UART_Transmit+0x104>
      }
      else
      {
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 8004190:	69fb      	ldr	r3, [r7, #28]
 8004192:	781a      	ldrb	r2, [r3, #0]
 8004194:	68fb      	ldr	r3, [r7, #12]
 8004196:	681b      	ldr	r3, [r3, #0]
 8004198:	629a      	str	r2, [r3, #40]	; 0x28
        pdata8bits++;
 800419a:	69fb      	ldr	r3, [r7, #28]
 800419c:	3301      	adds	r3, #1
 800419e:	61fb      	str	r3, [r7, #28]
      }
      huart->TxXferCount--;
 80041a0:	68fb      	ldr	r3, [r7, #12]
 80041a2:	2252      	movs	r2, #82	; 0x52
 80041a4:	5a9b      	ldrh	r3, [r3, r2]
 80041a6:	b29b      	uxth	r3, r3
 80041a8:	3b01      	subs	r3, #1
 80041aa:	b299      	uxth	r1, r3
 80041ac:	68fb      	ldr	r3, [r7, #12]
 80041ae:	2252      	movs	r2, #82	; 0x52
 80041b0:	5299      	strh	r1, [r3, r2]
    while (huart->TxXferCount > 0U)
 80041b2:	68fb      	ldr	r3, [r7, #12]
 80041b4:	2252      	movs	r2, #82	; 0x52
 80041b6:	5a9b      	ldrh	r3, [r3, r2]
 80041b8:	b29b      	uxth	r3, r3
 80041ba:	2b00      	cmp	r3, #0
 80041bc:	d1cc      	bne.n	8004158 <HAL_UART_Transmit+0xbc>
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 80041be:	697a      	ldr	r2, [r7, #20]
 80041c0:	68f8      	ldr	r0, [r7, #12]
 80041c2:	683b      	ldr	r3, [r7, #0]
 80041c4:	9300      	str	r3, [sp, #0]
 80041c6:	0013      	movs	r3, r2
 80041c8:	2200      	movs	r2, #0
 80041ca:	2140      	movs	r1, #64	; 0x40
 80041cc:	f000 ff26 	bl	800501c <UART_WaitOnFlagUntilTimeout>
 80041d0:	1e03      	subs	r3, r0, #0
 80041d2:	d001      	beq.n	80041d8 <HAL_UART_Transmit+0x13c>
    {
      return HAL_TIMEOUT;
 80041d4:	2303      	movs	r3, #3
 80041d6:	e005      	b.n	80041e4 <HAL_UART_Transmit+0x148>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
 80041d8:	68fb      	ldr	r3, [r7, #12]
 80041da:	2220      	movs	r2, #32
 80041dc:	679a      	str	r2, [r3, #120]	; 0x78

    return HAL_OK;
 80041de:	2300      	movs	r3, #0
 80041e0:	e000      	b.n	80041e4 <HAL_UART_Transmit+0x148>
  }
  else
  {
    return HAL_BUSY;
 80041e2:	2302      	movs	r3, #2
  }
}
 80041e4:	0018      	movs	r0, r3
 80041e6:	46bd      	mov	sp, r7
 80041e8:	b008      	add	sp, #32
 80041ea:	bd80      	pop	{r7, pc}

080041ec <HAL_UART_Receive_IT>:
  * @param pData Pointer to data buffer (u8 or u16 data elements).
  * @param Size  Amount of data elements (u8 or u16) to be received.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 80041ec:	b580      	push	{r7, lr}
 80041ee:	b088      	sub	sp, #32
 80041f0:	af00      	add	r7, sp, #0
 80041f2:	60f8      	str	r0, [r7, #12]
 80041f4:	60b9      	str	r1, [r7, #8]
 80041f6:	1dbb      	adds	r3, r7, #6
 80041f8:	801a      	strh	r2, [r3, #0]
  /* Check that a Rx process is not already ongoing */
  if (huart->RxState == HAL_UART_STATE_READY)
 80041fa:	68fb      	ldr	r3, [r7, #12]
 80041fc:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80041fe:	2b20      	cmp	r3, #32
 8004200:	d155      	bne.n	80042ae <HAL_UART_Receive_IT+0xc2>
  {
    if ((pData == NULL) || (Size == 0U))
 8004202:	68bb      	ldr	r3, [r7, #8]
 8004204:	2b00      	cmp	r3, #0
 8004206:	d003      	beq.n	8004210 <HAL_UART_Receive_IT+0x24>
 8004208:	1dbb      	adds	r3, r7, #6
 800420a:	881b      	ldrh	r3, [r3, #0]
 800420c:	2b00      	cmp	r3, #0
 800420e:	d101      	bne.n	8004214 <HAL_UART_Receive_IT+0x28>
    {
      return HAL_ERROR;
 8004210:	2301      	movs	r3, #1
 8004212:	e04d      	b.n	80042b0 <HAL_UART_Receive_IT+0xc4>
    }

    /* In case of 9bits/No Parity transfer, pData buffer provided as input parameter
       should be aligned on a u16 frontier, as data to be received from RDR will be
       handled through a u16 cast. */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8004214:	68fb      	ldr	r3, [r7, #12]
 8004216:	689a      	ldr	r2, [r3, #8]
 8004218:	2380      	movs	r3, #128	; 0x80
 800421a:	015b      	lsls	r3, r3, #5
 800421c:	429a      	cmp	r2, r3
 800421e:	d109      	bne.n	8004234 <HAL_UART_Receive_IT+0x48>
 8004220:	68fb      	ldr	r3, [r7, #12]
 8004222:	691b      	ldr	r3, [r3, #16]
 8004224:	2b00      	cmp	r3, #0
 8004226:	d105      	bne.n	8004234 <HAL_UART_Receive_IT+0x48>
    {
      if ((((uint32_t)pData) & 1U) != 0U)
 8004228:	68bb      	ldr	r3, [r7, #8]
 800422a:	2201      	movs	r2, #1
 800422c:	4013      	ands	r3, r2
 800422e:	d001      	beq.n	8004234 <HAL_UART_Receive_IT+0x48>
      {
        return  HAL_ERROR;
 8004230:	2301      	movs	r3, #1
 8004232:	e03d      	b.n	80042b0 <HAL_UART_Receive_IT+0xc4>
      }
    }

    __HAL_LOCK(huart);
 8004234:	68fb      	ldr	r3, [r7, #12]
 8004236:	2274      	movs	r2, #116	; 0x74
 8004238:	5c9b      	ldrb	r3, [r3, r2]
 800423a:	2b01      	cmp	r3, #1
 800423c:	d101      	bne.n	8004242 <HAL_UART_Receive_IT+0x56>
 800423e:	2302      	movs	r3, #2
 8004240:	e036      	b.n	80042b0 <HAL_UART_Receive_IT+0xc4>
 8004242:	68fb      	ldr	r3, [r7, #12]
 8004244:	2274      	movs	r2, #116	; 0x74
 8004246:	2101      	movs	r1, #1
 8004248:	5499      	strb	r1, [r3, r2]

    /* Set Reception type to Standard reception */
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800424a:	68fb      	ldr	r3, [r7, #12]
 800424c:	2200      	movs	r2, #0
 800424e:	661a      	str	r2, [r3, #96]	; 0x60

    if (!(IS_LPUART_INSTANCE(huart->Instance)))
 8004250:	68fb      	ldr	r3, [r7, #12]
 8004252:	681b      	ldr	r3, [r3, #0]
 8004254:	4a18      	ldr	r2, [pc, #96]	; (80042b8 <HAL_UART_Receive_IT+0xcc>)
 8004256:	4293      	cmp	r3, r2
 8004258:	d020      	beq.n	800429c <HAL_UART_Receive_IT+0xb0>
    {
      /* Check that USART RTOEN bit is set */
      if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 800425a:	68fb      	ldr	r3, [r7, #12]
 800425c:	681b      	ldr	r3, [r3, #0]
 800425e:	685a      	ldr	r2, [r3, #4]
 8004260:	2380      	movs	r3, #128	; 0x80
 8004262:	041b      	lsls	r3, r3, #16
 8004264:	4013      	ands	r3, r2
 8004266:	d019      	beq.n	800429c <HAL_UART_Receive_IT+0xb0>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004268:	f3ef 8310 	mrs	r3, PRIMASK
 800426c:	613b      	str	r3, [r7, #16]
  return(result);
 800426e:	693b      	ldr	r3, [r7, #16]
      {
        /* Enable the UART Receiver Timeout Interrupt */
        ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 8004270:	61fb      	str	r3, [r7, #28]
 8004272:	2301      	movs	r3, #1
 8004274:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004276:	697b      	ldr	r3, [r7, #20]
 8004278:	f383 8810 	msr	PRIMASK, r3
}
 800427c:	46c0      	nop			; (mov r8, r8)
 800427e:	68fb      	ldr	r3, [r7, #12]
 8004280:	681b      	ldr	r3, [r3, #0]
 8004282:	681a      	ldr	r2, [r3, #0]
 8004284:	68fb      	ldr	r3, [r7, #12]
 8004286:	681b      	ldr	r3, [r3, #0]
 8004288:	2180      	movs	r1, #128	; 0x80
 800428a:	04c9      	lsls	r1, r1, #19
 800428c:	430a      	orrs	r2, r1
 800428e:	601a      	str	r2, [r3, #0]
 8004290:	69fb      	ldr	r3, [r7, #28]
 8004292:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004294:	69bb      	ldr	r3, [r7, #24]
 8004296:	f383 8810 	msr	PRIMASK, r3
}
 800429a:	46c0      	nop			; (mov r8, r8)
      }
    }

    return (UART_Start_Receive_IT(huart, pData, Size));
 800429c:	1dbb      	adds	r3, r7, #6
 800429e:	881a      	ldrh	r2, [r3, #0]
 80042a0:	68b9      	ldr	r1, [r7, #8]
 80042a2:	68fb      	ldr	r3, [r7, #12]
 80042a4:	0018      	movs	r0, r3
 80042a6:	f000 ff7d 	bl	80051a4 <UART_Start_Receive_IT>
 80042aa:	0003      	movs	r3, r0
 80042ac:	e000      	b.n	80042b0 <HAL_UART_Receive_IT+0xc4>
  }
  else
  {
    return HAL_BUSY;
 80042ae:	2302      	movs	r3, #2
  }
}
 80042b0:	0018      	movs	r0, r3
 80042b2:	46bd      	mov	sp, r7
 80042b4:	b008      	add	sp, #32
 80042b6:	bd80      	pop	{r7, pc}
 80042b8:	40004800 	.word	0x40004800

080042bc <HAL_UART_IRQHandler>:
  * @brief Handle UART interrupt request.
  * @param huart UART handle.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
 80042bc:	b590      	push	{r4, r7, lr}
 80042be:	b0ab      	sub	sp, #172	; 0xac
 80042c0:	af00      	add	r7, sp, #0
 80042c2:	6078      	str	r0, [r7, #4]
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 80042c4:	687b      	ldr	r3, [r7, #4]
 80042c6:	681b      	ldr	r3, [r3, #0]
 80042c8:	69db      	ldr	r3, [r3, #28]
 80042ca:	22a4      	movs	r2, #164	; 0xa4
 80042cc:	18b9      	adds	r1, r7, r2
 80042ce:	600b      	str	r3, [r1, #0]
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 80042d0:	687b      	ldr	r3, [r7, #4]
 80042d2:	681b      	ldr	r3, [r3, #0]
 80042d4:	681b      	ldr	r3, [r3, #0]
 80042d6:	20a0      	movs	r0, #160	; 0xa0
 80042d8:	1839      	adds	r1, r7, r0
 80042da:	600b      	str	r3, [r1, #0]
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 80042dc:	687b      	ldr	r3, [r7, #4]
 80042de:	681b      	ldr	r3, [r3, #0]
 80042e0:	689b      	ldr	r3, [r3, #8]
 80042e2:	219c      	movs	r1, #156	; 0x9c
 80042e4:	1879      	adds	r1, r7, r1
 80042e6:	600b      	str	r3, [r1, #0]

  uint32_t errorflags;
  uint32_t errorcode;

  /* If no error occurs */
  errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE | USART_ISR_RTOF));
 80042e8:	0011      	movs	r1, r2
 80042ea:	18bb      	adds	r3, r7, r2
 80042ec:	681b      	ldr	r3, [r3, #0]
 80042ee:	4a99      	ldr	r2, [pc, #612]	; (8004554 <HAL_UART_IRQHandler+0x298>)
 80042f0:	4013      	ands	r3, r2
 80042f2:	2298      	movs	r2, #152	; 0x98
 80042f4:	18bc      	adds	r4, r7, r2
 80042f6:	6023      	str	r3, [r4, #0]
  if (errorflags == 0U)
 80042f8:	18bb      	adds	r3, r7, r2
 80042fa:	681b      	ldr	r3, [r3, #0]
 80042fc:	2b00      	cmp	r3, #0
 80042fe:	d114      	bne.n	800432a <HAL_UART_IRQHandler+0x6e>
  {
    /* UART in mode Receiver ---------------------------------------------------*/
    if (((isrflags & USART_ISR_RXNE) != 0U)
 8004300:	187b      	adds	r3, r7, r1
 8004302:	681b      	ldr	r3, [r3, #0]
 8004304:	2220      	movs	r2, #32
 8004306:	4013      	ands	r3, r2
 8004308:	d00f      	beq.n	800432a <HAL_UART_IRQHandler+0x6e>
        && ((cr1its & USART_CR1_RXNEIE) != 0U))
 800430a:	183b      	adds	r3, r7, r0
 800430c:	681b      	ldr	r3, [r3, #0]
 800430e:	2220      	movs	r2, #32
 8004310:	4013      	ands	r3, r2
 8004312:	d00a      	beq.n	800432a <HAL_UART_IRQHandler+0x6e>
    {
      if (huart->RxISR != NULL)
 8004314:	687b      	ldr	r3, [r7, #4]
 8004316:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8004318:	2b00      	cmp	r3, #0
 800431a:	d100      	bne.n	800431e <HAL_UART_IRQHandler+0x62>
 800431c:	e298      	b.n	8004850 <HAL_UART_IRQHandler+0x594>
      {
        huart->RxISR(huart);
 800431e:	687b      	ldr	r3, [r7, #4]
 8004320:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8004322:	687a      	ldr	r2, [r7, #4]
 8004324:	0010      	movs	r0, r2
 8004326:	4798      	blx	r3
      }
      return;
 8004328:	e292      	b.n	8004850 <HAL_UART_IRQHandler+0x594>
    }
  }

  /* If some errors occur */
  if ((errorflags != 0U)
 800432a:	2398      	movs	r3, #152	; 0x98
 800432c:	18fb      	adds	r3, r7, r3
 800432e:	681b      	ldr	r3, [r3, #0]
 8004330:	2b00      	cmp	r3, #0
 8004332:	d100      	bne.n	8004336 <HAL_UART_IRQHandler+0x7a>
 8004334:	e114      	b.n	8004560 <HAL_UART_IRQHandler+0x2a4>
      && (((cr3its & USART_CR3_EIE) != 0U)
 8004336:	239c      	movs	r3, #156	; 0x9c
 8004338:	18fb      	adds	r3, r7, r3
 800433a:	681b      	ldr	r3, [r3, #0]
 800433c:	2201      	movs	r2, #1
 800433e:	4013      	ands	r3, r2
 8004340:	d106      	bne.n	8004350 <HAL_UART_IRQHandler+0x94>
          || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U)))
 8004342:	23a0      	movs	r3, #160	; 0xa0
 8004344:	18fb      	adds	r3, r7, r3
 8004346:	681b      	ldr	r3, [r3, #0]
 8004348:	4a83      	ldr	r2, [pc, #524]	; (8004558 <HAL_UART_IRQHandler+0x29c>)
 800434a:	4013      	ands	r3, r2
 800434c:	d100      	bne.n	8004350 <HAL_UART_IRQHandler+0x94>
 800434e:	e107      	b.n	8004560 <HAL_UART_IRQHandler+0x2a4>
  {
    /* UART parity error interrupt occurred -------------------------------------*/
    if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 8004350:	23a4      	movs	r3, #164	; 0xa4
 8004352:	18fb      	adds	r3, r7, r3
 8004354:	681b      	ldr	r3, [r3, #0]
 8004356:	2201      	movs	r2, #1
 8004358:	4013      	ands	r3, r2
 800435a:	d012      	beq.n	8004382 <HAL_UART_IRQHandler+0xc6>
 800435c:	23a0      	movs	r3, #160	; 0xa0
 800435e:	18fb      	adds	r3, r7, r3
 8004360:	681a      	ldr	r2, [r3, #0]
 8004362:	2380      	movs	r3, #128	; 0x80
 8004364:	005b      	lsls	r3, r3, #1
 8004366:	4013      	ands	r3, r2
 8004368:	d00b      	beq.n	8004382 <HAL_UART_IRQHandler+0xc6>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 800436a:	687b      	ldr	r3, [r7, #4]
 800436c:	681b      	ldr	r3, [r3, #0]
 800436e:	2201      	movs	r2, #1
 8004370:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_PE;
 8004372:	687b      	ldr	r3, [r7, #4]
 8004374:	2280      	movs	r2, #128	; 0x80
 8004376:	589b      	ldr	r3, [r3, r2]
 8004378:	2201      	movs	r2, #1
 800437a:	431a      	orrs	r2, r3
 800437c:	687b      	ldr	r3, [r7, #4]
 800437e:	2180      	movs	r1, #128	; 0x80
 8004380:	505a      	str	r2, [r3, r1]
    }

    /* UART frame error interrupt occurred --------------------------------------*/
    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8004382:	23a4      	movs	r3, #164	; 0xa4
 8004384:	18fb      	adds	r3, r7, r3
 8004386:	681b      	ldr	r3, [r3, #0]
 8004388:	2202      	movs	r2, #2
 800438a:	4013      	ands	r3, r2
 800438c:	d011      	beq.n	80043b2 <HAL_UART_IRQHandler+0xf6>
 800438e:	239c      	movs	r3, #156	; 0x9c
 8004390:	18fb      	adds	r3, r7, r3
 8004392:	681b      	ldr	r3, [r3, #0]
 8004394:	2201      	movs	r2, #1
 8004396:	4013      	ands	r3, r2
 8004398:	d00b      	beq.n	80043b2 <HAL_UART_IRQHandler+0xf6>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 800439a:	687b      	ldr	r3, [r7, #4]
 800439c:	681b      	ldr	r3, [r3, #0]
 800439e:	2202      	movs	r2, #2
 80043a0:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_FE;
 80043a2:	687b      	ldr	r3, [r7, #4]
 80043a4:	2280      	movs	r2, #128	; 0x80
 80043a6:	589b      	ldr	r3, [r3, r2]
 80043a8:	2204      	movs	r2, #4
 80043aa:	431a      	orrs	r2, r3
 80043ac:	687b      	ldr	r3, [r7, #4]
 80043ae:	2180      	movs	r1, #128	; 0x80
 80043b0:	505a      	str	r2, [r3, r1]
    }

    /* UART noise error interrupt occurred --------------------------------------*/
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80043b2:	23a4      	movs	r3, #164	; 0xa4
 80043b4:	18fb      	adds	r3, r7, r3
 80043b6:	681b      	ldr	r3, [r3, #0]
 80043b8:	2204      	movs	r2, #4
 80043ba:	4013      	ands	r3, r2
 80043bc:	d011      	beq.n	80043e2 <HAL_UART_IRQHandler+0x126>
 80043be:	239c      	movs	r3, #156	; 0x9c
 80043c0:	18fb      	adds	r3, r7, r3
 80043c2:	681b      	ldr	r3, [r3, #0]
 80043c4:	2201      	movs	r2, #1
 80043c6:	4013      	ands	r3, r2
 80043c8:	d00b      	beq.n	80043e2 <HAL_UART_IRQHandler+0x126>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 80043ca:	687b      	ldr	r3, [r7, #4]
 80043cc:	681b      	ldr	r3, [r3, #0]
 80043ce:	2204      	movs	r2, #4
 80043d0:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_NE;
 80043d2:	687b      	ldr	r3, [r7, #4]
 80043d4:	2280      	movs	r2, #128	; 0x80
 80043d6:	589b      	ldr	r3, [r3, r2]
 80043d8:	2202      	movs	r2, #2
 80043da:	431a      	orrs	r2, r3
 80043dc:	687b      	ldr	r3, [r7, #4]
 80043de:	2180      	movs	r1, #128	; 0x80
 80043e0:	505a      	str	r2, [r3, r1]
    }

    /* UART Over-Run interrupt occurred -----------------------------------------*/
    if (((isrflags & USART_ISR_ORE) != 0U)
 80043e2:	23a4      	movs	r3, #164	; 0xa4
 80043e4:	18fb      	adds	r3, r7, r3
 80043e6:	681b      	ldr	r3, [r3, #0]
 80043e8:	2208      	movs	r2, #8
 80043ea:	4013      	ands	r3, r2
 80043ec:	d017      	beq.n	800441e <HAL_UART_IRQHandler+0x162>
        && (((cr1its & USART_CR1_RXNEIE) != 0U) ||
 80043ee:	23a0      	movs	r3, #160	; 0xa0
 80043f0:	18fb      	adds	r3, r7, r3
 80043f2:	681b      	ldr	r3, [r3, #0]
 80043f4:	2220      	movs	r2, #32
 80043f6:	4013      	ands	r3, r2
 80043f8:	d105      	bne.n	8004406 <HAL_UART_IRQHandler+0x14a>
            ((cr3its & USART_CR3_EIE) != 0U)))
 80043fa:	239c      	movs	r3, #156	; 0x9c
 80043fc:	18fb      	adds	r3, r7, r3
 80043fe:	681b      	ldr	r3, [r3, #0]
 8004400:	2201      	movs	r2, #1
 8004402:	4013      	ands	r3, r2
        && (((cr1its & USART_CR1_RXNEIE) != 0U) ||
 8004404:	d00b      	beq.n	800441e <HAL_UART_IRQHandler+0x162>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 8004406:	687b      	ldr	r3, [r7, #4]
 8004408:	681b      	ldr	r3, [r3, #0]
 800440a:	2208      	movs	r2, #8
 800440c:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 800440e:	687b      	ldr	r3, [r7, #4]
 8004410:	2280      	movs	r2, #128	; 0x80
 8004412:	589b      	ldr	r3, [r3, r2]
 8004414:	2208      	movs	r2, #8
 8004416:	431a      	orrs	r2, r3
 8004418:	687b      	ldr	r3, [r7, #4]
 800441a:	2180      	movs	r1, #128	; 0x80
 800441c:	505a      	str	r2, [r3, r1]
    }

    /* UART Receiver Timeout interrupt occurred ---------------------------------*/
    if (((isrflags & USART_ISR_RTOF) != 0U) && ((cr1its & USART_CR1_RTOIE) != 0U))
 800441e:	23a4      	movs	r3, #164	; 0xa4
 8004420:	18fb      	adds	r3, r7, r3
 8004422:	681a      	ldr	r2, [r3, #0]
 8004424:	2380      	movs	r3, #128	; 0x80
 8004426:	011b      	lsls	r3, r3, #4
 8004428:	4013      	ands	r3, r2
 800442a:	d013      	beq.n	8004454 <HAL_UART_IRQHandler+0x198>
 800442c:	23a0      	movs	r3, #160	; 0xa0
 800442e:	18fb      	adds	r3, r7, r3
 8004430:	681a      	ldr	r2, [r3, #0]
 8004432:	2380      	movs	r3, #128	; 0x80
 8004434:	04db      	lsls	r3, r3, #19
 8004436:	4013      	ands	r3, r2
 8004438:	d00c      	beq.n	8004454 <HAL_UART_IRQHandler+0x198>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 800443a:	687b      	ldr	r3, [r7, #4]
 800443c:	681b      	ldr	r3, [r3, #0]
 800443e:	2280      	movs	r2, #128	; 0x80
 8004440:	0112      	lsls	r2, r2, #4
 8004442:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_RTO;
 8004444:	687b      	ldr	r3, [r7, #4]
 8004446:	2280      	movs	r2, #128	; 0x80
 8004448:	589b      	ldr	r3, [r3, r2]
 800444a:	2220      	movs	r2, #32
 800444c:	431a      	orrs	r2, r3
 800444e:	687b      	ldr	r3, [r7, #4]
 8004450:	2180      	movs	r1, #128	; 0x80
 8004452:	505a      	str	r2, [r3, r1]
    }

    /* Call UART Error Call back function if need be ----------------------------*/
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 8004454:	687b      	ldr	r3, [r7, #4]
 8004456:	2280      	movs	r2, #128	; 0x80
 8004458:	589b      	ldr	r3, [r3, r2]
 800445a:	2b00      	cmp	r3, #0
 800445c:	d100      	bne.n	8004460 <HAL_UART_IRQHandler+0x1a4>
 800445e:	e1f9      	b.n	8004854 <HAL_UART_IRQHandler+0x598>
    {
      /* UART in mode Receiver --------------------------------------------------*/
      if (((isrflags & USART_ISR_RXNE) != 0U)
 8004460:	23a4      	movs	r3, #164	; 0xa4
 8004462:	18fb      	adds	r3, r7, r3
 8004464:	681b      	ldr	r3, [r3, #0]
 8004466:	2220      	movs	r2, #32
 8004468:	4013      	ands	r3, r2
 800446a:	d00e      	beq.n	800448a <HAL_UART_IRQHandler+0x1ce>
          && ((cr1its & USART_CR1_RXNEIE) != 0U))
 800446c:	23a0      	movs	r3, #160	; 0xa0
 800446e:	18fb      	adds	r3, r7, r3
 8004470:	681b      	ldr	r3, [r3, #0]
 8004472:	2220      	movs	r2, #32
 8004474:	4013      	ands	r3, r2
 8004476:	d008      	beq.n	800448a <HAL_UART_IRQHandler+0x1ce>
      {
        if (huart->RxISR != NULL)
 8004478:	687b      	ldr	r3, [r7, #4]
 800447a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800447c:	2b00      	cmp	r3, #0
 800447e:	d004      	beq.n	800448a <HAL_UART_IRQHandler+0x1ce>
        {
          huart->RxISR(huart);
 8004480:	687b      	ldr	r3, [r7, #4]
 8004482:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8004484:	687a      	ldr	r2, [r7, #4]
 8004486:	0010      	movs	r0, r2
 8004488:	4798      	blx	r3
      /* If Error is to be considered as blocking :
          - Receiver Timeout error in Reception
          - Overrun error in Reception
          - any error occurs in DMA mode reception
      */
      errorcode = huart->ErrorCode;
 800448a:	687b      	ldr	r3, [r7, #4]
 800448c:	2280      	movs	r2, #128	; 0x80
 800448e:	589b      	ldr	r3, [r3, r2]
 8004490:	2194      	movs	r1, #148	; 0x94
 8004492:	187a      	adds	r2, r7, r1
 8004494:	6013      	str	r3, [r2, #0]
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8004496:	687b      	ldr	r3, [r7, #4]
 8004498:	681b      	ldr	r3, [r3, #0]
 800449a:	689b      	ldr	r3, [r3, #8]
 800449c:	2240      	movs	r2, #64	; 0x40
 800449e:	4013      	ands	r3, r2
 80044a0:	2b40      	cmp	r3, #64	; 0x40
 80044a2:	d004      	beq.n	80044ae <HAL_UART_IRQHandler+0x1f2>
          ((errorcode & (HAL_UART_ERROR_RTO | HAL_UART_ERROR_ORE)) != 0U))
 80044a4:	187b      	adds	r3, r7, r1
 80044a6:	681b      	ldr	r3, [r3, #0]
 80044a8:	2228      	movs	r2, #40	; 0x28
 80044aa:	4013      	ands	r3, r2
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 80044ac:	d047      	beq.n	800453e <HAL_UART_IRQHandler+0x282>
      {
        /* Blocking error : transfer is aborted
           Set the UART state ready to be able to start again the process,
           Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
        UART_EndRxTransfer(huart);
 80044ae:	687b      	ldr	r3, [r7, #4]
 80044b0:	0018      	movs	r0, r3
 80044b2:	f000 ff27 	bl	8005304 <UART_EndRxTransfer>

        /* Disable the UART DMA Rx request if enabled */
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 80044b6:	687b      	ldr	r3, [r7, #4]
 80044b8:	681b      	ldr	r3, [r3, #0]
 80044ba:	689b      	ldr	r3, [r3, #8]
 80044bc:	2240      	movs	r2, #64	; 0x40
 80044be:	4013      	ands	r3, r2
 80044c0:	2b40      	cmp	r3, #64	; 0x40
 80044c2:	d137      	bne.n	8004534 <HAL_UART_IRQHandler+0x278>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80044c4:	f3ef 8310 	mrs	r3, PRIMASK
 80044c8:	663b      	str	r3, [r7, #96]	; 0x60
  return(result);
 80044ca:	6e3b      	ldr	r3, [r7, #96]	; 0x60
        {
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 80044cc:	2090      	movs	r0, #144	; 0x90
 80044ce:	183a      	adds	r2, r7, r0
 80044d0:	6013      	str	r3, [r2, #0]
 80044d2:	2301      	movs	r3, #1
 80044d4:	667b      	str	r3, [r7, #100]	; 0x64
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80044d6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80044d8:	f383 8810 	msr	PRIMASK, r3
}
 80044dc:	46c0      	nop			; (mov r8, r8)
 80044de:	687b      	ldr	r3, [r7, #4]
 80044e0:	681b      	ldr	r3, [r3, #0]
 80044e2:	689a      	ldr	r2, [r3, #8]
 80044e4:	687b      	ldr	r3, [r7, #4]
 80044e6:	681b      	ldr	r3, [r3, #0]
 80044e8:	2140      	movs	r1, #64	; 0x40
 80044ea:	438a      	bics	r2, r1
 80044ec:	609a      	str	r2, [r3, #8]
 80044ee:	183b      	adds	r3, r7, r0
 80044f0:	681b      	ldr	r3, [r3, #0]
 80044f2:	66bb      	str	r3, [r7, #104]	; 0x68
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80044f4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80044f6:	f383 8810 	msr	PRIMASK, r3
}
 80044fa:	46c0      	nop			; (mov r8, r8)

          /* Abort the UART DMA Rx channel */
          if (huart->hdmarx != NULL)
 80044fc:	687b      	ldr	r3, [r7, #4]
 80044fe:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8004500:	2b00      	cmp	r3, #0
 8004502:	d012      	beq.n	800452a <HAL_UART_IRQHandler+0x26e>
          {
            /* Set the UART DMA Abort callback :
               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 8004504:	687b      	ldr	r3, [r7, #4]
 8004506:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8004508:	4a14      	ldr	r2, [pc, #80]	; (800455c <HAL_UART_IRQHandler+0x2a0>)
 800450a:	639a      	str	r2, [r3, #56]	; 0x38

            /* Abort DMA RX */
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 800450c:	687b      	ldr	r3, [r7, #4]
 800450e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8004510:	0018      	movs	r0, r3
 8004512:	f7fe fca5 	bl	8002e60 <HAL_DMA_Abort_IT>
 8004516:	1e03      	subs	r3, r0, #0
 8004518:	d01a      	beq.n	8004550 <HAL_UART_IRQHandler+0x294>
            {
              /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 800451a:	687b      	ldr	r3, [r7, #4]
 800451c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800451e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8004520:	687b      	ldr	r3, [r7, #4]
 8004522:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8004524:	0018      	movs	r0, r3
 8004526:	4790      	blx	r2
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8004528:	e012      	b.n	8004550 <HAL_UART_IRQHandler+0x294>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
            /*Call registered error callback*/
            huart->ErrorCallback(huart);
#else
            /*Call legacy weak error callback*/
            HAL_UART_ErrorCallback(huart);
 800452a:	687b      	ldr	r3, [r7, #4]
 800452c:	0018      	movs	r0, r3
 800452e:	f000 f9a7 	bl	8004880 <HAL_UART_ErrorCallback>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8004532:	e00d      	b.n	8004550 <HAL_UART_IRQHandler+0x294>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
          /*Call registered error callback*/
          huart->ErrorCallback(huart);
#else
          /*Call legacy weak error callback*/
          HAL_UART_ErrorCallback(huart);
 8004534:	687b      	ldr	r3, [r7, #4]
 8004536:	0018      	movs	r0, r3
 8004538:	f000 f9a2 	bl	8004880 <HAL_UART_ErrorCallback>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800453c:	e008      	b.n	8004550 <HAL_UART_IRQHandler+0x294>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered error callback*/
        huart->ErrorCallback(huart);
#else
        /*Call legacy weak error callback*/
        HAL_UART_ErrorCallback(huart);
 800453e:	687b      	ldr	r3, [r7, #4]
 8004540:	0018      	movs	r0, r3
 8004542:	f000 f99d 	bl	8004880 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 8004546:	687b      	ldr	r3, [r7, #4]
 8004548:	2280      	movs	r2, #128	; 0x80
 800454a:	2100      	movs	r1, #0
 800454c:	5099      	str	r1, [r3, r2]
      }
    }
    return;
 800454e:	e181      	b.n	8004854 <HAL_UART_IRQHandler+0x598>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8004550:	46c0      	nop			; (mov r8, r8)
    return;
 8004552:	e17f      	b.n	8004854 <HAL_UART_IRQHandler+0x598>
 8004554:	0000080f 	.word	0x0000080f
 8004558:	04000120 	.word	0x04000120
 800455c:	080053c9 	.word	0x080053c9

  } /* End if some error occurs */

  /* Check current reception Mode :
     If Reception till IDLE event has been selected : */
  if ((huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8004560:	687b      	ldr	r3, [r7, #4]
 8004562:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8004564:	2b01      	cmp	r3, #1
 8004566:	d000      	beq.n	800456a <HAL_UART_IRQHandler+0x2ae>
 8004568:	e133      	b.n	80047d2 <HAL_UART_IRQHandler+0x516>
      && ((isrflags & USART_ISR_IDLE) != 0U)
 800456a:	23a4      	movs	r3, #164	; 0xa4
 800456c:	18fb      	adds	r3, r7, r3
 800456e:	681b      	ldr	r3, [r3, #0]
 8004570:	2210      	movs	r2, #16
 8004572:	4013      	ands	r3, r2
 8004574:	d100      	bne.n	8004578 <HAL_UART_IRQHandler+0x2bc>
 8004576:	e12c      	b.n	80047d2 <HAL_UART_IRQHandler+0x516>
      && ((cr1its & USART_ISR_IDLE) != 0U))
 8004578:	23a0      	movs	r3, #160	; 0xa0
 800457a:	18fb      	adds	r3, r7, r3
 800457c:	681b      	ldr	r3, [r3, #0]
 800457e:	2210      	movs	r2, #16
 8004580:	4013      	ands	r3, r2
 8004582:	d100      	bne.n	8004586 <HAL_UART_IRQHandler+0x2ca>
 8004584:	e125      	b.n	80047d2 <HAL_UART_IRQHandler+0x516>
  {
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8004586:	687b      	ldr	r3, [r7, #4]
 8004588:	681b      	ldr	r3, [r3, #0]
 800458a:	2210      	movs	r2, #16
 800458c:	621a      	str	r2, [r3, #32]

    /* Check if DMA mode is enabled in UART */
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800458e:	687b      	ldr	r3, [r7, #4]
 8004590:	681b      	ldr	r3, [r3, #0]
 8004592:	689b      	ldr	r3, [r3, #8]
 8004594:	2240      	movs	r2, #64	; 0x40
 8004596:	4013      	ands	r3, r2
 8004598:	2b40      	cmp	r3, #64	; 0x40
 800459a:	d000      	beq.n	800459e <HAL_UART_IRQHandler+0x2e2>
 800459c:	e09d      	b.n	80046da <HAL_UART_IRQHandler+0x41e>
    {
      /* DMA mode enabled */
      /* Check received length : If all expected data are received, do nothing,
         (DMA cplt callback will be called).
         Otherwise, if at least one data has already been received, IDLE event is to be notified to user */
      uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);
 800459e:	687b      	ldr	r3, [r7, #4]
 80045a0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80045a2:	681b      	ldr	r3, [r3, #0]
 80045a4:	685a      	ldr	r2, [r3, #4]
 80045a6:	217e      	movs	r1, #126	; 0x7e
 80045a8:	187b      	adds	r3, r7, r1
 80045aa:	801a      	strh	r2, [r3, #0]
      if ((nb_remaining_rx_data > 0U)
 80045ac:	187b      	adds	r3, r7, r1
 80045ae:	881b      	ldrh	r3, [r3, #0]
 80045b0:	2b00      	cmp	r3, #0
 80045b2:	d100      	bne.n	80045b6 <HAL_UART_IRQHandler+0x2fa>
 80045b4:	e150      	b.n	8004858 <HAL_UART_IRQHandler+0x59c>
          && (nb_remaining_rx_data < huart->RxXferSize))
 80045b6:	687b      	ldr	r3, [r7, #4]
 80045b8:	2258      	movs	r2, #88	; 0x58
 80045ba:	5a9b      	ldrh	r3, [r3, r2]
 80045bc:	187a      	adds	r2, r7, r1
 80045be:	8812      	ldrh	r2, [r2, #0]
 80045c0:	429a      	cmp	r2, r3
 80045c2:	d300      	bcc.n	80045c6 <HAL_UART_IRQHandler+0x30a>
 80045c4:	e148      	b.n	8004858 <HAL_UART_IRQHandler+0x59c>
      {
        /* Reception is not complete */
        huart->RxXferCount = nb_remaining_rx_data;
 80045c6:	687b      	ldr	r3, [r7, #4]
 80045c8:	187a      	adds	r2, r7, r1
 80045ca:	215a      	movs	r1, #90	; 0x5a
 80045cc:	8812      	ldrh	r2, [r2, #0]
 80045ce:	525a      	strh	r2, [r3, r1]

        /* In Normal mode, end DMA xfer and HAL UART Rx process*/
        if (HAL_IS_BIT_CLR(huart->hdmarx->Instance->CCR, DMA_CCR_CIRC))
 80045d0:	687b      	ldr	r3, [r7, #4]
 80045d2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80045d4:	681b      	ldr	r3, [r3, #0]
 80045d6:	681b      	ldr	r3, [r3, #0]
 80045d8:	2220      	movs	r2, #32
 80045da:	4013      	ands	r3, r2
 80045dc:	d16e      	bne.n	80046bc <HAL_UART_IRQHandler+0x400>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80045de:	f3ef 8310 	mrs	r3, PRIMASK
 80045e2:	633b      	str	r3, [r7, #48]	; 0x30
  return(result);
 80045e4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
        {
          /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 80045e6:	67bb      	str	r3, [r7, #120]	; 0x78
 80045e8:	2301      	movs	r3, #1
 80045ea:	637b      	str	r3, [r7, #52]	; 0x34
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80045ec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80045ee:	f383 8810 	msr	PRIMASK, r3
}
 80045f2:	46c0      	nop			; (mov r8, r8)
 80045f4:	687b      	ldr	r3, [r7, #4]
 80045f6:	681b      	ldr	r3, [r3, #0]
 80045f8:	681a      	ldr	r2, [r3, #0]
 80045fa:	687b      	ldr	r3, [r7, #4]
 80045fc:	681b      	ldr	r3, [r3, #0]
 80045fe:	499a      	ldr	r1, [pc, #616]	; (8004868 <HAL_UART_IRQHandler+0x5ac>)
 8004600:	400a      	ands	r2, r1
 8004602:	601a      	str	r2, [r3, #0]
 8004604:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8004606:	63bb      	str	r3, [r7, #56]	; 0x38
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004608:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800460a:	f383 8810 	msr	PRIMASK, r3
}
 800460e:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004610:	f3ef 8310 	mrs	r3, PRIMASK
 8004614:	63fb      	str	r3, [r7, #60]	; 0x3c
  return(result);
 8004616:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8004618:	677b      	str	r3, [r7, #116]	; 0x74
 800461a:	2301      	movs	r3, #1
 800461c:	643b      	str	r3, [r7, #64]	; 0x40
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800461e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8004620:	f383 8810 	msr	PRIMASK, r3
}
 8004624:	46c0      	nop			; (mov r8, r8)
 8004626:	687b      	ldr	r3, [r7, #4]
 8004628:	681b      	ldr	r3, [r3, #0]
 800462a:	689a      	ldr	r2, [r3, #8]
 800462c:	687b      	ldr	r3, [r7, #4]
 800462e:	681b      	ldr	r3, [r3, #0]
 8004630:	2101      	movs	r1, #1
 8004632:	438a      	bics	r2, r1
 8004634:	609a      	str	r2, [r3, #8]
 8004636:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8004638:	647b      	str	r3, [r7, #68]	; 0x44
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800463a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800463c:	f383 8810 	msr	PRIMASK, r3
}
 8004640:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004642:	f3ef 8310 	mrs	r3, PRIMASK
 8004646:	64bb      	str	r3, [r7, #72]	; 0x48
  return(result);
 8004648:	6cbb      	ldr	r3, [r7, #72]	; 0x48

          /* Disable the DMA transfer for the receiver request by resetting the DMAR bit
             in the UART CR3 register */
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 800464a:	673b      	str	r3, [r7, #112]	; 0x70
 800464c:	2301      	movs	r3, #1
 800464e:	64fb      	str	r3, [r7, #76]	; 0x4c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004650:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8004652:	f383 8810 	msr	PRIMASK, r3
}
 8004656:	46c0      	nop			; (mov r8, r8)
 8004658:	687b      	ldr	r3, [r7, #4]
 800465a:	681b      	ldr	r3, [r3, #0]
 800465c:	689a      	ldr	r2, [r3, #8]
 800465e:	687b      	ldr	r3, [r7, #4]
 8004660:	681b      	ldr	r3, [r3, #0]
 8004662:	2140      	movs	r1, #64	; 0x40
 8004664:	438a      	bics	r2, r1
 8004666:	609a      	str	r2, [r3, #8]
 8004668:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800466a:	653b      	str	r3, [r7, #80]	; 0x50
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800466c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800466e:	f383 8810 	msr	PRIMASK, r3
}
 8004672:	46c0      	nop			; (mov r8, r8)

          /* At end of Rx process, restore huart->RxState to Ready */
          huart->RxState = HAL_UART_STATE_READY;
 8004674:	687b      	ldr	r3, [r7, #4]
 8004676:	2220      	movs	r2, #32
 8004678:	67da      	str	r2, [r3, #124]	; 0x7c
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800467a:	687b      	ldr	r3, [r7, #4]
 800467c:	2200      	movs	r2, #0
 800467e:	661a      	str	r2, [r3, #96]	; 0x60
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004680:	f3ef 8310 	mrs	r3, PRIMASK
 8004684:	657b      	str	r3, [r7, #84]	; 0x54
  return(result);
 8004686:	6d7b      	ldr	r3, [r7, #84]	; 0x54

          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8004688:	66fb      	str	r3, [r7, #108]	; 0x6c
 800468a:	2301      	movs	r3, #1
 800468c:	65bb      	str	r3, [r7, #88]	; 0x58
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800468e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8004690:	f383 8810 	msr	PRIMASK, r3
}
 8004694:	46c0      	nop			; (mov r8, r8)
 8004696:	687b      	ldr	r3, [r7, #4]
 8004698:	681b      	ldr	r3, [r3, #0]
 800469a:	681a      	ldr	r2, [r3, #0]
 800469c:	687b      	ldr	r3, [r7, #4]
 800469e:	681b      	ldr	r3, [r3, #0]
 80046a0:	2110      	movs	r1, #16
 80046a2:	438a      	bics	r2, r1
 80046a4:	601a      	str	r2, [r3, #0]
 80046a6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80046a8:	65fb      	str	r3, [r7, #92]	; 0x5c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80046aa:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80046ac:	f383 8810 	msr	PRIMASK, r3
}
 80046b0:	46c0      	nop			; (mov r8, r8)

          /* Last bytes received, so no need as the abort is immediate */
          (void)HAL_DMA_Abort(huart->hdmarx);
 80046b2:	687b      	ldr	r3, [r7, #4]
 80046b4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80046b6:	0018      	movs	r0, r3
 80046b8:	f7fe fb92 	bl	8002de0 <HAL_DMA_Abort>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
 80046bc:	687b      	ldr	r3, [r7, #4]
 80046be:	2258      	movs	r2, #88	; 0x58
 80046c0:	5a9a      	ldrh	r2, [r3, r2]
 80046c2:	687b      	ldr	r3, [r7, #4]
 80046c4:	215a      	movs	r1, #90	; 0x5a
 80046c6:	5a5b      	ldrh	r3, [r3, r1]
 80046c8:	b29b      	uxth	r3, r3
 80046ca:	1ad3      	subs	r3, r2, r3
 80046cc:	b29a      	uxth	r2, r3
 80046ce:	687b      	ldr	r3, [r7, #4]
 80046d0:	0011      	movs	r1, r2
 80046d2:	0018      	movs	r0, r3
 80046d4:	f000 f8dc 	bl	8004890 <HAL_UARTEx_RxEventCallback>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
      }
      return;
 80046d8:	e0be      	b.n	8004858 <HAL_UART_IRQHandler+0x59c>
    else
    {
      /* DMA mode not enabled */
      /* Check received length : If all expected data are received, do nothing.
         Otherwise, if at least one data has already been received, IDLE event is to be notified to user */
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 80046da:	687b      	ldr	r3, [r7, #4]
 80046dc:	2258      	movs	r2, #88	; 0x58
 80046de:	5a99      	ldrh	r1, [r3, r2]
 80046e0:	687b      	ldr	r3, [r7, #4]
 80046e2:	225a      	movs	r2, #90	; 0x5a
 80046e4:	5a9b      	ldrh	r3, [r3, r2]
 80046e6:	b29a      	uxth	r2, r3
 80046e8:	208e      	movs	r0, #142	; 0x8e
 80046ea:	183b      	adds	r3, r7, r0
 80046ec:	1a8a      	subs	r2, r1, r2
 80046ee:	801a      	strh	r2, [r3, #0]
      if ((huart->RxXferCount > 0U)
 80046f0:	687b      	ldr	r3, [r7, #4]
 80046f2:	225a      	movs	r2, #90	; 0x5a
 80046f4:	5a9b      	ldrh	r3, [r3, r2]
 80046f6:	b29b      	uxth	r3, r3
 80046f8:	2b00      	cmp	r3, #0
 80046fa:	d100      	bne.n	80046fe <HAL_UART_IRQHandler+0x442>
 80046fc:	e0ae      	b.n	800485c <HAL_UART_IRQHandler+0x5a0>
          && (nb_rx_data > 0U))
 80046fe:	183b      	adds	r3, r7, r0
 8004700:	881b      	ldrh	r3, [r3, #0]
 8004702:	2b00      	cmp	r3, #0
 8004704:	d100      	bne.n	8004708 <HAL_UART_IRQHandler+0x44c>
 8004706:	e0a9      	b.n	800485c <HAL_UART_IRQHandler+0x5a0>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004708:	f3ef 8310 	mrs	r3, PRIMASK
 800470c:	60fb      	str	r3, [r7, #12]
  return(result);
 800470e:	68fb      	ldr	r3, [r7, #12]
      {
        /* Disable the UART Parity Error Interrupt and RXNE interrupts */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8004710:	2488      	movs	r4, #136	; 0x88
 8004712:	193a      	adds	r2, r7, r4
 8004714:	6013      	str	r3, [r2, #0]
 8004716:	2301      	movs	r3, #1
 8004718:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800471a:	693b      	ldr	r3, [r7, #16]
 800471c:	f383 8810 	msr	PRIMASK, r3
}
 8004720:	46c0      	nop			; (mov r8, r8)
 8004722:	687b      	ldr	r3, [r7, #4]
 8004724:	681b      	ldr	r3, [r3, #0]
 8004726:	681a      	ldr	r2, [r3, #0]
 8004728:	687b      	ldr	r3, [r7, #4]
 800472a:	681b      	ldr	r3, [r3, #0]
 800472c:	494f      	ldr	r1, [pc, #316]	; (800486c <HAL_UART_IRQHandler+0x5b0>)
 800472e:	400a      	ands	r2, r1
 8004730:	601a      	str	r2, [r3, #0]
 8004732:	193b      	adds	r3, r7, r4
 8004734:	681b      	ldr	r3, [r3, #0]
 8004736:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004738:	697b      	ldr	r3, [r7, #20]
 800473a:	f383 8810 	msr	PRIMASK, r3
}
 800473e:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004740:	f3ef 8310 	mrs	r3, PRIMASK
 8004744:	61bb      	str	r3, [r7, #24]
  return(result);
 8004746:	69bb      	ldr	r3, [r7, #24]

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8004748:	2484      	movs	r4, #132	; 0x84
 800474a:	193a      	adds	r2, r7, r4
 800474c:	6013      	str	r3, [r2, #0]
 800474e:	2301      	movs	r3, #1
 8004750:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004752:	69fb      	ldr	r3, [r7, #28]
 8004754:	f383 8810 	msr	PRIMASK, r3
}
 8004758:	46c0      	nop			; (mov r8, r8)
 800475a:	687b      	ldr	r3, [r7, #4]
 800475c:	681b      	ldr	r3, [r3, #0]
 800475e:	689a      	ldr	r2, [r3, #8]
 8004760:	687b      	ldr	r3, [r7, #4]
 8004762:	681b      	ldr	r3, [r3, #0]
 8004764:	2101      	movs	r1, #1
 8004766:	438a      	bics	r2, r1
 8004768:	609a      	str	r2, [r3, #8]
 800476a:	193b      	adds	r3, r7, r4
 800476c:	681b      	ldr	r3, [r3, #0]
 800476e:	623b      	str	r3, [r7, #32]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004770:	6a3b      	ldr	r3, [r7, #32]
 8004772:	f383 8810 	msr	PRIMASK, r3
}
 8004776:	46c0      	nop			; (mov r8, r8)

        /* Rx process is completed, restore huart->RxState to Ready */
        huart->RxState = HAL_UART_STATE_READY;
 8004778:	687b      	ldr	r3, [r7, #4]
 800477a:	2220      	movs	r2, #32
 800477c:	67da      	str	r2, [r3, #124]	; 0x7c
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800477e:	687b      	ldr	r3, [r7, #4]
 8004780:	2200      	movs	r2, #0
 8004782:	661a      	str	r2, [r3, #96]	; 0x60

        /* Clear RxISR function pointer */
        huart->RxISR = NULL;
 8004784:	687b      	ldr	r3, [r7, #4]
 8004786:	2200      	movs	r2, #0
 8004788:	665a      	str	r2, [r3, #100]	; 0x64
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800478a:	f3ef 8310 	mrs	r3, PRIMASK
 800478e:	627b      	str	r3, [r7, #36]	; 0x24
  return(result);
 8004790:	6a7b      	ldr	r3, [r7, #36]	; 0x24

        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8004792:	2480      	movs	r4, #128	; 0x80
 8004794:	193a      	adds	r2, r7, r4
 8004796:	6013      	str	r3, [r2, #0]
 8004798:	2301      	movs	r3, #1
 800479a:	62bb      	str	r3, [r7, #40]	; 0x28
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800479c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800479e:	f383 8810 	msr	PRIMASK, r3
}
 80047a2:	46c0      	nop			; (mov r8, r8)
 80047a4:	687b      	ldr	r3, [r7, #4]
 80047a6:	681b      	ldr	r3, [r3, #0]
 80047a8:	681a      	ldr	r2, [r3, #0]
 80047aa:	687b      	ldr	r3, [r7, #4]
 80047ac:	681b      	ldr	r3, [r3, #0]
 80047ae:	2110      	movs	r1, #16
 80047b0:	438a      	bics	r2, r1
 80047b2:	601a      	str	r2, [r3, #0]
 80047b4:	193b      	adds	r3, r7, r4
 80047b6:	681b      	ldr	r3, [r3, #0]
 80047b8:	62fb      	str	r3, [r7, #44]	; 0x2c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80047ba:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80047bc:	f383 8810 	msr	PRIMASK, r3
}
 80047c0:	46c0      	nop			; (mov r8, r8)
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx complete callback*/
        huart->RxEventCallback(huart, nb_rx_data);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, nb_rx_data);
 80047c2:	183b      	adds	r3, r7, r0
 80047c4:	881a      	ldrh	r2, [r3, #0]
 80047c6:	687b      	ldr	r3, [r7, #4]
 80047c8:	0011      	movs	r1, r2
 80047ca:	0018      	movs	r0, r3
 80047cc:	f000 f860 	bl	8004890 <HAL_UARTEx_RxEventCallback>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
      }
      return;
 80047d0:	e044      	b.n	800485c <HAL_UART_IRQHandler+0x5a0>
    }
  }

  /* UART wakeup from Stop mode interrupt occurred ---------------------------*/
  if (((isrflags & USART_ISR_WUF) != 0U) && ((cr3its & USART_CR3_WUFIE) != 0U))
 80047d2:	23a4      	movs	r3, #164	; 0xa4
 80047d4:	18fb      	adds	r3, r7, r3
 80047d6:	681a      	ldr	r2, [r3, #0]
 80047d8:	2380      	movs	r3, #128	; 0x80
 80047da:	035b      	lsls	r3, r3, #13
 80047dc:	4013      	ands	r3, r2
 80047de:	d010      	beq.n	8004802 <HAL_UART_IRQHandler+0x546>
 80047e0:	239c      	movs	r3, #156	; 0x9c
 80047e2:	18fb      	adds	r3, r7, r3
 80047e4:	681a      	ldr	r2, [r3, #0]
 80047e6:	2380      	movs	r3, #128	; 0x80
 80047e8:	03db      	lsls	r3, r3, #15
 80047ea:	4013      	ands	r3, r2
 80047ec:	d009      	beq.n	8004802 <HAL_UART_IRQHandler+0x546>
  {
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
 80047ee:	687b      	ldr	r3, [r7, #4]
 80047f0:	681b      	ldr	r3, [r3, #0]
 80047f2:	2280      	movs	r2, #128	; 0x80
 80047f4:	0352      	lsls	r2, r2, #13
 80047f6:	621a      	str	r2, [r3, #32]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    /* Call registered Wakeup Callback */
    huart->WakeupCallback(huart);
#else
    /* Call legacy weak Wakeup Callback */
    HAL_UARTEx_WakeupCallback(huart);
 80047f8:	687b      	ldr	r3, [r7, #4]
 80047fa:	0018      	movs	r0, r3
 80047fc:	f000 ff8e 	bl	800571c <HAL_UARTEx_WakeupCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
    return;
 8004800:	e02f      	b.n	8004862 <HAL_UART_IRQHandler+0x5a6>
  }

  /* UART in mode Transmitter ------------------------------------------------*/
  if (((isrflags & USART_ISR_TXE) != 0U)
 8004802:	23a4      	movs	r3, #164	; 0xa4
 8004804:	18fb      	adds	r3, r7, r3
 8004806:	681b      	ldr	r3, [r3, #0]
 8004808:	2280      	movs	r2, #128	; 0x80
 800480a:	4013      	ands	r3, r2
 800480c:	d00f      	beq.n	800482e <HAL_UART_IRQHandler+0x572>
      && ((cr1its & USART_CR1_TXEIE) != 0U))
 800480e:	23a0      	movs	r3, #160	; 0xa0
 8004810:	18fb      	adds	r3, r7, r3
 8004812:	681b      	ldr	r3, [r3, #0]
 8004814:	2280      	movs	r2, #128	; 0x80
 8004816:	4013      	ands	r3, r2
 8004818:	d009      	beq.n	800482e <HAL_UART_IRQHandler+0x572>
  {
    if (huart->TxISR != NULL)
 800481a:	687b      	ldr	r3, [r7, #4]
 800481c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800481e:	2b00      	cmp	r3, #0
 8004820:	d01e      	beq.n	8004860 <HAL_UART_IRQHandler+0x5a4>
    {
      huart->TxISR(huart);
 8004822:	687b      	ldr	r3, [r7, #4]
 8004824:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8004826:	687a      	ldr	r2, [r7, #4]
 8004828:	0010      	movs	r0, r2
 800482a:	4798      	blx	r3
    }
    return;
 800482c:	e018      	b.n	8004860 <HAL_UART_IRQHandler+0x5a4>
  }

  /* UART in mode Transmitter (transmission end) -----------------------------*/
  if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
 800482e:	23a4      	movs	r3, #164	; 0xa4
 8004830:	18fb      	adds	r3, r7, r3
 8004832:	681b      	ldr	r3, [r3, #0]
 8004834:	2240      	movs	r2, #64	; 0x40
 8004836:	4013      	ands	r3, r2
 8004838:	d013      	beq.n	8004862 <HAL_UART_IRQHandler+0x5a6>
 800483a:	23a0      	movs	r3, #160	; 0xa0
 800483c:	18fb      	adds	r3, r7, r3
 800483e:	681b      	ldr	r3, [r3, #0]
 8004840:	2240      	movs	r2, #64	; 0x40
 8004842:	4013      	ands	r3, r2
 8004844:	d00d      	beq.n	8004862 <HAL_UART_IRQHandler+0x5a6>
  {
    UART_EndTransmit_IT(huart);
 8004846:	687b      	ldr	r3, [r7, #4]
 8004848:	0018      	movs	r0, r3
 800484a:	f000 fdd4 	bl	80053f6 <UART_EndTransmit_IT>
    return;
 800484e:	e008      	b.n	8004862 <HAL_UART_IRQHandler+0x5a6>
      return;
 8004850:	46c0      	nop			; (mov r8, r8)
 8004852:	e006      	b.n	8004862 <HAL_UART_IRQHandler+0x5a6>
    return;
 8004854:	46c0      	nop			; (mov r8, r8)
 8004856:	e004      	b.n	8004862 <HAL_UART_IRQHandler+0x5a6>
      return;
 8004858:	46c0      	nop			; (mov r8, r8)
 800485a:	e002      	b.n	8004862 <HAL_UART_IRQHandler+0x5a6>
      return;
 800485c:	46c0      	nop			; (mov r8, r8)
 800485e:	e000      	b.n	8004862 <HAL_UART_IRQHandler+0x5a6>
    return;
 8004860:	46c0      	nop			; (mov r8, r8)
  }

}
 8004862:	46bd      	mov	sp, r7
 8004864:	b02b      	add	sp, #172	; 0xac
 8004866:	bd90      	pop	{r4, r7, pc}
 8004868:	fffffeff 	.word	0xfffffeff
 800486c:	fffffedf 	.word	0xfffffedf

08004870 <HAL_UART_TxCpltCallback>:
  * @brief Tx Transfer completed callback.
  * @param huart UART handle.
  * @retval None
  */
__weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
 8004870:	b580      	push	{r7, lr}
 8004872:	b082      	sub	sp, #8
 8004874:	af00      	add	r7, sp, #0
 8004876:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_TxCpltCallback can be implemented in the user file.
   */
}
 8004878:	46c0      	nop			; (mov r8, r8)
 800487a:	46bd      	mov	sp, r7
 800487c:	b002      	add	sp, #8
 800487e:	bd80      	pop	{r7, pc}

08004880 <HAL_UART_ErrorCallback>:
  * @brief  UART error callback.
  * @param  huart UART handle.
  * @retval None
  */
__weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
 8004880:	b580      	push	{r7, lr}
 8004882:	b082      	sub	sp, #8
 8004884:	af00      	add	r7, sp, #0
 8004886:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_ErrorCallback can be implemented in the user file.
   */
}
 8004888:	46c0      	nop			; (mov r8, r8)
 800488a:	46bd      	mov	sp, r7
 800488c:	b002      	add	sp, #8
 800488e:	bd80      	pop	{r7, pc}

08004890 <HAL_UARTEx_RxEventCallback>:
  * @param  Size  Number of data available in application reception buffer (indicates a position in
  *               reception buffer until which, data are available)
  * @retval None
  */
__weak void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
{
 8004890:	b580      	push	{r7, lr}
 8004892:	b082      	sub	sp, #8
 8004894:	af00      	add	r7, sp, #0
 8004896:	6078      	str	r0, [r7, #4]
 8004898:	000a      	movs	r2, r1
 800489a:	1cbb      	adds	r3, r7, #2
 800489c:	801a      	strh	r2, [r3, #0]
  UNUSED(Size);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_RxEventCallback can be implemented in the user file.
   */
}
 800489e:	46c0      	nop			; (mov r8, r8)
 80048a0:	46bd      	mov	sp, r7
 80048a2:	b002      	add	sp, #8
 80048a4:	bd80      	pop	{r7, pc}
	...

080048a8 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 80048a8:	b5b0      	push	{r4, r5, r7, lr}
 80048aa:	b08e      	sub	sp, #56	; 0x38
 80048ac:	af00      	add	r7, sp, #0
 80048ae:	61f8      	str	r0, [r7, #28]
  uint32_t tmpreg;
  uint16_t brrtemp;
  UART_ClockSourceTypeDef clocksource;
  uint32_t usartdiv;
  HAL_StatusTypeDef ret               = HAL_OK;
 80048b0:	231a      	movs	r3, #26
 80048b2:	2218      	movs	r2, #24
 80048b4:	4694      	mov	ip, r2
 80048b6:	44bc      	add	ip, r7
 80048b8:	4463      	add	r3, ip
 80048ba:	2200      	movs	r2, #0
 80048bc:	701a      	strb	r2, [r3, #0]
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80048be:	69fb      	ldr	r3, [r7, #28]
 80048c0:	689a      	ldr	r2, [r3, #8]
 80048c2:	69fb      	ldr	r3, [r7, #28]
 80048c4:	691b      	ldr	r3, [r3, #16]
 80048c6:	431a      	orrs	r2, r3
 80048c8:	69fb      	ldr	r3, [r7, #28]
 80048ca:	695b      	ldr	r3, [r3, #20]
 80048cc:	431a      	orrs	r2, r3
 80048ce:	69fb      	ldr	r3, [r7, #28]
 80048d0:	69db      	ldr	r3, [r3, #28]
 80048d2:	4313      	orrs	r3, r2
 80048d4:	637b      	str	r3, [r7, #52]	; 0x34
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80048d6:	69fb      	ldr	r3, [r7, #28]
 80048d8:	681b      	ldr	r3, [r3, #0]
 80048da:	681b      	ldr	r3, [r3, #0]
 80048dc:	4ab0      	ldr	r2, [pc, #704]	; (8004ba0 <UART_SetConfig+0x2f8>)
 80048de:	4013      	ands	r3, r2
 80048e0:	0019      	movs	r1, r3
 80048e2:	69fb      	ldr	r3, [r7, #28]
 80048e4:	681b      	ldr	r3, [r3, #0]
 80048e6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80048e8:	430a      	orrs	r2, r1
 80048ea:	601a      	str	r2, [r3, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80048ec:	69fb      	ldr	r3, [r7, #28]
 80048ee:	681b      	ldr	r3, [r3, #0]
 80048f0:	685b      	ldr	r3, [r3, #4]
 80048f2:	4aac      	ldr	r2, [pc, #688]	; (8004ba4 <UART_SetConfig+0x2fc>)
 80048f4:	4013      	ands	r3, r2
 80048f6:	0019      	movs	r1, r3
 80048f8:	69fb      	ldr	r3, [r7, #28]
 80048fa:	68da      	ldr	r2, [r3, #12]
 80048fc:	69fb      	ldr	r3, [r7, #28]
 80048fe:	681b      	ldr	r3, [r3, #0]
 8004900:	430a      	orrs	r2, r1
 8004902:	605a      	str	r2, [r3, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 8004904:	69fb      	ldr	r3, [r7, #28]
 8004906:	699b      	ldr	r3, [r3, #24]
 8004908:	637b      	str	r3, [r7, #52]	; 0x34

  if (!(UART_INSTANCE_LOWPOWER(huart)))
 800490a:	69fb      	ldr	r3, [r7, #28]
 800490c:	681b      	ldr	r3, [r3, #0]
 800490e:	4aa6      	ldr	r2, [pc, #664]	; (8004ba8 <UART_SetConfig+0x300>)
 8004910:	4293      	cmp	r3, r2
 8004912:	d004      	beq.n	800491e <UART_SetConfig+0x76>
  {
    tmpreg |= huart->Init.OneBitSampling;
 8004914:	69fb      	ldr	r3, [r7, #28]
 8004916:	6a1b      	ldr	r3, [r3, #32]
 8004918:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800491a:	4313      	orrs	r3, r2
 800491c:	637b      	str	r3, [r7, #52]	; 0x34
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 800491e:	69fb      	ldr	r3, [r7, #28]
 8004920:	681b      	ldr	r3, [r3, #0]
 8004922:	689b      	ldr	r3, [r3, #8]
 8004924:	4aa1      	ldr	r2, [pc, #644]	; (8004bac <UART_SetConfig+0x304>)
 8004926:	4013      	ands	r3, r2
 8004928:	0019      	movs	r1, r3
 800492a:	69fb      	ldr	r3, [r7, #28]
 800492c:	681b      	ldr	r3, [r3, #0]
 800492e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8004930:	430a      	orrs	r2, r1
 8004932:	609a      	str	r2, [r3, #8]


  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 8004934:	69fb      	ldr	r3, [r7, #28]
 8004936:	681b      	ldr	r3, [r3, #0]
 8004938:	4a9d      	ldr	r2, [pc, #628]	; (8004bb0 <UART_SetConfig+0x308>)
 800493a:	4293      	cmp	r3, r2
 800493c:	d136      	bne.n	80049ac <UART_SetConfig+0x104>
 800493e:	4b9d      	ldr	r3, [pc, #628]	; (8004bb4 <UART_SetConfig+0x30c>)
 8004940:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8004942:	2203      	movs	r2, #3
 8004944:	4013      	ands	r3, r2
 8004946:	2b03      	cmp	r3, #3
 8004948:	d020      	beq.n	800498c <UART_SetConfig+0xe4>
 800494a:	d827      	bhi.n	800499c <UART_SetConfig+0xf4>
 800494c:	2b02      	cmp	r3, #2
 800494e:	d00d      	beq.n	800496c <UART_SetConfig+0xc4>
 8004950:	d824      	bhi.n	800499c <UART_SetConfig+0xf4>
 8004952:	2b00      	cmp	r3, #0
 8004954:	d002      	beq.n	800495c <UART_SetConfig+0xb4>
 8004956:	2b01      	cmp	r3, #1
 8004958:	d010      	beq.n	800497c <UART_SetConfig+0xd4>
 800495a:	e01f      	b.n	800499c <UART_SetConfig+0xf4>
 800495c:	231b      	movs	r3, #27
 800495e:	2218      	movs	r2, #24
 8004960:	4694      	mov	ip, r2
 8004962:	44bc      	add	ip, r7
 8004964:	4463      	add	r3, ip
 8004966:	2201      	movs	r2, #1
 8004968:	701a      	strb	r2, [r3, #0]
 800496a:	e0c5      	b.n	8004af8 <UART_SetConfig+0x250>
 800496c:	231b      	movs	r3, #27
 800496e:	2218      	movs	r2, #24
 8004970:	4694      	mov	ip, r2
 8004972:	44bc      	add	ip, r7
 8004974:	4463      	add	r3, ip
 8004976:	2202      	movs	r2, #2
 8004978:	701a      	strb	r2, [r3, #0]
 800497a:	e0bd      	b.n	8004af8 <UART_SetConfig+0x250>
 800497c:	231b      	movs	r3, #27
 800497e:	2218      	movs	r2, #24
 8004980:	4694      	mov	ip, r2
 8004982:	44bc      	add	ip, r7
 8004984:	4463      	add	r3, ip
 8004986:	2204      	movs	r2, #4
 8004988:	701a      	strb	r2, [r3, #0]
 800498a:	e0b5      	b.n	8004af8 <UART_SetConfig+0x250>
 800498c:	231b      	movs	r3, #27
 800498e:	2218      	movs	r2, #24
 8004990:	4694      	mov	ip, r2
 8004992:	44bc      	add	ip, r7
 8004994:	4463      	add	r3, ip
 8004996:	2208      	movs	r2, #8
 8004998:	701a      	strb	r2, [r3, #0]
 800499a:	e0ad      	b.n	8004af8 <UART_SetConfig+0x250>
 800499c:	231b      	movs	r3, #27
 800499e:	2218      	movs	r2, #24
 80049a0:	4694      	mov	ip, r2
 80049a2:	44bc      	add	ip, r7
 80049a4:	4463      	add	r3, ip
 80049a6:	2210      	movs	r2, #16
 80049a8:	701a      	strb	r2, [r3, #0]
 80049aa:	e0a5      	b.n	8004af8 <UART_SetConfig+0x250>
 80049ac:	69fb      	ldr	r3, [r7, #28]
 80049ae:	681b      	ldr	r3, [r3, #0]
 80049b0:	4a81      	ldr	r2, [pc, #516]	; (8004bb8 <UART_SetConfig+0x310>)
 80049b2:	4293      	cmp	r3, r2
 80049b4:	d136      	bne.n	8004a24 <UART_SetConfig+0x17c>
 80049b6:	4b7f      	ldr	r3, [pc, #508]	; (8004bb4 <UART_SetConfig+0x30c>)
 80049b8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80049ba:	220c      	movs	r2, #12
 80049bc:	4013      	ands	r3, r2
 80049be:	2b0c      	cmp	r3, #12
 80049c0:	d020      	beq.n	8004a04 <UART_SetConfig+0x15c>
 80049c2:	d827      	bhi.n	8004a14 <UART_SetConfig+0x16c>
 80049c4:	2b08      	cmp	r3, #8
 80049c6:	d00d      	beq.n	80049e4 <UART_SetConfig+0x13c>
 80049c8:	d824      	bhi.n	8004a14 <UART_SetConfig+0x16c>
 80049ca:	2b00      	cmp	r3, #0
 80049cc:	d002      	beq.n	80049d4 <UART_SetConfig+0x12c>
 80049ce:	2b04      	cmp	r3, #4
 80049d0:	d010      	beq.n	80049f4 <UART_SetConfig+0x14c>
 80049d2:	e01f      	b.n	8004a14 <UART_SetConfig+0x16c>
 80049d4:	231b      	movs	r3, #27
 80049d6:	2218      	movs	r2, #24
 80049d8:	4694      	mov	ip, r2
 80049da:	44bc      	add	ip, r7
 80049dc:	4463      	add	r3, ip
 80049de:	2200      	movs	r2, #0
 80049e0:	701a      	strb	r2, [r3, #0]
 80049e2:	e089      	b.n	8004af8 <UART_SetConfig+0x250>
 80049e4:	231b      	movs	r3, #27
 80049e6:	2218      	movs	r2, #24
 80049e8:	4694      	mov	ip, r2
 80049ea:	44bc      	add	ip, r7
 80049ec:	4463      	add	r3, ip
 80049ee:	2202      	movs	r2, #2
 80049f0:	701a      	strb	r2, [r3, #0]
 80049f2:	e081      	b.n	8004af8 <UART_SetConfig+0x250>
 80049f4:	231b      	movs	r3, #27
 80049f6:	2218      	movs	r2, #24
 80049f8:	4694      	mov	ip, r2
 80049fa:	44bc      	add	ip, r7
 80049fc:	4463      	add	r3, ip
 80049fe:	2204      	movs	r2, #4
 8004a00:	701a      	strb	r2, [r3, #0]
 8004a02:	e079      	b.n	8004af8 <UART_SetConfig+0x250>
 8004a04:	231b      	movs	r3, #27
 8004a06:	2218      	movs	r2, #24
 8004a08:	4694      	mov	ip, r2
 8004a0a:	44bc      	add	ip, r7
 8004a0c:	4463      	add	r3, ip
 8004a0e:	2208      	movs	r2, #8
 8004a10:	701a      	strb	r2, [r3, #0]
 8004a12:	e071      	b.n	8004af8 <UART_SetConfig+0x250>
 8004a14:	231b      	movs	r3, #27
 8004a16:	2218      	movs	r2, #24
 8004a18:	4694      	mov	ip, r2
 8004a1a:	44bc      	add	ip, r7
 8004a1c:	4463      	add	r3, ip
 8004a1e:	2210      	movs	r2, #16
 8004a20:	701a      	strb	r2, [r3, #0]
 8004a22:	e069      	b.n	8004af8 <UART_SetConfig+0x250>
 8004a24:	69fb      	ldr	r3, [r7, #28]
 8004a26:	681b      	ldr	r3, [r3, #0]
 8004a28:	4a64      	ldr	r2, [pc, #400]	; (8004bbc <UART_SetConfig+0x314>)
 8004a2a:	4293      	cmp	r3, r2
 8004a2c:	d107      	bne.n	8004a3e <UART_SetConfig+0x196>
 8004a2e:	231b      	movs	r3, #27
 8004a30:	2218      	movs	r2, #24
 8004a32:	4694      	mov	ip, r2
 8004a34:	44bc      	add	ip, r7
 8004a36:	4463      	add	r3, ip
 8004a38:	2200      	movs	r2, #0
 8004a3a:	701a      	strb	r2, [r3, #0]
 8004a3c:	e05c      	b.n	8004af8 <UART_SetConfig+0x250>
 8004a3e:	69fb      	ldr	r3, [r7, #28]
 8004a40:	681b      	ldr	r3, [r3, #0]
 8004a42:	4a5f      	ldr	r2, [pc, #380]	; (8004bc0 <UART_SetConfig+0x318>)
 8004a44:	4293      	cmp	r3, r2
 8004a46:	d107      	bne.n	8004a58 <UART_SetConfig+0x1b0>
 8004a48:	231b      	movs	r3, #27
 8004a4a:	2218      	movs	r2, #24
 8004a4c:	4694      	mov	ip, r2
 8004a4e:	44bc      	add	ip, r7
 8004a50:	4463      	add	r3, ip
 8004a52:	2200      	movs	r2, #0
 8004a54:	701a      	strb	r2, [r3, #0]
 8004a56:	e04f      	b.n	8004af8 <UART_SetConfig+0x250>
 8004a58:	69fb      	ldr	r3, [r7, #28]
 8004a5a:	681b      	ldr	r3, [r3, #0]
 8004a5c:	4a52      	ldr	r2, [pc, #328]	; (8004ba8 <UART_SetConfig+0x300>)
 8004a5e:	4293      	cmp	r3, r2
 8004a60:	d143      	bne.n	8004aea <UART_SetConfig+0x242>
 8004a62:	4b54      	ldr	r3, [pc, #336]	; (8004bb4 <UART_SetConfig+0x30c>)
 8004a64:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8004a66:	23c0      	movs	r3, #192	; 0xc0
 8004a68:	011b      	lsls	r3, r3, #4
 8004a6a:	4013      	ands	r3, r2
 8004a6c:	22c0      	movs	r2, #192	; 0xc0
 8004a6e:	0112      	lsls	r2, r2, #4
 8004a70:	4293      	cmp	r3, r2
 8004a72:	d02a      	beq.n	8004aca <UART_SetConfig+0x222>
 8004a74:	22c0      	movs	r2, #192	; 0xc0
 8004a76:	0112      	lsls	r2, r2, #4
 8004a78:	4293      	cmp	r3, r2
 8004a7a:	d82e      	bhi.n	8004ada <UART_SetConfig+0x232>
 8004a7c:	2280      	movs	r2, #128	; 0x80
 8004a7e:	0112      	lsls	r2, r2, #4
 8004a80:	4293      	cmp	r3, r2
 8004a82:	d012      	beq.n	8004aaa <UART_SetConfig+0x202>
 8004a84:	2280      	movs	r2, #128	; 0x80
 8004a86:	0112      	lsls	r2, r2, #4
 8004a88:	4293      	cmp	r3, r2
 8004a8a:	d826      	bhi.n	8004ada <UART_SetConfig+0x232>
 8004a8c:	2b00      	cmp	r3, #0
 8004a8e:	d004      	beq.n	8004a9a <UART_SetConfig+0x1f2>
 8004a90:	2280      	movs	r2, #128	; 0x80
 8004a92:	00d2      	lsls	r2, r2, #3
 8004a94:	4293      	cmp	r3, r2
 8004a96:	d010      	beq.n	8004aba <UART_SetConfig+0x212>
 8004a98:	e01f      	b.n	8004ada <UART_SetConfig+0x232>
 8004a9a:	231b      	movs	r3, #27
 8004a9c:	2218      	movs	r2, #24
 8004a9e:	4694      	mov	ip, r2
 8004aa0:	44bc      	add	ip, r7
 8004aa2:	4463      	add	r3, ip
 8004aa4:	2200      	movs	r2, #0
 8004aa6:	701a      	strb	r2, [r3, #0]
 8004aa8:	e026      	b.n	8004af8 <UART_SetConfig+0x250>
 8004aaa:	231b      	movs	r3, #27
 8004aac:	2218      	movs	r2, #24
 8004aae:	4694      	mov	ip, r2
 8004ab0:	44bc      	add	ip, r7
 8004ab2:	4463      	add	r3, ip
 8004ab4:	2202      	movs	r2, #2
 8004ab6:	701a      	strb	r2, [r3, #0]
 8004ab8:	e01e      	b.n	8004af8 <UART_SetConfig+0x250>
 8004aba:	231b      	movs	r3, #27
 8004abc:	2218      	movs	r2, #24
 8004abe:	4694      	mov	ip, r2
 8004ac0:	44bc      	add	ip, r7
 8004ac2:	4463      	add	r3, ip
 8004ac4:	2204      	movs	r2, #4
 8004ac6:	701a      	strb	r2, [r3, #0]
 8004ac8:	e016      	b.n	8004af8 <UART_SetConfig+0x250>
 8004aca:	231b      	movs	r3, #27
 8004acc:	2218      	movs	r2, #24
 8004ace:	4694      	mov	ip, r2
 8004ad0:	44bc      	add	ip, r7
 8004ad2:	4463      	add	r3, ip
 8004ad4:	2208      	movs	r2, #8
 8004ad6:	701a      	strb	r2, [r3, #0]
 8004ad8:	e00e      	b.n	8004af8 <UART_SetConfig+0x250>
 8004ada:	231b      	movs	r3, #27
 8004adc:	2218      	movs	r2, #24
 8004ade:	4694      	mov	ip, r2
 8004ae0:	44bc      	add	ip, r7
 8004ae2:	4463      	add	r3, ip
 8004ae4:	2210      	movs	r2, #16
 8004ae6:	701a      	strb	r2, [r3, #0]
 8004ae8:	e006      	b.n	8004af8 <UART_SetConfig+0x250>
 8004aea:	231b      	movs	r3, #27
 8004aec:	2218      	movs	r2, #24
 8004aee:	4694      	mov	ip, r2
 8004af0:	44bc      	add	ip, r7
 8004af2:	4463      	add	r3, ip
 8004af4:	2210      	movs	r2, #16
 8004af6:	701a      	strb	r2, [r3, #0]

  /* Check LPUART instance */
  if (UART_INSTANCE_LOWPOWER(huart))
 8004af8:	69fb      	ldr	r3, [r7, #28]
 8004afa:	681b      	ldr	r3, [r3, #0]
 8004afc:	4a2a      	ldr	r2, [pc, #168]	; (8004ba8 <UART_SetConfig+0x300>)
 8004afe:	4293      	cmp	r3, r2
 8004b00:	d000      	beq.n	8004b04 <UART_SetConfig+0x25c>
 8004b02:	e09e      	b.n	8004c42 <UART_SetConfig+0x39a>
  {
    /* Retrieve frequency clock */
    switch (clocksource)
 8004b04:	231b      	movs	r3, #27
 8004b06:	2218      	movs	r2, #24
 8004b08:	4694      	mov	ip, r2
 8004b0a:	44bc      	add	ip, r7
 8004b0c:	4463      	add	r3, ip
 8004b0e:	781b      	ldrb	r3, [r3, #0]
 8004b10:	2b08      	cmp	r3, #8
 8004b12:	d01d      	beq.n	8004b50 <UART_SetConfig+0x2a8>
 8004b14:	dc20      	bgt.n	8004b58 <UART_SetConfig+0x2b0>
 8004b16:	2b04      	cmp	r3, #4
 8004b18:	d015      	beq.n	8004b46 <UART_SetConfig+0x29e>
 8004b1a:	dc1d      	bgt.n	8004b58 <UART_SetConfig+0x2b0>
 8004b1c:	2b00      	cmp	r3, #0
 8004b1e:	d002      	beq.n	8004b26 <UART_SetConfig+0x27e>
 8004b20:	2b02      	cmp	r3, #2
 8004b22:	d005      	beq.n	8004b30 <UART_SetConfig+0x288>
 8004b24:	e018      	b.n	8004b58 <UART_SetConfig+0x2b0>
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 8004b26:	f7ff f8f3 	bl	8003d10 <HAL_RCC_GetPCLK1Freq>
 8004b2a:	0003      	movs	r3, r0
 8004b2c:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004b2e:	e01d      	b.n	8004b6c <UART_SetConfig+0x2c4>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8004b30:	4b20      	ldr	r3, [pc, #128]	; (8004bb4 <UART_SetConfig+0x30c>)
 8004b32:	681b      	ldr	r3, [r3, #0]
 8004b34:	2210      	movs	r2, #16
 8004b36:	4013      	ands	r3, r2
 8004b38:	d002      	beq.n	8004b40 <UART_SetConfig+0x298>
        {
          pclk = (uint32_t)(HSI_VALUE >> 2U);
 8004b3a:	4b22      	ldr	r3, [pc, #136]	; (8004bc4 <UART_SetConfig+0x31c>)
 8004b3c:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
 8004b3e:	e015      	b.n	8004b6c <UART_SetConfig+0x2c4>
          pclk = (uint32_t) HSI_VALUE;
 8004b40:	4b21      	ldr	r3, [pc, #132]	; (8004bc8 <UART_SetConfig+0x320>)
 8004b42:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004b44:	e012      	b.n	8004b6c <UART_SetConfig+0x2c4>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
 8004b46:	f7ff f833 	bl	8003bb0 <HAL_RCC_GetSysClockFreq>
 8004b4a:	0003      	movs	r3, r0
 8004b4c:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004b4e:	e00d      	b.n	8004b6c <UART_SetConfig+0x2c4>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 8004b50:	2380      	movs	r3, #128	; 0x80
 8004b52:	021b      	lsls	r3, r3, #8
 8004b54:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004b56:	e009      	b.n	8004b6c <UART_SetConfig+0x2c4>
      default:
        pclk = 0U;
 8004b58:	2300      	movs	r3, #0
 8004b5a:	62fb      	str	r3, [r7, #44]	; 0x2c
        ret = HAL_ERROR;
 8004b5c:	231a      	movs	r3, #26
 8004b5e:	2218      	movs	r2, #24
 8004b60:	4694      	mov	ip, r2
 8004b62:	44bc      	add	ip, r7
 8004b64:	4463      	add	r3, ip
 8004b66:	2201      	movs	r2, #1
 8004b68:	701a      	strb	r2, [r3, #0]
        break;
 8004b6a:	46c0      	nop			; (mov r8, r8)
    }

    /* If proper clock source reported */
    if (pclk != 0U)
 8004b6c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004b6e:	2b00      	cmp	r3, #0
 8004b70:	d100      	bne.n	8004b74 <UART_SetConfig+0x2cc>
 8004b72:	e13c      	b.n	8004dee <UART_SetConfig+0x546>
    {
      /* No Prescaler applicable */
      /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ((pclk < (3U * huart->Init.BaudRate)) ||
 8004b74:	69fb      	ldr	r3, [r7, #28]
 8004b76:	685a      	ldr	r2, [r3, #4]
 8004b78:	0013      	movs	r3, r2
 8004b7a:	005b      	lsls	r3, r3, #1
 8004b7c:	189b      	adds	r3, r3, r2
 8004b7e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004b80:	429a      	cmp	r2, r3
 8004b82:	d305      	bcc.n	8004b90 <UART_SetConfig+0x2e8>
          (pclk > (4096U * huart->Init.BaudRate)))
 8004b84:	69fb      	ldr	r3, [r7, #28]
 8004b86:	685b      	ldr	r3, [r3, #4]
 8004b88:	031b      	lsls	r3, r3, #12
      if ((pclk < (3U * huart->Init.BaudRate)) ||
 8004b8a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004b8c:	429a      	cmp	r2, r3
 8004b8e:	d91d      	bls.n	8004bcc <UART_SetConfig+0x324>
      {
        ret = HAL_ERROR;
 8004b90:	231a      	movs	r3, #26
 8004b92:	2218      	movs	r2, #24
 8004b94:	4694      	mov	ip, r2
 8004b96:	44bc      	add	ip, r7
 8004b98:	4463      	add	r3, ip
 8004b9a:	2201      	movs	r2, #1
 8004b9c:	701a      	strb	r2, [r3, #0]
 8004b9e:	e126      	b.n	8004dee <UART_SetConfig+0x546>
 8004ba0:	efff69f3 	.word	0xefff69f3
 8004ba4:	ffffcfff 	.word	0xffffcfff
 8004ba8:	40004800 	.word	0x40004800
 8004bac:	fffff4ff 	.word	0xfffff4ff
 8004bb0:	40013800 	.word	0x40013800
 8004bb4:	40021000 	.word	0x40021000
 8004bb8:	40004400 	.word	0x40004400
 8004bbc:	40004c00 	.word	0x40004c00
 8004bc0:	40005000 	.word	0x40005000
 8004bc4:	003d0900 	.word	0x003d0900
 8004bc8:	00f42400 	.word	0x00f42400
      }
      else
      {
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate));
 8004bcc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004bce:	613b      	str	r3, [r7, #16]
 8004bd0:	2300      	movs	r3, #0
 8004bd2:	617b      	str	r3, [r7, #20]
 8004bd4:	6939      	ldr	r1, [r7, #16]
 8004bd6:	697a      	ldr	r2, [r7, #20]
 8004bd8:	000b      	movs	r3, r1
 8004bda:	0e1b      	lsrs	r3, r3, #24
 8004bdc:	0010      	movs	r0, r2
 8004bde:	0205      	lsls	r5, r0, #8
 8004be0:	431d      	orrs	r5, r3
 8004be2:	000b      	movs	r3, r1
 8004be4:	021c      	lsls	r4, r3, #8
 8004be6:	69fb      	ldr	r3, [r7, #28]
 8004be8:	685b      	ldr	r3, [r3, #4]
 8004bea:	085b      	lsrs	r3, r3, #1
 8004bec:	60bb      	str	r3, [r7, #8]
 8004bee:	2300      	movs	r3, #0
 8004bf0:	60fb      	str	r3, [r7, #12]
 8004bf2:	68b8      	ldr	r0, [r7, #8]
 8004bf4:	68f9      	ldr	r1, [r7, #12]
 8004bf6:	1900      	adds	r0, r0, r4
 8004bf8:	4169      	adcs	r1, r5
 8004bfa:	69fb      	ldr	r3, [r7, #28]
 8004bfc:	685b      	ldr	r3, [r3, #4]
 8004bfe:	603b      	str	r3, [r7, #0]
 8004c00:	2300      	movs	r3, #0
 8004c02:	607b      	str	r3, [r7, #4]
 8004c04:	683a      	ldr	r2, [r7, #0]
 8004c06:	687b      	ldr	r3, [r7, #4]
 8004c08:	f7fb fb1c 	bl	8000244 <__aeabi_uldivmod>
 8004c0c:	0002      	movs	r2, r0
 8004c0e:	000b      	movs	r3, r1
 8004c10:	0013      	movs	r3, r2
 8004c12:	62bb      	str	r3, [r7, #40]	; 0x28
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 8004c14:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8004c16:	23c0      	movs	r3, #192	; 0xc0
 8004c18:	009b      	lsls	r3, r3, #2
 8004c1a:	429a      	cmp	r2, r3
 8004c1c:	d309      	bcc.n	8004c32 <UART_SetConfig+0x38a>
 8004c1e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8004c20:	2380      	movs	r3, #128	; 0x80
 8004c22:	035b      	lsls	r3, r3, #13
 8004c24:	429a      	cmp	r2, r3
 8004c26:	d204      	bcs.n	8004c32 <UART_SetConfig+0x38a>
        {
          huart->Instance->BRR = usartdiv;
 8004c28:	69fb      	ldr	r3, [r7, #28]
 8004c2a:	681b      	ldr	r3, [r3, #0]
 8004c2c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8004c2e:	60da      	str	r2, [r3, #12]
 8004c30:	e0dd      	b.n	8004dee <UART_SetConfig+0x546>
        }
        else
        {
          ret = HAL_ERROR;
 8004c32:	231a      	movs	r3, #26
 8004c34:	2218      	movs	r2, #24
 8004c36:	4694      	mov	ip, r2
 8004c38:	44bc      	add	ip, r7
 8004c3a:	4463      	add	r3, ip
 8004c3c:	2201      	movs	r2, #1
 8004c3e:	701a      	strb	r2, [r3, #0]
 8004c40:	e0d5      	b.n	8004dee <UART_SetConfig+0x546>
        }
      } /* if ( (pclk < (3 * huart->Init.BaudRate) ) || (pclk > (4096 * huart->Init.BaudRate) )) */
    } /* if (pclk != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8004c42:	69fb      	ldr	r3, [r7, #28]
 8004c44:	69da      	ldr	r2, [r3, #28]
 8004c46:	2380      	movs	r3, #128	; 0x80
 8004c48:	021b      	lsls	r3, r3, #8
 8004c4a:	429a      	cmp	r2, r3
 8004c4c:	d000      	beq.n	8004c50 <UART_SetConfig+0x3a8>
 8004c4e:	e074      	b.n	8004d3a <UART_SetConfig+0x492>
  {
    switch (clocksource)
 8004c50:	231b      	movs	r3, #27
 8004c52:	2218      	movs	r2, #24
 8004c54:	4694      	mov	ip, r2
 8004c56:	44bc      	add	ip, r7
 8004c58:	4463      	add	r3, ip
 8004c5a:	781b      	ldrb	r3, [r3, #0]
 8004c5c:	2b08      	cmp	r3, #8
 8004c5e:	d822      	bhi.n	8004ca6 <UART_SetConfig+0x3fe>
 8004c60:	009a      	lsls	r2, r3, #2
 8004c62:	4b6b      	ldr	r3, [pc, #428]	; (8004e10 <UART_SetConfig+0x568>)
 8004c64:	18d3      	adds	r3, r2, r3
 8004c66:	681b      	ldr	r3, [r3, #0]
 8004c68:	469f      	mov	pc, r3
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 8004c6a:	f7ff f851 	bl	8003d10 <HAL_RCC_GetPCLK1Freq>
 8004c6e:	0003      	movs	r3, r0
 8004c70:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004c72:	e022      	b.n	8004cba <UART_SetConfig+0x412>
      case UART_CLOCKSOURCE_PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
 8004c74:	f7ff f862 	bl	8003d3c <HAL_RCC_GetPCLK2Freq>
 8004c78:	0003      	movs	r3, r0
 8004c7a:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004c7c:	e01d      	b.n	8004cba <UART_SetConfig+0x412>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8004c7e:	4b65      	ldr	r3, [pc, #404]	; (8004e14 <UART_SetConfig+0x56c>)
 8004c80:	681b      	ldr	r3, [r3, #0]
 8004c82:	2210      	movs	r2, #16
 8004c84:	4013      	ands	r3, r2
 8004c86:	d002      	beq.n	8004c8e <UART_SetConfig+0x3e6>
        {
          pclk = (uint32_t)(HSI_VALUE >> 2U);
 8004c88:	4b63      	ldr	r3, [pc, #396]	; (8004e18 <UART_SetConfig+0x570>)
 8004c8a:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
 8004c8c:	e015      	b.n	8004cba <UART_SetConfig+0x412>
          pclk = (uint32_t) HSI_VALUE;
 8004c8e:	4b63      	ldr	r3, [pc, #396]	; (8004e1c <UART_SetConfig+0x574>)
 8004c90:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004c92:	e012      	b.n	8004cba <UART_SetConfig+0x412>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
 8004c94:	f7fe ff8c 	bl	8003bb0 <HAL_RCC_GetSysClockFreq>
 8004c98:	0003      	movs	r3, r0
 8004c9a:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004c9c:	e00d      	b.n	8004cba <UART_SetConfig+0x412>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 8004c9e:	2380      	movs	r3, #128	; 0x80
 8004ca0:	021b      	lsls	r3, r3, #8
 8004ca2:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004ca4:	e009      	b.n	8004cba <UART_SetConfig+0x412>
      default:
        pclk = 0U;
 8004ca6:	2300      	movs	r3, #0
 8004ca8:	62fb      	str	r3, [r7, #44]	; 0x2c
        ret = HAL_ERROR;
 8004caa:	231a      	movs	r3, #26
 8004cac:	2218      	movs	r2, #24
 8004cae:	4694      	mov	ip, r2
 8004cb0:	44bc      	add	ip, r7
 8004cb2:	4463      	add	r3, ip
 8004cb4:	2201      	movs	r2, #1
 8004cb6:	701a      	strb	r2, [r3, #0]
        break;
 8004cb8:	46c0      	nop			; (mov r8, r8)
    }

    /* USARTDIV must be greater than or equal to 0d16 */
    if (pclk != 0U)
 8004cba:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004cbc:	2b00      	cmp	r3, #0
 8004cbe:	d100      	bne.n	8004cc2 <UART_SetConfig+0x41a>
 8004cc0:	e095      	b.n	8004dee <UART_SetConfig+0x546>
    {
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate));
 8004cc2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004cc4:	005a      	lsls	r2, r3, #1
 8004cc6:	69fb      	ldr	r3, [r7, #28]
 8004cc8:	685b      	ldr	r3, [r3, #4]
 8004cca:	085b      	lsrs	r3, r3, #1
 8004ccc:	18d2      	adds	r2, r2, r3
 8004cce:	69fb      	ldr	r3, [r7, #28]
 8004cd0:	685b      	ldr	r3, [r3, #4]
 8004cd2:	0019      	movs	r1, r3
 8004cd4:	0010      	movs	r0, r2
 8004cd6:	f7fb fa29 	bl	800012c <__udivsi3>
 8004cda:	0003      	movs	r3, r0
 8004cdc:	b29b      	uxth	r3, r3
 8004cde:	62bb      	str	r3, [r7, #40]	; 0x28
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8004ce0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004ce2:	2b0f      	cmp	r3, #15
 8004ce4:	d921      	bls.n	8004d2a <UART_SetConfig+0x482>
 8004ce6:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8004ce8:	2380      	movs	r3, #128	; 0x80
 8004cea:	025b      	lsls	r3, r3, #9
 8004cec:	429a      	cmp	r2, r3
 8004cee:	d21c      	bcs.n	8004d2a <UART_SetConfig+0x482>
      {
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 8004cf0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004cf2:	b29a      	uxth	r2, r3
 8004cf4:	200e      	movs	r0, #14
 8004cf6:	2418      	movs	r4, #24
 8004cf8:	193b      	adds	r3, r7, r4
 8004cfa:	181b      	adds	r3, r3, r0
 8004cfc:	210f      	movs	r1, #15
 8004cfe:	438a      	bics	r2, r1
 8004d00:	801a      	strh	r2, [r3, #0]
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8004d02:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004d04:	085b      	lsrs	r3, r3, #1
 8004d06:	b29b      	uxth	r3, r3
 8004d08:	2207      	movs	r2, #7
 8004d0a:	4013      	ands	r3, r2
 8004d0c:	b299      	uxth	r1, r3
 8004d0e:	193b      	adds	r3, r7, r4
 8004d10:	181b      	adds	r3, r3, r0
 8004d12:	193a      	adds	r2, r7, r4
 8004d14:	1812      	adds	r2, r2, r0
 8004d16:	8812      	ldrh	r2, [r2, #0]
 8004d18:	430a      	orrs	r2, r1
 8004d1a:	801a      	strh	r2, [r3, #0]
        huart->Instance->BRR = brrtemp;
 8004d1c:	69fb      	ldr	r3, [r7, #28]
 8004d1e:	681b      	ldr	r3, [r3, #0]
 8004d20:	193a      	adds	r2, r7, r4
 8004d22:	1812      	adds	r2, r2, r0
 8004d24:	8812      	ldrh	r2, [r2, #0]
 8004d26:	60da      	str	r2, [r3, #12]
 8004d28:	e061      	b.n	8004dee <UART_SetConfig+0x546>
      }
      else
      {
        ret = HAL_ERROR;
 8004d2a:	231a      	movs	r3, #26
 8004d2c:	2218      	movs	r2, #24
 8004d2e:	4694      	mov	ip, r2
 8004d30:	44bc      	add	ip, r7
 8004d32:	4463      	add	r3, ip
 8004d34:	2201      	movs	r2, #1
 8004d36:	701a      	strb	r2, [r3, #0]
 8004d38:	e059      	b.n	8004dee <UART_SetConfig+0x546>
      }
    }
  }
  else
  {
    switch (clocksource)
 8004d3a:	231b      	movs	r3, #27
 8004d3c:	2218      	movs	r2, #24
 8004d3e:	4694      	mov	ip, r2
 8004d40:	44bc      	add	ip, r7
 8004d42:	4463      	add	r3, ip
 8004d44:	781b      	ldrb	r3, [r3, #0]
 8004d46:	2b08      	cmp	r3, #8
 8004d48:	d822      	bhi.n	8004d90 <UART_SetConfig+0x4e8>
 8004d4a:	009a      	lsls	r2, r3, #2
 8004d4c:	4b34      	ldr	r3, [pc, #208]	; (8004e20 <UART_SetConfig+0x578>)
 8004d4e:	18d3      	adds	r3, r2, r3
 8004d50:	681b      	ldr	r3, [r3, #0]
 8004d52:	469f      	mov	pc, r3
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 8004d54:	f7fe ffdc 	bl	8003d10 <HAL_RCC_GetPCLK1Freq>
 8004d58:	0003      	movs	r3, r0
 8004d5a:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004d5c:	e022      	b.n	8004da4 <UART_SetConfig+0x4fc>
      case UART_CLOCKSOURCE_PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
 8004d5e:	f7fe ffed 	bl	8003d3c <HAL_RCC_GetPCLK2Freq>
 8004d62:	0003      	movs	r3, r0
 8004d64:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004d66:	e01d      	b.n	8004da4 <UART_SetConfig+0x4fc>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8004d68:	4b2a      	ldr	r3, [pc, #168]	; (8004e14 <UART_SetConfig+0x56c>)
 8004d6a:	681b      	ldr	r3, [r3, #0]
 8004d6c:	2210      	movs	r2, #16
 8004d6e:	4013      	ands	r3, r2
 8004d70:	d002      	beq.n	8004d78 <UART_SetConfig+0x4d0>
        {
          pclk = (uint32_t)(HSI_VALUE >> 2U);
 8004d72:	4b29      	ldr	r3, [pc, #164]	; (8004e18 <UART_SetConfig+0x570>)
 8004d74:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
 8004d76:	e015      	b.n	8004da4 <UART_SetConfig+0x4fc>
          pclk = (uint32_t) HSI_VALUE;
 8004d78:	4b28      	ldr	r3, [pc, #160]	; (8004e1c <UART_SetConfig+0x574>)
 8004d7a:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004d7c:	e012      	b.n	8004da4 <UART_SetConfig+0x4fc>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
 8004d7e:	f7fe ff17 	bl	8003bb0 <HAL_RCC_GetSysClockFreq>
 8004d82:	0003      	movs	r3, r0
 8004d84:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004d86:	e00d      	b.n	8004da4 <UART_SetConfig+0x4fc>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 8004d88:	2380      	movs	r3, #128	; 0x80
 8004d8a:	021b      	lsls	r3, r3, #8
 8004d8c:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004d8e:	e009      	b.n	8004da4 <UART_SetConfig+0x4fc>
      default:
        pclk = 0U;
 8004d90:	2300      	movs	r3, #0
 8004d92:	62fb      	str	r3, [r7, #44]	; 0x2c
        ret = HAL_ERROR;
 8004d94:	231a      	movs	r3, #26
 8004d96:	2218      	movs	r2, #24
 8004d98:	4694      	mov	ip, r2
 8004d9a:	44bc      	add	ip, r7
 8004d9c:	4463      	add	r3, ip
 8004d9e:	2201      	movs	r2, #1
 8004da0:	701a      	strb	r2, [r3, #0]
        break;
 8004da2:	46c0      	nop			; (mov r8, r8)
    }

    if (pclk != 0U)
 8004da4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004da6:	2b00      	cmp	r3, #0
 8004da8:	d021      	beq.n	8004dee <UART_SetConfig+0x546>
    {
      /* USARTDIV must be greater than or equal to 0d16 */
      usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate));
 8004daa:	69fb      	ldr	r3, [r7, #28]
 8004dac:	685b      	ldr	r3, [r3, #4]
 8004dae:	085a      	lsrs	r2, r3, #1
 8004db0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004db2:	18d2      	adds	r2, r2, r3
 8004db4:	69fb      	ldr	r3, [r7, #28]
 8004db6:	685b      	ldr	r3, [r3, #4]
 8004db8:	0019      	movs	r1, r3
 8004dba:	0010      	movs	r0, r2
 8004dbc:	f7fb f9b6 	bl	800012c <__udivsi3>
 8004dc0:	0003      	movs	r3, r0
 8004dc2:	b29b      	uxth	r3, r3
 8004dc4:	62bb      	str	r3, [r7, #40]	; 0x28
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8004dc6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004dc8:	2b0f      	cmp	r3, #15
 8004dca:	d909      	bls.n	8004de0 <UART_SetConfig+0x538>
 8004dcc:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8004dce:	2380      	movs	r3, #128	; 0x80
 8004dd0:	025b      	lsls	r3, r3, #9
 8004dd2:	429a      	cmp	r2, r3
 8004dd4:	d204      	bcs.n	8004de0 <UART_SetConfig+0x538>
      {
        huart->Instance->BRR = usartdiv;
 8004dd6:	69fb      	ldr	r3, [r7, #28]
 8004dd8:	681b      	ldr	r3, [r3, #0]
 8004dda:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8004ddc:	60da      	str	r2, [r3, #12]
 8004dde:	e006      	b.n	8004dee <UART_SetConfig+0x546>
      }
      else
      {
        ret = HAL_ERROR;
 8004de0:	231a      	movs	r3, #26
 8004de2:	2218      	movs	r2, #24
 8004de4:	4694      	mov	ip, r2
 8004de6:	44bc      	add	ip, r7
 8004de8:	4463      	add	r3, ip
 8004dea:	2201      	movs	r2, #1
 8004dec:	701a      	strb	r2, [r3, #0]
    }
  }


  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 8004dee:	69fb      	ldr	r3, [r7, #28]
 8004df0:	2200      	movs	r2, #0
 8004df2:	665a      	str	r2, [r3, #100]	; 0x64
  huart->TxISR = NULL;
 8004df4:	69fb      	ldr	r3, [r7, #28]
 8004df6:	2200      	movs	r2, #0
 8004df8:	669a      	str	r2, [r3, #104]	; 0x68

  return ret;
 8004dfa:	231a      	movs	r3, #26
 8004dfc:	2218      	movs	r2, #24
 8004dfe:	4694      	mov	ip, r2
 8004e00:	44bc      	add	ip, r7
 8004e02:	4463      	add	r3, ip
 8004e04:	781b      	ldrb	r3, [r3, #0]
}
 8004e06:	0018      	movs	r0, r3
 8004e08:	46bd      	mov	sp, r7
 8004e0a:	b00e      	add	sp, #56	; 0x38
 8004e0c:	bdb0      	pop	{r4, r5, r7, pc}
 8004e0e:	46c0      	nop			; (mov r8, r8)
 8004e10:	08022348 	.word	0x08022348
 8004e14:	40021000 	.word	0x40021000
 8004e18:	003d0900 	.word	0x003d0900
 8004e1c:	00f42400 	.word	0x00f42400
 8004e20:	0802236c 	.word	0x0802236c

08004e24 <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
 8004e24:	b580      	push	{r7, lr}
 8004e26:	b082      	sub	sp, #8
 8004e28:	af00      	add	r7, sp, #0
 8004e2a:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8004e2c:	687b      	ldr	r3, [r7, #4]
 8004e2e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004e30:	2201      	movs	r2, #1
 8004e32:	4013      	ands	r3, r2
 8004e34:	d00b      	beq.n	8004e4e <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 8004e36:	687b      	ldr	r3, [r7, #4]
 8004e38:	681b      	ldr	r3, [r3, #0]
 8004e3a:	685b      	ldr	r3, [r3, #4]
 8004e3c:	4a4a      	ldr	r2, [pc, #296]	; (8004f68 <UART_AdvFeatureConfig+0x144>)
 8004e3e:	4013      	ands	r3, r2
 8004e40:	0019      	movs	r1, r3
 8004e42:	687b      	ldr	r3, [r7, #4]
 8004e44:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8004e46:	687b      	ldr	r3, [r7, #4]
 8004e48:	681b      	ldr	r3, [r3, #0]
 8004e4a:	430a      	orrs	r2, r1
 8004e4c:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 8004e4e:	687b      	ldr	r3, [r7, #4]
 8004e50:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004e52:	2202      	movs	r2, #2
 8004e54:	4013      	ands	r3, r2
 8004e56:	d00b      	beq.n	8004e70 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 8004e58:	687b      	ldr	r3, [r7, #4]
 8004e5a:	681b      	ldr	r3, [r3, #0]
 8004e5c:	685b      	ldr	r3, [r3, #4]
 8004e5e:	4a43      	ldr	r2, [pc, #268]	; (8004f6c <UART_AdvFeatureConfig+0x148>)
 8004e60:	4013      	ands	r3, r2
 8004e62:	0019      	movs	r1, r3
 8004e64:	687b      	ldr	r3, [r7, #4]
 8004e66:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8004e68:	687b      	ldr	r3, [r7, #4]
 8004e6a:	681b      	ldr	r3, [r3, #0]
 8004e6c:	430a      	orrs	r2, r1
 8004e6e:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 8004e70:	687b      	ldr	r3, [r7, #4]
 8004e72:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004e74:	2204      	movs	r2, #4
 8004e76:	4013      	ands	r3, r2
 8004e78:	d00b      	beq.n	8004e92 <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 8004e7a:	687b      	ldr	r3, [r7, #4]
 8004e7c:	681b      	ldr	r3, [r3, #0]
 8004e7e:	685b      	ldr	r3, [r3, #4]
 8004e80:	4a3b      	ldr	r2, [pc, #236]	; (8004f70 <UART_AdvFeatureConfig+0x14c>)
 8004e82:	4013      	ands	r3, r2
 8004e84:	0019      	movs	r1, r3
 8004e86:	687b      	ldr	r3, [r7, #4]
 8004e88:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004e8a:	687b      	ldr	r3, [r7, #4]
 8004e8c:	681b      	ldr	r3, [r3, #0]
 8004e8e:	430a      	orrs	r2, r1
 8004e90:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 8004e92:	687b      	ldr	r3, [r7, #4]
 8004e94:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004e96:	2208      	movs	r2, #8
 8004e98:	4013      	ands	r3, r2
 8004e9a:	d00b      	beq.n	8004eb4 <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 8004e9c:	687b      	ldr	r3, [r7, #4]
 8004e9e:	681b      	ldr	r3, [r3, #0]
 8004ea0:	685b      	ldr	r3, [r3, #4]
 8004ea2:	4a34      	ldr	r2, [pc, #208]	; (8004f74 <UART_AdvFeatureConfig+0x150>)
 8004ea4:	4013      	ands	r3, r2
 8004ea6:	0019      	movs	r1, r3
 8004ea8:	687b      	ldr	r3, [r7, #4]
 8004eaa:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8004eac:	687b      	ldr	r3, [r7, #4]
 8004eae:	681b      	ldr	r3, [r3, #0]
 8004eb0:	430a      	orrs	r2, r1
 8004eb2:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8004eb4:	687b      	ldr	r3, [r7, #4]
 8004eb6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004eb8:	2210      	movs	r2, #16
 8004eba:	4013      	ands	r3, r2
 8004ebc:	d00b      	beq.n	8004ed6 <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 8004ebe:	687b      	ldr	r3, [r7, #4]
 8004ec0:	681b      	ldr	r3, [r3, #0]
 8004ec2:	689b      	ldr	r3, [r3, #8]
 8004ec4:	4a2c      	ldr	r2, [pc, #176]	; (8004f78 <UART_AdvFeatureConfig+0x154>)
 8004ec6:	4013      	ands	r3, r2
 8004ec8:	0019      	movs	r1, r3
 8004eca:	687b      	ldr	r3, [r7, #4]
 8004ecc:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8004ece:	687b      	ldr	r3, [r7, #4]
 8004ed0:	681b      	ldr	r3, [r3, #0]
 8004ed2:	430a      	orrs	r2, r1
 8004ed4:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 8004ed6:	687b      	ldr	r3, [r7, #4]
 8004ed8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004eda:	2220      	movs	r2, #32
 8004edc:	4013      	ands	r3, r2
 8004ede:	d00b      	beq.n	8004ef8 <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 8004ee0:	687b      	ldr	r3, [r7, #4]
 8004ee2:	681b      	ldr	r3, [r3, #0]
 8004ee4:	689b      	ldr	r3, [r3, #8]
 8004ee6:	4a25      	ldr	r2, [pc, #148]	; (8004f7c <UART_AdvFeatureConfig+0x158>)
 8004ee8:	4013      	ands	r3, r2
 8004eea:	0019      	movs	r1, r3
 8004eec:	687b      	ldr	r3, [r7, #4]
 8004eee:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8004ef0:	687b      	ldr	r3, [r7, #4]
 8004ef2:	681b      	ldr	r3, [r3, #0]
 8004ef4:	430a      	orrs	r2, r1
 8004ef6:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 8004ef8:	687b      	ldr	r3, [r7, #4]
 8004efa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004efc:	2240      	movs	r2, #64	; 0x40
 8004efe:	4013      	ands	r3, r2
 8004f00:	d01d      	beq.n	8004f3e <UART_AdvFeatureConfig+0x11a>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8004f02:	687b      	ldr	r3, [r7, #4]
 8004f04:	681b      	ldr	r3, [r3, #0]
 8004f06:	685b      	ldr	r3, [r3, #4]
 8004f08:	4a1d      	ldr	r2, [pc, #116]	; (8004f80 <UART_AdvFeatureConfig+0x15c>)
 8004f0a:	4013      	ands	r3, r2
 8004f0c:	0019      	movs	r1, r3
 8004f0e:	687b      	ldr	r3, [r7, #4]
 8004f10:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8004f12:	687b      	ldr	r3, [r7, #4]
 8004f14:	681b      	ldr	r3, [r3, #0]
 8004f16:	430a      	orrs	r2, r1
 8004f18:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8004f1a:	687b      	ldr	r3, [r7, #4]
 8004f1c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8004f1e:	2380      	movs	r3, #128	; 0x80
 8004f20:	035b      	lsls	r3, r3, #13
 8004f22:	429a      	cmp	r2, r3
 8004f24:	d10b      	bne.n	8004f3e <UART_AdvFeatureConfig+0x11a>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 8004f26:	687b      	ldr	r3, [r7, #4]
 8004f28:	681b      	ldr	r3, [r3, #0]
 8004f2a:	685b      	ldr	r3, [r3, #4]
 8004f2c:	4a15      	ldr	r2, [pc, #84]	; (8004f84 <UART_AdvFeatureConfig+0x160>)
 8004f2e:	4013      	ands	r3, r2
 8004f30:	0019      	movs	r1, r3
 8004f32:	687b      	ldr	r3, [r7, #4]
 8004f34:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8004f36:	687b      	ldr	r3, [r7, #4]
 8004f38:	681b      	ldr	r3, [r3, #0]
 8004f3a:	430a      	orrs	r2, r1
 8004f3c:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 8004f3e:	687b      	ldr	r3, [r7, #4]
 8004f40:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004f42:	2280      	movs	r2, #128	; 0x80
 8004f44:	4013      	ands	r3, r2
 8004f46:	d00b      	beq.n	8004f60 <UART_AdvFeatureConfig+0x13c>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8004f48:	687b      	ldr	r3, [r7, #4]
 8004f4a:	681b      	ldr	r3, [r3, #0]
 8004f4c:	685b      	ldr	r3, [r3, #4]
 8004f4e:	4a0e      	ldr	r2, [pc, #56]	; (8004f88 <UART_AdvFeatureConfig+0x164>)
 8004f50:	4013      	ands	r3, r2
 8004f52:	0019      	movs	r1, r3
 8004f54:	687b      	ldr	r3, [r7, #4]
 8004f56:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8004f58:	687b      	ldr	r3, [r7, #4]
 8004f5a:	681b      	ldr	r3, [r3, #0]
 8004f5c:	430a      	orrs	r2, r1
 8004f5e:	605a      	str	r2, [r3, #4]
  }
}
 8004f60:	46c0      	nop			; (mov r8, r8)
 8004f62:	46bd      	mov	sp, r7
 8004f64:	b002      	add	sp, #8
 8004f66:	bd80      	pop	{r7, pc}
 8004f68:	fffdffff 	.word	0xfffdffff
 8004f6c:	fffeffff 	.word	0xfffeffff
 8004f70:	fffbffff 	.word	0xfffbffff
 8004f74:	ffff7fff 	.word	0xffff7fff
 8004f78:	ffffefff 	.word	0xffffefff
 8004f7c:	ffffdfff 	.word	0xffffdfff
 8004f80:	ffefffff 	.word	0xffefffff
 8004f84:	ff9fffff 	.word	0xff9fffff
 8004f88:	fff7ffff 	.word	0xfff7ffff

08004f8c <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 8004f8c:	b580      	push	{r7, lr}
 8004f8e:	b086      	sub	sp, #24
 8004f90:	af02      	add	r7, sp, #8
 8004f92:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8004f94:	687b      	ldr	r3, [r7, #4]
 8004f96:	2280      	movs	r2, #128	; 0x80
 8004f98:	2100      	movs	r1, #0
 8004f9a:	5099      	str	r1, [r3, r2]

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
 8004f9c:	f7fd fe14 	bl	8002bc8 <HAL_GetTick>
 8004fa0:	0003      	movs	r3, r0
 8004fa2:	60fb      	str	r3, [r7, #12]

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8004fa4:	687b      	ldr	r3, [r7, #4]
 8004fa6:	681b      	ldr	r3, [r3, #0]
 8004fa8:	681b      	ldr	r3, [r3, #0]
 8004faa:	2208      	movs	r2, #8
 8004fac:	4013      	ands	r3, r2
 8004fae:	2b08      	cmp	r3, #8
 8004fb0:	d10c      	bne.n	8004fcc <UART_CheckIdleState+0x40>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8004fb2:	68fb      	ldr	r3, [r7, #12]
 8004fb4:	2280      	movs	r2, #128	; 0x80
 8004fb6:	0391      	lsls	r1, r2, #14
 8004fb8:	6878      	ldr	r0, [r7, #4]
 8004fba:	4a17      	ldr	r2, [pc, #92]	; (8005018 <UART_CheckIdleState+0x8c>)
 8004fbc:	9200      	str	r2, [sp, #0]
 8004fbe:	2200      	movs	r2, #0
 8004fc0:	f000 f82c 	bl	800501c <UART_WaitOnFlagUntilTimeout>
 8004fc4:	1e03      	subs	r3, r0, #0
 8004fc6:	d001      	beq.n	8004fcc <UART_CheckIdleState+0x40>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 8004fc8:	2303      	movs	r3, #3
 8004fca:	e021      	b.n	8005010 <UART_CheckIdleState+0x84>
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 8004fcc:	687b      	ldr	r3, [r7, #4]
 8004fce:	681b      	ldr	r3, [r3, #0]
 8004fd0:	681b      	ldr	r3, [r3, #0]
 8004fd2:	2204      	movs	r2, #4
 8004fd4:	4013      	ands	r3, r2
 8004fd6:	2b04      	cmp	r3, #4
 8004fd8:	d10c      	bne.n	8004ff4 <UART_CheckIdleState+0x68>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8004fda:	68fb      	ldr	r3, [r7, #12]
 8004fdc:	2280      	movs	r2, #128	; 0x80
 8004fde:	03d1      	lsls	r1, r2, #15
 8004fe0:	6878      	ldr	r0, [r7, #4]
 8004fe2:	4a0d      	ldr	r2, [pc, #52]	; (8005018 <UART_CheckIdleState+0x8c>)
 8004fe4:	9200      	str	r2, [sp, #0]
 8004fe6:	2200      	movs	r2, #0
 8004fe8:	f000 f818 	bl	800501c <UART_WaitOnFlagUntilTimeout>
 8004fec:	1e03      	subs	r3, r0, #0
 8004fee:	d001      	beq.n	8004ff4 <UART_CheckIdleState+0x68>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 8004ff0:	2303      	movs	r3, #3
 8004ff2:	e00d      	b.n	8005010 <UART_CheckIdleState+0x84>
    }
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
 8004ff4:	687b      	ldr	r3, [r7, #4]
 8004ff6:	2220      	movs	r2, #32
 8004ff8:	679a      	str	r2, [r3, #120]	; 0x78
  huart->RxState = HAL_UART_STATE_READY;
 8004ffa:	687b      	ldr	r3, [r7, #4]
 8004ffc:	2220      	movs	r2, #32
 8004ffe:	67da      	str	r2, [r3, #124]	; 0x7c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8005000:	687b      	ldr	r3, [r7, #4]
 8005002:	2200      	movs	r2, #0
 8005004:	661a      	str	r2, [r3, #96]	; 0x60

  __HAL_UNLOCK(huart);
 8005006:	687b      	ldr	r3, [r7, #4]
 8005008:	2274      	movs	r2, #116	; 0x74
 800500a:	2100      	movs	r1, #0
 800500c:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 800500e:	2300      	movs	r3, #0
}
 8005010:	0018      	movs	r0, r3
 8005012:	46bd      	mov	sp, r7
 8005014:	b004      	add	sp, #16
 8005016:	bd80      	pop	{r7, pc}
 8005018:	01ffffff 	.word	0x01ffffff

0800501c <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
 800501c:	b580      	push	{r7, lr}
 800501e:	b094      	sub	sp, #80	; 0x50
 8005020:	af00      	add	r7, sp, #0
 8005022:	60f8      	str	r0, [r7, #12]
 8005024:	60b9      	str	r1, [r7, #8]
 8005026:	603b      	str	r3, [r7, #0]
 8005028:	1dfb      	adds	r3, r7, #7
 800502a:	701a      	strb	r2, [r3, #0]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800502c:	e0a3      	b.n	8005176 <UART_WaitOnFlagUntilTimeout+0x15a>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800502e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8005030:	3301      	adds	r3, #1
 8005032:	d100      	bne.n	8005036 <UART_WaitOnFlagUntilTimeout+0x1a>
 8005034:	e09f      	b.n	8005176 <UART_WaitOnFlagUntilTimeout+0x15a>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8005036:	f7fd fdc7 	bl	8002bc8 <HAL_GetTick>
 800503a:	0002      	movs	r2, r0
 800503c:	683b      	ldr	r3, [r7, #0]
 800503e:	1ad3      	subs	r3, r2, r3
 8005040:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8005042:	429a      	cmp	r2, r3
 8005044:	d302      	bcc.n	800504c <UART_WaitOnFlagUntilTimeout+0x30>
 8005046:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8005048:	2b00      	cmp	r3, #0
 800504a:	d13d      	bne.n	80050c8 <UART_WaitOnFlagUntilTimeout+0xac>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800504c:	f3ef 8310 	mrs	r3, PRIMASK
 8005050:	62bb      	str	r3, [r7, #40]	; 0x28
  return(result);
 8005052:	6abb      	ldr	r3, [r7, #40]	; 0x28
      {
        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error)
           interrupts for the interrupt process */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 8005054:	647b      	str	r3, [r7, #68]	; 0x44
 8005056:	2301      	movs	r3, #1
 8005058:	62fb      	str	r3, [r7, #44]	; 0x2c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800505a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800505c:	f383 8810 	msr	PRIMASK, r3
}
 8005060:	46c0      	nop			; (mov r8, r8)
 8005062:	68fb      	ldr	r3, [r7, #12]
 8005064:	681b      	ldr	r3, [r3, #0]
 8005066:	681a      	ldr	r2, [r3, #0]
 8005068:	68fb      	ldr	r3, [r7, #12]
 800506a:	681b      	ldr	r3, [r3, #0]
 800506c:	494c      	ldr	r1, [pc, #304]	; (80051a0 <UART_WaitOnFlagUntilTimeout+0x184>)
 800506e:	400a      	ands	r2, r1
 8005070:	601a      	str	r2, [r3, #0]
 8005072:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8005074:	633b      	str	r3, [r7, #48]	; 0x30
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005076:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005078:	f383 8810 	msr	PRIMASK, r3
}
 800507c:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800507e:	f3ef 8310 	mrs	r3, PRIMASK
 8005082:	637b      	str	r3, [r7, #52]	; 0x34
  return(result);
 8005084:	6b7b      	ldr	r3, [r7, #52]	; 0x34
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8005086:	643b      	str	r3, [r7, #64]	; 0x40
 8005088:	2301      	movs	r3, #1
 800508a:	63bb      	str	r3, [r7, #56]	; 0x38
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800508c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800508e:	f383 8810 	msr	PRIMASK, r3
}
 8005092:	46c0      	nop			; (mov r8, r8)
 8005094:	68fb      	ldr	r3, [r7, #12]
 8005096:	681b      	ldr	r3, [r3, #0]
 8005098:	689a      	ldr	r2, [r3, #8]
 800509a:	68fb      	ldr	r3, [r7, #12]
 800509c:	681b      	ldr	r3, [r3, #0]
 800509e:	2101      	movs	r1, #1
 80050a0:	438a      	bics	r2, r1
 80050a2:	609a      	str	r2, [r3, #8]
 80050a4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80050a6:	63fb      	str	r3, [r7, #60]	; 0x3c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80050a8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80050aa:	f383 8810 	msr	PRIMASK, r3
}
 80050ae:	46c0      	nop			; (mov r8, r8)

        huart->gState = HAL_UART_STATE_READY;
 80050b0:	68fb      	ldr	r3, [r7, #12]
 80050b2:	2220      	movs	r2, #32
 80050b4:	679a      	str	r2, [r3, #120]	; 0x78
        huart->RxState = HAL_UART_STATE_READY;
 80050b6:	68fb      	ldr	r3, [r7, #12]
 80050b8:	2220      	movs	r2, #32
 80050ba:	67da      	str	r2, [r3, #124]	; 0x7c

        __HAL_UNLOCK(huart);
 80050bc:	68fb      	ldr	r3, [r7, #12]
 80050be:	2274      	movs	r2, #116	; 0x74
 80050c0:	2100      	movs	r1, #0
 80050c2:	5499      	strb	r1, [r3, r2]

        return HAL_TIMEOUT;
 80050c4:	2303      	movs	r3, #3
 80050c6:	e067      	b.n	8005198 <UART_WaitOnFlagUntilTimeout+0x17c>
      }

      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 80050c8:	68fb      	ldr	r3, [r7, #12]
 80050ca:	681b      	ldr	r3, [r3, #0]
 80050cc:	681b      	ldr	r3, [r3, #0]
 80050ce:	2204      	movs	r2, #4
 80050d0:	4013      	ands	r3, r2
 80050d2:	d050      	beq.n	8005176 <UART_WaitOnFlagUntilTimeout+0x15a>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 80050d4:	68fb      	ldr	r3, [r7, #12]
 80050d6:	681b      	ldr	r3, [r3, #0]
 80050d8:	69da      	ldr	r2, [r3, #28]
 80050da:	2380      	movs	r3, #128	; 0x80
 80050dc:	011b      	lsls	r3, r3, #4
 80050de:	401a      	ands	r2, r3
 80050e0:	2380      	movs	r3, #128	; 0x80
 80050e2:	011b      	lsls	r3, r3, #4
 80050e4:	429a      	cmp	r2, r3
 80050e6:	d146      	bne.n	8005176 <UART_WaitOnFlagUntilTimeout+0x15a>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 80050e8:	68fb      	ldr	r3, [r7, #12]
 80050ea:	681b      	ldr	r3, [r3, #0]
 80050ec:	2280      	movs	r2, #128	; 0x80
 80050ee:	0112      	lsls	r2, r2, #4
 80050f0:	621a      	str	r2, [r3, #32]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80050f2:	f3ef 8310 	mrs	r3, PRIMASK
 80050f6:	613b      	str	r3, [r7, #16]
  return(result);
 80050f8:	693b      	ldr	r3, [r7, #16]

          /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error)
             interrupts for the interrupt process */
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 80050fa:	64fb      	str	r3, [r7, #76]	; 0x4c
 80050fc:	2301      	movs	r3, #1
 80050fe:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005100:	697b      	ldr	r3, [r7, #20]
 8005102:	f383 8810 	msr	PRIMASK, r3
}
 8005106:	46c0      	nop			; (mov r8, r8)
 8005108:	68fb      	ldr	r3, [r7, #12]
 800510a:	681b      	ldr	r3, [r3, #0]
 800510c:	681a      	ldr	r2, [r3, #0]
 800510e:	68fb      	ldr	r3, [r7, #12]
 8005110:	681b      	ldr	r3, [r3, #0]
 8005112:	4923      	ldr	r1, [pc, #140]	; (80051a0 <UART_WaitOnFlagUntilTimeout+0x184>)
 8005114:	400a      	ands	r2, r1
 8005116:	601a      	str	r2, [r3, #0]
 8005118:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800511a:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800511c:	69bb      	ldr	r3, [r7, #24]
 800511e:	f383 8810 	msr	PRIMASK, r3
}
 8005122:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8005124:	f3ef 8310 	mrs	r3, PRIMASK
 8005128:	61fb      	str	r3, [r7, #28]
  return(result);
 800512a:	69fb      	ldr	r3, [r7, #28]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800512c:	64bb      	str	r3, [r7, #72]	; 0x48
 800512e:	2301      	movs	r3, #1
 8005130:	623b      	str	r3, [r7, #32]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005132:	6a3b      	ldr	r3, [r7, #32]
 8005134:	f383 8810 	msr	PRIMASK, r3
}
 8005138:	46c0      	nop			; (mov r8, r8)
 800513a:	68fb      	ldr	r3, [r7, #12]
 800513c:	681b      	ldr	r3, [r3, #0]
 800513e:	689a      	ldr	r2, [r3, #8]
 8005140:	68fb      	ldr	r3, [r7, #12]
 8005142:	681b      	ldr	r3, [r3, #0]
 8005144:	2101      	movs	r1, #1
 8005146:	438a      	bics	r2, r1
 8005148:	609a      	str	r2, [r3, #8]
 800514a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800514c:	627b      	str	r3, [r7, #36]	; 0x24
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800514e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005150:	f383 8810 	msr	PRIMASK, r3
}
 8005154:	46c0      	nop			; (mov r8, r8)

          huart->gState = HAL_UART_STATE_READY;
 8005156:	68fb      	ldr	r3, [r7, #12]
 8005158:	2220      	movs	r2, #32
 800515a:	679a      	str	r2, [r3, #120]	; 0x78
          huart->RxState = HAL_UART_STATE_READY;
 800515c:	68fb      	ldr	r3, [r7, #12]
 800515e:	2220      	movs	r2, #32
 8005160:	67da      	str	r2, [r3, #124]	; 0x7c
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 8005162:	68fb      	ldr	r3, [r7, #12]
 8005164:	2280      	movs	r2, #128	; 0x80
 8005166:	2120      	movs	r1, #32
 8005168:	5099      	str	r1, [r3, r2]

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 800516a:	68fb      	ldr	r3, [r7, #12]
 800516c:	2274      	movs	r2, #116	; 0x74
 800516e:	2100      	movs	r1, #0
 8005170:	5499      	strb	r1, [r3, r2]

          return HAL_TIMEOUT;
 8005172:	2303      	movs	r3, #3
 8005174:	e010      	b.n	8005198 <UART_WaitOnFlagUntilTimeout+0x17c>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8005176:	68fb      	ldr	r3, [r7, #12]
 8005178:	681b      	ldr	r3, [r3, #0]
 800517a:	69db      	ldr	r3, [r3, #28]
 800517c:	68ba      	ldr	r2, [r7, #8]
 800517e:	4013      	ands	r3, r2
 8005180:	68ba      	ldr	r2, [r7, #8]
 8005182:	1ad3      	subs	r3, r2, r3
 8005184:	425a      	negs	r2, r3
 8005186:	4153      	adcs	r3, r2
 8005188:	b2db      	uxtb	r3, r3
 800518a:	001a      	movs	r2, r3
 800518c:	1dfb      	adds	r3, r7, #7
 800518e:	781b      	ldrb	r3, [r3, #0]
 8005190:	429a      	cmp	r2, r3
 8005192:	d100      	bne.n	8005196 <UART_WaitOnFlagUntilTimeout+0x17a>
 8005194:	e74b      	b.n	800502e <UART_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
 8005196:	2300      	movs	r3, #0
}
 8005198:	0018      	movs	r0, r3
 800519a:	46bd      	mov	sp, r7
 800519c:	b014      	add	sp, #80	; 0x50
 800519e:	bd80      	pop	{r7, pc}
 80051a0:	fffffe5f 	.word	0xfffffe5f

080051a4 <UART_Start_Receive_IT>:
  * @param  pData Pointer to data buffer (u8 or u16 data elements).
  * @param  Size  Amount of data elements (u8 or u16) to be received.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_Start_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 80051a4:	b580      	push	{r7, lr}
 80051a6:	b08c      	sub	sp, #48	; 0x30
 80051a8:	af00      	add	r7, sp, #0
 80051aa:	60f8      	str	r0, [r7, #12]
 80051ac:	60b9      	str	r1, [r7, #8]
 80051ae:	1dbb      	adds	r3, r7, #6
 80051b0:	801a      	strh	r2, [r3, #0]
  huart->pRxBuffPtr  = pData;
 80051b2:	68fb      	ldr	r3, [r7, #12]
 80051b4:	68ba      	ldr	r2, [r7, #8]
 80051b6:	655a      	str	r2, [r3, #84]	; 0x54
  huart->RxXferSize  = Size;
 80051b8:	68fb      	ldr	r3, [r7, #12]
 80051ba:	1dba      	adds	r2, r7, #6
 80051bc:	2158      	movs	r1, #88	; 0x58
 80051be:	8812      	ldrh	r2, [r2, #0]
 80051c0:	525a      	strh	r2, [r3, r1]
  huart->RxXferCount = Size;
 80051c2:	68fb      	ldr	r3, [r7, #12]
 80051c4:	1dba      	adds	r2, r7, #6
 80051c6:	215a      	movs	r1, #90	; 0x5a
 80051c8:	8812      	ldrh	r2, [r2, #0]
 80051ca:	525a      	strh	r2, [r3, r1]
  huart->RxISR       = NULL;
 80051cc:	68fb      	ldr	r3, [r7, #12]
 80051ce:	2200      	movs	r2, #0
 80051d0:	665a      	str	r2, [r3, #100]	; 0x64

  /* Computation of UART mask to apply to RDR register */
  UART_MASK_COMPUTATION(huart);
 80051d2:	68fb      	ldr	r3, [r7, #12]
 80051d4:	689a      	ldr	r2, [r3, #8]
 80051d6:	2380      	movs	r3, #128	; 0x80
 80051d8:	015b      	lsls	r3, r3, #5
 80051da:	429a      	cmp	r2, r3
 80051dc:	d10d      	bne.n	80051fa <UART_Start_Receive_IT+0x56>
 80051de:	68fb      	ldr	r3, [r7, #12]
 80051e0:	691b      	ldr	r3, [r3, #16]
 80051e2:	2b00      	cmp	r3, #0
 80051e4:	d104      	bne.n	80051f0 <UART_Start_Receive_IT+0x4c>
 80051e6:	68fb      	ldr	r3, [r7, #12]
 80051e8:	225c      	movs	r2, #92	; 0x5c
 80051ea:	4943      	ldr	r1, [pc, #268]	; (80052f8 <UART_Start_Receive_IT+0x154>)
 80051ec:	5299      	strh	r1, [r3, r2]
 80051ee:	e02e      	b.n	800524e <UART_Start_Receive_IT+0xaa>
 80051f0:	68fb      	ldr	r3, [r7, #12]
 80051f2:	225c      	movs	r2, #92	; 0x5c
 80051f4:	21ff      	movs	r1, #255	; 0xff
 80051f6:	5299      	strh	r1, [r3, r2]
 80051f8:	e029      	b.n	800524e <UART_Start_Receive_IT+0xaa>
 80051fa:	68fb      	ldr	r3, [r7, #12]
 80051fc:	689b      	ldr	r3, [r3, #8]
 80051fe:	2b00      	cmp	r3, #0
 8005200:	d10d      	bne.n	800521e <UART_Start_Receive_IT+0x7a>
 8005202:	68fb      	ldr	r3, [r7, #12]
 8005204:	691b      	ldr	r3, [r3, #16]
 8005206:	2b00      	cmp	r3, #0
 8005208:	d104      	bne.n	8005214 <UART_Start_Receive_IT+0x70>
 800520a:	68fb      	ldr	r3, [r7, #12]
 800520c:	225c      	movs	r2, #92	; 0x5c
 800520e:	21ff      	movs	r1, #255	; 0xff
 8005210:	5299      	strh	r1, [r3, r2]
 8005212:	e01c      	b.n	800524e <UART_Start_Receive_IT+0xaa>
 8005214:	68fb      	ldr	r3, [r7, #12]
 8005216:	225c      	movs	r2, #92	; 0x5c
 8005218:	217f      	movs	r1, #127	; 0x7f
 800521a:	5299      	strh	r1, [r3, r2]
 800521c:	e017      	b.n	800524e <UART_Start_Receive_IT+0xaa>
 800521e:	68fb      	ldr	r3, [r7, #12]
 8005220:	689a      	ldr	r2, [r3, #8]
 8005222:	2380      	movs	r3, #128	; 0x80
 8005224:	055b      	lsls	r3, r3, #21
 8005226:	429a      	cmp	r2, r3
 8005228:	d10d      	bne.n	8005246 <UART_Start_Receive_IT+0xa2>
 800522a:	68fb      	ldr	r3, [r7, #12]
 800522c:	691b      	ldr	r3, [r3, #16]
 800522e:	2b00      	cmp	r3, #0
 8005230:	d104      	bne.n	800523c <UART_Start_Receive_IT+0x98>
 8005232:	68fb      	ldr	r3, [r7, #12]
 8005234:	225c      	movs	r2, #92	; 0x5c
 8005236:	217f      	movs	r1, #127	; 0x7f
 8005238:	5299      	strh	r1, [r3, r2]
 800523a:	e008      	b.n	800524e <UART_Start_Receive_IT+0xaa>
 800523c:	68fb      	ldr	r3, [r7, #12]
 800523e:	225c      	movs	r2, #92	; 0x5c
 8005240:	213f      	movs	r1, #63	; 0x3f
 8005242:	5299      	strh	r1, [r3, r2]
 8005244:	e003      	b.n	800524e <UART_Start_Receive_IT+0xaa>
 8005246:	68fb      	ldr	r3, [r7, #12]
 8005248:	225c      	movs	r2, #92	; 0x5c
 800524a:	2100      	movs	r1, #0
 800524c:	5299      	strh	r1, [r3, r2]

  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800524e:	68fb      	ldr	r3, [r7, #12]
 8005250:	2280      	movs	r2, #128	; 0x80
 8005252:	2100      	movs	r1, #0
 8005254:	5099      	str	r1, [r3, r2]
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 8005256:	68fb      	ldr	r3, [r7, #12]
 8005258:	2222      	movs	r2, #34	; 0x22
 800525a:	67da      	str	r2, [r3, #124]	; 0x7c
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800525c:	f3ef 8310 	mrs	r3, PRIMASK
 8005260:	61fb      	str	r3, [r7, #28]
  return(result);
 8005262:	69fb      	ldr	r3, [r7, #28]

  /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8005264:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005266:	2301      	movs	r3, #1
 8005268:	623b      	str	r3, [r7, #32]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800526a:	6a3b      	ldr	r3, [r7, #32]
 800526c:	f383 8810 	msr	PRIMASK, r3
}
 8005270:	46c0      	nop			; (mov r8, r8)
 8005272:	68fb      	ldr	r3, [r7, #12]
 8005274:	681b      	ldr	r3, [r3, #0]
 8005276:	689a      	ldr	r2, [r3, #8]
 8005278:	68fb      	ldr	r3, [r7, #12]
 800527a:	681b      	ldr	r3, [r3, #0]
 800527c:	2101      	movs	r1, #1
 800527e:	430a      	orrs	r2, r1
 8005280:	609a      	str	r2, [r3, #8]
 8005282:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005284:	627b      	str	r3, [r7, #36]	; 0x24
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005286:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005288:	f383 8810 	msr	PRIMASK, r3
}
 800528c:	46c0      	nop			; (mov r8, r8)

  /* Set the Rx ISR function pointer according to the data word length */
  if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800528e:	68fb      	ldr	r3, [r7, #12]
 8005290:	689a      	ldr	r2, [r3, #8]
 8005292:	2380      	movs	r3, #128	; 0x80
 8005294:	015b      	lsls	r3, r3, #5
 8005296:	429a      	cmp	r2, r3
 8005298:	d107      	bne.n	80052aa <UART_Start_Receive_IT+0x106>
 800529a:	68fb      	ldr	r3, [r7, #12]
 800529c:	691b      	ldr	r3, [r3, #16]
 800529e:	2b00      	cmp	r3, #0
 80052a0:	d103      	bne.n	80052aa <UART_Start_Receive_IT+0x106>
  {
    huart->RxISR = UART_RxISR_16BIT;
 80052a2:	68fb      	ldr	r3, [r7, #12]
 80052a4:	4a15      	ldr	r2, [pc, #84]	; (80052fc <UART_Start_Receive_IT+0x158>)
 80052a6:	665a      	str	r2, [r3, #100]	; 0x64
 80052a8:	e002      	b.n	80052b0 <UART_Start_Receive_IT+0x10c>
  }
  else
  {
    huart->RxISR = UART_RxISR_8BIT;
 80052aa:	68fb      	ldr	r3, [r7, #12]
 80052ac:	4a14      	ldr	r2, [pc, #80]	; (8005300 <UART_Start_Receive_IT+0x15c>)
 80052ae:	665a      	str	r2, [r3, #100]	; 0x64
  }

  __HAL_UNLOCK(huart);
 80052b0:	68fb      	ldr	r3, [r7, #12]
 80052b2:	2274      	movs	r2, #116	; 0x74
 80052b4:	2100      	movs	r1, #0
 80052b6:	5499      	strb	r1, [r3, r2]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80052b8:	f3ef 8310 	mrs	r3, PRIMASK
 80052bc:	613b      	str	r3, [r7, #16]
  return(result);
 80052be:	693b      	ldr	r3, [r7, #16]

  /* Enable the UART Parity Error interrupt and Data Register Not Empty interrupt */
  ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
 80052c0:	62bb      	str	r3, [r7, #40]	; 0x28
 80052c2:	2301      	movs	r3, #1
 80052c4:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80052c6:	697b      	ldr	r3, [r7, #20]
 80052c8:	f383 8810 	msr	PRIMASK, r3
}
 80052cc:	46c0      	nop			; (mov r8, r8)
 80052ce:	68fb      	ldr	r3, [r7, #12]
 80052d0:	681b      	ldr	r3, [r3, #0]
 80052d2:	681a      	ldr	r2, [r3, #0]
 80052d4:	68fb      	ldr	r3, [r7, #12]
 80052d6:	681b      	ldr	r3, [r3, #0]
 80052d8:	2190      	movs	r1, #144	; 0x90
 80052da:	0049      	lsls	r1, r1, #1
 80052dc:	430a      	orrs	r2, r1
 80052de:	601a      	str	r2, [r3, #0]
 80052e0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80052e2:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80052e4:	69bb      	ldr	r3, [r7, #24]
 80052e6:	f383 8810 	msr	PRIMASK, r3
}
 80052ea:	46c0      	nop			; (mov r8, r8)
  return HAL_OK;
 80052ec:	2300      	movs	r3, #0
}
 80052ee:	0018      	movs	r0, r3
 80052f0:	46bd      	mov	sp, r7
 80052f2:	b00c      	add	sp, #48	; 0x30
 80052f4:	bd80      	pop	{r7, pc}
 80052f6:	46c0      	nop			; (mov r8, r8)
 80052f8:	000001ff 	.word	0x000001ff
 80052fc:	080055b5 	.word	0x080055b5
 8005300:	0800544d 	.word	0x0800544d

08005304 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 8005304:	b580      	push	{r7, lr}
 8005306:	b08e      	sub	sp, #56	; 0x38
 8005308:	af00      	add	r7, sp, #0
 800530a:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800530c:	f3ef 8310 	mrs	r3, PRIMASK
 8005310:	617b      	str	r3, [r7, #20]
  return(result);
 8005312:	697b      	ldr	r3, [r7, #20]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8005314:	637b      	str	r3, [r7, #52]	; 0x34
 8005316:	2301      	movs	r3, #1
 8005318:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800531a:	69bb      	ldr	r3, [r7, #24]
 800531c:	f383 8810 	msr	PRIMASK, r3
}
 8005320:	46c0      	nop			; (mov r8, r8)
 8005322:	687b      	ldr	r3, [r7, #4]
 8005324:	681b      	ldr	r3, [r3, #0]
 8005326:	681a      	ldr	r2, [r3, #0]
 8005328:	687b      	ldr	r3, [r7, #4]
 800532a:	681b      	ldr	r3, [r3, #0]
 800532c:	4925      	ldr	r1, [pc, #148]	; (80053c4 <UART_EndRxTransfer+0xc0>)
 800532e:	400a      	ands	r2, r1
 8005330:	601a      	str	r2, [r3, #0]
 8005332:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8005334:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005336:	69fb      	ldr	r3, [r7, #28]
 8005338:	f383 8810 	msr	PRIMASK, r3
}
 800533c:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800533e:	f3ef 8310 	mrs	r3, PRIMASK
 8005342:	623b      	str	r3, [r7, #32]
  return(result);
 8005344:	6a3b      	ldr	r3, [r7, #32]
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8005346:	633b      	str	r3, [r7, #48]	; 0x30
 8005348:	2301      	movs	r3, #1
 800534a:	627b      	str	r3, [r7, #36]	; 0x24
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800534c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800534e:	f383 8810 	msr	PRIMASK, r3
}
 8005352:	46c0      	nop			; (mov r8, r8)
 8005354:	687b      	ldr	r3, [r7, #4]
 8005356:	681b      	ldr	r3, [r3, #0]
 8005358:	689a      	ldr	r2, [r3, #8]
 800535a:	687b      	ldr	r3, [r7, #4]
 800535c:	681b      	ldr	r3, [r3, #0]
 800535e:	2101      	movs	r1, #1
 8005360:	438a      	bics	r2, r1
 8005362:	609a      	str	r2, [r3, #8]
 8005364:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005366:	62bb      	str	r3, [r7, #40]	; 0x28
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005368:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800536a:	f383 8810 	msr	PRIMASK, r3
}
 800536e:	46c0      	nop			; (mov r8, r8)

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8005370:	687b      	ldr	r3, [r7, #4]
 8005372:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8005374:	2b01      	cmp	r3, #1
 8005376:	d118      	bne.n	80053aa <UART_EndRxTransfer+0xa6>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8005378:	f3ef 8310 	mrs	r3, PRIMASK
 800537c:	60bb      	str	r3, [r7, #8]
  return(result);
 800537e:	68bb      	ldr	r3, [r7, #8]
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8005380:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005382:	2301      	movs	r3, #1
 8005384:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005386:	68fb      	ldr	r3, [r7, #12]
 8005388:	f383 8810 	msr	PRIMASK, r3
}
 800538c:	46c0      	nop			; (mov r8, r8)
 800538e:	687b      	ldr	r3, [r7, #4]
 8005390:	681b      	ldr	r3, [r3, #0]
 8005392:	681a      	ldr	r2, [r3, #0]
 8005394:	687b      	ldr	r3, [r7, #4]
 8005396:	681b      	ldr	r3, [r3, #0]
 8005398:	2110      	movs	r1, #16
 800539a:	438a      	bics	r2, r1
 800539c:	601a      	str	r2, [r3, #0]
 800539e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80053a0:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80053a2:	693b      	ldr	r3, [r7, #16]
 80053a4:	f383 8810 	msr	PRIMASK, r3
}
 80053a8:	46c0      	nop			; (mov r8, r8)
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 80053aa:	687b      	ldr	r3, [r7, #4]
 80053ac:	2220      	movs	r2, #32
 80053ae:	67da      	str	r2, [r3, #124]	; 0x7c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80053b0:	687b      	ldr	r3, [r7, #4]
 80053b2:	2200      	movs	r2, #0
 80053b4:	661a      	str	r2, [r3, #96]	; 0x60

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 80053b6:	687b      	ldr	r3, [r7, #4]
 80053b8:	2200      	movs	r2, #0
 80053ba:	665a      	str	r2, [r3, #100]	; 0x64
}
 80053bc:	46c0      	nop			; (mov r8, r8)
 80053be:	46bd      	mov	sp, r7
 80053c0:	b00e      	add	sp, #56	; 0x38
 80053c2:	bd80      	pop	{r7, pc}
 80053c4:	fffffedf 	.word	0xfffffedf

080053c8 <UART_DMAAbortOnError>:
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 80053c8:	b580      	push	{r7, lr}
 80053ca:	b084      	sub	sp, #16
 80053cc:	af00      	add	r7, sp, #0
 80053ce:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 80053d0:	687b      	ldr	r3, [r7, #4]
 80053d2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80053d4:	60fb      	str	r3, [r7, #12]
  huart->RxXferCount = 0U;
 80053d6:	68fb      	ldr	r3, [r7, #12]
 80053d8:	225a      	movs	r2, #90	; 0x5a
 80053da:	2100      	movs	r1, #0
 80053dc:	5299      	strh	r1, [r3, r2]
  huart->TxXferCount = 0U;
 80053de:	68fb      	ldr	r3, [r7, #12]
 80053e0:	2252      	movs	r2, #82	; 0x52
 80053e2:	2100      	movs	r1, #0
 80053e4:	5299      	strh	r1, [r3, r2]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 80053e6:	68fb      	ldr	r3, [r7, #12]
 80053e8:	0018      	movs	r0, r3
 80053ea:	f7ff fa49 	bl	8004880 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 80053ee:	46c0      	nop			; (mov r8, r8)
 80053f0:	46bd      	mov	sp, r7
 80053f2:	b004      	add	sp, #16
 80053f4:	bd80      	pop	{r7, pc}

080053f6 <UART_EndTransmit_IT>:
  * @param  huart pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
 80053f6:	b580      	push	{r7, lr}
 80053f8:	b086      	sub	sp, #24
 80053fa:	af00      	add	r7, sp, #0
 80053fc:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80053fe:	f3ef 8310 	mrs	r3, PRIMASK
 8005402:	60bb      	str	r3, [r7, #8]
  return(result);
 8005404:	68bb      	ldr	r3, [r7, #8]
  /* Disable the UART Transmit Complete Interrupt */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8005406:	617b      	str	r3, [r7, #20]
 8005408:	2301      	movs	r3, #1
 800540a:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800540c:	68fb      	ldr	r3, [r7, #12]
 800540e:	f383 8810 	msr	PRIMASK, r3
}
 8005412:	46c0      	nop			; (mov r8, r8)
 8005414:	687b      	ldr	r3, [r7, #4]
 8005416:	681b      	ldr	r3, [r3, #0]
 8005418:	681a      	ldr	r2, [r3, #0]
 800541a:	687b      	ldr	r3, [r7, #4]
 800541c:	681b      	ldr	r3, [r3, #0]
 800541e:	2140      	movs	r1, #64	; 0x40
 8005420:	438a      	bics	r2, r1
 8005422:	601a      	str	r2, [r3, #0]
 8005424:	697b      	ldr	r3, [r7, #20]
 8005426:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005428:	693b      	ldr	r3, [r7, #16]
 800542a:	f383 8810 	msr	PRIMASK, r3
}
 800542e:	46c0      	nop			; (mov r8, r8)

  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 8005430:	687b      	ldr	r3, [r7, #4]
 8005432:	2220      	movs	r2, #32
 8005434:	679a      	str	r2, [r3, #120]	; 0x78

  /* Cleat TxISR function pointer */
  huart->TxISR = NULL;
 8005436:	687b      	ldr	r3, [r7, #4]
 8005438:	2200      	movs	r2, #0
 800543a:	669a      	str	r2, [r3, #104]	; 0x68
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx complete callback*/
  huart->TxCpltCallback(huart);
#else
  /*Call legacy weak Tx complete callback*/
  HAL_UART_TxCpltCallback(huart);
 800543c:	687b      	ldr	r3, [r7, #4]
 800543e:	0018      	movs	r0, r3
 8005440:	f7ff fa16 	bl	8004870 <HAL_UART_TxCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 8005444:	46c0      	nop			; (mov r8, r8)
 8005446:	46bd      	mov	sp, r7
 8005448:	b006      	add	sp, #24
 800544a:	bd80      	pop	{r7, pc}

0800544c <UART_RxISR_8BIT>:
  * @brief RX interrupt handler for 7 or 8 bits data word length .
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_8BIT(UART_HandleTypeDef *huart)
{
 800544c:	b580      	push	{r7, lr}
 800544e:	b090      	sub	sp, #64	; 0x40
 8005450:	af00      	add	r7, sp, #0
 8005452:	6078      	str	r0, [r7, #4]
  uint16_t uhMask = huart->Mask;
 8005454:	203e      	movs	r0, #62	; 0x3e
 8005456:	183b      	adds	r3, r7, r0
 8005458:	687a      	ldr	r2, [r7, #4]
 800545a:	215c      	movs	r1, #92	; 0x5c
 800545c:	5a52      	ldrh	r2, [r2, r1]
 800545e:	801a      	strh	r2, [r3, #0]
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8005460:	687b      	ldr	r3, [r7, #4]
 8005462:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8005464:	2b22      	cmp	r3, #34	; 0x22
 8005466:	d000      	beq.n	800546a <UART_RxISR_8BIT+0x1e>
 8005468:	e095      	b.n	8005596 <UART_RxISR_8BIT+0x14a>
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 800546a:	687b      	ldr	r3, [r7, #4]
 800546c:	681b      	ldr	r3, [r3, #0]
 800546e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8005470:	213c      	movs	r1, #60	; 0x3c
 8005472:	187b      	adds	r3, r7, r1
 8005474:	801a      	strh	r2, [r3, #0]
    *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 8005476:	187b      	adds	r3, r7, r1
 8005478:	881b      	ldrh	r3, [r3, #0]
 800547a:	b2da      	uxtb	r2, r3
 800547c:	183b      	adds	r3, r7, r0
 800547e:	881b      	ldrh	r3, [r3, #0]
 8005480:	b2d9      	uxtb	r1, r3
 8005482:	687b      	ldr	r3, [r7, #4]
 8005484:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8005486:	400a      	ands	r2, r1
 8005488:	b2d2      	uxtb	r2, r2
 800548a:	701a      	strb	r2, [r3, #0]
    huart->pRxBuffPtr++;
 800548c:	687b      	ldr	r3, [r7, #4]
 800548e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8005490:	1c5a      	adds	r2, r3, #1
 8005492:	687b      	ldr	r3, [r7, #4]
 8005494:	655a      	str	r2, [r3, #84]	; 0x54
    huart->RxXferCount--;
 8005496:	687b      	ldr	r3, [r7, #4]
 8005498:	225a      	movs	r2, #90	; 0x5a
 800549a:	5a9b      	ldrh	r3, [r3, r2]
 800549c:	b29b      	uxth	r3, r3
 800549e:	3b01      	subs	r3, #1
 80054a0:	b299      	uxth	r1, r3
 80054a2:	687b      	ldr	r3, [r7, #4]
 80054a4:	225a      	movs	r2, #90	; 0x5a
 80054a6:	5299      	strh	r1, [r3, r2]

    if (huart->RxXferCount == 0U)
 80054a8:	687b      	ldr	r3, [r7, #4]
 80054aa:	225a      	movs	r2, #90	; 0x5a
 80054ac:	5a9b      	ldrh	r3, [r3, r2]
 80054ae:	b29b      	uxth	r3, r3
 80054b0:	2b00      	cmp	r3, #0
 80054b2:	d178      	bne.n	80055a6 <UART_RxISR_8BIT+0x15a>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80054b4:	f3ef 8310 	mrs	r3, PRIMASK
 80054b8:	61bb      	str	r3, [r7, #24]
  return(result);
 80054ba:	69bb      	ldr	r3, [r7, #24]
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupts */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 80054bc:	63bb      	str	r3, [r7, #56]	; 0x38
 80054be:	2301      	movs	r3, #1
 80054c0:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80054c2:	69fb      	ldr	r3, [r7, #28]
 80054c4:	f383 8810 	msr	PRIMASK, r3
}
 80054c8:	46c0      	nop			; (mov r8, r8)
 80054ca:	687b      	ldr	r3, [r7, #4]
 80054cc:	681b      	ldr	r3, [r3, #0]
 80054ce:	681a      	ldr	r2, [r3, #0]
 80054d0:	687b      	ldr	r3, [r7, #4]
 80054d2:	681b      	ldr	r3, [r3, #0]
 80054d4:	4936      	ldr	r1, [pc, #216]	; (80055b0 <UART_RxISR_8BIT+0x164>)
 80054d6:	400a      	ands	r2, r1
 80054d8:	601a      	str	r2, [r3, #0]
 80054da:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80054dc:	623b      	str	r3, [r7, #32]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80054de:	6a3b      	ldr	r3, [r7, #32]
 80054e0:	f383 8810 	msr	PRIMASK, r3
}
 80054e4:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80054e6:	f3ef 8310 	mrs	r3, PRIMASK
 80054ea:	627b      	str	r3, [r7, #36]	; 0x24
  return(result);
 80054ec:	6a7b      	ldr	r3, [r7, #36]	; 0x24

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80054ee:	637b      	str	r3, [r7, #52]	; 0x34
 80054f0:	2301      	movs	r3, #1
 80054f2:	62bb      	str	r3, [r7, #40]	; 0x28
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80054f4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80054f6:	f383 8810 	msr	PRIMASK, r3
}
 80054fa:	46c0      	nop			; (mov r8, r8)
 80054fc:	687b      	ldr	r3, [r7, #4]
 80054fe:	681b      	ldr	r3, [r3, #0]
 8005500:	689a      	ldr	r2, [r3, #8]
 8005502:	687b      	ldr	r3, [r7, #4]
 8005504:	681b      	ldr	r3, [r3, #0]
 8005506:	2101      	movs	r1, #1
 8005508:	438a      	bics	r2, r1
 800550a:	609a      	str	r2, [r3, #8]
 800550c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800550e:	62fb      	str	r3, [r7, #44]	; 0x2c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005510:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005512:	f383 8810 	msr	PRIMASK, r3
}
 8005516:	46c0      	nop			; (mov r8, r8)

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 8005518:	687b      	ldr	r3, [r7, #4]
 800551a:	2220      	movs	r2, #32
 800551c:	67da      	str	r2, [r3, #124]	; 0x7c

      /* Clear RxISR function pointer */
      huart->RxISR = NULL;
 800551e:	687b      	ldr	r3, [r7, #4]
 8005520:	2200      	movs	r2, #0
 8005522:	665a      	str	r2, [r3, #100]	; 0x64

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8005524:	687b      	ldr	r3, [r7, #4]
 8005526:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8005528:	2b01      	cmp	r3, #1
 800552a:	d12f      	bne.n	800558c <UART_RxISR_8BIT+0x140>
      {
        /* Set reception type to Standard */
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800552c:	687b      	ldr	r3, [r7, #4]
 800552e:	2200      	movs	r2, #0
 8005530:	661a      	str	r2, [r3, #96]	; 0x60
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8005532:	f3ef 8310 	mrs	r3, PRIMASK
 8005536:	60fb      	str	r3, [r7, #12]
  return(result);
 8005538:	68fb      	ldr	r3, [r7, #12]

        /* Disable IDLE interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800553a:	633b      	str	r3, [r7, #48]	; 0x30
 800553c:	2301      	movs	r3, #1
 800553e:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005540:	693b      	ldr	r3, [r7, #16]
 8005542:	f383 8810 	msr	PRIMASK, r3
}
 8005546:	46c0      	nop			; (mov r8, r8)
 8005548:	687b      	ldr	r3, [r7, #4]
 800554a:	681b      	ldr	r3, [r3, #0]
 800554c:	681a      	ldr	r2, [r3, #0]
 800554e:	687b      	ldr	r3, [r7, #4]
 8005550:	681b      	ldr	r3, [r3, #0]
 8005552:	2110      	movs	r1, #16
 8005554:	438a      	bics	r2, r1
 8005556:	601a      	str	r2, [r3, #0]
 8005558:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800555a:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800555c:	697b      	ldr	r3, [r7, #20]
 800555e:	f383 8810 	msr	PRIMASK, r3
}
 8005562:	46c0      	nop			; (mov r8, r8)

        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 8005564:	687b      	ldr	r3, [r7, #4]
 8005566:	681b      	ldr	r3, [r3, #0]
 8005568:	69db      	ldr	r3, [r3, #28]
 800556a:	2210      	movs	r2, #16
 800556c:	4013      	ands	r3, r2
 800556e:	2b10      	cmp	r3, #16
 8005570:	d103      	bne.n	800557a <UART_RxISR_8BIT+0x12e>
        {
          /* Clear IDLE Flag */
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8005572:	687b      	ldr	r3, [r7, #4]
 8005574:	681b      	ldr	r3, [r3, #0]
 8005576:	2210      	movs	r2, #16
 8005578:	621a      	str	r2, [r3, #32]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, huart->RxXferSize);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 800557a:	687b      	ldr	r3, [r7, #4]
 800557c:	2258      	movs	r2, #88	; 0x58
 800557e:	5a9a      	ldrh	r2, [r3, r2]
 8005580:	687b      	ldr	r3, [r7, #4]
 8005582:	0011      	movs	r1, r2
 8005584:	0018      	movs	r0, r3
 8005586:	f7ff f983 	bl	8004890 <HAL_UARTEx_RxEventCallback>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 800558a:	e00c      	b.n	80055a6 <UART_RxISR_8BIT+0x15a>
        HAL_UART_RxCpltCallback(huart);
 800558c:	687b      	ldr	r3, [r7, #4]
 800558e:	0018      	movs	r0, r3
 8005590:	f7fa ff96 	bl	80004c0 <HAL_UART_RxCpltCallback>
}
 8005594:	e007      	b.n	80055a6 <UART_RxISR_8BIT+0x15a>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8005596:	687b      	ldr	r3, [r7, #4]
 8005598:	681b      	ldr	r3, [r3, #0]
 800559a:	699a      	ldr	r2, [r3, #24]
 800559c:	687b      	ldr	r3, [r7, #4]
 800559e:	681b      	ldr	r3, [r3, #0]
 80055a0:	2108      	movs	r1, #8
 80055a2:	430a      	orrs	r2, r1
 80055a4:	619a      	str	r2, [r3, #24]
}
 80055a6:	46c0      	nop			; (mov r8, r8)
 80055a8:	46bd      	mov	sp, r7
 80055aa:	b010      	add	sp, #64	; 0x40
 80055ac:	bd80      	pop	{r7, pc}
 80055ae:	46c0      	nop			; (mov r8, r8)
 80055b0:	fffffedf 	.word	0xfffffedf

080055b4 <UART_RxISR_16BIT>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_16BIT(UART_HandleTypeDef *huart)
{
 80055b4:	b580      	push	{r7, lr}
 80055b6:	b090      	sub	sp, #64	; 0x40
 80055b8:	af00      	add	r7, sp, #0
 80055ba:	6078      	str	r0, [r7, #4]
  uint16_t *tmp;
  uint16_t uhMask = huart->Mask;
 80055bc:	203e      	movs	r0, #62	; 0x3e
 80055be:	183b      	adds	r3, r7, r0
 80055c0:	687a      	ldr	r2, [r7, #4]
 80055c2:	215c      	movs	r1, #92	; 0x5c
 80055c4:	5a52      	ldrh	r2, [r2, r1]
 80055c6:	801a      	strh	r2, [r3, #0]
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 80055c8:	687b      	ldr	r3, [r7, #4]
 80055ca:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80055cc:	2b22      	cmp	r3, #34	; 0x22
 80055ce:	d000      	beq.n	80055d2 <UART_RxISR_16BIT+0x1e>
 80055d0:	e095      	b.n	80056fe <UART_RxISR_16BIT+0x14a>
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 80055d2:	687b      	ldr	r3, [r7, #4]
 80055d4:	681b      	ldr	r3, [r3, #0]
 80055d6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80055d8:	213c      	movs	r1, #60	; 0x3c
 80055da:	187b      	adds	r3, r7, r1
 80055dc:	801a      	strh	r2, [r3, #0]
    tmp = (uint16_t *) huart->pRxBuffPtr ;
 80055de:	687b      	ldr	r3, [r7, #4]
 80055e0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80055e2:	63bb      	str	r3, [r7, #56]	; 0x38
    *tmp = (uint16_t)(uhdata & uhMask);
 80055e4:	187b      	adds	r3, r7, r1
 80055e6:	183a      	adds	r2, r7, r0
 80055e8:	881b      	ldrh	r3, [r3, #0]
 80055ea:	8812      	ldrh	r2, [r2, #0]
 80055ec:	4013      	ands	r3, r2
 80055ee:	b29a      	uxth	r2, r3
 80055f0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80055f2:	801a      	strh	r2, [r3, #0]
    huart->pRxBuffPtr += 2U;
 80055f4:	687b      	ldr	r3, [r7, #4]
 80055f6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80055f8:	1c9a      	adds	r2, r3, #2
 80055fa:	687b      	ldr	r3, [r7, #4]
 80055fc:	655a      	str	r2, [r3, #84]	; 0x54
    huart->RxXferCount--;
 80055fe:	687b      	ldr	r3, [r7, #4]
 8005600:	225a      	movs	r2, #90	; 0x5a
 8005602:	5a9b      	ldrh	r3, [r3, r2]
 8005604:	b29b      	uxth	r3, r3
 8005606:	3b01      	subs	r3, #1
 8005608:	b299      	uxth	r1, r3
 800560a:	687b      	ldr	r3, [r7, #4]
 800560c:	225a      	movs	r2, #90	; 0x5a
 800560e:	5299      	strh	r1, [r3, r2]

    if (huart->RxXferCount == 0U)
 8005610:	687b      	ldr	r3, [r7, #4]
 8005612:	225a      	movs	r2, #90	; 0x5a
 8005614:	5a9b      	ldrh	r3, [r3, r2]
 8005616:	b29b      	uxth	r3, r3
 8005618:	2b00      	cmp	r3, #0
 800561a:	d178      	bne.n	800570e <UART_RxISR_16BIT+0x15a>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800561c:	f3ef 8310 	mrs	r3, PRIMASK
 8005620:	617b      	str	r3, [r7, #20]
  return(result);
 8005622:	697b      	ldr	r3, [r7, #20]
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8005624:	637b      	str	r3, [r7, #52]	; 0x34
 8005626:	2301      	movs	r3, #1
 8005628:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800562a:	69bb      	ldr	r3, [r7, #24]
 800562c:	f383 8810 	msr	PRIMASK, r3
}
 8005630:	46c0      	nop			; (mov r8, r8)
 8005632:	687b      	ldr	r3, [r7, #4]
 8005634:	681b      	ldr	r3, [r3, #0]
 8005636:	681a      	ldr	r2, [r3, #0]
 8005638:	687b      	ldr	r3, [r7, #4]
 800563a:	681b      	ldr	r3, [r3, #0]
 800563c:	4936      	ldr	r1, [pc, #216]	; (8005718 <UART_RxISR_16BIT+0x164>)
 800563e:	400a      	ands	r2, r1
 8005640:	601a      	str	r2, [r3, #0]
 8005642:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8005644:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005646:	69fb      	ldr	r3, [r7, #28]
 8005648:	f383 8810 	msr	PRIMASK, r3
}
 800564c:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800564e:	f3ef 8310 	mrs	r3, PRIMASK
 8005652:	623b      	str	r3, [r7, #32]
  return(result);
 8005654:	6a3b      	ldr	r3, [r7, #32]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8005656:	633b      	str	r3, [r7, #48]	; 0x30
 8005658:	2301      	movs	r3, #1
 800565a:	627b      	str	r3, [r7, #36]	; 0x24
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800565c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800565e:	f383 8810 	msr	PRIMASK, r3
}
 8005662:	46c0      	nop			; (mov r8, r8)
 8005664:	687b      	ldr	r3, [r7, #4]
 8005666:	681b      	ldr	r3, [r3, #0]
 8005668:	689a      	ldr	r2, [r3, #8]
 800566a:	687b      	ldr	r3, [r7, #4]
 800566c:	681b      	ldr	r3, [r3, #0]
 800566e:	2101      	movs	r1, #1
 8005670:	438a      	bics	r2, r1
 8005672:	609a      	str	r2, [r3, #8]
 8005674:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005676:	62bb      	str	r3, [r7, #40]	; 0x28
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005678:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800567a:	f383 8810 	msr	PRIMASK, r3
}
 800567e:	46c0      	nop			; (mov r8, r8)

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 8005680:	687b      	ldr	r3, [r7, #4]
 8005682:	2220      	movs	r2, #32
 8005684:	67da      	str	r2, [r3, #124]	; 0x7c

      /* Clear RxISR function pointer */
      huart->RxISR = NULL;
 8005686:	687b      	ldr	r3, [r7, #4]
 8005688:	2200      	movs	r2, #0
 800568a:	665a      	str	r2, [r3, #100]	; 0x64

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800568c:	687b      	ldr	r3, [r7, #4]
 800568e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8005690:	2b01      	cmp	r3, #1
 8005692:	d12f      	bne.n	80056f4 <UART_RxISR_16BIT+0x140>
      {
        /* Set reception type to Standard */
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8005694:	687b      	ldr	r3, [r7, #4]
 8005696:	2200      	movs	r2, #0
 8005698:	661a      	str	r2, [r3, #96]	; 0x60
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800569a:	f3ef 8310 	mrs	r3, PRIMASK
 800569e:	60bb      	str	r3, [r7, #8]
  return(result);
 80056a0:	68bb      	ldr	r3, [r7, #8]

        /* Disable IDLE interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 80056a2:	62fb      	str	r3, [r7, #44]	; 0x2c
 80056a4:	2301      	movs	r3, #1
 80056a6:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80056a8:	68fb      	ldr	r3, [r7, #12]
 80056aa:	f383 8810 	msr	PRIMASK, r3
}
 80056ae:	46c0      	nop			; (mov r8, r8)
 80056b0:	687b      	ldr	r3, [r7, #4]
 80056b2:	681b      	ldr	r3, [r3, #0]
 80056b4:	681a      	ldr	r2, [r3, #0]
 80056b6:	687b      	ldr	r3, [r7, #4]
 80056b8:	681b      	ldr	r3, [r3, #0]
 80056ba:	2110      	movs	r1, #16
 80056bc:	438a      	bics	r2, r1
 80056be:	601a      	str	r2, [r3, #0]
 80056c0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80056c2:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80056c4:	693b      	ldr	r3, [r7, #16]
 80056c6:	f383 8810 	msr	PRIMASK, r3
}
 80056ca:	46c0      	nop			; (mov r8, r8)

        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 80056cc:	687b      	ldr	r3, [r7, #4]
 80056ce:	681b      	ldr	r3, [r3, #0]
 80056d0:	69db      	ldr	r3, [r3, #28]
 80056d2:	2210      	movs	r2, #16
 80056d4:	4013      	ands	r3, r2
 80056d6:	2b10      	cmp	r3, #16
 80056d8:	d103      	bne.n	80056e2 <UART_RxISR_16BIT+0x12e>
        {
          /* Clear IDLE Flag */
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 80056da:	687b      	ldr	r3, [r7, #4]
 80056dc:	681b      	ldr	r3, [r3, #0]
 80056de:	2210      	movs	r2, #16
 80056e0:	621a      	str	r2, [r3, #32]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, huart->RxXferSize);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 80056e2:	687b      	ldr	r3, [r7, #4]
 80056e4:	2258      	movs	r2, #88	; 0x58
 80056e6:	5a9a      	ldrh	r2, [r3, r2]
 80056e8:	687b      	ldr	r3, [r7, #4]
 80056ea:	0011      	movs	r1, r2
 80056ec:	0018      	movs	r0, r3
 80056ee:	f7ff f8cf 	bl	8004890 <HAL_UARTEx_RxEventCallback>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 80056f2:	e00c      	b.n	800570e <UART_RxISR_16BIT+0x15a>
        HAL_UART_RxCpltCallback(huart);
 80056f4:	687b      	ldr	r3, [r7, #4]
 80056f6:	0018      	movs	r0, r3
 80056f8:	f7fa fee2 	bl	80004c0 <HAL_UART_RxCpltCallback>
}
 80056fc:	e007      	b.n	800570e <UART_RxISR_16BIT+0x15a>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 80056fe:	687b      	ldr	r3, [r7, #4]
 8005700:	681b      	ldr	r3, [r3, #0]
 8005702:	699a      	ldr	r2, [r3, #24]
 8005704:	687b      	ldr	r3, [r7, #4]
 8005706:	681b      	ldr	r3, [r3, #0]
 8005708:	2108      	movs	r1, #8
 800570a:	430a      	orrs	r2, r1
 800570c:	619a      	str	r2, [r3, #24]
}
 800570e:	46c0      	nop			; (mov r8, r8)
 8005710:	46bd      	mov	sp, r7
 8005712:	b010      	add	sp, #64	; 0x40
 8005714:	bd80      	pop	{r7, pc}
 8005716:	46c0      	nop			; (mov r8, r8)
 8005718:	fffffedf 	.word	0xfffffedf

0800571c <HAL_UARTEx_WakeupCallback>:
  * @brief UART wakeup from Stop mode callback.
  * @param huart UART handle.
  * @retval None
  */
__weak void HAL_UARTEx_WakeupCallback(UART_HandleTypeDef *huart)
{
 800571c:	b580      	push	{r7, lr}
 800571e:	b082      	sub	sp, #8
 8005720:	af00      	add	r7, sp, #0
 8005722:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_WakeupCallback can be implemented in the user file.
   */
}
 8005724:	46c0      	nop			; (mov r8, r8)
 8005726:	46bd      	mov	sp, r7
 8005728:	b002      	add	sp, #8
 800572a:	bd80      	pop	{r7, pc}

0800572c <HTTP_Headers_Done_Callback>:
}
/**
 * @brief Header received done callback
 */
err_t HTTP_Headers_Done_Callback(httpc_state_t *connection, void *arg, struct pbuf *hdr, u16_t hdr_len, u32_t content_len)
{
 800572c:	b580      	push	{r7, lr}
 800572e:	b084      	sub	sp, #16
 8005730:	af00      	add	r7, sp, #0
 8005732:	60f8      	str	r0, [r7, #12]
 8005734:	60b9      	str	r1, [r7, #8]
 8005736:	607a      	str	r2, [r7, #4]
 8005738:	001a      	movs	r2, r3
 800573a:	1cbb      	adds	r3, r7, #2
 800573c:	801a      	strh	r2, [r3, #0]
    DEBUG_INFO("httpc_headers_callback, content length %d\r\n", content_len);
 800573e:	f017 f9f5 	bl	801cb2c <sys_get_tick_ms>
 8005742:	0001      	movs	r1, r0
 8005744:	69bb      	ldr	r3, [r7, #24]
 8005746:	4a0e      	ldr	r2, [pc, #56]	; (8005780 <HTTP_Headers_Done_Callback+0x54>)
 8005748:	480e      	ldr	r0, [pc, #56]	; (8005784 <HTTP_Headers_Done_Callback+0x58>)
 800574a:	f7fd f8c7 	bl	80028dc <app_debug_rtt_raw>
    //DEBUG_INFO("HTTP header %.*s\r\n", hdr->len, hdr->payload);

    if (content_len == 0xFFFFFFFF)
 800574e:	69bb      	ldr	r3, [r7, #24]
 8005750:	3301      	adds	r3, #1
 8005752:	d108      	bne.n	8005766 <HTTP_Headers_Done_Callback+0x3a>
            Content length khÃ´ng há»£p lá», cÃ³ thá» cÃ³ nhá»¯ng lÃ­ do sau
            	- Trong header server tráº£ vá» khÃ´ng cÃ³ trÆ°á»ng "Content-Length"
            	- Server tráº£ vá» dáº¡ng stream data, dá»¯ liá»u káº¿t thÃºc khi server ÄÃ³ng káº¿t ná»i
            	- CÃ¡c lÃ­ do khÃ¡c
        */
        DEBUG_INFO("Invalid content length\r\n");
 8005754:	f017 f9ea 	bl	801cb2c <sys_get_tick_ms>
 8005758:	0001      	movs	r1, r0
 800575a:	4a09      	ldr	r2, [pc, #36]	; (8005780 <HTTP_Headers_Done_Callback+0x54>)
 800575c:	4b0a      	ldr	r3, [pc, #40]	; (8005788 <HTTP_Headers_Done_Callback+0x5c>)
 800575e:	0018      	movs	r0, r3
 8005760:	f7fd f8bc 	bl	80028dc <app_debug_rtt_raw>
 8005764:	e007      	b.n	8005776 <HTTP_Headers_Done_Callback+0x4a>
    }
    else
    {
        DEBUG_INFO("HTTP content length %u bytes\r\n", content_len);
 8005766:	f017 f9e1 	bl	801cb2c <sys_get_tick_ms>
 800576a:	0001      	movs	r1, r0
 800576c:	69bb      	ldr	r3, [r7, #24]
 800576e:	4a04      	ldr	r2, [pc, #16]	; (8005780 <HTTP_Headers_Done_Callback+0x54>)
 8005770:	4806      	ldr	r0, [pc, #24]	; (800578c <HTTP_Headers_Done_Callback+0x60>)
 8005772:	f7fd f8b3 	bl	80028dc <app_debug_rtt_raw>
    }

    return ERR_OK;
 8005776:	2300      	movs	r3, #0
}
 8005778:	0018      	movs	r0, r3
 800577a:	46bd      	mov	sp, r7
 800577c:	b004      	add	sp, #16
 800577e:	bd80      	pop	{r7, pc}
 8005780:	0801e6e0 	.word	0x0801e6e0
 8005784:	0801e718 	.word	0x0801e718
 8005788:	0801e760 	.word	0x0801e760
 800578c:	0801e794 	.word	0x0801e794

08005790 <HTTP_Result_Callback>:
/**
 * @brief Result transfer done callback
 */
static void HTTP_Result_Callback(void *arg, httpc_result_t httpc_result, u32_t rx_content_len, u32_t srv_res, err_t err)
{
 8005790:	b5b0      	push	{r4, r5, r7, lr}
 8005792:	b086      	sub	sp, #24
 8005794:	af02      	add	r7, sp, #8
 8005796:	60f8      	str	r0, [r7, #12]
 8005798:	607a      	str	r2, [r7, #4]
 800579a:	603b      	str	r3, [r7, #0]
 800579c:	250b      	movs	r5, #11
 800579e:	197b      	adds	r3, r7, r5
 80057a0:	1c0a      	adds	r2, r1, #0
 80057a2:	701a      	strb	r2, [r3, #0]
    DEBUG_INFO("result: %d, content len: %d, status code: %d\r\n", httpc_result, rx_content_len, srv_res);
 80057a4:	f017 f9c2 	bl	801cb2c <sys_get_tick_ms>
 80057a8:	0004      	movs	r4, r0
 80057aa:	197b      	adds	r3, r7, r5
 80057ac:	7819      	ldrb	r1, [r3, #0]
 80057ae:	4a1b      	ldr	r2, [pc, #108]	; (800581c <HTTP_Result_Callback+0x8c>)
 80057b0:	481b      	ldr	r0, [pc, #108]	; (8005820 <HTTP_Result_Callback+0x90>)
 80057b2:	683b      	ldr	r3, [r7, #0]
 80057b4:	9301      	str	r3, [sp, #4]
 80057b6:	687b      	ldr	r3, [r7, #4]
 80057b8:	9300      	str	r3, [sp, #0]
 80057ba:	000b      	movs	r3, r1
 80057bc:	0021      	movs	r1, r4
 80057be:	f7fd f88d 	bl	80028dc <app_debug_rtt_raw>
    switch (err)
 80057c2:	2320      	movs	r3, #32
 80057c4:	18fb      	adds	r3, r7, r3
 80057c6:	781b      	ldrb	r3, [r3, #0]
 80057c8:	b25b      	sxtb	r3, r3
 80057ca:	2b00      	cmp	r3, #0
 80057cc:	d004      	beq.n	80057d8 <HTTP_Result_Callback+0x48>
 80057ce:	db15      	blt.n	80057fc <HTTP_Result_Callback+0x6c>
 80057d0:	3b01      	subs	r3, #1
 80057d2:	2b08      	cmp	r3, #8
 80057d4:	d812      	bhi.n	80057fc <HTTP_Result_Callback+0x6c>
 80057d6:	e008      	b.n	80057ea <HTTP_Result_Callback+0x5a>
    {
        case HTTPC_RESULT_OK: /** File successfully received */
        {
            DEBUG_INFO("HTTPC_RESULT_OK\r\n");
 80057d8:	f017 f9a8 	bl	801cb2c <sys_get_tick_ms>
 80057dc:	0001      	movs	r1, r0
 80057de:	4a0f      	ldr	r2, [pc, #60]	; (800581c <HTTP_Result_Callback+0x8c>)
 80057e0:	4b10      	ldr	r3, [pc, #64]	; (8005824 <HTTP_Result_Callback+0x94>)
 80057e2:	0018      	movs	r0, r3
 80057e4:	f7fd f87a 	bl	80028dc <app_debug_rtt_raw>
        }
            break;
 80057e8:	e014      	b.n	8005814 <HTTP_Result_Callback+0x84>
        case HTTPC_RESULT_ERR_MEM:         /** Local memory error */
                                           //break;
        case HTTPC_RESULT_LOCAL_ABORT:     /** Local abort */
                                           //break;
        case HTTPC_RESULT_ERR_CONTENT_LEN: /** Content length mismatch */
            DEBUG_ERROR("Error content length\r\n");
 80057ea:	f017 f99f 	bl	801cb2c <sys_get_tick_ms>
 80057ee:	0001      	movs	r1, r0
 80057f0:	4a0a      	ldr	r2, [pc, #40]	; (800581c <HTTP_Result_Callback+0x8c>)
 80057f2:	4b0d      	ldr	r3, [pc, #52]	; (8005828 <HTTP_Result_Callback+0x98>)
 80057f4:	0018      	movs	r0, r3
 80057f6:	f7fd f871 	bl	80028dc <app_debug_rtt_raw>
            break;
 80057fa:	e00b      	b.n	8005814 <HTTP_Result_Callback+0x84>

        default:
            DEBUG_INFO("httpc_result_callback error %d\r\n", err);
 80057fc:	f017 f996 	bl	801cb2c <sys_get_tick_ms>
 8005800:	0001      	movs	r1, r0
 8005802:	2320      	movs	r3, #32
 8005804:	18fb      	adds	r3, r7, r3
 8005806:	781b      	ldrb	r3, [r3, #0]
 8005808:	b25b      	sxtb	r3, r3
 800580a:	4a04      	ldr	r2, [pc, #16]	; (800581c <HTTP_Result_Callback+0x8c>)
 800580c:	4807      	ldr	r0, [pc, #28]	; (800582c <HTTP_Result_Callback+0x9c>)
 800580e:	f7fd f865 	bl	80028dc <app_debug_rtt_raw>
            break;
 8005812:	46c0      	nop			; (mov r8, r8)
    }
}
 8005814:	46c0      	nop			; (mov r8, r8)
 8005816:	46bd      	mov	sp, r7
 8005818:	b004      	add	sp, #16
 800581a:	bdb0      	pop	{r4, r5, r7, pc}
 800581c:	0801e6e0 	.word	0x0801e6e0
 8005820:	0801e7cc 	.word	0x0801e7cc
 8005824:	0801e814 	.word	0x0801e814
 8005828:	0801e840 	.word	0x0801e840
 800582c:	0801e870 	.word	0x0801e870

08005830 <HTTP_File_Receive_Callback>:
 * @param pointer to PCB
 * @param pointer to incoming pbuf
 * @param state of incoming process
 */
static err_t HTTP_File_Receive_Callback(void *arg, struct tcp_pcb *tpcb, struct pbuf *data_recv, err_t err)
{
 8005830:	b590      	push	{r4, r7, lr}
 8005832:	b089      	sub	sp, #36	; 0x24
 8005834:	af02      	add	r7, sp, #8
 8005836:	60f8      	str	r0, [r7, #12]
 8005838:	60b9      	str	r1, [r7, #8]
 800583a:	607a      	str	r2, [r7, #4]
 800583c:	001a      	movs	r2, r3
 800583e:	1cfb      	adds	r3, r7, #3
 8005840:	701a      	strb	r2, [r3, #0]
    // Náº¿u cÃ³ dá»¯ liá»u Äáº¿n, kiá»m tra buffer
    // Náº¿u buffer khÃ´ng há»£p lá» (NULL) thÃ¬ ÄÃ³ng káº¿t ná»i TCP
    if (data_recv)
 8005842:	687b      	ldr	r3, [r7, #4]
 8005844:	2b00      	cmp	r3, #0
 8005846:	d02c      	beq.n	80058a2 <HTTP_File_Receive_Callback+0x72>
    {
        struct pbuf *q;
        for (q = data_recv; q; q = q->next)
 8005848:	687b      	ldr	r3, [r7, #4]
 800584a:	617b      	str	r3, [r7, #20]
 800584c:	e019      	b.n	8005882 <HTTP_File_Receive_Callback+0x52>
        {
            // ÄÃ¢y lÃ  dá»¯ liá»u nháº­n vá», cÃ³ Äá» dÃ i báº±ng q->len, vÃ  data lÃ  q->payload
            DEBUG_INFO("HTTP data length %u\r\n", q->len);
 800584e:	f017 f96d 	bl	801cb2c <sys_get_tick_ms>
 8005852:	0001      	movs	r1, r0
 8005854:	697b      	ldr	r3, [r7, #20]
 8005856:	895b      	ldrh	r3, [r3, #10]
 8005858:	4a1b      	ldr	r2, [pc, #108]	; (80058c8 <HTTP_File_Receive_Callback+0x98>)
 800585a:	481c      	ldr	r0, [pc, #112]	; (80058cc <HTTP_File_Receive_Callback+0x9c>)
 800585c:	f7fd f83e 	bl	80028dc <app_debug_rtt_raw>
            DEBUG_INFO("HTTP data %.*s\r\n", q->len, q->payload);
 8005860:	f017 f964 	bl	801cb2c <sys_get_tick_ms>
 8005864:	0001      	movs	r1, r0
 8005866:	697b      	ldr	r3, [r7, #20]
 8005868:	895b      	ldrh	r3, [r3, #10]
 800586a:	001c      	movs	r4, r3
 800586c:	697b      	ldr	r3, [r7, #20]
 800586e:	685b      	ldr	r3, [r3, #4]
 8005870:	4a15      	ldr	r2, [pc, #84]	; (80058c8 <HTTP_File_Receive_Callback+0x98>)
 8005872:	4817      	ldr	r0, [pc, #92]	; (80058d0 <HTTP_File_Receive_Callback+0xa0>)
 8005874:	9300      	str	r3, [sp, #0]
 8005876:	0023      	movs	r3, r4
 8005878:	f7fd f830 	bl	80028dc <app_debug_rtt_raw>
        for (q = data_recv; q; q = q->next)
 800587c:	697b      	ldr	r3, [r7, #20]
 800587e:	681b      	ldr	r3, [r3, #0]
 8005880:	617b      	str	r3, [r7, #20]
 8005882:	697b      	ldr	r3, [r7, #20]
 8005884:	2b00      	cmp	r3, #0
 8005886:	d1e2      	bne.n	800584e <HTTP_File_Receive_Callback+0x1e>
        }
        tcp_recved(tpcb, data_recv->tot_len);
 8005888:	687b      	ldr	r3, [r7, #4]
 800588a:	891a      	ldrh	r2, [r3, #8]
 800588c:	68bb      	ldr	r3, [r7, #8]
 800588e:	0011      	movs	r1, r2
 8005890:	0018      	movs	r0, r3
 8005892:	f005 fb77 	bl	800af84 <tcp_recved>
        pbuf_free(data_recv);
 8005896:	687b      	ldr	r3, [r7, #4]
 8005898:	0018      	movs	r0, r3
 800589a:	f004 f999 	bl	8009bd0 <pbuf_free>
        DEBUG_WARN("tcp_close\r\n");
        tcp_close(tpcb);
        return ERR_ABRT;
    }

    return ERR_OK;
 800589e:	2300      	movs	r3, #0
 80058a0:	e00d      	b.n	80058be <HTTP_File_Receive_Callback+0x8e>
        DEBUG_WARN("tcp_close\r\n");
 80058a2:	f017 f943 	bl	801cb2c <sys_get_tick_ms>
 80058a6:	0001      	movs	r1, r0
 80058a8:	4a07      	ldr	r2, [pc, #28]	; (80058c8 <HTTP_File_Receive_Callback+0x98>)
 80058aa:	4b0a      	ldr	r3, [pc, #40]	; (80058d4 <HTTP_File_Receive_Callback+0xa4>)
 80058ac:	0018      	movs	r0, r3
 80058ae:	f7fd f815 	bl	80028dc <app_debug_rtt_raw>
        tcp_close(tpcb);
 80058b2:	68bb      	ldr	r3, [r7, #8]
 80058b4:	0018      	movs	r0, r3
 80058b6:	f005 fa07 	bl	800acc8 <tcp_close>
        return ERR_ABRT;
 80058ba:	230d      	movs	r3, #13
 80058bc:	425b      	negs	r3, r3
}
 80058be:	0018      	movs	r0, r3
 80058c0:	46bd      	mov	sp, r7
 80058c2:	b007      	add	sp, #28
 80058c4:	bd90      	pop	{r4, r7, pc}
 80058c6:	46c0      	nop			; (mov r8, r8)
 80058c8:	0801e6e0 	.word	0x0801e6e0
 80058cc:	0801e8ac 	.word	0x0801e8ac
 80058d0:	0801e8dc 	.word	0x0801e8dc
 80058d4:	0801e908 	.word	0x0801e908

080058d8 <HTTP_Config>:

void HTTP_Config(void)
{
 80058d8:	b590      	push	{r4, r7, lr}
 80058da:	b083      	sub	sp, #12
 80058dc:	af02      	add	r7, sp, #8
    /* Init Http connection params */
    HTTP_Connect_Settings.use_proxy = 0;
 80058de:	4b0f      	ldr	r3, [pc, #60]	; (800591c <HTTP_Config+0x44>)
 80058e0:	2200      	movs	r2, #0
 80058e2:	719a      	strb	r2, [r3, #6]
    HTTP_Connect_Settings.headers_done_fn = HTTP_Headers_Done_Callback;
 80058e4:	4b0d      	ldr	r3, [pc, #52]	; (800591c <HTTP_Config+0x44>)
 80058e6:	4a0e      	ldr	r2, [pc, #56]	; (8005920 <HTTP_Config+0x48>)
 80058e8:	60da      	str	r2, [r3, #12]
    HTTP_Connect_Settings.result_fn = HTTP_Result_Callback;
 80058ea:	4b0c      	ldr	r3, [pc, #48]	; (800591c <HTTP_Config+0x44>)
 80058ec:	4a0d      	ldr	r2, [pc, #52]	; (8005924 <HTTP_Config+0x4c>)
 80058ee:	609a      	str	r2, [r3, #8]

    DEBUG_INFO("HTTP url %s%s, port %d\r\n", HTTP_Client_Config.Url,
 80058f0:	f017 f91c 	bl	801cb2c <sys_get_tick_ms>
 80058f4:	0004      	movs	r4, r0
 80058f6:	4a0c      	ldr	r2, [pc, #48]	; (8005928 <HTTP_Config+0x50>)
 80058f8:	2380      	movs	r3, #128	; 0x80
 80058fa:	005b      	lsls	r3, r3, #1
 80058fc:	5ad3      	ldrh	r3, [r2, r3]
 80058fe:	490a      	ldr	r1, [pc, #40]	; (8005928 <HTTP_Config+0x50>)
 8005900:	4a0a      	ldr	r2, [pc, #40]	; (800592c <HTTP_Config+0x54>)
 8005902:	480b      	ldr	r0, [pc, #44]	; (8005930 <HTTP_Config+0x58>)
 8005904:	9301      	str	r3, [sp, #4]
 8005906:	4b0b      	ldr	r3, [pc, #44]	; (8005934 <HTTP_Config+0x5c>)
 8005908:	9300      	str	r3, [sp, #0]
 800590a:	000b      	movs	r3, r1
 800590c:	0021      	movs	r1, r4
 800590e:	f7fc ffe5 	bl	80028dc <app_debug_rtt_raw>
                                             HTTP_Client_Config.File,
                                             HTTP_Client_Config.Port);
}
 8005912:	46c0      	nop			; (mov r8, r8)
 8005914:	46bd      	mov	sp, r7
 8005916:	b001      	add	sp, #4
 8005918:	bd90      	pop	{r4, r7, pc}
 800591a:	46c0      	nop			; (mov r8, r8)
 800591c:	200018e0 	.word	0x200018e0
 8005920:	0800572d 	.word	0x0800572d
 8005924:	08005791 	.word	0x08005791
 8005928:	200016dc 	.word	0x200016dc
 800592c:	0801e6e0 	.word	0x0801e6e0
 8005930:	0801e930 	.word	0x0801e930
 8005934:	200017de 	.word	0x200017de

08005938 <HTTP_Get_Data>:
void HTTP_Get_Data(void)
{
 8005938:	b5b0      	push	{r4, r5, r7, lr}
 800593a:	b086      	sub	sp, #24
 800593c:	af04      	add	r7, sp, #16
    // Káº¿t ná»i HTTP
    err_t err = httpc_get_file_dns((const char*)HTTP_Client_Config.Url,
 800593e:	4a1a      	ldr	r2, [pc, #104]	; (80059a8 <HTTP_Get_Data+0x70>)
 8005940:	2380      	movs	r3, #128	; 0x80
 8005942:	005b      	lsls	r3, r3, #1
 8005944:	5ad1      	ldrh	r1, [r2, r3]
 8005946:	1dfc      	adds	r4, r7, #7
 8005948:	4d18      	ldr	r5, [pc, #96]	; (80059ac <HTTP_Get_Data+0x74>)
 800594a:	4a19      	ldr	r2, [pc, #100]	; (80059b0 <HTTP_Get_Data+0x78>)
 800594c:	4816      	ldr	r0, [pc, #88]	; (80059a8 <HTTP_Get_Data+0x70>)
 800594e:	4b19      	ldr	r3, [pc, #100]	; (80059b4 <HTTP_Get_Data+0x7c>)
 8005950:	9302      	str	r3, [sp, #8]
 8005952:	2300      	movs	r3, #0
 8005954:	9301      	str	r3, [sp, #4]
 8005956:	4b18      	ldr	r3, [pc, #96]	; (80059b8 <HTTP_Get_Data+0x80>)
 8005958:	9300      	str	r3, [sp, #0]
 800595a:	002b      	movs	r3, r5
 800595c:	f000 fe66 	bl	800662c <httpc_get_file_dns>
 8005960:	0003      	movs	r3, r0
 8005962:	7023      	strb	r3, [r4, #0]
                                   HTTP_Client_Config.File,
                                   &HTTP_Connect_Settings,
                                   HTTP_File_Receive_Callback,
                                   NULL,
                                   &HTTP_Connection_State);
    HTTP_Connect_Settings.headers_done_fn = HTTP_Headers_Done_Callback;
 8005964:	4b11      	ldr	r3, [pc, #68]	; (80059ac <HTTP_Get_Data+0x74>)
 8005966:	4a15      	ldr	r2, [pc, #84]	; (80059bc <HTTP_Get_Data+0x84>)
 8005968:	60da      	str	r2, [r3, #12]
    HTTP_Connect_Settings.result_fn = HTTP_Result_Callback;
 800596a:	4b10      	ldr	r3, [pc, #64]	; (80059ac <HTTP_Get_Data+0x74>)
 800596c:	4a14      	ldr	r2, [pc, #80]	; (80059c0 <HTTP_Get_Data+0x88>)
 800596e:	609a      	str	r2, [r3, #8]
    if(err != ERR_OK)
 8005970:	1dfb      	adds	r3, r7, #7
 8005972:	781b      	ldrb	r3, [r3, #0]
 8005974:	b25b      	sxtb	r3, r3
 8005976:	2b00      	cmp	r3, #0
 8005978:	d00a      	beq.n	8005990 <HTTP_Get_Data+0x58>
    {
        DEBUG_INFO("HTTP Get File DNS return %d\r\n", err);
 800597a:	f017 f8d7 	bl	801cb2c <sys_get_tick_ms>
 800597e:	0001      	movs	r1, r0
 8005980:	1dfb      	adds	r3, r7, #7
 8005982:	781b      	ldrb	r3, [r3, #0]
 8005984:	b25b      	sxtb	r3, r3
 8005986:	4a0f      	ldr	r2, [pc, #60]	; (80059c4 <HTTP_Get_Data+0x8c>)
 8005988:	480f      	ldr	r0, [pc, #60]	; (80059c8 <HTTP_Get_Data+0x90>)
 800598a:	f7fc ffa7 	bl	80028dc <app_debug_rtt_raw>
    {
        DEBUG_INFO("HTTP Get File DNS successfully\r\n");
        //HTTP_Manager.Step = HTTP_STEP_CONNECTED;
        //DEBUG_INFO("HTTP_STEP_CONNECTED.\r\n");
    }
}
 800598e:	e007      	b.n	80059a0 <HTTP_Get_Data+0x68>
        DEBUG_INFO("HTTP Get File DNS successfully\r\n");
 8005990:	f017 f8cc 	bl	801cb2c <sys_get_tick_ms>
 8005994:	0001      	movs	r1, r0
 8005996:	4a0b      	ldr	r2, [pc, #44]	; (80059c4 <HTTP_Get_Data+0x8c>)
 8005998:	4b0c      	ldr	r3, [pc, #48]	; (80059cc <HTTP_Get_Data+0x94>)
 800599a:	0018      	movs	r0, r3
 800599c:	f7fc ff9e 	bl	80028dc <app_debug_rtt_raw>
}
 80059a0:	46c0      	nop			; (mov r8, r8)
 80059a2:	46bd      	mov	sp, r7
 80059a4:	b002      	add	sp, #8
 80059a6:	bdb0      	pop	{r4, r5, r7, pc}
 80059a8:	200016dc 	.word	0x200016dc
 80059ac:	200018e0 	.word	0x200018e0
 80059b0:	200017de 	.word	0x200017de
 80059b4:	200018f0 	.word	0x200018f0
 80059b8:	08005831 	.word	0x08005831
 80059bc:	0800572d 	.word	0x0800572d
 80059c0:	08005791 	.word	0x08005791
 80059c4:	0801e6e0 	.word	0x0801e6e0
 80059c8:	0801e964 	.word	0x0801e964
 80059cc:	0801e99c 	.word	0x0801e99c

080059d0 <HTTP_Client_Polling_Task>:
void HTTP_Client_Polling_Task(void *arg)
{
 80059d0:	b580      	push	{r7, lr}
 80059d2:	b084      	sub	sp, #16
 80059d4:	af00      	add	r7, sp, #0
 80059d6:	6078      	str	r0, [r7, #4]
    //static uint32_t Last_time_get_data = 0, tick = 0;
    static uint32_t Last_Tick = 0;
    uint32_t Current_Tick = sys_get_tick_ms();
 80059d8:	f017 f8a8 	bl	801cb2c <sys_get_tick_ms>
 80059dc:	0003      	movs	r3, r0
 80059de:	60fb      	str	r3, [r7, #12]

    if((Current_Tick - Last_Tick) >= (uint32_t)1000)
 80059e0:	4b34      	ldr	r3, [pc, #208]	; (8005ab4 <HTTP_Client_Polling_Task+0xe4>)
 80059e2:	681b      	ldr	r3, [r3, #0]
 80059e4:	68fa      	ldr	r2, [r7, #12]
 80059e6:	1ad2      	subs	r2, r2, r3
 80059e8:	23fa      	movs	r3, #250	; 0xfa
 80059ea:	009b      	lsls	r3, r3, #2
 80059ec:	429a      	cmp	r2, r3
 80059ee:	d359      	bcc.n	8005aa4 <HTTP_Client_Polling_Task+0xd4>
    {
        Last_Tick = Current_Tick;
 80059f0:	4b30      	ldr	r3, [pc, #192]	; (8005ab4 <HTTP_Client_Polling_Task+0xe4>)
 80059f2:	68fa      	ldr	r2, [r7, #12]
 80059f4:	601a      	str	r2, [r3, #0]
    else
    {
        return;
    }
    static bool HTTP_Allow = false;
    if(gsm_data_layer_is_ppp_connected())
 80059f6:	f7fb fc8f 	bl	8001318 <gsm_data_layer_is_ppp_connected>
 80059fa:	1e03      	subs	r3, r0, #0
 80059fc:	d012      	beq.n	8005a24 <HTTP_Client_Polling_Task+0x54>
    {
        if(HTTP_Allow == false)
 80059fe:	4b2e      	ldr	r3, [pc, #184]	; (8005ab8 <HTTP_Client_Polling_Task+0xe8>)
 8005a00:	781b      	ldrb	r3, [r3, #0]
 8005a02:	2201      	movs	r2, #1
 8005a04:	4053      	eors	r3, r2
 8005a06:	b2db      	uxtb	r3, r3
 8005a08:	2b00      	cmp	r3, #0
 8005a0a:	d01a      	beq.n	8005a42 <HTTP_Client_Polling_Task+0x72>
        {
            HTTP_Allow = true;
 8005a0c:	4b2a      	ldr	r3, [pc, #168]	; (8005ab8 <HTTP_Client_Polling_Task+0xe8>)
 8005a0e:	2201      	movs	r2, #1
 8005a10:	701a      	strb	r2, [r3, #0]
            DEBUG_INFO("HTTP Thread started.\r\n");
 8005a12:	f017 f88b 	bl	801cb2c <sys_get_tick_ms>
 8005a16:	0001      	movs	r1, r0
 8005a18:	4a28      	ldr	r2, [pc, #160]	; (8005abc <HTTP_Client_Polling_Task+0xec>)
 8005a1a:	4b29      	ldr	r3, [pc, #164]	; (8005ac0 <HTTP_Client_Polling_Task+0xf0>)
 8005a1c:	0018      	movs	r0, r3
 8005a1e:	f7fc ff5d 	bl	80028dc <app_debug_rtt_raw>
 8005a22:	e00e      	b.n	8005a42 <HTTP_Client_Polling_Task+0x72>
        }
    }
    else
    {
        if(HTTP_Allow == true)
 8005a24:	4b24      	ldr	r3, [pc, #144]	; (8005ab8 <HTTP_Client_Polling_Task+0xe8>)
 8005a26:	781b      	ldrb	r3, [r3, #0]
 8005a28:	2b00      	cmp	r3, #0
 8005a2a:	d00a      	beq.n	8005a42 <HTTP_Client_Polling_Task+0x72>
        {
            HTTP_Allow = false;
 8005a2c:	4b22      	ldr	r3, [pc, #136]	; (8005ab8 <HTTP_Client_Polling_Task+0xe8>)
 8005a2e:	2200      	movs	r2, #0
 8005a30:	701a      	strb	r2, [r3, #0]
            DEBUG_INFO("HTTP Thread stopped.\r\n");
 8005a32:	f017 f87b 	bl	801cb2c <sys_get_tick_ms>
 8005a36:	0001      	movs	r1, r0
 8005a38:	4a20      	ldr	r2, [pc, #128]	; (8005abc <HTTP_Client_Polling_Task+0xec>)
 8005a3a:	4b22      	ldr	r3, [pc, #136]	; (8005ac4 <HTTP_Client_Polling_Task+0xf4>)
 8005a3c:	0018      	movs	r0, r3
 8005a3e:	f7fc ff4d 	bl	80028dc <app_debug_rtt_raw>
        }
    }
    if(HTTP_Allow)
 8005a42:	4b1d      	ldr	r3, [pc, #116]	; (8005ab8 <HTTP_Client_Polling_Task+0xe8>)
 8005a44:	781b      	ldrb	r3, [r3, #0]
 8005a46:	2b00      	cmp	r3, #0
 8005a48:	d031      	beq.n	8005aae <HTTP_Client_Polling_Task+0xde>
    {
        switch (HTTP_Manager.Step)
 8005a4a:	4b1f      	ldr	r3, [pc, #124]	; (8005ac8 <HTTP_Client_Polling_Task+0xf8>)
 8005a4c:	781b      	ldrb	r3, [r3, #0]
 8005a4e:	2b03      	cmp	r3, #3
 8005a50:	d02a      	beq.n	8005aa8 <HTTP_Client_Polling_Task+0xd8>
 8005a52:	dc2b      	bgt.n	8005aac <HTTP_Client_Polling_Task+0xdc>
 8005a54:	2b02      	cmp	r3, #2
 8005a56:	d01f      	beq.n	8005a98 <HTTP_Client_Polling_Task+0xc8>
 8005a58:	dc28      	bgt.n	8005aac <HTTP_Client_Polling_Task+0xdc>
 8005a5a:	2b00      	cmp	r3, #0
 8005a5c:	d002      	beq.n	8005a64 <HTTP_Client_Polling_Task+0x94>
 8005a5e:	2b01      	cmp	r3, #1
 8005a60:	d00c      	beq.n	8005a7c <HTTP_Client_Polling_Task+0xac>
        case HTTP_STEP_CONNECTED:

            break;

        default:
            break;
 8005a62:	e023      	b.n	8005aac <HTTP_Client_Polling_Task+0xdc>
            HTTP_Manager.Step = HTTP_STEP_CONFIG;
 8005a64:	4b18      	ldr	r3, [pc, #96]	; (8005ac8 <HTTP_Client_Polling_Task+0xf8>)
 8005a66:	2201      	movs	r2, #1
 8005a68:	701a      	strb	r2, [r3, #0]
            DEBUG_INFO("HTTP_STEP_CONFIG.\r\n");
 8005a6a:	f017 f85f 	bl	801cb2c <sys_get_tick_ms>
 8005a6e:	0001      	movs	r1, r0
 8005a70:	4a12      	ldr	r2, [pc, #72]	; (8005abc <HTTP_Client_Polling_Task+0xec>)
 8005a72:	4b16      	ldr	r3, [pc, #88]	; (8005acc <HTTP_Client_Polling_Task+0xfc>)
 8005a74:	0018      	movs	r0, r3
 8005a76:	f7fc ff31 	bl	80028dc <app_debug_rtt_raw>
            break;
 8005a7a:	e018      	b.n	8005aae <HTTP_Client_Polling_Task+0xde>
            HTTP_Config();
 8005a7c:	f7ff ff2c 	bl	80058d8 <HTTP_Config>
            HTTP_Manager.Step = HTTP_STEP_CONNECTING;
 8005a80:	4b11      	ldr	r3, [pc, #68]	; (8005ac8 <HTTP_Client_Polling_Task+0xf8>)
 8005a82:	2202      	movs	r2, #2
 8005a84:	701a      	strb	r2, [r3, #0]
            DEBUG_INFO("HTTP_STEP_CONNECTING.\r\n");
 8005a86:	f017 f851 	bl	801cb2c <sys_get_tick_ms>
 8005a8a:	0001      	movs	r1, r0
 8005a8c:	4a0b      	ldr	r2, [pc, #44]	; (8005abc <HTTP_Client_Polling_Task+0xec>)
 8005a8e:	4b10      	ldr	r3, [pc, #64]	; (8005ad0 <HTTP_Client_Polling_Task+0x100>)
 8005a90:	0018      	movs	r0, r3
 8005a92:	f7fc ff23 	bl	80028dc <app_debug_rtt_raw>
            break;
 8005a96:	e00a      	b.n	8005aae <HTTP_Client_Polling_Task+0xde>
            HTTP_Get_Data();
 8005a98:	f7ff ff4e 	bl	8005938 <HTTP_Get_Data>
            HTTP_Manager.Step = HTTP_STEP_CONNECTED;
 8005a9c:	4b0a      	ldr	r3, [pc, #40]	; (8005ac8 <HTTP_Client_Polling_Task+0xf8>)
 8005a9e:	2203      	movs	r2, #3
 8005aa0:	701a      	strb	r2, [r3, #0]
            break;
 8005aa2:	e004      	b.n	8005aae <HTTP_Client_Polling_Task+0xde>
        return;
 8005aa4:	46c0      	nop			; (mov r8, r8)
 8005aa6:	e002      	b.n	8005aae <HTTP_Client_Polling_Task+0xde>
            break;
 8005aa8:	46c0      	nop			; (mov r8, r8)
 8005aaa:	e000      	b.n	8005aae <HTTP_Client_Polling_Task+0xde>
            break;
 8005aac:	46c0      	nop			; (mov r8, r8)
        }
    }
}
 8005aae:	46bd      	mov	sp, r7
 8005ab0:	b004      	add	sp, #16
 8005ab2:	bd80      	pop	{r7, pc}
 8005ab4:	200018f8 	.word	0x200018f8
 8005ab8:	200018fc 	.word	0x200018fc
 8005abc:	0801e6e0 	.word	0x0801e6e0
 8005ac0:	0801e9d8 	.word	0x0801e9d8
 8005ac4:	0801ea08 	.word	0x0801ea08
 8005ac8:	200018f4 	.word	0x200018f4
 8005acc:	0801ea38 	.word	0x0801ea38
 8005ad0:	0801ea68 	.word	0x0801ea68

08005ad4 <httpc_free_state>:
} httpc_state_t;

/** Free http client state and deallocate all resources within */
static err_t
httpc_free_state(httpc_state_t* req)
{
 8005ad4:	b5b0      	push	{r4, r5, r7, lr}
 8005ad6:	b084      	sub	sp, #16
 8005ad8:	af00      	add	r7, sp, #0
 8005ada:	6078      	str	r0, [r7, #4]
  struct altcp_pcb* tpcb;

  if (req->request != NULL) {
 8005adc:	687b      	ldr	r3, [r7, #4]
 8005ade:	691b      	ldr	r3, [r3, #16]
 8005ae0:	2b00      	cmp	r3, #0
 8005ae2:	d007      	beq.n	8005af4 <httpc_free_state+0x20>
    pbuf_free(req->request);
 8005ae4:	687b      	ldr	r3, [r7, #4]
 8005ae6:	691b      	ldr	r3, [r3, #16]
 8005ae8:	0018      	movs	r0, r3
 8005aea:	f004 f871 	bl	8009bd0 <pbuf_free>
    req->request = NULL;
 8005aee:	687b      	ldr	r3, [r7, #4]
 8005af0:	2200      	movs	r2, #0
 8005af2:	611a      	str	r2, [r3, #16]
  }
  if (req->rx_hdrs != NULL) {
 8005af4:	687b      	ldr	r3, [r7, #4]
 8005af6:	695b      	ldr	r3, [r3, #20]
 8005af8:	2b00      	cmp	r3, #0
 8005afa:	d007      	beq.n	8005b0c <httpc_free_state+0x38>
    pbuf_free(req->rx_hdrs);
 8005afc:	687b      	ldr	r3, [r7, #4]
 8005afe:	695b      	ldr	r3, [r3, #20]
 8005b00:	0018      	movs	r0, r3
 8005b02:	f004 f865 	bl	8009bd0 <pbuf_free>
    req->rx_hdrs = NULL;
 8005b06:	687b      	ldr	r3, [r7, #4]
 8005b08:	2200      	movs	r2, #0
 8005b0a:	615a      	str	r2, [r3, #20]
  }

  tpcb = req->pcb;
 8005b0c:	687b      	ldr	r3, [r7, #4]
 8005b0e:	681b      	ldr	r3, [r3, #0]
 8005b10:	60fb      	str	r3, [r7, #12]
  mem_free(req);
 8005b12:	687b      	ldr	r3, [r7, #4]
 8005b14:	0018      	movs	r0, r3
 8005b16:	f002 fdd1 	bl	80086bc <mem_free>
  req = NULL;
 8005b1a:	2300      	movs	r3, #0
 8005b1c:	607b      	str	r3, [r7, #4]

  if (tpcb != NULL) {
 8005b1e:	68fb      	ldr	r3, [r7, #12]
 8005b20:	2b00      	cmp	r3, #0
 8005b22:	d02d      	beq.n	8005b80 <httpc_free_state+0xac>
    err_t r;
    altcp_arg(tpcb, NULL);
 8005b24:	68fb      	ldr	r3, [r7, #12]
 8005b26:	2100      	movs	r1, #0
 8005b28:	0018      	movs	r0, r3
 8005b2a:	f006 fae0 	bl	800c0ee <tcp_arg>
    altcp_recv(tpcb, NULL);
 8005b2e:	68fb      	ldr	r3, [r7, #12]
 8005b30:	2100      	movs	r1, #0
 8005b32:	0018      	movs	r0, r3
 8005b34:	f006 faea 	bl	800c10c <tcp_recv>
    altcp_err(tpcb, NULL);
 8005b38:	68fb      	ldr	r3, [r7, #12]
 8005b3a:	2100      	movs	r1, #0
 8005b3c:	0018      	movs	r0, r3
 8005b3e:	f006 fb29 	bl	800c194 <tcp_err>
    altcp_poll(tpcb, NULL, 0);
 8005b42:	68fb      	ldr	r3, [r7, #12]
 8005b44:	2200      	movs	r2, #0
 8005b46:	2100      	movs	r1, #0
 8005b48:	0018      	movs	r0, r3
 8005b4a:	f006 fb45 	bl	800c1d8 <tcp_poll>
    altcp_sent(tpcb, NULL);
 8005b4e:	68fb      	ldr	r3, [r7, #12]
 8005b50:	2100      	movs	r1, #0
 8005b52:	0018      	movs	r0, r3
 8005b54:	f006 fafc 	bl	800c150 <tcp_sent>
    r = altcp_close(tpcb);
 8005b58:	250b      	movs	r5, #11
 8005b5a:	197c      	adds	r4, r7, r5
 8005b5c:	68fb      	ldr	r3, [r7, #12]
 8005b5e:	0018      	movs	r0, r3
 8005b60:	f005 f8b2 	bl	800acc8 <tcp_close>
 8005b64:	0003      	movs	r3, r0
 8005b66:	7023      	strb	r3, [r4, #0]
    if (r != ERR_OK) {
 8005b68:	197b      	adds	r3, r7, r5
 8005b6a:	781b      	ldrb	r3, [r3, #0]
 8005b6c:	b25b      	sxtb	r3, r3
 8005b6e:	2b00      	cmp	r3, #0
 8005b70:	d006      	beq.n	8005b80 <httpc_free_state+0xac>
      altcp_abort(tpcb);
 8005b72:	68fb      	ldr	r3, [r7, #12]
 8005b74:	0018      	movs	r0, r3
 8005b76:	f005 f997 	bl	800aea8 <tcp_abort>
      return ERR_ABRT;
 8005b7a:	230d      	movs	r3, #13
 8005b7c:	425b      	negs	r3, r3
 8005b7e:	e000      	b.n	8005b82 <httpc_free_state+0xae>
    }
  }
  return ERR_OK;
 8005b80:	2300      	movs	r3, #0
}
 8005b82:	0018      	movs	r0, r3
 8005b84:	46bd      	mov	sp, r7
 8005b86:	b004      	add	sp, #16
 8005b88:	bdb0      	pop	{r4, r5, r7, pc}

08005b8a <httpc_close>:

/** Close the connection: call finished callback and free the state */
static err_t
httpc_close(httpc_state_t* req, httpc_result_t result, u32_t server_response, err_t err)
{
 8005b8a:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005b8c:	b087      	sub	sp, #28
 8005b8e:	af02      	add	r7, sp, #8
 8005b90:	60f8      	str	r0, [r7, #12]
 8005b92:	0008      	movs	r0, r1
 8005b94:	607a      	str	r2, [r7, #4]
 8005b96:	0019      	movs	r1, r3
 8005b98:	260b      	movs	r6, #11
 8005b9a:	19bb      	adds	r3, r7, r6
 8005b9c:	1c02      	adds	r2, r0, #0
 8005b9e:	701a      	strb	r2, [r3, #0]
 8005ba0:	230a      	movs	r3, #10
 8005ba2:	18fb      	adds	r3, r7, r3
 8005ba4:	1c0a      	adds	r2, r1, #0
 8005ba6:	701a      	strb	r2, [r3, #0]
  if (req != NULL) {
 8005ba8:	68fb      	ldr	r3, [r7, #12]
 8005baa:	2b00      	cmp	r3, #0
 8005bac:	d01f      	beq.n	8005bee <httpc_close+0x64>
    if (req->conn_settings != NULL) {
 8005bae:	68fb      	ldr	r3, [r7, #12]
 8005bb0:	6a1b      	ldr	r3, [r3, #32]
 8005bb2:	2b00      	cmp	r3, #0
 8005bb4:	d015      	beq.n	8005be2 <httpc_close+0x58>
      if (req->conn_settings->result_fn != NULL) {
 8005bb6:	68fb      	ldr	r3, [r7, #12]
 8005bb8:	6a1b      	ldr	r3, [r3, #32]
 8005bba:	689b      	ldr	r3, [r3, #8]
 8005bbc:	2b00      	cmp	r3, #0
 8005bbe:	d010      	beq.n	8005be2 <httpc_close+0x58>
        req->conn_settings->result_fn(req->callback_arg, result, req->rx_content_len, server_response, err);
 8005bc0:	68fb      	ldr	r3, [r7, #12]
 8005bc2:	6a1b      	ldr	r3, [r3, #32]
 8005bc4:	689c      	ldr	r4, [r3, #8]
 8005bc6:	68fb      	ldr	r3, [r7, #12]
 8005bc8:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8005bca:	68fb      	ldr	r3, [r7, #12]
 8005bcc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8005bce:	687d      	ldr	r5, [r7, #4]
 8005bd0:	19bb      	adds	r3, r7, r6
 8005bd2:	7819      	ldrb	r1, [r3, #0]
 8005bd4:	230a      	movs	r3, #10
 8005bd6:	18fb      	adds	r3, r7, r3
 8005bd8:	781b      	ldrb	r3, [r3, #0]
 8005bda:	b25b      	sxtb	r3, r3
 8005bdc:	9300      	str	r3, [sp, #0]
 8005bde:	002b      	movs	r3, r5
 8005be0:	47a0      	blx	r4
      }
    }
    return httpc_free_state(req);
 8005be2:	68fb      	ldr	r3, [r7, #12]
 8005be4:	0018      	movs	r0, r3
 8005be6:	f7ff ff75 	bl	8005ad4 <httpc_free_state>
 8005bea:	0003      	movs	r3, r0
 8005bec:	e000      	b.n	8005bf0 <httpc_close+0x66>
  }
  return ERR_OK;
 8005bee:	2300      	movs	r3, #0
}
 8005bf0:	0018      	movs	r0, r3
 8005bf2:	46bd      	mov	sp, r7
 8005bf4:	b005      	add	sp, #20
 8005bf6:	bdf0      	pop	{r4, r5, r6, r7, pc}

08005bf8 <http_parse_response_status>:

/** Parse http header response line 1 */
static err_t
http_parse_response_status(struct pbuf *p, u16_t *http_version, u16_t *http_status, u16_t *http_status_str_offset)
{
 8005bf8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005bfa:	b08d      	sub	sp, #52	; 0x34
 8005bfc:	af00      	add	r7, sp, #0
 8005bfe:	60f8      	str	r0, [r7, #12]
 8005c00:	60b9      	str	r1, [r7, #8]
 8005c02:	607a      	str	r2, [r7, #4]
 8005c04:	603b      	str	r3, [r7, #0]
  u16_t end1 = pbuf_memfind(p, "\r\n", 2, 0);
 8005c06:	252a      	movs	r5, #42	; 0x2a
 8005c08:	197c      	adds	r4, r7, r5
 8005c0a:	4957      	ldr	r1, [pc, #348]	; (8005d68 <http_parse_response_status+0x170>)
 8005c0c:	68f8      	ldr	r0, [r7, #12]
 8005c0e:	2300      	movs	r3, #0
 8005c10:	2202      	movs	r2, #2
 8005c12:	f004 fde5 	bl	800a7e0 <pbuf_memfind>
 8005c16:	0003      	movs	r3, r0
 8005c18:	8023      	strh	r3, [r4, #0]
  if (end1 != 0xFFFF) {
 8005c1a:	197b      	adds	r3, r7, r5
 8005c1c:	881b      	ldrh	r3, [r3, #0]
 8005c1e:	4a53      	ldr	r2, [pc, #332]	; (8005d6c <http_parse_response_status+0x174>)
 8005c20:	4293      	cmp	r3, r2
 8005c22:	d100      	bne.n	8005c26 <http_parse_response_status+0x2e>
 8005c24:	e099      	b.n	8005d5a <http_parse_response_status+0x162>
    /* get parts of first line */
    u16_t space1, space2;
    space1 = pbuf_memfind(p, " ", 1, 0);
 8005c26:	2528      	movs	r5, #40	; 0x28
 8005c28:	197c      	adds	r4, r7, r5
 8005c2a:	4951      	ldr	r1, [pc, #324]	; (8005d70 <http_parse_response_status+0x178>)
 8005c2c:	68f8      	ldr	r0, [r7, #12]
 8005c2e:	2300      	movs	r3, #0
 8005c30:	2201      	movs	r2, #1
 8005c32:	f004 fdd5 	bl	800a7e0 <pbuf_memfind>
 8005c36:	0003      	movs	r3, r0
 8005c38:	8023      	strh	r3, [r4, #0]
    if (space1 != 0xFFFF) {
 8005c3a:	197b      	adds	r3, r7, r5
 8005c3c:	881b      	ldrh	r3, [r3, #0]
 8005c3e:	4a4b      	ldr	r2, [pc, #300]	; (8005d6c <http_parse_response_status+0x174>)
 8005c40:	4293      	cmp	r3, r2
 8005c42:	d100      	bne.n	8005c46 <http_parse_response_status+0x4e>
 8005c44:	e089      	b.n	8005d5a <http_parse_response_status+0x162>
      if ((pbuf_memcmp(p, 0, "HTTP/", 5) == 0)  && (pbuf_get_at(p, 6) == '.')) {
 8005c46:	4a4b      	ldr	r2, [pc, #300]	; (8005d74 <http_parse_response_status+0x17c>)
 8005c48:	68f8      	ldr	r0, [r7, #12]
 8005c4a:	2305      	movs	r3, #5
 8005c4c:	2100      	movs	r1, #0
 8005c4e:	f004 fd47 	bl	800a6e0 <pbuf_memcmp>
 8005c52:	1e03      	subs	r3, r0, #0
 8005c54:	d000      	beq.n	8005c58 <http_parse_response_status+0x60>
 8005c56:	e080      	b.n	8005d5a <http_parse_response_status+0x162>
 8005c58:	68fb      	ldr	r3, [r7, #12]
 8005c5a:	2106      	movs	r1, #6
 8005c5c:	0018      	movs	r0, r3
 8005c5e:	f004 fcd1 	bl	800a604 <pbuf_get_at>
 8005c62:	0003      	movs	r3, r0
 8005c64:	2b2e      	cmp	r3, #46	; 0x2e
 8005c66:	d000      	beq.n	8005c6a <http_parse_response_status+0x72>
 8005c68:	e077      	b.n	8005d5a <http_parse_response_status+0x162>
        char status_num[10];
        size_t status_num_len;
        /* parse http version */
        u16_t version = pbuf_get_at(p, 5) - '0';
 8005c6a:	68fb      	ldr	r3, [r7, #12]
 8005c6c:	2105      	movs	r1, #5
 8005c6e:	0018      	movs	r0, r3
 8005c70:	f004 fcc8 	bl	800a604 <pbuf_get_at>
 8005c74:	0003      	movs	r3, r0
 8005c76:	b29a      	uxth	r2, r3
 8005c78:	2426      	movs	r4, #38	; 0x26
 8005c7a:	193b      	adds	r3, r7, r4
 8005c7c:	3a30      	subs	r2, #48	; 0x30
 8005c7e:	801a      	strh	r2, [r3, #0]
        version <<= 8;
 8005c80:	193b      	adds	r3, r7, r4
 8005c82:	193a      	adds	r2, r7, r4
 8005c84:	8812      	ldrh	r2, [r2, #0]
 8005c86:	0212      	lsls	r2, r2, #8
 8005c88:	801a      	strh	r2, [r3, #0]
        version |= pbuf_get_at(p, 7) - '0';
 8005c8a:	68fb      	ldr	r3, [r7, #12]
 8005c8c:	2107      	movs	r1, #7
 8005c8e:	0018      	movs	r0, r3
 8005c90:	f004 fcb8 	bl	800a604 <pbuf_get_at>
 8005c94:	0003      	movs	r3, r0
 8005c96:	3b30      	subs	r3, #48	; 0x30
 8005c98:	b21a      	sxth	r2, r3
 8005c9a:	193b      	adds	r3, r7, r4
 8005c9c:	2100      	movs	r1, #0
 8005c9e:	5e5b      	ldrsh	r3, [r3, r1]
 8005ca0:	4313      	orrs	r3, r2
 8005ca2:	b21a      	sxth	r2, r3
 8005ca4:	193b      	adds	r3, r7, r4
 8005ca6:	801a      	strh	r2, [r3, #0]
        *http_version = version;
 8005ca8:	68bb      	ldr	r3, [r7, #8]
 8005caa:	193a      	adds	r2, r7, r4
 8005cac:	8812      	ldrh	r2, [r2, #0]
 8005cae:	801a      	strh	r2, [r3, #0]

        /* parse http status number */
        space2 = pbuf_memfind(p, " ", 1, space1 + 1);
 8005cb0:	197b      	adds	r3, r7, r5
 8005cb2:	881b      	ldrh	r3, [r3, #0]
 8005cb4:	3301      	adds	r3, #1
 8005cb6:	b29b      	uxth	r3, r3
 8005cb8:	2624      	movs	r6, #36	; 0x24
 8005cba:	19bc      	adds	r4, r7, r6
 8005cbc:	492c      	ldr	r1, [pc, #176]	; (8005d70 <http_parse_response_status+0x178>)
 8005cbe:	68f8      	ldr	r0, [r7, #12]
 8005cc0:	2201      	movs	r2, #1
 8005cc2:	f004 fd8d 	bl	800a7e0 <pbuf_memfind>
 8005cc6:	0003      	movs	r3, r0
 8005cc8:	8023      	strh	r3, [r4, #0]
        if (space2 != 0xFFFF) {
 8005cca:	0031      	movs	r1, r6
 8005ccc:	187b      	adds	r3, r7, r1
 8005cce:	881b      	ldrh	r3, [r3, #0]
 8005cd0:	4a26      	ldr	r2, [pc, #152]	; (8005d6c <http_parse_response_status+0x174>)
 8005cd2:	4293      	cmp	r3, r2
 8005cd4:	d00d      	beq.n	8005cf2 <http_parse_response_status+0xfa>
          *http_status_str_offset = space2 + 1;
 8005cd6:	187b      	adds	r3, r7, r1
 8005cd8:	881b      	ldrh	r3, [r3, #0]
 8005cda:	3301      	adds	r3, #1
 8005cdc:	b29a      	uxth	r2, r3
 8005cde:	683b      	ldr	r3, [r7, #0]
 8005ce0:	801a      	strh	r2, [r3, #0]
          status_num_len = space2 - space1 - 1;
 8005ce2:	187b      	adds	r3, r7, r1
 8005ce4:	881a      	ldrh	r2, [r3, #0]
 8005ce6:	197b      	adds	r3, r7, r5
 8005ce8:	881b      	ldrh	r3, [r3, #0]
 8005cea:	1ad3      	subs	r3, r2, r3
 8005cec:	3b01      	subs	r3, #1
 8005cee:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005cf0:	e008      	b.n	8005d04 <http_parse_response_status+0x10c>
        } else {
          status_num_len = end1 - space1 - 1;
 8005cf2:	232a      	movs	r3, #42	; 0x2a
 8005cf4:	18fb      	adds	r3, r7, r3
 8005cf6:	881a      	ldrh	r2, [r3, #0]
 8005cf8:	2328      	movs	r3, #40	; 0x28
 8005cfa:	18fb      	adds	r3, r7, r3
 8005cfc:	881b      	ldrh	r3, [r3, #0]
 8005cfe:	1ad3      	subs	r3, r2, r3
 8005d00:	3b01      	subs	r3, #1
 8005d02:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
        memset(status_num, 0, sizeof(status_num));
 8005d04:	2414      	movs	r4, #20
 8005d06:	193b      	adds	r3, r7, r4
 8005d08:	220a      	movs	r2, #10
 8005d0a:	2100      	movs	r1, #0
 8005d0c:	0018      	movs	r0, r3
 8005d0e:	f016 ff83 	bl	801cc18 <memset>
        if (pbuf_copy_partial(p, status_num, (u16_t)status_num_len, space1 + 1) == status_num_len) {
 8005d12:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005d14:	b29a      	uxth	r2, r3
 8005d16:	2328      	movs	r3, #40	; 0x28
 8005d18:	18fb      	adds	r3, r7, r3
 8005d1a:	881b      	ldrh	r3, [r3, #0]
 8005d1c:	3301      	adds	r3, #1
 8005d1e:	b29b      	uxth	r3, r3
 8005d20:	1939      	adds	r1, r7, r4
 8005d22:	68f8      	ldr	r0, [r7, #12]
 8005d24:	f004 fa1e 	bl	800a164 <pbuf_copy_partial>
 8005d28:	0003      	movs	r3, r0
 8005d2a:	001a      	movs	r2, r3
 8005d2c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005d2e:	4293      	cmp	r3, r2
 8005d30:	d113      	bne.n	8005d5a <http_parse_response_status+0x162>
          int status = atoi(status_num);
 8005d32:	193b      	adds	r3, r7, r4
 8005d34:	0018      	movs	r0, r3
 8005d36:	f016 ff11 	bl	801cb5c <atoi>
 8005d3a:	0003      	movs	r3, r0
 8005d3c:	623b      	str	r3, [r7, #32]
          if ((status > 0) && (status <= 0xFFFF)) {
 8005d3e:	6a3b      	ldr	r3, [r7, #32]
 8005d40:	2b00      	cmp	r3, #0
 8005d42:	dd0a      	ble.n	8005d5a <http_parse_response_status+0x162>
 8005d44:	6a3a      	ldr	r2, [r7, #32]
 8005d46:	2380      	movs	r3, #128	; 0x80
 8005d48:	025b      	lsls	r3, r3, #9
 8005d4a:	429a      	cmp	r2, r3
 8005d4c:	da05      	bge.n	8005d5a <http_parse_response_status+0x162>
            *http_status = (u16_t)status;
 8005d4e:	6a3b      	ldr	r3, [r7, #32]
 8005d50:	b29a      	uxth	r2, r3
 8005d52:	687b      	ldr	r3, [r7, #4]
 8005d54:	801a      	strh	r2, [r3, #0]
            return ERR_OK;
 8005d56:	2300      	movs	r3, #0
 8005d58:	e001      	b.n	8005d5e <http_parse_response_status+0x166>
          }
        }
      }
    }
  }
  return ERR_VAL;
 8005d5a:	2306      	movs	r3, #6
 8005d5c:	425b      	negs	r3, r3
}
 8005d5e:	0018      	movs	r0, r3
 8005d60:	46bd      	mov	sp, r7
 8005d62:	b00d      	add	sp, #52	; 0x34
 8005d64:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005d66:	46c0      	nop			; (mov r8, r8)
 8005d68:	0801ea9c 	.word	0x0801ea9c
 8005d6c:	0000ffff 	.word	0x0000ffff
 8005d70:	0801eaa0 	.word	0x0801eaa0
 8005d74:	0801eaa4 	.word	0x0801eaa4

08005d78 <http_wait_headers>:

/** Wait for all headers to be received, return its length and content-length (if available) */
static err_t
http_wait_headers(struct pbuf *p, u32_t *content_length, u16_t *total_header_len)
{
 8005d78:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005d7a:	b08d      	sub	sp, #52	; 0x34
 8005d7c:	af00      	add	r7, sp, #0
 8005d7e:	60f8      	str	r0, [r7, #12]
 8005d80:	60b9      	str	r1, [r7, #8]
 8005d82:	607a      	str	r2, [r7, #4]
  u16_t end1 = pbuf_memfind(p, "\r\n\r\n", 4, 0);
 8005d84:	252e      	movs	r5, #46	; 0x2e
 8005d86:	197c      	adds	r4, r7, r5
 8005d88:	4938      	ldr	r1, [pc, #224]	; (8005e6c <http_wait_headers+0xf4>)
 8005d8a:	68f8      	ldr	r0, [r7, #12]
 8005d8c:	2300      	movs	r3, #0
 8005d8e:	2204      	movs	r2, #4
 8005d90:	f004 fd26 	bl	800a7e0 <pbuf_memfind>
 8005d94:	0003      	movs	r3, r0
 8005d96:	8023      	strh	r3, [r4, #0]
  if (end1 < (0xFFFF - 2)) {
 8005d98:	0029      	movs	r1, r5
 8005d9a:	187b      	adds	r3, r7, r1
 8005d9c:	881b      	ldrh	r3, [r3, #0]
 8005d9e:	4a34      	ldr	r2, [pc, #208]	; (8005e70 <http_wait_headers+0xf8>)
 8005da0:	4293      	cmp	r3, r2
 8005da2:	d85c      	bhi.n	8005e5e <http_wait_headers+0xe6>
    /* all headers received */
    /* check if we have a content length (@todo: case insensitive?) */
    u16_t content_len_hdr;
    *content_length = HTTPC_CONTENT_LEN_INVALID;
 8005da4:	68bb      	ldr	r3, [r7, #8]
 8005da6:	2201      	movs	r2, #1
 8005da8:	4252      	negs	r2, r2
 8005daa:	601a      	str	r2, [r3, #0]
    *total_header_len = end1 + 4;
 8005dac:	187b      	adds	r3, r7, r1
 8005dae:	881b      	ldrh	r3, [r3, #0]
 8005db0:	3304      	adds	r3, #4
 8005db2:	b29a      	uxth	r2, r3
 8005db4:	687b      	ldr	r3, [r7, #4]
 8005db6:	801a      	strh	r2, [r3, #0]

    content_len_hdr = pbuf_memfind(p, "Content-Length: ", 16, 0);
 8005db8:	252c      	movs	r5, #44	; 0x2c
 8005dba:	197c      	adds	r4, r7, r5
 8005dbc:	492d      	ldr	r1, [pc, #180]	; (8005e74 <http_wait_headers+0xfc>)
 8005dbe:	68f8      	ldr	r0, [r7, #12]
 8005dc0:	2300      	movs	r3, #0
 8005dc2:	2210      	movs	r2, #16
 8005dc4:	f004 fd0c 	bl	800a7e0 <pbuf_memfind>
 8005dc8:	0003      	movs	r3, r0
 8005dca:	8023      	strh	r3, [r4, #0]
    if (content_len_hdr != 0xFFFF) {
 8005dcc:	197b      	adds	r3, r7, r5
 8005dce:	881b      	ldrh	r3, [r3, #0]
 8005dd0:	4a29      	ldr	r2, [pc, #164]	; (8005e78 <http_wait_headers+0x100>)
 8005dd2:	4293      	cmp	r3, r2
 8005dd4:	d041      	beq.n	8005e5a <http_wait_headers+0xe2>
      u16_t content_len_line_end = pbuf_memfind(p, "\r\n", 2, content_len_hdr);
 8005dd6:	262a      	movs	r6, #42	; 0x2a
 8005dd8:	19bc      	adds	r4, r7, r6
 8005dda:	197b      	adds	r3, r7, r5
 8005ddc:	881b      	ldrh	r3, [r3, #0]
 8005dde:	4927      	ldr	r1, [pc, #156]	; (8005e7c <http_wait_headers+0x104>)
 8005de0:	68f8      	ldr	r0, [r7, #12]
 8005de2:	2202      	movs	r2, #2
 8005de4:	f004 fcfc 	bl	800a7e0 <pbuf_memfind>
 8005de8:	0003      	movs	r3, r0
 8005dea:	8023      	strh	r3, [r4, #0]
      if (content_len_line_end != 0xFFFF) {
 8005dec:	19bb      	adds	r3, r7, r6
 8005dee:	881b      	ldrh	r3, [r3, #0]
 8005df0:	4a21      	ldr	r2, [pc, #132]	; (8005e78 <http_wait_headers+0x100>)
 8005df2:	4293      	cmp	r3, r2
 8005df4:	d031      	beq.n	8005e5a <http_wait_headers+0xe2>
        char content_len_num[16];
        u16_t content_len_num_len = (u16_t)(content_len_line_end - content_len_hdr - 16);
 8005df6:	19ba      	adds	r2, r7, r6
 8005df8:	002c      	movs	r4, r5
 8005dfa:	193b      	adds	r3, r7, r4
 8005dfc:	8812      	ldrh	r2, [r2, #0]
 8005dfe:	881b      	ldrh	r3, [r3, #0]
 8005e00:	1ad3      	subs	r3, r2, r3
 8005e02:	b29a      	uxth	r2, r3
 8005e04:	2528      	movs	r5, #40	; 0x28
 8005e06:	197b      	adds	r3, r7, r5
 8005e08:	3a10      	subs	r2, #16
 8005e0a:	801a      	strh	r2, [r3, #0]
        memset(content_len_num, 0, sizeof(content_len_num));
 8005e0c:	2614      	movs	r6, #20
 8005e0e:	19bb      	adds	r3, r7, r6
 8005e10:	2210      	movs	r2, #16
 8005e12:	2100      	movs	r1, #0
 8005e14:	0018      	movs	r0, r3
 8005e16:	f016 feff 	bl	801cc18 <memset>
        if (pbuf_copy_partial(p, content_len_num, content_len_num_len, content_len_hdr + 16) == content_len_num_len) {
 8005e1a:	193b      	adds	r3, r7, r4
 8005e1c:	881b      	ldrh	r3, [r3, #0]
 8005e1e:	3310      	adds	r3, #16
 8005e20:	b29c      	uxth	r4, r3
 8005e22:	197b      	adds	r3, r7, r5
 8005e24:	881a      	ldrh	r2, [r3, #0]
 8005e26:	19b9      	adds	r1, r7, r6
 8005e28:	68f8      	ldr	r0, [r7, #12]
 8005e2a:	0023      	movs	r3, r4
 8005e2c:	f004 f99a 	bl	800a164 <pbuf_copy_partial>
 8005e30:	0003      	movs	r3, r0
 8005e32:	001a      	movs	r2, r3
 8005e34:	197b      	adds	r3, r7, r5
 8005e36:	881b      	ldrh	r3, [r3, #0]
 8005e38:	4293      	cmp	r3, r2
 8005e3a:	d10e      	bne.n	8005e5a <http_wait_headers+0xe2>
          int len = atoi(content_len_num);
 8005e3c:	19bb      	adds	r3, r7, r6
 8005e3e:	0018      	movs	r0, r3
 8005e40:	f016 fe8c 	bl	801cb5c <atoi>
 8005e44:	0003      	movs	r3, r0
 8005e46:	627b      	str	r3, [r7, #36]	; 0x24
          if ((len >= 0) && ((u32_t)len < HTTPC_CONTENT_LEN_INVALID)) {
 8005e48:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005e4a:	2b00      	cmp	r3, #0
 8005e4c:	db05      	blt.n	8005e5a <http_wait_headers+0xe2>
 8005e4e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005e50:	3301      	adds	r3, #1
 8005e52:	d002      	beq.n	8005e5a <http_wait_headers+0xe2>
            *content_length = (u32_t)len;
 8005e54:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005e56:	68bb      	ldr	r3, [r7, #8]
 8005e58:	601a      	str	r2, [r3, #0]
          }
        }
      }
    }
    return ERR_OK;
 8005e5a:	2300      	movs	r3, #0
 8005e5c:	e001      	b.n	8005e62 <http_wait_headers+0xea>
  }
  return ERR_VAL;
 8005e5e:	2306      	movs	r3, #6
 8005e60:	425b      	negs	r3, r3
}
 8005e62:	0018      	movs	r0, r3
 8005e64:	46bd      	mov	sp, r7
 8005e66:	b00d      	add	sp, #52	; 0x34
 8005e68:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005e6a:	46c0      	nop			; (mov r8, r8)
 8005e6c:	0801eaac 	.word	0x0801eaac
 8005e70:	0000fffc 	.word	0x0000fffc
 8005e74:	0801eab4 	.word	0x0801eab4
 8005e78:	0000ffff 	.word	0x0000ffff
 8005e7c:	0801ea9c 	.word	0x0801ea9c

08005e80 <httpc_tcp_recv>:

/** http client tcp recv callback */
static err_t
httpc_tcp_recv(void *arg, struct altcp_pcb *pcb, struct pbuf *p, err_t r)
{
 8005e80:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005e82:	b08d      	sub	sp, #52	; 0x34
 8005e84:	af02      	add	r7, sp, #8
 8005e86:	60f8      	str	r0, [r7, #12]
 8005e88:	60b9      	str	r1, [r7, #8]
 8005e8a:	607a      	str	r2, [r7, #4]
 8005e8c:	001a      	movs	r2, r3
 8005e8e:	1cfb      	adds	r3, r7, #3
 8005e90:	701a      	strb	r2, [r3, #0]
  httpc_state_t* req = (httpc_state_t*)arg;
 8005e92:	68fb      	ldr	r3, [r7, #12]
 8005e94:	623b      	str	r3, [r7, #32]
  LWIP_UNUSED_ARG(r);

  if (p == NULL) {
 8005e96:	687b      	ldr	r3, [r7, #4]
 8005e98:	2b00      	cmp	r3, #0
 8005e9a:	d128      	bne.n	8005eee <httpc_tcp_recv+0x6e>
    httpc_result_t result;
    if (req->parse_state != HTTPC_PARSE_RX_DATA) {
 8005e9c:	6a3b      	ldr	r3, [r7, #32]
 8005e9e:	2230      	movs	r2, #48	; 0x30
 8005ea0:	5c9b      	ldrb	r3, [r3, r2]
 8005ea2:	2b02      	cmp	r3, #2
 8005ea4:	d004      	beq.n	8005eb0 <httpc_tcp_recv+0x30>
      /* did not get RX data yet */
      result = HTTPC_RESULT_ERR_CLOSED;
 8005ea6:	2327      	movs	r3, #39	; 0x27
 8005ea8:	18fb      	adds	r3, r7, r3
 8005eaa:	2204      	movs	r2, #4
 8005eac:	701a      	strb	r2, [r3, #0]
 8005eae:	e012      	b.n	8005ed6 <httpc_tcp_recv+0x56>
    } else if ((req->hdr_content_len != HTTPC_CONTENT_LEN_INVALID) &&
 8005eb0:	6a3b      	ldr	r3, [r7, #32]
 8005eb2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005eb4:	3301      	adds	r3, #1
 8005eb6:	d00a      	beq.n	8005ece <httpc_tcp_recv+0x4e>
      (req->hdr_content_len != req->rx_content_len)) {
 8005eb8:	6a3b      	ldr	r3, [r7, #32]
 8005eba:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005ebc:	6a3b      	ldr	r3, [r7, #32]
 8005ebe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    } else if ((req->hdr_content_len != HTTPC_CONTENT_LEN_INVALID) &&
 8005ec0:	429a      	cmp	r2, r3
 8005ec2:	d004      	beq.n	8005ece <httpc_tcp_recv+0x4e>
      /* header has been received with content length but not all data received */
      result = HTTPC_RESULT_ERR_CONTENT_LEN;
 8005ec4:	2327      	movs	r3, #39	; 0x27
 8005ec6:	18fb      	adds	r3, r7, r3
 8005ec8:	2209      	movs	r2, #9
 8005eca:	701a      	strb	r2, [r3, #0]
 8005ecc:	e003      	b.n	8005ed6 <httpc_tcp_recv+0x56>
    } else {
      /* receiving data and either all data received or no content length header */
      result = HTTPC_RESULT_OK;
 8005ece:	2327      	movs	r3, #39	; 0x27
 8005ed0:	18fb      	adds	r3, r7, r3
 8005ed2:	2200      	movs	r2, #0
 8005ed4:	701a      	strb	r2, [r3, #0]
    }
    return httpc_close(req, result, req->rx_status, ERR_OK);
 8005ed6:	6a3b      	ldr	r3, [r7, #32]
 8005ed8:	8b5b      	ldrh	r3, [r3, #26]
 8005eda:	001a      	movs	r2, r3
 8005edc:	2327      	movs	r3, #39	; 0x27
 8005ede:	18fb      	adds	r3, r7, r3
 8005ee0:	7819      	ldrb	r1, [r3, #0]
 8005ee2:	6a38      	ldr	r0, [r7, #32]
 8005ee4:	2300      	movs	r3, #0
 8005ee6:	f7ff fe50 	bl	8005b8a <httpc_close>
 8005eea:	0003      	movs	r3, r0
 8005eec:	e0bd      	b.n	800606a <httpc_tcp_recv+0x1ea>
  }
  if (req->parse_state != HTTPC_PARSE_RX_DATA) {
 8005eee:	6a3b      	ldr	r3, [r7, #32]
 8005ef0:	2230      	movs	r2, #48	; 0x30
 8005ef2:	5c9b      	ldrb	r3, [r3, r2]
 8005ef4:	2b02      	cmp	r3, #2
 8005ef6:	d100      	bne.n	8005efa <httpc_tcp_recv+0x7a>
 8005ef8:	e08c      	b.n	8006014 <httpc_tcp_recv+0x194>
    if (req->rx_hdrs == NULL) {
 8005efa:	6a3b      	ldr	r3, [r7, #32]
 8005efc:	695b      	ldr	r3, [r3, #20]
 8005efe:	2b00      	cmp	r3, #0
 8005f00:	d103      	bne.n	8005f0a <httpc_tcp_recv+0x8a>
      req->rx_hdrs = p;
 8005f02:	6a3b      	ldr	r3, [r7, #32]
 8005f04:	687a      	ldr	r2, [r7, #4]
 8005f06:	615a      	str	r2, [r3, #20]
 8005f08:	e006      	b.n	8005f18 <httpc_tcp_recv+0x98>
    } else {
      pbuf_cat(req->rx_hdrs, p);
 8005f0a:	6a3b      	ldr	r3, [r7, #32]
 8005f0c:	695b      	ldr	r3, [r3, #20]
 8005f0e:	687a      	ldr	r2, [r7, #4]
 8005f10:	0011      	movs	r1, r2
 8005f12:	0018      	movs	r0, r3
 8005f14:	f003 ff3c 	bl	8009d90 <pbuf_cat>
    }
    if (req->parse_state == HTTPC_PARSE_WAIT_FIRST_LINE) {
 8005f18:	6a3b      	ldr	r3, [r7, #32]
 8005f1a:	2230      	movs	r2, #48	; 0x30
 8005f1c:	5c9b      	ldrb	r3, [r3, r2]
 8005f1e:	2b00      	cmp	r3, #0
 8005f20:	d118      	bne.n	8005f54 <httpc_tcp_recv+0xd4>
      u16_t status_str_off;
      err_t err = http_parse_response_status(req->rx_hdrs, &req->rx_http_version, &req->rx_status, &status_str_off);
 8005f22:	6a3b      	ldr	r3, [r7, #32]
 8005f24:	6958      	ldr	r0, [r3, #20]
 8005f26:	6a3b      	ldr	r3, [r7, #32]
 8005f28:	3318      	adds	r3, #24
 8005f2a:	0019      	movs	r1, r3
 8005f2c:	6a3b      	ldr	r3, [r7, #32]
 8005f2e:	331a      	adds	r3, #26
 8005f30:	001a      	movs	r2, r3
 8005f32:	251f      	movs	r5, #31
 8005f34:	197c      	adds	r4, r7, r5
 8005f36:	2316      	movs	r3, #22
 8005f38:	18fb      	adds	r3, r7, r3
 8005f3a:	f7ff fe5d 	bl	8005bf8 <http_parse_response_status>
 8005f3e:	0003      	movs	r3, r0
 8005f40:	7023      	strb	r3, [r4, #0]
      if (err == ERR_OK) {
 8005f42:	197b      	adds	r3, r7, r5
 8005f44:	781b      	ldrb	r3, [r3, #0]
 8005f46:	b25b      	sxtb	r3, r3
 8005f48:	2b00      	cmp	r3, #0
 8005f4a:	d103      	bne.n	8005f54 <httpc_tcp_recv+0xd4>
        /* don't care status string */
        req->parse_state = HTTPC_PARSE_WAIT_HEADERS;
 8005f4c:	6a3b      	ldr	r3, [r7, #32]
 8005f4e:	2230      	movs	r2, #48	; 0x30
 8005f50:	2101      	movs	r1, #1
 8005f52:	5499      	strb	r1, [r3, r2]
      }
    }
    if (req->parse_state == HTTPC_PARSE_WAIT_HEADERS) {
 8005f54:	6a3b      	ldr	r3, [r7, #32]
 8005f56:	2230      	movs	r2, #48	; 0x30
 8005f58:	5c9b      	ldrb	r3, [r3, r2]
 8005f5a:	2b01      	cmp	r3, #1
 8005f5c:	d15a      	bne.n	8006014 <httpc_tcp_recv+0x194>
      u16_t total_header_len;
      err_t err = http_wait_headers(req->rx_hdrs, &req->hdr_content_len, &total_header_len);
 8005f5e:	6a3b      	ldr	r3, [r7, #32]
 8005f60:	6958      	ldr	r0, [r3, #20]
 8005f62:	6a3b      	ldr	r3, [r7, #32]
 8005f64:	332c      	adds	r3, #44	; 0x2c
 8005f66:	251e      	movs	r5, #30
 8005f68:	197c      	adds	r4, r7, r5
 8005f6a:	2614      	movs	r6, #20
 8005f6c:	19ba      	adds	r2, r7, r6
 8005f6e:	0019      	movs	r1, r3
 8005f70:	f7ff ff02 	bl	8005d78 <http_wait_headers>
 8005f74:	0003      	movs	r3, r0
 8005f76:	7023      	strb	r3, [r4, #0]
      if (err == ERR_OK) {
 8005f78:	002c      	movs	r4, r5
 8005f7a:	193b      	adds	r3, r7, r4
 8005f7c:	781b      	ldrb	r3, [r3, #0]
 8005f7e:	b25b      	sxtb	r3, r3
 8005f80:	2b00      	cmp	r3, #0
 8005f82:	d147      	bne.n	8006014 <httpc_tcp_recv+0x194>
        struct pbuf *q;
        /* full header received, send window update for header bytes and call into client callback */
        altcp_recved(pcb, total_header_len);
 8005f84:	19bb      	adds	r3, r7, r6
 8005f86:	881a      	ldrh	r2, [r3, #0]
 8005f88:	68bb      	ldr	r3, [r7, #8]
 8005f8a:	0011      	movs	r1, r2
 8005f8c:	0018      	movs	r0, r3
 8005f8e:	f004 fff9 	bl	800af84 <tcp_recved>
        if (req->conn_settings) {
 8005f92:	6a3b      	ldr	r3, [r7, #32]
 8005f94:	6a1b      	ldr	r3, [r3, #32]
 8005f96:	2b00      	cmp	r3, #0
 8005f98:	d028      	beq.n	8005fec <httpc_tcp_recv+0x16c>
          if (req->conn_settings->headers_done_fn) {
 8005f9a:	6a3b      	ldr	r3, [r7, #32]
 8005f9c:	6a1b      	ldr	r3, [r3, #32]
 8005f9e:	68db      	ldr	r3, [r3, #12]
 8005fa0:	2b00      	cmp	r3, #0
 8005fa2:	d023      	beq.n	8005fec <httpc_tcp_recv+0x16c>
            err = req->conn_settings->headers_done_fn(req, req->callback_arg, req->rx_hdrs, total_header_len, req->hdr_content_len);
 8005fa4:	6a3b      	ldr	r3, [r7, #32]
 8005fa6:	6a1b      	ldr	r3, [r3, #32]
 8005fa8:	68dd      	ldr	r5, [r3, #12]
 8005faa:	6a3b      	ldr	r3, [r7, #32]
 8005fac:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8005fae:	6a3b      	ldr	r3, [r7, #32]
 8005fb0:	695a      	ldr	r2, [r3, #20]
 8005fb2:	19bb      	adds	r3, r7, r6
 8005fb4:	881e      	ldrh	r6, [r3, #0]
 8005fb6:	6a3b      	ldr	r3, [r7, #32]
 8005fb8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005fba:	193c      	adds	r4, r7, r4
 8005fbc:	6a38      	ldr	r0, [r7, #32]
 8005fbe:	9300      	str	r3, [sp, #0]
 8005fc0:	0033      	movs	r3, r6
 8005fc2:	47a8      	blx	r5
 8005fc4:	0003      	movs	r3, r0
 8005fc6:	7023      	strb	r3, [r4, #0]
            if (err != ERR_OK) {
 8005fc8:	241e      	movs	r4, #30
 8005fca:	193b      	adds	r3, r7, r4
 8005fcc:	781b      	ldrb	r3, [r3, #0]
 8005fce:	b25b      	sxtb	r3, r3
 8005fd0:	2b00      	cmp	r3, #0
 8005fd2:	d00b      	beq.n	8005fec <httpc_tcp_recv+0x16c>
              return httpc_close(req, HTTPC_RESULT_LOCAL_ABORT, req->rx_status, err);
 8005fd4:	6a3b      	ldr	r3, [r7, #32]
 8005fd6:	8b5b      	ldrh	r3, [r3, #26]
 8005fd8:	001a      	movs	r2, r3
 8005fda:	193b      	adds	r3, r7, r4
 8005fdc:	781b      	ldrb	r3, [r3, #0]
 8005fde:	b25b      	sxtb	r3, r3
 8005fe0:	6a38      	ldr	r0, [r7, #32]
 8005fe2:	2108      	movs	r1, #8
 8005fe4:	f7ff fdd1 	bl	8005b8a <httpc_close>
 8005fe8:	0003      	movs	r3, r0
 8005fea:	e03e      	b.n	800606a <httpc_tcp_recv+0x1ea>
            }
          }
        }
        /* hide header bytes in pbuf */
        q = pbuf_free_header(req->rx_hdrs, total_header_len);
 8005fec:	6a3b      	ldr	r3, [r7, #32]
 8005fee:	695a      	ldr	r2, [r3, #20]
 8005ff0:	2314      	movs	r3, #20
 8005ff2:	18fb      	adds	r3, r7, r3
 8005ff4:	881b      	ldrh	r3, [r3, #0]
 8005ff6:	0019      	movs	r1, r3
 8005ff8:	0010      	movs	r0, r2
 8005ffa:	f003 fda6 	bl	8009b4a <pbuf_free_header>
 8005ffe:	0003      	movs	r3, r0
 8006000:	61bb      	str	r3, [r7, #24]
        p = q;
 8006002:	69bb      	ldr	r3, [r7, #24]
 8006004:	607b      	str	r3, [r7, #4]
        req->rx_hdrs = NULL;
 8006006:	6a3b      	ldr	r3, [r7, #32]
 8006008:	2200      	movs	r2, #0
 800600a:	615a      	str	r2, [r3, #20]
        /* go on with data */
        req->parse_state = HTTPC_PARSE_RX_DATA;
 800600c:	6a3b      	ldr	r3, [r7, #32]
 800600e:	2230      	movs	r2, #48	; 0x30
 8006010:	2102      	movs	r1, #2
 8006012:	5499      	strb	r1, [r3, r2]
      }
    }
  }
  if ((p != NULL) && (req->parse_state == HTTPC_PARSE_RX_DATA)) {
 8006014:	687b      	ldr	r3, [r7, #4]
 8006016:	2b00      	cmp	r3, #0
 8006018:	d026      	beq.n	8006068 <httpc_tcp_recv+0x1e8>
 800601a:	6a3b      	ldr	r3, [r7, #32]
 800601c:	2230      	movs	r2, #48	; 0x30
 800601e:	5c9b      	ldrb	r3, [r3, r2]
 8006020:	2b02      	cmp	r3, #2
 8006022:	d121      	bne.n	8006068 <httpc_tcp_recv+0x1e8>
    req->rx_content_len += p->tot_len;
 8006024:	6a3b      	ldr	r3, [r7, #32]
 8006026:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006028:	687a      	ldr	r2, [r7, #4]
 800602a:	8912      	ldrh	r2, [r2, #8]
 800602c:	189a      	adds	r2, r3, r2
 800602e:	6a3b      	ldr	r3, [r7, #32]
 8006030:	629a      	str	r2, [r3, #40]	; 0x28
    if (req->recv_fn != NULL) {
 8006032:	6a3b      	ldr	r3, [r7, #32]
 8006034:	69db      	ldr	r3, [r3, #28]
 8006036:	2b00      	cmp	r3, #0
 8006038:	d00b      	beq.n	8006052 <httpc_tcp_recv+0x1d2>
      /* directly return here: the connection migth already be aborted from the callback! */
      return req->recv_fn(req->callback_arg, pcb, p, r);
 800603a:	6a3b      	ldr	r3, [r7, #32]
 800603c:	69dc      	ldr	r4, [r3, #28]
 800603e:	6a3b      	ldr	r3, [r7, #32]
 8006040:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8006042:	1cfb      	adds	r3, r7, #3
 8006044:	781b      	ldrb	r3, [r3, #0]
 8006046:	b25b      	sxtb	r3, r3
 8006048:	687a      	ldr	r2, [r7, #4]
 800604a:	68b9      	ldr	r1, [r7, #8]
 800604c:	47a0      	blx	r4
 800604e:	0003      	movs	r3, r0
 8006050:	e00b      	b.n	800606a <httpc_tcp_recv+0x1ea>
    } else {
      altcp_recved(pcb, p->tot_len);
 8006052:	687b      	ldr	r3, [r7, #4]
 8006054:	891a      	ldrh	r2, [r3, #8]
 8006056:	68bb      	ldr	r3, [r7, #8]
 8006058:	0011      	movs	r1, r2
 800605a:	0018      	movs	r0, r3
 800605c:	f004 ff92 	bl	800af84 <tcp_recved>
      pbuf_free(p);
 8006060:	687b      	ldr	r3, [r7, #4]
 8006062:	0018      	movs	r0, r3
 8006064:	f003 fdb4 	bl	8009bd0 <pbuf_free>
    }
  }
  return ERR_OK;
 8006068:	2300      	movs	r3, #0
}
 800606a:	0018      	movs	r0, r3
 800606c:	46bd      	mov	sp, r7
 800606e:	b00b      	add	sp, #44	; 0x2c
 8006070:	bdf0      	pop	{r4, r5, r6, r7, pc}

08006072 <httpc_tcp_err>:

/** http client tcp err callback */
static void
httpc_tcp_err(void *arg, err_t err)
{
 8006072:	b580      	push	{r7, lr}
 8006074:	b084      	sub	sp, #16
 8006076:	af00      	add	r7, sp, #0
 8006078:	6078      	str	r0, [r7, #4]
 800607a:	000a      	movs	r2, r1
 800607c:	1cfb      	adds	r3, r7, #3
 800607e:	701a      	strb	r2, [r3, #0]
  httpc_state_t* req = (httpc_state_t*)arg;
 8006080:	687b      	ldr	r3, [r7, #4]
 8006082:	60fb      	str	r3, [r7, #12]
  if (req != NULL) {
 8006084:	68fb      	ldr	r3, [r7, #12]
 8006086:	2b00      	cmp	r3, #0
 8006088:	d00a      	beq.n	80060a0 <httpc_tcp_err+0x2e>
    /* pcb has already been deallocated */
    req->pcb = NULL;
 800608a:	68fb      	ldr	r3, [r7, #12]
 800608c:	2200      	movs	r2, #0
 800608e:	601a      	str	r2, [r3, #0]
    httpc_close(req, HTTPC_RESULT_ERR_CLOSED, 0, err);
 8006090:	1cfb      	adds	r3, r7, #3
 8006092:	781b      	ldrb	r3, [r3, #0]
 8006094:	b25b      	sxtb	r3, r3
 8006096:	68f8      	ldr	r0, [r7, #12]
 8006098:	2200      	movs	r2, #0
 800609a:	2104      	movs	r1, #4
 800609c:	f7ff fd75 	bl	8005b8a <httpc_close>
  }
}
 80060a0:	46c0      	nop			; (mov r8, r8)
 80060a2:	46bd      	mov	sp, r7
 80060a4:	b004      	add	sp, #16
 80060a6:	bd80      	pop	{r7, pc}

080060a8 <httpc_tcp_poll>:

/** http client tcp poll callback */
static err_t
httpc_tcp_poll(void *arg, struct altcp_pcb *pcb)
{
 80060a8:	b580      	push	{r7, lr}
 80060aa:	b084      	sub	sp, #16
 80060ac:	af00      	add	r7, sp, #0
 80060ae:	6078      	str	r0, [r7, #4]
 80060b0:	6039      	str	r1, [r7, #0]
  /* implement timeout */
  httpc_state_t* req = (httpc_state_t*)arg;
 80060b2:	687b      	ldr	r3, [r7, #4]
 80060b4:	60fb      	str	r3, [r7, #12]
  LWIP_UNUSED_ARG(pcb);
  if (req != NULL) {
 80060b6:	68fb      	ldr	r3, [r7, #12]
 80060b8:	2b00      	cmp	r3, #0
 80060ba:	d014      	beq.n	80060e6 <httpc_tcp_poll+0x3e>
    if (req->timeout_ticks) {
 80060bc:	68fb      	ldr	r3, [r7, #12]
 80060be:	68db      	ldr	r3, [r3, #12]
 80060c0:	2b00      	cmp	r3, #0
 80060c2:	d004      	beq.n	80060ce <httpc_tcp_poll+0x26>
      req->timeout_ticks--;
 80060c4:	68fb      	ldr	r3, [r7, #12]
 80060c6:	68db      	ldr	r3, [r3, #12]
 80060c8:	1e5a      	subs	r2, r3, #1
 80060ca:	68fb      	ldr	r3, [r7, #12]
 80060cc:	60da      	str	r2, [r3, #12]
    }
    if (!req->timeout_ticks) {
 80060ce:	68fb      	ldr	r3, [r7, #12]
 80060d0:	68db      	ldr	r3, [r3, #12]
 80060d2:	2b00      	cmp	r3, #0
 80060d4:	d107      	bne.n	80060e6 <httpc_tcp_poll+0x3e>
      return httpc_close(req, HTTPC_RESULT_ERR_TIMEOUT, 0, ERR_OK);
 80060d6:	68f8      	ldr	r0, [r7, #12]
 80060d8:	2300      	movs	r3, #0
 80060da:	2200      	movs	r2, #0
 80060dc:	2105      	movs	r1, #5
 80060de:	f7ff fd54 	bl	8005b8a <httpc_close>
 80060e2:	0003      	movs	r3, r0
 80060e4:	e000      	b.n	80060e8 <httpc_tcp_poll+0x40>
    }
  }
  return ERR_OK;
 80060e6:	2300      	movs	r3, #0
}
 80060e8:	0018      	movs	r0, r3
 80060ea:	46bd      	mov	sp, r7
 80060ec:	b004      	add	sp, #16
 80060ee:	bd80      	pop	{r7, pc}

080060f0 <httpc_tcp_sent>:

/** http client tcp sent callback */
static err_t
httpc_tcp_sent(void *arg, struct altcp_pcb *pcb, u16_t len)
{
 80060f0:	b580      	push	{r7, lr}
 80060f2:	b084      	sub	sp, #16
 80060f4:	af00      	add	r7, sp, #0
 80060f6:	60f8      	str	r0, [r7, #12]
 80060f8:	60b9      	str	r1, [r7, #8]
 80060fa:	1dbb      	adds	r3, r7, #6
 80060fc:	801a      	strh	r2, [r3, #0]
  /* nothing to do here for now */
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(len);
  return ERR_OK;
 80060fe:	2300      	movs	r3, #0
}
 8006100:	0018      	movs	r0, r3
 8006102:	46bd      	mov	sp, r7
 8006104:	b004      	add	sp, #16
 8006106:	bd80      	pop	{r7, pc}

08006108 <httpc_tcp_connected>:

/** http client tcp connected callback */
static err_t
httpc_tcp_connected(void *arg, struct altcp_pcb *pcb, err_t err)
{
 8006108:	b5b0      	push	{r4, r5, r7, lr}
 800610a:	b086      	sub	sp, #24
 800610c:	af00      	add	r7, sp, #0
 800610e:	60f8      	str	r0, [r7, #12]
 8006110:	60b9      	str	r1, [r7, #8]
 8006112:	1dfb      	adds	r3, r7, #7
 8006114:	701a      	strb	r2, [r3, #0]
  err_t r;
  httpc_state_t* req = (httpc_state_t*)arg;
 8006116:	68fb      	ldr	r3, [r7, #12]
 8006118:	617b      	str	r3, [r7, #20]
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  /* send request; last char is zero termination */
  r = altcp_write(req->pcb, req->request->payload, req->request->len - 1, TCP_WRITE_FLAG_COPY);
 800611a:	697b      	ldr	r3, [r7, #20]
 800611c:	6818      	ldr	r0, [r3, #0]
 800611e:	697b      	ldr	r3, [r7, #20]
 8006120:	691b      	ldr	r3, [r3, #16]
 8006122:	6859      	ldr	r1, [r3, #4]
 8006124:	697b      	ldr	r3, [r7, #20]
 8006126:	691b      	ldr	r3, [r3, #16]
 8006128:	895b      	ldrh	r3, [r3, #10]
 800612a:	3b01      	subs	r3, #1
 800612c:	b29a      	uxth	r2, r3
 800612e:	2513      	movs	r5, #19
 8006130:	197c      	adds	r4, r7, r5
 8006132:	2301      	movs	r3, #1
 8006134:	f009 fba4 	bl	800f880 <tcp_write>
 8006138:	0003      	movs	r3, r0
 800613a:	7023      	strb	r3, [r4, #0]
  if (r != ERR_OK) {
 800613c:	197b      	adds	r3, r7, r5
 800613e:	781b      	ldrb	r3, [r3, #0]
 8006140:	b25b      	sxtb	r3, r3
 8006142:	2b00      	cmp	r3, #0
 8006144:	d009      	beq.n	800615a <httpc_tcp_connected+0x52>
     /* could not write the single small request -> fail, don't retry */
     return httpc_close(req, HTTPC_RESULT_ERR_MEM, 0, r);
 8006146:	197b      	adds	r3, r7, r5
 8006148:	781b      	ldrb	r3, [r3, #0]
 800614a:	b25b      	sxtb	r3, r3
 800614c:	6978      	ldr	r0, [r7, #20]
 800614e:	2200      	movs	r2, #0
 8006150:	2107      	movs	r1, #7
 8006152:	f7ff fd1a 	bl	8005b8a <httpc_close>
 8006156:	0003      	movs	r3, r0
 8006158:	e00d      	b.n	8006176 <httpc_tcp_connected+0x6e>
  }
  /* everything written, we can free the request */
  pbuf_free(req->request);
 800615a:	697b      	ldr	r3, [r7, #20]
 800615c:	691b      	ldr	r3, [r3, #16]
 800615e:	0018      	movs	r0, r3
 8006160:	f003 fd36 	bl	8009bd0 <pbuf_free>
  req->request = NULL;
 8006164:	697b      	ldr	r3, [r7, #20]
 8006166:	2200      	movs	r2, #0
 8006168:	611a      	str	r2, [r3, #16]

  altcp_output(req->pcb);
 800616a:	697b      	ldr	r3, [r7, #20]
 800616c:	681b      	ldr	r3, [r3, #0]
 800616e:	0018      	movs	r0, r3
 8006170:	f00a fc8e 	bl	8010a90 <tcp_output>
  return ERR_OK;
 8006174:	2300      	movs	r3, #0
}
 8006176:	0018      	movs	r0, r3
 8006178:	46bd      	mov	sp, r7
 800617a:	b006      	add	sp, #24
 800617c:	bdb0      	pop	{r4, r5, r7, pc}
	...

08006180 <httpc_get_internal_addr>:

/** Start the http request when the server IP addr is known */
static err_t
httpc_get_internal_addr(httpc_state_t* req, const ip_addr_t *ipaddr)
{
 8006180:	b5b0      	push	{r4, r5, r7, lr}
 8006182:	b084      	sub	sp, #16
 8006184:	af00      	add	r7, sp, #0
 8006186:	6078      	str	r0, [r7, #4]
 8006188:	6039      	str	r1, [r7, #0]
  err_t err;
  LWIP_ASSERT("req != NULL", req != NULL);
 800618a:	687b      	ldr	r3, [r7, #4]
 800618c:	2b00      	cmp	r3, #0
 800618e:	d106      	bne.n	800619e <httpc_get_internal_addr+0x1e>
 8006190:	4b19      	ldr	r3, [pc, #100]	; (80061f8 <httpc_get_internal_addr+0x78>)
 8006192:	22d2      	movs	r2, #210	; 0xd2
 8006194:	0052      	lsls	r2, r2, #1
 8006196:	4919      	ldr	r1, [pc, #100]	; (80061fc <httpc_get_internal_addr+0x7c>)
 8006198:	4819      	ldr	r0, [pc, #100]	; (8006200 <httpc_get_internal_addr+0x80>)
 800619a:	f7fc fb9f 	bl	80028dc <app_debug_rtt_raw>

  if (&req->remote_addr != ipaddr) {
 800619e:	687b      	ldr	r3, [r7, #4]
 80061a0:	3304      	adds	r3, #4
 80061a2:	683a      	ldr	r2, [r7, #0]
 80061a4:	429a      	cmp	r2, r3
 80061a6:	d003      	beq.n	80061b0 <httpc_get_internal_addr+0x30>
    /* fill in remote addr if called externally */
    req->remote_addr = *ipaddr;
 80061a8:	687b      	ldr	r3, [r7, #4]
 80061aa:	683a      	ldr	r2, [r7, #0]
 80061ac:	6812      	ldr	r2, [r2, #0]
 80061ae:	605a      	str	r2, [r3, #4]
  }

  err = altcp_connect(req->pcb, &req->remote_addr, req->remote_port, httpc_tcp_connected);
 80061b0:	687b      	ldr	r3, [r7, #4]
 80061b2:	6818      	ldr	r0, [r3, #0]
 80061b4:	687b      	ldr	r3, [r7, #4]
 80061b6:	1d19      	adds	r1, r3, #4
 80061b8:	687b      	ldr	r3, [r7, #4]
 80061ba:	891a      	ldrh	r2, [r3, #8]
 80061bc:	250f      	movs	r5, #15
 80061be:	197c      	adds	r4, r7, r5
 80061c0:	4b10      	ldr	r3, [pc, #64]	; (8006204 <httpc_get_internal_addr+0x84>)
 80061c2:	f004 ff8b 	bl	800b0dc <tcp_connect>
 80061c6:	0003      	movs	r3, r0
 80061c8:	7023      	strb	r3, [r4, #0]
  if (err == ERR_OK) {
 80061ca:	197b      	adds	r3, r7, r5
 80061cc:	781b      	ldrb	r3, [r3, #0]
 80061ce:	b25b      	sxtb	r3, r3
 80061d0:	2b00      	cmp	r3, #0
 80061d2:	d101      	bne.n	80061d8 <httpc_get_internal_addr+0x58>
    return ERR_OK;
 80061d4:	2300      	movs	r3, #0
 80061d6:	e00b      	b.n	80061f0 <httpc_get_internal_addr+0x70>
  }
  LWIP_DEBUGF(HTTPC_DEBUG_WARN_STATE, ("tcp_connect failed: %d\n", (int)err));
 80061d8:	240f      	movs	r4, #15
 80061da:	193b      	adds	r3, r7, r4
 80061dc:	2200      	movs	r2, #0
 80061de:	569a      	ldrsb	r2, [r3, r2]
 80061e0:	4b09      	ldr	r3, [pc, #36]	; (8006208 <httpc_get_internal_addr+0x88>)
 80061e2:	0011      	movs	r1, r2
 80061e4:	0018      	movs	r0, r3
 80061e6:	f7fc fb79 	bl	80028dc <app_debug_rtt_raw>
  return err;
 80061ea:	193b      	adds	r3, r7, r4
 80061ec:	781b      	ldrb	r3, [r3, #0]
 80061ee:	b25b      	sxtb	r3, r3
}
 80061f0:	0018      	movs	r0, r3
 80061f2:	46bd      	mov	sp, r7
 80061f4:	b004      	add	sp, #16
 80061f6:	bdb0      	pop	{r4, r5, r7, pc}
 80061f8:	0801eac8 	.word	0x0801eac8
 80061fc:	0801eafc 	.word	0x0801eafc
 8006200:	0801eb08 	.word	0x0801eb08
 8006204:	08006109 	.word	0x08006109
 8006208:	0801eb34 	.word	0x0801eb34

0800620c <httpc_dns_found>:
/** DNS callback
 * If ipaddr is non-NULL, resolving succeeded and the request can be sent, otherwise it failed.
 */
static void
httpc_dns_found(const char* hostname, const ip_addr_t *ipaddr, void *arg)
{
 800620c:	b5b0      	push	{r4, r5, r7, lr}
 800620e:	b086      	sub	sp, #24
 8006210:	af00      	add	r7, sp, #0
 8006212:	60f8      	str	r0, [r7, #12]
 8006214:	60b9      	str	r1, [r7, #8]
 8006216:	607a      	str	r2, [r7, #4]
  httpc_state_t* req = (httpc_state_t*)arg;
 8006218:	687b      	ldr	r3, [r7, #4]
 800621a:	613b      	str	r3, [r7, #16]
  err_t err;
  httpc_result_t result;

  LWIP_UNUSED_ARG(hostname);

  if (ipaddr != NULL) {
 800621c:	68bb      	ldr	r3, [r7, #8]
 800621e:	2b00      	cmp	r3, #0
 8006220:	d013      	beq.n	800624a <httpc_dns_found+0x3e>
    err = httpc_get_internal_addr(req, ipaddr);
 8006222:	2517      	movs	r5, #23
 8006224:	197c      	adds	r4, r7, r5
 8006226:	68ba      	ldr	r2, [r7, #8]
 8006228:	693b      	ldr	r3, [r7, #16]
 800622a:	0011      	movs	r1, r2
 800622c:	0018      	movs	r0, r3
 800622e:	f7ff ffa7 	bl	8006180 <httpc_get_internal_addr>
 8006232:	0003      	movs	r3, r0
 8006234:	7023      	strb	r3, [r4, #0]
    if (err == ERR_OK) {
 8006236:	197b      	adds	r3, r7, r5
 8006238:	781b      	ldrb	r3, [r3, #0]
 800623a:	b25b      	sxtb	r3, r3
 800623c:	2b00      	cmp	r3, #0
 800623e:	d01f      	beq.n	8006280 <httpc_dns_found+0x74>
      return;
    }
    result = HTTPC_RESULT_ERR_CONNECT;
 8006240:	2316      	movs	r3, #22
 8006242:	18fb      	adds	r3, r7, r3
 8006244:	2202      	movs	r2, #2
 8006246:	701a      	strb	r2, [r3, #0]
 8006248:	e00d      	b.n	8006266 <httpc_dns_found+0x5a>
  } else {
    LWIP_DEBUGF(HTTPC_DEBUG_WARN_STATE, ("httpc_dns_found: failed to resolve hostname: %s\n",
 800624a:	68fa      	ldr	r2, [r7, #12]
 800624c:	4b0e      	ldr	r3, [pc, #56]	; (8006288 <httpc_dns_found+0x7c>)
 800624e:	0011      	movs	r1, r2
 8006250:	0018      	movs	r0, r3
 8006252:	f7fc fb43 	bl	80028dc <app_debug_rtt_raw>
      hostname));
    result = HTTPC_RESULT_ERR_HOSTNAME;
 8006256:	2316      	movs	r3, #22
 8006258:	18fb      	adds	r3, r7, r3
 800625a:	2203      	movs	r2, #3
 800625c:	701a      	strb	r2, [r3, #0]
    err = ERR_ARG;
 800625e:	2317      	movs	r3, #23
 8006260:	18fb      	adds	r3, r7, r3
 8006262:	22f0      	movs	r2, #240	; 0xf0
 8006264:	701a      	strb	r2, [r3, #0]
  }
  httpc_close(req, result, 0, err);
 8006266:	2317      	movs	r3, #23
 8006268:	18fb      	adds	r3, r7, r3
 800626a:	2200      	movs	r2, #0
 800626c:	569a      	ldrsb	r2, [r3, r2]
 800626e:	2316      	movs	r3, #22
 8006270:	18fb      	adds	r3, r7, r3
 8006272:	7819      	ldrb	r1, [r3, #0]
 8006274:	6938      	ldr	r0, [r7, #16]
 8006276:	0013      	movs	r3, r2
 8006278:	2200      	movs	r2, #0
 800627a:	f7ff fc86 	bl	8005b8a <httpc_close>
 800627e:	e000      	b.n	8006282 <httpc_dns_found+0x76>
      return;
 8006280:	46c0      	nop			; (mov r8, r8)
}
 8006282:	46bd      	mov	sp, r7
 8006284:	b006      	add	sp, #24
 8006286:	bdb0      	pop	{r4, r5, r7, pc}
 8006288:	0801eb4c 	.word	0x0801eb4c

0800628c <httpc_get_internal_dns>:
#endif /* LWIP_DNS */

/** Start the http request after converting 'server_name' to ip address (DNS or address string) */
static err_t
httpc_get_internal_dns(httpc_state_t* req, const char* server_name)
{
 800628c:	b5b0      	push	{r4, r5, r7, lr}
 800628e:	b084      	sub	sp, #16
 8006290:	af00      	add	r7, sp, #0
 8006292:	6078      	str	r0, [r7, #4]
 8006294:	6039      	str	r1, [r7, #0]
  err_t err;
  LWIP_ASSERT("req != NULL", req != NULL);
 8006296:	687b      	ldr	r3, [r7, #4]
 8006298:	2b00      	cmp	r3, #0
 800629a:	d106      	bne.n	80062aa <httpc_get_internal_dns+0x1e>
 800629c:	4b19      	ldr	r3, [pc, #100]	; (8006304 <httpc_get_internal_dns+0x78>)
 800629e:	22d6      	movs	r2, #214	; 0xd6
 80062a0:	32ff      	adds	r2, #255	; 0xff
 80062a2:	4919      	ldr	r1, [pc, #100]	; (8006308 <httpc_get_internal_dns+0x7c>)
 80062a4:	4819      	ldr	r0, [pc, #100]	; (800630c <httpc_get_internal_dns+0x80>)
 80062a6:	f7fc fb19 	bl	80028dc <app_debug_rtt_raw>

#if LWIP_DNS
  err = dns_gethostbyname(server_name, &req->remote_addr, httpc_dns_found, req);
 80062aa:	687b      	ldr	r3, [r7, #4]
 80062ac:	1d19      	adds	r1, r3, #4
 80062ae:	250f      	movs	r5, #15
 80062b0:	197c      	adds	r4, r7, r5
 80062b2:	687b      	ldr	r3, [r7, #4]
 80062b4:	4a16      	ldr	r2, [pc, #88]	; (8006310 <httpc_get_internal_dns+0x84>)
 80062b6:	6838      	ldr	r0, [r7, #0]
 80062b8:	f001 fdac 	bl	8007e14 <dns_gethostbyname>
 80062bc:	0003      	movs	r3, r0
 80062be:	7023      	strb	r3, [r4, #0]
#else
  err = ipaddr_aton(server_name, &req->remote_addr) ? ERR_OK : ERR_ARG;
#endif

  if (err == ERR_OK) {
 80062c0:	0029      	movs	r1, r5
 80062c2:	187b      	adds	r3, r7, r1
 80062c4:	781b      	ldrb	r3, [r3, #0]
 80062c6:	b25b      	sxtb	r3, r3
 80062c8:	2b00      	cmp	r3, #0
 80062ca:	d10a      	bne.n	80062e2 <httpc_get_internal_dns+0x56>
    /* cached or IP-string */
    err = httpc_get_internal_addr(req, &req->remote_addr);
 80062cc:	687b      	ldr	r3, [r7, #4]
 80062ce:	1d1a      	adds	r2, r3, #4
 80062d0:	187c      	adds	r4, r7, r1
 80062d2:	687b      	ldr	r3, [r7, #4]
 80062d4:	0011      	movs	r1, r2
 80062d6:	0018      	movs	r0, r3
 80062d8:	f7ff ff52 	bl	8006180 <httpc_get_internal_addr>
 80062dc:	0003      	movs	r3, r0
 80062de:	7023      	strb	r3, [r4, #0]
 80062e0:	e007      	b.n	80062f2 <httpc_get_internal_dns+0x66>
  } else if (err == ERR_INPROGRESS) {
 80062e2:	230f      	movs	r3, #15
 80062e4:	18fb      	adds	r3, r7, r3
 80062e6:	781b      	ldrb	r3, [r3, #0]
 80062e8:	b25b      	sxtb	r3, r3
 80062ea:	3305      	adds	r3, #5
 80062ec:	d101      	bne.n	80062f2 <httpc_get_internal_dns+0x66>
    return ERR_OK;
 80062ee:	2300      	movs	r3, #0
 80062f0:	e003      	b.n	80062fa <httpc_get_internal_dns+0x6e>
  }
  return err;
 80062f2:	230f      	movs	r3, #15
 80062f4:	18fb      	adds	r3, r7, r3
 80062f6:	781b      	ldrb	r3, [r3, #0]
 80062f8:	b25b      	sxtb	r3, r3
}
 80062fa:	0018      	movs	r0, r3
 80062fc:	46bd      	mov	sp, r7
 80062fe:	b004      	add	sp, #16
 8006300:	bdb0      	pop	{r4, r5, r7, pc}
 8006302:	46c0      	nop			; (mov r8, r8)
 8006304:	0801eac8 	.word	0x0801eac8
 8006308:	0801eafc 	.word	0x0801eafc
 800630c:	0801eb08 	.word	0x0801eb08
 8006310:	0800620d 	.word	0x0800620d

08006314 <httpc_create_request_string>:

static int
httpc_create_request_string(const httpc_connection_t *settings, const char* server_name, int server_port, const char* uri,
                            int use_host, char *buffer, size_t buffer_size)
{
 8006314:	b590      	push	{r4, r7, lr}
 8006316:	b089      	sub	sp, #36	; 0x24
 8006318:	af04      	add	r7, sp, #16
 800631a:	60f8      	str	r0, [r7, #12]
 800631c:	60b9      	str	r1, [r7, #8]
 800631e:	607a      	str	r2, [r7, #4]
 8006320:	603b      	str	r3, [r7, #0]
  if (settings->use_proxy) {
 8006322:	68fb      	ldr	r3, [r7, #12]
 8006324:	799b      	ldrb	r3, [r3, #6]
 8006326:	2b00      	cmp	r3, #0
 8006328:	d02c      	beq.n	8006384 <httpc_create_request_string+0x70>
    LWIP_ASSERT("server_name != NULL", server_name != NULL);
 800632a:	68bb      	ldr	r3, [r7, #8]
 800632c:	2b00      	cmp	r3, #0
 800632e:	d106      	bne.n	800633e <httpc_create_request_string+0x2a>
 8006330:	4b28      	ldr	r3, [pc, #160]	; (80063d4 <httpc_create_request_string+0xc0>)
 8006332:	22ec      	movs	r2, #236	; 0xec
 8006334:	32ff      	adds	r2, #255	; 0xff
 8006336:	4928      	ldr	r1, [pc, #160]	; (80063d8 <httpc_create_request_string+0xc4>)
 8006338:	4828      	ldr	r0, [pc, #160]	; (80063dc <httpc_create_request_string+0xc8>)
 800633a:	f7fc facf 	bl	80028dc <app_debug_rtt_raw>
    if (server_port != HTTP_DEFAULT_PORT) {
 800633e:	687b      	ldr	r3, [r7, #4]
 8006340:	2b50      	cmp	r3, #80	; 0x50
 8006342:	d010      	beq.n	8006366 <httpc_create_request_string+0x52>
      return snprintf(buffer, buffer_size, HTTPC_REQ_11_PROXY_PORT_FORMAT(server_name, server_port, uri, server_name));
 8006344:	68bc      	ldr	r4, [r7, #8]
 8006346:	4a26      	ldr	r2, [pc, #152]	; (80063e0 <httpc_create_request_string+0xcc>)
 8006348:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800634a:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800634c:	68bb      	ldr	r3, [r7, #8]
 800634e:	9303      	str	r3, [sp, #12]
 8006350:	4b24      	ldr	r3, [pc, #144]	; (80063e4 <httpc_create_request_string+0xd0>)
 8006352:	9302      	str	r3, [sp, #8]
 8006354:	683b      	ldr	r3, [r7, #0]
 8006356:	9301      	str	r3, [sp, #4]
 8006358:	687b      	ldr	r3, [r7, #4]
 800635a:	9300      	str	r3, [sp, #0]
 800635c:	0023      	movs	r3, r4
 800635e:	f016 fd1d 	bl	801cd9c <sniprintf>
 8006362:	0003      	movs	r3, r0
 8006364:	e032      	b.n	80063cc <httpc_create_request_string+0xb8>
    } else {
      return snprintf(buffer, buffer_size, HTTPC_REQ_11_PROXY_FORMAT(server_name, uri, server_name));
 8006366:	68bc      	ldr	r4, [r7, #8]
 8006368:	4a1f      	ldr	r2, [pc, #124]	; (80063e8 <httpc_create_request_string+0xd4>)
 800636a:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800636c:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800636e:	68bb      	ldr	r3, [r7, #8]
 8006370:	9302      	str	r3, [sp, #8]
 8006372:	4b1c      	ldr	r3, [pc, #112]	; (80063e4 <httpc_create_request_string+0xd0>)
 8006374:	9301      	str	r3, [sp, #4]
 8006376:	683b      	ldr	r3, [r7, #0]
 8006378:	9300      	str	r3, [sp, #0]
 800637a:	0023      	movs	r3, r4
 800637c:	f016 fd0e 	bl	801cd9c <sniprintf>
 8006380:	0003      	movs	r3, r0
 8006382:	e023      	b.n	80063cc <httpc_create_request_string+0xb8>
    }
  } else if (use_host) {
 8006384:	6a3b      	ldr	r3, [r7, #32]
 8006386:	2b00      	cmp	r3, #0
 8006388:	d016      	beq.n	80063b8 <httpc_create_request_string+0xa4>
    LWIP_ASSERT("server_name != NULL", server_name != NULL);
 800638a:	68bb      	ldr	r3, [r7, #8]
 800638c:	2b00      	cmp	r3, #0
 800638e:	d106      	bne.n	800639e <httpc_create_request_string+0x8a>
 8006390:	4b10      	ldr	r3, [pc, #64]	; (80063d4 <httpc_create_request_string+0xc0>)
 8006392:	22f9      	movs	r2, #249	; 0xf9
 8006394:	0052      	lsls	r2, r2, #1
 8006396:	4910      	ldr	r1, [pc, #64]	; (80063d8 <httpc_create_request_string+0xc4>)
 8006398:	4810      	ldr	r0, [pc, #64]	; (80063dc <httpc_create_request_string+0xc8>)
 800639a:	f7fc fa9f 	bl	80028dc <app_debug_rtt_raw>
    return snprintf(buffer, buffer_size, HTTPC_REQ_11_HOST_FORMAT(uri, server_name));
 800639e:	683c      	ldr	r4, [r7, #0]
 80063a0:	4a12      	ldr	r2, [pc, #72]	; (80063ec <httpc_create_request_string+0xd8>)
 80063a2:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80063a4:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80063a6:	68bb      	ldr	r3, [r7, #8]
 80063a8:	9301      	str	r3, [sp, #4]
 80063aa:	4b0e      	ldr	r3, [pc, #56]	; (80063e4 <httpc_create_request_string+0xd0>)
 80063ac:	9300      	str	r3, [sp, #0]
 80063ae:	0023      	movs	r3, r4
 80063b0:	f016 fcf4 	bl	801cd9c <sniprintf>
 80063b4:	0003      	movs	r3, r0
 80063b6:	e009      	b.n	80063cc <httpc_create_request_string+0xb8>
  } else {
    return snprintf(buffer, buffer_size, HTTPC_REQ_11_FORMAT(uri));
 80063b8:	683c      	ldr	r4, [r7, #0]
 80063ba:	4a0d      	ldr	r2, [pc, #52]	; (80063f0 <httpc_create_request_string+0xdc>)
 80063bc:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80063be:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80063c0:	4b08      	ldr	r3, [pc, #32]	; (80063e4 <httpc_create_request_string+0xd0>)
 80063c2:	9300      	str	r3, [sp, #0]
 80063c4:	0023      	movs	r3, r4
 80063c6:	f016 fce9 	bl	801cd9c <sniprintf>
 80063ca:	0003      	movs	r3, r0
  }
}
 80063cc:	0018      	movs	r0, r3
 80063ce:	46bd      	mov	sp, r7
 80063d0:	b005      	add	sp, #20
 80063d2:	bd90      	pop	{r4, r7, pc}
 80063d4:	0801eac8 	.word	0x0801eac8
 80063d8:	0801eb80 	.word	0x0801eb80
 80063dc:	0801eb08 	.word	0x0801eb08
 80063e0:	0801eb94 	.word	0x0801eb94
 80063e4:	0801ebf0 	.word	0x0801ebf0
 80063e8:	0801ec28 	.word	0x0801ec28
 80063ec:	0801ec80 	.word	0x0801ec80
 80063f0:	0801ecd0 	.word	0x0801ecd0

080063f4 <httpc_init_connection_common>:

/** Initialize the connection struct */
static err_t
httpc_init_connection_common(httpc_state_t **connection, const httpc_connection_t *settings, const char* server_name,
                      u16_t server_port, const char* uri, altcp_recv_fn recv_fn, void* callback_arg, int use_host)
{
 80063f4:	b5b0      	push	{r4, r5, r7, lr}
 80063f6:	b08e      	sub	sp, #56	; 0x38
 80063f8:	af04      	add	r7, sp, #16
 80063fa:	60f8      	str	r0, [r7, #12]
 80063fc:	60b9      	str	r1, [r7, #8]
 80063fe:	607a      	str	r2, [r7, #4]
 8006400:	001a      	movs	r2, r3
 8006402:	1cbb      	adds	r3, r7, #2
 8006404:	801a      	strh	r2, [r3, #0]
  httpc_state_t *req;
#if HTTPC_DEBUG_REQUEST
  size_t server_name_len, uri_len;
#endif

  LWIP_ASSERT("uri != NULL", uri != NULL);
 8006406:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006408:	2b00      	cmp	r3, #0
 800640a:	d105      	bne.n	8006418 <httpc_init_connection_common+0x24>
 800640c:	4b6f      	ldr	r3, [pc, #444]	; (80065cc <httpc_init_connection_common+0x1d8>)
 800640e:	4a70      	ldr	r2, [pc, #448]	; (80065d0 <httpc_init_connection_common+0x1dc>)
 8006410:	4970      	ldr	r1, [pc, #448]	; (80065d4 <httpc_init_connection_common+0x1e0>)
 8006412:	4871      	ldr	r0, [pc, #452]	; (80065d8 <httpc_init_connection_common+0x1e4>)
 8006414:	f7fc fa62 	bl	80028dc <app_debug_rtt_raw>

  /* get request len */
  req_len = httpc_create_request_string(settings, server_name, server_port, uri, use_host, NULL, 0);
 8006418:	1cbb      	adds	r3, r7, #2
 800641a:	881a      	ldrh	r2, [r3, #0]
 800641c:	6bbc      	ldr	r4, [r7, #56]	; 0x38
 800641e:	6879      	ldr	r1, [r7, #4]
 8006420:	68b8      	ldr	r0, [r7, #8]
 8006422:	2300      	movs	r3, #0
 8006424:	9302      	str	r3, [sp, #8]
 8006426:	2300      	movs	r3, #0
 8006428:	9301      	str	r3, [sp, #4]
 800642a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800642c:	9300      	str	r3, [sp, #0]
 800642e:	0023      	movs	r3, r4
 8006430:	f7ff ff70 	bl	8006314 <httpc_create_request_string>
 8006434:	0003      	movs	r3, r0
 8006436:	627b      	str	r3, [r7, #36]	; 0x24
  if ((req_len < 0) || (req_len > 0xFFFF)) {
 8006438:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800643a:	2b00      	cmp	r3, #0
 800643c:	db04      	blt.n	8006448 <httpc_init_connection_common+0x54>
 800643e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8006440:	2380      	movs	r3, #128	; 0x80
 8006442:	025b      	lsls	r3, r3, #9
 8006444:	429a      	cmp	r2, r3
 8006446:	db02      	blt.n	800644e <httpc_init_connection_common+0x5a>
    return ERR_VAL;
 8006448:	2306      	movs	r3, #6
 800644a:	425b      	negs	r3, r3
 800644c:	e0ba      	b.n	80065c4 <httpc_init_connection_common+0x1d0>
  }
  /* alloc state and request in one block */
  alloc_len = sizeof(httpc_state_t);
 800644e:	2334      	movs	r3, #52	; 0x34
 8006450:	623b      	str	r3, [r7, #32]
#if HTTPC_DEBUG_REQUEST
  server_name_len = server_name ? strlen(server_name) : 0;
  uri_len = strlen(uri);
  alloc_len += server_name_len + 1 + uri_len + 1;
#endif
  mem_alloc_len = (mem_size_t)alloc_len;
 8006452:	211e      	movs	r1, #30
 8006454:	187b      	adds	r3, r7, r1
 8006456:	6a3a      	ldr	r2, [r7, #32]
 8006458:	801a      	strh	r2, [r3, #0]
  if ((mem_alloc_len < alloc_len) || (req_len + 1 > 0xFFFF)) {
 800645a:	187b      	adds	r3, r7, r1
 800645c:	881b      	ldrh	r3, [r3, #0]
 800645e:	6a3a      	ldr	r2, [r7, #32]
 8006460:	429a      	cmp	r2, r3
 8006462:	d803      	bhi.n	800646c <httpc_init_connection_common+0x78>
 8006464:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006466:	4a5d      	ldr	r2, [pc, #372]	; (80065dc <httpc_init_connection_common+0x1e8>)
 8006468:	4293      	cmp	r3, r2
 800646a:	dd02      	ble.n	8006472 <httpc_init_connection_common+0x7e>
    return ERR_VAL;
 800646c:	2306      	movs	r3, #6
 800646e:	425b      	negs	r3, r3
 8006470:	e0a8      	b.n	80065c4 <httpc_init_connection_common+0x1d0>
  }

  req = (httpc_state_t*)mem_malloc((mem_size_t)alloc_len);
 8006472:	6a3b      	ldr	r3, [r7, #32]
 8006474:	b29b      	uxth	r3, r3
 8006476:	0018      	movs	r0, r3
 8006478:	f002 fad2 	bl	8008a20 <mem_malloc>
 800647c:	0003      	movs	r3, r0
 800647e:	61bb      	str	r3, [r7, #24]
  if(req == NULL) {
 8006480:	69bb      	ldr	r3, [r7, #24]
 8006482:	2b00      	cmp	r3, #0
 8006484:	d102      	bne.n	800648c <httpc_init_connection_common+0x98>
    return ERR_MEM;
 8006486:	2301      	movs	r3, #1
 8006488:	425b      	negs	r3, r3
 800648a:	e09b      	b.n	80065c4 <httpc_init_connection_common+0x1d0>
  }
  memset(req, 0, sizeof(httpc_state_t));
 800648c:	69bb      	ldr	r3, [r7, #24]
 800648e:	2234      	movs	r2, #52	; 0x34
 8006490:	2100      	movs	r1, #0
 8006492:	0018      	movs	r0, r3
 8006494:	f016 fbc0 	bl	801cc18 <memset>
  req->timeout_ticks = HTTPC_POLL_TIMEOUT;
 8006498:	69bb      	ldr	r3, [r7, #24]
 800649a:	221e      	movs	r2, #30
 800649c:	60da      	str	r2, [r3, #12]
  req->request = pbuf_alloc(PBUF_RAW, (u16_t)(req_len + 1), PBUF_RAM);
 800649e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80064a0:	b29b      	uxth	r3, r3
 80064a2:	3301      	adds	r3, #1
 80064a4:	b29b      	uxth	r3, r3
 80064a6:	22a0      	movs	r2, #160	; 0xa0
 80064a8:	0092      	lsls	r2, r2, #2
 80064aa:	0019      	movs	r1, r3
 80064ac:	2000      	movs	r0, #0
 80064ae:	f003 f817 	bl	80094e0 <pbuf_alloc>
 80064b2:	0002      	movs	r2, r0
 80064b4:	69bb      	ldr	r3, [r7, #24]
 80064b6:	611a      	str	r2, [r3, #16]
  if (req->request == NULL) {
 80064b8:	69bb      	ldr	r3, [r7, #24]
 80064ba:	691b      	ldr	r3, [r3, #16]
 80064bc:	2b00      	cmp	r3, #0
 80064be:	d106      	bne.n	80064ce <httpc_init_connection_common+0xda>
    httpc_free_state(req);
 80064c0:	69bb      	ldr	r3, [r7, #24]
 80064c2:	0018      	movs	r0, r3
 80064c4:	f7ff fb06 	bl	8005ad4 <httpc_free_state>
    return ERR_MEM;
 80064c8:	2301      	movs	r3, #1
 80064ca:	425b      	negs	r3, r3
 80064cc:	e07a      	b.n	80065c4 <httpc_init_connection_common+0x1d0>
  }
  if (req->request->next != NULL) {
 80064ce:	69bb      	ldr	r3, [r7, #24]
 80064d0:	691b      	ldr	r3, [r3, #16]
 80064d2:	681b      	ldr	r3, [r3, #0]
 80064d4:	2b00      	cmp	r3, #0
 80064d6:	d006      	beq.n	80064e6 <httpc_init_connection_common+0xf2>
    /* need a pbuf in one piece */
    httpc_free_state(req);
 80064d8:	69bb      	ldr	r3, [r7, #24]
 80064da:	0018      	movs	r0, r3
 80064dc:	f7ff fafa 	bl	8005ad4 <httpc_free_state>
    return ERR_MEM;
 80064e0:	2301      	movs	r3, #1
 80064e2:	425b      	negs	r3, r3
 80064e4:	e06e      	b.n	80065c4 <httpc_init_connection_common+0x1d0>
  }
  req->hdr_content_len = HTTPC_CONTENT_LEN_INVALID;
 80064e6:	69bb      	ldr	r3, [r7, #24]
 80064e8:	2201      	movs	r2, #1
 80064ea:	4252      	negs	r2, r2
 80064ec:	62da      	str	r2, [r3, #44]	; 0x2c
    memcpy(req->server_name, server_name, server_name_len + 1);
  }
  req->uri = req->server_name + server_name_len + 1;
  memcpy(req->uri, uri, uri_len + 1);
#endif
  req->pcb = altcp_new(settings->altcp_allocator);
 80064ee:	f005 fdf5 	bl	800c0dc <tcp_new>
 80064f2:	0002      	movs	r2, r0
 80064f4:	69bb      	ldr	r3, [r7, #24]
 80064f6:	601a      	str	r2, [r3, #0]
  if(req->pcb == NULL) {
 80064f8:	69bb      	ldr	r3, [r7, #24]
 80064fa:	681b      	ldr	r3, [r3, #0]
 80064fc:	2b00      	cmp	r3, #0
 80064fe:	d106      	bne.n	800650e <httpc_init_connection_common+0x11a>
    httpc_free_state(req);
 8006500:	69bb      	ldr	r3, [r7, #24]
 8006502:	0018      	movs	r0, r3
 8006504:	f7ff fae6 	bl	8005ad4 <httpc_free_state>
    return ERR_MEM;
 8006508:	2301      	movs	r3, #1
 800650a:	425b      	negs	r3, r3
 800650c:	e05a      	b.n	80065c4 <httpc_init_connection_common+0x1d0>
  }
  req->remote_port = settings->use_proxy ? settings->proxy_port : server_port;
 800650e:	68bb      	ldr	r3, [r7, #8]
 8006510:	799b      	ldrb	r3, [r3, #6]
 8006512:	2b00      	cmp	r3, #0
 8006514:	d002      	beq.n	800651c <httpc_init_connection_common+0x128>
 8006516:	68bb      	ldr	r3, [r7, #8]
 8006518:	889b      	ldrh	r3, [r3, #4]
 800651a:	e001      	b.n	8006520 <httpc_init_connection_common+0x12c>
 800651c:	1cbb      	adds	r3, r7, #2
 800651e:	881b      	ldrh	r3, [r3, #0]
 8006520:	69ba      	ldr	r2, [r7, #24]
 8006522:	8113      	strh	r3, [r2, #8]
  altcp_arg(req->pcb, req);
 8006524:	69bb      	ldr	r3, [r7, #24]
 8006526:	681b      	ldr	r3, [r3, #0]
 8006528:	69ba      	ldr	r2, [r7, #24]
 800652a:	0011      	movs	r1, r2
 800652c:	0018      	movs	r0, r3
 800652e:	f005 fdde 	bl	800c0ee <tcp_arg>
  altcp_recv(req->pcb, httpc_tcp_recv);
 8006532:	69bb      	ldr	r3, [r7, #24]
 8006534:	681b      	ldr	r3, [r3, #0]
 8006536:	4a2a      	ldr	r2, [pc, #168]	; (80065e0 <httpc_init_connection_common+0x1ec>)
 8006538:	0011      	movs	r1, r2
 800653a:	0018      	movs	r0, r3
 800653c:	f005 fde6 	bl	800c10c <tcp_recv>
  altcp_err(req->pcb, httpc_tcp_err);
 8006540:	69bb      	ldr	r3, [r7, #24]
 8006542:	681b      	ldr	r3, [r3, #0]
 8006544:	4a27      	ldr	r2, [pc, #156]	; (80065e4 <httpc_init_connection_common+0x1f0>)
 8006546:	0011      	movs	r1, r2
 8006548:	0018      	movs	r0, r3
 800654a:	f005 fe23 	bl	800c194 <tcp_err>
  altcp_poll(req->pcb, httpc_tcp_poll, HTTPC_POLL_INTERVAL);
 800654e:	69bb      	ldr	r3, [r7, #24]
 8006550:	681b      	ldr	r3, [r3, #0]
 8006552:	4925      	ldr	r1, [pc, #148]	; (80065e8 <httpc_init_connection_common+0x1f4>)
 8006554:	2201      	movs	r2, #1
 8006556:	0018      	movs	r0, r3
 8006558:	f005 fe3e 	bl	800c1d8 <tcp_poll>
  altcp_sent(req->pcb, httpc_tcp_sent);
 800655c:	69bb      	ldr	r3, [r7, #24]
 800655e:	681b      	ldr	r3, [r3, #0]
 8006560:	4a22      	ldr	r2, [pc, #136]	; (80065ec <httpc_init_connection_common+0x1f8>)
 8006562:	0011      	movs	r1, r2
 8006564:	0018      	movs	r0, r3
 8006566:	f005 fdf3 	bl	800c150 <tcp_sent>

  /* set up request buffer */
  req_len2 = httpc_create_request_string(settings, server_name, server_port, uri, use_host,
 800656a:	1cbb      	adds	r3, r7, #2
 800656c:	881c      	ldrh	r4, [r3, #0]
    (char *)req->request->payload, req_len + 1);
 800656e:	69bb      	ldr	r3, [r7, #24]
 8006570:	691b      	ldr	r3, [r3, #16]
 8006572:	685b      	ldr	r3, [r3, #4]
 8006574:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8006576:	3201      	adds	r2, #1
  req_len2 = httpc_create_request_string(settings, server_name, server_port, uri, use_host,
 8006578:	0015      	movs	r5, r2
 800657a:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800657c:	6879      	ldr	r1, [r7, #4]
 800657e:	68b8      	ldr	r0, [r7, #8]
 8006580:	9502      	str	r5, [sp, #8]
 8006582:	9301      	str	r3, [sp, #4]
 8006584:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006586:	9300      	str	r3, [sp, #0]
 8006588:	0013      	movs	r3, r2
 800658a:	0022      	movs	r2, r4
 800658c:	f7ff fec2 	bl	8006314 <httpc_create_request_string>
 8006590:	0003      	movs	r3, r0
 8006592:	617b      	str	r3, [r7, #20]
  if (req_len2 != req_len) {
 8006594:	697a      	ldr	r2, [r7, #20]
 8006596:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006598:	429a      	cmp	r2, r3
 800659a:	d006      	beq.n	80065aa <httpc_init_connection_common+0x1b6>
    httpc_free_state(req);
 800659c:	69bb      	ldr	r3, [r7, #24]
 800659e:	0018      	movs	r0, r3
 80065a0:	f7ff fa98 	bl	8005ad4 <httpc_free_state>
    return ERR_VAL;
 80065a4:	2306      	movs	r3, #6
 80065a6:	425b      	negs	r3, r3
 80065a8:	e00c      	b.n	80065c4 <httpc_init_connection_common+0x1d0>
  }

  req->recv_fn = recv_fn;
 80065aa:	69bb      	ldr	r3, [r7, #24]
 80065ac:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80065ae:	61da      	str	r2, [r3, #28]
  req->conn_settings = settings;
 80065b0:	69bb      	ldr	r3, [r7, #24]
 80065b2:	68ba      	ldr	r2, [r7, #8]
 80065b4:	621a      	str	r2, [r3, #32]
  req->callback_arg = callback_arg;
 80065b6:	69bb      	ldr	r3, [r7, #24]
 80065b8:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80065ba:	625a      	str	r2, [r3, #36]	; 0x24

  *connection = req;
 80065bc:	68fb      	ldr	r3, [r7, #12]
 80065be:	69ba      	ldr	r2, [r7, #24]
 80065c0:	601a      	str	r2, [r3, #0]
  return ERR_OK;
 80065c2:	2300      	movs	r3, #0
}
 80065c4:	0018      	movs	r0, r3
 80065c6:	46bd      	mov	sp, r7
 80065c8:	b00a      	add	sp, #40	; 0x28
 80065ca:	bdb0      	pop	{r4, r5, r7, pc}
 80065cc:	0801eac8 	.word	0x0801eac8
 80065d0:	00000206 	.word	0x00000206
 80065d4:	0801ed14 	.word	0x0801ed14
 80065d8:	0801eb08 	.word	0x0801eb08
 80065dc:	0000fffe 	.word	0x0000fffe
 80065e0:	08005e81 	.word	0x08005e81
 80065e4:	08006073 	.word	0x08006073
 80065e8:	080060a9 	.word	0x080060a9
 80065ec:	080060f1 	.word	0x080060f1

080065f0 <httpc_init_connection>:
 * Initialize the connection struct
 */
static err_t
httpc_init_connection(httpc_state_t **connection, const httpc_connection_t *settings, const char* server_name,
                      u16_t server_port, const char* uri, altcp_recv_fn recv_fn, void* callback_arg)
{
 80065f0:	b590      	push	{r4, r7, lr}
 80065f2:	b089      	sub	sp, #36	; 0x24
 80065f4:	af04      	add	r7, sp, #16
 80065f6:	60f8      	str	r0, [r7, #12]
 80065f8:	60b9      	str	r1, [r7, #8]
 80065fa:	607a      	str	r2, [r7, #4]
 80065fc:	001a      	movs	r2, r3
 80065fe:	1cbb      	adds	r3, r7, #2
 8006600:	801a      	strh	r2, [r3, #0]
  return httpc_init_connection_common(connection, settings, server_name, server_port, uri, recv_fn, callback_arg, 1);
 8006602:	1cbb      	adds	r3, r7, #2
 8006604:	881c      	ldrh	r4, [r3, #0]
 8006606:	687a      	ldr	r2, [r7, #4]
 8006608:	68b9      	ldr	r1, [r7, #8]
 800660a:	68f8      	ldr	r0, [r7, #12]
 800660c:	2301      	movs	r3, #1
 800660e:	9303      	str	r3, [sp, #12]
 8006610:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006612:	9302      	str	r3, [sp, #8]
 8006614:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006616:	9301      	str	r3, [sp, #4]
 8006618:	6a3b      	ldr	r3, [r7, #32]
 800661a:	9300      	str	r3, [sp, #0]
 800661c:	0023      	movs	r3, r4
 800661e:	f7ff fee9 	bl	80063f4 <httpc_init_connection_common>
 8006622:	0003      	movs	r3, r0
}
 8006624:	0018      	movs	r0, r3
 8006626:	46bd      	mov	sp, r7
 8006628:	b005      	add	sp, #20
 800662a:	bd90      	pop	{r4, r7, pc}

0800662c <httpc_get_file_dns>:
 *         or an error code
 */
err_t
httpc_get_file_dns(const char* server_name, u16_t port, const char* uri, const httpc_connection_t *settings,
                   altcp_recv_fn recv_fn, void* callback_arg, httpc_state_t **connection)
{
 800662c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800662e:	b08b      	sub	sp, #44	; 0x2c
 8006630:	af04      	add	r7, sp, #16
 8006632:	60f8      	str	r0, [r7, #12]
 8006634:	607a      	str	r2, [r7, #4]
 8006636:	603b      	str	r3, [r7, #0]
 8006638:	230a      	movs	r3, #10
 800663a:	18fb      	adds	r3, r7, r3
 800663c:	1c0a      	adds	r2, r1, #0
 800663e:	801a      	strh	r2, [r3, #0]
  err_t err;
  httpc_state_t* req;

  LWIP_ERROR("invalid parameters", (server_name != NULL) && (uri != NULL) && (recv_fn != NULL), return ERR_ARG;);
 8006640:	68fb      	ldr	r3, [r7, #12]
 8006642:	2b00      	cmp	r3, #0
 8006644:	d005      	beq.n	8006652 <httpc_get_file_dns+0x26>
 8006646:	687b      	ldr	r3, [r7, #4]
 8006648:	2b00      	cmp	r3, #0
 800664a:	d002      	beq.n	8006652 <httpc_get_file_dns+0x26>
 800664c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800664e:	2b00      	cmp	r3, #0
 8006650:	d106      	bne.n	8006660 <httpc_get_file_dns+0x34>
 8006652:	4b2b      	ldr	r3, [pc, #172]	; (8006700 <httpc_get_file_dns+0xd4>)
 8006654:	0018      	movs	r0, r3
 8006656:	f7fc f941 	bl	80028dc <app_debug_rtt_raw>
 800665a:	2310      	movs	r3, #16
 800665c:	425b      	negs	r3, r3
 800665e:	e04a      	b.n	80066f6 <httpc_get_file_dns+0xca>

  err = httpc_init_connection(&req, settings, server_name, port, uri, recv_fn, callback_arg);
 8006660:	2617      	movs	r6, #23
 8006662:	19bc      	adds	r4, r7, r6
 8006664:	230a      	movs	r3, #10
 8006666:	18fb      	adds	r3, r7, r3
 8006668:	881d      	ldrh	r5, [r3, #0]
 800666a:	68fa      	ldr	r2, [r7, #12]
 800666c:	6839      	ldr	r1, [r7, #0]
 800666e:	2310      	movs	r3, #16
 8006670:	18f8      	adds	r0, r7, r3
 8006672:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8006674:	9302      	str	r3, [sp, #8]
 8006676:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8006678:	9301      	str	r3, [sp, #4]
 800667a:	687b      	ldr	r3, [r7, #4]
 800667c:	9300      	str	r3, [sp, #0]
 800667e:	002b      	movs	r3, r5
 8006680:	f7ff ffb6 	bl	80065f0 <httpc_init_connection>
 8006684:	0003      	movs	r3, r0
 8006686:	7023      	strb	r3, [r4, #0]
  if (err != ERR_OK) {
 8006688:	19bb      	adds	r3, r7, r6
 800668a:	781b      	ldrb	r3, [r3, #0]
 800668c:	b25b      	sxtb	r3, r3
 800668e:	2b00      	cmp	r3, #0
 8006690:	d003      	beq.n	800669a <httpc_get_file_dns+0x6e>
    return err;
 8006692:	19bb      	adds	r3, r7, r6
 8006694:	781b      	ldrb	r3, [r3, #0]
 8006696:	b25b      	sxtb	r3, r3
 8006698:	e02d      	b.n	80066f6 <httpc_get_file_dns+0xca>
  }

  if (settings->use_proxy) {
 800669a:	683b      	ldr	r3, [r7, #0]
 800669c:	799b      	ldrb	r3, [r3, #6]
 800669e:	2b00      	cmp	r3, #0
 80066a0:	d00a      	beq.n	80066b8 <httpc_get_file_dns+0x8c>
    err = httpc_get_internal_addr(req, &settings->proxy_addr);
 80066a2:	693b      	ldr	r3, [r7, #16]
 80066a4:	683a      	ldr	r2, [r7, #0]
 80066a6:	2117      	movs	r1, #23
 80066a8:	187c      	adds	r4, r7, r1
 80066aa:	0011      	movs	r1, r2
 80066ac:	0018      	movs	r0, r3
 80066ae:	f7ff fd67 	bl	8006180 <httpc_get_internal_addr>
 80066b2:	0003      	movs	r3, r0
 80066b4:	7023      	strb	r3, [r4, #0]
 80066b6:	e009      	b.n	80066cc <httpc_get_file_dns+0xa0>
  } else {
    err = httpc_get_internal_dns(req, server_name);
 80066b8:	693b      	ldr	r3, [r7, #16]
 80066ba:	2217      	movs	r2, #23
 80066bc:	18bc      	adds	r4, r7, r2
 80066be:	68fa      	ldr	r2, [r7, #12]
 80066c0:	0011      	movs	r1, r2
 80066c2:	0018      	movs	r0, r3
 80066c4:	f7ff fde2 	bl	800628c <httpc_get_internal_dns>
 80066c8:	0003      	movs	r3, r0
 80066ca:	7023      	strb	r3, [r4, #0]
  }
  if(err != ERR_OK) {
 80066cc:	2417      	movs	r4, #23
 80066ce:	193b      	adds	r3, r7, r4
 80066d0:	781b      	ldrb	r3, [r3, #0]
 80066d2:	b25b      	sxtb	r3, r3
 80066d4:	2b00      	cmp	r3, #0
 80066d6:	d007      	beq.n	80066e8 <httpc_get_file_dns+0xbc>
    httpc_free_state(req);
 80066d8:	693b      	ldr	r3, [r7, #16]
 80066da:	0018      	movs	r0, r3
 80066dc:	f7ff f9fa 	bl	8005ad4 <httpc_free_state>
    return err;
 80066e0:	193b      	adds	r3, r7, r4
 80066e2:	781b      	ldrb	r3, [r3, #0]
 80066e4:	b25b      	sxtb	r3, r3
 80066e6:	e006      	b.n	80066f6 <httpc_get_file_dns+0xca>
  }

  if (connection != NULL) {
 80066e8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80066ea:	2b00      	cmp	r3, #0
 80066ec:	d002      	beq.n	80066f4 <httpc_get_file_dns+0xc8>
    *connection = req;
 80066ee:	693a      	ldr	r2, [r7, #16]
 80066f0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80066f2:	601a      	str	r2, [r3, #0]
  }
  return ERR_OK;
 80066f4:	2300      	movs	r3, #0
}
 80066f6:	0018      	movs	r0, r3
 80066f8:	46bd      	mov	sp, r7
 80066fa:	b007      	add	sp, #28
 80066fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80066fe:	46c0      	nop			; (mov r8, r8)
 8006700:	0801ed20 	.word	0x0801ed20

08006704 <sntp_process>:
/**
 * SNTP processing of received timestamp
 */
static void
sntp_process(const struct sntp_timestamps *timestamps)
{
 8006704:	b580      	push	{r7, lr}
 8006706:	b084      	sub	sp, #16
 8006708:	af00      	add	r7, sp, #0
 800670a:	6078      	str	r0, [r7, #4]
  s32_t sec;
  u32_t frac;

  sec  = (s32_t)lwip_ntohl(timestamps->xmit.sec);
 800670c:	687b      	ldr	r3, [r7, #4]
 800670e:	681b      	ldr	r3, [r3, #0]
 8006710:	0018      	movs	r0, r3
 8006712:	f000 fa8f 	bl	8006c34 <lwip_htonl>
 8006716:	0003      	movs	r3, r0
 8006718:	60fb      	str	r3, [r7, #12]
  frac = lwip_ntohl(timestamps->xmit.frac);
 800671a:	687b      	ldr	r3, [r7, #4]
 800671c:	685b      	ldr	r3, [r3, #4]
 800671e:	0018      	movs	r0, r3
 8006720:	f000 fa88 	bl	8006c34 <lwip_htonl>
 8006724:	0003      	movs	r3, r0
 8006726:	60bb      	str	r3, [r7, #8]
      frac = (u32_t)((u64_t)t4);
    }
  }
#endif /* SNTP_COMP_ROUNDTRIP */

  SNTP_SET_SYSTEM_TIME_NTP(sec, frac);
 8006728:	68fb      	ldr	r3, [r7, #12]
 800672a:	4a05      	ldr	r2, [pc, #20]	; (8006740 <sntp_process+0x3c>)
 800672c:	4694      	mov	ip, r2
 800672e:	4463      	add	r3, ip
 8006730:	0018      	movs	r0, r3
 8006732:	f7fa fc31 	bl	8000f98 <lwip_sntp_recv_callback>
  LWIP_UNUSED_ARG(frac); /* might be unused if only seconds are set */
  LWIP_DEBUGF(SNTP_DEBUG_TRACE, ("sntp_process: %s, %" U32_F " us\n",
                                 sntp_format_time(sec), SNTP_FRAC_TO_US(frac)));
}
 8006736:	46c0      	nop			; (mov r8, r8)
 8006738:	46bd      	mov	sp, r7
 800673a:	b004      	add	sp, #16
 800673c:	bd80      	pop	{r7, pc}
 800673e:	46c0      	nop			; (mov r8, r8)
 8006740:	7c558180 	.word	0x7c558180

08006744 <sntp_initialize_request>:
/**
 * Initialize request struct to be sent to server.
 */
static void
sntp_initialize_request(struct sntp_msg *req)
{
 8006744:	b580      	push	{r7, lr}
 8006746:	b082      	sub	sp, #8
 8006748:	af00      	add	r7, sp, #0
 800674a:	6078      	str	r0, [r7, #4]
  memset(req, 0, SNTP_MSG_LEN);
 800674c:	687b      	ldr	r3, [r7, #4]
 800674e:	2230      	movs	r2, #48	; 0x30
 8006750:	2100      	movs	r1, #0
 8006752:	0018      	movs	r0, r3
 8006754:	f016 fa60 	bl	801cc18 <memset>
  req->li_vn_mode = SNTP_LI_NO_WARNING | SNTP_VERSION | SNTP_MODE_CLIENT;
 8006758:	687b      	ldr	r3, [r7, #4]
 800675a:	2223      	movs	r2, #35	; 0x23
 800675c:	701a      	strb	r2, [r3, #0]
# endif
    req->transmit_timestamp[0] = sec;
    req->transmit_timestamp[1] = frac;
  }
#endif /* SNTP_CHECK_RESPONSE >= 2 || SNTP_COMP_ROUNDTRIP */
}
 800675e:	46c0      	nop			; (mov r8, r8)
 8006760:	46bd      	mov	sp, r7
 8006762:	b002      	add	sp, #8
 8006764:	bd80      	pop	{r7, pc}
	...

08006768 <sntp_retry>:
 *
 * @param arg is unused (only necessary to conform to sys_timeout)
 */
static void
sntp_retry(void *arg)
{
 8006768:	b580      	push	{r7, lr}
 800676a:	b084      	sub	sp, #16
 800676c:	af00      	add	r7, sp, #0
 800676e:	6078      	str	r0, [r7, #4]

  LWIP_DEBUGF(SNTP_DEBUG_STATE, ("sntp_retry: Next request will be sent in %"U32_F" ms\n",
                                 sntp_retry_timeout));

  /* set up a timer to send a retry and increase the retry delay */
  sys_untimeout(sntp_request, NULL);
 8006770:	4b12      	ldr	r3, [pc, #72]	; (80067bc <sntp_retry+0x54>)
 8006772:	2100      	movs	r1, #0
 8006774:	0018      	movs	r0, r3
 8006776:	f00b fcc7 	bl	8012108 <sys_untimeout>
  sys_timeout(sntp_retry_timeout, sntp_request, NULL);
 800677a:	4b11      	ldr	r3, [pc, #68]	; (80067c0 <sntp_retry+0x58>)
 800677c:	681b      	ldr	r3, [r3, #0]
 800677e:	490f      	ldr	r1, [pc, #60]	; (80067bc <sntp_retry+0x54>)
 8006780:	2200      	movs	r2, #0
 8006782:	0018      	movs	r0, r3
 8006784:	f00b fc98 	bl	80120b8 <sys_timeout>

#if SNTP_RETRY_TIMEOUT_EXP
  {
    u32_t new_retry_timeout;
    /* increase the timeout for next retry */
    new_retry_timeout = sntp_retry_timeout << 1;
 8006788:	4b0d      	ldr	r3, [pc, #52]	; (80067c0 <sntp_retry+0x58>)
 800678a:	681b      	ldr	r3, [r3, #0]
 800678c:	005b      	lsls	r3, r3, #1
 800678e:	60fb      	str	r3, [r7, #12]
    /* limit to maximum timeout and prevent overflow */
    if ((new_retry_timeout <= SNTP_RETRY_TIMEOUT_MAX) &&
 8006790:	68fb      	ldr	r3, [r7, #12]
 8006792:	4a0c      	ldr	r2, [pc, #48]	; (80067c4 <sntp_retry+0x5c>)
 8006794:	4293      	cmp	r3, r2
 8006796:	d808      	bhi.n	80067aa <sntp_retry+0x42>
        (new_retry_timeout > sntp_retry_timeout)) {
 8006798:	4b09      	ldr	r3, [pc, #36]	; (80067c0 <sntp_retry+0x58>)
 800679a:	681b      	ldr	r3, [r3, #0]
    if ((new_retry_timeout <= SNTP_RETRY_TIMEOUT_MAX) &&
 800679c:	68fa      	ldr	r2, [r7, #12]
 800679e:	429a      	cmp	r2, r3
 80067a0:	d903      	bls.n	80067aa <sntp_retry+0x42>
      sntp_retry_timeout = new_retry_timeout;
 80067a2:	4b07      	ldr	r3, [pc, #28]	; (80067c0 <sntp_retry+0x58>)
 80067a4:	68fa      	ldr	r2, [r7, #12]
 80067a6:	601a      	str	r2, [r3, #0]
 80067a8:	e003      	b.n	80067b2 <sntp_retry+0x4a>
    } else {
      sntp_retry_timeout = SNTP_RETRY_TIMEOUT_MAX;
 80067aa:	4b05      	ldr	r3, [pc, #20]	; (80067c0 <sntp_retry+0x58>)
 80067ac:	4a05      	ldr	r2, [pc, #20]	; (80067c4 <sntp_retry+0x5c>)
 80067ae:	601a      	str	r2, [r3, #0]
    }
  }
#endif /* SNTP_RETRY_TIMEOUT_EXP */
}
 80067b0:	46c0      	nop			; (mov r8, r8)
 80067b2:	46c0      	nop			; (mov r8, r8)
 80067b4:	46bd      	mov	sp, r7
 80067b6:	b004      	add	sp, #16
 80067b8:	bd80      	pop	{r7, pc}
 80067ba:	46c0      	nop			; (mov r8, r8)
 80067bc:	080069f9 	.word	0x080069f9
 80067c0:	20001910 	.word	0x20001910
 80067c4:	000249f0 	.word	0x000249f0

080067c8 <sntp_recv>:
#endif /* SNTP_SUPPORT_MULTIPLE_SERVERS */

/** UDP recv callback for the sntp pcb */
static void
sntp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr, u16_t port)
{
 80067c8:	b5b0      	push	{r4, r5, r7, lr}
 80067ca:	b088      	sub	sp, #32
 80067cc:	af00      	add	r7, sp, #0
 80067ce:	60f8      	str	r0, [r7, #12]
 80067d0:	60b9      	str	r1, [r7, #8]
 80067d2:	607a      	str	r2, [r7, #4]
 80067d4:	603b      	str	r3, [r7, #0]
  err_t err;

  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);

  err = ERR_ARG;
 80067d6:	231f      	movs	r3, #31
 80067d8:	18fb      	adds	r3, r7, r3
 80067da:	22f0      	movs	r2, #240	; 0xf0
 80067dc:	701a      	strb	r2, [r3, #0]
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
#endif /* SNTP_CHECK_RESPONSE >= 1 */
  {
    /* process the response */
    if (p->tot_len == SNTP_MSG_LEN) {
 80067de:	687b      	ldr	r3, [r7, #4]
 80067e0:	891b      	ldrh	r3, [r3, #8]
 80067e2:	2b30      	cmp	r3, #48	; 0x30
 80067e4:	d13e      	bne.n	8006864 <sntp_recv+0x9c>
      mode = pbuf_get_at(p, SNTP_OFFSET_LI_VN_MODE) & SNTP_MODE_MASK;
 80067e6:	687b      	ldr	r3, [r7, #4]
 80067e8:	2100      	movs	r1, #0
 80067ea:	0018      	movs	r0, r3
 80067ec:	f003 ff0a 	bl	800a604 <pbuf_get_at>
 80067f0:	0003      	movs	r3, r0
 80067f2:	0019      	movs	r1, r3
 80067f4:	201e      	movs	r0, #30
 80067f6:	183b      	adds	r3, r7, r0
 80067f8:	2207      	movs	r2, #7
 80067fa:	400a      	ands	r2, r1
 80067fc:	701a      	strb	r2, [r3, #0]
      /* if this is a SNTP response... */
      if (((sntp_opmode == SNTP_OPMODE_POLL)       && (mode == SNTP_MODE_SERVER)) ||
 80067fe:	4b3a      	ldr	r3, [pc, #232]	; (80068e8 <sntp_recv+0x120>)
 8006800:	781b      	ldrb	r3, [r3, #0]
 8006802:	2b00      	cmp	r3, #0
 8006804:	d103      	bne.n	800680e <sntp_recv+0x46>
 8006806:	183b      	adds	r3, r7, r0
 8006808:	781b      	ldrb	r3, [r3, #0]
 800680a:	2b04      	cmp	r3, #4
 800680c:	d008      	beq.n	8006820 <sntp_recv+0x58>
          ((sntp_opmode == SNTP_OPMODE_LISTENONLY) && (mode == SNTP_MODE_BROADCAST))) {
 800680e:	4b36      	ldr	r3, [pc, #216]	; (80068e8 <sntp_recv+0x120>)
 8006810:	781b      	ldrb	r3, [r3, #0]
      if (((sntp_opmode == SNTP_OPMODE_POLL)       && (mode == SNTP_MODE_SERVER)) ||
 8006812:	2b01      	cmp	r3, #1
 8006814:	d122      	bne.n	800685c <sntp_recv+0x94>
          ((sntp_opmode == SNTP_OPMODE_LISTENONLY) && (mode == SNTP_MODE_BROADCAST))) {
 8006816:	231e      	movs	r3, #30
 8006818:	18fb      	adds	r3, r7, r3
 800681a:	781b      	ldrb	r3, [r3, #0]
 800681c:	2b05      	cmp	r3, #5
 800681e:	d11d      	bne.n	800685c <sntp_recv+0x94>
        stratum = pbuf_get_at(p, SNTP_OFFSET_STRATUM);
 8006820:	251d      	movs	r5, #29
 8006822:	197c      	adds	r4, r7, r5
 8006824:	687b      	ldr	r3, [r7, #4]
 8006826:	2101      	movs	r1, #1
 8006828:	0018      	movs	r0, r3
 800682a:	f003 feeb 	bl	800a604 <pbuf_get_at>
 800682e:	0003      	movs	r3, r0
 8006830:	7023      	strb	r3, [r4, #0]

        if (stratum == SNTP_STRATUM_KOD) {
 8006832:	197b      	adds	r3, r7, r5
 8006834:	781b      	ldrb	r3, [r3, #0]
 8006836:	2b00      	cmp	r3, #0
 8006838:	d104      	bne.n	8006844 <sntp_recv+0x7c>
          /* Kiss-of-death packet. Use another server or increase UPDATE_DELAY. */
          err = SNTP_ERR_KOD;
 800683a:	231f      	movs	r3, #31
 800683c:	18fb      	adds	r3, r7, r3
 800683e:	2201      	movs	r2, #1
 8006840:	701a      	strb	r2, [r3, #0]
        if (stratum == SNTP_STRATUM_KOD) {
 8006842:	e00f      	b.n	8006864 <sntp_recv+0x9c>
          LWIP_DEBUGF(SNTP_DEBUG_STATE, ("sntp_recv: Received Kiss-of-Death\n"));
        } else {
          pbuf_copy_partial(p, &timestamps, sizeof(timestamps), SNTP_OFFSET_TIMESTAMPS);
 8006844:	2310      	movs	r3, #16
 8006846:	18f9      	adds	r1, r7, r3
 8006848:	6878      	ldr	r0, [r7, #4]
 800684a:	2328      	movs	r3, #40	; 0x28
 800684c:	2208      	movs	r2, #8
 800684e:	f003 fc89 	bl	800a164 <pbuf_copy_partial>
          } else
#endif /* SNTP_CHECK_RESPONSE >= 2 */
            /* @todo: add code for SNTP_CHECK_RESPONSE >= 3 and >= 4 here */
          {
            /* correct answer */
            err = ERR_OK;
 8006852:	231f      	movs	r3, #31
 8006854:	18fb      	adds	r3, r7, r3
 8006856:	2200      	movs	r2, #0
 8006858:	701a      	strb	r2, [r3, #0]
        if (stratum == SNTP_STRATUM_KOD) {
 800685a:	e003      	b.n	8006864 <sntp_recv+0x9c>
          }
        }
      } else {
        LWIP_DEBUGF(SNTP_DEBUG_WARN, ("sntp_recv: Invalid mode in response: %"U16_F"\n", (u16_t)mode));
        /* wait for correct response */
        err = ERR_TIMEOUT;
 800685c:	231f      	movs	r3, #31
 800685e:	18fb      	adds	r3, r7, r3
 8006860:	22fd      	movs	r2, #253	; 0xfd
 8006862:	701a      	strb	r2, [r3, #0]
    /* packet from wrong remote address or port, wait for correct response */
    err = ERR_TIMEOUT;
  }
#endif /* SNTP_CHECK_RESPONSE >= 1 */

  pbuf_free(p);
 8006864:	687b      	ldr	r3, [r7, #4]
 8006866:	0018      	movs	r0, r3
 8006868:	f003 f9b2 	bl	8009bd0 <pbuf_free>

  if (err == ERR_OK) {
 800686c:	231f      	movs	r3, #31
 800686e:	18fb      	adds	r3, r7, r3
 8006870:	781b      	ldrb	r3, [r3, #0]
 8006872:	b25b      	sxtb	r3, r3
 8006874:	2b00      	cmp	r3, #0
 8006876:	d125      	bne.n	80068c4 <sntp_recv+0xfc>
    /* correct packet received: process it it */
    sntp_process(&timestamps);
 8006878:	2310      	movs	r3, #16
 800687a:	18fb      	adds	r3, r7, r3
 800687c:	0018      	movs	r0, r3
 800687e:	f7ff ff41 	bl	8006704 <sntp_process>

#if SNTP_MONITOR_SERVER_REACHABILITY
    /* indicate that server responded */
    sntp_servers[sntp_current_server].reachability |= 1;
 8006882:	4b1a      	ldr	r3, [pc, #104]	; (80068ec <sntp_recv+0x124>)
 8006884:	7a1b      	ldrb	r3, [r3, #8]
 8006886:	2201      	movs	r2, #1
 8006888:	4313      	orrs	r3, r2
 800688a:	b2da      	uxtb	r2, r3
 800688c:	4b17      	ldr	r3, [pc, #92]	; (80068ec <sntp_recv+0x124>)
 800688e:	721a      	strb	r2, [r3, #8]
#endif /* SNTP_MONITOR_SERVER_REACHABILITY */
    /* Set up timeout for next request (only if poll response was received)*/
    if (sntp_opmode == SNTP_OPMODE_POLL) {
 8006890:	4b15      	ldr	r3, [pc, #84]	; (80068e8 <sntp_recv+0x120>)
 8006892:	781b      	ldrb	r3, [r3, #0]
 8006894:	2b00      	cmp	r3, #0
 8006896:	d122      	bne.n	80068de <sntp_recv+0x116>
      u32_t sntp_update_delay;
      sys_untimeout(sntp_try_next_server, NULL);
 8006898:	4b15      	ldr	r3, [pc, #84]	; (80068f0 <sntp_recv+0x128>)
 800689a:	2100      	movs	r1, #0
 800689c:	0018      	movs	r0, r3
 800689e:	f00b fc33 	bl	8012108 <sys_untimeout>
      sys_untimeout(sntp_request, NULL);
 80068a2:	4b14      	ldr	r3, [pc, #80]	; (80068f4 <sntp_recv+0x12c>)
 80068a4:	2100      	movs	r1, #0
 80068a6:	0018      	movs	r0, r3
 80068a8:	f00b fc2e 	bl	8012108 <sys_untimeout>

      /* Correct response, reset retry timeout */
      SNTP_RESET_RETRY_TIMEOUT();
 80068ac:	4b12      	ldr	r3, [pc, #72]	; (80068f8 <sntp_recv+0x130>)
 80068ae:	4a13      	ldr	r2, [pc, #76]	; (80068fc <sntp_recv+0x134>)
 80068b0:	601a      	str	r2, [r3, #0]

      sntp_update_delay = (u32_t)SNTP_UPDATE_DELAY;
 80068b2:	4b13      	ldr	r3, [pc, #76]	; (8006900 <sntp_recv+0x138>)
 80068b4:	61bb      	str	r3, [r7, #24]
      sys_timeout(sntp_update_delay, sntp_request, NULL);
 80068b6:	490f      	ldr	r1, [pc, #60]	; (80068f4 <sntp_recv+0x12c>)
 80068b8:	69bb      	ldr	r3, [r7, #24]
 80068ba:	2200      	movs	r2, #0
 80068bc:	0018      	movs	r0, r3
 80068be:	f00b fbfb 	bl	80120b8 <sys_timeout>
      sntp_try_next_server(NULL);
    }
  } else {
    /* ignore any broken packet, poll mode: retry after timeout to avoid flooding */
  }
}
 80068c2:	e00c      	b.n	80068de <sntp_recv+0x116>
  } else if (err == SNTP_ERR_KOD) {
 80068c4:	231f      	movs	r3, #31
 80068c6:	18fb      	adds	r3, r7, r3
 80068c8:	781b      	ldrb	r3, [r3, #0]
 80068ca:	b25b      	sxtb	r3, r3
 80068cc:	2b01      	cmp	r3, #1
 80068ce:	d106      	bne.n	80068de <sntp_recv+0x116>
    if (sntp_opmode == SNTP_OPMODE_POLL) {
 80068d0:	4b05      	ldr	r3, [pc, #20]	; (80068e8 <sntp_recv+0x120>)
 80068d2:	781b      	ldrb	r3, [r3, #0]
 80068d4:	2b00      	cmp	r3, #0
 80068d6:	d102      	bne.n	80068de <sntp_recv+0x116>
      sntp_try_next_server(NULL);
 80068d8:	2000      	movs	r0, #0
 80068da:	f7ff ff45 	bl	8006768 <sntp_retry>
}
 80068de:	46c0      	nop			; (mov r8, r8)
 80068e0:	46bd      	mov	sp, r7
 80068e2:	b008      	add	sp, #32
 80068e4:	bdb0      	pop	{r4, r5, r7, pc}
 80068e6:	46c0      	nop			; (mov r8, r8)
 80068e8:	200018fd 	.word	0x200018fd
 80068ec:	20001904 	.word	0x20001904
 80068f0:	08006769 	.word	0x08006769
 80068f4:	080069f9 	.word	0x080069f9
 80068f8:	20001910 	.word	0x20001910
 80068fc:	00003a98 	.word	0x00003a98
 8006900:	0036ee80 	.word	0x0036ee80

08006904 <sntp_send_request>:
 *
 * @param server_addr resolved IP address of the SNTP server
 */
static void
sntp_send_request(const ip_addr_t *server_addr)
{
 8006904:	b580      	push	{r7, lr}
 8006906:	b084      	sub	sp, #16
 8006908:	af00      	add	r7, sp, #0
 800690a:	6078      	str	r0, [r7, #4]
  struct pbuf *p;

  LWIP_ASSERT("server_addr != NULL", server_addr != NULL);
 800690c:	687b      	ldr	r3, [r7, #4]
 800690e:	2b00      	cmp	r3, #0
 8006910:	d105      	bne.n	800691e <sntp_send_request+0x1a>
 8006912:	4b22      	ldr	r3, [pc, #136]	; (800699c <sntp_send_request+0x98>)
 8006914:	4a22      	ldr	r2, [pc, #136]	; (80069a0 <sntp_send_request+0x9c>)
 8006916:	4923      	ldr	r1, [pc, #140]	; (80069a4 <sntp_send_request+0xa0>)
 8006918:	4823      	ldr	r0, [pc, #140]	; (80069a8 <sntp_send_request+0xa4>)
 800691a:	f7fb ffdf 	bl	80028dc <app_debug_rtt_raw>

  p = pbuf_alloc(PBUF_TRANSPORT, SNTP_MSG_LEN, PBUF_RAM);
 800691e:	23a0      	movs	r3, #160	; 0xa0
 8006920:	009b      	lsls	r3, r3, #2
 8006922:	001a      	movs	r2, r3
 8006924:	2130      	movs	r1, #48	; 0x30
 8006926:	2038      	movs	r0, #56	; 0x38
 8006928:	f002 fdda 	bl	80094e0 <pbuf_alloc>
 800692c:	0003      	movs	r3, r0
 800692e:	60fb      	str	r3, [r7, #12]
  if (p != NULL) {
 8006930:	68fb      	ldr	r3, [r7, #12]
 8006932:	2b00      	cmp	r3, #0
 8006934:	d023      	beq.n	800697e <sntp_send_request+0x7a>
    struct sntp_msg *sntpmsg = (struct sntp_msg *)p->payload;
 8006936:	68fb      	ldr	r3, [r7, #12]
 8006938:	685b      	ldr	r3, [r3, #4]
 800693a:	60bb      	str	r3, [r7, #8]
    LWIP_DEBUGF(SNTP_DEBUG_STATE, ("sntp_send_request: Sending request to server\n"));
    /* initialize request message */
    sntp_initialize_request(sntpmsg);
 800693c:	68bb      	ldr	r3, [r7, #8]
 800693e:	0018      	movs	r0, r3
 8006940:	f7ff ff00 	bl	8006744 <sntp_initialize_request>
    /* send request */
    udp_sendto(sntp_pcb, p, server_addr, SNTP_PORT);
 8006944:	4b19      	ldr	r3, [pc, #100]	; (80069ac <sntp_send_request+0xa8>)
 8006946:	6818      	ldr	r0, [r3, #0]
 8006948:	687a      	ldr	r2, [r7, #4]
 800694a:	68f9      	ldr	r1, [r7, #12]
 800694c:	237b      	movs	r3, #123	; 0x7b
 800694e:	f00b fe5d 	bl	801260c <udp_sendto>
    /* free the pbuf after sending it */
    pbuf_free(p);
 8006952:	68fb      	ldr	r3, [r7, #12]
 8006954:	0018      	movs	r0, r3
 8006956:	f003 f93b 	bl	8009bd0 <pbuf_free>
#if SNTP_MONITOR_SERVER_REACHABILITY
    /* indicate new packet has been sent */
    sntp_servers[sntp_current_server].reachability <<= 1;
 800695a:	4b15      	ldr	r3, [pc, #84]	; (80069b0 <sntp_send_request+0xac>)
 800695c:	7a1b      	ldrb	r3, [r3, #8]
 800695e:	18db      	adds	r3, r3, r3
 8006960:	b2da      	uxtb	r2, r3
 8006962:	4b13      	ldr	r3, [pc, #76]	; (80069b0 <sntp_send_request+0xac>)
 8006964:	721a      	strb	r2, [r3, #8]
#endif /* SNTP_MONITOR_SERVER_REACHABILITY */
    /* set up receive timeout: try next server or retry on timeout */
    sys_untimeout(sntp_try_next_server, NULL);
 8006966:	4b13      	ldr	r3, [pc, #76]	; (80069b4 <sntp_send_request+0xb0>)
 8006968:	2100      	movs	r1, #0
 800696a:	0018      	movs	r0, r3
 800696c:	f00b fbcc 	bl	8012108 <sys_untimeout>
    sys_timeout((u32_t)SNTP_RECV_TIMEOUT, sntp_try_next_server, NULL);
 8006970:	4b10      	ldr	r3, [pc, #64]	; (80069b4 <sntp_send_request+0xb0>)
 8006972:	4811      	ldr	r0, [pc, #68]	; (80069b8 <sntp_send_request+0xb4>)
 8006974:	2200      	movs	r2, #0
 8006976:	0019      	movs	r1, r3
 8006978:	f00b fb9e 	bl	80120b8 <sys_timeout>
                                     (u32_t)SNTP_RETRY_TIMEOUT));
    /* out of memory: set up a timer to send a retry */
    sys_untimeout(sntp_request, NULL);
    sys_timeout((u32_t)SNTP_RETRY_TIMEOUT, sntp_request, NULL);
  }
}
 800697c:	e00a      	b.n	8006994 <sntp_send_request+0x90>
    sys_untimeout(sntp_request, NULL);
 800697e:	4b0f      	ldr	r3, [pc, #60]	; (80069bc <sntp_send_request+0xb8>)
 8006980:	2100      	movs	r1, #0
 8006982:	0018      	movs	r0, r3
 8006984:	f00b fbc0 	bl	8012108 <sys_untimeout>
    sys_timeout((u32_t)SNTP_RETRY_TIMEOUT, sntp_request, NULL);
 8006988:	4b0c      	ldr	r3, [pc, #48]	; (80069bc <sntp_send_request+0xb8>)
 800698a:	480b      	ldr	r0, [pc, #44]	; (80069b8 <sntp_send_request+0xb4>)
 800698c:	2200      	movs	r2, #0
 800698e:	0019      	movs	r1, r3
 8006990:	f00b fb92 	bl	80120b8 <sys_timeout>
}
 8006994:	46c0      	nop			; (mov r8, r8)
 8006996:	46bd      	mov	sp, r7
 8006998:	b004      	add	sp, #16
 800699a:	bd80      	pop	{r7, pc}
 800699c:	0801ed34 	.word	0x0801ed34
 80069a0:	00000223 	.word	0x00000223
 80069a4:	0801ed60 	.word	0x0801ed60
 80069a8:	0801ed74 	.word	0x0801ed74
 80069ac:	20001900 	.word	0x20001900
 80069b0:	20001904 	.word	0x20001904
 80069b4:	08006769 	.word	0x08006769
 80069b8:	00003a98 	.word	0x00003a98
 80069bc:	080069f9 	.word	0x080069f9

080069c0 <sntp_dns_found>:
/**
 * DNS found callback when using DNS names as server address.
 */
static void
sntp_dns_found(const char *hostname, const ip_addr_t *ipaddr, void *arg)
{
 80069c0:	b580      	push	{r7, lr}
 80069c2:	b084      	sub	sp, #16
 80069c4:	af00      	add	r7, sp, #0
 80069c6:	60f8      	str	r0, [r7, #12]
 80069c8:	60b9      	str	r1, [r7, #8]
 80069ca:	607a      	str	r2, [r7, #4]
  LWIP_UNUSED_ARG(hostname);
  LWIP_UNUSED_ARG(arg);

  if (ipaddr != NULL) {
 80069cc:	68bb      	ldr	r3, [r7, #8]
 80069ce:	2b00      	cmp	r3, #0
 80069d0:	d008      	beq.n	80069e4 <sntp_dns_found+0x24>
    /* Address resolved, send request */
    LWIP_DEBUGF(SNTP_DEBUG_STATE, ("sntp_dns_found: Server address resolved, sending request\n"));
    sntp_servers[sntp_current_server].addr = *ipaddr;
 80069d2:	4b08      	ldr	r3, [pc, #32]	; (80069f4 <sntp_dns_found+0x34>)
 80069d4:	68ba      	ldr	r2, [r7, #8]
 80069d6:	6812      	ldr	r2, [r2, #0]
 80069d8:	605a      	str	r2, [r3, #4]
    sntp_send_request(ipaddr);
 80069da:	68bb      	ldr	r3, [r7, #8]
 80069dc:	0018      	movs	r0, r3
 80069de:	f7ff ff91 	bl	8006904 <sntp_send_request>
  } else {
    /* DNS resolving failed -> try another server */
    LWIP_DEBUGF(SNTP_DEBUG_WARN_STATE, ("sntp_dns_found: Failed to resolve server address resolved, trying next server\n"));
    sntp_try_next_server(NULL);
  }
}
 80069e2:	e002      	b.n	80069ea <sntp_dns_found+0x2a>
    sntp_try_next_server(NULL);
 80069e4:	2000      	movs	r0, #0
 80069e6:	f7ff febf 	bl	8006768 <sntp_retry>
}
 80069ea:	46c0      	nop			; (mov r8, r8)
 80069ec:	46bd      	mov	sp, r7
 80069ee:	b004      	add	sp, #16
 80069f0:	bd80      	pop	{r7, pc}
 80069f2:	46c0      	nop			; (mov r8, r8)
 80069f4:	20001904 	.word	0x20001904

080069f8 <sntp_request>:
 *
 * @param arg is unused (only necessary to conform to sys_timeout)
 */
static void
sntp_request(void *arg)
{
 80069f8:	b5b0      	push	{r4, r5, r7, lr}
 80069fa:	b084      	sub	sp, #16
 80069fc:	af00      	add	r7, sp, #0
 80069fe:	6078      	str	r0, [r7, #4]

  LWIP_UNUSED_ARG(arg);

  /* initialize SNTP server address */
#if SNTP_SERVER_DNS
  if (sntp_servers[sntp_current_server].name) {
 8006a00:	4b24      	ldr	r3, [pc, #144]	; (8006a94 <sntp_request+0x9c>)
 8006a02:	681b      	ldr	r3, [r3, #0]
 8006a04:	2b00      	cmp	r3, #0
 8006a06:	d01c      	beq.n	8006a42 <sntp_request+0x4a>
    /* always resolve the name and rely on dns-internal caching & timeout */
    ip_addr_set_zero(&sntp_servers[sntp_current_server].addr);
 8006a08:	4b22      	ldr	r3, [pc, #136]	; (8006a94 <sntp_request+0x9c>)
 8006a0a:	2200      	movs	r2, #0
 8006a0c:	605a      	str	r2, [r3, #4]
    err = dns_gethostbyname(sntp_servers[sntp_current_server].name, &sntp_server_address,
 8006a0e:	4b21      	ldr	r3, [pc, #132]	; (8006a94 <sntp_request+0x9c>)
 8006a10:	6818      	ldr	r0, [r3, #0]
 8006a12:	250f      	movs	r5, #15
 8006a14:	197c      	adds	r4, r7, r5
 8006a16:	4a20      	ldr	r2, [pc, #128]	; (8006a98 <sntp_request+0xa0>)
 8006a18:	2308      	movs	r3, #8
 8006a1a:	18f9      	adds	r1, r7, r3
 8006a1c:	2300      	movs	r3, #0
 8006a1e:	f001 f9f9 	bl	8007e14 <dns_gethostbyname>
 8006a22:	0003      	movs	r3, r0
 8006a24:	7023      	strb	r3, [r4, #0]
                            sntp_dns_found, NULL);
    if (err == ERR_INPROGRESS) {
 8006a26:	197b      	adds	r3, r7, r5
 8006a28:	781b      	ldrb	r3, [r3, #0]
 8006a2a:	b25b      	sxtb	r3, r3
 8006a2c:	3305      	adds	r3, #5
 8006a2e:	d02d      	beq.n	8006a8c <sntp_request+0x94>
      /* DNS request sent, wait for sntp_dns_found being called */
      LWIP_DEBUGF(SNTP_DEBUG_STATE, ("sntp_request: Waiting for server address to be resolved.\n"));
      return;
    } else if (err == ERR_OK) {
 8006a30:	197b      	adds	r3, r7, r5
 8006a32:	781b      	ldrb	r3, [r3, #0]
 8006a34:	b25b      	sxtb	r3, r3
 8006a36:	2b00      	cmp	r3, #0
 8006a38:	d110      	bne.n	8006a5c <sntp_request+0x64>
      sntp_servers[sntp_current_server].addr = sntp_server_address;
 8006a3a:	4b16      	ldr	r3, [pc, #88]	; (8006a94 <sntp_request+0x9c>)
 8006a3c:	68ba      	ldr	r2, [r7, #8]
 8006a3e:	605a      	str	r2, [r3, #4]
 8006a40:	e00c      	b.n	8006a5c <sntp_request+0x64>
    }
  } else
#endif /* SNTP_SERVER_DNS */
  {
    sntp_server_address = sntp_servers[sntp_current_server].addr;
 8006a42:	4b14      	ldr	r3, [pc, #80]	; (8006a94 <sntp_request+0x9c>)
 8006a44:	685b      	ldr	r3, [r3, #4]
 8006a46:	60bb      	str	r3, [r7, #8]
    err = (ip_addr_isany_val(sntp_server_address)) ? ERR_ARG : ERR_OK;
 8006a48:	68bb      	ldr	r3, [r7, #8]
 8006a4a:	2b00      	cmp	r3, #0
 8006a4c:	d102      	bne.n	8006a54 <sntp_request+0x5c>
 8006a4e:	2310      	movs	r3, #16
 8006a50:	425a      	negs	r2, r3
 8006a52:	e000      	b.n	8006a56 <sntp_request+0x5e>
 8006a54:	2200      	movs	r2, #0
 8006a56:	230f      	movs	r3, #15
 8006a58:	18fb      	adds	r3, r7, r3
 8006a5a:	701a      	strb	r2, [r3, #0]
  }

  if (err == ERR_OK) {
 8006a5c:	230f      	movs	r3, #15
 8006a5e:	18fb      	adds	r3, r7, r3
 8006a60:	781b      	ldrb	r3, [r3, #0]
 8006a62:	b25b      	sxtb	r3, r3
 8006a64:	2b00      	cmp	r3, #0
 8006a66:	d105      	bne.n	8006a74 <sntp_request+0x7c>
    LWIP_DEBUGF(SNTP_DEBUG_TRACE, ("sntp_request: current server address is %s\n",
                                   ipaddr_ntoa(&sntp_server_address)));
    sntp_send_request(&sntp_server_address);
 8006a68:	2308      	movs	r3, #8
 8006a6a:	18fb      	adds	r3, r7, r3
 8006a6c:	0018      	movs	r0, r3
 8006a6e:	f7ff ff49 	bl	8006904 <sntp_send_request>
 8006a72:	e00c      	b.n	8006a8e <sntp_request+0x96>
  } else {
    /* address conversion failed, try another server */
    LWIP_DEBUGF(SNTP_DEBUG_WARN_STATE, ("sntp_request: Invalid server address, trying next server.\n"));
    sys_untimeout(sntp_try_next_server, NULL);
 8006a74:	4b09      	ldr	r3, [pc, #36]	; (8006a9c <sntp_request+0xa4>)
 8006a76:	2100      	movs	r1, #0
 8006a78:	0018      	movs	r0, r3
 8006a7a:	f00b fb45 	bl	8012108 <sys_untimeout>
    sys_timeout((u32_t)SNTP_RETRY_TIMEOUT, sntp_try_next_server, NULL);
 8006a7e:	4b07      	ldr	r3, [pc, #28]	; (8006a9c <sntp_request+0xa4>)
 8006a80:	4807      	ldr	r0, [pc, #28]	; (8006aa0 <sntp_request+0xa8>)
 8006a82:	2200      	movs	r2, #0
 8006a84:	0019      	movs	r1, r3
 8006a86:	f00b fb17 	bl	80120b8 <sys_timeout>
 8006a8a:	e000      	b.n	8006a8e <sntp_request+0x96>
      return;
 8006a8c:	46c0      	nop			; (mov r8, r8)
  }
}
 8006a8e:	46bd      	mov	sp, r7
 8006a90:	b004      	add	sp, #16
 8006a92:	bdb0      	pop	{r4, r5, r7, pc}
 8006a94:	20001904 	.word	0x20001904
 8006a98:	080069c1 	.word	0x080069c1
 8006a9c:	08006769 	.word	0x08006769
 8006aa0:	00003a98 	.word	0x00003a98

08006aa4 <sntp_init>:
 * Initialize this module.
 * Send out request instantly or after SNTP_STARTUP_DELAY(_FUNC).
 */
void
sntp_init(void)
{
 8006aa4:	b580      	push	{r7, lr}
 8006aa6:	af00      	add	r7, sp, #0
#else
#error SNTP_SERVER_ADDRESS string not supported SNTP_SERVER_DNS==0
#endif
#endif /* SNTP_SERVER_ADDRESS */

  if (sntp_pcb == NULL) {
 8006aa8:	4b25      	ldr	r3, [pc, #148]	; (8006b40 <sntp_init+0x9c>)
 8006aaa:	681b      	ldr	r3, [r3, #0]
 8006aac:	2b00      	cmp	r3, #0
 8006aae:	d144      	bne.n	8006b3a <sntp_init+0x96>
    sntp_pcb = udp_new_ip_type(IPADDR_TYPE_ANY);
 8006ab0:	202e      	movs	r0, #46	; 0x2e
 8006ab2:	f00c f922 	bl	8012cfa <udp_new_ip_type>
 8006ab6:	0002      	movs	r2, r0
 8006ab8:	4b21      	ldr	r3, [pc, #132]	; (8006b40 <sntp_init+0x9c>)
 8006aba:	601a      	str	r2, [r3, #0]
    LWIP_ASSERT("Failed to allocate udp pcb for sntp client", sntp_pcb != NULL);
 8006abc:	4b20      	ldr	r3, [pc, #128]	; (8006b40 <sntp_init+0x9c>)
 8006abe:	681b      	ldr	r3, [r3, #0]
 8006ac0:	2b00      	cmp	r3, #0
 8006ac2:	d105      	bne.n	8006ad0 <sntp_init+0x2c>
 8006ac4:	4b1f      	ldr	r3, [pc, #124]	; (8006b44 <sntp_init+0xa0>)
 8006ac6:	4a20      	ldr	r2, [pc, #128]	; (8006b48 <sntp_init+0xa4>)
 8006ac8:	4920      	ldr	r1, [pc, #128]	; (8006b4c <sntp_init+0xa8>)
 8006aca:	4821      	ldr	r0, [pc, #132]	; (8006b50 <sntp_init+0xac>)
 8006acc:	f7fb ff06 	bl	80028dc <app_debug_rtt_raw>
    if (sntp_pcb != NULL) {
 8006ad0:	4b1b      	ldr	r3, [pc, #108]	; (8006b40 <sntp_init+0x9c>)
 8006ad2:	681b      	ldr	r3, [r3, #0]
 8006ad4:	2b00      	cmp	r3, #0
 8006ad6:	d030      	beq.n	8006b3a <sntp_init+0x96>
      udp_recv(sntp_pcb, sntp_recv, NULL);
 8006ad8:	4b19      	ldr	r3, [pc, #100]	; (8006b40 <sntp_init+0x9c>)
 8006ada:	681b      	ldr	r3, [r3, #0]
 8006adc:	491d      	ldr	r1, [pc, #116]	; (8006b54 <sntp_init+0xb0>)
 8006ade:	2200      	movs	r2, #0
 8006ae0:	0018      	movs	r0, r3
 8006ae2:	f00c f89b 	bl	8012c1c <udp_recv>

      if (sntp_opmode == SNTP_OPMODE_POLL) {
 8006ae6:	4b1c      	ldr	r3, [pc, #112]	; (8006b58 <sntp_init+0xb4>)
 8006ae8:	781b      	ldrb	r3, [r3, #0]
 8006aea:	2b00      	cmp	r3, #0
 8006aec:	d111      	bne.n	8006b12 <sntp_init+0x6e>
        SNTP_RESET_RETRY_TIMEOUT();
 8006aee:	4b1b      	ldr	r3, [pc, #108]	; (8006b5c <sntp_init+0xb8>)
 8006af0:	4a1b      	ldr	r2, [pc, #108]	; (8006b60 <sntp_init+0xbc>)
 8006af2:	601a      	str	r2, [r3, #0]
#if SNTP_STARTUP_DELAY
        sys_timeout((u32_t)SNTP_STARTUP_DELAY_FUNC, sntp_request, NULL);
 8006af4:	f016 f810 	bl	801cb18 <sys_rand>
 8006af8:	0003      	movs	r3, r0
 8006afa:	491a      	ldr	r1, [pc, #104]	; (8006b64 <sntp_init+0xc0>)
 8006afc:	0018      	movs	r0, r3
 8006afe:	f7f9 fb9b 	bl	8000238 <__aeabi_uidivmod>
 8006b02:	000b      	movs	r3, r1
 8006b04:	0018      	movs	r0, r3
 8006b06:	4b18      	ldr	r3, [pc, #96]	; (8006b68 <sntp_init+0xc4>)
 8006b08:	2200      	movs	r2, #0
 8006b0a:	0019      	movs	r1, r3
 8006b0c:	f00b fad4 	bl	80120b8 <sys_timeout>
        ip_set_option(sntp_pcb, SOF_BROADCAST);
        udp_bind(sntp_pcb, IP_ANY_TYPE, SNTP_PORT);
      }
    }
  }
}
 8006b10:	e013      	b.n	8006b3a <sntp_init+0x96>
      } else if (sntp_opmode == SNTP_OPMODE_LISTENONLY) {
 8006b12:	4b11      	ldr	r3, [pc, #68]	; (8006b58 <sntp_init+0xb4>)
 8006b14:	781b      	ldrb	r3, [r3, #0]
 8006b16:	2b01      	cmp	r3, #1
 8006b18:	d10f      	bne.n	8006b3a <sntp_init+0x96>
        ip_set_option(sntp_pcb, SOF_BROADCAST);
 8006b1a:	4b09      	ldr	r3, [pc, #36]	; (8006b40 <sntp_init+0x9c>)
 8006b1c:	681b      	ldr	r3, [r3, #0]
 8006b1e:	7a5a      	ldrb	r2, [r3, #9]
 8006b20:	4b07      	ldr	r3, [pc, #28]	; (8006b40 <sntp_init+0x9c>)
 8006b22:	681b      	ldr	r3, [r3, #0]
 8006b24:	2120      	movs	r1, #32
 8006b26:	430a      	orrs	r2, r1
 8006b28:	b2d2      	uxtb	r2, r2
 8006b2a:	725a      	strb	r2, [r3, #9]
        udp_bind(sntp_pcb, IP_ANY_TYPE, SNTP_PORT);
 8006b2c:	4b04      	ldr	r3, [pc, #16]	; (8006b40 <sntp_init+0x9c>)
 8006b2e:	681b      	ldr	r3, [r3, #0]
 8006b30:	490e      	ldr	r1, [pc, #56]	; (8006b6c <sntp_init+0xc8>)
 8006b32:	227b      	movs	r2, #123	; 0x7b
 8006b34:	0018      	movs	r0, r3
 8006b36:	f00b ffd9 	bl	8012aec <udp_bind>
}
 8006b3a:	46c0      	nop			; (mov r8, r8)
 8006b3c:	46bd      	mov	sp, r7
 8006b3e:	bd80      	pop	{r7, pc}
 8006b40:	20001900 	.word	0x20001900
 8006b44:	0801ed34 	.word	0x0801ed34
 8006b48:	0000029d 	.word	0x0000029d
 8006b4c:	0801eda0 	.word	0x0801eda0
 8006b50:	0801ed74 	.word	0x0801ed74
 8006b54:	080067c9 	.word	0x080067c9
 8006b58:	200018fd 	.word	0x200018fd
 8006b5c:	20001910 	.word	0x20001910
 8006b60:	00003a98 	.word	0x00003a98
 8006b64:	00001388 	.word	0x00001388
 8006b68:	080069f9 	.word	0x080069f9
 8006b6c:	0802246c 	.word	0x0802246c

08006b70 <sntp_setoperatingmode>:
 * Sets the operating mode.
 * @param operating_mode one of the available operating modes
 */
void
sntp_setoperatingmode(u8_t operating_mode)
{
 8006b70:	b580      	push	{r7, lr}
 8006b72:	b082      	sub	sp, #8
 8006b74:	af00      	add	r7, sp, #0
 8006b76:	0002      	movs	r2, r0
 8006b78:	1dfb      	adds	r3, r7, #7
 8006b7a:	701a      	strb	r2, [r3, #0]
  LWIP_ASSERT_CORE_LOCKED();
  LWIP_ASSERT("Invalid operating mode", operating_mode <= SNTP_OPMODE_LISTENONLY);
 8006b7c:	1dfb      	adds	r3, r7, #7
 8006b7e:	781b      	ldrb	r3, [r3, #0]
 8006b80:	2b01      	cmp	r3, #1
 8006b82:	d906      	bls.n	8006b92 <sntp_setoperatingmode+0x22>
 8006b84:	4b0c      	ldr	r3, [pc, #48]	; (8006bb8 <sntp_setoperatingmode+0x48>)
 8006b86:	22b6      	movs	r2, #182	; 0xb6
 8006b88:	0092      	lsls	r2, r2, #2
 8006b8a:	490c      	ldr	r1, [pc, #48]	; (8006bbc <sntp_setoperatingmode+0x4c>)
 8006b8c:	480c      	ldr	r0, [pc, #48]	; (8006bc0 <sntp_setoperatingmode+0x50>)
 8006b8e:	f7fb fea5 	bl	80028dc <app_debug_rtt_raw>
  LWIP_ASSERT("Operating mode must not be set while SNTP client is running", sntp_pcb == NULL);
 8006b92:	4b0c      	ldr	r3, [pc, #48]	; (8006bc4 <sntp_setoperatingmode+0x54>)
 8006b94:	681b      	ldr	r3, [r3, #0]
 8006b96:	2b00      	cmp	r3, #0
 8006b98:	d005      	beq.n	8006ba6 <sntp_setoperatingmode+0x36>
 8006b9a:	4b07      	ldr	r3, [pc, #28]	; (8006bb8 <sntp_setoperatingmode+0x48>)
 8006b9c:	4a0a      	ldr	r2, [pc, #40]	; (8006bc8 <sntp_setoperatingmode+0x58>)
 8006b9e:	490b      	ldr	r1, [pc, #44]	; (8006bcc <sntp_setoperatingmode+0x5c>)
 8006ba0:	4807      	ldr	r0, [pc, #28]	; (8006bc0 <sntp_setoperatingmode+0x50>)
 8006ba2:	f7fb fe9b 	bl	80028dc <app_debug_rtt_raw>
  sntp_opmode = operating_mode;
 8006ba6:	4b0a      	ldr	r3, [pc, #40]	; (8006bd0 <sntp_setoperatingmode+0x60>)
 8006ba8:	1dfa      	adds	r2, r7, #7
 8006baa:	7812      	ldrb	r2, [r2, #0]
 8006bac:	701a      	strb	r2, [r3, #0]
}
 8006bae:	46c0      	nop			; (mov r8, r8)
 8006bb0:	46bd      	mov	sp, r7
 8006bb2:	b002      	add	sp, #8
 8006bb4:	bd80      	pop	{r7, pc}
 8006bb6:	46c0      	nop			; (mov r8, r8)
 8006bb8:	0801ed34 	.word	0x0801ed34
 8006bbc:	0801edcc 	.word	0x0801edcc
 8006bc0:	0801ed74 	.word	0x0801ed74
 8006bc4:	20001900 	.word	0x20001900
 8006bc8:	000002d9 	.word	0x000002d9
 8006bcc:	0801ede4 	.word	0x0801ede4
 8006bd0:	200018fd 	.word	0x200018fd

08006bd4 <sntp_setservername>:
 * @param idx the index of the NTP server to set must be < SNTP_MAX_SERVERS
 * @param server DNS name of the NTP server to set, to be resolved at contact time
 */
void
sntp_setservername(u8_t idx, const char *server)
{
 8006bd4:	b580      	push	{r7, lr}
 8006bd6:	b082      	sub	sp, #8
 8006bd8:	af00      	add	r7, sp, #0
 8006bda:	0002      	movs	r2, r0
 8006bdc:	6039      	str	r1, [r7, #0]
 8006bde:	1dfb      	adds	r3, r7, #7
 8006be0:	701a      	strb	r2, [r3, #0]
  LWIP_ASSERT_CORE_LOCKED();
  if (idx < SNTP_MAX_SERVERS) {
 8006be2:	1dfb      	adds	r3, r7, #7
 8006be4:	781b      	ldrb	r3, [r3, #0]
 8006be6:	2b00      	cmp	r3, #0
 8006be8:	d108      	bne.n	8006bfc <sntp_setservername+0x28>
    sntp_servers[idx].name = server;
 8006bea:	1dfb      	adds	r3, r7, #7
 8006bec:	781a      	ldrb	r2, [r3, #0]
 8006bee:	4905      	ldr	r1, [pc, #20]	; (8006c04 <sntp_setservername+0x30>)
 8006bf0:	0013      	movs	r3, r2
 8006bf2:	005b      	lsls	r3, r3, #1
 8006bf4:	189b      	adds	r3, r3, r2
 8006bf6:	009b      	lsls	r3, r3, #2
 8006bf8:	683a      	ldr	r2, [r7, #0]
 8006bfa:	505a      	str	r2, [r3, r1]
  }
}
 8006bfc:	46c0      	nop			; (mov r8, r8)
 8006bfe:	46bd      	mov	sp, r7
 8006c00:	b002      	add	sp, #8
 8006c02:	bd80      	pop	{r7, pc}
 8006c04:	20001904 	.word	0x20001904

08006c08 <lwip_htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
lwip_htons(u16_t n)
{
 8006c08:	b580      	push	{r7, lr}
 8006c0a:	b082      	sub	sp, #8
 8006c0c:	af00      	add	r7, sp, #0
 8006c0e:	0002      	movs	r2, r0
 8006c10:	1dbb      	adds	r3, r7, #6
 8006c12:	801a      	strh	r2, [r3, #0]
  return PP_HTONS(n);
 8006c14:	1dbb      	adds	r3, r7, #6
 8006c16:	881b      	ldrh	r3, [r3, #0]
 8006c18:	021b      	lsls	r3, r3, #8
 8006c1a:	b21a      	sxth	r2, r3
 8006c1c:	1dbb      	adds	r3, r7, #6
 8006c1e:	881b      	ldrh	r3, [r3, #0]
 8006c20:	0a1b      	lsrs	r3, r3, #8
 8006c22:	b29b      	uxth	r3, r3
 8006c24:	b21b      	sxth	r3, r3
 8006c26:	4313      	orrs	r3, r2
 8006c28:	b21b      	sxth	r3, r3
 8006c2a:	b29b      	uxth	r3, r3
}
 8006c2c:	0018      	movs	r0, r3
 8006c2e:	46bd      	mov	sp, r7
 8006c30:	b002      	add	sp, #8
 8006c32:	bd80      	pop	{r7, pc}

08006c34 <lwip_htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
lwip_htonl(u32_t n)
{
 8006c34:	b580      	push	{r7, lr}
 8006c36:	b082      	sub	sp, #8
 8006c38:	af00      	add	r7, sp, #0
 8006c3a:	6078      	str	r0, [r7, #4]
  return PP_HTONL(n);
 8006c3c:	687b      	ldr	r3, [r7, #4]
 8006c3e:	061a      	lsls	r2, r3, #24
 8006c40:	687b      	ldr	r3, [r7, #4]
 8006c42:	0219      	lsls	r1, r3, #8
 8006c44:	23ff      	movs	r3, #255	; 0xff
 8006c46:	041b      	lsls	r3, r3, #16
 8006c48:	400b      	ands	r3, r1
 8006c4a:	431a      	orrs	r2, r3
 8006c4c:	687b      	ldr	r3, [r7, #4]
 8006c4e:	0a19      	lsrs	r1, r3, #8
 8006c50:	23ff      	movs	r3, #255	; 0xff
 8006c52:	021b      	lsls	r3, r3, #8
 8006c54:	400b      	ands	r3, r1
 8006c56:	431a      	orrs	r2, r3
 8006c58:	687b      	ldr	r3, [r7, #4]
 8006c5a:	0e1b      	lsrs	r3, r3, #24
 8006c5c:	4313      	orrs	r3, r2
}
 8006c5e:	0018      	movs	r0, r3
 8006c60:	46bd      	mov	sp, r7
 8006c62:	b002      	add	sp, #8
 8006c64:	bd80      	pop	{r7, pc}

08006c66 <lwip_strnicmp>:
 * lwIP default implementation for strnicmp() non-standard function.
 * This can be \#defined to strnicmp() depending on your platform port.
 */
int
lwip_strnicmp(const char *str1, const char *str2, size_t len)
{
 8006c66:	b5b0      	push	{r4, r5, r7, lr}
 8006c68:	b086      	sub	sp, #24
 8006c6a:	af00      	add	r7, sp, #0
 8006c6c:	60f8      	str	r0, [r7, #12]
 8006c6e:	60b9      	str	r1, [r7, #8]
 8006c70:	607a      	str	r2, [r7, #4]
  char c1, c2;

  do {
    c1 = *str1++;
 8006c72:	68fb      	ldr	r3, [r7, #12]
 8006c74:	1c5a      	adds	r2, r3, #1
 8006c76:	60fa      	str	r2, [r7, #12]
 8006c78:	2117      	movs	r1, #23
 8006c7a:	187a      	adds	r2, r7, r1
 8006c7c:	781b      	ldrb	r3, [r3, #0]
 8006c7e:	7013      	strb	r3, [r2, #0]
    c2 = *str2++;
 8006c80:	68bb      	ldr	r3, [r7, #8]
 8006c82:	1c5a      	adds	r2, r3, #1
 8006c84:	60ba      	str	r2, [r7, #8]
 8006c86:	2416      	movs	r4, #22
 8006c88:	193a      	adds	r2, r7, r4
 8006c8a:	781b      	ldrb	r3, [r3, #0]
 8006c8c:	7013      	strb	r3, [r2, #0]
    if (c1 != c2) {
 8006c8e:	187a      	adds	r2, r7, r1
 8006c90:	193b      	adds	r3, r7, r4
 8006c92:	7812      	ldrb	r2, [r2, #0]
 8006c94:	781b      	ldrb	r3, [r3, #0]
 8006c96:	429a      	cmp	r2, r3
 8006c98:	d020      	beq.n	8006cdc <lwip_strnicmp+0x76>
      char c1_upc = c1 | 0x20;
 8006c9a:	2015      	movs	r0, #21
 8006c9c:	183b      	adds	r3, r7, r0
 8006c9e:	187a      	adds	r2, r7, r1
 8006ca0:	7812      	ldrb	r2, [r2, #0]
 8006ca2:	2120      	movs	r1, #32
 8006ca4:	430a      	orrs	r2, r1
 8006ca6:	701a      	strb	r2, [r3, #0]
      if ((c1_upc >= 'a') && (c1_upc <= 'z')) {
 8006ca8:	183b      	adds	r3, r7, r0
 8006caa:	781b      	ldrb	r3, [r3, #0]
 8006cac:	2b60      	cmp	r3, #96	; 0x60
 8006cae:	d912      	bls.n	8006cd6 <lwip_strnicmp+0x70>
 8006cb0:	183b      	adds	r3, r7, r0
 8006cb2:	781b      	ldrb	r3, [r3, #0]
 8006cb4:	2b7a      	cmp	r3, #122	; 0x7a
 8006cb6:	d80e      	bhi.n	8006cd6 <lwip_strnicmp+0x70>
        /* characters are not equal an one is in the alphabet range:
        downcase both chars and check again */
        char c2_upc = c2 | 0x20;
 8006cb8:	2514      	movs	r5, #20
 8006cba:	197b      	adds	r3, r7, r5
 8006cbc:	193a      	adds	r2, r7, r4
 8006cbe:	7812      	ldrb	r2, [r2, #0]
 8006cc0:	2120      	movs	r1, #32
 8006cc2:	430a      	orrs	r2, r1
 8006cc4:	701a      	strb	r2, [r3, #0]
        if (c1_upc != c2_upc) {
 8006cc6:	183a      	adds	r2, r7, r0
 8006cc8:	197b      	adds	r3, r7, r5
 8006cca:	7812      	ldrb	r2, [r2, #0]
 8006ccc:	781b      	ldrb	r3, [r3, #0]
 8006cce:	429a      	cmp	r2, r3
 8006cd0:	d003      	beq.n	8006cda <lwip_strnicmp+0x74>
          /* still not equal */
          /* don't care for < or > */
          return 1;
 8006cd2:	2301      	movs	r3, #1
 8006cd4:	e00e      	b.n	8006cf4 <lwip_strnicmp+0x8e>
        }
      } else {
        /* characters are not equal but none is in the alphabet range */
        return 1;
 8006cd6:	2301      	movs	r3, #1
 8006cd8:	e00c      	b.n	8006cf4 <lwip_strnicmp+0x8e>
      if ((c1_upc >= 'a') && (c1_upc <= 'z')) {
 8006cda:	46c0      	nop			; (mov r8, r8)
      }
    }
    len--;
 8006cdc:	687b      	ldr	r3, [r7, #4]
 8006cde:	3b01      	subs	r3, #1
 8006ce0:	607b      	str	r3, [r7, #4]
  } while ((len != 0) && (c1 != 0));
 8006ce2:	687b      	ldr	r3, [r7, #4]
 8006ce4:	2b00      	cmp	r3, #0
 8006ce6:	d004      	beq.n	8006cf2 <lwip_strnicmp+0x8c>
 8006ce8:	2317      	movs	r3, #23
 8006cea:	18fb      	adds	r3, r7, r3
 8006cec:	781b      	ldrb	r3, [r3, #0]
 8006cee:	2b00      	cmp	r3, #0
 8006cf0:	d1bf      	bne.n	8006c72 <lwip_strnicmp+0xc>
  return 0;
 8006cf2:	2300      	movs	r3, #0
}
 8006cf4:	0018      	movs	r0, r3
 8006cf6:	46bd      	mov	sp, r7
 8006cf8:	b006      	add	sp, #24
 8006cfa:	bdb0      	pop	{r4, r5, r7, pc}

08006cfc <dns_init>:
 * Initialize the resolver: set up the UDP pcb and configure the default server
 * (if DNS_SERVER_ADDRESS is set).
 */
void
dns_init(void)
{
 8006cfc:	b580      	push	{r7, lr}
 8006cfe:	af00      	add	r7, sp, #0
#endif

#if DNS_LOCAL_HOSTLIST
  dns_init_local();
#endif
}
 8006d00:	46c0      	nop			; (mov r8, r8)
 8006d02:	46bd      	mov	sp, r7
 8006d04:	bd80      	pop	{r7, pc}
	...

08006d08 <dns_setserver>:
 * @param numdns the index of the DNS server to set must be < DNS_MAX_SERVERS
 * @param dnsserver IP address of the DNS server to set
 */
void
dns_setserver(u8_t numdns, const ip_addr_t *dnsserver)
{
 8006d08:	b580      	push	{r7, lr}
 8006d0a:	b082      	sub	sp, #8
 8006d0c:	af00      	add	r7, sp, #0
 8006d0e:	0002      	movs	r2, r0
 8006d10:	6039      	str	r1, [r7, #0]
 8006d12:	1dfb      	adds	r3, r7, #7
 8006d14:	701a      	strb	r2, [r3, #0]
  if (numdns < DNS_MAX_SERVERS) {
 8006d16:	1dfb      	adds	r3, r7, #7
 8006d18:	781b      	ldrb	r3, [r3, #0]
 8006d1a:	2b01      	cmp	r3, #1
 8006d1c:	d811      	bhi.n	8006d42 <dns_setserver+0x3a>
    if (dnsserver != NULL) {
 8006d1e:	683b      	ldr	r3, [r7, #0]
 8006d20:	2b00      	cmp	r3, #0
 8006d22:	d007      	beq.n	8006d34 <dns_setserver+0x2c>
      dns_servers[numdns] = (*dnsserver);
 8006d24:	1dfb      	adds	r3, r7, #7
 8006d26:	781b      	ldrb	r3, [r3, #0]
 8006d28:	4a08      	ldr	r2, [pc, #32]	; (8006d4c <dns_setserver+0x44>)
 8006d2a:	0099      	lsls	r1, r3, #2
 8006d2c:	683b      	ldr	r3, [r7, #0]
 8006d2e:	681b      	ldr	r3, [r3, #0]
 8006d30:	508b      	str	r3, [r1, r2]
    } else {
      dns_servers[numdns] = *IP_ADDR_ANY;
    }
  }
}
 8006d32:	e006      	b.n	8006d42 <dns_setserver+0x3a>
      dns_servers[numdns] = *IP_ADDR_ANY;
 8006d34:	1dfb      	adds	r3, r7, #7
 8006d36:	781b      	ldrb	r3, [r3, #0]
 8006d38:	4a04      	ldr	r2, [pc, #16]	; (8006d4c <dns_setserver+0x44>)
 8006d3a:	0099      	lsls	r1, r3, #2
 8006d3c:	4b04      	ldr	r3, [pc, #16]	; (8006d50 <dns_setserver+0x48>)
 8006d3e:	681b      	ldr	r3, [r3, #0]
 8006d40:	508b      	str	r3, [r1, r2]
}
 8006d42:	46c0      	nop			; (mov r8, r8)
 8006d44:	46bd      	mov	sp, r7
 8006d46:	b002      	add	sp, #8
 8006d48:	bd80      	pop	{r7, pc}
 8006d4a:	46c0      	nop			; (mov r8, r8)
 8006d4c:	20001af8 	.word	0x20001af8
 8006d50:	0802246c 	.word	0x0802246c

08006d54 <dns_getserver>:
 * @return IP address of the indexed DNS server or "ip_addr_any" if the DNS
 *         server has not been configured.
 */
const ip_addr_t *
dns_getserver(u8_t numdns)
{
 8006d54:	b580      	push	{r7, lr}
 8006d56:	b082      	sub	sp, #8
 8006d58:	af00      	add	r7, sp, #0
 8006d5a:	0002      	movs	r2, r0
 8006d5c:	1dfb      	adds	r3, r7, #7
 8006d5e:	701a      	strb	r2, [r3, #0]
  if (numdns < DNS_MAX_SERVERS) {
 8006d60:	1dfb      	adds	r3, r7, #7
 8006d62:	781b      	ldrb	r3, [r3, #0]
 8006d64:	2b01      	cmp	r3, #1
 8006d66:	d805      	bhi.n	8006d74 <dns_getserver+0x20>
    return &dns_servers[numdns];
 8006d68:	1dfb      	adds	r3, r7, #7
 8006d6a:	781b      	ldrb	r3, [r3, #0]
 8006d6c:	009a      	lsls	r2, r3, #2
 8006d6e:	4b04      	ldr	r3, [pc, #16]	; (8006d80 <dns_getserver+0x2c>)
 8006d70:	18d3      	adds	r3, r2, r3
 8006d72:	e000      	b.n	8006d76 <dns_getserver+0x22>
  } else {
    return IP_ADDR_ANY;
 8006d74:	4b03      	ldr	r3, [pc, #12]	; (8006d84 <dns_getserver+0x30>)
  }
}
 8006d76:	0018      	movs	r0, r3
 8006d78:	46bd      	mov	sp, r7
 8006d7a:	b002      	add	sp, #8
 8006d7c:	bd80      	pop	{r7, pc}
 8006d7e:	46c0      	nop			; (mov r8, r8)
 8006d80:	20001af8 	.word	0x20001af8
 8006d84:	0802246c 	.word	0x0802246c

08006d88 <dns_lookup>:
 *         was not found in the cached dns_table.
 * @return ERR_OK if found, ERR_ARG if not found
 */
static err_t
dns_lookup(const char *name, ip_addr_t *addr LWIP_DNS_ADDRTYPE_ARG(u8_t dns_addrtype))
{
 8006d88:	b590      	push	{r4, r7, lr}
 8006d8a:	b085      	sub	sp, #20
 8006d8c:	af00      	add	r7, sp, #0
 8006d8e:	6078      	str	r0, [r7, #4]
 8006d90:	6039      	str	r1, [r7, #0]
    return ERR_OK;
  }
#endif /* DNS_LOOKUP_LOCAL_EXTERN */

  /* Walk through name list, return entry if found. If not, return NULL. */
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 8006d92:	230f      	movs	r3, #15
 8006d94:	18fb      	adds	r3, r7, r3
 8006d96:	2200      	movs	r2, #0
 8006d98:	701a      	strb	r2, [r3, #0]
 8006d9a:	e034      	b.n	8006e06 <dns_lookup+0x7e>
    if ((dns_table[i].state == DNS_STATE_DONE) &&
 8006d9c:	240f      	movs	r4, #15
 8006d9e:	193b      	adds	r3, r7, r4
 8006da0:	781a      	ldrb	r2, [r3, #0]
 8006da2:	491e      	ldr	r1, [pc, #120]	; (8006e1c <dns_lookup+0x94>)
 8006da4:	0013      	movs	r3, r2
 8006da6:	00db      	lsls	r3, r3, #3
 8006da8:	189b      	adds	r3, r3, r2
 8006daa:	011b      	lsls	r3, r3, #4
 8006dac:	18cb      	adds	r3, r1, r3
 8006dae:	330a      	adds	r3, #10
 8006db0:	781b      	ldrb	r3, [r3, #0]
 8006db2:	2b03      	cmp	r3, #3
 8006db4:	d121      	bne.n	8006dfa <dns_lookup+0x72>
        (lwip_strnicmp(name, dns_table[i].name, sizeof(dns_table[i].name)) == 0) &&
 8006db6:	193b      	adds	r3, r7, r4
 8006db8:	781a      	ldrb	r2, [r3, #0]
 8006dba:	0013      	movs	r3, r2
 8006dbc:	00db      	lsls	r3, r3, #3
 8006dbe:	189b      	adds	r3, r3, r2
 8006dc0:	011b      	lsls	r3, r3, #4
 8006dc2:	3310      	adds	r3, #16
 8006dc4:	001a      	movs	r2, r3
 8006dc6:	4b15      	ldr	r3, [pc, #84]	; (8006e1c <dns_lookup+0x94>)
 8006dc8:	18d1      	adds	r1, r2, r3
 8006dca:	687b      	ldr	r3, [r7, #4]
 8006dcc:	2280      	movs	r2, #128	; 0x80
 8006dce:	0018      	movs	r0, r3
 8006dd0:	f7ff ff49 	bl	8006c66 <lwip_strnicmp>
 8006dd4:	1e03      	subs	r3, r0, #0
    if ((dns_table[i].state == DNS_STATE_DONE) &&
 8006dd6:	d110      	bne.n	8006dfa <dns_lookup+0x72>
        LWIP_DNS_ADDRTYPE_MATCH_IP(dns_addrtype, dns_table[i].ipaddr)) {
      LWIP_DEBUGF(DNS_DEBUG, ("dns_lookup: \"%s\": found = ", name));
      ip_addr_debug_print_val(DNS_DEBUG, dns_table[i].ipaddr);
      LWIP_DEBUGF(DNS_DEBUG, ("\n"));
      if (addr) {
 8006dd8:	683b      	ldr	r3, [r7, #0]
 8006dda:	2b00      	cmp	r3, #0
 8006ddc:	d00b      	beq.n	8006df6 <dns_lookup+0x6e>
        ip_addr_copy(*addr, dns_table[i].ipaddr);
 8006dde:	193b      	adds	r3, r7, r4
 8006de0:	781a      	ldrb	r2, [r3, #0]
 8006de2:	490e      	ldr	r1, [pc, #56]	; (8006e1c <dns_lookup+0x94>)
 8006de4:	0013      	movs	r3, r2
 8006de6:	00db      	lsls	r3, r3, #3
 8006de8:	189b      	adds	r3, r3, r2
 8006dea:	011b      	lsls	r3, r3, #4
 8006dec:	18cb      	adds	r3, r1, r3
 8006dee:	3304      	adds	r3, #4
 8006df0:	681a      	ldr	r2, [r3, #0]
 8006df2:	683b      	ldr	r3, [r7, #0]
 8006df4:	601a      	str	r2, [r3, #0]
      }
      return ERR_OK;
 8006df6:	2300      	movs	r3, #0
 8006df8:	e00c      	b.n	8006e14 <dns_lookup+0x8c>
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 8006dfa:	220f      	movs	r2, #15
 8006dfc:	18bb      	adds	r3, r7, r2
 8006dfe:	18ba      	adds	r2, r7, r2
 8006e00:	7812      	ldrb	r2, [r2, #0]
 8006e02:	3201      	adds	r2, #1
 8006e04:	701a      	strb	r2, [r3, #0]
 8006e06:	230f      	movs	r3, #15
 8006e08:	18fb      	adds	r3, r7, r3
 8006e0a:	781b      	ldrb	r3, [r3, #0]
 8006e0c:	2b02      	cmp	r3, #2
 8006e0e:	d9c5      	bls.n	8006d9c <dns_lookup+0x14>
    }
  }

  return ERR_ARG;
 8006e10:	2310      	movs	r3, #16
 8006e12:	425b      	negs	r3, r3
}
 8006e14:	0018      	movs	r0, r3
 8006e16:	46bd      	mov	sp, r7
 8006e18:	b005      	add	sp, #20
 8006e1a:	bd90      	pop	{r4, r7, pc}
 8006e1c:	20001924 	.word	0x20001924

08006e20 <dns_compare_name>:
 * @param start_offset offset into p where the name starts
 * @return 0xFFFF: names differ, other: names equal -> offset behind name
 */
static u16_t
dns_compare_name(const char *query, struct pbuf *p, u16_t start_offset)
{
 8006e20:	b590      	push	{r4, r7, lr}
 8006e22:	b089      	sub	sp, #36	; 0x24
 8006e24:	af00      	add	r7, sp, #0
 8006e26:	60f8      	str	r0, [r7, #12]
 8006e28:	60b9      	str	r1, [r7, #8]
 8006e2a:	1dbb      	adds	r3, r7, #6
 8006e2c:	801a      	strh	r2, [r3, #0]
  int n;
  u16_t response_offset = start_offset;
 8006e2e:	231a      	movs	r3, #26
 8006e30:	18fb      	adds	r3, r7, r3
 8006e32:	1dba      	adds	r2, r7, #6
 8006e34:	8812      	ldrh	r2, [r2, #0]
 8006e36:	801a      	strh	r2, [r3, #0]

  do {
    n = pbuf_try_get_at(p, response_offset);
 8006e38:	241a      	movs	r4, #26
 8006e3a:	193b      	adds	r3, r7, r4
 8006e3c:	881a      	ldrh	r2, [r3, #0]
 8006e3e:	68bb      	ldr	r3, [r7, #8]
 8006e40:	0011      	movs	r1, r2
 8006e42:	0018      	movs	r0, r3
 8006e44:	f003 fbf9 	bl	800a63a <pbuf_try_get_at>
 8006e48:	0003      	movs	r3, r0
 8006e4a:	61fb      	str	r3, [r7, #28]
    if ((n < 0) || (response_offset == 0xFFFF)) {
 8006e4c:	69fb      	ldr	r3, [r7, #28]
 8006e4e:	2b00      	cmp	r3, #0
 8006e50:	db04      	blt.n	8006e5c <dns_compare_name+0x3c>
 8006e52:	193b      	adds	r3, r7, r4
 8006e54:	881b      	ldrh	r3, [r3, #0]
 8006e56:	4a48      	ldr	r2, [pc, #288]	; (8006f78 <dns_compare_name+0x158>)
 8006e58:	4293      	cmp	r3, r2
 8006e5a:	d101      	bne.n	8006e60 <dns_compare_name+0x40>
      /* error or overflow */
      return 0xFFFF;
 8006e5c:	4b46      	ldr	r3, [pc, #280]	; (8006f78 <dns_compare_name+0x158>)
 8006e5e:	e087      	b.n	8006f70 <dns_compare_name+0x150>
    }
    response_offset++;
 8006e60:	211a      	movs	r1, #26
 8006e62:	187b      	adds	r3, r7, r1
 8006e64:	881a      	ldrh	r2, [r3, #0]
 8006e66:	187b      	adds	r3, r7, r1
 8006e68:	3201      	adds	r2, #1
 8006e6a:	801a      	strh	r2, [r3, #0]
    /** @see RFC 1035 - 4.1.4. Message compression */
    if ((n & 0xc0) == 0xc0) {
 8006e6c:	69fb      	ldr	r3, [r7, #28]
 8006e6e:	22c0      	movs	r2, #192	; 0xc0
 8006e70:	4013      	ands	r3, r2
 8006e72:	2bc0      	cmp	r3, #192	; 0xc0
 8006e74:	d156      	bne.n	8006f24 <dns_compare_name+0x104>
      /* Compressed name: cannot be equal since we don't send them */
      return 0xFFFF;
 8006e76:	4b40      	ldr	r3, [pc, #256]	; (8006f78 <dns_compare_name+0x158>)
 8006e78:	e07a      	b.n	8006f70 <dns_compare_name+0x150>
    } else {
      /* Not compressed name */
      while (n > 0) {
        int c = pbuf_try_get_at(p, response_offset);
 8006e7a:	231a      	movs	r3, #26
 8006e7c:	18fb      	adds	r3, r7, r3
 8006e7e:	881a      	ldrh	r2, [r3, #0]
 8006e80:	68bb      	ldr	r3, [r7, #8]
 8006e82:	0011      	movs	r1, r2
 8006e84:	0018      	movs	r0, r3
 8006e86:	f003 fbd8 	bl	800a63a <pbuf_try_get_at>
 8006e8a:	0003      	movs	r3, r0
 8006e8c:	617b      	str	r3, [r7, #20]
        if (c < 0) {
 8006e8e:	697b      	ldr	r3, [r7, #20]
 8006e90:	2b00      	cmp	r3, #0
 8006e92:	da01      	bge.n	8006e98 <dns_compare_name+0x78>
          return 0xFFFF;
 8006e94:	4b38      	ldr	r3, [pc, #224]	; (8006f78 <dns_compare_name+0x158>)
 8006e96:	e06b      	b.n	8006f70 <dns_compare_name+0x150>
        }
        if (lwip_tolower((*query)) != lwip_tolower((u8_t)c)) {
 8006e98:	2113      	movs	r1, #19
 8006e9a:	187b      	adds	r3, r7, r1
 8006e9c:	68fa      	ldr	r2, [r7, #12]
 8006e9e:	7812      	ldrb	r2, [r2, #0]
 8006ea0:	701a      	strb	r2, [r3, #0]
 8006ea2:	187b      	adds	r3, r7, r1
 8006ea4:	781b      	ldrb	r3, [r3, #0]
 8006ea6:	1c5a      	adds	r2, r3, #1
 8006ea8:	4b34      	ldr	r3, [pc, #208]	; (8006f7c <dns_compare_name+0x15c>)
 8006eaa:	18d3      	adds	r3, r2, r3
 8006eac:	781b      	ldrb	r3, [r3, #0]
 8006eae:	001a      	movs	r2, r3
 8006eb0:	2303      	movs	r3, #3
 8006eb2:	4013      	ands	r3, r2
 8006eb4:	2b01      	cmp	r3, #1
 8006eb6:	d104      	bne.n	8006ec2 <dns_compare_name+0xa2>
 8006eb8:	187b      	adds	r3, r7, r1
 8006eba:	781b      	ldrb	r3, [r3, #0]
 8006ebc:	3320      	adds	r3, #32
 8006ebe:	001a      	movs	r2, r3
 8006ec0:	e002      	b.n	8006ec8 <dns_compare_name+0xa8>
 8006ec2:	2313      	movs	r3, #19
 8006ec4:	18fb      	adds	r3, r7, r3
 8006ec6:	781a      	ldrb	r2, [r3, #0]
 8006ec8:	2012      	movs	r0, #18
 8006eca:	183b      	adds	r3, r7, r0
 8006ecc:	6979      	ldr	r1, [r7, #20]
 8006ece:	7019      	strb	r1, [r3, #0]
 8006ed0:	183b      	adds	r3, r7, r0
 8006ed2:	781b      	ldrb	r3, [r3, #0]
 8006ed4:	1c59      	adds	r1, r3, #1
 8006ed6:	4b29      	ldr	r3, [pc, #164]	; (8006f7c <dns_compare_name+0x15c>)
 8006ed8:	18cb      	adds	r3, r1, r3
 8006eda:	781b      	ldrb	r3, [r3, #0]
 8006edc:	0019      	movs	r1, r3
 8006ede:	2303      	movs	r3, #3
 8006ee0:	400b      	ands	r3, r1
 8006ee2:	2b01      	cmp	r3, #1
 8006ee4:	d103      	bne.n	8006eee <dns_compare_name+0xce>
 8006ee6:	183b      	adds	r3, r7, r0
 8006ee8:	781b      	ldrb	r3, [r3, #0]
 8006eea:	3320      	adds	r3, #32
 8006eec:	e002      	b.n	8006ef4 <dns_compare_name+0xd4>
 8006eee:	2312      	movs	r3, #18
 8006ef0:	18fb      	adds	r3, r7, r3
 8006ef2:	781b      	ldrb	r3, [r3, #0]
 8006ef4:	429a      	cmp	r2, r3
 8006ef6:	d001      	beq.n	8006efc <dns_compare_name+0xdc>
          return 0xFFFF;
 8006ef8:	4b1f      	ldr	r3, [pc, #124]	; (8006f78 <dns_compare_name+0x158>)
 8006efa:	e039      	b.n	8006f70 <dns_compare_name+0x150>
        }
        if (response_offset == 0xFFFF) {
 8006efc:	231a      	movs	r3, #26
 8006efe:	18fb      	adds	r3, r7, r3
 8006f00:	881b      	ldrh	r3, [r3, #0]
 8006f02:	4a1d      	ldr	r2, [pc, #116]	; (8006f78 <dns_compare_name+0x158>)
 8006f04:	4293      	cmp	r3, r2
 8006f06:	d101      	bne.n	8006f0c <dns_compare_name+0xec>
          /* would overflow */
          return 0xFFFF;
 8006f08:	4b1b      	ldr	r3, [pc, #108]	; (8006f78 <dns_compare_name+0x158>)
 8006f0a:	e031      	b.n	8006f70 <dns_compare_name+0x150>
        }
        response_offset++;
 8006f0c:	211a      	movs	r1, #26
 8006f0e:	187b      	adds	r3, r7, r1
 8006f10:	881a      	ldrh	r2, [r3, #0]
 8006f12:	187b      	adds	r3, r7, r1
 8006f14:	3201      	adds	r2, #1
 8006f16:	801a      	strh	r2, [r3, #0]
        ++query;
 8006f18:	68fb      	ldr	r3, [r7, #12]
 8006f1a:	3301      	adds	r3, #1
 8006f1c:	60fb      	str	r3, [r7, #12]
        --n;
 8006f1e:	69fb      	ldr	r3, [r7, #28]
 8006f20:	3b01      	subs	r3, #1
 8006f22:	61fb      	str	r3, [r7, #28]
      while (n > 0) {
 8006f24:	69fb      	ldr	r3, [r7, #28]
 8006f26:	2b00      	cmp	r3, #0
 8006f28:	dca7      	bgt.n	8006e7a <dns_compare_name+0x5a>
      }
      ++query;
 8006f2a:	68fb      	ldr	r3, [r7, #12]
 8006f2c:	3301      	adds	r3, #1
 8006f2e:	60fb      	str	r3, [r7, #12]
    }
    n = pbuf_try_get_at(p, response_offset);
 8006f30:	231a      	movs	r3, #26
 8006f32:	18fb      	adds	r3, r7, r3
 8006f34:	881a      	ldrh	r2, [r3, #0]
 8006f36:	68bb      	ldr	r3, [r7, #8]
 8006f38:	0011      	movs	r1, r2
 8006f3a:	0018      	movs	r0, r3
 8006f3c:	f003 fb7d 	bl	800a63a <pbuf_try_get_at>
 8006f40:	0003      	movs	r3, r0
 8006f42:	61fb      	str	r3, [r7, #28]
    if (n < 0) {
 8006f44:	69fb      	ldr	r3, [r7, #28]
 8006f46:	2b00      	cmp	r3, #0
 8006f48:	da01      	bge.n	8006f4e <dns_compare_name+0x12e>
      return 0xFFFF;
 8006f4a:	4b0b      	ldr	r3, [pc, #44]	; (8006f78 <dns_compare_name+0x158>)
 8006f4c:	e010      	b.n	8006f70 <dns_compare_name+0x150>
    }
  } while (n != 0);
 8006f4e:	69fb      	ldr	r3, [r7, #28]
 8006f50:	2b00      	cmp	r3, #0
 8006f52:	d000      	beq.n	8006f56 <dns_compare_name+0x136>
 8006f54:	e770      	b.n	8006e38 <dns_compare_name+0x18>

  if (response_offset == 0xFFFF) {
 8006f56:	231a      	movs	r3, #26
 8006f58:	18fb      	adds	r3, r7, r3
 8006f5a:	881b      	ldrh	r3, [r3, #0]
 8006f5c:	4a06      	ldr	r2, [pc, #24]	; (8006f78 <dns_compare_name+0x158>)
 8006f5e:	4293      	cmp	r3, r2
 8006f60:	d101      	bne.n	8006f66 <dns_compare_name+0x146>
    /* would overflow */
    return 0xFFFF;
 8006f62:	4b05      	ldr	r3, [pc, #20]	; (8006f78 <dns_compare_name+0x158>)
 8006f64:	e004      	b.n	8006f70 <dns_compare_name+0x150>
  }
  return (u16_t)(response_offset + 1);
 8006f66:	231a      	movs	r3, #26
 8006f68:	18fb      	adds	r3, r7, r3
 8006f6a:	881b      	ldrh	r3, [r3, #0]
 8006f6c:	3301      	adds	r3, #1
 8006f6e:	b29b      	uxth	r3, r3
}
 8006f70:	0018      	movs	r0, r3
 8006f72:	46bd      	mov	sp, r7
 8006f74:	b009      	add	sp, #36	; 0x24
 8006f76:	bd90      	pop	{r4, r7, pc}
 8006f78:	0000ffff 	.word	0x0000ffff
 8006f7c:	08022a48 	.word	0x08022a48

08006f80 <dns_skip_name>:
 * @param query_idx start index into p pointing to encoded DNS name in the DNS server response
 * @return index to end of the name
 */
static u16_t
dns_skip_name(struct pbuf *p, u16_t query_idx)
{
 8006f80:	b590      	push	{r4, r7, lr}
 8006f82:	b085      	sub	sp, #20
 8006f84:	af00      	add	r7, sp, #0
 8006f86:	6078      	str	r0, [r7, #4]
 8006f88:	000a      	movs	r2, r1
 8006f8a:	1cbb      	adds	r3, r7, #2
 8006f8c:	801a      	strh	r2, [r3, #0]
  int n;
  u16_t offset = query_idx;
 8006f8e:	230e      	movs	r3, #14
 8006f90:	18fb      	adds	r3, r7, r3
 8006f92:	1cba      	adds	r2, r7, #2
 8006f94:	8812      	ldrh	r2, [r2, #0]
 8006f96:	801a      	strh	r2, [r3, #0]

  do {
    n = pbuf_try_get_at(p, offset++);
 8006f98:	240e      	movs	r4, #14
 8006f9a:	193b      	adds	r3, r7, r4
 8006f9c:	881b      	ldrh	r3, [r3, #0]
 8006f9e:	193a      	adds	r2, r7, r4
 8006fa0:	1c59      	adds	r1, r3, #1
 8006fa2:	8011      	strh	r1, [r2, #0]
 8006fa4:	687a      	ldr	r2, [r7, #4]
 8006fa6:	0019      	movs	r1, r3
 8006fa8:	0010      	movs	r0, r2
 8006faa:	f003 fb46 	bl	800a63a <pbuf_try_get_at>
 8006fae:	0003      	movs	r3, r0
 8006fb0:	60bb      	str	r3, [r7, #8]
    if ((n < 0) || (offset == 0)) {
 8006fb2:	68bb      	ldr	r3, [r7, #8]
 8006fb4:	2b00      	cmp	r3, #0
 8006fb6:	db03      	blt.n	8006fc0 <dns_skip_name+0x40>
 8006fb8:	193b      	adds	r3, r7, r4
 8006fba:	881b      	ldrh	r3, [r3, #0]
 8006fbc:	2b00      	cmp	r3, #0
 8006fbe:	d101      	bne.n	8006fc4 <dns_skip_name+0x44>
      return 0xFFFF;
 8006fc0:	4b1e      	ldr	r3, [pc, #120]	; (800703c <dns_skip_name+0xbc>)
 8006fc2:	e037      	b.n	8007034 <dns_skip_name+0xb4>
    }
    /** @see RFC 1035 - 4.1.4. Message compression */
    if ((n & 0xc0) == 0xc0) {
 8006fc4:	68bb      	ldr	r3, [r7, #8]
 8006fc6:	22c0      	movs	r2, #192	; 0xc0
 8006fc8:	4013      	ands	r3, r2
 8006fca:	2bc0      	cmp	r3, #192	; 0xc0
 8006fcc:	d024      	beq.n	8007018 <dns_skip_name+0x98>
      /* Compressed name: since we only want to skip it (not check it), stop here */
      break;
    } else {
      /* Not compressed name */
      if (offset + n >= p->tot_len) {
 8006fce:	230e      	movs	r3, #14
 8006fd0:	18fb      	adds	r3, r7, r3
 8006fd2:	881a      	ldrh	r2, [r3, #0]
 8006fd4:	68bb      	ldr	r3, [r7, #8]
 8006fd6:	18d3      	adds	r3, r2, r3
 8006fd8:	687a      	ldr	r2, [r7, #4]
 8006fda:	8912      	ldrh	r2, [r2, #8]
 8006fdc:	4293      	cmp	r3, r2
 8006fde:	db01      	blt.n	8006fe4 <dns_skip_name+0x64>
        return 0xFFFF;
 8006fe0:	4b16      	ldr	r3, [pc, #88]	; (800703c <dns_skip_name+0xbc>)
 8006fe2:	e027      	b.n	8007034 <dns_skip_name+0xb4>
      }
      offset = (u16_t)(offset + n);
 8006fe4:	68bb      	ldr	r3, [r7, #8]
 8006fe6:	b299      	uxth	r1, r3
 8006fe8:	200e      	movs	r0, #14
 8006fea:	183b      	adds	r3, r7, r0
 8006fec:	183a      	adds	r2, r7, r0
 8006fee:	8812      	ldrh	r2, [r2, #0]
 8006ff0:	188a      	adds	r2, r1, r2
 8006ff2:	801a      	strh	r2, [r3, #0]
    }
    n = pbuf_try_get_at(p, offset);
 8006ff4:	183b      	adds	r3, r7, r0
 8006ff6:	881a      	ldrh	r2, [r3, #0]
 8006ff8:	687b      	ldr	r3, [r7, #4]
 8006ffa:	0011      	movs	r1, r2
 8006ffc:	0018      	movs	r0, r3
 8006ffe:	f003 fb1c 	bl	800a63a <pbuf_try_get_at>
 8007002:	0003      	movs	r3, r0
 8007004:	60bb      	str	r3, [r7, #8]
    if (n < 0) {
 8007006:	68bb      	ldr	r3, [r7, #8]
 8007008:	2b00      	cmp	r3, #0
 800700a:	da01      	bge.n	8007010 <dns_skip_name+0x90>
      return 0xFFFF;
 800700c:	4b0b      	ldr	r3, [pc, #44]	; (800703c <dns_skip_name+0xbc>)
 800700e:	e011      	b.n	8007034 <dns_skip_name+0xb4>
    }
  } while (n != 0);
 8007010:	68bb      	ldr	r3, [r7, #8]
 8007012:	2b00      	cmp	r3, #0
 8007014:	d1c0      	bne.n	8006f98 <dns_skip_name+0x18>
 8007016:	e000      	b.n	800701a <dns_skip_name+0x9a>
      break;
 8007018:	46c0      	nop			; (mov r8, r8)

  if (offset == 0xFFFF) {
 800701a:	230e      	movs	r3, #14
 800701c:	18fb      	adds	r3, r7, r3
 800701e:	881b      	ldrh	r3, [r3, #0]
 8007020:	4a06      	ldr	r2, [pc, #24]	; (800703c <dns_skip_name+0xbc>)
 8007022:	4293      	cmp	r3, r2
 8007024:	d101      	bne.n	800702a <dns_skip_name+0xaa>
    return 0xFFFF;
 8007026:	4b05      	ldr	r3, [pc, #20]	; (800703c <dns_skip_name+0xbc>)
 8007028:	e004      	b.n	8007034 <dns_skip_name+0xb4>
  }
  return (u16_t)(offset + 1);
 800702a:	230e      	movs	r3, #14
 800702c:	18fb      	adds	r3, r7, r3
 800702e:	881b      	ldrh	r3, [r3, #0]
 8007030:	3301      	adds	r3, #1
 8007032:	b29b      	uxth	r3, r3
}
 8007034:	0018      	movs	r0, r3
 8007036:	46bd      	mov	sp, r7
 8007038:	b005      	add	sp, #20
 800703a:	bd90      	pop	{r4, r7, pc}
 800703c:	0000ffff 	.word	0x0000ffff

08007040 <dns_send>:
 * @param idx the DNS table entry index for which to send a request
 * @return ERR_OK if packet is sent; an err_t indicating the problem otherwise
 */
static err_t
dns_send(u8_t idx)
{
 8007040:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007042:	b091      	sub	sp, #68	; 0x44
 8007044:	af00      	add	r7, sp, #0
 8007046:	0002      	movs	r2, r0
 8007048:	1dfb      	adds	r3, r7, #7
 800704a:	701a      	strb	r2, [r3, #0]
  struct pbuf *p;
  u16_t query_idx, copy_len;
  const char *hostname, *hostname_part;
  u8_t n;
  u8_t pcb_idx;
  struct dns_table_entry *entry = &dns_table[idx];
 800704c:	1dfb      	adds	r3, r7, #7
 800704e:	781a      	ldrb	r2, [r3, #0]
 8007050:	0013      	movs	r3, r2
 8007052:	00db      	lsls	r3, r3, #3
 8007054:	189b      	adds	r3, r3, r2
 8007056:	011b      	lsls	r3, r3, #4
 8007058:	4a7e      	ldr	r2, [pc, #504]	; (8007254 <dns_send+0x214>)
 800705a:	189b      	adds	r3, r3, r2
 800705c:	633b      	str	r3, [r7, #48]	; 0x30

  LWIP_DEBUGF(DNS_DEBUG, ("dns_send: dns_servers[%"U16_F"] \"%s\": request\n",
                          (u16_t)(entry->server_idx), entry->name));
  LWIP_ASSERT("dns server out of array", entry->server_idx < DNS_MAX_SERVERS);
 800705e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007060:	7adb      	ldrb	r3, [r3, #11]
 8007062:	2b01      	cmp	r3, #1
 8007064:	d905      	bls.n	8007072 <dns_send+0x32>
 8007066:	4b7c      	ldr	r3, [pc, #496]	; (8007258 <dns_send+0x218>)
 8007068:	4a7c      	ldr	r2, [pc, #496]	; (800725c <dns_send+0x21c>)
 800706a:	497d      	ldr	r1, [pc, #500]	; (8007260 <dns_send+0x220>)
 800706c:	487d      	ldr	r0, [pc, #500]	; (8007264 <dns_send+0x224>)
 800706e:	f7fb fc35 	bl	80028dc <app_debug_rtt_raw>
  if (ip_addr_isany_val(dns_servers[entry->server_idx])
 8007072:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007074:	7adb      	ldrb	r3, [r3, #11]
 8007076:	001a      	movs	r2, r3
 8007078:	4b7b      	ldr	r3, [pc, #492]	; (8007268 <dns_send+0x228>)
 800707a:	0092      	lsls	r2, r2, #2
 800707c:	58d3      	ldr	r3, [r2, r3]
 800707e:	2b00      	cmp	r3, #0
 8007080:	d10a      	bne.n	8007098 <dns_send+0x58>
      && !entry->is_mdns
#endif
     ) {
    /* DNS server not valid anymore, e.g. PPP netif has been shut down */
    /* call specified callback function if provided */
    dns_call_found(idx, NULL);
 8007082:	1dfb      	adds	r3, r7, #7
 8007084:	781b      	ldrb	r3, [r3, #0]
 8007086:	2100      	movs	r1, #0
 8007088:	0018      	movs	r0, r3
 800708a:	f000 f9a3 	bl	80073d4 <dns_call_found>
    /* flush this entry */
    entry->state = DNS_STATE_UNUSED;
 800708e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007090:	2200      	movs	r2, #0
 8007092:	729a      	strb	r2, [r3, #10]
    return ERR_OK;
 8007094:	2300      	movs	r3, #0
 8007096:	e0d8      	b.n	800724a <dns_send+0x20a>
  }

  /* if here, we have either a new query or a retry on a previous query to process */
  p = pbuf_alloc(PBUF_TRANSPORT, (u16_t)(SIZEOF_DNS_HDR + strlen(entry->name) + 2 +
 8007098:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800709a:	3310      	adds	r3, #16
 800709c:	0018      	movs	r0, r3
 800709e:	f7f9 f833 	bl	8000108 <strlen>
 80070a2:	0003      	movs	r3, r0
 80070a4:	b29b      	uxth	r3, r3
 80070a6:	3312      	adds	r3, #18
 80070a8:	b29b      	uxth	r3, r3
 80070aa:	22a0      	movs	r2, #160	; 0xa0
 80070ac:	0092      	lsls	r2, r2, #2
 80070ae:	0019      	movs	r1, r3
 80070b0:	2038      	movs	r0, #56	; 0x38
 80070b2:	f002 fa15 	bl	80094e0 <pbuf_alloc>
 80070b6:	0003      	movs	r3, r0
 80070b8:	62fb      	str	r3, [r7, #44]	; 0x2c
                                         SIZEOF_DNS_QUERY), PBUF_RAM);
  if (p != NULL) {
 80070ba:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80070bc:	2b00      	cmp	r3, #0
 80070be:	d100      	bne.n	80070c2 <dns_send+0x82>
 80070c0:	e0b3      	b.n	800722a <dns_send+0x1ea>
    const ip_addr_t *dst;
    u16_t dst_port;
    /* fill dns header */
    memset(&hdr, 0, SIZEOF_DNS_HDR);
 80070c2:	2410      	movs	r4, #16
 80070c4:	193b      	adds	r3, r7, r4
 80070c6:	220c      	movs	r2, #12
 80070c8:	2100      	movs	r1, #0
 80070ca:	0018      	movs	r0, r3
 80070cc:	f015 fda4 	bl	801cc18 <memset>
    hdr.id = lwip_htons(entry->txid);
 80070d0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80070d2:	891b      	ldrh	r3, [r3, #8]
 80070d4:	0018      	movs	r0, r3
 80070d6:	f7ff fd97 	bl	8006c08 <lwip_htons>
 80070da:	0003      	movs	r3, r0
 80070dc:	001a      	movs	r2, r3
 80070de:	193b      	adds	r3, r7, r4
 80070e0:	801a      	strh	r2, [r3, #0]
    hdr.flags1 = DNS_FLAG1_RD;
 80070e2:	193b      	adds	r3, r7, r4
 80070e4:	2201      	movs	r2, #1
 80070e6:	709a      	strb	r2, [r3, #2]
    hdr.numquestions = PP_HTONS(1);
 80070e8:	193b      	adds	r3, r7, r4
 80070ea:	2280      	movs	r2, #128	; 0x80
 80070ec:	0052      	lsls	r2, r2, #1
 80070ee:	809a      	strh	r2, [r3, #4]
    pbuf_take(p, &hdr, SIZEOF_DNS_HDR);
 80070f0:	1939      	adds	r1, r7, r4
 80070f2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80070f4:	220c      	movs	r2, #12
 80070f6:	0018      	movs	r0, r3
 80070f8:	f003 f90a 	bl	800a310 <pbuf_take>
    hostname = entry->name;
 80070fc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80070fe:	3310      	adds	r3, #16
 8007100:	63bb      	str	r3, [r7, #56]	; 0x38
    --hostname;
 8007102:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007104:	3b01      	subs	r3, #1
 8007106:	63bb      	str	r3, [r7, #56]	; 0x38

    /* convert hostname into suitable query format. */
    query_idx = SIZEOF_DNS_HDR;
 8007108:	233c      	movs	r3, #60	; 0x3c
 800710a:	18fb      	adds	r3, r7, r3
 800710c:	220c      	movs	r2, #12
 800710e:	801a      	strh	r2, [r3, #0]
    do {
      ++hostname;
 8007110:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007112:	3301      	adds	r3, #1
 8007114:	63bb      	str	r3, [r7, #56]	; 0x38
      hostname_part = hostname;
 8007116:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007118:	62bb      	str	r3, [r7, #40]	; 0x28
      for (n = 0; *hostname != '.' && *hostname != 0; ++hostname) {
 800711a:	2337      	movs	r3, #55	; 0x37
 800711c:	18fb      	adds	r3, r7, r3
 800711e:	2200      	movs	r2, #0
 8007120:	701a      	strb	r2, [r3, #0]
 8007122:	e008      	b.n	8007136 <dns_send+0xf6>
        ++n;
 8007124:	2237      	movs	r2, #55	; 0x37
 8007126:	18bb      	adds	r3, r7, r2
 8007128:	18ba      	adds	r2, r7, r2
 800712a:	7812      	ldrb	r2, [r2, #0]
 800712c:	3201      	adds	r2, #1
 800712e:	701a      	strb	r2, [r3, #0]
      for (n = 0; *hostname != '.' && *hostname != 0; ++hostname) {
 8007130:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007132:	3301      	adds	r3, #1
 8007134:	63bb      	str	r3, [r7, #56]	; 0x38
 8007136:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007138:	781b      	ldrb	r3, [r3, #0]
 800713a:	2b2e      	cmp	r3, #46	; 0x2e
 800713c:	d003      	beq.n	8007146 <dns_send+0x106>
 800713e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007140:	781b      	ldrb	r3, [r3, #0]
 8007142:	2b00      	cmp	r3, #0
 8007144:	d1ee      	bne.n	8007124 <dns_send+0xe4>
      }
      copy_len = (u16_t)(hostname - hostname_part);
 8007146:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8007148:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800714a:	1ad2      	subs	r2, r2, r3
 800714c:	2326      	movs	r3, #38	; 0x26
 800714e:	18fb      	adds	r3, r7, r3
 8007150:	801a      	strh	r2, [r3, #0]
      if (query_idx + n + 1 > 0xFFFF) {
 8007152:	253c      	movs	r5, #60	; 0x3c
 8007154:	197b      	adds	r3, r7, r5
 8007156:	881a      	ldrh	r2, [r3, #0]
 8007158:	2637      	movs	r6, #55	; 0x37
 800715a:	19bb      	adds	r3, r7, r6
 800715c:	781b      	ldrb	r3, [r3, #0]
 800715e:	18d3      	adds	r3, r2, r3
 8007160:	4a42      	ldr	r2, [pc, #264]	; (800726c <dns_send+0x22c>)
 8007162:	4293      	cmp	r3, r2
 8007164:	dc6a      	bgt.n	800723c <dns_send+0x1fc>
        /* u16_t overflow */
        goto overflow_return;
      }
      pbuf_put_at(p, query_idx, n);
 8007166:	19bb      	adds	r3, r7, r6
 8007168:	781a      	ldrb	r2, [r3, #0]
 800716a:	197b      	adds	r3, r7, r5
 800716c:	8819      	ldrh	r1, [r3, #0]
 800716e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007170:	0018      	movs	r0, r3
 8007172:	f003 fa89 	bl	800a688 <pbuf_put_at>
      pbuf_take_at(p, hostname_part, copy_len, (u16_t)(query_idx + 1));
 8007176:	197b      	adds	r3, r7, r5
 8007178:	881b      	ldrh	r3, [r3, #0]
 800717a:	3301      	adds	r3, #1
 800717c:	b29c      	uxth	r4, r3
 800717e:	2326      	movs	r3, #38	; 0x26
 8007180:	18fb      	adds	r3, r7, r3
 8007182:	881a      	ldrh	r2, [r3, #0]
 8007184:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8007186:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8007188:	0023      	movs	r3, r4
 800718a:	f003 f951 	bl	800a430 <pbuf_take_at>
      query_idx = (u16_t)(query_idx + n + 1);
 800718e:	19bb      	adds	r3, r7, r6
 8007190:	781b      	ldrb	r3, [r3, #0]
 8007192:	b29a      	uxth	r2, r3
 8007194:	197b      	adds	r3, r7, r5
 8007196:	881b      	ldrh	r3, [r3, #0]
 8007198:	18d3      	adds	r3, r2, r3
 800719a:	b29a      	uxth	r2, r3
 800719c:	197b      	adds	r3, r7, r5
 800719e:	3201      	adds	r2, #1
 80071a0:	801a      	strh	r2, [r3, #0]
    } while (*hostname != 0);
 80071a2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80071a4:	781b      	ldrb	r3, [r3, #0]
 80071a6:	2b00      	cmp	r3, #0
 80071a8:	d1b2      	bne.n	8007110 <dns_send+0xd0>
    pbuf_put_at(p, query_idx, 0);
 80071aa:	197b      	adds	r3, r7, r5
 80071ac:	8819      	ldrh	r1, [r3, #0]
 80071ae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80071b0:	2200      	movs	r2, #0
 80071b2:	0018      	movs	r0, r3
 80071b4:	f003 fa68 	bl	800a688 <pbuf_put_at>
    query_idx++;
 80071b8:	0029      	movs	r1, r5
 80071ba:	187b      	adds	r3, r7, r1
 80071bc:	881a      	ldrh	r2, [r3, #0]
 80071be:	187b      	adds	r3, r7, r1
 80071c0:	3201      	adds	r2, #1
 80071c2:	801a      	strh	r2, [r3, #0]

    /* fill dns query */
    if (LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype)) {
      qry.type = PP_HTONS(DNS_RRTYPE_AAAA);
    } else {
      qry.type = PP_HTONS(DNS_RRTYPE_A);
 80071c4:	200c      	movs	r0, #12
 80071c6:	183b      	adds	r3, r7, r0
 80071c8:	2280      	movs	r2, #128	; 0x80
 80071ca:	0052      	lsls	r2, r2, #1
 80071cc:	801a      	strh	r2, [r3, #0]
    }
    qry.cls = PP_HTONS(DNS_RRCLASS_IN);
 80071ce:	183b      	adds	r3, r7, r0
 80071d0:	2280      	movs	r2, #128	; 0x80
 80071d2:	0052      	lsls	r2, r2, #1
 80071d4:	805a      	strh	r2, [r3, #2]
    pbuf_take_at(p, &qry, SIZEOF_DNS_QUERY, query_idx);
 80071d6:	187b      	adds	r3, r7, r1
 80071d8:	881b      	ldrh	r3, [r3, #0]
 80071da:	1839      	adds	r1, r7, r0
 80071dc:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80071de:	2204      	movs	r2, #4
 80071e0:	f003 f926 	bl	800a430 <pbuf_take_at>

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) != 0)
    pcb_idx = entry->pcb_idx;
 80071e4:	2125      	movs	r1, #37	; 0x25
 80071e6:	187b      	adds	r3, r7, r1
 80071e8:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80071ea:	7bd2      	ldrb	r2, [r2, #15]
 80071ec:	701a      	strb	r2, [r3, #0]
      }
#endif
    } else
#endif /* LWIP_DNS_SUPPORT_MDNS_QUERIES */
    {
      dst_port = DNS_SERVER_PORT;
 80071ee:	2522      	movs	r5, #34	; 0x22
 80071f0:	197b      	adds	r3, r7, r5
 80071f2:	2235      	movs	r2, #53	; 0x35
 80071f4:	801a      	strh	r2, [r3, #0]
      dst = &dns_servers[entry->server_idx];
 80071f6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80071f8:	7adb      	ldrb	r3, [r3, #11]
 80071fa:	009a      	lsls	r2, r3, #2
 80071fc:	4b1a      	ldr	r3, [pc, #104]	; (8007268 <dns_send+0x228>)
 80071fe:	18d3      	adds	r3, r2, r3
 8007200:	61fb      	str	r3, [r7, #28]
    }
    err = udp_sendto(dns_pcbs[pcb_idx], p, dst, dst_port);
 8007202:	187b      	adds	r3, r7, r1
 8007204:	781a      	ldrb	r2, [r3, #0]
 8007206:	4b1a      	ldr	r3, [pc, #104]	; (8007270 <dns_send+0x230>)
 8007208:	0092      	lsls	r2, r2, #2
 800720a:	58d0      	ldr	r0, [r2, r3]
 800720c:	233f      	movs	r3, #63	; 0x3f
 800720e:	18fc      	adds	r4, r7, r3
 8007210:	197b      	adds	r3, r7, r5
 8007212:	881b      	ldrh	r3, [r3, #0]
 8007214:	69fa      	ldr	r2, [r7, #28]
 8007216:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8007218:	f00b f9f8 	bl	801260c <udp_sendto>
 800721c:	0003      	movs	r3, r0
 800721e:	7023      	strb	r3, [r4, #0]

    /* free pbuf */
    pbuf_free(p);
 8007220:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007222:	0018      	movs	r0, r3
 8007224:	f002 fcd4 	bl	8009bd0 <pbuf_free>
 8007228:	e003      	b.n	8007232 <dns_send+0x1f2>
  } else {
    err = ERR_MEM;
 800722a:	233f      	movs	r3, #63	; 0x3f
 800722c:	18fb      	adds	r3, r7, r3
 800722e:	22ff      	movs	r2, #255	; 0xff
 8007230:	701a      	strb	r2, [r3, #0]
  }

  return err;
 8007232:	233f      	movs	r3, #63	; 0x3f
 8007234:	18fb      	adds	r3, r7, r3
 8007236:	781b      	ldrb	r3, [r3, #0]
 8007238:	b25b      	sxtb	r3, r3
 800723a:	e006      	b.n	800724a <dns_send+0x20a>
        goto overflow_return;
 800723c:	46c0      	nop			; (mov r8, r8)
overflow_return:
  pbuf_free(p);
 800723e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007240:	0018      	movs	r0, r3
 8007242:	f002 fcc5 	bl	8009bd0 <pbuf_free>
  return ERR_VAL;
 8007246:	2306      	movs	r3, #6
 8007248:	425b      	negs	r3, r3
}
 800724a:	0018      	movs	r0, r3
 800724c:	46bd      	mov	sp, r7
 800724e:	b011      	add	sp, #68	; 0x44
 8007250:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007252:	46c0      	nop			; (mov r8, r8)
 8007254:	20001924 	.word	0x20001924
 8007258:	0801ee20 	.word	0x0801ee20
 800725c:	000002fa 	.word	0x000002fa
 8007260:	0801ee48 	.word	0x0801ee48
 8007264:	0801ee60 	.word	0x0801ee60
 8007268:	20001af8 	.word	0x20001af8
 800726c:	0000fffe 	.word	0x0000fffe
 8007270:	20001914 	.word	0x20001914

08007274 <dns_alloc_random_port>:

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) != 0)
static struct udp_pcb *
dns_alloc_random_port(void)
{
 8007274:	b590      	push	{r4, r7, lr}
 8007276:	b085      	sub	sp, #20
 8007278:	af00      	add	r7, sp, #0
  err_t err;
  struct udp_pcb *pcb;

  pcb = udp_new_ip_type(IPADDR_TYPE_ANY);
 800727a:	202e      	movs	r0, #46	; 0x2e
 800727c:	f00b fd3d 	bl	8012cfa <udp_new_ip_type>
 8007280:	0003      	movs	r3, r0
 8007282:	60bb      	str	r3, [r7, #8]
  if (pcb == NULL) {
 8007284:	68bb      	ldr	r3, [r7, #8]
 8007286:	2b00      	cmp	r3, #0
 8007288:	d101      	bne.n	800728e <dns_alloc_random_port+0x1a>
    /* out of memory, have to reuse an existing pcb */
    return NULL;
 800728a:	2300      	movs	r3, #0
 800728c:	e032      	b.n	80072f4 <dns_alloc_random_port+0x80>
  }
  do {
    u16_t port = (u16_t)DNS_RAND_TXID();
 800728e:	f015 fc43 	bl	801cb18 <sys_rand>
 8007292:	0002      	movs	r2, r0
 8007294:	1dbb      	adds	r3, r7, #6
 8007296:	801a      	strh	r2, [r3, #0]
    if (DNS_PORT_ALLOWED(port)) {
 8007298:	1dbb      	adds	r3, r7, #6
 800729a:	881a      	ldrh	r2, [r3, #0]
 800729c:	2380      	movs	r3, #128	; 0x80
 800729e:	00db      	lsls	r3, r3, #3
 80072a0:	429a      	cmp	r2, r3
 80072a2:	d30b      	bcc.n	80072bc <dns_alloc_random_port+0x48>
      err = udp_bind(pcb, IP_ANY_TYPE, port);
 80072a4:	230f      	movs	r3, #15
 80072a6:	18fc      	adds	r4, r7, r3
 80072a8:	1dbb      	adds	r3, r7, #6
 80072aa:	881a      	ldrh	r2, [r3, #0]
 80072ac:	4913      	ldr	r1, [pc, #76]	; (80072fc <dns_alloc_random_port+0x88>)
 80072ae:	68bb      	ldr	r3, [r7, #8]
 80072b0:	0018      	movs	r0, r3
 80072b2:	f00b fc1b 	bl	8012aec <udp_bind>
 80072b6:	0003      	movs	r3, r0
 80072b8:	7023      	strb	r3, [r4, #0]
 80072ba:	e003      	b.n	80072c4 <dns_alloc_random_port+0x50>
    } else {
      /* this port is not allowed, try again */
      err = ERR_USE;
 80072bc:	230f      	movs	r3, #15
 80072be:	18fb      	adds	r3, r7, r3
 80072c0:	22f8      	movs	r2, #248	; 0xf8
 80072c2:	701a      	strb	r2, [r3, #0]
    }
  } while (err == ERR_USE);
 80072c4:	220f      	movs	r2, #15
 80072c6:	18bb      	adds	r3, r7, r2
 80072c8:	781b      	ldrb	r3, [r3, #0]
 80072ca:	b25b      	sxtb	r3, r3
 80072cc:	3308      	adds	r3, #8
 80072ce:	d0de      	beq.n	800728e <dns_alloc_random_port+0x1a>
  if (err != ERR_OK) {
 80072d0:	18bb      	adds	r3, r7, r2
 80072d2:	781b      	ldrb	r3, [r3, #0]
 80072d4:	b25b      	sxtb	r3, r3
 80072d6:	2b00      	cmp	r3, #0
 80072d8:	d005      	beq.n	80072e6 <dns_alloc_random_port+0x72>
    udp_remove(pcb);
 80072da:	68bb      	ldr	r3, [r7, #8]
 80072dc:	0018      	movs	r0, r3
 80072de:	f00b fcb7 	bl	8012c50 <udp_remove>
    return NULL;
 80072e2:	2300      	movs	r3, #0
 80072e4:	e006      	b.n	80072f4 <dns_alloc_random_port+0x80>
  }
  udp_recv(pcb, dns_recv, NULL);
 80072e6:	4906      	ldr	r1, [pc, #24]	; (8007300 <dns_alloc_random_port+0x8c>)
 80072e8:	68bb      	ldr	r3, [r7, #8]
 80072ea:	2200      	movs	r2, #0
 80072ec:	0018      	movs	r0, r3
 80072ee:	f00b fc95 	bl	8012c1c <udp_recv>
  return pcb;
 80072f2:	68bb      	ldr	r3, [r7, #8]
}
 80072f4:	0018      	movs	r0, r3
 80072f6:	46bd      	mov	sp, r7
 80072f8:	b005      	add	sp, #20
 80072fa:	bd90      	pop	{r4, r7, pc}
 80072fc:	0802246c 	.word	0x0802246c
 8007300:	08007821 	.word	0x08007821

08007304 <dns_alloc_pcb>:
 *
 * @return an index into dns_pcbs
 */
static u8_t
dns_alloc_pcb(void)
{
 8007304:	b590      	push	{r4, r7, lr}
 8007306:	b083      	sub	sp, #12
 8007308:	af00      	add	r7, sp, #0
  u8_t i;
  u8_t idx;

  for (i = 0; i < DNS_MAX_SOURCE_PORTS; i++) {
 800730a:	1dfb      	adds	r3, r7, #7
 800730c:	2200      	movs	r2, #0
 800730e:	701a      	strb	r2, [r3, #0]
 8007310:	e00b      	b.n	800732a <dns_alloc_pcb+0x26>
    if (dns_pcbs[i] == NULL) {
 8007312:	1dfb      	adds	r3, r7, #7
 8007314:	781a      	ldrb	r2, [r3, #0]
 8007316:	4b2d      	ldr	r3, [pc, #180]	; (80073cc <dns_alloc_pcb+0xc8>)
 8007318:	0092      	lsls	r2, r2, #2
 800731a:	58d3      	ldr	r3, [r2, r3]
 800731c:	2b00      	cmp	r3, #0
 800731e:	d009      	beq.n	8007334 <dns_alloc_pcb+0x30>
  for (i = 0; i < DNS_MAX_SOURCE_PORTS; i++) {
 8007320:	1dfb      	adds	r3, r7, #7
 8007322:	781a      	ldrb	r2, [r3, #0]
 8007324:	1dfb      	adds	r3, r7, #7
 8007326:	3201      	adds	r2, #1
 8007328:	701a      	strb	r2, [r3, #0]
 800732a:	1dfb      	adds	r3, r7, #7
 800732c:	781b      	ldrb	r3, [r3, #0]
 800732e:	2b02      	cmp	r3, #2
 8007330:	d9ef      	bls.n	8007312 <dns_alloc_pcb+0xe>
 8007332:	e000      	b.n	8007336 <dns_alloc_pcb+0x32>
      break;
 8007334:	46c0      	nop			; (mov r8, r8)
    }
  }
  if (i < DNS_MAX_SOURCE_PORTS) {
 8007336:	1dfb      	adds	r3, r7, #7
 8007338:	781b      	ldrb	r3, [r3, #0]
 800733a:	2b02      	cmp	r3, #2
 800733c:	d815      	bhi.n	800736a <dns_alloc_pcb+0x66>
    dns_pcbs[i] = dns_alloc_random_port();
 800733e:	1dfb      	adds	r3, r7, #7
 8007340:	781c      	ldrb	r4, [r3, #0]
 8007342:	f7ff ff97 	bl	8007274 <dns_alloc_random_port>
 8007346:	0001      	movs	r1, r0
 8007348:	4b20      	ldr	r3, [pc, #128]	; (80073cc <dns_alloc_pcb+0xc8>)
 800734a:	00a2      	lsls	r2, r4, #2
 800734c:	50d1      	str	r1, [r2, r3]
    if (dns_pcbs[i] != NULL) {
 800734e:	1dfb      	adds	r3, r7, #7
 8007350:	781a      	ldrb	r2, [r3, #0]
 8007352:	4b1e      	ldr	r3, [pc, #120]	; (80073cc <dns_alloc_pcb+0xc8>)
 8007354:	0092      	lsls	r2, r2, #2
 8007356:	58d3      	ldr	r3, [r2, r3]
 8007358:	2b00      	cmp	r3, #0
 800735a:	d006      	beq.n	800736a <dns_alloc_pcb+0x66>
      /* succeeded */
      dns_last_pcb_idx = i;
 800735c:	4b1c      	ldr	r3, [pc, #112]	; (80073d0 <dns_alloc_pcb+0xcc>)
 800735e:	1dfa      	adds	r2, r7, #7
 8007360:	7812      	ldrb	r2, [r2, #0]
 8007362:	701a      	strb	r2, [r3, #0]
      return i;
 8007364:	1dfb      	adds	r3, r7, #7
 8007366:	781b      	ldrb	r3, [r3, #0]
 8007368:	e02c      	b.n	80073c4 <dns_alloc_pcb+0xc0>
    }
  }
  /* if we come here, creating a new UDP pcb failed, so we have to use
     an already existing one (so overflow is no issue) */
  for (i = 0, idx = (u8_t)(dns_last_pcb_idx + 1); i < DNS_MAX_SOURCE_PORTS; i++, idx++) {
 800736a:	1dfb      	adds	r3, r7, #7
 800736c:	2200      	movs	r2, #0
 800736e:	701a      	strb	r2, [r3, #0]
 8007370:	4b17      	ldr	r3, [pc, #92]	; (80073d0 <dns_alloc_pcb+0xcc>)
 8007372:	781a      	ldrb	r2, [r3, #0]
 8007374:	1dbb      	adds	r3, r7, #6
 8007376:	3201      	adds	r2, #1
 8007378:	701a      	strb	r2, [r3, #0]
 800737a:	e01e      	b.n	80073ba <dns_alloc_pcb+0xb6>
    if (idx >= DNS_MAX_SOURCE_PORTS) {
 800737c:	1dbb      	adds	r3, r7, #6
 800737e:	781b      	ldrb	r3, [r3, #0]
 8007380:	2b02      	cmp	r3, #2
 8007382:	d902      	bls.n	800738a <dns_alloc_pcb+0x86>
      idx = 0;
 8007384:	1dbb      	adds	r3, r7, #6
 8007386:	2200      	movs	r2, #0
 8007388:	701a      	strb	r2, [r3, #0]
    }
    if (dns_pcbs[idx] != NULL) {
 800738a:	1dbb      	adds	r3, r7, #6
 800738c:	781a      	ldrb	r2, [r3, #0]
 800738e:	4b0f      	ldr	r3, [pc, #60]	; (80073cc <dns_alloc_pcb+0xc8>)
 8007390:	0092      	lsls	r2, r2, #2
 8007392:	58d3      	ldr	r3, [r2, r3]
 8007394:	2b00      	cmp	r3, #0
 8007396:	d006      	beq.n	80073a6 <dns_alloc_pcb+0xa2>
      dns_last_pcb_idx = idx;
 8007398:	4b0d      	ldr	r3, [pc, #52]	; (80073d0 <dns_alloc_pcb+0xcc>)
 800739a:	1dba      	adds	r2, r7, #6
 800739c:	7812      	ldrb	r2, [r2, #0]
 800739e:	701a      	strb	r2, [r3, #0]
      return idx;
 80073a0:	1dbb      	adds	r3, r7, #6
 80073a2:	781b      	ldrb	r3, [r3, #0]
 80073a4:	e00e      	b.n	80073c4 <dns_alloc_pcb+0xc0>
  for (i = 0, idx = (u8_t)(dns_last_pcb_idx + 1); i < DNS_MAX_SOURCE_PORTS; i++, idx++) {
 80073a6:	1dfb      	adds	r3, r7, #7
 80073a8:	781a      	ldrb	r2, [r3, #0]
 80073aa:	1dfb      	adds	r3, r7, #7
 80073ac:	3201      	adds	r2, #1
 80073ae:	701a      	strb	r2, [r3, #0]
 80073b0:	1dbb      	adds	r3, r7, #6
 80073b2:	781a      	ldrb	r2, [r3, #0]
 80073b4:	1dbb      	adds	r3, r7, #6
 80073b6:	3201      	adds	r2, #1
 80073b8:	701a      	strb	r2, [r3, #0]
 80073ba:	1dfb      	adds	r3, r7, #7
 80073bc:	781b      	ldrb	r3, [r3, #0]
 80073be:	2b02      	cmp	r3, #2
 80073c0:	d9dc      	bls.n	800737c <dns_alloc_pcb+0x78>
    }
  }
  return DNS_MAX_SOURCE_PORTS;
 80073c2:	2303      	movs	r3, #3
}
 80073c4:	0018      	movs	r0, r3
 80073c6:	46bd      	mov	sp, r7
 80073c8:	b003      	add	sp, #12
 80073ca:	bd90      	pop	{r4, r7, pc}
 80073cc:	20001914 	.word	0x20001914
 80073d0:	20001920 	.word	0x20001920

080073d4 <dns_call_found>:
 * @param idx dns table index of the entry that is resolved or removed
 * @param addr IP address for the hostname (or NULL on error or memory shortage)
 */
static void
dns_call_found(u8_t idx, ip_addr_t *addr)
{
 80073d4:	b5b0      	push	{r4, r5, r7, lr}
 80073d6:	b084      	sub	sp, #16
 80073d8:	af00      	add	r7, sp, #0
 80073da:	0002      	movs	r2, r0
 80073dc:	6039      	str	r1, [r7, #0]
 80073de:	1dfb      	adds	r3, r7, #7
 80073e0:	701a      	strb	r2, [r3, #0]
    }
  }
#endif /* LWIP_IPV4 && LWIP_IPV6 */

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING) != 0)
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
 80073e2:	230f      	movs	r3, #15
 80073e4:	18fb      	adds	r3, r7, r3
 80073e6:	2200      	movs	r2, #0
 80073e8:	701a      	strb	r2, [r3, #0]
 80073ea:	e046      	b.n	800747a <dns_call_found+0xa6>
    if (dns_requests[i].found && (dns_requests[i].dns_table_idx == idx)) {
 80073ec:	250f      	movs	r5, #15
 80073ee:	197b      	adds	r3, r7, r5
 80073f0:	781a      	ldrb	r2, [r3, #0]
 80073f2:	4964      	ldr	r1, [pc, #400]	; (8007584 <dns_call_found+0x1b0>)
 80073f4:	0013      	movs	r3, r2
 80073f6:	005b      	lsls	r3, r3, #1
 80073f8:	189b      	adds	r3, r3, r2
 80073fa:	009b      	lsls	r3, r3, #2
 80073fc:	585b      	ldr	r3, [r3, r1]
 80073fe:	2b00      	cmp	r3, #0
 8007400:	d035      	beq.n	800746e <dns_call_found+0x9a>
 8007402:	197b      	adds	r3, r7, r5
 8007404:	781a      	ldrb	r2, [r3, #0]
 8007406:	495f      	ldr	r1, [pc, #380]	; (8007584 <dns_call_found+0x1b0>)
 8007408:	0013      	movs	r3, r2
 800740a:	005b      	lsls	r3, r3, #1
 800740c:	189b      	adds	r3, r3, r2
 800740e:	009b      	lsls	r3, r3, #2
 8007410:	18cb      	adds	r3, r1, r3
 8007412:	3308      	adds	r3, #8
 8007414:	781b      	ldrb	r3, [r3, #0]
 8007416:	1dfa      	adds	r2, r7, #7
 8007418:	7812      	ldrb	r2, [r2, #0]
 800741a:	429a      	cmp	r2, r3
 800741c:	d127      	bne.n	800746e <dns_call_found+0x9a>
      (*dns_requests[i].found)(dns_table[idx].name, addr, dns_requests[i].arg);
 800741e:	197b      	adds	r3, r7, r5
 8007420:	781a      	ldrb	r2, [r3, #0]
 8007422:	4958      	ldr	r1, [pc, #352]	; (8007584 <dns_call_found+0x1b0>)
 8007424:	0013      	movs	r3, r2
 8007426:	005b      	lsls	r3, r3, #1
 8007428:	189b      	adds	r3, r3, r2
 800742a:	009b      	lsls	r3, r3, #2
 800742c:	585c      	ldr	r4, [r3, r1]
 800742e:	1dfb      	adds	r3, r7, #7
 8007430:	781a      	ldrb	r2, [r3, #0]
 8007432:	0013      	movs	r3, r2
 8007434:	00db      	lsls	r3, r3, #3
 8007436:	189b      	adds	r3, r3, r2
 8007438:	011b      	lsls	r3, r3, #4
 800743a:	3310      	adds	r3, #16
 800743c:	001a      	movs	r2, r3
 800743e:	4b52      	ldr	r3, [pc, #328]	; (8007588 <dns_call_found+0x1b4>)
 8007440:	18d0      	adds	r0, r2, r3
 8007442:	197b      	adds	r3, r7, r5
 8007444:	781a      	ldrb	r2, [r3, #0]
 8007446:	494f      	ldr	r1, [pc, #316]	; (8007584 <dns_call_found+0x1b0>)
 8007448:	0013      	movs	r3, r2
 800744a:	005b      	lsls	r3, r3, #1
 800744c:	189b      	adds	r3, r3, r2
 800744e:	009b      	lsls	r3, r3, #2
 8007450:	18cb      	adds	r3, r1, r3
 8007452:	3304      	adds	r3, #4
 8007454:	681a      	ldr	r2, [r3, #0]
 8007456:	683b      	ldr	r3, [r7, #0]
 8007458:	0019      	movs	r1, r3
 800745a:	47a0      	blx	r4
      /* flush this entry */
      dns_requests[i].found = NULL;
 800745c:	197b      	adds	r3, r7, r5
 800745e:	781a      	ldrb	r2, [r3, #0]
 8007460:	4948      	ldr	r1, [pc, #288]	; (8007584 <dns_call_found+0x1b0>)
 8007462:	0013      	movs	r3, r2
 8007464:	005b      	lsls	r3, r3, #1
 8007466:	189b      	adds	r3, r3, r2
 8007468:	009b      	lsls	r3, r3, #2
 800746a:	2200      	movs	r2, #0
 800746c:	505a      	str	r2, [r3, r1]
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
 800746e:	210f      	movs	r1, #15
 8007470:	187b      	adds	r3, r7, r1
 8007472:	781a      	ldrb	r2, [r3, #0]
 8007474:	187b      	adds	r3, r7, r1
 8007476:	3201      	adds	r2, #1
 8007478:	701a      	strb	r2, [r3, #0]
 800747a:	220f      	movs	r2, #15
 800747c:	18bb      	adds	r3, r7, r2
 800747e:	781b      	ldrb	r3, [r3, #0]
 8007480:	2b02      	cmp	r3, #2
 8007482:	d9b3      	bls.n	80073ec <dns_call_found+0x18>
  }
  dns_requests[idx].found = NULL;
#endif
#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) != 0)
  /* close the pcb used unless other request are using it */
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
 8007484:	18bb      	adds	r3, r7, r2
 8007486:	2200      	movs	r2, #0
 8007488:	701a      	strb	r2, [r3, #0]
 800748a:	e03b      	b.n	8007504 <dns_call_found+0x130>
    if (i == idx) {
 800748c:	200f      	movs	r0, #15
 800748e:	183a      	adds	r2, r7, r0
 8007490:	1dfb      	adds	r3, r7, #7
 8007492:	7812      	ldrb	r2, [r2, #0]
 8007494:	781b      	ldrb	r3, [r3, #0]
 8007496:	429a      	cmp	r2, r3
 8007498:	d02d      	beq.n	80074f6 <dns_call_found+0x122>
      continue; /* only check other requests */
    }
    if (dns_table[i].state == DNS_STATE_ASKING) {
 800749a:	183b      	adds	r3, r7, r0
 800749c:	781a      	ldrb	r2, [r3, #0]
 800749e:	493a      	ldr	r1, [pc, #232]	; (8007588 <dns_call_found+0x1b4>)
 80074a0:	0013      	movs	r3, r2
 80074a2:	00db      	lsls	r3, r3, #3
 80074a4:	189b      	adds	r3, r3, r2
 80074a6:	011b      	lsls	r3, r3, #4
 80074a8:	18cb      	adds	r3, r1, r3
 80074aa:	330a      	adds	r3, #10
 80074ac:	781b      	ldrb	r3, [r3, #0]
 80074ae:	2b02      	cmp	r3, #2
 80074b0:	d122      	bne.n	80074f8 <dns_call_found+0x124>
      if (dns_table[i].pcb_idx == dns_table[idx].pcb_idx) {
 80074b2:	183b      	adds	r3, r7, r0
 80074b4:	781a      	ldrb	r2, [r3, #0]
 80074b6:	4934      	ldr	r1, [pc, #208]	; (8007588 <dns_call_found+0x1b4>)
 80074b8:	0013      	movs	r3, r2
 80074ba:	00db      	lsls	r3, r3, #3
 80074bc:	189b      	adds	r3, r3, r2
 80074be:	011b      	lsls	r3, r3, #4
 80074c0:	18cb      	adds	r3, r1, r3
 80074c2:	330f      	adds	r3, #15
 80074c4:	7819      	ldrb	r1, [r3, #0]
 80074c6:	1dfb      	adds	r3, r7, #7
 80074c8:	781a      	ldrb	r2, [r3, #0]
 80074ca:	482f      	ldr	r0, [pc, #188]	; (8007588 <dns_call_found+0x1b4>)
 80074cc:	0013      	movs	r3, r2
 80074ce:	00db      	lsls	r3, r3, #3
 80074d0:	189b      	adds	r3, r3, r2
 80074d2:	011b      	lsls	r3, r3, #4
 80074d4:	18c3      	adds	r3, r0, r3
 80074d6:	330f      	adds	r3, #15
 80074d8:	781b      	ldrb	r3, [r3, #0]
 80074da:	4299      	cmp	r1, r3
 80074dc:	d10c      	bne.n	80074f8 <dns_call_found+0x124>
        /* another request is still using the same pcb */
        dns_table[idx].pcb_idx = DNS_MAX_SOURCE_PORTS;
 80074de:	1dfb      	adds	r3, r7, #7
 80074e0:	781a      	ldrb	r2, [r3, #0]
 80074e2:	4929      	ldr	r1, [pc, #164]	; (8007588 <dns_call_found+0x1b4>)
 80074e4:	0013      	movs	r3, r2
 80074e6:	00db      	lsls	r3, r3, #3
 80074e8:	189b      	adds	r3, r3, r2
 80074ea:	011b      	lsls	r3, r3, #4
 80074ec:	18cb      	adds	r3, r1, r3
 80074ee:	330f      	adds	r3, #15
 80074f0:	2203      	movs	r2, #3
 80074f2:	701a      	strb	r2, [r3, #0]
        break;
 80074f4:	e00b      	b.n	800750e <dns_call_found+0x13a>
      continue; /* only check other requests */
 80074f6:	46c0      	nop			; (mov r8, r8)
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
 80074f8:	210f      	movs	r1, #15
 80074fa:	187b      	adds	r3, r7, r1
 80074fc:	781a      	ldrb	r2, [r3, #0]
 80074fe:	187b      	adds	r3, r7, r1
 8007500:	3201      	adds	r2, #1
 8007502:	701a      	strb	r2, [r3, #0]
 8007504:	230f      	movs	r3, #15
 8007506:	18fb      	adds	r3, r7, r3
 8007508:	781b      	ldrb	r3, [r3, #0]
 800750a:	2b02      	cmp	r3, #2
 800750c:	d9be      	bls.n	800748c <dns_call_found+0xb8>
      }
    }
  }
  if (dns_table[idx].pcb_idx < DNS_MAX_SOURCE_PORTS) {
 800750e:	1dfb      	adds	r3, r7, #7
 8007510:	781a      	ldrb	r2, [r3, #0]
 8007512:	491d      	ldr	r1, [pc, #116]	; (8007588 <dns_call_found+0x1b4>)
 8007514:	0013      	movs	r3, r2
 8007516:	00db      	lsls	r3, r3, #3
 8007518:	189b      	adds	r3, r3, r2
 800751a:	011b      	lsls	r3, r3, #4
 800751c:	18cb      	adds	r3, r1, r3
 800751e:	330f      	adds	r3, #15
 8007520:	781b      	ldrb	r3, [r3, #0]
 8007522:	2b02      	cmp	r3, #2
 8007524:	d82a      	bhi.n	800757c <dns_call_found+0x1a8>
    /* if we come here, the pcb is not used any more and can be removed */
    udp_remove(dns_pcbs[dns_table[idx].pcb_idx]);
 8007526:	1dfb      	adds	r3, r7, #7
 8007528:	781a      	ldrb	r2, [r3, #0]
 800752a:	4917      	ldr	r1, [pc, #92]	; (8007588 <dns_call_found+0x1b4>)
 800752c:	0013      	movs	r3, r2
 800752e:	00db      	lsls	r3, r3, #3
 8007530:	189b      	adds	r3, r3, r2
 8007532:	011b      	lsls	r3, r3, #4
 8007534:	18cb      	adds	r3, r1, r3
 8007536:	330f      	adds	r3, #15
 8007538:	781b      	ldrb	r3, [r3, #0]
 800753a:	001a      	movs	r2, r3
 800753c:	4b13      	ldr	r3, [pc, #76]	; (800758c <dns_call_found+0x1b8>)
 800753e:	0092      	lsls	r2, r2, #2
 8007540:	58d3      	ldr	r3, [r2, r3]
 8007542:	0018      	movs	r0, r3
 8007544:	f00b fb84 	bl	8012c50 <udp_remove>
    dns_pcbs[dns_table[idx].pcb_idx] = NULL;
 8007548:	1dfb      	adds	r3, r7, #7
 800754a:	781a      	ldrb	r2, [r3, #0]
 800754c:	490e      	ldr	r1, [pc, #56]	; (8007588 <dns_call_found+0x1b4>)
 800754e:	0013      	movs	r3, r2
 8007550:	00db      	lsls	r3, r3, #3
 8007552:	189b      	adds	r3, r3, r2
 8007554:	011b      	lsls	r3, r3, #4
 8007556:	18cb      	adds	r3, r1, r3
 8007558:	330f      	adds	r3, #15
 800755a:	781b      	ldrb	r3, [r3, #0]
 800755c:	001a      	movs	r2, r3
 800755e:	4b0b      	ldr	r3, [pc, #44]	; (800758c <dns_call_found+0x1b8>)
 8007560:	0092      	lsls	r2, r2, #2
 8007562:	2100      	movs	r1, #0
 8007564:	50d1      	str	r1, [r2, r3]
    dns_table[idx].pcb_idx = DNS_MAX_SOURCE_PORTS;
 8007566:	1dfb      	adds	r3, r7, #7
 8007568:	781a      	ldrb	r2, [r3, #0]
 800756a:	4907      	ldr	r1, [pc, #28]	; (8007588 <dns_call_found+0x1b4>)
 800756c:	0013      	movs	r3, r2
 800756e:	00db      	lsls	r3, r3, #3
 8007570:	189b      	adds	r3, r3, r2
 8007572:	011b      	lsls	r3, r3, #4
 8007574:	18cb      	adds	r3, r1, r3
 8007576:	330f      	adds	r3, #15
 8007578:	2203      	movs	r2, #3
 800757a:	701a      	strb	r2, [r3, #0]
  }
#endif
}
 800757c:	46c0      	nop			; (mov r8, r8)
 800757e:	46bd      	mov	sp, r7
 8007580:	b004      	add	sp, #16
 8007582:	bdb0      	pop	{r4, r5, r7, pc}
 8007584:	20001ad4 	.word	0x20001ad4
 8007588:	20001924 	.word	0x20001924
 800758c:	20001914 	.word	0x20001914

08007590 <dns_create_txid>:

/* Create a query transmission ID that is unique for all outstanding queries */
static u16_t
dns_create_txid(void)
{
 8007590:	b580      	push	{r7, lr}
 8007592:	b082      	sub	sp, #8
 8007594:	af00      	add	r7, sp, #0
  u16_t txid;
  u8_t i;

again:
  txid = (u16_t)DNS_RAND_TXID();
 8007596:	f015 fabf 	bl	801cb18 <sys_rand>
 800759a:	0002      	movs	r2, r0
 800759c:	1d3b      	adds	r3, r7, #4
 800759e:	801a      	strh	r2, [r3, #0]

  /* check whether the ID is unique */
  for (i = 0; i < DNS_TABLE_SIZE; i++) {
 80075a0:	1dfb      	adds	r3, r7, #7
 80075a2:	2200      	movs	r2, #0
 80075a4:	701a      	strb	r2, [r3, #0]
 80075a6:	e01f      	b.n	80075e8 <dns_create_txid+0x58>
    if ((dns_table[i].state == DNS_STATE_ASKING) &&
 80075a8:	1dfb      	adds	r3, r7, #7
 80075aa:	781a      	ldrb	r2, [r3, #0]
 80075ac:	4913      	ldr	r1, [pc, #76]	; (80075fc <dns_create_txid+0x6c>)
 80075ae:	0013      	movs	r3, r2
 80075b0:	00db      	lsls	r3, r3, #3
 80075b2:	189b      	adds	r3, r3, r2
 80075b4:	011b      	lsls	r3, r3, #4
 80075b6:	18cb      	adds	r3, r1, r3
 80075b8:	330a      	adds	r3, #10
 80075ba:	781b      	ldrb	r3, [r3, #0]
 80075bc:	2b02      	cmp	r3, #2
 80075be:	d10e      	bne.n	80075de <dns_create_txid+0x4e>
        (dns_table[i].txid == txid)) {
 80075c0:	1dfb      	adds	r3, r7, #7
 80075c2:	781a      	ldrb	r2, [r3, #0]
 80075c4:	490d      	ldr	r1, [pc, #52]	; (80075fc <dns_create_txid+0x6c>)
 80075c6:	0013      	movs	r3, r2
 80075c8:	00db      	lsls	r3, r3, #3
 80075ca:	189b      	adds	r3, r3, r2
 80075cc:	011b      	lsls	r3, r3, #4
 80075ce:	18cb      	adds	r3, r1, r3
 80075d0:	3308      	adds	r3, #8
 80075d2:	881b      	ldrh	r3, [r3, #0]
    if ((dns_table[i].state == DNS_STATE_ASKING) &&
 80075d4:	1d3a      	adds	r2, r7, #4
 80075d6:	8812      	ldrh	r2, [r2, #0]
 80075d8:	429a      	cmp	r2, r3
 80075da:	d100      	bne.n	80075de <dns_create_txid+0x4e>
      /* ID already used by another pending query */
      goto again;
 80075dc:	e7db      	b.n	8007596 <dns_create_txid+0x6>
  for (i = 0; i < DNS_TABLE_SIZE; i++) {
 80075de:	1dfb      	adds	r3, r7, #7
 80075e0:	781a      	ldrb	r2, [r3, #0]
 80075e2:	1dfb      	adds	r3, r7, #7
 80075e4:	3201      	adds	r2, #1
 80075e6:	701a      	strb	r2, [r3, #0]
 80075e8:	1dfb      	adds	r3, r7, #7
 80075ea:	781b      	ldrb	r3, [r3, #0]
 80075ec:	2b02      	cmp	r3, #2
 80075ee:	d9db      	bls.n	80075a8 <dns_create_txid+0x18>
    }
  }

  return txid;
 80075f0:	1d3b      	adds	r3, r7, #4
 80075f2:	881b      	ldrh	r3, [r3, #0]
}
 80075f4:	0018      	movs	r0, r3
 80075f6:	46bd      	mov	sp, r7
 80075f8:	b002      	add	sp, #8
 80075fa:	bd80      	pop	{r7, pc}
 80075fc:	20001924 	.word	0x20001924

08007600 <dns_backupserver_available>:
/**
 * Check whether there are other backup DNS servers available to try
 */
static u8_t
dns_backupserver_available(struct dns_table_entry *pentry)
{
 8007600:	b580      	push	{r7, lr}
 8007602:	b084      	sub	sp, #16
 8007604:	af00      	add	r7, sp, #0
 8007606:	6078      	str	r0, [r7, #4]
  u8_t ret = 0;
 8007608:	210f      	movs	r1, #15
 800760a:	187b      	adds	r3, r7, r1
 800760c:	2200      	movs	r2, #0
 800760e:	701a      	strb	r2, [r3, #0]

  if (pentry) {
 8007610:	687b      	ldr	r3, [r7, #4]
 8007612:	2b00      	cmp	r3, #0
 8007614:	d00e      	beq.n	8007634 <dns_backupserver_available+0x34>
    if ((pentry->server_idx + 1 < DNS_MAX_SERVERS) && !ip_addr_isany_val(dns_servers[pentry->server_idx + 1])) {
 8007616:	687b      	ldr	r3, [r7, #4]
 8007618:	7adb      	ldrb	r3, [r3, #11]
 800761a:	2b00      	cmp	r3, #0
 800761c:	d10a      	bne.n	8007634 <dns_backupserver_available+0x34>
 800761e:	687b      	ldr	r3, [r7, #4]
 8007620:	7adb      	ldrb	r3, [r3, #11]
 8007622:	1c5a      	adds	r2, r3, #1
 8007624:	4b07      	ldr	r3, [pc, #28]	; (8007644 <dns_backupserver_available+0x44>)
 8007626:	0092      	lsls	r2, r2, #2
 8007628:	58d3      	ldr	r3, [r2, r3]
 800762a:	2b00      	cmp	r3, #0
 800762c:	d002      	beq.n	8007634 <dns_backupserver_available+0x34>
      ret = 1;
 800762e:	187b      	adds	r3, r7, r1
 8007630:	2201      	movs	r2, #1
 8007632:	701a      	strb	r2, [r3, #0]
    }
  }

  return ret;
 8007634:	230f      	movs	r3, #15
 8007636:	18fb      	adds	r3, r7, r3
 8007638:	781b      	ldrb	r3, [r3, #0]
}
 800763a:	0018      	movs	r0, r3
 800763c:	46bd      	mov	sp, r7
 800763e:	b004      	add	sp, #16
 8007640:	bd80      	pop	{r7, pc}
 8007642:	46c0      	nop			; (mov r8, r8)
 8007644:	20001af8 	.word	0x20001af8

08007648 <dns_check_entry>:
 *
 * @param i index of the dns_table entry to check
 */
static void
dns_check_entry(u8_t i)
{
 8007648:	b590      	push	{r4, r7, lr}
 800764a:	b085      	sub	sp, #20
 800764c:	af00      	add	r7, sp, #0
 800764e:	0002      	movs	r2, r0
 8007650:	1dfb      	adds	r3, r7, #7
 8007652:	701a      	strb	r2, [r3, #0]
  err_t err;
  struct dns_table_entry *entry = &dns_table[i];
 8007654:	1dfb      	adds	r3, r7, #7
 8007656:	781a      	ldrb	r2, [r3, #0]
 8007658:	0013      	movs	r3, r2
 800765a:	00db      	lsls	r3, r3, #3
 800765c:	189b      	adds	r3, r3, r2
 800765e:	011b      	lsls	r3, r3, #4
 8007660:	4a4b      	ldr	r2, [pc, #300]	; (8007790 <dns_check_entry+0x148>)
 8007662:	189b      	adds	r3, r3, r2
 8007664:	60fb      	str	r3, [r7, #12]

  LWIP_ASSERT("array index out of bounds", i < DNS_TABLE_SIZE);
 8007666:	1dfb      	adds	r3, r7, #7
 8007668:	781b      	ldrb	r3, [r3, #0]
 800766a:	2b02      	cmp	r3, #2
 800766c:	d905      	bls.n	800767a <dns_check_entry+0x32>
 800766e:	4b49      	ldr	r3, [pc, #292]	; (8007794 <dns_check_entry+0x14c>)
 8007670:	4a49      	ldr	r2, [pc, #292]	; (8007798 <dns_check_entry+0x150>)
 8007672:	494a      	ldr	r1, [pc, #296]	; (800779c <dns_check_entry+0x154>)
 8007674:	484a      	ldr	r0, [pc, #296]	; (80077a0 <dns_check_entry+0x158>)
 8007676:	f7fb f931 	bl	80028dc <app_debug_rtt_raw>

  switch (entry->state) {
 800767a:	68fb      	ldr	r3, [r7, #12]
 800767c:	7a9b      	ldrb	r3, [r3, #10]
 800767e:	2b03      	cmp	r3, #3
 8007680:	d065      	beq.n	800774e <dns_check_entry+0x106>
 8007682:	dd00      	ble.n	8007686 <dns_check_entry+0x3e>
 8007684:	e074      	b.n	8007770 <dns_check_entry+0x128>
 8007686:	2b02      	cmp	r3, #2
 8007688:	d022      	beq.n	80076d0 <dns_check_entry+0x88>
 800768a:	dd00      	ble.n	800768e <dns_check_entry+0x46>
 800768c:	e070      	b.n	8007770 <dns_check_entry+0x128>
 800768e:	2b00      	cmp	r3, #0
 8007690:	d100      	bne.n	8007694 <dns_check_entry+0x4c>
 8007692:	e074      	b.n	800777e <dns_check_entry+0x136>
 8007694:	2b01      	cmp	r3, #1
 8007696:	d16b      	bne.n	8007770 <dns_check_entry+0x128>
    case DNS_STATE_NEW:
      /* initialize new entry */
      entry->txid = dns_create_txid();
 8007698:	f7ff ff7a 	bl	8007590 <dns_create_txid>
 800769c:	0003      	movs	r3, r0
 800769e:	001a      	movs	r2, r3
 80076a0:	68fb      	ldr	r3, [r7, #12]
 80076a2:	811a      	strh	r2, [r3, #8]
      entry->state = DNS_STATE_ASKING;
 80076a4:	68fb      	ldr	r3, [r7, #12]
 80076a6:	2202      	movs	r2, #2
 80076a8:	729a      	strb	r2, [r3, #10]
      entry->server_idx = 0;
 80076aa:	68fb      	ldr	r3, [r7, #12]
 80076ac:	2200      	movs	r2, #0
 80076ae:	72da      	strb	r2, [r3, #11]
      entry->tmr = 1;
 80076b0:	68fb      	ldr	r3, [r7, #12]
 80076b2:	2201      	movs	r2, #1
 80076b4:	731a      	strb	r2, [r3, #12]
      entry->retries = 0;
 80076b6:	68fb      	ldr	r3, [r7, #12]
 80076b8:	2200      	movs	r2, #0
 80076ba:	735a      	strb	r2, [r3, #13]

      /* send DNS packet for this entry */
      err = dns_send(i);
 80076bc:	230b      	movs	r3, #11
 80076be:	18fc      	adds	r4, r7, r3
 80076c0:	1dfb      	adds	r3, r7, #7
 80076c2:	781b      	ldrb	r3, [r3, #0]
 80076c4:	0018      	movs	r0, r3
 80076c6:	f7ff fcbb 	bl	8007040 <dns_send>
 80076ca:	0003      	movs	r3, r0
 80076cc:	7023      	strb	r3, [r4, #0]
      if (err != ERR_OK) {
        LWIP_DEBUGF(DNS_DEBUG | LWIP_DBG_LEVEL_WARNING,
                    ("dns_send returned error: %s\n", lwip_strerr(err)));
      }
      break;
 80076ce:	e05b      	b.n	8007788 <dns_check_entry+0x140>
    case DNS_STATE_ASKING:
      if (--entry->tmr == 0) {
 80076d0:	68fb      	ldr	r3, [r7, #12]
 80076d2:	7b1b      	ldrb	r3, [r3, #12]
 80076d4:	3b01      	subs	r3, #1
 80076d6:	b2da      	uxtb	r2, r3
 80076d8:	68fb      	ldr	r3, [r7, #12]
 80076da:	731a      	strb	r2, [r3, #12]
 80076dc:	68fb      	ldr	r3, [r7, #12]
 80076de:	7b1b      	ldrb	r3, [r3, #12]
 80076e0:	2b00      	cmp	r3, #0
 80076e2:	d14e      	bne.n	8007782 <dns_check_entry+0x13a>
        if (++entry->retries == DNS_MAX_RETRIES) {
 80076e4:	68fb      	ldr	r3, [r7, #12]
 80076e6:	7b5b      	ldrb	r3, [r3, #13]
 80076e8:	3301      	adds	r3, #1
 80076ea:	b2da      	uxtb	r2, r3
 80076ec:	68fb      	ldr	r3, [r7, #12]
 80076ee:	735a      	strb	r2, [r3, #13]
 80076f0:	68fb      	ldr	r3, [r7, #12]
 80076f2:	7b5b      	ldrb	r3, [r3, #13]
 80076f4:	2b04      	cmp	r3, #4
 80076f6:	d11c      	bne.n	8007732 <dns_check_entry+0xea>
          if (dns_backupserver_available(entry)
 80076f8:	68fb      	ldr	r3, [r7, #12]
 80076fa:	0018      	movs	r0, r3
 80076fc:	f7ff ff80 	bl	8007600 <dns_backupserver_available>
 8007700:	1e03      	subs	r3, r0, #0
 8007702:	d00c      	beq.n	800771e <dns_check_entry+0xd6>
#if LWIP_DNS_SUPPORT_MDNS_QUERIES
              && !entry->is_mdns
#endif /* LWIP_DNS_SUPPORT_MDNS_QUERIES */
             ) {
            /* change of server */
            entry->server_idx++;
 8007704:	68fb      	ldr	r3, [r7, #12]
 8007706:	7adb      	ldrb	r3, [r3, #11]
 8007708:	3301      	adds	r3, #1
 800770a:	b2da      	uxtb	r2, r3
 800770c:	68fb      	ldr	r3, [r7, #12]
 800770e:	72da      	strb	r2, [r3, #11]
            entry->tmr = 1;
 8007710:	68fb      	ldr	r3, [r7, #12]
 8007712:	2201      	movs	r2, #1
 8007714:	731a      	strb	r2, [r3, #12]
            entry->retries = 0;
 8007716:	68fb      	ldr	r3, [r7, #12]
 8007718:	2200      	movs	r2, #0
 800771a:	735a      	strb	r2, [r3, #13]
 800771c:	e00d      	b.n	800773a <dns_check_entry+0xf2>
          } else {
            LWIP_DEBUGF(DNS_DEBUG, ("dns_check_entry: \"%s\": timeout\n", entry->name));
            /* call specified callback function if provided */
            dns_call_found(i, NULL);
 800771e:	1dfb      	adds	r3, r7, #7
 8007720:	781b      	ldrb	r3, [r3, #0]
 8007722:	2100      	movs	r1, #0
 8007724:	0018      	movs	r0, r3
 8007726:	f7ff fe55 	bl	80073d4 <dns_call_found>
            /* flush this entry */
            entry->state = DNS_STATE_UNUSED;
 800772a:	68fb      	ldr	r3, [r7, #12]
 800772c:	2200      	movs	r2, #0
 800772e:	729a      	strb	r2, [r3, #10]
            break;
 8007730:	e02a      	b.n	8007788 <dns_check_entry+0x140>
          }
        } else {
          /* wait longer for the next retry */
          entry->tmr = entry->retries;
 8007732:	68fb      	ldr	r3, [r7, #12]
 8007734:	7b5a      	ldrb	r2, [r3, #13]
 8007736:	68fb      	ldr	r3, [r7, #12]
 8007738:	731a      	strb	r2, [r3, #12]
        }

        /* send DNS packet for this entry */
        err = dns_send(i);
 800773a:	230b      	movs	r3, #11
 800773c:	18fc      	adds	r4, r7, r3
 800773e:	1dfb      	adds	r3, r7, #7
 8007740:	781b      	ldrb	r3, [r3, #0]
 8007742:	0018      	movs	r0, r3
 8007744:	f7ff fc7c 	bl	8007040 <dns_send>
 8007748:	0003      	movs	r3, r0
 800774a:	7023      	strb	r3, [r4, #0]
        if (err != ERR_OK) {
          LWIP_DEBUGF(DNS_DEBUG | LWIP_DBG_LEVEL_WARNING,
                      ("dns_send returned error: %s\n", lwip_strerr(err)));
        }
      }
      break;
 800774c:	e019      	b.n	8007782 <dns_check_entry+0x13a>
    case DNS_STATE_DONE:
      /* if the time to live is nul */
      if ((entry->ttl == 0) || (--entry->ttl == 0)) {
 800774e:	68fb      	ldr	r3, [r7, #12]
 8007750:	681b      	ldr	r3, [r3, #0]
 8007752:	2b00      	cmp	r3, #0
 8007754:	d008      	beq.n	8007768 <dns_check_entry+0x120>
 8007756:	68fb      	ldr	r3, [r7, #12]
 8007758:	681b      	ldr	r3, [r3, #0]
 800775a:	1e5a      	subs	r2, r3, #1
 800775c:	68fb      	ldr	r3, [r7, #12]
 800775e:	601a      	str	r2, [r3, #0]
 8007760:	68fb      	ldr	r3, [r7, #12]
 8007762:	681b      	ldr	r3, [r3, #0]
 8007764:	2b00      	cmp	r3, #0
 8007766:	d10e      	bne.n	8007786 <dns_check_entry+0x13e>
        LWIP_DEBUGF(DNS_DEBUG, ("dns_check_entry: \"%s\": flush\n", entry->name));
        /* flush this entry, there cannot be any related pending entries in this state */
        entry->state = DNS_STATE_UNUSED;
 8007768:	68fb      	ldr	r3, [r7, #12]
 800776a:	2200      	movs	r2, #0
 800776c:	729a      	strb	r2, [r3, #10]
      }
      break;
 800776e:	e00a      	b.n	8007786 <dns_check_entry+0x13e>
    case DNS_STATE_UNUSED:
      /* nothing to do */
      break;
    default:
      LWIP_ASSERT("unknown dns_table entry state:", 0);
 8007770:	4b08      	ldr	r3, [pc, #32]	; (8007794 <dns_check_entry+0x14c>)
 8007772:	4a0c      	ldr	r2, [pc, #48]	; (80077a4 <dns_check_entry+0x15c>)
 8007774:	490c      	ldr	r1, [pc, #48]	; (80077a8 <dns_check_entry+0x160>)
 8007776:	480a      	ldr	r0, [pc, #40]	; (80077a0 <dns_check_entry+0x158>)
 8007778:	f7fb f8b0 	bl	80028dc <app_debug_rtt_raw>
      break;
 800777c:	e004      	b.n	8007788 <dns_check_entry+0x140>
      break;
 800777e:	46c0      	nop			; (mov r8, r8)
 8007780:	e002      	b.n	8007788 <dns_check_entry+0x140>
      break;
 8007782:	46c0      	nop			; (mov r8, r8)
 8007784:	e000      	b.n	8007788 <dns_check_entry+0x140>
      break;
 8007786:	46c0      	nop			; (mov r8, r8)
  }
}
 8007788:	46c0      	nop			; (mov r8, r8)
 800778a:	46bd      	mov	sp, r7
 800778c:	b005      	add	sp, #20
 800778e:	bd90      	pop	{r4, r7, pc}
 8007790:	20001924 	.word	0x20001924
 8007794:	0801ee20 	.word	0x0801ee20
 8007798:	0000041c 	.word	0x0000041c
 800779c:	0801ee8c 	.word	0x0801ee8c
 80077a0:	0801ee60 	.word	0x0801ee60
 80077a4:	0000045b 	.word	0x0000045b
 80077a8:	0801eea8 	.word	0x0801eea8

080077ac <dns_correct_response>:
/**
 * Save TTL and call dns_call_found for correct response.
 */
static void
dns_correct_response(u8_t idx, u32_t ttl)
{
 80077ac:	b580      	push	{r7, lr}
 80077ae:	b084      	sub	sp, #16
 80077b0:	af00      	add	r7, sp, #0
 80077b2:	0002      	movs	r2, r0
 80077b4:	6039      	str	r1, [r7, #0]
 80077b6:	1dfb      	adds	r3, r7, #7
 80077b8:	701a      	strb	r2, [r3, #0]
  struct dns_table_entry *entry = &dns_table[idx];
 80077ba:	1dfb      	adds	r3, r7, #7
 80077bc:	781a      	ldrb	r2, [r3, #0]
 80077be:	0013      	movs	r3, r2
 80077c0:	00db      	lsls	r3, r3, #3
 80077c2:	189b      	adds	r3, r3, r2
 80077c4:	011b      	lsls	r3, r3, #4
 80077c6:	4a14      	ldr	r2, [pc, #80]	; (8007818 <dns_correct_response+0x6c>)
 80077c8:	189b      	adds	r3, r3, r2
 80077ca:	60fb      	str	r3, [r7, #12]

  entry->state = DNS_STATE_DONE;
 80077cc:	68fb      	ldr	r3, [r7, #12]
 80077ce:	2203      	movs	r2, #3
 80077d0:	729a      	strb	r2, [r3, #10]
  LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response = ", entry->name));
  ip_addr_debug_print_val(DNS_DEBUG, entry->ipaddr);
  LWIP_DEBUGF(DNS_DEBUG, ("\n"));

  /* read the answer resource record's TTL, and maximize it if needed */
  entry->ttl = ttl;
 80077d2:	68fb      	ldr	r3, [r7, #12]
 80077d4:	683a      	ldr	r2, [r7, #0]
 80077d6:	601a      	str	r2, [r3, #0]
  if (entry->ttl > DNS_MAX_TTL) {
 80077d8:	68fb      	ldr	r3, [r7, #12]
 80077da:	681b      	ldr	r3, [r3, #0]
 80077dc:	4a0f      	ldr	r2, [pc, #60]	; (800781c <dns_correct_response+0x70>)
 80077de:	4293      	cmp	r3, r2
 80077e0:	d902      	bls.n	80077e8 <dns_correct_response+0x3c>
    entry->ttl = DNS_MAX_TTL;
 80077e2:	68fb      	ldr	r3, [r7, #12]
 80077e4:	4a0d      	ldr	r2, [pc, #52]	; (800781c <dns_correct_response+0x70>)
 80077e6:	601a      	str	r2, [r3, #0]
  }
  dns_call_found(idx, &entry->ipaddr);
 80077e8:	68fb      	ldr	r3, [r7, #12]
 80077ea:	1d1a      	adds	r2, r3, #4
 80077ec:	1dfb      	adds	r3, r7, #7
 80077ee:	781b      	ldrb	r3, [r3, #0]
 80077f0:	0011      	movs	r1, r2
 80077f2:	0018      	movs	r0, r3
 80077f4:	f7ff fdee 	bl	80073d4 <dns_call_found>

  if (entry->ttl == 0) {
 80077f8:	68fb      	ldr	r3, [r7, #12]
 80077fa:	681b      	ldr	r3, [r3, #0]
 80077fc:	2b00      	cmp	r3, #0
 80077fe:	d106      	bne.n	800780e <dns_correct_response+0x62>
    /* RFC 883, page 29: "Zero values are
       interpreted to mean that the RR can only be used for the
       transaction in progress, and should not be cached."
       -> flush this entry now */
    /* entry reused during callback? */
    if (entry->state == DNS_STATE_DONE) {
 8007800:	68fb      	ldr	r3, [r7, #12]
 8007802:	7a9b      	ldrb	r3, [r3, #10]
 8007804:	2b03      	cmp	r3, #3
 8007806:	d102      	bne.n	800780e <dns_correct_response+0x62>
      entry->state = DNS_STATE_UNUSED;
 8007808:	68fb      	ldr	r3, [r7, #12]
 800780a:	2200      	movs	r2, #0
 800780c:	729a      	strb	r2, [r3, #10]
    }
  }
}
 800780e:	46c0      	nop			; (mov r8, r8)
 8007810:	46bd      	mov	sp, r7
 8007812:	b004      	add	sp, #16
 8007814:	bd80      	pop	{r7, pc}
 8007816:	46c0      	nop			; (mov r8, r8)
 8007818:	20001924 	.word	0x20001924
 800781c:	00093a80 	.word	0x00093a80

08007820 <dns_recv>:
/**
 * Receive input function for DNS response packets arriving for the dns UDP pcb.
 */
static void
dns_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr, u16_t port)
{
 8007820:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007822:	b091      	sub	sp, #68	; 0x44
 8007824:	af00      	add	r7, sp, #0
 8007826:	60f8      	str	r0, [r7, #12]
 8007828:	60b9      	str	r1, [r7, #8]
 800782a:	607a      	str	r2, [r7, #4]
 800782c:	603b      	str	r3, [r7, #0]
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(port);

  /* is the dns message big enough ? */
  if (p->tot_len < (SIZEOF_DNS_HDR + SIZEOF_DNS_QUERY)) {
 800782e:	687b      	ldr	r3, [r7, #4]
 8007830:	891b      	ldrh	r3, [r3, #8]
 8007832:	2b0f      	cmp	r3, #15
 8007834:	d800      	bhi.n	8007838 <dns_recv+0x18>
 8007836:	e162      	b.n	8007afe <dns_recv+0x2de>
    /* free pbuf and return */
    goto ignore_packet;
  }

  /* copy dns payload inside static buffer for processing */
  if (pbuf_copy_partial(p, &hdr, SIZEOF_DNS_HDR, 0) == SIZEOF_DNS_HDR) {
 8007838:	2424      	movs	r4, #36	; 0x24
 800783a:	1939      	adds	r1, r7, r4
 800783c:	6878      	ldr	r0, [r7, #4]
 800783e:	2300      	movs	r3, #0
 8007840:	220c      	movs	r2, #12
 8007842:	f002 fc8f 	bl	800a164 <pbuf_copy_partial>
 8007846:	0003      	movs	r3, r0
 8007848:	2b0c      	cmp	r3, #12
 800784a:	d000      	beq.n	800784e <dns_recv+0x2e>
 800784c:	e159      	b.n	8007b02 <dns_recv+0x2e2>
    /* Match the ID in the DNS header with the name table. */
    txid = lwip_htons(hdr.id);
 800784e:	193b      	adds	r3, r7, r4
 8007850:	881b      	ldrh	r3, [r3, #0]
 8007852:	2238      	movs	r2, #56	; 0x38
 8007854:	18bc      	adds	r4, r7, r2
 8007856:	0018      	movs	r0, r3
 8007858:	f7ff f9d6 	bl	8006c08 <lwip_htons>
 800785c:	0003      	movs	r3, r0
 800785e:	8023      	strh	r3, [r4, #0]
    for (i = 0; i < DNS_TABLE_SIZE; i++) {
 8007860:	233b      	movs	r3, #59	; 0x3b
 8007862:	18fb      	adds	r3, r7, r3
 8007864:	2200      	movs	r2, #0
 8007866:	701a      	strb	r2, [r3, #0]
 8007868:	e142      	b.n	8007af0 <dns_recv+0x2d0>
      struct dns_table_entry *entry = &dns_table[i];
 800786a:	233b      	movs	r3, #59	; 0x3b
 800786c:	18fb      	adds	r3, r7, r3
 800786e:	781a      	ldrb	r2, [r3, #0]
 8007870:	0013      	movs	r3, r2
 8007872:	00db      	lsls	r3, r3, #3
 8007874:	189b      	adds	r3, r3, r2
 8007876:	011b      	lsls	r3, r3, #4
 8007878:	4ab2      	ldr	r2, [pc, #712]	; (8007b44 <dns_recv+0x324>)
 800787a:	189b      	adds	r3, r3, r2
 800787c:	637b      	str	r3, [r7, #52]	; 0x34
      if ((entry->state == DNS_STATE_ASKING) &&
 800787e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007880:	7a9b      	ldrb	r3, [r3, #10]
 8007882:	2b02      	cmp	r3, #2
 8007884:	d000      	beq.n	8007888 <dns_recv+0x68>
 8007886:	e12d      	b.n	8007ae4 <dns_recv+0x2c4>
          (entry->txid == txid)) {
 8007888:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800788a:	891b      	ldrh	r3, [r3, #8]
      if ((entry->state == DNS_STATE_ASKING) &&
 800788c:	2238      	movs	r2, #56	; 0x38
 800788e:	18ba      	adds	r2, r7, r2
 8007890:	8812      	ldrh	r2, [r2, #0]
 8007892:	429a      	cmp	r2, r3
 8007894:	d000      	beq.n	8007898 <dns_recv+0x78>
 8007896:	e125      	b.n	8007ae4 <dns_recv+0x2c4>

        /* We only care about the question(s) and the answers. The authrr
           and the extrarr are simply discarded. */
        nquestions = lwip_htons(hdr.numquestions);
 8007898:	2624      	movs	r6, #36	; 0x24
 800789a:	19bb      	adds	r3, r7, r6
 800789c:	889b      	ldrh	r3, [r3, #4]
 800789e:	2532      	movs	r5, #50	; 0x32
 80078a0:	197c      	adds	r4, r7, r5
 80078a2:	0018      	movs	r0, r3
 80078a4:	f7ff f9b0 	bl	8006c08 <lwip_htons>
 80078a8:	0003      	movs	r3, r0
 80078aa:	8023      	strh	r3, [r4, #0]
        nanswers   = lwip_htons(hdr.numanswers);
 80078ac:	19bb      	adds	r3, r7, r6
 80078ae:	88db      	ldrh	r3, [r3, #6]
 80078b0:	223e      	movs	r2, #62	; 0x3e
 80078b2:	18bc      	adds	r4, r7, r2
 80078b4:	0018      	movs	r0, r3
 80078b6:	f7ff f9a7 	bl	8006c08 <lwip_htons>
 80078ba:	0003      	movs	r3, r0
 80078bc:	8023      	strh	r3, [r4, #0]

        /* Check for correct response. */
        if ((hdr.flags1 & DNS_FLAG1_RESPONSE) == 0) {
 80078be:	19bb      	adds	r3, r7, r6
 80078c0:	789b      	ldrb	r3, [r3, #2]
 80078c2:	b25b      	sxtb	r3, r3
 80078c4:	2b00      	cmp	r3, #0
 80078c6:	db00      	blt.n	80078ca <dns_recv+0xaa>
 80078c8:	e11d      	b.n	8007b06 <dns_recv+0x2e6>
          LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": not a response\n", entry->name));
          goto ignore_packet; /* ignore this packet */
        }
        if (nquestions != 1) {
 80078ca:	197b      	adds	r3, r7, r5
 80078cc:	881b      	ldrh	r3, [r3, #0]
 80078ce:	2b01      	cmp	r3, #1
 80078d0:	d000      	beq.n	80078d4 <dns_recv+0xb4>
 80078d2:	e11a      	b.n	8007b0a <dns_recv+0x2ea>
        if (!entry->is_mdns)
#endif /* LWIP_DNS_SUPPORT_MDNS_QUERIES */
        {
          /* Check whether response comes from the same network address to which the
             question was sent. (RFC 5452) */
          if (!ip_addr_cmp(addr, &dns_servers[entry->server_idx])) {
 80078d4:	683b      	ldr	r3, [r7, #0]
 80078d6:	681a      	ldr	r2, [r3, #0]
 80078d8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80078da:	7adb      	ldrb	r3, [r3, #11]
 80078dc:	0019      	movs	r1, r3
 80078de:	4b9a      	ldr	r3, [pc, #616]	; (8007b48 <dns_recv+0x328>)
 80078e0:	0089      	lsls	r1, r1, #2
 80078e2:	58cb      	ldr	r3, [r1, r3]
 80078e4:	429a      	cmp	r2, r3
 80078e6:	d000      	beq.n	80078ea <dns_recv+0xca>
 80078e8:	e111      	b.n	8007b0e <dns_recv+0x2ee>
          }
        }

        /* Check if the name in the "question" part match with the name in the entry and
           skip it if equal. */
        res_idx = dns_compare_name(entry->name, p, SIZEOF_DNS_HDR);
 80078ea:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80078ec:	3310      	adds	r3, #16
 80078ee:	253c      	movs	r5, #60	; 0x3c
 80078f0:	197c      	adds	r4, r7, r5
 80078f2:	6879      	ldr	r1, [r7, #4]
 80078f4:	220c      	movs	r2, #12
 80078f6:	0018      	movs	r0, r3
 80078f8:	f7ff fa92 	bl	8006e20 <dns_compare_name>
 80078fc:	0003      	movs	r3, r0
 80078fe:	8023      	strh	r3, [r4, #0]
        if (res_idx == 0xFFFF) {
 8007900:	002c      	movs	r4, r5
 8007902:	193b      	adds	r3, r7, r4
 8007904:	881b      	ldrh	r3, [r3, #0]
 8007906:	4a91      	ldr	r2, [pc, #580]	; (8007b4c <dns_recv+0x32c>)
 8007908:	4293      	cmp	r3, r2
 800790a:	d100      	bne.n	800790e <dns_recv+0xee>
 800790c:	e101      	b.n	8007b12 <dns_recv+0x2f2>
          LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response not match to query\n", entry->name));
          goto ignore_packet; /* ignore this packet */
        }

        /* check if "question" part matches the request */
        if (pbuf_copy_partial(p, &qry, SIZEOF_DNS_QUERY, res_idx) != SIZEOF_DNS_QUERY) {
 800790e:	193b      	adds	r3, r7, r4
 8007910:	881b      	ldrh	r3, [r3, #0]
 8007912:	2514      	movs	r5, #20
 8007914:	1979      	adds	r1, r7, r5
 8007916:	6878      	ldr	r0, [r7, #4]
 8007918:	2204      	movs	r2, #4
 800791a:	f002 fc23 	bl	800a164 <pbuf_copy_partial>
 800791e:	0003      	movs	r3, r0
 8007920:	2b04      	cmp	r3, #4
 8007922:	d000      	beq.n	8007926 <dns_recv+0x106>
 8007924:	e0f7      	b.n	8007b16 <dns_recv+0x2f6>
          goto ignore_packet; /* ignore this packet */
        }
        if ((qry.cls != PP_HTONS(DNS_RRCLASS_IN)) ||
 8007926:	197b      	adds	r3, r7, r5
 8007928:	885a      	ldrh	r2, [r3, #2]
 800792a:	2380      	movs	r3, #128	; 0x80
 800792c:	005b      	lsls	r3, r3, #1
 800792e:	429a      	cmp	r2, r3
 8007930:	d000      	beq.n	8007934 <dns_recv+0x114>
 8007932:	e0f2      	b.n	8007b1a <dns_recv+0x2fa>
            (LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype) && (qry.type != PP_HTONS(DNS_RRTYPE_AAAA))) ||
            (!LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype) && (qry.type != PP_HTONS(DNS_RRTYPE_A)))) {
 8007934:	197b      	adds	r3, r7, r5
 8007936:	881a      	ldrh	r2, [r3, #0]
            (LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype) && (qry.type != PP_HTONS(DNS_RRTYPE_AAAA))) ||
 8007938:	2380      	movs	r3, #128	; 0x80
 800793a:	005b      	lsls	r3, r3, #1
 800793c:	429a      	cmp	r2, r3
 800793e:	d000      	beq.n	8007942 <dns_recv+0x122>
 8007940:	e0eb      	b.n	8007b1a <dns_recv+0x2fa>
          LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response not match to query\n", entry->name));
          goto ignore_packet; /* ignore this packet */
        }
        /* skip the rest of the "question" part */
        if (res_idx + SIZEOF_DNS_QUERY > 0xFFFF) {
 8007942:	193b      	adds	r3, r7, r4
 8007944:	881b      	ldrh	r3, [r3, #0]
 8007946:	4a82      	ldr	r2, [pc, #520]	; (8007b50 <dns_recv+0x330>)
 8007948:	4293      	cmp	r3, r2
 800794a:	d900      	bls.n	800794e <dns_recv+0x12e>
 800794c:	e0e7      	b.n	8007b1e <dns_recv+0x2fe>
          goto ignore_packet;
        }
        res_idx = (u16_t)(res_idx + SIZEOF_DNS_QUERY);
 800794e:	193b      	adds	r3, r7, r4
 8007950:	193a      	adds	r2, r7, r4
 8007952:	8812      	ldrh	r2, [r2, #0]
 8007954:	3204      	adds	r2, #4
 8007956:	801a      	strh	r2, [r3, #0]

        /* Check for error. If so, call callback to inform. */
        if (hdr.flags2 & DNS_FLAG2_ERR_MASK) {
 8007958:	19bb      	adds	r3, r7, r6
 800795a:	78db      	ldrb	r3, [r3, #3]
 800795c:	001a      	movs	r2, r3
 800795e:	230f      	movs	r3, #15
 8007960:	4013      	ands	r3, r2
 8007962:	d100      	bne.n	8007966 <dns_recv+0x146>
 8007964:	e09a      	b.n	8007a9c <dns_recv+0x27c>
          LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": error in flags\n", entry->name));

          /* if there is another backup DNS server to try
           * then don't stop the DNS request
           */
          if (dns_backupserver_available(entry)) {
 8007966:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007968:	0018      	movs	r0, r3
 800796a:	f7ff fe49 	bl	8007600 <dns_backupserver_available>
 800796e:	1e03      	subs	r3, r0, #0
 8007970:	d100      	bne.n	8007974 <dns_recv+0x154>
 8007972:	e0a0      	b.n	8007ab6 <dns_recv+0x296>
            /* avoid retrying the same server */
            entry->retries = DNS_MAX_RETRIES-1;
 8007974:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007976:	2203      	movs	r2, #3
 8007978:	735a      	strb	r2, [r3, #13]
            entry->tmr     = 1;
 800797a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800797c:	2201      	movs	r2, #1
 800797e:	731a      	strb	r2, [r3, #12]

            /* contact next available server for this entry */
            dns_check_entry(i);
 8007980:	233b      	movs	r3, #59	; 0x3b
 8007982:	18fb      	adds	r3, r7, r3
 8007984:	781b      	ldrb	r3, [r3, #0]
 8007986:	0018      	movs	r0, r3
 8007988:	f7ff fe5e 	bl	8007648 <dns_check_entry>

            goto ignore_packet;
 800798c:	e0d2      	b.n	8007b34 <dns_recv+0x314>
          }
        } else {
          while ((nanswers > 0) && (res_idx < p->tot_len)) {
            /* skip answer resource record's host name */
            res_idx = dns_skip_name(p, res_idx);
 800798e:	253c      	movs	r5, #60	; 0x3c
 8007990:	197c      	adds	r4, r7, r5
 8007992:	197b      	adds	r3, r7, r5
 8007994:	881a      	ldrh	r2, [r3, #0]
 8007996:	687b      	ldr	r3, [r7, #4]
 8007998:	0011      	movs	r1, r2
 800799a:	0018      	movs	r0, r3
 800799c:	f7ff faf0 	bl	8006f80 <dns_skip_name>
 80079a0:	0003      	movs	r3, r0
 80079a2:	8023      	strh	r3, [r4, #0]
            if (res_idx == 0xFFFF) {
 80079a4:	002c      	movs	r4, r5
 80079a6:	193b      	adds	r3, r7, r4
 80079a8:	881b      	ldrh	r3, [r3, #0]
 80079aa:	4a68      	ldr	r2, [pc, #416]	; (8007b4c <dns_recv+0x32c>)
 80079ac:	4293      	cmp	r3, r2
 80079ae:	d100      	bne.n	80079b2 <dns_recv+0x192>
 80079b0:	e0b7      	b.n	8007b22 <dns_recv+0x302>
              goto ignore_packet; /* ignore this packet */
            }

            /* Check for IP address type and Internet class. Others are discarded. */
            if (pbuf_copy_partial(p, &ans, SIZEOF_DNS_ANSWER, res_idx) != SIZEOF_DNS_ANSWER) {
 80079b2:	193b      	adds	r3, r7, r4
 80079b4:	881b      	ldrh	r3, [r3, #0]
 80079b6:	2518      	movs	r5, #24
 80079b8:	1979      	adds	r1, r7, r5
 80079ba:	6878      	ldr	r0, [r7, #4]
 80079bc:	220a      	movs	r2, #10
 80079be:	f002 fbd1 	bl	800a164 <pbuf_copy_partial>
 80079c2:	0003      	movs	r3, r0
 80079c4:	2b0a      	cmp	r3, #10
 80079c6:	d000      	beq.n	80079ca <dns_recv+0x1aa>
 80079c8:	e0ad      	b.n	8007b26 <dns_recv+0x306>
              goto ignore_packet; /* ignore this packet */
            }
            if (res_idx + SIZEOF_DNS_ANSWER > 0xFFFF) {
 80079ca:	193b      	adds	r3, r7, r4
 80079cc:	881b      	ldrh	r3, [r3, #0]
 80079ce:	4a61      	ldr	r2, [pc, #388]	; (8007b54 <dns_recv+0x334>)
 80079d0:	4293      	cmp	r3, r2
 80079d2:	d900      	bls.n	80079d6 <dns_recv+0x1b6>
 80079d4:	e0a9      	b.n	8007b2a <dns_recv+0x30a>
              goto ignore_packet;
            }
            res_idx = (u16_t)(res_idx + SIZEOF_DNS_ANSWER);
 80079d6:	193b      	adds	r3, r7, r4
 80079d8:	0021      	movs	r1, r4
 80079da:	193a      	adds	r2, r7, r4
 80079dc:	8812      	ldrh	r2, [r2, #0]
 80079de:	320a      	adds	r2, #10
 80079e0:	801a      	strh	r2, [r3, #0]

            if (ans.cls == PP_HTONS(DNS_RRCLASS_IN)) {
 80079e2:	002c      	movs	r4, r5
 80079e4:	193b      	adds	r3, r7, r4
 80079e6:	885a      	ldrh	r2, [r3, #2]
 80079e8:	2380      	movs	r3, #128	; 0x80
 80079ea:	005b      	lsls	r3, r3, #1
 80079ec:	429a      	cmp	r2, r3
 80079ee:	d134      	bne.n	8007a5a <dns_recv+0x23a>
#if LWIP_IPV4
              if ((ans.type == PP_HTONS(DNS_RRTYPE_A)) && (ans.len == PP_HTONS(sizeof(ip4_addr_t)))) {
 80079f0:	193b      	adds	r3, r7, r4
 80079f2:	881a      	ldrh	r2, [r3, #0]
 80079f4:	2380      	movs	r3, #128	; 0x80
 80079f6:	005b      	lsls	r3, r3, #1
 80079f8:	429a      	cmp	r2, r3
 80079fa:	d12e      	bne.n	8007a5a <dns_recv+0x23a>
 80079fc:	193b      	adds	r3, r7, r4
 80079fe:	891a      	ldrh	r2, [r3, #8]
 8007a00:	2380      	movs	r3, #128	; 0x80
 8007a02:	00db      	lsls	r3, r3, #3
 8007a04:	429a      	cmp	r2, r3
 8007a06:	d128      	bne.n	8007a5a <dns_recv+0x23a>
                if (!LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype))
#endif /* LWIP_IPV4 && LWIP_IPV6 */
                {
                  ip4_addr_t ip4addr;
                  /* read the IP address after answer resource record's header */
                  if (pbuf_copy_partial(p, &ip4addr, sizeof(ip4_addr_t), res_idx) != sizeof(ip4_addr_t)) {
 8007a08:	187b      	adds	r3, r7, r1
 8007a0a:	881b      	ldrh	r3, [r3, #0]
 8007a0c:	2210      	movs	r2, #16
 8007a0e:	18b9      	adds	r1, r7, r2
 8007a10:	6878      	ldr	r0, [r7, #4]
 8007a12:	2204      	movs	r2, #4
 8007a14:	f002 fba6 	bl	800a164 <pbuf_copy_partial>
 8007a18:	0003      	movs	r3, r0
 8007a1a:	2b04      	cmp	r3, #4
 8007a1c:	d000      	beq.n	8007a20 <dns_recv+0x200>
 8007a1e:	e086      	b.n	8007b2e <dns_recv+0x30e>
                    goto ignore_packet; /* ignore this packet */
                  }
                  ip_addr_copy_from_ip4(dns_table[i].ipaddr, ip4addr);
 8007a20:	253b      	movs	r5, #59	; 0x3b
 8007a22:	197b      	adds	r3, r7, r5
 8007a24:	781a      	ldrb	r2, [r3, #0]
 8007a26:	6939      	ldr	r1, [r7, #16]
 8007a28:	4846      	ldr	r0, [pc, #280]	; (8007b44 <dns_recv+0x324>)
 8007a2a:	0013      	movs	r3, r2
 8007a2c:	00db      	lsls	r3, r3, #3
 8007a2e:	189b      	adds	r3, r3, r2
 8007a30:	011b      	lsls	r3, r3, #4
 8007a32:	18c3      	adds	r3, r0, r3
 8007a34:	3304      	adds	r3, #4
 8007a36:	6019      	str	r1, [r3, #0]
                  pbuf_free(p);
 8007a38:	687b      	ldr	r3, [r7, #4]
 8007a3a:	0018      	movs	r0, r3
 8007a3c:	f002 f8c8 	bl	8009bd0 <pbuf_free>
                  /* handle correct response */
                  dns_correct_response(i, lwip_ntohl(ans.ttl));
 8007a40:	193b      	adds	r3, r7, r4
 8007a42:	685b      	ldr	r3, [r3, #4]
 8007a44:	0018      	movs	r0, r3
 8007a46:	f7ff f8f5 	bl	8006c34 <lwip_htonl>
 8007a4a:	0002      	movs	r2, r0
 8007a4c:	197b      	adds	r3, r7, r5
 8007a4e:	781b      	ldrb	r3, [r3, #0]
 8007a50:	0011      	movs	r1, r2
 8007a52:	0018      	movs	r0, r3
 8007a54:	f7ff feaa 	bl	80077ac <dns_correct_response>
 8007a58:	e071      	b.n	8007b3e <dns_recv+0x31e>
                }
              }
#endif /* LWIP_IPV6 */
            }
            /* skip this answer */
            if ((int)(res_idx + lwip_htons(ans.len)) > 0xFFFF) {
 8007a5a:	253c      	movs	r5, #60	; 0x3c
 8007a5c:	197b      	adds	r3, r7, r5
 8007a5e:	881c      	ldrh	r4, [r3, #0]
 8007a60:	2618      	movs	r6, #24
 8007a62:	19bb      	adds	r3, r7, r6
 8007a64:	891b      	ldrh	r3, [r3, #8]
 8007a66:	0018      	movs	r0, r3
 8007a68:	f7ff f8ce 	bl	8006c08 <lwip_htons>
 8007a6c:	0003      	movs	r3, r0
 8007a6e:	18e2      	adds	r2, r4, r3
 8007a70:	2380      	movs	r3, #128	; 0x80
 8007a72:	025b      	lsls	r3, r3, #9
 8007a74:	429a      	cmp	r2, r3
 8007a76:	da5c      	bge.n	8007b32 <dns_recv+0x312>
              goto ignore_packet; /* ignore this packet */
            }
            res_idx = (u16_t)(res_idx + lwip_htons(ans.len));
 8007a78:	19bb      	adds	r3, r7, r6
 8007a7a:	891b      	ldrh	r3, [r3, #8]
 8007a7c:	0018      	movs	r0, r3
 8007a7e:	f7ff f8c3 	bl	8006c08 <lwip_htons>
 8007a82:	0003      	movs	r3, r0
 8007a84:	0019      	movs	r1, r3
 8007a86:	197b      	adds	r3, r7, r5
 8007a88:	197a      	adds	r2, r7, r5
 8007a8a:	8812      	ldrh	r2, [r2, #0]
 8007a8c:	188a      	adds	r2, r1, r2
 8007a8e:	801a      	strh	r2, [r3, #0]
            --nanswers;
 8007a90:	223e      	movs	r2, #62	; 0x3e
 8007a92:	18bb      	adds	r3, r7, r2
 8007a94:	18ba      	adds	r2, r7, r2
 8007a96:	8812      	ldrh	r2, [r2, #0]
 8007a98:	3a01      	subs	r2, #1
 8007a9a:	801a      	strh	r2, [r3, #0]
          while ((nanswers > 0) && (res_idx < p->tot_len)) {
 8007a9c:	233e      	movs	r3, #62	; 0x3e
 8007a9e:	18fb      	adds	r3, r7, r3
 8007aa0:	881b      	ldrh	r3, [r3, #0]
 8007aa2:	2b00      	cmp	r3, #0
 8007aa4:	d007      	beq.n	8007ab6 <dns_recv+0x296>
 8007aa6:	687b      	ldr	r3, [r7, #4]
 8007aa8:	891b      	ldrh	r3, [r3, #8]
 8007aaa:	223c      	movs	r2, #60	; 0x3c
 8007aac:	18ba      	adds	r2, r7, r2
 8007aae:	8812      	ldrh	r2, [r2, #0]
 8007ab0:	429a      	cmp	r2, r3
 8007ab2:	d200      	bcs.n	8007ab6 <dns_recv+0x296>
 8007ab4:	e76b      	b.n	800798e <dns_recv+0x16e>
          }
#endif /* LWIP_IPV4 && LWIP_IPV6 */
          LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": error in response\n", entry->name));
        }
        /* call callback to indicate error, clean up memory and return */
        pbuf_free(p);
 8007ab6:	687b      	ldr	r3, [r7, #4]
 8007ab8:	0018      	movs	r0, r3
 8007aba:	f002 f889 	bl	8009bd0 <pbuf_free>
        dns_call_found(i, NULL);
 8007abe:	243b      	movs	r4, #59	; 0x3b
 8007ac0:	193b      	adds	r3, r7, r4
 8007ac2:	781b      	ldrb	r3, [r3, #0]
 8007ac4:	2100      	movs	r1, #0
 8007ac6:	0018      	movs	r0, r3
 8007ac8:	f7ff fc84 	bl	80073d4 <dns_call_found>
        dns_table[i].state = DNS_STATE_UNUSED;
 8007acc:	193b      	adds	r3, r7, r4
 8007ace:	781a      	ldrb	r2, [r3, #0]
 8007ad0:	491c      	ldr	r1, [pc, #112]	; (8007b44 <dns_recv+0x324>)
 8007ad2:	0013      	movs	r3, r2
 8007ad4:	00db      	lsls	r3, r3, #3
 8007ad6:	189b      	adds	r3, r3, r2
 8007ad8:	011b      	lsls	r3, r3, #4
 8007ada:	18cb      	adds	r3, r1, r3
 8007adc:	330a      	adds	r3, #10
 8007ade:	2200      	movs	r2, #0
 8007ae0:	701a      	strb	r2, [r3, #0]
        return;
 8007ae2:	e02c      	b.n	8007b3e <dns_recv+0x31e>
    for (i = 0; i < DNS_TABLE_SIZE; i++) {
 8007ae4:	213b      	movs	r1, #59	; 0x3b
 8007ae6:	187b      	adds	r3, r7, r1
 8007ae8:	781a      	ldrb	r2, [r3, #0]
 8007aea:	187b      	adds	r3, r7, r1
 8007aec:	3201      	adds	r2, #1
 8007aee:	701a      	strb	r2, [r3, #0]
 8007af0:	233b      	movs	r3, #59	; 0x3b
 8007af2:	18fb      	adds	r3, r7, r3
 8007af4:	781b      	ldrb	r3, [r3, #0]
 8007af6:	2b02      	cmp	r3, #2
 8007af8:	d800      	bhi.n	8007afc <dns_recv+0x2dc>
 8007afa:	e6b6      	b.n	800786a <dns_recv+0x4a>
      }
    }
  }

ignore_packet:
 8007afc:	e001      	b.n	8007b02 <dns_recv+0x2e2>
    goto ignore_packet;
 8007afe:	46c0      	nop			; (mov r8, r8)
 8007b00:	e018      	b.n	8007b34 <dns_recv+0x314>
ignore_packet:
 8007b02:	46c0      	nop			; (mov r8, r8)
 8007b04:	e016      	b.n	8007b34 <dns_recv+0x314>
          goto ignore_packet; /* ignore this packet */
 8007b06:	46c0      	nop			; (mov r8, r8)
 8007b08:	e014      	b.n	8007b34 <dns_recv+0x314>
          goto ignore_packet; /* ignore this packet */
 8007b0a:	46c0      	nop			; (mov r8, r8)
 8007b0c:	e012      	b.n	8007b34 <dns_recv+0x314>
            goto ignore_packet; /* ignore this packet */
 8007b0e:	46c0      	nop			; (mov r8, r8)
 8007b10:	e010      	b.n	8007b34 <dns_recv+0x314>
          goto ignore_packet; /* ignore this packet */
 8007b12:	46c0      	nop			; (mov r8, r8)
 8007b14:	e00e      	b.n	8007b34 <dns_recv+0x314>
          goto ignore_packet; /* ignore this packet */
 8007b16:	46c0      	nop			; (mov r8, r8)
 8007b18:	e00c      	b.n	8007b34 <dns_recv+0x314>
          goto ignore_packet; /* ignore this packet */
 8007b1a:	46c0      	nop			; (mov r8, r8)
 8007b1c:	e00a      	b.n	8007b34 <dns_recv+0x314>
          goto ignore_packet;
 8007b1e:	46c0      	nop			; (mov r8, r8)
 8007b20:	e008      	b.n	8007b34 <dns_recv+0x314>
              goto ignore_packet; /* ignore this packet */
 8007b22:	46c0      	nop			; (mov r8, r8)
 8007b24:	e006      	b.n	8007b34 <dns_recv+0x314>
              goto ignore_packet; /* ignore this packet */
 8007b26:	46c0      	nop			; (mov r8, r8)
 8007b28:	e004      	b.n	8007b34 <dns_recv+0x314>
              goto ignore_packet;
 8007b2a:	46c0      	nop			; (mov r8, r8)
 8007b2c:	e002      	b.n	8007b34 <dns_recv+0x314>
                    goto ignore_packet; /* ignore this packet */
 8007b2e:	46c0      	nop			; (mov r8, r8)
 8007b30:	e000      	b.n	8007b34 <dns_recv+0x314>
              goto ignore_packet; /* ignore this packet */
 8007b32:	46c0      	nop			; (mov r8, r8)
  /* deallocate memory and return */
  pbuf_free(p);
 8007b34:	687b      	ldr	r3, [r7, #4]
 8007b36:	0018      	movs	r0, r3
 8007b38:	f002 f84a 	bl	8009bd0 <pbuf_free>
  return;
 8007b3c:	46c0      	nop			; (mov r8, r8)
}
 8007b3e:	46bd      	mov	sp, r7
 8007b40:	b011      	add	sp, #68	; 0x44
 8007b42:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007b44:	20001924 	.word	0x20001924
 8007b48:	20001af8 	.word	0x20001af8
 8007b4c:	0000ffff 	.word	0x0000ffff
 8007b50:	0000fffb 	.word	0x0000fffb
 8007b54:	0000fff5 	.word	0x0000fff5

08007b58 <dns_enqueue>:
 * @return err_t return code.
 */
static err_t
dns_enqueue(const char *name, size_t hostnamelen, dns_found_callback found,
            void *callback_arg LWIP_DNS_ADDRTYPE_ARG(u8_t dns_addrtype) LWIP_DNS_ISMDNS_ARG(u8_t is_mdns))
{
 8007b58:	b590      	push	{r4, r7, lr}
 8007b5a:	b08b      	sub	sp, #44	; 0x2c
 8007b5c:	af00      	add	r7, sp, #0
 8007b5e:	60f8      	str	r0, [r7, #12]
 8007b60:	60b9      	str	r1, [r7, #8]
 8007b62:	607a      	str	r2, [r7, #4]
 8007b64:	603b      	str	r3, [r7, #0]
  u8_t i;
  u8_t lseq, lseqi;
  struct dns_table_entry *entry = NULL;
 8007b66:	2300      	movs	r3, #0
 8007b68:	623b      	str	r3, [r7, #32]
  struct dns_req_entry *req;

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING) != 0)
  u8_t r;
  /* check for duplicate entries */
  for (i = 0; i < DNS_TABLE_SIZE; i++) {
 8007b6a:	2327      	movs	r3, #39	; 0x27
 8007b6c:	18fb      	adds	r3, r7, r3
 8007b6e:	2200      	movs	r2, #0
 8007b70:	701a      	strb	r2, [r3, #0]
 8007b72:	e062      	b.n	8007c3a <dns_enqueue+0xe2>
    if ((dns_table[i].state == DNS_STATE_ASKING) &&
 8007b74:	2027      	movs	r0, #39	; 0x27
 8007b76:	183b      	adds	r3, r7, r0
 8007b78:	781a      	ldrb	r2, [r3, #0]
 8007b7a:	49a3      	ldr	r1, [pc, #652]	; (8007e08 <dns_enqueue+0x2b0>)
 8007b7c:	0013      	movs	r3, r2
 8007b7e:	00db      	lsls	r3, r3, #3
 8007b80:	189b      	adds	r3, r3, r2
 8007b82:	011b      	lsls	r3, r3, #4
 8007b84:	18cb      	adds	r3, r1, r3
 8007b86:	330a      	adds	r3, #10
 8007b88:	781b      	ldrb	r3, [r3, #0]
 8007b8a:	2b02      	cmp	r3, #2
 8007b8c:	d14f      	bne.n	8007c2e <dns_enqueue+0xd6>
        (lwip_strnicmp(name, dns_table[i].name, sizeof(dns_table[i].name)) == 0)) {
 8007b8e:	183b      	adds	r3, r7, r0
 8007b90:	781a      	ldrb	r2, [r3, #0]
 8007b92:	0013      	movs	r3, r2
 8007b94:	00db      	lsls	r3, r3, #3
 8007b96:	189b      	adds	r3, r3, r2
 8007b98:	011b      	lsls	r3, r3, #4
 8007b9a:	3310      	adds	r3, #16
 8007b9c:	001a      	movs	r2, r3
 8007b9e:	4b9a      	ldr	r3, [pc, #616]	; (8007e08 <dns_enqueue+0x2b0>)
 8007ba0:	18d1      	adds	r1, r2, r3
 8007ba2:	68fb      	ldr	r3, [r7, #12]
 8007ba4:	2280      	movs	r2, #128	; 0x80
 8007ba6:	0018      	movs	r0, r3
 8007ba8:	f7ff f85d 	bl	8006c66 <lwip_strnicmp>
 8007bac:	1e03      	subs	r3, r0, #0
    if ((dns_table[i].state == DNS_STATE_ASKING) &&
 8007bae:	d13e      	bne.n	8007c2e <dns_enqueue+0xd6>
           for the same host should not be that common */
        continue;
      }
#endif /* LWIP_IPV4 && LWIP_IPV6 */
      /* this is a duplicate entry, find a free request entry */
      for (r = 0; r < DNS_MAX_REQUESTS; r++) {
 8007bb0:	231b      	movs	r3, #27
 8007bb2:	18fb      	adds	r3, r7, r3
 8007bb4:	2200      	movs	r2, #0
 8007bb6:	701a      	strb	r2, [r3, #0]
 8007bb8:	e034      	b.n	8007c24 <dns_enqueue+0xcc>
        if (dns_requests[r].found == 0) {
 8007bba:	201b      	movs	r0, #27
 8007bbc:	183b      	adds	r3, r7, r0
 8007bbe:	781a      	ldrb	r2, [r3, #0]
 8007bc0:	4992      	ldr	r1, [pc, #584]	; (8007e0c <dns_enqueue+0x2b4>)
 8007bc2:	0013      	movs	r3, r2
 8007bc4:	005b      	lsls	r3, r3, #1
 8007bc6:	189b      	adds	r3, r3, r2
 8007bc8:	009b      	lsls	r3, r3, #2
 8007bca:	585b      	ldr	r3, [r3, r1]
 8007bcc:	2b00      	cmp	r3, #0
 8007bce:	d123      	bne.n	8007c18 <dns_enqueue+0xc0>
          dns_requests[r].found = found;
 8007bd0:	183b      	adds	r3, r7, r0
 8007bd2:	781a      	ldrb	r2, [r3, #0]
 8007bd4:	498d      	ldr	r1, [pc, #564]	; (8007e0c <dns_enqueue+0x2b4>)
 8007bd6:	0013      	movs	r3, r2
 8007bd8:	005b      	lsls	r3, r3, #1
 8007bda:	189b      	adds	r3, r3, r2
 8007bdc:	009b      	lsls	r3, r3, #2
 8007bde:	687a      	ldr	r2, [r7, #4]
 8007be0:	505a      	str	r2, [r3, r1]
          dns_requests[r].arg = callback_arg;
 8007be2:	183b      	adds	r3, r7, r0
 8007be4:	781a      	ldrb	r2, [r3, #0]
 8007be6:	4989      	ldr	r1, [pc, #548]	; (8007e0c <dns_enqueue+0x2b4>)
 8007be8:	0013      	movs	r3, r2
 8007bea:	005b      	lsls	r3, r3, #1
 8007bec:	189b      	adds	r3, r3, r2
 8007bee:	009b      	lsls	r3, r3, #2
 8007bf0:	18cb      	adds	r3, r1, r3
 8007bf2:	3304      	adds	r3, #4
 8007bf4:	683a      	ldr	r2, [r7, #0]
 8007bf6:	601a      	str	r2, [r3, #0]
          dns_requests[r].dns_table_idx = i;
 8007bf8:	183b      	adds	r3, r7, r0
 8007bfa:	781a      	ldrb	r2, [r3, #0]
 8007bfc:	4983      	ldr	r1, [pc, #524]	; (8007e0c <dns_enqueue+0x2b4>)
 8007bfe:	0013      	movs	r3, r2
 8007c00:	005b      	lsls	r3, r3, #1
 8007c02:	189b      	adds	r3, r3, r2
 8007c04:	009b      	lsls	r3, r3, #2
 8007c06:	18cb      	adds	r3, r1, r3
 8007c08:	3308      	adds	r3, #8
 8007c0a:	2227      	movs	r2, #39	; 0x27
 8007c0c:	18ba      	adds	r2, r7, r2
 8007c0e:	7812      	ldrb	r2, [r2, #0]
 8007c10:	701a      	strb	r2, [r3, #0]
          LWIP_DNS_SET_ADDRTYPE(dns_requests[r].reqaddrtype, dns_addrtype);
          LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": duplicate request\n", name));
          return ERR_INPROGRESS;
 8007c12:	2305      	movs	r3, #5
 8007c14:	425b      	negs	r3, r3
 8007c16:	e0f3      	b.n	8007e00 <dns_enqueue+0x2a8>
      for (r = 0; r < DNS_MAX_REQUESTS; r++) {
 8007c18:	211b      	movs	r1, #27
 8007c1a:	187b      	adds	r3, r7, r1
 8007c1c:	781a      	ldrb	r2, [r3, #0]
 8007c1e:	187b      	adds	r3, r7, r1
 8007c20:	3201      	adds	r2, #1
 8007c22:	701a      	strb	r2, [r3, #0]
 8007c24:	231b      	movs	r3, #27
 8007c26:	18fb      	adds	r3, r7, r3
 8007c28:	781b      	ldrb	r3, [r3, #0]
 8007c2a:	2b02      	cmp	r3, #2
 8007c2c:	d9c5      	bls.n	8007bba <dns_enqueue+0x62>
  for (i = 0; i < DNS_TABLE_SIZE; i++) {
 8007c2e:	2127      	movs	r1, #39	; 0x27
 8007c30:	187b      	adds	r3, r7, r1
 8007c32:	781a      	ldrb	r2, [r3, #0]
 8007c34:	187b      	adds	r3, r7, r1
 8007c36:	3201      	adds	r2, #1
 8007c38:	701a      	strb	r2, [r3, #0]
 8007c3a:	2127      	movs	r1, #39	; 0x27
 8007c3c:	187b      	adds	r3, r7, r1
 8007c3e:	781b      	ldrb	r3, [r3, #0]
 8007c40:	2b02      	cmp	r3, #2
 8007c42:	d997      	bls.n	8007b74 <dns_enqueue+0x1c>
  }
  /* no duplicate entries found */
#endif

  /* search an unused entry, or the oldest one */
  lseq = 0;
 8007c44:	2326      	movs	r3, #38	; 0x26
 8007c46:	18fb      	adds	r3, r7, r3
 8007c48:	2200      	movs	r2, #0
 8007c4a:	701a      	strb	r2, [r3, #0]
  lseqi = DNS_TABLE_SIZE;
 8007c4c:	2325      	movs	r3, #37	; 0x25
 8007c4e:	18fb      	adds	r3, r7, r3
 8007c50:	2203      	movs	r2, #3
 8007c52:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 8007c54:	187b      	adds	r3, r7, r1
 8007c56:	2200      	movs	r2, #0
 8007c58:	701a      	strb	r2, [r3, #0]
 8007c5a:	e030      	b.n	8007cbe <dns_enqueue+0x166>
    entry = &dns_table[i];
 8007c5c:	2427      	movs	r4, #39	; 0x27
 8007c5e:	193b      	adds	r3, r7, r4
 8007c60:	781a      	ldrb	r2, [r3, #0]
 8007c62:	0013      	movs	r3, r2
 8007c64:	00db      	lsls	r3, r3, #3
 8007c66:	189b      	adds	r3, r3, r2
 8007c68:	011b      	lsls	r3, r3, #4
 8007c6a:	4a67      	ldr	r2, [pc, #412]	; (8007e08 <dns_enqueue+0x2b0>)
 8007c6c:	189b      	adds	r3, r3, r2
 8007c6e:	623b      	str	r3, [r7, #32]
    /* is it an unused entry ? */
    if (entry->state == DNS_STATE_UNUSED) {
 8007c70:	6a3b      	ldr	r3, [r7, #32]
 8007c72:	7a9b      	ldrb	r3, [r3, #10]
 8007c74:	2b00      	cmp	r3, #0
 8007c76:	d028      	beq.n	8007cca <dns_enqueue+0x172>
      break;
    }
    /* check if this is the oldest completed entry */
    if (entry->state == DNS_STATE_DONE) {
 8007c78:	6a3b      	ldr	r3, [r7, #32]
 8007c7a:	7a9b      	ldrb	r3, [r3, #10]
 8007c7c:	2b03      	cmp	r3, #3
 8007c7e:	d118      	bne.n	8007cb2 <dns_enqueue+0x15a>
      u8_t age = (u8_t)(dns_seqno - entry->seqno);
 8007c80:	4b63      	ldr	r3, [pc, #396]	; (8007e10 <dns_enqueue+0x2b8>)
 8007c82:	7819      	ldrb	r1, [r3, #0]
 8007c84:	6a3b      	ldr	r3, [r7, #32]
 8007c86:	7b9a      	ldrb	r2, [r3, #14]
 8007c88:	201a      	movs	r0, #26
 8007c8a:	183b      	adds	r3, r7, r0
 8007c8c:	1a8a      	subs	r2, r1, r2
 8007c8e:	701a      	strb	r2, [r3, #0]
      if (age > lseq) {
 8007c90:	0001      	movs	r1, r0
 8007c92:	187a      	adds	r2, r7, r1
 8007c94:	2026      	movs	r0, #38	; 0x26
 8007c96:	183b      	adds	r3, r7, r0
 8007c98:	7812      	ldrb	r2, [r2, #0]
 8007c9a:	781b      	ldrb	r3, [r3, #0]
 8007c9c:	429a      	cmp	r2, r3
 8007c9e:	d908      	bls.n	8007cb2 <dns_enqueue+0x15a>
        lseq = age;
 8007ca0:	183b      	adds	r3, r7, r0
 8007ca2:	187a      	adds	r2, r7, r1
 8007ca4:	7812      	ldrb	r2, [r2, #0]
 8007ca6:	701a      	strb	r2, [r3, #0]
        lseqi = i;
 8007ca8:	2325      	movs	r3, #37	; 0x25
 8007caa:	18fb      	adds	r3, r7, r3
 8007cac:	193a      	adds	r2, r7, r4
 8007cae:	7812      	ldrb	r2, [r2, #0]
 8007cb0:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 8007cb2:	2227      	movs	r2, #39	; 0x27
 8007cb4:	18bb      	adds	r3, r7, r2
 8007cb6:	18ba      	adds	r2, r7, r2
 8007cb8:	7812      	ldrb	r2, [r2, #0]
 8007cba:	3201      	adds	r2, #1
 8007cbc:	701a      	strb	r2, [r3, #0]
 8007cbe:	2327      	movs	r3, #39	; 0x27
 8007cc0:	18fb      	adds	r3, r7, r3
 8007cc2:	781b      	ldrb	r3, [r3, #0]
 8007cc4:	2b02      	cmp	r3, #2
 8007cc6:	d9c9      	bls.n	8007c5c <dns_enqueue+0x104>
 8007cc8:	e000      	b.n	8007ccc <dns_enqueue+0x174>
      break;
 8007cca:	46c0      	nop			; (mov r8, r8)
      }
    }
  }

  /* if we don't have found an unused entry, use the oldest completed one */
  if (i == DNS_TABLE_SIZE) {
 8007ccc:	2327      	movs	r3, #39	; 0x27
 8007cce:	18fb      	adds	r3, r7, r3
 8007cd0:	781b      	ldrb	r3, [r3, #0]
 8007cd2:	2b03      	cmp	r3, #3
 8007cd4:	d122      	bne.n	8007d1c <dns_enqueue+0x1c4>
    if ((lseqi >= DNS_TABLE_SIZE) || (dns_table[lseqi].state != DNS_STATE_DONE)) {
 8007cd6:	2225      	movs	r2, #37	; 0x25
 8007cd8:	18bb      	adds	r3, r7, r2
 8007cda:	781b      	ldrb	r3, [r3, #0]
 8007cdc:	2b02      	cmp	r3, #2
 8007cde:	d80b      	bhi.n	8007cf8 <dns_enqueue+0x1a0>
 8007ce0:	18bb      	adds	r3, r7, r2
 8007ce2:	781a      	ldrb	r2, [r3, #0]
 8007ce4:	4948      	ldr	r1, [pc, #288]	; (8007e08 <dns_enqueue+0x2b0>)
 8007ce6:	0013      	movs	r3, r2
 8007ce8:	00db      	lsls	r3, r3, #3
 8007cea:	189b      	adds	r3, r3, r2
 8007cec:	011b      	lsls	r3, r3, #4
 8007cee:	18cb      	adds	r3, r1, r3
 8007cf0:	330a      	adds	r3, #10
 8007cf2:	781b      	ldrb	r3, [r3, #0]
 8007cf4:	2b03      	cmp	r3, #3
 8007cf6:	d002      	beq.n	8007cfe <dns_enqueue+0x1a6>
      /* no entry can be used now, table is full */
      LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": DNS entries table is full\n", name));
      return ERR_MEM;
 8007cf8:	2301      	movs	r3, #1
 8007cfa:	425b      	negs	r3, r3
 8007cfc:	e080      	b.n	8007e00 <dns_enqueue+0x2a8>
    } else {
      /* use the oldest completed one */
      i = lseqi;
 8007cfe:	2127      	movs	r1, #39	; 0x27
 8007d00:	187b      	adds	r3, r7, r1
 8007d02:	2225      	movs	r2, #37	; 0x25
 8007d04:	18ba      	adds	r2, r7, r2
 8007d06:	7812      	ldrb	r2, [r2, #0]
 8007d08:	701a      	strb	r2, [r3, #0]
      entry = &dns_table[i];
 8007d0a:	187b      	adds	r3, r7, r1
 8007d0c:	781a      	ldrb	r2, [r3, #0]
 8007d0e:	0013      	movs	r3, r2
 8007d10:	00db      	lsls	r3, r3, #3
 8007d12:	189b      	adds	r3, r3, r2
 8007d14:	011b      	lsls	r3, r3, #4
 8007d16:	4a3c      	ldr	r2, [pc, #240]	; (8007e08 <dns_enqueue+0x2b0>)
 8007d18:	189b      	adds	r3, r3, r2
 8007d1a:	623b      	str	r3, [r7, #32]
    }
  }

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING) != 0)
  /* find a free request entry */
  req = NULL;
 8007d1c:	2300      	movs	r3, #0
 8007d1e:	61fb      	str	r3, [r7, #28]
  for (r = 0; r < DNS_MAX_REQUESTS; r++) {
 8007d20:	231b      	movs	r3, #27
 8007d22:	18fb      	adds	r3, r7, r3
 8007d24:	2200      	movs	r2, #0
 8007d26:	701a      	strb	r2, [r3, #0]
 8007d28:	e01a      	b.n	8007d60 <dns_enqueue+0x208>
    if (dns_requests[r].found == NULL) {
 8007d2a:	201b      	movs	r0, #27
 8007d2c:	183b      	adds	r3, r7, r0
 8007d2e:	781a      	ldrb	r2, [r3, #0]
 8007d30:	4936      	ldr	r1, [pc, #216]	; (8007e0c <dns_enqueue+0x2b4>)
 8007d32:	0013      	movs	r3, r2
 8007d34:	005b      	lsls	r3, r3, #1
 8007d36:	189b      	adds	r3, r3, r2
 8007d38:	009b      	lsls	r3, r3, #2
 8007d3a:	585b      	ldr	r3, [r3, r1]
 8007d3c:	2b00      	cmp	r3, #0
 8007d3e:	d109      	bne.n	8007d54 <dns_enqueue+0x1fc>
      req = &dns_requests[r];
 8007d40:	183b      	adds	r3, r7, r0
 8007d42:	781a      	ldrb	r2, [r3, #0]
 8007d44:	0013      	movs	r3, r2
 8007d46:	005b      	lsls	r3, r3, #1
 8007d48:	189b      	adds	r3, r3, r2
 8007d4a:	009b      	lsls	r3, r3, #2
 8007d4c:	4a2f      	ldr	r2, [pc, #188]	; (8007e0c <dns_enqueue+0x2b4>)
 8007d4e:	189b      	adds	r3, r3, r2
 8007d50:	61fb      	str	r3, [r7, #28]
      break;
 8007d52:	e00a      	b.n	8007d6a <dns_enqueue+0x212>
  for (r = 0; r < DNS_MAX_REQUESTS; r++) {
 8007d54:	211b      	movs	r1, #27
 8007d56:	187b      	adds	r3, r7, r1
 8007d58:	781a      	ldrb	r2, [r3, #0]
 8007d5a:	187b      	adds	r3, r7, r1
 8007d5c:	3201      	adds	r2, #1
 8007d5e:	701a      	strb	r2, [r3, #0]
 8007d60:	231b      	movs	r3, #27
 8007d62:	18fb      	adds	r3, r7, r3
 8007d64:	781b      	ldrb	r3, [r3, #0]
 8007d66:	2b02      	cmp	r3, #2
 8007d68:	d9df      	bls.n	8007d2a <dns_enqueue+0x1d2>
    }
  }
  if (req == NULL) {
 8007d6a:	69fb      	ldr	r3, [r7, #28]
 8007d6c:	2b00      	cmp	r3, #0
 8007d6e:	d102      	bne.n	8007d76 <dns_enqueue+0x21e>
    /* no request entry can be used now, table is full */
    LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": DNS request entries table is full\n", name));
    return ERR_MEM;
 8007d70:	2301      	movs	r3, #1
 8007d72:	425b      	negs	r3, r3
 8007d74:	e044      	b.n	8007e00 <dns_enqueue+0x2a8>
  }
  req->dns_table_idx = i;
 8007d76:	69fb      	ldr	r3, [r7, #28]
 8007d78:	2227      	movs	r2, #39	; 0x27
 8007d7a:	18ba      	adds	r2, r7, r2
 8007d7c:	7812      	ldrb	r2, [r2, #0]
 8007d7e:	721a      	strb	r2, [r3, #8]

  /* use this entry */
  LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": use DNS entry %"U16_F"\n", name, (u16_t)(i)));

  /* fill the entry */
  entry->state = DNS_STATE_NEW;
 8007d80:	6a3b      	ldr	r3, [r7, #32]
 8007d82:	2201      	movs	r2, #1
 8007d84:	729a      	strb	r2, [r3, #10]
  entry->seqno = dns_seqno;
 8007d86:	4b22      	ldr	r3, [pc, #136]	; (8007e10 <dns_enqueue+0x2b8>)
 8007d88:	781a      	ldrb	r2, [r3, #0]
 8007d8a:	6a3b      	ldr	r3, [r7, #32]
 8007d8c:	739a      	strb	r2, [r3, #14]
  LWIP_DNS_SET_ADDRTYPE(entry->reqaddrtype, dns_addrtype);
  LWIP_DNS_SET_ADDRTYPE(req->reqaddrtype, dns_addrtype);
  req->found = found;
 8007d8e:	69fb      	ldr	r3, [r7, #28]
 8007d90:	687a      	ldr	r2, [r7, #4]
 8007d92:	601a      	str	r2, [r3, #0]
  req->arg   = callback_arg;
 8007d94:	69fb      	ldr	r3, [r7, #28]
 8007d96:	683a      	ldr	r2, [r7, #0]
 8007d98:	605a      	str	r2, [r3, #4]
  namelen = LWIP_MIN(hostnamelen, DNS_MAX_NAME_LENGTH - 1);
 8007d9a:	68bb      	ldr	r3, [r7, #8]
 8007d9c:	2b7f      	cmp	r3, #127	; 0x7f
 8007d9e:	d900      	bls.n	8007da2 <dns_enqueue+0x24a>
 8007da0:	237f      	movs	r3, #127	; 0x7f
 8007da2:	617b      	str	r3, [r7, #20]
  MEMCPY(entry->name, name, namelen);
 8007da4:	6a3b      	ldr	r3, [r7, #32]
 8007da6:	3310      	adds	r3, #16
 8007da8:	697a      	ldr	r2, [r7, #20]
 8007daa:	68f9      	ldr	r1, [r7, #12]
 8007dac:	0018      	movs	r0, r3
 8007dae:	f014 ff17 	bl	801cbe0 <memcpy>
  entry->name[namelen] = 0;
 8007db2:	6a3a      	ldr	r2, [r7, #32]
 8007db4:	697b      	ldr	r3, [r7, #20]
 8007db6:	18d3      	adds	r3, r2, r3
 8007db8:	3310      	adds	r3, #16
 8007dba:	2200      	movs	r2, #0
 8007dbc:	701a      	strb	r2, [r3, #0]

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) != 0)
  entry->pcb_idx = dns_alloc_pcb();
 8007dbe:	f7ff faa1 	bl	8007304 <dns_alloc_pcb>
 8007dc2:	0003      	movs	r3, r0
 8007dc4:	001a      	movs	r2, r3
 8007dc6:	6a3b      	ldr	r3, [r7, #32]
 8007dc8:	73da      	strb	r2, [r3, #15]
  if (entry->pcb_idx >= DNS_MAX_SOURCE_PORTS) {
 8007dca:	6a3b      	ldr	r3, [r7, #32]
 8007dcc:	7bdb      	ldrb	r3, [r3, #15]
 8007dce:	2b02      	cmp	r3, #2
 8007dd0:	d908      	bls.n	8007de4 <dns_enqueue+0x28c>
    /* failed to get a UDP pcb */
    LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": failed to allocate a pcb\n", name));
    entry->state = DNS_STATE_UNUSED;
 8007dd2:	6a3b      	ldr	r3, [r7, #32]
 8007dd4:	2200      	movs	r2, #0
 8007dd6:	729a      	strb	r2, [r3, #10]
    req->found = NULL;
 8007dd8:	69fb      	ldr	r3, [r7, #28]
 8007dda:	2200      	movs	r2, #0
 8007ddc:	601a      	str	r2, [r3, #0]
    return ERR_MEM;
 8007dde:	2301      	movs	r3, #1
 8007de0:	425b      	negs	r3, r3
 8007de2:	e00d      	b.n	8007e00 <dns_enqueue+0x2a8>

#if LWIP_DNS_SUPPORT_MDNS_QUERIES
  entry->is_mdns = is_mdns;
#endif

  dns_seqno++;
 8007de4:	4b0a      	ldr	r3, [pc, #40]	; (8007e10 <dns_enqueue+0x2b8>)
 8007de6:	781b      	ldrb	r3, [r3, #0]
 8007de8:	3301      	adds	r3, #1
 8007dea:	b2da      	uxtb	r2, r3
 8007dec:	4b08      	ldr	r3, [pc, #32]	; (8007e10 <dns_enqueue+0x2b8>)
 8007dee:	701a      	strb	r2, [r3, #0]

  /* force to send query without waiting timer */
  dns_check_entry(i);
 8007df0:	2327      	movs	r3, #39	; 0x27
 8007df2:	18fb      	adds	r3, r7, r3
 8007df4:	781b      	ldrb	r3, [r3, #0]
 8007df6:	0018      	movs	r0, r3
 8007df8:	f7ff fc26 	bl	8007648 <dns_check_entry>

  /* dns query is enqueued */
  return ERR_INPROGRESS;
 8007dfc:	2305      	movs	r3, #5
 8007dfe:	425b      	negs	r3, r3
}
 8007e00:	0018      	movs	r0, r3
 8007e02:	46bd      	mov	sp, r7
 8007e04:	b00b      	add	sp, #44	; 0x2c
 8007e06:	bd90      	pop	{r4, r7, pc}
 8007e08:	20001924 	.word	0x20001924
 8007e0c:	20001ad4 	.word	0x20001ad4
 8007e10:	20001921 	.word	0x20001921

08007e14 <dns_gethostbyname>:
 * @return a err_t return code.
 */
err_t
dns_gethostbyname(const char *hostname, ip_addr_t *addr, dns_found_callback found,
                  void *callback_arg)
{
 8007e14:	b590      	push	{r4, r7, lr}
 8007e16:	b087      	sub	sp, #28
 8007e18:	af02      	add	r7, sp, #8
 8007e1a:	60f8      	str	r0, [r7, #12]
 8007e1c:	60b9      	str	r1, [r7, #8]
 8007e1e:	607a      	str	r2, [r7, #4]
 8007e20:	603b      	str	r3, [r7, #0]
  return dns_gethostbyname_addrtype(hostname, addr, found, callback_arg, LWIP_DNS_ADDRTYPE_DEFAULT);
 8007e22:	683b      	ldr	r3, [r7, #0]
 8007e24:	687a      	ldr	r2, [r7, #4]
 8007e26:	68b9      	ldr	r1, [r7, #8]
 8007e28:	68f8      	ldr	r0, [r7, #12]
 8007e2a:	2400      	movs	r4, #0
 8007e2c:	9400      	str	r4, [sp, #0]
 8007e2e:	f000 f805 	bl	8007e3c <dns_gethostbyname_addrtype>
 8007e32:	0003      	movs	r3, r0
}
 8007e34:	0018      	movs	r0, r3
 8007e36:	46bd      	mov	sp, r7
 8007e38:	b005      	add	sp, #20
 8007e3a:	bd90      	pop	{r4, r7, pc}

08007e3c <dns_gethostbyname_addrtype>:
 *                     - LWIP_DNS_ADDRTYPE_IPV6: try to resolve IPv6 only
 */
err_t
dns_gethostbyname_addrtype(const char *hostname, ip_addr_t *addr, dns_found_callback found,
                           void *callback_arg, u8_t dns_addrtype)
{
 8007e3c:	b580      	push	{r7, lr}
 8007e3e:	b086      	sub	sp, #24
 8007e40:	af00      	add	r7, sp, #0
 8007e42:	60f8      	str	r0, [r7, #12]
 8007e44:	60b9      	str	r1, [r7, #8]
 8007e46:	607a      	str	r2, [r7, #4]
 8007e48:	603b      	str	r3, [r7, #0]
#if LWIP_DNS_SUPPORT_MDNS_QUERIES
  u8_t is_mdns;
#endif
  /* not initialized or no valid server yet, or invalid addr pointer
   * or invalid hostname or invalid hostname length */
  if ((addr == NULL) ||
 8007e4a:	68bb      	ldr	r3, [r7, #8]
 8007e4c:	2b00      	cmp	r3, #0
 8007e4e:	d006      	beq.n	8007e5e <dns_gethostbyname_addrtype+0x22>
 8007e50:	68fb      	ldr	r3, [r7, #12]
 8007e52:	2b00      	cmp	r3, #0
 8007e54:	d003      	beq.n	8007e5e <dns_gethostbyname_addrtype+0x22>
      (!hostname) || (!hostname[0])) {
 8007e56:	68fb      	ldr	r3, [r7, #12]
 8007e58:	781b      	ldrb	r3, [r3, #0]
 8007e5a:	2b00      	cmp	r3, #0
 8007e5c:	d102      	bne.n	8007e64 <dns_gethostbyname_addrtype+0x28>
    return ERR_ARG;
 8007e5e:	2310      	movs	r3, #16
 8007e60:	425b      	negs	r3, r3
 8007e62:	e02d      	b.n	8007ec0 <dns_gethostbyname_addrtype+0x84>
#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) == 0)
  if (dns_pcbs[0] == NULL) {
    return ERR_ARG;
  }
#endif
  hostnamelen = strlen(hostname);
 8007e64:	68fb      	ldr	r3, [r7, #12]
 8007e66:	0018      	movs	r0, r3
 8007e68:	f7f8 f94e 	bl	8000108 <strlen>
 8007e6c:	0003      	movs	r3, r0
 8007e6e:	617b      	str	r3, [r7, #20]
  if (hostnamelen >= DNS_MAX_NAME_LENGTH) {
 8007e70:	697b      	ldr	r3, [r7, #20]
 8007e72:	2b7f      	cmp	r3, #127	; 0x7f
 8007e74:	d902      	bls.n	8007e7c <dns_gethostbyname_addrtype+0x40>
    LWIP_DEBUGF(DNS_DEBUG, ("dns_gethostbyname: name too long to resolve"));
    return ERR_ARG;
 8007e76:	2310      	movs	r3, #16
 8007e78:	425b      	negs	r3, r3
 8007e7a:	e021      	b.n	8007ec0 <dns_gethostbyname_addrtype+0x84>
    return ERR_OK;
  }
#endif /* LWIP_HAVE_LOOPIF */

  /* host name already in octet notation? set ip addr and return ERR_OK */
  if (ipaddr_aton(hostname, addr)) {
 8007e7c:	68ba      	ldr	r2, [r7, #8]
 8007e7e:	68fb      	ldr	r3, [r7, #12]
 8007e80:	0011      	movs	r1, r2
 8007e82:	0018      	movs	r0, r3
 8007e84:	f00b fe92 	bl	8013bac <ip4addr_aton>
 8007e88:	1e03      	subs	r3, r0, #0
 8007e8a:	d001      	beq.n	8007e90 <dns_gethostbyname_addrtype+0x54>
#if LWIP_IPV4 && LWIP_IPV6
    if ((IP_IS_V6(addr) && (dns_addrtype != LWIP_DNS_ADDRTYPE_IPV4)) ||
        (IP_IS_V4(addr) && (dns_addrtype != LWIP_DNS_ADDRTYPE_IPV6)))
#endif /* LWIP_IPV4 && LWIP_IPV6 */
    {
      return ERR_OK;
 8007e8c:	2300      	movs	r3, #0
 8007e8e:	e017      	b.n	8007ec0 <dns_gethostbyname_addrtype+0x84>
    }
  }
  /* already have this address cached? */
  if (dns_lookup(hostname, addr LWIP_DNS_ADDRTYPE_ARG(dns_addrtype)) == ERR_OK) {
 8007e90:	68ba      	ldr	r2, [r7, #8]
 8007e92:	68fb      	ldr	r3, [r7, #12]
 8007e94:	0011      	movs	r1, r2
 8007e96:	0018      	movs	r0, r3
 8007e98:	f7fe ff76 	bl	8006d88 <dns_lookup>
 8007e9c:	1e03      	subs	r3, r0, #0
 8007e9e:	d101      	bne.n	8007ea4 <dns_gethostbyname_addrtype+0x68>
    return ERR_OK;
 8007ea0:	2300      	movs	r3, #0
 8007ea2:	e00d      	b.n	8007ec0 <dns_gethostbyname_addrtype+0x84>

  if (!is_mdns)
#endif /* LWIP_DNS_SUPPORT_MDNS_QUERIES */
  {
    /* prevent calling found callback if no server is set, return error instead */
    if (ip_addr_isany_val(dns_servers[0])) {
 8007ea4:	4b08      	ldr	r3, [pc, #32]	; (8007ec8 <dns_gethostbyname_addrtype+0x8c>)
 8007ea6:	681b      	ldr	r3, [r3, #0]
 8007ea8:	2b00      	cmp	r3, #0
 8007eaa:	d102      	bne.n	8007eb2 <dns_gethostbyname_addrtype+0x76>
      return ERR_VAL;
 8007eac:	2306      	movs	r3, #6
 8007eae:	425b      	negs	r3, r3
 8007eb0:	e006      	b.n	8007ec0 <dns_gethostbyname_addrtype+0x84>
    }
  }

  /* queue query with specified callback */
  return dns_enqueue(hostname, hostnamelen, found, callback_arg LWIP_DNS_ADDRTYPE_ARG(dns_addrtype)
 8007eb2:	683b      	ldr	r3, [r7, #0]
 8007eb4:	687a      	ldr	r2, [r7, #4]
 8007eb6:	6979      	ldr	r1, [r7, #20]
 8007eb8:	68f8      	ldr	r0, [r7, #12]
 8007eba:	f7ff fe4d 	bl	8007b58 <dns_enqueue>
 8007ebe:	0003      	movs	r3, r0
                     LWIP_DNS_ISMDNS_ARG(is_mdns));
}
 8007ec0:	0018      	movs	r0, r3
 8007ec2:	46bd      	mov	sp, r7
 8007ec4:	b006      	add	sp, #24
 8007ec6:	bd80      	pop	{r7, pc}
 8007ec8:	20001af8 	.word	0x20001af8

08007ecc <lwip_standard_chksum>:
 * @param len length of data to be summed
 * @return host order (!) lwip checksum (non-inverted Internet sum)
 */
u16_t
lwip_standard_chksum(const void *dataptr, int len)
{
 8007ecc:	b580      	push	{r7, lr}
 8007ece:	b088      	sub	sp, #32
 8007ed0:	af00      	add	r7, sp, #0
 8007ed2:	6078      	str	r0, [r7, #4]
 8007ed4:	6039      	str	r1, [r7, #0]
  const u8_t *pb = (const u8_t *)dataptr;
 8007ed6:	687b      	ldr	r3, [r7, #4]
 8007ed8:	61fb      	str	r3, [r7, #28]
  const u16_t *ps;
  u16_t t = 0;
 8007eda:	210e      	movs	r1, #14
 8007edc:	187b      	adds	r3, r7, r1
 8007ede:	2200      	movs	r2, #0
 8007ee0:	801a      	strh	r2, [r3, #0]
  u32_t sum = 0;
 8007ee2:	2300      	movs	r3, #0
 8007ee4:	617b      	str	r3, [r7, #20]
  int odd = ((mem_ptr_t)pb & 1);
 8007ee6:	69fb      	ldr	r3, [r7, #28]
 8007ee8:	2201      	movs	r2, #1
 8007eea:	4013      	ands	r3, r2
 8007eec:	613b      	str	r3, [r7, #16]

  /* Get aligned to u16_t */
  if (odd && len > 0) {
 8007eee:	693b      	ldr	r3, [r7, #16]
 8007ef0:	2b00      	cmp	r3, #0
 8007ef2:	d00c      	beq.n	8007f0e <lwip_standard_chksum+0x42>
 8007ef4:	683b      	ldr	r3, [r7, #0]
 8007ef6:	2b00      	cmp	r3, #0
 8007ef8:	dd09      	ble.n	8007f0e <lwip_standard_chksum+0x42>
    ((u8_t *)&t)[1] = *pb++;
 8007efa:	69fa      	ldr	r2, [r7, #28]
 8007efc:	1c53      	adds	r3, r2, #1
 8007efe:	61fb      	str	r3, [r7, #28]
 8007f00:	187b      	adds	r3, r7, r1
 8007f02:	3301      	adds	r3, #1
 8007f04:	7812      	ldrb	r2, [r2, #0]
 8007f06:	701a      	strb	r2, [r3, #0]
    len--;
 8007f08:	683b      	ldr	r3, [r7, #0]
 8007f0a:	3b01      	subs	r3, #1
 8007f0c:	603b      	str	r3, [r7, #0]
  }

  /* Add the bulk of the data */
  ps = (const u16_t *)(const void *)pb;
 8007f0e:	69fb      	ldr	r3, [r7, #28]
 8007f10:	61bb      	str	r3, [r7, #24]
  while (len > 1) {
 8007f12:	e00a      	b.n	8007f2a <lwip_standard_chksum+0x5e>
    sum += *ps++;
 8007f14:	69bb      	ldr	r3, [r7, #24]
 8007f16:	1c9a      	adds	r2, r3, #2
 8007f18:	61ba      	str	r2, [r7, #24]
 8007f1a:	881b      	ldrh	r3, [r3, #0]
 8007f1c:	001a      	movs	r2, r3
 8007f1e:	697b      	ldr	r3, [r7, #20]
 8007f20:	189b      	adds	r3, r3, r2
 8007f22:	617b      	str	r3, [r7, #20]
    len -= 2;
 8007f24:	683b      	ldr	r3, [r7, #0]
 8007f26:	3b02      	subs	r3, #2
 8007f28:	603b      	str	r3, [r7, #0]
  while (len > 1) {
 8007f2a:	683b      	ldr	r3, [r7, #0]
 8007f2c:	2b01      	cmp	r3, #1
 8007f2e:	dcf1      	bgt.n	8007f14 <lwip_standard_chksum+0x48>
  }

  /* Consume left-over byte, if any */
  if (len > 0) {
 8007f30:	683b      	ldr	r3, [r7, #0]
 8007f32:	2b00      	cmp	r3, #0
 8007f34:	dd04      	ble.n	8007f40 <lwip_standard_chksum+0x74>
    ((u8_t *)&t)[0] = *(const u8_t *)ps;
 8007f36:	230e      	movs	r3, #14
 8007f38:	18fb      	adds	r3, r7, r3
 8007f3a:	69ba      	ldr	r2, [r7, #24]
 8007f3c:	7812      	ldrb	r2, [r2, #0]
 8007f3e:	701a      	strb	r2, [r3, #0]
  }

  /* Add end bytes */
  sum += t;
 8007f40:	230e      	movs	r3, #14
 8007f42:	18fb      	adds	r3, r7, r3
 8007f44:	881b      	ldrh	r3, [r3, #0]
 8007f46:	001a      	movs	r2, r3
 8007f48:	697b      	ldr	r3, [r7, #20]
 8007f4a:	189b      	adds	r3, r3, r2
 8007f4c:	617b      	str	r3, [r7, #20]

  /* Fold 32-bit sum to 16 bits
     calling this twice is probably faster than if statements... */
  sum = FOLD_U32T(sum);
 8007f4e:	697b      	ldr	r3, [r7, #20]
 8007f50:	0c1a      	lsrs	r2, r3, #16
 8007f52:	697b      	ldr	r3, [r7, #20]
 8007f54:	041b      	lsls	r3, r3, #16
 8007f56:	0c1b      	lsrs	r3, r3, #16
 8007f58:	18d3      	adds	r3, r2, r3
 8007f5a:	617b      	str	r3, [r7, #20]
  sum = FOLD_U32T(sum);
 8007f5c:	697b      	ldr	r3, [r7, #20]
 8007f5e:	0c1a      	lsrs	r2, r3, #16
 8007f60:	697b      	ldr	r3, [r7, #20]
 8007f62:	041b      	lsls	r3, r3, #16
 8007f64:	0c1b      	lsrs	r3, r3, #16
 8007f66:	18d3      	adds	r3, r2, r3
 8007f68:	617b      	str	r3, [r7, #20]

  /* Swap if alignment was odd */
  if (odd) {
 8007f6a:	693b      	ldr	r3, [r7, #16]
 8007f6c:	2b00      	cmp	r3, #0
 8007f6e:	d009      	beq.n	8007f84 <lwip_standard_chksum+0xb8>
    sum = SWAP_BYTES_IN_WORD(sum);
 8007f70:	697b      	ldr	r3, [r7, #20]
 8007f72:	021b      	lsls	r3, r3, #8
 8007f74:	041b      	lsls	r3, r3, #16
 8007f76:	0c1a      	lsrs	r2, r3, #16
 8007f78:	697b      	ldr	r3, [r7, #20]
 8007f7a:	0a1b      	lsrs	r3, r3, #8
 8007f7c:	21ff      	movs	r1, #255	; 0xff
 8007f7e:	400b      	ands	r3, r1
 8007f80:	4313      	orrs	r3, r2
 8007f82:	617b      	str	r3, [r7, #20]
  }

  return (u16_t)sum;
 8007f84:	697b      	ldr	r3, [r7, #20]
 8007f86:	b29b      	uxth	r3, r3
}
 8007f88:	0018      	movs	r0, r3
 8007f8a:	46bd      	mov	sp, r7
 8007f8c:	b008      	add	sp, #32
 8007f8e:	bd80      	pop	{r7, pc}

08007f90 <inet_cksum_pseudo_base>:
#endif

/** Parts of the pseudo checksum which are common to IPv4 and IPv6 */
static u16_t
inet_cksum_pseudo_base(struct pbuf *p, u8_t proto, u16_t proto_len, u32_t acc)
{
 8007f90:	b580      	push	{r7, lr}
 8007f92:	b086      	sub	sp, #24
 8007f94:	af00      	add	r7, sp, #0
 8007f96:	60f8      	str	r0, [r7, #12]
 8007f98:	0008      	movs	r0, r1
 8007f9a:	0011      	movs	r1, r2
 8007f9c:	607b      	str	r3, [r7, #4]
 8007f9e:	230b      	movs	r3, #11
 8007fa0:	18fb      	adds	r3, r7, r3
 8007fa2:	1c02      	adds	r2, r0, #0
 8007fa4:	701a      	strb	r2, [r3, #0]
 8007fa6:	2308      	movs	r3, #8
 8007fa8:	18fb      	adds	r3, r7, r3
 8007faa:	1c0a      	adds	r2, r1, #0
 8007fac:	801a      	strh	r2, [r3, #0]
  struct pbuf *q;
  int swapped = 0;
 8007fae:	2300      	movs	r3, #0
 8007fb0:	613b      	str	r3, [r7, #16]

  /* iterate through all pbuf in chain */
  for (q = p; q != NULL; q = q->next) {
 8007fb2:	68fb      	ldr	r3, [r7, #12]
 8007fb4:	617b      	str	r3, [r7, #20]
 8007fb6:	e02c      	b.n	8008012 <inet_cksum_pseudo_base+0x82>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
                             (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
 8007fb8:	697b      	ldr	r3, [r7, #20]
 8007fba:	685a      	ldr	r2, [r3, #4]
 8007fbc:	697b      	ldr	r3, [r7, #20]
 8007fbe:	895b      	ldrh	r3, [r3, #10]
 8007fc0:	0019      	movs	r1, r3
 8007fc2:	0010      	movs	r0, r2
 8007fc4:	f7ff ff82 	bl	8007ecc <lwip_standard_chksum>
 8007fc8:	0003      	movs	r3, r0
 8007fca:	001a      	movs	r2, r3
 8007fcc:	687b      	ldr	r3, [r7, #4]
 8007fce:	189b      	adds	r3, r3, r2
 8007fd0:	607b      	str	r3, [r7, #4]
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
 8007fd2:	687b      	ldr	r3, [r7, #4]
 8007fd4:	0c1a      	lsrs	r2, r3, #16
 8007fd6:	687b      	ldr	r3, [r7, #4]
 8007fd8:	041b      	lsls	r3, r3, #16
 8007fda:	0c1b      	lsrs	r3, r3, #16
 8007fdc:	18d3      	adds	r3, r2, r3
 8007fde:	607b      	str	r3, [r7, #4]
    if (q->len % 2 != 0) {
 8007fe0:	697b      	ldr	r3, [r7, #20]
 8007fe2:	895b      	ldrh	r3, [r3, #10]
 8007fe4:	2201      	movs	r2, #1
 8007fe6:	4013      	ands	r3, r2
 8007fe8:	b29b      	uxth	r3, r3
 8007fea:	2b00      	cmp	r3, #0
 8007fec:	d00e      	beq.n	800800c <inet_cksum_pseudo_base+0x7c>
      swapped = !swapped;
 8007fee:	693b      	ldr	r3, [r7, #16]
 8007ff0:	425a      	negs	r2, r3
 8007ff2:	4153      	adcs	r3, r2
 8007ff4:	b2db      	uxtb	r3, r3
 8007ff6:	613b      	str	r3, [r7, #16]
      acc = SWAP_BYTES_IN_WORD(acc);
 8007ff8:	687b      	ldr	r3, [r7, #4]
 8007ffa:	021b      	lsls	r3, r3, #8
 8007ffc:	041b      	lsls	r3, r3, #16
 8007ffe:	0c1a      	lsrs	r2, r3, #16
 8008000:	687b      	ldr	r3, [r7, #4]
 8008002:	0a1b      	lsrs	r3, r3, #8
 8008004:	21ff      	movs	r1, #255	; 0xff
 8008006:	400b      	ands	r3, r1
 8008008:	4313      	orrs	r3, r2
 800800a:	607b      	str	r3, [r7, #4]
  for (q = p; q != NULL; q = q->next) {
 800800c:	697b      	ldr	r3, [r7, #20]
 800800e:	681b      	ldr	r3, [r3, #0]
 8008010:	617b      	str	r3, [r7, #20]
 8008012:	697b      	ldr	r3, [r7, #20]
 8008014:	2b00      	cmp	r3, #0
 8008016:	d1cf      	bne.n	8007fb8 <inet_cksum_pseudo_base+0x28>
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
 8008018:	693b      	ldr	r3, [r7, #16]
 800801a:	2b00      	cmp	r3, #0
 800801c:	d009      	beq.n	8008032 <inet_cksum_pseudo_base+0xa2>
    acc = SWAP_BYTES_IN_WORD(acc);
 800801e:	687b      	ldr	r3, [r7, #4]
 8008020:	021b      	lsls	r3, r3, #8
 8008022:	041b      	lsls	r3, r3, #16
 8008024:	0c1a      	lsrs	r2, r3, #16
 8008026:	687b      	ldr	r3, [r7, #4]
 8008028:	0a1b      	lsrs	r3, r3, #8
 800802a:	21ff      	movs	r1, #255	; 0xff
 800802c:	400b      	ands	r3, r1
 800802e:	4313      	orrs	r3, r2
 8008030:	607b      	str	r3, [r7, #4]
  }

  acc += (u32_t)lwip_htons((u16_t)proto);
 8008032:	230b      	movs	r3, #11
 8008034:	18fb      	adds	r3, r7, r3
 8008036:	781b      	ldrb	r3, [r3, #0]
 8008038:	b29b      	uxth	r3, r3
 800803a:	0018      	movs	r0, r3
 800803c:	f7fe fde4 	bl	8006c08 <lwip_htons>
 8008040:	0003      	movs	r3, r0
 8008042:	001a      	movs	r2, r3
 8008044:	687b      	ldr	r3, [r7, #4]
 8008046:	189b      	adds	r3, r3, r2
 8008048:	607b      	str	r3, [r7, #4]
  acc += (u32_t)lwip_htons(proto_len);
 800804a:	2308      	movs	r3, #8
 800804c:	18fb      	adds	r3, r7, r3
 800804e:	881b      	ldrh	r3, [r3, #0]
 8008050:	0018      	movs	r0, r3
 8008052:	f7fe fdd9 	bl	8006c08 <lwip_htons>
 8008056:	0003      	movs	r3, r0
 8008058:	001a      	movs	r2, r3
 800805a:	687b      	ldr	r3, [r7, #4]
 800805c:	189b      	adds	r3, r3, r2
 800805e:	607b      	str	r3, [r7, #4]

  /* Fold 32-bit sum to 16 bits
     calling this twice is probably faster than if statements... */
  acc = FOLD_U32T(acc);
 8008060:	687b      	ldr	r3, [r7, #4]
 8008062:	0c1a      	lsrs	r2, r3, #16
 8008064:	687b      	ldr	r3, [r7, #4]
 8008066:	041b      	lsls	r3, r3, #16
 8008068:	0c1b      	lsrs	r3, r3, #16
 800806a:	18d3      	adds	r3, r2, r3
 800806c:	607b      	str	r3, [r7, #4]
  acc = FOLD_U32T(acc);
 800806e:	687b      	ldr	r3, [r7, #4]
 8008070:	0c1a      	lsrs	r2, r3, #16
 8008072:	687b      	ldr	r3, [r7, #4]
 8008074:	041b      	lsls	r3, r3, #16
 8008076:	0c1b      	lsrs	r3, r3, #16
 8008078:	18d3      	adds	r3, r2, r3
 800807a:	607b      	str	r3, [r7, #4]
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
 800807c:	687b      	ldr	r3, [r7, #4]
 800807e:	b29b      	uxth	r3, r3
 8008080:	43db      	mvns	r3, r3
 8008082:	b29b      	uxth	r3, r3
}
 8008084:	0018      	movs	r0, r3
 8008086:	46bd      	mov	sp, r7
 8008088:	b006      	add	sp, #24
 800808a:	bd80      	pop	{r7, pc}

0800808c <inet_chksum_pseudo>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pseudo(struct pbuf *p, u8_t proto, u16_t proto_len,
                   const ip4_addr_t *src, const ip4_addr_t *dest)
{
 800808c:	b5b0      	push	{r4, r5, r7, lr}
 800808e:	b086      	sub	sp, #24
 8008090:	af00      	add	r7, sp, #0
 8008092:	60f8      	str	r0, [r7, #12]
 8008094:	0008      	movs	r0, r1
 8008096:	0011      	movs	r1, r2
 8008098:	607b      	str	r3, [r7, #4]
 800809a:	250b      	movs	r5, #11
 800809c:	197b      	adds	r3, r7, r5
 800809e:	1c02      	adds	r2, r0, #0
 80080a0:	701a      	strb	r2, [r3, #0]
 80080a2:	2008      	movs	r0, #8
 80080a4:	183b      	adds	r3, r7, r0
 80080a6:	1c0a      	adds	r2, r1, #0
 80080a8:	801a      	strh	r2, [r3, #0]
  u32_t acc;
  u32_t addr;

  addr = ip4_addr_get_u32(src);
 80080aa:	687b      	ldr	r3, [r7, #4]
 80080ac:	681b      	ldr	r3, [r3, #0]
 80080ae:	617b      	str	r3, [r7, #20]
  acc = (addr & 0xffffUL);
 80080b0:	697b      	ldr	r3, [r7, #20]
 80080b2:	041b      	lsls	r3, r3, #16
 80080b4:	0c1b      	lsrs	r3, r3, #16
 80080b6:	613b      	str	r3, [r7, #16]
  acc = (u32_t)(acc + ((addr >> 16) & 0xffffUL));
 80080b8:	697b      	ldr	r3, [r7, #20]
 80080ba:	0c1b      	lsrs	r3, r3, #16
 80080bc:	693a      	ldr	r2, [r7, #16]
 80080be:	18d3      	adds	r3, r2, r3
 80080c0:	613b      	str	r3, [r7, #16]
  addr = ip4_addr_get_u32(dest);
 80080c2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80080c4:	681b      	ldr	r3, [r3, #0]
 80080c6:	617b      	str	r3, [r7, #20]
  acc = (u32_t)(acc + (addr & 0xffffUL));
 80080c8:	697b      	ldr	r3, [r7, #20]
 80080ca:	041b      	lsls	r3, r3, #16
 80080cc:	0c1b      	lsrs	r3, r3, #16
 80080ce:	693a      	ldr	r2, [r7, #16]
 80080d0:	18d3      	adds	r3, r2, r3
 80080d2:	613b      	str	r3, [r7, #16]
  acc = (u32_t)(acc + ((addr >> 16) & 0xffffUL));
 80080d4:	697b      	ldr	r3, [r7, #20]
 80080d6:	0c1b      	lsrs	r3, r3, #16
 80080d8:	693a      	ldr	r2, [r7, #16]
 80080da:	18d3      	adds	r3, r2, r3
 80080dc:	613b      	str	r3, [r7, #16]
  /* fold down to 16 bits */
  acc = FOLD_U32T(acc);
 80080de:	693b      	ldr	r3, [r7, #16]
 80080e0:	0c1a      	lsrs	r2, r3, #16
 80080e2:	693b      	ldr	r3, [r7, #16]
 80080e4:	041b      	lsls	r3, r3, #16
 80080e6:	0c1b      	lsrs	r3, r3, #16
 80080e8:	18d3      	adds	r3, r2, r3
 80080ea:	613b      	str	r3, [r7, #16]
  acc = FOLD_U32T(acc);
 80080ec:	693b      	ldr	r3, [r7, #16]
 80080ee:	0c1a      	lsrs	r2, r3, #16
 80080f0:	693b      	ldr	r3, [r7, #16]
 80080f2:	041b      	lsls	r3, r3, #16
 80080f4:	0c1b      	lsrs	r3, r3, #16
 80080f6:	18d3      	adds	r3, r2, r3
 80080f8:	613b      	str	r3, [r7, #16]

  return inet_cksum_pseudo_base(p, proto, proto_len, acc);
 80080fa:	693c      	ldr	r4, [r7, #16]
 80080fc:	183b      	adds	r3, r7, r0
 80080fe:	881a      	ldrh	r2, [r3, #0]
 8008100:	197b      	adds	r3, r7, r5
 8008102:	7819      	ldrb	r1, [r3, #0]
 8008104:	68f8      	ldr	r0, [r7, #12]
 8008106:	0023      	movs	r3, r4
 8008108:	f7ff ff42 	bl	8007f90 <inet_cksum_pseudo_base>
 800810c:	0003      	movs	r3, r0
}
 800810e:	0018      	movs	r0, r3
 8008110:	46bd      	mov	sp, r7
 8008112:	b006      	add	sp, #24
 8008114:	bdb0      	pop	{r4, r5, r7, pc}

08008116 <ip_chksum_pseudo>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
ip_chksum_pseudo(struct pbuf *p, u8_t proto, u16_t proto_len,
                 const ip_addr_t *src, const ip_addr_t *dest)
{
 8008116:	b5b0      	push	{r4, r5, r7, lr}
 8008118:	b086      	sub	sp, #24
 800811a:	af02      	add	r7, sp, #8
 800811c:	60f8      	str	r0, [r7, #12]
 800811e:	0008      	movs	r0, r1
 8008120:	0011      	movs	r1, r2
 8008122:	607b      	str	r3, [r7, #4]
 8008124:	250b      	movs	r5, #11
 8008126:	197b      	adds	r3, r7, r5
 8008128:	1c02      	adds	r2, r0, #0
 800812a:	701a      	strb	r2, [r3, #0]
 800812c:	2008      	movs	r0, #8
 800812e:	183b      	adds	r3, r7, r0
 8008130:	1c0a      	adds	r2, r1, #0
 8008132:	801a      	strh	r2, [r3, #0]
#if LWIP_IPV4 && LWIP_IPV6
  else
#endif /* LWIP_IPV4 && LWIP_IPV6 */
#if LWIP_IPV4
  {
    return inet_chksum_pseudo(p, proto, proto_len, ip_2_ip4(src), ip_2_ip4(dest));
 8008134:	687c      	ldr	r4, [r7, #4]
 8008136:	183b      	adds	r3, r7, r0
 8008138:	881a      	ldrh	r2, [r3, #0]
 800813a:	197b      	adds	r3, r7, r5
 800813c:	7819      	ldrb	r1, [r3, #0]
 800813e:	68f8      	ldr	r0, [r7, #12]
 8008140:	6a3b      	ldr	r3, [r7, #32]
 8008142:	9300      	str	r3, [sp, #0]
 8008144:	0023      	movs	r3, r4
 8008146:	f7ff ffa1 	bl	800808c <inet_chksum_pseudo>
 800814a:	0003      	movs	r3, r0
  }
#endif /* LWIP_IPV4 */
}
 800814c:	0018      	movs	r0, r3
 800814e:	46bd      	mov	sp, r7
 8008150:	b004      	add	sp, #16
 8008152:	bdb0      	pop	{r4, r5, r7, pc}

08008154 <inet_cksum_pseudo_partial_base>:

/** Parts of the pseudo checksum which are common to IPv4 and IPv6 */
static u16_t
inet_cksum_pseudo_partial_base(struct pbuf *p, u8_t proto, u16_t proto_len,
                               u16_t chksum_len, u32_t acc)
{
 8008154:	b590      	push	{r4, r7, lr}
 8008156:	b089      	sub	sp, #36	; 0x24
 8008158:	af00      	add	r7, sp, #0
 800815a:	60f8      	str	r0, [r7, #12]
 800815c:	000c      	movs	r4, r1
 800815e:	0010      	movs	r0, r2
 8008160:	0019      	movs	r1, r3
 8008162:	230b      	movs	r3, #11
 8008164:	18fb      	adds	r3, r7, r3
 8008166:	1c22      	adds	r2, r4, #0
 8008168:	701a      	strb	r2, [r3, #0]
 800816a:	2308      	movs	r3, #8
 800816c:	18fb      	adds	r3, r7, r3
 800816e:	1c02      	adds	r2, r0, #0
 8008170:	801a      	strh	r2, [r3, #0]
 8008172:	1dbb      	adds	r3, r7, #6
 8008174:	1c0a      	adds	r2, r1, #0
 8008176:	801a      	strh	r2, [r3, #0]
  struct pbuf *q;
  int swapped = 0;
 8008178:	2300      	movs	r3, #0
 800817a:	61bb      	str	r3, [r7, #24]
  u16_t chklen;

  /* iterate through all pbuf in chain */
  for (q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
 800817c:	68fb      	ldr	r3, [r7, #12]
 800817e:	61fb      	str	r3, [r7, #28]
 8008180:	e04f      	b.n	8008222 <inet_cksum_pseudo_partial_base+0xce>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
                             (void *)q, (void *)q->next));
    chklen = q->len;
 8008182:	2116      	movs	r1, #22
 8008184:	187b      	adds	r3, r7, r1
 8008186:	69fa      	ldr	r2, [r7, #28]
 8008188:	8952      	ldrh	r2, [r2, #10]
 800818a:	801a      	strh	r2, [r3, #0]
    if (chklen > chksum_len) {
 800818c:	187a      	adds	r2, r7, r1
 800818e:	1dbb      	adds	r3, r7, #6
 8008190:	8812      	ldrh	r2, [r2, #0]
 8008192:	881b      	ldrh	r3, [r3, #0]
 8008194:	429a      	cmp	r2, r3
 8008196:	d903      	bls.n	80081a0 <inet_cksum_pseudo_partial_base+0x4c>
      chklen = chksum_len;
 8008198:	187b      	adds	r3, r7, r1
 800819a:	1dba      	adds	r2, r7, #6
 800819c:	8812      	ldrh	r2, [r2, #0]
 800819e:	801a      	strh	r2, [r3, #0]
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
 80081a0:	69fb      	ldr	r3, [r7, #28]
 80081a2:	685a      	ldr	r2, [r3, #4]
 80081a4:	2416      	movs	r4, #22
 80081a6:	193b      	adds	r3, r7, r4
 80081a8:	881b      	ldrh	r3, [r3, #0]
 80081aa:	0019      	movs	r1, r3
 80081ac:	0010      	movs	r0, r2
 80081ae:	f7ff fe8d 	bl	8007ecc <lwip_standard_chksum>
 80081b2:	0003      	movs	r3, r0
 80081b4:	001a      	movs	r2, r3
 80081b6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80081b8:	189b      	adds	r3, r3, r2
 80081ba:	633b      	str	r3, [r7, #48]	; 0x30
    chksum_len = (u16_t)(chksum_len - chklen);
 80081bc:	1dbb      	adds	r3, r7, #6
 80081be:	1db9      	adds	r1, r7, #6
 80081c0:	193a      	adds	r2, r7, r4
 80081c2:	8809      	ldrh	r1, [r1, #0]
 80081c4:	8812      	ldrh	r2, [r2, #0]
 80081c6:	1a8a      	subs	r2, r1, r2
 80081c8:	801a      	strh	r2, [r3, #0]
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
 80081ca:	1dbb      	adds	r3, r7, #6
 80081cc:	881b      	ldrh	r3, [r3, #0]
 80081ce:	4a35      	ldr	r2, [pc, #212]	; (80082a4 <inet_cksum_pseudo_partial_base+0x150>)
 80081d0:	4293      	cmp	r3, r2
 80081d2:	d906      	bls.n	80081e2 <inet_cksum_pseudo_partial_base+0x8e>
 80081d4:	4b34      	ldr	r3, [pc, #208]	; (80082a8 <inet_cksum_pseudo_partial_base+0x154>)
 80081d6:	22d0      	movs	r2, #208	; 0xd0
 80081d8:	0052      	lsls	r2, r2, #1
 80081da:	4934      	ldr	r1, [pc, #208]	; (80082ac <inet_cksum_pseudo_partial_base+0x158>)
 80081dc:	4834      	ldr	r0, [pc, #208]	; (80082b0 <inet_cksum_pseudo_partial_base+0x15c>)
 80081de:	f7fa fb7d 	bl	80028dc <app_debug_rtt_raw>
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
 80081e2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80081e4:	0c1a      	lsrs	r2, r3, #16
 80081e6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80081e8:	041b      	lsls	r3, r3, #16
 80081ea:	0c1b      	lsrs	r3, r3, #16
 80081ec:	18d3      	adds	r3, r2, r3
 80081ee:	633b      	str	r3, [r7, #48]	; 0x30
    if (q->len % 2 != 0) {
 80081f0:	69fb      	ldr	r3, [r7, #28]
 80081f2:	895b      	ldrh	r3, [r3, #10]
 80081f4:	2201      	movs	r2, #1
 80081f6:	4013      	ands	r3, r2
 80081f8:	b29b      	uxth	r3, r3
 80081fa:	2b00      	cmp	r3, #0
 80081fc:	d00e      	beq.n	800821c <inet_cksum_pseudo_partial_base+0xc8>
      swapped = !swapped;
 80081fe:	69bb      	ldr	r3, [r7, #24]
 8008200:	425a      	negs	r2, r3
 8008202:	4153      	adcs	r3, r2
 8008204:	b2db      	uxtb	r3, r3
 8008206:	61bb      	str	r3, [r7, #24]
      acc = SWAP_BYTES_IN_WORD(acc);
 8008208:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800820a:	021b      	lsls	r3, r3, #8
 800820c:	041b      	lsls	r3, r3, #16
 800820e:	0c1a      	lsrs	r2, r3, #16
 8008210:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008212:	0a1b      	lsrs	r3, r3, #8
 8008214:	21ff      	movs	r1, #255	; 0xff
 8008216:	400b      	ands	r3, r1
 8008218:	4313      	orrs	r3, r2
 800821a:	633b      	str	r3, [r7, #48]	; 0x30
  for (q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
 800821c:	69fb      	ldr	r3, [r7, #28]
 800821e:	681b      	ldr	r3, [r3, #0]
 8008220:	61fb      	str	r3, [r7, #28]
 8008222:	69fb      	ldr	r3, [r7, #28]
 8008224:	2b00      	cmp	r3, #0
 8008226:	d003      	beq.n	8008230 <inet_cksum_pseudo_partial_base+0xdc>
 8008228:	1dbb      	adds	r3, r7, #6
 800822a:	881b      	ldrh	r3, [r3, #0]
 800822c:	2b00      	cmp	r3, #0
 800822e:	d1a8      	bne.n	8008182 <inet_cksum_pseudo_partial_base+0x2e>
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
 8008230:	69bb      	ldr	r3, [r7, #24]
 8008232:	2b00      	cmp	r3, #0
 8008234:	d009      	beq.n	800824a <inet_cksum_pseudo_partial_base+0xf6>
    acc = SWAP_BYTES_IN_WORD(acc);
 8008236:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008238:	021b      	lsls	r3, r3, #8
 800823a:	041b      	lsls	r3, r3, #16
 800823c:	0c1a      	lsrs	r2, r3, #16
 800823e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008240:	0a1b      	lsrs	r3, r3, #8
 8008242:	21ff      	movs	r1, #255	; 0xff
 8008244:	400b      	ands	r3, r1
 8008246:	4313      	orrs	r3, r2
 8008248:	633b      	str	r3, [r7, #48]	; 0x30
  }

  acc += (u32_t)lwip_htons((u16_t)proto);
 800824a:	230b      	movs	r3, #11
 800824c:	18fb      	adds	r3, r7, r3
 800824e:	781b      	ldrb	r3, [r3, #0]
 8008250:	b29b      	uxth	r3, r3
 8008252:	0018      	movs	r0, r3
 8008254:	f7fe fcd8 	bl	8006c08 <lwip_htons>
 8008258:	0003      	movs	r3, r0
 800825a:	001a      	movs	r2, r3
 800825c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800825e:	189b      	adds	r3, r3, r2
 8008260:	633b      	str	r3, [r7, #48]	; 0x30
  acc += (u32_t)lwip_htons(proto_len);
 8008262:	2308      	movs	r3, #8
 8008264:	18fb      	adds	r3, r7, r3
 8008266:	881b      	ldrh	r3, [r3, #0]
 8008268:	0018      	movs	r0, r3
 800826a:	f7fe fccd 	bl	8006c08 <lwip_htons>
 800826e:	0003      	movs	r3, r0
 8008270:	001a      	movs	r2, r3
 8008272:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008274:	189b      	adds	r3, r3, r2
 8008276:	633b      	str	r3, [r7, #48]	; 0x30

  /* Fold 32-bit sum to 16 bits
     calling this twice is probably faster than if statements... */
  acc = FOLD_U32T(acc);
 8008278:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800827a:	0c1a      	lsrs	r2, r3, #16
 800827c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800827e:	041b      	lsls	r3, r3, #16
 8008280:	0c1b      	lsrs	r3, r3, #16
 8008282:	18d3      	adds	r3, r2, r3
 8008284:	633b      	str	r3, [r7, #48]	; 0x30
  acc = FOLD_U32T(acc);
 8008286:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008288:	0c1a      	lsrs	r2, r3, #16
 800828a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800828c:	041b      	lsls	r3, r3, #16
 800828e:	0c1b      	lsrs	r3, r3, #16
 8008290:	18d3      	adds	r3, r2, r3
 8008292:	633b      	str	r3, [r7, #48]	; 0x30
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
 8008294:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008296:	b29b      	uxth	r3, r3
 8008298:	43db      	mvns	r3, r3
 800829a:	b29b      	uxth	r3, r3
}
 800829c:	0018      	movs	r0, r3
 800829e:	46bd      	mov	sp, r7
 80082a0:	b009      	add	sp, #36	; 0x24
 80082a2:	bd90      	pop	{r4, r7, pc}
 80082a4:	00007ffe 	.word	0x00007ffe
 80082a8:	0801eec8 	.word	0x0801eec8
 80082ac:	0801eef8 	.word	0x0801eef8
 80082b0:	0801ef04 	.word	0x0801ef04

080082b4 <inet_chksum_pseudo_partial>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p, u8_t proto, u16_t proto_len,
                           u16_t chksum_len, const ip4_addr_t *src, const ip4_addr_t *dest)
{
 80082b4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80082b6:	b089      	sub	sp, #36	; 0x24
 80082b8:	af02      	add	r7, sp, #8
 80082ba:	60f8      	str	r0, [r7, #12]
 80082bc:	000c      	movs	r4, r1
 80082be:	0010      	movs	r0, r2
 80082c0:	0019      	movs	r1, r3
 80082c2:	250b      	movs	r5, #11
 80082c4:	197b      	adds	r3, r7, r5
 80082c6:	1c22      	adds	r2, r4, #0
 80082c8:	701a      	strb	r2, [r3, #0]
 80082ca:	2608      	movs	r6, #8
 80082cc:	19bb      	adds	r3, r7, r6
 80082ce:	1c02      	adds	r2, r0, #0
 80082d0:	801a      	strh	r2, [r3, #0]
 80082d2:	1dbb      	adds	r3, r7, #6
 80082d4:	1c0a      	adds	r2, r1, #0
 80082d6:	801a      	strh	r2, [r3, #0]
  u32_t acc;
  u32_t addr;

  addr = ip4_addr_get_u32(src);
 80082d8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80082da:	681b      	ldr	r3, [r3, #0]
 80082dc:	617b      	str	r3, [r7, #20]
  acc = (addr & 0xffffUL);
 80082de:	697b      	ldr	r3, [r7, #20]
 80082e0:	041b      	lsls	r3, r3, #16
 80082e2:	0c1b      	lsrs	r3, r3, #16
 80082e4:	613b      	str	r3, [r7, #16]
  acc = (u32_t)(acc + ((addr >> 16) & 0xffffUL));
 80082e6:	697b      	ldr	r3, [r7, #20]
 80082e8:	0c1b      	lsrs	r3, r3, #16
 80082ea:	693a      	ldr	r2, [r7, #16]
 80082ec:	18d3      	adds	r3, r2, r3
 80082ee:	613b      	str	r3, [r7, #16]
  addr = ip4_addr_get_u32(dest);
 80082f0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80082f2:	681b      	ldr	r3, [r3, #0]
 80082f4:	617b      	str	r3, [r7, #20]
  acc = (u32_t)(acc + (addr & 0xffffUL));
 80082f6:	697b      	ldr	r3, [r7, #20]
 80082f8:	041b      	lsls	r3, r3, #16
 80082fa:	0c1b      	lsrs	r3, r3, #16
 80082fc:	693a      	ldr	r2, [r7, #16]
 80082fe:	18d3      	adds	r3, r2, r3
 8008300:	613b      	str	r3, [r7, #16]
  acc = (u32_t)(acc + ((addr >> 16) & 0xffffUL));
 8008302:	697b      	ldr	r3, [r7, #20]
 8008304:	0c1b      	lsrs	r3, r3, #16
 8008306:	693a      	ldr	r2, [r7, #16]
 8008308:	18d3      	adds	r3, r2, r3
 800830a:	613b      	str	r3, [r7, #16]
  /* fold down to 16 bits */
  acc = FOLD_U32T(acc);
 800830c:	693b      	ldr	r3, [r7, #16]
 800830e:	0c1a      	lsrs	r2, r3, #16
 8008310:	693b      	ldr	r3, [r7, #16]
 8008312:	041b      	lsls	r3, r3, #16
 8008314:	0c1b      	lsrs	r3, r3, #16
 8008316:	18d3      	adds	r3, r2, r3
 8008318:	613b      	str	r3, [r7, #16]
  acc = FOLD_U32T(acc);
 800831a:	693b      	ldr	r3, [r7, #16]
 800831c:	0c1a      	lsrs	r2, r3, #16
 800831e:	693b      	ldr	r3, [r7, #16]
 8008320:	041b      	lsls	r3, r3, #16
 8008322:	0c1b      	lsrs	r3, r3, #16
 8008324:	18d3      	adds	r3, r2, r3
 8008326:	613b      	str	r3, [r7, #16]

  return inet_cksum_pseudo_partial_base(p, proto, proto_len, chksum_len, acc);
 8008328:	1dbb      	adds	r3, r7, #6
 800832a:	881c      	ldrh	r4, [r3, #0]
 800832c:	19bb      	adds	r3, r7, r6
 800832e:	881a      	ldrh	r2, [r3, #0]
 8008330:	197b      	adds	r3, r7, r5
 8008332:	7819      	ldrb	r1, [r3, #0]
 8008334:	68f8      	ldr	r0, [r7, #12]
 8008336:	693b      	ldr	r3, [r7, #16]
 8008338:	9300      	str	r3, [sp, #0]
 800833a:	0023      	movs	r3, r4
 800833c:	f7ff ff0a 	bl	8008154 <inet_cksum_pseudo_partial_base>
 8008340:	0003      	movs	r3, r0
}
 8008342:	0018      	movs	r0, r3
 8008344:	46bd      	mov	sp, r7
 8008346:	b007      	add	sp, #28
 8008348:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800834a <ip_chksum_pseudo_partial>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
ip_chksum_pseudo_partial(struct pbuf *p, u8_t proto, u16_t proto_len,
                         u16_t chksum_len, const ip_addr_t *src, const ip_addr_t *dest)
{
 800834a:	b5f0      	push	{r4, r5, r6, r7, lr}
 800834c:	b087      	sub	sp, #28
 800834e:	af02      	add	r7, sp, #8
 8008350:	60f8      	str	r0, [r7, #12]
 8008352:	000c      	movs	r4, r1
 8008354:	0010      	movs	r0, r2
 8008356:	0019      	movs	r1, r3
 8008358:	250b      	movs	r5, #11
 800835a:	197b      	adds	r3, r7, r5
 800835c:	1c22      	adds	r2, r4, #0
 800835e:	701a      	strb	r2, [r3, #0]
 8008360:	2608      	movs	r6, #8
 8008362:	19bb      	adds	r3, r7, r6
 8008364:	1c02      	adds	r2, r0, #0
 8008366:	801a      	strh	r2, [r3, #0]
 8008368:	1dbb      	adds	r3, r7, #6
 800836a:	1c0a      	adds	r2, r1, #0
 800836c:	801a      	strh	r2, [r3, #0]
#if LWIP_IPV4 && LWIP_IPV6
  else
#endif /* LWIP_IPV4 && LWIP_IPV6 */
#if LWIP_IPV4
  {
    return inet_chksum_pseudo_partial(p, proto, proto_len, chksum_len, ip_2_ip4(src), ip_2_ip4(dest));
 800836e:	1dbb      	adds	r3, r7, #6
 8008370:	881c      	ldrh	r4, [r3, #0]
 8008372:	19bb      	adds	r3, r7, r6
 8008374:	881a      	ldrh	r2, [r3, #0]
 8008376:	197b      	adds	r3, r7, r5
 8008378:	7819      	ldrb	r1, [r3, #0]
 800837a:	68f8      	ldr	r0, [r7, #12]
 800837c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800837e:	9301      	str	r3, [sp, #4]
 8008380:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008382:	9300      	str	r3, [sp, #0]
 8008384:	0023      	movs	r3, r4
 8008386:	f7ff ff95 	bl	80082b4 <inet_chksum_pseudo_partial>
 800838a:	0003      	movs	r3, r0
  }
#endif /* LWIP_IPV4 */
}
 800838c:	0018      	movs	r0, r3
 800838e:	46bd      	mov	sp, r7
 8008390:	b005      	add	sp, #20
 8008392:	bdf0      	pop	{r4, r5, r6, r7, pc}

08008394 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(const void *dataptr, u16_t len)
{
 8008394:	b580      	push	{r7, lr}
 8008396:	b082      	sub	sp, #8
 8008398:	af00      	add	r7, sp, #0
 800839a:	6078      	str	r0, [r7, #4]
 800839c:	000a      	movs	r2, r1
 800839e:	1cbb      	adds	r3, r7, #2
 80083a0:	801a      	strh	r2, [r3, #0]
  return (u16_t)~(unsigned int)LWIP_CHKSUM(dataptr, len);
 80083a2:	1cbb      	adds	r3, r7, #2
 80083a4:	881a      	ldrh	r2, [r3, #0]
 80083a6:	687b      	ldr	r3, [r7, #4]
 80083a8:	0011      	movs	r1, r2
 80083aa:	0018      	movs	r0, r3
 80083ac:	f7ff fd8e 	bl	8007ecc <lwip_standard_chksum>
 80083b0:	0003      	movs	r3, r0
 80083b2:	43db      	mvns	r3, r3
 80083b4:	b29b      	uxth	r3, r3
}
 80083b6:	0018      	movs	r0, r3
 80083b8:	46bd      	mov	sp, r7
 80083ba:	b002      	add	sp, #8
 80083bc:	bd80      	pop	{r7, pc}

080083be <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
 80083be:	b580      	push	{r7, lr}
 80083c0:	b086      	sub	sp, #24
 80083c2:	af00      	add	r7, sp, #0
 80083c4:	6078      	str	r0, [r7, #4]
  u32_t acc;
  struct pbuf *q;
  int swapped = 0;
 80083c6:	2300      	movs	r3, #0
 80083c8:	60fb      	str	r3, [r7, #12]

  acc = 0;
 80083ca:	2300      	movs	r3, #0
 80083cc:	617b      	str	r3, [r7, #20]
  for (q = p; q != NULL; q = q->next) {
 80083ce:	687b      	ldr	r3, [r7, #4]
 80083d0:	613b      	str	r3, [r7, #16]
 80083d2:	e02c      	b.n	800842e <inet_chksum_pbuf+0x70>
    acc += LWIP_CHKSUM(q->payload, q->len);
 80083d4:	693b      	ldr	r3, [r7, #16]
 80083d6:	685a      	ldr	r2, [r3, #4]
 80083d8:	693b      	ldr	r3, [r7, #16]
 80083da:	895b      	ldrh	r3, [r3, #10]
 80083dc:	0019      	movs	r1, r3
 80083de:	0010      	movs	r0, r2
 80083e0:	f7ff fd74 	bl	8007ecc <lwip_standard_chksum>
 80083e4:	0003      	movs	r3, r0
 80083e6:	001a      	movs	r2, r3
 80083e8:	697b      	ldr	r3, [r7, #20]
 80083ea:	189b      	adds	r3, r3, r2
 80083ec:	617b      	str	r3, [r7, #20]
    acc = FOLD_U32T(acc);
 80083ee:	697b      	ldr	r3, [r7, #20]
 80083f0:	0c1a      	lsrs	r2, r3, #16
 80083f2:	697b      	ldr	r3, [r7, #20]
 80083f4:	041b      	lsls	r3, r3, #16
 80083f6:	0c1b      	lsrs	r3, r3, #16
 80083f8:	18d3      	adds	r3, r2, r3
 80083fa:	617b      	str	r3, [r7, #20]
    if (q->len % 2 != 0) {
 80083fc:	693b      	ldr	r3, [r7, #16]
 80083fe:	895b      	ldrh	r3, [r3, #10]
 8008400:	2201      	movs	r2, #1
 8008402:	4013      	ands	r3, r2
 8008404:	b29b      	uxth	r3, r3
 8008406:	2b00      	cmp	r3, #0
 8008408:	d00e      	beq.n	8008428 <inet_chksum_pbuf+0x6a>
      swapped = !swapped;
 800840a:	68fb      	ldr	r3, [r7, #12]
 800840c:	425a      	negs	r2, r3
 800840e:	4153      	adcs	r3, r2
 8008410:	b2db      	uxtb	r3, r3
 8008412:	60fb      	str	r3, [r7, #12]
      acc = SWAP_BYTES_IN_WORD(acc);
 8008414:	697b      	ldr	r3, [r7, #20]
 8008416:	021b      	lsls	r3, r3, #8
 8008418:	041b      	lsls	r3, r3, #16
 800841a:	0c1a      	lsrs	r2, r3, #16
 800841c:	697b      	ldr	r3, [r7, #20]
 800841e:	0a1b      	lsrs	r3, r3, #8
 8008420:	21ff      	movs	r1, #255	; 0xff
 8008422:	400b      	ands	r3, r1
 8008424:	4313      	orrs	r3, r2
 8008426:	617b      	str	r3, [r7, #20]
  for (q = p; q != NULL; q = q->next) {
 8008428:	693b      	ldr	r3, [r7, #16]
 800842a:	681b      	ldr	r3, [r3, #0]
 800842c:	613b      	str	r3, [r7, #16]
 800842e:	693b      	ldr	r3, [r7, #16]
 8008430:	2b00      	cmp	r3, #0
 8008432:	d1cf      	bne.n	80083d4 <inet_chksum_pbuf+0x16>
    }
  }

  if (swapped) {
 8008434:	68fb      	ldr	r3, [r7, #12]
 8008436:	2b00      	cmp	r3, #0
 8008438:	d009      	beq.n	800844e <inet_chksum_pbuf+0x90>
    acc = SWAP_BYTES_IN_WORD(acc);
 800843a:	697b      	ldr	r3, [r7, #20]
 800843c:	021b      	lsls	r3, r3, #8
 800843e:	041b      	lsls	r3, r3, #16
 8008440:	0c1a      	lsrs	r2, r3, #16
 8008442:	697b      	ldr	r3, [r7, #20]
 8008444:	0a1b      	lsrs	r3, r3, #8
 8008446:	21ff      	movs	r1, #255	; 0xff
 8008448:	400b      	ands	r3, r1
 800844a:	4313      	orrs	r3, r2
 800844c:	617b      	str	r3, [r7, #20]
  }
  return (u16_t)~(acc & 0xffffUL);
 800844e:	697b      	ldr	r3, [r7, #20]
 8008450:	b29b      	uxth	r3, r3
 8008452:	43db      	mvns	r3, r3
 8008454:	b29b      	uxth	r3, r3
}
 8008456:	0018      	movs	r0, r3
 8008458:	46bd      	mov	sp, r7
 800845a:	b006      	add	sp, #24
 800845c:	bd80      	pop	{r7, pc}

0800845e <lwip_chksum_copy>:
 * For architectures with big caches, data might still be in cache when
 * generating the checksum after copying.
 */
u16_t
lwip_chksum_copy(void *dst, const void *src, u16_t len)
{
 800845e:	b580      	push	{r7, lr}
 8008460:	b084      	sub	sp, #16
 8008462:	af00      	add	r7, sp, #0
 8008464:	60f8      	str	r0, [r7, #12]
 8008466:	60b9      	str	r1, [r7, #8]
 8008468:	1dbb      	adds	r3, r7, #6
 800846a:	801a      	strh	r2, [r3, #0]
  MEMCPY(dst, src, len);
 800846c:	1dbb      	adds	r3, r7, #6
 800846e:	881a      	ldrh	r2, [r3, #0]
 8008470:	68b9      	ldr	r1, [r7, #8]
 8008472:	68fb      	ldr	r3, [r7, #12]
 8008474:	0018      	movs	r0, r3
 8008476:	f014 fbb3 	bl	801cbe0 <memcpy>
  return LWIP_CHKSUM(dst, len);
 800847a:	1dbb      	adds	r3, r7, #6
 800847c:	881a      	ldrh	r2, [r3, #0]
 800847e:	68fb      	ldr	r3, [r7, #12]
 8008480:	0011      	movs	r1, r2
 8008482:	0018      	movs	r0, r3
 8008484:	f7ff fd22 	bl	8007ecc <lwip_standard_chksum>
 8008488:	0003      	movs	r3, r0
}
 800848a:	0018      	movs	r0, r3
 800848c:	46bd      	mov	sp, r7
 800848e:	b004      	add	sp, #16
 8008490:	bd80      	pop	{r7, pc}
	...

08008494 <ptr_to_mem>:
#define mem_overflow_check_element(mem)
#endif /* MEM_OVERFLOW_CHECK */

static struct mem *
ptr_to_mem(mem_size_t ptr)
{
 8008494:	b580      	push	{r7, lr}
 8008496:	b082      	sub	sp, #8
 8008498:	af00      	add	r7, sp, #0
 800849a:	0002      	movs	r2, r0
 800849c:	1dbb      	adds	r3, r7, #6
 800849e:	801a      	strh	r2, [r3, #0]
  return (struct mem *)(void *)&ram[ptr];
 80084a0:	4b04      	ldr	r3, [pc, #16]	; (80084b4 <ptr_to_mem+0x20>)
 80084a2:	681a      	ldr	r2, [r3, #0]
 80084a4:	1dbb      	adds	r3, r7, #6
 80084a6:	881b      	ldrh	r3, [r3, #0]
 80084a8:	18d3      	adds	r3, r2, r3
}
 80084aa:	0018      	movs	r0, r3
 80084ac:	46bd      	mov	sp, r7
 80084ae:	b002      	add	sp, #8
 80084b0:	bd80      	pop	{r7, pc}
 80084b2:	46c0      	nop			; (mov r8, r8)
 80084b4:	20001b00 	.word	0x20001b00

080084b8 <mem_to_ptr>:

static mem_size_t
mem_to_ptr(void *mem)
{
 80084b8:	b580      	push	{r7, lr}
 80084ba:	b082      	sub	sp, #8
 80084bc:	af00      	add	r7, sp, #0
 80084be:	6078      	str	r0, [r7, #4]
  return (mem_size_t)((u8_t *)mem - ram);
 80084c0:	4b04      	ldr	r3, [pc, #16]	; (80084d4 <mem_to_ptr+0x1c>)
 80084c2:	681b      	ldr	r3, [r3, #0]
 80084c4:	687a      	ldr	r2, [r7, #4]
 80084c6:	1ad3      	subs	r3, r2, r3
 80084c8:	b29b      	uxth	r3, r3
}
 80084ca:	0018      	movs	r0, r3
 80084cc:	46bd      	mov	sp, r7
 80084ce:	b002      	add	sp, #8
 80084d0:	bd80      	pop	{r7, pc}
 80084d2:	46c0      	nop			; (mov r8, r8)
 80084d4:	20001b00 	.word	0x20001b00

080084d8 <plug_holes>:
 * This assumes access to the heap is protected by the calling function
 * already.
 */
static void
plug_holes(struct mem *mem)
{
 80084d8:	b590      	push	{r4, r7, lr}
 80084da:	b085      	sub	sp, #20
 80084dc:	af00      	add	r7, sp, #0
 80084de:	6078      	str	r0, [r7, #4]
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
 80084e0:	4b49      	ldr	r3, [pc, #292]	; (8008608 <plug_holes+0x130>)
 80084e2:	681b      	ldr	r3, [r3, #0]
 80084e4:	687a      	ldr	r2, [r7, #4]
 80084e6:	429a      	cmp	r2, r3
 80084e8:	d206      	bcs.n	80084f8 <plug_holes+0x20>
 80084ea:	4b48      	ldr	r3, [pc, #288]	; (800860c <plug_holes+0x134>)
 80084ec:	22e0      	movs	r2, #224	; 0xe0
 80084ee:	32ff      	adds	r2, #255	; 0xff
 80084f0:	4947      	ldr	r1, [pc, #284]	; (8008610 <plug_holes+0x138>)
 80084f2:	4848      	ldr	r0, [pc, #288]	; (8008614 <plug_holes+0x13c>)
 80084f4:	f7fa f9f2 	bl	80028dc <app_debug_rtt_raw>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
 80084f8:	4b47      	ldr	r3, [pc, #284]	; (8008618 <plug_holes+0x140>)
 80084fa:	681b      	ldr	r3, [r3, #0]
 80084fc:	687a      	ldr	r2, [r7, #4]
 80084fe:	429a      	cmp	r2, r3
 8008500:	d306      	bcc.n	8008510 <plug_holes+0x38>
 8008502:	4b42      	ldr	r3, [pc, #264]	; (800860c <plug_holes+0x134>)
 8008504:	22f0      	movs	r2, #240	; 0xf0
 8008506:	0052      	lsls	r2, r2, #1
 8008508:	4944      	ldr	r1, [pc, #272]	; (800861c <plug_holes+0x144>)
 800850a:	4842      	ldr	r0, [pc, #264]	; (8008614 <plug_holes+0x13c>)
 800850c:	f7fa f9e6 	bl	80028dc <app_debug_rtt_raw>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
 8008510:	687b      	ldr	r3, [r7, #4]
 8008512:	791b      	ldrb	r3, [r3, #4]
 8008514:	2b00      	cmp	r3, #0
 8008516:	d006      	beq.n	8008526 <plug_holes+0x4e>
 8008518:	4b3c      	ldr	r3, [pc, #240]	; (800860c <plug_holes+0x134>)
 800851a:	22e2      	movs	r2, #226	; 0xe2
 800851c:	32ff      	adds	r2, #255	; 0xff
 800851e:	4940      	ldr	r1, [pc, #256]	; (8008620 <plug_holes+0x148>)
 8008520:	483c      	ldr	r0, [pc, #240]	; (8008614 <plug_holes+0x13c>)
 8008522:	f7fa f9db 	bl	80028dc <app_debug_rtt_raw>

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
 8008526:	687b      	ldr	r3, [r7, #4]
 8008528:	881a      	ldrh	r2, [r3, #0]
 800852a:	2380      	movs	r3, #128	; 0x80
 800852c:	00db      	lsls	r3, r3, #3
 800852e:	429a      	cmp	r2, r3
 8008530:	d906      	bls.n	8008540 <plug_holes+0x68>
 8008532:	4b36      	ldr	r3, [pc, #216]	; (800860c <plug_holes+0x134>)
 8008534:	22f2      	movs	r2, #242	; 0xf2
 8008536:	0052      	lsls	r2, r2, #1
 8008538:	493a      	ldr	r1, [pc, #232]	; (8008624 <plug_holes+0x14c>)
 800853a:	4836      	ldr	r0, [pc, #216]	; (8008614 <plug_holes+0x13c>)
 800853c:	f7fa f9ce 	bl	80028dc <app_debug_rtt_raw>

  nmem = ptr_to_mem(mem->next);
 8008540:	687b      	ldr	r3, [r7, #4]
 8008542:	881b      	ldrh	r3, [r3, #0]
 8008544:	0018      	movs	r0, r3
 8008546:	f7ff ffa5 	bl	8008494 <ptr_to_mem>
 800854a:	0003      	movs	r3, r0
 800854c:	60fb      	str	r3, [r7, #12]
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
 800854e:	687a      	ldr	r2, [r7, #4]
 8008550:	68fb      	ldr	r3, [r7, #12]
 8008552:	429a      	cmp	r2, r3
 8008554:	d026      	beq.n	80085a4 <plug_holes+0xcc>
 8008556:	68fb      	ldr	r3, [r7, #12]
 8008558:	791b      	ldrb	r3, [r3, #4]
 800855a:	2b00      	cmp	r3, #0
 800855c:	d122      	bne.n	80085a4 <plug_holes+0xcc>
 800855e:	4b2e      	ldr	r3, [pc, #184]	; (8008618 <plug_holes+0x140>)
 8008560:	681b      	ldr	r3, [r3, #0]
 8008562:	68fa      	ldr	r2, [r7, #12]
 8008564:	429a      	cmp	r2, r3
 8008566:	d01d      	beq.n	80085a4 <plug_holes+0xcc>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
 8008568:	4b2f      	ldr	r3, [pc, #188]	; (8008628 <plug_holes+0x150>)
 800856a:	681b      	ldr	r3, [r3, #0]
 800856c:	68fa      	ldr	r2, [r7, #12]
 800856e:	429a      	cmp	r2, r3
 8008570:	d102      	bne.n	8008578 <plug_holes+0xa0>
      lfree = mem;
 8008572:	4b2d      	ldr	r3, [pc, #180]	; (8008628 <plug_holes+0x150>)
 8008574:	687a      	ldr	r2, [r7, #4]
 8008576:	601a      	str	r2, [r3, #0]
    }
    mem->next = nmem->next;
 8008578:	68fb      	ldr	r3, [r7, #12]
 800857a:	881a      	ldrh	r2, [r3, #0]
 800857c:	687b      	ldr	r3, [r7, #4]
 800857e:	801a      	strh	r2, [r3, #0]
    if (nmem->next != MEM_SIZE_ALIGNED) {
 8008580:	68fb      	ldr	r3, [r7, #12]
 8008582:	881a      	ldrh	r2, [r3, #0]
 8008584:	2380      	movs	r3, #128	; 0x80
 8008586:	00db      	lsls	r3, r3, #3
 8008588:	429a      	cmp	r2, r3
 800858a:	d00b      	beq.n	80085a4 <plug_holes+0xcc>
      ptr_to_mem(nmem->next)->prev = mem_to_ptr(mem);
 800858c:	68fb      	ldr	r3, [r7, #12]
 800858e:	881b      	ldrh	r3, [r3, #0]
 8008590:	0018      	movs	r0, r3
 8008592:	f7ff ff7f 	bl	8008494 <ptr_to_mem>
 8008596:	0004      	movs	r4, r0
 8008598:	687b      	ldr	r3, [r7, #4]
 800859a:	0018      	movs	r0, r3
 800859c:	f7ff ff8c 	bl	80084b8 <mem_to_ptr>
 80085a0:	0003      	movs	r3, r0
 80085a2:	8063      	strh	r3, [r4, #2]
    }
  }

  /* plug hole backward */
  pmem = ptr_to_mem(mem->prev);
 80085a4:	687b      	ldr	r3, [r7, #4]
 80085a6:	885b      	ldrh	r3, [r3, #2]
 80085a8:	0018      	movs	r0, r3
 80085aa:	f7ff ff73 	bl	8008494 <ptr_to_mem>
 80085ae:	0003      	movs	r3, r0
 80085b0:	60bb      	str	r3, [r7, #8]
  if (pmem != mem && pmem->used == 0) {
 80085b2:	68ba      	ldr	r2, [r7, #8]
 80085b4:	687b      	ldr	r3, [r7, #4]
 80085b6:	429a      	cmp	r2, r3
 80085b8:	d021      	beq.n	80085fe <plug_holes+0x126>
 80085ba:	68bb      	ldr	r3, [r7, #8]
 80085bc:	791b      	ldrb	r3, [r3, #4]
 80085be:	2b00      	cmp	r3, #0
 80085c0:	d11d      	bne.n	80085fe <plug_holes+0x126>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
 80085c2:	4b19      	ldr	r3, [pc, #100]	; (8008628 <plug_holes+0x150>)
 80085c4:	681b      	ldr	r3, [r3, #0]
 80085c6:	687a      	ldr	r2, [r7, #4]
 80085c8:	429a      	cmp	r2, r3
 80085ca:	d102      	bne.n	80085d2 <plug_holes+0xfa>
      lfree = pmem;
 80085cc:	4b16      	ldr	r3, [pc, #88]	; (8008628 <plug_holes+0x150>)
 80085ce:	68ba      	ldr	r2, [r7, #8]
 80085d0:	601a      	str	r2, [r3, #0]
    }
    pmem->next = mem->next;
 80085d2:	687b      	ldr	r3, [r7, #4]
 80085d4:	881a      	ldrh	r2, [r3, #0]
 80085d6:	68bb      	ldr	r3, [r7, #8]
 80085d8:	801a      	strh	r2, [r3, #0]
    if (mem->next != MEM_SIZE_ALIGNED) {
 80085da:	687b      	ldr	r3, [r7, #4]
 80085dc:	881a      	ldrh	r2, [r3, #0]
 80085de:	2380      	movs	r3, #128	; 0x80
 80085e0:	00db      	lsls	r3, r3, #3
 80085e2:	429a      	cmp	r2, r3
 80085e4:	d00b      	beq.n	80085fe <plug_holes+0x126>
      ptr_to_mem(mem->next)->prev = mem_to_ptr(pmem);
 80085e6:	687b      	ldr	r3, [r7, #4]
 80085e8:	881b      	ldrh	r3, [r3, #0]
 80085ea:	0018      	movs	r0, r3
 80085ec:	f7ff ff52 	bl	8008494 <ptr_to_mem>
 80085f0:	0004      	movs	r4, r0
 80085f2:	68bb      	ldr	r3, [r7, #8]
 80085f4:	0018      	movs	r0, r3
 80085f6:	f7ff ff5f 	bl	80084b8 <mem_to_ptr>
 80085fa:	0003      	movs	r3, r0
 80085fc:	8063      	strh	r3, [r4, #2]
    }
  }
}
 80085fe:	46c0      	nop			; (mov r8, r8)
 8008600:	46bd      	mov	sp, r7
 8008602:	b005      	add	sp, #20
 8008604:	bd90      	pop	{r4, r7, pc}
 8008606:	46c0      	nop			; (mov r8, r8)
 8008608:	20001b00 	.word	0x20001b00
 800860c:	0801ef30 	.word	0x0801ef30
 8008610:	0801ef58 	.word	0x0801ef58
 8008614:	0801ef70 	.word	0x0801ef70
 8008618:	20001b04 	.word	0x20001b04
 800861c:	0801ef9c 	.word	0x0801ef9c
 8008620:	0801efb8 	.word	0x0801efb8
 8008624:	0801efd4 	.word	0x0801efd4
 8008628:	20001b08 	.word	0x20001b08

0800862c <mem_link_valid>:
/* Check if a struct mem is correctly linked.
 * If not, double-free is a possible reason.
 */
static int
mem_link_valid(struct mem *mem)
{
 800862c:	b5b0      	push	{r4, r5, r7, lr}
 800862e:	b086      	sub	sp, #24
 8008630:	af00      	add	r7, sp, #0
 8008632:	6078      	str	r0, [r7, #4]
  struct mem *nmem, *pmem;
  mem_size_t rmem_idx;
  rmem_idx = mem_to_ptr(mem);
 8008634:	2516      	movs	r5, #22
 8008636:	197c      	adds	r4, r7, r5
 8008638:	687b      	ldr	r3, [r7, #4]
 800863a:	0018      	movs	r0, r3
 800863c:	f7ff ff3c 	bl	80084b8 <mem_to_ptr>
 8008640:	0003      	movs	r3, r0
 8008642:	8023      	strh	r3, [r4, #0]
  nmem = ptr_to_mem(mem->next);
 8008644:	687b      	ldr	r3, [r7, #4]
 8008646:	881b      	ldrh	r3, [r3, #0]
 8008648:	0018      	movs	r0, r3
 800864a:	f7ff ff23 	bl	8008494 <ptr_to_mem>
 800864e:	0003      	movs	r3, r0
 8008650:	613b      	str	r3, [r7, #16]
  pmem = ptr_to_mem(mem->prev);
 8008652:	687b      	ldr	r3, [r7, #4]
 8008654:	885b      	ldrh	r3, [r3, #2]
 8008656:	0018      	movs	r0, r3
 8008658:	f7ff ff1c 	bl	8008494 <ptr_to_mem>
 800865c:	0003      	movs	r3, r0
 800865e:	60fb      	str	r3, [r7, #12]
  if ((mem->next > MEM_SIZE_ALIGNED) || (mem->prev > MEM_SIZE_ALIGNED) ||
 8008660:	687b      	ldr	r3, [r7, #4]
 8008662:	881a      	ldrh	r2, [r3, #0]
 8008664:	2380      	movs	r3, #128	; 0x80
 8008666:	00db      	lsls	r3, r3, #3
 8008668:	429a      	cmp	r2, r3
 800866a:	d81d      	bhi.n	80086a8 <mem_link_valid+0x7c>
 800866c:	687b      	ldr	r3, [r7, #4]
 800866e:	885a      	ldrh	r2, [r3, #2]
 8008670:	2380      	movs	r3, #128	; 0x80
 8008672:	00db      	lsls	r3, r3, #3
 8008674:	429a      	cmp	r2, r3
 8008676:	d817      	bhi.n	80086a8 <mem_link_valid+0x7c>
      ((mem->prev != rmem_idx) && (pmem->next != rmem_idx)) ||
 8008678:	687b      	ldr	r3, [r7, #4]
 800867a:	885b      	ldrh	r3, [r3, #2]
  if ((mem->next > MEM_SIZE_ALIGNED) || (mem->prev > MEM_SIZE_ALIGNED) ||
 800867c:	197a      	adds	r2, r7, r5
 800867e:	8812      	ldrh	r2, [r2, #0]
 8008680:	429a      	cmp	r2, r3
 8008682:	d005      	beq.n	8008690 <mem_link_valid+0x64>
      ((mem->prev != rmem_idx) && (pmem->next != rmem_idx)) ||
 8008684:	68fb      	ldr	r3, [r7, #12]
 8008686:	881b      	ldrh	r3, [r3, #0]
 8008688:	197a      	adds	r2, r7, r5
 800868a:	8812      	ldrh	r2, [r2, #0]
 800868c:	429a      	cmp	r2, r3
 800868e:	d10b      	bne.n	80086a8 <mem_link_valid+0x7c>
      ((nmem != ram_end) && (nmem->prev != rmem_idx))) {
 8008690:	4b09      	ldr	r3, [pc, #36]	; (80086b8 <mem_link_valid+0x8c>)
 8008692:	681b      	ldr	r3, [r3, #0]
      ((mem->prev != rmem_idx) && (pmem->next != rmem_idx)) ||
 8008694:	693a      	ldr	r2, [r7, #16]
 8008696:	429a      	cmp	r2, r3
 8008698:	d008      	beq.n	80086ac <mem_link_valid+0x80>
      ((nmem != ram_end) && (nmem->prev != rmem_idx))) {
 800869a:	693b      	ldr	r3, [r7, #16]
 800869c:	885b      	ldrh	r3, [r3, #2]
 800869e:	2216      	movs	r2, #22
 80086a0:	18ba      	adds	r2, r7, r2
 80086a2:	8812      	ldrh	r2, [r2, #0]
 80086a4:	429a      	cmp	r2, r3
 80086a6:	d001      	beq.n	80086ac <mem_link_valid+0x80>
    return 0;
 80086a8:	2300      	movs	r3, #0
 80086aa:	e000      	b.n	80086ae <mem_link_valid+0x82>
  }
  return 1;
 80086ac:	2301      	movs	r3, #1
}
 80086ae:	0018      	movs	r0, r3
 80086b0:	46bd      	mov	sp, r7
 80086b2:	b006      	add	sp, #24
 80086b4:	bdb0      	pop	{r4, r5, r7, pc}
 80086b6:	46c0      	nop			; (mov r8, r8)
 80086b8:	20001b04 	.word	0x20001b04

080086bc <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
 80086bc:	b580      	push	{r7, lr}
 80086be:	b084      	sub	sp, #16
 80086c0:	af00      	add	r7, sp, #0
 80086c2:	6078      	str	r0, [r7, #4]
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
 80086c4:	687b      	ldr	r3, [r7, #4]
 80086c6:	2b00      	cmp	r3, #0
 80086c8:	d049      	beq.n	800875e <mem_free+0xa2>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  if ((((mem_ptr_t)rmem) & (MEM_ALIGNMENT - 1)) != 0) {
 80086ca:	687b      	ldr	r3, [r7, #4]
 80086cc:	2203      	movs	r2, #3
 80086ce:	4013      	ands	r3, r2
 80086d0:	d006      	beq.n	80086e0 <mem_free+0x24>
    LWIP_MEM_ILLEGAL_FREE("mem_free: sanity check alignment");
 80086d2:	4b25      	ldr	r3, [pc, #148]	; (8008768 <mem_free+0xac>)
 80086d4:	4a25      	ldr	r2, [pc, #148]	; (800876c <mem_free+0xb0>)
 80086d6:	4926      	ldr	r1, [pc, #152]	; (8008770 <mem_free+0xb4>)
 80086d8:	4826      	ldr	r0, [pc, #152]	; (8008774 <mem_free+0xb8>)
 80086da:	f7fa f8ff 	bl	80028dc <app_debug_rtt_raw>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: sanity check alignment\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
    return;
 80086de:	e03f      	b.n	8008760 <mem_free+0xa4>
  }

  /* Get the corresponding struct mem: */
  /* cast through void* to get rid of alignment warnings */
  mem = (struct mem *)(void *)((u8_t *)rmem - (SIZEOF_STRUCT_MEM + MEM_SANITY_OFFSET));
 80086e0:	687b      	ldr	r3, [r7, #4]
 80086e2:	3b08      	subs	r3, #8
 80086e4:	60fb      	str	r3, [r7, #12]

  if ((u8_t *)mem < ram || (u8_t *)rmem + MIN_SIZE_ALIGNED > (u8_t *)ram_end) {
 80086e6:	4b24      	ldr	r3, [pc, #144]	; (8008778 <mem_free+0xbc>)
 80086e8:	681b      	ldr	r3, [r3, #0]
 80086ea:	68fa      	ldr	r2, [r7, #12]
 80086ec:	429a      	cmp	r2, r3
 80086ee:	d306      	bcc.n	80086fe <mem_free+0x42>
 80086f0:	687b      	ldr	r3, [r7, #4]
 80086f2:	330c      	adds	r3, #12
 80086f4:	001a      	movs	r2, r3
 80086f6:	4b21      	ldr	r3, [pc, #132]	; (800877c <mem_free+0xc0>)
 80086f8:	681b      	ldr	r3, [r3, #0]
 80086fa:	429a      	cmp	r2, r3
 80086fc:	d906      	bls.n	800870c <mem_free+0x50>
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory");
 80086fe:	4b1a      	ldr	r3, [pc, #104]	; (8008768 <mem_free+0xac>)
 8008700:	4a1f      	ldr	r2, [pc, #124]	; (8008780 <mem_free+0xc4>)
 8008702:	4920      	ldr	r1, [pc, #128]	; (8008784 <mem_free+0xc8>)
 8008704:	481b      	ldr	r0, [pc, #108]	; (8008774 <mem_free+0xb8>)
 8008706:	f7fa f8e9 	bl	80028dc <app_debug_rtt_raw>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
    return;
 800870a:	e029      	b.n	8008760 <mem_free+0xa4>
  mem_overflow_check_element(mem);
#endif
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* mem has to be in a used state */
  if (!mem->used) {
 800870c:	68fb      	ldr	r3, [r7, #12]
 800870e:	791b      	ldrb	r3, [r3, #4]
 8008710:	2b00      	cmp	r3, #0
 8008712:	d107      	bne.n	8008724 <mem_free+0x68>
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory: double free");
 8008714:	4b14      	ldr	r3, [pc, #80]	; (8008768 <mem_free+0xac>)
 8008716:	22a3      	movs	r2, #163	; 0xa3
 8008718:	0092      	lsls	r2, r2, #2
 800871a:	491b      	ldr	r1, [pc, #108]	; (8008788 <mem_free+0xcc>)
 800871c:	4815      	ldr	r0, [pc, #84]	; (8008774 <mem_free+0xb8>)
 800871e:	f7fa f8dd 	bl	80028dc <app_debug_rtt_raw>
    LWIP_MEM_FREE_UNPROTECT();
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory: double free?\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
    return;
 8008722:	e01d      	b.n	8008760 <mem_free+0xa4>
  }

  if (!mem_link_valid(mem)) {
 8008724:	68fb      	ldr	r3, [r7, #12]
 8008726:	0018      	movs	r0, r3
 8008728:	f7ff ff80 	bl	800862c <mem_link_valid>
 800872c:	1e03      	subs	r3, r0, #0
 800872e:	d106      	bne.n	800873e <mem_free+0x82>
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory: non-linked: double free");
 8008730:	4b0d      	ldr	r3, [pc, #52]	; (8008768 <mem_free+0xac>)
 8008732:	4a16      	ldr	r2, [pc, #88]	; (800878c <mem_free+0xd0>)
 8008734:	4916      	ldr	r1, [pc, #88]	; (8008790 <mem_free+0xd4>)
 8008736:	480f      	ldr	r0, [pc, #60]	; (8008774 <mem_free+0xb8>)
 8008738:	f7fa f8d0 	bl	80028dc <app_debug_rtt_raw>
    LWIP_MEM_FREE_UNPROTECT();
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory: non-linked: double free?\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
    return;
 800873c:	e010      	b.n	8008760 <mem_free+0xa4>
  }

  /* mem is now unused. */
  mem->used = 0;
 800873e:	68fb      	ldr	r3, [r7, #12]
 8008740:	2200      	movs	r2, #0
 8008742:	711a      	strb	r2, [r3, #4]

  if (mem < lfree) {
 8008744:	4b13      	ldr	r3, [pc, #76]	; (8008794 <mem_free+0xd8>)
 8008746:	681b      	ldr	r3, [r3, #0]
 8008748:	68fa      	ldr	r2, [r7, #12]
 800874a:	429a      	cmp	r2, r3
 800874c:	d202      	bcs.n	8008754 <mem_free+0x98>
    /* the newly freed struct is now the lowest */
    lfree = mem;
 800874e:	4b11      	ldr	r3, [pc, #68]	; (8008794 <mem_free+0xd8>)
 8008750:	68fa      	ldr	r2, [r7, #12]
 8008752:	601a      	str	r2, [r3, #0]
  }

  MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));

  /* finally, see if prev or next are free also */
  plug_holes(mem);
 8008754:	68fb      	ldr	r3, [r7, #12]
 8008756:	0018      	movs	r0, r3
 8008758:	f7ff febe 	bl	80084d8 <plug_holes>
 800875c:	e000      	b.n	8008760 <mem_free+0xa4>
    return;
 800875e:	46c0      	nop			; (mov r8, r8)
  MEM_SANITY();
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
 8008760:	46bd      	mov	sp, r7
 8008762:	b004      	add	sp, #16
 8008764:	bd80      	pop	{r7, pc}
 8008766:	46c0      	nop			; (mov r8, r8)
 8008768:	0801ef30 	.word	0x0801ef30
 800876c:	00000273 	.word	0x00000273
 8008770:	0801f000 	.word	0x0801f000
 8008774:	0801ef70 	.word	0x0801ef70
 8008778:	20001b00 	.word	0x20001b00
 800877c:	20001b04 	.word	0x20001b04
 8008780:	0000027f 	.word	0x0000027f
 8008784:	0801f024 	.word	0x0801f024
 8008788:	0801f040 	.word	0x0801f040
 800878c:	00000295 	.word	0x00000295
 8008790:	0801f068 	.word	0x0801f068
 8008794:	20001b08 	.word	0x20001b08

08008798 <mem_trim>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_trim(void *rmem, mem_size_t new_size)
{
 8008798:	b5b0      	push	{r4, r5, r7, lr}
 800879a:	b088      	sub	sp, #32
 800879c:	af00      	add	r7, sp, #0
 800879e:	6078      	str	r0, [r7, #4]
 80087a0:	000a      	movs	r2, r1
 80087a2:	1cbb      	adds	r3, r7, #2
 80087a4:	801a      	strh	r2, [r3, #0]
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = (mem_size_t)LWIP_MEM_ALIGN_SIZE(new_size);
 80087a6:	1cbb      	adds	r3, r7, #2
 80087a8:	881b      	ldrh	r3, [r3, #0]
 80087aa:	3303      	adds	r3, #3
 80087ac:	b29a      	uxth	r2, r3
 80087ae:	201e      	movs	r0, #30
 80087b0:	183b      	adds	r3, r7, r0
 80087b2:	2103      	movs	r1, #3
 80087b4:	438a      	bics	r2, r1
 80087b6:	801a      	strh	r2, [r3, #0]
  if (newsize < MIN_SIZE_ALIGNED) {
 80087b8:	183b      	adds	r3, r7, r0
 80087ba:	881b      	ldrh	r3, [r3, #0]
 80087bc:	2b0b      	cmp	r3, #11
 80087be:	d802      	bhi.n	80087c6 <mem_trim+0x2e>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
 80087c0:	183b      	adds	r3, r7, r0
 80087c2:	220c      	movs	r2, #12
 80087c4:	801a      	strh	r2, [r3, #0]
  }
#if MEM_OVERFLOW_CHECK
  newsize += MEM_SANITY_REGION_BEFORE_ALIGNED + MEM_SANITY_REGION_AFTER_ALIGNED;
#endif
  if ((newsize > MEM_SIZE_ALIGNED) || (newsize < new_size)) {
 80087c6:	211e      	movs	r1, #30
 80087c8:	187b      	adds	r3, r7, r1
 80087ca:	881a      	ldrh	r2, [r3, #0]
 80087cc:	2380      	movs	r3, #128	; 0x80
 80087ce:	00db      	lsls	r3, r3, #3
 80087d0:	429a      	cmp	r2, r3
 80087d2:	d805      	bhi.n	80087e0 <mem_trim+0x48>
 80087d4:	187a      	adds	r2, r7, r1
 80087d6:	1cbb      	adds	r3, r7, #2
 80087d8:	8812      	ldrh	r2, [r2, #0]
 80087da:	881b      	ldrh	r3, [r3, #0]
 80087dc:	429a      	cmp	r2, r3
 80087de:	d201      	bcs.n	80087e4 <mem_trim+0x4c>
    return NULL;
 80087e0:	2300      	movs	r3, #0
 80087e2:	e102      	b.n	80089ea <mem_trim+0x252>
  }

  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 80087e4:	4b83      	ldr	r3, [pc, #524]	; (80089f4 <mem_trim+0x25c>)
 80087e6:	681b      	ldr	r3, [r3, #0]
 80087e8:	687a      	ldr	r2, [r7, #4]
 80087ea:	429a      	cmp	r2, r3
 80087ec:	d304      	bcc.n	80087f8 <mem_trim+0x60>
 80087ee:	4b82      	ldr	r3, [pc, #520]	; (80089f8 <mem_trim+0x260>)
 80087f0:	681b      	ldr	r3, [r3, #0]
 80087f2:	687a      	ldr	r2, [r7, #4]
 80087f4:	429a      	cmp	r2, r3
 80087f6:	d305      	bcc.n	8008804 <mem_trim+0x6c>
 80087f8:	4b80      	ldr	r3, [pc, #512]	; (80089fc <mem_trim+0x264>)
 80087fa:	4a81      	ldr	r2, [pc, #516]	; (8008a00 <mem_trim+0x268>)
 80087fc:	4981      	ldr	r1, [pc, #516]	; (8008a04 <mem_trim+0x26c>)
 80087fe:	4882      	ldr	r0, [pc, #520]	; (8008a08 <mem_trim+0x270>)
 8008800:	f7fa f86c 	bl	80028dc <app_debug_rtt_raw>
              (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 8008804:	4b7b      	ldr	r3, [pc, #492]	; (80089f4 <mem_trim+0x25c>)
 8008806:	681b      	ldr	r3, [r3, #0]
 8008808:	687a      	ldr	r2, [r7, #4]
 800880a:	429a      	cmp	r2, r3
 800880c:	d304      	bcc.n	8008818 <mem_trim+0x80>
 800880e:	4b7a      	ldr	r3, [pc, #488]	; (80089f8 <mem_trim+0x260>)
 8008810:	681b      	ldr	r3, [r3, #0]
 8008812:	687a      	ldr	r2, [r7, #4]
 8008814:	429a      	cmp	r2, r3
 8008816:	d301      	bcc.n	800881c <mem_trim+0x84>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_trim: illegal memory\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
    return rmem;
 8008818:	687b      	ldr	r3, [r7, #4]
 800881a:	e0e6      	b.n	80089ea <mem_trim+0x252>
  }
  /* Get the corresponding struct mem ... */
  /* cast through void* to get rid of alignment warnings */
  mem = (struct mem *)(void *)((u8_t *)rmem - (SIZEOF_STRUCT_MEM + MEM_SANITY_OFFSET));
 800881c:	687b      	ldr	r3, [r7, #4]
 800881e:	3b08      	subs	r3, #8
 8008820:	61bb      	str	r3, [r7, #24]
#if MEM_OVERFLOW_CHECK
  mem_overflow_check_element(mem);
#endif
  /* ... and its offset pointer */
  ptr = mem_to_ptr(mem);
 8008822:	2516      	movs	r5, #22
 8008824:	197c      	adds	r4, r7, r5
 8008826:	69bb      	ldr	r3, [r7, #24]
 8008828:	0018      	movs	r0, r3
 800882a:	f7ff fe45 	bl	80084b8 <mem_to_ptr>
 800882e:	0003      	movs	r3, r0
 8008830:	8023      	strh	r3, [r4, #0]

  size = (mem_size_t)((mem_size_t)(mem->next - ptr) - (SIZEOF_STRUCT_MEM + MEM_SANITY_OVERHEAD));
 8008832:	69bb      	ldr	r3, [r7, #24]
 8008834:	881a      	ldrh	r2, [r3, #0]
 8008836:	197b      	adds	r3, r7, r5
 8008838:	881b      	ldrh	r3, [r3, #0]
 800883a:	1ad3      	subs	r3, r2, r3
 800883c:	b29a      	uxth	r2, r3
 800883e:	2114      	movs	r1, #20
 8008840:	187b      	adds	r3, r7, r1
 8008842:	3a08      	subs	r2, #8
 8008844:	801a      	strh	r2, [r3, #0]
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
 8008846:	231e      	movs	r3, #30
 8008848:	18fa      	adds	r2, r7, r3
 800884a:	187b      	adds	r3, r7, r1
 800884c:	8812      	ldrh	r2, [r2, #0]
 800884e:	881b      	ldrh	r3, [r3, #0]
 8008850:	429a      	cmp	r2, r3
 8008852:	d906      	bls.n	8008862 <mem_trim+0xca>
 8008854:	4b69      	ldr	r3, [pc, #420]	; (80089fc <mem_trim+0x264>)
 8008856:	22b9      	movs	r2, #185	; 0xb9
 8008858:	0092      	lsls	r2, r2, #2
 800885a:	496c      	ldr	r1, [pc, #432]	; (8008a0c <mem_trim+0x274>)
 800885c:	486a      	ldr	r0, [pc, #424]	; (8008a08 <mem_trim+0x270>)
 800885e:	f7fa f83d 	bl	80028dc <app_debug_rtt_raw>
  if (newsize > size) {
 8008862:	231e      	movs	r3, #30
 8008864:	18fa      	adds	r2, r7, r3
 8008866:	2314      	movs	r3, #20
 8008868:	18fb      	adds	r3, r7, r3
 800886a:	8812      	ldrh	r2, [r2, #0]
 800886c:	881b      	ldrh	r3, [r3, #0]
 800886e:	429a      	cmp	r2, r3
 8008870:	d901      	bls.n	8008876 <mem_trim+0xde>
    /* not supported */
    return NULL;
 8008872:	2300      	movs	r3, #0
 8008874:	e0b9      	b.n	80089ea <mem_trim+0x252>
  }
  if (newsize == size) {
 8008876:	231e      	movs	r3, #30
 8008878:	18fa      	adds	r2, r7, r3
 800887a:	2314      	movs	r3, #20
 800887c:	18fb      	adds	r3, r7, r3
 800887e:	8812      	ldrh	r2, [r2, #0]
 8008880:	881b      	ldrh	r3, [r3, #0]
 8008882:	429a      	cmp	r2, r3
 8008884:	d101      	bne.n	800888a <mem_trim+0xf2>
    /* No change in size, simply return */
    return rmem;
 8008886:	687b      	ldr	r3, [r7, #4]
 8008888:	e0af      	b.n	80089ea <mem_trim+0x252>
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();

  mem2 = ptr_to_mem(mem->next);
 800888a:	69bb      	ldr	r3, [r7, #24]
 800888c:	881b      	ldrh	r3, [r3, #0]
 800888e:	0018      	movs	r0, r3
 8008890:	f7ff fe00 	bl	8008494 <ptr_to_mem>
 8008894:	0003      	movs	r3, r0
 8008896:	613b      	str	r3, [r7, #16]
  if (mem2->used == 0) {
 8008898:	693b      	ldr	r3, [r7, #16]
 800889a:	791b      	ldrb	r3, [r3, #4]
 800889c:	2b00      	cmp	r3, #0
 800889e:	d152      	bne.n	8008946 <mem_trim+0x1ae>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    LWIP_ASSERT("invalid next ptr", mem->next != MEM_SIZE_ALIGNED);
 80088a0:	69bb      	ldr	r3, [r7, #24]
 80088a2:	881a      	ldrh	r2, [r3, #0]
 80088a4:	2380      	movs	r3, #128	; 0x80
 80088a6:	00db      	lsls	r3, r3, #3
 80088a8:	429a      	cmp	r2, r3
 80088aa:	d105      	bne.n	80088b8 <mem_trim+0x120>
 80088ac:	4b53      	ldr	r3, [pc, #332]	; (80089fc <mem_trim+0x264>)
 80088ae:	4a58      	ldr	r2, [pc, #352]	; (8008a10 <mem_trim+0x278>)
 80088b0:	4958      	ldr	r1, [pc, #352]	; (8008a14 <mem_trim+0x27c>)
 80088b2:	4855      	ldr	r0, [pc, #340]	; (8008a08 <mem_trim+0x270>)
 80088b4:	f7fa f812 	bl	80028dc <app_debug_rtt_raw>
    /* remember the old next pointer */
    next = mem2->next;
 80088b8:	230c      	movs	r3, #12
 80088ba:	18fb      	adds	r3, r7, r3
 80088bc:	693a      	ldr	r2, [r7, #16]
 80088be:	8812      	ldrh	r2, [r2, #0]
 80088c0:	801a      	strh	r2, [r3, #0]
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + newsize);
 80088c2:	2316      	movs	r3, #22
 80088c4:	18fa      	adds	r2, r7, r3
 80088c6:	231e      	movs	r3, #30
 80088c8:	18fb      	adds	r3, r7, r3
 80088ca:	8812      	ldrh	r2, [r2, #0]
 80088cc:	881b      	ldrh	r3, [r3, #0]
 80088ce:	18d3      	adds	r3, r2, r3
 80088d0:	b29a      	uxth	r2, r3
 80088d2:	210e      	movs	r1, #14
 80088d4:	187b      	adds	r3, r7, r1
 80088d6:	3208      	adds	r2, #8
 80088d8:	801a      	strh	r2, [r3, #0]
    if (lfree == mem2) {
 80088da:	4b4f      	ldr	r3, [pc, #316]	; (8008a18 <mem_trim+0x280>)
 80088dc:	681b      	ldr	r3, [r3, #0]
 80088de:	693a      	ldr	r2, [r7, #16]
 80088e0:	429a      	cmp	r2, r3
 80088e2:	d107      	bne.n	80088f4 <mem_trim+0x15c>
      lfree = ptr_to_mem(ptr2);
 80088e4:	187b      	adds	r3, r7, r1
 80088e6:	881b      	ldrh	r3, [r3, #0]
 80088e8:	0018      	movs	r0, r3
 80088ea:	f7ff fdd3 	bl	8008494 <ptr_to_mem>
 80088ee:	0002      	movs	r2, r0
 80088f0:	4b49      	ldr	r3, [pc, #292]	; (8008a18 <mem_trim+0x280>)
 80088f2:	601a      	str	r2, [r3, #0]
    }
    mem2 = ptr_to_mem(ptr2);
 80088f4:	240e      	movs	r4, #14
 80088f6:	193b      	adds	r3, r7, r4
 80088f8:	881b      	ldrh	r3, [r3, #0]
 80088fa:	0018      	movs	r0, r3
 80088fc:	f7ff fdca 	bl	8008494 <ptr_to_mem>
 8008900:	0003      	movs	r3, r0
 8008902:	613b      	str	r3, [r7, #16]
    mem2->used = 0;
 8008904:	693b      	ldr	r3, [r7, #16]
 8008906:	2200      	movs	r2, #0
 8008908:	711a      	strb	r2, [r3, #4]
    /* restore the next pointer */
    mem2->next = next;
 800890a:	693b      	ldr	r3, [r7, #16]
 800890c:	220c      	movs	r2, #12
 800890e:	18ba      	adds	r2, r7, r2
 8008910:	8812      	ldrh	r2, [r2, #0]
 8008912:	801a      	strh	r2, [r3, #0]
    /* link it back to mem */
    mem2->prev = ptr;
 8008914:	693b      	ldr	r3, [r7, #16]
 8008916:	2216      	movs	r2, #22
 8008918:	18ba      	adds	r2, r7, r2
 800891a:	8812      	ldrh	r2, [r2, #0]
 800891c:	805a      	strh	r2, [r3, #2]
    /* link mem to it */
    mem->next = ptr2;
 800891e:	69bb      	ldr	r3, [r7, #24]
 8008920:	193a      	adds	r2, r7, r4
 8008922:	8812      	ldrh	r2, [r2, #0]
 8008924:	801a      	strh	r2, [r3, #0]
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
 8008926:	693b      	ldr	r3, [r7, #16]
 8008928:	881a      	ldrh	r2, [r3, #0]
 800892a:	2380      	movs	r3, #128	; 0x80
 800892c:	00db      	lsls	r3, r3, #3
 800892e:	429a      	cmp	r2, r3
 8008930:	d05a      	beq.n	80089e8 <mem_trim+0x250>
      ptr_to_mem(mem2->next)->prev = ptr2;
 8008932:	693b      	ldr	r3, [r7, #16]
 8008934:	881b      	ldrh	r3, [r3, #0]
 8008936:	0018      	movs	r0, r3
 8008938:	f7ff fdac 	bl	8008494 <ptr_to_mem>
 800893c:	0002      	movs	r2, r0
 800893e:	193b      	adds	r3, r7, r4
 8008940:	881b      	ldrh	r3, [r3, #0]
 8008942:	8053      	strh	r3, [r2, #2]
 8008944:	e050      	b.n	80089e8 <mem_trim+0x250>
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
 8008946:	211e      	movs	r1, #30
 8008948:	187b      	adds	r3, r7, r1
 800894a:	881b      	ldrh	r3, [r3, #0]
 800894c:	3314      	adds	r3, #20
 800894e:	001a      	movs	r2, r3
 8008950:	2314      	movs	r3, #20
 8008952:	18fb      	adds	r3, r7, r3
 8008954:	881b      	ldrh	r3, [r3, #0]
 8008956:	429a      	cmp	r2, r3
 8008958:	d846      	bhi.n	80089e8 <mem_trim+0x250>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + newsize);
 800895a:	2316      	movs	r3, #22
 800895c:	18fa      	adds	r2, r7, r3
 800895e:	187b      	adds	r3, r7, r1
 8008960:	8812      	ldrh	r2, [r2, #0]
 8008962:	881b      	ldrh	r3, [r3, #0]
 8008964:	18d3      	adds	r3, r2, r3
 8008966:	b29a      	uxth	r2, r3
 8008968:	230e      	movs	r3, #14
 800896a:	18fb      	adds	r3, r7, r3
 800896c:	3208      	adds	r2, #8
 800896e:	801a      	strh	r2, [r3, #0]
    LWIP_ASSERT("invalid next ptr", mem->next != MEM_SIZE_ALIGNED);
 8008970:	69bb      	ldr	r3, [r7, #24]
 8008972:	881a      	ldrh	r2, [r3, #0]
 8008974:	2380      	movs	r3, #128	; 0x80
 8008976:	00db      	lsls	r3, r3, #3
 8008978:	429a      	cmp	r2, r3
 800897a:	d105      	bne.n	8008988 <mem_trim+0x1f0>
 800897c:	4b1f      	ldr	r3, [pc, #124]	; (80089fc <mem_trim+0x264>)
 800897e:	4a27      	ldr	r2, [pc, #156]	; (8008a1c <mem_trim+0x284>)
 8008980:	4924      	ldr	r1, [pc, #144]	; (8008a14 <mem_trim+0x27c>)
 8008982:	4821      	ldr	r0, [pc, #132]	; (8008a08 <mem_trim+0x270>)
 8008984:	f7f9 ffaa 	bl	80028dc <app_debug_rtt_raw>
    mem2 = ptr_to_mem(ptr2);
 8008988:	230e      	movs	r3, #14
 800898a:	18fb      	adds	r3, r7, r3
 800898c:	881b      	ldrh	r3, [r3, #0]
 800898e:	0018      	movs	r0, r3
 8008990:	f7ff fd80 	bl	8008494 <ptr_to_mem>
 8008994:	0003      	movs	r3, r0
 8008996:	613b      	str	r3, [r7, #16]
    if (mem2 < lfree) {
 8008998:	4b1f      	ldr	r3, [pc, #124]	; (8008a18 <mem_trim+0x280>)
 800899a:	681b      	ldr	r3, [r3, #0]
 800899c:	693a      	ldr	r2, [r7, #16]
 800899e:	429a      	cmp	r2, r3
 80089a0:	d202      	bcs.n	80089a8 <mem_trim+0x210>
      lfree = mem2;
 80089a2:	4b1d      	ldr	r3, [pc, #116]	; (8008a18 <mem_trim+0x280>)
 80089a4:	693a      	ldr	r2, [r7, #16]
 80089a6:	601a      	str	r2, [r3, #0]
    }
    mem2->used = 0;
 80089a8:	693b      	ldr	r3, [r7, #16]
 80089aa:	2200      	movs	r2, #0
 80089ac:	711a      	strb	r2, [r3, #4]
    mem2->next = mem->next;
 80089ae:	69bb      	ldr	r3, [r7, #24]
 80089b0:	881a      	ldrh	r2, [r3, #0]
 80089b2:	693b      	ldr	r3, [r7, #16]
 80089b4:	801a      	strh	r2, [r3, #0]
    mem2->prev = ptr;
 80089b6:	693b      	ldr	r3, [r7, #16]
 80089b8:	2216      	movs	r2, #22
 80089ba:	18ba      	adds	r2, r7, r2
 80089bc:	8812      	ldrh	r2, [r2, #0]
 80089be:	805a      	strh	r2, [r3, #2]
    mem->next = ptr2;
 80089c0:	69bb      	ldr	r3, [r7, #24]
 80089c2:	240e      	movs	r4, #14
 80089c4:	193a      	adds	r2, r7, r4
 80089c6:	8812      	ldrh	r2, [r2, #0]
 80089c8:	801a      	strh	r2, [r3, #0]
    if (mem2->next != MEM_SIZE_ALIGNED) {
 80089ca:	693b      	ldr	r3, [r7, #16]
 80089cc:	881a      	ldrh	r2, [r3, #0]
 80089ce:	2380      	movs	r3, #128	; 0x80
 80089d0:	00db      	lsls	r3, r3, #3
 80089d2:	429a      	cmp	r2, r3
 80089d4:	d008      	beq.n	80089e8 <mem_trim+0x250>
      ptr_to_mem(mem2->next)->prev = ptr2;
 80089d6:	693b      	ldr	r3, [r7, #16]
 80089d8:	881b      	ldrh	r3, [r3, #0]
 80089da:	0018      	movs	r0, r3
 80089dc:	f7ff fd5a 	bl	8008494 <ptr_to_mem>
 80089e0:	0002      	movs	r2, r0
 80089e2:	193b      	adds	r3, r7, r4
 80089e4:	881b      	ldrh	r3, [r3, #0]
 80089e6:	8053      	strh	r3, [r2, #2]
  MEM_SANITY();
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
 80089e8:	687b      	ldr	r3, [r7, #4]
}
 80089ea:	0018      	movs	r0, r3
 80089ec:	46bd      	mov	sp, r7
 80089ee:	b008      	add	sp, #32
 80089f0:	bdb0      	pop	{r4, r5, r7, pc}
 80089f2:	46c0      	nop			; (mov r8, r8)
 80089f4:	20001b00 	.word	0x20001b00
 80089f8:	20001b04 	.word	0x20001b04
 80089fc:	0801ef30 	.word	0x0801ef30
 8008a00:	000002d1 	.word	0x000002d1
 8008a04:	0801f09c 	.word	0x0801f09c
 8008a08:	0801ef70 	.word	0x0801ef70
 8008a0c:	0801f0b4 	.word	0x0801f0b4
 8008a10:	000002f5 	.word	0x000002f5
 8008a14:	0801f0d4 	.word	0x0801f0d4
 8008a18:	20001b08 	.word	0x20001b08
 8008a1c:	00000316 	.word	0x00000316

08008a20 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size_in)
{
 8008a20:	b590      	push	{r4, r7, lr}
 8008a22:	b089      	sub	sp, #36	; 0x24
 8008a24:	af00      	add	r7, sp, #0
 8008a26:	0002      	movs	r2, r0
 8008a28:	1dbb      	adds	r3, r7, #6
 8008a2a:	801a      	strh	r2, [r3, #0]
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size_in == 0) {
 8008a2c:	1dbb      	adds	r3, r7, #6
 8008a2e:	881b      	ldrh	r3, [r3, #0]
 8008a30:	2b00      	cmp	r3, #0
 8008a32:	d101      	bne.n	8008a38 <mem_malloc+0x18>
    return NULL;
 8008a34:	2300      	movs	r3, #0
 8008a36:	e101      	b.n	8008c3c <mem_malloc+0x21c>
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = (mem_size_t)LWIP_MEM_ALIGN_SIZE(size_in);
 8008a38:	1dbb      	adds	r3, r7, #6
 8008a3a:	881b      	ldrh	r3, [r3, #0]
 8008a3c:	3303      	adds	r3, #3
 8008a3e:	b29a      	uxth	r2, r3
 8008a40:	201c      	movs	r0, #28
 8008a42:	183b      	adds	r3, r7, r0
 8008a44:	2103      	movs	r1, #3
 8008a46:	438a      	bics	r2, r1
 8008a48:	801a      	strh	r2, [r3, #0]
  if (size < MIN_SIZE_ALIGNED) {
 8008a4a:	183b      	adds	r3, r7, r0
 8008a4c:	881b      	ldrh	r3, [r3, #0]
 8008a4e:	2b0b      	cmp	r3, #11
 8008a50:	d802      	bhi.n	8008a58 <mem_malloc+0x38>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
 8008a52:	183b      	adds	r3, r7, r0
 8008a54:	220c      	movs	r2, #12
 8008a56:	801a      	strh	r2, [r3, #0]
  }
#if MEM_OVERFLOW_CHECK
  size += MEM_SANITY_REGION_BEFORE_ALIGNED + MEM_SANITY_REGION_AFTER_ALIGNED;
#endif
  if ((size > MEM_SIZE_ALIGNED) || (size < size_in)) {
 8008a58:	211c      	movs	r1, #28
 8008a5a:	187b      	adds	r3, r7, r1
 8008a5c:	881a      	ldrh	r2, [r3, #0]
 8008a5e:	2380      	movs	r3, #128	; 0x80
 8008a60:	00db      	lsls	r3, r3, #3
 8008a62:	429a      	cmp	r2, r3
 8008a64:	d805      	bhi.n	8008a72 <mem_malloc+0x52>
 8008a66:	187a      	adds	r2, r7, r1
 8008a68:	1dbb      	adds	r3, r7, #6
 8008a6a:	8812      	ldrh	r2, [r2, #0]
 8008a6c:	881b      	ldrh	r3, [r3, #0]
 8008a6e:	429a      	cmp	r2, r3
 8008a70:	d201      	bcs.n	8008a76 <mem_malloc+0x56>
    return NULL;
 8008a72:	2300      	movs	r3, #0
 8008a74:	e0e2      	b.n	8008c3c <mem_malloc+0x21c>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = mem_to_ptr(lfree); ptr < MEM_SIZE_ALIGNED - size;
 8008a76:	4b73      	ldr	r3, [pc, #460]	; (8008c44 <mem_malloc+0x224>)
 8008a78:	681b      	ldr	r3, [r3, #0]
 8008a7a:	221e      	movs	r2, #30
 8008a7c:	18bc      	adds	r4, r7, r2
 8008a7e:	0018      	movs	r0, r3
 8008a80:	f7ff fd1a 	bl	80084b8 <mem_to_ptr>
 8008a84:	0003      	movs	r3, r0
 8008a86:	8023      	strh	r3, [r4, #0]
 8008a88:	e0cb      	b.n	8008c22 <mem_malloc+0x202>
         ptr = ptr_to_mem(ptr)->next) {
      mem = ptr_to_mem(ptr);
 8008a8a:	241e      	movs	r4, #30
 8008a8c:	193b      	adds	r3, r7, r4
 8008a8e:	881b      	ldrh	r3, [r3, #0]
 8008a90:	0018      	movs	r0, r3
 8008a92:	f7ff fcff 	bl	8008494 <ptr_to_mem>
 8008a96:	0003      	movs	r3, r0
 8008a98:	617b      	str	r3, [r7, #20]
        local_mem_free_count = 1;
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
 8008a9a:	697b      	ldr	r3, [r7, #20]
 8008a9c:	791b      	ldrb	r3, [r3, #4]
 8008a9e:	2b00      	cmp	r3, #0
 8008aa0:	d000      	beq.n	8008aa4 <mem_malloc+0x84>
 8008aa2:	e0b4      	b.n	8008c0e <mem_malloc+0x1ee>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 8008aa4:	697b      	ldr	r3, [r7, #20]
 8008aa6:	881b      	ldrh	r3, [r3, #0]
 8008aa8:	001a      	movs	r2, r3
 8008aaa:	0021      	movs	r1, r4
 8008aac:	187b      	adds	r3, r7, r1
 8008aae:	881b      	ldrh	r3, [r3, #0]
 8008ab0:	1ad3      	subs	r3, r2, r3
 8008ab2:	3b08      	subs	r3, #8
 8008ab4:	001a      	movs	r2, r3
 8008ab6:	201c      	movs	r0, #28
 8008ab8:	183b      	adds	r3, r7, r0
 8008aba:	881b      	ldrh	r3, [r3, #0]
      if ((!mem->used) &&
 8008abc:	429a      	cmp	r2, r3
 8008abe:	d200      	bcs.n	8008ac2 <mem_malloc+0xa2>
 8008ac0:	e0a5      	b.n	8008c0e <mem_malloc+0x1ee>
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
 8008ac2:	697b      	ldr	r3, [r7, #20]
 8008ac4:	881b      	ldrh	r3, [r3, #0]
 8008ac6:	001a      	movs	r2, r3
 8008ac8:	187b      	adds	r3, r7, r1
 8008aca:	881b      	ldrh	r3, [r3, #0]
 8008acc:	1ad3      	subs	r3, r2, r3
 8008ace:	3b08      	subs	r3, #8
 8008ad0:	001a      	movs	r2, r3
 8008ad2:	183b      	adds	r3, r7, r0
 8008ad4:	881b      	ldrh	r3, [r3, #0]
 8008ad6:	3314      	adds	r3, #20
 8008ad8:	429a      	cmp	r2, r3
 8008ada:	d340      	bcc.n	8008b5e <mem_malloc+0x13e>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + size);
 8008adc:	187a      	adds	r2, r7, r1
 8008ade:	183b      	adds	r3, r7, r0
 8008ae0:	8812      	ldrh	r2, [r2, #0]
 8008ae2:	881b      	ldrh	r3, [r3, #0]
 8008ae4:	18d3      	adds	r3, r2, r3
 8008ae6:	b29a      	uxth	r2, r3
 8008ae8:	2112      	movs	r1, #18
 8008aea:	187b      	adds	r3, r7, r1
 8008aec:	3208      	adds	r2, #8
 8008aee:	801a      	strh	r2, [r3, #0]
          LWIP_ASSERT("invalid next ptr",ptr2 != MEM_SIZE_ALIGNED);
 8008af0:	187b      	adds	r3, r7, r1
 8008af2:	881a      	ldrh	r2, [r3, #0]
 8008af4:	2380      	movs	r3, #128	; 0x80
 8008af6:	00db      	lsls	r3, r3, #3
 8008af8:	429a      	cmp	r2, r3
 8008afa:	d105      	bne.n	8008b08 <mem_malloc+0xe8>
 8008afc:	4b52      	ldr	r3, [pc, #328]	; (8008c48 <mem_malloc+0x228>)
 8008afe:	4a53      	ldr	r2, [pc, #332]	; (8008c4c <mem_malloc+0x22c>)
 8008b00:	4953      	ldr	r1, [pc, #332]	; (8008c50 <mem_malloc+0x230>)
 8008b02:	4854      	ldr	r0, [pc, #336]	; (8008c54 <mem_malloc+0x234>)
 8008b04:	f7f9 feea 	bl	80028dc <app_debug_rtt_raw>
          /* create mem2 struct */
          mem2 = ptr_to_mem(ptr2);
 8008b08:	2412      	movs	r4, #18
 8008b0a:	193b      	adds	r3, r7, r4
 8008b0c:	881b      	ldrh	r3, [r3, #0]
 8008b0e:	0018      	movs	r0, r3
 8008b10:	f7ff fcc0 	bl	8008494 <ptr_to_mem>
 8008b14:	0003      	movs	r3, r0
 8008b16:	60fb      	str	r3, [r7, #12]
          mem2->used = 0;
 8008b18:	68fb      	ldr	r3, [r7, #12]
 8008b1a:	2200      	movs	r2, #0
 8008b1c:	711a      	strb	r2, [r3, #4]
          mem2->next = mem->next;
 8008b1e:	697b      	ldr	r3, [r7, #20]
 8008b20:	881a      	ldrh	r2, [r3, #0]
 8008b22:	68fb      	ldr	r3, [r7, #12]
 8008b24:	801a      	strh	r2, [r3, #0]
          mem2->prev = ptr;
 8008b26:	68fb      	ldr	r3, [r7, #12]
 8008b28:	221e      	movs	r2, #30
 8008b2a:	18ba      	adds	r2, r7, r2
 8008b2c:	8812      	ldrh	r2, [r2, #0]
 8008b2e:	805a      	strh	r2, [r3, #2]
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
 8008b30:	697b      	ldr	r3, [r7, #20]
 8008b32:	193a      	adds	r2, r7, r4
 8008b34:	8812      	ldrh	r2, [r2, #0]
 8008b36:	801a      	strh	r2, [r3, #0]
          mem->used = 1;
 8008b38:	697b      	ldr	r3, [r7, #20]
 8008b3a:	2201      	movs	r2, #1
 8008b3c:	711a      	strb	r2, [r3, #4]

          if (mem2->next != MEM_SIZE_ALIGNED) {
 8008b3e:	68fb      	ldr	r3, [r7, #12]
 8008b40:	881a      	ldrh	r2, [r3, #0]
 8008b42:	2380      	movs	r3, #128	; 0x80
 8008b44:	00db      	lsls	r3, r3, #3
 8008b46:	429a      	cmp	r2, r3
 8008b48:	d00c      	beq.n	8008b64 <mem_malloc+0x144>
            ptr_to_mem(mem2->next)->prev = ptr2;
 8008b4a:	68fb      	ldr	r3, [r7, #12]
 8008b4c:	881b      	ldrh	r3, [r3, #0]
 8008b4e:	0018      	movs	r0, r3
 8008b50:	f7ff fca0 	bl	8008494 <ptr_to_mem>
 8008b54:	0002      	movs	r2, r0
 8008b56:	193b      	adds	r3, r7, r4
 8008b58:	881b      	ldrh	r3, [r3, #0]
 8008b5a:	8053      	strh	r3, [r2, #2]
 8008b5c:	e002      	b.n	8008b64 <mem_malloc+0x144>
           * take care of this).
           * -> near fit or exact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
 8008b5e:	697b      	ldr	r3, [r7, #20]
 8008b60:	2201      	movs	r2, #1
 8008b62:	711a      	strb	r2, [r3, #4]
          MEM_STATS_INC_USED(used, mem->next - mem_to_ptr(mem));
        }
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
 8008b64:	4b37      	ldr	r3, [pc, #220]	; (8008c44 <mem_malloc+0x224>)
 8008b66:	681b      	ldr	r3, [r3, #0]
 8008b68:	697a      	ldr	r2, [r7, #20]
 8008b6a:	429a      	cmp	r2, r3
 8008b6c:	d127      	bne.n	8008bbe <mem_malloc+0x19e>
          struct mem *cur = lfree;
 8008b6e:	4b35      	ldr	r3, [pc, #212]	; (8008c44 <mem_malloc+0x224>)
 8008b70:	681b      	ldr	r3, [r3, #0]
 8008b72:	61bb      	str	r3, [r7, #24]
          /* Find next free block after mem and update lowest free pointer */
          while (cur->used && cur != ram_end) {
 8008b74:	e006      	b.n	8008b84 <mem_malloc+0x164>
              /* If mem_free or mem_trim have run, we have to restart since they
                 could have altered our current struct mem or lfree. */
              goto mem_malloc_adjust_lfree;
            }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
            cur = ptr_to_mem(cur->next);
 8008b76:	69bb      	ldr	r3, [r7, #24]
 8008b78:	881b      	ldrh	r3, [r3, #0]
 8008b7a:	0018      	movs	r0, r3
 8008b7c:	f7ff fc8a 	bl	8008494 <ptr_to_mem>
 8008b80:	0003      	movs	r3, r0
 8008b82:	61bb      	str	r3, [r7, #24]
          while (cur->used && cur != ram_end) {
 8008b84:	69bb      	ldr	r3, [r7, #24]
 8008b86:	791b      	ldrb	r3, [r3, #4]
 8008b88:	2b00      	cmp	r3, #0
 8008b8a:	d004      	beq.n	8008b96 <mem_malloc+0x176>
 8008b8c:	4b32      	ldr	r3, [pc, #200]	; (8008c58 <mem_malloc+0x238>)
 8008b8e:	681b      	ldr	r3, [r3, #0]
 8008b90:	69ba      	ldr	r2, [r7, #24]
 8008b92:	429a      	cmp	r2, r3
 8008b94:	d1ef      	bne.n	8008b76 <mem_malloc+0x156>
          }
          lfree = cur;
 8008b96:	4b2b      	ldr	r3, [pc, #172]	; (8008c44 <mem_malloc+0x224>)
 8008b98:	69ba      	ldr	r2, [r7, #24]
 8008b9a:	601a      	str	r2, [r3, #0]
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
 8008b9c:	4b29      	ldr	r3, [pc, #164]	; (8008c44 <mem_malloc+0x224>)
 8008b9e:	681a      	ldr	r2, [r3, #0]
 8008ba0:	4b2d      	ldr	r3, [pc, #180]	; (8008c58 <mem_malloc+0x238>)
 8008ba2:	681b      	ldr	r3, [r3, #0]
 8008ba4:	429a      	cmp	r2, r3
 8008ba6:	d00a      	beq.n	8008bbe <mem_malloc+0x19e>
 8008ba8:	4b26      	ldr	r3, [pc, #152]	; (8008c44 <mem_malloc+0x224>)
 8008baa:	681b      	ldr	r3, [r3, #0]
 8008bac:	791b      	ldrb	r3, [r3, #4]
 8008bae:	2b00      	cmp	r3, #0
 8008bb0:	d005      	beq.n	8008bbe <mem_malloc+0x19e>
 8008bb2:	4b25      	ldr	r3, [pc, #148]	; (8008c48 <mem_malloc+0x228>)
 8008bb4:	4a29      	ldr	r2, [pc, #164]	; (8008c5c <mem_malloc+0x23c>)
 8008bb6:	492a      	ldr	r1, [pc, #168]	; (8008c60 <mem_malloc+0x240>)
 8008bb8:	4826      	ldr	r0, [pc, #152]	; (8008c54 <mem_malloc+0x234>)
 8008bba:	f7f9 fe8f 	bl	80028dc <app_debug_rtt_raw>
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_mutex_unlock(&mem_mutex);
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
 8008bbe:	231c      	movs	r3, #28
 8008bc0:	18fb      	adds	r3, r7, r3
 8008bc2:	881a      	ldrh	r2, [r3, #0]
 8008bc4:	697b      	ldr	r3, [r7, #20]
 8008bc6:	18d3      	adds	r3, r2, r3
 8008bc8:	3308      	adds	r3, #8
 8008bca:	001a      	movs	r2, r3
 8008bcc:	4b22      	ldr	r3, [pc, #136]	; (8008c58 <mem_malloc+0x238>)
 8008bce:	681b      	ldr	r3, [r3, #0]
 8008bd0:	429a      	cmp	r2, r3
 8008bd2:	d905      	bls.n	8008be0 <mem_malloc+0x1c0>
 8008bd4:	4b1c      	ldr	r3, [pc, #112]	; (8008c48 <mem_malloc+0x228>)
 8008bd6:	4a23      	ldr	r2, [pc, #140]	; (8008c64 <mem_malloc+0x244>)
 8008bd8:	4923      	ldr	r1, [pc, #140]	; (8008c68 <mem_malloc+0x248>)
 8008bda:	481e      	ldr	r0, [pc, #120]	; (8008c54 <mem_malloc+0x234>)
 8008bdc:	f7f9 fe7e 	bl	80028dc <app_debug_rtt_raw>
                    (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
 8008be0:	697b      	ldr	r3, [r7, #20]
 8008be2:	2203      	movs	r2, #3
 8008be4:	4013      	ands	r3, r2
 8008be6:	d005      	beq.n	8008bf4 <mem_malloc+0x1d4>
 8008be8:	4b17      	ldr	r3, [pc, #92]	; (8008c48 <mem_malloc+0x228>)
 8008bea:	4a20      	ldr	r2, [pc, #128]	; (8008c6c <mem_malloc+0x24c>)
 8008bec:	4920      	ldr	r1, [pc, #128]	; (8008c70 <mem_malloc+0x250>)
 8008bee:	4819      	ldr	r0, [pc, #100]	; (8008c54 <mem_malloc+0x234>)
 8008bf0:	f7f9 fe74 	bl	80028dc <app_debug_rtt_raw>
                    ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
 8008bf4:	697b      	ldr	r3, [r7, #20]
 8008bf6:	2203      	movs	r2, #3
 8008bf8:	4013      	ands	r3, r2
 8008bfa:	d005      	beq.n	8008c08 <mem_malloc+0x1e8>
 8008bfc:	4b12      	ldr	r3, [pc, #72]	; (8008c48 <mem_malloc+0x228>)
 8008bfe:	4a1d      	ldr	r2, [pc, #116]	; (8008c74 <mem_malloc+0x254>)
 8008c00:	491d      	ldr	r1, [pc, #116]	; (8008c78 <mem_malloc+0x258>)
 8008c02:	4814      	ldr	r0, [pc, #80]	; (8008c54 <mem_malloc+0x234>)
 8008c04:	f7f9 fe6a 	bl	80028dc <app_debug_rtt_raw>

#if MEM_OVERFLOW_CHECK
        mem_overflow_init_element(mem, size_in);
#endif
        MEM_SANITY();
        return (u8_t *)mem + SIZEOF_STRUCT_MEM + MEM_SANITY_OFFSET;
 8008c08:	697b      	ldr	r3, [r7, #20]
 8008c0a:	3308      	adds	r3, #8
 8008c0c:	e016      	b.n	8008c3c <mem_malloc+0x21c>
         ptr = ptr_to_mem(ptr)->next) {
 8008c0e:	241e      	movs	r4, #30
 8008c10:	193b      	adds	r3, r7, r4
 8008c12:	881b      	ldrh	r3, [r3, #0]
 8008c14:	0018      	movs	r0, r3
 8008c16:	f7ff fc3d 	bl	8008494 <ptr_to_mem>
 8008c1a:	0002      	movs	r2, r0
 8008c1c:	193b      	adds	r3, r7, r4
 8008c1e:	8812      	ldrh	r2, [r2, #0]
 8008c20:	801a      	strh	r2, [r3, #0]
    for (ptr = mem_to_ptr(lfree); ptr < MEM_SIZE_ALIGNED - size;
 8008c22:	231e      	movs	r3, #30
 8008c24:	18fb      	adds	r3, r7, r3
 8008c26:	881a      	ldrh	r2, [r3, #0]
 8008c28:	231c      	movs	r3, #28
 8008c2a:	18fb      	adds	r3, r7, r3
 8008c2c:	881b      	ldrh	r3, [r3, #0]
 8008c2e:	2180      	movs	r1, #128	; 0x80
 8008c30:	00c9      	lsls	r1, r1, #3
 8008c32:	1acb      	subs	r3, r1, r3
 8008c34:	429a      	cmp	r2, r3
 8008c36:	d200      	bcs.n	8008c3a <mem_malloc+0x21a>
 8008c38:	e727      	b.n	8008a8a <mem_malloc+0x6a>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  return NULL;
 8008c3a:	2300      	movs	r3, #0
}
 8008c3c:	0018      	movs	r0, r3
 8008c3e:	46bd      	mov	sp, r7
 8008c40:	b009      	add	sp, #36	; 0x24
 8008c42:	bd90      	pop	{r4, r7, pc}
 8008c44:	20001b08 	.word	0x20001b08
 8008c48:	0801ef30 	.word	0x0801ef30
 8008c4c:	00000387 	.word	0x00000387
 8008c50:	0801f0d4 	.word	0x0801f0d4
 8008c54:	0801ef70 	.word	0x0801ef70
 8008c58:	20001b04 	.word	0x20001b04
 8008c5c:	000003b5 	.word	0x000003b5
 8008c60:	0801f0e8 	.word	0x0801f0e8
 8008c64:	000003b9 	.word	0x000003b9
 8008c68:	0801f104 	.word	0x0801f104
 8008c6c:	000003bb 	.word	0x000003bb
 8008c70:	0801f134 	.word	0x0801f134
 8008c74:	000003bd 	.word	0x000003bd
 8008c78:	0801f164 	.word	0x0801f164

08008c7c <do_memp_malloc_pool>:
#if !MEMP_OVERFLOW_CHECK
do_memp_malloc_pool(const struct memp_desc *desc)
#else
do_memp_malloc_pool_fn(const struct memp_desc *desc, const char *file, const int line)
#endif
{
 8008c7c:	b580      	push	{r7, lr}
 8008c7e:	b084      	sub	sp, #16
 8008c80:	af00      	add	r7, sp, #0
 8008c82:	6078      	str	r0, [r7, #4]
  memp = (struct memp *)mem_malloc(MEMP_SIZE + MEMP_ALIGN_SIZE(desc->size));
  SYS_ARCH_PROTECT(old_level);
#else /* MEMP_MEM_MALLOC */
  SYS_ARCH_PROTECT(old_level);

  memp = *desc->tab;
 8008c84:	687b      	ldr	r3, [r7, #4]
 8008c86:	68db      	ldr	r3, [r3, #12]
 8008c88:	681b      	ldr	r3, [r3, #0]
 8008c8a:	60fb      	str	r3, [r7, #12]
#endif /* MEMP_MEM_MALLOC */

  if (memp != NULL) {
 8008c8c:	68fb      	ldr	r3, [r7, #12]
 8008c8e:	2b00      	cmp	r3, #0
 8008c90:	d011      	beq.n	8008cb6 <do_memp_malloc_pool+0x3a>
#if !MEMP_MEM_MALLOC
#if MEMP_OVERFLOW_CHECK == 1
    memp_overflow_check_element(memp, desc);
#endif /* MEMP_OVERFLOW_CHECK */

    *desc->tab = memp->next;
 8008c92:	687b      	ldr	r3, [r7, #4]
 8008c94:	68db      	ldr	r3, [r3, #12]
 8008c96:	68fa      	ldr	r2, [r7, #12]
 8008c98:	6812      	ldr	r2, [r2, #0]
 8008c9a:	601a      	str	r2, [r3, #0]
    memp->line = line;
#if MEMP_MEM_MALLOC
    memp_overflow_init_element(memp, desc);
#endif /* MEMP_MEM_MALLOC */
#endif /* MEMP_OVERFLOW_CHECK */
    LWIP_ASSERT("memp_malloc: memp properly aligned",
 8008c9c:	68fb      	ldr	r3, [r7, #12]
 8008c9e:	2203      	movs	r2, #3
 8008ca0:	4013      	ands	r3, r2
 8008ca2:	d006      	beq.n	8008cb2 <do_memp_malloc_pool+0x36>
 8008ca4:	4b06      	ldr	r3, [pc, #24]	; (8008cc0 <do_memp_malloc_pool+0x44>)
 8008ca6:	228c      	movs	r2, #140	; 0x8c
 8008ca8:	0052      	lsls	r2, r2, #1
 8008caa:	4906      	ldr	r1, [pc, #24]	; (8008cc4 <do_memp_malloc_pool+0x48>)
 8008cac:	4806      	ldr	r0, [pc, #24]	; (8008cc8 <do_memp_malloc_pool+0x4c>)
 8008cae:	f7f9 fe15 	bl	80028dc <app_debug_rtt_raw>
      desc->stats->max = desc->stats->used;
    }
#endif
    SYS_ARCH_UNPROTECT(old_level);
    /* cast through u8_t* to get rid of alignment warnings */
    return ((u8_t *)memp + MEMP_SIZE);
 8008cb2:	68fb      	ldr	r3, [r7, #12]
 8008cb4:	e000      	b.n	8008cb8 <do_memp_malloc_pool+0x3c>
#endif
    SYS_ARCH_UNPROTECT(old_level);
    LWIP_DEBUGF(MEMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("memp_malloc: out of memory in pool %s\n", desc->desc));
  }

  return NULL;
 8008cb6:	2300      	movs	r3, #0
}
 8008cb8:	0018      	movs	r0, r3
 8008cba:	46bd      	mov	sp, r7
 8008cbc:	b004      	add	sp, #16
 8008cbe:	bd80      	pop	{r7, pc}
 8008cc0:	0801f1d8 	.word	0x0801f1d8
 8008cc4:	0801f200 	.word	0x0801f200
 8008cc8:	0801f224 	.word	0x0801f224

08008ccc <memp_malloc_pool>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc_pool(const struct memp_desc *desc)
#else
memp_malloc_pool_fn(const struct memp_desc *desc, const char *file, const int line)
#endif
{
 8008ccc:	b580      	push	{r7, lr}
 8008cce:	b082      	sub	sp, #8
 8008cd0:	af00      	add	r7, sp, #0
 8008cd2:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("invalid pool desc", desc != NULL);
 8008cd4:	687b      	ldr	r3, [r7, #4]
 8008cd6:	2b00      	cmp	r3, #0
 8008cd8:	d106      	bne.n	8008ce8 <memp_malloc_pool+0x1c>
 8008cda:	4b0a      	ldr	r3, [pc, #40]	; (8008d04 <memp_malloc_pool+0x38>)
 8008cdc:	229e      	movs	r2, #158	; 0x9e
 8008cde:	0052      	lsls	r2, r2, #1
 8008ce0:	4909      	ldr	r1, [pc, #36]	; (8008d08 <memp_malloc_pool+0x3c>)
 8008ce2:	480a      	ldr	r0, [pc, #40]	; (8008d0c <memp_malloc_pool+0x40>)
 8008ce4:	f7f9 fdfa 	bl	80028dc <app_debug_rtt_raw>
  if (desc == NULL) {
 8008ce8:	687b      	ldr	r3, [r7, #4]
 8008cea:	2b00      	cmp	r3, #0
 8008cec:	d101      	bne.n	8008cf2 <memp_malloc_pool+0x26>
    return NULL;
 8008cee:	2300      	movs	r3, #0
 8008cf0:	e004      	b.n	8008cfc <memp_malloc_pool+0x30>
  }

#if !MEMP_OVERFLOW_CHECK
  return do_memp_malloc_pool(desc);
 8008cf2:	687b      	ldr	r3, [r7, #4]
 8008cf4:	0018      	movs	r0, r3
 8008cf6:	f7ff ffc1 	bl	8008c7c <do_memp_malloc_pool>
 8008cfa:	0003      	movs	r3, r0
#else
  return do_memp_malloc_pool_fn(desc, file, line);
#endif
}
 8008cfc:	0018      	movs	r0, r3
 8008cfe:	46bd      	mov	sp, r7
 8008d00:	b002      	add	sp, #8
 8008d02:	bd80      	pop	{r7, pc}
 8008d04:	0801f1d8 	.word	0x0801f1d8
 8008d08:	0801f250 	.word	0x0801f250
 8008d0c:	0801f224 	.word	0x0801f224

08008d10 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char *file, const int line)
#endif
{
 8008d10:	b580      	push	{r7, lr}
 8008d12:	b084      	sub	sp, #16
 8008d14:	af00      	add	r7, sp, #0
 8008d16:	0002      	movs	r2, r0
 8008d18:	1dfb      	adds	r3, r7, #7
 8008d1a:	701a      	strb	r2, [r3, #0]
  void *memp;
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 8008d1c:	1dfb      	adds	r3, r7, #7
 8008d1e:	781b      	ldrb	r3, [r3, #0]
 8008d20:	2b06      	cmp	r3, #6
 8008d22:	d905      	bls.n	8008d30 <memp_malloc+0x20>
 8008d24:	4b0a      	ldr	r3, [pc, #40]	; (8008d50 <memp_malloc+0x40>)
 8008d26:	0018      	movs	r0, r3
 8008d28:	f7f9 fdd8 	bl	80028dc <app_debug_rtt_raw>
 8008d2c:	2300      	movs	r3, #0
 8008d2e:	e00a      	b.n	8008d46 <memp_malloc+0x36>
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

#if !MEMP_OVERFLOW_CHECK
  memp = do_memp_malloc_pool(memp_pools[type]);
 8008d30:	1dfb      	adds	r3, r7, #7
 8008d32:	781a      	ldrb	r2, [r3, #0]
 8008d34:	4b07      	ldr	r3, [pc, #28]	; (8008d54 <memp_malloc+0x44>)
 8008d36:	0092      	lsls	r2, r2, #2
 8008d38:	58d3      	ldr	r3, [r2, r3]
 8008d3a:	0018      	movs	r0, r3
 8008d3c:	f7ff ff9e 	bl	8008c7c <do_memp_malloc_pool>
 8008d40:	0003      	movs	r3, r0
 8008d42:	60fb      	str	r3, [r7, #12]
#else
  memp = do_memp_malloc_pool_fn(memp_pools[type], file, line);
#endif

  return memp;
 8008d44:	68fb      	ldr	r3, [r7, #12]
}
 8008d46:	0018      	movs	r0, r3
 8008d48:	46bd      	mov	sp, r7
 8008d4a:	b004      	add	sp, #16
 8008d4c:	bd80      	pop	{r7, pc}
 8008d4e:	46c0      	nop			; (mov r8, r8)
 8008d50:	0801f264 	.word	0x0801f264
 8008d54:	08022400 	.word	0x08022400

08008d58 <do_memp_free_pool>:

static void
do_memp_free_pool(const struct memp_desc *desc, void *mem)
{
 8008d58:	b580      	push	{r7, lr}
 8008d5a:	b084      	sub	sp, #16
 8008d5c:	af00      	add	r7, sp, #0
 8008d5e:	6078      	str	r0, [r7, #4]
 8008d60:	6039      	str	r1, [r7, #0]
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  LWIP_ASSERT("memp_free: mem properly aligned",
 8008d62:	683b      	ldr	r3, [r7, #0]
 8008d64:	2203      	movs	r2, #3
 8008d66:	4013      	ands	r3, r2
 8008d68:	d006      	beq.n	8008d78 <do_memp_free_pool+0x20>
 8008d6a:	4b0b      	ldr	r3, [pc, #44]	; (8008d98 <do_memp_free_pool+0x40>)
 8008d6c:	22b6      	movs	r2, #182	; 0xb6
 8008d6e:	0052      	lsls	r2, r2, #1
 8008d70:	490a      	ldr	r1, [pc, #40]	; (8008d9c <do_memp_free_pool+0x44>)
 8008d72:	480b      	ldr	r0, [pc, #44]	; (8008da0 <do_memp_free_pool+0x48>)
 8008d74:	f7f9 fdb2 	bl	80028dc <app_debug_rtt_raw>
              ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  /* cast through void* to get rid of alignment warnings */
  memp = (struct memp *)(void *)((u8_t *)mem - MEMP_SIZE);
 8008d78:	683b      	ldr	r3, [r7, #0]
 8008d7a:	60fb      	str	r3, [r7, #12]
#if MEMP_MEM_MALLOC
  LWIP_UNUSED_ARG(desc);
  SYS_ARCH_UNPROTECT(old_level);
  mem_free(memp);
#else /* MEMP_MEM_MALLOC */
  memp->next = *desc->tab;
 8008d7c:	687b      	ldr	r3, [r7, #4]
 8008d7e:	68db      	ldr	r3, [r3, #12]
 8008d80:	681a      	ldr	r2, [r3, #0]
 8008d82:	68fb      	ldr	r3, [r7, #12]
 8008d84:	601a      	str	r2, [r3, #0]
  *desc->tab = memp;
 8008d86:	687b      	ldr	r3, [r7, #4]
 8008d88:	68db      	ldr	r3, [r3, #12]
 8008d8a:	68fa      	ldr	r2, [r7, #12]
 8008d8c:	601a      	str	r2, [r3, #0]
  LWIP_ASSERT("memp sanity", memp_sanity(desc));
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
#endif /* !MEMP_MEM_MALLOC */
}
 8008d8e:	46c0      	nop			; (mov r8, r8)
 8008d90:	46bd      	mov	sp, r7
 8008d92:	b004      	add	sp, #16
 8008d94:	bd80      	pop	{r7, pc}
 8008d96:	46c0      	nop			; (mov r8, r8)
 8008d98:	0801f1d8 	.word	0x0801f1d8
 8008d9c:	0801f284 	.word	0x0801f284
 8008da0:	0801f224 	.word	0x0801f224

08008da4 <memp_free_pool>:
 * @param desc the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free_pool(const struct memp_desc *desc, void *mem)
{
 8008da4:	b580      	push	{r7, lr}
 8008da6:	b082      	sub	sp, #8
 8008da8:	af00      	add	r7, sp, #0
 8008daa:	6078      	str	r0, [r7, #4]
 8008dac:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT("invalid pool desc", desc != NULL);
 8008dae:	687b      	ldr	r3, [r7, #4]
 8008db0:	2b00      	cmp	r3, #0
 8008db2:	d106      	bne.n	8008dc2 <memp_free_pool+0x1e>
 8008db4:	4b0b      	ldr	r3, [pc, #44]	; (8008de4 <memp_free_pool+0x40>)
 8008db6:	2296      	movs	r2, #150	; 0x96
 8008db8:	32ff      	adds	r2, #255	; 0xff
 8008dba:	490b      	ldr	r1, [pc, #44]	; (8008de8 <memp_free_pool+0x44>)
 8008dbc:	480b      	ldr	r0, [pc, #44]	; (8008dec <memp_free_pool+0x48>)
 8008dbe:	f7f9 fd8d 	bl	80028dc <app_debug_rtt_raw>
  if ((desc == NULL) || (mem == NULL)) {
 8008dc2:	687b      	ldr	r3, [r7, #4]
 8008dc4:	2b00      	cmp	r3, #0
 8008dc6:	d009      	beq.n	8008ddc <memp_free_pool+0x38>
 8008dc8:	683b      	ldr	r3, [r7, #0]
 8008dca:	2b00      	cmp	r3, #0
 8008dcc:	d006      	beq.n	8008ddc <memp_free_pool+0x38>
    return;
  }

  do_memp_free_pool(desc, mem);
 8008dce:	683a      	ldr	r2, [r7, #0]
 8008dd0:	687b      	ldr	r3, [r7, #4]
 8008dd2:	0011      	movs	r1, r2
 8008dd4:	0018      	movs	r0, r3
 8008dd6:	f7ff ffbf 	bl	8008d58 <do_memp_free_pool>
 8008dda:	e000      	b.n	8008dde <memp_free_pool+0x3a>
    return;
 8008ddc:	46c0      	nop			; (mov r8, r8)
}
 8008dde:	46bd      	mov	sp, r7
 8008de0:	b002      	add	sp, #8
 8008de2:	bd80      	pop	{r7, pc}
 8008de4:	0801f1d8 	.word	0x0801f1d8
 8008de8:	0801f250 	.word	0x0801f250
 8008dec:	0801f224 	.word	0x0801f224

08008df0 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
 8008df0:	b580      	push	{r7, lr}
 8008df2:	b082      	sub	sp, #8
 8008df4:	af00      	add	r7, sp, #0
 8008df6:	0002      	movs	r2, r0
 8008df8:	6039      	str	r1, [r7, #0]
 8008dfa:	1dfb      	adds	r3, r7, #7
 8008dfc:	701a      	strb	r2, [r3, #0]
#ifdef LWIP_HOOK_MEMP_AVAILABLE
  struct memp *old_first;
#endif

  LWIP_ERROR("memp_free: type < MEMP_MAX", (type < MEMP_MAX), return;);
 8008dfe:	1dfb      	adds	r3, r7, #7
 8008e00:	781b      	ldrb	r3, [r3, #0]
 8008e02:	2b06      	cmp	r3, #6
 8008e04:	d904      	bls.n	8008e10 <memp_free+0x20>
 8008e06:	4b0b      	ldr	r3, [pc, #44]	; (8008e34 <memp_free+0x44>)
 8008e08:	0018      	movs	r0, r3
 8008e0a:	f7f9 fd67 	bl	80028dc <app_debug_rtt_raw>
 8008e0e:	e00e      	b.n	8008e2e <memp_free+0x3e>

  if (mem == NULL) {
 8008e10:	683b      	ldr	r3, [r7, #0]
 8008e12:	2b00      	cmp	r3, #0
 8008e14:	d00a      	beq.n	8008e2c <memp_free+0x3c>

#ifdef LWIP_HOOK_MEMP_AVAILABLE
  old_first = *memp_pools[type]->tab;
#endif

  do_memp_free_pool(memp_pools[type], mem);
 8008e16:	1dfb      	adds	r3, r7, #7
 8008e18:	781a      	ldrb	r2, [r3, #0]
 8008e1a:	4b07      	ldr	r3, [pc, #28]	; (8008e38 <memp_free+0x48>)
 8008e1c:	0092      	lsls	r2, r2, #2
 8008e1e:	58d3      	ldr	r3, [r2, r3]
 8008e20:	683a      	ldr	r2, [r7, #0]
 8008e22:	0011      	movs	r1, r2
 8008e24:	0018      	movs	r0, r3
 8008e26:	f7ff ff97 	bl	8008d58 <do_memp_free_pool>
 8008e2a:	e000      	b.n	8008e2e <memp_free+0x3e>
    return;
 8008e2c:	46c0      	nop			; (mov r8, r8)
#ifdef LWIP_HOOK_MEMP_AVAILABLE
  if (old_first == NULL) {
    LWIP_HOOK_MEMP_AVAILABLE(type);
  }
#endif
}
 8008e2e:	46bd      	mov	sp, r7
 8008e30:	b002      	add	sp, #8
 8008e32:	bd80      	pop	{r7, pc}
 8008e34:	0801f2a4 	.word	0x0801f2a4
 8008e38:	08022400 	.word	0x08022400

08008e3c <netif_add>:
netif_add(struct netif *netif,
#if LWIP_IPV4
          const ip4_addr_t *ipaddr, const ip4_addr_t *netmask, const ip4_addr_t *gw,
#endif /* LWIP_IPV4 */
          void *state, netif_init_fn init, netif_input_fn input)
{
 8008e3c:	b580      	push	{r7, lr}
 8008e3e:	b086      	sub	sp, #24
 8008e40:	af00      	add	r7, sp, #0
 8008e42:	60f8      	str	r0, [r7, #12]
 8008e44:	60b9      	str	r1, [r7, #8]
 8008e46:	607a      	str	r2, [r7, #4]
 8008e48:	603b      	str	r3, [r7, #0]
    LWIP_ASSERT("single netif already set", 0);
    return NULL;
  }
#endif

  LWIP_ERROR("netif_add: invalid netif", netif != NULL, return NULL);
 8008e4a:	68fb      	ldr	r3, [r7, #12]
 8008e4c:	2b00      	cmp	r3, #0
 8008e4e:	d105      	bne.n	8008e5c <netif_add+0x20>
 8008e50:	4b57      	ldr	r3, [pc, #348]	; (8008fb0 <netif_add+0x174>)
 8008e52:	0018      	movs	r0, r3
 8008e54:	f7f9 fd42 	bl	80028dc <app_debug_rtt_raw>
 8008e58:	2300      	movs	r3, #0
 8008e5a:	e0a5      	b.n	8008fa8 <netif_add+0x16c>
  LWIP_ERROR("netif_add: No init function given", init != NULL, return NULL);
 8008e5c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008e5e:	2b00      	cmp	r3, #0
 8008e60:	d105      	bne.n	8008e6e <netif_add+0x32>
 8008e62:	4b54      	ldr	r3, [pc, #336]	; (8008fb4 <netif_add+0x178>)
 8008e64:	0018      	movs	r0, r3
 8008e66:	f7f9 fd39 	bl	80028dc <app_debug_rtt_raw>
 8008e6a:	2300      	movs	r3, #0
 8008e6c:	e09c      	b.n	8008fa8 <netif_add+0x16c>

#if LWIP_IPV4
  if (ipaddr == NULL) {
 8008e6e:	68bb      	ldr	r3, [r7, #8]
 8008e70:	2b00      	cmp	r3, #0
 8008e72:	d101      	bne.n	8008e78 <netif_add+0x3c>
    ipaddr = ip_2_ip4(IP4_ADDR_ANY);
 8008e74:	4b50      	ldr	r3, [pc, #320]	; (8008fb8 <netif_add+0x17c>)
 8008e76:	60bb      	str	r3, [r7, #8]
  }
  if (netmask == NULL) {
 8008e78:	687b      	ldr	r3, [r7, #4]
 8008e7a:	2b00      	cmp	r3, #0
 8008e7c:	d101      	bne.n	8008e82 <netif_add+0x46>
    netmask = ip_2_ip4(IP4_ADDR_ANY);
 8008e7e:	4b4e      	ldr	r3, [pc, #312]	; (8008fb8 <netif_add+0x17c>)
 8008e80:	607b      	str	r3, [r7, #4]
  }
  if (gw == NULL) {
 8008e82:	683b      	ldr	r3, [r7, #0]
 8008e84:	2b00      	cmp	r3, #0
 8008e86:	d101      	bne.n	8008e8c <netif_add+0x50>
    gw = ip_2_ip4(IP4_ADDR_ANY);
 8008e88:	4b4b      	ldr	r3, [pc, #300]	; (8008fb8 <netif_add+0x17c>)
 8008e8a:	603b      	str	r3, [r7, #0]
  }

  /* reset new interface configuration state */
  ip_addr_set_zero_ip4(&netif->ip_addr);
 8008e8c:	68fb      	ldr	r3, [r7, #12]
 8008e8e:	2200      	movs	r2, #0
 8008e90:	605a      	str	r2, [r3, #4]
  ip_addr_set_zero_ip4(&netif->netmask);
 8008e92:	68fb      	ldr	r3, [r7, #12]
 8008e94:	2200      	movs	r2, #0
 8008e96:	609a      	str	r2, [r3, #8]
  ip_addr_set_zero_ip4(&netif->gw);
 8008e98:	68fb      	ldr	r3, [r7, #12]
 8008e9a:	2200      	movs	r2, #0
 8008e9c:	60da      	str	r2, [r3, #12]
  netif->output = netif_null_output_ip4;
 8008e9e:	68fb      	ldr	r3, [r7, #12]
 8008ea0:	4a46      	ldr	r2, [pc, #280]	; (8008fbc <netif_add+0x180>)
 8008ea2:	615a      	str	r2, [r3, #20]
#endif /* LWIP_IPV6_ADDRESS_LIFETIMES */
  }
  netif->output_ip6 = netif_null_output_ip6;
#endif /* LWIP_IPV6 */
  NETIF_SET_CHECKSUM_CTRL(netif, NETIF_CHECKSUM_ENABLE_ALL);
  netif->mtu = 0;
 8008ea4:	68fb      	ldr	r3, [r7, #12]
 8008ea6:	2200      	movs	r2, #0
 8008ea8:	851a      	strh	r2, [r3, #40]	; 0x28
  netif->flags = 0;
 8008eaa:	68fb      	ldr	r3, [r7, #12]
 8008eac:	2231      	movs	r2, #49	; 0x31
 8008eae:	2100      	movs	r1, #0
 8008eb0:	5499      	strb	r1, [r3, r2]
  netif->ip6_autoconfig_enabled = 0;
#endif /* LWIP_IPV6_AUTOCONFIG */
  nd6_restart_netif(netif);
#endif /* LWIP_IPV6 */
#if LWIP_NETIF_STATUS_CALLBACK
  netif->status_callback = NULL;
 8008eb2:	68fb      	ldr	r3, [r7, #12]
 8008eb4:	2200      	movs	r2, #0
 8008eb6:	61da      	str	r2, [r3, #28]
#endif /* LWIP_NETIF_STATUS_CALLBACK */
#if LWIP_NETIF_LINK_CALLBACK
  netif->link_callback = NULL;
 8008eb8:	68fb      	ldr	r3, [r7, #12]
 8008eba:	2200      	movs	r2, #0
 8008ebc:	621a      	str	r2, [r3, #32]
#if LWIP_IPV6 && LWIP_IPV6_MLD
  netif->mld_mac_filter = NULL;
#endif /* LWIP_IPV6 && LWIP_IPV6_MLD */

  /* remember netif specific state information data */
  netif->state = state;
 8008ebe:	68fb      	ldr	r3, [r7, #12]
 8008ec0:	6a3a      	ldr	r2, [r7, #32]
 8008ec2:	625a      	str	r2, [r3, #36]	; 0x24
  netif->num = netif_num;
 8008ec4:	4b3e      	ldr	r3, [pc, #248]	; (8008fc0 <netif_add+0x184>)
 8008ec6:	7819      	ldrb	r1, [r3, #0]
 8008ec8:	68fb      	ldr	r3, [r7, #12]
 8008eca:	2234      	movs	r2, #52	; 0x34
 8008ecc:	5499      	strb	r1, [r3, r2]
  netif->input = input;
 8008ece:	68fb      	ldr	r3, [r7, #12]
 8008ed0:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8008ed2:	611a      	str	r2, [r3, #16]

  NETIF_RESET_HINTS(netif);
 8008ed4:	68fb      	ldr	r3, [r7, #12]
 8008ed6:	2200      	movs	r2, #0
 8008ed8:	639a      	str	r2, [r3, #56]	; 0x38
  netif->reschedule_poll = 0;
#endif /* LWIP_NETIF_LOOPBACK_MULTITHREADING */
#endif /* ENABLE_LOOPBACK */

#if LWIP_IPV4
  netif_set_addr(netif, ipaddr, netmask, gw);
 8008eda:	683b      	ldr	r3, [r7, #0]
 8008edc:	687a      	ldr	r2, [r7, #4]
 8008ede:	68b9      	ldr	r1, [r7, #8]
 8008ee0:	68f8      	ldr	r0, [r7, #12]
 8008ee2:	f000 f91d 	bl	8009120 <netif_set_addr>
#endif /* LWIP_IPV4 */

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
 8008ee6:	68fa      	ldr	r2, [r7, #12]
 8008ee8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008eea:	0010      	movs	r0, r2
 8008eec:	4798      	blx	r3
 8008eee:	1e03      	subs	r3, r0, #0
 8008ef0:	d001      	beq.n	8008ef6 <netif_add+0xba>
    return NULL;
 8008ef2:	2300      	movs	r3, #0
 8008ef4:	e058      	b.n	8008fa8 <netif_add+0x16c>
     */
  {
    struct netif *netif2;
    int num_netifs;
    do {
      if (netif->num == 255) {
 8008ef6:	68fb      	ldr	r3, [r7, #12]
 8008ef8:	2234      	movs	r2, #52	; 0x34
 8008efa:	5c9b      	ldrb	r3, [r3, r2]
 8008efc:	2bff      	cmp	r3, #255	; 0xff
 8008efe:	d103      	bne.n	8008f08 <netif_add+0xcc>
        netif->num = 0;
 8008f00:	68fb      	ldr	r3, [r7, #12]
 8008f02:	2234      	movs	r2, #52	; 0x34
 8008f04:	2100      	movs	r1, #0
 8008f06:	5499      	strb	r1, [r3, r2]
      }
      num_netifs = 0;
 8008f08:	2300      	movs	r3, #0
 8008f0a:	613b      	str	r3, [r7, #16]
      for (netif2 = netif_list; netif2 != NULL; netif2 = netif2->next) {
 8008f0c:	4b2d      	ldr	r3, [pc, #180]	; (8008fc4 <netif_add+0x188>)
 8008f0e:	681b      	ldr	r3, [r3, #0]
 8008f10:	617b      	str	r3, [r7, #20]
 8008f12:	e02b      	b.n	8008f6c <netif_add+0x130>
        LWIP_ASSERT("netif already added", netif2 != netif);
 8008f14:	697a      	ldr	r2, [r7, #20]
 8008f16:	68fb      	ldr	r3, [r7, #12]
 8008f18:	429a      	cmp	r2, r3
 8008f1a:	d106      	bne.n	8008f2a <netif_add+0xee>
 8008f1c:	4b2a      	ldr	r3, [pc, #168]	; (8008fc8 <netif_add+0x18c>)
 8008f1e:	22c7      	movs	r2, #199	; 0xc7
 8008f20:	0052      	lsls	r2, r2, #1
 8008f22:	492a      	ldr	r1, [pc, #168]	; (8008fcc <netif_add+0x190>)
 8008f24:	482a      	ldr	r0, [pc, #168]	; (8008fd0 <netif_add+0x194>)
 8008f26:	f7f9 fcd9 	bl	80028dc <app_debug_rtt_raw>
        num_netifs++;
 8008f2a:	693b      	ldr	r3, [r7, #16]
 8008f2c:	3301      	adds	r3, #1
 8008f2e:	613b      	str	r3, [r7, #16]
        LWIP_ASSERT("too many netifs, max. supported number is 255", num_netifs <= 255);
 8008f30:	693b      	ldr	r3, [r7, #16]
 8008f32:	2bff      	cmp	r3, #255	; 0xff
 8008f34:	dd06      	ble.n	8008f44 <netif_add+0x108>
 8008f36:	4b24      	ldr	r3, [pc, #144]	; (8008fc8 <netif_add+0x18c>)
 8008f38:	22c8      	movs	r2, #200	; 0xc8
 8008f3a:	0052      	lsls	r2, r2, #1
 8008f3c:	4925      	ldr	r1, [pc, #148]	; (8008fd4 <netif_add+0x198>)
 8008f3e:	4824      	ldr	r0, [pc, #144]	; (8008fd0 <netif_add+0x194>)
 8008f40:	f7f9 fccc 	bl	80028dc <app_debug_rtt_raw>
        if (netif2->num == netif->num) {
 8008f44:	697b      	ldr	r3, [r7, #20]
 8008f46:	2234      	movs	r2, #52	; 0x34
 8008f48:	5c9a      	ldrb	r2, [r3, r2]
 8008f4a:	68fb      	ldr	r3, [r7, #12]
 8008f4c:	2134      	movs	r1, #52	; 0x34
 8008f4e:	5c5b      	ldrb	r3, [r3, r1]
 8008f50:	429a      	cmp	r2, r3
 8008f52:	d108      	bne.n	8008f66 <netif_add+0x12a>
          netif->num++;
 8008f54:	68fb      	ldr	r3, [r7, #12]
 8008f56:	2234      	movs	r2, #52	; 0x34
 8008f58:	5c9b      	ldrb	r3, [r3, r2]
 8008f5a:	3301      	adds	r3, #1
 8008f5c:	b2d9      	uxtb	r1, r3
 8008f5e:	68fb      	ldr	r3, [r7, #12]
 8008f60:	2234      	movs	r2, #52	; 0x34
 8008f62:	5499      	strb	r1, [r3, r2]
          break;
 8008f64:	e005      	b.n	8008f72 <netif_add+0x136>
      for (netif2 = netif_list; netif2 != NULL; netif2 = netif2->next) {
 8008f66:	697b      	ldr	r3, [r7, #20]
 8008f68:	681b      	ldr	r3, [r3, #0]
 8008f6a:	617b      	str	r3, [r7, #20]
 8008f6c:	697b      	ldr	r3, [r7, #20]
 8008f6e:	2b00      	cmp	r3, #0
 8008f70:	d1d0      	bne.n	8008f14 <netif_add+0xd8>
        }
      }
    } while (netif2 != NULL);
 8008f72:	697b      	ldr	r3, [r7, #20]
 8008f74:	2b00      	cmp	r3, #0
 8008f76:	d1be      	bne.n	8008ef6 <netif_add+0xba>
  }
  if (netif->num == 254) {
 8008f78:	68fb      	ldr	r3, [r7, #12]
 8008f7a:	2234      	movs	r2, #52	; 0x34
 8008f7c:	5c9b      	ldrb	r3, [r3, r2]
 8008f7e:	2bfe      	cmp	r3, #254	; 0xfe
 8008f80:	d103      	bne.n	8008f8a <netif_add+0x14e>
    netif_num = 0;
 8008f82:	4b0f      	ldr	r3, [pc, #60]	; (8008fc0 <netif_add+0x184>)
 8008f84:	2200      	movs	r2, #0
 8008f86:	701a      	strb	r2, [r3, #0]
 8008f88:	e006      	b.n	8008f98 <netif_add+0x15c>
  } else {
    netif_num = (u8_t)(netif->num + 1);
 8008f8a:	68fb      	ldr	r3, [r7, #12]
 8008f8c:	2234      	movs	r2, #52	; 0x34
 8008f8e:	5c9b      	ldrb	r3, [r3, r2]
 8008f90:	3301      	adds	r3, #1
 8008f92:	b2da      	uxtb	r2, r3
 8008f94:	4b0a      	ldr	r3, [pc, #40]	; (8008fc0 <netif_add+0x184>)
 8008f96:	701a      	strb	r2, [r3, #0]
  }

  /* add this netif to the list */
  netif->next = netif_list;
 8008f98:	4b0a      	ldr	r3, [pc, #40]	; (8008fc4 <netif_add+0x188>)
 8008f9a:	681a      	ldr	r2, [r3, #0]
 8008f9c:	68fb      	ldr	r3, [r7, #12]
 8008f9e:	601a      	str	r2, [r3, #0]
  netif_list = netif;
 8008fa0:	4b08      	ldr	r3, [pc, #32]	; (8008fc4 <netif_add+0x188>)
 8008fa2:	68fa      	ldr	r2, [r7, #12]
 8008fa4:	601a      	str	r2, [r3, #0]
#endif /* LWIP_IPV4 */
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));

  netif_invoke_ext_callback(netif, LWIP_NSC_NETIF_ADDED, NULL);

  return netif;
 8008fa6:	68fb      	ldr	r3, [r7, #12]
}
 8008fa8:	0018      	movs	r0, r3
 8008faa:	46bd      	mov	sp, r7
 8008fac:	b006      	add	sp, #24
 8008fae:	bd80      	pop	{r7, pc}
 8008fb0:	0801f34c 	.word	0x0801f34c
 8008fb4:	0801f368 	.word	0x0801f368
 8008fb8:	0802246c 	.word	0x0802246c
 8008fbc:	080093cd 	.word	0x080093cd
 8008fc0:	20001b28 	.word	0x20001b28
 8008fc4:	20002ec4 	.word	0x20002ec4
 8008fc8:	0801f2c0 	.word	0x0801f2c0
 8008fcc:	0801f38c 	.word	0x0801f38c
 8008fd0:	0801f304 	.word	0x0801f304
 8008fd4:	0801f3a0 	.word	0x0801f3a0

08008fd8 <netif_do_ip_addr_changed>:

static void
netif_do_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_addr)
{
 8008fd8:	b580      	push	{r7, lr}
 8008fda:	b082      	sub	sp, #8
 8008fdc:	af00      	add	r7, sp, #0
 8008fde:	6078      	str	r0, [r7, #4]
 8008fe0:	6039      	str	r1, [r7, #0]
#if LWIP_TCP
  tcp_netif_ip_addr_changed(old_addr, new_addr);
 8008fe2:	683a      	ldr	r2, [r7, #0]
 8008fe4:	687b      	ldr	r3, [r7, #4]
 8008fe6:	0011      	movs	r1, r2
 8008fe8:	0018      	movs	r0, r3
 8008fea:	f003 fab5 	bl	800c558 <tcp_netif_ip_addr_changed>
#endif /* LWIP_TCP */
#if LWIP_UDP
  udp_netif_ip_addr_changed(old_addr, new_addr);
 8008fee:	683a      	ldr	r2, [r7, #0]
 8008ff0:	687b      	ldr	r3, [r7, #4]
 8008ff2:	0011      	movs	r1, r2
 8008ff4:	0018      	movs	r0, r3
 8008ff6:	f009 fe8f 	bl	8012d18 <udp_netif_ip_addr_changed>
#endif /* LWIP_UDP */
#if LWIP_RAW
  raw_netif_ip_addr_changed(old_addr, new_addr);
#endif /* LWIP_RAW */
}
 8008ffa:	46c0      	nop			; (mov r8, r8)
 8008ffc:	46bd      	mov	sp, r7
 8008ffe:	b002      	add	sp, #8
 8009000:	bd80      	pop	{r7, pc}
	...

08009004 <netif_do_set_ipaddr>:

#if LWIP_IPV4
static int
netif_do_set_ipaddr(struct netif *netif, const ip4_addr_t *ipaddr, ip_addr_t *old_addr)
{
 8009004:	b580      	push	{r7, lr}
 8009006:	b086      	sub	sp, #24
 8009008:	af00      	add	r7, sp, #0
 800900a:	60f8      	str	r0, [r7, #12]
 800900c:	60b9      	str	r1, [r7, #8]
 800900e:	607a      	str	r2, [r7, #4]
  LWIP_ASSERT("invalid pointer", ipaddr != NULL);
 8009010:	68bb      	ldr	r3, [r7, #8]
 8009012:	2b00      	cmp	r3, #0
 8009014:	d106      	bne.n	8009024 <netif_do_set_ipaddr+0x20>
 8009016:	4b22      	ldr	r3, [pc, #136]	; (80090a0 <netif_do_set_ipaddr+0x9c>)
 8009018:	22e7      	movs	r2, #231	; 0xe7
 800901a:	0052      	lsls	r2, r2, #1
 800901c:	4921      	ldr	r1, [pc, #132]	; (80090a4 <netif_do_set_ipaddr+0xa0>)
 800901e:	4822      	ldr	r0, [pc, #136]	; (80090a8 <netif_do_set_ipaddr+0xa4>)
 8009020:	f7f9 fc5c 	bl	80028dc <app_debug_rtt_raw>
  LWIP_ASSERT("invalid pointer", old_addr != NULL);
 8009024:	687b      	ldr	r3, [r7, #4]
 8009026:	2b00      	cmp	r3, #0
 8009028:	d106      	bne.n	8009038 <netif_do_set_ipaddr+0x34>
 800902a:	4b1d      	ldr	r3, [pc, #116]	; (80090a0 <netif_do_set_ipaddr+0x9c>)
 800902c:	22d0      	movs	r2, #208	; 0xd0
 800902e:	32ff      	adds	r2, #255	; 0xff
 8009030:	491c      	ldr	r1, [pc, #112]	; (80090a4 <netif_do_set_ipaddr+0xa0>)
 8009032:	481d      	ldr	r0, [pc, #116]	; (80090a8 <netif_do_set_ipaddr+0xa4>)
 8009034:	f7f9 fc52 	bl	80028dc <app_debug_rtt_raw>

  /* address is actually being changed? */
  if (ip4_addr_cmp(ipaddr, netif_ip4_addr(netif)) == 0) {
 8009038:	68bb      	ldr	r3, [r7, #8]
 800903a:	681a      	ldr	r2, [r3, #0]
 800903c:	68fb      	ldr	r3, [r7, #12]
 800903e:	3304      	adds	r3, #4
 8009040:	681b      	ldr	r3, [r3, #0]
 8009042:	429a      	cmp	r2, r3
 8009044:	d027      	beq.n	8009096 <netif_do_set_ipaddr+0x92>
    ip_addr_t new_addr;
    *ip_2_ip4(&new_addr) = *ipaddr;
 8009046:	68bb      	ldr	r3, [r7, #8]
 8009048:	681b      	ldr	r3, [r3, #0]
 800904a:	617b      	str	r3, [r7, #20]
    IP_SET_TYPE_VAL(new_addr, IPADDR_TYPE_V4);

    ip_addr_copy(*old_addr, *netif_ip_addr4(netif));
 800904c:	68fb      	ldr	r3, [r7, #12]
 800904e:	3304      	adds	r3, #4
 8009050:	681a      	ldr	r2, [r3, #0]
 8009052:	687b      	ldr	r3, [r7, #4]
 8009054:	601a      	str	r2, [r3, #0]

    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    netif_do_ip_addr_changed(old_addr, &new_addr);
 8009056:	2314      	movs	r3, #20
 8009058:	18fa      	adds	r2, r7, r3
 800905a:	687b      	ldr	r3, [r7, #4]
 800905c:	0011      	movs	r1, r2
 800905e:	0018      	movs	r0, r3
 8009060:	f7ff ffba 	bl	8008fd8 <netif_do_ip_addr_changed>

    mib2_remove_ip4(netif);
    mib2_remove_route_ip4(0, netif);
    /* set new IP address to netif */
    ip4_addr_set(ip_2_ip4(&netif->ip_addr), ipaddr);
 8009064:	68bb      	ldr	r3, [r7, #8]
 8009066:	2b00      	cmp	r3, #0
 8009068:	d002      	beq.n	8009070 <netif_do_set_ipaddr+0x6c>
 800906a:	68bb      	ldr	r3, [r7, #8]
 800906c:	681a      	ldr	r2, [r3, #0]
 800906e:	e000      	b.n	8009072 <netif_do_set_ipaddr+0x6e>
 8009070:	2200      	movs	r2, #0
 8009072:	68fb      	ldr	r3, [r7, #12]
 8009074:	605a      	str	r2, [r3, #4]
    IP_SET_TYPE_VAL(netif->ip_addr, IPADDR_TYPE_V4);
    mib2_add_ip4(netif);
    mib2_add_route_ip4(0, netif);

    netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4);
 8009076:	68fb      	ldr	r3, [r7, #12]
 8009078:	2101      	movs	r1, #1
 800907a:	0018      	movs	r0, r3
 800907c:	f000 f8f8 	bl	8009270 <netif_issue_reports>

    NETIF_STATUS_CALLBACK(netif);
 8009080:	68fb      	ldr	r3, [r7, #12]
 8009082:	69db      	ldr	r3, [r3, #28]
 8009084:	2b00      	cmp	r3, #0
 8009086:	d004      	beq.n	8009092 <netif_do_set_ipaddr+0x8e>
 8009088:	68fb      	ldr	r3, [r7, #12]
 800908a:	69db      	ldr	r3, [r3, #28]
 800908c:	68fa      	ldr	r2, [r7, #12]
 800908e:	0010      	movs	r0, r2
 8009090:	4798      	blx	r3
    return 1; /* address changed */
 8009092:	2301      	movs	r3, #1
 8009094:	e000      	b.n	8009098 <netif_do_set_ipaddr+0x94>
  }
  return 0; /* address unchanged */
 8009096:	2300      	movs	r3, #0
}
 8009098:	0018      	movs	r0, r3
 800909a:	46bd      	mov	sp, r7
 800909c:	b006      	add	sp, #24
 800909e:	bd80      	pop	{r7, pc}
 80090a0:	0801f2c0 	.word	0x0801f2c0
 80090a4:	0801f3d0 	.word	0x0801f3d0
 80090a8:	0801f304 	.word	0x0801f304

080090ac <netif_do_set_netmask>:
  }
}

static int
netif_do_set_netmask(struct netif *netif, const ip4_addr_t *netmask, ip_addr_t *old_nm)
{
 80090ac:	b580      	push	{r7, lr}
 80090ae:	b084      	sub	sp, #16
 80090b0:	af00      	add	r7, sp, #0
 80090b2:	60f8      	str	r0, [r7, #12]
 80090b4:	60b9      	str	r1, [r7, #8]
 80090b6:	607a      	str	r2, [r7, #4]
  /* address is actually being changed? */
  if (ip4_addr_cmp(netmask, netif_ip4_netmask(netif)) == 0) {
 80090b8:	68bb      	ldr	r3, [r7, #8]
 80090ba:	681a      	ldr	r2, [r3, #0]
 80090bc:	68fb      	ldr	r3, [r7, #12]
 80090be:	3308      	adds	r3, #8
 80090c0:	681b      	ldr	r3, [r3, #0]
 80090c2:	429a      	cmp	r2, r3
 80090c4:	d00a      	beq.n	80090dc <netif_do_set_netmask+0x30>
#else
    LWIP_UNUSED_ARG(old_nm);
#endif
    mib2_remove_route_ip4(0, netif);
    /* set new netmask to netif */
    ip4_addr_set(ip_2_ip4(&netif->netmask), netmask);
 80090c6:	68bb      	ldr	r3, [r7, #8]
 80090c8:	2b00      	cmp	r3, #0
 80090ca:	d002      	beq.n	80090d2 <netif_do_set_netmask+0x26>
 80090cc:	68bb      	ldr	r3, [r7, #8]
 80090ce:	681a      	ldr	r2, [r3, #0]
 80090d0:	e000      	b.n	80090d4 <netif_do_set_netmask+0x28>
 80090d2:	2200      	movs	r2, #0
 80090d4:	68fb      	ldr	r3, [r7, #12]
 80090d6:	609a      	str	r2, [r3, #8]
                netif->name[0], netif->name[1],
                ip4_addr1_16(netif_ip4_netmask(netif)),
                ip4_addr2_16(netif_ip4_netmask(netif)),
                ip4_addr3_16(netif_ip4_netmask(netif)),
                ip4_addr4_16(netif_ip4_netmask(netif))));
    return 1; /* netmask changed */
 80090d8:	2301      	movs	r3, #1
 80090da:	e000      	b.n	80090de <netif_do_set_netmask+0x32>
  }
  return 0; /* netmask unchanged */
 80090dc:	2300      	movs	r3, #0
}
 80090de:	0018      	movs	r0, r3
 80090e0:	46bd      	mov	sp, r7
 80090e2:	b004      	add	sp, #16
 80090e4:	bd80      	pop	{r7, pc}

080090e6 <netif_do_set_gw>:
  }
}

static int
netif_do_set_gw(struct netif *netif, const ip4_addr_t *gw, ip_addr_t *old_gw)
{
 80090e6:	b580      	push	{r7, lr}
 80090e8:	b084      	sub	sp, #16
 80090ea:	af00      	add	r7, sp, #0
 80090ec:	60f8      	str	r0, [r7, #12]
 80090ee:	60b9      	str	r1, [r7, #8]
 80090f0:	607a      	str	r2, [r7, #4]
  /* address is actually being changed? */
  if (ip4_addr_cmp(gw, netif_ip4_gw(netif)) == 0) {
 80090f2:	68bb      	ldr	r3, [r7, #8]
 80090f4:	681a      	ldr	r2, [r3, #0]
 80090f6:	68fb      	ldr	r3, [r7, #12]
 80090f8:	330c      	adds	r3, #12
 80090fa:	681b      	ldr	r3, [r3, #0]
 80090fc:	429a      	cmp	r2, r3
 80090fe:	d00a      	beq.n	8009116 <netif_do_set_gw+0x30>
    ip_addr_copy(*old_gw, *netif_ip_gw4(netif));
#else
    LWIP_UNUSED_ARG(old_gw);
#endif

    ip4_addr_set(ip_2_ip4(&netif->gw), gw);
 8009100:	68bb      	ldr	r3, [r7, #8]
 8009102:	2b00      	cmp	r3, #0
 8009104:	d002      	beq.n	800910c <netif_do_set_gw+0x26>
 8009106:	68bb      	ldr	r3, [r7, #8]
 8009108:	681a      	ldr	r2, [r3, #0]
 800910a:	e000      	b.n	800910e <netif_do_set_gw+0x28>
 800910c:	2200      	movs	r2, #0
 800910e:	68fb      	ldr	r3, [r7, #12]
 8009110:	60da      	str	r2, [r3, #12]
                netif->name[0], netif->name[1],
                ip4_addr1_16(netif_ip4_gw(netif)),
                ip4_addr2_16(netif_ip4_gw(netif)),
                ip4_addr3_16(netif_ip4_gw(netif)),
                ip4_addr4_16(netif_ip4_gw(netif))));
    return 1; /* gateway changed */
 8009112:	2301      	movs	r3, #1
 8009114:	e000      	b.n	8009118 <netif_do_set_gw+0x32>
  }
  return 0; /* gateway unchanged */
 8009116:	2300      	movs	r3, #0
}
 8009118:	0018      	movs	r0, r3
 800911a:	46bd      	mov	sp, r7
 800911c:	b004      	add	sp, #16
 800911e:	bd80      	pop	{r7, pc}

08009120 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, const ip4_addr_t *ipaddr, const ip4_addr_t *netmask,
               const ip4_addr_t *gw)
{
 8009120:	b580      	push	{r7, lr}
 8009122:	b088      	sub	sp, #32
 8009124:	af00      	add	r7, sp, #0
 8009126:	60f8      	str	r0, [r7, #12]
 8009128:	60b9      	str	r1, [r7, #8]
 800912a:	607a      	str	r2, [r7, #4]
 800912c:	603b      	str	r3, [r7, #0]
  ip_addr_t old_nm_val;
  ip_addr_t old_gw_val;
  ip_addr_t *old_nm = &old_nm_val;
  ip_addr_t *old_gw = &old_gw_val;
#else
  ip_addr_t *old_nm = NULL;
 800912e:	2300      	movs	r3, #0
 8009130:	61fb      	str	r3, [r7, #28]
  ip_addr_t *old_gw = NULL;
 8009132:	2300      	movs	r3, #0
 8009134:	61bb      	str	r3, [r7, #24]
  int remove;

  LWIP_ASSERT_CORE_LOCKED();

  /* Don't propagate NULL pointer (IPv4 ANY) to subsequent functions */
  if (ipaddr == NULL) {
 8009136:	68bb      	ldr	r3, [r7, #8]
 8009138:	2b00      	cmp	r3, #0
 800913a:	d101      	bne.n	8009140 <netif_set_addr+0x20>
    ipaddr = IP4_ADDR_ANY4;
 800913c:	4b1d      	ldr	r3, [pc, #116]	; (80091b4 <netif_set_addr+0x94>)
 800913e:	60bb      	str	r3, [r7, #8]
  }
  if (netmask == NULL) {
 8009140:	687b      	ldr	r3, [r7, #4]
 8009142:	2b00      	cmp	r3, #0
 8009144:	d101      	bne.n	800914a <netif_set_addr+0x2a>
    netmask = IP4_ADDR_ANY4;
 8009146:	4b1b      	ldr	r3, [pc, #108]	; (80091b4 <netif_set_addr+0x94>)
 8009148:	607b      	str	r3, [r7, #4]
  }
  if (gw == NULL) {
 800914a:	683b      	ldr	r3, [r7, #0]
 800914c:	2b00      	cmp	r3, #0
 800914e:	d101      	bne.n	8009154 <netif_set_addr+0x34>
    gw = IP4_ADDR_ANY4;
 8009150:	4b18      	ldr	r3, [pc, #96]	; (80091b4 <netif_set_addr+0x94>)
 8009152:	603b      	str	r3, [r7, #0]
  }

  remove = ip4_addr_isany(ipaddr);
 8009154:	68bb      	ldr	r3, [r7, #8]
 8009156:	2b00      	cmp	r3, #0
 8009158:	d003      	beq.n	8009162 <netif_set_addr+0x42>
 800915a:	68bb      	ldr	r3, [r7, #8]
 800915c:	681b      	ldr	r3, [r3, #0]
 800915e:	2b00      	cmp	r3, #0
 8009160:	d101      	bne.n	8009166 <netif_set_addr+0x46>
 8009162:	2301      	movs	r3, #1
 8009164:	e000      	b.n	8009168 <netif_set_addr+0x48>
 8009166:	2300      	movs	r3, #0
 8009168:	617b      	str	r3, [r7, #20]
  if (remove) {
 800916a:	697b      	ldr	r3, [r7, #20]
 800916c:	2b00      	cmp	r3, #0
 800916e:	d006      	beq.n	800917e <netif_set_addr+0x5e>
    /* when removing an address, we have to remove it *before* changing netmask/gw
       to ensure that tcp RST segment can be sent correctly */
    if (netif_do_set_ipaddr(netif, ipaddr, &old_addr)) {
 8009170:	2310      	movs	r3, #16
 8009172:	18fa      	adds	r2, r7, r3
 8009174:	68b9      	ldr	r1, [r7, #8]
 8009176:	68fb      	ldr	r3, [r7, #12]
 8009178:	0018      	movs	r0, r3
 800917a:	f7ff ff43 	bl	8009004 <netif_do_set_ipaddr>
      change_reason |= LWIP_NSC_IPV4_ADDRESS_CHANGED;
      cb_args.ipv4_changed.old_address = &old_addr;
#endif
    }
  }
  if (netif_do_set_netmask(netif, netmask, old_nm)) {
 800917e:	69fa      	ldr	r2, [r7, #28]
 8009180:	6879      	ldr	r1, [r7, #4]
 8009182:	68fb      	ldr	r3, [r7, #12]
 8009184:	0018      	movs	r0, r3
 8009186:	f7ff ff91 	bl	80090ac <netif_do_set_netmask>
#if LWIP_NETIF_EXT_STATUS_CALLBACK
    change_reason |= LWIP_NSC_IPV4_NETMASK_CHANGED;
    cb_args.ipv4_changed.old_netmask = old_nm;
#endif
  }
  if (netif_do_set_gw(netif, gw, old_gw)) {
 800918a:	69ba      	ldr	r2, [r7, #24]
 800918c:	6839      	ldr	r1, [r7, #0]
 800918e:	68fb      	ldr	r3, [r7, #12]
 8009190:	0018      	movs	r0, r3
 8009192:	f7ff ffa8 	bl	80090e6 <netif_do_set_gw>
#if LWIP_NETIF_EXT_STATUS_CALLBACK
    change_reason |= LWIP_NSC_IPV4_GATEWAY_CHANGED;
    cb_args.ipv4_changed.old_gw = old_gw;
#endif
  }
  if (!remove) {
 8009196:	697b      	ldr	r3, [r7, #20]
 8009198:	2b00      	cmp	r3, #0
 800919a:	d106      	bne.n	80091aa <netif_set_addr+0x8a>
    /* set ipaddr last to ensure netmask/gw have been set when status callback is called */
    if (netif_do_set_ipaddr(netif, ipaddr, &old_addr)) {
 800919c:	2310      	movs	r3, #16
 800919e:	18fa      	adds	r2, r7, r3
 80091a0:	68b9      	ldr	r1, [r7, #8]
 80091a2:	68fb      	ldr	r3, [r7, #12]
 80091a4:	0018      	movs	r0, r3
 80091a6:	f7ff ff2d 	bl	8009004 <netif_do_set_ipaddr>
  if (change_reason != LWIP_NSC_NONE) {
    change_reason |= LWIP_NSC_IPV4_SETTINGS_CHANGED;
    netif_invoke_ext_callback(netif, change_reason, &cb_args);
  }
#endif
}
 80091aa:	46c0      	nop			; (mov r8, r8)
 80091ac:	46bd      	mov	sp, r7
 80091ae:	b008      	add	sp, #32
 80091b0:	bd80      	pop	{r7, pc}
 80091b2:	46c0      	nop			; (mov r8, r8)
 80091b4:	0802246c 	.word	0x0802246c

080091b8 <netif_remove>:
 *
 * @param netif the network interface to remove
 */
void
netif_remove(struct netif *netif)
{
 80091b8:	b580      	push	{r7, lr}
 80091ba:	b084      	sub	sp, #16
 80091bc:	af00      	add	r7, sp, #0
 80091be:	6078      	str	r0, [r7, #4]
  int i;
#endif

  LWIP_ASSERT_CORE_LOCKED();

  if (netif == NULL) {
 80091c0:	687b      	ldr	r3, [r7, #4]
 80091c2:	2b00      	cmp	r3, #0
 80091c4:	d03e      	beq.n	8009244 <netif_remove+0x8c>
  }

  netif_invoke_ext_callback(netif, LWIP_NSC_NETIF_REMOVED, NULL);

#if LWIP_IPV4
  if (!ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 80091c6:	687b      	ldr	r3, [r7, #4]
 80091c8:	3304      	adds	r3, #4
 80091ca:	681b      	ldr	r3, [r3, #0]
 80091cc:	2b00      	cmp	r3, #0
 80091ce:	d005      	beq.n	80091dc <netif_remove+0x24>
    netif_do_ip_addr_changed(netif_ip_addr4(netif), NULL);
 80091d0:	687b      	ldr	r3, [r7, #4]
 80091d2:	3304      	adds	r3, #4
 80091d4:	2100      	movs	r1, #0
 80091d6:	0018      	movs	r0, r3
 80091d8:	f7ff fefe 	bl	8008fd8 <netif_do_ip_addr_changed>
#if LWIP_IPV6_MLD
  /* stop MLD processing */
  mld6_stop(netif);
#endif /* LWIP_IPV6_MLD */
#endif /* LWIP_IPV6 */
  if (netif_is_up(netif)) {
 80091dc:	687b      	ldr	r3, [r7, #4]
 80091de:	2231      	movs	r2, #49	; 0x31
 80091e0:	5c9b      	ldrb	r3, [r3, r2]
 80091e2:	1c1a      	adds	r2, r3, #0
 80091e4:	2301      	movs	r3, #1
 80091e6:	4013      	ands	r3, r2
 80091e8:	b2db      	uxtb	r3, r3
 80091ea:	2b00      	cmp	r3, #0
 80091ec:	d003      	beq.n	80091f6 <netif_remove+0x3e>
    /* set netif down before removing (call callback function) */
    netif_set_down(netif);
 80091ee:	687b      	ldr	r3, [r7, #4]
 80091f0:	0018      	movs	r0, r3
 80091f2:	f000 f867 	bl	80092c4 <netif_set_down>
  }

  mib2_remove_ip4(netif);

  /* this netif is default? */
  if (netif_default == netif) {
 80091f6:	4b15      	ldr	r3, [pc, #84]	; (800924c <netif_remove+0x94>)
 80091f8:	681b      	ldr	r3, [r3, #0]
 80091fa:	687a      	ldr	r2, [r7, #4]
 80091fc:	429a      	cmp	r2, r3
 80091fe:	d102      	bne.n	8009206 <netif_remove+0x4e>
    /* reset default netif */
    netif_set_default(NULL);
 8009200:	2000      	movs	r0, #0
 8009202:	f000 f827 	bl	8009254 <netif_set_default>
  }
#if !LWIP_SINGLE_NETIF
  /*  is it the first netif? */
  if (netif_list == netif) {
 8009206:	4b12      	ldr	r3, [pc, #72]	; (8009250 <netif_remove+0x98>)
 8009208:	681b      	ldr	r3, [r3, #0]
 800920a:	687a      	ldr	r2, [r7, #4]
 800920c:	429a      	cmp	r2, r3
 800920e:	d104      	bne.n	800921a <netif_remove+0x62>
    netif_list = netif->next;
 8009210:	687b      	ldr	r3, [r7, #4]
 8009212:	681a      	ldr	r2, [r3, #0]
 8009214:	4b0e      	ldr	r3, [pc, #56]	; (8009250 <netif_remove+0x98>)
 8009216:	601a      	str	r2, [r3, #0]
 8009218:	e015      	b.n	8009246 <netif_remove+0x8e>
  } else {
    /*  look for netif further down the list */
    struct netif *tmp_netif;
    NETIF_FOREACH(tmp_netif) {
 800921a:	4b0d      	ldr	r3, [pc, #52]	; (8009250 <netif_remove+0x98>)
 800921c:	681b      	ldr	r3, [r3, #0]
 800921e:	60fb      	str	r3, [r7, #12]
 8009220:	e00c      	b.n	800923c <netif_remove+0x84>
      if (tmp_netif->next == netif) {
 8009222:	68fb      	ldr	r3, [r7, #12]
 8009224:	681b      	ldr	r3, [r3, #0]
 8009226:	687a      	ldr	r2, [r7, #4]
 8009228:	429a      	cmp	r2, r3
 800922a:	d104      	bne.n	8009236 <netif_remove+0x7e>
        tmp_netif->next = netif->next;
 800922c:	687b      	ldr	r3, [r7, #4]
 800922e:	681a      	ldr	r2, [r3, #0]
 8009230:	68fb      	ldr	r3, [r7, #12]
 8009232:	601a      	str	r2, [r3, #0]
        break;
 8009234:	e007      	b.n	8009246 <netif_remove+0x8e>
    NETIF_FOREACH(tmp_netif) {
 8009236:	68fb      	ldr	r3, [r7, #12]
 8009238:	681b      	ldr	r3, [r3, #0]
 800923a:	60fb      	str	r3, [r7, #12]
 800923c:	68fb      	ldr	r3, [r7, #12]
 800923e:	2b00      	cmp	r3, #0
 8009240:	d1ef      	bne.n	8009222 <netif_remove+0x6a>
 8009242:	e000      	b.n	8009246 <netif_remove+0x8e>
    return;
 8009244:	46c0      	nop			; (mov r8, r8)
  if (netif->remove_callback) {
    netif->remove_callback(netif);
  }
#endif /* LWIP_NETIF_REMOVE_CALLBACK */
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
 8009246:	46bd      	mov	sp, r7
 8009248:	b004      	add	sp, #16
 800924a:	bd80      	pop	{r7, pc}
 800924c:	20002ec8 	.word	0x20002ec8
 8009250:	20002ec4 	.word	0x20002ec4

08009254 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
 8009254:	b580      	push	{r7, lr}
 8009256:	b082      	sub	sp, #8
 8009258:	af00      	add	r7, sp, #0
 800925a:	6078      	str	r0, [r7, #4]
    mib2_remove_route_ip4(1, netif);
  } else {
    /* install default route */
    mib2_add_route_ip4(1, netif);
  }
  netif_default = netif;
 800925c:	4b03      	ldr	r3, [pc, #12]	; (800926c <netif_set_default+0x18>)
 800925e:	687a      	ldr	r2, [r7, #4]
 8009260:	601a      	str	r2, [r3, #0]
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
                            netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
 8009262:	46c0      	nop			; (mov r8, r8)
 8009264:	46bd      	mov	sp, r7
 8009266:	b002      	add	sp, #8
 8009268:	bd80      	pop	{r7, pc}
 800926a:	46c0      	nop			; (mov r8, r8)
 800926c:	20002ec8 	.word	0x20002ec8

08009270 <netif_issue_reports>:

/** Send ARP/IGMP/MLD/RS events, e.g. on link-up/netif-up or addr-change
 */
static void
netif_issue_reports(struct netif *netif, u8_t report_type)
{
 8009270:	b580      	push	{r7, lr}
 8009272:	b082      	sub	sp, #8
 8009274:	af00      	add	r7, sp, #0
 8009276:	6078      	str	r0, [r7, #4]
 8009278:	000a      	movs	r2, r1
 800927a:	1cfb      	adds	r3, r7, #3
 800927c:	701a      	strb	r2, [r3, #0]
  LWIP_ASSERT("netif_issue_reports: invalid netif", netif != NULL);
 800927e:	687b      	ldr	r3, [r7, #4]
 8009280:	2b00      	cmp	r3, #0
 8009282:	d106      	bne.n	8009292 <netif_issue_reports+0x22>
 8009284:	4b0c      	ldr	r3, [pc, #48]	; (80092b8 <netif_issue_reports+0x48>)
 8009286:	22dc      	movs	r2, #220	; 0xdc
 8009288:	0092      	lsls	r2, r2, #2
 800928a:	490c      	ldr	r1, [pc, #48]	; (80092bc <netif_issue_reports+0x4c>)
 800928c:	480c      	ldr	r0, [pc, #48]	; (80092c0 <netif_issue_reports+0x50>)
 800928e:	f7f9 fb25 	bl	80028dc <app_debug_rtt_raw>

  /* Only send reports when both link and admin states are up */
  if (!(netif->flags & NETIF_FLAG_LINK_UP) ||
 8009292:	687b      	ldr	r3, [r7, #4]
 8009294:	2231      	movs	r2, #49	; 0x31
 8009296:	5c9b      	ldrb	r3, [r3, r2]
 8009298:	001a      	movs	r2, r3
 800929a:	2304      	movs	r3, #4
 800929c:	4013      	ands	r3, r2
 800929e:	d007      	beq.n	80092b0 <netif_issue_reports+0x40>
      !(netif->flags & NETIF_FLAG_UP)) {
 80092a0:	687b      	ldr	r3, [r7, #4]
 80092a2:	2231      	movs	r2, #49	; 0x31
 80092a4:	5c9b      	ldrb	r3, [r3, r2]
 80092a6:	001a      	movs	r2, r3
 80092a8:	2301      	movs	r3, #1
 80092aa:	4013      	ands	r3, r2
  if (!(netif->flags & NETIF_FLAG_LINK_UP) ||
 80092ac:	d000      	beq.n	80092b0 <netif_issue_reports+0x40>
 80092ae:	e000      	b.n	80092b2 <netif_issue_reports+0x42>
    return;
 80092b0:	46c0      	nop			; (mov r8, r8)
    /* send mld memberships */
    mld6_report_groups(netif);
#endif /* LWIP_IPV6_MLD */
  }
#endif /* LWIP_IPV6 */
}
 80092b2:	46bd      	mov	sp, r7
 80092b4:	b002      	add	sp, #8
 80092b6:	bd80      	pop	{r7, pc}
 80092b8:	0801f2c0 	.word	0x0801f2c0
 80092bc:	0801f45c 	.word	0x0801f45c
 80092c0:	0801f304 	.word	0x0801f304

080092c4 <netif_set_down>:
 * @ingroup netif
 * Bring an interface down, disabling any traffic processing.
 */
void
netif_set_down(struct netif *netif)
{
 80092c4:	b580      	push	{r7, lr}
 80092c6:	b082      	sub	sp, #8
 80092c8:	af00      	add	r7, sp, #0
 80092ca:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif_set_down: invalid netif", netif != NULL, return);
 80092cc:	687b      	ldr	r3, [r7, #4]
 80092ce:	2b00      	cmp	r3, #0
 80092d0:	d104      	bne.n	80092dc <netif_set_down+0x18>
 80092d2:	4b10      	ldr	r3, [pc, #64]	; (8009314 <netif_set_down+0x50>)
 80092d4:	0018      	movs	r0, r3
 80092d6:	f7f9 fb01 	bl	80028dc <app_debug_rtt_raw>
 80092da:	e018      	b.n	800930e <netif_set_down+0x4a>

  if (netif->flags & NETIF_FLAG_UP) {
 80092dc:	687b      	ldr	r3, [r7, #4]
 80092de:	2231      	movs	r2, #49	; 0x31
 80092e0:	5c9b      	ldrb	r3, [r3, r2]
 80092e2:	001a      	movs	r2, r3
 80092e4:	2301      	movs	r3, #1
 80092e6:	4013      	ands	r3, r2
 80092e8:	d011      	beq.n	800930e <netif_set_down+0x4a>
      args.status_changed.state = 0;
      netif_invoke_ext_callback(netif, LWIP_NSC_STATUS_CHANGED, &args);
    }
#endif

    netif_clear_flags(netif, NETIF_FLAG_UP);
 80092ea:	687b      	ldr	r3, [r7, #4]
 80092ec:	2231      	movs	r2, #49	; 0x31
 80092ee:	5c9b      	ldrb	r3, [r3, r2]
 80092f0:	2201      	movs	r2, #1
 80092f2:	4393      	bics	r3, r2
 80092f4:	b2d9      	uxtb	r1, r3
 80092f6:	687b      	ldr	r3, [r7, #4]
 80092f8:	2231      	movs	r2, #49	; 0x31
 80092fa:	5499      	strb	r1, [r3, r2]

#if LWIP_IPV6
    nd6_cleanup_netif(netif);
#endif /* LWIP_IPV6 */

    NETIF_STATUS_CALLBACK(netif);
 80092fc:	687b      	ldr	r3, [r7, #4]
 80092fe:	69db      	ldr	r3, [r3, #28]
 8009300:	2b00      	cmp	r3, #0
 8009302:	d004      	beq.n	800930e <netif_set_down+0x4a>
 8009304:	687b      	ldr	r3, [r7, #4]
 8009306:	69db      	ldr	r3, [r3, #28]
 8009308:	687a      	ldr	r2, [r7, #4]
 800930a:	0010      	movs	r0, r2
 800930c:	4798      	blx	r3
  }
}
 800930e:	46bd      	mov	sp, r7
 8009310:	b002      	add	sp, #8
 8009312:	bd80      	pop	{r7, pc}
 8009314:	0801f480 	.word	0x0801f480

08009318 <netif_set_link_up>:
 * @ingroup netif
 * Called by a driver when its link goes up
 */
void
netif_set_link_up(struct netif *netif)
{
 8009318:	b580      	push	{r7, lr}
 800931a:	b082      	sub	sp, #8
 800931c:	af00      	add	r7, sp, #0
 800931e:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif_set_link_up: invalid netif", netif != NULL, return);
 8009320:	687b      	ldr	r3, [r7, #4]
 8009322:	2b00      	cmp	r3, #0
 8009324:	d104      	bne.n	8009330 <netif_set_link_up+0x18>
 8009326:	4b13      	ldr	r3, [pc, #76]	; (8009374 <netif_set_link_up+0x5c>)
 8009328:	0018      	movs	r0, r3
 800932a:	f7f9 fad7 	bl	80028dc <app_debug_rtt_raw>
 800932e:	e01d      	b.n	800936c <netif_set_link_up+0x54>

  if (!(netif->flags & NETIF_FLAG_LINK_UP)) {
 8009330:	687b      	ldr	r3, [r7, #4]
 8009332:	2231      	movs	r2, #49	; 0x31
 8009334:	5c9b      	ldrb	r3, [r3, r2]
 8009336:	001a      	movs	r2, r3
 8009338:	2304      	movs	r3, #4
 800933a:	4013      	ands	r3, r2
 800933c:	d116      	bne.n	800936c <netif_set_link_up+0x54>
    netif_set_flags(netif, NETIF_FLAG_LINK_UP);
 800933e:	687b      	ldr	r3, [r7, #4]
 8009340:	2231      	movs	r2, #49	; 0x31
 8009342:	5c9b      	ldrb	r3, [r3, r2]
 8009344:	2204      	movs	r2, #4
 8009346:	4313      	orrs	r3, r2
 8009348:	b2d9      	uxtb	r1, r3
 800934a:	687b      	ldr	r3, [r7, #4]
 800934c:	2231      	movs	r2, #49	; 0x31
 800934e:	5499      	strb	r1, [r3, r2]

#if LWIP_AUTOIP
    autoip_network_changed(netif);
#endif /* LWIP_AUTOIP */

    netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4 | NETIF_REPORT_TYPE_IPV6);
 8009350:	687b      	ldr	r3, [r7, #4]
 8009352:	2103      	movs	r1, #3
 8009354:	0018      	movs	r0, r3
 8009356:	f7ff ff8b 	bl	8009270 <netif_issue_reports>
#if LWIP_IPV6
    nd6_restart_netif(netif);
#endif /* LWIP_IPV6 */

    NETIF_LINK_CALLBACK(netif);
 800935a:	687b      	ldr	r3, [r7, #4]
 800935c:	6a1b      	ldr	r3, [r3, #32]
 800935e:	2b00      	cmp	r3, #0
 8009360:	d004      	beq.n	800936c <netif_set_link_up+0x54>
 8009362:	687b      	ldr	r3, [r7, #4]
 8009364:	6a1b      	ldr	r3, [r3, #32]
 8009366:	687a      	ldr	r2, [r7, #4]
 8009368:	0010      	movs	r0, r2
 800936a:	4798      	blx	r3
      args.link_changed.state = 1;
      netif_invoke_ext_callback(netif, LWIP_NSC_LINK_CHANGED, &args);
    }
#endif
  }
}
 800936c:	46bd      	mov	sp, r7
 800936e:	b002      	add	sp, #8
 8009370:	bd80      	pop	{r7, pc}
 8009372:	46c0      	nop			; (mov r8, r8)
 8009374:	0801f4a0 	.word	0x0801f4a0

08009378 <netif_set_link_down>:
 * @ingroup netif
 * Called by a driver when its link goes down
 */
void
netif_set_link_down(struct netif *netif)
{
 8009378:	b580      	push	{r7, lr}
 800937a:	b082      	sub	sp, #8
 800937c:	af00      	add	r7, sp, #0
 800937e:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif_set_link_down: invalid netif", netif != NULL, return);
 8009380:	687b      	ldr	r3, [r7, #4]
 8009382:	2b00      	cmp	r3, #0
 8009384:	d104      	bne.n	8009390 <netif_set_link_down+0x18>
 8009386:	4b10      	ldr	r3, [pc, #64]	; (80093c8 <netif_set_link_down+0x50>)
 8009388:	0018      	movs	r0, r3
 800938a:	f7f9 faa7 	bl	80028dc <app_debug_rtt_raw>
 800938e:	e018      	b.n	80093c2 <netif_set_link_down+0x4a>

  if (netif->flags & NETIF_FLAG_LINK_UP) {
 8009390:	687b      	ldr	r3, [r7, #4]
 8009392:	2231      	movs	r2, #49	; 0x31
 8009394:	5c9b      	ldrb	r3, [r3, r2]
 8009396:	001a      	movs	r2, r3
 8009398:	2304      	movs	r3, #4
 800939a:	4013      	ands	r3, r2
 800939c:	d011      	beq.n	80093c2 <netif_set_link_down+0x4a>
    netif_clear_flags(netif, NETIF_FLAG_LINK_UP);
 800939e:	687b      	ldr	r3, [r7, #4]
 80093a0:	2231      	movs	r2, #49	; 0x31
 80093a2:	5c9b      	ldrb	r3, [r3, r2]
 80093a4:	2204      	movs	r2, #4
 80093a6:	4393      	bics	r3, r2
 80093a8:	b2d9      	uxtb	r1, r3
 80093aa:	687b      	ldr	r3, [r7, #4]
 80093ac:	2231      	movs	r2, #49	; 0x31
 80093ae:	5499      	strb	r1, [r3, r2]
#if LWIP_IPV6 && LWIP_ND6_ALLOW_RA_UPDATES
    netif->mtu6 = netif->mtu;
#endif

    NETIF_LINK_CALLBACK(netif);
 80093b0:	687b      	ldr	r3, [r7, #4]
 80093b2:	6a1b      	ldr	r3, [r3, #32]
 80093b4:	2b00      	cmp	r3, #0
 80093b6:	d004      	beq.n	80093c2 <netif_set_link_down+0x4a>
 80093b8:	687b      	ldr	r3, [r7, #4]
 80093ba:	6a1b      	ldr	r3, [r3, #32]
 80093bc:	687a      	ldr	r2, [r7, #4]
 80093be:	0010      	movs	r0, r2
 80093c0:	4798      	blx	r3
      args.link_changed.state = 0;
      netif_invoke_ext_callback(netif, LWIP_NSC_LINK_CHANGED, &args);
    }
#endif
  }
}
 80093c2:	46bd      	mov	sp, r7
 80093c4:	b002      	add	sp, #8
 80093c6:	bd80      	pop	{r7, pc}
 80093c8:	0801f4c4 	.word	0x0801f4c4

080093cc <netif_null_output_ip4>:
#if LWIP_IPV4
/** Dummy IPv4 output function for netifs not supporting IPv4
 */
static err_t
netif_null_output_ip4(struct netif *netif, struct pbuf *p, const ip4_addr_t *ipaddr)
{
 80093cc:	b580      	push	{r7, lr}
 80093ce:	b084      	sub	sp, #16
 80093d0:	af00      	add	r7, sp, #0
 80093d2:	60f8      	str	r0, [r7, #12]
 80093d4:	60b9      	str	r1, [r7, #8]
 80093d6:	607a      	str	r2, [r7, #4]
  LWIP_UNUSED_ARG(netif);
  LWIP_UNUSED_ARG(p);
  LWIP_UNUSED_ARG(ipaddr);

  return ERR_IF;
 80093d8:	230c      	movs	r3, #12
 80093da:	425b      	negs	r3, r3
}
 80093dc:	0018      	movs	r0, r3
 80093de:	46bd      	mov	sp, r7
 80093e0:	b004      	add	sp, #16
 80093e2:	bd80      	pop	{r7, pc}

080093e4 <netif_get_by_index>:
*
* @param idx index of netif to find
*/
struct netif *
netif_get_by_index(u8_t idx)
{
 80093e4:	b580      	push	{r7, lr}
 80093e6:	b084      	sub	sp, #16
 80093e8:	af00      	add	r7, sp, #0
 80093ea:	0002      	movs	r2, r0
 80093ec:	1dfb      	adds	r3, r7, #7
 80093ee:	701a      	strb	r2, [r3, #0]
  struct netif *netif;

  LWIP_ASSERT_CORE_LOCKED();

  if (idx != NETIF_NO_INDEX) {
 80093f0:	1dfb      	adds	r3, r7, #7
 80093f2:	781b      	ldrb	r3, [r3, #0]
 80093f4:	2b00      	cmp	r3, #0
 80093f6:	d014      	beq.n	8009422 <netif_get_by_index+0x3e>
    NETIF_FOREACH(netif) {
 80093f8:	4b0c      	ldr	r3, [pc, #48]	; (800942c <netif_get_by_index+0x48>)
 80093fa:	681b      	ldr	r3, [r3, #0]
 80093fc:	60fb      	str	r3, [r7, #12]
 80093fe:	e00d      	b.n	800941c <netif_get_by_index+0x38>
      if (idx == netif_get_index(netif)) {
 8009400:	68fb      	ldr	r3, [r7, #12]
 8009402:	2234      	movs	r2, #52	; 0x34
 8009404:	5c9b      	ldrb	r3, [r3, r2]
 8009406:	3301      	adds	r3, #1
 8009408:	b2db      	uxtb	r3, r3
 800940a:	1dfa      	adds	r2, r7, #7
 800940c:	7812      	ldrb	r2, [r2, #0]
 800940e:	429a      	cmp	r2, r3
 8009410:	d101      	bne.n	8009416 <netif_get_by_index+0x32>
        return netif; /* found! */
 8009412:	68fb      	ldr	r3, [r7, #12]
 8009414:	e006      	b.n	8009424 <netif_get_by_index+0x40>
    NETIF_FOREACH(netif) {
 8009416:	68fb      	ldr	r3, [r7, #12]
 8009418:	681b      	ldr	r3, [r3, #0]
 800941a:	60fb      	str	r3, [r7, #12]
 800941c:	68fb      	ldr	r3, [r7, #12]
 800941e:	2b00      	cmp	r3, #0
 8009420:	d1ee      	bne.n	8009400 <netif_get_by_index+0x1c>
      }
    }
  }

  return NULL;
 8009422:	2300      	movs	r3, #0
}
 8009424:	0018      	movs	r0, r3
 8009426:	46bd      	mov	sp, r7
 8009428:	b004      	add	sp, #16
 800942a:	bd80      	pop	{r7, pc}
 800942c:	20002ec4 	.word	0x20002ec4

08009430 <pbuf_free_ooseq>:
#if !NO_SYS
static
#endif /* !NO_SYS */
void
pbuf_free_ooseq(void)
{
 8009430:	b580      	push	{r7, lr}
 8009432:	b082      	sub	sp, #8
 8009434:	af00      	add	r7, sp, #0
  struct tcp_pcb *pcb;
  SYS_ARCH_SET(pbuf_free_ooseq_pending, 0);
 8009436:	4b0c      	ldr	r3, [pc, #48]	; (8009468 <pbuf_free_ooseq+0x38>)
 8009438:	2200      	movs	r2, #0
 800943a:	701a      	strb	r2, [r3, #0]

  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
 800943c:	4b0b      	ldr	r3, [pc, #44]	; (800946c <pbuf_free_ooseq+0x3c>)
 800943e:	681b      	ldr	r3, [r3, #0]
 8009440:	607b      	str	r3, [r7, #4]
 8009442:	e00b      	b.n	800945c <pbuf_free_ooseq+0x2c>
    if (pcb->ooseq != NULL) {
 8009444:	687b      	ldr	r3, [r7, #4]
 8009446:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8009448:	2b00      	cmp	r3, #0
 800944a:	d004      	beq.n	8009456 <pbuf_free_ooseq+0x26>
      /** Free the ooseq pbufs of one PCB only */
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free_ooseq: freeing out-of-sequence pbufs\n"));
      tcp_free_ooseq(pcb);
 800944c:	687b      	ldr	r3, [r7, #4]
 800944e:	0018      	movs	r0, r3
 8009450:	f003 f8c2 	bl	800c5d8 <tcp_free_ooseq>
      return;
 8009454:	e005      	b.n	8009462 <pbuf_free_ooseq+0x32>
  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
 8009456:	687b      	ldr	r3, [r7, #4]
 8009458:	691b      	ldr	r3, [r3, #16]
 800945a:	607b      	str	r3, [r7, #4]
 800945c:	687b      	ldr	r3, [r7, #4]
 800945e:	2b00      	cmp	r3, #0
 8009460:	d1f0      	bne.n	8009444 <pbuf_free_ooseq+0x14>
    }
  }
}
 8009462:	46bd      	mov	sp, r7
 8009464:	b002      	add	sp, #8
 8009466:	bd80      	pop	{r7, pc}
 8009468:	20002ecc 	.word	0x20002ecc
 800946c:	20002ed4 	.word	0x20002ed4

08009470 <pbuf_pool_is_empty>:
#endif /* !NO_SYS */

/** Queue a call to pbuf_free_ooseq if not already queued. */
static void
pbuf_pool_is_empty(void)
{
 8009470:	b580      	push	{r7, lr}
 8009472:	af00      	add	r7, sp, #0
#ifndef PBUF_POOL_FREE_OOSEQ_QUEUE_CALL
  SYS_ARCH_SET(pbuf_free_ooseq_pending, 1);
 8009474:	4b02      	ldr	r3, [pc, #8]	; (8009480 <pbuf_pool_is_empty+0x10>)
 8009476:	2201      	movs	r2, #1
 8009478:	701a      	strb	r2, [r3, #0]
  if (!queued) {
    /* queue a call to pbuf_free_ooseq if not already queued */
    PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
  }
#endif /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
}
 800947a:	46c0      	nop			; (mov r8, r8)
 800947c:	46bd      	mov	sp, r7
 800947e:	bd80      	pop	{r7, pc}
 8009480:	20002ecc 	.word	0x20002ecc

08009484 <pbuf_init_alloced_pbuf>:
#endif /* !LWIP_TCP || !TCP_QUEUE_OOSEQ || !PBUF_POOL_FREE_OOSEQ */

/* Initialize members of struct pbuf after allocation */
static void
pbuf_init_alloced_pbuf(struct pbuf *p, void *payload, u16_t tot_len, u16_t len, pbuf_type type, u8_t flags)
{
 8009484:	b580      	push	{r7, lr}
 8009486:	b084      	sub	sp, #16
 8009488:	af00      	add	r7, sp, #0
 800948a:	60f8      	str	r0, [r7, #12]
 800948c:	60b9      	str	r1, [r7, #8]
 800948e:	0019      	movs	r1, r3
 8009490:	1dbb      	adds	r3, r7, #6
 8009492:	801a      	strh	r2, [r3, #0]
 8009494:	1d3b      	adds	r3, r7, #4
 8009496:	1c0a      	adds	r2, r1, #0
 8009498:	801a      	strh	r2, [r3, #0]
  p->next = NULL;
 800949a:	68fb      	ldr	r3, [r7, #12]
 800949c:	2200      	movs	r2, #0
 800949e:	601a      	str	r2, [r3, #0]
  p->payload = payload;
 80094a0:	68fb      	ldr	r3, [r7, #12]
 80094a2:	68ba      	ldr	r2, [r7, #8]
 80094a4:	605a      	str	r2, [r3, #4]
  p->tot_len = tot_len;
 80094a6:	68fb      	ldr	r3, [r7, #12]
 80094a8:	1dba      	adds	r2, r7, #6
 80094aa:	8812      	ldrh	r2, [r2, #0]
 80094ac:	811a      	strh	r2, [r3, #8]
  p->len = len;
 80094ae:	68fb      	ldr	r3, [r7, #12]
 80094b0:	1d3a      	adds	r2, r7, #4
 80094b2:	8812      	ldrh	r2, [r2, #0]
 80094b4:	815a      	strh	r2, [r3, #10]
  p->type_internal = (u8_t)type;
 80094b6:	2318      	movs	r3, #24
 80094b8:	18fb      	adds	r3, r7, r3
 80094ba:	881b      	ldrh	r3, [r3, #0]
 80094bc:	b2da      	uxtb	r2, r3
 80094be:	68fb      	ldr	r3, [r7, #12]
 80094c0:	731a      	strb	r2, [r3, #12]
  p->flags = flags;
 80094c2:	68fb      	ldr	r3, [r7, #12]
 80094c4:	221c      	movs	r2, #28
 80094c6:	18ba      	adds	r2, r7, r2
 80094c8:	7812      	ldrb	r2, [r2, #0]
 80094ca:	735a      	strb	r2, [r3, #13]
  p->ref = 1;
 80094cc:	68fb      	ldr	r3, [r7, #12]
 80094ce:	2201      	movs	r2, #1
 80094d0:	739a      	strb	r2, [r3, #14]
  p->if_idx = NETIF_NO_INDEX;
 80094d2:	68fb      	ldr	r3, [r7, #12]
 80094d4:	2200      	movs	r2, #0
 80094d6:	73da      	strb	r2, [r3, #15]
}
 80094d8:	46c0      	nop			; (mov r8, r8)
 80094da:	46bd      	mov	sp, r7
 80094dc:	b004      	add	sp, #16
 80094de:	bd80      	pop	{r7, pc}

080094e0 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
 80094e0:	b590      	push	{r4, r7, lr}
 80094e2:	b08d      	sub	sp, #52	; 0x34
 80094e4:	af02      	add	r7, sp, #8
 80094e6:	0004      	movs	r4, r0
 80094e8:	0008      	movs	r0, r1
 80094ea:	0011      	movs	r1, r2
 80094ec:	1dfb      	adds	r3, r7, #7
 80094ee:	1c22      	adds	r2, r4, #0
 80094f0:	701a      	strb	r2, [r3, #0]
 80094f2:	1d3b      	adds	r3, r7, #4
 80094f4:	1c02      	adds	r2, r0, #0
 80094f6:	801a      	strh	r2, [r3, #0]
 80094f8:	1cbb      	adds	r3, r7, #2
 80094fa:	1c0a      	adds	r2, r1, #0
 80094fc:	801a      	strh	r2, [r3, #0]
  struct pbuf *p;
  u16_t offset = (u16_t)layer;
 80094fe:	2322      	movs	r3, #34	; 0x22
 8009500:	18fb      	adds	r3, r7, r3
 8009502:	1dfa      	adds	r2, r7, #7
 8009504:	7812      	ldrb	r2, [r2, #0]
 8009506:	801a      	strh	r2, [r3, #0]
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));

  switch (type) {
 8009508:	1cbb      	adds	r3, r7, #2
 800950a:	881b      	ldrh	r3, [r3, #0]
 800950c:	22a0      	movs	r2, #160	; 0xa0
 800950e:	0092      	lsls	r2, r2, #2
 8009510:	4293      	cmp	r3, r2
 8009512:	d100      	bne.n	8009516 <pbuf_alloc+0x36>
 8009514:	e0a8      	b.n	8009668 <pbuf_alloc+0x188>
 8009516:	22a0      	movs	r2, #160	; 0xa0
 8009518:	0092      	lsls	r2, r2, #2
 800951a:	4293      	cmp	r3, r2
 800951c:	dd00      	ble.n	8009520 <pbuf_alloc+0x40>
 800951e:	e103      	b.n	8009728 <pbuf_alloc+0x248>
 8009520:	22c1      	movs	r2, #193	; 0xc1
 8009522:	0052      	lsls	r2, r2, #1
 8009524:	4293      	cmp	r3, r2
 8009526:	d014      	beq.n	8009552 <pbuf_alloc+0x72>
 8009528:	22c1      	movs	r2, #193	; 0xc1
 800952a:	0052      	lsls	r2, r2, #1
 800952c:	4293      	cmp	r3, r2
 800952e:	dd00      	ble.n	8009532 <pbuf_alloc+0x52>
 8009530:	e0fa      	b.n	8009728 <pbuf_alloc+0x248>
 8009532:	2b01      	cmp	r3, #1
 8009534:	d002      	beq.n	800953c <pbuf_alloc+0x5c>
 8009536:	2b41      	cmp	r3, #65	; 0x41
 8009538:	d000      	beq.n	800953c <pbuf_alloc+0x5c>
 800953a:	e0f5      	b.n	8009728 <pbuf_alloc+0x248>
    case PBUF_REF: /* fall through */
    case PBUF_ROM:
      p = pbuf_alloc_reference(NULL, length, type);
 800953c:	1cbb      	adds	r3, r7, #2
 800953e:	881a      	ldrh	r2, [r3, #0]
 8009540:	1d3b      	adds	r3, r7, #4
 8009542:	881b      	ldrh	r3, [r3, #0]
 8009544:	0019      	movs	r1, r3
 8009546:	2000      	movs	r0, #0
 8009548:	f000 f90a 	bl	8009760 <pbuf_alloc_reference>
 800954c:	0003      	movs	r3, r0
 800954e:	627b      	str	r3, [r7, #36]	; 0x24
      break;
 8009550:	e0f4      	b.n	800973c <pbuf_alloc+0x25c>
    case PBUF_POOL: {
      struct pbuf *q, *last;
      u16_t rem_len; /* remaining length */
      p = NULL;
 8009552:	2300      	movs	r3, #0
 8009554:	627b      	str	r3, [r7, #36]	; 0x24
      last = NULL;
 8009556:	2300      	movs	r3, #0
 8009558:	61fb      	str	r3, [r7, #28]
      rem_len = length;
 800955a:	231a      	movs	r3, #26
 800955c:	18fb      	adds	r3, r7, r3
 800955e:	1d3a      	adds	r2, r7, #4
 8009560:	8812      	ldrh	r2, [r2, #0]
 8009562:	801a      	strh	r2, [r3, #0]
      do {
        u16_t qlen;
        q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 8009564:	2006      	movs	r0, #6
 8009566:	f7ff fbd3 	bl	8008d10 <memp_malloc>
 800956a:	0003      	movs	r3, r0
 800956c:	613b      	str	r3, [r7, #16]
        if (q == NULL) {
 800956e:	693b      	ldr	r3, [r7, #16]
 8009570:	2b00      	cmp	r3, #0
 8009572:	d10a      	bne.n	800958a <pbuf_alloc+0xaa>
          PBUF_POOL_IS_EMPTY();
 8009574:	f7ff ff7c 	bl	8009470 <pbuf_pool_is_empty>
          /* free chain so far allocated */
          if (p) {
 8009578:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800957a:	2b00      	cmp	r3, #0
 800957c:	d003      	beq.n	8009586 <pbuf_alloc+0xa6>
            pbuf_free(p);
 800957e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009580:	0018      	movs	r0, r3
 8009582:	f000 fb25 	bl	8009bd0 <pbuf_free>
          }
          /* bail out unsuccessfully */
          return NULL;
 8009586:	2300      	movs	r3, #0
 8009588:	e0d9      	b.n	800973e <pbuf_alloc+0x25e>
        }
        qlen = LWIP_MIN(rem_len, (u16_t)(PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)));
 800958a:	2322      	movs	r3, #34	; 0x22
 800958c:	18fb      	adds	r3, r7, r3
 800958e:	881b      	ldrh	r3, [r3, #0]
 8009590:	3303      	adds	r3, #3
 8009592:	b29b      	uxth	r3, r3
 8009594:	2203      	movs	r2, #3
 8009596:	4393      	bics	r3, r2
 8009598:	b29b      	uxth	r3, r3
 800959a:	2294      	movs	r2, #148	; 0x94
 800959c:	0092      	lsls	r2, r2, #2
 800959e:	1ad3      	subs	r3, r2, r3
 80095a0:	b299      	uxth	r1, r3
 80095a2:	230e      	movs	r3, #14
 80095a4:	18fa      	adds	r2, r7, r3
 80095a6:	231a      	movs	r3, #26
 80095a8:	18fb      	adds	r3, r7, r3
 80095aa:	1c0c      	adds	r4, r1, #0
 80095ac:	881b      	ldrh	r3, [r3, #0]
 80095ae:	b298      	uxth	r0, r3
 80095b0:	b2a1      	uxth	r1, r4
 80095b2:	4288      	cmp	r0, r1
 80095b4:	d900      	bls.n	80095b8 <pbuf_alloc+0xd8>
 80095b6:	1c23      	adds	r3, r4, #0
 80095b8:	8013      	strh	r3, [r2, #0]
        pbuf_init_alloced_pbuf(q, LWIP_MEM_ALIGN((void *)((u8_t *)q + SIZEOF_STRUCT_PBUF + offset)),
 80095ba:	2322      	movs	r3, #34	; 0x22
 80095bc:	18fb      	adds	r3, r7, r3
 80095be:	881b      	ldrh	r3, [r3, #0]
 80095c0:	3310      	adds	r3, #16
 80095c2:	693a      	ldr	r2, [r7, #16]
 80095c4:	18d3      	adds	r3, r2, r3
 80095c6:	3303      	adds	r3, #3
 80095c8:	2203      	movs	r2, #3
 80095ca:	4393      	bics	r3, r2
 80095cc:	001c      	movs	r4, r3
 80095ce:	230e      	movs	r3, #14
 80095d0:	18fb      	adds	r3, r7, r3
 80095d2:	8819      	ldrh	r1, [r3, #0]
 80095d4:	231a      	movs	r3, #26
 80095d6:	18fb      	adds	r3, r7, r3
 80095d8:	881a      	ldrh	r2, [r3, #0]
 80095da:	6938      	ldr	r0, [r7, #16]
 80095dc:	2300      	movs	r3, #0
 80095de:	9301      	str	r3, [sp, #4]
 80095e0:	1cbb      	adds	r3, r7, #2
 80095e2:	881b      	ldrh	r3, [r3, #0]
 80095e4:	9300      	str	r3, [sp, #0]
 80095e6:	000b      	movs	r3, r1
 80095e8:	0021      	movs	r1, r4
 80095ea:	f7ff ff4b 	bl	8009484 <pbuf_init_alloced_pbuf>
                               rem_len, qlen, type, 0);
        LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
 80095ee:	693b      	ldr	r3, [r7, #16]
 80095f0:	685b      	ldr	r3, [r3, #4]
 80095f2:	001a      	movs	r2, r3
 80095f4:	2303      	movs	r3, #3
 80095f6:	4013      	ands	r3, r2
 80095f8:	d006      	beq.n	8009608 <pbuf_alloc+0x128>
 80095fa:	4b53      	ldr	r3, [pc, #332]	; (8009748 <pbuf_alloc+0x268>)
 80095fc:	2280      	movs	r2, #128	; 0x80
 80095fe:	0052      	lsls	r2, r2, #1
 8009600:	4952      	ldr	r1, [pc, #328]	; (800974c <pbuf_alloc+0x26c>)
 8009602:	4853      	ldr	r0, [pc, #332]	; (8009750 <pbuf_alloc+0x270>)
 8009604:	f7f9 f96a 	bl	80028dc <app_debug_rtt_raw>
                    ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
        LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
 8009608:	2322      	movs	r3, #34	; 0x22
 800960a:	18fb      	adds	r3, r7, r3
 800960c:	881b      	ldrh	r3, [r3, #0]
 800960e:	3303      	adds	r3, #3
 8009610:	2203      	movs	r2, #3
 8009612:	4393      	bics	r3, r2
 8009614:	001a      	movs	r2, r3
 8009616:	2394      	movs	r3, #148	; 0x94
 8009618:	009b      	lsls	r3, r3, #2
 800961a:	429a      	cmp	r2, r3
 800961c:	d106      	bne.n	800962c <pbuf_alloc+0x14c>
 800961e:	4b4a      	ldr	r3, [pc, #296]	; (8009748 <pbuf_alloc+0x268>)
 8009620:	2281      	movs	r2, #129	; 0x81
 8009622:	0052      	lsls	r2, r2, #1
 8009624:	494b      	ldr	r1, [pc, #300]	; (8009754 <pbuf_alloc+0x274>)
 8009626:	484a      	ldr	r0, [pc, #296]	; (8009750 <pbuf_alloc+0x270>)
 8009628:	f7f9 f958 	bl	80028dc <app_debug_rtt_raw>
                    (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
        if (p == NULL) {
 800962c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800962e:	2b00      	cmp	r3, #0
 8009630:	d102      	bne.n	8009638 <pbuf_alloc+0x158>
          /* allocated head of pbuf chain (into p) */
          p = q;
 8009632:	693b      	ldr	r3, [r7, #16]
 8009634:	627b      	str	r3, [r7, #36]	; 0x24
 8009636:	e002      	b.n	800963e <pbuf_alloc+0x15e>
        } else {
          /* make previous pbuf point to this pbuf */
          last->next = q;
 8009638:	69fb      	ldr	r3, [r7, #28]
 800963a:	693a      	ldr	r2, [r7, #16]
 800963c:	601a      	str	r2, [r3, #0]
        }
        last = q;
 800963e:	693b      	ldr	r3, [r7, #16]
 8009640:	61fb      	str	r3, [r7, #28]
        rem_len = (u16_t)(rem_len - qlen);
 8009642:	201a      	movs	r0, #26
 8009644:	183b      	adds	r3, r7, r0
 8009646:	1839      	adds	r1, r7, r0
 8009648:	220e      	movs	r2, #14
 800964a:	18ba      	adds	r2, r7, r2
 800964c:	8809      	ldrh	r1, [r1, #0]
 800964e:	8812      	ldrh	r2, [r2, #0]
 8009650:	1a8a      	subs	r2, r1, r2
 8009652:	801a      	strh	r2, [r3, #0]
        offset = 0;
 8009654:	2322      	movs	r3, #34	; 0x22
 8009656:	18fb      	adds	r3, r7, r3
 8009658:	2200      	movs	r2, #0
 800965a:	801a      	strh	r2, [r3, #0]
      } while (rem_len > 0);
 800965c:	183b      	adds	r3, r7, r0
 800965e:	881b      	ldrh	r3, [r3, #0]
 8009660:	2b00      	cmp	r3, #0
 8009662:	d000      	beq.n	8009666 <pbuf_alloc+0x186>
 8009664:	e77e      	b.n	8009564 <pbuf_alloc+0x84>
      break;
 8009666:	e069      	b.n	800973c <pbuf_alloc+0x25c>
    }
    case PBUF_RAM: {
      mem_size_t payload_len = (mem_size_t)(LWIP_MEM_ALIGN_SIZE(offset) + LWIP_MEM_ALIGN_SIZE(length));
 8009668:	2322      	movs	r3, #34	; 0x22
 800966a:	18fb      	adds	r3, r7, r3
 800966c:	881b      	ldrh	r3, [r3, #0]
 800966e:	3303      	adds	r3, #3
 8009670:	b29b      	uxth	r3, r3
 8009672:	2203      	movs	r2, #3
 8009674:	4393      	bics	r3, r2
 8009676:	b299      	uxth	r1, r3
 8009678:	1d3b      	adds	r3, r7, #4
 800967a:	881b      	ldrh	r3, [r3, #0]
 800967c:	3303      	adds	r3, #3
 800967e:	b29b      	uxth	r3, r3
 8009680:	2203      	movs	r2, #3
 8009682:	4393      	bics	r3, r2
 8009684:	b29a      	uxth	r2, r3
 8009686:	2018      	movs	r0, #24
 8009688:	183b      	adds	r3, r7, r0
 800968a:	188a      	adds	r2, r1, r2
 800968c:	801a      	strh	r2, [r3, #0]
      mem_size_t alloc_len = (mem_size_t)(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF) + payload_len);
 800968e:	2416      	movs	r4, #22
 8009690:	193b      	adds	r3, r7, r4
 8009692:	183a      	adds	r2, r7, r0
 8009694:	8812      	ldrh	r2, [r2, #0]
 8009696:	3210      	adds	r2, #16
 8009698:	801a      	strh	r2, [r3, #0]

      /* bug #50040: Check for integer overflow when calculating alloc_len */
      if ((payload_len < LWIP_MEM_ALIGN_SIZE(length)) ||
 800969a:	183b      	adds	r3, r7, r0
 800969c:	881a      	ldrh	r2, [r3, #0]
 800969e:	1d3b      	adds	r3, r7, #4
 80096a0:	881b      	ldrh	r3, [r3, #0]
 80096a2:	3303      	adds	r3, #3
 80096a4:	2103      	movs	r1, #3
 80096a6:	438b      	bics	r3, r1
 80096a8:	429a      	cmp	r2, r3
 80096aa:	d308      	bcc.n	80096be <pbuf_alloc+0x1de>
          (alloc_len < LWIP_MEM_ALIGN_SIZE(length))) {
 80096ac:	193b      	adds	r3, r7, r4
 80096ae:	881a      	ldrh	r2, [r3, #0]
 80096b0:	1d3b      	adds	r3, r7, #4
 80096b2:	881b      	ldrh	r3, [r3, #0]
 80096b4:	3303      	adds	r3, #3
 80096b6:	2103      	movs	r1, #3
 80096b8:	438b      	bics	r3, r1
      if ((payload_len < LWIP_MEM_ALIGN_SIZE(length)) ||
 80096ba:	429a      	cmp	r2, r3
 80096bc:	d201      	bcs.n	80096c2 <pbuf_alloc+0x1e2>
        return NULL;
 80096be:	2300      	movs	r3, #0
 80096c0:	e03d      	b.n	800973e <pbuf_alloc+0x25e>
      }

      /* If pbuf is to be allocated in RAM, allocate memory for it. */
      p = (struct pbuf *)mem_malloc(alloc_len);
 80096c2:	2316      	movs	r3, #22
 80096c4:	18fb      	adds	r3, r7, r3
 80096c6:	881b      	ldrh	r3, [r3, #0]
 80096c8:	0018      	movs	r0, r3
 80096ca:	f7ff f9a9 	bl	8008a20 <mem_malloc>
 80096ce:	0003      	movs	r3, r0
 80096d0:	627b      	str	r3, [r7, #36]	; 0x24
      if (p == NULL) {
 80096d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80096d4:	2b00      	cmp	r3, #0
 80096d6:	d101      	bne.n	80096dc <pbuf_alloc+0x1fc>
        return NULL;
 80096d8:	2300      	movs	r3, #0
 80096da:	e030      	b.n	800973e <pbuf_alloc+0x25e>
      }
      pbuf_init_alloced_pbuf(p, LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset)),
 80096dc:	2322      	movs	r3, #34	; 0x22
 80096de:	18fb      	adds	r3, r7, r3
 80096e0:	881b      	ldrh	r3, [r3, #0]
 80096e2:	3310      	adds	r3, #16
 80096e4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80096e6:	18d3      	adds	r3, r2, r3
 80096e8:	3303      	adds	r3, #3
 80096ea:	2203      	movs	r2, #3
 80096ec:	4393      	bics	r3, r2
 80096ee:	001c      	movs	r4, r3
 80096f0:	1d3b      	adds	r3, r7, #4
 80096f2:	8819      	ldrh	r1, [r3, #0]
 80096f4:	1d3b      	adds	r3, r7, #4
 80096f6:	881a      	ldrh	r2, [r3, #0]
 80096f8:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80096fa:	2300      	movs	r3, #0
 80096fc:	9301      	str	r3, [sp, #4]
 80096fe:	1cbb      	adds	r3, r7, #2
 8009700:	881b      	ldrh	r3, [r3, #0]
 8009702:	9300      	str	r3, [sp, #0]
 8009704:	000b      	movs	r3, r1
 8009706:	0021      	movs	r1, r4
 8009708:	f7ff febc 	bl	8009484 <pbuf_init_alloced_pbuf>
                             length, length, type, 0);
      LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
 800970c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800970e:	685b      	ldr	r3, [r3, #4]
 8009710:	001a      	movs	r2, r3
 8009712:	2303      	movs	r3, #3
 8009714:	4013      	ands	r3, r2
 8009716:	d010      	beq.n	800973a <pbuf_alloc+0x25a>
 8009718:	4b0b      	ldr	r3, [pc, #44]	; (8009748 <pbuf_alloc+0x268>)
 800971a:	2291      	movs	r2, #145	; 0x91
 800971c:	0052      	lsls	r2, r2, #1
 800971e:	490e      	ldr	r1, [pc, #56]	; (8009758 <pbuf_alloc+0x278>)
 8009720:	480b      	ldr	r0, [pc, #44]	; (8009750 <pbuf_alloc+0x270>)
 8009722:	f7f9 f8db 	bl	80028dc <app_debug_rtt_raw>
                  ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
      break;
 8009726:	e008      	b.n	800973a <pbuf_alloc+0x25a>
    }
    default:
      LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
 8009728:	4b07      	ldr	r3, [pc, #28]	; (8009748 <pbuf_alloc+0x268>)
 800972a:	2228      	movs	r2, #40	; 0x28
 800972c:	32ff      	adds	r2, #255	; 0xff
 800972e:	490b      	ldr	r1, [pc, #44]	; (800975c <pbuf_alloc+0x27c>)
 8009730:	4807      	ldr	r0, [pc, #28]	; (8009750 <pbuf_alloc+0x270>)
 8009732:	f7f9 f8d3 	bl	80028dc <app_debug_rtt_raw>
      return NULL;
 8009736:	2300      	movs	r3, #0
 8009738:	e001      	b.n	800973e <pbuf_alloc+0x25e>
      break;
 800973a:	46c0      	nop			; (mov r8, r8)
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
 800973c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 800973e:	0018      	movs	r0, r3
 8009740:	46bd      	mov	sp, r7
 8009742:	b00b      	add	sp, #44	; 0x2c
 8009744:	bd90      	pop	{r4, r7, pc}
 8009746:	46c0      	nop			; (mov r8, r8)
 8009748:	0801f4e8 	.word	0x0801f4e8
 800974c:	0801f510 	.word	0x0801f510
 8009750:	0801f540 	.word	0x0801f540
 8009754:	0801f56c 	.word	0x0801f56c
 8009758:	0801f5a0 	.word	0x0801f5a0
 800975c:	0801f5cc 	.word	0x0801f5cc

08009760 <pbuf_alloc_reference>:
 *
 * @return the allocated pbuf.
 */
struct pbuf *
pbuf_alloc_reference(void *payload, u16_t length, pbuf_type type)
{
 8009760:	b590      	push	{r4, r7, lr}
 8009762:	b087      	sub	sp, #28
 8009764:	af02      	add	r7, sp, #8
 8009766:	6078      	str	r0, [r7, #4]
 8009768:	0008      	movs	r0, r1
 800976a:	0011      	movs	r1, r2
 800976c:	1cbb      	adds	r3, r7, #2
 800976e:	1c02      	adds	r2, r0, #0
 8009770:	801a      	strh	r2, [r3, #0]
 8009772:	003b      	movs	r3, r7
 8009774:	1c0a      	adds	r2, r1, #0
 8009776:	801a      	strh	r2, [r3, #0]
  struct pbuf *p;
  LWIP_ASSERT("invalid pbuf_type", (type == PBUF_REF) || (type == PBUF_ROM));
 8009778:	003b      	movs	r3, r7
 800977a:	881b      	ldrh	r3, [r3, #0]
 800977c:	2b41      	cmp	r3, #65	; 0x41
 800977e:	d00a      	beq.n	8009796 <pbuf_alloc_reference+0x36>
 8009780:	003b      	movs	r3, r7
 8009782:	881b      	ldrh	r3, [r3, #0]
 8009784:	2b01      	cmp	r3, #1
 8009786:	d006      	beq.n	8009796 <pbuf_alloc_reference+0x36>
 8009788:	4b11      	ldr	r3, [pc, #68]	; (80097d0 <pbuf_alloc_reference+0x70>)
 800978a:	22a5      	movs	r2, #165	; 0xa5
 800978c:	0052      	lsls	r2, r2, #1
 800978e:	4911      	ldr	r1, [pc, #68]	; (80097d4 <pbuf_alloc_reference+0x74>)
 8009790:	4811      	ldr	r0, [pc, #68]	; (80097d8 <pbuf_alloc_reference+0x78>)
 8009792:	f7f9 f8a3 	bl	80028dc <app_debug_rtt_raw>
  /* only allocate memory for the pbuf structure */
  p = (struct pbuf *)memp_malloc(MEMP_PBUF);
 8009796:	2005      	movs	r0, #5
 8009798:	f7ff faba 	bl	8008d10 <memp_malloc>
 800979c:	0003      	movs	r3, r0
 800979e:	60fb      	str	r3, [r7, #12]
  if (p == NULL) {
 80097a0:	68fb      	ldr	r3, [r7, #12]
 80097a2:	2b00      	cmp	r3, #0
 80097a4:	d101      	bne.n	80097aa <pbuf_alloc_reference+0x4a>
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                ("pbuf_alloc_reference: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                 (type == PBUF_ROM) ? "ROM" : "REF"));
    return NULL;
 80097a6:	2300      	movs	r3, #0
 80097a8:	e00e      	b.n	80097c8 <pbuf_alloc_reference+0x68>
  }
  pbuf_init_alloced_pbuf(p, payload, length, length, type, 0);
 80097aa:	1cbb      	adds	r3, r7, #2
 80097ac:	881c      	ldrh	r4, [r3, #0]
 80097ae:	1cbb      	adds	r3, r7, #2
 80097b0:	881a      	ldrh	r2, [r3, #0]
 80097b2:	6879      	ldr	r1, [r7, #4]
 80097b4:	68f8      	ldr	r0, [r7, #12]
 80097b6:	2300      	movs	r3, #0
 80097b8:	9301      	str	r3, [sp, #4]
 80097ba:	003b      	movs	r3, r7
 80097bc:	881b      	ldrh	r3, [r3, #0]
 80097be:	9300      	str	r3, [sp, #0]
 80097c0:	0023      	movs	r3, r4
 80097c2:	f7ff fe5f 	bl	8009484 <pbuf_init_alloced_pbuf>
  return p;
 80097c6:	68fb      	ldr	r3, [r7, #12]
}
 80097c8:	0018      	movs	r0, r3
 80097ca:	46bd      	mov	sp, r7
 80097cc:	b005      	add	sp, #20
 80097ce:	bd90      	pop	{r4, r7, pc}
 80097d0:	0801f4e8 	.word	0x0801f4e8
 80097d4:	0801f5e8 	.word	0x0801f5e8
 80097d8:	0801f540 	.word	0x0801f540

080097dc <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
 80097dc:	b580      	push	{r7, lr}
 80097de:	b084      	sub	sp, #16
 80097e0:	af00      	add	r7, sp, #0
 80097e2:	6078      	str	r0, [r7, #4]
 80097e4:	000a      	movs	r2, r1
 80097e6:	1cbb      	adds	r3, r7, #2
 80097e8:	801a      	strh	r2, [r3, #0]
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  u16_t shrink;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
 80097ea:	687b      	ldr	r3, [r7, #4]
 80097ec:	2b00      	cmp	r3, #0
 80097ee:	d106      	bne.n	80097fe <pbuf_realloc+0x22>
 80097f0:	4b44      	ldr	r3, [pc, #272]	; (8009904 <pbuf_realloc+0x128>)
 80097f2:	22cc      	movs	r2, #204	; 0xcc
 80097f4:	0052      	lsls	r2, r2, #1
 80097f6:	4944      	ldr	r1, [pc, #272]	; (8009908 <pbuf_realloc+0x12c>)
 80097f8:	4844      	ldr	r0, [pc, #272]	; (800990c <pbuf_realloc+0x130>)
 80097fa:	f7f9 f86f 	bl	80028dc <app_debug_rtt_raw>

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
 80097fe:	687b      	ldr	r3, [r7, #4]
 8009800:	891b      	ldrh	r3, [r3, #8]
 8009802:	1cba      	adds	r2, r7, #2
 8009804:	8812      	ldrh	r2, [r2, #0]
 8009806:	429a      	cmp	r2, r3
 8009808:	d300      	bcc.n	800980c <pbuf_realloc+0x30>
 800980a:	e076      	b.n	80098fa <pbuf_realloc+0x11e>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  shrink = (u16_t)(p->tot_len - new_len);
 800980c:	687b      	ldr	r3, [r7, #4]
 800980e:	8919      	ldrh	r1, [r3, #8]
 8009810:	2308      	movs	r3, #8
 8009812:	18fb      	adds	r3, r7, r3
 8009814:	1cba      	adds	r2, r7, #2
 8009816:	8812      	ldrh	r2, [r2, #0]
 8009818:	1a8a      	subs	r2, r1, r2
 800981a:	801a      	strh	r2, [r3, #0]

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
 800981c:	230a      	movs	r3, #10
 800981e:	18fb      	adds	r3, r7, r3
 8009820:	1cba      	adds	r2, r7, #2
 8009822:	8812      	ldrh	r2, [r2, #0]
 8009824:	801a      	strh	r2, [r3, #0]
  q = p;
 8009826:	687b      	ldr	r3, [r7, #4]
 8009828:	60fb      	str	r3, [r7, #12]
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
 800982a:	e01d      	b.n	8009868 <pbuf_realloc+0x8c>
    /* decrease remaining length by pbuf length */
    rem_len = (u16_t)(rem_len - q->len);
 800982c:	68fb      	ldr	r3, [r7, #12]
 800982e:	895a      	ldrh	r2, [r3, #10]
 8009830:	210a      	movs	r1, #10
 8009832:	187b      	adds	r3, r7, r1
 8009834:	1879      	adds	r1, r7, r1
 8009836:	8809      	ldrh	r1, [r1, #0]
 8009838:	1a8a      	subs	r2, r1, r2
 800983a:	801a      	strh	r2, [r3, #0]
    /* decrease total length indicator */
    q->tot_len = (u16_t)(q->tot_len - shrink);
 800983c:	68fb      	ldr	r3, [r7, #12]
 800983e:	891a      	ldrh	r2, [r3, #8]
 8009840:	2308      	movs	r3, #8
 8009842:	18fb      	adds	r3, r7, r3
 8009844:	881b      	ldrh	r3, [r3, #0]
 8009846:	1ad3      	subs	r3, r2, r3
 8009848:	b29a      	uxth	r2, r3
 800984a:	68fb      	ldr	r3, [r7, #12]
 800984c:	811a      	strh	r2, [r3, #8]
    /* proceed to next pbuf in chain */
    q = q->next;
 800984e:	68fb      	ldr	r3, [r7, #12]
 8009850:	681b      	ldr	r3, [r3, #0]
 8009852:	60fb      	str	r3, [r7, #12]
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
 8009854:	68fb      	ldr	r3, [r7, #12]
 8009856:	2b00      	cmp	r3, #0
 8009858:	d106      	bne.n	8009868 <pbuf_realloc+0x8c>
 800985a:	4b2a      	ldr	r3, [pc, #168]	; (8009904 <pbuf_realloc+0x128>)
 800985c:	22b0      	movs	r2, #176	; 0xb0
 800985e:	32ff      	adds	r2, #255	; 0xff
 8009860:	492b      	ldr	r1, [pc, #172]	; (8009910 <pbuf_realloc+0x134>)
 8009862:	482a      	ldr	r0, [pc, #168]	; (800990c <pbuf_realloc+0x130>)
 8009864:	f7f9 f83a 	bl	80028dc <app_debug_rtt_raw>
  while (rem_len > q->len) {
 8009868:	68fb      	ldr	r3, [r7, #12]
 800986a:	895b      	ldrh	r3, [r3, #10]
 800986c:	210a      	movs	r1, #10
 800986e:	187a      	adds	r2, r7, r1
 8009870:	8812      	ldrh	r2, [r2, #0]
 8009872:	429a      	cmp	r2, r3
 8009874:	d8da      	bhi.n	800982c <pbuf_realloc+0x50>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if (pbuf_match_allocsrc(q, PBUF_TYPE_ALLOC_SRC_MASK_STD_HEAP) && (rem_len != q->len)
 8009876:	68fb      	ldr	r3, [r7, #12]
 8009878:	7b1b      	ldrb	r3, [r3, #12]
 800987a:	001a      	movs	r2, r3
 800987c:	230f      	movs	r3, #15
 800987e:	4013      	ands	r3, r2
 8009880:	d125      	bne.n	80098ce <pbuf_realloc+0xf2>
 8009882:	68fb      	ldr	r3, [r7, #12]
 8009884:	895b      	ldrh	r3, [r3, #10]
 8009886:	187a      	adds	r2, r7, r1
 8009888:	8812      	ldrh	r2, [r2, #0]
 800988a:	429a      	cmp	r2, r3
 800988c:	d01f      	beq.n	80098ce <pbuf_realloc+0xf2>
#if LWIP_SUPPORT_CUSTOM_PBUF
      && ((q->flags & PBUF_FLAG_IS_CUSTOM) == 0)
 800988e:	68fb      	ldr	r3, [r7, #12]
 8009890:	7b5b      	ldrb	r3, [r3, #13]
 8009892:	001a      	movs	r2, r3
 8009894:	2302      	movs	r3, #2
 8009896:	4013      	ands	r3, r2
 8009898:	d119      	bne.n	80098ce <pbuf_realloc+0xf2>
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
     ) {
    /* reallocate and adjust the length of the pbuf that will be split */
    q = (struct pbuf *)mem_trim(q, (mem_size_t)(((u8_t *)q->payload - (u8_t *)q) + rem_len));
 800989a:	68fb      	ldr	r3, [r7, #12]
 800989c:	685a      	ldr	r2, [r3, #4]
 800989e:	68fb      	ldr	r3, [r7, #12]
 80098a0:	1ad3      	subs	r3, r2, r3
 80098a2:	b29a      	uxth	r2, r3
 80098a4:	187b      	adds	r3, r7, r1
 80098a6:	881b      	ldrh	r3, [r3, #0]
 80098a8:	18d3      	adds	r3, r2, r3
 80098aa:	b29a      	uxth	r2, r3
 80098ac:	68fb      	ldr	r3, [r7, #12]
 80098ae:	0011      	movs	r1, r2
 80098b0:	0018      	movs	r0, r3
 80098b2:	f7fe ff71 	bl	8008798 <mem_trim>
 80098b6:	0003      	movs	r3, r0
 80098b8:	60fb      	str	r3, [r7, #12]
    LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
 80098ba:	68fb      	ldr	r3, [r7, #12]
 80098bc:	2b00      	cmp	r3, #0
 80098be:	d106      	bne.n	80098ce <pbuf_realloc+0xf2>
 80098c0:	4b10      	ldr	r3, [pc, #64]	; (8009904 <pbuf_realloc+0x128>)
 80098c2:	22be      	movs	r2, #190	; 0xbe
 80098c4:	32ff      	adds	r2, #255	; 0xff
 80098c6:	4913      	ldr	r1, [pc, #76]	; (8009914 <pbuf_realloc+0x138>)
 80098c8:	4810      	ldr	r0, [pc, #64]	; (800990c <pbuf_realloc+0x130>)
 80098ca:	f7f9 f807 	bl	80028dc <app_debug_rtt_raw>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
 80098ce:	68fb      	ldr	r3, [r7, #12]
 80098d0:	220a      	movs	r2, #10
 80098d2:	18ba      	adds	r2, r7, r2
 80098d4:	8812      	ldrh	r2, [r2, #0]
 80098d6:	815a      	strh	r2, [r3, #10]
  q->tot_len = q->len;
 80098d8:	68fb      	ldr	r3, [r7, #12]
 80098da:	895a      	ldrh	r2, [r3, #10]
 80098dc:	68fb      	ldr	r3, [r7, #12]
 80098de:	811a      	strh	r2, [r3, #8]

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
 80098e0:	68fb      	ldr	r3, [r7, #12]
 80098e2:	681b      	ldr	r3, [r3, #0]
 80098e4:	2b00      	cmp	r3, #0
 80098e6:	d004      	beq.n	80098f2 <pbuf_realloc+0x116>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
 80098e8:	68fb      	ldr	r3, [r7, #12]
 80098ea:	681b      	ldr	r3, [r3, #0]
 80098ec:	0018      	movs	r0, r3
 80098ee:	f000 f96f 	bl	8009bd0 <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
 80098f2:	68fb      	ldr	r3, [r7, #12]
 80098f4:	2200      	movs	r2, #0
 80098f6:	601a      	str	r2, [r3, #0]
 80098f8:	e000      	b.n	80098fc <pbuf_realloc+0x120>
    return;
 80098fa:	46c0      	nop			; (mov r8, r8)

}
 80098fc:	46bd      	mov	sp, r7
 80098fe:	b004      	add	sp, #16
 8009900:	bd80      	pop	{r7, pc}
 8009902:	46c0      	nop			; (mov r8, r8)
 8009904:	0801f4e8 	.word	0x0801f4e8
 8009908:	0801f5fc 	.word	0x0801f5fc
 800990c:	0801f540 	.word	0x0801f540
 8009910:	0801f614 	.word	0x0801f614
 8009914:	0801f62c 	.word	0x0801f62c

08009918 <pbuf_add_header_impl>:
 * @return non-zero on failure, zero on success.
 *
 */
static u8_t
pbuf_add_header_impl(struct pbuf *p, size_t header_size_increment, u8_t force)
{
 8009918:	b580      	push	{r7, lr}
 800991a:	b086      	sub	sp, #24
 800991c:	af00      	add	r7, sp, #0
 800991e:	60f8      	str	r0, [r7, #12]
 8009920:	60b9      	str	r1, [r7, #8]
 8009922:	1dfb      	adds	r3, r7, #7
 8009924:	701a      	strb	r2, [r3, #0]
  u16_t type_internal;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
 8009926:	68fb      	ldr	r3, [r7, #12]
 8009928:	2b00      	cmp	r3, #0
 800992a:	d106      	bne.n	800993a <pbuf_add_header_impl+0x22>
 800992c:	4b31      	ldr	r3, [pc, #196]	; (80099f4 <pbuf_add_header_impl+0xdc>)
 800992e:	22e0      	movs	r2, #224	; 0xe0
 8009930:	32ff      	adds	r2, #255	; 0xff
 8009932:	4931      	ldr	r1, [pc, #196]	; (80099f8 <pbuf_add_header_impl+0xe0>)
 8009934:	4831      	ldr	r0, [pc, #196]	; (80099fc <pbuf_add_header_impl+0xe4>)
 8009936:	f7f8 ffd1 	bl	80028dc <app_debug_rtt_raw>
  if ((p == NULL) || (header_size_increment > 0xFFFF)) {
 800993a:	68fb      	ldr	r3, [r7, #12]
 800993c:	2b00      	cmp	r3, #0
 800993e:	d004      	beq.n	800994a <pbuf_add_header_impl+0x32>
 8009940:	68ba      	ldr	r2, [r7, #8]
 8009942:	2380      	movs	r3, #128	; 0x80
 8009944:	025b      	lsls	r3, r3, #9
 8009946:	429a      	cmp	r2, r3
 8009948:	d301      	bcc.n	800994e <pbuf_add_header_impl+0x36>
    return 1;
 800994a:	2301      	movs	r3, #1
 800994c:	e04d      	b.n	80099ea <pbuf_add_header_impl+0xd2>
  }
  if (header_size_increment == 0) {
 800994e:	68bb      	ldr	r3, [r7, #8]
 8009950:	2b00      	cmp	r3, #0
 8009952:	d101      	bne.n	8009958 <pbuf_add_header_impl+0x40>
    return 0;
 8009954:	2300      	movs	r3, #0
 8009956:	e048      	b.n	80099ea <pbuf_add_header_impl+0xd2>
  }

  increment_magnitude = (u16_t)header_size_increment;
 8009958:	2112      	movs	r1, #18
 800995a:	187b      	adds	r3, r7, r1
 800995c:	68ba      	ldr	r2, [r7, #8]
 800995e:	801a      	strh	r2, [r3, #0]
  /* Do not allow tot_len to wrap as a result. */
  if ((u16_t)(increment_magnitude + p->tot_len) < increment_magnitude) {
 8009960:	68fb      	ldr	r3, [r7, #12]
 8009962:	891a      	ldrh	r2, [r3, #8]
 8009964:	187b      	adds	r3, r7, r1
 8009966:	881b      	ldrh	r3, [r3, #0]
 8009968:	18d3      	adds	r3, r2, r3
 800996a:	b29b      	uxth	r3, r3
 800996c:	187a      	adds	r2, r7, r1
 800996e:	8812      	ldrh	r2, [r2, #0]
 8009970:	429a      	cmp	r2, r3
 8009972:	d901      	bls.n	8009978 <pbuf_add_header_impl+0x60>
    return 1;
 8009974:	2301      	movs	r3, #1
 8009976:	e038      	b.n	80099ea <pbuf_add_header_impl+0xd2>
  }

  type_internal = p->type_internal;
 8009978:	68fb      	ldr	r3, [r7, #12]
 800997a:	7b1a      	ldrb	r2, [r3, #12]
 800997c:	2110      	movs	r1, #16
 800997e:	187b      	adds	r3, r7, r1
 8009980:	801a      	strh	r2, [r3, #0]

  /* pbuf types containing payloads? */
  if (type_internal & PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS) {
 8009982:	187b      	adds	r3, r7, r1
 8009984:	881b      	ldrh	r3, [r3, #0]
 8009986:	2280      	movs	r2, #128	; 0x80
 8009988:	4013      	ands	r3, r2
 800998a:	d00c      	beq.n	80099a6 <pbuf_add_header_impl+0x8e>
    /* set new payload pointer */
    payload = (u8_t *)p->payload - header_size_increment;
 800998c:	68fb      	ldr	r3, [r7, #12]
 800998e:	685a      	ldr	r2, [r3, #4]
 8009990:	68bb      	ldr	r3, [r7, #8]
 8009992:	425b      	negs	r3, r3
 8009994:	18d3      	adds	r3, r2, r3
 8009996:	617b      	str	r3, [r7, #20]
    /* boundary check fails? */
    if ((u8_t *)payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
 8009998:	68fb      	ldr	r3, [r7, #12]
 800999a:	3310      	adds	r3, #16
 800999c:	697a      	ldr	r2, [r7, #20]
 800999e:	429a      	cmp	r2, r3
 80099a0:	d20e      	bcs.n	80099c0 <pbuf_add_header_impl+0xa8>
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE,
                   ("pbuf_add_header: failed as %p < %p (not enough space for new header size)\n",
                    (void *)payload, (void *)((u8_t *)p + SIZEOF_STRUCT_PBUF)));
      /* bail out unsuccessfully */
      return 1;
 80099a2:	2301      	movs	r3, #1
 80099a4:	e021      	b.n	80099ea <pbuf_add_header_impl+0xd2>
    }
    /* pbuf types referring to external payloads? */
  } else {
    /* hide a header in the payload? */
    if (force) {
 80099a6:	1dfb      	adds	r3, r7, #7
 80099a8:	781b      	ldrb	r3, [r3, #0]
 80099aa:	2b00      	cmp	r3, #0
 80099ac:	d006      	beq.n	80099bc <pbuf_add_header_impl+0xa4>
      payload = (u8_t *)p->payload - header_size_increment;
 80099ae:	68fb      	ldr	r3, [r7, #12]
 80099b0:	685a      	ldr	r2, [r3, #4]
 80099b2:	68bb      	ldr	r3, [r7, #8]
 80099b4:	425b      	negs	r3, r3
 80099b6:	18d3      	adds	r3, r2, r3
 80099b8:	617b      	str	r3, [r7, #20]
 80099ba:	e001      	b.n	80099c0 <pbuf_add_header_impl+0xa8>
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccessfully */
      return 1;
 80099bc:	2301      	movs	r3, #1
 80099be:	e014      	b.n	80099ea <pbuf_add_header_impl+0xd2>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_add_header: old %p new %p (%"U16_F")\n",
              (void *)p->payload, (void *)payload, increment_magnitude));

  /* modify pbuf fields */
  p->payload = payload;
 80099c0:	68fb      	ldr	r3, [r7, #12]
 80099c2:	697a      	ldr	r2, [r7, #20]
 80099c4:	605a      	str	r2, [r3, #4]
  p->len = (u16_t)(p->len + increment_magnitude);
 80099c6:	68fb      	ldr	r3, [r7, #12]
 80099c8:	895a      	ldrh	r2, [r3, #10]
 80099ca:	2112      	movs	r1, #18
 80099cc:	187b      	adds	r3, r7, r1
 80099ce:	881b      	ldrh	r3, [r3, #0]
 80099d0:	18d3      	adds	r3, r2, r3
 80099d2:	b29a      	uxth	r2, r3
 80099d4:	68fb      	ldr	r3, [r7, #12]
 80099d6:	815a      	strh	r2, [r3, #10]
  p->tot_len = (u16_t)(p->tot_len + increment_magnitude);
 80099d8:	68fb      	ldr	r3, [r7, #12]
 80099da:	891a      	ldrh	r2, [r3, #8]
 80099dc:	187b      	adds	r3, r7, r1
 80099de:	881b      	ldrh	r3, [r3, #0]
 80099e0:	18d3      	adds	r3, r2, r3
 80099e2:	b29a      	uxth	r2, r3
 80099e4:	68fb      	ldr	r3, [r7, #12]
 80099e6:	811a      	strh	r2, [r3, #8]


  return 0;
 80099e8:	2300      	movs	r3, #0
}
 80099ea:	0018      	movs	r0, r3
 80099ec:	46bd      	mov	sp, r7
 80099ee:	b006      	add	sp, #24
 80099f0:	bd80      	pop	{r7, pc}
 80099f2:	46c0      	nop			; (mov r8, r8)
 80099f4:	0801f4e8 	.word	0x0801f4e8
 80099f8:	0801f648 	.word	0x0801f648
 80099fc:	0801f540 	.word	0x0801f540

08009a00 <pbuf_add_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_add_header(struct pbuf *p, size_t header_size_increment)
{
 8009a00:	b580      	push	{r7, lr}
 8009a02:	b082      	sub	sp, #8
 8009a04:	af00      	add	r7, sp, #0
 8009a06:	6078      	str	r0, [r7, #4]
 8009a08:	6039      	str	r1, [r7, #0]
  return pbuf_add_header_impl(p, header_size_increment, 0);
 8009a0a:	6839      	ldr	r1, [r7, #0]
 8009a0c:	687b      	ldr	r3, [r7, #4]
 8009a0e:	2200      	movs	r2, #0
 8009a10:	0018      	movs	r0, r3
 8009a12:	f7ff ff81 	bl	8009918 <pbuf_add_header_impl>
 8009a16:	0003      	movs	r3, r0
}
 8009a18:	0018      	movs	r0, r3
 8009a1a:	46bd      	mov	sp, r7
 8009a1c:	b002      	add	sp, #8
 8009a1e:	bd80      	pop	{r7, pc}

08009a20 <pbuf_remove_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_remove_header(struct pbuf *p, size_t header_size_decrement)
{
 8009a20:	b580      	push	{r7, lr}
 8009a22:	b084      	sub	sp, #16
 8009a24:	af00      	add	r7, sp, #0
 8009a26:	6078      	str	r0, [r7, #4]
 8009a28:	6039      	str	r1, [r7, #0]
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
 8009a2a:	687b      	ldr	r3, [r7, #4]
 8009a2c:	2b00      	cmp	r3, #0
 8009a2e:	d105      	bne.n	8009a3c <pbuf_remove_header+0x1c>
 8009a30:	4b21      	ldr	r3, [pc, #132]	; (8009ab8 <pbuf_remove_header+0x98>)
 8009a32:	4a22      	ldr	r2, [pc, #136]	; (8009abc <pbuf_remove_header+0x9c>)
 8009a34:	4922      	ldr	r1, [pc, #136]	; (8009ac0 <pbuf_remove_header+0xa0>)
 8009a36:	4823      	ldr	r0, [pc, #140]	; (8009ac4 <pbuf_remove_header+0xa4>)
 8009a38:	f7f8 ff50 	bl	80028dc <app_debug_rtt_raw>
  if ((p == NULL) || (header_size_decrement > 0xFFFF)) {
 8009a3c:	687b      	ldr	r3, [r7, #4]
 8009a3e:	2b00      	cmp	r3, #0
 8009a40:	d004      	beq.n	8009a4c <pbuf_remove_header+0x2c>
 8009a42:	683a      	ldr	r2, [r7, #0]
 8009a44:	2380      	movs	r3, #128	; 0x80
 8009a46:	025b      	lsls	r3, r3, #9
 8009a48:	429a      	cmp	r2, r3
 8009a4a:	d301      	bcc.n	8009a50 <pbuf_remove_header+0x30>
    return 1;
 8009a4c:	2301      	movs	r3, #1
 8009a4e:	e02f      	b.n	8009ab0 <pbuf_remove_header+0x90>
  }
  if (header_size_decrement == 0) {
 8009a50:	683b      	ldr	r3, [r7, #0]
 8009a52:	2b00      	cmp	r3, #0
 8009a54:	d101      	bne.n	8009a5a <pbuf_remove_header+0x3a>
    return 0;
 8009a56:	2300      	movs	r3, #0
 8009a58:	e02a      	b.n	8009ab0 <pbuf_remove_header+0x90>
  }

  increment_magnitude = (u16_t)header_size_decrement;
 8009a5a:	210e      	movs	r1, #14
 8009a5c:	187b      	adds	r3, r7, r1
 8009a5e:	683a      	ldr	r2, [r7, #0]
 8009a60:	801a      	strh	r2, [r3, #0]
  /* Check that we aren't going to move off the end of the pbuf */
  LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 8009a62:	687b      	ldr	r3, [r7, #4]
 8009a64:	895b      	ldrh	r3, [r3, #10]
 8009a66:	187a      	adds	r2, r7, r1
 8009a68:	8812      	ldrh	r2, [r2, #0]
 8009a6a:	429a      	cmp	r2, r3
 8009a6c:	d905      	bls.n	8009a7a <pbuf_remove_header+0x5a>
 8009a6e:	4b16      	ldr	r3, [pc, #88]	; (8009ac8 <pbuf_remove_header+0xa8>)
 8009a70:	0018      	movs	r0, r3
 8009a72:	f7f8 ff33 	bl	80028dc <app_debug_rtt_raw>
 8009a76:	2301      	movs	r3, #1
 8009a78:	e01a      	b.n	8009ab0 <pbuf_remove_header+0x90>

  /* remember current payload pointer */
  payload = p->payload;
 8009a7a:	687b      	ldr	r3, [r7, #4]
 8009a7c:	685b      	ldr	r3, [r3, #4]
 8009a7e:	60bb      	str	r3, [r7, #8]
  LWIP_UNUSED_ARG(payload); /* only used in LWIP_DEBUGF below */

  /* increase payload pointer (guarded by length check above) */
  p->payload = (u8_t *)p->payload + header_size_decrement;
 8009a80:	687b      	ldr	r3, [r7, #4]
 8009a82:	685a      	ldr	r2, [r3, #4]
 8009a84:	683b      	ldr	r3, [r7, #0]
 8009a86:	18d2      	adds	r2, r2, r3
 8009a88:	687b      	ldr	r3, [r7, #4]
 8009a8a:	605a      	str	r2, [r3, #4]
  /* modify pbuf length fields */
  p->len = (u16_t)(p->len - increment_magnitude);
 8009a8c:	687b      	ldr	r3, [r7, #4]
 8009a8e:	895a      	ldrh	r2, [r3, #10]
 8009a90:	210e      	movs	r1, #14
 8009a92:	187b      	adds	r3, r7, r1
 8009a94:	881b      	ldrh	r3, [r3, #0]
 8009a96:	1ad3      	subs	r3, r2, r3
 8009a98:	b29a      	uxth	r2, r3
 8009a9a:	687b      	ldr	r3, [r7, #4]
 8009a9c:	815a      	strh	r2, [r3, #10]
  p->tot_len = (u16_t)(p->tot_len - increment_magnitude);
 8009a9e:	687b      	ldr	r3, [r7, #4]
 8009aa0:	891a      	ldrh	r2, [r3, #8]
 8009aa2:	187b      	adds	r3, r7, r1
 8009aa4:	881b      	ldrh	r3, [r3, #0]
 8009aa6:	1ad3      	subs	r3, r2, r3
 8009aa8:	b29a      	uxth	r2, r3
 8009aaa:	687b      	ldr	r3, [r7, #4]
 8009aac:	811a      	strh	r2, [r3, #8]

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_remove_header: old %p new %p (%"U16_F")\n",
              (void *)payload, (void *)p->payload, increment_magnitude));

  return 0;
 8009aae:	2300      	movs	r3, #0
}
 8009ab0:	0018      	movs	r0, r3
 8009ab2:	46bd      	mov	sp, r7
 8009ab4:	b004      	add	sp, #16
 8009ab6:	bd80      	pop	{r7, pc}
 8009ab8:	0801f4e8 	.word	0x0801f4e8
 8009abc:	0000024b 	.word	0x0000024b
 8009ac0:	0801f648 	.word	0x0801f648
 8009ac4:	0801f540 	.word	0x0801f540
 8009ac8:	0801f654 	.word	0x0801f654

08009acc <pbuf_header_impl>:

static u8_t
pbuf_header_impl(struct pbuf *p, s16_t header_size_increment, u8_t force)
{
 8009acc:	b580      	push	{r7, lr}
 8009ace:	b082      	sub	sp, #8
 8009ad0:	af00      	add	r7, sp, #0
 8009ad2:	6078      	str	r0, [r7, #4]
 8009ad4:	0008      	movs	r0, r1
 8009ad6:	0011      	movs	r1, r2
 8009ad8:	1cbb      	adds	r3, r7, #2
 8009ada:	1c02      	adds	r2, r0, #0
 8009adc:	801a      	strh	r2, [r3, #0]
 8009ade:	1c7b      	adds	r3, r7, #1
 8009ae0:	1c0a      	adds	r2, r1, #0
 8009ae2:	701a      	strb	r2, [r3, #0]
  if (header_size_increment < 0) {
 8009ae4:	1cbb      	adds	r3, r7, #2
 8009ae6:	2200      	movs	r2, #0
 8009ae8:	5e9b      	ldrsh	r3, [r3, r2]
 8009aea:	2b00      	cmp	r3, #0
 8009aec:	da0b      	bge.n	8009b06 <pbuf_header_impl+0x3a>
    return pbuf_remove_header(p, (size_t) - header_size_increment);
 8009aee:	1cbb      	adds	r3, r7, #2
 8009af0:	2200      	movs	r2, #0
 8009af2:	5e9b      	ldrsh	r3, [r3, r2]
 8009af4:	425b      	negs	r3, r3
 8009af6:	001a      	movs	r2, r3
 8009af8:	687b      	ldr	r3, [r7, #4]
 8009afa:	0011      	movs	r1, r2
 8009afc:	0018      	movs	r0, r3
 8009afe:	f7ff ff8f 	bl	8009a20 <pbuf_remove_header>
 8009b02:	0003      	movs	r3, r0
 8009b04:	e009      	b.n	8009b1a <pbuf_header_impl+0x4e>
  } else {
    return pbuf_add_header_impl(p, (size_t)header_size_increment, force);
 8009b06:	1cbb      	adds	r3, r7, #2
 8009b08:	2100      	movs	r1, #0
 8009b0a:	5e59      	ldrsh	r1, [r3, r1]
 8009b0c:	1c7b      	adds	r3, r7, #1
 8009b0e:	781a      	ldrb	r2, [r3, #0]
 8009b10:	687b      	ldr	r3, [r7, #4]
 8009b12:	0018      	movs	r0, r3
 8009b14:	f7ff ff00 	bl	8009918 <pbuf_add_header_impl>
 8009b18:	0003      	movs	r3, r0
  }
}
 8009b1a:	0018      	movs	r0, r3
 8009b1c:	46bd      	mov	sp, r7
 8009b1e:	b002      	add	sp, #8
 8009b20:	bd80      	pop	{r7, pc}

08009b22 <pbuf_header_force>:
 * Same as pbuf_header but does not check if 'header_size > 0' is allowed.
 * This is used internally only, to allow PBUF_REF for RX.
 */
u8_t
pbuf_header_force(struct pbuf *p, s16_t header_size_increment)
{
 8009b22:	b580      	push	{r7, lr}
 8009b24:	b082      	sub	sp, #8
 8009b26:	af00      	add	r7, sp, #0
 8009b28:	6078      	str	r0, [r7, #4]
 8009b2a:	000a      	movs	r2, r1
 8009b2c:	1cbb      	adds	r3, r7, #2
 8009b2e:	801a      	strh	r2, [r3, #0]
  return pbuf_header_impl(p, header_size_increment, 1);
 8009b30:	1cbb      	adds	r3, r7, #2
 8009b32:	2100      	movs	r1, #0
 8009b34:	5e59      	ldrsh	r1, [r3, r1]
 8009b36:	687b      	ldr	r3, [r7, #4]
 8009b38:	2201      	movs	r2, #1
 8009b3a:	0018      	movs	r0, r3
 8009b3c:	f7ff ffc6 	bl	8009acc <pbuf_header_impl>
 8009b40:	0003      	movs	r3, r0
}
 8009b42:	0018      	movs	r0, r3
 8009b44:	46bd      	mov	sp, r7
 8009b46:	b002      	add	sp, #8
 8009b48:	bd80      	pop	{r7, pc}

08009b4a <pbuf_free_header>:
 *                   takes an u16_t not s16_t!
 * @return the new head pbuf
 */
struct pbuf *
pbuf_free_header(struct pbuf *q, u16_t size)
{
 8009b4a:	b590      	push	{r4, r7, lr}
 8009b4c:	b087      	sub	sp, #28
 8009b4e:	af00      	add	r7, sp, #0
 8009b50:	6078      	str	r0, [r7, #4]
 8009b52:	000a      	movs	r2, r1
 8009b54:	1cbb      	adds	r3, r7, #2
 8009b56:	801a      	strh	r2, [r3, #0]
  struct pbuf *p = q;
 8009b58:	687b      	ldr	r3, [r7, #4]
 8009b5a:	617b      	str	r3, [r7, #20]
  u16_t free_left = size;
 8009b5c:	2312      	movs	r3, #18
 8009b5e:	18fb      	adds	r3, r7, r3
 8009b60:	1cba      	adds	r2, r7, #2
 8009b62:	8812      	ldrh	r2, [r2, #0]
 8009b64:	801a      	strh	r2, [r3, #0]
  while (free_left && p) {
 8009b66:	e025      	b.n	8009bb4 <pbuf_free_header+0x6a>
    if (free_left >= p->len) {
 8009b68:	697b      	ldr	r3, [r7, #20]
 8009b6a:	895b      	ldrh	r3, [r3, #10]
 8009b6c:	2112      	movs	r1, #18
 8009b6e:	187a      	adds	r2, r7, r1
 8009b70:	8812      	ldrh	r2, [r2, #0]
 8009b72:	429a      	cmp	r2, r3
 8009b74:	d313      	bcc.n	8009b9e <pbuf_free_header+0x54>
      struct pbuf *f = p;
 8009b76:	697b      	ldr	r3, [r7, #20]
 8009b78:	60fb      	str	r3, [r7, #12]
      free_left = (u16_t)(free_left - p->len);
 8009b7a:	697b      	ldr	r3, [r7, #20]
 8009b7c:	895a      	ldrh	r2, [r3, #10]
 8009b7e:	187b      	adds	r3, r7, r1
 8009b80:	1879      	adds	r1, r7, r1
 8009b82:	8809      	ldrh	r1, [r1, #0]
 8009b84:	1a8a      	subs	r2, r1, r2
 8009b86:	801a      	strh	r2, [r3, #0]
      p = p->next;
 8009b88:	697b      	ldr	r3, [r7, #20]
 8009b8a:	681b      	ldr	r3, [r3, #0]
 8009b8c:	617b      	str	r3, [r7, #20]
      f->next = 0;
 8009b8e:	68fb      	ldr	r3, [r7, #12]
 8009b90:	2200      	movs	r2, #0
 8009b92:	601a      	str	r2, [r3, #0]
      pbuf_free(f);
 8009b94:	68fb      	ldr	r3, [r7, #12]
 8009b96:	0018      	movs	r0, r3
 8009b98:	f000 f81a 	bl	8009bd0 <pbuf_free>
 8009b9c:	e00a      	b.n	8009bb4 <pbuf_free_header+0x6a>
    } else {
      pbuf_remove_header(p, free_left);
 8009b9e:	2412      	movs	r4, #18
 8009ba0:	193b      	adds	r3, r7, r4
 8009ba2:	881a      	ldrh	r2, [r3, #0]
 8009ba4:	697b      	ldr	r3, [r7, #20]
 8009ba6:	0011      	movs	r1, r2
 8009ba8:	0018      	movs	r0, r3
 8009baa:	f7ff ff39 	bl	8009a20 <pbuf_remove_header>
      free_left = 0;
 8009bae:	193b      	adds	r3, r7, r4
 8009bb0:	2200      	movs	r2, #0
 8009bb2:	801a      	strh	r2, [r3, #0]
  while (free_left && p) {
 8009bb4:	2312      	movs	r3, #18
 8009bb6:	18fb      	adds	r3, r7, r3
 8009bb8:	881b      	ldrh	r3, [r3, #0]
 8009bba:	2b00      	cmp	r3, #0
 8009bbc:	d002      	beq.n	8009bc4 <pbuf_free_header+0x7a>
 8009bbe:	697b      	ldr	r3, [r7, #20]
 8009bc0:	2b00      	cmp	r3, #0
 8009bc2:	d1d1      	bne.n	8009b68 <pbuf_free_header+0x1e>
    }
  }
  return p;
 8009bc4:	697b      	ldr	r3, [r7, #20]
}
 8009bc6:	0018      	movs	r0, r3
 8009bc8:	46bd      	mov	sp, r7
 8009bca:	b007      	add	sp, #28
 8009bcc:	bd90      	pop	{r4, r7, pc}
	...

08009bd0 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
 8009bd0:	b580      	push	{r7, lr}
 8009bd2:	b086      	sub	sp, #24
 8009bd4:	af00      	add	r7, sp, #0
 8009bd6:	6078      	str	r0, [r7, #4]
  u8_t alloc_src;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
 8009bd8:	687b      	ldr	r3, [r7, #4]
 8009bda:	2b00      	cmp	r3, #0
 8009bdc:	d10b      	bne.n	8009bf6 <pbuf_free+0x26>
    LWIP_ASSERT("p != NULL", p != NULL);
 8009bde:	687b      	ldr	r3, [r7, #4]
 8009be0:	2b00      	cmp	r3, #0
 8009be2:	d106      	bne.n	8009bf2 <pbuf_free+0x22>
 8009be4:	4b41      	ldr	r3, [pc, #260]	; (8009cec <pbuf_free+0x11c>)
 8009be6:	22b7      	movs	r2, #183	; 0xb7
 8009be8:	0092      	lsls	r2, r2, #2
 8009bea:	4941      	ldr	r1, [pc, #260]	; (8009cf0 <pbuf_free+0x120>)
 8009bec:	4841      	ldr	r0, [pc, #260]	; (8009cf4 <pbuf_free+0x124>)
 8009bee:	f7f8 fe75 	bl	80028dc <app_debug_rtt_raw>
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                ("pbuf_free(p == NULL) was called.\n"));
    return 0;
 8009bf2:	2300      	movs	r3, #0
 8009bf4:	e076      	b.n	8009ce4 <pbuf_free+0x114>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  count = 0;
 8009bf6:	2317      	movs	r3, #23
 8009bf8:	18fb      	adds	r3, r7, r3
 8009bfa:	2200      	movs	r2, #0
 8009bfc:	701a      	strb	r2, [r3, #0]
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
 8009bfe:	e06b      	b.n	8009cd8 <pbuf_free+0x108>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
 8009c00:	687b      	ldr	r3, [r7, #4]
 8009c02:	7b9b      	ldrb	r3, [r3, #14]
 8009c04:	2b00      	cmp	r3, #0
 8009c06:	d105      	bne.n	8009c14 <pbuf_free+0x44>
 8009c08:	4b38      	ldr	r3, [pc, #224]	; (8009cec <pbuf_free+0x11c>)
 8009c0a:	4a3b      	ldr	r2, [pc, #236]	; (8009cf8 <pbuf_free+0x128>)
 8009c0c:	493b      	ldr	r1, [pc, #236]	; (8009cfc <pbuf_free+0x12c>)
 8009c0e:	4839      	ldr	r0, [pc, #228]	; (8009cf4 <pbuf_free+0x124>)
 8009c10:	f7f8 fe64 	bl	80028dc <app_debug_rtt_raw>
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
 8009c14:	687b      	ldr	r3, [r7, #4]
 8009c16:	7b9b      	ldrb	r3, [r3, #14]
 8009c18:	3b01      	subs	r3, #1
 8009c1a:	b2da      	uxtb	r2, r3
 8009c1c:	687b      	ldr	r3, [r7, #4]
 8009c1e:	739a      	strb	r2, [r3, #14]
 8009c20:	2116      	movs	r1, #22
 8009c22:	187b      	adds	r3, r7, r1
 8009c24:	687a      	ldr	r2, [r7, #4]
 8009c26:	7b92      	ldrb	r2, [r2, #14]
 8009c28:	701a      	strb	r2, [r3, #0]
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
 8009c2a:	187b      	adds	r3, r7, r1
 8009c2c:	781b      	ldrb	r3, [r3, #0]
 8009c2e:	2b00      	cmp	r3, #0
 8009c30:	d150      	bne.n	8009cd4 <pbuf_free+0x104>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
 8009c32:	687b      	ldr	r3, [r7, #4]
 8009c34:	681b      	ldr	r3, [r3, #0]
 8009c36:	613b      	str	r3, [r7, #16]
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      alloc_src = pbuf_get_allocsrc(p);
 8009c38:	687b      	ldr	r3, [r7, #4]
 8009c3a:	7b1a      	ldrb	r2, [r3, #12]
 8009c3c:	230f      	movs	r3, #15
 8009c3e:	18fb      	adds	r3, r7, r3
 8009c40:	210f      	movs	r1, #15
 8009c42:	400a      	ands	r2, r1
 8009c44:	701a      	strb	r2, [r3, #0]
#if LWIP_SUPPORT_CUSTOM_PBUF
      /* is this a custom pbuf? */
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
 8009c46:	687b      	ldr	r3, [r7, #4]
 8009c48:	7b5b      	ldrb	r3, [r3, #13]
 8009c4a:	001a      	movs	r2, r3
 8009c4c:	2302      	movs	r3, #2
 8009c4e:	4013      	ands	r3, r2
 8009c50:	d011      	beq.n	8009c76 <pbuf_free+0xa6>
        struct pbuf_custom *pc = (struct pbuf_custom *)p;
 8009c52:	687b      	ldr	r3, [r7, #4]
 8009c54:	60bb      	str	r3, [r7, #8]
        LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
 8009c56:	68bb      	ldr	r3, [r7, #8]
 8009c58:	691b      	ldr	r3, [r3, #16]
 8009c5a:	2b00      	cmp	r3, #0
 8009c5c:	d105      	bne.n	8009c6a <pbuf_free+0x9a>
 8009c5e:	4b23      	ldr	r3, [pc, #140]	; (8009cec <pbuf_free+0x11c>)
 8009c60:	4a27      	ldr	r2, [pc, #156]	; (8009d00 <pbuf_free+0x130>)
 8009c62:	4928      	ldr	r1, [pc, #160]	; (8009d04 <pbuf_free+0x134>)
 8009c64:	4823      	ldr	r0, [pc, #140]	; (8009cf4 <pbuf_free+0x124>)
 8009c66:	f7f8 fe39 	bl	80028dc <app_debug_rtt_raw>
        pc->custom_free_function(p);
 8009c6a:	68bb      	ldr	r3, [r7, #8]
 8009c6c:	691b      	ldr	r3, [r3, #16]
 8009c6e:	687a      	ldr	r2, [r7, #4]
 8009c70:	0010      	movs	r0, r2
 8009c72:	4798      	blx	r3
 8009c74:	e025      	b.n	8009cc2 <pbuf_free+0xf2>
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (alloc_src == PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF_POOL) {
 8009c76:	230f      	movs	r3, #15
 8009c78:	18fb      	adds	r3, r7, r3
 8009c7a:	781b      	ldrb	r3, [r3, #0]
 8009c7c:	2b02      	cmp	r3, #2
 8009c7e:	d105      	bne.n	8009c8c <pbuf_free+0xbc>
          memp_free(MEMP_PBUF_POOL, p);
 8009c80:	687b      	ldr	r3, [r7, #4]
 8009c82:	0019      	movs	r1, r3
 8009c84:	2006      	movs	r0, #6
 8009c86:	f7ff f8b3 	bl	8008df0 <memp_free>
 8009c8a:	e01a      	b.n	8009cc2 <pbuf_free+0xf2>
          /* is this a ROM or RAM referencing pbuf? */
        } else if (alloc_src == PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF) {
 8009c8c:	230f      	movs	r3, #15
 8009c8e:	18fb      	adds	r3, r7, r3
 8009c90:	781b      	ldrb	r3, [r3, #0]
 8009c92:	2b01      	cmp	r3, #1
 8009c94:	d105      	bne.n	8009ca2 <pbuf_free+0xd2>
          memp_free(MEMP_PBUF, p);
 8009c96:	687b      	ldr	r3, [r7, #4]
 8009c98:	0019      	movs	r1, r3
 8009c9a:	2005      	movs	r0, #5
 8009c9c:	f7ff f8a8 	bl	8008df0 <memp_free>
 8009ca0:	e00f      	b.n	8009cc2 <pbuf_free+0xf2>
          /* type == PBUF_RAM */
        } else if (alloc_src == PBUF_TYPE_ALLOC_SRC_MASK_STD_HEAP) {
 8009ca2:	230f      	movs	r3, #15
 8009ca4:	18fb      	adds	r3, r7, r3
 8009ca6:	781b      	ldrb	r3, [r3, #0]
 8009ca8:	2b00      	cmp	r3, #0
 8009caa:	d104      	bne.n	8009cb6 <pbuf_free+0xe6>
          mem_free(p);
 8009cac:	687b      	ldr	r3, [r7, #4]
 8009cae:	0018      	movs	r0, r3
 8009cb0:	f7fe fd04 	bl	80086bc <mem_free>
 8009cb4:	e005      	b.n	8009cc2 <pbuf_free+0xf2>
        } else {
          /* @todo: support freeing other types */
          LWIP_ASSERT("invalid pbuf type", 0);
 8009cb6:	4b0d      	ldr	r3, [pc, #52]	; (8009cec <pbuf_free+0x11c>)
 8009cb8:	4a13      	ldr	r2, [pc, #76]	; (8009d08 <pbuf_free+0x138>)
 8009cba:	4914      	ldr	r1, [pc, #80]	; (8009d0c <pbuf_free+0x13c>)
 8009cbc:	480d      	ldr	r0, [pc, #52]	; (8009cf4 <pbuf_free+0x124>)
 8009cbe:	f7f8 fe0d 	bl	80028dc <app_debug_rtt_raw>
        }
      }
      count++;
 8009cc2:	2117      	movs	r1, #23
 8009cc4:	187b      	adds	r3, r7, r1
 8009cc6:	781a      	ldrb	r2, [r3, #0]
 8009cc8:	187b      	adds	r3, r7, r1
 8009cca:	3201      	adds	r2, #1
 8009ccc:	701a      	strb	r2, [r3, #0]
      /* proceed to next pbuf */
      p = q;
 8009cce:	693b      	ldr	r3, [r7, #16]
 8009cd0:	607b      	str	r3, [r7, #4]
 8009cd2:	e001      	b.n	8009cd8 <pbuf_free+0x108>
      /* p->ref > 0, this pbuf is still referenced to */
      /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, (u16_t)ref));
      /* stop walking through the chain */
      p = NULL;
 8009cd4:	2300      	movs	r3, #0
 8009cd6:	607b      	str	r3, [r7, #4]
  while (p != NULL) {
 8009cd8:	687b      	ldr	r3, [r7, #4]
 8009cda:	2b00      	cmp	r3, #0
 8009cdc:	d190      	bne.n	8009c00 <pbuf_free+0x30>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
 8009cde:	2317      	movs	r3, #23
 8009ce0:	18fb      	adds	r3, r7, r3
 8009ce2:	781b      	ldrb	r3, [r3, #0]
}
 8009ce4:	0018      	movs	r0, r3
 8009ce6:	46bd      	mov	sp, r7
 8009ce8:	b006      	add	sp, #24
 8009cea:	bd80      	pop	{r7, pc}
 8009cec:	0801f4e8 	.word	0x0801f4e8
 8009cf0:	0801f648 	.word	0x0801f648
 8009cf4:	0801f540 	.word	0x0801f540
 8009cf8:	000002f1 	.word	0x000002f1
 8009cfc:	0801f674 	.word	0x0801f674
 8009d00:	000002ff 	.word	0x000002ff
 8009d04:	0801f68c 	.word	0x0801f68c
 8009d08:	0000030f 	.word	0x0000030f
 8009d0c:	0801f6b0 	.word	0x0801f6b0

08009d10 <pbuf_clen>:
 * @param p first pbuf of chain
 * @return the number of pbufs in a chain
 */
u16_t
pbuf_clen(const struct pbuf *p)
{
 8009d10:	b580      	push	{r7, lr}
 8009d12:	b084      	sub	sp, #16
 8009d14:	af00      	add	r7, sp, #0
 8009d16:	6078      	str	r0, [r7, #4]
  u16_t len;

  len = 0;
 8009d18:	230e      	movs	r3, #14
 8009d1a:	18fb      	adds	r3, r7, r3
 8009d1c:	2200      	movs	r2, #0
 8009d1e:	801a      	strh	r2, [r3, #0]
  while (p != NULL) {
 8009d20:	e008      	b.n	8009d34 <pbuf_clen+0x24>
    ++len;
 8009d22:	220e      	movs	r2, #14
 8009d24:	18bb      	adds	r3, r7, r2
 8009d26:	18ba      	adds	r2, r7, r2
 8009d28:	8812      	ldrh	r2, [r2, #0]
 8009d2a:	3201      	adds	r2, #1
 8009d2c:	801a      	strh	r2, [r3, #0]
    p = p->next;
 8009d2e:	687b      	ldr	r3, [r7, #4]
 8009d30:	681b      	ldr	r3, [r3, #0]
 8009d32:	607b      	str	r3, [r7, #4]
  while (p != NULL) {
 8009d34:	687b      	ldr	r3, [r7, #4]
 8009d36:	2b00      	cmp	r3, #0
 8009d38:	d1f3      	bne.n	8009d22 <pbuf_clen+0x12>
  }
  return len;
 8009d3a:	230e      	movs	r3, #14
 8009d3c:	18fb      	adds	r3, r7, r3
 8009d3e:	881b      	ldrh	r3, [r3, #0]
}
 8009d40:	0018      	movs	r0, r3
 8009d42:	46bd      	mov	sp, r7
 8009d44:	b004      	add	sp, #16
 8009d46:	bd80      	pop	{r7, pc}

08009d48 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
 8009d48:	b580      	push	{r7, lr}
 8009d4a:	b082      	sub	sp, #8
 8009d4c:	af00      	add	r7, sp, #0
 8009d4e:	6078      	str	r0, [r7, #4]
  /* pbuf given? */
  if (p != NULL) {
 8009d50:	687b      	ldr	r3, [r7, #4]
 8009d52:	2b00      	cmp	r3, #0
 8009d54:	d00f      	beq.n	8009d76 <pbuf_ref+0x2e>
    SYS_ARCH_SET(p->ref, (LWIP_PBUF_REF_T)(p->ref + 1));
 8009d56:	687b      	ldr	r3, [r7, #4]
 8009d58:	7b9b      	ldrb	r3, [r3, #14]
 8009d5a:	3301      	adds	r3, #1
 8009d5c:	b2da      	uxtb	r2, r3
 8009d5e:	687b      	ldr	r3, [r7, #4]
 8009d60:	739a      	strb	r2, [r3, #14]
    LWIP_ASSERT("pbuf ref overflow", p->ref > 0);
 8009d62:	687b      	ldr	r3, [r7, #4]
 8009d64:	7b9b      	ldrb	r3, [r3, #14]
 8009d66:	2b00      	cmp	r3, #0
 8009d68:	d105      	bne.n	8009d76 <pbuf_ref+0x2e>
 8009d6a:	4b05      	ldr	r3, [pc, #20]	; (8009d80 <pbuf_ref+0x38>)
 8009d6c:	4a05      	ldr	r2, [pc, #20]	; (8009d84 <pbuf_ref+0x3c>)
 8009d6e:	4906      	ldr	r1, [pc, #24]	; (8009d88 <pbuf_ref+0x40>)
 8009d70:	4806      	ldr	r0, [pc, #24]	; (8009d8c <pbuf_ref+0x44>)
 8009d72:	f7f8 fdb3 	bl	80028dc <app_debug_rtt_raw>
  }
}
 8009d76:	46c0      	nop			; (mov r8, r8)
 8009d78:	46bd      	mov	sp, r7
 8009d7a:	b002      	add	sp, #8
 8009d7c:	bd80      	pop	{r7, pc}
 8009d7e:	46c0      	nop			; (mov r8, r8)
 8009d80:	0801f4e8 	.word	0x0801f4e8
 8009d84:	00000342 	.word	0x00000342
 8009d88:	0801f6c4 	.word	0x0801f6c4
 8009d8c:	0801f540 	.word	0x0801f540

08009d90 <pbuf_cat>:
 *
 * @see pbuf_chain()
 */
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
 8009d90:	b580      	push	{r7, lr}
 8009d92:	b084      	sub	sp, #16
 8009d94:	af00      	add	r7, sp, #0
 8009d96:	6078      	str	r0, [r7, #4]
 8009d98:	6039      	str	r1, [r7, #0]
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 8009d9a:	687b      	ldr	r3, [r7, #4]
 8009d9c:	2b00      	cmp	r3, #0
 8009d9e:	d002      	beq.n	8009da6 <pbuf_cat+0x16>
 8009da0:	683b      	ldr	r3, [r7, #0]
 8009da2:	2b00      	cmp	r3, #0
 8009da4:	d104      	bne.n	8009db0 <pbuf_cat+0x20>
 8009da6:	4b1d      	ldr	r3, [pc, #116]	; (8009e1c <pbuf_cat+0x8c>)
 8009da8:	0018      	movs	r0, r3
 8009daa:	f7f8 fd97 	bl	80028dc <app_debug_rtt_raw>
 8009dae:	e032      	b.n	8009e16 <pbuf_cat+0x86>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 8009db0:	687b      	ldr	r3, [r7, #4]
 8009db2:	60fb      	str	r3, [r7, #12]
 8009db4:	e00a      	b.n	8009dcc <pbuf_cat+0x3c>
    /* add total length of second chain to all totals of first chain */
    p->tot_len = (u16_t)(p->tot_len + t->tot_len);
 8009db6:	68fb      	ldr	r3, [r7, #12]
 8009db8:	891a      	ldrh	r2, [r3, #8]
 8009dba:	683b      	ldr	r3, [r7, #0]
 8009dbc:	891b      	ldrh	r3, [r3, #8]
 8009dbe:	18d3      	adds	r3, r2, r3
 8009dc0:	b29a      	uxth	r2, r3
 8009dc2:	68fb      	ldr	r3, [r7, #12]
 8009dc4:	811a      	strh	r2, [r3, #8]
  for (p = h; p->next != NULL; p = p->next) {
 8009dc6:	68fb      	ldr	r3, [r7, #12]
 8009dc8:	681b      	ldr	r3, [r3, #0]
 8009dca:	60fb      	str	r3, [r7, #12]
 8009dcc:	68fb      	ldr	r3, [r7, #12]
 8009dce:	681b      	ldr	r3, [r3, #0]
 8009dd0:	2b00      	cmp	r3, #0
 8009dd2:	d1f0      	bne.n	8009db6 <pbuf_cat+0x26>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
 8009dd4:	68fb      	ldr	r3, [r7, #12]
 8009dd6:	891a      	ldrh	r2, [r3, #8]
 8009dd8:	68fb      	ldr	r3, [r7, #12]
 8009dda:	895b      	ldrh	r3, [r3, #10]
 8009ddc:	429a      	cmp	r2, r3
 8009dde:	d005      	beq.n	8009dec <pbuf_cat+0x5c>
 8009de0:	4b0f      	ldr	r3, [pc, #60]	; (8009e20 <pbuf_cat+0x90>)
 8009de2:	4a10      	ldr	r2, [pc, #64]	; (8009e24 <pbuf_cat+0x94>)
 8009de4:	4910      	ldr	r1, [pc, #64]	; (8009e28 <pbuf_cat+0x98>)
 8009de6:	4811      	ldr	r0, [pc, #68]	; (8009e2c <pbuf_cat+0x9c>)
 8009de8:	f7f8 fd78 	bl	80028dc <app_debug_rtt_raw>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
 8009dec:	68fb      	ldr	r3, [r7, #12]
 8009dee:	681b      	ldr	r3, [r3, #0]
 8009df0:	2b00      	cmp	r3, #0
 8009df2:	d005      	beq.n	8009e00 <pbuf_cat+0x70>
 8009df4:	4b0a      	ldr	r3, [pc, #40]	; (8009e20 <pbuf_cat+0x90>)
 8009df6:	4a0e      	ldr	r2, [pc, #56]	; (8009e30 <pbuf_cat+0xa0>)
 8009df8:	490e      	ldr	r1, [pc, #56]	; (8009e34 <pbuf_cat+0xa4>)
 8009dfa:	480c      	ldr	r0, [pc, #48]	; (8009e2c <pbuf_cat+0x9c>)
 8009dfc:	f7f8 fd6e 	bl	80028dc <app_debug_rtt_raw>
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len = (u16_t)(p->tot_len + t->tot_len);
 8009e00:	68fb      	ldr	r3, [r7, #12]
 8009e02:	891a      	ldrh	r2, [r3, #8]
 8009e04:	683b      	ldr	r3, [r7, #0]
 8009e06:	891b      	ldrh	r3, [r3, #8]
 8009e08:	18d3      	adds	r3, r2, r3
 8009e0a:	b29a      	uxth	r2, r3
 8009e0c:	68fb      	ldr	r3, [r7, #12]
 8009e0e:	811a      	strh	r2, [r3, #8]
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
 8009e10:	68fb      	ldr	r3, [r7, #12]
 8009e12:	683a      	ldr	r2, [r7, #0]
 8009e14:	601a      	str	r2, [r3, #0]
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
 8009e16:	46bd      	mov	sp, r7
 8009e18:	b004      	add	sp, #16
 8009e1a:	bd80      	pop	{r7, pc}
 8009e1c:	0801f6d8 	.word	0x0801f6d8
 8009e20:	0801f4e8 	.word	0x0801f4e8
 8009e24:	00000362 	.word	0x00000362
 8009e28:	0801f710 	.word	0x0801f710
 8009e2c:	0801f540 	.word	0x0801f540
 8009e30:	00000363 	.word	0x00000363
 8009e34:	0801f740 	.word	0x0801f740

08009e38 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
 8009e38:	b580      	push	{r7, lr}
 8009e3a:	b082      	sub	sp, #8
 8009e3c:	af00      	add	r7, sp, #0
 8009e3e:	6078      	str	r0, [r7, #4]
 8009e40:	6039      	str	r1, [r7, #0]
  pbuf_cat(h, t);
 8009e42:	683a      	ldr	r2, [r7, #0]
 8009e44:	687b      	ldr	r3, [r7, #4]
 8009e46:	0011      	movs	r1, r2
 8009e48:	0018      	movs	r0, r3
 8009e4a:	f7ff ffa1 	bl	8009d90 <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
 8009e4e:	683b      	ldr	r3, [r7, #0]
 8009e50:	0018      	movs	r0, r3
 8009e52:	f7ff ff79 	bl	8009d48 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
 8009e56:	46c0      	nop			; (mov r8, r8)
 8009e58:	46bd      	mov	sp, r7
 8009e5a:	b002      	add	sp, #8
 8009e5c:	bd80      	pop	{r7, pc}
	...

08009e60 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
 8009e60:	b590      	push	{r4, r7, lr}
 8009e62:	b085      	sub	sp, #20
 8009e64:	af00      	add	r7, sp, #0
 8009e66:	6078      	str	r0, [r7, #4]
  struct pbuf *q;
  u8_t tail_gone = 1;
 8009e68:	230f      	movs	r3, #15
 8009e6a:	18fb      	adds	r3, r7, r3
 8009e6c:	2201      	movs	r2, #1
 8009e6e:	701a      	strb	r2, [r3, #0]
  /* tail */
  q = p->next;
 8009e70:	687b      	ldr	r3, [r7, #4]
 8009e72:	681b      	ldr	r3, [r3, #0]
 8009e74:	60bb      	str	r3, [r7, #8]
  /* pbuf has successor in chain? */
  if (q != NULL) {
 8009e76:	68bb      	ldr	r3, [r7, #8]
 8009e78:	2b00      	cmp	r3, #0
 8009e7a:	d027      	beq.n	8009ecc <pbuf_dechain+0x6c>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
 8009e7c:	68bb      	ldr	r3, [r7, #8]
 8009e7e:	891b      	ldrh	r3, [r3, #8]
 8009e80:	001a      	movs	r2, r3
 8009e82:	687b      	ldr	r3, [r7, #4]
 8009e84:	891b      	ldrh	r3, [r3, #8]
 8009e86:	0019      	movs	r1, r3
 8009e88:	687b      	ldr	r3, [r7, #4]
 8009e8a:	895b      	ldrh	r3, [r3, #10]
 8009e8c:	1acb      	subs	r3, r1, r3
 8009e8e:	429a      	cmp	r2, r3
 8009e90:	d005      	beq.n	8009e9e <pbuf_dechain+0x3e>
 8009e92:	4b1a      	ldr	r3, [pc, #104]	; (8009efc <pbuf_dechain+0x9c>)
 8009e94:	4a1a      	ldr	r2, [pc, #104]	; (8009f00 <pbuf_dechain+0xa0>)
 8009e96:	491b      	ldr	r1, [pc, #108]	; (8009f04 <pbuf_dechain+0xa4>)
 8009e98:	481b      	ldr	r0, [pc, #108]	; (8009f08 <pbuf_dechain+0xa8>)
 8009e9a:	f7f8 fd1f 	bl	80028dc <app_debug_rtt_raw>
    /* enforce invariant if assertion is disabled */
    q->tot_len = (u16_t)(p->tot_len - p->len);
 8009e9e:	687b      	ldr	r3, [r7, #4]
 8009ea0:	891a      	ldrh	r2, [r3, #8]
 8009ea2:	687b      	ldr	r3, [r7, #4]
 8009ea4:	895b      	ldrh	r3, [r3, #10]
 8009ea6:	1ad3      	subs	r3, r2, r3
 8009ea8:	b29a      	uxth	r2, r3
 8009eaa:	68bb      	ldr	r3, [r7, #8]
 8009eac:	811a      	strh	r2, [r3, #8]
    /* decouple pbuf from remainder */
    p->next = NULL;
 8009eae:	687b      	ldr	r3, [r7, #4]
 8009eb0:	2200      	movs	r2, #0
 8009eb2:	601a      	str	r2, [r3, #0]
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
 8009eb4:	687b      	ldr	r3, [r7, #4]
 8009eb6:	895a      	ldrh	r2, [r3, #10]
 8009eb8:	687b      	ldr	r3, [r7, #4]
 8009eba:	811a      	strh	r2, [r3, #8]
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
 8009ebc:	230f      	movs	r3, #15
 8009ebe:	18fc      	adds	r4, r7, r3
 8009ec0:	68bb      	ldr	r3, [r7, #8]
 8009ec2:	0018      	movs	r0, r3
 8009ec4:	f7ff fe84 	bl	8009bd0 <pbuf_free>
 8009ec8:	0003      	movs	r3, r0
 8009eca:	7023      	strb	r3, [r4, #0]
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
 8009ecc:	687b      	ldr	r3, [r7, #4]
 8009ece:	891a      	ldrh	r2, [r3, #8]
 8009ed0:	687b      	ldr	r3, [r7, #4]
 8009ed2:	895b      	ldrh	r3, [r3, #10]
 8009ed4:	429a      	cmp	r2, r3
 8009ed6:	d005      	beq.n	8009ee4 <pbuf_dechain+0x84>
 8009ed8:	4b08      	ldr	r3, [pc, #32]	; (8009efc <pbuf_dechain+0x9c>)
 8009eda:	4a0c      	ldr	r2, [pc, #48]	; (8009f0c <pbuf_dechain+0xac>)
 8009edc:	490c      	ldr	r1, [pc, #48]	; (8009f10 <pbuf_dechain+0xb0>)
 8009ede:	480a      	ldr	r0, [pc, #40]	; (8009f08 <pbuf_dechain+0xa8>)
 8009ee0:	f7f8 fcfc 	bl	80028dc <app_debug_rtt_raw>
  return ((tail_gone > 0) ? NULL : q);
 8009ee4:	230f      	movs	r3, #15
 8009ee6:	18fb      	adds	r3, r7, r3
 8009ee8:	781b      	ldrb	r3, [r3, #0]
 8009eea:	2b00      	cmp	r3, #0
 8009eec:	d101      	bne.n	8009ef2 <pbuf_dechain+0x92>
 8009eee:	68bb      	ldr	r3, [r7, #8]
 8009ef0:	e000      	b.n	8009ef4 <pbuf_dechain+0x94>
 8009ef2:	2300      	movs	r3, #0
}
 8009ef4:	0018      	movs	r0, r3
 8009ef6:	46bd      	mov	sp, r7
 8009ef8:	b005      	add	sp, #20
 8009efa:	bd90      	pop	{r4, r7, pc}
 8009efc:	0801f4e8 	.word	0x0801f4e8
 8009f00:	00000399 	.word	0x00000399
 8009f04:	0801f750 	.word	0x0801f750
 8009f08:	0801f540 	.word	0x0801f540
 8009f0c:	000003aa 	.word	0x000003aa
 8009f10:	0801f774 	.word	0x0801f774

08009f14 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, const struct pbuf *p_from)
{
 8009f14:	b580      	push	{r7, lr}
 8009f16:	b082      	sub	sp, #8
 8009f18:	af00      	add	r7, sp, #0
 8009f1a:	6078      	str	r0, [r7, #4]
 8009f1c:	6039      	str	r1, [r7, #0]
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
              (const void *)p_to, (const void *)p_from));

  LWIP_ERROR("pbuf_copy: invalid source", p_from != NULL, return ERR_ARG;);
 8009f1e:	683b      	ldr	r3, [r7, #0]
 8009f20:	2b00      	cmp	r3, #0
 8009f22:	d106      	bne.n	8009f32 <pbuf_copy+0x1e>
 8009f24:	4b09      	ldr	r3, [pc, #36]	; (8009f4c <pbuf_copy+0x38>)
 8009f26:	0018      	movs	r0, r3
 8009f28:	f7f8 fcd8 	bl	80028dc <app_debug_rtt_raw>
 8009f2c:	2310      	movs	r3, #16
 8009f2e:	425b      	negs	r3, r3
 8009f30:	e007      	b.n	8009f42 <pbuf_copy+0x2e>
  return pbuf_copy_partial_pbuf(p_to, p_from, p_from->tot_len, 0);
 8009f32:	683b      	ldr	r3, [r7, #0]
 8009f34:	891a      	ldrh	r2, [r3, #8]
 8009f36:	6839      	ldr	r1, [r7, #0]
 8009f38:	6878      	ldr	r0, [r7, #4]
 8009f3a:	2300      	movs	r3, #0
 8009f3c:	f000 f808 	bl	8009f50 <pbuf_copy_partial_pbuf>
 8009f40:	0003      	movs	r3, r0
}
 8009f42:	0018      	movs	r0, r3
 8009f44:	46bd      	mov	sp, r7
 8009f46:	b002      	add	sp, #8
 8009f48:	bd80      	pop	{r7, pc}
 8009f4a:	46c0      	nop			; (mov r8, r8)
 8009f4c:	0801f78c 	.word	0x0801f78c

08009f50 <pbuf_copy_partial_pbuf>:
 *                 or p_to is not big enough to hold copy_len at offset
 *         ERR_VAL if any of the pbufs are part of a queue
 */
err_t
pbuf_copy_partial_pbuf(struct pbuf *p_to, const struct pbuf *p_from, u16_t copy_len, u16_t offset)
{
 8009f50:	b590      	push	{r4, r7, lr}
 8009f52:	b089      	sub	sp, #36	; 0x24
 8009f54:	af00      	add	r7, sp, #0
 8009f56:	60f8      	str	r0, [r7, #12]
 8009f58:	60b9      	str	r1, [r7, #8]
 8009f5a:	0019      	movs	r1, r3
 8009f5c:	1dbb      	adds	r3, r7, #6
 8009f5e:	801a      	strh	r2, [r3, #0]
 8009f60:	1d3b      	adds	r3, r7, #4
 8009f62:	1c0a      	adds	r2, r1, #0
 8009f64:	801a      	strh	r2, [r3, #0]
  size_t offset_to = offset, offset_from = 0, len_calc;
 8009f66:	1d3b      	adds	r3, r7, #4
 8009f68:	881b      	ldrh	r3, [r3, #0]
 8009f6a:	61fb      	str	r3, [r7, #28]
 8009f6c:	2300      	movs	r3, #0
 8009f6e:	61bb      	str	r3, [r7, #24]

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy_partial_pbuf(%p, %p, %"U16_F", %"U16_F")\n",
              (const void *)p_to, (const void *)p_from, copy_len, offset));

  /* is the copy_len in range? */
  LWIP_ERROR("pbuf_copy_partial_pbuf: copy_len bigger than source", ((p_from != NULL) &&
 8009f70:	68bb      	ldr	r3, [r7, #8]
 8009f72:	2b00      	cmp	r3, #0
 8009f74:	d005      	beq.n	8009f82 <pbuf_copy_partial_pbuf+0x32>
 8009f76:	68bb      	ldr	r3, [r7, #8]
 8009f78:	891b      	ldrh	r3, [r3, #8]
 8009f7a:	1dba      	adds	r2, r7, #6
 8009f7c:	8812      	ldrh	r2, [r2, #0]
 8009f7e:	429a      	cmp	r2, r3
 8009f80:	d906      	bls.n	8009f90 <pbuf_copy_partial_pbuf+0x40>
 8009f82:	4b6d      	ldr	r3, [pc, #436]	; (800a138 <pbuf_copy_partial_pbuf+0x1e8>)
 8009f84:	0018      	movs	r0, r3
 8009f86:	f7f8 fca9 	bl	80028dc <app_debug_rtt_raw>
 8009f8a:	2310      	movs	r3, #16
 8009f8c:	425b      	negs	r3, r3
 8009f8e:	e0cf      	b.n	800a130 <pbuf_copy_partial_pbuf+0x1e0>
             (p_from->tot_len >= copy_len)), return ERR_ARG;);
  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy_partial_pbuf: target not big enough", ((p_to != NULL) &&
 8009f90:	68fb      	ldr	r3, [r7, #12]
 8009f92:	2b00      	cmp	r3, #0
 8009f94:	d009      	beq.n	8009faa <pbuf_copy_partial_pbuf+0x5a>
 8009f96:	68fb      	ldr	r3, [r7, #12]
 8009f98:	891b      	ldrh	r3, [r3, #8]
 8009f9a:	0019      	movs	r1, r3
 8009f9c:	1d3b      	adds	r3, r7, #4
 8009f9e:	881a      	ldrh	r2, [r3, #0]
 8009fa0:	1dbb      	adds	r3, r7, #6
 8009fa2:	881b      	ldrh	r3, [r3, #0]
 8009fa4:	18d3      	adds	r3, r2, r3
 8009fa6:	4299      	cmp	r1, r3
 8009fa8:	da06      	bge.n	8009fb8 <pbuf_copy_partial_pbuf+0x68>
 8009faa:	4b64      	ldr	r3, [pc, #400]	; (800a13c <pbuf_copy_partial_pbuf+0x1ec>)
 8009fac:	0018      	movs	r0, r3
 8009fae:	f7f8 fc95 	bl	80028dc <app_debug_rtt_raw>
 8009fb2:	2310      	movs	r3, #16
 8009fb4:	425b      	negs	r3, r3
 8009fb6:	e0bb      	b.n	800a130 <pbuf_copy_partial_pbuf+0x1e0>
             (p_to->tot_len >= (offset + copy_len))), return ERR_ARG;);

  /* iterate through pbuf chain */
  do {
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
 8009fb8:	68fb      	ldr	r3, [r7, #12]
 8009fba:	895b      	ldrh	r3, [r3, #10]
 8009fbc:	001a      	movs	r2, r3
 8009fbe:	69fb      	ldr	r3, [r7, #28]
 8009fc0:	1ad2      	subs	r2, r2, r3
 8009fc2:	68bb      	ldr	r3, [r7, #8]
 8009fc4:	895b      	ldrh	r3, [r3, #10]
 8009fc6:	0019      	movs	r1, r3
 8009fc8:	69bb      	ldr	r3, [r7, #24]
 8009fca:	1acb      	subs	r3, r1, r3
 8009fcc:	429a      	cmp	r2, r3
 8009fce:	d306      	bcc.n	8009fde <pbuf_copy_partial_pbuf+0x8e>
      /* complete current p_from fits into current p_to */
      len_calc = p_from->len - offset_from;
 8009fd0:	68bb      	ldr	r3, [r7, #8]
 8009fd2:	895b      	ldrh	r3, [r3, #10]
 8009fd4:	001a      	movs	r2, r3
 8009fd6:	69bb      	ldr	r3, [r7, #24]
 8009fd8:	1ad3      	subs	r3, r2, r3
 8009fda:	617b      	str	r3, [r7, #20]
 8009fdc:	e005      	b.n	8009fea <pbuf_copy_partial_pbuf+0x9a>
    } else {
      /* current p_from does not fit into current p_to */
      len_calc = p_to->len - offset_to;
 8009fde:	68fb      	ldr	r3, [r7, #12]
 8009fe0:	895b      	ldrh	r3, [r3, #10]
 8009fe2:	001a      	movs	r2, r3
 8009fe4:	69fb      	ldr	r3, [r7, #28]
 8009fe6:	1ad3      	subs	r3, r2, r3
 8009fe8:	617b      	str	r3, [r7, #20]
    }
    len = (u16_t)LWIP_MIN(copy_len, len_calc);
 8009fea:	1dbb      	adds	r3, r7, #6
 8009fec:	881b      	ldrh	r3, [r3, #0]
 8009fee:	697a      	ldr	r2, [r7, #20]
 8009ff0:	429a      	cmp	r2, r3
 8009ff2:	d802      	bhi.n	8009ffa <pbuf_copy_partial_pbuf+0xaa>
 8009ff4:	697b      	ldr	r3, [r7, #20]
 8009ff6:	b29b      	uxth	r3, r3
 8009ff8:	e001      	b.n	8009ffe <pbuf_copy_partial_pbuf+0xae>
 8009ffa:	1dbb      	adds	r3, r7, #6
 8009ffc:	881b      	ldrh	r3, [r3, #0]
 8009ffe:	2412      	movs	r4, #18
 800a000:	193a      	adds	r2, r7, r4
 800a002:	8013      	strh	r3, [r2, #0]
    MEMCPY((u8_t *)p_to->payload + offset_to, (u8_t *)p_from->payload + offset_from, len);
 800a004:	68fb      	ldr	r3, [r7, #12]
 800a006:	685a      	ldr	r2, [r3, #4]
 800a008:	69fb      	ldr	r3, [r7, #28]
 800a00a:	18d0      	adds	r0, r2, r3
 800a00c:	68bb      	ldr	r3, [r7, #8]
 800a00e:	685a      	ldr	r2, [r3, #4]
 800a010:	69bb      	ldr	r3, [r7, #24]
 800a012:	18d1      	adds	r1, r2, r3
 800a014:	193b      	adds	r3, r7, r4
 800a016:	881b      	ldrh	r3, [r3, #0]
 800a018:	001a      	movs	r2, r3
 800a01a:	f012 fde1 	bl	801cbe0 <memcpy>
    offset_to += len;
 800a01e:	193b      	adds	r3, r7, r4
 800a020:	881b      	ldrh	r3, [r3, #0]
 800a022:	69fa      	ldr	r2, [r7, #28]
 800a024:	18d3      	adds	r3, r2, r3
 800a026:	61fb      	str	r3, [r7, #28]
    offset_from += len;
 800a028:	193b      	adds	r3, r7, r4
 800a02a:	881b      	ldrh	r3, [r3, #0]
 800a02c:	69ba      	ldr	r2, [r7, #24]
 800a02e:	18d3      	adds	r3, r2, r3
 800a030:	61bb      	str	r3, [r7, #24]
    copy_len -= len;
 800a032:	1dbb      	adds	r3, r7, #6
 800a034:	1db9      	adds	r1, r7, #6
 800a036:	193a      	adds	r2, r7, r4
 800a038:	8809      	ldrh	r1, [r1, #0]
 800a03a:	8812      	ldrh	r2, [r2, #0]
 800a03c:	1a8a      	subs	r2, r1, r2
 800a03e:	801a      	strh	r2, [r3, #0]
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 800a040:	68fb      	ldr	r3, [r7, #12]
 800a042:	895b      	ldrh	r3, [r3, #10]
 800a044:	001a      	movs	r2, r3
 800a046:	69fb      	ldr	r3, [r7, #28]
 800a048:	4293      	cmp	r3, r2
 800a04a:	d905      	bls.n	800a058 <pbuf_copy_partial_pbuf+0x108>
 800a04c:	4b3c      	ldr	r3, [pc, #240]	; (800a140 <pbuf_copy_partial_pbuf+0x1f0>)
 800a04e:	4a3d      	ldr	r2, [pc, #244]	; (800a144 <pbuf_copy_partial_pbuf+0x1f4>)
 800a050:	493d      	ldr	r1, [pc, #244]	; (800a148 <pbuf_copy_partial_pbuf+0x1f8>)
 800a052:	483e      	ldr	r0, [pc, #248]	; (800a14c <pbuf_copy_partial_pbuf+0x1fc>)
 800a054:	f7f8 fc42 	bl	80028dc <app_debug_rtt_raw>
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
 800a058:	68bb      	ldr	r3, [r7, #8]
 800a05a:	895b      	ldrh	r3, [r3, #10]
 800a05c:	001a      	movs	r2, r3
 800a05e:	69bb      	ldr	r3, [r7, #24]
 800a060:	4293      	cmp	r3, r2
 800a062:	d905      	bls.n	800a070 <pbuf_copy_partial_pbuf+0x120>
 800a064:	4b36      	ldr	r3, [pc, #216]	; (800a140 <pbuf_copy_partial_pbuf+0x1f0>)
 800a066:	4a3a      	ldr	r2, [pc, #232]	; (800a150 <pbuf_copy_partial_pbuf+0x200>)
 800a068:	493a      	ldr	r1, [pc, #232]	; (800a154 <pbuf_copy_partial_pbuf+0x204>)
 800a06a:	4838      	ldr	r0, [pc, #224]	; (800a14c <pbuf_copy_partial_pbuf+0x1fc>)
 800a06c:	f7f8 fc36 	bl	80028dc <app_debug_rtt_raw>
    if (offset_from >= p_from->len) {
 800a070:	68bb      	ldr	r3, [r7, #8]
 800a072:	895b      	ldrh	r3, [r3, #10]
 800a074:	001a      	movs	r2, r3
 800a076:	69bb      	ldr	r3, [r7, #24]
 800a078:	4293      	cmp	r3, r2
 800a07a:	d312      	bcc.n	800a0a2 <pbuf_copy_partial_pbuf+0x152>
      /* on to next p_from (if any) */
      offset_from = 0;
 800a07c:	2300      	movs	r3, #0
 800a07e:	61bb      	str	r3, [r7, #24]
      p_from = p_from->next;
 800a080:	68bb      	ldr	r3, [r7, #8]
 800a082:	681b      	ldr	r3, [r3, #0]
 800a084:	60bb      	str	r3, [r7, #8]
      LWIP_ERROR("p_from != NULL", (p_from != NULL) || (copy_len == 0), return ERR_ARG;);
 800a086:	68bb      	ldr	r3, [r7, #8]
 800a088:	2b00      	cmp	r3, #0
 800a08a:	d10a      	bne.n	800a0a2 <pbuf_copy_partial_pbuf+0x152>
 800a08c:	1dbb      	adds	r3, r7, #6
 800a08e:	881b      	ldrh	r3, [r3, #0]
 800a090:	2b00      	cmp	r3, #0
 800a092:	d006      	beq.n	800a0a2 <pbuf_copy_partial_pbuf+0x152>
 800a094:	4b30      	ldr	r3, [pc, #192]	; (800a158 <pbuf_copy_partial_pbuf+0x208>)
 800a096:	0018      	movs	r0, r3
 800a098:	f7f8 fc20 	bl	80028dc <app_debug_rtt_raw>
 800a09c:	2310      	movs	r3, #16
 800a09e:	425b      	negs	r3, r3
 800a0a0:	e046      	b.n	800a130 <pbuf_copy_partial_pbuf+0x1e0>
    }
    if (offset_to == p_to->len) {
 800a0a2:	68fb      	ldr	r3, [r7, #12]
 800a0a4:	895b      	ldrh	r3, [r3, #10]
 800a0a6:	001a      	movs	r2, r3
 800a0a8:	69fb      	ldr	r3, [r7, #28]
 800a0aa:	4293      	cmp	r3, r2
 800a0ac:	d112      	bne.n	800a0d4 <pbuf_copy_partial_pbuf+0x184>
      /* on to next p_to (if any) */
      offset_to = 0;
 800a0ae:	2300      	movs	r3, #0
 800a0b0:	61fb      	str	r3, [r7, #28]
      p_to = p_to->next;
 800a0b2:	68fb      	ldr	r3, [r7, #12]
 800a0b4:	681b      	ldr	r3, [r3, #0]
 800a0b6:	60fb      	str	r3, [r7, #12]
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (copy_len == 0), return ERR_ARG;);
 800a0b8:	68fb      	ldr	r3, [r7, #12]
 800a0ba:	2b00      	cmp	r3, #0
 800a0bc:	d10a      	bne.n	800a0d4 <pbuf_copy_partial_pbuf+0x184>
 800a0be:	1dbb      	adds	r3, r7, #6
 800a0c0:	881b      	ldrh	r3, [r3, #0]
 800a0c2:	2b00      	cmp	r3, #0
 800a0c4:	d006      	beq.n	800a0d4 <pbuf_copy_partial_pbuf+0x184>
 800a0c6:	4b25      	ldr	r3, [pc, #148]	; (800a15c <pbuf_copy_partial_pbuf+0x20c>)
 800a0c8:	0018      	movs	r0, r3
 800a0ca:	f7f8 fc07 	bl	80028dc <app_debug_rtt_raw>
 800a0ce:	2310      	movs	r3, #16
 800a0d0:	425b      	negs	r3, r3
 800a0d2:	e02d      	b.n	800a130 <pbuf_copy_partial_pbuf+0x1e0>
    }

    if ((p_from != NULL) && (p_from->len == p_from->tot_len)) {
 800a0d4:	68bb      	ldr	r3, [r7, #8]
 800a0d6:	2b00      	cmp	r3, #0
 800a0d8:	d010      	beq.n	800a0fc <pbuf_copy_partial_pbuf+0x1ac>
 800a0da:	68bb      	ldr	r3, [r7, #8]
 800a0dc:	895a      	ldrh	r2, [r3, #10]
 800a0de:	68bb      	ldr	r3, [r7, #8]
 800a0e0:	891b      	ldrh	r3, [r3, #8]
 800a0e2:	429a      	cmp	r2, r3
 800a0e4:	d10a      	bne.n	800a0fc <pbuf_copy_partial_pbuf+0x1ac>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy_partial_pbuf() does not allow packet queues!",
 800a0e6:	68bb      	ldr	r3, [r7, #8]
 800a0e8:	681b      	ldr	r3, [r3, #0]
 800a0ea:	2b00      	cmp	r3, #0
 800a0ec:	d006      	beq.n	800a0fc <pbuf_copy_partial_pbuf+0x1ac>
 800a0ee:	4b1c      	ldr	r3, [pc, #112]	; (800a160 <pbuf_copy_partial_pbuf+0x210>)
 800a0f0:	0018      	movs	r0, r3
 800a0f2:	f7f8 fbf3 	bl	80028dc <app_debug_rtt_raw>
 800a0f6:	2306      	movs	r3, #6
 800a0f8:	425b      	negs	r3, r3
 800a0fa:	e019      	b.n	800a130 <pbuf_copy_partial_pbuf+0x1e0>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if ((p_to != NULL) && (p_to->len == p_to->tot_len)) {
 800a0fc:	68fb      	ldr	r3, [r7, #12]
 800a0fe:	2b00      	cmp	r3, #0
 800a100:	d010      	beq.n	800a124 <pbuf_copy_partial_pbuf+0x1d4>
 800a102:	68fb      	ldr	r3, [r7, #12]
 800a104:	895a      	ldrh	r2, [r3, #10]
 800a106:	68fb      	ldr	r3, [r7, #12]
 800a108:	891b      	ldrh	r3, [r3, #8]
 800a10a:	429a      	cmp	r2, r3
 800a10c:	d10a      	bne.n	800a124 <pbuf_copy_partial_pbuf+0x1d4>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy_partial_pbuf() does not allow packet queues!",
 800a10e:	68fb      	ldr	r3, [r7, #12]
 800a110:	681b      	ldr	r3, [r3, #0]
 800a112:	2b00      	cmp	r3, #0
 800a114:	d006      	beq.n	800a124 <pbuf_copy_partial_pbuf+0x1d4>
 800a116:	4b12      	ldr	r3, [pc, #72]	; (800a160 <pbuf_copy_partial_pbuf+0x210>)
 800a118:	0018      	movs	r0, r3
 800a11a:	f7f8 fbdf 	bl	80028dc <app_debug_rtt_raw>
 800a11e:	2306      	movs	r3, #6
 800a120:	425b      	negs	r3, r3
 800a122:	e005      	b.n	800a130 <pbuf_copy_partial_pbuf+0x1e0>
                 (p_to->next == NULL), return ERR_VAL;);
    }
  } while (copy_len);
 800a124:	1dbb      	adds	r3, r7, #6
 800a126:	881b      	ldrh	r3, [r3, #0]
 800a128:	2b00      	cmp	r3, #0
 800a12a:	d000      	beq.n	800a12e <pbuf_copy_partial_pbuf+0x1de>
 800a12c:	e744      	b.n	8009fb8 <pbuf_copy_partial_pbuf+0x68>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy_partial_pbuf: copy complete.\n"));
  return ERR_OK;
 800a12e:	2300      	movs	r3, #0
}
 800a130:	0018      	movs	r0, r3
 800a132:	46bd      	mov	sp, r7
 800a134:	b009      	add	sp, #36	; 0x24
 800a136:	bd90      	pop	{r4, r7, pc}
 800a138:	0801f7a8 	.word	0x0801f7a8
 800a13c:	0801f7dc 	.word	0x0801f7dc
 800a140:	0801f4e8 	.word	0x0801f4e8
 800a144:	000003fa 	.word	0x000003fa
 800a148:	0801f80c 	.word	0x0801f80c
 800a14c:	0801f540 	.word	0x0801f540
 800a150:	000003fb 	.word	0x000003fb
 800a154:	0801f824 	.word	0x0801f824
 800a158:	0801f840 	.word	0x0801f840
 800a15c:	0801f850 	.word	0x0801f850
 800a160:	0801f860 	.word	0x0801f860

0800a164 <pbuf_copy_partial>:
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t
pbuf_copy_partial(const struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
 800a164:	b5b0      	push	{r4, r5, r7, lr}
 800a166:	b088      	sub	sp, #32
 800a168:	af00      	add	r7, sp, #0
 800a16a:	60f8      	str	r0, [r7, #12]
 800a16c:	60b9      	str	r1, [r7, #8]
 800a16e:	0019      	movs	r1, r3
 800a170:	1dbb      	adds	r3, r7, #6
 800a172:	801a      	strh	r2, [r3, #0]
 800a174:	1d3b      	adds	r3, r7, #4
 800a176:	1c0a      	adds	r2, r1, #0
 800a178:	801a      	strh	r2, [r3, #0]
  const struct pbuf *p;
  u16_t left = 0;
 800a17a:	231a      	movs	r3, #26
 800a17c:	18fb      	adds	r3, r7, r3
 800a17e:	2200      	movs	r2, #0
 800a180:	801a      	strh	r2, [r3, #0]
  u16_t buf_copy_len;
  u16_t copied_total = 0;
 800a182:	2316      	movs	r3, #22
 800a184:	18fb      	adds	r3, r7, r3
 800a186:	2200      	movs	r2, #0
 800a188:	801a      	strh	r2, [r3, #0]

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 800a18a:	68fb      	ldr	r3, [r7, #12]
 800a18c:	2b00      	cmp	r3, #0
 800a18e:	d105      	bne.n	800a19c <pbuf_copy_partial+0x38>
 800a190:	4b38      	ldr	r3, [pc, #224]	; (800a274 <pbuf_copy_partial+0x110>)
 800a192:	0018      	movs	r0, r3
 800a194:	f7f8 fba2 	bl	80028dc <app_debug_rtt_raw>
 800a198:	2300      	movs	r3, #0
 800a19a:	e066      	b.n	800a26a <pbuf_copy_partial+0x106>
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 800a19c:	68bb      	ldr	r3, [r7, #8]
 800a19e:	2b00      	cmp	r3, #0
 800a1a0:	d105      	bne.n	800a1ae <pbuf_copy_partial+0x4a>
 800a1a2:	4b35      	ldr	r3, [pc, #212]	; (800a278 <pbuf_copy_partial+0x114>)
 800a1a4:	0018      	movs	r0, r3
 800a1a6:	f7f8 fb99 	bl	80028dc <app_debug_rtt_raw>
 800a1aa:	2300      	movs	r3, #0
 800a1ac:	e05d      	b.n	800a26a <pbuf_copy_partial+0x106>

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for (p = buf; len != 0 && p != NULL; p = p->next) {
 800a1ae:	68fb      	ldr	r3, [r7, #12]
 800a1b0:	61fb      	str	r3, [r7, #28]
 800a1b2:	e050      	b.n	800a256 <pbuf_copy_partial+0xf2>
    if ((offset != 0) && (offset >= p->len)) {
 800a1b4:	1d3b      	adds	r3, r7, #4
 800a1b6:	881b      	ldrh	r3, [r3, #0]
 800a1b8:	2b00      	cmp	r3, #0
 800a1ba:	d00d      	beq.n	800a1d8 <pbuf_copy_partial+0x74>
 800a1bc:	69fb      	ldr	r3, [r7, #28]
 800a1be:	895b      	ldrh	r3, [r3, #10]
 800a1c0:	1d3a      	adds	r2, r7, #4
 800a1c2:	8812      	ldrh	r2, [r2, #0]
 800a1c4:	429a      	cmp	r2, r3
 800a1c6:	d307      	bcc.n	800a1d8 <pbuf_copy_partial+0x74>
      /* don't copy from this buffer -> on to the next */
      offset = (u16_t)(offset - p->len);
 800a1c8:	69fb      	ldr	r3, [r7, #28]
 800a1ca:	895a      	ldrh	r2, [r3, #10]
 800a1cc:	1d3b      	adds	r3, r7, #4
 800a1ce:	1d39      	adds	r1, r7, #4
 800a1d0:	8809      	ldrh	r1, [r1, #0]
 800a1d2:	1a8a      	subs	r2, r1, r2
 800a1d4:	801a      	strh	r2, [r3, #0]
 800a1d6:	e03b      	b.n	800a250 <pbuf_copy_partial+0xec>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = (u16_t)(p->len - offset);
 800a1d8:	69fb      	ldr	r3, [r7, #28]
 800a1da:	8959      	ldrh	r1, [r3, #10]
 800a1dc:	2018      	movs	r0, #24
 800a1de:	183b      	adds	r3, r7, r0
 800a1e0:	1d3a      	adds	r2, r7, #4
 800a1e2:	8812      	ldrh	r2, [r2, #0]
 800a1e4:	1a8a      	subs	r2, r1, r2
 800a1e6:	801a      	strh	r2, [r3, #0]
      if (buf_copy_len > len) {
 800a1e8:	183a      	adds	r2, r7, r0
 800a1ea:	1dbb      	adds	r3, r7, #6
 800a1ec:	8812      	ldrh	r2, [r2, #0]
 800a1ee:	881b      	ldrh	r3, [r3, #0]
 800a1f0:	429a      	cmp	r2, r3
 800a1f2:	d903      	bls.n	800a1fc <pbuf_copy_partial+0x98>
        buf_copy_len = len;
 800a1f4:	183b      	adds	r3, r7, r0
 800a1f6:	1dba      	adds	r2, r7, #6
 800a1f8:	8812      	ldrh	r2, [r2, #0]
 800a1fa:	801a      	strh	r2, [r3, #0]
      }
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char *)dataptr)[left], &((char *)p->payload)[offset], buf_copy_len);
 800a1fc:	251a      	movs	r5, #26
 800a1fe:	197b      	adds	r3, r7, r5
 800a200:	881b      	ldrh	r3, [r3, #0]
 800a202:	68ba      	ldr	r2, [r7, #8]
 800a204:	18d0      	adds	r0, r2, r3
 800a206:	69fb      	ldr	r3, [r7, #28]
 800a208:	685a      	ldr	r2, [r3, #4]
 800a20a:	1d3b      	adds	r3, r7, #4
 800a20c:	881b      	ldrh	r3, [r3, #0]
 800a20e:	18d1      	adds	r1, r2, r3
 800a210:	2418      	movs	r4, #24
 800a212:	193b      	adds	r3, r7, r4
 800a214:	881b      	ldrh	r3, [r3, #0]
 800a216:	001a      	movs	r2, r3
 800a218:	f012 fce2 	bl	801cbe0 <memcpy>
      copied_total = (u16_t)(copied_total + buf_copy_len);
 800a21c:	2216      	movs	r2, #22
 800a21e:	18bb      	adds	r3, r7, r2
 800a220:	18b9      	adds	r1, r7, r2
 800a222:	0020      	movs	r0, r4
 800a224:	183a      	adds	r2, r7, r0
 800a226:	8809      	ldrh	r1, [r1, #0]
 800a228:	8812      	ldrh	r2, [r2, #0]
 800a22a:	188a      	adds	r2, r1, r2
 800a22c:	801a      	strh	r2, [r3, #0]
      left = (u16_t)(left + buf_copy_len);
 800a22e:	197b      	adds	r3, r7, r5
 800a230:	1979      	adds	r1, r7, r5
 800a232:	183a      	adds	r2, r7, r0
 800a234:	8809      	ldrh	r1, [r1, #0]
 800a236:	8812      	ldrh	r2, [r2, #0]
 800a238:	188a      	adds	r2, r1, r2
 800a23a:	801a      	strh	r2, [r3, #0]
      len = (u16_t)(len - buf_copy_len);
 800a23c:	1dbb      	adds	r3, r7, #6
 800a23e:	1db9      	adds	r1, r7, #6
 800a240:	183a      	adds	r2, r7, r0
 800a242:	8809      	ldrh	r1, [r1, #0]
 800a244:	8812      	ldrh	r2, [r2, #0]
 800a246:	1a8a      	subs	r2, r1, r2
 800a248:	801a      	strh	r2, [r3, #0]
      offset = 0;
 800a24a:	1d3b      	adds	r3, r7, #4
 800a24c:	2200      	movs	r2, #0
 800a24e:	801a      	strh	r2, [r3, #0]
  for (p = buf; len != 0 && p != NULL; p = p->next) {
 800a250:	69fb      	ldr	r3, [r7, #28]
 800a252:	681b      	ldr	r3, [r3, #0]
 800a254:	61fb      	str	r3, [r7, #28]
 800a256:	1dbb      	adds	r3, r7, #6
 800a258:	881b      	ldrh	r3, [r3, #0]
 800a25a:	2b00      	cmp	r3, #0
 800a25c:	d002      	beq.n	800a264 <pbuf_copy_partial+0x100>
 800a25e:	69fb      	ldr	r3, [r7, #28]
 800a260:	2b00      	cmp	r3, #0
 800a262:	d1a7      	bne.n	800a1b4 <pbuf_copy_partial+0x50>
    }
  }
  return copied_total;
 800a264:	2316      	movs	r3, #22
 800a266:	18fb      	adds	r3, r7, r3
 800a268:	881b      	ldrh	r3, [r3, #0]
}
 800a26a:	0018      	movs	r0, r3
 800a26c:	46bd      	mov	sp, r7
 800a26e:	b008      	add	sp, #32
 800a270:	bdb0      	pop	{r4, r5, r7, pc}
 800a272:	46c0      	nop			; (mov r8, r8)
 800a274:	0801f898 	.word	0x0801f898
 800a278:	0801f8b8 	.word	0x0801f8b8

0800a27c <pbuf_skip_const>:
#endif /* LWIP_TCP && TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */

/* Actual implementation of pbuf_skip() but returning const pointer... */
static const struct pbuf *
pbuf_skip_const(const struct pbuf *in, u16_t in_offset, u16_t *out_offset)
{
 800a27c:	b580      	push	{r7, lr}
 800a27e:	b086      	sub	sp, #24
 800a280:	af00      	add	r7, sp, #0
 800a282:	60f8      	str	r0, [r7, #12]
 800a284:	607a      	str	r2, [r7, #4]
 800a286:	200a      	movs	r0, #10
 800a288:	183b      	adds	r3, r7, r0
 800a28a:	1c0a      	adds	r2, r1, #0
 800a28c:	801a      	strh	r2, [r3, #0]
  u16_t offset_left = in_offset;
 800a28e:	2316      	movs	r3, #22
 800a290:	18fb      	adds	r3, r7, r3
 800a292:	183a      	adds	r2, r7, r0
 800a294:	8812      	ldrh	r2, [r2, #0]
 800a296:	801a      	strh	r2, [r3, #0]
  const struct pbuf *q = in;
 800a298:	68fb      	ldr	r3, [r7, #12]
 800a29a:	613b      	str	r3, [r7, #16]

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= offset_left)) {
 800a29c:	e00a      	b.n	800a2b4 <pbuf_skip_const+0x38>
    offset_left = (u16_t)(offset_left - q->len);
 800a29e:	693b      	ldr	r3, [r7, #16]
 800a2a0:	895a      	ldrh	r2, [r3, #10]
 800a2a2:	2116      	movs	r1, #22
 800a2a4:	187b      	adds	r3, r7, r1
 800a2a6:	1879      	adds	r1, r7, r1
 800a2a8:	8809      	ldrh	r1, [r1, #0]
 800a2aa:	1a8a      	subs	r2, r1, r2
 800a2ac:	801a      	strh	r2, [r3, #0]
    q = q->next;
 800a2ae:	693b      	ldr	r3, [r7, #16]
 800a2b0:	681b      	ldr	r3, [r3, #0]
 800a2b2:	613b      	str	r3, [r7, #16]
  while ((q != NULL) && (q->len <= offset_left)) {
 800a2b4:	693b      	ldr	r3, [r7, #16]
 800a2b6:	2b00      	cmp	r3, #0
 800a2b8:	d006      	beq.n	800a2c8 <pbuf_skip_const+0x4c>
 800a2ba:	693b      	ldr	r3, [r7, #16]
 800a2bc:	895b      	ldrh	r3, [r3, #10]
 800a2be:	2216      	movs	r2, #22
 800a2c0:	18ba      	adds	r2, r7, r2
 800a2c2:	8812      	ldrh	r2, [r2, #0]
 800a2c4:	429a      	cmp	r2, r3
 800a2c6:	d2ea      	bcs.n	800a29e <pbuf_skip_const+0x22>
  }
  if (out_offset != NULL) {
 800a2c8:	687b      	ldr	r3, [r7, #4]
 800a2ca:	2b00      	cmp	r3, #0
 800a2cc:	d004      	beq.n	800a2d8 <pbuf_skip_const+0x5c>
    *out_offset = offset_left;
 800a2ce:	687b      	ldr	r3, [r7, #4]
 800a2d0:	2216      	movs	r2, #22
 800a2d2:	18ba      	adds	r2, r7, r2
 800a2d4:	8812      	ldrh	r2, [r2, #0]
 800a2d6:	801a      	strh	r2, [r3, #0]
  }
  return q;
 800a2d8:	693b      	ldr	r3, [r7, #16]
}
 800a2da:	0018      	movs	r0, r3
 800a2dc:	46bd      	mov	sp, r7
 800a2de:	b006      	add	sp, #24
 800a2e0:	bd80      	pop	{r7, pc}

0800a2e2 <pbuf_skip>:
 * @param out_offset resulting offset in the returned pbuf
 * @return the pbuf in the queue where the offset is
 */
struct pbuf *
pbuf_skip(struct pbuf *in, u16_t in_offset, u16_t *out_offset)
{
 800a2e2:	b580      	push	{r7, lr}
 800a2e4:	b086      	sub	sp, #24
 800a2e6:	af00      	add	r7, sp, #0
 800a2e8:	60f8      	str	r0, [r7, #12]
 800a2ea:	607a      	str	r2, [r7, #4]
 800a2ec:	200a      	movs	r0, #10
 800a2ee:	183b      	adds	r3, r7, r0
 800a2f0:	1c0a      	adds	r2, r1, #0
 800a2f2:	801a      	strh	r2, [r3, #0]
  const struct pbuf *out = pbuf_skip_const(in, in_offset, out_offset);
 800a2f4:	687a      	ldr	r2, [r7, #4]
 800a2f6:	183b      	adds	r3, r7, r0
 800a2f8:	8819      	ldrh	r1, [r3, #0]
 800a2fa:	68fb      	ldr	r3, [r7, #12]
 800a2fc:	0018      	movs	r0, r3
 800a2fe:	f7ff ffbd 	bl	800a27c <pbuf_skip_const>
 800a302:	0003      	movs	r3, r0
 800a304:	617b      	str	r3, [r7, #20]
  return LWIP_CONST_CAST(struct pbuf *, out);
 800a306:	697b      	ldr	r3, [r7, #20]
}
 800a308:	0018      	movs	r0, r3
 800a30a:	46bd      	mov	sp, r7
 800a30c:	b006      	add	sp, #24
 800a30e:	bd80      	pop	{r7, pc}

0800a310 <pbuf_take>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
{
 800a310:	b580      	push	{r7, lr}
 800a312:	b088      	sub	sp, #32
 800a314:	af00      	add	r7, sp, #0
 800a316:	60f8      	str	r0, [r7, #12]
 800a318:	60b9      	str	r1, [r7, #8]
 800a31a:	1dbb      	adds	r3, r7, #6
 800a31c:	801a      	strh	r2, [r3, #0]
  struct pbuf *p;
  size_t buf_copy_len;
  size_t total_copy_len = len;
 800a31e:	1dbb      	adds	r3, r7, #6
 800a320:	881b      	ldrh	r3, [r3, #0]
 800a322:	617b      	str	r3, [r7, #20]
  size_t copied_total = 0;
 800a324:	2300      	movs	r3, #0
 800a326:	613b      	str	r3, [r7, #16]

  LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return ERR_ARG;);
 800a328:	68fb      	ldr	r3, [r7, #12]
 800a32a:	2b00      	cmp	r3, #0
 800a32c:	d106      	bne.n	800a33c <pbuf_take+0x2c>
 800a32e:	4b37      	ldr	r3, [pc, #220]	; (800a40c <pbuf_take+0xfc>)
 800a330:	0018      	movs	r0, r3
 800a332:	f7f8 fad3 	bl	80028dc <app_debug_rtt_raw>
 800a336:	2310      	movs	r3, #16
 800a338:	425b      	negs	r3, r3
 800a33a:	e062      	b.n	800a402 <pbuf_take+0xf2>
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
 800a33c:	68bb      	ldr	r3, [r7, #8]
 800a33e:	2b00      	cmp	r3, #0
 800a340:	d106      	bne.n	800a350 <pbuf_take+0x40>
 800a342:	4b33      	ldr	r3, [pc, #204]	; (800a410 <pbuf_take+0x100>)
 800a344:	0018      	movs	r0, r3
 800a346:	f7f8 fac9 	bl	80028dc <app_debug_rtt_raw>
 800a34a:	2310      	movs	r3, #16
 800a34c:	425b      	negs	r3, r3
 800a34e:	e058      	b.n	800a402 <pbuf_take+0xf2>
  LWIP_ERROR("pbuf_take: buf not large enough", (buf->tot_len >= len), return ERR_MEM;);
 800a350:	68fb      	ldr	r3, [r7, #12]
 800a352:	891b      	ldrh	r3, [r3, #8]
 800a354:	1dba      	adds	r2, r7, #6
 800a356:	8812      	ldrh	r2, [r2, #0]
 800a358:	429a      	cmp	r2, r3
 800a35a:	d906      	bls.n	800a36a <pbuf_take+0x5a>
 800a35c:	4b2d      	ldr	r3, [pc, #180]	; (800a414 <pbuf_take+0x104>)
 800a35e:	0018      	movs	r0, r3
 800a360:	f7f8 fabc 	bl	80028dc <app_debug_rtt_raw>
 800a364:	2301      	movs	r3, #1
 800a366:	425b      	negs	r3, r3
 800a368:	e04b      	b.n	800a402 <pbuf_take+0xf2>

  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
 800a36a:	68fb      	ldr	r3, [r7, #12]
 800a36c:	2b00      	cmp	r3, #0
 800a36e:	d008      	beq.n	800a382 <pbuf_take+0x72>
 800a370:	68bb      	ldr	r3, [r7, #8]
 800a372:	2b00      	cmp	r3, #0
 800a374:	d005      	beq.n	800a382 <pbuf_take+0x72>
 800a376:	68fb      	ldr	r3, [r7, #12]
 800a378:	891b      	ldrh	r3, [r3, #8]
 800a37a:	1dba      	adds	r2, r7, #6
 800a37c:	8812      	ldrh	r2, [r2, #0]
 800a37e:	429a      	cmp	r2, r3
 800a380:	d902      	bls.n	800a388 <pbuf_take+0x78>
    return ERR_ARG;
 800a382:	2310      	movs	r3, #16
 800a384:	425b      	negs	r3, r3
 800a386:	e03c      	b.n	800a402 <pbuf_take+0xf2>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for (p = buf; total_copy_len != 0; p = p->next) {
 800a388:	68fb      	ldr	r3, [r7, #12]
 800a38a:	61fb      	str	r3, [r7, #28]
 800a38c:	e027      	b.n	800a3de <pbuf_take+0xce>
    LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
 800a38e:	69fb      	ldr	r3, [r7, #28]
 800a390:	2b00      	cmp	r3, #0
 800a392:	d105      	bne.n	800a3a0 <pbuf_take+0x90>
 800a394:	4b20      	ldr	r3, [pc, #128]	; (800a418 <pbuf_take+0x108>)
 800a396:	4a21      	ldr	r2, [pc, #132]	; (800a41c <pbuf_take+0x10c>)
 800a398:	4921      	ldr	r1, [pc, #132]	; (800a420 <pbuf_take+0x110>)
 800a39a:	4822      	ldr	r0, [pc, #136]	; (800a424 <pbuf_take+0x114>)
 800a39c:	f7f8 fa9e 	bl	80028dc <app_debug_rtt_raw>
    buf_copy_len = total_copy_len;
 800a3a0:	697b      	ldr	r3, [r7, #20]
 800a3a2:	61bb      	str	r3, [r7, #24]
    if (buf_copy_len > p->len) {
 800a3a4:	69fb      	ldr	r3, [r7, #28]
 800a3a6:	895b      	ldrh	r3, [r3, #10]
 800a3a8:	001a      	movs	r2, r3
 800a3aa:	69bb      	ldr	r3, [r7, #24]
 800a3ac:	4293      	cmp	r3, r2
 800a3ae:	d902      	bls.n	800a3b6 <pbuf_take+0xa6>
      /* this pbuf cannot hold all remaining data */
      buf_copy_len = p->len;
 800a3b0:	69fb      	ldr	r3, [r7, #28]
 800a3b2:	895b      	ldrh	r3, [r3, #10]
 800a3b4:	61bb      	str	r3, [r7, #24]
    }
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((const char *)dataptr)[copied_total], buf_copy_len);
 800a3b6:	69fb      	ldr	r3, [r7, #28]
 800a3b8:	6858      	ldr	r0, [r3, #4]
 800a3ba:	68ba      	ldr	r2, [r7, #8]
 800a3bc:	693b      	ldr	r3, [r7, #16]
 800a3be:	18d3      	adds	r3, r2, r3
 800a3c0:	69ba      	ldr	r2, [r7, #24]
 800a3c2:	0019      	movs	r1, r3
 800a3c4:	f012 fc0c 	bl	801cbe0 <memcpy>
    total_copy_len -= buf_copy_len;
 800a3c8:	697a      	ldr	r2, [r7, #20]
 800a3ca:	69bb      	ldr	r3, [r7, #24]
 800a3cc:	1ad3      	subs	r3, r2, r3
 800a3ce:	617b      	str	r3, [r7, #20]
    copied_total += buf_copy_len;
 800a3d0:	693a      	ldr	r2, [r7, #16]
 800a3d2:	69bb      	ldr	r3, [r7, #24]
 800a3d4:	18d3      	adds	r3, r2, r3
 800a3d6:	613b      	str	r3, [r7, #16]
  for (p = buf; total_copy_len != 0; p = p->next) {
 800a3d8:	69fb      	ldr	r3, [r7, #28]
 800a3da:	681b      	ldr	r3, [r3, #0]
 800a3dc:	61fb      	str	r3, [r7, #28]
 800a3de:	697b      	ldr	r3, [r7, #20]
 800a3e0:	2b00      	cmp	r3, #0
 800a3e2:	d1d4      	bne.n	800a38e <pbuf_take+0x7e>
  }
  LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
 800a3e4:	697b      	ldr	r3, [r7, #20]
 800a3e6:	2b00      	cmp	r3, #0
 800a3e8:	d104      	bne.n	800a3f4 <pbuf_take+0xe4>
 800a3ea:	1dbb      	adds	r3, r7, #6
 800a3ec:	881b      	ldrh	r3, [r3, #0]
 800a3ee:	693a      	ldr	r2, [r7, #16]
 800a3f0:	429a      	cmp	r2, r3
 800a3f2:	d005      	beq.n	800a400 <pbuf_take+0xf0>
 800a3f4:	4b08      	ldr	r3, [pc, #32]	; (800a418 <pbuf_take+0x108>)
 800a3f6:	4a0c      	ldr	r2, [pc, #48]	; (800a428 <pbuf_take+0x118>)
 800a3f8:	490c      	ldr	r1, [pc, #48]	; (800a42c <pbuf_take+0x11c>)
 800a3fa:	480a      	ldr	r0, [pc, #40]	; (800a424 <pbuf_take+0x114>)
 800a3fc:	f7f8 fa6e 	bl	80028dc <app_debug_rtt_raw>
  return ERR_OK;
 800a400:	2300      	movs	r3, #0
}
 800a402:	0018      	movs	r0, r3
 800a404:	46bd      	mov	sp, r7
 800a406:	b008      	add	sp, #32
 800a408:	bd80      	pop	{r7, pc}
 800a40a:	46c0      	nop			; (mov r8, r8)
 800a40c:	0801f928 	.word	0x0801f928
 800a410:	0801f940 	.word	0x0801f940
 800a414:	0801f95c 	.word	0x0801f95c
 800a418:	0801f4e8 	.word	0x0801f4e8
 800a41c:	000004df 	.word	0x000004df
 800a420:	0801f97c 	.word	0x0801f97c
 800a424:	0801f540 	.word	0x0801f540
 800a428:	000004ea 	.word	0x000004ea
 800a42c:	0801f994 	.word	0x0801f994

0800a430 <pbuf_take_at>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take_at(struct pbuf *buf, const void *dataptr, u16_t len, u16_t offset)
{
 800a430:	b590      	push	{r4, r7, lr}
 800a432:	b089      	sub	sp, #36	; 0x24
 800a434:	af00      	add	r7, sp, #0
 800a436:	60f8      	str	r0, [r7, #12]
 800a438:	60b9      	str	r1, [r7, #8]
 800a43a:	0019      	movs	r1, r3
 800a43c:	1dbb      	adds	r3, r7, #6
 800a43e:	801a      	strh	r2, [r3, #0]
 800a440:	1d3b      	adds	r3, r7, #4
 800a442:	1c0a      	adds	r2, r1, #0
 800a444:	801a      	strh	r2, [r3, #0]
  u16_t target_offset;
  struct pbuf *q = pbuf_skip(buf, offset, &target_offset);
 800a446:	2410      	movs	r4, #16
 800a448:	193a      	adds	r2, r7, r4
 800a44a:	1d3b      	adds	r3, r7, #4
 800a44c:	8819      	ldrh	r1, [r3, #0]
 800a44e:	68fb      	ldr	r3, [r7, #12]
 800a450:	0018      	movs	r0, r3
 800a452:	f7ff ff46 	bl	800a2e2 <pbuf_skip>
 800a456:	0003      	movs	r3, r0
 800a458:	61fb      	str	r3, [r7, #28]

  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->tot_len >= target_offset + len)) {
 800a45a:	69fb      	ldr	r3, [r7, #28]
 800a45c:	2b00      	cmp	r3, #0
 800a45e:	d060      	beq.n	800a522 <pbuf_take_at+0xf2>
 800a460:	69fb      	ldr	r3, [r7, #28]
 800a462:	891b      	ldrh	r3, [r3, #8]
 800a464:	001a      	movs	r2, r3
 800a466:	0020      	movs	r0, r4
 800a468:	183b      	adds	r3, r7, r0
 800a46a:	881b      	ldrh	r3, [r3, #0]
 800a46c:	0019      	movs	r1, r3
 800a46e:	1dbb      	adds	r3, r7, #6
 800a470:	881b      	ldrh	r3, [r3, #0]
 800a472:	18cb      	adds	r3, r1, r3
 800a474:	429a      	cmp	r2, r3
 800a476:	db54      	blt.n	800a522 <pbuf_take_at+0xf2>
    u16_t remaining_len = len;
 800a478:	231a      	movs	r3, #26
 800a47a:	18fb      	adds	r3, r7, r3
 800a47c:	1dba      	adds	r2, r7, #6
 800a47e:	8812      	ldrh	r2, [r2, #0]
 800a480:	801a      	strh	r2, [r3, #0]
    const u8_t *src_ptr = (const u8_t *)dataptr;
 800a482:	68bb      	ldr	r3, [r7, #8]
 800a484:	617b      	str	r3, [r7, #20]
    /* copy the part that goes into the first pbuf */
    u16_t first_copy_len;
    LWIP_ASSERT("check pbuf_skip result", target_offset < q->len);
 800a486:	69fb      	ldr	r3, [r7, #28]
 800a488:	895a      	ldrh	r2, [r3, #10]
 800a48a:	183b      	adds	r3, r7, r0
 800a48c:	881b      	ldrh	r3, [r3, #0]
 800a48e:	429a      	cmp	r2, r3
 800a490:	d805      	bhi.n	800a49e <pbuf_take_at+0x6e>
 800a492:	4b27      	ldr	r3, [pc, #156]	; (800a530 <pbuf_take_at+0x100>)
 800a494:	4a27      	ldr	r2, [pc, #156]	; (800a534 <pbuf_take_at+0x104>)
 800a496:	4928      	ldr	r1, [pc, #160]	; (800a538 <pbuf_take_at+0x108>)
 800a498:	4828      	ldr	r0, [pc, #160]	; (800a53c <pbuf_take_at+0x10c>)
 800a49a:	f7f8 fa1f 	bl	80028dc <app_debug_rtt_raw>
    first_copy_len = (u16_t)LWIP_MIN(q->len - target_offset, len);
 800a49e:	69fb      	ldr	r3, [r7, #28]
 800a4a0:	895b      	ldrh	r3, [r3, #10]
 800a4a2:	001a      	movs	r2, r3
 800a4a4:	2110      	movs	r1, #16
 800a4a6:	187b      	adds	r3, r7, r1
 800a4a8:	881b      	ldrh	r3, [r3, #0]
 800a4aa:	1ad2      	subs	r2, r2, r3
 800a4ac:	1dbb      	adds	r3, r7, #6
 800a4ae:	881b      	ldrh	r3, [r3, #0]
 800a4b0:	429a      	cmp	r2, r3
 800a4b2:	da06      	bge.n	800a4c2 <pbuf_take_at+0x92>
 800a4b4:	69fb      	ldr	r3, [r7, #28]
 800a4b6:	895a      	ldrh	r2, [r3, #10]
 800a4b8:	187b      	adds	r3, r7, r1
 800a4ba:	881b      	ldrh	r3, [r3, #0]
 800a4bc:	1ad3      	subs	r3, r2, r3
 800a4be:	b29b      	uxth	r3, r3
 800a4c0:	e001      	b.n	800a4c6 <pbuf_take_at+0x96>
 800a4c2:	1dbb      	adds	r3, r7, #6
 800a4c4:	881b      	ldrh	r3, [r3, #0]
 800a4c6:	2112      	movs	r1, #18
 800a4c8:	187a      	adds	r2, r7, r1
 800a4ca:	8013      	strh	r3, [r2, #0]
    MEMCPY(((u8_t *)q->payload) + target_offset, dataptr, first_copy_len);
 800a4cc:	69fb      	ldr	r3, [r7, #28]
 800a4ce:	685b      	ldr	r3, [r3, #4]
 800a4d0:	2210      	movs	r2, #16
 800a4d2:	18ba      	adds	r2, r7, r2
 800a4d4:	8812      	ldrh	r2, [r2, #0]
 800a4d6:	1898      	adds	r0, r3, r2
 800a4d8:	000c      	movs	r4, r1
 800a4da:	187b      	adds	r3, r7, r1
 800a4dc:	881a      	ldrh	r2, [r3, #0]
 800a4de:	68bb      	ldr	r3, [r7, #8]
 800a4e0:	0019      	movs	r1, r3
 800a4e2:	f012 fb7d 	bl	801cbe0 <memcpy>
    remaining_len = (u16_t)(remaining_len - first_copy_len);
 800a4e6:	201a      	movs	r0, #26
 800a4e8:	183b      	adds	r3, r7, r0
 800a4ea:	1839      	adds	r1, r7, r0
 800a4ec:	193a      	adds	r2, r7, r4
 800a4ee:	8809      	ldrh	r1, [r1, #0]
 800a4f0:	8812      	ldrh	r2, [r2, #0]
 800a4f2:	1a8a      	subs	r2, r1, r2
 800a4f4:	801a      	strh	r2, [r3, #0]
    src_ptr += first_copy_len;
 800a4f6:	193b      	adds	r3, r7, r4
 800a4f8:	881b      	ldrh	r3, [r3, #0]
 800a4fa:	697a      	ldr	r2, [r7, #20]
 800a4fc:	18d3      	adds	r3, r2, r3
 800a4fe:	617b      	str	r3, [r7, #20]
    if (remaining_len > 0) {
 800a500:	0002      	movs	r2, r0
 800a502:	18bb      	adds	r3, r7, r2
 800a504:	881b      	ldrh	r3, [r3, #0]
 800a506:	2b00      	cmp	r3, #0
 800a508:	d009      	beq.n	800a51e <pbuf_take_at+0xee>
      return pbuf_take(q->next, src_ptr, remaining_len);
 800a50a:	69fb      	ldr	r3, [r7, #28]
 800a50c:	6818      	ldr	r0, [r3, #0]
 800a50e:	18bb      	adds	r3, r7, r2
 800a510:	881a      	ldrh	r2, [r3, #0]
 800a512:	697b      	ldr	r3, [r7, #20]
 800a514:	0019      	movs	r1, r3
 800a516:	f7ff fefb 	bl	800a310 <pbuf_take>
 800a51a:	0003      	movs	r3, r0
 800a51c:	e003      	b.n	800a526 <pbuf_take_at+0xf6>
    }
    return ERR_OK;
 800a51e:	2300      	movs	r3, #0
 800a520:	e001      	b.n	800a526 <pbuf_take_at+0xf6>
  }
  return ERR_MEM;
 800a522:	2301      	movs	r3, #1
 800a524:	425b      	negs	r3, r3
}
 800a526:	0018      	movs	r0, r3
 800a528:	46bd      	mov	sp, r7
 800a52a:	b009      	add	sp, #36	; 0x24
 800a52c:	bd90      	pop	{r4, r7, pc}
 800a52e:	46c0      	nop			; (mov r8, r8)
 800a530:	0801f4e8 	.word	0x0801f4e8
 800a534:	00000505 	.word	0x00000505
 800a538:	0801f9ac 	.word	0x0801f9ac
 800a53c:	0801f540 	.word	0x0801f540

0800a540 <pbuf_coalesce>:
 * @return a new, single pbuf (p->next is NULL)
 *         or the old pbuf if allocation fails
 */
struct pbuf *
pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
{
 800a540:	b580      	push	{r7, lr}
 800a542:	b084      	sub	sp, #16
 800a544:	af00      	add	r7, sp, #0
 800a546:	6078      	str	r0, [r7, #4]
 800a548:	000a      	movs	r2, r1
 800a54a:	1cfb      	adds	r3, r7, #3
 800a54c:	701a      	strb	r2, [r3, #0]
  struct pbuf *q;
  if (p->next == NULL) {
 800a54e:	687b      	ldr	r3, [r7, #4]
 800a550:	681b      	ldr	r3, [r3, #0]
 800a552:	2b00      	cmp	r3, #0
 800a554:	d101      	bne.n	800a55a <pbuf_coalesce+0x1a>
    return p;
 800a556:	687b      	ldr	r3, [r7, #4]
 800a558:	e013      	b.n	800a582 <pbuf_coalesce+0x42>
  }
  q = pbuf_clone(layer, PBUF_RAM, p);
 800a55a:	687a      	ldr	r2, [r7, #4]
 800a55c:	23a0      	movs	r3, #160	; 0xa0
 800a55e:	0099      	lsls	r1, r3, #2
 800a560:	1cfb      	adds	r3, r7, #3
 800a562:	781b      	ldrb	r3, [r3, #0]
 800a564:	0018      	movs	r0, r3
 800a566:	f000 f811 	bl	800a58c <pbuf_clone>
 800a56a:	0003      	movs	r3, r0
 800a56c:	60fb      	str	r3, [r7, #12]
  if (q == NULL) {
 800a56e:	68fb      	ldr	r3, [r7, #12]
 800a570:	2b00      	cmp	r3, #0
 800a572:	d101      	bne.n	800a578 <pbuf_coalesce+0x38>
    /* @todo: what do we do now? */
    return p;
 800a574:	687b      	ldr	r3, [r7, #4]
 800a576:	e004      	b.n	800a582 <pbuf_coalesce+0x42>
  }
  pbuf_free(p);
 800a578:	687b      	ldr	r3, [r7, #4]
 800a57a:	0018      	movs	r0, r3
 800a57c:	f7ff fb28 	bl	8009bd0 <pbuf_free>
  return q;
 800a580:	68fb      	ldr	r3, [r7, #12]
}
 800a582:	0018      	movs	r0, r3
 800a584:	46bd      	mov	sp, r7
 800a586:	b004      	add	sp, #16
 800a588:	bd80      	pop	{r7, pc}
	...

0800a58c <pbuf_clone>:
 *
 * @return a new pbuf or NULL if allocation fails
 */
struct pbuf *
pbuf_clone(pbuf_layer layer, pbuf_type type, struct pbuf *p)
{
 800a58c:	b5b0      	push	{r4, r5, r7, lr}
 800a58e:	b084      	sub	sp, #16
 800a590:	af00      	add	r7, sp, #0
 800a592:	603a      	str	r2, [r7, #0]
 800a594:	1dfb      	adds	r3, r7, #7
 800a596:	1c02      	adds	r2, r0, #0
 800a598:	701a      	strb	r2, [r3, #0]
 800a59a:	1d3b      	adds	r3, r7, #4
 800a59c:	1c0a      	adds	r2, r1, #0
 800a59e:	801a      	strh	r2, [r3, #0]
  struct pbuf *q;
  err_t err;
  q = pbuf_alloc(layer, p->tot_len, type);
 800a5a0:	683b      	ldr	r3, [r7, #0]
 800a5a2:	8919      	ldrh	r1, [r3, #8]
 800a5a4:	1d3b      	adds	r3, r7, #4
 800a5a6:	881a      	ldrh	r2, [r3, #0]
 800a5a8:	1dfb      	adds	r3, r7, #7
 800a5aa:	781b      	ldrb	r3, [r3, #0]
 800a5ac:	0018      	movs	r0, r3
 800a5ae:	f7fe ff97 	bl	80094e0 <pbuf_alloc>
 800a5b2:	0003      	movs	r3, r0
 800a5b4:	60fb      	str	r3, [r7, #12]
  if (q == NULL) {
 800a5b6:	68fb      	ldr	r3, [r7, #12]
 800a5b8:	2b00      	cmp	r3, #0
 800a5ba:	d101      	bne.n	800a5c0 <pbuf_clone+0x34>
    return NULL;
 800a5bc:	2300      	movs	r3, #0
 800a5be:	e015      	b.n	800a5ec <pbuf_clone+0x60>
  }
  err = pbuf_copy(q, p);
 800a5c0:	250b      	movs	r5, #11
 800a5c2:	197c      	adds	r4, r7, r5
 800a5c4:	683a      	ldr	r2, [r7, #0]
 800a5c6:	68fb      	ldr	r3, [r7, #12]
 800a5c8:	0011      	movs	r1, r2
 800a5ca:	0018      	movs	r0, r3
 800a5cc:	f7ff fca2 	bl	8009f14 <pbuf_copy>
 800a5d0:	0003      	movs	r3, r0
 800a5d2:	7023      	strb	r3, [r4, #0]
  LWIP_UNUSED_ARG(err); /* in case of LWIP_NOASSERT */
  LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
 800a5d4:	197b      	adds	r3, r7, r5
 800a5d6:	781b      	ldrb	r3, [r3, #0]
 800a5d8:	b25b      	sxtb	r3, r3
 800a5da:	2b00      	cmp	r3, #0
 800a5dc:	d005      	beq.n	800a5ea <pbuf_clone+0x5e>
 800a5de:	4b05      	ldr	r3, [pc, #20]	; (800a5f4 <pbuf_clone+0x68>)
 800a5e0:	4a05      	ldr	r2, [pc, #20]	; (800a5f8 <pbuf_clone+0x6c>)
 800a5e2:	4906      	ldr	r1, [pc, #24]	; (800a5fc <pbuf_clone+0x70>)
 800a5e4:	4806      	ldr	r0, [pc, #24]	; (800a600 <pbuf_clone+0x74>)
 800a5e6:	f7f8 f979 	bl	80028dc <app_debug_rtt_raw>
  return q;
 800a5ea:	68fb      	ldr	r3, [r7, #12]
}
 800a5ec:	0018      	movs	r0, r3
 800a5ee:	46bd      	mov	sp, r7
 800a5f0:	b004      	add	sp, #16
 800a5f2:	bdb0      	pop	{r4, r5, r7, pc}
 800a5f4:	0801f4e8 	.word	0x0801f4e8
 800a5f8:	00000546 	.word	0x00000546
 800a5fc:	0801f9c4 	.word	0x0801f9c4
 800a600:	0801f540 	.word	0x0801f540

0800a604 <pbuf_get_at>:
 * @param offset offset into p of the byte to return
 * @return byte at an offset into p OR ZERO IF 'offset' >= p->tot_len
 */
u8_t
pbuf_get_at(const struct pbuf *p, u16_t offset)
{
 800a604:	b580      	push	{r7, lr}
 800a606:	b084      	sub	sp, #16
 800a608:	af00      	add	r7, sp, #0
 800a60a:	6078      	str	r0, [r7, #4]
 800a60c:	000a      	movs	r2, r1
 800a60e:	1cbb      	adds	r3, r7, #2
 800a610:	801a      	strh	r2, [r3, #0]
  int ret = pbuf_try_get_at(p, offset);
 800a612:	1cbb      	adds	r3, r7, #2
 800a614:	881a      	ldrh	r2, [r3, #0]
 800a616:	687b      	ldr	r3, [r7, #4]
 800a618:	0011      	movs	r1, r2
 800a61a:	0018      	movs	r0, r3
 800a61c:	f000 f80d 	bl	800a63a <pbuf_try_get_at>
 800a620:	0003      	movs	r3, r0
 800a622:	60fb      	str	r3, [r7, #12]
  if (ret >= 0) {
 800a624:	68fb      	ldr	r3, [r7, #12]
 800a626:	2b00      	cmp	r3, #0
 800a628:	db02      	blt.n	800a630 <pbuf_get_at+0x2c>
    return (u8_t)ret;
 800a62a:	68fb      	ldr	r3, [r7, #12]
 800a62c:	b2db      	uxtb	r3, r3
 800a62e:	e000      	b.n	800a632 <pbuf_get_at+0x2e>
  }
  return 0;
 800a630:	2300      	movs	r3, #0
}
 800a632:	0018      	movs	r0, r3
 800a634:	46bd      	mov	sp, r7
 800a636:	b004      	add	sp, #16
 800a638:	bd80      	pop	{r7, pc}

0800a63a <pbuf_try_get_at>:
 * @param offset offset into p of the byte to return
 * @return byte at an offset into p [0..0xFF] OR negative if 'offset' >= p->tot_len
 */
int
pbuf_try_get_at(const struct pbuf *p, u16_t offset)
{
 800a63a:	b590      	push	{r4, r7, lr}
 800a63c:	b085      	sub	sp, #20
 800a63e:	af00      	add	r7, sp, #0
 800a640:	6078      	str	r0, [r7, #4]
 800a642:	000a      	movs	r2, r1
 800a644:	1cbb      	adds	r3, r7, #2
 800a646:	801a      	strh	r2, [r3, #0]
  u16_t q_idx;
  const struct pbuf *q = pbuf_skip_const(p, offset, &q_idx);
 800a648:	240a      	movs	r4, #10
 800a64a:	193a      	adds	r2, r7, r4
 800a64c:	1cbb      	adds	r3, r7, #2
 800a64e:	8819      	ldrh	r1, [r3, #0]
 800a650:	687b      	ldr	r3, [r7, #4]
 800a652:	0018      	movs	r0, r3
 800a654:	f7ff fe12 	bl	800a27c <pbuf_skip_const>
 800a658:	0003      	movs	r3, r0
 800a65a:	60fb      	str	r3, [r7, #12]

  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > q_idx)) {
 800a65c:	68fb      	ldr	r3, [r7, #12]
 800a65e:	2b00      	cmp	r3, #0
 800a660:	d00c      	beq.n	800a67c <pbuf_try_get_at+0x42>
 800a662:	68fb      	ldr	r3, [r7, #12]
 800a664:	895a      	ldrh	r2, [r3, #10]
 800a666:	193b      	adds	r3, r7, r4
 800a668:	881b      	ldrh	r3, [r3, #0]
 800a66a:	429a      	cmp	r2, r3
 800a66c:	d906      	bls.n	800a67c <pbuf_try_get_at+0x42>
    return ((u8_t *)q->payload)[q_idx];
 800a66e:	68fb      	ldr	r3, [r7, #12]
 800a670:	685b      	ldr	r3, [r3, #4]
 800a672:	193a      	adds	r2, r7, r4
 800a674:	8812      	ldrh	r2, [r2, #0]
 800a676:	189b      	adds	r3, r3, r2
 800a678:	781b      	ldrb	r3, [r3, #0]
 800a67a:	e001      	b.n	800a680 <pbuf_try_get_at+0x46>
  }
  return -1;
 800a67c:	2301      	movs	r3, #1
 800a67e:	425b      	negs	r3, r3
}
 800a680:	0018      	movs	r0, r3
 800a682:	46bd      	mov	sp, r7
 800a684:	b005      	add	sp, #20
 800a686:	bd90      	pop	{r4, r7, pc}

0800a688 <pbuf_put_at>:
 * @param offset offset into p of the byte to write
 * @param data byte to write at an offset into p
 */
void
pbuf_put_at(struct pbuf *p, u16_t offset, u8_t data)
{
 800a688:	b590      	push	{r4, r7, lr}
 800a68a:	b085      	sub	sp, #20
 800a68c:	af00      	add	r7, sp, #0
 800a68e:	6078      	str	r0, [r7, #4]
 800a690:	0008      	movs	r0, r1
 800a692:	0011      	movs	r1, r2
 800a694:	1cbb      	adds	r3, r7, #2
 800a696:	1c02      	adds	r2, r0, #0
 800a698:	801a      	strh	r2, [r3, #0]
 800a69a:	1c7b      	adds	r3, r7, #1
 800a69c:	1c0a      	adds	r2, r1, #0
 800a69e:	701a      	strb	r2, [r3, #0]
  u16_t q_idx;
  struct pbuf *q = pbuf_skip(p, offset, &q_idx);
 800a6a0:	240a      	movs	r4, #10
 800a6a2:	193a      	adds	r2, r7, r4
 800a6a4:	1cbb      	adds	r3, r7, #2
 800a6a6:	8819      	ldrh	r1, [r3, #0]
 800a6a8:	687b      	ldr	r3, [r7, #4]
 800a6aa:	0018      	movs	r0, r3
 800a6ac:	f7ff fe19 	bl	800a2e2 <pbuf_skip>
 800a6b0:	0003      	movs	r3, r0
 800a6b2:	60fb      	str	r3, [r7, #12]

  /* write requested data if pbuf is OK */
  if ((q != NULL) && (q->len > q_idx)) {
 800a6b4:	68fb      	ldr	r3, [r7, #12]
 800a6b6:	2b00      	cmp	r3, #0
 800a6b8:	d00d      	beq.n	800a6d6 <pbuf_put_at+0x4e>
 800a6ba:	68fb      	ldr	r3, [r7, #12]
 800a6bc:	895a      	ldrh	r2, [r3, #10]
 800a6be:	193b      	adds	r3, r7, r4
 800a6c0:	881b      	ldrh	r3, [r3, #0]
 800a6c2:	429a      	cmp	r2, r3
 800a6c4:	d907      	bls.n	800a6d6 <pbuf_put_at+0x4e>
    ((u8_t *)q->payload)[q_idx] = data;
 800a6c6:	68fb      	ldr	r3, [r7, #12]
 800a6c8:	685b      	ldr	r3, [r3, #4]
 800a6ca:	193a      	adds	r2, r7, r4
 800a6cc:	8812      	ldrh	r2, [r2, #0]
 800a6ce:	189b      	adds	r3, r3, r2
 800a6d0:	1c7a      	adds	r2, r7, #1
 800a6d2:	7812      	ldrb	r2, [r2, #0]
 800a6d4:	701a      	strb	r2, [r3, #0]
  }
}
 800a6d6:	46c0      	nop			; (mov r8, r8)
 800a6d8:	46bd      	mov	sp, r7
 800a6da:	b005      	add	sp, #20
 800a6dc:	bd90      	pop	{r4, r7, pc}
	...

0800a6e0 <pbuf_memcmp>:
 * @return zero if equal, nonzero otherwise
 *         (0xffff if p is too short, diffoffset+1 otherwise)
 */
u16_t
pbuf_memcmp(const struct pbuf *p, u16_t offset, const void *s2, u16_t n)
{
 800a6e0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a6e2:	b089      	sub	sp, #36	; 0x24
 800a6e4:	af00      	add	r7, sp, #0
 800a6e6:	60f8      	str	r0, [r7, #12]
 800a6e8:	0008      	movs	r0, r1
 800a6ea:	607a      	str	r2, [r7, #4]
 800a6ec:	0019      	movs	r1, r3
 800a6ee:	240a      	movs	r4, #10
 800a6f0:	193b      	adds	r3, r7, r4
 800a6f2:	1c02      	adds	r2, r0, #0
 800a6f4:	801a      	strh	r2, [r3, #0]
 800a6f6:	2008      	movs	r0, #8
 800a6f8:	183b      	adds	r3, r7, r0
 800a6fa:	1c0a      	adds	r2, r1, #0
 800a6fc:	801a      	strh	r2, [r3, #0]
  u16_t start = offset;
 800a6fe:	231e      	movs	r3, #30
 800a700:	18fb      	adds	r3, r7, r3
 800a702:	193a      	adds	r2, r7, r4
 800a704:	8812      	ldrh	r2, [r2, #0]
 800a706:	801a      	strh	r2, [r3, #0]
  const struct pbuf *q = p;
 800a708:	68fb      	ldr	r3, [r7, #12]
 800a70a:	61bb      	str	r3, [r7, #24]
  u16_t i;

  /* pbuf long enough to perform check? */
  if (p->tot_len < (offset + n)) {
 800a70c:	68fb      	ldr	r3, [r7, #12]
 800a70e:	891b      	ldrh	r3, [r3, #8]
 800a710:	0019      	movs	r1, r3
 800a712:	193b      	adds	r3, r7, r4
 800a714:	881a      	ldrh	r2, [r3, #0]
 800a716:	183b      	adds	r3, r7, r0
 800a718:	881b      	ldrh	r3, [r3, #0]
 800a71a:	18d3      	adds	r3, r2, r3
 800a71c:	4299      	cmp	r1, r3
 800a71e:	da0c      	bge.n	800a73a <pbuf_memcmp+0x5a>
    return 0xffff;
 800a720:	4b2d      	ldr	r3, [pc, #180]	; (800a7d8 <pbuf_memcmp+0xf8>)
 800a722:	e054      	b.n	800a7ce <pbuf_memcmp+0xee>
  }

  /* get the correct pbuf from chain. We know it succeeds because of p->tot_len check above. */
  while ((q != NULL) && (q->len <= start)) {
    start = (u16_t)(start - q->len);
 800a724:	69bb      	ldr	r3, [r7, #24]
 800a726:	895a      	ldrh	r2, [r3, #10]
 800a728:	211e      	movs	r1, #30
 800a72a:	187b      	adds	r3, r7, r1
 800a72c:	1879      	adds	r1, r7, r1
 800a72e:	8809      	ldrh	r1, [r1, #0]
 800a730:	1a8a      	subs	r2, r1, r2
 800a732:	801a      	strh	r2, [r3, #0]
    q = q->next;
 800a734:	69bb      	ldr	r3, [r7, #24]
 800a736:	681b      	ldr	r3, [r3, #0]
 800a738:	61bb      	str	r3, [r7, #24]
  while ((q != NULL) && (q->len <= start)) {
 800a73a:	69bb      	ldr	r3, [r7, #24]
 800a73c:	2b00      	cmp	r3, #0
 800a73e:	d006      	beq.n	800a74e <pbuf_memcmp+0x6e>
 800a740:	69bb      	ldr	r3, [r7, #24]
 800a742:	895b      	ldrh	r3, [r3, #10]
 800a744:	221e      	movs	r2, #30
 800a746:	18ba      	adds	r2, r7, r2
 800a748:	8812      	ldrh	r2, [r2, #0]
 800a74a:	429a      	cmp	r2, r3
 800a74c:	d2ea      	bcs.n	800a724 <pbuf_memcmp+0x44>
  }

  /* return requested data if pbuf is OK */
  for (i = 0; i < n; i++) {
 800a74e:	2316      	movs	r3, #22
 800a750:	18fb      	adds	r3, r7, r3
 800a752:	2200      	movs	r2, #0
 800a754:	801a      	strh	r2, [r3, #0]
 800a756:	e031      	b.n	800a7bc <pbuf_memcmp+0xdc>
    /* We know pbuf_get_at() succeeds because of p->tot_len check above. */
    u8_t a = pbuf_get_at(q, (u16_t)(start + i));
 800a758:	231e      	movs	r3, #30
 800a75a:	18fa      	adds	r2, r7, r3
 800a75c:	2516      	movs	r5, #22
 800a75e:	197b      	adds	r3, r7, r5
 800a760:	8812      	ldrh	r2, [r2, #0]
 800a762:	881b      	ldrh	r3, [r3, #0]
 800a764:	18d3      	adds	r3, r2, r3
 800a766:	b29a      	uxth	r2, r3
 800a768:	2615      	movs	r6, #21
 800a76a:	19bc      	adds	r4, r7, r6
 800a76c:	69bb      	ldr	r3, [r7, #24]
 800a76e:	0011      	movs	r1, r2
 800a770:	0018      	movs	r0, r3
 800a772:	f7ff ff47 	bl	800a604 <pbuf_get_at>
 800a776:	0003      	movs	r3, r0
 800a778:	7023      	strb	r3, [r4, #0]
    u8_t b = ((const u8_t *)s2)[i];
 800a77a:	0029      	movs	r1, r5
 800a77c:	187b      	adds	r3, r7, r1
 800a77e:	881b      	ldrh	r3, [r3, #0]
 800a780:	687a      	ldr	r2, [r7, #4]
 800a782:	18d2      	adds	r2, r2, r3
 800a784:	2014      	movs	r0, #20
 800a786:	183b      	adds	r3, r7, r0
 800a788:	7812      	ldrb	r2, [r2, #0]
 800a78a:	701a      	strb	r2, [r3, #0]
    if (a != b) {
 800a78c:	19ba      	adds	r2, r7, r6
 800a78e:	183b      	adds	r3, r7, r0
 800a790:	7812      	ldrb	r2, [r2, #0]
 800a792:	781b      	ldrb	r3, [r3, #0]
 800a794:	429a      	cmp	r2, r3
 800a796:	d00b      	beq.n	800a7b0 <pbuf_memcmp+0xd0>
      return (u16_t)LWIP_MIN(i + 1, 0xFFFF);
 800a798:	187b      	adds	r3, r7, r1
 800a79a:	881b      	ldrh	r3, [r3, #0]
 800a79c:	b29a      	uxth	r2, r3
 800a79e:	490f      	ldr	r1, [pc, #60]	; (800a7dc <pbuf_memcmp+0xfc>)
 800a7a0:	428a      	cmp	r2, r1
 800a7a2:	d901      	bls.n	800a7a8 <pbuf_memcmp+0xc8>
 800a7a4:	2302      	movs	r3, #2
 800a7a6:	425b      	negs	r3, r3
 800a7a8:	b29b      	uxth	r3, r3
 800a7aa:	3301      	adds	r3, #1
 800a7ac:	b29b      	uxth	r3, r3
 800a7ae:	e00e      	b.n	800a7ce <pbuf_memcmp+0xee>
  for (i = 0; i < n; i++) {
 800a7b0:	2116      	movs	r1, #22
 800a7b2:	187b      	adds	r3, r7, r1
 800a7b4:	881a      	ldrh	r2, [r3, #0]
 800a7b6:	187b      	adds	r3, r7, r1
 800a7b8:	3201      	adds	r2, #1
 800a7ba:	801a      	strh	r2, [r3, #0]
 800a7bc:	2316      	movs	r3, #22
 800a7be:	18fa      	adds	r2, r7, r3
 800a7c0:	2308      	movs	r3, #8
 800a7c2:	18fb      	adds	r3, r7, r3
 800a7c4:	8812      	ldrh	r2, [r2, #0]
 800a7c6:	881b      	ldrh	r3, [r3, #0]
 800a7c8:	429a      	cmp	r2, r3
 800a7ca:	d3c5      	bcc.n	800a758 <pbuf_memcmp+0x78>
    }
  }
  return 0;
 800a7cc:	2300      	movs	r3, #0
}
 800a7ce:	0018      	movs	r0, r3
 800a7d0:	46bd      	mov	sp, r7
 800a7d2:	b009      	add	sp, #36	; 0x24
 800a7d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a7d6:	46c0      	nop			; (mov r8, r8)
 800a7d8:	0000ffff 	.word	0x0000ffff
 800a7dc:	0000fffe 	.word	0x0000fffe

0800a7e0 <pbuf_memfind>:
 * @param start_offset offset into p at which to start searching
 * @return 0xFFFF if substr was not found in p or the index where it was found
 */
u16_t
pbuf_memfind(const struct pbuf *p, const void *mem, u16_t mem_len, u16_t start_offset)
{
 800a7e0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a7e2:	b087      	sub	sp, #28
 800a7e4:	af00      	add	r7, sp, #0
 800a7e6:	60f8      	str	r0, [r7, #12]
 800a7e8:	60b9      	str	r1, [r7, #8]
 800a7ea:	0019      	movs	r1, r3
 800a7ec:	1dbb      	adds	r3, r7, #6
 800a7ee:	801a      	strh	r2, [r3, #0]
 800a7f0:	1d3b      	adds	r3, r7, #4
 800a7f2:	1c0a      	adds	r2, r1, #0
 800a7f4:	801a      	strh	r2, [r3, #0]
  u16_t i;
  u16_t max_cmp_start = (u16_t)(p->tot_len - mem_len);
 800a7f6:	68fb      	ldr	r3, [r7, #12]
 800a7f8:	8919      	ldrh	r1, [r3, #8]
 800a7fa:	2314      	movs	r3, #20
 800a7fc:	18fb      	adds	r3, r7, r3
 800a7fe:	1dba      	adds	r2, r7, #6
 800a800:	8812      	ldrh	r2, [r2, #0]
 800a802:	1a8a      	subs	r2, r1, r2
 800a804:	801a      	strh	r2, [r3, #0]
  if (p->tot_len >= mem_len + start_offset) {
 800a806:	68fb      	ldr	r3, [r7, #12]
 800a808:	891b      	ldrh	r3, [r3, #8]
 800a80a:	0019      	movs	r1, r3
 800a80c:	1dbb      	adds	r3, r7, #6
 800a80e:	881a      	ldrh	r2, [r3, #0]
 800a810:	1d3b      	adds	r3, r7, #4
 800a812:	881b      	ldrh	r3, [r3, #0]
 800a814:	18d3      	adds	r3, r2, r3
 800a816:	4299      	cmp	r1, r3
 800a818:	db29      	blt.n	800a86e <pbuf_memfind+0x8e>
    for (i = start_offset; i <= max_cmp_start; i++) {
 800a81a:	2316      	movs	r3, #22
 800a81c:	18fb      	adds	r3, r7, r3
 800a81e:	1d3a      	adds	r2, r7, #4
 800a820:	8812      	ldrh	r2, [r2, #0]
 800a822:	801a      	strh	r2, [r3, #0]
 800a824:	e01b      	b.n	800a85e <pbuf_memfind+0x7e>
      u16_t plus = pbuf_memcmp(p, i, mem, mem_len);
 800a826:	2612      	movs	r6, #18
 800a828:	19bc      	adds	r4, r7, r6
 800a82a:	1dbb      	adds	r3, r7, #6
 800a82c:	881d      	ldrh	r5, [r3, #0]
 800a82e:	68ba      	ldr	r2, [r7, #8]
 800a830:	2316      	movs	r3, #22
 800a832:	18fb      	adds	r3, r7, r3
 800a834:	8819      	ldrh	r1, [r3, #0]
 800a836:	68f8      	ldr	r0, [r7, #12]
 800a838:	002b      	movs	r3, r5
 800a83a:	f7ff ff51 	bl	800a6e0 <pbuf_memcmp>
 800a83e:	0003      	movs	r3, r0
 800a840:	8023      	strh	r3, [r4, #0]
      if (plus == 0) {
 800a842:	19bb      	adds	r3, r7, r6
 800a844:	881b      	ldrh	r3, [r3, #0]
 800a846:	2b00      	cmp	r3, #0
 800a848:	d103      	bne.n	800a852 <pbuf_memfind+0x72>
        return i;
 800a84a:	2316      	movs	r3, #22
 800a84c:	18fb      	adds	r3, r7, r3
 800a84e:	881b      	ldrh	r3, [r3, #0]
 800a850:	e00e      	b.n	800a870 <pbuf_memfind+0x90>
    for (i = start_offset; i <= max_cmp_start; i++) {
 800a852:	2116      	movs	r1, #22
 800a854:	187b      	adds	r3, r7, r1
 800a856:	881a      	ldrh	r2, [r3, #0]
 800a858:	187b      	adds	r3, r7, r1
 800a85a:	3201      	adds	r2, #1
 800a85c:	801a      	strh	r2, [r3, #0]
 800a85e:	2316      	movs	r3, #22
 800a860:	18fa      	adds	r2, r7, r3
 800a862:	2314      	movs	r3, #20
 800a864:	18fb      	adds	r3, r7, r3
 800a866:	8812      	ldrh	r2, [r2, #0]
 800a868:	881b      	ldrh	r3, [r3, #0]
 800a86a:	429a      	cmp	r2, r3
 800a86c:	d9db      	bls.n	800a826 <pbuf_memfind+0x46>
      }
    }
  }
  return 0xFFFF;
 800a86e:	4b02      	ldr	r3, [pc, #8]	; (800a878 <pbuf_memfind+0x98>)
}
 800a870:	0018      	movs	r0, r3
 800a872:	46bd      	mov	sp, r7
 800a874:	b007      	add	sp, #28
 800a876:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a878:	0000ffff 	.word	0x0000ffff

0800a87c <tcp_free>:
}

/** Free a tcp pcb */
void
tcp_free(struct tcp_pcb *pcb)
{
 800a87c:	b580      	push	{r7, lr}
 800a87e:	b082      	sub	sp, #8
 800a880:	af00      	add	r7, sp, #0
 800a882:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_free: LISTEN", pcb->state != LISTEN);
 800a884:	687b      	ldr	r3, [r7, #4]
 800a886:	7e1b      	ldrb	r3, [r3, #24]
 800a888:	2b01      	cmp	r3, #1
 800a88a:	d105      	bne.n	800a898 <tcp_free+0x1c>
 800a88c:	4b07      	ldr	r3, [pc, #28]	; (800a8ac <tcp_free+0x30>)
 800a88e:	4908      	ldr	r1, [pc, #32]	; (800a8b0 <tcp_free+0x34>)
 800a890:	4808      	ldr	r0, [pc, #32]	; (800a8b4 <tcp_free+0x38>)
 800a892:	22d4      	movs	r2, #212	; 0xd4
 800a894:	f7f8 f822 	bl	80028dc <app_debug_rtt_raw>
#if LWIP_TCP_PCB_NUM_EXT_ARGS
  tcp_ext_arg_invoke_callbacks_destroyed(pcb->ext_args);
#endif
  memp_free(MEMP_TCP_PCB, pcb);
 800a898:	687b      	ldr	r3, [r7, #4]
 800a89a:	0019      	movs	r1, r3
 800a89c:	2001      	movs	r0, #1
 800a89e:	f7fe faa7 	bl	8008df0 <memp_free>
}
 800a8a2:	46c0      	nop			; (mov r8, r8)
 800a8a4:	46bd      	mov	sp, r7
 800a8a6:	b002      	add	sp, #8
 800a8a8:	bd80      	pop	{r7, pc}
 800a8aa:	46c0      	nop			; (mov r8, r8)
 800a8ac:	0801fa7c 	.word	0x0801fa7c
 800a8b0:	0801faa4 	.word	0x0801faa4
 800a8b4:	0801fab8 	.word	0x0801fab8

0800a8b8 <tcp_free_listen>:

/** Free a tcp listen pcb */
static void
tcp_free_listen(struct tcp_pcb *pcb)
{
 800a8b8:	b580      	push	{r7, lr}
 800a8ba:	b082      	sub	sp, #8
 800a8bc:	af00      	add	r7, sp, #0
 800a8be:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_free_listen: !LISTEN", pcb->state != LISTEN);
 800a8c0:	687b      	ldr	r3, [r7, #4]
 800a8c2:	7e1b      	ldrb	r3, [r3, #24]
 800a8c4:	2b01      	cmp	r3, #1
 800a8c6:	d105      	bne.n	800a8d4 <tcp_free_listen+0x1c>
 800a8c8:	4b07      	ldr	r3, [pc, #28]	; (800a8e8 <tcp_free_listen+0x30>)
 800a8ca:	4908      	ldr	r1, [pc, #32]	; (800a8ec <tcp_free_listen+0x34>)
 800a8cc:	4808      	ldr	r0, [pc, #32]	; (800a8f0 <tcp_free_listen+0x38>)
 800a8ce:	22df      	movs	r2, #223	; 0xdf
 800a8d0:	f7f8 f804 	bl	80028dc <app_debug_rtt_raw>
#if LWIP_TCP_PCB_NUM_EXT_ARGS
  tcp_ext_arg_invoke_callbacks_destroyed(pcb->ext_args);
#endif
  memp_free(MEMP_TCP_PCB_LISTEN, pcb);
 800a8d4:	687b      	ldr	r3, [r7, #4]
 800a8d6:	0019      	movs	r1, r3
 800a8d8:	2002      	movs	r0, #2
 800a8da:	f7fe fa89 	bl	8008df0 <memp_free>
}
 800a8de:	46c0      	nop			; (mov r8, r8)
 800a8e0:	46bd      	mov	sp, r7
 800a8e2:	b002      	add	sp, #8
 800a8e4:	bd80      	pop	{r7, pc}
 800a8e6:	46c0      	nop			; (mov r8, r8)
 800a8e8:	0801fa7c 	.word	0x0801fa7c
 800a8ec:	0801fae4 	.word	0x0801fae4
 800a8f0:	0801fab8 	.word	0x0801fab8

0800a8f4 <tcp_tmr>:
/**
 * Called periodically to dispatch TCP timers.
 */
void
tcp_tmr(void)
{
 800a8f4:	b580      	push	{r7, lr}
 800a8f6:	af00      	add	r7, sp, #0
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
 800a8f8:	f001 f8d0 	bl	800ba9c <tcp_fasttmr>

  if (++tcp_timer & 1) {
 800a8fc:	4b08      	ldr	r3, [pc, #32]	; (800a920 <tcp_tmr+0x2c>)
 800a8fe:	781b      	ldrb	r3, [r3, #0]
 800a900:	3301      	adds	r3, #1
 800a902:	b2da      	uxtb	r2, r3
 800a904:	4b06      	ldr	r3, [pc, #24]	; (800a920 <tcp_tmr+0x2c>)
 800a906:	701a      	strb	r2, [r3, #0]
 800a908:	4b05      	ldr	r3, [pc, #20]	; (800a920 <tcp_tmr+0x2c>)
 800a90a:	781b      	ldrb	r3, [r3, #0]
 800a90c:	001a      	movs	r2, r3
 800a90e:	2301      	movs	r3, #1
 800a910:	4013      	ands	r3, r2
 800a912:	d001      	beq.n	800a918 <tcp_tmr+0x24>
    /* Call tcp_slowtmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
 800a914:	f000 fd36 	bl	800b384 <tcp_slowtmr>
  }
}
 800a918:	46c0      	nop			; (mov r8, r8)
 800a91a:	46bd      	mov	sp, r7
 800a91c:	bd80      	pop	{r7, pc}
 800a91e:	46c0      	nop			; (mov r8, r8)
 800a920:	20001b29 	.word	0x20001b29

0800a924 <tcp_remove_listener>:
/** Called when a listen pcb is closed. Iterates one pcb list and removes the
 * closed listener pcb from pcb->listener if matching.
 */
static void
tcp_remove_listener(struct tcp_pcb *list, struct tcp_pcb_listen *lpcb)
{
 800a924:	b580      	push	{r7, lr}
 800a926:	b084      	sub	sp, #16
 800a928:	af00      	add	r7, sp, #0
 800a92a:	6078      	str	r0, [r7, #4]
 800a92c:	6039      	str	r1, [r7, #0]
  struct tcp_pcb *pcb;

  LWIP_ASSERT("tcp_remove_listener: invalid listener", lpcb != NULL);
 800a92e:	683b      	ldr	r3, [r7, #0]
 800a930:	2b00      	cmp	r3, #0
 800a932:	d105      	bne.n	800a940 <tcp_remove_listener+0x1c>
 800a934:	4b0e      	ldr	r3, [pc, #56]	; (800a970 <tcp_remove_listener+0x4c>)
 800a936:	490f      	ldr	r1, [pc, #60]	; (800a974 <tcp_remove_listener+0x50>)
 800a938:	480f      	ldr	r0, [pc, #60]	; (800a978 <tcp_remove_listener+0x54>)
 800a93a:	22ff      	movs	r2, #255	; 0xff
 800a93c:	f7f7 ffce 	bl	80028dc <app_debug_rtt_raw>

  for (pcb = list; pcb != NULL; pcb = pcb->next) {
 800a940:	687b      	ldr	r3, [r7, #4]
 800a942:	60fb      	str	r3, [r7, #12]
 800a944:	e00c      	b.n	800a960 <tcp_remove_listener+0x3c>
    if (pcb->listener == lpcb) {
 800a946:	68fb      	ldr	r3, [r7, #12]
 800a948:	2280      	movs	r2, #128	; 0x80
 800a94a:	589b      	ldr	r3, [r3, r2]
 800a94c:	683a      	ldr	r2, [r7, #0]
 800a94e:	429a      	cmp	r2, r3
 800a950:	d103      	bne.n	800a95a <tcp_remove_listener+0x36>
      pcb->listener = NULL;
 800a952:	68fb      	ldr	r3, [r7, #12]
 800a954:	2280      	movs	r2, #128	; 0x80
 800a956:	2100      	movs	r1, #0
 800a958:	5099      	str	r1, [r3, r2]
  for (pcb = list; pcb != NULL; pcb = pcb->next) {
 800a95a:	68fb      	ldr	r3, [r7, #12]
 800a95c:	691b      	ldr	r3, [r3, #16]
 800a95e:	60fb      	str	r3, [r7, #12]
 800a960:	68fb      	ldr	r3, [r7, #12]
 800a962:	2b00      	cmp	r3, #0
 800a964:	d1ef      	bne.n	800a946 <tcp_remove_listener+0x22>
    }
  }
}
 800a966:	46c0      	nop			; (mov r8, r8)
 800a968:	46c0      	nop			; (mov r8, r8)
 800a96a:	46bd      	mov	sp, r7
 800a96c:	b004      	add	sp, #16
 800a96e:	bd80      	pop	{r7, pc}
 800a970:	0801fa7c 	.word	0x0801fa7c
 800a974:	0801fb00 	.word	0x0801fb00
 800a978:	0801fab8 	.word	0x0801fab8

0800a97c <tcp_listen_closed>:
/** Called when a listen pcb is closed. Iterates all pcb lists and removes the
 * closed listener pcb from pcb->listener if matching.
 */
static void
tcp_listen_closed(struct tcp_pcb *pcb)
{
 800a97c:	b580      	push	{r7, lr}
 800a97e:	b084      	sub	sp, #16
 800a980:	af00      	add	r7, sp, #0
 800a982:	6078      	str	r0, [r7, #4]
#if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
  size_t i;
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
 800a984:	687b      	ldr	r3, [r7, #4]
 800a986:	2b00      	cmp	r3, #0
 800a988:	d106      	bne.n	800a998 <tcp_listen_closed+0x1c>
 800a98a:	4b15      	ldr	r3, [pc, #84]	; (800a9e0 <tcp_listen_closed+0x64>)
 800a98c:	2212      	movs	r2, #18
 800a98e:	32ff      	adds	r2, #255	; 0xff
 800a990:	4914      	ldr	r1, [pc, #80]	; (800a9e4 <tcp_listen_closed+0x68>)
 800a992:	4815      	ldr	r0, [pc, #84]	; (800a9e8 <tcp_listen_closed+0x6c>)
 800a994:	f7f7 ffa2 	bl	80028dc <app_debug_rtt_raw>
  LWIP_ASSERT("pcb->state == LISTEN", pcb->state == LISTEN);
 800a998:	687b      	ldr	r3, [r7, #4]
 800a99a:	7e1b      	ldrb	r3, [r3, #24]
 800a99c:	2b01      	cmp	r3, #1
 800a99e:	d006      	beq.n	800a9ae <tcp_listen_closed+0x32>
 800a9a0:	4b0f      	ldr	r3, [pc, #60]	; (800a9e0 <tcp_listen_closed+0x64>)
 800a9a2:	2289      	movs	r2, #137	; 0x89
 800a9a4:	0052      	lsls	r2, r2, #1
 800a9a6:	4911      	ldr	r1, [pc, #68]	; (800a9ec <tcp_listen_closed+0x70>)
 800a9a8:	480f      	ldr	r0, [pc, #60]	; (800a9e8 <tcp_listen_closed+0x6c>)
 800a9aa:	f7f7 ff97 	bl	80028dc <app_debug_rtt_raw>
  for (i = 1; i < LWIP_ARRAYSIZE(tcp_pcb_lists); i++) {
 800a9ae:	2301      	movs	r3, #1
 800a9b0:	60fb      	str	r3, [r7, #12]
 800a9b2:	e00c      	b.n	800a9ce <tcp_listen_closed+0x52>
    tcp_remove_listener(*tcp_pcb_lists[i], (struct tcp_pcb_listen *)pcb);
 800a9b4:	4b0e      	ldr	r3, [pc, #56]	; (800a9f0 <tcp_listen_closed+0x74>)
 800a9b6:	68fa      	ldr	r2, [r7, #12]
 800a9b8:	0092      	lsls	r2, r2, #2
 800a9ba:	58d3      	ldr	r3, [r2, r3]
 800a9bc:	681b      	ldr	r3, [r3, #0]
 800a9be:	687a      	ldr	r2, [r7, #4]
 800a9c0:	0011      	movs	r1, r2
 800a9c2:	0018      	movs	r0, r3
 800a9c4:	f7ff ffae 	bl	800a924 <tcp_remove_listener>
  for (i = 1; i < LWIP_ARRAYSIZE(tcp_pcb_lists); i++) {
 800a9c8:	68fb      	ldr	r3, [r7, #12]
 800a9ca:	3301      	adds	r3, #1
 800a9cc:	60fb      	str	r3, [r7, #12]
 800a9ce:	68fb      	ldr	r3, [r7, #12]
 800a9d0:	2b03      	cmp	r3, #3
 800a9d2:	d9ef      	bls.n	800a9b4 <tcp_listen_closed+0x38>
  }
#endif
  LWIP_UNUSED_ARG(pcb);
}
 800a9d4:	46c0      	nop			; (mov r8, r8)
 800a9d6:	46c0      	nop			; (mov r8, r8)
 800a9d8:	46bd      	mov	sp, r7
 800a9da:	b004      	add	sp, #16
 800a9dc:	bd80      	pop	{r7, pc}
 800a9de:	46c0      	nop			; (mov r8, r8)
 800a9e0:	0801fa7c 	.word	0x0801fa7c
 800a9e4:	0801fb28 	.word	0x0801fb28
 800a9e8:	0801fab8 	.word	0x0801fab8
 800a9ec:	0801fb34 	.word	0x0801fb34
 800a9f0:	08022434 	.word	0x08022434

0800a9f4 <tcp_close_shutdown>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
static err_t
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
 800a9f4:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a9f6:	b089      	sub	sp, #36	; 0x24
 800a9f8:	af04      	add	r7, sp, #16
 800a9fa:	6078      	str	r0, [r7, #4]
 800a9fc:	000a      	movs	r2, r1
 800a9fe:	1cfb      	adds	r3, r7, #3
 800aa00:	701a      	strb	r2, [r3, #0]
  LWIP_ASSERT("tcp_close_shutdown: invalid pcb", pcb != NULL);
 800aa02:	687b      	ldr	r3, [r7, #4]
 800aa04:	2b00      	cmp	r3, #0
 800aa06:	d106      	bne.n	800aa16 <tcp_close_shutdown+0x22>
 800aa08:	4b69      	ldr	r3, [pc, #420]	; (800abb0 <tcp_close_shutdown+0x1bc>)
 800aa0a:	22af      	movs	r2, #175	; 0xaf
 800aa0c:	0052      	lsls	r2, r2, #1
 800aa0e:	4969      	ldr	r1, [pc, #420]	; (800abb4 <tcp_close_shutdown+0x1c0>)
 800aa10:	4869      	ldr	r0, [pc, #420]	; (800abb8 <tcp_close_shutdown+0x1c4>)
 800aa12:	f7f7 ff63 	bl	80028dc <app_debug_rtt_raw>

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
 800aa16:	1cfb      	adds	r3, r7, #3
 800aa18:	781b      	ldrb	r3, [r3, #0]
 800aa1a:	2b00      	cmp	r3, #0
 800aa1c:	d100      	bne.n	800aa20 <tcp_close_shutdown+0x2c>
 800aa1e:	e069      	b.n	800aaf4 <tcp_close_shutdown+0x100>
 800aa20:	687b      	ldr	r3, [r7, #4]
 800aa22:	7e1b      	ldrb	r3, [r3, #24]
 800aa24:	2b04      	cmp	r3, #4
 800aa26:	d003      	beq.n	800aa30 <tcp_close_shutdown+0x3c>
 800aa28:	687b      	ldr	r3, [r7, #4]
 800aa2a:	7e1b      	ldrb	r3, [r3, #24]
 800aa2c:	2b07      	cmp	r3, #7
 800aa2e:	d161      	bne.n	800aaf4 <tcp_close_shutdown+0x100>
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND_MAX(pcb))) {
 800aa30:	687b      	ldr	r3, [r7, #4]
 800aa32:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800aa34:	2b00      	cmp	r3, #0
 800aa36:	d105      	bne.n	800aa44 <tcp_close_shutdown+0x50>
 800aa38:	687b      	ldr	r3, [r7, #4]
 800aa3a:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800aa3c:	2386      	movs	r3, #134	; 0x86
 800aa3e:	00db      	lsls	r3, r3, #3
 800aa40:	429a      	cmp	r2, r3
 800aa42:	d057      	beq.n	800aaf4 <tcp_close_shutdown+0x100>
      /* Not all data received by application, send RST to tell the remote
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
 800aa44:	687b      	ldr	r3, [r7, #4]
 800aa46:	8bdb      	ldrh	r3, [r3, #30]
 800aa48:	001a      	movs	r2, r3
 800aa4a:	2310      	movs	r3, #16
 800aa4c:	4013      	ands	r3, r2
 800aa4e:	d106      	bne.n	800aa5e <tcp_close_shutdown+0x6a>
 800aa50:	4b57      	ldr	r3, [pc, #348]	; (800abb0 <tcp_close_shutdown+0x1bc>)
 800aa52:	22b2      	movs	r2, #178	; 0xb2
 800aa54:	0052      	lsls	r2, r2, #1
 800aa56:	4959      	ldr	r1, [pc, #356]	; (800abbc <tcp_close_shutdown+0x1c8>)
 800aa58:	4857      	ldr	r0, [pc, #348]	; (800abb8 <tcp_close_shutdown+0x1c4>)
 800aa5a:	f7f7 ff3f 	bl	80028dc <app_debug_rtt_raw>

      /* don't call tcp_abort here: we must not deallocate the pcb since
         that might not be expected when calling tcp_close */
      tcp_rst(pcb, pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 800aa5e:	687b      	ldr	r3, [r7, #4]
 800aa60:	6d5c      	ldr	r4, [r3, #84]	; 0x54
 800aa62:	687b      	ldr	r3, [r7, #4]
 800aa64:	6a9d      	ldr	r5, [r3, #40]	; 0x28
 800aa66:	687e      	ldr	r6, [r7, #4]
 800aa68:	687b      	ldr	r3, [r7, #4]
 800aa6a:	3304      	adds	r3, #4
 800aa6c:	687a      	ldr	r2, [r7, #4]
 800aa6e:	8b52      	ldrh	r2, [r2, #26]
 800aa70:	6879      	ldr	r1, [r7, #4]
 800aa72:	8b89      	ldrh	r1, [r1, #28]
 800aa74:	6878      	ldr	r0, [r7, #4]
 800aa76:	9102      	str	r1, [sp, #8]
 800aa78:	9201      	str	r2, [sp, #4]
 800aa7a:	9300      	str	r3, [sp, #0]
 800aa7c:	0033      	movs	r3, r6
 800aa7e:	002a      	movs	r2, r5
 800aa80:	0021      	movs	r1, r4
 800aa82:	f007 f859 	bl	8011b38 <tcp_rst>
              pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
 800aa86:	687b      	ldr	r3, [r7, #4]
 800aa88:	0018      	movs	r0, r3
 800aa8a:	f001 fbd5 	bl	800c238 <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 800aa8e:	4b4c      	ldr	r3, [pc, #304]	; (800abc0 <tcp_close_shutdown+0x1cc>)
 800aa90:	681b      	ldr	r3, [r3, #0]
 800aa92:	687a      	ldr	r2, [r7, #4]
 800aa94:	429a      	cmp	r2, r3
 800aa96:	d105      	bne.n	800aaa4 <tcp_close_shutdown+0xb0>
 800aa98:	4b49      	ldr	r3, [pc, #292]	; (800abc0 <tcp_close_shutdown+0x1cc>)
 800aa9a:	681b      	ldr	r3, [r3, #0]
 800aa9c:	691a      	ldr	r2, [r3, #16]
 800aa9e:	4b48      	ldr	r3, [pc, #288]	; (800abc0 <tcp_close_shutdown+0x1cc>)
 800aaa0:	601a      	str	r2, [r3, #0]
 800aaa2:	e013      	b.n	800aacc <tcp_close_shutdown+0xd8>
 800aaa4:	4b46      	ldr	r3, [pc, #280]	; (800abc0 <tcp_close_shutdown+0x1cc>)
 800aaa6:	681b      	ldr	r3, [r3, #0]
 800aaa8:	60fb      	str	r3, [r7, #12]
 800aaaa:	e00c      	b.n	800aac6 <tcp_close_shutdown+0xd2>
 800aaac:	68fb      	ldr	r3, [r7, #12]
 800aaae:	691b      	ldr	r3, [r3, #16]
 800aab0:	687a      	ldr	r2, [r7, #4]
 800aab2:	429a      	cmp	r2, r3
 800aab4:	d104      	bne.n	800aac0 <tcp_close_shutdown+0xcc>
 800aab6:	687b      	ldr	r3, [r7, #4]
 800aab8:	691a      	ldr	r2, [r3, #16]
 800aaba:	68fb      	ldr	r3, [r7, #12]
 800aabc:	611a      	str	r2, [r3, #16]
 800aabe:	e005      	b.n	800aacc <tcp_close_shutdown+0xd8>
 800aac0:	68fb      	ldr	r3, [r7, #12]
 800aac2:	691b      	ldr	r3, [r3, #16]
 800aac4:	60fb      	str	r3, [r7, #12]
 800aac6:	68fb      	ldr	r3, [r7, #12]
 800aac8:	2b00      	cmp	r3, #0
 800aaca:	d1ef      	bne.n	800aaac <tcp_close_shutdown+0xb8>
 800aacc:	687b      	ldr	r3, [r7, #4]
 800aace:	2200      	movs	r2, #0
 800aad0:	611a      	str	r2, [r3, #16]
 800aad2:	4b3c      	ldr	r3, [pc, #240]	; (800abc4 <tcp_close_shutdown+0x1d0>)
 800aad4:	2201      	movs	r2, #1
 800aad6:	701a      	strb	r2, [r3, #0]
      /* Deallocate the pcb since we already sent a RST for it */
      if (tcp_input_pcb == pcb) {
 800aad8:	4b3b      	ldr	r3, [pc, #236]	; (800abc8 <tcp_close_shutdown+0x1d4>)
 800aada:	681b      	ldr	r3, [r3, #0]
 800aadc:	687a      	ldr	r2, [r7, #4]
 800aade:	429a      	cmp	r2, r3
 800aae0:	d102      	bne.n	800aae8 <tcp_close_shutdown+0xf4>
        /* prevent using a deallocated pcb: free it from tcp_input later */
        tcp_trigger_input_pcb_close();
 800aae2:	f004 fc25 	bl	800f330 <tcp_trigger_input_pcb_close>
 800aae6:	e003      	b.n	800aaf0 <tcp_close_shutdown+0xfc>
      } else {
        tcp_free(pcb);
 800aae8:	687b      	ldr	r3, [r7, #4]
 800aaea:	0018      	movs	r0, r3
 800aaec:	f7ff fec6 	bl	800a87c <tcp_free>
      }
      return ERR_OK;
 800aaf0:	2300      	movs	r3, #0
 800aaf2:	e058      	b.n	800aba6 <tcp_close_shutdown+0x1b2>
    }
  }

  /* - states which free the pcb are handled here,
     - states which send FIN and change state are handled in tcp_close_shutdown_fin() */
  switch (pcb->state) {
 800aaf4:	687b      	ldr	r3, [r7, #4]
 800aaf6:	7e1b      	ldrb	r3, [r3, #24]
 800aaf8:	2b02      	cmp	r3, #2
 800aafa:	d03f      	beq.n	800ab7c <tcp_close_shutdown+0x188>
 800aafc:	dc4c      	bgt.n	800ab98 <tcp_close_shutdown+0x1a4>
 800aafe:	2b00      	cmp	r3, #0
 800ab00:	d002      	beq.n	800ab08 <tcp_close_shutdown+0x114>
 800ab02:	2b01      	cmp	r3, #1
 800ab04:	d02b      	beq.n	800ab5e <tcp_close_shutdown+0x16a>
 800ab06:	e047      	b.n	800ab98 <tcp_close_shutdown+0x1a4>
       * and the user needs some way to free it should the need arise.
       * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
       * or for a pcb that has been used and then entered the CLOSED state
       * is erroneous, but this should never happen as the pcb has in those cases
       * been freed, and so any remaining handles are bogus. */
      if (pcb->local_port != 0) {
 800ab08:	687b      	ldr	r3, [r7, #4]
 800ab0a:	8b5b      	ldrh	r3, [r3, #26]
 800ab0c:	2b00      	cmp	r3, #0
 800ab0e:	d021      	beq.n	800ab54 <tcp_close_shutdown+0x160>
        TCP_RMV(&tcp_bound_pcbs, pcb);
 800ab10:	4b2e      	ldr	r3, [pc, #184]	; (800abcc <tcp_close_shutdown+0x1d8>)
 800ab12:	681b      	ldr	r3, [r3, #0]
 800ab14:	687a      	ldr	r2, [r7, #4]
 800ab16:	429a      	cmp	r2, r3
 800ab18:	d105      	bne.n	800ab26 <tcp_close_shutdown+0x132>
 800ab1a:	4b2c      	ldr	r3, [pc, #176]	; (800abcc <tcp_close_shutdown+0x1d8>)
 800ab1c:	681b      	ldr	r3, [r3, #0]
 800ab1e:	691a      	ldr	r2, [r3, #16]
 800ab20:	4b2a      	ldr	r3, [pc, #168]	; (800abcc <tcp_close_shutdown+0x1d8>)
 800ab22:	601a      	str	r2, [r3, #0]
 800ab24:	e013      	b.n	800ab4e <tcp_close_shutdown+0x15a>
 800ab26:	4b29      	ldr	r3, [pc, #164]	; (800abcc <tcp_close_shutdown+0x1d8>)
 800ab28:	681b      	ldr	r3, [r3, #0]
 800ab2a:	60bb      	str	r3, [r7, #8]
 800ab2c:	e00c      	b.n	800ab48 <tcp_close_shutdown+0x154>
 800ab2e:	68bb      	ldr	r3, [r7, #8]
 800ab30:	691b      	ldr	r3, [r3, #16]
 800ab32:	687a      	ldr	r2, [r7, #4]
 800ab34:	429a      	cmp	r2, r3
 800ab36:	d104      	bne.n	800ab42 <tcp_close_shutdown+0x14e>
 800ab38:	687b      	ldr	r3, [r7, #4]
 800ab3a:	691a      	ldr	r2, [r3, #16]
 800ab3c:	68bb      	ldr	r3, [r7, #8]
 800ab3e:	611a      	str	r2, [r3, #16]
 800ab40:	e005      	b.n	800ab4e <tcp_close_shutdown+0x15a>
 800ab42:	68bb      	ldr	r3, [r7, #8]
 800ab44:	691b      	ldr	r3, [r3, #16]
 800ab46:	60bb      	str	r3, [r7, #8]
 800ab48:	68bb      	ldr	r3, [r7, #8]
 800ab4a:	2b00      	cmp	r3, #0
 800ab4c:	d1ef      	bne.n	800ab2e <tcp_close_shutdown+0x13a>
 800ab4e:	687b      	ldr	r3, [r7, #4]
 800ab50:	2200      	movs	r2, #0
 800ab52:	611a      	str	r2, [r3, #16]
      }
      tcp_free(pcb);
 800ab54:	687b      	ldr	r3, [r7, #4]
 800ab56:	0018      	movs	r0, r3
 800ab58:	f7ff fe90 	bl	800a87c <tcp_free>
      break;
 800ab5c:	e022      	b.n	800aba4 <tcp_close_shutdown+0x1b0>
    case LISTEN:
      tcp_listen_closed(pcb);
 800ab5e:	687b      	ldr	r3, [r7, #4]
 800ab60:	0018      	movs	r0, r3
 800ab62:	f7ff ff0b 	bl	800a97c <tcp_listen_closed>
      tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
 800ab66:	687a      	ldr	r2, [r7, #4]
 800ab68:	4b19      	ldr	r3, [pc, #100]	; (800abd0 <tcp_close_shutdown+0x1dc>)
 800ab6a:	0011      	movs	r1, r2
 800ab6c:	0018      	movs	r0, r3
 800ab6e:	f001 fbad 	bl	800c2cc <tcp_pcb_remove>
      tcp_free_listen(pcb);
 800ab72:	687b      	ldr	r3, [r7, #4]
 800ab74:	0018      	movs	r0, r3
 800ab76:	f7ff fe9f 	bl	800a8b8 <tcp_free_listen>
      break;
 800ab7a:	e013      	b.n	800aba4 <tcp_close_shutdown+0x1b0>
    case SYN_SENT:
      TCP_PCB_REMOVE_ACTIVE(pcb);
 800ab7c:	687a      	ldr	r2, [r7, #4]
 800ab7e:	4b10      	ldr	r3, [pc, #64]	; (800abc0 <tcp_close_shutdown+0x1cc>)
 800ab80:	0011      	movs	r1, r2
 800ab82:	0018      	movs	r0, r3
 800ab84:	f001 fba2 	bl	800c2cc <tcp_pcb_remove>
 800ab88:	4b0e      	ldr	r3, [pc, #56]	; (800abc4 <tcp_close_shutdown+0x1d0>)
 800ab8a:	2201      	movs	r2, #1
 800ab8c:	701a      	strb	r2, [r3, #0]
      tcp_free(pcb);
 800ab8e:	687b      	ldr	r3, [r7, #4]
 800ab90:	0018      	movs	r0, r3
 800ab92:	f7ff fe73 	bl	800a87c <tcp_free>
      MIB2_STATS_INC(mib2.tcpattemptfails);
      break;
 800ab96:	e005      	b.n	800aba4 <tcp_close_shutdown+0x1b0>
    default:
      return tcp_close_shutdown_fin(pcb);
 800ab98:	687b      	ldr	r3, [r7, #4]
 800ab9a:	0018      	movs	r0, r3
 800ab9c:	f000 f81a 	bl	800abd4 <tcp_close_shutdown_fin>
 800aba0:	0003      	movs	r3, r0
 800aba2:	e000      	b.n	800aba6 <tcp_close_shutdown+0x1b2>
  }
  return ERR_OK;
 800aba4:	2300      	movs	r3, #0
}
 800aba6:	0018      	movs	r0, r3
 800aba8:	46bd      	mov	sp, r7
 800abaa:	b005      	add	sp, #20
 800abac:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800abae:	46c0      	nop			; (mov r8, r8)
 800abb0:	0801fa7c 	.word	0x0801fa7c
 800abb4:	0801fb4c 	.word	0x0801fb4c
 800abb8:	0801fab8 	.word	0x0801fab8
 800abbc:	0801fb6c 	.word	0x0801fb6c
 800abc0:	20002ed4 	.word	0x20002ed4
 800abc4:	20002ed0 	.word	0x20002ed0
 800abc8:	20002ee8 	.word	0x20002ee8
 800abcc:	20002ee0 	.word	0x20002ee0
 800abd0:	20002edc 	.word	0x20002edc

0800abd4 <tcp_close_shutdown_fin>:

static err_t
tcp_close_shutdown_fin(struct tcp_pcb *pcb)
{
 800abd4:	b5b0      	push	{r4, r5, r7, lr}
 800abd6:	b084      	sub	sp, #16
 800abd8:	af00      	add	r7, sp, #0
 800abda:	6078      	str	r0, [r7, #4]
  err_t err;
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
 800abdc:	687b      	ldr	r3, [r7, #4]
 800abde:	2b00      	cmp	r3, #0
 800abe0:	d106      	bne.n	800abf0 <tcp_close_shutdown_fin+0x1c>
 800abe2:	4b36      	ldr	r3, [pc, #216]	; (800acbc <tcp_close_shutdown_fin+0xe8>)
 800abe4:	22ce      	movs	r2, #206	; 0xce
 800abe6:	0052      	lsls	r2, r2, #1
 800abe8:	4935      	ldr	r1, [pc, #212]	; (800acc0 <tcp_close_shutdown_fin+0xec>)
 800abea:	4836      	ldr	r0, [pc, #216]	; (800acc4 <tcp_close_shutdown_fin+0xf0>)
 800abec:	f7f7 fe76 	bl	80028dc <app_debug_rtt_raw>

  switch (pcb->state) {
 800abf0:	687b      	ldr	r3, [r7, #4]
 800abf2:	7e1b      	ldrb	r3, [r3, #24]
 800abf4:	2b07      	cmp	r3, #7
 800abf6:	d027      	beq.n	800ac48 <tcp_close_shutdown_fin+0x74>
 800abf8:	dc37      	bgt.n	800ac6a <tcp_close_shutdown_fin+0x96>
 800abfa:	2b03      	cmp	r3, #3
 800abfc:	d002      	beq.n	800ac04 <tcp_close_shutdown_fin+0x30>
 800abfe:	2b04      	cmp	r3, #4
 800ac00:	d011      	beq.n	800ac26 <tcp_close_shutdown_fin+0x52>
 800ac02:	e032      	b.n	800ac6a <tcp_close_shutdown_fin+0x96>
    case SYN_RCVD:
      err = tcp_send_fin(pcb);
 800ac04:	250f      	movs	r5, #15
 800ac06:	197c      	adds	r4, r7, r5
 800ac08:	687b      	ldr	r3, [r7, #4]
 800ac0a:	0018      	movs	r0, r3
 800ac0c:	f005 fdd0 	bl	80107b0 <tcp_send_fin>
 800ac10:	0003      	movs	r3, r0
 800ac12:	7023      	strb	r3, [r4, #0]
      if (err == ERR_OK) {
 800ac14:	197b      	adds	r3, r7, r5
 800ac16:	781b      	ldrb	r3, [r3, #0]
 800ac18:	b25b      	sxtb	r3, r3
 800ac1a:	2b00      	cmp	r3, #0
 800ac1c:	d127      	bne.n	800ac6e <tcp_close_shutdown_fin+0x9a>
        tcp_backlog_accepted(pcb);
        MIB2_STATS_INC(mib2.tcpattemptfails);
        pcb->state = FIN_WAIT_1;
 800ac1e:	687b      	ldr	r3, [r7, #4]
 800ac20:	2205      	movs	r2, #5
 800ac22:	761a      	strb	r2, [r3, #24]
      }
      break;
 800ac24:	e023      	b.n	800ac6e <tcp_close_shutdown_fin+0x9a>
    case ESTABLISHED:
      err = tcp_send_fin(pcb);
 800ac26:	250f      	movs	r5, #15
 800ac28:	197c      	adds	r4, r7, r5
 800ac2a:	687b      	ldr	r3, [r7, #4]
 800ac2c:	0018      	movs	r0, r3
 800ac2e:	f005 fdbf 	bl	80107b0 <tcp_send_fin>
 800ac32:	0003      	movs	r3, r0
 800ac34:	7023      	strb	r3, [r4, #0]
      if (err == ERR_OK) {
 800ac36:	197b      	adds	r3, r7, r5
 800ac38:	781b      	ldrb	r3, [r3, #0]
 800ac3a:	b25b      	sxtb	r3, r3
 800ac3c:	2b00      	cmp	r3, #0
 800ac3e:	d118      	bne.n	800ac72 <tcp_close_shutdown_fin+0x9e>
        MIB2_STATS_INC(mib2.tcpestabresets);
        pcb->state = FIN_WAIT_1;
 800ac40:	687b      	ldr	r3, [r7, #4]
 800ac42:	2205      	movs	r2, #5
 800ac44:	761a      	strb	r2, [r3, #24]
      }
      break;
 800ac46:	e014      	b.n	800ac72 <tcp_close_shutdown_fin+0x9e>
    case CLOSE_WAIT:
      err = tcp_send_fin(pcb);
 800ac48:	250f      	movs	r5, #15
 800ac4a:	197c      	adds	r4, r7, r5
 800ac4c:	687b      	ldr	r3, [r7, #4]
 800ac4e:	0018      	movs	r0, r3
 800ac50:	f005 fdae 	bl	80107b0 <tcp_send_fin>
 800ac54:	0003      	movs	r3, r0
 800ac56:	7023      	strb	r3, [r4, #0]
      if (err == ERR_OK) {
 800ac58:	197b      	adds	r3, r7, r5
 800ac5a:	781b      	ldrb	r3, [r3, #0]
 800ac5c:	b25b      	sxtb	r3, r3
 800ac5e:	2b00      	cmp	r3, #0
 800ac60:	d109      	bne.n	800ac76 <tcp_close_shutdown_fin+0xa2>
        MIB2_STATS_INC(mib2.tcpestabresets);
        pcb->state = LAST_ACK;
 800ac62:	687b      	ldr	r3, [r7, #4]
 800ac64:	2209      	movs	r2, #9
 800ac66:	761a      	strb	r2, [r3, #24]
      }
      break;
 800ac68:	e005      	b.n	800ac76 <tcp_close_shutdown_fin+0xa2>
    default:
      /* Has already been closed, do nothing. */
      return ERR_OK;
 800ac6a:	2300      	movs	r3, #0
 800ac6c:	e022      	b.n	800acb4 <tcp_close_shutdown_fin+0xe0>
      break;
 800ac6e:	46c0      	nop			; (mov r8, r8)
 800ac70:	e002      	b.n	800ac78 <tcp_close_shutdown_fin+0xa4>
      break;
 800ac72:	46c0      	nop			; (mov r8, r8)
 800ac74:	e000      	b.n	800ac78 <tcp_close_shutdown_fin+0xa4>
      break;
 800ac76:	46c0      	nop			; (mov r8, r8)
  }

  if (err == ERR_OK) {
 800ac78:	230f      	movs	r3, #15
 800ac7a:	18fb      	adds	r3, r7, r3
 800ac7c:	781b      	ldrb	r3, [r3, #0]
 800ac7e:	b25b      	sxtb	r3, r3
 800ac80:	2b00      	cmp	r3, #0
 800ac82:	d104      	bne.n	800ac8e <tcp_close_shutdown_fin+0xba>
    /* To ensure all data has been sent when tcp_close returns, we have
       to make sure tcp_output doesn't fail.
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    tcp_output(pcb);
 800ac84:	687b      	ldr	r3, [r7, #4]
 800ac86:	0018      	movs	r0, r3
 800ac88:	f005 ff02 	bl	8010a90 <tcp_output>
 800ac8c:	e00e      	b.n	800acac <tcp_close_shutdown_fin+0xd8>
  } else if (err == ERR_MEM) {
 800ac8e:	230f      	movs	r3, #15
 800ac90:	18fb      	adds	r3, r7, r3
 800ac92:	781b      	ldrb	r3, [r3, #0]
 800ac94:	b25b      	sxtb	r3, r3
 800ac96:	3301      	adds	r3, #1
 800ac98:	d108      	bne.n	800acac <tcp_close_shutdown_fin+0xd8>
    /* Mark this pcb for closing. Closing is retried from tcp_tmr. */
    tcp_set_flags(pcb, TF_CLOSEPEND);
 800ac9a:	687b      	ldr	r3, [r7, #4]
 800ac9c:	8bdb      	ldrh	r3, [r3, #30]
 800ac9e:	2208      	movs	r2, #8
 800aca0:	4313      	orrs	r3, r2
 800aca2:	b29a      	uxth	r2, r3
 800aca4:	687b      	ldr	r3, [r7, #4]
 800aca6:	83da      	strh	r2, [r3, #30]
    /* We have to return ERR_OK from here to indicate to the callers that this
       pcb should not be used any more as it will be freed soon via tcp_tmr.
       This is OK here since sending FIN does not guarantee a time frime for
       actually freeing the pcb, either (it is left in closure states for
       remote ACK or timeout) */
    return ERR_OK;
 800aca8:	2300      	movs	r3, #0
 800acaa:	e003      	b.n	800acb4 <tcp_close_shutdown_fin+0xe0>
  }
  return err;
 800acac:	230f      	movs	r3, #15
 800acae:	18fb      	adds	r3, r7, r3
 800acb0:	781b      	ldrb	r3, [r3, #0]
 800acb2:	b25b      	sxtb	r3, r3
}
 800acb4:	0018      	movs	r0, r3
 800acb6:	46bd      	mov	sp, r7
 800acb8:	b004      	add	sp, #16
 800acba:	bdb0      	pop	{r4, r5, r7, pc}
 800acbc:	0801fa7c 	.word	0x0801fa7c
 800acc0:	0801fb28 	.word	0x0801fb28
 800acc4:	0801fab8 	.word	0x0801fab8

0800acc8 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
 800acc8:	b580      	push	{r7, lr}
 800acca:	b082      	sub	sp, #8
 800accc:	af00      	add	r7, sp, #0
 800acce:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_close: invalid pcb", pcb != NULL, return ERR_ARG);
 800acd0:	687b      	ldr	r3, [r7, #4]
 800acd2:	2b00      	cmp	r3, #0
 800acd4:	d106      	bne.n	800ace4 <tcp_close+0x1c>
 800acd6:	4b0e      	ldr	r3, [pc, #56]	; (800ad10 <tcp_close+0x48>)
 800acd8:	0018      	movs	r0, r3
 800acda:	f7f7 fdff 	bl	80028dc <app_debug_rtt_raw>
 800acde:	2310      	movs	r3, #16
 800ace0:	425b      	negs	r3, r3
 800ace2:	e010      	b.n	800ad06 <tcp_close+0x3e>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));

  tcp_debug_print_state(pcb->state);

  if (pcb->state != LISTEN) {
 800ace4:	687b      	ldr	r3, [r7, #4]
 800ace6:	7e1b      	ldrb	r3, [r3, #24]
 800ace8:	2b01      	cmp	r3, #1
 800acea:	d006      	beq.n	800acfa <tcp_close+0x32>
    /* Set a flag not to receive any more data... */
    tcp_set_flags(pcb, TF_RXCLOSED);
 800acec:	687b      	ldr	r3, [r7, #4]
 800acee:	8bdb      	ldrh	r3, [r3, #30]
 800acf0:	2210      	movs	r2, #16
 800acf2:	4313      	orrs	r3, r2
 800acf4:	b29a      	uxth	r2, r3
 800acf6:	687b      	ldr	r3, [r7, #4]
 800acf8:	83da      	strh	r2, [r3, #30]
  }
  /* ... and close */
  return tcp_close_shutdown(pcb, 1);
 800acfa:	687b      	ldr	r3, [r7, #4]
 800acfc:	2101      	movs	r1, #1
 800acfe:	0018      	movs	r0, r3
 800ad00:	f7ff fe78 	bl	800a9f4 <tcp_close_shutdown>
 800ad04:	0003      	movs	r3, r0
}
 800ad06:	0018      	movs	r0, r3
 800ad08:	46bd      	mov	sp, r7
 800ad0a:	b002      	add	sp, #8
 800ad0c:	bd80      	pop	{r7, pc}
 800ad0e:	46c0      	nop			; (mov r8, r8)
 800ad10:	0801fb88 	.word	0x0801fb88

0800ad14 <tcp_abandon>:
 * @param pcb the tcp_pcb to abort
 * @param reset boolean to indicate whether a reset should be sent
 */
void
tcp_abandon(struct tcp_pcb *pcb, int reset)
{
 800ad14:	b5b0      	push	{r4, r5, r7, lr}
 800ad16:	b08e      	sub	sp, #56	; 0x38
 800ad18:	af04      	add	r7, sp, #16
 800ad1a:	6078      	str	r0, [r7, #4]
 800ad1c:	6039      	str	r1, [r7, #0]
#endif /* LWIP_CALLBACK_API */
  void *errf_arg;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_abandon: invalid pcb", pcb != NULL, return);
 800ad1e:	687b      	ldr	r3, [r7, #4]
 800ad20:	2b00      	cmp	r3, #0
 800ad22:	d104      	bne.n	800ad2e <tcp_abandon+0x1a>
 800ad24:	4b58      	ldr	r3, [pc, #352]	; (800ae88 <tcp_abandon+0x174>)
 800ad26:	0018      	movs	r0, r3
 800ad28:	f7f7 fdd8 	bl	80028dc <app_debug_rtt_raw>
 800ad2c:	e0a9      	b.n	800ae82 <tcp_abandon+0x16e>

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
 800ad2e:	687b      	ldr	r3, [r7, #4]
 800ad30:	7e1b      	ldrb	r3, [r3, #24]
 800ad32:	2b01      	cmp	r3, #1
 800ad34:	d106      	bne.n	800ad44 <tcp_abandon+0x30>
 800ad36:	4b55      	ldr	r3, [pc, #340]	; (800ae8c <tcp_abandon+0x178>)
 800ad38:	2290      	movs	r2, #144	; 0x90
 800ad3a:	0092      	lsls	r2, r2, #2
 800ad3c:	4954      	ldr	r1, [pc, #336]	; (800ae90 <tcp_abandon+0x17c>)
 800ad3e:	4855      	ldr	r0, [pc, #340]	; (800ae94 <tcp_abandon+0x180>)
 800ad40:	f7f7 fdcc 	bl	80028dc <app_debug_rtt_raw>
              pcb->state != LISTEN);
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
 800ad44:	687b      	ldr	r3, [r7, #4]
 800ad46:	7e1b      	ldrb	r3, [r3, #24]
 800ad48:	2b0a      	cmp	r3, #10
 800ad4a:	d10a      	bne.n	800ad62 <tcp_abandon+0x4e>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
 800ad4c:	687a      	ldr	r2, [r7, #4]
 800ad4e:	4b52      	ldr	r3, [pc, #328]	; (800ae98 <tcp_abandon+0x184>)
 800ad50:	0011      	movs	r1, r2
 800ad52:	0018      	movs	r0, r3
 800ad54:	f001 faba 	bl	800c2cc <tcp_pcb_remove>
    tcp_free(pcb);
 800ad58:	687b      	ldr	r3, [r7, #4]
 800ad5a:	0018      	movs	r0, r3
 800ad5c:	f7ff fd8e 	bl	800a87c <tcp_free>
 800ad60:	e08f      	b.n	800ae82 <tcp_abandon+0x16e>
  } else {
    int send_rst = 0;
 800ad62:	2300      	movs	r3, #0
 800ad64:	627b      	str	r3, [r7, #36]	; 0x24
    u16_t local_port = 0;
 800ad66:	2322      	movs	r3, #34	; 0x22
 800ad68:	18fb      	adds	r3, r7, r3
 800ad6a:	2200      	movs	r2, #0
 800ad6c:	801a      	strh	r2, [r3, #0]
    enum tcp_state last_state;
    seqno = pcb->snd_nxt;
 800ad6e:	687b      	ldr	r3, [r7, #4]
 800ad70:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800ad72:	61bb      	str	r3, [r7, #24]
    ackno = pcb->rcv_nxt;
 800ad74:	687b      	ldr	r3, [r7, #4]
 800ad76:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ad78:	617b      	str	r3, [r7, #20]
#if LWIP_CALLBACK_API
    errf = pcb->errf;
 800ad7a:	687b      	ldr	r3, [r7, #4]
 800ad7c:	2294      	movs	r2, #148	; 0x94
 800ad7e:	589b      	ldr	r3, [r3, r2]
 800ad80:	613b      	str	r3, [r7, #16]
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
 800ad82:	687b      	ldr	r3, [r7, #4]
 800ad84:	695b      	ldr	r3, [r3, #20]
 800ad86:	60fb      	str	r3, [r7, #12]
    if (pcb->state == CLOSED) {
 800ad88:	687b      	ldr	r3, [r7, #4]
 800ad8a:	7e1b      	ldrb	r3, [r3, #24]
 800ad8c:	2b00      	cmp	r3, #0
 800ad8e:	d126      	bne.n	800adde <tcp_abandon+0xca>
      if (pcb->local_port != 0) {
 800ad90:	687b      	ldr	r3, [r7, #4]
 800ad92:	8b5b      	ldrh	r3, [r3, #26]
 800ad94:	2b00      	cmp	r3, #0
 800ad96:	d032      	beq.n	800adfe <tcp_abandon+0xea>
        /* bound, not yet opened */
        TCP_RMV(&tcp_bound_pcbs, pcb);
 800ad98:	4b40      	ldr	r3, [pc, #256]	; (800ae9c <tcp_abandon+0x188>)
 800ad9a:	681b      	ldr	r3, [r3, #0]
 800ad9c:	687a      	ldr	r2, [r7, #4]
 800ad9e:	429a      	cmp	r2, r3
 800ada0:	d105      	bne.n	800adae <tcp_abandon+0x9a>
 800ada2:	4b3e      	ldr	r3, [pc, #248]	; (800ae9c <tcp_abandon+0x188>)
 800ada4:	681b      	ldr	r3, [r3, #0]
 800ada6:	691a      	ldr	r2, [r3, #16]
 800ada8:	4b3c      	ldr	r3, [pc, #240]	; (800ae9c <tcp_abandon+0x188>)
 800adaa:	601a      	str	r2, [r3, #0]
 800adac:	e013      	b.n	800add6 <tcp_abandon+0xc2>
 800adae:	4b3b      	ldr	r3, [pc, #236]	; (800ae9c <tcp_abandon+0x188>)
 800adb0:	681b      	ldr	r3, [r3, #0]
 800adb2:	61fb      	str	r3, [r7, #28]
 800adb4:	e00c      	b.n	800add0 <tcp_abandon+0xbc>
 800adb6:	69fb      	ldr	r3, [r7, #28]
 800adb8:	691b      	ldr	r3, [r3, #16]
 800adba:	687a      	ldr	r2, [r7, #4]
 800adbc:	429a      	cmp	r2, r3
 800adbe:	d104      	bne.n	800adca <tcp_abandon+0xb6>
 800adc0:	687b      	ldr	r3, [r7, #4]
 800adc2:	691a      	ldr	r2, [r3, #16]
 800adc4:	69fb      	ldr	r3, [r7, #28]
 800adc6:	611a      	str	r2, [r3, #16]
 800adc8:	e005      	b.n	800add6 <tcp_abandon+0xc2>
 800adca:	69fb      	ldr	r3, [r7, #28]
 800adcc:	691b      	ldr	r3, [r3, #16]
 800adce:	61fb      	str	r3, [r7, #28]
 800add0:	69fb      	ldr	r3, [r7, #28]
 800add2:	2b00      	cmp	r3, #0
 800add4:	d1ef      	bne.n	800adb6 <tcp_abandon+0xa2>
 800add6:	687b      	ldr	r3, [r7, #4]
 800add8:	2200      	movs	r2, #0
 800adda:	611a      	str	r2, [r3, #16]
 800addc:	e00f      	b.n	800adfe <tcp_abandon+0xea>
      }
    } else {
      send_rst = reset;
 800adde:	683b      	ldr	r3, [r7, #0]
 800ade0:	627b      	str	r3, [r7, #36]	; 0x24
      local_port = pcb->local_port;
 800ade2:	2322      	movs	r3, #34	; 0x22
 800ade4:	18fb      	adds	r3, r7, r3
 800ade6:	687a      	ldr	r2, [r7, #4]
 800ade8:	8b52      	ldrh	r2, [r2, #26]
 800adea:	801a      	strh	r2, [r3, #0]
      TCP_PCB_REMOVE_ACTIVE(pcb);
 800adec:	687a      	ldr	r2, [r7, #4]
 800adee:	4b2c      	ldr	r3, [pc, #176]	; (800aea0 <tcp_abandon+0x18c>)
 800adf0:	0011      	movs	r1, r2
 800adf2:	0018      	movs	r0, r3
 800adf4:	f001 fa6a 	bl	800c2cc <tcp_pcb_remove>
 800adf8:	4b2a      	ldr	r3, [pc, #168]	; (800aea4 <tcp_abandon+0x190>)
 800adfa:	2201      	movs	r2, #1
 800adfc:	701a      	strb	r2, [r3, #0]
    }
    if (pcb->unacked != NULL) {
 800adfe:	687b      	ldr	r3, [r7, #4]
 800ae00:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800ae02:	2b00      	cmp	r3, #0
 800ae04:	d004      	beq.n	800ae10 <tcp_abandon+0xfc>
      tcp_segs_free(pcb->unacked);
 800ae06:	687b      	ldr	r3, [r7, #4]
 800ae08:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800ae0a:	0018      	movs	r0, r3
 800ae0c:	f000 ff36 	bl	800bc7c <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
 800ae10:	687b      	ldr	r3, [r7, #4]
 800ae12:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800ae14:	2b00      	cmp	r3, #0
 800ae16:	d004      	beq.n	800ae22 <tcp_abandon+0x10e>
      tcp_segs_free(pcb->unsent);
 800ae18:	687b      	ldr	r3, [r7, #4]
 800ae1a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800ae1c:	0018      	movs	r0, r3
 800ae1e:	f000 ff2d 	bl	800bc7c <tcp_segs_free>
    }
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
 800ae22:	687b      	ldr	r3, [r7, #4]
 800ae24:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800ae26:	2b00      	cmp	r3, #0
 800ae28:	d004      	beq.n	800ae34 <tcp_abandon+0x120>
      tcp_segs_free(pcb->ooseq);
 800ae2a:	687b      	ldr	r3, [r7, #4]
 800ae2c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800ae2e:	0018      	movs	r0, r3
 800ae30:	f000 ff24 	bl	800bc7c <tcp_segs_free>
    }
#endif /* TCP_QUEUE_OOSEQ */
    tcp_backlog_accepted(pcb);
    if (send_rst) {
 800ae34:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ae36:	2b00      	cmp	r3, #0
 800ae38:	d011      	beq.n	800ae5e <tcp_abandon+0x14a>
      LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
      tcp_rst(pcb, seqno, ackno, &pcb->local_ip, &pcb->remote_ip, local_port, pcb->remote_port);
 800ae3a:	687d      	ldr	r5, [r7, #4]
 800ae3c:	687b      	ldr	r3, [r7, #4]
 800ae3e:	3304      	adds	r3, #4
 800ae40:	687a      	ldr	r2, [r7, #4]
 800ae42:	8b92      	ldrh	r2, [r2, #28]
 800ae44:	697c      	ldr	r4, [r7, #20]
 800ae46:	69b9      	ldr	r1, [r7, #24]
 800ae48:	6878      	ldr	r0, [r7, #4]
 800ae4a:	9202      	str	r2, [sp, #8]
 800ae4c:	2222      	movs	r2, #34	; 0x22
 800ae4e:	18ba      	adds	r2, r7, r2
 800ae50:	8812      	ldrh	r2, [r2, #0]
 800ae52:	9201      	str	r2, [sp, #4]
 800ae54:	9300      	str	r3, [sp, #0]
 800ae56:	002b      	movs	r3, r5
 800ae58:	0022      	movs	r2, r4
 800ae5a:	f006 fe6d 	bl	8011b38 <tcp_rst>
    }
    last_state = pcb->state;
 800ae5e:	230b      	movs	r3, #11
 800ae60:	18fb      	adds	r3, r7, r3
 800ae62:	687a      	ldr	r2, [r7, #4]
 800ae64:	7e12      	ldrb	r2, [r2, #24]
 800ae66:	701a      	strb	r2, [r3, #0]
    tcp_free(pcb);
 800ae68:	687b      	ldr	r3, [r7, #4]
 800ae6a:	0018      	movs	r0, r3
 800ae6c:	f7ff fd06 	bl	800a87c <tcp_free>
    TCP_EVENT_ERR(last_state, errf, errf_arg, ERR_ABRT);
 800ae70:	693b      	ldr	r3, [r7, #16]
 800ae72:	2b00      	cmp	r3, #0
 800ae74:	d005      	beq.n	800ae82 <tcp_abandon+0x16e>
 800ae76:	230d      	movs	r3, #13
 800ae78:	4259      	negs	r1, r3
 800ae7a:	68fa      	ldr	r2, [r7, #12]
 800ae7c:	693b      	ldr	r3, [r7, #16]
 800ae7e:	0010      	movs	r0, r2
 800ae80:	4798      	blx	r3
  }
}
 800ae82:	46bd      	mov	sp, r7
 800ae84:	b00a      	add	sp, #40	; 0x28
 800ae86:	bdb0      	pop	{r4, r5, r7, pc}
 800ae88:	0801fbbc 	.word	0x0801fbbc
 800ae8c:	0801fa7c 	.word	0x0801fa7c
 800ae90:	0801fbd8 	.word	0x0801fbd8
 800ae94:	0801fab8 	.word	0x0801fab8
 800ae98:	20002ee4 	.word	0x20002ee4
 800ae9c:	20002ee0 	.word	0x20002ee0
 800aea0:	20002ed4 	.word	0x20002ed4
 800aea4:	20002ed0 	.word	0x20002ed0

0800aea8 <tcp_abort>:
 *
 * @param pcb the tcp pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
 800aea8:	b580      	push	{r7, lr}
 800aeaa:	b082      	sub	sp, #8
 800aeac:	af00      	add	r7, sp, #0
 800aeae:	6078      	str	r0, [r7, #4]
  tcp_abandon(pcb, 1);
 800aeb0:	687b      	ldr	r3, [r7, #4]
 800aeb2:	2101      	movs	r1, #1
 800aeb4:	0018      	movs	r0, r3
 800aeb6:	f7ff ff2d 	bl	800ad14 <tcp_abandon>
}
 800aeba:	46c0      	nop			; (mov r8, r8)
 800aebc:	46bd      	mov	sp, r7
 800aebe:	b002      	add	sp, #8
 800aec0:	bd80      	pop	{r7, pc}
	...

0800aec4 <tcp_update_rcv_ann_wnd>:
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t
tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
 800aec4:	b580      	push	{r7, lr}
 800aec6:	b084      	sub	sp, #16
 800aec8:	af00      	add	r7, sp, #0
 800aeca:	6078      	str	r0, [r7, #4]
  u32_t new_right_edge;

  LWIP_ASSERT("tcp_update_rcv_ann_wnd: invalid pcb", pcb != NULL);
 800aecc:	687b      	ldr	r3, [r7, #4]
 800aece:	2b00      	cmp	r3, #0
 800aed0:	d105      	bne.n	800aede <tcp_update_rcv_ann_wnd+0x1a>
 800aed2:	4b26      	ldr	r3, [pc, #152]	; (800af6c <tcp_update_rcv_ann_wnd+0xa8>)
 800aed4:	4a26      	ldr	r2, [pc, #152]	; (800af70 <tcp_update_rcv_ann_wnd+0xac>)
 800aed6:	4927      	ldr	r1, [pc, #156]	; (800af74 <tcp_update_rcv_ann_wnd+0xb0>)
 800aed8:	4827      	ldr	r0, [pc, #156]	; (800af78 <tcp_update_rcv_ann_wnd+0xb4>)
 800aeda:	f7f7 fcff 	bl	80028dc <app_debug_rtt_raw>
  new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 800aede:	687b      	ldr	r3, [r7, #4]
 800aee0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800aee2:	687a      	ldr	r2, [r7, #4]
 800aee4:	8d92      	ldrh	r2, [r2, #44]	; 0x2c
 800aee6:	189b      	adds	r3, r3, r2
 800aee8:	60fb      	str	r3, [r7, #12]

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 800aeea:	687b      	ldr	r3, [r7, #4]
 800aeec:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800aeee:	687a      	ldr	r2, [r7, #4]
 800aef0:	8ed2      	ldrh	r2, [r2, #54]	; 0x36
 800aef2:	1c10      	adds	r0, r2, #0
 800aef4:	b281      	uxth	r1, r0
 800aef6:	2286      	movs	r2, #134	; 0x86
 800aef8:	0092      	lsls	r2, r2, #2
 800aefa:	4291      	cmp	r1, r2
 800aefc:	d902      	bls.n	800af04 <tcp_update_rcv_ann_wnd+0x40>
 800aefe:	2286      	movs	r2, #134	; 0x86
 800af00:	0092      	lsls	r2, r2, #2
 800af02:	1c10      	adds	r0, r2, #0
 800af04:	b282      	uxth	r2, r0
 800af06:	189b      	adds	r3, r3, r2
 800af08:	68fa      	ldr	r2, [r7, #12]
 800af0a:	1ad3      	subs	r3, r2, r3
 800af0c:	d408      	bmi.n	800af20 <tcp_update_rcv_ann_wnd+0x5c>
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
 800af0e:	687b      	ldr	r3, [r7, #4]
 800af10:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800af12:	687b      	ldr	r3, [r7, #4]
 800af14:	85da      	strh	r2, [r3, #46]	; 0x2e
    return new_right_edge - pcb->rcv_ann_right_edge;
 800af16:	687b      	ldr	r3, [r7, #4]
 800af18:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800af1a:	68fa      	ldr	r2, [r7, #12]
 800af1c:	1ad3      	subs	r3, r2, r3
 800af1e:	e020      	b.n	800af62 <tcp_update_rcv_ann_wnd+0x9e>
  } else {
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
 800af20:	687b      	ldr	r3, [r7, #4]
 800af22:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800af24:	687b      	ldr	r3, [r7, #4]
 800af26:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800af28:	1ad3      	subs	r3, r2, r3
 800af2a:	2b00      	cmp	r3, #0
 800af2c:	dd03      	ble.n	800af36 <tcp_update_rcv_ann_wnd+0x72>
      /* Can happen due to other end sending out of advertised window,
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
 800af2e:	687b      	ldr	r3, [r7, #4]
 800af30:	2200      	movs	r2, #0
 800af32:	85da      	strh	r2, [r3, #46]	; 0x2e
 800af34:	e014      	b.n	800af60 <tcp_update_rcv_ann_wnd+0x9c>
    } else {
      /* keep the right edge of window constant */
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
 800af36:	687b      	ldr	r3, [r7, #4]
 800af38:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800af3a:	687b      	ldr	r3, [r7, #4]
 800af3c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800af3e:	1ad3      	subs	r3, r2, r3
 800af40:	60bb      	str	r3, [r7, #8]
#if !LWIP_WND_SCALE
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
 800af42:	68ba      	ldr	r2, [r7, #8]
 800af44:	2380      	movs	r3, #128	; 0x80
 800af46:	025b      	lsls	r3, r3, #9
 800af48:	429a      	cmp	r2, r3
 800af4a:	d305      	bcc.n	800af58 <tcp_update_rcv_ann_wnd+0x94>
 800af4c:	4b07      	ldr	r3, [pc, #28]	; (800af6c <tcp_update_rcv_ann_wnd+0xa8>)
 800af4e:	4a0b      	ldr	r2, [pc, #44]	; (800af7c <tcp_update_rcv_ann_wnd+0xb8>)
 800af50:	490b      	ldr	r1, [pc, #44]	; (800af80 <tcp_update_rcv_ann_wnd+0xbc>)
 800af52:	4809      	ldr	r0, [pc, #36]	; (800af78 <tcp_update_rcv_ann_wnd+0xb4>)
 800af54:	f7f7 fcc2 	bl	80028dc <app_debug_rtt_raw>
#endif
      pcb->rcv_ann_wnd = (tcpwnd_size_t)new_rcv_ann_wnd;
 800af58:	68bb      	ldr	r3, [r7, #8]
 800af5a:	b29a      	uxth	r2, r3
 800af5c:	687b      	ldr	r3, [r7, #4]
 800af5e:	85da      	strh	r2, [r3, #46]	; 0x2e
    }
    return 0;
 800af60:	2300      	movs	r3, #0
  }
}
 800af62:	0018      	movs	r0, r3
 800af64:	46bd      	mov	sp, r7
 800af66:	b004      	add	sp, #16
 800af68:	bd80      	pop	{r7, pc}
 800af6a:	46c0      	nop			; (mov r8, r8)
 800af6c:	0801fa7c 	.word	0x0801fa7c
 800af70:	000003a7 	.word	0x000003a7
 800af74:	0801fcd4 	.word	0x0801fcd4
 800af78:	0801fab8 	.word	0x0801fab8
 800af7c:	000003b7 	.word	0x000003b7
 800af80:	0801fcf8 	.word	0x0801fcf8

0800af84 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
 800af84:	b580      	push	{r7, lr}
 800af86:	b084      	sub	sp, #16
 800af88:	af00      	add	r7, sp, #0
 800af8a:	6078      	str	r0, [r7, #4]
 800af8c:	000a      	movs	r2, r1
 800af8e:	1cbb      	adds	r3, r7, #2
 800af90:	801a      	strh	r2, [r3, #0]
  u32_t wnd_inflation;
  tcpwnd_size_t rcv_wnd;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_recved: invalid pcb", pcb != NULL, return);
 800af92:	687b      	ldr	r3, [r7, #4]
 800af94:	2b00      	cmp	r3, #0
 800af96:	d104      	bne.n	800afa2 <tcp_recved+0x1e>
 800af98:	4b23      	ldr	r3, [pc, #140]	; (800b028 <tcp_recved+0xa4>)
 800af9a:	0018      	movs	r0, r3
 800af9c:	f7f7 fc9e 	bl	80028dc <app_debug_rtt_raw>
 800afa0:	e03e      	b.n	800b020 <tcp_recved+0x9c>

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
 800afa2:	687b      	ldr	r3, [r7, #4]
 800afa4:	7e1b      	ldrb	r3, [r3, #24]
 800afa6:	2b01      	cmp	r3, #1
 800afa8:	d105      	bne.n	800afb6 <tcp_recved+0x32>
 800afaa:	4b20      	ldr	r3, [pc, #128]	; (800b02c <tcp_recved+0xa8>)
 800afac:	4a20      	ldr	r2, [pc, #128]	; (800b030 <tcp_recved+0xac>)
 800afae:	4921      	ldr	r1, [pc, #132]	; (800b034 <tcp_recved+0xb0>)
 800afb0:	4821      	ldr	r0, [pc, #132]	; (800b038 <tcp_recved+0xb4>)
 800afb2:	f7f7 fc93 	bl	80028dc <app_debug_rtt_raw>
              pcb->state != LISTEN);

  rcv_wnd = (tcpwnd_size_t)(pcb->rcv_wnd + len);
 800afb6:	687b      	ldr	r3, [r7, #4]
 800afb8:	8d99      	ldrh	r1, [r3, #44]	; 0x2c
 800afba:	200e      	movs	r0, #14
 800afbc:	183b      	adds	r3, r7, r0
 800afbe:	1cba      	adds	r2, r7, #2
 800afc0:	8812      	ldrh	r2, [r2, #0]
 800afc2:	188a      	adds	r2, r1, r2
 800afc4:	801a      	strh	r2, [r3, #0]
  if ((rcv_wnd > TCP_WND_MAX(pcb)) || (rcv_wnd < pcb->rcv_wnd)) {
 800afc6:	0001      	movs	r1, r0
 800afc8:	187b      	adds	r3, r7, r1
 800afca:	881a      	ldrh	r2, [r3, #0]
 800afcc:	2386      	movs	r3, #134	; 0x86
 800afce:	00db      	lsls	r3, r3, #3
 800afd0:	429a      	cmp	r2, r3
 800afd2:	d805      	bhi.n	800afe0 <tcp_recved+0x5c>
 800afd4:	687b      	ldr	r3, [r7, #4]
 800afd6:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 800afd8:	187a      	adds	r2, r7, r1
 800afda:	8812      	ldrh	r2, [r2, #0]
 800afdc:	429a      	cmp	r2, r3
 800afde:	d204      	bcs.n	800afea <tcp_recved+0x66>
    /* window got too big or tcpwnd_size_t overflow */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: window got too big or tcpwnd_size_t overflow\n"));
    pcb->rcv_wnd = TCP_WND_MAX(pcb);
 800afe0:	687b      	ldr	r3, [r7, #4]
 800afe2:	2286      	movs	r2, #134	; 0x86
 800afe4:	00d2      	lsls	r2, r2, #3
 800afe6:	859a      	strh	r2, [r3, #44]	; 0x2c
 800afe8:	e004      	b.n	800aff4 <tcp_recved+0x70>
  } else  {
    pcb->rcv_wnd = rcv_wnd;
 800afea:	687b      	ldr	r3, [r7, #4]
 800afec:	220e      	movs	r2, #14
 800afee:	18ba      	adds	r2, r7, r2
 800aff0:	8812      	ldrh	r2, [r2, #0]
 800aff2:	859a      	strh	r2, [r3, #44]	; 0x2c
  }

  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
 800aff4:	687b      	ldr	r3, [r7, #4]
 800aff6:	0018      	movs	r0, r3
 800aff8:	f7ff ff64 	bl	800aec4 <tcp_update_rcv_ann_wnd>
 800affc:	0003      	movs	r3, r0
 800affe:	60bb      	str	r3, [r7, #8]

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
 800b000:	68ba      	ldr	r2, [r7, #8]
 800b002:	2386      	movs	r3, #134	; 0x86
 800b004:	005b      	lsls	r3, r3, #1
 800b006:	429a      	cmp	r2, r3
 800b008:	d30a      	bcc.n	800b020 <tcp_recved+0x9c>
    tcp_ack_now(pcb);
 800b00a:	687b      	ldr	r3, [r7, #4]
 800b00c:	8bdb      	ldrh	r3, [r3, #30]
 800b00e:	2202      	movs	r2, #2
 800b010:	4313      	orrs	r3, r2
 800b012:	b29a      	uxth	r2, r3
 800b014:	687b      	ldr	r3, [r7, #4]
 800b016:	83da      	strh	r2, [r3, #30]
    tcp_output(pcb);
 800b018:	687b      	ldr	r3, [r7, #4]
 800b01a:	0018      	movs	r0, r3
 800b01c:	f005 fd38 	bl	8010a90 <tcp_output>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: received %"U16_F" bytes, wnd %"TCPWNDSIZE_F" (%"TCPWNDSIZE_F").\n",
                          len, pcb->rcv_wnd, (u16_t)(TCP_WND_MAX(pcb) - pcb->rcv_wnd)));
}
 800b020:	46bd      	mov	sp, r7
 800b022:	b004      	add	sp, #16
 800b024:	bd80      	pop	{r7, pc}
 800b026:	46c0      	nop			; (mov r8, r8)
 800b028:	0801fd14 	.word	0x0801fd14
 800b02c:	0801fa7c 	.word	0x0801fa7c
 800b030:	000003d3 	.word	0x000003d3
 800b034:	0801fd2c 	.word	0x0801fd2c
 800b038:	0801fab8 	.word	0x0801fab8

0800b03c <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
 800b03c:	b580      	push	{r7, lr}
 800b03e:	b082      	sub	sp, #8
 800b040:	af00      	add	r7, sp, #0
  u8_t i;
  u16_t n = 0;
 800b042:	1d3b      	adds	r3, r7, #4
 800b044:	2200      	movs	r2, #0
 800b046:	801a      	strh	r2, [r3, #0]
  struct tcp_pcb *pcb;

again:
  tcp_port++;
 800b048:	4b20      	ldr	r3, [pc, #128]	; (800b0cc <tcp_new_port+0x90>)
 800b04a:	881b      	ldrh	r3, [r3, #0]
 800b04c:	3301      	adds	r3, #1
 800b04e:	b29a      	uxth	r2, r3
 800b050:	4b1e      	ldr	r3, [pc, #120]	; (800b0cc <tcp_new_port+0x90>)
 800b052:	801a      	strh	r2, [r3, #0]
  if (tcp_port == TCP_LOCAL_PORT_RANGE_END) {
 800b054:	4b1d      	ldr	r3, [pc, #116]	; (800b0cc <tcp_new_port+0x90>)
 800b056:	881b      	ldrh	r3, [r3, #0]
 800b058:	4a1d      	ldr	r2, [pc, #116]	; (800b0d0 <tcp_new_port+0x94>)
 800b05a:	4293      	cmp	r3, r2
 800b05c:	d102      	bne.n	800b064 <tcp_new_port+0x28>
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
 800b05e:	4b1b      	ldr	r3, [pc, #108]	; (800b0cc <tcp_new_port+0x90>)
 800b060:	4a1c      	ldr	r2, [pc, #112]	; (800b0d4 <tcp_new_port+0x98>)
 800b062:	801a      	strh	r2, [r3, #0]
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
 800b064:	1dfb      	adds	r3, r7, #7
 800b066:	2200      	movs	r2, #0
 800b068:	701a      	strb	r2, [r3, #0]
 800b06a:	e025      	b.n	800b0b8 <tcp_new_port+0x7c>
    for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 800b06c:	1dfb      	adds	r3, r7, #7
 800b06e:	781a      	ldrb	r2, [r3, #0]
 800b070:	4b19      	ldr	r3, [pc, #100]	; (800b0d8 <tcp_new_port+0x9c>)
 800b072:	0092      	lsls	r2, r2, #2
 800b074:	58d3      	ldr	r3, [r2, r3]
 800b076:	681b      	ldr	r3, [r3, #0]
 800b078:	603b      	str	r3, [r7, #0]
 800b07a:	e015      	b.n	800b0a8 <tcp_new_port+0x6c>
      if (pcb->local_port == tcp_port) {
 800b07c:	683b      	ldr	r3, [r7, #0]
 800b07e:	8b5a      	ldrh	r2, [r3, #26]
 800b080:	4b12      	ldr	r3, [pc, #72]	; (800b0cc <tcp_new_port+0x90>)
 800b082:	881b      	ldrh	r3, [r3, #0]
 800b084:	429a      	cmp	r2, r3
 800b086:	d10c      	bne.n	800b0a2 <tcp_new_port+0x66>
        n++;
 800b088:	1d3b      	adds	r3, r7, #4
 800b08a:	881a      	ldrh	r2, [r3, #0]
 800b08c:	1d3b      	adds	r3, r7, #4
 800b08e:	3201      	adds	r2, #1
 800b090:	801a      	strh	r2, [r3, #0]
        if (n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
 800b092:	1d3b      	adds	r3, r7, #4
 800b094:	881a      	ldrh	r2, [r3, #0]
 800b096:	2380      	movs	r3, #128	; 0x80
 800b098:	01db      	lsls	r3, r3, #7
 800b09a:	429a      	cmp	r2, r3
 800b09c:	d3d4      	bcc.n	800b048 <tcp_new_port+0xc>
          return 0;
 800b09e:	2300      	movs	r3, #0
 800b0a0:	e010      	b.n	800b0c4 <tcp_new_port+0x88>
    for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 800b0a2:	683b      	ldr	r3, [r7, #0]
 800b0a4:	691b      	ldr	r3, [r3, #16]
 800b0a6:	603b      	str	r3, [r7, #0]
 800b0a8:	683b      	ldr	r3, [r7, #0]
 800b0aa:	2b00      	cmp	r3, #0
 800b0ac:	d1e6      	bne.n	800b07c <tcp_new_port+0x40>
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
 800b0ae:	1dfb      	adds	r3, r7, #7
 800b0b0:	781a      	ldrb	r2, [r3, #0]
 800b0b2:	1dfb      	adds	r3, r7, #7
 800b0b4:	3201      	adds	r2, #1
 800b0b6:	701a      	strb	r2, [r3, #0]
 800b0b8:	1dfb      	adds	r3, r7, #7
 800b0ba:	781b      	ldrb	r3, [r3, #0]
 800b0bc:	2b03      	cmp	r3, #3
 800b0be:	d9d5      	bls.n	800b06c <tcp_new_port+0x30>
        }
        goto again;
      }
    }
  }
  return tcp_port;
 800b0c0:	4b02      	ldr	r3, [pc, #8]	; (800b0cc <tcp_new_port+0x90>)
 800b0c2:	881b      	ldrh	r3, [r3, #0]
}
 800b0c4:	0018      	movs	r0, r3
 800b0c6:	46bd      	mov	sp, r7
 800b0c8:	b002      	add	sp, #8
 800b0ca:	bd80      	pop	{r7, pc}
 800b0cc:	2000001a 	.word	0x2000001a
 800b0d0:	0000ffff 	.word	0x0000ffff
 800b0d4:	ffffc000 	.word	0xffffc000
 800b0d8:	08022434 	.word	0x08022434

0800b0dc <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port,
            tcp_connected_fn connected)
{
 800b0dc:	b5b0      	push	{r4, r5, r7, lr}
 800b0de:	b08c      	sub	sp, #48	; 0x30
 800b0e0:	af00      	add	r7, sp, #0
 800b0e2:	60f8      	str	r0, [r7, #12]
 800b0e4:	60b9      	str	r1, [r7, #8]
 800b0e6:	603b      	str	r3, [r7, #0]
 800b0e8:	1dbb      	adds	r3, r7, #6
 800b0ea:	801a      	strh	r2, [r3, #0]
  struct netif *netif = NULL;
 800b0ec:	2300      	movs	r3, #0
 800b0ee:	62fb      	str	r3, [r7, #44]	; 0x2c
  u32_t iss;
  u16_t old_local_port;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_connect: invalid pcb", pcb != NULL, return ERR_ARG);
 800b0f0:	68fb      	ldr	r3, [r7, #12]
 800b0f2:	2b00      	cmp	r3, #0
 800b0f4:	d106      	bne.n	800b104 <tcp_connect+0x28>
 800b0f6:	4b9c      	ldr	r3, [pc, #624]	; (800b368 <tcp_connect+0x28c>)
 800b0f8:	0018      	movs	r0, r3
 800b0fa:	f7f7 fbef 	bl	80028dc <app_debug_rtt_raw>
 800b0fe:	2310      	movs	r3, #16
 800b100:	425b      	negs	r3, r3
 800b102:	e12d      	b.n	800b360 <tcp_connect+0x284>
  LWIP_ERROR("tcp_connect: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
 800b104:	68bb      	ldr	r3, [r7, #8]
 800b106:	2b00      	cmp	r3, #0
 800b108:	d106      	bne.n	800b118 <tcp_connect+0x3c>
 800b10a:	4b98      	ldr	r3, [pc, #608]	; (800b36c <tcp_connect+0x290>)
 800b10c:	0018      	movs	r0, r3
 800b10e:	f7f7 fbe5 	bl	80028dc <app_debug_rtt_raw>
 800b112:	2310      	movs	r3, #16
 800b114:	425b      	negs	r3, r3
 800b116:	e123      	b.n	800b360 <tcp_connect+0x284>

  LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
 800b118:	68fb      	ldr	r3, [r7, #12]
 800b11a:	7e1b      	ldrb	r3, [r3, #24]
 800b11c:	2b00      	cmp	r3, #0
 800b11e:	d006      	beq.n	800b12e <tcp_connect+0x52>
 800b120:	4b93      	ldr	r3, [pc, #588]	; (800b370 <tcp_connect+0x294>)
 800b122:	0018      	movs	r0, r3
 800b124:	f7f7 fbda 	bl	80028dc <app_debug_rtt_raw>
 800b128:	230a      	movs	r3, #10
 800b12a:	425b      	negs	r3, r3
 800b12c:	e118      	b.n	800b360 <tcp_connect+0x284>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  ip_addr_set(&pcb->remote_ip, ipaddr);
 800b12e:	68bb      	ldr	r3, [r7, #8]
 800b130:	2b00      	cmp	r3, #0
 800b132:	d002      	beq.n	800b13a <tcp_connect+0x5e>
 800b134:	68bb      	ldr	r3, [r7, #8]
 800b136:	681a      	ldr	r2, [r3, #0]
 800b138:	e000      	b.n	800b13c <tcp_connect+0x60>
 800b13a:	2200      	movs	r2, #0
 800b13c:	68fb      	ldr	r3, [r7, #12]
 800b13e:	605a      	str	r2, [r3, #4]
  pcb->remote_port = port;
 800b140:	68fb      	ldr	r3, [r7, #12]
 800b142:	1dba      	adds	r2, r7, #6
 800b144:	8812      	ldrh	r2, [r2, #0]
 800b146:	839a      	strh	r2, [r3, #28]

  if (pcb->netif_idx != NETIF_NO_INDEX) {
 800b148:	68fb      	ldr	r3, [r7, #12]
 800b14a:	7a1b      	ldrb	r3, [r3, #8]
 800b14c:	2b00      	cmp	r3, #0
 800b14e:	d007      	beq.n	800b160 <tcp_connect+0x84>
    netif = netif_get_by_index(pcb->netif_idx);
 800b150:	68fb      	ldr	r3, [r7, #12]
 800b152:	7a1b      	ldrb	r3, [r3, #8]
 800b154:	0018      	movs	r0, r3
 800b156:	f7fe f945 	bl	80093e4 <netif_get_by_index>
 800b15a:	0003      	movs	r3, r0
 800b15c:	62fb      	str	r3, [r7, #44]	; 0x2c
 800b15e:	e006      	b.n	800b16e <tcp_connect+0x92>
  } else {
    /* check if we have a route to the remote host */
    netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
 800b160:	68fb      	ldr	r3, [r7, #12]
 800b162:	3304      	adds	r3, #4
 800b164:	0018      	movs	r0, r3
 800b166:	f008 f8bb 	bl	80132e0 <ip4_route>
 800b16a:	0003      	movs	r3, r0
 800b16c:	62fb      	str	r3, [r7, #44]	; 0x2c
  }
  if (netif == NULL) {
 800b16e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b170:	2b00      	cmp	r3, #0
 800b172:	d102      	bne.n	800b17a <tcp_connect+0x9e>
    /* Don't even try to send a SYN packet if we have no route since that will fail. */
    return ERR_RTE;
 800b174:	2304      	movs	r3, #4
 800b176:	425b      	negs	r3, r3
 800b178:	e0f2      	b.n	800b360 <tcp_connect+0x284>
  }

  /* check if local IP has been assigned to pcb, if not, get one */
  if (ip_addr_isany(&pcb->local_ip)) {
 800b17a:	68fb      	ldr	r3, [r7, #12]
 800b17c:	2b00      	cmp	r3, #0
 800b17e:	d003      	beq.n	800b188 <tcp_connect+0xac>
 800b180:	68fb      	ldr	r3, [r7, #12]
 800b182:	681b      	ldr	r3, [r3, #0]
 800b184:	2b00      	cmp	r3, #0
 800b186:	d111      	bne.n	800b1ac <tcp_connect+0xd0>
    const ip_addr_t *local_ip = ip_netif_get_local_ip(netif, ipaddr);
 800b188:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b18a:	2b00      	cmp	r3, #0
 800b18c:	d002      	beq.n	800b194 <tcp_connect+0xb8>
 800b18e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b190:	3304      	adds	r3, #4
 800b192:	e000      	b.n	800b196 <tcp_connect+0xba>
 800b194:	2300      	movs	r3, #0
 800b196:	61fb      	str	r3, [r7, #28]
    if (local_ip == NULL) {
 800b198:	69fb      	ldr	r3, [r7, #28]
 800b19a:	2b00      	cmp	r3, #0
 800b19c:	d102      	bne.n	800b1a4 <tcp_connect+0xc8>
      return ERR_RTE;
 800b19e:	2304      	movs	r3, #4
 800b1a0:	425b      	negs	r3, r3
 800b1a2:	e0dd      	b.n	800b360 <tcp_connect+0x284>
    }
    ip_addr_copy(pcb->local_ip, *local_ip);
 800b1a4:	69fb      	ldr	r3, [r7, #28]
 800b1a6:	681a      	ldr	r2, [r3, #0]
 800b1a8:	68fb      	ldr	r3, [r7, #12]
 800b1aa:	601a      	str	r2, [r3, #0]
      ip6_addr_lacks_zone(ip_2_ip6(&pcb->remote_ip), IP6_UNICAST)) {
    ip6_addr_assign_zone(ip_2_ip6(&pcb->remote_ip), IP6_UNICAST, netif);
  }
#endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */

  old_local_port = pcb->local_port;
 800b1ac:	231a      	movs	r3, #26
 800b1ae:	18fb      	adds	r3, r7, r3
 800b1b0:	68fa      	ldr	r2, [r7, #12]
 800b1b2:	8b52      	ldrh	r2, [r2, #26]
 800b1b4:	801a      	strh	r2, [r3, #0]
  if (pcb->local_port == 0) {
 800b1b6:	68fb      	ldr	r3, [r7, #12]
 800b1b8:	8b5b      	ldrh	r3, [r3, #26]
 800b1ba:	2b00      	cmp	r3, #0
 800b1bc:	d10c      	bne.n	800b1d8 <tcp_connect+0xfc>
    pcb->local_port = tcp_new_port();
 800b1be:	f7ff ff3d 	bl	800b03c <tcp_new_port>
 800b1c2:	0003      	movs	r3, r0
 800b1c4:	001a      	movs	r2, r3
 800b1c6:	68fb      	ldr	r3, [r7, #12]
 800b1c8:	835a      	strh	r2, [r3, #26]
    if (pcb->local_port == 0) {
 800b1ca:	68fb      	ldr	r3, [r7, #12]
 800b1cc:	8b5b      	ldrh	r3, [r3, #26]
 800b1ce:	2b00      	cmp	r3, #0
 800b1d0:	d139      	bne.n	800b246 <tcp_connect+0x16a>
      return ERR_BUF;
 800b1d2:	2302      	movs	r3, #2
 800b1d4:	425b      	negs	r3, r3
 800b1d6:	e0c3      	b.n	800b360 <tcp_connect+0x284>
    }
  } else {
#if SO_REUSE
    if (ip_get_option(pcb, SOF_REUSEADDR)) {
 800b1d8:	68fb      	ldr	r3, [r7, #12]
 800b1da:	7a5b      	ldrb	r3, [r3, #9]
 800b1dc:	001a      	movs	r2, r3
 800b1de:	2304      	movs	r3, #4
 800b1e0:	4013      	ands	r3, r2
 800b1e2:	d030      	beq.n	800b246 <tcp_connect+0x16a>
      /* Since SOF_REUSEADDR allows reusing a local address, we have to make sure
         now that the 5-tuple is unique. */
      struct tcp_pcb *cpcb;
      int i;
      /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
      for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
 800b1e4:	2302      	movs	r3, #2
 800b1e6:	627b      	str	r3, [r7, #36]	; 0x24
 800b1e8:	e02a      	b.n	800b240 <tcp_connect+0x164>
        for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 800b1ea:	4b62      	ldr	r3, [pc, #392]	; (800b374 <tcp_connect+0x298>)
 800b1ec:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b1ee:	0092      	lsls	r2, r2, #2
 800b1f0:	58d3      	ldr	r3, [r2, r3]
 800b1f2:	681b      	ldr	r3, [r3, #0]
 800b1f4:	62bb      	str	r3, [r7, #40]	; 0x28
 800b1f6:	e01d      	b.n	800b234 <tcp_connect+0x158>
          if ((cpcb->local_port == pcb->local_port) &&
 800b1f8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b1fa:	8b5a      	ldrh	r2, [r3, #26]
 800b1fc:	68fb      	ldr	r3, [r7, #12]
 800b1fe:	8b5b      	ldrh	r3, [r3, #26]
 800b200:	429a      	cmp	r2, r3
 800b202:	d114      	bne.n	800b22e <tcp_connect+0x152>
              (cpcb->remote_port == port) &&
 800b204:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b206:	8b9b      	ldrh	r3, [r3, #28]
          if ((cpcb->local_port == pcb->local_port) &&
 800b208:	1dba      	adds	r2, r7, #6
 800b20a:	8812      	ldrh	r2, [r2, #0]
 800b20c:	429a      	cmp	r2, r3
 800b20e:	d10e      	bne.n	800b22e <tcp_connect+0x152>
              ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
 800b210:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b212:	681a      	ldr	r2, [r3, #0]
 800b214:	68fb      	ldr	r3, [r7, #12]
 800b216:	681b      	ldr	r3, [r3, #0]
              (cpcb->remote_port == port) &&
 800b218:	429a      	cmp	r2, r3
 800b21a:	d108      	bne.n	800b22e <tcp_connect+0x152>
              ip_addr_cmp(&cpcb->remote_ip, ipaddr)) {
 800b21c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b21e:	685a      	ldr	r2, [r3, #4]
 800b220:	68bb      	ldr	r3, [r7, #8]
 800b222:	681b      	ldr	r3, [r3, #0]
              ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
 800b224:	429a      	cmp	r2, r3
 800b226:	d102      	bne.n	800b22e <tcp_connect+0x152>
            /* linux returns EISCONN here, but ERR_USE should be OK for us */
            return ERR_USE;
 800b228:	2308      	movs	r3, #8
 800b22a:	425b      	negs	r3, r3
 800b22c:	e098      	b.n	800b360 <tcp_connect+0x284>
        for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 800b22e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b230:	691b      	ldr	r3, [r3, #16]
 800b232:	62bb      	str	r3, [r7, #40]	; 0x28
 800b234:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b236:	2b00      	cmp	r3, #0
 800b238:	d1de      	bne.n	800b1f8 <tcp_connect+0x11c>
      for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
 800b23a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b23c:	3301      	adds	r3, #1
 800b23e:	627b      	str	r3, [r7, #36]	; 0x24
 800b240:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b242:	2b03      	cmp	r3, #3
 800b244:	ddd1      	ble.n	800b1ea <tcp_connect+0x10e>
      }
    }
#endif /* SO_REUSE */
  }

  iss = tcp_next_iss(pcb);
 800b246:	68fb      	ldr	r3, [r7, #12]
 800b248:	0018      	movs	r0, r3
 800b24a:	f001 f8d9 	bl	800c400 <tcp_next_iss>
 800b24e:	0003      	movs	r3, r0
 800b250:	617b      	str	r3, [r7, #20]
  pcb->rcv_nxt = 0;
 800b252:	68fb      	ldr	r3, [r7, #12]
 800b254:	2200      	movs	r2, #0
 800b256:	629a      	str	r2, [r3, #40]	; 0x28
  pcb->snd_nxt = iss;
 800b258:	68fb      	ldr	r3, [r7, #12]
 800b25a:	697a      	ldr	r2, [r7, #20]
 800b25c:	655a      	str	r2, [r3, #84]	; 0x54
  pcb->lastack = iss - 1;
 800b25e:	697b      	ldr	r3, [r7, #20]
 800b260:	1e5a      	subs	r2, r3, #1
 800b262:	68fb      	ldr	r3, [r7, #12]
 800b264:	649a      	str	r2, [r3, #72]	; 0x48
  pcb->snd_wl2 = iss - 1;
 800b266:	697b      	ldr	r3, [r7, #20]
 800b268:	1e5a      	subs	r2, r3, #1
 800b26a:	68fb      	ldr	r3, [r7, #12]
 800b26c:	65da      	str	r2, [r3, #92]	; 0x5c
  pcb->snd_lbb = iss - 1;
 800b26e:	697b      	ldr	r3, [r7, #20]
 800b270:	1e5a      	subs	r2, r3, #1
 800b272:	68fb      	ldr	r3, [r7, #12]
 800b274:	661a      	str	r2, [r3, #96]	; 0x60
  /* Start with a window that does not need scaling. When window scaling is
     enabled and used, the window is enlarged when both sides agree on scaling. */
  pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
 800b276:	68fb      	ldr	r3, [r7, #12]
 800b278:	2286      	movs	r2, #134	; 0x86
 800b27a:	00d2      	lsls	r2, r2, #3
 800b27c:	85da      	strh	r2, [r3, #46]	; 0x2e
 800b27e:	68fb      	ldr	r3, [r7, #12]
 800b280:	8dda      	ldrh	r2, [r3, #46]	; 0x2e
 800b282:	68fb      	ldr	r3, [r7, #12]
 800b284:	859a      	strh	r2, [r3, #44]	; 0x2c
  pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 800b286:	68fb      	ldr	r3, [r7, #12]
 800b288:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800b28a:	68fb      	ldr	r3, [r7, #12]
 800b28c:	631a      	str	r2, [r3, #48]	; 0x30
  pcb->snd_wnd = TCP_WND;
 800b28e:	68fb      	ldr	r3, [r7, #12]
 800b290:	2264      	movs	r2, #100	; 0x64
 800b292:	2186      	movs	r1, #134	; 0x86
 800b294:	00c9      	lsls	r1, r1, #3
 800b296:	5299      	strh	r1, [r3, r2]
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = INITIAL_MSS;
 800b298:	68fb      	ldr	r3, [r7, #12]
 800b29a:	2286      	movs	r2, #134	; 0x86
 800b29c:	0092      	lsls	r2, r2, #2
 800b29e:	86da      	strh	r2, [r3, #54]	; 0x36
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss_netif(pcb->mss, netif, &pcb->remote_ip);
 800b2a0:	68fb      	ldr	r3, [r7, #12]
 800b2a2:	8ed8      	ldrh	r0, [r3, #54]	; 0x36
 800b2a4:	68fb      	ldr	r3, [r7, #12]
 800b2a6:	1d1a      	adds	r2, r3, #4
 800b2a8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b2aa:	0019      	movs	r1, r3
 800b2ac:	f001 f8ce 	bl	800c44c <tcp_eff_send_mss_netif>
 800b2b0:	0003      	movs	r3, r0
 800b2b2:	001a      	movs	r2, r3
 800b2b4:	68fb      	ldr	r3, [r7, #12]
 800b2b6:	86da      	strh	r2, [r3, #54]	; 0x36
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
 800b2b8:	68fb      	ldr	r3, [r7, #12]
 800b2ba:	224c      	movs	r2, #76	; 0x4c
 800b2bc:	2101      	movs	r1, #1
 800b2be:	5299      	strh	r1, [r3, r2]
#if LWIP_CALLBACK_API
  pcb->connected = connected;
 800b2c0:	68fb      	ldr	r3, [r7, #12]
 800b2c2:	218c      	movs	r1, #140	; 0x8c
 800b2c4:	683a      	ldr	r2, [r7, #0]
 800b2c6:	505a      	str	r2, [r3, r1]
#else /* LWIP_CALLBACK_API */
  LWIP_UNUSED_ARG(connected);
#endif /* LWIP_CALLBACK_API */

  /* Send a SYN together with the MSS option. */
  ret = tcp_enqueue_flags(pcb, TCP_SYN);
 800b2c8:	2513      	movs	r5, #19
 800b2ca:	197c      	adds	r4, r7, r5
 800b2cc:	68fb      	ldr	r3, [r7, #12]
 800b2ce:	2102      	movs	r1, #2
 800b2d0:	0018      	movs	r0, r3
 800b2d2:	f005 fad7 	bl	8010884 <tcp_enqueue_flags>
 800b2d6:	0003      	movs	r3, r0
 800b2d8:	7023      	strb	r3, [r4, #0]
  if (ret == ERR_OK) {
 800b2da:	197b      	adds	r3, r7, r5
 800b2dc:	781b      	ldrb	r3, [r3, #0]
 800b2de:	b25b      	sxtb	r3, r3
 800b2e0:	2b00      	cmp	r3, #0
 800b2e2:	d139      	bne.n	800b358 <tcp_connect+0x27c>
    /* SYN segment was enqueued, changed the pcbs state now */
    pcb->state = SYN_SENT;
 800b2e4:	68fb      	ldr	r3, [r7, #12]
 800b2e6:	2202      	movs	r2, #2
 800b2e8:	761a      	strb	r2, [r3, #24]
    if (old_local_port != 0) {
 800b2ea:	231a      	movs	r3, #26
 800b2ec:	18fb      	adds	r3, r7, r3
 800b2ee:	881b      	ldrh	r3, [r3, #0]
 800b2f0:	2b00      	cmp	r3, #0
 800b2f2:	d021      	beq.n	800b338 <tcp_connect+0x25c>
      TCP_RMV(&tcp_bound_pcbs, pcb);
 800b2f4:	4b20      	ldr	r3, [pc, #128]	; (800b378 <tcp_connect+0x29c>)
 800b2f6:	681b      	ldr	r3, [r3, #0]
 800b2f8:	68fa      	ldr	r2, [r7, #12]
 800b2fa:	429a      	cmp	r2, r3
 800b2fc:	d105      	bne.n	800b30a <tcp_connect+0x22e>
 800b2fe:	4b1e      	ldr	r3, [pc, #120]	; (800b378 <tcp_connect+0x29c>)
 800b300:	681b      	ldr	r3, [r3, #0]
 800b302:	691a      	ldr	r2, [r3, #16]
 800b304:	4b1c      	ldr	r3, [pc, #112]	; (800b378 <tcp_connect+0x29c>)
 800b306:	601a      	str	r2, [r3, #0]
 800b308:	e013      	b.n	800b332 <tcp_connect+0x256>
 800b30a:	4b1b      	ldr	r3, [pc, #108]	; (800b378 <tcp_connect+0x29c>)
 800b30c:	681b      	ldr	r3, [r3, #0]
 800b30e:	623b      	str	r3, [r7, #32]
 800b310:	e00c      	b.n	800b32c <tcp_connect+0x250>
 800b312:	6a3b      	ldr	r3, [r7, #32]
 800b314:	691b      	ldr	r3, [r3, #16]
 800b316:	68fa      	ldr	r2, [r7, #12]
 800b318:	429a      	cmp	r2, r3
 800b31a:	d104      	bne.n	800b326 <tcp_connect+0x24a>
 800b31c:	68fb      	ldr	r3, [r7, #12]
 800b31e:	691a      	ldr	r2, [r3, #16]
 800b320:	6a3b      	ldr	r3, [r7, #32]
 800b322:	611a      	str	r2, [r3, #16]
 800b324:	e005      	b.n	800b332 <tcp_connect+0x256>
 800b326:	6a3b      	ldr	r3, [r7, #32]
 800b328:	691b      	ldr	r3, [r3, #16]
 800b32a:	623b      	str	r3, [r7, #32]
 800b32c:	6a3b      	ldr	r3, [r7, #32]
 800b32e:	2b00      	cmp	r3, #0
 800b330:	d1ef      	bne.n	800b312 <tcp_connect+0x236>
 800b332:	68fb      	ldr	r3, [r7, #12]
 800b334:	2200      	movs	r2, #0
 800b336:	611a      	str	r2, [r3, #16]
    }
    TCP_REG_ACTIVE(pcb);
 800b338:	4b10      	ldr	r3, [pc, #64]	; (800b37c <tcp_connect+0x2a0>)
 800b33a:	681a      	ldr	r2, [r3, #0]
 800b33c:	68fb      	ldr	r3, [r7, #12]
 800b33e:	611a      	str	r2, [r3, #16]
 800b340:	4b0e      	ldr	r3, [pc, #56]	; (800b37c <tcp_connect+0x2a0>)
 800b342:	68fa      	ldr	r2, [r7, #12]
 800b344:	601a      	str	r2, [r3, #0]
 800b346:	f006 fe21 	bl	8011f8c <tcp_timer_needed>
 800b34a:	4b0d      	ldr	r3, [pc, #52]	; (800b380 <tcp_connect+0x2a4>)
 800b34c:	2201      	movs	r2, #1
 800b34e:	701a      	strb	r2, [r3, #0]
    MIB2_STATS_INC(mib2.tcpactiveopens);

    tcp_output(pcb);
 800b350:	68fb      	ldr	r3, [r7, #12]
 800b352:	0018      	movs	r0, r3
 800b354:	f005 fb9c 	bl	8010a90 <tcp_output>
  }
  return ret;
 800b358:	2313      	movs	r3, #19
 800b35a:	18fb      	adds	r3, r7, r3
 800b35c:	781b      	ldrb	r3, [r3, #0]
 800b35e:	b25b      	sxtb	r3, r3
}
 800b360:	0018      	movs	r0, r3
 800b362:	46bd      	mov	sp, r7
 800b364:	b00c      	add	sp, #48	; 0x30
 800b366:	bdb0      	pop	{r4, r5, r7, pc}
 800b368:	0801fd54 	.word	0x0801fd54
 800b36c:	0801fd70 	.word	0x0801fd70
 800b370:	0801fd8c 	.word	0x0801fd8c
 800b374:	08022434 	.word	0x08022434
 800b378:	20002ee0 	.word	0x20002ee0
 800b37c:	20002ed4 	.word	0x20002ed4
 800b380:	20002ed0 	.word	0x20002ed0

0800b384 <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
 800b384:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b386:	b091      	sub	sp, #68	; 0x44
 800b388:	af04      	add	r7, sp, #16
  tcpwnd_size_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;
 800b38a:	2325      	movs	r3, #37	; 0x25
 800b38c:	18fb      	adds	r3, r7, r3
 800b38e:	2200      	movs	r2, #0
 800b390:	701a      	strb	r2, [r3, #0]

  ++tcp_ticks;
 800b392:	4b9c      	ldr	r3, [pc, #624]	; (800b604 <tcp_slowtmr+0x280>)
 800b394:	681b      	ldr	r3, [r3, #0]
 800b396:	1c5a      	adds	r2, r3, #1
 800b398:	4b9a      	ldr	r3, [pc, #616]	; (800b604 <tcp_slowtmr+0x280>)
 800b39a:	601a      	str	r2, [r3, #0]
  ++tcp_timer_ctr;
 800b39c:	4b9a      	ldr	r3, [pc, #616]	; (800b608 <tcp_slowtmr+0x284>)
 800b39e:	781b      	ldrb	r3, [r3, #0]
 800b3a0:	3301      	adds	r3, #1
 800b3a2:	b2da      	uxtb	r2, r3
 800b3a4:	4b98      	ldr	r3, [pc, #608]	; (800b608 <tcp_slowtmr+0x284>)
 800b3a6:	701a      	strb	r2, [r3, #0]

tcp_slowtmr_start:
  /* Steps through all of the active PCBs. */
  prev = NULL;
 800b3a8:	2300      	movs	r3, #0
 800b3aa:	62bb      	str	r3, [r7, #40]	; 0x28
  pcb = tcp_active_pcbs;
 800b3ac:	4b97      	ldr	r3, [pc, #604]	; (800b60c <tcp_slowtmr+0x288>)
 800b3ae:	681b      	ldr	r3, [r3, #0]
 800b3b0:	62fb      	str	r3, [r7, #44]	; 0x2c
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
 800b3b2:	e2e2      	b.n	800b97a <tcp_slowtmr+0x5f6>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
 800b3b4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b3b6:	7e1b      	ldrb	r3, [r3, #24]
 800b3b8:	2b00      	cmp	r3, #0
 800b3ba:	d105      	bne.n	800b3c8 <tcp_slowtmr+0x44>
 800b3bc:	4b94      	ldr	r3, [pc, #592]	; (800b610 <tcp_slowtmr+0x28c>)
 800b3be:	4a95      	ldr	r2, [pc, #596]	; (800b614 <tcp_slowtmr+0x290>)
 800b3c0:	4995      	ldr	r1, [pc, #596]	; (800b618 <tcp_slowtmr+0x294>)
 800b3c2:	4896      	ldr	r0, [pc, #600]	; (800b61c <tcp_slowtmr+0x298>)
 800b3c4:	f7f7 fa8a 	bl	80028dc <app_debug_rtt_raw>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
 800b3c8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b3ca:	7e1b      	ldrb	r3, [r3, #24]
 800b3cc:	2b01      	cmp	r3, #1
 800b3ce:	d106      	bne.n	800b3de <tcp_slowtmr+0x5a>
 800b3d0:	4b8f      	ldr	r3, [pc, #572]	; (800b610 <tcp_slowtmr+0x28c>)
 800b3d2:	2298      	movs	r2, #152	; 0x98
 800b3d4:	00d2      	lsls	r2, r2, #3
 800b3d6:	4992      	ldr	r1, [pc, #584]	; (800b620 <tcp_slowtmr+0x29c>)
 800b3d8:	4890      	ldr	r0, [pc, #576]	; (800b61c <tcp_slowtmr+0x298>)
 800b3da:	f7f7 fa7f 	bl	80028dc <app_debug_rtt_raw>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
 800b3de:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b3e0:	7e1b      	ldrb	r3, [r3, #24]
 800b3e2:	2b0a      	cmp	r3, #10
 800b3e4:	d105      	bne.n	800b3f2 <tcp_slowtmr+0x6e>
 800b3e6:	4b8a      	ldr	r3, [pc, #552]	; (800b610 <tcp_slowtmr+0x28c>)
 800b3e8:	4a8e      	ldr	r2, [pc, #568]	; (800b624 <tcp_slowtmr+0x2a0>)
 800b3ea:	498f      	ldr	r1, [pc, #572]	; (800b628 <tcp_slowtmr+0x2a4>)
 800b3ec:	488b      	ldr	r0, [pc, #556]	; (800b61c <tcp_slowtmr+0x298>)
 800b3ee:	f7f7 fa75 	bl	80028dc <app_debug_rtt_raw>
    if (pcb->last_timer == tcp_timer_ctr) {
 800b3f2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b3f4:	2222      	movs	r2, #34	; 0x22
 800b3f6:	5c9a      	ldrb	r2, [r3, r2]
 800b3f8:	4b83      	ldr	r3, [pc, #524]	; (800b608 <tcp_slowtmr+0x284>)
 800b3fa:	781b      	ldrb	r3, [r3, #0]
 800b3fc:	429a      	cmp	r2, r3
 800b3fe:	d105      	bne.n	800b40c <tcp_slowtmr+0x88>
      /* skip this pcb, we have already processed it */
      prev = pcb;
 800b400:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b402:	62bb      	str	r3, [r7, #40]	; 0x28
      pcb = pcb->next;
 800b404:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b406:	691b      	ldr	r3, [r3, #16]
 800b408:	62fb      	str	r3, [r7, #44]	; 0x2c
      continue;
 800b40a:	e2b6      	b.n	800b97a <tcp_slowtmr+0x5f6>
    }
    pcb->last_timer = tcp_timer_ctr;
 800b40c:	4b7e      	ldr	r3, [pc, #504]	; (800b608 <tcp_slowtmr+0x284>)
 800b40e:	7819      	ldrb	r1, [r3, #0]
 800b410:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b412:	2222      	movs	r2, #34	; 0x22
 800b414:	5499      	strb	r1, [r3, r2]

    pcb_remove = 0;
 800b416:	2127      	movs	r1, #39	; 0x27
 800b418:	187b      	adds	r3, r7, r1
 800b41a:	2200      	movs	r2, #0
 800b41c:	701a      	strb	r2, [r3, #0]
    pcb_reset = 0;
 800b41e:	2326      	movs	r3, #38	; 0x26
 800b420:	18fb      	adds	r3, r7, r3
 800b422:	2200      	movs	r2, #0
 800b424:	701a      	strb	r2, [r3, #0]

    if (pcb->state == SYN_SENT && pcb->nrtx >= TCP_SYNMAXRTX) {
 800b426:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b428:	7e1b      	ldrb	r3, [r3, #24]
 800b42a:	2b02      	cmp	r3, #2
 800b42c:	d10a      	bne.n	800b444 <tcp_slowtmr+0xc0>
 800b42e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b430:	2246      	movs	r2, #70	; 0x46
 800b432:	5c9b      	ldrb	r3, [r3, r2]
 800b434:	2b05      	cmp	r3, #5
 800b436:	d905      	bls.n	800b444 <tcp_slowtmr+0xc0>
      ++pcb_remove;
 800b438:	187b      	adds	r3, r7, r1
 800b43a:	187a      	adds	r2, r7, r1
 800b43c:	7812      	ldrb	r2, [r2, #0]
 800b43e:	3201      	adds	r2, #1
 800b440:	701a      	strb	r2, [r3, #0]
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
 800b442:	e13f      	b.n	800b6c4 <tcp_slowtmr+0x340>
    } else if (pcb->nrtx >= TCP_MAXRTX) {
 800b444:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b446:	2246      	movs	r2, #70	; 0x46
 800b448:	5c9b      	ldrb	r3, [r3, r2]
 800b44a:	2b0b      	cmp	r3, #11
 800b44c:	d906      	bls.n	800b45c <tcp_slowtmr+0xd8>
      ++pcb_remove;
 800b44e:	2227      	movs	r2, #39	; 0x27
 800b450:	18bb      	adds	r3, r7, r2
 800b452:	18ba      	adds	r2, r7, r2
 800b454:	7812      	ldrb	r2, [r2, #0]
 800b456:	3201      	adds	r2, #1
 800b458:	701a      	strb	r2, [r3, #0]
 800b45a:	e133      	b.n	800b6c4 <tcp_slowtmr+0x340>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
 800b45c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b45e:	22a5      	movs	r2, #165	; 0xa5
 800b460:	5c9b      	ldrb	r3, [r3, r2]
 800b462:	2b00      	cmp	r3, #0
 800b464:	d100      	bne.n	800b468 <tcp_slowtmr+0xe4>
 800b466:	e079      	b.n	800b55c <tcp_slowtmr+0x1d8>
        LWIP_ASSERT("tcp_slowtimr: persist ticking with in-flight data", pcb->unacked == NULL);
 800b468:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b46a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800b46c:	2b00      	cmp	r3, #0
 800b46e:	d005      	beq.n	800b47c <tcp_slowtmr+0xf8>
 800b470:	4b67      	ldr	r3, [pc, #412]	; (800b610 <tcp_slowtmr+0x28c>)
 800b472:	4a6e      	ldr	r2, [pc, #440]	; (800b62c <tcp_slowtmr+0x2a8>)
 800b474:	496e      	ldr	r1, [pc, #440]	; (800b630 <tcp_slowtmr+0x2ac>)
 800b476:	4869      	ldr	r0, [pc, #420]	; (800b61c <tcp_slowtmr+0x298>)
 800b478:	f7f7 fa30 	bl	80028dc <app_debug_rtt_raw>
        LWIP_ASSERT("tcp_slowtimr: persist ticking with empty send buffer", pcb->unsent != NULL);
 800b47c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b47e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800b480:	2b00      	cmp	r3, #0
 800b482:	d105      	bne.n	800b490 <tcp_slowtmr+0x10c>
 800b484:	4b62      	ldr	r3, [pc, #392]	; (800b610 <tcp_slowtmr+0x28c>)
 800b486:	4a6b      	ldr	r2, [pc, #428]	; (800b634 <tcp_slowtmr+0x2b0>)
 800b488:	496b      	ldr	r1, [pc, #428]	; (800b638 <tcp_slowtmr+0x2b4>)
 800b48a:	4864      	ldr	r0, [pc, #400]	; (800b61c <tcp_slowtmr+0x298>)
 800b48c:	f7f7 fa26 	bl	80028dc <app_debug_rtt_raw>
        if (pcb->persist_probe >= TCP_MAXRTX) {
 800b490:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b492:	22a6      	movs	r2, #166	; 0xa6
 800b494:	5c9b      	ldrb	r3, [r3, r2]
 800b496:	2b0b      	cmp	r3, #11
 800b498:	d906      	bls.n	800b4a8 <tcp_slowtmr+0x124>
          ++pcb_remove; /* max probes reached */
 800b49a:	2227      	movs	r2, #39	; 0x27
 800b49c:	18bb      	adds	r3, r7, r2
 800b49e:	18ba      	adds	r2, r7, r2
 800b4a0:	7812      	ldrb	r2, [r2, #0]
 800b4a2:	3201      	adds	r2, #1
 800b4a4:	701a      	strb	r2, [r3, #0]
 800b4a6:	e10d      	b.n	800b6c4 <tcp_slowtmr+0x340>
        } else {
          u8_t backoff_cnt = tcp_persist_backoff[pcb->persist_backoff - 1];
 800b4a8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b4aa:	22a5      	movs	r2, #165	; 0xa5
 800b4ac:	5c9b      	ldrb	r3, [r3, r2]
 800b4ae:	1e5a      	subs	r2, r3, #1
 800b4b0:	2011      	movs	r0, #17
 800b4b2:	183b      	adds	r3, r7, r0
 800b4b4:	4961      	ldr	r1, [pc, #388]	; (800b63c <tcp_slowtmr+0x2b8>)
 800b4b6:	5c8a      	ldrb	r2, [r1, r2]
 800b4b8:	701a      	strb	r2, [r3, #0]
          if (pcb->persist_cnt < backoff_cnt) {
 800b4ba:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b4bc:	22a4      	movs	r2, #164	; 0xa4
 800b4be:	5c9b      	ldrb	r3, [r3, r2]
 800b4c0:	183a      	adds	r2, r7, r0
 800b4c2:	7812      	ldrb	r2, [r2, #0]
 800b4c4:	429a      	cmp	r2, r3
 800b4c6:	d907      	bls.n	800b4d8 <tcp_slowtmr+0x154>
            pcb->persist_cnt++;
 800b4c8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b4ca:	22a4      	movs	r2, #164	; 0xa4
 800b4cc:	5c9b      	ldrb	r3, [r3, r2]
 800b4ce:	3301      	adds	r3, #1
 800b4d0:	b2d9      	uxtb	r1, r3
 800b4d2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b4d4:	22a4      	movs	r2, #164	; 0xa4
 800b4d6:	5499      	strb	r1, [r3, r2]
          }
          if (pcb->persist_cnt >= backoff_cnt) {
 800b4d8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b4da:	22a4      	movs	r2, #164	; 0xa4
 800b4dc:	5c9b      	ldrb	r3, [r3, r2]
 800b4de:	2211      	movs	r2, #17
 800b4e0:	18ba      	adds	r2, r7, r2
 800b4e2:	7812      	ldrb	r2, [r2, #0]
 800b4e4:	429a      	cmp	r2, r3
 800b4e6:	d900      	bls.n	800b4ea <tcp_slowtmr+0x166>
 800b4e8:	e0ec      	b.n	800b6c4 <tcp_slowtmr+0x340>
            int next_slot = 1; /* increment timer to next slot */
 800b4ea:	2301      	movs	r3, #1
 800b4ec:	623b      	str	r3, [r7, #32]
            /* If snd_wnd is zero, send 1 byte probes */
            if (pcb->snd_wnd == 0) {
 800b4ee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b4f0:	2264      	movs	r2, #100	; 0x64
 800b4f2:	5a9b      	ldrh	r3, [r3, r2]
 800b4f4:	2b00      	cmp	r3, #0
 800b4f6:	d108      	bne.n	800b50a <tcp_slowtmr+0x186>
              if (tcp_zero_window_probe(pcb) != ERR_OK) {
 800b4f8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b4fa:	0018      	movs	r0, r3
 800b4fc:	f006 fc3c 	bl	8011d78 <tcp_zero_window_probe>
 800b500:	1e03      	subs	r3, r0, #0
 800b502:	d014      	beq.n	800b52e <tcp_slowtmr+0x1aa>
                next_slot = 0; /* try probe again with current slot */
 800b504:	2300      	movs	r3, #0
 800b506:	623b      	str	r3, [r7, #32]
 800b508:	e011      	b.n	800b52e <tcp_slowtmr+0x1aa>
              }
              /* snd_wnd not fully closed, split unsent head and fill window */
            } else {
              if (tcp_split_unsent_seg(pcb, (u16_t)pcb->snd_wnd) == ERR_OK) {
 800b50a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b50c:	2264      	movs	r2, #100	; 0x64
 800b50e:	5a9a      	ldrh	r2, [r3, r2]
 800b510:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b512:	0011      	movs	r1, r2
 800b514:	0018      	movs	r0, r3
 800b516:	f004 ff0f 	bl	8010338 <tcp_split_unsent_seg>
 800b51a:	1e03      	subs	r3, r0, #0
 800b51c:	d107      	bne.n	800b52e <tcp_slowtmr+0x1aa>
                if (tcp_output(pcb) == ERR_OK) {
 800b51e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b520:	0018      	movs	r0, r3
 800b522:	f005 fab5 	bl	8010a90 <tcp_output>
 800b526:	1e03      	subs	r3, r0, #0
 800b528:	d101      	bne.n	800b52e <tcp_slowtmr+0x1aa>
                  /* sending will cancel persist timer, else retry with current slot */
                  next_slot = 0;
 800b52a:	2300      	movs	r3, #0
 800b52c:	623b      	str	r3, [r7, #32]
                }
              }
            }
            if (next_slot) {
 800b52e:	6a3b      	ldr	r3, [r7, #32]
 800b530:	2b00      	cmp	r3, #0
 800b532:	d100      	bne.n	800b536 <tcp_slowtmr+0x1b2>
 800b534:	e0c6      	b.n	800b6c4 <tcp_slowtmr+0x340>
              pcb->persist_cnt = 0;
 800b536:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b538:	22a4      	movs	r2, #164	; 0xa4
 800b53a:	2100      	movs	r1, #0
 800b53c:	5499      	strb	r1, [r3, r2]
              if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
 800b53e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b540:	22a5      	movs	r2, #165	; 0xa5
 800b542:	5c9b      	ldrb	r3, [r3, r2]
 800b544:	2b06      	cmp	r3, #6
 800b546:	d900      	bls.n	800b54a <tcp_slowtmr+0x1c6>
 800b548:	e0bc      	b.n	800b6c4 <tcp_slowtmr+0x340>
                pcb->persist_backoff++;
 800b54a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b54c:	22a5      	movs	r2, #165	; 0xa5
 800b54e:	5c9b      	ldrb	r3, [r3, r2]
 800b550:	3301      	adds	r3, #1
 800b552:	b2d9      	uxtb	r1, r3
 800b554:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b556:	22a5      	movs	r2, #165	; 0xa5
 800b558:	5499      	strb	r1, [r3, r2]
 800b55a:	e0b3      	b.n	800b6c4 <tcp_slowtmr+0x340>
            }
          }
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if ((pcb->rtime >= 0) && (pcb->rtime < 0x7FFF)) {
 800b55c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b55e:	2234      	movs	r2, #52	; 0x34
 800b560:	5e9b      	ldrsh	r3, [r3, r2]
 800b562:	2b00      	cmp	r3, #0
 800b564:	db0e      	blt.n	800b584 <tcp_slowtmr+0x200>
 800b566:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b568:	2234      	movs	r2, #52	; 0x34
 800b56a:	5e9b      	ldrsh	r3, [r3, r2]
 800b56c:	4a34      	ldr	r2, [pc, #208]	; (800b640 <tcp_slowtmr+0x2bc>)
 800b56e:	4293      	cmp	r3, r2
 800b570:	d008      	beq.n	800b584 <tcp_slowtmr+0x200>
          ++pcb->rtime;
 800b572:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b574:	2234      	movs	r2, #52	; 0x34
 800b576:	5e9b      	ldrsh	r3, [r3, r2]
 800b578:	b29b      	uxth	r3, r3
 800b57a:	3301      	adds	r3, #1
 800b57c:	b29b      	uxth	r3, r3
 800b57e:	b21a      	sxth	r2, r3
 800b580:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b582:	869a      	strh	r2, [r3, #52]	; 0x34
        }

        if (pcb->rtime >= pcb->rto) {
 800b584:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b586:	2234      	movs	r2, #52	; 0x34
 800b588:	5e9a      	ldrsh	r2, [r3, r2]
 800b58a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b58c:	2144      	movs	r1, #68	; 0x44
 800b58e:	5e5b      	ldrsh	r3, [r3, r1]
 800b590:	429a      	cmp	r2, r3
 800b592:	da00      	bge.n	800b596 <tcp_slowtmr+0x212>
 800b594:	e096      	b.n	800b6c4 <tcp_slowtmr+0x340>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));
          /* If prepare phase fails but we have unsent data but no unacked data,
             still execute the backoff calculations below, as this means we somehow
             failed to send segment. */
          if ((tcp_rexmit_rto_prepare(pcb) == ERR_OK) || ((pcb->unacked == NULL) && (pcb->unsent != NULL))) {
 800b596:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b598:	0018      	movs	r0, r3
 800b59a:	f005 fed3 	bl	8011344 <tcp_rexmit_rto_prepare>
 800b59e:	1e03      	subs	r3, r0, #0
 800b5a0:	d009      	beq.n	800b5b6 <tcp_slowtmr+0x232>
 800b5a2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b5a4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800b5a6:	2b00      	cmp	r3, #0
 800b5a8:	d000      	beq.n	800b5ac <tcp_slowtmr+0x228>
 800b5aa:	e08b      	b.n	800b6c4 <tcp_slowtmr+0x340>
 800b5ac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b5ae:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800b5b0:	2b00      	cmp	r3, #0
 800b5b2:	d100      	bne.n	800b5b6 <tcp_slowtmr+0x232>
 800b5b4:	e086      	b.n	800b6c4 <tcp_slowtmr+0x340>
            /* Double retransmission time-out unless we are trying to
             * connect to somebody (i.e., we are in SYN_SENT). */
            if (pcb->state != SYN_SENT) {
 800b5b6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b5b8:	7e1b      	ldrb	r3, [r3, #24]
 800b5ba:	2b02      	cmp	r3, #2
 800b5bc:	d04a      	beq.n	800b654 <tcp_slowtmr+0x2d0>
              u8_t backoff_idx = LWIP_MIN(pcb->nrtx, sizeof(tcp_backoff) - 1);
 800b5be:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b5c0:	2246      	movs	r2, #70	; 0x46
 800b5c2:	5c9b      	ldrb	r3, [r3, r2]
 800b5c4:	221b      	movs	r2, #27
 800b5c6:	18ba      	adds	r2, r7, r2
 800b5c8:	b2d9      	uxtb	r1, r3
 800b5ca:	290c      	cmp	r1, #12
 800b5cc:	d900      	bls.n	800b5d0 <tcp_slowtmr+0x24c>
 800b5ce:	230c      	movs	r3, #12
 800b5d0:	7013      	strb	r3, [r2, #0]
              int calc_rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[backoff_idx];
 800b5d2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b5d4:	2240      	movs	r2, #64	; 0x40
 800b5d6:	5e9b      	ldrsh	r3, [r3, r2]
 800b5d8:	10db      	asrs	r3, r3, #3
 800b5da:	b21b      	sxth	r3, r3
 800b5dc:	0019      	movs	r1, r3
 800b5de:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b5e0:	2242      	movs	r2, #66	; 0x42
 800b5e2:	5e9b      	ldrsh	r3, [r3, r2]
 800b5e4:	18cb      	adds	r3, r1, r3
 800b5e6:	221b      	movs	r2, #27
 800b5e8:	18ba      	adds	r2, r7, r2
 800b5ea:	7812      	ldrb	r2, [r2, #0]
 800b5ec:	4915      	ldr	r1, [pc, #84]	; (800b644 <tcp_slowtmr+0x2c0>)
 800b5ee:	5c8a      	ldrb	r2, [r1, r2]
 800b5f0:	4093      	lsls	r3, r2
 800b5f2:	617b      	str	r3, [r7, #20]
              pcb->rto = (s16_t)LWIP_MIN(calc_rto, 0x7FFF);
 800b5f4:	697b      	ldr	r3, [r7, #20]
 800b5f6:	4a14      	ldr	r2, [pc, #80]	; (800b648 <tcp_slowtmr+0x2c4>)
 800b5f8:	4293      	cmp	r3, r2
 800b5fa:	dc27      	bgt.n	800b64c <tcp_slowtmr+0x2c8>
 800b5fc:	697b      	ldr	r3, [r7, #20]
 800b5fe:	b21a      	sxth	r2, r3
 800b600:	e025      	b.n	800b64e <tcp_slowtmr+0x2ca>
 800b602:	46c0      	nop			; (mov r8, r8)
 800b604:	20002ed8 	.word	0x20002ed8
 800b608:	20001b2a 	.word	0x20001b2a
 800b60c:	20002ed4 	.word	0x20002ed4
 800b610:	0801fa7c 	.word	0x0801fa7c
 800b614:	000004bf 	.word	0x000004bf
 800b618:	0801fdbc 	.word	0x0801fdbc
 800b61c:	0801fab8 	.word	0x0801fab8
 800b620:	0801fde8 	.word	0x0801fde8
 800b624:	000004c1 	.word	0x000004c1
 800b628:	0801fe14 	.word	0x0801fe14
 800b62c:	000004d5 	.word	0x000004d5
 800b630:	0801fe44 	.word	0x0801fe44
 800b634:	000004d6 	.word	0x000004d6
 800b638:	0801fe78 	.word	0x0801fe78
 800b63c:	0802242c 	.word	0x0802242c
 800b640:	00007fff 	.word	0x00007fff
 800b644:	0802241c 	.word	0x0802241c
 800b648:	00007ffe 	.word	0x00007ffe
 800b64c:	4ad0      	ldr	r2, [pc, #832]	; (800b990 <tcp_slowtmr+0x60c>)
 800b64e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b650:	2144      	movs	r1, #68	; 0x44
 800b652:	525a      	strh	r2, [r3, r1]
            }

            /* Reset the retransmission timer. */
            pcb->rtime = 0;
 800b654:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b656:	2200      	movs	r2, #0
 800b658:	869a      	strh	r2, [r3, #52]	; 0x34

            /* Reduce congestion window and ssthresh. */
            eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
 800b65a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b65c:	2264      	movs	r2, #100	; 0x64
 800b65e:	5a99      	ldrh	r1, [r3, r2]
 800b660:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b662:	224c      	movs	r2, #76	; 0x4c
 800b664:	5a9b      	ldrh	r3, [r3, r2]
 800b666:	2212      	movs	r2, #18
 800b668:	18ba      	adds	r2, r7, r2
 800b66a:	1c1c      	adds	r4, r3, #0
 800b66c:	1c0b      	adds	r3, r1, #0
 800b66e:	b298      	uxth	r0, r3
 800b670:	b2a1      	uxth	r1, r4
 800b672:	4288      	cmp	r0, r1
 800b674:	d900      	bls.n	800b678 <tcp_slowtmr+0x2f4>
 800b676:	1c23      	adds	r3, r4, #0
 800b678:	8013      	strh	r3, [r2, #0]
            pcb->ssthresh = eff_wnd >> 1;
 800b67a:	2312      	movs	r3, #18
 800b67c:	18fb      	adds	r3, r7, r3
 800b67e:	881b      	ldrh	r3, [r3, #0]
 800b680:	085b      	lsrs	r3, r3, #1
 800b682:	b299      	uxth	r1, r3
 800b684:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b686:	224e      	movs	r2, #78	; 0x4e
 800b688:	5299      	strh	r1, [r3, r2]
            if (pcb->ssthresh < (tcpwnd_size_t)(pcb->mss << 1)) {
 800b68a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b68c:	224e      	movs	r2, #78	; 0x4e
 800b68e:	5a9a      	ldrh	r2, [r3, r2]
 800b690:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b692:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800b694:	18db      	adds	r3, r3, r3
 800b696:	b29b      	uxth	r3, r3
 800b698:	429a      	cmp	r2, r3
 800b69a:	d206      	bcs.n	800b6aa <tcp_slowtmr+0x326>
              pcb->ssthresh = (tcpwnd_size_t)(pcb->mss << 1);
 800b69c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b69e:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800b6a0:	18db      	adds	r3, r3, r3
 800b6a2:	b299      	uxth	r1, r3
 800b6a4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b6a6:	224e      	movs	r2, #78	; 0x4e
 800b6a8:	5299      	strh	r1, [r3, r2]
            }
            pcb->cwnd = pcb->mss;
 800b6aa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b6ac:	8ed9      	ldrh	r1, [r3, #54]	; 0x36
 800b6ae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b6b0:	224c      	movs	r2, #76	; 0x4c
 800b6b2:	5299      	strh	r1, [r3, r2]
            LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: cwnd %"TCPWNDSIZE_F
                                         " ssthresh %"TCPWNDSIZE_F"\n",
                                         pcb->cwnd, pcb->ssthresh));
            pcb->bytes_acked = 0;
 800b6b4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b6b6:	226e      	movs	r2, #110	; 0x6e
 800b6b8:	2100      	movs	r1, #0
 800b6ba:	5299      	strh	r1, [r3, r2]

            /* The following needs to be called AFTER cwnd is set to one
               mss - STJ */
            tcp_rexmit_rto_commit(pcb);
 800b6bc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b6be:	0018      	movs	r0, r3
 800b6c0:	f005 fec8 	bl	8011454 <tcp_rexmit_rto_commit>
          }
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
 800b6c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b6c6:	7e1b      	ldrb	r3, [r3, #24]
 800b6c8:	2b06      	cmp	r3, #6
 800b6ca:	d112      	bne.n	800b6f2 <tcp_slowtmr+0x36e>
      /* If this PCB is in FIN_WAIT_2 because of SHUT_WR don't let it time out. */
      if (pcb->flags & TF_RXCLOSED) {
 800b6cc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b6ce:	8bdb      	ldrh	r3, [r3, #30]
 800b6d0:	001a      	movs	r2, r3
 800b6d2:	2310      	movs	r3, #16
 800b6d4:	4013      	ands	r3, r2
 800b6d6:	d00c      	beq.n	800b6f2 <tcp_slowtmr+0x36e>
        /* PCB was fully closed (either through close() or SHUT_RDWR):
           normal FIN-WAIT timeout handling. */
        if ((u32_t)(tcp_ticks - pcb->tmr) >
 800b6d8:	4bae      	ldr	r3, [pc, #696]	; (800b994 <tcp_slowtmr+0x610>)
 800b6da:	681a      	ldr	r2, [r3, #0]
 800b6dc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b6de:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b6e0:	1ad3      	subs	r3, r2, r3
 800b6e2:	2b14      	cmp	r3, #20
 800b6e4:	d905      	bls.n	800b6f2 <tcp_slowtmr+0x36e>
            TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
          ++pcb_remove;
 800b6e6:	2227      	movs	r2, #39	; 0x27
 800b6e8:	18bb      	adds	r3, r7, r2
 800b6ea:	18ba      	adds	r2, r7, r2
 800b6ec:	7812      	ldrb	r2, [r2, #0]
 800b6ee:	3201      	adds	r2, #1
 800b6f0:	701a      	strb	r2, [r3, #0]
        }
      }
    }

    /* Check if KEEPALIVE should be sent */
    if (ip_get_option(pcb, SOF_KEEPALIVE) &&
 800b6f2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b6f4:	7a5b      	ldrb	r3, [r3, #9]
 800b6f6:	001a      	movs	r2, r3
 800b6f8:	2308      	movs	r3, #8
 800b6fa:	4013      	ands	r3, r2
 800b6fc:	d05a      	beq.n	800b7b4 <tcp_slowtmr+0x430>
        ((pcb->state == ESTABLISHED) ||
 800b6fe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b700:	7e1b      	ldrb	r3, [r3, #24]
    if (ip_get_option(pcb, SOF_KEEPALIVE) &&
 800b702:	2b04      	cmp	r3, #4
 800b704:	d003      	beq.n	800b70e <tcp_slowtmr+0x38a>
         (pcb->state == CLOSE_WAIT))) {
 800b706:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b708:	7e1b      	ldrb	r3, [r3, #24]
        ((pcb->state == ESTABLISHED) ||
 800b70a:	2b07      	cmp	r3, #7
 800b70c:	d152      	bne.n	800b7b4 <tcp_slowtmr+0x430>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 800b70e:	4ba1      	ldr	r3, [pc, #644]	; (800b994 <tcp_slowtmr+0x610>)
 800b710:	681a      	ldr	r2, [r3, #0]
 800b712:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b714:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b716:	1ad4      	subs	r4, r2, r3
          (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL) {
 800b718:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b71a:	2298      	movs	r2, #152	; 0x98
 800b71c:	589a      	ldr	r2, [r3, r2]
 800b71e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b720:	21a0      	movs	r1, #160	; 0xa0
 800b722:	585b      	ldr	r3, [r3, r1]
 800b724:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800b726:	209c      	movs	r0, #156	; 0x9c
 800b728:	5809      	ldr	r1, [r1, r0]
 800b72a:	434b      	muls	r3, r1
 800b72c:	18d3      	adds	r3, r2, r3
 800b72e:	22fa      	movs	r2, #250	; 0xfa
 800b730:	0091      	lsls	r1, r2, #2
 800b732:	0018      	movs	r0, r3
 800b734:	f7f4 fcfa 	bl	800012c <__udivsi3>
 800b738:	0003      	movs	r3, r0
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 800b73a:	429c      	cmp	r4, r3
 800b73c:	d90c      	bls.n	800b758 <tcp_slowtmr+0x3d4>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to "));
        ip_addr_debug_print_val(TCP_DEBUG, pcb->remote_ip);
        LWIP_DEBUGF(TCP_DEBUG, ("\n"));

        ++pcb_remove;
 800b73e:	2227      	movs	r2, #39	; 0x27
 800b740:	18bb      	adds	r3, r7, r2
 800b742:	18ba      	adds	r2, r7, r2
 800b744:	7812      	ldrb	r2, [r2, #0]
 800b746:	3201      	adds	r2, #1
 800b748:	701a      	strb	r2, [r3, #0]
        ++pcb_reset;
 800b74a:	2226      	movs	r2, #38	; 0x26
 800b74c:	18bb      	adds	r3, r7, r2
 800b74e:	18ba      	adds	r2, r7, r2
 800b750:	7812      	ldrb	r2, [r2, #0]
 800b752:	3201      	adds	r2, #1
 800b754:	701a      	strb	r2, [r3, #0]
 800b756:	e02d      	b.n	800b7b4 <tcp_slowtmr+0x430>
      } else if ((u32_t)(tcp_ticks - pcb->tmr) >
 800b758:	4b8e      	ldr	r3, [pc, #568]	; (800b994 <tcp_slowtmr+0x610>)
 800b75a:	681a      	ldr	r2, [r3, #0]
 800b75c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b75e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b760:	1ad4      	subs	r4, r2, r3
                 (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
 800b762:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b764:	2298      	movs	r2, #152	; 0x98
 800b766:	589a      	ldr	r2, [r3, r2]
 800b768:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b76a:	21a7      	movs	r1, #167	; 0xa7
 800b76c:	5c5b      	ldrb	r3, [r3, r1]
 800b76e:	0018      	movs	r0, r3
 800b770:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b772:	219c      	movs	r1, #156	; 0x9c
 800b774:	585b      	ldr	r3, [r3, r1]
 800b776:	4343      	muls	r3, r0
 800b778:	18d3      	adds	r3, r2, r3
                 / TCP_SLOW_INTERVAL) {
 800b77a:	22fa      	movs	r2, #250	; 0xfa
 800b77c:	0091      	lsls	r1, r2, #2
 800b77e:	0018      	movs	r0, r3
 800b780:	f7f4 fcd4 	bl	800012c <__udivsi3>
 800b784:	0003      	movs	r3, r0
      } else if ((u32_t)(tcp_ticks - pcb->tmr) >
 800b786:	429c      	cmp	r4, r3
 800b788:	d914      	bls.n	800b7b4 <tcp_slowtmr+0x430>
        err = tcp_keepalive(pcb);
 800b78a:	2525      	movs	r5, #37	; 0x25
 800b78c:	197c      	adds	r4, r7, r5
 800b78e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b790:	0018      	movs	r0, r3
 800b792:	f006 faa7 	bl	8011ce4 <tcp_keepalive>
 800b796:	0003      	movs	r3, r0
 800b798:	7023      	strb	r3, [r4, #0]
        if (err == ERR_OK) {
 800b79a:	197b      	adds	r3, r7, r5
 800b79c:	781b      	ldrb	r3, [r3, #0]
 800b79e:	b25b      	sxtb	r3, r3
 800b7a0:	2b00      	cmp	r3, #0
 800b7a2:	d107      	bne.n	800b7b4 <tcp_slowtmr+0x430>
          pcb->keep_cnt_sent++;
 800b7a4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b7a6:	22a7      	movs	r2, #167	; 0xa7
 800b7a8:	5c9b      	ldrb	r3, [r3, r2]
 800b7aa:	3301      	adds	r3, #1
 800b7ac:	b2d9      	uxtb	r1, r3
 800b7ae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b7b0:	22a7      	movs	r2, #167	; 0xa7
 800b7b2:	5499      	strb	r1, [r3, r2]

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL &&
 800b7b4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b7b6:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800b7b8:	2b00      	cmp	r3, #0
 800b7ba:	d012      	beq.n	800b7e2 <tcp_slowtmr+0x45e>
        (tcp_ticks - pcb->tmr >= (u32_t)pcb->rto * TCP_OOSEQ_TIMEOUT)) {
 800b7bc:	4b75      	ldr	r3, [pc, #468]	; (800b994 <tcp_slowtmr+0x610>)
 800b7be:	681a      	ldr	r2, [r3, #0]
 800b7c0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b7c2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b7c4:	1ad2      	subs	r2, r2, r3
 800b7c6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b7c8:	2144      	movs	r1, #68	; 0x44
 800b7ca:	5e5b      	ldrsh	r3, [r3, r1]
 800b7cc:	0019      	movs	r1, r3
 800b7ce:	000b      	movs	r3, r1
 800b7d0:	005b      	lsls	r3, r3, #1
 800b7d2:	185b      	adds	r3, r3, r1
 800b7d4:	005b      	lsls	r3, r3, #1
    if (pcb->ooseq != NULL &&
 800b7d6:	429a      	cmp	r2, r3
 800b7d8:	d303      	bcc.n	800b7e2 <tcp_slowtmr+0x45e>
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
      tcp_free_ooseq(pcb);
 800b7da:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b7dc:	0018      	movs	r0, r3
 800b7de:	f000 fefb 	bl	800c5d8 <tcp_free_ooseq>
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
 800b7e2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b7e4:	7e1b      	ldrb	r3, [r3, #24]
 800b7e6:	2b03      	cmp	r3, #3
 800b7e8:	d10c      	bne.n	800b804 <tcp_slowtmr+0x480>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 800b7ea:	4b6a      	ldr	r3, [pc, #424]	; (800b994 <tcp_slowtmr+0x610>)
 800b7ec:	681a      	ldr	r2, [r3, #0]
 800b7ee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b7f0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b7f2:	1ad3      	subs	r3, r2, r3
 800b7f4:	2b14      	cmp	r3, #20
 800b7f6:	d905      	bls.n	800b804 <tcp_slowtmr+0x480>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
 800b7f8:	2227      	movs	r2, #39	; 0x27
 800b7fa:	18bb      	adds	r3, r7, r2
 800b7fc:	18ba      	adds	r2, r7, r2
 800b7fe:	7812      	ldrb	r2, [r2, #0]
 800b800:	3201      	adds	r2, #1
 800b802:	701a      	strb	r2, [r3, #0]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
 800b804:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b806:	7e1b      	ldrb	r3, [r3, #24]
 800b808:	2b09      	cmp	r3, #9
 800b80a:	d10c      	bne.n	800b826 <tcp_slowtmr+0x4a2>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 800b80c:	4b61      	ldr	r3, [pc, #388]	; (800b994 <tcp_slowtmr+0x610>)
 800b80e:	681a      	ldr	r2, [r3, #0]
 800b810:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b812:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b814:	1ad3      	subs	r3, r2, r3
 800b816:	2b78      	cmp	r3, #120	; 0x78
 800b818:	d905      	bls.n	800b826 <tcp_slowtmr+0x4a2>
        ++pcb_remove;
 800b81a:	2227      	movs	r2, #39	; 0x27
 800b81c:	18bb      	adds	r3, r7, r2
 800b81e:	18ba      	adds	r2, r7, r2
 800b820:	7812      	ldrb	r2, [r2, #0]
 800b822:	3201      	adds	r2, #1
 800b824:	701a      	strb	r2, [r3, #0]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
 800b826:	2327      	movs	r3, #39	; 0x27
 800b828:	18fb      	adds	r3, r7, r3
 800b82a:	781b      	ldrb	r3, [r3, #0]
 800b82c:	2b00      	cmp	r3, #0
 800b82e:	d063      	beq.n	800b8f8 <tcp_slowtmr+0x574>
      struct tcp_pcb *pcb2;
#if LWIP_CALLBACK_API
      tcp_err_fn err_fn = pcb->errf;
 800b830:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b832:	2294      	movs	r2, #148	; 0x94
 800b834:	589b      	ldr	r3, [r3, r2]
 800b836:	60fb      	str	r3, [r7, #12]
#endif /* LWIP_CALLBACK_API */
      void *err_arg;
      enum tcp_state last_state;
      tcp_pcb_purge(pcb);
 800b838:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b83a:	0018      	movs	r0, r3
 800b83c:	f000 fcfc 	bl	800c238 <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
 800b840:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b842:	2b00      	cmp	r3, #0
 800b844:	d00f      	beq.n	800b866 <tcp_slowtmr+0x4e2>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
 800b846:	4b54      	ldr	r3, [pc, #336]	; (800b998 <tcp_slowtmr+0x614>)
 800b848:	681b      	ldr	r3, [r3, #0]
 800b84a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800b84c:	429a      	cmp	r2, r3
 800b84e:	d105      	bne.n	800b85c <tcp_slowtmr+0x4d8>
 800b850:	4b52      	ldr	r3, [pc, #328]	; (800b99c <tcp_slowtmr+0x618>)
 800b852:	4a53      	ldr	r2, [pc, #332]	; (800b9a0 <tcp_slowtmr+0x61c>)
 800b854:	4953      	ldr	r1, [pc, #332]	; (800b9a4 <tcp_slowtmr+0x620>)
 800b856:	4854      	ldr	r0, [pc, #336]	; (800b9a8 <tcp_slowtmr+0x624>)
 800b858:	f7f7 f840 	bl	80028dc <app_debug_rtt_raw>
        prev->next = pcb->next;
 800b85c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b85e:	691a      	ldr	r2, [r3, #16]
 800b860:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b862:	611a      	str	r2, [r3, #16]
 800b864:	e00e      	b.n	800b884 <tcp_slowtmr+0x500>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
 800b866:	4b4c      	ldr	r3, [pc, #304]	; (800b998 <tcp_slowtmr+0x614>)
 800b868:	681b      	ldr	r3, [r3, #0]
 800b86a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800b86c:	429a      	cmp	r2, r3
 800b86e:	d005      	beq.n	800b87c <tcp_slowtmr+0x4f8>
 800b870:	4b4a      	ldr	r3, [pc, #296]	; (800b99c <tcp_slowtmr+0x618>)
 800b872:	4a4e      	ldr	r2, [pc, #312]	; (800b9ac <tcp_slowtmr+0x628>)
 800b874:	494e      	ldr	r1, [pc, #312]	; (800b9b0 <tcp_slowtmr+0x62c>)
 800b876:	484c      	ldr	r0, [pc, #304]	; (800b9a8 <tcp_slowtmr+0x624>)
 800b878:	f7f7 f830 	bl	80028dc <app_debug_rtt_raw>
        tcp_active_pcbs = pcb->next;
 800b87c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b87e:	691a      	ldr	r2, [r3, #16]
 800b880:	4b45      	ldr	r3, [pc, #276]	; (800b998 <tcp_slowtmr+0x614>)
 800b882:	601a      	str	r2, [r3, #0]
      }

      if (pcb_reset) {
 800b884:	2326      	movs	r3, #38	; 0x26
 800b886:	18fb      	adds	r3, r7, r3
 800b888:	781b      	ldrb	r3, [r3, #0]
 800b88a:	2b00      	cmp	r3, #0
 800b88c:	d013      	beq.n	800b8b6 <tcp_slowtmr+0x532>
        tcp_rst(pcb, pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 800b88e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b890:	6d5c      	ldr	r4, [r3, #84]	; 0x54
 800b892:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b894:	6a9d      	ldr	r5, [r3, #40]	; 0x28
 800b896:	6afe      	ldr	r6, [r7, #44]	; 0x2c
 800b898:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b89a:	3304      	adds	r3, #4
 800b89c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800b89e:	8b52      	ldrh	r2, [r2, #26]
 800b8a0:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800b8a2:	8b89      	ldrh	r1, [r1, #28]
 800b8a4:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800b8a6:	9102      	str	r1, [sp, #8]
 800b8a8:	9201      	str	r2, [sp, #4]
 800b8aa:	9300      	str	r3, [sp, #0]
 800b8ac:	0033      	movs	r3, r6
 800b8ae:	002a      	movs	r2, r5
 800b8b0:	0021      	movs	r1, r4
 800b8b2:	f006 f941 	bl	8011b38 <tcp_rst>
                pcb->local_port, pcb->remote_port);
      }

      err_arg = pcb->callback_arg;
 800b8b6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b8b8:	695b      	ldr	r3, [r3, #20]
 800b8ba:	60bb      	str	r3, [r7, #8]
      last_state = pcb->state;
 800b8bc:	1dfb      	adds	r3, r7, #7
 800b8be:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800b8c0:	7e12      	ldrb	r2, [r2, #24]
 800b8c2:	701a      	strb	r2, [r3, #0]
      pcb2 = pcb;
 800b8c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b8c6:	603b      	str	r3, [r7, #0]
      pcb = pcb->next;
 800b8c8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b8ca:	691b      	ldr	r3, [r3, #16]
 800b8cc:	62fb      	str	r3, [r7, #44]	; 0x2c
      tcp_free(pcb2);
 800b8ce:	683b      	ldr	r3, [r7, #0]
 800b8d0:	0018      	movs	r0, r3
 800b8d2:	f7fe ffd3 	bl	800a87c <tcp_free>

      tcp_active_pcbs_changed = 0;
 800b8d6:	4b37      	ldr	r3, [pc, #220]	; (800b9b4 <tcp_slowtmr+0x630>)
 800b8d8:	2200      	movs	r2, #0
 800b8da:	701a      	strb	r2, [r3, #0]
      TCP_EVENT_ERR(last_state, err_fn, err_arg, ERR_ABRT);
 800b8dc:	68fb      	ldr	r3, [r7, #12]
 800b8de:	2b00      	cmp	r3, #0
 800b8e0:	d005      	beq.n	800b8ee <tcp_slowtmr+0x56a>
 800b8e2:	230d      	movs	r3, #13
 800b8e4:	4259      	negs	r1, r3
 800b8e6:	68ba      	ldr	r2, [r7, #8]
 800b8e8:	68fb      	ldr	r3, [r7, #12]
 800b8ea:	0010      	movs	r0, r2
 800b8ec:	4798      	blx	r3
      if (tcp_active_pcbs_changed) {
 800b8ee:	4b31      	ldr	r3, [pc, #196]	; (800b9b4 <tcp_slowtmr+0x630>)
 800b8f0:	781b      	ldrb	r3, [r3, #0]
 800b8f2:	2b00      	cmp	r3, #0
 800b8f4:	d041      	beq.n	800b97a <tcp_slowtmr+0x5f6>
        goto tcp_slowtmr_start;
 800b8f6:	e557      	b.n	800b3a8 <tcp_slowtmr+0x24>
      }
    } else {
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
 800b8f8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b8fa:	62bb      	str	r3, [r7, #40]	; 0x28
      pcb = pcb->next;
 800b8fc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b8fe:	691b      	ldr	r3, [r3, #16]
 800b900:	62fb      	str	r3, [r7, #44]	; 0x2c

      /* We check if we should poll the connection. */
      ++prev->polltmr;
 800b902:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b904:	2220      	movs	r2, #32
 800b906:	5c9b      	ldrb	r3, [r3, r2]
 800b908:	3301      	adds	r3, #1
 800b90a:	b2d9      	uxtb	r1, r3
 800b90c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b90e:	2220      	movs	r2, #32
 800b910:	5499      	strb	r1, [r3, r2]
      if (prev->polltmr >= prev->pollinterval) {
 800b912:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b914:	2220      	movs	r2, #32
 800b916:	5c9a      	ldrb	r2, [r3, r2]
 800b918:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b91a:	2121      	movs	r1, #33	; 0x21
 800b91c:	5c5b      	ldrb	r3, [r3, r1]
 800b91e:	429a      	cmp	r2, r3
 800b920:	d32b      	bcc.n	800b97a <tcp_slowtmr+0x5f6>
        prev->polltmr = 0;
 800b922:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b924:	2220      	movs	r2, #32
 800b926:	2100      	movs	r1, #0
 800b928:	5499      	strb	r1, [r3, r2]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        tcp_active_pcbs_changed = 0;
 800b92a:	4b22      	ldr	r3, [pc, #136]	; (800b9b4 <tcp_slowtmr+0x630>)
 800b92c:	2200      	movs	r2, #0
 800b92e:	701a      	strb	r2, [r3, #0]
        TCP_EVENT_POLL(prev, err);
 800b930:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b932:	2290      	movs	r2, #144	; 0x90
 800b934:	589b      	ldr	r3, [r3, r2]
 800b936:	2b00      	cmp	r3, #0
 800b938:	d00c      	beq.n	800b954 <tcp_slowtmr+0x5d0>
 800b93a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b93c:	2290      	movs	r2, #144	; 0x90
 800b93e:	589a      	ldr	r2, [r3, r2]
 800b940:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b942:	695b      	ldr	r3, [r3, #20]
 800b944:	2125      	movs	r1, #37	; 0x25
 800b946:	187c      	adds	r4, r7, r1
 800b948:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800b94a:	0018      	movs	r0, r3
 800b94c:	4790      	blx	r2
 800b94e:	0003      	movs	r3, r0
 800b950:	7023      	strb	r3, [r4, #0]
 800b952:	e003      	b.n	800b95c <tcp_slowtmr+0x5d8>
 800b954:	2325      	movs	r3, #37	; 0x25
 800b956:	18fb      	adds	r3, r7, r3
 800b958:	2200      	movs	r2, #0
 800b95a:	701a      	strb	r2, [r3, #0]
        if (tcp_active_pcbs_changed) {
 800b95c:	4b15      	ldr	r3, [pc, #84]	; (800b9b4 <tcp_slowtmr+0x630>)
 800b95e:	781b      	ldrb	r3, [r3, #0]
 800b960:	2b00      	cmp	r3, #0
 800b962:	d000      	beq.n	800b966 <tcp_slowtmr+0x5e2>
          goto tcp_slowtmr_start;
 800b964:	e520      	b.n	800b3a8 <tcp_slowtmr+0x24>
        }
        /* if err == ERR_ABRT, 'prev' is already deallocated */
        if (err == ERR_OK) {
 800b966:	2325      	movs	r3, #37	; 0x25
 800b968:	18fb      	adds	r3, r7, r3
 800b96a:	781b      	ldrb	r3, [r3, #0]
 800b96c:	b25b      	sxtb	r3, r3
 800b96e:	2b00      	cmp	r3, #0
 800b970:	d103      	bne.n	800b97a <tcp_slowtmr+0x5f6>
          tcp_output(prev);
 800b972:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b974:	0018      	movs	r0, r3
 800b976:	f005 f88b 	bl	8010a90 <tcp_output>
  while (pcb != NULL) {
 800b97a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b97c:	2b00      	cmp	r3, #0
 800b97e:	d000      	beq.n	800b982 <tcp_slowtmr+0x5fe>
 800b980:	e518      	b.n	800b3b4 <tcp_slowtmr+0x30>
    }
  }


  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
 800b982:	2300      	movs	r3, #0
 800b984:	62bb      	str	r3, [r7, #40]	; 0x28
  pcb = tcp_tw_pcbs;
 800b986:	4b0c      	ldr	r3, [pc, #48]	; (800b9b8 <tcp_slowtmr+0x634>)
 800b988:	681b      	ldr	r3, [r3, #0]
 800b98a:	62fb      	str	r3, [r7, #44]	; 0x2c
  while (pcb != NULL) {
 800b98c:	e06b      	b.n	800ba66 <tcp_slowtmr+0x6e2>
 800b98e:	46c0      	nop			; (mov r8, r8)
 800b990:	00007fff 	.word	0x00007fff
 800b994:	20002ed8 	.word	0x20002ed8
 800b998:	20002ed4 	.word	0x20002ed4
 800b99c:	0801fa7c 	.word	0x0801fa7c
 800b9a0:	0000056e 	.word	0x0000056e
 800b9a4:	0801feb0 	.word	0x0801feb0
 800b9a8:	0801fab8 	.word	0x0801fab8
 800b9ac:	00000572 	.word	0x00000572
 800b9b0:	0801fedc 	.word	0x0801fedc
 800b9b4:	20002ed0 	.word	0x20002ed0
 800b9b8:	20002ee4 	.word	0x20002ee4
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 800b9bc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b9be:	7e1b      	ldrb	r3, [r3, #24]
 800b9c0:	2b0a      	cmp	r3, #10
 800b9c2:	d005      	beq.n	800b9d0 <tcp_slowtmr+0x64c>
 800b9c4:	4b2c      	ldr	r3, [pc, #176]	; (800ba78 <tcp_slowtmr+0x6f4>)
 800b9c6:	4a2d      	ldr	r2, [pc, #180]	; (800ba7c <tcp_slowtmr+0x6f8>)
 800b9c8:	492d      	ldr	r1, [pc, #180]	; (800ba80 <tcp_slowtmr+0x6fc>)
 800b9ca:	482e      	ldr	r0, [pc, #184]	; (800ba84 <tcp_slowtmr+0x700>)
 800b9cc:	f7f6 ff86 	bl	80028dc <app_debug_rtt_raw>
    pcb_remove = 0;
 800b9d0:	2127      	movs	r1, #39	; 0x27
 800b9d2:	187b      	adds	r3, r7, r1
 800b9d4:	2200      	movs	r2, #0
 800b9d6:	701a      	strb	r2, [r3, #0]

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 800b9d8:	4b2b      	ldr	r3, [pc, #172]	; (800ba88 <tcp_slowtmr+0x704>)
 800b9da:	681a      	ldr	r2, [r3, #0]
 800b9dc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b9de:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b9e0:	1ad3      	subs	r3, r2, r3
 800b9e2:	2b78      	cmp	r3, #120	; 0x78
 800b9e4:	d904      	bls.n	800b9f0 <tcp_slowtmr+0x66c>
      ++pcb_remove;
 800b9e6:	187b      	adds	r3, r7, r1
 800b9e8:	187a      	adds	r2, r7, r1
 800b9ea:	7812      	ldrb	r2, [r2, #0]
 800b9ec:	3201      	adds	r2, #1
 800b9ee:	701a      	strb	r2, [r3, #0]
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
 800b9f0:	2327      	movs	r3, #39	; 0x27
 800b9f2:	18fb      	adds	r3, r7, r3
 800b9f4:	781b      	ldrb	r3, [r3, #0]
 800b9f6:	2b00      	cmp	r3, #0
 800b9f8:	d030      	beq.n	800ba5c <tcp_slowtmr+0x6d8>
      struct tcp_pcb *pcb2;
      tcp_pcb_purge(pcb);
 800b9fa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b9fc:	0018      	movs	r0, r3
 800b9fe:	f000 fc1b 	bl	800c238 <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
 800ba02:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ba04:	2b00      	cmp	r3, #0
 800ba06:	d010      	beq.n	800ba2a <tcp_slowtmr+0x6a6>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
 800ba08:	4b20      	ldr	r3, [pc, #128]	; (800ba8c <tcp_slowtmr+0x708>)
 800ba0a:	681b      	ldr	r3, [r3, #0]
 800ba0c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800ba0e:	429a      	cmp	r2, r3
 800ba10:	d106      	bne.n	800ba20 <tcp_slowtmr+0x69c>
 800ba12:	4b19      	ldr	r3, [pc, #100]	; (800ba78 <tcp_slowtmr+0x6f4>)
 800ba14:	22b6      	movs	r2, #182	; 0xb6
 800ba16:	00d2      	lsls	r2, r2, #3
 800ba18:	491d      	ldr	r1, [pc, #116]	; (800ba90 <tcp_slowtmr+0x70c>)
 800ba1a:	481a      	ldr	r0, [pc, #104]	; (800ba84 <tcp_slowtmr+0x700>)
 800ba1c:	f7f6 ff5e 	bl	80028dc <app_debug_rtt_raw>
        prev->next = pcb->next;
 800ba20:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ba22:	691a      	ldr	r2, [r3, #16]
 800ba24:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ba26:	611a      	str	r2, [r3, #16]
 800ba28:	e00e      	b.n	800ba48 <tcp_slowtmr+0x6c4>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
 800ba2a:	4b18      	ldr	r3, [pc, #96]	; (800ba8c <tcp_slowtmr+0x708>)
 800ba2c:	681b      	ldr	r3, [r3, #0]
 800ba2e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800ba30:	429a      	cmp	r2, r3
 800ba32:	d005      	beq.n	800ba40 <tcp_slowtmr+0x6bc>
 800ba34:	4b10      	ldr	r3, [pc, #64]	; (800ba78 <tcp_slowtmr+0x6f4>)
 800ba36:	4a17      	ldr	r2, [pc, #92]	; (800ba94 <tcp_slowtmr+0x710>)
 800ba38:	4917      	ldr	r1, [pc, #92]	; (800ba98 <tcp_slowtmr+0x714>)
 800ba3a:	4812      	ldr	r0, [pc, #72]	; (800ba84 <tcp_slowtmr+0x700>)
 800ba3c:	f7f6 ff4e 	bl	80028dc <app_debug_rtt_raw>
        tcp_tw_pcbs = pcb->next;
 800ba40:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ba42:	691a      	ldr	r2, [r3, #16]
 800ba44:	4b11      	ldr	r3, [pc, #68]	; (800ba8c <tcp_slowtmr+0x708>)
 800ba46:	601a      	str	r2, [r3, #0]
      }
      pcb2 = pcb;
 800ba48:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ba4a:	61fb      	str	r3, [r7, #28]
      pcb = pcb->next;
 800ba4c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ba4e:	691b      	ldr	r3, [r3, #16]
 800ba50:	62fb      	str	r3, [r7, #44]	; 0x2c
      tcp_free(pcb2);
 800ba52:	69fb      	ldr	r3, [r7, #28]
 800ba54:	0018      	movs	r0, r3
 800ba56:	f7fe ff11 	bl	800a87c <tcp_free>
 800ba5a:	e004      	b.n	800ba66 <tcp_slowtmr+0x6e2>
    } else {
      prev = pcb;
 800ba5c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ba5e:	62bb      	str	r3, [r7, #40]	; 0x28
      pcb = pcb->next;
 800ba60:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ba62:	691b      	ldr	r3, [r3, #16]
 800ba64:	62fb      	str	r3, [r7, #44]	; 0x2c
  while (pcb != NULL) {
 800ba66:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ba68:	2b00      	cmp	r3, #0
 800ba6a:	d1a7      	bne.n	800b9bc <tcp_slowtmr+0x638>
    }
  }
}
 800ba6c:	46c0      	nop			; (mov r8, r8)
 800ba6e:	46c0      	nop			; (mov r8, r8)
 800ba70:	46bd      	mov	sp, r7
 800ba72:	b00d      	add	sp, #52	; 0x34
 800ba74:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800ba76:	46c0      	nop			; (mov r8, r8)
 800ba78:	0801fa7c 	.word	0x0801fa7c
 800ba7c:	000005a2 	.word	0x000005a2
 800ba80:	0801ff08 	.word	0x0801ff08
 800ba84:	0801fab8 	.word	0x0801fab8
 800ba88:	20002ed8 	.word	0x20002ed8
 800ba8c:	20002ee4 	.word	0x20002ee4
 800ba90:	0801ff38 	.word	0x0801ff38
 800ba94:	000005b4 	.word	0x000005b4
 800ba98:	0801ff60 	.word	0x0801ff60

0800ba9c <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
 800ba9c:	b580      	push	{r7, lr}
 800ba9e:	b082      	sub	sp, #8
 800baa0:	af00      	add	r7, sp, #0
  struct tcp_pcb *pcb;

  ++tcp_timer_ctr;
 800baa2:	4b30      	ldr	r3, [pc, #192]	; (800bb64 <tcp_fasttmr+0xc8>)
 800baa4:	781b      	ldrb	r3, [r3, #0]
 800baa6:	3301      	adds	r3, #1
 800baa8:	b2da      	uxtb	r2, r3
 800baaa:	4b2e      	ldr	r3, [pc, #184]	; (800bb64 <tcp_fasttmr+0xc8>)
 800baac:	701a      	strb	r2, [r3, #0]

tcp_fasttmr_start:
  pcb = tcp_active_pcbs;
 800baae:	4b2e      	ldr	r3, [pc, #184]	; (800bb68 <tcp_fasttmr+0xcc>)
 800bab0:	681b      	ldr	r3, [r3, #0]
 800bab2:	607b      	str	r3, [r7, #4]

  while (pcb != NULL) {
 800bab4:	e04d      	b.n	800bb52 <tcp_fasttmr+0xb6>
    if (pcb->last_timer != tcp_timer_ctr) {
 800bab6:	687b      	ldr	r3, [r7, #4]
 800bab8:	2222      	movs	r2, #34	; 0x22
 800baba:	5c9a      	ldrb	r2, [r3, r2]
 800babc:	4b29      	ldr	r3, [pc, #164]	; (800bb64 <tcp_fasttmr+0xc8>)
 800babe:	781b      	ldrb	r3, [r3, #0]
 800bac0:	429a      	cmp	r2, r3
 800bac2:	d043      	beq.n	800bb4c <tcp_fasttmr+0xb0>
      struct tcp_pcb *next;
      pcb->last_timer = tcp_timer_ctr;
 800bac4:	4b27      	ldr	r3, [pc, #156]	; (800bb64 <tcp_fasttmr+0xc8>)
 800bac6:	7819      	ldrb	r1, [r3, #0]
 800bac8:	687b      	ldr	r3, [r7, #4]
 800baca:	2222      	movs	r2, #34	; 0x22
 800bacc:	5499      	strb	r1, [r3, r2]
      /* send delayed ACKs */
      if (pcb->flags & TF_ACK_DELAY) {
 800bace:	687b      	ldr	r3, [r7, #4]
 800bad0:	8bdb      	ldrh	r3, [r3, #30]
 800bad2:	001a      	movs	r2, r3
 800bad4:	2301      	movs	r3, #1
 800bad6:	4013      	ands	r3, r2
 800bad8:	d011      	beq.n	800bafe <tcp_fasttmr+0x62>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
        tcp_ack_now(pcb);
 800bada:	687b      	ldr	r3, [r7, #4]
 800badc:	8bdb      	ldrh	r3, [r3, #30]
 800bade:	2202      	movs	r2, #2
 800bae0:	4313      	orrs	r3, r2
 800bae2:	b29a      	uxth	r2, r3
 800bae4:	687b      	ldr	r3, [r7, #4]
 800bae6:	83da      	strh	r2, [r3, #30]
        tcp_output(pcb);
 800bae8:	687b      	ldr	r3, [r7, #4]
 800baea:	0018      	movs	r0, r3
 800baec:	f004 ffd0 	bl	8010a90 <tcp_output>
        tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 800baf0:	687b      	ldr	r3, [r7, #4]
 800baf2:	8bdb      	ldrh	r3, [r3, #30]
 800baf4:	2203      	movs	r2, #3
 800baf6:	4393      	bics	r3, r2
 800baf8:	b29a      	uxth	r2, r3
 800bafa:	687b      	ldr	r3, [r7, #4]
 800bafc:	83da      	strh	r2, [r3, #30]
      }
      /* send pending FIN */
      if (pcb->flags & TF_CLOSEPEND) {
 800bafe:	687b      	ldr	r3, [r7, #4]
 800bb00:	8bdb      	ldrh	r3, [r3, #30]
 800bb02:	001a      	movs	r2, r3
 800bb04:	2308      	movs	r3, #8
 800bb06:	4013      	ands	r3, r2
 800bb08:	d00a      	beq.n	800bb20 <tcp_fasttmr+0x84>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: pending FIN\n"));
        tcp_clear_flags(pcb, TF_CLOSEPEND);
 800bb0a:	687b      	ldr	r3, [r7, #4]
 800bb0c:	8bdb      	ldrh	r3, [r3, #30]
 800bb0e:	2208      	movs	r2, #8
 800bb10:	4393      	bics	r3, r2
 800bb12:	b29a      	uxth	r2, r3
 800bb14:	687b      	ldr	r3, [r7, #4]
 800bb16:	83da      	strh	r2, [r3, #30]
        tcp_close_shutdown_fin(pcb);
 800bb18:	687b      	ldr	r3, [r7, #4]
 800bb1a:	0018      	movs	r0, r3
 800bb1c:	f7ff f85a 	bl	800abd4 <tcp_close_shutdown_fin>
      }

      next = pcb->next;
 800bb20:	687b      	ldr	r3, [r7, #4]
 800bb22:	691b      	ldr	r3, [r3, #16]
 800bb24:	603b      	str	r3, [r7, #0]

      /* If there is data which was previously "refused" by upper layer */
      if (pcb->refused_data != NULL) {
 800bb26:	687b      	ldr	r3, [r7, #4]
 800bb28:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800bb2a:	2b00      	cmp	r3, #0
 800bb2c:	d00b      	beq.n	800bb46 <tcp_fasttmr+0xaa>
        tcp_active_pcbs_changed = 0;
 800bb2e:	4b0f      	ldr	r3, [pc, #60]	; (800bb6c <tcp_fasttmr+0xd0>)
 800bb30:	2200      	movs	r2, #0
 800bb32:	701a      	strb	r2, [r3, #0]
        tcp_process_refused_data(pcb);
 800bb34:	687b      	ldr	r3, [r7, #4]
 800bb36:	0018      	movs	r0, r3
 800bb38:	f000 f81a 	bl	800bb70 <tcp_process_refused_data>
        if (tcp_active_pcbs_changed) {
 800bb3c:	4b0b      	ldr	r3, [pc, #44]	; (800bb6c <tcp_fasttmr+0xd0>)
 800bb3e:	781b      	ldrb	r3, [r3, #0]
 800bb40:	2b00      	cmp	r3, #0
 800bb42:	d000      	beq.n	800bb46 <tcp_fasttmr+0xaa>
          /* application callback has changed the pcb list: restart the loop */
          goto tcp_fasttmr_start;
 800bb44:	e7b3      	b.n	800baae <tcp_fasttmr+0x12>
        }
      }
      pcb = next;
 800bb46:	683b      	ldr	r3, [r7, #0]
 800bb48:	607b      	str	r3, [r7, #4]
 800bb4a:	e002      	b.n	800bb52 <tcp_fasttmr+0xb6>
    } else {
      pcb = pcb->next;
 800bb4c:	687b      	ldr	r3, [r7, #4]
 800bb4e:	691b      	ldr	r3, [r3, #16]
 800bb50:	607b      	str	r3, [r7, #4]
  while (pcb != NULL) {
 800bb52:	687b      	ldr	r3, [r7, #4]
 800bb54:	2b00      	cmp	r3, #0
 800bb56:	d1ae      	bne.n	800bab6 <tcp_fasttmr+0x1a>
    }
  }
}
 800bb58:	46c0      	nop			; (mov r8, r8)
 800bb5a:	46c0      	nop			; (mov r8, r8)
 800bb5c:	46bd      	mov	sp, r7
 800bb5e:	b002      	add	sp, #8
 800bb60:	bd80      	pop	{r7, pc}
 800bb62:	46c0      	nop			; (mov r8, r8)
 800bb64:	20001b2a 	.word	0x20001b2a
 800bb68:	20002ed4 	.word	0x20002ed4
 800bb6c:	20002ed0 	.word	0x20002ed0

0800bb70 <tcp_process_refused_data>:
}

/** Pass pcb->refused_data to the recv callback */
err_t
tcp_process_refused_data(struct tcp_pcb *pcb)
{
 800bb70:	b5b0      	push	{r4, r5, r7, lr}
 800bb72:	b084      	sub	sp, #16
 800bb74:	af00      	add	r7, sp, #0
 800bb76:	6078      	str	r0, [r7, #4]
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
  struct pbuf *rest;
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */

  LWIP_ERROR("tcp_process_refused_data: invalid pcb", pcb != NULL, return ERR_ARG);
 800bb78:	687b      	ldr	r3, [r7, #4]
 800bb7a:	2b00      	cmp	r3, #0
 800bb7c:	d106      	bne.n	800bb8c <tcp_process_refused_data+0x1c>
 800bb7e:	4b3e      	ldr	r3, [pc, #248]	; (800bc78 <tcp_process_refused_data+0x108>)
 800bb80:	0018      	movs	r0, r3
 800bb82:	f7f6 feab 	bl	80028dc <app_debug_rtt_raw>
 800bb86:	2310      	movs	r3, #16
 800bb88:	425b      	negs	r3, r3
 800bb8a:	e070      	b.n	800bc6e <tcp_process_refused_data+0xfe>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
  while (pcb->refused_data != NULL)
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
  {
    err_t err;
    u8_t refused_flags = pcb->refused_data->flags;
 800bb8c:	687b      	ldr	r3, [r7, #4]
 800bb8e:	6fda      	ldr	r2, [r3, #124]	; 0x7c
 800bb90:	230e      	movs	r3, #14
 800bb92:	18fb      	adds	r3, r7, r3
 800bb94:	7b52      	ldrb	r2, [r2, #13]
 800bb96:	701a      	strb	r2, [r3, #0]
    /* set pcb->refused_data to NULL in case the callback frees it and then
       closes the pcb */
    struct pbuf *refused_data = pcb->refused_data;
 800bb98:	687b      	ldr	r3, [r7, #4]
 800bb9a:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800bb9c:	60bb      	str	r3, [r7, #8]
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
    pbuf_split_64k(refused_data, &rest);
    pcb->refused_data = rest;
#else /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
    pcb->refused_data = NULL;
 800bb9e:	687b      	ldr	r3, [r7, #4]
 800bba0:	2200      	movs	r2, #0
 800bba2:	67da      	str	r2, [r3, #124]	; 0x7c
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
    /* Notify again application with data previously received. */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
    TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 800bba4:	687b      	ldr	r3, [r7, #4]
 800bba6:	2288      	movs	r2, #136	; 0x88
 800bba8:	589b      	ldr	r3, [r3, r2]
 800bbaa:	2b00      	cmp	r3, #0
 800bbac:	d00d      	beq.n	800bbca <tcp_process_refused_data+0x5a>
 800bbae:	687b      	ldr	r3, [r7, #4]
 800bbb0:	2288      	movs	r2, #136	; 0x88
 800bbb2:	589d      	ldr	r5, [r3, r2]
 800bbb4:	687b      	ldr	r3, [r7, #4]
 800bbb6:	6958      	ldr	r0, [r3, #20]
 800bbb8:	230f      	movs	r3, #15
 800bbba:	18fc      	adds	r4, r7, r3
 800bbbc:	68ba      	ldr	r2, [r7, #8]
 800bbbe:	6879      	ldr	r1, [r7, #4]
 800bbc0:	2300      	movs	r3, #0
 800bbc2:	47a8      	blx	r5
 800bbc4:	0003      	movs	r3, r0
 800bbc6:	7023      	strb	r3, [r4, #0]
 800bbc8:	e009      	b.n	800bbde <tcp_process_refused_data+0x6e>
 800bbca:	230f      	movs	r3, #15
 800bbcc:	18fc      	adds	r4, r7, r3
 800bbce:	68ba      	ldr	r2, [r7, #8]
 800bbd0:	6879      	ldr	r1, [r7, #4]
 800bbd2:	2300      	movs	r3, #0
 800bbd4:	2000      	movs	r0, #0
 800bbd6:	f000 f8b1 	bl	800bd3c <tcp_recv_null>
 800bbda:	0003      	movs	r3, r0
 800bbdc:	7023      	strb	r3, [r4, #0]
    if (err == ERR_OK) {
 800bbde:	230f      	movs	r3, #15
 800bbe0:	18fb      	adds	r3, r7, r3
 800bbe2:	781b      	ldrb	r3, [r3, #0]
 800bbe4:	b25b      	sxtb	r3, r3
 800bbe6:	2b00      	cmp	r3, #0
 800bbe8:	d131      	bne.n	800bc4e <tcp_process_refused_data+0xde>
      /* did refused_data include a FIN? */
      if ((refused_flags & PBUF_FLAG_TCP_FIN)
 800bbea:	230e      	movs	r3, #14
 800bbec:	18fb      	adds	r3, r7, r3
 800bbee:	781b      	ldrb	r3, [r3, #0]
 800bbf0:	2220      	movs	r2, #32
 800bbf2:	4013      	ands	r3, r2
 800bbf4:	d03a      	beq.n	800bc6c <tcp_process_refused_data+0xfc>
          && (rest == NULL)
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
         ) {
        /* correct rcv_wnd as the application won't call tcp_recved()
           for the FIN's seqno */
        if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
 800bbf6:	687b      	ldr	r3, [r7, #4]
 800bbf8:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800bbfa:	2386      	movs	r3, #134	; 0x86
 800bbfc:	00db      	lsls	r3, r3, #3
 800bbfe:	429a      	cmp	r2, r3
 800bc00:	d005      	beq.n	800bc0e <tcp_process_refused_data+0x9e>
          pcb->rcv_wnd++;
 800bc02:	687b      	ldr	r3, [r7, #4]
 800bc04:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 800bc06:	3301      	adds	r3, #1
 800bc08:	b29a      	uxth	r2, r3
 800bc0a:	687b      	ldr	r3, [r7, #4]
 800bc0c:	859a      	strh	r2, [r3, #44]	; 0x2c
        }
        TCP_EVENT_CLOSED(pcb, err);
 800bc0e:	687b      	ldr	r3, [r7, #4]
 800bc10:	2288      	movs	r2, #136	; 0x88
 800bc12:	589b      	ldr	r3, [r3, r2]
 800bc14:	2b00      	cmp	r3, #0
 800bc16:	d00d      	beq.n	800bc34 <tcp_process_refused_data+0xc4>
 800bc18:	687b      	ldr	r3, [r7, #4]
 800bc1a:	2288      	movs	r2, #136	; 0x88
 800bc1c:	589d      	ldr	r5, [r3, r2]
 800bc1e:	687b      	ldr	r3, [r7, #4]
 800bc20:	6958      	ldr	r0, [r3, #20]
 800bc22:	230f      	movs	r3, #15
 800bc24:	18fc      	adds	r4, r7, r3
 800bc26:	6879      	ldr	r1, [r7, #4]
 800bc28:	2300      	movs	r3, #0
 800bc2a:	2200      	movs	r2, #0
 800bc2c:	47a8      	blx	r5
 800bc2e:	0003      	movs	r3, r0
 800bc30:	7023      	strb	r3, [r4, #0]
 800bc32:	e003      	b.n	800bc3c <tcp_process_refused_data+0xcc>
 800bc34:	230f      	movs	r3, #15
 800bc36:	18fb      	adds	r3, r7, r3
 800bc38:	2200      	movs	r2, #0
 800bc3a:	701a      	strb	r2, [r3, #0]
        if (err == ERR_ABRT) {
 800bc3c:	230f      	movs	r3, #15
 800bc3e:	18fb      	adds	r3, r7, r3
 800bc40:	781b      	ldrb	r3, [r3, #0]
 800bc42:	b25b      	sxtb	r3, r3
 800bc44:	330d      	adds	r3, #13
 800bc46:	d111      	bne.n	800bc6c <tcp_process_refused_data+0xfc>
          return ERR_ABRT;
 800bc48:	230d      	movs	r3, #13
 800bc4a:	425b      	negs	r3, r3
 800bc4c:	e00f      	b.n	800bc6e <tcp_process_refused_data+0xfe>
        }
      }
    } else if (err == ERR_ABRT) {
 800bc4e:	230f      	movs	r3, #15
 800bc50:	18fb      	adds	r3, r7, r3
 800bc52:	781b      	ldrb	r3, [r3, #0]
 800bc54:	b25b      	sxtb	r3, r3
 800bc56:	330d      	adds	r3, #13
 800bc58:	d102      	bne.n	800bc60 <tcp_process_refused_data+0xf0>
      /* if err == ERR_ABRT, 'pcb' is already deallocated */
      /* Drop incoming packets because pcb is "full" (only if the incoming
         segment contains data). */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
      return ERR_ABRT;
 800bc5a:	230d      	movs	r3, #13
 800bc5c:	425b      	negs	r3, r3
 800bc5e:	e006      	b.n	800bc6e <tcp_process_refused_data+0xfe>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
      if (rest != NULL) {
        pbuf_cat(refused_data, rest);
      }
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
      pcb->refused_data = refused_data;
 800bc60:	687b      	ldr	r3, [r7, #4]
 800bc62:	68ba      	ldr	r2, [r7, #8]
 800bc64:	67da      	str	r2, [r3, #124]	; 0x7c
      return ERR_INPROGRESS;
 800bc66:	2305      	movs	r3, #5
 800bc68:	425b      	negs	r3, r3
 800bc6a:	e000      	b.n	800bc6e <tcp_process_refused_data+0xfe>
    }
  }
  return ERR_OK;
 800bc6c:	2300      	movs	r3, #0
}
 800bc6e:	0018      	movs	r0, r3
 800bc70:	46bd      	mov	sp, r7
 800bc72:	b004      	add	sp, #16
 800bc74:	bdb0      	pop	{r4, r5, r7, pc}
 800bc76:	46c0      	nop			; (mov r8, r8)
 800bc78:	0801ff88 	.word	0x0801ff88

0800bc7c <tcp_segs_free>:
 *
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
 800bc7c:	b580      	push	{r7, lr}
 800bc7e:	b084      	sub	sp, #16
 800bc80:	af00      	add	r7, sp, #0
 800bc82:	6078      	str	r0, [r7, #4]
  while (seg != NULL) {
 800bc84:	e008      	b.n	800bc98 <tcp_segs_free+0x1c>
    struct tcp_seg *next = seg->next;
 800bc86:	687b      	ldr	r3, [r7, #4]
 800bc88:	681b      	ldr	r3, [r3, #0]
 800bc8a:	60fb      	str	r3, [r7, #12]
    tcp_seg_free(seg);
 800bc8c:	687b      	ldr	r3, [r7, #4]
 800bc8e:	0018      	movs	r0, r3
 800bc90:	f000 f80a 	bl	800bca8 <tcp_seg_free>
    seg = next;
 800bc94:	68fb      	ldr	r3, [r7, #12]
 800bc96:	607b      	str	r3, [r7, #4]
  while (seg != NULL) {
 800bc98:	687b      	ldr	r3, [r7, #4]
 800bc9a:	2b00      	cmp	r3, #0
 800bc9c:	d1f3      	bne.n	800bc86 <tcp_segs_free+0xa>
  }
}
 800bc9e:	46c0      	nop			; (mov r8, r8)
 800bca0:	46c0      	nop			; (mov r8, r8)
 800bca2:	46bd      	mov	sp, r7
 800bca4:	b004      	add	sp, #16
 800bca6:	bd80      	pop	{r7, pc}

0800bca8 <tcp_seg_free>:
 *
 * @param seg single tcp_seg to free
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
 800bca8:	b580      	push	{r7, lr}
 800bcaa:	b082      	sub	sp, #8
 800bcac:	af00      	add	r7, sp, #0
 800bcae:	6078      	str	r0, [r7, #4]
  if (seg != NULL) {
 800bcb0:	687b      	ldr	r3, [r7, #4]
 800bcb2:	2b00      	cmp	r3, #0
 800bcb4:	d00d      	beq.n	800bcd2 <tcp_seg_free+0x2a>
    if (seg->p != NULL) {
 800bcb6:	687b      	ldr	r3, [r7, #4]
 800bcb8:	685b      	ldr	r3, [r3, #4]
 800bcba:	2b00      	cmp	r3, #0
 800bcbc:	d004      	beq.n	800bcc8 <tcp_seg_free+0x20>
      pbuf_free(seg->p);
 800bcbe:	687b      	ldr	r3, [r7, #4]
 800bcc0:	685b      	ldr	r3, [r3, #4]
 800bcc2:	0018      	movs	r0, r3
 800bcc4:	f7fd ff84 	bl	8009bd0 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 800bcc8:	687b      	ldr	r3, [r7, #4]
 800bcca:	0019      	movs	r1, r3
 800bccc:	2003      	movs	r0, #3
 800bcce:	f7fd f88f 	bl	8008df0 <memp_free>
  }
}
 800bcd2:	46c0      	nop			; (mov r8, r8)
 800bcd4:	46bd      	mov	sp, r7
 800bcd6:	b002      	add	sp, #8
 800bcd8:	bd80      	pop	{r7, pc}
	...

0800bcdc <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
 800bcdc:	b580      	push	{r7, lr}
 800bcde:	b084      	sub	sp, #16
 800bce0:	af00      	add	r7, sp, #0
 800bce2:	6078      	str	r0, [r7, #4]
  struct tcp_seg *cseg;

  LWIP_ASSERT("tcp_seg_copy: invalid seg", seg != NULL);
 800bce4:	687b      	ldr	r3, [r7, #4]
 800bce6:	2b00      	cmp	r3, #0
 800bce8:	d105      	bne.n	800bcf6 <tcp_seg_copy+0x1a>
 800bcea:	4b10      	ldr	r3, [pc, #64]	; (800bd2c <tcp_seg_copy+0x50>)
 800bcec:	4a10      	ldr	r2, [pc, #64]	; (800bd30 <tcp_seg_copy+0x54>)
 800bcee:	4911      	ldr	r1, [pc, #68]	; (800bd34 <tcp_seg_copy+0x58>)
 800bcf0:	4811      	ldr	r0, [pc, #68]	; (800bd38 <tcp_seg_copy+0x5c>)
 800bcf2:	f7f6 fdf3 	bl	80028dc <app_debug_rtt_raw>

  cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
 800bcf6:	2003      	movs	r0, #3
 800bcf8:	f7fd f80a 	bl	8008d10 <memp_malloc>
 800bcfc:	0003      	movs	r3, r0
 800bcfe:	60fb      	str	r3, [r7, #12]
  if (cseg == NULL) {
 800bd00:	68fb      	ldr	r3, [r7, #12]
 800bd02:	2b00      	cmp	r3, #0
 800bd04:	d101      	bne.n	800bd0a <tcp_seg_copy+0x2e>
    return NULL;
 800bd06:	2300      	movs	r3, #0
 800bd08:	e00b      	b.n	800bd22 <tcp_seg_copy+0x46>
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg));
 800bd0a:	6879      	ldr	r1, [r7, #4]
 800bd0c:	68fb      	ldr	r3, [r7, #12]
 800bd0e:	2214      	movs	r2, #20
 800bd10:	0018      	movs	r0, r3
 800bd12:	f010 ff65 	bl	801cbe0 <memcpy>
  pbuf_ref(cseg->p);
 800bd16:	68fb      	ldr	r3, [r7, #12]
 800bd18:	685b      	ldr	r3, [r3, #4]
 800bd1a:	0018      	movs	r0, r3
 800bd1c:	f7fe f814 	bl	8009d48 <pbuf_ref>
  return cseg;
 800bd20:	68fb      	ldr	r3, [r7, #12]
}
 800bd22:	0018      	movs	r0, r3
 800bd24:	46bd      	mov	sp, r7
 800bd26:	b004      	add	sp, #16
 800bd28:	bd80      	pop	{r7, pc}
 800bd2a:	46c0      	nop			; (mov r8, r8)
 800bd2c:	0801fa7c 	.word	0x0801fa7c
 800bd30:	00000683 	.word	0x00000683
 800bd34:	0801ffcc 	.word	0x0801ffcc
 800bd38:	0801fab8 	.word	0x0801fab8

0800bd3c <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
 800bd3c:	b580      	push	{r7, lr}
 800bd3e:	b084      	sub	sp, #16
 800bd40:	af00      	add	r7, sp, #0
 800bd42:	60f8      	str	r0, [r7, #12]
 800bd44:	60b9      	str	r1, [r7, #8]
 800bd46:	607a      	str	r2, [r7, #4]
 800bd48:	001a      	movs	r2, r3
 800bd4a:	1cfb      	adds	r3, r7, #3
 800bd4c:	701a      	strb	r2, [r3, #0]
  LWIP_UNUSED_ARG(arg);

  LWIP_ERROR("tcp_recv_null: invalid pcb", pcb != NULL, return ERR_ARG);
 800bd4e:	68bb      	ldr	r3, [r7, #8]
 800bd50:	2b00      	cmp	r3, #0
 800bd52:	d106      	bne.n	800bd62 <tcp_recv_null+0x26>
 800bd54:	4b12      	ldr	r3, [pc, #72]	; (800bda0 <tcp_recv_null+0x64>)
 800bd56:	0018      	movs	r0, r3
 800bd58:	f7f6 fdc0 	bl	80028dc <app_debug_rtt_raw>
 800bd5c:	2310      	movs	r3, #16
 800bd5e:	425b      	negs	r3, r3
 800bd60:	e01a      	b.n	800bd98 <tcp_recv_null+0x5c>

  if (p != NULL) {
 800bd62:	687b      	ldr	r3, [r7, #4]
 800bd64:	2b00      	cmp	r3, #0
 800bd66:	d00b      	beq.n	800bd80 <tcp_recv_null+0x44>
    tcp_recved(pcb, p->tot_len);
 800bd68:	687b      	ldr	r3, [r7, #4]
 800bd6a:	891a      	ldrh	r2, [r3, #8]
 800bd6c:	68bb      	ldr	r3, [r7, #8]
 800bd6e:	0011      	movs	r1, r2
 800bd70:	0018      	movs	r0, r3
 800bd72:	f7ff f907 	bl	800af84 <tcp_recved>
    pbuf_free(p);
 800bd76:	687b      	ldr	r3, [r7, #4]
 800bd78:	0018      	movs	r0, r3
 800bd7a:	f7fd ff29 	bl	8009bd0 <pbuf_free>
 800bd7e:	e00a      	b.n	800bd96 <tcp_recv_null+0x5a>
  } else if (err == ERR_OK) {
 800bd80:	1cfb      	adds	r3, r7, #3
 800bd82:	781b      	ldrb	r3, [r3, #0]
 800bd84:	b25b      	sxtb	r3, r3
 800bd86:	2b00      	cmp	r3, #0
 800bd88:	d105      	bne.n	800bd96 <tcp_recv_null+0x5a>
    return tcp_close(pcb);
 800bd8a:	68bb      	ldr	r3, [r7, #8]
 800bd8c:	0018      	movs	r0, r3
 800bd8e:	f7fe ff9b 	bl	800acc8 <tcp_close>
 800bd92:	0003      	movs	r3, r0
 800bd94:	e000      	b.n	800bd98 <tcp_recv_null+0x5c>
  }
  return ERR_OK;
 800bd96:	2300      	movs	r3, #0
}
 800bd98:	0018      	movs	r0, r3
 800bd9a:	46bd      	mov	sp, r7
 800bd9c:	b004      	add	sp, #16
 800bd9e:	bd80      	pop	{r7, pc}
 800bda0:	0801ffe8 	.word	0x0801ffe8

0800bda4 <tcp_kill_prio>:
 *
 * @param prio minimum priority
 */
static void
tcp_kill_prio(u8_t prio)
{
 800bda4:	b580      	push	{r7, lr}
 800bda6:	b086      	sub	sp, #24
 800bda8:	af00      	add	r7, sp, #0
 800bdaa:	0002      	movs	r2, r0
 800bdac:	1dfb      	adds	r3, r7, #7
 800bdae:	701a      	strb	r2, [r3, #0]
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;

  mprio = LWIP_MIN(TCP_PRIO_MAX, prio);
 800bdb0:	1dfb      	adds	r3, r7, #7
 800bdb2:	781b      	ldrb	r3, [r3, #0]
 800bdb4:	b25b      	sxtb	r3, r3
 800bdb6:	2b00      	cmp	r3, #0
 800bdb8:	db02      	blt.n	800bdc0 <tcp_kill_prio+0x1c>
 800bdba:	1dfb      	adds	r3, r7, #7
 800bdbc:	781a      	ldrb	r2, [r3, #0]
 800bdbe:	e000      	b.n	800bdc2 <tcp_kill_prio+0x1e>
 800bdc0:	227f      	movs	r2, #127	; 0x7f
 800bdc2:	210b      	movs	r1, #11
 800bdc4:	187b      	adds	r3, r7, r1
 800bdc6:	701a      	strb	r2, [r3, #0]

  /* We want to kill connections with a lower prio, so bail out if 
   * supplied prio is 0 - there can never be a lower prio
   */
  if (mprio == 0) {
 800bdc8:	187b      	adds	r3, r7, r1
 800bdca:	781b      	ldrb	r3, [r3, #0]
 800bdcc:	2b00      	cmp	r3, #0
 800bdce:	d03c      	beq.n	800be4a <tcp_kill_prio+0xa6>
  /* We only want kill connections with a lower prio, so decrement prio by one 
   * and start searching for oldest connection with same or lower priority than mprio.
   * We want to find the connections with the lowest possible prio, and among
   * these the one with the longest inactivity time.
   */
  mprio--;
 800bdd0:	187b      	adds	r3, r7, r1
 800bdd2:	781a      	ldrb	r2, [r3, #0]
 800bdd4:	187b      	adds	r3, r7, r1
 800bdd6:	3a01      	subs	r2, #1
 800bdd8:	701a      	strb	r2, [r3, #0]

  inactivity = 0;
 800bdda:	2300      	movs	r3, #0
 800bddc:	60fb      	str	r3, [r7, #12]
  inactive = NULL;
 800bdde:	2300      	movs	r3, #0
 800bde0:	613b      	str	r3, [r7, #16]
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800bde2:	4b1c      	ldr	r3, [pc, #112]	; (800be54 <tcp_kill_prio+0xb0>)
 800bde4:	681b      	ldr	r3, [r3, #0]
 800bde6:	617b      	str	r3, [r7, #20]
 800bde8:	e024      	b.n	800be34 <tcp_kill_prio+0x90>
        /* lower prio is always a kill candidate */
    if ((pcb->prio < mprio) ||
 800bdea:	697b      	ldr	r3, [r7, #20]
 800bdec:	7e5b      	ldrb	r3, [r3, #25]
 800bdee:	210b      	movs	r1, #11
 800bdf0:	187a      	adds	r2, r7, r1
 800bdf2:	7812      	ldrb	r2, [r2, #0]
 800bdf4:	429a      	cmp	r2, r3
 800bdf6:	d80d      	bhi.n	800be14 <tcp_kill_prio+0x70>
        /* longer inactivity is also a kill candidate */
        ((pcb->prio == mprio) && ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity))) {
 800bdf8:	697b      	ldr	r3, [r7, #20]
 800bdfa:	7e5b      	ldrb	r3, [r3, #25]
    if ((pcb->prio < mprio) ||
 800bdfc:	187a      	adds	r2, r7, r1
 800bdfe:	7812      	ldrb	r2, [r2, #0]
 800be00:	429a      	cmp	r2, r3
 800be02:	d114      	bne.n	800be2e <tcp_kill_prio+0x8a>
        ((pcb->prio == mprio) && ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity))) {
 800be04:	4b14      	ldr	r3, [pc, #80]	; (800be58 <tcp_kill_prio+0xb4>)
 800be06:	681a      	ldr	r2, [r3, #0]
 800be08:	697b      	ldr	r3, [r7, #20]
 800be0a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800be0c:	1ad3      	subs	r3, r2, r3
 800be0e:	68fa      	ldr	r2, [r7, #12]
 800be10:	429a      	cmp	r2, r3
 800be12:	d80c      	bhi.n	800be2e <tcp_kill_prio+0x8a>
      inactivity = tcp_ticks - pcb->tmr;
 800be14:	4b10      	ldr	r3, [pc, #64]	; (800be58 <tcp_kill_prio+0xb4>)
 800be16:	681a      	ldr	r2, [r3, #0]
 800be18:	697b      	ldr	r3, [r7, #20]
 800be1a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800be1c:	1ad3      	subs	r3, r2, r3
 800be1e:	60fb      	str	r3, [r7, #12]
      inactive   = pcb;
 800be20:	697b      	ldr	r3, [r7, #20]
 800be22:	613b      	str	r3, [r7, #16]
      mprio      = pcb->prio;
 800be24:	230b      	movs	r3, #11
 800be26:	18fb      	adds	r3, r7, r3
 800be28:	697a      	ldr	r2, [r7, #20]
 800be2a:	7e52      	ldrb	r2, [r2, #25]
 800be2c:	701a      	strb	r2, [r3, #0]
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800be2e:	697b      	ldr	r3, [r7, #20]
 800be30:	691b      	ldr	r3, [r3, #16]
 800be32:	617b      	str	r3, [r7, #20]
 800be34:	697b      	ldr	r3, [r7, #20]
 800be36:	2b00      	cmp	r3, #0
 800be38:	d1d7      	bne.n	800bdea <tcp_kill_prio+0x46>
    }
  }
  if (inactive != NULL) {
 800be3a:	693b      	ldr	r3, [r7, #16]
 800be3c:	2b00      	cmp	r3, #0
 800be3e:	d005      	beq.n	800be4c <tcp_kill_prio+0xa8>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
                            (void *)inactive, inactivity));
    tcp_abort(inactive);
 800be40:	693b      	ldr	r3, [r7, #16]
 800be42:	0018      	movs	r0, r3
 800be44:	f7ff f830 	bl	800aea8 <tcp_abort>
 800be48:	e000      	b.n	800be4c <tcp_kill_prio+0xa8>
    return;
 800be4a:	46c0      	nop			; (mov r8, r8)
  }
}
 800be4c:	46bd      	mov	sp, r7
 800be4e:	b006      	add	sp, #24
 800be50:	bd80      	pop	{r7, pc}
 800be52:	46c0      	nop			; (mov r8, r8)
 800be54:	20002ed4 	.word	0x20002ed4
 800be58:	20002ed8 	.word	0x20002ed8

0800be5c <tcp_kill_state>:
 * Kills the oldest connection that is in specific state.
 * Called from tcp_alloc() for LAST_ACK and CLOSING if no more connections are available.
 */
static void
tcp_kill_state(enum tcp_state state)
{
 800be5c:	b580      	push	{r7, lr}
 800be5e:	b086      	sub	sp, #24
 800be60:	af00      	add	r7, sp, #0
 800be62:	0002      	movs	r2, r0
 800be64:	1dfb      	adds	r3, r7, #7
 800be66:	701a      	strb	r2, [r3, #0]
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  LWIP_ASSERT("invalid state", (state == CLOSING) || (state == LAST_ACK));
 800be68:	1dfb      	adds	r3, r7, #7
 800be6a:	781b      	ldrb	r3, [r3, #0]
 800be6c:	2b08      	cmp	r3, #8
 800be6e:	d009      	beq.n	800be84 <tcp_kill_state+0x28>
 800be70:	1dfb      	adds	r3, r7, #7
 800be72:	781b      	ldrb	r3, [r3, #0]
 800be74:	2b09      	cmp	r3, #9
 800be76:	d005      	beq.n	800be84 <tcp_kill_state+0x28>
 800be78:	4b1a      	ldr	r3, [pc, #104]	; (800bee4 <tcp_kill_state+0x88>)
 800be7a:	4a1b      	ldr	r2, [pc, #108]	; (800bee8 <tcp_kill_state+0x8c>)
 800be7c:	491b      	ldr	r1, [pc, #108]	; (800beec <tcp_kill_state+0x90>)
 800be7e:	481c      	ldr	r0, [pc, #112]	; (800bef0 <tcp_kill_state+0x94>)
 800be80:	f7f6 fd2c 	bl	80028dc <app_debug_rtt_raw>

  inactivity = 0;
 800be84:	2300      	movs	r3, #0
 800be86:	60fb      	str	r3, [r7, #12]
  inactive = NULL;
 800be88:	2300      	movs	r3, #0
 800be8a:	613b      	str	r3, [r7, #16]
  /* Go through the list of active pcbs and get the oldest pcb that is in state
     CLOSING/LAST_ACK. */
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800be8c:	4b19      	ldr	r3, [pc, #100]	; (800bef4 <tcp_kill_state+0x98>)
 800be8e:	681b      	ldr	r3, [r3, #0]
 800be90:	617b      	str	r3, [r7, #20]
 800be92:	e018      	b.n	800bec6 <tcp_kill_state+0x6a>
    if (pcb->state == state) {
 800be94:	697b      	ldr	r3, [r7, #20]
 800be96:	7e1b      	ldrb	r3, [r3, #24]
 800be98:	1dfa      	adds	r2, r7, #7
 800be9a:	7812      	ldrb	r2, [r2, #0]
 800be9c:	429a      	cmp	r2, r3
 800be9e:	d10f      	bne.n	800bec0 <tcp_kill_state+0x64>
      if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 800bea0:	4b15      	ldr	r3, [pc, #84]	; (800bef8 <tcp_kill_state+0x9c>)
 800bea2:	681a      	ldr	r2, [r3, #0]
 800bea4:	697b      	ldr	r3, [r7, #20]
 800bea6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800bea8:	1ad3      	subs	r3, r2, r3
 800beaa:	68fa      	ldr	r2, [r7, #12]
 800beac:	429a      	cmp	r2, r3
 800beae:	d807      	bhi.n	800bec0 <tcp_kill_state+0x64>
        inactivity = tcp_ticks - pcb->tmr;
 800beb0:	4b11      	ldr	r3, [pc, #68]	; (800bef8 <tcp_kill_state+0x9c>)
 800beb2:	681a      	ldr	r2, [r3, #0]
 800beb4:	697b      	ldr	r3, [r7, #20]
 800beb6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800beb8:	1ad3      	subs	r3, r2, r3
 800beba:	60fb      	str	r3, [r7, #12]
        inactive = pcb;
 800bebc:	697b      	ldr	r3, [r7, #20]
 800bebe:	613b      	str	r3, [r7, #16]
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800bec0:	697b      	ldr	r3, [r7, #20]
 800bec2:	691b      	ldr	r3, [r3, #16]
 800bec4:	617b      	str	r3, [r7, #20]
 800bec6:	697b      	ldr	r3, [r7, #20]
 800bec8:	2b00      	cmp	r3, #0
 800beca:	d1e3      	bne.n	800be94 <tcp_kill_state+0x38>
      }
    }
  }
  if (inactive != NULL) {
 800becc:	693b      	ldr	r3, [r7, #16]
 800bece:	2b00      	cmp	r3, #0
 800bed0:	d004      	beq.n	800bedc <tcp_kill_state+0x80>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_closing: killing oldest %s PCB %p (%"S32_F")\n",
                            tcp_state_str[state], (void *)inactive, inactivity));
    /* Don't send a RST, since no data is lost. */
    tcp_abandon(inactive, 0);
 800bed2:	693b      	ldr	r3, [r7, #16]
 800bed4:	2100      	movs	r1, #0
 800bed6:	0018      	movs	r0, r3
 800bed8:	f7fe ff1c 	bl	800ad14 <tcp_abandon>
  }
}
 800bedc:	46c0      	nop			; (mov r8, r8)
 800bede:	46bd      	mov	sp, r7
 800bee0:	b006      	add	sp, #24
 800bee2:	bd80      	pop	{r7, pc}
 800bee4:	0801fa7c 	.word	0x0801fa7c
 800bee8:	000006de 	.word	0x000006de
 800beec:	08020004 	.word	0x08020004
 800bef0:	0801fab8 	.word	0x0801fab8
 800bef4:	20002ed4 	.word	0x20002ed4
 800bef8:	20002ed8 	.word	0x20002ed8

0800befc <tcp_kill_timewait>:
 * Kills the oldest connection that is in TIME_WAIT state.
 * Called from tcp_alloc() if no more connections are available.
 */
static void
tcp_kill_timewait(void)
{
 800befc:	b580      	push	{r7, lr}
 800befe:	b084      	sub	sp, #16
 800bf00:	af00      	add	r7, sp, #0
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
 800bf02:	2300      	movs	r3, #0
 800bf04:	607b      	str	r3, [r7, #4]
  inactive = NULL;
 800bf06:	2300      	movs	r3, #0
 800bf08:	60bb      	str	r3, [r7, #8]
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800bf0a:	4b12      	ldr	r3, [pc, #72]	; (800bf54 <tcp_kill_timewait+0x58>)
 800bf0c:	681b      	ldr	r3, [r3, #0]
 800bf0e:	60fb      	str	r3, [r7, #12]
 800bf10:	e012      	b.n	800bf38 <tcp_kill_timewait+0x3c>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 800bf12:	4b11      	ldr	r3, [pc, #68]	; (800bf58 <tcp_kill_timewait+0x5c>)
 800bf14:	681a      	ldr	r2, [r3, #0]
 800bf16:	68fb      	ldr	r3, [r7, #12]
 800bf18:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800bf1a:	1ad3      	subs	r3, r2, r3
 800bf1c:	687a      	ldr	r2, [r7, #4]
 800bf1e:	429a      	cmp	r2, r3
 800bf20:	d807      	bhi.n	800bf32 <tcp_kill_timewait+0x36>
      inactivity = tcp_ticks - pcb->tmr;
 800bf22:	4b0d      	ldr	r3, [pc, #52]	; (800bf58 <tcp_kill_timewait+0x5c>)
 800bf24:	681a      	ldr	r2, [r3, #0]
 800bf26:	68fb      	ldr	r3, [r7, #12]
 800bf28:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800bf2a:	1ad3      	subs	r3, r2, r3
 800bf2c:	607b      	str	r3, [r7, #4]
      inactive = pcb;
 800bf2e:	68fb      	ldr	r3, [r7, #12]
 800bf30:	60bb      	str	r3, [r7, #8]
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800bf32:	68fb      	ldr	r3, [r7, #12]
 800bf34:	691b      	ldr	r3, [r3, #16]
 800bf36:	60fb      	str	r3, [r7, #12]
 800bf38:	68fb      	ldr	r3, [r7, #12]
 800bf3a:	2b00      	cmp	r3, #0
 800bf3c:	d1e9      	bne.n	800bf12 <tcp_kill_timewait+0x16>
    }
  }
  if (inactive != NULL) {
 800bf3e:	68bb      	ldr	r3, [r7, #8]
 800bf40:	2b00      	cmp	r3, #0
 800bf42:	d003      	beq.n	800bf4c <tcp_kill_timewait+0x50>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
                            (void *)inactive, inactivity));
    tcp_abort(inactive);
 800bf44:	68bb      	ldr	r3, [r7, #8]
 800bf46:	0018      	movs	r0, r3
 800bf48:	f7fe ffae 	bl	800aea8 <tcp_abort>
  }
}
 800bf4c:	46c0      	nop			; (mov r8, r8)
 800bf4e:	46bd      	mov	sp, r7
 800bf50:	b004      	add	sp, #16
 800bf52:	bd80      	pop	{r7, pc}
 800bf54:	20002ee4 	.word	0x20002ee4
 800bf58:	20002ed8 	.word	0x20002ed8

0800bf5c <tcp_handle_closepend>:
 * now send the FIN (which failed before), the pcb might be in a state that is
 * OK for us to now free it.
 */
static void
tcp_handle_closepend(void)
{
 800bf5c:	b580      	push	{r7, lr}
 800bf5e:	b082      	sub	sp, #8
 800bf60:	af00      	add	r7, sp, #0
  struct tcp_pcb *pcb = tcp_active_pcbs;
 800bf62:	4b11      	ldr	r3, [pc, #68]	; (800bfa8 <tcp_handle_closepend+0x4c>)
 800bf64:	681b      	ldr	r3, [r3, #0]
 800bf66:	607b      	str	r3, [r7, #4]

  while (pcb != NULL) {
 800bf68:	e015      	b.n	800bf96 <tcp_handle_closepend+0x3a>
    struct tcp_pcb *next = pcb->next;
 800bf6a:	687b      	ldr	r3, [r7, #4]
 800bf6c:	691b      	ldr	r3, [r3, #16]
 800bf6e:	603b      	str	r3, [r7, #0]
    /* send pending FIN */
    if (pcb->flags & TF_CLOSEPEND) {
 800bf70:	687b      	ldr	r3, [r7, #4]
 800bf72:	8bdb      	ldrh	r3, [r3, #30]
 800bf74:	001a      	movs	r2, r3
 800bf76:	2308      	movs	r3, #8
 800bf78:	4013      	ands	r3, r2
 800bf7a:	d00a      	beq.n	800bf92 <tcp_handle_closepend+0x36>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_handle_closepend: pending FIN\n"));
      tcp_clear_flags(pcb, TF_CLOSEPEND);
 800bf7c:	687b      	ldr	r3, [r7, #4]
 800bf7e:	8bdb      	ldrh	r3, [r3, #30]
 800bf80:	2208      	movs	r2, #8
 800bf82:	4393      	bics	r3, r2
 800bf84:	b29a      	uxth	r2, r3
 800bf86:	687b      	ldr	r3, [r7, #4]
 800bf88:	83da      	strh	r2, [r3, #30]
      tcp_close_shutdown_fin(pcb);
 800bf8a:	687b      	ldr	r3, [r7, #4]
 800bf8c:	0018      	movs	r0, r3
 800bf8e:	f7fe fe21 	bl	800abd4 <tcp_close_shutdown_fin>
    }
    pcb = next;
 800bf92:	683b      	ldr	r3, [r7, #0]
 800bf94:	607b      	str	r3, [r7, #4]
  while (pcb != NULL) {
 800bf96:	687b      	ldr	r3, [r7, #4]
 800bf98:	2b00      	cmp	r3, #0
 800bf9a:	d1e6      	bne.n	800bf6a <tcp_handle_closepend+0xe>
  }
}
 800bf9c:	46c0      	nop			; (mov r8, r8)
 800bf9e:	46c0      	nop			; (mov r8, r8)
 800bfa0:	46bd      	mov	sp, r7
 800bfa2:	b002      	add	sp, #8
 800bfa4:	bd80      	pop	{r7, pc}
 800bfa6:	46c0      	nop			; (mov r8, r8)
 800bfa8:	20002ed4 	.word	0x20002ed4

0800bfac <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
 800bfac:	b580      	push	{r7, lr}
 800bfae:	b084      	sub	sp, #16
 800bfb0:	af00      	add	r7, sp, #0
 800bfb2:	0002      	movs	r2, r0
 800bfb4:	1dfb      	adds	r3, r7, #7
 800bfb6:	701a      	strb	r2, [r3, #0]
  struct tcp_pcb *pcb;

  LWIP_ASSERT_CORE_LOCKED();

  pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800bfb8:	2001      	movs	r0, #1
 800bfba:	f7fc fea9 	bl	8008d10 <memp_malloc>
 800bfbe:	0003      	movs	r3, r0
 800bfc0:	60fb      	str	r3, [r7, #12]
  if (pcb == NULL) {
 800bfc2:	68fb      	ldr	r3, [r7, #12]
 800bfc4:	2b00      	cmp	r3, #0
 800bfc6:	d12b      	bne.n	800c020 <tcp_alloc+0x74>
    /* Try to send FIN for all pcbs stuck in TF_CLOSEPEND first */
    tcp_handle_closepend();
 800bfc8:	f7ff ffc8 	bl	800bf5c <tcp_handle_closepend>

    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
 800bfcc:	f7ff ff96 	bl	800befc <tcp_kill_timewait>
    /* Try to allocate a tcp_pcb again. */
    pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800bfd0:	2001      	movs	r0, #1
 800bfd2:	f7fc fe9d 	bl	8008d10 <memp_malloc>
 800bfd6:	0003      	movs	r3, r0
 800bfd8:	60fb      	str	r3, [r7, #12]
    if (pcb == NULL) {
 800bfda:	68fb      	ldr	r3, [r7, #12]
 800bfdc:	2b00      	cmp	r3, #0
 800bfde:	d11f      	bne.n	800c020 <tcp_alloc+0x74>
      /* Try killing oldest connection in LAST-ACK (these wouldn't go to TIME-WAIT). */
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest LAST-ACK connection\n"));
      tcp_kill_state(LAST_ACK);
 800bfe0:	2009      	movs	r0, #9
 800bfe2:	f7ff ff3b 	bl	800be5c <tcp_kill_state>
      /* Try to allocate a tcp_pcb again. */
      pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800bfe6:	2001      	movs	r0, #1
 800bfe8:	f7fc fe92 	bl	8008d10 <memp_malloc>
 800bfec:	0003      	movs	r3, r0
 800bfee:	60fb      	str	r3, [r7, #12]
      if (pcb == NULL) {
 800bff0:	68fb      	ldr	r3, [r7, #12]
 800bff2:	2b00      	cmp	r3, #0
 800bff4:	d114      	bne.n	800c020 <tcp_alloc+0x74>
        /* Try killing oldest connection in CLOSING. */
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest CLOSING connection\n"));
        tcp_kill_state(CLOSING);
 800bff6:	2008      	movs	r0, #8
 800bff8:	f7ff ff30 	bl	800be5c <tcp_kill_state>
        /* Try to allocate a tcp_pcb again. */
        pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800bffc:	2001      	movs	r0, #1
 800bffe:	f7fc fe87 	bl	8008d10 <memp_malloc>
 800c002:	0003      	movs	r3, r0
 800c004:	60fb      	str	r3, [r7, #12]
        if (pcb == NULL) {
 800c006:	68fb      	ldr	r3, [r7, #12]
 800c008:	2b00      	cmp	r3, #0
 800c00a:	d109      	bne.n	800c020 <tcp_alloc+0x74>
          /* Try killing oldest active connection with lower priority than the new one. */
          LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing oldest connection with prio lower than %d\n", prio));
          tcp_kill_prio(prio);
 800c00c:	1dfb      	adds	r3, r7, #7
 800c00e:	781b      	ldrb	r3, [r3, #0]
 800c010:	0018      	movs	r0, r3
 800c012:	f7ff fec7 	bl	800bda4 <tcp_kill_prio>
          /* Try to allocate a tcp_pcb again. */
          pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800c016:	2001      	movs	r0, #1
 800c018:	f7fc fe7a 	bl	8008d10 <memp_malloc>
 800c01c:	0003      	movs	r3, r0
 800c01e:	60fb      	str	r3, [r7, #12]
    if (pcb != NULL) {
      /* adjust err stats: memp_malloc failed above */
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
    }
  }
  if (pcb != NULL) {
 800c020:	68fb      	ldr	r3, [r7, #12]
 800c022:	2b00      	cmp	r3, #0
 800c024:	d04c      	beq.n	800c0c0 <tcp_alloc+0x114>
    /* zero out the whole pcb, so there is no need to initialize members to zero */
    memset(pcb, 0, sizeof(struct tcp_pcb));
 800c026:	68fb      	ldr	r3, [r7, #12]
 800c028:	22a8      	movs	r2, #168	; 0xa8
 800c02a:	2100      	movs	r1, #0
 800c02c:	0018      	movs	r0, r3
 800c02e:	f010 fdf3 	bl	801cc18 <memset>
    pcb->prio = prio;
 800c032:	68fb      	ldr	r3, [r7, #12]
 800c034:	1dfa      	adds	r2, r7, #7
 800c036:	7812      	ldrb	r2, [r2, #0]
 800c038:	765a      	strb	r2, [r3, #25]
    pcb->snd_buf = TCP_SND_BUF;
 800c03a:	68fb      	ldr	r3, [r7, #12]
 800c03c:	2268      	movs	r2, #104	; 0x68
 800c03e:	2186      	movs	r1, #134	; 0x86
 800c040:	00c9      	lsls	r1, r1, #3
 800c042:	5299      	strh	r1, [r3, r2]
    /* Start with a window that does not need scaling. When window scaling is
       enabled and used, the window is enlarged when both sides agree on scaling. */
    pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
 800c044:	68fb      	ldr	r3, [r7, #12]
 800c046:	2286      	movs	r2, #134	; 0x86
 800c048:	00d2      	lsls	r2, r2, #3
 800c04a:	85da      	strh	r2, [r3, #46]	; 0x2e
 800c04c:	68fb      	ldr	r3, [r7, #12]
 800c04e:	8dda      	ldrh	r2, [r3, #46]	; 0x2e
 800c050:	68fb      	ldr	r3, [r7, #12]
 800c052:	859a      	strh	r2, [r3, #44]	; 0x2c
    pcb->ttl = TCP_TTL;
 800c054:	68fb      	ldr	r3, [r7, #12]
 800c056:	22ff      	movs	r2, #255	; 0xff
 800c058:	72da      	strb	r2, [r3, #11]
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = INITIAL_MSS;
 800c05a:	68fb      	ldr	r3, [r7, #12]
 800c05c:	2286      	movs	r2, #134	; 0x86
 800c05e:	0092      	lsls	r2, r2, #2
 800c060:	86da      	strh	r2, [r3, #54]	; 0x36
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
 800c062:	68fb      	ldr	r3, [r7, #12]
 800c064:	2244      	movs	r2, #68	; 0x44
 800c066:	2103      	movs	r1, #3
 800c068:	5299      	strh	r1, [r3, r2]
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
 800c06a:	68fb      	ldr	r3, [r7, #12]
 800c06c:	2242      	movs	r2, #66	; 0x42
 800c06e:	2103      	movs	r1, #3
 800c070:	5299      	strh	r1, [r3, r2]
    pcb->rtime = -1;
 800c072:	68fb      	ldr	r3, [r7, #12]
 800c074:	2201      	movs	r2, #1
 800c076:	4252      	negs	r2, r2
 800c078:	869a      	strh	r2, [r3, #52]	; 0x34
    pcb->cwnd = 1;
 800c07a:	68fb      	ldr	r3, [r7, #12]
 800c07c:	224c      	movs	r2, #76	; 0x4c
 800c07e:	2101      	movs	r1, #1
 800c080:	5299      	strh	r1, [r3, r2]
    pcb->tmr = tcp_ticks;
 800c082:	4b12      	ldr	r3, [pc, #72]	; (800c0cc <tcp_alloc+0x120>)
 800c084:	681a      	ldr	r2, [r3, #0]
 800c086:	68fb      	ldr	r3, [r7, #12]
 800c088:	625a      	str	r2, [r3, #36]	; 0x24
    pcb->last_timer = tcp_timer_ctr;
 800c08a:	4b11      	ldr	r3, [pc, #68]	; (800c0d0 <tcp_alloc+0x124>)
 800c08c:	7819      	ldrb	r1, [r3, #0]
 800c08e:	68fb      	ldr	r3, [r7, #12]
 800c090:	2222      	movs	r2, #34	; 0x22
 800c092:	5499      	strb	r1, [r3, r2]
    of using the largest advertised receive window.  We've seen complications with
    receiving TCPs that use window scaling and/or window auto-tuning where the
    initial advertised window is very small and then grows rapidly once the
    connection is established. To avoid these complications, we set ssthresh to the
    largest effective cwnd (amount of in-flight data) that the sender can have. */
    pcb->ssthresh = TCP_SND_BUF;
 800c094:	68fb      	ldr	r3, [r7, #12]
 800c096:	224e      	movs	r2, #78	; 0x4e
 800c098:	2186      	movs	r1, #134	; 0x86
 800c09a:	00c9      	lsls	r1, r1, #3
 800c09c:	5299      	strh	r1, [r3, r2]

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
 800c09e:	68fb      	ldr	r3, [r7, #12]
 800c0a0:	2188      	movs	r1, #136	; 0x88
 800c0a2:	4a0c      	ldr	r2, [pc, #48]	; (800c0d4 <tcp_alloc+0x128>)
 800c0a4:	505a      	str	r2, [r3, r1]
#endif /* LWIP_CALLBACK_API */

    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
 800c0a6:	68fb      	ldr	r3, [r7, #12]
 800c0a8:	2298      	movs	r2, #152	; 0x98
 800c0aa:	490b      	ldr	r1, [pc, #44]	; (800c0d8 <tcp_alloc+0x12c>)
 800c0ac:	5099      	str	r1, [r3, r2]

#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
 800c0ae:	68fb      	ldr	r3, [r7, #12]
 800c0b0:	219c      	movs	r1, #156	; 0x9c
 800c0b2:	22fa      	movs	r2, #250	; 0xfa
 800c0b4:	00d2      	lsls	r2, r2, #3
 800c0b6:	505a      	str	r2, [r3, r1]
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
 800c0b8:	68fb      	ldr	r3, [r7, #12]
 800c0ba:	22a0      	movs	r2, #160	; 0xa0
 800c0bc:	2109      	movs	r1, #9
 800c0be:	5099      	str	r1, [r3, r2]
#endif /* LWIP_TCP_KEEPALIVE */
  }
  return pcb;
 800c0c0:	68fb      	ldr	r3, [r7, #12]
}
 800c0c2:	0018      	movs	r0, r3
 800c0c4:	46bd      	mov	sp, r7
 800c0c6:	b004      	add	sp, #16
 800c0c8:	bd80      	pop	{r7, pc}
 800c0ca:	46c0      	nop			; (mov r8, r8)
 800c0cc:	20002ed8 	.word	0x20002ed8
 800c0d0:	20001b2a 	.word	0x20001b2a
 800c0d4:	0800bd3d 	.word	0x0800bd3d
 800c0d8:	00002710 	.word	0x00002710

0800c0dc <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
 800c0dc:	b580      	push	{r7, lr}
 800c0de:	af00      	add	r7, sp, #0
  return tcp_alloc(TCP_PRIO_NORMAL);
 800c0e0:	2040      	movs	r0, #64	; 0x40
 800c0e2:	f7ff ff63 	bl	800bfac <tcp_alloc>
 800c0e6:	0003      	movs	r3, r0
}
 800c0e8:	0018      	movs	r0, r3
 800c0ea:	46bd      	mov	sp, r7
 800c0ec:	bd80      	pop	{r7, pc}

0800c0ee <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{
 800c0ee:	b580      	push	{r7, lr}
 800c0f0:	b082      	sub	sp, #8
 800c0f2:	af00      	add	r7, sp, #0
 800c0f4:	6078      	str	r0, [r7, #4]
 800c0f6:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT_CORE_LOCKED();
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  if (pcb != NULL) {
 800c0f8:	687b      	ldr	r3, [r7, #4]
 800c0fa:	2b00      	cmp	r3, #0
 800c0fc:	d002      	beq.n	800c104 <tcp_arg+0x16>
    pcb->callback_arg = arg;
 800c0fe:	687b      	ldr	r3, [r7, #4]
 800c100:	683a      	ldr	r2, [r7, #0]
 800c102:	615a      	str	r2, [r3, #20]
  }
}
 800c104:	46c0      	nop			; (mov r8, r8)
 800c106:	46bd      	mov	sp, r7
 800c108:	b002      	add	sp, #8
 800c10a:	bd80      	pop	{r7, pc}

0800c10c <tcp_recv>:
 * @param pcb tcp_pcb to set the recv callback
 * @param recv callback function to call for this pcb when data is received
 */
void
tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
 800c10c:	b580      	push	{r7, lr}
 800c10e:	b082      	sub	sp, #8
 800c110:	af00      	add	r7, sp, #0
 800c112:	6078      	str	r0, [r7, #4]
 800c114:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb != NULL) {
 800c116:	687b      	ldr	r3, [r7, #4]
 800c118:	2b00      	cmp	r3, #0
 800c11a:	d00d      	beq.n	800c138 <tcp_recv+0x2c>
    LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
 800c11c:	687b      	ldr	r3, [r7, #4]
 800c11e:	7e1b      	ldrb	r3, [r3, #24]
 800c120:	2b01      	cmp	r3, #1
 800c122:	d105      	bne.n	800c130 <tcp_recv+0x24>
 800c124:	4b06      	ldr	r3, [pc, #24]	; (800c140 <tcp_recv+0x34>)
 800c126:	4a07      	ldr	r2, [pc, #28]	; (800c144 <tcp_recv+0x38>)
 800c128:	4907      	ldr	r1, [pc, #28]	; (800c148 <tcp_recv+0x3c>)
 800c12a:	4808      	ldr	r0, [pc, #32]	; (800c14c <tcp_recv+0x40>)
 800c12c:	f7f6 fbd6 	bl	80028dc <app_debug_rtt_raw>
    pcb->recv = recv;
 800c130:	687b      	ldr	r3, [r7, #4]
 800c132:	2188      	movs	r1, #136	; 0x88
 800c134:	683a      	ldr	r2, [r7, #0]
 800c136:	505a      	str	r2, [r3, r1]
  }
}
 800c138:	46c0      	nop			; (mov r8, r8)
 800c13a:	46bd      	mov	sp, r7
 800c13c:	b002      	add	sp, #8
 800c13e:	bd80      	pop	{r7, pc}
 800c140:	0801fa7c 	.word	0x0801fa7c
 800c144:	000007e2 	.word	0x000007e2
 800c148:	08020014 	.word	0x08020014
 800c14c:	0801fab8 	.word	0x0801fab8

0800c150 <tcp_sent>:
 * @param pcb tcp_pcb to set the sent callback
 * @param sent callback function to call for this pcb when data is successfully sent
 */
void
tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
 800c150:	b580      	push	{r7, lr}
 800c152:	b082      	sub	sp, #8
 800c154:	af00      	add	r7, sp, #0
 800c156:	6078      	str	r0, [r7, #4]
 800c158:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb != NULL) {
 800c15a:	687b      	ldr	r3, [r7, #4]
 800c15c:	2b00      	cmp	r3, #0
 800c15e:	d00d      	beq.n	800c17c <tcp_sent+0x2c>
    LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
 800c160:	687b      	ldr	r3, [r7, #4]
 800c162:	7e1b      	ldrb	r3, [r3, #24]
 800c164:	2b01      	cmp	r3, #1
 800c166:	d105      	bne.n	800c174 <tcp_sent+0x24>
 800c168:	4b06      	ldr	r3, [pc, #24]	; (800c184 <tcp_sent+0x34>)
 800c16a:	4a07      	ldr	r2, [pc, #28]	; (800c188 <tcp_sent+0x38>)
 800c16c:	4907      	ldr	r1, [pc, #28]	; (800c18c <tcp_sent+0x3c>)
 800c16e:	4808      	ldr	r0, [pc, #32]	; (800c190 <tcp_sent+0x40>)
 800c170:	f7f6 fbb4 	bl	80028dc <app_debug_rtt_raw>
    pcb->sent = sent;
 800c174:	687b      	ldr	r3, [r7, #4]
 800c176:	2184      	movs	r1, #132	; 0x84
 800c178:	683a      	ldr	r2, [r7, #0]
 800c17a:	505a      	str	r2, [r3, r1]
  }
}
 800c17c:	46c0      	nop			; (mov r8, r8)
 800c17e:	46bd      	mov	sp, r7
 800c180:	b002      	add	sp, #8
 800c182:	bd80      	pop	{r7, pc}
 800c184:	0801fa7c 	.word	0x0801fa7c
 800c188:	000007f6 	.word	0x000007f6
 800c18c:	0802003c 	.word	0x0802003c
 800c190:	0801fab8 	.word	0x0801fab8

0800c194 <tcp_err>:
 * @param err callback function to call for this pcb when a fatal error
 *        has occurred on the connection
 */
void
tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
 800c194:	b580      	push	{r7, lr}
 800c196:	b082      	sub	sp, #8
 800c198:	af00      	add	r7, sp, #0
 800c19a:	6078      	str	r0, [r7, #4]
 800c19c:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb != NULL) {
 800c19e:	687b      	ldr	r3, [r7, #4]
 800c1a0:	2b00      	cmp	r3, #0
 800c1a2:	d00e      	beq.n	800c1c2 <tcp_err+0x2e>
    LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
 800c1a4:	687b      	ldr	r3, [r7, #4]
 800c1a6:	7e1b      	ldrb	r3, [r3, #24]
 800c1a8:	2b01      	cmp	r3, #1
 800c1aa:	d106      	bne.n	800c1ba <tcp_err+0x26>
 800c1ac:	4b07      	ldr	r3, [pc, #28]	; (800c1cc <tcp_err+0x38>)
 800c1ae:	2281      	movs	r2, #129	; 0x81
 800c1b0:	0112      	lsls	r2, r2, #4
 800c1b2:	4907      	ldr	r1, [pc, #28]	; (800c1d0 <tcp_err+0x3c>)
 800c1b4:	4807      	ldr	r0, [pc, #28]	; (800c1d4 <tcp_err+0x40>)
 800c1b6:	f7f6 fb91 	bl	80028dc <app_debug_rtt_raw>
    pcb->errf = err;
 800c1ba:	687b      	ldr	r3, [r7, #4]
 800c1bc:	2194      	movs	r1, #148	; 0x94
 800c1be:	683a      	ldr	r2, [r7, #0]
 800c1c0:	505a      	str	r2, [r3, r1]
  }
}
 800c1c2:	46c0      	nop			; (mov r8, r8)
 800c1c4:	46bd      	mov	sp, r7
 800c1c6:	b002      	add	sp, #8
 800c1c8:	bd80      	pop	{r7, pc}
 800c1ca:	46c0      	nop			; (mov r8, r8)
 800c1cc:	0801fa7c 	.word	0x0801fa7c
 800c1d0:	08020064 	.word	0x08020064
 800c1d4:	0801fab8 	.word	0x0801fab8

0800c1d8 <tcp_poll>:
 * the application may use the polling functionality to call tcp_write()
 * again when the connection has been idle for a while.
 */
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
 800c1d8:	b580      	push	{r7, lr}
 800c1da:	b084      	sub	sp, #16
 800c1dc:	af00      	add	r7, sp, #0
 800c1de:	60f8      	str	r0, [r7, #12]
 800c1e0:	60b9      	str	r1, [r7, #8]
 800c1e2:	1dfb      	adds	r3, r7, #7
 800c1e4:	701a      	strb	r2, [r3, #0]
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_poll: invalid pcb", pcb != NULL, return);
 800c1e6:	68fb      	ldr	r3, [r7, #12]
 800c1e8:	2b00      	cmp	r3, #0
 800c1ea:	d104      	bne.n	800c1f6 <tcp_poll+0x1e>
 800c1ec:	4b0d      	ldr	r3, [pc, #52]	; (800c224 <tcp_poll+0x4c>)
 800c1ee:	0018      	movs	r0, r3
 800c1f0:	f7f6 fb74 	bl	80028dc <app_debug_rtt_raw>
 800c1f4:	e012      	b.n	800c21c <tcp_poll+0x44>
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
 800c1f6:	68fb      	ldr	r3, [r7, #12]
 800c1f8:	7e1b      	ldrb	r3, [r3, #24]
 800c1fa:	2b01      	cmp	r3, #1
 800c1fc:	d105      	bne.n	800c20a <tcp_poll+0x32>
 800c1fe:	4b0a      	ldr	r3, [pc, #40]	; (800c228 <tcp_poll+0x50>)
 800c200:	4a0a      	ldr	r2, [pc, #40]	; (800c22c <tcp_poll+0x54>)
 800c202:	490b      	ldr	r1, [pc, #44]	; (800c230 <tcp_poll+0x58>)
 800c204:	480b      	ldr	r0, [pc, #44]	; (800c234 <tcp_poll+0x5c>)
 800c206:	f7f6 fb69 	bl	80028dc <app_debug_rtt_raw>

#if LWIP_CALLBACK_API
  pcb->poll = poll;
 800c20a:	68fb      	ldr	r3, [r7, #12]
 800c20c:	2190      	movs	r1, #144	; 0x90
 800c20e:	68ba      	ldr	r2, [r7, #8]
 800c210:	505a      	str	r2, [r3, r1]
#else /* LWIP_CALLBACK_API */
  LWIP_UNUSED_ARG(poll);
#endif /* LWIP_CALLBACK_API */
  pcb->pollinterval = interval;
 800c212:	68fb      	ldr	r3, [r7, #12]
 800c214:	1dfa      	adds	r2, r7, #7
 800c216:	2121      	movs	r1, #33	; 0x21
 800c218:	7812      	ldrb	r2, [r2, #0]
 800c21a:	545a      	strb	r2, [r3, r1]
}
 800c21c:	46bd      	mov	sp, r7
 800c21e:	b004      	add	sp, #16
 800c220:	bd80      	pop	{r7, pc}
 800c222:	46c0      	nop			; (mov r8, r8)
 800c224:	0802008c 	.word	0x0802008c
 800c228:	0801fa7c 	.word	0x0801fa7c
 800c22c:	00000842 	.word	0x00000842
 800c230:	080200a4 	.word	0x080200a4
 800c234:	0801fab8 	.word	0x0801fab8

0800c238 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
 800c238:	b580      	push	{r7, lr}
 800c23a:	b082      	sub	sp, #8
 800c23c:	af00      	add	r7, sp, #0
 800c23e:	6078      	str	r0, [r7, #4]
  LWIP_ERROR("tcp_pcb_purge: invalid pcb", pcb != NULL, return);
 800c240:	687b      	ldr	r3, [r7, #4]
 800c242:	2b00      	cmp	r3, #0
 800c244:	d104      	bne.n	800c250 <tcp_pcb_purge+0x18>
 800c246:	4b20      	ldr	r3, [pc, #128]	; (800c2c8 <tcp_pcb_purge+0x90>)
 800c248:	0018      	movs	r0, r3
 800c24a:	f7f6 fb47 	bl	80028dc <app_debug_rtt_raw>
 800c24e:	e038      	b.n	800c2c2 <tcp_pcb_purge+0x8a>

  if (pcb->state != CLOSED &&
 800c250:	687b      	ldr	r3, [r7, #4]
 800c252:	7e1b      	ldrb	r3, [r3, #24]
 800c254:	2b00      	cmp	r3, #0
 800c256:	d034      	beq.n	800c2c2 <tcp_pcb_purge+0x8a>
      pcb->state != TIME_WAIT &&
 800c258:	687b      	ldr	r3, [r7, #4]
 800c25a:	7e1b      	ldrb	r3, [r3, #24]
  if (pcb->state != CLOSED &&
 800c25c:	2b0a      	cmp	r3, #10
 800c25e:	d030      	beq.n	800c2c2 <tcp_pcb_purge+0x8a>
      pcb->state != LISTEN) {
 800c260:	687b      	ldr	r3, [r7, #4]
 800c262:	7e1b      	ldrb	r3, [r3, #24]
      pcb->state != TIME_WAIT &&
 800c264:	2b01      	cmp	r3, #1
 800c266:	d02c      	beq.n	800c2c2 <tcp_pcb_purge+0x8a>

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    tcp_backlog_accepted(pcb);

    if (pcb->refused_data != NULL) {
 800c268:	687b      	ldr	r3, [r7, #4]
 800c26a:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800c26c:	2b00      	cmp	r3, #0
 800c26e:	d007      	beq.n	800c280 <tcp_pcb_purge+0x48>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
 800c270:	687b      	ldr	r3, [r7, #4]
 800c272:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800c274:	0018      	movs	r0, r3
 800c276:	f7fd fcab 	bl	8009bd0 <pbuf_free>
      pcb->refused_data = NULL;
 800c27a:	687b      	ldr	r3, [r7, #4]
 800c27c:	2200      	movs	r2, #0
 800c27e:	67da      	str	r2, [r3, #124]	; 0x7c
    }
    if (pcb->unacked != NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->unacked\n"));
    }
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
 800c280:	687b      	ldr	r3, [r7, #4]
 800c282:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800c284:	2b00      	cmp	r3, #0
 800c286:	d003      	beq.n	800c290 <tcp_pcb_purge+0x58>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
      tcp_free_ooseq(pcb);
 800c288:	687b      	ldr	r3, [r7, #4]
 800c28a:	0018      	movs	r0, r3
 800c28c:	f000 f9a4 	bl	800c5d8 <tcp_free_ooseq>
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
 800c290:	687b      	ldr	r3, [r7, #4]
 800c292:	2201      	movs	r2, #1
 800c294:	4252      	negs	r2, r2
 800c296:	869a      	strh	r2, [r3, #52]	; 0x34

    tcp_segs_free(pcb->unsent);
 800c298:	687b      	ldr	r3, [r7, #4]
 800c29a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800c29c:	0018      	movs	r0, r3
 800c29e:	f7ff fced 	bl	800bc7c <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
 800c2a2:	687b      	ldr	r3, [r7, #4]
 800c2a4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800c2a6:	0018      	movs	r0, r3
 800c2a8:	f7ff fce8 	bl	800bc7c <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
 800c2ac:	687b      	ldr	r3, [r7, #4]
 800c2ae:	2200      	movs	r2, #0
 800c2b0:	671a      	str	r2, [r3, #112]	; 0x70
 800c2b2:	687b      	ldr	r3, [r7, #4]
 800c2b4:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800c2b6:	687b      	ldr	r3, [r7, #4]
 800c2b8:	675a      	str	r2, [r3, #116]	; 0x74
#if TCP_OVERSIZE
    pcb->unsent_oversize = 0;
 800c2ba:	687b      	ldr	r3, [r7, #4]
 800c2bc:	226c      	movs	r2, #108	; 0x6c
 800c2be:	2100      	movs	r1, #0
 800c2c0:	5299      	strh	r1, [r3, r2]
#endif /* TCP_OVERSIZE */
  }
}
 800c2c2:	46bd      	mov	sp, r7
 800c2c4:	b002      	add	sp, #8
 800c2c6:	bd80      	pop	{r7, pc}
 800c2c8:	080200c4 	.word	0x080200c4

0800c2cc <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
 800c2cc:	b580      	push	{r7, lr}
 800c2ce:	b084      	sub	sp, #16
 800c2d0:	af00      	add	r7, sp, #0
 800c2d2:	6078      	str	r0, [r7, #4]
 800c2d4:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT("tcp_pcb_remove: invalid pcb", pcb != NULL);
 800c2d6:	683b      	ldr	r3, [r7, #0]
 800c2d8:	2b00      	cmp	r3, #0
 800c2da:	d105      	bne.n	800c2e8 <tcp_pcb_remove+0x1c>
 800c2dc:	4b3c      	ldr	r3, [pc, #240]	; (800c3d0 <tcp_pcb_remove+0x104>)
 800c2de:	4a3d      	ldr	r2, [pc, #244]	; (800c3d4 <tcp_pcb_remove+0x108>)
 800c2e0:	493d      	ldr	r1, [pc, #244]	; (800c3d8 <tcp_pcb_remove+0x10c>)
 800c2e2:	483e      	ldr	r0, [pc, #248]	; (800c3dc <tcp_pcb_remove+0x110>)
 800c2e4:	f7f6 fafa 	bl	80028dc <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_pcb_remove: invalid pcblist", pcblist != NULL);
 800c2e8:	687b      	ldr	r3, [r7, #4]
 800c2ea:	2b00      	cmp	r3, #0
 800c2ec:	d105      	bne.n	800c2fa <tcp_pcb_remove+0x2e>
 800c2ee:	4b38      	ldr	r3, [pc, #224]	; (800c3d0 <tcp_pcb_remove+0x104>)
 800c2f0:	4a3b      	ldr	r2, [pc, #236]	; (800c3e0 <tcp_pcb_remove+0x114>)
 800c2f2:	493c      	ldr	r1, [pc, #240]	; (800c3e4 <tcp_pcb_remove+0x118>)
 800c2f4:	4839      	ldr	r0, [pc, #228]	; (800c3dc <tcp_pcb_remove+0x110>)
 800c2f6:	f7f6 faf1 	bl	80028dc <app_debug_rtt_raw>

  TCP_RMV(pcblist, pcb);
 800c2fa:	687b      	ldr	r3, [r7, #4]
 800c2fc:	681b      	ldr	r3, [r3, #0]
 800c2fe:	683a      	ldr	r2, [r7, #0]
 800c300:	429a      	cmp	r2, r3
 800c302:	d105      	bne.n	800c310 <tcp_pcb_remove+0x44>
 800c304:	687b      	ldr	r3, [r7, #4]
 800c306:	681b      	ldr	r3, [r3, #0]
 800c308:	691a      	ldr	r2, [r3, #16]
 800c30a:	687b      	ldr	r3, [r7, #4]
 800c30c:	601a      	str	r2, [r3, #0]
 800c30e:	e013      	b.n	800c338 <tcp_pcb_remove+0x6c>
 800c310:	687b      	ldr	r3, [r7, #4]
 800c312:	681b      	ldr	r3, [r3, #0]
 800c314:	60fb      	str	r3, [r7, #12]
 800c316:	e00c      	b.n	800c332 <tcp_pcb_remove+0x66>
 800c318:	68fb      	ldr	r3, [r7, #12]
 800c31a:	691b      	ldr	r3, [r3, #16]
 800c31c:	683a      	ldr	r2, [r7, #0]
 800c31e:	429a      	cmp	r2, r3
 800c320:	d104      	bne.n	800c32c <tcp_pcb_remove+0x60>
 800c322:	683b      	ldr	r3, [r7, #0]
 800c324:	691a      	ldr	r2, [r3, #16]
 800c326:	68fb      	ldr	r3, [r7, #12]
 800c328:	611a      	str	r2, [r3, #16]
 800c32a:	e005      	b.n	800c338 <tcp_pcb_remove+0x6c>
 800c32c:	68fb      	ldr	r3, [r7, #12]
 800c32e:	691b      	ldr	r3, [r3, #16]
 800c330:	60fb      	str	r3, [r7, #12]
 800c332:	68fb      	ldr	r3, [r7, #12]
 800c334:	2b00      	cmp	r3, #0
 800c336:	d1ef      	bne.n	800c318 <tcp_pcb_remove+0x4c>
 800c338:	683b      	ldr	r3, [r7, #0]
 800c33a:	2200      	movs	r2, #0
 800c33c:	611a      	str	r2, [r3, #16]

  tcp_pcb_purge(pcb);
 800c33e:	683b      	ldr	r3, [r7, #0]
 800c340:	0018      	movs	r0, r3
 800c342:	f7ff ff79 	bl	800c238 <tcp_pcb_purge>

  /* if there is an outstanding delayed ACKs, send it */
  if ((pcb->state != TIME_WAIT) &&
 800c346:	683b      	ldr	r3, [r7, #0]
 800c348:	7e1b      	ldrb	r3, [r3, #24]
 800c34a:	2b0a      	cmp	r3, #10
 800c34c:	d014      	beq.n	800c378 <tcp_pcb_remove+0xac>
      (pcb->state != LISTEN) &&
 800c34e:	683b      	ldr	r3, [r7, #0]
 800c350:	7e1b      	ldrb	r3, [r3, #24]
  if ((pcb->state != TIME_WAIT) &&
 800c352:	2b01      	cmp	r3, #1
 800c354:	d010      	beq.n	800c378 <tcp_pcb_remove+0xac>
      (pcb->flags & TF_ACK_DELAY)) {
 800c356:	683b      	ldr	r3, [r7, #0]
 800c358:	8bdb      	ldrh	r3, [r3, #30]
 800c35a:	001a      	movs	r2, r3
 800c35c:	2301      	movs	r3, #1
 800c35e:	4013      	ands	r3, r2
      (pcb->state != LISTEN) &&
 800c360:	d00a      	beq.n	800c378 <tcp_pcb_remove+0xac>
    tcp_ack_now(pcb);
 800c362:	683b      	ldr	r3, [r7, #0]
 800c364:	8bdb      	ldrh	r3, [r3, #30]
 800c366:	2202      	movs	r2, #2
 800c368:	4313      	orrs	r3, r2
 800c36a:	b29a      	uxth	r2, r3
 800c36c:	683b      	ldr	r3, [r7, #0]
 800c36e:	83da      	strh	r2, [r3, #30]
    tcp_output(pcb);
 800c370:	683b      	ldr	r3, [r7, #0]
 800c372:	0018      	movs	r0, r3
 800c374:	f004 fb8c 	bl	8010a90 <tcp_output>
  }

  if (pcb->state != LISTEN) {
 800c378:	683b      	ldr	r3, [r7, #0]
 800c37a:	7e1b      	ldrb	r3, [r3, #24]
 800c37c:	2b01      	cmp	r3, #1
 800c37e:	d01d      	beq.n	800c3bc <tcp_pcb_remove+0xf0>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
 800c380:	683b      	ldr	r3, [r7, #0]
 800c382:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800c384:	2b00      	cmp	r3, #0
 800c386:	d005      	beq.n	800c394 <tcp_pcb_remove+0xc8>
 800c388:	4b11      	ldr	r3, [pc, #68]	; (800c3d0 <tcp_pcb_remove+0x104>)
 800c38a:	4a17      	ldr	r2, [pc, #92]	; (800c3e8 <tcp_pcb_remove+0x11c>)
 800c38c:	4917      	ldr	r1, [pc, #92]	; (800c3ec <tcp_pcb_remove+0x120>)
 800c38e:	4813      	ldr	r0, [pc, #76]	; (800c3dc <tcp_pcb_remove+0x110>)
 800c390:	f7f6 faa4 	bl	80028dc <app_debug_rtt_raw>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
 800c394:	683b      	ldr	r3, [r7, #0]
 800c396:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800c398:	2b00      	cmp	r3, #0
 800c39a:	d005      	beq.n	800c3a8 <tcp_pcb_remove+0xdc>
 800c39c:	4b0c      	ldr	r3, [pc, #48]	; (800c3d0 <tcp_pcb_remove+0x104>)
 800c39e:	4a14      	ldr	r2, [pc, #80]	; (800c3f0 <tcp_pcb_remove+0x124>)
 800c3a0:	4914      	ldr	r1, [pc, #80]	; (800c3f4 <tcp_pcb_remove+0x128>)
 800c3a2:	480e      	ldr	r0, [pc, #56]	; (800c3dc <tcp_pcb_remove+0x110>)
 800c3a4:	f7f6 fa9a 	bl	80028dc <app_debug_rtt_raw>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
 800c3a8:	683b      	ldr	r3, [r7, #0]
 800c3aa:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800c3ac:	2b00      	cmp	r3, #0
 800c3ae:	d005      	beq.n	800c3bc <tcp_pcb_remove+0xf0>
 800c3b0:	4b07      	ldr	r3, [pc, #28]	; (800c3d0 <tcp_pcb_remove+0x104>)
 800c3b2:	4a11      	ldr	r2, [pc, #68]	; (800c3f8 <tcp_pcb_remove+0x12c>)
 800c3b4:	4911      	ldr	r1, [pc, #68]	; (800c3fc <tcp_pcb_remove+0x130>)
 800c3b6:	4809      	ldr	r0, [pc, #36]	; (800c3dc <tcp_pcb_remove+0x110>)
 800c3b8:	f7f6 fa90 	bl	80028dc <app_debug_rtt_raw>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
 800c3bc:	683b      	ldr	r3, [r7, #0]
 800c3be:	2200      	movs	r2, #0
 800c3c0:	761a      	strb	r2, [r3, #24]
  /* reset the local port to prevent the pcb from being 'bound' */
  pcb->local_port = 0;
 800c3c2:	683b      	ldr	r3, [r7, #0]
 800c3c4:	2200      	movs	r2, #0
 800c3c6:	835a      	strh	r2, [r3, #26]

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
 800c3c8:	46c0      	nop			; (mov r8, r8)
 800c3ca:	46bd      	mov	sp, r7
 800c3cc:	b004      	add	sp, #16
 800c3ce:	bd80      	pop	{r7, pc}
 800c3d0:	0801fa7c 	.word	0x0801fa7c
 800c3d4:	00000887 	.word	0x00000887
 800c3d8:	080200e0 	.word	0x080200e0
 800c3dc:	0801fab8 	.word	0x0801fab8
 800c3e0:	00000888 	.word	0x00000888
 800c3e4:	080200fc 	.word	0x080200fc
 800c3e8:	00000897 	.word	0x00000897
 800c3ec:	0802011c 	.word	0x0802011c
 800c3f0:	00000898 	.word	0x00000898
 800c3f4:	08020134 	.word	0x08020134
 800c3f8:	0000089a 	.word	0x0000089a
 800c3fc:	08020150 	.word	0x08020150

0800c400 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(struct tcp_pcb *pcb)
{
 800c400:	b580      	push	{r7, lr}
 800c402:	b082      	sub	sp, #8
 800c404:	af00      	add	r7, sp, #0
 800c406:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_next_iss: invalid pcb", pcb != NULL);
  return LWIP_HOOK_TCP_ISN(&pcb->local_ip, pcb->local_port, &pcb->remote_ip, pcb->remote_port);
#else /* LWIP_HOOK_TCP_ISN */
  static u32_t iss = 6510;

  LWIP_ASSERT("tcp_next_iss: invalid pcb", pcb != NULL);
 800c408:	687b      	ldr	r3, [r7, #4]
 800c40a:	2b00      	cmp	r3, #0
 800c40c:	d105      	bne.n	800c41a <tcp_next_iss+0x1a>
 800c40e:	4b09      	ldr	r3, [pc, #36]	; (800c434 <tcp_next_iss+0x34>)
 800c410:	4a09      	ldr	r2, [pc, #36]	; (800c438 <tcp_next_iss+0x38>)
 800c412:	490a      	ldr	r1, [pc, #40]	; (800c43c <tcp_next_iss+0x3c>)
 800c414:	480a      	ldr	r0, [pc, #40]	; (800c440 <tcp_next_iss+0x40>)
 800c416:	f7f6 fa61 	bl	80028dc <app_debug_rtt_raw>
  LWIP_UNUSED_ARG(pcb);

  iss += tcp_ticks;       /* XXX */
 800c41a:	4b0a      	ldr	r3, [pc, #40]	; (800c444 <tcp_next_iss+0x44>)
 800c41c:	681a      	ldr	r2, [r3, #0]
 800c41e:	4b0a      	ldr	r3, [pc, #40]	; (800c448 <tcp_next_iss+0x48>)
 800c420:	681b      	ldr	r3, [r3, #0]
 800c422:	18d2      	adds	r2, r2, r3
 800c424:	4b07      	ldr	r3, [pc, #28]	; (800c444 <tcp_next_iss+0x44>)
 800c426:	601a      	str	r2, [r3, #0]
  return iss;
 800c428:	4b06      	ldr	r3, [pc, #24]	; (800c444 <tcp_next_iss+0x44>)
 800c42a:	681b      	ldr	r3, [r3, #0]
#endif /* LWIP_HOOK_TCP_ISN */
}
 800c42c:	0018      	movs	r0, r3
 800c42e:	46bd      	mov	sp, r7
 800c430:	b002      	add	sp, #8
 800c432:	bd80      	pop	{r7, pc}
 800c434:	0801fa7c 	.word	0x0801fa7c
 800c438:	000008b3 	.word	0x000008b3
 800c43c:	08020168 	.word	0x08020168
 800c440:	0801fab8 	.word	0x0801fab8
 800c444:	2000001c 	.word	0x2000001c
 800c448:	20002ed8 	.word	0x20002ed8

0800c44c <tcp_eff_send_mss_netif>:
 * by calculating the minimum of TCP_MSS and the mtu (if set) of the target
 * netif (if not NULL).
 */
u16_t
tcp_eff_send_mss_netif(u16_t sendmss, struct netif *outif, const ip_addr_t *dest)
{
 800c44c:	b590      	push	{r4, r7, lr}
 800c44e:	b087      	sub	sp, #28
 800c450:	af00      	add	r7, sp, #0
 800c452:	60b9      	str	r1, [r7, #8]
 800c454:	607a      	str	r2, [r7, #4]
 800c456:	230e      	movs	r3, #14
 800c458:	18fb      	adds	r3, r7, r3
 800c45a:	1c02      	adds	r2, r0, #0
 800c45c:	801a      	strh	r2, [r3, #0]
  u16_t mss_s;
  u16_t mtu;

  LWIP_UNUSED_ARG(dest); /* in case IPv6 is disabled */

  LWIP_ASSERT("tcp_eff_send_mss_netif: invalid dst_ip", dest != NULL);
 800c45e:	687b      	ldr	r3, [r7, #4]
 800c460:	2b00      	cmp	r3, #0
 800c462:	d105      	bne.n	800c470 <tcp_eff_send_mss_netif+0x24>
 800c464:	4b1e      	ldr	r3, [pc, #120]	; (800c4e0 <tcp_eff_send_mss_netif+0x94>)
 800c466:	4a1f      	ldr	r2, [pc, #124]	; (800c4e4 <tcp_eff_send_mss_netif+0x98>)
 800c468:	491f      	ldr	r1, [pc, #124]	; (800c4e8 <tcp_eff_send_mss_netif+0x9c>)
 800c46a:	4820      	ldr	r0, [pc, #128]	; (800c4ec <tcp_eff_send_mss_netif+0xa0>)
 800c46c:	f7f6 fa36 	bl	80028dc <app_debug_rtt_raw>
  else
#endif /* LWIP_IPV4 */
#endif /* LWIP_IPV6 */
#if LWIP_IPV4
  {
    if (outif == NULL) {
 800c470:	68bb      	ldr	r3, [r7, #8]
 800c472:	2b00      	cmp	r3, #0
 800c474:	d103      	bne.n	800c47e <tcp_eff_send_mss_netif+0x32>
      return sendmss;
 800c476:	230e      	movs	r3, #14
 800c478:	18fb      	adds	r3, r7, r3
 800c47a:	881b      	ldrh	r3, [r3, #0]
 800c47c:	e02c      	b.n	800c4d8 <tcp_eff_send_mss_netif+0x8c>
    }
    mtu = outif->mtu;
 800c47e:	2116      	movs	r1, #22
 800c480:	187b      	adds	r3, r7, r1
 800c482:	68ba      	ldr	r2, [r7, #8]
 800c484:	8d12      	ldrh	r2, [r2, #40]	; 0x28
 800c486:	801a      	strh	r2, [r3, #0]
  }
#endif /* LWIP_IPV4 */

  if (mtu != 0) {
 800c488:	187b      	adds	r3, r7, r1
 800c48a:	881b      	ldrh	r3, [r3, #0]
 800c48c:	2b00      	cmp	r3, #0
 800c48e:	d020      	beq.n	800c4d2 <tcp_eff_send_mss_netif+0x86>
    else
#endif /* LWIP_IPV4 */
#endif /* LWIP_IPV6 */
#if LWIP_IPV4
    {
      offset = IP_HLEN + TCP_HLEN;
 800c490:	2014      	movs	r0, #20
 800c492:	183b      	adds	r3, r7, r0
 800c494:	2228      	movs	r2, #40	; 0x28
 800c496:	801a      	strh	r2, [r3, #0]
    }
#endif /* LWIP_IPV4 */
    mss_s = (mtu > offset) ? (u16_t)(mtu - offset) : 0;
 800c498:	187a      	adds	r2, r7, r1
 800c49a:	183b      	adds	r3, r7, r0
 800c49c:	8812      	ldrh	r2, [r2, #0]
 800c49e:	881b      	ldrh	r3, [r3, #0]
 800c4a0:	429a      	cmp	r2, r3
 800c4a2:	d906      	bls.n	800c4b2 <tcp_eff_send_mss_netif+0x66>
 800c4a4:	187a      	adds	r2, r7, r1
 800c4a6:	183b      	adds	r3, r7, r0
 800c4a8:	8812      	ldrh	r2, [r2, #0]
 800c4aa:	881b      	ldrh	r3, [r3, #0]
 800c4ac:	1ad3      	subs	r3, r2, r3
 800c4ae:	b29a      	uxth	r2, r3
 800c4b0:	e000      	b.n	800c4b4 <tcp_eff_send_mss_netif+0x68>
 800c4b2:	2200      	movs	r2, #0
 800c4b4:	2112      	movs	r1, #18
 800c4b6:	187b      	adds	r3, r7, r1
 800c4b8:	801a      	strh	r2, [r3, #0]
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * We correct for TCP options in tcp_write(), and don't support IP options.
     */
    sendmss = LWIP_MIN(sendmss, mss_s);
 800c4ba:	200e      	movs	r0, #14
 800c4bc:	183a      	adds	r2, r7, r0
 800c4be:	187b      	adds	r3, r7, r1
 800c4c0:	1839      	adds	r1, r7, r0
 800c4c2:	880c      	ldrh	r4, [r1, #0]
 800c4c4:	881b      	ldrh	r3, [r3, #0]
 800c4c6:	b298      	uxth	r0, r3
 800c4c8:	b2a1      	uxth	r1, r4
 800c4ca:	4288      	cmp	r0, r1
 800c4cc:	d900      	bls.n	800c4d0 <tcp_eff_send_mss_netif+0x84>
 800c4ce:	1c23      	adds	r3, r4, #0
 800c4d0:	8013      	strh	r3, [r2, #0]
  }
  return sendmss;
 800c4d2:	230e      	movs	r3, #14
 800c4d4:	18fb      	adds	r3, r7, r3
 800c4d6:	881b      	ldrh	r3, [r3, #0]
}
 800c4d8:	0018      	movs	r0, r3
 800c4da:	46bd      	mov	sp, r7
 800c4dc:	b007      	add	sp, #28
 800c4de:	bd90      	pop	{r4, r7, pc}
 800c4e0:	0801fa7c 	.word	0x0801fa7c
 800c4e4:	000008c9 	.word	0x000008c9
 800c4e8:	08020184 	.word	0x08020184
 800c4ec:	0801fab8 	.word	0x0801fab8

0800c4f0 <tcp_netif_ip_addr_changed_pcblist>:
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

/** Helper function for tcp_netif_ip_addr_changed() that iterates a pcb list */
static void
tcp_netif_ip_addr_changed_pcblist(const ip_addr_t *old_addr, struct tcp_pcb *pcb_list)
{
 800c4f0:	b580      	push	{r7, lr}
 800c4f2:	b084      	sub	sp, #16
 800c4f4:	af00      	add	r7, sp, #0
 800c4f6:	6078      	str	r0, [r7, #4]
 800c4f8:	6039      	str	r1, [r7, #0]
  struct tcp_pcb *pcb;
  pcb = pcb_list;
 800c4fa:	683b      	ldr	r3, [r7, #0]
 800c4fc:	60fb      	str	r3, [r7, #12]

  LWIP_ASSERT("tcp_netif_ip_addr_changed_pcblist: invalid old_addr", old_addr != NULL);
 800c4fe:	687b      	ldr	r3, [r7, #4]
 800c500:	2b00      	cmp	r3, #0
 800c502:	d119      	bne.n	800c538 <tcp_netif_ip_addr_changed_pcblist+0x48>
 800c504:	4b10      	ldr	r3, [pc, #64]	; (800c548 <tcp_netif_ip_addr_changed_pcblist+0x58>)
 800c506:	4a11      	ldr	r2, [pc, #68]	; (800c54c <tcp_netif_ip_addr_changed_pcblist+0x5c>)
 800c508:	4911      	ldr	r1, [pc, #68]	; (800c550 <tcp_netif_ip_addr_changed_pcblist+0x60>)
 800c50a:	4812      	ldr	r0, [pc, #72]	; (800c554 <tcp_netif_ip_addr_changed_pcblist+0x64>)
 800c50c:	f7f6 f9e6 	bl	80028dc <app_debug_rtt_raw>

  while (pcb != NULL) {
 800c510:	e012      	b.n	800c538 <tcp_netif_ip_addr_changed_pcblist+0x48>
    /* PCB bound to current local interface address? */
    if (ip_addr_cmp(&pcb->local_ip, old_addr)
 800c512:	68fb      	ldr	r3, [r7, #12]
 800c514:	681a      	ldr	r2, [r3, #0]
 800c516:	687b      	ldr	r3, [r7, #4]
 800c518:	681b      	ldr	r3, [r3, #0]
 800c51a:	429a      	cmp	r2, r3
 800c51c:	d109      	bne.n	800c532 <tcp_netif_ip_addr_changed_pcblist+0x42>
        /* connections to link-local addresses must persist (RFC3927 ch. 1.9) */
        && (!IP_IS_V4_VAL(pcb->local_ip) || !ip4_addr_islinklocal(ip_2_ip4(&pcb->local_ip)))
#endif /* LWIP_AUTOIP */
       ) {
      /* this connection must be aborted */
      struct tcp_pcb *next = pcb->next;
 800c51e:	68fb      	ldr	r3, [r7, #12]
 800c520:	691b      	ldr	r3, [r3, #16]
 800c522:	60bb      	str	r3, [r7, #8]
      LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
      tcp_abort(pcb);
 800c524:	68fb      	ldr	r3, [r7, #12]
 800c526:	0018      	movs	r0, r3
 800c528:	f7fe fcbe 	bl	800aea8 <tcp_abort>
      pcb = next;
 800c52c:	68bb      	ldr	r3, [r7, #8]
 800c52e:	60fb      	str	r3, [r7, #12]
 800c530:	e002      	b.n	800c538 <tcp_netif_ip_addr_changed_pcblist+0x48>
    } else {
      pcb = pcb->next;
 800c532:	68fb      	ldr	r3, [r7, #12]
 800c534:	691b      	ldr	r3, [r3, #16]
 800c536:	60fb      	str	r3, [r7, #12]
  while (pcb != NULL) {
 800c538:	68fb      	ldr	r3, [r7, #12]
 800c53a:	2b00      	cmp	r3, #0
 800c53c:	d1e9      	bne.n	800c512 <tcp_netif_ip_addr_changed_pcblist+0x22>
    }
  }
}
 800c53e:	46c0      	nop			; (mov r8, r8)
 800c540:	46c0      	nop			; (mov r8, r8)
 800c542:	46bd      	mov	sp, r7
 800c544:	b004      	add	sp, #16
 800c546:	bd80      	pop	{r7, pc}
 800c548:	0801fa7c 	.word	0x0801fa7c
 800c54c:	00000904 	.word	0x00000904
 800c550:	080201ac 	.word	0x080201ac
 800c554:	0801fab8 	.word	0x0801fab8

0800c558 <tcp_netif_ip_addr_changed>:
 * @param old_addr IP address of the netif before change
 * @param new_addr IP address of the netif after change or NULL if netif has been removed
 */
void
tcp_netif_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_addr)
{
 800c558:	b580      	push	{r7, lr}
 800c55a:	b084      	sub	sp, #16
 800c55c:	af00      	add	r7, sp, #0
 800c55e:	6078      	str	r0, [r7, #4]
 800c560:	6039      	str	r1, [r7, #0]
  struct tcp_pcb_listen *lpcb;

  if (!ip_addr_isany(old_addr)) {
 800c562:	687b      	ldr	r3, [r7, #4]
 800c564:	2b00      	cmp	r3, #0
 800c566:	d02c      	beq.n	800c5c2 <tcp_netif_ip_addr_changed+0x6a>
 800c568:	687b      	ldr	r3, [r7, #4]
 800c56a:	681b      	ldr	r3, [r3, #0]
 800c56c:	2b00      	cmp	r3, #0
 800c56e:	d028      	beq.n	800c5c2 <tcp_netif_ip_addr_changed+0x6a>
    tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_active_pcbs);
 800c570:	4b16      	ldr	r3, [pc, #88]	; (800c5cc <tcp_netif_ip_addr_changed+0x74>)
 800c572:	681a      	ldr	r2, [r3, #0]
 800c574:	687b      	ldr	r3, [r7, #4]
 800c576:	0011      	movs	r1, r2
 800c578:	0018      	movs	r0, r3
 800c57a:	f7ff ffb9 	bl	800c4f0 <tcp_netif_ip_addr_changed_pcblist>
    tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_bound_pcbs);
 800c57e:	4b14      	ldr	r3, [pc, #80]	; (800c5d0 <tcp_netif_ip_addr_changed+0x78>)
 800c580:	681a      	ldr	r2, [r3, #0]
 800c582:	687b      	ldr	r3, [r7, #4]
 800c584:	0011      	movs	r1, r2
 800c586:	0018      	movs	r0, r3
 800c588:	f7ff ffb2 	bl	800c4f0 <tcp_netif_ip_addr_changed_pcblist>

    if (!ip_addr_isany(new_addr)) {
 800c58c:	683b      	ldr	r3, [r7, #0]
 800c58e:	2b00      	cmp	r3, #0
 800c590:	d017      	beq.n	800c5c2 <tcp_netif_ip_addr_changed+0x6a>
 800c592:	683b      	ldr	r3, [r7, #0]
 800c594:	681b      	ldr	r3, [r3, #0]
 800c596:	2b00      	cmp	r3, #0
 800c598:	d013      	beq.n	800c5c2 <tcp_netif_ip_addr_changed+0x6a>
      /* PCB bound to current local interface address? */
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 800c59a:	4b0e      	ldr	r3, [pc, #56]	; (800c5d4 <tcp_netif_ip_addr_changed+0x7c>)
 800c59c:	681b      	ldr	r3, [r3, #0]
 800c59e:	60fb      	str	r3, [r7, #12]
 800c5a0:	e00c      	b.n	800c5bc <tcp_netif_ip_addr_changed+0x64>
        /* PCB bound to current local interface address? */
        if (ip_addr_cmp(&lpcb->local_ip, old_addr)) {
 800c5a2:	68fb      	ldr	r3, [r7, #12]
 800c5a4:	681a      	ldr	r2, [r3, #0]
 800c5a6:	687b      	ldr	r3, [r7, #4]
 800c5a8:	681b      	ldr	r3, [r3, #0]
 800c5aa:	429a      	cmp	r2, r3
 800c5ac:	d103      	bne.n	800c5b6 <tcp_netif_ip_addr_changed+0x5e>
          /* The PCB is listening to the old ipaddr and
            * is set to listen to the new one instead */
          ip_addr_copy(lpcb->local_ip, *new_addr);
 800c5ae:	683b      	ldr	r3, [r7, #0]
 800c5b0:	681a      	ldr	r2, [r3, #0]
 800c5b2:	68fb      	ldr	r3, [r7, #12]
 800c5b4:	601a      	str	r2, [r3, #0]
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 800c5b6:	68fb      	ldr	r3, [r7, #12]
 800c5b8:	691b      	ldr	r3, [r3, #16]
 800c5ba:	60fb      	str	r3, [r7, #12]
 800c5bc:	68fb      	ldr	r3, [r7, #12]
 800c5be:	2b00      	cmp	r3, #0
 800c5c0:	d1ef      	bne.n	800c5a2 <tcp_netif_ip_addr_changed+0x4a>
        }
      }
    }
  }
}
 800c5c2:	46c0      	nop			; (mov r8, r8)
 800c5c4:	46bd      	mov	sp, r7
 800c5c6:	b004      	add	sp, #16
 800c5c8:	bd80      	pop	{r7, pc}
 800c5ca:	46c0      	nop			; (mov r8, r8)
 800c5cc:	20002ed4 	.word	0x20002ed4
 800c5d0:	20002ee0 	.word	0x20002ee0
 800c5d4:	20002edc 	.word	0x20002edc

0800c5d8 <tcp_free_ooseq>:

#if TCP_QUEUE_OOSEQ
/* Free all ooseq pbufs (and possibly reset SACK state) */
void
tcp_free_ooseq(struct tcp_pcb *pcb)
{
 800c5d8:	b580      	push	{r7, lr}
 800c5da:	b082      	sub	sp, #8
 800c5dc:	af00      	add	r7, sp, #0
 800c5de:	6078      	str	r0, [r7, #4]
  if (pcb->ooseq) {
 800c5e0:	687b      	ldr	r3, [r7, #4]
 800c5e2:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800c5e4:	2b00      	cmp	r3, #0
 800c5e6:	d007      	beq.n	800c5f8 <tcp_free_ooseq+0x20>
    tcp_segs_free(pcb->ooseq);
 800c5e8:	687b      	ldr	r3, [r7, #4]
 800c5ea:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800c5ec:	0018      	movs	r0, r3
 800c5ee:	f7ff fb45 	bl	800bc7c <tcp_segs_free>
    pcb->ooseq = NULL;
 800c5f2:	687b      	ldr	r3, [r7, #4]
 800c5f4:	2200      	movs	r2, #0
 800c5f6:	679a      	str	r2, [r3, #120]	; 0x78
#if LWIP_TCP_SACK_OUT
    memset(pcb->rcv_sacks, 0, sizeof(pcb->rcv_sacks));
#endif /* LWIP_TCP_SACK_OUT */
  }
}
 800c5f8:	46c0      	nop			; (mov r8, r8)
 800c5fa:	46bd      	mov	sp, r7
 800c5fc:	b002      	add	sp, #8
 800c5fe:	bd80      	pop	{r7, pc}

0800c600 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the TCP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
 800c600:	b5f0      	push	{r4, r5, r6, r7, lr}
 800c602:	b08f      	sub	sp, #60	; 0x3c
 800c604:	af04      	add	r7, sp, #16
 800c606:	6078      	str	r0, [r7, #4]
 800c608:	6039      	str	r1, [r7, #0]
  struct tcp_pcb *pcb, *prev;
  struct tcp_pcb_listen *lpcb;
#if SO_REUSE
  struct tcp_pcb *lpcb_prev = NULL;
 800c60a:	2300      	movs	r3, #0
 800c60c:	61bb      	str	r3, [r7, #24]
  struct tcp_pcb_listen *lpcb_any = NULL;
 800c60e:	2300      	movs	r3, #0
 800c610:	617b      	str	r3, [r7, #20]
  u8_t hdrlen_bytes;
  err_t err;

  LWIP_UNUSED_ARG(inp);
  LWIP_ASSERT_CORE_LOCKED();
  LWIP_ASSERT("tcp_input: invalid pbuf", p != NULL);
 800c612:	687b      	ldr	r3, [r7, #4]
 800c614:	2b00      	cmp	r3, #0
 800c616:	d105      	bne.n	800c624 <tcp_input+0x24>
 800c618:	4b3a      	ldr	r3, [pc, #232]	; (800c704 <tcp_input+0x104>)
 800c61a:	493b      	ldr	r1, [pc, #236]	; (800c708 <tcp_input+0x108>)
 800c61c:	483b      	ldr	r0, [pc, #236]	; (800c70c <tcp_input+0x10c>)
 800c61e:	2283      	movs	r2, #131	; 0x83
 800c620:	f7f6 f95c 	bl	80028dc <app_debug_rtt_raw>
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  MIB2_STATS_INC(mib2.tcpinsegs);

  tcphdr = (struct tcp_hdr *)p->payload;
 800c624:	687b      	ldr	r3, [r7, #4]
 800c626:	685a      	ldr	r2, [r3, #4]
 800c628:	4b39      	ldr	r3, [pc, #228]	; (800c710 <tcp_input+0x110>)
 800c62a:	601a      	str	r2, [r3, #0]
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* Check that TCP header fits in payload */
  if (p->len < TCP_HLEN) {
 800c62c:	687b      	ldr	r3, [r7, #4]
 800c62e:	895b      	ldrh	r3, [r3, #10]
 800c630:	2b13      	cmp	r3, #19
 800c632:	d801      	bhi.n	800c638 <tcp_input+0x38>
 800c634:	f000 fd03 	bl	800d03e <tcp_input+0xa3e>
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||
 800c638:	4b36      	ldr	r3, [pc, #216]	; (800c714 <tcp_input+0x114>)
 800c63a:	695a      	ldr	r2, [r3, #20]
 800c63c:	4b35      	ldr	r3, [pc, #212]	; (800c714 <tcp_input+0x114>)
 800c63e:	681b      	ldr	r3, [r3, #0]
 800c640:	0019      	movs	r1, r3
 800c642:	0010      	movs	r0, r2
 800c644:	f007 fa74 	bl	8013b30 <ip4_addr_isbroadcast_u32>
 800c648:	1e03      	subs	r3, r0, #0
 800c64a:	d001      	beq.n	800c650 <tcp_input+0x50>
 800c64c:	f000 fcf9 	bl	800d042 <tcp_input+0xa42>
      ip_addr_ismulticast(ip_current_dest_addr())) {
 800c650:	4b30      	ldr	r3, [pc, #192]	; (800c714 <tcp_input+0x114>)
 800c652:	695b      	ldr	r3, [r3, #20]
 800c654:	22f0      	movs	r2, #240	; 0xf0
 800c656:	4013      	ands	r3, r2
  if (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||
 800c658:	2be0      	cmp	r3, #224	; 0xe0
 800c65a:	d101      	bne.n	800c660 <tcp_input+0x60>
 800c65c:	f000 fcf1 	bl	800d042 <tcp_input+0xa42>
  }

#if CHECKSUM_CHECK_TCP
  IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_TCP) {
    /* Verify TCP checksum. */
    u16_t chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
 800c660:	687b      	ldr	r3, [r7, #4]
 800c662:	891a      	ldrh	r2, [r3, #8]
 800c664:	2510      	movs	r5, #16
 800c666:	197c      	adds	r4, r7, r5
 800c668:	492b      	ldr	r1, [pc, #172]	; (800c718 <tcp_input+0x118>)
 800c66a:	6878      	ldr	r0, [r7, #4]
 800c66c:	4b2b      	ldr	r3, [pc, #172]	; (800c71c <tcp_input+0x11c>)
 800c66e:	9300      	str	r3, [sp, #0]
 800c670:	000b      	movs	r3, r1
 800c672:	2106      	movs	r1, #6
 800c674:	f7fb fd4f 	bl	8008116 <ip_chksum_pseudo>
 800c678:	0003      	movs	r3, r0
 800c67a:	8023      	strh	r3, [r4, #0]
                                    ip_current_src_addr(), ip_current_dest_addr());
    if (chksum != 0) {
 800c67c:	197b      	adds	r3, r7, r5
 800c67e:	881b      	ldrh	r3, [r3, #0]
 800c680:	2b00      	cmp	r3, #0
 800c682:	d001      	beq.n	800c688 <tcp_input+0x88>
 800c684:	f000 fcdf 	bl	800d046 <tcp_input+0xa46>
    }
  }
#endif /* CHECKSUM_CHECK_TCP */

  /* sanity-check header length */
  hdrlen_bytes = TCPH_HDRLEN_BYTES(tcphdr);
 800c688:	4b21      	ldr	r3, [pc, #132]	; (800c710 <tcp_input+0x110>)
 800c68a:	681b      	ldr	r3, [r3, #0]
 800c68c:	7b1a      	ldrb	r2, [r3, #12]
 800c68e:	7b5b      	ldrb	r3, [r3, #13]
 800c690:	021b      	lsls	r3, r3, #8
 800c692:	4313      	orrs	r3, r2
 800c694:	b29b      	uxth	r3, r3
 800c696:	0018      	movs	r0, r3
 800c698:	f7fa fab6 	bl	8006c08 <lwip_htons>
 800c69c:	0003      	movs	r3, r0
 800c69e:	0b1b      	lsrs	r3, r3, #12
 800c6a0:	b29b      	uxth	r3, r3
 800c6a2:	b2da      	uxtb	r2, r3
 800c6a4:	210f      	movs	r1, #15
 800c6a6:	187b      	adds	r3, r7, r1
 800c6a8:	0092      	lsls	r2, r2, #2
 800c6aa:	701a      	strb	r2, [r3, #0]
  if ((hdrlen_bytes < TCP_HLEN) || (hdrlen_bytes > p->tot_len)) {
 800c6ac:	187b      	adds	r3, r7, r1
 800c6ae:	781b      	ldrb	r3, [r3, #0]
 800c6b0:	2b13      	cmp	r3, #19
 800c6b2:	d801      	bhi.n	800c6b8 <tcp_input+0xb8>
 800c6b4:	f000 fcc9 	bl	800d04a <tcp_input+0xa4a>
 800c6b8:	187b      	adds	r3, r7, r1
 800c6ba:	781b      	ldrb	r3, [r3, #0]
 800c6bc:	b29a      	uxth	r2, r3
 800c6be:	687b      	ldr	r3, [r7, #4]
 800c6c0:	891b      	ldrh	r3, [r3, #8]
 800c6c2:	429a      	cmp	r2, r3
 800c6c4:	d901      	bls.n	800c6ca <tcp_input+0xca>
 800c6c6:	f000 fcc0 	bl	800d04a <tcp_input+0xa4a>
    goto dropped;
  }

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  tcphdr_optlen = (u16_t)(hdrlen_bytes - TCP_HLEN);
 800c6ca:	187b      	adds	r3, r7, r1
 800c6cc:	781b      	ldrb	r3, [r3, #0]
 800c6ce:	b29b      	uxth	r3, r3
 800c6d0:	3b14      	subs	r3, #20
 800c6d2:	b29a      	uxth	r2, r3
 800c6d4:	4b12      	ldr	r3, [pc, #72]	; (800c720 <tcp_input+0x120>)
 800c6d6:	801a      	strh	r2, [r3, #0]
  tcphdr_opt2 = NULL;
 800c6d8:	4b12      	ldr	r3, [pc, #72]	; (800c724 <tcp_input+0x124>)
 800c6da:	2200      	movs	r2, #0
 800c6dc:	601a      	str	r2, [r3, #0]
  if (p->len >= hdrlen_bytes) {
 800c6de:	687b      	ldr	r3, [r7, #4]
 800c6e0:	895a      	ldrh	r2, [r3, #10]
 800c6e2:	187b      	adds	r3, r7, r1
 800c6e4:	781b      	ldrb	r3, [r3, #0]
 800c6e6:	b29b      	uxth	r3, r3
 800c6e8:	429a      	cmp	r2, r3
 800c6ea:	d31f      	bcc.n	800c72c <tcp_input+0x12c>
    /* all options are in the first pbuf */
    tcphdr_opt1len = tcphdr_optlen;
 800c6ec:	4b0c      	ldr	r3, [pc, #48]	; (800c720 <tcp_input+0x120>)
 800c6ee:	881a      	ldrh	r2, [r3, #0]
 800c6f0:	4b0d      	ldr	r3, [pc, #52]	; (800c728 <tcp_input+0x128>)
 800c6f2:	801a      	strh	r2, [r3, #0]
    pbuf_remove_header(p, hdrlen_bytes); /* cannot fail */
 800c6f4:	187b      	adds	r3, r7, r1
 800c6f6:	781a      	ldrb	r2, [r3, #0]
 800c6f8:	687b      	ldr	r3, [r7, #4]
 800c6fa:	0011      	movs	r1, r2
 800c6fc:	0018      	movs	r0, r3
 800c6fe:	f7fd f98f 	bl	8009a20 <pbuf_remove_header>
 800c702:	e06b      	b.n	800c7dc <tcp_input+0x1dc>
 800c704:	080201e0 	.word	0x080201e0
 800c708:	08020208 	.word	0x08020208
 800c70c:	08020220 	.word	0x08020220
 800c710:	20001b40 	.word	0x20001b40
 800c714:	20001c94 	.word	0x20001c94
 800c718:	20001ca4 	.word	0x20001ca4
 800c71c:	20001ca8 	.word	0x20001ca8
 800c720:	20001b44 	.word	0x20001b44
 800c724:	20001b48 	.word	0x20001b48
 800c728:	20001b46 	.word	0x20001b46
  } else {
    u16_t opt2len;
    /* TCP header fits into first pbuf, options don't - data is in the next pbuf */
    /* there must be a next pbuf, due to hdrlen_bytes sanity check above */
    LWIP_ASSERT("p->next != NULL", p->next != NULL);
 800c72c:	687b      	ldr	r3, [r7, #4]
 800c72e:	681b      	ldr	r3, [r3, #0]
 800c730:	2b00      	cmp	r3, #0
 800c732:	d105      	bne.n	800c740 <tcp_input+0x140>
 800c734:	4bd0      	ldr	r3, [pc, #832]	; (800ca78 <tcp_input+0x478>)
 800c736:	49d1      	ldr	r1, [pc, #836]	; (800ca7c <tcp_input+0x47c>)
 800c738:	48d1      	ldr	r0, [pc, #836]	; (800ca80 <tcp_input+0x480>)
 800c73a:	22c2      	movs	r2, #194	; 0xc2
 800c73c:	f7f6 f8ce 	bl	80028dc <app_debug_rtt_raw>

    /* advance over the TCP header (cannot fail) */
    pbuf_remove_header(p, TCP_HLEN);
 800c740:	687b      	ldr	r3, [r7, #4]
 800c742:	2114      	movs	r1, #20
 800c744:	0018      	movs	r0, r3
 800c746:	f7fd f96b 	bl	8009a20 <pbuf_remove_header>

    /* determine how long the first and second parts of the options are */
    tcphdr_opt1len = p->len;
 800c74a:	687b      	ldr	r3, [r7, #4]
 800c74c:	895a      	ldrh	r2, [r3, #10]
 800c74e:	4bcd      	ldr	r3, [pc, #820]	; (800ca84 <tcp_input+0x484>)
 800c750:	801a      	strh	r2, [r3, #0]
    opt2len = (u16_t)(tcphdr_optlen - tcphdr_opt1len);
 800c752:	4bcd      	ldr	r3, [pc, #820]	; (800ca88 <tcp_input+0x488>)
 800c754:	8819      	ldrh	r1, [r3, #0]
 800c756:	4bcb      	ldr	r3, [pc, #812]	; (800ca84 <tcp_input+0x484>)
 800c758:	881a      	ldrh	r2, [r3, #0]
 800c75a:	240c      	movs	r4, #12
 800c75c:	193b      	adds	r3, r7, r4
 800c75e:	1a8a      	subs	r2, r1, r2
 800c760:	801a      	strh	r2, [r3, #0]

    /* options continue in the next pbuf: set p to zero length and hide the
        options in the next pbuf (adjusting p->tot_len) */
    pbuf_remove_header(p, tcphdr_opt1len);
 800c762:	4bc8      	ldr	r3, [pc, #800]	; (800ca84 <tcp_input+0x484>)
 800c764:	881b      	ldrh	r3, [r3, #0]
 800c766:	001a      	movs	r2, r3
 800c768:	687b      	ldr	r3, [r7, #4]
 800c76a:	0011      	movs	r1, r2
 800c76c:	0018      	movs	r0, r3
 800c76e:	f7fd f957 	bl	8009a20 <pbuf_remove_header>

    /* check that the options fit in the second pbuf */
    if (opt2len > p->next->len) {
 800c772:	687b      	ldr	r3, [r7, #4]
 800c774:	681b      	ldr	r3, [r3, #0]
 800c776:	895b      	ldrh	r3, [r3, #10]
 800c778:	193a      	adds	r2, r7, r4
 800c77a:	8812      	ldrh	r2, [r2, #0]
 800c77c:	429a      	cmp	r2, r3
 800c77e:	d901      	bls.n	800c784 <tcp_input+0x184>
 800c780:	f000 fc65 	bl	800d04e <tcp_input+0xa4e>
      TCP_STATS_INC(tcp.lenerr);
      goto dropped;
    }

    /* remember the pointer to the second part of the options */
    tcphdr_opt2 = (u8_t *)p->next->payload;
 800c784:	687b      	ldr	r3, [r7, #4]
 800c786:	681b      	ldr	r3, [r3, #0]
 800c788:	685a      	ldr	r2, [r3, #4]
 800c78a:	4bc0      	ldr	r3, [pc, #768]	; (800ca8c <tcp_input+0x48c>)
 800c78c:	601a      	str	r2, [r3, #0]

    /* advance p->next to point after the options, and manually
        adjust p->tot_len to keep it consistent with the changed p->next */
    pbuf_remove_header(p->next, opt2len);
 800c78e:	687b      	ldr	r3, [r7, #4]
 800c790:	681a      	ldr	r2, [r3, #0]
 800c792:	193b      	adds	r3, r7, r4
 800c794:	881b      	ldrh	r3, [r3, #0]
 800c796:	0019      	movs	r1, r3
 800c798:	0010      	movs	r0, r2
 800c79a:	f7fd f941 	bl	8009a20 <pbuf_remove_header>
    p->tot_len = (u16_t)(p->tot_len - opt2len);
 800c79e:	687b      	ldr	r3, [r7, #4]
 800c7a0:	891a      	ldrh	r2, [r3, #8]
 800c7a2:	193b      	adds	r3, r7, r4
 800c7a4:	881b      	ldrh	r3, [r3, #0]
 800c7a6:	1ad3      	subs	r3, r2, r3
 800c7a8:	b29a      	uxth	r2, r3
 800c7aa:	687b      	ldr	r3, [r7, #4]
 800c7ac:	811a      	strh	r2, [r3, #8]

    LWIP_ASSERT("p->len == 0", p->len == 0);
 800c7ae:	687b      	ldr	r3, [r7, #4]
 800c7b0:	895b      	ldrh	r3, [r3, #10]
 800c7b2:	2b00      	cmp	r3, #0
 800c7b4:	d005      	beq.n	800c7c2 <tcp_input+0x1c2>
 800c7b6:	4bb0      	ldr	r3, [pc, #704]	; (800ca78 <tcp_input+0x478>)
 800c7b8:	49b5      	ldr	r1, [pc, #724]	; (800ca90 <tcp_input+0x490>)
 800c7ba:	48b1      	ldr	r0, [pc, #708]	; (800ca80 <tcp_input+0x480>)
 800c7bc:	22df      	movs	r2, #223	; 0xdf
 800c7be:	f7f6 f88d 	bl	80028dc <app_debug_rtt_raw>
    LWIP_ASSERT("p->tot_len == p->next->tot_len", p->tot_len == p->next->tot_len);
 800c7c2:	687b      	ldr	r3, [r7, #4]
 800c7c4:	891a      	ldrh	r2, [r3, #8]
 800c7c6:	687b      	ldr	r3, [r7, #4]
 800c7c8:	681b      	ldr	r3, [r3, #0]
 800c7ca:	891b      	ldrh	r3, [r3, #8]
 800c7cc:	429a      	cmp	r2, r3
 800c7ce:	d005      	beq.n	800c7dc <tcp_input+0x1dc>
 800c7d0:	4ba9      	ldr	r3, [pc, #676]	; (800ca78 <tcp_input+0x478>)
 800c7d2:	49b0      	ldr	r1, [pc, #704]	; (800ca94 <tcp_input+0x494>)
 800c7d4:	48aa      	ldr	r0, [pc, #680]	; (800ca80 <tcp_input+0x480>)
 800c7d6:	22e0      	movs	r2, #224	; 0xe0
 800c7d8:	f7f6 f880 	bl	80028dc <app_debug_rtt_raw>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = lwip_ntohs(tcphdr->src);
 800c7dc:	4bae      	ldr	r3, [pc, #696]	; (800ca98 <tcp_input+0x498>)
 800c7de:	681b      	ldr	r3, [r3, #0]
 800c7e0:	781a      	ldrb	r2, [r3, #0]
 800c7e2:	785b      	ldrb	r3, [r3, #1]
 800c7e4:	021b      	lsls	r3, r3, #8
 800c7e6:	4313      	orrs	r3, r2
 800c7e8:	b29a      	uxth	r2, r3
 800c7ea:	4bab      	ldr	r3, [pc, #684]	; (800ca98 <tcp_input+0x498>)
 800c7ec:	681c      	ldr	r4, [r3, #0]
 800c7ee:	0010      	movs	r0, r2
 800c7f0:	f7fa fa0a 	bl	8006c08 <lwip_htons>
 800c7f4:	0003      	movs	r3, r0
 800c7f6:	22ff      	movs	r2, #255	; 0xff
 800c7f8:	401a      	ands	r2, r3
 800c7fa:	0010      	movs	r0, r2
 800c7fc:	7822      	ldrb	r2, [r4, #0]
 800c7fe:	2100      	movs	r1, #0
 800c800:	400a      	ands	r2, r1
 800c802:	1c11      	adds	r1, r2, #0
 800c804:	1c02      	adds	r2, r0, #0
 800c806:	430a      	orrs	r2, r1
 800c808:	7022      	strb	r2, [r4, #0]
 800c80a:	0a1b      	lsrs	r3, r3, #8
 800c80c:	b299      	uxth	r1, r3
 800c80e:	7863      	ldrb	r3, [r4, #1]
 800c810:	2200      	movs	r2, #0
 800c812:	4013      	ands	r3, r2
 800c814:	1c1a      	adds	r2, r3, #0
 800c816:	1c0b      	adds	r3, r1, #0
 800c818:	4313      	orrs	r3, r2
 800c81a:	7063      	strb	r3, [r4, #1]
  tcphdr->dest = lwip_ntohs(tcphdr->dest);
 800c81c:	4b9e      	ldr	r3, [pc, #632]	; (800ca98 <tcp_input+0x498>)
 800c81e:	681b      	ldr	r3, [r3, #0]
 800c820:	789a      	ldrb	r2, [r3, #2]
 800c822:	78db      	ldrb	r3, [r3, #3]
 800c824:	021b      	lsls	r3, r3, #8
 800c826:	4313      	orrs	r3, r2
 800c828:	b29a      	uxth	r2, r3
 800c82a:	4b9b      	ldr	r3, [pc, #620]	; (800ca98 <tcp_input+0x498>)
 800c82c:	681c      	ldr	r4, [r3, #0]
 800c82e:	0010      	movs	r0, r2
 800c830:	f7fa f9ea 	bl	8006c08 <lwip_htons>
 800c834:	0003      	movs	r3, r0
 800c836:	22ff      	movs	r2, #255	; 0xff
 800c838:	401a      	ands	r2, r3
 800c83a:	0010      	movs	r0, r2
 800c83c:	78a2      	ldrb	r2, [r4, #2]
 800c83e:	2100      	movs	r1, #0
 800c840:	400a      	ands	r2, r1
 800c842:	1c11      	adds	r1, r2, #0
 800c844:	1c02      	adds	r2, r0, #0
 800c846:	430a      	orrs	r2, r1
 800c848:	70a2      	strb	r2, [r4, #2]
 800c84a:	0a1b      	lsrs	r3, r3, #8
 800c84c:	b299      	uxth	r1, r3
 800c84e:	78e3      	ldrb	r3, [r4, #3]
 800c850:	2200      	movs	r2, #0
 800c852:	4013      	ands	r3, r2
 800c854:	1c1a      	adds	r2, r3, #0
 800c856:	1c0b      	adds	r3, r1, #0
 800c858:	4313      	orrs	r3, r2
 800c85a:	70e3      	strb	r3, [r4, #3]
  seqno = tcphdr->seqno = lwip_ntohl(tcphdr->seqno);
 800c85c:	4b8e      	ldr	r3, [pc, #568]	; (800ca98 <tcp_input+0x498>)
 800c85e:	681b      	ldr	r3, [r3, #0]
 800c860:	791a      	ldrb	r2, [r3, #4]
 800c862:	7959      	ldrb	r1, [r3, #5]
 800c864:	0209      	lsls	r1, r1, #8
 800c866:	430a      	orrs	r2, r1
 800c868:	7999      	ldrb	r1, [r3, #6]
 800c86a:	0409      	lsls	r1, r1, #16
 800c86c:	430a      	orrs	r2, r1
 800c86e:	79db      	ldrb	r3, [r3, #7]
 800c870:	061b      	lsls	r3, r3, #24
 800c872:	4313      	orrs	r3, r2
 800c874:	001a      	movs	r2, r3
 800c876:	4b88      	ldr	r3, [pc, #544]	; (800ca98 <tcp_input+0x498>)
 800c878:	681c      	ldr	r4, [r3, #0]
 800c87a:	0010      	movs	r0, r2
 800c87c:	f7fa f9da 	bl	8006c34 <lwip_htonl>
 800c880:	0003      	movs	r3, r0
 800c882:	22ff      	movs	r2, #255	; 0xff
 800c884:	401a      	ands	r2, r3
 800c886:	0010      	movs	r0, r2
 800c888:	7922      	ldrb	r2, [r4, #4]
 800c88a:	2100      	movs	r1, #0
 800c88c:	400a      	ands	r2, r1
 800c88e:	1c11      	adds	r1, r2, #0
 800c890:	1c02      	adds	r2, r0, #0
 800c892:	430a      	orrs	r2, r1
 800c894:	7122      	strb	r2, [r4, #4]
 800c896:	0a1a      	lsrs	r2, r3, #8
 800c898:	21ff      	movs	r1, #255	; 0xff
 800c89a:	400a      	ands	r2, r1
 800c89c:	0010      	movs	r0, r2
 800c89e:	7962      	ldrb	r2, [r4, #5]
 800c8a0:	2100      	movs	r1, #0
 800c8a2:	400a      	ands	r2, r1
 800c8a4:	1c11      	adds	r1, r2, #0
 800c8a6:	1c02      	adds	r2, r0, #0
 800c8a8:	430a      	orrs	r2, r1
 800c8aa:	7162      	strb	r2, [r4, #5]
 800c8ac:	0c1a      	lsrs	r2, r3, #16
 800c8ae:	21ff      	movs	r1, #255	; 0xff
 800c8b0:	400a      	ands	r2, r1
 800c8b2:	0010      	movs	r0, r2
 800c8b4:	79a2      	ldrb	r2, [r4, #6]
 800c8b6:	2100      	movs	r1, #0
 800c8b8:	400a      	ands	r2, r1
 800c8ba:	1c11      	adds	r1, r2, #0
 800c8bc:	1c02      	adds	r2, r0, #0
 800c8be:	430a      	orrs	r2, r1
 800c8c0:	71a2      	strb	r2, [r4, #6]
 800c8c2:	0e19      	lsrs	r1, r3, #24
 800c8c4:	79e3      	ldrb	r3, [r4, #7]
 800c8c6:	2200      	movs	r2, #0
 800c8c8:	4013      	ands	r3, r2
 800c8ca:	1c1a      	adds	r2, r3, #0
 800c8cc:	1c0b      	adds	r3, r1, #0
 800c8ce:	4313      	orrs	r3, r2
 800c8d0:	71e3      	strb	r3, [r4, #7]
 800c8d2:	7923      	ldrb	r3, [r4, #4]
 800c8d4:	7962      	ldrb	r2, [r4, #5]
 800c8d6:	0212      	lsls	r2, r2, #8
 800c8d8:	4313      	orrs	r3, r2
 800c8da:	79a2      	ldrb	r2, [r4, #6]
 800c8dc:	0412      	lsls	r2, r2, #16
 800c8de:	4313      	orrs	r3, r2
 800c8e0:	79e2      	ldrb	r2, [r4, #7]
 800c8e2:	0612      	lsls	r2, r2, #24
 800c8e4:	4313      	orrs	r3, r2
 800c8e6:	001a      	movs	r2, r3
 800c8e8:	4b6c      	ldr	r3, [pc, #432]	; (800ca9c <tcp_input+0x49c>)
 800c8ea:	601a      	str	r2, [r3, #0]
  ackno = tcphdr->ackno = lwip_ntohl(tcphdr->ackno);
 800c8ec:	4b6a      	ldr	r3, [pc, #424]	; (800ca98 <tcp_input+0x498>)
 800c8ee:	681b      	ldr	r3, [r3, #0]
 800c8f0:	7a1a      	ldrb	r2, [r3, #8]
 800c8f2:	7a59      	ldrb	r1, [r3, #9]
 800c8f4:	0209      	lsls	r1, r1, #8
 800c8f6:	430a      	orrs	r2, r1
 800c8f8:	7a99      	ldrb	r1, [r3, #10]
 800c8fa:	0409      	lsls	r1, r1, #16
 800c8fc:	430a      	orrs	r2, r1
 800c8fe:	7adb      	ldrb	r3, [r3, #11]
 800c900:	061b      	lsls	r3, r3, #24
 800c902:	4313      	orrs	r3, r2
 800c904:	001a      	movs	r2, r3
 800c906:	4b64      	ldr	r3, [pc, #400]	; (800ca98 <tcp_input+0x498>)
 800c908:	681c      	ldr	r4, [r3, #0]
 800c90a:	0010      	movs	r0, r2
 800c90c:	f7fa f992 	bl	8006c34 <lwip_htonl>
 800c910:	0003      	movs	r3, r0
 800c912:	22ff      	movs	r2, #255	; 0xff
 800c914:	401a      	ands	r2, r3
 800c916:	0010      	movs	r0, r2
 800c918:	7a22      	ldrb	r2, [r4, #8]
 800c91a:	2100      	movs	r1, #0
 800c91c:	400a      	ands	r2, r1
 800c91e:	1c11      	adds	r1, r2, #0
 800c920:	1c02      	adds	r2, r0, #0
 800c922:	430a      	orrs	r2, r1
 800c924:	7222      	strb	r2, [r4, #8]
 800c926:	0a1a      	lsrs	r2, r3, #8
 800c928:	21ff      	movs	r1, #255	; 0xff
 800c92a:	400a      	ands	r2, r1
 800c92c:	0010      	movs	r0, r2
 800c92e:	7a62      	ldrb	r2, [r4, #9]
 800c930:	2100      	movs	r1, #0
 800c932:	400a      	ands	r2, r1
 800c934:	1c11      	adds	r1, r2, #0
 800c936:	1c02      	adds	r2, r0, #0
 800c938:	430a      	orrs	r2, r1
 800c93a:	7262      	strb	r2, [r4, #9]
 800c93c:	0c1a      	lsrs	r2, r3, #16
 800c93e:	21ff      	movs	r1, #255	; 0xff
 800c940:	400a      	ands	r2, r1
 800c942:	0010      	movs	r0, r2
 800c944:	7aa2      	ldrb	r2, [r4, #10]
 800c946:	2100      	movs	r1, #0
 800c948:	400a      	ands	r2, r1
 800c94a:	1c11      	adds	r1, r2, #0
 800c94c:	1c02      	adds	r2, r0, #0
 800c94e:	430a      	orrs	r2, r1
 800c950:	72a2      	strb	r2, [r4, #10]
 800c952:	0e19      	lsrs	r1, r3, #24
 800c954:	7ae3      	ldrb	r3, [r4, #11]
 800c956:	2200      	movs	r2, #0
 800c958:	4013      	ands	r3, r2
 800c95a:	1c1a      	adds	r2, r3, #0
 800c95c:	1c0b      	adds	r3, r1, #0
 800c95e:	4313      	orrs	r3, r2
 800c960:	72e3      	strb	r3, [r4, #11]
 800c962:	7a23      	ldrb	r3, [r4, #8]
 800c964:	7a62      	ldrb	r2, [r4, #9]
 800c966:	0212      	lsls	r2, r2, #8
 800c968:	4313      	orrs	r3, r2
 800c96a:	7aa2      	ldrb	r2, [r4, #10]
 800c96c:	0412      	lsls	r2, r2, #16
 800c96e:	4313      	orrs	r3, r2
 800c970:	7ae2      	ldrb	r2, [r4, #11]
 800c972:	0612      	lsls	r2, r2, #24
 800c974:	4313      	orrs	r3, r2
 800c976:	001a      	movs	r2, r3
 800c978:	4b49      	ldr	r3, [pc, #292]	; (800caa0 <tcp_input+0x4a0>)
 800c97a:	601a      	str	r2, [r3, #0]
  tcphdr->wnd = lwip_ntohs(tcphdr->wnd);
 800c97c:	4b46      	ldr	r3, [pc, #280]	; (800ca98 <tcp_input+0x498>)
 800c97e:	681b      	ldr	r3, [r3, #0]
 800c980:	7b9a      	ldrb	r2, [r3, #14]
 800c982:	7bdb      	ldrb	r3, [r3, #15]
 800c984:	021b      	lsls	r3, r3, #8
 800c986:	4313      	orrs	r3, r2
 800c988:	b29a      	uxth	r2, r3
 800c98a:	4b43      	ldr	r3, [pc, #268]	; (800ca98 <tcp_input+0x498>)
 800c98c:	681c      	ldr	r4, [r3, #0]
 800c98e:	0010      	movs	r0, r2
 800c990:	f7fa f93a 	bl	8006c08 <lwip_htons>
 800c994:	0003      	movs	r3, r0
 800c996:	22ff      	movs	r2, #255	; 0xff
 800c998:	401a      	ands	r2, r3
 800c99a:	0010      	movs	r0, r2
 800c99c:	7ba2      	ldrb	r2, [r4, #14]
 800c99e:	2100      	movs	r1, #0
 800c9a0:	400a      	ands	r2, r1
 800c9a2:	1c11      	adds	r1, r2, #0
 800c9a4:	1c02      	adds	r2, r0, #0
 800c9a6:	430a      	orrs	r2, r1
 800c9a8:	73a2      	strb	r2, [r4, #14]
 800c9aa:	0a1b      	lsrs	r3, r3, #8
 800c9ac:	b299      	uxth	r1, r3
 800c9ae:	7be3      	ldrb	r3, [r4, #15]
 800c9b0:	2200      	movs	r2, #0
 800c9b2:	4013      	ands	r3, r2
 800c9b4:	1c1a      	adds	r2, r3, #0
 800c9b6:	1c0b      	adds	r3, r1, #0
 800c9b8:	4313      	orrs	r3, r2
 800c9ba:	73e3      	strb	r3, [r4, #15]

  flags = TCPH_FLAGS(tcphdr);
 800c9bc:	4b36      	ldr	r3, [pc, #216]	; (800ca98 <tcp_input+0x498>)
 800c9be:	681b      	ldr	r3, [r3, #0]
 800c9c0:	7b1a      	ldrb	r2, [r3, #12]
 800c9c2:	7b5b      	ldrb	r3, [r3, #13]
 800c9c4:	021b      	lsls	r3, r3, #8
 800c9c6:	4313      	orrs	r3, r2
 800c9c8:	b29b      	uxth	r3, r3
 800c9ca:	0018      	movs	r0, r3
 800c9cc:	f7fa f91c 	bl	8006c08 <lwip_htons>
 800c9d0:	0003      	movs	r3, r0
 800c9d2:	b2db      	uxtb	r3, r3
 800c9d4:	223f      	movs	r2, #63	; 0x3f
 800c9d6:	4013      	ands	r3, r2
 800c9d8:	b2da      	uxtb	r2, r3
 800c9da:	4b32      	ldr	r3, [pc, #200]	; (800caa4 <tcp_input+0x4a4>)
 800c9dc:	701a      	strb	r2, [r3, #0]
  tcplen = p->tot_len;
 800c9de:	687b      	ldr	r3, [r7, #4]
 800c9e0:	891a      	ldrh	r2, [r3, #8]
 800c9e2:	4b31      	ldr	r3, [pc, #196]	; (800caa8 <tcp_input+0x4a8>)
 800c9e4:	801a      	strh	r2, [r3, #0]
  if (flags & (TCP_FIN | TCP_SYN)) {
 800c9e6:	4b2f      	ldr	r3, [pc, #188]	; (800caa4 <tcp_input+0x4a4>)
 800c9e8:	781b      	ldrb	r3, [r3, #0]
 800c9ea:	001a      	movs	r2, r3
 800c9ec:	2303      	movs	r3, #3
 800c9ee:	4013      	ands	r3, r2
 800c9f0:	d00c      	beq.n	800ca0c <tcp_input+0x40c>
    tcplen++;
 800c9f2:	4b2d      	ldr	r3, [pc, #180]	; (800caa8 <tcp_input+0x4a8>)
 800c9f4:	881b      	ldrh	r3, [r3, #0]
 800c9f6:	3301      	adds	r3, #1
 800c9f8:	b29a      	uxth	r2, r3
 800c9fa:	4b2b      	ldr	r3, [pc, #172]	; (800caa8 <tcp_input+0x4a8>)
 800c9fc:	801a      	strh	r2, [r3, #0]
    if (tcplen < p->tot_len) {
 800c9fe:	687b      	ldr	r3, [r7, #4]
 800ca00:	891a      	ldrh	r2, [r3, #8]
 800ca02:	4b29      	ldr	r3, [pc, #164]	; (800caa8 <tcp_input+0x4a8>)
 800ca04:	881b      	ldrh	r3, [r3, #0]
 800ca06:	429a      	cmp	r2, r3
 800ca08:	d900      	bls.n	800ca0c <tcp_input+0x40c>
 800ca0a:	e322      	b.n	800d052 <tcp_input+0xa52>
    }
  }

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
 800ca0c:	2300      	movs	r3, #0
 800ca0e:	627b      	str	r3, [r7, #36]	; 0x24

  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800ca10:	4b26      	ldr	r3, [pc, #152]	; (800caac <tcp_input+0x4ac>)
 800ca12:	681b      	ldr	r3, [r3, #0]
 800ca14:	623b      	str	r3, [r7, #32]
 800ca16:	e0a1      	b.n	800cb5c <tcp_input+0x55c>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
 800ca18:	6a3b      	ldr	r3, [r7, #32]
 800ca1a:	7e1b      	ldrb	r3, [r3, #24]
 800ca1c:	2b00      	cmp	r3, #0
 800ca1e:	d105      	bne.n	800ca2c <tcp_input+0x42c>
 800ca20:	4b15      	ldr	r3, [pc, #84]	; (800ca78 <tcp_input+0x478>)
 800ca22:	4923      	ldr	r1, [pc, #140]	; (800cab0 <tcp_input+0x4b0>)
 800ca24:	4816      	ldr	r0, [pc, #88]	; (800ca80 <tcp_input+0x480>)
 800ca26:	22fb      	movs	r2, #251	; 0xfb
 800ca28:	f7f5 ff58 	bl	80028dc <app_debug_rtt_raw>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
 800ca2c:	6a3b      	ldr	r3, [r7, #32]
 800ca2e:	7e1b      	ldrb	r3, [r3, #24]
 800ca30:	2b0a      	cmp	r3, #10
 800ca32:	d105      	bne.n	800ca40 <tcp_input+0x440>
 800ca34:	4b10      	ldr	r3, [pc, #64]	; (800ca78 <tcp_input+0x478>)
 800ca36:	491f      	ldr	r1, [pc, #124]	; (800cab4 <tcp_input+0x4b4>)
 800ca38:	4811      	ldr	r0, [pc, #68]	; (800ca80 <tcp_input+0x480>)
 800ca3a:	22fc      	movs	r2, #252	; 0xfc
 800ca3c:	f7f5 ff4e 	bl	80028dc <app_debug_rtt_raw>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
 800ca40:	6a3b      	ldr	r3, [r7, #32]
 800ca42:	7e1b      	ldrb	r3, [r3, #24]
 800ca44:	2b01      	cmp	r3, #1
 800ca46:	d105      	bne.n	800ca54 <tcp_input+0x454>
 800ca48:	4b0b      	ldr	r3, [pc, #44]	; (800ca78 <tcp_input+0x478>)
 800ca4a:	491b      	ldr	r1, [pc, #108]	; (800cab8 <tcp_input+0x4b8>)
 800ca4c:	480c      	ldr	r0, [pc, #48]	; (800ca80 <tcp_input+0x480>)
 800ca4e:	22fd      	movs	r2, #253	; 0xfd
 800ca50:	f7f5 ff44 	bl	80028dc <app_debug_rtt_raw>

    /* check if PCB is bound to specific netif */
    if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 800ca54:	6a3b      	ldr	r3, [r7, #32]
 800ca56:	7a1b      	ldrb	r3, [r3, #8]
 800ca58:	2b00      	cmp	r3, #0
 800ca5a:	d031      	beq.n	800cac0 <tcp_input+0x4c0>
        (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 800ca5c:	6a3b      	ldr	r3, [r7, #32]
 800ca5e:	7a1a      	ldrb	r2, [r3, #8]
 800ca60:	4b16      	ldr	r3, [pc, #88]	; (800cabc <tcp_input+0x4bc>)
 800ca62:	685b      	ldr	r3, [r3, #4]
 800ca64:	2134      	movs	r1, #52	; 0x34
 800ca66:	5c5b      	ldrb	r3, [r3, r1]
 800ca68:	3301      	adds	r3, #1
 800ca6a:	b2db      	uxtb	r3, r3
    if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 800ca6c:	429a      	cmp	r2, r3
 800ca6e:	d027      	beq.n	800cac0 <tcp_input+0x4c0>
      prev = pcb;
 800ca70:	6a3b      	ldr	r3, [r7, #32]
 800ca72:	627b      	str	r3, [r7, #36]	; 0x24
      continue;
 800ca74:	e06f      	b.n	800cb56 <tcp_input+0x556>
 800ca76:	46c0      	nop			; (mov r8, r8)
 800ca78:	080201e0 	.word	0x080201e0
 800ca7c:	0802024c 	.word	0x0802024c
 800ca80:	08020220 	.word	0x08020220
 800ca84:	20001b46 	.word	0x20001b46
 800ca88:	20001b44 	.word	0x20001b44
 800ca8c:	20001b48 	.word	0x20001b48
 800ca90:	0802025c 	.word	0x0802025c
 800ca94:	08020268 	.word	0x08020268
 800ca98:	20001b40 	.word	0x20001b40
 800ca9c:	20001b50 	.word	0x20001b50
 800caa0:	20001b54 	.word	0x20001b54
 800caa4:	20001b5c 	.word	0x20001b5c
 800caa8:	20001b5a 	.word	0x20001b5a
 800caac:	20002ed4 	.word	0x20002ed4
 800cab0:	08020288 	.word	0x08020288
 800cab4:	080202b0 	.word	0x080202b0
 800cab8:	080202dc 	.word	0x080202dc
 800cabc:	20001c94 	.word	0x20001c94
    }

    if (pcb->remote_port == tcphdr->src &&
 800cac0:	6a3b      	ldr	r3, [r7, #32]
 800cac2:	8b9a      	ldrh	r2, [r3, #28]
 800cac4:	4bcb      	ldr	r3, [pc, #812]	; (800cdf4 <tcp_input+0x7f4>)
 800cac6:	681b      	ldr	r3, [r3, #0]
 800cac8:	7819      	ldrb	r1, [r3, #0]
 800caca:	785b      	ldrb	r3, [r3, #1]
 800cacc:	021b      	lsls	r3, r3, #8
 800cace:	430b      	orrs	r3, r1
 800cad0:	b29b      	uxth	r3, r3
 800cad2:	429a      	cmp	r2, r3
 800cad4:	d13d      	bne.n	800cb52 <tcp_input+0x552>
        pcb->local_port == tcphdr->dest &&
 800cad6:	6a3b      	ldr	r3, [r7, #32]
 800cad8:	8b5a      	ldrh	r2, [r3, #26]
 800cada:	4bc6      	ldr	r3, [pc, #792]	; (800cdf4 <tcp_input+0x7f4>)
 800cadc:	681b      	ldr	r3, [r3, #0]
 800cade:	7899      	ldrb	r1, [r3, #2]
 800cae0:	78db      	ldrb	r3, [r3, #3]
 800cae2:	021b      	lsls	r3, r3, #8
 800cae4:	430b      	orrs	r3, r1
 800cae6:	b29b      	uxth	r3, r3
    if (pcb->remote_port == tcphdr->src &&
 800cae8:	429a      	cmp	r2, r3
 800caea:	d132      	bne.n	800cb52 <tcp_input+0x552>
        ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 800caec:	6a3b      	ldr	r3, [r7, #32]
 800caee:	685a      	ldr	r2, [r3, #4]
 800caf0:	4bc1      	ldr	r3, [pc, #772]	; (800cdf8 <tcp_input+0x7f8>)
 800caf2:	691b      	ldr	r3, [r3, #16]
        pcb->local_port == tcphdr->dest &&
 800caf4:	429a      	cmp	r2, r3
 800caf6:	d12c      	bne.n	800cb52 <tcp_input+0x552>
        ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 800caf8:	6a3b      	ldr	r3, [r7, #32]
 800cafa:	681a      	ldr	r2, [r3, #0]
 800cafc:	4bbe      	ldr	r3, [pc, #760]	; (800cdf8 <tcp_input+0x7f8>)
 800cafe:	695b      	ldr	r3, [r3, #20]
        ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 800cb00:	429a      	cmp	r2, r3
 800cb02:	d126      	bne.n	800cb52 <tcp_input+0x552>
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
 800cb04:	6a3b      	ldr	r3, [r7, #32]
 800cb06:	691b      	ldr	r3, [r3, #16]
 800cb08:	6a3a      	ldr	r2, [r7, #32]
 800cb0a:	429a      	cmp	r2, r3
 800cb0c:	d106      	bne.n	800cb1c <tcp_input+0x51c>
 800cb0e:	4bbb      	ldr	r3, [pc, #748]	; (800cdfc <tcp_input+0x7fc>)
 800cb10:	220e      	movs	r2, #14
 800cb12:	32ff      	adds	r2, #255	; 0xff
 800cb14:	49ba      	ldr	r1, [pc, #744]	; (800ce00 <tcp_input+0x800>)
 800cb16:	48bb      	ldr	r0, [pc, #748]	; (800ce04 <tcp_input+0x804>)
 800cb18:	f7f5 fee0 	bl	80028dc <app_debug_rtt_raw>
      if (prev != NULL) {
 800cb1c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cb1e:	2b00      	cmp	r3, #0
 800cb20:	d00a      	beq.n	800cb38 <tcp_input+0x538>
        prev->next = pcb->next;
 800cb22:	6a3b      	ldr	r3, [r7, #32]
 800cb24:	691a      	ldr	r2, [r3, #16]
 800cb26:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cb28:	611a      	str	r2, [r3, #16]
        pcb->next = tcp_active_pcbs;
 800cb2a:	4bb7      	ldr	r3, [pc, #732]	; (800ce08 <tcp_input+0x808>)
 800cb2c:	681a      	ldr	r2, [r3, #0]
 800cb2e:	6a3b      	ldr	r3, [r7, #32]
 800cb30:	611a      	str	r2, [r3, #16]
        tcp_active_pcbs = pcb;
 800cb32:	4bb5      	ldr	r3, [pc, #724]	; (800ce08 <tcp_input+0x808>)
 800cb34:	6a3a      	ldr	r2, [r7, #32]
 800cb36:	601a      	str	r2, [r3, #0]
      } else {
        TCP_STATS_INC(tcp.cachehit);
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
 800cb38:	6a3b      	ldr	r3, [r7, #32]
 800cb3a:	691b      	ldr	r3, [r3, #16]
 800cb3c:	6a3a      	ldr	r2, [r7, #32]
 800cb3e:	429a      	cmp	r2, r3
 800cb40:	d111      	bne.n	800cb66 <tcp_input+0x566>
 800cb42:	4bae      	ldr	r3, [pc, #696]	; (800cdfc <tcp_input+0x7fc>)
 800cb44:	2216      	movs	r2, #22
 800cb46:	32ff      	adds	r2, #255	; 0xff
 800cb48:	49b0      	ldr	r1, [pc, #704]	; (800ce0c <tcp_input+0x80c>)
 800cb4a:	48ae      	ldr	r0, [pc, #696]	; (800ce04 <tcp_input+0x804>)
 800cb4c:	f7f5 fec6 	bl	80028dc <app_debug_rtt_raw>
      break;
 800cb50:	e009      	b.n	800cb66 <tcp_input+0x566>
    }
    prev = pcb;
 800cb52:	6a3b      	ldr	r3, [r7, #32]
 800cb54:	627b      	str	r3, [r7, #36]	; 0x24
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800cb56:	6a3b      	ldr	r3, [r7, #32]
 800cb58:	691b      	ldr	r3, [r3, #16]
 800cb5a:	623b      	str	r3, [r7, #32]
 800cb5c:	6a3b      	ldr	r3, [r7, #32]
 800cb5e:	2b00      	cmp	r3, #0
 800cb60:	d000      	beq.n	800cb64 <tcp_input+0x564>
 800cb62:	e759      	b.n	800ca18 <tcp_input+0x418>
 800cb64:	e000      	b.n	800cb68 <tcp_input+0x568>
      break;
 800cb66:	46c0      	nop			; (mov r8, r8)
  }

  if (pcb == NULL) {
 800cb68:	6a3b      	ldr	r3, [r7, #32]
 800cb6a:	2b00      	cmp	r3, #0
 800cb6c:	d000      	beq.n	800cb70 <tcp_input+0x570>
 800cb6e:	e0ac      	b.n	800ccca <tcp_input+0x6ca>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800cb70:	4ba7      	ldr	r3, [pc, #668]	; (800ce10 <tcp_input+0x810>)
 800cb72:	681b      	ldr	r3, [r3, #0]
 800cb74:	623b      	str	r3, [r7, #32]
 800cb76:	e047      	b.n	800cc08 <tcp_input+0x608>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 800cb78:	6a3b      	ldr	r3, [r7, #32]
 800cb7a:	7e1b      	ldrb	r3, [r3, #24]
 800cb7c:	2b0a      	cmp	r3, #10
 800cb7e:	d006      	beq.n	800cb8e <tcp_input+0x58e>
 800cb80:	4b9e      	ldr	r3, [pc, #632]	; (800cdfc <tcp_input+0x7fc>)
 800cb82:	2220      	movs	r2, #32
 800cb84:	32ff      	adds	r2, #255	; 0xff
 800cb86:	49a3      	ldr	r1, [pc, #652]	; (800ce14 <tcp_input+0x814>)
 800cb88:	489e      	ldr	r0, [pc, #632]	; (800ce04 <tcp_input+0x804>)
 800cb8a:	f7f5 fea7 	bl	80028dc <app_debug_rtt_raw>

      /* check if PCB is bound to specific netif */
      if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 800cb8e:	6a3b      	ldr	r3, [r7, #32]
 800cb90:	7a1b      	ldrb	r3, [r3, #8]
 800cb92:	2b00      	cmp	r3, #0
 800cb94:	d009      	beq.n	800cbaa <tcp_input+0x5aa>
          (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 800cb96:	6a3b      	ldr	r3, [r7, #32]
 800cb98:	7a1a      	ldrb	r2, [r3, #8]
 800cb9a:	4b97      	ldr	r3, [pc, #604]	; (800cdf8 <tcp_input+0x7f8>)
 800cb9c:	685b      	ldr	r3, [r3, #4]
 800cb9e:	2134      	movs	r1, #52	; 0x34
 800cba0:	5c5b      	ldrb	r3, [r3, r1]
 800cba2:	3301      	adds	r3, #1
 800cba4:	b2db      	uxtb	r3, r3
      if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 800cba6:	429a      	cmp	r2, r3
 800cba8:	d12a      	bne.n	800cc00 <tcp_input+0x600>
        continue;
      }

      if (pcb->remote_port == tcphdr->src &&
 800cbaa:	6a3b      	ldr	r3, [r7, #32]
 800cbac:	8b9a      	ldrh	r2, [r3, #28]
 800cbae:	4b91      	ldr	r3, [pc, #580]	; (800cdf4 <tcp_input+0x7f4>)
 800cbb0:	681b      	ldr	r3, [r3, #0]
 800cbb2:	7819      	ldrb	r1, [r3, #0]
 800cbb4:	785b      	ldrb	r3, [r3, #1]
 800cbb6:	021b      	lsls	r3, r3, #8
 800cbb8:	430b      	orrs	r3, r1
 800cbba:	b29b      	uxth	r3, r3
 800cbbc:	429a      	cmp	r2, r3
 800cbbe:	d120      	bne.n	800cc02 <tcp_input+0x602>
          pcb->local_port == tcphdr->dest &&
 800cbc0:	6a3b      	ldr	r3, [r7, #32]
 800cbc2:	8b5a      	ldrh	r2, [r3, #26]
 800cbc4:	4b8b      	ldr	r3, [pc, #556]	; (800cdf4 <tcp_input+0x7f4>)
 800cbc6:	681b      	ldr	r3, [r3, #0]
 800cbc8:	7899      	ldrb	r1, [r3, #2]
 800cbca:	78db      	ldrb	r3, [r3, #3]
 800cbcc:	021b      	lsls	r3, r3, #8
 800cbce:	430b      	orrs	r3, r1
 800cbd0:	b29b      	uxth	r3, r3
      if (pcb->remote_port == tcphdr->src &&
 800cbd2:	429a      	cmp	r2, r3
 800cbd4:	d115      	bne.n	800cc02 <tcp_input+0x602>
          ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 800cbd6:	6a3b      	ldr	r3, [r7, #32]
 800cbd8:	685a      	ldr	r2, [r3, #4]
 800cbda:	4b87      	ldr	r3, [pc, #540]	; (800cdf8 <tcp_input+0x7f8>)
 800cbdc:	691b      	ldr	r3, [r3, #16]
          pcb->local_port == tcphdr->dest &&
 800cbde:	429a      	cmp	r2, r3
 800cbe0:	d10f      	bne.n	800cc02 <tcp_input+0x602>
          ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 800cbe2:	6a3b      	ldr	r3, [r7, #32]
 800cbe4:	681a      	ldr	r2, [r3, #0]
 800cbe6:	4b84      	ldr	r3, [pc, #528]	; (800cdf8 <tcp_input+0x7f8>)
 800cbe8:	695b      	ldr	r3, [r3, #20]
          ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 800cbea:	429a      	cmp	r2, r3
 800cbec:	d109      	bne.n	800cc02 <tcp_input+0x602>
#ifdef LWIP_HOOK_TCP_INPACKET_PCB
        if (LWIP_HOOK_TCP_INPACKET_PCB(pcb, tcphdr, tcphdr_optlen, tcphdr_opt1len,
                                       tcphdr_opt2, p) == ERR_OK)
#endif
        {
          tcp_timewait_input(pcb);
 800cbee:	6a3b      	ldr	r3, [r7, #32]
 800cbf0:	0018      	movs	r0, r3
 800cbf2:	f000 fbb5 	bl	800d360 <tcp_timewait_input>
        }
        pbuf_free(p);
 800cbf6:	687b      	ldr	r3, [r7, #4]
 800cbf8:	0018      	movs	r0, r3
 800cbfa:	f7fc ffe9 	bl	8009bd0 <pbuf_free>
        return;
 800cbfe:	e22f      	b.n	800d060 <tcp_input+0xa60>
        continue;
 800cc00:	46c0      	nop			; (mov r8, r8)
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800cc02:	6a3b      	ldr	r3, [r7, #32]
 800cc04:	691b      	ldr	r3, [r3, #16]
 800cc06:	623b      	str	r3, [r7, #32]
 800cc08:	6a3b      	ldr	r3, [r7, #32]
 800cc0a:	2b00      	cmp	r3, #0
 800cc0c:	d1b4      	bne.n	800cb78 <tcp_input+0x578>
      }
    }

    /* Finally, if we still did not get a match, we check all PCBs that
       are LISTENing for incoming connections. */
    prev = NULL;
 800cc0e:	2300      	movs	r3, #0
 800cc10:	627b      	str	r3, [r7, #36]	; 0x24
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 800cc12:	4b81      	ldr	r3, [pc, #516]	; (800ce18 <tcp_input+0x818>)
 800cc14:	681b      	ldr	r3, [r3, #0]
 800cc16:	61fb      	str	r3, [r7, #28]
 800cc18:	e031      	b.n	800cc7e <tcp_input+0x67e>
      /* check if PCB is bound to specific netif */
      if ((lpcb->netif_idx != NETIF_NO_INDEX) &&
 800cc1a:	69fb      	ldr	r3, [r7, #28]
 800cc1c:	7a1b      	ldrb	r3, [r3, #8]
 800cc1e:	2b00      	cmp	r3, #0
 800cc20:	d00c      	beq.n	800cc3c <tcp_input+0x63c>
          (lpcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 800cc22:	69fb      	ldr	r3, [r7, #28]
 800cc24:	7a1a      	ldrb	r2, [r3, #8]
 800cc26:	4b74      	ldr	r3, [pc, #464]	; (800cdf8 <tcp_input+0x7f8>)
 800cc28:	685b      	ldr	r3, [r3, #4]
 800cc2a:	2134      	movs	r1, #52	; 0x34
 800cc2c:	5c5b      	ldrb	r3, [r3, r1]
 800cc2e:	3301      	adds	r3, #1
 800cc30:	b2db      	uxtb	r3, r3
      if ((lpcb->netif_idx != NETIF_NO_INDEX) &&
 800cc32:	429a      	cmp	r2, r3
 800cc34:	d002      	beq.n	800cc3c <tcp_input+0x63c>
        prev = (struct tcp_pcb *)lpcb;
 800cc36:	69fb      	ldr	r3, [r7, #28]
 800cc38:	627b      	str	r3, [r7, #36]	; 0x24
        continue;
 800cc3a:	e01d      	b.n	800cc78 <tcp_input+0x678>
      }

      if (lpcb->local_port == tcphdr->dest) {
 800cc3c:	69fb      	ldr	r3, [r7, #28]
 800cc3e:	8b5a      	ldrh	r2, [r3, #26]
 800cc40:	4b6c      	ldr	r3, [pc, #432]	; (800cdf4 <tcp_input+0x7f4>)
 800cc42:	681b      	ldr	r3, [r3, #0]
 800cc44:	7899      	ldrb	r1, [r3, #2]
 800cc46:	78db      	ldrb	r3, [r3, #3]
 800cc48:	021b      	lsls	r3, r3, #8
 800cc4a:	430b      	orrs	r3, r1
 800cc4c:	b29b      	uxth	r3, r3
 800cc4e:	429a      	cmp	r2, r3
 800cc50:	d110      	bne.n	800cc74 <tcp_input+0x674>
          lpcb_prev = prev;
#else /* SO_REUSE */
          break;
#endif /* SO_REUSE */
        } else if (IP_ADDR_PCB_VERSION_MATCH_EXACT(lpcb, ip_current_dest_addr())) {
          if (ip_addr_cmp(&lpcb->local_ip, ip_current_dest_addr())) {
 800cc52:	69fb      	ldr	r3, [r7, #28]
 800cc54:	681a      	ldr	r2, [r3, #0]
 800cc56:	4b68      	ldr	r3, [pc, #416]	; (800cdf8 <tcp_input+0x7f8>)
 800cc58:	695b      	ldr	r3, [r3, #20]
 800cc5a:	429a      	cmp	r2, r3
 800cc5c:	d013      	beq.n	800cc86 <tcp_input+0x686>
            /* found an exact match */
            break;
          } else if (ip_addr_isany(&lpcb->local_ip)) {
 800cc5e:	69fb      	ldr	r3, [r7, #28]
 800cc60:	2b00      	cmp	r3, #0
 800cc62:	d003      	beq.n	800cc6c <tcp_input+0x66c>
 800cc64:	69fb      	ldr	r3, [r7, #28]
 800cc66:	681b      	ldr	r3, [r3, #0]
 800cc68:	2b00      	cmp	r3, #0
 800cc6a:	d103      	bne.n	800cc74 <tcp_input+0x674>
            /* found an ANY-match */
#if SO_REUSE
            lpcb_any = lpcb;
 800cc6c:	69fb      	ldr	r3, [r7, #28]
 800cc6e:	617b      	str	r3, [r7, #20]
            lpcb_prev = prev;
 800cc70:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cc72:	61bb      	str	r3, [r7, #24]
            break;
#endif /* SO_REUSE */
          }
        }
      }
      prev = (struct tcp_pcb *)lpcb;
 800cc74:	69fb      	ldr	r3, [r7, #28]
 800cc76:	627b      	str	r3, [r7, #36]	; 0x24
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 800cc78:	69fb      	ldr	r3, [r7, #28]
 800cc7a:	691b      	ldr	r3, [r3, #16]
 800cc7c:	61fb      	str	r3, [r7, #28]
 800cc7e:	69fb      	ldr	r3, [r7, #28]
 800cc80:	2b00      	cmp	r3, #0
 800cc82:	d1ca      	bne.n	800cc1a <tcp_input+0x61a>
 800cc84:	e000      	b.n	800cc88 <tcp_input+0x688>
            break;
 800cc86:	46c0      	nop			; (mov r8, r8)
    }
#if SO_REUSE
    /* first try specific local IP */
    if (lpcb == NULL) {
 800cc88:	69fb      	ldr	r3, [r7, #28]
 800cc8a:	2b00      	cmp	r3, #0
 800cc8c:	d103      	bne.n	800cc96 <tcp_input+0x696>
      /* only pass to ANY if no specific local IP has been found */
      lpcb = lpcb_any;
 800cc8e:	697b      	ldr	r3, [r7, #20]
 800cc90:	61fb      	str	r3, [r7, #28]
      prev = lpcb_prev;
 800cc92:	69bb      	ldr	r3, [r7, #24]
 800cc94:	627b      	str	r3, [r7, #36]	; 0x24
    }
#endif /* SO_REUSE */
    if (lpcb != NULL) {
 800cc96:	69fb      	ldr	r3, [r7, #28]
 800cc98:	2b00      	cmp	r3, #0
 800cc9a:	d016      	beq.n	800ccca <tcp_input+0x6ca>
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      if (prev != NULL) {
 800cc9c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cc9e:	2b00      	cmp	r3, #0
 800cca0:	d00a      	beq.n	800ccb8 <tcp_input+0x6b8>
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
 800cca2:	69fb      	ldr	r3, [r7, #28]
 800cca4:	691a      	ldr	r2, [r3, #16]
 800cca6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cca8:	611a      	str	r2, [r3, #16]
        /* our successor is the remainder of the listening list */
        lpcb->next = tcp_listen_pcbs.listen_pcbs;
 800ccaa:	4b5b      	ldr	r3, [pc, #364]	; (800ce18 <tcp_input+0x818>)
 800ccac:	681a      	ldr	r2, [r3, #0]
 800ccae:	69fb      	ldr	r3, [r7, #28]
 800ccb0:	611a      	str	r2, [r3, #16]
        /* put this listening pcb at the head of the listening list */
        tcp_listen_pcbs.listen_pcbs = lpcb;
 800ccb2:	4b59      	ldr	r3, [pc, #356]	; (800ce18 <tcp_input+0x818>)
 800ccb4:	69fa      	ldr	r2, [r7, #28]
 800ccb6:	601a      	str	r2, [r3, #0]
#ifdef LWIP_HOOK_TCP_INPACKET_PCB
      if (LWIP_HOOK_TCP_INPACKET_PCB((struct tcp_pcb *)lpcb, tcphdr, tcphdr_optlen,
                                     tcphdr_opt1len, tcphdr_opt2, p) == ERR_OK)
#endif
      {
        tcp_listen_input(lpcb);
 800ccb8:	69fb      	ldr	r3, [r7, #28]
 800ccba:	0018      	movs	r0, r3
 800ccbc:	f000 fa34 	bl	800d128 <tcp_listen_input>
      }
      pbuf_free(p);
 800ccc0:	687b      	ldr	r3, [r7, #4]
 800ccc2:	0018      	movs	r0, r3
 800ccc4:	f7fc ff84 	bl	8009bd0 <pbuf_free>
      return;
 800ccc8:	e1ca      	b.n	800d060 <tcp_input+0xa60>
      tcphdr_opt1len, tcphdr_opt2, p) != ERR_OK) {
    pbuf_free(p);
    return;
  }
#endif
  if (pcb != NULL) {
 800ccca:	6a3b      	ldr	r3, [r7, #32]
 800cccc:	2b00      	cmp	r3, #0
 800ccce:	d100      	bne.n	800ccd2 <tcp_input+0x6d2>
 800ccd0:	e17f      	b.n	800cfd2 <tcp_input+0x9d2>
#if TCP_INPUT_DEBUG
    tcp_debug_print_state(pcb->state);
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
 800ccd2:	4b52      	ldr	r3, [pc, #328]	; (800ce1c <tcp_input+0x81c>)
 800ccd4:	2200      	movs	r2, #0
 800ccd6:	601a      	str	r2, [r3, #0]
    inseg.len = p->tot_len;
 800ccd8:	687b      	ldr	r3, [r7, #4]
 800ccda:	891a      	ldrh	r2, [r3, #8]
 800ccdc:	4b4f      	ldr	r3, [pc, #316]	; (800ce1c <tcp_input+0x81c>)
 800ccde:	811a      	strh	r2, [r3, #8]
    inseg.p = p;
 800cce0:	4b4e      	ldr	r3, [pc, #312]	; (800ce1c <tcp_input+0x81c>)
 800cce2:	687a      	ldr	r2, [r7, #4]
 800cce4:	605a      	str	r2, [r3, #4]
    inseg.tcphdr = tcphdr;
 800cce6:	4b43      	ldr	r3, [pc, #268]	; (800cdf4 <tcp_input+0x7f4>)
 800cce8:	681a      	ldr	r2, [r3, #0]
 800ccea:	4b4c      	ldr	r3, [pc, #304]	; (800ce1c <tcp_input+0x81c>)
 800ccec:	611a      	str	r2, [r3, #16]

    recv_data = NULL;
 800ccee:	4b4c      	ldr	r3, [pc, #304]	; (800ce20 <tcp_input+0x820>)
 800ccf0:	2200      	movs	r2, #0
 800ccf2:	601a      	str	r2, [r3, #0]
    recv_flags = 0;
 800ccf4:	4b4b      	ldr	r3, [pc, #300]	; (800ce24 <tcp_input+0x824>)
 800ccf6:	2200      	movs	r2, #0
 800ccf8:	701a      	strb	r2, [r3, #0]
    recv_acked = 0;
 800ccfa:	4b4b      	ldr	r3, [pc, #300]	; (800ce28 <tcp_input+0x828>)
 800ccfc:	2200      	movs	r2, #0
 800ccfe:	801a      	strh	r2, [r3, #0]

    if (flags & TCP_PSH) {
 800cd00:	4b4a      	ldr	r3, [pc, #296]	; (800ce2c <tcp_input+0x82c>)
 800cd02:	781b      	ldrb	r3, [r3, #0]
 800cd04:	001a      	movs	r2, r3
 800cd06:	2308      	movs	r3, #8
 800cd08:	4013      	ands	r3, r2
 800cd0a:	d006      	beq.n	800cd1a <tcp_input+0x71a>
      p->flags |= PBUF_FLAG_PUSH;
 800cd0c:	687b      	ldr	r3, [r7, #4]
 800cd0e:	7b5b      	ldrb	r3, [r3, #13]
 800cd10:	2201      	movs	r2, #1
 800cd12:	4313      	orrs	r3, r2
 800cd14:	b2da      	uxtb	r2, r3
 800cd16:	687b      	ldr	r3, [r7, #4]
 800cd18:	735a      	strb	r2, [r3, #13]
    }

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
 800cd1a:	6a3b      	ldr	r3, [r7, #32]
 800cd1c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800cd1e:	2b00      	cmp	r3, #0
 800cd20:	d018      	beq.n	800cd54 <tcp_input+0x754>
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 800cd22:	6a3b      	ldr	r3, [r7, #32]
 800cd24:	0018      	movs	r0, r3
 800cd26:	f7fe ff23 	bl	800bb70 <tcp_process_refused_data>
 800cd2a:	0003      	movs	r3, r0
 800cd2c:	330d      	adds	r3, #13
 800cd2e:	d007      	beq.n	800cd40 <tcp_input+0x740>
          ((pcb->refused_data != NULL) && (tcplen > 0))) {
 800cd30:	6a3b      	ldr	r3, [r7, #32]
 800cd32:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 800cd34:	2b00      	cmp	r3, #0
 800cd36:	d00d      	beq.n	800cd54 <tcp_input+0x754>
          ((pcb->refused_data != NULL) && (tcplen > 0))) {
 800cd38:	4b3d      	ldr	r3, [pc, #244]	; (800ce30 <tcp_input+0x830>)
 800cd3a:	881b      	ldrh	r3, [r3, #0]
 800cd3c:	2b00      	cmp	r3, #0
 800cd3e:	d009      	beq.n	800cd54 <tcp_input+0x754>
        /* pcb has been aborted or refused data is still refused and the new
           segment contains data */
        if (pcb->rcv_ann_wnd == 0) {
 800cd40:	6a3b      	ldr	r3, [r7, #32]
 800cd42:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
 800cd44:	2b00      	cmp	r3, #0
 800cd46:	d000      	beq.n	800cd4a <tcp_input+0x74a>
 800cd48:	e123      	b.n	800cf92 <tcp_input+0x992>
          /* this is a zero-window probe, we respond to it with current RCV.NXT
          and drop the data segment */
          tcp_send_empty_ack(pcb);
 800cd4a:	6a3b      	ldr	r3, [r7, #32]
 800cd4c:	0018      	movs	r0, r3
 800cd4e:	f004 ff53 	bl	8011bf8 <tcp_send_empty_ack>
        }
        TCP_STATS_INC(tcp.drop);
        MIB2_STATS_INC(mib2.tcpinerrs);
        goto aborted;
 800cd52:	e11e      	b.n	800cf92 <tcp_input+0x992>
      }
    }
    tcp_input_pcb = pcb;
 800cd54:	4b37      	ldr	r3, [pc, #220]	; (800ce34 <tcp_input+0x834>)
 800cd56:	6a3a      	ldr	r2, [r7, #32]
 800cd58:	601a      	str	r2, [r3, #0]
    err = tcp_process(pcb);
 800cd5a:	2513      	movs	r5, #19
 800cd5c:	197c      	adds	r4, r7, r5
 800cd5e:	6a3b      	ldr	r3, [r7, #32]
 800cd60:	0018      	movs	r0, r3
 800cd62:	f000 fb81 	bl	800d468 <tcp_process>
 800cd66:	0003      	movs	r3, r0
 800cd68:	7023      	strb	r3, [r4, #0]
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
 800cd6a:	197b      	adds	r3, r7, r5
 800cd6c:	781b      	ldrb	r3, [r3, #0]
 800cd6e:	b25b      	sxtb	r3, r3
 800cd70:	330d      	adds	r3, #13
 800cd72:	d100      	bne.n	800cd76 <tcp_input+0x776>
 800cd74:	e10f      	b.n	800cf96 <tcp_input+0x996>
      if (recv_flags & TF_RESET) {
 800cd76:	4b2b      	ldr	r3, [pc, #172]	; (800ce24 <tcp_input+0x824>)
 800cd78:	781b      	ldrb	r3, [r3, #0]
 800cd7a:	001a      	movs	r2, r3
 800cd7c:	2308      	movs	r3, #8
 800cd7e:	4013      	ands	r3, r2
 800cd80:	d018      	beq.n	800cdb4 <tcp_input+0x7b4>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_RST);
 800cd82:	6a3b      	ldr	r3, [r7, #32]
 800cd84:	2294      	movs	r2, #148	; 0x94
 800cd86:	589b      	ldr	r3, [r3, r2]
 800cd88:	2b00      	cmp	r3, #0
 800cd8a:	d008      	beq.n	800cd9e <tcp_input+0x79e>
 800cd8c:	6a3b      	ldr	r3, [r7, #32]
 800cd8e:	2294      	movs	r2, #148	; 0x94
 800cd90:	589a      	ldr	r2, [r3, r2]
 800cd92:	6a3b      	ldr	r3, [r7, #32]
 800cd94:	695b      	ldr	r3, [r3, #20]
 800cd96:	210e      	movs	r1, #14
 800cd98:	4249      	negs	r1, r1
 800cd9a:	0018      	movs	r0, r3
 800cd9c:	4790      	blx	r2
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
 800cd9e:	6a3a      	ldr	r2, [r7, #32]
 800cda0:	4b19      	ldr	r3, [pc, #100]	; (800ce08 <tcp_input+0x808>)
 800cda2:	0011      	movs	r1, r2
 800cda4:	0018      	movs	r0, r3
 800cda6:	f7ff fa91 	bl	800c2cc <tcp_pcb_remove>
        tcp_free(pcb);
 800cdaa:	6a3b      	ldr	r3, [r7, #32]
 800cdac:	0018      	movs	r0, r3
 800cdae:	f7fd fd65 	bl	800a87c <tcp_free>
 800cdb2:	e0fb      	b.n	800cfac <tcp_input+0x9ac>
      } else {
        err = ERR_OK;
 800cdb4:	2113      	movs	r1, #19
 800cdb6:	187b      	adds	r3, r7, r1
 800cdb8:	2200      	movs	r2, #0
 800cdba:	701a      	strb	r2, [r3, #0]
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (recv_acked > 0) {
 800cdbc:	4b1a      	ldr	r3, [pc, #104]	; (800ce28 <tcp_input+0x828>)
 800cdbe:	881b      	ldrh	r3, [r3, #0]
 800cdc0:	2b00      	cmp	r3, #0
 800cdc2:	d047      	beq.n	800ce54 <tcp_input+0x854>
          while (acked > 0) {
            acked16 = (u16_t)LWIP_MIN(acked, 0xffffu);
            acked -= acked16;
#else
          {
            acked16 = recv_acked;
 800cdc4:	260a      	movs	r6, #10
 800cdc6:	19bb      	adds	r3, r7, r6
 800cdc8:	4a17      	ldr	r2, [pc, #92]	; (800ce28 <tcp_input+0x828>)
 800cdca:	8812      	ldrh	r2, [r2, #0]
 800cdcc:	801a      	strh	r2, [r3, #0]
#endif
            TCP_EVENT_SENT(pcb, (u16_t)acked16, err);
 800cdce:	6a3b      	ldr	r3, [r7, #32]
 800cdd0:	2284      	movs	r2, #132	; 0x84
 800cdd2:	589b      	ldr	r3, [r3, r2]
 800cdd4:	2b00      	cmp	r3, #0
 800cdd6:	d02f      	beq.n	800ce38 <tcp_input+0x838>
 800cdd8:	6a3b      	ldr	r3, [r7, #32]
 800cdda:	2284      	movs	r2, #132	; 0x84
 800cddc:	589d      	ldr	r5, [r3, r2]
 800cdde:	6a3b      	ldr	r3, [r7, #32]
 800cde0:	6958      	ldr	r0, [r3, #20]
 800cde2:	187c      	adds	r4, r7, r1
 800cde4:	19bb      	adds	r3, r7, r6
 800cde6:	881a      	ldrh	r2, [r3, #0]
 800cde8:	6a3b      	ldr	r3, [r7, #32]
 800cdea:	0019      	movs	r1, r3
 800cdec:	47a8      	blx	r5
 800cdee:	0003      	movs	r3, r0
 800cdf0:	7023      	strb	r3, [r4, #0]
 800cdf2:	e025      	b.n	800ce40 <tcp_input+0x840>
 800cdf4:	20001b40 	.word	0x20001b40
 800cdf8:	20001c94 	.word	0x20001c94
 800cdfc:	080201e0 	.word	0x080201e0
 800ce00:	08020304 	.word	0x08020304
 800ce04:	08020220 	.word	0x08020220
 800ce08:	20002ed4 	.word	0x20002ed4
 800ce0c:	08020330 	.word	0x08020330
 800ce10:	20002ee4 	.word	0x20002ee4
 800ce14:	0802035c 	.word	0x0802035c
 800ce18:	20002edc 	.word	0x20002edc
 800ce1c:	20001b2c 	.word	0x20001b2c
 800ce20:	20001b60 	.word	0x20001b60
 800ce24:	20001b5d 	.word	0x20001b5d
 800ce28:	20001b58 	.word	0x20001b58
 800ce2c:	20001b5c 	.word	0x20001b5c
 800ce30:	20001b5a 	.word	0x20001b5a
 800ce34:	20002ee8 	.word	0x20002ee8
 800ce38:	2313      	movs	r3, #19
 800ce3a:	18fb      	adds	r3, r7, r3
 800ce3c:	2200      	movs	r2, #0
 800ce3e:	701a      	strb	r2, [r3, #0]
            if (err == ERR_ABRT) {
 800ce40:	2313      	movs	r3, #19
 800ce42:	18fb      	adds	r3, r7, r3
 800ce44:	781b      	ldrb	r3, [r3, #0]
 800ce46:	b25b      	sxtb	r3, r3
 800ce48:	330d      	adds	r3, #13
 800ce4a:	d100      	bne.n	800ce4e <tcp_input+0x84e>
 800ce4c:	e0a5      	b.n	800cf9a <tcp_input+0x99a>
              goto aborted;
            }
          }
          recv_acked = 0;
 800ce4e:	4b86      	ldr	r3, [pc, #536]	; (800d068 <tcp_input+0xa68>)
 800ce50:	2200      	movs	r2, #0
 800ce52:	801a      	strh	r2, [r3, #0]
        }
        if (tcp_input_delayed_close(pcb)) {
 800ce54:	6a3b      	ldr	r3, [r7, #32]
 800ce56:	0018      	movs	r0, r3
 800ce58:	f000 f922 	bl	800d0a0 <tcp_input_delayed_close>
 800ce5c:	1e03      	subs	r3, r0, #0
 800ce5e:	d000      	beq.n	800ce62 <tcp_input+0x862>
 800ce60:	e09d      	b.n	800cf9e <tcp_input+0x99e>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
        while (recv_data != NULL) {
          struct pbuf *rest = NULL;
          pbuf_split_64k(recv_data, &rest);
#else /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
        if (recv_data != NULL) {
 800ce62:	4b82      	ldr	r3, [pc, #520]	; (800d06c <tcp_input+0xa6c>)
 800ce64:	681b      	ldr	r3, [r3, #0]
 800ce66:	2b00      	cmp	r3, #0
 800ce68:	d048      	beq.n	800cefc <tcp_input+0x8fc>
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */

          LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
 800ce6a:	6a3b      	ldr	r3, [r7, #32]
 800ce6c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800ce6e:	2b00      	cmp	r3, #0
 800ce70:	d006      	beq.n	800ce80 <tcp_input+0x880>
 800ce72:	4b7f      	ldr	r3, [pc, #508]	; (800d070 <tcp_input+0xa70>)
 800ce74:	22f3      	movs	r2, #243	; 0xf3
 800ce76:	0052      	lsls	r2, r2, #1
 800ce78:	497e      	ldr	r1, [pc, #504]	; (800d074 <tcp_input+0xa74>)
 800ce7a:	487f      	ldr	r0, [pc, #508]	; (800d078 <tcp_input+0xa78>)
 800ce7c:	f7f5 fd2e 	bl	80028dc <app_debug_rtt_raw>
          if (pcb->flags & TF_RXCLOSED) {
 800ce80:	6a3b      	ldr	r3, [r7, #32]
 800ce82:	8bdb      	ldrh	r3, [r3, #30]
 800ce84:	001a      	movs	r2, r3
 800ce86:	2310      	movs	r3, #16
 800ce88:	4013      	ands	r3, r2
 800ce8a:	d009      	beq.n	800cea0 <tcp_input+0x8a0>
            /* received data although already closed -> abort (send RST) to
               notify the remote host that not all data has been processed */
            pbuf_free(recv_data);
 800ce8c:	4b77      	ldr	r3, [pc, #476]	; (800d06c <tcp_input+0xa6c>)
 800ce8e:	681b      	ldr	r3, [r3, #0]
 800ce90:	0018      	movs	r0, r3
 800ce92:	f7fc fe9d 	bl	8009bd0 <pbuf_free>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
            if (rest != NULL) {
              pbuf_free(rest);
            }
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
            tcp_abort(pcb);
 800ce96:	6a3b      	ldr	r3, [r7, #32]
 800ce98:	0018      	movs	r0, r3
 800ce9a:	f7fe f805 	bl	800aea8 <tcp_abort>
            goto aborted;
 800ce9e:	e085      	b.n	800cfac <tcp_input+0x9ac>
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 800cea0:	6a3b      	ldr	r3, [r7, #32]
 800cea2:	2288      	movs	r2, #136	; 0x88
 800cea4:	589b      	ldr	r3, [r3, r2]
 800cea6:	2b00      	cmp	r3, #0
 800cea8:	d00e      	beq.n	800cec8 <tcp_input+0x8c8>
 800ceaa:	6a3b      	ldr	r3, [r7, #32]
 800ceac:	2288      	movs	r2, #136	; 0x88
 800ceae:	589d      	ldr	r5, [r3, r2]
 800ceb0:	6a3b      	ldr	r3, [r7, #32]
 800ceb2:	6958      	ldr	r0, [r3, #20]
 800ceb4:	4b6d      	ldr	r3, [pc, #436]	; (800d06c <tcp_input+0xa6c>)
 800ceb6:	681a      	ldr	r2, [r3, #0]
 800ceb8:	2313      	movs	r3, #19
 800ceba:	18fc      	adds	r4, r7, r3
 800cebc:	6a39      	ldr	r1, [r7, #32]
 800cebe:	2300      	movs	r3, #0
 800cec0:	47a8      	blx	r5
 800cec2:	0003      	movs	r3, r0
 800cec4:	7023      	strb	r3, [r4, #0]
 800cec6:	e00a      	b.n	800cede <tcp_input+0x8de>
 800cec8:	4b68      	ldr	r3, [pc, #416]	; (800d06c <tcp_input+0xa6c>)
 800ceca:	681a      	ldr	r2, [r3, #0]
 800cecc:	2313      	movs	r3, #19
 800cece:	18fc      	adds	r4, r7, r3
 800ced0:	6a39      	ldr	r1, [r7, #32]
 800ced2:	2300      	movs	r3, #0
 800ced4:	2000      	movs	r0, #0
 800ced6:	f7fe ff31 	bl	800bd3c <tcp_recv_null>
 800ceda:	0003      	movs	r3, r0
 800cedc:	7023      	strb	r3, [r4, #0]
          if (err == ERR_ABRT) {
 800cede:	2213      	movs	r2, #19
 800cee0:	18bb      	adds	r3, r7, r2
 800cee2:	781b      	ldrb	r3, [r3, #0]
 800cee4:	b25b      	sxtb	r3, r3
 800cee6:	330d      	adds	r3, #13
 800cee8:	d05b      	beq.n	800cfa2 <tcp_input+0x9a2>
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
            goto aborted;
          }

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
 800ceea:	18bb      	adds	r3, r7, r2
 800ceec:	781b      	ldrb	r3, [r3, #0]
 800ceee:	b25b      	sxtb	r3, r3
 800cef0:	2b00      	cmp	r3, #0
 800cef2:	d003      	beq.n	800cefc <tcp_input+0x8fc>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
            if (rest != NULL) {
              pbuf_cat(recv_data, rest);
            }
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
            pcb->refused_data = recv_data;
 800cef4:	4b5d      	ldr	r3, [pc, #372]	; (800d06c <tcp_input+0xa6c>)
 800cef6:	681a      	ldr	r2, [r3, #0]
 800cef8:	6a3b      	ldr	r3, [r7, #32]
 800cefa:	67da      	str	r2, [r3, #124]	; 0x7c
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
 800cefc:	4b5f      	ldr	r3, [pc, #380]	; (800d07c <tcp_input+0xa7c>)
 800cefe:	781b      	ldrb	r3, [r3, #0]
 800cf00:	001a      	movs	r2, r3
 800cf02:	2320      	movs	r3, #32
 800cf04:	4013      	ands	r3, r2
 800cf06:	d036      	beq.n	800cf76 <tcp_input+0x976>
          if (pcb->refused_data != NULL) {
 800cf08:	6a3b      	ldr	r3, [r7, #32]
 800cf0a:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800cf0c:	2b00      	cmp	r3, #0
 800cf0e:	d009      	beq.n	800cf24 <tcp_input+0x924>
            /* Delay this if we have refused data. */
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
 800cf10:	6a3b      	ldr	r3, [r7, #32]
 800cf12:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800cf14:	7b5a      	ldrb	r2, [r3, #13]
 800cf16:	6a3b      	ldr	r3, [r7, #32]
 800cf18:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800cf1a:	2120      	movs	r1, #32
 800cf1c:	430a      	orrs	r2, r1
 800cf1e:	b2d2      	uxtb	r2, r2
 800cf20:	735a      	strb	r2, [r3, #13]
 800cf22:	e028      	b.n	800cf76 <tcp_input+0x976>
          } else {
            /* correct rcv_wnd as the application won't call tcp_recved()
               for the FIN's seqno */
            if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
 800cf24:	6a3b      	ldr	r3, [r7, #32]
 800cf26:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800cf28:	2386      	movs	r3, #134	; 0x86
 800cf2a:	00db      	lsls	r3, r3, #3
 800cf2c:	429a      	cmp	r2, r3
 800cf2e:	d005      	beq.n	800cf3c <tcp_input+0x93c>
              pcb->rcv_wnd++;
 800cf30:	6a3b      	ldr	r3, [r7, #32]
 800cf32:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 800cf34:	3301      	adds	r3, #1
 800cf36:	b29a      	uxth	r2, r3
 800cf38:	6a3b      	ldr	r3, [r7, #32]
 800cf3a:	859a      	strh	r2, [r3, #44]	; 0x2c
            }
            TCP_EVENT_CLOSED(pcb, err);
 800cf3c:	6a3b      	ldr	r3, [r7, #32]
 800cf3e:	2288      	movs	r2, #136	; 0x88
 800cf40:	589b      	ldr	r3, [r3, r2]
 800cf42:	2b00      	cmp	r3, #0
 800cf44:	d00d      	beq.n	800cf62 <tcp_input+0x962>
 800cf46:	6a3b      	ldr	r3, [r7, #32]
 800cf48:	2288      	movs	r2, #136	; 0x88
 800cf4a:	589d      	ldr	r5, [r3, r2]
 800cf4c:	6a3b      	ldr	r3, [r7, #32]
 800cf4e:	6958      	ldr	r0, [r3, #20]
 800cf50:	2313      	movs	r3, #19
 800cf52:	18fc      	adds	r4, r7, r3
 800cf54:	6a39      	ldr	r1, [r7, #32]
 800cf56:	2300      	movs	r3, #0
 800cf58:	2200      	movs	r2, #0
 800cf5a:	47a8      	blx	r5
 800cf5c:	0003      	movs	r3, r0
 800cf5e:	7023      	strb	r3, [r4, #0]
 800cf60:	e003      	b.n	800cf6a <tcp_input+0x96a>
 800cf62:	2313      	movs	r3, #19
 800cf64:	18fb      	adds	r3, r7, r3
 800cf66:	2200      	movs	r2, #0
 800cf68:	701a      	strb	r2, [r3, #0]
            if (err == ERR_ABRT) {
 800cf6a:	2313      	movs	r3, #19
 800cf6c:	18fb      	adds	r3, r7, r3
 800cf6e:	781b      	ldrb	r3, [r3, #0]
 800cf70:	b25b      	sxtb	r3, r3
 800cf72:	330d      	adds	r3, #13
 800cf74:	d017      	beq.n	800cfa6 <tcp_input+0x9a6>
              goto aborted;
            }
          }
        }

        tcp_input_pcb = NULL;
 800cf76:	4b42      	ldr	r3, [pc, #264]	; (800d080 <tcp_input+0xa80>)
 800cf78:	2200      	movs	r2, #0
 800cf7a:	601a      	str	r2, [r3, #0]
        if (tcp_input_delayed_close(pcb)) {
 800cf7c:	6a3b      	ldr	r3, [r7, #32]
 800cf7e:	0018      	movs	r0, r3
 800cf80:	f000 f88e 	bl	800d0a0 <tcp_input_delayed_close>
 800cf84:	1e03      	subs	r3, r0, #0
 800cf86:	d110      	bne.n	800cfaa <tcp_input+0x9aa>
          goto aborted;
        }
        /* Try to send something out. */
        tcp_output(pcb);
 800cf88:	6a3b      	ldr	r3, [r7, #32]
 800cf8a:	0018      	movs	r0, r3
 800cf8c:	f003 fd80 	bl	8010a90 <tcp_output>
 800cf90:	e00c      	b.n	800cfac <tcp_input+0x9ac>
        goto aborted;
 800cf92:	46c0      	nop			; (mov r8, r8)
 800cf94:	e00a      	b.n	800cfac <tcp_input+0x9ac>
#endif /* TCP_INPUT_DEBUG */
      }
    }
    /* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).
       Below this line, 'pcb' may not be dereferenced! */
aborted:
 800cf96:	46c0      	nop			; (mov r8, r8)
 800cf98:	e008      	b.n	800cfac <tcp_input+0x9ac>
              goto aborted;
 800cf9a:	46c0      	nop			; (mov r8, r8)
 800cf9c:	e006      	b.n	800cfac <tcp_input+0x9ac>
          goto aborted;
 800cf9e:	46c0      	nop			; (mov r8, r8)
 800cfa0:	e004      	b.n	800cfac <tcp_input+0x9ac>
            goto aborted;
 800cfa2:	46c0      	nop			; (mov r8, r8)
 800cfa4:	e002      	b.n	800cfac <tcp_input+0x9ac>
              goto aborted;
 800cfa6:	46c0      	nop			; (mov r8, r8)
 800cfa8:	e000      	b.n	800cfac <tcp_input+0x9ac>
          goto aborted;
 800cfaa:	46c0      	nop			; (mov r8, r8)
    tcp_input_pcb = NULL;
 800cfac:	4b34      	ldr	r3, [pc, #208]	; (800d080 <tcp_input+0xa80>)
 800cfae:	2200      	movs	r2, #0
 800cfb0:	601a      	str	r2, [r3, #0]
    recv_data = NULL;
 800cfb2:	4b2e      	ldr	r3, [pc, #184]	; (800d06c <tcp_input+0xa6c>)
 800cfb4:	2200      	movs	r2, #0
 800cfb6:	601a      	str	r2, [r3, #0]

    /* give up our reference to inseg.p */
    if (inseg.p != NULL) {
 800cfb8:	4b32      	ldr	r3, [pc, #200]	; (800d084 <tcp_input+0xa84>)
 800cfba:	685b      	ldr	r3, [r3, #4]
 800cfbc:	2b00      	cmp	r3, #0
 800cfbe:	d04e      	beq.n	800d05e <tcp_input+0xa5e>
      pbuf_free(inseg.p);
 800cfc0:	4b30      	ldr	r3, [pc, #192]	; (800d084 <tcp_input+0xa84>)
 800cfc2:	685b      	ldr	r3, [r3, #4]
 800cfc4:	0018      	movs	r0, r3
 800cfc6:	f7fc fe03 	bl	8009bd0 <pbuf_free>
      inseg.p = NULL;
 800cfca:	4b2e      	ldr	r3, [pc, #184]	; (800d084 <tcp_input+0xa84>)
 800cfcc:	2200      	movs	r2, #0
 800cfce:	605a      	str	r2, [r3, #4]
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
 800cfd0:	e045      	b.n	800d05e <tcp_input+0xa5e>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
 800cfd2:	4b2d      	ldr	r3, [pc, #180]	; (800d088 <tcp_input+0xa88>)
 800cfd4:	681b      	ldr	r3, [r3, #0]
 800cfd6:	7b1a      	ldrb	r2, [r3, #12]
 800cfd8:	7b5b      	ldrb	r3, [r3, #13]
 800cfda:	021b      	lsls	r3, r3, #8
 800cfdc:	4313      	orrs	r3, r2
 800cfde:	b29b      	uxth	r3, r3
 800cfe0:	0018      	movs	r0, r3
 800cfe2:	f7f9 fe11 	bl	8006c08 <lwip_htons>
 800cfe6:	0003      	movs	r3, r0
 800cfe8:	b2db      	uxtb	r3, r3
 800cfea:	001a      	movs	r2, r3
 800cfec:	2304      	movs	r3, #4
 800cfee:	4013      	ands	r3, r2
 800cff0:	d120      	bne.n	800d034 <tcp_input+0xa34>
      tcp_rst(NULL, ackno, seqno + tcplen, ip_current_dest_addr(),
 800cff2:	4b26      	ldr	r3, [pc, #152]	; (800d08c <tcp_input+0xa8c>)
 800cff4:	6818      	ldr	r0, [r3, #0]
 800cff6:	4b26      	ldr	r3, [pc, #152]	; (800d090 <tcp_input+0xa90>)
 800cff8:	881b      	ldrh	r3, [r3, #0]
 800cffa:	001a      	movs	r2, r3
 800cffc:	4b25      	ldr	r3, [pc, #148]	; (800d094 <tcp_input+0xa94>)
 800cffe:	681b      	ldr	r3, [r3, #0]
 800d000:	18d4      	adds	r4, r2, r3
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800d002:	4b21      	ldr	r3, [pc, #132]	; (800d088 <tcp_input+0xa88>)
 800d004:	681b      	ldr	r3, [r3, #0]
      tcp_rst(NULL, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d006:	789a      	ldrb	r2, [r3, #2]
 800d008:	78db      	ldrb	r3, [r3, #3]
 800d00a:	021b      	lsls	r3, r3, #8
 800d00c:	4313      	orrs	r3, r2
 800d00e:	b29a      	uxth	r2, r3
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800d010:	4b1d      	ldr	r3, [pc, #116]	; (800d088 <tcp_input+0xa88>)
 800d012:	681b      	ldr	r3, [r3, #0]
      tcp_rst(NULL, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d014:	7819      	ldrb	r1, [r3, #0]
 800d016:	785b      	ldrb	r3, [r3, #1]
 800d018:	021b      	lsls	r3, r3, #8
 800d01a:	430b      	orrs	r3, r1
 800d01c:	b29b      	uxth	r3, r3
 800d01e:	491e      	ldr	r1, [pc, #120]	; (800d098 <tcp_input+0xa98>)
 800d020:	9302      	str	r3, [sp, #8]
 800d022:	9201      	str	r2, [sp, #4]
 800d024:	4b1d      	ldr	r3, [pc, #116]	; (800d09c <tcp_input+0xa9c>)
 800d026:	9300      	str	r3, [sp, #0]
 800d028:	000b      	movs	r3, r1
 800d02a:	0022      	movs	r2, r4
 800d02c:	0001      	movs	r1, r0
 800d02e:	2000      	movs	r0, #0
 800d030:	f004 fd82 	bl	8011b38 <tcp_rst>
    pbuf_free(p);
 800d034:	687b      	ldr	r3, [r7, #4]
 800d036:	0018      	movs	r0, r3
 800d038:	f7fc fdca 	bl	8009bd0 <pbuf_free>
  return;
 800d03c:	e00f      	b.n	800d05e <tcp_input+0xa5e>
    goto dropped;
 800d03e:	46c0      	nop			; (mov r8, r8)
 800d040:	e008      	b.n	800d054 <tcp_input+0xa54>
    goto dropped;
 800d042:	46c0      	nop			; (mov r8, r8)
 800d044:	e006      	b.n	800d054 <tcp_input+0xa54>
      goto dropped;
 800d046:	46c0      	nop			; (mov r8, r8)
 800d048:	e004      	b.n	800d054 <tcp_input+0xa54>
    goto dropped;
 800d04a:	46c0      	nop			; (mov r8, r8)
 800d04c:	e002      	b.n	800d054 <tcp_input+0xa54>
      goto dropped;
 800d04e:	46c0      	nop			; (mov r8, r8)
 800d050:	e000      	b.n	800d054 <tcp_input+0xa54>
      goto dropped;
 800d052:	46c0      	nop			; (mov r8, r8)
dropped:
  TCP_STATS_INC(tcp.drop);
  MIB2_STATS_INC(mib2.tcpinerrs);
  pbuf_free(p);
 800d054:	687b      	ldr	r3, [r7, #4]
 800d056:	0018      	movs	r0, r3
 800d058:	f7fc fdba 	bl	8009bd0 <pbuf_free>
 800d05c:	e000      	b.n	800d060 <tcp_input+0xa60>
  return;
 800d05e:	46c0      	nop			; (mov r8, r8)
}
 800d060:	46bd      	mov	sp, r7
 800d062:	b00b      	add	sp, #44	; 0x2c
 800d064:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800d066:	46c0      	nop			; (mov r8, r8)
 800d068:	20001b58 	.word	0x20001b58
 800d06c:	20001b60 	.word	0x20001b60
 800d070:	080201e0 	.word	0x080201e0
 800d074:	0802038c 	.word	0x0802038c
 800d078:	08020220 	.word	0x08020220
 800d07c:	20001b5d 	.word	0x20001b5d
 800d080:	20002ee8 	.word	0x20002ee8
 800d084:	20001b2c 	.word	0x20001b2c
 800d088:	20001b40 	.word	0x20001b40
 800d08c:	20001b54 	.word	0x20001b54
 800d090:	20001b5a 	.word	0x20001b5a
 800d094:	20001b50 	.word	0x20001b50
 800d098:	20001ca8 	.word	0x20001ca8
 800d09c:	20001ca4 	.word	0x20001ca4

0800d0a0 <tcp_input_delayed_close>:
 * any more.
 * @returns 1 if the pcb has been closed and deallocated, 0 otherwise
 */
static int
tcp_input_delayed_close(struct tcp_pcb *pcb)
{
 800d0a0:	b580      	push	{r7, lr}
 800d0a2:	b082      	sub	sp, #8
 800d0a4:	af00      	add	r7, sp, #0
 800d0a6:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_input_delayed_close: invalid pcb", pcb != NULL);
 800d0a8:	687b      	ldr	r3, [r7, #4]
 800d0aa:	2b00      	cmp	r3, #0
 800d0ac:	d105      	bne.n	800d0ba <tcp_input_delayed_close+0x1a>
 800d0ae:	4b18      	ldr	r3, [pc, #96]	; (800d110 <tcp_input_delayed_close+0x70>)
 800d0b0:	4a18      	ldr	r2, [pc, #96]	; (800d114 <tcp_input_delayed_close+0x74>)
 800d0b2:	4919      	ldr	r1, [pc, #100]	; (800d118 <tcp_input_delayed_close+0x78>)
 800d0b4:	4819      	ldr	r0, [pc, #100]	; (800d11c <tcp_input_delayed_close+0x7c>)
 800d0b6:	f7f5 fc11 	bl	80028dc <app_debug_rtt_raw>

  if (recv_flags & TF_CLOSED) {
 800d0ba:	4b19      	ldr	r3, [pc, #100]	; (800d120 <tcp_input_delayed_close+0x80>)
 800d0bc:	781b      	ldrb	r3, [r3, #0]
 800d0be:	001a      	movs	r2, r3
 800d0c0:	2310      	movs	r3, #16
 800d0c2:	4013      	ands	r3, r2
 800d0c4:	d01f      	beq.n	800d106 <tcp_input_delayed_close+0x66>
    /* The connection has been closed and we will deallocate the
        PCB. */
    if (!(pcb->flags & TF_RXCLOSED)) {
 800d0c6:	687b      	ldr	r3, [r7, #4]
 800d0c8:	8bdb      	ldrh	r3, [r3, #30]
 800d0ca:	001a      	movs	r2, r3
 800d0cc:	2310      	movs	r3, #16
 800d0ce:	4013      	ands	r3, r2
 800d0d0:	d10d      	bne.n	800d0ee <tcp_input_delayed_close+0x4e>
      /* Connection closed although the application has only shut down the
          tx side: call the PCB's err callback and indicate the closure to
          ensure the application doesn't continue using the PCB. */
      TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_CLSD);
 800d0d2:	687b      	ldr	r3, [r7, #4]
 800d0d4:	2294      	movs	r2, #148	; 0x94
 800d0d6:	589b      	ldr	r3, [r3, r2]
 800d0d8:	2b00      	cmp	r3, #0
 800d0da:	d008      	beq.n	800d0ee <tcp_input_delayed_close+0x4e>
 800d0dc:	687b      	ldr	r3, [r7, #4]
 800d0de:	2294      	movs	r2, #148	; 0x94
 800d0e0:	589a      	ldr	r2, [r3, r2]
 800d0e2:	687b      	ldr	r3, [r7, #4]
 800d0e4:	695b      	ldr	r3, [r3, #20]
 800d0e6:	210f      	movs	r1, #15
 800d0e8:	4249      	negs	r1, r1
 800d0ea:	0018      	movs	r0, r3
 800d0ec:	4790      	blx	r2
    }
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
 800d0ee:	687a      	ldr	r2, [r7, #4]
 800d0f0:	4b0c      	ldr	r3, [pc, #48]	; (800d124 <tcp_input_delayed_close+0x84>)
 800d0f2:	0011      	movs	r1, r2
 800d0f4:	0018      	movs	r0, r3
 800d0f6:	f7ff f8e9 	bl	800c2cc <tcp_pcb_remove>
    tcp_free(pcb);
 800d0fa:	687b      	ldr	r3, [r7, #4]
 800d0fc:	0018      	movs	r0, r3
 800d0fe:	f7fd fbbd 	bl	800a87c <tcp_free>
    return 1;
 800d102:	2301      	movs	r3, #1
 800d104:	e000      	b.n	800d108 <tcp_input_delayed_close+0x68>
  }
  return 0;
 800d106:	2300      	movs	r3, #0
}
 800d108:	0018      	movs	r0, r3
 800d10a:	46bd      	mov	sp, r7
 800d10c:	b002      	add	sp, #8
 800d10e:	bd80      	pop	{r7, pc}
 800d110:	080201e0 	.word	0x080201e0
 800d114:	0000025a 	.word	0x0000025a
 800d118:	080203a8 	.word	0x080203a8
 800d11c:	08020220 	.word	0x08020220
 800d120:	20001b5d 	.word	0x20001b5d
 800d124:	20002ed4 	.word	0x20002ed4

0800d128 <tcp_listen_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static void
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
 800d128:	b5b0      	push	{r4, r5, r7, lr}
 800d12a:	b08a      	sub	sp, #40	; 0x28
 800d12c:	af04      	add	r7, sp, #16
 800d12e:	6078      	str	r0, [r7, #4]
  struct tcp_pcb *npcb;
  u32_t iss;
  err_t rc;

  if (flags & TCP_RST) {
 800d130:	4b7d      	ldr	r3, [pc, #500]	; (800d328 <tcp_listen_input+0x200>)
 800d132:	781b      	ldrb	r3, [r3, #0]
 800d134:	001a      	movs	r2, r3
 800d136:	2304      	movs	r3, #4
 800d138:	4013      	ands	r3, r2
 800d13a:	d000      	beq.n	800d13e <tcp_listen_input+0x16>
 800d13c:	e0ee      	b.n	800d31c <tcp_listen_input+0x1f4>
    /* An incoming RST should be ignored. Return. */
    return;
  }

  LWIP_ASSERT("tcp_listen_input: invalid pcb", pcb != NULL);
 800d13e:	687b      	ldr	r3, [r7, #4]
 800d140:	2b00      	cmp	r3, #0
 800d142:	d105      	bne.n	800d150 <tcp_listen_input+0x28>
 800d144:	4b79      	ldr	r3, [pc, #484]	; (800d32c <tcp_listen_input+0x204>)
 800d146:	4a7a      	ldr	r2, [pc, #488]	; (800d330 <tcp_listen_input+0x208>)
 800d148:	497a      	ldr	r1, [pc, #488]	; (800d334 <tcp_listen_input+0x20c>)
 800d14a:	487b      	ldr	r0, [pc, #492]	; (800d338 <tcp_listen_input+0x210>)
 800d14c:	f7f5 fbc6 	bl	80028dc <app_debug_rtt_raw>

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
 800d150:	4b75      	ldr	r3, [pc, #468]	; (800d328 <tcp_listen_input+0x200>)
 800d152:	781b      	ldrb	r3, [r3, #0]
 800d154:	001a      	movs	r2, r3
 800d156:	2310      	movs	r3, #16
 800d158:	4013      	ands	r3, r2
 800d15a:	d021      	beq.n	800d1a0 <tcp_listen_input+0x78>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst((const struct tcp_pcb *)pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d15c:	4b77      	ldr	r3, [pc, #476]	; (800d33c <tcp_listen_input+0x214>)
 800d15e:	681c      	ldr	r4, [r3, #0]
 800d160:	4b77      	ldr	r3, [pc, #476]	; (800d340 <tcp_listen_input+0x218>)
 800d162:	881b      	ldrh	r3, [r3, #0]
 800d164:	001a      	movs	r2, r3
 800d166:	4b77      	ldr	r3, [pc, #476]	; (800d344 <tcp_listen_input+0x21c>)
 800d168:	681b      	ldr	r3, [r3, #0]
 800d16a:	18d5      	adds	r5, r2, r3
            ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800d16c:	4b76      	ldr	r3, [pc, #472]	; (800d348 <tcp_listen_input+0x220>)
 800d16e:	681b      	ldr	r3, [r3, #0]
    tcp_rst((const struct tcp_pcb *)pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d170:	789a      	ldrb	r2, [r3, #2]
 800d172:	78db      	ldrb	r3, [r3, #3]
 800d174:	021b      	lsls	r3, r3, #8
 800d176:	4313      	orrs	r3, r2
 800d178:	b29a      	uxth	r2, r3
            ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800d17a:	4b73      	ldr	r3, [pc, #460]	; (800d348 <tcp_listen_input+0x220>)
 800d17c:	681b      	ldr	r3, [r3, #0]
    tcp_rst((const struct tcp_pcb *)pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d17e:	7819      	ldrb	r1, [r3, #0]
 800d180:	785b      	ldrb	r3, [r3, #1]
 800d182:	021b      	lsls	r3, r3, #8
 800d184:	430b      	orrs	r3, r1
 800d186:	b29b      	uxth	r3, r3
 800d188:	4970      	ldr	r1, [pc, #448]	; (800d34c <tcp_listen_input+0x224>)
 800d18a:	6878      	ldr	r0, [r7, #4]
 800d18c:	9302      	str	r3, [sp, #8]
 800d18e:	9201      	str	r2, [sp, #4]
 800d190:	4b6f      	ldr	r3, [pc, #444]	; (800d350 <tcp_listen_input+0x228>)
 800d192:	9300      	str	r3, [sp, #0]
 800d194:	000b      	movs	r3, r1
 800d196:	002a      	movs	r2, r5
 800d198:	0021      	movs	r1, r4
 800d19a:	f004 fccd 	bl	8011b38 <tcp_rst>
      tcp_abandon(npcb, 0);
      return;
    }
    tcp_output(npcb);
  }
  return;
 800d19e:	e0bf      	b.n	800d320 <tcp_listen_input+0x1f8>
  } else if (flags & TCP_SYN) {
 800d1a0:	4b61      	ldr	r3, [pc, #388]	; (800d328 <tcp_listen_input+0x200>)
 800d1a2:	781b      	ldrb	r3, [r3, #0]
 800d1a4:	001a      	movs	r2, r3
 800d1a6:	2302      	movs	r3, #2
 800d1a8:	4013      	ands	r3, r2
 800d1aa:	d100      	bne.n	800d1ae <tcp_listen_input+0x86>
 800d1ac:	e0b8      	b.n	800d320 <tcp_listen_input+0x1f8>
    npcb = tcp_alloc(pcb->prio);
 800d1ae:	687b      	ldr	r3, [r7, #4]
 800d1b0:	7e5b      	ldrb	r3, [r3, #25]
 800d1b2:	0018      	movs	r0, r3
 800d1b4:	f7fe fefa 	bl	800bfac <tcp_alloc>
 800d1b8:	0003      	movs	r3, r0
 800d1ba:	617b      	str	r3, [r7, #20]
    if (npcb == NULL) {
 800d1bc:	697b      	ldr	r3, [r7, #20]
 800d1be:	2b00      	cmp	r3, #0
 800d1c0:	d116      	bne.n	800d1f0 <tcp_listen_input+0xc8>
      TCP_EVENT_ACCEPT(pcb, NULL, pcb->callback_arg, ERR_MEM, err);
 800d1c2:	687b      	ldr	r3, [r7, #4]
 800d1c4:	69db      	ldr	r3, [r3, #28]
 800d1c6:	2b00      	cmp	r3, #0
 800d1c8:	d00d      	beq.n	800d1e6 <tcp_listen_input+0xbe>
 800d1ca:	687b      	ldr	r3, [r7, #4]
 800d1cc:	69dd      	ldr	r5, [r3, #28]
 800d1ce:	687b      	ldr	r3, [r7, #4]
 800d1d0:	695b      	ldr	r3, [r3, #20]
 800d1d2:	220e      	movs	r2, #14
 800d1d4:	18bc      	adds	r4, r7, r2
 800d1d6:	2201      	movs	r2, #1
 800d1d8:	4252      	negs	r2, r2
 800d1da:	2100      	movs	r1, #0
 800d1dc:	0018      	movs	r0, r3
 800d1de:	47a8      	blx	r5
 800d1e0:	0003      	movs	r3, r0
 800d1e2:	7023      	strb	r3, [r4, #0]
      return;
 800d1e4:	e09d      	b.n	800d322 <tcp_listen_input+0x1fa>
      TCP_EVENT_ACCEPT(pcb, NULL, pcb->callback_arg, ERR_MEM, err);
 800d1e6:	230e      	movs	r3, #14
 800d1e8:	18fb      	adds	r3, r7, r3
 800d1ea:	22f0      	movs	r2, #240	; 0xf0
 800d1ec:	701a      	strb	r2, [r3, #0]
      return;
 800d1ee:	e098      	b.n	800d322 <tcp_listen_input+0x1fa>
    ip_addr_copy(npcb->local_ip, *ip_current_dest_addr());
 800d1f0:	4b58      	ldr	r3, [pc, #352]	; (800d354 <tcp_listen_input+0x22c>)
 800d1f2:	695a      	ldr	r2, [r3, #20]
 800d1f4:	697b      	ldr	r3, [r7, #20]
 800d1f6:	601a      	str	r2, [r3, #0]
    ip_addr_copy(npcb->remote_ip, *ip_current_src_addr());
 800d1f8:	4b56      	ldr	r3, [pc, #344]	; (800d354 <tcp_listen_input+0x22c>)
 800d1fa:	691a      	ldr	r2, [r3, #16]
 800d1fc:	697b      	ldr	r3, [r7, #20]
 800d1fe:	605a      	str	r2, [r3, #4]
    npcb->local_port = pcb->local_port;
 800d200:	687b      	ldr	r3, [r7, #4]
 800d202:	8b5a      	ldrh	r2, [r3, #26]
 800d204:	697b      	ldr	r3, [r7, #20]
 800d206:	835a      	strh	r2, [r3, #26]
    npcb->remote_port = tcphdr->src;
 800d208:	4b4f      	ldr	r3, [pc, #316]	; (800d348 <tcp_listen_input+0x220>)
 800d20a:	681b      	ldr	r3, [r3, #0]
 800d20c:	781a      	ldrb	r2, [r3, #0]
 800d20e:	785b      	ldrb	r3, [r3, #1]
 800d210:	021b      	lsls	r3, r3, #8
 800d212:	4313      	orrs	r3, r2
 800d214:	b29a      	uxth	r2, r3
 800d216:	697b      	ldr	r3, [r7, #20]
 800d218:	839a      	strh	r2, [r3, #28]
    npcb->state = SYN_RCVD;
 800d21a:	697b      	ldr	r3, [r7, #20]
 800d21c:	2203      	movs	r2, #3
 800d21e:	761a      	strb	r2, [r3, #24]
    npcb->rcv_nxt = seqno + 1;
 800d220:	4b48      	ldr	r3, [pc, #288]	; (800d344 <tcp_listen_input+0x21c>)
 800d222:	681b      	ldr	r3, [r3, #0]
 800d224:	1c5a      	adds	r2, r3, #1
 800d226:	697b      	ldr	r3, [r7, #20]
 800d228:	629a      	str	r2, [r3, #40]	; 0x28
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
 800d22a:	697b      	ldr	r3, [r7, #20]
 800d22c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800d22e:	697b      	ldr	r3, [r7, #20]
 800d230:	631a      	str	r2, [r3, #48]	; 0x30
    iss = tcp_next_iss(npcb);
 800d232:	697b      	ldr	r3, [r7, #20]
 800d234:	0018      	movs	r0, r3
 800d236:	f7ff f8e3 	bl	800c400 <tcp_next_iss>
 800d23a:	0003      	movs	r3, r0
 800d23c:	613b      	str	r3, [r7, #16]
    npcb->snd_wl2 = iss;
 800d23e:	697b      	ldr	r3, [r7, #20]
 800d240:	693a      	ldr	r2, [r7, #16]
 800d242:	65da      	str	r2, [r3, #92]	; 0x5c
    npcb->snd_nxt = iss;
 800d244:	697b      	ldr	r3, [r7, #20]
 800d246:	693a      	ldr	r2, [r7, #16]
 800d248:	655a      	str	r2, [r3, #84]	; 0x54
    npcb->lastack = iss;
 800d24a:	697b      	ldr	r3, [r7, #20]
 800d24c:	693a      	ldr	r2, [r7, #16]
 800d24e:	649a      	str	r2, [r3, #72]	; 0x48
    npcb->snd_lbb = iss;
 800d250:	697b      	ldr	r3, [r7, #20]
 800d252:	693a      	ldr	r2, [r7, #16]
 800d254:	661a      	str	r2, [r3, #96]	; 0x60
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
 800d256:	4b3b      	ldr	r3, [pc, #236]	; (800d344 <tcp_listen_input+0x21c>)
 800d258:	681b      	ldr	r3, [r3, #0]
 800d25a:	1e5a      	subs	r2, r3, #1
 800d25c:	697b      	ldr	r3, [r7, #20]
 800d25e:	659a      	str	r2, [r3, #88]	; 0x58
    npcb->callback_arg = pcb->callback_arg;
 800d260:	687b      	ldr	r3, [r7, #4]
 800d262:	695a      	ldr	r2, [r3, #20]
 800d264:	697b      	ldr	r3, [r7, #20]
 800d266:	615a      	str	r2, [r3, #20]
    npcb->listener = pcb;
 800d268:	697b      	ldr	r3, [r7, #20]
 800d26a:	2180      	movs	r1, #128	; 0x80
 800d26c:	687a      	ldr	r2, [r7, #4]
 800d26e:	505a      	str	r2, [r3, r1]
    npcb->so_options = pcb->so_options & SOF_INHERITED;
 800d270:	687b      	ldr	r3, [r7, #4]
 800d272:	7a5b      	ldrb	r3, [r3, #9]
 800d274:	220c      	movs	r2, #12
 800d276:	4013      	ands	r3, r2
 800d278:	b2da      	uxtb	r2, r3
 800d27a:	697b      	ldr	r3, [r7, #20]
 800d27c:	725a      	strb	r2, [r3, #9]
    npcb->netif_idx = pcb->netif_idx;
 800d27e:	687b      	ldr	r3, [r7, #4]
 800d280:	7a1a      	ldrb	r2, [r3, #8]
 800d282:	697b      	ldr	r3, [r7, #20]
 800d284:	721a      	strb	r2, [r3, #8]
    TCP_REG_ACTIVE(npcb);
 800d286:	4b34      	ldr	r3, [pc, #208]	; (800d358 <tcp_listen_input+0x230>)
 800d288:	681a      	ldr	r2, [r3, #0]
 800d28a:	697b      	ldr	r3, [r7, #20]
 800d28c:	611a      	str	r2, [r3, #16]
 800d28e:	4b32      	ldr	r3, [pc, #200]	; (800d358 <tcp_listen_input+0x230>)
 800d290:	697a      	ldr	r2, [r7, #20]
 800d292:	601a      	str	r2, [r3, #0]
 800d294:	f004 fe7a 	bl	8011f8c <tcp_timer_needed>
 800d298:	4b30      	ldr	r3, [pc, #192]	; (800d35c <tcp_listen_input+0x234>)
 800d29a:	2201      	movs	r2, #1
 800d29c:	701a      	strb	r2, [r3, #0]
    tcp_parseopt(npcb);
 800d29e:	697b      	ldr	r3, [r7, #20]
 800d2a0:	0018      	movs	r0, r3
 800d2a2:	f001 ffbf 	bl	800f224 <tcp_parseopt>
    npcb->snd_wnd = tcphdr->wnd;
 800d2a6:	4b28      	ldr	r3, [pc, #160]	; (800d348 <tcp_listen_input+0x220>)
 800d2a8:	681b      	ldr	r3, [r3, #0]
 800d2aa:	7b9a      	ldrb	r2, [r3, #14]
 800d2ac:	7bdb      	ldrb	r3, [r3, #15]
 800d2ae:	021b      	lsls	r3, r3, #8
 800d2b0:	4313      	orrs	r3, r2
 800d2b2:	b299      	uxth	r1, r3
 800d2b4:	697b      	ldr	r3, [r7, #20]
 800d2b6:	2264      	movs	r2, #100	; 0x64
 800d2b8:	5299      	strh	r1, [r3, r2]
    npcb->snd_wnd_max = npcb->snd_wnd;
 800d2ba:	697b      	ldr	r3, [r7, #20]
 800d2bc:	2264      	movs	r2, #100	; 0x64
 800d2be:	5a99      	ldrh	r1, [r3, r2]
 800d2c0:	697b      	ldr	r3, [r7, #20]
 800d2c2:	2266      	movs	r2, #102	; 0x66
 800d2c4:	5299      	strh	r1, [r3, r2]
    npcb->mss = tcp_eff_send_mss(npcb->mss, &npcb->local_ip, &npcb->remote_ip);
 800d2c6:	697b      	ldr	r3, [r7, #20]
 800d2c8:	8edc      	ldrh	r4, [r3, #54]	; 0x36
 800d2ca:	697b      	ldr	r3, [r7, #20]
 800d2cc:	3304      	adds	r3, #4
 800d2ce:	0018      	movs	r0, r3
 800d2d0:	f006 f806 	bl	80132e0 <ip4_route>
 800d2d4:	0001      	movs	r1, r0
 800d2d6:	697b      	ldr	r3, [r7, #20]
 800d2d8:	3304      	adds	r3, #4
 800d2da:	001a      	movs	r2, r3
 800d2dc:	0020      	movs	r0, r4
 800d2de:	f7ff f8b5 	bl	800c44c <tcp_eff_send_mss_netif>
 800d2e2:	0003      	movs	r3, r0
 800d2e4:	001a      	movs	r2, r3
 800d2e6:	697b      	ldr	r3, [r7, #20]
 800d2e8:	86da      	strh	r2, [r3, #54]	; 0x36
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
 800d2ea:	250f      	movs	r5, #15
 800d2ec:	197c      	adds	r4, r7, r5
 800d2ee:	697b      	ldr	r3, [r7, #20]
 800d2f0:	2112      	movs	r1, #18
 800d2f2:	0018      	movs	r0, r3
 800d2f4:	f003 fac6 	bl	8010884 <tcp_enqueue_flags>
 800d2f8:	0003      	movs	r3, r0
 800d2fa:	7023      	strb	r3, [r4, #0]
    if (rc != ERR_OK) {
 800d2fc:	197b      	adds	r3, r7, r5
 800d2fe:	781b      	ldrb	r3, [r3, #0]
 800d300:	b25b      	sxtb	r3, r3
 800d302:	2b00      	cmp	r3, #0
 800d304:	d005      	beq.n	800d312 <tcp_listen_input+0x1ea>
      tcp_abandon(npcb, 0);
 800d306:	697b      	ldr	r3, [r7, #20]
 800d308:	2100      	movs	r1, #0
 800d30a:	0018      	movs	r0, r3
 800d30c:	f7fd fd02 	bl	800ad14 <tcp_abandon>
      return;
 800d310:	e007      	b.n	800d322 <tcp_listen_input+0x1fa>
    tcp_output(npcb);
 800d312:	697b      	ldr	r3, [r7, #20]
 800d314:	0018      	movs	r0, r3
 800d316:	f003 fbbb 	bl	8010a90 <tcp_output>
  return;
 800d31a:	e001      	b.n	800d320 <tcp_listen_input+0x1f8>
    return;
 800d31c:	46c0      	nop			; (mov r8, r8)
 800d31e:	e000      	b.n	800d322 <tcp_listen_input+0x1fa>
  return;
 800d320:	46c0      	nop			; (mov r8, r8)
}
 800d322:	46bd      	mov	sp, r7
 800d324:	b006      	add	sp, #24
 800d326:	bdb0      	pop	{r4, r5, r7, pc}
 800d328:	20001b5c 	.word	0x20001b5c
 800d32c:	080201e0 	.word	0x080201e0
 800d330:	00000281 	.word	0x00000281
 800d334:	080203d0 	.word	0x080203d0
 800d338:	08020220 	.word	0x08020220
 800d33c:	20001b54 	.word	0x20001b54
 800d340:	20001b5a 	.word	0x20001b5a
 800d344:	20001b50 	.word	0x20001b50
 800d348:	20001b40 	.word	0x20001b40
 800d34c:	20001ca8 	.word	0x20001ca8
 800d350:	20001ca4 	.word	0x20001ca4
 800d354:	20001c94 	.word	0x20001c94
 800d358:	20002ed4 	.word	0x20002ed4
 800d35c:	20002ed0 	.word	0x20002ed0

0800d360 <tcp_timewait_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static void
tcp_timewait_input(struct tcp_pcb *pcb)
{
 800d360:	b5b0      	push	{r4, r5, r7, lr}
 800d362:	b086      	sub	sp, #24
 800d364:	af04      	add	r7, sp, #16
 800d366:	6078      	str	r0, [r7, #4]
  /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
  /* RFC 793 3.9 Event Processing - Segment Arrives:
   * - first check sequence number - we skip that one in TIME_WAIT (always
   *   acceptable since we only send ACKs)
   * - second check the RST bit (... return) */
  if (flags & TCP_RST) {
 800d368:	4b33      	ldr	r3, [pc, #204]	; (800d438 <tcp_timewait_input+0xd8>)
 800d36a:	781b      	ldrb	r3, [r3, #0]
 800d36c:	001a      	movs	r2, r3
 800d36e:	2304      	movs	r3, #4
 800d370:	4013      	ands	r3, r2
 800d372:	d15a      	bne.n	800d42a <tcp_timewait_input+0xca>
    return;
  }

  LWIP_ASSERT("tcp_timewait_input: invalid pcb", pcb != NULL);
 800d374:	687b      	ldr	r3, [r7, #4]
 800d376:	2b00      	cmp	r3, #0
 800d378:	d105      	bne.n	800d386 <tcp_timewait_input+0x26>
 800d37a:	4b30      	ldr	r3, [pc, #192]	; (800d43c <tcp_timewait_input+0xdc>)
 800d37c:	4a30      	ldr	r2, [pc, #192]	; (800d440 <tcp_timewait_input+0xe0>)
 800d37e:	4931      	ldr	r1, [pc, #196]	; (800d444 <tcp_timewait_input+0xe4>)
 800d380:	4831      	ldr	r0, [pc, #196]	; (800d448 <tcp_timewait_input+0xe8>)
 800d382:	f7f5 faab 	bl	80028dc <app_debug_rtt_raw>

  /* - fourth, check the SYN bit, */
  if (flags & TCP_SYN) {
 800d386:	4b2c      	ldr	r3, [pc, #176]	; (800d438 <tcp_timewait_input+0xd8>)
 800d388:	781b      	ldrb	r3, [r3, #0]
 800d38a:	001a      	movs	r2, r3
 800d38c:	2302      	movs	r3, #2
 800d38e:	4013      	ands	r3, r2
 800d390:	d031      	beq.n	800d3f6 <tcp_timewait_input+0x96>
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd)) {
 800d392:	4b2e      	ldr	r3, [pc, #184]	; (800d44c <tcp_timewait_input+0xec>)
 800d394:	681a      	ldr	r2, [r3, #0]
 800d396:	687b      	ldr	r3, [r7, #4]
 800d398:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800d39a:	1ad3      	subs	r3, r2, r3
 800d39c:	d435      	bmi.n	800d40a <tcp_timewait_input+0xaa>
 800d39e:	4b2b      	ldr	r3, [pc, #172]	; (800d44c <tcp_timewait_input+0xec>)
 800d3a0:	681a      	ldr	r2, [r3, #0]
 800d3a2:	687b      	ldr	r3, [r7, #4]
 800d3a4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800d3a6:	6879      	ldr	r1, [r7, #4]
 800d3a8:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
 800d3aa:	185b      	adds	r3, r3, r1
 800d3ac:	1ad3      	subs	r3, r2, r3
 800d3ae:	2b00      	cmp	r3, #0
 800d3b0:	dc2b      	bgt.n	800d40a <tcp_timewait_input+0xaa>
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d3b2:	4b27      	ldr	r3, [pc, #156]	; (800d450 <tcp_timewait_input+0xf0>)
 800d3b4:	681c      	ldr	r4, [r3, #0]
 800d3b6:	4b27      	ldr	r3, [pc, #156]	; (800d454 <tcp_timewait_input+0xf4>)
 800d3b8:	881b      	ldrh	r3, [r3, #0]
 800d3ba:	001a      	movs	r2, r3
 800d3bc:	4b23      	ldr	r3, [pc, #140]	; (800d44c <tcp_timewait_input+0xec>)
 800d3be:	681b      	ldr	r3, [r3, #0]
 800d3c0:	18d5      	adds	r5, r2, r3
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800d3c2:	4b25      	ldr	r3, [pc, #148]	; (800d458 <tcp_timewait_input+0xf8>)
 800d3c4:	681b      	ldr	r3, [r3, #0]
      tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d3c6:	789a      	ldrb	r2, [r3, #2]
 800d3c8:	78db      	ldrb	r3, [r3, #3]
 800d3ca:	021b      	lsls	r3, r3, #8
 800d3cc:	4313      	orrs	r3, r2
 800d3ce:	b29a      	uxth	r2, r3
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800d3d0:	4b21      	ldr	r3, [pc, #132]	; (800d458 <tcp_timewait_input+0xf8>)
 800d3d2:	681b      	ldr	r3, [r3, #0]
      tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d3d4:	7819      	ldrb	r1, [r3, #0]
 800d3d6:	785b      	ldrb	r3, [r3, #1]
 800d3d8:	021b      	lsls	r3, r3, #8
 800d3da:	430b      	orrs	r3, r1
 800d3dc:	b29b      	uxth	r3, r3
 800d3de:	491f      	ldr	r1, [pc, #124]	; (800d45c <tcp_timewait_input+0xfc>)
 800d3e0:	6878      	ldr	r0, [r7, #4]
 800d3e2:	9302      	str	r3, [sp, #8]
 800d3e4:	9201      	str	r2, [sp, #4]
 800d3e6:	4b1e      	ldr	r3, [pc, #120]	; (800d460 <tcp_timewait_input+0x100>)
 800d3e8:	9300      	str	r3, [sp, #0]
 800d3ea:	000b      	movs	r3, r1
 800d3ec:	002a      	movs	r2, r5
 800d3ee:	0021      	movs	r1, r4
 800d3f0:	f004 fba2 	bl	8011b38 <tcp_rst>
      return;
 800d3f4:	e01c      	b.n	800d430 <tcp_timewait_input+0xd0>
    }
  } else if (flags & TCP_FIN) {
 800d3f6:	4b10      	ldr	r3, [pc, #64]	; (800d438 <tcp_timewait_input+0xd8>)
 800d3f8:	781b      	ldrb	r3, [r3, #0]
 800d3fa:	001a      	movs	r2, r3
 800d3fc:	2301      	movs	r3, #1
 800d3fe:	4013      	ands	r3, r2
 800d400:	d003      	beq.n	800d40a <tcp_timewait_input+0xaa>
    /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
         Restart the 2 MSL time-wait timeout.*/
    pcb->tmr = tcp_ticks;
 800d402:	4b18      	ldr	r3, [pc, #96]	; (800d464 <tcp_timewait_input+0x104>)
 800d404:	681a      	ldr	r2, [r3, #0]
 800d406:	687b      	ldr	r3, [r7, #4]
 800d408:	625a      	str	r2, [r3, #36]	; 0x24
  }

  if ((tcplen > 0)) {
 800d40a:	4b12      	ldr	r3, [pc, #72]	; (800d454 <tcp_timewait_input+0xf4>)
 800d40c:	881b      	ldrh	r3, [r3, #0]
 800d40e:	2b00      	cmp	r3, #0
 800d410:	d00d      	beq.n	800d42e <tcp_timewait_input+0xce>
    /* Acknowledge data, FIN or out-of-window SYN */
    tcp_ack_now(pcb);
 800d412:	687b      	ldr	r3, [r7, #4]
 800d414:	8bdb      	ldrh	r3, [r3, #30]
 800d416:	2202      	movs	r2, #2
 800d418:	4313      	orrs	r3, r2
 800d41a:	b29a      	uxth	r2, r3
 800d41c:	687b      	ldr	r3, [r7, #4]
 800d41e:	83da      	strh	r2, [r3, #30]
    tcp_output(pcb);
 800d420:	687b      	ldr	r3, [r7, #4]
 800d422:	0018      	movs	r0, r3
 800d424:	f003 fb34 	bl	8010a90 <tcp_output>
  }
  return;
 800d428:	e001      	b.n	800d42e <tcp_timewait_input+0xce>
    return;
 800d42a:	46c0      	nop			; (mov r8, r8)
 800d42c:	e000      	b.n	800d430 <tcp_timewait_input+0xd0>
  return;
 800d42e:	46c0      	nop			; (mov r8, r8)
}
 800d430:	46bd      	mov	sp, r7
 800d432:	b002      	add	sp, #8
 800d434:	bdb0      	pop	{r4, r5, r7, pc}
 800d436:	46c0      	nop			; (mov r8, r8)
 800d438:	20001b5c 	.word	0x20001b5c
 800d43c:	080201e0 	.word	0x080201e0
 800d440:	000002ee 	.word	0x000002ee
 800d444:	080203f0 	.word	0x080203f0
 800d448:	08020220 	.word	0x08020220
 800d44c:	20001b50 	.word	0x20001b50
 800d450:	20001b54 	.word	0x20001b54
 800d454:	20001b5a 	.word	0x20001b5a
 800d458:	20001b40 	.word	0x20001b40
 800d45c:	20001ca8 	.word	0x20001ca8
 800d460:	20001ca4 	.word	0x20001ca4
 800d464:	20002ed8 	.word	0x20002ed8

0800d468 <tcp_process>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
 800d468:	b5b0      	push	{r4, r5, r7, lr}
 800d46a:	b08c      	sub	sp, #48	; 0x30
 800d46c:	af04      	add	r7, sp, #16
 800d46e:	6078      	str	r0, [r7, #4]
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
 800d470:	231f      	movs	r3, #31
 800d472:	18fb      	adds	r3, r7, r3
 800d474:	2200      	movs	r2, #0
 800d476:	701a      	strb	r2, [r3, #0]
  err_t err;

  err = ERR_OK;
 800d478:	231e      	movs	r3, #30
 800d47a:	18fb      	adds	r3, r7, r3
 800d47c:	2200      	movs	r2, #0
 800d47e:	701a      	strb	r2, [r3, #0]

  LWIP_ASSERT("tcp_process: invalid pcb", pcb != NULL);
 800d480:	687b      	ldr	r3, [r7, #4]
 800d482:	2b00      	cmp	r3, #0
 800d484:	d106      	bne.n	800d494 <tcp_process+0x2c>
 800d486:	4bd4      	ldr	r3, [pc, #848]	; (800d7d8 <tcp_process+0x370>)
 800d488:	22c7      	movs	r2, #199	; 0xc7
 800d48a:	0092      	lsls	r2, r2, #2
 800d48c:	49d3      	ldr	r1, [pc, #844]	; (800d7dc <tcp_process+0x374>)
 800d48e:	48d4      	ldr	r0, [pc, #848]	; (800d7e0 <tcp_process+0x378>)
 800d490:	f7f5 fa24 	bl	80028dc <app_debug_rtt_raw>

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
 800d494:	4bd3      	ldr	r3, [pc, #844]	; (800d7e4 <tcp_process+0x37c>)
 800d496:	781b      	ldrb	r3, [r3, #0]
 800d498:	001a      	movs	r2, r3
 800d49a:	2304      	movs	r3, #4
 800d49c:	4013      	ands	r3, r2
 800d49e:	d055      	beq.n	800d54c <tcp_process+0xe4>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
 800d4a0:	687b      	ldr	r3, [r7, #4]
 800d4a2:	7e1b      	ldrb	r3, [r3, #24]
 800d4a4:	2b02      	cmp	r3, #2
 800d4a6:	d10a      	bne.n	800d4be <tcp_process+0x56>
      /* "In the SYN-SENT state (a RST received in response to an initial SYN),
          the RST is acceptable if the ACK field acknowledges the SYN." */
      if (ackno == pcb->snd_nxt) {
 800d4a8:	687b      	ldr	r3, [r7, #4]
 800d4aa:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800d4ac:	4bce      	ldr	r3, [pc, #824]	; (800d7e8 <tcp_process+0x380>)
 800d4ae:	681b      	ldr	r3, [r3, #0]
 800d4b0:	429a      	cmp	r2, r3
 800d4b2:	d126      	bne.n	800d502 <tcp_process+0x9a>
        acceptable = 1;
 800d4b4:	231f      	movs	r3, #31
 800d4b6:	18fb      	adds	r3, r7, r3
 800d4b8:	2201      	movs	r2, #1
 800d4ba:	701a      	strb	r2, [r3, #0]
 800d4bc:	e021      	b.n	800d502 <tcp_process+0x9a>
      }
    } else {
      /* "In all states except SYN-SENT, all reset (RST) segments are validated
          by checking their SEQ-fields." */
      if (seqno == pcb->rcv_nxt) {
 800d4be:	687b      	ldr	r3, [r7, #4]
 800d4c0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800d4c2:	4bca      	ldr	r3, [pc, #808]	; (800d7ec <tcp_process+0x384>)
 800d4c4:	681b      	ldr	r3, [r3, #0]
 800d4c6:	429a      	cmp	r2, r3
 800d4c8:	d104      	bne.n	800d4d4 <tcp_process+0x6c>
        acceptable = 1;
 800d4ca:	231f      	movs	r3, #31
 800d4cc:	18fb      	adds	r3, r7, r3
 800d4ce:	2201      	movs	r2, #1
 800d4d0:	701a      	strb	r2, [r3, #0]
 800d4d2:	e016      	b.n	800d502 <tcp_process+0x9a>
      } else  if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
 800d4d4:	4bc5      	ldr	r3, [pc, #788]	; (800d7ec <tcp_process+0x384>)
 800d4d6:	681a      	ldr	r2, [r3, #0]
 800d4d8:	687b      	ldr	r3, [r7, #4]
 800d4da:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800d4dc:	1ad3      	subs	r3, r2, r3
 800d4de:	d410      	bmi.n	800d502 <tcp_process+0x9a>
 800d4e0:	4bc2      	ldr	r3, [pc, #776]	; (800d7ec <tcp_process+0x384>)
 800d4e2:	681a      	ldr	r2, [r3, #0]
 800d4e4:	687b      	ldr	r3, [r7, #4]
 800d4e6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800d4e8:	6879      	ldr	r1, [r7, #4]
 800d4ea:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
 800d4ec:	185b      	adds	r3, r3, r1
 800d4ee:	1ad3      	subs	r3, r2, r3
 800d4f0:	2b00      	cmp	r3, #0
 800d4f2:	dc06      	bgt.n	800d502 <tcp_process+0x9a>
                                  pcb->rcv_nxt + pcb->rcv_wnd)) {
        /* If the sequence number is inside the window, we send a challenge ACK
           and wait for a re-send with matching sequence number.
           This follows RFC 5961 section 3.2 and addresses CVE-2004-0230
           (RST spoofing attack), which is present in RFC 793 RST handling. */
        tcp_ack_now(pcb);
 800d4f4:	687b      	ldr	r3, [r7, #4]
 800d4f6:	8bdb      	ldrh	r3, [r3, #30]
 800d4f8:	2202      	movs	r2, #2
 800d4fa:	4313      	orrs	r3, r2
 800d4fc:	b29a      	uxth	r2, r3
 800d4fe:	687b      	ldr	r3, [r7, #4]
 800d500:	83da      	strh	r2, [r3, #30]
      }
    }

    if (acceptable) {
 800d502:	231f      	movs	r3, #31
 800d504:	18fb      	adds	r3, r7, r3
 800d506:	781b      	ldrb	r3, [r3, #0]
 800d508:	2b00      	cmp	r3, #0
 800d50a:	d01c      	beq.n	800d546 <tcp_process+0xde>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
 800d50c:	687b      	ldr	r3, [r7, #4]
 800d50e:	7e1b      	ldrb	r3, [r3, #24]
 800d510:	2b00      	cmp	r3, #0
 800d512:	d106      	bne.n	800d522 <tcp_process+0xba>
 800d514:	4bb0      	ldr	r3, [pc, #704]	; (800d7d8 <tcp_process+0x370>)
 800d516:	22ce      	movs	r2, #206	; 0xce
 800d518:	0092      	lsls	r2, r2, #2
 800d51a:	49b5      	ldr	r1, [pc, #724]	; (800d7f0 <tcp_process+0x388>)
 800d51c:	48b0      	ldr	r0, [pc, #704]	; (800d7e0 <tcp_process+0x378>)
 800d51e:	f7f5 f9dd 	bl	80028dc <app_debug_rtt_raw>
      recv_flags |= TF_RESET;
 800d522:	4bb4      	ldr	r3, [pc, #720]	; (800d7f4 <tcp_process+0x38c>)
 800d524:	781b      	ldrb	r3, [r3, #0]
 800d526:	2208      	movs	r2, #8
 800d528:	4313      	orrs	r3, r2
 800d52a:	b2da      	uxtb	r2, r3
 800d52c:	4bb1      	ldr	r3, [pc, #708]	; (800d7f4 <tcp_process+0x38c>)
 800d52e:	701a      	strb	r2, [r3, #0]
      tcp_clear_flags(pcb, TF_ACK_DELAY);
 800d530:	687b      	ldr	r3, [r7, #4]
 800d532:	8bdb      	ldrh	r3, [r3, #30]
 800d534:	2201      	movs	r2, #1
 800d536:	4393      	bics	r3, r2
 800d538:	b29a      	uxth	r2, r3
 800d53a:	687b      	ldr	r3, [r7, #4]
 800d53c:	83da      	strh	r2, [r3, #30]
      return ERR_RST;
 800d53e:	230e      	movs	r3, #14
 800d540:	425b      	negs	r3, r3
 800d542:	f000 fbb1 	bl	800dca8 <tcp_process+0x840>
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
                                    seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
                              seqno, pcb->rcv_nxt));
      return ERR_OK;
 800d546:	2300      	movs	r3, #0
 800d548:	f000 fbae 	bl	800dca8 <tcp_process+0x840>
    }
  }

  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) {
 800d54c:	4ba5      	ldr	r3, [pc, #660]	; (800d7e4 <tcp_process+0x37c>)
 800d54e:	781b      	ldrb	r3, [r3, #0]
 800d550:	001a      	movs	r2, r3
 800d552:	2302      	movs	r3, #2
 800d554:	4013      	ands	r3, r2
 800d556:	d011      	beq.n	800d57c <tcp_process+0x114>
 800d558:	687b      	ldr	r3, [r7, #4]
 800d55a:	7e1b      	ldrb	r3, [r3, #24]
 800d55c:	2b02      	cmp	r3, #2
 800d55e:	d00d      	beq.n	800d57c <tcp_process+0x114>
 800d560:	687b      	ldr	r3, [r7, #4]
 800d562:	7e1b      	ldrb	r3, [r3, #24]
 800d564:	2b03      	cmp	r3, #3
 800d566:	d009      	beq.n	800d57c <tcp_process+0x114>
    /* Cope with new connection attempt after remote end crashed */
    tcp_ack_now(pcb);
 800d568:	687b      	ldr	r3, [r7, #4]
 800d56a:	8bdb      	ldrh	r3, [r3, #30]
 800d56c:	2202      	movs	r2, #2
 800d56e:	4313      	orrs	r3, r2
 800d570:	b29a      	uxth	r2, r3
 800d572:	687b      	ldr	r3, [r7, #4]
 800d574:	83da      	strh	r2, [r3, #30]
    return ERR_OK;
 800d576:	2300      	movs	r3, #0
 800d578:	f000 fb96 	bl	800dca8 <tcp_process+0x840>
  }

  if ((pcb->flags & TF_RXCLOSED) == 0) {
 800d57c:	687b      	ldr	r3, [r7, #4]
 800d57e:	8bdb      	ldrh	r3, [r3, #30]
 800d580:	001a      	movs	r2, r3
 800d582:	2310      	movs	r3, #16
 800d584:	4013      	ands	r3, r2
 800d586:	d103      	bne.n	800d590 <tcp_process+0x128>
    /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
    pcb->tmr = tcp_ticks;
 800d588:	4b9b      	ldr	r3, [pc, #620]	; (800d7f8 <tcp_process+0x390>)
 800d58a:	681a      	ldr	r2, [r3, #0]
 800d58c:	687b      	ldr	r3, [r7, #4]
 800d58e:	625a      	str	r2, [r3, #36]	; 0x24
  }
  pcb->keep_cnt_sent = 0;
 800d590:	687b      	ldr	r3, [r7, #4]
 800d592:	22a7      	movs	r2, #167	; 0xa7
 800d594:	2100      	movs	r1, #0
 800d596:	5499      	strb	r1, [r3, r2]
  pcb->persist_probe = 0;
 800d598:	687b      	ldr	r3, [r7, #4]
 800d59a:	22a6      	movs	r2, #166	; 0xa6
 800d59c:	2100      	movs	r1, #0
 800d59e:	5499      	strb	r1, [r3, r2]

  tcp_parseopt(pcb);
 800d5a0:	687b      	ldr	r3, [r7, #4]
 800d5a2:	0018      	movs	r0, r3
 800d5a4:	f001 fe3e 	bl	800f224 <tcp_parseopt>

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
 800d5a8:	687b      	ldr	r3, [r7, #4]
 800d5aa:	7e1b      	ldrb	r3, [r3, #24]
 800d5ac:	2b09      	cmp	r3, #9
 800d5ae:	d901      	bls.n	800d5b4 <tcp_process+0x14c>
 800d5b0:	f000 fb6a 	bl	800dc88 <tcp_process+0x820>
 800d5b4:	009a      	lsls	r2, r3, #2
 800d5b6:	4b91      	ldr	r3, [pc, #580]	; (800d7fc <tcp_process+0x394>)
 800d5b8:	18d3      	adds	r3, r2, r3
 800d5ba:	681b      	ldr	r3, [r3, #0]
 800d5bc:	469f      	mov	pc, r3
    case SYN_SENT:
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %s %"U32_F"\n",
                                    ackno, pcb->snd_nxt, pcb->unacked ? "" : " empty:",
                                    pcb->unacked ? lwip_ntohl(pcb->unacked->tcphdr->seqno) : 0));
      /* received SYN ACK with expected sequence number? */
      if ((flags & TCP_ACK) && (flags & TCP_SYN)
 800d5be:	4b89      	ldr	r3, [pc, #548]	; (800d7e4 <tcp_process+0x37c>)
 800d5c0:	781b      	ldrb	r3, [r3, #0]
 800d5c2:	001a      	movs	r2, r3
 800d5c4:	2310      	movs	r3, #16
 800d5c6:	4013      	ands	r3, r2
 800d5c8:	d100      	bne.n	800d5cc <tcp_process+0x164>
 800d5ca:	e0cf      	b.n	800d76c <tcp_process+0x304>
 800d5cc:	4b85      	ldr	r3, [pc, #532]	; (800d7e4 <tcp_process+0x37c>)
 800d5ce:	781b      	ldrb	r3, [r3, #0]
 800d5d0:	001a      	movs	r2, r3
 800d5d2:	2302      	movs	r3, #2
 800d5d4:	4013      	ands	r3, r2
 800d5d6:	d100      	bne.n	800d5da <tcp_process+0x172>
 800d5d8:	e0c8      	b.n	800d76c <tcp_process+0x304>
          && (ackno == pcb->lastack + 1)) {
 800d5da:	687b      	ldr	r3, [r7, #4]
 800d5dc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800d5de:	1c5a      	adds	r2, r3, #1
 800d5e0:	4b81      	ldr	r3, [pc, #516]	; (800d7e8 <tcp_process+0x380>)
 800d5e2:	681b      	ldr	r3, [r3, #0]
 800d5e4:	429a      	cmp	r2, r3
 800d5e6:	d000      	beq.n	800d5ea <tcp_process+0x182>
 800d5e8:	e0c0      	b.n	800d76c <tcp_process+0x304>
        pcb->rcv_nxt = seqno + 1;
 800d5ea:	4b80      	ldr	r3, [pc, #512]	; (800d7ec <tcp_process+0x384>)
 800d5ec:	681b      	ldr	r3, [r3, #0]
 800d5ee:	1c5a      	adds	r2, r3, #1
 800d5f0:	687b      	ldr	r3, [r7, #4]
 800d5f2:	629a      	str	r2, [r3, #40]	; 0x28
        pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 800d5f4:	687b      	ldr	r3, [r7, #4]
 800d5f6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800d5f8:	687b      	ldr	r3, [r7, #4]
 800d5fa:	631a      	str	r2, [r3, #48]	; 0x30
        pcb->lastack = ackno;
 800d5fc:	4b7a      	ldr	r3, [pc, #488]	; (800d7e8 <tcp_process+0x380>)
 800d5fe:	681a      	ldr	r2, [r3, #0]
 800d600:	687b      	ldr	r3, [r7, #4]
 800d602:	649a      	str	r2, [r3, #72]	; 0x48
        pcb->snd_wnd = tcphdr->wnd;
 800d604:	4b7e      	ldr	r3, [pc, #504]	; (800d800 <tcp_process+0x398>)
 800d606:	681b      	ldr	r3, [r3, #0]
 800d608:	7b9a      	ldrb	r2, [r3, #14]
 800d60a:	7bdb      	ldrb	r3, [r3, #15]
 800d60c:	021b      	lsls	r3, r3, #8
 800d60e:	4313      	orrs	r3, r2
 800d610:	b299      	uxth	r1, r3
 800d612:	687b      	ldr	r3, [r7, #4]
 800d614:	2264      	movs	r2, #100	; 0x64
 800d616:	5299      	strh	r1, [r3, r2]
        pcb->snd_wnd_max = pcb->snd_wnd;
 800d618:	687b      	ldr	r3, [r7, #4]
 800d61a:	2264      	movs	r2, #100	; 0x64
 800d61c:	5a99      	ldrh	r1, [r3, r2]
 800d61e:	687b      	ldr	r3, [r7, #4]
 800d620:	2266      	movs	r2, #102	; 0x66
 800d622:	5299      	strh	r1, [r3, r2]
        pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
 800d624:	4b71      	ldr	r3, [pc, #452]	; (800d7ec <tcp_process+0x384>)
 800d626:	681b      	ldr	r3, [r3, #0]
 800d628:	1e5a      	subs	r2, r3, #1
 800d62a:	687b      	ldr	r3, [r7, #4]
 800d62c:	659a      	str	r2, [r3, #88]	; 0x58
        pcb->state = ESTABLISHED;
 800d62e:	687b      	ldr	r3, [r7, #4]
 800d630:	2204      	movs	r2, #4
 800d632:	761a      	strb	r2, [r3, #24]

#if TCP_CALCULATE_EFF_SEND_MSS
        pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip);
 800d634:	687b      	ldr	r3, [r7, #4]
 800d636:	8edc      	ldrh	r4, [r3, #54]	; 0x36
 800d638:	687b      	ldr	r3, [r7, #4]
 800d63a:	3304      	adds	r3, #4
 800d63c:	0018      	movs	r0, r3
 800d63e:	f005 fe4f 	bl	80132e0 <ip4_route>
 800d642:	0001      	movs	r1, r0
 800d644:	687b      	ldr	r3, [r7, #4]
 800d646:	3304      	adds	r3, #4
 800d648:	001a      	movs	r2, r3
 800d64a:	0020      	movs	r0, r4
 800d64c:	f7fe fefe 	bl	800c44c <tcp_eff_send_mss_netif>
 800d650:	0003      	movs	r3, r0
 800d652:	001a      	movs	r2, r3
 800d654:	687b      	ldr	r3, [r7, #4]
 800d656:	86da      	strh	r2, [r3, #54]	; 0x36
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

        pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
 800d658:	687b      	ldr	r3, [r7, #4]
 800d65a:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800d65c:	009a      	lsls	r2, r3, #2
 800d65e:	687b      	ldr	r3, [r7, #4]
 800d660:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800d662:	005b      	lsls	r3, r3, #1
 800d664:	4967      	ldr	r1, [pc, #412]	; (800d804 <tcp_process+0x39c>)
 800d666:	428b      	cmp	r3, r1
 800d668:	d200      	bcs.n	800d66c <tcp_process+0x204>
 800d66a:	4b66      	ldr	r3, [pc, #408]	; (800d804 <tcp_process+0x39c>)
 800d66c:	429a      	cmp	r2, r3
 800d66e:	d204      	bcs.n	800d67a <tcp_process+0x212>
 800d670:	687b      	ldr	r3, [r7, #4]
 800d672:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800d674:	009b      	lsls	r3, r3, #2
 800d676:	b29b      	uxth	r3, r3
 800d678:	e00b      	b.n	800d692 <tcp_process+0x22a>
 800d67a:	687b      	ldr	r3, [r7, #4]
 800d67c:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800d67e:	005b      	lsls	r3, r3, #1
 800d680:	4a60      	ldr	r2, [pc, #384]	; (800d804 <tcp_process+0x39c>)
 800d682:	4293      	cmp	r3, r2
 800d684:	d904      	bls.n	800d690 <tcp_process+0x228>
 800d686:	687b      	ldr	r3, [r7, #4]
 800d688:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800d68a:	18db      	adds	r3, r3, r3
 800d68c:	b29b      	uxth	r3, r3
 800d68e:	e000      	b.n	800d692 <tcp_process+0x22a>
 800d690:	4b5c      	ldr	r3, [pc, #368]	; (800d804 <tcp_process+0x39c>)
 800d692:	687a      	ldr	r2, [r7, #4]
 800d694:	214c      	movs	r1, #76	; 0x4c
 800d696:	5253      	strh	r3, [r2, r1]
        LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SENT): cwnd %"TCPWNDSIZE_F
                                     " ssthresh %"TCPWNDSIZE_F"\n",
                                     pcb->cwnd, pcb->ssthresh));
        LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
 800d698:	687b      	ldr	r3, [r7, #4]
 800d69a:	226a      	movs	r2, #106	; 0x6a
 800d69c:	5a9b      	ldrh	r3, [r3, r2]
 800d69e:	2b00      	cmp	r3, #0
 800d6a0:	d105      	bne.n	800d6ae <tcp_process+0x246>
 800d6a2:	4b4d      	ldr	r3, [pc, #308]	; (800d7d8 <tcp_process+0x370>)
 800d6a4:	4a58      	ldr	r2, [pc, #352]	; (800d808 <tcp_process+0x3a0>)
 800d6a6:	4959      	ldr	r1, [pc, #356]	; (800d80c <tcp_process+0x3a4>)
 800d6a8:	484d      	ldr	r0, [pc, #308]	; (800d7e0 <tcp_process+0x378>)
 800d6aa:	f7f5 f917 	bl	80028dc <app_debug_rtt_raw>
        --pcb->snd_queuelen;
 800d6ae:	687b      	ldr	r3, [r7, #4]
 800d6b0:	226a      	movs	r2, #106	; 0x6a
 800d6b2:	5a9b      	ldrh	r3, [r3, r2]
 800d6b4:	3b01      	subs	r3, #1
 800d6b6:	b299      	uxth	r1, r3
 800d6b8:	687b      	ldr	r3, [r7, #4]
 800d6ba:	226a      	movs	r2, #106	; 0x6a
 800d6bc:	5299      	strh	r1, [r3, r2]
        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"TCPWNDSIZE_F"\n", (tcpwnd_size_t)pcb->snd_queuelen));
        rseg = pcb->unacked;
 800d6be:	687b      	ldr	r3, [r7, #4]
 800d6c0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800d6c2:	617b      	str	r3, [r7, #20]
        if (rseg == NULL) {
 800d6c4:	697b      	ldr	r3, [r7, #20]
 800d6c6:	2b00      	cmp	r3, #0
 800d6c8:	d110      	bne.n	800d6ec <tcp_process+0x284>
          /* might happen if tcp_output fails in tcp_rexmit_rto()
             in which case the segment is on the unsent list */
          rseg = pcb->unsent;
 800d6ca:	687b      	ldr	r3, [r7, #4]
 800d6cc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d6ce:	617b      	str	r3, [r7, #20]
          LWIP_ASSERT("no segment to free", rseg != NULL);
 800d6d0:	697b      	ldr	r3, [r7, #20]
 800d6d2:	2b00      	cmp	r3, #0
 800d6d4:	d105      	bne.n	800d6e2 <tcp_process+0x27a>
 800d6d6:	4b40      	ldr	r3, [pc, #256]	; (800d7d8 <tcp_process+0x370>)
 800d6d8:	4a4d      	ldr	r2, [pc, #308]	; (800d810 <tcp_process+0x3a8>)
 800d6da:	494e      	ldr	r1, [pc, #312]	; (800d814 <tcp_process+0x3ac>)
 800d6dc:	4840      	ldr	r0, [pc, #256]	; (800d7e0 <tcp_process+0x378>)
 800d6de:	f7f5 f8fd 	bl	80028dc <app_debug_rtt_raw>
          pcb->unsent = rseg->next;
 800d6e2:	697b      	ldr	r3, [r7, #20]
 800d6e4:	681a      	ldr	r2, [r3, #0]
 800d6e6:	687b      	ldr	r3, [r7, #4]
 800d6e8:	671a      	str	r2, [r3, #112]	; 0x70
 800d6ea:	e003      	b.n	800d6f4 <tcp_process+0x28c>
        } else {
          pcb->unacked = rseg->next;
 800d6ec:	697b      	ldr	r3, [r7, #20]
 800d6ee:	681a      	ldr	r2, [r3, #0]
 800d6f0:	687b      	ldr	r3, [r7, #4]
 800d6f2:	675a      	str	r2, [r3, #116]	; 0x74
        }
        tcp_seg_free(rseg);
 800d6f4:	697b      	ldr	r3, [r7, #20]
 800d6f6:	0018      	movs	r0, r3
 800d6f8:	f7fe fad6 	bl	800bca8 <tcp_seg_free>

        /* If there's nothing left to acknowledge, stop the retransmit
           timer, otherwise reset it to start again */
        if (pcb->unacked == NULL) {
 800d6fc:	687b      	ldr	r3, [r7, #4]
 800d6fe:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800d700:	2b00      	cmp	r3, #0
 800d702:	d104      	bne.n	800d70e <tcp_process+0x2a6>
          pcb->rtime = -1;
 800d704:	687b      	ldr	r3, [r7, #4]
 800d706:	2201      	movs	r2, #1
 800d708:	4252      	negs	r2, r2
 800d70a:	869a      	strh	r2, [r3, #52]	; 0x34
 800d70c:	e006      	b.n	800d71c <tcp_process+0x2b4>
        } else {
          pcb->rtime = 0;
 800d70e:	687b      	ldr	r3, [r7, #4]
 800d710:	2200      	movs	r2, #0
 800d712:	869a      	strh	r2, [r3, #52]	; 0x34
          pcb->nrtx = 0;
 800d714:	687b      	ldr	r3, [r7, #4]
 800d716:	2246      	movs	r2, #70	; 0x46
 800d718:	2100      	movs	r1, #0
 800d71a:	5499      	strb	r1, [r3, r2]
        }

        /* Call the user specified function to call when successfully
         * connected. */
        TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
 800d71c:	687b      	ldr	r3, [r7, #4]
 800d71e:	228c      	movs	r2, #140	; 0x8c
 800d720:	589b      	ldr	r3, [r3, r2]
 800d722:	2b00      	cmp	r3, #0
 800d724:	d00d      	beq.n	800d742 <tcp_process+0x2da>
 800d726:	687b      	ldr	r3, [r7, #4]
 800d728:	228c      	movs	r2, #140	; 0x8c
 800d72a:	589d      	ldr	r5, [r3, r2]
 800d72c:	687b      	ldr	r3, [r7, #4]
 800d72e:	695b      	ldr	r3, [r3, #20]
 800d730:	221e      	movs	r2, #30
 800d732:	18bc      	adds	r4, r7, r2
 800d734:	6879      	ldr	r1, [r7, #4]
 800d736:	2200      	movs	r2, #0
 800d738:	0018      	movs	r0, r3
 800d73a:	47a8      	blx	r5
 800d73c:	0003      	movs	r3, r0
 800d73e:	7023      	strb	r3, [r4, #0]
 800d740:	e003      	b.n	800d74a <tcp_process+0x2e2>
 800d742:	231e      	movs	r3, #30
 800d744:	18fb      	adds	r3, r7, r3
 800d746:	2200      	movs	r2, #0
 800d748:	701a      	strb	r2, [r3, #0]
        if (err == ERR_ABRT) {
 800d74a:	231e      	movs	r3, #30
 800d74c:	18fb      	adds	r3, r7, r3
 800d74e:	781b      	ldrb	r3, [r3, #0]
 800d750:	b25b      	sxtb	r3, r3
 800d752:	330d      	adds	r3, #13
 800d754:	d102      	bne.n	800d75c <tcp_process+0x2f4>
          return ERR_ABRT;
 800d756:	230d      	movs	r3, #13
 800d758:	425b      	negs	r3, r3
 800d75a:	e2a5      	b.n	800dca8 <tcp_process+0x840>
        }
        tcp_ack_now(pcb);
 800d75c:	687b      	ldr	r3, [r7, #4]
 800d75e:	8bdb      	ldrh	r3, [r3, #30]
 800d760:	2202      	movs	r2, #2
 800d762:	4313      	orrs	r3, r2
 800d764:	b29a      	uxth	r2, r3
 800d766:	687b      	ldr	r3, [r7, #4]
 800d768:	83da      	strh	r2, [r3, #30]
        if (pcb->nrtx < TCP_SYNMAXRTX) {
          pcb->rtime = 0;
          tcp_rexmit_rto(pcb);
        }
      }
      break;
 800d76a:	e28f      	b.n	800dc8c <tcp_process+0x824>
      else if (flags & TCP_ACK) {
 800d76c:	4b1d      	ldr	r3, [pc, #116]	; (800d7e4 <tcp_process+0x37c>)
 800d76e:	781b      	ldrb	r3, [r3, #0]
 800d770:	001a      	movs	r2, r3
 800d772:	2310      	movs	r3, #16
 800d774:	4013      	ands	r3, r2
 800d776:	d100      	bne.n	800d77a <tcp_process+0x312>
 800d778:	e288      	b.n	800dc8c <tcp_process+0x824>
        tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d77a:	4b1b      	ldr	r3, [pc, #108]	; (800d7e8 <tcp_process+0x380>)
 800d77c:	681c      	ldr	r4, [r3, #0]
 800d77e:	4b26      	ldr	r3, [pc, #152]	; (800d818 <tcp_process+0x3b0>)
 800d780:	881b      	ldrh	r3, [r3, #0]
 800d782:	001a      	movs	r2, r3
 800d784:	4b19      	ldr	r3, [pc, #100]	; (800d7ec <tcp_process+0x384>)
 800d786:	681b      	ldr	r3, [r3, #0]
 800d788:	18d5      	adds	r5, r2, r3
                ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800d78a:	4b1d      	ldr	r3, [pc, #116]	; (800d800 <tcp_process+0x398>)
 800d78c:	681b      	ldr	r3, [r3, #0]
        tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d78e:	789a      	ldrb	r2, [r3, #2]
 800d790:	78db      	ldrb	r3, [r3, #3]
 800d792:	021b      	lsls	r3, r3, #8
 800d794:	4313      	orrs	r3, r2
 800d796:	b29a      	uxth	r2, r3
                ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800d798:	4b19      	ldr	r3, [pc, #100]	; (800d800 <tcp_process+0x398>)
 800d79a:	681b      	ldr	r3, [r3, #0]
        tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d79c:	7819      	ldrb	r1, [r3, #0]
 800d79e:	785b      	ldrb	r3, [r3, #1]
 800d7a0:	021b      	lsls	r3, r3, #8
 800d7a2:	430b      	orrs	r3, r1
 800d7a4:	b29b      	uxth	r3, r3
 800d7a6:	491d      	ldr	r1, [pc, #116]	; (800d81c <tcp_process+0x3b4>)
 800d7a8:	6878      	ldr	r0, [r7, #4]
 800d7aa:	9302      	str	r3, [sp, #8]
 800d7ac:	9201      	str	r2, [sp, #4]
 800d7ae:	4b1c      	ldr	r3, [pc, #112]	; (800d820 <tcp_process+0x3b8>)
 800d7b0:	9300      	str	r3, [sp, #0]
 800d7b2:	000b      	movs	r3, r1
 800d7b4:	002a      	movs	r2, r5
 800d7b6:	0021      	movs	r1, r4
 800d7b8:	f004 f9be 	bl	8011b38 <tcp_rst>
        if (pcb->nrtx < TCP_SYNMAXRTX) {
 800d7bc:	687b      	ldr	r3, [r7, #4]
 800d7be:	2246      	movs	r2, #70	; 0x46
 800d7c0:	5c9b      	ldrb	r3, [r3, r2]
 800d7c2:	2b05      	cmp	r3, #5
 800d7c4:	d900      	bls.n	800d7c8 <tcp_process+0x360>
 800d7c6:	e261      	b.n	800dc8c <tcp_process+0x824>
          pcb->rtime = 0;
 800d7c8:	687b      	ldr	r3, [r7, #4]
 800d7ca:	2200      	movs	r2, #0
 800d7cc:	869a      	strh	r2, [r3, #52]	; 0x34
          tcp_rexmit_rto(pcb);
 800d7ce:	687b      	ldr	r3, [r7, #4]
 800d7d0:	0018      	movs	r0, r3
 800d7d2:	f003 fe69 	bl	80114a8 <tcp_rexmit_rto>
      break;
 800d7d6:	e259      	b.n	800dc8c <tcp_process+0x824>
 800d7d8:	080201e0 	.word	0x080201e0
 800d7dc:	08020410 	.word	0x08020410
 800d7e0:	08020220 	.word	0x08020220
 800d7e4:	20001b5c 	.word	0x20001b5c
 800d7e8:	20001b54 	.word	0x20001b54
 800d7ec:	20001b50 	.word	0x20001b50
 800d7f0:	0802042c 	.word	0x0802042c
 800d7f4:	20001b5d 	.word	0x20001b5d
 800d7f8:	20002ed8 	.word	0x20002ed8
 800d7fc:	08022444 	.word	0x08022444
 800d800:	20001b40 	.word	0x20001b40
 800d804:	0000111c 	.word	0x0000111c
 800d808:	0000036d 	.word	0x0000036d
 800d80c:	0802044c 	.word	0x0802044c
 800d810:	00000375 	.word	0x00000375
 800d814:	08020464 	.word	0x08020464
 800d818:	20001b5a 	.word	0x20001b5a
 800d81c:	20001ca8 	.word	0x20001ca8
 800d820:	20001ca4 	.word	0x20001ca4
    case SYN_RCVD:
      if (flags & TCP_ACK) {
 800d824:	4bc7      	ldr	r3, [pc, #796]	; (800db44 <tcp_process+0x6dc>)
 800d826:	781b      	ldrb	r3, [r3, #0]
 800d828:	001a      	movs	r2, r3
 800d82a:	2310      	movs	r3, #16
 800d82c:	4013      	ands	r3, r2
 800d82e:	d100      	bne.n	800d832 <tcp_process+0x3ca>
 800d830:	e0b5      	b.n	800d99e <tcp_process+0x536>
        /* expected ACK number? */
        if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 800d832:	4bc5      	ldr	r3, [pc, #788]	; (800db48 <tcp_process+0x6e0>)
 800d834:	681a      	ldr	r2, [r3, #0]
 800d836:	687b      	ldr	r3, [r7, #4]
 800d838:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800d83a:	1ad3      	subs	r3, r2, r3
 800d83c:	3b01      	subs	r3, #1
 800d83e:	2b00      	cmp	r3, #0
 800d840:	da00      	bge.n	800d844 <tcp_process+0x3dc>
 800d842:	e08a      	b.n	800d95a <tcp_process+0x4f2>
 800d844:	4bc0      	ldr	r3, [pc, #768]	; (800db48 <tcp_process+0x6e0>)
 800d846:	681a      	ldr	r2, [r3, #0]
 800d848:	687b      	ldr	r3, [r7, #4]
 800d84a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800d84c:	1ad3      	subs	r3, r2, r3
 800d84e:	2b00      	cmp	r3, #0
 800d850:	dd00      	ble.n	800d854 <tcp_process+0x3ec>
 800d852:	e082      	b.n	800d95a <tcp_process+0x4f2>
          pcb->state = ESTABLISHED;
 800d854:	687b      	ldr	r3, [r7, #4]
 800d856:	2204      	movs	r2, #4
 800d858:	761a      	strb	r2, [r3, #24]
          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
          if (pcb->listener == NULL) {
 800d85a:	687b      	ldr	r3, [r7, #4]
 800d85c:	2280      	movs	r2, #128	; 0x80
 800d85e:	589b      	ldr	r3, [r3, r2]
 800d860:	2b00      	cmp	r3, #0
 800d862:	d104      	bne.n	800d86e <tcp_process+0x406>
            /* listen pcb might be closed by now */
            err = ERR_VAL;
 800d864:	231e      	movs	r3, #30
 800d866:	18fb      	adds	r3, r7, r3
 800d868:	22fa      	movs	r2, #250	; 0xfa
 800d86a:	701a      	strb	r2, [r3, #0]
 800d86c:	e024      	b.n	800d8b8 <tcp_process+0x450>
          } else
#endif /* LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG */
          {
#if LWIP_CALLBACK_API
            LWIP_ASSERT("pcb->listener->accept != NULL", pcb->listener->accept != NULL);
 800d86e:	687b      	ldr	r3, [r7, #4]
 800d870:	2280      	movs	r2, #128	; 0x80
 800d872:	589b      	ldr	r3, [r3, r2]
 800d874:	69db      	ldr	r3, [r3, #28]
 800d876:	2b00      	cmp	r3, #0
 800d878:	d105      	bne.n	800d886 <tcp_process+0x41e>
 800d87a:	4bb4      	ldr	r3, [pc, #720]	; (800db4c <tcp_process+0x6e4>)
 800d87c:	4ab4      	ldr	r2, [pc, #720]	; (800db50 <tcp_process+0x6e8>)
 800d87e:	49b5      	ldr	r1, [pc, #724]	; (800db54 <tcp_process+0x6ec>)
 800d880:	48b5      	ldr	r0, [pc, #724]	; (800db58 <tcp_process+0x6f0>)
 800d882:	f7f5 f82b 	bl	80028dc <app_debug_rtt_raw>
#endif
            tcp_backlog_accepted(pcb);
            /* Call the accept function. */
            TCP_EVENT_ACCEPT(pcb->listener, pcb, pcb->callback_arg, ERR_OK, err);
 800d886:	687b      	ldr	r3, [r7, #4]
 800d888:	2280      	movs	r2, #128	; 0x80
 800d88a:	589b      	ldr	r3, [r3, r2]
 800d88c:	69db      	ldr	r3, [r3, #28]
 800d88e:	2b00      	cmp	r3, #0
 800d890:	d00e      	beq.n	800d8b0 <tcp_process+0x448>
 800d892:	687b      	ldr	r3, [r7, #4]
 800d894:	2280      	movs	r2, #128	; 0x80
 800d896:	589b      	ldr	r3, [r3, r2]
 800d898:	69dd      	ldr	r5, [r3, #28]
 800d89a:	687b      	ldr	r3, [r7, #4]
 800d89c:	695b      	ldr	r3, [r3, #20]
 800d89e:	221e      	movs	r2, #30
 800d8a0:	18bc      	adds	r4, r7, r2
 800d8a2:	6879      	ldr	r1, [r7, #4]
 800d8a4:	2200      	movs	r2, #0
 800d8a6:	0018      	movs	r0, r3
 800d8a8:	47a8      	blx	r5
 800d8aa:	0003      	movs	r3, r0
 800d8ac:	7023      	strb	r3, [r4, #0]
 800d8ae:	e003      	b.n	800d8b8 <tcp_process+0x450>
 800d8b0:	231e      	movs	r3, #30
 800d8b2:	18fb      	adds	r3, r7, r3
 800d8b4:	22f0      	movs	r2, #240	; 0xf0
 800d8b6:	701a      	strb	r2, [r3, #0]
          }
          if (err != ERR_OK) {
 800d8b8:	221e      	movs	r2, #30
 800d8ba:	18bb      	adds	r3, r7, r2
 800d8bc:	781b      	ldrb	r3, [r3, #0]
 800d8be:	b25b      	sxtb	r3, r3
 800d8c0:	2b00      	cmp	r3, #0
 800d8c2:	d00b      	beq.n	800d8dc <tcp_process+0x474>
            /* If the accept function returns with an error, we abort
             * the connection. */
            /* Already aborted? */
            if (err != ERR_ABRT) {
 800d8c4:	18bb      	adds	r3, r7, r2
 800d8c6:	781b      	ldrb	r3, [r3, #0]
 800d8c8:	b25b      	sxtb	r3, r3
 800d8ca:	330d      	adds	r3, #13
 800d8cc:	d003      	beq.n	800d8d6 <tcp_process+0x46e>
              tcp_abort(pcb);
 800d8ce:	687b      	ldr	r3, [r7, #4]
 800d8d0:	0018      	movs	r0, r3
 800d8d2:	f7fd fae9 	bl	800aea8 <tcp_abort>
            }
            return ERR_ABRT;
 800d8d6:	230d      	movs	r3, #13
 800d8d8:	425b      	negs	r3, r3
 800d8da:	e1e5      	b.n	800dca8 <tcp_process+0x840>
          }
          /* If there was any data contained within this ACK,
           * we'd better pass it on to the application as well. */
          tcp_receive(pcb);
 800d8dc:	687b      	ldr	r3, [r7, #4]
 800d8de:	0018      	movs	r0, r3
 800d8e0:	f000 fb42 	bl	800df68 <tcp_receive>

          /* Prevent ACK for SYN to generate a sent event */
          if (recv_acked != 0) {
 800d8e4:	4b9d      	ldr	r3, [pc, #628]	; (800db5c <tcp_process+0x6f4>)
 800d8e6:	881b      	ldrh	r3, [r3, #0]
 800d8e8:	2b00      	cmp	r3, #0
 800d8ea:	d005      	beq.n	800d8f8 <tcp_process+0x490>
            recv_acked--;
 800d8ec:	4b9b      	ldr	r3, [pc, #620]	; (800db5c <tcp_process+0x6f4>)
 800d8ee:	881b      	ldrh	r3, [r3, #0]
 800d8f0:	3b01      	subs	r3, #1
 800d8f2:	b29a      	uxth	r2, r3
 800d8f4:	4b99      	ldr	r3, [pc, #612]	; (800db5c <tcp_process+0x6f4>)
 800d8f6:	801a      	strh	r2, [r3, #0]
          }

          pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
 800d8f8:	687b      	ldr	r3, [r7, #4]
 800d8fa:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800d8fc:	009a      	lsls	r2, r3, #2
 800d8fe:	687b      	ldr	r3, [r7, #4]
 800d900:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800d902:	005b      	lsls	r3, r3, #1
 800d904:	4996      	ldr	r1, [pc, #600]	; (800db60 <tcp_process+0x6f8>)
 800d906:	428b      	cmp	r3, r1
 800d908:	d200      	bcs.n	800d90c <tcp_process+0x4a4>
 800d90a:	4b95      	ldr	r3, [pc, #596]	; (800db60 <tcp_process+0x6f8>)
 800d90c:	429a      	cmp	r2, r3
 800d90e:	d204      	bcs.n	800d91a <tcp_process+0x4b2>
 800d910:	687b      	ldr	r3, [r7, #4]
 800d912:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800d914:	009b      	lsls	r3, r3, #2
 800d916:	b29b      	uxth	r3, r3
 800d918:	e00b      	b.n	800d932 <tcp_process+0x4ca>
 800d91a:	687b      	ldr	r3, [r7, #4]
 800d91c:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800d91e:	005b      	lsls	r3, r3, #1
 800d920:	4a8f      	ldr	r2, [pc, #572]	; (800db60 <tcp_process+0x6f8>)
 800d922:	4293      	cmp	r3, r2
 800d924:	d904      	bls.n	800d930 <tcp_process+0x4c8>
 800d926:	687b      	ldr	r3, [r7, #4]
 800d928:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800d92a:	18db      	adds	r3, r3, r3
 800d92c:	b29b      	uxth	r3, r3
 800d92e:	e000      	b.n	800d932 <tcp_process+0x4ca>
 800d930:	4b8b      	ldr	r3, [pc, #556]	; (800db60 <tcp_process+0x6f8>)
 800d932:	687a      	ldr	r2, [r7, #4]
 800d934:	214c      	movs	r1, #76	; 0x4c
 800d936:	5253      	strh	r3, [r2, r1]
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SYN_RCVD): cwnd %"TCPWNDSIZE_F
                                       " ssthresh %"TCPWNDSIZE_F"\n",
                                       pcb->cwnd, pcb->ssthresh));

          if (recv_flags & TF_GOT_FIN) {
 800d938:	4b8a      	ldr	r3, [pc, #552]	; (800db64 <tcp_process+0x6fc>)
 800d93a:	781b      	ldrb	r3, [r3, #0]
 800d93c:	001a      	movs	r2, r3
 800d93e:	2320      	movs	r3, #32
 800d940:	4013      	ands	r3, r2
 800d942:	d040      	beq.n	800d9c6 <tcp_process+0x55e>
            tcp_ack_now(pcb);
 800d944:	687b      	ldr	r3, [r7, #4]
 800d946:	8bdb      	ldrh	r3, [r3, #30]
 800d948:	2202      	movs	r2, #2
 800d94a:	4313      	orrs	r3, r2
 800d94c:	b29a      	uxth	r2, r3
 800d94e:	687b      	ldr	r3, [r7, #4]
 800d950:	83da      	strh	r2, [r3, #30]
            pcb->state = CLOSE_WAIT;
 800d952:	687b      	ldr	r3, [r7, #4]
 800d954:	2207      	movs	r2, #7
 800d956:	761a      	strb	r2, [r3, #24]
          if (recv_flags & TF_GOT_FIN) {
 800d958:	e035      	b.n	800d9c6 <tcp_process+0x55e>
          }
        } else {
          /* incorrect ACK number, send RST */
          tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d95a:	4b7b      	ldr	r3, [pc, #492]	; (800db48 <tcp_process+0x6e0>)
 800d95c:	681c      	ldr	r4, [r3, #0]
 800d95e:	4b82      	ldr	r3, [pc, #520]	; (800db68 <tcp_process+0x700>)
 800d960:	881b      	ldrh	r3, [r3, #0]
 800d962:	001a      	movs	r2, r3
 800d964:	4b81      	ldr	r3, [pc, #516]	; (800db6c <tcp_process+0x704>)
 800d966:	681b      	ldr	r3, [r3, #0]
 800d968:	18d5      	adds	r5, r2, r3
                  ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800d96a:	4b81      	ldr	r3, [pc, #516]	; (800db70 <tcp_process+0x708>)
 800d96c:	681b      	ldr	r3, [r3, #0]
          tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d96e:	789a      	ldrb	r2, [r3, #2]
 800d970:	78db      	ldrb	r3, [r3, #3]
 800d972:	021b      	lsls	r3, r3, #8
 800d974:	4313      	orrs	r3, r2
 800d976:	b29a      	uxth	r2, r3
                  ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800d978:	4b7d      	ldr	r3, [pc, #500]	; (800db70 <tcp_process+0x708>)
 800d97a:	681b      	ldr	r3, [r3, #0]
          tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d97c:	7819      	ldrb	r1, [r3, #0]
 800d97e:	785b      	ldrb	r3, [r3, #1]
 800d980:	021b      	lsls	r3, r3, #8
 800d982:	430b      	orrs	r3, r1
 800d984:	b29b      	uxth	r3, r3
 800d986:	497b      	ldr	r1, [pc, #492]	; (800db74 <tcp_process+0x70c>)
 800d988:	6878      	ldr	r0, [r7, #4]
 800d98a:	9302      	str	r3, [sp, #8]
 800d98c:	9201      	str	r2, [sp, #4]
 800d98e:	4b7a      	ldr	r3, [pc, #488]	; (800db78 <tcp_process+0x710>)
 800d990:	9300      	str	r3, [sp, #0]
 800d992:	000b      	movs	r3, r1
 800d994:	002a      	movs	r2, r5
 800d996:	0021      	movs	r1, r4
 800d998:	f004 f8ce 	bl	8011b38 <tcp_rst>
        }
      } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
        /* Looks like another copy of the SYN - retransmit our SYN-ACK */
        tcp_rexmit(pcb);
      }
      break;
 800d99c:	e178      	b.n	800dc90 <tcp_process+0x828>
      } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
 800d99e:	4b69      	ldr	r3, [pc, #420]	; (800db44 <tcp_process+0x6dc>)
 800d9a0:	781b      	ldrb	r3, [r3, #0]
 800d9a2:	001a      	movs	r2, r3
 800d9a4:	2302      	movs	r3, #2
 800d9a6:	4013      	ands	r3, r2
 800d9a8:	d100      	bne.n	800d9ac <tcp_process+0x544>
 800d9aa:	e171      	b.n	800dc90 <tcp_process+0x828>
 800d9ac:	687b      	ldr	r3, [r7, #4]
 800d9ae:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800d9b0:	1e5a      	subs	r2, r3, #1
 800d9b2:	4b6e      	ldr	r3, [pc, #440]	; (800db6c <tcp_process+0x704>)
 800d9b4:	681b      	ldr	r3, [r3, #0]
 800d9b6:	429a      	cmp	r2, r3
 800d9b8:	d000      	beq.n	800d9bc <tcp_process+0x554>
 800d9ba:	e169      	b.n	800dc90 <tcp_process+0x828>
        tcp_rexmit(pcb);
 800d9bc:	687b      	ldr	r3, [r7, #4]
 800d9be:	0018      	movs	r0, r3
 800d9c0:	f003 fd96 	bl	80114f0 <tcp_rexmit>
      break;
 800d9c4:	e164      	b.n	800dc90 <tcp_process+0x828>
 800d9c6:	e163      	b.n	800dc90 <tcp_process+0x828>
    case CLOSE_WAIT:
    /* FALLTHROUGH */
    case ESTABLISHED:
      tcp_receive(pcb);
 800d9c8:	687b      	ldr	r3, [r7, #4]
 800d9ca:	0018      	movs	r0, r3
 800d9cc:	f000 facc 	bl	800df68 <tcp_receive>
      if (recv_flags & TF_GOT_FIN) { /* passive close */
 800d9d0:	4b64      	ldr	r3, [pc, #400]	; (800db64 <tcp_process+0x6fc>)
 800d9d2:	781b      	ldrb	r3, [r3, #0]
 800d9d4:	001a      	movs	r2, r3
 800d9d6:	2320      	movs	r3, #32
 800d9d8:	4013      	ands	r3, r2
 800d9da:	d100      	bne.n	800d9de <tcp_process+0x576>
 800d9dc:	e15a      	b.n	800dc94 <tcp_process+0x82c>
        tcp_ack_now(pcb);
 800d9de:	687b      	ldr	r3, [r7, #4]
 800d9e0:	8bdb      	ldrh	r3, [r3, #30]
 800d9e2:	2202      	movs	r2, #2
 800d9e4:	4313      	orrs	r3, r2
 800d9e6:	b29a      	uxth	r2, r3
 800d9e8:	687b      	ldr	r3, [r7, #4]
 800d9ea:	83da      	strh	r2, [r3, #30]
        pcb->state = CLOSE_WAIT;
 800d9ec:	687b      	ldr	r3, [r7, #4]
 800d9ee:	2207      	movs	r2, #7
 800d9f0:	761a      	strb	r2, [r3, #24]
      }
      break;
 800d9f2:	e14f      	b.n	800dc94 <tcp_process+0x82c>
    case FIN_WAIT_1:
      tcp_receive(pcb);
 800d9f4:	687b      	ldr	r3, [r7, #4]
 800d9f6:	0018      	movs	r0, r3
 800d9f8:	f000 fab6 	bl	800df68 <tcp_receive>
      if (recv_flags & TF_GOT_FIN) {
 800d9fc:	4b59      	ldr	r3, [pc, #356]	; (800db64 <tcp_process+0x6fc>)
 800d9fe:	781b      	ldrb	r3, [r3, #0]
 800da00:	001a      	movs	r2, r3
 800da02:	2320      	movs	r3, #32
 800da04:	4013      	ands	r3, r2
 800da06:	d057      	beq.n	800dab8 <tcp_process+0x650>
        if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 800da08:	4b4e      	ldr	r3, [pc, #312]	; (800db44 <tcp_process+0x6dc>)
 800da0a:	781b      	ldrb	r3, [r3, #0]
 800da0c:	001a      	movs	r2, r3
 800da0e:	2310      	movs	r3, #16
 800da10:	4013      	ands	r3, r2
 800da12:	d046      	beq.n	800daa2 <tcp_process+0x63a>
 800da14:	687b      	ldr	r3, [r7, #4]
 800da16:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800da18:	4b4b      	ldr	r3, [pc, #300]	; (800db48 <tcp_process+0x6e0>)
 800da1a:	681b      	ldr	r3, [r3, #0]
 800da1c:	429a      	cmp	r2, r3
 800da1e:	d140      	bne.n	800daa2 <tcp_process+0x63a>
            pcb->unsent == NULL) {
 800da20:	687b      	ldr	r3, [r7, #4]
 800da22:	6f1b      	ldr	r3, [r3, #112]	; 0x70
        if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 800da24:	2b00      	cmp	r3, #0
 800da26:	d13c      	bne.n	800daa2 <tcp_process+0x63a>
          LWIP_DEBUGF(TCP_DEBUG,
                      ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
          tcp_ack_now(pcb);
 800da28:	687b      	ldr	r3, [r7, #4]
 800da2a:	8bdb      	ldrh	r3, [r3, #30]
 800da2c:	2202      	movs	r2, #2
 800da2e:	4313      	orrs	r3, r2
 800da30:	b29a      	uxth	r2, r3
 800da32:	687b      	ldr	r3, [r7, #4]
 800da34:	83da      	strh	r2, [r3, #30]
          tcp_pcb_purge(pcb);
 800da36:	687b      	ldr	r3, [r7, #4]
 800da38:	0018      	movs	r0, r3
 800da3a:	f7fe fbfd 	bl	800c238 <tcp_pcb_purge>
          TCP_RMV_ACTIVE(pcb);
 800da3e:	4b4f      	ldr	r3, [pc, #316]	; (800db7c <tcp_process+0x714>)
 800da40:	681b      	ldr	r3, [r3, #0]
 800da42:	687a      	ldr	r2, [r7, #4]
 800da44:	429a      	cmp	r2, r3
 800da46:	d105      	bne.n	800da54 <tcp_process+0x5ec>
 800da48:	4b4c      	ldr	r3, [pc, #304]	; (800db7c <tcp_process+0x714>)
 800da4a:	681b      	ldr	r3, [r3, #0]
 800da4c:	691a      	ldr	r2, [r3, #16]
 800da4e:	4b4b      	ldr	r3, [pc, #300]	; (800db7c <tcp_process+0x714>)
 800da50:	601a      	str	r2, [r3, #0]
 800da52:	e013      	b.n	800da7c <tcp_process+0x614>
 800da54:	4b49      	ldr	r3, [pc, #292]	; (800db7c <tcp_process+0x714>)
 800da56:	681b      	ldr	r3, [r3, #0]
 800da58:	613b      	str	r3, [r7, #16]
 800da5a:	e00c      	b.n	800da76 <tcp_process+0x60e>
 800da5c:	693b      	ldr	r3, [r7, #16]
 800da5e:	691b      	ldr	r3, [r3, #16]
 800da60:	687a      	ldr	r2, [r7, #4]
 800da62:	429a      	cmp	r2, r3
 800da64:	d104      	bne.n	800da70 <tcp_process+0x608>
 800da66:	687b      	ldr	r3, [r7, #4]
 800da68:	691a      	ldr	r2, [r3, #16]
 800da6a:	693b      	ldr	r3, [r7, #16]
 800da6c:	611a      	str	r2, [r3, #16]
 800da6e:	e005      	b.n	800da7c <tcp_process+0x614>
 800da70:	693b      	ldr	r3, [r7, #16]
 800da72:	691b      	ldr	r3, [r3, #16]
 800da74:	613b      	str	r3, [r7, #16]
 800da76:	693b      	ldr	r3, [r7, #16]
 800da78:	2b00      	cmp	r3, #0
 800da7a:	d1ef      	bne.n	800da5c <tcp_process+0x5f4>
 800da7c:	687b      	ldr	r3, [r7, #4]
 800da7e:	2200      	movs	r2, #0
 800da80:	611a      	str	r2, [r3, #16]
 800da82:	4b3f      	ldr	r3, [pc, #252]	; (800db80 <tcp_process+0x718>)
 800da84:	2201      	movs	r2, #1
 800da86:	701a      	strb	r2, [r3, #0]
          pcb->state = TIME_WAIT;
 800da88:	687b      	ldr	r3, [r7, #4]
 800da8a:	220a      	movs	r2, #10
 800da8c:	761a      	strb	r2, [r3, #24]
          TCP_REG(&tcp_tw_pcbs, pcb);
 800da8e:	4b3d      	ldr	r3, [pc, #244]	; (800db84 <tcp_process+0x71c>)
 800da90:	681a      	ldr	r2, [r3, #0]
 800da92:	687b      	ldr	r3, [r7, #4]
 800da94:	611a      	str	r2, [r3, #16]
 800da96:	4b3b      	ldr	r3, [pc, #236]	; (800db84 <tcp_process+0x71c>)
 800da98:	687a      	ldr	r2, [r7, #4]
 800da9a:	601a      	str	r2, [r3, #0]
 800da9c:	f004 fa76 	bl	8011f8c <tcp_timer_needed>
        }
      } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
                 pcb->unsent == NULL) {
        pcb->state = FIN_WAIT_2;
      }
      break;
 800daa0:	e0fa      	b.n	800dc98 <tcp_process+0x830>
          tcp_ack_now(pcb);
 800daa2:	687b      	ldr	r3, [r7, #4]
 800daa4:	8bdb      	ldrh	r3, [r3, #30]
 800daa6:	2202      	movs	r2, #2
 800daa8:	4313      	orrs	r3, r2
 800daaa:	b29a      	uxth	r2, r3
 800daac:	687b      	ldr	r3, [r7, #4]
 800daae:	83da      	strh	r2, [r3, #30]
          pcb->state = CLOSING;
 800dab0:	687b      	ldr	r3, [r7, #4]
 800dab2:	2208      	movs	r2, #8
 800dab4:	761a      	strb	r2, [r3, #24]
      break;
 800dab6:	e0ef      	b.n	800dc98 <tcp_process+0x830>
      } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 800dab8:	4b22      	ldr	r3, [pc, #136]	; (800db44 <tcp_process+0x6dc>)
 800daba:	781b      	ldrb	r3, [r3, #0]
 800dabc:	001a      	movs	r2, r3
 800dabe:	2310      	movs	r3, #16
 800dac0:	4013      	ands	r3, r2
 800dac2:	d100      	bne.n	800dac6 <tcp_process+0x65e>
 800dac4:	e0e8      	b.n	800dc98 <tcp_process+0x830>
 800dac6:	687b      	ldr	r3, [r7, #4]
 800dac8:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800daca:	4b1f      	ldr	r3, [pc, #124]	; (800db48 <tcp_process+0x6e0>)
 800dacc:	681b      	ldr	r3, [r3, #0]
 800dace:	429a      	cmp	r2, r3
 800dad0:	d000      	beq.n	800dad4 <tcp_process+0x66c>
 800dad2:	e0e1      	b.n	800dc98 <tcp_process+0x830>
                 pcb->unsent == NULL) {
 800dad4:	687b      	ldr	r3, [r7, #4]
 800dad6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
      } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 800dad8:	2b00      	cmp	r3, #0
 800dada:	d000      	beq.n	800dade <tcp_process+0x676>
 800dadc:	e0dc      	b.n	800dc98 <tcp_process+0x830>
        pcb->state = FIN_WAIT_2;
 800dade:	687b      	ldr	r3, [r7, #4]
 800dae0:	2206      	movs	r2, #6
 800dae2:	761a      	strb	r2, [r3, #24]
      break;
 800dae4:	e0d8      	b.n	800dc98 <tcp_process+0x830>
    case FIN_WAIT_2:
      tcp_receive(pcb);
 800dae6:	687b      	ldr	r3, [r7, #4]
 800dae8:	0018      	movs	r0, r3
 800daea:	f000 fa3d 	bl	800df68 <tcp_receive>
      if (recv_flags & TF_GOT_FIN) {
 800daee:	4b1d      	ldr	r3, [pc, #116]	; (800db64 <tcp_process+0x6fc>)
 800daf0:	781b      	ldrb	r3, [r3, #0]
 800daf2:	001a      	movs	r2, r3
 800daf4:	2320      	movs	r3, #32
 800daf6:	4013      	ands	r3, r2
 800daf8:	d100      	bne.n	800dafc <tcp_process+0x694>
 800dafa:	e0cf      	b.n	800dc9c <tcp_process+0x834>
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
 800dafc:	687b      	ldr	r3, [r7, #4]
 800dafe:	8bdb      	ldrh	r3, [r3, #30]
 800db00:	2202      	movs	r2, #2
 800db02:	4313      	orrs	r3, r2
 800db04:	b29a      	uxth	r2, r3
 800db06:	687b      	ldr	r3, [r7, #4]
 800db08:	83da      	strh	r2, [r3, #30]
        tcp_pcb_purge(pcb);
 800db0a:	687b      	ldr	r3, [r7, #4]
 800db0c:	0018      	movs	r0, r3
 800db0e:	f7fe fb93 	bl	800c238 <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
 800db12:	4b1a      	ldr	r3, [pc, #104]	; (800db7c <tcp_process+0x714>)
 800db14:	681b      	ldr	r3, [r3, #0]
 800db16:	687a      	ldr	r2, [r7, #4]
 800db18:	429a      	cmp	r2, r3
 800db1a:	d105      	bne.n	800db28 <tcp_process+0x6c0>
 800db1c:	4b17      	ldr	r3, [pc, #92]	; (800db7c <tcp_process+0x714>)
 800db1e:	681b      	ldr	r3, [r3, #0]
 800db20:	691a      	ldr	r2, [r3, #16]
 800db22:	4b16      	ldr	r3, [pc, #88]	; (800db7c <tcp_process+0x714>)
 800db24:	601a      	str	r2, [r3, #0]
 800db26:	e035      	b.n	800db94 <tcp_process+0x72c>
 800db28:	4b14      	ldr	r3, [pc, #80]	; (800db7c <tcp_process+0x714>)
 800db2a:	681b      	ldr	r3, [r3, #0]
 800db2c:	60fb      	str	r3, [r7, #12]
 800db2e:	e02e      	b.n	800db8e <tcp_process+0x726>
 800db30:	68fb      	ldr	r3, [r7, #12]
 800db32:	691b      	ldr	r3, [r3, #16]
 800db34:	687a      	ldr	r2, [r7, #4]
 800db36:	429a      	cmp	r2, r3
 800db38:	d126      	bne.n	800db88 <tcp_process+0x720>
 800db3a:	687b      	ldr	r3, [r7, #4]
 800db3c:	691a      	ldr	r2, [r3, #16]
 800db3e:	68fb      	ldr	r3, [r7, #12]
 800db40:	611a      	str	r2, [r3, #16]
 800db42:	e027      	b.n	800db94 <tcp_process+0x72c>
 800db44:	20001b5c 	.word	0x20001b5c
 800db48:	20001b54 	.word	0x20001b54
 800db4c:	080201e0 	.word	0x080201e0
 800db50:	000003a9 	.word	0x000003a9
 800db54:	08020478 	.word	0x08020478
 800db58:	08020220 	.word	0x08020220
 800db5c:	20001b58 	.word	0x20001b58
 800db60:	0000111c 	.word	0x0000111c
 800db64:	20001b5d 	.word	0x20001b5d
 800db68:	20001b5a 	.word	0x20001b5a
 800db6c:	20001b50 	.word	0x20001b50
 800db70:	20001b40 	.word	0x20001b40
 800db74:	20001ca8 	.word	0x20001ca8
 800db78:	20001ca4 	.word	0x20001ca4
 800db7c:	20002ed4 	.word	0x20002ed4
 800db80:	20002ed0 	.word	0x20002ed0
 800db84:	20002ee4 	.word	0x20002ee4
 800db88:	68fb      	ldr	r3, [r7, #12]
 800db8a:	691b      	ldr	r3, [r3, #16]
 800db8c:	60fb      	str	r3, [r7, #12]
 800db8e:	68fb      	ldr	r3, [r7, #12]
 800db90:	2b00      	cmp	r3, #0
 800db92:	d1cd      	bne.n	800db30 <tcp_process+0x6c8>
 800db94:	687b      	ldr	r3, [r7, #4]
 800db96:	2200      	movs	r2, #0
 800db98:	611a      	str	r2, [r3, #16]
 800db9a:	4b45      	ldr	r3, [pc, #276]	; (800dcb0 <tcp_process+0x848>)
 800db9c:	2201      	movs	r2, #1
 800db9e:	701a      	strb	r2, [r3, #0]
        pcb->state = TIME_WAIT;
 800dba0:	687b      	ldr	r3, [r7, #4]
 800dba2:	220a      	movs	r2, #10
 800dba4:	761a      	strb	r2, [r3, #24]
        TCP_REG(&tcp_tw_pcbs, pcb);
 800dba6:	4b43      	ldr	r3, [pc, #268]	; (800dcb4 <tcp_process+0x84c>)
 800dba8:	681a      	ldr	r2, [r3, #0]
 800dbaa:	687b      	ldr	r3, [r7, #4]
 800dbac:	611a      	str	r2, [r3, #16]
 800dbae:	4b41      	ldr	r3, [pc, #260]	; (800dcb4 <tcp_process+0x84c>)
 800dbb0:	687a      	ldr	r2, [r7, #4]
 800dbb2:	601a      	str	r2, [r3, #0]
 800dbb4:	f004 f9ea 	bl	8011f8c <tcp_timer_needed>
      }
      break;
 800dbb8:	e070      	b.n	800dc9c <tcp_process+0x834>
    case CLOSING:
      tcp_receive(pcb);
 800dbba:	687b      	ldr	r3, [r7, #4]
 800dbbc:	0018      	movs	r0, r3
 800dbbe:	f000 f9d3 	bl	800df68 <tcp_receive>
      if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
 800dbc2:	4b3d      	ldr	r3, [pc, #244]	; (800dcb8 <tcp_process+0x850>)
 800dbc4:	781b      	ldrb	r3, [r3, #0]
 800dbc6:	001a      	movs	r2, r3
 800dbc8:	2310      	movs	r3, #16
 800dbca:	4013      	ands	r3, r2
 800dbcc:	d100      	bne.n	800dbd0 <tcp_process+0x768>
 800dbce:	e067      	b.n	800dca0 <tcp_process+0x838>
 800dbd0:	687b      	ldr	r3, [r7, #4]
 800dbd2:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800dbd4:	4b39      	ldr	r3, [pc, #228]	; (800dcbc <tcp_process+0x854>)
 800dbd6:	681b      	ldr	r3, [r3, #0]
 800dbd8:	429a      	cmp	r2, r3
 800dbda:	d161      	bne.n	800dca0 <tcp_process+0x838>
 800dbdc:	687b      	ldr	r3, [r7, #4]
 800dbde:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800dbe0:	2b00      	cmp	r3, #0
 800dbe2:	d15d      	bne.n	800dca0 <tcp_process+0x838>
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_pcb_purge(pcb);
 800dbe4:	687b      	ldr	r3, [r7, #4]
 800dbe6:	0018      	movs	r0, r3
 800dbe8:	f7fe fb26 	bl	800c238 <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
 800dbec:	4b34      	ldr	r3, [pc, #208]	; (800dcc0 <tcp_process+0x858>)
 800dbee:	681b      	ldr	r3, [r3, #0]
 800dbf0:	687a      	ldr	r2, [r7, #4]
 800dbf2:	429a      	cmp	r2, r3
 800dbf4:	d105      	bne.n	800dc02 <tcp_process+0x79a>
 800dbf6:	4b32      	ldr	r3, [pc, #200]	; (800dcc0 <tcp_process+0x858>)
 800dbf8:	681b      	ldr	r3, [r3, #0]
 800dbfa:	691a      	ldr	r2, [r3, #16]
 800dbfc:	4b30      	ldr	r3, [pc, #192]	; (800dcc0 <tcp_process+0x858>)
 800dbfe:	601a      	str	r2, [r3, #0]
 800dc00:	e013      	b.n	800dc2a <tcp_process+0x7c2>
 800dc02:	4b2f      	ldr	r3, [pc, #188]	; (800dcc0 <tcp_process+0x858>)
 800dc04:	681b      	ldr	r3, [r3, #0]
 800dc06:	61bb      	str	r3, [r7, #24]
 800dc08:	e00c      	b.n	800dc24 <tcp_process+0x7bc>
 800dc0a:	69bb      	ldr	r3, [r7, #24]
 800dc0c:	691b      	ldr	r3, [r3, #16]
 800dc0e:	687a      	ldr	r2, [r7, #4]
 800dc10:	429a      	cmp	r2, r3
 800dc12:	d104      	bne.n	800dc1e <tcp_process+0x7b6>
 800dc14:	687b      	ldr	r3, [r7, #4]
 800dc16:	691a      	ldr	r2, [r3, #16]
 800dc18:	69bb      	ldr	r3, [r7, #24]
 800dc1a:	611a      	str	r2, [r3, #16]
 800dc1c:	e005      	b.n	800dc2a <tcp_process+0x7c2>
 800dc1e:	69bb      	ldr	r3, [r7, #24]
 800dc20:	691b      	ldr	r3, [r3, #16]
 800dc22:	61bb      	str	r3, [r7, #24]
 800dc24:	69bb      	ldr	r3, [r7, #24]
 800dc26:	2b00      	cmp	r3, #0
 800dc28:	d1ef      	bne.n	800dc0a <tcp_process+0x7a2>
 800dc2a:	687b      	ldr	r3, [r7, #4]
 800dc2c:	2200      	movs	r2, #0
 800dc2e:	611a      	str	r2, [r3, #16]
 800dc30:	4b1f      	ldr	r3, [pc, #124]	; (800dcb0 <tcp_process+0x848>)
 800dc32:	2201      	movs	r2, #1
 800dc34:	701a      	strb	r2, [r3, #0]
        pcb->state = TIME_WAIT;
 800dc36:	687b      	ldr	r3, [r7, #4]
 800dc38:	220a      	movs	r2, #10
 800dc3a:	761a      	strb	r2, [r3, #24]
        TCP_REG(&tcp_tw_pcbs, pcb);
 800dc3c:	4b1d      	ldr	r3, [pc, #116]	; (800dcb4 <tcp_process+0x84c>)
 800dc3e:	681a      	ldr	r2, [r3, #0]
 800dc40:	687b      	ldr	r3, [r7, #4]
 800dc42:	611a      	str	r2, [r3, #16]
 800dc44:	4b1b      	ldr	r3, [pc, #108]	; (800dcb4 <tcp_process+0x84c>)
 800dc46:	687a      	ldr	r2, [r7, #4]
 800dc48:	601a      	str	r2, [r3, #0]
 800dc4a:	f004 f99f 	bl	8011f8c <tcp_timer_needed>
      }
      break;
 800dc4e:	e027      	b.n	800dca0 <tcp_process+0x838>
    case LAST_ACK:
      tcp_receive(pcb);
 800dc50:	687b      	ldr	r3, [r7, #4]
 800dc52:	0018      	movs	r0, r3
 800dc54:	f000 f988 	bl	800df68 <tcp_receive>
      if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
 800dc58:	4b17      	ldr	r3, [pc, #92]	; (800dcb8 <tcp_process+0x850>)
 800dc5a:	781b      	ldrb	r3, [r3, #0]
 800dc5c:	001a      	movs	r2, r3
 800dc5e:	2310      	movs	r3, #16
 800dc60:	4013      	ands	r3, r2
 800dc62:	d01f      	beq.n	800dca4 <tcp_process+0x83c>
 800dc64:	687b      	ldr	r3, [r7, #4]
 800dc66:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800dc68:	4b14      	ldr	r3, [pc, #80]	; (800dcbc <tcp_process+0x854>)
 800dc6a:	681b      	ldr	r3, [r3, #0]
 800dc6c:	429a      	cmp	r2, r3
 800dc6e:	d119      	bne.n	800dca4 <tcp_process+0x83c>
 800dc70:	687b      	ldr	r3, [r7, #4]
 800dc72:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800dc74:	2b00      	cmp	r3, #0
 800dc76:	d115      	bne.n	800dca4 <tcp_process+0x83c>
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
        recv_flags |= TF_CLOSED;
 800dc78:	4b12      	ldr	r3, [pc, #72]	; (800dcc4 <tcp_process+0x85c>)
 800dc7a:	781b      	ldrb	r3, [r3, #0]
 800dc7c:	2210      	movs	r2, #16
 800dc7e:	4313      	orrs	r3, r2
 800dc80:	b2da      	uxtb	r2, r3
 800dc82:	4b10      	ldr	r3, [pc, #64]	; (800dcc4 <tcp_process+0x85c>)
 800dc84:	701a      	strb	r2, [r3, #0]
      }
      break;
 800dc86:	e00d      	b.n	800dca4 <tcp_process+0x83c>
    default:
      break;
 800dc88:	46c0      	nop			; (mov r8, r8)
 800dc8a:	e00c      	b.n	800dca6 <tcp_process+0x83e>
      break;
 800dc8c:	46c0      	nop			; (mov r8, r8)
 800dc8e:	e00a      	b.n	800dca6 <tcp_process+0x83e>
      break;
 800dc90:	46c0      	nop			; (mov r8, r8)
 800dc92:	e008      	b.n	800dca6 <tcp_process+0x83e>
      break;
 800dc94:	46c0      	nop			; (mov r8, r8)
 800dc96:	e006      	b.n	800dca6 <tcp_process+0x83e>
      break;
 800dc98:	46c0      	nop			; (mov r8, r8)
 800dc9a:	e004      	b.n	800dca6 <tcp_process+0x83e>
      break;
 800dc9c:	46c0      	nop			; (mov r8, r8)
 800dc9e:	e002      	b.n	800dca6 <tcp_process+0x83e>
      break;
 800dca0:	46c0      	nop			; (mov r8, r8)
 800dca2:	e000      	b.n	800dca6 <tcp_process+0x83e>
      break;
 800dca4:	46c0      	nop			; (mov r8, r8)
  }
  return ERR_OK;
 800dca6:	2300      	movs	r3, #0
}
 800dca8:	0018      	movs	r0, r3
 800dcaa:	46bd      	mov	sp, r7
 800dcac:	b008      	add	sp, #32
 800dcae:	bdb0      	pop	{r4, r5, r7, pc}
 800dcb0:	20002ed0 	.word	0x20002ed0
 800dcb4:	20002ee4 	.word	0x20002ee4
 800dcb8:	20001b5c 	.word	0x20001b5c
 800dcbc:	20001b54 	.word	0x20001b54
 800dcc0:	20002ed4 	.word	0x20002ed4
 800dcc4:	20001b5d 	.word	0x20001b5d

0800dcc8 <tcp_oos_insert_segment>:
 *
 * Called from tcp_receive()
 */
static void
tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
{
 800dcc8:	b590      	push	{r4, r7, lr}
 800dcca:	b085      	sub	sp, #20
 800dccc:	af00      	add	r7, sp, #0
 800dcce:	6078      	str	r0, [r7, #4]
 800dcd0:	6039      	str	r1, [r7, #0]
  struct tcp_seg *old_seg;

  LWIP_ASSERT("tcp_oos_insert_segment: invalid cseg", cseg != NULL);
 800dcd2:	687b      	ldr	r3, [r7, #4]
 800dcd4:	2b00      	cmp	r3, #0
 800dcd6:	d106      	bne.n	800dce6 <tcp_oos_insert_segment+0x1e>
 800dcd8:	4b57      	ldr	r3, [pc, #348]	; (800de38 <tcp_oos_insert_segment+0x170>)
 800dcda:	2284      	movs	r2, #132	; 0x84
 800dcdc:	00d2      	lsls	r2, r2, #3
 800dcde:	4957      	ldr	r1, [pc, #348]	; (800de3c <tcp_oos_insert_segment+0x174>)
 800dce0:	4857      	ldr	r0, [pc, #348]	; (800de40 <tcp_oos_insert_segment+0x178>)
 800dce2:	f7f4 fdfb 	bl	80028dc <app_debug_rtt_raw>

  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 800dce6:	687b      	ldr	r3, [r7, #4]
 800dce8:	691b      	ldr	r3, [r3, #16]
 800dcea:	7b1a      	ldrb	r2, [r3, #12]
 800dcec:	7b5b      	ldrb	r3, [r3, #13]
 800dcee:	021b      	lsls	r3, r3, #8
 800dcf0:	4313      	orrs	r3, r2
 800dcf2:	b29b      	uxth	r3, r3
 800dcf4:	0018      	movs	r0, r3
 800dcf6:	f7f8 ff87 	bl	8006c08 <lwip_htons>
 800dcfa:	0003      	movs	r3, r0
 800dcfc:	b2db      	uxtb	r3, r3
 800dcfe:	001a      	movs	r2, r3
 800dd00:	2301      	movs	r3, #1
 800dd02:	4013      	ands	r3, r2
 800dd04:	d042      	beq.n	800dd8c <tcp_oos_insert_segment+0xc4>
    /* received segment overlaps all following segments */
    tcp_segs_free(next);
 800dd06:	683b      	ldr	r3, [r7, #0]
 800dd08:	0018      	movs	r0, r3
 800dd0a:	f7fd ffb7 	bl	800bc7c <tcp_segs_free>
    next = NULL;
 800dd0e:	2300      	movs	r3, #0
 800dd10:	603b      	str	r3, [r7, #0]
 800dd12:	e08a      	b.n	800de2a <tcp_oos_insert_segment+0x162>
       oos queue may have segments with FIN flag */
    while (next &&
           TCP_SEQ_GEQ((seqno + cseg->len),
                       (next->tcphdr->seqno + next->len))) {
      /* cseg with FIN already processed */
      if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 800dd14:	683b      	ldr	r3, [r7, #0]
 800dd16:	691b      	ldr	r3, [r3, #16]
 800dd18:	7b1a      	ldrb	r2, [r3, #12]
 800dd1a:	7b5b      	ldrb	r3, [r3, #13]
 800dd1c:	021b      	lsls	r3, r3, #8
 800dd1e:	4313      	orrs	r3, r2
 800dd20:	b29b      	uxth	r3, r3
 800dd22:	0018      	movs	r0, r3
 800dd24:	f7f8 ff70 	bl	8006c08 <lwip_htons>
 800dd28:	0003      	movs	r3, r0
 800dd2a:	b2db      	uxtb	r3, r3
 800dd2c:	001a      	movs	r2, r3
 800dd2e:	2301      	movs	r3, #1
 800dd30:	4013      	ands	r3, r2
 800dd32:	d022      	beq.n	800dd7a <tcp_oos_insert_segment+0xb2>
        TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
 800dd34:	687b      	ldr	r3, [r7, #4]
 800dd36:	691b      	ldr	r3, [r3, #16]
 800dd38:	7b1a      	ldrb	r2, [r3, #12]
 800dd3a:	7b5b      	ldrb	r3, [r3, #13]
 800dd3c:	021b      	lsls	r3, r3, #8
 800dd3e:	4313      	orrs	r3, r2
 800dd40:	b29c      	uxth	r4, r3
 800dd42:	2001      	movs	r0, #1
 800dd44:	f7f8 ff60 	bl	8006c08 <lwip_htons>
 800dd48:	0003      	movs	r3, r0
 800dd4a:	001a      	movs	r2, r3
 800dd4c:	687b      	ldr	r3, [r7, #4]
 800dd4e:	691b      	ldr	r3, [r3, #16]
 800dd50:	4322      	orrs	r2, r4
 800dd52:	b292      	uxth	r2, r2
 800dd54:	21ff      	movs	r1, #255	; 0xff
 800dd56:	4011      	ands	r1, r2
 800dd58:	000c      	movs	r4, r1
 800dd5a:	7b19      	ldrb	r1, [r3, #12]
 800dd5c:	2000      	movs	r0, #0
 800dd5e:	4001      	ands	r1, r0
 800dd60:	1c08      	adds	r0, r1, #0
 800dd62:	1c21      	adds	r1, r4, #0
 800dd64:	4301      	orrs	r1, r0
 800dd66:	7319      	strb	r1, [r3, #12]
 800dd68:	0a12      	lsrs	r2, r2, #8
 800dd6a:	b290      	uxth	r0, r2
 800dd6c:	7b5a      	ldrb	r2, [r3, #13]
 800dd6e:	2100      	movs	r1, #0
 800dd70:	400a      	ands	r2, r1
 800dd72:	1c11      	adds	r1, r2, #0
 800dd74:	1c02      	adds	r2, r0, #0
 800dd76:	430a      	orrs	r2, r1
 800dd78:	735a      	strb	r2, [r3, #13]
      }
      old_seg = next;
 800dd7a:	683b      	ldr	r3, [r7, #0]
 800dd7c:	60fb      	str	r3, [r7, #12]
      next = next->next;
 800dd7e:	683b      	ldr	r3, [r7, #0]
 800dd80:	681b      	ldr	r3, [r3, #0]
 800dd82:	603b      	str	r3, [r7, #0]
      tcp_seg_free(old_seg);
 800dd84:	68fb      	ldr	r3, [r7, #12]
 800dd86:	0018      	movs	r0, r3
 800dd88:	f7fd ff8e 	bl	800bca8 <tcp_seg_free>
    while (next &&
 800dd8c:	683b      	ldr	r3, [r7, #0]
 800dd8e:	2b00      	cmp	r3, #0
 800dd90:	d017      	beq.n	800ddc2 <tcp_oos_insert_segment+0xfa>
           TCP_SEQ_GEQ((seqno + cseg->len),
 800dd92:	687b      	ldr	r3, [r7, #4]
 800dd94:	891b      	ldrh	r3, [r3, #8]
 800dd96:	001a      	movs	r2, r3
 800dd98:	4b2a      	ldr	r3, [pc, #168]	; (800de44 <tcp_oos_insert_segment+0x17c>)
 800dd9a:	681b      	ldr	r3, [r3, #0]
 800dd9c:	18d2      	adds	r2, r2, r3
 800dd9e:	683b      	ldr	r3, [r7, #0]
 800dda0:	691b      	ldr	r3, [r3, #16]
 800dda2:	7919      	ldrb	r1, [r3, #4]
 800dda4:	7958      	ldrb	r0, [r3, #5]
 800dda6:	0200      	lsls	r0, r0, #8
 800dda8:	4301      	orrs	r1, r0
 800ddaa:	7998      	ldrb	r0, [r3, #6]
 800ddac:	0400      	lsls	r0, r0, #16
 800ddae:	4301      	orrs	r1, r0
 800ddb0:	79db      	ldrb	r3, [r3, #7]
 800ddb2:	061b      	lsls	r3, r3, #24
 800ddb4:	430b      	orrs	r3, r1
 800ddb6:	0019      	movs	r1, r3
 800ddb8:	683b      	ldr	r3, [r7, #0]
 800ddba:	891b      	ldrh	r3, [r3, #8]
 800ddbc:	18cb      	adds	r3, r1, r3
 800ddbe:	1ad3      	subs	r3, r2, r3
    while (next &&
 800ddc0:	d5a8      	bpl.n	800dd14 <tcp_oos_insert_segment+0x4c>
    }
    if (next &&
 800ddc2:	683b      	ldr	r3, [r7, #0]
 800ddc4:	2b00      	cmp	r3, #0
 800ddc6:	d030      	beq.n	800de2a <tcp_oos_insert_segment+0x162>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
 800ddc8:	687b      	ldr	r3, [r7, #4]
 800ddca:	891b      	ldrh	r3, [r3, #8]
 800ddcc:	001a      	movs	r2, r3
 800ddce:	4b1d      	ldr	r3, [pc, #116]	; (800de44 <tcp_oos_insert_segment+0x17c>)
 800ddd0:	681b      	ldr	r3, [r3, #0]
 800ddd2:	18d2      	adds	r2, r2, r3
 800ddd4:	683b      	ldr	r3, [r7, #0]
 800ddd6:	691b      	ldr	r3, [r3, #16]
 800ddd8:	7919      	ldrb	r1, [r3, #4]
 800ddda:	7958      	ldrb	r0, [r3, #5]
 800dddc:	0200      	lsls	r0, r0, #8
 800ddde:	4301      	orrs	r1, r0
 800dde0:	7998      	ldrb	r0, [r3, #6]
 800dde2:	0400      	lsls	r0, r0, #16
 800dde4:	4301      	orrs	r1, r0
 800dde6:	79db      	ldrb	r3, [r3, #7]
 800dde8:	061b      	lsls	r3, r3, #24
 800ddea:	430b      	orrs	r3, r1
 800ddec:	1ad3      	subs	r3, r2, r3
    if (next &&
 800ddee:	2b00      	cmp	r3, #0
 800ddf0:	dd1b      	ble.n	800de2a <tcp_oos_insert_segment+0x162>
      /* We need to trim the incoming segment. */
      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
 800ddf2:	683b      	ldr	r3, [r7, #0]
 800ddf4:	691b      	ldr	r3, [r3, #16]
 800ddf6:	791a      	ldrb	r2, [r3, #4]
 800ddf8:	7959      	ldrb	r1, [r3, #5]
 800ddfa:	0209      	lsls	r1, r1, #8
 800ddfc:	430a      	orrs	r2, r1
 800ddfe:	7999      	ldrb	r1, [r3, #6]
 800de00:	0409      	lsls	r1, r1, #16
 800de02:	430a      	orrs	r2, r1
 800de04:	79db      	ldrb	r3, [r3, #7]
 800de06:	061b      	lsls	r3, r3, #24
 800de08:	4313      	orrs	r3, r2
 800de0a:	b29a      	uxth	r2, r3
 800de0c:	4b0d      	ldr	r3, [pc, #52]	; (800de44 <tcp_oos_insert_segment+0x17c>)
 800de0e:	681b      	ldr	r3, [r3, #0]
 800de10:	b29b      	uxth	r3, r3
 800de12:	1ad3      	subs	r3, r2, r3
 800de14:	b29a      	uxth	r2, r3
 800de16:	687b      	ldr	r3, [r7, #4]
 800de18:	811a      	strh	r2, [r3, #8]
      pbuf_realloc(cseg->p, cseg->len);
 800de1a:	687b      	ldr	r3, [r7, #4]
 800de1c:	685a      	ldr	r2, [r3, #4]
 800de1e:	687b      	ldr	r3, [r7, #4]
 800de20:	891b      	ldrh	r3, [r3, #8]
 800de22:	0019      	movs	r1, r3
 800de24:	0010      	movs	r0, r2
 800de26:	f7fb fcd9 	bl	80097dc <pbuf_realloc>
    }
  }
  cseg->next = next;
 800de2a:	687b      	ldr	r3, [r7, #4]
 800de2c:	683a      	ldr	r2, [r7, #0]
 800de2e:	601a      	str	r2, [r3, #0]
}
 800de30:	46c0      	nop			; (mov r8, r8)
 800de32:	46bd      	mov	sp, r7
 800de34:	b005      	add	sp, #20
 800de36:	bd90      	pop	{r4, r7, pc}
 800de38:	080201e0 	.word	0x080201e0
 800de3c:	08020498 	.word	0x08020498
 800de40:	08020220 	.word	0x08020220
 800de44:	20001b50 	.word	0x20001b50

0800de48 <tcp_free_acked_segments>:

/** Remove segments from a list if the incoming ACK acknowledges them */
static struct tcp_seg *
tcp_free_acked_segments(struct tcp_pcb *pcb, struct tcp_seg *seg_list, const char *dbg_list_name,
                        struct tcp_seg *dbg_other_seg_list)
{
 800de48:	b5b0      	push	{r4, r5, r7, lr}
 800de4a:	b086      	sub	sp, #24
 800de4c:	af00      	add	r7, sp, #0
 800de4e:	60f8      	str	r0, [r7, #12]
 800de50:	60b9      	str	r1, [r7, #8]
 800de52:	607a      	str	r2, [r7, #4]
 800de54:	603b      	str	r3, [r7, #0]
  u16_t clen;

  LWIP_UNUSED_ARG(dbg_list_name);
  LWIP_UNUSED_ARG(dbg_other_seg_list);

  while (seg_list != NULL &&
 800de56:	e043      	b.n	800dee0 <tcp_free_acked_segments+0x98>
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->%s\n",
                                  lwip_ntohl(seg_list->tcphdr->seqno),
                                  lwip_ntohl(seg_list->tcphdr->seqno) + TCP_TCPLEN(seg_list),
                                  dbg_list_name));

    next = seg_list;
 800de58:	68bb      	ldr	r3, [r7, #8]
 800de5a:	617b      	str	r3, [r7, #20]
    seg_list = seg_list->next;
 800de5c:	68bb      	ldr	r3, [r7, #8]
 800de5e:	681b      	ldr	r3, [r3, #0]
 800de60:	60bb      	str	r3, [r7, #8]

    clen = pbuf_clen(next->p);
 800de62:	697b      	ldr	r3, [r7, #20]
 800de64:	685b      	ldr	r3, [r3, #4]
 800de66:	2512      	movs	r5, #18
 800de68:	197c      	adds	r4, r7, r5
 800de6a:	0018      	movs	r0, r3
 800de6c:	f7fb ff50 	bl	8009d10 <pbuf_clen>
 800de70:	0003      	movs	r3, r0
 800de72:	8023      	strh	r3, [r4, #0]
    LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"TCPWNDSIZE_F" ... ",
                                 (tcpwnd_size_t)pcb->snd_queuelen));
    LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= clen));
 800de74:	68fb      	ldr	r3, [r7, #12]
 800de76:	226a      	movs	r2, #106	; 0x6a
 800de78:	5a9b      	ldrh	r3, [r3, r2]
 800de7a:	197a      	adds	r2, r7, r5
 800de7c:	8812      	ldrh	r2, [r2, #0]
 800de7e:	429a      	cmp	r2, r3
 800de80:	d906      	bls.n	800de90 <tcp_free_acked_segments+0x48>
 800de82:	4b32      	ldr	r3, [pc, #200]	; (800df4c <tcp_free_acked_segments+0x104>)
 800de84:	228b      	movs	r2, #139	; 0x8b
 800de86:	00d2      	lsls	r2, r2, #3
 800de88:	4931      	ldr	r1, [pc, #196]	; (800df50 <tcp_free_acked_segments+0x108>)
 800de8a:	4832      	ldr	r0, [pc, #200]	; (800df54 <tcp_free_acked_segments+0x10c>)
 800de8c:	f7f4 fd26 	bl	80028dc <app_debug_rtt_raw>

    pcb->snd_queuelen = (u16_t)(pcb->snd_queuelen - clen);
 800de90:	68fb      	ldr	r3, [r7, #12]
 800de92:	226a      	movs	r2, #106	; 0x6a
 800de94:	5a9a      	ldrh	r2, [r3, r2]
 800de96:	2312      	movs	r3, #18
 800de98:	18fb      	adds	r3, r7, r3
 800de9a:	881b      	ldrh	r3, [r3, #0]
 800de9c:	1ad3      	subs	r3, r2, r3
 800de9e:	b299      	uxth	r1, r3
 800dea0:	68fb      	ldr	r3, [r7, #12]
 800dea2:	226a      	movs	r2, #106	; 0x6a
 800dea4:	5299      	strh	r1, [r3, r2]
    recv_acked = (tcpwnd_size_t)(recv_acked + next->len);
 800dea6:	697b      	ldr	r3, [r7, #20]
 800dea8:	891a      	ldrh	r2, [r3, #8]
 800deaa:	4b2b      	ldr	r3, [pc, #172]	; (800df58 <tcp_free_acked_segments+0x110>)
 800deac:	881b      	ldrh	r3, [r3, #0]
 800deae:	18d3      	adds	r3, r2, r3
 800deb0:	b29a      	uxth	r2, r3
 800deb2:	4b29      	ldr	r3, [pc, #164]	; (800df58 <tcp_free_acked_segments+0x110>)
 800deb4:	801a      	strh	r2, [r3, #0]
    tcp_seg_free(next);
 800deb6:	697b      	ldr	r3, [r7, #20]
 800deb8:	0018      	movs	r0, r3
 800deba:	f7fd fef5 	bl	800bca8 <tcp_seg_free>

    LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"TCPWNDSIZE_F" (after freeing %s)\n",
                                 (tcpwnd_size_t)pcb->snd_queuelen,
                                 dbg_list_name));
    if (pcb->snd_queuelen != 0) {
 800debe:	68fb      	ldr	r3, [r7, #12]
 800dec0:	226a      	movs	r2, #106	; 0x6a
 800dec2:	5a9b      	ldrh	r3, [r3, r2]
 800dec4:	2b00      	cmp	r3, #0
 800dec6:	d00b      	beq.n	800dee0 <tcp_free_acked_segments+0x98>
      LWIP_ASSERT("tcp_receive: valid queue length",
 800dec8:	68bb      	ldr	r3, [r7, #8]
 800deca:	2b00      	cmp	r3, #0
 800decc:	d108      	bne.n	800dee0 <tcp_free_acked_segments+0x98>
 800dece:	683b      	ldr	r3, [r7, #0]
 800ded0:	2b00      	cmp	r3, #0
 800ded2:	d105      	bne.n	800dee0 <tcp_free_acked_segments+0x98>
 800ded4:	4b1d      	ldr	r3, [pc, #116]	; (800df4c <tcp_free_acked_segments+0x104>)
 800ded6:	4a21      	ldr	r2, [pc, #132]	; (800df5c <tcp_free_acked_segments+0x114>)
 800ded8:	4921      	ldr	r1, [pc, #132]	; (800df60 <tcp_free_acked_segments+0x118>)
 800deda:	481e      	ldr	r0, [pc, #120]	; (800df54 <tcp_free_acked_segments+0x10c>)
 800dedc:	f7f4 fcfe 	bl	80028dc <app_debug_rtt_raw>
  while (seg_list != NULL &&
 800dee0:	68bb      	ldr	r3, [r7, #8]
 800dee2:	2b00      	cmp	r3, #0
 800dee4:	d02c      	beq.n	800df40 <tcp_free_acked_segments+0xf8>
         TCP_SEQ_LEQ(lwip_ntohl(seg_list->tcphdr->seqno) +
 800dee6:	68bb      	ldr	r3, [r7, #8]
 800dee8:	691b      	ldr	r3, [r3, #16]
 800deea:	791a      	ldrb	r2, [r3, #4]
 800deec:	7959      	ldrb	r1, [r3, #5]
 800deee:	0209      	lsls	r1, r1, #8
 800def0:	430a      	orrs	r2, r1
 800def2:	7999      	ldrb	r1, [r3, #6]
 800def4:	0409      	lsls	r1, r1, #16
 800def6:	430a      	orrs	r2, r1
 800def8:	79db      	ldrb	r3, [r3, #7]
 800defa:	061b      	lsls	r3, r3, #24
 800defc:	4313      	orrs	r3, r2
 800defe:	0018      	movs	r0, r3
 800df00:	f7f8 fe98 	bl	8006c34 <lwip_htonl>
 800df04:	0004      	movs	r4, r0
 800df06:	68bb      	ldr	r3, [r7, #8]
 800df08:	891b      	ldrh	r3, [r3, #8]
 800df0a:	001d      	movs	r5, r3
 800df0c:	68bb      	ldr	r3, [r7, #8]
 800df0e:	691b      	ldr	r3, [r3, #16]
 800df10:	7b1a      	ldrb	r2, [r3, #12]
 800df12:	7b5b      	ldrb	r3, [r3, #13]
 800df14:	021b      	lsls	r3, r3, #8
 800df16:	4313      	orrs	r3, r2
 800df18:	b29b      	uxth	r3, r3
 800df1a:	0018      	movs	r0, r3
 800df1c:	f7f8 fe74 	bl	8006c08 <lwip_htons>
 800df20:	0003      	movs	r3, r0
 800df22:	b2db      	uxtb	r3, r3
 800df24:	001a      	movs	r2, r3
 800df26:	2303      	movs	r3, #3
 800df28:	4013      	ands	r3, r2
 800df2a:	d001      	beq.n	800df30 <tcp_free_acked_segments+0xe8>
 800df2c:	2301      	movs	r3, #1
 800df2e:	e000      	b.n	800df32 <tcp_free_acked_segments+0xea>
 800df30:	2300      	movs	r3, #0
 800df32:	195b      	adds	r3, r3, r5
 800df34:	18e2      	adds	r2, r4, r3
 800df36:	4b0b      	ldr	r3, [pc, #44]	; (800df64 <tcp_free_acked_segments+0x11c>)
 800df38:	681b      	ldr	r3, [r3, #0]
 800df3a:	1ad3      	subs	r3, r2, r3
  while (seg_list != NULL &&
 800df3c:	2b00      	cmp	r3, #0
 800df3e:	dd8b      	ble.n	800de58 <tcp_free_acked_segments+0x10>
                  seg_list != NULL || dbg_other_seg_list != NULL);
    }
  }
  return seg_list;
 800df40:	68bb      	ldr	r3, [r7, #8]
}
 800df42:	0018      	movs	r0, r3
 800df44:	46bd      	mov	sp, r7
 800df46:	b006      	add	sp, #24
 800df48:	bdb0      	pop	{r4, r5, r7, pc}
 800df4a:	46c0      	nop			; (mov r8, r8)
 800df4c:	080201e0 	.word	0x080201e0
 800df50:	080204c0 	.word	0x080204c0
 800df54:	08020220 	.word	0x08020220
 800df58:	20001b58 	.word	0x20001b58
 800df5c:	00000462 	.word	0x00000462
 800df60:	080204e8 	.word	0x080204e8
 800df64:	20001b54 	.word	0x20001b54

0800df68 <tcp_receive>:
 *
 * Called from tcp_process().
 */
static void
tcp_receive(struct tcp_pcb *pcb)
{
 800df68:	b5b0      	push	{r4, r5, r7, lr}
 800df6a:	b094      	sub	sp, #80	; 0x50
 800df6c:	af00      	add	r7, sp, #0
 800df6e:	6078      	str	r0, [r7, #4]
  s16_t m;
  u32_t right_wnd_edge;
  int found_dupack = 0;
 800df70:	2300      	movs	r3, #0
 800df72:	64bb      	str	r3, [r7, #72]	; 0x48

  LWIP_ASSERT("tcp_receive: invalid pcb", pcb != NULL);
 800df74:	687b      	ldr	r3, [r7, #4]
 800df76:	2b00      	cmp	r3, #0
 800df78:	d105      	bne.n	800df86 <tcp_receive+0x1e>
 800df7a:	4bba      	ldr	r3, [pc, #744]	; (800e264 <tcp_receive+0x2fc>)
 800df7c:	4aba      	ldr	r2, [pc, #744]	; (800e268 <tcp_receive+0x300>)
 800df7e:	49bb      	ldr	r1, [pc, #748]	; (800e26c <tcp_receive+0x304>)
 800df80:	48bb      	ldr	r0, [pc, #748]	; (800e270 <tcp_receive+0x308>)
 800df82:	f7f4 fcab 	bl	80028dc <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 800df86:	687b      	ldr	r3, [r7, #4]
 800df88:	7e1b      	ldrb	r3, [r3, #24]
 800df8a:	2b03      	cmp	r3, #3
 800df8c:	d805      	bhi.n	800df9a <tcp_receive+0x32>
 800df8e:	4bb5      	ldr	r3, [pc, #724]	; (800e264 <tcp_receive+0x2fc>)
 800df90:	4ab8      	ldr	r2, [pc, #736]	; (800e274 <tcp_receive+0x30c>)
 800df92:	49b9      	ldr	r1, [pc, #740]	; (800e278 <tcp_receive+0x310>)
 800df94:	48b6      	ldr	r0, [pc, #728]	; (800e270 <tcp_receive+0x308>)
 800df96:	f7f4 fca1 	bl	80028dc <app_debug_rtt_raw>

  if (flags & TCP_ACK) {
 800df9a:	4bb8      	ldr	r3, [pc, #736]	; (800e27c <tcp_receive+0x314>)
 800df9c:	781b      	ldrb	r3, [r3, #0]
 800df9e:	001a      	movs	r2, r3
 800dfa0:	2310      	movs	r3, #16
 800dfa2:	4013      	ands	r3, r2
 800dfa4:	d100      	bne.n	800dfa8 <tcp_receive+0x40>
 800dfa6:	e294      	b.n	800e4d2 <tcp_receive+0x56a>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 800dfa8:	687b      	ldr	r3, [r7, #4]
 800dfaa:	2264      	movs	r2, #100	; 0x64
 800dfac:	5a9b      	ldrh	r3, [r3, r2]
 800dfae:	001a      	movs	r2, r3
 800dfb0:	687b      	ldr	r3, [r7, #4]
 800dfb2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800dfb4:	18d3      	adds	r3, r2, r3
 800dfb6:	633b      	str	r3, [r7, #48]	; 0x30

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 800dfb8:	687b      	ldr	r3, [r7, #4]
 800dfba:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800dfbc:	4bb0      	ldr	r3, [pc, #704]	; (800e280 <tcp_receive+0x318>)
 800dfbe:	681b      	ldr	r3, [r3, #0]
 800dfc0:	1ad3      	subs	r3, r2, r3
 800dfc2:	d41d      	bmi.n	800e000 <tcp_receive+0x98>
        (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 800dfc4:	687b      	ldr	r3, [r7, #4]
 800dfc6:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800dfc8:	4bad      	ldr	r3, [pc, #692]	; (800e280 <tcp_receive+0x318>)
 800dfca:	681b      	ldr	r3, [r3, #0]
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 800dfcc:	429a      	cmp	r2, r3
 800dfce:	d105      	bne.n	800dfdc <tcp_receive+0x74>
        (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 800dfd0:	687b      	ldr	r3, [r7, #4]
 800dfd2:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 800dfd4:	4bab      	ldr	r3, [pc, #684]	; (800e284 <tcp_receive+0x31c>)
 800dfd6:	681b      	ldr	r3, [r3, #0]
 800dfd8:	1ad3      	subs	r3, r2, r3
 800dfda:	d411      	bmi.n	800e000 <tcp_receive+0x98>
        (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
 800dfdc:	687b      	ldr	r3, [r7, #4]
 800dfde:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 800dfe0:	4ba8      	ldr	r3, [pc, #672]	; (800e284 <tcp_receive+0x31c>)
 800dfe2:	681b      	ldr	r3, [r3, #0]
        (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 800dfe4:	429a      	cmp	r2, r3
 800dfe6:	d12b      	bne.n	800e040 <tcp_receive+0xd8>
        (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
 800dfe8:	4ba7      	ldr	r3, [pc, #668]	; (800e288 <tcp_receive+0x320>)
 800dfea:	681b      	ldr	r3, [r3, #0]
 800dfec:	7b9a      	ldrb	r2, [r3, #14]
 800dfee:	7bdb      	ldrb	r3, [r3, #15]
 800dff0:	021b      	lsls	r3, r3, #8
 800dff2:	4313      	orrs	r3, r2
 800dff4:	b29a      	uxth	r2, r3
 800dff6:	687b      	ldr	r3, [r7, #4]
 800dff8:	2164      	movs	r1, #100	; 0x64
 800dffa:	5a5b      	ldrh	r3, [r3, r1]
 800dffc:	429a      	cmp	r2, r3
 800dffe:	d91f      	bls.n	800e040 <tcp_receive+0xd8>
      pcb->snd_wnd = SND_WND_SCALE(pcb, tcphdr->wnd);
 800e000:	4ba1      	ldr	r3, [pc, #644]	; (800e288 <tcp_receive+0x320>)
 800e002:	681b      	ldr	r3, [r3, #0]
 800e004:	7b9a      	ldrb	r2, [r3, #14]
 800e006:	7bdb      	ldrb	r3, [r3, #15]
 800e008:	021b      	lsls	r3, r3, #8
 800e00a:	4313      	orrs	r3, r2
 800e00c:	b299      	uxth	r1, r3
 800e00e:	687b      	ldr	r3, [r7, #4]
 800e010:	2264      	movs	r2, #100	; 0x64
 800e012:	5299      	strh	r1, [r3, r2]
      /* keep track of the biggest window announced by the remote host to calculate
         the maximum segment size */
      if (pcb->snd_wnd_max < pcb->snd_wnd) {
 800e014:	687b      	ldr	r3, [r7, #4]
 800e016:	2266      	movs	r2, #102	; 0x66
 800e018:	5a9a      	ldrh	r2, [r3, r2]
 800e01a:	687b      	ldr	r3, [r7, #4]
 800e01c:	2164      	movs	r1, #100	; 0x64
 800e01e:	5a5b      	ldrh	r3, [r3, r1]
 800e020:	429a      	cmp	r2, r3
 800e022:	d205      	bcs.n	800e030 <tcp_receive+0xc8>
        pcb->snd_wnd_max = pcb->snd_wnd;
 800e024:	687b      	ldr	r3, [r7, #4]
 800e026:	2264      	movs	r2, #100	; 0x64
 800e028:	5a99      	ldrh	r1, [r3, r2]
 800e02a:	687b      	ldr	r3, [r7, #4]
 800e02c:	2266      	movs	r2, #102	; 0x66
 800e02e:	5299      	strh	r1, [r3, r2]
      }
      pcb->snd_wl1 = seqno;
 800e030:	4b93      	ldr	r3, [pc, #588]	; (800e280 <tcp_receive+0x318>)
 800e032:	681a      	ldr	r2, [r3, #0]
 800e034:	687b      	ldr	r3, [r7, #4]
 800e036:	659a      	str	r2, [r3, #88]	; 0x58
      pcb->snd_wl2 = ackno;
 800e038:	4b92      	ldr	r3, [pc, #584]	; (800e284 <tcp_receive+0x31c>)
 800e03a:	681a      	ldr	r2, [r3, #0]
 800e03c:	687b      	ldr	r3, [r7, #4]
 800e03e:	65da      	str	r2, [r3, #92]	; 0x5c
     * If it only passes 1, should reset dupack counter
     *
     */

    /* Clause 1 */
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
 800e040:	4b90      	ldr	r3, [pc, #576]	; (800e284 <tcp_receive+0x31c>)
 800e042:	681a      	ldr	r2, [r3, #0]
 800e044:	687b      	ldr	r3, [r7, #4]
 800e046:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800e048:	1ad3      	subs	r3, r2, r3
 800e04a:	2b00      	cmp	r3, #0
 800e04c:	dc59      	bgt.n	800e102 <tcp_receive+0x19a>
      /* Clause 2 */
      if (tcplen == 0) {
 800e04e:	4b8f      	ldr	r3, [pc, #572]	; (800e28c <tcp_receive+0x324>)
 800e050:	881b      	ldrh	r3, [r3, #0]
 800e052:	2b00      	cmp	r3, #0
 800e054:	d14c      	bne.n	800e0f0 <tcp_receive+0x188>
        /* Clause 3 */
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge) {
 800e056:	687b      	ldr	r3, [r7, #4]
 800e058:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800e05a:	687a      	ldr	r2, [r7, #4]
 800e05c:	2164      	movs	r1, #100	; 0x64
 800e05e:	5a52      	ldrh	r2, [r2, r1]
 800e060:	189b      	adds	r3, r3, r2
 800e062:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800e064:	429a      	cmp	r2, r3
 800e066:	d143      	bne.n	800e0f0 <tcp_receive+0x188>
          /* Clause 4 */
          if (pcb->rtime >= 0) {
 800e068:	687b      	ldr	r3, [r7, #4]
 800e06a:	2234      	movs	r2, #52	; 0x34
 800e06c:	5e9b      	ldrsh	r3, [r3, r2]
 800e06e:	2b00      	cmp	r3, #0
 800e070:	db3e      	blt.n	800e0f0 <tcp_receive+0x188>
            /* Clause 5 */
            if (pcb->lastack == ackno) {
 800e072:	687b      	ldr	r3, [r7, #4]
 800e074:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800e076:	4b83      	ldr	r3, [pc, #524]	; (800e284 <tcp_receive+0x31c>)
 800e078:	681b      	ldr	r3, [r3, #0]
 800e07a:	429a      	cmp	r2, r3
 800e07c:	d138      	bne.n	800e0f0 <tcp_receive+0x188>
              found_dupack = 1;
 800e07e:	2301      	movs	r3, #1
 800e080:	64bb      	str	r3, [r7, #72]	; 0x48
              if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
 800e082:	687b      	ldr	r3, [r7, #4]
 800e084:	2247      	movs	r2, #71	; 0x47
 800e086:	5c9b      	ldrb	r3, [r3, r2]
 800e088:	2bff      	cmp	r3, #255	; 0xff
 800e08a:	d007      	beq.n	800e09c <tcp_receive+0x134>
                ++pcb->dupacks;
 800e08c:	687b      	ldr	r3, [r7, #4]
 800e08e:	2247      	movs	r2, #71	; 0x47
 800e090:	5c9b      	ldrb	r3, [r3, r2]
 800e092:	3301      	adds	r3, #1
 800e094:	b2d9      	uxtb	r1, r3
 800e096:	687b      	ldr	r3, [r7, #4]
 800e098:	2247      	movs	r2, #71	; 0x47
 800e09a:	5499      	strb	r1, [r3, r2]
              }
              if (pcb->dupacks > 3) {
 800e09c:	687b      	ldr	r3, [r7, #4]
 800e09e:	2247      	movs	r2, #71	; 0x47
 800e0a0:	5c9b      	ldrb	r3, [r3, r2]
 800e0a2:	2b03      	cmp	r3, #3
 800e0a4:	d91b      	bls.n	800e0de <tcp_receive+0x176>
                /* Inflate the congestion window */
                TCP_WND_INC(pcb->cwnd, pcb->mss);
 800e0a6:	687b      	ldr	r3, [r7, #4]
 800e0a8:	224c      	movs	r2, #76	; 0x4c
 800e0aa:	5a9a      	ldrh	r2, [r3, r2]
 800e0ac:	687b      	ldr	r3, [r7, #4]
 800e0ae:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800e0b0:	18d3      	adds	r3, r2, r3
 800e0b2:	b29a      	uxth	r2, r3
 800e0b4:	687b      	ldr	r3, [r7, #4]
 800e0b6:	214c      	movs	r1, #76	; 0x4c
 800e0b8:	5a5b      	ldrh	r3, [r3, r1]
 800e0ba:	429a      	cmp	r2, r3
 800e0bc:	d30a      	bcc.n	800e0d4 <tcp_receive+0x16c>
 800e0be:	687b      	ldr	r3, [r7, #4]
 800e0c0:	224c      	movs	r2, #76	; 0x4c
 800e0c2:	5a9a      	ldrh	r2, [r3, r2]
 800e0c4:	687b      	ldr	r3, [r7, #4]
 800e0c6:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800e0c8:	18d3      	adds	r3, r2, r3
 800e0ca:	b299      	uxth	r1, r3
 800e0cc:	687b      	ldr	r3, [r7, #4]
 800e0ce:	224c      	movs	r2, #76	; 0x4c
 800e0d0:	5299      	strh	r1, [r3, r2]
 800e0d2:	e004      	b.n	800e0de <tcp_receive+0x176>
 800e0d4:	687b      	ldr	r3, [r7, #4]
 800e0d6:	224c      	movs	r2, #76	; 0x4c
 800e0d8:	2101      	movs	r1, #1
 800e0da:	4249      	negs	r1, r1
 800e0dc:	5299      	strh	r1, [r3, r2]
              }
              if (pcb->dupacks >= 3) {
 800e0de:	687b      	ldr	r3, [r7, #4]
 800e0e0:	2247      	movs	r2, #71	; 0x47
 800e0e2:	5c9b      	ldrb	r3, [r3, r2]
 800e0e4:	2b02      	cmp	r3, #2
 800e0e6:	d903      	bls.n	800e0f0 <tcp_receive+0x188>
                /* Do fast retransmit (checked via TF_INFR, not via dupacks count) */
                tcp_rexmit_fast(pcb);
 800e0e8:	687b      	ldr	r3, [r7, #4]
 800e0ea:	0018      	movs	r0, r3
 800e0ec:	f003 fa7e 	bl	80115ec <tcp_rexmit_fast>
          }
        }
      }
      /* If Clause (1) or more is true, but not a duplicate ack, reset
       * count of consecutive duplicate acks */
      if (!found_dupack) {
 800e0f0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800e0f2:	2b00      	cmp	r3, #0
 800e0f4:	d000      	beq.n	800e0f8 <tcp_receive+0x190>
 800e0f6:	e188      	b.n	800e40a <tcp_receive+0x4a2>
        pcb->dupacks = 0;
 800e0f8:	687b      	ldr	r3, [r7, #4]
 800e0fa:	2247      	movs	r2, #71	; 0x47
 800e0fc:	2100      	movs	r1, #0
 800e0fe:	5499      	strb	r1, [r3, r2]
 800e100:	e183      	b.n	800e40a <tcp_receive+0x4a2>
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 800e102:	4b60      	ldr	r3, [pc, #384]	; (800e284 <tcp_receive+0x31c>)
 800e104:	681a      	ldr	r2, [r3, #0]
 800e106:	687b      	ldr	r3, [r7, #4]
 800e108:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800e10a:	1ad3      	subs	r3, r2, r3
 800e10c:	3b01      	subs	r3, #1
 800e10e:	2b00      	cmp	r3, #0
 800e110:	da00      	bge.n	800e114 <tcp_receive+0x1ac>
 800e112:	e174      	b.n	800e3fe <tcp_receive+0x496>
 800e114:	4b5b      	ldr	r3, [pc, #364]	; (800e284 <tcp_receive+0x31c>)
 800e116:	681a      	ldr	r2, [r3, #0]
 800e118:	687b      	ldr	r3, [r7, #4]
 800e11a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800e11c:	1ad3      	subs	r3, r2, r3
 800e11e:	2b00      	cmp	r3, #0
 800e120:	dd00      	ble.n	800e124 <tcp_receive+0x1bc>
 800e122:	e16c      	b.n	800e3fe <tcp_receive+0x496>
      tcpwnd_size_t acked;

      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
 800e124:	687b      	ldr	r3, [r7, #4]
 800e126:	8bdb      	ldrh	r3, [r3, #30]
 800e128:	001a      	movs	r2, r3
 800e12a:	2304      	movs	r3, #4
 800e12c:	4013      	ands	r3, r2
 800e12e:	d010      	beq.n	800e152 <tcp_receive+0x1ea>
        tcp_clear_flags(pcb, TF_INFR);
 800e130:	687b      	ldr	r3, [r7, #4]
 800e132:	8bdb      	ldrh	r3, [r3, #30]
 800e134:	2204      	movs	r2, #4
 800e136:	4393      	bics	r3, r2
 800e138:	b29a      	uxth	r2, r3
 800e13a:	687b      	ldr	r3, [r7, #4]
 800e13c:	83da      	strh	r2, [r3, #30]
        pcb->cwnd = pcb->ssthresh;
 800e13e:	687b      	ldr	r3, [r7, #4]
 800e140:	224e      	movs	r2, #78	; 0x4e
 800e142:	5a99      	ldrh	r1, [r3, r2]
 800e144:	687b      	ldr	r3, [r7, #4]
 800e146:	224c      	movs	r2, #76	; 0x4c
 800e148:	5299      	strh	r1, [r3, r2]
        pcb->bytes_acked = 0;
 800e14a:	687b      	ldr	r3, [r7, #4]
 800e14c:	226e      	movs	r2, #110	; 0x6e
 800e14e:	2100      	movs	r1, #0
 800e150:	5299      	strh	r1, [r3, r2]
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
 800e152:	687b      	ldr	r3, [r7, #4]
 800e154:	2246      	movs	r2, #70	; 0x46
 800e156:	2100      	movs	r1, #0
 800e158:	5499      	strb	r1, [r3, r2]

      /* Reset the retransmission time-out. */
      pcb->rto = (s16_t)((pcb->sa >> 3) + pcb->sv);
 800e15a:	687b      	ldr	r3, [r7, #4]
 800e15c:	2240      	movs	r2, #64	; 0x40
 800e15e:	5e9b      	ldrsh	r3, [r3, r2]
 800e160:	10db      	asrs	r3, r3, #3
 800e162:	b21b      	sxth	r3, r3
 800e164:	b29a      	uxth	r2, r3
 800e166:	687b      	ldr	r3, [r7, #4]
 800e168:	2142      	movs	r1, #66	; 0x42
 800e16a:	5e5b      	ldrsh	r3, [r3, r1]
 800e16c:	b29b      	uxth	r3, r3
 800e16e:	18d3      	adds	r3, r2, r3
 800e170:	b29b      	uxth	r3, r3
 800e172:	b219      	sxth	r1, r3
 800e174:	687b      	ldr	r3, [r7, #4]
 800e176:	2244      	movs	r2, #68	; 0x44
 800e178:	5299      	strh	r1, [r3, r2]

      /* Record how much data this ACK acks */
      acked = (tcpwnd_size_t)(ackno - pcb->lastack);
 800e17a:	4b42      	ldr	r3, [pc, #264]	; (800e284 <tcp_receive+0x31c>)
 800e17c:	681b      	ldr	r3, [r3, #0]
 800e17e:	b299      	uxth	r1, r3
 800e180:	687b      	ldr	r3, [r7, #4]
 800e182:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800e184:	b29a      	uxth	r2, r3
 800e186:	232e      	movs	r3, #46	; 0x2e
 800e188:	18fb      	adds	r3, r7, r3
 800e18a:	1a8a      	subs	r2, r1, r2
 800e18c:	801a      	strh	r2, [r3, #0]

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
 800e18e:	687b      	ldr	r3, [r7, #4]
 800e190:	2247      	movs	r2, #71	; 0x47
 800e192:	2100      	movs	r1, #0
 800e194:	5499      	strb	r1, [r3, r2]
      pcb->lastack = ackno;
 800e196:	4b3b      	ldr	r3, [pc, #236]	; (800e284 <tcp_receive+0x31c>)
 800e198:	681a      	ldr	r2, [r3, #0]
 800e19a:	687b      	ldr	r3, [r7, #4]
 800e19c:	649a      	str	r2, [r3, #72]	; 0x48

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
 800e19e:	687b      	ldr	r3, [r7, #4]
 800e1a0:	7e1b      	ldrb	r3, [r3, #24]
 800e1a2:	2b03      	cmp	r3, #3
 800e1a4:	d800      	bhi.n	800e1a8 <tcp_receive+0x240>
 800e1a6:	e0a7      	b.n	800e2f8 <tcp_receive+0x390>
        if (pcb->cwnd < pcb->ssthresh) {
 800e1a8:	687b      	ldr	r3, [r7, #4]
 800e1aa:	224c      	movs	r2, #76	; 0x4c
 800e1ac:	5a9a      	ldrh	r2, [r3, r2]
 800e1ae:	687b      	ldr	r3, [r7, #4]
 800e1b0:	214e      	movs	r1, #78	; 0x4e
 800e1b2:	5a5b      	ldrh	r3, [r3, r1]
 800e1b4:	429a      	cmp	r2, r3
 800e1b6:	d23d      	bcs.n	800e234 <tcp_receive+0x2cc>
          tcpwnd_size_t increase;
          /* limit to 1 SMSS segment during period following RTO */
          u8_t num_seg = (pcb->flags & TF_RTO) ? 1 : 2;
 800e1b8:	687b      	ldr	r3, [r7, #4]
 800e1ba:	8bdb      	ldrh	r3, [r3, #30]
 800e1bc:	001a      	movs	r2, r3
 800e1be:	2380      	movs	r3, #128	; 0x80
 800e1c0:	011b      	lsls	r3, r3, #4
 800e1c2:	4013      	ands	r3, r2
 800e1c4:	d001      	beq.n	800e1ca <tcp_receive+0x262>
 800e1c6:	2201      	movs	r2, #1
 800e1c8:	e000      	b.n	800e1cc <tcp_receive+0x264>
 800e1ca:	2202      	movs	r2, #2
 800e1cc:	212d      	movs	r1, #45	; 0x2d
 800e1ce:	187b      	adds	r3, r7, r1
 800e1d0:	701a      	strb	r2, [r3, #0]
          /* RFC 3465, section 2.2 Slow Start */
          increase = LWIP_MIN(acked, (tcpwnd_size_t)(num_seg * pcb->mss));
 800e1d2:	187b      	adds	r3, r7, r1
 800e1d4:	781b      	ldrb	r3, [r3, #0]
 800e1d6:	b29b      	uxth	r3, r3
 800e1d8:	687a      	ldr	r2, [r7, #4]
 800e1da:	8ed2      	ldrh	r2, [r2, #54]	; 0x36
 800e1dc:	4353      	muls	r3, r2
 800e1de:	b299      	uxth	r1, r3
 800e1e0:	232a      	movs	r3, #42	; 0x2a
 800e1e2:	18fa      	adds	r2, r7, r3
 800e1e4:	232e      	movs	r3, #46	; 0x2e
 800e1e6:	18fb      	adds	r3, r7, r3
 800e1e8:	1c0c      	adds	r4, r1, #0
 800e1ea:	881b      	ldrh	r3, [r3, #0]
 800e1ec:	b298      	uxth	r0, r3
 800e1ee:	b2a1      	uxth	r1, r4
 800e1f0:	4288      	cmp	r0, r1
 800e1f2:	d900      	bls.n	800e1f6 <tcp_receive+0x28e>
 800e1f4:	1c23      	adds	r3, r4, #0
 800e1f6:	8013      	strh	r3, [r2, #0]
          TCP_WND_INC(pcb->cwnd, increase);
 800e1f8:	687b      	ldr	r3, [r7, #4]
 800e1fa:	224c      	movs	r2, #76	; 0x4c
 800e1fc:	5a9a      	ldrh	r2, [r3, r2]
 800e1fe:	202a      	movs	r0, #42	; 0x2a
 800e200:	183b      	adds	r3, r7, r0
 800e202:	881b      	ldrh	r3, [r3, #0]
 800e204:	18d3      	adds	r3, r2, r3
 800e206:	b29a      	uxth	r2, r3
 800e208:	687b      	ldr	r3, [r7, #4]
 800e20a:	214c      	movs	r1, #76	; 0x4c
 800e20c:	5a5b      	ldrh	r3, [r3, r1]
 800e20e:	429a      	cmp	r2, r3
 800e210:	d30a      	bcc.n	800e228 <tcp_receive+0x2c0>
 800e212:	687b      	ldr	r3, [r7, #4]
 800e214:	224c      	movs	r2, #76	; 0x4c
 800e216:	5a9a      	ldrh	r2, [r3, r2]
 800e218:	183b      	adds	r3, r7, r0
 800e21a:	881b      	ldrh	r3, [r3, #0]
 800e21c:	18d3      	adds	r3, r2, r3
 800e21e:	b299      	uxth	r1, r3
 800e220:	687b      	ldr	r3, [r7, #4]
 800e222:	224c      	movs	r2, #76	; 0x4c
 800e224:	5299      	strh	r1, [r3, r2]
 800e226:	e067      	b.n	800e2f8 <tcp_receive+0x390>
 800e228:	687b      	ldr	r3, [r7, #4]
 800e22a:	224c      	movs	r2, #76	; 0x4c
 800e22c:	2101      	movs	r1, #1
 800e22e:	4249      	negs	r1, r1
 800e230:	5299      	strh	r1, [r3, r2]
 800e232:	e061      	b.n	800e2f8 <tcp_receive+0x390>
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"TCPWNDSIZE_F"\n", pcb->cwnd));
        } else {
          /* RFC 3465, section 2.1 Congestion Avoidance */
          TCP_WND_INC(pcb->bytes_acked, acked);
 800e234:	687b      	ldr	r3, [r7, #4]
 800e236:	226e      	movs	r2, #110	; 0x6e
 800e238:	5a9a      	ldrh	r2, [r3, r2]
 800e23a:	202e      	movs	r0, #46	; 0x2e
 800e23c:	183b      	adds	r3, r7, r0
 800e23e:	881b      	ldrh	r3, [r3, #0]
 800e240:	18d3      	adds	r3, r2, r3
 800e242:	b29a      	uxth	r2, r3
 800e244:	687b      	ldr	r3, [r7, #4]
 800e246:	216e      	movs	r1, #110	; 0x6e
 800e248:	5a5b      	ldrh	r3, [r3, r1]
 800e24a:	429a      	cmp	r2, r3
 800e24c:	d320      	bcc.n	800e290 <tcp_receive+0x328>
 800e24e:	687b      	ldr	r3, [r7, #4]
 800e250:	226e      	movs	r2, #110	; 0x6e
 800e252:	5a9a      	ldrh	r2, [r3, r2]
 800e254:	183b      	adds	r3, r7, r0
 800e256:	881b      	ldrh	r3, [r3, #0]
 800e258:	18d3      	adds	r3, r2, r3
 800e25a:	b299      	uxth	r1, r3
 800e25c:	687b      	ldr	r3, [r7, #4]
 800e25e:	226e      	movs	r2, #110	; 0x6e
 800e260:	5299      	strh	r1, [r3, r2]
 800e262:	e01a      	b.n	800e29a <tcp_receive+0x332>
 800e264:	080201e0 	.word	0x080201e0
 800e268:	0000047c 	.word	0x0000047c
 800e26c:	08020508 	.word	0x08020508
 800e270:	08020220 	.word	0x08020220
 800e274:	0000047d 	.word	0x0000047d
 800e278:	08020524 	.word	0x08020524
 800e27c:	20001b5c 	.word	0x20001b5c
 800e280:	20001b50 	.word	0x20001b50
 800e284:	20001b54 	.word	0x20001b54
 800e288:	20001b40 	.word	0x20001b40
 800e28c:	20001b5a 	.word	0x20001b5a
 800e290:	687b      	ldr	r3, [r7, #4]
 800e292:	226e      	movs	r2, #110	; 0x6e
 800e294:	2101      	movs	r1, #1
 800e296:	4249      	negs	r1, r1
 800e298:	5299      	strh	r1, [r3, r2]
          if (pcb->bytes_acked >= pcb->cwnd) {
 800e29a:	687b      	ldr	r3, [r7, #4]
 800e29c:	226e      	movs	r2, #110	; 0x6e
 800e29e:	5a9a      	ldrh	r2, [r3, r2]
 800e2a0:	687b      	ldr	r3, [r7, #4]
 800e2a2:	214c      	movs	r1, #76	; 0x4c
 800e2a4:	5a5b      	ldrh	r3, [r3, r1]
 800e2a6:	429a      	cmp	r2, r3
 800e2a8:	d326      	bcc.n	800e2f8 <tcp_receive+0x390>
            pcb->bytes_acked = (tcpwnd_size_t)(pcb->bytes_acked - pcb->cwnd);
 800e2aa:	687b      	ldr	r3, [r7, #4]
 800e2ac:	226e      	movs	r2, #110	; 0x6e
 800e2ae:	5a9a      	ldrh	r2, [r3, r2]
 800e2b0:	687b      	ldr	r3, [r7, #4]
 800e2b2:	214c      	movs	r1, #76	; 0x4c
 800e2b4:	5a5b      	ldrh	r3, [r3, r1]
 800e2b6:	1ad3      	subs	r3, r2, r3
 800e2b8:	b299      	uxth	r1, r3
 800e2ba:	687b      	ldr	r3, [r7, #4]
 800e2bc:	226e      	movs	r2, #110	; 0x6e
 800e2be:	5299      	strh	r1, [r3, r2]
            TCP_WND_INC(pcb->cwnd, pcb->mss);
 800e2c0:	687b      	ldr	r3, [r7, #4]
 800e2c2:	224c      	movs	r2, #76	; 0x4c
 800e2c4:	5a9a      	ldrh	r2, [r3, r2]
 800e2c6:	687b      	ldr	r3, [r7, #4]
 800e2c8:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800e2ca:	18d3      	adds	r3, r2, r3
 800e2cc:	b29a      	uxth	r2, r3
 800e2ce:	687b      	ldr	r3, [r7, #4]
 800e2d0:	214c      	movs	r1, #76	; 0x4c
 800e2d2:	5a5b      	ldrh	r3, [r3, r1]
 800e2d4:	429a      	cmp	r2, r3
 800e2d6:	d30a      	bcc.n	800e2ee <tcp_receive+0x386>
 800e2d8:	687b      	ldr	r3, [r7, #4]
 800e2da:	224c      	movs	r2, #76	; 0x4c
 800e2dc:	5a9a      	ldrh	r2, [r3, r2]
 800e2de:	687b      	ldr	r3, [r7, #4]
 800e2e0:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800e2e2:	18d3      	adds	r3, r2, r3
 800e2e4:	b299      	uxth	r1, r3
 800e2e6:	687b      	ldr	r3, [r7, #4]
 800e2e8:	224c      	movs	r2, #76	; 0x4c
 800e2ea:	5299      	strh	r1, [r3, r2]
 800e2ec:	e004      	b.n	800e2f8 <tcp_receive+0x390>
 800e2ee:	687b      	ldr	r3, [r7, #4]
 800e2f0:	224c      	movs	r2, #76	; 0x4c
 800e2f2:	2101      	movs	r1, #1
 800e2f4:	4249      	negs	r1, r1
 800e2f6:	5299      	strh	r1, [r3, r2]
                                    pcb->unacked != NULL ?
                                    lwip_ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked) : 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowledges them. */
      pcb->unacked = tcp_free_acked_segments(pcb, pcb->unacked, "unacked", pcb->unsent);
 800e2f8:	687b      	ldr	r3, [r7, #4]
 800e2fa:	6f59      	ldr	r1, [r3, #116]	; 0x74
 800e2fc:	687b      	ldr	r3, [r7, #4]
 800e2fe:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800e300:	4acf      	ldr	r2, [pc, #828]	; (800e640 <tcp_receive+0x6d8>)
 800e302:	6878      	ldr	r0, [r7, #4]
 800e304:	f7ff fda0 	bl	800de48 <tcp_free_acked_segments>
 800e308:	0002      	movs	r2, r0
 800e30a:	687b      	ldr	r3, [r7, #4]
 800e30c:	675a      	str	r2, [r3, #116]	; 0x74
         on the list are acknowledged by the ACK. This may seem
         strange since an "unsent" segment shouldn't be acked. The
         rationale is that lwIP puts all outstanding segments on the
         ->unsent list after a retransmission, so these segments may
         in fact have been sent once. */
      pcb->unsent = tcp_free_acked_segments(pcb, pcb->unsent, "unsent", pcb->unacked);
 800e30e:	687b      	ldr	r3, [r7, #4]
 800e310:	6f19      	ldr	r1, [r3, #112]	; 0x70
 800e312:	687b      	ldr	r3, [r7, #4]
 800e314:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800e316:	4acb      	ldr	r2, [pc, #812]	; (800e644 <tcp_receive+0x6dc>)
 800e318:	6878      	ldr	r0, [r7, #4]
 800e31a:	f7ff fd95 	bl	800de48 <tcp_free_acked_segments>
 800e31e:	0002      	movs	r2, r0
 800e320:	687b      	ldr	r3, [r7, #4]
 800e322:	671a      	str	r2, [r3, #112]	; 0x70

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if (pcb->unacked == NULL) {
 800e324:	687b      	ldr	r3, [r7, #4]
 800e326:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800e328:	2b00      	cmp	r3, #0
 800e32a:	d104      	bne.n	800e336 <tcp_receive+0x3ce>
        pcb->rtime = -1;
 800e32c:	687b      	ldr	r3, [r7, #4]
 800e32e:	2201      	movs	r2, #1
 800e330:	4252      	negs	r2, r2
 800e332:	869a      	strh	r2, [r3, #52]	; 0x34
 800e334:	e002      	b.n	800e33c <tcp_receive+0x3d4>
      } else {
        pcb->rtime = 0;
 800e336:	687b      	ldr	r3, [r7, #4]
 800e338:	2200      	movs	r2, #0
 800e33a:	869a      	strh	r2, [r3, #52]	; 0x34
      }

      pcb->polltmr = 0;
 800e33c:	687b      	ldr	r3, [r7, #4]
 800e33e:	2220      	movs	r2, #32
 800e340:	2100      	movs	r1, #0
 800e342:	5499      	strb	r1, [r3, r2]

#if TCP_OVERSIZE
      if (pcb->unsent == NULL) {
 800e344:	687b      	ldr	r3, [r7, #4]
 800e346:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800e348:	2b00      	cmp	r3, #0
 800e34a:	d103      	bne.n	800e354 <tcp_receive+0x3ec>
        pcb->unsent_oversize = 0;
 800e34c:	687b      	ldr	r3, [r7, #4]
 800e34e:	226c      	movs	r2, #108	; 0x6c
 800e350:	2100      	movs	r1, #0
 800e352:	5299      	strh	r1, [r3, r2]
        /* Inform neighbor reachability of forward progress. */
        nd6_reachability_hint(ip6_current_src_addr());
      }
#endif /* LWIP_IPV6 && LWIP_ND6_TCP_REACHABILITY_HINTS*/

      pcb->snd_buf = (tcpwnd_size_t)(pcb->snd_buf + recv_acked);
 800e354:	687b      	ldr	r3, [r7, #4]
 800e356:	2268      	movs	r2, #104	; 0x68
 800e358:	5a9a      	ldrh	r2, [r3, r2]
 800e35a:	4bbb      	ldr	r3, [pc, #748]	; (800e648 <tcp_receive+0x6e0>)
 800e35c:	881b      	ldrh	r3, [r3, #0]
 800e35e:	18d3      	adds	r3, r2, r3
 800e360:	b299      	uxth	r1, r3
 800e362:	687b      	ldr	r3, [r7, #4]
 800e364:	2268      	movs	r2, #104	; 0x68
 800e366:	5299      	strh	r1, [r3, r2]
      /* check if this ACK ends our retransmission of in-flight data */
      if (pcb->flags & TF_RTO) {
 800e368:	687b      	ldr	r3, [r7, #4]
 800e36a:	8bdb      	ldrh	r3, [r3, #30]
 800e36c:	001a      	movs	r2, r3
 800e36e:	2380      	movs	r3, #128	; 0x80
 800e370:	011b      	lsls	r3, r3, #4
 800e372:	4013      	ands	r3, r2
 800e374:	d048      	beq.n	800e408 <tcp_receive+0x4a0>
        /* RTO is done if
            1) both queues are empty or
            2) unacked is empty and unsent head contains data not part of RTO or
            3) unacked head contains data not part of RTO */
        if (pcb->unacked == NULL) {
 800e376:	687b      	ldr	r3, [r7, #4]
 800e378:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800e37a:	2b00      	cmp	r3, #0
 800e37c:	d121      	bne.n	800e3c2 <tcp_receive+0x45a>
          if ((pcb->unsent == NULL) ||
 800e37e:	687b      	ldr	r3, [r7, #4]
 800e380:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800e382:	2b00      	cmp	r3, #0
 800e384:	d015      	beq.n	800e3b2 <tcp_receive+0x44a>
              (TCP_SEQ_LEQ(pcb->rto_end, lwip_ntohl(pcb->unsent->tcphdr->seqno)))) {
 800e386:	687b      	ldr	r3, [r7, #4]
 800e388:	6d1c      	ldr	r4, [r3, #80]	; 0x50
 800e38a:	687b      	ldr	r3, [r7, #4]
 800e38c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800e38e:	691b      	ldr	r3, [r3, #16]
 800e390:	791a      	ldrb	r2, [r3, #4]
 800e392:	7959      	ldrb	r1, [r3, #5]
 800e394:	0209      	lsls	r1, r1, #8
 800e396:	430a      	orrs	r2, r1
 800e398:	7999      	ldrb	r1, [r3, #6]
 800e39a:	0409      	lsls	r1, r1, #16
 800e39c:	430a      	orrs	r2, r1
 800e39e:	79db      	ldrb	r3, [r3, #7]
 800e3a0:	061b      	lsls	r3, r3, #24
 800e3a2:	4313      	orrs	r3, r2
 800e3a4:	0018      	movs	r0, r3
 800e3a6:	f7f8 fc45 	bl	8006c34 <lwip_htonl>
 800e3aa:	0003      	movs	r3, r0
 800e3ac:	1ae3      	subs	r3, r4, r3
          if ((pcb->unsent == NULL) ||
 800e3ae:	2b00      	cmp	r3, #0
 800e3b0:	dc2a      	bgt.n	800e408 <tcp_receive+0x4a0>
            tcp_clear_flags(pcb, TF_RTO);
 800e3b2:	687b      	ldr	r3, [r7, #4]
 800e3b4:	8bdb      	ldrh	r3, [r3, #30]
 800e3b6:	4aa5      	ldr	r2, [pc, #660]	; (800e64c <tcp_receive+0x6e4>)
 800e3b8:	4013      	ands	r3, r2
 800e3ba:	b29a      	uxth	r2, r3
 800e3bc:	687b      	ldr	r3, [r7, #4]
 800e3be:	83da      	strh	r2, [r3, #30]
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 800e3c0:	e022      	b.n	800e408 <tcp_receive+0x4a0>
          }
        } else if (TCP_SEQ_LEQ(pcb->rto_end, lwip_ntohl(pcb->unacked->tcphdr->seqno))) {
 800e3c2:	687b      	ldr	r3, [r7, #4]
 800e3c4:	6d1c      	ldr	r4, [r3, #80]	; 0x50
 800e3c6:	687b      	ldr	r3, [r7, #4]
 800e3c8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800e3ca:	691b      	ldr	r3, [r3, #16]
 800e3cc:	791a      	ldrb	r2, [r3, #4]
 800e3ce:	7959      	ldrb	r1, [r3, #5]
 800e3d0:	0209      	lsls	r1, r1, #8
 800e3d2:	430a      	orrs	r2, r1
 800e3d4:	7999      	ldrb	r1, [r3, #6]
 800e3d6:	0409      	lsls	r1, r1, #16
 800e3d8:	430a      	orrs	r2, r1
 800e3da:	79db      	ldrb	r3, [r3, #7]
 800e3dc:	061b      	lsls	r3, r3, #24
 800e3de:	4313      	orrs	r3, r2
 800e3e0:	0018      	movs	r0, r3
 800e3e2:	f7f8 fc27 	bl	8006c34 <lwip_htonl>
 800e3e6:	0003      	movs	r3, r0
 800e3e8:	1ae3      	subs	r3, r4, r3
 800e3ea:	2b00      	cmp	r3, #0
 800e3ec:	dc0c      	bgt.n	800e408 <tcp_receive+0x4a0>
          tcp_clear_flags(pcb, TF_RTO);
 800e3ee:	687b      	ldr	r3, [r7, #4]
 800e3f0:	8bdb      	ldrh	r3, [r3, #30]
 800e3f2:	4a96      	ldr	r2, [pc, #600]	; (800e64c <tcp_receive+0x6e4>)
 800e3f4:	4013      	ands	r3, r2
 800e3f6:	b29a      	uxth	r2, r3
 800e3f8:	687b      	ldr	r3, [r7, #4]
 800e3fa:	83da      	strh	r2, [r3, #30]
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 800e3fc:	e004      	b.n	800e408 <tcp_receive+0x4a0>
        }
      }
      /* End of ACK for new data processing. */
    } else {
      /* Out of sequence ACK, didn't really ack anything */
      tcp_send_empty_ack(pcb);
 800e3fe:	687b      	ldr	r3, [r7, #4]
 800e400:	0018      	movs	r0, r3
 800e402:	f003 fbf9 	bl	8011bf8 <tcp_send_empty_ack>
 800e406:	e000      	b.n	800e40a <tcp_receive+0x4a2>
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 800e408:	46c0      	nop			; (mov r8, r8)
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
 800e40a:	687b      	ldr	r3, [r7, #4]
 800e40c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800e40e:	2b00      	cmp	r3, #0
 800e410:	d05f      	beq.n	800e4d2 <tcp_receive+0x56a>
 800e412:	687b      	ldr	r3, [r7, #4]
 800e414:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800e416:	4b8e      	ldr	r3, [pc, #568]	; (800e650 <tcp_receive+0x6e8>)
 800e418:	681b      	ldr	r3, [r3, #0]
 800e41a:	1ad3      	subs	r3, r2, r3
 800e41c:	d559      	bpl.n	800e4d2 <tcp_receive+0x56a>
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
 800e41e:	4b8d      	ldr	r3, [pc, #564]	; (800e654 <tcp_receive+0x6ec>)
 800e420:	681b      	ldr	r3, [r3, #0]
 800e422:	b29a      	uxth	r2, r3
 800e424:	687b      	ldr	r3, [r7, #4]
 800e426:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800e428:	b29b      	uxth	r3, r3
 800e42a:	1ad3      	subs	r3, r2, r3
 800e42c:	b29a      	uxth	r2, r3
 800e42e:	204e      	movs	r0, #78	; 0x4e
 800e430:	183b      	adds	r3, r7, r0
 800e432:	801a      	strh	r2, [r3, #0]

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, (u16_t)(m * TCP_SLOW_INTERVAL)));

      /* This is taken directly from VJs original code in his paper */
      m = (s16_t)(m - (pcb->sa >> 3));
 800e434:	183b      	adds	r3, r7, r0
 800e436:	881a      	ldrh	r2, [r3, #0]
 800e438:	687b      	ldr	r3, [r7, #4]
 800e43a:	2140      	movs	r1, #64	; 0x40
 800e43c:	5e5b      	ldrsh	r3, [r3, r1]
 800e43e:	10db      	asrs	r3, r3, #3
 800e440:	b21b      	sxth	r3, r3
 800e442:	b29b      	uxth	r3, r3
 800e444:	1ad3      	subs	r3, r2, r3
 800e446:	b29a      	uxth	r2, r3
 800e448:	183b      	adds	r3, r7, r0
 800e44a:	801a      	strh	r2, [r3, #0]
      pcb->sa = (s16_t)(pcb->sa + m);
 800e44c:	687b      	ldr	r3, [r7, #4]
 800e44e:	2240      	movs	r2, #64	; 0x40
 800e450:	5e9b      	ldrsh	r3, [r3, r2]
 800e452:	b29a      	uxth	r2, r3
 800e454:	183b      	adds	r3, r7, r0
 800e456:	881b      	ldrh	r3, [r3, #0]
 800e458:	18d3      	adds	r3, r2, r3
 800e45a:	b29b      	uxth	r3, r3
 800e45c:	b219      	sxth	r1, r3
 800e45e:	687b      	ldr	r3, [r7, #4]
 800e460:	2240      	movs	r2, #64	; 0x40
 800e462:	5299      	strh	r1, [r3, r2]
      if (m < 0) {
 800e464:	183b      	adds	r3, r7, r0
 800e466:	2200      	movs	r2, #0
 800e468:	5e9b      	ldrsh	r3, [r3, r2]
 800e46a:	2b00      	cmp	r3, #0
 800e46c:	da05      	bge.n	800e47a <tcp_receive+0x512>
        m = (s16_t) - m;
 800e46e:	183b      	adds	r3, r7, r0
 800e470:	881b      	ldrh	r3, [r3, #0]
 800e472:	425b      	negs	r3, r3
 800e474:	b29a      	uxth	r2, r3
 800e476:	183b      	adds	r3, r7, r0
 800e478:	801a      	strh	r2, [r3, #0]
      }
      m = (s16_t)(m - (pcb->sv >> 2));
 800e47a:	204e      	movs	r0, #78	; 0x4e
 800e47c:	183b      	adds	r3, r7, r0
 800e47e:	881a      	ldrh	r2, [r3, #0]
 800e480:	687b      	ldr	r3, [r7, #4]
 800e482:	2142      	movs	r1, #66	; 0x42
 800e484:	5e5b      	ldrsh	r3, [r3, r1]
 800e486:	109b      	asrs	r3, r3, #2
 800e488:	b21b      	sxth	r3, r3
 800e48a:	b29b      	uxth	r3, r3
 800e48c:	1ad3      	subs	r3, r2, r3
 800e48e:	b29a      	uxth	r2, r3
 800e490:	183b      	adds	r3, r7, r0
 800e492:	801a      	strh	r2, [r3, #0]
      pcb->sv = (s16_t)(pcb->sv + m);
 800e494:	687b      	ldr	r3, [r7, #4]
 800e496:	2242      	movs	r2, #66	; 0x42
 800e498:	5e9b      	ldrsh	r3, [r3, r2]
 800e49a:	b29a      	uxth	r2, r3
 800e49c:	183b      	adds	r3, r7, r0
 800e49e:	881b      	ldrh	r3, [r3, #0]
 800e4a0:	18d3      	adds	r3, r2, r3
 800e4a2:	b29b      	uxth	r3, r3
 800e4a4:	b219      	sxth	r1, r3
 800e4a6:	687b      	ldr	r3, [r7, #4]
 800e4a8:	2242      	movs	r2, #66	; 0x42
 800e4aa:	5299      	strh	r1, [r3, r2]
      pcb->rto = (s16_t)((pcb->sa >> 3) + pcb->sv);
 800e4ac:	687b      	ldr	r3, [r7, #4]
 800e4ae:	2240      	movs	r2, #64	; 0x40
 800e4b0:	5e9b      	ldrsh	r3, [r3, r2]
 800e4b2:	10db      	asrs	r3, r3, #3
 800e4b4:	b21b      	sxth	r3, r3
 800e4b6:	b29a      	uxth	r2, r3
 800e4b8:	687b      	ldr	r3, [r7, #4]
 800e4ba:	2142      	movs	r1, #66	; 0x42
 800e4bc:	5e5b      	ldrsh	r3, [r3, r1]
 800e4be:	b29b      	uxth	r3, r3
 800e4c0:	18d3      	adds	r3, r2, r3
 800e4c2:	b29b      	uxth	r3, r3
 800e4c4:	b219      	sxth	r1, r3
 800e4c6:	687b      	ldr	r3, [r7, #4]
 800e4c8:	2244      	movs	r2, #68	; 0x44
 800e4ca:	5299      	strh	r1, [r3, r2]

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, (u16_t)(pcb->rto * TCP_SLOW_INTERVAL)));

      pcb->rttest = 0;
 800e4cc:	687b      	ldr	r3, [r7, #4]
 800e4ce:	2200      	movs	r2, #0
 800e4d0:	639a      	str	r2, [r3, #56]	; 0x38

  /* If the incoming segment contains data, we must process it
     further unless the pcb already received a FIN.
     (RFC 793, chapter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
     LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
  if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
 800e4d2:	4b61      	ldr	r3, [pc, #388]	; (800e658 <tcp_receive+0x6f0>)
 800e4d4:	881b      	ldrh	r3, [r3, #0]
 800e4d6:	2b00      	cmp	r3, #0
 800e4d8:	d101      	bne.n	800e4de <tcp_receive+0x576>
 800e4da:	f000 fe3b 	bl	800f154 <tcp_receive+0x11ec>
 800e4de:	687b      	ldr	r3, [r7, #4]
 800e4e0:	7e1b      	ldrb	r3, [r3, #24]
 800e4e2:	2b06      	cmp	r3, #6
 800e4e4:	d901      	bls.n	800e4ea <tcp_receive+0x582>
 800e4e6:	f000 fe35 	bl	800f154 <tcp_receive+0x11ec>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
 800e4ea:	687b      	ldr	r3, [r7, #4]
 800e4ec:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800e4ee:	4b5b      	ldr	r3, [pc, #364]	; (800e65c <tcp_receive+0x6f4>)
 800e4f0:	681b      	ldr	r3, [r3, #0]
 800e4f2:	1ad3      	subs	r3, r2, r3
 800e4f4:	3b01      	subs	r3, #1
 800e4f6:	2b00      	cmp	r3, #0
 800e4f8:	da00      	bge.n	800e4fc <tcp_receive+0x594>
 800e4fa:	e0c3      	b.n	800e684 <tcp_receive+0x71c>
 800e4fc:	687b      	ldr	r3, [r7, #4]
 800e4fe:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800e500:	4b55      	ldr	r3, [pc, #340]	; (800e658 <tcp_receive+0x6f0>)
 800e502:	881b      	ldrh	r3, [r3, #0]
 800e504:	0019      	movs	r1, r3
 800e506:	4b55      	ldr	r3, [pc, #340]	; (800e65c <tcp_receive+0x6f4>)
 800e508:	681b      	ldr	r3, [r3, #0]
 800e50a:	18cb      	adds	r3, r1, r3
 800e50c:	1ad3      	subs	r3, r2, r3
 800e50e:	3301      	adds	r3, #1
 800e510:	2b00      	cmp	r3, #0
 800e512:	dd00      	ble.n	800e516 <tcp_receive+0x5ae>
 800e514:	e0b6      	b.n	800e684 <tcp_receive+0x71c>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      struct pbuf *p = inseg.p;
 800e516:	4b52      	ldr	r3, [pc, #328]	; (800e660 <tcp_receive+0x6f8>)
 800e518:	685b      	ldr	r3, [r3, #4]
 800e51a:	647b      	str	r3, [r7, #68]	; 0x44
      u32_t off32 = pcb->rcv_nxt - seqno;
 800e51c:	687b      	ldr	r3, [r7, #4]
 800e51e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800e520:	4b4e      	ldr	r3, [pc, #312]	; (800e65c <tcp_receive+0x6f4>)
 800e522:	681b      	ldr	r3, [r3, #0]
 800e524:	1ad3      	subs	r3, r2, r3
 800e526:	627b      	str	r3, [r7, #36]	; 0x24
      u16_t new_tot_len, off;
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
 800e528:	4b4d      	ldr	r3, [pc, #308]	; (800e660 <tcp_receive+0x6f8>)
 800e52a:	685b      	ldr	r3, [r3, #4]
 800e52c:	2b00      	cmp	r3, #0
 800e52e:	d105      	bne.n	800e53c <tcp_receive+0x5d4>
 800e530:	4b4c      	ldr	r3, [pc, #304]	; (800e664 <tcp_receive+0x6fc>)
 800e532:	4a4d      	ldr	r2, [pc, #308]	; (800e668 <tcp_receive+0x700>)
 800e534:	494d      	ldr	r1, [pc, #308]	; (800e66c <tcp_receive+0x704>)
 800e536:	484e      	ldr	r0, [pc, #312]	; (800e670 <tcp_receive+0x708>)
 800e538:	f7f4 f9d0 	bl	80028dc <app_debug_rtt_raw>
      LWIP_ASSERT("insane offset!", (off32 < 0xffff));
 800e53c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e53e:	4a4d      	ldr	r2, [pc, #308]	; (800e674 <tcp_receive+0x70c>)
 800e540:	4293      	cmp	r3, r2
 800e542:	d905      	bls.n	800e550 <tcp_receive+0x5e8>
 800e544:	4b47      	ldr	r3, [pc, #284]	; (800e664 <tcp_receive+0x6fc>)
 800e546:	4a4c      	ldr	r2, [pc, #304]	; (800e678 <tcp_receive+0x710>)
 800e548:	494c      	ldr	r1, [pc, #304]	; (800e67c <tcp_receive+0x714>)
 800e54a:	4849      	ldr	r0, [pc, #292]	; (800e670 <tcp_receive+0x708>)
 800e54c:	f7f4 f9c6 	bl	80028dc <app_debug_rtt_raw>
      off = (u16_t)off32;
 800e550:	2142      	movs	r1, #66	; 0x42
 800e552:	187b      	adds	r3, r7, r1
 800e554:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800e556:	801a      	strh	r2, [r3, #0]
      LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
 800e558:	4b41      	ldr	r3, [pc, #260]	; (800e660 <tcp_receive+0x6f8>)
 800e55a:	685b      	ldr	r3, [r3, #4]
 800e55c:	891b      	ldrh	r3, [r3, #8]
 800e55e:	187a      	adds	r2, r7, r1
 800e560:	8812      	ldrh	r2, [r2, #0]
 800e562:	429a      	cmp	r2, r3
 800e564:	d906      	bls.n	800e574 <tcp_receive+0x60c>
 800e566:	4b3f      	ldr	r3, [pc, #252]	; (800e664 <tcp_receive+0x6fc>)
 800e568:	22b3      	movs	r2, #179	; 0xb3
 800e56a:	00d2      	lsls	r2, r2, #3
 800e56c:	4944      	ldr	r1, [pc, #272]	; (800e680 <tcp_receive+0x718>)
 800e56e:	4840      	ldr	r0, [pc, #256]	; (800e670 <tcp_receive+0x708>)
 800e570:	f7f4 f9b4 	bl	80028dc <app_debug_rtt_raw>
      inseg.len -= off;
 800e574:	4b3a      	ldr	r3, [pc, #232]	; (800e660 <tcp_receive+0x6f8>)
 800e576:	891a      	ldrh	r2, [r3, #8]
 800e578:	2042      	movs	r0, #66	; 0x42
 800e57a:	183b      	adds	r3, r7, r0
 800e57c:	881b      	ldrh	r3, [r3, #0]
 800e57e:	1ad3      	subs	r3, r2, r3
 800e580:	b29a      	uxth	r2, r3
 800e582:	4b37      	ldr	r3, [pc, #220]	; (800e660 <tcp_receive+0x6f8>)
 800e584:	811a      	strh	r2, [r3, #8]
      new_tot_len = (u16_t)(inseg.p->tot_len - off);
 800e586:	4b36      	ldr	r3, [pc, #216]	; (800e660 <tcp_receive+0x6f8>)
 800e588:	685b      	ldr	r3, [r3, #4]
 800e58a:	8919      	ldrh	r1, [r3, #8]
 800e58c:	2322      	movs	r3, #34	; 0x22
 800e58e:	18fb      	adds	r3, r7, r3
 800e590:	183a      	adds	r2, r7, r0
 800e592:	8812      	ldrh	r2, [r2, #0]
 800e594:	1a8a      	subs	r2, r1, r2
 800e596:	801a      	strh	r2, [r3, #0]
      while (p->len < off) {
 800e598:	e012      	b.n	800e5c0 <tcp_receive+0x658>
        off -= p->len;
 800e59a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e59c:	895a      	ldrh	r2, [r3, #10]
 800e59e:	2142      	movs	r1, #66	; 0x42
 800e5a0:	187b      	adds	r3, r7, r1
 800e5a2:	1879      	adds	r1, r7, r1
 800e5a4:	8809      	ldrh	r1, [r1, #0]
 800e5a6:	1a8a      	subs	r2, r1, r2
 800e5a8:	801a      	strh	r2, [r3, #0]
        /* all pbufs up to and including this one have len==0, so tot_len is equal */
        p->tot_len = new_tot_len;
 800e5aa:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e5ac:	2222      	movs	r2, #34	; 0x22
 800e5ae:	18ba      	adds	r2, r7, r2
 800e5b0:	8812      	ldrh	r2, [r2, #0]
 800e5b2:	811a      	strh	r2, [r3, #8]
        p->len = 0;
 800e5b4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e5b6:	2200      	movs	r2, #0
 800e5b8:	815a      	strh	r2, [r3, #10]
        p = p->next;
 800e5ba:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e5bc:	681b      	ldr	r3, [r3, #0]
 800e5be:	647b      	str	r3, [r7, #68]	; 0x44
      while (p->len < off) {
 800e5c0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e5c2:	895b      	ldrh	r3, [r3, #10]
 800e5c4:	2142      	movs	r1, #66	; 0x42
 800e5c6:	187a      	adds	r2, r7, r1
 800e5c8:	8812      	ldrh	r2, [r2, #0]
 800e5ca:	429a      	cmp	r2, r3
 800e5cc:	d8e5      	bhi.n	800e59a <tcp_receive+0x632>
      }
      /* cannot fail... */
      pbuf_remove_header(p, off);
 800e5ce:	187b      	adds	r3, r7, r1
 800e5d0:	881a      	ldrh	r2, [r3, #0]
 800e5d2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e5d4:	0011      	movs	r1, r2
 800e5d6:	0018      	movs	r0, r3
 800e5d8:	f7fb fa22 	bl	8009a20 <pbuf_remove_header>
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
 800e5dc:	687b      	ldr	r3, [r7, #4]
 800e5de:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800e5e0:	4b1e      	ldr	r3, [pc, #120]	; (800e65c <tcp_receive+0x6f4>)
 800e5e2:	601a      	str	r2, [r3, #0]
 800e5e4:	4b1e      	ldr	r3, [pc, #120]	; (800e660 <tcp_receive+0x6f8>)
 800e5e6:	691b      	ldr	r3, [r3, #16]
 800e5e8:	4a1c      	ldr	r2, [pc, #112]	; (800e65c <tcp_receive+0x6f4>)
 800e5ea:	6812      	ldr	r2, [r2, #0]
 800e5ec:	21ff      	movs	r1, #255	; 0xff
 800e5ee:	4011      	ands	r1, r2
 800e5f0:	000c      	movs	r4, r1
 800e5f2:	7919      	ldrb	r1, [r3, #4]
 800e5f4:	2000      	movs	r0, #0
 800e5f6:	4001      	ands	r1, r0
 800e5f8:	1c08      	adds	r0, r1, #0
 800e5fa:	1c21      	adds	r1, r4, #0
 800e5fc:	4301      	orrs	r1, r0
 800e5fe:	7119      	strb	r1, [r3, #4]
 800e600:	0a11      	lsrs	r1, r2, #8
 800e602:	20ff      	movs	r0, #255	; 0xff
 800e604:	4001      	ands	r1, r0
 800e606:	000c      	movs	r4, r1
 800e608:	7959      	ldrb	r1, [r3, #5]
 800e60a:	2000      	movs	r0, #0
 800e60c:	4001      	ands	r1, r0
 800e60e:	1c08      	adds	r0, r1, #0
 800e610:	1c21      	adds	r1, r4, #0
 800e612:	4301      	orrs	r1, r0
 800e614:	7159      	strb	r1, [r3, #5]
 800e616:	0c11      	lsrs	r1, r2, #16
 800e618:	20ff      	movs	r0, #255	; 0xff
 800e61a:	4001      	ands	r1, r0
 800e61c:	000c      	movs	r4, r1
 800e61e:	7999      	ldrb	r1, [r3, #6]
 800e620:	2000      	movs	r0, #0
 800e622:	4001      	ands	r1, r0
 800e624:	1c08      	adds	r0, r1, #0
 800e626:	1c21      	adds	r1, r4, #0
 800e628:	4301      	orrs	r1, r0
 800e62a:	7199      	strb	r1, [r3, #6]
 800e62c:	0e10      	lsrs	r0, r2, #24
 800e62e:	79da      	ldrb	r2, [r3, #7]
 800e630:	2100      	movs	r1, #0
 800e632:	400a      	ands	r2, r1
 800e634:	1c11      	adds	r1, r2, #0
 800e636:	1c02      	adds	r2, r0, #0
 800e638:	430a      	orrs	r2, r1
 800e63a:	71da      	strb	r2, [r3, #7]
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
 800e63c:	e02f      	b.n	800e69e <tcp_receive+0x736>
 800e63e:	46c0      	nop			; (mov r8, r8)
 800e640:	08020540 	.word	0x08020540
 800e644:	08020548 	.word	0x08020548
 800e648:	20001b58 	.word	0x20001b58
 800e64c:	fffff7ff 	.word	0xfffff7ff
 800e650:	20001b54 	.word	0x20001b54
 800e654:	20002ed8 	.word	0x20002ed8
 800e658:	20001b5a 	.word	0x20001b5a
 800e65c:	20001b50 	.word	0x20001b50
 800e660:	20001b2c 	.word	0x20001b2c
 800e664:	080201e0 	.word	0x080201e0
 800e668:	00000595 	.word	0x00000595
 800e66c:	08020550 	.word	0x08020550
 800e670:	08020220 	.word	0x08020220
 800e674:	0000fffe 	.word	0x0000fffe
 800e678:	00000596 	.word	0x00000596
 800e67c:	08020560 	.word	0x08020560
 800e680:	08020570 	.word	0x08020570
    } else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
 800e684:	4bb0      	ldr	r3, [pc, #704]	; (800e948 <tcp_receive+0x9e0>)
 800e686:	681a      	ldr	r2, [r3, #0]
 800e688:	687b      	ldr	r3, [r7, #4]
 800e68a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800e68c:	1ad3      	subs	r3, r2, r3
 800e68e:	d506      	bpl.n	800e69e <tcp_receive+0x736>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
 800e690:	687b      	ldr	r3, [r7, #4]
 800e692:	8bdb      	ldrh	r3, [r3, #30]
 800e694:	2202      	movs	r2, #2
 800e696:	4313      	orrs	r3, r2
 800e698:	b29a      	uxth	r2, r3
 800e69a:	687b      	ldr	r3, [r7, #4]
 800e69c:	83da      	strh	r2, [r3, #30]
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
 800e69e:	4baa      	ldr	r3, [pc, #680]	; (800e948 <tcp_receive+0x9e0>)
 800e6a0:	681a      	ldr	r2, [r3, #0]
 800e6a2:	687b      	ldr	r3, [r7, #4]
 800e6a4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800e6a6:	1ad3      	subs	r3, r2, r3
 800e6a8:	d501      	bpl.n	800e6ae <tcp_receive+0x746>
 800e6aa:	f000 fd4d 	bl	800f148 <tcp_receive+0x11e0>
 800e6ae:	4ba6      	ldr	r3, [pc, #664]	; (800e948 <tcp_receive+0x9e0>)
 800e6b0:	681a      	ldr	r2, [r3, #0]
 800e6b2:	687b      	ldr	r3, [r7, #4]
 800e6b4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800e6b6:	6879      	ldr	r1, [r7, #4]
 800e6b8:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
 800e6ba:	185b      	adds	r3, r3, r1
 800e6bc:	1ad3      	subs	r3, r2, r3
 800e6be:	3301      	adds	r3, #1
 800e6c0:	2b00      	cmp	r3, #0
 800e6c2:	dd01      	ble.n	800e6c8 <tcp_receive+0x760>
 800e6c4:	f000 fd40 	bl	800f148 <tcp_receive+0x11e0>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
      if (pcb->rcv_nxt == seqno) {
 800e6c8:	687b      	ldr	r3, [r7, #4]
 800e6ca:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800e6cc:	4b9e      	ldr	r3, [pc, #632]	; (800e948 <tcp_receive+0x9e0>)
 800e6ce:	681b      	ldr	r3, [r3, #0]
 800e6d0:	429a      	cmp	r2, r3
 800e6d2:	d000      	beq.n	800e6d6 <tcp_receive+0x76e>
 800e6d4:	e337      	b.n	800ed46 <tcp_receive+0xdde>
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
        tcplen = TCP_TCPLEN(&inseg);
 800e6d6:	4b9d      	ldr	r3, [pc, #628]	; (800e94c <tcp_receive+0x9e4>)
 800e6d8:	891c      	ldrh	r4, [r3, #8]
 800e6da:	4b9c      	ldr	r3, [pc, #624]	; (800e94c <tcp_receive+0x9e4>)
 800e6dc:	691b      	ldr	r3, [r3, #16]
 800e6de:	7b1a      	ldrb	r2, [r3, #12]
 800e6e0:	7b5b      	ldrb	r3, [r3, #13]
 800e6e2:	021b      	lsls	r3, r3, #8
 800e6e4:	4313      	orrs	r3, r2
 800e6e6:	b29b      	uxth	r3, r3
 800e6e8:	0018      	movs	r0, r3
 800e6ea:	f7f8 fa8d 	bl	8006c08 <lwip_htons>
 800e6ee:	0003      	movs	r3, r0
 800e6f0:	b2db      	uxtb	r3, r3
 800e6f2:	001a      	movs	r2, r3
 800e6f4:	2303      	movs	r3, #3
 800e6f6:	4013      	ands	r3, r2
 800e6f8:	d001      	beq.n	800e6fe <tcp_receive+0x796>
 800e6fa:	2301      	movs	r3, #1
 800e6fc:	e000      	b.n	800e700 <tcp_receive+0x798>
 800e6fe:	2300      	movs	r3, #0
 800e700:	191b      	adds	r3, r3, r4
 800e702:	b29a      	uxth	r2, r3
 800e704:	4b92      	ldr	r3, [pc, #584]	; (800e950 <tcp_receive+0x9e8>)
 800e706:	801a      	strh	r2, [r3, #0]

        if (tcplen > pcb->rcv_wnd) {
 800e708:	687b      	ldr	r3, [r7, #4]
 800e70a:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800e70c:	4b90      	ldr	r3, [pc, #576]	; (800e950 <tcp_receive+0x9e8>)
 800e70e:	881b      	ldrh	r3, [r3, #0]
 800e710:	429a      	cmp	r2, r3
 800e712:	d300      	bcc.n	800e716 <tcp_receive+0x7ae>
 800e714:	e095      	b.n	800e842 <tcp_receive+0x8da>
          LWIP_DEBUGF(TCP_INPUT_DEBUG,
                      ("tcp_receive: other end overran receive window"
                       "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                       seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 800e716:	4b8d      	ldr	r3, [pc, #564]	; (800e94c <tcp_receive+0x9e4>)
 800e718:	691b      	ldr	r3, [r3, #16]
 800e71a:	7b1a      	ldrb	r2, [r3, #12]
 800e71c:	7b5b      	ldrb	r3, [r3, #13]
 800e71e:	021b      	lsls	r3, r3, #8
 800e720:	4313      	orrs	r3, r2
 800e722:	b29b      	uxth	r3, r3
 800e724:	0018      	movs	r0, r3
 800e726:	f7f8 fa6f 	bl	8006c08 <lwip_htons>
 800e72a:	0003      	movs	r3, r0
 800e72c:	b2db      	uxtb	r3, r3
 800e72e:	001a      	movs	r2, r3
 800e730:	2301      	movs	r3, #1
 800e732:	4013      	ands	r3, r2
 800e734:	d037      	beq.n	800e7a6 <tcp_receive+0x83e>
            /* Must remove the FIN from the header as we're trimming
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) & ~(unsigned int)TCP_FIN);
 800e736:	4b85      	ldr	r3, [pc, #532]	; (800e94c <tcp_receive+0x9e4>)
 800e738:	691b      	ldr	r3, [r3, #16]
 800e73a:	7b1a      	ldrb	r2, [r3, #12]
 800e73c:	7b5b      	ldrb	r3, [r3, #13]
 800e73e:	021b      	lsls	r3, r3, #8
 800e740:	4313      	orrs	r3, r2
 800e742:	b29b      	uxth	r3, r3
 800e744:	b21b      	sxth	r3, r3
 800e746:	4a83      	ldr	r2, [pc, #524]	; (800e954 <tcp_receive+0x9ec>)
 800e748:	4013      	ands	r3, r2
 800e74a:	b21c      	sxth	r4, r3
 800e74c:	4b7f      	ldr	r3, [pc, #508]	; (800e94c <tcp_receive+0x9e4>)
 800e74e:	691b      	ldr	r3, [r3, #16]
 800e750:	7b1a      	ldrb	r2, [r3, #12]
 800e752:	7b5b      	ldrb	r3, [r3, #13]
 800e754:	021b      	lsls	r3, r3, #8
 800e756:	4313      	orrs	r3, r2
 800e758:	b29b      	uxth	r3, r3
 800e75a:	0018      	movs	r0, r3
 800e75c:	f7f8 fa54 	bl	8006c08 <lwip_htons>
 800e760:	0003      	movs	r3, r0
 800e762:	b2db      	uxtb	r3, r3
 800e764:	b29b      	uxth	r3, r3
 800e766:	223e      	movs	r2, #62	; 0x3e
 800e768:	4013      	ands	r3, r2
 800e76a:	b29b      	uxth	r3, r3
 800e76c:	0018      	movs	r0, r3
 800e76e:	f7f8 fa4b 	bl	8006c08 <lwip_htons>
 800e772:	0003      	movs	r3, r0
 800e774:	b21b      	sxth	r3, r3
 800e776:	4323      	orrs	r3, r4
 800e778:	b21a      	sxth	r2, r3
 800e77a:	4b74      	ldr	r3, [pc, #464]	; (800e94c <tcp_receive+0x9e4>)
 800e77c:	691b      	ldr	r3, [r3, #16]
 800e77e:	b292      	uxth	r2, r2
 800e780:	21ff      	movs	r1, #255	; 0xff
 800e782:	4011      	ands	r1, r2
 800e784:	000c      	movs	r4, r1
 800e786:	7b19      	ldrb	r1, [r3, #12]
 800e788:	2000      	movs	r0, #0
 800e78a:	4001      	ands	r1, r0
 800e78c:	1c08      	adds	r0, r1, #0
 800e78e:	1c21      	adds	r1, r4, #0
 800e790:	4301      	orrs	r1, r0
 800e792:	7319      	strb	r1, [r3, #12]
 800e794:	0a12      	lsrs	r2, r2, #8
 800e796:	b290      	uxth	r0, r2
 800e798:	7b5a      	ldrb	r2, [r3, #13]
 800e79a:	2100      	movs	r1, #0
 800e79c:	400a      	ands	r2, r1
 800e79e:	1c11      	adds	r1, r2, #0
 800e7a0:	1c02      	adds	r2, r0, #0
 800e7a2:	430a      	orrs	r2, r1
 800e7a4:	735a      	strb	r2, [r3, #13]
          }
          /* Adjust length of segment to fit in the window. */
          TCPWND_CHECK16(pcb->rcv_wnd);
          inseg.len = (u16_t)pcb->rcv_wnd;
 800e7a6:	687b      	ldr	r3, [r7, #4]
 800e7a8:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800e7aa:	4b68      	ldr	r3, [pc, #416]	; (800e94c <tcp_receive+0x9e4>)
 800e7ac:	811a      	strh	r2, [r3, #8]
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 800e7ae:	4b67      	ldr	r3, [pc, #412]	; (800e94c <tcp_receive+0x9e4>)
 800e7b0:	691b      	ldr	r3, [r3, #16]
 800e7b2:	7b1a      	ldrb	r2, [r3, #12]
 800e7b4:	7b5b      	ldrb	r3, [r3, #13]
 800e7b6:	021b      	lsls	r3, r3, #8
 800e7b8:	4313      	orrs	r3, r2
 800e7ba:	b29b      	uxth	r3, r3
 800e7bc:	0018      	movs	r0, r3
 800e7be:	f7f8 fa23 	bl	8006c08 <lwip_htons>
 800e7c2:	0003      	movs	r3, r0
 800e7c4:	b2db      	uxtb	r3, r3
 800e7c6:	001a      	movs	r2, r3
 800e7c8:	2302      	movs	r3, #2
 800e7ca:	4013      	ands	r3, r2
 800e7cc:	d005      	beq.n	800e7da <tcp_receive+0x872>
            inseg.len -= 1;
 800e7ce:	4b5f      	ldr	r3, [pc, #380]	; (800e94c <tcp_receive+0x9e4>)
 800e7d0:	891b      	ldrh	r3, [r3, #8]
 800e7d2:	3b01      	subs	r3, #1
 800e7d4:	b29a      	uxth	r2, r3
 800e7d6:	4b5d      	ldr	r3, [pc, #372]	; (800e94c <tcp_receive+0x9e4>)
 800e7d8:	811a      	strh	r2, [r3, #8]
          }
          pbuf_realloc(inseg.p, inseg.len);
 800e7da:	4b5c      	ldr	r3, [pc, #368]	; (800e94c <tcp_receive+0x9e4>)
 800e7dc:	685a      	ldr	r2, [r3, #4]
 800e7de:	4b5b      	ldr	r3, [pc, #364]	; (800e94c <tcp_receive+0x9e4>)
 800e7e0:	891b      	ldrh	r3, [r3, #8]
 800e7e2:	0019      	movs	r1, r3
 800e7e4:	0010      	movs	r0, r2
 800e7e6:	f7fa fff9 	bl	80097dc <pbuf_realloc>
          tcplen = TCP_TCPLEN(&inseg);
 800e7ea:	4b58      	ldr	r3, [pc, #352]	; (800e94c <tcp_receive+0x9e4>)
 800e7ec:	891c      	ldrh	r4, [r3, #8]
 800e7ee:	4b57      	ldr	r3, [pc, #348]	; (800e94c <tcp_receive+0x9e4>)
 800e7f0:	691b      	ldr	r3, [r3, #16]
 800e7f2:	7b1a      	ldrb	r2, [r3, #12]
 800e7f4:	7b5b      	ldrb	r3, [r3, #13]
 800e7f6:	021b      	lsls	r3, r3, #8
 800e7f8:	4313      	orrs	r3, r2
 800e7fa:	b29b      	uxth	r3, r3
 800e7fc:	0018      	movs	r0, r3
 800e7fe:	f7f8 fa03 	bl	8006c08 <lwip_htons>
 800e802:	0003      	movs	r3, r0
 800e804:	b2db      	uxtb	r3, r3
 800e806:	001a      	movs	r2, r3
 800e808:	2303      	movs	r3, #3
 800e80a:	4013      	ands	r3, r2
 800e80c:	d001      	beq.n	800e812 <tcp_receive+0x8aa>
 800e80e:	2301      	movs	r3, #1
 800e810:	e000      	b.n	800e814 <tcp_receive+0x8ac>
 800e812:	2300      	movs	r3, #0
 800e814:	191b      	adds	r3, r3, r4
 800e816:	b29a      	uxth	r2, r3
 800e818:	4b4d      	ldr	r3, [pc, #308]	; (800e950 <tcp_receive+0x9e8>)
 800e81a:	801a      	strh	r2, [r3, #0]
          LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 800e81c:	4b4c      	ldr	r3, [pc, #304]	; (800e950 <tcp_receive+0x9e8>)
 800e81e:	881b      	ldrh	r3, [r3, #0]
 800e820:	001a      	movs	r2, r3
 800e822:	4b49      	ldr	r3, [pc, #292]	; (800e948 <tcp_receive+0x9e0>)
 800e824:	681b      	ldr	r3, [r3, #0]
 800e826:	18d2      	adds	r2, r2, r3
 800e828:	687b      	ldr	r3, [r7, #4]
 800e82a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800e82c:	6879      	ldr	r1, [r7, #4]
 800e82e:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
 800e830:	185b      	adds	r3, r3, r1
 800e832:	429a      	cmp	r2, r3
 800e834:	d005      	beq.n	800e842 <tcp_receive+0x8da>
 800e836:	4b48      	ldr	r3, [pc, #288]	; (800e958 <tcp_receive+0x9f0>)
 800e838:	4a48      	ldr	r2, [pc, #288]	; (800e95c <tcp_receive+0x9f4>)
 800e83a:	4949      	ldr	r1, [pc, #292]	; (800e960 <tcp_receive+0x9f8>)
 800e83c:	4849      	ldr	r0, [pc, #292]	; (800e964 <tcp_receive+0x9fc>)
 800e83e:	f7f4 f84d 	bl	80028dc <app_debug_rtt_raw>
        }
#if TCP_QUEUE_OOSEQ
        /* Received in-sequence data, adjust ooseq data if:
           - FIN has been received or
           - inseq overlaps with ooseq */
        if (pcb->ooseq != NULL) {
 800e842:	687b      	ldr	r3, [r7, #4]
 800e844:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800e846:	2b00      	cmp	r3, #0
 800e848:	d100      	bne.n	800e84c <tcp_receive+0x8e4>
 800e84a:	e138      	b.n	800eabe <tcp_receive+0xb56>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 800e84c:	4b3f      	ldr	r3, [pc, #252]	; (800e94c <tcp_receive+0x9e4>)
 800e84e:	691b      	ldr	r3, [r3, #16]
 800e850:	7b1a      	ldrb	r2, [r3, #12]
 800e852:	7b5b      	ldrb	r3, [r3, #13]
 800e854:	021b      	lsls	r3, r3, #8
 800e856:	4313      	orrs	r3, r2
 800e858:	b29b      	uxth	r3, r3
 800e85a:	0018      	movs	r0, r3
 800e85c:	f7f8 f9d4 	bl	8006c08 <lwip_htons>
 800e860:	0003      	movs	r3, r0
 800e862:	b2db      	uxtb	r3, r3
 800e864:	001a      	movs	r2, r3
 800e866:	2301      	movs	r3, #1
 800e868:	4013      	ands	r3, r2
 800e86a:	d011      	beq.n	800e890 <tcp_receive+0x928>
            LWIP_DEBUGF(TCP_INPUT_DEBUG,
                        ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
            /* Received in-order FIN means anything that was received
             * out of order must now have been received in-order, so
             * bin the ooseq queue */
            while (pcb->ooseq != NULL) {
 800e86c:	e00b      	b.n	800e886 <tcp_receive+0x91e>
              struct tcp_seg *old_ooseq = pcb->ooseq;
 800e86e:	687b      	ldr	r3, [r7, #4]
 800e870:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800e872:	60fb      	str	r3, [r7, #12]
              pcb->ooseq = pcb->ooseq->next;
 800e874:	687b      	ldr	r3, [r7, #4]
 800e876:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800e878:	681a      	ldr	r2, [r3, #0]
 800e87a:	687b      	ldr	r3, [r7, #4]
 800e87c:	679a      	str	r2, [r3, #120]	; 0x78
              tcp_seg_free(old_ooseq);
 800e87e:	68fb      	ldr	r3, [r7, #12]
 800e880:	0018      	movs	r0, r3
 800e882:	f7fd fa11 	bl	800bca8 <tcp_seg_free>
            while (pcb->ooseq != NULL) {
 800e886:	687b      	ldr	r3, [r7, #4]
 800e888:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800e88a:	2b00      	cmp	r3, #0
 800e88c:	d1ef      	bne.n	800e86e <tcp_receive+0x906>
 800e88e:	e116      	b.n	800eabe <tcp_receive+0xb56>
            }
          } else {
            struct tcp_seg *next = pcb->ooseq;
 800e890:	687b      	ldr	r3, [r7, #4]
 800e892:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800e894:	63fb      	str	r3, [r7, #60]	; 0x3c
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
 800e896:	e075      	b.n	800e984 <tcp_receive+0xa1c>
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              struct tcp_seg *tmp;
              /* inseg cannot have FIN here (already processed above) */
              if ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0 &&
 800e898:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e89a:	691b      	ldr	r3, [r3, #16]
 800e89c:	7b1a      	ldrb	r2, [r3, #12]
 800e89e:	7b5b      	ldrb	r3, [r3, #13]
 800e8a0:	021b      	lsls	r3, r3, #8
 800e8a2:	4313      	orrs	r3, r2
 800e8a4:	b29b      	uxth	r3, r3
 800e8a6:	0018      	movs	r0, r3
 800e8a8:	f7f8 f9ae 	bl	8006c08 <lwip_htons>
 800e8ac:	0003      	movs	r3, r0
 800e8ae:	b2db      	uxtb	r3, r3
 800e8b0:	001a      	movs	r2, r3
 800e8b2:	2301      	movs	r3, #1
 800e8b4:	4013      	ands	r3, r2
 800e8b6:	d05c      	beq.n	800e972 <tcp_receive+0xa0a>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
 800e8b8:	4b24      	ldr	r3, [pc, #144]	; (800e94c <tcp_receive+0x9e4>)
 800e8ba:	691b      	ldr	r3, [r3, #16]
 800e8bc:	7b1a      	ldrb	r2, [r3, #12]
 800e8be:	7b5b      	ldrb	r3, [r3, #13]
 800e8c0:	021b      	lsls	r3, r3, #8
 800e8c2:	4313      	orrs	r3, r2
 800e8c4:	b29b      	uxth	r3, r3
 800e8c6:	0018      	movs	r0, r3
 800e8c8:	f7f8 f99e 	bl	8006c08 <lwip_htons>
 800e8cc:	0003      	movs	r3, r0
 800e8ce:	b2db      	uxtb	r3, r3
 800e8d0:	001a      	movs	r2, r3
 800e8d2:	2302      	movs	r3, #2
 800e8d4:	4013      	ands	r3, r2
              if ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0 &&
 800e8d6:	d14c      	bne.n	800e972 <tcp_receive+0xa0a>
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
 800e8d8:	4b1c      	ldr	r3, [pc, #112]	; (800e94c <tcp_receive+0x9e4>)
 800e8da:	691b      	ldr	r3, [r3, #16]
 800e8dc:	7b1a      	ldrb	r2, [r3, #12]
 800e8de:	7b5b      	ldrb	r3, [r3, #13]
 800e8e0:	021b      	lsls	r3, r3, #8
 800e8e2:	4313      	orrs	r3, r2
 800e8e4:	b29c      	uxth	r4, r3
 800e8e6:	2001      	movs	r0, #1
 800e8e8:	f7f8 f98e 	bl	8006c08 <lwip_htons>
 800e8ec:	0003      	movs	r3, r0
 800e8ee:	001a      	movs	r2, r3
 800e8f0:	4b16      	ldr	r3, [pc, #88]	; (800e94c <tcp_receive+0x9e4>)
 800e8f2:	691b      	ldr	r3, [r3, #16]
 800e8f4:	4322      	orrs	r2, r4
 800e8f6:	b292      	uxth	r2, r2
 800e8f8:	21ff      	movs	r1, #255	; 0xff
 800e8fa:	4011      	ands	r1, r2
 800e8fc:	000c      	movs	r4, r1
 800e8fe:	7b19      	ldrb	r1, [r3, #12]
 800e900:	2000      	movs	r0, #0
 800e902:	4001      	ands	r1, r0
 800e904:	1c08      	adds	r0, r1, #0
 800e906:	1c21      	adds	r1, r4, #0
 800e908:	4301      	orrs	r1, r0
 800e90a:	7319      	strb	r1, [r3, #12]
 800e90c:	0a12      	lsrs	r2, r2, #8
 800e90e:	b290      	uxth	r0, r2
 800e910:	7b5a      	ldrb	r2, [r3, #13]
 800e912:	2100      	movs	r1, #0
 800e914:	400a      	ands	r2, r1
 800e916:	1c11      	adds	r1, r2, #0
 800e918:	1c02      	adds	r2, r0, #0
 800e91a:	430a      	orrs	r2, r1
 800e91c:	735a      	strb	r2, [r3, #13]
                tcplen = TCP_TCPLEN(&inseg);
 800e91e:	4b0b      	ldr	r3, [pc, #44]	; (800e94c <tcp_receive+0x9e4>)
 800e920:	891c      	ldrh	r4, [r3, #8]
 800e922:	4b0a      	ldr	r3, [pc, #40]	; (800e94c <tcp_receive+0x9e4>)
 800e924:	691b      	ldr	r3, [r3, #16]
 800e926:	7b1a      	ldrb	r2, [r3, #12]
 800e928:	7b5b      	ldrb	r3, [r3, #13]
 800e92a:	021b      	lsls	r3, r3, #8
 800e92c:	4313      	orrs	r3, r2
 800e92e:	b29b      	uxth	r3, r3
 800e930:	0018      	movs	r0, r3
 800e932:	f7f8 f969 	bl	8006c08 <lwip_htons>
 800e936:	0003      	movs	r3, r0
 800e938:	b2db      	uxtb	r3, r3
 800e93a:	001a      	movs	r2, r3
 800e93c:	2303      	movs	r3, #3
 800e93e:	4013      	ands	r3, r2
 800e940:	d012      	beq.n	800e968 <tcp_receive+0xa00>
 800e942:	2301      	movs	r3, #1
 800e944:	e011      	b.n	800e96a <tcp_receive+0xa02>
 800e946:	46c0      	nop			; (mov r8, r8)
 800e948:	20001b50 	.word	0x20001b50
 800e94c:	20001b2c 	.word	0x20001b2c
 800e950:	20001b5a 	.word	0x20001b5a
 800e954:	ffffc0ff 	.word	0xffffc0ff
 800e958:	080201e0 	.word	0x080201e0
 800e95c:	000005cc 	.word	0x000005cc
 800e960:	08020580 	.word	0x08020580
 800e964:	08020220 	.word	0x08020220
 800e968:	2300      	movs	r3, #0
 800e96a:	191b      	adds	r3, r3, r4
 800e96c:	b29a      	uxth	r2, r3
 800e96e:	4bb9      	ldr	r3, [pc, #740]	; (800ec54 <tcp_receive+0xcec>)
 800e970:	801a      	strh	r2, [r3, #0]
              }
              tmp = next;
 800e972:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e974:	613b      	str	r3, [r7, #16]
              next = next->next;
 800e976:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e978:	681b      	ldr	r3, [r3, #0]
 800e97a:	63fb      	str	r3, [r7, #60]	; 0x3c
              tcp_seg_free(tmp);
 800e97c:	693b      	ldr	r3, [r7, #16]
 800e97e:	0018      	movs	r0, r3
 800e980:	f7fd f992 	bl	800bca8 <tcp_seg_free>
            while (next &&
 800e984:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e986:	2b00      	cmp	r3, #0
 800e988:	d018      	beq.n	800e9bc <tcp_receive+0xa54>
                   TCP_SEQ_GEQ(seqno + tcplen,
 800e98a:	4bb2      	ldr	r3, [pc, #712]	; (800ec54 <tcp_receive+0xcec>)
 800e98c:	881b      	ldrh	r3, [r3, #0]
 800e98e:	001a      	movs	r2, r3
 800e990:	4bb1      	ldr	r3, [pc, #708]	; (800ec58 <tcp_receive+0xcf0>)
 800e992:	681b      	ldr	r3, [r3, #0]
 800e994:	18d2      	adds	r2, r2, r3
 800e996:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e998:	691b      	ldr	r3, [r3, #16]
 800e99a:	7919      	ldrb	r1, [r3, #4]
 800e99c:	7958      	ldrb	r0, [r3, #5]
 800e99e:	0200      	lsls	r0, r0, #8
 800e9a0:	4301      	orrs	r1, r0
 800e9a2:	7998      	ldrb	r0, [r3, #6]
 800e9a4:	0400      	lsls	r0, r0, #16
 800e9a6:	4301      	orrs	r1, r0
 800e9a8:	79db      	ldrb	r3, [r3, #7]
 800e9aa:	061b      	lsls	r3, r3, #24
 800e9ac:	430b      	orrs	r3, r1
 800e9ae:	0019      	movs	r1, r3
 800e9b0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e9b2:	891b      	ldrh	r3, [r3, #8]
 800e9b4:	18cb      	adds	r3, r1, r3
 800e9b6:	1ad3      	subs	r3, r2, r3
            while (next &&
 800e9b8:	d400      	bmi.n	800e9bc <tcp_receive+0xa54>
 800e9ba:	e76d      	b.n	800e898 <tcp_receive+0x930>
            }
            /* Now trim right side of inseg if it overlaps with the first
             * segment on ooseq */
            if (next &&
 800e9bc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e9be:	2b00      	cmp	r3, #0
 800e9c0:	d100      	bne.n	800e9c4 <tcp_receive+0xa5c>
 800e9c2:	e079      	b.n	800eab8 <tcp_receive+0xb50>
                TCP_SEQ_GT(seqno + tcplen,
 800e9c4:	4ba3      	ldr	r3, [pc, #652]	; (800ec54 <tcp_receive+0xcec>)
 800e9c6:	881b      	ldrh	r3, [r3, #0]
 800e9c8:	001a      	movs	r2, r3
 800e9ca:	4ba3      	ldr	r3, [pc, #652]	; (800ec58 <tcp_receive+0xcf0>)
 800e9cc:	681b      	ldr	r3, [r3, #0]
 800e9ce:	18d2      	adds	r2, r2, r3
 800e9d0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e9d2:	691b      	ldr	r3, [r3, #16]
 800e9d4:	7919      	ldrb	r1, [r3, #4]
 800e9d6:	7958      	ldrb	r0, [r3, #5]
 800e9d8:	0200      	lsls	r0, r0, #8
 800e9da:	4301      	orrs	r1, r0
 800e9dc:	7998      	ldrb	r0, [r3, #6]
 800e9de:	0400      	lsls	r0, r0, #16
 800e9e0:	4301      	orrs	r1, r0
 800e9e2:	79db      	ldrb	r3, [r3, #7]
 800e9e4:	061b      	lsls	r3, r3, #24
 800e9e6:	430b      	orrs	r3, r1
 800e9e8:	1ad3      	subs	r3, r2, r3
            if (next &&
 800e9ea:	2b00      	cmp	r3, #0
 800e9ec:	dd64      	ble.n	800eab8 <tcp_receive+0xb50>
                           next->tcphdr->seqno)) {
              /* inseg cannot have FIN here (already processed above) */
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
 800e9ee:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e9f0:	691b      	ldr	r3, [r3, #16]
 800e9f2:	791a      	ldrb	r2, [r3, #4]
 800e9f4:	7959      	ldrb	r1, [r3, #5]
 800e9f6:	0209      	lsls	r1, r1, #8
 800e9f8:	430a      	orrs	r2, r1
 800e9fa:	7999      	ldrb	r1, [r3, #6]
 800e9fc:	0409      	lsls	r1, r1, #16
 800e9fe:	430a      	orrs	r2, r1
 800ea00:	79db      	ldrb	r3, [r3, #7]
 800ea02:	061b      	lsls	r3, r3, #24
 800ea04:	4313      	orrs	r3, r2
 800ea06:	b29a      	uxth	r2, r3
 800ea08:	4b93      	ldr	r3, [pc, #588]	; (800ec58 <tcp_receive+0xcf0>)
 800ea0a:	681b      	ldr	r3, [r3, #0]
 800ea0c:	b29b      	uxth	r3, r3
 800ea0e:	1ad3      	subs	r3, r2, r3
 800ea10:	b29a      	uxth	r2, r3
 800ea12:	4b92      	ldr	r3, [pc, #584]	; (800ec5c <tcp_receive+0xcf4>)
 800ea14:	811a      	strh	r2, [r3, #8]
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 800ea16:	4b91      	ldr	r3, [pc, #580]	; (800ec5c <tcp_receive+0xcf4>)
 800ea18:	691b      	ldr	r3, [r3, #16]
 800ea1a:	7b1a      	ldrb	r2, [r3, #12]
 800ea1c:	7b5b      	ldrb	r3, [r3, #13]
 800ea1e:	021b      	lsls	r3, r3, #8
 800ea20:	4313      	orrs	r3, r2
 800ea22:	b29b      	uxth	r3, r3
 800ea24:	0018      	movs	r0, r3
 800ea26:	f7f8 f8ef 	bl	8006c08 <lwip_htons>
 800ea2a:	0003      	movs	r3, r0
 800ea2c:	b2db      	uxtb	r3, r3
 800ea2e:	001a      	movs	r2, r3
 800ea30:	2302      	movs	r3, #2
 800ea32:	4013      	ands	r3, r2
 800ea34:	d005      	beq.n	800ea42 <tcp_receive+0xada>
                inseg.len -= 1;
 800ea36:	4b89      	ldr	r3, [pc, #548]	; (800ec5c <tcp_receive+0xcf4>)
 800ea38:	891b      	ldrh	r3, [r3, #8]
 800ea3a:	3b01      	subs	r3, #1
 800ea3c:	b29a      	uxth	r2, r3
 800ea3e:	4b87      	ldr	r3, [pc, #540]	; (800ec5c <tcp_receive+0xcf4>)
 800ea40:	811a      	strh	r2, [r3, #8]
              }
              pbuf_realloc(inseg.p, inseg.len);
 800ea42:	4b86      	ldr	r3, [pc, #536]	; (800ec5c <tcp_receive+0xcf4>)
 800ea44:	685a      	ldr	r2, [r3, #4]
 800ea46:	4b85      	ldr	r3, [pc, #532]	; (800ec5c <tcp_receive+0xcf4>)
 800ea48:	891b      	ldrh	r3, [r3, #8]
 800ea4a:	0019      	movs	r1, r3
 800ea4c:	0010      	movs	r0, r2
 800ea4e:	f7fa fec5 	bl	80097dc <pbuf_realloc>
              tcplen = TCP_TCPLEN(&inseg);
 800ea52:	4b82      	ldr	r3, [pc, #520]	; (800ec5c <tcp_receive+0xcf4>)
 800ea54:	891c      	ldrh	r4, [r3, #8]
 800ea56:	4b81      	ldr	r3, [pc, #516]	; (800ec5c <tcp_receive+0xcf4>)
 800ea58:	691b      	ldr	r3, [r3, #16]
 800ea5a:	7b1a      	ldrb	r2, [r3, #12]
 800ea5c:	7b5b      	ldrb	r3, [r3, #13]
 800ea5e:	021b      	lsls	r3, r3, #8
 800ea60:	4313      	orrs	r3, r2
 800ea62:	b29b      	uxth	r3, r3
 800ea64:	0018      	movs	r0, r3
 800ea66:	f7f8 f8cf 	bl	8006c08 <lwip_htons>
 800ea6a:	0003      	movs	r3, r0
 800ea6c:	b2db      	uxtb	r3, r3
 800ea6e:	001a      	movs	r2, r3
 800ea70:	2303      	movs	r3, #3
 800ea72:	4013      	ands	r3, r2
 800ea74:	d001      	beq.n	800ea7a <tcp_receive+0xb12>
 800ea76:	2301      	movs	r3, #1
 800ea78:	e000      	b.n	800ea7c <tcp_receive+0xb14>
 800ea7a:	2300      	movs	r3, #0
 800ea7c:	191b      	adds	r3, r3, r4
 800ea7e:	b29a      	uxth	r2, r3
 800ea80:	4b74      	ldr	r3, [pc, #464]	; (800ec54 <tcp_receive+0xcec>)
 800ea82:	801a      	strh	r2, [r3, #0]
              LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
 800ea84:	4b73      	ldr	r3, [pc, #460]	; (800ec54 <tcp_receive+0xcec>)
 800ea86:	881b      	ldrh	r3, [r3, #0]
 800ea88:	001a      	movs	r2, r3
 800ea8a:	4b73      	ldr	r3, [pc, #460]	; (800ec58 <tcp_receive+0xcf0>)
 800ea8c:	681b      	ldr	r3, [r3, #0]
 800ea8e:	18d2      	adds	r2, r2, r3
 800ea90:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ea92:	691b      	ldr	r3, [r3, #16]
 800ea94:	7919      	ldrb	r1, [r3, #4]
 800ea96:	7958      	ldrb	r0, [r3, #5]
 800ea98:	0200      	lsls	r0, r0, #8
 800ea9a:	4301      	orrs	r1, r0
 800ea9c:	7998      	ldrb	r0, [r3, #6]
 800ea9e:	0400      	lsls	r0, r0, #16
 800eaa0:	4301      	orrs	r1, r0
 800eaa2:	79db      	ldrb	r3, [r3, #7]
 800eaa4:	061b      	lsls	r3, r3, #24
 800eaa6:	430b      	orrs	r3, r1
 800eaa8:	429a      	cmp	r2, r3
 800eaaa:	d005      	beq.n	800eab8 <tcp_receive+0xb50>
 800eaac:	4b6c      	ldr	r3, [pc, #432]	; (800ec60 <tcp_receive+0xcf8>)
 800eaae:	4a6d      	ldr	r2, [pc, #436]	; (800ec64 <tcp_receive+0xcfc>)
 800eab0:	496d      	ldr	r1, [pc, #436]	; (800ec68 <tcp_receive+0xd00>)
 800eab2:	486e      	ldr	r0, [pc, #440]	; (800ec6c <tcp_receive+0xd04>)
 800eab4:	f7f3 ff12 	bl	80028dc <app_debug_rtt_raw>
                          (seqno + tcplen) == next->tcphdr->seqno);
            }
            pcb->ooseq = next;
 800eab8:	687b      	ldr	r3, [r7, #4]
 800eaba:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800eabc:	679a      	str	r2, [r3, #120]	; 0x78
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;
 800eabe:	4b65      	ldr	r3, [pc, #404]	; (800ec54 <tcp_receive+0xcec>)
 800eac0:	881b      	ldrh	r3, [r3, #0]
 800eac2:	001a      	movs	r2, r3
 800eac4:	4b64      	ldr	r3, [pc, #400]	; (800ec58 <tcp_receive+0xcf0>)
 800eac6:	681b      	ldr	r3, [r3, #0]
 800eac8:	18d2      	adds	r2, r2, r3
 800eaca:	687b      	ldr	r3, [r7, #4]
 800eacc:	629a      	str	r2, [r3, #40]	; 0x28

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
 800eace:	687b      	ldr	r3, [r7, #4]
 800ead0:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800ead2:	4b60      	ldr	r3, [pc, #384]	; (800ec54 <tcp_receive+0xcec>)
 800ead4:	881b      	ldrh	r3, [r3, #0]
 800ead6:	429a      	cmp	r2, r3
 800ead8:	d206      	bcs.n	800eae8 <tcp_receive+0xb80>
 800eada:	4b61      	ldr	r3, [pc, #388]	; (800ec60 <tcp_receive+0xcf8>)
 800eadc:	22c1      	movs	r2, #193	; 0xc1
 800eade:	00d2      	lsls	r2, r2, #3
 800eae0:	4963      	ldr	r1, [pc, #396]	; (800ec70 <tcp_receive+0xd08>)
 800eae2:	4862      	ldr	r0, [pc, #392]	; (800ec6c <tcp_receive+0xd04>)
 800eae4:	f7f3 fefa 	bl	80028dc <app_debug_rtt_raw>
        pcb->rcv_wnd -= tcplen;
 800eae8:	687b      	ldr	r3, [r7, #4]
 800eaea:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800eaec:	4b59      	ldr	r3, [pc, #356]	; (800ec54 <tcp_receive+0xcec>)
 800eaee:	881b      	ldrh	r3, [r3, #0]
 800eaf0:	1ad3      	subs	r3, r2, r3
 800eaf2:	b29a      	uxth	r2, r3
 800eaf4:	687b      	ldr	r3, [r7, #4]
 800eaf6:	859a      	strh	r2, [r3, #44]	; 0x2c

        tcp_update_rcv_ann_wnd(pcb);
 800eaf8:	687b      	ldr	r3, [r7, #4]
 800eafa:	0018      	movs	r0, r3
 800eafc:	f7fc f9e2 	bl	800aec4 <tcp_update_rcv_ann_wnd>
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
 800eb00:	4b56      	ldr	r3, [pc, #344]	; (800ec5c <tcp_receive+0xcf4>)
 800eb02:	685b      	ldr	r3, [r3, #4]
 800eb04:	891b      	ldrh	r3, [r3, #8]
 800eb06:	2b00      	cmp	r3, #0
 800eb08:	d006      	beq.n	800eb18 <tcp_receive+0xbb0>
          recv_data = inseg.p;
 800eb0a:	4b54      	ldr	r3, [pc, #336]	; (800ec5c <tcp_receive+0xcf4>)
 800eb0c:	685a      	ldr	r2, [r3, #4]
 800eb0e:	4b59      	ldr	r3, [pc, #356]	; (800ec74 <tcp_receive+0xd0c>)
 800eb10:	601a      	str	r2, [r3, #0]
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
 800eb12:	4b52      	ldr	r3, [pc, #328]	; (800ec5c <tcp_receive+0xcf4>)
 800eb14:	2200      	movs	r2, #0
 800eb16:	605a      	str	r2, [r3, #4]
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 800eb18:	4b50      	ldr	r3, [pc, #320]	; (800ec5c <tcp_receive+0xcf4>)
 800eb1a:	691b      	ldr	r3, [r3, #16]
 800eb1c:	7b1a      	ldrb	r2, [r3, #12]
 800eb1e:	7b5b      	ldrb	r3, [r3, #13]
 800eb20:	021b      	lsls	r3, r3, #8
 800eb22:	4313      	orrs	r3, r2
 800eb24:	b29b      	uxth	r3, r3
 800eb26:	0018      	movs	r0, r3
 800eb28:	f7f8 f86e 	bl	8006c08 <lwip_htons>
 800eb2c:	0003      	movs	r3, r0
 800eb2e:	b2db      	uxtb	r3, r3
 800eb30:	001a      	movs	r2, r3
 800eb32:	2301      	movs	r3, #1
 800eb34:	4013      	ands	r3, r2
 800eb36:	d100      	bne.n	800eb3a <tcp_receive+0xbd2>
 800eb38:	e0d1      	b.n	800ecde <tcp_receive+0xd76>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags |= TF_GOT_FIN;
 800eb3a:	4b4f      	ldr	r3, [pc, #316]	; (800ec78 <tcp_receive+0xd10>)
 800eb3c:	781b      	ldrb	r3, [r3, #0]
 800eb3e:	2220      	movs	r2, #32
 800eb40:	4313      	orrs	r3, r2
 800eb42:	b2da      	uxtb	r2, r3
 800eb44:	4b4c      	ldr	r3, [pc, #304]	; (800ec78 <tcp_receive+0xd10>)
 800eb46:	701a      	strb	r2, [r3, #0]
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
 800eb48:	e0c9      	b.n	800ecde <tcp_receive+0xd76>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          struct tcp_seg *cseg = pcb->ooseq;
 800eb4a:	687b      	ldr	r3, [r7, #4]
 800eb4c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800eb4e:	60bb      	str	r3, [r7, #8]
          seqno = pcb->ooseq->tcphdr->seqno;
 800eb50:	687b      	ldr	r3, [r7, #4]
 800eb52:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800eb54:	691b      	ldr	r3, [r3, #16]
 800eb56:	791a      	ldrb	r2, [r3, #4]
 800eb58:	7959      	ldrb	r1, [r3, #5]
 800eb5a:	0209      	lsls	r1, r1, #8
 800eb5c:	430a      	orrs	r2, r1
 800eb5e:	7999      	ldrb	r1, [r3, #6]
 800eb60:	0409      	lsls	r1, r1, #16
 800eb62:	430a      	orrs	r2, r1
 800eb64:	79db      	ldrb	r3, [r3, #7]
 800eb66:	061b      	lsls	r3, r3, #24
 800eb68:	4313      	orrs	r3, r2
 800eb6a:	001a      	movs	r2, r3
 800eb6c:	4b3a      	ldr	r3, [pc, #232]	; (800ec58 <tcp_receive+0xcf0>)
 800eb6e:	601a      	str	r2, [r3, #0]

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
 800eb70:	68bb      	ldr	r3, [r7, #8]
 800eb72:	891b      	ldrh	r3, [r3, #8]
 800eb74:	001c      	movs	r4, r3
 800eb76:	68bb      	ldr	r3, [r7, #8]
 800eb78:	691b      	ldr	r3, [r3, #16]
 800eb7a:	7b1a      	ldrb	r2, [r3, #12]
 800eb7c:	7b5b      	ldrb	r3, [r3, #13]
 800eb7e:	021b      	lsls	r3, r3, #8
 800eb80:	4313      	orrs	r3, r2
 800eb82:	b29b      	uxth	r3, r3
 800eb84:	0018      	movs	r0, r3
 800eb86:	f7f8 f83f 	bl	8006c08 <lwip_htons>
 800eb8a:	0003      	movs	r3, r0
 800eb8c:	b2db      	uxtb	r3, r3
 800eb8e:	001a      	movs	r2, r3
 800eb90:	2303      	movs	r3, #3
 800eb92:	4013      	ands	r3, r2
 800eb94:	d001      	beq.n	800eb9a <tcp_receive+0xc32>
 800eb96:	2301      	movs	r3, #1
 800eb98:	e000      	b.n	800eb9c <tcp_receive+0xc34>
 800eb9a:	2300      	movs	r3, #0
 800eb9c:	191a      	adds	r2, r3, r4
 800eb9e:	687b      	ldr	r3, [r7, #4]
 800eba0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800eba2:	18d2      	adds	r2, r2, r3
 800eba4:	687b      	ldr	r3, [r7, #4]
 800eba6:	629a      	str	r2, [r3, #40]	; 0x28
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
 800eba8:	687b      	ldr	r3, [r7, #4]
 800ebaa:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 800ebac:	001c      	movs	r4, r3
 800ebae:	68bb      	ldr	r3, [r7, #8]
 800ebb0:	891b      	ldrh	r3, [r3, #8]
 800ebb2:	001d      	movs	r5, r3
 800ebb4:	68bb      	ldr	r3, [r7, #8]
 800ebb6:	691b      	ldr	r3, [r3, #16]
 800ebb8:	7b1a      	ldrb	r2, [r3, #12]
 800ebba:	7b5b      	ldrb	r3, [r3, #13]
 800ebbc:	021b      	lsls	r3, r3, #8
 800ebbe:	4313      	orrs	r3, r2
 800ebc0:	b29b      	uxth	r3, r3
 800ebc2:	0018      	movs	r0, r3
 800ebc4:	f7f8 f820 	bl	8006c08 <lwip_htons>
 800ebc8:	0003      	movs	r3, r0
 800ebca:	b2db      	uxtb	r3, r3
 800ebcc:	001a      	movs	r2, r3
 800ebce:	2303      	movs	r3, #3
 800ebd0:	4013      	ands	r3, r2
 800ebd2:	d001      	beq.n	800ebd8 <tcp_receive+0xc70>
 800ebd4:	2301      	movs	r3, #1
 800ebd6:	e000      	b.n	800ebda <tcp_receive+0xc72>
 800ebd8:	2300      	movs	r3, #0
 800ebda:	195b      	adds	r3, r3, r5
 800ebdc:	429c      	cmp	r4, r3
 800ebde:	d205      	bcs.n	800ebec <tcp_receive+0xc84>
 800ebe0:	4b1f      	ldr	r3, [pc, #124]	; (800ec60 <tcp_receive+0xcf8>)
 800ebe2:	4a26      	ldr	r2, [pc, #152]	; (800ec7c <tcp_receive+0xd14>)
 800ebe4:	4926      	ldr	r1, [pc, #152]	; (800ec80 <tcp_receive+0xd18>)
 800ebe6:	4821      	ldr	r0, [pc, #132]	; (800ec6c <tcp_receive+0xd04>)
 800ebe8:	f7f3 fe78 	bl	80028dc <app_debug_rtt_raw>
                      pcb->rcv_wnd >= TCP_TCPLEN(cseg));
          pcb->rcv_wnd -= TCP_TCPLEN(cseg);
 800ebec:	68bb      	ldr	r3, [r7, #8]
 800ebee:	891b      	ldrh	r3, [r3, #8]
 800ebf0:	001c      	movs	r4, r3
 800ebf2:	68bb      	ldr	r3, [r7, #8]
 800ebf4:	691b      	ldr	r3, [r3, #16]
 800ebf6:	7b1a      	ldrb	r2, [r3, #12]
 800ebf8:	7b5b      	ldrb	r3, [r3, #13]
 800ebfa:	021b      	lsls	r3, r3, #8
 800ebfc:	4313      	orrs	r3, r2
 800ebfe:	b29b      	uxth	r3, r3
 800ec00:	0018      	movs	r0, r3
 800ec02:	f7f8 f801 	bl	8006c08 <lwip_htons>
 800ec06:	0003      	movs	r3, r0
 800ec08:	b2db      	uxtb	r3, r3
 800ec0a:	001a      	movs	r2, r3
 800ec0c:	2303      	movs	r3, #3
 800ec0e:	4013      	ands	r3, r2
 800ec10:	d001      	beq.n	800ec16 <tcp_receive+0xcae>
 800ec12:	2301      	movs	r3, #1
 800ec14:	e000      	b.n	800ec18 <tcp_receive+0xcb0>
 800ec16:	2300      	movs	r3, #0
 800ec18:	1919      	adds	r1, r3, r4
 800ec1a:	687b      	ldr	r3, [r7, #4]
 800ec1c:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800ec1e:	b28b      	uxth	r3, r1
 800ec20:	1ad3      	subs	r3, r2, r3
 800ec22:	b29a      	uxth	r2, r3
 800ec24:	687b      	ldr	r3, [r7, #4]
 800ec26:	859a      	strh	r2, [r3, #44]	; 0x2c

          tcp_update_rcv_ann_wnd(pcb);
 800ec28:	687b      	ldr	r3, [r7, #4]
 800ec2a:	0018      	movs	r0, r3
 800ec2c:	f7fc f94a 	bl	800aec4 <tcp_update_rcv_ann_wnd>

          if (cseg->p->tot_len > 0) {
 800ec30:	68bb      	ldr	r3, [r7, #8]
 800ec32:	685b      	ldr	r3, [r3, #4]
 800ec34:	891b      	ldrh	r3, [r3, #8]
 800ec36:	2b00      	cmp	r3, #0
 800ec38:	d02b      	beq.n	800ec92 <tcp_receive+0xd2a>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            /* With window scaling, this can overflow recv_data->tot_len, but
               that's not a problem since we explicitly fix that before passing
               recv_data to the application. */
            if (recv_data) {
 800ec3a:	4b0e      	ldr	r3, [pc, #56]	; (800ec74 <tcp_receive+0xd0c>)
 800ec3c:	681b      	ldr	r3, [r3, #0]
 800ec3e:	2b00      	cmp	r3, #0
 800ec40:	d020      	beq.n	800ec84 <tcp_receive+0xd1c>
              pbuf_cat(recv_data, cseg->p);
 800ec42:	4b0c      	ldr	r3, [pc, #48]	; (800ec74 <tcp_receive+0xd0c>)
 800ec44:	681a      	ldr	r2, [r3, #0]
 800ec46:	68bb      	ldr	r3, [r7, #8]
 800ec48:	685b      	ldr	r3, [r3, #4]
 800ec4a:	0019      	movs	r1, r3
 800ec4c:	0010      	movs	r0, r2
 800ec4e:	f7fb f89f 	bl	8009d90 <pbuf_cat>
 800ec52:	e01b      	b.n	800ec8c <tcp_receive+0xd24>
 800ec54:	20001b5a 	.word	0x20001b5a
 800ec58:	20001b50 	.word	0x20001b50
 800ec5c:	20001b2c 	.word	0x20001b2c
 800ec60:	080201e0 	.word	0x080201e0
 800ec64:	000005fd 	.word	0x000005fd
 800ec68:	080205b8 	.word	0x080205b8
 800ec6c:	08020220 	.word	0x08020220
 800ec70:	080205f4 	.word	0x080205f4
 800ec74:	20001b60 	.word	0x20001b60
 800ec78:	20001b5d 	.word	0x20001b5d
 800ec7c:	0000062c 	.word	0x0000062c
 800ec80:	08020614 	.word	0x08020614
            } else {
              recv_data = cseg->p;
 800ec84:	68bb      	ldr	r3, [r7, #8]
 800ec86:	685a      	ldr	r2, [r3, #4]
 800ec88:	4b9a      	ldr	r3, [pc, #616]	; (800eef4 <tcp_receive+0xf8c>)
 800ec8a:	601a      	str	r2, [r3, #0]
            }
            cseg->p = NULL;
 800ec8c:	68bb      	ldr	r3, [r7, #8]
 800ec8e:	2200      	movs	r2, #0
 800ec90:	605a      	str	r2, [r3, #4]
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 800ec92:	68bb      	ldr	r3, [r7, #8]
 800ec94:	691b      	ldr	r3, [r3, #16]
 800ec96:	7b1a      	ldrb	r2, [r3, #12]
 800ec98:	7b5b      	ldrb	r3, [r3, #13]
 800ec9a:	021b      	lsls	r3, r3, #8
 800ec9c:	4313      	orrs	r3, r2
 800ec9e:	b29b      	uxth	r3, r3
 800eca0:	0018      	movs	r0, r3
 800eca2:	f7f7 ffb1 	bl	8006c08 <lwip_htons>
 800eca6:	0003      	movs	r3, r0
 800eca8:	b2db      	uxtb	r3, r3
 800ecaa:	001a      	movs	r2, r3
 800ecac:	2301      	movs	r3, #1
 800ecae:	4013      	ands	r3, r2
 800ecb0:	d00d      	beq.n	800ecce <tcp_receive+0xd66>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags |= TF_GOT_FIN;
 800ecb2:	4b91      	ldr	r3, [pc, #580]	; (800eef8 <tcp_receive+0xf90>)
 800ecb4:	781b      	ldrb	r3, [r3, #0]
 800ecb6:	2220      	movs	r2, #32
 800ecb8:	4313      	orrs	r3, r2
 800ecba:	b2da      	uxtb	r2, r3
 800ecbc:	4b8e      	ldr	r3, [pc, #568]	; (800eef8 <tcp_receive+0xf90>)
 800ecbe:	701a      	strb	r2, [r3, #0]
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
 800ecc0:	687b      	ldr	r3, [r7, #4]
 800ecc2:	7e1b      	ldrb	r3, [r3, #24]
 800ecc4:	2b04      	cmp	r3, #4
 800ecc6:	d102      	bne.n	800ecce <tcp_receive+0xd66>
              pcb->state = CLOSE_WAIT;
 800ecc8:	687b      	ldr	r3, [r7, #4]
 800ecca:	2207      	movs	r2, #7
 800eccc:	761a      	strb	r2, [r3, #24]
            }
          }

          pcb->ooseq = cseg->next;
 800ecce:	68bb      	ldr	r3, [r7, #8]
 800ecd0:	681a      	ldr	r2, [r3, #0]
 800ecd2:	687b      	ldr	r3, [r7, #4]
 800ecd4:	679a      	str	r2, [r3, #120]	; 0x78
          tcp_seg_free(cseg);
 800ecd6:	68bb      	ldr	r3, [r7, #8]
 800ecd8:	0018      	movs	r0, r3
 800ecda:	f7fc ffe5 	bl	800bca8 <tcp_seg_free>
        while (pcb->ooseq != NULL &&
 800ecde:	687b      	ldr	r3, [r7, #4]
 800ece0:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800ece2:	2b00      	cmp	r3, #0
 800ece4:	d012      	beq.n	800ed0c <tcp_receive+0xda4>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
 800ece6:	687b      	ldr	r3, [r7, #4]
 800ece8:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800ecea:	691b      	ldr	r3, [r3, #16]
 800ecec:	791a      	ldrb	r2, [r3, #4]
 800ecee:	7959      	ldrb	r1, [r3, #5]
 800ecf0:	0209      	lsls	r1, r1, #8
 800ecf2:	430a      	orrs	r2, r1
 800ecf4:	7999      	ldrb	r1, [r3, #6]
 800ecf6:	0409      	lsls	r1, r1, #16
 800ecf8:	430a      	orrs	r2, r1
 800ecfa:	79db      	ldrb	r3, [r3, #7]
 800ecfc:	061b      	lsls	r3, r3, #24
 800ecfe:	4313      	orrs	r3, r2
 800ed00:	001a      	movs	r2, r3
 800ed02:	687b      	ldr	r3, [r7, #4]
 800ed04:	6a9b      	ldr	r3, [r3, #40]	; 0x28
        while (pcb->ooseq != NULL &&
 800ed06:	429a      	cmp	r2, r3
 800ed08:	d100      	bne.n	800ed0c <tcp_receive+0xda4>
 800ed0a:	e71e      	b.n	800eb4a <tcp_receive+0xbe2>
#endif /* LWIP_TCP_SACK_OUT */
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
 800ed0c:	687b      	ldr	r3, [r7, #4]
 800ed0e:	8bdb      	ldrh	r3, [r3, #30]
 800ed10:	001a      	movs	r2, r3
 800ed12:	2301      	movs	r3, #1
 800ed14:	4013      	ands	r3, r2
 800ed16:	d00e      	beq.n	800ed36 <tcp_receive+0xdce>
 800ed18:	687b      	ldr	r3, [r7, #4]
 800ed1a:	8bdb      	ldrh	r3, [r3, #30]
 800ed1c:	2201      	movs	r2, #1
 800ed1e:	4393      	bics	r3, r2
 800ed20:	b29a      	uxth	r2, r3
 800ed22:	687b      	ldr	r3, [r7, #4]
 800ed24:	83da      	strh	r2, [r3, #30]
 800ed26:	687b      	ldr	r3, [r7, #4]
 800ed28:	8bdb      	ldrh	r3, [r3, #30]
 800ed2a:	2202      	movs	r2, #2
 800ed2c:	4313      	orrs	r3, r2
 800ed2e:	b29a      	uxth	r2, r3
 800ed30:	687b      	ldr	r3, [r7, #4]
 800ed32:	83da      	strh	r2, [r3, #30]
      if (pcb->rcv_nxt == seqno) {
 800ed34:	e20d      	b.n	800f152 <tcp_receive+0x11ea>
        tcp_ack(pcb);
 800ed36:	687b      	ldr	r3, [r7, #4]
 800ed38:	8bdb      	ldrh	r3, [r3, #30]
 800ed3a:	2201      	movs	r2, #1
 800ed3c:	4313      	orrs	r3, r2
 800ed3e:	b29a      	uxth	r2, r3
 800ed40:	687b      	ldr	r3, [r7, #4]
 800ed42:	83da      	strh	r2, [r3, #30]
      if (pcb->rcv_nxt == seqno) {
 800ed44:	e205      	b.n	800f152 <tcp_receive+0x11ea>
      } else {
        /* We get here if the incoming segment is out-of-sequence. */

#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
 800ed46:	687b      	ldr	r3, [r7, #4]
 800ed48:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800ed4a:	2b00      	cmp	r3, #0
 800ed4c:	d107      	bne.n	800ed5e <tcp_receive+0xdf6>
          pcb->ooseq = tcp_seg_copy(&inseg);
 800ed4e:	4b6b      	ldr	r3, [pc, #428]	; (800eefc <tcp_receive+0xf94>)
 800ed50:	0018      	movs	r0, r3
 800ed52:	f7fc ffc3 	bl	800bcdc <tcp_seg_copy>
 800ed56:	0002      	movs	r2, r0
 800ed58:	687b      	ldr	r3, [r7, #4]
 800ed5a:	679a      	str	r2, [r3, #120]	; 0x78
 800ed5c:	e1ef      	b.n	800f13e <tcp_receive+0x11d6>
#if LWIP_TCP_SACK_OUT
          /* This is the left edge of the lowest possible SACK range.
             It may start before the newly received segment (possibly adjusted below). */
          u32_t sackbeg = TCP_SEQ_LT(seqno, pcb->ooseq->tcphdr->seqno) ? seqno : pcb->ooseq->tcphdr->seqno;
#endif /* LWIP_TCP_SACK_OUT */
          struct tcp_seg *next, *prev = NULL;
 800ed5e:	2300      	movs	r3, #0
 800ed60:	637b      	str	r3, [r7, #52]	; 0x34
          for (next = pcb->ooseq; next != NULL; next = next->next) {
 800ed62:	687b      	ldr	r3, [r7, #4]
 800ed64:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800ed66:	63bb      	str	r3, [r7, #56]	; 0x38
 800ed68:	e1d9      	b.n	800f11e <tcp_receive+0x11b6>
            if (seqno == next->tcphdr->seqno) {
 800ed6a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ed6c:	691b      	ldr	r3, [r3, #16]
 800ed6e:	791a      	ldrb	r2, [r3, #4]
 800ed70:	7959      	ldrb	r1, [r3, #5]
 800ed72:	0209      	lsls	r1, r1, #8
 800ed74:	430a      	orrs	r2, r1
 800ed76:	7999      	ldrb	r1, [r3, #6]
 800ed78:	0409      	lsls	r1, r1, #16
 800ed7a:	430a      	orrs	r2, r1
 800ed7c:	79db      	ldrb	r3, [r3, #7]
 800ed7e:	061b      	lsls	r3, r3, #24
 800ed80:	4313      	orrs	r3, r2
 800ed82:	001a      	movs	r2, r3
 800ed84:	4b5e      	ldr	r3, [pc, #376]	; (800ef00 <tcp_receive+0xf98>)
 800ed86:	681b      	ldr	r3, [r3, #0]
 800ed88:	429a      	cmp	r2, r3
 800ed8a:	d121      	bne.n	800edd0 <tcp_receive+0xe68>
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
 800ed8c:	4b5b      	ldr	r3, [pc, #364]	; (800eefc <tcp_receive+0xf94>)
 800ed8e:	891a      	ldrh	r2, [r3, #8]
 800ed90:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ed92:	891b      	ldrh	r3, [r3, #8]
 800ed94:	429a      	cmp	r2, r3
 800ed96:	d800      	bhi.n	800ed9a <tcp_receive+0xe32>
 800ed98:	e1c6      	b.n	800f128 <tcp_receive+0x11c0>
                /* The incoming segment is larger than the old
                   segment. We replace some segments with the new
                   one. */
                struct tcp_seg *cseg = tcp_seg_copy(&inseg);
 800ed9a:	4b58      	ldr	r3, [pc, #352]	; (800eefc <tcp_receive+0xf94>)
 800ed9c:	0018      	movs	r0, r3
 800ed9e:	f7fc ff9d 	bl	800bcdc <tcp_seg_copy>
 800eda2:	0003      	movs	r3, r0
 800eda4:	617b      	str	r3, [r7, #20]
                if (cseg != NULL) {
 800eda6:	697b      	ldr	r3, [r7, #20]
 800eda8:	2b00      	cmp	r3, #0
 800edaa:	d100      	bne.n	800edae <tcp_receive+0xe46>
 800edac:	e1be      	b.n	800f12c <tcp_receive+0x11c4>
                  if (prev != NULL) {
 800edae:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800edb0:	2b00      	cmp	r3, #0
 800edb2:	d003      	beq.n	800edbc <tcp_receive+0xe54>
                    prev->next = cseg;
 800edb4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800edb6:	697a      	ldr	r2, [r7, #20]
 800edb8:	601a      	str	r2, [r3, #0]
 800edba:	e002      	b.n	800edc2 <tcp_receive+0xe5a>
                  } else {
                    pcb->ooseq = cseg;
 800edbc:	687b      	ldr	r3, [r7, #4]
 800edbe:	697a      	ldr	r2, [r7, #20]
 800edc0:	679a      	str	r2, [r3, #120]	; 0x78
                  }
                  tcp_oos_insert_segment(cseg, next);
 800edc2:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800edc4:	697b      	ldr	r3, [r7, #20]
 800edc6:	0011      	movs	r1, r2
 800edc8:	0018      	movs	r0, r3
 800edca:	f7fe ff7d 	bl	800dcc8 <tcp_oos_insert_segment>
                }
                break;
 800edce:	e1ad      	b.n	800f12c <tcp_receive+0x11c4>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
 800edd0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800edd2:	2b00      	cmp	r3, #0
 800edd4:	d124      	bne.n	800ee20 <tcp_receive+0xeb8>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
 800edd6:	4b4a      	ldr	r3, [pc, #296]	; (800ef00 <tcp_receive+0xf98>)
 800edd8:	681a      	ldr	r2, [r3, #0]
 800edda:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800eddc:	691b      	ldr	r3, [r3, #16]
 800edde:	7919      	ldrb	r1, [r3, #4]
 800ede0:	7958      	ldrb	r0, [r3, #5]
 800ede2:	0200      	lsls	r0, r0, #8
 800ede4:	4301      	orrs	r1, r0
 800ede6:	7998      	ldrb	r0, [r3, #6]
 800ede8:	0400      	lsls	r0, r0, #16
 800edea:	4301      	orrs	r1, r0
 800edec:	79db      	ldrb	r3, [r3, #7]
 800edee:	061b      	lsls	r3, r3, #24
 800edf0:	430b      	orrs	r3, r1
 800edf2:	1ad3      	subs	r3, r2, r3
 800edf4:	d400      	bmi.n	800edf8 <tcp_receive+0xe90>
 800edf6:	e085      	b.n	800ef04 <tcp_receive+0xf9c>
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */
                  struct tcp_seg *cseg = tcp_seg_copy(&inseg);
 800edf8:	4b40      	ldr	r3, [pc, #256]	; (800eefc <tcp_receive+0xf94>)
 800edfa:	0018      	movs	r0, r3
 800edfc:	f7fc ff6e 	bl	800bcdc <tcp_seg_copy>
 800ee00:	0003      	movs	r3, r0
 800ee02:	61bb      	str	r3, [r7, #24]
                  if (cseg != NULL) {
 800ee04:	69bb      	ldr	r3, [r7, #24]
 800ee06:	2b00      	cmp	r3, #0
 800ee08:	d100      	bne.n	800ee0c <tcp_receive+0xea4>
 800ee0a:	e191      	b.n	800f130 <tcp_receive+0x11c8>
                    pcb->ooseq = cseg;
 800ee0c:	687b      	ldr	r3, [r7, #4]
 800ee0e:	69ba      	ldr	r2, [r7, #24]
 800ee10:	679a      	str	r2, [r3, #120]	; 0x78
                    tcp_oos_insert_segment(cseg, next);
 800ee12:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800ee14:	69bb      	ldr	r3, [r7, #24]
 800ee16:	0011      	movs	r1, r2
 800ee18:	0018      	movs	r0, r3
 800ee1a:	f7fe ff55 	bl	800dcc8 <tcp_oos_insert_segment>
                  }
                  break;
 800ee1e:	e187      	b.n	800f130 <tcp_receive+0x11c8>
                }
              } else {
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno + 1, next->tcphdr->seqno - 1)) {
 800ee20:	4b37      	ldr	r3, [pc, #220]	; (800ef00 <tcp_receive+0xf98>)
 800ee22:	681a      	ldr	r2, [r3, #0]
 800ee24:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ee26:	691b      	ldr	r3, [r3, #16]
 800ee28:	7919      	ldrb	r1, [r3, #4]
 800ee2a:	7958      	ldrb	r0, [r3, #5]
 800ee2c:	0200      	lsls	r0, r0, #8
 800ee2e:	4301      	orrs	r1, r0
 800ee30:	7998      	ldrb	r0, [r3, #6]
 800ee32:	0400      	lsls	r0, r0, #16
 800ee34:	4301      	orrs	r1, r0
 800ee36:	79db      	ldrb	r3, [r3, #7]
 800ee38:	061b      	lsls	r3, r3, #24
 800ee3a:	430b      	orrs	r3, r1
 800ee3c:	1ad3      	subs	r3, r2, r3
 800ee3e:	3b01      	subs	r3, #1
 800ee40:	2b00      	cmp	r3, #0
 800ee42:	db5f      	blt.n	800ef04 <tcp_receive+0xf9c>
 800ee44:	4b2e      	ldr	r3, [pc, #184]	; (800ef00 <tcp_receive+0xf98>)
 800ee46:	681a      	ldr	r2, [r3, #0]
 800ee48:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ee4a:	691b      	ldr	r3, [r3, #16]
 800ee4c:	7919      	ldrb	r1, [r3, #4]
 800ee4e:	7958      	ldrb	r0, [r3, #5]
 800ee50:	0200      	lsls	r0, r0, #8
 800ee52:	4301      	orrs	r1, r0
 800ee54:	7998      	ldrb	r0, [r3, #6]
 800ee56:	0400      	lsls	r0, r0, #16
 800ee58:	4301      	orrs	r1, r0
 800ee5a:	79db      	ldrb	r3, [r3, #7]
 800ee5c:	061b      	lsls	r3, r3, #24
 800ee5e:	430b      	orrs	r3, r1
 800ee60:	1ad3      	subs	r3, r2, r3
 800ee62:	3301      	adds	r3, #1
 800ee64:	2b00      	cmp	r3, #0
 800ee66:	dc4d      	bgt.n	800ef04 <tcp_receive+0xf9c>
                  /* The sequence number of the incoming segment is in
                     between the sequence numbers of the previous and
                     the next segment on ->ooseq. We trim trim the previous
                     segment, delete next segments that included in received segment
                     and trim received, if needed. */
                  struct tcp_seg *cseg = tcp_seg_copy(&inseg);
 800ee68:	4b24      	ldr	r3, [pc, #144]	; (800eefc <tcp_receive+0xf94>)
 800ee6a:	0018      	movs	r0, r3
 800ee6c:	f7fc ff36 	bl	800bcdc <tcp_seg_copy>
 800ee70:	0003      	movs	r3, r0
 800ee72:	61fb      	str	r3, [r7, #28]
                  if (cseg != NULL) {
 800ee74:	69fb      	ldr	r3, [r7, #28]
 800ee76:	2b00      	cmp	r3, #0
 800ee78:	d100      	bne.n	800ee7c <tcp_receive+0xf14>
 800ee7a:	e15b      	b.n	800f134 <tcp_receive+0x11cc>
                    if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
 800ee7c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ee7e:	691b      	ldr	r3, [r3, #16]
 800ee80:	791a      	ldrb	r2, [r3, #4]
 800ee82:	7959      	ldrb	r1, [r3, #5]
 800ee84:	0209      	lsls	r1, r1, #8
 800ee86:	430a      	orrs	r2, r1
 800ee88:	7999      	ldrb	r1, [r3, #6]
 800ee8a:	0409      	lsls	r1, r1, #16
 800ee8c:	430a      	orrs	r2, r1
 800ee8e:	79db      	ldrb	r3, [r3, #7]
 800ee90:	061b      	lsls	r3, r3, #24
 800ee92:	4313      	orrs	r3, r2
 800ee94:	001a      	movs	r2, r3
 800ee96:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ee98:	891b      	ldrh	r3, [r3, #8]
 800ee9a:	18d2      	adds	r2, r2, r3
 800ee9c:	4b18      	ldr	r3, [pc, #96]	; (800ef00 <tcp_receive+0xf98>)
 800ee9e:	681b      	ldr	r3, [r3, #0]
 800eea0:	1ad3      	subs	r3, r2, r3
 800eea2:	2b00      	cmp	r3, #0
 800eea4:	dd1b      	ble.n	800eede <tcp_receive+0xf76>
                      /* We need to trim the prev segment. */
                      prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
 800eea6:	4b16      	ldr	r3, [pc, #88]	; (800ef00 <tcp_receive+0xf98>)
 800eea8:	681b      	ldr	r3, [r3, #0]
 800eeaa:	b29a      	uxth	r2, r3
 800eeac:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800eeae:	691b      	ldr	r3, [r3, #16]
 800eeb0:	7919      	ldrb	r1, [r3, #4]
 800eeb2:	7958      	ldrb	r0, [r3, #5]
 800eeb4:	0200      	lsls	r0, r0, #8
 800eeb6:	4301      	orrs	r1, r0
 800eeb8:	7998      	ldrb	r0, [r3, #6]
 800eeba:	0400      	lsls	r0, r0, #16
 800eebc:	4301      	orrs	r1, r0
 800eebe:	79db      	ldrb	r3, [r3, #7]
 800eec0:	061b      	lsls	r3, r3, #24
 800eec2:	430b      	orrs	r3, r1
 800eec4:	b29b      	uxth	r3, r3
 800eec6:	1ad3      	subs	r3, r2, r3
 800eec8:	b29a      	uxth	r2, r3
 800eeca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800eecc:	811a      	strh	r2, [r3, #8]
                      pbuf_realloc(prev->p, prev->len);
 800eece:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800eed0:	685a      	ldr	r2, [r3, #4]
 800eed2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800eed4:	891b      	ldrh	r3, [r3, #8]
 800eed6:	0019      	movs	r1, r3
 800eed8:	0010      	movs	r0, r2
 800eeda:	f7fa fc7f 	bl	80097dc <pbuf_realloc>
                    }
                    prev->next = cseg;
 800eede:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800eee0:	69fa      	ldr	r2, [r7, #28]
 800eee2:	601a      	str	r2, [r3, #0]
                    tcp_oos_insert_segment(cseg, next);
 800eee4:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800eee6:	69fb      	ldr	r3, [r7, #28]
 800eee8:	0011      	movs	r1, r2
 800eeea:	0018      	movs	r0, r3
 800eeec:	f7fe feec 	bl	800dcc8 <tcp_oos_insert_segment>
                  }
                  break;
 800eef0:	e120      	b.n	800f134 <tcp_receive+0x11cc>
 800eef2:	46c0      	nop			; (mov r8, r8)
 800eef4:	20001b60 	.word	0x20001b60
 800eef8:	20001b5d 	.word	0x20001b5d
 800eefc:	20001b2c 	.word	0x20001b2c
 800ef00:	20001b50 	.word	0x20001b50
#endif /* LWIP_TCP_SACK_OUT */

              /* We don't use 'prev' below, so let's set it to current 'next'.
                 This way even if we break the loop below, 'prev' will be pointing
                 at the segment right in front of the newly added one. */
              prev = next;
 800ef04:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ef06:	637b      	str	r3, [r7, #52]	; 0x34

              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
 800ef08:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ef0a:	681b      	ldr	r3, [r3, #0]
 800ef0c:	2b00      	cmp	r3, #0
 800ef0e:	d000      	beq.n	800ef12 <tcp_receive+0xfaa>
 800ef10:	e102      	b.n	800f118 <tcp_receive+0x11b0>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
 800ef12:	4b9f      	ldr	r3, [pc, #636]	; (800f190 <tcp_receive+0x1228>)
 800ef14:	681a      	ldr	r2, [r3, #0]
 800ef16:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ef18:	691b      	ldr	r3, [r3, #16]
 800ef1a:	7919      	ldrb	r1, [r3, #4]
 800ef1c:	7958      	ldrb	r0, [r3, #5]
 800ef1e:	0200      	lsls	r0, r0, #8
 800ef20:	4301      	orrs	r1, r0
 800ef22:	7998      	ldrb	r0, [r3, #6]
 800ef24:	0400      	lsls	r0, r0, #16
 800ef26:	4301      	orrs	r1, r0
 800ef28:	79db      	ldrb	r3, [r3, #7]
 800ef2a:	061b      	lsls	r3, r3, #24
 800ef2c:	430b      	orrs	r3, r1
 800ef2e:	1ad3      	subs	r3, r2, r3
              if (next->next == NULL &&
 800ef30:	2b00      	cmp	r3, #0
 800ef32:	dc00      	bgt.n	800ef36 <tcp_receive+0xfce>
 800ef34:	e0f0      	b.n	800f118 <tcp_receive+0x11b0>
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 800ef36:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ef38:	691b      	ldr	r3, [r3, #16]
 800ef3a:	7b1a      	ldrb	r2, [r3, #12]
 800ef3c:	7b5b      	ldrb	r3, [r3, #13]
 800ef3e:	021b      	lsls	r3, r3, #8
 800ef40:	4313      	orrs	r3, r2
 800ef42:	b29b      	uxth	r3, r3
 800ef44:	0018      	movs	r0, r3
 800ef46:	f7f7 fe5f 	bl	8006c08 <lwip_htons>
 800ef4a:	0003      	movs	r3, r0
 800ef4c:	b2db      	uxtb	r3, r3
 800ef4e:	001a      	movs	r2, r3
 800ef50:	2301      	movs	r3, #1
 800ef52:	4013      	ands	r3, r2
 800ef54:	d000      	beq.n	800ef58 <tcp_receive+0xff0>
 800ef56:	e0ef      	b.n	800f138 <tcp_receive+0x11d0>
                  /* segment "next" already contains all data */
                  break;
                }
                next->next = tcp_seg_copy(&inseg);
 800ef58:	4b8e      	ldr	r3, [pc, #568]	; (800f194 <tcp_receive+0x122c>)
 800ef5a:	0018      	movs	r0, r3
 800ef5c:	f7fc febe 	bl	800bcdc <tcp_seg_copy>
 800ef60:	0002      	movs	r2, r0
 800ef62:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ef64:	601a      	str	r2, [r3, #0]
                if (next->next != NULL) {
 800ef66:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ef68:	681b      	ldr	r3, [r3, #0]
 800ef6a:	2b00      	cmp	r3, #0
 800ef6c:	d100      	bne.n	800ef70 <tcp_receive+0x1008>
 800ef6e:	e0e5      	b.n	800f13c <tcp_receive+0x11d4>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
 800ef70:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ef72:	691b      	ldr	r3, [r3, #16]
 800ef74:	791a      	ldrb	r2, [r3, #4]
 800ef76:	7959      	ldrb	r1, [r3, #5]
 800ef78:	0209      	lsls	r1, r1, #8
 800ef7a:	430a      	orrs	r2, r1
 800ef7c:	7999      	ldrb	r1, [r3, #6]
 800ef7e:	0409      	lsls	r1, r1, #16
 800ef80:	430a      	orrs	r2, r1
 800ef82:	79db      	ldrb	r3, [r3, #7]
 800ef84:	061b      	lsls	r3, r3, #24
 800ef86:	4313      	orrs	r3, r2
 800ef88:	001a      	movs	r2, r3
 800ef8a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ef8c:	891b      	ldrh	r3, [r3, #8]
 800ef8e:	18d2      	adds	r2, r2, r3
 800ef90:	4b7f      	ldr	r3, [pc, #508]	; (800f190 <tcp_receive+0x1228>)
 800ef92:	681b      	ldr	r3, [r3, #0]
 800ef94:	1ad3      	subs	r3, r2, r3
 800ef96:	2b00      	cmp	r3, #0
 800ef98:	dd1b      	ble.n	800efd2 <tcp_receive+0x106a>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
 800ef9a:	4b7d      	ldr	r3, [pc, #500]	; (800f190 <tcp_receive+0x1228>)
 800ef9c:	681b      	ldr	r3, [r3, #0]
 800ef9e:	b29a      	uxth	r2, r3
 800efa0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800efa2:	691b      	ldr	r3, [r3, #16]
 800efa4:	7919      	ldrb	r1, [r3, #4]
 800efa6:	7958      	ldrb	r0, [r3, #5]
 800efa8:	0200      	lsls	r0, r0, #8
 800efaa:	4301      	orrs	r1, r0
 800efac:	7998      	ldrb	r0, [r3, #6]
 800efae:	0400      	lsls	r0, r0, #16
 800efb0:	4301      	orrs	r1, r0
 800efb2:	79db      	ldrb	r3, [r3, #7]
 800efb4:	061b      	lsls	r3, r3, #24
 800efb6:	430b      	orrs	r3, r1
 800efb8:	b29b      	uxth	r3, r3
 800efba:	1ad3      	subs	r3, r2, r3
 800efbc:	b29a      	uxth	r2, r3
 800efbe:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800efc0:	811a      	strh	r2, [r3, #8]
                    pbuf_realloc(next->p, next->len);
 800efc2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800efc4:	685a      	ldr	r2, [r3, #4]
 800efc6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800efc8:	891b      	ldrh	r3, [r3, #8]
 800efca:	0019      	movs	r1, r3
 800efcc:	0010      	movs	r0, r2
 800efce:	f7fa fc05 	bl	80097dc <pbuf_realloc>
                  }
                  /* check if the remote side overruns our receive window */
                  if (TCP_SEQ_GT((u32_t)tcplen + seqno, pcb->rcv_nxt + (u32_t)pcb->rcv_wnd)) {
 800efd2:	4b71      	ldr	r3, [pc, #452]	; (800f198 <tcp_receive+0x1230>)
 800efd4:	881b      	ldrh	r3, [r3, #0]
 800efd6:	001a      	movs	r2, r3
 800efd8:	4b6d      	ldr	r3, [pc, #436]	; (800f190 <tcp_receive+0x1228>)
 800efda:	681b      	ldr	r3, [r3, #0]
 800efdc:	18d2      	adds	r2, r2, r3
 800efde:	687b      	ldr	r3, [r7, #4]
 800efe0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800efe2:	6879      	ldr	r1, [r7, #4]
 800efe4:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
 800efe6:	185b      	adds	r3, r3, r1
 800efe8:	1ad3      	subs	r3, r2, r3
 800efea:	2b00      	cmp	r3, #0
 800efec:	dc00      	bgt.n	800eff0 <tcp_receive+0x1088>
 800efee:	e0a5      	b.n	800f13c <tcp_receive+0x11d4>
                    LWIP_DEBUGF(TCP_INPUT_DEBUG,
                                ("tcp_receive: other end overran receive window"
                                 "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                                 seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
                    if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
 800eff0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800eff2:	681b      	ldr	r3, [r3, #0]
 800eff4:	691b      	ldr	r3, [r3, #16]
 800eff6:	7b1a      	ldrb	r2, [r3, #12]
 800eff8:	7b5b      	ldrb	r3, [r3, #13]
 800effa:	021b      	lsls	r3, r3, #8
 800effc:	4313      	orrs	r3, r2
 800effe:	b29b      	uxth	r3, r3
 800f000:	0018      	movs	r0, r3
 800f002:	f7f7 fe01 	bl	8006c08 <lwip_htons>
 800f006:	0003      	movs	r3, r0
 800f008:	b2db      	uxtb	r3, r3
 800f00a:	001a      	movs	r2, r3
 800f00c:	2301      	movs	r3, #1
 800f00e:	4013      	ands	r3, r2
 800f010:	d03a      	beq.n	800f088 <tcp_receive+0x1120>
                      /* Must remove the FIN from the header as we're trimming
                       * that byte of sequence-space from the packet */
                      TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) & ~TCP_FIN);
 800f012:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f014:	681b      	ldr	r3, [r3, #0]
 800f016:	691b      	ldr	r3, [r3, #16]
 800f018:	7b1a      	ldrb	r2, [r3, #12]
 800f01a:	7b5b      	ldrb	r3, [r3, #13]
 800f01c:	021b      	lsls	r3, r3, #8
 800f01e:	4313      	orrs	r3, r2
 800f020:	b29b      	uxth	r3, r3
 800f022:	b21b      	sxth	r3, r3
 800f024:	4a5d      	ldr	r2, [pc, #372]	; (800f19c <tcp_receive+0x1234>)
 800f026:	4013      	ands	r3, r2
 800f028:	b21c      	sxth	r4, r3
 800f02a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f02c:	681b      	ldr	r3, [r3, #0]
 800f02e:	691b      	ldr	r3, [r3, #16]
 800f030:	7b1a      	ldrb	r2, [r3, #12]
 800f032:	7b5b      	ldrb	r3, [r3, #13]
 800f034:	021b      	lsls	r3, r3, #8
 800f036:	4313      	orrs	r3, r2
 800f038:	b29b      	uxth	r3, r3
 800f03a:	0018      	movs	r0, r3
 800f03c:	f7f7 fde4 	bl	8006c08 <lwip_htons>
 800f040:	0003      	movs	r3, r0
 800f042:	b2db      	uxtb	r3, r3
 800f044:	b29b      	uxth	r3, r3
 800f046:	223e      	movs	r2, #62	; 0x3e
 800f048:	4013      	ands	r3, r2
 800f04a:	b29b      	uxth	r3, r3
 800f04c:	0018      	movs	r0, r3
 800f04e:	f7f7 fddb 	bl	8006c08 <lwip_htons>
 800f052:	0003      	movs	r3, r0
 800f054:	b21b      	sxth	r3, r3
 800f056:	4323      	orrs	r3, r4
 800f058:	b21a      	sxth	r2, r3
 800f05a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f05c:	681b      	ldr	r3, [r3, #0]
 800f05e:	691b      	ldr	r3, [r3, #16]
 800f060:	b292      	uxth	r2, r2
 800f062:	21ff      	movs	r1, #255	; 0xff
 800f064:	4011      	ands	r1, r2
 800f066:	000c      	movs	r4, r1
 800f068:	7b19      	ldrb	r1, [r3, #12]
 800f06a:	2000      	movs	r0, #0
 800f06c:	4001      	ands	r1, r0
 800f06e:	1c08      	adds	r0, r1, #0
 800f070:	1c21      	adds	r1, r4, #0
 800f072:	4301      	orrs	r1, r0
 800f074:	7319      	strb	r1, [r3, #12]
 800f076:	0a12      	lsrs	r2, r2, #8
 800f078:	b290      	uxth	r0, r2
 800f07a:	7b5a      	ldrb	r2, [r3, #13]
 800f07c:	2100      	movs	r1, #0
 800f07e:	400a      	ands	r2, r1
 800f080:	1c11      	adds	r1, r2, #0
 800f082:	1c02      	adds	r2, r0, #0
 800f084:	430a      	orrs	r2, r1
 800f086:	735a      	strb	r2, [r3, #13]
                    }
                    /* Adjust length of segment to fit in the window. */
                    next->next->len = (u16_t)(pcb->rcv_nxt + pcb->rcv_wnd - seqno);
 800f088:	687b      	ldr	r3, [r7, #4]
 800f08a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800f08c:	b29a      	uxth	r2, r3
 800f08e:	687b      	ldr	r3, [r7, #4]
 800f090:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 800f092:	18d3      	adds	r3, r2, r3
 800f094:	b299      	uxth	r1, r3
 800f096:	4b3e      	ldr	r3, [pc, #248]	; (800f190 <tcp_receive+0x1228>)
 800f098:	681b      	ldr	r3, [r3, #0]
 800f09a:	b29a      	uxth	r2, r3
 800f09c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f09e:	681b      	ldr	r3, [r3, #0]
 800f0a0:	1a8a      	subs	r2, r1, r2
 800f0a2:	b292      	uxth	r2, r2
 800f0a4:	811a      	strh	r2, [r3, #8]
                    pbuf_realloc(next->next->p, next->next->len);
 800f0a6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f0a8:	681b      	ldr	r3, [r3, #0]
 800f0aa:	685a      	ldr	r2, [r3, #4]
 800f0ac:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f0ae:	681b      	ldr	r3, [r3, #0]
 800f0b0:	891b      	ldrh	r3, [r3, #8]
 800f0b2:	0019      	movs	r1, r3
 800f0b4:	0010      	movs	r0, r2
 800f0b6:	f7fa fb91 	bl	80097dc <pbuf_realloc>
                    tcplen = TCP_TCPLEN(next->next);
 800f0ba:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f0bc:	681b      	ldr	r3, [r3, #0]
 800f0be:	891c      	ldrh	r4, [r3, #8]
 800f0c0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f0c2:	681b      	ldr	r3, [r3, #0]
 800f0c4:	691b      	ldr	r3, [r3, #16]
 800f0c6:	7b1a      	ldrb	r2, [r3, #12]
 800f0c8:	7b5b      	ldrb	r3, [r3, #13]
 800f0ca:	021b      	lsls	r3, r3, #8
 800f0cc:	4313      	orrs	r3, r2
 800f0ce:	b29b      	uxth	r3, r3
 800f0d0:	0018      	movs	r0, r3
 800f0d2:	f7f7 fd99 	bl	8006c08 <lwip_htons>
 800f0d6:	0003      	movs	r3, r0
 800f0d8:	b2db      	uxtb	r3, r3
 800f0da:	001a      	movs	r2, r3
 800f0dc:	2303      	movs	r3, #3
 800f0de:	4013      	ands	r3, r2
 800f0e0:	d001      	beq.n	800f0e6 <tcp_receive+0x117e>
 800f0e2:	2301      	movs	r3, #1
 800f0e4:	e000      	b.n	800f0e8 <tcp_receive+0x1180>
 800f0e6:	2300      	movs	r3, #0
 800f0e8:	191b      	adds	r3, r3, r4
 800f0ea:	b29a      	uxth	r2, r3
 800f0ec:	4b2a      	ldr	r3, [pc, #168]	; (800f198 <tcp_receive+0x1230>)
 800f0ee:	801a      	strh	r2, [r3, #0]
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 800f0f0:	4b29      	ldr	r3, [pc, #164]	; (800f198 <tcp_receive+0x1230>)
 800f0f2:	881b      	ldrh	r3, [r3, #0]
 800f0f4:	001a      	movs	r2, r3
 800f0f6:	4b26      	ldr	r3, [pc, #152]	; (800f190 <tcp_receive+0x1228>)
 800f0f8:	681b      	ldr	r3, [r3, #0]
 800f0fa:	18d2      	adds	r2, r2, r3
 800f0fc:	687b      	ldr	r3, [r7, #4]
 800f0fe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800f100:	6879      	ldr	r1, [r7, #4]
 800f102:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
 800f104:	185b      	adds	r3, r3, r1
 800f106:	429a      	cmp	r2, r3
 800f108:	d018      	beq.n	800f13c <tcp_receive+0x11d4>
 800f10a:	4b25      	ldr	r3, [pc, #148]	; (800f1a0 <tcp_receive+0x1238>)
 800f10c:	4a25      	ldr	r2, [pc, #148]	; (800f1a4 <tcp_receive+0x123c>)
 800f10e:	4926      	ldr	r1, [pc, #152]	; (800f1a8 <tcp_receive+0x1240>)
 800f110:	4826      	ldr	r0, [pc, #152]	; (800f1ac <tcp_receive+0x1244>)
 800f112:	f7f3 fbe3 	bl	80028dc <app_debug_rtt_raw>
                                (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
                  }
                }
                break;
 800f116:	e011      	b.n	800f13c <tcp_receive+0x11d4>
          for (next = pcb->ooseq; next != NULL; next = next->next) {
 800f118:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f11a:	681b      	ldr	r3, [r3, #0]
 800f11c:	63bb      	str	r3, [r7, #56]	; 0x38
 800f11e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f120:	2b00      	cmp	r3, #0
 800f122:	d000      	beq.n	800f126 <tcp_receive+0x11be>
 800f124:	e621      	b.n	800ed6a <tcp_receive+0xe02>
 800f126:	e00a      	b.n	800f13e <tcp_receive+0x11d6>
                break;
 800f128:	46c0      	nop			; (mov r8, r8)
 800f12a:	e008      	b.n	800f13e <tcp_receive+0x11d6>
                break;
 800f12c:	46c0      	nop			; (mov r8, r8)
 800f12e:	e006      	b.n	800f13e <tcp_receive+0x11d6>
                  break;
 800f130:	46c0      	nop			; (mov r8, r8)
 800f132:	e004      	b.n	800f13e <tcp_receive+0x11d6>
                  break;
 800f134:	46c0      	nop			; (mov r8, r8)
 800f136:	e002      	b.n	800f13e <tcp_receive+0x11d6>
                  break;
 800f138:	46c0      	nop			; (mov r8, r8)
 800f13a:	e000      	b.n	800f13e <tcp_receive+0x11d6>
                break;
 800f13c:	46c0      	nop			; (mov r8, r8)
#endif /* TCP_OOSEQ_BYTES_LIMIT || TCP_OOSEQ_PBUFS_LIMIT */
#endif /* TCP_QUEUE_OOSEQ */

        /* We send the ACK packet after we've (potentially) dealt with SACKs,
           so they can be included in the acknowledgment. */
        tcp_send_empty_ack(pcb);
 800f13e:	687b      	ldr	r3, [r7, #4]
 800f140:	0018      	movs	r0, r3
 800f142:	f002 fd59 	bl	8011bf8 <tcp_send_empty_ack>
      if (pcb->rcv_nxt == seqno) {
 800f146:	e004      	b.n	800f152 <tcp_receive+0x11ea>
      }
    } else {
      /* The incoming segment is not within the window. */
      tcp_send_empty_ack(pcb);
 800f148:	687b      	ldr	r3, [r7, #4]
 800f14a:	0018      	movs	r0, r3
 800f14c:	f002 fd54 	bl	8011bf8 <tcp_send_empty_ack>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
 800f150:	e019      	b.n	800f186 <tcp_receive+0x121e>
 800f152:	e018      	b.n	800f186 <tcp_receive+0x121e>
    }
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    if (!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
 800f154:	4b0e      	ldr	r3, [pc, #56]	; (800f190 <tcp_receive+0x1228>)
 800f156:	681a      	ldr	r2, [r3, #0]
 800f158:	687b      	ldr	r3, [r7, #4]
 800f15a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800f15c:	1ad3      	subs	r3, r2, r3
 800f15e:	d40a      	bmi.n	800f176 <tcp_receive+0x120e>
 800f160:	4b0b      	ldr	r3, [pc, #44]	; (800f190 <tcp_receive+0x1228>)
 800f162:	681a      	ldr	r2, [r3, #0]
 800f164:	687b      	ldr	r3, [r7, #4]
 800f166:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800f168:	6879      	ldr	r1, [r7, #4]
 800f16a:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
 800f16c:	185b      	adds	r3, r3, r1
 800f16e:	1ad3      	subs	r3, r2, r3
 800f170:	3301      	adds	r3, #1
 800f172:	2b00      	cmp	r3, #0
 800f174:	dd07      	ble.n	800f186 <tcp_receive+0x121e>
      tcp_ack_now(pcb);
 800f176:	687b      	ldr	r3, [r7, #4]
 800f178:	8bdb      	ldrh	r3, [r3, #30]
 800f17a:	2202      	movs	r2, #2
 800f17c:	4313      	orrs	r3, r2
 800f17e:	b29a      	uxth	r2, r3
 800f180:	687b      	ldr	r3, [r7, #4]
 800f182:	83da      	strh	r2, [r3, #30]
    }
  }
}
 800f184:	e7ff      	b.n	800f186 <tcp_receive+0x121e>
 800f186:	46c0      	nop			; (mov r8, r8)
 800f188:	46bd      	mov	sp, r7
 800f18a:	b014      	add	sp, #80	; 0x50
 800f18c:	bdb0      	pop	{r4, r5, r7, pc}
 800f18e:	46c0      	nop			; (mov r8, r8)
 800f190:	20001b50 	.word	0x20001b50
 800f194:	20001b2c 	.word	0x20001b2c
 800f198:	20001b5a 	.word	0x20001b5a
 800f19c:	ffffc0ff 	.word	0xffffc0ff
 800f1a0:	080201e0 	.word	0x080201e0
 800f1a4:	000006f9 	.word	0x000006f9
 800f1a8:	08020580 	.word	0x08020580
 800f1ac:	08020220 	.word	0x08020220

0800f1b0 <tcp_get_next_optbyte>:

static u8_t
tcp_get_next_optbyte(void)
{
 800f1b0:	b580      	push	{r7, lr}
 800f1b2:	b082      	sub	sp, #8
 800f1b4:	af00      	add	r7, sp, #0
  u16_t optidx = tcp_optidx++;
 800f1b6:	4b17      	ldr	r3, [pc, #92]	; (800f214 <tcp_get_next_optbyte+0x64>)
 800f1b8:	881b      	ldrh	r3, [r3, #0]
 800f1ba:	1c5a      	adds	r2, r3, #1
 800f1bc:	b291      	uxth	r1, r2
 800f1be:	4a15      	ldr	r2, [pc, #84]	; (800f214 <tcp_get_next_optbyte+0x64>)
 800f1c0:	8011      	strh	r1, [r2, #0]
 800f1c2:	1dba      	adds	r2, r7, #6
 800f1c4:	8013      	strh	r3, [r2, #0]
  if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 800f1c6:	4b14      	ldr	r3, [pc, #80]	; (800f218 <tcp_get_next_optbyte+0x68>)
 800f1c8:	681b      	ldr	r3, [r3, #0]
 800f1ca:	2b00      	cmp	r3, #0
 800f1cc:	d005      	beq.n	800f1da <tcp_get_next_optbyte+0x2a>
 800f1ce:	4b13      	ldr	r3, [pc, #76]	; (800f21c <tcp_get_next_optbyte+0x6c>)
 800f1d0:	881b      	ldrh	r3, [r3, #0]
 800f1d2:	1dba      	adds	r2, r7, #6
 800f1d4:	8812      	ldrh	r2, [r2, #0]
 800f1d6:	429a      	cmp	r2, r3
 800f1d8:	d209      	bcs.n	800f1ee <tcp_get_next_optbyte+0x3e>
    u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
 800f1da:	4b11      	ldr	r3, [pc, #68]	; (800f220 <tcp_get_next_optbyte+0x70>)
 800f1dc:	681b      	ldr	r3, [r3, #0]
 800f1de:	3314      	adds	r3, #20
 800f1e0:	603b      	str	r3, [r7, #0]
    return opts[optidx];
 800f1e2:	1dbb      	adds	r3, r7, #6
 800f1e4:	881b      	ldrh	r3, [r3, #0]
 800f1e6:	683a      	ldr	r2, [r7, #0]
 800f1e8:	18d3      	adds	r3, r2, r3
 800f1ea:	781b      	ldrb	r3, [r3, #0]
 800f1ec:	e00e      	b.n	800f20c <tcp_get_next_optbyte+0x5c>
  } else {
    u8_t idx = (u8_t)(optidx - tcphdr_opt1len);
 800f1ee:	1dbb      	adds	r3, r7, #6
 800f1f0:	881b      	ldrh	r3, [r3, #0]
 800f1f2:	b2d9      	uxtb	r1, r3
 800f1f4:	4b09      	ldr	r3, [pc, #36]	; (800f21c <tcp_get_next_optbyte+0x6c>)
 800f1f6:	881b      	ldrh	r3, [r3, #0]
 800f1f8:	b2da      	uxtb	r2, r3
 800f1fa:	1d7b      	adds	r3, r7, #5
 800f1fc:	1a8a      	subs	r2, r1, r2
 800f1fe:	701a      	strb	r2, [r3, #0]
    return tcphdr_opt2[idx];
 800f200:	4b05      	ldr	r3, [pc, #20]	; (800f218 <tcp_get_next_optbyte+0x68>)
 800f202:	681a      	ldr	r2, [r3, #0]
 800f204:	1d7b      	adds	r3, r7, #5
 800f206:	781b      	ldrb	r3, [r3, #0]
 800f208:	18d3      	adds	r3, r2, r3
 800f20a:	781b      	ldrb	r3, [r3, #0]
  }
}
 800f20c:	0018      	movs	r0, r3
 800f20e:	46bd      	mov	sp, r7
 800f210:	b002      	add	sp, #8
 800f212:	bd80      	pop	{r7, pc}
 800f214:	20001b4c 	.word	0x20001b4c
 800f218:	20001b48 	.word	0x20001b48
 800f21c:	20001b46 	.word	0x20001b46
 800f220:	20001b40 	.word	0x20001b40

0800f224 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
 800f224:	b5b0      	push	{r4, r5, r7, lr}
 800f226:	b084      	sub	sp, #16
 800f228:	af00      	add	r7, sp, #0
 800f22a:	6078      	str	r0, [r7, #4]
  u16_t mss;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  LWIP_ASSERT("tcp_parseopt: invalid pcb", pcb != NULL);
 800f22c:	687b      	ldr	r3, [r7, #4]
 800f22e:	2b00      	cmp	r3, #0
 800f230:	d105      	bne.n	800f23e <tcp_parseopt+0x1a>
 800f232:	4b39      	ldr	r3, [pc, #228]	; (800f318 <tcp_parseopt+0xf4>)
 800f234:	4a39      	ldr	r2, [pc, #228]	; (800f31c <tcp_parseopt+0xf8>)
 800f236:	493a      	ldr	r1, [pc, #232]	; (800f320 <tcp_parseopt+0xfc>)
 800f238:	483a      	ldr	r0, [pc, #232]	; (800f324 <tcp_parseopt+0x100>)
 800f23a:	f7f3 fb4f 	bl	80028dc <app_debug_rtt_raw>

  /* Parse the TCP MSS option, if present. */
  if (tcphdr_optlen != 0) {
 800f23e:	4b3a      	ldr	r3, [pc, #232]	; (800f328 <tcp_parseopt+0x104>)
 800f240:	881b      	ldrh	r3, [r3, #0]
 800f242:	2b00      	cmp	r3, #0
 800f244:	d100      	bne.n	800f248 <tcp_parseopt+0x24>
 800f246:	e064      	b.n	800f312 <tcp_parseopt+0xee>
    for (tcp_optidx = 0; tcp_optidx < tcphdr_optlen; ) {
 800f248:	4b38      	ldr	r3, [pc, #224]	; (800f32c <tcp_parseopt+0x108>)
 800f24a:	2200      	movs	r2, #0
 800f24c:	801a      	strh	r2, [r3, #0]
 800f24e:	e054      	b.n	800f2fa <tcp_parseopt+0xd6>
      u8_t opt = tcp_get_next_optbyte();
 800f250:	250f      	movs	r5, #15
 800f252:	197c      	adds	r4, r7, r5
 800f254:	f7ff ffac 	bl	800f1b0 <tcp_get_next_optbyte>
 800f258:	0003      	movs	r3, r0
 800f25a:	7023      	strb	r3, [r4, #0]
      switch (opt) {
 800f25c:	197b      	adds	r3, r7, r5
 800f25e:	781b      	ldrb	r3, [r3, #0]
 800f260:	2b02      	cmp	r3, #2
 800f262:	d005      	beq.n	800f270 <tcp_parseopt+0x4c>
 800f264:	dc33      	bgt.n	800f2ce <tcp_parseopt+0xaa>
 800f266:	2b00      	cmp	r3, #0
 800f268:	d04e      	beq.n	800f308 <tcp_parseopt+0xe4>
 800f26a:	2b01      	cmp	r3, #1
 800f26c:	d12f      	bne.n	800f2ce <tcp_parseopt+0xaa>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
          return;
        case LWIP_TCP_OPT_NOP:
          /* NOP option. */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
          break;
 800f26e:	e044      	b.n	800f2fa <tcp_parseopt+0xd6>
        case LWIP_TCP_OPT_MSS:
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
          if (tcp_get_next_optbyte() != LWIP_TCP_OPT_LEN_MSS || (tcp_optidx - 2 + LWIP_TCP_OPT_LEN_MSS) > tcphdr_optlen) {
 800f270:	f7ff ff9e 	bl	800f1b0 <tcp_get_next_optbyte>
 800f274:	0003      	movs	r3, r0
 800f276:	2b04      	cmp	r3, #4
 800f278:	d148      	bne.n	800f30c <tcp_parseopt+0xe8>
 800f27a:	4b2c      	ldr	r3, [pc, #176]	; (800f32c <tcp_parseopt+0x108>)
 800f27c:	881b      	ldrh	r3, [r3, #0]
 800f27e:	3301      	adds	r3, #1
 800f280:	4a29      	ldr	r2, [pc, #164]	; (800f328 <tcp_parseopt+0x104>)
 800f282:	8812      	ldrh	r2, [r2, #0]
 800f284:	4293      	cmp	r3, r2
 800f286:	da41      	bge.n	800f30c <tcp_parseopt+0xe8>
            /* Bad length */
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
            return;
          }
          /* An MSS option with the right option length. */
          mss = (u16_t)(tcp_get_next_optbyte() << 8);
 800f288:	f7ff ff92 	bl	800f1b0 <tcp_get_next_optbyte>
 800f28c:	0003      	movs	r3, r0
 800f28e:	b29a      	uxth	r2, r3
 800f290:	240c      	movs	r4, #12
 800f292:	193b      	adds	r3, r7, r4
 800f294:	0212      	lsls	r2, r2, #8
 800f296:	801a      	strh	r2, [r3, #0]
          mss |= tcp_get_next_optbyte();
 800f298:	f7ff ff8a 	bl	800f1b0 <tcp_get_next_optbyte>
 800f29c:	0003      	movs	r3, r0
 800f29e:	b299      	uxth	r1, r3
 800f2a0:	193b      	adds	r3, r7, r4
 800f2a2:	193a      	adds	r2, r7, r4
 800f2a4:	8812      	ldrh	r2, [r2, #0]
 800f2a6:	430a      	orrs	r2, r1
 800f2a8:	801a      	strh	r2, [r3, #0]
          /* Limit the mss to the configured TCP_MSS and prevent division by zero */
          pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 800f2aa:	193b      	adds	r3, r7, r4
 800f2ac:	881a      	ldrh	r2, [r3, #0]
 800f2ae:	2386      	movs	r3, #134	; 0x86
 800f2b0:	009b      	lsls	r3, r3, #2
 800f2b2:	429a      	cmp	r2, r3
 800f2b4:	d806      	bhi.n	800f2c4 <tcp_parseopt+0xa0>
 800f2b6:	193b      	adds	r3, r7, r4
 800f2b8:	881b      	ldrh	r3, [r3, #0]
 800f2ba:	2b00      	cmp	r3, #0
 800f2bc:	d002      	beq.n	800f2c4 <tcp_parseopt+0xa0>
 800f2be:	193b      	adds	r3, r7, r4
 800f2c0:	881b      	ldrh	r3, [r3, #0]
 800f2c2:	e001      	b.n	800f2c8 <tcp_parseopt+0xa4>
 800f2c4:	2386      	movs	r3, #134	; 0x86
 800f2c6:	009b      	lsls	r3, r3, #2
 800f2c8:	687a      	ldr	r2, [r7, #4]
 800f2ca:	86d3      	strh	r3, [r2, #54]	; 0x36
          break;
 800f2cc:	e015      	b.n	800f2fa <tcp_parseopt+0xd6>
          }
          break;
#endif /* LWIP_TCP_SACK_OUT */
        default:
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
          data = tcp_get_next_optbyte();
 800f2ce:	250b      	movs	r5, #11
 800f2d0:	197c      	adds	r4, r7, r5
 800f2d2:	f7ff ff6d 	bl	800f1b0 <tcp_get_next_optbyte>
 800f2d6:	0003      	movs	r3, r0
 800f2d8:	7023      	strb	r3, [r4, #0]
          if (data < 2) {
 800f2da:	002a      	movs	r2, r5
 800f2dc:	18bb      	adds	r3, r7, r2
 800f2de:	781b      	ldrb	r3, [r3, #0]
 800f2e0:	2b01      	cmp	r3, #1
 800f2e2:	d915      	bls.n	800f310 <tcp_parseopt+0xec>
               and we don't process them further. */
            return;
          }
          /* All other options have a length field, so that we easily
             can skip past them. */
          tcp_optidx += data - 2;
 800f2e4:	18bb      	adds	r3, r7, r2
 800f2e6:	781b      	ldrb	r3, [r3, #0]
 800f2e8:	b29a      	uxth	r2, r3
 800f2ea:	4b10      	ldr	r3, [pc, #64]	; (800f32c <tcp_parseopt+0x108>)
 800f2ec:	881b      	ldrh	r3, [r3, #0]
 800f2ee:	18d3      	adds	r3, r2, r3
 800f2f0:	b29b      	uxth	r3, r3
 800f2f2:	3b02      	subs	r3, #2
 800f2f4:	b29a      	uxth	r2, r3
 800f2f6:	4b0d      	ldr	r3, [pc, #52]	; (800f32c <tcp_parseopt+0x108>)
 800f2f8:	801a      	strh	r2, [r3, #0]
    for (tcp_optidx = 0; tcp_optidx < tcphdr_optlen; ) {
 800f2fa:	4b0c      	ldr	r3, [pc, #48]	; (800f32c <tcp_parseopt+0x108>)
 800f2fc:	881a      	ldrh	r2, [r3, #0]
 800f2fe:	4b0a      	ldr	r3, [pc, #40]	; (800f328 <tcp_parseopt+0x104>)
 800f300:	881b      	ldrh	r3, [r3, #0]
 800f302:	429a      	cmp	r2, r3
 800f304:	d3a4      	bcc.n	800f250 <tcp_parseopt+0x2c>
 800f306:	e004      	b.n	800f312 <tcp_parseopt+0xee>
          return;
 800f308:	46c0      	nop			; (mov r8, r8)
 800f30a:	e002      	b.n	800f312 <tcp_parseopt+0xee>
            return;
 800f30c:	46c0      	nop			; (mov r8, r8)
 800f30e:	e000      	b.n	800f312 <tcp_parseopt+0xee>
            return;
 800f310:	46c0      	nop			; (mov r8, r8)
      }
    }
  }
}
 800f312:	46bd      	mov	sp, r7
 800f314:	b004      	add	sp, #16
 800f316:	bdb0      	pop	{r4, r5, r7, pc}
 800f318:	080201e0 	.word	0x080201e0
 800f31c:	0000077e 	.word	0x0000077e
 800f320:	0802063c 	.word	0x0802063c
 800f324:	08020220 	.word	0x08020220
 800f328:	20001b44 	.word	0x20001b44
 800f32c:	20001b4c 	.word	0x20001b4c

0800f330 <tcp_trigger_input_pcb_close>:

void
tcp_trigger_input_pcb_close(void)
{
 800f330:	b580      	push	{r7, lr}
 800f332:	af00      	add	r7, sp, #0
  recv_flags |= TF_CLOSED;
 800f334:	4b04      	ldr	r3, [pc, #16]	; (800f348 <tcp_trigger_input_pcb_close+0x18>)
 800f336:	781b      	ldrb	r3, [r3, #0]
 800f338:	2210      	movs	r2, #16
 800f33a:	4313      	orrs	r3, r2
 800f33c:	b2da      	uxtb	r2, r3
 800f33e:	4b02      	ldr	r3, [pc, #8]	; (800f348 <tcp_trigger_input_pcb_close+0x18>)
 800f340:	701a      	strb	r2, [r3, #0]
}
 800f342:	46c0      	nop			; (mov r8, r8)
 800f344:	46bd      	mov	sp, r7
 800f346:	bd80      	pop	{r7, pc}
 800f348:	20001b5d 	.word	0x20001b5d

0800f34c <tcp_route>:
static err_t tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb, struct netif *netif);

/* tcp_route: common code that returns a fixed bound netif or calls ip_route */
static struct netif *
tcp_route(const struct tcp_pcb *pcb, const ip_addr_t *src, const ip_addr_t *dst)
{
 800f34c:	b580      	push	{r7, lr}
 800f34e:	b084      	sub	sp, #16
 800f350:	af00      	add	r7, sp, #0
 800f352:	60f8      	str	r0, [r7, #12]
 800f354:	60b9      	str	r1, [r7, #8]
 800f356:	607a      	str	r2, [r7, #4]
  LWIP_UNUSED_ARG(src); /* in case IPv4-only and source-based routing is disabled */

  if ((pcb != NULL) && (pcb->netif_idx != NETIF_NO_INDEX)) {
 800f358:	68fb      	ldr	r3, [r7, #12]
 800f35a:	2b00      	cmp	r3, #0
 800f35c:	d00a      	beq.n	800f374 <tcp_route+0x28>
 800f35e:	68fb      	ldr	r3, [r7, #12]
 800f360:	7a1b      	ldrb	r3, [r3, #8]
 800f362:	2b00      	cmp	r3, #0
 800f364:	d006      	beq.n	800f374 <tcp_route+0x28>
    return netif_get_by_index(pcb->netif_idx);
 800f366:	68fb      	ldr	r3, [r7, #12]
 800f368:	7a1b      	ldrb	r3, [r3, #8]
 800f36a:	0018      	movs	r0, r3
 800f36c:	f7fa f83a 	bl	80093e4 <netif_get_by_index>
 800f370:	0003      	movs	r3, r0
 800f372:	e004      	b.n	800f37e <tcp_route+0x32>
  } else {
    return ip_route(src, dst);
 800f374:	687b      	ldr	r3, [r7, #4]
 800f376:	0018      	movs	r0, r3
 800f378:	f003 ffb2 	bl	80132e0 <ip4_route>
 800f37c:	0003      	movs	r3, r0
  }
}
 800f37e:	0018      	movs	r0, r3
 800f380:	46bd      	mov	sp, r7
 800f382:	b004      	add	sp, #16
 800f384:	bd80      	pop	{r7, pc}
	...

0800f388 <tcp_create_segment>:
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *
tcp_create_segment(const struct tcp_pcb *pcb, struct pbuf *p, u8_t hdrflags, u32_t seqno, u8_t optflags)
{
 800f388:	b590      	push	{r4, r7, lr}
 800f38a:	b087      	sub	sp, #28
 800f38c:	af00      	add	r7, sp, #0
 800f38e:	60f8      	str	r0, [r7, #12]
 800f390:	60b9      	str	r1, [r7, #8]
 800f392:	603b      	str	r3, [r7, #0]
 800f394:	1dfb      	adds	r3, r7, #7
 800f396:	701a      	strb	r2, [r3, #0]
  struct tcp_seg *seg;
  u8_t optlen;

  LWIP_ASSERT("tcp_create_segment: invalid pcb", pcb != NULL);
 800f398:	68fb      	ldr	r3, [r7, #12]
 800f39a:	2b00      	cmp	r3, #0
 800f39c:	d105      	bne.n	800f3aa <tcp_create_segment+0x22>
 800f39e:	4b86      	ldr	r3, [pc, #536]	; (800f5b8 <tcp_create_segment+0x230>)
 800f3a0:	4986      	ldr	r1, [pc, #536]	; (800f5bc <tcp_create_segment+0x234>)
 800f3a2:	4887      	ldr	r0, [pc, #540]	; (800f5c0 <tcp_create_segment+0x238>)
 800f3a4:	22a3      	movs	r2, #163	; 0xa3
 800f3a6:	f7f3 fa99 	bl	80028dc <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_create_segment: invalid pbuf", p != NULL);
 800f3aa:	68bb      	ldr	r3, [r7, #8]
 800f3ac:	2b00      	cmp	r3, #0
 800f3ae:	d105      	bne.n	800f3bc <tcp_create_segment+0x34>
 800f3b0:	4b81      	ldr	r3, [pc, #516]	; (800f5b8 <tcp_create_segment+0x230>)
 800f3b2:	4984      	ldr	r1, [pc, #528]	; (800f5c4 <tcp_create_segment+0x23c>)
 800f3b4:	4882      	ldr	r0, [pc, #520]	; (800f5c0 <tcp_create_segment+0x238>)
 800f3b6:	22a4      	movs	r2, #164	; 0xa4
 800f3b8:	f7f3 fa90 	bl	80028dc <app_debug_rtt_raw>

  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
 800f3bc:	2328      	movs	r3, #40	; 0x28
 800f3be:	18fb      	adds	r3, r7, r3
 800f3c0:	781b      	ldrb	r3, [r3, #0]
 800f3c2:	009b      	lsls	r3, r3, #2
 800f3c4:	b2da      	uxtb	r2, r3
 800f3c6:	2317      	movs	r3, #23
 800f3c8:	18fb      	adds	r3, r7, r3
 800f3ca:	2104      	movs	r1, #4
 800f3cc:	400a      	ands	r2, r1
 800f3ce:	701a      	strb	r2, [r3, #0]

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 800f3d0:	2003      	movs	r0, #3
 800f3d2:	f7f9 fc9d 	bl	8008d10 <memp_malloc>
 800f3d6:	0003      	movs	r3, r0
 800f3d8:	613b      	str	r3, [r7, #16]
 800f3da:	693b      	ldr	r3, [r7, #16]
 800f3dc:	2b00      	cmp	r3, #0
 800f3de:	d105      	bne.n	800f3ec <tcp_create_segment+0x64>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
 800f3e0:	68bb      	ldr	r3, [r7, #8]
 800f3e2:	0018      	movs	r0, r3
 800f3e4:	f7fa fbf4 	bl	8009bd0 <pbuf_free>
    return NULL;
 800f3e8:	2300      	movs	r3, #0
 800f3ea:	e0e1      	b.n	800f5b0 <tcp_create_segment+0x228>
  }
  seg->flags = optflags;
 800f3ec:	693a      	ldr	r2, [r7, #16]
 800f3ee:	2328      	movs	r3, #40	; 0x28
 800f3f0:	18fb      	adds	r3, r7, r3
 800f3f2:	781b      	ldrb	r3, [r3, #0]
 800f3f4:	73d3      	strb	r3, [r2, #15]
  seg->next = NULL;
 800f3f6:	693b      	ldr	r3, [r7, #16]
 800f3f8:	2200      	movs	r2, #0
 800f3fa:	601a      	str	r2, [r3, #0]
  seg->p = p;
 800f3fc:	693b      	ldr	r3, [r7, #16]
 800f3fe:	68ba      	ldr	r2, [r7, #8]
 800f400:	605a      	str	r2, [r3, #4]
  LWIP_ASSERT("p->tot_len >= optlen", p->tot_len >= optlen);
 800f402:	68bb      	ldr	r3, [r7, #8]
 800f404:	891a      	ldrh	r2, [r3, #8]
 800f406:	2317      	movs	r3, #23
 800f408:	18fb      	adds	r3, r7, r3
 800f40a:	781b      	ldrb	r3, [r3, #0]
 800f40c:	b29b      	uxth	r3, r3
 800f40e:	429a      	cmp	r2, r3
 800f410:	d205      	bcs.n	800f41e <tcp_create_segment+0x96>
 800f412:	4b69      	ldr	r3, [pc, #420]	; (800f5b8 <tcp_create_segment+0x230>)
 800f414:	496c      	ldr	r1, [pc, #432]	; (800f5c8 <tcp_create_segment+0x240>)
 800f416:	486a      	ldr	r0, [pc, #424]	; (800f5c0 <tcp_create_segment+0x238>)
 800f418:	22b0      	movs	r2, #176	; 0xb0
 800f41a:	f7f3 fa5f 	bl	80028dc <app_debug_rtt_raw>
  seg->len = p->tot_len - optlen;
 800f41e:	68bb      	ldr	r3, [r7, #8]
 800f420:	891a      	ldrh	r2, [r3, #8]
 800f422:	2317      	movs	r3, #23
 800f424:	18fb      	adds	r3, r7, r3
 800f426:	781b      	ldrb	r3, [r3, #0]
 800f428:	b29b      	uxth	r3, r3
 800f42a:	1ad3      	subs	r3, r2, r3
 800f42c:	b29a      	uxth	r2, r3
 800f42e:	693b      	ldr	r3, [r7, #16]
 800f430:	811a      	strh	r2, [r3, #8]
#if TCP_OVERSIZE_DBGCHECK
  seg->oversize_left = 0;
 800f432:	693b      	ldr	r3, [r7, #16]
 800f434:	2200      	movs	r2, #0
 800f436:	815a      	strh	r2, [r3, #10]
#endif /* TCP_OVERSIZE_DBGCHECK */
#if TCP_CHECKSUM_ON_COPY
  seg->chksum = 0;
 800f438:	693b      	ldr	r3, [r7, #16]
 800f43a:	2200      	movs	r2, #0
 800f43c:	819a      	strh	r2, [r3, #12]
  seg->chksum_swapped = 0;
 800f43e:	693b      	ldr	r3, [r7, #16]
 800f440:	2200      	movs	r2, #0
 800f442:	739a      	strb	r2, [r3, #14]
  /* check optflags */
  LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
 800f444:	2328      	movs	r3, #40	; 0x28
 800f446:	18fb      	adds	r3, r7, r3
 800f448:	781b      	ldrb	r3, [r3, #0]
 800f44a:	2204      	movs	r2, #4
 800f44c:	4013      	ands	r3, r2
 800f44e:	d005      	beq.n	800f45c <tcp_create_segment+0xd4>
 800f450:	4b59      	ldr	r3, [pc, #356]	; (800f5b8 <tcp_create_segment+0x230>)
 800f452:	495e      	ldr	r1, [pc, #376]	; (800f5cc <tcp_create_segment+0x244>)
 800f454:	485a      	ldr	r0, [pc, #360]	; (800f5c0 <tcp_create_segment+0x238>)
 800f456:	22b9      	movs	r2, #185	; 0xb9
 800f458:	f7f3 fa40 	bl	80028dc <app_debug_rtt_raw>
              (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_add_header(p, TCP_HLEN)) {
 800f45c:	68bb      	ldr	r3, [r7, #8]
 800f45e:	2114      	movs	r1, #20
 800f460:	0018      	movs	r0, r3
 800f462:	f7fa facd 	bl	8009a00 <pbuf_add_header>
 800f466:	1e03      	subs	r3, r0, #0
 800f468:	d005      	beq.n	800f476 <tcp_create_segment+0xee>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
 800f46a:	693b      	ldr	r3, [r7, #16]
 800f46c:	0018      	movs	r0, r3
 800f46e:	f7fc fc1b 	bl	800bca8 <tcp_seg_free>
    return NULL;
 800f472:	2300      	movs	r3, #0
 800f474:	e09c      	b.n	800f5b0 <tcp_create_segment+0x228>
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 800f476:	693b      	ldr	r3, [r7, #16]
 800f478:	685b      	ldr	r3, [r3, #4]
 800f47a:	685a      	ldr	r2, [r3, #4]
 800f47c:	693b      	ldr	r3, [r7, #16]
 800f47e:	611a      	str	r2, [r3, #16]
  seg->tcphdr->src = lwip_htons(pcb->local_port);
 800f480:	68fb      	ldr	r3, [r7, #12]
 800f482:	8b5a      	ldrh	r2, [r3, #26]
 800f484:	693b      	ldr	r3, [r7, #16]
 800f486:	691c      	ldr	r4, [r3, #16]
 800f488:	0010      	movs	r0, r2
 800f48a:	f7f7 fbbd 	bl	8006c08 <lwip_htons>
 800f48e:	0003      	movs	r3, r0
 800f490:	22ff      	movs	r2, #255	; 0xff
 800f492:	401a      	ands	r2, r3
 800f494:	0010      	movs	r0, r2
 800f496:	7822      	ldrb	r2, [r4, #0]
 800f498:	2100      	movs	r1, #0
 800f49a:	400a      	ands	r2, r1
 800f49c:	1c11      	adds	r1, r2, #0
 800f49e:	1c02      	adds	r2, r0, #0
 800f4a0:	430a      	orrs	r2, r1
 800f4a2:	7022      	strb	r2, [r4, #0]
 800f4a4:	0a1b      	lsrs	r3, r3, #8
 800f4a6:	b299      	uxth	r1, r3
 800f4a8:	7863      	ldrb	r3, [r4, #1]
 800f4aa:	2200      	movs	r2, #0
 800f4ac:	4013      	ands	r3, r2
 800f4ae:	1c1a      	adds	r2, r3, #0
 800f4b0:	1c0b      	adds	r3, r1, #0
 800f4b2:	4313      	orrs	r3, r2
 800f4b4:	7063      	strb	r3, [r4, #1]
  seg->tcphdr->dest = lwip_htons(pcb->remote_port);
 800f4b6:	68fb      	ldr	r3, [r7, #12]
 800f4b8:	8b9a      	ldrh	r2, [r3, #28]
 800f4ba:	693b      	ldr	r3, [r7, #16]
 800f4bc:	691c      	ldr	r4, [r3, #16]
 800f4be:	0010      	movs	r0, r2
 800f4c0:	f7f7 fba2 	bl	8006c08 <lwip_htons>
 800f4c4:	0003      	movs	r3, r0
 800f4c6:	22ff      	movs	r2, #255	; 0xff
 800f4c8:	401a      	ands	r2, r3
 800f4ca:	0010      	movs	r0, r2
 800f4cc:	78a2      	ldrb	r2, [r4, #2]
 800f4ce:	2100      	movs	r1, #0
 800f4d0:	400a      	ands	r2, r1
 800f4d2:	1c11      	adds	r1, r2, #0
 800f4d4:	1c02      	adds	r2, r0, #0
 800f4d6:	430a      	orrs	r2, r1
 800f4d8:	70a2      	strb	r2, [r4, #2]
 800f4da:	0a1b      	lsrs	r3, r3, #8
 800f4dc:	b299      	uxth	r1, r3
 800f4de:	78e3      	ldrb	r3, [r4, #3]
 800f4e0:	2200      	movs	r2, #0
 800f4e2:	4013      	ands	r3, r2
 800f4e4:	1c1a      	adds	r2, r3, #0
 800f4e6:	1c0b      	adds	r3, r1, #0
 800f4e8:	4313      	orrs	r3, r2
 800f4ea:	70e3      	strb	r3, [r4, #3]
  seg->tcphdr->seqno = lwip_htonl(seqno);
 800f4ec:	693b      	ldr	r3, [r7, #16]
 800f4ee:	691c      	ldr	r4, [r3, #16]
 800f4f0:	683b      	ldr	r3, [r7, #0]
 800f4f2:	0018      	movs	r0, r3
 800f4f4:	f7f7 fb9e 	bl	8006c34 <lwip_htonl>
 800f4f8:	0003      	movs	r3, r0
 800f4fa:	22ff      	movs	r2, #255	; 0xff
 800f4fc:	401a      	ands	r2, r3
 800f4fe:	0010      	movs	r0, r2
 800f500:	7922      	ldrb	r2, [r4, #4]
 800f502:	2100      	movs	r1, #0
 800f504:	400a      	ands	r2, r1
 800f506:	1c11      	adds	r1, r2, #0
 800f508:	1c02      	adds	r2, r0, #0
 800f50a:	430a      	orrs	r2, r1
 800f50c:	7122      	strb	r2, [r4, #4]
 800f50e:	0a1a      	lsrs	r2, r3, #8
 800f510:	21ff      	movs	r1, #255	; 0xff
 800f512:	400a      	ands	r2, r1
 800f514:	0010      	movs	r0, r2
 800f516:	7962      	ldrb	r2, [r4, #5]
 800f518:	2100      	movs	r1, #0
 800f51a:	400a      	ands	r2, r1
 800f51c:	1c11      	adds	r1, r2, #0
 800f51e:	1c02      	adds	r2, r0, #0
 800f520:	430a      	orrs	r2, r1
 800f522:	7162      	strb	r2, [r4, #5]
 800f524:	0c1a      	lsrs	r2, r3, #16
 800f526:	21ff      	movs	r1, #255	; 0xff
 800f528:	400a      	ands	r2, r1
 800f52a:	0010      	movs	r0, r2
 800f52c:	79a2      	ldrb	r2, [r4, #6]
 800f52e:	2100      	movs	r1, #0
 800f530:	400a      	ands	r2, r1
 800f532:	1c11      	adds	r1, r2, #0
 800f534:	1c02      	adds	r2, r0, #0
 800f536:	430a      	orrs	r2, r1
 800f538:	71a2      	strb	r2, [r4, #6]
 800f53a:	0e19      	lsrs	r1, r3, #24
 800f53c:	79e3      	ldrb	r3, [r4, #7]
 800f53e:	2200      	movs	r2, #0
 800f540:	4013      	ands	r3, r2
 800f542:	1c1a      	adds	r2, r3, #0
 800f544:	1c0b      	adds	r3, r1, #0
 800f546:	4313      	orrs	r3, r2
 800f548:	71e3      	strb	r3, [r4, #7]
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), hdrflags);
 800f54a:	2317      	movs	r3, #23
 800f54c:	18fb      	adds	r3, r7, r3
 800f54e:	781b      	ldrb	r3, [r3, #0]
 800f550:	089b      	lsrs	r3, r3, #2
 800f552:	b2db      	uxtb	r3, r3
 800f554:	b29b      	uxth	r3, r3
 800f556:	3305      	adds	r3, #5
 800f558:	b29b      	uxth	r3, r3
 800f55a:	031b      	lsls	r3, r3, #12
 800f55c:	b29a      	uxth	r2, r3
 800f55e:	1dfb      	adds	r3, r7, #7
 800f560:	781b      	ldrb	r3, [r3, #0]
 800f562:	b29b      	uxth	r3, r3
 800f564:	4313      	orrs	r3, r2
 800f566:	b29a      	uxth	r2, r3
 800f568:	693b      	ldr	r3, [r7, #16]
 800f56a:	691c      	ldr	r4, [r3, #16]
 800f56c:	0010      	movs	r0, r2
 800f56e:	f7f7 fb4b 	bl	8006c08 <lwip_htons>
 800f572:	0003      	movs	r3, r0
 800f574:	22ff      	movs	r2, #255	; 0xff
 800f576:	401a      	ands	r2, r3
 800f578:	0010      	movs	r0, r2
 800f57a:	7b22      	ldrb	r2, [r4, #12]
 800f57c:	2100      	movs	r1, #0
 800f57e:	400a      	ands	r2, r1
 800f580:	1c11      	adds	r1, r2, #0
 800f582:	1c02      	adds	r2, r0, #0
 800f584:	430a      	orrs	r2, r1
 800f586:	7322      	strb	r2, [r4, #12]
 800f588:	0a1b      	lsrs	r3, r3, #8
 800f58a:	b299      	uxth	r1, r3
 800f58c:	7b63      	ldrb	r3, [r4, #13]
 800f58e:	2200      	movs	r2, #0
 800f590:	4013      	ands	r3, r2
 800f592:	1c1a      	adds	r2, r3, #0
 800f594:	1c0b      	adds	r3, r1, #0
 800f596:	4313      	orrs	r3, r2
 800f598:	7363      	strb	r3, [r4, #13]
  /* wnd and chksum are set in tcp_output */
  seg->tcphdr->urgp = 0;
 800f59a:	693b      	ldr	r3, [r7, #16]
 800f59c:	691b      	ldr	r3, [r3, #16]
 800f59e:	7c9a      	ldrb	r2, [r3, #18]
 800f5a0:	2100      	movs	r1, #0
 800f5a2:	400a      	ands	r2, r1
 800f5a4:	749a      	strb	r2, [r3, #18]
 800f5a6:	7cda      	ldrb	r2, [r3, #19]
 800f5a8:	2100      	movs	r1, #0
 800f5aa:	400a      	ands	r2, r1
 800f5ac:	74da      	strb	r2, [r3, #19]
  return seg;
 800f5ae:	693b      	ldr	r3, [r7, #16]
}
 800f5b0:	0018      	movs	r0, r3
 800f5b2:	46bd      	mov	sp, r7
 800f5b4:	b007      	add	sp, #28
 800f5b6:	bd90      	pop	{r4, r7, pc}
 800f5b8:	08020658 	.word	0x08020658
 800f5bc:	08020684 	.word	0x08020684
 800f5c0:	080206a4 	.word	0x080206a4
 800f5c4:	080206d0 	.word	0x080206d0
 800f5c8:	080206f4 	.word	0x080206f4
 800f5cc:	0802070c 	.word	0x0802070c

0800f5d0 <tcp_pbuf_prealloc>:
#if TCP_OVERSIZE
static struct pbuf *
tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
                  u16_t *oversize, const struct tcp_pcb *pcb, u8_t apiflags,
                  u8_t first_seg)
{
 800f5d0:	b590      	push	{r4, r7, lr}
 800f5d2:	b087      	sub	sp, #28
 800f5d4:	af00      	add	r7, sp, #0
 800f5d6:	0004      	movs	r4, r0
 800f5d8:	0008      	movs	r0, r1
 800f5da:	0011      	movs	r1, r2
 800f5dc:	607b      	str	r3, [r7, #4]
 800f5de:	230f      	movs	r3, #15
 800f5e0:	18fb      	adds	r3, r7, r3
 800f5e2:	1c22      	adds	r2, r4, #0
 800f5e4:	701a      	strb	r2, [r3, #0]
 800f5e6:	240c      	movs	r4, #12
 800f5e8:	193b      	adds	r3, r7, r4
 800f5ea:	1c02      	adds	r2, r0, #0
 800f5ec:	801a      	strh	r2, [r3, #0]
 800f5ee:	230a      	movs	r3, #10
 800f5f0:	18fb      	adds	r3, r7, r3
 800f5f2:	1c0a      	adds	r2, r1, #0
 800f5f4:	801a      	strh	r2, [r3, #0]
  struct pbuf *p;
  u16_t alloc = length;
 800f5f6:	2316      	movs	r3, #22
 800f5f8:	18fb      	adds	r3, r7, r3
 800f5fa:	193a      	adds	r2, r7, r4
 800f5fc:	8812      	ldrh	r2, [r2, #0]
 800f5fe:	801a      	strh	r2, [r3, #0]

  LWIP_ASSERT("tcp_pbuf_prealloc: invalid oversize", oversize != NULL);
 800f600:	687b      	ldr	r3, [r7, #4]
 800f602:	2b00      	cmp	r3, #0
 800f604:	d105      	bne.n	800f612 <tcp_pbuf_prealloc+0x42>
 800f606:	4b3a      	ldr	r3, [pc, #232]	; (800f6f0 <tcp_pbuf_prealloc+0x120>)
 800f608:	493a      	ldr	r1, [pc, #232]	; (800f6f4 <tcp_pbuf_prealloc+0x124>)
 800f60a:	483b      	ldr	r0, [pc, #236]	; (800f6f8 <tcp_pbuf_prealloc+0x128>)
 800f60c:	22e8      	movs	r2, #232	; 0xe8
 800f60e:	f7f3 f965 	bl	80028dc <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_pbuf_prealloc: invalid pcb", pcb != NULL);
 800f612:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f614:	2b00      	cmp	r3, #0
 800f616:	d105      	bne.n	800f624 <tcp_pbuf_prealloc+0x54>
 800f618:	4b35      	ldr	r3, [pc, #212]	; (800f6f0 <tcp_pbuf_prealloc+0x120>)
 800f61a:	4938      	ldr	r1, [pc, #224]	; (800f6fc <tcp_pbuf_prealloc+0x12c>)
 800f61c:	4836      	ldr	r0, [pc, #216]	; (800f6f8 <tcp_pbuf_prealloc+0x128>)
 800f61e:	22e9      	movs	r2, #233	; 0xe9
 800f620:	f7f3 f95c 	bl	80028dc <app_debug_rtt_raw>
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(apiflags);
  LWIP_UNUSED_ARG(first_seg);
  alloc = max_length;
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (length < max_length) {
 800f624:	230c      	movs	r3, #12
 800f626:	18fa      	adds	r2, r7, r3
 800f628:	230a      	movs	r3, #10
 800f62a:	18fb      	adds	r3, r7, r3
 800f62c:	8812      	ldrh	r2, [r2, #0]
 800f62e:	881b      	ldrh	r3, [r3, #0]
 800f630:	429a      	cmp	r2, r3
 800f632:	d22a      	bcs.n	800f68a <tcp_pbuf_prealloc+0xba>
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
 800f634:	232c      	movs	r3, #44	; 0x2c
 800f636:	18fb      	adds	r3, r7, r3
 800f638:	781b      	ldrb	r3, [r3, #0]
 800f63a:	2202      	movs	r2, #2
 800f63c:	4013      	ands	r3, r2
 800f63e:	d112      	bne.n	800f666 <tcp_pbuf_prealloc+0x96>
        (!(pcb->flags & TF_NODELAY) &&
 800f640:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f642:	8bdb      	ldrh	r3, [r3, #30]
 800f644:	001a      	movs	r2, r3
 800f646:	2340      	movs	r3, #64	; 0x40
 800f648:	4013      	ands	r3, r2
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
 800f64a:	d11e      	bne.n	800f68a <tcp_pbuf_prealloc+0xba>
        (!(pcb->flags & TF_NODELAY) &&
 800f64c:	2330      	movs	r3, #48	; 0x30
 800f64e:	18fb      	adds	r3, r7, r3
 800f650:	781b      	ldrb	r3, [r3, #0]
 800f652:	2b00      	cmp	r3, #0
 800f654:	d007      	beq.n	800f666 <tcp_pbuf_prealloc+0x96>
         (!first_seg ||
          pcb->unsent != NULL ||
 800f656:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f658:	6f1b      	ldr	r3, [r3, #112]	; 0x70
         (!first_seg ||
 800f65a:	2b00      	cmp	r3, #0
 800f65c:	d103      	bne.n	800f666 <tcp_pbuf_prealloc+0x96>
          pcb->unacked != NULL))) {
 800f65e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f660:	6f5b      	ldr	r3, [r3, #116]	; 0x74
          pcb->unsent != NULL ||
 800f662:	2b00      	cmp	r3, #0
 800f664:	d011      	beq.n	800f68a <tcp_pbuf_prealloc+0xba>
      alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(TCP_OVERSIZE_CALC_LENGTH(length)));
 800f666:	230c      	movs	r3, #12
 800f668:	18fb      	adds	r3, r7, r3
 800f66a:	881b      	ldrh	r3, [r3, #0]
 800f66c:	4a24      	ldr	r2, [pc, #144]	; (800f700 <tcp_pbuf_prealloc+0x130>)
 800f66e:	4694      	mov	ip, r2
 800f670:	4463      	add	r3, ip
 800f672:	2203      	movs	r2, #3
 800f674:	4393      	bics	r3, r2
 800f676:	001a      	movs	r2, r3
 800f678:	230a      	movs	r3, #10
 800f67a:	18fb      	adds	r3, r7, r3
 800f67c:	881b      	ldrh	r3, [r3, #0]
 800f67e:	429a      	cmp	r2, r3
 800f680:	d900      	bls.n	800f684 <tcp_pbuf_prealloc+0xb4>
 800f682:	001a      	movs	r2, r3
 800f684:	2316      	movs	r3, #22
 800f686:	18fb      	adds	r3, r7, r3
 800f688:	801a      	strh	r2, [r3, #0]
    }
  }
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
 800f68a:	23a0      	movs	r3, #160	; 0xa0
 800f68c:	009a      	lsls	r2, r3, #2
 800f68e:	2316      	movs	r3, #22
 800f690:	18fb      	adds	r3, r7, r3
 800f692:	8819      	ldrh	r1, [r3, #0]
 800f694:	230f      	movs	r3, #15
 800f696:	18fb      	adds	r3, r7, r3
 800f698:	781b      	ldrb	r3, [r3, #0]
 800f69a:	0018      	movs	r0, r3
 800f69c:	f7f9 ff20 	bl	80094e0 <pbuf_alloc>
 800f6a0:	0003      	movs	r3, r0
 800f6a2:	613b      	str	r3, [r7, #16]
  if (p == NULL) {
 800f6a4:	693b      	ldr	r3, [r7, #16]
 800f6a6:	2b00      	cmp	r3, #0
 800f6a8:	d101      	bne.n	800f6ae <tcp_pbuf_prealloc+0xde>
    return NULL;
 800f6aa:	2300      	movs	r3, #0
 800f6ac:	e01c      	b.n	800f6e8 <tcp_pbuf_prealloc+0x118>
  }
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
 800f6ae:	693b      	ldr	r3, [r7, #16]
 800f6b0:	681b      	ldr	r3, [r3, #0]
 800f6b2:	2b00      	cmp	r3, #0
 800f6b4:	d006      	beq.n	800f6c4 <tcp_pbuf_prealloc+0xf4>
 800f6b6:	4b0e      	ldr	r3, [pc, #56]	; (800f6f0 <tcp_pbuf_prealloc+0x120>)
 800f6b8:	220c      	movs	r2, #12
 800f6ba:	32ff      	adds	r2, #255	; 0xff
 800f6bc:	4911      	ldr	r1, [pc, #68]	; (800f704 <tcp_pbuf_prealloc+0x134>)
 800f6be:	480e      	ldr	r0, [pc, #56]	; (800f6f8 <tcp_pbuf_prealloc+0x128>)
 800f6c0:	f7f3 f90c 	bl	80028dc <app_debug_rtt_raw>
  *oversize = p->len - length;
 800f6c4:	693b      	ldr	r3, [r7, #16]
 800f6c6:	895a      	ldrh	r2, [r3, #10]
 800f6c8:	210c      	movs	r1, #12
 800f6ca:	187b      	adds	r3, r7, r1
 800f6cc:	881b      	ldrh	r3, [r3, #0]
 800f6ce:	1ad3      	subs	r3, r2, r3
 800f6d0:	b29a      	uxth	r2, r3
 800f6d2:	687b      	ldr	r3, [r7, #4]
 800f6d4:	801a      	strh	r2, [r3, #0]
  /* trim p->len to the currently used size */
  p->len = p->tot_len = length;
 800f6d6:	693b      	ldr	r3, [r7, #16]
 800f6d8:	187a      	adds	r2, r7, r1
 800f6da:	8812      	ldrh	r2, [r2, #0]
 800f6dc:	811a      	strh	r2, [r3, #8]
 800f6de:	693b      	ldr	r3, [r7, #16]
 800f6e0:	891a      	ldrh	r2, [r3, #8]
 800f6e2:	693b      	ldr	r3, [r7, #16]
 800f6e4:	815a      	strh	r2, [r3, #10]
  return p;
 800f6e6:	693b      	ldr	r3, [r7, #16]
}
 800f6e8:	0018      	movs	r0, r3
 800f6ea:	46bd      	mov	sp, r7
 800f6ec:	b007      	add	sp, #28
 800f6ee:	bd90      	pop	{r4, r7, pc}
 800f6f0:	08020658 	.word	0x08020658
 800f6f4:	08020740 	.word	0x08020740
 800f6f8:	080206a4 	.word	0x080206a4
 800f6fc:	08020764 	.word	0x08020764
 800f700:	0000021b 	.word	0x0000021b
 800f704:	08020784 	.word	0x08020784

0800f708 <tcp_seg_add_chksum>:
 * Called by tcp_write and tcp_split_unsent_seg.
 */
static void
tcp_seg_add_chksum(u16_t chksum, u16_t len, u16_t *seg_chksum,
                   u8_t *seg_chksum_swapped)
{
 800f708:	b5b0      	push	{r4, r5, r7, lr}
 800f70a:	b086      	sub	sp, #24
 800f70c:	af00      	add	r7, sp, #0
 800f70e:	60ba      	str	r2, [r7, #8]
 800f710:	607b      	str	r3, [r7, #4]
 800f712:	240e      	movs	r4, #14
 800f714:	193b      	adds	r3, r7, r4
 800f716:	1c02      	adds	r2, r0, #0
 800f718:	801a      	strh	r2, [r3, #0]
 800f71a:	250c      	movs	r5, #12
 800f71c:	197b      	adds	r3, r7, r5
 800f71e:	1c0a      	adds	r2, r1, #0
 800f720:	801a      	strh	r2, [r3, #0]
  u32_t helper;
  /* add chksum to old chksum and fold to u16_t */
  helper = chksum + *seg_chksum;
 800f722:	0020      	movs	r0, r4
 800f724:	183b      	adds	r3, r7, r0
 800f726:	881b      	ldrh	r3, [r3, #0]
 800f728:	68ba      	ldr	r2, [r7, #8]
 800f72a:	8812      	ldrh	r2, [r2, #0]
 800f72c:	189b      	adds	r3, r3, r2
 800f72e:	617b      	str	r3, [r7, #20]
  chksum = FOLD_U32T(helper);
 800f730:	697b      	ldr	r3, [r7, #20]
 800f732:	0c1b      	lsrs	r3, r3, #16
 800f734:	b299      	uxth	r1, r3
 800f736:	697b      	ldr	r3, [r7, #20]
 800f738:	b29a      	uxth	r2, r3
 800f73a:	183b      	adds	r3, r7, r0
 800f73c:	188a      	adds	r2, r1, r2
 800f73e:	801a      	strh	r2, [r3, #0]
  if ((len & 1) != 0) {
 800f740:	197b      	adds	r3, r7, r5
 800f742:	881b      	ldrh	r3, [r3, #0]
 800f744:	2201      	movs	r2, #1
 800f746:	4013      	ands	r3, r2
 800f748:	d013      	beq.n	800f772 <tcp_seg_add_chksum+0x6a>
    *seg_chksum_swapped = 1 - *seg_chksum_swapped;
 800f74a:	687b      	ldr	r3, [r7, #4]
 800f74c:	781b      	ldrb	r3, [r3, #0]
 800f74e:	2201      	movs	r2, #1
 800f750:	1ad3      	subs	r3, r2, r3
 800f752:	b2da      	uxtb	r2, r3
 800f754:	687b      	ldr	r3, [r7, #4]
 800f756:	701a      	strb	r2, [r3, #0]
    chksum = SWAP_BYTES_IN_WORD(chksum);
 800f758:	183b      	adds	r3, r7, r0
 800f75a:	881b      	ldrh	r3, [r3, #0]
 800f75c:	021b      	lsls	r3, r3, #8
 800f75e:	b21a      	sxth	r2, r3
 800f760:	183b      	adds	r3, r7, r0
 800f762:	881b      	ldrh	r3, [r3, #0]
 800f764:	0a1b      	lsrs	r3, r3, #8
 800f766:	b29b      	uxth	r3, r3
 800f768:	b21b      	sxth	r3, r3
 800f76a:	4313      	orrs	r3, r2
 800f76c:	b21a      	sxth	r2, r3
 800f76e:	183b      	adds	r3, r7, r0
 800f770:	801a      	strh	r2, [r3, #0]
  }
  *seg_chksum = chksum;
 800f772:	68bb      	ldr	r3, [r7, #8]
 800f774:	220e      	movs	r2, #14
 800f776:	18ba      	adds	r2, r7, r2
 800f778:	8812      	ldrh	r2, [r2, #0]
 800f77a:	801a      	strh	r2, [r3, #0]
}
 800f77c:	46c0      	nop			; (mov r8, r8)
 800f77e:	46bd      	mov	sp, r7
 800f780:	b006      	add	sp, #24
 800f782:	bdb0      	pop	{r4, r5, r7, pc}

0800f784 <tcp_write_checks>:
 * @param len length of data to send (checked agains snd_buf)
 * @return ERR_OK if tcp_write is allowed to proceed, another err_t otherwise
 */
static err_t
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
 800f784:	b580      	push	{r7, lr}
 800f786:	b082      	sub	sp, #8
 800f788:	af00      	add	r7, sp, #0
 800f78a:	6078      	str	r0, [r7, #4]
 800f78c:	000a      	movs	r2, r1
 800f78e:	1cbb      	adds	r3, r7, #2
 800f790:	801a      	strh	r2, [r3, #0]
  LWIP_ASSERT("tcp_write_checks: invalid pcb", pcb != NULL);
 800f792:	687b      	ldr	r3, [r7, #4]
 800f794:	2b00      	cmp	r3, #0
 800f796:	d106      	bne.n	800f7a6 <tcp_write_checks+0x22>
 800f798:	4b34      	ldr	r3, [pc, #208]	; (800f86c <tcp_write_checks+0xe8>)
 800f79a:	2234      	movs	r2, #52	; 0x34
 800f79c:	32ff      	adds	r2, #255	; 0xff
 800f79e:	4934      	ldr	r1, [pc, #208]	; (800f870 <tcp_write_checks+0xec>)
 800f7a0:	4834      	ldr	r0, [pc, #208]	; (800f874 <tcp_write_checks+0xf0>)
 800f7a2:	f7f3 f89b 	bl	80028dc <app_debug_rtt_raw>

  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
 800f7a6:	687b      	ldr	r3, [r7, #4]
 800f7a8:	7e1b      	ldrb	r3, [r3, #24]
 800f7aa:	2b04      	cmp	r3, #4
 800f7ac:	d00e      	beq.n	800f7cc <tcp_write_checks+0x48>
      (pcb->state != CLOSE_WAIT) &&
 800f7ae:	687b      	ldr	r3, [r7, #4]
 800f7b0:	7e1b      	ldrb	r3, [r3, #24]
  if ((pcb->state != ESTABLISHED) &&
 800f7b2:	2b07      	cmp	r3, #7
 800f7b4:	d00a      	beq.n	800f7cc <tcp_write_checks+0x48>
      (pcb->state != SYN_SENT) &&
 800f7b6:	687b      	ldr	r3, [r7, #4]
 800f7b8:	7e1b      	ldrb	r3, [r3, #24]
      (pcb->state != CLOSE_WAIT) &&
 800f7ba:	2b02      	cmp	r3, #2
 800f7bc:	d006      	beq.n	800f7cc <tcp_write_checks+0x48>
      (pcb->state != SYN_RCVD)) {
 800f7be:	687b      	ldr	r3, [r7, #4]
 800f7c0:	7e1b      	ldrb	r3, [r3, #24]
      (pcb->state != SYN_SENT) &&
 800f7c2:	2b03      	cmp	r3, #3
 800f7c4:	d002      	beq.n	800f7cc <tcp_write_checks+0x48>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
 800f7c6:	230b      	movs	r3, #11
 800f7c8:	425b      	negs	r3, r3
 800f7ca:	e04a      	b.n	800f862 <tcp_write_checks+0xde>
  } else if (len == 0) {
 800f7cc:	1cbb      	adds	r3, r7, #2
 800f7ce:	881b      	ldrh	r3, [r3, #0]
 800f7d0:	2b00      	cmp	r3, #0
 800f7d2:	d101      	bne.n	800f7d8 <tcp_write_checks+0x54>
    return ERR_OK;
 800f7d4:	2300      	movs	r3, #0
 800f7d6:	e044      	b.n	800f862 <tcp_write_checks+0xde>
  }

  /* fail on too much data */
  if (len > pcb->snd_buf) {
 800f7d8:	687b      	ldr	r3, [r7, #4]
 800f7da:	2268      	movs	r2, #104	; 0x68
 800f7dc:	5a9b      	ldrh	r3, [r3, r2]
 800f7de:	1cba      	adds	r2, r7, #2
 800f7e0:	8812      	ldrh	r2, [r2, #0]
 800f7e2:	429a      	cmp	r2, r3
 800f7e4:	d909      	bls.n	800f7fa <tcp_write_checks+0x76>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("tcp_write: too much data (len=%"U16_F" > snd_buf=%"TCPWNDSIZE_F")\n",
                len, pcb->snd_buf));
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
 800f7e6:	687b      	ldr	r3, [r7, #4]
 800f7e8:	8bdb      	ldrh	r3, [r3, #30]
 800f7ea:	2280      	movs	r2, #128	; 0x80
 800f7ec:	4313      	orrs	r3, r2
 800f7ee:	b29a      	uxth	r2, r3
 800f7f0:	687b      	ldr	r3, [r7, #4]
 800f7f2:	83da      	strh	r2, [r3, #30]
    return ERR_MEM;
 800f7f4:	2301      	movs	r3, #1
 800f7f6:	425b      	negs	r3, r3
 800f7f8:	e033      	b.n	800f862 <tcp_write_checks+0xde>
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"TCPWNDSIZE_F"\n", (tcpwnd_size_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  /* check for configured max queuelen and possible overflow */
  if (pcb->snd_queuelen >= LWIP_MIN(TCP_SND_QUEUELEN, (TCP_SNDQUEUELEN_OVERFLOW + 1))) {
 800f7fa:	687b      	ldr	r3, [r7, #4]
 800f7fc:	226a      	movs	r2, #106	; 0x6a
 800f7fe:	5a9b      	ldrh	r3, [r3, r2]
 800f800:	2b07      	cmp	r3, #7
 800f802:	d909      	bls.n	800f818 <tcp_write_checks+0x94>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("tcp_write: too long queue %"U16_F" (max %"U16_F")\n",
                pcb->snd_queuelen, (u16_t)TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
 800f804:	687b      	ldr	r3, [r7, #4]
 800f806:	8bdb      	ldrh	r3, [r3, #30]
 800f808:	2280      	movs	r2, #128	; 0x80
 800f80a:	4313      	orrs	r3, r2
 800f80c:	b29a      	uxth	r2, r3
 800f80e:	687b      	ldr	r3, [r7, #4]
 800f810:	83da      	strh	r2, [r3, #30]
    return ERR_MEM;
 800f812:	2301      	movs	r3, #1
 800f814:	425b      	negs	r3, r3
 800f816:	e024      	b.n	800f862 <tcp_write_checks+0xde>
  }
  if (pcb->snd_queuelen != 0) {
 800f818:	687b      	ldr	r3, [r7, #4]
 800f81a:	226a      	movs	r2, #106	; 0x6a
 800f81c:	5a9b      	ldrh	r3, [r3, r2]
 800f81e:	2b00      	cmp	r3, #0
 800f820:	d00f      	beq.n	800f842 <tcp_write_checks+0xbe>
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
 800f822:	687b      	ldr	r3, [r7, #4]
 800f824:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800f826:	2b00      	cmp	r3, #0
 800f828:	d11a      	bne.n	800f860 <tcp_write_checks+0xdc>
 800f82a:	687b      	ldr	r3, [r7, #4]
 800f82c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800f82e:	2b00      	cmp	r3, #0
 800f830:	d116      	bne.n	800f860 <tcp_write_checks+0xdc>
 800f832:	4b0e      	ldr	r3, [pc, #56]	; (800f86c <tcp_write_checks+0xe8>)
 800f834:	2256      	movs	r2, #86	; 0x56
 800f836:	32ff      	adds	r2, #255	; 0xff
 800f838:	490f      	ldr	r1, [pc, #60]	; (800f878 <tcp_write_checks+0xf4>)
 800f83a:	480e      	ldr	r0, [pc, #56]	; (800f874 <tcp_write_checks+0xf0>)
 800f83c:	f7f3 f84e 	bl	80028dc <app_debug_rtt_raw>
 800f840:	e00e      	b.n	800f860 <tcp_write_checks+0xdc>
                pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
 800f842:	687b      	ldr	r3, [r7, #4]
 800f844:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800f846:	2b00      	cmp	r3, #0
 800f848:	d103      	bne.n	800f852 <tcp_write_checks+0xce>
 800f84a:	687b      	ldr	r3, [r7, #4]
 800f84c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800f84e:	2b00      	cmp	r3, #0
 800f850:	d006      	beq.n	800f860 <tcp_write_checks+0xdc>
 800f852:	4b06      	ldr	r3, [pc, #24]	; (800f86c <tcp_write_checks+0xe8>)
 800f854:	22ac      	movs	r2, #172	; 0xac
 800f856:	0052      	lsls	r2, r2, #1
 800f858:	4908      	ldr	r1, [pc, #32]	; (800f87c <tcp_write_checks+0xf8>)
 800f85a:	4806      	ldr	r0, [pc, #24]	; (800f874 <tcp_write_checks+0xf0>)
 800f85c:	f7f3 f83e 	bl	80028dc <app_debug_rtt_raw>
                pcb->unacked == NULL && pcb->unsent == NULL);
  }
  return ERR_OK;
 800f860:	2300      	movs	r3, #0
}
 800f862:	0018      	movs	r0, r3
 800f864:	46bd      	mov	sp, r7
 800f866:	b002      	add	sp, #8
 800f868:	bd80      	pop	{r7, pc}
 800f86a:	46c0      	nop			; (mov r8, r8)
 800f86c:	08020658 	.word	0x08020658
 800f870:	08020798 	.word	0x08020798
 800f874:	080206a4 	.word	0x080206a4
 800f878:	080207b8 	.word	0x080207b8
 800f87c:	080207f4 	.word	0x080207f4

0800f880 <tcp_write>:
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will not be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
 800f880:	b5b0      	push	{r4, r5, r7, lr}
 800f882:	b09e      	sub	sp, #120	; 0x78
 800f884:	af04      	add	r7, sp, #16
 800f886:	60f8      	str	r0, [r7, #12]
 800f888:	60b9      	str	r1, [r7, #8]
 800f88a:	0019      	movs	r1, r3
 800f88c:	1dbb      	adds	r3, r7, #6
 800f88e:	801a      	strh	r2, [r3, #0]
 800f890:	1d7b      	adds	r3, r7, #5
 800f892:	1c0a      	adds	r2, r1, #0
 800f894:	701a      	strb	r2, [r3, #0]
  struct pbuf *concat_p = NULL;
 800f896:	2300      	movs	r3, #0
 800f898:	64bb      	str	r3, [r7, #72]	; 0x48
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 800f89a:	2300      	movs	r3, #0
 800f89c:	64fb      	str	r3, [r7, #76]	; 0x4c
 800f89e:	2300      	movs	r3, #0
 800f8a0:	65fb      	str	r3, [r7, #92]	; 0x5c
 800f8a2:	2300      	movs	r3, #0
 800f8a4:	65bb      	str	r3, [r7, #88]	; 0x58
 800f8a6:	2300      	movs	r3, #0
 800f8a8:	657b      	str	r3, [r7, #84]	; 0x54
  u16_t pos = 0; /* position in 'arg' data */
 800f8aa:	2352      	movs	r3, #82	; 0x52
 800f8ac:	18fb      	adds	r3, r7, r3
 800f8ae:	2200      	movs	r2, #0
 800f8b0:	801a      	strh	r2, [r3, #0]
  u16_t queuelen;
  u8_t optlen;
  u8_t optflags = 0;
 800f8b2:	2333      	movs	r3, #51	; 0x33
 800f8b4:	18fb      	adds	r3, r7, r3
 800f8b6:	2200      	movs	r2, #0
 800f8b8:	701a      	strb	r2, [r3, #0]
#if TCP_OVERSIZE
  u16_t oversize = 0;
 800f8ba:	231e      	movs	r3, #30
 800f8bc:	18fb      	adds	r3, r7, r3
 800f8be:	2200      	movs	r2, #0
 800f8c0:	801a      	strh	r2, [r3, #0]
  u16_t oversize_used = 0;
 800f8c2:	2362      	movs	r3, #98	; 0x62
 800f8c4:	18fb      	adds	r3, r7, r3
 800f8c6:	2200      	movs	r2, #0
 800f8c8:	801a      	strh	r2, [r3, #0]
#if TCP_OVERSIZE_DBGCHECK
  u16_t oversize_add = 0;
 800f8ca:	2366      	movs	r3, #102	; 0x66
 800f8cc:	18fb      	adds	r3, r7, r3
 800f8ce:	2200      	movs	r2, #0
 800f8d0:	801a      	strh	r2, [r3, #0]
#endif /* TCP_OVERSIZE_DBGCHECK*/
#endif /* TCP_OVERSIZE */
  u16_t extendlen = 0;
 800f8d2:	2364      	movs	r3, #100	; 0x64
 800f8d4:	18fb      	adds	r3, r7, r3
 800f8d6:	2200      	movs	r2, #0
 800f8d8:	801a      	strh	r2, [r3, #0]
#if TCP_CHECKSUM_ON_COPY
  u16_t concat_chksum = 0;
 800f8da:	231c      	movs	r3, #28
 800f8dc:	18fb      	adds	r3, r7, r3
 800f8de:	2200      	movs	r2, #0
 800f8e0:	801a      	strh	r2, [r3, #0]
  u8_t concat_chksum_swapped = 0;
 800f8e2:	231b      	movs	r3, #27
 800f8e4:	18fb      	adds	r3, r7, r3
 800f8e6:	2200      	movs	r2, #0
 800f8e8:	701a      	strb	r2, [r3, #0]
  u16_t concat_chksummed = 0;
 800f8ea:	2346      	movs	r3, #70	; 0x46
 800f8ec:	18fb      	adds	r3, r7, r3
 800f8ee:	2200      	movs	r2, #0
 800f8f0:	801a      	strh	r2, [r3, #0]
#endif /* TCP_CHECKSUM_ON_COPY */
  err_t err;
  u16_t mss_local;

  LWIP_ERROR("tcp_write: invalid pcb", pcb != NULL, return ERR_ARG);
 800f8f2:	68fb      	ldr	r3, [r7, #12]
 800f8f4:	2b00      	cmp	r3, #0
 800f8f6:	d107      	bne.n	800f908 <tcp_write+0x88>
 800f8f8:	4bca      	ldr	r3, [pc, #808]	; (800fc24 <tcp_write+0x3a4>)
 800f8fa:	0018      	movs	r0, r3
 800f8fc:	f7f2 ffee 	bl	80028dc <app_debug_rtt_raw>
 800f900:	2310      	movs	r3, #16
 800f902:	425b      	negs	r3, r3
 800f904:	f000 fcfb 	bl	80102fe <tcp_write+0xa7e>

  /* don't allocate segments bigger than half the maximum window we ever received */
  mss_local = LWIP_MIN(pcb->mss, TCPWND_MIN16(pcb->snd_wnd_max / 2));
 800f908:	68fb      	ldr	r3, [r7, #12]
 800f90a:	2266      	movs	r2, #102	; 0x66
 800f90c:	5a9b      	ldrh	r3, [r3, r2]
 800f90e:	085b      	lsrs	r3, r3, #1
 800f910:	b299      	uxth	r1, r3
 800f912:	68fb      	ldr	r3, [r7, #12]
 800f914:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800f916:	2230      	movs	r2, #48	; 0x30
 800f918:	18ba      	adds	r2, r7, r2
 800f91a:	1c1c      	adds	r4, r3, #0
 800f91c:	1c0b      	adds	r3, r1, #0
 800f91e:	b298      	uxth	r0, r3
 800f920:	b2a1      	uxth	r1, r4
 800f922:	4288      	cmp	r0, r1
 800f924:	d900      	bls.n	800f928 <tcp_write+0xa8>
 800f926:	1c23      	adds	r3, r4, #0
 800f928:	8013      	strh	r3, [r2, #0]
  mss_local = mss_local ? mss_local : pcb->mss;
 800f92a:	2330      	movs	r3, #48	; 0x30
 800f92c:	18fb      	adds	r3, r7, r3
 800f92e:	881b      	ldrh	r3, [r3, #0]
 800f930:	2b00      	cmp	r3, #0
 800f932:	d102      	bne.n	800f93a <tcp_write+0xba>
 800f934:	68fb      	ldr	r3, [r7, #12]
 800f936:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800f938:	e002      	b.n	800f940 <tcp_write+0xc0>
 800f93a:	2330      	movs	r3, #48	; 0x30
 800f93c:	18fb      	adds	r3, r7, r3
 800f93e:	881b      	ldrh	r3, [r3, #0]
 800f940:	2230      	movs	r2, #48	; 0x30
 800f942:	18ba      	adds	r2, r7, r2
 800f944:	8013      	strh	r3, [r2, #0]
  apiflags |= TCP_WRITE_FLAG_COPY;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
                                 (void *)pcb, arg, len, (u16_t)apiflags));
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)",
 800f946:	68bb      	ldr	r3, [r7, #8]
 800f948:	2b00      	cmp	r3, #0
 800f94a:	d107      	bne.n	800f95c <tcp_write+0xdc>
 800f94c:	4bb6      	ldr	r3, [pc, #728]	; (800fc28 <tcp_write+0x3a8>)
 800f94e:	0018      	movs	r0, r3
 800f950:	f7f2 ffc4 	bl	80028dc <app_debug_rtt_raw>
 800f954:	2310      	movs	r3, #16
 800f956:	425b      	negs	r3, r3
 800f958:	f000 fcd1 	bl	80102fe <tcp_write+0xa7e>
             arg != NULL, return ERR_ARG;);

  err = tcp_write_checks(pcb, len);
 800f95c:	252f      	movs	r5, #47	; 0x2f
 800f95e:	197c      	adds	r4, r7, r5
 800f960:	1dbb      	adds	r3, r7, #6
 800f962:	881a      	ldrh	r2, [r3, #0]
 800f964:	68fb      	ldr	r3, [r7, #12]
 800f966:	0011      	movs	r1, r2
 800f968:	0018      	movs	r0, r3
 800f96a:	f7ff ff0b 	bl	800f784 <tcp_write_checks>
 800f96e:	0003      	movs	r3, r0
 800f970:	7023      	strb	r3, [r4, #0]
  if (err != ERR_OK) {
 800f972:	197b      	adds	r3, r7, r5
 800f974:	781b      	ldrb	r3, [r3, #0]
 800f976:	b25b      	sxtb	r3, r3
 800f978:	2b00      	cmp	r3, #0
 800f97a:	d004      	beq.n	800f986 <tcp_write+0x106>
    return err;
 800f97c:	197b      	adds	r3, r7, r5
 800f97e:	781b      	ldrb	r3, [r3, #0]
 800f980:	b25b      	sxtb	r3, r3
 800f982:	f000 fcbc 	bl	80102fe <tcp_write+0xa7e>
  }
  queuelen = pcb->snd_queuelen;
 800f986:	2350      	movs	r3, #80	; 0x50
 800f988:	18fb      	adds	r3, r7, r3
 800f98a:	68fa      	ldr	r2, [r7, #12]
 800f98c:	216a      	movs	r1, #106	; 0x6a
 800f98e:	5a52      	ldrh	r2, [r2, r1]
 800f990:	801a      	strh	r2, [r3, #0]
    /* ensure that segments can hold at least one data byte... */
    mss_local = LWIP_MAX(mss_local, LWIP_TCP_OPT_LEN_TS + 1);
  } else
#endif /* LWIP_TCP_TIMESTAMPS */
  {
    optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
 800f992:	232e      	movs	r3, #46	; 0x2e
 800f994:	18fb      	adds	r3, r7, r3
 800f996:	2200      	movs	r2, #0
 800f998:	701a      	strb	r2, [r3, #0]
   *
   * pos records progress as data is segmented.
   */

  /* Find the tail of the unsent queue. */
  if (pcb->unsent != NULL) {
 800f99a:	68fb      	ldr	r3, [r7, #12]
 800f99c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800f99e:	2b00      	cmp	r3, #0
 800f9a0:	d100      	bne.n	800f9a4 <tcp_write+0x124>
 800f9a2:	e19e      	b.n	800fce2 <tcp_write+0x462>
    u16_t space;
    u16_t unsent_optlen;

    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 800f9a4:	68fb      	ldr	r3, [r7, #12]
 800f9a6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800f9a8:	64fb      	str	r3, [r7, #76]	; 0x4c
 800f9aa:	e002      	b.n	800f9b2 <tcp_write+0x132>
         last_unsent = last_unsent->next);
 800f9ac:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f9ae:	681b      	ldr	r3, [r3, #0]
 800f9b0:	64fb      	str	r3, [r7, #76]	; 0x4c
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 800f9b2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f9b4:	681b      	ldr	r3, [r3, #0]
 800f9b6:	2b00      	cmp	r3, #0
 800f9b8:	d1f8      	bne.n	800f9ac <tcp_write+0x12c>

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(last_unsent->flags, pcb);
 800f9ba:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f9bc:	7bdb      	ldrb	r3, [r3, #15]
 800f9be:	009b      	lsls	r3, r3, #2
 800f9c0:	b29a      	uxth	r2, r3
 800f9c2:	202c      	movs	r0, #44	; 0x2c
 800f9c4:	183b      	adds	r3, r7, r0
 800f9c6:	2104      	movs	r1, #4
 800f9c8:	400a      	ands	r2, r1
 800f9ca:	801a      	strh	r2, [r3, #0]
    LWIP_ASSERT("mss_local is too small", mss_local >= last_unsent->len + unsent_optlen);
 800f9cc:	2330      	movs	r3, #48	; 0x30
 800f9ce:	18fb      	adds	r3, r7, r3
 800f9d0:	881a      	ldrh	r2, [r3, #0]
 800f9d2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f9d4:	891b      	ldrh	r3, [r3, #8]
 800f9d6:	0019      	movs	r1, r3
 800f9d8:	183b      	adds	r3, r7, r0
 800f9da:	881b      	ldrh	r3, [r3, #0]
 800f9dc:	18cb      	adds	r3, r1, r3
 800f9de:	429a      	cmp	r2, r3
 800f9e0:	da06      	bge.n	800f9f0 <tcp_write+0x170>
 800f9e2:	4b92      	ldr	r3, [pc, #584]	; (800fc2c <tcp_write+0x3ac>)
 800f9e4:	22f3      	movs	r2, #243	; 0xf3
 800f9e6:	0052      	lsls	r2, r2, #1
 800f9e8:	4991      	ldr	r1, [pc, #580]	; (800fc30 <tcp_write+0x3b0>)
 800f9ea:	4892      	ldr	r0, [pc, #584]	; (800fc34 <tcp_write+0x3b4>)
 800f9ec:	f7f2 ff76 	bl	80028dc <app_debug_rtt_raw>
    space = mss_local - (last_unsent->len + unsent_optlen);
 800f9f0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f9f2:	891a      	ldrh	r2, [r3, #8]
 800f9f4:	232c      	movs	r3, #44	; 0x2c
 800f9f6:	18fb      	adds	r3, r7, r3
 800f9f8:	881b      	ldrh	r3, [r3, #0]
 800f9fa:	18d3      	adds	r3, r2, r3
 800f9fc:	b29a      	uxth	r2, r3
 800f9fe:	2344      	movs	r3, #68	; 0x44
 800fa00:	18fb      	adds	r3, r7, r3
 800fa02:	2130      	movs	r1, #48	; 0x30
 800fa04:	1879      	adds	r1, r7, r1
 800fa06:	8809      	ldrh	r1, [r1, #0]
 800fa08:	1a8a      	subs	r2, r1, r2
 800fa0a:	801a      	strh	r2, [r3, #0]
     * function.
     */
#if TCP_OVERSIZE
#if TCP_OVERSIZE_DBGCHECK
    /* check that pcb->unsent_oversize matches last_unsent->oversize_left */
    LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
 800fa0c:	68fb      	ldr	r3, [r7, #12]
 800fa0e:	226c      	movs	r2, #108	; 0x6c
 800fa10:	5a9a      	ldrh	r2, [r3, r2]
 800fa12:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fa14:	895b      	ldrh	r3, [r3, #10]
 800fa16:	429a      	cmp	r2, r3
 800fa18:	d006      	beq.n	800fa28 <tcp_write+0x1a8>
 800fa1a:	4b84      	ldr	r3, [pc, #528]	; (800fc2c <tcp_write+0x3ac>)
 800fa1c:	22f4      	movs	r2, #244	; 0xf4
 800fa1e:	32ff      	adds	r2, #255	; 0xff
 800fa20:	4985      	ldr	r1, [pc, #532]	; (800fc38 <tcp_write+0x3b8>)
 800fa22:	4884      	ldr	r0, [pc, #528]	; (800fc34 <tcp_write+0x3b4>)
 800fa24:	f7f2 ff5a 	bl	80028dc <app_debug_rtt_raw>
                pcb->unsent_oversize == last_unsent->oversize_left);
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
 800fa28:	68fb      	ldr	r3, [r7, #12]
 800fa2a:	226c      	movs	r2, #108	; 0x6c
 800fa2c:	5a9a      	ldrh	r2, [r3, r2]
 800fa2e:	211e      	movs	r1, #30
 800fa30:	187b      	adds	r3, r7, r1
 800fa32:	801a      	strh	r2, [r3, #0]
    if (oversize > 0) {
 800fa34:	000a      	movs	r2, r1
 800fa36:	18bb      	adds	r3, r7, r2
 800fa38:	881b      	ldrh	r3, [r3, #0]
 800fa3a:	2b00      	cmp	r3, #0
 800fa3c:	d041      	beq.n	800fac2 <tcp_write+0x242>
      LWIP_ASSERT("inconsistent oversize vs. space", oversize <= space);
 800fa3e:	18bb      	adds	r3, r7, r2
 800fa40:	881b      	ldrh	r3, [r3, #0]
 800fa42:	2244      	movs	r2, #68	; 0x44
 800fa44:	18ba      	adds	r2, r7, r2
 800fa46:	8812      	ldrh	r2, [r2, #0]
 800fa48:	429a      	cmp	r2, r3
 800fa4a:	d206      	bcs.n	800fa5a <tcp_write+0x1da>
 800fa4c:	4b77      	ldr	r3, [pc, #476]	; (800fc2c <tcp_write+0x3ac>)
 800fa4e:	22fc      	movs	r2, #252	; 0xfc
 800fa50:	0052      	lsls	r2, r2, #1
 800fa52:	497a      	ldr	r1, [pc, #488]	; (800fc3c <tcp_write+0x3bc>)
 800fa54:	4877      	ldr	r0, [pc, #476]	; (800fc34 <tcp_write+0x3b4>)
 800fa56:	f7f2 ff41 	bl	80028dc <app_debug_rtt_raw>
      seg = last_unsent;
 800fa5a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fa5c:	65fb      	str	r3, [r7, #92]	; 0x5c
      oversize_used = LWIP_MIN(space, LWIP_MIN(oversize, len));
 800fa5e:	231e      	movs	r3, #30
 800fa60:	18fb      	adds	r3, r7, r3
 800fa62:	881a      	ldrh	r2, [r3, #0]
 800fa64:	1dbb      	adds	r3, r7, #6
 800fa66:	1c10      	adds	r0, r2, #0
 800fa68:	881b      	ldrh	r3, [r3, #0]
 800fa6a:	b299      	uxth	r1, r3
 800fa6c:	b282      	uxth	r2, r0
 800fa6e:	4291      	cmp	r1, r2
 800fa70:	d900      	bls.n	800fa74 <tcp_write+0x1f4>
 800fa72:	1c03      	adds	r3, r0, #0
 800fa74:	b299      	uxth	r1, r3
 800fa76:	2362      	movs	r3, #98	; 0x62
 800fa78:	18fa      	adds	r2, r7, r3
 800fa7a:	2344      	movs	r3, #68	; 0x44
 800fa7c:	18fb      	adds	r3, r7, r3
 800fa7e:	1c0c      	adds	r4, r1, #0
 800fa80:	881b      	ldrh	r3, [r3, #0]
 800fa82:	b298      	uxth	r0, r3
 800fa84:	b2a1      	uxth	r1, r4
 800fa86:	4288      	cmp	r0, r1
 800fa88:	d900      	bls.n	800fa8c <tcp_write+0x20c>
 800fa8a:	1c23      	adds	r3, r4, #0
 800fa8c:	8013      	strh	r3, [r2, #0]
      pos += oversize_used;
 800fa8e:	2252      	movs	r2, #82	; 0x52
 800fa90:	18bb      	adds	r3, r7, r2
 800fa92:	18b9      	adds	r1, r7, r2
 800fa94:	2062      	movs	r0, #98	; 0x62
 800fa96:	183a      	adds	r2, r7, r0
 800fa98:	8809      	ldrh	r1, [r1, #0]
 800fa9a:	8812      	ldrh	r2, [r2, #0]
 800fa9c:	188a      	adds	r2, r1, r2
 800fa9e:	801a      	strh	r2, [r3, #0]
      oversize -= oversize_used;
 800faa0:	211e      	movs	r1, #30
 800faa2:	187b      	adds	r3, r7, r1
 800faa4:	881a      	ldrh	r2, [r3, #0]
 800faa6:	183b      	adds	r3, r7, r0
 800faa8:	881b      	ldrh	r3, [r3, #0]
 800faaa:	1ad3      	subs	r3, r2, r3
 800faac:	b29a      	uxth	r2, r3
 800faae:	187b      	adds	r3, r7, r1
 800fab0:	801a      	strh	r2, [r3, #0]
      space -= oversize_used;
 800fab2:	2244      	movs	r2, #68	; 0x44
 800fab4:	18bb      	adds	r3, r7, r2
 800fab6:	18b9      	adds	r1, r7, r2
 800fab8:	183a      	adds	r2, r7, r0
 800faba:	8809      	ldrh	r1, [r1, #0]
 800fabc:	8812      	ldrh	r2, [r2, #0]
 800fabe:	1a8a      	subs	r2, r1, r2
 800fac0:	801a      	strh	r2, [r3, #0]
    }
    /* now we are either finished or oversize is zero */
    LWIP_ASSERT("inconsistent oversize vs. len", (oversize == 0) || (pos == len));
 800fac2:	231e      	movs	r3, #30
 800fac4:	18fb      	adds	r3, r7, r3
 800fac6:	881b      	ldrh	r3, [r3, #0]
 800fac8:	2b00      	cmp	r3, #0
 800faca:	d00d      	beq.n	800fae8 <tcp_write+0x268>
 800facc:	2352      	movs	r3, #82	; 0x52
 800face:	18fa      	adds	r2, r7, r3
 800fad0:	1dbb      	adds	r3, r7, #6
 800fad2:	8812      	ldrh	r2, [r2, #0]
 800fad4:	881b      	ldrh	r3, [r3, #0]
 800fad6:	429a      	cmp	r2, r3
 800fad8:	d006      	beq.n	800fae8 <tcp_write+0x268>
 800fada:	4b54      	ldr	r3, [pc, #336]	; (800fc2c <tcp_write+0x3ac>)
 800fadc:	2280      	movs	r2, #128	; 0x80
 800fade:	0092      	lsls	r2, r2, #2
 800fae0:	4957      	ldr	r1, [pc, #348]	; (800fc40 <tcp_write+0x3c0>)
 800fae2:	4854      	ldr	r0, [pc, #336]	; (800fc34 <tcp_write+0x3b4>)
 800fae4:	f7f2 fefa 	bl	80028dc <app_debug_rtt_raw>
     *
     * This phase is skipped for LWIP_NETIF_TX_SINGLE_PBUF as we could only execute
     * it after rexmit puts a segment from unacked to unsent and at this point,
     * oversize info is lost.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
 800fae8:	2152      	movs	r1, #82	; 0x52
 800faea:	187a      	adds	r2, r7, r1
 800faec:	1dbb      	adds	r3, r7, #6
 800faee:	8812      	ldrh	r2, [r2, #0]
 800faf0:	881b      	ldrh	r3, [r3, #0]
 800faf2:	429a      	cmp	r2, r3
 800faf4:	d300      	bcc.n	800faf8 <tcp_write+0x278>
 800faf6:	e23b      	b.n	800ff70 <tcp_write+0x6f0>
 800faf8:	2044      	movs	r0, #68	; 0x44
 800fafa:	183b      	adds	r3, r7, r0
 800fafc:	881b      	ldrh	r3, [r3, #0]
 800fafe:	2b00      	cmp	r3, #0
 800fb00:	d100      	bne.n	800fb04 <tcp_write+0x284>
 800fb02:	e235      	b.n	800ff70 <tcp_write+0x6f0>
 800fb04:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fb06:	891b      	ldrh	r3, [r3, #8]
 800fb08:	2b00      	cmp	r3, #0
 800fb0a:	d100      	bne.n	800fb0e <tcp_write+0x28e>
 800fb0c:	e230      	b.n	800ff70 <tcp_write+0x6f0>
      u16_t seglen = LWIP_MIN(space, len - pos);
 800fb0e:	1dbb      	adds	r3, r7, #6
 800fb10:	881a      	ldrh	r2, [r3, #0]
 800fb12:	187b      	adds	r3, r7, r1
 800fb14:	881b      	ldrh	r3, [r3, #0]
 800fb16:	1ad2      	subs	r2, r2, r3
 800fb18:	183b      	adds	r3, r7, r0
 800fb1a:	881b      	ldrh	r3, [r3, #0]
 800fb1c:	429a      	cmp	r2, r3
 800fb1e:	dd00      	ble.n	800fb22 <tcp_write+0x2a2>
 800fb20:	001a      	movs	r2, r3
 800fb22:	242a      	movs	r4, #42	; 0x2a
 800fb24:	193b      	adds	r3, r7, r4
 800fb26:	801a      	strh	r2, [r3, #0]
      seg = last_unsent;
 800fb28:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fb2a:	65fb      	str	r3, [r7, #92]	; 0x5c

      /* Create a pbuf with a copy or reference to seglen bytes. We
       * can use PBUF_RAW here since the data appears in the middle of
       * a segment. A header will never be prepended. */
      if (apiflags & TCP_WRITE_FLAG_COPY) {
 800fb2c:	1d7b      	adds	r3, r7, #5
 800fb2e:	781b      	ldrb	r3, [r3, #0]
 800fb30:	2201      	movs	r2, #1
 800fb32:	4013      	ands	r3, r2
 800fb34:	d04b      	beq.n	800fbce <tcp_write+0x34e>
        /* Data is copied */
        if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
 800fb36:	251e      	movs	r5, #30
 800fb38:	1978      	adds	r0, r7, r5
 800fb3a:	2344      	movs	r3, #68	; 0x44
 800fb3c:	18fb      	adds	r3, r7, r3
 800fb3e:	881a      	ldrh	r2, [r3, #0]
 800fb40:	193b      	adds	r3, r7, r4
 800fb42:	8819      	ldrh	r1, [r3, #0]
 800fb44:	2301      	movs	r3, #1
 800fb46:	9302      	str	r3, [sp, #8]
 800fb48:	1d7b      	adds	r3, r7, #5
 800fb4a:	781b      	ldrb	r3, [r3, #0]
 800fb4c:	9301      	str	r3, [sp, #4]
 800fb4e:	68fb      	ldr	r3, [r7, #12]
 800fb50:	9300      	str	r3, [sp, #0]
 800fb52:	0003      	movs	r3, r0
 800fb54:	2000      	movs	r0, #0
 800fb56:	f7ff fd3b 	bl	800f5d0 <tcp_pbuf_prealloc>
 800fb5a:	0003      	movs	r3, r0
 800fb5c:	64bb      	str	r3, [r7, #72]	; 0x48
 800fb5e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800fb60:	2b00      	cmp	r3, #0
 800fb62:	d101      	bne.n	800fb68 <tcp_write+0x2e8>
 800fb64:	f000 fb98 	bl	8010298 <tcp_write+0xa18>
                      ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n",
                       seglen));
          goto memerr;
        }
#if TCP_OVERSIZE_DBGCHECK
        oversize_add = oversize;
 800fb68:	2366      	movs	r3, #102	; 0x66
 800fb6a:	18fb      	adds	r3, r7, r3
 800fb6c:	197a      	adds	r2, r7, r5
 800fb6e:	8812      	ldrh	r2, [r2, #0]
 800fb70:	801a      	strh	r2, [r3, #0]
#endif /* TCP_OVERSIZE_DBGCHECK */
        TCP_DATA_COPY2(concat_p->payload, (const u8_t *)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
 800fb72:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800fb74:	6858      	ldr	r0, [r3, #4]
 800fb76:	2352      	movs	r3, #82	; 0x52
 800fb78:	18fb      	adds	r3, r7, r3
 800fb7a:	881b      	ldrh	r3, [r3, #0]
 800fb7c:	68ba      	ldr	r2, [r7, #8]
 800fb7e:	18d1      	adds	r1, r2, r3
 800fb80:	0025      	movs	r5, r4
 800fb82:	193b      	adds	r3, r7, r4
 800fb84:	881b      	ldrh	r3, [r3, #0]
 800fb86:	001a      	movs	r2, r3
 800fb88:	f7f8 fc69 	bl	800845e <lwip_chksum_copy>
 800fb8c:	0003      	movs	r3, r0
 800fb8e:	001c      	movs	r4, r3
 800fb90:	231b      	movs	r3, #27
 800fb92:	18f8      	adds	r0, r7, r3
 800fb94:	231c      	movs	r3, #28
 800fb96:	18fa      	adds	r2, r7, r3
 800fb98:	197b      	adds	r3, r7, r5
 800fb9a:	8819      	ldrh	r1, [r3, #0]
 800fb9c:	0003      	movs	r3, r0
 800fb9e:	0020      	movs	r0, r4
 800fba0:	f7ff fdb2 	bl	800f708 <tcp_seg_add_chksum>
#if TCP_CHECKSUM_ON_COPY
        concat_chksummed += seglen;
 800fba4:	2246      	movs	r2, #70	; 0x46
 800fba6:	18bb      	adds	r3, r7, r2
 800fba8:	18b9      	adds	r1, r7, r2
 800fbaa:	197a      	adds	r2, r7, r5
 800fbac:	8809      	ldrh	r1, [r1, #0]
 800fbae:	8812      	ldrh	r2, [r2, #0]
 800fbb0:	188a      	adds	r2, r1, r2
 800fbb2:	801a      	strh	r2, [r3, #0]
#endif /* TCP_CHECKSUM_ON_COPY */
        queuelen += pbuf_clen(concat_p);
 800fbb4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800fbb6:	0018      	movs	r0, r3
 800fbb8:	f7fa f8aa 	bl	8009d10 <pbuf_clen>
 800fbbc:	0003      	movs	r3, r0
 800fbbe:	0019      	movs	r1, r3
 800fbc0:	2250      	movs	r2, #80	; 0x50
 800fbc2:	18bb      	adds	r3, r7, r2
 800fbc4:	18ba      	adds	r2, r7, r2
 800fbc6:	8812      	ldrh	r2, [r2, #0]
 800fbc8:	188a      	adds	r2, r1, r2
 800fbca:	801a      	strh	r2, [r3, #0]
 800fbcc:	e07f      	b.n	800fcce <tcp_write+0x44e>
      } else {
        /* Data is not copied */
        /* If the last unsent pbuf is of type PBUF_ROM, try to extend it. */
        struct pbuf *p;
        for (p = last_unsent->p; p->next != NULL; p = p->next);
 800fbce:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fbd0:	685b      	ldr	r3, [r3, #4]
 800fbd2:	643b      	str	r3, [r7, #64]	; 0x40
 800fbd4:	e002      	b.n	800fbdc <tcp_write+0x35c>
 800fbd6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800fbd8:	681b      	ldr	r3, [r3, #0]
 800fbda:	643b      	str	r3, [r7, #64]	; 0x40
 800fbdc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800fbde:	681b      	ldr	r3, [r3, #0]
 800fbe0:	2b00      	cmp	r3, #0
 800fbe2:	d1f8      	bne.n	800fbd6 <tcp_write+0x356>
        if (((p->type_internal & (PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS | PBUF_TYPE_FLAG_DATA_VOLATILE)) == 0) &&
 800fbe4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800fbe6:	7b1b      	ldrb	r3, [r3, #12]
 800fbe8:	001a      	movs	r2, r3
 800fbea:	23c0      	movs	r3, #192	; 0xc0
 800fbec:	4013      	ands	r3, r2
 800fbee:	d12d      	bne.n	800fc4c <tcp_write+0x3cc>
            (const u8_t *)p->payload + p->len == (const u8_t *)arg) {
 800fbf0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800fbf2:	685b      	ldr	r3, [r3, #4]
 800fbf4:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800fbf6:	8952      	ldrh	r2, [r2, #10]
 800fbf8:	189b      	adds	r3, r3, r2
        if (((p->type_internal & (PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS | PBUF_TYPE_FLAG_DATA_VOLATILE)) == 0) &&
 800fbfa:	68ba      	ldr	r2, [r7, #8]
 800fbfc:	429a      	cmp	r2, r3
 800fbfe:	d125      	bne.n	800fc4c <tcp_write+0x3cc>
          LWIP_ASSERT("tcp_write: ROM pbufs cannot be oversized", pos == 0);
 800fc00:	2352      	movs	r3, #82	; 0x52
 800fc02:	18fb      	adds	r3, r7, r3
 800fc04:	881b      	ldrh	r3, [r3, #0]
 800fc06:	2b00      	cmp	r3, #0
 800fc08:	d005      	beq.n	800fc16 <tcp_write+0x396>
 800fc0a:	4b08      	ldr	r3, [pc, #32]	; (800fc2c <tcp_write+0x3ac>)
 800fc0c:	4a0d      	ldr	r2, [pc, #52]	; (800fc44 <tcp_write+0x3c4>)
 800fc0e:	490e      	ldr	r1, [pc, #56]	; (800fc48 <tcp_write+0x3c8>)
 800fc10:	4808      	ldr	r0, [pc, #32]	; (800fc34 <tcp_write+0x3b4>)
 800fc12:	f7f2 fe63 	bl	80028dc <app_debug_rtt_raw>
          extendlen = seglen;
 800fc16:	2364      	movs	r3, #100	; 0x64
 800fc18:	18fb      	adds	r3, r7, r3
 800fc1a:	222a      	movs	r2, #42	; 0x2a
 800fc1c:	18ba      	adds	r2, r7, r2
 800fc1e:	8812      	ldrh	r2, [r2, #0]
 800fc20:	801a      	strh	r2, [r3, #0]
 800fc22:	e034      	b.n	800fc8e <tcp_write+0x40e>
 800fc24:	08020828 	.word	0x08020828
 800fc28:	08020840 	.word	0x08020840
 800fc2c:	08020658 	.word	0x08020658
 800fc30:	08020874 	.word	0x08020874
 800fc34:	080206a4 	.word	0x080206a4
 800fc38:	0802088c 	.word	0x0802088c
 800fc3c:	080208bc 	.word	0x080208bc
 800fc40:	080208dc 	.word	0x080208dc
 800fc44:	00000231 	.word	0x00000231
 800fc48:	080208fc 	.word	0x080208fc
        } else {
          if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
 800fc4c:	232a      	movs	r3, #42	; 0x2a
 800fc4e:	18fb      	adds	r3, r7, r3
 800fc50:	881b      	ldrh	r3, [r3, #0]
 800fc52:	2201      	movs	r2, #1
 800fc54:	0019      	movs	r1, r3
 800fc56:	2000      	movs	r0, #0
 800fc58:	f7f9 fc42 	bl	80094e0 <pbuf_alloc>
 800fc5c:	0003      	movs	r3, r0
 800fc5e:	64bb      	str	r3, [r7, #72]	; 0x48
 800fc60:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800fc62:	2b00      	cmp	r3, #0
 800fc64:	d100      	bne.n	800fc68 <tcp_write+0x3e8>
 800fc66:	e319      	b.n	801029c <tcp_write+0xa1c>
            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                        ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
            goto memerr;
          }
          /* reference the non-volatile payload data */
          ((struct pbuf_rom *)concat_p)->payload = (const u8_t *)arg + pos;
 800fc68:	2352      	movs	r3, #82	; 0x52
 800fc6a:	18fb      	adds	r3, r7, r3
 800fc6c:	881b      	ldrh	r3, [r3, #0]
 800fc6e:	68ba      	ldr	r2, [r7, #8]
 800fc70:	18d2      	adds	r2, r2, r3
 800fc72:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800fc74:	605a      	str	r2, [r3, #4]
          queuelen += pbuf_clen(concat_p);
 800fc76:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800fc78:	0018      	movs	r0, r3
 800fc7a:	f7fa f849 	bl	8009d10 <pbuf_clen>
 800fc7e:	0003      	movs	r3, r0
 800fc80:	0019      	movs	r1, r3
 800fc82:	2250      	movs	r2, #80	; 0x50
 800fc84:	18bb      	adds	r3, r7, r2
 800fc86:	18ba      	adds	r2, r7, r2
 800fc88:	8812      	ldrh	r2, [r2, #0]
 800fc8a:	188a      	adds	r2, r1, r2
 800fc8c:	801a      	strh	r2, [r3, #0]
        }
#if TCP_CHECKSUM_ON_COPY
        /* calculate the checksum of nocopy-data */
        tcp_seg_add_chksum(~inet_chksum((const u8_t *)arg + pos, seglen), seglen,
 800fc8e:	2352      	movs	r3, #82	; 0x52
 800fc90:	18fb      	adds	r3, r7, r3
 800fc92:	881b      	ldrh	r3, [r3, #0]
 800fc94:	68ba      	ldr	r2, [r7, #8]
 800fc96:	18d2      	adds	r2, r2, r3
 800fc98:	252a      	movs	r5, #42	; 0x2a
 800fc9a:	197b      	adds	r3, r7, r5
 800fc9c:	881b      	ldrh	r3, [r3, #0]
 800fc9e:	0019      	movs	r1, r3
 800fca0:	0010      	movs	r0, r2
 800fca2:	f7f8 fb77 	bl	8008394 <inet_chksum>
 800fca6:	0003      	movs	r3, r0
 800fca8:	43db      	mvns	r3, r3
 800fcaa:	b298      	uxth	r0, r3
 800fcac:	231b      	movs	r3, #27
 800fcae:	18fc      	adds	r4, r7, r3
 800fcb0:	231c      	movs	r3, #28
 800fcb2:	18fa      	adds	r2, r7, r3
 800fcb4:	197b      	adds	r3, r7, r5
 800fcb6:	8819      	ldrh	r1, [r3, #0]
 800fcb8:	0023      	movs	r3, r4
 800fcba:	f7ff fd25 	bl	800f708 <tcp_seg_add_chksum>
                           &concat_chksum, &concat_chksum_swapped);
        concat_chksummed += seglen;
 800fcbe:	2246      	movs	r2, #70	; 0x46
 800fcc0:	18bb      	adds	r3, r7, r2
 800fcc2:	18b9      	adds	r1, r7, r2
 800fcc4:	197a      	adds	r2, r7, r5
 800fcc6:	8809      	ldrh	r1, [r1, #0]
 800fcc8:	8812      	ldrh	r2, [r2, #0]
 800fcca:	188a      	adds	r2, r1, r2
 800fccc:	801a      	strh	r2, [r3, #0]
#endif /* TCP_CHECKSUM_ON_COPY */
      }

      pos += seglen;
 800fcce:	2252      	movs	r2, #82	; 0x52
 800fcd0:	18bb      	adds	r3, r7, r2
 800fcd2:	18b9      	adds	r1, r7, r2
 800fcd4:	222a      	movs	r2, #42	; 0x2a
 800fcd6:	18ba      	adds	r2, r7, r2
 800fcd8:	8809      	ldrh	r1, [r1, #0]
 800fcda:	8812      	ldrh	r2, [r2, #0]
 800fcdc:	188a      	adds	r2, r1, r2
 800fcde:	801a      	strh	r2, [r3, #0]
 800fce0:	e146      	b.n	800ff70 <tcp_write+0x6f0>
    }
#endif /* !LWIP_NETIF_TX_SINGLE_PBUF */
  } else {
#if TCP_OVERSIZE
    LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
 800fce2:	68fb      	ldr	r3, [r7, #12]
 800fce4:	226c      	movs	r2, #108	; 0x6c
 800fce6:	5a9b      	ldrh	r3, [r3, r2]
 800fce8:	2b00      	cmp	r3, #0
 800fcea:	d100      	bne.n	800fcee <tcp_write+0x46e>
 800fcec:	e140      	b.n	800ff70 <tcp_write+0x6f0>
 800fcee:	4bb1      	ldr	r3, [pc, #708]	; (800ffb4 <tcp_write+0x734>)
 800fcf0:	4ab1      	ldr	r2, [pc, #708]	; (800ffb8 <tcp_write+0x738>)
 800fcf2:	49b2      	ldr	r1, [pc, #712]	; (800ffbc <tcp_write+0x73c>)
 800fcf4:	48b2      	ldr	r0, [pc, #712]	; (800ffc0 <tcp_write+0x740>)
 800fcf6:	f7f2 fdf1 	bl	80028dc <app_debug_rtt_raw>
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
 800fcfa:	e139      	b.n	800ff70 <tcp_write+0x6f0>
    struct pbuf *p;
    u16_t left = len - pos;
 800fcfc:	2028      	movs	r0, #40	; 0x28
 800fcfe:	183b      	adds	r3, r7, r0
 800fd00:	1db9      	adds	r1, r7, #6
 800fd02:	2252      	movs	r2, #82	; 0x52
 800fd04:	18ba      	adds	r2, r7, r2
 800fd06:	8809      	ldrh	r1, [r1, #0]
 800fd08:	8812      	ldrh	r2, [r2, #0]
 800fd0a:	1a8a      	subs	r2, r1, r2
 800fd0c:	801a      	strh	r2, [r3, #0]
    u16_t max_len = mss_local - optlen;
 800fd0e:	232e      	movs	r3, #46	; 0x2e
 800fd10:	18fb      	adds	r3, r7, r3
 800fd12:	781b      	ldrb	r3, [r3, #0]
 800fd14:	b29a      	uxth	r2, r3
 800fd16:	2426      	movs	r4, #38	; 0x26
 800fd18:	193b      	adds	r3, r7, r4
 800fd1a:	2130      	movs	r1, #48	; 0x30
 800fd1c:	1879      	adds	r1, r7, r1
 800fd1e:	8809      	ldrh	r1, [r1, #0]
 800fd20:	1a8a      	subs	r2, r1, r2
 800fd22:	801a      	strh	r2, [r3, #0]
    u16_t seglen = LWIP_MIN(left, max_len);
 800fd24:	2324      	movs	r3, #36	; 0x24
 800fd26:	18fa      	adds	r2, r7, r3
 800fd28:	193b      	adds	r3, r7, r4
 800fd2a:	1839      	adds	r1, r7, r0
 800fd2c:	880c      	ldrh	r4, [r1, #0]
 800fd2e:	881b      	ldrh	r3, [r3, #0]
 800fd30:	b298      	uxth	r0, r3
 800fd32:	b2a1      	uxth	r1, r4
 800fd34:	4288      	cmp	r0, r1
 800fd36:	d900      	bls.n	800fd3a <tcp_write+0x4ba>
 800fd38:	1c23      	adds	r3, r4, #0
 800fd3a:	8013      	strh	r3, [r2, #0]
#if TCP_CHECKSUM_ON_COPY
    u16_t chksum = 0;
 800fd3c:	2318      	movs	r3, #24
 800fd3e:	18fb      	adds	r3, r7, r3
 800fd40:	2200      	movs	r2, #0
 800fd42:	801a      	strh	r2, [r3, #0]
    u8_t chksum_swapped = 0;
 800fd44:	2317      	movs	r3, #23
 800fd46:	18fb      	adds	r3, r7, r3
 800fd48:	2200      	movs	r2, #0
 800fd4a:	701a      	strb	r2, [r3, #0]
#endif /* TCP_CHECKSUM_ON_COPY */

    if (apiflags & TCP_WRITE_FLAG_COPY) {
 800fd4c:	1d7b      	adds	r3, r7, #5
 800fd4e:	781b      	ldrb	r3, [r3, #0]
 800fd50:	2201      	movs	r2, #1
 800fd52:	4013      	ands	r3, r2
 800fd54:	d04c      	beq.n	800fdf0 <tcp_write+0x570>
      /* If copy is set, memory should be allocated and data copied
       * into pbuf */
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
 800fd56:	232e      	movs	r3, #46	; 0x2e
 800fd58:	18fb      	adds	r3, r7, r3
 800fd5a:	781b      	ldrb	r3, [r3, #0]
 800fd5c:	b29a      	uxth	r2, r3
 800fd5e:	2524      	movs	r5, #36	; 0x24
 800fd60:	197b      	adds	r3, r7, r5
 800fd62:	881b      	ldrh	r3, [r3, #0]
 800fd64:	18d3      	adds	r3, r2, r3
 800fd66:	b299      	uxth	r1, r3
 800fd68:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800fd6a:	425a      	negs	r2, r3
 800fd6c:	4153      	adcs	r3, r2
 800fd6e:	b2db      	uxtb	r3, r3
 800fd70:	001c      	movs	r4, r3
 800fd72:	231e      	movs	r3, #30
 800fd74:	18f8      	adds	r0, r7, r3
 800fd76:	2330      	movs	r3, #48	; 0x30
 800fd78:	18fb      	adds	r3, r7, r3
 800fd7a:	881a      	ldrh	r2, [r3, #0]
 800fd7c:	9402      	str	r4, [sp, #8]
 800fd7e:	1d7b      	adds	r3, r7, #5
 800fd80:	781b      	ldrb	r3, [r3, #0]
 800fd82:	9301      	str	r3, [sp, #4]
 800fd84:	68fb      	ldr	r3, [r7, #12]
 800fd86:	9300      	str	r3, [sp, #0]
 800fd88:	0003      	movs	r3, r0
 800fd8a:	2038      	movs	r0, #56	; 0x38
 800fd8c:	f7ff fc20 	bl	800f5d0 <tcp_pbuf_prealloc>
 800fd90:	0003      	movs	r3, r0
 800fd92:	63fb      	str	r3, [r7, #60]	; 0x3c
 800fd94:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800fd96:	2b00      	cmp	r3, #0
 800fd98:	d100      	bne.n	800fd9c <tcp_write+0x51c>
 800fd9a:	e281      	b.n	80102a0 <tcp_write+0xa20>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
 800fd9c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800fd9e:	895b      	ldrh	r3, [r3, #10]
 800fda0:	197a      	adds	r2, r7, r5
 800fda2:	8812      	ldrh	r2, [r2, #0]
 800fda4:	429a      	cmp	r2, r3
 800fda6:	d905      	bls.n	800fdb4 <tcp_write+0x534>
 800fda8:	4b82      	ldr	r3, [pc, #520]	; (800ffb4 <tcp_write+0x734>)
 800fdaa:	4a86      	ldr	r2, [pc, #536]	; (800ffc4 <tcp_write+0x744>)
 800fdac:	4986      	ldr	r1, [pc, #536]	; (800ffc8 <tcp_write+0x748>)
 800fdae:	4884      	ldr	r0, [pc, #528]	; (800ffc0 <tcp_write+0x740>)
 800fdb0:	f7f2 fd94 	bl	80028dc <app_debug_rtt_raw>
                  (p->len >= seglen));
      TCP_DATA_COPY2((char *)p->payload + optlen, (const u8_t *)arg + pos, seglen, &chksum, &chksum_swapped);
 800fdb4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800fdb6:	685a      	ldr	r2, [r3, #4]
 800fdb8:	232e      	movs	r3, #46	; 0x2e
 800fdba:	18fb      	adds	r3, r7, r3
 800fdbc:	781b      	ldrb	r3, [r3, #0]
 800fdbe:	18d0      	adds	r0, r2, r3
 800fdc0:	2352      	movs	r3, #82	; 0x52
 800fdc2:	18fb      	adds	r3, r7, r3
 800fdc4:	881b      	ldrh	r3, [r3, #0]
 800fdc6:	68ba      	ldr	r2, [r7, #8]
 800fdc8:	18d1      	adds	r1, r2, r3
 800fdca:	2524      	movs	r5, #36	; 0x24
 800fdcc:	197b      	adds	r3, r7, r5
 800fdce:	881b      	ldrh	r3, [r3, #0]
 800fdd0:	001a      	movs	r2, r3
 800fdd2:	f7f8 fb44 	bl	800845e <lwip_chksum_copy>
 800fdd6:	0003      	movs	r3, r0
 800fdd8:	001c      	movs	r4, r3
 800fdda:	2317      	movs	r3, #23
 800fddc:	18f8      	adds	r0, r7, r3
 800fdde:	2318      	movs	r3, #24
 800fde0:	18fa      	adds	r2, r7, r3
 800fde2:	197b      	adds	r3, r7, r5
 800fde4:	8819      	ldrh	r1, [r3, #0]
 800fde6:	0003      	movs	r3, r0
 800fde8:	0020      	movs	r0, r4
 800fdea:	f7ff fc8d 	bl	800f708 <tcp_seg_add_chksum>
 800fdee:	e061      	b.n	800feb4 <tcp_write+0x634>
       * sent out on the link (as it has to be ACKed by the remote
       * party) we can safely use PBUF_ROM instead of PBUF_REF here.
       */
      struct pbuf *p2;
#if TCP_OVERSIZE
      LWIP_ASSERT("oversize == 0", oversize == 0);
 800fdf0:	231e      	movs	r3, #30
 800fdf2:	18fb      	adds	r3, r7, r3
 800fdf4:	881b      	ldrh	r3, [r3, #0]
 800fdf6:	2b00      	cmp	r3, #0
 800fdf8:	d005      	beq.n	800fe06 <tcp_write+0x586>
 800fdfa:	4b6e      	ldr	r3, [pc, #440]	; (800ffb4 <tcp_write+0x734>)
 800fdfc:	4a73      	ldr	r2, [pc, #460]	; (800ffcc <tcp_write+0x74c>)
 800fdfe:	4974      	ldr	r1, [pc, #464]	; (800ffd0 <tcp_write+0x750>)
 800fe00:	486f      	ldr	r0, [pc, #444]	; (800ffc0 <tcp_write+0x740>)
 800fe02:	f7f2 fd6b 	bl	80028dc <app_debug_rtt_raw>
#endif /* TCP_OVERSIZE */
      if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
 800fe06:	2424      	movs	r4, #36	; 0x24
 800fe08:	193b      	adds	r3, r7, r4
 800fe0a:	881b      	ldrh	r3, [r3, #0]
 800fe0c:	2201      	movs	r2, #1
 800fe0e:	0019      	movs	r1, r3
 800fe10:	2038      	movs	r0, #56	; 0x38
 800fe12:	f7f9 fb65 	bl	80094e0 <pbuf_alloc>
 800fe16:	0003      	movs	r3, r0
 800fe18:	623b      	str	r3, [r7, #32]
 800fe1a:	6a3b      	ldr	r3, [r7, #32]
 800fe1c:	2b00      	cmp	r3, #0
 800fe1e:	d100      	bne.n	800fe22 <tcp_write+0x5a2>
 800fe20:	e240      	b.n	80102a4 <tcp_write+0xa24>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
#if TCP_CHECKSUM_ON_COPY
      /* calculate the checksum of nocopy-data */
      chksum = ~inet_chksum((const u8_t *)arg + pos, seglen);
 800fe22:	2352      	movs	r3, #82	; 0x52
 800fe24:	18fb      	adds	r3, r7, r3
 800fe26:	881b      	ldrh	r3, [r3, #0]
 800fe28:	68ba      	ldr	r2, [r7, #8]
 800fe2a:	18d2      	adds	r2, r2, r3
 800fe2c:	193b      	adds	r3, r7, r4
 800fe2e:	881b      	ldrh	r3, [r3, #0]
 800fe30:	0019      	movs	r1, r3
 800fe32:	0010      	movs	r0, r2
 800fe34:	f7f8 faae 	bl	8008394 <inet_chksum>
 800fe38:	0003      	movs	r3, r0
 800fe3a:	43db      	mvns	r3, r3
 800fe3c:	b29a      	uxth	r2, r3
 800fe3e:	2118      	movs	r1, #24
 800fe40:	187b      	adds	r3, r7, r1
 800fe42:	801a      	strh	r2, [r3, #0]
      if (seglen & 1) {
 800fe44:	193b      	adds	r3, r7, r4
 800fe46:	881b      	ldrh	r3, [r3, #0]
 800fe48:	2201      	movs	r2, #1
 800fe4a:	4013      	ands	r3, r2
 800fe4c:	d011      	beq.n	800fe72 <tcp_write+0x5f2>
        chksum_swapped = 1;
 800fe4e:	2317      	movs	r3, #23
 800fe50:	18fb      	adds	r3, r7, r3
 800fe52:	2201      	movs	r2, #1
 800fe54:	701a      	strb	r2, [r3, #0]
        chksum = SWAP_BYTES_IN_WORD(chksum);
 800fe56:	187b      	adds	r3, r7, r1
 800fe58:	881b      	ldrh	r3, [r3, #0]
 800fe5a:	021b      	lsls	r3, r3, #8
 800fe5c:	b21a      	sxth	r2, r3
 800fe5e:	187b      	adds	r3, r7, r1
 800fe60:	881b      	ldrh	r3, [r3, #0]
 800fe62:	0a1b      	lsrs	r3, r3, #8
 800fe64:	b29b      	uxth	r3, r3
 800fe66:	b21b      	sxth	r3, r3
 800fe68:	4313      	orrs	r3, r2
 800fe6a:	b21b      	sxth	r3, r3
 800fe6c:	b29a      	uxth	r2, r3
 800fe6e:	187b      	adds	r3, r7, r1
 800fe70:	801a      	strh	r2, [r3, #0]
      }
#endif /* TCP_CHECKSUM_ON_COPY */
      /* reference the non-volatile payload data */
      ((struct pbuf_rom *)p2)->payload = (const u8_t *)arg + pos;
 800fe72:	2352      	movs	r3, #82	; 0x52
 800fe74:	18fb      	adds	r3, r7, r3
 800fe76:	881b      	ldrh	r3, [r3, #0]
 800fe78:	68ba      	ldr	r2, [r7, #8]
 800fe7a:	18d2      	adds	r2, r2, r3
 800fe7c:	6a3b      	ldr	r3, [r7, #32]
 800fe7e:	605a      	str	r2, [r3, #4]

      /* Second, allocate a pbuf for the headers. */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 800fe80:	232e      	movs	r3, #46	; 0x2e
 800fe82:	18fb      	adds	r3, r7, r3
 800fe84:	781b      	ldrb	r3, [r3, #0]
 800fe86:	b29b      	uxth	r3, r3
 800fe88:	22a0      	movs	r2, #160	; 0xa0
 800fe8a:	0092      	lsls	r2, r2, #2
 800fe8c:	0019      	movs	r1, r3
 800fe8e:	2038      	movs	r0, #56	; 0x38
 800fe90:	f7f9 fb26 	bl	80094e0 <pbuf_alloc>
 800fe94:	0003      	movs	r3, r0
 800fe96:	63fb      	str	r3, [r7, #60]	; 0x3c
 800fe98:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800fe9a:	2b00      	cmp	r3, #0
 800fe9c:	d104      	bne.n	800fea8 <tcp_write+0x628>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p2);
 800fe9e:	6a3b      	ldr	r3, [r7, #32]
 800fea0:	0018      	movs	r0, r3
 800fea2:	f7f9 fe95 	bl	8009bd0 <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: could not allocate memory for header pbuf\n"));
        goto memerr;
 800fea6:	e200      	b.n	80102aa <tcp_write+0xa2a>
      }
      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(p/*header*/, p2/*data*/);
 800fea8:	6a3a      	ldr	r2, [r7, #32]
 800feaa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800feac:	0011      	movs	r1, r2
 800feae:	0018      	movs	r0, r3
 800feb0:	f7f9 ff6e 	bl	8009d90 <pbuf_cat>
    }

    queuelen += pbuf_clen(p);
 800feb4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800feb6:	0018      	movs	r0, r3
 800feb8:	f7f9 ff2a 	bl	8009d10 <pbuf_clen>
 800febc:	0003      	movs	r3, r0
 800febe:	0019      	movs	r1, r3
 800fec0:	2050      	movs	r0, #80	; 0x50
 800fec2:	183b      	adds	r3, r7, r0
 800fec4:	183a      	adds	r2, r7, r0
 800fec6:	8812      	ldrh	r2, [r2, #0]
 800fec8:	188a      	adds	r2, r1, r2
 800feca:	801a      	strh	r2, [r3, #0]

    /* Now that there are more segments queued, we check again if the
     * length of the queue exceeds the configured maximum or
     * overflows. */
    if (queuelen > LWIP_MIN(TCP_SND_QUEUELEN, TCP_SNDQUEUELEN_OVERFLOW)) {
 800fecc:	183b      	adds	r3, r7, r0
 800fece:	881b      	ldrh	r3, [r3, #0]
 800fed0:	2b08      	cmp	r3, #8
 800fed2:	d904      	bls.n	800fede <tcp_write+0x65e>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: queue too long %"U16_F" (%d)\n",
                  queuelen, (int)TCP_SND_QUEUELEN));
      pbuf_free(p);
 800fed4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800fed6:	0018      	movs	r0, r3
 800fed8:	f7f9 fe7a 	bl	8009bd0 <pbuf_free>
      goto memerr;
 800fedc:	e1e5      	b.n	80102aa <tcp_write+0xa2a>
    }

    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
 800fede:	68fb      	ldr	r3, [r7, #12]
 800fee0:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800fee2:	2352      	movs	r3, #82	; 0x52
 800fee4:	18fb      	adds	r3, r7, r3
 800fee6:	881b      	ldrh	r3, [r3, #0]
 800fee8:	18d2      	adds	r2, r2, r3
 800feea:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 800feec:	68f8      	ldr	r0, [r7, #12]
 800feee:	2333      	movs	r3, #51	; 0x33
 800fef0:	18fb      	adds	r3, r7, r3
 800fef2:	781b      	ldrb	r3, [r3, #0]
 800fef4:	9300      	str	r3, [sp, #0]
 800fef6:	0013      	movs	r3, r2
 800fef8:	2200      	movs	r2, #0
 800fefa:	f7ff fa45 	bl	800f388 <tcp_create_segment>
 800fefe:	0003      	movs	r3, r0
 800ff00:	65fb      	str	r3, [r7, #92]	; 0x5c
 800ff02:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800ff04:	2b00      	cmp	r3, #0
 800ff06:	d100      	bne.n	800ff0a <tcp_write+0x68a>
 800ff08:	e1ce      	b.n	80102a8 <tcp_write+0xa28>
      goto memerr;
    }
#if TCP_OVERSIZE_DBGCHECK
    seg->oversize_left = oversize;
 800ff0a:	231e      	movs	r3, #30
 800ff0c:	18fb      	adds	r3, r7, r3
 800ff0e:	881a      	ldrh	r2, [r3, #0]
 800ff10:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800ff12:	815a      	strh	r2, [r3, #10]
#endif /* TCP_OVERSIZE_DBGCHECK */
#if TCP_CHECKSUM_ON_COPY
    seg->chksum = chksum;
 800ff14:	2318      	movs	r3, #24
 800ff16:	18fb      	adds	r3, r7, r3
 800ff18:	881a      	ldrh	r2, [r3, #0]
 800ff1a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800ff1c:	819a      	strh	r2, [r3, #12]
    seg->chksum_swapped = chksum_swapped;
 800ff1e:	2317      	movs	r3, #23
 800ff20:	18fb      	adds	r3, r7, r3
 800ff22:	781a      	ldrb	r2, [r3, #0]
 800ff24:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800ff26:	739a      	strb	r2, [r3, #14]
    seg->flags |= TF_SEG_DATA_CHECKSUMMED;
 800ff28:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800ff2a:	7bdb      	ldrb	r3, [r3, #15]
 800ff2c:	2204      	movs	r2, #4
 800ff2e:	4313      	orrs	r3, r2
 800ff30:	b2da      	uxtb	r2, r3
 800ff32:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800ff34:	73da      	strb	r2, [r3, #15]
#endif /* TCP_CHECKSUM_ON_COPY */

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
 800ff36:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ff38:	2b00      	cmp	r3, #0
 800ff3a:	d102      	bne.n	800ff42 <tcp_write+0x6c2>
      queue = seg;
 800ff3c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800ff3e:	657b      	str	r3, [r7, #84]	; 0x54
 800ff40:	e00b      	b.n	800ff5a <tcp_write+0x6da>
    } else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
 800ff42:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800ff44:	2b00      	cmp	r3, #0
 800ff46:	d105      	bne.n	800ff54 <tcp_write+0x6d4>
 800ff48:	4b1a      	ldr	r3, [pc, #104]	; (800ffb4 <tcp_write+0x734>)
 800ff4a:	4a22      	ldr	r2, [pc, #136]	; (800ffd4 <tcp_write+0x754>)
 800ff4c:	4922      	ldr	r1, [pc, #136]	; (800ffd8 <tcp_write+0x758>)
 800ff4e:	481c      	ldr	r0, [pc, #112]	; (800ffc0 <tcp_write+0x740>)
 800ff50:	f7f2 fcc4 	bl	80028dc <app_debug_rtt_raw>
      prev_seg->next = seg;
 800ff54:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800ff56:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800ff58:	601a      	str	r2, [r3, #0]
    }
    /* remember last segment of to-be-queued data for next iteration */
    prev_seg = seg;
 800ff5a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800ff5c:	65bb      	str	r3, [r7, #88]	; 0x58

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
                lwip_ntohl(seg->tcphdr->seqno),
                lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));

    pos += seglen;
 800ff5e:	2252      	movs	r2, #82	; 0x52
 800ff60:	18bb      	adds	r3, r7, r2
 800ff62:	18b9      	adds	r1, r7, r2
 800ff64:	2224      	movs	r2, #36	; 0x24
 800ff66:	18ba      	adds	r2, r7, r2
 800ff68:	8809      	ldrh	r1, [r1, #0]
 800ff6a:	8812      	ldrh	r2, [r2, #0]
 800ff6c:	188a      	adds	r2, r1, r2
 800ff6e:	801a      	strh	r2, [r3, #0]
  while (pos < len) {
 800ff70:	2352      	movs	r3, #82	; 0x52
 800ff72:	18fa      	adds	r2, r7, r3
 800ff74:	1dbb      	adds	r3, r7, #6
 800ff76:	8812      	ldrh	r2, [r2, #0]
 800ff78:	881b      	ldrh	r3, [r3, #0]
 800ff7a:	429a      	cmp	r2, r3
 800ff7c:	d200      	bcs.n	800ff80 <tcp_write+0x700>
 800ff7e:	e6bd      	b.n	800fcfc <tcp_write+0x47c>
  /*
   * All three segmentation phases were successful. We can commit the
   * transaction.
   */
#if TCP_OVERSIZE_DBGCHECK
  if ((last_unsent != NULL) && (oversize_add != 0)) {
 800ff80:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ff82:	2b00      	cmp	r3, #0
 800ff84:	d00c      	beq.n	800ffa0 <tcp_write+0x720>
 800ff86:	2166      	movs	r1, #102	; 0x66
 800ff88:	187b      	adds	r3, r7, r1
 800ff8a:	881b      	ldrh	r3, [r3, #0]
 800ff8c:	2b00      	cmp	r3, #0
 800ff8e:	d007      	beq.n	800ffa0 <tcp_write+0x720>
    last_unsent->oversize_left += oversize_add;
 800ff90:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ff92:	895a      	ldrh	r2, [r3, #10]
 800ff94:	187b      	adds	r3, r7, r1
 800ff96:	881b      	ldrh	r3, [r3, #0]
 800ff98:	18d3      	adds	r3, r2, r3
 800ff9a:	b29a      	uxth	r2, r3
 800ff9c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ff9e:	815a      	strh	r2, [r3, #10]
  /*
   * Phase 1: If data has been added to the preallocated tail of
   * last_unsent, we update the length fields of the pbuf chain.
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
 800ffa0:	2362      	movs	r3, #98	; 0x62
 800ffa2:	18fb      	adds	r3, r7, r3
 800ffa4:	881b      	ldrh	r3, [r3, #0]
 800ffa6:	2b00      	cmp	r3, #0
 800ffa8:	d100      	bne.n	800ffac <tcp_write+0x72c>
 800ffaa:	e071      	b.n	8010090 <tcp_write+0x810>
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
 800ffac:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ffae:	685b      	ldr	r3, [r3, #4]
 800ffb0:	63bb      	str	r3, [r7, #56]	; 0x38
 800ffb2:	e04c      	b.n	801004e <tcp_write+0x7ce>
 800ffb4:	08020658 	.word	0x08020658
 800ffb8:	0000024a 	.word	0x0000024a
 800ffbc:	08020928 	.word	0x08020928
 800ffc0:	080206a4 	.word	0x080206a4
 800ffc4:	00000266 	.word	0x00000266
 800ffc8:	08020958 	.word	0x08020958
 800ffcc:	00000271 	.word	0x00000271
 800ffd0:	08020998 	.word	0x08020998
 800ffd4:	000002ab 	.word	0x000002ab
 800ffd8:	080209a8 	.word	0x080209a8
      p->tot_len += oversize_used;
 800ffdc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ffde:	891a      	ldrh	r2, [r3, #8]
 800ffe0:	2162      	movs	r1, #98	; 0x62
 800ffe2:	187b      	adds	r3, r7, r1
 800ffe4:	881b      	ldrh	r3, [r3, #0]
 800ffe6:	18d3      	adds	r3, r2, r3
 800ffe8:	b29a      	uxth	r2, r3
 800ffea:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ffec:	811a      	strh	r2, [r3, #8]
      if (p->next == NULL) {
 800ffee:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800fff0:	681b      	ldr	r3, [r3, #0]
 800fff2:	2b00      	cmp	r3, #0
 800fff4:	d128      	bne.n	8010048 <tcp_write+0x7c8>
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
 800fff6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800fff8:	685b      	ldr	r3, [r3, #4]
 800fffa:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800fffc:	8952      	ldrh	r2, [r2, #10]
 800fffe:	1898      	adds	r0, r3, r2
 8010000:	000d      	movs	r5, r1
 8010002:	197b      	adds	r3, r7, r5
 8010004:	881a      	ldrh	r2, [r3, #0]
 8010006:	68bb      	ldr	r3, [r7, #8]
 8010008:	0019      	movs	r1, r3
 801000a:	f7f8 fa28 	bl	800845e <lwip_chksum_copy>
 801000e:	0003      	movs	r3, r0
 8010010:	001c      	movs	r4, r3
 8010012:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010014:	330c      	adds	r3, #12
 8010016:	001a      	movs	r2, r3
 8010018:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801001a:	330e      	adds	r3, #14
 801001c:	0018      	movs	r0, r3
 801001e:	197b      	adds	r3, r7, r5
 8010020:	8819      	ldrh	r1, [r3, #0]
 8010022:	0003      	movs	r3, r0
 8010024:	0020      	movs	r0, r4
 8010026:	f7ff fb6f 	bl	800f708 <tcp_seg_add_chksum>
 801002a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801002c:	7bdb      	ldrb	r3, [r3, #15]
 801002e:	2204      	movs	r2, #4
 8010030:	4313      	orrs	r3, r2
 8010032:	b2da      	uxtb	r2, r3
 8010034:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010036:	73da      	strb	r2, [r3, #15]
        p->len += oversize_used;
 8010038:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801003a:	895a      	ldrh	r2, [r3, #10]
 801003c:	197b      	adds	r3, r7, r5
 801003e:	881b      	ldrh	r3, [r3, #0]
 8010040:	18d3      	adds	r3, r2, r3
 8010042:	b29a      	uxth	r2, r3
 8010044:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010046:	815a      	strh	r2, [r3, #10]
    for (p = last_unsent->p; p; p = p->next) {
 8010048:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801004a:	681b      	ldr	r3, [r3, #0]
 801004c:	63bb      	str	r3, [r7, #56]	; 0x38
 801004e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010050:	2b00      	cmp	r3, #0
 8010052:	d1c3      	bne.n	800ffdc <tcp_write+0x75c>
      }
    }
    last_unsent->len += oversize_used;
 8010054:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010056:	891a      	ldrh	r2, [r3, #8]
 8010058:	2162      	movs	r1, #98	; 0x62
 801005a:	187b      	adds	r3, r7, r1
 801005c:	881b      	ldrh	r3, [r3, #0]
 801005e:	18d3      	adds	r3, r2, r3
 8010060:	b29a      	uxth	r2, r3
 8010062:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010064:	811a      	strh	r2, [r3, #8]
#if TCP_OVERSIZE_DBGCHECK
    LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
 8010066:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010068:	895b      	ldrh	r3, [r3, #10]
 801006a:	187a      	adds	r2, r7, r1
 801006c:	8812      	ldrh	r2, [r2, #0]
 801006e:	429a      	cmp	r2, r3
 8010070:	d905      	bls.n	801007e <tcp_write+0x7fe>
 8010072:	4ba5      	ldr	r3, [pc, #660]	; (8010308 <tcp_write+0xa88>)
 8010074:	4aa5      	ldr	r2, [pc, #660]	; (801030c <tcp_write+0xa8c>)
 8010076:	49a6      	ldr	r1, [pc, #664]	; (8010310 <tcp_write+0xa90>)
 8010078:	48a6      	ldr	r0, [pc, #664]	; (8010314 <tcp_write+0xa94>)
 801007a:	f7f2 fc2f 	bl	80028dc <app_debug_rtt_raw>
                last_unsent->oversize_left >= oversize_used);
    last_unsent->oversize_left -= oversize_used;
 801007e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010080:	895a      	ldrh	r2, [r3, #10]
 8010082:	2362      	movs	r3, #98	; 0x62
 8010084:	18fb      	adds	r3, r7, r3
 8010086:	881b      	ldrh	r3, [r3, #0]
 8010088:	1ad3      	subs	r3, r2, r3
 801008a:	b29a      	uxth	r2, r3
 801008c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801008e:	815a      	strh	r2, [r3, #10]
#endif /* TCP_OVERSIZE_DBGCHECK */
  }
  pcb->unsent_oversize = oversize;
 8010090:	231e      	movs	r3, #30
 8010092:	18fb      	adds	r3, r7, r3
 8010094:	8819      	ldrh	r1, [r3, #0]
 8010096:	68fb      	ldr	r3, [r7, #12]
 8010098:	226c      	movs	r2, #108	; 0x6c
 801009a:	5299      	strh	r1, [r3, r2]

  /*
   * Phase 2: concat_p can be concatenated onto last_unsent->p, unless we
   * determined that the last ROM pbuf can be extended to include the new data.
   */
  if (concat_p != NULL) {
 801009c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801009e:	2b00      	cmp	r3, #0
 80100a0:	d019      	beq.n	80100d6 <tcp_write+0x856>
    LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
 80100a2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80100a4:	2b00      	cmp	r3, #0
 80100a6:	d106      	bne.n	80100b6 <tcp_write+0x836>
 80100a8:	4b97      	ldr	r3, [pc, #604]	; (8010308 <tcp_write+0xa88>)
 80100aa:	22b8      	movs	r2, #184	; 0xb8
 80100ac:	0092      	lsls	r2, r2, #2
 80100ae:	499a      	ldr	r1, [pc, #616]	; (8010318 <tcp_write+0xa98>)
 80100b0:	4898      	ldr	r0, [pc, #608]	; (8010314 <tcp_write+0xa94>)
 80100b2:	f7f2 fc13 	bl	80028dc <app_debug_rtt_raw>
                (last_unsent != NULL));
    pbuf_cat(last_unsent->p, concat_p);
 80100b6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80100b8:	685b      	ldr	r3, [r3, #4]
 80100ba:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80100bc:	0011      	movs	r1, r2
 80100be:	0018      	movs	r0, r3
 80100c0:	f7f9 fe66 	bl	8009d90 <pbuf_cat>
    last_unsent->len += concat_p->tot_len;
 80100c4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80100c6:	891a      	ldrh	r2, [r3, #8]
 80100c8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80100ca:	891b      	ldrh	r3, [r3, #8]
 80100cc:	18d3      	adds	r3, r2, r3
 80100ce:	b29a      	uxth	r2, r3
 80100d0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80100d2:	811a      	strh	r2, [r3, #8]
 80100d4:	e03e      	b.n	8010154 <tcp_write+0x8d4>
  } else if (extendlen > 0) {
 80100d6:	2364      	movs	r3, #100	; 0x64
 80100d8:	18fb      	adds	r3, r7, r3
 80100da:	881b      	ldrh	r3, [r3, #0]
 80100dc:	2b00      	cmp	r3, #0
 80100de:	d039      	beq.n	8010154 <tcp_write+0x8d4>
    struct pbuf *p;
    LWIP_ASSERT("tcp_write: extension of reference requires reference",
 80100e0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80100e2:	2b00      	cmp	r3, #0
 80100e4:	d003      	beq.n	80100ee <tcp_write+0x86e>
 80100e6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80100e8:	685b      	ldr	r3, [r3, #4]
 80100ea:	2b00      	cmp	r3, #0
 80100ec:	d105      	bne.n	80100fa <tcp_write+0x87a>
 80100ee:	4b86      	ldr	r3, [pc, #536]	; (8010308 <tcp_write+0xa88>)
 80100f0:	4a8a      	ldr	r2, [pc, #552]	; (801031c <tcp_write+0xa9c>)
 80100f2:	498b      	ldr	r1, [pc, #556]	; (8010320 <tcp_write+0xaa0>)
 80100f4:	4887      	ldr	r0, [pc, #540]	; (8010314 <tcp_write+0xa94>)
 80100f6:	f7f2 fbf1 	bl	80028dc <app_debug_rtt_raw>
                last_unsent != NULL && last_unsent->p != NULL);
    for (p = last_unsent->p; p->next != NULL; p = p->next) {
 80100fa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80100fc:	685b      	ldr	r3, [r3, #4]
 80100fe:	637b      	str	r3, [r7, #52]	; 0x34
 8010100:	e00b      	b.n	801011a <tcp_write+0x89a>
      p->tot_len += extendlen;
 8010102:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010104:	891a      	ldrh	r2, [r3, #8]
 8010106:	2364      	movs	r3, #100	; 0x64
 8010108:	18fb      	adds	r3, r7, r3
 801010a:	881b      	ldrh	r3, [r3, #0]
 801010c:	18d3      	adds	r3, r2, r3
 801010e:	b29a      	uxth	r2, r3
 8010110:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010112:	811a      	strh	r2, [r3, #8]
    for (p = last_unsent->p; p->next != NULL; p = p->next) {
 8010114:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010116:	681b      	ldr	r3, [r3, #0]
 8010118:	637b      	str	r3, [r7, #52]	; 0x34
 801011a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801011c:	681b      	ldr	r3, [r3, #0]
 801011e:	2b00      	cmp	r3, #0
 8010120:	d1ef      	bne.n	8010102 <tcp_write+0x882>
    }
    p->tot_len += extendlen;
 8010122:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010124:	891a      	ldrh	r2, [r3, #8]
 8010126:	2164      	movs	r1, #100	; 0x64
 8010128:	187b      	adds	r3, r7, r1
 801012a:	881b      	ldrh	r3, [r3, #0]
 801012c:	18d3      	adds	r3, r2, r3
 801012e:	b29a      	uxth	r2, r3
 8010130:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010132:	811a      	strh	r2, [r3, #8]
    p->len += extendlen;
 8010134:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010136:	895a      	ldrh	r2, [r3, #10]
 8010138:	187b      	adds	r3, r7, r1
 801013a:	881b      	ldrh	r3, [r3, #0]
 801013c:	18d3      	adds	r3, r2, r3
 801013e:	b29a      	uxth	r2, r3
 8010140:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010142:	815a      	strh	r2, [r3, #10]
    last_unsent->len += extendlen;
 8010144:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010146:	891a      	ldrh	r2, [r3, #8]
 8010148:	187b      	adds	r3, r7, r1
 801014a:	881b      	ldrh	r3, [r3, #0]
 801014c:	18d3      	adds	r3, r2, r3
 801014e:	b29a      	uxth	r2, r3
 8010150:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010152:	811a      	strh	r2, [r3, #8]
  }

#if TCP_CHECKSUM_ON_COPY
  if (concat_chksummed) {
 8010154:	2346      	movs	r3, #70	; 0x46
 8010156:	18fb      	adds	r3, r7, r3
 8010158:	881b      	ldrh	r3, [r3, #0]
 801015a:	2b00      	cmp	r3, #0
 801015c:	d037      	beq.n	80101ce <tcp_write+0x94e>
    LWIP_ASSERT("tcp_write: concat checksum needs concatenated data",
 801015e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010160:	2b00      	cmp	r3, #0
 8010162:	d10a      	bne.n	801017a <tcp_write+0x8fa>
 8010164:	2364      	movs	r3, #100	; 0x64
 8010166:	18fb      	adds	r3, r7, r3
 8010168:	881b      	ldrh	r3, [r3, #0]
 801016a:	2b00      	cmp	r3, #0
 801016c:	d105      	bne.n	801017a <tcp_write+0x8fa>
 801016e:	4b66      	ldr	r3, [pc, #408]	; (8010308 <tcp_write+0xa88>)
 8010170:	4a6c      	ldr	r2, [pc, #432]	; (8010324 <tcp_write+0xaa4>)
 8010172:	496d      	ldr	r1, [pc, #436]	; (8010328 <tcp_write+0xaa8>)
 8010174:	4867      	ldr	r0, [pc, #412]	; (8010314 <tcp_write+0xa94>)
 8010176:	f7f2 fbb1 	bl	80028dc <app_debug_rtt_raw>
                concat_p != NULL || extendlen > 0);
    /*if concat checksumm swapped - swap it back */
    if (concat_chksum_swapped) {
 801017a:	231b      	movs	r3, #27
 801017c:	18fb      	adds	r3, r7, r3
 801017e:	781b      	ldrb	r3, [r3, #0]
 8010180:	2b00      	cmp	r3, #0
 8010182:	d00e      	beq.n	80101a2 <tcp_write+0x922>
      concat_chksum = SWAP_BYTES_IN_WORD(concat_chksum);
 8010184:	211c      	movs	r1, #28
 8010186:	187b      	adds	r3, r7, r1
 8010188:	881b      	ldrh	r3, [r3, #0]
 801018a:	021b      	lsls	r3, r3, #8
 801018c:	b21a      	sxth	r2, r3
 801018e:	187b      	adds	r3, r7, r1
 8010190:	881b      	ldrh	r3, [r3, #0]
 8010192:	0a1b      	lsrs	r3, r3, #8
 8010194:	b29b      	uxth	r3, r3
 8010196:	b21b      	sxth	r3, r3
 8010198:	4313      	orrs	r3, r2
 801019a:	b21b      	sxth	r3, r3
 801019c:	b29a      	uxth	r2, r3
 801019e:	187b      	adds	r3, r7, r1
 80101a0:	801a      	strh	r2, [r3, #0]
    }
    tcp_seg_add_chksum(concat_chksum, concat_chksummed, &last_unsent->chksum,
 80101a2:	231c      	movs	r3, #28
 80101a4:	18fb      	adds	r3, r7, r3
 80101a6:	8818      	ldrh	r0, [r3, #0]
 80101a8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80101aa:	330c      	adds	r3, #12
 80101ac:	001a      	movs	r2, r3
 80101ae:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80101b0:	330e      	adds	r3, #14
 80101b2:	001c      	movs	r4, r3
 80101b4:	2346      	movs	r3, #70	; 0x46
 80101b6:	18fb      	adds	r3, r7, r3
 80101b8:	8819      	ldrh	r1, [r3, #0]
 80101ba:	0023      	movs	r3, r4
 80101bc:	f7ff faa4 	bl	800f708 <tcp_seg_add_chksum>
                       &last_unsent->chksum_swapped);
    last_unsent->flags |= TF_SEG_DATA_CHECKSUMMED;
 80101c0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80101c2:	7bdb      	ldrb	r3, [r3, #15]
 80101c4:	2204      	movs	r2, #4
 80101c6:	4313      	orrs	r3, r2
 80101c8:	b2da      	uxtb	r2, r3
 80101ca:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80101cc:	73da      	strb	r2, [r3, #15]

  /*
   * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
   * is harmless
   */
  if (last_unsent == NULL) {
 80101ce:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80101d0:	2b00      	cmp	r3, #0
 80101d2:	d103      	bne.n	80101dc <tcp_write+0x95c>
    pcb->unsent = queue;
 80101d4:	68fb      	ldr	r3, [r7, #12]
 80101d6:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 80101d8:	671a      	str	r2, [r3, #112]	; 0x70
 80101da:	e002      	b.n	80101e2 <tcp_write+0x962>
  } else {
    last_unsent->next = queue;
 80101dc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80101de:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 80101e0:	601a      	str	r2, [r3, #0]
  }

  /*
   * Finally update the pcb state.
   */
  pcb->snd_lbb += len;
 80101e2:	68fb      	ldr	r3, [r7, #12]
 80101e4:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80101e6:	1dbb      	adds	r3, r7, #6
 80101e8:	881b      	ldrh	r3, [r3, #0]
 80101ea:	18d2      	adds	r2, r2, r3
 80101ec:	68fb      	ldr	r3, [r7, #12]
 80101ee:	661a      	str	r2, [r3, #96]	; 0x60
  pcb->snd_buf -= len;
 80101f0:	68fb      	ldr	r3, [r7, #12]
 80101f2:	2268      	movs	r2, #104	; 0x68
 80101f4:	5a9a      	ldrh	r2, [r3, r2]
 80101f6:	1dbb      	adds	r3, r7, #6
 80101f8:	881b      	ldrh	r3, [r3, #0]
 80101fa:	1ad3      	subs	r3, r2, r3
 80101fc:	b299      	uxth	r1, r3
 80101fe:	68fb      	ldr	r3, [r7, #12]
 8010200:	2268      	movs	r2, #104	; 0x68
 8010202:	5299      	strh	r1, [r3, r2]
  pcb->snd_queuelen = queuelen;
 8010204:	68fb      	ldr	r3, [r7, #12]
 8010206:	2250      	movs	r2, #80	; 0x50
 8010208:	18ba      	adds	r2, r7, r2
 801020a:	216a      	movs	r1, #106	; 0x6a
 801020c:	8812      	ldrh	r2, [r2, #0]
 801020e:	525a      	strh	r2, [r3, r1]

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: %"S16_F" (after enqueued)\n",
                               pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
 8010210:	68fb      	ldr	r3, [r7, #12]
 8010212:	226a      	movs	r2, #106	; 0x6a
 8010214:	5a9b      	ldrh	r3, [r3, r2]
 8010216:	2b00      	cmp	r3, #0
 8010218:	d00d      	beq.n	8010236 <tcp_write+0x9b6>
    LWIP_ASSERT("tcp_write: valid queue length",
 801021a:	68fb      	ldr	r3, [r7, #12]
 801021c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 801021e:	2b00      	cmp	r3, #0
 8010220:	d109      	bne.n	8010236 <tcp_write+0x9b6>
 8010222:	68fb      	ldr	r3, [r7, #12]
 8010224:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010226:	2b00      	cmp	r3, #0
 8010228:	d105      	bne.n	8010236 <tcp_write+0x9b6>
 801022a:	4b37      	ldr	r3, [pc, #220]	; (8010308 <tcp_write+0xa88>)
 801022c:	4a3f      	ldr	r2, [pc, #252]	; (801032c <tcp_write+0xaac>)
 801022e:	4940      	ldr	r1, [pc, #256]	; (8010330 <tcp_write+0xab0>)
 8010230:	4838      	ldr	r0, [pc, #224]	; (8010314 <tcp_write+0xa94>)
 8010232:	f7f2 fb53 	bl	80028dc <app_debug_rtt_raw>
                pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued. */
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE) == 0)) {
 8010236:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010238:	2b00      	cmp	r3, #0
 801023a:	d02b      	beq.n	8010294 <tcp_write+0xa14>
 801023c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801023e:	691b      	ldr	r3, [r3, #16]
 8010240:	2b00      	cmp	r3, #0
 8010242:	d027      	beq.n	8010294 <tcp_write+0xa14>
 8010244:	1d7b      	adds	r3, r7, #5
 8010246:	781b      	ldrb	r3, [r3, #0]
 8010248:	2202      	movs	r2, #2
 801024a:	4013      	ands	r3, r2
 801024c:	d122      	bne.n	8010294 <tcp_write+0xa14>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
 801024e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010250:	691b      	ldr	r3, [r3, #16]
 8010252:	7b1a      	ldrb	r2, [r3, #12]
 8010254:	7b5b      	ldrb	r3, [r3, #13]
 8010256:	021b      	lsls	r3, r3, #8
 8010258:	4313      	orrs	r3, r2
 801025a:	b29c      	uxth	r4, r3
 801025c:	2008      	movs	r0, #8
 801025e:	f7f6 fcd3 	bl	8006c08 <lwip_htons>
 8010262:	0003      	movs	r3, r0
 8010264:	001a      	movs	r2, r3
 8010266:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010268:	691b      	ldr	r3, [r3, #16]
 801026a:	4322      	orrs	r2, r4
 801026c:	b292      	uxth	r2, r2
 801026e:	21ff      	movs	r1, #255	; 0xff
 8010270:	4011      	ands	r1, r2
 8010272:	000c      	movs	r4, r1
 8010274:	7b19      	ldrb	r1, [r3, #12]
 8010276:	2000      	movs	r0, #0
 8010278:	4001      	ands	r1, r0
 801027a:	1c08      	adds	r0, r1, #0
 801027c:	1c21      	adds	r1, r4, #0
 801027e:	4301      	orrs	r1, r0
 8010280:	7319      	strb	r1, [r3, #12]
 8010282:	0a12      	lsrs	r2, r2, #8
 8010284:	b290      	uxth	r0, r2
 8010286:	7b5a      	ldrb	r2, [r3, #13]
 8010288:	2100      	movs	r1, #0
 801028a:	400a      	ands	r2, r1
 801028c:	1c11      	adds	r1, r2, #0
 801028e:	1c02      	adds	r2, r0, #0
 8010290:	430a      	orrs	r2, r1
 8010292:	735a      	strb	r2, [r3, #13]
  }

  return ERR_OK;
 8010294:	2300      	movs	r3, #0
 8010296:	e032      	b.n	80102fe <tcp_write+0xa7e>
          goto memerr;
 8010298:	46c0      	nop			; (mov r8, r8)
 801029a:	e006      	b.n	80102aa <tcp_write+0xa2a>
            goto memerr;
 801029c:	46c0      	nop			; (mov r8, r8)
 801029e:	e004      	b.n	80102aa <tcp_write+0xa2a>
        goto memerr;
 80102a0:	46c0      	nop			; (mov r8, r8)
 80102a2:	e002      	b.n	80102aa <tcp_write+0xa2a>
        goto memerr;
 80102a4:	46c0      	nop			; (mov r8, r8)
 80102a6:	e000      	b.n	80102aa <tcp_write+0xa2a>
      goto memerr;
 80102a8:	46c0      	nop			; (mov r8, r8)
memerr:
  tcp_set_flags(pcb, TF_NAGLEMEMERR);
 80102aa:	68fb      	ldr	r3, [r7, #12]
 80102ac:	8bdb      	ldrh	r3, [r3, #30]
 80102ae:	2280      	movs	r2, #128	; 0x80
 80102b0:	4313      	orrs	r3, r2
 80102b2:	b29a      	uxth	r2, r3
 80102b4:	68fb      	ldr	r3, [r7, #12]
 80102b6:	83da      	strh	r2, [r3, #30]
  TCP_STATS_INC(tcp.memerr);

  if (concat_p != NULL) {
 80102b8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80102ba:	2b00      	cmp	r3, #0
 80102bc:	d003      	beq.n	80102c6 <tcp_write+0xa46>
    pbuf_free(concat_p);
 80102be:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80102c0:	0018      	movs	r0, r3
 80102c2:	f7f9 fc85 	bl	8009bd0 <pbuf_free>
  }
  if (queue != NULL) {
 80102c6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80102c8:	2b00      	cmp	r3, #0
 80102ca:	d003      	beq.n	80102d4 <tcp_write+0xa54>
    tcp_segs_free(queue);
 80102cc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80102ce:	0018      	movs	r0, r3
 80102d0:	f7fb fcd4 	bl	800bc7c <tcp_segs_free>
  }
  if (pcb->snd_queuelen != 0) {
 80102d4:	68fb      	ldr	r3, [r7, #12]
 80102d6:	226a      	movs	r2, #106	; 0x6a
 80102d8:	5a9b      	ldrh	r3, [r3, r2]
 80102da:	2b00      	cmp	r3, #0
 80102dc:	d00d      	beq.n	80102fa <tcp_write+0xa7a>
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
 80102de:	68fb      	ldr	r3, [r7, #12]
 80102e0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80102e2:	2b00      	cmp	r3, #0
 80102e4:	d109      	bne.n	80102fa <tcp_write+0xa7a>
 80102e6:	68fb      	ldr	r3, [r7, #12]
 80102e8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80102ea:	2b00      	cmp	r3, #0
 80102ec:	d105      	bne.n	80102fa <tcp_write+0xa7a>
 80102ee:	4b06      	ldr	r3, [pc, #24]	; (8010308 <tcp_write+0xa88>)
 80102f0:	4a10      	ldr	r2, [pc, #64]	; (8010334 <tcp_write+0xab4>)
 80102f2:	490f      	ldr	r1, [pc, #60]	; (8010330 <tcp_write+0xab0>)
 80102f4:	4807      	ldr	r0, [pc, #28]	; (8010314 <tcp_write+0xa94>)
 80102f6:	f7f2 faf1 	bl	80028dc <app_debug_rtt_raw>
                pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
 80102fa:	2301      	movs	r3, #1
 80102fc:	425b      	negs	r3, r3
}
 80102fe:	0018      	movs	r0, r3
 8010300:	46bd      	mov	sp, r7
 8010302:	b01a      	add	sp, #104	; 0x68
 8010304:	bdb0      	pop	{r4, r5, r7, pc}
 8010306:	46c0      	nop			; (mov r8, r8)
 8010308:	08020658 	.word	0x08020658
 801030c:	000002d3 	.word	0x000002d3
 8010310:	080209bc 	.word	0x080209bc
 8010314:	080206a4 	.word	0x080206a4
 8010318:	080209e8 	.word	0x080209e8
 801031c:	000002e6 	.word	0x000002e6
 8010320:	08020a20 	.word	0x08020a20
 8010324:	000002f2 	.word	0x000002f2
 8010328:	08020a58 	.word	0x08020a58
 801032c:	00000312 	.word	0x00000312
 8010330:	08020a8c 	.word	0x08020a8c
 8010334:	00000327 	.word	0x00000327

08010338 <tcp_split_unsent_seg>:
 * @param pcb the tcp_pcb for which to split the unsent head
 * @param split the amount of payload to remain in the head
 */
err_t
tcp_split_unsent_seg(struct tcp_pcb *pcb, u16_t split)
{
 8010338:	b5f0      	push	{r4, r5, r6, r7, lr}
 801033a:	b08d      	sub	sp, #52	; 0x34
 801033c:	af02      	add	r7, sp, #8
 801033e:	6078      	str	r0, [r7, #4]
 8010340:	000a      	movs	r2, r1
 8010342:	1cbb      	adds	r3, r7, #2
 8010344:	801a      	strh	r2, [r3, #0]
  struct tcp_seg *seg = NULL, *useg = NULL;
 8010346:	2300      	movs	r3, #0
 8010348:	61fb      	str	r3, [r7, #28]
 801034a:	2300      	movs	r3, #0
 801034c:	613b      	str	r3, [r7, #16]
  struct pbuf *p = NULL;
 801034e:	2300      	movs	r3, #0
 8010350:	623b      	str	r3, [r7, #32]
  u8_t split_flags;
  u8_t remainder_flags;
  u16_t remainder;
  u16_t offset;
#if TCP_CHECKSUM_ON_COPY
  u16_t chksum = 0;
 8010352:	230a      	movs	r3, #10
 8010354:	18fb      	adds	r3, r7, r3
 8010356:	2200      	movs	r2, #0
 8010358:	801a      	strh	r2, [r3, #0]
  u8_t chksum_swapped = 0;
 801035a:	2309      	movs	r3, #9
 801035c:	18fb      	adds	r3, r7, r3
 801035e:	2200      	movs	r2, #0
 8010360:	701a      	strb	r2, [r3, #0]
  struct pbuf *q;
#endif /* TCP_CHECKSUM_ON_COPY */

  LWIP_ASSERT("tcp_split_unsent_seg: invalid pcb", pcb != NULL);
 8010362:	687b      	ldr	r3, [r7, #4]
 8010364:	2b00      	cmp	r3, #0
 8010366:	d105      	bne.n	8010374 <tcp_split_unsent_seg+0x3c>
 8010368:	4bd2      	ldr	r3, [pc, #840]	; (80106b4 <tcp_split_unsent_seg+0x37c>)
 801036a:	4ad3      	ldr	r2, [pc, #844]	; (80106b8 <tcp_split_unsent_seg+0x380>)
 801036c:	49d3      	ldr	r1, [pc, #844]	; (80106bc <tcp_split_unsent_seg+0x384>)
 801036e:	48d4      	ldr	r0, [pc, #848]	; (80106c0 <tcp_split_unsent_seg+0x388>)
 8010370:	f7f2 fab4 	bl	80028dc <app_debug_rtt_raw>

  useg = pcb->unsent;
 8010374:	687b      	ldr	r3, [r7, #4]
 8010376:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010378:	613b      	str	r3, [r7, #16]
  if (useg == NULL) {
 801037a:	693b      	ldr	r3, [r7, #16]
 801037c:	2b00      	cmp	r3, #0
 801037e:	d102      	bne.n	8010386 <tcp_split_unsent_seg+0x4e>
    return ERR_MEM;
 8010380:	2301      	movs	r3, #1
 8010382:	425b      	negs	r3, r3
 8010384:	e207      	b.n	8010796 <tcp_split_unsent_seg+0x45e>
  }

  if (split == 0) {
 8010386:	1cbb      	adds	r3, r7, #2
 8010388:	881b      	ldrh	r3, [r3, #0]
 801038a:	2b00      	cmp	r3, #0
 801038c:	d108      	bne.n	80103a0 <tcp_split_unsent_seg+0x68>
    LWIP_ASSERT("Can't split segment into length 0", 0);
 801038e:	4bc9      	ldr	r3, [pc, #804]	; (80106b4 <tcp_split_unsent_seg+0x37c>)
 8010390:	4acc      	ldr	r2, [pc, #816]	; (80106c4 <tcp_split_unsent_seg+0x38c>)
 8010392:	49cd      	ldr	r1, [pc, #820]	; (80106c8 <tcp_split_unsent_seg+0x390>)
 8010394:	48ca      	ldr	r0, [pc, #808]	; (80106c0 <tcp_split_unsent_seg+0x388>)
 8010396:	f7f2 faa1 	bl	80028dc <app_debug_rtt_raw>
    return ERR_VAL;
 801039a:	2306      	movs	r3, #6
 801039c:	425b      	negs	r3, r3
 801039e:	e1fa      	b.n	8010796 <tcp_split_unsent_seg+0x45e>
  }

  if (useg->len <= split) {
 80103a0:	693b      	ldr	r3, [r7, #16]
 80103a2:	891b      	ldrh	r3, [r3, #8]
 80103a4:	1cba      	adds	r2, r7, #2
 80103a6:	8812      	ldrh	r2, [r2, #0]
 80103a8:	429a      	cmp	r2, r3
 80103aa:	d301      	bcc.n	80103b0 <tcp_split_unsent_seg+0x78>
    return ERR_OK;
 80103ac:	2300      	movs	r3, #0
 80103ae:	e1f2      	b.n	8010796 <tcp_split_unsent_seg+0x45e>
  }

  LWIP_ASSERT("split <= mss", split <= pcb->mss);
 80103b0:	687b      	ldr	r3, [r7, #4]
 80103b2:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 80103b4:	1cba      	adds	r2, r7, #2
 80103b6:	8812      	ldrh	r2, [r2, #0]
 80103b8:	429a      	cmp	r2, r3
 80103ba:	d905      	bls.n	80103c8 <tcp_split_unsent_seg+0x90>
 80103bc:	4bbd      	ldr	r3, [pc, #756]	; (80106b4 <tcp_split_unsent_seg+0x37c>)
 80103be:	4ac3      	ldr	r2, [pc, #780]	; (80106cc <tcp_split_unsent_seg+0x394>)
 80103c0:	49c3      	ldr	r1, [pc, #780]	; (80106d0 <tcp_split_unsent_seg+0x398>)
 80103c2:	48bf      	ldr	r0, [pc, #764]	; (80106c0 <tcp_split_unsent_seg+0x388>)
 80103c4:	f7f2 fa8a 	bl	80028dc <app_debug_rtt_raw>
  LWIP_ASSERT("useg->len > 0", useg->len > 0);
 80103c8:	693b      	ldr	r3, [r7, #16]
 80103ca:	891b      	ldrh	r3, [r3, #8]
 80103cc:	2b00      	cmp	r3, #0
 80103ce:	d106      	bne.n	80103de <tcp_split_unsent_seg+0xa6>
 80103d0:	4bb8      	ldr	r3, [pc, #736]	; (80106b4 <tcp_split_unsent_seg+0x37c>)
 80103d2:	22d7      	movs	r2, #215	; 0xd7
 80103d4:	0092      	lsls	r2, r2, #2
 80103d6:	49bf      	ldr	r1, [pc, #764]	; (80106d4 <tcp_split_unsent_seg+0x39c>)
 80103d8:	48b9      	ldr	r0, [pc, #740]	; (80106c0 <tcp_split_unsent_seg+0x388>)
 80103da:	f7f2 fa7f 	bl	80028dc <app_debug_rtt_raw>
   * to split this packet so we may actually exceed the max value by
   * one!
   */
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: split_unsent_seg: %u\n", (unsigned int)pcb->snd_queuelen));

  optflags = useg->flags;
 80103de:	200f      	movs	r0, #15
 80103e0:	183b      	adds	r3, r7, r0
 80103e2:	693a      	ldr	r2, [r7, #16]
 80103e4:	7bd2      	ldrb	r2, [r2, #15]
 80103e6:	701a      	strb	r2, [r3, #0]
#if TCP_CHECKSUM_ON_COPY
  /* Remove since checksum is not stored until after tcp_create_segment() */
  optflags &= ~TF_SEG_DATA_CHECKSUMMED;
 80103e8:	183b      	adds	r3, r7, r0
 80103ea:	183a      	adds	r2, r7, r0
 80103ec:	7812      	ldrb	r2, [r2, #0]
 80103ee:	2104      	movs	r1, #4
 80103f0:	438a      	bics	r2, r1
 80103f2:	701a      	strb	r2, [r3, #0]
#endif /* TCP_CHECKSUM_ON_COPY */
  optlen = LWIP_TCP_OPT_LENGTH(optflags);
 80103f4:	183b      	adds	r3, r7, r0
 80103f6:	781b      	ldrb	r3, [r3, #0]
 80103f8:	009b      	lsls	r3, r3, #2
 80103fa:	b2da      	uxtb	r2, r3
 80103fc:	240e      	movs	r4, #14
 80103fe:	193b      	adds	r3, r7, r4
 8010400:	2104      	movs	r1, #4
 8010402:	400a      	ands	r2, r1
 8010404:	701a      	strb	r2, [r3, #0]
  remainder = useg->len - split;
 8010406:	693b      	ldr	r3, [r7, #16]
 8010408:	8919      	ldrh	r1, [r3, #8]
 801040a:	250c      	movs	r5, #12
 801040c:	197b      	adds	r3, r7, r5
 801040e:	1cba      	adds	r2, r7, #2
 8010410:	8812      	ldrh	r2, [r2, #0]
 8010412:	1a8a      	subs	r2, r1, r2
 8010414:	801a      	strh	r2, [r3, #0]

  /* Create new pbuf for the remainder of the split */
  p = pbuf_alloc(PBUF_TRANSPORT, remainder + optlen, PBUF_RAM);
 8010416:	193b      	adds	r3, r7, r4
 8010418:	781b      	ldrb	r3, [r3, #0]
 801041a:	b29a      	uxth	r2, r3
 801041c:	197b      	adds	r3, r7, r5
 801041e:	881b      	ldrh	r3, [r3, #0]
 8010420:	18d3      	adds	r3, r2, r3
 8010422:	b29b      	uxth	r3, r3
 8010424:	22a0      	movs	r2, #160	; 0xa0
 8010426:	0092      	lsls	r2, r2, #2
 8010428:	0019      	movs	r1, r3
 801042a:	2038      	movs	r0, #56	; 0x38
 801042c:	f7f9 f858 	bl	80094e0 <pbuf_alloc>
 8010430:	0003      	movs	r3, r0
 8010432:	623b      	str	r3, [r7, #32]
  if (p == NULL) {
 8010434:	6a3b      	ldr	r3, [r7, #32]
 8010436:	2b00      	cmp	r3, #0
 8010438:	d100      	bne.n	801043c <tcp_split_unsent_seg+0x104>
 801043a:	e197      	b.n	801076c <tcp_split_unsent_seg+0x434>
                ("tcp_split_unsent_seg: could not allocate memory for pbuf remainder %u\n", remainder));
    goto memerr;
  }

  /* Offset into the original pbuf is past TCP/IP headers, options, and split amount */
  offset = useg->p->tot_len - useg->len + split;
 801043c:	693b      	ldr	r3, [r7, #16]
 801043e:	685b      	ldr	r3, [r3, #4]
 8010440:	891a      	ldrh	r2, [r3, #8]
 8010442:	693b      	ldr	r3, [r7, #16]
 8010444:	891b      	ldrh	r3, [r3, #8]
 8010446:	1ad3      	subs	r3, r2, r3
 8010448:	b299      	uxth	r1, r3
 801044a:	2318      	movs	r3, #24
 801044c:	18fb      	adds	r3, r7, r3
 801044e:	1cba      	adds	r2, r7, #2
 8010450:	8812      	ldrh	r2, [r2, #0]
 8010452:	188a      	adds	r2, r1, r2
 8010454:	801a      	strh	r2, [r3, #0]
  /* Copy remainder into new pbuf, headers and options will not be filled out */
  if (pbuf_copy_partial(useg->p, (u8_t *)p->payload + optlen, remainder, offset ) != remainder) {
 8010456:	693b      	ldr	r3, [r7, #16]
 8010458:	6858      	ldr	r0, [r3, #4]
 801045a:	6a3b      	ldr	r3, [r7, #32]
 801045c:	685a      	ldr	r2, [r3, #4]
 801045e:	0026      	movs	r6, r4
 8010460:	193b      	adds	r3, r7, r4
 8010462:	781b      	ldrb	r3, [r3, #0]
 8010464:	18d1      	adds	r1, r2, r3
 8010466:	2318      	movs	r3, #24
 8010468:	18fb      	adds	r3, r7, r3
 801046a:	881c      	ldrh	r4, [r3, #0]
 801046c:	197b      	adds	r3, r7, r5
 801046e:	881a      	ldrh	r2, [r3, #0]
 8010470:	0023      	movs	r3, r4
 8010472:	f7f9 fe77 	bl	800a164 <pbuf_copy_partial>
 8010476:	0003      	movs	r3, r0
 8010478:	001a      	movs	r2, r3
 801047a:	197b      	adds	r3, r7, r5
 801047c:	881b      	ldrh	r3, [r3, #0]
 801047e:	4293      	cmp	r3, r2
 8010480:	d000      	beq.n	8010484 <tcp_split_unsent_seg+0x14c>
 8010482:	e175      	b.n	8010770 <tcp_split_unsent_seg+0x438>
                ("tcp_split_unsent_seg: could not copy pbuf remainder %u\n", remainder));
    goto memerr;
  }
#if TCP_CHECKSUM_ON_COPY
  /* calculate the checksum on remainder data */
  tcp_seg_add_chksum(~inet_chksum((const u8_t *)p->payload + optlen, remainder), remainder,
 8010484:	6a3b      	ldr	r3, [r7, #32]
 8010486:	685a      	ldr	r2, [r3, #4]
 8010488:	19bb      	adds	r3, r7, r6
 801048a:	781b      	ldrb	r3, [r3, #0]
 801048c:	18d2      	adds	r2, r2, r3
 801048e:	197b      	adds	r3, r7, r5
 8010490:	881b      	ldrh	r3, [r3, #0]
 8010492:	0019      	movs	r1, r3
 8010494:	0010      	movs	r0, r2
 8010496:	f7f7 ff7d 	bl	8008394 <inet_chksum>
 801049a:	0003      	movs	r3, r0
 801049c:	43db      	mvns	r3, r3
 801049e:	b298      	uxth	r0, r3
 80104a0:	2309      	movs	r3, #9
 80104a2:	18fc      	adds	r4, r7, r3
 80104a4:	230a      	movs	r3, #10
 80104a6:	18fa      	adds	r2, r7, r3
 80104a8:	197b      	adds	r3, r7, r5
 80104aa:	8819      	ldrh	r1, [r3, #0]
 80104ac:	0023      	movs	r3, r4
 80104ae:	f7ff f92b 	bl	800f708 <tcp_seg_add_chksum>
#endif /* TCP_CHECKSUM_ON_COPY */

  /* Options are created when calling tcp_output() */

  /* Migrate flags from original segment */
  split_flags = TCPH_FLAGS(useg->tcphdr);
 80104b2:	693b      	ldr	r3, [r7, #16]
 80104b4:	691b      	ldr	r3, [r3, #16]
 80104b6:	7b1a      	ldrb	r2, [r3, #12]
 80104b8:	7b5b      	ldrb	r3, [r3, #13]
 80104ba:	021b      	lsls	r3, r3, #8
 80104bc:	4313      	orrs	r3, r2
 80104be:	b29b      	uxth	r3, r3
 80104c0:	0018      	movs	r0, r3
 80104c2:	f7f6 fba1 	bl	8006c08 <lwip_htons>
 80104c6:	0003      	movs	r3, r0
 80104c8:	b2da      	uxtb	r2, r3
 80104ca:	2027      	movs	r0, #39	; 0x27
 80104cc:	183b      	adds	r3, r7, r0
 80104ce:	213f      	movs	r1, #63	; 0x3f
 80104d0:	400a      	ands	r2, r1
 80104d2:	701a      	strb	r2, [r3, #0]
  remainder_flags = 0; /* ACK added in tcp_output() */
 80104d4:	241b      	movs	r4, #27
 80104d6:	193b      	adds	r3, r7, r4
 80104d8:	2200      	movs	r2, #0
 80104da:	701a      	strb	r2, [r3, #0]

  if (split_flags & TCP_PSH) {
 80104dc:	183b      	adds	r3, r7, r0
 80104de:	781b      	ldrb	r3, [r3, #0]
 80104e0:	2208      	movs	r2, #8
 80104e2:	4013      	ands	r3, r2
 80104e4:	d00b      	beq.n	80104fe <tcp_split_unsent_seg+0x1c6>
    split_flags &= ~TCP_PSH;
 80104e6:	183b      	adds	r3, r7, r0
 80104e8:	183a      	adds	r2, r7, r0
 80104ea:	7812      	ldrb	r2, [r2, #0]
 80104ec:	2108      	movs	r1, #8
 80104ee:	438a      	bics	r2, r1
 80104f0:	701a      	strb	r2, [r3, #0]
    remainder_flags |= TCP_PSH;
 80104f2:	193b      	adds	r3, r7, r4
 80104f4:	193a      	adds	r2, r7, r4
 80104f6:	7812      	ldrb	r2, [r2, #0]
 80104f8:	2108      	movs	r1, #8
 80104fa:	430a      	orrs	r2, r1
 80104fc:	701a      	strb	r2, [r3, #0]
  }
  if (split_flags & TCP_FIN) {
 80104fe:	2127      	movs	r1, #39	; 0x27
 8010500:	187b      	adds	r3, r7, r1
 8010502:	781b      	ldrb	r3, [r3, #0]
 8010504:	2201      	movs	r2, #1
 8010506:	4013      	ands	r3, r2
 8010508:	d00c      	beq.n	8010524 <tcp_split_unsent_seg+0x1ec>
    split_flags &= ~TCP_FIN;
 801050a:	187b      	adds	r3, r7, r1
 801050c:	187a      	adds	r2, r7, r1
 801050e:	7812      	ldrb	r2, [r2, #0]
 8010510:	2101      	movs	r1, #1
 8010512:	438a      	bics	r2, r1
 8010514:	701a      	strb	r2, [r3, #0]
    remainder_flags |= TCP_FIN;
 8010516:	221b      	movs	r2, #27
 8010518:	18bb      	adds	r3, r7, r2
 801051a:	18ba      	adds	r2, r7, r2
 801051c:	7812      	ldrb	r2, [r2, #0]
 801051e:	2101      	movs	r1, #1
 8010520:	430a      	orrs	r2, r1
 8010522:	701a      	strb	r2, [r3, #0]
  }
  /* SYN should be left on split, RST should not be present with data */

  seg = tcp_create_segment(pcb, p, remainder_flags, lwip_ntohl(useg->tcphdr->seqno) + split, optflags);
 8010524:	693b      	ldr	r3, [r7, #16]
 8010526:	691b      	ldr	r3, [r3, #16]
 8010528:	791a      	ldrb	r2, [r3, #4]
 801052a:	7959      	ldrb	r1, [r3, #5]
 801052c:	0209      	lsls	r1, r1, #8
 801052e:	430a      	orrs	r2, r1
 8010530:	7999      	ldrb	r1, [r3, #6]
 8010532:	0409      	lsls	r1, r1, #16
 8010534:	430a      	orrs	r2, r1
 8010536:	79db      	ldrb	r3, [r3, #7]
 8010538:	061b      	lsls	r3, r3, #24
 801053a:	4313      	orrs	r3, r2
 801053c:	0018      	movs	r0, r3
 801053e:	f7f6 fb79 	bl	8006c34 <lwip_htonl>
 8010542:	0002      	movs	r2, r0
 8010544:	1cbb      	adds	r3, r7, #2
 8010546:	881b      	ldrh	r3, [r3, #0]
 8010548:	18d4      	adds	r4, r2, r3
 801054a:	231b      	movs	r3, #27
 801054c:	18fb      	adds	r3, r7, r3
 801054e:	781a      	ldrb	r2, [r3, #0]
 8010550:	6a39      	ldr	r1, [r7, #32]
 8010552:	6878      	ldr	r0, [r7, #4]
 8010554:	230f      	movs	r3, #15
 8010556:	18fb      	adds	r3, r7, r3
 8010558:	781b      	ldrb	r3, [r3, #0]
 801055a:	9300      	str	r3, [sp, #0]
 801055c:	0023      	movs	r3, r4
 801055e:	f7fe ff13 	bl	800f388 <tcp_create_segment>
 8010562:	0003      	movs	r3, r0
 8010564:	61fb      	str	r3, [r7, #28]
  if (seg == NULL) {
 8010566:	69fb      	ldr	r3, [r7, #28]
 8010568:	2b00      	cmp	r3, #0
 801056a:	d102      	bne.n	8010572 <tcp_split_unsent_seg+0x23a>
    p = NULL; /* Freed by tcp_create_segment */
 801056c:	2300      	movs	r3, #0
 801056e:	623b      	str	r3, [r7, #32]
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                ("tcp_split_unsent_seg: could not create new TCP segment\n"));
    goto memerr;
 8010570:	e0ff      	b.n	8010772 <tcp_split_unsent_seg+0x43a>
  }

#if TCP_CHECKSUM_ON_COPY
  seg->chksum = chksum;
 8010572:	230a      	movs	r3, #10
 8010574:	18fb      	adds	r3, r7, r3
 8010576:	881a      	ldrh	r2, [r3, #0]
 8010578:	69fb      	ldr	r3, [r7, #28]
 801057a:	819a      	strh	r2, [r3, #12]
  seg->chksum_swapped = chksum_swapped;
 801057c:	2309      	movs	r3, #9
 801057e:	18fb      	adds	r3, r7, r3
 8010580:	781a      	ldrb	r2, [r3, #0]
 8010582:	69fb      	ldr	r3, [r7, #28]
 8010584:	739a      	strb	r2, [r3, #14]
  seg->flags |= TF_SEG_DATA_CHECKSUMMED;
 8010586:	69fb      	ldr	r3, [r7, #28]
 8010588:	7bdb      	ldrb	r3, [r3, #15]
 801058a:	2204      	movs	r2, #4
 801058c:	4313      	orrs	r3, r2
 801058e:	b2da      	uxtb	r2, r3
 8010590:	69fb      	ldr	r3, [r7, #28]
 8010592:	73da      	strb	r2, [r3, #15]
#endif /* TCP_CHECKSUM_ON_COPY */

  /* Remove this segment from the queue since trimming it may free pbufs */
  pcb->snd_queuelen -= pbuf_clen(useg->p);
 8010594:	693b      	ldr	r3, [r7, #16]
 8010596:	685b      	ldr	r3, [r3, #4]
 8010598:	0018      	movs	r0, r3
 801059a:	f7f9 fbb9 	bl	8009d10 <pbuf_clen>
 801059e:	0003      	movs	r3, r0
 80105a0:	0019      	movs	r1, r3
 80105a2:	687b      	ldr	r3, [r7, #4]
 80105a4:	226a      	movs	r2, #106	; 0x6a
 80105a6:	5a9b      	ldrh	r3, [r3, r2]
 80105a8:	1a5b      	subs	r3, r3, r1
 80105aa:	b299      	uxth	r1, r3
 80105ac:	687b      	ldr	r3, [r7, #4]
 80105ae:	226a      	movs	r2, #106	; 0x6a
 80105b0:	5299      	strh	r1, [r3, r2]

  /* Trim the original pbuf into our split size.  At this point our remainder segment must be setup
  successfully because we are modifying the original segment */
  pbuf_realloc(useg->p, useg->p->tot_len - remainder);
 80105b2:	693b      	ldr	r3, [r7, #16]
 80105b4:	6858      	ldr	r0, [r3, #4]
 80105b6:	693b      	ldr	r3, [r7, #16]
 80105b8:	685b      	ldr	r3, [r3, #4]
 80105ba:	891a      	ldrh	r2, [r3, #8]
 80105bc:	240c      	movs	r4, #12
 80105be:	193b      	adds	r3, r7, r4
 80105c0:	881b      	ldrh	r3, [r3, #0]
 80105c2:	1ad3      	subs	r3, r2, r3
 80105c4:	b29b      	uxth	r3, r3
 80105c6:	0019      	movs	r1, r3
 80105c8:	f7f9 f908 	bl	80097dc <pbuf_realloc>
  useg->len -= remainder;
 80105cc:	693b      	ldr	r3, [r7, #16]
 80105ce:	891a      	ldrh	r2, [r3, #8]
 80105d0:	193b      	adds	r3, r7, r4
 80105d2:	881b      	ldrh	r3, [r3, #0]
 80105d4:	1ad3      	subs	r3, r2, r3
 80105d6:	b29a      	uxth	r2, r3
 80105d8:	693b      	ldr	r3, [r7, #16]
 80105da:	811a      	strh	r2, [r3, #8]
  TCPH_SET_FLAG(useg->tcphdr, split_flags);
 80105dc:	693b      	ldr	r3, [r7, #16]
 80105de:	691b      	ldr	r3, [r3, #16]
 80105e0:	7b1a      	ldrb	r2, [r3, #12]
 80105e2:	7b5b      	ldrb	r3, [r3, #13]
 80105e4:	021b      	lsls	r3, r3, #8
 80105e6:	4313      	orrs	r3, r2
 80105e8:	b29c      	uxth	r4, r3
 80105ea:	2327      	movs	r3, #39	; 0x27
 80105ec:	18fb      	adds	r3, r7, r3
 80105ee:	781b      	ldrb	r3, [r3, #0]
 80105f0:	b29b      	uxth	r3, r3
 80105f2:	0018      	movs	r0, r3
 80105f4:	f7f6 fb08 	bl	8006c08 <lwip_htons>
 80105f8:	0003      	movs	r3, r0
 80105fa:	001a      	movs	r2, r3
 80105fc:	693b      	ldr	r3, [r7, #16]
 80105fe:	691b      	ldr	r3, [r3, #16]
 8010600:	4322      	orrs	r2, r4
 8010602:	b292      	uxth	r2, r2
 8010604:	21ff      	movs	r1, #255	; 0xff
 8010606:	4011      	ands	r1, r2
 8010608:	000c      	movs	r4, r1
 801060a:	7b19      	ldrb	r1, [r3, #12]
 801060c:	2000      	movs	r0, #0
 801060e:	4001      	ands	r1, r0
 8010610:	1c08      	adds	r0, r1, #0
 8010612:	1c21      	adds	r1, r4, #0
 8010614:	4301      	orrs	r1, r0
 8010616:	7319      	strb	r1, [r3, #12]
 8010618:	0a12      	lsrs	r2, r2, #8
 801061a:	b290      	uxth	r0, r2
 801061c:	7b5a      	ldrb	r2, [r3, #13]
 801061e:	2100      	movs	r1, #0
 8010620:	400a      	ands	r2, r1
 8010622:	1c11      	adds	r1, r2, #0
 8010624:	1c02      	adds	r2, r0, #0
 8010626:	430a      	orrs	r2, r1
 8010628:	735a      	strb	r2, [r3, #13]
#if TCP_OVERSIZE_DBGCHECK
  /* By trimming, realloc may have actually shrunk the pbuf, so clear oversize_left */
  useg->oversize_left = 0;
 801062a:	693b      	ldr	r3, [r7, #16]
 801062c:	2200      	movs	r2, #0
 801062e:	815a      	strh	r2, [r3, #10]
#endif /* TCP_OVERSIZE_DBGCHECK */

  /* Add back to the queue with new trimmed pbuf */
  pcb->snd_queuelen += pbuf_clen(useg->p);
 8010630:	693b      	ldr	r3, [r7, #16]
 8010632:	685b      	ldr	r3, [r3, #4]
 8010634:	0018      	movs	r0, r3
 8010636:	f7f9 fb6b 	bl	8009d10 <pbuf_clen>
 801063a:	0003      	movs	r3, r0
 801063c:	0019      	movs	r1, r3
 801063e:	687b      	ldr	r3, [r7, #4]
 8010640:	226a      	movs	r2, #106	; 0x6a
 8010642:	5a9b      	ldrh	r3, [r3, r2]
 8010644:	18cb      	adds	r3, r1, r3
 8010646:	b299      	uxth	r1, r3
 8010648:	687b      	ldr	r3, [r7, #4]
 801064a:	226a      	movs	r2, #106	; 0x6a
 801064c:	5299      	strh	r1, [r3, r2]

#if TCP_CHECKSUM_ON_COPY
  /* The checksum on the split segment is now incorrect. We need to re-run it over the split */
  useg->chksum = 0;
 801064e:	693b      	ldr	r3, [r7, #16]
 8010650:	2200      	movs	r2, #0
 8010652:	819a      	strh	r2, [r3, #12]
  useg->chksum_swapped = 0;
 8010654:	693b      	ldr	r3, [r7, #16]
 8010656:	2200      	movs	r2, #0
 8010658:	739a      	strb	r2, [r3, #14]
  q = useg->p;
 801065a:	693b      	ldr	r3, [r7, #16]
 801065c:	685b      	ldr	r3, [r3, #4]
 801065e:	617b      	str	r3, [r7, #20]
  offset = q->tot_len - useg->len; /* Offset due to exposed headers */
 8010660:	697b      	ldr	r3, [r7, #20]
 8010662:	8919      	ldrh	r1, [r3, #8]
 8010664:	693b      	ldr	r3, [r7, #16]
 8010666:	891a      	ldrh	r2, [r3, #8]
 8010668:	2318      	movs	r3, #24
 801066a:	18fb      	adds	r3, r7, r3
 801066c:	1a8a      	subs	r2, r1, r2
 801066e:	801a      	strh	r2, [r3, #0]

  /* Advance to the pbuf where the offset ends */
  while (q != NULL && offset > q->len) {
 8010670:	e00a      	b.n	8010688 <tcp_split_unsent_seg+0x350>
    offset -= q->len;
 8010672:	697b      	ldr	r3, [r7, #20]
 8010674:	895a      	ldrh	r2, [r3, #10]
 8010676:	2118      	movs	r1, #24
 8010678:	187b      	adds	r3, r7, r1
 801067a:	1879      	adds	r1, r7, r1
 801067c:	8809      	ldrh	r1, [r1, #0]
 801067e:	1a8a      	subs	r2, r1, r2
 8010680:	801a      	strh	r2, [r3, #0]
    q = q->next;
 8010682:	697b      	ldr	r3, [r7, #20]
 8010684:	681b      	ldr	r3, [r3, #0]
 8010686:	617b      	str	r3, [r7, #20]
  while (q != NULL && offset > q->len) {
 8010688:	697b      	ldr	r3, [r7, #20]
 801068a:	2b00      	cmp	r3, #0
 801068c:	d006      	beq.n	801069c <tcp_split_unsent_seg+0x364>
 801068e:	697b      	ldr	r3, [r7, #20]
 8010690:	895b      	ldrh	r3, [r3, #10]
 8010692:	2218      	movs	r2, #24
 8010694:	18ba      	adds	r2, r7, r2
 8010696:	8812      	ldrh	r2, [r2, #0]
 8010698:	429a      	cmp	r2, r3
 801069a:	d8ea      	bhi.n	8010672 <tcp_split_unsent_seg+0x33a>
  }
  LWIP_ASSERT("Found start of payload pbuf", q != NULL);
 801069c:	697b      	ldr	r3, [r7, #20]
 801069e:	2b00      	cmp	r3, #0
 80106a0:	d141      	bne.n	8010726 <tcp_split_unsent_seg+0x3ee>
 80106a2:	4b04      	ldr	r3, [pc, #16]	; (80106b4 <tcp_split_unsent_seg+0x37c>)
 80106a4:	22ef      	movs	r2, #239	; 0xef
 80106a6:	0092      	lsls	r2, r2, #2
 80106a8:	490b      	ldr	r1, [pc, #44]	; (80106d8 <tcp_split_unsent_seg+0x3a0>)
 80106aa:	4805      	ldr	r0, [pc, #20]	; (80106c0 <tcp_split_unsent_seg+0x388>)
 80106ac:	f7f2 f916 	bl	80028dc <app_debug_rtt_raw>
  /* Checksum the first payload pbuf accounting for offset, then other pbufs are all payload */
  for (; q != NULL; offset = 0, q = q->next) {
 80106b0:	e039      	b.n	8010726 <tcp_split_unsent_seg+0x3ee>
 80106b2:	46c0      	nop			; (mov r8, r8)
 80106b4:	08020658 	.word	0x08020658
 80106b8:	0000034b 	.word	0x0000034b
 80106bc:	08020aac 	.word	0x08020aac
 80106c0:	080206a4 	.word	0x080206a4
 80106c4:	00000353 	.word	0x00000353
 80106c8:	08020ad0 	.word	0x08020ad0
 80106cc:	0000035b 	.word	0x0000035b
 80106d0:	08020af4 	.word	0x08020af4
 80106d4:	08020b04 	.word	0x08020b04
 80106d8:	08020b14 	.word	0x08020b14
    tcp_seg_add_chksum(~inet_chksum((const u8_t *)q->payload + offset, q->len - offset), q->len - offset,
 80106dc:	697b      	ldr	r3, [r7, #20]
 80106de:	685a      	ldr	r2, [r3, #4]
 80106e0:	2418      	movs	r4, #24
 80106e2:	193b      	adds	r3, r7, r4
 80106e4:	881b      	ldrh	r3, [r3, #0]
 80106e6:	18d0      	adds	r0, r2, r3
 80106e8:	697b      	ldr	r3, [r7, #20]
 80106ea:	895a      	ldrh	r2, [r3, #10]
 80106ec:	193b      	adds	r3, r7, r4
 80106ee:	881b      	ldrh	r3, [r3, #0]
 80106f0:	1ad3      	subs	r3, r2, r3
 80106f2:	b29b      	uxth	r3, r3
 80106f4:	0019      	movs	r1, r3
 80106f6:	f7f7 fe4d 	bl	8008394 <inet_chksum>
 80106fa:	0003      	movs	r3, r0
 80106fc:	43db      	mvns	r3, r3
 80106fe:	b298      	uxth	r0, r3
 8010700:	697b      	ldr	r3, [r7, #20]
 8010702:	895a      	ldrh	r2, [r3, #10]
 8010704:	193b      	adds	r3, r7, r4
 8010706:	881b      	ldrh	r3, [r3, #0]
 8010708:	1ad3      	subs	r3, r2, r3
 801070a:	b299      	uxth	r1, r3
 801070c:	693b      	ldr	r3, [r7, #16]
 801070e:	330c      	adds	r3, #12
 8010710:	001a      	movs	r2, r3
 8010712:	693b      	ldr	r3, [r7, #16]
 8010714:	330e      	adds	r3, #14
 8010716:	f7fe fff7 	bl	800f708 <tcp_seg_add_chksum>
  for (; q != NULL; offset = 0, q = q->next) {
 801071a:	193b      	adds	r3, r7, r4
 801071c:	2200      	movs	r2, #0
 801071e:	801a      	strh	r2, [r3, #0]
 8010720:	697b      	ldr	r3, [r7, #20]
 8010722:	681b      	ldr	r3, [r3, #0]
 8010724:	617b      	str	r3, [r7, #20]
 8010726:	697b      	ldr	r3, [r7, #20]
 8010728:	2b00      	cmp	r3, #0
 801072a:	d1d7      	bne.n	80106dc <tcp_split_unsent_seg+0x3a4>
#endif /* TCP_CHECKSUM_ON_COPY */

  /* Update number of segments on the queues. Note that length now may
   * exceed TCP_SND_QUEUELEN! We don't have to touch pcb->snd_buf
   * because the total amount of data is constant when packet is split */
  pcb->snd_queuelen += pbuf_clen(seg->p);
 801072c:	69fb      	ldr	r3, [r7, #28]
 801072e:	685b      	ldr	r3, [r3, #4]
 8010730:	0018      	movs	r0, r3
 8010732:	f7f9 faed 	bl	8009d10 <pbuf_clen>
 8010736:	0003      	movs	r3, r0
 8010738:	0019      	movs	r1, r3
 801073a:	687b      	ldr	r3, [r7, #4]
 801073c:	226a      	movs	r2, #106	; 0x6a
 801073e:	5a9b      	ldrh	r3, [r3, r2]
 8010740:	18cb      	adds	r3, r1, r3
 8010742:	b299      	uxth	r1, r3
 8010744:	687b      	ldr	r3, [r7, #4]
 8010746:	226a      	movs	r2, #106	; 0x6a
 8010748:	5299      	strh	r1, [r3, r2]

  /* Finally insert remainder into queue after split (which stays head) */
  seg->next = useg->next;
 801074a:	693b      	ldr	r3, [r7, #16]
 801074c:	681a      	ldr	r2, [r3, #0]
 801074e:	69fb      	ldr	r3, [r7, #28]
 8010750:	601a      	str	r2, [r3, #0]
  useg->next = seg;
 8010752:	693b      	ldr	r3, [r7, #16]
 8010754:	69fa      	ldr	r2, [r7, #28]
 8010756:	601a      	str	r2, [r3, #0]

#if TCP_OVERSIZE
  /* If remainder is last segment on the unsent, ensure we clear the oversize amount
   * because the remainder is always sized to the exact remaining amount */
  if (seg->next == NULL) {
 8010758:	69fb      	ldr	r3, [r7, #28]
 801075a:	681b      	ldr	r3, [r3, #0]
 801075c:	2b00      	cmp	r3, #0
 801075e:	d103      	bne.n	8010768 <tcp_split_unsent_seg+0x430>
    pcb->unsent_oversize = 0;
 8010760:	687b      	ldr	r3, [r7, #4]
 8010762:	226c      	movs	r2, #108	; 0x6c
 8010764:	2100      	movs	r1, #0
 8010766:	5299      	strh	r1, [r3, r2]
  }
#endif /* TCP_OVERSIZE */

  return ERR_OK;
 8010768:	2300      	movs	r3, #0
 801076a:	e014      	b.n	8010796 <tcp_split_unsent_seg+0x45e>
    goto memerr;
 801076c:	46c0      	nop			; (mov r8, r8)
 801076e:	e000      	b.n	8010772 <tcp_split_unsent_seg+0x43a>
    goto memerr;
 8010770:	46c0      	nop			; (mov r8, r8)
memerr:
  TCP_STATS_INC(tcp.memerr);

  LWIP_ASSERT("seg == NULL", seg == NULL);
 8010772:	69fb      	ldr	r3, [r7, #28]
 8010774:	2b00      	cmp	r3, #0
 8010776:	d005      	beq.n	8010784 <tcp_split_unsent_seg+0x44c>
 8010778:	4b09      	ldr	r3, [pc, #36]	; (80107a0 <tcp_split_unsent_seg+0x468>)
 801077a:	4a0a      	ldr	r2, [pc, #40]	; (80107a4 <tcp_split_unsent_seg+0x46c>)
 801077c:	490a      	ldr	r1, [pc, #40]	; (80107a8 <tcp_split_unsent_seg+0x470>)
 801077e:	480b      	ldr	r0, [pc, #44]	; (80107ac <tcp_split_unsent_seg+0x474>)
 8010780:	f7f2 f8ac 	bl	80028dc <app_debug_rtt_raw>
  if (p != NULL) {
 8010784:	6a3b      	ldr	r3, [r7, #32]
 8010786:	2b00      	cmp	r3, #0
 8010788:	d003      	beq.n	8010792 <tcp_split_unsent_seg+0x45a>
    pbuf_free(p);
 801078a:	6a3b      	ldr	r3, [r7, #32]
 801078c:	0018      	movs	r0, r3
 801078e:	f7f9 fa1f 	bl	8009bd0 <pbuf_free>
  }

  return ERR_MEM;
 8010792:	2301      	movs	r3, #1
 8010794:	425b      	negs	r3, r3
}
 8010796:	0018      	movs	r0, r3
 8010798:	46bd      	mov	sp, r7
 801079a:	b00b      	add	sp, #44	; 0x2c
 801079c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801079e:	46c0      	nop			; (mov r8, r8)
 80107a0:	08020658 	.word	0x08020658
 80107a4:	000003d9 	.word	0x000003d9
 80107a8:	08020b30 	.word	0x08020b30
 80107ac:	080206a4 	.word	0x080206a4

080107b0 <tcp_send_fin>:
 * @param pcb the tcp_pcb over which to send a segment
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_fin(struct tcp_pcb *pcb)
{
 80107b0:	b590      	push	{r4, r7, lr}
 80107b2:	b085      	sub	sp, #20
 80107b4:	af00      	add	r7, sp, #0
 80107b6:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_send_fin: invalid pcb", pcb != NULL);
 80107b8:	687b      	ldr	r3, [r7, #4]
 80107ba:	2b00      	cmp	r3, #0
 80107bc:	d106      	bne.n	80107cc <tcp_send_fin+0x1c>
 80107be:	4b2e      	ldr	r3, [pc, #184]	; (8010878 <tcp_send_fin+0xc8>)
 80107c0:	22fb      	movs	r2, #251	; 0xfb
 80107c2:	0092      	lsls	r2, r2, #2
 80107c4:	492d      	ldr	r1, [pc, #180]	; (801087c <tcp_send_fin+0xcc>)
 80107c6:	482e      	ldr	r0, [pc, #184]	; (8010880 <tcp_send_fin+0xd0>)
 80107c8:	f7f2 f888 	bl	80028dc <app_debug_rtt_raw>

  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
 80107cc:	687b      	ldr	r3, [r7, #4]
 80107ce:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80107d0:	2b00      	cmp	r3, #0
 80107d2:	d046      	beq.n	8010862 <tcp_send_fin+0xb2>
    struct tcp_seg *last_unsent;
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 80107d4:	687b      	ldr	r3, [r7, #4]
 80107d6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80107d8:	60fb      	str	r3, [r7, #12]
 80107da:	e002      	b.n	80107e2 <tcp_send_fin+0x32>
         last_unsent = last_unsent->next);
 80107dc:	68fb      	ldr	r3, [r7, #12]
 80107de:	681b      	ldr	r3, [r3, #0]
 80107e0:	60fb      	str	r3, [r7, #12]
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 80107e2:	68fb      	ldr	r3, [r7, #12]
 80107e4:	681b      	ldr	r3, [r3, #0]
 80107e6:	2b00      	cmp	r3, #0
 80107e8:	d1f8      	bne.n	80107dc <tcp_send_fin+0x2c>

    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
 80107ea:	68fb      	ldr	r3, [r7, #12]
 80107ec:	691b      	ldr	r3, [r3, #16]
 80107ee:	7b1a      	ldrb	r2, [r3, #12]
 80107f0:	7b5b      	ldrb	r3, [r3, #13]
 80107f2:	021b      	lsls	r3, r3, #8
 80107f4:	4313      	orrs	r3, r2
 80107f6:	b29b      	uxth	r3, r3
 80107f8:	0018      	movs	r0, r3
 80107fa:	f7f6 fa05 	bl	8006c08 <lwip_htons>
 80107fe:	0003      	movs	r3, r0
 8010800:	b2db      	uxtb	r3, r3
 8010802:	001a      	movs	r2, r3
 8010804:	2307      	movs	r3, #7
 8010806:	4013      	ands	r3, r2
 8010808:	d12b      	bne.n	8010862 <tcp_send_fin+0xb2>
      /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
 801080a:	68fb      	ldr	r3, [r7, #12]
 801080c:	691b      	ldr	r3, [r3, #16]
 801080e:	7b1a      	ldrb	r2, [r3, #12]
 8010810:	7b5b      	ldrb	r3, [r3, #13]
 8010812:	021b      	lsls	r3, r3, #8
 8010814:	4313      	orrs	r3, r2
 8010816:	b29c      	uxth	r4, r3
 8010818:	2001      	movs	r0, #1
 801081a:	f7f6 f9f5 	bl	8006c08 <lwip_htons>
 801081e:	0003      	movs	r3, r0
 8010820:	001a      	movs	r2, r3
 8010822:	68fb      	ldr	r3, [r7, #12]
 8010824:	691b      	ldr	r3, [r3, #16]
 8010826:	4322      	orrs	r2, r4
 8010828:	b292      	uxth	r2, r2
 801082a:	21ff      	movs	r1, #255	; 0xff
 801082c:	4011      	ands	r1, r2
 801082e:	000c      	movs	r4, r1
 8010830:	7b19      	ldrb	r1, [r3, #12]
 8010832:	2000      	movs	r0, #0
 8010834:	4001      	ands	r1, r0
 8010836:	1c08      	adds	r0, r1, #0
 8010838:	1c21      	adds	r1, r4, #0
 801083a:	4301      	orrs	r1, r0
 801083c:	7319      	strb	r1, [r3, #12]
 801083e:	0a12      	lsrs	r2, r2, #8
 8010840:	b290      	uxth	r0, r2
 8010842:	7b5a      	ldrb	r2, [r3, #13]
 8010844:	2100      	movs	r1, #0
 8010846:	400a      	ands	r2, r1
 8010848:	1c11      	adds	r1, r2, #0
 801084a:	1c02      	adds	r2, r0, #0
 801084c:	430a      	orrs	r2, r1
 801084e:	735a      	strb	r2, [r3, #13]
      tcp_set_flags(pcb, TF_FIN);
 8010850:	687b      	ldr	r3, [r7, #4]
 8010852:	8bdb      	ldrh	r3, [r3, #30]
 8010854:	2220      	movs	r2, #32
 8010856:	4313      	orrs	r3, r2
 8010858:	b29a      	uxth	r2, r3
 801085a:	687b      	ldr	r3, [r7, #4]
 801085c:	83da      	strh	r2, [r3, #30]
      return ERR_OK;
 801085e:	2300      	movs	r3, #0
 8010860:	e005      	b.n	801086e <tcp_send_fin+0xbe>
    }
  }
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue_flags(pcb, TCP_FIN);
 8010862:	687b      	ldr	r3, [r7, #4]
 8010864:	2101      	movs	r1, #1
 8010866:	0018      	movs	r0, r3
 8010868:	f000 f80c 	bl	8010884 <tcp_enqueue_flags>
 801086c:	0003      	movs	r3, r0
}
 801086e:	0018      	movs	r0, r3
 8010870:	46bd      	mov	sp, r7
 8010872:	b005      	add	sp, #20
 8010874:	bd90      	pop	{r4, r7, pc}
 8010876:	46c0      	nop			; (mov r8, r8)
 8010878:	08020658 	.word	0x08020658
 801087c:	08020b3c 	.word	0x08020b3c
 8010880:	080206a4 	.word	0x080206a4

08010884 <tcp_enqueue_flags>:
 * @param pcb Protocol control block for the TCP connection.
 * @param flags TCP header flags to set in the outgoing segment.
 */
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
 8010884:	b590      	push	{r4, r7, lr}
 8010886:	b089      	sub	sp, #36	; 0x24
 8010888:	af02      	add	r7, sp, #8
 801088a:	6078      	str	r0, [r7, #4]
 801088c:	000a      	movs	r2, r1
 801088e:	1cfb      	adds	r3, r7, #3
 8010890:	701a      	strb	r2, [r3, #0]
  struct pbuf *p;
  struct tcp_seg *seg;
  u8_t optflags = 0;
 8010892:	2317      	movs	r3, #23
 8010894:	18fb      	adds	r3, r7, r3
 8010896:	2200      	movs	r2, #0
 8010898:	701a      	strb	r2, [r3, #0]
  u8_t optlen = 0;
 801089a:	2316      	movs	r3, #22
 801089c:	18fb      	adds	r3, r7, r3
 801089e:	2200      	movs	r2, #0
 80108a0:	701a      	strb	r2, [r3, #0]

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
 80108a2:	1cfb      	adds	r3, r7, #3
 80108a4:	781b      	ldrb	r3, [r3, #0]
 80108a6:	2203      	movs	r2, #3
 80108a8:	4013      	ands	r3, r2
 80108aa:	d105      	bne.n	80108b8 <tcp_enqueue_flags+0x34>
 80108ac:	4b6a      	ldr	r3, [pc, #424]	; (8010a58 <tcp_enqueue_flags+0x1d4>)
 80108ae:	4a6b      	ldr	r2, [pc, #428]	; (8010a5c <tcp_enqueue_flags+0x1d8>)
 80108b0:	496b      	ldr	r1, [pc, #428]	; (8010a60 <tcp_enqueue_flags+0x1dc>)
 80108b2:	486c      	ldr	r0, [pc, #432]	; (8010a64 <tcp_enqueue_flags+0x1e0>)
 80108b4:	f7f2 f812 	bl	80028dc <app_debug_rtt_raw>
              (flags & (TCP_SYN | TCP_FIN)) != 0);
  LWIP_ASSERT("tcp_enqueue_flags: invalid pcb", pcb != NULL);
 80108b8:	687b      	ldr	r3, [r7, #4]
 80108ba:	2b00      	cmp	r3, #0
 80108bc:	d105      	bne.n	80108ca <tcp_enqueue_flags+0x46>
 80108be:	4b66      	ldr	r3, [pc, #408]	; (8010a58 <tcp_enqueue_flags+0x1d4>)
 80108c0:	4a69      	ldr	r2, [pc, #420]	; (8010a68 <tcp_enqueue_flags+0x1e4>)
 80108c2:	496a      	ldr	r1, [pc, #424]	; (8010a6c <tcp_enqueue_flags+0x1e8>)
 80108c4:	4867      	ldr	r0, [pc, #412]	; (8010a64 <tcp_enqueue_flags+0x1e0>)
 80108c6:	f7f2 f809 	bl	80028dc <app_debug_rtt_raw>

  /* No need to check pcb->snd_queuelen if only SYN or FIN are allowed! */

  /* Get options for this segment. This is a special case since this is the
     only place where a SYN can be sent. */
  if (flags & TCP_SYN) {
 80108ca:	1cfb      	adds	r3, r7, #3
 80108cc:	781b      	ldrb	r3, [r3, #0]
 80108ce:	2202      	movs	r2, #2
 80108d0:	4013      	ands	r3, r2
 80108d2:	d003      	beq.n	80108dc <tcp_enqueue_flags+0x58>
    optflags = TF_SEG_OPTS_MSS;
 80108d4:	2317      	movs	r3, #23
 80108d6:	18fb      	adds	r3, r7, r3
 80108d8:	2201      	movs	r2, #1
 80108da:	701a      	strb	r2, [r3, #0]
    /* Make sure the timestamp option is only included in data segments if we
       agreed about it with the remote host (and in active open SYN segments). */
    optflags |= TF_SEG_OPTS_TS;
  }
#endif /* LWIP_TCP_TIMESTAMPS */
  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
 80108dc:	2317      	movs	r3, #23
 80108de:	18fb      	adds	r3, r7, r3
 80108e0:	781b      	ldrb	r3, [r3, #0]
 80108e2:	009b      	lsls	r3, r3, #2
 80108e4:	b2da      	uxtb	r2, r3
 80108e6:	2016      	movs	r0, #22
 80108e8:	183b      	adds	r3, r7, r0
 80108ea:	2104      	movs	r1, #4
 80108ec:	400a      	ands	r2, r1
 80108ee:	701a      	strb	r2, [r3, #0]

  /* Allocate pbuf with room for TCP header + options */
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 80108f0:	183b      	adds	r3, r7, r0
 80108f2:	781b      	ldrb	r3, [r3, #0]
 80108f4:	b29b      	uxth	r3, r3
 80108f6:	22a0      	movs	r2, #160	; 0xa0
 80108f8:	0092      	lsls	r2, r2, #2
 80108fa:	0019      	movs	r1, r3
 80108fc:	2038      	movs	r0, #56	; 0x38
 80108fe:	f7f8 fdef 	bl	80094e0 <pbuf_alloc>
 8010902:	0003      	movs	r3, r0
 8010904:	60fb      	str	r3, [r7, #12]
 8010906:	68fb      	ldr	r3, [r7, #12]
 8010908:	2b00      	cmp	r3, #0
 801090a:	d109      	bne.n	8010920 <tcp_enqueue_flags+0x9c>
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
 801090c:	687b      	ldr	r3, [r7, #4]
 801090e:	8bdb      	ldrh	r3, [r3, #30]
 8010910:	2280      	movs	r2, #128	; 0x80
 8010912:	4313      	orrs	r3, r2
 8010914:	b29a      	uxth	r2, r3
 8010916:	687b      	ldr	r3, [r7, #4]
 8010918:	83da      	strh	r2, [r3, #30]
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
 801091a:	2301      	movs	r3, #1
 801091c:	425b      	negs	r3, r3
 801091e:	e097      	b.n	8010a50 <tcp_enqueue_flags+0x1cc>
  }
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
 8010920:	68fb      	ldr	r3, [r7, #12]
 8010922:	895a      	ldrh	r2, [r3, #10]
 8010924:	2316      	movs	r3, #22
 8010926:	18fb      	adds	r3, r7, r3
 8010928:	781b      	ldrb	r3, [r3, #0]
 801092a:	b29b      	uxth	r3, r3
 801092c:	429a      	cmp	r2, r3
 801092e:	d205      	bcs.n	801093c <tcp_enqueue_flags+0xb8>
 8010930:	4b49      	ldr	r3, [pc, #292]	; (8010a58 <tcp_enqueue_flags+0x1d4>)
 8010932:	4a4f      	ldr	r2, [pc, #316]	; (8010a70 <tcp_enqueue_flags+0x1ec>)
 8010934:	494f      	ldr	r1, [pc, #316]	; (8010a74 <tcp_enqueue_flags+0x1f0>)
 8010936:	484b      	ldr	r0, [pc, #300]	; (8010a64 <tcp_enqueue_flags+0x1e0>)
 8010938:	f7f1 ffd0 	bl	80028dc <app_debug_rtt_raw>
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
 801093c:	687b      	ldr	r3, [r7, #4]
 801093e:	6e1c      	ldr	r4, [r3, #96]	; 0x60
 8010940:	1cfb      	adds	r3, r7, #3
 8010942:	781a      	ldrb	r2, [r3, #0]
 8010944:	68f9      	ldr	r1, [r7, #12]
 8010946:	6878      	ldr	r0, [r7, #4]
 8010948:	2317      	movs	r3, #23
 801094a:	18fb      	adds	r3, r7, r3
 801094c:	781b      	ldrb	r3, [r3, #0]
 801094e:	9300      	str	r3, [sp, #0]
 8010950:	0023      	movs	r3, r4
 8010952:	f7fe fd19 	bl	800f388 <tcp_create_segment>
 8010956:	0003      	movs	r3, r0
 8010958:	60bb      	str	r3, [r7, #8]
 801095a:	68bb      	ldr	r3, [r7, #8]
 801095c:	2b00      	cmp	r3, #0
 801095e:	d109      	bne.n	8010974 <tcp_enqueue_flags+0xf0>
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
 8010960:	687b      	ldr	r3, [r7, #4]
 8010962:	8bdb      	ldrh	r3, [r3, #30]
 8010964:	2280      	movs	r2, #128	; 0x80
 8010966:	4313      	orrs	r3, r2
 8010968:	b29a      	uxth	r2, r3
 801096a:	687b      	ldr	r3, [r7, #4]
 801096c:	83da      	strh	r2, [r3, #30]
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
 801096e:	2301      	movs	r3, #1
 8010970:	425b      	negs	r3, r3
 8010972:	e06d      	b.n	8010a50 <tcp_enqueue_flags+0x1cc>
  }
  LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % LWIP_MIN(MEM_ALIGNMENT, 4)) == 0);
 8010974:	68bb      	ldr	r3, [r7, #8]
 8010976:	691b      	ldr	r3, [r3, #16]
 8010978:	001a      	movs	r2, r3
 801097a:	2303      	movs	r3, #3
 801097c:	4013      	ands	r3, r2
 801097e:	d005      	beq.n	801098c <tcp_enqueue_flags+0x108>
 8010980:	4b35      	ldr	r3, [pc, #212]	; (8010a58 <tcp_enqueue_flags+0x1d4>)
 8010982:	4a3d      	ldr	r2, [pc, #244]	; (8010a78 <tcp_enqueue_flags+0x1f4>)
 8010984:	493d      	ldr	r1, [pc, #244]	; (8010a7c <tcp_enqueue_flags+0x1f8>)
 8010986:	4837      	ldr	r0, [pc, #220]	; (8010a64 <tcp_enqueue_flags+0x1e0>)
 8010988:	f7f1 ffa8 	bl	80028dc <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
 801098c:	68bb      	ldr	r3, [r7, #8]
 801098e:	891b      	ldrh	r3, [r3, #8]
 8010990:	2b00      	cmp	r3, #0
 8010992:	d005      	beq.n	80109a0 <tcp_enqueue_flags+0x11c>
 8010994:	4b30      	ldr	r3, [pc, #192]	; (8010a58 <tcp_enqueue_flags+0x1d4>)
 8010996:	4a3a      	ldr	r2, [pc, #232]	; (8010a80 <tcp_enqueue_flags+0x1fc>)
 8010998:	493a      	ldr	r1, [pc, #232]	; (8010a84 <tcp_enqueue_flags+0x200>)
 801099a:	4832      	ldr	r0, [pc, #200]	; (8010a64 <tcp_enqueue_flags+0x1e0>)
 801099c:	f7f1 ff9e 	bl	80028dc <app_debug_rtt_raw>
               lwip_ntohl(seg->tcphdr->seqno),
               lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
 80109a0:	687b      	ldr	r3, [r7, #4]
 80109a2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80109a4:	2b00      	cmp	r3, #0
 80109a6:	d103      	bne.n	80109b0 <tcp_enqueue_flags+0x12c>
    pcb->unsent = seg;
 80109a8:	687b      	ldr	r3, [r7, #4]
 80109aa:	68ba      	ldr	r2, [r7, #8]
 80109ac:	671a      	str	r2, [r3, #112]	; 0x70
 80109ae:	e00d      	b.n	80109cc <tcp_enqueue_flags+0x148>
  } else {
    struct tcp_seg *useg;
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
 80109b0:	687b      	ldr	r3, [r7, #4]
 80109b2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80109b4:	613b      	str	r3, [r7, #16]
 80109b6:	e002      	b.n	80109be <tcp_enqueue_flags+0x13a>
 80109b8:	693b      	ldr	r3, [r7, #16]
 80109ba:	681b      	ldr	r3, [r3, #0]
 80109bc:	613b      	str	r3, [r7, #16]
 80109be:	693b      	ldr	r3, [r7, #16]
 80109c0:	681b      	ldr	r3, [r3, #0]
 80109c2:	2b00      	cmp	r3, #0
 80109c4:	d1f8      	bne.n	80109b8 <tcp_enqueue_flags+0x134>
    useg->next = seg;
 80109c6:	693b      	ldr	r3, [r7, #16]
 80109c8:	68ba      	ldr	r2, [r7, #8]
 80109ca:	601a      	str	r2, [r3, #0]
  }
#if TCP_OVERSIZE
  /* The new unsent tail has no space */
  pcb->unsent_oversize = 0;
 80109cc:	687b      	ldr	r3, [r7, #4]
 80109ce:	226c      	movs	r2, #108	; 0x6c
 80109d0:	2100      	movs	r1, #0
 80109d2:	5299      	strh	r1, [r3, r2]
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
 80109d4:	1cfb      	adds	r3, r7, #3
 80109d6:	781b      	ldrb	r3, [r3, #0]
 80109d8:	2202      	movs	r2, #2
 80109da:	4013      	ands	r3, r2
 80109dc:	d104      	bne.n	80109e8 <tcp_enqueue_flags+0x164>
 80109de:	1cfb      	adds	r3, r7, #3
 80109e0:	781b      	ldrb	r3, [r3, #0]
 80109e2:	2201      	movs	r2, #1
 80109e4:	4013      	ands	r3, r2
 80109e6:	d004      	beq.n	80109f2 <tcp_enqueue_flags+0x16e>
    pcb->snd_lbb++;
 80109e8:	687b      	ldr	r3, [r7, #4]
 80109ea:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80109ec:	1c5a      	adds	r2, r3, #1
 80109ee:	687b      	ldr	r3, [r7, #4]
 80109f0:	661a      	str	r2, [r3, #96]	; 0x60
    /* optlen does not influence snd_buf */
  }
  if (flags & TCP_FIN) {
 80109f2:	1cfb      	adds	r3, r7, #3
 80109f4:	781b      	ldrb	r3, [r3, #0]
 80109f6:	2201      	movs	r2, #1
 80109f8:	4013      	ands	r3, r2
 80109fa:	d006      	beq.n	8010a0a <tcp_enqueue_flags+0x186>
    tcp_set_flags(pcb, TF_FIN);
 80109fc:	687b      	ldr	r3, [r7, #4]
 80109fe:	8bdb      	ldrh	r3, [r3, #30]
 8010a00:	2220      	movs	r2, #32
 8010a02:	4313      	orrs	r3, r2
 8010a04:	b29a      	uxth	r2, r3
 8010a06:	687b      	ldr	r3, [r7, #4]
 8010a08:	83da      	strh	r2, [r3, #30]
  }

  /* update number of segments on the queues */
  pcb->snd_queuelen += pbuf_clen(seg->p);
 8010a0a:	68bb      	ldr	r3, [r7, #8]
 8010a0c:	685b      	ldr	r3, [r3, #4]
 8010a0e:	0018      	movs	r0, r3
 8010a10:	f7f9 f97e 	bl	8009d10 <pbuf_clen>
 8010a14:	0003      	movs	r3, r0
 8010a16:	0019      	movs	r1, r3
 8010a18:	687b      	ldr	r3, [r7, #4]
 8010a1a:	226a      	movs	r2, #106	; 0x6a
 8010a1c:	5a9b      	ldrh	r3, [r3, r2]
 8010a1e:	18cb      	adds	r3, r1, r3
 8010a20:	b299      	uxth	r1, r3
 8010a22:	687b      	ldr	r3, [r7, #4]
 8010a24:	226a      	movs	r2, #106	; 0x6a
 8010a26:	5299      	strh	r1, [r3, r2]
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
 8010a28:	687b      	ldr	r3, [r7, #4]
 8010a2a:	226a      	movs	r2, #106	; 0x6a
 8010a2c:	5a9b      	ldrh	r3, [r3, r2]
 8010a2e:	2b00      	cmp	r3, #0
 8010a30:	d00d      	beq.n	8010a4e <tcp_enqueue_flags+0x1ca>
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
 8010a32:	687b      	ldr	r3, [r7, #4]
 8010a34:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8010a36:	2b00      	cmp	r3, #0
 8010a38:	d109      	bne.n	8010a4e <tcp_enqueue_flags+0x1ca>
 8010a3a:	687b      	ldr	r3, [r7, #4]
 8010a3c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010a3e:	2b00      	cmp	r3, #0
 8010a40:	d105      	bne.n	8010a4e <tcp_enqueue_flags+0x1ca>
 8010a42:	4b05      	ldr	r3, [pc, #20]	; (8010a58 <tcp_enqueue_flags+0x1d4>)
 8010a44:	4a10      	ldr	r2, [pc, #64]	; (8010a88 <tcp_enqueue_flags+0x204>)
 8010a46:	4911      	ldr	r1, [pc, #68]	; (8010a8c <tcp_enqueue_flags+0x208>)
 8010a48:	4806      	ldr	r0, [pc, #24]	; (8010a64 <tcp_enqueue_flags+0x1e0>)
 8010a4a:	f7f1 ff47 	bl	80028dc <app_debug_rtt_raw>
                pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
 8010a4e:	2300      	movs	r3, #0
}
 8010a50:	0018      	movs	r0, r3
 8010a52:	46bd      	mov	sp, r7
 8010a54:	b007      	add	sp, #28
 8010a56:	bd90      	pop	{r4, r7, pc}
 8010a58:	08020658 	.word	0x08020658
 8010a5c:	00000412 	.word	0x00000412
 8010a60:	08020b58 	.word	0x08020b58
 8010a64:	080206a4 	.word	0x080206a4
 8010a68:	00000414 	.word	0x00000414
 8010a6c:	08020bb0 	.word	0x08020bb0
 8010a70:	0000043a 	.word	0x0000043a
 8010a74:	08020bd0 	.word	0x08020bd0
 8010a78:	00000443 	.word	0x00000443
 8010a7c:	08020c0c 	.word	0x08020c0c
 8010a80:	00000444 	.word	0x00000444
 8010a84:	08020c24 	.word	0x08020c24
 8010a88:	00000466 	.word	0x00000466
 8010a8c:	08020c50 	.word	0x08020c50

08010a90 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
 8010a90:	b5b0      	push	{r4, r5, r7, lr}
 8010a92:	b08a      	sub	sp, #40	; 0x28
 8010a94:	af00      	add	r7, sp, #0
 8010a96:	6078      	str	r0, [r7, #4]
  s16_t i = 0;
#endif /* TCP_CWND_DEBUG */

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ASSERT("tcp_output: invalid pcb", pcb != NULL);
 8010a98:	687b      	ldr	r3, [r7, #4]
 8010a9a:	2b00      	cmp	r3, #0
 8010a9c:	d105      	bne.n	8010aaa <tcp_output+0x1a>
 8010a9e:	4bcb      	ldr	r3, [pc, #812]	; (8010dcc <tcp_output+0x33c>)
 8010aa0:	4acb      	ldr	r2, [pc, #812]	; (8010dd0 <tcp_output+0x340>)
 8010aa2:	49cc      	ldr	r1, [pc, #816]	; (8010dd4 <tcp_output+0x344>)
 8010aa4:	48cc      	ldr	r0, [pc, #816]	; (8010dd8 <tcp_output+0x348>)
 8010aa6:	f7f1 ff19 	bl	80028dc <app_debug_rtt_raw>
  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_output for listen-pcbs",
 8010aaa:	687b      	ldr	r3, [r7, #4]
 8010aac:	7e1b      	ldrb	r3, [r3, #24]
 8010aae:	2b01      	cmp	r3, #1
 8010ab0:	d105      	bne.n	8010abe <tcp_output+0x2e>
 8010ab2:	4bc6      	ldr	r3, [pc, #792]	; (8010dcc <tcp_output+0x33c>)
 8010ab4:	4ac9      	ldr	r2, [pc, #804]	; (8010ddc <tcp_output+0x34c>)
 8010ab6:	49ca      	ldr	r1, [pc, #808]	; (8010de0 <tcp_output+0x350>)
 8010ab8:	48c7      	ldr	r0, [pc, #796]	; (8010dd8 <tcp_output+0x348>)
 8010aba:	f7f1 ff0f 	bl	80028dc <app_debug_rtt_raw>

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
 8010abe:	4bc9      	ldr	r3, [pc, #804]	; (8010de4 <tcp_output+0x354>)
 8010ac0:	681b      	ldr	r3, [r3, #0]
 8010ac2:	687a      	ldr	r2, [r7, #4]
 8010ac4:	429a      	cmp	r2, r3
 8010ac6:	d101      	bne.n	8010acc <tcp_output+0x3c>
    return ERR_OK;
 8010ac8:	2300      	movs	r3, #0
 8010aca:	e23d      	b.n	8010f48 <tcp_output+0x4b8>
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
 8010acc:	687b      	ldr	r3, [r7, #4]
 8010ace:	224c      	movs	r2, #76	; 0x4c
 8010ad0:	5a99      	ldrh	r1, [r3, r2]
 8010ad2:	687b      	ldr	r3, [r7, #4]
 8010ad4:	2264      	movs	r2, #100	; 0x64
 8010ad6:	5a9b      	ldrh	r3, [r3, r2]
 8010ad8:	1c18      	adds	r0, r3, #0
 8010ada:	b28a      	uxth	r2, r1
 8010adc:	b283      	uxth	r3, r0
 8010ade:	429a      	cmp	r2, r3
 8010ae0:	d900      	bls.n	8010ae4 <tcp_output+0x54>
 8010ae2:	1c01      	adds	r1, r0, #0
 8010ae4:	b28b      	uxth	r3, r1
 8010ae6:	61bb      	str	r3, [r7, #24]

  seg = pcb->unsent;
 8010ae8:	687b      	ldr	r3, [r7, #4]
 8010aea:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010aec:	627b      	str	r3, [r7, #36]	; 0x24

  if (seg == NULL) {
 8010aee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010af0:	2b00      	cmp	r3, #0
 8010af2:	d10c      	bne.n	8010b0e <tcp_output+0x7e>
                                 ", seg == NULL, ack %"U32_F"\n",
                                 pcb->snd_wnd, pcb->cwnd, wnd, pcb->lastack));

    /* If the TF_ACK_NOW flag is set and the ->unsent queue is empty, construct
     * an empty ACK segment and send it. */
    if (pcb->flags & TF_ACK_NOW) {
 8010af4:	687b      	ldr	r3, [r7, #4]
 8010af6:	8bdb      	ldrh	r3, [r3, #30]
 8010af8:	001a      	movs	r2, r3
 8010afa:	2302      	movs	r3, #2
 8010afc:	4013      	ands	r3, r2
 8010afe:	d100      	bne.n	8010b02 <tcp_output+0x72>
 8010b00:	e215      	b.n	8010f2e <tcp_output+0x49e>
      return tcp_send_empty_ack(pcb);
 8010b02:	687b      	ldr	r3, [r7, #4]
 8010b04:	0018      	movs	r0, r3
 8010b06:	f001 f877 	bl	8011bf8 <tcp_send_empty_ack>
 8010b0a:	0003      	movs	r3, r0
 8010b0c:	e21c      	b.n	8010f48 <tcp_output+0x4b8>
                 pcb->snd_wnd, pcb->cwnd, wnd,
                 lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 lwip_ntohl(seg->tcphdr->seqno), pcb->lastack));
  }

  netif = tcp_route(pcb, &pcb->local_ip, &pcb->remote_ip);
 8010b0e:	6879      	ldr	r1, [r7, #4]
 8010b10:	687b      	ldr	r3, [r7, #4]
 8010b12:	1d1a      	adds	r2, r3, #4
 8010b14:	687b      	ldr	r3, [r7, #4]
 8010b16:	0018      	movs	r0, r3
 8010b18:	f7fe fc18 	bl	800f34c <tcp_route>
 8010b1c:	0003      	movs	r3, r0
 8010b1e:	617b      	str	r3, [r7, #20]
  if (netif == NULL) {
 8010b20:	697b      	ldr	r3, [r7, #20]
 8010b22:	2b00      	cmp	r3, #0
 8010b24:	d102      	bne.n	8010b2c <tcp_output+0x9c>
    return ERR_RTE;
 8010b26:	2304      	movs	r3, #4
 8010b28:	425b      	negs	r3, r3
 8010b2a:	e20d      	b.n	8010f48 <tcp_output+0x4b8>
  }

  /* If we don't have a local IP address, we get one from netif */
  if (ip_addr_isany(&pcb->local_ip)) {
 8010b2c:	687b      	ldr	r3, [r7, #4]
 8010b2e:	2b00      	cmp	r3, #0
 8010b30:	d003      	beq.n	8010b3a <tcp_output+0xaa>
 8010b32:	687b      	ldr	r3, [r7, #4]
 8010b34:	681b      	ldr	r3, [r3, #0]
 8010b36:	2b00      	cmp	r3, #0
 8010b38:	d111      	bne.n	8010b5e <tcp_output+0xce>
    const ip_addr_t *local_ip = ip_netif_get_local_ip(netif, &pcb->remote_ip);
 8010b3a:	697b      	ldr	r3, [r7, #20]
 8010b3c:	2b00      	cmp	r3, #0
 8010b3e:	d002      	beq.n	8010b46 <tcp_output+0xb6>
 8010b40:	697b      	ldr	r3, [r7, #20]
 8010b42:	3304      	adds	r3, #4
 8010b44:	e000      	b.n	8010b48 <tcp_output+0xb8>
 8010b46:	2300      	movs	r3, #0
 8010b48:	613b      	str	r3, [r7, #16]
    if (local_ip == NULL) {
 8010b4a:	693b      	ldr	r3, [r7, #16]
 8010b4c:	2b00      	cmp	r3, #0
 8010b4e:	d102      	bne.n	8010b56 <tcp_output+0xc6>
      return ERR_RTE;
 8010b50:	2304      	movs	r3, #4
 8010b52:	425b      	negs	r3, r3
 8010b54:	e1f8      	b.n	8010f48 <tcp_output+0x4b8>
    }
    ip_addr_copy(pcb->local_ip, *local_ip);
 8010b56:	693b      	ldr	r3, [r7, #16]
 8010b58:	681a      	ldr	r2, [r3, #0]
 8010b5a:	687b      	ldr	r3, [r7, #4]
 8010b5c:	601a      	str	r2, [r3, #0]
  }

  /* Handle the current segment not fitting within the window */
  if (lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd) {
 8010b5e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010b60:	691b      	ldr	r3, [r3, #16]
 8010b62:	791a      	ldrb	r2, [r3, #4]
 8010b64:	7959      	ldrb	r1, [r3, #5]
 8010b66:	0209      	lsls	r1, r1, #8
 8010b68:	430a      	orrs	r2, r1
 8010b6a:	7999      	ldrb	r1, [r3, #6]
 8010b6c:	0409      	lsls	r1, r1, #16
 8010b6e:	430a      	orrs	r2, r1
 8010b70:	79db      	ldrb	r3, [r3, #7]
 8010b72:	061b      	lsls	r3, r3, #24
 8010b74:	4313      	orrs	r3, r2
 8010b76:	0018      	movs	r0, r3
 8010b78:	f7f6 f85c 	bl	8006c34 <lwip_htonl>
 8010b7c:	0002      	movs	r2, r0
 8010b7e:	687b      	ldr	r3, [r7, #4]
 8010b80:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8010b82:	1ad3      	subs	r3, r2, r3
 8010b84:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8010b86:	8912      	ldrh	r2, [r2, #8]
 8010b88:	189b      	adds	r3, r3, r2
 8010b8a:	69ba      	ldr	r2, [r7, #24]
 8010b8c:	429a      	cmp	r2, r3
 8010b8e:	d228      	bcs.n	8010be2 <tcp_output+0x152>
     * within the remaining (could be 0) send window and RTO timer is not running (we
     * have no in-flight data). If window is still too small after persist timer fires,
     * then we split the segment. We don't consider the congestion window since a cwnd
     * smaller than 1 SMSS implies in-flight data
     */
    if (wnd == pcb->snd_wnd && pcb->unacked == NULL && pcb->persist_backoff == 0) {
 8010b90:	687b      	ldr	r3, [r7, #4]
 8010b92:	2264      	movs	r2, #100	; 0x64
 8010b94:	5a9b      	ldrh	r3, [r3, r2]
 8010b96:	001a      	movs	r2, r3
 8010b98:	69bb      	ldr	r3, [r7, #24]
 8010b9a:	4293      	cmp	r3, r2
 8010b9c:	d114      	bne.n	8010bc8 <tcp_output+0x138>
 8010b9e:	687b      	ldr	r3, [r7, #4]
 8010ba0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8010ba2:	2b00      	cmp	r3, #0
 8010ba4:	d110      	bne.n	8010bc8 <tcp_output+0x138>
 8010ba6:	687b      	ldr	r3, [r7, #4]
 8010ba8:	22a5      	movs	r2, #165	; 0xa5
 8010baa:	5c9b      	ldrb	r3, [r3, r2]
 8010bac:	2b00      	cmp	r3, #0
 8010bae:	d10b      	bne.n	8010bc8 <tcp_output+0x138>
      pcb->persist_cnt = 0;
 8010bb0:	687b      	ldr	r3, [r7, #4]
 8010bb2:	22a4      	movs	r2, #164	; 0xa4
 8010bb4:	2100      	movs	r1, #0
 8010bb6:	5499      	strb	r1, [r3, r2]
      pcb->persist_backoff = 1;
 8010bb8:	687b      	ldr	r3, [r7, #4]
 8010bba:	22a5      	movs	r2, #165	; 0xa5
 8010bbc:	2101      	movs	r1, #1
 8010bbe:	5499      	strb	r1, [r3, r2]
      pcb->persist_probe = 0;
 8010bc0:	687b      	ldr	r3, [r7, #4]
 8010bc2:	22a6      	movs	r2, #166	; 0xa6
 8010bc4:	2100      	movs	r1, #0
 8010bc6:	5499      	strb	r1, [r3, r2]
    }
    /* We need an ACK, but can't send data now, so send an empty ACK */
    if (pcb->flags & TF_ACK_NOW) {
 8010bc8:	687b      	ldr	r3, [r7, #4]
 8010bca:	8bdb      	ldrh	r3, [r3, #30]
 8010bcc:	001a      	movs	r2, r3
 8010bce:	2302      	movs	r3, #2
 8010bd0:	4013      	ands	r3, r2
 8010bd2:	d100      	bne.n	8010bd6 <tcp_output+0x146>
 8010bd4:	e1ad      	b.n	8010f32 <tcp_output+0x4a2>
      return tcp_send_empty_ack(pcb);
 8010bd6:	687b      	ldr	r3, [r7, #4]
 8010bd8:	0018      	movs	r0, r3
 8010bda:	f001 f80d 	bl	8011bf8 <tcp_send_empty_ack>
 8010bde:	0003      	movs	r3, r0
 8010be0:	e1b2      	b.n	8010f48 <tcp_output+0x4b8>
    }
    goto output_done;
  }
  /* Stop persist timer, above conditions are not active */
  pcb->persist_backoff = 0;
 8010be2:	687b      	ldr	r3, [r7, #4]
 8010be4:	22a5      	movs	r2, #165	; 0xa5
 8010be6:	2100      	movs	r1, #0
 8010be8:	5499      	strb	r1, [r3, r2]

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
 8010bea:	687b      	ldr	r3, [r7, #4]
 8010bec:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8010bee:	623b      	str	r3, [r7, #32]
  if (useg != NULL) {
 8010bf0:	6a3b      	ldr	r3, [r7, #32]
 8010bf2:	2b00      	cmp	r3, #0
 8010bf4:	d100      	bne.n	8010bf8 <tcp_output+0x168>
 8010bf6:	e172      	b.n	8010ede <tcp_output+0x44e>
    for (; useg->next != NULL; useg = useg->next);
 8010bf8:	e002      	b.n	8010c00 <tcp_output+0x170>
 8010bfa:	6a3b      	ldr	r3, [r7, #32]
 8010bfc:	681b      	ldr	r3, [r3, #0]
 8010bfe:	623b      	str	r3, [r7, #32]
 8010c00:	6a3b      	ldr	r3, [r7, #32]
 8010c02:	681b      	ldr	r3, [r3, #0]
 8010c04:	2b00      	cmp	r3, #0
 8010c06:	d1f8      	bne.n	8010bfa <tcp_output+0x16a>
  }
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 8010c08:	e169      	b.n	8010ede <tcp_output+0x44e>
         lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!",
 8010c0a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010c0c:	691b      	ldr	r3, [r3, #16]
 8010c0e:	7b1a      	ldrb	r2, [r3, #12]
 8010c10:	7b5b      	ldrb	r3, [r3, #13]
 8010c12:	021b      	lsls	r3, r3, #8
 8010c14:	4313      	orrs	r3, r2
 8010c16:	b29b      	uxth	r3, r3
 8010c18:	0018      	movs	r0, r3
 8010c1a:	f7f5 fff5 	bl	8006c08 <lwip_htons>
 8010c1e:	0003      	movs	r3, r0
 8010c20:	b2db      	uxtb	r3, r3
 8010c22:	001a      	movs	r2, r3
 8010c24:	2304      	movs	r3, #4
 8010c26:	4013      	ands	r3, r2
 8010c28:	d005      	beq.n	8010c36 <tcp_output+0x1a6>
 8010c2a:	4b68      	ldr	r3, [pc, #416]	; (8010dcc <tcp_output+0x33c>)
 8010c2c:	4a6e      	ldr	r2, [pc, #440]	; (8010de8 <tcp_output+0x358>)
 8010c2e:	496f      	ldr	r1, [pc, #444]	; (8010dec <tcp_output+0x35c>)
 8010c30:	4869      	ldr	r0, [pc, #420]	; (8010dd8 <tcp_output+0x348>)
 8010c32:	f7f1 fe53 	bl	80028dc <app_debug_rtt_raw>
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if ((tcp_do_output_nagle(pcb) == 0) &&
 8010c36:	687b      	ldr	r3, [r7, #4]
 8010c38:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8010c3a:	2b00      	cmp	r3, #0
 8010c3c:	d01f      	beq.n	8010c7e <tcp_output+0x1ee>
 8010c3e:	687b      	ldr	r3, [r7, #4]
 8010c40:	8bdb      	ldrh	r3, [r3, #30]
 8010c42:	001a      	movs	r2, r3
 8010c44:	2344      	movs	r3, #68	; 0x44
 8010c46:	4013      	ands	r3, r2
 8010c48:	d119      	bne.n	8010c7e <tcp_output+0x1ee>
 8010c4a:	687b      	ldr	r3, [r7, #4]
 8010c4c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010c4e:	2b00      	cmp	r3, #0
 8010c50:	d00b      	beq.n	8010c6a <tcp_output+0x1da>
 8010c52:	687b      	ldr	r3, [r7, #4]
 8010c54:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010c56:	681b      	ldr	r3, [r3, #0]
 8010c58:	2b00      	cmp	r3, #0
 8010c5a:	d110      	bne.n	8010c7e <tcp_output+0x1ee>
 8010c5c:	687b      	ldr	r3, [r7, #4]
 8010c5e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010c60:	891a      	ldrh	r2, [r3, #8]
 8010c62:	687b      	ldr	r3, [r7, #4]
 8010c64:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8010c66:	429a      	cmp	r2, r3
 8010c68:	d209      	bcs.n	8010c7e <tcp_output+0x1ee>
 8010c6a:	687b      	ldr	r3, [r7, #4]
 8010c6c:	2268      	movs	r2, #104	; 0x68
 8010c6e:	5a9b      	ldrh	r3, [r3, r2]
 8010c70:	2b00      	cmp	r3, #0
 8010c72:	d004      	beq.n	8010c7e <tcp_output+0x1ee>
 8010c74:	687b      	ldr	r3, [r7, #4]
 8010c76:	226a      	movs	r2, #106	; 0x6a
 8010c78:	5a9b      	ldrh	r3, [r3, r2]
 8010c7a:	2b07      	cmp	r3, #7
 8010c7c:	d901      	bls.n	8010c82 <tcp_output+0x1f2>
 8010c7e:	2301      	movs	r3, #1
 8010c80:	e000      	b.n	8010c84 <tcp_output+0x1f4>
 8010c82:	2300      	movs	r3, #0
 8010c84:	2b00      	cmp	r3, #0
 8010c86:	d106      	bne.n	8010c96 <tcp_output+0x206>
        ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)) {
 8010c88:	687b      	ldr	r3, [r7, #4]
 8010c8a:	8bdb      	ldrh	r3, [r3, #30]
 8010c8c:	001a      	movs	r2, r3
 8010c8e:	23a0      	movs	r3, #160	; 0xa0
 8010c90:	4013      	ands	r3, r2
    if ((tcp_do_output_nagle(pcb) == 0) &&
 8010c92:	d100      	bne.n	8010c96 <tcp_output+0x206>
 8010c94:	e141      	b.n	8010f1a <tcp_output+0x48a>
                                 pcb->lastack,
                                 lwip_ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    if (pcb->state != SYN_SENT) {
 8010c96:	687b      	ldr	r3, [r7, #4]
 8010c98:	7e1b      	ldrb	r3, [r3, #24]
 8010c9a:	2b02      	cmp	r3, #2
 8010c9c:	d022      	beq.n	8010ce4 <tcp_output+0x254>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
 8010c9e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010ca0:	691b      	ldr	r3, [r3, #16]
 8010ca2:	7b1a      	ldrb	r2, [r3, #12]
 8010ca4:	7b5b      	ldrb	r3, [r3, #13]
 8010ca6:	021b      	lsls	r3, r3, #8
 8010ca8:	4313      	orrs	r3, r2
 8010caa:	b29c      	uxth	r4, r3
 8010cac:	2010      	movs	r0, #16
 8010cae:	f7f5 ffab 	bl	8006c08 <lwip_htons>
 8010cb2:	0003      	movs	r3, r0
 8010cb4:	001a      	movs	r2, r3
 8010cb6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010cb8:	691b      	ldr	r3, [r3, #16]
 8010cba:	4322      	orrs	r2, r4
 8010cbc:	b292      	uxth	r2, r2
 8010cbe:	21ff      	movs	r1, #255	; 0xff
 8010cc0:	4011      	ands	r1, r2
 8010cc2:	000c      	movs	r4, r1
 8010cc4:	7b19      	ldrb	r1, [r3, #12]
 8010cc6:	2000      	movs	r0, #0
 8010cc8:	4001      	ands	r1, r0
 8010cca:	1c08      	adds	r0, r1, #0
 8010ccc:	1c21      	adds	r1, r4, #0
 8010cce:	4301      	orrs	r1, r0
 8010cd0:	7319      	strb	r1, [r3, #12]
 8010cd2:	0a12      	lsrs	r2, r2, #8
 8010cd4:	b290      	uxth	r0, r2
 8010cd6:	7b5a      	ldrb	r2, [r3, #13]
 8010cd8:	2100      	movs	r1, #0
 8010cda:	400a      	ands	r2, r1
 8010cdc:	1c11      	adds	r1, r2, #0
 8010cde:	1c02      	adds	r2, r0, #0
 8010ce0:	430a      	orrs	r2, r1
 8010ce2:	735a      	strb	r2, [r3, #13]
    }

    err = tcp_output_segment(seg, pcb, netif);
 8010ce4:	250f      	movs	r5, #15
 8010ce6:	197c      	adds	r4, r7, r5
 8010ce8:	697a      	ldr	r2, [r7, #20]
 8010cea:	6879      	ldr	r1, [r7, #4]
 8010cec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010cee:	0018      	movs	r0, r3
 8010cf0:	f000 f950 	bl	8010f94 <tcp_output_segment>
 8010cf4:	0003      	movs	r3, r0
 8010cf6:	7023      	strb	r3, [r4, #0]
    if (err != ERR_OK) {
 8010cf8:	0029      	movs	r1, r5
 8010cfa:	187b      	adds	r3, r7, r1
 8010cfc:	781b      	ldrb	r3, [r3, #0]
 8010cfe:	b25b      	sxtb	r3, r3
 8010d00:	2b00      	cmp	r3, #0
 8010d02:	d00a      	beq.n	8010d1a <tcp_output+0x28a>
      /* segment could not be sent, for whatever reason */
      tcp_set_flags(pcb, TF_NAGLEMEMERR);
 8010d04:	687b      	ldr	r3, [r7, #4]
 8010d06:	8bdb      	ldrh	r3, [r3, #30]
 8010d08:	2280      	movs	r2, #128	; 0x80
 8010d0a:	4313      	orrs	r3, r2
 8010d0c:	b29a      	uxth	r2, r3
 8010d0e:	687b      	ldr	r3, [r7, #4]
 8010d10:	83da      	strh	r2, [r3, #30]
      return err;
 8010d12:	187b      	adds	r3, r7, r1
 8010d14:	781b      	ldrb	r3, [r3, #0]
 8010d16:	b25b      	sxtb	r3, r3
 8010d18:	e116      	b.n	8010f48 <tcp_output+0x4b8>
    }
#if TCP_OVERSIZE_DBGCHECK
    seg->oversize_left = 0;
 8010d1a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010d1c:	2200      	movs	r2, #0
 8010d1e:	815a      	strh	r2, [r3, #10]
#endif /* TCP_OVERSIZE_DBGCHECK */
    pcb->unsent = seg->next;
 8010d20:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010d22:	681a      	ldr	r2, [r3, #0]
 8010d24:	687b      	ldr	r3, [r7, #4]
 8010d26:	671a      	str	r2, [r3, #112]	; 0x70
    if (pcb->state != SYN_SENT) {
 8010d28:	687b      	ldr	r3, [r7, #4]
 8010d2a:	7e1b      	ldrb	r3, [r3, #24]
 8010d2c:	2b02      	cmp	r3, #2
 8010d2e:	d006      	beq.n	8010d3e <tcp_output+0x2ae>
      tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 8010d30:	687b      	ldr	r3, [r7, #4]
 8010d32:	8bdb      	ldrh	r3, [r3, #30]
 8010d34:	2203      	movs	r2, #3
 8010d36:	4393      	bics	r3, r2
 8010d38:	b29a      	uxth	r2, r3
 8010d3a:	687b      	ldr	r3, [r7, #4]
 8010d3c:	83da      	strh	r2, [r3, #30]
    }
    snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 8010d3e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010d40:	691b      	ldr	r3, [r3, #16]
 8010d42:	791a      	ldrb	r2, [r3, #4]
 8010d44:	7959      	ldrb	r1, [r3, #5]
 8010d46:	0209      	lsls	r1, r1, #8
 8010d48:	430a      	orrs	r2, r1
 8010d4a:	7999      	ldrb	r1, [r3, #6]
 8010d4c:	0409      	lsls	r1, r1, #16
 8010d4e:	430a      	orrs	r2, r1
 8010d50:	79db      	ldrb	r3, [r3, #7]
 8010d52:	061b      	lsls	r3, r3, #24
 8010d54:	4313      	orrs	r3, r2
 8010d56:	0018      	movs	r0, r3
 8010d58:	f7f5 ff6c 	bl	8006c34 <lwip_htonl>
 8010d5c:	0004      	movs	r4, r0
 8010d5e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010d60:	891b      	ldrh	r3, [r3, #8]
 8010d62:	001d      	movs	r5, r3
 8010d64:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010d66:	691b      	ldr	r3, [r3, #16]
 8010d68:	7b1a      	ldrb	r2, [r3, #12]
 8010d6a:	7b5b      	ldrb	r3, [r3, #13]
 8010d6c:	021b      	lsls	r3, r3, #8
 8010d6e:	4313      	orrs	r3, r2
 8010d70:	b29b      	uxth	r3, r3
 8010d72:	0018      	movs	r0, r3
 8010d74:	f7f5 ff48 	bl	8006c08 <lwip_htons>
 8010d78:	0003      	movs	r3, r0
 8010d7a:	b2db      	uxtb	r3, r3
 8010d7c:	001a      	movs	r2, r3
 8010d7e:	2303      	movs	r3, #3
 8010d80:	4013      	ands	r3, r2
 8010d82:	d001      	beq.n	8010d88 <tcp_output+0x2f8>
 8010d84:	2301      	movs	r3, #1
 8010d86:	e000      	b.n	8010d8a <tcp_output+0x2fa>
 8010d88:	2300      	movs	r3, #0
 8010d8a:	195b      	adds	r3, r3, r5
 8010d8c:	18e3      	adds	r3, r4, r3
 8010d8e:	60bb      	str	r3, [r7, #8]
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 8010d90:	687b      	ldr	r3, [r7, #4]
 8010d92:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8010d94:	68bb      	ldr	r3, [r7, #8]
 8010d96:	1ad3      	subs	r3, r2, r3
 8010d98:	d502      	bpl.n	8010da0 <tcp_output+0x310>
      pcb->snd_nxt = snd_nxt;
 8010d9a:	687b      	ldr	r3, [r7, #4]
 8010d9c:	68ba      	ldr	r2, [r7, #8]
 8010d9e:	655a      	str	r2, [r3, #84]	; 0x54
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
 8010da0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010da2:	891b      	ldrh	r3, [r3, #8]
 8010da4:	001c      	movs	r4, r3
 8010da6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010da8:	691b      	ldr	r3, [r3, #16]
 8010daa:	7b1a      	ldrb	r2, [r3, #12]
 8010dac:	7b5b      	ldrb	r3, [r3, #13]
 8010dae:	021b      	lsls	r3, r3, #8
 8010db0:	4313      	orrs	r3, r2
 8010db2:	b29b      	uxth	r3, r3
 8010db4:	0018      	movs	r0, r3
 8010db6:	f7f5 ff27 	bl	8006c08 <lwip_htons>
 8010dba:	0003      	movs	r3, r0
 8010dbc:	b2db      	uxtb	r3, r3
 8010dbe:	001a      	movs	r2, r3
 8010dc0:	2303      	movs	r3, #3
 8010dc2:	4013      	ands	r3, r2
 8010dc4:	d014      	beq.n	8010df0 <tcp_output+0x360>
 8010dc6:	2301      	movs	r3, #1
 8010dc8:	e013      	b.n	8010df2 <tcp_output+0x362>
 8010dca:	46c0      	nop			; (mov r8, r8)
 8010dcc:	08020658 	.word	0x08020658
 8010dd0:	000004e2 	.word	0x000004e2
 8010dd4:	08020c78 	.word	0x08020c78
 8010dd8:	080206a4 	.word	0x080206a4
 8010ddc:	000004e4 	.word	0x000004e4
 8010de0:	08020c90 	.word	0x08020c90
 8010de4:	20002ee8 	.word	0x20002ee8
 8010de8:	00000537 	.word	0x00000537
 8010dec:	08020cb8 	.word	0x08020cb8
 8010df0:	2300      	movs	r3, #0
 8010df2:	191b      	adds	r3, r3, r4
 8010df4:	2b00      	cmp	r3, #0
 8010df6:	d06b      	beq.n	8010ed0 <tcp_output+0x440>
      seg->next = NULL;
 8010df8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010dfa:	2200      	movs	r2, #0
 8010dfc:	601a      	str	r2, [r3, #0]
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
 8010dfe:	687b      	ldr	r3, [r7, #4]
 8010e00:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8010e02:	2b00      	cmp	r3, #0
 8010e04:	d105      	bne.n	8010e12 <tcp_output+0x382>
        pcb->unacked = seg;
 8010e06:	687b      	ldr	r3, [r7, #4]
 8010e08:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8010e0a:	675a      	str	r2, [r3, #116]	; 0x74
        useg = seg;
 8010e0c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010e0e:	623b      	str	r3, [r7, #32]
 8010e10:	e062      	b.n	8010ed8 <tcp_output+0x448>
        /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(lwip_ntohl(seg->tcphdr->seqno), lwip_ntohl(useg->tcphdr->seqno))) {
 8010e12:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010e14:	691b      	ldr	r3, [r3, #16]
 8010e16:	791a      	ldrb	r2, [r3, #4]
 8010e18:	7959      	ldrb	r1, [r3, #5]
 8010e1a:	0209      	lsls	r1, r1, #8
 8010e1c:	430a      	orrs	r2, r1
 8010e1e:	7999      	ldrb	r1, [r3, #6]
 8010e20:	0409      	lsls	r1, r1, #16
 8010e22:	430a      	orrs	r2, r1
 8010e24:	79db      	ldrb	r3, [r3, #7]
 8010e26:	061b      	lsls	r3, r3, #24
 8010e28:	4313      	orrs	r3, r2
 8010e2a:	0018      	movs	r0, r3
 8010e2c:	f7f5 ff02 	bl	8006c34 <lwip_htonl>
 8010e30:	0004      	movs	r4, r0
 8010e32:	6a3b      	ldr	r3, [r7, #32]
 8010e34:	691b      	ldr	r3, [r3, #16]
 8010e36:	791a      	ldrb	r2, [r3, #4]
 8010e38:	7959      	ldrb	r1, [r3, #5]
 8010e3a:	0209      	lsls	r1, r1, #8
 8010e3c:	430a      	orrs	r2, r1
 8010e3e:	7999      	ldrb	r1, [r3, #6]
 8010e40:	0409      	lsls	r1, r1, #16
 8010e42:	430a      	orrs	r2, r1
 8010e44:	79db      	ldrb	r3, [r3, #7]
 8010e46:	061b      	lsls	r3, r3, #24
 8010e48:	4313      	orrs	r3, r2
 8010e4a:	0018      	movs	r0, r3
 8010e4c:	f7f5 fef2 	bl	8006c34 <lwip_htonl>
 8010e50:	0003      	movs	r3, r0
 8010e52:	1ae3      	subs	r3, r4, r3
 8010e54:	d535      	bpl.n	8010ec2 <tcp_output+0x432>
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
 8010e56:	687b      	ldr	r3, [r7, #4]
 8010e58:	3374      	adds	r3, #116	; 0x74
 8010e5a:	61fb      	str	r3, [r7, #28]
          while (*cur_seg &&
 8010e5c:	e002      	b.n	8010e64 <tcp_output+0x3d4>
                 TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
            cur_seg = &((*cur_seg)->next );
 8010e5e:	69fb      	ldr	r3, [r7, #28]
 8010e60:	681b      	ldr	r3, [r3, #0]
 8010e62:	61fb      	str	r3, [r7, #28]
          while (*cur_seg &&
 8010e64:	69fb      	ldr	r3, [r7, #28]
 8010e66:	681b      	ldr	r3, [r3, #0]
 8010e68:	2b00      	cmp	r3, #0
 8010e6a:	d022      	beq.n	8010eb2 <tcp_output+0x422>
                 TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
 8010e6c:	69fb      	ldr	r3, [r7, #28]
 8010e6e:	681b      	ldr	r3, [r3, #0]
 8010e70:	691b      	ldr	r3, [r3, #16]
 8010e72:	791a      	ldrb	r2, [r3, #4]
 8010e74:	7959      	ldrb	r1, [r3, #5]
 8010e76:	0209      	lsls	r1, r1, #8
 8010e78:	430a      	orrs	r2, r1
 8010e7a:	7999      	ldrb	r1, [r3, #6]
 8010e7c:	0409      	lsls	r1, r1, #16
 8010e7e:	430a      	orrs	r2, r1
 8010e80:	79db      	ldrb	r3, [r3, #7]
 8010e82:	061b      	lsls	r3, r3, #24
 8010e84:	4313      	orrs	r3, r2
 8010e86:	0018      	movs	r0, r3
 8010e88:	f7f5 fed4 	bl	8006c34 <lwip_htonl>
 8010e8c:	0004      	movs	r4, r0
 8010e8e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010e90:	691b      	ldr	r3, [r3, #16]
 8010e92:	791a      	ldrb	r2, [r3, #4]
 8010e94:	7959      	ldrb	r1, [r3, #5]
 8010e96:	0209      	lsls	r1, r1, #8
 8010e98:	430a      	orrs	r2, r1
 8010e9a:	7999      	ldrb	r1, [r3, #6]
 8010e9c:	0409      	lsls	r1, r1, #16
 8010e9e:	430a      	orrs	r2, r1
 8010ea0:	79db      	ldrb	r3, [r3, #7]
 8010ea2:	061b      	lsls	r3, r3, #24
 8010ea4:	4313      	orrs	r3, r2
 8010ea6:	0018      	movs	r0, r3
 8010ea8:	f7f5 fec4 	bl	8006c34 <lwip_htonl>
 8010eac:	0003      	movs	r3, r0
 8010eae:	1ae3      	subs	r3, r4, r3
          while (*cur_seg &&
 8010eb0:	d4d5      	bmi.n	8010e5e <tcp_output+0x3ce>
          }
          seg->next = (*cur_seg);
 8010eb2:	69fb      	ldr	r3, [r7, #28]
 8010eb4:	681a      	ldr	r2, [r3, #0]
 8010eb6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010eb8:	601a      	str	r2, [r3, #0]
          (*cur_seg) = seg;
 8010eba:	69fb      	ldr	r3, [r7, #28]
 8010ebc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8010ebe:	601a      	str	r2, [r3, #0]
 8010ec0:	e00a      	b.n	8010ed8 <tcp_output+0x448>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
 8010ec2:	6a3b      	ldr	r3, [r7, #32]
 8010ec4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8010ec6:	601a      	str	r2, [r3, #0]
          useg = useg->next;
 8010ec8:	6a3b      	ldr	r3, [r7, #32]
 8010eca:	681b      	ldr	r3, [r3, #0]
 8010ecc:	623b      	str	r3, [r7, #32]
 8010ece:	e003      	b.n	8010ed8 <tcp_output+0x448>
        }
      }
      /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
 8010ed0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010ed2:	0018      	movs	r0, r3
 8010ed4:	f7fa fee8 	bl	800bca8 <tcp_seg_free>
    }
    seg = pcb->unsent;
 8010ed8:	687b      	ldr	r3, [r7, #4]
 8010eda:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010edc:	627b      	str	r3, [r7, #36]	; 0x24
  while (seg != NULL &&
 8010ede:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010ee0:	2b00      	cmp	r3, #0
 8010ee2:	d01b      	beq.n	8010f1c <tcp_output+0x48c>
         lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
 8010ee4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010ee6:	691b      	ldr	r3, [r3, #16]
 8010ee8:	791a      	ldrb	r2, [r3, #4]
 8010eea:	7959      	ldrb	r1, [r3, #5]
 8010eec:	0209      	lsls	r1, r1, #8
 8010eee:	430a      	orrs	r2, r1
 8010ef0:	7999      	ldrb	r1, [r3, #6]
 8010ef2:	0409      	lsls	r1, r1, #16
 8010ef4:	430a      	orrs	r2, r1
 8010ef6:	79db      	ldrb	r3, [r3, #7]
 8010ef8:	061b      	lsls	r3, r3, #24
 8010efa:	4313      	orrs	r3, r2
 8010efc:	0018      	movs	r0, r3
 8010efe:	f7f5 fe99 	bl	8006c34 <lwip_htonl>
 8010f02:	0002      	movs	r2, r0
 8010f04:	687b      	ldr	r3, [r7, #4]
 8010f06:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8010f08:	1ad3      	subs	r3, r2, r3
 8010f0a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8010f0c:	8912      	ldrh	r2, [r2, #8]
 8010f0e:	189b      	adds	r3, r3, r2
  while (seg != NULL &&
 8010f10:	69ba      	ldr	r2, [r7, #24]
 8010f12:	429a      	cmp	r2, r3
 8010f14:	d300      	bcc.n	8010f18 <tcp_output+0x488>
 8010f16:	e678      	b.n	8010c0a <tcp_output+0x17a>
 8010f18:	e000      	b.n	8010f1c <tcp_output+0x48c>
      break;
 8010f1a:	46c0      	nop			; (mov r8, r8)
  }
#if TCP_OVERSIZE
  if (pcb->unsent == NULL) {
 8010f1c:	687b      	ldr	r3, [r7, #4]
 8010f1e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010f20:	2b00      	cmp	r3, #0
 8010f22:	d108      	bne.n	8010f36 <tcp_output+0x4a6>
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
 8010f24:	687b      	ldr	r3, [r7, #4]
 8010f26:	226c      	movs	r2, #108	; 0x6c
 8010f28:	2100      	movs	r1, #0
 8010f2a:	5299      	strh	r1, [r3, r2]
 8010f2c:	e004      	b.n	8010f38 <tcp_output+0x4a8>
    goto output_done;
 8010f2e:	46c0      	nop			; (mov r8, r8)
 8010f30:	e002      	b.n	8010f38 <tcp_output+0x4a8>
    goto output_done;
 8010f32:	46c0      	nop			; (mov r8, r8)
 8010f34:	e000      	b.n	8010f38 <tcp_output+0x4a8>
  }
#endif /* TCP_OVERSIZE */

output_done:
 8010f36:	46c0      	nop			; (mov r8, r8)
  tcp_clear_flags(pcb, TF_NAGLEMEMERR);
 8010f38:	687b      	ldr	r3, [r7, #4]
 8010f3a:	8bdb      	ldrh	r3, [r3, #30]
 8010f3c:	2280      	movs	r2, #128	; 0x80
 8010f3e:	4393      	bics	r3, r2
 8010f40:	b29a      	uxth	r2, r3
 8010f42:	687b      	ldr	r3, [r7, #4]
 8010f44:	83da      	strh	r2, [r3, #30]
  return ERR_OK;
 8010f46:	2300      	movs	r3, #0
}
 8010f48:	0018      	movs	r0, r3
 8010f4a:	46bd      	mov	sp, r7
 8010f4c:	b00a      	add	sp, #40	; 0x28
 8010f4e:	bdb0      	pop	{r4, r5, r7, pc}

08010f50 <tcp_output_segment_busy>:
 * @arg seg the tcp segment to check
 * @return 1 if ref != 1, 0 if ref == 1
 */
static int
tcp_output_segment_busy(const struct tcp_seg *seg)
{
 8010f50:	b580      	push	{r7, lr}
 8010f52:	b082      	sub	sp, #8
 8010f54:	af00      	add	r7, sp, #0
 8010f56:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_output_segment_busy: invalid seg", seg != NULL);
 8010f58:	687b      	ldr	r3, [r7, #4]
 8010f5a:	2b00      	cmp	r3, #0
 8010f5c:	d105      	bne.n	8010f6a <tcp_output_segment_busy+0x1a>
 8010f5e:	4b09      	ldr	r3, [pc, #36]	; (8010f84 <tcp_output_segment_busy+0x34>)
 8010f60:	4a09      	ldr	r2, [pc, #36]	; (8010f88 <tcp_output_segment_busy+0x38>)
 8010f62:	490a      	ldr	r1, [pc, #40]	; (8010f8c <tcp_output_segment_busy+0x3c>)
 8010f64:	480a      	ldr	r0, [pc, #40]	; (8010f90 <tcp_output_segment_busy+0x40>)
 8010f66:	f7f1 fcb9 	bl	80028dc <app_debug_rtt_raw>

  /* We only need to check the first pbuf here:
     If a pbuf is queued for transmission, a driver calls pbuf_ref(),
     which only changes the ref count of the first pbuf */
  if (seg->p->ref != 1) {
 8010f6a:	687b      	ldr	r3, [r7, #4]
 8010f6c:	685b      	ldr	r3, [r3, #4]
 8010f6e:	7b9b      	ldrb	r3, [r3, #14]
 8010f70:	2b01      	cmp	r3, #1
 8010f72:	d001      	beq.n	8010f78 <tcp_output_segment_busy+0x28>
    /* other reference found */
    return 1;
 8010f74:	2301      	movs	r3, #1
 8010f76:	e000      	b.n	8010f7a <tcp_output_segment_busy+0x2a>
  }
  /* no other references found */
  return 0;
 8010f78:	2300      	movs	r3, #0
}
 8010f7a:	0018      	movs	r0, r3
 8010f7c:	46bd      	mov	sp, r7
 8010f7e:	b002      	add	sp, #8
 8010f80:	bd80      	pop	{r7, pc}
 8010f82:	46c0      	nop			; (mov r8, r8)
 8010f84:	08020658 	.word	0x08020658
 8010f88:	0000059b 	.word	0x0000059b
 8010f8c:	08020cd0 	.word	0x08020cd0
 8010f90:	080206a4 	.word	0x080206a4

08010f94 <tcp_output_segment>:
 * @param pcb the tcp_pcb for the TCP connection used to send the segment
 * @param netif the netif used to send the segment
 */
static err_t
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb, struct netif *netif)
{
 8010f94:	b5f0      	push	{r4, r5, r6, r7, lr}
 8010f96:	b08f      	sub	sp, #60	; 0x3c
 8010f98:	af04      	add	r7, sp, #16
 8010f9a:	60f8      	str	r0, [r7, #12]
 8010f9c:	60b9      	str	r1, [r7, #8]
 8010f9e:	607a      	str	r2, [r7, #4]
  err_t err;
  u16_t len;
  u32_t *opts;
#if TCP_CHECKSUM_ON_COPY
  int seg_chksum_was_swapped = 0;
 8010fa0:	2300      	movs	r3, #0
 8010fa2:	623b      	str	r3, [r7, #32]
#endif

  LWIP_ASSERT("tcp_output_segment: invalid seg", seg != NULL);
 8010fa4:	68fb      	ldr	r3, [r7, #12]
 8010fa6:	2b00      	cmp	r3, #0
 8010fa8:	d105      	bne.n	8010fb6 <tcp_output_segment+0x22>
 8010faa:	4bda      	ldr	r3, [pc, #872]	; (8011314 <tcp_output_segment+0x380>)
 8010fac:	4ada      	ldr	r2, [pc, #872]	; (8011318 <tcp_output_segment+0x384>)
 8010fae:	49db      	ldr	r1, [pc, #876]	; (801131c <tcp_output_segment+0x388>)
 8010fb0:	48db      	ldr	r0, [pc, #876]	; (8011320 <tcp_output_segment+0x38c>)
 8010fb2:	f7f1 fc93 	bl	80028dc <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_output_segment: invalid pcb", pcb != NULL);
 8010fb6:	68bb      	ldr	r3, [r7, #8]
 8010fb8:	2b00      	cmp	r3, #0
 8010fba:	d105      	bne.n	8010fc8 <tcp_output_segment+0x34>
 8010fbc:	4bd5      	ldr	r3, [pc, #852]	; (8011314 <tcp_output_segment+0x380>)
 8010fbe:	4ad9      	ldr	r2, [pc, #868]	; (8011324 <tcp_output_segment+0x390>)
 8010fc0:	49d9      	ldr	r1, [pc, #868]	; (8011328 <tcp_output_segment+0x394>)
 8010fc2:	48d7      	ldr	r0, [pc, #860]	; (8011320 <tcp_output_segment+0x38c>)
 8010fc4:	f7f1 fc8a 	bl	80028dc <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_output_segment: invalid netif", netif != NULL);
 8010fc8:	687b      	ldr	r3, [r7, #4]
 8010fca:	2b00      	cmp	r3, #0
 8010fcc:	d105      	bne.n	8010fda <tcp_output_segment+0x46>
 8010fce:	4bd1      	ldr	r3, [pc, #836]	; (8011314 <tcp_output_segment+0x380>)
 8010fd0:	4ad6      	ldr	r2, [pc, #856]	; (801132c <tcp_output_segment+0x398>)
 8010fd2:	49d7      	ldr	r1, [pc, #860]	; (8011330 <tcp_output_segment+0x39c>)
 8010fd4:	48d2      	ldr	r0, [pc, #840]	; (8011320 <tcp_output_segment+0x38c>)
 8010fd6:	f7f1 fc81 	bl	80028dc <app_debug_rtt_raw>

  if (tcp_output_segment_busy(seg)) {
 8010fda:	68fb      	ldr	r3, [r7, #12]
 8010fdc:	0018      	movs	r0, r3
 8010fde:	f7ff ffb7 	bl	8010f50 <tcp_output_segment_busy>
 8010fe2:	1e03      	subs	r3, r0, #0
 8010fe4:	d001      	beq.n	8010fea <tcp_output_segment+0x56>
    /* This should not happen: rexmit functions should have checked this.
       However, since this function modifies p->len, we must not continue in this case. */
    LWIP_DEBUGF(TCP_RTO_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_output_segment: segment busy\n"));
    return ERR_OK;
 8010fe6:	2300      	movs	r3, #0
 8010fe8:	e190      	b.n	801130c <tcp_output_segment+0x378>
  }

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = lwip_htonl(pcb->rcv_nxt);
 8010fea:	68bb      	ldr	r3, [r7, #8]
 8010fec:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8010fee:	68fb      	ldr	r3, [r7, #12]
 8010ff0:	691c      	ldr	r4, [r3, #16]
 8010ff2:	0010      	movs	r0, r2
 8010ff4:	f7f5 fe1e 	bl	8006c34 <lwip_htonl>
 8010ff8:	0003      	movs	r3, r0
 8010ffa:	22ff      	movs	r2, #255	; 0xff
 8010ffc:	401a      	ands	r2, r3
 8010ffe:	0010      	movs	r0, r2
 8011000:	7a22      	ldrb	r2, [r4, #8]
 8011002:	2100      	movs	r1, #0
 8011004:	400a      	ands	r2, r1
 8011006:	1c11      	adds	r1, r2, #0
 8011008:	1c02      	adds	r2, r0, #0
 801100a:	430a      	orrs	r2, r1
 801100c:	7222      	strb	r2, [r4, #8]
 801100e:	0a1a      	lsrs	r2, r3, #8
 8011010:	21ff      	movs	r1, #255	; 0xff
 8011012:	400a      	ands	r2, r1
 8011014:	0010      	movs	r0, r2
 8011016:	7a62      	ldrb	r2, [r4, #9]
 8011018:	2100      	movs	r1, #0
 801101a:	400a      	ands	r2, r1
 801101c:	1c11      	adds	r1, r2, #0
 801101e:	1c02      	adds	r2, r0, #0
 8011020:	430a      	orrs	r2, r1
 8011022:	7262      	strb	r2, [r4, #9]
 8011024:	0c1a      	lsrs	r2, r3, #16
 8011026:	21ff      	movs	r1, #255	; 0xff
 8011028:	400a      	ands	r2, r1
 801102a:	0010      	movs	r0, r2
 801102c:	7aa2      	ldrb	r2, [r4, #10]
 801102e:	2100      	movs	r1, #0
 8011030:	400a      	ands	r2, r1
 8011032:	1c11      	adds	r1, r2, #0
 8011034:	1c02      	adds	r2, r0, #0
 8011036:	430a      	orrs	r2, r1
 8011038:	72a2      	strb	r2, [r4, #10]
 801103a:	0e19      	lsrs	r1, r3, #24
 801103c:	7ae3      	ldrb	r3, [r4, #11]
 801103e:	2200      	movs	r2, #0
 8011040:	4013      	ands	r3, r2
 8011042:	1c1a      	adds	r2, r3, #0
 8011044:	1c0b      	adds	r3, r1, #0
 8011046:	4313      	orrs	r3, r2
 8011048:	72e3      	strb	r3, [r4, #11]
       the window scale option) is never scaled. */
    seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(pcb->rcv_ann_wnd));
  } else
#endif /* LWIP_WND_SCALE */
  {
    seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
 801104a:	68bb      	ldr	r3, [r7, #8]
 801104c:	8dda      	ldrh	r2, [r3, #46]	; 0x2e
 801104e:	68fb      	ldr	r3, [r7, #12]
 8011050:	691c      	ldr	r4, [r3, #16]
 8011052:	0010      	movs	r0, r2
 8011054:	f7f5 fdd8 	bl	8006c08 <lwip_htons>
 8011058:	0003      	movs	r3, r0
 801105a:	22ff      	movs	r2, #255	; 0xff
 801105c:	401a      	ands	r2, r3
 801105e:	0010      	movs	r0, r2
 8011060:	7ba2      	ldrb	r2, [r4, #14]
 8011062:	2100      	movs	r1, #0
 8011064:	400a      	ands	r2, r1
 8011066:	1c11      	adds	r1, r2, #0
 8011068:	1c02      	adds	r2, r0, #0
 801106a:	430a      	orrs	r2, r1
 801106c:	73a2      	strb	r2, [r4, #14]
 801106e:	0a1b      	lsrs	r3, r3, #8
 8011070:	b299      	uxth	r1, r3
 8011072:	7be3      	ldrb	r3, [r4, #15]
 8011074:	2200      	movs	r2, #0
 8011076:	4013      	ands	r3, r2
 8011078:	1c1a      	adds	r2, r3, #0
 801107a:	1c0b      	adds	r3, r1, #0
 801107c:	4313      	orrs	r3, r2
 801107e:	73e3      	strb	r3, [r4, #15]
  }

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 8011080:	68bb      	ldr	r3, [r7, #8]
 8011082:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8011084:	68ba      	ldr	r2, [r7, #8]
 8011086:	8dd2      	ldrh	r2, [r2, #46]	; 0x2e
 8011088:	189a      	adds	r2, r3, r2
 801108a:	68bb      	ldr	r3, [r7, #8]
 801108c:	631a      	str	r2, [r3, #48]	; 0x30

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  /* cast through void* to get rid of alignment warnings */
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
 801108e:	68fb      	ldr	r3, [r7, #12]
 8011090:	691b      	ldr	r3, [r3, #16]
 8011092:	3314      	adds	r3, #20
 8011094:	627b      	str	r3, [r7, #36]	; 0x24
  if (seg->flags & TF_SEG_OPTS_MSS) {
 8011096:	68fb      	ldr	r3, [r7, #12]
 8011098:	7bdb      	ldrb	r3, [r3, #15]
 801109a:	001a      	movs	r2, r3
 801109c:	2301      	movs	r3, #1
 801109e:	4013      	ands	r3, r2
 80110a0:	d019      	beq.n	80110d6 <tcp_output_segment+0x142>
    u16_t mss;
#if TCP_CALCULATE_EFF_SEND_MSS
    mss = tcp_eff_send_mss_netif(TCP_MSS, netif, &pcb->remote_ip);
 80110a2:	68bb      	ldr	r3, [r7, #8]
 80110a4:	1d1a      	adds	r2, r3, #4
 80110a6:	251e      	movs	r5, #30
 80110a8:	197c      	adds	r4, r7, r5
 80110aa:	6879      	ldr	r1, [r7, #4]
 80110ac:	2386      	movs	r3, #134	; 0x86
 80110ae:	009b      	lsls	r3, r3, #2
 80110b0:	0018      	movs	r0, r3
 80110b2:	f7fb f9cb 	bl	800c44c <tcp_eff_send_mss_netif>
 80110b6:	0003      	movs	r3, r0
 80110b8:	8023      	strh	r3, [r4, #0]
#else /* TCP_CALCULATE_EFF_SEND_MSS */
    mss = TCP_MSS;
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
    *opts = TCP_BUILD_MSS_OPTION(mss);
 80110ba:	197b      	adds	r3, r7, r5
 80110bc:	881b      	ldrh	r3, [r3, #0]
 80110be:	2281      	movs	r2, #129	; 0x81
 80110c0:	0492      	lsls	r2, r2, #18
 80110c2:	4313      	orrs	r3, r2
 80110c4:	0018      	movs	r0, r3
 80110c6:	f7f5 fdb5 	bl	8006c34 <lwip_htonl>
 80110ca:	0002      	movs	r2, r0
 80110cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80110ce:	601a      	str	r2, [r3, #0]
    opts += 1;
 80110d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80110d2:	3304      	adds	r3, #4
 80110d4:	627b      	str	r3, [r7, #36]	; 0x24
  }
#endif

  /* Set retransmission timer running if it is not currently enabled
     This must be set before checking the route. */
  if (pcb->rtime < 0) {
 80110d6:	68bb      	ldr	r3, [r7, #8]
 80110d8:	2234      	movs	r2, #52	; 0x34
 80110da:	5e9b      	ldrsh	r3, [r3, r2]
 80110dc:	2b00      	cmp	r3, #0
 80110de:	da02      	bge.n	80110e6 <tcp_output_segment+0x152>
    pcb->rtime = 0;
 80110e0:	68bb      	ldr	r3, [r7, #8]
 80110e2:	2200      	movs	r2, #0
 80110e4:	869a      	strh	r2, [r3, #52]	; 0x34
  }

  if (pcb->rttest == 0) {
 80110e6:	68bb      	ldr	r3, [r7, #8]
 80110e8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80110ea:	2b00      	cmp	r3, #0
 80110ec:	d115      	bne.n	801111a <tcp_output_segment+0x186>
    pcb->rttest = tcp_ticks;
 80110ee:	4b91      	ldr	r3, [pc, #580]	; (8011334 <tcp_output_segment+0x3a0>)
 80110f0:	681a      	ldr	r2, [r3, #0]
 80110f2:	68bb      	ldr	r3, [r7, #8]
 80110f4:	639a      	str	r2, [r3, #56]	; 0x38
    pcb->rtseq = lwip_ntohl(seg->tcphdr->seqno);
 80110f6:	68fb      	ldr	r3, [r7, #12]
 80110f8:	691b      	ldr	r3, [r3, #16]
 80110fa:	791a      	ldrb	r2, [r3, #4]
 80110fc:	7959      	ldrb	r1, [r3, #5]
 80110fe:	0209      	lsls	r1, r1, #8
 8011100:	430a      	orrs	r2, r1
 8011102:	7999      	ldrb	r1, [r3, #6]
 8011104:	0409      	lsls	r1, r1, #16
 8011106:	430a      	orrs	r2, r1
 8011108:	79db      	ldrb	r3, [r3, #7]
 801110a:	061b      	lsls	r3, r3, #24
 801110c:	4313      	orrs	r3, r2
 801110e:	0018      	movs	r0, r3
 8011110:	f7f5 fd90 	bl	8006c34 <lwip_htonl>
 8011114:	0002      	movs	r2, r0
 8011116:	68bb      	ldr	r3, [r7, #8]
 8011118:	63da      	str	r2, [r3, #60]	; 0x3c
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
                                 lwip_htonl(seg->tcphdr->seqno), lwip_htonl(seg->tcphdr->seqno) +
                                 seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 801111a:	68fb      	ldr	r3, [r7, #12]
 801111c:	691a      	ldr	r2, [r3, #16]
 801111e:	68fb      	ldr	r3, [r7, #12]
 8011120:	685b      	ldr	r3, [r3, #4]
 8011122:	685b      	ldr	r3, [r3, #4]
 8011124:	1ad2      	subs	r2, r2, r3
 8011126:	201c      	movs	r0, #28
 8011128:	183b      	adds	r3, r7, r0
 801112a:	801a      	strh	r2, [r3, #0]
  if (len == 0) {
    /** Exclude retransmitted segments from this count. */
    MIB2_STATS_INC(mib2.tcpoutsegs);
  }

  seg->p->len -= len;
 801112c:	68fb      	ldr	r3, [r7, #12]
 801112e:	685b      	ldr	r3, [r3, #4]
 8011130:	8959      	ldrh	r1, [r3, #10]
 8011132:	68fb      	ldr	r3, [r7, #12]
 8011134:	685b      	ldr	r3, [r3, #4]
 8011136:	183a      	adds	r2, r7, r0
 8011138:	8812      	ldrh	r2, [r2, #0]
 801113a:	1a8a      	subs	r2, r1, r2
 801113c:	b292      	uxth	r2, r2
 801113e:	815a      	strh	r2, [r3, #10]
  seg->p->tot_len -= len;
 8011140:	68fb      	ldr	r3, [r7, #12]
 8011142:	685b      	ldr	r3, [r3, #4]
 8011144:	8919      	ldrh	r1, [r3, #8]
 8011146:	68fb      	ldr	r3, [r7, #12]
 8011148:	685b      	ldr	r3, [r3, #4]
 801114a:	183a      	adds	r2, r7, r0
 801114c:	8812      	ldrh	r2, [r2, #0]
 801114e:	1a8a      	subs	r2, r1, r2
 8011150:	b292      	uxth	r2, r2
 8011152:	811a      	strh	r2, [r3, #8]

  seg->p->payload = seg->tcphdr;
 8011154:	68fb      	ldr	r3, [r7, #12]
 8011156:	685b      	ldr	r3, [r3, #4]
 8011158:	68fa      	ldr	r2, [r7, #12]
 801115a:	6912      	ldr	r2, [r2, #16]
 801115c:	605a      	str	r2, [r3, #4]

  seg->tcphdr->chksum = 0;
 801115e:	68fb      	ldr	r3, [r7, #12]
 8011160:	691b      	ldr	r3, [r3, #16]
 8011162:	7c1a      	ldrb	r2, [r3, #16]
 8011164:	2100      	movs	r1, #0
 8011166:	400a      	ands	r2, r1
 8011168:	741a      	strb	r2, [r3, #16]
 801116a:	7c5a      	ldrb	r2, [r3, #17]
 801116c:	2100      	movs	r1, #0
 801116e:	400a      	ands	r2, r1
 8011170:	745a      	strb	r2, [r3, #17]

#ifdef LWIP_HOOK_TCP_OUT_ADD_TCPOPTS
  opts = LWIP_HOOK_TCP_OUT_ADD_TCPOPTS(seg->p, seg->tcphdr, pcb, opts);
#endif
  LWIP_ASSERT("options not filled", (u8_t *)opts == ((u8_t *)(seg->tcphdr + 1)) + LWIP_TCP_OPT_LENGTH_SEGMENT(seg->flags, pcb));
 8011172:	68fb      	ldr	r3, [r7, #12]
 8011174:	691b      	ldr	r3, [r3, #16]
 8011176:	3314      	adds	r3, #20
 8011178:	001a      	movs	r2, r3
 801117a:	68fb      	ldr	r3, [r7, #12]
 801117c:	7bdb      	ldrb	r3, [r3, #15]
 801117e:	009b      	lsls	r3, r3, #2
 8011180:	2104      	movs	r1, #4
 8011182:	400b      	ands	r3, r1
 8011184:	18d3      	adds	r3, r2, r3
 8011186:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8011188:	429a      	cmp	r2, r3
 801118a:	d005      	beq.n	8011198 <tcp_output_segment+0x204>
 801118c:	4b61      	ldr	r3, [pc, #388]	; (8011314 <tcp_output_segment+0x380>)
 801118e:	4a6a      	ldr	r2, [pc, #424]	; (8011338 <tcp_output_segment+0x3a4>)
 8011190:	496a      	ldr	r1, [pc, #424]	; (801133c <tcp_output_segment+0x3a8>)
 8011192:	4863      	ldr	r0, [pc, #396]	; (8011320 <tcp_output_segment+0x38c>)
 8011194:	f7f1 fba2 	bl	80028dc <app_debug_rtt_raw>
    u32_t acc;
#if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
    u16_t chksum_slow = ip_chksum_pseudo(seg->p, IP_PROTO_TCP,
                                         seg->p->tot_len, &pcb->local_ip, &pcb->remote_ip);
#endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
    if ((seg->flags & TF_SEG_DATA_CHECKSUMMED) == 0) {
 8011198:	68fb      	ldr	r3, [r7, #12]
 801119a:	7bdb      	ldrb	r3, [r3, #15]
 801119c:	001a      	movs	r2, r3
 801119e:	2304      	movs	r3, #4
 80111a0:	4013      	ands	r3, r2
 80111a2:	d11c      	bne.n	80111de <tcp_output_segment+0x24a>
      LWIP_ASSERT("data included but not checksummed",
 80111a4:	68fb      	ldr	r3, [r7, #12]
 80111a6:	685b      	ldr	r3, [r3, #4]
 80111a8:	891c      	ldrh	r4, [r3, #8]
 80111aa:	68fb      	ldr	r3, [r7, #12]
 80111ac:	691b      	ldr	r3, [r3, #16]
 80111ae:	7b1a      	ldrb	r2, [r3, #12]
 80111b0:	7b5b      	ldrb	r3, [r3, #13]
 80111b2:	021b      	lsls	r3, r3, #8
 80111b4:	4313      	orrs	r3, r2
 80111b6:	b29b      	uxth	r3, r3
 80111b8:	0018      	movs	r0, r3
 80111ba:	f7f5 fd25 	bl	8006c08 <lwip_htons>
 80111be:	0003      	movs	r3, r0
 80111c0:	0b1b      	lsrs	r3, r3, #12
 80111c2:	b29b      	uxth	r3, r3
 80111c4:	b2db      	uxtb	r3, r3
 80111c6:	009b      	lsls	r3, r3, #2
 80111c8:	b2db      	uxtb	r3, r3
 80111ca:	b29b      	uxth	r3, r3
 80111cc:	429c      	cmp	r4, r3
 80111ce:	d006      	beq.n	80111de <tcp_output_segment+0x24a>
 80111d0:	4b50      	ldr	r3, [pc, #320]	; (8011314 <tcp_output_segment+0x380>)
 80111d2:	22c5      	movs	r2, #197	; 0xc5
 80111d4:	00d2      	lsls	r2, r2, #3
 80111d6:	495a      	ldr	r1, [pc, #360]	; (8011340 <tcp_output_segment+0x3ac>)
 80111d8:	4851      	ldr	r0, [pc, #324]	; (8011320 <tcp_output_segment+0x38c>)
 80111da:	f7f1 fb7f 	bl	80028dc <app_debug_rtt_raw>
                  seg->p->tot_len == TCPH_HDRLEN_BYTES(seg->tcphdr));
    }

    /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
    acc = ip_chksum_pseudo_partial(seg->p, IP_PROTO_TCP,
 80111de:	68fb      	ldr	r3, [r7, #12]
 80111e0:	685c      	ldr	r4, [r3, #4]
                                   seg->p->tot_len, TCPH_HDRLEN_BYTES(seg->tcphdr), &pcb->local_ip, &pcb->remote_ip);
 80111e2:	68fb      	ldr	r3, [r7, #12]
 80111e4:	685b      	ldr	r3, [r3, #4]
    acc = ip_chksum_pseudo_partial(seg->p, IP_PROTO_TCP,
 80111e6:	891d      	ldrh	r5, [r3, #8]
                                   seg->p->tot_len, TCPH_HDRLEN_BYTES(seg->tcphdr), &pcb->local_ip, &pcb->remote_ip);
 80111e8:	68fb      	ldr	r3, [r7, #12]
 80111ea:	691b      	ldr	r3, [r3, #16]
 80111ec:	7b1a      	ldrb	r2, [r3, #12]
 80111ee:	7b5b      	ldrb	r3, [r3, #13]
 80111f0:	021b      	lsls	r3, r3, #8
 80111f2:	4313      	orrs	r3, r2
 80111f4:	b29b      	uxth	r3, r3
 80111f6:	0018      	movs	r0, r3
 80111f8:	f7f5 fd06 	bl	8006c08 <lwip_htons>
 80111fc:	0003      	movs	r3, r0
 80111fe:	0b1b      	lsrs	r3, r3, #12
 8011200:	b29b      	uxth	r3, r3
 8011202:	b2db      	uxtb	r3, r3
 8011204:	009b      	lsls	r3, r3, #2
 8011206:	b2db      	uxtb	r3, r3
    acc = ip_chksum_pseudo_partial(seg->p, IP_PROTO_TCP,
 8011208:	b299      	uxth	r1, r3
                                   seg->p->tot_len, TCPH_HDRLEN_BYTES(seg->tcphdr), &pcb->local_ip, &pcb->remote_ip);
 801120a:	68bb      	ldr	r3, [r7, #8]
 801120c:	68ba      	ldr	r2, [r7, #8]
 801120e:	3204      	adds	r2, #4
    acc = ip_chksum_pseudo_partial(seg->p, IP_PROTO_TCP,
 8011210:	9201      	str	r2, [sp, #4]
 8011212:	9300      	str	r3, [sp, #0]
 8011214:	000b      	movs	r3, r1
 8011216:	002a      	movs	r2, r5
 8011218:	2106      	movs	r1, #6
 801121a:	0020      	movs	r0, r4
 801121c:	f7f7 f895 	bl	800834a <ip_chksum_pseudo_partial>
 8011220:	0003      	movs	r3, r0
 8011222:	61bb      	str	r3, [r7, #24]
    /* add payload checksum */
    if (seg->chksum_swapped) {
 8011224:	68fb      	ldr	r3, [r7, #12]
 8011226:	7b9b      	ldrb	r3, [r3, #14]
 8011228:	2b00      	cmp	r3, #0
 801122a:	d012      	beq.n	8011252 <tcp_output_segment+0x2be>
      seg_chksum_was_swapped = 1;
 801122c:	2301      	movs	r3, #1
 801122e:	623b      	str	r3, [r7, #32]
      seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
 8011230:	68fb      	ldr	r3, [r7, #12]
 8011232:	899b      	ldrh	r3, [r3, #12]
 8011234:	021b      	lsls	r3, r3, #8
 8011236:	b21a      	sxth	r2, r3
 8011238:	68fb      	ldr	r3, [r7, #12]
 801123a:	899b      	ldrh	r3, [r3, #12]
 801123c:	0a1b      	lsrs	r3, r3, #8
 801123e:	b29b      	uxth	r3, r3
 8011240:	b21b      	sxth	r3, r3
 8011242:	4313      	orrs	r3, r2
 8011244:	b21b      	sxth	r3, r3
 8011246:	b29a      	uxth	r2, r3
 8011248:	68fb      	ldr	r3, [r7, #12]
 801124a:	819a      	strh	r2, [r3, #12]
      seg->chksum_swapped = 0;
 801124c:	68fb      	ldr	r3, [r7, #12]
 801124e:	2200      	movs	r2, #0
 8011250:	739a      	strb	r2, [r3, #14]
    }
    acc = (u16_t)~acc + seg->chksum;
 8011252:	69bb      	ldr	r3, [r7, #24]
 8011254:	b29b      	uxth	r3, r3
 8011256:	43db      	mvns	r3, r3
 8011258:	b29b      	uxth	r3, r3
 801125a:	001a      	movs	r2, r3
 801125c:	68fb      	ldr	r3, [r7, #12]
 801125e:	899b      	ldrh	r3, [r3, #12]
 8011260:	18d3      	adds	r3, r2, r3
 8011262:	61bb      	str	r3, [r7, #24]
    seg->tcphdr->chksum = (u16_t)~FOLD_U32T(acc);
 8011264:	69bb      	ldr	r3, [r7, #24]
 8011266:	0c1b      	lsrs	r3, r3, #16
 8011268:	b29a      	uxth	r2, r3
 801126a:	69bb      	ldr	r3, [r7, #24]
 801126c:	b29b      	uxth	r3, r3
 801126e:	18d3      	adds	r3, r2, r3
 8011270:	b29a      	uxth	r2, r3
 8011272:	68fb      	ldr	r3, [r7, #12]
 8011274:	691b      	ldr	r3, [r3, #16]
 8011276:	43d2      	mvns	r2, r2
 8011278:	b292      	uxth	r2, r2
 801127a:	21ff      	movs	r1, #255	; 0xff
 801127c:	4011      	ands	r1, r2
 801127e:	000c      	movs	r4, r1
 8011280:	7c19      	ldrb	r1, [r3, #16]
 8011282:	2000      	movs	r0, #0
 8011284:	4001      	ands	r1, r0
 8011286:	1c08      	adds	r0, r1, #0
 8011288:	1c21      	adds	r1, r4, #0
 801128a:	4301      	orrs	r1, r0
 801128c:	7419      	strb	r1, [r3, #16]
 801128e:	0a12      	lsrs	r2, r2, #8
 8011290:	b290      	uxth	r0, r2
 8011292:	7c5a      	ldrb	r2, [r3, #17]
 8011294:	2100      	movs	r1, #0
 8011296:	400a      	ands	r2, r1
 8011298:	1c11      	adds	r1, r2, #0
 801129a:	1c02      	adds	r2, r0, #0
 801129c:	430a      	orrs	r2, r1
 801129e:	745a      	strb	r2, [r3, #17]
#endif /* TCP_CHECKSUM_ON_COPY */
  }
#endif /* CHECKSUM_GEN_TCP */
  TCP_STATS_INC(tcp.xmit);

  NETIF_SET_HINTS(netif, &(pcb->netif_hints));
 80112a0:	68bb      	ldr	r3, [r7, #8]
 80112a2:	330c      	adds	r3, #12
 80112a4:	001a      	movs	r2, r3
 80112a6:	687b      	ldr	r3, [r7, #4]
 80112a8:	639a      	str	r2, [r3, #56]	; 0x38
  err = ip_output_if(seg->p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
 80112aa:	68fb      	ldr	r3, [r7, #12]
 80112ac:	6858      	ldr	r0, [r3, #4]
 80112ae:	68b9      	ldr	r1, [r7, #8]
 80112b0:	68bb      	ldr	r3, [r7, #8]
 80112b2:	1d1d      	adds	r5, r3, #4
 80112b4:	68bb      	ldr	r3, [r7, #8]
 80112b6:	7ade      	ldrb	r6, [r3, #11]
 80112b8:	68bb      	ldr	r3, [r7, #8]
 80112ba:	7a9b      	ldrb	r3, [r3, #10]
 80112bc:	2217      	movs	r2, #23
 80112be:	18bc      	adds	r4, r7, r2
 80112c0:	687a      	ldr	r2, [r7, #4]
 80112c2:	9202      	str	r2, [sp, #8]
 80112c4:	2206      	movs	r2, #6
 80112c6:	9201      	str	r2, [sp, #4]
 80112c8:	9300      	str	r3, [sp, #0]
 80112ca:	0033      	movs	r3, r6
 80112cc:	002a      	movs	r2, r5
 80112ce:	f002 fa09 	bl	80136e4 <ip4_output_if>
 80112d2:	0003      	movs	r3, r0
 80112d4:	7023      	strb	r3, [r4, #0]
                     pcb->tos, IP_PROTO_TCP, netif);
  NETIF_RESET_HINTS(netif);
 80112d6:	687b      	ldr	r3, [r7, #4]
 80112d8:	2200      	movs	r2, #0
 80112da:	639a      	str	r2, [r3, #56]	; 0x38

#if TCP_CHECKSUM_ON_COPY
  if (seg_chksum_was_swapped) {
 80112dc:	6a3b      	ldr	r3, [r7, #32]
 80112de:	2b00      	cmp	r3, #0
 80112e0:	d010      	beq.n	8011304 <tcp_output_segment+0x370>
    /* if data is added to this segment later, chksum needs to be swapped,
       so restore this now */
    seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
 80112e2:	68fb      	ldr	r3, [r7, #12]
 80112e4:	899b      	ldrh	r3, [r3, #12]
 80112e6:	021b      	lsls	r3, r3, #8
 80112e8:	b21a      	sxth	r2, r3
 80112ea:	68fb      	ldr	r3, [r7, #12]
 80112ec:	899b      	ldrh	r3, [r3, #12]
 80112ee:	0a1b      	lsrs	r3, r3, #8
 80112f0:	b29b      	uxth	r3, r3
 80112f2:	b21b      	sxth	r3, r3
 80112f4:	4313      	orrs	r3, r2
 80112f6:	b21b      	sxth	r3, r3
 80112f8:	b29a      	uxth	r2, r3
 80112fa:	68fb      	ldr	r3, [r7, #12]
 80112fc:	819a      	strh	r2, [r3, #12]
    seg->chksum_swapped = 1;
 80112fe:	68fb      	ldr	r3, [r7, #12]
 8011300:	2201      	movs	r2, #1
 8011302:	739a      	strb	r2, [r3, #14]
  }
#endif

  return err;
 8011304:	2317      	movs	r3, #23
 8011306:	18fb      	adds	r3, r7, r3
 8011308:	781b      	ldrb	r3, [r3, #0]
 801130a:	b25b      	sxtb	r3, r3
}
 801130c:	0018      	movs	r0, r3
 801130e:	46bd      	mov	sp, r7
 8011310:	b00b      	add	sp, #44	; 0x2c
 8011312:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8011314:	08020658 	.word	0x08020658
 8011318:	000005b9 	.word	0x000005b9
 801131c:	08020cf8 	.word	0x08020cf8
 8011320:	080206a4 	.word	0x080206a4
 8011324:	000005ba 	.word	0x000005ba
 8011328:	08020d18 	.word	0x08020d18
 801132c:	000005bb 	.word	0x000005bb
 8011330:	08020d38 	.word	0x08020d38
 8011334:	20002ed8 	.word	0x20002ed8
 8011338:	0000061d 	.word	0x0000061d
 801133c:	08020d5c 	.word	0x08020d5c
 8011340:	08020d70 	.word	0x08020d70

08011344 <tcp_rexmit_rto_prepare>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
err_t
tcp_rexmit_rto_prepare(struct tcp_pcb *pcb)
{
 8011344:	b5b0      	push	{r4, r5, r7, lr}
 8011346:	b084      	sub	sp, #16
 8011348:	af00      	add	r7, sp, #0
 801134a:	6078      	str	r0, [r7, #4]
  struct tcp_seg *seg;

  LWIP_ASSERT("tcp_rexmit_rto_prepare: invalid pcb", pcb != NULL);
 801134c:	687b      	ldr	r3, [r7, #4]
 801134e:	2b00      	cmp	r3, #0
 8011350:	d105      	bne.n	801135e <tcp_rexmit_rto_prepare+0x1a>
 8011352:	4b3c      	ldr	r3, [pc, #240]	; (8011444 <tcp_rexmit_rto_prepare+0x100>)
 8011354:	4a3c      	ldr	r2, [pc, #240]	; (8011448 <tcp_rexmit_rto_prepare+0x104>)
 8011356:	493d      	ldr	r1, [pc, #244]	; (801144c <tcp_rexmit_rto_prepare+0x108>)
 8011358:	483d      	ldr	r0, [pc, #244]	; (8011450 <tcp_rexmit_rto_prepare+0x10c>)
 801135a:	f7f1 fabf 	bl	80028dc <app_debug_rtt_raw>

  if (pcb->unacked == NULL) {
 801135e:	687b      	ldr	r3, [r7, #4]
 8011360:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8011362:	2b00      	cmp	r3, #0
 8011364:	d102      	bne.n	801136c <tcp_rexmit_rto_prepare+0x28>
    return ERR_VAL;
 8011366:	2306      	movs	r3, #6
 8011368:	425b      	negs	r3, r3
 801136a:	e066      	b.n	801143a <tcp_rexmit_rto_prepare+0xf6>

  /* Move all unacked segments to the head of the unsent queue.
     However, give up if any of the unsent pbufs are still referenced by the
     netif driver due to deferred transmission. No point loading the link further
     if it is struggling to flush its buffered writes. */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next) {
 801136c:	687b      	ldr	r3, [r7, #4]
 801136e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8011370:	60fb      	str	r3, [r7, #12]
 8011372:	e00b      	b.n	801138c <tcp_rexmit_rto_prepare+0x48>
    if (tcp_output_segment_busy(seg)) {
 8011374:	68fb      	ldr	r3, [r7, #12]
 8011376:	0018      	movs	r0, r3
 8011378:	f7ff fdea 	bl	8010f50 <tcp_output_segment_busy>
 801137c:	1e03      	subs	r3, r0, #0
 801137e:	d002      	beq.n	8011386 <tcp_rexmit_rto_prepare+0x42>
      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_rexmit_rto: segment busy\n"));
      return ERR_VAL;
 8011380:	2306      	movs	r3, #6
 8011382:	425b      	negs	r3, r3
 8011384:	e059      	b.n	801143a <tcp_rexmit_rto_prepare+0xf6>
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next) {
 8011386:	68fb      	ldr	r3, [r7, #12]
 8011388:	681b      	ldr	r3, [r3, #0]
 801138a:	60fb      	str	r3, [r7, #12]
 801138c:	68fb      	ldr	r3, [r7, #12]
 801138e:	681b      	ldr	r3, [r3, #0]
 8011390:	2b00      	cmp	r3, #0
 8011392:	d1ef      	bne.n	8011374 <tcp_rexmit_rto_prepare+0x30>
    }
  }
  if (tcp_output_segment_busy(seg)) {
 8011394:	68fb      	ldr	r3, [r7, #12]
 8011396:	0018      	movs	r0, r3
 8011398:	f7ff fdda 	bl	8010f50 <tcp_output_segment_busy>
 801139c:	1e03      	subs	r3, r0, #0
 801139e:	d002      	beq.n	80113a6 <tcp_rexmit_rto_prepare+0x62>
    LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_rexmit_rto: segment busy\n"));
    return ERR_VAL;
 80113a0:	2306      	movs	r3, #6
 80113a2:	425b      	negs	r3, r3
 80113a4:	e049      	b.n	801143a <tcp_rexmit_rto_prepare+0xf6>
  }
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
 80113a6:	687b      	ldr	r3, [r7, #4]
 80113a8:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80113aa:	68fb      	ldr	r3, [r7, #12]
 80113ac:	601a      	str	r2, [r3, #0]
#if TCP_OVERSIZE_DBGCHECK
  /* if last unsent changed, we need to update unsent_oversize */
  if (pcb->unsent == NULL) {
 80113ae:	687b      	ldr	r3, [r7, #4]
 80113b0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80113b2:	2b00      	cmp	r3, #0
 80113b4:	d104      	bne.n	80113c0 <tcp_rexmit_rto_prepare+0x7c>
    pcb->unsent_oversize = seg->oversize_left;
 80113b6:	68fb      	ldr	r3, [r7, #12]
 80113b8:	8959      	ldrh	r1, [r3, #10]
 80113ba:	687b      	ldr	r3, [r7, #4]
 80113bc:	226c      	movs	r2, #108	; 0x6c
 80113be:	5299      	strh	r1, [r3, r2]
  }
#endif /* TCP_OVERSIZE_DBGCHECK */
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
 80113c0:	687b      	ldr	r3, [r7, #4]
 80113c2:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 80113c4:	687b      	ldr	r3, [r7, #4]
 80113c6:	671a      	str	r2, [r3, #112]	; 0x70
  /* unacked queue is now empty */
  pcb->unacked = NULL;
 80113c8:	687b      	ldr	r3, [r7, #4]
 80113ca:	2200      	movs	r2, #0
 80113cc:	675a      	str	r2, [r3, #116]	; 0x74

  /* Mark RTO in-progress */
  tcp_set_flags(pcb, TF_RTO);
 80113ce:	687b      	ldr	r3, [r7, #4]
 80113d0:	8bdb      	ldrh	r3, [r3, #30]
 80113d2:	2280      	movs	r2, #128	; 0x80
 80113d4:	0112      	lsls	r2, r2, #4
 80113d6:	4313      	orrs	r3, r2
 80113d8:	b29a      	uxth	r2, r3
 80113da:	687b      	ldr	r3, [r7, #4]
 80113dc:	83da      	strh	r2, [r3, #30]
  /* Record the next byte following retransmit */
  pcb->rto_end = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 80113de:	68fb      	ldr	r3, [r7, #12]
 80113e0:	691b      	ldr	r3, [r3, #16]
 80113e2:	791a      	ldrb	r2, [r3, #4]
 80113e4:	7959      	ldrb	r1, [r3, #5]
 80113e6:	0209      	lsls	r1, r1, #8
 80113e8:	430a      	orrs	r2, r1
 80113ea:	7999      	ldrb	r1, [r3, #6]
 80113ec:	0409      	lsls	r1, r1, #16
 80113ee:	430a      	orrs	r2, r1
 80113f0:	79db      	ldrb	r3, [r3, #7]
 80113f2:	061b      	lsls	r3, r3, #24
 80113f4:	4313      	orrs	r3, r2
 80113f6:	0018      	movs	r0, r3
 80113f8:	f7f5 fc1c 	bl	8006c34 <lwip_htonl>
 80113fc:	0004      	movs	r4, r0
 80113fe:	68fb      	ldr	r3, [r7, #12]
 8011400:	891b      	ldrh	r3, [r3, #8]
 8011402:	001d      	movs	r5, r3
 8011404:	68fb      	ldr	r3, [r7, #12]
 8011406:	691b      	ldr	r3, [r3, #16]
 8011408:	7b1a      	ldrb	r2, [r3, #12]
 801140a:	7b5b      	ldrb	r3, [r3, #13]
 801140c:	021b      	lsls	r3, r3, #8
 801140e:	4313      	orrs	r3, r2
 8011410:	b29b      	uxth	r3, r3
 8011412:	0018      	movs	r0, r3
 8011414:	f7f5 fbf8 	bl	8006c08 <lwip_htons>
 8011418:	0003      	movs	r3, r0
 801141a:	b2db      	uxtb	r3, r3
 801141c:	001a      	movs	r2, r3
 801141e:	2303      	movs	r3, #3
 8011420:	4013      	ands	r3, r2
 8011422:	d001      	beq.n	8011428 <tcp_rexmit_rto_prepare+0xe4>
 8011424:	2301      	movs	r3, #1
 8011426:	e000      	b.n	801142a <tcp_rexmit_rto_prepare+0xe6>
 8011428:	2300      	movs	r3, #0
 801142a:	195b      	adds	r3, r3, r5
 801142c:	18e2      	adds	r2, r4, r3
 801142e:	687b      	ldr	r3, [r7, #4]
 8011430:	651a      	str	r2, [r3, #80]	; 0x50
  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
 8011432:	687b      	ldr	r3, [r7, #4]
 8011434:	2200      	movs	r2, #0
 8011436:	639a      	str	r2, [r3, #56]	; 0x38

  return ERR_OK;
 8011438:	2300      	movs	r3, #0
}
 801143a:	0018      	movs	r0, r3
 801143c:	46bd      	mov	sp, r7
 801143e:	b004      	add	sp, #16
 8011440:	bdb0      	pop	{r4, r5, r7, pc}
 8011442:	46c0      	nop			; (mov r8, r8)
 8011444:	08020658 	.word	0x08020658
 8011448:	00000664 	.word	0x00000664
 801144c:	08020d94 	.word	0x08020d94
 8011450:	080206a4 	.word	0x080206a4

08011454 <tcp_rexmit_rto_commit>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto_commit(struct tcp_pcb *pcb)
{
 8011454:	b580      	push	{r7, lr}
 8011456:	b082      	sub	sp, #8
 8011458:	af00      	add	r7, sp, #0
 801145a:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_rexmit_rto_commit: invalid pcb", pcb != NULL);
 801145c:	687b      	ldr	r3, [r7, #4]
 801145e:	2b00      	cmp	r3, #0
 8011460:	d105      	bne.n	801146e <tcp_rexmit_rto_commit+0x1a>
 8011462:	4b0d      	ldr	r3, [pc, #52]	; (8011498 <tcp_rexmit_rto_commit+0x44>)
 8011464:	4a0d      	ldr	r2, [pc, #52]	; (801149c <tcp_rexmit_rto_commit+0x48>)
 8011466:	490e      	ldr	r1, [pc, #56]	; (80114a0 <tcp_rexmit_rto_commit+0x4c>)
 8011468:	480e      	ldr	r0, [pc, #56]	; (80114a4 <tcp_rexmit_rto_commit+0x50>)
 801146a:	f7f1 fa37 	bl	80028dc <app_debug_rtt_raw>

  /* increment number of retransmissions */
  if (pcb->nrtx < 0xFF) {
 801146e:	687b      	ldr	r3, [r7, #4]
 8011470:	2246      	movs	r2, #70	; 0x46
 8011472:	5c9b      	ldrb	r3, [r3, r2]
 8011474:	2bff      	cmp	r3, #255	; 0xff
 8011476:	d007      	beq.n	8011488 <tcp_rexmit_rto_commit+0x34>
    ++pcb->nrtx;
 8011478:	687b      	ldr	r3, [r7, #4]
 801147a:	2246      	movs	r2, #70	; 0x46
 801147c:	5c9b      	ldrb	r3, [r3, r2]
 801147e:	3301      	adds	r3, #1
 8011480:	b2d9      	uxtb	r1, r3
 8011482:	687b      	ldr	r3, [r7, #4]
 8011484:	2246      	movs	r2, #70	; 0x46
 8011486:	5499      	strb	r1, [r3, r2]
  }
  /* Do the actual retransmission */
  tcp_output(pcb);
 8011488:	687b      	ldr	r3, [r7, #4]
 801148a:	0018      	movs	r0, r3
 801148c:	f7ff fb00 	bl	8010a90 <tcp_output>
}
 8011490:	46c0      	nop			; (mov r8, r8)
 8011492:	46bd      	mov	sp, r7
 8011494:	b002      	add	sp, #8
 8011496:	bd80      	pop	{r7, pc}
 8011498:	08020658 	.word	0x08020658
 801149c:	00000699 	.word	0x00000699
 80114a0:	08020db8 	.word	0x08020db8
 80114a4:	080206a4 	.word	0x080206a4

080114a8 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
 80114a8:	b580      	push	{r7, lr}
 80114aa:	b082      	sub	sp, #8
 80114ac:	af00      	add	r7, sp, #0
 80114ae:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_rexmit_rto: invalid pcb", pcb != NULL);
 80114b0:	687b      	ldr	r3, [r7, #4]
 80114b2:	2b00      	cmp	r3, #0
 80114b4:	d105      	bne.n	80114c2 <tcp_rexmit_rto+0x1a>
 80114b6:	4b0a      	ldr	r3, [pc, #40]	; (80114e0 <tcp_rexmit_rto+0x38>)
 80114b8:	4a0a      	ldr	r2, [pc, #40]	; (80114e4 <tcp_rexmit_rto+0x3c>)
 80114ba:	490b      	ldr	r1, [pc, #44]	; (80114e8 <tcp_rexmit_rto+0x40>)
 80114bc:	480b      	ldr	r0, [pc, #44]	; (80114ec <tcp_rexmit_rto+0x44>)
 80114be:	f7f1 fa0d 	bl	80028dc <app_debug_rtt_raw>

  if (tcp_rexmit_rto_prepare(pcb) == ERR_OK) {
 80114c2:	687b      	ldr	r3, [r7, #4]
 80114c4:	0018      	movs	r0, r3
 80114c6:	f7ff ff3d 	bl	8011344 <tcp_rexmit_rto_prepare>
 80114ca:	1e03      	subs	r3, r0, #0
 80114cc:	d103      	bne.n	80114d6 <tcp_rexmit_rto+0x2e>
    tcp_rexmit_rto_commit(pcb);
 80114ce:	687b      	ldr	r3, [r7, #4]
 80114d0:	0018      	movs	r0, r3
 80114d2:	f7ff ffbf 	bl	8011454 <tcp_rexmit_rto_commit>
  }
}
 80114d6:	46c0      	nop			; (mov r8, r8)
 80114d8:	46bd      	mov	sp, r7
 80114da:	b002      	add	sp, #8
 80114dc:	bd80      	pop	{r7, pc}
 80114de:	46c0      	nop			; (mov r8, r8)
 80114e0:	08020658 	.word	0x08020658
 80114e4:	000006ae 	.word	0x000006ae
 80114e8:	08020ddc 	.word	0x08020ddc
 80114ec:	080206a4 	.word	0x080206a4

080114f0 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
err_t
tcp_rexmit(struct tcp_pcb *pcb)
{
 80114f0:	b590      	push	{r4, r7, lr}
 80114f2:	b085      	sub	sp, #20
 80114f4:	af00      	add	r7, sp, #0
 80114f6:	6078      	str	r0, [r7, #4]
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  LWIP_ASSERT("tcp_rexmit: invalid pcb", pcb != NULL);
 80114f8:	687b      	ldr	r3, [r7, #4]
 80114fa:	2b00      	cmp	r3, #0
 80114fc:	d105      	bne.n	801150a <tcp_rexmit+0x1a>
 80114fe:	4b37      	ldr	r3, [pc, #220]	; (80115dc <tcp_rexmit+0xec>)
 8011500:	4a37      	ldr	r2, [pc, #220]	; (80115e0 <tcp_rexmit+0xf0>)
 8011502:	4938      	ldr	r1, [pc, #224]	; (80115e4 <tcp_rexmit+0xf4>)
 8011504:	4838      	ldr	r0, [pc, #224]	; (80115e8 <tcp_rexmit+0xf8>)
 8011506:	f7f1 f9e9 	bl	80028dc <app_debug_rtt_raw>

  if (pcb->unacked == NULL) {
 801150a:	687b      	ldr	r3, [r7, #4]
 801150c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 801150e:	2b00      	cmp	r3, #0
 8011510:	d102      	bne.n	8011518 <tcp_rexmit+0x28>
    return ERR_VAL;
 8011512:	2306      	movs	r3, #6
 8011514:	425b      	negs	r3, r3
 8011516:	e05d      	b.n	80115d4 <tcp_rexmit+0xe4>
  }

  seg = pcb->unacked;
 8011518:	687b      	ldr	r3, [r7, #4]
 801151a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 801151c:	60bb      	str	r3, [r7, #8]

  /* Give up if the segment is still referenced by the netif driver
     due to deferred transmission. */
  if (tcp_output_segment_busy(seg)) {
 801151e:	68bb      	ldr	r3, [r7, #8]
 8011520:	0018      	movs	r0, r3
 8011522:	f7ff fd15 	bl	8010f50 <tcp_output_segment_busy>
 8011526:	1e03      	subs	r3, r0, #0
 8011528:	d002      	beq.n	8011530 <tcp_rexmit+0x40>
    LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_rexmit busy\n"));
    return ERR_VAL;
 801152a:	2306      	movs	r3, #6
 801152c:	425b      	negs	r3, r3
 801152e:	e051      	b.n	80115d4 <tcp_rexmit+0xe4>
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  pcb->unacked = seg->next;
 8011530:	68bb      	ldr	r3, [r7, #8]
 8011532:	681a      	ldr	r2, [r3, #0]
 8011534:	687b      	ldr	r3, [r7, #4]
 8011536:	675a      	str	r2, [r3, #116]	; 0x74

  cur_seg = &(pcb->unsent);
 8011538:	687b      	ldr	r3, [r7, #4]
 801153a:	3370      	adds	r3, #112	; 0x70
 801153c:	60fb      	str	r3, [r7, #12]
  while (*cur_seg &&
 801153e:	e002      	b.n	8011546 <tcp_rexmit+0x56>
         TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
    cur_seg = &((*cur_seg)->next );
 8011540:	68fb      	ldr	r3, [r7, #12]
 8011542:	681b      	ldr	r3, [r3, #0]
 8011544:	60fb      	str	r3, [r7, #12]
  while (*cur_seg &&
 8011546:	68fb      	ldr	r3, [r7, #12]
 8011548:	681b      	ldr	r3, [r3, #0]
 801154a:	2b00      	cmp	r3, #0
 801154c:	d022      	beq.n	8011594 <tcp_rexmit+0xa4>
         TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
 801154e:	68fb      	ldr	r3, [r7, #12]
 8011550:	681b      	ldr	r3, [r3, #0]
 8011552:	691b      	ldr	r3, [r3, #16]
 8011554:	791a      	ldrb	r2, [r3, #4]
 8011556:	7959      	ldrb	r1, [r3, #5]
 8011558:	0209      	lsls	r1, r1, #8
 801155a:	430a      	orrs	r2, r1
 801155c:	7999      	ldrb	r1, [r3, #6]
 801155e:	0409      	lsls	r1, r1, #16
 8011560:	430a      	orrs	r2, r1
 8011562:	79db      	ldrb	r3, [r3, #7]
 8011564:	061b      	lsls	r3, r3, #24
 8011566:	4313      	orrs	r3, r2
 8011568:	0018      	movs	r0, r3
 801156a:	f7f5 fb63 	bl	8006c34 <lwip_htonl>
 801156e:	0004      	movs	r4, r0
 8011570:	68bb      	ldr	r3, [r7, #8]
 8011572:	691b      	ldr	r3, [r3, #16]
 8011574:	791a      	ldrb	r2, [r3, #4]
 8011576:	7959      	ldrb	r1, [r3, #5]
 8011578:	0209      	lsls	r1, r1, #8
 801157a:	430a      	orrs	r2, r1
 801157c:	7999      	ldrb	r1, [r3, #6]
 801157e:	0409      	lsls	r1, r1, #16
 8011580:	430a      	orrs	r2, r1
 8011582:	79db      	ldrb	r3, [r3, #7]
 8011584:	061b      	lsls	r3, r3, #24
 8011586:	4313      	orrs	r3, r2
 8011588:	0018      	movs	r0, r3
 801158a:	f7f5 fb53 	bl	8006c34 <lwip_htonl>
 801158e:	0003      	movs	r3, r0
 8011590:	1ae3      	subs	r3, r4, r3
  while (*cur_seg &&
 8011592:	d4d5      	bmi.n	8011540 <tcp_rexmit+0x50>
  }
  seg->next = *cur_seg;
 8011594:	68fb      	ldr	r3, [r7, #12]
 8011596:	681a      	ldr	r2, [r3, #0]
 8011598:	68bb      	ldr	r3, [r7, #8]
 801159a:	601a      	str	r2, [r3, #0]
  *cur_seg = seg;
 801159c:	68fb      	ldr	r3, [r7, #12]
 801159e:	68ba      	ldr	r2, [r7, #8]
 80115a0:	601a      	str	r2, [r3, #0]
#if TCP_OVERSIZE
  if (seg->next == NULL) {
 80115a2:	68bb      	ldr	r3, [r7, #8]
 80115a4:	681b      	ldr	r3, [r3, #0]
 80115a6:	2b00      	cmp	r3, #0
 80115a8:	d103      	bne.n	80115b2 <tcp_rexmit+0xc2>
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
 80115aa:	687b      	ldr	r3, [r7, #4]
 80115ac:	226c      	movs	r2, #108	; 0x6c
 80115ae:	2100      	movs	r1, #0
 80115b0:	5299      	strh	r1, [r3, r2]
  }
#endif /* TCP_OVERSIZE */

  if (pcb->nrtx < 0xFF) {
 80115b2:	687b      	ldr	r3, [r7, #4]
 80115b4:	2246      	movs	r2, #70	; 0x46
 80115b6:	5c9b      	ldrb	r3, [r3, r2]
 80115b8:	2bff      	cmp	r3, #255	; 0xff
 80115ba:	d007      	beq.n	80115cc <tcp_rexmit+0xdc>
    ++pcb->nrtx;
 80115bc:	687b      	ldr	r3, [r7, #4]
 80115be:	2246      	movs	r2, #70	; 0x46
 80115c0:	5c9b      	ldrb	r3, [r3, r2]
 80115c2:	3301      	adds	r3, #1
 80115c4:	b2d9      	uxtb	r1, r3
 80115c6:	687b      	ldr	r3, [r7, #4]
 80115c8:	2246      	movs	r2, #70	; 0x46
 80115ca:	5499      	strb	r1, [r3, r2]
  }

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
 80115cc:	687b      	ldr	r3, [r7, #4]
 80115ce:	2200      	movs	r2, #0
 80115d0:	639a      	str	r2, [r3, #56]	; 0x38

  /* Do the actual retransmission. */
  MIB2_STATS_INC(mib2.tcpretranssegs);
  /* No need to call tcp_output: we are always called from tcp_input()
     and thus tcp_output directly returns. */
  return ERR_OK;
 80115d2:	2300      	movs	r3, #0
}
 80115d4:	0018      	movs	r0, r3
 80115d6:	46bd      	mov	sp, r7
 80115d8:	b005      	add	sp, #20
 80115da:	bd90      	pop	{r4, r7, pc}
 80115dc:	08020658 	.word	0x08020658
 80115e0:	000006c2 	.word	0x000006c2
 80115e4:	08020df8 	.word	0x08020df8
 80115e8:	080206a4 	.word	0x080206a4

080115ec <tcp_rexmit_fast>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
 80115ec:	b580      	push	{r7, lr}
 80115ee:	b082      	sub	sp, #8
 80115f0:	af00      	add	r7, sp, #0
 80115f2:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_rexmit_fast: invalid pcb", pcb != NULL);
 80115f4:	687b      	ldr	r3, [r7, #4]
 80115f6:	2b00      	cmp	r3, #0
 80115f8:	d105      	bne.n	8011606 <tcp_rexmit_fast+0x1a>
 80115fa:	4b2c      	ldr	r3, [pc, #176]	; (80116ac <tcp_rexmit_fast+0xc0>)
 80115fc:	4a2c      	ldr	r2, [pc, #176]	; (80116b0 <tcp_rexmit_fast+0xc4>)
 80115fe:	492d      	ldr	r1, [pc, #180]	; (80116b4 <tcp_rexmit_fast+0xc8>)
 8011600:	482d      	ldr	r0, [pc, #180]	; (80116b8 <tcp_rexmit_fast+0xcc>)
 8011602:	f7f1 f96b 	bl	80028dc <app_debug_rtt_raw>

  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
 8011606:	687b      	ldr	r3, [r7, #4]
 8011608:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 801160a:	2b00      	cmp	r3, #0
 801160c:	d049      	beq.n	80116a2 <tcp_rexmit_fast+0xb6>
 801160e:	687b      	ldr	r3, [r7, #4]
 8011610:	8bdb      	ldrh	r3, [r3, #30]
 8011612:	001a      	movs	r2, r3
 8011614:	2304      	movs	r3, #4
 8011616:	4013      	ands	r3, r2
 8011618:	d143      	bne.n	80116a2 <tcp_rexmit_fast+0xb6>
    LWIP_DEBUGF(TCP_FR_DEBUG,
                ("tcp_receive: dupacks %"U16_F" (%"U32_F
                 "), fast retransmit %"U32_F"\n",
                 (u16_t)pcb->dupacks, pcb->lastack,
                 lwip_ntohl(pcb->unacked->tcphdr->seqno)));
    if (tcp_rexmit(pcb) == ERR_OK) {
 801161a:	687b      	ldr	r3, [r7, #4]
 801161c:	0018      	movs	r0, r3
 801161e:	f7ff ff67 	bl	80114f0 <tcp_rexmit>
 8011622:	1e03      	subs	r3, r0, #0
 8011624:	d13d      	bne.n	80116a2 <tcp_rexmit_fast+0xb6>
      /* Set ssthresh to half of the minimum of the current
       * cwnd and the advertised window */
      pcb->ssthresh = LWIP_MIN(pcb->cwnd, pcb->snd_wnd) / 2;
 8011626:	687b      	ldr	r3, [r7, #4]
 8011628:	2264      	movs	r2, #100	; 0x64
 801162a:	5a99      	ldrh	r1, [r3, r2]
 801162c:	687b      	ldr	r3, [r7, #4]
 801162e:	224c      	movs	r2, #76	; 0x4c
 8011630:	5a9b      	ldrh	r3, [r3, r2]
 8011632:	1c18      	adds	r0, r3, #0
 8011634:	b28a      	uxth	r2, r1
 8011636:	b283      	uxth	r3, r0
 8011638:	429a      	cmp	r2, r3
 801163a:	d900      	bls.n	801163e <tcp_rexmit_fast+0x52>
 801163c:	1c01      	adds	r1, r0, #0
 801163e:	b28b      	uxth	r3, r1
 8011640:	2b00      	cmp	r3, #0
 8011642:	da00      	bge.n	8011646 <tcp_rexmit_fast+0x5a>
 8011644:	3301      	adds	r3, #1
 8011646:	105b      	asrs	r3, r3, #1
 8011648:	b299      	uxth	r1, r3
 801164a:	687b      	ldr	r3, [r7, #4]
 801164c:	224e      	movs	r2, #78	; 0x4e
 801164e:	5299      	strh	r1, [r3, r2]

      /* The minimum value for ssthresh should be 2 MSS */
      if (pcb->ssthresh < (2U * pcb->mss)) {
 8011650:	687b      	ldr	r3, [r7, #4]
 8011652:	224e      	movs	r2, #78	; 0x4e
 8011654:	5a9b      	ldrh	r3, [r3, r2]
 8011656:	001a      	movs	r2, r3
 8011658:	687b      	ldr	r3, [r7, #4]
 801165a:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 801165c:	005b      	lsls	r3, r3, #1
 801165e:	429a      	cmp	r2, r3
 8011660:	d206      	bcs.n	8011670 <tcp_rexmit_fast+0x84>
        LWIP_DEBUGF(TCP_FR_DEBUG,
                    ("tcp_receive: The minimum value for ssthresh %"TCPWNDSIZE_F
                     " should be min 2 mss %"U16_F"...\n",
                     pcb->ssthresh, (u16_t)(2 * pcb->mss)));
        pcb->ssthresh = 2 * pcb->mss;
 8011662:	687b      	ldr	r3, [r7, #4]
 8011664:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8011666:	18db      	adds	r3, r3, r3
 8011668:	b299      	uxth	r1, r3
 801166a:	687b      	ldr	r3, [r7, #4]
 801166c:	224e      	movs	r2, #78	; 0x4e
 801166e:	5299      	strh	r1, [r3, r2]
      }

      pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
 8011670:	687b      	ldr	r3, [r7, #4]
 8011672:	224e      	movs	r2, #78	; 0x4e
 8011674:	5a9a      	ldrh	r2, [r3, r2]
 8011676:	687b      	ldr	r3, [r7, #4]
 8011678:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 801167a:	1c19      	adds	r1, r3, #0
 801167c:	1c0b      	adds	r3, r1, #0
 801167e:	18db      	adds	r3, r3, r3
 8011680:	185b      	adds	r3, r3, r1
 8011682:	b29b      	uxth	r3, r3
 8011684:	18d3      	adds	r3, r2, r3
 8011686:	b299      	uxth	r1, r3
 8011688:	687b      	ldr	r3, [r7, #4]
 801168a:	224c      	movs	r2, #76	; 0x4c
 801168c:	5299      	strh	r1, [r3, r2]
      tcp_set_flags(pcb, TF_INFR);
 801168e:	687b      	ldr	r3, [r7, #4]
 8011690:	8bdb      	ldrh	r3, [r3, #30]
 8011692:	2204      	movs	r2, #4
 8011694:	4313      	orrs	r3, r2
 8011696:	b29a      	uxth	r2, r3
 8011698:	687b      	ldr	r3, [r7, #4]
 801169a:	83da      	strh	r2, [r3, #30]

      /* Reset the retransmission timer to prevent immediate rto retransmissions */
      pcb->rtime = 0;
 801169c:	687b      	ldr	r3, [r7, #4]
 801169e:	2200      	movs	r2, #0
 80116a0:	869a      	strh	r2, [r3, #52]	; 0x34
    }
  }
}
 80116a2:	46c0      	nop			; (mov r8, r8)
 80116a4:	46bd      	mov	sp, r7
 80116a6:	b002      	add	sp, #8
 80116a8:	bd80      	pop	{r7, pc}
 80116aa:	46c0      	nop			; (mov r8, r8)
 80116ac:	08020658 	.word	0x08020658
 80116b0:	000006fa 	.word	0x000006fa
 80116b4:	08020e10 	.word	0x08020e10
 80116b8:	080206a4 	.word	0x080206a4

080116bc <tcp_output_alloc_header_common>:

static struct pbuf *
tcp_output_alloc_header_common(u32_t ackno, u16_t optlen, u16_t datalen,
                        u32_t seqno_be /* already in network byte order */,
                        u16_t src_port, u16_t dst_port, u8_t flags, u16_t wnd)
{
 80116bc:	b590      	push	{r4, r7, lr}
 80116be:	b087      	sub	sp, #28
 80116c0:	af00      	add	r7, sp, #0
 80116c2:	60f8      	str	r0, [r7, #12]
 80116c4:	0008      	movs	r0, r1
 80116c6:	0011      	movs	r1, r2
 80116c8:	607b      	str	r3, [r7, #4]
 80116ca:	240a      	movs	r4, #10
 80116cc:	193b      	adds	r3, r7, r4
 80116ce:	1c02      	adds	r2, r0, #0
 80116d0:	801a      	strh	r2, [r3, #0]
 80116d2:	2008      	movs	r0, #8
 80116d4:	183b      	adds	r3, r7, r0
 80116d6:	1c0a      	adds	r2, r1, #0
 80116d8:	801a      	strh	r2, [r3, #0]
  struct tcp_hdr *tcphdr;
  struct pbuf *p;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 80116da:	193a      	adds	r2, r7, r4
 80116dc:	183b      	adds	r3, r7, r0
 80116de:	8812      	ldrh	r2, [r2, #0]
 80116e0:	881b      	ldrh	r3, [r3, #0]
 80116e2:	18d3      	adds	r3, r2, r3
 80116e4:	b29b      	uxth	r3, r3
 80116e6:	3314      	adds	r3, #20
 80116e8:	b29b      	uxth	r3, r3
 80116ea:	22a0      	movs	r2, #160	; 0xa0
 80116ec:	0092      	lsls	r2, r2, #2
 80116ee:	0019      	movs	r1, r3
 80116f0:	2024      	movs	r0, #36	; 0x24
 80116f2:	f7f7 fef5 	bl	80094e0 <pbuf_alloc>
 80116f6:	0003      	movs	r3, r0
 80116f8:	617b      	str	r3, [r7, #20]
  if (p != NULL) {
 80116fa:	697b      	ldr	r3, [r7, #20]
 80116fc:	2b00      	cmp	r3, #0
 80116fe:	d100      	bne.n	8011702 <tcp_output_alloc_header_common+0x46>
 8011700:	e0f0      	b.n	80118e4 <tcp_output_alloc_header_common+0x228>
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
 8011702:	193b      	adds	r3, r7, r4
 8011704:	881b      	ldrh	r3, [r3, #0]
 8011706:	3313      	adds	r3, #19
 8011708:	697a      	ldr	r2, [r7, #20]
 801170a:	8952      	ldrh	r2, [r2, #10]
 801170c:	4293      	cmp	r3, r2
 801170e:	db05      	blt.n	801171c <tcp_output_alloc_header_common+0x60>
 8011710:	4b77      	ldr	r3, [pc, #476]	; (80118f0 <tcp_output_alloc_header_common+0x234>)
 8011712:	4a78      	ldr	r2, [pc, #480]	; (80118f4 <tcp_output_alloc_header_common+0x238>)
 8011714:	4978      	ldr	r1, [pc, #480]	; (80118f8 <tcp_output_alloc_header_common+0x23c>)
 8011716:	4879      	ldr	r0, [pc, #484]	; (80118fc <tcp_output_alloc_header_common+0x240>)
 8011718:	f7f1 f8e0 	bl	80028dc <app_debug_rtt_raw>
                (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
 801171c:	697b      	ldr	r3, [r7, #20]
 801171e:	685b      	ldr	r3, [r3, #4]
 8011720:	613b      	str	r3, [r7, #16]
    tcphdr->src = lwip_htons(src_port);
 8011722:	2328      	movs	r3, #40	; 0x28
 8011724:	18fb      	adds	r3, r7, r3
 8011726:	881b      	ldrh	r3, [r3, #0]
 8011728:	0018      	movs	r0, r3
 801172a:	f7f5 fa6d 	bl	8006c08 <lwip_htons>
 801172e:	0003      	movs	r3, r0
 8011730:	001a      	movs	r2, r3
 8011732:	693b      	ldr	r3, [r7, #16]
 8011734:	21ff      	movs	r1, #255	; 0xff
 8011736:	4011      	ands	r1, r2
 8011738:	000c      	movs	r4, r1
 801173a:	7819      	ldrb	r1, [r3, #0]
 801173c:	2000      	movs	r0, #0
 801173e:	4001      	ands	r1, r0
 8011740:	1c08      	adds	r0, r1, #0
 8011742:	1c21      	adds	r1, r4, #0
 8011744:	4301      	orrs	r1, r0
 8011746:	7019      	strb	r1, [r3, #0]
 8011748:	0a12      	lsrs	r2, r2, #8
 801174a:	b290      	uxth	r0, r2
 801174c:	785a      	ldrb	r2, [r3, #1]
 801174e:	2100      	movs	r1, #0
 8011750:	400a      	ands	r2, r1
 8011752:	1c11      	adds	r1, r2, #0
 8011754:	1c02      	adds	r2, r0, #0
 8011756:	430a      	orrs	r2, r1
 8011758:	705a      	strb	r2, [r3, #1]
    tcphdr->dest = lwip_htons(dst_port);
 801175a:	232c      	movs	r3, #44	; 0x2c
 801175c:	18fb      	adds	r3, r7, r3
 801175e:	881b      	ldrh	r3, [r3, #0]
 8011760:	0018      	movs	r0, r3
 8011762:	f7f5 fa51 	bl	8006c08 <lwip_htons>
 8011766:	0003      	movs	r3, r0
 8011768:	001a      	movs	r2, r3
 801176a:	693b      	ldr	r3, [r7, #16]
 801176c:	21ff      	movs	r1, #255	; 0xff
 801176e:	4011      	ands	r1, r2
 8011770:	000c      	movs	r4, r1
 8011772:	7899      	ldrb	r1, [r3, #2]
 8011774:	2000      	movs	r0, #0
 8011776:	4001      	ands	r1, r0
 8011778:	1c08      	adds	r0, r1, #0
 801177a:	1c21      	adds	r1, r4, #0
 801177c:	4301      	orrs	r1, r0
 801177e:	7099      	strb	r1, [r3, #2]
 8011780:	0a12      	lsrs	r2, r2, #8
 8011782:	b290      	uxth	r0, r2
 8011784:	78da      	ldrb	r2, [r3, #3]
 8011786:	2100      	movs	r1, #0
 8011788:	400a      	ands	r2, r1
 801178a:	1c11      	adds	r1, r2, #0
 801178c:	1c02      	adds	r2, r0, #0
 801178e:	430a      	orrs	r2, r1
 8011790:	70da      	strb	r2, [r3, #3]
    tcphdr->seqno = seqno_be;
 8011792:	693b      	ldr	r3, [r7, #16]
 8011794:	1d3a      	adds	r2, r7, #4
 8011796:	7810      	ldrb	r0, [r2, #0]
 8011798:	791a      	ldrb	r2, [r3, #4]
 801179a:	2100      	movs	r1, #0
 801179c:	400a      	ands	r2, r1
 801179e:	1c11      	adds	r1, r2, #0
 80117a0:	1c02      	adds	r2, r0, #0
 80117a2:	430a      	orrs	r2, r1
 80117a4:	711a      	strb	r2, [r3, #4]
 80117a6:	1d7a      	adds	r2, r7, #5
 80117a8:	7810      	ldrb	r0, [r2, #0]
 80117aa:	795a      	ldrb	r2, [r3, #5]
 80117ac:	2100      	movs	r1, #0
 80117ae:	400a      	ands	r2, r1
 80117b0:	1c11      	adds	r1, r2, #0
 80117b2:	1c02      	adds	r2, r0, #0
 80117b4:	430a      	orrs	r2, r1
 80117b6:	715a      	strb	r2, [r3, #5]
 80117b8:	1dba      	adds	r2, r7, #6
 80117ba:	7810      	ldrb	r0, [r2, #0]
 80117bc:	799a      	ldrb	r2, [r3, #6]
 80117be:	2100      	movs	r1, #0
 80117c0:	400a      	ands	r2, r1
 80117c2:	1c11      	adds	r1, r2, #0
 80117c4:	1c02      	adds	r2, r0, #0
 80117c6:	430a      	orrs	r2, r1
 80117c8:	719a      	strb	r2, [r3, #6]
 80117ca:	1dfa      	adds	r2, r7, #7
 80117cc:	7810      	ldrb	r0, [r2, #0]
 80117ce:	79da      	ldrb	r2, [r3, #7]
 80117d0:	2100      	movs	r1, #0
 80117d2:	400a      	ands	r2, r1
 80117d4:	1c11      	adds	r1, r2, #0
 80117d6:	1c02      	adds	r2, r0, #0
 80117d8:	430a      	orrs	r2, r1
 80117da:	71da      	strb	r2, [r3, #7]
    tcphdr->ackno = lwip_htonl(ackno);
 80117dc:	68fb      	ldr	r3, [r7, #12]
 80117de:	0018      	movs	r0, r3
 80117e0:	f7f5 fa28 	bl	8006c34 <lwip_htonl>
 80117e4:	0002      	movs	r2, r0
 80117e6:	693b      	ldr	r3, [r7, #16]
 80117e8:	21ff      	movs	r1, #255	; 0xff
 80117ea:	4011      	ands	r1, r2
 80117ec:	000c      	movs	r4, r1
 80117ee:	7a19      	ldrb	r1, [r3, #8]
 80117f0:	2000      	movs	r0, #0
 80117f2:	4001      	ands	r1, r0
 80117f4:	1c08      	adds	r0, r1, #0
 80117f6:	1c21      	adds	r1, r4, #0
 80117f8:	4301      	orrs	r1, r0
 80117fa:	7219      	strb	r1, [r3, #8]
 80117fc:	0a11      	lsrs	r1, r2, #8
 80117fe:	20ff      	movs	r0, #255	; 0xff
 8011800:	4001      	ands	r1, r0
 8011802:	000c      	movs	r4, r1
 8011804:	7a59      	ldrb	r1, [r3, #9]
 8011806:	2000      	movs	r0, #0
 8011808:	4001      	ands	r1, r0
 801180a:	1c08      	adds	r0, r1, #0
 801180c:	1c21      	adds	r1, r4, #0
 801180e:	4301      	orrs	r1, r0
 8011810:	7259      	strb	r1, [r3, #9]
 8011812:	0c11      	lsrs	r1, r2, #16
 8011814:	20ff      	movs	r0, #255	; 0xff
 8011816:	4001      	ands	r1, r0
 8011818:	000c      	movs	r4, r1
 801181a:	7a99      	ldrb	r1, [r3, #10]
 801181c:	2000      	movs	r0, #0
 801181e:	4001      	ands	r1, r0
 8011820:	1c08      	adds	r0, r1, #0
 8011822:	1c21      	adds	r1, r4, #0
 8011824:	4301      	orrs	r1, r0
 8011826:	7299      	strb	r1, [r3, #10]
 8011828:	0e10      	lsrs	r0, r2, #24
 801182a:	7ada      	ldrb	r2, [r3, #11]
 801182c:	2100      	movs	r1, #0
 801182e:	400a      	ands	r2, r1
 8011830:	1c11      	adds	r1, r2, #0
 8011832:	1c02      	adds	r2, r0, #0
 8011834:	430a      	orrs	r2, r1
 8011836:	72da      	strb	r2, [r3, #11]
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), flags);
 8011838:	230a      	movs	r3, #10
 801183a:	18fb      	adds	r3, r7, r3
 801183c:	881b      	ldrh	r3, [r3, #0]
 801183e:	089b      	lsrs	r3, r3, #2
 8011840:	b29b      	uxth	r3, r3
 8011842:	3305      	adds	r3, #5
 8011844:	b29b      	uxth	r3, r3
 8011846:	031b      	lsls	r3, r3, #12
 8011848:	b29a      	uxth	r2, r3
 801184a:	2330      	movs	r3, #48	; 0x30
 801184c:	18fb      	adds	r3, r7, r3
 801184e:	781b      	ldrb	r3, [r3, #0]
 8011850:	b29b      	uxth	r3, r3
 8011852:	4313      	orrs	r3, r2
 8011854:	b29b      	uxth	r3, r3
 8011856:	0018      	movs	r0, r3
 8011858:	f7f5 f9d6 	bl	8006c08 <lwip_htons>
 801185c:	0003      	movs	r3, r0
 801185e:	001a      	movs	r2, r3
 8011860:	693b      	ldr	r3, [r7, #16]
 8011862:	21ff      	movs	r1, #255	; 0xff
 8011864:	4011      	ands	r1, r2
 8011866:	000c      	movs	r4, r1
 8011868:	7b19      	ldrb	r1, [r3, #12]
 801186a:	2000      	movs	r0, #0
 801186c:	4001      	ands	r1, r0
 801186e:	1c08      	adds	r0, r1, #0
 8011870:	1c21      	adds	r1, r4, #0
 8011872:	4301      	orrs	r1, r0
 8011874:	7319      	strb	r1, [r3, #12]
 8011876:	0a12      	lsrs	r2, r2, #8
 8011878:	b290      	uxth	r0, r2
 801187a:	7b5a      	ldrb	r2, [r3, #13]
 801187c:	2100      	movs	r1, #0
 801187e:	400a      	ands	r2, r1
 8011880:	1c11      	adds	r1, r2, #0
 8011882:	1c02      	adds	r2, r0, #0
 8011884:	430a      	orrs	r2, r1
 8011886:	735a      	strb	r2, [r3, #13]
    tcphdr->wnd = lwip_htons(wnd);
 8011888:	2334      	movs	r3, #52	; 0x34
 801188a:	18fb      	adds	r3, r7, r3
 801188c:	881b      	ldrh	r3, [r3, #0]
 801188e:	0018      	movs	r0, r3
 8011890:	f7f5 f9ba 	bl	8006c08 <lwip_htons>
 8011894:	0003      	movs	r3, r0
 8011896:	001a      	movs	r2, r3
 8011898:	693b      	ldr	r3, [r7, #16]
 801189a:	21ff      	movs	r1, #255	; 0xff
 801189c:	4011      	ands	r1, r2
 801189e:	000c      	movs	r4, r1
 80118a0:	7b99      	ldrb	r1, [r3, #14]
 80118a2:	2000      	movs	r0, #0
 80118a4:	4001      	ands	r1, r0
 80118a6:	1c08      	adds	r0, r1, #0
 80118a8:	1c21      	adds	r1, r4, #0
 80118aa:	4301      	orrs	r1, r0
 80118ac:	7399      	strb	r1, [r3, #14]
 80118ae:	0a12      	lsrs	r2, r2, #8
 80118b0:	b290      	uxth	r0, r2
 80118b2:	7bda      	ldrb	r2, [r3, #15]
 80118b4:	2100      	movs	r1, #0
 80118b6:	400a      	ands	r2, r1
 80118b8:	1c11      	adds	r1, r2, #0
 80118ba:	1c02      	adds	r2, r0, #0
 80118bc:	430a      	orrs	r2, r1
 80118be:	73da      	strb	r2, [r3, #15]
    tcphdr->chksum = 0;
 80118c0:	693b      	ldr	r3, [r7, #16]
 80118c2:	7c1a      	ldrb	r2, [r3, #16]
 80118c4:	2100      	movs	r1, #0
 80118c6:	400a      	ands	r2, r1
 80118c8:	741a      	strb	r2, [r3, #16]
 80118ca:	7c5a      	ldrb	r2, [r3, #17]
 80118cc:	2100      	movs	r1, #0
 80118ce:	400a      	ands	r2, r1
 80118d0:	745a      	strb	r2, [r3, #17]
    tcphdr->urgp = 0;
 80118d2:	693b      	ldr	r3, [r7, #16]
 80118d4:	7c9a      	ldrb	r2, [r3, #18]
 80118d6:	2100      	movs	r1, #0
 80118d8:	400a      	ands	r2, r1
 80118da:	749a      	strb	r2, [r3, #18]
 80118dc:	7cda      	ldrb	r2, [r3, #19]
 80118de:	2100      	movs	r1, #0
 80118e0:	400a      	ands	r2, r1
 80118e2:	74da      	strb	r2, [r3, #19]
  }
  return p;
 80118e4:	697b      	ldr	r3, [r7, #20]
}
 80118e6:	0018      	movs	r0, r3
 80118e8:	46bd      	mov	sp, r7
 80118ea:	b007      	add	sp, #28
 80118ec:	bd90      	pop	{r4, r7, pc}
 80118ee:	46c0      	nop			; (mov r8, r8)
 80118f0:	08020658 	.word	0x08020658
 80118f4:	00000724 	.word	0x00000724
 80118f8:	08020e30 	.word	0x08020e30
 80118fc:	080206a4 	.word	0x080206a4

08011900 <tcp_output_alloc_header>:
 * @return pbuf with p->payload being the tcp_hdr
 */
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
                        u32_t seqno_be /* already in network byte order */)
{
 8011900:	b5f0      	push	{r4, r5, r6, r7, lr}
 8011902:	b08b      	sub	sp, #44	; 0x2c
 8011904:	af04      	add	r7, sp, #16
 8011906:	60f8      	str	r0, [r7, #12]
 8011908:	0008      	movs	r0, r1
 801190a:	0011      	movs	r1, r2
 801190c:	607b      	str	r3, [r7, #4]
 801190e:	230a      	movs	r3, #10
 8011910:	18fb      	adds	r3, r7, r3
 8011912:	1c02      	adds	r2, r0, #0
 8011914:	801a      	strh	r2, [r3, #0]
 8011916:	2308      	movs	r3, #8
 8011918:	18fb      	adds	r3, r7, r3
 801191a:	1c0a      	adds	r2, r1, #0
 801191c:	801a      	strh	r2, [r3, #0]
  struct pbuf *p;

  LWIP_ASSERT("tcp_output_alloc_header: invalid pcb", pcb != NULL);
 801191e:	68fb      	ldr	r3, [r7, #12]
 8011920:	2b00      	cmp	r3, #0
 8011922:	d105      	bne.n	8011930 <tcp_output_alloc_header+0x30>
 8011924:	4b18      	ldr	r3, [pc, #96]	; (8011988 <tcp_output_alloc_header+0x88>)
 8011926:	4a19      	ldr	r2, [pc, #100]	; (801198c <tcp_output_alloc_header+0x8c>)
 8011928:	4919      	ldr	r1, [pc, #100]	; (8011990 <tcp_output_alloc_header+0x90>)
 801192a:	481a      	ldr	r0, [pc, #104]	; (8011994 <tcp_output_alloc_header+0x94>)
 801192c:	f7f0 ffd6 	bl	80028dc <app_debug_rtt_raw>

  p = tcp_output_alloc_header_common(pcb->rcv_nxt, optlen, datalen,
 8011930:	68fb      	ldr	r3, [r7, #12]
 8011932:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 8011934:	68fb      	ldr	r3, [r7, #12]
 8011936:	8b5b      	ldrh	r3, [r3, #26]
 8011938:	68fa      	ldr	r2, [r7, #12]
 801193a:	8b92      	ldrh	r2, [r2, #28]
 801193c:	68f9      	ldr	r1, [r7, #12]
 801193e:	8dc9      	ldrh	r1, [r1, #46]	; 0x2e
 8011940:	687e      	ldr	r6, [r7, #4]
 8011942:	2008      	movs	r0, #8
 8011944:	1838      	adds	r0, r7, r0
 8011946:	8805      	ldrh	r5, [r0, #0]
 8011948:	200a      	movs	r0, #10
 801194a:	1838      	adds	r0, r7, r0
 801194c:	8800      	ldrh	r0, [r0, #0]
 801194e:	9103      	str	r1, [sp, #12]
 8011950:	2110      	movs	r1, #16
 8011952:	9102      	str	r1, [sp, #8]
 8011954:	9201      	str	r2, [sp, #4]
 8011956:	9300      	str	r3, [sp, #0]
 8011958:	0033      	movs	r3, r6
 801195a:	002a      	movs	r2, r5
 801195c:	0001      	movs	r1, r0
 801195e:	0020      	movs	r0, r4
 8011960:	f7ff feac 	bl	80116bc <tcp_output_alloc_header_common>
 8011964:	0003      	movs	r3, r0
 8011966:	617b      	str	r3, [r7, #20]
    seqno_be, pcb->local_port, pcb->remote_port, TCP_ACK,
    TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
  if (p != NULL) {
 8011968:	697b      	ldr	r3, [r7, #20]
 801196a:	2b00      	cmp	r3, #0
 801196c:	d006      	beq.n	801197c <tcp_output_alloc_header+0x7c>
    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 801196e:	68fb      	ldr	r3, [r7, #12]
 8011970:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8011972:	68fa      	ldr	r2, [r7, #12]
 8011974:	8dd2      	ldrh	r2, [r2, #46]	; 0x2e
 8011976:	189a      	adds	r2, r3, r2
 8011978:	68fb      	ldr	r3, [r7, #12]
 801197a:	631a      	str	r2, [r3, #48]	; 0x30
  }
  return p;
 801197c:	697b      	ldr	r3, [r7, #20]
}
 801197e:	0018      	movs	r0, r3
 8011980:	46bd      	mov	sp, r7
 8011982:	b007      	add	sp, #28
 8011984:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8011986:	46c0      	nop			; (mov r8, r8)
 8011988:	08020658 	.word	0x08020658
 801198c:	00000743 	.word	0x00000743
 8011990:	08020e60 	.word	0x08020e60
 8011994:	080206a4 	.word	0x080206a4

08011998 <tcp_output_fill_options>:

/* Fill in options for control segments */
static void
tcp_output_fill_options(const struct tcp_pcb *pcb, struct pbuf *p, u8_t optflags, u8_t num_sacks)
{
 8011998:	b580      	push	{r7, lr}
 801199a:	b088      	sub	sp, #32
 801199c:	af00      	add	r7, sp, #0
 801199e:	60f8      	str	r0, [r7, #12]
 80119a0:	60b9      	str	r1, [r7, #8]
 80119a2:	0019      	movs	r1, r3
 80119a4:	1dfb      	adds	r3, r7, #7
 80119a6:	701a      	strb	r2, [r3, #0]
 80119a8:	1dbb      	adds	r3, r7, #6
 80119aa:	1c0a      	adds	r2, r1, #0
 80119ac:	701a      	strb	r2, [r3, #0]
  struct tcp_hdr *tcphdr;
  u32_t *opts;
  u16_t sacks_len = 0;
 80119ae:	231e      	movs	r3, #30
 80119b0:	18fb      	adds	r3, r7, r3
 80119b2:	2200      	movs	r2, #0
 80119b4:	801a      	strh	r2, [r3, #0]

  LWIP_ASSERT("tcp_output_fill_options: invalid pbuf", p != NULL);
 80119b6:	68bb      	ldr	r3, [r7, #8]
 80119b8:	2b00      	cmp	r3, #0
 80119ba:	d105      	bne.n	80119c8 <tcp_output_fill_options+0x30>
 80119bc:	4b13      	ldr	r3, [pc, #76]	; (8011a0c <tcp_output_fill_options+0x74>)
 80119be:	4a14      	ldr	r2, [pc, #80]	; (8011a10 <tcp_output_fill_options+0x78>)
 80119c0:	4914      	ldr	r1, [pc, #80]	; (8011a14 <tcp_output_fill_options+0x7c>)
 80119c2:	4815      	ldr	r0, [pc, #84]	; (8011a18 <tcp_output_fill_options+0x80>)
 80119c4:	f7f0 ff8a 	bl	80028dc <app_debug_rtt_raw>

  tcphdr = (struct tcp_hdr *)p->payload;
 80119c8:	68bb      	ldr	r3, [r7, #8]
 80119ca:	685b      	ldr	r3, [r3, #4]
 80119cc:	61bb      	str	r3, [r7, #24]
  opts = (u32_t *)(void *)(tcphdr + 1);
 80119ce:	69bb      	ldr	r3, [r7, #24]
 80119d0:	3314      	adds	r3, #20
 80119d2:	617b      	str	r3, [r7, #20]
  opts = LWIP_HOOK_TCP_OUT_ADD_TCPOPTS(p, tcphdr, pcb, opts);
#endif

  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(sacks_len);
  LWIP_ASSERT("options not filled", (u8_t *)opts == ((u8_t *)(tcphdr + 1)) + sacks_len * 4 + LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb));
 80119d4:	69bb      	ldr	r3, [r7, #24]
 80119d6:	3314      	adds	r3, #20
 80119d8:	001a      	movs	r2, r3
 80119da:	231e      	movs	r3, #30
 80119dc:	18fb      	adds	r3, r7, r3
 80119de:	881b      	ldrh	r3, [r3, #0]
 80119e0:	009b      	lsls	r3, r3, #2
 80119e2:	0018      	movs	r0, r3
 80119e4:	1dfb      	adds	r3, r7, #7
 80119e6:	781b      	ldrb	r3, [r3, #0]
 80119e8:	009b      	lsls	r3, r3, #2
 80119ea:	2104      	movs	r1, #4
 80119ec:	400b      	ands	r3, r1
 80119ee:	18c3      	adds	r3, r0, r3
 80119f0:	18d3      	adds	r3, r2, r3
 80119f2:	697a      	ldr	r2, [r7, #20]
 80119f4:	429a      	cmp	r2, r3
 80119f6:	d005      	beq.n	8011a04 <tcp_output_fill_options+0x6c>
 80119f8:	4b04      	ldr	r3, [pc, #16]	; (8011a0c <tcp_output_fill_options+0x74>)
 80119fa:	4a08      	ldr	r2, [pc, #32]	; (8011a1c <tcp_output_fill_options+0x84>)
 80119fc:	4908      	ldr	r1, [pc, #32]	; (8011a20 <tcp_output_fill_options+0x88>)
 80119fe:	4806      	ldr	r0, [pc, #24]	; (8011a18 <tcp_output_fill_options+0x80>)
 8011a00:	f7f0 ff6c 	bl	80028dc <app_debug_rtt_raw>
  LWIP_UNUSED_ARG(optflags); /* for LWIP_NOASSERT */
  LWIP_UNUSED_ARG(opts); /* for LWIP_NOASSERT */
}
 8011a04:	46c0      	nop			; (mov r8, r8)
 8011a06:	46bd      	mov	sp, r7
 8011a08:	b008      	add	sp, #32
 8011a0a:	bd80      	pop	{r7, pc}
 8011a0c:	08020658 	.word	0x08020658
 8011a10:	00000757 	.word	0x00000757
 8011a14:	08020e88 	.word	0x08020e88
 8011a18:	080206a4 	.word	0x080206a4
 8011a1c:	00000776 	.word	0x00000776
 8011a20:	08020d5c 	.word	0x08020d5c

08011a24 <tcp_output_control_segment>:
 * header checksum and calling ip_output_if while handling netif hints and stats.
 */
static err_t
tcp_output_control_segment(const struct tcp_pcb *pcb, struct pbuf *p,
                           const ip_addr_t *src, const ip_addr_t *dst)
{
 8011a24:	b5b0      	push	{r4, r5, r7, lr}
 8011a26:	b08c      	sub	sp, #48	; 0x30
 8011a28:	af04      	add	r7, sp, #16
 8011a2a:	60f8      	str	r0, [r7, #12]
 8011a2c:	60b9      	str	r1, [r7, #8]
 8011a2e:	607a      	str	r2, [r7, #4]
 8011a30:	603b      	str	r3, [r7, #0]
  err_t err;
  struct netif *netif;

  LWIP_ASSERT("tcp_output_control_segment: invalid pbuf", p != NULL);
 8011a32:	68bb      	ldr	r3, [r7, #8]
 8011a34:	2b00      	cmp	r3, #0
 8011a36:	d106      	bne.n	8011a46 <tcp_output_control_segment+0x22>
 8011a38:	4b3c      	ldr	r3, [pc, #240]	; (8011b2c <tcp_output_control_segment+0x108>)
 8011a3a:	22f1      	movs	r2, #241	; 0xf1
 8011a3c:	00d2      	lsls	r2, r2, #3
 8011a3e:	493c      	ldr	r1, [pc, #240]	; (8011b30 <tcp_output_control_segment+0x10c>)
 8011a40:	483c      	ldr	r0, [pc, #240]	; (8011b34 <tcp_output_control_segment+0x110>)
 8011a42:	f7f0 ff4b 	bl	80028dc <app_debug_rtt_raw>

  netif = tcp_route(pcb, src, dst);
 8011a46:	683a      	ldr	r2, [r7, #0]
 8011a48:	6879      	ldr	r1, [r7, #4]
 8011a4a:	68fb      	ldr	r3, [r7, #12]
 8011a4c:	0018      	movs	r0, r3
 8011a4e:	f7fd fc7d 	bl	800f34c <tcp_route>
 8011a52:	0003      	movs	r3, r0
 8011a54:	61bb      	str	r3, [r7, #24]
  if (netif == NULL) {
 8011a56:	69bb      	ldr	r3, [r7, #24]
 8011a58:	2b00      	cmp	r3, #0
 8011a5a:	d104      	bne.n	8011a66 <tcp_output_control_segment+0x42>
    err = ERR_RTE;
 8011a5c:	231f      	movs	r3, #31
 8011a5e:	18fb      	adds	r3, r7, r3
 8011a60:	22fc      	movs	r2, #252	; 0xfc
 8011a62:	701a      	strb	r2, [r3, #0]
 8011a64:	e055      	b.n	8011b12 <tcp_output_control_segment+0xee>
  } else {
    u8_t ttl, tos;
#if CHECKSUM_GEN_TCP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_TCP) {
      struct tcp_hdr *tcphdr = (struct tcp_hdr *)p->payload;
 8011a66:	68bb      	ldr	r3, [r7, #8]
 8011a68:	685b      	ldr	r3, [r3, #4]
 8011a6a:	617b      	str	r3, [r7, #20]
      tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
 8011a6c:	68bb      	ldr	r3, [r7, #8]
 8011a6e:	891a      	ldrh	r2, [r3, #8]
 8011a70:	6879      	ldr	r1, [r7, #4]
 8011a72:	68b8      	ldr	r0, [r7, #8]
 8011a74:	683b      	ldr	r3, [r7, #0]
 8011a76:	9300      	str	r3, [sp, #0]
 8011a78:	000b      	movs	r3, r1
 8011a7a:	2106      	movs	r1, #6
 8011a7c:	f7f6 fb4b 	bl	8008116 <ip_chksum_pseudo>
 8011a80:	0003      	movs	r3, r0
 8011a82:	001a      	movs	r2, r3
 8011a84:	697b      	ldr	r3, [r7, #20]
 8011a86:	21ff      	movs	r1, #255	; 0xff
 8011a88:	4011      	ands	r1, r2
 8011a8a:	000c      	movs	r4, r1
 8011a8c:	7c19      	ldrb	r1, [r3, #16]
 8011a8e:	2000      	movs	r0, #0
 8011a90:	4001      	ands	r1, r0
 8011a92:	1c08      	adds	r0, r1, #0
 8011a94:	1c21      	adds	r1, r4, #0
 8011a96:	4301      	orrs	r1, r0
 8011a98:	7419      	strb	r1, [r3, #16]
 8011a9a:	0a12      	lsrs	r2, r2, #8
 8011a9c:	b290      	uxth	r0, r2
 8011a9e:	7c5a      	ldrb	r2, [r3, #17]
 8011aa0:	2100      	movs	r1, #0
 8011aa2:	400a      	ands	r2, r1
 8011aa4:	1c11      	adds	r1, r2, #0
 8011aa6:	1c02      	adds	r2, r0, #0
 8011aa8:	430a      	orrs	r2, r1
 8011aaa:	745a      	strb	r2, [r3, #17]
                                        src, dst);
    }
#endif
    if (pcb != NULL) {
 8011aac:	68fb      	ldr	r3, [r7, #12]
 8011aae:	2b00      	cmp	r3, #0
 8011ab0:	d00f      	beq.n	8011ad2 <tcp_output_control_segment+0xae>
      NETIF_SET_HINTS(netif, LWIP_CONST_CAST(struct netif_hint*, &(pcb->netif_hints)));
 8011ab2:	68fb      	ldr	r3, [r7, #12]
 8011ab4:	330c      	adds	r3, #12
 8011ab6:	001a      	movs	r2, r3
 8011ab8:	69bb      	ldr	r3, [r7, #24]
 8011aba:	639a      	str	r2, [r3, #56]	; 0x38
      ttl = pcb->ttl;
 8011abc:	231e      	movs	r3, #30
 8011abe:	18fb      	adds	r3, r7, r3
 8011ac0:	68fa      	ldr	r2, [r7, #12]
 8011ac2:	7ad2      	ldrb	r2, [r2, #11]
 8011ac4:	701a      	strb	r2, [r3, #0]
      tos = pcb->tos;
 8011ac6:	231d      	movs	r3, #29
 8011ac8:	18fb      	adds	r3, r7, r3
 8011aca:	68fa      	ldr	r2, [r7, #12]
 8011acc:	7a92      	ldrb	r2, [r2, #10]
 8011ace:	701a      	strb	r2, [r3, #0]
 8011ad0:	e007      	b.n	8011ae2 <tcp_output_control_segment+0xbe>
    } else {
      /* Send output with hardcoded TTL/HL since we have no access to the pcb */
      ttl = TCP_TTL;
 8011ad2:	231e      	movs	r3, #30
 8011ad4:	18fb      	adds	r3, r7, r3
 8011ad6:	22ff      	movs	r2, #255	; 0xff
 8011ad8:	701a      	strb	r2, [r3, #0]
      tos = 0;
 8011ada:	231d      	movs	r3, #29
 8011adc:	18fb      	adds	r3, r7, r3
 8011ade:	2200      	movs	r2, #0
 8011ae0:	701a      	strb	r2, [r3, #0]
    }
    TCP_STATS_INC(tcp.xmit);
    err = ip_output_if(p, src, dst, ttl, tos, IP_PROTO_TCP, netif);
 8011ae2:	231f      	movs	r3, #31
 8011ae4:	18fc      	adds	r4, r7, r3
 8011ae6:	231e      	movs	r3, #30
 8011ae8:	18fb      	adds	r3, r7, r3
 8011aea:	781d      	ldrb	r5, [r3, #0]
 8011aec:	683a      	ldr	r2, [r7, #0]
 8011aee:	6879      	ldr	r1, [r7, #4]
 8011af0:	68b8      	ldr	r0, [r7, #8]
 8011af2:	69bb      	ldr	r3, [r7, #24]
 8011af4:	9302      	str	r3, [sp, #8]
 8011af6:	2306      	movs	r3, #6
 8011af8:	9301      	str	r3, [sp, #4]
 8011afa:	231d      	movs	r3, #29
 8011afc:	18fb      	adds	r3, r7, r3
 8011afe:	781b      	ldrb	r3, [r3, #0]
 8011b00:	9300      	str	r3, [sp, #0]
 8011b02:	002b      	movs	r3, r5
 8011b04:	f001 fdee 	bl	80136e4 <ip4_output_if>
 8011b08:	0003      	movs	r3, r0
 8011b0a:	7023      	strb	r3, [r4, #0]
    NETIF_RESET_HINTS(netif);
 8011b0c:	69bb      	ldr	r3, [r7, #24]
 8011b0e:	2200      	movs	r2, #0
 8011b10:	639a      	str	r2, [r3, #56]	; 0x38
  }
  pbuf_free(p);
 8011b12:	68bb      	ldr	r3, [r7, #8]
 8011b14:	0018      	movs	r0, r3
 8011b16:	f7f8 f85b 	bl	8009bd0 <pbuf_free>
  return err;
 8011b1a:	231f      	movs	r3, #31
 8011b1c:	18fb      	adds	r3, r7, r3
 8011b1e:	781b      	ldrb	r3, [r3, #0]
 8011b20:	b25b      	sxtb	r3, r3
}
 8011b22:	0018      	movs	r0, r3
 8011b24:	46bd      	mov	sp, r7
 8011b26:	b008      	add	sp, #32
 8011b28:	bdb0      	pop	{r4, r5, r7, pc}
 8011b2a:	46c0      	nop			; (mov r8, r8)
 8011b2c:	08020658 	.word	0x08020658
 8011b30:	08020eb0 	.word	0x08020eb0
 8011b34:	080206a4 	.word	0x080206a4

08011b38 <tcp_rst>:
 */
void
tcp_rst(const struct tcp_pcb *pcb, u32_t seqno, u32_t ackno,
        const ip_addr_t *local_ip, const ip_addr_t *remote_ip,
        u16_t local_port, u16_t remote_port)
{
 8011b38:	b5b0      	push	{r4, r5, r7, lr}
 8011b3a:	b08a      	sub	sp, #40	; 0x28
 8011b3c:	af04      	add	r7, sp, #16
 8011b3e:	60f8      	str	r0, [r7, #12]
 8011b40:	60b9      	str	r1, [r7, #8]
 8011b42:	607a      	str	r2, [r7, #4]
 8011b44:	603b      	str	r3, [r7, #0]
  struct pbuf *p;
  u16_t wnd;
  u8_t optlen;

  LWIP_ASSERT("tcp_rst: invalid local_ip", local_ip != NULL);
 8011b46:	683b      	ldr	r3, [r7, #0]
 8011b48:	2b00      	cmp	r3, #0
 8011b4a:	d105      	bne.n	8011b58 <tcp_rst+0x20>
 8011b4c:	4b23      	ldr	r3, [pc, #140]	; (8011bdc <tcp_rst+0xa4>)
 8011b4e:	4a24      	ldr	r2, [pc, #144]	; (8011be0 <tcp_rst+0xa8>)
 8011b50:	4924      	ldr	r1, [pc, #144]	; (8011be4 <tcp_rst+0xac>)
 8011b52:	4825      	ldr	r0, [pc, #148]	; (8011be8 <tcp_rst+0xb0>)
 8011b54:	f7f0 fec2 	bl	80028dc <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_rst: invalid remote_ip", remote_ip != NULL);
 8011b58:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011b5a:	2b00      	cmp	r3, #0
 8011b5c:	d105      	bne.n	8011b6a <tcp_rst+0x32>
 8011b5e:	4b1f      	ldr	r3, [pc, #124]	; (8011bdc <tcp_rst+0xa4>)
 8011b60:	4a22      	ldr	r2, [pc, #136]	; (8011bec <tcp_rst+0xb4>)
 8011b62:	4923      	ldr	r1, [pc, #140]	; (8011bf0 <tcp_rst+0xb8>)
 8011b64:	4820      	ldr	r0, [pc, #128]	; (8011be8 <tcp_rst+0xb0>)
 8011b66:	f7f0 feb9 	bl	80028dc <app_debug_rtt_raw>

  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
 8011b6a:	2117      	movs	r1, #23
 8011b6c:	187b      	adds	r3, r7, r1
 8011b6e:	2200      	movs	r2, #0
 8011b70:	701a      	strb	r2, [r3, #0]

#if LWIP_WND_SCALE
  wnd = PP_HTONS(((TCP_WND >> TCP_RCV_SCALE) & 0xFFFF));
#else
  wnd = PP_HTONS(TCP_WND);
 8011b72:	2514      	movs	r5, #20
 8011b74:	197b      	adds	r3, r7, r5
 8011b76:	4a1f      	ldr	r2, [pc, #124]	; (8011bf4 <tcp_rst+0xbc>)
 8011b78:	801a      	strh	r2, [r3, #0]
#endif

  p = tcp_output_alloc_header_common(ackno, optlen, 0, lwip_htonl(seqno), local_port,
 8011b7a:	187b      	adds	r3, r7, r1
 8011b7c:	781b      	ldrb	r3, [r3, #0]
 8011b7e:	b29c      	uxth	r4, r3
 8011b80:	68bb      	ldr	r3, [r7, #8]
 8011b82:	0018      	movs	r0, r3
 8011b84:	f7f5 f856 	bl	8006c34 <lwip_htonl>
 8011b88:	0002      	movs	r2, r0
 8011b8a:	6878      	ldr	r0, [r7, #4]
 8011b8c:	197b      	adds	r3, r7, r5
 8011b8e:	881b      	ldrh	r3, [r3, #0]
 8011b90:	9303      	str	r3, [sp, #12]
 8011b92:	2314      	movs	r3, #20
 8011b94:	9302      	str	r3, [sp, #8]
 8011b96:	2330      	movs	r3, #48	; 0x30
 8011b98:	18fb      	adds	r3, r7, r3
 8011b9a:	881b      	ldrh	r3, [r3, #0]
 8011b9c:	9301      	str	r3, [sp, #4]
 8011b9e:	232c      	movs	r3, #44	; 0x2c
 8011ba0:	18fb      	adds	r3, r7, r3
 8011ba2:	881b      	ldrh	r3, [r3, #0]
 8011ba4:	9300      	str	r3, [sp, #0]
 8011ba6:	0013      	movs	r3, r2
 8011ba8:	2200      	movs	r2, #0
 8011baa:	0021      	movs	r1, r4
 8011bac:	f7ff fd86 	bl	80116bc <tcp_output_alloc_header_common>
 8011bb0:	0003      	movs	r3, r0
 8011bb2:	613b      	str	r3, [r7, #16]
    remote_port, TCP_RST | TCP_ACK, wnd);
  if (p == NULL) {
 8011bb4:	693b      	ldr	r3, [r7, #16]
 8011bb6:	2b00      	cmp	r3, #0
 8011bb8:	d00c      	beq.n	8011bd4 <tcp_rst+0x9c>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
    return;
  }
  tcp_output_fill_options(pcb, p, 0, 0);
 8011bba:	6939      	ldr	r1, [r7, #16]
 8011bbc:	68f8      	ldr	r0, [r7, #12]
 8011bbe:	2300      	movs	r3, #0
 8011bc0:	2200      	movs	r2, #0
 8011bc2:	f7ff fee9 	bl	8011998 <tcp_output_fill_options>

  MIB2_STATS_INC(mib2.tcpoutrsts);

  tcp_output_control_segment(pcb, p, local_ip, remote_ip);
 8011bc6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011bc8:	683a      	ldr	r2, [r7, #0]
 8011bca:	6939      	ldr	r1, [r7, #16]
 8011bcc:	68f8      	ldr	r0, [r7, #12]
 8011bce:	f7ff ff29 	bl	8011a24 <tcp_output_control_segment>
 8011bd2:	e000      	b.n	8011bd6 <tcp_rst+0x9e>
    return;
 8011bd4:	46c0      	nop			; (mov r8, r8)
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
 8011bd6:	46bd      	mov	sp, r7
 8011bd8:	b006      	add	sp, #24
 8011bda:	bdb0      	pop	{r4, r5, r7, pc}
 8011bdc:	08020658 	.word	0x08020658
 8011be0:	000007c5 	.word	0x000007c5
 8011be4:	08020edc 	.word	0x08020edc
 8011be8:	080206a4 	.word	0x080206a4
 8011bec:	000007c6 	.word	0x000007c6
 8011bf0:	08020ef8 	.word	0x08020ef8
 8011bf4:	00003004 	.word	0x00003004

08011bf8 <tcp_send_empty_ack>:
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
 8011bf8:	b5b0      	push	{r4, r5, r7, lr}
 8011bfa:	b086      	sub	sp, #24
 8011bfc:	af00      	add	r7, sp, #0
 8011bfe:	6078      	str	r0, [r7, #4]
  err_t err;
  struct pbuf *p;
  u8_t optlen, optflags = 0;
 8011c00:	2317      	movs	r3, #23
 8011c02:	18fb      	adds	r3, r7, r3
 8011c04:	2200      	movs	r2, #0
 8011c06:	701a      	strb	r2, [r3, #0]
  u8_t num_sacks = 0;
 8011c08:	2316      	movs	r3, #22
 8011c0a:	18fb      	adds	r3, r7, r3
 8011c0c:	2200      	movs	r2, #0
 8011c0e:	701a      	strb	r2, [r3, #0]

  LWIP_ASSERT("tcp_send_empty_ack: invalid pcb", pcb != NULL);
 8011c10:	687b      	ldr	r3, [r7, #4]
 8011c12:	2b00      	cmp	r3, #0
 8011c14:	d105      	bne.n	8011c22 <tcp_send_empty_ack+0x2a>
 8011c16:	4b2f      	ldr	r3, [pc, #188]	; (8011cd4 <tcp_send_empty_ack+0xdc>)
 8011c18:	4a2f      	ldr	r2, [pc, #188]	; (8011cd8 <tcp_send_empty_ack+0xe0>)
 8011c1a:	4930      	ldr	r1, [pc, #192]	; (8011cdc <tcp_send_empty_ack+0xe4>)
 8011c1c:	4830      	ldr	r0, [pc, #192]	; (8011ce0 <tcp_send_empty_ack+0xe8>)
 8011c1e:	f7f0 fe5d 	bl	80028dc <app_debug_rtt_raw>
#if LWIP_TCP_TIMESTAMPS
  if (pcb->flags & TF_TIMESTAMP) {
    optflags = TF_SEG_OPTS_TS;
  }
#endif
  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
 8011c22:	2317      	movs	r3, #23
 8011c24:	18fb      	adds	r3, r7, r3
 8011c26:	781b      	ldrb	r3, [r3, #0]
 8011c28:	009b      	lsls	r3, r3, #2
 8011c2a:	b2da      	uxtb	r2, r3
 8011c2c:	2015      	movs	r0, #21
 8011c2e:	183b      	adds	r3, r7, r0
 8011c30:	2104      	movs	r1, #4
 8011c32:	400a      	ands	r2, r1
 8011c34:	701a      	strb	r2, [r3, #0]
  if ((num_sacks = tcp_get_num_sacks(pcb, optlen)) > 0) {
    optlen += 4 + num_sacks * 8; /* 4 bytes for header (including 2*NOP), plus 8B for each SACK */
  }
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, lwip_htonl(pcb->snd_nxt));
 8011c36:	183b      	adds	r3, r7, r0
 8011c38:	781b      	ldrb	r3, [r3, #0]
 8011c3a:	b29c      	uxth	r4, r3
 8011c3c:	687b      	ldr	r3, [r7, #4]
 8011c3e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8011c40:	0018      	movs	r0, r3
 8011c42:	f7f4 fff7 	bl	8006c34 <lwip_htonl>
 8011c46:	0003      	movs	r3, r0
 8011c48:	6878      	ldr	r0, [r7, #4]
 8011c4a:	2200      	movs	r2, #0
 8011c4c:	0021      	movs	r1, r4
 8011c4e:	f7ff fe57 	bl	8011900 <tcp_output_alloc_header>
 8011c52:	0003      	movs	r3, r0
 8011c54:	613b      	str	r3, [r7, #16]
  if (p == NULL) {
 8011c56:	693b      	ldr	r3, [r7, #16]
 8011c58:	2b00      	cmp	r3, #0
 8011c5a:	d109      	bne.n	8011c70 <tcp_send_empty_ack+0x78>
    /* let tcp_fasttmr retry sending this ACK */
    tcp_set_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 8011c5c:	687b      	ldr	r3, [r7, #4]
 8011c5e:	8bdb      	ldrh	r3, [r3, #30]
 8011c60:	2203      	movs	r2, #3
 8011c62:	4313      	orrs	r3, r2
 8011c64:	b29a      	uxth	r2, r3
 8011c66:	687b      	ldr	r3, [r7, #4]
 8011c68:	83da      	strh	r2, [r3, #30]
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
 8011c6a:	2302      	movs	r3, #2
 8011c6c:	425b      	negs	r3, r3
 8011c6e:	e02d      	b.n	8011ccc <tcp_send_empty_ack+0xd4>
  }
  tcp_output_fill_options(pcb, p, optflags, num_sacks);
 8011c70:	2316      	movs	r3, #22
 8011c72:	18fb      	adds	r3, r7, r3
 8011c74:	781c      	ldrb	r4, [r3, #0]
 8011c76:	2317      	movs	r3, #23
 8011c78:	18fb      	adds	r3, r7, r3
 8011c7a:	781a      	ldrb	r2, [r3, #0]
 8011c7c:	6939      	ldr	r1, [r7, #16]
 8011c7e:	6878      	ldr	r0, [r7, #4]
 8011c80:	0023      	movs	r3, r4
 8011c82:	f7ff fe89 	bl	8011998 <tcp_output_fill_options>
  pcb->ts_lastacksent = pcb->rcv_nxt;
#endif

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG,
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
 8011c86:	687a      	ldr	r2, [r7, #4]
 8011c88:	687b      	ldr	r3, [r7, #4]
 8011c8a:	3304      	adds	r3, #4
 8011c8c:	250f      	movs	r5, #15
 8011c8e:	197c      	adds	r4, r7, r5
 8011c90:	6939      	ldr	r1, [r7, #16]
 8011c92:	6878      	ldr	r0, [r7, #4]
 8011c94:	f7ff fec6 	bl	8011a24 <tcp_output_control_segment>
 8011c98:	0003      	movs	r3, r0
 8011c9a:	7023      	strb	r3, [r4, #0]
  if (err != ERR_OK) {
 8011c9c:	197b      	adds	r3, r7, r5
 8011c9e:	781b      	ldrb	r3, [r3, #0]
 8011ca0:	b25b      	sxtb	r3, r3
 8011ca2:	2b00      	cmp	r3, #0
 8011ca4:	d007      	beq.n	8011cb6 <tcp_send_empty_ack+0xbe>
    /* let tcp_fasttmr retry sending this ACK */
    tcp_set_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 8011ca6:	687b      	ldr	r3, [r7, #4]
 8011ca8:	8bdb      	ldrh	r3, [r3, #30]
 8011caa:	2203      	movs	r2, #3
 8011cac:	4313      	orrs	r3, r2
 8011cae:	b29a      	uxth	r2, r3
 8011cb0:	687b      	ldr	r3, [r7, #4]
 8011cb2:	83da      	strh	r2, [r3, #30]
 8011cb4:	e006      	b.n	8011cc4 <tcp_send_empty_ack+0xcc>
  } else {
    /* remove ACK flags from the PCB, as we sent an empty ACK now */
    tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 8011cb6:	687b      	ldr	r3, [r7, #4]
 8011cb8:	8bdb      	ldrh	r3, [r3, #30]
 8011cba:	2203      	movs	r2, #3
 8011cbc:	4393      	bics	r3, r2
 8011cbe:	b29a      	uxth	r2, r3
 8011cc0:	687b      	ldr	r3, [r7, #4]
 8011cc2:	83da      	strh	r2, [r3, #30]
  }

  return err;
 8011cc4:	230f      	movs	r3, #15
 8011cc6:	18fb      	adds	r3, r7, r3
 8011cc8:	781b      	ldrb	r3, [r3, #0]
 8011cca:	b25b      	sxtb	r3, r3
}
 8011ccc:	0018      	movs	r0, r3
 8011cce:	46bd      	mov	sp, r7
 8011cd0:	b006      	add	sp, #24
 8011cd2:	bdb0      	pop	{r4, r5, r7, pc}
 8011cd4:	08020658 	.word	0x08020658
 8011cd8:	000007eb 	.word	0x000007eb
 8011cdc:	08020f14 	.word	0x08020f14
 8011ce0:	080206a4 	.word	0x080206a4

08011ce4 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
err_t
tcp_keepalive(struct tcp_pcb *pcb)
{
 8011ce4:	b5b0      	push	{r4, r5, r7, lr}
 8011ce6:	b084      	sub	sp, #16
 8011ce8:	af00      	add	r7, sp, #0
 8011cea:	6078      	str	r0, [r7, #4]
  err_t err;
  struct pbuf *p;
  u8_t optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
 8011cec:	230a      	movs	r3, #10
 8011cee:	18fb      	adds	r3, r7, r3
 8011cf0:	2200      	movs	r2, #0
 8011cf2:	701a      	strb	r2, [r3, #0]

  LWIP_ASSERT("tcp_keepalive: invalid pcb", pcb != NULL);
 8011cf4:	687b      	ldr	r3, [r7, #4]
 8011cf6:	2b00      	cmp	r3, #0
 8011cf8:	d105      	bne.n	8011d06 <tcp_keepalive+0x22>
 8011cfa:	4b1b      	ldr	r3, [pc, #108]	; (8011d68 <tcp_keepalive+0x84>)
 8011cfc:	4a1b      	ldr	r2, [pc, #108]	; (8011d6c <tcp_keepalive+0x88>)
 8011cfe:	491c      	ldr	r1, [pc, #112]	; (8011d70 <tcp_keepalive+0x8c>)
 8011d00:	481c      	ldr	r0, [pc, #112]	; (8011d74 <tcp_keepalive+0x90>)
 8011d02:	f7f0 fdeb 	bl	80028dc <app_debug_rtt_raw>
  LWIP_DEBUGF(TCP_DEBUG, ("\n"));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
                          tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));

  p = tcp_output_alloc_header(pcb, optlen, 0, lwip_htonl(pcb->snd_nxt - 1));
 8011d06:	230a      	movs	r3, #10
 8011d08:	18fb      	adds	r3, r7, r3
 8011d0a:	781b      	ldrb	r3, [r3, #0]
 8011d0c:	b29c      	uxth	r4, r3
 8011d0e:	687b      	ldr	r3, [r7, #4]
 8011d10:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8011d12:	3b01      	subs	r3, #1
 8011d14:	0018      	movs	r0, r3
 8011d16:	f7f4 ff8d 	bl	8006c34 <lwip_htonl>
 8011d1a:	0003      	movs	r3, r0
 8011d1c:	6878      	ldr	r0, [r7, #4]
 8011d1e:	2200      	movs	r2, #0
 8011d20:	0021      	movs	r1, r4
 8011d22:	f7ff fded 	bl	8011900 <tcp_output_alloc_header>
 8011d26:	0003      	movs	r3, r0
 8011d28:	60fb      	str	r3, [r7, #12]
  if (p == NULL) {
 8011d2a:	68fb      	ldr	r3, [r7, #12]
 8011d2c:	2b00      	cmp	r3, #0
 8011d2e:	d102      	bne.n	8011d36 <tcp_keepalive+0x52>
    LWIP_DEBUGF(TCP_DEBUG,
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return ERR_MEM;
 8011d30:	2301      	movs	r3, #1
 8011d32:	425b      	negs	r3, r3
 8011d34:	e013      	b.n	8011d5e <tcp_keepalive+0x7a>
  }
  tcp_output_fill_options(pcb, p, 0, 0);
 8011d36:	68f9      	ldr	r1, [r7, #12]
 8011d38:	6878      	ldr	r0, [r7, #4]
 8011d3a:	2300      	movs	r3, #0
 8011d3c:	2200      	movs	r2, #0
 8011d3e:	f7ff fe2b 	bl	8011998 <tcp_output_fill_options>
  err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
 8011d42:	687a      	ldr	r2, [r7, #4]
 8011d44:	687b      	ldr	r3, [r7, #4]
 8011d46:	3304      	adds	r3, #4
 8011d48:	250b      	movs	r5, #11
 8011d4a:	197c      	adds	r4, r7, r5
 8011d4c:	68f9      	ldr	r1, [r7, #12]
 8011d4e:	6878      	ldr	r0, [r7, #4]
 8011d50:	f7ff fe68 	bl	8011a24 <tcp_output_control_segment>
 8011d54:	0003      	movs	r3, r0
 8011d56:	7023      	strb	r3, [r4, #0]

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F" err %d.\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
  return err;
 8011d58:	197b      	adds	r3, r7, r5
 8011d5a:	781b      	ldrb	r3, [r3, #0]
 8011d5c:	b25b      	sxtb	r3, r3
}
 8011d5e:	0018      	movs	r0, r3
 8011d60:	46bd      	mov	sp, r7
 8011d62:	b004      	add	sp, #16
 8011d64:	bdb0      	pop	{r4, r5, r7, pc}
 8011d66:	46c0      	nop			; (mov r8, r8)
 8011d68:	08020658 	.word	0x08020658
 8011d6c:	00000825 	.word	0x00000825
 8011d70:	08020f34 	.word	0x08020f34
 8011d74:	080206a4 	.word	0x080206a4

08011d78 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
err_t
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
 8011d78:	b5b0      	push	{r4, r5, r7, lr}
 8011d7a:	b08a      	sub	sp, #40	; 0x28
 8011d7c:	af00      	add	r7, sp, #0
 8011d7e:	6078      	str	r0, [r7, #4]
  struct tcp_hdr *tcphdr;
  struct tcp_seg *seg;
  u16_t len;
  u8_t is_fin;
  u32_t snd_nxt;
  u8_t optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
 8011d80:	2313      	movs	r3, #19
 8011d82:	18fb      	adds	r3, r7, r3
 8011d84:	2200      	movs	r2, #0
 8011d86:	701a      	strb	r2, [r3, #0]

  LWIP_ASSERT("tcp_zero_window_probe: invalid pcb", pcb != NULL);
 8011d88:	687b      	ldr	r3, [r7, #4]
 8011d8a:	2b00      	cmp	r3, #0
 8011d8c:	d106      	bne.n	8011d9c <tcp_zero_window_probe+0x24>
 8011d8e:	4b68      	ldr	r3, [pc, #416]	; (8011f30 <tcp_zero_window_probe+0x1b8>)
 8011d90:	2285      	movs	r2, #133	; 0x85
 8011d92:	0112      	lsls	r2, r2, #4
 8011d94:	4967      	ldr	r1, [pc, #412]	; (8011f34 <tcp_zero_window_probe+0x1bc>)
 8011d96:	4868      	ldr	r0, [pc, #416]	; (8011f38 <tcp_zero_window_probe+0x1c0>)
 8011d98:	f7f0 fda0 	bl	80028dc <app_debug_rtt_raw>
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
               tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));

  /* Only consider unsent, persist timer should be off when there is data in-flight */
  seg = pcb->unsent;
 8011d9c:	687b      	ldr	r3, [r7, #4]
 8011d9e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8011da0:	627b      	str	r3, [r7, #36]	; 0x24
  if (seg == NULL) {
 8011da2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011da4:	2b00      	cmp	r3, #0
 8011da6:	d101      	bne.n	8011dac <tcp_zero_window_probe+0x34>
    /* Not expected, persist timer should be off when the send buffer is empty */
    return ERR_OK;
 8011da8:	2300      	movs	r3, #0
 8011daa:	e0bc      	b.n	8011f26 <tcp_zero_window_probe+0x1ae>

  /* increment probe count. NOTE: we record probe even if it fails
     to actually transmit due to an error. This ensures memory exhaustion/
     routing problem doesn't leave a zero-window pcb as an indefinite zombie.
     RTO mechanism has similar behavior, see pcb->nrtx */
  if (pcb->persist_probe < 0xFF) {
 8011dac:	687b      	ldr	r3, [r7, #4]
 8011dae:	22a6      	movs	r2, #166	; 0xa6
 8011db0:	5c9b      	ldrb	r3, [r3, r2]
 8011db2:	2bff      	cmp	r3, #255	; 0xff
 8011db4:	d007      	beq.n	8011dc6 <tcp_zero_window_probe+0x4e>
    ++pcb->persist_probe;
 8011db6:	687b      	ldr	r3, [r7, #4]
 8011db8:	22a6      	movs	r2, #166	; 0xa6
 8011dba:	5c9b      	ldrb	r3, [r3, r2]
 8011dbc:	3301      	adds	r3, #1
 8011dbe:	b2d9      	uxtb	r1, r3
 8011dc0:	687b      	ldr	r3, [r7, #4]
 8011dc2:	22a6      	movs	r2, #166	; 0xa6
 8011dc4:	5499      	strb	r1, [r3, r2]
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 8011dc6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011dc8:	691b      	ldr	r3, [r3, #16]
 8011dca:	7b1a      	ldrb	r2, [r3, #12]
 8011dcc:	7b5b      	ldrb	r3, [r3, #13]
 8011dce:	021b      	lsls	r3, r3, #8
 8011dd0:	4313      	orrs	r3, r2
 8011dd2:	b29b      	uxth	r3, r3
 8011dd4:	0018      	movs	r0, r3
 8011dd6:	f7f4 ff17 	bl	8006c08 <lwip_htons>
 8011dda:	0003      	movs	r3, r0
 8011ddc:	b2db      	uxtb	r3, r3
 8011dde:	001a      	movs	r2, r3
 8011de0:	2301      	movs	r3, #1
 8011de2:	4013      	ands	r3, r2
 8011de4:	d005      	beq.n	8011df2 <tcp_zero_window_probe+0x7a>
 8011de6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011de8:	891b      	ldrh	r3, [r3, #8]
 8011dea:	2b00      	cmp	r3, #0
 8011dec:	d101      	bne.n	8011df2 <tcp_zero_window_probe+0x7a>
 8011dee:	2201      	movs	r2, #1
 8011df0:	e000      	b.n	8011df4 <tcp_zero_window_probe+0x7c>
 8011df2:	2200      	movs	r2, #0
 8011df4:	2123      	movs	r1, #35	; 0x23
 8011df6:	187b      	adds	r3, r7, r1
 8011df8:	701a      	strb	r2, [r3, #0]
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;
 8011dfa:	187b      	adds	r3, r7, r1
 8011dfc:	781b      	ldrb	r3, [r3, #0]
 8011dfe:	425a      	negs	r2, r3
 8011e00:	4153      	adcs	r3, r2
 8011e02:	b2da      	uxtb	r2, r3
 8011e04:	2020      	movs	r0, #32
 8011e06:	183b      	adds	r3, r7, r0
 8011e08:	801a      	strh	r2, [r3, #0]

  p = tcp_output_alloc_header(pcb, optlen, len, seg->tcphdr->seqno);
 8011e0a:	2313      	movs	r3, #19
 8011e0c:	18fb      	adds	r3, r7, r3
 8011e0e:	781b      	ldrb	r3, [r3, #0]
 8011e10:	b29c      	uxth	r4, r3
 8011e12:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011e14:	691b      	ldr	r3, [r3, #16]
 8011e16:	791a      	ldrb	r2, [r3, #4]
 8011e18:	7959      	ldrb	r1, [r3, #5]
 8011e1a:	0209      	lsls	r1, r1, #8
 8011e1c:	430a      	orrs	r2, r1
 8011e1e:	7999      	ldrb	r1, [r3, #6]
 8011e20:	0409      	lsls	r1, r1, #16
 8011e22:	430a      	orrs	r2, r1
 8011e24:	79db      	ldrb	r3, [r3, #7]
 8011e26:	061b      	lsls	r3, r3, #24
 8011e28:	4313      	orrs	r3, r2
 8011e2a:	0019      	movs	r1, r3
 8011e2c:	183b      	adds	r3, r7, r0
 8011e2e:	881a      	ldrh	r2, [r3, #0]
 8011e30:	6878      	ldr	r0, [r7, #4]
 8011e32:	000b      	movs	r3, r1
 8011e34:	0021      	movs	r1, r4
 8011e36:	f7ff fd63 	bl	8011900 <tcp_output_alloc_header>
 8011e3a:	0003      	movs	r3, r0
 8011e3c:	61fb      	str	r3, [r7, #28]
  if (p == NULL) {
 8011e3e:	69fb      	ldr	r3, [r7, #28]
 8011e40:	2b00      	cmp	r3, #0
 8011e42:	d102      	bne.n	8011e4a <tcp_zero_window_probe+0xd2>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return ERR_MEM;
 8011e44:	2301      	movs	r3, #1
 8011e46:	425b      	negs	r3, r3
 8011e48:	e06d      	b.n	8011f26 <tcp_zero_window_probe+0x1ae>
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 8011e4a:	69fb      	ldr	r3, [r7, #28]
 8011e4c:	685b      	ldr	r3, [r3, #4]
 8011e4e:	61bb      	str	r3, [r7, #24]

  if (is_fin) {
 8011e50:	2323      	movs	r3, #35	; 0x23
 8011e52:	18fb      	adds	r3, r7, r3
 8011e54:	781b      	ldrb	r3, [r3, #0]
 8011e56:	2b00      	cmp	r3, #0
 8011e58:	d026      	beq.n	8011ea8 <tcp_zero_window_probe+0x130>
    /* FIN segment, no data */
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
 8011e5a:	69bb      	ldr	r3, [r7, #24]
 8011e5c:	7b1a      	ldrb	r2, [r3, #12]
 8011e5e:	7b5b      	ldrb	r3, [r3, #13]
 8011e60:	021b      	lsls	r3, r3, #8
 8011e62:	4313      	orrs	r3, r2
 8011e64:	b29b      	uxth	r3, r3
 8011e66:	b21b      	sxth	r3, r3
 8011e68:	4a34      	ldr	r2, [pc, #208]	; (8011f3c <tcp_zero_window_probe+0x1c4>)
 8011e6a:	4013      	ands	r3, r2
 8011e6c:	b21c      	sxth	r4, r3
 8011e6e:	2011      	movs	r0, #17
 8011e70:	f7f4 feca 	bl	8006c08 <lwip_htons>
 8011e74:	0003      	movs	r3, r0
 8011e76:	b21b      	sxth	r3, r3
 8011e78:	4323      	orrs	r3, r4
 8011e7a:	b21b      	sxth	r3, r3
 8011e7c:	b29a      	uxth	r2, r3
 8011e7e:	69bb      	ldr	r3, [r7, #24]
 8011e80:	21ff      	movs	r1, #255	; 0xff
 8011e82:	4011      	ands	r1, r2
 8011e84:	000c      	movs	r4, r1
 8011e86:	7b19      	ldrb	r1, [r3, #12]
 8011e88:	2000      	movs	r0, #0
 8011e8a:	4001      	ands	r1, r0
 8011e8c:	1c08      	adds	r0, r1, #0
 8011e8e:	1c21      	adds	r1, r4, #0
 8011e90:	4301      	orrs	r1, r0
 8011e92:	7319      	strb	r1, [r3, #12]
 8011e94:	0a12      	lsrs	r2, r2, #8
 8011e96:	b290      	uxth	r0, r2
 8011e98:	7b5a      	ldrb	r2, [r3, #13]
 8011e9a:	2100      	movs	r1, #0
 8011e9c:	400a      	ands	r2, r1
 8011e9e:	1c11      	adds	r1, r2, #0
 8011ea0:	1c02      	adds	r2, r0, #0
 8011ea2:	430a      	orrs	r2, r1
 8011ea4:	735a      	strb	r2, [r3, #13]
 8011ea6:	e010      	b.n	8011eca <tcp_zero_window_probe+0x152>
  } else {
    /* Data segment, copy in one byte from the head of the unacked queue */
    char *d = ((char *)p->payload + TCP_HLEN);
 8011ea8:	69fb      	ldr	r3, [r7, #28]
 8011eaa:	685b      	ldr	r3, [r3, #4]
 8011eac:	3314      	adds	r3, #20
 8011eae:	617b      	str	r3, [r7, #20]
    /* Depending on whether the segment has already been sent (unacked) or not
       (unsent), seg->p->payload points to the IP header or TCP header.
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
 8011eb0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011eb2:	6858      	ldr	r0, [r3, #4]
 8011eb4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011eb6:	685b      	ldr	r3, [r3, #4]
 8011eb8:	891a      	ldrh	r2, [r3, #8]
 8011eba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011ebc:	891b      	ldrh	r3, [r3, #8]
 8011ebe:	1ad3      	subs	r3, r2, r3
 8011ec0:	b29b      	uxth	r3, r3
 8011ec2:	6979      	ldr	r1, [r7, #20]
 8011ec4:	2201      	movs	r2, #1
 8011ec6:	f7f8 f94d 	bl	800a164 <pbuf_copy_partial>
  }

  /* The byte may be acknowledged without the window being opened. */
  snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + 1;
 8011eca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011ecc:	691b      	ldr	r3, [r3, #16]
 8011ece:	791a      	ldrb	r2, [r3, #4]
 8011ed0:	7959      	ldrb	r1, [r3, #5]
 8011ed2:	0209      	lsls	r1, r1, #8
 8011ed4:	430a      	orrs	r2, r1
 8011ed6:	7999      	ldrb	r1, [r3, #6]
 8011ed8:	0409      	lsls	r1, r1, #16
 8011eda:	430a      	orrs	r2, r1
 8011edc:	79db      	ldrb	r3, [r3, #7]
 8011ede:	061b      	lsls	r3, r3, #24
 8011ee0:	4313      	orrs	r3, r2
 8011ee2:	0018      	movs	r0, r3
 8011ee4:	f7f4 fea6 	bl	8006c34 <lwip_htonl>
 8011ee8:	0003      	movs	r3, r0
 8011eea:	3301      	adds	r3, #1
 8011eec:	60fb      	str	r3, [r7, #12]
  if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 8011eee:	687b      	ldr	r3, [r7, #4]
 8011ef0:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8011ef2:	68fb      	ldr	r3, [r7, #12]
 8011ef4:	1ad3      	subs	r3, r2, r3
 8011ef6:	d502      	bpl.n	8011efe <tcp_zero_window_probe+0x186>
    pcb->snd_nxt = snd_nxt;
 8011ef8:	687b      	ldr	r3, [r7, #4]
 8011efa:	68fa      	ldr	r2, [r7, #12]
 8011efc:	655a      	str	r2, [r3, #84]	; 0x54
  }
  tcp_output_fill_options(pcb, p, 0, 0);
 8011efe:	69f9      	ldr	r1, [r7, #28]
 8011f00:	6878      	ldr	r0, [r7, #4]
 8011f02:	2300      	movs	r3, #0
 8011f04:	2200      	movs	r2, #0
 8011f06:	f7ff fd47 	bl	8011998 <tcp_output_fill_options>

  err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
 8011f0a:	687a      	ldr	r2, [r7, #4]
 8011f0c:	687b      	ldr	r3, [r7, #4]
 8011f0e:	3304      	adds	r3, #4
 8011f10:	250b      	movs	r5, #11
 8011f12:	197c      	adds	r4, r7, r5
 8011f14:	69f9      	ldr	r1, [r7, #28]
 8011f16:	6878      	ldr	r0, [r7, #4]
 8011f18:	f7ff fd84 	bl	8011a24 <tcp_output_control_segment>
 8011f1c:	0003      	movs	r3, r0
 8011f1e:	7023      	strb	r3, [r4, #0]

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F" err %d.\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
  return err;
 8011f20:	197b      	adds	r3, r7, r5
 8011f22:	781b      	ldrb	r3, [r3, #0]
 8011f24:	b25b      	sxtb	r3, r3
}
 8011f26:	0018      	movs	r0, r3
 8011f28:	46bd      	mov	sp, r7
 8011f2a:	b00a      	add	sp, #40	; 0x28
 8011f2c:	bdb0      	pop	{r4, r5, r7, pc}
 8011f2e:	46c0      	nop			; (mov r8, r8)
 8011f30:	08020658 	.word	0x08020658
 8011f34:	08020f50 	.word	0x08020f50
 8011f38:	080206a4 	.word	0x080206a4
 8011f3c:	ffffc0ff 	.word	0xffffc0ff

08011f40 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
 8011f40:	b580      	push	{r7, lr}
 8011f42:	b082      	sub	sp, #8
 8011f44:	af00      	add	r7, sp, #0
 8011f46:	6078      	str	r0, [r7, #4]
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
 8011f48:	f7f8 fcd4 	bl	800a8f4 <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
 8011f4c:	4b0b      	ldr	r3, [pc, #44]	; (8011f7c <tcpip_tcp_timer+0x3c>)
 8011f4e:	681b      	ldr	r3, [r3, #0]
 8011f50:	2b00      	cmp	r3, #0
 8011f52:	d103      	bne.n	8011f5c <tcpip_tcp_timer+0x1c>
 8011f54:	4b0a      	ldr	r3, [pc, #40]	; (8011f80 <tcpip_tcp_timer+0x40>)
 8011f56:	681b      	ldr	r3, [r3, #0]
 8011f58:	2b00      	cmp	r3, #0
 8011f5a:	d007      	beq.n	8011f6c <tcpip_tcp_timer+0x2c>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 8011f5c:	4909      	ldr	r1, [pc, #36]	; (8011f84 <tcpip_tcp_timer+0x44>)
 8011f5e:	23fa      	movs	r3, #250	; 0xfa
 8011f60:	005b      	lsls	r3, r3, #1
 8011f62:	2200      	movs	r2, #0
 8011f64:	0018      	movs	r0, r3
 8011f66:	f000 f8a7 	bl	80120b8 <sys_timeout>
 8011f6a:	e003      	b.n	8011f74 <tcpip_tcp_timer+0x34>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
 8011f6c:	4b06      	ldr	r3, [pc, #24]	; (8011f88 <tcpip_tcp_timer+0x48>)
 8011f6e:	2200      	movs	r2, #0
 8011f70:	601a      	str	r2, [r3, #0]
  }
}
 8011f72:	46c0      	nop			; (mov r8, r8)
 8011f74:	46c0      	nop			; (mov r8, r8)
 8011f76:	46bd      	mov	sp, r7
 8011f78:	b002      	add	sp, #8
 8011f7a:	bd80      	pop	{r7, pc}
 8011f7c:	20002ed4 	.word	0x20002ed4
 8011f80:	20002ee4 	.word	0x20002ee4
 8011f84:	08011f41 	.word	0x08011f41
 8011f88:	20001b6c 	.word	0x20001b6c

08011f8c <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
 8011f8c:	b580      	push	{r7, lr}
 8011f8e:	af00      	add	r7, sp, #0
  LWIP_ASSERT_CORE_LOCKED();

  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
 8011f90:	4b0c      	ldr	r3, [pc, #48]	; (8011fc4 <tcp_timer_needed+0x38>)
 8011f92:	681b      	ldr	r3, [r3, #0]
 8011f94:	2b00      	cmp	r3, #0
 8011f96:	d111      	bne.n	8011fbc <tcp_timer_needed+0x30>
 8011f98:	4b0b      	ldr	r3, [pc, #44]	; (8011fc8 <tcp_timer_needed+0x3c>)
 8011f9a:	681b      	ldr	r3, [r3, #0]
 8011f9c:	2b00      	cmp	r3, #0
 8011f9e:	d103      	bne.n	8011fa8 <tcp_timer_needed+0x1c>
 8011fa0:	4b0a      	ldr	r3, [pc, #40]	; (8011fcc <tcp_timer_needed+0x40>)
 8011fa2:	681b      	ldr	r3, [r3, #0]
 8011fa4:	2b00      	cmp	r3, #0
 8011fa6:	d009      	beq.n	8011fbc <tcp_timer_needed+0x30>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
 8011fa8:	4b06      	ldr	r3, [pc, #24]	; (8011fc4 <tcp_timer_needed+0x38>)
 8011faa:	2201      	movs	r2, #1
 8011fac:	601a      	str	r2, [r3, #0]
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 8011fae:	4908      	ldr	r1, [pc, #32]	; (8011fd0 <tcp_timer_needed+0x44>)
 8011fb0:	23fa      	movs	r3, #250	; 0xfa
 8011fb2:	005b      	lsls	r3, r3, #1
 8011fb4:	2200      	movs	r2, #0
 8011fb6:	0018      	movs	r0, r3
 8011fb8:	f000 f87e 	bl	80120b8 <sys_timeout>
  }
}
 8011fbc:	46c0      	nop			; (mov r8, r8)
 8011fbe:	46bd      	mov	sp, r7
 8011fc0:	bd80      	pop	{r7, pc}
 8011fc2:	46c0      	nop			; (mov r8, r8)
 8011fc4:	20001b6c 	.word	0x20001b6c
 8011fc8:	20002ed4 	.word	0x20002ed4
 8011fcc:	20002ee4 	.word	0x20002ee4
 8011fd0:	08011f41 	.word	0x08011f41

08011fd4 <sys_timeout_abs>:
#if LWIP_DEBUG_TIMERNAMES
sys_timeout_abs(u32_t abs_time, sys_timeout_handler handler, void *arg, const char *handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
sys_timeout_abs(u32_t abs_time, sys_timeout_handler handler, void *arg)
#endif
{
 8011fd4:	b580      	push	{r7, lr}
 8011fd6:	b086      	sub	sp, #24
 8011fd8:	af00      	add	r7, sp, #0
 8011fda:	60f8      	str	r0, [r7, #12]
 8011fdc:	60b9      	str	r1, [r7, #8]
 8011fde:	607a      	str	r2, [r7, #4]
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
 8011fe0:	2004      	movs	r0, #4
 8011fe2:	f7f6 fe95 	bl	8008d10 <memp_malloc>
 8011fe6:	0003      	movs	r3, r0
 8011fe8:	613b      	str	r3, [r7, #16]
  if (timeout == NULL) {
 8011fea:	693b      	ldr	r3, [r7, #16]
 8011fec:	2b00      	cmp	r3, #0
 8011fee:	d109      	bne.n	8012004 <sys_timeout_abs+0x30>
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
 8011ff0:	693b      	ldr	r3, [r7, #16]
 8011ff2:	2b00      	cmp	r3, #0
 8011ff4:	d153      	bne.n	801209e <sys_timeout_abs+0xca>
 8011ff6:	4b2c      	ldr	r3, [pc, #176]	; (80120a8 <sys_timeout_abs+0xd4>)
 8011ff8:	492c      	ldr	r1, [pc, #176]	; (80120ac <sys_timeout_abs+0xd8>)
 8011ffa:	482d      	ldr	r0, [pc, #180]	; (80120b0 <sys_timeout_abs+0xdc>)
 8011ffc:	22be      	movs	r2, #190	; 0xbe
 8011ffe:	f7f0 fc6d 	bl	80028dc <app_debug_rtt_raw>
    return;
 8012002:	e04c      	b.n	801209e <sys_timeout_abs+0xca>
  }

  timeout->next = NULL;
 8012004:	693b      	ldr	r3, [r7, #16]
 8012006:	2200      	movs	r2, #0
 8012008:	601a      	str	r2, [r3, #0]
  timeout->h = handler;
 801200a:	693b      	ldr	r3, [r7, #16]
 801200c:	68ba      	ldr	r2, [r7, #8]
 801200e:	609a      	str	r2, [r3, #8]
  timeout->arg = arg;
 8012010:	693b      	ldr	r3, [r7, #16]
 8012012:	687a      	ldr	r2, [r7, #4]
 8012014:	60da      	str	r2, [r3, #12]
  timeout->time = abs_time;
 8012016:	693b      	ldr	r3, [r7, #16]
 8012018:	68fa      	ldr	r2, [r7, #12]
 801201a:	605a      	str	r2, [r3, #4]
  timeout->handler_name = handler_name;
  LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p abs_time=%"U32_F" handler=%s arg=%p\n",
                             (void *)timeout, abs_time, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

  if (next_timeout == NULL) {
 801201c:	4b25      	ldr	r3, [pc, #148]	; (80120b4 <sys_timeout_abs+0xe0>)
 801201e:	681b      	ldr	r3, [r3, #0]
 8012020:	2b00      	cmp	r3, #0
 8012022:	d103      	bne.n	801202c <sys_timeout_abs+0x58>
    next_timeout = timeout;
 8012024:	4b23      	ldr	r3, [pc, #140]	; (80120b4 <sys_timeout_abs+0xe0>)
 8012026:	693a      	ldr	r2, [r7, #16]
 8012028:	601a      	str	r2, [r3, #0]
    return;
 801202a:	e039      	b.n	80120a0 <sys_timeout_abs+0xcc>
  }
  if (TIME_LESS_THAN(timeout->time, next_timeout->time)) {
 801202c:	693b      	ldr	r3, [r7, #16]
 801202e:	685a      	ldr	r2, [r3, #4]
 8012030:	4b20      	ldr	r3, [pc, #128]	; (80120b4 <sys_timeout_abs+0xe0>)
 8012032:	681b      	ldr	r3, [r3, #0]
 8012034:	685b      	ldr	r3, [r3, #4]
 8012036:	1ad3      	subs	r3, r2, r3
 8012038:	0fdb      	lsrs	r3, r3, #31
 801203a:	1c1a      	adds	r2, r3, #0
 801203c:	2301      	movs	r3, #1
 801203e:	4013      	ands	r3, r2
 8012040:	b2db      	uxtb	r3, r3
 8012042:	2b00      	cmp	r3, #0
 8012044:	d007      	beq.n	8012056 <sys_timeout_abs+0x82>
    timeout->next = next_timeout;
 8012046:	4b1b      	ldr	r3, [pc, #108]	; (80120b4 <sys_timeout_abs+0xe0>)
 8012048:	681a      	ldr	r2, [r3, #0]
 801204a:	693b      	ldr	r3, [r7, #16]
 801204c:	601a      	str	r2, [r3, #0]
    next_timeout = timeout;
 801204e:	4b19      	ldr	r3, [pc, #100]	; (80120b4 <sys_timeout_abs+0xe0>)
 8012050:	693a      	ldr	r2, [r7, #16]
 8012052:	601a      	str	r2, [r3, #0]
 8012054:	e024      	b.n	80120a0 <sys_timeout_abs+0xcc>
  } else {
    for (t = next_timeout; t != NULL; t = t->next) {
 8012056:	4b17      	ldr	r3, [pc, #92]	; (80120b4 <sys_timeout_abs+0xe0>)
 8012058:	681b      	ldr	r3, [r3, #0]
 801205a:	617b      	str	r3, [r7, #20]
 801205c:	e01b      	b.n	8012096 <sys_timeout_abs+0xc2>
      if ((t->next == NULL) || TIME_LESS_THAN(timeout->time, t->next->time)) {
 801205e:	697b      	ldr	r3, [r7, #20]
 8012060:	681b      	ldr	r3, [r3, #0]
 8012062:	2b00      	cmp	r3, #0
 8012064:	d00c      	beq.n	8012080 <sys_timeout_abs+0xac>
 8012066:	693b      	ldr	r3, [r7, #16]
 8012068:	685a      	ldr	r2, [r3, #4]
 801206a:	697b      	ldr	r3, [r7, #20]
 801206c:	681b      	ldr	r3, [r3, #0]
 801206e:	685b      	ldr	r3, [r3, #4]
 8012070:	1ad3      	subs	r3, r2, r3
 8012072:	0fdb      	lsrs	r3, r3, #31
 8012074:	1c1a      	adds	r2, r3, #0
 8012076:	2301      	movs	r3, #1
 8012078:	4013      	ands	r3, r2
 801207a:	b2db      	uxtb	r3, r3
 801207c:	2b00      	cmp	r3, #0
 801207e:	d007      	beq.n	8012090 <sys_timeout_abs+0xbc>
        timeout->next = t->next;
 8012080:	697b      	ldr	r3, [r7, #20]
 8012082:	681a      	ldr	r2, [r3, #0]
 8012084:	693b      	ldr	r3, [r7, #16]
 8012086:	601a      	str	r2, [r3, #0]
        t->next = timeout;
 8012088:	697b      	ldr	r3, [r7, #20]
 801208a:	693a      	ldr	r2, [r7, #16]
 801208c:	601a      	str	r2, [r3, #0]
        break;
 801208e:	e007      	b.n	80120a0 <sys_timeout_abs+0xcc>
    for (t = next_timeout; t != NULL; t = t->next) {
 8012090:	697b      	ldr	r3, [r7, #20]
 8012092:	681b      	ldr	r3, [r3, #0]
 8012094:	617b      	str	r3, [r7, #20]
 8012096:	697b      	ldr	r3, [r7, #20]
 8012098:	2b00      	cmp	r3, #0
 801209a:	d1e0      	bne.n	801205e <sys_timeout_abs+0x8a>
 801209c:	e000      	b.n	80120a0 <sys_timeout_abs+0xcc>
    return;
 801209e:	46c0      	nop			; (mov r8, r8)
      }
    }
  }
}
 80120a0:	46bd      	mov	sp, r7
 80120a2:	b006      	add	sp, #24
 80120a4:	bd80      	pop	{r7, pc}
 80120a6:	46c0      	nop			; (mov r8, r8)
 80120a8:	08020f74 	.word	0x08020f74
 80120ac:	08020fa0 	.word	0x08020fa0
 80120b0:	08020fe0 	.word	0x08020fe0
 80120b4:	20001b64 	.word	0x20001b64

080120b8 <sys_timeout>:
sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char *handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
void
sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
 80120b8:	b580      	push	{r7, lr}
 80120ba:	b086      	sub	sp, #24
 80120bc:	af00      	add	r7, sp, #0
 80120be:	60f8      	str	r0, [r7, #12]
 80120c0:	60b9      	str	r1, [r7, #8]
 80120c2:	607a      	str	r2, [r7, #4]
  u32_t next_timeout_time;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ASSERT("Timeout time too long, max is LWIP_UINT32_MAX/4 msecs", msecs <= (LWIP_UINT32_MAX / 4));
 80120c4:	68fa      	ldr	r2, [r7, #12]
 80120c6:	2380      	movs	r3, #128	; 0x80
 80120c8:	05db      	lsls	r3, r3, #23
 80120ca:	429a      	cmp	r2, r3
 80120cc:	d306      	bcc.n	80120dc <sys_timeout+0x24>
 80120ce:	4b0b      	ldr	r3, [pc, #44]	; (80120fc <sys_timeout+0x44>)
 80120d0:	222a      	movs	r2, #42	; 0x2a
 80120d2:	32ff      	adds	r2, #255	; 0xff
 80120d4:	490a      	ldr	r1, [pc, #40]	; (8012100 <sys_timeout+0x48>)
 80120d6:	480b      	ldr	r0, [pc, #44]	; (8012104 <sys_timeout+0x4c>)
 80120d8:	f7f0 fc00 	bl	80028dc <app_debug_rtt_raw>

  next_timeout_time = (u32_t)(sys_now() + msecs); /* overflow handled by TIME_LESS_THAN macro */ 
 80120dc:	f00a fd2e 	bl	801cb3c <sys_now>
 80120e0:	0002      	movs	r2, r0
 80120e2:	68fb      	ldr	r3, [r7, #12]
 80120e4:	189b      	adds	r3, r3, r2
 80120e6:	617b      	str	r3, [r7, #20]

#if LWIP_DEBUG_TIMERNAMES
  sys_timeout_abs(next_timeout_time, handler, arg, handler_name);
#else
  sys_timeout_abs(next_timeout_time, handler, arg);
 80120e8:	687a      	ldr	r2, [r7, #4]
 80120ea:	68b9      	ldr	r1, [r7, #8]
 80120ec:	697b      	ldr	r3, [r7, #20]
 80120ee:	0018      	movs	r0, r3
 80120f0:	f7ff ff70 	bl	8011fd4 <sys_timeout_abs>
#endif
}
 80120f4:	46c0      	nop			; (mov r8, r8)
 80120f6:	46bd      	mov	sp, r7
 80120f8:	b006      	add	sp, #24
 80120fa:	bd80      	pop	{r7, pc}
 80120fc:	08020f74 	.word	0x08020f74
 8012100:	0802100c 	.word	0x0802100c
 8012104:	08020fe0 	.word	0x08020fe0

08012108 <sys_untimeout>:
 * @param handler callback function that would be called by the timeout
 * @param arg callback argument that would be passed to handler
*/
void
sys_untimeout(sys_timeout_handler handler, void *arg)
{
 8012108:	b580      	push	{r7, lr}
 801210a:	b084      	sub	sp, #16
 801210c:	af00      	add	r7, sp, #0
 801210e:	6078      	str	r0, [r7, #4]
 8012110:	6039      	str	r1, [r7, #0]
  struct sys_timeo *prev_t, *t;

  LWIP_ASSERT_CORE_LOCKED();

  if (next_timeout == NULL) {
 8012112:	4b19      	ldr	r3, [pc, #100]	; (8012178 <sys_untimeout+0x70>)
 8012114:	681b      	ldr	r3, [r3, #0]
 8012116:	2b00      	cmp	r3, #0
 8012118:	d02a      	beq.n	8012170 <sys_untimeout+0x68>
    return;
  }

  for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
 801211a:	4b17      	ldr	r3, [pc, #92]	; (8012178 <sys_untimeout+0x70>)
 801211c:	681b      	ldr	r3, [r3, #0]
 801211e:	60bb      	str	r3, [r7, #8]
 8012120:	2300      	movs	r3, #0
 8012122:	60fb      	str	r3, [r7, #12]
 8012124:	e020      	b.n	8012168 <sys_untimeout+0x60>
    if ((t->h == handler) && (t->arg == arg)) {
 8012126:	68bb      	ldr	r3, [r7, #8]
 8012128:	689b      	ldr	r3, [r3, #8]
 801212a:	687a      	ldr	r2, [r7, #4]
 801212c:	429a      	cmp	r2, r3
 801212e:	d116      	bne.n	801215e <sys_untimeout+0x56>
 8012130:	68bb      	ldr	r3, [r7, #8]
 8012132:	68db      	ldr	r3, [r3, #12]
 8012134:	683a      	ldr	r2, [r7, #0]
 8012136:	429a      	cmp	r2, r3
 8012138:	d111      	bne.n	801215e <sys_untimeout+0x56>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL) {
 801213a:	68fb      	ldr	r3, [r7, #12]
 801213c:	2b00      	cmp	r3, #0
 801213e:	d104      	bne.n	801214a <sys_untimeout+0x42>
        next_timeout = t->next;
 8012140:	68bb      	ldr	r3, [r7, #8]
 8012142:	681a      	ldr	r2, [r3, #0]
 8012144:	4b0c      	ldr	r3, [pc, #48]	; (8012178 <sys_untimeout+0x70>)
 8012146:	601a      	str	r2, [r3, #0]
 8012148:	e003      	b.n	8012152 <sys_untimeout+0x4a>
      } else {
        prev_t->next = t->next;
 801214a:	68bb      	ldr	r3, [r7, #8]
 801214c:	681a      	ldr	r2, [r3, #0]
 801214e:	68fb      	ldr	r3, [r7, #12]
 8012150:	601a      	str	r2, [r3, #0]
      }
      memp_free(MEMP_SYS_TIMEOUT, t);
 8012152:	68bb      	ldr	r3, [r7, #8]
 8012154:	0019      	movs	r1, r3
 8012156:	2004      	movs	r0, #4
 8012158:	f7f6 fe4a 	bl	8008df0 <memp_free>
      return;
 801215c:	e009      	b.n	8012172 <sys_untimeout+0x6a>
  for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
 801215e:	68bb      	ldr	r3, [r7, #8]
 8012160:	60fb      	str	r3, [r7, #12]
 8012162:	68bb      	ldr	r3, [r7, #8]
 8012164:	681b      	ldr	r3, [r3, #0]
 8012166:	60bb      	str	r3, [r7, #8]
 8012168:	68bb      	ldr	r3, [r7, #8]
 801216a:	2b00      	cmp	r3, #0
 801216c:	d1db      	bne.n	8012126 <sys_untimeout+0x1e>
    }
  }
  return;
 801216e:	e000      	b.n	8012172 <sys_untimeout+0x6a>
    return;
 8012170:	46c0      	nop			; (mov r8, r8)
}
 8012172:	46bd      	mov	sp, r7
 8012174:	b004      	add	sp, #16
 8012176:	bd80      	pop	{r7, pc}
 8012178:	20001b64 	.word	0x20001b64

0801217c <sys_check_timeouts>:
 *
 * Must be called periodically from your main loop.
 */
void
sys_check_timeouts(void)
{
 801217c:	b580      	push	{r7, lr}
 801217e:	b084      	sub	sp, #16
 8012180:	af00      	add	r7, sp, #0
  u32_t now;

  LWIP_ASSERT_CORE_LOCKED();

  /* Process only timers expired at the start of the function. */
  now = sys_now();
 8012182:	f00a fcdb 	bl	801cb3c <sys_now>
 8012186:	0003      	movs	r3, r0
 8012188:	60fb      	str	r3, [r7, #12]
  do {
    struct sys_timeo *tmptimeout;
    sys_timeout_handler handler;
    void *arg;

    PBUF_CHECK_FREE_OOSEQ();
 801218a:	4b1c      	ldr	r3, [pc, #112]	; (80121fc <sys_check_timeouts+0x80>)
 801218c:	781b      	ldrb	r3, [r3, #0]
 801218e:	b2db      	uxtb	r3, r3
 8012190:	2b00      	cmp	r3, #0
 8012192:	d001      	beq.n	8012198 <sys_check_timeouts+0x1c>
 8012194:	f7f7 f94c 	bl	8009430 <pbuf_free_ooseq>

    tmptimeout = next_timeout;
 8012198:	4b19      	ldr	r3, [pc, #100]	; (8012200 <sys_check_timeouts+0x84>)
 801219a:	681b      	ldr	r3, [r3, #0]
 801219c:	60bb      	str	r3, [r7, #8]
    if (tmptimeout == NULL) {
 801219e:	68bb      	ldr	r3, [r7, #8]
 80121a0:	2b00      	cmp	r3, #0
 80121a2:	d025      	beq.n	80121f0 <sys_check_timeouts+0x74>
      return;
    }

    if (TIME_LESS_THAN(now, tmptimeout->time)) {
 80121a4:	68bb      	ldr	r3, [r7, #8]
 80121a6:	685b      	ldr	r3, [r3, #4]
 80121a8:	68fa      	ldr	r2, [r7, #12]
 80121aa:	1ad3      	subs	r3, r2, r3
 80121ac:	0fdb      	lsrs	r3, r3, #31
 80121ae:	1c1a      	adds	r2, r3, #0
 80121b0:	2301      	movs	r3, #1
 80121b2:	4013      	ands	r3, r2
 80121b4:	b2db      	uxtb	r3, r3
 80121b6:	2b00      	cmp	r3, #0
 80121b8:	d11c      	bne.n	80121f4 <sys_check_timeouts+0x78>
      return;
    }

    /* Timeout has expired */
    next_timeout = tmptimeout->next;
 80121ba:	68bb      	ldr	r3, [r7, #8]
 80121bc:	681a      	ldr	r2, [r3, #0]
 80121be:	4b10      	ldr	r3, [pc, #64]	; (8012200 <sys_check_timeouts+0x84>)
 80121c0:	601a      	str	r2, [r3, #0]
    handler = tmptimeout->h;
 80121c2:	68bb      	ldr	r3, [r7, #8]
 80121c4:	689b      	ldr	r3, [r3, #8]
 80121c6:	607b      	str	r3, [r7, #4]
    arg = tmptimeout->arg;
 80121c8:	68bb      	ldr	r3, [r7, #8]
 80121ca:	68db      	ldr	r3, [r3, #12]
 80121cc:	603b      	str	r3, [r7, #0]
    current_timeout_due_time = tmptimeout->time;
 80121ce:	68bb      	ldr	r3, [r7, #8]
 80121d0:	685a      	ldr	r2, [r3, #4]
 80121d2:	4b0c      	ldr	r3, [pc, #48]	; (8012204 <sys_check_timeouts+0x88>)
 80121d4:	601a      	str	r2, [r3, #0]
    if (handler != NULL) {
      LWIP_DEBUGF(TIMERS_DEBUG, ("sct calling h=%s t=%"U32_F" arg=%p\n",
                                 tmptimeout->handler_name, sys_now() - tmptimeout->time, arg));
    }
#endif /* LWIP_DEBUG_TIMERNAMES */
    memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
 80121d6:	68bb      	ldr	r3, [r7, #8]
 80121d8:	0019      	movs	r1, r3
 80121da:	2004      	movs	r0, #4
 80121dc:	f7f6 fe08 	bl	8008df0 <memp_free>
    if (handler != NULL) {
 80121e0:	687b      	ldr	r3, [r7, #4]
 80121e2:	2b00      	cmp	r3, #0
 80121e4:	d0d1      	beq.n	801218a <sys_check_timeouts+0xe>
      handler(arg);
 80121e6:	683a      	ldr	r2, [r7, #0]
 80121e8:	687b      	ldr	r3, [r7, #4]
 80121ea:	0010      	movs	r0, r2
 80121ec:	4798      	blx	r3
  do {
 80121ee:	e7cc      	b.n	801218a <sys_check_timeouts+0xe>
      return;
 80121f0:	46c0      	nop			; (mov r8, r8)
 80121f2:	e000      	b.n	80121f6 <sys_check_timeouts+0x7a>
      return;
 80121f4:	46c0      	nop			; (mov r8, r8)
    }
    LWIP_TCPIP_THREAD_ALIVE();

    /* Repeat until all expired timers have been called */
  } while (1);
}
 80121f6:	46bd      	mov	sp, r7
 80121f8:	b004      	add	sp, #16
 80121fa:	bd80      	pop	{r7, pc}
 80121fc:	20002ecc 	.word	0x20002ecc
 8012200:	20001b64 	.word	0x20001b64
 8012204:	20001b68 	.word	0x20001b68

08012208 <udp_new_port>:
 *
 * @return a new (free) local UDP port number
 */
static u16_t
udp_new_port(void)
{
 8012208:	b580      	push	{r7, lr}
 801220a:	b082      	sub	sp, #8
 801220c:	af00      	add	r7, sp, #0
  u16_t n = 0;
 801220e:	1dbb      	adds	r3, r7, #6
 8012210:	2200      	movs	r2, #0
 8012212:	801a      	strh	r2, [r3, #0]
  struct udp_pcb *pcb;

again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
 8012214:	4b17      	ldr	r3, [pc, #92]	; (8012274 <udp_new_port+0x6c>)
 8012216:	881b      	ldrh	r3, [r3, #0]
 8012218:	1c5a      	adds	r2, r3, #1
 801221a:	b291      	uxth	r1, r2
 801221c:	4a15      	ldr	r2, [pc, #84]	; (8012274 <udp_new_port+0x6c>)
 801221e:	8011      	strh	r1, [r2, #0]
 8012220:	4a15      	ldr	r2, [pc, #84]	; (8012278 <udp_new_port+0x70>)
 8012222:	4293      	cmp	r3, r2
 8012224:	d102      	bne.n	801222c <udp_new_port+0x24>
    udp_port = UDP_LOCAL_PORT_RANGE_START;
 8012226:	4b13      	ldr	r3, [pc, #76]	; (8012274 <udp_new_port+0x6c>)
 8012228:	4a14      	ldr	r2, [pc, #80]	; (801227c <udp_new_port+0x74>)
 801222a:	801a      	strh	r2, [r3, #0]
  }
  /* Check all PCBs. */
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 801222c:	4b14      	ldr	r3, [pc, #80]	; (8012280 <udp_new_port+0x78>)
 801222e:	681b      	ldr	r3, [r3, #0]
 8012230:	603b      	str	r3, [r7, #0]
 8012232:	e015      	b.n	8012260 <udp_new_port+0x58>
    if (pcb->local_port == udp_port) {
 8012234:	683b      	ldr	r3, [r7, #0]
 8012236:	8ada      	ldrh	r2, [r3, #22]
 8012238:	4b0e      	ldr	r3, [pc, #56]	; (8012274 <udp_new_port+0x6c>)
 801223a:	881b      	ldrh	r3, [r3, #0]
 801223c:	429a      	cmp	r2, r3
 801223e:	d10c      	bne.n	801225a <udp_new_port+0x52>
      if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
 8012240:	1dbb      	adds	r3, r7, #6
 8012242:	1dba      	adds	r2, r7, #6
 8012244:	8812      	ldrh	r2, [r2, #0]
 8012246:	3201      	adds	r2, #1
 8012248:	801a      	strh	r2, [r3, #0]
 801224a:	1dbb      	adds	r3, r7, #6
 801224c:	881a      	ldrh	r2, [r3, #0]
 801224e:	2380      	movs	r3, #128	; 0x80
 8012250:	01db      	lsls	r3, r3, #7
 8012252:	429a      	cmp	r2, r3
 8012254:	d3de      	bcc.n	8012214 <udp_new_port+0xc>
        return 0;
 8012256:	2300      	movs	r3, #0
 8012258:	e007      	b.n	801226a <udp_new_port+0x62>
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 801225a:	683b      	ldr	r3, [r7, #0]
 801225c:	691b      	ldr	r3, [r3, #16]
 801225e:	603b      	str	r3, [r7, #0]
 8012260:	683b      	ldr	r3, [r7, #0]
 8012262:	2b00      	cmp	r3, #0
 8012264:	d1e6      	bne.n	8012234 <udp_new_port+0x2c>
      }
      goto again;
    }
  }
  return udp_port;
 8012266:	4b03      	ldr	r3, [pc, #12]	; (8012274 <udp_new_port+0x6c>)
 8012268:	881b      	ldrh	r3, [r3, #0]
}
 801226a:	0018      	movs	r0, r3
 801226c:	46bd      	mov	sp, r7
 801226e:	b002      	add	sp, #8
 8012270:	bd80      	pop	{r7, pc}
 8012272:	46c0      	nop			; (mov r8, r8)
 8012274:	20000020 	.word	0x20000020
 8012278:	0000ffff 	.word	0x0000ffff
 801227c:	ffffc000 	.word	0xffffc000
 8012280:	20002eec 	.word	0x20002eec

08012284 <udp_input_local_match>:
 * @param broadcast 1 if his is an IPv4 broadcast (global or subnet-only), 0 otherwise (only used for IPv4)
 * @return 1 on match, 0 otherwise
 */
static u8_t
udp_input_local_match(struct udp_pcb *pcb, struct netif *inp, u8_t broadcast)
{
 8012284:	b580      	push	{r7, lr}
 8012286:	b084      	sub	sp, #16
 8012288:	af00      	add	r7, sp, #0
 801228a:	60f8      	str	r0, [r7, #12]
 801228c:	60b9      	str	r1, [r7, #8]
 801228e:	1dfb      	adds	r3, r7, #7
 8012290:	701a      	strb	r2, [r3, #0]
  LWIP_UNUSED_ARG(inp);       /* in IPv6 only case */
  LWIP_UNUSED_ARG(broadcast); /* in IPv6 only case */

  LWIP_ASSERT("udp_input_local_match: invalid pcb", pcb != NULL);
 8012292:	68fb      	ldr	r3, [r7, #12]
 8012294:	2b00      	cmp	r3, #0
 8012296:	d105      	bne.n	80122a4 <udp_input_local_match+0x20>
 8012298:	4b26      	ldr	r3, [pc, #152]	; (8012334 <udp_input_local_match+0xb0>)
 801229a:	4927      	ldr	r1, [pc, #156]	; (8012338 <udp_input_local_match+0xb4>)
 801229c:	4827      	ldr	r0, [pc, #156]	; (801233c <udp_input_local_match+0xb8>)
 801229e:	2287      	movs	r2, #135	; 0x87
 80122a0:	f7f0 fb1c 	bl	80028dc <app_debug_rtt_raw>
  LWIP_ASSERT("udp_input_local_match: invalid netif", inp != NULL);
 80122a4:	68bb      	ldr	r3, [r7, #8]
 80122a6:	2b00      	cmp	r3, #0
 80122a8:	d105      	bne.n	80122b6 <udp_input_local_match+0x32>
 80122aa:	4b22      	ldr	r3, [pc, #136]	; (8012334 <udp_input_local_match+0xb0>)
 80122ac:	4924      	ldr	r1, [pc, #144]	; (8012340 <udp_input_local_match+0xbc>)
 80122ae:	4823      	ldr	r0, [pc, #140]	; (801233c <udp_input_local_match+0xb8>)
 80122b0:	2288      	movs	r2, #136	; 0x88
 80122b2:	f7f0 fb13 	bl	80028dc <app_debug_rtt_raw>

  /* check if PCB is bound to specific netif */
  if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 80122b6:	68fb      	ldr	r3, [r7, #12]
 80122b8:	7a1b      	ldrb	r3, [r3, #8]
 80122ba:	2b00      	cmp	r3, #0
 80122bc:	d00b      	beq.n	80122d6 <udp_input_local_match+0x52>
      (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 80122be:	68fb      	ldr	r3, [r7, #12]
 80122c0:	7a1a      	ldrb	r2, [r3, #8]
 80122c2:	4b20      	ldr	r3, [pc, #128]	; (8012344 <udp_input_local_match+0xc0>)
 80122c4:	685b      	ldr	r3, [r3, #4]
 80122c6:	2134      	movs	r1, #52	; 0x34
 80122c8:	5c5b      	ldrb	r3, [r3, r1]
 80122ca:	3301      	adds	r3, #1
 80122cc:	b2db      	uxtb	r3, r3
  if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 80122ce:	429a      	cmp	r2, r3
 80122d0:	d001      	beq.n	80122d6 <udp_input_local_match+0x52>
    return 0;
 80122d2:	2300      	movs	r3, #0
 80122d4:	e02a      	b.n	801232c <udp_input_local_match+0xa8>
  /* Only need to check PCB if incoming IP version matches PCB IP version */
  if (IP_ADDR_PCB_VERSION_MATCH_EXACT(pcb, ip_current_dest_addr())) {
#if LWIP_IPV4
    /* Special case: IPv4 broadcast: all or broadcasts in my subnet
     * Note: broadcast variable can only be 1 if it is an IPv4 broadcast */
    if (broadcast != 0) {
 80122d6:	1dfb      	adds	r3, r7, #7
 80122d8:	781b      	ldrb	r3, [r3, #0]
 80122da:	2b00      	cmp	r3, #0
 80122dc:	d016      	beq.n	801230c <udp_input_local_match+0x88>
#if IP_SOF_BROADCAST_RECV
      if (ip_get_option(pcb, SOF_BROADCAST))
#endif /* IP_SOF_BROADCAST_RECV */
      {
        if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 80122de:	68fb      	ldr	r3, [r7, #12]
 80122e0:	2b00      	cmp	r3, #0
 80122e2:	d011      	beq.n	8012308 <udp_input_local_match+0x84>
 80122e4:	68fb      	ldr	r3, [r7, #12]
 80122e6:	681b      	ldr	r3, [r3, #0]
 80122e8:	2b00      	cmp	r3, #0
 80122ea:	d00d      	beq.n	8012308 <udp_input_local_match+0x84>
            ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
 80122ec:	4b15      	ldr	r3, [pc, #84]	; (8012344 <udp_input_local_match+0xc0>)
 80122ee:	695b      	ldr	r3, [r3, #20]
        if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 80122f0:	3301      	adds	r3, #1
 80122f2:	d009      	beq.n	8012308 <udp_input_local_match+0x84>
            ip4_addr_netcmp(ip_2_ip4(&pcb->local_ip), ip4_current_dest_addr(), netif_ip4_netmask(inp))) {
 80122f4:	68fb      	ldr	r3, [r7, #12]
 80122f6:	681a      	ldr	r2, [r3, #0]
 80122f8:	4b12      	ldr	r3, [pc, #72]	; (8012344 <udp_input_local_match+0xc0>)
 80122fa:	695b      	ldr	r3, [r3, #20]
 80122fc:	405a      	eors	r2, r3
 80122fe:	68bb      	ldr	r3, [r7, #8]
 8012300:	3308      	adds	r3, #8
 8012302:	681b      	ldr	r3, [r3, #0]
 8012304:	4013      	ands	r3, r2
            ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
 8012306:	d110      	bne.n	801232a <udp_input_local_match+0xa6>
          return 1;
 8012308:	2301      	movs	r3, #1
 801230a:	e00f      	b.n	801232c <udp_input_local_match+0xa8>
        }
      }
    } else
#endif /* LWIP_IPV4 */
      /* Handle IPv4 and IPv6: all or exact match */
      if (ip_addr_isany(&pcb->local_ip) || ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 801230c:	68fb      	ldr	r3, [r7, #12]
 801230e:	2b00      	cmp	r3, #0
 8012310:	d009      	beq.n	8012326 <udp_input_local_match+0xa2>
 8012312:	68fb      	ldr	r3, [r7, #12]
 8012314:	681b      	ldr	r3, [r3, #0]
 8012316:	2b00      	cmp	r3, #0
 8012318:	d005      	beq.n	8012326 <udp_input_local_match+0xa2>
 801231a:	68fb      	ldr	r3, [r7, #12]
 801231c:	681a      	ldr	r2, [r3, #0]
 801231e:	4b09      	ldr	r3, [pc, #36]	; (8012344 <udp_input_local_match+0xc0>)
 8012320:	695b      	ldr	r3, [r3, #20]
 8012322:	429a      	cmp	r2, r3
 8012324:	d101      	bne.n	801232a <udp_input_local_match+0xa6>
        return 1;
 8012326:	2301      	movs	r3, #1
 8012328:	e000      	b.n	801232c <udp_input_local_match+0xa8>
      }
  }

  return 0;
 801232a:	2300      	movs	r3, #0
}
 801232c:	0018      	movs	r0, r3
 801232e:	46bd      	mov	sp, r7
 8012330:	b004      	add	sp, #16
 8012332:	bd80      	pop	{r7, pc}
 8012334:	08021058 	.word	0x08021058
 8012338:	08021080 	.word	0x08021080
 801233c:	080210a4 	.word	0x080210a4
 8012340:	080210d0 	.word	0x080210d0
 8012344:	20001c94 	.word	0x20001c94

08012348 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
 8012348:	b5b0      	push	{r4, r5, r7, lr}
 801234a:	b08c      	sub	sp, #48	; 0x30
 801234c:	af02      	add	r7, sp, #8
 801234e:	6078      	str	r0, [r7, #4]
 8012350:	6039      	str	r1, [r7, #0]
  struct udp_hdr *udphdr;
  struct udp_pcb *pcb, *prev;
  struct udp_pcb *uncon_pcb;
  u16_t src, dest;
  u8_t broadcast;
  u8_t for_us = 0;
 8012352:	231b      	movs	r3, #27
 8012354:	18fb      	adds	r3, r7, r3
 8012356:	2200      	movs	r2, #0
 8012358:	701a      	strb	r2, [r3, #0]

  LWIP_UNUSED_ARG(inp);

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ASSERT("udp_input: invalid pbuf", p != NULL);
 801235a:	687b      	ldr	r3, [r7, #4]
 801235c:	2b00      	cmp	r3, #0
 801235e:	d105      	bne.n	801236c <udp_input+0x24>
 8012360:	4ba1      	ldr	r3, [pc, #644]	; (80125e8 <udp_input+0x2a0>)
 8012362:	49a2      	ldr	r1, [pc, #648]	; (80125ec <udp_input+0x2a4>)
 8012364:	48a2      	ldr	r0, [pc, #648]	; (80125f0 <udp_input+0x2a8>)
 8012366:	22cf      	movs	r2, #207	; 0xcf
 8012368:	f7f0 fab8 	bl	80028dc <app_debug_rtt_raw>
  LWIP_ASSERT("udp_input: invalid netif", inp != NULL);
 801236c:	683b      	ldr	r3, [r7, #0]
 801236e:	2b00      	cmp	r3, #0
 8012370:	d105      	bne.n	801237e <udp_input+0x36>
 8012372:	4b9d      	ldr	r3, [pc, #628]	; (80125e8 <udp_input+0x2a0>)
 8012374:	499f      	ldr	r1, [pc, #636]	; (80125f4 <udp_input+0x2ac>)
 8012376:	489e      	ldr	r0, [pc, #632]	; (80125f0 <udp_input+0x2a8>)
 8012378:	22d0      	movs	r2, #208	; 0xd0
 801237a:	f7f0 faaf 	bl	80028dc <app_debug_rtt_raw>
  PERF_START;

  UDP_STATS_INC(udp.recv);

  /* Check minimum length (UDP header) */
  if (p->len < UDP_HLEN) {
 801237e:	687b      	ldr	r3, [r7, #4]
 8012380:	895b      	ldrh	r3, [r3, #10]
 8012382:	2b07      	cmp	r3, #7
 8012384:	d804      	bhi.n	8012390 <udp_input+0x48>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    MIB2_STATS_INC(mib2.udpinerrors);
    pbuf_free(p);
 8012386:	687b      	ldr	r3, [r7, #4]
 8012388:	0018      	movs	r0, r3
 801238a:	f7f7 fc21 	bl	8009bd0 <pbuf_free>
    goto end;
 801238e:	e121      	b.n	80125d4 <udp_input+0x28c>
  }

  udphdr = (struct udp_hdr *)p->payload;
 8012390:	687b      	ldr	r3, [r7, #4]
 8012392:	685b      	ldr	r3, [r3, #4]
 8012394:	617b      	str	r3, [r7, #20]

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif());
 8012396:	4b98      	ldr	r3, [pc, #608]	; (80125f8 <udp_input+0x2b0>)
 8012398:	695a      	ldr	r2, [r3, #20]
 801239a:	4b97      	ldr	r3, [pc, #604]	; (80125f8 <udp_input+0x2b0>)
 801239c:	681b      	ldr	r3, [r3, #0]
 801239e:	2113      	movs	r1, #19
 80123a0:	187c      	adds	r4, r7, r1
 80123a2:	0019      	movs	r1, r3
 80123a4:	0010      	movs	r0, r2
 80123a6:	f001 fbc3 	bl	8013b30 <ip4_addr_isbroadcast_u32>
 80123aa:	0003      	movs	r3, r0
 80123ac:	7023      	strb	r3, [r4, #0]

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = lwip_ntohs(udphdr->src);
 80123ae:	697b      	ldr	r3, [r7, #20]
 80123b0:	781a      	ldrb	r2, [r3, #0]
 80123b2:	785b      	ldrb	r3, [r3, #1]
 80123b4:	021b      	lsls	r3, r3, #8
 80123b6:	4313      	orrs	r3, r2
 80123b8:	b29b      	uxth	r3, r3
 80123ba:	2210      	movs	r2, #16
 80123bc:	18bc      	adds	r4, r7, r2
 80123be:	0018      	movs	r0, r3
 80123c0:	f7f4 fc22 	bl	8006c08 <lwip_htons>
 80123c4:	0003      	movs	r3, r0
 80123c6:	8023      	strh	r3, [r4, #0]
  dest = lwip_ntohs(udphdr->dest);
 80123c8:	697b      	ldr	r3, [r7, #20]
 80123ca:	789a      	ldrb	r2, [r3, #2]
 80123cc:	78db      	ldrb	r3, [r3, #3]
 80123ce:	021b      	lsls	r3, r3, #8
 80123d0:	4313      	orrs	r3, r2
 80123d2:	b29b      	uxth	r3, r3
 80123d4:	220e      	movs	r2, #14
 80123d6:	18bc      	adds	r4, r7, r2
 80123d8:	0018      	movs	r0, r3
 80123da:	f7f4 fc15 	bl	8006c08 <lwip_htons>
 80123de:	0003      	movs	r3, r0
 80123e0:	8023      	strh	r3, [r4, #0]
  ip_addr_debug_print_val(UDP_DEBUG, *ip_current_dest_addr());
  LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F") <-- (", lwip_ntohs(udphdr->dest)));
  ip_addr_debug_print_val(UDP_DEBUG, *ip_current_src_addr());
  LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F")\n", lwip_ntohs(udphdr->src)));

  pcb = NULL;
 80123e2:	2300      	movs	r3, #0
 80123e4:	61fb      	str	r3, [r7, #28]
  prev = NULL;
 80123e6:	2300      	movs	r3, #0
 80123e8:	623b      	str	r3, [r7, #32]
  uncon_pcb = NULL;
 80123ea:	2300      	movs	r3, #0
 80123ec:	627b      	str	r3, [r7, #36]	; 0x24
  /* Iterate through the UDP pcb list for a matching pcb.
   * 'Perfect match' pcbs (connected to the remote port & ip address) are
   * preferred. If no perfect match is found, the first unconnected pcb that
   * matches the local port and ip address gets the datagram. */
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 80123ee:	4b83      	ldr	r3, [pc, #524]	; (80125fc <udp_input+0x2b4>)
 80123f0:	681b      	ldr	r3, [r3, #0]
 80123f2:	61fb      	str	r3, [r7, #28]
 80123f4:	e066      	b.n	80124c4 <udp_input+0x17c>
    LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F") <-- (", pcb->local_port));
    ip_addr_debug_print_val(UDP_DEBUG, pcb->remote_ip);
    LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F")\n", pcb->remote_port));

    /* compare PCB local addr+port to UDP destination addr+port */
    if ((pcb->local_port == dest) &&
 80123f6:	69fb      	ldr	r3, [r7, #28]
 80123f8:	8adb      	ldrh	r3, [r3, #22]
 80123fa:	220e      	movs	r2, #14
 80123fc:	18ba      	adds	r2, r7, r2
 80123fe:	8812      	ldrh	r2, [r2, #0]
 8012400:	429a      	cmp	r2, r3
 8012402:	d15a      	bne.n	80124ba <udp_input+0x172>
        (udp_input_local_match(pcb, inp, broadcast) != 0)) {
 8012404:	2313      	movs	r3, #19
 8012406:	18fb      	adds	r3, r7, r3
 8012408:	781a      	ldrb	r2, [r3, #0]
 801240a:	6839      	ldr	r1, [r7, #0]
 801240c:	69fb      	ldr	r3, [r7, #28]
 801240e:	0018      	movs	r0, r3
 8012410:	f7ff ff38 	bl	8012284 <udp_input_local_match>
 8012414:	1e03      	subs	r3, r0, #0
    if ((pcb->local_port == dest) &&
 8012416:	d050      	beq.n	80124ba <udp_input+0x172>
      if ((pcb->flags & UDP_FLAGS_CONNECTED) == 0) {
 8012418:	69fb      	ldr	r3, [r7, #28]
 801241a:	7d1b      	ldrb	r3, [r3, #20]
 801241c:	001a      	movs	r2, r3
 801241e:	2304      	movs	r3, #4
 8012420:	4013      	ands	r3, r2
 8012422:	d12a      	bne.n	801247a <udp_input+0x132>
        if (uncon_pcb == NULL) {
 8012424:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012426:	2b00      	cmp	r3, #0
 8012428:	d102      	bne.n	8012430 <udp_input+0xe8>
          /* the first unconnected matching PCB */
          uncon_pcb = pcb;
 801242a:	69fb      	ldr	r3, [r7, #28]
 801242c:	627b      	str	r3, [r7, #36]	; 0x24
 801242e:	e024      	b.n	801247a <udp_input+0x132>
#if LWIP_IPV4
        } else if (broadcast && ip4_current_dest_addr()->addr == IPADDR_BROADCAST) {
 8012430:	2313      	movs	r3, #19
 8012432:	18fb      	adds	r3, r7, r3
 8012434:	781b      	ldrb	r3, [r3, #0]
 8012436:	2b00      	cmp	r3, #0
 8012438:	d014      	beq.n	8012464 <udp_input+0x11c>
 801243a:	4b6f      	ldr	r3, [pc, #444]	; (80125f8 <udp_input+0x2b0>)
 801243c:	695b      	ldr	r3, [r3, #20]
 801243e:	3301      	adds	r3, #1
 8012440:	d110      	bne.n	8012464 <udp_input+0x11c>
          /* global broadcast address (only valid for IPv4; match was checked before) */
          if (!IP_IS_V4_VAL(uncon_pcb->local_ip) || !ip4_addr_cmp(ip_2_ip4(&uncon_pcb->local_ip), netif_ip4_addr(inp))) {
 8012442:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012444:	681a      	ldr	r2, [r3, #0]
 8012446:	683b      	ldr	r3, [r7, #0]
 8012448:	3304      	adds	r3, #4
 801244a:	681b      	ldr	r3, [r3, #0]
 801244c:	429a      	cmp	r2, r3
 801244e:	d013      	beq.n	8012478 <udp_input+0x130>
            /* uncon_pcb does not match the input netif, check this pcb */
            if (IP_IS_V4_VAL(pcb->local_ip) && ip4_addr_cmp(ip_2_ip4(&pcb->local_ip), netif_ip4_addr(inp))) {
 8012450:	69fb      	ldr	r3, [r7, #28]
 8012452:	681a      	ldr	r2, [r3, #0]
 8012454:	683b      	ldr	r3, [r7, #0]
 8012456:	3304      	adds	r3, #4
 8012458:	681b      	ldr	r3, [r3, #0]
 801245a:	429a      	cmp	r2, r3
 801245c:	d10c      	bne.n	8012478 <udp_input+0x130>
              /* better match */
              uncon_pcb = pcb;
 801245e:	69fb      	ldr	r3, [r7, #28]
 8012460:	627b      	str	r3, [r7, #36]	; 0x24
          if (!IP_IS_V4_VAL(uncon_pcb->local_ip) || !ip4_addr_cmp(ip_2_ip4(&uncon_pcb->local_ip), netif_ip4_addr(inp))) {
 8012462:	e009      	b.n	8012478 <udp_input+0x130>
            }
          }
#endif /* LWIP_IPV4 */
        }
#if SO_REUSE
        else if (!ip_addr_isany(&pcb->local_ip)) {
 8012464:	69fb      	ldr	r3, [r7, #28]
 8012466:	2b00      	cmp	r3, #0
 8012468:	d007      	beq.n	801247a <udp_input+0x132>
 801246a:	69fb      	ldr	r3, [r7, #28]
 801246c:	681b      	ldr	r3, [r3, #0]
 801246e:	2b00      	cmp	r3, #0
 8012470:	d003      	beq.n	801247a <udp_input+0x132>
          /* prefer specific IPs over catch-all */
          uncon_pcb = pcb;
 8012472:	69fb      	ldr	r3, [r7, #28]
 8012474:	627b      	str	r3, [r7, #36]	; 0x24
 8012476:	e000      	b.n	801247a <udp_input+0x132>
          if (!IP_IS_V4_VAL(uncon_pcb->local_ip) || !ip4_addr_cmp(ip_2_ip4(&uncon_pcb->local_ip), netif_ip4_addr(inp))) {
 8012478:	46c0      	nop			; (mov r8, r8)
        }
#endif /* SO_REUSE */
      }

      /* compare PCB remote addr+port to UDP source addr+port */
      if ((pcb->remote_port == src) &&
 801247a:	69fb      	ldr	r3, [r7, #28]
 801247c:	8b1b      	ldrh	r3, [r3, #24]
 801247e:	2210      	movs	r2, #16
 8012480:	18ba      	adds	r2, r7, r2
 8012482:	8812      	ldrh	r2, [r2, #0]
 8012484:	429a      	cmp	r2, r3
 8012486:	d118      	bne.n	80124ba <udp_input+0x172>
          (ip_addr_isany_val(pcb->remote_ip) ||
 8012488:	69fb      	ldr	r3, [r7, #28]
 801248a:	685b      	ldr	r3, [r3, #4]
      if ((pcb->remote_port == src) &&
 801248c:	2b00      	cmp	r3, #0
 801248e:	d005      	beq.n	801249c <udp_input+0x154>
           ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()))) {
 8012490:	69fb      	ldr	r3, [r7, #28]
 8012492:	685a      	ldr	r2, [r3, #4]
 8012494:	4b58      	ldr	r3, [pc, #352]	; (80125f8 <udp_input+0x2b0>)
 8012496:	691b      	ldr	r3, [r3, #16]
          (ip_addr_isany_val(pcb->remote_ip) ||
 8012498:	429a      	cmp	r2, r3
 801249a:	d10e      	bne.n	80124ba <udp_input+0x172>
        /* the first fully matching PCB */
        if (prev != NULL) {
 801249c:	6a3b      	ldr	r3, [r7, #32]
 801249e:	2b00      	cmp	r3, #0
 80124a0:	d014      	beq.n	80124cc <udp_input+0x184>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
 80124a2:	69fb      	ldr	r3, [r7, #28]
 80124a4:	691a      	ldr	r2, [r3, #16]
 80124a6:	6a3b      	ldr	r3, [r7, #32]
 80124a8:	611a      	str	r2, [r3, #16]
          pcb->next = udp_pcbs;
 80124aa:	4b54      	ldr	r3, [pc, #336]	; (80125fc <udp_input+0x2b4>)
 80124ac:	681a      	ldr	r2, [r3, #0]
 80124ae:	69fb      	ldr	r3, [r7, #28]
 80124b0:	611a      	str	r2, [r3, #16]
          udp_pcbs = pcb;
 80124b2:	4b52      	ldr	r3, [pc, #328]	; (80125fc <udp_input+0x2b4>)
 80124b4:	69fa      	ldr	r2, [r7, #28]
 80124b6:	601a      	str	r2, [r3, #0]
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
 80124b8:	e008      	b.n	80124cc <udp_input+0x184>
      }
    }

    prev = pcb;
 80124ba:	69fb      	ldr	r3, [r7, #28]
 80124bc:	623b      	str	r3, [r7, #32]
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 80124be:	69fb      	ldr	r3, [r7, #28]
 80124c0:	691b      	ldr	r3, [r3, #16]
 80124c2:	61fb      	str	r3, [r7, #28]
 80124c4:	69fb      	ldr	r3, [r7, #28]
 80124c6:	2b00      	cmp	r3, #0
 80124c8:	d195      	bne.n	80123f6 <udp_input+0xae>
 80124ca:	e000      	b.n	80124ce <udp_input+0x186>
        break;
 80124cc:	46c0      	nop			; (mov r8, r8)
  }
  /* no fully matching pcb found? then look for an unconnected pcb */
  if (pcb == NULL) {
 80124ce:	69fb      	ldr	r3, [r7, #28]
 80124d0:	2b00      	cmp	r3, #0
 80124d2:	d101      	bne.n	80124d8 <udp_input+0x190>
    pcb = uncon_pcb;
 80124d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80124d6:	61fb      	str	r3, [r7, #28]
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL) {
 80124d8:	69fb      	ldr	r3, [r7, #28]
 80124da:	2b00      	cmp	r3, #0
 80124dc:	d004      	beq.n	80124e8 <udp_input+0x1a0>
    for_us = 1;
 80124de:	231b      	movs	r3, #27
 80124e0:	18fb      	adds	r3, r7, r3
 80124e2:	2201      	movs	r2, #1
 80124e4:	701a      	strb	r2, [r3, #0]
 80124e6:	e00b      	b.n	8012500 <udp_input+0x1b8>
      for_us = netif_get_ip6_addr_match(inp, ip6_current_dest_addr()) >= 0;
    }
#endif /* LWIP_IPV6 */
#if LWIP_IPV4
    if (!ip_current_is_v6()) {
      for_us = ip4_addr_cmp(netif_ip4_addr(inp), ip4_current_dest_addr());
 80124e8:	683b      	ldr	r3, [r7, #0]
 80124ea:	3304      	adds	r3, #4
 80124ec:	681a      	ldr	r2, [r3, #0]
 80124ee:	4b42      	ldr	r3, [pc, #264]	; (80125f8 <udp_input+0x2b0>)
 80124f0:	695b      	ldr	r3, [r3, #20]
 80124f2:	1ad3      	subs	r3, r2, r3
 80124f4:	425a      	negs	r2, r3
 80124f6:	4153      	adcs	r3, r2
 80124f8:	b2da      	uxtb	r2, r3
 80124fa:	231b      	movs	r3, #27
 80124fc:	18fb      	adds	r3, r7, r3
 80124fe:	701a      	strb	r2, [r3, #0]
    }
#endif /* LWIP_IPV4 */
  }

  if (for_us) {
 8012500:	231b      	movs	r3, #27
 8012502:	18fb      	adds	r3, r7, r3
 8012504:	781b      	ldrb	r3, [r3, #0]
 8012506:	2b00      	cmp	r3, #0
 8012508:	d05f      	beq.n	80125ca <udp_input+0x282>
          goto chkerr;
        }
      } else
#endif /* LWIP_UDPLITE */
      {
        if (udphdr->chksum != 0) {
 801250a:	697b      	ldr	r3, [r7, #20]
 801250c:	799a      	ldrb	r2, [r3, #6]
 801250e:	79db      	ldrb	r3, [r3, #7]
 8012510:	021b      	lsls	r3, r3, #8
 8012512:	4313      	orrs	r3, r2
 8012514:	b29b      	uxth	r3, r3
 8012516:	2b00      	cmp	r3, #0
 8012518:	d00b      	beq.n	8012532 <udp_input+0x1ea>
          if (ip_chksum_pseudo(p, IP_PROTO_UDP, p->tot_len,
 801251a:	687b      	ldr	r3, [r7, #4]
 801251c:	891a      	ldrh	r2, [r3, #8]
 801251e:	4938      	ldr	r1, [pc, #224]	; (8012600 <udp_input+0x2b8>)
 8012520:	6878      	ldr	r0, [r7, #4]
 8012522:	4b38      	ldr	r3, [pc, #224]	; (8012604 <udp_input+0x2bc>)
 8012524:	9300      	str	r3, [sp, #0]
 8012526:	000b      	movs	r3, r1
 8012528:	2111      	movs	r1, #17
 801252a:	f7f5 fdf4 	bl	8008116 <ip_chksum_pseudo>
 801252e:	1e03      	subs	r3, r0, #0
 8012530:	d151      	bne.n	80125d6 <udp_input+0x28e>
          }
        }
      }
    }
#endif /* CHECKSUM_CHECK_UDP */
    if (pbuf_remove_header(p, UDP_HLEN)) {
 8012532:	687b      	ldr	r3, [r7, #4]
 8012534:	2108      	movs	r1, #8
 8012536:	0018      	movs	r0, r3
 8012538:	f7f7 fa72 	bl	8009a20 <pbuf_remove_header>
 801253c:	1e03      	subs	r3, r0, #0
 801253e:	d00b      	beq.n	8012558 <udp_input+0x210>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_remove_header failed\n", 0);
 8012540:	4b29      	ldr	r3, [pc, #164]	; (80125e8 <udp_input+0x2a0>)
 8012542:	22b8      	movs	r2, #184	; 0xb8
 8012544:	0052      	lsls	r2, r2, #1
 8012546:	4930      	ldr	r1, [pc, #192]	; (8012608 <udp_input+0x2c0>)
 8012548:	4829      	ldr	r0, [pc, #164]	; (80125f0 <udp_input+0x2a8>)
 801254a:	f7f0 f9c7 	bl	80028dc <app_debug_rtt_raw>
      UDP_STATS_INC(udp.drop);
      MIB2_STATS_INC(mib2.udpinerrors);
      pbuf_free(p);
 801254e:	687b      	ldr	r3, [r7, #4]
 8012550:	0018      	movs	r0, r3
 8012552:	f7f7 fb3d 	bl	8009bd0 <pbuf_free>
      goto end;
 8012556:	e03d      	b.n	80125d4 <udp_input+0x28c>
    }

    if (pcb != NULL) {
 8012558:	69fb      	ldr	r3, [r7, #28]
 801255a:	2b00      	cmp	r3, #0
 801255c:	d016      	beq.n	801258c <udp_input+0x244>
          }
        }
      }
#endif /* SO_REUSE && SO_REUSE_RXTOALL */
      /* callback */
      if (pcb->recv != NULL) {
 801255e:	69fb      	ldr	r3, [r7, #28]
 8012560:	69db      	ldr	r3, [r3, #28]
 8012562:	2b00      	cmp	r3, #0
 8012564:	d00d      	beq.n	8012582 <udp_input+0x23a>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
 8012566:	69fb      	ldr	r3, [r7, #28]
 8012568:	69dc      	ldr	r4, [r3, #28]
 801256a:	69fb      	ldr	r3, [r7, #28]
 801256c:	6a18      	ldr	r0, [r3, #32]
 801256e:	4d24      	ldr	r5, [pc, #144]	; (8012600 <udp_input+0x2b8>)
 8012570:	687a      	ldr	r2, [r7, #4]
 8012572:	69f9      	ldr	r1, [r7, #28]
 8012574:	2310      	movs	r3, #16
 8012576:	18fb      	adds	r3, r7, r3
 8012578:	881b      	ldrh	r3, [r3, #0]
 801257a:	9300      	str	r3, [sp, #0]
 801257c:	002b      	movs	r3, r5
 801257e:	47a0      	blx	r4
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
  return;
 8012580:	e02e      	b.n	80125e0 <udp_input+0x298>
        pbuf_free(p);
 8012582:	687b      	ldr	r3, [r7, #4]
 8012584:	0018      	movs	r0, r3
 8012586:	f7f7 fb23 	bl	8009bd0 <pbuf_free>
        goto end;
 801258a:	e023      	b.n	80125d4 <udp_input+0x28c>
      if (!broadcast && !ip_addr_ismulticast(ip_current_dest_addr())) {
 801258c:	2313      	movs	r3, #19
 801258e:	18fb      	adds	r3, r7, r3
 8012590:	781b      	ldrb	r3, [r3, #0]
 8012592:	2b00      	cmp	r3, #0
 8012594:	d114      	bne.n	80125c0 <udp_input+0x278>
 8012596:	4b18      	ldr	r3, [pc, #96]	; (80125f8 <udp_input+0x2b0>)
 8012598:	695b      	ldr	r3, [r3, #20]
 801259a:	22f0      	movs	r2, #240	; 0xf0
 801259c:	4013      	ands	r3, r2
 801259e:	2be0      	cmp	r3, #224	; 0xe0
 80125a0:	d00e      	beq.n	80125c0 <udp_input+0x278>
        pbuf_header_force(p, (s16_t)(ip_current_header_tot_len() + UDP_HLEN));
 80125a2:	4b15      	ldr	r3, [pc, #84]	; (80125f8 <udp_input+0x2b0>)
 80125a4:	899b      	ldrh	r3, [r3, #12]
 80125a6:	3308      	adds	r3, #8
 80125a8:	b29b      	uxth	r3, r3
 80125aa:	b21a      	sxth	r2, r3
 80125ac:	687b      	ldr	r3, [r7, #4]
 80125ae:	0011      	movs	r1, r2
 80125b0:	0018      	movs	r0, r3
 80125b2:	f7f7 fab6 	bl	8009b22 <pbuf_header_force>
        icmp_port_unreach(ip_current_is_v6(), p);
 80125b6:	687b      	ldr	r3, [r7, #4]
 80125b8:	2103      	movs	r1, #3
 80125ba:	0018      	movs	r0, r3
 80125bc:	f000 fdc0 	bl	8013140 <icmp_dest_unreach>
      pbuf_free(p);
 80125c0:	687b      	ldr	r3, [r7, #4]
 80125c2:	0018      	movs	r0, r3
 80125c4:	f7f7 fb04 	bl	8009bd0 <pbuf_free>
  return;
 80125c8:	e00a      	b.n	80125e0 <udp_input+0x298>
    pbuf_free(p);
 80125ca:	687b      	ldr	r3, [r7, #4]
 80125cc:	0018      	movs	r0, r3
 80125ce:	f7f7 faff 	bl	8009bd0 <pbuf_free>
  return;
 80125d2:	e005      	b.n	80125e0 <udp_input+0x298>
 80125d4:	e004      	b.n	80125e0 <udp_input+0x298>
            goto chkerr;
 80125d6:	46c0      	nop			; (mov r8, r8)
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
              ("udp_input: UDP (or UDP Lite) datagram discarded due to failing checksum\n"));
  UDP_STATS_INC(udp.chkerr);
  UDP_STATS_INC(udp.drop);
  MIB2_STATS_INC(mib2.udpinerrors);
  pbuf_free(p);
 80125d8:	687b      	ldr	r3, [r7, #4]
 80125da:	0018      	movs	r0, r3
 80125dc:	f7f7 faf8 	bl	8009bd0 <pbuf_free>
  PERF_STOP("udp_input");
#endif /* CHECKSUM_CHECK_UDP */
}
 80125e0:	46bd      	mov	sp, r7
 80125e2:	b00a      	add	sp, #40	; 0x28
 80125e4:	bdb0      	pop	{r4, r5, r7, pc}
 80125e6:	46c0      	nop			; (mov r8, r8)
 80125e8:	08021058 	.word	0x08021058
 80125ec:	080210f8 	.word	0x080210f8
 80125f0:	080210a4 	.word	0x080210a4
 80125f4:	08021110 	.word	0x08021110
 80125f8:	20001c94 	.word	0x20001c94
 80125fc:	20002eec 	.word	0x20002eec
 8012600:	20001ca4 	.word	0x20001ca4
 8012604:	20001ca8 	.word	0x20001ca8
 8012608:	0802112c 	.word	0x0802112c

0801260c <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
           const ip_addr_t *dst_ip, u16_t dst_port)
{
 801260c:	b590      	push	{r4, r7, lr}
 801260e:	b087      	sub	sp, #28
 8012610:	af02      	add	r7, sp, #8
 8012612:	60f8      	str	r0, [r7, #12]
 8012614:	60b9      	str	r1, [r7, #8]
 8012616:	607a      	str	r2, [r7, #4]
 8012618:	001a      	movs	r2, r3
 801261a:	1cbb      	adds	r3, r7, #2
 801261c:	801a      	strh	r2, [r3, #0]
#if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
  return udp_sendto_chksum(pcb, p, dst_ip, dst_port, 0, 0);
 801261e:	1cbb      	adds	r3, r7, #2
 8012620:	881b      	ldrh	r3, [r3, #0]
 8012622:	687a      	ldr	r2, [r7, #4]
 8012624:	68b9      	ldr	r1, [r7, #8]
 8012626:	68f8      	ldr	r0, [r7, #12]
 8012628:	2400      	movs	r4, #0
 801262a:	9401      	str	r4, [sp, #4]
 801262c:	2400      	movs	r4, #0
 801262e:	9400      	str	r4, [sp, #0]
 8012630:	f000 f806 	bl	8012640 <udp_sendto_chksum>
 8012634:	0003      	movs	r3, r0
}
 8012636:	0018      	movs	r0, r3
 8012638:	46bd      	mov	sp, r7
 801263a:	b005      	add	sp, #20
 801263c:	bd90      	pop	{r4, r7, pc}
	...

08012640 <udp_sendto_chksum>:
/** @ingroup udp_raw
 * Same as udp_sendto(), but with checksum */
err_t
udp_sendto_chksum(struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip,
                  u16_t dst_port, u8_t have_chksum, u16_t chksum)
{
 8012640:	b590      	push	{r4, r7, lr}
 8012642:	b08b      	sub	sp, #44	; 0x2c
 8012644:	af04      	add	r7, sp, #16
 8012646:	60f8      	str	r0, [r7, #12]
 8012648:	60b9      	str	r1, [r7, #8]
 801264a:	607a      	str	r2, [r7, #4]
 801264c:	001a      	movs	r2, r3
 801264e:	1cbb      	adds	r3, r7, #2
 8012650:	801a      	strh	r2, [r3, #0]
#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
  struct netif *netif;

  LWIP_ERROR("udp_sendto: invalid pcb", pcb != NULL, return ERR_ARG);
 8012652:	68fb      	ldr	r3, [r7, #12]
 8012654:	2b00      	cmp	r3, #0
 8012656:	d106      	bne.n	8012666 <udp_sendto_chksum+0x26>
 8012658:	4b24      	ldr	r3, [pc, #144]	; (80126ec <udp_sendto_chksum+0xac>)
 801265a:	0018      	movs	r0, r3
 801265c:	f7f0 f93e 	bl	80028dc <app_debug_rtt_raw>
 8012660:	2310      	movs	r3, #16
 8012662:	425b      	negs	r3, r3
 8012664:	e03e      	b.n	80126e4 <udp_sendto_chksum+0xa4>
  LWIP_ERROR("udp_sendto: invalid pbuf", p != NULL, return ERR_ARG);
 8012666:	68bb      	ldr	r3, [r7, #8]
 8012668:	2b00      	cmp	r3, #0
 801266a:	d106      	bne.n	801267a <udp_sendto_chksum+0x3a>
 801266c:	4b20      	ldr	r3, [pc, #128]	; (80126f0 <udp_sendto_chksum+0xb0>)
 801266e:	0018      	movs	r0, r3
 8012670:	f7f0 f934 	bl	80028dc <app_debug_rtt_raw>
 8012674:	2310      	movs	r3, #16
 8012676:	425b      	negs	r3, r3
 8012678:	e034      	b.n	80126e4 <udp_sendto_chksum+0xa4>
  LWIP_ERROR("udp_sendto: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 801267a:	687b      	ldr	r3, [r7, #4]
 801267c:	2b00      	cmp	r3, #0
 801267e:	d106      	bne.n	801268e <udp_sendto_chksum+0x4e>
 8012680:	4b1c      	ldr	r3, [pc, #112]	; (80126f4 <udp_sendto_chksum+0xb4>)
 8012682:	0018      	movs	r0, r3
 8012684:	f7f0 f92a 	bl	80028dc <app_debug_rtt_raw>
 8012688:	2310      	movs	r3, #16
 801268a:	425b      	negs	r3, r3
 801268c:	e02a      	b.n	80126e4 <udp_sendto_chksum+0xa4>
    return ERR_VAL;
  }

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send\n"));

  if (pcb->netif_idx != NETIF_NO_INDEX) {
 801268e:	68fb      	ldr	r3, [r7, #12]
 8012690:	7a1b      	ldrb	r3, [r3, #8]
 8012692:	2b00      	cmp	r3, #0
 8012694:	d007      	beq.n	80126a6 <udp_sendto_chksum+0x66>
    netif = netif_get_by_index(pcb->netif_idx);
 8012696:	68fb      	ldr	r3, [r7, #12]
 8012698:	7a1b      	ldrb	r3, [r3, #8]
 801269a:	0018      	movs	r0, r3
 801269c:	f7f6 fea2 	bl	80093e4 <netif_get_by_index>
 80126a0:	0003      	movs	r3, r0
 80126a2:	617b      	str	r3, [r7, #20]
 80126a4:	e005      	b.n	80126b2 <udp_sendto_chksum+0x72>

    if (netif == NULL)
#endif /* LWIP_MULTICAST_TX_OPTIONS */
    {
      /* find the outgoing network interface for this packet */
      netif = ip_route(&pcb->local_ip, dst_ip);
 80126a6:	687b      	ldr	r3, [r7, #4]
 80126a8:	0018      	movs	r0, r3
 80126aa:	f000 fe19 	bl	80132e0 <ip4_route>
 80126ae:	0003      	movs	r3, r0
 80126b0:	617b      	str	r3, [r7, #20]
    }
  }

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
 80126b2:	697b      	ldr	r3, [r7, #20]
 80126b4:	2b00      	cmp	r3, #0
 80126b6:	d102      	bne.n	80126be <udp_sendto_chksum+0x7e>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to "));
    ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, dst_ip);
    LWIP_DEBUGF(UDP_DEBUG, ("\n"));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
 80126b8:	2304      	movs	r3, #4
 80126ba:	425b      	negs	r3, r3
 80126bc:	e012      	b.n	80126e4 <udp_sendto_chksum+0xa4>
  }
#if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
  return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum);
 80126be:	1cbb      	adds	r3, r7, #2
 80126c0:	881c      	ldrh	r4, [r3, #0]
 80126c2:	687a      	ldr	r2, [r7, #4]
 80126c4:	68b9      	ldr	r1, [r7, #8]
 80126c6:	68f8      	ldr	r0, [r7, #12]
 80126c8:	232c      	movs	r3, #44	; 0x2c
 80126ca:	18fb      	adds	r3, r7, r3
 80126cc:	881b      	ldrh	r3, [r3, #0]
 80126ce:	9302      	str	r3, [sp, #8]
 80126d0:	2328      	movs	r3, #40	; 0x28
 80126d2:	18fb      	adds	r3, r7, r3
 80126d4:	781b      	ldrb	r3, [r3, #0]
 80126d6:	9301      	str	r3, [sp, #4]
 80126d8:	697b      	ldr	r3, [r7, #20]
 80126da:	9300      	str	r3, [sp, #0]
 80126dc:	0023      	movs	r3, r4
 80126de:	f000 f80b 	bl	80126f8 <udp_sendto_if_chksum>
 80126e2:	0003      	movs	r3, r0
#else /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
}
 80126e4:	0018      	movs	r0, r3
 80126e6:	46bd      	mov	sp, r7
 80126e8:	b007      	add	sp, #28
 80126ea:	bd90      	pop	{r4, r7, pc}
 80126ec:	080211b8 	.word	0x080211b8
 80126f0:	080211d0 	.word	0x080211d0
 80126f4:	080211ec 	.word	0x080211ec

080126f8 <udp_sendto_if_chksum>:
/** Same as udp_sendto_if(), but with checksum */
err_t
udp_sendto_if_chksum(struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip,
                     u16_t dst_port, struct netif *netif, u8_t have_chksum,
                     u16_t chksum)
{
 80126f8:	b590      	push	{r4, r7, lr}
 80126fa:	b08b      	sub	sp, #44	; 0x2c
 80126fc:	af04      	add	r7, sp, #16
 80126fe:	60f8      	str	r0, [r7, #12]
 8012700:	60b9      	str	r1, [r7, #8]
 8012702:	607a      	str	r2, [r7, #4]
 8012704:	001a      	movs	r2, r3
 8012706:	1cbb      	adds	r3, r7, #2
 8012708:	801a      	strh	r2, [r3, #0]
#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
  const ip_addr_t *src_ip;

  LWIP_ERROR("udp_sendto_if: invalid pcb", pcb != NULL, return ERR_ARG);
 801270a:	68fb      	ldr	r3, [r7, #12]
 801270c:	2b00      	cmp	r3, #0
 801270e:	d106      	bne.n	801271e <udp_sendto_if_chksum+0x26>
 8012710:	4b2d      	ldr	r3, [pc, #180]	; (80127c8 <udp_sendto_if_chksum+0xd0>)
 8012712:	0018      	movs	r0, r3
 8012714:	f7f0 f8e2 	bl	80028dc <app_debug_rtt_raw>
 8012718:	2310      	movs	r3, #16
 801271a:	425b      	negs	r3, r3
 801271c:	e04f      	b.n	80127be <udp_sendto_if_chksum+0xc6>
  LWIP_ERROR("udp_sendto_if: invalid pbuf", p != NULL, return ERR_ARG);
 801271e:	68bb      	ldr	r3, [r7, #8]
 8012720:	2b00      	cmp	r3, #0
 8012722:	d106      	bne.n	8012732 <udp_sendto_if_chksum+0x3a>
 8012724:	4b29      	ldr	r3, [pc, #164]	; (80127cc <udp_sendto_if_chksum+0xd4>)
 8012726:	0018      	movs	r0, r3
 8012728:	f7f0 f8d8 	bl	80028dc <app_debug_rtt_raw>
 801272c:	2310      	movs	r3, #16
 801272e:	425b      	negs	r3, r3
 8012730:	e045      	b.n	80127be <udp_sendto_if_chksum+0xc6>
  LWIP_ERROR("udp_sendto_if: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 8012732:	687b      	ldr	r3, [r7, #4]
 8012734:	2b00      	cmp	r3, #0
 8012736:	d106      	bne.n	8012746 <udp_sendto_if_chksum+0x4e>
 8012738:	4b25      	ldr	r3, [pc, #148]	; (80127d0 <udp_sendto_if_chksum+0xd8>)
 801273a:	0018      	movs	r0, r3
 801273c:	f7f0 f8ce 	bl	80028dc <app_debug_rtt_raw>
 8012740:	2310      	movs	r3, #16
 8012742:	425b      	negs	r3, r3
 8012744:	e03b      	b.n	80127be <udp_sendto_if_chksum+0xc6>
  LWIP_ERROR("udp_sendto_if: invalid netif", netif != NULL, return ERR_ARG);
 8012746:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012748:	2b00      	cmp	r3, #0
 801274a:	d106      	bne.n	801275a <udp_sendto_if_chksum+0x62>
 801274c:	4b21      	ldr	r3, [pc, #132]	; (80127d4 <udp_sendto_if_chksum+0xdc>)
 801274e:	0018      	movs	r0, r3
 8012750:	f7f0 f8c4 	bl	80028dc <app_debug_rtt_raw>
 8012754:	2310      	movs	r3, #16
 8012756:	425b      	negs	r3, r3
 8012758:	e031      	b.n	80127be <udp_sendto_if_chksum+0xc6>
#endif /* LWIP_IPV6 */
#if LWIP_IPV4 && LWIP_IPV6
  else
#endif /* LWIP_IPV4 && LWIP_IPV6 */
#if LWIP_IPV4
    if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 801275a:	68fb      	ldr	r3, [r7, #12]
 801275c:	2b00      	cmp	r3, #0
 801275e:	d009      	beq.n	8012774 <udp_sendto_if_chksum+0x7c>
 8012760:	68fb      	ldr	r3, [r7, #12]
 8012762:	681b      	ldr	r3, [r3, #0]
 8012764:	2b00      	cmp	r3, #0
 8012766:	d005      	beq.n	8012774 <udp_sendto_if_chksum+0x7c>
        ip4_addr_ismulticast(ip_2_ip4(&pcb->local_ip))) {
 8012768:	68fb      	ldr	r3, [r7, #12]
 801276a:	681b      	ldr	r3, [r3, #0]
 801276c:	22f0      	movs	r2, #240	; 0xf0
 801276e:	4013      	ands	r3, r2
    if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 8012770:	2be0      	cmp	r3, #224	; 0xe0
 8012772:	d103      	bne.n	801277c <udp_sendto_if_chksum+0x84>
      /* if the local_ip is any or multicast
       * use the outgoing network interface IP address as source address */
      src_ip = netif_ip_addr4(netif);
 8012774:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012776:	3304      	adds	r3, #4
 8012778:	617b      	str	r3, [r7, #20]
 801277a:	e00b      	b.n	8012794 <udp_sendto_if_chksum+0x9c>
    } else {
      /* check if UDP PCB local IP address is correct
       * this could be an old address if netif->ip_addr has changed */
      if (!ip4_addr_cmp(ip_2_ip4(&(pcb->local_ip)), netif_ip4_addr(netif))) {
 801277c:	68fb      	ldr	r3, [r7, #12]
 801277e:	681a      	ldr	r2, [r3, #0]
 8012780:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012782:	3304      	adds	r3, #4
 8012784:	681b      	ldr	r3, [r3, #0]
 8012786:	429a      	cmp	r2, r3
 8012788:	d002      	beq.n	8012790 <udp_sendto_if_chksum+0x98>
        /* local_ip doesn't match, drop the packet */
        return ERR_RTE;
 801278a:	2304      	movs	r3, #4
 801278c:	425b      	negs	r3, r3
 801278e:	e016      	b.n	80127be <udp_sendto_if_chksum+0xc6>
      }
      /* use UDP PCB local IP address as source address */
      src_ip = &pcb->local_ip;
 8012790:	68fb      	ldr	r3, [r7, #12]
 8012792:	617b      	str	r3, [r7, #20]
    }
#endif /* LWIP_IPV4 */
#if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
  return udp_sendto_if_src_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum, src_ip);
 8012794:	1cbb      	adds	r3, r7, #2
 8012796:	881c      	ldrh	r4, [r3, #0]
 8012798:	687a      	ldr	r2, [r7, #4]
 801279a:	68b9      	ldr	r1, [r7, #8]
 801279c:	68f8      	ldr	r0, [r7, #12]
 801279e:	697b      	ldr	r3, [r7, #20]
 80127a0:	9303      	str	r3, [sp, #12]
 80127a2:	2330      	movs	r3, #48	; 0x30
 80127a4:	18fb      	adds	r3, r7, r3
 80127a6:	881b      	ldrh	r3, [r3, #0]
 80127a8:	9302      	str	r3, [sp, #8]
 80127aa:	232c      	movs	r3, #44	; 0x2c
 80127ac:	18fb      	adds	r3, r7, r3
 80127ae:	781b      	ldrb	r3, [r3, #0]
 80127b0:	9301      	str	r3, [sp, #4]
 80127b2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80127b4:	9300      	str	r3, [sp, #0]
 80127b6:	0023      	movs	r3, r4
 80127b8:	f000 f80e 	bl	80127d8 <udp_sendto_if_src_chksum>
 80127bc:	0003      	movs	r3, r0
#else /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
  return udp_sendto_if_src(pcb, p, dst_ip, dst_port, netif, src_ip);
#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
}
 80127be:	0018      	movs	r0, r3
 80127c0:	46bd      	mov	sp, r7
 80127c2:	b007      	add	sp, #28
 80127c4:	bd90      	pop	{r4, r7, pc}
 80127c6:	46c0      	nop			; (mov r8, r8)
 80127c8:	08021208 	.word	0x08021208
 80127cc:	08021224 	.word	0x08021224
 80127d0:	08021240 	.word	0x08021240
 80127d4:	08021260 	.word	0x08021260

080127d8 <udp_sendto_if_src_chksum>:
/** Same as udp_sendto_if_src(), but with checksum */
err_t
udp_sendto_if_src_chksum(struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip,
                         u16_t dst_port, struct netif *netif, u8_t have_chksum,
                         u16_t chksum, const ip_addr_t *src_ip)
{
 80127d8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80127da:	b08f      	sub	sp, #60	; 0x3c
 80127dc:	af04      	add	r7, sp, #16
 80127de:	60f8      	str	r0, [r7, #12]
 80127e0:	60b9      	str	r1, [r7, #8]
 80127e2:	607a      	str	r2, [r7, #4]
 80127e4:	001a      	movs	r2, r3
 80127e6:	1cbb      	adds	r3, r7, #2
 80127e8:	801a      	strh	r2, [r3, #0]
  u8_t ip_proto;
  u8_t ttl;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_sendto_if_src: invalid pcb", pcb != NULL, return ERR_ARG);
 80127ea:	68fb      	ldr	r3, [r7, #12]
 80127ec:	2b00      	cmp	r3, #0
 80127ee:	d106      	bne.n	80127fe <udp_sendto_if_src_chksum+0x26>
 80127f0:	4bb4      	ldr	r3, [pc, #720]	; (8012ac4 <udp_sendto_if_src_chksum+0x2ec>)
 80127f2:	0018      	movs	r0, r3
 80127f4:	f7f0 f872 	bl	80028dc <app_debug_rtt_raw>
 80127f8:	2310      	movs	r3, #16
 80127fa:	425b      	negs	r3, r3
 80127fc:	e15d      	b.n	8012aba <udp_sendto_if_src_chksum+0x2e2>
  LWIP_ERROR("udp_sendto_if_src: invalid pbuf", p != NULL, return ERR_ARG);
 80127fe:	68bb      	ldr	r3, [r7, #8]
 8012800:	2b00      	cmp	r3, #0
 8012802:	d106      	bne.n	8012812 <udp_sendto_if_src_chksum+0x3a>
 8012804:	4bb0      	ldr	r3, [pc, #704]	; (8012ac8 <udp_sendto_if_src_chksum+0x2f0>)
 8012806:	0018      	movs	r0, r3
 8012808:	f7f0 f868 	bl	80028dc <app_debug_rtt_raw>
 801280c:	2310      	movs	r3, #16
 801280e:	425b      	negs	r3, r3
 8012810:	e153      	b.n	8012aba <udp_sendto_if_src_chksum+0x2e2>
  LWIP_ERROR("udp_sendto_if_src: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 8012812:	687b      	ldr	r3, [r7, #4]
 8012814:	2b00      	cmp	r3, #0
 8012816:	d106      	bne.n	8012826 <udp_sendto_if_src_chksum+0x4e>
 8012818:	4bac      	ldr	r3, [pc, #688]	; (8012acc <udp_sendto_if_src_chksum+0x2f4>)
 801281a:	0018      	movs	r0, r3
 801281c:	f7f0 f85e 	bl	80028dc <app_debug_rtt_raw>
 8012820:	2310      	movs	r3, #16
 8012822:	425b      	negs	r3, r3
 8012824:	e149      	b.n	8012aba <udp_sendto_if_src_chksum+0x2e2>
  LWIP_ERROR("udp_sendto_if_src: invalid src_ip", src_ip != NULL, return ERR_ARG);
 8012826:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8012828:	2b00      	cmp	r3, #0
 801282a:	d106      	bne.n	801283a <udp_sendto_if_src_chksum+0x62>
 801282c:	4ba8      	ldr	r3, [pc, #672]	; (8012ad0 <udp_sendto_if_src_chksum+0x2f8>)
 801282e:	0018      	movs	r0, r3
 8012830:	f7f0 f854 	bl	80028dc <app_debug_rtt_raw>
 8012834:	2310      	movs	r3, #16
 8012836:	425b      	negs	r3, r3
 8012838:	e13f      	b.n	8012aba <udp_sendto_if_src_chksum+0x2e2>
  LWIP_ERROR("udp_sendto_if_src: invalid netif", netif != NULL, return ERR_ARG);
 801283a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801283c:	2b00      	cmp	r3, #0
 801283e:	d106      	bne.n	801284e <udp_sendto_if_src_chksum+0x76>
 8012840:	4ba4      	ldr	r3, [pc, #656]	; (8012ad4 <udp_sendto_if_src_chksum+0x2fc>)
 8012842:	0018      	movs	r0, r3
 8012844:	f7f0 f84a 	bl	80028dc <app_debug_rtt_raw>
 8012848:	2310      	movs	r3, #16
 801284a:	425b      	negs	r3, r3
 801284c:	e135      	b.n	8012aba <udp_sendto_if_src_chksum+0x2e2>
    return ERR_VAL;
  }
#endif /* LWIP_IPV4 && IP_SOF_BROADCAST */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
 801284e:	68fb      	ldr	r3, [r7, #12]
 8012850:	8adb      	ldrh	r3, [r3, #22]
 8012852:	2b00      	cmp	r3, #0
 8012854:	d113      	bne.n	801287e <udp_sendto_if_src_chksum+0xa6>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 8012856:	68f9      	ldr	r1, [r7, #12]
 8012858:	68fb      	ldr	r3, [r7, #12]
 801285a:	8ada      	ldrh	r2, [r3, #22]
 801285c:	251f      	movs	r5, #31
 801285e:	197c      	adds	r4, r7, r5
 8012860:	68fb      	ldr	r3, [r7, #12]
 8012862:	0018      	movs	r0, r3
 8012864:	f000 f942 	bl	8012aec <udp_bind>
 8012868:	0003      	movs	r3, r0
 801286a:	7023      	strb	r3, [r4, #0]
    if (err != ERR_OK) {
 801286c:	197b      	adds	r3, r7, r5
 801286e:	781b      	ldrb	r3, [r3, #0]
 8012870:	b25b      	sxtb	r3, r3
 8012872:	2b00      	cmp	r3, #0
 8012874:	d003      	beq.n	801287e <udp_sendto_if_src_chksum+0xa6>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind failed\n"));
      return err;
 8012876:	197b      	adds	r3, r7, r5
 8012878:	781b      	ldrb	r3, [r3, #0]
 801287a:	b25b      	sxtb	r3, r3
 801287c:	e11d      	b.n	8012aba <udp_sendto_if_src_chksum+0x2e2>
    }
  }

  /* packet too large to add a UDP header without causing an overflow? */
  if ((u16_t)(p->tot_len + UDP_HLEN) < p->tot_len) {
 801287e:	68bb      	ldr	r3, [r7, #8]
 8012880:	891b      	ldrh	r3, [r3, #8]
 8012882:	4a95      	ldr	r2, [pc, #596]	; (8012ad8 <udp_sendto_if_src_chksum+0x300>)
 8012884:	4293      	cmp	r3, r2
 8012886:	d902      	bls.n	801288e <udp_sendto_if_src_chksum+0xb6>
    return ERR_MEM;
 8012888:	2301      	movs	r3, #1
 801288a:	425b      	negs	r3, r3
 801288c:	e115      	b.n	8012aba <udp_sendto_if_src_chksum+0x2e2>
  }
  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_add_header(p, UDP_HLEN)) {
 801288e:	68bb      	ldr	r3, [r7, #8]
 8012890:	2108      	movs	r1, #8
 8012892:	0018      	movs	r0, r3
 8012894:	f7f7 f8b4 	bl	8009a00 <pbuf_add_header>
 8012898:	1e03      	subs	r3, r0, #0
 801289a:	d019      	beq.n	80128d0 <udp_sendto_if_src_chksum+0xf8>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
 801289c:	23a0      	movs	r3, #160	; 0xa0
 801289e:	009b      	lsls	r3, r3, #2
 80128a0:	001a      	movs	r2, r3
 80128a2:	2108      	movs	r1, #8
 80128a4:	2024      	movs	r0, #36	; 0x24
 80128a6:	f7f6 fe1b 	bl	80094e0 <pbuf_alloc>
 80128aa:	0003      	movs	r3, r0
 80128ac:	623b      	str	r3, [r7, #32]
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
 80128ae:	6a3b      	ldr	r3, [r7, #32]
 80128b0:	2b00      	cmp	r3, #0
 80128b2:	d102      	bne.n	80128ba <udp_sendto_if_src_chksum+0xe2>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
 80128b4:	2301      	movs	r3, #1
 80128b6:	425b      	negs	r3, r3
 80128b8:	e0ff      	b.n	8012aba <udp_sendto_if_src_chksum+0x2e2>
    }
    if (p->tot_len != 0) {
 80128ba:	68bb      	ldr	r3, [r7, #8]
 80128bc:	891b      	ldrh	r3, [r3, #8]
 80128be:	2b00      	cmp	r3, #0
 80128c0:	d008      	beq.n	80128d4 <udp_sendto_if_src_chksum+0xfc>
      /* chain header q in front of given pbuf p (only if p contains data) */
      pbuf_chain(q, p);
 80128c2:	68ba      	ldr	r2, [r7, #8]
 80128c4:	6a3b      	ldr	r3, [r7, #32]
 80128c6:	0011      	movs	r1, r2
 80128c8:	0018      	movs	r0, r3
 80128ca:	f7f7 fab5 	bl	8009e38 <pbuf_chain>
 80128ce:	e001      	b.n	80128d4 <udp_sendto_if_src_chksum+0xfc>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
 80128d0:	68bb      	ldr	r3, [r7, #8]
 80128d2:	623b      	str	r3, [r7, #32]
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
 80128d4:	6a3b      	ldr	r3, [r7, #32]
 80128d6:	895b      	ldrh	r3, [r3, #10]
 80128d8:	2b07      	cmp	r3, #7
 80128da:	d805      	bhi.n	80128e8 <udp_sendto_if_src_chksum+0x110>
 80128dc:	4b7f      	ldr	r3, [pc, #508]	; (8012adc <udp_sendto_if_src_chksum+0x304>)
 80128de:	4a80      	ldr	r2, [pc, #512]	; (8012ae0 <udp_sendto_if_src_chksum+0x308>)
 80128e0:	4980      	ldr	r1, [pc, #512]	; (8012ae4 <udp_sendto_if_src_chksum+0x30c>)
 80128e2:	4881      	ldr	r0, [pc, #516]	; (8012ae8 <udp_sendto_if_src_chksum+0x310>)
 80128e4:	f7ef fffa 	bl	80028dc <app_debug_rtt_raw>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = (struct udp_hdr *)q->payload;
 80128e8:	6a3b      	ldr	r3, [r7, #32]
 80128ea:	685b      	ldr	r3, [r3, #4]
 80128ec:	61bb      	str	r3, [r7, #24]
  udphdr->src = lwip_htons(pcb->local_port);
 80128ee:	68fb      	ldr	r3, [r7, #12]
 80128f0:	8adb      	ldrh	r3, [r3, #22]
 80128f2:	0018      	movs	r0, r3
 80128f4:	f7f4 f988 	bl	8006c08 <lwip_htons>
 80128f8:	0003      	movs	r3, r0
 80128fa:	001a      	movs	r2, r3
 80128fc:	69bb      	ldr	r3, [r7, #24]
 80128fe:	21ff      	movs	r1, #255	; 0xff
 8012900:	4011      	ands	r1, r2
 8012902:	000c      	movs	r4, r1
 8012904:	7819      	ldrb	r1, [r3, #0]
 8012906:	2000      	movs	r0, #0
 8012908:	4001      	ands	r1, r0
 801290a:	1c08      	adds	r0, r1, #0
 801290c:	1c21      	adds	r1, r4, #0
 801290e:	4301      	orrs	r1, r0
 8012910:	7019      	strb	r1, [r3, #0]
 8012912:	0a12      	lsrs	r2, r2, #8
 8012914:	b290      	uxth	r0, r2
 8012916:	785a      	ldrb	r2, [r3, #1]
 8012918:	2100      	movs	r1, #0
 801291a:	400a      	ands	r2, r1
 801291c:	1c11      	adds	r1, r2, #0
 801291e:	1c02      	adds	r2, r0, #0
 8012920:	430a      	orrs	r2, r1
 8012922:	705a      	strb	r2, [r3, #1]
  udphdr->dest = lwip_htons(dst_port);
 8012924:	1cbb      	adds	r3, r7, #2
 8012926:	881b      	ldrh	r3, [r3, #0]
 8012928:	0018      	movs	r0, r3
 801292a:	f7f4 f96d 	bl	8006c08 <lwip_htons>
 801292e:	0003      	movs	r3, r0
 8012930:	001a      	movs	r2, r3
 8012932:	69bb      	ldr	r3, [r7, #24]
 8012934:	21ff      	movs	r1, #255	; 0xff
 8012936:	4011      	ands	r1, r2
 8012938:	000c      	movs	r4, r1
 801293a:	7899      	ldrb	r1, [r3, #2]
 801293c:	2000      	movs	r0, #0
 801293e:	4001      	ands	r1, r0
 8012940:	1c08      	adds	r0, r1, #0
 8012942:	1c21      	adds	r1, r4, #0
 8012944:	4301      	orrs	r1, r0
 8012946:	7099      	strb	r1, [r3, #2]
 8012948:	0a12      	lsrs	r2, r2, #8
 801294a:	b290      	uxth	r0, r2
 801294c:	78da      	ldrb	r2, [r3, #3]
 801294e:	2100      	movs	r1, #0
 8012950:	400a      	ands	r2, r1
 8012952:	1c11      	adds	r1, r2, #0
 8012954:	1c02      	adds	r2, r0, #0
 8012956:	430a      	orrs	r2, r1
 8012958:	70da      	strb	r2, [r3, #3]
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000;
 801295a:	69bb      	ldr	r3, [r7, #24]
 801295c:	799a      	ldrb	r2, [r3, #6]
 801295e:	2100      	movs	r1, #0
 8012960:	400a      	ands	r2, r1
 8012962:	719a      	strb	r2, [r3, #6]
 8012964:	79da      	ldrb	r2, [r3, #7]
 8012966:	2100      	movs	r1, #0
 8012968:	400a      	ands	r2, r1
 801296a:	71da      	strb	r2, [r3, #7]
    ip_proto = IP_PROTO_UDPLITE;
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = lwip_htons(q->tot_len);
 801296c:	6a3b      	ldr	r3, [r7, #32]
 801296e:	891b      	ldrh	r3, [r3, #8]
 8012970:	0018      	movs	r0, r3
 8012972:	f7f4 f949 	bl	8006c08 <lwip_htons>
 8012976:	0003      	movs	r3, r0
 8012978:	001a      	movs	r2, r3
 801297a:	69bb      	ldr	r3, [r7, #24]
 801297c:	21ff      	movs	r1, #255	; 0xff
 801297e:	4011      	ands	r1, r2
 8012980:	000c      	movs	r4, r1
 8012982:	7919      	ldrb	r1, [r3, #4]
 8012984:	2000      	movs	r0, #0
 8012986:	4001      	ands	r1, r0
 8012988:	1c08      	adds	r0, r1, #0
 801298a:	1c21      	adds	r1, r4, #0
 801298c:	4301      	orrs	r1, r0
 801298e:	7119      	strb	r1, [r3, #4]
 8012990:	0a12      	lsrs	r2, r2, #8
 8012992:	b290      	uxth	r0, r2
 8012994:	795a      	ldrb	r2, [r3, #5]
 8012996:	2100      	movs	r1, #0
 8012998:	400a      	ands	r2, r1
 801299a:	1c11      	adds	r1, r2, #0
 801299c:	1c02      	adds	r2, r0, #0
 801299e:	430a      	orrs	r2, r1
 80129a0:	715a      	strb	r2, [r3, #5]
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_UDP) {
      /* Checksum is mandatory over IPv6. */
      if (IP_IS_V6(dst_ip) || (pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
 80129a2:	68fb      	ldr	r3, [r7, #12]
 80129a4:	7d1b      	ldrb	r3, [r3, #20]
 80129a6:	001a      	movs	r2, r3
 80129a8:	2301      	movs	r3, #1
 80129aa:	4013      	ands	r3, r2
 80129ac:	d150      	bne.n	8012a50 <udp_sendto_if_src_chksum+0x278>
        u16_t udpchksum;
#if LWIP_CHECKSUM_ON_COPY
        if (have_chksum) {
 80129ae:	2344      	movs	r3, #68	; 0x44
 80129b0:	18fb      	adds	r3, r7, r3
 80129b2:	781b      	ldrb	r3, [r3, #0]
 80129b4:	2b00      	cmp	r3, #0
 80129b6:	d021      	beq.n	80129fc <udp_sendto_if_src_chksum+0x224>
          u32_t acc;
          udpchksum = ip_chksum_pseudo_partial(q, IP_PROTO_UDP,
 80129b8:	6a3b      	ldr	r3, [r7, #32]
 80129ba:	891a      	ldrh	r2, [r3, #8]
 80129bc:	2526      	movs	r5, #38	; 0x26
 80129be:	197c      	adds	r4, r7, r5
 80129c0:	6a38      	ldr	r0, [r7, #32]
 80129c2:	687b      	ldr	r3, [r7, #4]
 80129c4:	9301      	str	r3, [sp, #4]
 80129c6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80129c8:	9300      	str	r3, [sp, #0]
 80129ca:	2308      	movs	r3, #8
 80129cc:	2111      	movs	r1, #17
 80129ce:	f7f5 fcbc 	bl	800834a <ip_chksum_pseudo_partial>
 80129d2:	0003      	movs	r3, r0
 80129d4:	8023      	strh	r3, [r4, #0]
                                               q->tot_len, UDP_HLEN, src_ip, dst_ip);
          acc = udpchksum + (u16_t)~(chksum);
 80129d6:	0028      	movs	r0, r5
 80129d8:	183b      	adds	r3, r7, r0
 80129da:	881b      	ldrh	r3, [r3, #0]
 80129dc:	2248      	movs	r2, #72	; 0x48
 80129de:	18ba      	adds	r2, r7, r2
 80129e0:	8812      	ldrh	r2, [r2, #0]
 80129e2:	43d2      	mvns	r2, r2
 80129e4:	b292      	uxth	r2, r2
 80129e6:	189b      	adds	r3, r3, r2
 80129e8:	617b      	str	r3, [r7, #20]
          udpchksum = FOLD_U32T(acc);
 80129ea:	697b      	ldr	r3, [r7, #20]
 80129ec:	0c1b      	lsrs	r3, r3, #16
 80129ee:	b299      	uxth	r1, r3
 80129f0:	697b      	ldr	r3, [r7, #20]
 80129f2:	b29a      	uxth	r2, r3
 80129f4:	183b      	adds	r3, r7, r0
 80129f6:	188a      	adds	r2, r1, r2
 80129f8:	801a      	strh	r2, [r3, #0]
 80129fa:	e00d      	b.n	8012a18 <udp_sendto_if_src_chksum+0x240>
        } else
#endif /* LWIP_CHECKSUM_ON_COPY */
        {
          udpchksum = ip_chksum_pseudo(q, IP_PROTO_UDP, q->tot_len,
 80129fc:	6a3b      	ldr	r3, [r7, #32]
 80129fe:	891a      	ldrh	r2, [r3, #8]
 8012a00:	2326      	movs	r3, #38	; 0x26
 8012a02:	18fc      	adds	r4, r7, r3
 8012a04:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 8012a06:	6a38      	ldr	r0, [r7, #32]
 8012a08:	687b      	ldr	r3, [r7, #4]
 8012a0a:	9300      	str	r3, [sp, #0]
 8012a0c:	000b      	movs	r3, r1
 8012a0e:	2111      	movs	r1, #17
 8012a10:	f7f5 fb81 	bl	8008116 <ip_chksum_pseudo>
 8012a14:	0003      	movs	r3, r0
 8012a16:	8023      	strh	r3, [r4, #0]
                                       src_ip, dst_ip);
        }

        /* chksum zero must become 0xffff, as zero means 'no checksum' */
        if (udpchksum == 0x0000) {
 8012a18:	2226      	movs	r2, #38	; 0x26
 8012a1a:	18bb      	adds	r3, r7, r2
 8012a1c:	881b      	ldrh	r3, [r3, #0]
 8012a1e:	2b00      	cmp	r3, #0
 8012a20:	d103      	bne.n	8012a2a <udp_sendto_if_src_chksum+0x252>
          udpchksum = 0xffff;
 8012a22:	18bb      	adds	r3, r7, r2
 8012a24:	2201      	movs	r2, #1
 8012a26:	4252      	negs	r2, r2
 8012a28:	801a      	strh	r2, [r3, #0]
        }
        udphdr->chksum = udpchksum;
 8012a2a:	69bb      	ldr	r3, [r7, #24]
 8012a2c:	2226      	movs	r2, #38	; 0x26
 8012a2e:	18ba      	adds	r2, r7, r2
 8012a30:	7814      	ldrb	r4, [r2, #0]
 8012a32:	7999      	ldrb	r1, [r3, #6]
 8012a34:	2000      	movs	r0, #0
 8012a36:	4001      	ands	r1, r0
 8012a38:	1c08      	adds	r0, r1, #0
 8012a3a:	1c21      	adds	r1, r4, #0
 8012a3c:	4301      	orrs	r1, r0
 8012a3e:	7199      	strb	r1, [r3, #6]
 8012a40:	7850      	ldrb	r0, [r2, #1]
 8012a42:	79da      	ldrb	r2, [r3, #7]
 8012a44:	2100      	movs	r1, #0
 8012a46:	400a      	ands	r2, r1
 8012a48:	1c11      	adds	r1, r2, #0
 8012a4a:	1c02      	adds	r2, r0, #0
 8012a4c:	430a      	orrs	r2, r1
 8012a4e:	71da      	strb	r2, [r3, #7]
      }
    }
#endif /* CHECKSUM_GEN_UDP */
    ip_proto = IP_PROTO_UDP;
 8012a50:	2313      	movs	r3, #19
 8012a52:	18fb      	adds	r3, r7, r3
 8012a54:	2211      	movs	r2, #17
 8012a56:	701a      	strb	r2, [r3, #0]

  /* Determine TTL to use */
#if LWIP_MULTICAST_TX_OPTIONS
  ttl = (ip_addr_ismulticast(dst_ip) ? udp_get_multicast_ttl(pcb) : pcb->ttl);
#else /* LWIP_MULTICAST_TX_OPTIONS */
  ttl = pcb->ttl;
 8012a58:	2112      	movs	r1, #18
 8012a5a:	187b      	adds	r3, r7, r1
 8012a5c:	68fa      	ldr	r2, [r7, #12]
 8012a5e:	7ad2      	ldrb	r2, [r2, #11]
 8012a60:	701a      	strb	r2, [r3, #0]
#endif /* LWIP_MULTICAST_TX_OPTIONS */

  LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04"X16_F"\n", udphdr->chksum));
  LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,0x%02"X16_F",)\n", (u16_t)ip_proto));
  /* output to IP */
  NETIF_SET_HINTS(netif, &(pcb->netif_hints));
 8012a62:	68fb      	ldr	r3, [r7, #12]
 8012a64:	330c      	adds	r3, #12
 8012a66:	001a      	movs	r2, r3
 8012a68:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8012a6a:	639a      	str	r2, [r3, #56]	; 0x38
  err = ip_output_if_src(q, src_ip, dst_ip, ttl, pcb->tos, ip_proto, netif);
 8012a6c:	68fb      	ldr	r3, [r7, #12]
 8012a6e:	7a9b      	ldrb	r3, [r3, #10]
 8012a70:	201f      	movs	r0, #31
 8012a72:	183c      	adds	r4, r7, r0
 8012a74:	187a      	adds	r2, r7, r1
 8012a76:	7816      	ldrb	r6, [r2, #0]
 8012a78:	687d      	ldr	r5, [r7, #4]
 8012a7a:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 8012a7c:	6a38      	ldr	r0, [r7, #32]
 8012a7e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8012a80:	9202      	str	r2, [sp, #8]
 8012a82:	2213      	movs	r2, #19
 8012a84:	18ba      	adds	r2, r7, r2
 8012a86:	7812      	ldrb	r2, [r2, #0]
 8012a88:	9201      	str	r2, [sp, #4]
 8012a8a:	9300      	str	r3, [sp, #0]
 8012a8c:	0033      	movs	r3, r6
 8012a8e:	002a      	movs	r2, r5
 8012a90:	f000 fe58 	bl	8013744 <ip4_output_if_src>
 8012a94:	0003      	movs	r3, r0
 8012a96:	7023      	strb	r3, [r4, #0]
  NETIF_RESET_HINTS(netif);
 8012a98:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8012a9a:	2200      	movs	r2, #0
 8012a9c:	639a      	str	r2, [r3, #56]	; 0x38

  /* @todo: must this be increased even if error occurred? */
  MIB2_STATS_INC(mib2.udpoutdatagrams);

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
 8012a9e:	6a3a      	ldr	r2, [r7, #32]
 8012aa0:	68bb      	ldr	r3, [r7, #8]
 8012aa2:	429a      	cmp	r2, r3
 8012aa4:	d005      	beq.n	8012ab2 <udp_sendto_if_src_chksum+0x2da>
    /* free the header pbuf */
    pbuf_free(q);
 8012aa6:	6a3b      	ldr	r3, [r7, #32]
 8012aa8:	0018      	movs	r0, r3
 8012aaa:	f7f7 f891 	bl	8009bd0 <pbuf_free>
    q = NULL;
 8012aae:	2300      	movs	r3, #0
 8012ab0:	623b      	str	r3, [r7, #32]
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
 8012ab2:	231f      	movs	r3, #31
 8012ab4:	18fb      	adds	r3, r7, r3
 8012ab6:	781b      	ldrb	r3, [r3, #0]
 8012ab8:	b25b      	sxtb	r3, r3
}
 8012aba:	0018      	movs	r0, r3
 8012abc:	46bd      	mov	sp, r7
 8012abe:	b00b      	add	sp, #44	; 0x2c
 8012ac0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8012ac2:	46c0      	nop			; (mov r8, r8)
 8012ac4:	08021280 	.word	0x08021280
 8012ac8:	080212a0 	.word	0x080212a0
 8012acc:	080212c0 	.word	0x080212c0
 8012ad0:	080212e4 	.word	0x080212e4
 8012ad4:	08021308 	.word	0x08021308
 8012ad8:	0000fff7 	.word	0x0000fff7
 8012adc:	08021058 	.word	0x08021058
 8012ae0:	0000030d 	.word	0x0000030d
 8012ae4:	0802132c 	.word	0x0802132c
 8012ae8:	080210a4 	.word	0x080210a4

08012aec <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
{
 8012aec:	b590      	push	{r4, r7, lr}
 8012aee:	b087      	sub	sp, #28
 8012af0:	af00      	add	r7, sp, #0
 8012af2:	60f8      	str	r0, [r7, #12]
 8012af4:	60b9      	str	r1, [r7, #8]
 8012af6:	1dbb      	adds	r3, r7, #6
 8012af8:	801a      	strh	r2, [r3, #0]

  LWIP_ASSERT_CORE_LOCKED();

#if LWIP_IPV4
  /* Don't propagate NULL pointer (IPv4 ANY) to subsequent functions */
  if (ipaddr == NULL) {
 8012afa:	68bb      	ldr	r3, [r7, #8]
 8012afc:	2b00      	cmp	r3, #0
 8012afe:	d101      	bne.n	8012b04 <udp_bind+0x18>
    ipaddr = IP4_ADDR_ANY;
 8012b00:	4b43      	ldr	r3, [pc, #268]	; (8012c10 <udp_bind+0x124>)
 8012b02:	60bb      	str	r3, [r7, #8]
  }
#else /* LWIP_IPV4 */
  LWIP_ERROR("udp_bind: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
#endif /* LWIP_IPV4 */

  LWIP_ERROR("udp_bind: invalid pcb", pcb != NULL, return ERR_ARG);
 8012b04:	68fb      	ldr	r3, [r7, #12]
 8012b06:	2b00      	cmp	r3, #0
 8012b08:	d106      	bne.n	8012b18 <udp_bind+0x2c>
 8012b0a:	4b42      	ldr	r3, [pc, #264]	; (8012c14 <udp_bind+0x128>)
 8012b0c:	0018      	movs	r0, r3
 8012b0e:	f7ef fee5 	bl	80028dc <app_debug_rtt_raw>
 8012b12:	2310      	movs	r3, #16
 8012b14:	425b      	negs	r3, r3
 8012b16:	e077      	b.n	8012c08 <udp_bind+0x11c>

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_TRACE, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
 8012b18:	2313      	movs	r3, #19
 8012b1a:	18fb      	adds	r3, r7, r3
 8012b1c:	2200      	movs	r2, #0
 8012b1e:	701a      	strb	r2, [r3, #0]
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8012b20:	4b3d      	ldr	r3, [pc, #244]	; (8012c18 <udp_bind+0x12c>)
 8012b22:	681b      	ldr	r3, [r3, #0]
 8012b24:	617b      	str	r3, [r7, #20]
 8012b26:	e00b      	b.n	8012b40 <udp_bind+0x54>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
 8012b28:	68fa      	ldr	r2, [r7, #12]
 8012b2a:	697b      	ldr	r3, [r7, #20]
 8012b2c:	429a      	cmp	r2, r3
 8012b2e:	d104      	bne.n	8012b3a <udp_bind+0x4e>
      rebind = 1;
 8012b30:	2313      	movs	r3, #19
 8012b32:	18fb      	adds	r3, r7, r3
 8012b34:	2201      	movs	r2, #1
 8012b36:	701a      	strb	r2, [r3, #0]
      break;
 8012b38:	e005      	b.n	8012b46 <udp_bind+0x5a>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8012b3a:	697b      	ldr	r3, [r7, #20]
 8012b3c:	691b      	ldr	r3, [r3, #16]
 8012b3e:	617b      	str	r3, [r7, #20]
 8012b40:	697b      	ldr	r3, [r7, #20]
 8012b42:	2b00      	cmp	r3, #0
 8012b44:	d1f0      	bne.n	8012b28 <udp_bind+0x3c>
    ipaddr = &zoned_ipaddr;
  }
#endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */

  /* no port specified? */
  if (port == 0) {
 8012b46:	1dbb      	adds	r3, r7, #6
 8012b48:	881b      	ldrh	r3, [r3, #0]
 8012b4a:	2b00      	cmp	r3, #0
 8012b4c:	d10b      	bne.n	8012b66 <udp_bind+0x7a>
    port = udp_new_port();
 8012b4e:	1dbc      	adds	r4, r7, #6
 8012b50:	f7ff fb5a 	bl	8012208 <udp_new_port>
 8012b54:	0003      	movs	r3, r0
 8012b56:	8023      	strh	r3, [r4, #0]
    if (port == 0) {
 8012b58:	1dbb      	adds	r3, r7, #6
 8012b5a:	881b      	ldrh	r3, [r3, #0]
 8012b5c:	2b00      	cmp	r3, #0
 8012b5e:	d139      	bne.n	8012bd4 <udp_bind+0xe8>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
 8012b60:	2308      	movs	r3, #8
 8012b62:	425b      	negs	r3, r3
 8012b64:	e050      	b.n	8012c08 <udp_bind+0x11c>
    }
  } else {
    for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8012b66:	4b2c      	ldr	r3, [pc, #176]	; (8012c18 <udp_bind+0x12c>)
 8012b68:	681b      	ldr	r3, [r3, #0]
 8012b6a:	617b      	str	r3, [r7, #20]
 8012b6c:	e02f      	b.n	8012bce <udp_bind+0xe2>
      if (pcb != ipcb) {
 8012b6e:	68fa      	ldr	r2, [r7, #12]
 8012b70:	697b      	ldr	r3, [r7, #20]
 8012b72:	429a      	cmp	r2, r3
 8012b74:	d028      	beq.n	8012bc8 <udp_bind+0xdc>
        /* By default, we don't allow to bind to a port that any other udp
           PCB is already bound to, unless *all* PCBs with that port have tha
           REUSEADDR flag set. */
#if SO_REUSE
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
 8012b76:	68fb      	ldr	r3, [r7, #12]
 8012b78:	7a5b      	ldrb	r3, [r3, #9]
 8012b7a:	001a      	movs	r2, r3
 8012b7c:	2304      	movs	r3, #4
 8012b7e:	4013      	ands	r3, r2
 8012b80:	d005      	beq.n	8012b8e <udp_bind+0xa2>
            !ip_get_option(ipcb, SOF_REUSEADDR))
 8012b82:	697b      	ldr	r3, [r7, #20]
 8012b84:	7a5b      	ldrb	r3, [r3, #9]
 8012b86:	001a      	movs	r2, r3
 8012b88:	2304      	movs	r3, #4
 8012b8a:	4013      	ands	r3, r2
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
 8012b8c:	d11c      	bne.n	8012bc8 <udp_bind+0xdc>
#endif /* SO_REUSE */
        {
          /* port matches that of PCB in list and REUSEADDR not set -> reject */
          if ((ipcb->local_port == port) &&
 8012b8e:	697b      	ldr	r3, [r7, #20]
 8012b90:	8adb      	ldrh	r3, [r3, #22]
 8012b92:	1dba      	adds	r2, r7, #6
 8012b94:	8812      	ldrh	r2, [r2, #0]
 8012b96:	429a      	cmp	r2, r3
 8012b98:	d116      	bne.n	8012bc8 <udp_bind+0xdc>
              (((IP_GET_TYPE(&ipcb->local_ip) == IP_GET_TYPE(ipaddr)) &&
              /* IP address matches or any IP used? */
              (ip_addr_cmp(&ipcb->local_ip, ipaddr) ||
 8012b9a:	697b      	ldr	r3, [r7, #20]
 8012b9c:	681a      	ldr	r2, [r3, #0]
 8012b9e:	68bb      	ldr	r3, [r7, #8]
 8012ba0:	681b      	ldr	r3, [r3, #0]
          if ((ipcb->local_port == port) &&
 8012ba2:	429a      	cmp	r2, r3
 8012ba4:	d00d      	beq.n	8012bc2 <udp_bind+0xd6>
              (ip_addr_cmp(&ipcb->local_ip, ipaddr) ||
 8012ba6:	68bb      	ldr	r3, [r7, #8]
 8012ba8:	2b00      	cmp	r3, #0
 8012baa:	d00a      	beq.n	8012bc2 <udp_bind+0xd6>
              ip_addr_isany(ipaddr) ||
 8012bac:	68bb      	ldr	r3, [r7, #8]
 8012bae:	681b      	ldr	r3, [r3, #0]
 8012bb0:	2b00      	cmp	r3, #0
 8012bb2:	d006      	beq.n	8012bc2 <udp_bind+0xd6>
              ip_addr_isany(&ipcb->local_ip))) ||
 8012bb4:	697b      	ldr	r3, [r7, #20]
              (IP_GET_TYPE(&ipcb->local_ip) == IPADDR_TYPE_ANY) ||
 8012bb6:	2b00      	cmp	r3, #0
 8012bb8:	d003      	beq.n	8012bc2 <udp_bind+0xd6>
              ip_addr_isany(&ipcb->local_ip))) ||
 8012bba:	697b      	ldr	r3, [r7, #20]
 8012bbc:	681b      	ldr	r3, [r3, #0]
 8012bbe:	2b00      	cmp	r3, #0
 8012bc0:	d102      	bne.n	8012bc8 <udp_bind+0xdc>
              (IP_GET_TYPE(ipaddr) == IPADDR_TYPE_ANY))) {
            /* other PCB already binds to this local IP and port */
            LWIP_DEBUGF(UDP_DEBUG,
                        ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
            return ERR_USE;
 8012bc2:	2308      	movs	r3, #8
 8012bc4:	425b      	negs	r3, r3
 8012bc6:	e01f      	b.n	8012c08 <udp_bind+0x11c>
    for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8012bc8:	697b      	ldr	r3, [r7, #20]
 8012bca:	691b      	ldr	r3, [r3, #16]
 8012bcc:	617b      	str	r3, [r7, #20]
 8012bce:	697b      	ldr	r3, [r7, #20]
 8012bd0:	2b00      	cmp	r3, #0
 8012bd2:	d1cc      	bne.n	8012b6e <udp_bind+0x82>
        }
      }
    }
  }

  ip_addr_set_ipaddr(&pcb->local_ip, ipaddr);
 8012bd4:	68bb      	ldr	r3, [r7, #8]
 8012bd6:	2b00      	cmp	r3, #0
 8012bd8:	d002      	beq.n	8012be0 <udp_bind+0xf4>
 8012bda:	68bb      	ldr	r3, [r7, #8]
 8012bdc:	681a      	ldr	r2, [r3, #0]
 8012bde:	e000      	b.n	8012be2 <udp_bind+0xf6>
 8012be0:	2200      	movs	r2, #0
 8012be2:	68fb      	ldr	r3, [r7, #12]
 8012be4:	601a      	str	r2, [r3, #0]

  pcb->local_port = port;
 8012be6:	68fb      	ldr	r3, [r7, #12]
 8012be8:	1dba      	adds	r2, r7, #6
 8012bea:	8812      	ldrh	r2, [r2, #0]
 8012bec:	82da      	strh	r2, [r3, #22]
  mib2_udp_bind(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
 8012bee:	2313      	movs	r3, #19
 8012bf0:	18fb      	adds	r3, r7, r3
 8012bf2:	781b      	ldrb	r3, [r3, #0]
 8012bf4:	2b00      	cmp	r3, #0
 8012bf6:	d106      	bne.n	8012c06 <udp_bind+0x11a>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
 8012bf8:	4b07      	ldr	r3, [pc, #28]	; (8012c18 <udp_bind+0x12c>)
 8012bfa:	681a      	ldr	r2, [r3, #0]
 8012bfc:	68fb      	ldr	r3, [r7, #12]
 8012bfe:	611a      	str	r2, [r3, #16]
    udp_pcbs = pcb;
 8012c00:	4b05      	ldr	r3, [pc, #20]	; (8012c18 <udp_bind+0x12c>)
 8012c02:	68fa      	ldr	r2, [r7, #12]
 8012c04:	601a      	str	r2, [r3, #0]
  }
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("udp_bind: bound to "));
  ip_addr_debug_print_val(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, pcb->local_ip);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, (", port %"U16_F")\n", pcb->local_port));
  return ERR_OK;
 8012c06:	2300      	movs	r3, #0
}
 8012c08:	0018      	movs	r0, r3
 8012c0a:	46bd      	mov	sp, r7
 8012c0c:	b007      	add	sp, #28
 8012c0e:	bd90      	pop	{r4, r7, pc}
 8012c10:	0802246c 	.word	0x0802246c
 8012c14:	0802135c 	.word	0x0802135c
 8012c18:	20002eec 	.word	0x20002eec

08012c1c <udp_recv>:
 * @param recv function pointer of the callback function
 * @param recv_arg additional argument to pass to the callback function
 */
void
udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
 8012c1c:	b580      	push	{r7, lr}
 8012c1e:	b084      	sub	sp, #16
 8012c20:	af00      	add	r7, sp, #0
 8012c22:	60f8      	str	r0, [r7, #12]
 8012c24:	60b9      	str	r1, [r7, #8]
 8012c26:	607a      	str	r2, [r7, #4]
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_recv: invalid pcb", pcb != NULL, return);
 8012c28:	68fb      	ldr	r3, [r7, #12]
 8012c2a:	2b00      	cmp	r3, #0
 8012c2c:	d104      	bne.n	8012c38 <udp_recv+0x1c>
 8012c2e:	4b07      	ldr	r3, [pc, #28]	; (8012c4c <udp_recv+0x30>)
 8012c30:	0018      	movs	r0, r3
 8012c32:	f7ef fe53 	bl	80028dc <app_debug_rtt_raw>
 8012c36:	e005      	b.n	8012c44 <udp_recv+0x28>

  /* remember recv() callback and user data */
  pcb->recv = recv;
 8012c38:	68fb      	ldr	r3, [r7, #12]
 8012c3a:	68ba      	ldr	r2, [r7, #8]
 8012c3c:	61da      	str	r2, [r3, #28]
  pcb->recv_arg = recv_arg;
 8012c3e:	68fb      	ldr	r3, [r7, #12]
 8012c40:	687a      	ldr	r2, [r7, #4]
 8012c42:	621a      	str	r2, [r3, #32]
}
 8012c44:	46bd      	mov	sp, r7
 8012c46:	b004      	add	sp, #16
 8012c48:	bd80      	pop	{r7, pc}
 8012c4a:	46c0      	nop			; (mov r8, r8)
 8012c4c:	080213c8 	.word	0x080213c8

08012c50 <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
 8012c50:	b580      	push	{r7, lr}
 8012c52:	b084      	sub	sp, #16
 8012c54:	af00      	add	r7, sp, #0
 8012c56:	6078      	str	r0, [r7, #4]
  struct udp_pcb *pcb2;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_remove: invalid pcb", pcb != NULL, return);
 8012c58:	687b      	ldr	r3, [r7, #4]
 8012c5a:	2b00      	cmp	r3, #0
 8012c5c:	d104      	bne.n	8012c68 <udp_remove+0x18>
 8012c5e:	4b18      	ldr	r3, [pc, #96]	; (8012cc0 <udp_remove+0x70>)
 8012c60:	0018      	movs	r0, r3
 8012c62:	f7ef fe3b 	bl	80028dc <app_debug_rtt_raw>
 8012c66:	e027      	b.n	8012cb8 <udp_remove+0x68>

  mib2_udp_unbind(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
 8012c68:	4b16      	ldr	r3, [pc, #88]	; (8012cc4 <udp_remove+0x74>)
 8012c6a:	681b      	ldr	r3, [r3, #0]
 8012c6c:	687a      	ldr	r2, [r7, #4]
 8012c6e:	429a      	cmp	r2, r3
 8012c70:	d105      	bne.n	8012c7e <udp_remove+0x2e>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
 8012c72:	4b14      	ldr	r3, [pc, #80]	; (8012cc4 <udp_remove+0x74>)
 8012c74:	681b      	ldr	r3, [r3, #0]
 8012c76:	691a      	ldr	r2, [r3, #16]
 8012c78:	4b12      	ldr	r3, [pc, #72]	; (8012cc4 <udp_remove+0x74>)
 8012c7a:	601a      	str	r2, [r3, #0]
 8012c7c:	e017      	b.n	8012cae <udp_remove+0x5e>
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 8012c7e:	4b11      	ldr	r3, [pc, #68]	; (8012cc4 <udp_remove+0x74>)
 8012c80:	681b      	ldr	r3, [r3, #0]
 8012c82:	60fb      	str	r3, [r7, #12]
 8012c84:	e010      	b.n	8012ca8 <udp_remove+0x58>
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
 8012c86:	68fb      	ldr	r3, [r7, #12]
 8012c88:	691b      	ldr	r3, [r3, #16]
 8012c8a:	2b00      	cmp	r3, #0
 8012c8c:	d009      	beq.n	8012ca2 <udp_remove+0x52>
 8012c8e:	68fb      	ldr	r3, [r7, #12]
 8012c90:	691b      	ldr	r3, [r3, #16]
 8012c92:	687a      	ldr	r2, [r7, #4]
 8012c94:	429a      	cmp	r2, r3
 8012c96:	d104      	bne.n	8012ca2 <udp_remove+0x52>
        /* remove pcb from list */
        pcb2->next = pcb->next;
 8012c98:	687b      	ldr	r3, [r7, #4]
 8012c9a:	691a      	ldr	r2, [r3, #16]
 8012c9c:	68fb      	ldr	r3, [r7, #12]
 8012c9e:	611a      	str	r2, [r3, #16]
        break;
 8012ca0:	e005      	b.n	8012cae <udp_remove+0x5e>
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 8012ca2:	68fb      	ldr	r3, [r7, #12]
 8012ca4:	691b      	ldr	r3, [r3, #16]
 8012ca6:	60fb      	str	r3, [r7, #12]
 8012ca8:	68fb      	ldr	r3, [r7, #12]
 8012caa:	2b00      	cmp	r3, #0
 8012cac:	d1eb      	bne.n	8012c86 <udp_remove+0x36>
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
 8012cae:	687b      	ldr	r3, [r7, #4]
 8012cb0:	0019      	movs	r1, r3
 8012cb2:	2000      	movs	r0, #0
 8012cb4:	f7f6 f89c 	bl	8008df0 <memp_free>
}
 8012cb8:	46bd      	mov	sp, r7
 8012cba:	b004      	add	sp, #16
 8012cbc:	bd80      	pop	{r7, pc}
 8012cbe:	46c0      	nop			; (mov r8, r8)
 8012cc0:	080213e0 	.word	0x080213e0
 8012cc4:	20002eec 	.word	0x20002eec

08012cc8 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
 8012cc8:	b580      	push	{r7, lr}
 8012cca:	b082      	sub	sp, #8
 8012ccc:	af00      	add	r7, sp, #0
  struct udp_pcb *pcb;

  LWIP_ASSERT_CORE_LOCKED();

  pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
 8012cce:	2000      	movs	r0, #0
 8012cd0:	f7f6 f81e 	bl	8008d10 <memp_malloc>
 8012cd4:	0003      	movs	r3, r0
 8012cd6:	607b      	str	r3, [r7, #4]
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
 8012cd8:	687b      	ldr	r3, [r7, #4]
 8012cda:	2b00      	cmp	r3, #0
 8012cdc:	d008      	beq.n	8012cf0 <udp_new+0x28>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
 8012cde:	687b      	ldr	r3, [r7, #4]
 8012ce0:	2224      	movs	r2, #36	; 0x24
 8012ce2:	2100      	movs	r1, #0
 8012ce4:	0018      	movs	r0, r3
 8012ce6:	f009 ff97 	bl	801cc18 <memset>
    pcb->ttl = UDP_TTL;
 8012cea:	687b      	ldr	r3, [r7, #4]
 8012cec:	22ff      	movs	r2, #255	; 0xff
 8012cee:	72da      	strb	r2, [r3, #11]
#if LWIP_MULTICAST_TX_OPTIONS
    udp_set_multicast_ttl(pcb, UDP_TTL);
#endif /* LWIP_MULTICAST_TX_OPTIONS */
  }
  return pcb;
 8012cf0:	687b      	ldr	r3, [r7, #4]
}
 8012cf2:	0018      	movs	r0, r3
 8012cf4:	46bd      	mov	sp, r7
 8012cf6:	b002      	add	sp, #8
 8012cf8:	bd80      	pop	{r7, pc}

08012cfa <udp_new_ip_type>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new_ip_type(u8_t type)
{
 8012cfa:	b580      	push	{r7, lr}
 8012cfc:	b084      	sub	sp, #16
 8012cfe:	af00      	add	r7, sp, #0
 8012d00:	0002      	movs	r2, r0
 8012d02:	1dfb      	adds	r3, r7, #7
 8012d04:	701a      	strb	r2, [r3, #0]
  struct udp_pcb *pcb;

  LWIP_ASSERT_CORE_LOCKED();

  pcb = udp_new();
 8012d06:	f7ff ffdf 	bl	8012cc8 <udp_new>
 8012d0a:	0003      	movs	r3, r0
 8012d0c:	60fb      	str	r3, [r7, #12]
    IP_SET_TYPE_VAL(pcb->remote_ip, type);
  }
#else
  LWIP_UNUSED_ARG(type);
#endif /* LWIP_IPV4 && LWIP_IPV6 */
  return pcb;
 8012d0e:	68fb      	ldr	r3, [r7, #12]
}
 8012d10:	0018      	movs	r0, r3
 8012d12:	46bd      	mov	sp, r7
 8012d14:	b004      	add	sp, #16
 8012d16:	bd80      	pop	{r7, pc}

08012d18 <udp_netif_ip_addr_changed>:
 *
 * @param old_addr IP address of the netif before change
 * @param new_addr IP address of the netif after change
 */
void udp_netif_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_addr)
{
 8012d18:	b580      	push	{r7, lr}
 8012d1a:	b084      	sub	sp, #16
 8012d1c:	af00      	add	r7, sp, #0
 8012d1e:	6078      	str	r0, [r7, #4]
 8012d20:	6039      	str	r1, [r7, #0]
  struct udp_pcb *upcb;

  if (!ip_addr_isany(old_addr) && !ip_addr_isany(new_addr)) {
 8012d22:	687b      	ldr	r3, [r7, #4]
 8012d24:	2b00      	cmp	r3, #0
 8012d26:	d01e      	beq.n	8012d66 <udp_netif_ip_addr_changed+0x4e>
 8012d28:	687b      	ldr	r3, [r7, #4]
 8012d2a:	681b      	ldr	r3, [r3, #0]
 8012d2c:	2b00      	cmp	r3, #0
 8012d2e:	d01a      	beq.n	8012d66 <udp_netif_ip_addr_changed+0x4e>
 8012d30:	683b      	ldr	r3, [r7, #0]
 8012d32:	2b00      	cmp	r3, #0
 8012d34:	d017      	beq.n	8012d66 <udp_netif_ip_addr_changed+0x4e>
 8012d36:	683b      	ldr	r3, [r7, #0]
 8012d38:	681b      	ldr	r3, [r3, #0]
 8012d3a:	2b00      	cmp	r3, #0
 8012d3c:	d013      	beq.n	8012d66 <udp_netif_ip_addr_changed+0x4e>
    for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
 8012d3e:	4b0c      	ldr	r3, [pc, #48]	; (8012d70 <udp_netif_ip_addr_changed+0x58>)
 8012d40:	681b      	ldr	r3, [r3, #0]
 8012d42:	60fb      	str	r3, [r7, #12]
 8012d44:	e00c      	b.n	8012d60 <udp_netif_ip_addr_changed+0x48>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&upcb->local_ip, old_addr)) {
 8012d46:	68fb      	ldr	r3, [r7, #12]
 8012d48:	681a      	ldr	r2, [r3, #0]
 8012d4a:	687b      	ldr	r3, [r7, #4]
 8012d4c:	681b      	ldr	r3, [r3, #0]
 8012d4e:	429a      	cmp	r2, r3
 8012d50:	d103      	bne.n	8012d5a <udp_netif_ip_addr_changed+0x42>
        /* The PCB is bound to the old ipaddr and
         * is set to bound to the new one instead */
        ip_addr_copy(upcb->local_ip, *new_addr);
 8012d52:	683b      	ldr	r3, [r7, #0]
 8012d54:	681a      	ldr	r2, [r3, #0]
 8012d56:	68fb      	ldr	r3, [r7, #12]
 8012d58:	601a      	str	r2, [r3, #0]
    for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
 8012d5a:	68fb      	ldr	r3, [r7, #12]
 8012d5c:	691b      	ldr	r3, [r3, #16]
 8012d5e:	60fb      	str	r3, [r7, #12]
 8012d60:	68fb      	ldr	r3, [r7, #12]
 8012d62:	2b00      	cmp	r3, #0
 8012d64:	d1ef      	bne.n	8012d46 <udp_netif_ip_addr_changed+0x2e>
      }
    }
  }
}
 8012d66:	46c0      	nop			; (mov r8, r8)
 8012d68:	46bd      	mov	sp, r7
 8012d6a:	b004      	add	sp, #16
 8012d6c:	bd80      	pop	{r7, pc}
 8012d6e:	46c0      	nop			; (mov r8, r8)
 8012d70:	20002eec 	.word	0x20002eec

08012d74 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the icmp header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
 8012d74:	b590      	push	{r4, r7, lr}
 8012d76:	b08f      	sub	sp, #60	; 0x3c
 8012d78:	af04      	add	r7, sp, #16
 8012d7a:	6078      	str	r0, [r7, #4]
 8012d7c:	6039      	str	r1, [r7, #0]
  const ip4_addr_t *src;

  ICMP_STATS_INC(icmp.recv);
  MIB2_STATS_INC(mib2.icmpinmsgs);

  iphdr_in = ip4_current_header();
 8012d7e:	4bde      	ldr	r3, [pc, #888]	; (80130f8 <icmp_input+0x384>)
 8012d80:	689b      	ldr	r3, [r3, #8]
 8012d82:	627b      	str	r3, [r7, #36]	; 0x24
  hlen = IPH_HL_BYTES(iphdr_in);
 8012d84:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012d86:	781b      	ldrb	r3, [r3, #0]
 8012d88:	220f      	movs	r2, #15
 8012d8a:	4013      	ands	r3, r2
 8012d8c:	b2db      	uxtb	r3, r3
 8012d8e:	009b      	lsls	r3, r3, #2
 8012d90:	b2da      	uxtb	r2, r3
 8012d92:	2122      	movs	r1, #34	; 0x22
 8012d94:	187b      	adds	r3, r7, r1
 8012d96:	801a      	strh	r2, [r3, #0]
  if (hlen < IP_HLEN) {
 8012d98:	187b      	adds	r3, r7, r1
 8012d9a:	881b      	ldrh	r3, [r3, #0]
 8012d9c:	2b13      	cmp	r3, #19
 8012d9e:	d800      	bhi.n	8012da2 <icmp_input+0x2e>
 8012da0:	e1a5      	b.n	80130ee <icmp_input+0x37a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short IP header (%"S16_F" bytes) received\n", hlen));
    goto lenerr;
  }
  if (p->len < sizeof(u16_t) * 2) {
 8012da2:	687b      	ldr	r3, [r7, #4]
 8012da4:	895b      	ldrh	r3, [r3, #10]
 8012da6:	2b03      	cmp	r3, #3
 8012da8:	d800      	bhi.n	8012dac <icmp_input+0x38>
 8012daa:	e1a2      	b.n	80130f2 <icmp_input+0x37e>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
 8012dac:	687b      	ldr	r3, [r7, #4]
 8012dae:	685a      	ldr	r2, [r3, #4]
 8012db0:	2121      	movs	r1, #33	; 0x21
 8012db2:	187b      	adds	r3, r7, r1
 8012db4:	7812      	ldrb	r2, [r2, #0]
 8012db6:	701a      	strb	r2, [r3, #0]
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload) + 1);
 8012db8:	687b      	ldr	r3, [r7, #4]
 8012dba:	685a      	ldr	r2, [r3, #4]
 8012dbc:	2320      	movs	r3, #32
 8012dbe:	18fb      	adds	r3, r7, r3
 8012dc0:	7852      	ldrb	r2, [r2, #1]
 8012dc2:	701a      	strb	r2, [r3, #0]
  /* if debug is enabled but debug statement below is somehow disabled: */
  LWIP_UNUSED_ARG(code);
#endif /* LWIP_DEBUG */
  switch (type) {
 8012dc4:	187b      	adds	r3, r7, r1
 8012dc6:	781b      	ldrb	r3, [r3, #0]
 8012dc8:	2b00      	cmp	r3, #0
 8012dca:	d100      	bne.n	8012dce <icmp_input+0x5a>
 8012dcc:	e187      	b.n	80130de <icmp_input+0x36a>
 8012dce:	2b08      	cmp	r3, #8
 8012dd0:	d000      	beq.n	8012dd4 <icmp_input+0x60>
 8012dd2:	e187      	b.n	80130e4 <icmp_input+0x370>
         (as obviously, an echo request has been sent, too). */
      MIB2_STATS_INC(mib2.icmpinechoreps);
      break;
    case ICMP_ECHO:
      MIB2_STATS_INC(mib2.icmpinechos);
      src = ip4_current_dest_addr();
 8012dd4:	4bc9      	ldr	r3, [pc, #804]	; (80130fc <icmp_input+0x388>)
 8012dd6:	61fb      	str	r3, [r7, #28]
      /* multicast destination address? */
      if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
 8012dd8:	4bc7      	ldr	r3, [pc, #796]	; (80130f8 <icmp_input+0x384>)
 8012dda:	695b      	ldr	r3, [r3, #20]
 8012ddc:	22f0      	movs	r2, #240	; 0xf0
 8012dde:	4013      	ands	r3, r2
 8012de0:	2be0      	cmp	r3, #224	; 0xe0
 8012de2:	d100      	bne.n	8012de6 <icmp_input+0x72>
 8012de4:	e19c      	b.n	8013120 <icmp_input+0x3ac>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast pings\n"));
        goto icmperr;
#endif /* LWIP_MULTICAST_PING */
      }
      /* broadcast destination address? */
      if (ip4_addr_isbroadcast(ip4_current_dest_addr(), ip_current_netif())) {
 8012de6:	4bc4      	ldr	r3, [pc, #784]	; (80130f8 <icmp_input+0x384>)
 8012de8:	695a      	ldr	r2, [r3, #20]
 8012dea:	4bc3      	ldr	r3, [pc, #780]	; (80130f8 <icmp_input+0x384>)
 8012dec:	681b      	ldr	r3, [r3, #0]
 8012dee:	0019      	movs	r1, r3
 8012df0:	0010      	movs	r0, r2
 8012df2:	f000 fe9d 	bl	8013b30 <ip4_addr_isbroadcast_u32>
 8012df6:	1e03      	subs	r3, r0, #0
 8012df8:	d000      	beq.n	8012dfc <icmp_input+0x88>
 8012dfa:	e193      	b.n	8013124 <icmp_input+0x3b0>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to broadcast pings\n"));
        goto icmperr;
#endif /* LWIP_BROADCAST_PING */
      }
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
      if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
 8012dfc:	687b      	ldr	r3, [r7, #4]
 8012dfe:	891b      	ldrh	r3, [r3, #8]
 8012e00:	2b07      	cmp	r3, #7
 8012e02:	d800      	bhi.n	8012e06 <icmp_input+0x92>
 8012e04:	e186      	b.n	8013114 <icmp_input+0x3a0>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
        goto lenerr;
      }
#if CHECKSUM_CHECK_ICMP
      IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_ICMP) {
        if (inet_chksum_pbuf(p) != 0) {
 8012e06:	687b      	ldr	r3, [r7, #4]
 8012e08:	0018      	movs	r0, r3
 8012e0a:	f7f5 fad8 	bl	80083be <inet_chksum_pbuf>
 8012e0e:	1e03      	subs	r3, r0, #0
 8012e10:	d004      	beq.n	8012e1c <icmp_input+0xa8>
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
          pbuf_free(p);
 8012e12:	687b      	ldr	r3, [r7, #4]
 8012e14:	0018      	movs	r0, r3
 8012e16:	f7f6 fedb 	bl	8009bd0 <pbuf_free>
          ICMP_STATS_INC(icmp.chkerr);
          MIB2_STATS_INC(mib2.icmpinerrors);
          return;
 8012e1a:	e18d      	b.n	8013138 <icmp_input+0x3c4>
        }
      }
#endif
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
      if (pbuf_add_header(p, hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN)) {
 8012e1c:	2422      	movs	r4, #34	; 0x22
 8012e1e:	193b      	adds	r3, r7, r4
 8012e20:	881b      	ldrh	r3, [r3, #0]
 8012e22:	3310      	adds	r3, #16
 8012e24:	001a      	movs	r2, r3
 8012e26:	687b      	ldr	r3, [r7, #4]
 8012e28:	0011      	movs	r1, r2
 8012e2a:	0018      	movs	r0, r3
 8012e2c:	f7f6 fde8 	bl	8009a00 <pbuf_add_header>
 8012e30:	1e03      	subs	r3, r0, #0
 8012e32:	d05a      	beq.n	8012eea <icmp_input+0x176>
        /* p is not big enough to contain link headers
         * allocate a new one and copy p into it
         */
        struct pbuf *r;
        u16_t alloc_len = (u16_t)(p->tot_len + hlen);
 8012e34:	687b      	ldr	r3, [r7, #4]
 8012e36:	8919      	ldrh	r1, [r3, #8]
 8012e38:	201a      	movs	r0, #26
 8012e3a:	183b      	adds	r3, r7, r0
 8012e3c:	193a      	adds	r2, r7, r4
 8012e3e:	8812      	ldrh	r2, [r2, #0]
 8012e40:	188a      	adds	r2, r1, r2
 8012e42:	801a      	strh	r2, [r3, #0]
        if (alloc_len < p->tot_len) {
 8012e44:	687b      	ldr	r3, [r7, #4]
 8012e46:	891b      	ldrh	r3, [r3, #8]
 8012e48:	183a      	adds	r2, r7, r0
 8012e4a:	8812      	ldrh	r2, [r2, #0]
 8012e4c:	429a      	cmp	r2, r3
 8012e4e:	d200      	bcs.n	8012e52 <icmp_input+0xde>
 8012e50:	e16a      	b.n	8013128 <icmp_input+0x3b4>
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed (tot_len overflow)\n"));
          goto icmperr;
        }
        /* allocate new packet buffer with space for link headers */
        r = pbuf_alloc(PBUF_LINK, alloc_len, PBUF_RAM);
 8012e52:	23a0      	movs	r3, #160	; 0xa0
 8012e54:	009a      	lsls	r2, r3, #2
 8012e56:	183b      	adds	r3, r7, r0
 8012e58:	881b      	ldrh	r3, [r3, #0]
 8012e5a:	0019      	movs	r1, r3
 8012e5c:	2010      	movs	r0, #16
 8012e5e:	f7f6 fb3f 	bl	80094e0 <pbuf_alloc>
 8012e62:	0003      	movs	r3, r0
 8012e64:	617b      	str	r3, [r7, #20]
        if (r == NULL) {
 8012e66:	697b      	ldr	r3, [r7, #20]
 8012e68:	2b00      	cmp	r3, #0
 8012e6a:	d100      	bne.n	8012e6e <icmp_input+0xfa>
 8012e6c:	e15e      	b.n	801312c <icmp_input+0x3b8>
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
          goto icmperr;
        }
        if (r->len < hlen + sizeof(struct icmp_echo_hdr)) {
 8012e6e:	697b      	ldr	r3, [r7, #20]
 8012e70:	895b      	ldrh	r3, [r3, #10]
 8012e72:	001a      	movs	r2, r3
 8012e74:	193b      	adds	r3, r7, r4
 8012e76:	881b      	ldrh	r3, [r3, #0]
 8012e78:	3308      	adds	r3, #8
 8012e7a:	429a      	cmp	r2, r3
 8012e7c:	d204      	bcs.n	8012e88 <icmp_input+0x114>
          LWIP_DEBUGF(ICMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("first pbuf cannot hold the ICMP header"));
          pbuf_free(r);
 8012e7e:	697b      	ldr	r3, [r7, #20]
 8012e80:	0018      	movs	r0, r3
 8012e82:	f7f6 fea5 	bl	8009bd0 <pbuf_free>
          goto icmperr;
 8012e86:	e152      	b.n	801312e <icmp_input+0x3ba>
        }
        /* copy the ip header */
        MEMCPY(r->payload, iphdr_in, hlen);
 8012e88:	697b      	ldr	r3, [r7, #20]
 8012e8a:	6858      	ldr	r0, [r3, #4]
 8012e8c:	2422      	movs	r4, #34	; 0x22
 8012e8e:	193b      	adds	r3, r7, r4
 8012e90:	881a      	ldrh	r2, [r3, #0]
 8012e92:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012e94:	0019      	movs	r1, r3
 8012e96:	f009 fea3 	bl	801cbe0 <memcpy>
        /* switch r->payload back to icmp header (cannot fail) */
        if (pbuf_remove_header(r, hlen)) {
 8012e9a:	193b      	adds	r3, r7, r4
 8012e9c:	881a      	ldrh	r2, [r3, #0]
 8012e9e:	697b      	ldr	r3, [r7, #20]
 8012ea0:	0011      	movs	r1, r2
 8012ea2:	0018      	movs	r0, r3
 8012ea4:	f7f6 fdbc 	bl	8009a20 <pbuf_remove_header>
 8012ea8:	1e03      	subs	r3, r0, #0
 8012eaa:	d00a      	beq.n	8012ec2 <icmp_input+0x14e>
          LWIP_ASSERT("icmp_input: moving r->payload to icmp header failed\n", 0);
 8012eac:	4b94      	ldr	r3, [pc, #592]	; (8013100 <icmp_input+0x38c>)
 8012eae:	4995      	ldr	r1, [pc, #596]	; (8013104 <icmp_input+0x390>)
 8012eb0:	4895      	ldr	r0, [pc, #596]	; (8013108 <icmp_input+0x394>)
 8012eb2:	22b6      	movs	r2, #182	; 0xb6
 8012eb4:	f7ef fd12 	bl	80028dc <app_debug_rtt_raw>
          pbuf_free(r);
 8012eb8:	697b      	ldr	r3, [r7, #20]
 8012eba:	0018      	movs	r0, r3
 8012ebc:	f7f6 fe88 	bl	8009bd0 <pbuf_free>
          goto icmperr;
 8012ec0:	e135      	b.n	801312e <icmp_input+0x3ba>
        }
        /* copy the rest of the packet without ip header */
        if (pbuf_copy(r, p) != ERR_OK) {
 8012ec2:	687a      	ldr	r2, [r7, #4]
 8012ec4:	697b      	ldr	r3, [r7, #20]
 8012ec6:	0011      	movs	r1, r2
 8012ec8:	0018      	movs	r0, r3
 8012eca:	f7f7 f823 	bl	8009f14 <pbuf_copy>
 8012ece:	1e03      	subs	r3, r0, #0
 8012ed0:	d004      	beq.n	8012edc <icmp_input+0x168>
          LWIP_DEBUGF(ICMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("icmp_input: copying to new pbuf failed"));
          pbuf_free(r);
 8012ed2:	697b      	ldr	r3, [r7, #20]
 8012ed4:	0018      	movs	r0, r3
 8012ed6:	f7f6 fe7b 	bl	8009bd0 <pbuf_free>
          goto icmperr;
 8012eda:	e128      	b.n	801312e <icmp_input+0x3ba>
        }
        /* free the original p */
        pbuf_free(p);
 8012edc:	687b      	ldr	r3, [r7, #4]
 8012ede:	0018      	movs	r0, r3
 8012ee0:	f7f6 fe76 	bl	8009bd0 <pbuf_free>
        /* we now have an identical copy of p that has room for link headers */
        p = r;
 8012ee4:	697b      	ldr	r3, [r7, #20]
 8012ee6:	607b      	str	r3, [r7, #4]
 8012ee8:	e012      	b.n	8012f10 <icmp_input+0x19c>
      } else {
        /* restore p->payload to point to icmp header (cannot fail) */
        if (pbuf_remove_header(p, hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN)) {
 8012eea:	2322      	movs	r3, #34	; 0x22
 8012eec:	18fb      	adds	r3, r7, r3
 8012eee:	881b      	ldrh	r3, [r3, #0]
 8012ef0:	3310      	adds	r3, #16
 8012ef2:	001a      	movs	r2, r3
 8012ef4:	687b      	ldr	r3, [r7, #4]
 8012ef6:	0011      	movs	r1, r2
 8012ef8:	0018      	movs	r0, r3
 8012efa:	f7f6 fd91 	bl	8009a20 <pbuf_remove_header>
 8012efe:	1e03      	subs	r3, r0, #0
 8012f00:	d006      	beq.n	8012f10 <icmp_input+0x19c>
          LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
 8012f02:	4b7f      	ldr	r3, [pc, #508]	; (8013100 <icmp_input+0x38c>)
 8012f04:	4981      	ldr	r1, [pc, #516]	; (801310c <icmp_input+0x398>)
 8012f06:	4880      	ldr	r0, [pc, #512]	; (8013108 <icmp_input+0x394>)
 8012f08:	22c7      	movs	r2, #199	; 0xc7
 8012f0a:	f7ef fce7 	bl	80028dc <app_debug_rtt_raw>
          goto icmperr;
 8012f0e:	e10e      	b.n	801312e <icmp_input+0x3ba>
      }
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
      /* At this point, all checks are OK. */
      /* We generate an answer by switching the dest and src ip addresses,
       * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
      iecho = (struct icmp_echo_hdr *)p->payload;
 8012f10:	687b      	ldr	r3, [r7, #4]
 8012f12:	685b      	ldr	r3, [r3, #4]
 8012f14:	613b      	str	r3, [r7, #16]
      if (pbuf_add_header(p, hlen)) {
 8012f16:	2322      	movs	r3, #34	; 0x22
 8012f18:	18fb      	adds	r3, r7, r3
 8012f1a:	881a      	ldrh	r2, [r3, #0]
 8012f1c:	687b      	ldr	r3, [r7, #4]
 8012f1e:	0011      	movs	r1, r2
 8012f20:	0018      	movs	r0, r3
 8012f22:	f7f6 fd6d 	bl	8009a00 <pbuf_add_header>
 8012f26:	1e03      	subs	r3, r0, #0
 8012f28:	d000      	beq.n	8012f2c <icmp_input+0x1b8>
 8012f2a:	e0da      	b.n	80130e2 <icmp_input+0x36e>
        LWIP_DEBUGF(ICMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Can't move over header in packet"));
      } else {
        err_t ret;
        struct ip_hdr *iphdr = (struct ip_hdr *)p->payload;
 8012f2c:	687b      	ldr	r3, [r7, #4]
 8012f2e:	685b      	ldr	r3, [r3, #4]
 8012f30:	60fb      	str	r3, [r7, #12]
        ip4_addr_copy(iphdr->src, *src);
 8012f32:	69fb      	ldr	r3, [r7, #28]
 8012f34:	681a      	ldr	r2, [r3, #0]
 8012f36:	68fb      	ldr	r3, [r7, #12]
 8012f38:	21ff      	movs	r1, #255	; 0xff
 8012f3a:	4011      	ands	r1, r2
 8012f3c:	000c      	movs	r4, r1
 8012f3e:	7b19      	ldrb	r1, [r3, #12]
 8012f40:	2000      	movs	r0, #0
 8012f42:	4001      	ands	r1, r0
 8012f44:	1c08      	adds	r0, r1, #0
 8012f46:	1c21      	adds	r1, r4, #0
 8012f48:	4301      	orrs	r1, r0
 8012f4a:	7319      	strb	r1, [r3, #12]
 8012f4c:	0a11      	lsrs	r1, r2, #8
 8012f4e:	20ff      	movs	r0, #255	; 0xff
 8012f50:	4001      	ands	r1, r0
 8012f52:	000c      	movs	r4, r1
 8012f54:	7b59      	ldrb	r1, [r3, #13]
 8012f56:	2000      	movs	r0, #0
 8012f58:	4001      	ands	r1, r0
 8012f5a:	1c08      	adds	r0, r1, #0
 8012f5c:	1c21      	adds	r1, r4, #0
 8012f5e:	4301      	orrs	r1, r0
 8012f60:	7359      	strb	r1, [r3, #13]
 8012f62:	0c11      	lsrs	r1, r2, #16
 8012f64:	20ff      	movs	r0, #255	; 0xff
 8012f66:	4001      	ands	r1, r0
 8012f68:	000c      	movs	r4, r1
 8012f6a:	7b99      	ldrb	r1, [r3, #14]
 8012f6c:	2000      	movs	r0, #0
 8012f6e:	4001      	ands	r1, r0
 8012f70:	1c08      	adds	r0, r1, #0
 8012f72:	1c21      	adds	r1, r4, #0
 8012f74:	4301      	orrs	r1, r0
 8012f76:	7399      	strb	r1, [r3, #14]
 8012f78:	0e10      	lsrs	r0, r2, #24
 8012f7a:	7bda      	ldrb	r2, [r3, #15]
 8012f7c:	2100      	movs	r1, #0
 8012f7e:	400a      	ands	r2, r1
 8012f80:	1c11      	adds	r1, r2, #0
 8012f82:	1c02      	adds	r2, r0, #0
 8012f84:	430a      	orrs	r2, r1
 8012f86:	73da      	strb	r2, [r3, #15]
        ip4_addr_copy(iphdr->dest, *ip4_current_src_addr());
 8012f88:	4b5b      	ldr	r3, [pc, #364]	; (80130f8 <icmp_input+0x384>)
 8012f8a:	691a      	ldr	r2, [r3, #16]
 8012f8c:	68fb      	ldr	r3, [r7, #12]
 8012f8e:	21ff      	movs	r1, #255	; 0xff
 8012f90:	4011      	ands	r1, r2
 8012f92:	000c      	movs	r4, r1
 8012f94:	7c19      	ldrb	r1, [r3, #16]
 8012f96:	2000      	movs	r0, #0
 8012f98:	4001      	ands	r1, r0
 8012f9a:	1c08      	adds	r0, r1, #0
 8012f9c:	1c21      	adds	r1, r4, #0
 8012f9e:	4301      	orrs	r1, r0
 8012fa0:	7419      	strb	r1, [r3, #16]
 8012fa2:	0a11      	lsrs	r1, r2, #8
 8012fa4:	20ff      	movs	r0, #255	; 0xff
 8012fa6:	4001      	ands	r1, r0
 8012fa8:	000c      	movs	r4, r1
 8012faa:	7c59      	ldrb	r1, [r3, #17]
 8012fac:	2000      	movs	r0, #0
 8012fae:	4001      	ands	r1, r0
 8012fb0:	1c08      	adds	r0, r1, #0
 8012fb2:	1c21      	adds	r1, r4, #0
 8012fb4:	4301      	orrs	r1, r0
 8012fb6:	7459      	strb	r1, [r3, #17]
 8012fb8:	0c11      	lsrs	r1, r2, #16
 8012fba:	20ff      	movs	r0, #255	; 0xff
 8012fbc:	4001      	ands	r1, r0
 8012fbe:	000c      	movs	r4, r1
 8012fc0:	7c99      	ldrb	r1, [r3, #18]
 8012fc2:	2000      	movs	r0, #0
 8012fc4:	4001      	ands	r1, r0
 8012fc6:	1c08      	adds	r0, r1, #0
 8012fc8:	1c21      	adds	r1, r4, #0
 8012fca:	4301      	orrs	r1, r0
 8012fcc:	7499      	strb	r1, [r3, #18]
 8012fce:	0e10      	lsrs	r0, r2, #24
 8012fd0:	7cda      	ldrb	r2, [r3, #19]
 8012fd2:	2100      	movs	r1, #0
 8012fd4:	400a      	ands	r2, r1
 8012fd6:	1c11      	adds	r1, r2, #0
 8012fd8:	1c02      	adds	r2, r0, #0
 8012fda:	430a      	orrs	r2, r1
 8012fdc:	74da      	strb	r2, [r3, #19]
        ICMPH_TYPE_SET(iecho, ICMP_ER);
 8012fde:	693b      	ldr	r3, [r7, #16]
 8012fe0:	2200      	movs	r2, #0
 8012fe2:	701a      	strb	r2, [r3, #0]
#if CHECKSUM_GEN_ICMP
        IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_GEN_ICMP) {
          /* adjust the checksum */
          if (iecho->chksum > PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
 8012fe4:	693b      	ldr	r3, [r7, #16]
 8012fe6:	789a      	ldrb	r2, [r3, #2]
 8012fe8:	78db      	ldrb	r3, [r3, #3]
 8012fea:	021b      	lsls	r3, r3, #8
 8012fec:	4313      	orrs	r3, r2
 8012fee:	b29b      	uxth	r3, r3
 8012ff0:	4a47      	ldr	r2, [pc, #284]	; (8013110 <icmp_input+0x39c>)
 8012ff2:	4293      	cmp	r3, r2
 8012ff4:	d91c      	bls.n	8013030 <icmp_input+0x2bc>
            iecho->chksum = (u16_t)(iecho->chksum + PP_HTONS((u16_t)(ICMP_ECHO << 8)) + 1);
 8012ff6:	693b      	ldr	r3, [r7, #16]
 8012ff8:	789a      	ldrb	r2, [r3, #2]
 8012ffa:	78db      	ldrb	r3, [r3, #3]
 8012ffc:	021b      	lsls	r3, r3, #8
 8012ffe:	4313      	orrs	r3, r2
 8013000:	b29b      	uxth	r3, r3
 8013002:	3309      	adds	r3, #9
 8013004:	b29a      	uxth	r2, r3
 8013006:	693b      	ldr	r3, [r7, #16]
 8013008:	21ff      	movs	r1, #255	; 0xff
 801300a:	4011      	ands	r1, r2
 801300c:	000c      	movs	r4, r1
 801300e:	7899      	ldrb	r1, [r3, #2]
 8013010:	2000      	movs	r0, #0
 8013012:	4001      	ands	r1, r0
 8013014:	1c08      	adds	r0, r1, #0
 8013016:	1c21      	adds	r1, r4, #0
 8013018:	4301      	orrs	r1, r0
 801301a:	7099      	strb	r1, [r3, #2]
 801301c:	0a12      	lsrs	r2, r2, #8
 801301e:	b290      	uxth	r0, r2
 8013020:	78da      	ldrb	r2, [r3, #3]
 8013022:	2100      	movs	r1, #0
 8013024:	400a      	ands	r2, r1
 8013026:	1c11      	adds	r1, r2, #0
 8013028:	1c02      	adds	r2, r0, #0
 801302a:	430a      	orrs	r2, r1
 801302c:	70da      	strb	r2, [r3, #3]
 801302e:	e01b      	b.n	8013068 <icmp_input+0x2f4>
          } else {
            iecho->chksum = (u16_t)(iecho->chksum + PP_HTONS(ICMP_ECHO << 8));
 8013030:	693b      	ldr	r3, [r7, #16]
 8013032:	789a      	ldrb	r2, [r3, #2]
 8013034:	78db      	ldrb	r3, [r3, #3]
 8013036:	021b      	lsls	r3, r3, #8
 8013038:	4313      	orrs	r3, r2
 801303a:	b29b      	uxth	r3, r3
 801303c:	3308      	adds	r3, #8
 801303e:	b29a      	uxth	r2, r3
 8013040:	693b      	ldr	r3, [r7, #16]
 8013042:	21ff      	movs	r1, #255	; 0xff
 8013044:	4011      	ands	r1, r2
 8013046:	000c      	movs	r4, r1
 8013048:	7899      	ldrb	r1, [r3, #2]
 801304a:	2000      	movs	r0, #0
 801304c:	4001      	ands	r1, r0
 801304e:	1c08      	adds	r0, r1, #0
 8013050:	1c21      	adds	r1, r4, #0
 8013052:	4301      	orrs	r1, r0
 8013054:	7099      	strb	r1, [r3, #2]
 8013056:	0a12      	lsrs	r2, r2, #8
 8013058:	b290      	uxth	r0, r2
 801305a:	78da      	ldrb	r2, [r3, #3]
 801305c:	2100      	movs	r1, #0
 801305e:	400a      	ands	r2, r1
 8013060:	1c11      	adds	r1, r2, #0
 8013062:	1c02      	adds	r2, r0, #0
 8013064:	430a      	orrs	r2, r1
 8013066:	70da      	strb	r2, [r3, #3]
#else /* CHECKSUM_GEN_ICMP */
        iecho->chksum = 0;
#endif /* CHECKSUM_GEN_ICMP */

        /* Set the correct TTL and recalculate the header checksum. */
        IPH_TTL_SET(iphdr, ICMP_TTL);
 8013068:	68fb      	ldr	r3, [r7, #12]
 801306a:	22ff      	movs	r2, #255	; 0xff
 801306c:	721a      	strb	r2, [r3, #8]
        IPH_CHKSUM_SET(iphdr, 0);
 801306e:	68fb      	ldr	r3, [r7, #12]
 8013070:	7a9a      	ldrb	r2, [r3, #10]
 8013072:	2100      	movs	r1, #0
 8013074:	400a      	ands	r2, r1
 8013076:	729a      	strb	r2, [r3, #10]
 8013078:	7ada      	ldrb	r2, [r3, #11]
 801307a:	2100      	movs	r1, #0
 801307c:	400a      	ands	r2, r1
 801307e:	72da      	strb	r2, [r3, #11]
#if CHECKSUM_GEN_IP
        IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_GEN_IP) {
          IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, hlen));
 8013080:	2322      	movs	r3, #34	; 0x22
 8013082:	18fb      	adds	r3, r7, r3
 8013084:	881a      	ldrh	r2, [r3, #0]
 8013086:	68fb      	ldr	r3, [r7, #12]
 8013088:	0011      	movs	r1, r2
 801308a:	0018      	movs	r0, r3
 801308c:	f7f5 f982 	bl	8008394 <inet_chksum>
 8013090:	0003      	movs	r3, r0
 8013092:	001a      	movs	r2, r3
 8013094:	68fb      	ldr	r3, [r7, #12]
 8013096:	21ff      	movs	r1, #255	; 0xff
 8013098:	4011      	ands	r1, r2
 801309a:	000c      	movs	r4, r1
 801309c:	7a99      	ldrb	r1, [r3, #10]
 801309e:	2000      	movs	r0, #0
 80130a0:	4001      	ands	r1, r0
 80130a2:	1c08      	adds	r0, r1, #0
 80130a4:	1c21      	adds	r1, r4, #0
 80130a6:	4301      	orrs	r1, r0
 80130a8:	7299      	strb	r1, [r3, #10]
 80130aa:	0a12      	lsrs	r2, r2, #8
 80130ac:	b290      	uxth	r0, r2
 80130ae:	7ada      	ldrb	r2, [r3, #11]
 80130b0:	2100      	movs	r1, #0
 80130b2:	400a      	ands	r2, r1
 80130b4:	1c11      	adds	r1, r2, #0
 80130b6:	1c02      	adds	r2, r0, #0
 80130b8:	430a      	orrs	r2, r1
 80130ba:	72da      	strb	r2, [r3, #11]
        MIB2_STATS_INC(mib2.icmpoutmsgs);
        /* increase number of echo replies attempted to send */
        MIB2_STATS_INC(mib2.icmpoutechoreps);

        /* send an ICMP packet */
        ret = ip4_output_if(p, src, LWIP_IP_HDRINCL,
 80130bc:	230b      	movs	r3, #11
 80130be:	18fc      	adds	r4, r7, r3
 80130c0:	69f9      	ldr	r1, [r7, #28]
 80130c2:	6878      	ldr	r0, [r7, #4]
 80130c4:	683b      	ldr	r3, [r7, #0]
 80130c6:	9302      	str	r3, [sp, #8]
 80130c8:	2301      	movs	r3, #1
 80130ca:	9301      	str	r3, [sp, #4]
 80130cc:	2300      	movs	r3, #0
 80130ce:	9300      	str	r3, [sp, #0]
 80130d0:	23ff      	movs	r3, #255	; 0xff
 80130d2:	2200      	movs	r2, #0
 80130d4:	f000 fb06 	bl	80136e4 <ip4_output_if>
 80130d8:	0003      	movs	r3, r0
 80130da:	7023      	strb	r3, [r4, #0]
                            ICMP_TTL, 0, IP_PROTO_ICMP, inp);
        if (ret != ERR_OK) {
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %s\n", lwip_strerr(ret)));
        }
      }
      break;
 80130dc:	e001      	b.n	80130e2 <icmp_input+0x36e>
      break;
 80130de:	46c0      	nop			; (mov r8, r8)
 80130e0:	e000      	b.n	80130e4 <icmp_input+0x370>
      break;
 80130e2:	46c0      	nop			; (mov r8, r8)
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n",
                               (s16_t)type, (s16_t)code));
      ICMP_STATS_INC(icmp.proterr);
      ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
 80130e4:	687b      	ldr	r3, [r7, #4]
 80130e6:	0018      	movs	r0, r3
 80130e8:	f7f6 fd72 	bl	8009bd0 <pbuf_free>
  return;
 80130ec:	e024      	b.n	8013138 <icmp_input+0x3c4>
    goto lenerr;
 80130ee:	46c0      	nop			; (mov r8, r8)
 80130f0:	e011      	b.n	8013116 <icmp_input+0x3a2>
    goto lenerr;
 80130f2:	46c0      	nop			; (mov r8, r8)
 80130f4:	e00f      	b.n	8013116 <icmp_input+0x3a2>
 80130f6:	46c0      	nop			; (mov r8, r8)
 80130f8:	20001c94 	.word	0x20001c94
 80130fc:	20001ca8 	.word	0x20001ca8
 8013100:	080213f8 	.word	0x080213f8
 8013104:	08021424 	.word	0x08021424
 8013108:	0802145c 	.word	0x0802145c
 801310c:	08021488 	.word	0x08021488
 8013110:	0000fff7 	.word	0x0000fff7
        goto lenerr;
 8013114:	46c0      	nop			; (mov r8, r8)
lenerr:
  pbuf_free(p);
 8013116:	687b      	ldr	r3, [r7, #4]
 8013118:	0018      	movs	r0, r3
 801311a:	f7f6 fd59 	bl	8009bd0 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  MIB2_STATS_INC(mib2.icmpinerrors);
  return;
 801311e:	e00b      	b.n	8013138 <icmp_input+0x3c4>
        goto icmperr;
 8013120:	46c0      	nop			; (mov r8, r8)
 8013122:	e004      	b.n	801312e <icmp_input+0x3ba>
        goto icmperr;
 8013124:	46c0      	nop			; (mov r8, r8)
 8013126:	e002      	b.n	801312e <icmp_input+0x3ba>
          goto icmperr;
 8013128:	46c0      	nop			; (mov r8, r8)
 801312a:	e000      	b.n	801312e <icmp_input+0x3ba>
          goto icmperr;
 801312c:	46c0      	nop			; (mov r8, r8)
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN || !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
icmperr:
  pbuf_free(p);
 801312e:	687b      	ldr	r3, [r7, #4]
 8013130:	0018      	movs	r0, r3
 8013132:	f7f6 fd4d 	bl	8009bd0 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
  MIB2_STATS_INC(mib2.icmpinerrors);
  return;
 8013136:	46c0      	nop			; (mov r8, r8)
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN || !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
}
 8013138:	46bd      	mov	sp, r7
 801313a:	b00b      	add	sp, #44	; 0x2c
 801313c:	bd90      	pop	{r4, r7, pc}
 801313e:	46c0      	nop			; (mov r8, r8)

08013140 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
 8013140:	b580      	push	{r7, lr}
 8013142:	b082      	sub	sp, #8
 8013144:	af00      	add	r7, sp, #0
 8013146:	6078      	str	r0, [r7, #4]
 8013148:	000a      	movs	r2, r1
 801314a:	1cfb      	adds	r3, r7, #3
 801314c:	701a      	strb	r2, [r3, #0]
  MIB2_STATS_INC(mib2.icmpoutdestunreachs);
  icmp_send_response(p, ICMP_DUR, t);
 801314e:	1cfb      	adds	r3, r7, #3
 8013150:	781a      	ldrb	r2, [r3, #0]
 8013152:	687b      	ldr	r3, [r7, #4]
 8013154:	2103      	movs	r1, #3
 8013156:	0018      	movs	r0, r3
 8013158:	f000 f804 	bl	8013164 <icmp_send_response>
}
 801315c:	46c0      	nop			; (mov r8, r8)
 801315e:	46bd      	mov	sp, r7
 8013160:	b002      	add	sp, #8
 8013162:	bd80      	pop	{r7, pc}

08013164 <icmp_send_response>:
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
 8013164:	b5b0      	push	{r4, r5, r7, lr}
 8013166:	b08c      	sub	sp, #48	; 0x30
 8013168:	af04      	add	r7, sp, #16
 801316a:	6078      	str	r0, [r7, #4]
 801316c:	0008      	movs	r0, r1
 801316e:	0011      	movs	r1, r2
 8013170:	1cfb      	adds	r3, r7, #3
 8013172:	1c02      	adds	r2, r0, #0
 8013174:	701a      	strb	r2, [r3, #0]
 8013176:	1cbb      	adds	r3, r7, #2
 8013178:	1c0a      	adds	r2, r1, #0
 801317a:	701a      	strb	r2, [r3, #0]

  /* increase number of messages attempted to send */
  MIB2_STATS_INC(mib2.icmpoutmsgs);

  /* Keep IP header + up to 8 bytes */
  response_pkt_len = IP_HLEN + ICMP_DEST_UNREACH_DATASIZE;
 801317c:	211a      	movs	r1, #26
 801317e:	187b      	adds	r3, r7, r1
 8013180:	221c      	movs	r2, #28
 8013182:	801a      	strh	r2, [r3, #0]
  if (p->tot_len < response_pkt_len) {
 8013184:	687b      	ldr	r3, [r7, #4]
 8013186:	891b      	ldrh	r3, [r3, #8]
 8013188:	187a      	adds	r2, r7, r1
 801318a:	8812      	ldrh	r2, [r2, #0]
 801318c:	429a      	cmp	r2, r3
 801318e:	d903      	bls.n	8013198 <icmp_send_response+0x34>
    response_pkt_len = p->tot_len;
 8013190:	187b      	adds	r3, r7, r1
 8013192:	687a      	ldr	r2, [r7, #4]
 8013194:	8912      	ldrh	r2, [r2, #8]
 8013196:	801a      	strh	r2, [r3, #0]
  }

  /* ICMP header + part of original packet */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + response_pkt_len, PBUF_RAM);
 8013198:	241a      	movs	r4, #26
 801319a:	193b      	adds	r3, r7, r4
 801319c:	881b      	ldrh	r3, [r3, #0]
 801319e:	3308      	adds	r3, #8
 80131a0:	b29b      	uxth	r3, r3
 80131a2:	22a0      	movs	r2, #160	; 0xa0
 80131a4:	0092      	lsls	r2, r2, #2
 80131a6:	0019      	movs	r1, r3
 80131a8:	2024      	movs	r0, #36	; 0x24
 80131aa:	f7f6 f999 	bl	80094e0 <pbuf_alloc>
 80131ae:	0003      	movs	r3, r0
 80131b0:	617b      	str	r3, [r7, #20]
  if (q == NULL) {
 80131b2:	697b      	ldr	r3, [r7, #20]
 80131b4:	2b00      	cmp	r3, #0
 80131b6:	d100      	bne.n	80131ba <icmp_send_response+0x56>
 80131b8:	e087      	b.n	80132ca <icmp_send_response+0x166>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    MIB2_STATS_INC(mib2.icmpouterrors);
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
 80131ba:	697b      	ldr	r3, [r7, #20]
 80131bc:	895b      	ldrh	r3, [r3, #10]
 80131be:	001a      	movs	r2, r3
 80131c0:	193b      	adds	r3, r7, r4
 80131c2:	881b      	ldrh	r3, [r3, #0]
 80131c4:	3308      	adds	r3, #8
 80131c6:	429a      	cmp	r2, r3
 80131c8:	d206      	bcs.n	80131d8 <icmp_send_response+0x74>
 80131ca:	4b42      	ldr	r3, [pc, #264]	; (80132d4 <icmp_send_response+0x170>)
 80131cc:	22b7      	movs	r2, #183	; 0xb7
 80131ce:	0052      	lsls	r2, r2, #1
 80131d0:	4941      	ldr	r1, [pc, #260]	; (80132d8 <icmp_send_response+0x174>)
 80131d2:	4842      	ldr	r0, [pc, #264]	; (80132dc <icmp_send_response+0x178>)
 80131d4:	f7ef fb82 	bl	80028dc <app_debug_rtt_raw>
              (q->len >= (sizeof(struct icmp_echo_hdr) + response_pkt_len)));

  iphdr = (struct ip_hdr *)p->payload;
 80131d8:	687b      	ldr	r3, [r7, #4]
 80131da:	685b      	ldr	r3, [r3, #4]
 80131dc:	613b      	str	r3, [r7, #16]
  ip4_addr_debug_print_val(ICMP_DEBUG, iphdr->src);
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip4_addr_debug_print_val(ICMP_DEBUG, iphdr->dest);
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
 80131de:	697b      	ldr	r3, [r7, #20]
 80131e0:	685b      	ldr	r3, [r3, #4]
 80131e2:	60fb      	str	r3, [r7, #12]
  icmphdr->type = type;
 80131e4:	68fb      	ldr	r3, [r7, #12]
 80131e6:	1cfa      	adds	r2, r7, #3
 80131e8:	7812      	ldrb	r2, [r2, #0]
 80131ea:	701a      	strb	r2, [r3, #0]
  icmphdr->code = code;
 80131ec:	68fb      	ldr	r3, [r7, #12]
 80131ee:	1cba      	adds	r2, r7, #2
 80131f0:	7812      	ldrb	r2, [r2, #0]
 80131f2:	705a      	strb	r2, [r3, #1]
  icmphdr->id = 0;
 80131f4:	68fb      	ldr	r3, [r7, #12]
 80131f6:	791a      	ldrb	r2, [r3, #4]
 80131f8:	2100      	movs	r1, #0
 80131fa:	400a      	ands	r2, r1
 80131fc:	711a      	strb	r2, [r3, #4]
 80131fe:	795a      	ldrb	r2, [r3, #5]
 8013200:	2100      	movs	r1, #0
 8013202:	400a      	ands	r2, r1
 8013204:	715a      	strb	r2, [r3, #5]
  icmphdr->seqno = 0;
 8013206:	68fb      	ldr	r3, [r7, #12]
 8013208:	799a      	ldrb	r2, [r3, #6]
 801320a:	2100      	movs	r1, #0
 801320c:	400a      	ands	r2, r1
 801320e:	719a      	strb	r2, [r3, #6]
 8013210:	79da      	ldrb	r2, [r3, #7]
 8013212:	2100      	movs	r1, #0
 8013214:	400a      	ands	r2, r1
 8013216:	71da      	strb	r2, [r3, #7]

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 8013218:	697b      	ldr	r3, [r7, #20]
 801321a:	685b      	ldr	r3, [r3, #4]
 801321c:	3308      	adds	r3, #8
 801321e:	0018      	movs	r0, r3
 8013220:	687b      	ldr	r3, [r7, #4]
 8013222:	6859      	ldr	r1, [r3, #4]
 8013224:	231a      	movs	r3, #26
 8013226:	18fb      	adds	r3, r7, r3
 8013228:	881b      	ldrh	r3, [r3, #0]
 801322a:	001a      	movs	r2, r3
 801322c:	f009 fcd8 	bl	801cbe0 <memcpy>
          response_pkt_len);

  ip4_addr_copy(iphdr_src, iphdr->src);
 8013230:	693b      	ldr	r3, [r7, #16]
 8013232:	7b1a      	ldrb	r2, [r3, #12]
 8013234:	7b59      	ldrb	r1, [r3, #13]
 8013236:	0209      	lsls	r1, r1, #8
 8013238:	430a      	orrs	r2, r1
 801323a:	7b99      	ldrb	r1, [r3, #14]
 801323c:	0409      	lsls	r1, r1, #16
 801323e:	430a      	orrs	r2, r1
 8013240:	7bdb      	ldrb	r3, [r3, #15]
 8013242:	061b      	lsls	r3, r3, #24
 8013244:	4313      	orrs	r3, r2
 8013246:	60bb      	str	r3, [r7, #8]
    ip4_addr_t iphdr_dst;
    ip4_addr_copy(iphdr_dst, iphdr->dest);
    netif = ip4_route_src(&iphdr_dst, &iphdr_src);
  }
#else
  netif = ip4_route(&iphdr_src);
 8013248:	2508      	movs	r5, #8
 801324a:	197b      	adds	r3, r7, r5
 801324c:	0018      	movs	r0, r3
 801324e:	f000 f847 	bl	80132e0 <ip4_route>
 8013252:	0003      	movs	r3, r0
 8013254:	61fb      	str	r3, [r7, #28]
#endif
  if (netif != NULL) {
 8013256:	69fb      	ldr	r3, [r7, #28]
 8013258:	2b00      	cmp	r3, #0
 801325a:	d031      	beq.n	80132c0 <icmp_send_response+0x15c>
    /* calculate checksum */
    icmphdr->chksum = 0;
 801325c:	68fb      	ldr	r3, [r7, #12]
 801325e:	789a      	ldrb	r2, [r3, #2]
 8013260:	2100      	movs	r1, #0
 8013262:	400a      	ands	r2, r1
 8013264:	709a      	strb	r2, [r3, #2]
 8013266:	78da      	ldrb	r2, [r3, #3]
 8013268:	2100      	movs	r1, #0
 801326a:	400a      	ands	r2, r1
 801326c:	70da      	strb	r2, [r3, #3]
#if CHECKSUM_GEN_ICMP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_ICMP) {
      icmphdr->chksum = inet_chksum(icmphdr, q->len);
 801326e:	697b      	ldr	r3, [r7, #20]
 8013270:	895a      	ldrh	r2, [r3, #10]
 8013272:	68fb      	ldr	r3, [r7, #12]
 8013274:	0011      	movs	r1, r2
 8013276:	0018      	movs	r0, r3
 8013278:	f7f5 f88c 	bl	8008394 <inet_chksum>
 801327c:	0003      	movs	r3, r0
 801327e:	001a      	movs	r2, r3
 8013280:	68fb      	ldr	r3, [r7, #12]
 8013282:	21ff      	movs	r1, #255	; 0xff
 8013284:	4011      	ands	r1, r2
 8013286:	000c      	movs	r4, r1
 8013288:	7899      	ldrb	r1, [r3, #2]
 801328a:	2000      	movs	r0, #0
 801328c:	4001      	ands	r1, r0
 801328e:	1c08      	adds	r0, r1, #0
 8013290:	1c21      	adds	r1, r4, #0
 8013292:	4301      	orrs	r1, r0
 8013294:	7099      	strb	r1, [r3, #2]
 8013296:	0a12      	lsrs	r2, r2, #8
 8013298:	b290      	uxth	r0, r2
 801329a:	78da      	ldrb	r2, [r3, #3]
 801329c:	2100      	movs	r1, #0
 801329e:	400a      	ands	r2, r1
 80132a0:	1c11      	adds	r1, r2, #0
 80132a2:	1c02      	adds	r2, r0, #0
 80132a4:	430a      	orrs	r2, r1
 80132a6:	70da      	strb	r2, [r3, #3]
    }
#endif
    ICMP_STATS_INC(icmp.xmit);
    ip4_output_if(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP, netif);
 80132a8:	197a      	adds	r2, r7, r5
 80132aa:	6978      	ldr	r0, [r7, #20]
 80132ac:	69fb      	ldr	r3, [r7, #28]
 80132ae:	9302      	str	r3, [sp, #8]
 80132b0:	2301      	movs	r3, #1
 80132b2:	9301      	str	r3, [sp, #4]
 80132b4:	2300      	movs	r3, #0
 80132b6:	9300      	str	r3, [sp, #0]
 80132b8:	23ff      	movs	r3, #255	; 0xff
 80132ba:	2100      	movs	r1, #0
 80132bc:	f000 fa12 	bl	80136e4 <ip4_output_if>
  }
  pbuf_free(q);
 80132c0:	697b      	ldr	r3, [r7, #20]
 80132c2:	0018      	movs	r0, r3
 80132c4:	f7f6 fc84 	bl	8009bd0 <pbuf_free>
 80132c8:	e000      	b.n	80132cc <icmp_send_response+0x168>
    return;
 80132ca:	46c0      	nop			; (mov r8, r8)
}
 80132cc:	46bd      	mov	sp, r7
 80132ce:	b008      	add	sp, #32
 80132d0:	bdb0      	pop	{r4, r5, r7, pc}
 80132d2:	46c0      	nop			; (mov r8, r8)
 80132d4:	080213f8 	.word	0x080213f8
 80132d8:	080214bc 	.word	0x080214bc
 80132dc:	0802145c 	.word	0x0802145c

080132e0 <ip4_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip4_route(const ip4_addr_t *dest)
{
 80132e0:	b580      	push	{r7, lr}
 80132e2:	b084      	sub	sp, #16
 80132e4:	af00      	add	r7, sp, #0
 80132e6:	6078      	str	r0, [r7, #4]

  /* bug #54569: in case LWIP_SINGLE_NETIF=1 and LWIP_DEBUGF() disabled, the following loop is optimized away */
  LWIP_UNUSED_ARG(dest);

  /* iterate through netifs */
  NETIF_FOREACH(netif) {
 80132e8:	4b33      	ldr	r3, [pc, #204]	; (80133b8 <ip4_route+0xd8>)
 80132ea:	681b      	ldr	r3, [r3, #0]
 80132ec:	60fb      	str	r3, [r7, #12]
 80132ee:	e037      	b.n	8013360 <ip4_route+0x80>
    /* is the netif up, does it have a link and a valid address? */
    if (netif_is_up(netif) && netif_is_link_up(netif) && !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 80132f0:	68fb      	ldr	r3, [r7, #12]
 80132f2:	2231      	movs	r2, #49	; 0x31
 80132f4:	5c9b      	ldrb	r3, [r3, r2]
 80132f6:	1c1a      	adds	r2, r3, #0
 80132f8:	2301      	movs	r3, #1
 80132fa:	4013      	ands	r3, r2
 80132fc:	b2db      	uxtb	r3, r3
 80132fe:	2b00      	cmp	r3, #0
 8013300:	d02b      	beq.n	801335a <ip4_route+0x7a>
 8013302:	68fb      	ldr	r3, [r7, #12]
 8013304:	2231      	movs	r2, #49	; 0x31
 8013306:	5c9b      	ldrb	r3, [r3, r2]
 8013308:	089b      	lsrs	r3, r3, #2
 801330a:	1c1a      	adds	r2, r3, #0
 801330c:	2301      	movs	r3, #1
 801330e:	4013      	ands	r3, r2
 8013310:	b2db      	uxtb	r3, r3
 8013312:	2b00      	cmp	r3, #0
 8013314:	d021      	beq.n	801335a <ip4_route+0x7a>
 8013316:	68fb      	ldr	r3, [r7, #12]
 8013318:	3304      	adds	r3, #4
 801331a:	681b      	ldr	r3, [r3, #0]
 801331c:	2b00      	cmp	r3, #0
 801331e:	d01c      	beq.n	801335a <ip4_route+0x7a>
      /* network mask matches? */
      if (ip4_addr_netcmp(dest, netif_ip4_addr(netif), netif_ip4_netmask(netif))) {
 8013320:	687b      	ldr	r3, [r7, #4]
 8013322:	681a      	ldr	r2, [r3, #0]
 8013324:	68fb      	ldr	r3, [r7, #12]
 8013326:	3304      	adds	r3, #4
 8013328:	681b      	ldr	r3, [r3, #0]
 801332a:	405a      	eors	r2, r3
 801332c:	68fb      	ldr	r3, [r7, #12]
 801332e:	3308      	adds	r3, #8
 8013330:	681b      	ldr	r3, [r3, #0]
 8013332:	4013      	ands	r3, r2
 8013334:	d101      	bne.n	801333a <ip4_route+0x5a>
        /* return netif on which to forward IP packet */
        return netif;
 8013336:	68fb      	ldr	r3, [r7, #12]
 8013338:	e039      	b.n	80133ae <ip4_route+0xce>
      }
      /* gateway matches on a non broadcast interface? (i.e. peer in a point to point interface) */
      if (((netif->flags & NETIF_FLAG_BROADCAST) == 0) && ip4_addr_cmp(dest, netif_ip4_gw(netif))) {
 801333a:	68fb      	ldr	r3, [r7, #12]
 801333c:	2231      	movs	r2, #49	; 0x31
 801333e:	5c9b      	ldrb	r3, [r3, r2]
 8013340:	001a      	movs	r2, r3
 8013342:	2302      	movs	r3, #2
 8013344:	4013      	ands	r3, r2
 8013346:	d108      	bne.n	801335a <ip4_route+0x7a>
 8013348:	687b      	ldr	r3, [r7, #4]
 801334a:	681a      	ldr	r2, [r3, #0]
 801334c:	68fb      	ldr	r3, [r7, #12]
 801334e:	330c      	adds	r3, #12
 8013350:	681b      	ldr	r3, [r3, #0]
 8013352:	429a      	cmp	r2, r3
 8013354:	d101      	bne.n	801335a <ip4_route+0x7a>
        /* return netif on which to forward IP packet */
        return netif;
 8013356:	68fb      	ldr	r3, [r7, #12]
 8013358:	e029      	b.n	80133ae <ip4_route+0xce>
  NETIF_FOREACH(netif) {
 801335a:	68fb      	ldr	r3, [r7, #12]
 801335c:	681b      	ldr	r3, [r3, #0]
 801335e:	60fb      	str	r3, [r7, #12]
 8013360:	68fb      	ldr	r3, [r7, #12]
 8013362:	2b00      	cmp	r3, #0
 8013364:	d1c4      	bne.n	80132f0 <ip4_route+0x10>
    return netif;
  }
#endif
#endif /* !LWIP_SINGLE_NETIF */

  if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
 8013366:	4b15      	ldr	r3, [pc, #84]	; (80133bc <ip4_route+0xdc>)
 8013368:	681b      	ldr	r3, [r3, #0]
 801336a:	2b00      	cmp	r3, #0
 801336c:	d01b      	beq.n	80133a6 <ip4_route+0xc6>
 801336e:	4b13      	ldr	r3, [pc, #76]	; (80133bc <ip4_route+0xdc>)
 8013370:	681b      	ldr	r3, [r3, #0]
 8013372:	2231      	movs	r2, #49	; 0x31
 8013374:	5c9b      	ldrb	r3, [r3, r2]
 8013376:	001a      	movs	r2, r3
 8013378:	2301      	movs	r3, #1
 801337a:	4013      	ands	r3, r2
 801337c:	d013      	beq.n	80133a6 <ip4_route+0xc6>
 801337e:	4b0f      	ldr	r3, [pc, #60]	; (80133bc <ip4_route+0xdc>)
 8013380:	681b      	ldr	r3, [r3, #0]
 8013382:	2231      	movs	r2, #49	; 0x31
 8013384:	5c9b      	ldrb	r3, [r3, r2]
 8013386:	001a      	movs	r2, r3
 8013388:	2304      	movs	r3, #4
 801338a:	4013      	ands	r3, r2
 801338c:	d00b      	beq.n	80133a6 <ip4_route+0xc6>
      ip4_addr_isany_val(*netif_ip4_addr(netif_default)) || ip4_addr_isloopback(dest)) {
 801338e:	4b0b      	ldr	r3, [pc, #44]	; (80133bc <ip4_route+0xdc>)
 8013390:	681b      	ldr	r3, [r3, #0]
 8013392:	3304      	adds	r3, #4
 8013394:	681b      	ldr	r3, [r3, #0]
  if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
 8013396:	2b00      	cmp	r3, #0
 8013398:	d005      	beq.n	80133a6 <ip4_route+0xc6>
      ip4_addr_isany_val(*netif_ip4_addr(netif_default)) || ip4_addr_isloopback(dest)) {
 801339a:	687b      	ldr	r3, [r7, #4]
 801339c:	681b      	ldr	r3, [r3, #0]
 801339e:	22ff      	movs	r2, #255	; 0xff
 80133a0:	4013      	ands	r3, r2
 80133a2:	2b7f      	cmp	r3, #127	; 0x7f
 80133a4:	d101      	bne.n	80133aa <ip4_route+0xca>
       If this is not good enough for you, use LWIP_HOOK_IP4_ROUTE() */
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_route: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
                ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
    MIB2_STATS_INC(mib2.ipoutnoroutes);
    return NULL;
 80133a6:	2300      	movs	r3, #0
 80133a8:	e001      	b.n	80133ae <ip4_route+0xce>
  }

  return netif_default;
 80133aa:	4b04      	ldr	r3, [pc, #16]	; (80133bc <ip4_route+0xdc>)
 80133ac:	681b      	ldr	r3, [r3, #0]
}
 80133ae:	0018      	movs	r0, r3
 80133b0:	46bd      	mov	sp, r7
 80133b2:	b004      	add	sp, #16
 80133b4:	bd80      	pop	{r7, pc}
 80133b6:	46c0      	nop			; (mov r8, r8)
 80133b8:	20002ec4 	.word	0x20002ec4
 80133bc:	20002ec8 	.word	0x20002ec8

080133c0 <ip4_input_accept>:
#endif /* IP_FORWARD */

/** Return true if the current input packet should be accepted on this netif */
static int
ip4_input_accept(struct netif *netif)
{
 80133c0:	b580      	push	{r7, lr}
 80133c2:	b082      	sub	sp, #8
 80133c4:	af00      	add	r7, sp, #0
 80133c6:	6078      	str	r0, [r7, #4]
                         ip4_addr_get_u32(ip4_current_dest_addr()) & ip4_addr_get_u32(netif_ip4_netmask(netif)),
                         ip4_addr_get_u32(netif_ip4_addr(netif)) & ip4_addr_get_u32(netif_ip4_netmask(netif)),
                         ip4_addr_get_u32(ip4_current_dest_addr()) & ~ip4_addr_get_u32(netif_ip4_netmask(netif))));

  /* interface is up and configured? */
  if ((netif_is_up(netif)) && (!ip4_addr_isany_val(*netif_ip4_addr(netif)))) {
 80133c8:	687b      	ldr	r3, [r7, #4]
 80133ca:	2231      	movs	r2, #49	; 0x31
 80133cc:	5c9b      	ldrb	r3, [r3, r2]
 80133ce:	1c1a      	adds	r2, r3, #0
 80133d0:	2301      	movs	r3, #1
 80133d2:	4013      	ands	r3, r2
 80133d4:	b2db      	uxtb	r3, r3
 80133d6:	2b00      	cmp	r3, #0
 80133d8:	d016      	beq.n	8013408 <ip4_input_accept+0x48>
 80133da:	687b      	ldr	r3, [r7, #4]
 80133dc:	3304      	adds	r3, #4
 80133de:	681b      	ldr	r3, [r3, #0]
 80133e0:	2b00      	cmp	r3, #0
 80133e2:	d011      	beq.n	8013408 <ip4_input_accept+0x48>
    /* unicast to this interface address? */
    if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
 80133e4:	4b0b      	ldr	r3, [pc, #44]	; (8013414 <ip4_input_accept+0x54>)
 80133e6:	695a      	ldr	r2, [r3, #20]
 80133e8:	687b      	ldr	r3, [r7, #4]
 80133ea:	3304      	adds	r3, #4
 80133ec:	681b      	ldr	r3, [r3, #0]
 80133ee:	429a      	cmp	r2, r3
 80133f0:	d008      	beq.n	8013404 <ip4_input_accept+0x44>
        /* or broadcast on this interface network address? */
        ip4_addr_isbroadcast(ip4_current_dest_addr(), netif)
 80133f2:	4b08      	ldr	r3, [pc, #32]	; (8013414 <ip4_input_accept+0x54>)
 80133f4:	695b      	ldr	r3, [r3, #20]
 80133f6:	687a      	ldr	r2, [r7, #4]
 80133f8:	0011      	movs	r1, r2
 80133fa:	0018      	movs	r0, r3
 80133fc:	f000 fb98 	bl	8013b30 <ip4_addr_isbroadcast_u32>
 8013400:	1e03      	subs	r3, r0, #0
    if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
 8013402:	d001      	beq.n	8013408 <ip4_input_accept+0x48>
#endif /* LWIP_NETIF_LOOPBACK && !LWIP_HAVE_LOOPIF */
       ) {
      LWIP_DEBUGF(IP_DEBUG, ("ip4_input: packet accepted on interface %c%c\n",
                             netif->name[0], netif->name[1]));
      /* accept on this netif */
      return 1;
 8013404:	2301      	movs	r3, #1
 8013406:	e000      	b.n	801340a <ip4_input_accept+0x4a>
      /* accept on this netif */
      return 1;
    }
#endif /* LWIP_AUTOIP */
  }
  return 0;
 8013408:	2300      	movs	r3, #0
}
 801340a:	0018      	movs	r0, r3
 801340c:	46bd      	mov	sp, r7
 801340e:	b002      	add	sp, #8
 8013410:	bd80      	pop	{r7, pc}
 8013412:	46c0      	nop			; (mov r8, r8)
 8013414:	20001c94 	.word	0x20001c94

08013418 <ip4_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip4_input(struct pbuf *p, struct netif *inp)
{
 8013418:	b5b0      	push	{r4, r5, r7, lr}
 801341a:	b086      	sub	sp, #24
 801341c:	af00      	add	r7, sp, #0
 801341e:	6078      	str	r0, [r7, #4]
 8013420:	6039      	str	r1, [r7, #0]

  IP_STATS_INC(ip.recv);
  MIB2_STATS_INC(mib2.ipinreceives);

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
 8013422:	687b      	ldr	r3, [r7, #4]
 8013424:	685b      	ldr	r3, [r3, #4]
 8013426:	613b      	str	r3, [r7, #16]
  if (IPH_V(iphdr) != 4) {
 8013428:	693b      	ldr	r3, [r7, #16]
 801342a:	781b      	ldrb	r3, [r3, #0]
 801342c:	091b      	lsrs	r3, r3, #4
 801342e:	b2db      	uxtb	r3, r3
 8013430:	2b04      	cmp	r3, #4
 8013432:	d005      	beq.n	8013440 <ip4_input+0x28>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", (u16_t)IPH_V(iphdr)));
    ip4_debug_print(p);
    pbuf_free(p);
 8013434:	687b      	ldr	r3, [r7, #4]
 8013436:	0018      	movs	r0, r3
 8013438:	f7f6 fbca 	bl	8009bd0 <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    MIB2_STATS_INC(mib2.ipinhdrerrors);
    return ERR_OK;
 801343c:	2300      	movs	r3, #0
 801343e:	e147      	b.n	80136d0 <ip4_input+0x2b8>
    return ERR_OK;
  }
#endif

  /* obtain IP header length in bytes */
  iphdr_hlen = IPH_HL_BYTES(iphdr);
 8013440:	693b      	ldr	r3, [r7, #16]
 8013442:	781b      	ldrb	r3, [r3, #0]
 8013444:	220f      	movs	r2, #15
 8013446:	4013      	ands	r3, r2
 8013448:	b2db      	uxtb	r3, r3
 801344a:	009b      	lsls	r3, r3, #2
 801344c:	b2da      	uxtb	r2, r3
 801344e:	2316      	movs	r3, #22
 8013450:	18fb      	adds	r3, r7, r3
 8013452:	801a      	strh	r2, [r3, #0]
  /* obtain ip length in bytes */
  iphdr_len = lwip_ntohs(IPH_LEN(iphdr));
 8013454:	693b      	ldr	r3, [r7, #16]
 8013456:	789a      	ldrb	r2, [r3, #2]
 8013458:	78db      	ldrb	r3, [r3, #3]
 801345a:	021b      	lsls	r3, r3, #8
 801345c:	4313      	orrs	r3, r2
 801345e:	b29b      	uxth	r3, r3
 8013460:	2514      	movs	r5, #20
 8013462:	197c      	adds	r4, r7, r5
 8013464:	0018      	movs	r0, r3
 8013466:	f7f3 fbcf 	bl	8006c08 <lwip_htons>
 801346a:	0003      	movs	r3, r0
 801346c:	8023      	strh	r3, [r4, #0]

  /* Trim pbuf. This is especially required for packets < 60 bytes. */
  if (iphdr_len < p->tot_len) {
 801346e:	687b      	ldr	r3, [r7, #4]
 8013470:	891b      	ldrh	r3, [r3, #8]
 8013472:	197a      	adds	r2, r7, r5
 8013474:	8812      	ldrh	r2, [r2, #0]
 8013476:	429a      	cmp	r2, r3
 8013478:	d206      	bcs.n	8013488 <ip4_input+0x70>
    pbuf_realloc(p, iphdr_len);
 801347a:	197b      	adds	r3, r7, r5
 801347c:	881a      	ldrh	r2, [r3, #0]
 801347e:	687b      	ldr	r3, [r7, #4]
 8013480:	0011      	movs	r1, r2
 8013482:	0018      	movs	r0, r3
 8013484:	f7f6 f9aa 	bl	80097dc <pbuf_realloc>
  }

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len) || (iphdr_hlen < IP_HLEN)) {
 8013488:	687b      	ldr	r3, [r7, #4]
 801348a:	895b      	ldrh	r3, [r3, #10]
 801348c:	2116      	movs	r1, #22
 801348e:	187a      	adds	r2, r7, r1
 8013490:	8812      	ldrh	r2, [r2, #0]
 8013492:	429a      	cmp	r2, r3
 8013494:	d80a      	bhi.n	80134ac <ip4_input+0x94>
 8013496:	687b      	ldr	r3, [r7, #4]
 8013498:	891b      	ldrh	r3, [r3, #8]
 801349a:	2214      	movs	r2, #20
 801349c:	18ba      	adds	r2, r7, r2
 801349e:	8812      	ldrh	r2, [r2, #0]
 80134a0:	429a      	cmp	r2, r3
 80134a2:	d803      	bhi.n	80134ac <ip4_input+0x94>
 80134a4:	187b      	adds	r3, r7, r1
 80134a6:	881b      	ldrh	r3, [r3, #0]
 80134a8:	2b13      	cmp	r3, #19
 80134aa:	d805      	bhi.n	80134b8 <ip4_input+0xa0>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                  ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
                   iphdr_len, p->tot_len));
    }
    /* free (drop) packet pbufs */
    pbuf_free(p);
 80134ac:	687b      	ldr	r3, [r7, #4]
 80134ae:	0018      	movs	r0, r3
 80134b0:	f7f6 fb8e 	bl	8009bd0 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    MIB2_STATS_INC(mib2.ipindiscards);
    return ERR_OK;
 80134b4:	2300      	movs	r3, #0
 80134b6:	e10b      	b.n	80136d0 <ip4_input+0x2b8>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_IP) {
    if (inet_chksum(iphdr, iphdr_hlen) != 0) {
 80134b8:	2316      	movs	r3, #22
 80134ba:	18fb      	adds	r3, r7, r3
 80134bc:	881a      	ldrh	r2, [r3, #0]
 80134be:	693b      	ldr	r3, [r7, #16]
 80134c0:	0011      	movs	r1, r2
 80134c2:	0018      	movs	r0, r3
 80134c4:	f7f4 ff66 	bl	8008394 <inet_chksum>
 80134c8:	1e03      	subs	r3, r0, #0
 80134ca:	d005      	beq.n	80134d8 <ip4_input+0xc0>

      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                  ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
      ip4_debug_print(p);
      pbuf_free(p);
 80134cc:	687b      	ldr	r3, [r7, #4]
 80134ce:	0018      	movs	r0, r3
 80134d0:	f7f6 fb7e 	bl	8009bd0 <pbuf_free>
      IP_STATS_INC(ip.chkerr);
      IP_STATS_INC(ip.drop);
      MIB2_STATS_INC(mib2.ipinhdrerrors);
      return ERR_OK;
 80134d4:	2300      	movs	r3, #0
 80134d6:	e0fb      	b.n	80136d0 <ip4_input+0x2b8>
    }
  }
#endif

  /* copy IP addresses to aligned ip_addr_t */
  ip_addr_copy_from_ip4(ip_data.current_iphdr_dest, iphdr->dest);
 80134d8:	693b      	ldr	r3, [r7, #16]
 80134da:	7c1a      	ldrb	r2, [r3, #16]
 80134dc:	7c59      	ldrb	r1, [r3, #17]
 80134de:	0209      	lsls	r1, r1, #8
 80134e0:	430a      	orrs	r2, r1
 80134e2:	7c99      	ldrb	r1, [r3, #18]
 80134e4:	0409      	lsls	r1, r1, #16
 80134e6:	430a      	orrs	r2, r1
 80134e8:	7cdb      	ldrb	r3, [r3, #19]
 80134ea:	061b      	lsls	r3, r3, #24
 80134ec:	4313      	orrs	r3, r2
 80134ee:	001a      	movs	r2, r3
 80134f0:	4b79      	ldr	r3, [pc, #484]	; (80136d8 <ip4_input+0x2c0>)
 80134f2:	615a      	str	r2, [r3, #20]
  ip_addr_copy_from_ip4(ip_data.current_iphdr_src, iphdr->src);
 80134f4:	693b      	ldr	r3, [r7, #16]
 80134f6:	7b1a      	ldrb	r2, [r3, #12]
 80134f8:	7b59      	ldrb	r1, [r3, #13]
 80134fa:	0209      	lsls	r1, r1, #8
 80134fc:	430a      	orrs	r2, r1
 80134fe:	7b99      	ldrb	r1, [r3, #14]
 8013500:	0409      	lsls	r1, r1, #16
 8013502:	430a      	orrs	r2, r1
 8013504:	7bdb      	ldrb	r3, [r3, #15]
 8013506:	061b      	lsls	r3, r3, #24
 8013508:	4313      	orrs	r3, r2
 801350a:	001a      	movs	r2, r3
 801350c:	4b72      	ldr	r3, [pc, #456]	; (80136d8 <ip4_input+0x2c0>)
 801350e:	611a      	str	r2, [r3, #16]

  /* match packet against an interface, i.e. is this packet for us? */
  if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
 8013510:	4b71      	ldr	r3, [pc, #452]	; (80136d8 <ip4_input+0x2c0>)
 8013512:	695b      	ldr	r3, [r3, #20]
 8013514:	22f0      	movs	r2, #240	; 0xf0
 8013516:	4013      	ands	r3, r2
 8013518:	2be0      	cmp	r3, #224	; 0xe0
 801351a:	d113      	bne.n	8013544 <ip4_input+0x12c>
      netif = inp;
    } else {
      netif = NULL;
    }
#else /* LWIP_IGMP */
    if ((netif_is_up(inp)) && (!ip4_addr_isany_val(*netif_ip4_addr(inp)))) {
 801351c:	683b      	ldr	r3, [r7, #0]
 801351e:	2231      	movs	r2, #49	; 0x31
 8013520:	5c9b      	ldrb	r3, [r3, r2]
 8013522:	1c1a      	adds	r2, r3, #0
 8013524:	2301      	movs	r3, #1
 8013526:	4013      	ands	r3, r2
 8013528:	b2db      	uxtb	r3, r3
 801352a:	2b00      	cmp	r3, #0
 801352c:	d007      	beq.n	801353e <ip4_input+0x126>
 801352e:	683b      	ldr	r3, [r7, #0]
 8013530:	3304      	adds	r3, #4
 8013532:	681b      	ldr	r3, [r3, #0]
 8013534:	2b00      	cmp	r3, #0
 8013536:	d002      	beq.n	801353e <ip4_input+0x126>
      netif = inp;
 8013538:	683b      	ldr	r3, [r7, #0]
 801353a:	60fb      	str	r3, [r7, #12]
 801353c:	e02b      	b.n	8013596 <ip4_input+0x17e>
    } else {
      netif = NULL;
 801353e:	2300      	movs	r3, #0
 8013540:	60fb      	str	r3, [r7, #12]
 8013542:	e028      	b.n	8013596 <ip4_input+0x17e>
    }
#endif /* LWIP_IGMP */
  } else {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs. */
    if (ip4_input_accept(inp)) {
 8013544:	683b      	ldr	r3, [r7, #0]
 8013546:	0018      	movs	r0, r3
 8013548:	f7ff ff3a 	bl	80133c0 <ip4_input_accept>
 801354c:	1e03      	subs	r3, r0, #0
 801354e:	d002      	beq.n	8013556 <ip4_input+0x13e>
      netif = inp;
 8013550:	683b      	ldr	r3, [r7, #0]
 8013552:	60fb      	str	r3, [r7, #12]
 8013554:	e01f      	b.n	8013596 <ip4_input+0x17e>
    } else {
      netif = NULL;
 8013556:	2300      	movs	r3, #0
 8013558:	60fb      	str	r3, [r7, #12]
#if !LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF
      /* Packets sent to the loopback address must not be accepted on an
       * interface that does not have the loopback address assigned to it,
       * unless a non-loopback interface is used for loopback traffic. */
      if (!ip4_addr_isloopback(ip4_current_dest_addr()))
 801355a:	4b5f      	ldr	r3, [pc, #380]	; (80136d8 <ip4_input+0x2c0>)
 801355c:	695b      	ldr	r3, [r3, #20]
 801355e:	22ff      	movs	r2, #255	; 0xff
 8013560:	4013      	ands	r3, r2
 8013562:	2b7f      	cmp	r3, #127	; 0x7f
 8013564:	d017      	beq.n	8013596 <ip4_input+0x17e>
#endif /* !LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF */
      {
#if !LWIP_SINGLE_NETIF
        NETIF_FOREACH(netif) {
 8013566:	4b5d      	ldr	r3, [pc, #372]	; (80136dc <ip4_input+0x2c4>)
 8013568:	681b      	ldr	r3, [r3, #0]
 801356a:	60fb      	str	r3, [r7, #12]
 801356c:	e00e      	b.n	801358c <ip4_input+0x174>
          if (netif == inp) {
 801356e:	68fa      	ldr	r2, [r7, #12]
 8013570:	683b      	ldr	r3, [r7, #0]
 8013572:	429a      	cmp	r2, r3
 8013574:	d006      	beq.n	8013584 <ip4_input+0x16c>
            /* we checked that before already */
            continue;
          }
          if (ip4_input_accept(netif)) {
 8013576:	68fb      	ldr	r3, [r7, #12]
 8013578:	0018      	movs	r0, r3
 801357a:	f7ff ff21 	bl	80133c0 <ip4_input_accept>
 801357e:	1e03      	subs	r3, r0, #0
 8013580:	d108      	bne.n	8013594 <ip4_input+0x17c>
 8013582:	e000      	b.n	8013586 <ip4_input+0x16e>
            continue;
 8013584:	46c0      	nop			; (mov r8, r8)
        NETIF_FOREACH(netif) {
 8013586:	68fb      	ldr	r3, [r7, #12]
 8013588:	681b      	ldr	r3, [r3, #0]
 801358a:	60fb      	str	r3, [r7, #12]
 801358c:	68fb      	ldr	r3, [r7, #12]
 801358e:	2b00      	cmp	r3, #0
 8013590:	d1ed      	bne.n	801356e <ip4_input+0x156>
 8013592:	e000      	b.n	8013596 <ip4_input+0x17e>
            break;
 8013594:	46c0      	nop			; (mov r8, r8)
      && !ip4_addr_isany_val(*ip4_current_src_addr())
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
     )
#endif /* LWIP_IGMP || IP_ACCEPT_LINK_LAYER_ADDRESSING */
  {
    if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
 8013596:	4b50      	ldr	r3, [pc, #320]	; (80136d8 <ip4_input+0x2c0>)
 8013598:	691b      	ldr	r3, [r3, #16]
 801359a:	683a      	ldr	r2, [r7, #0]
 801359c:	0011      	movs	r1, r2
 801359e:	0018      	movs	r0, r3
 80135a0:	f000 fac6 	bl	8013b30 <ip4_addr_isbroadcast_u32>
 80135a4:	1e03      	subs	r3, r0, #0
 80135a6:	d105      	bne.n	80135b4 <ip4_input+0x19c>
        (ip4_addr_ismulticast(ip4_current_src_addr()))) {
 80135a8:	4b4b      	ldr	r3, [pc, #300]	; (80136d8 <ip4_input+0x2c0>)
 80135aa:	691b      	ldr	r3, [r3, #16]
 80135ac:	22f0      	movs	r2, #240	; 0xf0
 80135ae:	4013      	ands	r3, r2
    if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
 80135b0:	2be0      	cmp	r3, #224	; 0xe0
 80135b2:	d105      	bne.n	80135c0 <ip4_input+0x1a8>
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("ip4_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
 80135b4:	687b      	ldr	r3, [r7, #4]
 80135b6:	0018      	movs	r0, r3
 80135b8:	f7f6 fb0a 	bl	8009bd0 <pbuf_free>
      IP_STATS_INC(ip.drop);
      MIB2_STATS_INC(mib2.ipinaddrerrors);
      MIB2_STATS_INC(mib2.ipindiscards);
      return ERR_OK;
 80135bc:	2300      	movs	r3, #0
 80135be:	e087      	b.n	80136d0 <ip4_input+0x2b8>
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
 80135c0:	68fb      	ldr	r3, [r7, #12]
 80135c2:	2b00      	cmp	r3, #0
 80135c4:	d105      	bne.n	80135d2 <ip4_input+0x1ba>
    {
      IP_STATS_INC(ip.drop);
      MIB2_STATS_INC(mib2.ipinaddrerrors);
      MIB2_STATS_INC(mib2.ipindiscards);
    }
    pbuf_free(p);
 80135c6:	687b      	ldr	r3, [r7, #4]
 80135c8:	0018      	movs	r0, r3
 80135ca:	f7f6 fb01 	bl	8009bd0 <pbuf_free>
    return ERR_OK;
 80135ce:	2300      	movs	r3, #0
 80135d0:	e07e      	b.n	80136d0 <ip4_input+0x2b8>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
 80135d2:	693b      	ldr	r3, [r7, #16]
 80135d4:	799a      	ldrb	r2, [r3, #6]
 80135d6:	79db      	ldrb	r3, [r3, #7]
 80135d8:	021b      	lsls	r3, r3, #8
 80135da:	4313      	orrs	r3, r2
 80135dc:	b29b      	uxth	r3, r3
 80135de:	001a      	movs	r2, r3
 80135e0:	4b3f      	ldr	r3, [pc, #252]	; (80136e0 <ip4_input+0x2c8>)
 80135e2:	4013      	ands	r3, r2
 80135e4:	d005      	beq.n	80135f2 <ip4_input+0x1da>
    if (p == NULL) {
      return ERR_OK;
    }
    iphdr = (const struct ip_hdr *)p->payload;
#else /* IP_REASSEMBLY == 0, no packet fragment reassembly code present */
    pbuf_free(p);
 80135e6:	687b      	ldr	r3, [r7, #4]
 80135e8:	0018      	movs	r0, r3
 80135ea:	f7f6 faf1 	bl	8009bd0 <pbuf_free>
                lwip_ntohs(IPH_OFFSET(iphdr))));
    IP_STATS_INC(ip.opterr);
    IP_STATS_INC(ip.drop);
    /* unsupported protocol feature */
    MIB2_STATS_INC(mib2.ipinunknownprotos);
    return ERR_OK;
 80135ee:	2300      	movs	r3, #0
 80135f0:	e06e      	b.n	80136d0 <ip4_input+0x2b8>
  /* send to upper layers */
  LWIP_DEBUGF(IP_DEBUG, ("ip4_input: \n"));
  ip4_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip4_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

  ip_data.current_netif = netif;
 80135f2:	4b39      	ldr	r3, [pc, #228]	; (80136d8 <ip4_input+0x2c0>)
 80135f4:	68fa      	ldr	r2, [r7, #12]
 80135f6:	601a      	str	r2, [r3, #0]
  ip_data.current_input_netif = inp;
 80135f8:	4b37      	ldr	r3, [pc, #220]	; (80136d8 <ip4_input+0x2c0>)
 80135fa:	683a      	ldr	r2, [r7, #0]
 80135fc:	605a      	str	r2, [r3, #4]
  ip_data.current_ip4_header = iphdr;
 80135fe:	4b36      	ldr	r3, [pc, #216]	; (80136d8 <ip4_input+0x2c0>)
 8013600:	693a      	ldr	r2, [r7, #16]
 8013602:	609a      	str	r2, [r3, #8]
  ip_data.current_ip_header_tot_len = IPH_HL_BYTES(iphdr);
 8013604:	693b      	ldr	r3, [r7, #16]
 8013606:	781b      	ldrb	r3, [r3, #0]
 8013608:	220f      	movs	r2, #15
 801360a:	4013      	ands	r3, r2
 801360c:	b2db      	uxtb	r3, r3
 801360e:	009b      	lsls	r3, r3, #2
 8013610:	b2db      	uxtb	r3, r3
 8013612:	b29a      	uxth	r2, r3
 8013614:	4b30      	ldr	r3, [pc, #192]	; (80136d8 <ip4_input+0x2c0>)
 8013616:	819a      	strh	r2, [r3, #12]
  /* raw input did not eat the packet? */
  raw_status = raw_input(p, inp);
  if (raw_status != RAW_INPUT_EATEN)
#endif /* LWIP_RAW */
  {
    pbuf_remove_header(p, iphdr_hlen); /* Move to payload, no check necessary. */
 8013618:	2316      	movs	r3, #22
 801361a:	18fb      	adds	r3, r7, r3
 801361c:	881a      	ldrh	r2, [r3, #0]
 801361e:	687b      	ldr	r3, [r7, #4]
 8013620:	0011      	movs	r1, r2
 8013622:	0018      	movs	r0, r3
 8013624:	f7f6 f9fc 	bl	8009a20 <pbuf_remove_header>

    switch (IPH_PROTO(iphdr)) {
 8013628:	693b      	ldr	r3, [r7, #16]
 801362a:	7a5b      	ldrb	r3, [r3, #9]
 801362c:	2b11      	cmp	r3, #17
 801362e:	d005      	beq.n	801363c <ip4_input+0x224>
 8013630:	dc19      	bgt.n	8013666 <ip4_input+0x24e>
 8013632:	2b01      	cmp	r3, #1
 8013634:	d010      	beq.n	8013658 <ip4_input+0x240>
 8013636:	2b06      	cmp	r3, #6
 8013638:	d007      	beq.n	801364a <ip4_input+0x232>
 801363a:	e014      	b.n	8013666 <ip4_input+0x24e>
      case IP_PROTO_UDP:
#if LWIP_UDPLITE
      case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
        MIB2_STATS_INC(mib2.ipindelivers);
        udp_input(p, inp);
 801363c:	683a      	ldr	r2, [r7, #0]
 801363e:	687b      	ldr	r3, [r7, #4]
 8013640:	0011      	movs	r1, r2
 8013642:	0018      	movs	r0, r3
 8013644:	f7fe fe80 	bl	8012348 <udp_input>
        break;
 8013648:	e02f      	b.n	80136aa <ip4_input+0x292>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case IP_PROTO_TCP:
        MIB2_STATS_INC(mib2.ipindelivers);
        tcp_input(p, inp);
 801364a:	683a      	ldr	r2, [r7, #0]
 801364c:	687b      	ldr	r3, [r7, #4]
 801364e:	0011      	movs	r1, r2
 8013650:	0018      	movs	r0, r3
 8013652:	f7f8 ffd5 	bl	800c600 <tcp_input>
        break;
 8013656:	e028      	b.n	80136aa <ip4_input+0x292>
#endif /* LWIP_TCP */
#if LWIP_ICMP
      case IP_PROTO_ICMP:
        MIB2_STATS_INC(mib2.ipindelivers);
        icmp_input(p, inp);
 8013658:	683a      	ldr	r2, [r7, #0]
 801365a:	687b      	ldr	r3, [r7, #4]
 801365c:	0011      	movs	r1, r2
 801365e:	0018      	movs	r0, r3
 8013660:	f7ff fb88 	bl	8012d74 <icmp_input>
        break;
 8013664:	e021      	b.n	80136aa <ip4_input+0x292>
        } else
#endif /* LWIP_RAW */
        {
#if LWIP_ICMP
          /* send ICMP destination protocol unreachable unless is was a broadcast */
          if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
 8013666:	4b1c      	ldr	r3, [pc, #112]	; (80136d8 <ip4_input+0x2c0>)
 8013668:	695b      	ldr	r3, [r3, #20]
 801366a:	68fa      	ldr	r2, [r7, #12]
 801366c:	0011      	movs	r1, r2
 801366e:	0018      	movs	r0, r3
 8013670:	f000 fa5e 	bl	8013b30 <ip4_addr_isbroadcast_u32>
 8013674:	1e03      	subs	r3, r0, #0
 8013676:	d113      	bne.n	80136a0 <ip4_input+0x288>
              !ip4_addr_ismulticast(ip4_current_dest_addr())) {
 8013678:	4b17      	ldr	r3, [pc, #92]	; (80136d8 <ip4_input+0x2c0>)
 801367a:	695b      	ldr	r3, [r3, #20]
 801367c:	22f0      	movs	r2, #240	; 0xf0
 801367e:	4013      	ands	r3, r2
          if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
 8013680:	2be0      	cmp	r3, #224	; 0xe0
 8013682:	d00d      	beq.n	80136a0 <ip4_input+0x288>
            pbuf_header_force(p, (s16_t)iphdr_hlen); /* Move to ip header, no check necessary. */
 8013684:	2316      	movs	r3, #22
 8013686:	18fb      	adds	r3, r7, r3
 8013688:	2200      	movs	r2, #0
 801368a:	5e9a      	ldrsh	r2, [r3, r2]
 801368c:	687b      	ldr	r3, [r7, #4]
 801368e:	0011      	movs	r1, r2
 8013690:	0018      	movs	r0, r3
 8013692:	f7f6 fa46 	bl	8009b22 <pbuf_header_force>
            icmp_dest_unreach(p, ICMP_DUR_PROTO);
 8013696:	687b      	ldr	r3, [r7, #4]
 8013698:	2102      	movs	r1, #2
 801369a:	0018      	movs	r0, r3
 801369c:	f7ff fd50 	bl	8013140 <icmp_dest_unreach>

          IP_STATS_INC(ip.proterr);
          IP_STATS_INC(ip.drop);
          MIB2_STATS_INC(mib2.ipinunknownprotos);
        }
        pbuf_free(p);
 80136a0:	687b      	ldr	r3, [r7, #4]
 80136a2:	0018      	movs	r0, r3
 80136a4:	f7f6 fa94 	bl	8009bd0 <pbuf_free>
        break;
 80136a8:	46c0      	nop			; (mov r8, r8)
    }
  }

  /* @todo: this is not really necessary... */
  ip_data.current_netif = NULL;
 80136aa:	4b0b      	ldr	r3, [pc, #44]	; (80136d8 <ip4_input+0x2c0>)
 80136ac:	2200      	movs	r2, #0
 80136ae:	601a      	str	r2, [r3, #0]
  ip_data.current_input_netif = NULL;
 80136b0:	4b09      	ldr	r3, [pc, #36]	; (80136d8 <ip4_input+0x2c0>)
 80136b2:	2200      	movs	r2, #0
 80136b4:	605a      	str	r2, [r3, #4]
  ip_data.current_ip4_header = NULL;
 80136b6:	4b08      	ldr	r3, [pc, #32]	; (80136d8 <ip4_input+0x2c0>)
 80136b8:	2200      	movs	r2, #0
 80136ba:	609a      	str	r2, [r3, #8]
  ip_data.current_ip_header_tot_len = 0;
 80136bc:	4b06      	ldr	r3, [pc, #24]	; (80136d8 <ip4_input+0x2c0>)
 80136be:	2200      	movs	r2, #0
 80136c0:	819a      	strh	r2, [r3, #12]
  ip4_addr_set_any(ip4_current_src_addr());
 80136c2:	4b05      	ldr	r3, [pc, #20]	; (80136d8 <ip4_input+0x2c0>)
 80136c4:	2200      	movs	r2, #0
 80136c6:	611a      	str	r2, [r3, #16]
  ip4_addr_set_any(ip4_current_dest_addr());
 80136c8:	4b03      	ldr	r3, [pc, #12]	; (80136d8 <ip4_input+0x2c0>)
 80136ca:	2200      	movs	r2, #0
 80136cc:	615a      	str	r2, [r3, #20]

  return ERR_OK;
 80136ce:	2300      	movs	r3, #0
}
 80136d0:	0018      	movs	r0, r3
 80136d2:	46bd      	mov	sp, r7
 80136d4:	b006      	add	sp, #24
 80136d6:	bdb0      	pop	{r4, r5, r7, pc}
 80136d8:	20001c94 	.word	0x20001c94
 80136dc:	20002ec4 	.word	0x20002ec4
 80136e0:	0000ff3f 	.word	0x0000ff3f

080136e4 <ip4_output_if>:
 */
err_t
ip4_output_if(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
              u8_t ttl, u8_t tos,
              u8_t proto, struct netif *netif)
{
 80136e4:	b590      	push	{r4, r7, lr}
 80136e6:	b08b      	sub	sp, #44	; 0x2c
 80136e8:	af04      	add	r7, sp, #16
 80136ea:	60f8      	str	r0, [r7, #12]
 80136ec:	60b9      	str	r1, [r7, #8]
 80136ee:	607a      	str	r2, [r7, #4]
 80136f0:	001a      	movs	r2, r3
 80136f2:	1cfb      	adds	r3, r7, #3
 80136f4:	701a      	strb	r2, [r3, #0]
ip4_output_if_opt(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
                  u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
                  u16_t optlen)
{
#endif /* IP_OPTIONS_SEND */
  const ip4_addr_t *src_used = src;
 80136f6:	68bb      	ldr	r3, [r7, #8]
 80136f8:	617b      	str	r3, [r7, #20]
  if (dest != LWIP_IP_HDRINCL) {
 80136fa:	687b      	ldr	r3, [r7, #4]
 80136fc:	2b00      	cmp	r3, #0
 80136fe:	d009      	beq.n	8013714 <ip4_output_if+0x30>
    if (ip4_addr_isany(src)) {
 8013700:	68bb      	ldr	r3, [r7, #8]
 8013702:	2b00      	cmp	r3, #0
 8013704:	d003      	beq.n	801370e <ip4_output_if+0x2a>
 8013706:	68bb      	ldr	r3, [r7, #8]
 8013708:	681b      	ldr	r3, [r3, #0]
 801370a:	2b00      	cmp	r3, #0
 801370c:	d102      	bne.n	8013714 <ip4_output_if+0x30>
      src_used = netif_ip4_addr(netif);
 801370e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8013710:	3304      	adds	r3, #4
 8013712:	617b      	str	r3, [r7, #20]

#if IP_OPTIONS_SEND
  return ip4_output_if_opt_src(p, src_used, dest, ttl, tos, proto, netif,
                               ip_options, optlen);
#else /* IP_OPTIONS_SEND */
  return ip4_output_if_src(p, src_used, dest, ttl, tos, proto, netif);
 8013714:	1cfb      	adds	r3, r7, #3
 8013716:	781c      	ldrb	r4, [r3, #0]
 8013718:	687a      	ldr	r2, [r7, #4]
 801371a:	6979      	ldr	r1, [r7, #20]
 801371c:	68f8      	ldr	r0, [r7, #12]
 801371e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8013720:	9302      	str	r3, [sp, #8]
 8013722:	232c      	movs	r3, #44	; 0x2c
 8013724:	18fb      	adds	r3, r7, r3
 8013726:	781b      	ldrb	r3, [r3, #0]
 8013728:	9301      	str	r3, [sp, #4]
 801372a:	2328      	movs	r3, #40	; 0x28
 801372c:	18fb      	adds	r3, r7, r3
 801372e:	781b      	ldrb	r3, [r3, #0]
 8013730:	9300      	str	r3, [sp, #0]
 8013732:	0023      	movs	r3, r4
 8013734:	f000 f806 	bl	8013744 <ip4_output_if_src>
 8013738:	0003      	movs	r3, r0
#endif /* IP_OPTIONS_SEND */
}
 801373a:	0018      	movs	r0, r3
 801373c:	46bd      	mov	sp, r7
 801373e:	b007      	add	sp, #28
 8013740:	bd90      	pop	{r4, r7, pc}
	...

08013744 <ip4_output_if_src>:
 */
err_t
ip4_output_if_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
                  u8_t ttl, u8_t tos,
                  u8_t proto, struct netif *netif)
{
 8013744:	b590      	push	{r4, r7, lr}
 8013746:	b089      	sub	sp, #36	; 0x24
 8013748:	af00      	add	r7, sp, #0
 801374a:	60f8      	str	r0, [r7, #12]
 801374c:	60b9      	str	r1, [r7, #8]
 801374e:	607a      	str	r2, [r7, #4]
 8013750:	001a      	movs	r2, r3
 8013752:	1cfb      	adds	r3, r7, #3
 8013754:	701a      	strb	r2, [r3, #0]
{
#endif /* IP_OPTIONS_SEND */
  struct ip_hdr *iphdr;
  ip4_addr_t dest_addr;
#if CHECKSUM_GEN_IP_INLINE
  u32_t chk_sum = 0;
 8013756:	2300      	movs	r3, #0
 8013758:	61fb      	str	r3, [r7, #28]
#endif /* CHECKSUM_GEN_IP_INLINE */

  LWIP_ASSERT_CORE_LOCKED();
  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
 801375a:	68fb      	ldr	r3, [r7, #12]
 801375c:	7b9b      	ldrb	r3, [r3, #14]
 801375e:	2b01      	cmp	r3, #1
 8013760:	d006      	beq.n	8013770 <ip4_output_if_src+0x2c>
 8013762:	4bde      	ldr	r3, [pc, #888]	; (8013adc <ip4_output_if_src+0x398>)
 8013764:	22d5      	movs	r2, #213	; 0xd5
 8013766:	0092      	lsls	r2, r2, #2
 8013768:	49dd      	ldr	r1, [pc, #884]	; (8013ae0 <ip4_output_if_src+0x39c>)
 801376a:	48de      	ldr	r0, [pc, #888]	; (8013ae4 <ip4_output_if_src+0x3a0>)
 801376c:	f7ef f8b6 	bl	80028dc <app_debug_rtt_raw>

  MIB2_STATS_INC(mib2.ipoutrequests);

  /* Should the IP header be generated or is it already included in p? */
  if (dest != LWIP_IP_HDRINCL) {
 8013770:	687b      	ldr	r3, [r7, #4]
 8013772:	2b00      	cmp	r3, #0
 8013774:	d100      	bne.n	8013778 <ip4_output_if_src+0x34>
 8013776:	e1aa      	b.n	8013ace <ip4_output_if_src+0x38a>
    u16_t ip_hlen = IP_HLEN;
 8013778:	2316      	movs	r3, #22
 801377a:	18fb      	adds	r3, r7, r3
 801377c:	2214      	movs	r2, #20
 801377e:	801a      	strh	r2, [r3, #0]
      }
#endif /* CHECKSUM_GEN_IP_INLINE */
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_add_header(p, IP_HLEN)) {
 8013780:	68fb      	ldr	r3, [r7, #12]
 8013782:	2114      	movs	r1, #20
 8013784:	0018      	movs	r0, r3
 8013786:	f7f6 f93b 	bl	8009a00 <pbuf_add_header>
 801378a:	1e03      	subs	r3, r0, #0
 801378c:	d002      	beq.n	8013794 <ip4_output_if_src+0x50>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      MIB2_STATS_INC(mib2.ipoutdiscards);
      return ERR_BUF;
 801378e:	2302      	movs	r3, #2
 8013790:	425b      	negs	r3, r3
 8013792:	e1c8      	b.n	8013b26 <ip4_output_if_src+0x3e2>
    }

    iphdr = (struct ip_hdr *)p->payload;
 8013794:	68fb      	ldr	r3, [r7, #12]
 8013796:	685b      	ldr	r3, [r3, #4]
 8013798:	61bb      	str	r3, [r7, #24]
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
 801379a:	68fb      	ldr	r3, [r7, #12]
 801379c:	895b      	ldrh	r3, [r3, #10]
 801379e:	2b13      	cmp	r3, #19
 80137a0:	d806      	bhi.n	80137b0 <ip4_output_if_src+0x6c>
 80137a2:	4bce      	ldr	r3, [pc, #824]	; (8013adc <ip4_output_if_src+0x398>)
 80137a4:	22e2      	movs	r2, #226	; 0xe2
 80137a6:	0092      	lsls	r2, r2, #2
 80137a8:	49cf      	ldr	r1, [pc, #828]	; (8013ae8 <ip4_output_if_src+0x3a4>)
 80137aa:	48ce      	ldr	r0, [pc, #824]	; (8013ae4 <ip4_output_if_src+0x3a0>)
 80137ac:	f7ef f896 	bl	80028dc <app_debug_rtt_raw>
                (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
 80137b0:	69bb      	ldr	r3, [r7, #24]
 80137b2:	1cfa      	adds	r2, r7, #3
 80137b4:	7812      	ldrb	r2, [r2, #0]
 80137b6:	721a      	strb	r2, [r3, #8]
    IPH_PROTO_SET(iphdr, proto);
 80137b8:	69bb      	ldr	r3, [r7, #24]
 80137ba:	2134      	movs	r1, #52	; 0x34
 80137bc:	187a      	adds	r2, r7, r1
 80137be:	7812      	ldrb	r2, [r2, #0]
 80137c0:	725a      	strb	r2, [r3, #9]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += PP_NTOHS(proto | (ttl << 8));
 80137c2:	187b      	adds	r3, r7, r1
 80137c4:	781a      	ldrb	r2, [r3, #0]
 80137c6:	1cfb      	adds	r3, r7, #3
 80137c8:	781b      	ldrb	r3, [r3, #0]
 80137ca:	021b      	lsls	r3, r3, #8
 80137cc:	4313      	orrs	r3, r2
 80137ce:	021b      	lsls	r3, r3, #8
 80137d0:	b21a      	sxth	r2, r3
 80137d2:	187b      	adds	r3, r7, r1
 80137d4:	7819      	ldrb	r1, [r3, #0]
 80137d6:	1cfb      	adds	r3, r7, #3
 80137d8:	781b      	ldrb	r3, [r3, #0]
 80137da:	021b      	lsls	r3, r3, #8
 80137dc:	430b      	orrs	r3, r1
 80137de:	121b      	asrs	r3, r3, #8
 80137e0:	b21b      	sxth	r3, r3
 80137e2:	21ff      	movs	r1, #255	; 0xff
 80137e4:	400b      	ands	r3, r1
 80137e6:	b21b      	sxth	r3, r3
 80137e8:	4313      	orrs	r3, r2
 80137ea:	b21b      	sxth	r3, r3
 80137ec:	b29b      	uxth	r3, r3
 80137ee:	001a      	movs	r2, r3
 80137f0:	69fb      	ldr	r3, [r7, #28]
 80137f2:	189b      	adds	r3, r3, r2
 80137f4:	61fb      	str	r3, [r7, #28]
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip4_addr_copy(iphdr->dest, *dest);
 80137f6:	687b      	ldr	r3, [r7, #4]
 80137f8:	681a      	ldr	r2, [r3, #0]
 80137fa:	69bb      	ldr	r3, [r7, #24]
 80137fc:	21ff      	movs	r1, #255	; 0xff
 80137fe:	4011      	ands	r1, r2
 8013800:	000c      	movs	r4, r1
 8013802:	7c19      	ldrb	r1, [r3, #16]
 8013804:	2000      	movs	r0, #0
 8013806:	4001      	ands	r1, r0
 8013808:	1c08      	adds	r0, r1, #0
 801380a:	1c21      	adds	r1, r4, #0
 801380c:	4301      	orrs	r1, r0
 801380e:	7419      	strb	r1, [r3, #16]
 8013810:	0a11      	lsrs	r1, r2, #8
 8013812:	20ff      	movs	r0, #255	; 0xff
 8013814:	4001      	ands	r1, r0
 8013816:	000c      	movs	r4, r1
 8013818:	7c59      	ldrb	r1, [r3, #17]
 801381a:	2000      	movs	r0, #0
 801381c:	4001      	ands	r1, r0
 801381e:	1c08      	adds	r0, r1, #0
 8013820:	1c21      	adds	r1, r4, #0
 8013822:	4301      	orrs	r1, r0
 8013824:	7459      	strb	r1, [r3, #17]
 8013826:	0c11      	lsrs	r1, r2, #16
 8013828:	20ff      	movs	r0, #255	; 0xff
 801382a:	4001      	ands	r1, r0
 801382c:	000c      	movs	r4, r1
 801382e:	7c99      	ldrb	r1, [r3, #18]
 8013830:	2000      	movs	r0, #0
 8013832:	4001      	ands	r1, r0
 8013834:	1c08      	adds	r0, r1, #0
 8013836:	1c21      	adds	r1, r4, #0
 8013838:	4301      	orrs	r1, r0
 801383a:	7499      	strb	r1, [r3, #18]
 801383c:	0e10      	lsrs	r0, r2, #24
 801383e:	7cda      	ldrb	r2, [r3, #19]
 8013840:	2100      	movs	r1, #0
 8013842:	400a      	ands	r2, r1
 8013844:	1c11      	adds	r1, r2, #0
 8013846:	1c02      	adds	r2, r0, #0
 8013848:	430a      	orrs	r2, r1
 801384a:	74da      	strb	r2, [r3, #19]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
 801384c:	69bb      	ldr	r3, [r7, #24]
 801384e:	7c1a      	ldrb	r2, [r3, #16]
 8013850:	7c59      	ldrb	r1, [r3, #17]
 8013852:	0209      	lsls	r1, r1, #8
 8013854:	430a      	orrs	r2, r1
 8013856:	7c99      	ldrb	r1, [r3, #18]
 8013858:	0409      	lsls	r1, r1, #16
 801385a:	430a      	orrs	r2, r1
 801385c:	7cdb      	ldrb	r3, [r3, #19]
 801385e:	061b      	lsls	r3, r3, #24
 8013860:	4313      	orrs	r3, r2
 8013862:	041b      	lsls	r3, r3, #16
 8013864:	0c1b      	lsrs	r3, r3, #16
 8013866:	69fa      	ldr	r2, [r7, #28]
 8013868:	18d3      	adds	r3, r2, r3
 801386a:	61fb      	str	r3, [r7, #28]
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
 801386c:	69bb      	ldr	r3, [r7, #24]
 801386e:	7c1a      	ldrb	r2, [r3, #16]
 8013870:	7c59      	ldrb	r1, [r3, #17]
 8013872:	0209      	lsls	r1, r1, #8
 8013874:	430a      	orrs	r2, r1
 8013876:	7c99      	ldrb	r1, [r3, #18]
 8013878:	0409      	lsls	r1, r1, #16
 801387a:	430a      	orrs	r2, r1
 801387c:	7cdb      	ldrb	r3, [r3, #19]
 801387e:	061b      	lsls	r3, r3, #24
 8013880:	4313      	orrs	r3, r2
 8013882:	0c1b      	lsrs	r3, r3, #16
 8013884:	69fa      	ldr	r2, [r7, #28]
 8013886:	18d3      	adds	r3, r2, r3
 8013888:	61fb      	str	r3, [r7, #28]
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
 801388a:	2316      	movs	r3, #22
 801388c:	18fb      	adds	r3, r7, r3
 801388e:	881b      	ldrh	r3, [r3, #0]
 8013890:	089b      	lsrs	r3, r3, #2
 8013892:	b29b      	uxth	r3, r3
 8013894:	b2db      	uxtb	r3, r3
 8013896:	2240      	movs	r2, #64	; 0x40
 8013898:	4313      	orrs	r3, r2
 801389a:	b2da      	uxtb	r2, r3
 801389c:	69bb      	ldr	r3, [r7, #24]
 801389e:	701a      	strb	r2, [r3, #0]
    IPH_TOS_SET(iphdr, tos);
 80138a0:	69ba      	ldr	r2, [r7, #24]
 80138a2:	2130      	movs	r1, #48	; 0x30
 80138a4:	187b      	adds	r3, r7, r1
 80138a6:	781b      	ldrb	r3, [r3, #0]
 80138a8:	7053      	strb	r3, [r2, #1]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += PP_NTOHS(tos | (iphdr->_v_hl << 8));
 80138aa:	187b      	adds	r3, r7, r1
 80138ac:	781a      	ldrb	r2, [r3, #0]
 80138ae:	69bb      	ldr	r3, [r7, #24]
 80138b0:	781b      	ldrb	r3, [r3, #0]
 80138b2:	021b      	lsls	r3, r3, #8
 80138b4:	4313      	orrs	r3, r2
 80138b6:	021b      	lsls	r3, r3, #8
 80138b8:	b21a      	sxth	r2, r3
 80138ba:	187b      	adds	r3, r7, r1
 80138bc:	7819      	ldrb	r1, [r3, #0]
 80138be:	69bb      	ldr	r3, [r7, #24]
 80138c0:	781b      	ldrb	r3, [r3, #0]
 80138c2:	021b      	lsls	r3, r3, #8
 80138c4:	430b      	orrs	r3, r1
 80138c6:	121b      	asrs	r3, r3, #8
 80138c8:	b21b      	sxth	r3, r3
 80138ca:	21ff      	movs	r1, #255	; 0xff
 80138cc:	400b      	ands	r3, r1
 80138ce:	b21b      	sxth	r3, r3
 80138d0:	4313      	orrs	r3, r2
 80138d2:	b21b      	sxth	r3, r3
 80138d4:	b29b      	uxth	r3, r3
 80138d6:	001a      	movs	r2, r3
 80138d8:	69fb      	ldr	r3, [r7, #28]
 80138da:	189b      	adds	r3, r3, r2
 80138dc:	61fb      	str	r3, [r7, #28]
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, lwip_htons(p->tot_len));
 80138de:	68fb      	ldr	r3, [r7, #12]
 80138e0:	891b      	ldrh	r3, [r3, #8]
 80138e2:	0018      	movs	r0, r3
 80138e4:	f7f3 f990 	bl	8006c08 <lwip_htons>
 80138e8:	0003      	movs	r3, r0
 80138ea:	001a      	movs	r2, r3
 80138ec:	69bb      	ldr	r3, [r7, #24]
 80138ee:	21ff      	movs	r1, #255	; 0xff
 80138f0:	4011      	ands	r1, r2
 80138f2:	000c      	movs	r4, r1
 80138f4:	7899      	ldrb	r1, [r3, #2]
 80138f6:	2000      	movs	r0, #0
 80138f8:	4001      	ands	r1, r0
 80138fa:	1c08      	adds	r0, r1, #0
 80138fc:	1c21      	adds	r1, r4, #0
 80138fe:	4301      	orrs	r1, r0
 8013900:	7099      	strb	r1, [r3, #2]
 8013902:	0a12      	lsrs	r2, r2, #8
 8013904:	b290      	uxth	r0, r2
 8013906:	78da      	ldrb	r2, [r3, #3]
 8013908:	2100      	movs	r1, #0
 801390a:	400a      	ands	r2, r1
 801390c:	1c11      	adds	r1, r2, #0
 801390e:	1c02      	adds	r2, r0, #0
 8013910:	430a      	orrs	r2, r1
 8013912:	70da      	strb	r2, [r3, #3]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
 8013914:	69bb      	ldr	r3, [r7, #24]
 8013916:	789a      	ldrb	r2, [r3, #2]
 8013918:	78db      	ldrb	r3, [r3, #3]
 801391a:	021b      	lsls	r3, r3, #8
 801391c:	4313      	orrs	r3, r2
 801391e:	b29b      	uxth	r3, r3
 8013920:	001a      	movs	r2, r3
 8013922:	69fb      	ldr	r3, [r7, #28]
 8013924:	189b      	adds	r3, r3, r2
 8013926:	61fb      	str	r3, [r7, #28]
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
 8013928:	69bb      	ldr	r3, [r7, #24]
 801392a:	799a      	ldrb	r2, [r3, #6]
 801392c:	2100      	movs	r1, #0
 801392e:	400a      	ands	r2, r1
 8013930:	719a      	strb	r2, [r3, #6]
 8013932:	79da      	ldrb	r2, [r3, #7]
 8013934:	2100      	movs	r1, #0
 8013936:	400a      	ands	r2, r1
 8013938:	71da      	strb	r2, [r3, #7]
    IPH_ID_SET(iphdr, lwip_htons(ip_id));
 801393a:	4b6c      	ldr	r3, [pc, #432]	; (8013aec <ip4_output_if_src+0x3a8>)
 801393c:	881b      	ldrh	r3, [r3, #0]
 801393e:	0018      	movs	r0, r3
 8013940:	f7f3 f962 	bl	8006c08 <lwip_htons>
 8013944:	0003      	movs	r3, r0
 8013946:	001a      	movs	r2, r3
 8013948:	69bb      	ldr	r3, [r7, #24]
 801394a:	21ff      	movs	r1, #255	; 0xff
 801394c:	4011      	ands	r1, r2
 801394e:	000c      	movs	r4, r1
 8013950:	7919      	ldrb	r1, [r3, #4]
 8013952:	2000      	movs	r0, #0
 8013954:	4001      	ands	r1, r0
 8013956:	1c08      	adds	r0, r1, #0
 8013958:	1c21      	adds	r1, r4, #0
 801395a:	4301      	orrs	r1, r0
 801395c:	7119      	strb	r1, [r3, #4]
 801395e:	0a12      	lsrs	r2, r2, #8
 8013960:	b290      	uxth	r0, r2
 8013962:	795a      	ldrb	r2, [r3, #5]
 8013964:	2100      	movs	r1, #0
 8013966:	400a      	ands	r2, r1
 8013968:	1c11      	adds	r1, r2, #0
 801396a:	1c02      	adds	r2, r0, #0
 801396c:	430a      	orrs	r2, r1
 801396e:	715a      	strb	r2, [r3, #5]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
 8013970:	69bb      	ldr	r3, [r7, #24]
 8013972:	791a      	ldrb	r2, [r3, #4]
 8013974:	795b      	ldrb	r3, [r3, #5]
 8013976:	021b      	lsls	r3, r3, #8
 8013978:	4313      	orrs	r3, r2
 801397a:	b29b      	uxth	r3, r3
 801397c:	001a      	movs	r2, r3
 801397e:	69fb      	ldr	r3, [r7, #28]
 8013980:	189b      	adds	r3, r3, r2
 8013982:	61fb      	str	r3, [r7, #28]
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
 8013984:	4b59      	ldr	r3, [pc, #356]	; (8013aec <ip4_output_if_src+0x3a8>)
 8013986:	881b      	ldrh	r3, [r3, #0]
 8013988:	3301      	adds	r3, #1
 801398a:	b29a      	uxth	r2, r3
 801398c:	4b57      	ldr	r3, [pc, #348]	; (8013aec <ip4_output_if_src+0x3a8>)
 801398e:	801a      	strh	r2, [r3, #0]

    if (src == NULL) {
 8013990:	68bb      	ldr	r3, [r7, #8]
 8013992:	2b00      	cmp	r3, #0
 8013994:	d12b      	bne.n	80139ee <ip4_output_if_src+0x2aa>
      ip4_addr_copy(iphdr->src, *IP4_ADDR_ANY4);
 8013996:	4b56      	ldr	r3, [pc, #344]	; (8013af0 <ip4_output_if_src+0x3ac>)
 8013998:	681a      	ldr	r2, [r3, #0]
 801399a:	69bb      	ldr	r3, [r7, #24]
 801399c:	21ff      	movs	r1, #255	; 0xff
 801399e:	4011      	ands	r1, r2
 80139a0:	000c      	movs	r4, r1
 80139a2:	7b19      	ldrb	r1, [r3, #12]
 80139a4:	2000      	movs	r0, #0
 80139a6:	4001      	ands	r1, r0
 80139a8:	1c08      	adds	r0, r1, #0
 80139aa:	1c21      	adds	r1, r4, #0
 80139ac:	4301      	orrs	r1, r0
 80139ae:	7319      	strb	r1, [r3, #12]
 80139b0:	0a11      	lsrs	r1, r2, #8
 80139b2:	20ff      	movs	r0, #255	; 0xff
 80139b4:	4001      	ands	r1, r0
 80139b6:	000c      	movs	r4, r1
 80139b8:	7b59      	ldrb	r1, [r3, #13]
 80139ba:	2000      	movs	r0, #0
 80139bc:	4001      	ands	r1, r0
 80139be:	1c08      	adds	r0, r1, #0
 80139c0:	1c21      	adds	r1, r4, #0
 80139c2:	4301      	orrs	r1, r0
 80139c4:	7359      	strb	r1, [r3, #13]
 80139c6:	0c11      	lsrs	r1, r2, #16
 80139c8:	20ff      	movs	r0, #255	; 0xff
 80139ca:	4001      	ands	r1, r0
 80139cc:	000c      	movs	r4, r1
 80139ce:	7b99      	ldrb	r1, [r3, #14]
 80139d0:	2000      	movs	r0, #0
 80139d2:	4001      	ands	r1, r0
 80139d4:	1c08      	adds	r0, r1, #0
 80139d6:	1c21      	adds	r1, r4, #0
 80139d8:	4301      	orrs	r1, r0
 80139da:	7399      	strb	r1, [r3, #14]
 80139dc:	0e10      	lsrs	r0, r2, #24
 80139de:	7bda      	ldrb	r2, [r3, #15]
 80139e0:	2100      	movs	r1, #0
 80139e2:	400a      	ands	r2, r1
 80139e4:	1c11      	adds	r1, r2, #0
 80139e6:	1c02      	adds	r2, r0, #0
 80139e8:	430a      	orrs	r2, r1
 80139ea:	73da      	strb	r2, [r3, #15]
 80139ec:	e02a      	b.n	8013a44 <ip4_output_if_src+0x300>
    } else {
      /* src cannot be NULL here */
      ip4_addr_copy(iphdr->src, *src);
 80139ee:	68bb      	ldr	r3, [r7, #8]
 80139f0:	681a      	ldr	r2, [r3, #0]
 80139f2:	69bb      	ldr	r3, [r7, #24]
 80139f4:	21ff      	movs	r1, #255	; 0xff
 80139f6:	4011      	ands	r1, r2
 80139f8:	000c      	movs	r4, r1
 80139fa:	7b19      	ldrb	r1, [r3, #12]
 80139fc:	2000      	movs	r0, #0
 80139fe:	4001      	ands	r1, r0
 8013a00:	1c08      	adds	r0, r1, #0
 8013a02:	1c21      	adds	r1, r4, #0
 8013a04:	4301      	orrs	r1, r0
 8013a06:	7319      	strb	r1, [r3, #12]
 8013a08:	0a11      	lsrs	r1, r2, #8
 8013a0a:	20ff      	movs	r0, #255	; 0xff
 8013a0c:	4001      	ands	r1, r0
 8013a0e:	000c      	movs	r4, r1
 8013a10:	7b59      	ldrb	r1, [r3, #13]
 8013a12:	2000      	movs	r0, #0
 8013a14:	4001      	ands	r1, r0
 8013a16:	1c08      	adds	r0, r1, #0
 8013a18:	1c21      	adds	r1, r4, #0
 8013a1a:	4301      	orrs	r1, r0
 8013a1c:	7359      	strb	r1, [r3, #13]
 8013a1e:	0c11      	lsrs	r1, r2, #16
 8013a20:	20ff      	movs	r0, #255	; 0xff
 8013a22:	4001      	ands	r1, r0
 8013a24:	000c      	movs	r4, r1
 8013a26:	7b99      	ldrb	r1, [r3, #14]
 8013a28:	2000      	movs	r0, #0
 8013a2a:	4001      	ands	r1, r0
 8013a2c:	1c08      	adds	r0, r1, #0
 8013a2e:	1c21      	adds	r1, r4, #0
 8013a30:	4301      	orrs	r1, r0
 8013a32:	7399      	strb	r1, [r3, #14]
 8013a34:	0e10      	lsrs	r0, r2, #24
 8013a36:	7bda      	ldrb	r2, [r3, #15]
 8013a38:	2100      	movs	r1, #0
 8013a3a:	400a      	ands	r2, r1
 8013a3c:	1c11      	adds	r1, r2, #0
 8013a3e:	1c02      	adds	r2, r0, #0
 8013a40:	430a      	orrs	r2, r1
 8013a42:	73da      	strb	r2, [r3, #15]
    }

#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
 8013a44:	69bb      	ldr	r3, [r7, #24]
 8013a46:	7b1a      	ldrb	r2, [r3, #12]
 8013a48:	7b59      	ldrb	r1, [r3, #13]
 8013a4a:	0209      	lsls	r1, r1, #8
 8013a4c:	430a      	orrs	r2, r1
 8013a4e:	7b99      	ldrb	r1, [r3, #14]
 8013a50:	0409      	lsls	r1, r1, #16
 8013a52:	430a      	orrs	r2, r1
 8013a54:	7bdb      	ldrb	r3, [r3, #15]
 8013a56:	061b      	lsls	r3, r3, #24
 8013a58:	4313      	orrs	r3, r2
 8013a5a:	041b      	lsls	r3, r3, #16
 8013a5c:	0c1b      	lsrs	r3, r3, #16
 8013a5e:	69fa      	ldr	r2, [r7, #28]
 8013a60:	18d3      	adds	r3, r2, r3
 8013a62:	61fb      	str	r3, [r7, #28]
    chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
 8013a64:	69bb      	ldr	r3, [r7, #24]
 8013a66:	7b1a      	ldrb	r2, [r3, #12]
 8013a68:	7b59      	ldrb	r1, [r3, #13]
 8013a6a:	0209      	lsls	r1, r1, #8
 8013a6c:	430a      	orrs	r2, r1
 8013a6e:	7b99      	ldrb	r1, [r3, #14]
 8013a70:	0409      	lsls	r1, r1, #16
 8013a72:	430a      	orrs	r2, r1
 8013a74:	7bdb      	ldrb	r3, [r3, #15]
 8013a76:	061b      	lsls	r3, r3, #24
 8013a78:	4313      	orrs	r3, r2
 8013a7a:	0c1b      	lsrs	r3, r3, #16
 8013a7c:	69fa      	ldr	r2, [r7, #28]
 8013a7e:	18d3      	adds	r3, r2, r3
 8013a80:	61fb      	str	r3, [r7, #28]
    chk_sum = (chk_sum >> 16) + (chk_sum & 0xFFFF);
 8013a82:	69fb      	ldr	r3, [r7, #28]
 8013a84:	0c1a      	lsrs	r2, r3, #16
 8013a86:	69fb      	ldr	r3, [r7, #28]
 8013a88:	041b      	lsls	r3, r3, #16
 8013a8a:	0c1b      	lsrs	r3, r3, #16
 8013a8c:	18d3      	adds	r3, r2, r3
 8013a8e:	61fb      	str	r3, [r7, #28]
    chk_sum = (chk_sum >> 16) + chk_sum;
 8013a90:	69fb      	ldr	r3, [r7, #28]
 8013a92:	0c1b      	lsrs	r3, r3, #16
 8013a94:	69fa      	ldr	r2, [r7, #28]
 8013a96:	18d3      	adds	r3, r2, r3
 8013a98:	61fb      	str	r3, [r7, #28]
    chk_sum = ~chk_sum;
 8013a9a:	69fb      	ldr	r3, [r7, #28]
 8013a9c:	43db      	mvns	r3, r3
 8013a9e:	61fb      	str	r3, [r7, #28]
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_IP) {
      iphdr->_chksum = (u16_t)chk_sum; /* network order */
 8013aa0:	69fb      	ldr	r3, [r7, #28]
 8013aa2:	b29a      	uxth	r2, r3
 8013aa4:	69bb      	ldr	r3, [r7, #24]
 8013aa6:	21ff      	movs	r1, #255	; 0xff
 8013aa8:	4011      	ands	r1, r2
 8013aaa:	000c      	movs	r4, r1
 8013aac:	7a99      	ldrb	r1, [r3, #10]
 8013aae:	2000      	movs	r0, #0
 8013ab0:	4001      	ands	r1, r0
 8013ab2:	1c08      	adds	r0, r1, #0
 8013ab4:	1c21      	adds	r1, r4, #0
 8013ab6:	4301      	orrs	r1, r0
 8013ab8:	7299      	strb	r1, [r3, #10]
 8013aba:	0a12      	lsrs	r2, r2, #8
 8013abc:	b290      	uxth	r0, r2
 8013abe:	7ada      	ldrb	r2, [r3, #11]
 8013ac0:	2100      	movs	r1, #0
 8013ac2:	400a      	ands	r2, r1
 8013ac4:	1c11      	adds	r1, r2, #0
 8013ac6:	1c02      	adds	r2, r0, #0
 8013ac8:	430a      	orrs	r2, r1
 8013aca:	72da      	strb	r2, [r3, #11]
 8013acc:	e024      	b.n	8013b18 <ip4_output_if_src+0x3d4>
    }
#endif /* CHECKSUM_GEN_IP */
#endif /* CHECKSUM_GEN_IP_INLINE */
  } else {
    /* IP header already included in p */
    if (p->len < IP_HLEN) {
 8013ace:	68fb      	ldr	r3, [r7, #12]
 8013ad0:	895b      	ldrh	r3, [r3, #10]
 8013ad2:	2b13      	cmp	r3, #19
 8013ad4:	d80e      	bhi.n	8013af4 <ip4_output_if_src+0x3b0>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output: LWIP_IP_HDRINCL but pbuf is too short\n"));
      IP_STATS_INC(ip.err);
      MIB2_STATS_INC(mib2.ipoutdiscards);
      return ERR_BUF;
 8013ad6:	2302      	movs	r3, #2
 8013ad8:	425b      	negs	r3, r3
 8013ada:	e024      	b.n	8013b26 <ip4_output_if_src+0x3e2>
 8013adc:	080214e8 	.word	0x080214e8
 8013ae0:	08021514 	.word	0x08021514
 8013ae4:	08021520 	.word	0x08021520
 8013ae8:	0802154c 	.word	0x0802154c
 8013aec:	20001b70 	.word	0x20001b70
 8013af0:	0802246c 	.word	0x0802246c
    }
    iphdr = (struct ip_hdr *)p->payload;
 8013af4:	68fb      	ldr	r3, [r7, #12]
 8013af6:	685b      	ldr	r3, [r3, #4]
 8013af8:	61bb      	str	r3, [r7, #24]
    ip4_addr_copy(dest_addr, iphdr->dest);
 8013afa:	69bb      	ldr	r3, [r7, #24]
 8013afc:	7c1a      	ldrb	r2, [r3, #16]
 8013afe:	7c59      	ldrb	r1, [r3, #17]
 8013b00:	0209      	lsls	r1, r1, #8
 8013b02:	430a      	orrs	r2, r1
 8013b04:	7c99      	ldrb	r1, [r3, #18]
 8013b06:	0409      	lsls	r1, r1, #16
 8013b08:	430a      	orrs	r2, r1
 8013b0a:	7cdb      	ldrb	r3, [r3, #19]
 8013b0c:	061b      	lsls	r3, r3, #24
 8013b0e:	4313      	orrs	r3, r2
 8013b10:	613b      	str	r3, [r7, #16]
    dest = &dest_addr;
 8013b12:	2310      	movs	r3, #16
 8013b14:	18fb      	adds	r3, r7, r3
 8013b16:	607b      	str	r3, [r7, #4]
    return ip4_frag(p, netif, dest);
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("ip4_output_if: call netif->output()\n"));
  return netif->output(netif, p, dest);
 8013b18:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8013b1a:	695b      	ldr	r3, [r3, #20]
 8013b1c:	687a      	ldr	r2, [r7, #4]
 8013b1e:	68f9      	ldr	r1, [r7, #12]
 8013b20:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8013b22:	4798      	blx	r3
 8013b24:	0003      	movs	r3, r0
}
 8013b26:	0018      	movs	r0, r3
 8013b28:	46bd      	mov	sp, r7
 8013b2a:	b009      	add	sp, #36	; 0x24
 8013b2c:	bd90      	pop	{r4, r7, pc}
 8013b2e:	46c0      	nop			; (mov r8, r8)

08013b30 <ip4_addr_isbroadcast_u32>:
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t
ip4_addr_isbroadcast_u32(u32_t addr, const struct netif *netif)
{
 8013b30:	b580      	push	{r7, lr}
 8013b32:	b084      	sub	sp, #16
 8013b34:	af00      	add	r7, sp, #0
 8013b36:	6078      	str	r0, [r7, #4]
 8013b38:	6039      	str	r1, [r7, #0]
  ip4_addr_t ipaddr;
  ip4_addr_set_u32(&ipaddr, addr);
 8013b3a:	687b      	ldr	r3, [r7, #4]
 8013b3c:	60fb      	str	r3, [r7, #12]

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
 8013b3e:	687b      	ldr	r3, [r7, #4]
 8013b40:	3301      	adds	r3, #1
 8013b42:	d002      	beq.n	8013b4a <ip4_addr_isbroadcast_u32+0x1a>
 8013b44:	687b      	ldr	r3, [r7, #4]
 8013b46:	2b00      	cmp	r3, #0
 8013b48:	d101      	bne.n	8013b4e <ip4_addr_isbroadcast_u32+0x1e>
      (addr == IPADDR_ANY)) {
    return 1;
 8013b4a:	2301      	movs	r3, #1
 8013b4c:	e029      	b.n	8013ba2 <ip4_addr_isbroadcast_u32+0x72>
    /* no broadcast support on this network interface? */
  } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
 8013b4e:	683b      	ldr	r3, [r7, #0]
 8013b50:	2231      	movs	r2, #49	; 0x31
 8013b52:	5c9b      	ldrb	r3, [r3, r2]
 8013b54:	001a      	movs	r2, r3
 8013b56:	2302      	movs	r3, #2
 8013b58:	4013      	ands	r3, r2
 8013b5a:	d101      	bne.n	8013b60 <ip4_addr_isbroadcast_u32+0x30>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
 8013b5c:	2300      	movs	r3, #0
 8013b5e:	e020      	b.n	8013ba2 <ip4_addr_isbroadcast_u32+0x72>
    /* address matches network interface address exactly? => no broadcast */
  } else if (addr == ip4_addr_get_u32(netif_ip4_addr(netif))) {
 8013b60:	683b      	ldr	r3, [r7, #0]
 8013b62:	3304      	adds	r3, #4
 8013b64:	681b      	ldr	r3, [r3, #0]
 8013b66:	687a      	ldr	r2, [r7, #4]
 8013b68:	429a      	cmp	r2, r3
 8013b6a:	d101      	bne.n	8013b70 <ip4_addr_isbroadcast_u32+0x40>
    return 0;
 8013b6c:	2300      	movs	r3, #0
 8013b6e:	e018      	b.n	8013ba2 <ip4_addr_isbroadcast_u32+0x72>
    /*  on the same (sub) network... */
  } else if (ip4_addr_netcmp(&ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif))
 8013b70:	68fa      	ldr	r2, [r7, #12]
 8013b72:	683b      	ldr	r3, [r7, #0]
 8013b74:	3304      	adds	r3, #4
 8013b76:	681b      	ldr	r3, [r3, #0]
 8013b78:	405a      	eors	r2, r3
 8013b7a:	683b      	ldr	r3, [r7, #0]
 8013b7c:	3308      	adds	r3, #8
 8013b7e:	681b      	ldr	r3, [r3, #0]
 8013b80:	4013      	ands	r3, r2
 8013b82:	d10d      	bne.n	8013ba0 <ip4_addr_isbroadcast_u32+0x70>
             /* ...and host identifier bits are all ones? =>... */
             && ((addr & ~ip4_addr_get_u32(netif_ip4_netmask(netif))) ==
 8013b84:	683b      	ldr	r3, [r7, #0]
 8013b86:	3308      	adds	r3, #8
 8013b88:	681b      	ldr	r3, [r3, #0]
 8013b8a:	43db      	mvns	r3, r3
 8013b8c:	687a      	ldr	r2, [r7, #4]
 8013b8e:	401a      	ands	r2, r3
                 (IPADDR_BROADCAST & ~ip4_addr_get_u32(netif_ip4_netmask(netif))))) {
 8013b90:	683b      	ldr	r3, [r7, #0]
 8013b92:	3308      	adds	r3, #8
 8013b94:	681b      	ldr	r3, [r3, #0]
 8013b96:	43db      	mvns	r3, r3
             && ((addr & ~ip4_addr_get_u32(netif_ip4_netmask(netif))) ==
 8013b98:	429a      	cmp	r2, r3
 8013b9a:	d101      	bne.n	8013ba0 <ip4_addr_isbroadcast_u32+0x70>
    /* => network broadcast address */
    return 1;
 8013b9c:	2301      	movs	r3, #1
 8013b9e:	e000      	b.n	8013ba2 <ip4_addr_isbroadcast_u32+0x72>
  } else {
    return 0;
 8013ba0:	2300      	movs	r3, #0
  }
}
 8013ba2:	0018      	movs	r0, r3
 8013ba4:	46bd      	mov	sp, r7
 8013ba6:	b004      	add	sp, #16
 8013ba8:	bd80      	pop	{r7, pc}
	...

08013bac <ip4addr_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
ip4addr_aton(const char *cp, ip4_addr_t *addr)
{
 8013bac:	b580      	push	{r7, lr}
 8013bae:	b08a      	sub	sp, #40	; 0x28
 8013bb0:	af00      	add	r7, sp, #0
 8013bb2:	6078      	str	r0, [r7, #4]
 8013bb4:	6039      	str	r1, [r7, #0]
  u32_t val;
  u8_t base;
  char c;
  u32_t parts[4];
  u32_t *pp = parts;
 8013bb6:	230c      	movs	r3, #12
 8013bb8:	18fb      	adds	r3, r7, r3
 8013bba:	61fb      	str	r3, [r7, #28]

  c = *cp;
 8013bbc:	2322      	movs	r3, #34	; 0x22
 8013bbe:	18fb      	adds	r3, r7, r3
 8013bc0:	687a      	ldr	r2, [r7, #4]
 8013bc2:	7812      	ldrb	r2, [r2, #0]
 8013bc4:	701a      	strb	r2, [r3, #0]
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!lwip_isdigit(c)) {
 8013bc6:	2322      	movs	r3, #34	; 0x22
 8013bc8:	18fb      	adds	r3, r7, r3
 8013bca:	781b      	ldrb	r3, [r3, #0]
 8013bcc:	1c5a      	adds	r2, r3, #1
 8013bce:	4b9d      	ldr	r3, [pc, #628]	; (8013e44 <ip4addr_aton+0x298>)
 8013bd0:	18d3      	adds	r3, r2, r3
 8013bd2:	781b      	ldrb	r3, [r3, #0]
 8013bd4:	001a      	movs	r2, r3
 8013bd6:	2304      	movs	r3, #4
 8013bd8:	4013      	ands	r3, r2
 8013bda:	d101      	bne.n	8013be0 <ip4addr_aton+0x34>
      return 0;
 8013bdc:	2300      	movs	r3, #0
 8013bde:	e12d      	b.n	8013e3c <ip4addr_aton+0x290>
    }
    val = 0;
 8013be0:	2300      	movs	r3, #0
 8013be2:	627b      	str	r3, [r7, #36]	; 0x24
    base = 10;
 8013be4:	2323      	movs	r3, #35	; 0x23
 8013be6:	18fb      	adds	r3, r7, r3
 8013be8:	220a      	movs	r2, #10
 8013bea:	701a      	strb	r2, [r3, #0]
    if (c == '0') {
 8013bec:	2222      	movs	r2, #34	; 0x22
 8013bee:	18bb      	adds	r3, r7, r2
 8013bf0:	781b      	ldrb	r3, [r3, #0]
 8013bf2:	2b30      	cmp	r3, #48	; 0x30
 8013bf4:	d121      	bne.n	8013c3a <ip4addr_aton+0x8e>
      c = *++cp;
 8013bf6:	687b      	ldr	r3, [r7, #4]
 8013bf8:	3301      	adds	r3, #1
 8013bfa:	607b      	str	r3, [r7, #4]
 8013bfc:	0011      	movs	r1, r2
 8013bfe:	18bb      	adds	r3, r7, r2
 8013c00:	687a      	ldr	r2, [r7, #4]
 8013c02:	7812      	ldrb	r2, [r2, #0]
 8013c04:	701a      	strb	r2, [r3, #0]
      if (c == 'x' || c == 'X') {
 8013c06:	000a      	movs	r2, r1
 8013c08:	18bb      	adds	r3, r7, r2
 8013c0a:	781b      	ldrb	r3, [r3, #0]
 8013c0c:	2b78      	cmp	r3, #120	; 0x78
 8013c0e:	d003      	beq.n	8013c18 <ip4addr_aton+0x6c>
 8013c10:	18bb      	adds	r3, r7, r2
 8013c12:	781b      	ldrb	r3, [r3, #0]
 8013c14:	2b58      	cmp	r3, #88	; 0x58
 8013c16:	d10c      	bne.n	8013c32 <ip4addr_aton+0x86>
        base = 16;
 8013c18:	2323      	movs	r3, #35	; 0x23
 8013c1a:	18fb      	adds	r3, r7, r3
 8013c1c:	2210      	movs	r2, #16
 8013c1e:	701a      	strb	r2, [r3, #0]
        c = *++cp;
 8013c20:	687b      	ldr	r3, [r7, #4]
 8013c22:	3301      	adds	r3, #1
 8013c24:	607b      	str	r3, [r7, #4]
 8013c26:	2322      	movs	r3, #34	; 0x22
 8013c28:	18fb      	adds	r3, r7, r3
 8013c2a:	687a      	ldr	r2, [r7, #4]
 8013c2c:	7812      	ldrb	r2, [r2, #0]
 8013c2e:	701a      	strb	r2, [r3, #0]
 8013c30:	e003      	b.n	8013c3a <ip4addr_aton+0x8e>
      } else {
        base = 8;
 8013c32:	2323      	movs	r3, #35	; 0x23
 8013c34:	18fb      	adds	r3, r7, r3
 8013c36:	2208      	movs	r2, #8
 8013c38:	701a      	strb	r2, [r3, #0]
      }
    }
    for (;;) {
      if (lwip_isdigit(c)) {
 8013c3a:	2122      	movs	r1, #34	; 0x22
 8013c3c:	187b      	adds	r3, r7, r1
 8013c3e:	781b      	ldrb	r3, [r3, #0]
 8013c40:	1c5a      	adds	r2, r3, #1
 8013c42:	4b80      	ldr	r3, [pc, #512]	; (8013e44 <ip4addr_aton+0x298>)
 8013c44:	18d3      	adds	r3, r2, r3
 8013c46:	781b      	ldrb	r3, [r3, #0]
 8013c48:	001a      	movs	r2, r3
 8013c4a:	2304      	movs	r3, #4
 8013c4c:	4013      	ands	r3, r2
 8013c4e:	d01c      	beq.n	8013c8a <ip4addr_aton+0xde>
        if((base == 8) && ((u32_t)(c - '0') >= 8))
 8013c50:	2323      	movs	r3, #35	; 0x23
 8013c52:	18fb      	adds	r3, r7, r3
 8013c54:	781b      	ldrb	r3, [r3, #0]
 8013c56:	2b08      	cmp	r3, #8
 8013c58:	d104      	bne.n	8013c64 <ip4addr_aton+0xb8>
 8013c5a:	187b      	adds	r3, r7, r1
 8013c5c:	781b      	ldrb	r3, [r3, #0]
 8013c5e:	3b30      	subs	r3, #48	; 0x30
 8013c60:	2b07      	cmp	r3, #7
 8013c62:	d843      	bhi.n	8013cec <ip4addr_aton+0x140>
          break;
        val = (val * base) + (u32_t)(c - '0');
 8013c64:	2323      	movs	r3, #35	; 0x23
 8013c66:	18fb      	adds	r3, r7, r3
 8013c68:	781b      	ldrb	r3, [r3, #0]
 8013c6a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8013c6c:	435a      	muls	r2, r3
 8013c6e:	2122      	movs	r1, #34	; 0x22
 8013c70:	187b      	adds	r3, r7, r1
 8013c72:	781b      	ldrb	r3, [r3, #0]
 8013c74:	18d3      	adds	r3, r2, r3
 8013c76:	3b30      	subs	r3, #48	; 0x30
 8013c78:	627b      	str	r3, [r7, #36]	; 0x24
        c = *++cp;
 8013c7a:	687b      	ldr	r3, [r7, #4]
 8013c7c:	3301      	adds	r3, #1
 8013c7e:	607b      	str	r3, [r7, #4]
 8013c80:	187b      	adds	r3, r7, r1
 8013c82:	687a      	ldr	r2, [r7, #4]
 8013c84:	7812      	ldrb	r2, [r2, #0]
 8013c86:	701a      	strb	r2, [r3, #0]
 8013c88:	e7d7      	b.n	8013c3a <ip4addr_aton+0x8e>
      } else if (base == 16 && lwip_isxdigit(c)) {
 8013c8a:	2323      	movs	r3, #35	; 0x23
 8013c8c:	18fb      	adds	r3, r7, r3
 8013c8e:	781b      	ldrb	r3, [r3, #0]
 8013c90:	2b10      	cmp	r3, #16
 8013c92:	d12c      	bne.n	8013cee <ip4addr_aton+0x142>
 8013c94:	2122      	movs	r1, #34	; 0x22
 8013c96:	187b      	adds	r3, r7, r1
 8013c98:	781b      	ldrb	r3, [r3, #0]
 8013c9a:	1c5a      	adds	r2, r3, #1
 8013c9c:	4b69      	ldr	r3, [pc, #420]	; (8013e44 <ip4addr_aton+0x298>)
 8013c9e:	18d3      	adds	r3, r2, r3
 8013ca0:	781b      	ldrb	r3, [r3, #0]
 8013ca2:	001a      	movs	r2, r3
 8013ca4:	2344      	movs	r3, #68	; 0x44
 8013ca6:	4013      	ands	r3, r2
 8013ca8:	d021      	beq.n	8013cee <ip4addr_aton+0x142>
        val = (val << 4) | (u32_t)(c + 10 - (lwip_islower(c) ? 'a' : 'A'));
 8013caa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013cac:	011a      	lsls	r2, r3, #4
 8013cae:	0008      	movs	r0, r1
 8013cb0:	187b      	adds	r3, r7, r1
 8013cb2:	781b      	ldrb	r3, [r3, #0]
 8013cb4:	330a      	adds	r3, #10
 8013cb6:	0019      	movs	r1, r3
 8013cb8:	183b      	adds	r3, r7, r0
 8013cba:	781b      	ldrb	r3, [r3, #0]
 8013cbc:	1c58      	adds	r0, r3, #1
 8013cbe:	4b61      	ldr	r3, [pc, #388]	; (8013e44 <ip4addr_aton+0x298>)
 8013cc0:	18c3      	adds	r3, r0, r3
 8013cc2:	781b      	ldrb	r3, [r3, #0]
 8013cc4:	0018      	movs	r0, r3
 8013cc6:	2303      	movs	r3, #3
 8013cc8:	4003      	ands	r3, r0
 8013cca:	2b02      	cmp	r3, #2
 8013ccc:	d101      	bne.n	8013cd2 <ip4addr_aton+0x126>
 8013cce:	2361      	movs	r3, #97	; 0x61
 8013cd0:	e000      	b.n	8013cd4 <ip4addr_aton+0x128>
 8013cd2:	2341      	movs	r3, #65	; 0x41
 8013cd4:	1acb      	subs	r3, r1, r3
 8013cd6:	4313      	orrs	r3, r2
 8013cd8:	627b      	str	r3, [r7, #36]	; 0x24
        c = *++cp;
 8013cda:	687b      	ldr	r3, [r7, #4]
 8013cdc:	3301      	adds	r3, #1
 8013cde:	607b      	str	r3, [r7, #4]
 8013ce0:	2322      	movs	r3, #34	; 0x22
 8013ce2:	18fb      	adds	r3, r7, r3
 8013ce4:	687a      	ldr	r2, [r7, #4]
 8013ce6:	7812      	ldrb	r2, [r2, #0]
 8013ce8:	701a      	strb	r2, [r3, #0]
      if (lwip_isdigit(c)) {
 8013cea:	e7a6      	b.n	8013c3a <ip4addr_aton+0x8e>
          break;
 8013cec:	46c0      	nop			; (mov r8, r8)
      } else {
        break;
      }
    }
    if (c == '.') {
 8013cee:	2322      	movs	r3, #34	; 0x22
 8013cf0:	18fb      	adds	r3, r7, r3
 8013cf2:	781b      	ldrb	r3, [r3, #0]
 8013cf4:	2b2e      	cmp	r3, #46	; 0x2e
 8013cf6:	d115      	bne.n	8013d24 <ip4addr_aton+0x178>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3) {
 8013cf8:	230c      	movs	r3, #12
 8013cfa:	18fb      	adds	r3, r7, r3
 8013cfc:	330c      	adds	r3, #12
 8013cfe:	69fa      	ldr	r2, [r7, #28]
 8013d00:	429a      	cmp	r2, r3
 8013d02:	d301      	bcc.n	8013d08 <ip4addr_aton+0x15c>
        return 0;
 8013d04:	2300      	movs	r3, #0
 8013d06:	e099      	b.n	8013e3c <ip4addr_aton+0x290>
      }
      *pp++ = val;
 8013d08:	69fb      	ldr	r3, [r7, #28]
 8013d0a:	1d1a      	adds	r2, r3, #4
 8013d0c:	61fa      	str	r2, [r7, #28]
 8013d0e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8013d10:	601a      	str	r2, [r3, #0]
      c = *++cp;
 8013d12:	687b      	ldr	r3, [r7, #4]
 8013d14:	3301      	adds	r3, #1
 8013d16:	607b      	str	r3, [r7, #4]
 8013d18:	2322      	movs	r3, #34	; 0x22
 8013d1a:	18fb      	adds	r3, r7, r3
 8013d1c:	687a      	ldr	r2, [r7, #4]
 8013d1e:	7812      	ldrb	r2, [r2, #0]
 8013d20:	701a      	strb	r2, [r3, #0]
    if (!lwip_isdigit(c)) {
 8013d22:	e750      	b.n	8013bc6 <ip4addr_aton+0x1a>
    } else {
      break;
 8013d24:	46c0      	nop			; (mov r8, r8)
    }
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && !lwip_isspace(c)) {
 8013d26:	2222      	movs	r2, #34	; 0x22
 8013d28:	18bb      	adds	r3, r7, r2
 8013d2a:	781b      	ldrb	r3, [r3, #0]
 8013d2c:	2b00      	cmp	r3, #0
 8013d2e:	d00b      	beq.n	8013d48 <ip4addr_aton+0x19c>
 8013d30:	18bb      	adds	r3, r7, r2
 8013d32:	781b      	ldrb	r3, [r3, #0]
 8013d34:	1c5a      	adds	r2, r3, #1
 8013d36:	4b43      	ldr	r3, [pc, #268]	; (8013e44 <ip4addr_aton+0x298>)
 8013d38:	18d3      	adds	r3, r2, r3
 8013d3a:	781b      	ldrb	r3, [r3, #0]
 8013d3c:	001a      	movs	r2, r3
 8013d3e:	2308      	movs	r3, #8
 8013d40:	4013      	ands	r3, r2
 8013d42:	d101      	bne.n	8013d48 <ip4addr_aton+0x19c>
    return 0;
 8013d44:	2300      	movs	r3, #0
 8013d46:	e079      	b.n	8013e3c <ip4addr_aton+0x290>
  }
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  switch (pp - parts + 1) {
 8013d48:	230c      	movs	r3, #12
 8013d4a:	18fb      	adds	r3, r7, r3
 8013d4c:	69fa      	ldr	r2, [r7, #28]
 8013d4e:	1ad3      	subs	r3, r2, r3
 8013d50:	109b      	asrs	r3, r3, #2
 8013d52:	3301      	adds	r3, #1
 8013d54:	2b04      	cmp	r3, #4
 8013d56:	d85e      	bhi.n	8013e16 <ip4addr_aton+0x26a>
 8013d58:	009a      	lsls	r2, r3, #2
 8013d5a:	4b3b      	ldr	r3, [pc, #236]	; (8013e48 <ip4addr_aton+0x29c>)
 8013d5c:	18d3      	adds	r3, r2, r3
 8013d5e:	681b      	ldr	r3, [r3, #0]
 8013d60:	469f      	mov	pc, r3

    case 0:
      return 0;       /* initial nondigit */
 8013d62:	2300      	movs	r3, #0
 8013d64:	e06a      	b.n	8013e3c <ip4addr_aton+0x290>

    case 1:             /* a -- 32 bits */
      break;

    case 2:             /* a.b -- 8.24 bits */
      if (val > 0xffffffUL) {
 8013d66:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8013d68:	2380      	movs	r3, #128	; 0x80
 8013d6a:	045b      	lsls	r3, r3, #17
 8013d6c:	429a      	cmp	r2, r3
 8013d6e:	d301      	bcc.n	8013d74 <ip4addr_aton+0x1c8>
        return 0;
 8013d70:	2300      	movs	r3, #0
 8013d72:	e063      	b.n	8013e3c <ip4addr_aton+0x290>
      }
      if (parts[0] > 0xff) {
 8013d74:	230c      	movs	r3, #12
 8013d76:	18fb      	adds	r3, r7, r3
 8013d78:	681b      	ldr	r3, [r3, #0]
 8013d7a:	2bff      	cmp	r3, #255	; 0xff
 8013d7c:	d901      	bls.n	8013d82 <ip4addr_aton+0x1d6>
        return 0;
 8013d7e:	2300      	movs	r3, #0
 8013d80:	e05c      	b.n	8013e3c <ip4addr_aton+0x290>
      }
      val |= parts[0] << 24;
 8013d82:	230c      	movs	r3, #12
 8013d84:	18fb      	adds	r3, r7, r3
 8013d86:	681b      	ldr	r3, [r3, #0]
 8013d88:	061b      	lsls	r3, r3, #24
 8013d8a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8013d8c:	4313      	orrs	r3, r2
 8013d8e:	627b      	str	r3, [r7, #36]	; 0x24
      break;
 8013d90:	e049      	b.n	8013e26 <ip4addr_aton+0x27a>

    case 3:             /* a.b.c -- 8.8.16 bits */
      if (val > 0xffff) {
 8013d92:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8013d94:	2380      	movs	r3, #128	; 0x80
 8013d96:	025b      	lsls	r3, r3, #9
 8013d98:	429a      	cmp	r2, r3
 8013d9a:	d301      	bcc.n	8013da0 <ip4addr_aton+0x1f4>
        return 0;
 8013d9c:	2300      	movs	r3, #0
 8013d9e:	e04d      	b.n	8013e3c <ip4addr_aton+0x290>
      }
      if ((parts[0] > 0xff) || (parts[1] > 0xff)) {
 8013da0:	220c      	movs	r2, #12
 8013da2:	18bb      	adds	r3, r7, r2
 8013da4:	681b      	ldr	r3, [r3, #0]
 8013da6:	2bff      	cmp	r3, #255	; 0xff
 8013da8:	d803      	bhi.n	8013db2 <ip4addr_aton+0x206>
 8013daa:	18bb      	adds	r3, r7, r2
 8013dac:	685b      	ldr	r3, [r3, #4]
 8013dae:	2bff      	cmp	r3, #255	; 0xff
 8013db0:	d901      	bls.n	8013db6 <ip4addr_aton+0x20a>
        return 0;
 8013db2:	2300      	movs	r3, #0
 8013db4:	e042      	b.n	8013e3c <ip4addr_aton+0x290>
      }
      val |= (parts[0] << 24) | (parts[1] << 16);
 8013db6:	210c      	movs	r1, #12
 8013db8:	187b      	adds	r3, r7, r1
 8013dba:	681b      	ldr	r3, [r3, #0]
 8013dbc:	061a      	lsls	r2, r3, #24
 8013dbe:	187b      	adds	r3, r7, r1
 8013dc0:	685b      	ldr	r3, [r3, #4]
 8013dc2:	041b      	lsls	r3, r3, #16
 8013dc4:	4313      	orrs	r3, r2
 8013dc6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8013dc8:	4313      	orrs	r3, r2
 8013dca:	627b      	str	r3, [r7, #36]	; 0x24
      break;
 8013dcc:	e02b      	b.n	8013e26 <ip4addr_aton+0x27a>

    case 4:             /* a.b.c.d -- 8.8.8.8 bits */
      if (val > 0xff) {
 8013dce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013dd0:	2bff      	cmp	r3, #255	; 0xff
 8013dd2:	d901      	bls.n	8013dd8 <ip4addr_aton+0x22c>
        return 0;
 8013dd4:	2300      	movs	r3, #0
 8013dd6:	e031      	b.n	8013e3c <ip4addr_aton+0x290>
      }
      if ((parts[0] > 0xff) || (parts[1] > 0xff) || (parts[2] > 0xff)) {
 8013dd8:	220c      	movs	r2, #12
 8013dda:	18bb      	adds	r3, r7, r2
 8013ddc:	681b      	ldr	r3, [r3, #0]
 8013dde:	2bff      	cmp	r3, #255	; 0xff
 8013de0:	d807      	bhi.n	8013df2 <ip4addr_aton+0x246>
 8013de2:	18bb      	adds	r3, r7, r2
 8013de4:	685b      	ldr	r3, [r3, #4]
 8013de6:	2bff      	cmp	r3, #255	; 0xff
 8013de8:	d803      	bhi.n	8013df2 <ip4addr_aton+0x246>
 8013dea:	18bb      	adds	r3, r7, r2
 8013dec:	689b      	ldr	r3, [r3, #8]
 8013dee:	2bff      	cmp	r3, #255	; 0xff
 8013df0:	d901      	bls.n	8013df6 <ip4addr_aton+0x24a>
        return 0;
 8013df2:	2300      	movs	r3, #0
 8013df4:	e022      	b.n	8013e3c <ip4addr_aton+0x290>
      }
      val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
 8013df6:	210c      	movs	r1, #12
 8013df8:	187b      	adds	r3, r7, r1
 8013dfa:	681b      	ldr	r3, [r3, #0]
 8013dfc:	061a      	lsls	r2, r3, #24
 8013dfe:	187b      	adds	r3, r7, r1
 8013e00:	685b      	ldr	r3, [r3, #4]
 8013e02:	041b      	lsls	r3, r3, #16
 8013e04:	431a      	orrs	r2, r3
 8013e06:	187b      	adds	r3, r7, r1
 8013e08:	689b      	ldr	r3, [r3, #8]
 8013e0a:	021b      	lsls	r3, r3, #8
 8013e0c:	4313      	orrs	r3, r2
 8013e0e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8013e10:	4313      	orrs	r3, r2
 8013e12:	627b      	str	r3, [r7, #36]	; 0x24
      break;
 8013e14:	e007      	b.n	8013e26 <ip4addr_aton+0x27a>
    default:
      LWIP_ASSERT("unhandled", 0);
 8013e16:	4b0d      	ldr	r3, [pc, #52]	; (8013e4c <ip4addr_aton+0x2a0>)
 8013e18:	490d      	ldr	r1, [pc, #52]	; (8013e50 <ip4addr_aton+0x2a4>)
 8013e1a:	480e      	ldr	r0, [pc, #56]	; (8013e54 <ip4addr_aton+0x2a8>)
 8013e1c:	22fb      	movs	r2, #251	; 0xfb
 8013e1e:	f7ee fd5d 	bl	80028dc <app_debug_rtt_raw>
      break;
 8013e22:	e000      	b.n	8013e26 <ip4addr_aton+0x27a>
      break;
 8013e24:	46c0      	nop			; (mov r8, r8)
  }
  if (addr) {
 8013e26:	683b      	ldr	r3, [r7, #0]
 8013e28:	2b00      	cmp	r3, #0
 8013e2a:	d006      	beq.n	8013e3a <ip4addr_aton+0x28e>
    ip4_addr_set_u32(addr, lwip_htonl(val));
 8013e2c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013e2e:	0018      	movs	r0, r3
 8013e30:	f7f2 ff00 	bl	8006c34 <lwip_htonl>
 8013e34:	0002      	movs	r2, r0
 8013e36:	683b      	ldr	r3, [r7, #0]
 8013e38:	601a      	str	r2, [r3, #0]
  }
  return 1;
 8013e3a:	2301      	movs	r3, #1
}
 8013e3c:	0018      	movs	r0, r3
 8013e3e:	46bd      	mov	sp, r7
 8013e40:	b00a      	add	sp, #40	; 0x28
 8013e42:	bd80      	pop	{r7, pc}
 8013e44:	08022a48 	.word	0x08022a48
 8013e48:	08022474 	.word	0x08022474
 8013e4c:	0802157c 	.word	0x0802157c
 8013e50:	080215ac 	.word	0x080215ac
 8013e54:	080215b8 	.word	0x080215b8

08013e58 <ip4addr_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         representation of addr
 */
char *
ip4addr_ntoa(const ip4_addr_t *addr)
{
 8013e58:	b580      	push	{r7, lr}
 8013e5a:	b082      	sub	sp, #8
 8013e5c:	af00      	add	r7, sp, #0
 8013e5e:	6078      	str	r0, [r7, #4]
  static char str[IP4ADDR_STRLEN_MAX];
  return ip4addr_ntoa_r(addr, str, IP4ADDR_STRLEN_MAX);
 8013e60:	4905      	ldr	r1, [pc, #20]	; (8013e78 <ip4addr_ntoa+0x20>)
 8013e62:	687b      	ldr	r3, [r7, #4]
 8013e64:	2210      	movs	r2, #16
 8013e66:	0018      	movs	r0, r3
 8013e68:	f000 f808 	bl	8013e7c <ip4addr_ntoa_r>
 8013e6c:	0003      	movs	r3, r0
}
 8013e6e:	0018      	movs	r0, r3
 8013e70:	46bd      	mov	sp, r7
 8013e72:	b002      	add	sp, #8
 8013e74:	bd80      	pop	{r7, pc}
 8013e76:	46c0      	nop			; (mov r8, r8)
 8013e78:	20001b74 	.word	0x20001b74

08013e7c <ip4addr_ntoa_r>:
 * @return either pointer to buf which now holds the ASCII
 *         representation of addr or NULL if buf was too small
 */
char *
ip4addr_ntoa_r(const ip4_addr_t *addr, char *buf, int buflen)
{
 8013e7c:	b5b0      	push	{r4, r5, r7, lr}
 8013e7e:	b08c      	sub	sp, #48	; 0x30
 8013e80:	af00      	add	r7, sp, #0
 8013e82:	60f8      	str	r0, [r7, #12]
 8013e84:	60b9      	str	r1, [r7, #8]
 8013e86:	607a      	str	r2, [r7, #4]
  char *rp;
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;
  int len = 0;
 8013e88:	2300      	movs	r3, #0
 8013e8a:	623b      	str	r3, [r7, #32]

  s_addr = ip4_addr_get_u32(addr);
 8013e8c:	68fb      	ldr	r3, [r7, #12]
 8013e8e:	681b      	ldr	r3, [r3, #0]
 8013e90:	61bb      	str	r3, [r7, #24]

  rp = buf;
 8013e92:	68bb      	ldr	r3, [r7, #8]
 8013e94:	62fb      	str	r3, [r7, #44]	; 0x2c
  ap = (u8_t *)&s_addr;
 8013e96:	2318      	movs	r3, #24
 8013e98:	18fb      	adds	r3, r7, r3
 8013e9a:	62bb      	str	r3, [r7, #40]	; 0x28
  for (n = 0; n < 4; n++) {
 8013e9c:	2327      	movs	r3, #39	; 0x27
 8013e9e:	18fb      	adds	r3, r7, r3
 8013ea0:	2200      	movs	r2, #0
 8013ea2:	701a      	strb	r2, [r3, #0]
 8013ea4:	e05a      	b.n	8013f5c <ip4addr_ntoa_r+0xe0>
    i = 0;
 8013ea6:	2326      	movs	r3, #38	; 0x26
 8013ea8:	18fb      	adds	r3, r7, r3
 8013eaa:	2200      	movs	r2, #0
 8013eac:	701a      	strb	r2, [r3, #0]
    do {
      rem = *ap % (u8_t)10;
 8013eae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013eb0:	781b      	ldrb	r3, [r3, #0]
 8013eb2:	251f      	movs	r5, #31
 8013eb4:	197c      	adds	r4, r7, r5
 8013eb6:	210a      	movs	r1, #10
 8013eb8:	0018      	movs	r0, r3
 8013eba:	f7ec f9bd 	bl	8000238 <__aeabi_uidivmod>
 8013ebe:	000b      	movs	r3, r1
 8013ec0:	7023      	strb	r3, [r4, #0]
      *ap /= (u8_t)10;
 8013ec2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013ec4:	781b      	ldrb	r3, [r3, #0]
 8013ec6:	210a      	movs	r1, #10
 8013ec8:	0018      	movs	r0, r3
 8013eca:	f7ec f92f 	bl	800012c <__udivsi3>
 8013ece:	0003      	movs	r3, r0
 8013ed0:	b2da      	uxtb	r2, r3
 8013ed2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013ed4:	701a      	strb	r2, [r3, #0]
      inv[i++] = (char)('0' + rem);
 8013ed6:	2226      	movs	r2, #38	; 0x26
 8013ed8:	18bb      	adds	r3, r7, r2
 8013eda:	781b      	ldrb	r3, [r3, #0]
 8013edc:	18ba      	adds	r2, r7, r2
 8013ede:	1c59      	adds	r1, r3, #1
 8013ee0:	7011      	strb	r1, [r2, #0]
 8013ee2:	001a      	movs	r2, r3
 8013ee4:	197b      	adds	r3, r7, r5
 8013ee6:	781b      	ldrb	r3, [r3, #0]
 8013ee8:	3330      	adds	r3, #48	; 0x30
 8013eea:	b2d9      	uxtb	r1, r3
 8013eec:	2314      	movs	r3, #20
 8013eee:	18fb      	adds	r3, r7, r3
 8013ef0:	5499      	strb	r1, [r3, r2]
    } while (*ap);
 8013ef2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013ef4:	781b      	ldrb	r3, [r3, #0]
 8013ef6:	2b00      	cmp	r3, #0
 8013ef8:	d1d9      	bne.n	8013eae <ip4addr_ntoa_r+0x32>
    while (i--) {
 8013efa:	e011      	b.n	8013f20 <ip4addr_ntoa_r+0xa4>
      if (len++ >= buflen) {
 8013efc:	6a3b      	ldr	r3, [r7, #32]
 8013efe:	1c5a      	adds	r2, r3, #1
 8013f00:	623a      	str	r2, [r7, #32]
 8013f02:	687a      	ldr	r2, [r7, #4]
 8013f04:	429a      	cmp	r2, r3
 8013f06:	dc01      	bgt.n	8013f0c <ip4addr_ntoa_r+0x90>
        return NULL;
 8013f08:	2300      	movs	r3, #0
 8013f0a:	e033      	b.n	8013f74 <ip4addr_ntoa_r+0xf8>
      }
      *rp++ = inv[i];
 8013f0c:	2326      	movs	r3, #38	; 0x26
 8013f0e:	18fb      	adds	r3, r7, r3
 8013f10:	781a      	ldrb	r2, [r3, #0]
 8013f12:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013f14:	1c59      	adds	r1, r3, #1
 8013f16:	62f9      	str	r1, [r7, #44]	; 0x2c
 8013f18:	2114      	movs	r1, #20
 8013f1a:	1879      	adds	r1, r7, r1
 8013f1c:	5c8a      	ldrb	r2, [r1, r2]
 8013f1e:	701a      	strb	r2, [r3, #0]
    while (i--) {
 8013f20:	2226      	movs	r2, #38	; 0x26
 8013f22:	18bb      	adds	r3, r7, r2
 8013f24:	781b      	ldrb	r3, [r3, #0]
 8013f26:	18ba      	adds	r2, r7, r2
 8013f28:	1e59      	subs	r1, r3, #1
 8013f2a:	7011      	strb	r1, [r2, #0]
 8013f2c:	2b00      	cmp	r3, #0
 8013f2e:	d1e5      	bne.n	8013efc <ip4addr_ntoa_r+0x80>
    }
    if (len++ >= buflen) {
 8013f30:	6a3b      	ldr	r3, [r7, #32]
 8013f32:	1c5a      	adds	r2, r3, #1
 8013f34:	623a      	str	r2, [r7, #32]
 8013f36:	687a      	ldr	r2, [r7, #4]
 8013f38:	429a      	cmp	r2, r3
 8013f3a:	dc01      	bgt.n	8013f40 <ip4addr_ntoa_r+0xc4>
      return NULL;
 8013f3c:	2300      	movs	r3, #0
 8013f3e:	e019      	b.n	8013f74 <ip4addr_ntoa_r+0xf8>
    }
    *rp++ = '.';
 8013f40:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013f42:	1c5a      	adds	r2, r3, #1
 8013f44:	62fa      	str	r2, [r7, #44]	; 0x2c
 8013f46:	222e      	movs	r2, #46	; 0x2e
 8013f48:	701a      	strb	r2, [r3, #0]
    ap++;
 8013f4a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013f4c:	3301      	adds	r3, #1
 8013f4e:	62bb      	str	r3, [r7, #40]	; 0x28
  for (n = 0; n < 4; n++) {
 8013f50:	2127      	movs	r1, #39	; 0x27
 8013f52:	187b      	adds	r3, r7, r1
 8013f54:	781a      	ldrb	r2, [r3, #0]
 8013f56:	187b      	adds	r3, r7, r1
 8013f58:	3201      	adds	r2, #1
 8013f5a:	701a      	strb	r2, [r3, #0]
 8013f5c:	2327      	movs	r3, #39	; 0x27
 8013f5e:	18fb      	adds	r3, r7, r3
 8013f60:	781b      	ldrb	r3, [r3, #0]
 8013f62:	2b03      	cmp	r3, #3
 8013f64:	d99f      	bls.n	8013ea6 <ip4addr_ntoa_r+0x2a>
  }
  *--rp = 0;
 8013f66:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013f68:	3b01      	subs	r3, #1
 8013f6a:	62fb      	str	r3, [r7, #44]	; 0x2c
 8013f6c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013f6e:	2200      	movs	r2, #0
 8013f70:	701a      	strb	r2, [r3, #0]
  return buf;
 8013f72:	68bb      	ldr	r3, [r7, #8]
}
 8013f74:	0018      	movs	r0, r3
 8013f76:	46bd      	mov	sp, r7
 8013f78:	b00c      	add	sp, #48	; 0x30
 8013f7a:	bdb0      	pop	{r4, r5, r7, pc}

08013f7c <link_required>:
#endif

/*
 * An Open on LCP has requested a change from Dead to Establish phase.
 */
void link_required(ppp_pcb *pcb) {
 8013f7c:	b580      	push	{r7, lr}
 8013f7e:	b082      	sub	sp, #8
 8013f80:	af00      	add	r7, sp, #0
 8013f82:	6078      	str	r0, [r7, #4]
    LWIP_UNUSED_ARG(pcb);
}
 8013f84:	46c0      	nop			; (mov r8, r8)
 8013f86:	46bd      	mov	sp, r7
 8013f88:	b002      	add	sp, #8
 8013f8a:	bd80      	pop	{r7, pc}

08013f8c <link_terminated>:

/*
 * LCP has terminated the link; go to the Dead phase and take the
 * physical layer down.
 */
void link_terminated(ppp_pcb *pcb) {
 8013f8c:	b580      	push	{r7, lr}
 8013f8e:	b082      	sub	sp, #8
 8013f90:	af00      	add	r7, sp, #0
 8013f92:	6078      	str	r0, [r7, #4]
    if (pcb->phase == PPP_PHASE_DEAD
 8013f94:	687b      	ldr	r3, [r7, #4]
 8013f96:	2224      	movs	r2, #36	; 0x24
 8013f98:	5c9b      	ldrb	r3, [r3, r2]
 8013f9a:	2b00      	cmp	r3, #0
 8013f9c:	d011      	beq.n	8013fc2 <link_terminated+0x36>
#ifdef HAVE_MULTILINK
    || pcb->phase == PPP_PHASE_MASTER
#endif /* HAVE_MULTILINK */
    )
	return;
    new_phase(pcb, PPP_PHASE_DISCONNECT);
 8013f9e:	687b      	ldr	r3, [r7, #4]
 8013fa0:	210c      	movs	r1, #12
 8013fa2:	0018      	movs	r0, r3
 8013fa4:	f006 f813 	bl	8019fce <new_phase>
    }
    session_end(devnam);
#endif /* UNUSED */

    if (!doing_multilink) {
	ppp_notice("Connection terminated.");
 8013fa8:	4b08      	ldr	r3, [pc, #32]	; (8013fcc <link_terminated+0x40>)
 8013faa:	0018      	movs	r0, r3
 8013fac:	f007 fae1 	bl	801b572 <ppp_notice>
	print_link_stats();
#endif /* PPP_STATS_SUPPORT */
    } else
	ppp_notice("Link terminated.");

    lcp_lowerdown(pcb);
 8013fb0:	687b      	ldr	r3, [r7, #4]
 8013fb2:	0018      	movs	r0, r3
 8013fb4:	f003 fcfc 	bl	80179b0 <lcp_lowerdown>

    ppp_link_terminated(pcb);
 8013fb8:	687b      	ldr	r3, [r7, #4]
 8013fba:	0018      	movs	r0, r3
 8013fbc:	f005 fff7 	bl	8019fae <ppp_link_terminated>
 8013fc0:	e000      	b.n	8013fc4 <link_terminated+0x38>
	return;
 8013fc2:	46c0      	nop			; (mov r8, r8)
	else
	    mp_bundle_terminated();
    } else
	new_phase(pcb, PPP_PHASE_DEAD);
#endif
}
 8013fc4:	46bd      	mov	sp, r7
 8013fc6:	b002      	add	sp, #8
 8013fc8:	bd80      	pop	{r7, pc}
 8013fca:	46c0      	nop			; (mov r8, r8)
 8013fcc:	080215e4 	.word	0x080215e4

08013fd0 <link_down>:

/*
 * LCP has gone down; it will either die or try to re-establish.
 */
void link_down(ppp_pcb *pcb) {
 8013fd0:	b580      	push	{r7, lr}
 8013fd2:	b082      	sub	sp, #8
 8013fd4:	af00      	add	r7, sp, #0
 8013fd6:	6078      	str	r0, [r7, #4]
#if PPP_NOTIFY
    notify(link_down_notifier, 0);
#endif /* PPP_NOTIFY */

    if (!doing_multilink) {
	upper_layers_down(pcb);
 8013fd8:	687b      	ldr	r3, [r7, #4]
 8013fda:	0018      	movs	r0, r3
 8013fdc:	f000 f80e 	bl	8013ffc <upper_layers_down>
	if (pcb->phase != PPP_PHASE_DEAD
 8013fe0:	687b      	ldr	r3, [r7, #4]
 8013fe2:	2224      	movs	r2, #36	; 0x24
 8013fe4:	5c9b      	ldrb	r3, [r3, r2]
 8013fe6:	2b00      	cmp	r3, #0
 8013fe8:	d004      	beq.n	8013ff4 <link_down+0x24>
#ifdef HAVE_MULTILINK
	&& pcb->phase != PPP_PHASE_MASTER
#endif /* HAVE_MULTILINK */
	)
	    new_phase(pcb, PPP_PHASE_ESTABLISH);
 8013fea:	687b      	ldr	r3, [r7, #4]
 8013fec:	2106      	movs	r1, #6
 8013fee:	0018      	movs	r0, r3
 8013ff0:	f005 ffed 	bl	8019fce <new_phase>
    }
    /* XXX if doing_multilink, should do something to stop
       network-layer traffic on the link */
}
 8013ff4:	46c0      	nop			; (mov r8, r8)
 8013ff6:	46bd      	mov	sp, r7
 8013ff8:	b002      	add	sp, #8
 8013ffa:	bd80      	pop	{r7, pc}

08013ffc <upper_layers_down>:

void upper_layers_down(ppp_pcb *pcb) {
 8013ffc:	b580      	push	{r7, lr}
 8013ffe:	b084      	sub	sp, #16
 8014000:	af00      	add	r7, sp, #0
 8014002:	6078      	str	r0, [r7, #4]
    int i;
    const struct protent *protp;

    for (i = 0; (protp = protocols[i]) != NULL; ++i) {
 8014004:	2300      	movs	r3, #0
 8014006:	60fb      	str	r3, [r7, #12]
 8014008:	e01f      	b.n	801404a <upper_layers_down+0x4e>
        if (protp->protocol != PPP_LCP && protp->lowerdown != NULL)
 801400a:	68bb      	ldr	r3, [r7, #8]
 801400c:	881b      	ldrh	r3, [r3, #0]
 801400e:	4a19      	ldr	r2, [pc, #100]	; (8014074 <upper_layers_down+0x78>)
 8014010:	4293      	cmp	r3, r2
 8014012:	d008      	beq.n	8014026 <upper_layers_down+0x2a>
 8014014:	68bb      	ldr	r3, [r7, #8]
 8014016:	695b      	ldr	r3, [r3, #20]
 8014018:	2b00      	cmp	r3, #0
 801401a:	d004      	beq.n	8014026 <upper_layers_down+0x2a>
	    (*protp->lowerdown)(pcb);
 801401c:	68bb      	ldr	r3, [r7, #8]
 801401e:	695b      	ldr	r3, [r3, #20]
 8014020:	687a      	ldr	r2, [r7, #4]
 8014022:	0010      	movs	r0, r2
 8014024:	4798      	blx	r3
        if (protp->protocol < 0xC000 && protp->close != NULL)
 8014026:	68bb      	ldr	r3, [r7, #8]
 8014028:	881b      	ldrh	r3, [r3, #0]
 801402a:	4a13      	ldr	r2, [pc, #76]	; (8014078 <upper_layers_down+0x7c>)
 801402c:	4293      	cmp	r3, r2
 801402e:	d809      	bhi.n	8014044 <upper_layers_down+0x48>
 8014030:	68bb      	ldr	r3, [r7, #8]
 8014032:	69db      	ldr	r3, [r3, #28]
 8014034:	2b00      	cmp	r3, #0
 8014036:	d005      	beq.n	8014044 <upper_layers_down+0x48>
	    (*protp->close)(pcb, "LCP down");
 8014038:	68bb      	ldr	r3, [r7, #8]
 801403a:	69db      	ldr	r3, [r3, #28]
 801403c:	490f      	ldr	r1, [pc, #60]	; (801407c <upper_layers_down+0x80>)
 801403e:	687a      	ldr	r2, [r7, #4]
 8014040:	0010      	movs	r0, r2
 8014042:	4798      	blx	r3
    for (i = 0; (protp = protocols[i]) != NULL; ++i) {
 8014044:	68fb      	ldr	r3, [r7, #12]
 8014046:	3301      	adds	r3, #1
 8014048:	60fb      	str	r3, [r7, #12]
 801404a:	4b0d      	ldr	r3, [pc, #52]	; (8014080 <upper_layers_down+0x84>)
 801404c:	68fa      	ldr	r2, [r7, #12]
 801404e:	0092      	lsls	r2, r2, #2
 8014050:	58d3      	ldr	r3, [r2, r3]
 8014052:	60bb      	str	r3, [r7, #8]
 8014054:	68bb      	ldr	r3, [r7, #8]
 8014056:	2b00      	cmp	r3, #0
 8014058:	d1d7      	bne.n	801400a <upper_layers_down+0xe>
    }
    pcb->num_np_open = 0;
 801405a:	687b      	ldr	r3, [r7, #4]
 801405c:	22d8      	movs	r2, #216	; 0xd8
 801405e:	2100      	movs	r1, #0
 8014060:	5499      	strb	r1, [r3, r2]
    pcb->num_np_up = 0;
 8014062:	687b      	ldr	r3, [r7, #4]
 8014064:	22d9      	movs	r2, #217	; 0xd9
 8014066:	2100      	movs	r1, #0
 8014068:	5499      	strb	r1, [r3, r2]
}
 801406a:	46c0      	nop			; (mov r8, r8)
 801406c:	46bd      	mov	sp, r7
 801406e:	b004      	add	sp, #16
 8014070:	bd80      	pop	{r7, pc}
 8014072:	46c0      	nop			; (mov r8, r8)
 8014074:	0000c021 	.word	0x0000c021
 8014078:	0000bfff 	.word	0x0000bfff
 801407c:	080215fc 	.word	0x080215fc
 8014080:	080226d8 	.word	0x080226d8

08014084 <link_established>:

/*
 * The link is established.
 * Proceed to the Dead, Authenticate or Network phase as appropriate.
 */
void link_established(ppp_pcb *pcb) {
 8014084:	b580      	push	{r7, lr}
 8014086:	b084      	sub	sp, #16
 8014088:	af00      	add	r7, sp, #0
 801408a:	6078      	str	r0, [r7, #4]

    /*
     * Tell higher-level protocols that LCP is up.
     */
    if (!doing_multilink) {
	for (i = 0; (protp = protocols[i]) != NULL; ++i)
 801408c:	2300      	movs	r3, #0
 801408e:	60fb      	str	r3, [r7, #12]
 8014090:	e010      	b.n	80140b4 <link_established+0x30>
	    if (protp->protocol != PPP_LCP
 8014092:	68bb      	ldr	r3, [r7, #8]
 8014094:	881b      	ldrh	r3, [r3, #0]
 8014096:	4a0f      	ldr	r2, [pc, #60]	; (80140d4 <link_established+0x50>)
 8014098:	4293      	cmp	r3, r2
 801409a:	d008      	beq.n	80140ae <link_established+0x2a>
		&& protp->lowerup != NULL)
 801409c:	68bb      	ldr	r3, [r7, #8]
 801409e:	691b      	ldr	r3, [r3, #16]
 80140a0:	2b00      	cmp	r3, #0
 80140a2:	d004      	beq.n	80140ae <link_established+0x2a>
		(*protp->lowerup)(pcb);
 80140a4:	68bb      	ldr	r3, [r7, #8]
 80140a6:	691b      	ldr	r3, [r3, #16]
 80140a8:	687a      	ldr	r2, [r7, #4]
 80140aa:	0010      	movs	r0, r2
 80140ac:	4798      	blx	r3
	for (i = 0; (protp = protocols[i]) != NULL; ++i)
 80140ae:	68fb      	ldr	r3, [r7, #12]
 80140b0:	3301      	adds	r3, #1
 80140b2:	60fb      	str	r3, [r7, #12]
 80140b4:	4b08      	ldr	r3, [pc, #32]	; (80140d8 <link_established+0x54>)
 80140b6:	68fa      	ldr	r2, [r7, #12]
 80140b8:	0092      	lsls	r2, r2, #2
 80140ba:	58d3      	ldr	r3, [r2, r3]
 80140bc:	60bb      	str	r3, [r7, #8]
 80140be:	68bb      	ldr	r3, [r7, #8]
 80140c0:	2b00      	cmp	r3, #0
 80140c2:	d1e6      	bne.n	8014092 <link_established+0xe>
    pcb->auth_pending = auth;
    pcb->auth_done = 0;

    if (!auth)
#endif /* PPP_AUTH_SUPPORT */
	network_phase(pcb);
 80140c4:	687b      	ldr	r3, [r7, #4]
 80140c6:	0018      	movs	r0, r3
 80140c8:	f000 f808 	bl	80140dc <network_phase>
}
 80140cc:	46c0      	nop			; (mov r8, r8)
 80140ce:	46bd      	mov	sp, r7
 80140d0:	b004      	add	sp, #16
 80140d2:	bd80      	pop	{r7, pc}
 80140d4:	0000c021 	.word	0x0000c021
 80140d8:	080226d8 	.word	0x080226d8

080140dc <network_phase>:

/*
 * Proceed to the network phase.
 */
static void network_phase(ppp_pcb *pcb) {
 80140dc:	b580      	push	{r7, lr}
 80140de:	b082      	sub	sp, #8
 80140e0:	af00      	add	r7, sp, #0
 80140e2:	6078      	str	r0, [r7, #4]
	options_from_list(extra_options, 1);
	free_wordlist(extra_options);
	extra_options = 0;
    }
#endif /* PPP_OPTIONS */
    start_networks(pcb);
 80140e4:	687b      	ldr	r3, [r7, #4]
 80140e6:	0018      	movs	r0, r3
 80140e8:	f000 f804 	bl	80140f4 <start_networks>
}
 80140ec:	46c0      	nop			; (mov r8, r8)
 80140ee:	46bd      	mov	sp, r7
 80140f0:	b002      	add	sp, #8
 80140f2:	bd80      	pop	{r7, pc}

080140f4 <start_networks>:

void start_networks(ppp_pcb *pcb) {
 80140f4:	b580      	push	{r7, lr}
 80140f6:	b082      	sub	sp, #8
 80140f8:	af00      	add	r7, sp, #0
 80140fa:	6078      	str	r0, [r7, #4]
#if CCP_SUPPORT || ECP_SUPPORT
    int i;
    const struct protent *protp;
#endif /* CCP_SUPPORT || ECP_SUPPORT */

    new_phase(pcb, PPP_PHASE_NETWORK);
 80140fc:	687b      	ldr	r3, [r7, #4]
 80140fe:	2109      	movs	r1, #9
 8014100:	0018      	movs	r0, r3
 8014102:	f005 ff64 	bl	8019fce <new_phase>
#endif /* ECP_SUPPORT */
#if MPPE_SUPPORT
        && !pcb->ccp_gotoptions.mppe
#endif /* MPPE_SUPPORT */
        )
	continue_networks(pcb);
 8014106:	687b      	ldr	r3, [r7, #4]
 8014108:	0018      	movs	r0, r3
 801410a:	f000 f805 	bl	8014118 <continue_networks>
}
 801410e:	46c0      	nop			; (mov r8, r8)
 8014110:	46bd      	mov	sp, r7
 8014112:	b002      	add	sp, #8
 8014114:	bd80      	pop	{r7, pc}
	...

08014118 <continue_networks>:

void continue_networks(ppp_pcb *pcb) {
 8014118:	b580      	push	{r7, lr}
 801411a:	b084      	sub	sp, #16
 801411c:	af00      	add	r7, sp, #0
 801411e:	6078      	str	r0, [r7, #4]
    const struct protent *protp;

    /*
     * Start the "real" network protocols.
     */
    for (i = 0; (protp = protocols[i]) != NULL; ++i)
 8014120:	2300      	movs	r3, #0
 8014122:	60fb      	str	r3, [r7, #12]
 8014124:	e018      	b.n	8014158 <continue_networks+0x40>
	if (protp->protocol < 0xC000
 8014126:	68bb      	ldr	r3, [r7, #8]
 8014128:	881b      	ldrh	r3, [r3, #0]
 801412a:	4a17      	ldr	r2, [pc, #92]	; (8014188 <continue_networks+0x70>)
 801412c:	4293      	cmp	r3, r2
 801412e:	d810      	bhi.n	8014152 <continue_networks+0x3a>
	    && protp->protocol != PPP_CCP
#endif /* CCP_SUPPORT */
#if ECP_SUPPORT
	    && protp->protocol != PPP_ECP
#endif /* ECP_SUPPORT */
	    && protp->open != NULL) {
 8014130:	68bb      	ldr	r3, [r7, #8]
 8014132:	699b      	ldr	r3, [r3, #24]
 8014134:	2b00      	cmp	r3, #0
 8014136:	d00c      	beq.n	8014152 <continue_networks+0x3a>
	    (*protp->open)(pcb);
 8014138:	68bb      	ldr	r3, [r7, #8]
 801413a:	699b      	ldr	r3, [r3, #24]
 801413c:	687a      	ldr	r2, [r7, #4]
 801413e:	0010      	movs	r0, r2
 8014140:	4798      	blx	r3
	    ++pcb->num_np_open;
 8014142:	687b      	ldr	r3, [r7, #4]
 8014144:	22d8      	movs	r2, #216	; 0xd8
 8014146:	5c9b      	ldrb	r3, [r3, r2]
 8014148:	3301      	adds	r3, #1
 801414a:	b2d9      	uxtb	r1, r3
 801414c:	687b      	ldr	r3, [r7, #4]
 801414e:	22d8      	movs	r2, #216	; 0xd8
 8014150:	5499      	strb	r1, [r3, r2]
    for (i = 0; (protp = protocols[i]) != NULL; ++i)
 8014152:	68fb      	ldr	r3, [r7, #12]
 8014154:	3301      	adds	r3, #1
 8014156:	60fb      	str	r3, [r7, #12]
 8014158:	4b0c      	ldr	r3, [pc, #48]	; (801418c <continue_networks+0x74>)
 801415a:	68fa      	ldr	r2, [r7, #12]
 801415c:	0092      	lsls	r2, r2, #2
 801415e:	58d3      	ldr	r3, [r2, r3]
 8014160:	60bb      	str	r3, [r7, #8]
 8014162:	68bb      	ldr	r3, [r7, #8]
 8014164:	2b00      	cmp	r3, #0
 8014166:	d1de      	bne.n	8014126 <continue_networks+0xe>
	}

    if (pcb->num_np_open == 0)
 8014168:	687b      	ldr	r3, [r7, #4]
 801416a:	22d8      	movs	r2, #216	; 0xd8
 801416c:	5c9b      	ldrb	r3, [r3, r2]
 801416e:	2b00      	cmp	r3, #0
 8014170:	d105      	bne.n	801417e <continue_networks+0x66>
	/* nothing to do */
	lcp_close(pcb, "No network protocols running");
 8014172:	4a07      	ldr	r2, [pc, #28]	; (8014190 <continue_networks+0x78>)
 8014174:	687b      	ldr	r3, [r7, #4]
 8014176:	0011      	movs	r1, r2
 8014178:	0018      	movs	r0, r3
 801417a:	f003 fb75 	bl	8017868 <lcp_close>
}
 801417e:	46c0      	nop			; (mov r8, r8)
 8014180:	46bd      	mov	sp, r7
 8014182:	b004      	add	sp, #16
 8014184:	bd80      	pop	{r7, pc}
 8014186:	46c0      	nop			; (mov r8, r8)
 8014188:	0000bfff 	.word	0x0000bfff
 801418c:	080226d8 	.word	0x080226d8
 8014190:	08021608 	.word	0x08021608

08014194 <np_up>:


/*
 * np_up - a network protocol has come up.
 */
void np_up(ppp_pcb *pcb, int proto) {
 8014194:	b580      	push	{r7, lr}
 8014196:	b082      	sub	sp, #8
 8014198:	af00      	add	r7, sp, #0
 801419a:	6078      	str	r0, [r7, #4]
 801419c:	6039      	str	r1, [r7, #0]
#if PPP_IDLETIMELIMIT
    int tlim;
#endif /* PPP_IDLETIMELIMIT */
    LWIP_UNUSED_ARG(proto);

    if (pcb->num_np_up == 0) {
 801419e:	687b      	ldr	r3, [r7, #4]
 80141a0:	22d9      	movs	r2, #217	; 0xd9
 80141a2:	5c9b      	ldrb	r3, [r3, r2]
 80141a4:	2b00      	cmp	r3, #0
 80141a6:	d104      	bne.n	80141b2 <np_up+0x1e>
	/*
	 * At this point we consider that the link has come up successfully.
	 */
	new_phase(pcb, PPP_PHASE_RUNNING);
 80141a8:	687b      	ldr	r3, [r7, #4]
 80141aa:	210a      	movs	r1, #10
 80141ac:	0018      	movs	r0, r3
 80141ae:	f005 ff0e 	bl	8019fce <new_phase>
	 */
	if (updetach && !nodetach)
	    detach();
#endif /* Unused */
    }
    ++pcb->num_np_up;
 80141b2:	687b      	ldr	r3, [r7, #4]
 80141b4:	22d9      	movs	r2, #217	; 0xd9
 80141b6:	5c9b      	ldrb	r3, [r3, r2]
 80141b8:	3301      	adds	r3, #1
 80141ba:	b2d9      	uxtb	r1, r3
 80141bc:	687b      	ldr	r3, [r7, #4]
 80141be:	22d9      	movs	r2, #217	; 0xd9
 80141c0:	5499      	strb	r1, [r3, r2]
}
 80141c2:	46c0      	nop			; (mov r8, r8)
 80141c4:	46bd      	mov	sp, r7
 80141c6:	b002      	add	sp, #8
 80141c8:	bd80      	pop	{r7, pc}

080141ca <np_down>:

/*
 * np_down - a network protocol has gone down.
 */
void np_down(ppp_pcb *pcb, int proto) {
 80141ca:	b580      	push	{r7, lr}
 80141cc:	b082      	sub	sp, #8
 80141ce:	af00      	add	r7, sp, #0
 80141d0:	6078      	str	r0, [r7, #4]
 80141d2:	6039      	str	r1, [r7, #0]
    LWIP_UNUSED_ARG(proto);
    if (--pcb->num_np_up == 0) {
 80141d4:	687b      	ldr	r3, [r7, #4]
 80141d6:	22d9      	movs	r2, #217	; 0xd9
 80141d8:	5c9b      	ldrb	r3, [r3, r2]
 80141da:	3b01      	subs	r3, #1
 80141dc:	b2d9      	uxtb	r1, r3
 80141de:	687b      	ldr	r3, [r7, #4]
 80141e0:	22d9      	movs	r2, #217	; 0xd9
 80141e2:	5499      	strb	r1, [r3, r2]
 80141e4:	687b      	ldr	r3, [r7, #4]
 80141e6:	22d9      	movs	r2, #217	; 0xd9
 80141e8:	5c9b      	ldrb	r3, [r3, r2]
 80141ea:	2b00      	cmp	r3, #0
 80141ec:	d104      	bne.n	80141f8 <np_down+0x2e>
	UNTIMEOUT(connect_time_expired, NULL);
#endif /* PPP_MAXCONNECT */
#ifdef MAXOCTETS
	UNTIMEOUT(check_maxoctets, NULL);
#endif
	new_phase(pcb, PPP_PHASE_NETWORK);
 80141ee:	687b      	ldr	r3, [r7, #4]
 80141f0:	2109      	movs	r1, #9
 80141f2:	0018      	movs	r0, r3
 80141f4:	f005 feeb 	bl	8019fce <new_phase>
    }
}
 80141f8:	46c0      	nop			; (mov r8, r8)
 80141fa:	46bd      	mov	sp, r7
 80141fc:	b002      	add	sp, #8
 80141fe:	bd80      	pop	{r7, pc}

08014200 <np_finished>:

/*
 * np_finished - a network protocol has finished using the link.
 */
void np_finished(ppp_pcb *pcb, int proto) {
 8014200:	b580      	push	{r7, lr}
 8014202:	b082      	sub	sp, #8
 8014204:	af00      	add	r7, sp, #0
 8014206:	6078      	str	r0, [r7, #4]
 8014208:	6039      	str	r1, [r7, #0]
    LWIP_UNUSED_ARG(proto);
    if (--pcb->num_np_open <= 0) {
 801420a:	687b      	ldr	r3, [r7, #4]
 801420c:	22d8      	movs	r2, #216	; 0xd8
 801420e:	5c9b      	ldrb	r3, [r3, r2]
 8014210:	3b01      	subs	r3, #1
 8014212:	b2d9      	uxtb	r1, r3
 8014214:	687b      	ldr	r3, [r7, #4]
 8014216:	22d8      	movs	r2, #216	; 0xd8
 8014218:	5499      	strb	r1, [r3, r2]
 801421a:	687b      	ldr	r3, [r7, #4]
 801421c:	22d8      	movs	r2, #216	; 0xd8
 801421e:	5c9b      	ldrb	r3, [r3, r2]
 8014220:	2b00      	cmp	r3, #0
 8014222:	d105      	bne.n	8014230 <np_finished+0x30>
	/* no further use for the link: shut up shop. */
	lcp_close(pcb, "No network protocols running");
 8014224:	4a04      	ldr	r2, [pc, #16]	; (8014238 <np_finished+0x38>)
 8014226:	687b      	ldr	r3, [r7, #4]
 8014228:	0011      	movs	r1, r2
 801422a:	0018      	movs	r0, r3
 801422c:	f003 fb1c 	bl	8017868 <lcp_close>
    }
}
 8014230:	46c0      	nop			; (mov r8, r8)
 8014232:	46bd      	mov	sp, r7
 8014234:	b002      	add	sp, #8
 8014236:	bd80      	pop	{r7, pc}
 8014238:	08021608 	.word	0x08021608

0801423c <fsm_init>:
/*
 * fsm_init - Initialize fsm.
 *
 * Initialize fsm state.
 */
void fsm_init(fsm *f) {
 801423c:	b580      	push	{r7, lr}
 801423e:	b084      	sub	sp, #16
 8014240:	af00      	add	r7, sp, #0
 8014242:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8014244:	687b      	ldr	r3, [r7, #4]
 8014246:	681b      	ldr	r3, [r3, #0]
 8014248:	60fb      	str	r3, [r7, #12]
    f->state = PPP_FSM_INITIAL;
 801424a:	687b      	ldr	r3, [r7, #4]
 801424c:	2200      	movs	r2, #0
 801424e:	741a      	strb	r2, [r3, #16]
    f->flags = 0;
 8014250:	687b      	ldr	r3, [r7, #4]
 8014252:	2200      	movs	r2, #0
 8014254:	745a      	strb	r2, [r3, #17]
    f->id = 0;				/* XXX Start with random id? */
 8014256:	687b      	ldr	r3, [r7, #4]
 8014258:	2200      	movs	r2, #0
 801425a:	749a      	strb	r2, [r3, #18]
    f->maxnakloops = pcb->settings.fsm_max_nak_loops;
 801425c:	68fb      	ldr	r3, [r7, #12]
 801425e:	79da      	ldrb	r2, [r3, #7]
 8014260:	687b      	ldr	r3, [r7, #4]
 8014262:	75da      	strb	r2, [r3, #23]
    f->term_reason_len = 0;
 8014264:	687b      	ldr	r3, [r7, #4]
 8014266:	2200      	movs	r2, #0
 8014268:	761a      	strb	r2, [r3, #24]
}
 801426a:	46c0      	nop			; (mov r8, r8)
 801426c:	46bd      	mov	sp, r7
 801426e:	b004      	add	sp, #16
 8014270:	bd80      	pop	{r7, pc}

08014272 <fsm_lowerup>:


/*
 * fsm_lowerup - The lower layer is up.
 */
void fsm_lowerup(fsm *f) {
 8014272:	b580      	push	{r7, lr}
 8014274:	b082      	sub	sp, #8
 8014276:	af00      	add	r7, sp, #0
 8014278:	6078      	str	r0, [r7, #4]
    switch( f->state ){
 801427a:	687b      	ldr	r3, [r7, #4]
 801427c:	7c1b      	ldrb	r3, [r3, #16]
 801427e:	2b00      	cmp	r3, #0
 8014280:	d002      	beq.n	8014288 <fsm_lowerup+0x16>
 8014282:	2b01      	cmp	r3, #1
 8014284:	d004      	beq.n	8014290 <fsm_lowerup+0x1e>

    default:
	FSMDEBUG(("%s: Up event in state %d!", PROTO_NAME(f), f->state));
	/* no break */
    }
}
 8014286:	e016      	b.n	80142b6 <fsm_lowerup+0x44>
	f->state = PPP_FSM_CLOSED;
 8014288:	687b      	ldr	r3, [r7, #4]
 801428a:	2202      	movs	r2, #2
 801428c:	741a      	strb	r2, [r3, #16]
	break;
 801428e:	e012      	b.n	80142b6 <fsm_lowerup+0x44>
	if( f->flags & OPT_SILENT )
 8014290:	687b      	ldr	r3, [r7, #4]
 8014292:	7c5b      	ldrb	r3, [r3, #17]
 8014294:	001a      	movs	r2, r3
 8014296:	2304      	movs	r3, #4
 8014298:	4013      	ands	r3, r2
 801429a:	d003      	beq.n	80142a4 <fsm_lowerup+0x32>
	    f->state = PPP_FSM_STOPPED;
 801429c:	687b      	ldr	r3, [r7, #4]
 801429e:	2203      	movs	r2, #3
 80142a0:	741a      	strb	r2, [r3, #16]
	break;
 80142a2:	e007      	b.n	80142b4 <fsm_lowerup+0x42>
	    fsm_sconfreq(f, 0);
 80142a4:	687b      	ldr	r3, [r7, #4]
 80142a6:	2100      	movs	r1, #0
 80142a8:	0018      	movs	r0, r3
 80142aa:	f000 fded 	bl	8014e88 <fsm_sconfreq>
	    f->state = PPP_FSM_REQSENT;
 80142ae:	687b      	ldr	r3, [r7, #4]
 80142b0:	2206      	movs	r2, #6
 80142b2:	741a      	strb	r2, [r3, #16]
	break;
 80142b4:	46c0      	nop			; (mov r8, r8)
}
 80142b6:	46c0      	nop			; (mov r8, r8)
 80142b8:	46bd      	mov	sp, r7
 80142ba:	b002      	add	sp, #8
 80142bc:	bd80      	pop	{r7, pc}
	...

080142c0 <fsm_lowerdown>:
/*
 * fsm_lowerdown - The lower layer is down.
 *
 * Cancel all timeouts and inform upper layers.
 */
void fsm_lowerdown(fsm *f) {
 80142c0:	b580      	push	{r7, lr}
 80142c2:	b082      	sub	sp, #8
 80142c4:	af00      	add	r7, sp, #0
 80142c6:	6078      	str	r0, [r7, #4]
    switch( f->state ){
 80142c8:	687b      	ldr	r3, [r7, #4]
 80142ca:	7c1b      	ldrb	r3, [r3, #16]
 80142cc:	2b09      	cmp	r3, #9
 80142ce:	d83b      	bhi.n	8014348 <fsm_lowerdown+0x88>
 80142d0:	009a      	lsls	r2, r3, #2
 80142d2:	4b1f      	ldr	r3, [pc, #124]	; (8014350 <fsm_lowerdown+0x90>)
 80142d4:	18d3      	adds	r3, r2, r3
 80142d6:	681b      	ldr	r3, [r3, #0]
 80142d8:	469f      	mov	pc, r3
    case PPP_FSM_CLOSED:
	f->state = PPP_FSM_INITIAL;
 80142da:	687b      	ldr	r3, [r7, #4]
 80142dc:	2200      	movs	r2, #0
 80142de:	741a      	strb	r2, [r3, #16]
	break;
 80142e0:	e032      	b.n	8014348 <fsm_lowerdown+0x88>

    case PPP_FSM_STOPPED:
	f->state = PPP_FSM_STARTING;
 80142e2:	687b      	ldr	r3, [r7, #4]
 80142e4:	2201      	movs	r2, #1
 80142e6:	741a      	strb	r2, [r3, #16]
	if( f->callbacks->starting )
 80142e8:	687b      	ldr	r3, [r7, #4]
 80142ea:	685b      	ldr	r3, [r3, #4]
 80142ec:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80142ee:	2b00      	cmp	r3, #0
 80142f0:	d029      	beq.n	8014346 <fsm_lowerdown+0x86>
	    (*f->callbacks->starting)(f);
 80142f2:	687b      	ldr	r3, [r7, #4]
 80142f4:	685b      	ldr	r3, [r3, #4]
 80142f6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80142f8:	687a      	ldr	r2, [r7, #4]
 80142fa:	0010      	movs	r0, r2
 80142fc:	4798      	blx	r3
	break;
 80142fe:	e022      	b.n	8014346 <fsm_lowerdown+0x86>

    case PPP_FSM_CLOSING:
	f->state = PPP_FSM_INITIAL;
 8014300:	687b      	ldr	r3, [r7, #4]
 8014302:	2200      	movs	r2, #0
 8014304:	741a      	strb	r2, [r3, #16]
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 8014306:	687a      	ldr	r2, [r7, #4]
 8014308:	4b12      	ldr	r3, [pc, #72]	; (8014354 <fsm_lowerdown+0x94>)
 801430a:	0011      	movs	r1, r2
 801430c:	0018      	movs	r0, r3
 801430e:	f7fd fefb 	bl	8012108 <sys_untimeout>
	break;
 8014312:	e019      	b.n	8014348 <fsm_lowerdown+0x88>

    case PPP_FSM_STOPPING:
    case PPP_FSM_REQSENT:
    case PPP_FSM_ACKRCVD:
    case PPP_FSM_ACKSENT:
	f->state = PPP_FSM_STARTING;
 8014314:	687b      	ldr	r3, [r7, #4]
 8014316:	2201      	movs	r2, #1
 8014318:	741a      	strb	r2, [r3, #16]
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 801431a:	687a      	ldr	r2, [r7, #4]
 801431c:	4b0d      	ldr	r3, [pc, #52]	; (8014354 <fsm_lowerdown+0x94>)
 801431e:	0011      	movs	r1, r2
 8014320:	0018      	movs	r0, r3
 8014322:	f7fd fef1 	bl	8012108 <sys_untimeout>
	break;
 8014326:	e00f      	b.n	8014348 <fsm_lowerdown+0x88>

    case PPP_FSM_OPENED:
	if( f->callbacks->down )
 8014328:	687b      	ldr	r3, [r7, #4]
 801432a:	685b      	ldr	r3, [r3, #4]
 801432c:	6a1b      	ldr	r3, [r3, #32]
 801432e:	2b00      	cmp	r3, #0
 8014330:	d005      	beq.n	801433e <fsm_lowerdown+0x7e>
	    (*f->callbacks->down)(f);
 8014332:	687b      	ldr	r3, [r7, #4]
 8014334:	685b      	ldr	r3, [r3, #4]
 8014336:	6a1b      	ldr	r3, [r3, #32]
 8014338:	687a      	ldr	r2, [r7, #4]
 801433a:	0010      	movs	r0, r2
 801433c:	4798      	blx	r3
	f->state = PPP_FSM_STARTING;
 801433e:	687b      	ldr	r3, [r7, #4]
 8014340:	2201      	movs	r2, #1
 8014342:	741a      	strb	r2, [r3, #16]
	break;
 8014344:	e000      	b.n	8014348 <fsm_lowerdown+0x88>
	break;
 8014346:	46c0      	nop			; (mov r8, r8)

    default:
	FSMDEBUG(("%s: Down event in state %d!", PROTO_NAME(f), f->state));
	/* no break */
    }
}
 8014348:	46c0      	nop			; (mov r8, r8)
 801434a:	46bd      	mov	sp, r7
 801434c:	b002      	add	sp, #8
 801434e:	bd80      	pop	{r7, pc}
 8014350:	08022488 	.word	0x08022488
 8014354:	08014565 	.word	0x08014565

08014358 <fsm_open>:


/*
 * fsm_open - Link is allowed to come up.
 */
void fsm_open(fsm *f) {
 8014358:	b580      	push	{r7, lr}
 801435a:	b082      	sub	sp, #8
 801435c:	af00      	add	r7, sp, #0
 801435e:	6078      	str	r0, [r7, #4]
    switch( f->state ){
 8014360:	687b      	ldr	r3, [r7, #4]
 8014362:	7c1b      	ldrb	r3, [r3, #16]
 8014364:	2b09      	cmp	r3, #9
 8014366:	d838      	bhi.n	80143da <fsm_open+0x82>
 8014368:	009a      	lsls	r2, r3, #2
 801436a:	4b20      	ldr	r3, [pc, #128]	; (80143ec <fsm_open+0x94>)
 801436c:	18d3      	adds	r3, r2, r3
 801436e:	681b      	ldr	r3, [r3, #0]
 8014370:	469f      	mov	pc, r3
    case PPP_FSM_INITIAL:
	f->state = PPP_FSM_STARTING;
 8014372:	687b      	ldr	r3, [r7, #4]
 8014374:	2201      	movs	r2, #1
 8014376:	741a      	strb	r2, [r3, #16]
	if( f->callbacks->starting )
 8014378:	687b      	ldr	r3, [r7, #4]
 801437a:	685b      	ldr	r3, [r3, #4]
 801437c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801437e:	2b00      	cmp	r3, #0
 8014380:	d02d      	beq.n	80143de <fsm_open+0x86>
	    (*f->callbacks->starting)(f);
 8014382:	687b      	ldr	r3, [r7, #4]
 8014384:	685b      	ldr	r3, [r3, #4]
 8014386:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8014388:	687a      	ldr	r2, [r7, #4]
 801438a:	0010      	movs	r0, r2
 801438c:	4798      	blx	r3
	break;
 801438e:	e026      	b.n	80143de <fsm_open+0x86>

    case PPP_FSM_CLOSED:
	if( f->flags & OPT_SILENT )
 8014390:	687b      	ldr	r3, [r7, #4]
 8014392:	7c5b      	ldrb	r3, [r3, #17]
 8014394:	001a      	movs	r2, r3
 8014396:	2304      	movs	r3, #4
 8014398:	4013      	ands	r3, r2
 801439a:	d003      	beq.n	80143a4 <fsm_open+0x4c>
	    f->state = PPP_FSM_STOPPED;
 801439c:	687b      	ldr	r3, [r7, #4]
 801439e:	2203      	movs	r2, #3
 80143a0:	741a      	strb	r2, [r3, #16]
	else {
	    /* Send an initial configure-request */
	    fsm_sconfreq(f, 0);
	    f->state = PPP_FSM_REQSENT;
	}
	break;
 80143a2:	e01f      	b.n	80143e4 <fsm_open+0x8c>
	    fsm_sconfreq(f, 0);
 80143a4:	687b      	ldr	r3, [r7, #4]
 80143a6:	2100      	movs	r1, #0
 80143a8:	0018      	movs	r0, r3
 80143aa:	f000 fd6d 	bl	8014e88 <fsm_sconfreq>
	    f->state = PPP_FSM_REQSENT;
 80143ae:	687b      	ldr	r3, [r7, #4]
 80143b0:	2206      	movs	r2, #6
 80143b2:	741a      	strb	r2, [r3, #16]
	break;
 80143b4:	e016      	b.n	80143e4 <fsm_open+0x8c>

    case PPP_FSM_CLOSING:
	f->state = PPP_FSM_STOPPING;
 80143b6:	687b      	ldr	r3, [r7, #4]
 80143b8:	2205      	movs	r2, #5
 80143ba:	741a      	strb	r2, [r3, #16]
	/* fall through */
	/* no break */
    case PPP_FSM_STOPPED:
    case PPP_FSM_OPENED:
	if( f->flags & OPT_RESTART ){
 80143bc:	687b      	ldr	r3, [r7, #4]
 80143be:	7c5b      	ldrb	r3, [r3, #17]
 80143c0:	001a      	movs	r2, r3
 80143c2:	2302      	movs	r3, #2
 80143c4:	4013      	ands	r3, r2
 80143c6:	d00c      	beq.n	80143e2 <fsm_open+0x8a>
	    fsm_lowerdown(f);
 80143c8:	687b      	ldr	r3, [r7, #4]
 80143ca:	0018      	movs	r0, r3
 80143cc:	f7ff ff78 	bl	80142c0 <fsm_lowerdown>
	    fsm_lowerup(f);
 80143d0:	687b      	ldr	r3, [r7, #4]
 80143d2:	0018      	movs	r0, r3
 80143d4:	f7ff ff4d 	bl	8014272 <fsm_lowerup>
	}
	break;
 80143d8:	e003      	b.n	80143e2 <fsm_open+0x8a>
    default:
	break;
 80143da:	46c0      	nop			; (mov r8, r8)
 80143dc:	e002      	b.n	80143e4 <fsm_open+0x8c>
	break;
 80143de:	46c0      	nop			; (mov r8, r8)
 80143e0:	e000      	b.n	80143e4 <fsm_open+0x8c>
	break;
 80143e2:	46c0      	nop			; (mov r8, r8)
    }
}
 80143e4:	46c0      	nop			; (mov r8, r8)
 80143e6:	46bd      	mov	sp, r7
 80143e8:	b002      	add	sp, #8
 80143ea:	bd80      	pop	{r7, pc}
 80143ec:	080224b0 	.word	0x080224b0

080143f0 <terminate_layer>:
 * terminate_layer - Start process of shutting down the FSM
 *
 * Cancel any timeout running, notify upper layers we're done, and
 * send a terminate-request message as configured.
 */
static void terminate_layer(fsm *f, int nextstate) {
 80143f0:	b580      	push	{r7, lr}
 80143f2:	b086      	sub	sp, #24
 80143f4:	af02      	add	r7, sp, #8
 80143f6:	6078      	str	r0, [r7, #4]
 80143f8:	6039      	str	r1, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 80143fa:	687b      	ldr	r3, [r7, #4]
 80143fc:	681b      	ldr	r3, [r3, #0]
 80143fe:	60fb      	str	r3, [r7, #12]

    if( f->state != PPP_FSM_OPENED )
 8014400:	687b      	ldr	r3, [r7, #4]
 8014402:	7c1b      	ldrb	r3, [r3, #16]
 8014404:	2b09      	cmp	r3, #9
 8014406:	d006      	beq.n	8014416 <terminate_layer+0x26>
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 8014408:	687a      	ldr	r2, [r7, #4]
 801440a:	4b33      	ldr	r3, [pc, #204]	; (80144d8 <terminate_layer+0xe8>)
 801440c:	0011      	movs	r1, r2
 801440e:	0018      	movs	r0, r3
 8014410:	f7fd fe7a 	bl	8012108 <sys_untimeout>
 8014414:	e00a      	b.n	801442c <terminate_layer+0x3c>
    else if( f->callbacks->down )
 8014416:	687b      	ldr	r3, [r7, #4]
 8014418:	685b      	ldr	r3, [r3, #4]
 801441a:	6a1b      	ldr	r3, [r3, #32]
 801441c:	2b00      	cmp	r3, #0
 801441e:	d005      	beq.n	801442c <terminate_layer+0x3c>
	(*f->callbacks->down)(f);	/* Inform upper layers we're down */
 8014420:	687b      	ldr	r3, [r7, #4]
 8014422:	685b      	ldr	r3, [r3, #4]
 8014424:	6a1b      	ldr	r3, [r3, #32]
 8014426:	687a      	ldr	r2, [r7, #4]
 8014428:	0010      	movs	r0, r2
 801442a:	4798      	blx	r3

    /* Init restart counter and send Terminate-Request */
    f->retransmits = pcb->settings.fsm_max_term_transmits;
 801442c:	68fb      	ldr	r3, [r7, #12]
 801442e:	799a      	ldrb	r2, [r3, #6]
 8014430:	687b      	ldr	r3, [r7, #4]
 8014432:	751a      	strb	r2, [r3, #20]
    fsm_sdata(f, TERMREQ, f->reqid = ++f->id,
 8014434:	687b      	ldr	r3, [r7, #4]
 8014436:	7c9b      	ldrb	r3, [r3, #18]
 8014438:	3301      	adds	r3, #1
 801443a:	b2da      	uxtb	r2, r3
 801443c:	687b      	ldr	r3, [r7, #4]
 801443e:	749a      	strb	r2, [r3, #18]
 8014440:	687b      	ldr	r3, [r7, #4]
 8014442:	7c9a      	ldrb	r2, [r3, #18]
 8014444:	687b      	ldr	r3, [r7, #4]
 8014446:	74da      	strb	r2, [r3, #19]
 8014448:	687b      	ldr	r3, [r7, #4]
 801444a:	7cda      	ldrb	r2, [r3, #19]
	      (const u_char *) f->term_reason, f->term_reason_len);
 801444c:	687b      	ldr	r3, [r7, #4]
 801444e:	6899      	ldr	r1, [r3, #8]
 8014450:	687b      	ldr	r3, [r7, #4]
 8014452:	7e1b      	ldrb	r3, [r3, #24]
    fsm_sdata(f, TERMREQ, f->reqid = ++f->id,
 8014454:	6878      	ldr	r0, [r7, #4]
 8014456:	9300      	str	r3, [sp, #0]
 8014458:	000b      	movs	r3, r1
 801445a:	2105      	movs	r1, #5
 801445c:	f000 fe0a 	bl	8015074 <fsm_sdata>

    if (f->retransmits == 0) {
 8014460:	687b      	ldr	r3, [r7, #4]
 8014462:	7d1b      	ldrb	r3, [r3, #20]
 8014464:	2b00      	cmp	r3, #0
 8014466:	d113      	bne.n	8014490 <terminate_layer+0xa0>
	/*
	 * User asked for no terminate requests at all; just close it.
	 * We've already fired off one Terminate-Request just to be nice
	 * to the peer, but we're not going to wait for a reply.
	 */
	f->state = nextstate == PPP_FSM_CLOSING ? PPP_FSM_CLOSED : PPP_FSM_STOPPED;
 8014468:	683b      	ldr	r3, [r7, #0]
 801446a:	2b04      	cmp	r3, #4
 801446c:	d101      	bne.n	8014472 <terminate_layer+0x82>
 801446e:	2202      	movs	r2, #2
 8014470:	e000      	b.n	8014474 <terminate_layer+0x84>
 8014472:	2203      	movs	r2, #3
 8014474:	687b      	ldr	r3, [r7, #4]
 8014476:	741a      	strb	r2, [r3, #16]
	if( f->callbacks->finished )
 8014478:	687b      	ldr	r3, [r7, #4]
 801447a:	685b      	ldr	r3, [r3, #4]
 801447c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801447e:	2b00      	cmp	r3, #0
 8014480:	d026      	beq.n	80144d0 <terminate_layer+0xe0>
	    (*f->callbacks->finished)(f);
 8014482:	687b      	ldr	r3, [r7, #4]
 8014484:	685b      	ldr	r3, [r3, #4]
 8014486:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014488:	687a      	ldr	r2, [r7, #4]
 801448a:	0010      	movs	r0, r2
 801448c:	4798      	blx	r3
	return;
 801448e:	e01f      	b.n	80144d0 <terminate_layer+0xe0>
    }

    TIMEOUT(fsm_timeout, f, pcb->settings.fsm_timeout_time);
 8014490:	687a      	ldr	r2, [r7, #4]
 8014492:	4b11      	ldr	r3, [pc, #68]	; (80144d8 <terminate_layer+0xe8>)
 8014494:	0011      	movs	r1, r2
 8014496:	0018      	movs	r0, r3
 8014498:	f7fd fe36 	bl	8012108 <sys_untimeout>
 801449c:	68fb      	ldr	r3, [r7, #12]
 801449e:	791b      	ldrb	r3, [r3, #4]
 80144a0:	001a      	movs	r2, r3
 80144a2:	0013      	movs	r3, r2
 80144a4:	015b      	lsls	r3, r3, #5
 80144a6:	1a9b      	subs	r3, r3, r2
 80144a8:	009b      	lsls	r3, r3, #2
 80144aa:	189b      	adds	r3, r3, r2
 80144ac:	00db      	lsls	r3, r3, #3
 80144ae:	0018      	movs	r0, r3
 80144b0:	687a      	ldr	r2, [r7, #4]
 80144b2:	4b09      	ldr	r3, [pc, #36]	; (80144d8 <terminate_layer+0xe8>)
 80144b4:	0019      	movs	r1, r3
 80144b6:	f7fd fdff 	bl	80120b8 <sys_timeout>
    --f->retransmits;
 80144ba:	687b      	ldr	r3, [r7, #4]
 80144bc:	7d1b      	ldrb	r3, [r3, #20]
 80144be:	3b01      	subs	r3, #1
 80144c0:	b2da      	uxtb	r2, r3
 80144c2:	687b      	ldr	r3, [r7, #4]
 80144c4:	751a      	strb	r2, [r3, #20]

    f->state = nextstate;
 80144c6:	683b      	ldr	r3, [r7, #0]
 80144c8:	b2da      	uxtb	r2, r3
 80144ca:	687b      	ldr	r3, [r7, #4]
 80144cc:	741a      	strb	r2, [r3, #16]
 80144ce:	e000      	b.n	80144d2 <terminate_layer+0xe2>
	return;
 80144d0:	46c0      	nop			; (mov r8, r8)
}
 80144d2:	46bd      	mov	sp, r7
 80144d4:	b004      	add	sp, #16
 80144d6:	bd80      	pop	{r7, pc}
 80144d8:	08014565 	.word	0x08014565

080144dc <fsm_close>:
 * fsm_close - Start closing connection.
 *
 * Cancel timeouts and either initiate close or possibly go directly to
 * the PPP_FSM_CLOSED state.
 */
void fsm_close(fsm *f, const char *reason) {
 80144dc:	b580      	push	{r7, lr}
 80144de:	b082      	sub	sp, #8
 80144e0:	af00      	add	r7, sp, #0
 80144e2:	6078      	str	r0, [r7, #4]
 80144e4:	6039      	str	r1, [r7, #0]
    f->term_reason = reason;
 80144e6:	687b      	ldr	r3, [r7, #4]
 80144e8:	683a      	ldr	r2, [r7, #0]
 80144ea:	609a      	str	r2, [r3, #8]
    f->term_reason_len = (reason == NULL? 0: (u8_t)LWIP_MIN(strlen(reason), 0xFF) );
 80144ec:	683b      	ldr	r3, [r7, #0]
 80144ee:	2b00      	cmp	r3, #0
 80144f0:	d00f      	beq.n	8014512 <fsm_close+0x36>
 80144f2:	683b      	ldr	r3, [r7, #0]
 80144f4:	0018      	movs	r0, r3
 80144f6:	f7eb fe07 	bl	8000108 <strlen>
 80144fa:	0003      	movs	r3, r0
 80144fc:	2bfe      	cmp	r3, #254	; 0xfe
 80144fe:	d806      	bhi.n	801450e <fsm_close+0x32>
 8014500:	683b      	ldr	r3, [r7, #0]
 8014502:	0018      	movs	r0, r3
 8014504:	f7eb fe00 	bl	8000108 <strlen>
 8014508:	0003      	movs	r3, r0
 801450a:	b2db      	uxtb	r3, r3
 801450c:	e002      	b.n	8014514 <fsm_close+0x38>
 801450e:	23ff      	movs	r3, #255	; 0xff
 8014510:	e000      	b.n	8014514 <fsm_close+0x38>
 8014512:	2300      	movs	r3, #0
 8014514:	687a      	ldr	r2, [r7, #4]
 8014516:	7613      	strb	r3, [r2, #24]
    switch( f->state ){
 8014518:	687b      	ldr	r3, [r7, #4]
 801451a:	7c1b      	ldrb	r3, [r3, #16]
 801451c:	2b09      	cmp	r3, #9
 801451e:	dc1b      	bgt.n	8014558 <fsm_close+0x7c>
 8014520:	2b06      	cmp	r3, #6
 8014522:	da13      	bge.n	801454c <fsm_close+0x70>
 8014524:	2b05      	cmp	r3, #5
 8014526:	d00d      	beq.n	8014544 <fsm_close+0x68>
 8014528:	dc16      	bgt.n	8014558 <fsm_close+0x7c>
 801452a:	2b01      	cmp	r3, #1
 801452c:	d002      	beq.n	8014534 <fsm_close+0x58>
 801452e:	2b03      	cmp	r3, #3
 8014530:	d004      	beq.n	801453c <fsm_close+0x60>
    case PPP_FSM_ACKSENT:
    case PPP_FSM_OPENED:
	terminate_layer(f, PPP_FSM_CLOSING);
	break;
    default:
	break;
 8014532:	e011      	b.n	8014558 <fsm_close+0x7c>
	f->state = PPP_FSM_INITIAL;
 8014534:	687b      	ldr	r3, [r7, #4]
 8014536:	2200      	movs	r2, #0
 8014538:	741a      	strb	r2, [r3, #16]
	break;
 801453a:	e00e      	b.n	801455a <fsm_close+0x7e>
	f->state = PPP_FSM_CLOSED;
 801453c:	687b      	ldr	r3, [r7, #4]
 801453e:	2202      	movs	r2, #2
 8014540:	741a      	strb	r2, [r3, #16]
	break;
 8014542:	e00a      	b.n	801455a <fsm_close+0x7e>
	f->state = PPP_FSM_CLOSING;
 8014544:	687b      	ldr	r3, [r7, #4]
 8014546:	2204      	movs	r2, #4
 8014548:	741a      	strb	r2, [r3, #16]
	break;
 801454a:	e006      	b.n	801455a <fsm_close+0x7e>
	terminate_layer(f, PPP_FSM_CLOSING);
 801454c:	687b      	ldr	r3, [r7, #4]
 801454e:	2104      	movs	r1, #4
 8014550:	0018      	movs	r0, r3
 8014552:	f7ff ff4d 	bl	80143f0 <terminate_layer>
	break;
 8014556:	e000      	b.n	801455a <fsm_close+0x7e>
	break;
 8014558:	46c0      	nop			; (mov r8, r8)
    }
}
 801455a:	46c0      	nop			; (mov r8, r8)
 801455c:	46bd      	mov	sp, r7
 801455e:	b002      	add	sp, #8
 8014560:	bd80      	pop	{r7, pc}
	...

08014564 <fsm_timeout>:


/*
 * fsm_timeout - Timeout expired.
 */
static void fsm_timeout(void *arg) {
 8014564:	b580      	push	{r7, lr}
 8014566:	b086      	sub	sp, #24
 8014568:	af02      	add	r7, sp, #8
 801456a:	6078      	str	r0, [r7, #4]
    fsm *f = (fsm *) arg;
 801456c:	687b      	ldr	r3, [r7, #4]
 801456e:	60fb      	str	r3, [r7, #12]
    ppp_pcb *pcb = f->pcb;
 8014570:	68fb      	ldr	r3, [r7, #12]
 8014572:	681b      	ldr	r3, [r3, #0]
 8014574:	60bb      	str	r3, [r7, #8]

    switch (f->state) {
 8014576:	68fb      	ldr	r3, [r7, #12]
 8014578:	7c1b      	ldrb	r3, [r3, #16]
 801457a:	2b05      	cmp	r3, #5
 801457c:	dc02      	bgt.n	8014584 <fsm_timeout+0x20>
 801457e:	2b04      	cmp	r3, #4
 8014580:	da05      	bge.n	801458e <fsm_timeout+0x2a>

    default:
	FSMDEBUG(("%s: Timeout event in state %d!", PROTO_NAME(f), f->state));
	/* no break */
    }
}
 8014582:	e08c      	b.n	801469e <fsm_timeout+0x13a>
 8014584:	3b06      	subs	r3, #6
    switch (f->state) {
 8014586:	2b02      	cmp	r3, #2
 8014588:	d900      	bls.n	801458c <fsm_timeout+0x28>
 801458a:	e088      	b.n	801469e <fsm_timeout+0x13a>
 801458c:	e04b      	b.n	8014626 <fsm_timeout+0xc2>
	if( f->retransmits <= 0 ){
 801458e:	68fb      	ldr	r3, [r7, #12]
 8014590:	7d1b      	ldrb	r3, [r3, #20]
 8014592:	2b00      	cmp	r3, #0
 8014594:	d115      	bne.n	80145c2 <fsm_timeout+0x5e>
	    f->state = (f->state == PPP_FSM_CLOSING)? PPP_FSM_CLOSED: PPP_FSM_STOPPED;
 8014596:	68fb      	ldr	r3, [r7, #12]
 8014598:	7c1b      	ldrb	r3, [r3, #16]
 801459a:	2b04      	cmp	r3, #4
 801459c:	d101      	bne.n	80145a2 <fsm_timeout+0x3e>
 801459e:	2202      	movs	r2, #2
 80145a0:	e000      	b.n	80145a4 <fsm_timeout+0x40>
 80145a2:	2203      	movs	r2, #3
 80145a4:	68fb      	ldr	r3, [r7, #12]
 80145a6:	741a      	strb	r2, [r3, #16]
	    if( f->callbacks->finished )
 80145a8:	68fb      	ldr	r3, [r7, #12]
 80145aa:	685b      	ldr	r3, [r3, #4]
 80145ac:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80145ae:	2b00      	cmp	r3, #0
 80145b0:	d100      	bne.n	80145b4 <fsm_timeout+0x50>
 80145b2:	e071      	b.n	8014698 <fsm_timeout+0x134>
		(*f->callbacks->finished)(f);
 80145b4:	68fb      	ldr	r3, [r7, #12]
 80145b6:	685b      	ldr	r3, [r3, #4]
 80145b8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80145ba:	68fa      	ldr	r2, [r7, #12]
 80145bc:	0010      	movs	r0, r2
 80145be:	4798      	blx	r3
	break;
 80145c0:	e06a      	b.n	8014698 <fsm_timeout+0x134>
	    fsm_sdata(f, TERMREQ, f->reqid = ++f->id,
 80145c2:	68fb      	ldr	r3, [r7, #12]
 80145c4:	7c9b      	ldrb	r3, [r3, #18]
 80145c6:	3301      	adds	r3, #1
 80145c8:	b2da      	uxtb	r2, r3
 80145ca:	68fb      	ldr	r3, [r7, #12]
 80145cc:	749a      	strb	r2, [r3, #18]
 80145ce:	68fb      	ldr	r3, [r7, #12]
 80145d0:	7c9a      	ldrb	r2, [r3, #18]
 80145d2:	68fb      	ldr	r3, [r7, #12]
 80145d4:	74da      	strb	r2, [r3, #19]
 80145d6:	68fb      	ldr	r3, [r7, #12]
 80145d8:	7cda      	ldrb	r2, [r3, #19]
		      (const u_char *) f->term_reason, f->term_reason_len);
 80145da:	68fb      	ldr	r3, [r7, #12]
 80145dc:	6899      	ldr	r1, [r3, #8]
 80145de:	68fb      	ldr	r3, [r7, #12]
 80145e0:	7e1b      	ldrb	r3, [r3, #24]
	    fsm_sdata(f, TERMREQ, f->reqid = ++f->id,
 80145e2:	68f8      	ldr	r0, [r7, #12]
 80145e4:	9300      	str	r3, [sp, #0]
 80145e6:	000b      	movs	r3, r1
 80145e8:	2105      	movs	r1, #5
 80145ea:	f000 fd43 	bl	8015074 <fsm_sdata>
	    TIMEOUT(fsm_timeout, f, pcb->settings.fsm_timeout_time);
 80145ee:	68fa      	ldr	r2, [r7, #12]
 80145f0:	4b2d      	ldr	r3, [pc, #180]	; (80146a8 <fsm_timeout+0x144>)
 80145f2:	0011      	movs	r1, r2
 80145f4:	0018      	movs	r0, r3
 80145f6:	f7fd fd87 	bl	8012108 <sys_untimeout>
 80145fa:	68bb      	ldr	r3, [r7, #8]
 80145fc:	791b      	ldrb	r3, [r3, #4]
 80145fe:	001a      	movs	r2, r3
 8014600:	0013      	movs	r3, r2
 8014602:	015b      	lsls	r3, r3, #5
 8014604:	1a9b      	subs	r3, r3, r2
 8014606:	009b      	lsls	r3, r3, #2
 8014608:	189b      	adds	r3, r3, r2
 801460a:	00db      	lsls	r3, r3, #3
 801460c:	0018      	movs	r0, r3
 801460e:	68fa      	ldr	r2, [r7, #12]
 8014610:	4b25      	ldr	r3, [pc, #148]	; (80146a8 <fsm_timeout+0x144>)
 8014612:	0019      	movs	r1, r3
 8014614:	f7fd fd50 	bl	80120b8 <sys_timeout>
	    --f->retransmits;
 8014618:	68fb      	ldr	r3, [r7, #12]
 801461a:	7d1b      	ldrb	r3, [r3, #20]
 801461c:	3b01      	subs	r3, #1
 801461e:	b2da      	uxtb	r2, r3
 8014620:	68fb      	ldr	r3, [r7, #12]
 8014622:	751a      	strb	r2, [r3, #20]
	break;
 8014624:	e038      	b.n	8014698 <fsm_timeout+0x134>
	if (f->retransmits <= 0) {
 8014626:	68fb      	ldr	r3, [r7, #12]
 8014628:	7d1b      	ldrb	r3, [r3, #20]
 801462a:	2b00      	cmp	r3, #0
 801462c:	d11c      	bne.n	8014668 <fsm_timeout+0x104>
	    ppp_warn("%s: timeout sending Config-Requests", PROTO_NAME(f));
 801462e:	68fb      	ldr	r3, [r7, #12]
 8014630:	685b      	ldr	r3, [r3, #4]
 8014632:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8014634:	4b1d      	ldr	r3, [pc, #116]	; (80146ac <fsm_timeout+0x148>)
 8014636:	0011      	movs	r1, r2
 8014638:	0018      	movs	r0, r3
 801463a:	f006 ff86 	bl	801b54a <ppp_warn>
	    f->state = PPP_FSM_STOPPED;
 801463e:	68fb      	ldr	r3, [r7, #12]
 8014640:	2203      	movs	r2, #3
 8014642:	741a      	strb	r2, [r3, #16]
	    if( (f->flags & OPT_PASSIVE) == 0 && f->callbacks->finished )
 8014644:	68fb      	ldr	r3, [r7, #12]
 8014646:	7c5b      	ldrb	r3, [r3, #17]
 8014648:	001a      	movs	r2, r3
 801464a:	2301      	movs	r3, #1
 801464c:	4013      	ands	r3, r2
 801464e:	d125      	bne.n	801469c <fsm_timeout+0x138>
 8014650:	68fb      	ldr	r3, [r7, #12]
 8014652:	685b      	ldr	r3, [r3, #4]
 8014654:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014656:	2b00      	cmp	r3, #0
 8014658:	d020      	beq.n	801469c <fsm_timeout+0x138>
		(*f->callbacks->finished)(f);
 801465a:	68fb      	ldr	r3, [r7, #12]
 801465c:	685b      	ldr	r3, [r3, #4]
 801465e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014660:	68fa      	ldr	r2, [r7, #12]
 8014662:	0010      	movs	r0, r2
 8014664:	4798      	blx	r3
	break;
 8014666:	e019      	b.n	801469c <fsm_timeout+0x138>
	    if (f->callbacks->retransmit)
 8014668:	68fb      	ldr	r3, [r7, #12]
 801466a:	685b      	ldr	r3, [r3, #4]
 801466c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801466e:	2b00      	cmp	r3, #0
 8014670:	d005      	beq.n	801467e <fsm_timeout+0x11a>
		(*f->callbacks->retransmit)(f);
 8014672:	68fb      	ldr	r3, [r7, #12]
 8014674:	685b      	ldr	r3, [r3, #4]
 8014676:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014678:	68fa      	ldr	r2, [r7, #12]
 801467a:	0010      	movs	r0, r2
 801467c:	4798      	blx	r3
	    fsm_sconfreq(f, 1);		/* Re-send Configure-Request */
 801467e:	68fb      	ldr	r3, [r7, #12]
 8014680:	2101      	movs	r1, #1
 8014682:	0018      	movs	r0, r3
 8014684:	f000 fc00 	bl	8014e88 <fsm_sconfreq>
	    if( f->state == PPP_FSM_ACKRCVD )
 8014688:	68fb      	ldr	r3, [r7, #12]
 801468a:	7c1b      	ldrb	r3, [r3, #16]
 801468c:	2b07      	cmp	r3, #7
 801468e:	d105      	bne.n	801469c <fsm_timeout+0x138>
		f->state = PPP_FSM_REQSENT;
 8014690:	68fb      	ldr	r3, [r7, #12]
 8014692:	2206      	movs	r2, #6
 8014694:	741a      	strb	r2, [r3, #16]
	break;
 8014696:	e001      	b.n	801469c <fsm_timeout+0x138>
	break;
 8014698:	46c0      	nop			; (mov r8, r8)
 801469a:	e000      	b.n	801469e <fsm_timeout+0x13a>
	break;
 801469c:	46c0      	nop			; (mov r8, r8)
}
 801469e:	46c0      	nop			; (mov r8, r8)
 80146a0:	46bd      	mov	sp, r7
 80146a2:	b004      	add	sp, #16
 80146a4:	bd80      	pop	{r7, pc}
 80146a6:	46c0      	nop			; (mov r8, r8)
 80146a8:	08014565 	.word	0x08014565
 80146ac:	08021628 	.word	0x08021628

080146b0 <fsm_input>:


/*
 * fsm_input - Input packet.
 */
void fsm_input(fsm *f, u_char *inpacket, int l) {
 80146b0:	b5b0      	push	{r4, r5, r7, lr}
 80146b2:	b08a      	sub	sp, #40	; 0x28
 80146b4:	af02      	add	r7, sp, #8
 80146b6:	60f8      	str	r0, [r7, #12]
 80146b8:	60b9      	str	r1, [r7, #8]
 80146ba:	607a      	str	r2, [r7, #4]

    /*
     * Parse header (code, id and length).
     * If packet too short, drop it.
     */
    inp = inpacket;
 80146bc:	68bb      	ldr	r3, [r7, #8]
 80146be:	61fb      	str	r3, [r7, #28]
    if (l < HEADERLEN) {
 80146c0:	687b      	ldr	r3, [r7, #4]
 80146c2:	2b03      	cmp	r3, #3
 80146c4:	dc00      	bgt.n	80146c8 <fsm_input+0x18>
 80146c6:	e097      	b.n	80147f8 <fsm_input+0x148>
	FSMDEBUG(("fsm_input(%x): Rcvd short header.", f->protocol));
	return;
    }
    GETCHAR(code, inp);
 80146c8:	69fb      	ldr	r3, [r7, #28]
 80146ca:	1c5a      	adds	r2, r3, #1
 80146cc:	61fa      	str	r2, [r7, #28]
 80146ce:	211b      	movs	r1, #27
 80146d0:	187a      	adds	r2, r7, r1
 80146d2:	781b      	ldrb	r3, [r3, #0]
 80146d4:	7013      	strb	r3, [r2, #0]
    GETCHAR(id, inp);
 80146d6:	69fb      	ldr	r3, [r7, #28]
 80146d8:	1c5a      	adds	r2, r3, #1
 80146da:	61fa      	str	r2, [r7, #28]
 80146dc:	221a      	movs	r2, #26
 80146de:	18ba      	adds	r2, r7, r2
 80146e0:	781b      	ldrb	r3, [r3, #0]
 80146e2:	7013      	strb	r3, [r2, #0]
    GETSHORT(len, inp);
 80146e4:	69fb      	ldr	r3, [r7, #28]
 80146e6:	1c5a      	adds	r2, r3, #1
 80146e8:	61fa      	str	r2, [r7, #28]
 80146ea:	781b      	ldrb	r3, [r3, #0]
 80146ec:	021b      	lsls	r3, r3, #8
 80146ee:	617b      	str	r3, [r7, #20]
 80146f0:	69fb      	ldr	r3, [r7, #28]
 80146f2:	1c5a      	adds	r2, r3, #1
 80146f4:	61fa      	str	r2, [r7, #28]
 80146f6:	781b      	ldrb	r3, [r3, #0]
 80146f8:	001a      	movs	r2, r3
 80146fa:	697b      	ldr	r3, [r7, #20]
 80146fc:	4313      	orrs	r3, r2
 80146fe:	617b      	str	r3, [r7, #20]
    if (len < HEADERLEN) {
 8014700:	697b      	ldr	r3, [r7, #20]
 8014702:	2b03      	cmp	r3, #3
 8014704:	dc00      	bgt.n	8014708 <fsm_input+0x58>
 8014706:	e079      	b.n	80147fc <fsm_input+0x14c>
	FSMDEBUG(("fsm_input(%x): Rcvd illegal length.", f->protocol));
	return;
    }
    if (len > l) {
 8014708:	697a      	ldr	r2, [r7, #20]
 801470a:	687b      	ldr	r3, [r7, #4]
 801470c:	429a      	cmp	r2, r3
 801470e:	dd00      	ble.n	8014712 <fsm_input+0x62>
 8014710:	e076      	b.n	8014800 <fsm_input+0x150>
	FSMDEBUG(("fsm_input(%x): Rcvd short packet.", f->protocol));
	return;
    }
    len -= HEADERLEN;		/* subtract header length */
 8014712:	697b      	ldr	r3, [r7, #20]
 8014714:	3b04      	subs	r3, #4
 8014716:	617b      	str	r3, [r7, #20]

    if( f->state == PPP_FSM_INITIAL || f->state == PPP_FSM_STARTING ){
 8014718:	68fb      	ldr	r3, [r7, #12]
 801471a:	7c1b      	ldrb	r3, [r3, #16]
 801471c:	2b00      	cmp	r3, #0
 801471e:	d100      	bne.n	8014722 <fsm_input+0x72>
 8014720:	e070      	b.n	8014804 <fsm_input+0x154>
 8014722:	68fb      	ldr	r3, [r7, #12]
 8014724:	7c1b      	ldrb	r3, [r3, #16]
 8014726:	2b01      	cmp	r3, #1
 8014728:	d06c      	beq.n	8014804 <fsm_input+0x154>
    }

    /*
     * Action depends on code.
     */
    switch (code) {
 801472a:	187b      	adds	r3, r7, r1
 801472c:	781b      	ldrb	r3, [r3, #0]
 801472e:	2b07      	cmp	r3, #7
 8014730:	d83a      	bhi.n	80147a8 <fsm_input+0xf8>
 8014732:	009a      	lsls	r2, r3, #2
 8014734:	4b36      	ldr	r3, [pc, #216]	; (8014810 <fsm_input+0x160>)
 8014736:	18d3      	adds	r3, r2, r3
 8014738:	681b      	ldr	r3, [r3, #0]
 801473a:	469f      	mov	pc, r3
    case CONFREQ:
	fsm_rconfreq(f, id, inp, len);
 801473c:	697c      	ldr	r4, [r7, #20]
 801473e:	69fa      	ldr	r2, [r7, #28]
 8014740:	231a      	movs	r3, #26
 8014742:	18fb      	adds	r3, r7, r3
 8014744:	7819      	ldrb	r1, [r3, #0]
 8014746:	68f8      	ldr	r0, [r7, #12]
 8014748:	0023      	movs	r3, r4
 801474a:	f000 f863 	bl	8014814 <fsm_rconfreq>
	break;
 801474e:	e05c      	b.n	801480a <fsm_input+0x15a>
    
    case CONFACK:
	fsm_rconfack(f, id, inp, len);
 8014750:	231a      	movs	r3, #26
 8014752:	18fb      	adds	r3, r7, r3
 8014754:	7819      	ldrb	r1, [r3, #0]
 8014756:	697b      	ldr	r3, [r7, #20]
 8014758:	69fa      	ldr	r2, [r7, #28]
 801475a:	68f8      	ldr	r0, [r7, #12]
 801475c:	f000 f904 	bl	8014968 <fsm_rconfack>
	break;
 8014760:	e053      	b.n	801480a <fsm_input+0x15a>
    
    case CONFNAK:
    case CONFREJ:
	fsm_rconfnakrej(f, code, id, inp, len);
 8014762:	231b      	movs	r3, #27
 8014764:	18fb      	adds	r3, r7, r3
 8014766:	7819      	ldrb	r1, [r3, #0]
 8014768:	231a      	movs	r3, #26
 801476a:	18fb      	adds	r3, r7, r3
 801476c:	781a      	ldrb	r2, [r3, #0]
 801476e:	69fc      	ldr	r4, [r7, #28]
 8014770:	68f8      	ldr	r0, [r7, #12]
 8014772:	697b      	ldr	r3, [r7, #20]
 8014774:	9300      	str	r3, [sp, #0]
 8014776:	0023      	movs	r3, r4
 8014778:	f000 f996 	bl	8014aa8 <fsm_rconfnakrej>
	break;
 801477c:	e045      	b.n	801480a <fsm_input+0x15a>
    
    case TERMREQ:
	fsm_rtermreq(f, id, inp, len);
 801477e:	231a      	movs	r3, #26
 8014780:	18fb      	adds	r3, r7, r3
 8014782:	7819      	ldrb	r1, [r3, #0]
 8014784:	697b      	ldr	r3, [r7, #20]
 8014786:	69fa      	ldr	r2, [r7, #28]
 8014788:	68f8      	ldr	r0, [r7, #12]
 801478a:	f000 fa41 	bl	8014c10 <fsm_rtermreq>
	break;
 801478e:	e03c      	b.n	801480a <fsm_input+0x15a>
    
    case TERMACK:
	fsm_rtermack(f);
 8014790:	68fb      	ldr	r3, [r7, #12]
 8014792:	0018      	movs	r0, r3
 8014794:	f000 faa2 	bl	8014cdc <fsm_rtermack>
	break;
 8014798:	e037      	b.n	801480a <fsm_input+0x15a>
    
    case CODEREJ:
	fsm_rcoderej(f, inp, len);
 801479a:	697a      	ldr	r2, [r7, #20]
 801479c:	69f9      	ldr	r1, [r7, #28]
 801479e:	68fb      	ldr	r3, [r7, #12]
 80147a0:	0018      	movs	r0, r3
 80147a2:	f000 faf9 	bl	8014d98 <fsm_rcoderej>
	break;
 80147a6:	e030      	b.n	801480a <fsm_input+0x15a>
    
    default:
	if( !f->callbacks->extcode
 80147a8:	68fb      	ldr	r3, [r7, #12]
 80147aa:	685b      	ldr	r3, [r3, #4]
 80147ac:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80147ae:	2b00      	cmp	r3, #0
 80147b0:	d010      	beq.n	80147d4 <fsm_input+0x124>
	   || !(*f->callbacks->extcode)(f, code, id, inp, len) )
 80147b2:	68fb      	ldr	r3, [r7, #12]
 80147b4:	685b      	ldr	r3, [r3, #4]
 80147b6:	6b5c      	ldr	r4, [r3, #52]	; 0x34
 80147b8:	231b      	movs	r3, #27
 80147ba:	18fb      	adds	r3, r7, r3
 80147bc:	7819      	ldrb	r1, [r3, #0]
 80147be:	231a      	movs	r3, #26
 80147c0:	18fb      	adds	r3, r7, r3
 80147c2:	781a      	ldrb	r2, [r3, #0]
 80147c4:	69fd      	ldr	r5, [r7, #28]
 80147c6:	68f8      	ldr	r0, [r7, #12]
 80147c8:	697b      	ldr	r3, [r7, #20]
 80147ca:	9300      	str	r3, [sp, #0]
 80147cc:	002b      	movs	r3, r5
 80147ce:	47a0      	blx	r4
 80147d0:	1e03      	subs	r3, r0, #0
 80147d2:	d119      	bne.n	8014808 <fsm_input+0x158>
	    fsm_sdata(f, CODEREJ, ++f->id, inpacket, len + HEADERLEN);
 80147d4:	68fb      	ldr	r3, [r7, #12]
 80147d6:	7c9b      	ldrb	r3, [r3, #18]
 80147d8:	3301      	adds	r3, #1
 80147da:	b2da      	uxtb	r2, r3
 80147dc:	68fb      	ldr	r3, [r7, #12]
 80147de:	749a      	strb	r2, [r3, #18]
 80147e0:	68fb      	ldr	r3, [r7, #12]
 80147e2:	7c9a      	ldrb	r2, [r3, #18]
 80147e4:	697b      	ldr	r3, [r7, #20]
 80147e6:	3304      	adds	r3, #4
 80147e8:	68b9      	ldr	r1, [r7, #8]
 80147ea:	68f8      	ldr	r0, [r7, #12]
 80147ec:	9300      	str	r3, [sp, #0]
 80147ee:	000b      	movs	r3, r1
 80147f0:	2107      	movs	r1, #7
 80147f2:	f000 fc3f 	bl	8015074 <fsm_sdata>
	break;
 80147f6:	e007      	b.n	8014808 <fsm_input+0x158>
	return;
 80147f8:	46c0      	nop			; (mov r8, r8)
 80147fa:	e006      	b.n	801480a <fsm_input+0x15a>
	return;
 80147fc:	46c0      	nop			; (mov r8, r8)
 80147fe:	e004      	b.n	801480a <fsm_input+0x15a>
	return;
 8014800:	46c0      	nop			; (mov r8, r8)
 8014802:	e002      	b.n	801480a <fsm_input+0x15a>
	return;
 8014804:	46c0      	nop			; (mov r8, r8)
 8014806:	e000      	b.n	801480a <fsm_input+0x15a>
	break;
 8014808:	46c0      	nop			; (mov r8, r8)
    }
}
 801480a:	46bd      	mov	sp, r7
 801480c:	b008      	add	sp, #32
 801480e:	bdb0      	pop	{r4, r5, r7, pc}
 8014810:	080224d8 	.word	0x080224d8

08014814 <fsm_rconfreq>:


/*
 * fsm_rconfreq - Receive Configure-Request.
 */
static void fsm_rconfreq(fsm *f, u_char id, u_char *inp, int len) {
 8014814:	b590      	push	{r4, r7, lr}
 8014816:	b089      	sub	sp, #36	; 0x24
 8014818:	af02      	add	r7, sp, #8
 801481a:	60f8      	str	r0, [r7, #12]
 801481c:	607a      	str	r2, [r7, #4]
 801481e:	603b      	str	r3, [r7, #0]
 8014820:	230b      	movs	r3, #11
 8014822:	18fb      	adds	r3, r7, r3
 8014824:	1c0a      	adds	r2, r1, #0
 8014826:	701a      	strb	r2, [r3, #0]
    int code, reject_if_disagree;

    switch( f->state ){
 8014828:	68fb      	ldr	r3, [r7, #12]
 801482a:	7c1b      	ldrb	r3, [r3, #16]
 801482c:	2b09      	cmp	r3, #9
 801482e:	d015      	beq.n	801485c <fsm_rconfreq+0x48>
 8014830:	dc31      	bgt.n	8014896 <fsm_rconfreq+0x82>
 8014832:	2b05      	cmp	r3, #5
 8014834:	dc2f      	bgt.n	8014896 <fsm_rconfreq+0x82>
 8014836:	2b04      	cmp	r3, #4
 8014838:	db00      	blt.n	801483c <fsm_rconfreq+0x28>
 801483a:	e08e      	b.n	801495a <fsm_rconfreq+0x146>
 801483c:	2b02      	cmp	r3, #2
 801483e:	d002      	beq.n	8014846 <fsm_rconfreq+0x32>
 8014840:	2b03      	cmp	r3, #3
 8014842:	d01f      	beq.n	8014884 <fsm_rconfreq+0x70>
	/* Negotiation started by our peer */
	fsm_sconfreq(f, 0);		/* Send initial Configure-Request */
	f->state = PPP_FSM_REQSENT;
	break;
    default:
	break;
 8014844:	e027      	b.n	8014896 <fsm_rconfreq+0x82>
	fsm_sdata(f, TERMACK, id, NULL, 0);
 8014846:	230b      	movs	r3, #11
 8014848:	18fb      	adds	r3, r7, r3
 801484a:	781a      	ldrb	r2, [r3, #0]
 801484c:	68f8      	ldr	r0, [r7, #12]
 801484e:	2300      	movs	r3, #0
 8014850:	9300      	str	r3, [sp, #0]
 8014852:	2300      	movs	r3, #0
 8014854:	2106      	movs	r1, #6
 8014856:	f000 fc0d 	bl	8015074 <fsm_sdata>
	return;
 801485a:	e07f      	b.n	801495c <fsm_rconfreq+0x148>
	if( f->callbacks->down )
 801485c:	68fb      	ldr	r3, [r7, #12]
 801485e:	685b      	ldr	r3, [r3, #4]
 8014860:	6a1b      	ldr	r3, [r3, #32]
 8014862:	2b00      	cmp	r3, #0
 8014864:	d005      	beq.n	8014872 <fsm_rconfreq+0x5e>
	    (*f->callbacks->down)(f);	/* Inform upper layers */
 8014866:	68fb      	ldr	r3, [r7, #12]
 8014868:	685b      	ldr	r3, [r3, #4]
 801486a:	6a1b      	ldr	r3, [r3, #32]
 801486c:	68fa      	ldr	r2, [r7, #12]
 801486e:	0010      	movs	r0, r2
 8014870:	4798      	blx	r3
	fsm_sconfreq(f, 0);		/* Send initial Configure-Request */
 8014872:	68fb      	ldr	r3, [r7, #12]
 8014874:	2100      	movs	r1, #0
 8014876:	0018      	movs	r0, r3
 8014878:	f000 fb06 	bl	8014e88 <fsm_sconfreq>
	f->state = PPP_FSM_REQSENT;
 801487c:	68fb      	ldr	r3, [r7, #12]
 801487e:	2206      	movs	r2, #6
 8014880:	741a      	strb	r2, [r3, #16]
	break;
 8014882:	e009      	b.n	8014898 <fsm_rconfreq+0x84>
	fsm_sconfreq(f, 0);		/* Send initial Configure-Request */
 8014884:	68fb      	ldr	r3, [r7, #12]
 8014886:	2100      	movs	r1, #0
 8014888:	0018      	movs	r0, r3
 801488a:	f000 fafd 	bl	8014e88 <fsm_sconfreq>
	f->state = PPP_FSM_REQSENT;
 801488e:	68fb      	ldr	r3, [r7, #12]
 8014890:	2206      	movs	r2, #6
 8014892:	741a      	strb	r2, [r3, #16]
	break;
 8014894:	e000      	b.n	8014898 <fsm_rconfreq+0x84>
	break;
 8014896:	46c0      	nop			; (mov r8, r8)

    /*
     * Pass the requested configuration options
     * to protocol-specific code for checking.
     */
    if (f->callbacks->reqci){		/* Check CI */
 8014898:	68fb      	ldr	r3, [r7, #12]
 801489a:	685b      	ldr	r3, [r3, #4]
 801489c:	699b      	ldr	r3, [r3, #24]
 801489e:	2b00      	cmp	r3, #0
 80148a0:	d013      	beq.n	80148ca <fsm_rconfreq+0xb6>
	reject_if_disagree = (f->nakloops >= f->maxnakloops);
 80148a2:	68fb      	ldr	r3, [r7, #12]
 80148a4:	7d59      	ldrb	r1, [r3, #21]
 80148a6:	68fb      	ldr	r3, [r7, #12]
 80148a8:	7dda      	ldrb	r2, [r3, #23]
 80148aa:	2300      	movs	r3, #0
 80148ac:	4291      	cmp	r1, r2
 80148ae:	415b      	adcs	r3, r3
 80148b0:	b2db      	uxtb	r3, r3
 80148b2:	613b      	str	r3, [r7, #16]
	code = (*f->callbacks->reqci)(f, inp, &len, reject_if_disagree);
 80148b4:	68fb      	ldr	r3, [r7, #12]
 80148b6:	685b      	ldr	r3, [r3, #4]
 80148b8:	699c      	ldr	r4, [r3, #24]
 80148ba:	693b      	ldr	r3, [r7, #16]
 80148bc:	003a      	movs	r2, r7
 80148be:	6879      	ldr	r1, [r7, #4]
 80148c0:	68f8      	ldr	r0, [r7, #12]
 80148c2:	47a0      	blx	r4
 80148c4:	0003      	movs	r3, r0
 80148c6:	617b      	str	r3, [r7, #20]
 80148c8:	e007      	b.n	80148da <fsm_rconfreq+0xc6>
    } else if (len)
 80148ca:	683b      	ldr	r3, [r7, #0]
 80148cc:	2b00      	cmp	r3, #0
 80148ce:	d002      	beq.n	80148d6 <fsm_rconfreq+0xc2>
	code = CONFREJ;			/* Reject all CI */
 80148d0:	2304      	movs	r3, #4
 80148d2:	617b      	str	r3, [r7, #20]
 80148d4:	e001      	b.n	80148da <fsm_rconfreq+0xc6>
    else
	code = CONFACK;
 80148d6:	2302      	movs	r3, #2
 80148d8:	617b      	str	r3, [r7, #20]

    /* send the Ack, Nak or Rej to the peer */
    fsm_sdata(f, code, id, inp, len);
 80148da:	697b      	ldr	r3, [r7, #20]
 80148dc:	b2d9      	uxtb	r1, r3
 80148de:	683b      	ldr	r3, [r7, #0]
 80148e0:	687c      	ldr	r4, [r7, #4]
 80148e2:	220b      	movs	r2, #11
 80148e4:	18ba      	adds	r2, r7, r2
 80148e6:	7812      	ldrb	r2, [r2, #0]
 80148e8:	68f8      	ldr	r0, [r7, #12]
 80148ea:	9300      	str	r3, [sp, #0]
 80148ec:	0023      	movs	r3, r4
 80148ee:	f000 fbc1 	bl	8015074 <fsm_sdata>

    if (code == CONFACK) {
 80148f2:	697b      	ldr	r3, [r7, #20]
 80148f4:	2b02      	cmp	r3, #2
 80148f6:	d11f      	bne.n	8014938 <fsm_rconfreq+0x124>
	if (f->state == PPP_FSM_ACKRCVD) {
 80148f8:	68fb      	ldr	r3, [r7, #12]
 80148fa:	7c1b      	ldrb	r3, [r3, #16]
 80148fc:	2b07      	cmp	r3, #7
 80148fe:	d114      	bne.n	801492a <fsm_rconfreq+0x116>
	    UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 8014900:	68fa      	ldr	r2, [r7, #12]
 8014902:	4b18      	ldr	r3, [pc, #96]	; (8014964 <fsm_rconfreq+0x150>)
 8014904:	0011      	movs	r1, r2
 8014906:	0018      	movs	r0, r3
 8014908:	f7fd fbfe 	bl	8012108 <sys_untimeout>
	    f->state = PPP_FSM_OPENED;
 801490c:	68fb      	ldr	r3, [r7, #12]
 801490e:	2209      	movs	r2, #9
 8014910:	741a      	strb	r2, [r3, #16]
	    if (f->callbacks->up)
 8014912:	68fb      	ldr	r3, [r7, #12]
 8014914:	685b      	ldr	r3, [r3, #4]
 8014916:	69db      	ldr	r3, [r3, #28]
 8014918:	2b00      	cmp	r3, #0
 801491a:	d009      	beq.n	8014930 <fsm_rconfreq+0x11c>
		(*f->callbacks->up)(f);	/* Inform upper layers */
 801491c:	68fb      	ldr	r3, [r7, #12]
 801491e:	685b      	ldr	r3, [r3, #4]
 8014920:	69db      	ldr	r3, [r3, #28]
 8014922:	68fa      	ldr	r2, [r7, #12]
 8014924:	0010      	movs	r0, r2
 8014926:	4798      	blx	r3
 8014928:	e002      	b.n	8014930 <fsm_rconfreq+0x11c>
	} else
	    f->state = PPP_FSM_ACKSENT;
 801492a:	68fb      	ldr	r3, [r7, #12]
 801492c:	2208      	movs	r2, #8
 801492e:	741a      	strb	r2, [r3, #16]
	f->nakloops = 0;
 8014930:	68fb      	ldr	r3, [r7, #12]
 8014932:	2200      	movs	r2, #0
 8014934:	755a      	strb	r2, [r3, #21]
 8014936:	e011      	b.n	801495c <fsm_rconfreq+0x148>

    } else {
	/* we sent CONFACK or CONFREJ */
	if (f->state != PPP_FSM_ACKRCVD)
 8014938:	68fb      	ldr	r3, [r7, #12]
 801493a:	7c1b      	ldrb	r3, [r3, #16]
 801493c:	2b07      	cmp	r3, #7
 801493e:	d002      	beq.n	8014946 <fsm_rconfreq+0x132>
	    f->state = PPP_FSM_REQSENT;
 8014940:	68fb      	ldr	r3, [r7, #12]
 8014942:	2206      	movs	r2, #6
 8014944:	741a      	strb	r2, [r3, #16]
	if( code == CONFNAK )
 8014946:	697b      	ldr	r3, [r7, #20]
 8014948:	2b03      	cmp	r3, #3
 801494a:	d107      	bne.n	801495c <fsm_rconfreq+0x148>
	    ++f->nakloops;
 801494c:	68fb      	ldr	r3, [r7, #12]
 801494e:	7d5b      	ldrb	r3, [r3, #21]
 8014950:	3301      	adds	r3, #1
 8014952:	b2da      	uxtb	r2, r3
 8014954:	68fb      	ldr	r3, [r7, #12]
 8014956:	755a      	strb	r2, [r3, #21]
 8014958:	e000      	b.n	801495c <fsm_rconfreq+0x148>
	return;
 801495a:	46c0      	nop			; (mov r8, r8)
    }
}
 801495c:	46bd      	mov	sp, r7
 801495e:	b007      	add	sp, #28
 8014960:	bd90      	pop	{r4, r7, pc}
 8014962:	46c0      	nop			; (mov r8, r8)
 8014964:	08014565 	.word	0x08014565

08014968 <fsm_rconfack>:


/*
 * fsm_rconfack - Receive Configure-Ack.
 */
static void fsm_rconfack(fsm *f, int id, u_char *inp, int len) {
 8014968:	b580      	push	{r7, lr}
 801496a:	b088      	sub	sp, #32
 801496c:	af02      	add	r7, sp, #8
 801496e:	60f8      	str	r0, [r7, #12]
 8014970:	60b9      	str	r1, [r7, #8]
 8014972:	607a      	str	r2, [r7, #4]
 8014974:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 8014976:	68fb      	ldr	r3, [r7, #12]
 8014978:	681b      	ldr	r3, [r3, #0]
 801497a:	617b      	str	r3, [r7, #20]

    if (id != f->reqid || f->seen_ack)		/* Expected id? */
 801497c:	68fb      	ldr	r3, [r7, #12]
 801497e:	7cdb      	ldrb	r3, [r3, #19]
 8014980:	001a      	movs	r2, r3
 8014982:	68bb      	ldr	r3, [r7, #8]
 8014984:	4293      	cmp	r3, r2
 8014986:	d000      	beq.n	801498a <fsm_rconfack+0x22>
 8014988:	e07f      	b.n	8014a8a <fsm_rconfack+0x122>
 801498a:	68fb      	ldr	r3, [r7, #12]
 801498c:	7b1b      	ldrb	r3, [r3, #12]
 801498e:	2b00      	cmp	r3, #0
 8014990:	d000      	beq.n	8014994 <fsm_rconfack+0x2c>
 8014992:	e07a      	b.n	8014a8a <fsm_rconfack+0x122>
	return;					/* Nope, toss... */
    if( !(f->callbacks->ackci? (*f->callbacks->ackci)(f, inp, len):
 8014994:	68fb      	ldr	r3, [r7, #12]
 8014996:	685b      	ldr	r3, [r3, #4]
 8014998:	68db      	ldr	r3, [r3, #12]
 801499a:	2b00      	cmp	r3, #0
 801499c:	d00b      	beq.n	80149b6 <fsm_rconfack+0x4e>
 801499e:	68fb      	ldr	r3, [r7, #12]
 80149a0:	685b      	ldr	r3, [r3, #4]
 80149a2:	68db      	ldr	r3, [r3, #12]
 80149a4:	683a      	ldr	r2, [r7, #0]
 80149a6:	6879      	ldr	r1, [r7, #4]
 80149a8:	68f8      	ldr	r0, [r7, #12]
 80149aa:	4798      	blx	r3
 80149ac:	0003      	movs	r3, r0
 80149ae:	425a      	negs	r2, r3
 80149b0:	4153      	adcs	r3, r2
 80149b2:	b2db      	uxtb	r3, r3
 80149b4:	e003      	b.n	80149be <fsm_rconfack+0x56>
 80149b6:	683b      	ldr	r3, [r7, #0]
 80149b8:	1e5a      	subs	r2, r3, #1
 80149ba:	4193      	sbcs	r3, r2
 80149bc:	b2db      	uxtb	r3, r3
 80149be:	2b00      	cmp	r3, #0
 80149c0:	d006      	beq.n	80149d0 <fsm_rconfack+0x68>
	  (len == 0)) ){
	/* Ack is bad - ignore it */
	ppp_error("Received bad configure-ack: %P", inp, len);
 80149c2:	683a      	ldr	r2, [r7, #0]
 80149c4:	6879      	ldr	r1, [r7, #4]
 80149c6:	4b35      	ldr	r3, [pc, #212]	; (8014a9c <fsm_rconfack+0x134>)
 80149c8:	0018      	movs	r0, r3
 80149ca:	f006 fdaa 	bl	801b522 <ppp_error>
	return;
 80149ce:	e061      	b.n	8014a94 <fsm_rconfack+0x12c>
    }
    f->seen_ack = 1;
 80149d0:	68fb      	ldr	r3, [r7, #12]
 80149d2:	2201      	movs	r2, #1
 80149d4:	731a      	strb	r2, [r3, #12]
    f->rnakloops = 0;
 80149d6:	68fb      	ldr	r3, [r7, #12]
 80149d8:	2200      	movs	r2, #0
 80149da:	759a      	strb	r2, [r3, #22]

    switch (f->state) {
 80149dc:	68fb      	ldr	r3, [r7, #12]
 80149de:	7c1b      	ldrb	r3, [r3, #16]
 80149e0:	2b09      	cmp	r3, #9
 80149e2:	d854      	bhi.n	8014a8e <fsm_rconfack+0x126>
 80149e4:	009a      	lsls	r2, r3, #2
 80149e6:	4b2e      	ldr	r3, [pc, #184]	; (8014aa0 <fsm_rconfack+0x138>)
 80149e8:	18d3      	adds	r3, r2, r3
 80149ea:	681b      	ldr	r3, [r3, #0]
 80149ec:	469f      	mov	pc, r3
    case PPP_FSM_CLOSED:
    case PPP_FSM_STOPPED:
	fsm_sdata(f, TERMACK, id, NULL, 0);
 80149ee:	68bb      	ldr	r3, [r7, #8]
 80149f0:	b2da      	uxtb	r2, r3
 80149f2:	68f8      	ldr	r0, [r7, #12]
 80149f4:	2300      	movs	r3, #0
 80149f6:	9300      	str	r3, [sp, #0]
 80149f8:	2300      	movs	r3, #0
 80149fa:	2106      	movs	r1, #6
 80149fc:	f000 fb3a 	bl	8015074 <fsm_sdata>
	break;
 8014a00:	e048      	b.n	8014a94 <fsm_rconfack+0x12c>

    case PPP_FSM_REQSENT:
	f->state = PPP_FSM_ACKRCVD;
 8014a02:	68fb      	ldr	r3, [r7, #12]
 8014a04:	2207      	movs	r2, #7
 8014a06:	741a      	strb	r2, [r3, #16]
	f->retransmits = pcb->settings.fsm_max_conf_req_transmits;
 8014a08:	697b      	ldr	r3, [r7, #20]
 8014a0a:	795a      	ldrb	r2, [r3, #5]
 8014a0c:	68fb      	ldr	r3, [r7, #12]
 8014a0e:	751a      	strb	r2, [r3, #20]
	break;
 8014a10:	e040      	b.n	8014a94 <fsm_rconfack+0x12c>

    case PPP_FSM_ACKRCVD:
	/* Huh? an extra valid Ack? oh well... */
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 8014a12:	68fa      	ldr	r2, [r7, #12]
 8014a14:	4b23      	ldr	r3, [pc, #140]	; (8014aa4 <fsm_rconfack+0x13c>)
 8014a16:	0011      	movs	r1, r2
 8014a18:	0018      	movs	r0, r3
 8014a1a:	f7fd fb75 	bl	8012108 <sys_untimeout>
	fsm_sconfreq(f, 0);
 8014a1e:	68fb      	ldr	r3, [r7, #12]
 8014a20:	2100      	movs	r1, #0
 8014a22:	0018      	movs	r0, r3
 8014a24:	f000 fa30 	bl	8014e88 <fsm_sconfreq>
	f->state = PPP_FSM_REQSENT;
 8014a28:	68fb      	ldr	r3, [r7, #12]
 8014a2a:	2206      	movs	r2, #6
 8014a2c:	741a      	strb	r2, [r3, #16]
	break;
 8014a2e:	e031      	b.n	8014a94 <fsm_rconfack+0x12c>

    case PPP_FSM_ACKSENT:
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 8014a30:	68fa      	ldr	r2, [r7, #12]
 8014a32:	4b1c      	ldr	r3, [pc, #112]	; (8014aa4 <fsm_rconfack+0x13c>)
 8014a34:	0011      	movs	r1, r2
 8014a36:	0018      	movs	r0, r3
 8014a38:	f7fd fb66 	bl	8012108 <sys_untimeout>
	f->state = PPP_FSM_OPENED;
 8014a3c:	68fb      	ldr	r3, [r7, #12]
 8014a3e:	2209      	movs	r2, #9
 8014a40:	741a      	strb	r2, [r3, #16]
	f->retransmits = pcb->settings.fsm_max_conf_req_transmits;
 8014a42:	697b      	ldr	r3, [r7, #20]
 8014a44:	795a      	ldrb	r2, [r3, #5]
 8014a46:	68fb      	ldr	r3, [r7, #12]
 8014a48:	751a      	strb	r2, [r3, #20]
	if (f->callbacks->up)
 8014a4a:	68fb      	ldr	r3, [r7, #12]
 8014a4c:	685b      	ldr	r3, [r3, #4]
 8014a4e:	69db      	ldr	r3, [r3, #28]
 8014a50:	2b00      	cmp	r3, #0
 8014a52:	d01e      	beq.n	8014a92 <fsm_rconfack+0x12a>
	    (*f->callbacks->up)(f);	/* Inform upper layers */
 8014a54:	68fb      	ldr	r3, [r7, #12]
 8014a56:	685b      	ldr	r3, [r3, #4]
 8014a58:	69db      	ldr	r3, [r3, #28]
 8014a5a:	68fa      	ldr	r2, [r7, #12]
 8014a5c:	0010      	movs	r0, r2
 8014a5e:	4798      	blx	r3
	break;
 8014a60:	e017      	b.n	8014a92 <fsm_rconfack+0x12a>

    case PPP_FSM_OPENED:
	/* Go down and restart negotiation */
	if (f->callbacks->down)
 8014a62:	68fb      	ldr	r3, [r7, #12]
 8014a64:	685b      	ldr	r3, [r3, #4]
 8014a66:	6a1b      	ldr	r3, [r3, #32]
 8014a68:	2b00      	cmp	r3, #0
 8014a6a:	d005      	beq.n	8014a78 <fsm_rconfack+0x110>
	    (*f->callbacks->down)(f);	/* Inform upper layers */
 8014a6c:	68fb      	ldr	r3, [r7, #12]
 8014a6e:	685b      	ldr	r3, [r3, #4]
 8014a70:	6a1b      	ldr	r3, [r3, #32]
 8014a72:	68fa      	ldr	r2, [r7, #12]
 8014a74:	0010      	movs	r0, r2
 8014a76:	4798      	blx	r3
	fsm_sconfreq(f, 0);		/* Send initial Configure-Request */
 8014a78:	68fb      	ldr	r3, [r7, #12]
 8014a7a:	2100      	movs	r1, #0
 8014a7c:	0018      	movs	r0, r3
 8014a7e:	f000 fa03 	bl	8014e88 <fsm_sconfreq>
	f->state = PPP_FSM_REQSENT;
 8014a82:	68fb      	ldr	r3, [r7, #12]
 8014a84:	2206      	movs	r2, #6
 8014a86:	741a      	strb	r2, [r3, #16]
	break;
 8014a88:	e004      	b.n	8014a94 <fsm_rconfack+0x12c>
	return;					/* Nope, toss... */
 8014a8a:	46c0      	nop			; (mov r8, r8)
 8014a8c:	e002      	b.n	8014a94 <fsm_rconfack+0x12c>
    default:
	break;
 8014a8e:	46c0      	nop			; (mov r8, r8)
 8014a90:	e000      	b.n	8014a94 <fsm_rconfack+0x12c>
	break;
 8014a92:	46c0      	nop			; (mov r8, r8)
    }
}
 8014a94:	46bd      	mov	sp, r7
 8014a96:	b006      	add	sp, #24
 8014a98:	bd80      	pop	{r7, pc}
 8014a9a:	46c0      	nop			; (mov r8, r8)
 8014a9c:	0802164c 	.word	0x0802164c
 8014aa0:	080224f8 	.word	0x080224f8
 8014aa4:	08014565 	.word	0x08014565

08014aa8 <fsm_rconfnakrej>:


/*
 * fsm_rconfnakrej - Receive Configure-Nak or Configure-Reject.
 */
static void fsm_rconfnakrej(fsm *f, int code, int id, u_char *inp, int len) {
 8014aa8:	b590      	push	{r4, r7, lr}
 8014aaa:	b089      	sub	sp, #36	; 0x24
 8014aac:	af02      	add	r7, sp, #8
 8014aae:	60f8      	str	r0, [r7, #12]
 8014ab0:	60b9      	str	r1, [r7, #8]
 8014ab2:	607a      	str	r2, [r7, #4]
 8014ab4:	603b      	str	r3, [r7, #0]
    int ret;
    int treat_as_reject;

    if (id != f->reqid || f->seen_ack)	/* Expected id? */
 8014ab6:	68fb      	ldr	r3, [r7, #12]
 8014ab8:	7cdb      	ldrb	r3, [r3, #19]
 8014aba:	001a      	movs	r2, r3
 8014abc:	687b      	ldr	r3, [r7, #4]
 8014abe:	4293      	cmp	r3, r2
 8014ac0:	d000      	beq.n	8014ac4 <fsm_rconfnakrej+0x1c>
 8014ac2:	e096      	b.n	8014bf2 <fsm_rconfnakrej+0x14a>
 8014ac4:	68fb      	ldr	r3, [r7, #12]
 8014ac6:	7b1b      	ldrb	r3, [r3, #12]
 8014ac8:	2b00      	cmp	r3, #0
 8014aca:	d000      	beq.n	8014ace <fsm_rconfnakrej+0x26>
 8014acc:	e091      	b.n	8014bf2 <fsm_rconfnakrej+0x14a>
	return;				/* Nope, toss... */

    if (code == CONFNAK) {
 8014ace:	68bb      	ldr	r3, [r7, #8]
 8014ad0:	2b03      	cmp	r3, #3
 8014ad2:	d127      	bne.n	8014b24 <fsm_rconfnakrej+0x7c>
	++f->rnakloops;
 8014ad4:	68fb      	ldr	r3, [r7, #12]
 8014ad6:	7d9b      	ldrb	r3, [r3, #22]
 8014ad8:	3301      	adds	r3, #1
 8014ada:	b2da      	uxtb	r2, r3
 8014adc:	68fb      	ldr	r3, [r7, #12]
 8014ade:	759a      	strb	r2, [r3, #22]
	treat_as_reject = (f->rnakloops >= f->maxnakloops);
 8014ae0:	68fb      	ldr	r3, [r7, #12]
 8014ae2:	7d99      	ldrb	r1, [r3, #22]
 8014ae4:	68fb      	ldr	r3, [r7, #12]
 8014ae6:	7dda      	ldrb	r2, [r3, #23]
 8014ae8:	2300      	movs	r3, #0
 8014aea:	4291      	cmp	r1, r2
 8014aec:	415b      	adcs	r3, r3
 8014aee:	b2db      	uxtb	r3, r3
 8014af0:	613b      	str	r3, [r7, #16]
	if (f->callbacks->nakci == NULL
 8014af2:	68fb      	ldr	r3, [r7, #12]
 8014af4:	685b      	ldr	r3, [r3, #4]
 8014af6:	691b      	ldr	r3, [r3, #16]
 8014af8:	2b00      	cmp	r3, #0
 8014afa:	d00c      	beq.n	8014b16 <fsm_rconfnakrej+0x6e>
	    || !(ret = f->callbacks->nakci(f, inp, len, treat_as_reject))) {
 8014afc:	68fb      	ldr	r3, [r7, #12]
 8014afe:	685b      	ldr	r3, [r3, #4]
 8014b00:	691c      	ldr	r4, [r3, #16]
 8014b02:	693b      	ldr	r3, [r7, #16]
 8014b04:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8014b06:	6839      	ldr	r1, [r7, #0]
 8014b08:	68f8      	ldr	r0, [r7, #12]
 8014b0a:	47a0      	blx	r4
 8014b0c:	0003      	movs	r3, r0
 8014b0e:	617b      	str	r3, [r7, #20]
 8014b10:	697b      	ldr	r3, [r7, #20]
 8014b12:	2b00      	cmp	r3, #0
 8014b14:	d121      	bne.n	8014b5a <fsm_rconfnakrej+0xb2>
	    ppp_error("Received bad configure-nak: %P", inp, len);
 8014b16:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8014b18:	6839      	ldr	r1, [r7, #0]
 8014b1a:	4b39      	ldr	r3, [pc, #228]	; (8014c00 <fsm_rconfnakrej+0x158>)
 8014b1c:	0018      	movs	r0, r3
 8014b1e:	f006 fd00 	bl	801b522 <ppp_error>
	    return;
 8014b22:	e069      	b.n	8014bf8 <fsm_rconfnakrej+0x150>
	}
    } else {
	f->rnakloops = 0;
 8014b24:	68fb      	ldr	r3, [r7, #12]
 8014b26:	2200      	movs	r2, #0
 8014b28:	759a      	strb	r2, [r3, #22]
	if (f->callbacks->rejci == NULL
 8014b2a:	68fb      	ldr	r3, [r7, #12]
 8014b2c:	685b      	ldr	r3, [r3, #4]
 8014b2e:	695b      	ldr	r3, [r3, #20]
 8014b30:	2b00      	cmp	r3, #0
 8014b32:	d00b      	beq.n	8014b4c <fsm_rconfnakrej+0xa4>
	    || !(ret = f->callbacks->rejci(f, inp, len))) {
 8014b34:	68fb      	ldr	r3, [r7, #12]
 8014b36:	685b      	ldr	r3, [r3, #4]
 8014b38:	695b      	ldr	r3, [r3, #20]
 8014b3a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8014b3c:	6839      	ldr	r1, [r7, #0]
 8014b3e:	68f8      	ldr	r0, [r7, #12]
 8014b40:	4798      	blx	r3
 8014b42:	0003      	movs	r3, r0
 8014b44:	617b      	str	r3, [r7, #20]
 8014b46:	697b      	ldr	r3, [r7, #20]
 8014b48:	2b00      	cmp	r3, #0
 8014b4a:	d106      	bne.n	8014b5a <fsm_rconfnakrej+0xb2>
	    ppp_error("Received bad configure-rej: %P", inp, len);
 8014b4c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8014b4e:	6839      	ldr	r1, [r7, #0]
 8014b50:	4b2c      	ldr	r3, [pc, #176]	; (8014c04 <fsm_rconfnakrej+0x15c>)
 8014b52:	0018      	movs	r0, r3
 8014b54:	f006 fce5 	bl	801b522 <ppp_error>
	    return;
 8014b58:	e04e      	b.n	8014bf8 <fsm_rconfnakrej+0x150>
	}
    }

    f->seen_ack = 1;
 8014b5a:	68fb      	ldr	r3, [r7, #12]
 8014b5c:	2201      	movs	r2, #1
 8014b5e:	731a      	strb	r2, [r3, #12]

    switch (f->state) {
 8014b60:	68fb      	ldr	r3, [r7, #12]
 8014b62:	7c1b      	ldrb	r3, [r3, #16]
 8014b64:	2b09      	cmp	r3, #9
 8014b66:	d846      	bhi.n	8014bf6 <fsm_rconfnakrej+0x14e>
 8014b68:	009a      	lsls	r2, r3, #2
 8014b6a:	4b27      	ldr	r3, [pc, #156]	; (8014c08 <fsm_rconfnakrej+0x160>)
 8014b6c:	18d3      	adds	r3, r2, r3
 8014b6e:	681b      	ldr	r3, [r3, #0]
 8014b70:	469f      	mov	pc, r3
    case PPP_FSM_CLOSED:
    case PPP_FSM_STOPPED:
	fsm_sdata(f, TERMACK, id, NULL, 0);
 8014b72:	687b      	ldr	r3, [r7, #4]
 8014b74:	b2da      	uxtb	r2, r3
 8014b76:	68f8      	ldr	r0, [r7, #12]
 8014b78:	2300      	movs	r3, #0
 8014b7a:	9300      	str	r3, [sp, #0]
 8014b7c:	2300      	movs	r3, #0
 8014b7e:	2106      	movs	r1, #6
 8014b80:	f000 fa78 	bl	8015074 <fsm_sdata>
	break;
 8014b84:	e038      	b.n	8014bf8 <fsm_rconfnakrej+0x150>

    case PPP_FSM_REQSENT:
    case PPP_FSM_ACKSENT:
	/* They didn't agree to what we wanted - try another request */
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 8014b86:	68fa      	ldr	r2, [r7, #12]
 8014b88:	4b20      	ldr	r3, [pc, #128]	; (8014c0c <fsm_rconfnakrej+0x164>)
 8014b8a:	0011      	movs	r1, r2
 8014b8c:	0018      	movs	r0, r3
 8014b8e:	f7fd fabb 	bl	8012108 <sys_untimeout>
	if (ret < 0)
 8014b92:	697b      	ldr	r3, [r7, #20]
 8014b94:	2b00      	cmp	r3, #0
 8014b96:	da03      	bge.n	8014ba0 <fsm_rconfnakrej+0xf8>
	    f->state = PPP_FSM_STOPPED;		/* kludge for stopping CCP */
 8014b98:	68fb      	ldr	r3, [r7, #12]
 8014b9a:	2203      	movs	r2, #3
 8014b9c:	741a      	strb	r2, [r3, #16]
	else
	    fsm_sconfreq(f, 0);		/* Send Configure-Request */
	break;
 8014b9e:	e02b      	b.n	8014bf8 <fsm_rconfnakrej+0x150>
	    fsm_sconfreq(f, 0);		/* Send Configure-Request */
 8014ba0:	68fb      	ldr	r3, [r7, #12]
 8014ba2:	2100      	movs	r1, #0
 8014ba4:	0018      	movs	r0, r3
 8014ba6:	f000 f96f 	bl	8014e88 <fsm_sconfreq>
	break;
 8014baa:	e025      	b.n	8014bf8 <fsm_rconfnakrej+0x150>

    case PPP_FSM_ACKRCVD:
	/* Got a Nak/reject when we had already had an Ack?? oh well... */
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 8014bac:	68fa      	ldr	r2, [r7, #12]
 8014bae:	4b17      	ldr	r3, [pc, #92]	; (8014c0c <fsm_rconfnakrej+0x164>)
 8014bb0:	0011      	movs	r1, r2
 8014bb2:	0018      	movs	r0, r3
 8014bb4:	f7fd faa8 	bl	8012108 <sys_untimeout>
	fsm_sconfreq(f, 0);
 8014bb8:	68fb      	ldr	r3, [r7, #12]
 8014bba:	2100      	movs	r1, #0
 8014bbc:	0018      	movs	r0, r3
 8014bbe:	f000 f963 	bl	8014e88 <fsm_sconfreq>
	f->state = PPP_FSM_REQSENT;
 8014bc2:	68fb      	ldr	r3, [r7, #12]
 8014bc4:	2206      	movs	r2, #6
 8014bc6:	741a      	strb	r2, [r3, #16]
	break;
 8014bc8:	e016      	b.n	8014bf8 <fsm_rconfnakrej+0x150>

    case PPP_FSM_OPENED:
	/* Go down and restart negotiation */
	if (f->callbacks->down)
 8014bca:	68fb      	ldr	r3, [r7, #12]
 8014bcc:	685b      	ldr	r3, [r3, #4]
 8014bce:	6a1b      	ldr	r3, [r3, #32]
 8014bd0:	2b00      	cmp	r3, #0
 8014bd2:	d005      	beq.n	8014be0 <fsm_rconfnakrej+0x138>
	    (*f->callbacks->down)(f);	/* Inform upper layers */
 8014bd4:	68fb      	ldr	r3, [r7, #12]
 8014bd6:	685b      	ldr	r3, [r3, #4]
 8014bd8:	6a1b      	ldr	r3, [r3, #32]
 8014bda:	68fa      	ldr	r2, [r7, #12]
 8014bdc:	0010      	movs	r0, r2
 8014bde:	4798      	blx	r3
	fsm_sconfreq(f, 0);		/* Send initial Configure-Request */
 8014be0:	68fb      	ldr	r3, [r7, #12]
 8014be2:	2100      	movs	r1, #0
 8014be4:	0018      	movs	r0, r3
 8014be6:	f000 f94f 	bl	8014e88 <fsm_sconfreq>
	f->state = PPP_FSM_REQSENT;
 8014bea:	68fb      	ldr	r3, [r7, #12]
 8014bec:	2206      	movs	r2, #6
 8014bee:	741a      	strb	r2, [r3, #16]
	break;
 8014bf0:	e002      	b.n	8014bf8 <fsm_rconfnakrej+0x150>
	return;				/* Nope, toss... */
 8014bf2:	46c0      	nop			; (mov r8, r8)
 8014bf4:	e000      	b.n	8014bf8 <fsm_rconfnakrej+0x150>
    default:
	break;
 8014bf6:	46c0      	nop			; (mov r8, r8)
    }
}
 8014bf8:	46bd      	mov	sp, r7
 8014bfa:	b007      	add	sp, #28
 8014bfc:	bd90      	pop	{r4, r7, pc}
 8014bfe:	46c0      	nop			; (mov r8, r8)
 8014c00:	0802166c 	.word	0x0802166c
 8014c04:	0802168c 	.word	0x0802168c
 8014c08:	08022520 	.word	0x08022520
 8014c0c:	08014565 	.word	0x08014565

08014c10 <fsm_rtermreq>:


/*
 * fsm_rtermreq - Receive Terminate-Req.
 */
static void fsm_rtermreq(fsm *f, int id, u_char *p, int len) {
 8014c10:	b580      	push	{r7, lr}
 8014c12:	b088      	sub	sp, #32
 8014c14:	af02      	add	r7, sp, #8
 8014c16:	60f8      	str	r0, [r7, #12]
 8014c18:	60b9      	str	r1, [r7, #8]
 8014c1a:	607a      	str	r2, [r7, #4]
 8014c1c:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 8014c1e:	68fb      	ldr	r3, [r7, #12]
 8014c20:	681b      	ldr	r3, [r3, #0]
 8014c22:	617b      	str	r3, [r7, #20]

    switch (f->state) {
 8014c24:	68fb      	ldr	r3, [r7, #12]
 8014c26:	7c1b      	ldrb	r3, [r3, #16]
 8014c28:	2b08      	cmp	r3, #8
 8014c2a:	dc02      	bgt.n	8014c32 <fsm_rtermreq+0x22>
 8014c2c:	2b07      	cmp	r3, #7
 8014c2e:	da03      	bge.n	8014c38 <fsm_rtermreq+0x28>
	if (f->callbacks->down)
	    (*f->callbacks->down)(f);	/* Inform upper layers */
	TIMEOUT(fsm_timeout, f, pcb->settings.fsm_timeout_time);
	break;
    default:
	break;
 8014c30:	e041      	b.n	8014cb6 <fsm_rtermreq+0xa6>
    switch (f->state) {
 8014c32:	2b09      	cmp	r3, #9
 8014c34:	d004      	beq.n	8014c40 <fsm_rtermreq+0x30>
	break;
 8014c36:	e03e      	b.n	8014cb6 <fsm_rtermreq+0xa6>
	f->state = PPP_FSM_REQSENT;		/* Start over but keep trying */
 8014c38:	68fb      	ldr	r3, [r7, #12]
 8014c3a:	2206      	movs	r2, #6
 8014c3c:	741a      	strb	r2, [r3, #16]
	break;
 8014c3e:	e03a      	b.n	8014cb6 <fsm_rtermreq+0xa6>
	if (len > 0) {
 8014c40:	683b      	ldr	r3, [r7, #0]
 8014c42:	2b00      	cmp	r3, #0
 8014c44:	dd08      	ble.n	8014c58 <fsm_rtermreq+0x48>
	    ppp_info("%s terminated by peer (%0.*v)", PROTO_NAME(f), len, p);
 8014c46:	68fb      	ldr	r3, [r7, #12]
 8014c48:	685b      	ldr	r3, [r3, #4]
 8014c4a:	6b99      	ldr	r1, [r3, #56]	; 0x38
 8014c4c:	687b      	ldr	r3, [r7, #4]
 8014c4e:	683a      	ldr	r2, [r7, #0]
 8014c50:	481f      	ldr	r0, [pc, #124]	; (8014cd0 <fsm_rtermreq+0xc0>)
 8014c52:	f006 fca2 	bl	801b59a <ppp_info>
 8014c56:	e007      	b.n	8014c68 <fsm_rtermreq+0x58>
	    ppp_info("%s terminated by peer", PROTO_NAME(f));
 8014c58:	68fb      	ldr	r3, [r7, #12]
 8014c5a:	685b      	ldr	r3, [r3, #4]
 8014c5c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8014c5e:	4b1d      	ldr	r3, [pc, #116]	; (8014cd4 <fsm_rtermreq+0xc4>)
 8014c60:	0011      	movs	r1, r2
 8014c62:	0018      	movs	r0, r3
 8014c64:	f006 fc99 	bl	801b59a <ppp_info>
	f->retransmits = 0;
 8014c68:	68fb      	ldr	r3, [r7, #12]
 8014c6a:	2200      	movs	r2, #0
 8014c6c:	751a      	strb	r2, [r3, #20]
	f->state = PPP_FSM_STOPPING;
 8014c6e:	68fb      	ldr	r3, [r7, #12]
 8014c70:	2205      	movs	r2, #5
 8014c72:	741a      	strb	r2, [r3, #16]
	if (f->callbacks->down)
 8014c74:	68fb      	ldr	r3, [r7, #12]
 8014c76:	685b      	ldr	r3, [r3, #4]
 8014c78:	6a1b      	ldr	r3, [r3, #32]
 8014c7a:	2b00      	cmp	r3, #0
 8014c7c:	d005      	beq.n	8014c8a <fsm_rtermreq+0x7a>
	    (*f->callbacks->down)(f);	/* Inform upper layers */
 8014c7e:	68fb      	ldr	r3, [r7, #12]
 8014c80:	685b      	ldr	r3, [r3, #4]
 8014c82:	6a1b      	ldr	r3, [r3, #32]
 8014c84:	68fa      	ldr	r2, [r7, #12]
 8014c86:	0010      	movs	r0, r2
 8014c88:	4798      	blx	r3
	TIMEOUT(fsm_timeout, f, pcb->settings.fsm_timeout_time);
 8014c8a:	68fa      	ldr	r2, [r7, #12]
 8014c8c:	4b12      	ldr	r3, [pc, #72]	; (8014cd8 <fsm_rtermreq+0xc8>)
 8014c8e:	0011      	movs	r1, r2
 8014c90:	0018      	movs	r0, r3
 8014c92:	f7fd fa39 	bl	8012108 <sys_untimeout>
 8014c96:	697b      	ldr	r3, [r7, #20]
 8014c98:	791b      	ldrb	r3, [r3, #4]
 8014c9a:	001a      	movs	r2, r3
 8014c9c:	0013      	movs	r3, r2
 8014c9e:	015b      	lsls	r3, r3, #5
 8014ca0:	1a9b      	subs	r3, r3, r2
 8014ca2:	009b      	lsls	r3, r3, #2
 8014ca4:	189b      	adds	r3, r3, r2
 8014ca6:	00db      	lsls	r3, r3, #3
 8014ca8:	0018      	movs	r0, r3
 8014caa:	68fa      	ldr	r2, [r7, #12]
 8014cac:	4b0a      	ldr	r3, [pc, #40]	; (8014cd8 <fsm_rtermreq+0xc8>)
 8014cae:	0019      	movs	r1, r3
 8014cb0:	f7fd fa02 	bl	80120b8 <sys_timeout>
	break;
 8014cb4:	46c0      	nop			; (mov r8, r8)
    }

    fsm_sdata(f, TERMACK, id, NULL, 0);
 8014cb6:	68bb      	ldr	r3, [r7, #8]
 8014cb8:	b2da      	uxtb	r2, r3
 8014cba:	68f8      	ldr	r0, [r7, #12]
 8014cbc:	2300      	movs	r3, #0
 8014cbe:	9300      	str	r3, [sp, #0]
 8014cc0:	2300      	movs	r3, #0
 8014cc2:	2106      	movs	r1, #6
 8014cc4:	f000 f9d6 	bl	8015074 <fsm_sdata>
}
 8014cc8:	46c0      	nop			; (mov r8, r8)
 8014cca:	46bd      	mov	sp, r7
 8014ccc:	b006      	add	sp, #24
 8014cce:	bd80      	pop	{r7, pc}
 8014cd0:	080216ac 	.word	0x080216ac
 8014cd4:	080216cc 	.word	0x080216cc
 8014cd8:	08014565 	.word	0x08014565

08014cdc <fsm_rtermack>:


/*
 * fsm_rtermack - Receive Terminate-Ack.
 */
static void fsm_rtermack(fsm *f) {
 8014cdc:	b580      	push	{r7, lr}
 8014cde:	b082      	sub	sp, #8
 8014ce0:	af00      	add	r7, sp, #0
 8014ce2:	6078      	str	r0, [r7, #4]
    switch (f->state) {
 8014ce4:	687b      	ldr	r3, [r7, #4]
 8014ce6:	7c1b      	ldrb	r3, [r3, #16]
 8014ce8:	2b09      	cmp	r3, #9
 8014cea:	d036      	beq.n	8014d5a <fsm_rtermack+0x7e>
 8014cec:	dc49      	bgt.n	8014d82 <fsm_rtermack+0xa6>
 8014cee:	2b07      	cmp	r3, #7
 8014cf0:	d02f      	beq.n	8014d52 <fsm_rtermack+0x76>
 8014cf2:	dc46      	bgt.n	8014d82 <fsm_rtermack+0xa6>
 8014cf4:	2b04      	cmp	r3, #4
 8014cf6:	d002      	beq.n	8014cfe <fsm_rtermack+0x22>
 8014cf8:	2b05      	cmp	r3, #5
 8014cfa:	d015      	beq.n	8014d28 <fsm_rtermack+0x4c>
	    (*f->callbacks->down)(f);	/* Inform upper layers */
	fsm_sconfreq(f, 0);
	f->state = PPP_FSM_REQSENT;
	break;
    default:
	break;
 8014cfc:	e041      	b.n	8014d82 <fsm_rtermack+0xa6>
	UNTIMEOUT(fsm_timeout, f);
 8014cfe:	687a      	ldr	r2, [r7, #4]
 8014d00:	4b24      	ldr	r3, [pc, #144]	; (8014d94 <fsm_rtermack+0xb8>)
 8014d02:	0011      	movs	r1, r2
 8014d04:	0018      	movs	r0, r3
 8014d06:	f7fd f9ff 	bl	8012108 <sys_untimeout>
	f->state = PPP_FSM_CLOSED;
 8014d0a:	687b      	ldr	r3, [r7, #4]
 8014d0c:	2202      	movs	r2, #2
 8014d0e:	741a      	strb	r2, [r3, #16]
	if( f->callbacks->finished )
 8014d10:	687b      	ldr	r3, [r7, #4]
 8014d12:	685b      	ldr	r3, [r3, #4]
 8014d14:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014d16:	2b00      	cmp	r3, #0
 8014d18:	d035      	beq.n	8014d86 <fsm_rtermack+0xaa>
	    (*f->callbacks->finished)(f);
 8014d1a:	687b      	ldr	r3, [r7, #4]
 8014d1c:	685b      	ldr	r3, [r3, #4]
 8014d1e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014d20:	687a      	ldr	r2, [r7, #4]
 8014d22:	0010      	movs	r0, r2
 8014d24:	4798      	blx	r3
	break;
 8014d26:	e02e      	b.n	8014d86 <fsm_rtermack+0xaa>
	UNTIMEOUT(fsm_timeout, f);
 8014d28:	687a      	ldr	r2, [r7, #4]
 8014d2a:	4b1a      	ldr	r3, [pc, #104]	; (8014d94 <fsm_rtermack+0xb8>)
 8014d2c:	0011      	movs	r1, r2
 8014d2e:	0018      	movs	r0, r3
 8014d30:	f7fd f9ea 	bl	8012108 <sys_untimeout>
	f->state = PPP_FSM_STOPPED;
 8014d34:	687b      	ldr	r3, [r7, #4]
 8014d36:	2203      	movs	r2, #3
 8014d38:	741a      	strb	r2, [r3, #16]
	if( f->callbacks->finished )
 8014d3a:	687b      	ldr	r3, [r7, #4]
 8014d3c:	685b      	ldr	r3, [r3, #4]
 8014d3e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014d40:	2b00      	cmp	r3, #0
 8014d42:	d022      	beq.n	8014d8a <fsm_rtermack+0xae>
	    (*f->callbacks->finished)(f);
 8014d44:	687b      	ldr	r3, [r7, #4]
 8014d46:	685b      	ldr	r3, [r3, #4]
 8014d48:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014d4a:	687a      	ldr	r2, [r7, #4]
 8014d4c:	0010      	movs	r0, r2
 8014d4e:	4798      	blx	r3
	break;
 8014d50:	e01b      	b.n	8014d8a <fsm_rtermack+0xae>
	f->state = PPP_FSM_REQSENT;
 8014d52:	687b      	ldr	r3, [r7, #4]
 8014d54:	2206      	movs	r2, #6
 8014d56:	741a      	strb	r2, [r3, #16]
	break;
 8014d58:	e018      	b.n	8014d8c <fsm_rtermack+0xb0>
	if (f->callbacks->down)
 8014d5a:	687b      	ldr	r3, [r7, #4]
 8014d5c:	685b      	ldr	r3, [r3, #4]
 8014d5e:	6a1b      	ldr	r3, [r3, #32]
 8014d60:	2b00      	cmp	r3, #0
 8014d62:	d005      	beq.n	8014d70 <fsm_rtermack+0x94>
	    (*f->callbacks->down)(f);	/* Inform upper layers */
 8014d64:	687b      	ldr	r3, [r7, #4]
 8014d66:	685b      	ldr	r3, [r3, #4]
 8014d68:	6a1b      	ldr	r3, [r3, #32]
 8014d6a:	687a      	ldr	r2, [r7, #4]
 8014d6c:	0010      	movs	r0, r2
 8014d6e:	4798      	blx	r3
	fsm_sconfreq(f, 0);
 8014d70:	687b      	ldr	r3, [r7, #4]
 8014d72:	2100      	movs	r1, #0
 8014d74:	0018      	movs	r0, r3
 8014d76:	f000 f887 	bl	8014e88 <fsm_sconfreq>
	f->state = PPP_FSM_REQSENT;
 8014d7a:	687b      	ldr	r3, [r7, #4]
 8014d7c:	2206      	movs	r2, #6
 8014d7e:	741a      	strb	r2, [r3, #16]
	break;
 8014d80:	e004      	b.n	8014d8c <fsm_rtermack+0xb0>
	break;
 8014d82:	46c0      	nop			; (mov r8, r8)
 8014d84:	e002      	b.n	8014d8c <fsm_rtermack+0xb0>
	break;
 8014d86:	46c0      	nop			; (mov r8, r8)
 8014d88:	e000      	b.n	8014d8c <fsm_rtermack+0xb0>
	break;
 8014d8a:	46c0      	nop			; (mov r8, r8)
    }
}
 8014d8c:	46c0      	nop			; (mov r8, r8)
 8014d8e:	46bd      	mov	sp, r7
 8014d90:	b002      	add	sp, #8
 8014d92:	bd80      	pop	{r7, pc}
 8014d94:	08014565 	.word	0x08014565

08014d98 <fsm_rcoderej>:


/*
 * fsm_rcoderej - Receive an Code-Reject.
 */
static void fsm_rcoderej(fsm *f, u_char *inp, int len) {
 8014d98:	b590      	push	{r4, r7, lr}
 8014d9a:	b087      	sub	sp, #28
 8014d9c:	af00      	add	r7, sp, #0
 8014d9e:	60f8      	str	r0, [r7, #12]
 8014da0:	60b9      	str	r1, [r7, #8]
 8014da2:	607a      	str	r2, [r7, #4]
    u_char code, id;

    if (len < HEADERLEN) {
 8014da4:	687b      	ldr	r3, [r7, #4]
 8014da6:	2b03      	cmp	r3, #3
 8014da8:	dd1f      	ble.n	8014dea <fsm_rcoderej+0x52>
	FSMDEBUG(("fsm_rcoderej: Rcvd short Code-Reject packet!"));
	return;
    }
    GETCHAR(code, inp);
 8014daa:	68bb      	ldr	r3, [r7, #8]
 8014dac:	1c5a      	adds	r2, r3, #1
 8014dae:	60ba      	str	r2, [r7, #8]
 8014db0:	2017      	movs	r0, #23
 8014db2:	183a      	adds	r2, r7, r0
 8014db4:	781b      	ldrb	r3, [r3, #0]
 8014db6:	7013      	strb	r3, [r2, #0]
    GETCHAR(id, inp);
 8014db8:	68bb      	ldr	r3, [r7, #8]
 8014dba:	1c5a      	adds	r2, r3, #1
 8014dbc:	60ba      	str	r2, [r7, #8]
 8014dbe:	2416      	movs	r4, #22
 8014dc0:	193a      	adds	r2, r7, r4
 8014dc2:	781b      	ldrb	r3, [r3, #0]
 8014dc4:	7013      	strb	r3, [r2, #0]
    ppp_warn("%s: Rcvd Code-Reject for code %d, id %d", PROTO_NAME(f), code, id);
 8014dc6:	68fb      	ldr	r3, [r7, #12]
 8014dc8:	685b      	ldr	r3, [r3, #4]
 8014dca:	6b99      	ldr	r1, [r3, #56]	; 0x38
 8014dcc:	183b      	adds	r3, r7, r0
 8014dce:	781a      	ldrb	r2, [r3, #0]
 8014dd0:	193b      	adds	r3, r7, r4
 8014dd2:	781b      	ldrb	r3, [r3, #0]
 8014dd4:	4807      	ldr	r0, [pc, #28]	; (8014df4 <fsm_rcoderej+0x5c>)
 8014dd6:	f006 fbb8 	bl	801b54a <ppp_warn>

    if( f->state == PPP_FSM_ACKRCVD )
 8014dda:	68fb      	ldr	r3, [r7, #12]
 8014ddc:	7c1b      	ldrb	r3, [r3, #16]
 8014dde:	2b07      	cmp	r3, #7
 8014de0:	d104      	bne.n	8014dec <fsm_rcoderej+0x54>
	f->state = PPP_FSM_REQSENT;
 8014de2:	68fb      	ldr	r3, [r7, #12]
 8014de4:	2206      	movs	r2, #6
 8014de6:	741a      	strb	r2, [r3, #16]
 8014de8:	e000      	b.n	8014dec <fsm_rcoderej+0x54>
	return;
 8014dea:	46c0      	nop			; (mov r8, r8)
}
 8014dec:	46bd      	mov	sp, r7
 8014dee:	b007      	add	sp, #28
 8014df0:	bd90      	pop	{r4, r7, pc}
 8014df2:	46c0      	nop			; (mov r8, r8)
 8014df4:	080216e4 	.word	0x080216e4

08014df8 <fsm_protreject>:
/*
 * fsm_protreject - Peer doesn't speak this protocol.
 *
 * Treat this as a catastrophic error (RXJ-).
 */
void fsm_protreject(fsm *f) {
 8014df8:	b580      	push	{r7, lr}
 8014dfa:	b082      	sub	sp, #8
 8014dfc:	af00      	add	r7, sp, #0
 8014dfe:	6078      	str	r0, [r7, #4]
    switch( f->state ){
 8014e00:	687b      	ldr	r3, [r7, #4]
 8014e02:	7c1b      	ldrb	r3, [r3, #16]
 8014e04:	2b09      	cmp	r3, #9
 8014e06:	d837      	bhi.n	8014e78 <fsm_protreject+0x80>
 8014e08:	009a      	lsls	r2, r3, #2
 8014e0a:	4b1d      	ldr	r3, [pc, #116]	; (8014e80 <fsm_protreject+0x88>)
 8014e0c:	18d3      	adds	r3, r2, r3
 8014e0e:	681b      	ldr	r3, [r3, #0]
 8014e10:	469f      	mov	pc, r3
    case PPP_FSM_CLOSING:
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 8014e12:	687a      	ldr	r2, [r7, #4]
 8014e14:	4b1b      	ldr	r3, [pc, #108]	; (8014e84 <fsm_protreject+0x8c>)
 8014e16:	0011      	movs	r1, r2
 8014e18:	0018      	movs	r0, r3
 8014e1a:	f7fd f975 	bl	8012108 <sys_untimeout>
	/* fall through */
	/* no break */
    case PPP_FSM_CLOSED:
	f->state = PPP_FSM_CLOSED;
 8014e1e:	687b      	ldr	r3, [r7, #4]
 8014e20:	2202      	movs	r2, #2
 8014e22:	741a      	strb	r2, [r3, #16]
	if( f->callbacks->finished )
 8014e24:	687b      	ldr	r3, [r7, #4]
 8014e26:	685b      	ldr	r3, [r3, #4]
 8014e28:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014e2a:	2b00      	cmp	r3, #0
 8014e2c:	d021      	beq.n	8014e72 <fsm_protreject+0x7a>
	    (*f->callbacks->finished)(f);
 8014e2e:	687b      	ldr	r3, [r7, #4]
 8014e30:	685b      	ldr	r3, [r3, #4]
 8014e32:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014e34:	687a      	ldr	r2, [r7, #4]
 8014e36:	0010      	movs	r0, r2
 8014e38:	4798      	blx	r3
	break;
 8014e3a:	e01a      	b.n	8014e72 <fsm_protreject+0x7a>

    case PPP_FSM_STOPPING:
    case PPP_FSM_REQSENT:
    case PPP_FSM_ACKRCVD:
    case PPP_FSM_ACKSENT:
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 8014e3c:	687a      	ldr	r2, [r7, #4]
 8014e3e:	4b11      	ldr	r3, [pc, #68]	; (8014e84 <fsm_protreject+0x8c>)
 8014e40:	0011      	movs	r1, r2
 8014e42:	0018      	movs	r0, r3
 8014e44:	f7fd f960 	bl	8012108 <sys_untimeout>
	/* fall through */
	/* no break */
    case PPP_FSM_STOPPED:
	f->state = PPP_FSM_STOPPED;
 8014e48:	687b      	ldr	r3, [r7, #4]
 8014e4a:	2203      	movs	r2, #3
 8014e4c:	741a      	strb	r2, [r3, #16]
	if( f->callbacks->finished )
 8014e4e:	687b      	ldr	r3, [r7, #4]
 8014e50:	685b      	ldr	r3, [r3, #4]
 8014e52:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014e54:	2b00      	cmp	r3, #0
 8014e56:	d00e      	beq.n	8014e76 <fsm_protreject+0x7e>
	    (*f->callbacks->finished)(f);
 8014e58:	687b      	ldr	r3, [r7, #4]
 8014e5a:	685b      	ldr	r3, [r3, #4]
 8014e5c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014e5e:	687a      	ldr	r2, [r7, #4]
 8014e60:	0010      	movs	r0, r2
 8014e62:	4798      	blx	r3
	break;
 8014e64:	e007      	b.n	8014e76 <fsm_protreject+0x7e>

    case PPP_FSM_OPENED:
	terminate_layer(f, PPP_FSM_STOPPING);
 8014e66:	687b      	ldr	r3, [r7, #4]
 8014e68:	2105      	movs	r1, #5
 8014e6a:	0018      	movs	r0, r3
 8014e6c:	f7ff fac0 	bl	80143f0 <terminate_layer>
	break;
 8014e70:	e002      	b.n	8014e78 <fsm_protreject+0x80>
	break;
 8014e72:	46c0      	nop			; (mov r8, r8)
 8014e74:	e000      	b.n	8014e78 <fsm_protreject+0x80>
	break;
 8014e76:	46c0      	nop			; (mov r8, r8)
    default:
	FSMDEBUG(("%s: Protocol-reject event in state %d!",
		  PROTO_NAME(f), f->state));
	/* no break */
    }
}
 8014e78:	46c0      	nop			; (mov r8, r8)
 8014e7a:	46bd      	mov	sp, r7
 8014e7c:	b002      	add	sp, #8
 8014e7e:	bd80      	pop	{r7, pc}
 8014e80:	08022548 	.word	0x08022548
 8014e84:	08014565 	.word	0x08014565

08014e88 <fsm_sconfreq>:


/*
 * fsm_sconfreq - Send a Configure-Request.
 */
static void fsm_sconfreq(fsm *f, int retransmit) {
 8014e88:	b580      	push	{r7, lr}
 8014e8a:	b086      	sub	sp, #24
 8014e8c:	af00      	add	r7, sp, #0
 8014e8e:	6078      	str	r0, [r7, #4]
 8014e90:	6039      	str	r1, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 8014e92:	687b      	ldr	r3, [r7, #4]
 8014e94:	681b      	ldr	r3, [r3, #0]
 8014e96:	617b      	str	r3, [r7, #20]
    struct pbuf *p;
    u_char *outp;
    int cilen;

    if( f->state != PPP_FSM_REQSENT && f->state != PPP_FSM_ACKRCVD && f->state != PPP_FSM_ACKSENT ){
 8014e98:	687b      	ldr	r3, [r7, #4]
 8014e9a:	7c1b      	ldrb	r3, [r3, #16]
 8014e9c:	2b06      	cmp	r3, #6
 8014e9e:	d018      	beq.n	8014ed2 <fsm_sconfreq+0x4a>
 8014ea0:	687b      	ldr	r3, [r7, #4]
 8014ea2:	7c1b      	ldrb	r3, [r3, #16]
 8014ea4:	2b07      	cmp	r3, #7
 8014ea6:	d014      	beq.n	8014ed2 <fsm_sconfreq+0x4a>
 8014ea8:	687b      	ldr	r3, [r7, #4]
 8014eaa:	7c1b      	ldrb	r3, [r3, #16]
 8014eac:	2b08      	cmp	r3, #8
 8014eae:	d010      	beq.n	8014ed2 <fsm_sconfreq+0x4a>
	/* Not currently negotiating - reset options */
	if( f->callbacks->resetci )
 8014eb0:	687b      	ldr	r3, [r7, #4]
 8014eb2:	685b      	ldr	r3, [r3, #4]
 8014eb4:	681b      	ldr	r3, [r3, #0]
 8014eb6:	2b00      	cmp	r3, #0
 8014eb8:	d005      	beq.n	8014ec6 <fsm_sconfreq+0x3e>
	    (*f->callbacks->resetci)(f);
 8014eba:	687b      	ldr	r3, [r7, #4]
 8014ebc:	685b      	ldr	r3, [r3, #4]
 8014ebe:	681b      	ldr	r3, [r3, #0]
 8014ec0:	687a      	ldr	r2, [r7, #4]
 8014ec2:	0010      	movs	r0, r2
 8014ec4:	4798      	blx	r3
	f->nakloops = 0;
 8014ec6:	687b      	ldr	r3, [r7, #4]
 8014ec8:	2200      	movs	r2, #0
 8014eca:	755a      	strb	r2, [r3, #21]
	f->rnakloops = 0;
 8014ecc:	687b      	ldr	r3, [r7, #4]
 8014ece:	2200      	movs	r2, #0
 8014ed0:	759a      	strb	r2, [r3, #22]
    }

    if( !retransmit ){
 8014ed2:	683b      	ldr	r3, [r7, #0]
 8014ed4:	2b00      	cmp	r3, #0
 8014ed6:	d10d      	bne.n	8014ef4 <fsm_sconfreq+0x6c>
	/* New request - reset retransmission counter, use new ID */
	f->retransmits = pcb->settings.fsm_max_conf_req_transmits;
 8014ed8:	697b      	ldr	r3, [r7, #20]
 8014eda:	795a      	ldrb	r2, [r3, #5]
 8014edc:	687b      	ldr	r3, [r7, #4]
 8014ede:	751a      	strb	r2, [r3, #20]
	f->reqid = ++f->id;
 8014ee0:	687b      	ldr	r3, [r7, #4]
 8014ee2:	7c9b      	ldrb	r3, [r3, #18]
 8014ee4:	3301      	adds	r3, #1
 8014ee6:	b2da      	uxtb	r2, r3
 8014ee8:	687b      	ldr	r3, [r7, #4]
 8014eea:	749a      	strb	r2, [r3, #18]
 8014eec:	687b      	ldr	r3, [r7, #4]
 8014eee:	7c9a      	ldrb	r2, [r3, #18]
 8014ef0:	687b      	ldr	r3, [r7, #4]
 8014ef2:	74da      	strb	r2, [r3, #19]
    }

    f->seen_ack = 0;
 8014ef4:	687b      	ldr	r3, [r7, #4]
 8014ef6:	2200      	movs	r2, #0
 8014ef8:	731a      	strb	r2, [r3, #12]

    /*
     * Make up the request packet
     */
    if( f->callbacks->cilen && f->callbacks->addci ){
 8014efa:	687b      	ldr	r3, [r7, #4]
 8014efc:	685b      	ldr	r3, [r3, #4]
 8014efe:	685b      	ldr	r3, [r3, #4]
 8014f00:	2b00      	cmp	r3, #0
 8014f02:	d019      	beq.n	8014f38 <fsm_sconfreq+0xb0>
 8014f04:	687b      	ldr	r3, [r7, #4]
 8014f06:	685b      	ldr	r3, [r3, #4]
 8014f08:	689b      	ldr	r3, [r3, #8]
 8014f0a:	2b00      	cmp	r3, #0
 8014f0c:	d014      	beq.n	8014f38 <fsm_sconfreq+0xb0>
	cilen = (*f->callbacks->cilen)(f);
 8014f0e:	687b      	ldr	r3, [r7, #4]
 8014f10:	685b      	ldr	r3, [r3, #4]
 8014f12:	685b      	ldr	r3, [r3, #4]
 8014f14:	687a      	ldr	r2, [r7, #4]
 8014f16:	0010      	movs	r0, r2
 8014f18:	4798      	blx	r3
 8014f1a:	0003      	movs	r3, r0
 8014f1c:	60bb      	str	r3, [r7, #8]
	if( cilen > pcb->peer_mru - HEADERLEN )
 8014f1e:	697b      	ldr	r3, [r7, #20]
 8014f20:	22d4      	movs	r2, #212	; 0xd4
 8014f22:	5a9b      	ldrh	r3, [r3, r2]
 8014f24:	1eda      	subs	r2, r3, #3
 8014f26:	68bb      	ldr	r3, [r7, #8]
 8014f28:	429a      	cmp	r2, r3
 8014f2a:	dc07      	bgt.n	8014f3c <fsm_sconfreq+0xb4>
	    cilen = pcb->peer_mru - HEADERLEN;
 8014f2c:	697b      	ldr	r3, [r7, #20]
 8014f2e:	22d4      	movs	r2, #212	; 0xd4
 8014f30:	5a9b      	ldrh	r3, [r3, r2]
 8014f32:	3b04      	subs	r3, #4
 8014f34:	60bb      	str	r3, [r7, #8]
	if( cilen > pcb->peer_mru - HEADERLEN )
 8014f36:	e001      	b.n	8014f3c <fsm_sconfreq+0xb4>
    } else
	cilen = 0;
 8014f38:	2300      	movs	r3, #0
 8014f3a:	60bb      	str	r3, [r7, #8]

    p = pbuf_alloc(PBUF_RAW, (u16_t)(cilen + HEADERLEN + PPP_HDRLEN), PPP_CTRL_PBUF_TYPE);
 8014f3c:	68bb      	ldr	r3, [r7, #8]
 8014f3e:	b29b      	uxth	r3, r3
 8014f40:	3308      	adds	r3, #8
 8014f42:	b29b      	uxth	r3, r3
 8014f44:	22c1      	movs	r2, #193	; 0xc1
 8014f46:	0052      	lsls	r2, r2, #1
 8014f48:	0019      	movs	r1, r3
 8014f4a:	2000      	movs	r0, #0
 8014f4c:	f7f4 fac8 	bl	80094e0 <pbuf_alloc>
 8014f50:	0003      	movs	r3, r0
 8014f52:	613b      	str	r3, [r7, #16]
    if(NULL == p)
 8014f54:	693b      	ldr	r3, [r7, #16]
 8014f56:	2b00      	cmp	r3, #0
 8014f58:	d100      	bne.n	8014f5c <fsm_sconfreq+0xd4>
 8014f5a:	e07c      	b.n	8015056 <fsm_sconfreq+0x1ce>
        return;
    if(p->tot_len != p->len) {
 8014f5c:	693b      	ldr	r3, [r7, #16]
 8014f5e:	891a      	ldrh	r2, [r3, #8]
 8014f60:	693b      	ldr	r3, [r7, #16]
 8014f62:	895b      	ldrh	r3, [r3, #10]
 8014f64:	429a      	cmp	r2, r3
 8014f66:	d004      	beq.n	8014f72 <fsm_sconfreq+0xea>
        pbuf_free(p);
 8014f68:	693b      	ldr	r3, [r7, #16]
 8014f6a:	0018      	movs	r0, r3
 8014f6c:	f7f4 fe30 	bl	8009bd0 <pbuf_free>
        return;
 8014f70:	e072      	b.n	8015058 <fsm_sconfreq+0x1d0>
    }

    /* send the request to our peer */
    outp = (u_char*)p->payload;
 8014f72:	693b      	ldr	r3, [r7, #16]
 8014f74:	685b      	ldr	r3, [r3, #4]
 8014f76:	60fb      	str	r3, [r7, #12]
    MAKEHEADER(outp, f->protocol);
 8014f78:	68fb      	ldr	r3, [r7, #12]
 8014f7a:	1c5a      	adds	r2, r3, #1
 8014f7c:	60fa      	str	r2, [r7, #12]
 8014f7e:	22ff      	movs	r2, #255	; 0xff
 8014f80:	701a      	strb	r2, [r3, #0]
 8014f82:	68fb      	ldr	r3, [r7, #12]
 8014f84:	1c5a      	adds	r2, r3, #1
 8014f86:	60fa      	str	r2, [r7, #12]
 8014f88:	2203      	movs	r2, #3
 8014f8a:	701a      	strb	r2, [r3, #0]
 8014f8c:	687b      	ldr	r3, [r7, #4]
 8014f8e:	89db      	ldrh	r3, [r3, #14]
 8014f90:	0a1b      	lsrs	r3, r3, #8
 8014f92:	b299      	uxth	r1, r3
 8014f94:	68fb      	ldr	r3, [r7, #12]
 8014f96:	1c5a      	adds	r2, r3, #1
 8014f98:	60fa      	str	r2, [r7, #12]
 8014f9a:	b2ca      	uxtb	r2, r1
 8014f9c:	701a      	strb	r2, [r3, #0]
 8014f9e:	687b      	ldr	r3, [r7, #4]
 8014fa0:	89d9      	ldrh	r1, [r3, #14]
 8014fa2:	68fb      	ldr	r3, [r7, #12]
 8014fa4:	1c5a      	adds	r2, r3, #1
 8014fa6:	60fa      	str	r2, [r7, #12]
 8014fa8:	b2ca      	uxtb	r2, r1
 8014faa:	701a      	strb	r2, [r3, #0]
    PUTCHAR(CONFREQ, outp);
 8014fac:	68fb      	ldr	r3, [r7, #12]
 8014fae:	1c5a      	adds	r2, r3, #1
 8014fb0:	60fa      	str	r2, [r7, #12]
 8014fb2:	2201      	movs	r2, #1
 8014fb4:	701a      	strb	r2, [r3, #0]
    PUTCHAR(f->reqid, outp);
 8014fb6:	68fb      	ldr	r3, [r7, #12]
 8014fb8:	1c5a      	adds	r2, r3, #1
 8014fba:	60fa      	str	r2, [r7, #12]
 8014fbc:	687a      	ldr	r2, [r7, #4]
 8014fbe:	7cd2      	ldrb	r2, [r2, #19]
 8014fc0:	701a      	strb	r2, [r3, #0]
    PUTSHORT(cilen + HEADERLEN, outp);
 8014fc2:	68bb      	ldr	r3, [r7, #8]
 8014fc4:	3304      	adds	r3, #4
 8014fc6:	1219      	asrs	r1, r3, #8
 8014fc8:	68fb      	ldr	r3, [r7, #12]
 8014fca:	1c5a      	adds	r2, r3, #1
 8014fcc:	60fa      	str	r2, [r7, #12]
 8014fce:	b2ca      	uxtb	r2, r1
 8014fd0:	701a      	strb	r2, [r3, #0]
 8014fd2:	68bb      	ldr	r3, [r7, #8]
 8014fd4:	b2da      	uxtb	r2, r3
 8014fd6:	68fb      	ldr	r3, [r7, #12]
 8014fd8:	1c59      	adds	r1, r3, #1
 8014fda:	60f9      	str	r1, [r7, #12]
 8014fdc:	3204      	adds	r2, #4
 8014fde:	b2d2      	uxtb	r2, r2
 8014fe0:	701a      	strb	r2, [r3, #0]
    if (cilen != 0) {
 8014fe2:	68bb      	ldr	r3, [r7, #8]
 8014fe4:	2b00      	cmp	r3, #0
 8014fe6:	d014      	beq.n	8015012 <fsm_sconfreq+0x18a>
	(*f->callbacks->addci)(f, outp, &cilen);
 8014fe8:	687b      	ldr	r3, [r7, #4]
 8014fea:	685b      	ldr	r3, [r3, #4]
 8014fec:	689b      	ldr	r3, [r3, #8]
 8014fee:	2208      	movs	r2, #8
 8014ff0:	18ba      	adds	r2, r7, r2
 8014ff2:	68f9      	ldr	r1, [r7, #12]
 8014ff4:	6878      	ldr	r0, [r7, #4]
 8014ff6:	4798      	blx	r3
	LWIP_ASSERT("cilen == p->len - HEADERLEN - PPP_HDRLEN", cilen == p->len - HEADERLEN - PPP_HDRLEN);
 8014ff8:	693b      	ldr	r3, [r7, #16]
 8014ffa:	895b      	ldrh	r3, [r3, #10]
 8014ffc:	3b08      	subs	r3, #8
 8014ffe:	001a      	movs	r2, r3
 8015000:	68bb      	ldr	r3, [r7, #8]
 8015002:	429a      	cmp	r2, r3
 8015004:	d005      	beq.n	8015012 <fsm_sconfreq+0x18a>
 8015006:	4b16      	ldr	r3, [pc, #88]	; (8015060 <fsm_sconfreq+0x1d8>)
 8015008:	4a16      	ldr	r2, [pc, #88]	; (8015064 <fsm_sconfreq+0x1dc>)
 801500a:	4917      	ldr	r1, [pc, #92]	; (8015068 <fsm_sconfreq+0x1e0>)
 801500c:	4817      	ldr	r0, [pc, #92]	; (801506c <fsm_sconfreq+0x1e4>)
 801500e:	f7ed fc65 	bl	80028dc <app_debug_rtt_raw>
    }

    ppp_write(pcb, p);
 8015012:	693a      	ldr	r2, [r7, #16]
 8015014:	697b      	ldr	r3, [r7, #20]
 8015016:	0011      	movs	r1, r2
 8015018:	0018      	movs	r0, r3
 801501a:	f004 ffb5 	bl	8019f88 <ppp_write>

    /* start the retransmit timer */
    --f->retransmits;
 801501e:	687b      	ldr	r3, [r7, #4]
 8015020:	7d1b      	ldrb	r3, [r3, #20]
 8015022:	3b01      	subs	r3, #1
 8015024:	b2da      	uxtb	r2, r3
 8015026:	687b      	ldr	r3, [r7, #4]
 8015028:	751a      	strb	r2, [r3, #20]
    TIMEOUT(fsm_timeout, f, pcb->settings.fsm_timeout_time);
 801502a:	687a      	ldr	r2, [r7, #4]
 801502c:	4b10      	ldr	r3, [pc, #64]	; (8015070 <fsm_sconfreq+0x1e8>)
 801502e:	0011      	movs	r1, r2
 8015030:	0018      	movs	r0, r3
 8015032:	f7fd f869 	bl	8012108 <sys_untimeout>
 8015036:	697b      	ldr	r3, [r7, #20]
 8015038:	791b      	ldrb	r3, [r3, #4]
 801503a:	001a      	movs	r2, r3
 801503c:	0013      	movs	r3, r2
 801503e:	015b      	lsls	r3, r3, #5
 8015040:	1a9b      	subs	r3, r3, r2
 8015042:	009b      	lsls	r3, r3, #2
 8015044:	189b      	adds	r3, r3, r2
 8015046:	00db      	lsls	r3, r3, #3
 8015048:	0018      	movs	r0, r3
 801504a:	687a      	ldr	r2, [r7, #4]
 801504c:	4b08      	ldr	r3, [pc, #32]	; (8015070 <fsm_sconfreq+0x1e8>)
 801504e:	0019      	movs	r1, r3
 8015050:	f7fd f832 	bl	80120b8 <sys_timeout>
 8015054:	e000      	b.n	8015058 <fsm_sconfreq+0x1d0>
        return;
 8015056:	46c0      	nop			; (mov r8, r8)
}
 8015058:	46bd      	mov	sp, r7
 801505a:	b006      	add	sp, #24
 801505c:	bd80      	pop	{r7, pc}
 801505e:	46c0      	nop			; (mov r8, r8)
 8015060:	0802170c 	.word	0x0802170c
 8015064:	000002f2 	.word	0x000002f2
 8015068:	08021738 	.word	0x08021738
 801506c:	08021764 	.word	0x08021764
 8015070:	08014565 	.word	0x08014565

08015074 <fsm_sdata>:
/*
 * fsm_sdata - Send some data.
 *
 * Used for all packets sent to our peer by this module.
 */
void fsm_sdata(fsm *f, u_char code, u_char id, const u_char *data, int datalen) {
 8015074:	b580      	push	{r7, lr}
 8015076:	b088      	sub	sp, #32
 8015078:	af00      	add	r7, sp, #0
 801507a:	60f8      	str	r0, [r7, #12]
 801507c:	0008      	movs	r0, r1
 801507e:	0011      	movs	r1, r2
 8015080:	607b      	str	r3, [r7, #4]
 8015082:	230b      	movs	r3, #11
 8015084:	18fb      	adds	r3, r7, r3
 8015086:	1c02      	adds	r2, r0, #0
 8015088:	701a      	strb	r2, [r3, #0]
 801508a:	230a      	movs	r3, #10
 801508c:	18fb      	adds	r3, r7, r3
 801508e:	1c0a      	adds	r2, r1, #0
 8015090:	701a      	strb	r2, [r3, #0]
    ppp_pcb *pcb = f->pcb;
 8015092:	68fb      	ldr	r3, [r7, #12]
 8015094:	681b      	ldr	r3, [r3, #0]
 8015096:	61fb      	str	r3, [r7, #28]
    struct pbuf *p;
    u_char *outp;
    int outlen;

    /* Adjust length to be smaller than MTU */
    if (datalen > pcb->peer_mru - HEADERLEN)
 8015098:	69fb      	ldr	r3, [r7, #28]
 801509a:	22d4      	movs	r2, #212	; 0xd4
 801509c:	5a9b      	ldrh	r3, [r3, r2]
 801509e:	3b03      	subs	r3, #3
 80150a0:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80150a2:	429a      	cmp	r2, r3
 80150a4:	db04      	blt.n	80150b0 <fsm_sdata+0x3c>
	datalen = pcb->peer_mru - HEADERLEN;
 80150a6:	69fb      	ldr	r3, [r7, #28]
 80150a8:	22d4      	movs	r2, #212	; 0xd4
 80150aa:	5a9b      	ldrh	r3, [r3, r2]
 80150ac:	3b04      	subs	r3, #4
 80150ae:	62bb      	str	r3, [r7, #40]	; 0x28
    outlen = datalen + HEADERLEN;
 80150b0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80150b2:	3304      	adds	r3, #4
 80150b4:	61bb      	str	r3, [r7, #24]

    p = pbuf_alloc(PBUF_RAW, (u16_t)(outlen + PPP_HDRLEN), PPP_CTRL_PBUF_TYPE);
 80150b6:	69bb      	ldr	r3, [r7, #24]
 80150b8:	b29b      	uxth	r3, r3
 80150ba:	3304      	adds	r3, #4
 80150bc:	b29b      	uxth	r3, r3
 80150be:	22c1      	movs	r2, #193	; 0xc1
 80150c0:	0052      	lsls	r2, r2, #1
 80150c2:	0019      	movs	r1, r3
 80150c4:	2000      	movs	r0, #0
 80150c6:	f7f4 fa0b 	bl	80094e0 <pbuf_alloc>
 80150ca:	0003      	movs	r3, r0
 80150cc:	617b      	str	r3, [r7, #20]
    if(NULL == p)
 80150ce:	697b      	ldr	r3, [r7, #20]
 80150d0:	2b00      	cmp	r3, #0
 80150d2:	d053      	beq.n	801517c <fsm_sdata+0x108>
        return;
    if(p->tot_len != p->len) {
 80150d4:	697b      	ldr	r3, [r7, #20]
 80150d6:	891a      	ldrh	r2, [r3, #8]
 80150d8:	697b      	ldr	r3, [r7, #20]
 80150da:	895b      	ldrh	r3, [r3, #10]
 80150dc:	429a      	cmp	r2, r3
 80150de:	d004      	beq.n	80150ea <fsm_sdata+0x76>
        pbuf_free(p);
 80150e0:	697b      	ldr	r3, [r7, #20]
 80150e2:	0018      	movs	r0, r3
 80150e4:	f7f4 fd74 	bl	8009bd0 <pbuf_free>
        return;
 80150e8:	e049      	b.n	801517e <fsm_sdata+0x10a>
    }

    outp = (u_char*)p->payload;
 80150ea:	697b      	ldr	r3, [r7, #20]
 80150ec:	685b      	ldr	r3, [r3, #4]
 80150ee:	613b      	str	r3, [r7, #16]
    if (datalen) /* && data != outp + PPP_HDRLEN + HEADERLEN)  -- was only for fsm_sconfreq() */
 80150f0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80150f2:	2b00      	cmp	r3, #0
 80150f4:	d006      	beq.n	8015104 <fsm_sdata+0x90>
	MEMCPY(outp + PPP_HDRLEN + HEADERLEN, data, datalen);
 80150f6:	693b      	ldr	r3, [r7, #16]
 80150f8:	3308      	adds	r3, #8
 80150fa:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80150fc:	6879      	ldr	r1, [r7, #4]
 80150fe:	0018      	movs	r0, r3
 8015100:	f007 fd6e 	bl	801cbe0 <memcpy>
    MAKEHEADER(outp, f->protocol);
 8015104:	693b      	ldr	r3, [r7, #16]
 8015106:	1c5a      	adds	r2, r3, #1
 8015108:	613a      	str	r2, [r7, #16]
 801510a:	22ff      	movs	r2, #255	; 0xff
 801510c:	701a      	strb	r2, [r3, #0]
 801510e:	693b      	ldr	r3, [r7, #16]
 8015110:	1c5a      	adds	r2, r3, #1
 8015112:	613a      	str	r2, [r7, #16]
 8015114:	2203      	movs	r2, #3
 8015116:	701a      	strb	r2, [r3, #0]
 8015118:	68fb      	ldr	r3, [r7, #12]
 801511a:	89db      	ldrh	r3, [r3, #14]
 801511c:	0a1b      	lsrs	r3, r3, #8
 801511e:	b299      	uxth	r1, r3
 8015120:	693b      	ldr	r3, [r7, #16]
 8015122:	1c5a      	adds	r2, r3, #1
 8015124:	613a      	str	r2, [r7, #16]
 8015126:	b2ca      	uxtb	r2, r1
 8015128:	701a      	strb	r2, [r3, #0]
 801512a:	68fb      	ldr	r3, [r7, #12]
 801512c:	89d9      	ldrh	r1, [r3, #14]
 801512e:	693b      	ldr	r3, [r7, #16]
 8015130:	1c5a      	adds	r2, r3, #1
 8015132:	613a      	str	r2, [r7, #16]
 8015134:	b2ca      	uxtb	r2, r1
 8015136:	701a      	strb	r2, [r3, #0]
    PUTCHAR(code, outp);
 8015138:	693b      	ldr	r3, [r7, #16]
 801513a:	1c5a      	adds	r2, r3, #1
 801513c:	613a      	str	r2, [r7, #16]
 801513e:	220b      	movs	r2, #11
 8015140:	18ba      	adds	r2, r7, r2
 8015142:	7812      	ldrb	r2, [r2, #0]
 8015144:	701a      	strb	r2, [r3, #0]
    PUTCHAR(id, outp);
 8015146:	693b      	ldr	r3, [r7, #16]
 8015148:	1c5a      	adds	r2, r3, #1
 801514a:	613a      	str	r2, [r7, #16]
 801514c:	220a      	movs	r2, #10
 801514e:	18ba      	adds	r2, r7, r2
 8015150:	7812      	ldrb	r2, [r2, #0]
 8015152:	701a      	strb	r2, [r3, #0]
    PUTSHORT(outlen, outp);
 8015154:	69bb      	ldr	r3, [r7, #24]
 8015156:	1219      	asrs	r1, r3, #8
 8015158:	693b      	ldr	r3, [r7, #16]
 801515a:	1c5a      	adds	r2, r3, #1
 801515c:	613a      	str	r2, [r7, #16]
 801515e:	b2ca      	uxtb	r2, r1
 8015160:	701a      	strb	r2, [r3, #0]
 8015162:	693b      	ldr	r3, [r7, #16]
 8015164:	1c5a      	adds	r2, r3, #1
 8015166:	613a      	str	r2, [r7, #16]
 8015168:	69ba      	ldr	r2, [r7, #24]
 801516a:	b2d2      	uxtb	r2, r2
 801516c:	701a      	strb	r2, [r3, #0]
    ppp_write(pcb, p);
 801516e:	697a      	ldr	r2, [r7, #20]
 8015170:	69fb      	ldr	r3, [r7, #28]
 8015172:	0011      	movs	r1, r2
 8015174:	0018      	movs	r0, r3
 8015176:	f004 ff07 	bl	8019f88 <ppp_write>
 801517a:	e000      	b.n	801517e <fsm_sdata+0x10a>
        return;
 801517c:	46c0      	nop			; (mov r8, r8)
}
 801517e:	46bd      	mov	sp, r7
 8015180:	b008      	add	sp, #32
 8015182:	bd80      	pop	{r7, pc}

08015184 <ipcp_init>:
#endif /* PPP_OPTIONS */

/*
 * ipcp_init - Initialize IPCP.
 */
static void ipcp_init(ppp_pcb *pcb) {
 8015184:	b580      	push	{r7, lr}
 8015186:	b086      	sub	sp, #24
 8015188:	af00      	add	r7, sp, #0
 801518a:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->ipcp_fsm;
 801518c:	687b      	ldr	r3, [r7, #4]
 801518e:	4a34      	ldr	r2, [pc, #208]	; (8015260 <ipcp_init+0xdc>)
 8015190:	4694      	mov	ip, r2
 8015192:	4463      	add	r3, ip
 8015194:	617b      	str	r3, [r7, #20]

    ipcp_options *wo = &pcb->ipcp_wantoptions;
 8015196:	687b      	ldr	r3, [r7, #4]
 8015198:	4a32      	ldr	r2, [pc, #200]	; (8015264 <ipcp_init+0xe0>)
 801519a:	4694      	mov	ip, r2
 801519c:	4463      	add	r3, ip
 801519e:	613b      	str	r3, [r7, #16]
    ipcp_options *ao = &pcb->ipcp_allowoptions;
 80151a0:	687b      	ldr	r3, [r7, #4]
 80151a2:	4a31      	ldr	r2, [pc, #196]	; (8015268 <ipcp_init+0xe4>)
 80151a4:	4694      	mov	ip, r2
 80151a6:	4463      	add	r3, ip
 80151a8:	60fb      	str	r3, [r7, #12]

    f->pcb = pcb;
 80151aa:	697b      	ldr	r3, [r7, #20]
 80151ac:	687a      	ldr	r2, [r7, #4]
 80151ae:	601a      	str	r2, [r3, #0]
    f->protocol = PPP_IPCP;
 80151b0:	697b      	ldr	r3, [r7, #20]
 80151b2:	4a2e      	ldr	r2, [pc, #184]	; (801526c <ipcp_init+0xe8>)
 80151b4:	81da      	strh	r2, [r3, #14]
    f->callbacks = &ipcp_callbacks;
 80151b6:	697b      	ldr	r3, [r7, #20]
 80151b8:	4a2d      	ldr	r2, [pc, #180]	; (8015270 <ipcp_init+0xec>)
 80151ba:	605a      	str	r2, [r3, #4]
    fsm_init(f);
 80151bc:	697b      	ldr	r3, [r7, #20]
 80151be:	0018      	movs	r0, r3
 80151c0:	f7ff f83c 	bl	801423c <fsm_init>
     * Some 3G modems use repeated IPCP NAKs as a way of stalling
     * until they can contact a server on the network, so we increase
     * the default number of NAKs we accept before we start treating
     * them as rejects.
     */
    f->maxnakloops = 100;
 80151c4:	697b      	ldr	r3, [r7, #20]
 80151c6:	2264      	movs	r2, #100	; 0x64
 80151c8:	75da      	strb	r2, [r3, #23]
#if 0 /* Not necessary, everything is cleared in ppp_new() */
    memset(wo, 0, sizeof(*wo));
    memset(ao, 0, sizeof(*ao));
#endif /* 0 */

    wo->neg_addr = wo->old_addrs = 1;
 80151ca:	693b      	ldr	r3, [r7, #16]
 80151cc:	781a      	ldrb	r2, [r3, #0]
 80151ce:	2102      	movs	r1, #2
 80151d0:	430a      	orrs	r2, r1
 80151d2:	701a      	strb	r2, [r3, #0]
 80151d4:	693b      	ldr	r3, [r7, #16]
 80151d6:	781b      	ldrb	r3, [r3, #0]
 80151d8:	079b      	lsls	r3, r3, #30
 80151da:	0fdb      	lsrs	r3, r3, #31
 80151dc:	b2da      	uxtb	r2, r3
 80151de:	693b      	ldr	r3, [r7, #16]
 80151e0:	2101      	movs	r1, #1
 80151e2:	400a      	ands	r2, r1
 80151e4:	0010      	movs	r0, r2
 80151e6:	781a      	ldrb	r2, [r3, #0]
 80151e8:	2101      	movs	r1, #1
 80151ea:	438a      	bics	r2, r1
 80151ec:	1c11      	adds	r1, r2, #0
 80151ee:	1c02      	adds	r2, r0, #0
 80151f0:	430a      	orrs	r2, r1
 80151f2:	701a      	strb	r2, [r3, #0]
#if VJ_SUPPORT
    wo->neg_vj = 1;
 80151f4:	693b      	ldr	r3, [r7, #16]
 80151f6:	781a      	ldrb	r2, [r3, #0]
 80151f8:	2108      	movs	r1, #8
 80151fa:	430a      	orrs	r2, r1
 80151fc:	701a      	strb	r2, [r3, #0]
    wo->vj_protocol = IPCP_VJ_COMP;
 80151fe:	693b      	ldr	r3, [r7, #16]
 8015200:	222d      	movs	r2, #45	; 0x2d
 8015202:	829a      	strh	r2, [r3, #20]
    wo->maxslotindex = MAX_STATES - 1; /* really max index */
 8015204:	693b      	ldr	r3, [r7, #16]
 8015206:	220f      	movs	r2, #15
 8015208:	759a      	strb	r2, [r3, #22]
    wo->cflag = 1;
 801520a:	693b      	ldr	r3, [r7, #16]
 801520c:	781a      	ldrb	r2, [r3, #0]
 801520e:	2120      	movs	r1, #32
 8015210:	430a      	orrs	r2, r1
 8015212:	701a      	strb	r2, [r3, #0]
#if 0 /* UNUSED */
    /* wanting default route by default */
    wo->default_route = 1;
#endif /* UNUSED */

    ao->neg_addr = ao->old_addrs = 1;
 8015214:	68fb      	ldr	r3, [r7, #12]
 8015216:	781a      	ldrb	r2, [r3, #0]
 8015218:	2102      	movs	r1, #2
 801521a:	430a      	orrs	r2, r1
 801521c:	701a      	strb	r2, [r3, #0]
 801521e:	68fb      	ldr	r3, [r7, #12]
 8015220:	781b      	ldrb	r3, [r3, #0]
 8015222:	079b      	lsls	r3, r3, #30
 8015224:	0fdb      	lsrs	r3, r3, #31
 8015226:	b2da      	uxtb	r2, r3
 8015228:	68fb      	ldr	r3, [r7, #12]
 801522a:	2101      	movs	r1, #1
 801522c:	400a      	ands	r2, r1
 801522e:	0010      	movs	r0, r2
 8015230:	781a      	ldrb	r2, [r3, #0]
 8015232:	2101      	movs	r1, #1
 8015234:	438a      	bics	r2, r1
 8015236:	1c11      	adds	r1, r2, #0
 8015238:	1c02      	adds	r2, r0, #0
 801523a:	430a      	orrs	r2, r1
 801523c:	701a      	strb	r2, [r3, #0]
#if VJ_SUPPORT
    /* max slots and slot-id compression are currently hardwired in */
    /* ppp_if.c to 16 and 1, this needs to be changed (among other */
    /* things) gmc */

    ao->neg_vj = 1;
 801523e:	68fb      	ldr	r3, [r7, #12]
 8015240:	781a      	ldrb	r2, [r3, #0]
 8015242:	2108      	movs	r1, #8
 8015244:	430a      	orrs	r2, r1
 8015246:	701a      	strb	r2, [r3, #0]
    ao->maxslotindex = MAX_STATES - 1;
 8015248:	68fb      	ldr	r3, [r7, #12]
 801524a:	220f      	movs	r2, #15
 801524c:	759a      	strb	r2, [r3, #22]
    ao->cflag = 1;
 801524e:	68fb      	ldr	r3, [r7, #12]
 8015250:	781a      	ldrb	r2, [r3, #0]
 8015252:	2120      	movs	r1, #32
 8015254:	430a      	orrs	r2, r1
 8015256:	701a      	strb	r2, [r3, #0]
     * and defaultroute options.
     */
    ao->proxy_arp = 1;
    ao->default_route = 1;
#endif /* UNUSED */
}
 8015258:	46c0      	nop			; (mov r8, r8)
 801525a:	46bd      	mov	sp, r7
 801525c:	b006      	add	sp, #24
 801525e:	bd80      	pop	{r7, pc}
 8015260:	000011e8 	.word	0x000011e8
 8015264:	00001204 	.word	0x00001204
 8015268:	00001234 	.word	0x00001234
 801526c:	ffff8021 	.word	0xffff8021
 8015270:	08022570 	.word	0x08022570

08015274 <ipcp_open>:


/*
 * ipcp_open - IPCP is allowed to come up.
 */
static void ipcp_open(ppp_pcb *pcb) {
 8015274:	b580      	push	{r7, lr}
 8015276:	b084      	sub	sp, #16
 8015278:	af00      	add	r7, sp, #0
 801527a:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->ipcp_fsm;
 801527c:	687b      	ldr	r3, [r7, #4]
 801527e:	4a09      	ldr	r2, [pc, #36]	; (80152a4 <ipcp_open+0x30>)
 8015280:	4694      	mov	ip, r2
 8015282:	4463      	add	r3, ip
 8015284:	60fb      	str	r3, [r7, #12]
    fsm_open(f);
 8015286:	68fb      	ldr	r3, [r7, #12]
 8015288:	0018      	movs	r0, r3
 801528a:	f7ff f865 	bl	8014358 <fsm_open>
    pcb->ipcp_is_open = 1;
 801528e:	687b      	ldr	r3, [r7, #4]
 8015290:	2226      	movs	r2, #38	; 0x26
 8015292:	5c99      	ldrb	r1, [r3, r2]
 8015294:	2002      	movs	r0, #2
 8015296:	4301      	orrs	r1, r0
 8015298:	5499      	strb	r1, [r3, r2]
}
 801529a:	46c0      	nop			; (mov r8, r8)
 801529c:	46bd      	mov	sp, r7
 801529e:	b004      	add	sp, #16
 80152a0:	bd80      	pop	{r7, pc}
 80152a2:	46c0      	nop			; (mov r8, r8)
 80152a4:	000011e8 	.word	0x000011e8

080152a8 <ipcp_close>:


/*
 * ipcp_close - Take IPCP down.
 */
static void ipcp_close(ppp_pcb *pcb, const char *reason) {
 80152a8:	b580      	push	{r7, lr}
 80152aa:	b084      	sub	sp, #16
 80152ac:	af00      	add	r7, sp, #0
 80152ae:	6078      	str	r0, [r7, #4]
 80152b0:	6039      	str	r1, [r7, #0]
    fsm *f = &pcb->ipcp_fsm;
 80152b2:	687b      	ldr	r3, [r7, #4]
 80152b4:	4a06      	ldr	r2, [pc, #24]	; (80152d0 <ipcp_close+0x28>)
 80152b6:	4694      	mov	ip, r2
 80152b8:	4463      	add	r3, ip
 80152ba:	60fb      	str	r3, [r7, #12]
    fsm_close(f, reason);
 80152bc:	683a      	ldr	r2, [r7, #0]
 80152be:	68fb      	ldr	r3, [r7, #12]
 80152c0:	0011      	movs	r1, r2
 80152c2:	0018      	movs	r0, r3
 80152c4:	f7ff f90a 	bl	80144dc <fsm_close>
}
 80152c8:	46c0      	nop			; (mov r8, r8)
 80152ca:	46bd      	mov	sp, r7
 80152cc:	b004      	add	sp, #16
 80152ce:	bd80      	pop	{r7, pc}
 80152d0:	000011e8 	.word	0x000011e8

080152d4 <ipcp_lowerup>:


/*
 * ipcp_lowerup - The lower layer is up.
 */
static void ipcp_lowerup(ppp_pcb *pcb) {
 80152d4:	b580      	push	{r7, lr}
 80152d6:	b084      	sub	sp, #16
 80152d8:	af00      	add	r7, sp, #0
 80152da:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->ipcp_fsm;
 80152dc:	687b      	ldr	r3, [r7, #4]
 80152de:	4a06      	ldr	r2, [pc, #24]	; (80152f8 <ipcp_lowerup+0x24>)
 80152e0:	4694      	mov	ip, r2
 80152e2:	4463      	add	r3, ip
 80152e4:	60fb      	str	r3, [r7, #12]
    fsm_lowerup(f);
 80152e6:	68fb      	ldr	r3, [r7, #12]
 80152e8:	0018      	movs	r0, r3
 80152ea:	f7fe ffc2 	bl	8014272 <fsm_lowerup>
}
 80152ee:	46c0      	nop			; (mov r8, r8)
 80152f0:	46bd      	mov	sp, r7
 80152f2:	b004      	add	sp, #16
 80152f4:	bd80      	pop	{r7, pc}
 80152f6:	46c0      	nop			; (mov r8, r8)
 80152f8:	000011e8 	.word	0x000011e8

080152fc <ipcp_lowerdown>:


/*
 * ipcp_lowerdown - The lower layer is down.
 */
static void ipcp_lowerdown(ppp_pcb *pcb) {
 80152fc:	b580      	push	{r7, lr}
 80152fe:	b084      	sub	sp, #16
 8015300:	af00      	add	r7, sp, #0
 8015302:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->ipcp_fsm;
 8015304:	687b      	ldr	r3, [r7, #4]
 8015306:	4a06      	ldr	r2, [pc, #24]	; (8015320 <ipcp_lowerdown+0x24>)
 8015308:	4694      	mov	ip, r2
 801530a:	4463      	add	r3, ip
 801530c:	60fb      	str	r3, [r7, #12]
    fsm_lowerdown(f);
 801530e:	68fb      	ldr	r3, [r7, #12]
 8015310:	0018      	movs	r0, r3
 8015312:	f7fe ffd5 	bl	80142c0 <fsm_lowerdown>
}
 8015316:	46c0      	nop			; (mov r8, r8)
 8015318:	46bd      	mov	sp, r7
 801531a:	b004      	add	sp, #16
 801531c:	bd80      	pop	{r7, pc}
 801531e:	46c0      	nop			; (mov r8, r8)
 8015320:	000011e8 	.word	0x000011e8

08015324 <ipcp_input>:


/*
 * ipcp_input - Input IPCP packet.
 */
static void ipcp_input(ppp_pcb *pcb, u_char *p, int len) {
 8015324:	b580      	push	{r7, lr}
 8015326:	b086      	sub	sp, #24
 8015328:	af00      	add	r7, sp, #0
 801532a:	60f8      	str	r0, [r7, #12]
 801532c:	60b9      	str	r1, [r7, #8]
 801532e:	607a      	str	r2, [r7, #4]
    fsm *f = &pcb->ipcp_fsm;
 8015330:	68fb      	ldr	r3, [r7, #12]
 8015332:	4a07      	ldr	r2, [pc, #28]	; (8015350 <ipcp_input+0x2c>)
 8015334:	4694      	mov	ip, r2
 8015336:	4463      	add	r3, ip
 8015338:	617b      	str	r3, [r7, #20]
    fsm_input(f, p, len);
 801533a:	687a      	ldr	r2, [r7, #4]
 801533c:	68b9      	ldr	r1, [r7, #8]
 801533e:	697b      	ldr	r3, [r7, #20]
 8015340:	0018      	movs	r0, r3
 8015342:	f7ff f9b5 	bl	80146b0 <fsm_input>
}
 8015346:	46c0      	nop			; (mov r8, r8)
 8015348:	46bd      	mov	sp, r7
 801534a:	b006      	add	sp, #24
 801534c:	bd80      	pop	{r7, pc}
 801534e:	46c0      	nop			; (mov r8, r8)
 8015350:	000011e8 	.word	0x000011e8

08015354 <ipcp_protrej>:
/*
 * ipcp_protrej - A Protocol-Reject was received for IPCP.
 *
 * Pretend the lower layer went down, so we shut up.
 */
static void ipcp_protrej(ppp_pcb *pcb) {
 8015354:	b580      	push	{r7, lr}
 8015356:	b084      	sub	sp, #16
 8015358:	af00      	add	r7, sp, #0
 801535a:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->ipcp_fsm;
 801535c:	687b      	ldr	r3, [r7, #4]
 801535e:	4a06      	ldr	r2, [pc, #24]	; (8015378 <ipcp_protrej+0x24>)
 8015360:	4694      	mov	ip, r2
 8015362:	4463      	add	r3, ip
 8015364:	60fb      	str	r3, [r7, #12]
    fsm_lowerdown(f);
 8015366:	68fb      	ldr	r3, [r7, #12]
 8015368:	0018      	movs	r0, r3
 801536a:	f7fe ffa9 	bl	80142c0 <fsm_lowerdown>
}
 801536e:	46c0      	nop			; (mov r8, r8)
 8015370:	46bd      	mov	sp, r7
 8015372:	b004      	add	sp, #16
 8015374:	bd80      	pop	{r7, pc}
 8015376:	46c0      	nop			; (mov r8, r8)
 8015378:	000011e8 	.word	0x000011e8

0801537c <ipcp_resetci>:

/*
 * ipcp_resetci - Reset our CI.
 * Called by fsm_sconfreq, Send Configure Request.
 */
static void ipcp_resetci(fsm *f) {
 801537c:	b590      	push	{r4, r7, lr}
 801537e:	b087      	sub	sp, #28
 8015380:	af00      	add	r7, sp, #0
 8015382:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8015384:	687b      	ldr	r3, [r7, #4]
 8015386:	681b      	ldr	r3, [r3, #0]
 8015388:	617b      	str	r3, [r7, #20]
    ipcp_options *wo = &pcb->ipcp_wantoptions;
 801538a:	697b      	ldr	r3, [r7, #20]
 801538c:	4a46      	ldr	r2, [pc, #280]	; (80154a8 <ipcp_resetci+0x12c>)
 801538e:	4694      	mov	ip, r2
 8015390:	4463      	add	r3, ip
 8015392:	613b      	str	r3, [r7, #16]
    ipcp_options *go = &pcb->ipcp_gotoptions;
 8015394:	697b      	ldr	r3, [r7, #20]
 8015396:	4a45      	ldr	r2, [pc, #276]	; (80154ac <ipcp_resetci+0x130>)
 8015398:	4694      	mov	ip, r2
 801539a:	4463      	add	r3, ip
 801539c:	60fb      	str	r3, [r7, #12]
    ipcp_options *ao = &pcb->ipcp_allowoptions;
 801539e:	697b      	ldr	r3, [r7, #20]
 80153a0:	4a43      	ldr	r2, [pc, #268]	; (80154b0 <ipcp_resetci+0x134>)
 80153a2:	4694      	mov	ip, r2
 80153a4:	4463      	add	r3, ip
 80153a6:	60bb      	str	r3, [r7, #8]

    wo->req_addr = (wo->neg_addr || wo->old_addrs) &&
 80153a8:	693b      	ldr	r3, [r7, #16]
 80153aa:	781b      	ldrb	r3, [r3, #0]
 80153ac:	2201      	movs	r2, #1
 80153ae:	4013      	ands	r3, r2
 80153b0:	b2db      	uxtb	r3, r3
 80153b2:	2b00      	cmp	r3, #0
 80153b4:	d106      	bne.n	80153c4 <ipcp_resetci+0x48>
 80153b6:	693b      	ldr	r3, [r7, #16]
 80153b8:	781b      	ldrb	r3, [r3, #0]
 80153ba:	2202      	movs	r2, #2
 80153bc:	4013      	ands	r3, r2
 80153be:	b2db      	uxtb	r3, r3
 80153c0:	2b00      	cmp	r3, #0
 80153c2:	d00f      	beq.n	80153e4 <ipcp_resetci+0x68>
	(ao->neg_addr || ao->old_addrs);
 80153c4:	68bb      	ldr	r3, [r7, #8]
 80153c6:	781b      	ldrb	r3, [r3, #0]
 80153c8:	2201      	movs	r2, #1
 80153ca:	4013      	ands	r3, r2
 80153cc:	b2db      	uxtb	r3, r3
    wo->req_addr = (wo->neg_addr || wo->old_addrs) &&
 80153ce:	2b00      	cmp	r3, #0
 80153d0:	d106      	bne.n	80153e0 <ipcp_resetci+0x64>
	(ao->neg_addr || ao->old_addrs);
 80153d2:	68bb      	ldr	r3, [r7, #8]
 80153d4:	781b      	ldrb	r3, [r3, #0]
 80153d6:	2202      	movs	r2, #2
 80153d8:	4013      	ands	r3, r2
 80153da:	b2db      	uxtb	r3, r3
 80153dc:	2b00      	cmp	r3, #0
 80153de:	d001      	beq.n	80153e4 <ipcp_resetci+0x68>
    wo->req_addr = (wo->neg_addr || wo->old_addrs) &&
 80153e0:	2301      	movs	r3, #1
 80153e2:	e000      	b.n	80153e6 <ipcp_resetci+0x6a>
 80153e4:	2300      	movs	r3, #0
 80153e6:	1c1a      	adds	r2, r3, #0
 80153e8:	2301      	movs	r3, #1
 80153ea:	4013      	ands	r3, r2
 80153ec:	b2da      	uxtb	r2, r3
 80153ee:	693b      	ldr	r3, [r7, #16]
 80153f0:	2101      	movs	r1, #1
 80153f2:	400a      	ands	r2, r1
 80153f4:	0090      	lsls	r0, r2, #2
 80153f6:	781a      	ldrb	r2, [r3, #0]
 80153f8:	2104      	movs	r1, #4
 80153fa:	438a      	bics	r2, r1
 80153fc:	1c11      	adds	r1, r2, #0
 80153fe:	1c02      	adds	r2, r0, #0
 8015400:	430a      	orrs	r2, r1
 8015402:	701a      	strb	r2, [r3, #0]
    if (wo->ouraddr == 0)
 8015404:	693b      	ldr	r3, [r7, #16]
 8015406:	685b      	ldr	r3, [r3, #4]
 8015408:	2b00      	cmp	r3, #0
 801540a:	d104      	bne.n	8015416 <ipcp_resetci+0x9a>
	wo->accept_local = 1;
 801540c:	693b      	ldr	r3, [r7, #16]
 801540e:	781a      	ldrb	r2, [r3, #0]
 8015410:	2140      	movs	r1, #64	; 0x40
 8015412:	430a      	orrs	r2, r1
 8015414:	701a      	strb	r2, [r3, #0]
    if (wo->hisaddr == 0)
 8015416:	693b      	ldr	r3, [r7, #16]
 8015418:	689b      	ldr	r3, [r3, #8]
 801541a:	2b00      	cmp	r3, #0
 801541c:	d105      	bne.n	801542a <ipcp_resetci+0xae>
	wo->accept_remote = 1;
 801541e:	693b      	ldr	r3, [r7, #16]
 8015420:	781a      	ldrb	r2, [r3, #0]
 8015422:	2180      	movs	r1, #128	; 0x80
 8015424:	4249      	negs	r1, r1
 8015426:	430a      	orrs	r2, r1
 8015428:	701a      	strb	r2, [r3, #0]
#if LWIP_DNS
    wo->req_dns1 = wo->req_dns2 = pcb->settings.usepeerdns;	/* Request DNS addresses from the peer */
 801542a:	697b      	ldr	r3, [r7, #20]
 801542c:	781b      	ldrb	r3, [r3, #0]
 801542e:	07db      	lsls	r3, r3, #31
 8015430:	0fdb      	lsrs	r3, r3, #31
 8015432:	b2da      	uxtb	r2, r3
 8015434:	693b      	ldr	r3, [r7, #16]
 8015436:	2101      	movs	r1, #1
 8015438:	400a      	ands	r2, r1
 801543a:	1890      	adds	r0, r2, r2
 801543c:	785a      	ldrb	r2, [r3, #1]
 801543e:	2102      	movs	r1, #2
 8015440:	438a      	bics	r2, r1
 8015442:	1c11      	adds	r1, r2, #0
 8015444:	1c02      	adds	r2, r0, #0
 8015446:	430a      	orrs	r2, r1
 8015448:	705a      	strb	r2, [r3, #1]
 801544a:	693b      	ldr	r3, [r7, #16]
 801544c:	785b      	ldrb	r3, [r3, #1]
 801544e:	079b      	lsls	r3, r3, #30
 8015450:	0fdb      	lsrs	r3, r3, #31
 8015452:	b2da      	uxtb	r2, r3
 8015454:	693b      	ldr	r3, [r7, #16]
 8015456:	2101      	movs	r1, #1
 8015458:	400a      	ands	r2, r1
 801545a:	0010      	movs	r0, r2
 801545c:	785a      	ldrb	r2, [r3, #1]
 801545e:	2101      	movs	r1, #1
 8015460:	438a      	bics	r2, r1
 8015462:	1c11      	adds	r1, r2, #0
 8015464:	1c02      	adds	r2, r0, #0
 8015466:	430a      	orrs	r2, r1
 8015468:	705a      	strb	r2, [r3, #1]
#endif /* LWIP_DNS */
    *go = *wo;
 801546a:	68fb      	ldr	r3, [r7, #12]
 801546c:	693a      	ldr	r2, [r7, #16]
 801546e:	ca13      	ldmia	r2!, {r0, r1, r4}
 8015470:	c313      	stmia	r3!, {r0, r1, r4}
 8015472:	ca13      	ldmia	r2!, {r0, r1, r4}
 8015474:	c313      	stmia	r3!, {r0, r1, r4}
    if (!pcb->ask_for_local)
 8015476:	697b      	ldr	r3, [r7, #20]
 8015478:	2226      	movs	r2, #38	; 0x26
 801547a:	5c9b      	ldrb	r3, [r3, r2]
 801547c:	2201      	movs	r2, #1
 801547e:	4013      	ands	r3, r2
 8015480:	b2db      	uxtb	r3, r3
 8015482:	2b00      	cmp	r3, #0
 8015484:	d102      	bne.n	801548c <ipcp_resetci+0x110>
	go->ouraddr = 0;
 8015486:	68fb      	ldr	r3, [r7, #12]
 8015488:	2200      	movs	r2, #0
 801548a:	605a      	str	r2, [r3, #4]
	if (wo->hisaddr) {
	    wo->accept_remote = 0;
	}
    }
#endif /* UNUSED */
    BZERO(&pcb->ipcp_hisoptions, sizeof(ipcp_options));
 801548c:	697b      	ldr	r3, [r7, #20]
 801548e:	4a09      	ldr	r2, [pc, #36]	; (80154b4 <ipcp_resetci+0x138>)
 8015490:	4694      	mov	ip, r2
 8015492:	4463      	add	r3, ip
 8015494:	2218      	movs	r2, #24
 8015496:	2100      	movs	r1, #0
 8015498:	0018      	movs	r0, r3
 801549a:	f007 fbbd 	bl	801cc18 <memset>
}
 801549e:	46c0      	nop			; (mov r8, r8)
 80154a0:	46bd      	mov	sp, r7
 80154a2:	b007      	add	sp, #28
 80154a4:	bd90      	pop	{r4, r7, pc}
 80154a6:	46c0      	nop			; (mov r8, r8)
 80154a8:	00001204 	.word	0x00001204
 80154ac:	0000121c 	.word	0x0000121c
 80154b0:	00001234 	.word	0x00001234
 80154b4:	0000124c 	.word	0x0000124c

080154b8 <ipcp_cilen>:

/*
 * ipcp_cilen - Return length of our CI.
 * Called by fsm_sconfreq, Send Configure Request.
 */
static int ipcp_cilen(fsm *f) {
 80154b8:	b580      	push	{r7, lr}
 80154ba:	b086      	sub	sp, #24
 80154bc:	af00      	add	r7, sp, #0
 80154be:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 80154c0:	687b      	ldr	r3, [r7, #4]
 80154c2:	681b      	ldr	r3, [r3, #0]
 80154c4:	617b      	str	r3, [r7, #20]
    ipcp_options *go = &pcb->ipcp_gotoptions;
 80154c6:	697b      	ldr	r3, [r7, #20]
 80154c8:	4a54      	ldr	r2, [pc, #336]	; (801561c <ipcp_cilen+0x164>)
 80154ca:	4694      	mov	ip, r2
 80154cc:	4463      	add	r3, ip
 80154ce:	613b      	str	r3, [r7, #16]
#if VJ_SUPPORT
    ipcp_options *wo = &pcb->ipcp_wantoptions;
 80154d0:	697b      	ldr	r3, [r7, #20]
 80154d2:	4a53      	ldr	r2, [pc, #332]	; (8015620 <ipcp_cilen+0x168>)
 80154d4:	4694      	mov	ip, r2
 80154d6:	4463      	add	r3, ip
 80154d8:	60fb      	str	r3, [r7, #12]
#endif /* VJ_SUPPORT */
    ipcp_options *ho = &pcb->ipcp_hisoptions;
 80154da:	697b      	ldr	r3, [r7, #20]
 80154dc:	4a51      	ldr	r2, [pc, #324]	; (8015624 <ipcp_cilen+0x16c>)
 80154de:	4694      	mov	ip, r2
 80154e0:	4463      	add	r3, ip
 80154e2:	60bb      	str	r3, [r7, #8]

    /*
     * First see if we want to change our options to the old
     * forms because we have received old forms from the peer.
     */
    if (go->neg_addr && go->old_addrs && !ho->neg_addr && ho->old_addrs)
 80154e4:	693b      	ldr	r3, [r7, #16]
 80154e6:	781b      	ldrb	r3, [r3, #0]
 80154e8:	2201      	movs	r2, #1
 80154ea:	4013      	ands	r3, r2
 80154ec:	b2db      	uxtb	r3, r3
 80154ee:	2b00      	cmp	r3, #0
 80154f0:	d019      	beq.n	8015526 <ipcp_cilen+0x6e>
 80154f2:	693b      	ldr	r3, [r7, #16]
 80154f4:	781b      	ldrb	r3, [r3, #0]
 80154f6:	2202      	movs	r2, #2
 80154f8:	4013      	ands	r3, r2
 80154fa:	b2db      	uxtb	r3, r3
 80154fc:	2b00      	cmp	r3, #0
 80154fe:	d012      	beq.n	8015526 <ipcp_cilen+0x6e>
 8015500:	68bb      	ldr	r3, [r7, #8]
 8015502:	781b      	ldrb	r3, [r3, #0]
 8015504:	2201      	movs	r2, #1
 8015506:	4013      	ands	r3, r2
 8015508:	b2db      	uxtb	r3, r3
 801550a:	2b00      	cmp	r3, #0
 801550c:	d10b      	bne.n	8015526 <ipcp_cilen+0x6e>
 801550e:	68bb      	ldr	r3, [r7, #8]
 8015510:	781b      	ldrb	r3, [r3, #0]
 8015512:	2202      	movs	r2, #2
 8015514:	4013      	ands	r3, r2
 8015516:	b2db      	uxtb	r3, r3
 8015518:	2b00      	cmp	r3, #0
 801551a:	d004      	beq.n	8015526 <ipcp_cilen+0x6e>
	go->neg_addr = 0;
 801551c:	693b      	ldr	r3, [r7, #16]
 801551e:	781a      	ldrb	r2, [r3, #0]
 8015520:	2101      	movs	r1, #1
 8015522:	438a      	bics	r2, r1
 8015524:	701a      	strb	r2, [r3, #0]

#if VJ_SUPPORT
    if (wo->neg_vj && !go->neg_vj && !go->old_vj) {
 8015526:	68fb      	ldr	r3, [r7, #12]
 8015528:	781b      	ldrb	r3, [r3, #0]
 801552a:	2208      	movs	r2, #8
 801552c:	4013      	ands	r3, r2
 801552e:	b2db      	uxtb	r3, r3
 8015530:	2b00      	cmp	r3, #0
 8015532:	d029      	beq.n	8015588 <ipcp_cilen+0xd0>
 8015534:	693b      	ldr	r3, [r7, #16]
 8015536:	781b      	ldrb	r3, [r3, #0]
 8015538:	2208      	movs	r2, #8
 801553a:	4013      	ands	r3, r2
 801553c:	b2db      	uxtb	r3, r3
 801553e:	2b00      	cmp	r3, #0
 8015540:	d122      	bne.n	8015588 <ipcp_cilen+0xd0>
 8015542:	693b      	ldr	r3, [r7, #16]
 8015544:	781b      	ldrb	r3, [r3, #0]
 8015546:	2210      	movs	r2, #16
 8015548:	4013      	ands	r3, r2
 801554a:	b2db      	uxtb	r3, r3
 801554c:	2b00      	cmp	r3, #0
 801554e:	d11b      	bne.n	8015588 <ipcp_cilen+0xd0>
	/* try an older style of VJ negotiation */
	/* use the old style only if the peer did */
	if (ho->neg_vj && ho->old_vj) {
 8015550:	68bb      	ldr	r3, [r7, #8]
 8015552:	781b      	ldrb	r3, [r3, #0]
 8015554:	2208      	movs	r2, #8
 8015556:	4013      	ands	r3, r2
 8015558:	b2db      	uxtb	r3, r3
 801555a:	2b00      	cmp	r3, #0
 801555c:	d014      	beq.n	8015588 <ipcp_cilen+0xd0>
 801555e:	68bb      	ldr	r3, [r7, #8]
 8015560:	781b      	ldrb	r3, [r3, #0]
 8015562:	2210      	movs	r2, #16
 8015564:	4013      	ands	r3, r2
 8015566:	b2db      	uxtb	r3, r3
 8015568:	2b00      	cmp	r3, #0
 801556a:	d00d      	beq.n	8015588 <ipcp_cilen+0xd0>
	    go->neg_vj = 1;
 801556c:	693b      	ldr	r3, [r7, #16]
 801556e:	781a      	ldrb	r2, [r3, #0]
 8015570:	2108      	movs	r1, #8
 8015572:	430a      	orrs	r2, r1
 8015574:	701a      	strb	r2, [r3, #0]
	    go->old_vj = 1;
 8015576:	693b      	ldr	r3, [r7, #16]
 8015578:	781a      	ldrb	r2, [r3, #0]
 801557a:	2110      	movs	r1, #16
 801557c:	430a      	orrs	r2, r1
 801557e:	701a      	strb	r2, [r3, #0]
	    go->vj_protocol = ho->vj_protocol;
 8015580:	68bb      	ldr	r3, [r7, #8]
 8015582:	8a9a      	ldrh	r2, [r3, #20]
 8015584:	693b      	ldr	r3, [r7, #16]
 8015586:	829a      	strh	r2, [r3, #20]
	}
    }
#endif /* VJ_SUPPORT */

    return (LENCIADDRS(!go->neg_addr && go->old_addrs) +
 8015588:	693b      	ldr	r3, [r7, #16]
 801558a:	781b      	ldrb	r3, [r3, #0]
 801558c:	2201      	movs	r2, #1
 801558e:	4013      	ands	r3, r2
 8015590:	b2db      	uxtb	r3, r3
 8015592:	2b00      	cmp	r3, #0
 8015594:	d108      	bne.n	80155a8 <ipcp_cilen+0xf0>
 8015596:	693b      	ldr	r3, [r7, #16]
 8015598:	781b      	ldrb	r3, [r3, #0]
 801559a:	2202      	movs	r2, #2
 801559c:	4013      	ands	r3, r2
 801559e:	b2db      	uxtb	r3, r3
 80155a0:	2b00      	cmp	r3, #0
 80155a2:	d001      	beq.n	80155a8 <ipcp_cilen+0xf0>
 80155a4:	220a      	movs	r2, #10
 80155a6:	e000      	b.n	80155aa <ipcp_cilen+0xf2>
 80155a8:	2200      	movs	r2, #0
#if VJ_SUPPORT
	    LENCIVJ(go->neg_vj, go->old_vj) +
 80155aa:	693b      	ldr	r3, [r7, #16]
 80155ac:	781b      	ldrb	r3, [r3, #0]
 80155ae:	2108      	movs	r1, #8
 80155b0:	400b      	ands	r3, r1
 80155b2:	b2db      	uxtb	r3, r3
 80155b4:	2b00      	cmp	r3, #0
 80155b6:	d00a      	beq.n	80155ce <ipcp_cilen+0x116>
 80155b8:	693b      	ldr	r3, [r7, #16]
 80155ba:	781b      	ldrb	r3, [r3, #0]
 80155bc:	2110      	movs	r1, #16
 80155be:	400b      	ands	r3, r1
 80155c0:	b2db      	uxtb	r3, r3
 80155c2:	2b00      	cmp	r3, #0
 80155c4:	d001      	beq.n	80155ca <ipcp_cilen+0x112>
 80155c6:	2304      	movs	r3, #4
 80155c8:	e002      	b.n	80155d0 <ipcp_cilen+0x118>
 80155ca:	2306      	movs	r3, #6
 80155cc:	e000      	b.n	80155d0 <ipcp_cilen+0x118>
 80155ce:	2300      	movs	r3, #0
    return (LENCIADDRS(!go->neg_addr && go->old_addrs) +
 80155d0:	18d2      	adds	r2, r2, r3
#endif /* VJ_SUPPORT */
	    LENCIADDR(go->neg_addr) +
 80155d2:	693b      	ldr	r3, [r7, #16]
 80155d4:	781b      	ldrb	r3, [r3, #0]
 80155d6:	2101      	movs	r1, #1
 80155d8:	400b      	ands	r3, r1
 80155da:	b2db      	uxtb	r3, r3
 80155dc:	2b00      	cmp	r3, #0
 80155de:	d001      	beq.n	80155e4 <ipcp_cilen+0x12c>
 80155e0:	2306      	movs	r3, #6
 80155e2:	e000      	b.n	80155e6 <ipcp_cilen+0x12e>
 80155e4:	2300      	movs	r3, #0
	    LENCIVJ(go->neg_vj, go->old_vj) +
 80155e6:	189a      	adds	r2, r3, r2
#if LWIP_DNS
	    LENCIDNS(go->req_dns1) +
 80155e8:	693b      	ldr	r3, [r7, #16]
 80155ea:	785b      	ldrb	r3, [r3, #1]
 80155ec:	2101      	movs	r1, #1
 80155ee:	400b      	ands	r3, r1
 80155f0:	b2db      	uxtb	r3, r3
 80155f2:	2b00      	cmp	r3, #0
 80155f4:	d001      	beq.n	80155fa <ipcp_cilen+0x142>
 80155f6:	2306      	movs	r3, #6
 80155f8:	e000      	b.n	80155fc <ipcp_cilen+0x144>
 80155fa:	2300      	movs	r3, #0
	    LENCIADDR(go->neg_addr) +
 80155fc:	189a      	adds	r2, r3, r2
	    LENCIDNS(go->req_dns2) +
 80155fe:	693b      	ldr	r3, [r7, #16]
 8015600:	785b      	ldrb	r3, [r3, #1]
 8015602:	2102      	movs	r1, #2
 8015604:	400b      	ands	r3, r1
 8015606:	b2db      	uxtb	r3, r3
 8015608:	2b00      	cmp	r3, #0
 801560a:	d001      	beq.n	8015610 <ipcp_cilen+0x158>
 801560c:	2306      	movs	r3, #6
 801560e:	e000      	b.n	8015612 <ipcp_cilen+0x15a>
 8015610:	2300      	movs	r3, #0
 8015612:	189b      	adds	r3, r3, r2
#if 0 /* UNUSED - WINS */
	    LENCIWINS(go->winsaddr[0]) +
	    LENCIWINS(go->winsaddr[1]) +
#endif /* UNUSED - WINS */
	    0);
}
 8015614:	0018      	movs	r0, r3
 8015616:	46bd      	mov	sp, r7
 8015618:	b006      	add	sp, #24
 801561a:	bd80      	pop	{r7, pc}
 801561c:	0000121c 	.word	0x0000121c
 8015620:	00001204 	.word	0x00001204
 8015624:	0000124c 	.word	0x0000124c

08015628 <ipcp_addci>:

/*
 * ipcp_addci - Add our desired CIs to a packet.
 * Called by fsm_sconfreq, Send Configure Request.
 */
static void ipcp_addci(fsm *f, u_char *ucp, int *lenp) {
 8015628:	b580      	push	{r7, lr}
 801562a:	b08c      	sub	sp, #48	; 0x30
 801562c:	af00      	add	r7, sp, #0
 801562e:	60f8      	str	r0, [r7, #12]
 8015630:	60b9      	str	r1, [r7, #8]
 8015632:	607a      	str	r2, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8015634:	68fb      	ldr	r3, [r7, #12]
 8015636:	681b      	ldr	r3, [r3, #0]
 8015638:	62bb      	str	r3, [r7, #40]	; 0x28
    ipcp_options *go = &pcb->ipcp_gotoptions;
 801563a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801563c:	4ac3      	ldr	r2, [pc, #780]	; (801594c <ipcp_addci+0x324>)
 801563e:	4694      	mov	ip, r2
 8015640:	4463      	add	r3, ip
 8015642:	627b      	str	r3, [r7, #36]	; 0x24
    int len = *lenp;
 8015644:	687b      	ldr	r3, [r7, #4]
 8015646:	681b      	ldr	r3, [r3, #0]
 8015648:	62fb      	str	r3, [r7, #44]	; 0x2c
	} else \
	    addr = 0; \
    }
#endif /* UNUSED - WINS */

    ADDCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs, go->ouraddr,
 801564a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801564c:	781b      	ldrb	r3, [r3, #0]
 801564e:	2201      	movs	r2, #1
 8015650:	4013      	ands	r3, r2
 8015652:	b2db      	uxtb	r3, r3
 8015654:	2b00      	cmp	r3, #0
 8015656:	d160      	bne.n	801571a <ipcp_addci+0xf2>
 8015658:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801565a:	781b      	ldrb	r3, [r3, #0]
 801565c:	2202      	movs	r2, #2
 801565e:	4013      	ands	r3, r2
 8015660:	b2db      	uxtb	r3, r3
 8015662:	2b00      	cmp	r3, #0
 8015664:	d059      	beq.n	801571a <ipcp_addci+0xf2>
 8015666:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015668:	2b09      	cmp	r3, #9
 801566a:	dd51      	ble.n	8015710 <ipcp_addci+0xe8>
 801566c:	68bb      	ldr	r3, [r7, #8]
 801566e:	1c5a      	adds	r2, r3, #1
 8015670:	60ba      	str	r2, [r7, #8]
 8015672:	2201      	movs	r2, #1
 8015674:	701a      	strb	r2, [r3, #0]
 8015676:	68bb      	ldr	r3, [r7, #8]
 8015678:	1c5a      	adds	r2, r3, #1
 801567a:	60ba      	str	r2, [r7, #8]
 801567c:	220a      	movs	r2, #10
 801567e:	701a      	strb	r2, [r3, #0]
 8015680:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015682:	685b      	ldr	r3, [r3, #4]
 8015684:	0018      	movs	r0, r3
 8015686:	f7f1 fad5 	bl	8006c34 <lwip_htonl>
 801568a:	0003      	movs	r3, r0
 801568c:	623b      	str	r3, [r7, #32]
 801568e:	6a3b      	ldr	r3, [r7, #32]
 8015690:	0e19      	lsrs	r1, r3, #24
 8015692:	68bb      	ldr	r3, [r7, #8]
 8015694:	1c5a      	adds	r2, r3, #1
 8015696:	60ba      	str	r2, [r7, #8]
 8015698:	b2ca      	uxtb	r2, r1
 801569a:	701a      	strb	r2, [r3, #0]
 801569c:	6a3b      	ldr	r3, [r7, #32]
 801569e:	0c19      	lsrs	r1, r3, #16
 80156a0:	68bb      	ldr	r3, [r7, #8]
 80156a2:	1c5a      	adds	r2, r3, #1
 80156a4:	60ba      	str	r2, [r7, #8]
 80156a6:	b2ca      	uxtb	r2, r1
 80156a8:	701a      	strb	r2, [r3, #0]
 80156aa:	6a3b      	ldr	r3, [r7, #32]
 80156ac:	0a19      	lsrs	r1, r3, #8
 80156ae:	68bb      	ldr	r3, [r7, #8]
 80156b0:	1c5a      	adds	r2, r3, #1
 80156b2:	60ba      	str	r2, [r7, #8]
 80156b4:	b2ca      	uxtb	r2, r1
 80156b6:	701a      	strb	r2, [r3, #0]
 80156b8:	68bb      	ldr	r3, [r7, #8]
 80156ba:	1c5a      	adds	r2, r3, #1
 80156bc:	60ba      	str	r2, [r7, #8]
 80156be:	6a3a      	ldr	r2, [r7, #32]
 80156c0:	b2d2      	uxtb	r2, r2
 80156c2:	701a      	strb	r2, [r3, #0]
 80156c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80156c6:	689b      	ldr	r3, [r3, #8]
 80156c8:	0018      	movs	r0, r3
 80156ca:	f7f1 fab3 	bl	8006c34 <lwip_htonl>
 80156ce:	0003      	movs	r3, r0
 80156d0:	623b      	str	r3, [r7, #32]
 80156d2:	6a3b      	ldr	r3, [r7, #32]
 80156d4:	0e19      	lsrs	r1, r3, #24
 80156d6:	68bb      	ldr	r3, [r7, #8]
 80156d8:	1c5a      	adds	r2, r3, #1
 80156da:	60ba      	str	r2, [r7, #8]
 80156dc:	b2ca      	uxtb	r2, r1
 80156de:	701a      	strb	r2, [r3, #0]
 80156e0:	6a3b      	ldr	r3, [r7, #32]
 80156e2:	0c19      	lsrs	r1, r3, #16
 80156e4:	68bb      	ldr	r3, [r7, #8]
 80156e6:	1c5a      	adds	r2, r3, #1
 80156e8:	60ba      	str	r2, [r7, #8]
 80156ea:	b2ca      	uxtb	r2, r1
 80156ec:	701a      	strb	r2, [r3, #0]
 80156ee:	6a3b      	ldr	r3, [r7, #32]
 80156f0:	0a19      	lsrs	r1, r3, #8
 80156f2:	68bb      	ldr	r3, [r7, #8]
 80156f4:	1c5a      	adds	r2, r3, #1
 80156f6:	60ba      	str	r2, [r7, #8]
 80156f8:	b2ca      	uxtb	r2, r1
 80156fa:	701a      	strb	r2, [r3, #0]
 80156fc:	68bb      	ldr	r3, [r7, #8]
 80156fe:	1c5a      	adds	r2, r3, #1
 8015700:	60ba      	str	r2, [r7, #8]
 8015702:	6a3a      	ldr	r2, [r7, #32]
 8015704:	b2d2      	uxtb	r2, r2
 8015706:	701a      	strb	r2, [r3, #0]
 8015708:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801570a:	3b0a      	subs	r3, #10
 801570c:	62fb      	str	r3, [r7, #44]	; 0x2c
 801570e:	e004      	b.n	801571a <ipcp_addci+0xf2>
 8015710:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015712:	781a      	ldrb	r2, [r3, #0]
 8015714:	2102      	movs	r1, #2
 8015716:	438a      	bics	r2, r1
 8015718:	701a      	strb	r2, [r3, #0]
	       go->hisaddr);

#if VJ_SUPPORT
    ADDCIVJ(CI_COMPRESSTYPE, go->neg_vj, go->vj_protocol, go->old_vj,
 801571a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801571c:	781b      	ldrb	r3, [r3, #0]
 801571e:	2208      	movs	r2, #8
 8015720:	4013      	ands	r3, r2
 8015722:	b2db      	uxtb	r3, r3
 8015724:	2b00      	cmp	r3, #0
 8015726:	d04a      	beq.n	80157be <ipcp_addci+0x196>
 8015728:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801572a:	781b      	ldrb	r3, [r3, #0]
 801572c:	2210      	movs	r2, #16
 801572e:	4013      	ands	r3, r2
 8015730:	b2db      	uxtb	r3, r3
 8015732:	2b00      	cmp	r3, #0
 8015734:	d001      	beq.n	801573a <ipcp_addci+0x112>
 8015736:	2304      	movs	r3, #4
 8015738:	e000      	b.n	801573c <ipcp_addci+0x114>
 801573a:	2306      	movs	r3, #6
 801573c:	61fb      	str	r3, [r7, #28]
 801573e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8015740:	69fb      	ldr	r3, [r7, #28]
 8015742:	429a      	cmp	r2, r3
 8015744:	db36      	blt.n	80157b4 <ipcp_addci+0x18c>
 8015746:	68bb      	ldr	r3, [r7, #8]
 8015748:	1c5a      	adds	r2, r3, #1
 801574a:	60ba      	str	r2, [r7, #8]
 801574c:	2202      	movs	r2, #2
 801574e:	701a      	strb	r2, [r3, #0]
 8015750:	68bb      	ldr	r3, [r7, #8]
 8015752:	1c5a      	adds	r2, r3, #1
 8015754:	60ba      	str	r2, [r7, #8]
 8015756:	69fa      	ldr	r2, [r7, #28]
 8015758:	b2d2      	uxtb	r2, r2
 801575a:	701a      	strb	r2, [r3, #0]
 801575c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801575e:	8a9b      	ldrh	r3, [r3, #20]
 8015760:	0a1b      	lsrs	r3, r3, #8
 8015762:	b299      	uxth	r1, r3
 8015764:	68bb      	ldr	r3, [r7, #8]
 8015766:	1c5a      	adds	r2, r3, #1
 8015768:	60ba      	str	r2, [r7, #8]
 801576a:	b2ca      	uxtb	r2, r1
 801576c:	701a      	strb	r2, [r3, #0]
 801576e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015770:	8a99      	ldrh	r1, [r3, #20]
 8015772:	68bb      	ldr	r3, [r7, #8]
 8015774:	1c5a      	adds	r2, r3, #1
 8015776:	60ba      	str	r2, [r7, #8]
 8015778:	b2ca      	uxtb	r2, r1
 801577a:	701a      	strb	r2, [r3, #0]
 801577c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801577e:	781b      	ldrb	r3, [r3, #0]
 8015780:	2210      	movs	r2, #16
 8015782:	4013      	ands	r3, r2
 8015784:	b2db      	uxtb	r3, r3
 8015786:	2b00      	cmp	r3, #0
 8015788:	d10f      	bne.n	80157aa <ipcp_addci+0x182>
 801578a:	68bb      	ldr	r3, [r7, #8]
 801578c:	1c5a      	adds	r2, r3, #1
 801578e:	60ba      	str	r2, [r7, #8]
 8015790:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015792:	7d92      	ldrb	r2, [r2, #22]
 8015794:	701a      	strb	r2, [r3, #0]
 8015796:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015798:	781b      	ldrb	r3, [r3, #0]
 801579a:	069b      	lsls	r3, r3, #26
 801579c:	0fdb      	lsrs	r3, r3, #31
 801579e:	b2d9      	uxtb	r1, r3
 80157a0:	68bb      	ldr	r3, [r7, #8]
 80157a2:	1c5a      	adds	r2, r3, #1
 80157a4:	60ba      	str	r2, [r7, #8]
 80157a6:	000a      	movs	r2, r1
 80157a8:	701a      	strb	r2, [r3, #0]
 80157aa:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80157ac:	69fb      	ldr	r3, [r7, #28]
 80157ae:	1ad3      	subs	r3, r2, r3
 80157b0:	62fb      	str	r3, [r7, #44]	; 0x2c
 80157b2:	e004      	b.n	80157be <ipcp_addci+0x196>
 80157b4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80157b6:	781a      	ldrb	r2, [r3, #0]
 80157b8:	2108      	movs	r1, #8
 80157ba:	438a      	bics	r2, r1
 80157bc:	701a      	strb	r2, [r3, #0]
	    go->maxslotindex, go->cflag);
#endif /* VJ_SUPPORT */

    ADDCIADDR(CI_ADDR, go->neg_addr, go->ouraddr);
 80157be:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80157c0:	781b      	ldrb	r3, [r3, #0]
 80157c2:	2201      	movs	r2, #1
 80157c4:	4013      	ands	r3, r2
 80157c6:	b2db      	uxtb	r3, r3
 80157c8:	2b00      	cmp	r3, #0
 80157ca:	d037      	beq.n	801583c <ipcp_addci+0x214>
 80157cc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80157ce:	2b05      	cmp	r3, #5
 80157d0:	dd2f      	ble.n	8015832 <ipcp_addci+0x20a>
 80157d2:	68bb      	ldr	r3, [r7, #8]
 80157d4:	1c5a      	adds	r2, r3, #1
 80157d6:	60ba      	str	r2, [r7, #8]
 80157d8:	2203      	movs	r2, #3
 80157da:	701a      	strb	r2, [r3, #0]
 80157dc:	68bb      	ldr	r3, [r7, #8]
 80157de:	1c5a      	adds	r2, r3, #1
 80157e0:	60ba      	str	r2, [r7, #8]
 80157e2:	2206      	movs	r2, #6
 80157e4:	701a      	strb	r2, [r3, #0]
 80157e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80157e8:	685b      	ldr	r3, [r3, #4]
 80157ea:	0018      	movs	r0, r3
 80157ec:	f7f1 fa22 	bl	8006c34 <lwip_htonl>
 80157f0:	0003      	movs	r3, r0
 80157f2:	61bb      	str	r3, [r7, #24]
 80157f4:	69bb      	ldr	r3, [r7, #24]
 80157f6:	0e19      	lsrs	r1, r3, #24
 80157f8:	68bb      	ldr	r3, [r7, #8]
 80157fa:	1c5a      	adds	r2, r3, #1
 80157fc:	60ba      	str	r2, [r7, #8]
 80157fe:	b2ca      	uxtb	r2, r1
 8015800:	701a      	strb	r2, [r3, #0]
 8015802:	69bb      	ldr	r3, [r7, #24]
 8015804:	0c19      	lsrs	r1, r3, #16
 8015806:	68bb      	ldr	r3, [r7, #8]
 8015808:	1c5a      	adds	r2, r3, #1
 801580a:	60ba      	str	r2, [r7, #8]
 801580c:	b2ca      	uxtb	r2, r1
 801580e:	701a      	strb	r2, [r3, #0]
 8015810:	69bb      	ldr	r3, [r7, #24]
 8015812:	0a19      	lsrs	r1, r3, #8
 8015814:	68bb      	ldr	r3, [r7, #8]
 8015816:	1c5a      	adds	r2, r3, #1
 8015818:	60ba      	str	r2, [r7, #8]
 801581a:	b2ca      	uxtb	r2, r1
 801581c:	701a      	strb	r2, [r3, #0]
 801581e:	68bb      	ldr	r3, [r7, #8]
 8015820:	1c5a      	adds	r2, r3, #1
 8015822:	60ba      	str	r2, [r7, #8]
 8015824:	69ba      	ldr	r2, [r7, #24]
 8015826:	b2d2      	uxtb	r2, r2
 8015828:	701a      	strb	r2, [r3, #0]
 801582a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801582c:	3b06      	subs	r3, #6
 801582e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8015830:	e004      	b.n	801583c <ipcp_addci+0x214>
 8015832:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015834:	781a      	ldrb	r2, [r3, #0]
 8015836:	2101      	movs	r1, #1
 8015838:	438a      	bics	r2, r1
 801583a:	701a      	strb	r2, [r3, #0]

#if LWIP_DNS
    ADDCIDNS(CI_MS_DNS1, go->req_dns1, go->dnsaddr[0]);
 801583c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801583e:	785b      	ldrb	r3, [r3, #1]
 8015840:	2201      	movs	r2, #1
 8015842:	4013      	ands	r3, r2
 8015844:	b2db      	uxtb	r3, r3
 8015846:	2b00      	cmp	r3, #0
 8015848:	d037      	beq.n	80158ba <ipcp_addci+0x292>
 801584a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801584c:	2b05      	cmp	r3, #5
 801584e:	dd2f      	ble.n	80158b0 <ipcp_addci+0x288>
 8015850:	68bb      	ldr	r3, [r7, #8]
 8015852:	1c5a      	adds	r2, r3, #1
 8015854:	60ba      	str	r2, [r7, #8]
 8015856:	2281      	movs	r2, #129	; 0x81
 8015858:	701a      	strb	r2, [r3, #0]
 801585a:	68bb      	ldr	r3, [r7, #8]
 801585c:	1c5a      	adds	r2, r3, #1
 801585e:	60ba      	str	r2, [r7, #8]
 8015860:	2206      	movs	r2, #6
 8015862:	701a      	strb	r2, [r3, #0]
 8015864:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015866:	68db      	ldr	r3, [r3, #12]
 8015868:	0018      	movs	r0, r3
 801586a:	f7f1 f9e3 	bl	8006c34 <lwip_htonl>
 801586e:	0003      	movs	r3, r0
 8015870:	617b      	str	r3, [r7, #20]
 8015872:	697b      	ldr	r3, [r7, #20]
 8015874:	0e19      	lsrs	r1, r3, #24
 8015876:	68bb      	ldr	r3, [r7, #8]
 8015878:	1c5a      	adds	r2, r3, #1
 801587a:	60ba      	str	r2, [r7, #8]
 801587c:	b2ca      	uxtb	r2, r1
 801587e:	701a      	strb	r2, [r3, #0]
 8015880:	697b      	ldr	r3, [r7, #20]
 8015882:	0c19      	lsrs	r1, r3, #16
 8015884:	68bb      	ldr	r3, [r7, #8]
 8015886:	1c5a      	adds	r2, r3, #1
 8015888:	60ba      	str	r2, [r7, #8]
 801588a:	b2ca      	uxtb	r2, r1
 801588c:	701a      	strb	r2, [r3, #0]
 801588e:	697b      	ldr	r3, [r7, #20]
 8015890:	0a19      	lsrs	r1, r3, #8
 8015892:	68bb      	ldr	r3, [r7, #8]
 8015894:	1c5a      	adds	r2, r3, #1
 8015896:	60ba      	str	r2, [r7, #8]
 8015898:	b2ca      	uxtb	r2, r1
 801589a:	701a      	strb	r2, [r3, #0]
 801589c:	68bb      	ldr	r3, [r7, #8]
 801589e:	1c5a      	adds	r2, r3, #1
 80158a0:	60ba      	str	r2, [r7, #8]
 80158a2:	697a      	ldr	r2, [r7, #20]
 80158a4:	b2d2      	uxtb	r2, r2
 80158a6:	701a      	strb	r2, [r3, #0]
 80158a8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80158aa:	3b06      	subs	r3, #6
 80158ac:	62fb      	str	r3, [r7, #44]	; 0x2c
 80158ae:	e004      	b.n	80158ba <ipcp_addci+0x292>
 80158b0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80158b2:	785a      	ldrb	r2, [r3, #1]
 80158b4:	2101      	movs	r1, #1
 80158b6:	438a      	bics	r2, r1
 80158b8:	705a      	strb	r2, [r3, #1]

    ADDCIDNS(CI_MS_DNS2, go->req_dns2, go->dnsaddr[1]);
 80158ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80158bc:	785b      	ldrb	r3, [r3, #1]
 80158be:	2202      	movs	r2, #2
 80158c0:	4013      	ands	r3, r2
 80158c2:	b2db      	uxtb	r3, r3
 80158c4:	2b00      	cmp	r3, #0
 80158c6:	d037      	beq.n	8015938 <ipcp_addci+0x310>
 80158c8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80158ca:	2b05      	cmp	r3, #5
 80158cc:	dd2f      	ble.n	801592e <ipcp_addci+0x306>
 80158ce:	68bb      	ldr	r3, [r7, #8]
 80158d0:	1c5a      	adds	r2, r3, #1
 80158d2:	60ba      	str	r2, [r7, #8]
 80158d4:	2283      	movs	r2, #131	; 0x83
 80158d6:	701a      	strb	r2, [r3, #0]
 80158d8:	68bb      	ldr	r3, [r7, #8]
 80158da:	1c5a      	adds	r2, r3, #1
 80158dc:	60ba      	str	r2, [r7, #8]
 80158de:	2206      	movs	r2, #6
 80158e0:	701a      	strb	r2, [r3, #0]
 80158e2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80158e4:	691b      	ldr	r3, [r3, #16]
 80158e6:	0018      	movs	r0, r3
 80158e8:	f7f1 f9a4 	bl	8006c34 <lwip_htonl>
 80158ec:	0003      	movs	r3, r0
 80158ee:	613b      	str	r3, [r7, #16]
 80158f0:	693b      	ldr	r3, [r7, #16]
 80158f2:	0e19      	lsrs	r1, r3, #24
 80158f4:	68bb      	ldr	r3, [r7, #8]
 80158f6:	1c5a      	adds	r2, r3, #1
 80158f8:	60ba      	str	r2, [r7, #8]
 80158fa:	b2ca      	uxtb	r2, r1
 80158fc:	701a      	strb	r2, [r3, #0]
 80158fe:	693b      	ldr	r3, [r7, #16]
 8015900:	0c19      	lsrs	r1, r3, #16
 8015902:	68bb      	ldr	r3, [r7, #8]
 8015904:	1c5a      	adds	r2, r3, #1
 8015906:	60ba      	str	r2, [r7, #8]
 8015908:	b2ca      	uxtb	r2, r1
 801590a:	701a      	strb	r2, [r3, #0]
 801590c:	693b      	ldr	r3, [r7, #16]
 801590e:	0a19      	lsrs	r1, r3, #8
 8015910:	68bb      	ldr	r3, [r7, #8]
 8015912:	1c5a      	adds	r2, r3, #1
 8015914:	60ba      	str	r2, [r7, #8]
 8015916:	b2ca      	uxtb	r2, r1
 8015918:	701a      	strb	r2, [r3, #0]
 801591a:	68bb      	ldr	r3, [r7, #8]
 801591c:	1c5a      	adds	r2, r3, #1
 801591e:	60ba      	str	r2, [r7, #8]
 8015920:	693a      	ldr	r2, [r7, #16]
 8015922:	b2d2      	uxtb	r2, r2
 8015924:	701a      	strb	r2, [r3, #0]
 8015926:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015928:	3b06      	subs	r3, #6
 801592a:	62fb      	str	r3, [r7, #44]	; 0x2c
 801592c:	e004      	b.n	8015938 <ipcp_addci+0x310>
 801592e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015930:	785a      	ldrb	r2, [r3, #1]
 8015932:	2102      	movs	r1, #2
 8015934:	438a      	bics	r2, r1
 8015936:	705a      	strb	r2, [r3, #1]
    ADDCIWINS(CI_MS_WINS1, go->winsaddr[0]);

    ADDCIWINS(CI_MS_WINS2, go->winsaddr[1]);
#endif /* UNUSED - WINS */
    
    *lenp -= len;
 8015938:	687b      	ldr	r3, [r7, #4]
 801593a:	681a      	ldr	r2, [r3, #0]
 801593c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801593e:	1ad2      	subs	r2, r2, r3
 8015940:	687b      	ldr	r3, [r7, #4]
 8015942:	601a      	str	r2, [r3, #0]
}
 8015944:	46c0      	nop			; (mov r8, r8)
 8015946:	46bd      	mov	sp, r7
 8015948:	b00c      	add	sp, #48	; 0x30
 801594a:	bd80      	pop	{r7, pc}
 801594c:	0000121c 	.word	0x0000121c

08015950 <ipcp_ackci>:
 *
 * Returns:
 *	0 - Ack was bad.
 *	1 - Ack was good.
 */
static int ipcp_ackci(fsm *f, u_char *p, int len) {
 8015950:	b580      	push	{r7, lr}
 8015952:	b08e      	sub	sp, #56	; 0x38
 8015954:	af00      	add	r7, sp, #0
 8015956:	60f8      	str	r0, [r7, #12]
 8015958:	60b9      	str	r1, [r7, #8]
 801595a:	607a      	str	r2, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 801595c:	68fb      	ldr	r3, [r7, #12]
 801595e:	681b      	ldr	r3, [r3, #0]
 8015960:	637b      	str	r3, [r7, #52]	; 0x34
    ipcp_options *go = &pcb->ipcp_gotoptions;
 8015962:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8015964:	4a51      	ldr	r2, [pc, #324]	; (8015aac <ipcp_ackci+0x15c>)
 8015966:	4694      	mov	ip, r2
 8015968:	4463      	add	r3, ip
 801596a:	633b      	str	r3, [r7, #48]	; 0x30
	if (addr != cilong) \
	    goto bad; \
    }
#endif /* UNUSED - WINS */

    ACKCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs, go->ouraddr,
 801596c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801596e:	781b      	ldrb	r3, [r3, #0]
 8015970:	2201      	movs	r2, #1
 8015972:	4013      	ands	r3, r2
 8015974:	b2db      	uxtb	r3, r3
 8015976:	2b00      	cmp	r3, #0
 8015978:	d000      	beq.n	801597c <ipcp_ackci+0x2c>
 801597a:	e086      	b.n	8015a8a <ipcp_ackci+0x13a>
 801597c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801597e:	781b      	ldrb	r3, [r3, #0]
 8015980:	2202      	movs	r2, #2
 8015982:	4013      	ands	r3, r2
 8015984:	b2db      	uxtb	r3, r3
 8015986:	2b00      	cmp	r3, #0
 8015988:	d100      	bne.n	801598c <ipcp_ackci+0x3c>
 801598a:	e07e      	b.n	8015a8a <ipcp_ackci+0x13a>
 801598c:	687b      	ldr	r3, [r7, #4]
 801598e:	3b0a      	subs	r3, #10
 8015990:	607b      	str	r3, [r7, #4]
 8015992:	687b      	ldr	r3, [r7, #4]
 8015994:	2b00      	cmp	r3, #0
 8015996:	da00      	bge.n	801599a <ipcp_ackci+0x4a>
 8015998:	e1f2      	b.n	8015d80 <ipcp_ackci+0x430>
 801599a:	68bb      	ldr	r3, [r7, #8]
 801599c:	1c5a      	adds	r2, r3, #1
 801599e:	60ba      	str	r2, [r7, #8]
 80159a0:	781a      	ldrb	r2, [r3, #0]
 80159a2:	212e      	movs	r1, #46	; 0x2e
 80159a4:	187b      	adds	r3, r7, r1
 80159a6:	801a      	strh	r2, [r3, #0]
 80159a8:	68bb      	ldr	r3, [r7, #8]
 80159aa:	1c5a      	adds	r2, r3, #1
 80159ac:	60ba      	str	r2, [r7, #8]
 80159ae:	781a      	ldrb	r2, [r3, #0]
 80159b0:	202c      	movs	r0, #44	; 0x2c
 80159b2:	183b      	adds	r3, r7, r0
 80159b4:	801a      	strh	r2, [r3, #0]
 80159b6:	183b      	adds	r3, r7, r0
 80159b8:	881b      	ldrh	r3, [r3, #0]
 80159ba:	2b0a      	cmp	r3, #10
 80159bc:	d000      	beq.n	80159c0 <ipcp_ackci+0x70>
 80159be:	e1e1      	b.n	8015d84 <ipcp_ackci+0x434>
 80159c0:	187b      	adds	r3, r7, r1
 80159c2:	881b      	ldrh	r3, [r3, #0]
 80159c4:	2b01      	cmp	r3, #1
 80159c6:	d000      	beq.n	80159ca <ipcp_ackci+0x7a>
 80159c8:	e1dc      	b.n	8015d84 <ipcp_ackci+0x434>
 80159ca:	68bb      	ldr	r3, [r7, #8]
 80159cc:	1c5a      	adds	r2, r3, #1
 80159ce:	60ba      	str	r2, [r7, #8]
 80159d0:	781b      	ldrb	r3, [r3, #0]
 80159d2:	021b      	lsls	r3, r3, #8
 80159d4:	62bb      	str	r3, [r7, #40]	; 0x28
 80159d6:	68bb      	ldr	r3, [r7, #8]
 80159d8:	1c5a      	adds	r2, r3, #1
 80159da:	60ba      	str	r2, [r7, #8]
 80159dc:	781b      	ldrb	r3, [r3, #0]
 80159de:	001a      	movs	r2, r3
 80159e0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80159e2:	4313      	orrs	r3, r2
 80159e4:	62bb      	str	r3, [r7, #40]	; 0x28
 80159e6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80159e8:	021b      	lsls	r3, r3, #8
 80159ea:	62bb      	str	r3, [r7, #40]	; 0x28
 80159ec:	68bb      	ldr	r3, [r7, #8]
 80159ee:	1c5a      	adds	r2, r3, #1
 80159f0:	60ba      	str	r2, [r7, #8]
 80159f2:	781b      	ldrb	r3, [r3, #0]
 80159f4:	001a      	movs	r2, r3
 80159f6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80159f8:	4313      	orrs	r3, r2
 80159fa:	62bb      	str	r3, [r7, #40]	; 0x28
 80159fc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80159fe:	021b      	lsls	r3, r3, #8
 8015a00:	62bb      	str	r3, [r7, #40]	; 0x28
 8015a02:	68bb      	ldr	r3, [r7, #8]
 8015a04:	1c5a      	adds	r2, r3, #1
 8015a06:	60ba      	str	r2, [r7, #8]
 8015a08:	781b      	ldrb	r3, [r3, #0]
 8015a0a:	001a      	movs	r2, r3
 8015a0c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015a0e:	4313      	orrs	r3, r2
 8015a10:	62bb      	str	r3, [r7, #40]	; 0x28
 8015a12:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015a14:	0018      	movs	r0, r3
 8015a16:	f7f1 f90d 	bl	8006c34 <lwip_htonl>
 8015a1a:	0003      	movs	r3, r0
 8015a1c:	627b      	str	r3, [r7, #36]	; 0x24
 8015a1e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015a20:	685b      	ldr	r3, [r3, #4]
 8015a22:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015a24:	429a      	cmp	r2, r3
 8015a26:	d000      	beq.n	8015a2a <ipcp_ackci+0xda>
 8015a28:	e1ae      	b.n	8015d88 <ipcp_ackci+0x438>
 8015a2a:	68bb      	ldr	r3, [r7, #8]
 8015a2c:	1c5a      	adds	r2, r3, #1
 8015a2e:	60ba      	str	r2, [r7, #8]
 8015a30:	781b      	ldrb	r3, [r3, #0]
 8015a32:	021b      	lsls	r3, r3, #8
 8015a34:	62bb      	str	r3, [r7, #40]	; 0x28
 8015a36:	68bb      	ldr	r3, [r7, #8]
 8015a38:	1c5a      	adds	r2, r3, #1
 8015a3a:	60ba      	str	r2, [r7, #8]
 8015a3c:	781b      	ldrb	r3, [r3, #0]
 8015a3e:	001a      	movs	r2, r3
 8015a40:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015a42:	4313      	orrs	r3, r2
 8015a44:	62bb      	str	r3, [r7, #40]	; 0x28
 8015a46:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015a48:	021b      	lsls	r3, r3, #8
 8015a4a:	62bb      	str	r3, [r7, #40]	; 0x28
 8015a4c:	68bb      	ldr	r3, [r7, #8]
 8015a4e:	1c5a      	adds	r2, r3, #1
 8015a50:	60ba      	str	r2, [r7, #8]
 8015a52:	781b      	ldrb	r3, [r3, #0]
 8015a54:	001a      	movs	r2, r3
 8015a56:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015a58:	4313      	orrs	r3, r2
 8015a5a:	62bb      	str	r3, [r7, #40]	; 0x28
 8015a5c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015a5e:	021b      	lsls	r3, r3, #8
 8015a60:	62bb      	str	r3, [r7, #40]	; 0x28
 8015a62:	68bb      	ldr	r3, [r7, #8]
 8015a64:	1c5a      	adds	r2, r3, #1
 8015a66:	60ba      	str	r2, [r7, #8]
 8015a68:	781b      	ldrb	r3, [r3, #0]
 8015a6a:	001a      	movs	r2, r3
 8015a6c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015a6e:	4313      	orrs	r3, r2
 8015a70:	62bb      	str	r3, [r7, #40]	; 0x28
 8015a72:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015a74:	0018      	movs	r0, r3
 8015a76:	f7f1 f8dd 	bl	8006c34 <lwip_htonl>
 8015a7a:	0003      	movs	r3, r0
 8015a7c:	627b      	str	r3, [r7, #36]	; 0x24
 8015a7e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015a80:	689b      	ldr	r3, [r3, #8]
 8015a82:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015a84:	429a      	cmp	r2, r3
 8015a86:	d000      	beq.n	8015a8a <ipcp_ackci+0x13a>
 8015a88:	e180      	b.n	8015d8c <ipcp_ackci+0x43c>
	       go->hisaddr);

#if VJ_SUPPORT
    ACKCIVJ(CI_COMPRESSTYPE, go->neg_vj, go->vj_protocol, go->old_vj,
 8015a8a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015a8c:	781b      	ldrb	r3, [r3, #0]
 8015a8e:	2208      	movs	r2, #8
 8015a90:	4013      	ands	r3, r2
 8015a92:	b2db      	uxtb	r3, r3
 8015a94:	2b00      	cmp	r3, #0
 8015a96:	d100      	bne.n	8015a9a <ipcp_ackci+0x14a>
 8015a98:	e06e      	b.n	8015b78 <ipcp_ackci+0x228>
 8015a9a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015a9c:	781b      	ldrb	r3, [r3, #0]
 8015a9e:	2210      	movs	r2, #16
 8015aa0:	4013      	ands	r3, r2
 8015aa2:	b2db      	uxtb	r3, r3
 8015aa4:	2b00      	cmp	r3, #0
 8015aa6:	d003      	beq.n	8015ab0 <ipcp_ackci+0x160>
 8015aa8:	2304      	movs	r3, #4
 8015aaa:	e002      	b.n	8015ab2 <ipcp_ackci+0x162>
 8015aac:	0000121c 	.word	0x0000121c
 8015ab0:	2306      	movs	r3, #6
 8015ab2:	623b      	str	r3, [r7, #32]
 8015ab4:	687a      	ldr	r2, [r7, #4]
 8015ab6:	6a3b      	ldr	r3, [r7, #32]
 8015ab8:	1ad3      	subs	r3, r2, r3
 8015aba:	607b      	str	r3, [r7, #4]
 8015abc:	687b      	ldr	r3, [r7, #4]
 8015abe:	2b00      	cmp	r3, #0
 8015ac0:	da00      	bge.n	8015ac4 <ipcp_ackci+0x174>
 8015ac2:	e165      	b.n	8015d90 <ipcp_ackci+0x440>
 8015ac4:	68bb      	ldr	r3, [r7, #8]
 8015ac6:	1c5a      	adds	r2, r3, #1
 8015ac8:	60ba      	str	r2, [r7, #8]
 8015aca:	781a      	ldrb	r2, [r3, #0]
 8015acc:	212e      	movs	r1, #46	; 0x2e
 8015ace:	187b      	adds	r3, r7, r1
 8015ad0:	801a      	strh	r2, [r3, #0]
 8015ad2:	68bb      	ldr	r3, [r7, #8]
 8015ad4:	1c5a      	adds	r2, r3, #1
 8015ad6:	60ba      	str	r2, [r7, #8]
 8015ad8:	781a      	ldrb	r2, [r3, #0]
 8015ada:	202c      	movs	r0, #44	; 0x2c
 8015adc:	183b      	adds	r3, r7, r0
 8015ade:	801a      	strh	r2, [r3, #0]
 8015ae0:	183b      	adds	r3, r7, r0
 8015ae2:	881b      	ldrh	r3, [r3, #0]
 8015ae4:	6a3a      	ldr	r2, [r7, #32]
 8015ae6:	429a      	cmp	r2, r3
 8015ae8:	d000      	beq.n	8015aec <ipcp_ackci+0x19c>
 8015aea:	e153      	b.n	8015d94 <ipcp_ackci+0x444>
 8015aec:	187b      	adds	r3, r7, r1
 8015aee:	881b      	ldrh	r3, [r3, #0]
 8015af0:	2b02      	cmp	r3, #2
 8015af2:	d000      	beq.n	8015af6 <ipcp_ackci+0x1a6>
 8015af4:	e14e      	b.n	8015d94 <ipcp_ackci+0x444>
 8015af6:	68bb      	ldr	r3, [r7, #8]
 8015af8:	1c5a      	adds	r2, r3, #1
 8015afa:	60ba      	str	r2, [r7, #8]
 8015afc:	781b      	ldrb	r3, [r3, #0]
 8015afe:	b29a      	uxth	r2, r3
 8015b00:	201e      	movs	r0, #30
 8015b02:	183b      	adds	r3, r7, r0
 8015b04:	0212      	lsls	r2, r2, #8
 8015b06:	801a      	strh	r2, [r3, #0]
 8015b08:	68bb      	ldr	r3, [r7, #8]
 8015b0a:	1c5a      	adds	r2, r3, #1
 8015b0c:	60ba      	str	r2, [r7, #8]
 8015b0e:	781b      	ldrb	r3, [r3, #0]
 8015b10:	b299      	uxth	r1, r3
 8015b12:	183b      	adds	r3, r7, r0
 8015b14:	183a      	adds	r2, r7, r0
 8015b16:	8812      	ldrh	r2, [r2, #0]
 8015b18:	430a      	orrs	r2, r1
 8015b1a:	801a      	strh	r2, [r3, #0]
 8015b1c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015b1e:	8a9b      	ldrh	r3, [r3, #20]
 8015b20:	183a      	adds	r2, r7, r0
 8015b22:	8812      	ldrh	r2, [r2, #0]
 8015b24:	429a      	cmp	r2, r3
 8015b26:	d000      	beq.n	8015b2a <ipcp_ackci+0x1da>
 8015b28:	e136      	b.n	8015d98 <ipcp_ackci+0x448>
 8015b2a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015b2c:	781b      	ldrb	r3, [r3, #0]
 8015b2e:	2210      	movs	r2, #16
 8015b30:	4013      	ands	r3, r2
 8015b32:	b2db      	uxtb	r3, r3
 8015b34:	2b00      	cmp	r3, #0
 8015b36:	d11f      	bne.n	8015b78 <ipcp_ackci+0x228>
 8015b38:	68bb      	ldr	r3, [r7, #8]
 8015b3a:	1c5a      	adds	r2, r3, #1
 8015b3c:	60ba      	str	r2, [r7, #8]
 8015b3e:	211d      	movs	r1, #29
 8015b40:	187a      	adds	r2, r7, r1
 8015b42:	781b      	ldrb	r3, [r3, #0]
 8015b44:	7013      	strb	r3, [r2, #0]
 8015b46:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015b48:	7d9b      	ldrb	r3, [r3, #22]
 8015b4a:	187a      	adds	r2, r7, r1
 8015b4c:	7812      	ldrb	r2, [r2, #0]
 8015b4e:	429a      	cmp	r2, r3
 8015b50:	d000      	beq.n	8015b54 <ipcp_ackci+0x204>
 8015b52:	e123      	b.n	8015d9c <ipcp_ackci+0x44c>
 8015b54:	68bb      	ldr	r3, [r7, #8]
 8015b56:	1c5a      	adds	r2, r3, #1
 8015b58:	60ba      	str	r2, [r7, #8]
 8015b5a:	211c      	movs	r1, #28
 8015b5c:	187a      	adds	r2, r7, r1
 8015b5e:	781b      	ldrb	r3, [r3, #0]
 8015b60:	7013      	strb	r3, [r2, #0]
 8015b62:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015b64:	781b      	ldrb	r3, [r3, #0]
 8015b66:	069b      	lsls	r3, r3, #26
 8015b68:	0fdb      	lsrs	r3, r3, #31
 8015b6a:	b2db      	uxtb	r3, r3
 8015b6c:	001a      	movs	r2, r3
 8015b6e:	187b      	adds	r3, r7, r1
 8015b70:	781b      	ldrb	r3, [r3, #0]
 8015b72:	4293      	cmp	r3, r2
 8015b74:	d000      	beq.n	8015b78 <ipcp_ackci+0x228>
 8015b76:	e113      	b.n	8015da0 <ipcp_ackci+0x450>
	    go->maxslotindex, go->cflag);
#endif /* VJ_SUPPORT */

    ACKCIADDR(CI_ADDR, go->neg_addr, go->ouraddr);
 8015b78:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015b7a:	781b      	ldrb	r3, [r3, #0]
 8015b7c:	2201      	movs	r2, #1
 8015b7e:	4013      	ands	r3, r2
 8015b80:	b2db      	uxtb	r3, r3
 8015b82:	2b00      	cmp	r3, #0
 8015b84:	d04e      	beq.n	8015c24 <ipcp_ackci+0x2d4>
 8015b86:	687b      	ldr	r3, [r7, #4]
 8015b88:	3b06      	subs	r3, #6
 8015b8a:	607b      	str	r3, [r7, #4]
 8015b8c:	687b      	ldr	r3, [r7, #4]
 8015b8e:	2b00      	cmp	r3, #0
 8015b90:	da00      	bge.n	8015b94 <ipcp_ackci+0x244>
 8015b92:	e107      	b.n	8015da4 <ipcp_ackci+0x454>
 8015b94:	68bb      	ldr	r3, [r7, #8]
 8015b96:	1c5a      	adds	r2, r3, #1
 8015b98:	60ba      	str	r2, [r7, #8]
 8015b9a:	781a      	ldrb	r2, [r3, #0]
 8015b9c:	212e      	movs	r1, #46	; 0x2e
 8015b9e:	187b      	adds	r3, r7, r1
 8015ba0:	801a      	strh	r2, [r3, #0]
 8015ba2:	68bb      	ldr	r3, [r7, #8]
 8015ba4:	1c5a      	adds	r2, r3, #1
 8015ba6:	60ba      	str	r2, [r7, #8]
 8015ba8:	781a      	ldrb	r2, [r3, #0]
 8015baa:	202c      	movs	r0, #44	; 0x2c
 8015bac:	183b      	adds	r3, r7, r0
 8015bae:	801a      	strh	r2, [r3, #0]
 8015bb0:	183b      	adds	r3, r7, r0
 8015bb2:	881b      	ldrh	r3, [r3, #0]
 8015bb4:	2b06      	cmp	r3, #6
 8015bb6:	d000      	beq.n	8015bba <ipcp_ackci+0x26a>
 8015bb8:	e0f6      	b.n	8015da8 <ipcp_ackci+0x458>
 8015bba:	187b      	adds	r3, r7, r1
 8015bbc:	881b      	ldrh	r3, [r3, #0]
 8015bbe:	2b03      	cmp	r3, #3
 8015bc0:	d000      	beq.n	8015bc4 <ipcp_ackci+0x274>
 8015bc2:	e0f1      	b.n	8015da8 <ipcp_ackci+0x458>
 8015bc4:	68bb      	ldr	r3, [r7, #8]
 8015bc6:	1c5a      	adds	r2, r3, #1
 8015bc8:	60ba      	str	r2, [r7, #8]
 8015bca:	781b      	ldrb	r3, [r3, #0]
 8015bcc:	021b      	lsls	r3, r3, #8
 8015bce:	61bb      	str	r3, [r7, #24]
 8015bd0:	68bb      	ldr	r3, [r7, #8]
 8015bd2:	1c5a      	adds	r2, r3, #1
 8015bd4:	60ba      	str	r2, [r7, #8]
 8015bd6:	781b      	ldrb	r3, [r3, #0]
 8015bd8:	001a      	movs	r2, r3
 8015bda:	69bb      	ldr	r3, [r7, #24]
 8015bdc:	4313      	orrs	r3, r2
 8015bde:	61bb      	str	r3, [r7, #24]
 8015be0:	69bb      	ldr	r3, [r7, #24]
 8015be2:	021b      	lsls	r3, r3, #8
 8015be4:	61bb      	str	r3, [r7, #24]
 8015be6:	68bb      	ldr	r3, [r7, #8]
 8015be8:	1c5a      	adds	r2, r3, #1
 8015bea:	60ba      	str	r2, [r7, #8]
 8015bec:	781b      	ldrb	r3, [r3, #0]
 8015bee:	001a      	movs	r2, r3
 8015bf0:	69bb      	ldr	r3, [r7, #24]
 8015bf2:	4313      	orrs	r3, r2
 8015bf4:	61bb      	str	r3, [r7, #24]
 8015bf6:	69bb      	ldr	r3, [r7, #24]
 8015bf8:	021b      	lsls	r3, r3, #8
 8015bfa:	61bb      	str	r3, [r7, #24]
 8015bfc:	68bb      	ldr	r3, [r7, #8]
 8015bfe:	1c5a      	adds	r2, r3, #1
 8015c00:	60ba      	str	r2, [r7, #8]
 8015c02:	781b      	ldrb	r3, [r3, #0]
 8015c04:	001a      	movs	r2, r3
 8015c06:	69bb      	ldr	r3, [r7, #24]
 8015c08:	4313      	orrs	r3, r2
 8015c0a:	61bb      	str	r3, [r7, #24]
 8015c0c:	69bb      	ldr	r3, [r7, #24]
 8015c0e:	0018      	movs	r0, r3
 8015c10:	f7f1 f810 	bl	8006c34 <lwip_htonl>
 8015c14:	0003      	movs	r3, r0
 8015c16:	627b      	str	r3, [r7, #36]	; 0x24
 8015c18:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015c1a:	685b      	ldr	r3, [r3, #4]
 8015c1c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015c1e:	429a      	cmp	r2, r3
 8015c20:	d000      	beq.n	8015c24 <ipcp_ackci+0x2d4>
 8015c22:	e0c3      	b.n	8015dac <ipcp_ackci+0x45c>

#if LWIP_DNS
    ACKCIDNS(CI_MS_DNS1, go->req_dns1, go->dnsaddr[0]);
 8015c24:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015c26:	785b      	ldrb	r3, [r3, #1]
 8015c28:	2201      	movs	r2, #1
 8015c2a:	4013      	ands	r3, r2
 8015c2c:	b2db      	uxtb	r3, r3
 8015c2e:	2b00      	cmp	r3, #0
 8015c30:	d04e      	beq.n	8015cd0 <ipcp_ackci+0x380>
 8015c32:	687b      	ldr	r3, [r7, #4]
 8015c34:	3b06      	subs	r3, #6
 8015c36:	607b      	str	r3, [r7, #4]
 8015c38:	687b      	ldr	r3, [r7, #4]
 8015c3a:	2b00      	cmp	r3, #0
 8015c3c:	da00      	bge.n	8015c40 <ipcp_ackci+0x2f0>
 8015c3e:	e0b7      	b.n	8015db0 <ipcp_ackci+0x460>
 8015c40:	68bb      	ldr	r3, [r7, #8]
 8015c42:	1c5a      	adds	r2, r3, #1
 8015c44:	60ba      	str	r2, [r7, #8]
 8015c46:	781a      	ldrb	r2, [r3, #0]
 8015c48:	212e      	movs	r1, #46	; 0x2e
 8015c4a:	187b      	adds	r3, r7, r1
 8015c4c:	801a      	strh	r2, [r3, #0]
 8015c4e:	68bb      	ldr	r3, [r7, #8]
 8015c50:	1c5a      	adds	r2, r3, #1
 8015c52:	60ba      	str	r2, [r7, #8]
 8015c54:	781a      	ldrb	r2, [r3, #0]
 8015c56:	202c      	movs	r0, #44	; 0x2c
 8015c58:	183b      	adds	r3, r7, r0
 8015c5a:	801a      	strh	r2, [r3, #0]
 8015c5c:	183b      	adds	r3, r7, r0
 8015c5e:	881b      	ldrh	r3, [r3, #0]
 8015c60:	2b06      	cmp	r3, #6
 8015c62:	d000      	beq.n	8015c66 <ipcp_ackci+0x316>
 8015c64:	e0a6      	b.n	8015db4 <ipcp_ackci+0x464>
 8015c66:	187b      	adds	r3, r7, r1
 8015c68:	881b      	ldrh	r3, [r3, #0]
 8015c6a:	2b81      	cmp	r3, #129	; 0x81
 8015c6c:	d000      	beq.n	8015c70 <ipcp_ackci+0x320>
 8015c6e:	e0a1      	b.n	8015db4 <ipcp_ackci+0x464>
 8015c70:	68bb      	ldr	r3, [r7, #8]
 8015c72:	1c5a      	adds	r2, r3, #1
 8015c74:	60ba      	str	r2, [r7, #8]
 8015c76:	781b      	ldrb	r3, [r3, #0]
 8015c78:	021b      	lsls	r3, r3, #8
 8015c7a:	617b      	str	r3, [r7, #20]
 8015c7c:	68bb      	ldr	r3, [r7, #8]
 8015c7e:	1c5a      	adds	r2, r3, #1
 8015c80:	60ba      	str	r2, [r7, #8]
 8015c82:	781b      	ldrb	r3, [r3, #0]
 8015c84:	001a      	movs	r2, r3
 8015c86:	697b      	ldr	r3, [r7, #20]
 8015c88:	4313      	orrs	r3, r2
 8015c8a:	617b      	str	r3, [r7, #20]
 8015c8c:	697b      	ldr	r3, [r7, #20]
 8015c8e:	021b      	lsls	r3, r3, #8
 8015c90:	617b      	str	r3, [r7, #20]
 8015c92:	68bb      	ldr	r3, [r7, #8]
 8015c94:	1c5a      	adds	r2, r3, #1
 8015c96:	60ba      	str	r2, [r7, #8]
 8015c98:	781b      	ldrb	r3, [r3, #0]
 8015c9a:	001a      	movs	r2, r3
 8015c9c:	697b      	ldr	r3, [r7, #20]
 8015c9e:	4313      	orrs	r3, r2
 8015ca0:	617b      	str	r3, [r7, #20]
 8015ca2:	697b      	ldr	r3, [r7, #20]
 8015ca4:	021b      	lsls	r3, r3, #8
 8015ca6:	617b      	str	r3, [r7, #20]
 8015ca8:	68bb      	ldr	r3, [r7, #8]
 8015caa:	1c5a      	adds	r2, r3, #1
 8015cac:	60ba      	str	r2, [r7, #8]
 8015cae:	781b      	ldrb	r3, [r3, #0]
 8015cb0:	001a      	movs	r2, r3
 8015cb2:	697b      	ldr	r3, [r7, #20]
 8015cb4:	4313      	orrs	r3, r2
 8015cb6:	617b      	str	r3, [r7, #20]
 8015cb8:	697b      	ldr	r3, [r7, #20]
 8015cba:	0018      	movs	r0, r3
 8015cbc:	f7f0 ffba 	bl	8006c34 <lwip_htonl>
 8015cc0:	0003      	movs	r3, r0
 8015cc2:	627b      	str	r3, [r7, #36]	; 0x24
 8015cc4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015cc6:	68db      	ldr	r3, [r3, #12]
 8015cc8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015cca:	429a      	cmp	r2, r3
 8015ccc:	d000      	beq.n	8015cd0 <ipcp_ackci+0x380>
 8015cce:	e073      	b.n	8015db8 <ipcp_ackci+0x468>

    ACKCIDNS(CI_MS_DNS2, go->req_dns2, go->dnsaddr[1]);
 8015cd0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015cd2:	785b      	ldrb	r3, [r3, #1]
 8015cd4:	2202      	movs	r2, #2
 8015cd6:	4013      	ands	r3, r2
 8015cd8:	b2db      	uxtb	r3, r3
 8015cda:	2b00      	cmp	r3, #0
 8015cdc:	d04b      	beq.n	8015d76 <ipcp_ackci+0x426>
 8015cde:	687b      	ldr	r3, [r7, #4]
 8015ce0:	3b06      	subs	r3, #6
 8015ce2:	607b      	str	r3, [r7, #4]
 8015ce4:	687b      	ldr	r3, [r7, #4]
 8015ce6:	2b00      	cmp	r3, #0
 8015ce8:	da00      	bge.n	8015cec <ipcp_ackci+0x39c>
 8015cea:	e067      	b.n	8015dbc <ipcp_ackci+0x46c>
 8015cec:	68bb      	ldr	r3, [r7, #8]
 8015cee:	1c5a      	adds	r2, r3, #1
 8015cf0:	60ba      	str	r2, [r7, #8]
 8015cf2:	781a      	ldrb	r2, [r3, #0]
 8015cf4:	212e      	movs	r1, #46	; 0x2e
 8015cf6:	187b      	adds	r3, r7, r1
 8015cf8:	801a      	strh	r2, [r3, #0]
 8015cfa:	68bb      	ldr	r3, [r7, #8]
 8015cfc:	1c5a      	adds	r2, r3, #1
 8015cfe:	60ba      	str	r2, [r7, #8]
 8015d00:	781a      	ldrb	r2, [r3, #0]
 8015d02:	202c      	movs	r0, #44	; 0x2c
 8015d04:	183b      	adds	r3, r7, r0
 8015d06:	801a      	strh	r2, [r3, #0]
 8015d08:	183b      	adds	r3, r7, r0
 8015d0a:	881b      	ldrh	r3, [r3, #0]
 8015d0c:	2b06      	cmp	r3, #6
 8015d0e:	d157      	bne.n	8015dc0 <ipcp_ackci+0x470>
 8015d10:	187b      	adds	r3, r7, r1
 8015d12:	881b      	ldrh	r3, [r3, #0]
 8015d14:	2b83      	cmp	r3, #131	; 0x83
 8015d16:	d153      	bne.n	8015dc0 <ipcp_ackci+0x470>
 8015d18:	68bb      	ldr	r3, [r7, #8]
 8015d1a:	1c5a      	adds	r2, r3, #1
 8015d1c:	60ba      	str	r2, [r7, #8]
 8015d1e:	781b      	ldrb	r3, [r3, #0]
 8015d20:	021b      	lsls	r3, r3, #8
 8015d22:	613b      	str	r3, [r7, #16]
 8015d24:	68bb      	ldr	r3, [r7, #8]
 8015d26:	1c5a      	adds	r2, r3, #1
 8015d28:	60ba      	str	r2, [r7, #8]
 8015d2a:	781b      	ldrb	r3, [r3, #0]
 8015d2c:	001a      	movs	r2, r3
 8015d2e:	693b      	ldr	r3, [r7, #16]
 8015d30:	4313      	orrs	r3, r2
 8015d32:	613b      	str	r3, [r7, #16]
 8015d34:	693b      	ldr	r3, [r7, #16]
 8015d36:	021b      	lsls	r3, r3, #8
 8015d38:	613b      	str	r3, [r7, #16]
 8015d3a:	68bb      	ldr	r3, [r7, #8]
 8015d3c:	1c5a      	adds	r2, r3, #1
 8015d3e:	60ba      	str	r2, [r7, #8]
 8015d40:	781b      	ldrb	r3, [r3, #0]
 8015d42:	001a      	movs	r2, r3
 8015d44:	693b      	ldr	r3, [r7, #16]
 8015d46:	4313      	orrs	r3, r2
 8015d48:	613b      	str	r3, [r7, #16]
 8015d4a:	693b      	ldr	r3, [r7, #16]
 8015d4c:	021b      	lsls	r3, r3, #8
 8015d4e:	613b      	str	r3, [r7, #16]
 8015d50:	68bb      	ldr	r3, [r7, #8]
 8015d52:	1c5a      	adds	r2, r3, #1
 8015d54:	60ba      	str	r2, [r7, #8]
 8015d56:	781b      	ldrb	r3, [r3, #0]
 8015d58:	001a      	movs	r2, r3
 8015d5a:	693b      	ldr	r3, [r7, #16]
 8015d5c:	4313      	orrs	r3, r2
 8015d5e:	613b      	str	r3, [r7, #16]
 8015d60:	693b      	ldr	r3, [r7, #16]
 8015d62:	0018      	movs	r0, r3
 8015d64:	f7f0 ff66 	bl	8006c34 <lwip_htonl>
 8015d68:	0003      	movs	r3, r0
 8015d6a:	627b      	str	r3, [r7, #36]	; 0x24
 8015d6c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015d6e:	691b      	ldr	r3, [r3, #16]
 8015d70:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015d72:	429a      	cmp	r2, r3
 8015d74:	d126      	bne.n	8015dc4 <ipcp_ackci+0x474>
#endif /* UNUSED - WINS */

    /*
     * If there are any remaining CIs, then this packet is bad.
     */
    if (len != 0)
 8015d76:	687b      	ldr	r3, [r7, #4]
 8015d78:	2b00      	cmp	r3, #0
 8015d7a:	d125      	bne.n	8015dc8 <ipcp_ackci+0x478>
	goto bad;
    return (1);
 8015d7c:	2301      	movs	r3, #1
 8015d7e:	e025      	b.n	8015dcc <ipcp_ackci+0x47c>
    ACKCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs, go->ouraddr,
 8015d80:	46c0      	nop			; (mov r8, r8)
 8015d82:	e022      	b.n	8015dca <ipcp_ackci+0x47a>
 8015d84:	46c0      	nop			; (mov r8, r8)
 8015d86:	e020      	b.n	8015dca <ipcp_ackci+0x47a>
 8015d88:	46c0      	nop			; (mov r8, r8)
 8015d8a:	e01e      	b.n	8015dca <ipcp_ackci+0x47a>
 8015d8c:	46c0      	nop			; (mov r8, r8)
 8015d8e:	e01c      	b.n	8015dca <ipcp_ackci+0x47a>
    ACKCIVJ(CI_COMPRESSTYPE, go->neg_vj, go->vj_protocol, go->old_vj,
 8015d90:	46c0      	nop			; (mov r8, r8)
 8015d92:	e01a      	b.n	8015dca <ipcp_ackci+0x47a>
 8015d94:	46c0      	nop			; (mov r8, r8)
 8015d96:	e018      	b.n	8015dca <ipcp_ackci+0x47a>
 8015d98:	46c0      	nop			; (mov r8, r8)
 8015d9a:	e016      	b.n	8015dca <ipcp_ackci+0x47a>
 8015d9c:	46c0      	nop			; (mov r8, r8)
 8015d9e:	e014      	b.n	8015dca <ipcp_ackci+0x47a>
 8015da0:	46c0      	nop			; (mov r8, r8)
 8015da2:	e012      	b.n	8015dca <ipcp_ackci+0x47a>
    ACKCIADDR(CI_ADDR, go->neg_addr, go->ouraddr);
 8015da4:	46c0      	nop			; (mov r8, r8)
 8015da6:	e010      	b.n	8015dca <ipcp_ackci+0x47a>
 8015da8:	46c0      	nop			; (mov r8, r8)
 8015daa:	e00e      	b.n	8015dca <ipcp_ackci+0x47a>
 8015dac:	46c0      	nop			; (mov r8, r8)
 8015dae:	e00c      	b.n	8015dca <ipcp_ackci+0x47a>
    ACKCIDNS(CI_MS_DNS1, go->req_dns1, go->dnsaddr[0]);
 8015db0:	46c0      	nop			; (mov r8, r8)
 8015db2:	e00a      	b.n	8015dca <ipcp_ackci+0x47a>
 8015db4:	46c0      	nop			; (mov r8, r8)
 8015db6:	e008      	b.n	8015dca <ipcp_ackci+0x47a>
 8015db8:	46c0      	nop			; (mov r8, r8)
 8015dba:	e006      	b.n	8015dca <ipcp_ackci+0x47a>
    ACKCIDNS(CI_MS_DNS2, go->req_dns2, go->dnsaddr[1]);
 8015dbc:	46c0      	nop			; (mov r8, r8)
 8015dbe:	e004      	b.n	8015dca <ipcp_ackci+0x47a>
 8015dc0:	46c0      	nop			; (mov r8, r8)
 8015dc2:	e002      	b.n	8015dca <ipcp_ackci+0x47a>
 8015dc4:	46c0      	nop			; (mov r8, r8)
 8015dc6:	e000      	b.n	8015dca <ipcp_ackci+0x47a>
	goto bad;
 8015dc8:	46c0      	nop			; (mov r8, r8)

bad:
    IPCPDEBUG(("ipcp_ackci: received bad Ack!"));
    return (0);
 8015dca:	2300      	movs	r3, #0
}
 8015dcc:	0018      	movs	r0, r3
 8015dce:	46bd      	mov	sp, r7
 8015dd0:	b00e      	add	sp, #56	; 0x38
 8015dd2:	bd80      	pop	{r7, pc}

08015dd4 <ipcp_nakci>:
 *
 * Returns:
 *	0 - Nak was bad.
 *	1 - Nak was good.
 */
static int ipcp_nakci(fsm *f, u_char *p, int len, int treat_as_reject) {
 8015dd4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8015dd6:	b09b      	sub	sp, #108	; 0x6c
 8015dd8:	af00      	add	r7, sp, #0
 8015dda:	60f8      	str	r0, [r7, #12]
 8015ddc:	60b9      	str	r1, [r7, #8]
 8015dde:	607a      	str	r2, [r7, #4]
 8015de0:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 8015de2:	68fb      	ldr	r3, [r7, #12]
 8015de4:	681b      	ldr	r3, [r3, #0]
 8015de6:	667b      	str	r3, [r7, #100]	; 0x64
    ipcp_options *go = &pcb->ipcp_gotoptions;
 8015de8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8015dea:	4ae0      	ldr	r2, [pc, #896]	; (801616c <ipcp_nakci+0x398>)
 8015dec:	4694      	mov	ip, r2
 8015dee:	4463      	add	r3, ip
 8015df0:	663b      	str	r3, [r7, #96]	; 0x60
    u32_t cidnsaddr;
#endif /* LWIP_DNS */
    ipcp_options no;		/* options we've seen Naks for */
    ipcp_options try_;		/* options to request next time */

    BZERO(&no, sizeof(no));
 8015df2:	2428      	movs	r4, #40	; 0x28
 8015df4:	193b      	adds	r3, r7, r4
 8015df6:	2218      	movs	r2, #24
 8015df8:	2100      	movs	r1, #0
 8015dfa:	0018      	movs	r0, r3
 8015dfc:	f006 ff0c 	bl	801cc18 <memset>
    try_ = *go;
 8015e00:	2510      	movs	r5, #16
 8015e02:	197b      	adds	r3, r7, r5
 8015e04:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8015e06:	ca43      	ldmia	r2!, {r0, r1, r6}
 8015e08:	c343      	stmia	r3!, {r0, r1, r6}
 8015e0a:	ca43      	ldmia	r2!, {r0, r1, r6}
 8015e0c:	c343      	stmia	r3!, {r0, r1, r6}

    /*
     * Accept the peer's idea of {our,his} address, if different
     * from our idea, only if the accept_{local,remote} flag is set.
     */
    NAKCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs,
 8015e0e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8015e10:	781b      	ldrb	r3, [r3, #0]
 8015e12:	2201      	movs	r2, #1
 8015e14:	4013      	ands	r3, r2
 8015e16:	b2db      	uxtb	r3, r3
 8015e18:	2b00      	cmp	r3, #0
 8015e1a:	d000      	beq.n	8015e1e <ipcp_nakci+0x4a>
 8015e1c:	e0a2      	b.n	8015f64 <ipcp_nakci+0x190>
 8015e1e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8015e20:	781b      	ldrb	r3, [r3, #0]
 8015e22:	2202      	movs	r2, #2
 8015e24:	4013      	ands	r3, r2
 8015e26:	b2db      	uxtb	r3, r3
 8015e28:	2b00      	cmp	r3, #0
 8015e2a:	d100      	bne.n	8015e2e <ipcp_nakci+0x5a>
 8015e2c:	e09a      	b.n	8015f64 <ipcp_nakci+0x190>
 8015e2e:	215f      	movs	r1, #95	; 0x5f
 8015e30:	187b      	adds	r3, r7, r1
 8015e32:	68ba      	ldr	r2, [r7, #8]
 8015e34:	7852      	ldrb	r2, [r2, #1]
 8015e36:	701a      	strb	r2, [r3, #0]
 8015e38:	187b      	adds	r3, r7, r1
 8015e3a:	781b      	ldrb	r3, [r3, #0]
 8015e3c:	2b0a      	cmp	r3, #10
 8015e3e:	d000      	beq.n	8015e42 <ipcp_nakci+0x6e>
 8015e40:	e090      	b.n	8015f64 <ipcp_nakci+0x190>
 8015e42:	187b      	adds	r3, r7, r1
 8015e44:	781b      	ldrb	r3, [r3, #0]
 8015e46:	687a      	ldr	r2, [r7, #4]
 8015e48:	429a      	cmp	r2, r3
 8015e4a:	da00      	bge.n	8015e4e <ipcp_nakci+0x7a>
 8015e4c:	e08a      	b.n	8015f64 <ipcp_nakci+0x190>
 8015e4e:	68bb      	ldr	r3, [r7, #8]
 8015e50:	781b      	ldrb	r3, [r3, #0]
 8015e52:	2b01      	cmp	r3, #1
 8015e54:	d000      	beq.n	8015e58 <ipcp_nakci+0x84>
 8015e56:	e085      	b.n	8015f64 <ipcp_nakci+0x190>
 8015e58:	187b      	adds	r3, r7, r1
 8015e5a:	781b      	ldrb	r3, [r3, #0]
 8015e5c:	687a      	ldr	r2, [r7, #4]
 8015e5e:	1ad3      	subs	r3, r2, r3
 8015e60:	607b      	str	r3, [r7, #4]
 8015e62:	68bb      	ldr	r3, [r7, #8]
 8015e64:	3302      	adds	r3, #2
 8015e66:	60bb      	str	r3, [r7, #8]
 8015e68:	68bb      	ldr	r3, [r7, #8]
 8015e6a:	1c5a      	adds	r2, r3, #1
 8015e6c:	60ba      	str	r2, [r7, #8]
 8015e6e:	781b      	ldrb	r3, [r3, #0]
 8015e70:	021b      	lsls	r3, r3, #8
 8015e72:	65bb      	str	r3, [r7, #88]	; 0x58
 8015e74:	68bb      	ldr	r3, [r7, #8]
 8015e76:	1c5a      	adds	r2, r3, #1
 8015e78:	60ba      	str	r2, [r7, #8]
 8015e7a:	781b      	ldrb	r3, [r3, #0]
 8015e7c:	001a      	movs	r2, r3
 8015e7e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015e80:	4313      	orrs	r3, r2
 8015e82:	65bb      	str	r3, [r7, #88]	; 0x58
 8015e84:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015e86:	021b      	lsls	r3, r3, #8
 8015e88:	65bb      	str	r3, [r7, #88]	; 0x58
 8015e8a:	68bb      	ldr	r3, [r7, #8]
 8015e8c:	1c5a      	adds	r2, r3, #1
 8015e8e:	60ba      	str	r2, [r7, #8]
 8015e90:	781b      	ldrb	r3, [r3, #0]
 8015e92:	001a      	movs	r2, r3
 8015e94:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015e96:	4313      	orrs	r3, r2
 8015e98:	65bb      	str	r3, [r7, #88]	; 0x58
 8015e9a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015e9c:	021b      	lsls	r3, r3, #8
 8015e9e:	65bb      	str	r3, [r7, #88]	; 0x58
 8015ea0:	68bb      	ldr	r3, [r7, #8]
 8015ea2:	1c5a      	adds	r2, r3, #1
 8015ea4:	60ba      	str	r2, [r7, #8]
 8015ea6:	781b      	ldrb	r3, [r3, #0]
 8015ea8:	001a      	movs	r2, r3
 8015eaa:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015eac:	4313      	orrs	r3, r2
 8015eae:	65bb      	str	r3, [r7, #88]	; 0x58
 8015eb0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015eb2:	0018      	movs	r0, r3
 8015eb4:	f7f0 febe 	bl	8006c34 <lwip_htonl>
 8015eb8:	0003      	movs	r3, r0
 8015eba:	657b      	str	r3, [r7, #84]	; 0x54
 8015ebc:	68bb      	ldr	r3, [r7, #8]
 8015ebe:	1c5a      	adds	r2, r3, #1
 8015ec0:	60ba      	str	r2, [r7, #8]
 8015ec2:	781b      	ldrb	r3, [r3, #0]
 8015ec4:	021b      	lsls	r3, r3, #8
 8015ec6:	65bb      	str	r3, [r7, #88]	; 0x58
 8015ec8:	68bb      	ldr	r3, [r7, #8]
 8015eca:	1c5a      	adds	r2, r3, #1
 8015ecc:	60ba      	str	r2, [r7, #8]
 8015ece:	781b      	ldrb	r3, [r3, #0]
 8015ed0:	001a      	movs	r2, r3
 8015ed2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015ed4:	4313      	orrs	r3, r2
 8015ed6:	65bb      	str	r3, [r7, #88]	; 0x58
 8015ed8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015eda:	021b      	lsls	r3, r3, #8
 8015edc:	65bb      	str	r3, [r7, #88]	; 0x58
 8015ede:	68bb      	ldr	r3, [r7, #8]
 8015ee0:	1c5a      	adds	r2, r3, #1
 8015ee2:	60ba      	str	r2, [r7, #8]
 8015ee4:	781b      	ldrb	r3, [r3, #0]
 8015ee6:	001a      	movs	r2, r3
 8015ee8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015eea:	4313      	orrs	r3, r2
 8015eec:	65bb      	str	r3, [r7, #88]	; 0x58
 8015eee:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015ef0:	021b      	lsls	r3, r3, #8
 8015ef2:	65bb      	str	r3, [r7, #88]	; 0x58
 8015ef4:	68bb      	ldr	r3, [r7, #8]
 8015ef6:	1c5a      	adds	r2, r3, #1
 8015ef8:	60ba      	str	r2, [r7, #8]
 8015efa:	781b      	ldrb	r3, [r3, #0]
 8015efc:	001a      	movs	r2, r3
 8015efe:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015f00:	4313      	orrs	r3, r2
 8015f02:	65bb      	str	r3, [r7, #88]	; 0x58
 8015f04:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015f06:	0018      	movs	r0, r3
 8015f08:	f7f0 fe94 	bl	8006c34 <lwip_htonl>
 8015f0c:	0003      	movs	r3, r0
 8015f0e:	653b      	str	r3, [r7, #80]	; 0x50
 8015f10:	193b      	adds	r3, r7, r4
 8015f12:	781a      	ldrb	r2, [r3, #0]
 8015f14:	2102      	movs	r1, #2
 8015f16:	430a      	orrs	r2, r1
 8015f18:	701a      	strb	r2, [r3, #0]
 8015f1a:	683b      	ldr	r3, [r7, #0]
 8015f1c:	2b00      	cmp	r3, #0
 8015f1e:	d005      	beq.n	8015f2c <ipcp_nakci+0x158>
 8015f20:	197b      	adds	r3, r7, r5
 8015f22:	781a      	ldrb	r2, [r3, #0]
 8015f24:	2102      	movs	r1, #2
 8015f26:	438a      	bics	r2, r1
 8015f28:	701a      	strb	r2, [r3, #0]
 8015f2a:	e01b      	b.n	8015f64 <ipcp_nakci+0x190>
 8015f2c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8015f2e:	781b      	ldrb	r3, [r3, #0]
 8015f30:	2240      	movs	r2, #64	; 0x40
 8015f32:	4013      	ands	r3, r2
 8015f34:	b2db      	uxtb	r3, r3
 8015f36:	2b00      	cmp	r3, #0
 8015f38:	d006      	beq.n	8015f48 <ipcp_nakci+0x174>
 8015f3a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8015f3c:	2b00      	cmp	r3, #0
 8015f3e:	d003      	beq.n	8015f48 <ipcp_nakci+0x174>
 8015f40:	2310      	movs	r3, #16
 8015f42:	18fb      	adds	r3, r7, r3
 8015f44:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8015f46:	605a      	str	r2, [r3, #4]
 8015f48:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8015f4a:	781b      	ldrb	r3, [r3, #0]
 8015f4c:	227f      	movs	r2, #127	; 0x7f
 8015f4e:	4393      	bics	r3, r2
 8015f50:	b2db      	uxtb	r3, r3
 8015f52:	2b00      	cmp	r3, #0
 8015f54:	d006      	beq.n	8015f64 <ipcp_nakci+0x190>
 8015f56:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015f58:	2b00      	cmp	r3, #0
 8015f5a:	d003      	beq.n	8015f64 <ipcp_nakci+0x190>
 8015f5c:	2310      	movs	r3, #16
 8015f5e:	18fb      	adds	r3, r7, r3
 8015f60:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8015f62:	609a      	str	r2, [r3, #8]
     * Accept the peer's value of maxslotindex provided that it
     * is less than what we asked for.  Turn off slot-ID compression
     * if the peer wants.  Send old-style compress-type option if
     * the peer wants.
     */
    NAKCIVJ(CI_COMPRESSTYPE, neg_vj,
 8015f64:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8015f66:	781b      	ldrb	r3, [r3, #0]
 8015f68:	2208      	movs	r2, #8
 8015f6a:	4013      	ands	r3, r2
 8015f6c:	b2db      	uxtb	r3, r3
 8015f6e:	2b00      	cmp	r3, #0
 8015f70:	d100      	bne.n	8015f74 <ipcp_nakci+0x1a0>
 8015f72:	e09b      	b.n	80160ac <ipcp_nakci+0x2d8>
 8015f74:	215f      	movs	r1, #95	; 0x5f
 8015f76:	187b      	adds	r3, r7, r1
 8015f78:	68ba      	ldr	r2, [r7, #8]
 8015f7a:	7852      	ldrb	r2, [r2, #1]
 8015f7c:	701a      	strb	r2, [r3, #0]
 8015f7e:	000a      	movs	r2, r1
 8015f80:	18bb      	adds	r3, r7, r2
 8015f82:	781b      	ldrb	r3, [r3, #0]
 8015f84:	2b04      	cmp	r3, #4
 8015f86:	d004      	beq.n	8015f92 <ipcp_nakci+0x1be>
 8015f88:	18bb      	adds	r3, r7, r2
 8015f8a:	781b      	ldrb	r3, [r3, #0]
 8015f8c:	2b06      	cmp	r3, #6
 8015f8e:	d000      	beq.n	8015f92 <ipcp_nakci+0x1be>
 8015f90:	e08c      	b.n	80160ac <ipcp_nakci+0x2d8>
 8015f92:	215f      	movs	r1, #95	; 0x5f
 8015f94:	187b      	adds	r3, r7, r1
 8015f96:	781b      	ldrb	r3, [r3, #0]
 8015f98:	687a      	ldr	r2, [r7, #4]
 8015f9a:	429a      	cmp	r2, r3
 8015f9c:	da00      	bge.n	8015fa0 <ipcp_nakci+0x1cc>
 8015f9e:	e085      	b.n	80160ac <ipcp_nakci+0x2d8>
 8015fa0:	68bb      	ldr	r3, [r7, #8]
 8015fa2:	781b      	ldrb	r3, [r3, #0]
 8015fa4:	2b02      	cmp	r3, #2
 8015fa6:	d000      	beq.n	8015faa <ipcp_nakci+0x1d6>
 8015fa8:	e080      	b.n	80160ac <ipcp_nakci+0x2d8>
 8015faa:	187b      	adds	r3, r7, r1
 8015fac:	781b      	ldrb	r3, [r3, #0]
 8015fae:	687a      	ldr	r2, [r7, #4]
 8015fb0:	1ad3      	subs	r3, r2, r3
 8015fb2:	607b      	str	r3, [r7, #4]
 8015fb4:	68bb      	ldr	r3, [r7, #8]
 8015fb6:	3302      	adds	r3, #2
 8015fb8:	60bb      	str	r3, [r7, #8]
 8015fba:	68bb      	ldr	r3, [r7, #8]
 8015fbc:	1c5a      	adds	r2, r3, #1
 8015fbe:	60ba      	str	r2, [r7, #8]
 8015fc0:	781b      	ldrb	r3, [r3, #0]
 8015fc2:	b29a      	uxth	r2, r3
 8015fc4:	204e      	movs	r0, #78	; 0x4e
 8015fc6:	183b      	adds	r3, r7, r0
 8015fc8:	0212      	lsls	r2, r2, #8
 8015fca:	801a      	strh	r2, [r3, #0]
 8015fcc:	68bb      	ldr	r3, [r7, #8]
 8015fce:	1c5a      	adds	r2, r3, #1
 8015fd0:	60ba      	str	r2, [r7, #8]
 8015fd2:	781b      	ldrb	r3, [r3, #0]
 8015fd4:	b299      	uxth	r1, r3
 8015fd6:	183b      	adds	r3, r7, r0
 8015fd8:	183a      	adds	r2, r7, r0
 8015fda:	8812      	ldrh	r2, [r2, #0]
 8015fdc:	430a      	orrs	r2, r1
 8015fde:	801a      	strh	r2, [r3, #0]
 8015fe0:	2328      	movs	r3, #40	; 0x28
 8015fe2:	18fb      	adds	r3, r7, r3
 8015fe4:	781a      	ldrb	r2, [r3, #0]
 8015fe6:	2108      	movs	r1, #8
 8015fe8:	430a      	orrs	r2, r1
 8015fea:	701a      	strb	r2, [r3, #0]
 8015fec:	683b      	ldr	r3, [r7, #0]
 8015fee:	2b00      	cmp	r3, #0
 8015ff0:	d006      	beq.n	8016000 <ipcp_nakci+0x22c>
 8015ff2:	2310      	movs	r3, #16
 8015ff4:	18fb      	adds	r3, r7, r3
 8015ff6:	781a      	ldrb	r2, [r3, #0]
 8015ff8:	2108      	movs	r1, #8
 8015ffa:	438a      	bics	r2, r1
 8015ffc:	701a      	strb	r2, [r3, #0]
 8015ffe:	e055      	b.n	80160ac <ipcp_nakci+0x2d8>
 8016000:	235f      	movs	r3, #95	; 0x5f
 8016002:	18fb      	adds	r3, r7, r3
 8016004:	781b      	ldrb	r3, [r3, #0]
 8016006:	2b06      	cmp	r3, #6
 8016008:	d135      	bne.n	8016076 <ipcp_nakci+0x2a2>
 801600a:	68bb      	ldr	r3, [r7, #8]
 801600c:	1c5a      	adds	r2, r3, #1
 801600e:	60ba      	str	r2, [r7, #8]
 8016010:	204d      	movs	r0, #77	; 0x4d
 8016012:	183a      	adds	r2, r7, r0
 8016014:	781b      	ldrb	r3, [r3, #0]
 8016016:	7013      	strb	r3, [r2, #0]
 8016018:	68bb      	ldr	r3, [r7, #8]
 801601a:	1c5a      	adds	r2, r3, #1
 801601c:	60ba      	str	r2, [r7, #8]
 801601e:	224c      	movs	r2, #76	; 0x4c
 8016020:	18ba      	adds	r2, r7, r2
 8016022:	781b      	ldrb	r3, [r3, #0]
 8016024:	7013      	strb	r3, [r2, #0]
 8016026:	234e      	movs	r3, #78	; 0x4e
 8016028:	18fb      	adds	r3, r7, r3
 801602a:	881b      	ldrh	r3, [r3, #0]
 801602c:	2b2d      	cmp	r3, #45	; 0x2d
 801602e:	d11b      	bne.n	8016068 <ipcp_nakci+0x294>
 8016030:	2410      	movs	r4, #16
 8016032:	193b      	adds	r3, r7, r4
 8016034:	781a      	ldrb	r2, [r3, #0]
 8016036:	2110      	movs	r1, #16
 8016038:	438a      	bics	r2, r1
 801603a:	701a      	strb	r2, [r3, #0]
 801603c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801603e:	7d9b      	ldrb	r3, [r3, #22]
 8016040:	183a      	adds	r2, r7, r0
 8016042:	7812      	ldrb	r2, [r2, #0]
 8016044:	429a      	cmp	r2, r3
 8016046:	d203      	bcs.n	8016050 <ipcp_nakci+0x27c>
 8016048:	193b      	adds	r3, r7, r4
 801604a:	183a      	adds	r2, r7, r0
 801604c:	7812      	ldrb	r2, [r2, #0]
 801604e:	759a      	strb	r2, [r3, #22]
 8016050:	234c      	movs	r3, #76	; 0x4c
 8016052:	18fb      	adds	r3, r7, r3
 8016054:	781b      	ldrb	r3, [r3, #0]
 8016056:	2b00      	cmp	r3, #0
 8016058:	d128      	bne.n	80160ac <ipcp_nakci+0x2d8>
 801605a:	2310      	movs	r3, #16
 801605c:	18fb      	adds	r3, r7, r3
 801605e:	781a      	ldrb	r2, [r3, #0]
 8016060:	2120      	movs	r1, #32
 8016062:	438a      	bics	r2, r1
 8016064:	701a      	strb	r2, [r3, #0]
 8016066:	e021      	b.n	80160ac <ipcp_nakci+0x2d8>
 8016068:	2310      	movs	r3, #16
 801606a:	18fb      	adds	r3, r7, r3
 801606c:	781a      	ldrb	r2, [r3, #0]
 801606e:	2108      	movs	r1, #8
 8016070:	438a      	bics	r2, r1
 8016072:	701a      	strb	r2, [r3, #0]
 8016074:	e01a      	b.n	80160ac <ipcp_nakci+0x2d8>
 8016076:	224e      	movs	r2, #78	; 0x4e
 8016078:	18bb      	adds	r3, r7, r2
 801607a:	881b      	ldrh	r3, [r3, #0]
 801607c:	2b2d      	cmp	r3, #45	; 0x2d
 801607e:	d003      	beq.n	8016088 <ipcp_nakci+0x2b4>
 8016080:	18bb      	adds	r3, r7, r2
 8016082:	881b      	ldrh	r3, [r3, #0]
 8016084:	2b37      	cmp	r3, #55	; 0x37
 8016086:	d10b      	bne.n	80160a0 <ipcp_nakci+0x2cc>
 8016088:	2010      	movs	r0, #16
 801608a:	183b      	adds	r3, r7, r0
 801608c:	781a      	ldrb	r2, [r3, #0]
 801608e:	2110      	movs	r1, #16
 8016090:	430a      	orrs	r2, r1
 8016092:	701a      	strb	r2, [r3, #0]
 8016094:	183b      	adds	r3, r7, r0
 8016096:	224e      	movs	r2, #78	; 0x4e
 8016098:	18ba      	adds	r2, r7, r2
 801609a:	8812      	ldrh	r2, [r2, #0]
 801609c:	829a      	strh	r2, [r3, #20]
 801609e:	e005      	b.n	80160ac <ipcp_nakci+0x2d8>
 80160a0:	2310      	movs	r3, #16
 80160a2:	18fb      	adds	r3, r7, r3
 80160a4:	781a      	ldrb	r2, [r3, #0]
 80160a6:	2108      	movs	r1, #8
 80160a8:	438a      	bics	r2, r1
 80160aa:	701a      	strb	r2, [r3, #0]
		}
	    }
	    );
#endif /* VJ_SUPPORT */

    NAKCIADDR(CI_ADDR, neg_addr,
 80160ac:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80160ae:	781b      	ldrb	r3, [r3, #0]
 80160b0:	2201      	movs	r2, #1
 80160b2:	4013      	ands	r3, r2
 80160b4:	b2db      	uxtb	r3, r3
 80160b6:	2b00      	cmp	r3, #0
 80160b8:	d068      	beq.n	801618c <ipcp_nakci+0x3b8>
 80160ba:	215f      	movs	r1, #95	; 0x5f
 80160bc:	187b      	adds	r3, r7, r1
 80160be:	68ba      	ldr	r2, [r7, #8]
 80160c0:	7852      	ldrb	r2, [r2, #1]
 80160c2:	701a      	strb	r2, [r3, #0]
 80160c4:	187b      	adds	r3, r7, r1
 80160c6:	781b      	ldrb	r3, [r3, #0]
 80160c8:	2b06      	cmp	r3, #6
 80160ca:	d15f      	bne.n	801618c <ipcp_nakci+0x3b8>
 80160cc:	187b      	adds	r3, r7, r1
 80160ce:	781b      	ldrb	r3, [r3, #0]
 80160d0:	687a      	ldr	r2, [r7, #4]
 80160d2:	429a      	cmp	r2, r3
 80160d4:	db5a      	blt.n	801618c <ipcp_nakci+0x3b8>
 80160d6:	68bb      	ldr	r3, [r7, #8]
 80160d8:	781b      	ldrb	r3, [r3, #0]
 80160da:	2b03      	cmp	r3, #3
 80160dc:	d156      	bne.n	801618c <ipcp_nakci+0x3b8>
 80160de:	187b      	adds	r3, r7, r1
 80160e0:	781b      	ldrb	r3, [r3, #0]
 80160e2:	687a      	ldr	r2, [r7, #4]
 80160e4:	1ad3      	subs	r3, r2, r3
 80160e6:	607b      	str	r3, [r7, #4]
 80160e8:	68bb      	ldr	r3, [r7, #8]
 80160ea:	3302      	adds	r3, #2
 80160ec:	60bb      	str	r3, [r7, #8]
 80160ee:	68bb      	ldr	r3, [r7, #8]
 80160f0:	1c5a      	adds	r2, r3, #1
 80160f2:	60ba      	str	r2, [r7, #8]
 80160f4:	781b      	ldrb	r3, [r3, #0]
 80160f6:	021b      	lsls	r3, r3, #8
 80160f8:	65bb      	str	r3, [r7, #88]	; 0x58
 80160fa:	68bb      	ldr	r3, [r7, #8]
 80160fc:	1c5a      	adds	r2, r3, #1
 80160fe:	60ba      	str	r2, [r7, #8]
 8016100:	781b      	ldrb	r3, [r3, #0]
 8016102:	001a      	movs	r2, r3
 8016104:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016106:	4313      	orrs	r3, r2
 8016108:	65bb      	str	r3, [r7, #88]	; 0x58
 801610a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801610c:	021b      	lsls	r3, r3, #8
 801610e:	65bb      	str	r3, [r7, #88]	; 0x58
 8016110:	68bb      	ldr	r3, [r7, #8]
 8016112:	1c5a      	adds	r2, r3, #1
 8016114:	60ba      	str	r2, [r7, #8]
 8016116:	781b      	ldrb	r3, [r3, #0]
 8016118:	001a      	movs	r2, r3
 801611a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801611c:	4313      	orrs	r3, r2
 801611e:	65bb      	str	r3, [r7, #88]	; 0x58
 8016120:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016122:	021b      	lsls	r3, r3, #8
 8016124:	65bb      	str	r3, [r7, #88]	; 0x58
 8016126:	68bb      	ldr	r3, [r7, #8]
 8016128:	1c5a      	adds	r2, r3, #1
 801612a:	60ba      	str	r2, [r7, #8]
 801612c:	781b      	ldrb	r3, [r3, #0]
 801612e:	001a      	movs	r2, r3
 8016130:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016132:	4313      	orrs	r3, r2
 8016134:	65bb      	str	r3, [r7, #88]	; 0x58
 8016136:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016138:	0018      	movs	r0, r3
 801613a:	f7f0 fd7b 	bl	8006c34 <lwip_htonl>
 801613e:	0003      	movs	r3, r0
 8016140:	657b      	str	r3, [r7, #84]	; 0x54
 8016142:	2328      	movs	r3, #40	; 0x28
 8016144:	18fb      	adds	r3, r7, r3
 8016146:	781a      	ldrb	r2, [r3, #0]
 8016148:	2101      	movs	r1, #1
 801614a:	430a      	orrs	r2, r1
 801614c:	701a      	strb	r2, [r3, #0]
 801614e:	683b      	ldr	r3, [r7, #0]
 8016150:	2b00      	cmp	r3, #0
 8016152:	d00d      	beq.n	8016170 <ipcp_nakci+0x39c>
 8016154:	2010      	movs	r0, #16
 8016156:	183b      	adds	r3, r7, r0
 8016158:	781a      	ldrb	r2, [r3, #0]
 801615a:	2101      	movs	r1, #1
 801615c:	438a      	bics	r2, r1
 801615e:	701a      	strb	r2, [r3, #0]
 8016160:	183b      	adds	r3, r7, r0
 8016162:	781a      	ldrb	r2, [r3, #0]
 8016164:	2102      	movs	r1, #2
 8016166:	438a      	bics	r2, r1
 8016168:	701a      	strb	r2, [r3, #0]
 801616a:	e00f      	b.n	801618c <ipcp_nakci+0x3b8>
 801616c:	0000121c 	.word	0x0000121c
 8016170:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016172:	781b      	ldrb	r3, [r3, #0]
 8016174:	2240      	movs	r2, #64	; 0x40
 8016176:	4013      	ands	r3, r2
 8016178:	b2db      	uxtb	r3, r3
 801617a:	2b00      	cmp	r3, #0
 801617c:	d006      	beq.n	801618c <ipcp_nakci+0x3b8>
 801617e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016180:	2b00      	cmp	r3, #0
 8016182:	d003      	beq.n	801618c <ipcp_nakci+0x3b8>
 8016184:	2310      	movs	r3, #16
 8016186:	18fb      	adds	r3, r7, r3
 8016188:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801618a:	605a      	str	r2, [r3, #4]
		  try_.ouraddr = ciaddr1;
	      }
	      );

#if LWIP_DNS
    NAKCIDNS(CI_MS_DNS1, req_dns1,
 801618c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801618e:	785b      	ldrb	r3, [r3, #1]
 8016190:	2201      	movs	r2, #1
 8016192:	4013      	ands	r3, r2
 8016194:	b2db      	uxtb	r3, r3
 8016196:	2b00      	cmp	r3, #0
 8016198:	d057      	beq.n	801624a <ipcp_nakci+0x476>
 801619a:	215f      	movs	r1, #95	; 0x5f
 801619c:	187b      	adds	r3, r7, r1
 801619e:	68ba      	ldr	r2, [r7, #8]
 80161a0:	7852      	ldrb	r2, [r2, #1]
 80161a2:	701a      	strb	r2, [r3, #0]
 80161a4:	187b      	adds	r3, r7, r1
 80161a6:	781b      	ldrb	r3, [r3, #0]
 80161a8:	2b06      	cmp	r3, #6
 80161aa:	d14e      	bne.n	801624a <ipcp_nakci+0x476>
 80161ac:	187b      	adds	r3, r7, r1
 80161ae:	781b      	ldrb	r3, [r3, #0]
 80161b0:	687a      	ldr	r2, [r7, #4]
 80161b2:	429a      	cmp	r2, r3
 80161b4:	db49      	blt.n	801624a <ipcp_nakci+0x476>
 80161b6:	68bb      	ldr	r3, [r7, #8]
 80161b8:	781b      	ldrb	r3, [r3, #0]
 80161ba:	2b81      	cmp	r3, #129	; 0x81
 80161bc:	d145      	bne.n	801624a <ipcp_nakci+0x476>
 80161be:	187b      	adds	r3, r7, r1
 80161c0:	781b      	ldrb	r3, [r3, #0]
 80161c2:	687a      	ldr	r2, [r7, #4]
 80161c4:	1ad3      	subs	r3, r2, r3
 80161c6:	607b      	str	r3, [r7, #4]
 80161c8:	68bb      	ldr	r3, [r7, #8]
 80161ca:	3302      	adds	r3, #2
 80161cc:	60bb      	str	r3, [r7, #8]
 80161ce:	68bb      	ldr	r3, [r7, #8]
 80161d0:	1c5a      	adds	r2, r3, #1
 80161d2:	60ba      	str	r2, [r7, #8]
 80161d4:	781b      	ldrb	r3, [r3, #0]
 80161d6:	021b      	lsls	r3, r3, #8
 80161d8:	65bb      	str	r3, [r7, #88]	; 0x58
 80161da:	68bb      	ldr	r3, [r7, #8]
 80161dc:	1c5a      	adds	r2, r3, #1
 80161de:	60ba      	str	r2, [r7, #8]
 80161e0:	781b      	ldrb	r3, [r3, #0]
 80161e2:	001a      	movs	r2, r3
 80161e4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80161e6:	4313      	orrs	r3, r2
 80161e8:	65bb      	str	r3, [r7, #88]	; 0x58
 80161ea:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80161ec:	021b      	lsls	r3, r3, #8
 80161ee:	65bb      	str	r3, [r7, #88]	; 0x58
 80161f0:	68bb      	ldr	r3, [r7, #8]
 80161f2:	1c5a      	adds	r2, r3, #1
 80161f4:	60ba      	str	r2, [r7, #8]
 80161f6:	781b      	ldrb	r3, [r3, #0]
 80161f8:	001a      	movs	r2, r3
 80161fa:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80161fc:	4313      	orrs	r3, r2
 80161fe:	65bb      	str	r3, [r7, #88]	; 0x58
 8016200:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016202:	021b      	lsls	r3, r3, #8
 8016204:	65bb      	str	r3, [r7, #88]	; 0x58
 8016206:	68bb      	ldr	r3, [r7, #8]
 8016208:	1c5a      	adds	r2, r3, #1
 801620a:	60ba      	str	r2, [r7, #8]
 801620c:	781b      	ldrb	r3, [r3, #0]
 801620e:	001a      	movs	r2, r3
 8016210:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016212:	4313      	orrs	r3, r2
 8016214:	65bb      	str	r3, [r7, #88]	; 0x58
 8016216:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016218:	0018      	movs	r0, r3
 801621a:	f7f0 fd0b 	bl	8006c34 <lwip_htonl>
 801621e:	0003      	movs	r3, r0
 8016220:	64bb      	str	r3, [r7, #72]	; 0x48
 8016222:	2328      	movs	r3, #40	; 0x28
 8016224:	18fb      	adds	r3, r7, r3
 8016226:	785a      	ldrb	r2, [r3, #1]
 8016228:	2101      	movs	r1, #1
 801622a:	430a      	orrs	r2, r1
 801622c:	705a      	strb	r2, [r3, #1]
 801622e:	683b      	ldr	r3, [r7, #0]
 8016230:	2b00      	cmp	r3, #0
 8016232:	d006      	beq.n	8016242 <ipcp_nakci+0x46e>
 8016234:	2310      	movs	r3, #16
 8016236:	18fb      	adds	r3, r7, r3
 8016238:	785a      	ldrb	r2, [r3, #1]
 801623a:	2101      	movs	r1, #1
 801623c:	438a      	bics	r2, r1
 801623e:	705a      	strb	r2, [r3, #1]
 8016240:	e003      	b.n	801624a <ipcp_nakci+0x476>
 8016242:	2310      	movs	r3, #16
 8016244:	18fb      	adds	r3, r7, r3
 8016246:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8016248:	60da      	str	r2, [r3, #12]
	     } else {
		 try_.dnsaddr[0] = cidnsaddr;
	     }
	     );

    NAKCIDNS(CI_MS_DNS2, req_dns2,
 801624a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801624c:	785b      	ldrb	r3, [r3, #1]
 801624e:	2202      	movs	r2, #2
 8016250:	4013      	ands	r3, r2
 8016252:	b2db      	uxtb	r3, r3
 8016254:	2b00      	cmp	r3, #0
 8016256:	d100      	bne.n	801625a <ipcp_nakci+0x486>
 8016258:	e24f      	b.n	80166fa <ipcp_nakci+0x926>
 801625a:	215f      	movs	r1, #95	; 0x5f
 801625c:	187b      	adds	r3, r7, r1
 801625e:	68ba      	ldr	r2, [r7, #8]
 8016260:	7852      	ldrb	r2, [r2, #1]
 8016262:	701a      	strb	r2, [r3, #0]
 8016264:	187b      	adds	r3, r7, r1
 8016266:	781b      	ldrb	r3, [r3, #0]
 8016268:	2b06      	cmp	r3, #6
 801626a:	d000      	beq.n	801626e <ipcp_nakci+0x49a>
 801626c:	e245      	b.n	80166fa <ipcp_nakci+0x926>
 801626e:	187b      	adds	r3, r7, r1
 8016270:	781b      	ldrb	r3, [r3, #0]
 8016272:	687a      	ldr	r2, [r7, #4]
 8016274:	429a      	cmp	r2, r3
 8016276:	da00      	bge.n	801627a <ipcp_nakci+0x4a6>
 8016278:	e23f      	b.n	80166fa <ipcp_nakci+0x926>
 801627a:	68bb      	ldr	r3, [r7, #8]
 801627c:	781b      	ldrb	r3, [r3, #0]
 801627e:	2b83      	cmp	r3, #131	; 0x83
 8016280:	d000      	beq.n	8016284 <ipcp_nakci+0x4b0>
 8016282:	e23a      	b.n	80166fa <ipcp_nakci+0x926>
 8016284:	187b      	adds	r3, r7, r1
 8016286:	781b      	ldrb	r3, [r3, #0]
 8016288:	687a      	ldr	r2, [r7, #4]
 801628a:	1ad3      	subs	r3, r2, r3
 801628c:	607b      	str	r3, [r7, #4]
 801628e:	68bb      	ldr	r3, [r7, #8]
 8016290:	3302      	adds	r3, #2
 8016292:	60bb      	str	r3, [r7, #8]
 8016294:	68bb      	ldr	r3, [r7, #8]
 8016296:	1c5a      	adds	r2, r3, #1
 8016298:	60ba      	str	r2, [r7, #8]
 801629a:	781b      	ldrb	r3, [r3, #0]
 801629c:	021b      	lsls	r3, r3, #8
 801629e:	65bb      	str	r3, [r7, #88]	; 0x58
 80162a0:	68bb      	ldr	r3, [r7, #8]
 80162a2:	1c5a      	adds	r2, r3, #1
 80162a4:	60ba      	str	r2, [r7, #8]
 80162a6:	781b      	ldrb	r3, [r3, #0]
 80162a8:	001a      	movs	r2, r3
 80162aa:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80162ac:	4313      	orrs	r3, r2
 80162ae:	65bb      	str	r3, [r7, #88]	; 0x58
 80162b0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80162b2:	021b      	lsls	r3, r3, #8
 80162b4:	65bb      	str	r3, [r7, #88]	; 0x58
 80162b6:	68bb      	ldr	r3, [r7, #8]
 80162b8:	1c5a      	adds	r2, r3, #1
 80162ba:	60ba      	str	r2, [r7, #8]
 80162bc:	781b      	ldrb	r3, [r3, #0]
 80162be:	001a      	movs	r2, r3
 80162c0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80162c2:	4313      	orrs	r3, r2
 80162c4:	65bb      	str	r3, [r7, #88]	; 0x58
 80162c6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80162c8:	021b      	lsls	r3, r3, #8
 80162ca:	65bb      	str	r3, [r7, #88]	; 0x58
 80162cc:	68bb      	ldr	r3, [r7, #8]
 80162ce:	1c5a      	adds	r2, r3, #1
 80162d0:	60ba      	str	r2, [r7, #8]
 80162d2:	781b      	ldrb	r3, [r3, #0]
 80162d4:	001a      	movs	r2, r3
 80162d6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80162d8:	4313      	orrs	r3, r2
 80162da:	65bb      	str	r3, [r7, #88]	; 0x58
 80162dc:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80162de:	0018      	movs	r0, r3
 80162e0:	f7f0 fca8 	bl	8006c34 <lwip_htonl>
 80162e4:	0003      	movs	r3, r0
 80162e6:	64bb      	str	r3, [r7, #72]	; 0x48
 80162e8:	2328      	movs	r3, #40	; 0x28
 80162ea:	18fb      	adds	r3, r7, r3
 80162ec:	785a      	ldrb	r2, [r3, #1]
 80162ee:	2102      	movs	r1, #2
 80162f0:	430a      	orrs	r2, r1
 80162f2:	705a      	strb	r2, [r3, #1]
 80162f4:	683b      	ldr	r3, [r7, #0]
 80162f6:	2b00      	cmp	r3, #0
 80162f8:	d006      	beq.n	8016308 <ipcp_nakci+0x534>
 80162fa:	2310      	movs	r3, #16
 80162fc:	18fb      	adds	r3, r7, r3
 80162fe:	785a      	ldrb	r2, [r3, #1]
 8016300:	2102      	movs	r1, #2
 8016302:	438a      	bics	r2, r1
 8016304:	705a      	strb	r2, [r3, #1]
 8016306:	e1f8      	b.n	80166fa <ipcp_nakci+0x926>
 8016308:	2310      	movs	r3, #16
 801630a:	18fb      	adds	r3, r7, r3
 801630c:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801630e:	611a      	str	r2, [r3, #16]
     * If they want to negotiate about IP addresses, we comply.
     * If they want us to ask for compression, we refuse.
     * If they want us to ask for ms-dns, we do that, since some
     * peers get huffy if we don't.
     */
    while (len >= CILEN_VOID) {
 8016310:	e1f3      	b.n	80166fa <ipcp_nakci+0x926>
	GETCHAR(citype, p);
 8016312:	68bb      	ldr	r3, [r7, #8]
 8016314:	1c5a      	adds	r2, r3, #1
 8016316:	60ba      	str	r2, [r7, #8]
 8016318:	2047      	movs	r0, #71	; 0x47
 801631a:	183a      	adds	r2, r7, r0
 801631c:	781b      	ldrb	r3, [r3, #0]
 801631e:	7013      	strb	r3, [r2, #0]
	GETCHAR(cilen, p);
 8016320:	68bb      	ldr	r3, [r7, #8]
 8016322:	1c5a      	adds	r2, r3, #1
 8016324:	60ba      	str	r2, [r7, #8]
 8016326:	215f      	movs	r1, #95	; 0x5f
 8016328:	187a      	adds	r2, r7, r1
 801632a:	781b      	ldrb	r3, [r3, #0]
 801632c:	7013      	strb	r3, [r2, #0]
	if ( cilen < CILEN_VOID || (len -= cilen) < 0 )
 801632e:	187b      	adds	r3, r7, r1
 8016330:	781b      	ldrb	r3, [r3, #0]
 8016332:	2b01      	cmp	r3, #1
 8016334:	d800      	bhi.n	8016338 <ipcp_nakci+0x564>
 8016336:	e1f1      	b.n	801671c <ipcp_nakci+0x948>
 8016338:	187b      	adds	r3, r7, r1
 801633a:	781b      	ldrb	r3, [r3, #0]
 801633c:	687a      	ldr	r2, [r7, #4]
 801633e:	1ad3      	subs	r3, r2, r3
 8016340:	607b      	str	r3, [r7, #4]
 8016342:	687b      	ldr	r3, [r7, #4]
 8016344:	2b00      	cmp	r3, #0
 8016346:	da00      	bge.n	801634a <ipcp_nakci+0x576>
 8016348:	e1e8      	b.n	801671c <ipcp_nakci+0x948>
	    goto bad;
	next = p + cilen - 2;
 801634a:	187b      	adds	r3, r7, r1
 801634c:	781b      	ldrb	r3, [r3, #0]
 801634e:	3b02      	subs	r3, #2
 8016350:	68ba      	ldr	r2, [r7, #8]
 8016352:	18d3      	adds	r3, r2, r3
 8016354:	643b      	str	r3, [r7, #64]	; 0x40

	switch (citype) {
 8016356:	183b      	adds	r3, r7, r0
 8016358:	781b      	ldrb	r3, [r3, #0]
 801635a:	2b83      	cmp	r3, #131	; 0x83
 801635c:	d100      	bne.n	8016360 <ipcp_nakci+0x58c>
 801635e:	e17e      	b.n	801665e <ipcp_nakci+0x88a>
 8016360:	dd00      	ble.n	8016364 <ipcp_nakci+0x590>
 8016362:	e1c7      	b.n	80166f4 <ipcp_nakci+0x920>
 8016364:	2b81      	cmp	r3, #129	; 0x81
 8016366:	d100      	bne.n	801636a <ipcp_nakci+0x596>
 8016368:	e12b      	b.n	80165c2 <ipcp_nakci+0x7ee>
 801636a:	dd00      	ble.n	801636e <ipcp_nakci+0x59a>
 801636c:	e1c2      	b.n	80166f4 <ipcp_nakci+0x920>
 801636e:	2b03      	cmp	r3, #3
 8016370:	d100      	bne.n	8016374 <ipcp_nakci+0x5a0>
 8016372:	e0c1      	b.n	80164f8 <ipcp_nakci+0x724>
 8016374:	dd00      	ble.n	8016378 <ipcp_nakci+0x5a4>
 8016376:	e1bd      	b.n	80166f4 <ipcp_nakci+0x920>
 8016378:	2b01      	cmp	r3, #1
 801637a:	d023      	beq.n	80163c4 <ipcp_nakci+0x5f0>
 801637c:	2b02      	cmp	r3, #2
 801637e:	d000      	beq.n	8016382 <ipcp_nakci+0x5ae>
 8016380:	e1b8      	b.n	80166f4 <ipcp_nakci+0x920>
#if VJ_SUPPORT
	case CI_COMPRESSTYPE:
	    if (go->neg_vj || no.neg_vj ||
 8016382:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016384:	781b      	ldrb	r3, [r3, #0]
 8016386:	2208      	movs	r2, #8
 8016388:	4013      	ands	r3, r2
 801638a:	b2db      	uxtb	r3, r3
 801638c:	2b00      	cmp	r3, #0
 801638e:	d000      	beq.n	8016392 <ipcp_nakci+0x5be>
 8016390:	e1c6      	b.n	8016720 <ipcp_nakci+0x94c>
 8016392:	2328      	movs	r3, #40	; 0x28
 8016394:	18fb      	adds	r3, r7, r3
 8016396:	781b      	ldrb	r3, [r3, #0]
 8016398:	2208      	movs	r2, #8
 801639a:	4013      	ands	r3, r2
 801639c:	b2db      	uxtb	r3, r3
 801639e:	2b00      	cmp	r3, #0
 80163a0:	d000      	beq.n	80163a4 <ipcp_nakci+0x5d0>
 80163a2:	e1bd      	b.n	8016720 <ipcp_nakci+0x94c>
 80163a4:	187b      	adds	r3, r7, r1
 80163a6:	781b      	ldrb	r3, [r3, #0]
 80163a8:	2b06      	cmp	r3, #6
 80163aa:	d004      	beq.n	80163b6 <ipcp_nakci+0x5e2>
		(cilen != CILEN_VJ && cilen != CILEN_COMPRESS))
 80163ac:	187b      	adds	r3, r7, r1
 80163ae:	781b      	ldrb	r3, [r3, #0]
 80163b0:	2b04      	cmp	r3, #4
 80163b2:	d000      	beq.n	80163b6 <ipcp_nakci+0x5e2>
 80163b4:	e1b4      	b.n	8016720 <ipcp_nakci+0x94c>
		goto bad;
	    no.neg_vj = 1;
 80163b6:	2328      	movs	r3, #40	; 0x28
 80163b8:	18fb      	adds	r3, r7, r3
 80163ba:	781a      	ldrb	r2, [r3, #0]
 80163bc:	2108      	movs	r1, #8
 80163be:	430a      	orrs	r2, r1
 80163c0:	701a      	strb	r2, [r3, #0]
	    break;
 80163c2:	e198      	b.n	80166f6 <ipcp_nakci+0x922>
#endif /* VJ_SUPPORT */
	case CI_ADDRS:
	    if ((!go->neg_addr && go->old_addrs) || no.old_addrs
 80163c4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80163c6:	781b      	ldrb	r3, [r3, #0]
 80163c8:	2201      	movs	r2, #1
 80163ca:	4013      	ands	r3, r2
 80163cc:	b2db      	uxtb	r3, r3
 80163ce:	2b00      	cmp	r3, #0
 80163d0:	d107      	bne.n	80163e2 <ipcp_nakci+0x60e>
 80163d2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80163d4:	781b      	ldrb	r3, [r3, #0]
 80163d6:	2202      	movs	r2, #2
 80163d8:	4013      	ands	r3, r2
 80163da:	b2db      	uxtb	r3, r3
 80163dc:	2b00      	cmp	r3, #0
 80163de:	d000      	beq.n	80163e2 <ipcp_nakci+0x60e>
 80163e0:	e1a0      	b.n	8016724 <ipcp_nakci+0x950>
 80163e2:	2328      	movs	r3, #40	; 0x28
 80163e4:	18fb      	adds	r3, r7, r3
 80163e6:	781b      	ldrb	r3, [r3, #0]
 80163e8:	2202      	movs	r2, #2
 80163ea:	4013      	ands	r3, r2
 80163ec:	b2db      	uxtb	r3, r3
 80163ee:	2b00      	cmp	r3, #0
 80163f0:	d000      	beq.n	80163f4 <ipcp_nakci+0x620>
 80163f2:	e197      	b.n	8016724 <ipcp_nakci+0x950>
		|| cilen != CILEN_ADDRS)
 80163f4:	235f      	movs	r3, #95	; 0x5f
 80163f6:	18fb      	adds	r3, r7, r3
 80163f8:	781b      	ldrb	r3, [r3, #0]
 80163fa:	2b0a      	cmp	r3, #10
 80163fc:	d000      	beq.n	8016400 <ipcp_nakci+0x62c>
 80163fe:	e191      	b.n	8016724 <ipcp_nakci+0x950>
		goto bad;
	    try_.neg_addr = 0;
 8016400:	2410      	movs	r4, #16
 8016402:	193b      	adds	r3, r7, r4
 8016404:	781a      	ldrb	r2, [r3, #0]
 8016406:	2101      	movs	r1, #1
 8016408:	438a      	bics	r2, r1
 801640a:	701a      	strb	r2, [r3, #0]
	    GETLONG(l, p);
 801640c:	68bb      	ldr	r3, [r7, #8]
 801640e:	1c5a      	adds	r2, r3, #1
 8016410:	60ba      	str	r2, [r7, #8]
 8016412:	781b      	ldrb	r3, [r3, #0]
 8016414:	021b      	lsls	r3, r3, #8
 8016416:	65bb      	str	r3, [r7, #88]	; 0x58
 8016418:	68bb      	ldr	r3, [r7, #8]
 801641a:	1c5a      	adds	r2, r3, #1
 801641c:	60ba      	str	r2, [r7, #8]
 801641e:	781b      	ldrb	r3, [r3, #0]
 8016420:	001a      	movs	r2, r3
 8016422:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016424:	4313      	orrs	r3, r2
 8016426:	65bb      	str	r3, [r7, #88]	; 0x58
 8016428:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801642a:	021b      	lsls	r3, r3, #8
 801642c:	65bb      	str	r3, [r7, #88]	; 0x58
 801642e:	68bb      	ldr	r3, [r7, #8]
 8016430:	1c5a      	adds	r2, r3, #1
 8016432:	60ba      	str	r2, [r7, #8]
 8016434:	781b      	ldrb	r3, [r3, #0]
 8016436:	001a      	movs	r2, r3
 8016438:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801643a:	4313      	orrs	r3, r2
 801643c:	65bb      	str	r3, [r7, #88]	; 0x58
 801643e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016440:	021b      	lsls	r3, r3, #8
 8016442:	65bb      	str	r3, [r7, #88]	; 0x58
 8016444:	68bb      	ldr	r3, [r7, #8]
 8016446:	1c5a      	adds	r2, r3, #1
 8016448:	60ba      	str	r2, [r7, #8]
 801644a:	781b      	ldrb	r3, [r3, #0]
 801644c:	001a      	movs	r2, r3
 801644e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016450:	4313      	orrs	r3, r2
 8016452:	65bb      	str	r3, [r7, #88]	; 0x58
	    ciaddr1 = lwip_htonl(l);
 8016454:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016456:	0018      	movs	r0, r3
 8016458:	f7f0 fbec 	bl	8006c34 <lwip_htonl>
 801645c:	0003      	movs	r3, r0
 801645e:	657b      	str	r3, [r7, #84]	; 0x54
	    if (ciaddr1 && go->accept_local)
 8016460:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016462:	2b00      	cmp	r3, #0
 8016464:	d009      	beq.n	801647a <ipcp_nakci+0x6a6>
 8016466:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016468:	781b      	ldrb	r3, [r3, #0]
 801646a:	2240      	movs	r2, #64	; 0x40
 801646c:	4013      	ands	r3, r2
 801646e:	b2db      	uxtb	r3, r3
 8016470:	2b00      	cmp	r3, #0
 8016472:	d002      	beq.n	801647a <ipcp_nakci+0x6a6>
		try_.ouraddr = ciaddr1;
 8016474:	193b      	adds	r3, r7, r4
 8016476:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8016478:	605a      	str	r2, [r3, #4]
	    GETLONG(l, p);
 801647a:	68bb      	ldr	r3, [r7, #8]
 801647c:	1c5a      	adds	r2, r3, #1
 801647e:	60ba      	str	r2, [r7, #8]
 8016480:	781b      	ldrb	r3, [r3, #0]
 8016482:	021b      	lsls	r3, r3, #8
 8016484:	65bb      	str	r3, [r7, #88]	; 0x58
 8016486:	68bb      	ldr	r3, [r7, #8]
 8016488:	1c5a      	adds	r2, r3, #1
 801648a:	60ba      	str	r2, [r7, #8]
 801648c:	781b      	ldrb	r3, [r3, #0]
 801648e:	001a      	movs	r2, r3
 8016490:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016492:	4313      	orrs	r3, r2
 8016494:	65bb      	str	r3, [r7, #88]	; 0x58
 8016496:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016498:	021b      	lsls	r3, r3, #8
 801649a:	65bb      	str	r3, [r7, #88]	; 0x58
 801649c:	68bb      	ldr	r3, [r7, #8]
 801649e:	1c5a      	adds	r2, r3, #1
 80164a0:	60ba      	str	r2, [r7, #8]
 80164a2:	781b      	ldrb	r3, [r3, #0]
 80164a4:	001a      	movs	r2, r3
 80164a6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80164a8:	4313      	orrs	r3, r2
 80164aa:	65bb      	str	r3, [r7, #88]	; 0x58
 80164ac:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80164ae:	021b      	lsls	r3, r3, #8
 80164b0:	65bb      	str	r3, [r7, #88]	; 0x58
 80164b2:	68bb      	ldr	r3, [r7, #8]
 80164b4:	1c5a      	adds	r2, r3, #1
 80164b6:	60ba      	str	r2, [r7, #8]
 80164b8:	781b      	ldrb	r3, [r3, #0]
 80164ba:	001a      	movs	r2, r3
 80164bc:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80164be:	4313      	orrs	r3, r2
 80164c0:	65bb      	str	r3, [r7, #88]	; 0x58
	    ciaddr2 = lwip_htonl(l);
 80164c2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80164c4:	0018      	movs	r0, r3
 80164c6:	f7f0 fbb5 	bl	8006c34 <lwip_htonl>
 80164ca:	0003      	movs	r3, r0
 80164cc:	653b      	str	r3, [r7, #80]	; 0x50
	    if (ciaddr2 && go->accept_remote)
 80164ce:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80164d0:	2b00      	cmp	r3, #0
 80164d2:	d00a      	beq.n	80164ea <ipcp_nakci+0x716>
 80164d4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80164d6:	781b      	ldrb	r3, [r3, #0]
 80164d8:	227f      	movs	r2, #127	; 0x7f
 80164da:	4393      	bics	r3, r2
 80164dc:	b2db      	uxtb	r3, r3
 80164de:	2b00      	cmp	r3, #0
 80164e0:	d003      	beq.n	80164ea <ipcp_nakci+0x716>
		try_.hisaddr = ciaddr2;
 80164e2:	2310      	movs	r3, #16
 80164e4:	18fb      	adds	r3, r7, r3
 80164e6:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80164e8:	609a      	str	r2, [r3, #8]
	    no.old_addrs = 1;
 80164ea:	2328      	movs	r3, #40	; 0x28
 80164ec:	18fb      	adds	r3, r7, r3
 80164ee:	781a      	ldrb	r2, [r3, #0]
 80164f0:	2102      	movs	r1, #2
 80164f2:	430a      	orrs	r2, r1
 80164f4:	701a      	strb	r2, [r3, #0]
	    break;
 80164f6:	e0fe      	b.n	80166f6 <ipcp_nakci+0x922>
	case CI_ADDR:
	    if (go->neg_addr || no.neg_addr || cilen != CILEN_ADDR)
 80164f8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80164fa:	781b      	ldrb	r3, [r3, #0]
 80164fc:	2201      	movs	r2, #1
 80164fe:	4013      	ands	r3, r2
 8016500:	b2db      	uxtb	r3, r3
 8016502:	2b00      	cmp	r3, #0
 8016504:	d000      	beq.n	8016508 <ipcp_nakci+0x734>
 8016506:	e10f      	b.n	8016728 <ipcp_nakci+0x954>
 8016508:	2328      	movs	r3, #40	; 0x28
 801650a:	18fb      	adds	r3, r7, r3
 801650c:	781b      	ldrb	r3, [r3, #0]
 801650e:	2201      	movs	r2, #1
 8016510:	4013      	ands	r3, r2
 8016512:	b2db      	uxtb	r3, r3
 8016514:	2b00      	cmp	r3, #0
 8016516:	d000      	beq.n	801651a <ipcp_nakci+0x746>
 8016518:	e106      	b.n	8016728 <ipcp_nakci+0x954>
 801651a:	235f      	movs	r3, #95	; 0x5f
 801651c:	18fb      	adds	r3, r7, r3
 801651e:	781b      	ldrb	r3, [r3, #0]
 8016520:	2b06      	cmp	r3, #6
 8016522:	d000      	beq.n	8016526 <ipcp_nakci+0x752>
 8016524:	e100      	b.n	8016728 <ipcp_nakci+0x954>
		goto bad;
	    try_.old_addrs = 0;
 8016526:	2410      	movs	r4, #16
 8016528:	193b      	adds	r3, r7, r4
 801652a:	781a      	ldrb	r2, [r3, #0]
 801652c:	2102      	movs	r1, #2
 801652e:	438a      	bics	r2, r1
 8016530:	701a      	strb	r2, [r3, #0]
	    GETLONG(l, p);
 8016532:	68bb      	ldr	r3, [r7, #8]
 8016534:	1c5a      	adds	r2, r3, #1
 8016536:	60ba      	str	r2, [r7, #8]
 8016538:	781b      	ldrb	r3, [r3, #0]
 801653a:	021b      	lsls	r3, r3, #8
 801653c:	65bb      	str	r3, [r7, #88]	; 0x58
 801653e:	68bb      	ldr	r3, [r7, #8]
 8016540:	1c5a      	adds	r2, r3, #1
 8016542:	60ba      	str	r2, [r7, #8]
 8016544:	781b      	ldrb	r3, [r3, #0]
 8016546:	001a      	movs	r2, r3
 8016548:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801654a:	4313      	orrs	r3, r2
 801654c:	65bb      	str	r3, [r7, #88]	; 0x58
 801654e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016550:	021b      	lsls	r3, r3, #8
 8016552:	65bb      	str	r3, [r7, #88]	; 0x58
 8016554:	68bb      	ldr	r3, [r7, #8]
 8016556:	1c5a      	adds	r2, r3, #1
 8016558:	60ba      	str	r2, [r7, #8]
 801655a:	781b      	ldrb	r3, [r3, #0]
 801655c:	001a      	movs	r2, r3
 801655e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016560:	4313      	orrs	r3, r2
 8016562:	65bb      	str	r3, [r7, #88]	; 0x58
 8016564:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016566:	021b      	lsls	r3, r3, #8
 8016568:	65bb      	str	r3, [r7, #88]	; 0x58
 801656a:	68bb      	ldr	r3, [r7, #8]
 801656c:	1c5a      	adds	r2, r3, #1
 801656e:	60ba      	str	r2, [r7, #8]
 8016570:	781b      	ldrb	r3, [r3, #0]
 8016572:	001a      	movs	r2, r3
 8016574:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016576:	4313      	orrs	r3, r2
 8016578:	65bb      	str	r3, [r7, #88]	; 0x58
	    ciaddr1 = lwip_htonl(l);
 801657a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801657c:	0018      	movs	r0, r3
 801657e:	f7f0 fb59 	bl	8006c34 <lwip_htonl>
 8016582:	0003      	movs	r3, r0
 8016584:	657b      	str	r3, [r7, #84]	; 0x54
	    if (ciaddr1 && go->accept_local)
 8016586:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016588:	2b00      	cmp	r3, #0
 801658a:	d009      	beq.n	80165a0 <ipcp_nakci+0x7cc>
 801658c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801658e:	781b      	ldrb	r3, [r3, #0]
 8016590:	2240      	movs	r2, #64	; 0x40
 8016592:	4013      	ands	r3, r2
 8016594:	b2db      	uxtb	r3, r3
 8016596:	2b00      	cmp	r3, #0
 8016598:	d002      	beq.n	80165a0 <ipcp_nakci+0x7cc>
		try_.ouraddr = ciaddr1;
 801659a:	193b      	adds	r3, r7, r4
 801659c:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801659e:	605a      	str	r2, [r3, #4]
	    if (try_.ouraddr != 0)
 80165a0:	2210      	movs	r2, #16
 80165a2:	18bb      	adds	r3, r7, r2
 80165a4:	685b      	ldr	r3, [r3, #4]
 80165a6:	2b00      	cmp	r3, #0
 80165a8:	d004      	beq.n	80165b4 <ipcp_nakci+0x7e0>
		try_.neg_addr = 1;
 80165aa:	18bb      	adds	r3, r7, r2
 80165ac:	781a      	ldrb	r2, [r3, #0]
 80165ae:	2101      	movs	r1, #1
 80165b0:	430a      	orrs	r2, r1
 80165b2:	701a      	strb	r2, [r3, #0]
	    no.neg_addr = 1;
 80165b4:	2328      	movs	r3, #40	; 0x28
 80165b6:	18fb      	adds	r3, r7, r3
 80165b8:	781a      	ldrb	r2, [r3, #0]
 80165ba:	2101      	movs	r1, #1
 80165bc:	430a      	orrs	r2, r1
 80165be:	701a      	strb	r2, [r3, #0]
	    break;
 80165c0:	e099      	b.n	80166f6 <ipcp_nakci+0x922>
#if LWIP_DNS
	case CI_MS_DNS1:
	    if (go->req_dns1 || no.req_dns1 || cilen != CILEN_ADDR)
 80165c2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80165c4:	785b      	ldrb	r3, [r3, #1]
 80165c6:	2201      	movs	r2, #1
 80165c8:	4013      	ands	r3, r2
 80165ca:	b2db      	uxtb	r3, r3
 80165cc:	2b00      	cmp	r3, #0
 80165ce:	d000      	beq.n	80165d2 <ipcp_nakci+0x7fe>
 80165d0:	e0ac      	b.n	801672c <ipcp_nakci+0x958>
 80165d2:	2428      	movs	r4, #40	; 0x28
 80165d4:	193b      	adds	r3, r7, r4
 80165d6:	785b      	ldrb	r3, [r3, #1]
 80165d8:	2201      	movs	r2, #1
 80165da:	4013      	ands	r3, r2
 80165dc:	b2db      	uxtb	r3, r3
 80165de:	2b00      	cmp	r3, #0
 80165e0:	d000      	beq.n	80165e4 <ipcp_nakci+0x810>
 80165e2:	e0a3      	b.n	801672c <ipcp_nakci+0x958>
 80165e4:	235f      	movs	r3, #95	; 0x5f
 80165e6:	18fb      	adds	r3, r7, r3
 80165e8:	781b      	ldrb	r3, [r3, #0]
 80165ea:	2b06      	cmp	r3, #6
 80165ec:	d000      	beq.n	80165f0 <ipcp_nakci+0x81c>
 80165ee:	e09d      	b.n	801672c <ipcp_nakci+0x958>
		goto bad;
	    GETLONG(l, p);
 80165f0:	68bb      	ldr	r3, [r7, #8]
 80165f2:	1c5a      	adds	r2, r3, #1
 80165f4:	60ba      	str	r2, [r7, #8]
 80165f6:	781b      	ldrb	r3, [r3, #0]
 80165f8:	021b      	lsls	r3, r3, #8
 80165fa:	65bb      	str	r3, [r7, #88]	; 0x58
 80165fc:	68bb      	ldr	r3, [r7, #8]
 80165fe:	1c5a      	adds	r2, r3, #1
 8016600:	60ba      	str	r2, [r7, #8]
 8016602:	781b      	ldrb	r3, [r3, #0]
 8016604:	001a      	movs	r2, r3
 8016606:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016608:	4313      	orrs	r3, r2
 801660a:	65bb      	str	r3, [r7, #88]	; 0x58
 801660c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801660e:	021b      	lsls	r3, r3, #8
 8016610:	65bb      	str	r3, [r7, #88]	; 0x58
 8016612:	68bb      	ldr	r3, [r7, #8]
 8016614:	1c5a      	adds	r2, r3, #1
 8016616:	60ba      	str	r2, [r7, #8]
 8016618:	781b      	ldrb	r3, [r3, #0]
 801661a:	001a      	movs	r2, r3
 801661c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801661e:	4313      	orrs	r3, r2
 8016620:	65bb      	str	r3, [r7, #88]	; 0x58
 8016622:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016624:	021b      	lsls	r3, r3, #8
 8016626:	65bb      	str	r3, [r7, #88]	; 0x58
 8016628:	68bb      	ldr	r3, [r7, #8]
 801662a:	1c5a      	adds	r2, r3, #1
 801662c:	60ba      	str	r2, [r7, #8]
 801662e:	781b      	ldrb	r3, [r3, #0]
 8016630:	001a      	movs	r2, r3
 8016632:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016634:	4313      	orrs	r3, r2
 8016636:	65bb      	str	r3, [r7, #88]	; 0x58
	    try_.dnsaddr[0] = lwip_htonl(l);
 8016638:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801663a:	0018      	movs	r0, r3
 801663c:	f7f0 fafa 	bl	8006c34 <lwip_htonl>
 8016640:	0002      	movs	r2, r0
 8016642:	2110      	movs	r1, #16
 8016644:	187b      	adds	r3, r7, r1
 8016646:	60da      	str	r2, [r3, #12]
	    try_.req_dns1 = 1;
 8016648:	187b      	adds	r3, r7, r1
 801664a:	785a      	ldrb	r2, [r3, #1]
 801664c:	2101      	movs	r1, #1
 801664e:	430a      	orrs	r2, r1
 8016650:	705a      	strb	r2, [r3, #1]
	    no.req_dns1 = 1;
 8016652:	193b      	adds	r3, r7, r4
 8016654:	785a      	ldrb	r2, [r3, #1]
 8016656:	2101      	movs	r1, #1
 8016658:	430a      	orrs	r2, r1
 801665a:	705a      	strb	r2, [r3, #1]
	    break;
 801665c:	e04b      	b.n	80166f6 <ipcp_nakci+0x922>
	case CI_MS_DNS2:
	    if (go->req_dns2 || no.req_dns2 || cilen != CILEN_ADDR)
 801665e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016660:	785b      	ldrb	r3, [r3, #1]
 8016662:	2202      	movs	r2, #2
 8016664:	4013      	ands	r3, r2
 8016666:	b2db      	uxtb	r3, r3
 8016668:	2b00      	cmp	r3, #0
 801666a:	d161      	bne.n	8016730 <ipcp_nakci+0x95c>
 801666c:	2428      	movs	r4, #40	; 0x28
 801666e:	193b      	adds	r3, r7, r4
 8016670:	785b      	ldrb	r3, [r3, #1]
 8016672:	2202      	movs	r2, #2
 8016674:	4013      	ands	r3, r2
 8016676:	b2db      	uxtb	r3, r3
 8016678:	2b00      	cmp	r3, #0
 801667a:	d159      	bne.n	8016730 <ipcp_nakci+0x95c>
 801667c:	235f      	movs	r3, #95	; 0x5f
 801667e:	18fb      	adds	r3, r7, r3
 8016680:	781b      	ldrb	r3, [r3, #0]
 8016682:	2b06      	cmp	r3, #6
 8016684:	d154      	bne.n	8016730 <ipcp_nakci+0x95c>
		goto bad;
	    GETLONG(l, p);
 8016686:	68bb      	ldr	r3, [r7, #8]
 8016688:	1c5a      	adds	r2, r3, #1
 801668a:	60ba      	str	r2, [r7, #8]
 801668c:	781b      	ldrb	r3, [r3, #0]
 801668e:	021b      	lsls	r3, r3, #8
 8016690:	65bb      	str	r3, [r7, #88]	; 0x58
 8016692:	68bb      	ldr	r3, [r7, #8]
 8016694:	1c5a      	adds	r2, r3, #1
 8016696:	60ba      	str	r2, [r7, #8]
 8016698:	781b      	ldrb	r3, [r3, #0]
 801669a:	001a      	movs	r2, r3
 801669c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801669e:	4313      	orrs	r3, r2
 80166a0:	65bb      	str	r3, [r7, #88]	; 0x58
 80166a2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80166a4:	021b      	lsls	r3, r3, #8
 80166a6:	65bb      	str	r3, [r7, #88]	; 0x58
 80166a8:	68bb      	ldr	r3, [r7, #8]
 80166aa:	1c5a      	adds	r2, r3, #1
 80166ac:	60ba      	str	r2, [r7, #8]
 80166ae:	781b      	ldrb	r3, [r3, #0]
 80166b0:	001a      	movs	r2, r3
 80166b2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80166b4:	4313      	orrs	r3, r2
 80166b6:	65bb      	str	r3, [r7, #88]	; 0x58
 80166b8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80166ba:	021b      	lsls	r3, r3, #8
 80166bc:	65bb      	str	r3, [r7, #88]	; 0x58
 80166be:	68bb      	ldr	r3, [r7, #8]
 80166c0:	1c5a      	adds	r2, r3, #1
 80166c2:	60ba      	str	r2, [r7, #8]
 80166c4:	781b      	ldrb	r3, [r3, #0]
 80166c6:	001a      	movs	r2, r3
 80166c8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80166ca:	4313      	orrs	r3, r2
 80166cc:	65bb      	str	r3, [r7, #88]	; 0x58
	    try_.dnsaddr[1] = lwip_htonl(l);
 80166ce:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80166d0:	0018      	movs	r0, r3
 80166d2:	f7f0 faaf 	bl	8006c34 <lwip_htonl>
 80166d6:	0002      	movs	r2, r0
 80166d8:	2110      	movs	r1, #16
 80166da:	187b      	adds	r3, r7, r1
 80166dc:	611a      	str	r2, [r3, #16]
	    try_.req_dns2 = 1;
 80166de:	187b      	adds	r3, r7, r1
 80166e0:	785a      	ldrb	r2, [r3, #1]
 80166e2:	2102      	movs	r1, #2
 80166e4:	430a      	orrs	r2, r1
 80166e6:	705a      	strb	r2, [r3, #1]
	    no.req_dns2 = 1;
 80166e8:	193b      	adds	r3, r7, r4
 80166ea:	785a      	ldrb	r2, [r3, #1]
 80166ec:	2102      	movs	r1, #2
 80166ee:	430a      	orrs	r2, r1
 80166f0:	705a      	strb	r2, [r3, #1]
	    break;
 80166f2:	e000      	b.n	80166f6 <ipcp_nakci+0x922>
	    if (ciaddr1)
		try_.winsaddr[citype == CI_MS_WINS2] = ciaddr1;
	    break;
#endif /* UNUSED - WINS */
	default:
	    break;
 80166f4:	46c0      	nop			; (mov r8, r8)
	}
	p = next;
 80166f6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80166f8:	60bb      	str	r3, [r7, #8]
    while (len >= CILEN_VOID) {
 80166fa:	687b      	ldr	r3, [r7, #4]
 80166fc:	2b01      	cmp	r3, #1
 80166fe:	dd00      	ble.n	8016702 <ipcp_nakci+0x92e>
 8016700:	e607      	b.n	8016312 <ipcp_nakci+0x53e>

    /*
     * OK, the Nak is good.  Now we can update state.
     * If there are any remaining options, we ignore them.
     */
    if (f->state != PPP_FSM_OPENED)
 8016702:	68fb      	ldr	r3, [r7, #12]
 8016704:	7c1b      	ldrb	r3, [r3, #16]
 8016706:	2b09      	cmp	r3, #9
 8016708:	d006      	beq.n	8016718 <ipcp_nakci+0x944>
	*go = try_;
 801670a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801670c:	2210      	movs	r2, #16
 801670e:	18ba      	adds	r2, r7, r2
 8016710:	ca13      	ldmia	r2!, {r0, r1, r4}
 8016712:	c313      	stmia	r3!, {r0, r1, r4}
 8016714:	ca13      	ldmia	r2!, {r0, r1, r4}
 8016716:	c313      	stmia	r3!, {r0, r1, r4}

    return 1;
 8016718:	2301      	movs	r3, #1
 801671a:	e00b      	b.n	8016734 <ipcp_nakci+0x960>
	    goto bad;
 801671c:	46c0      	nop			; (mov r8, r8)
 801671e:	e008      	b.n	8016732 <ipcp_nakci+0x95e>
		goto bad;
 8016720:	46c0      	nop			; (mov r8, r8)
 8016722:	e006      	b.n	8016732 <ipcp_nakci+0x95e>
		goto bad;
 8016724:	46c0      	nop			; (mov r8, r8)
 8016726:	e004      	b.n	8016732 <ipcp_nakci+0x95e>
		goto bad;
 8016728:	46c0      	nop			; (mov r8, r8)
 801672a:	e002      	b.n	8016732 <ipcp_nakci+0x95e>
		goto bad;
 801672c:	46c0      	nop			; (mov r8, r8)
 801672e:	e000      	b.n	8016732 <ipcp_nakci+0x95e>
		goto bad;
 8016730:	46c0      	nop			; (mov r8, r8)

bad:
    IPCPDEBUG(("ipcp_nakci: received bad Nak!"));
    return 0;
 8016732:	2300      	movs	r3, #0
}
 8016734:	0018      	movs	r0, r3
 8016736:	46bd      	mov	sp, r7
 8016738:	b01b      	add	sp, #108	; 0x6c
 801673a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0801673c <ipcp_rejci>:

/*
 * ipcp_rejci - Reject some of our CIs.
 * Callback from fsm_rconfnakrej.
 */
static int ipcp_rejci(fsm *f, u_char *p, int len) {
 801673c:	b5b0      	push	{r4, r5, r7, lr}
 801673e:	b094      	sub	sp, #80	; 0x50
 8016740:	af00      	add	r7, sp, #0
 8016742:	60f8      	str	r0, [r7, #12]
 8016744:	60b9      	str	r1, [r7, #8]
 8016746:	607a      	str	r2, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8016748:	68fb      	ldr	r3, [r7, #12]
 801674a:	681b      	ldr	r3, [r3, #0]
 801674c:	64fb      	str	r3, [r7, #76]	; 0x4c
    ipcp_options *go = &pcb->ipcp_gotoptions;
 801674e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8016750:	4a57      	ldr	r2, [pc, #348]	; (80168b0 <ipcp_rejci+0x174>)
 8016752:	4694      	mov	ip, r2
 8016754:	4463      	add	r3, ip
 8016756:	64bb      	str	r3, [r7, #72]	; 0x48
    u_short cishort;
#endif /* VJ_SUPPORT */
    u32_t cilong;
    ipcp_options try_;		/* options to request next time */

    try_ = *go;
 8016758:	2414      	movs	r4, #20
 801675a:	193b      	adds	r3, r7, r4
 801675c:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801675e:	ca23      	ldmia	r2!, {r0, r1, r5}
 8016760:	c323      	stmia	r3!, {r0, r1, r5}
 8016762:	ca23      	ldmia	r2!, {r0, r1, r5}
 8016764:	c323      	stmia	r3!, {r0, r1, r5}
	    goto bad; \
	try_.winsaddr[opt == CI_MS_WINS2] = 0; \
    }
#endif /* UNUSED - WINS */

    REJCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs,
 8016766:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016768:	781b      	ldrb	r3, [r3, #0]
 801676a:	2201      	movs	r2, #1
 801676c:	4013      	ands	r3, r2
 801676e:	b2db      	uxtb	r3, r3
 8016770:	2b00      	cmp	r3, #0
 8016772:	d000      	beq.n	8016776 <ipcp_rejci+0x3a>
 8016774:	e086      	b.n	8016884 <ipcp_rejci+0x148>
 8016776:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016778:	781b      	ldrb	r3, [r3, #0]
 801677a:	2202      	movs	r2, #2
 801677c:	4013      	ands	r3, r2
 801677e:	b2db      	uxtb	r3, r3
 8016780:	2b00      	cmp	r3, #0
 8016782:	d100      	bne.n	8016786 <ipcp_rejci+0x4a>
 8016784:	e07e      	b.n	8016884 <ipcp_rejci+0x148>
 8016786:	2147      	movs	r1, #71	; 0x47
 8016788:	187b      	adds	r3, r7, r1
 801678a:	68ba      	ldr	r2, [r7, #8]
 801678c:	7852      	ldrb	r2, [r2, #1]
 801678e:	701a      	strb	r2, [r3, #0]
 8016790:	187b      	adds	r3, r7, r1
 8016792:	781b      	ldrb	r3, [r3, #0]
 8016794:	2b0a      	cmp	r3, #10
 8016796:	d175      	bne.n	8016884 <ipcp_rejci+0x148>
 8016798:	187b      	adds	r3, r7, r1
 801679a:	781b      	ldrb	r3, [r3, #0]
 801679c:	687a      	ldr	r2, [r7, #4]
 801679e:	429a      	cmp	r2, r3
 80167a0:	db70      	blt.n	8016884 <ipcp_rejci+0x148>
 80167a2:	68bb      	ldr	r3, [r7, #8]
 80167a4:	781b      	ldrb	r3, [r3, #0]
 80167a6:	2b01      	cmp	r3, #1
 80167a8:	d16c      	bne.n	8016884 <ipcp_rejci+0x148>
 80167aa:	187b      	adds	r3, r7, r1
 80167ac:	781b      	ldrb	r3, [r3, #0]
 80167ae:	687a      	ldr	r2, [r7, #4]
 80167b0:	1ad3      	subs	r3, r2, r3
 80167b2:	607b      	str	r3, [r7, #4]
 80167b4:	68bb      	ldr	r3, [r7, #8]
 80167b6:	3302      	adds	r3, #2
 80167b8:	60bb      	str	r3, [r7, #8]
 80167ba:	68bb      	ldr	r3, [r7, #8]
 80167bc:	1c5a      	adds	r2, r3, #1
 80167be:	60ba      	str	r2, [r7, #8]
 80167c0:	781b      	ldrb	r3, [r3, #0]
 80167c2:	021b      	lsls	r3, r3, #8
 80167c4:	643b      	str	r3, [r7, #64]	; 0x40
 80167c6:	68bb      	ldr	r3, [r7, #8]
 80167c8:	1c5a      	adds	r2, r3, #1
 80167ca:	60ba      	str	r2, [r7, #8]
 80167cc:	781b      	ldrb	r3, [r3, #0]
 80167ce:	001a      	movs	r2, r3
 80167d0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80167d2:	4313      	orrs	r3, r2
 80167d4:	643b      	str	r3, [r7, #64]	; 0x40
 80167d6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80167d8:	021b      	lsls	r3, r3, #8
 80167da:	643b      	str	r3, [r7, #64]	; 0x40
 80167dc:	68bb      	ldr	r3, [r7, #8]
 80167de:	1c5a      	adds	r2, r3, #1
 80167e0:	60ba      	str	r2, [r7, #8]
 80167e2:	781b      	ldrb	r3, [r3, #0]
 80167e4:	001a      	movs	r2, r3
 80167e6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80167e8:	4313      	orrs	r3, r2
 80167ea:	643b      	str	r3, [r7, #64]	; 0x40
 80167ec:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80167ee:	021b      	lsls	r3, r3, #8
 80167f0:	643b      	str	r3, [r7, #64]	; 0x40
 80167f2:	68bb      	ldr	r3, [r7, #8]
 80167f4:	1c5a      	adds	r2, r3, #1
 80167f6:	60ba      	str	r2, [r7, #8]
 80167f8:	781b      	ldrb	r3, [r3, #0]
 80167fa:	001a      	movs	r2, r3
 80167fc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80167fe:	4313      	orrs	r3, r2
 8016800:	643b      	str	r3, [r7, #64]	; 0x40
 8016802:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016804:	0018      	movs	r0, r3
 8016806:	f7f0 fa15 	bl	8006c34 <lwip_htonl>
 801680a:	0003      	movs	r3, r0
 801680c:	63fb      	str	r3, [r7, #60]	; 0x3c
 801680e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016810:	685b      	ldr	r3, [r3, #4]
 8016812:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8016814:	429a      	cmp	r2, r3
 8016816:	d000      	beq.n	801681a <ipcp_rejci+0xde>
 8016818:	e1bf      	b.n	8016b9a <ipcp_rejci+0x45e>
 801681a:	68bb      	ldr	r3, [r7, #8]
 801681c:	1c5a      	adds	r2, r3, #1
 801681e:	60ba      	str	r2, [r7, #8]
 8016820:	781b      	ldrb	r3, [r3, #0]
 8016822:	021b      	lsls	r3, r3, #8
 8016824:	643b      	str	r3, [r7, #64]	; 0x40
 8016826:	68bb      	ldr	r3, [r7, #8]
 8016828:	1c5a      	adds	r2, r3, #1
 801682a:	60ba      	str	r2, [r7, #8]
 801682c:	781b      	ldrb	r3, [r3, #0]
 801682e:	001a      	movs	r2, r3
 8016830:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016832:	4313      	orrs	r3, r2
 8016834:	643b      	str	r3, [r7, #64]	; 0x40
 8016836:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016838:	021b      	lsls	r3, r3, #8
 801683a:	643b      	str	r3, [r7, #64]	; 0x40
 801683c:	68bb      	ldr	r3, [r7, #8]
 801683e:	1c5a      	adds	r2, r3, #1
 8016840:	60ba      	str	r2, [r7, #8]
 8016842:	781b      	ldrb	r3, [r3, #0]
 8016844:	001a      	movs	r2, r3
 8016846:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016848:	4313      	orrs	r3, r2
 801684a:	643b      	str	r3, [r7, #64]	; 0x40
 801684c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801684e:	021b      	lsls	r3, r3, #8
 8016850:	643b      	str	r3, [r7, #64]	; 0x40
 8016852:	68bb      	ldr	r3, [r7, #8]
 8016854:	1c5a      	adds	r2, r3, #1
 8016856:	60ba      	str	r2, [r7, #8]
 8016858:	781b      	ldrb	r3, [r3, #0]
 801685a:	001a      	movs	r2, r3
 801685c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801685e:	4313      	orrs	r3, r2
 8016860:	643b      	str	r3, [r7, #64]	; 0x40
 8016862:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016864:	0018      	movs	r0, r3
 8016866:	f7f0 f9e5 	bl	8006c34 <lwip_htonl>
 801686a:	0003      	movs	r3, r0
 801686c:	63fb      	str	r3, [r7, #60]	; 0x3c
 801686e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016870:	689b      	ldr	r3, [r3, #8]
 8016872:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8016874:	429a      	cmp	r2, r3
 8016876:	d000      	beq.n	801687a <ipcp_rejci+0x13e>
 8016878:	e191      	b.n	8016b9e <ipcp_rejci+0x462>
 801687a:	193b      	adds	r3, r7, r4
 801687c:	781a      	ldrb	r2, [r3, #0]
 801687e:	2102      	movs	r1, #2
 8016880:	438a      	bics	r2, r1
 8016882:	701a      	strb	r2, [r3, #0]
	       go->ouraddr, go->hisaddr);

#if VJ_SUPPORT
    REJCIVJ(CI_COMPRESSTYPE, neg_vj, go->vj_protocol, go->old_vj,
 8016884:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016886:	781b      	ldrb	r3, [r3, #0]
 8016888:	2208      	movs	r2, #8
 801688a:	4013      	ands	r3, r2
 801688c:	b2db      	uxtb	r3, r3
 801688e:	2b00      	cmp	r3, #0
 8016890:	d100      	bne.n	8016894 <ipcp_rejci+0x158>
 8016892:	e06e      	b.n	8016972 <ipcp_rejci+0x236>
 8016894:	68bb      	ldr	r3, [r7, #8]
 8016896:	3301      	adds	r3, #1
 8016898:	781b      	ldrb	r3, [r3, #0]
 801689a:	0019      	movs	r1, r3
 801689c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801689e:	781b      	ldrb	r3, [r3, #0]
 80168a0:	2210      	movs	r2, #16
 80168a2:	4013      	ands	r3, r2
 80168a4:	b2db      	uxtb	r3, r3
 80168a6:	2b00      	cmp	r3, #0
 80168a8:	d004      	beq.n	80168b4 <ipcp_rejci+0x178>
 80168aa:	2304      	movs	r3, #4
 80168ac:	e003      	b.n	80168b6 <ipcp_rejci+0x17a>
 80168ae:	46c0      	nop			; (mov r8, r8)
 80168b0:	0000121c 	.word	0x0000121c
 80168b4:	2306      	movs	r3, #6
 80168b6:	428b      	cmp	r3, r1
 80168b8:	d15b      	bne.n	8016972 <ipcp_rejci+0x236>
 80168ba:	68bb      	ldr	r3, [r7, #8]
 80168bc:	3301      	adds	r3, #1
 80168be:	781b      	ldrb	r3, [r3, #0]
 80168c0:	001a      	movs	r2, r3
 80168c2:	687b      	ldr	r3, [r7, #4]
 80168c4:	4293      	cmp	r3, r2
 80168c6:	db54      	blt.n	8016972 <ipcp_rejci+0x236>
 80168c8:	68bb      	ldr	r3, [r7, #8]
 80168ca:	781b      	ldrb	r3, [r3, #0]
 80168cc:	2b02      	cmp	r3, #2
 80168ce:	d150      	bne.n	8016972 <ipcp_rejci+0x236>
 80168d0:	68bb      	ldr	r3, [r7, #8]
 80168d2:	3301      	adds	r3, #1
 80168d4:	781b      	ldrb	r3, [r3, #0]
 80168d6:	001a      	movs	r2, r3
 80168d8:	687b      	ldr	r3, [r7, #4]
 80168da:	1a9b      	subs	r3, r3, r2
 80168dc:	607b      	str	r3, [r7, #4]
 80168de:	68bb      	ldr	r3, [r7, #8]
 80168e0:	3302      	adds	r3, #2
 80168e2:	60bb      	str	r3, [r7, #8]
 80168e4:	68bb      	ldr	r3, [r7, #8]
 80168e6:	1c5a      	adds	r2, r3, #1
 80168e8:	60ba      	str	r2, [r7, #8]
 80168ea:	781b      	ldrb	r3, [r3, #0]
 80168ec:	b29a      	uxth	r2, r3
 80168ee:	203a      	movs	r0, #58	; 0x3a
 80168f0:	183b      	adds	r3, r7, r0
 80168f2:	0212      	lsls	r2, r2, #8
 80168f4:	801a      	strh	r2, [r3, #0]
 80168f6:	68bb      	ldr	r3, [r7, #8]
 80168f8:	1c5a      	adds	r2, r3, #1
 80168fa:	60ba      	str	r2, [r7, #8]
 80168fc:	781b      	ldrb	r3, [r3, #0]
 80168fe:	b299      	uxth	r1, r3
 8016900:	183b      	adds	r3, r7, r0
 8016902:	183a      	adds	r2, r7, r0
 8016904:	8812      	ldrh	r2, [r2, #0]
 8016906:	430a      	orrs	r2, r1
 8016908:	801a      	strh	r2, [r3, #0]
 801690a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801690c:	8a9b      	ldrh	r3, [r3, #20]
 801690e:	183a      	adds	r2, r7, r0
 8016910:	8812      	ldrh	r2, [r2, #0]
 8016912:	429a      	cmp	r2, r3
 8016914:	d000      	beq.n	8016918 <ipcp_rejci+0x1dc>
 8016916:	e144      	b.n	8016ba2 <ipcp_rejci+0x466>
 8016918:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801691a:	781b      	ldrb	r3, [r3, #0]
 801691c:	2210      	movs	r2, #16
 801691e:	4013      	ands	r3, r2
 8016920:	b2db      	uxtb	r3, r3
 8016922:	2b00      	cmp	r3, #0
 8016924:	d11f      	bne.n	8016966 <ipcp_rejci+0x22a>
 8016926:	68bb      	ldr	r3, [r7, #8]
 8016928:	1c5a      	adds	r2, r3, #1
 801692a:	60ba      	str	r2, [r7, #8]
 801692c:	2139      	movs	r1, #57	; 0x39
 801692e:	187a      	adds	r2, r7, r1
 8016930:	781b      	ldrb	r3, [r3, #0]
 8016932:	7013      	strb	r3, [r2, #0]
 8016934:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016936:	7d9b      	ldrb	r3, [r3, #22]
 8016938:	187a      	adds	r2, r7, r1
 801693a:	7812      	ldrb	r2, [r2, #0]
 801693c:	429a      	cmp	r2, r3
 801693e:	d000      	beq.n	8016942 <ipcp_rejci+0x206>
 8016940:	e131      	b.n	8016ba6 <ipcp_rejci+0x46a>
 8016942:	68bb      	ldr	r3, [r7, #8]
 8016944:	1c5a      	adds	r2, r3, #1
 8016946:	60ba      	str	r2, [r7, #8]
 8016948:	2138      	movs	r1, #56	; 0x38
 801694a:	187a      	adds	r2, r7, r1
 801694c:	781b      	ldrb	r3, [r3, #0]
 801694e:	7013      	strb	r3, [r2, #0]
 8016950:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016952:	781b      	ldrb	r3, [r3, #0]
 8016954:	069b      	lsls	r3, r3, #26
 8016956:	0fdb      	lsrs	r3, r3, #31
 8016958:	b2db      	uxtb	r3, r3
 801695a:	001a      	movs	r2, r3
 801695c:	187b      	adds	r3, r7, r1
 801695e:	781b      	ldrb	r3, [r3, #0]
 8016960:	4293      	cmp	r3, r2
 8016962:	d000      	beq.n	8016966 <ipcp_rejci+0x22a>
 8016964:	e121      	b.n	8016baa <ipcp_rejci+0x46e>
 8016966:	2314      	movs	r3, #20
 8016968:	18fb      	adds	r3, r7, r3
 801696a:	781a      	ldrb	r2, [r3, #0]
 801696c:	2108      	movs	r1, #8
 801696e:	438a      	bics	r2, r1
 8016970:	701a      	strb	r2, [r3, #0]
	    go->maxslotindex, go->cflag);
#endif /* VJ_SUPPORT */

    REJCIADDR(CI_ADDR, neg_addr, go->ouraddr);
 8016972:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016974:	781b      	ldrb	r3, [r3, #0]
 8016976:	2201      	movs	r2, #1
 8016978:	4013      	ands	r3, r2
 801697a:	b2db      	uxtb	r3, r3
 801697c:	2b00      	cmp	r3, #0
 801697e:	d04f      	beq.n	8016a20 <ipcp_rejci+0x2e4>
 8016980:	2147      	movs	r1, #71	; 0x47
 8016982:	187b      	adds	r3, r7, r1
 8016984:	68ba      	ldr	r2, [r7, #8]
 8016986:	7852      	ldrb	r2, [r2, #1]
 8016988:	701a      	strb	r2, [r3, #0]
 801698a:	187b      	adds	r3, r7, r1
 801698c:	781b      	ldrb	r3, [r3, #0]
 801698e:	2b06      	cmp	r3, #6
 8016990:	d146      	bne.n	8016a20 <ipcp_rejci+0x2e4>
 8016992:	187b      	adds	r3, r7, r1
 8016994:	781b      	ldrb	r3, [r3, #0]
 8016996:	687a      	ldr	r2, [r7, #4]
 8016998:	429a      	cmp	r2, r3
 801699a:	db41      	blt.n	8016a20 <ipcp_rejci+0x2e4>
 801699c:	68bb      	ldr	r3, [r7, #8]
 801699e:	781b      	ldrb	r3, [r3, #0]
 80169a0:	2b03      	cmp	r3, #3
 80169a2:	d13d      	bne.n	8016a20 <ipcp_rejci+0x2e4>
 80169a4:	187b      	adds	r3, r7, r1
 80169a6:	781b      	ldrb	r3, [r3, #0]
 80169a8:	687a      	ldr	r2, [r7, #4]
 80169aa:	1ad3      	subs	r3, r2, r3
 80169ac:	607b      	str	r3, [r7, #4]
 80169ae:	68bb      	ldr	r3, [r7, #8]
 80169b0:	3302      	adds	r3, #2
 80169b2:	60bb      	str	r3, [r7, #8]
 80169b4:	68bb      	ldr	r3, [r7, #8]
 80169b6:	1c5a      	adds	r2, r3, #1
 80169b8:	60ba      	str	r2, [r7, #8]
 80169ba:	781b      	ldrb	r3, [r3, #0]
 80169bc:	021b      	lsls	r3, r3, #8
 80169be:	637b      	str	r3, [r7, #52]	; 0x34
 80169c0:	68bb      	ldr	r3, [r7, #8]
 80169c2:	1c5a      	adds	r2, r3, #1
 80169c4:	60ba      	str	r2, [r7, #8]
 80169c6:	781b      	ldrb	r3, [r3, #0]
 80169c8:	001a      	movs	r2, r3
 80169ca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80169cc:	4313      	orrs	r3, r2
 80169ce:	637b      	str	r3, [r7, #52]	; 0x34
 80169d0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80169d2:	021b      	lsls	r3, r3, #8
 80169d4:	637b      	str	r3, [r7, #52]	; 0x34
 80169d6:	68bb      	ldr	r3, [r7, #8]
 80169d8:	1c5a      	adds	r2, r3, #1
 80169da:	60ba      	str	r2, [r7, #8]
 80169dc:	781b      	ldrb	r3, [r3, #0]
 80169de:	001a      	movs	r2, r3
 80169e0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80169e2:	4313      	orrs	r3, r2
 80169e4:	637b      	str	r3, [r7, #52]	; 0x34
 80169e6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80169e8:	021b      	lsls	r3, r3, #8
 80169ea:	637b      	str	r3, [r7, #52]	; 0x34
 80169ec:	68bb      	ldr	r3, [r7, #8]
 80169ee:	1c5a      	adds	r2, r3, #1
 80169f0:	60ba      	str	r2, [r7, #8]
 80169f2:	781b      	ldrb	r3, [r3, #0]
 80169f4:	001a      	movs	r2, r3
 80169f6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80169f8:	4313      	orrs	r3, r2
 80169fa:	637b      	str	r3, [r7, #52]	; 0x34
 80169fc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80169fe:	0018      	movs	r0, r3
 8016a00:	f7f0 f918 	bl	8006c34 <lwip_htonl>
 8016a04:	0003      	movs	r3, r0
 8016a06:	63fb      	str	r3, [r7, #60]	; 0x3c
 8016a08:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016a0a:	685b      	ldr	r3, [r3, #4]
 8016a0c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8016a0e:	429a      	cmp	r2, r3
 8016a10:	d000      	beq.n	8016a14 <ipcp_rejci+0x2d8>
 8016a12:	e0cc      	b.n	8016bae <ipcp_rejci+0x472>
 8016a14:	2314      	movs	r3, #20
 8016a16:	18fb      	adds	r3, r7, r3
 8016a18:	781a      	ldrb	r2, [r3, #0]
 8016a1a:	2101      	movs	r1, #1
 8016a1c:	438a      	bics	r2, r1
 8016a1e:	701a      	strb	r2, [r3, #0]

#if LWIP_DNS
    REJCIDNS(CI_MS_DNS1, req_dns1, go->dnsaddr[0]);
 8016a20:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016a22:	785b      	ldrb	r3, [r3, #1]
 8016a24:	2201      	movs	r2, #1
 8016a26:	4013      	ands	r3, r2
 8016a28:	b2db      	uxtb	r3, r3
 8016a2a:	2b00      	cmp	r3, #0
 8016a2c:	d04f      	beq.n	8016ace <ipcp_rejci+0x392>
 8016a2e:	2147      	movs	r1, #71	; 0x47
 8016a30:	187b      	adds	r3, r7, r1
 8016a32:	68ba      	ldr	r2, [r7, #8]
 8016a34:	7852      	ldrb	r2, [r2, #1]
 8016a36:	701a      	strb	r2, [r3, #0]
 8016a38:	187b      	adds	r3, r7, r1
 8016a3a:	781b      	ldrb	r3, [r3, #0]
 8016a3c:	2b06      	cmp	r3, #6
 8016a3e:	d146      	bne.n	8016ace <ipcp_rejci+0x392>
 8016a40:	187b      	adds	r3, r7, r1
 8016a42:	781b      	ldrb	r3, [r3, #0]
 8016a44:	687a      	ldr	r2, [r7, #4]
 8016a46:	429a      	cmp	r2, r3
 8016a48:	db41      	blt.n	8016ace <ipcp_rejci+0x392>
 8016a4a:	68bb      	ldr	r3, [r7, #8]
 8016a4c:	781b      	ldrb	r3, [r3, #0]
 8016a4e:	2b81      	cmp	r3, #129	; 0x81
 8016a50:	d13d      	bne.n	8016ace <ipcp_rejci+0x392>
 8016a52:	187b      	adds	r3, r7, r1
 8016a54:	781b      	ldrb	r3, [r3, #0]
 8016a56:	687a      	ldr	r2, [r7, #4]
 8016a58:	1ad3      	subs	r3, r2, r3
 8016a5a:	607b      	str	r3, [r7, #4]
 8016a5c:	68bb      	ldr	r3, [r7, #8]
 8016a5e:	3302      	adds	r3, #2
 8016a60:	60bb      	str	r3, [r7, #8]
 8016a62:	68bb      	ldr	r3, [r7, #8]
 8016a64:	1c5a      	adds	r2, r3, #1
 8016a66:	60ba      	str	r2, [r7, #8]
 8016a68:	781b      	ldrb	r3, [r3, #0]
 8016a6a:	021b      	lsls	r3, r3, #8
 8016a6c:	633b      	str	r3, [r7, #48]	; 0x30
 8016a6e:	68bb      	ldr	r3, [r7, #8]
 8016a70:	1c5a      	adds	r2, r3, #1
 8016a72:	60ba      	str	r2, [r7, #8]
 8016a74:	781b      	ldrb	r3, [r3, #0]
 8016a76:	001a      	movs	r2, r3
 8016a78:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016a7a:	4313      	orrs	r3, r2
 8016a7c:	633b      	str	r3, [r7, #48]	; 0x30
 8016a7e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016a80:	021b      	lsls	r3, r3, #8
 8016a82:	633b      	str	r3, [r7, #48]	; 0x30
 8016a84:	68bb      	ldr	r3, [r7, #8]
 8016a86:	1c5a      	adds	r2, r3, #1
 8016a88:	60ba      	str	r2, [r7, #8]
 8016a8a:	781b      	ldrb	r3, [r3, #0]
 8016a8c:	001a      	movs	r2, r3
 8016a8e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016a90:	4313      	orrs	r3, r2
 8016a92:	633b      	str	r3, [r7, #48]	; 0x30
 8016a94:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016a96:	021b      	lsls	r3, r3, #8
 8016a98:	633b      	str	r3, [r7, #48]	; 0x30
 8016a9a:	68bb      	ldr	r3, [r7, #8]
 8016a9c:	1c5a      	adds	r2, r3, #1
 8016a9e:	60ba      	str	r2, [r7, #8]
 8016aa0:	781b      	ldrb	r3, [r3, #0]
 8016aa2:	001a      	movs	r2, r3
 8016aa4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016aa6:	4313      	orrs	r3, r2
 8016aa8:	633b      	str	r3, [r7, #48]	; 0x30
 8016aaa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016aac:	0018      	movs	r0, r3
 8016aae:	f7f0 f8c1 	bl	8006c34 <lwip_htonl>
 8016ab2:	0003      	movs	r3, r0
 8016ab4:	63fb      	str	r3, [r7, #60]	; 0x3c
 8016ab6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016ab8:	68db      	ldr	r3, [r3, #12]
 8016aba:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8016abc:	429a      	cmp	r2, r3
 8016abe:	d000      	beq.n	8016ac2 <ipcp_rejci+0x386>
 8016ac0:	e077      	b.n	8016bb2 <ipcp_rejci+0x476>
 8016ac2:	2314      	movs	r3, #20
 8016ac4:	18fb      	adds	r3, r7, r3
 8016ac6:	785a      	ldrb	r2, [r3, #1]
 8016ac8:	2101      	movs	r1, #1
 8016aca:	438a      	bics	r2, r1
 8016acc:	705a      	strb	r2, [r3, #1]

    REJCIDNS(CI_MS_DNS2, req_dns2, go->dnsaddr[1]);
 8016ace:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016ad0:	785b      	ldrb	r3, [r3, #1]
 8016ad2:	2202      	movs	r2, #2
 8016ad4:	4013      	ands	r3, r2
 8016ad6:	b2db      	uxtb	r3, r3
 8016ad8:	2b00      	cmp	r3, #0
 8016ada:	d04e      	beq.n	8016b7a <ipcp_rejci+0x43e>
 8016adc:	2147      	movs	r1, #71	; 0x47
 8016ade:	187b      	adds	r3, r7, r1
 8016ae0:	68ba      	ldr	r2, [r7, #8]
 8016ae2:	7852      	ldrb	r2, [r2, #1]
 8016ae4:	701a      	strb	r2, [r3, #0]
 8016ae6:	187b      	adds	r3, r7, r1
 8016ae8:	781b      	ldrb	r3, [r3, #0]
 8016aea:	2b06      	cmp	r3, #6
 8016aec:	d145      	bne.n	8016b7a <ipcp_rejci+0x43e>
 8016aee:	187b      	adds	r3, r7, r1
 8016af0:	781b      	ldrb	r3, [r3, #0]
 8016af2:	687a      	ldr	r2, [r7, #4]
 8016af4:	429a      	cmp	r2, r3
 8016af6:	db40      	blt.n	8016b7a <ipcp_rejci+0x43e>
 8016af8:	68bb      	ldr	r3, [r7, #8]
 8016afa:	781b      	ldrb	r3, [r3, #0]
 8016afc:	2b83      	cmp	r3, #131	; 0x83
 8016afe:	d13c      	bne.n	8016b7a <ipcp_rejci+0x43e>
 8016b00:	187b      	adds	r3, r7, r1
 8016b02:	781b      	ldrb	r3, [r3, #0]
 8016b04:	687a      	ldr	r2, [r7, #4]
 8016b06:	1ad3      	subs	r3, r2, r3
 8016b08:	607b      	str	r3, [r7, #4]
 8016b0a:	68bb      	ldr	r3, [r7, #8]
 8016b0c:	3302      	adds	r3, #2
 8016b0e:	60bb      	str	r3, [r7, #8]
 8016b10:	68bb      	ldr	r3, [r7, #8]
 8016b12:	1c5a      	adds	r2, r3, #1
 8016b14:	60ba      	str	r2, [r7, #8]
 8016b16:	781b      	ldrb	r3, [r3, #0]
 8016b18:	021b      	lsls	r3, r3, #8
 8016b1a:	62fb      	str	r3, [r7, #44]	; 0x2c
 8016b1c:	68bb      	ldr	r3, [r7, #8]
 8016b1e:	1c5a      	adds	r2, r3, #1
 8016b20:	60ba      	str	r2, [r7, #8]
 8016b22:	781b      	ldrb	r3, [r3, #0]
 8016b24:	001a      	movs	r2, r3
 8016b26:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016b28:	4313      	orrs	r3, r2
 8016b2a:	62fb      	str	r3, [r7, #44]	; 0x2c
 8016b2c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016b2e:	021b      	lsls	r3, r3, #8
 8016b30:	62fb      	str	r3, [r7, #44]	; 0x2c
 8016b32:	68bb      	ldr	r3, [r7, #8]
 8016b34:	1c5a      	adds	r2, r3, #1
 8016b36:	60ba      	str	r2, [r7, #8]
 8016b38:	781b      	ldrb	r3, [r3, #0]
 8016b3a:	001a      	movs	r2, r3
 8016b3c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016b3e:	4313      	orrs	r3, r2
 8016b40:	62fb      	str	r3, [r7, #44]	; 0x2c
 8016b42:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016b44:	021b      	lsls	r3, r3, #8
 8016b46:	62fb      	str	r3, [r7, #44]	; 0x2c
 8016b48:	68bb      	ldr	r3, [r7, #8]
 8016b4a:	1c5a      	adds	r2, r3, #1
 8016b4c:	60ba      	str	r2, [r7, #8]
 8016b4e:	781b      	ldrb	r3, [r3, #0]
 8016b50:	001a      	movs	r2, r3
 8016b52:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016b54:	4313      	orrs	r3, r2
 8016b56:	62fb      	str	r3, [r7, #44]	; 0x2c
 8016b58:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016b5a:	0018      	movs	r0, r3
 8016b5c:	f7f0 f86a 	bl	8006c34 <lwip_htonl>
 8016b60:	0003      	movs	r3, r0
 8016b62:	63fb      	str	r3, [r7, #60]	; 0x3c
 8016b64:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016b66:	691b      	ldr	r3, [r3, #16]
 8016b68:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8016b6a:	429a      	cmp	r2, r3
 8016b6c:	d123      	bne.n	8016bb6 <ipcp_rejci+0x47a>
 8016b6e:	2314      	movs	r3, #20
 8016b70:	18fb      	adds	r3, r7, r3
 8016b72:	785a      	ldrb	r2, [r3, #1]
 8016b74:	2102      	movs	r1, #2
 8016b76:	438a      	bics	r2, r1
 8016b78:	705a      	strb	r2, [r3, #1]
#endif /* UNUSED - WINS */

    /*
     * If there are any remaining CIs, then this packet is bad.
     */
    if (len != 0)
 8016b7a:	687b      	ldr	r3, [r7, #4]
 8016b7c:	2b00      	cmp	r3, #0
 8016b7e:	d11c      	bne.n	8016bba <ipcp_rejci+0x47e>
	goto bad;
    /*
     * Now we can update state.
     */
    if (f->state != PPP_FSM_OPENED)
 8016b80:	68fb      	ldr	r3, [r7, #12]
 8016b82:	7c1b      	ldrb	r3, [r3, #16]
 8016b84:	2b09      	cmp	r3, #9
 8016b86:	d006      	beq.n	8016b96 <ipcp_rejci+0x45a>
	*go = try_;
 8016b88:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016b8a:	2214      	movs	r2, #20
 8016b8c:	18ba      	adds	r2, r7, r2
 8016b8e:	ca13      	ldmia	r2!, {r0, r1, r4}
 8016b90:	c313      	stmia	r3!, {r0, r1, r4}
 8016b92:	ca13      	ldmia	r2!, {r0, r1, r4}
 8016b94:	c313      	stmia	r3!, {r0, r1, r4}
    return 1;
 8016b96:	2301      	movs	r3, #1
 8016b98:	e011      	b.n	8016bbe <ipcp_rejci+0x482>
    REJCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs,
 8016b9a:	46c0      	nop			; (mov r8, r8)
 8016b9c:	e00e      	b.n	8016bbc <ipcp_rejci+0x480>
 8016b9e:	46c0      	nop			; (mov r8, r8)
 8016ba0:	e00c      	b.n	8016bbc <ipcp_rejci+0x480>
    REJCIVJ(CI_COMPRESSTYPE, neg_vj, go->vj_protocol, go->old_vj,
 8016ba2:	46c0      	nop			; (mov r8, r8)
 8016ba4:	e00a      	b.n	8016bbc <ipcp_rejci+0x480>
 8016ba6:	46c0      	nop			; (mov r8, r8)
 8016ba8:	e008      	b.n	8016bbc <ipcp_rejci+0x480>
 8016baa:	46c0      	nop			; (mov r8, r8)
 8016bac:	e006      	b.n	8016bbc <ipcp_rejci+0x480>
    REJCIADDR(CI_ADDR, neg_addr, go->ouraddr);
 8016bae:	46c0      	nop			; (mov r8, r8)
 8016bb0:	e004      	b.n	8016bbc <ipcp_rejci+0x480>
    REJCIDNS(CI_MS_DNS1, req_dns1, go->dnsaddr[0]);
 8016bb2:	46c0      	nop			; (mov r8, r8)
 8016bb4:	e002      	b.n	8016bbc <ipcp_rejci+0x480>
    REJCIDNS(CI_MS_DNS2, req_dns2, go->dnsaddr[1]);
 8016bb6:	46c0      	nop			; (mov r8, r8)
 8016bb8:	e000      	b.n	8016bbc <ipcp_rejci+0x480>
	goto bad;
 8016bba:	46c0      	nop			; (mov r8, r8)

bad:
    IPCPDEBUG(("ipcp_rejci: received bad Reject!"));
    return 0;
 8016bbc:	2300      	movs	r3, #0
}
 8016bbe:	0018      	movs	r0, r3
 8016bc0:	46bd      	mov	sp, r7
 8016bc2:	b014      	add	sp, #80	; 0x50
 8016bc4:	bdb0      	pop	{r4, r5, r7, pc}
 8016bc6:	46c0      	nop			; (mov r8, r8)

08016bc8 <ipcp_reqci>:
 * CONFNAK; returns CONFREJ if it can't return CONFACK.
 *
 * inp = Requested CIs
 * len = Length of requested CIs
 */
static int ipcp_reqci(fsm *f, u_char *inp, int *len, int reject_if_disagree) {
 8016bc8:	b580      	push	{r7, lr}
 8016bca:	b096      	sub	sp, #88	; 0x58
 8016bcc:	af00      	add	r7, sp, #0
 8016bce:	60f8      	str	r0, [r7, #12]
 8016bd0:	60b9      	str	r1, [r7, #8]
 8016bd2:	607a      	str	r2, [r7, #4]
 8016bd4:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 8016bd6:	68fb      	ldr	r3, [r7, #12]
 8016bd8:	681b      	ldr	r3, [r3, #0]
 8016bda:	63bb      	str	r3, [r7, #56]	; 0x38
    ipcp_options *wo = &pcb->ipcp_wantoptions;
 8016bdc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016bde:	4abe      	ldr	r2, [pc, #760]	; (8016ed8 <ipcp_reqci+0x310>)
 8016be0:	4694      	mov	ip, r2
 8016be2:	4463      	add	r3, ip
 8016be4:	637b      	str	r3, [r7, #52]	; 0x34
    ipcp_options *ho = &pcb->ipcp_hisoptions;
 8016be6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016be8:	4abc      	ldr	r2, [pc, #752]	; (8016edc <ipcp_reqci+0x314>)
 8016bea:	4694      	mov	ip, r2
 8016bec:	4463      	add	r3, ip
 8016bee:	633b      	str	r3, [r7, #48]	; 0x30
    ipcp_options *ao = &pcb->ipcp_allowoptions;
 8016bf0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016bf2:	4abb      	ldr	r2, [pc, #748]	; (8016ee0 <ipcp_reqci+0x318>)
 8016bf4:	4694      	mov	ip, r2
 8016bf6:	4463      	add	r3, ip
 8016bf8:	62fb      	str	r3, [r7, #44]	; 0x2c
    u_short cilen, citype;	/* Parsed len, type */
#if VJ_SUPPORT
    u_short cishort;		/* Parsed short value */
#endif /* VJ_SUPPORT */
    u32_t tl, ciaddr1, ciaddr2;/* Parsed address values */
    int rc = CONFACK;		/* Final packet return code */
 8016bfa:	2302      	movs	r3, #2
 8016bfc:	64fb      	str	r3, [r7, #76]	; 0x4c
    int orc;			/* Individual option return code */
    u_char *p;			/* Pointer to next char to parse */
    u_char *ucp = inp;		/* Pointer to current output char */
 8016bfe:	68bb      	ldr	r3, [r7, #8]
 8016c00:	643b      	str	r3, [r7, #64]	; 0x40
    int l = *len;		/* Length left */
 8016c02:	687b      	ldr	r3, [r7, #4]
 8016c04:	681b      	ldr	r3, [r3, #0]
 8016c06:	63fb      	str	r3, [r7, #60]	; 0x3c
#endif /* LWIP_DNS */

    /*
     * Reset all his options.
     */
    BZERO(ho, sizeof(*ho));
 8016c08:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016c0a:	2218      	movs	r2, #24
 8016c0c:	2100      	movs	r1, #0
 8016c0e:	0018      	movs	r0, r3
 8016c10:	f006 f802 	bl	801cc18 <memset>
    
    /*
     * Process all his options.
     */
    next = inp;
 8016c14:	68bb      	ldr	r3, [r7, #8]
 8016c16:	657b      	str	r3, [r7, #84]	; 0x54
    while (l) {
 8016c18:	e33d      	b.n	8017296 <ipcp_reqci+0x6ce>
	orc = CONFACK;			/* Assume success */
 8016c1a:	2302      	movs	r3, #2
 8016c1c:	64bb      	str	r3, [r7, #72]	; 0x48
	cip = p = next;			/* Remember begining of CI */
 8016c1e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016c20:	647b      	str	r3, [r7, #68]	; 0x44
 8016c22:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016c24:	627b      	str	r3, [r7, #36]	; 0x24
	if (l < 2 ||			/* Not enough data for CI header or */
 8016c26:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016c28:	2b01      	cmp	r3, #1
 8016c2a:	dd0b      	ble.n	8016c44 <ipcp_reqci+0x7c>
	    p[1] < 2 ||			/*  CI length too small or */
 8016c2c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016c2e:	3301      	adds	r3, #1
 8016c30:	781b      	ldrb	r3, [r3, #0]
	if (l < 2 ||			/* Not enough data for CI header or */
 8016c32:	2b01      	cmp	r3, #1
 8016c34:	d906      	bls.n	8016c44 <ipcp_reqci+0x7c>
	    p[1] > l) {			/*  CI length too big? */
 8016c36:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016c38:	3301      	adds	r3, #1
 8016c3a:	781b      	ldrb	r3, [r3, #0]
 8016c3c:	001a      	movs	r2, r3
	    p[1] < 2 ||			/*  CI length too small or */
 8016c3e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016c40:	4293      	cmp	r3, r2
 8016c42:	da08      	bge.n	8016c56 <ipcp_reqci+0x8e>
	    IPCPDEBUG(("ipcp_reqci: bad CI length!"));
	    orc = CONFREJ;		/* Reject bad CI */
 8016c44:	2304      	movs	r3, #4
 8016c46:	64bb      	str	r3, [r7, #72]	; 0x48
	    cilen = l;			/* Reject till end of packet */
 8016c48:	2352      	movs	r3, #82	; 0x52
 8016c4a:	18fb      	adds	r3, r7, r3
 8016c4c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8016c4e:	801a      	strh	r2, [r3, #0]
	    l = 0;			/* Don't loop again */
 8016c50:	2300      	movs	r3, #0
 8016c52:	63fb      	str	r3, [r7, #60]	; 0x3c
	    goto endswitch;
 8016c54:	e2e8      	b.n	8017228 <ipcp_reqci+0x660>
	}
	GETCHAR(citype, p);		/* Parse CI type */
 8016c56:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016c58:	1c5a      	adds	r2, r3, #1
 8016c5a:	647a      	str	r2, [r7, #68]	; 0x44
 8016c5c:	781a      	ldrb	r2, [r3, #0]
 8016c5e:	2022      	movs	r0, #34	; 0x22
 8016c60:	183b      	adds	r3, r7, r0
 8016c62:	801a      	strh	r2, [r3, #0]
	GETCHAR(cilen, p);		/* Parse CI length */
 8016c64:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016c66:	1c5a      	adds	r2, r3, #1
 8016c68:	647a      	str	r2, [r7, #68]	; 0x44
 8016c6a:	781a      	ldrb	r2, [r3, #0]
 8016c6c:	2152      	movs	r1, #82	; 0x52
 8016c6e:	187b      	adds	r3, r7, r1
 8016c70:	801a      	strh	r2, [r3, #0]
	l -= cilen;			/* Adjust remaining length */
 8016c72:	187b      	adds	r3, r7, r1
 8016c74:	881b      	ldrh	r3, [r3, #0]
 8016c76:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8016c78:	1ad3      	subs	r3, r2, r3
 8016c7a:	63fb      	str	r3, [r7, #60]	; 0x3c
	next += cilen;			/* Step to next CI */
 8016c7c:	187b      	adds	r3, r7, r1
 8016c7e:	881b      	ldrh	r3, [r3, #0]
 8016c80:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8016c82:	18d3      	adds	r3, r2, r3
 8016c84:	657b      	str	r3, [r7, #84]	; 0x54

	switch (citype) {		/* Check CI type */
 8016c86:	183b      	adds	r3, r7, r0
 8016c88:	881b      	ldrh	r3, [r3, #0]
 8016c8a:	2b83      	cmp	r3, #131	; 0x83
 8016c8c:	d100      	bne.n	8016c90 <ipcp_reqci+0xc8>
 8016c8e:	e1a5      	b.n	8016fdc <ipcp_reqci+0x414>
 8016c90:	dd00      	ble.n	8016c94 <ipcp_reqci+0xcc>
 8016c92:	e2c5      	b.n	8017220 <ipcp_reqci+0x658>
 8016c94:	2b81      	cmp	r3, #129	; 0x81
 8016c96:	d100      	bne.n	8016c9a <ipcp_reqci+0xd2>
 8016c98:	e1a0      	b.n	8016fdc <ipcp_reqci+0x414>
 8016c9a:	dd00      	ble.n	8016c9e <ipcp_reqci+0xd6>
 8016c9c:	e2c0      	b.n	8017220 <ipcp_reqci+0x658>
 8016c9e:	2b03      	cmp	r3, #3
 8016ca0:	d100      	bne.n	8016ca4 <ipcp_reqci+0xdc>
 8016ca2:	e103      	b.n	8016eac <ipcp_reqci+0x2e4>
 8016ca4:	dd00      	ble.n	8016ca8 <ipcp_reqci+0xe0>
 8016ca6:	e2bb      	b.n	8017220 <ipcp_reqci+0x658>
 8016ca8:	2b01      	cmp	r3, #1
 8016caa:	d003      	beq.n	8016cb4 <ipcp_reqci+0xec>
 8016cac:	2b02      	cmp	r3, #2
 8016cae:	d100      	bne.n	8016cb2 <ipcp_reqci+0xea>
 8016cb0:	e20d      	b.n	80170ce <ipcp_reqci+0x506>
 8016cb2:	e2b5      	b.n	8017220 <ipcp_reqci+0x658>
	case CI_ADDRS:
	    if (!ao->old_addrs || ho->neg_addr ||
 8016cb4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016cb6:	781b      	ldrb	r3, [r3, #0]
 8016cb8:	2202      	movs	r2, #2
 8016cba:	4013      	ands	r3, r2
 8016cbc:	b2db      	uxtb	r3, r3
 8016cbe:	2b00      	cmp	r3, #0
 8016cc0:	d00b      	beq.n	8016cda <ipcp_reqci+0x112>
 8016cc2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016cc4:	781b      	ldrb	r3, [r3, #0]
 8016cc6:	2201      	movs	r2, #1
 8016cc8:	4013      	ands	r3, r2
 8016cca:	b2db      	uxtb	r3, r3
 8016ccc:	2b00      	cmp	r3, #0
 8016cce:	d104      	bne.n	8016cda <ipcp_reqci+0x112>
 8016cd0:	2352      	movs	r3, #82	; 0x52
 8016cd2:	18fb      	adds	r3, r7, r3
 8016cd4:	881b      	ldrh	r3, [r3, #0]
 8016cd6:	2b0a      	cmp	r3, #10
 8016cd8:	d002      	beq.n	8016ce0 <ipcp_reqci+0x118>
		cilen != CILEN_ADDRS) {	/* Check CI length */
		orc = CONFREJ;		/* Reject CI */
 8016cda:	2304      	movs	r3, #4
 8016cdc:	64bb      	str	r3, [r7, #72]	; 0x48
		break;
 8016cde:	e2a3      	b.n	8017228 <ipcp_reqci+0x660>
	     * If he has no address, or if we both have his address but
	     * disagree about it, then NAK it with our idea.
	     * In particular, if we don't know his address, but he does,
	     * then accept it.
	     */
	    GETLONG(tl, p);		/* Parse source address (his) */
 8016ce0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016ce2:	1c5a      	adds	r2, r3, #1
 8016ce4:	647a      	str	r2, [r7, #68]	; 0x44
 8016ce6:	781b      	ldrb	r3, [r3, #0]
 8016ce8:	021b      	lsls	r3, r3, #8
 8016cea:	62bb      	str	r3, [r7, #40]	; 0x28
 8016cec:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016cee:	1c5a      	adds	r2, r3, #1
 8016cf0:	647a      	str	r2, [r7, #68]	; 0x44
 8016cf2:	781b      	ldrb	r3, [r3, #0]
 8016cf4:	001a      	movs	r2, r3
 8016cf6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016cf8:	4313      	orrs	r3, r2
 8016cfa:	62bb      	str	r3, [r7, #40]	; 0x28
 8016cfc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016cfe:	021b      	lsls	r3, r3, #8
 8016d00:	62bb      	str	r3, [r7, #40]	; 0x28
 8016d02:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016d04:	1c5a      	adds	r2, r3, #1
 8016d06:	647a      	str	r2, [r7, #68]	; 0x44
 8016d08:	781b      	ldrb	r3, [r3, #0]
 8016d0a:	001a      	movs	r2, r3
 8016d0c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016d0e:	4313      	orrs	r3, r2
 8016d10:	62bb      	str	r3, [r7, #40]	; 0x28
 8016d12:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016d14:	021b      	lsls	r3, r3, #8
 8016d16:	62bb      	str	r3, [r7, #40]	; 0x28
 8016d18:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016d1a:	1c5a      	adds	r2, r3, #1
 8016d1c:	647a      	str	r2, [r7, #68]	; 0x44
 8016d1e:	781b      	ldrb	r3, [r3, #0]
 8016d20:	001a      	movs	r2, r3
 8016d22:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016d24:	4313      	orrs	r3, r2
 8016d26:	62bb      	str	r3, [r7, #40]	; 0x28
	    ciaddr1 = lwip_htonl(tl);
 8016d28:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016d2a:	0018      	movs	r0, r3
 8016d2c:	f7ef ff82 	bl	8006c34 <lwip_htonl>
 8016d30:	0003      	movs	r3, r0
 8016d32:	61bb      	str	r3, [r7, #24]
	    if (ciaddr1 != wo->hisaddr
 8016d34:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016d36:	689b      	ldr	r3, [r3, #8]
 8016d38:	69ba      	ldr	r2, [r7, #24]
 8016d3a:	429a      	cmp	r2, r3
 8016d3c:	d034      	beq.n	8016da8 <ipcp_reqci+0x1e0>
		&& (ciaddr1 == 0 || !wo->accept_remote)) {
 8016d3e:	69bb      	ldr	r3, [r7, #24]
 8016d40:	2b00      	cmp	r3, #0
 8016d42:	d006      	beq.n	8016d52 <ipcp_reqci+0x18a>
 8016d44:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016d46:	781b      	ldrb	r3, [r3, #0]
 8016d48:	227f      	movs	r2, #127	; 0x7f
 8016d4a:	4393      	bics	r3, r2
 8016d4c:	b2db      	uxtb	r3, r3
 8016d4e:	2b00      	cmp	r3, #0
 8016d50:	d12a      	bne.n	8016da8 <ipcp_reqci+0x1e0>
		orc = CONFNAK;
 8016d52:	2303      	movs	r3, #3
 8016d54:	64bb      	str	r3, [r7, #72]	; 0x48
		if (!reject_if_disagree) {
 8016d56:	683b      	ldr	r3, [r7, #0]
 8016d58:	2b00      	cmp	r3, #0
 8016d5a:	d134      	bne.n	8016dc6 <ipcp_reqci+0x1fe>
		    DECPTR(sizeof(u32_t), p);
 8016d5c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016d5e:	3b04      	subs	r3, #4
 8016d60:	647b      	str	r3, [r7, #68]	; 0x44
		    tl = lwip_ntohl(wo->hisaddr);
 8016d62:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016d64:	689b      	ldr	r3, [r3, #8]
 8016d66:	0018      	movs	r0, r3
 8016d68:	f7ef ff64 	bl	8006c34 <lwip_htonl>
 8016d6c:	0003      	movs	r3, r0
 8016d6e:	62bb      	str	r3, [r7, #40]	; 0x28
		    PUTLONG(tl, p);
 8016d70:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016d72:	0e19      	lsrs	r1, r3, #24
 8016d74:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016d76:	1c5a      	adds	r2, r3, #1
 8016d78:	647a      	str	r2, [r7, #68]	; 0x44
 8016d7a:	b2ca      	uxtb	r2, r1
 8016d7c:	701a      	strb	r2, [r3, #0]
 8016d7e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016d80:	0c19      	lsrs	r1, r3, #16
 8016d82:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016d84:	1c5a      	adds	r2, r3, #1
 8016d86:	647a      	str	r2, [r7, #68]	; 0x44
 8016d88:	b2ca      	uxtb	r2, r1
 8016d8a:	701a      	strb	r2, [r3, #0]
 8016d8c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016d8e:	0a19      	lsrs	r1, r3, #8
 8016d90:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016d92:	1c5a      	adds	r2, r3, #1
 8016d94:	647a      	str	r2, [r7, #68]	; 0x44
 8016d96:	b2ca      	uxtb	r2, r1
 8016d98:	701a      	strb	r2, [r3, #0]
 8016d9a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016d9c:	1c5a      	adds	r2, r3, #1
 8016d9e:	647a      	str	r2, [r7, #68]	; 0x44
 8016da0:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016da2:	b2d2      	uxtb	r2, r2
 8016da4:	701a      	strb	r2, [r3, #0]
		if (!reject_if_disagree) {
 8016da6:	e00e      	b.n	8016dc6 <ipcp_reqci+0x1fe>
		}
	    } else if (ciaddr1 == 0 && wo->hisaddr == 0) {
 8016da8:	69bb      	ldr	r3, [r7, #24]
 8016daa:	2b00      	cmp	r3, #0
 8016dac:	d10b      	bne.n	8016dc6 <ipcp_reqci+0x1fe>
 8016dae:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016db0:	689b      	ldr	r3, [r3, #8]
 8016db2:	2b00      	cmp	r3, #0
 8016db4:	d107      	bne.n	8016dc6 <ipcp_reqci+0x1fe>
		/*
		 * If neither we nor he knows his address, reject the option.
		 */
		orc = CONFREJ;
 8016db6:	2304      	movs	r3, #4
 8016db8:	64bb      	str	r3, [r7, #72]	; 0x48
		wo->req_addr = 0;	/* don't NAK with 0.0.0.0 later */
 8016dba:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016dbc:	781a      	ldrb	r2, [r3, #0]
 8016dbe:	2104      	movs	r1, #4
 8016dc0:	438a      	bics	r2, r1
 8016dc2:	701a      	strb	r2, [r3, #0]
		break;
 8016dc4:	e230      	b.n	8017228 <ipcp_reqci+0x660>

	    /*
	     * If he doesn't know our address, or if we both have our address
	     * but disagree about it, then NAK it with our idea.
	     */
	    GETLONG(tl, p);		/* Parse desination address (ours) */
 8016dc6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016dc8:	1c5a      	adds	r2, r3, #1
 8016dca:	647a      	str	r2, [r7, #68]	; 0x44
 8016dcc:	781b      	ldrb	r3, [r3, #0]
 8016dce:	021b      	lsls	r3, r3, #8
 8016dd0:	62bb      	str	r3, [r7, #40]	; 0x28
 8016dd2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016dd4:	1c5a      	adds	r2, r3, #1
 8016dd6:	647a      	str	r2, [r7, #68]	; 0x44
 8016dd8:	781b      	ldrb	r3, [r3, #0]
 8016dda:	001a      	movs	r2, r3
 8016ddc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016dde:	4313      	orrs	r3, r2
 8016de0:	62bb      	str	r3, [r7, #40]	; 0x28
 8016de2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016de4:	021b      	lsls	r3, r3, #8
 8016de6:	62bb      	str	r3, [r7, #40]	; 0x28
 8016de8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016dea:	1c5a      	adds	r2, r3, #1
 8016dec:	647a      	str	r2, [r7, #68]	; 0x44
 8016dee:	781b      	ldrb	r3, [r3, #0]
 8016df0:	001a      	movs	r2, r3
 8016df2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016df4:	4313      	orrs	r3, r2
 8016df6:	62bb      	str	r3, [r7, #40]	; 0x28
 8016df8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016dfa:	021b      	lsls	r3, r3, #8
 8016dfc:	62bb      	str	r3, [r7, #40]	; 0x28
 8016dfe:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016e00:	1c5a      	adds	r2, r3, #1
 8016e02:	647a      	str	r2, [r7, #68]	; 0x44
 8016e04:	781b      	ldrb	r3, [r3, #0]
 8016e06:	001a      	movs	r2, r3
 8016e08:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016e0a:	4313      	orrs	r3, r2
 8016e0c:	62bb      	str	r3, [r7, #40]	; 0x28
	    ciaddr2 = lwip_htonl(tl);
 8016e0e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016e10:	0018      	movs	r0, r3
 8016e12:	f7ef ff0f 	bl	8006c34 <lwip_htonl>
 8016e16:	0003      	movs	r3, r0
 8016e18:	613b      	str	r3, [r7, #16]
	    if (ciaddr2 != wo->ouraddr) {
 8016e1a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016e1c:	685b      	ldr	r3, [r3, #4]
 8016e1e:	693a      	ldr	r2, [r7, #16]
 8016e20:	429a      	cmp	r2, r3
 8016e22:	d037      	beq.n	8016e94 <ipcp_reqci+0x2cc>
		if (ciaddr2 == 0 || !wo->accept_local) {
 8016e24:	693b      	ldr	r3, [r7, #16]
 8016e26:	2b00      	cmp	r3, #0
 8016e28:	d006      	beq.n	8016e38 <ipcp_reqci+0x270>
 8016e2a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016e2c:	781b      	ldrb	r3, [r3, #0]
 8016e2e:	2240      	movs	r2, #64	; 0x40
 8016e30:	4013      	ands	r3, r2
 8016e32:	b2db      	uxtb	r3, r3
 8016e34:	2b00      	cmp	r3, #0
 8016e36:	d12a      	bne.n	8016e8e <ipcp_reqci+0x2c6>
		    orc = CONFNAK;
 8016e38:	2303      	movs	r3, #3
 8016e3a:	64bb      	str	r3, [r7, #72]	; 0x48
		    if (!reject_if_disagree) {
 8016e3c:	683b      	ldr	r3, [r7, #0]
 8016e3e:	2b00      	cmp	r3, #0
 8016e40:	d128      	bne.n	8016e94 <ipcp_reqci+0x2cc>
			DECPTR(sizeof(u32_t), p);
 8016e42:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016e44:	3b04      	subs	r3, #4
 8016e46:	647b      	str	r3, [r7, #68]	; 0x44
			tl = lwip_ntohl(wo->ouraddr);
 8016e48:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016e4a:	685b      	ldr	r3, [r3, #4]
 8016e4c:	0018      	movs	r0, r3
 8016e4e:	f7ef fef1 	bl	8006c34 <lwip_htonl>
 8016e52:	0003      	movs	r3, r0
 8016e54:	62bb      	str	r3, [r7, #40]	; 0x28
			PUTLONG(tl, p);
 8016e56:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016e58:	0e19      	lsrs	r1, r3, #24
 8016e5a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016e5c:	1c5a      	adds	r2, r3, #1
 8016e5e:	647a      	str	r2, [r7, #68]	; 0x44
 8016e60:	b2ca      	uxtb	r2, r1
 8016e62:	701a      	strb	r2, [r3, #0]
 8016e64:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016e66:	0c19      	lsrs	r1, r3, #16
 8016e68:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016e6a:	1c5a      	adds	r2, r3, #1
 8016e6c:	647a      	str	r2, [r7, #68]	; 0x44
 8016e6e:	b2ca      	uxtb	r2, r1
 8016e70:	701a      	strb	r2, [r3, #0]
 8016e72:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016e74:	0a19      	lsrs	r1, r3, #8
 8016e76:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016e78:	1c5a      	adds	r2, r3, #1
 8016e7a:	647a      	str	r2, [r7, #68]	; 0x44
 8016e7c:	b2ca      	uxtb	r2, r1
 8016e7e:	701a      	strb	r2, [r3, #0]
 8016e80:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016e82:	1c5a      	adds	r2, r3, #1
 8016e84:	647a      	str	r2, [r7, #68]	; 0x44
 8016e86:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016e88:	b2d2      	uxtb	r2, r2
 8016e8a:	701a      	strb	r2, [r3, #0]
		    if (!reject_if_disagree) {
 8016e8c:	e002      	b.n	8016e94 <ipcp_reqci+0x2cc>
		    }
		} else {
		    wo->ouraddr = ciaddr2;	/* accept peer's idea */
 8016e8e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016e90:	693a      	ldr	r2, [r7, #16]
 8016e92:	605a      	str	r2, [r3, #4]
		}
	    }

	    ho->old_addrs = 1;
 8016e94:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016e96:	781a      	ldrb	r2, [r3, #0]
 8016e98:	2102      	movs	r1, #2
 8016e9a:	430a      	orrs	r2, r1
 8016e9c:	701a      	strb	r2, [r3, #0]
	    ho->hisaddr = ciaddr1;
 8016e9e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016ea0:	69ba      	ldr	r2, [r7, #24]
 8016ea2:	609a      	str	r2, [r3, #8]
	    ho->ouraddr = ciaddr2;
 8016ea4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016ea6:	693a      	ldr	r2, [r7, #16]
 8016ea8:	605a      	str	r2, [r3, #4]
	    break;
 8016eaa:	e1bd      	b.n	8017228 <ipcp_reqci+0x660>

	case CI_ADDR:
	    if (!ao->neg_addr || ho->old_addrs ||
 8016eac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016eae:	781b      	ldrb	r3, [r3, #0]
 8016eb0:	2201      	movs	r2, #1
 8016eb2:	4013      	ands	r3, r2
 8016eb4:	b2db      	uxtb	r3, r3
 8016eb6:	2b00      	cmp	r3, #0
 8016eb8:	d00b      	beq.n	8016ed2 <ipcp_reqci+0x30a>
 8016eba:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016ebc:	781b      	ldrb	r3, [r3, #0]
 8016ebe:	2202      	movs	r2, #2
 8016ec0:	4013      	ands	r3, r2
 8016ec2:	b2db      	uxtb	r3, r3
 8016ec4:	2b00      	cmp	r3, #0
 8016ec6:	d104      	bne.n	8016ed2 <ipcp_reqci+0x30a>
 8016ec8:	2352      	movs	r3, #82	; 0x52
 8016eca:	18fb      	adds	r3, r7, r3
 8016ecc:	881b      	ldrh	r3, [r3, #0]
 8016ece:	2b06      	cmp	r3, #6
 8016ed0:	d008      	beq.n	8016ee4 <ipcp_reqci+0x31c>
		cilen != CILEN_ADDR) {	/* Check CI length */
		orc = CONFREJ;		/* Reject CI */
 8016ed2:	2304      	movs	r3, #4
 8016ed4:	64bb      	str	r3, [r7, #72]	; 0x48
		break;
 8016ed6:	e1a7      	b.n	8017228 <ipcp_reqci+0x660>
 8016ed8:	00001204 	.word	0x00001204
 8016edc:	0000124c 	.word	0x0000124c
 8016ee0:	00001234 	.word	0x00001234
	     * If he has no address, or if we both have his address but
	     * disagree about it, then NAK it with our idea.
	     * In particular, if we don't know his address, but he does,
	     * then accept it.
	     */
	    GETLONG(tl, p);	/* Parse source address (his) */
 8016ee4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016ee6:	1c5a      	adds	r2, r3, #1
 8016ee8:	647a      	str	r2, [r7, #68]	; 0x44
 8016eea:	781b      	ldrb	r3, [r3, #0]
 8016eec:	021b      	lsls	r3, r3, #8
 8016eee:	62bb      	str	r3, [r7, #40]	; 0x28
 8016ef0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016ef2:	1c5a      	adds	r2, r3, #1
 8016ef4:	647a      	str	r2, [r7, #68]	; 0x44
 8016ef6:	781b      	ldrb	r3, [r3, #0]
 8016ef8:	001a      	movs	r2, r3
 8016efa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016efc:	4313      	orrs	r3, r2
 8016efe:	62bb      	str	r3, [r7, #40]	; 0x28
 8016f00:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016f02:	021b      	lsls	r3, r3, #8
 8016f04:	62bb      	str	r3, [r7, #40]	; 0x28
 8016f06:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016f08:	1c5a      	adds	r2, r3, #1
 8016f0a:	647a      	str	r2, [r7, #68]	; 0x44
 8016f0c:	781b      	ldrb	r3, [r3, #0]
 8016f0e:	001a      	movs	r2, r3
 8016f10:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016f12:	4313      	orrs	r3, r2
 8016f14:	62bb      	str	r3, [r7, #40]	; 0x28
 8016f16:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016f18:	021b      	lsls	r3, r3, #8
 8016f1a:	62bb      	str	r3, [r7, #40]	; 0x28
 8016f1c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016f1e:	1c5a      	adds	r2, r3, #1
 8016f20:	647a      	str	r2, [r7, #68]	; 0x44
 8016f22:	781b      	ldrb	r3, [r3, #0]
 8016f24:	001a      	movs	r2, r3
 8016f26:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016f28:	4313      	orrs	r3, r2
 8016f2a:	62bb      	str	r3, [r7, #40]	; 0x28
	    ciaddr1 = lwip_htonl(tl);
 8016f2c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016f2e:	0018      	movs	r0, r3
 8016f30:	f7ef fe80 	bl	8006c34 <lwip_htonl>
 8016f34:	0003      	movs	r3, r0
 8016f36:	61bb      	str	r3, [r7, #24]
	    if (ciaddr1 != wo->hisaddr
 8016f38:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016f3a:	689b      	ldr	r3, [r3, #8]
 8016f3c:	69ba      	ldr	r2, [r7, #24]
 8016f3e:	429a      	cmp	r2, r3
 8016f40:	d034      	beq.n	8016fac <ipcp_reqci+0x3e4>
		&& (ciaddr1 == 0 || !wo->accept_remote)) {
 8016f42:	69bb      	ldr	r3, [r7, #24]
 8016f44:	2b00      	cmp	r3, #0
 8016f46:	d006      	beq.n	8016f56 <ipcp_reqci+0x38e>
 8016f48:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016f4a:	781b      	ldrb	r3, [r3, #0]
 8016f4c:	227f      	movs	r2, #127	; 0x7f
 8016f4e:	4393      	bics	r3, r2
 8016f50:	b2db      	uxtb	r3, r3
 8016f52:	2b00      	cmp	r3, #0
 8016f54:	d12a      	bne.n	8016fac <ipcp_reqci+0x3e4>
		orc = CONFNAK;
 8016f56:	2303      	movs	r3, #3
 8016f58:	64bb      	str	r3, [r7, #72]	; 0x48
		if (!reject_if_disagree) {
 8016f5a:	683b      	ldr	r3, [r7, #0]
 8016f5c:	2b00      	cmp	r3, #0
 8016f5e:	d134      	bne.n	8016fca <ipcp_reqci+0x402>
		    DECPTR(sizeof(u32_t), p);
 8016f60:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016f62:	3b04      	subs	r3, #4
 8016f64:	647b      	str	r3, [r7, #68]	; 0x44
		    tl = lwip_ntohl(wo->hisaddr);
 8016f66:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016f68:	689b      	ldr	r3, [r3, #8]
 8016f6a:	0018      	movs	r0, r3
 8016f6c:	f7ef fe62 	bl	8006c34 <lwip_htonl>
 8016f70:	0003      	movs	r3, r0
 8016f72:	62bb      	str	r3, [r7, #40]	; 0x28
		    PUTLONG(tl, p);
 8016f74:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016f76:	0e19      	lsrs	r1, r3, #24
 8016f78:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016f7a:	1c5a      	adds	r2, r3, #1
 8016f7c:	647a      	str	r2, [r7, #68]	; 0x44
 8016f7e:	b2ca      	uxtb	r2, r1
 8016f80:	701a      	strb	r2, [r3, #0]
 8016f82:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016f84:	0c19      	lsrs	r1, r3, #16
 8016f86:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016f88:	1c5a      	adds	r2, r3, #1
 8016f8a:	647a      	str	r2, [r7, #68]	; 0x44
 8016f8c:	b2ca      	uxtb	r2, r1
 8016f8e:	701a      	strb	r2, [r3, #0]
 8016f90:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016f92:	0a19      	lsrs	r1, r3, #8
 8016f94:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016f96:	1c5a      	adds	r2, r3, #1
 8016f98:	647a      	str	r2, [r7, #68]	; 0x44
 8016f9a:	b2ca      	uxtb	r2, r1
 8016f9c:	701a      	strb	r2, [r3, #0]
 8016f9e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016fa0:	1c5a      	adds	r2, r3, #1
 8016fa2:	647a      	str	r2, [r7, #68]	; 0x44
 8016fa4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016fa6:	b2d2      	uxtb	r2, r2
 8016fa8:	701a      	strb	r2, [r3, #0]
		if (!reject_if_disagree) {
 8016faa:	e00e      	b.n	8016fca <ipcp_reqci+0x402>
		}
	    } else if (ciaddr1 == 0 && wo->hisaddr == 0) {
 8016fac:	69bb      	ldr	r3, [r7, #24]
 8016fae:	2b00      	cmp	r3, #0
 8016fb0:	d10b      	bne.n	8016fca <ipcp_reqci+0x402>
 8016fb2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016fb4:	689b      	ldr	r3, [r3, #8]
 8016fb6:	2b00      	cmp	r3, #0
 8016fb8:	d107      	bne.n	8016fca <ipcp_reqci+0x402>
		/*
		 * Don't ACK an address of 0.0.0.0 - reject it instead.
		 */
		orc = CONFREJ;
 8016fba:	2304      	movs	r3, #4
 8016fbc:	64bb      	str	r3, [r7, #72]	; 0x48
		wo->req_addr = 0;	/* don't NAK with 0.0.0.0 later */
 8016fbe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016fc0:	781a      	ldrb	r2, [r3, #0]
 8016fc2:	2104      	movs	r1, #4
 8016fc4:	438a      	bics	r2, r1
 8016fc6:	701a      	strb	r2, [r3, #0]
		break;
 8016fc8:	e12e      	b.n	8017228 <ipcp_reqci+0x660>
	    }
	
	    ho->neg_addr = 1;
 8016fca:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016fcc:	781a      	ldrb	r2, [r3, #0]
 8016fce:	2101      	movs	r1, #1
 8016fd0:	430a      	orrs	r2, r1
 8016fd2:	701a      	strb	r2, [r3, #0]
	    ho->hisaddr = ciaddr1;
 8016fd4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016fd6:	69ba      	ldr	r2, [r7, #24]
 8016fd8:	609a      	str	r2, [r3, #8]
	    break;
 8016fda:	e125      	b.n	8017228 <ipcp_reqci+0x660>

#if LWIP_DNS
	case CI_MS_DNS1:
	case CI_MS_DNS2:
	    /* Microsoft primary or secondary DNS request */
	    d = citype == CI_MS_DNS2;
 8016fdc:	2322      	movs	r3, #34	; 0x22
 8016fde:	18fb      	adds	r3, r7, r3
 8016fe0:	881b      	ldrh	r3, [r3, #0]
 8016fe2:	3b83      	subs	r3, #131	; 0x83
 8016fe4:	425a      	negs	r2, r3
 8016fe6:	4153      	adcs	r3, r2
 8016fe8:	b2db      	uxtb	r3, r3
 8016fea:	61fb      	str	r3, [r7, #28]

	    /* If we do not have a DNS address then we cannot send it */
	    if (ao->dnsaddr[d] == 0 ||
 8016fec:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8016fee:	69fb      	ldr	r3, [r7, #28]
 8016ff0:	3302      	adds	r3, #2
 8016ff2:	009b      	lsls	r3, r3, #2
 8016ff4:	18d3      	adds	r3, r2, r3
 8016ff6:	3304      	adds	r3, #4
 8016ff8:	681b      	ldr	r3, [r3, #0]
 8016ffa:	2b00      	cmp	r3, #0
 8016ffc:	d004      	beq.n	8017008 <ipcp_reqci+0x440>
 8016ffe:	2352      	movs	r3, #82	; 0x52
 8017000:	18fb      	adds	r3, r7, r3
 8017002:	881b      	ldrh	r3, [r3, #0]
 8017004:	2b06      	cmp	r3, #6
 8017006:	d002      	beq.n	801700e <ipcp_reqci+0x446>
		cilen != CILEN_ADDR) {	/* Check CI length */
		orc = CONFREJ;		/* Reject CI */
 8017008:	2304      	movs	r3, #4
 801700a:	64bb      	str	r3, [r7, #72]	; 0x48
		break;
 801700c:	e10c      	b.n	8017228 <ipcp_reqci+0x660>
	    }
	    GETLONG(tl, p);
 801700e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017010:	1c5a      	adds	r2, r3, #1
 8017012:	647a      	str	r2, [r7, #68]	; 0x44
 8017014:	781b      	ldrb	r3, [r3, #0]
 8017016:	021b      	lsls	r3, r3, #8
 8017018:	62bb      	str	r3, [r7, #40]	; 0x28
 801701a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801701c:	1c5a      	adds	r2, r3, #1
 801701e:	647a      	str	r2, [r7, #68]	; 0x44
 8017020:	781b      	ldrb	r3, [r3, #0]
 8017022:	001a      	movs	r2, r3
 8017024:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017026:	4313      	orrs	r3, r2
 8017028:	62bb      	str	r3, [r7, #40]	; 0x28
 801702a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801702c:	021b      	lsls	r3, r3, #8
 801702e:	62bb      	str	r3, [r7, #40]	; 0x28
 8017030:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017032:	1c5a      	adds	r2, r3, #1
 8017034:	647a      	str	r2, [r7, #68]	; 0x44
 8017036:	781b      	ldrb	r3, [r3, #0]
 8017038:	001a      	movs	r2, r3
 801703a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801703c:	4313      	orrs	r3, r2
 801703e:	62bb      	str	r3, [r7, #40]	; 0x28
 8017040:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017042:	021b      	lsls	r3, r3, #8
 8017044:	62bb      	str	r3, [r7, #40]	; 0x28
 8017046:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017048:	1c5a      	adds	r2, r3, #1
 801704a:	647a      	str	r2, [r7, #68]	; 0x44
 801704c:	781b      	ldrb	r3, [r3, #0]
 801704e:	001a      	movs	r2, r3
 8017050:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017052:	4313      	orrs	r3, r2
 8017054:	62bb      	str	r3, [r7, #40]	; 0x28
	    if (lwip_htonl(tl) != ao->dnsaddr[d]) {
 8017056:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017058:	0018      	movs	r0, r3
 801705a:	f7ef fdeb 	bl	8006c34 <lwip_htonl>
 801705e:	0001      	movs	r1, r0
 8017060:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8017062:	69fb      	ldr	r3, [r7, #28]
 8017064:	3302      	adds	r3, #2
 8017066:	009b      	lsls	r3, r3, #2
 8017068:	18d3      	adds	r3, r2, r3
 801706a:	3304      	adds	r3, #4
 801706c:	681b      	ldr	r3, [r3, #0]
 801706e:	4299      	cmp	r1, r3
 8017070:	d100      	bne.n	8017074 <ipcp_reqci+0x4ac>
 8017072:	e0d8      	b.n	8017226 <ipcp_reqci+0x65e>
                DECPTR(sizeof(u32_t), p);
 8017074:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017076:	3b04      	subs	r3, #4
 8017078:	647b      	str	r3, [r7, #68]	; 0x44
		tl = lwip_ntohl(ao->dnsaddr[d]);
 801707a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801707c:	69fb      	ldr	r3, [r7, #28]
 801707e:	3302      	adds	r3, #2
 8017080:	009b      	lsls	r3, r3, #2
 8017082:	18d3      	adds	r3, r2, r3
 8017084:	3304      	adds	r3, #4
 8017086:	681b      	ldr	r3, [r3, #0]
 8017088:	0018      	movs	r0, r3
 801708a:	f7ef fdd3 	bl	8006c34 <lwip_htonl>
 801708e:	0003      	movs	r3, r0
 8017090:	62bb      	str	r3, [r7, #40]	; 0x28
		PUTLONG(tl, p);
 8017092:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017094:	0e19      	lsrs	r1, r3, #24
 8017096:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017098:	1c5a      	adds	r2, r3, #1
 801709a:	647a      	str	r2, [r7, #68]	; 0x44
 801709c:	b2ca      	uxtb	r2, r1
 801709e:	701a      	strb	r2, [r3, #0]
 80170a0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80170a2:	0c19      	lsrs	r1, r3, #16
 80170a4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80170a6:	1c5a      	adds	r2, r3, #1
 80170a8:	647a      	str	r2, [r7, #68]	; 0x44
 80170aa:	b2ca      	uxtb	r2, r1
 80170ac:	701a      	strb	r2, [r3, #0]
 80170ae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80170b0:	0a19      	lsrs	r1, r3, #8
 80170b2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80170b4:	1c5a      	adds	r2, r3, #1
 80170b6:	647a      	str	r2, [r7, #68]	; 0x44
 80170b8:	b2ca      	uxtb	r2, r1
 80170ba:	701a      	strb	r2, [r3, #0]
 80170bc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80170be:	1c5a      	adds	r2, r3, #1
 80170c0:	647a      	str	r2, [r7, #68]	; 0x44
 80170c2:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80170c4:	b2d2      	uxtb	r2, r2
 80170c6:	701a      	strb	r2, [r3, #0]
		orc = CONFNAK;
 80170c8:	2303      	movs	r3, #3
 80170ca:	64bb      	str	r3, [r7, #72]	; 0x48
            }
            break;
 80170cc:	e0ab      	b.n	8017226 <ipcp_reqci+0x65e>
            break;
#endif /* UNUSED - WINS */

#if VJ_SUPPORT
	case CI_COMPRESSTYPE:
	    if (!ao->neg_vj ||
 80170ce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80170d0:	781b      	ldrb	r3, [r3, #0]
 80170d2:	2208      	movs	r2, #8
 80170d4:	4013      	ands	r3, r2
 80170d6:	b2db      	uxtb	r3, r3
 80170d8:	2b00      	cmp	r3, #0
 80170da:	d008      	beq.n	80170ee <ipcp_reqci+0x526>
 80170dc:	2252      	movs	r2, #82	; 0x52
 80170de:	18bb      	adds	r3, r7, r2
 80170e0:	881b      	ldrh	r3, [r3, #0]
 80170e2:	2b06      	cmp	r3, #6
 80170e4:	d006      	beq.n	80170f4 <ipcp_reqci+0x52c>
		(cilen != CILEN_VJ && cilen != CILEN_COMPRESS)) {
 80170e6:	18bb      	adds	r3, r7, r2
 80170e8:	881b      	ldrh	r3, [r3, #0]
 80170ea:	2b04      	cmp	r3, #4
 80170ec:	d002      	beq.n	80170f4 <ipcp_reqci+0x52c>
		orc = CONFREJ;
 80170ee:	2304      	movs	r3, #4
 80170f0:	64bb      	str	r3, [r7, #72]	; 0x48
		break;
 80170f2:	e099      	b.n	8017228 <ipcp_reqci+0x660>
	    }
	    GETSHORT(cishort, p);
 80170f4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80170f6:	1c5a      	adds	r2, r3, #1
 80170f8:	647a      	str	r2, [r7, #68]	; 0x44
 80170fa:	781b      	ldrb	r3, [r3, #0]
 80170fc:	b29a      	uxth	r2, r3
 80170fe:	2016      	movs	r0, #22
 8017100:	183b      	adds	r3, r7, r0
 8017102:	0212      	lsls	r2, r2, #8
 8017104:	801a      	strh	r2, [r3, #0]
 8017106:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017108:	1c5a      	adds	r2, r3, #1
 801710a:	647a      	str	r2, [r7, #68]	; 0x44
 801710c:	781b      	ldrb	r3, [r3, #0]
 801710e:	b299      	uxth	r1, r3
 8017110:	183b      	adds	r3, r7, r0
 8017112:	183a      	adds	r2, r7, r0
 8017114:	8812      	ldrh	r2, [r2, #0]
 8017116:	430a      	orrs	r2, r1
 8017118:	801a      	strh	r2, [r3, #0]

	    if (!(cishort == IPCP_VJ_COMP ||
 801711a:	183b      	adds	r3, r7, r0
 801711c:	881b      	ldrh	r3, [r3, #0]
 801711e:	2b2d      	cmp	r3, #45	; 0x2d
 8017120:	d00b      	beq.n	801713a <ipcp_reqci+0x572>
 8017122:	183b      	adds	r3, r7, r0
 8017124:	881b      	ldrh	r3, [r3, #0]
 8017126:	2b37      	cmp	r3, #55	; 0x37
 8017128:	d104      	bne.n	8017134 <ipcp_reqci+0x56c>
		  (cishort == IPCP_VJ_COMP_OLD && cilen == CILEN_COMPRESS))) {
 801712a:	2352      	movs	r3, #82	; 0x52
 801712c:	18fb      	adds	r3, r7, r3
 801712e:	881b      	ldrh	r3, [r3, #0]
 8017130:	2b04      	cmp	r3, #4
 8017132:	d002      	beq.n	801713a <ipcp_reqci+0x572>
		orc = CONFREJ;
 8017134:	2304      	movs	r3, #4
 8017136:	64bb      	str	r3, [r7, #72]	; 0x48
		break;
 8017138:	e076      	b.n	8017228 <ipcp_reqci+0x660>
	    }

	    ho->neg_vj = 1;
 801713a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801713c:	781a      	ldrb	r2, [r3, #0]
 801713e:	2108      	movs	r1, #8
 8017140:	430a      	orrs	r2, r1
 8017142:	701a      	strb	r2, [r3, #0]
	    ho->vj_protocol = cishort;
 8017144:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017146:	2216      	movs	r2, #22
 8017148:	18ba      	adds	r2, r7, r2
 801714a:	8812      	ldrh	r2, [r2, #0]
 801714c:	829a      	strh	r2, [r3, #20]
	    if (cilen == CILEN_VJ) {
 801714e:	2352      	movs	r3, #82	; 0x52
 8017150:	18fb      	adds	r3, r7, r3
 8017152:	881b      	ldrh	r3, [r3, #0]
 8017154:	2b06      	cmp	r3, #6
 8017156:	d155      	bne.n	8017204 <ipcp_reqci+0x63c>
		GETCHAR(maxslotindex, p);
 8017158:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801715a:	1c5a      	adds	r2, r3, #1
 801715c:	647a      	str	r2, [r7, #68]	; 0x44
 801715e:	2115      	movs	r1, #21
 8017160:	187a      	adds	r2, r7, r1
 8017162:	781b      	ldrb	r3, [r3, #0]
 8017164:	7013      	strb	r3, [r2, #0]
		if (maxslotindex > ao->maxslotindex) { 
 8017166:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017168:	7d9b      	ldrb	r3, [r3, #22]
 801716a:	187a      	adds	r2, r7, r1
 801716c:	7812      	ldrb	r2, [r2, #0]
 801716e:	429a      	cmp	r2, r3
 8017170:	d90d      	bls.n	801718e <ipcp_reqci+0x5c6>
		    orc = CONFNAK;
 8017172:	2303      	movs	r3, #3
 8017174:	64bb      	str	r3, [r7, #72]	; 0x48
		    if (!reject_if_disagree){
 8017176:	683b      	ldr	r3, [r7, #0]
 8017178:	2b00      	cmp	r3, #0
 801717a:	d108      	bne.n	801718e <ipcp_reqci+0x5c6>
			DECPTR(1, p);
 801717c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801717e:	3b01      	subs	r3, #1
 8017180:	647b      	str	r3, [r7, #68]	; 0x44
			PUTCHAR(ao->maxslotindex, p);
 8017182:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017184:	1c5a      	adds	r2, r3, #1
 8017186:	647a      	str	r2, [r7, #68]	; 0x44
 8017188:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801718a:	7d92      	ldrb	r2, [r2, #22]
 801718c:	701a      	strb	r2, [r3, #0]
		    }
		}
		GETCHAR(cflag, p);
 801718e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017190:	1c5a      	adds	r2, r3, #1
 8017192:	647a      	str	r2, [r7, #68]	; 0x44
 8017194:	2114      	movs	r1, #20
 8017196:	187a      	adds	r2, r7, r1
 8017198:	781b      	ldrb	r3, [r3, #0]
 801719a:	7013      	strb	r3, [r2, #0]
		if (cflag && !ao->cflag) {
 801719c:	187b      	adds	r3, r7, r1
 801719e:	781b      	ldrb	r3, [r3, #0]
 80171a0:	2b00      	cmp	r3, #0
 80171a2:	d018      	beq.n	80171d6 <ipcp_reqci+0x60e>
 80171a4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80171a6:	781b      	ldrb	r3, [r3, #0]
 80171a8:	2220      	movs	r2, #32
 80171aa:	4013      	ands	r3, r2
 80171ac:	b2db      	uxtb	r3, r3
 80171ae:	2b00      	cmp	r3, #0
 80171b0:	d111      	bne.n	80171d6 <ipcp_reqci+0x60e>
		    orc = CONFNAK;
 80171b2:	2303      	movs	r3, #3
 80171b4:	64bb      	str	r3, [r7, #72]	; 0x48
		    if (!reject_if_disagree){
 80171b6:	683b      	ldr	r3, [r7, #0]
 80171b8:	2b00      	cmp	r3, #0
 80171ba:	d10c      	bne.n	80171d6 <ipcp_reqci+0x60e>
			DECPTR(1, p);
 80171bc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80171be:	3b01      	subs	r3, #1
 80171c0:	647b      	str	r3, [r7, #68]	; 0x44
			PUTCHAR(wo->cflag, p);
 80171c2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80171c4:	781b      	ldrb	r3, [r3, #0]
 80171c6:	069b      	lsls	r3, r3, #26
 80171c8:	0fdb      	lsrs	r3, r3, #31
 80171ca:	b2d9      	uxtb	r1, r3
 80171cc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80171ce:	1c5a      	adds	r2, r3, #1
 80171d0:	647a      	str	r2, [r7, #68]	; 0x44
 80171d2:	000a      	movs	r2, r1
 80171d4:	701a      	strb	r2, [r3, #0]
		    }
		}
		ho->maxslotindex = maxslotindex;
 80171d6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80171d8:	2215      	movs	r2, #21
 80171da:	18ba      	adds	r2, r7, r2
 80171dc:	7812      	ldrb	r2, [r2, #0]
 80171de:	759a      	strb	r2, [r3, #22]
		ho->cflag = cflag;
 80171e0:	2314      	movs	r3, #20
 80171e2:	18fb      	adds	r3, r7, r3
 80171e4:	781b      	ldrb	r3, [r3, #0]
 80171e6:	2201      	movs	r2, #1
 80171e8:	4013      	ands	r3, r2
 80171ea:	b2da      	uxtb	r2, r3
 80171ec:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80171ee:	2101      	movs	r1, #1
 80171f0:	400a      	ands	r2, r1
 80171f2:	0150      	lsls	r0, r2, #5
 80171f4:	781a      	ldrb	r2, [r3, #0]
 80171f6:	2120      	movs	r1, #32
 80171f8:	438a      	bics	r2, r1
 80171fa:	1c11      	adds	r1, r2, #0
 80171fc:	1c02      	adds	r2, r0, #0
 80171fe:	430a      	orrs	r2, r1
 8017200:	701a      	strb	r2, [r3, #0]
	    } else {
		ho->old_vj = 1;
		ho->maxslotindex = MAX_STATES - 1;
		ho->cflag = 1;
	    }
	    break;
 8017202:	e011      	b.n	8017228 <ipcp_reqci+0x660>
		ho->old_vj = 1;
 8017204:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017206:	781a      	ldrb	r2, [r3, #0]
 8017208:	2110      	movs	r1, #16
 801720a:	430a      	orrs	r2, r1
 801720c:	701a      	strb	r2, [r3, #0]
		ho->maxslotindex = MAX_STATES - 1;
 801720e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017210:	220f      	movs	r2, #15
 8017212:	759a      	strb	r2, [r3, #22]
		ho->cflag = 1;
 8017214:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017216:	781a      	ldrb	r2, [r3, #0]
 8017218:	2120      	movs	r1, #32
 801721a:	430a      	orrs	r2, r1
 801721c:	701a      	strb	r2, [r3, #0]
	    break;
 801721e:	e003      	b.n	8017228 <ipcp_reqci+0x660>
#endif /* VJ_SUPPORT */

	default:
	    orc = CONFREJ;
 8017220:	2304      	movs	r3, #4
 8017222:	64bb      	str	r3, [r7, #72]	; 0x48
	    break;
 8017224:	e000      	b.n	8017228 <ipcp_reqci+0x660>
            break;
 8017226:	46c0      	nop			; (mov r8, r8)
	}
endswitch:
	if (orc == CONFACK &&		/* Good CI */
 8017228:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801722a:	2b02      	cmp	r3, #2
 801722c:	d103      	bne.n	8017236 <ipcp_reqci+0x66e>
 801722e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8017230:	2b02      	cmp	r3, #2
 8017232:	d000      	beq.n	8017236 <ipcp_reqci+0x66e>
	    rc != CONFACK)		/*  but prior CI wasnt? */
	    continue;			/* Don't send this one */
 8017234:	e02f      	b.n	8017296 <ipcp_reqci+0x6ce>

	if (orc == CONFNAK) {		/* Nak this CI? */
 8017236:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8017238:	2b03      	cmp	r3, #3
 801723a:	d110      	bne.n	801725e <ipcp_reqci+0x696>
	    if (reject_if_disagree)	/* Getting fed up with sending NAKs? */
 801723c:	683b      	ldr	r3, [r7, #0]
 801723e:	2b00      	cmp	r3, #0
 8017240:	d002      	beq.n	8017248 <ipcp_reqci+0x680>
		orc = CONFREJ;		/* Get tough if so */
 8017242:	2304      	movs	r3, #4
 8017244:	64bb      	str	r3, [r7, #72]	; 0x48
 8017246:	e00a      	b.n	801725e <ipcp_reqci+0x696>
	    else {
		if (rc == CONFREJ)	/* Rejecting prior CI? */
 8017248:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801724a:	2b04      	cmp	r3, #4
 801724c:	d100      	bne.n	8017250 <ipcp_reqci+0x688>
		    continue;		/* Don't send this one */
 801724e:	e022      	b.n	8017296 <ipcp_reqci+0x6ce>
		if (rc == CONFACK) {	/* Ack'd all prior CIs? */
 8017250:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8017252:	2b02      	cmp	r3, #2
 8017254:	d103      	bne.n	801725e <ipcp_reqci+0x696>
		    rc = CONFNAK;	/* Not anymore... */
 8017256:	2303      	movs	r3, #3
 8017258:	64fb      	str	r3, [r7, #76]	; 0x4c
		    ucp = inp;		/* Backup */
 801725a:	68bb      	ldr	r3, [r7, #8]
 801725c:	643b      	str	r3, [r7, #64]	; 0x40
		}
	    }
	}

	if (orc == CONFREJ &&		/* Reject this CI */
 801725e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8017260:	2b04      	cmp	r3, #4
 8017262:	d106      	bne.n	8017272 <ipcp_reqci+0x6aa>
 8017264:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8017266:	2b04      	cmp	r3, #4
 8017268:	d003      	beq.n	8017272 <ipcp_reqci+0x6aa>
	    rc != CONFREJ) {		/*  but no prior ones? */
	    rc = CONFREJ;
 801726a:	2304      	movs	r3, #4
 801726c:	64fb      	str	r3, [r7, #76]	; 0x4c
	    ucp = inp;			/* Backup */
 801726e:	68bb      	ldr	r3, [r7, #8]
 8017270:	643b      	str	r3, [r7, #64]	; 0x40
	}

	/* Need to move CI? */
	if (ucp != cip)
 8017272:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8017274:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017276:	429a      	cmp	r2, r3
 8017278:	d007      	beq.n	801728a <ipcp_reqci+0x6c2>
	    MEMCPY(ucp, cip, cilen);	/* Move it */
 801727a:	2352      	movs	r3, #82	; 0x52
 801727c:	18fb      	adds	r3, r7, r3
 801727e:	881a      	ldrh	r2, [r3, #0]
 8017280:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8017282:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8017284:	0018      	movs	r0, r3
 8017286:	f005 fcab 	bl	801cbe0 <memcpy>

	/* Update output pointer */
	INCPTR(cilen, ucp);
 801728a:	2352      	movs	r3, #82	; 0x52
 801728c:	18fb      	adds	r3, r7, r3
 801728e:	881b      	ldrh	r3, [r3, #0]
 8017290:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8017292:	18d3      	adds	r3, r2, r3
 8017294:	643b      	str	r3, [r7, #64]	; 0x40
    while (l) {
 8017296:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8017298:	2b00      	cmp	r3, #0
 801729a:	d000      	beq.n	801729e <ipcp_reqci+0x6d6>
 801729c:	e4bd      	b.n	8016c1a <ipcp_reqci+0x52>
     * their address, and they didn't send their address, then we
     * send a NAK with a CI_ADDR option appended.  We assume the
     * input buffer is long enough that we can append the extra
     * option safely.
     */
    if (rc != CONFREJ && !ho->neg_addr && !ho->old_addrs &&
 801729e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80172a0:	2b04      	cmp	r3, #4
 80172a2:	d056      	beq.n	8017352 <ipcp_reqci+0x78a>
 80172a4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80172a6:	781b      	ldrb	r3, [r3, #0]
 80172a8:	2201      	movs	r2, #1
 80172aa:	4013      	ands	r3, r2
 80172ac:	b2db      	uxtb	r3, r3
 80172ae:	2b00      	cmp	r3, #0
 80172b0:	d14f      	bne.n	8017352 <ipcp_reqci+0x78a>
 80172b2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80172b4:	781b      	ldrb	r3, [r3, #0]
 80172b6:	2202      	movs	r2, #2
 80172b8:	4013      	ands	r3, r2
 80172ba:	b2db      	uxtb	r3, r3
 80172bc:	2b00      	cmp	r3, #0
 80172be:	d148      	bne.n	8017352 <ipcp_reqci+0x78a>
 80172c0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80172c2:	781b      	ldrb	r3, [r3, #0]
 80172c4:	2204      	movs	r2, #4
 80172c6:	4013      	ands	r3, r2
 80172c8:	b2db      	uxtb	r3, r3
 80172ca:	2b00      	cmp	r3, #0
 80172cc:	d041      	beq.n	8017352 <ipcp_reqci+0x78a>
	wo->req_addr && !reject_if_disagree && !pcb->settings.noremoteip) {
 80172ce:	683b      	ldr	r3, [r7, #0]
 80172d0:	2b00      	cmp	r3, #0
 80172d2:	d13e      	bne.n	8017352 <ipcp_reqci+0x78a>
 80172d4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80172d6:	781b      	ldrb	r3, [r3, #0]
 80172d8:	2204      	movs	r2, #4
 80172da:	4013      	ands	r3, r2
 80172dc:	b2db      	uxtb	r3, r3
 80172de:	2b00      	cmp	r3, #0
 80172e0:	d137      	bne.n	8017352 <ipcp_reqci+0x78a>
	if (rc == CONFACK) {
 80172e2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80172e4:	2b02      	cmp	r3, #2
 80172e6:	d108      	bne.n	80172fa <ipcp_reqci+0x732>
	    rc = CONFNAK;
 80172e8:	2303      	movs	r3, #3
 80172ea:	64fb      	str	r3, [r7, #76]	; 0x4c
	    ucp = inp;			/* reset pointer */
 80172ec:	68bb      	ldr	r3, [r7, #8]
 80172ee:	643b      	str	r3, [r7, #64]	; 0x40
	    wo->req_addr = 0;		/* don't ask again */
 80172f0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80172f2:	781a      	ldrb	r2, [r3, #0]
 80172f4:	2104      	movs	r1, #4
 80172f6:	438a      	bics	r2, r1
 80172f8:	701a      	strb	r2, [r3, #0]
	}
	PUTCHAR(CI_ADDR, ucp);
 80172fa:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80172fc:	1c5a      	adds	r2, r3, #1
 80172fe:	643a      	str	r2, [r7, #64]	; 0x40
 8017300:	2203      	movs	r2, #3
 8017302:	701a      	strb	r2, [r3, #0]
	PUTCHAR(CILEN_ADDR, ucp);
 8017304:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8017306:	1c5a      	adds	r2, r3, #1
 8017308:	643a      	str	r2, [r7, #64]	; 0x40
 801730a:	2206      	movs	r2, #6
 801730c:	701a      	strb	r2, [r3, #0]
	tl = lwip_ntohl(wo->hisaddr);
 801730e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017310:	689b      	ldr	r3, [r3, #8]
 8017312:	0018      	movs	r0, r3
 8017314:	f7ef fc8e 	bl	8006c34 <lwip_htonl>
 8017318:	0003      	movs	r3, r0
 801731a:	62bb      	str	r3, [r7, #40]	; 0x28
	PUTLONG(tl, ucp);
 801731c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801731e:	0e19      	lsrs	r1, r3, #24
 8017320:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8017322:	1c5a      	adds	r2, r3, #1
 8017324:	643a      	str	r2, [r7, #64]	; 0x40
 8017326:	b2ca      	uxtb	r2, r1
 8017328:	701a      	strb	r2, [r3, #0]
 801732a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801732c:	0c19      	lsrs	r1, r3, #16
 801732e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8017330:	1c5a      	adds	r2, r3, #1
 8017332:	643a      	str	r2, [r7, #64]	; 0x40
 8017334:	b2ca      	uxtb	r2, r1
 8017336:	701a      	strb	r2, [r3, #0]
 8017338:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801733a:	0a19      	lsrs	r1, r3, #8
 801733c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801733e:	1c5a      	adds	r2, r3, #1
 8017340:	643a      	str	r2, [r7, #64]	; 0x40
 8017342:	b2ca      	uxtb	r2, r1
 8017344:	701a      	strb	r2, [r3, #0]
 8017346:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8017348:	1c5a      	adds	r2, r3, #1
 801734a:	643a      	str	r2, [r7, #64]	; 0x40
 801734c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801734e:	b2d2      	uxtb	r2, r2
 8017350:	701a      	strb	r2, [r3, #0]
    }

    *len = ucp - inp;			/* Compute output length */
 8017352:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8017354:	68bb      	ldr	r3, [r7, #8]
 8017356:	1ad2      	subs	r2, r2, r3
 8017358:	687b      	ldr	r3, [r7, #4]
 801735a:	601a      	str	r2, [r3, #0]
    IPCPDEBUG(("ipcp: returning Configure-%s", CODENAME(rc)));
    return (rc);			/* Return final code */
 801735c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
}
 801735e:	0018      	movs	r0, r3
 8017360:	46bd      	mov	sp, r7
 8017362:	b016      	add	sp, #88	; 0x58
 8017364:	bd80      	pop	{r7, pc}
 8017366:	46c0      	nop			; (mov r8, r8)

08017368 <ipcp_up>:
/*
 * ipcp_up - IPCP has come UP.
 *
 * Configure the IP network interface appropriately and bring it up.
 */
static void ipcp_up(fsm *f) {
 8017368:	b580      	push	{r7, lr}
 801736a:	b088      	sub	sp, #32
 801736c:	af00      	add	r7, sp, #0
 801736e:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8017370:	687b      	ldr	r3, [r7, #4]
 8017372:	681b      	ldr	r3, [r3, #0]
 8017374:	61fb      	str	r3, [r7, #28]
    u32_t mask;
    ipcp_options *ho = &pcb->ipcp_hisoptions;
 8017376:	69fb      	ldr	r3, [r7, #28]
 8017378:	4a9e      	ldr	r2, [pc, #632]	; (80175f4 <ipcp_up+0x28c>)
 801737a:	4694      	mov	ip, r2
 801737c:	4463      	add	r3, ip
 801737e:	61bb      	str	r3, [r7, #24]
    ipcp_options *go = &pcb->ipcp_gotoptions;
 8017380:	69fb      	ldr	r3, [r7, #28]
 8017382:	4a9d      	ldr	r2, [pc, #628]	; (80175f8 <ipcp_up+0x290>)
 8017384:	4694      	mov	ip, r2
 8017386:	4463      	add	r3, ip
 8017388:	617b      	str	r3, [r7, #20]
    ipcp_options *wo = &pcb->ipcp_wantoptions;
 801738a:	69fb      	ldr	r3, [r7, #28]
 801738c:	4a9b      	ldr	r2, [pc, #620]	; (80175fc <ipcp_up+0x294>)
 801738e:	4694      	mov	ip, r2
 8017390:	4463      	add	r3, ip
 8017392:	613b      	str	r3, [r7, #16]
    IPCPDEBUG(("ipcp: up"));

    /*
     * We must have a non-zero IP address for both ends of the link.
     */
    if (!ho->neg_addr && !ho->old_addrs)
 8017394:	69bb      	ldr	r3, [r7, #24]
 8017396:	781b      	ldrb	r3, [r3, #0]
 8017398:	2201      	movs	r2, #1
 801739a:	4013      	ands	r3, r2
 801739c:	b2db      	uxtb	r3, r3
 801739e:	2b00      	cmp	r3, #0
 80173a0:	d10a      	bne.n	80173b8 <ipcp_up+0x50>
 80173a2:	69bb      	ldr	r3, [r7, #24]
 80173a4:	781b      	ldrb	r3, [r3, #0]
 80173a6:	2202      	movs	r2, #2
 80173a8:	4013      	ands	r3, r2
 80173aa:	b2db      	uxtb	r3, r3
 80173ac:	2b00      	cmp	r3, #0
 80173ae:	d103      	bne.n	80173b8 <ipcp_up+0x50>
	ho->hisaddr = wo->hisaddr;
 80173b0:	693b      	ldr	r3, [r7, #16]
 80173b2:	689a      	ldr	r2, [r3, #8]
 80173b4:	69bb      	ldr	r3, [r7, #24]
 80173b6:	609a      	str	r2, [r3, #8]

    if (!(go->neg_addr || go->old_addrs) && (wo->neg_addr || wo->old_addrs)
 80173b8:	697b      	ldr	r3, [r7, #20]
 80173ba:	781b      	ldrb	r3, [r3, #0]
 80173bc:	2201      	movs	r2, #1
 80173be:	4013      	ands	r3, r2
 80173c0:	b2db      	uxtb	r3, r3
 80173c2:	2b00      	cmp	r3, #0
 80173c4:	d124      	bne.n	8017410 <ipcp_up+0xa8>
 80173c6:	697b      	ldr	r3, [r7, #20]
 80173c8:	781b      	ldrb	r3, [r3, #0]
 80173ca:	2202      	movs	r2, #2
 80173cc:	4013      	ands	r3, r2
 80173ce:	b2db      	uxtb	r3, r3
 80173d0:	2b00      	cmp	r3, #0
 80173d2:	d11d      	bne.n	8017410 <ipcp_up+0xa8>
 80173d4:	693b      	ldr	r3, [r7, #16]
 80173d6:	781b      	ldrb	r3, [r3, #0]
 80173d8:	2201      	movs	r2, #1
 80173da:	4013      	ands	r3, r2
 80173dc:	b2db      	uxtb	r3, r3
 80173de:	2b00      	cmp	r3, #0
 80173e0:	d106      	bne.n	80173f0 <ipcp_up+0x88>
 80173e2:	693b      	ldr	r3, [r7, #16]
 80173e4:	781b      	ldrb	r3, [r3, #0]
 80173e6:	2202      	movs	r2, #2
 80173e8:	4013      	ands	r3, r2
 80173ea:	b2db      	uxtb	r3, r3
 80173ec:	2b00      	cmp	r3, #0
 80173ee:	d00f      	beq.n	8017410 <ipcp_up+0xa8>
	&& wo->ouraddr != 0) {
 80173f0:	693b      	ldr	r3, [r7, #16]
 80173f2:	685b      	ldr	r3, [r3, #4]
 80173f4:	2b00      	cmp	r3, #0
 80173f6:	d00b      	beq.n	8017410 <ipcp_up+0xa8>
	ppp_error("Peer refused to agree to our IP address");
 80173f8:	4b81      	ldr	r3, [pc, #516]	; (8017600 <ipcp_up+0x298>)
 80173fa:	0018      	movs	r0, r3
 80173fc:	f004 f891 	bl	801b522 <ppp_error>
	ipcp_close(f->pcb, "Refused our IP address");
 8017400:	687b      	ldr	r3, [r7, #4]
 8017402:	681b      	ldr	r3, [r3, #0]
 8017404:	4a7f      	ldr	r2, [pc, #508]	; (8017604 <ipcp_up+0x29c>)
 8017406:	0011      	movs	r1, r2
 8017408:	0018      	movs	r0, r3
 801740a:	f7fd ff4d 	bl	80152a8 <ipcp_close>
	return;
 801740e:	e0ed      	b.n	80175ec <ipcp_up+0x284>
    }
    if (go->ouraddr == 0) {
 8017410:	697b      	ldr	r3, [r7, #20]
 8017412:	685b      	ldr	r3, [r3, #4]
 8017414:	2b00      	cmp	r3, #0
 8017416:	d10b      	bne.n	8017430 <ipcp_up+0xc8>
	ppp_error("Could not determine local IP address");
 8017418:	4b7b      	ldr	r3, [pc, #492]	; (8017608 <ipcp_up+0x2a0>)
 801741a:	0018      	movs	r0, r3
 801741c:	f004 f881 	bl	801b522 <ppp_error>
	ipcp_close(f->pcb, "Could not determine local IP address");
 8017420:	687b      	ldr	r3, [r7, #4]
 8017422:	681b      	ldr	r3, [r3, #0]
 8017424:	4a78      	ldr	r2, [pc, #480]	; (8017608 <ipcp_up+0x2a0>)
 8017426:	0011      	movs	r1, r2
 8017428:	0018      	movs	r0, r3
 801742a:	f7fd ff3d 	bl	80152a8 <ipcp_close>
	return;
 801742e:	e0dd      	b.n	80175ec <ipcp_up+0x284>
    }
    if (ho->hisaddr == 0 && !pcb->settings.noremoteip) {
 8017430:	69bb      	ldr	r3, [r7, #24]
 8017432:	689b      	ldr	r3, [r3, #8]
 8017434:	2b00      	cmp	r3, #0
 8017436:	d114      	bne.n	8017462 <ipcp_up+0xfa>
 8017438:	69fb      	ldr	r3, [r7, #28]
 801743a:	781b      	ldrb	r3, [r3, #0]
 801743c:	2204      	movs	r2, #4
 801743e:	4013      	ands	r3, r2
 8017440:	b2db      	uxtb	r3, r3
 8017442:	2b00      	cmp	r3, #0
 8017444:	d10d      	bne.n	8017462 <ipcp_up+0xfa>
	ho->hisaddr = lwip_htonl(0x0a404040);
 8017446:	4b71      	ldr	r3, [pc, #452]	; (801760c <ipcp_up+0x2a4>)
 8017448:	0018      	movs	r0, r3
 801744a:	f7ef fbf3 	bl	8006c34 <lwip_htonl>
 801744e:	0002      	movs	r2, r0
 8017450:	69bb      	ldr	r3, [r7, #24]
 8017452:	609a      	str	r2, [r3, #8]
	ppp_warn("Could not determine remote IP address: defaulting to %I",
 8017454:	69bb      	ldr	r3, [r7, #24]
 8017456:	689a      	ldr	r2, [r3, #8]
 8017458:	4b6d      	ldr	r3, [pc, #436]	; (8017610 <ipcp_up+0x2a8>)
 801745a:	0011      	movs	r1, r2
 801745c:	0018      	movs	r0, r3
 801745e:	f004 f874 	bl	801b54a <ppp_warn>
    if (ho->hisaddr != 0)
	script_setenv("IPREMOTE", ip_ntoa(ho->hisaddr), 1);
#endif /* UNUSED */

#if LWIP_DNS
    if (!go->req_dns1)
 8017462:	697b      	ldr	r3, [r7, #20]
 8017464:	785b      	ldrb	r3, [r3, #1]
 8017466:	2201      	movs	r2, #1
 8017468:	4013      	ands	r3, r2
 801746a:	b2db      	uxtb	r3, r3
 801746c:	2b00      	cmp	r3, #0
 801746e:	d102      	bne.n	8017476 <ipcp_up+0x10e>
	    go->dnsaddr[0] = 0;
 8017470:	697b      	ldr	r3, [r7, #20]
 8017472:	2200      	movs	r2, #0
 8017474:	60da      	str	r2, [r3, #12]
    if (!go->req_dns2)
 8017476:	697b      	ldr	r3, [r7, #20]
 8017478:	785b      	ldrb	r3, [r3, #1]
 801747a:	2202      	movs	r2, #2
 801747c:	4013      	ands	r3, r2
 801747e:	b2db      	uxtb	r3, r3
 8017480:	2b00      	cmp	r3, #0
 8017482:	d102      	bne.n	801748a <ipcp_up+0x122>
	    go->dnsaddr[1] = 0;
 8017484:	697b      	ldr	r3, [r7, #20]
 8017486:	2200      	movs	r2, #0
 8017488:	611a      	str	r2, [r3, #16]
    if (go->dnsaddr[0])
	script_setenv("DNS1", ip_ntoa(go->dnsaddr[0]), 0);
    if (go->dnsaddr[1])
	script_setenv("DNS2", ip_ntoa(go->dnsaddr[1]), 0);
#endif /* UNUSED */
    if (pcb->settings.usepeerdns && (go->dnsaddr[0] || go->dnsaddr[1])) {
 801748a:	69fb      	ldr	r3, [r7, #28]
 801748c:	781b      	ldrb	r3, [r3, #0]
 801748e:	2201      	movs	r2, #1
 8017490:	4013      	ands	r3, r2
 8017492:	b2db      	uxtb	r3, r3
 8017494:	2b00      	cmp	r3, #0
 8017496:	d00f      	beq.n	80174b8 <ipcp_up+0x150>
 8017498:	697b      	ldr	r3, [r7, #20]
 801749a:	68db      	ldr	r3, [r3, #12]
 801749c:	2b00      	cmp	r3, #0
 801749e:	d103      	bne.n	80174a8 <ipcp_up+0x140>
 80174a0:	697b      	ldr	r3, [r7, #20]
 80174a2:	691b      	ldr	r3, [r3, #16]
 80174a4:	2b00      	cmp	r3, #0
 80174a6:	d007      	beq.n	80174b8 <ipcp_up+0x150>
	sdns(pcb, go->dnsaddr[0], go->dnsaddr[1]);
 80174a8:	697b      	ldr	r3, [r7, #20]
 80174aa:	68d9      	ldr	r1, [r3, #12]
 80174ac:	697b      	ldr	r3, [r7, #20]
 80174ae:	691a      	ldr	r2, [r3, #16]
 80174b0:	69fb      	ldr	r3, [r7, #28]
 80174b2:	0018      	movs	r0, r3
 80174b4:	f002 fe12 	bl	801a0dc <sdns>
#endif /* LWIP_DNS */

    /*
     * Check that the peer is allowed to use the IP address it wants.
     */
    if (ho->hisaddr != 0) {
 80174b8:	69bb      	ldr	r3, [r7, #24]
 80174ba:	689b      	ldr	r3, [r3, #8]
 80174bc:	2b00      	cmp	r3, #0
 80174be:	d026      	beq.n	801750e <ipcp_up+0x1a6>
	u32_t addr = lwip_ntohl(ho->hisaddr);
 80174c0:	69bb      	ldr	r3, [r7, #24]
 80174c2:	689b      	ldr	r3, [r3, #8]
 80174c4:	0018      	movs	r0, r3
 80174c6:	f7ef fbb5 	bl	8006c34 <lwip_htonl>
 80174ca:	0003      	movs	r3, r0
 80174cc:	60fb      	str	r3, [r7, #12]
	if ((addr >> IP_CLASSA_NSHIFT) == IP_LOOPBACKNET
 80174ce:	68fb      	ldr	r3, [r7, #12]
 80174d0:	0e1b      	lsrs	r3, r3, #24
 80174d2:	2b7f      	cmp	r3, #127	; 0x7f
 80174d4:	d00d      	beq.n	80174f2 <ipcp_up+0x18a>
	    || IP_MULTICAST(addr) || IP_BADCLASS(addr)
 80174d6:	68fb      	ldr	r3, [r7, #12]
 80174d8:	0f1b      	lsrs	r3, r3, #28
 80174da:	071a      	lsls	r2, r3, #28
 80174dc:	23e0      	movs	r3, #224	; 0xe0
 80174de:	061b      	lsls	r3, r3, #24
 80174e0:	429a      	cmp	r2, r3
 80174e2:	d006      	beq.n	80174f2 <ipcp_up+0x18a>
 80174e4:	68fb      	ldr	r3, [r7, #12]
 80174e6:	0f1b      	lsrs	r3, r3, #28
 80174e8:	071a      	lsls	r2, r3, #28
 80174ea:	23f0      	movs	r3, #240	; 0xf0
 80174ec:	061b      	lsls	r3, r3, #24
 80174ee:	429a      	cmp	r2, r3
 80174f0:	d10d      	bne.n	801750e <ipcp_up+0x1a6>
	     */
#if PPP_SERVER && PPP_AUTH_SUPPORT
	    || (pcb->settings.auth_required && wo->hisaddr != ho->hisaddr)
#endif /* PPP_SERVER && PPP_AUTH_SUPPORT */
	    ) {
		ppp_error("Peer is not authorized to use remote address %I", ho->hisaddr);
 80174f2:	69bb      	ldr	r3, [r7, #24]
 80174f4:	689a      	ldr	r2, [r3, #8]
 80174f6:	4b47      	ldr	r3, [pc, #284]	; (8017614 <ipcp_up+0x2ac>)
 80174f8:	0011      	movs	r1, r2
 80174fa:	0018      	movs	r0, r3
 80174fc:	f004 f811 	bl	801b522 <ppp_error>
		ipcp_close(pcb, "Unauthorized remote IP address");
 8017500:	4a45      	ldr	r2, [pc, #276]	; (8017618 <ipcp_up+0x2b0>)
 8017502:	69fb      	ldr	r3, [r7, #28]
 8017504:	0011      	movs	r1, r2
 8017506:	0018      	movs	r0, r3
 8017508:	f7fd fece 	bl	80152a8 <ipcp_close>
		return;
 801750c:	e06e      	b.n	80175ec <ipcp_up+0x284>
    }
#endif /* Unused */

#if VJ_SUPPORT
    /* set tcp compression */
    sifvjcomp(pcb, ho->neg_vj, ho->cflag, ho->maxslotindex);
 801750e:	69bb      	ldr	r3, [r7, #24]
 8017510:	781b      	ldrb	r3, [r3, #0]
 8017512:	071b      	lsls	r3, r3, #28
 8017514:	0fdb      	lsrs	r3, r3, #31
 8017516:	b2db      	uxtb	r3, r3
 8017518:	0019      	movs	r1, r3
 801751a:	69bb      	ldr	r3, [r7, #24]
 801751c:	781b      	ldrb	r3, [r3, #0]
 801751e:	069b      	lsls	r3, r3, #26
 8017520:	0fdb      	lsrs	r3, r3, #31
 8017522:	b2db      	uxtb	r3, r3
 8017524:	001a      	movs	r2, r3
 8017526:	69bb      	ldr	r3, [r7, #24]
 8017528:	7d9b      	ldrb	r3, [r3, #22]
 801752a:	69f8      	ldr	r0, [r7, #28]
 801752c:	f002 fe20 	bl	801a170 <sifvjcomp>
#endif /* DEMAND_SUPPORT */
    {
	/*
	 * Set IP addresses and (if specified) netmask.
	 */
	mask = get_mask(go->ouraddr);
 8017530:	697b      	ldr	r3, [r7, #20]
 8017532:	685b      	ldr	r3, [r3, #4]
 8017534:	0018      	movs	r0, r3
 8017536:	f002 fe79 	bl	801a22c <get_mask>
 801753a:	0003      	movs	r3, r0
 801753c:	60bb      	str	r3, [r7, #8]

#if !(defined(SVR4) && (defined(SNI) || defined(__USLC__)))
	if (!sifaddr(pcb, go->ouraddr, ho->hisaddr, mask)) {
 801753e:	697b      	ldr	r3, [r7, #20]
 8017540:	6859      	ldr	r1, [r3, #4]
 8017542:	69bb      	ldr	r3, [r7, #24]
 8017544:	689a      	ldr	r2, [r3, #8]
 8017546:	68bb      	ldr	r3, [r7, #8]
 8017548:	69f8      	ldr	r0, [r7, #28]
 801754a:	f002 fd95 	bl	801a078 <sifaddr>
 801754e:	1e03      	subs	r3, r0, #0
 8017550:	d107      	bne.n	8017562 <ipcp_up+0x1fa>
#if PPP_DEBUG
	    ppp_warn("Interface configuration failed");
#endif /* PPP_DEBUG */
	    ipcp_close(f->pcb, "Interface configuration failed");
 8017552:	687b      	ldr	r3, [r7, #4]
 8017554:	681b      	ldr	r3, [r3, #0]
 8017556:	4a31      	ldr	r2, [pc, #196]	; (801761c <ipcp_up+0x2b4>)
 8017558:	0011      	movs	r1, r2
 801755a:	0018      	movs	r0, r3
 801755c:	f7fd fea4 	bl	80152a8 <ipcp_close>
	    return;
 8017560:	e044      	b.n	80175ec <ipcp_up+0x284>
	}
#endif

	/* bring the interface up for IP */
	if (!sifup(pcb)) {
 8017562:	69fb      	ldr	r3, [r7, #28]
 8017564:	0018      	movs	r0, r3
 8017566:	f002 fe2a 	bl	801a1be <sifup>
 801756a:	1e03      	subs	r3, r0, #0
 801756c:	d107      	bne.n	801757e <ipcp_up+0x216>
#if PPP_DEBUG
	    ppp_warn("Interface failed to come up");
#endif /* PPP_DEBUG */
	    ipcp_close(f->pcb, "Interface configuration failed");
 801756e:	687b      	ldr	r3, [r7, #4]
 8017570:	681b      	ldr	r3, [r3, #0]
 8017572:	4a2a      	ldr	r2, [pc, #168]	; (801761c <ipcp_up+0x2b4>)
 8017574:	0011      	movs	r1, r2
 8017576:	0018      	movs	r0, r3
 8017578:	f7fd fe96 	bl	80152a8 <ipcp_close>
	    return;
 801757c:	e036      	b.n	80175ec <ipcp_up+0x284>
	if (ho->hisaddr != 0 && wo->proxy_arp)
	    if (sifproxyarp(pcb, ho->hisaddr))
		pcb->proxy_arp_set = 1;
#endif /* UNUSED - PROXY ARP */

	wo->ouraddr = go->ouraddr;
 801757e:	697b      	ldr	r3, [r7, #20]
 8017580:	685a      	ldr	r2, [r3, #4]
 8017582:	693b      	ldr	r3, [r7, #16]
 8017584:	605a      	str	r2, [r3, #4]

	ppp_notice("local  IP address %I", go->ouraddr);
 8017586:	697b      	ldr	r3, [r7, #20]
 8017588:	685a      	ldr	r2, [r3, #4]
 801758a:	4b25      	ldr	r3, [pc, #148]	; (8017620 <ipcp_up+0x2b8>)
 801758c:	0011      	movs	r1, r2
 801758e:	0018      	movs	r0, r3
 8017590:	f003 ffef 	bl	801b572 <ppp_notice>
	if (ho->hisaddr != 0)
 8017594:	69bb      	ldr	r3, [r7, #24]
 8017596:	689b      	ldr	r3, [r3, #8]
 8017598:	2b00      	cmp	r3, #0
 801759a:	d006      	beq.n	80175aa <ipcp_up+0x242>
	    ppp_notice("remote IP address %I", ho->hisaddr);
 801759c:	69bb      	ldr	r3, [r7, #24]
 801759e:	689a      	ldr	r2, [r3, #8]
 80175a0:	4b20      	ldr	r3, [pc, #128]	; (8017624 <ipcp_up+0x2bc>)
 80175a2:	0011      	movs	r1, r2
 80175a4:	0018      	movs	r0, r3
 80175a6:	f003 ffe4 	bl	801b572 <ppp_notice>
#if LWIP_DNS
	if (go->dnsaddr[0])
 80175aa:	697b      	ldr	r3, [r7, #20]
 80175ac:	68db      	ldr	r3, [r3, #12]
 80175ae:	2b00      	cmp	r3, #0
 80175b0:	d006      	beq.n	80175c0 <ipcp_up+0x258>
	    ppp_notice("primary   DNS address %I", go->dnsaddr[0]);
 80175b2:	697b      	ldr	r3, [r7, #20]
 80175b4:	68da      	ldr	r2, [r3, #12]
 80175b6:	4b1c      	ldr	r3, [pc, #112]	; (8017628 <ipcp_up+0x2c0>)
 80175b8:	0011      	movs	r1, r2
 80175ba:	0018      	movs	r0, r3
 80175bc:	f003 ffd9 	bl	801b572 <ppp_notice>
	if (go->dnsaddr[1])
 80175c0:	697b      	ldr	r3, [r7, #20]
 80175c2:	691b      	ldr	r3, [r3, #16]
 80175c4:	2b00      	cmp	r3, #0
 80175c6:	d006      	beq.n	80175d6 <ipcp_up+0x26e>
	    ppp_notice("secondary DNS address %I", go->dnsaddr[1]);
 80175c8:	697b      	ldr	r3, [r7, #20]
 80175ca:	691a      	ldr	r2, [r3, #16]
 80175cc:	4b17      	ldr	r3, [pc, #92]	; (801762c <ipcp_up+0x2c4>)
 80175ce:	0011      	movs	r1, r2
 80175d0:	0018      	movs	r0, r3
 80175d2:	f003 ffce 	bl	801b572 <ppp_notice>

#if PPP_STATS_SUPPORT
    reset_link_stats(f->unit);
#endif /* PPP_STATS_SUPPORT */

    np_up(pcb, PPP_IP);
 80175d6:	69fb      	ldr	r3, [r7, #28]
 80175d8:	2121      	movs	r1, #33	; 0x21
 80175da:	0018      	movs	r0, r3
 80175dc:	f7fc fdda 	bl	8014194 <np_up>
    pcb->ipcp_is_up = 1;
 80175e0:	69fb      	ldr	r3, [r7, #28]
 80175e2:	2226      	movs	r2, #38	; 0x26
 80175e4:	5c99      	ldrb	r1, [r3, r2]
 80175e6:	2004      	movs	r0, #4
 80175e8:	4301      	orrs	r1, r0
 80175ea:	5499      	strb	r1, [r3, r2]
#endif /* PPP_NOTIFY */
#if 0 /* UNUSED */
    if (ip_up_hook)
	ip_up_hook();
#endif /* UNUSED */
}
 80175ec:	46bd      	mov	sp, r7
 80175ee:	b008      	add	sp, #32
 80175f0:	bd80      	pop	{r7, pc}
 80175f2:	46c0      	nop			; (mov r8, r8)
 80175f4:	0000124c 	.word	0x0000124c
 80175f8:	0000121c 	.word	0x0000121c
 80175fc:	00001204 	.word	0x00001204
 8017600:	08021798 	.word	0x08021798
 8017604:	080217c0 	.word	0x080217c0
 8017608:	080217d8 	.word	0x080217d8
 801760c:	0a404040 	.word	0x0a404040
 8017610:	08021800 	.word	0x08021800
 8017614:	08021838 	.word	0x08021838
 8017618:	08021868 	.word	0x08021868
 801761c:	08021888 	.word	0x08021888
 8017620:	080218a8 	.word	0x080218a8
 8017624:	080218c0 	.word	0x080218c0
 8017628:	080218d8 	.word	0x080218d8
 801762c:	080218f4 	.word	0x080218f4

08017630 <ipcp_down>:
 * ipcp_down - IPCP has gone DOWN.
 *
 * Take the IP network interface down, clear its addresses
 * and delete routes through it.
 */
static void ipcp_down(fsm *f) {
 8017630:	b580      	push	{r7, lr}
 8017632:	b086      	sub	sp, #24
 8017634:	af00      	add	r7, sp, #0
 8017636:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8017638:	687b      	ldr	r3, [r7, #4]
 801763a:	681b      	ldr	r3, [r3, #0]
 801763c:	617b      	str	r3, [r7, #20]
    ipcp_options *ho = &pcb->ipcp_hisoptions;
 801763e:	697b      	ldr	r3, [r7, #20]
 8017640:	4a1c      	ldr	r2, [pc, #112]	; (80176b4 <ipcp_down+0x84>)
 8017642:	4694      	mov	ip, r2
 8017644:	4463      	add	r3, ip
 8017646:	613b      	str	r3, [r7, #16]
    ipcp_options *go = &pcb->ipcp_gotoptions;
 8017648:	697b      	ldr	r3, [r7, #20]
 801764a:	4a1b      	ldr	r2, [pc, #108]	; (80176b8 <ipcp_down+0x88>)
 801764c:	4694      	mov	ip, r2
 801764e:	4463      	add	r3, ip
 8017650:	60fb      	str	r3, [r7, #12]
#endif /* PPP_NOTIFY */
#if 0 /* UNUSED */
    if (ip_down_hook)
	ip_down_hook();
#endif /* UNUSED */
    if (pcb->ipcp_is_up) {
 8017652:	697b      	ldr	r3, [r7, #20]
 8017654:	2226      	movs	r2, #38	; 0x26
 8017656:	5c9b      	ldrb	r3, [r3, r2]
 8017658:	2204      	movs	r2, #4
 801765a:	4013      	ands	r3, r2
 801765c:	b2db      	uxtb	r3, r3
 801765e:	2b00      	cmp	r3, #0
 8017660:	d00a      	beq.n	8017678 <ipcp_down+0x48>
	pcb->ipcp_is_up = 0;
 8017662:	697b      	ldr	r3, [r7, #20]
 8017664:	2226      	movs	r2, #38	; 0x26
 8017666:	5c99      	ldrb	r1, [r3, r2]
 8017668:	2004      	movs	r0, #4
 801766a:	4381      	bics	r1, r0
 801766c:	5499      	strb	r1, [r3, r2]
	np_down(pcb, PPP_IP);
 801766e:	697b      	ldr	r3, [r7, #20]
 8017670:	2121      	movs	r1, #33	; 0x21
 8017672:	0018      	movs	r0, r3
 8017674:	f7fc fda9 	bl	80141ca <np_down>
    }
#if VJ_SUPPORT
    sifvjcomp(pcb, 0, 0, 0);
 8017678:	6978      	ldr	r0, [r7, #20]
 801767a:	2300      	movs	r3, #0
 801767c:	2200      	movs	r2, #0
 801767e:	2100      	movs	r1, #0
 8017680:	f002 fd76 	bl	801a170 <sifvjcomp>
#endif /* DEMAND_SUPPORT */
    {
#if DEMAND_SUPPORT
	sifnpmode(pcb, PPP_IP, NPMODE_DROP);
#endif /* DEMAND_SUPPORT */
	sifdown(pcb);
 8017684:	697b      	ldr	r3, [r7, #20]
 8017686:	0018      	movs	r0, r3
 8017688:	f002 fdbc 	bl	801a204 <sifdown>
	ipcp_clear_addrs(pcb, go->ouraddr,
 801768c:	68fb      	ldr	r3, [r7, #12]
 801768e:	6859      	ldr	r1, [r3, #4]
 8017690:	693b      	ldr	r3, [r7, #16]
 8017692:	689a      	ldr	r2, [r3, #8]
 8017694:	6978      	ldr	r0, [r7, #20]
 8017696:	2300      	movs	r3, #0
 8017698:	f000 f810 	bl	80176bc <ipcp_clear_addrs>
			 ho->hisaddr, 0);
#if LWIP_DNS
	cdns(pcb, go->dnsaddr[0], go->dnsaddr[1]);
 801769c:	68fb      	ldr	r3, [r7, #12]
 801769e:	68d9      	ldr	r1, [r3, #12]
 80176a0:	68fb      	ldr	r3, [r7, #12]
 80176a2:	691a      	ldr	r2, [r3, #16]
 80176a4:	697b      	ldr	r3, [r7, #20]
 80176a6:	0018      	movs	r0, r3
 80176a8:	f002 fd32 	bl	801a110 <cdns>
#endif /* LWIP_DNS */
    }
}
 80176ac:	46c0      	nop			; (mov r8, r8)
 80176ae:	46bd      	mov	sp, r7
 80176b0:	b006      	add	sp, #24
 80176b2:	bd80      	pop	{r7, pc}
 80176b4:	0000124c 	.word	0x0000124c
 80176b8:	0000121c 	.word	0x0000121c

080176bc <ipcp_clear_addrs>:

/*
 * ipcp_clear_addrs() - clear the interface addresses, routes,
 * proxy arp entries, etc.
 */
static void ipcp_clear_addrs(ppp_pcb *pcb, u32_t ouraddr, u32_t hisaddr, u8_t replacedefaultroute) {
 80176bc:	b580      	push	{r7, lr}
 80176be:	b084      	sub	sp, #16
 80176c0:	af00      	add	r7, sp, #0
 80176c2:	60f8      	str	r0, [r7, #12]
 80176c4:	60b9      	str	r1, [r7, #8]
 80176c6:	607a      	str	r2, [r7, #4]
 80176c8:	001a      	movs	r2, r3
 80176ca:	1cfb      	adds	r3, r7, #3
 80176cc:	701a      	strb	r2, [r3, #0]
    if (!replacedefaultroute && pcb->default_route_set) {
	cifdefaultroute(pcb, ouraddr, hisaddr);
	pcb->default_route_set = 0;
    }
#endif /* UNUSED */
    cifaddr(pcb, ouraddr, hisaddr);
 80176ce:	687a      	ldr	r2, [r7, #4]
 80176d0:	68b9      	ldr	r1, [r7, #8]
 80176d2:	68fb      	ldr	r3, [r7, #12]
 80176d4:	0018      	movs	r0, r3
 80176d6:	f002 fceb 	bl	801a0b0 <cifaddr>
}
 80176da:	46c0      	nop			; (mov r8, r8)
 80176dc:	46bd      	mov	sp, r7
 80176de:	b004      	add	sp, #16
 80176e0:	bd80      	pop	{r7, pc}

080176e2 <ipcp_finished>:


/*
 * ipcp_finished - possibly shut down the lower layers.
 */
static void ipcp_finished(fsm *f) {
 80176e2:	b580      	push	{r7, lr}
 80176e4:	b084      	sub	sp, #16
 80176e6:	af00      	add	r7, sp, #0
 80176e8:	6078      	str	r0, [r7, #4]
	ppp_pcb *pcb = f->pcb;
 80176ea:	687b      	ldr	r3, [r7, #4]
 80176ec:	681b      	ldr	r3, [r3, #0]
 80176ee:	60fb      	str	r3, [r7, #12]
	if (pcb->ipcp_is_open) {
 80176f0:	68fb      	ldr	r3, [r7, #12]
 80176f2:	2226      	movs	r2, #38	; 0x26
 80176f4:	5c9b      	ldrb	r3, [r3, r2]
 80176f6:	2202      	movs	r2, #2
 80176f8:	4013      	ands	r3, r2
 80176fa:	b2db      	uxtb	r3, r3
 80176fc:	2b00      	cmp	r3, #0
 80176fe:	d00a      	beq.n	8017716 <ipcp_finished+0x34>
		pcb->ipcp_is_open = 0;
 8017700:	68fb      	ldr	r3, [r7, #12]
 8017702:	2226      	movs	r2, #38	; 0x26
 8017704:	5c99      	ldrb	r1, [r3, r2]
 8017706:	2002      	movs	r0, #2
 8017708:	4381      	bics	r1, r0
 801770a:	5499      	strb	r1, [r3, r2]
		np_finished(pcb, PPP_IP);
 801770c:	68fb      	ldr	r3, [r7, #12]
 801770e:	2121      	movs	r1, #33	; 0x21
 8017710:	0018      	movs	r0, r3
 8017712:	f7fc fd75 	bl	8014200 <np_finished>
	}
}
 8017716:	46c0      	nop			; (mov r8, r8)
 8017718:	46bd      	mov	sp, r7
 801771a:	b004      	add	sp, #16
 801771c:	bd80      	pop	{r7, pc}
	...

08017720 <lcp_init>:
#endif /* HAVE_MULTILINK */

/*
 * lcp_init - Initialize LCP.
 */
static void lcp_init(ppp_pcb *pcb) {
 8017720:	b580      	push	{r7, lr}
 8017722:	b086      	sub	sp, #24
 8017724:	af00      	add	r7, sp, #0
 8017726:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->lcp_fsm;
 8017728:	687b      	ldr	r3, [r7, #4]
 801772a:	3328      	adds	r3, #40	; 0x28
 801772c:	617b      	str	r3, [r7, #20]
    lcp_options *wo = &pcb->lcp_wantoptions;
 801772e:	687b      	ldr	r3, [r7, #4]
 8017730:	3344      	adds	r3, #68	; 0x44
 8017732:	613b      	str	r3, [r7, #16]
    lcp_options *ao = &pcb->lcp_allowoptions;
 8017734:	687b      	ldr	r3, [r7, #4]
 8017736:	338c      	adds	r3, #140	; 0x8c
 8017738:	60fb      	str	r3, [r7, #12]

    f->pcb = pcb;
 801773a:	697b      	ldr	r3, [r7, #20]
 801773c:	687a      	ldr	r2, [r7, #4]
 801773e:	601a      	str	r2, [r3, #0]
    f->protocol = PPP_LCP;
 8017740:	697b      	ldr	r3, [r7, #20]
 8017742:	4a2b      	ldr	r2, [pc, #172]	; (80177f0 <lcp_init+0xd0>)
 8017744:	81da      	strh	r2, [r3, #14]
    f->callbacks = &lcp_callbacks;
 8017746:	697b      	ldr	r3, [r7, #20]
 8017748:	4a2a      	ldr	r2, [pc, #168]	; (80177f4 <lcp_init+0xd4>)
 801774a:	605a      	str	r2, [r3, #4]

    fsm_init(f);
 801774c:	697b      	ldr	r3, [r7, #20]
 801774e:	0018      	movs	r0, r3
 8017750:	f7fc fd74 	bl	801423c <fsm_init>

    BZERO(wo, sizeof(*wo));
 8017754:	693b      	ldr	r3, [r7, #16]
 8017756:	2224      	movs	r2, #36	; 0x24
 8017758:	2100      	movs	r1, #0
 801775a:	0018      	movs	r0, r3
 801775c:	f005 fa5c 	bl	801cc18 <memset>
    wo->neg_mru = 1;
 8017760:	693b      	ldr	r3, [r7, #16]
 8017762:	781a      	ldrb	r2, [r3, #0]
 8017764:	2104      	movs	r1, #4
 8017766:	430a      	orrs	r2, r1
 8017768:	701a      	strb	r2, [r3, #0]
    wo->mru = PPP_DEFMRU;
 801776a:	693b      	ldr	r3, [r7, #16]
 801776c:	4a22      	ldr	r2, [pc, #136]	; (80177f8 <lcp_init+0xd8>)
 801776e:	805a      	strh	r2, [r3, #2]
    wo->neg_asyncmap = 1;
 8017770:	693b      	ldr	r3, [r7, #16]
 8017772:	781a      	ldrb	r2, [r3, #0]
 8017774:	2108      	movs	r1, #8
 8017776:	430a      	orrs	r2, r1
 8017778:	701a      	strb	r2, [r3, #0]
    wo->neg_magicnumber = 1;
 801777a:	693b      	ldr	r3, [r7, #16]
 801777c:	781a      	ldrb	r2, [r3, #0]
 801777e:	2110      	movs	r1, #16
 8017780:	430a      	orrs	r2, r1
 8017782:	701a      	strb	r2, [r3, #0]
    wo->neg_pcompression = 1;
 8017784:	693b      	ldr	r3, [r7, #16]
 8017786:	781a      	ldrb	r2, [r3, #0]
 8017788:	2120      	movs	r1, #32
 801778a:	430a      	orrs	r2, r1
 801778c:	701a      	strb	r2, [r3, #0]
    wo->neg_accompression = 1;
 801778e:	693b      	ldr	r3, [r7, #16]
 8017790:	781a      	ldrb	r2, [r3, #0]
 8017792:	2140      	movs	r1, #64	; 0x40
 8017794:	430a      	orrs	r2, r1
 8017796:	701a      	strb	r2, [r3, #0]

    BZERO(ao, sizeof(*ao));
 8017798:	68fb      	ldr	r3, [r7, #12]
 801779a:	2224      	movs	r2, #36	; 0x24
 801779c:	2100      	movs	r1, #0
 801779e:	0018      	movs	r0, r3
 80177a0:	f005 fa3a 	bl	801cc18 <memset>
    ao->neg_mru = 1;
 80177a4:	68fb      	ldr	r3, [r7, #12]
 80177a6:	781a      	ldrb	r2, [r3, #0]
 80177a8:	2104      	movs	r1, #4
 80177aa:	430a      	orrs	r2, r1
 80177ac:	701a      	strb	r2, [r3, #0]
    ao->mru = PPP_MAXMRU;
 80177ae:	68fb      	ldr	r3, [r7, #12]
 80177b0:	4a11      	ldr	r2, [pc, #68]	; (80177f8 <lcp_init+0xd8>)
 80177b2:	805a      	strh	r2, [r3, #2]
    ao->neg_asyncmap = 1;
 80177b4:	68fb      	ldr	r3, [r7, #12]
 80177b6:	781a      	ldrb	r2, [r3, #0]
 80177b8:	2108      	movs	r1, #8
 80177ba:	430a      	orrs	r2, r1
 80177bc:	701a      	strb	r2, [r3, #0]
    ao->neg_upap = 1;
#endif /* PAP_SUPPORT */
#if EAP_SUPPORT
    ao->neg_eap = 1;
#endif /* EAP_SUPPORT */
    ao->neg_magicnumber = 1;
 80177be:	68fb      	ldr	r3, [r7, #12]
 80177c0:	781a      	ldrb	r2, [r3, #0]
 80177c2:	2110      	movs	r1, #16
 80177c4:	430a      	orrs	r2, r1
 80177c6:	701a      	strb	r2, [r3, #0]
    ao->neg_pcompression = 1;
 80177c8:	68fb      	ldr	r3, [r7, #12]
 80177ca:	781a      	ldrb	r2, [r3, #0]
 80177cc:	2120      	movs	r1, #32
 80177ce:	430a      	orrs	r2, r1
 80177d0:	701a      	strb	r2, [r3, #0]
    ao->neg_accompression = 1;
 80177d2:	68fb      	ldr	r3, [r7, #12]
 80177d4:	781a      	ldrb	r2, [r3, #0]
 80177d6:	2140      	movs	r1, #64	; 0x40
 80177d8:	430a      	orrs	r2, r1
 80177da:	701a      	strb	r2, [r3, #0]
    ao->neg_endpoint = 1;
 80177dc:	68fb      	ldr	r3, [r7, #12]
 80177de:	785a      	ldrb	r2, [r3, #1]
 80177e0:	2102      	movs	r1, #2
 80177e2:	430a      	orrs	r2, r1
 80177e4:	705a      	strb	r2, [r3, #1]
}
 80177e6:	46c0      	nop			; (mov r8, r8)
 80177e8:	46bd      	mov	sp, r7
 80177ea:	b006      	add	sp, #24
 80177ec:	bd80      	pop	{r7, pc}
 80177ee:	46c0      	nop			; (mov r8, r8)
 80177f0:	ffffc021 	.word	0xffffc021
 80177f4:	080225cc 	.word	0x080225cc
 80177f8:	000005dc 	.word	0x000005dc

080177fc <lcp_open>:


/*
 * lcp_open - LCP is allowed to come up.
 */
void lcp_open(ppp_pcb *pcb) {
 80177fc:	b580      	push	{r7, lr}
 80177fe:	b084      	sub	sp, #16
 8017800:	af00      	add	r7, sp, #0
 8017802:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->lcp_fsm;
 8017804:	687b      	ldr	r3, [r7, #4]
 8017806:	3328      	adds	r3, #40	; 0x28
 8017808:	60fb      	str	r3, [r7, #12]
    lcp_options *wo = &pcb->lcp_wantoptions;
 801780a:	687b      	ldr	r3, [r7, #4]
 801780c:	3344      	adds	r3, #68	; 0x44
 801780e:	60bb      	str	r3, [r7, #8]

    f->flags &= ~(OPT_PASSIVE | OPT_SILENT);
 8017810:	68fb      	ldr	r3, [r7, #12]
 8017812:	7c5b      	ldrb	r3, [r3, #17]
 8017814:	2205      	movs	r2, #5
 8017816:	4393      	bics	r3, r2
 8017818:	b2da      	uxtb	r2, r3
 801781a:	68fb      	ldr	r3, [r7, #12]
 801781c:	745a      	strb	r2, [r3, #17]
    if (wo->passive)
 801781e:	68bb      	ldr	r3, [r7, #8]
 8017820:	781b      	ldrb	r3, [r3, #0]
 8017822:	2201      	movs	r2, #1
 8017824:	4013      	ands	r3, r2
 8017826:	b2db      	uxtb	r3, r3
 8017828:	2b00      	cmp	r3, #0
 801782a:	d006      	beq.n	801783a <lcp_open+0x3e>
	f->flags |= OPT_PASSIVE;
 801782c:	68fb      	ldr	r3, [r7, #12]
 801782e:	7c5b      	ldrb	r3, [r3, #17]
 8017830:	2201      	movs	r2, #1
 8017832:	4313      	orrs	r3, r2
 8017834:	b2da      	uxtb	r2, r3
 8017836:	68fb      	ldr	r3, [r7, #12]
 8017838:	745a      	strb	r2, [r3, #17]
    if (wo->silent)
 801783a:	68bb      	ldr	r3, [r7, #8]
 801783c:	781b      	ldrb	r3, [r3, #0]
 801783e:	2202      	movs	r2, #2
 8017840:	4013      	ands	r3, r2
 8017842:	b2db      	uxtb	r3, r3
 8017844:	2b00      	cmp	r3, #0
 8017846:	d006      	beq.n	8017856 <lcp_open+0x5a>
	f->flags |= OPT_SILENT;
 8017848:	68fb      	ldr	r3, [r7, #12]
 801784a:	7c5b      	ldrb	r3, [r3, #17]
 801784c:	2204      	movs	r2, #4
 801784e:	4313      	orrs	r3, r2
 8017850:	b2da      	uxtb	r2, r3
 8017852:	68fb      	ldr	r3, [r7, #12]
 8017854:	745a      	strb	r2, [r3, #17]
    fsm_open(f);
 8017856:	68fb      	ldr	r3, [r7, #12]
 8017858:	0018      	movs	r0, r3
 801785a:	f7fc fd7d 	bl	8014358 <fsm_open>
}
 801785e:	46c0      	nop			; (mov r8, r8)
 8017860:	46bd      	mov	sp, r7
 8017862:	b004      	add	sp, #16
 8017864:	bd80      	pop	{r7, pc}
	...

08017868 <lcp_close>:


/*
 * lcp_close - Take LCP down.
 */
void lcp_close(ppp_pcb *pcb, const char *reason) {
 8017868:	b580      	push	{r7, lr}
 801786a:	b084      	sub	sp, #16
 801786c:	af00      	add	r7, sp, #0
 801786e:	6078      	str	r0, [r7, #4]
 8017870:	6039      	str	r1, [r7, #0]
    fsm *f = &pcb->lcp_fsm;
 8017872:	687b      	ldr	r3, [r7, #4]
 8017874:	3328      	adds	r3, #40	; 0x28
 8017876:	60fb      	str	r3, [r7, #12]
    int oldstate;

    if (pcb->phase != PPP_PHASE_DEAD
 8017878:	687b      	ldr	r3, [r7, #4]
 801787a:	2224      	movs	r2, #36	; 0x24
 801787c:	5c9b      	ldrb	r3, [r3, r2]
 801787e:	2b00      	cmp	r3, #0
 8017880:	d004      	beq.n	801788c <lcp_close+0x24>
#ifdef HAVE_MULTILINK
    && pcb->phase != PPP_PHASE_MASTER
#endif /* HAVE_MULTILINK */
    )
	new_phase(pcb, PPP_PHASE_TERMINATE);
 8017882:	687b      	ldr	r3, [r7, #4]
 8017884:	210b      	movs	r1, #11
 8017886:	0018      	movs	r0, r3
 8017888:	f002 fba1 	bl	8019fce <new_phase>

    if (f->flags & DELAYED_UP) {
 801788c:	68fb      	ldr	r3, [r7, #12]
 801788e:	7c5b      	ldrb	r3, [r3, #17]
 8017890:	b25b      	sxtb	r3, r3
 8017892:	2b00      	cmp	r3, #0
 8017894:	da08      	bge.n	80178a8 <lcp_close+0x40>
	UNTIMEOUT(lcp_delayed_up, f);
 8017896:	68fa      	ldr	r2, [r7, #12]
 8017898:	4b14      	ldr	r3, [pc, #80]	; (80178ec <lcp_close+0x84>)
 801789a:	0011      	movs	r1, r2
 801789c:	0018      	movs	r0, r3
 801789e:	f7fa fc33 	bl	8012108 <sys_untimeout>
	f->state = PPP_FSM_STOPPED;
 80178a2:	68fb      	ldr	r3, [r7, #12]
 80178a4:	2203      	movs	r2, #3
 80178a6:	741a      	strb	r2, [r3, #16]
    }
    oldstate = f->state;
 80178a8:	68fb      	ldr	r3, [r7, #12]
 80178aa:	7c1b      	ldrb	r3, [r3, #16]
 80178ac:	60bb      	str	r3, [r7, #8]

    fsm_close(f, reason);
 80178ae:	683a      	ldr	r2, [r7, #0]
 80178b0:	68fb      	ldr	r3, [r7, #12]
 80178b2:	0011      	movs	r1, r2
 80178b4:	0018      	movs	r0, r3
 80178b6:	f7fc fe11 	bl	80144dc <fsm_close>
    if (oldstate == PPP_FSM_STOPPED && (f->flags & (OPT_PASSIVE|OPT_SILENT|DELAYED_UP))) {
 80178ba:	68bb      	ldr	r3, [r7, #8]
 80178bc:	2b03      	cmp	r3, #3
 80178be:	d110      	bne.n	80178e2 <lcp_close+0x7a>
 80178c0:	68fb      	ldr	r3, [r7, #12]
 80178c2:	7c5b      	ldrb	r3, [r3, #17]
 80178c4:	001a      	movs	r2, r3
 80178c6:	2385      	movs	r3, #133	; 0x85
 80178c8:	4013      	ands	r3, r2
 80178ca:	d00a      	beq.n	80178e2 <lcp_close+0x7a>
	 * but it does mean that the program terminates if you do a
	 * lcp_close() when a connection hasn't been established
	 * because we are in passive/silent mode or because we have
	 * delayed the fsm_lowerup() call and it hasn't happened yet.
	 */
	f->flags &= ~DELAYED_UP;
 80178cc:	68fb      	ldr	r3, [r7, #12]
 80178ce:	7c5b      	ldrb	r3, [r3, #17]
 80178d0:	227f      	movs	r2, #127	; 0x7f
 80178d2:	4013      	ands	r3, r2
 80178d4:	b2da      	uxtb	r2, r3
 80178d6:	68fb      	ldr	r3, [r7, #12]
 80178d8:	745a      	strb	r2, [r3, #17]
	lcp_finished(f);
 80178da:	68fb      	ldr	r3, [r7, #12]
 80178dc:	0018      	movs	r0, r3
 80178de:	f001 fe64 	bl	80195aa <lcp_finished>
    }
}
 80178e2:	46c0      	nop			; (mov r8, r8)
 80178e4:	46bd      	mov	sp, r7
 80178e6:	b004      	add	sp, #16
 80178e8:	bd80      	pop	{r7, pc}
 80178ea:	46c0      	nop			; (mov r8, r8)
 80178ec:	080179f9 	.word	0x080179f9

080178f0 <lcp_lowerup>:


/*
 * lcp_lowerup - The lower layer is up.
 */
void lcp_lowerup(ppp_pcb *pcb) {
 80178f0:	b590      	push	{r4, r7, lr}
 80178f2:	b087      	sub	sp, #28
 80178f4:	af02      	add	r7, sp, #8
 80178f6:	6078      	str	r0, [r7, #4]
    lcp_options *wo = &pcb->lcp_wantoptions;
 80178f8:	687b      	ldr	r3, [r7, #4]
 80178fa:	3344      	adds	r3, #68	; 0x44
 80178fc:	60fb      	str	r3, [r7, #12]
    fsm *f = &pcb->lcp_fsm;
 80178fe:	687b      	ldr	r3, [r7, #4]
 8017900:	3328      	adds	r3, #40	; 0x28
 8017902:	60bb      	str	r3, [r7, #8]
    /*
     * Don't use A/C or protocol compression on transmission,
     * but accept A/C and protocol compressed packets
     * if we are going to ask for A/C and protocol compression.
     */
    if (ppp_send_config(pcb, PPP_MRU, 0xffffffff, 0, 0) < 0
 8017904:	2301      	movs	r3, #1
 8017906:	425a      	negs	r2, r3
 8017908:	4927      	ldr	r1, [pc, #156]	; (80179a8 <lcp_lowerup+0xb8>)
 801790a:	6878      	ldr	r0, [r7, #4]
 801790c:	2300      	movs	r3, #0
 801790e:	9300      	str	r3, [sp, #0]
 8017910:	2300      	movs	r3, #0
 8017912:	f002 fb77 	bl	801a004 <ppp_send_config>
 8017916:	1e03      	subs	r3, r0, #0
 8017918:	db41      	blt.n	801799e <lcp_lowerup+0xae>
	|| ppp_recv_config(pcb, PPP_MRU, (pcb->settings.lax_recv? 0: 0xffffffff),
 801791a:	687b      	ldr	r3, [r7, #4]
 801791c:	781b      	ldrb	r3, [r3, #0]
 801791e:	2208      	movs	r2, #8
 8017920:	4013      	ands	r3, r2
 8017922:	b2db      	uxtb	r3, r3
 8017924:	2b00      	cmp	r3, #0
 8017926:	d001      	beq.n	801792c <lcp_lowerup+0x3c>
 8017928:	2200      	movs	r2, #0
 801792a:	e001      	b.n	8017930 <lcp_lowerup+0x40>
 801792c:	2301      	movs	r3, #1
 801792e:	425a      	negs	r2, r3
			   wo->neg_pcompression, wo->neg_accompression) < 0)
 8017930:	68fb      	ldr	r3, [r7, #12]
 8017932:	781b      	ldrb	r3, [r3, #0]
 8017934:	069b      	lsls	r3, r3, #26
 8017936:	0fdb      	lsrs	r3, r3, #31
 8017938:	b2db      	uxtb	r3, r3
	|| ppp_recv_config(pcb, PPP_MRU, (pcb->settings.lax_recv? 0: 0xffffffff),
 801793a:	001c      	movs	r4, r3
			   wo->neg_pcompression, wo->neg_accompression) < 0)
 801793c:	68fb      	ldr	r3, [r7, #12]
 801793e:	781b      	ldrb	r3, [r3, #0]
 8017940:	065b      	lsls	r3, r3, #25
 8017942:	0fdb      	lsrs	r3, r3, #31
 8017944:	b2db      	uxtb	r3, r3
	|| ppp_recv_config(pcb, PPP_MRU, (pcb->settings.lax_recv? 0: 0xffffffff),
 8017946:	4918      	ldr	r1, [pc, #96]	; (80179a8 <lcp_lowerup+0xb8>)
 8017948:	6878      	ldr	r0, [r7, #4]
 801794a:	9300      	str	r3, [sp, #0]
 801794c:	0023      	movs	r3, r4
 801794e:	f002 fb76 	bl	801a03e <ppp_recv_config>
 8017952:	1e03      	subs	r3, r0, #0
 8017954:	db23      	blt.n	801799e <lcp_lowerup+0xae>
	    return;
    pcb->peer_mru = PPP_MRU;
 8017956:	687b      	ldr	r3, [r7, #4]
 8017958:	22d4      	movs	r2, #212	; 0xd4
 801795a:	4913      	ldr	r1, [pc, #76]	; (80179a8 <lcp_lowerup+0xb8>)
 801795c:	5299      	strh	r1, [r3, r2]

    if (pcb->settings.listen_time != 0) {
 801795e:	687b      	ldr	r3, [r7, #4]
 8017960:	885b      	ldrh	r3, [r3, #2]
 8017962:	2b00      	cmp	r3, #0
 8017964:	d016      	beq.n	8017994 <lcp_lowerup+0xa4>
	f->flags |= DELAYED_UP;
 8017966:	68bb      	ldr	r3, [r7, #8]
 8017968:	7c5b      	ldrb	r3, [r3, #17]
 801796a:	2280      	movs	r2, #128	; 0x80
 801796c:	4252      	negs	r2, r2
 801796e:	4313      	orrs	r3, r2
 8017970:	b2da      	uxtb	r2, r3
 8017972:	68bb      	ldr	r3, [r7, #8]
 8017974:	745a      	strb	r2, [r3, #17]
	TIMEOUTMS(lcp_delayed_up, f, pcb->settings.listen_time);
 8017976:	68ba      	ldr	r2, [r7, #8]
 8017978:	4b0c      	ldr	r3, [pc, #48]	; (80179ac <lcp_lowerup+0xbc>)
 801797a:	0011      	movs	r1, r2
 801797c:	0018      	movs	r0, r3
 801797e:	f7fa fbc3 	bl	8012108 <sys_untimeout>
 8017982:	687b      	ldr	r3, [r7, #4]
 8017984:	885b      	ldrh	r3, [r3, #2]
 8017986:	0018      	movs	r0, r3
 8017988:	68ba      	ldr	r2, [r7, #8]
 801798a:	4b08      	ldr	r3, [pc, #32]	; (80179ac <lcp_lowerup+0xbc>)
 801798c:	0019      	movs	r1, r3
 801798e:	f7fa fb93 	bl	80120b8 <sys_timeout>
 8017992:	e005      	b.n	80179a0 <lcp_lowerup+0xb0>
    } else
	fsm_lowerup(f);
 8017994:	68bb      	ldr	r3, [r7, #8]
 8017996:	0018      	movs	r0, r3
 8017998:	f7fc fc6b 	bl	8014272 <fsm_lowerup>
 801799c:	e000      	b.n	80179a0 <lcp_lowerup+0xb0>
	    return;
 801799e:	46c0      	nop			; (mov r8, r8)
}
 80179a0:	46bd      	mov	sp, r7
 80179a2:	b005      	add	sp, #20
 80179a4:	bd90      	pop	{r4, r7, pc}
 80179a6:	46c0      	nop			; (mov r8, r8)
 80179a8:	000005dc 	.word	0x000005dc
 80179ac:	080179f9 	.word	0x080179f9

080179b0 <lcp_lowerdown>:


/*
 * lcp_lowerdown - The lower layer is down.
 */
void lcp_lowerdown(ppp_pcb *pcb) {
 80179b0:	b580      	push	{r7, lr}
 80179b2:	b084      	sub	sp, #16
 80179b4:	af00      	add	r7, sp, #0
 80179b6:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->lcp_fsm;
 80179b8:	687b      	ldr	r3, [r7, #4]
 80179ba:	3328      	adds	r3, #40	; 0x28
 80179bc:	60fb      	str	r3, [r7, #12]

    if (f->flags & DELAYED_UP) {
 80179be:	68fb      	ldr	r3, [r7, #12]
 80179c0:	7c5b      	ldrb	r3, [r3, #17]
 80179c2:	b25b      	sxtb	r3, r3
 80179c4:	2b00      	cmp	r3, #0
 80179c6:	da0d      	bge.n	80179e4 <lcp_lowerdown+0x34>
	f->flags &= ~DELAYED_UP;
 80179c8:	68fb      	ldr	r3, [r7, #12]
 80179ca:	7c5b      	ldrb	r3, [r3, #17]
 80179cc:	227f      	movs	r2, #127	; 0x7f
 80179ce:	4013      	ands	r3, r2
 80179d0:	b2da      	uxtb	r2, r3
 80179d2:	68fb      	ldr	r3, [r7, #12]
 80179d4:	745a      	strb	r2, [r3, #17]
	UNTIMEOUT(lcp_delayed_up, f);
 80179d6:	68fa      	ldr	r2, [r7, #12]
 80179d8:	4b06      	ldr	r3, [pc, #24]	; (80179f4 <lcp_lowerdown+0x44>)
 80179da:	0011      	movs	r1, r2
 80179dc:	0018      	movs	r0, r3
 80179de:	f7fa fb93 	bl	8012108 <sys_untimeout>
    } else
	fsm_lowerdown(f);
}
 80179e2:	e003      	b.n	80179ec <lcp_lowerdown+0x3c>
	fsm_lowerdown(f);
 80179e4:	68fb      	ldr	r3, [r7, #12]
 80179e6:	0018      	movs	r0, r3
 80179e8:	f7fc fc6a 	bl	80142c0 <fsm_lowerdown>
}
 80179ec:	46c0      	nop			; (mov r8, r8)
 80179ee:	46bd      	mov	sp, r7
 80179f0:	b004      	add	sp, #16
 80179f2:	bd80      	pop	{r7, pc}
 80179f4:	080179f9 	.word	0x080179f9

080179f8 <lcp_delayed_up>:


/*
 * lcp_delayed_up - Bring the lower layer up now.
 */
static void lcp_delayed_up(void *arg) {
 80179f8:	b580      	push	{r7, lr}
 80179fa:	b084      	sub	sp, #16
 80179fc:	af00      	add	r7, sp, #0
 80179fe:	6078      	str	r0, [r7, #4]
    fsm *f = (fsm*)arg;
 8017a00:	687b      	ldr	r3, [r7, #4]
 8017a02:	60fb      	str	r3, [r7, #12]

    if (f->flags & DELAYED_UP) {
 8017a04:	68fb      	ldr	r3, [r7, #12]
 8017a06:	7c5b      	ldrb	r3, [r3, #17]
 8017a08:	b25b      	sxtb	r3, r3
 8017a0a:	2b00      	cmp	r3, #0
 8017a0c:	da0a      	bge.n	8017a24 <lcp_delayed_up+0x2c>
	f->flags &= ~DELAYED_UP;
 8017a0e:	68fb      	ldr	r3, [r7, #12]
 8017a10:	7c5b      	ldrb	r3, [r3, #17]
 8017a12:	227f      	movs	r2, #127	; 0x7f
 8017a14:	4013      	ands	r3, r2
 8017a16:	b2da      	uxtb	r2, r3
 8017a18:	68fb      	ldr	r3, [r7, #12]
 8017a1a:	745a      	strb	r2, [r3, #17]
	fsm_lowerup(f);
 8017a1c:	68fb      	ldr	r3, [r7, #12]
 8017a1e:	0018      	movs	r0, r3
 8017a20:	f7fc fc27 	bl	8014272 <fsm_lowerup>
    }
}
 8017a24:	46c0      	nop			; (mov r8, r8)
 8017a26:	46bd      	mov	sp, r7
 8017a28:	b004      	add	sp, #16
 8017a2a:	bd80      	pop	{r7, pc}

08017a2c <lcp_input>:


/*
 * lcp_input - Input LCP packet.
 */
static void lcp_input(ppp_pcb *pcb, u_char *p, int len) {
 8017a2c:	b580      	push	{r7, lr}
 8017a2e:	b086      	sub	sp, #24
 8017a30:	af00      	add	r7, sp, #0
 8017a32:	60f8      	str	r0, [r7, #12]
 8017a34:	60b9      	str	r1, [r7, #8]
 8017a36:	607a      	str	r2, [r7, #4]
    fsm *f = &pcb->lcp_fsm;
 8017a38:	68fb      	ldr	r3, [r7, #12]
 8017a3a:	3328      	adds	r3, #40	; 0x28
 8017a3c:	617b      	str	r3, [r7, #20]

    if (f->flags & DELAYED_UP) {
 8017a3e:	697b      	ldr	r3, [r7, #20]
 8017a40:	7c5b      	ldrb	r3, [r3, #17]
 8017a42:	b25b      	sxtb	r3, r3
 8017a44:	2b00      	cmp	r3, #0
 8017a46:	da10      	bge.n	8017a6a <lcp_input+0x3e>
	f->flags &= ~DELAYED_UP;
 8017a48:	697b      	ldr	r3, [r7, #20]
 8017a4a:	7c5b      	ldrb	r3, [r3, #17]
 8017a4c:	227f      	movs	r2, #127	; 0x7f
 8017a4e:	4013      	ands	r3, r2
 8017a50:	b2da      	uxtb	r2, r3
 8017a52:	697b      	ldr	r3, [r7, #20]
 8017a54:	745a      	strb	r2, [r3, #17]
	UNTIMEOUT(lcp_delayed_up, f);
 8017a56:	697a      	ldr	r2, [r7, #20]
 8017a58:	4b09      	ldr	r3, [pc, #36]	; (8017a80 <lcp_input+0x54>)
 8017a5a:	0011      	movs	r1, r2
 8017a5c:	0018      	movs	r0, r3
 8017a5e:	f7fa fb53 	bl	8012108 <sys_untimeout>
	fsm_lowerup(f);
 8017a62:	697b      	ldr	r3, [r7, #20]
 8017a64:	0018      	movs	r0, r3
 8017a66:	f7fc fc04 	bl	8014272 <fsm_lowerup>
    }
    fsm_input(f, p, len);
 8017a6a:	687a      	ldr	r2, [r7, #4]
 8017a6c:	68b9      	ldr	r1, [r7, #8]
 8017a6e:	697b      	ldr	r3, [r7, #20]
 8017a70:	0018      	movs	r0, r3
 8017a72:	f7fc fe1d 	bl	80146b0 <fsm_input>
}
 8017a76:	46c0      	nop			; (mov r8, r8)
 8017a78:	46bd      	mov	sp, r7
 8017a7a:	b006      	add	sp, #24
 8017a7c:	bd80      	pop	{r7, pc}
 8017a7e:	46c0      	nop			; (mov r8, r8)
 8017a80:	080179f9 	.word	0x080179f9

08017a84 <lcp_extcode>:

/*
 * lcp_extcode - Handle a LCP-specific code.
 */
static int lcp_extcode(fsm *f, int code, int id, u_char *inp, int len) {
 8017a84:	b580      	push	{r7, lr}
 8017a86:	b08a      	sub	sp, #40	; 0x28
 8017a88:	af02      	add	r7, sp, #8
 8017a8a:	60f8      	str	r0, [r7, #12]
 8017a8c:	60b9      	str	r1, [r7, #8]
 8017a8e:	607a      	str	r2, [r7, #4]
 8017a90:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 8017a92:	68fb      	ldr	r3, [r7, #12]
 8017a94:	681b      	ldr	r3, [r3, #0]
 8017a96:	61fb      	str	r3, [r7, #28]
    lcp_options *go = &pcb->lcp_gotoptions;
 8017a98:	69fb      	ldr	r3, [r7, #28]
 8017a9a:	3368      	adds	r3, #104	; 0x68
 8017a9c:	61bb      	str	r3, [r7, #24]
    u_char *magp;

    switch( code ){
 8017a9e:	68bb      	ldr	r3, [r7, #8]
 8017aa0:	2b0d      	cmp	r3, #13
 8017aa2:	dc4d      	bgt.n	8017b40 <lcp_extcode+0xbc>
 8017aa4:	68bb      	ldr	r3, [r7, #8]
 8017aa6:	2b0b      	cmp	r3, #11
 8017aa8:	da4c      	bge.n	8017b44 <lcp_extcode+0xc0>
 8017aaa:	68bb      	ldr	r3, [r7, #8]
 8017aac:	2b0a      	cmp	r3, #10
 8017aae:	d040      	beq.n	8017b32 <lcp_extcode+0xae>
 8017ab0:	68bb      	ldr	r3, [r7, #8]
 8017ab2:	2b0a      	cmp	r3, #10
 8017ab4:	dc44      	bgt.n	8017b40 <lcp_extcode+0xbc>
 8017ab6:	68bb      	ldr	r3, [r7, #8]
 8017ab8:	2b08      	cmp	r3, #8
 8017aba:	d003      	beq.n	8017ac4 <lcp_extcode+0x40>
 8017abc:	68bb      	ldr	r3, [r7, #8]
 8017abe:	2b09      	cmp	r3, #9
 8017ac0:	d007      	beq.n	8017ad2 <lcp_extcode+0x4e>
 8017ac2:	e03d      	b.n	8017b40 <lcp_extcode+0xbc>
    case PROTREJ:
	lcp_rprotrej(f, inp, len);
 8017ac4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8017ac6:	6839      	ldr	r1, [r7, #0]
 8017ac8:	68fb      	ldr	r3, [r7, #12]
 8017aca:	0018      	movs	r0, r3
 8017acc:	f000 f842 	bl	8017b54 <lcp_rprotrej>
	break;
 8017ad0:	e03b      	b.n	8017b4a <lcp_extcode+0xc6>
    
    case ECHOREQ:
	if (f->state != PPP_FSM_OPENED)
 8017ad2:	68fb      	ldr	r3, [r7, #12]
 8017ad4:	7c1b      	ldrb	r3, [r3, #16]
 8017ad6:	2b09      	cmp	r3, #9
 8017ad8:	d136      	bne.n	8017b48 <lcp_extcode+0xc4>
	    break;
	magp = inp;
 8017ada:	683b      	ldr	r3, [r7, #0]
 8017adc:	617b      	str	r3, [r7, #20]
	PUTLONG(go->magicnumber, magp);
 8017ade:	69bb      	ldr	r3, [r7, #24]
 8017ae0:	689b      	ldr	r3, [r3, #8]
 8017ae2:	0e19      	lsrs	r1, r3, #24
 8017ae4:	697b      	ldr	r3, [r7, #20]
 8017ae6:	1c5a      	adds	r2, r3, #1
 8017ae8:	617a      	str	r2, [r7, #20]
 8017aea:	b2ca      	uxtb	r2, r1
 8017aec:	701a      	strb	r2, [r3, #0]
 8017aee:	69bb      	ldr	r3, [r7, #24]
 8017af0:	689b      	ldr	r3, [r3, #8]
 8017af2:	0c19      	lsrs	r1, r3, #16
 8017af4:	697b      	ldr	r3, [r7, #20]
 8017af6:	1c5a      	adds	r2, r3, #1
 8017af8:	617a      	str	r2, [r7, #20]
 8017afa:	b2ca      	uxtb	r2, r1
 8017afc:	701a      	strb	r2, [r3, #0]
 8017afe:	69bb      	ldr	r3, [r7, #24]
 8017b00:	689b      	ldr	r3, [r3, #8]
 8017b02:	0a19      	lsrs	r1, r3, #8
 8017b04:	697b      	ldr	r3, [r7, #20]
 8017b06:	1c5a      	adds	r2, r3, #1
 8017b08:	617a      	str	r2, [r7, #20]
 8017b0a:	b2ca      	uxtb	r2, r1
 8017b0c:	701a      	strb	r2, [r3, #0]
 8017b0e:	69bb      	ldr	r3, [r7, #24]
 8017b10:	6899      	ldr	r1, [r3, #8]
 8017b12:	697b      	ldr	r3, [r7, #20]
 8017b14:	1c5a      	adds	r2, r3, #1
 8017b16:	617a      	str	r2, [r7, #20]
 8017b18:	b2ca      	uxtb	r2, r1
 8017b1a:	701a      	strb	r2, [r3, #0]
	fsm_sdata(f, ECHOREP, id, inp, len);
 8017b1c:	687b      	ldr	r3, [r7, #4]
 8017b1e:	b2da      	uxtb	r2, r3
 8017b20:	6839      	ldr	r1, [r7, #0]
 8017b22:	68f8      	ldr	r0, [r7, #12]
 8017b24:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017b26:	9300      	str	r3, [sp, #0]
 8017b28:	000b      	movs	r3, r1
 8017b2a:	210a      	movs	r1, #10
 8017b2c:	f7fd faa2 	bl	8015074 <fsm_sdata>
	break;
 8017b30:	e00b      	b.n	8017b4a <lcp_extcode+0xc6>
    
    case ECHOREP:
	lcp_received_echo_reply(f, id, inp, len);
 8017b32:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017b34:	683a      	ldr	r2, [r7, #0]
 8017b36:	6879      	ldr	r1, [r7, #4]
 8017b38:	68f8      	ldr	r0, [r7, #12]
 8017b3a:	f001 fdd1 	bl	80196e0 <lcp_received_echo_reply>
	break;
 8017b3e:	e004      	b.n	8017b4a <lcp_extcode+0xc6>
    case IDENTIF:
    case TIMEREM:
	break;

    default:
	return 0;
 8017b40:	2300      	movs	r3, #0
 8017b42:	e003      	b.n	8017b4c <lcp_extcode+0xc8>
	break;
 8017b44:	46c0      	nop			; (mov r8, r8)
 8017b46:	e000      	b.n	8017b4a <lcp_extcode+0xc6>
	    break;
 8017b48:	46c0      	nop			; (mov r8, r8)
    }
    return 1;
 8017b4a:	2301      	movs	r3, #1
}
 8017b4c:	0018      	movs	r0, r3
 8017b4e:	46bd      	mov	sp, r7
 8017b50:	b008      	add	sp, #32
 8017b52:	bd80      	pop	{r7, pc}

08017b54 <lcp_rprotrej>:
/*
 * lcp_rprotrej - Receive an Protocol-Reject.
 *
 * Figure out which protocol is rejected and inform it.
 */
static void lcp_rprotrej(fsm *f, u_char *inp, int len) {
 8017b54:	b580      	push	{r7, lr}
 8017b56:	b088      	sub	sp, #32
 8017b58:	af00      	add	r7, sp, #0
 8017b5a:	60f8      	str	r0, [r7, #12]
 8017b5c:	60b9      	str	r1, [r7, #8]
 8017b5e:	607a      	str	r2, [r7, #4]
    u_short prot;
#if PPP_PROTOCOLNAME
    const char *pname;
#endif /* PPP_PROTOCOLNAME */

    if (len < 2) {
 8017b60:	687b      	ldr	r3, [r7, #4]
 8017b62:	2b01      	cmp	r3, #1
 8017b64:	dd42      	ble.n	8017bec <lcp_rprotrej+0x98>
	LCPDEBUG(("lcp_rprotrej: Rcvd short Protocol-Reject packet!"));
	return;
    }

    GETSHORT(prot, inp);
 8017b66:	68bb      	ldr	r3, [r7, #8]
 8017b68:	1c5a      	adds	r2, r3, #1
 8017b6a:	60ba      	str	r2, [r7, #8]
 8017b6c:	781b      	ldrb	r3, [r3, #0]
 8017b6e:	b29a      	uxth	r2, r3
 8017b70:	201a      	movs	r0, #26
 8017b72:	183b      	adds	r3, r7, r0
 8017b74:	0212      	lsls	r2, r2, #8
 8017b76:	801a      	strh	r2, [r3, #0]
 8017b78:	68bb      	ldr	r3, [r7, #8]
 8017b7a:	1c5a      	adds	r2, r3, #1
 8017b7c:	60ba      	str	r2, [r7, #8]
 8017b7e:	781b      	ldrb	r3, [r3, #0]
 8017b80:	b299      	uxth	r1, r3
 8017b82:	183b      	adds	r3, r7, r0
 8017b84:	183a      	adds	r2, r7, r0
 8017b86:	8812      	ldrh	r2, [r2, #0]
 8017b88:	430a      	orrs	r2, r1
 8017b8a:	801a      	strh	r2, [r3, #0]

    /*
     * Protocol-Reject packets received in any state other than the LCP
     * OPENED state SHOULD be silently discarded.
     */
    if( f->state != PPP_FSM_OPENED ){
 8017b8c:	68fb      	ldr	r3, [r7, #12]
 8017b8e:	7c1b      	ldrb	r3, [r3, #16]
 8017b90:	2b09      	cmp	r3, #9
 8017b92:	d12d      	bne.n	8017bf0 <lcp_rprotrej+0x9c>
#endif /* PPP_PROTOCOLNAME */

    /*
     * Upcall the proper Protocol-Reject routine.
     */
    for (i = 0; (protp = protocols[i]) != NULL; ++i)
 8017b94:	2300      	movs	r3, #0
 8017b96:	61fb      	str	r3, [r7, #28]
 8017b98:	e017      	b.n	8017bca <lcp_rprotrej+0x76>
	if (protp->protocol == prot) {
 8017b9a:	697b      	ldr	r3, [r7, #20]
 8017b9c:	881b      	ldrh	r3, [r3, #0]
 8017b9e:	211a      	movs	r1, #26
 8017ba0:	187a      	adds	r2, r7, r1
 8017ba2:	8812      	ldrh	r2, [r2, #0]
 8017ba4:	429a      	cmp	r2, r3
 8017ba6:	d10d      	bne.n	8017bc4 <lcp_rprotrej+0x70>
	    if (pname != NULL)
		ppp_dbglog("Protocol-Reject for '%s' (0x%x) received", pname,
		       prot);
	    else
#endif /* PPP_PROTOCOLNAME */
		ppp_dbglog("Protocol-Reject for 0x%x received", prot);
 8017ba8:	187b      	adds	r3, r7, r1
 8017baa:	881a      	ldrh	r2, [r3, #0]
 8017bac:	4b12      	ldr	r3, [pc, #72]	; (8017bf8 <lcp_rprotrej+0xa4>)
 8017bae:	0011      	movs	r1, r2
 8017bb0:	0018      	movs	r0, r3
 8017bb2:	f003 fd06 	bl	801b5c2 <ppp_dbglog>
	    (*protp->protrej)(f->pcb);
 8017bb6:	697b      	ldr	r3, [r7, #20]
 8017bb8:	68da      	ldr	r2, [r3, #12]
 8017bba:	68fb      	ldr	r3, [r7, #12]
 8017bbc:	681b      	ldr	r3, [r3, #0]
 8017bbe:	0018      	movs	r0, r3
 8017bc0:	4790      	blx	r2
	    return;
 8017bc2:	e016      	b.n	8017bf2 <lcp_rprotrej+0x9e>
    for (i = 0; (protp = protocols[i]) != NULL; ++i)
 8017bc4:	69fb      	ldr	r3, [r7, #28]
 8017bc6:	3301      	adds	r3, #1
 8017bc8:	61fb      	str	r3, [r7, #28]
 8017bca:	4b0c      	ldr	r3, [pc, #48]	; (8017bfc <lcp_rprotrej+0xa8>)
 8017bcc:	69fa      	ldr	r2, [r7, #28]
 8017bce:	0092      	lsls	r2, r2, #2
 8017bd0:	58d3      	ldr	r3, [r2, r3]
 8017bd2:	617b      	str	r3, [r7, #20]
 8017bd4:	697b      	ldr	r3, [r7, #20]
 8017bd6:	2b00      	cmp	r3, #0
 8017bd8:	d1df      	bne.n	8017b9a <lcp_rprotrej+0x46>
    if (pname != NULL)
	ppp_warn("Protocol-Reject for unsupported protocol '%s' (0x%x)", pname,
	     prot);
    else
#endif /* #if PPP_PROTOCOLNAME */
	ppp_warn("Protocol-Reject for unsupported protocol 0x%x", prot);
 8017bda:	231a      	movs	r3, #26
 8017bdc:	18fb      	adds	r3, r7, r3
 8017bde:	881a      	ldrh	r2, [r3, #0]
 8017be0:	4b07      	ldr	r3, [pc, #28]	; (8017c00 <lcp_rprotrej+0xac>)
 8017be2:	0011      	movs	r1, r2
 8017be4:	0018      	movs	r0, r3
 8017be6:	f003 fcb0 	bl	801b54a <ppp_warn>
 8017bea:	e002      	b.n	8017bf2 <lcp_rprotrej+0x9e>
	return;
 8017bec:	46c0      	nop			; (mov r8, r8)
 8017bee:	e000      	b.n	8017bf2 <lcp_rprotrej+0x9e>
	return;
 8017bf0:	46c0      	nop			; (mov r8, r8)
}
 8017bf2:	46bd      	mov	sp, r7
 8017bf4:	b008      	add	sp, #32
 8017bf6:	bd80      	pop	{r7, pc}
 8017bf8:	08021914 	.word	0x08021914
 8017bfc:	080226d8 	.word	0x080226d8
 8017c00:	08021938 	.word	0x08021938

08017c04 <lcp_protrej>:

/*
 * lcp_protrej - A Protocol-Reject was received.
 */
/*ARGSUSED*/
static void lcp_protrej(ppp_pcb *pcb) {
 8017c04:	b580      	push	{r7, lr}
 8017c06:	b082      	sub	sp, #8
 8017c08:	af00      	add	r7, sp, #0
 8017c0a:	6078      	str	r0, [r7, #4]
    /*
     * Can't reject LCP!
     */
    ppp_error("Received Protocol-Reject for LCP!");
 8017c0c:	4b06      	ldr	r3, [pc, #24]	; (8017c28 <lcp_protrej+0x24>)
 8017c0e:	0018      	movs	r0, r3
 8017c10:	f003 fc87 	bl	801b522 <ppp_error>
    fsm_protreject(&pcb->lcp_fsm);
 8017c14:	687b      	ldr	r3, [r7, #4]
 8017c16:	3328      	adds	r3, #40	; 0x28
 8017c18:	0018      	movs	r0, r3
 8017c1a:	f7fd f8ed 	bl	8014df8 <fsm_protreject>
}
 8017c1e:	46c0      	nop			; (mov r8, r8)
 8017c20:	46bd      	mov	sp, r7
 8017c22:	b002      	add	sp, #8
 8017c24:	bd80      	pop	{r7, pc}
 8017c26:	46c0      	nop			; (mov r8, r8)
 8017c28:	08021968 	.word	0x08021968

08017c2c <lcp_sprotrej>:


/*
 * lcp_sprotrej - Send a Protocol-Reject for some protocol.
 */
void lcp_sprotrej(ppp_pcb *pcb, u_char *p, int len) {
 8017c2c:	b580      	push	{r7, lr}
 8017c2e:	b088      	sub	sp, #32
 8017c30:	af02      	add	r7, sp, #8
 8017c32:	60f8      	str	r0, [r7, #12]
 8017c34:	60b9      	str	r1, [r7, #8]
 8017c36:	607a      	str	r2, [r7, #4]
    fsm *f = &pcb->lcp_fsm;
 8017c38:	68fb      	ldr	r3, [r7, #12]
 8017c3a:	3328      	adds	r3, #40	; 0x28
 8017c3c:	617b      	str	r3, [r7, #20]
#if 0
    p += 2;
    len -= 2;
#endif

    fsm_sdata(f, PROTREJ, ++f->id,
 8017c3e:	697b      	ldr	r3, [r7, #20]
 8017c40:	7c9b      	ldrb	r3, [r3, #18]
 8017c42:	3301      	adds	r3, #1
 8017c44:	b2da      	uxtb	r2, r3
 8017c46:	697b      	ldr	r3, [r7, #20]
 8017c48:	749a      	strb	r2, [r3, #18]
 8017c4a:	697b      	ldr	r3, [r7, #20]
 8017c4c:	7c9a      	ldrb	r2, [r3, #18]
 8017c4e:	68b9      	ldr	r1, [r7, #8]
 8017c50:	6978      	ldr	r0, [r7, #20]
 8017c52:	687b      	ldr	r3, [r7, #4]
 8017c54:	9300      	str	r3, [sp, #0]
 8017c56:	000b      	movs	r3, r1
 8017c58:	2108      	movs	r1, #8
 8017c5a:	f7fd fa0b 	bl	8015074 <fsm_sdata>
	      p, len);
}
 8017c5e:	46c0      	nop			; (mov r8, r8)
 8017c60:	46bd      	mov	sp, r7
 8017c62:	b006      	add	sp, #24
 8017c64:	bd80      	pop	{r7, pc}
	...

08017c68 <lcp_resetci>:


/*
 * lcp_resetci - Reset our CI.
 */
static void lcp_resetci(fsm *f) {
 8017c68:	b590      	push	{r4, r7, lr}
 8017c6a:	b087      	sub	sp, #28
 8017c6c:	af00      	add	r7, sp, #0
 8017c6e:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8017c70:	687b      	ldr	r3, [r7, #4]
 8017c72:	681b      	ldr	r3, [r3, #0]
 8017c74:	617b      	str	r3, [r7, #20]
    lcp_options *wo = &pcb->lcp_wantoptions;
 8017c76:	697b      	ldr	r3, [r7, #20]
 8017c78:	3344      	adds	r3, #68	; 0x44
 8017c7a:	613b      	str	r3, [r7, #16]
    lcp_options *go = &pcb->lcp_gotoptions;
 8017c7c:	697b      	ldr	r3, [r7, #20]
 8017c7e:	3368      	adds	r3, #104	; 0x68
 8017c80:	60fb      	str	r3, [r7, #12]
    lcp_options *ao = &pcb->lcp_allowoptions;
 8017c82:	697b      	ldr	r3, [r7, #20]
 8017c84:	338c      	adds	r3, #140	; 0x8c
 8017c86:	60bb      	str	r3, [r7, #8]
#endif /* EAP_SUPPORT */
    PPPDEBUG(LOG_DEBUG, ("\n"));

#endif /* PPP_AUTH_SUPPORT */

    wo->magicnumber = magic();
 8017c88:	f001 fe36 	bl	80198f8 <magic>
 8017c8c:	0002      	movs	r2, r0
 8017c8e:	693b      	ldr	r3, [r7, #16]
 8017c90:	609a      	str	r2, [r3, #8]
    wo->numloops = 0;
 8017c92:	693b      	ldr	r3, [r7, #16]
 8017c94:	2200      	movs	r2, #0
 8017c96:	731a      	strb	r2, [r3, #12]
    *go = *wo;
 8017c98:	68fb      	ldr	r3, [r7, #12]
 8017c9a:	693a      	ldr	r2, [r7, #16]
 8017c9c:	ca13      	ldmia	r2!, {r0, r1, r4}
 8017c9e:	c313      	stmia	r3!, {r0, r1, r4}
 8017ca0:	ca13      	ldmia	r2!, {r0, r1, r4}
 8017ca2:	c313      	stmia	r3!, {r0, r1, r4}
 8017ca4:	ca13      	ldmia	r2!, {r0, r1, r4}
 8017ca6:	c313      	stmia	r3!, {r0, r1, r4}
#ifdef HAVE_MULTILINK
    if (!multilink) {
	go->neg_mrru = 0;
#endif /* HAVE_MULTILINK */
	go->neg_ssnhf = 0;
 8017ca8:	68fb      	ldr	r3, [r7, #12]
 8017caa:	785a      	ldrb	r2, [r3, #1]
 8017cac:	2101      	movs	r1, #1
 8017cae:	438a      	bics	r2, r1
 8017cb0:	705a      	strb	r2, [r3, #1]
	go->neg_endpoint = 0;
 8017cb2:	68fb      	ldr	r3, [r7, #12]
 8017cb4:	785a      	ldrb	r2, [r3, #1]
 8017cb6:	2102      	movs	r1, #2
 8017cb8:	438a      	bics	r2, r1
 8017cba:	705a      	strb	r2, [r3, #1]
#ifdef HAVE_MULTILINK
    }
#endif /* HAVE_MULTILINK */
    if (pcb->settings.noendpoint)
 8017cbc:	697b      	ldr	r3, [r7, #20]
 8017cbe:	781b      	ldrb	r3, [r3, #0]
 8017cc0:	2210      	movs	r2, #16
 8017cc2:	4013      	ands	r3, r2
 8017cc4:	b2db      	uxtb	r3, r3
 8017cc6:	2b00      	cmp	r3, #0
 8017cc8:	d004      	beq.n	8017cd4 <lcp_resetci+0x6c>
	ao->neg_endpoint = 0;
 8017cca:	68bb      	ldr	r3, [r7, #8]
 8017ccc:	785a      	ldrb	r2, [r3, #1]
 8017cce:	2102      	movs	r1, #2
 8017cd0:	438a      	bics	r2, r1
 8017cd2:	705a      	strb	r2, [r3, #1]
    pcb->peer_mru = PPP_MRU;
 8017cd4:	697b      	ldr	r3, [r7, #20]
 8017cd6:	22d4      	movs	r2, #212	; 0xd4
 8017cd8:	4902      	ldr	r1, [pc, #8]	; (8017ce4 <lcp_resetci+0x7c>)
 8017cda:	5299      	strh	r1, [r3, r2]
#if 0 /* UNUSED */
    auth_reset(pcb);
#endif /* UNUSED */
}
 8017cdc:	46c0      	nop			; (mov r8, r8)
 8017cde:	46bd      	mov	sp, r7
 8017ce0:	b007      	add	sp, #28
 8017ce2:	bd90      	pop	{r4, r7, pc}
 8017ce4:	000005dc 	.word	0x000005dc

08017ce8 <lcp_cilen>:


/*
 * lcp_cilen - Return length of our CI.
 */
static int lcp_cilen(fsm *f) {
 8017ce8:	b580      	push	{r7, lr}
 8017cea:	b084      	sub	sp, #16
 8017cec:	af00      	add	r7, sp, #0
 8017cee:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8017cf0:	687b      	ldr	r3, [r7, #4]
 8017cf2:	681b      	ldr	r3, [r3, #0]
 8017cf4:	60fb      	str	r3, [r7, #12]
    lcp_options *go = &pcb->lcp_gotoptions;
 8017cf6:	68fb      	ldr	r3, [r7, #12]
 8017cf8:	3368      	adds	r3, #104	; 0x68
 8017cfa:	60bb      	str	r3, [r7, #8]
    /*
     * NB: we only ask for one of CHAP, UPAP, or EAP, even if we will
     * accept more than one.  We prefer EAP first, then CHAP, then
     * PAP.
     */
    return (LENCISHORT(go->neg_mru && go->mru != PPP_DEFMRU) +
 8017cfc:	68bb      	ldr	r3, [r7, #8]
 8017cfe:	781b      	ldrb	r3, [r3, #0]
 8017d00:	2204      	movs	r2, #4
 8017d02:	4013      	ands	r3, r2
 8017d04:	b2db      	uxtb	r3, r3
 8017d06:	2b00      	cmp	r3, #0
 8017d08:	d006      	beq.n	8017d18 <lcp_cilen+0x30>
 8017d0a:	68bb      	ldr	r3, [r7, #8]
 8017d0c:	885b      	ldrh	r3, [r3, #2]
 8017d0e:	4a29      	ldr	r2, [pc, #164]	; (8017db4 <lcp_cilen+0xcc>)
 8017d10:	4293      	cmp	r3, r2
 8017d12:	d001      	beq.n	8017d18 <lcp_cilen+0x30>
 8017d14:	2204      	movs	r2, #4
 8017d16:	e000      	b.n	8017d1a <lcp_cilen+0x32>
 8017d18:	2200      	movs	r2, #0
	    LENCILONG(go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF) +
 8017d1a:	68bb      	ldr	r3, [r7, #8]
 8017d1c:	781b      	ldrb	r3, [r3, #0]
 8017d1e:	2108      	movs	r1, #8
 8017d20:	400b      	ands	r3, r1
 8017d22:	b2db      	uxtb	r3, r3
 8017d24:	2b00      	cmp	r3, #0
 8017d26:	d005      	beq.n	8017d34 <lcp_cilen+0x4c>
 8017d28:	68bb      	ldr	r3, [r7, #8]
 8017d2a:	685b      	ldr	r3, [r3, #4]
 8017d2c:	3301      	adds	r3, #1
 8017d2e:	d001      	beq.n	8017d34 <lcp_cilen+0x4c>
 8017d30:	2306      	movs	r3, #6
 8017d32:	e000      	b.n	8017d36 <lcp_cilen+0x4e>
 8017d34:	2300      	movs	r3, #0
    return (LENCISHORT(go->neg_mru && go->mru != PPP_DEFMRU) +
 8017d36:	18d2      	adds	r2, r2, r3
#endif /* !EAP_SUPPORT && !CHAP_SUPPORT */
#endif /* PAP_SUPPORT */
#if LQR_SUPPORT
	    LENCILQR(go->neg_lqr) +
#endif /* LQR_SUPPORT */
	    LENCICBCP(go->neg_cbcp) +
 8017d38:	68bb      	ldr	r3, [r7, #8]
 8017d3a:	781b      	ldrb	r3, [r3, #0]
 8017d3c:	217f      	movs	r1, #127	; 0x7f
 8017d3e:	438b      	bics	r3, r1
 8017d40:	b2db      	uxtb	r3, r3
 8017d42:	2b00      	cmp	r3, #0
 8017d44:	d001      	beq.n	8017d4a <lcp_cilen+0x62>
 8017d46:	2303      	movs	r3, #3
 8017d48:	e000      	b.n	8017d4c <lcp_cilen+0x64>
 8017d4a:	2300      	movs	r3, #0
	    LENCILONG(go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF) +
 8017d4c:	189a      	adds	r2, r3, r2
	    LENCILONG(go->neg_magicnumber) +
 8017d4e:	68bb      	ldr	r3, [r7, #8]
 8017d50:	781b      	ldrb	r3, [r3, #0]
 8017d52:	2110      	movs	r1, #16
 8017d54:	400b      	ands	r3, r1
 8017d56:	b2db      	uxtb	r3, r3
 8017d58:	2b00      	cmp	r3, #0
 8017d5a:	d001      	beq.n	8017d60 <lcp_cilen+0x78>
 8017d5c:	2306      	movs	r3, #6
 8017d5e:	e000      	b.n	8017d62 <lcp_cilen+0x7a>
 8017d60:	2300      	movs	r3, #0
	    LENCICBCP(go->neg_cbcp) +
 8017d62:	189a      	adds	r2, r3, r2
	    LENCIVOID(go->neg_pcompression) +
 8017d64:	68bb      	ldr	r3, [r7, #8]
 8017d66:	781b      	ldrb	r3, [r3, #0]
 8017d68:	091b      	lsrs	r3, r3, #4
 8017d6a:	b2db      	uxtb	r3, r3
 8017d6c:	0019      	movs	r1, r3
 8017d6e:	2302      	movs	r3, #2
 8017d70:	400b      	ands	r3, r1
	    LENCILONG(go->neg_magicnumber) +
 8017d72:	18d2      	adds	r2, r2, r3
	    LENCIVOID(go->neg_accompression) +
 8017d74:	68bb      	ldr	r3, [r7, #8]
 8017d76:	781b      	ldrb	r3, [r3, #0]
 8017d78:	095b      	lsrs	r3, r3, #5
 8017d7a:	b2db      	uxtb	r3, r3
 8017d7c:	0019      	movs	r1, r3
 8017d7e:	2302      	movs	r3, #2
 8017d80:	400b      	ands	r3, r1
	    LENCIVOID(go->neg_pcompression) +
 8017d82:	18d2      	adds	r2, r2, r3
#ifdef HAVE_MULTILINK
	    LENCISHORT(go->neg_mrru) +
#endif /* HAVE_MULTILINK */
	    LENCIVOID(go->neg_ssnhf) +
 8017d84:	68bb      	ldr	r3, [r7, #8]
 8017d86:	785b      	ldrb	r3, [r3, #1]
 8017d88:	005b      	lsls	r3, r3, #1
 8017d8a:	2102      	movs	r1, #2
 8017d8c:	400b      	ands	r3, r1
	    LENCIVOID(go->neg_accompression) +
 8017d8e:	18d2      	adds	r2, r2, r3
	    (go->neg_endpoint? CILEN_CHAR + go->endpoint.length: 0));
 8017d90:	68bb      	ldr	r3, [r7, #8]
 8017d92:	785b      	ldrb	r3, [r3, #1]
 8017d94:	2102      	movs	r1, #2
 8017d96:	400b      	ands	r3, r1
 8017d98:	b2db      	uxtb	r3, r3
 8017d9a:	2b00      	cmp	r3, #0
 8017d9c:	d003      	beq.n	8017da6 <lcp_cilen+0xbe>
 8017d9e:	68bb      	ldr	r3, [r7, #8]
 8017da0:	7b9b      	ldrb	r3, [r3, #14]
 8017da2:	3303      	adds	r3, #3
 8017da4:	e000      	b.n	8017da8 <lcp_cilen+0xc0>
 8017da6:	2300      	movs	r3, #0
	    LENCIVOID(go->neg_ssnhf) +
 8017da8:	189b      	adds	r3, r3, r2
}
 8017daa:	0018      	movs	r0, r3
 8017dac:	46bd      	mov	sp, r7
 8017dae:	b004      	add	sp, #16
 8017db0:	bd80      	pop	{r7, pc}
 8017db2:	46c0      	nop			; (mov r8, r8)
 8017db4:	000005dc 	.word	0x000005dc

08017db8 <lcp_addci>:


/*
 * lcp_addci - Add our desired CIs to a packet.
 */
static void lcp_addci(fsm *f, u_char *ucp, int *lenp) {
 8017db8:	b580      	push	{r7, lr}
 8017dba:	b088      	sub	sp, #32
 8017dbc:	af00      	add	r7, sp, #0
 8017dbe:	60f8      	str	r0, [r7, #12]
 8017dc0:	60b9      	str	r1, [r7, #8]
 8017dc2:	607a      	str	r2, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8017dc4:	68fb      	ldr	r3, [r7, #12]
 8017dc6:	681b      	ldr	r3, [r3, #0]
 8017dc8:	61bb      	str	r3, [r7, #24]
    lcp_options *go = &pcb->lcp_gotoptions;
 8017dca:	69bb      	ldr	r3, [r7, #24]
 8017dcc:	3368      	adds	r3, #104	; 0x68
 8017dce:	617b      	str	r3, [r7, #20]
    u_char *start_ucp = ucp;
 8017dd0:	68bb      	ldr	r3, [r7, #8]
 8017dd2:	613b      	str	r3, [r7, #16]
	PUTCHAR(class, ucp); \
	for (i = 0; i < len; ++i) \
	    PUTCHAR(val[i], ucp); \
    }

    ADDCISHORT(CI_MRU, go->neg_mru && go->mru != PPP_DEFMRU, go->mru);
 8017dd4:	697b      	ldr	r3, [r7, #20]
 8017dd6:	781b      	ldrb	r3, [r3, #0]
 8017dd8:	2204      	movs	r2, #4
 8017dda:	4013      	ands	r3, r2
 8017ddc:	b2db      	uxtb	r3, r3
 8017dde:	2b00      	cmp	r3, #0
 8017de0:	d01e      	beq.n	8017e20 <lcp_addci+0x68>
 8017de2:	697b      	ldr	r3, [r7, #20]
 8017de4:	885b      	ldrh	r3, [r3, #2]
 8017de6:	4a84      	ldr	r2, [pc, #528]	; (8017ff8 <lcp_addci+0x240>)
 8017de8:	4293      	cmp	r3, r2
 8017dea:	d019      	beq.n	8017e20 <lcp_addci+0x68>
 8017dec:	68bb      	ldr	r3, [r7, #8]
 8017dee:	1c5a      	adds	r2, r3, #1
 8017df0:	60ba      	str	r2, [r7, #8]
 8017df2:	2201      	movs	r2, #1
 8017df4:	701a      	strb	r2, [r3, #0]
 8017df6:	68bb      	ldr	r3, [r7, #8]
 8017df8:	1c5a      	adds	r2, r3, #1
 8017dfa:	60ba      	str	r2, [r7, #8]
 8017dfc:	2204      	movs	r2, #4
 8017dfe:	701a      	strb	r2, [r3, #0]
 8017e00:	697b      	ldr	r3, [r7, #20]
 8017e02:	885b      	ldrh	r3, [r3, #2]
 8017e04:	0a1b      	lsrs	r3, r3, #8
 8017e06:	b299      	uxth	r1, r3
 8017e08:	68bb      	ldr	r3, [r7, #8]
 8017e0a:	1c5a      	adds	r2, r3, #1
 8017e0c:	60ba      	str	r2, [r7, #8]
 8017e0e:	b2ca      	uxtb	r2, r1
 8017e10:	701a      	strb	r2, [r3, #0]
 8017e12:	697b      	ldr	r3, [r7, #20]
 8017e14:	8859      	ldrh	r1, [r3, #2]
 8017e16:	68bb      	ldr	r3, [r7, #8]
 8017e18:	1c5a      	adds	r2, r3, #1
 8017e1a:	60ba      	str	r2, [r7, #8]
 8017e1c:	b2ca      	uxtb	r2, r1
 8017e1e:	701a      	strb	r2, [r3, #0]
    ADDCILONG(CI_ASYNCMAP, go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF,
 8017e20:	697b      	ldr	r3, [r7, #20]
 8017e22:	781b      	ldrb	r3, [r3, #0]
 8017e24:	2208      	movs	r2, #8
 8017e26:	4013      	ands	r3, r2
 8017e28:	b2db      	uxtb	r3, r3
 8017e2a:	2b00      	cmp	r3, #0
 8017e2c:	d02c      	beq.n	8017e88 <lcp_addci+0xd0>
 8017e2e:	697b      	ldr	r3, [r7, #20]
 8017e30:	685b      	ldr	r3, [r3, #4]
 8017e32:	3301      	adds	r3, #1
 8017e34:	d028      	beq.n	8017e88 <lcp_addci+0xd0>
 8017e36:	68bb      	ldr	r3, [r7, #8]
 8017e38:	1c5a      	adds	r2, r3, #1
 8017e3a:	60ba      	str	r2, [r7, #8]
 8017e3c:	2202      	movs	r2, #2
 8017e3e:	701a      	strb	r2, [r3, #0]
 8017e40:	68bb      	ldr	r3, [r7, #8]
 8017e42:	1c5a      	adds	r2, r3, #1
 8017e44:	60ba      	str	r2, [r7, #8]
 8017e46:	2206      	movs	r2, #6
 8017e48:	701a      	strb	r2, [r3, #0]
 8017e4a:	697b      	ldr	r3, [r7, #20]
 8017e4c:	685b      	ldr	r3, [r3, #4]
 8017e4e:	0e19      	lsrs	r1, r3, #24
 8017e50:	68bb      	ldr	r3, [r7, #8]
 8017e52:	1c5a      	adds	r2, r3, #1
 8017e54:	60ba      	str	r2, [r7, #8]
 8017e56:	b2ca      	uxtb	r2, r1
 8017e58:	701a      	strb	r2, [r3, #0]
 8017e5a:	697b      	ldr	r3, [r7, #20]
 8017e5c:	685b      	ldr	r3, [r3, #4]
 8017e5e:	0c19      	lsrs	r1, r3, #16
 8017e60:	68bb      	ldr	r3, [r7, #8]
 8017e62:	1c5a      	adds	r2, r3, #1
 8017e64:	60ba      	str	r2, [r7, #8]
 8017e66:	b2ca      	uxtb	r2, r1
 8017e68:	701a      	strb	r2, [r3, #0]
 8017e6a:	697b      	ldr	r3, [r7, #20]
 8017e6c:	685b      	ldr	r3, [r3, #4]
 8017e6e:	0a19      	lsrs	r1, r3, #8
 8017e70:	68bb      	ldr	r3, [r7, #8]
 8017e72:	1c5a      	adds	r2, r3, #1
 8017e74:	60ba      	str	r2, [r7, #8]
 8017e76:	b2ca      	uxtb	r2, r1
 8017e78:	701a      	strb	r2, [r3, #0]
 8017e7a:	697b      	ldr	r3, [r7, #20]
 8017e7c:	6859      	ldr	r1, [r3, #4]
 8017e7e:	68bb      	ldr	r3, [r7, #8]
 8017e80:	1c5a      	adds	r2, r3, #1
 8017e82:	60ba      	str	r2, [r7, #8]
 8017e84:	b2ca      	uxtb	r2, r1
 8017e86:	701a      	strb	r2, [r3, #0]
#endif /* !EAP_SUPPORT && !CHAP_SUPPORT */
#endif /* PAP_SUPPORT */
#if LQR_SUPPORT
    ADDCILQR(CI_QUALITY, go->neg_lqr, go->lqr_period);
#endif /* LQR_SUPPORT */
    ADDCICHAR(CI_CALLBACK, go->neg_cbcp, CBCP_OPT);
 8017e88:	697b      	ldr	r3, [r7, #20]
 8017e8a:	781b      	ldrb	r3, [r3, #0]
 8017e8c:	227f      	movs	r2, #127	; 0x7f
 8017e8e:	4393      	bics	r3, r2
 8017e90:	b2db      	uxtb	r3, r3
 8017e92:	2b00      	cmp	r3, #0
 8017e94:	d00e      	beq.n	8017eb4 <lcp_addci+0xfc>
 8017e96:	68bb      	ldr	r3, [r7, #8]
 8017e98:	1c5a      	adds	r2, r3, #1
 8017e9a:	60ba      	str	r2, [r7, #8]
 8017e9c:	220d      	movs	r2, #13
 8017e9e:	701a      	strb	r2, [r3, #0]
 8017ea0:	68bb      	ldr	r3, [r7, #8]
 8017ea2:	1c5a      	adds	r2, r3, #1
 8017ea4:	60ba      	str	r2, [r7, #8]
 8017ea6:	2203      	movs	r2, #3
 8017ea8:	701a      	strb	r2, [r3, #0]
 8017eaa:	68bb      	ldr	r3, [r7, #8]
 8017eac:	1c5a      	adds	r2, r3, #1
 8017eae:	60ba      	str	r2, [r7, #8]
 8017eb0:	2206      	movs	r2, #6
 8017eb2:	701a      	strb	r2, [r3, #0]
    ADDCILONG(CI_MAGICNUMBER, go->neg_magicnumber, go->magicnumber);
 8017eb4:	697b      	ldr	r3, [r7, #20]
 8017eb6:	781b      	ldrb	r3, [r3, #0]
 8017eb8:	2210      	movs	r2, #16
 8017eba:	4013      	ands	r3, r2
 8017ebc:	b2db      	uxtb	r3, r3
 8017ebe:	2b00      	cmp	r3, #0
 8017ec0:	d028      	beq.n	8017f14 <lcp_addci+0x15c>
 8017ec2:	68bb      	ldr	r3, [r7, #8]
 8017ec4:	1c5a      	adds	r2, r3, #1
 8017ec6:	60ba      	str	r2, [r7, #8]
 8017ec8:	2205      	movs	r2, #5
 8017eca:	701a      	strb	r2, [r3, #0]
 8017ecc:	68bb      	ldr	r3, [r7, #8]
 8017ece:	1c5a      	adds	r2, r3, #1
 8017ed0:	60ba      	str	r2, [r7, #8]
 8017ed2:	2206      	movs	r2, #6
 8017ed4:	701a      	strb	r2, [r3, #0]
 8017ed6:	697b      	ldr	r3, [r7, #20]
 8017ed8:	689b      	ldr	r3, [r3, #8]
 8017eda:	0e19      	lsrs	r1, r3, #24
 8017edc:	68bb      	ldr	r3, [r7, #8]
 8017ede:	1c5a      	adds	r2, r3, #1
 8017ee0:	60ba      	str	r2, [r7, #8]
 8017ee2:	b2ca      	uxtb	r2, r1
 8017ee4:	701a      	strb	r2, [r3, #0]
 8017ee6:	697b      	ldr	r3, [r7, #20]
 8017ee8:	689b      	ldr	r3, [r3, #8]
 8017eea:	0c19      	lsrs	r1, r3, #16
 8017eec:	68bb      	ldr	r3, [r7, #8]
 8017eee:	1c5a      	adds	r2, r3, #1
 8017ef0:	60ba      	str	r2, [r7, #8]
 8017ef2:	b2ca      	uxtb	r2, r1
 8017ef4:	701a      	strb	r2, [r3, #0]
 8017ef6:	697b      	ldr	r3, [r7, #20]
 8017ef8:	689b      	ldr	r3, [r3, #8]
 8017efa:	0a19      	lsrs	r1, r3, #8
 8017efc:	68bb      	ldr	r3, [r7, #8]
 8017efe:	1c5a      	adds	r2, r3, #1
 8017f00:	60ba      	str	r2, [r7, #8]
 8017f02:	b2ca      	uxtb	r2, r1
 8017f04:	701a      	strb	r2, [r3, #0]
 8017f06:	697b      	ldr	r3, [r7, #20]
 8017f08:	6899      	ldr	r1, [r3, #8]
 8017f0a:	68bb      	ldr	r3, [r7, #8]
 8017f0c:	1c5a      	adds	r2, r3, #1
 8017f0e:	60ba      	str	r2, [r7, #8]
 8017f10:	b2ca      	uxtb	r2, r1
 8017f12:	701a      	strb	r2, [r3, #0]
    ADDCIVOID(CI_PCOMPRESSION, go->neg_pcompression);
 8017f14:	697b      	ldr	r3, [r7, #20]
 8017f16:	781b      	ldrb	r3, [r3, #0]
 8017f18:	2220      	movs	r2, #32
 8017f1a:	4013      	ands	r3, r2
 8017f1c:	b2db      	uxtb	r3, r3
 8017f1e:	2b00      	cmp	r3, #0
 8017f20:	d009      	beq.n	8017f36 <lcp_addci+0x17e>
 8017f22:	68bb      	ldr	r3, [r7, #8]
 8017f24:	1c5a      	adds	r2, r3, #1
 8017f26:	60ba      	str	r2, [r7, #8]
 8017f28:	2207      	movs	r2, #7
 8017f2a:	701a      	strb	r2, [r3, #0]
 8017f2c:	68bb      	ldr	r3, [r7, #8]
 8017f2e:	1c5a      	adds	r2, r3, #1
 8017f30:	60ba      	str	r2, [r7, #8]
 8017f32:	2202      	movs	r2, #2
 8017f34:	701a      	strb	r2, [r3, #0]
    ADDCIVOID(CI_ACCOMPRESSION, go->neg_accompression);
 8017f36:	697b      	ldr	r3, [r7, #20]
 8017f38:	781b      	ldrb	r3, [r3, #0]
 8017f3a:	2240      	movs	r2, #64	; 0x40
 8017f3c:	4013      	ands	r3, r2
 8017f3e:	b2db      	uxtb	r3, r3
 8017f40:	2b00      	cmp	r3, #0
 8017f42:	d009      	beq.n	8017f58 <lcp_addci+0x1a0>
 8017f44:	68bb      	ldr	r3, [r7, #8]
 8017f46:	1c5a      	adds	r2, r3, #1
 8017f48:	60ba      	str	r2, [r7, #8]
 8017f4a:	2208      	movs	r2, #8
 8017f4c:	701a      	strb	r2, [r3, #0]
 8017f4e:	68bb      	ldr	r3, [r7, #8]
 8017f50:	1c5a      	adds	r2, r3, #1
 8017f52:	60ba      	str	r2, [r7, #8]
 8017f54:	2202      	movs	r2, #2
 8017f56:	701a      	strb	r2, [r3, #0]
#ifdef HAVE_MULTILINK
    ADDCISHORT(CI_MRRU, go->neg_mrru, go->mrru);
#endif
    ADDCIVOID(CI_SSNHF, go->neg_ssnhf);
 8017f58:	697b      	ldr	r3, [r7, #20]
 8017f5a:	785b      	ldrb	r3, [r3, #1]
 8017f5c:	2201      	movs	r2, #1
 8017f5e:	4013      	ands	r3, r2
 8017f60:	b2db      	uxtb	r3, r3
 8017f62:	2b00      	cmp	r3, #0
 8017f64:	d009      	beq.n	8017f7a <lcp_addci+0x1c2>
 8017f66:	68bb      	ldr	r3, [r7, #8]
 8017f68:	1c5a      	adds	r2, r3, #1
 8017f6a:	60ba      	str	r2, [r7, #8]
 8017f6c:	2212      	movs	r2, #18
 8017f6e:	701a      	strb	r2, [r3, #0]
 8017f70:	68bb      	ldr	r3, [r7, #8]
 8017f72:	1c5a      	adds	r2, r3, #1
 8017f74:	60ba      	str	r2, [r7, #8]
 8017f76:	2202      	movs	r2, #2
 8017f78:	701a      	strb	r2, [r3, #0]
    ADDCIENDP(CI_EPDISC, go->neg_endpoint, go->endpoint.class_,
 8017f7a:	697b      	ldr	r3, [r7, #20]
 8017f7c:	785b      	ldrb	r3, [r3, #1]
 8017f7e:	2202      	movs	r2, #2
 8017f80:	4013      	ands	r3, r2
 8017f82:	b2db      	uxtb	r3, r3
 8017f84:	2b00      	cmp	r3, #0
 8017f86:	d027      	beq.n	8017fd8 <lcp_addci+0x220>
 8017f88:	68bb      	ldr	r3, [r7, #8]
 8017f8a:	1c5a      	adds	r2, r3, #1
 8017f8c:	60ba      	str	r2, [r7, #8]
 8017f8e:	2213      	movs	r2, #19
 8017f90:	701a      	strb	r2, [r3, #0]
 8017f92:	697b      	ldr	r3, [r7, #20]
 8017f94:	7b9a      	ldrb	r2, [r3, #14]
 8017f96:	68bb      	ldr	r3, [r7, #8]
 8017f98:	1c59      	adds	r1, r3, #1
 8017f9a:	60b9      	str	r1, [r7, #8]
 8017f9c:	3203      	adds	r2, #3
 8017f9e:	b2d2      	uxtb	r2, r2
 8017fa0:	701a      	strb	r2, [r3, #0]
 8017fa2:	68bb      	ldr	r3, [r7, #8]
 8017fa4:	1c5a      	adds	r2, r3, #1
 8017fa6:	60ba      	str	r2, [r7, #8]
 8017fa8:	697a      	ldr	r2, [r7, #20]
 8017faa:	7b52      	ldrb	r2, [r2, #13]
 8017fac:	701a      	strb	r2, [r3, #0]
 8017fae:	2300      	movs	r3, #0
 8017fb0:	61fb      	str	r3, [r7, #28]
 8017fb2:	e00b      	b.n	8017fcc <lcp_addci+0x214>
 8017fb4:	68bb      	ldr	r3, [r7, #8]
 8017fb6:	1c5a      	adds	r2, r3, #1
 8017fb8:	60ba      	str	r2, [r7, #8]
 8017fba:	6979      	ldr	r1, [r7, #20]
 8017fbc:	69fa      	ldr	r2, [r7, #28]
 8017fbe:	188a      	adds	r2, r1, r2
 8017fc0:	320f      	adds	r2, #15
 8017fc2:	7812      	ldrb	r2, [r2, #0]
 8017fc4:	701a      	strb	r2, [r3, #0]
 8017fc6:	69fb      	ldr	r3, [r7, #28]
 8017fc8:	3301      	adds	r3, #1
 8017fca:	61fb      	str	r3, [r7, #28]
 8017fcc:	697b      	ldr	r3, [r7, #20]
 8017fce:	7b9b      	ldrb	r3, [r3, #14]
 8017fd0:	001a      	movs	r2, r3
 8017fd2:	69fb      	ldr	r3, [r7, #28]
 8017fd4:	4293      	cmp	r3, r2
 8017fd6:	dbed      	blt.n	8017fb4 <lcp_addci+0x1fc>
	      go->endpoint.value, go->endpoint.length);

    if (ucp - start_ucp != *lenp) {
 8017fd8:	68ba      	ldr	r2, [r7, #8]
 8017fda:	693b      	ldr	r3, [r7, #16]
 8017fdc:	1ad2      	subs	r2, r2, r3
 8017fde:	687b      	ldr	r3, [r7, #4]
 8017fe0:	681b      	ldr	r3, [r3, #0]
 8017fe2:	429a      	cmp	r2, r3
 8017fe4:	d003      	beq.n	8017fee <lcp_addci+0x236>
	/* this should never happen, because peer_mtu should be 1500 */
	ppp_error("Bug in lcp_addci: wrong length");
 8017fe6:	4b05      	ldr	r3, [pc, #20]	; (8017ffc <lcp_addci+0x244>)
 8017fe8:	0018      	movs	r0, r3
 8017fea:	f003 fa9a 	bl	801b522 <ppp_error>
    }
}
 8017fee:	46c0      	nop			; (mov r8, r8)
 8017ff0:	46bd      	mov	sp, r7
 8017ff2:	b008      	add	sp, #32
 8017ff4:	bd80      	pop	{r7, pc}
 8017ff6:	46c0      	nop			; (mov r8, r8)
 8017ff8:	000005dc 	.word	0x000005dc
 8017ffc:	0802198c 	.word	0x0802198c

08018000 <lcp_ackci>:
 *
 * Returns:
 *	0 - Ack was bad.
 *	1 - Ack was good.
 */
static int lcp_ackci(fsm *f, u_char *p, int len) {
 8018000:	b580      	push	{r7, lr}
 8018002:	b08a      	sub	sp, #40	; 0x28
 8018004:	af00      	add	r7, sp, #0
 8018006:	60f8      	str	r0, [r7, #12]
 8018008:	60b9      	str	r1, [r7, #8]
 801800a:	607a      	str	r2, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 801800c:	68fb      	ldr	r3, [r7, #12]
 801800e:	681b      	ldr	r3, [r3, #0]
 8018010:	623b      	str	r3, [r7, #32]
    lcp_options *go = &pcb->lcp_gotoptions;
 8018012:	6a3b      	ldr	r3, [r7, #32]
 8018014:	3368      	adds	r3, #104	; 0x68
 8018016:	61fb      	str	r3, [r7, #28]
	    if (cichar != val[i]) \
		goto bad; \
	} \
    }

    ACKCISHORT(CI_MRU, go->neg_mru && go->mru != PPP_DEFMRU, go->mru);
 8018018:	69fb      	ldr	r3, [r7, #28]
 801801a:	781b      	ldrb	r3, [r3, #0]
 801801c:	2204      	movs	r2, #4
 801801e:	4013      	ands	r3, r2
 8018020:	b2db      	uxtb	r3, r3
 8018022:	2b00      	cmp	r3, #0
 8018024:	d03d      	beq.n	80180a2 <lcp_ackci+0xa2>
 8018026:	69fb      	ldr	r3, [r7, #28]
 8018028:	885b      	ldrh	r3, [r3, #2]
 801802a:	4adf      	ldr	r2, [pc, #892]	; (80183a8 <lcp_ackci+0x3a8>)
 801802c:	4293      	cmp	r3, r2
 801802e:	d038      	beq.n	80180a2 <lcp_ackci+0xa2>
 8018030:	687b      	ldr	r3, [r7, #4]
 8018032:	3b04      	subs	r3, #4
 8018034:	607b      	str	r3, [r7, #4]
 8018036:	687b      	ldr	r3, [r7, #4]
 8018038:	2b00      	cmp	r3, #0
 801803a:	da00      	bge.n	801803e <lcp_ackci+0x3e>
 801803c:	e1d4      	b.n	80183e8 <lcp_ackci+0x3e8>
 801803e:	68bb      	ldr	r3, [r7, #8]
 8018040:	1c5a      	adds	r2, r3, #1
 8018042:	60ba      	str	r2, [r7, #8]
 8018044:	211b      	movs	r1, #27
 8018046:	187a      	adds	r2, r7, r1
 8018048:	781b      	ldrb	r3, [r3, #0]
 801804a:	7013      	strb	r3, [r2, #0]
 801804c:	68bb      	ldr	r3, [r7, #8]
 801804e:	1c5a      	adds	r2, r3, #1
 8018050:	60ba      	str	r2, [r7, #8]
 8018052:	201a      	movs	r0, #26
 8018054:	183a      	adds	r2, r7, r0
 8018056:	781b      	ldrb	r3, [r3, #0]
 8018058:	7013      	strb	r3, [r2, #0]
 801805a:	183b      	adds	r3, r7, r0
 801805c:	781b      	ldrb	r3, [r3, #0]
 801805e:	2b04      	cmp	r3, #4
 8018060:	d000      	beq.n	8018064 <lcp_ackci+0x64>
 8018062:	e1c3      	b.n	80183ec <lcp_ackci+0x3ec>
 8018064:	187b      	adds	r3, r7, r1
 8018066:	781b      	ldrb	r3, [r3, #0]
 8018068:	2b01      	cmp	r3, #1
 801806a:	d000      	beq.n	801806e <lcp_ackci+0x6e>
 801806c:	e1be      	b.n	80183ec <lcp_ackci+0x3ec>
 801806e:	68bb      	ldr	r3, [r7, #8]
 8018070:	1c5a      	adds	r2, r3, #1
 8018072:	60ba      	str	r2, [r7, #8]
 8018074:	781b      	ldrb	r3, [r3, #0]
 8018076:	b29a      	uxth	r2, r3
 8018078:	2018      	movs	r0, #24
 801807a:	183b      	adds	r3, r7, r0
 801807c:	0212      	lsls	r2, r2, #8
 801807e:	801a      	strh	r2, [r3, #0]
 8018080:	68bb      	ldr	r3, [r7, #8]
 8018082:	1c5a      	adds	r2, r3, #1
 8018084:	60ba      	str	r2, [r7, #8]
 8018086:	781b      	ldrb	r3, [r3, #0]
 8018088:	b299      	uxth	r1, r3
 801808a:	183b      	adds	r3, r7, r0
 801808c:	183a      	adds	r2, r7, r0
 801808e:	8812      	ldrh	r2, [r2, #0]
 8018090:	430a      	orrs	r2, r1
 8018092:	801a      	strh	r2, [r3, #0]
 8018094:	69fb      	ldr	r3, [r7, #28]
 8018096:	885b      	ldrh	r3, [r3, #2]
 8018098:	183a      	adds	r2, r7, r0
 801809a:	8812      	ldrh	r2, [r2, #0]
 801809c:	429a      	cmp	r2, r3
 801809e:	d000      	beq.n	80180a2 <lcp_ackci+0xa2>
 80180a0:	e1a6      	b.n	80183f0 <lcp_ackci+0x3f0>
    ACKCILONG(CI_ASYNCMAP, go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF,
 80180a2:	69fb      	ldr	r3, [r7, #28]
 80180a4:	781b      	ldrb	r3, [r3, #0]
 80180a6:	2208      	movs	r2, #8
 80180a8:	4013      	ands	r3, r2
 80180aa:	b2db      	uxtb	r3, r3
 80180ac:	2b00      	cmp	r3, #0
 80180ae:	d04c      	beq.n	801814a <lcp_ackci+0x14a>
 80180b0:	69fb      	ldr	r3, [r7, #28]
 80180b2:	685b      	ldr	r3, [r3, #4]
 80180b4:	3301      	adds	r3, #1
 80180b6:	d048      	beq.n	801814a <lcp_ackci+0x14a>
 80180b8:	687b      	ldr	r3, [r7, #4]
 80180ba:	3b06      	subs	r3, #6
 80180bc:	607b      	str	r3, [r7, #4]
 80180be:	687b      	ldr	r3, [r7, #4]
 80180c0:	2b00      	cmp	r3, #0
 80180c2:	da00      	bge.n	80180c6 <lcp_ackci+0xc6>
 80180c4:	e196      	b.n	80183f4 <lcp_ackci+0x3f4>
 80180c6:	68bb      	ldr	r3, [r7, #8]
 80180c8:	1c5a      	adds	r2, r3, #1
 80180ca:	60ba      	str	r2, [r7, #8]
 80180cc:	211b      	movs	r1, #27
 80180ce:	187a      	adds	r2, r7, r1
 80180d0:	781b      	ldrb	r3, [r3, #0]
 80180d2:	7013      	strb	r3, [r2, #0]
 80180d4:	68bb      	ldr	r3, [r7, #8]
 80180d6:	1c5a      	adds	r2, r3, #1
 80180d8:	60ba      	str	r2, [r7, #8]
 80180da:	201a      	movs	r0, #26
 80180dc:	183a      	adds	r2, r7, r0
 80180de:	781b      	ldrb	r3, [r3, #0]
 80180e0:	7013      	strb	r3, [r2, #0]
 80180e2:	183b      	adds	r3, r7, r0
 80180e4:	781b      	ldrb	r3, [r3, #0]
 80180e6:	2b06      	cmp	r3, #6
 80180e8:	d000      	beq.n	80180ec <lcp_ackci+0xec>
 80180ea:	e185      	b.n	80183f8 <lcp_ackci+0x3f8>
 80180ec:	187b      	adds	r3, r7, r1
 80180ee:	781b      	ldrb	r3, [r3, #0]
 80180f0:	2b02      	cmp	r3, #2
 80180f2:	d000      	beq.n	80180f6 <lcp_ackci+0xf6>
 80180f4:	e180      	b.n	80183f8 <lcp_ackci+0x3f8>
 80180f6:	68bb      	ldr	r3, [r7, #8]
 80180f8:	1c5a      	adds	r2, r3, #1
 80180fa:	60ba      	str	r2, [r7, #8]
 80180fc:	781b      	ldrb	r3, [r3, #0]
 80180fe:	021b      	lsls	r3, r3, #8
 8018100:	617b      	str	r3, [r7, #20]
 8018102:	68bb      	ldr	r3, [r7, #8]
 8018104:	1c5a      	adds	r2, r3, #1
 8018106:	60ba      	str	r2, [r7, #8]
 8018108:	781b      	ldrb	r3, [r3, #0]
 801810a:	001a      	movs	r2, r3
 801810c:	697b      	ldr	r3, [r7, #20]
 801810e:	4313      	orrs	r3, r2
 8018110:	617b      	str	r3, [r7, #20]
 8018112:	697b      	ldr	r3, [r7, #20]
 8018114:	021b      	lsls	r3, r3, #8
 8018116:	617b      	str	r3, [r7, #20]
 8018118:	68bb      	ldr	r3, [r7, #8]
 801811a:	1c5a      	adds	r2, r3, #1
 801811c:	60ba      	str	r2, [r7, #8]
 801811e:	781b      	ldrb	r3, [r3, #0]
 8018120:	001a      	movs	r2, r3
 8018122:	697b      	ldr	r3, [r7, #20]
 8018124:	4313      	orrs	r3, r2
 8018126:	617b      	str	r3, [r7, #20]
 8018128:	697b      	ldr	r3, [r7, #20]
 801812a:	021b      	lsls	r3, r3, #8
 801812c:	617b      	str	r3, [r7, #20]
 801812e:	68bb      	ldr	r3, [r7, #8]
 8018130:	1c5a      	adds	r2, r3, #1
 8018132:	60ba      	str	r2, [r7, #8]
 8018134:	781b      	ldrb	r3, [r3, #0]
 8018136:	001a      	movs	r2, r3
 8018138:	697b      	ldr	r3, [r7, #20]
 801813a:	4313      	orrs	r3, r2
 801813c:	617b      	str	r3, [r7, #20]
 801813e:	69fb      	ldr	r3, [r7, #28]
 8018140:	685b      	ldr	r3, [r3, #4]
 8018142:	697a      	ldr	r2, [r7, #20]
 8018144:	429a      	cmp	r2, r3
 8018146:	d000      	beq.n	801814a <lcp_ackci+0x14a>
 8018148:	e158      	b.n	80183fc <lcp_ackci+0x3fc>
#endif /* !EAP_SUPPORT && !CHAP_SUPPORT */
#endif /* PAP_SUPPORT */
#if LQR_SUPPORT
    ACKCILQR(CI_QUALITY, go->neg_lqr, go->lqr_period);
#endif /* LQR_SUPPORT */
    ACKCICHAR(CI_CALLBACK, go->neg_cbcp, CBCP_OPT);
 801814a:	69fb      	ldr	r3, [r7, #28]
 801814c:	781b      	ldrb	r3, [r3, #0]
 801814e:	227f      	movs	r2, #127	; 0x7f
 8018150:	4393      	bics	r3, r2
 8018152:	b2db      	uxtb	r3, r3
 8018154:	2b00      	cmp	r3, #0
 8018156:	d02a      	beq.n	80181ae <lcp_ackci+0x1ae>
 8018158:	687b      	ldr	r3, [r7, #4]
 801815a:	3b03      	subs	r3, #3
 801815c:	607b      	str	r3, [r7, #4]
 801815e:	687b      	ldr	r3, [r7, #4]
 8018160:	2b00      	cmp	r3, #0
 8018162:	da00      	bge.n	8018166 <lcp_ackci+0x166>
 8018164:	e14c      	b.n	8018400 <lcp_ackci+0x400>
 8018166:	68bb      	ldr	r3, [r7, #8]
 8018168:	1c5a      	adds	r2, r3, #1
 801816a:	60ba      	str	r2, [r7, #8]
 801816c:	211b      	movs	r1, #27
 801816e:	187a      	adds	r2, r7, r1
 8018170:	781b      	ldrb	r3, [r3, #0]
 8018172:	7013      	strb	r3, [r2, #0]
 8018174:	68bb      	ldr	r3, [r7, #8]
 8018176:	1c5a      	adds	r2, r3, #1
 8018178:	60ba      	str	r2, [r7, #8]
 801817a:	201a      	movs	r0, #26
 801817c:	183a      	adds	r2, r7, r0
 801817e:	781b      	ldrb	r3, [r3, #0]
 8018180:	7013      	strb	r3, [r2, #0]
 8018182:	183b      	adds	r3, r7, r0
 8018184:	781b      	ldrb	r3, [r3, #0]
 8018186:	2b03      	cmp	r3, #3
 8018188:	d000      	beq.n	801818c <lcp_ackci+0x18c>
 801818a:	e13b      	b.n	8018404 <lcp_ackci+0x404>
 801818c:	187b      	adds	r3, r7, r1
 801818e:	781b      	ldrb	r3, [r3, #0]
 8018190:	2b0d      	cmp	r3, #13
 8018192:	d000      	beq.n	8018196 <lcp_ackci+0x196>
 8018194:	e136      	b.n	8018404 <lcp_ackci+0x404>
 8018196:	68bb      	ldr	r3, [r7, #8]
 8018198:	1c5a      	adds	r2, r3, #1
 801819a:	60ba      	str	r2, [r7, #8]
 801819c:	2113      	movs	r1, #19
 801819e:	187a      	adds	r2, r7, r1
 80181a0:	781b      	ldrb	r3, [r3, #0]
 80181a2:	7013      	strb	r3, [r2, #0]
 80181a4:	187b      	adds	r3, r7, r1
 80181a6:	781b      	ldrb	r3, [r3, #0]
 80181a8:	2b06      	cmp	r3, #6
 80181aa:	d000      	beq.n	80181ae <lcp_ackci+0x1ae>
 80181ac:	e12c      	b.n	8018408 <lcp_ackci+0x408>
    ACKCILONG(CI_MAGICNUMBER, go->neg_magicnumber, go->magicnumber);
 80181ae:	69fb      	ldr	r3, [r7, #28]
 80181b0:	781b      	ldrb	r3, [r3, #0]
 80181b2:	2210      	movs	r2, #16
 80181b4:	4013      	ands	r3, r2
 80181b6:	b2db      	uxtb	r3, r3
 80181b8:	2b00      	cmp	r3, #0
 80181ba:	d048      	beq.n	801824e <lcp_ackci+0x24e>
 80181bc:	687b      	ldr	r3, [r7, #4]
 80181be:	3b06      	subs	r3, #6
 80181c0:	607b      	str	r3, [r7, #4]
 80181c2:	687b      	ldr	r3, [r7, #4]
 80181c4:	2b00      	cmp	r3, #0
 80181c6:	da00      	bge.n	80181ca <lcp_ackci+0x1ca>
 80181c8:	e120      	b.n	801840c <lcp_ackci+0x40c>
 80181ca:	68bb      	ldr	r3, [r7, #8]
 80181cc:	1c5a      	adds	r2, r3, #1
 80181ce:	60ba      	str	r2, [r7, #8]
 80181d0:	211b      	movs	r1, #27
 80181d2:	187a      	adds	r2, r7, r1
 80181d4:	781b      	ldrb	r3, [r3, #0]
 80181d6:	7013      	strb	r3, [r2, #0]
 80181d8:	68bb      	ldr	r3, [r7, #8]
 80181da:	1c5a      	adds	r2, r3, #1
 80181dc:	60ba      	str	r2, [r7, #8]
 80181de:	201a      	movs	r0, #26
 80181e0:	183a      	adds	r2, r7, r0
 80181e2:	781b      	ldrb	r3, [r3, #0]
 80181e4:	7013      	strb	r3, [r2, #0]
 80181e6:	183b      	adds	r3, r7, r0
 80181e8:	781b      	ldrb	r3, [r3, #0]
 80181ea:	2b06      	cmp	r3, #6
 80181ec:	d000      	beq.n	80181f0 <lcp_ackci+0x1f0>
 80181ee:	e10f      	b.n	8018410 <lcp_ackci+0x410>
 80181f0:	187b      	adds	r3, r7, r1
 80181f2:	781b      	ldrb	r3, [r3, #0]
 80181f4:	2b05      	cmp	r3, #5
 80181f6:	d000      	beq.n	80181fa <lcp_ackci+0x1fa>
 80181f8:	e10a      	b.n	8018410 <lcp_ackci+0x410>
 80181fa:	68bb      	ldr	r3, [r7, #8]
 80181fc:	1c5a      	adds	r2, r3, #1
 80181fe:	60ba      	str	r2, [r7, #8]
 8018200:	781b      	ldrb	r3, [r3, #0]
 8018202:	021b      	lsls	r3, r3, #8
 8018204:	617b      	str	r3, [r7, #20]
 8018206:	68bb      	ldr	r3, [r7, #8]
 8018208:	1c5a      	adds	r2, r3, #1
 801820a:	60ba      	str	r2, [r7, #8]
 801820c:	781b      	ldrb	r3, [r3, #0]
 801820e:	001a      	movs	r2, r3
 8018210:	697b      	ldr	r3, [r7, #20]
 8018212:	4313      	orrs	r3, r2
 8018214:	617b      	str	r3, [r7, #20]
 8018216:	697b      	ldr	r3, [r7, #20]
 8018218:	021b      	lsls	r3, r3, #8
 801821a:	617b      	str	r3, [r7, #20]
 801821c:	68bb      	ldr	r3, [r7, #8]
 801821e:	1c5a      	adds	r2, r3, #1
 8018220:	60ba      	str	r2, [r7, #8]
 8018222:	781b      	ldrb	r3, [r3, #0]
 8018224:	001a      	movs	r2, r3
 8018226:	697b      	ldr	r3, [r7, #20]
 8018228:	4313      	orrs	r3, r2
 801822a:	617b      	str	r3, [r7, #20]
 801822c:	697b      	ldr	r3, [r7, #20]
 801822e:	021b      	lsls	r3, r3, #8
 8018230:	617b      	str	r3, [r7, #20]
 8018232:	68bb      	ldr	r3, [r7, #8]
 8018234:	1c5a      	adds	r2, r3, #1
 8018236:	60ba      	str	r2, [r7, #8]
 8018238:	781b      	ldrb	r3, [r3, #0]
 801823a:	001a      	movs	r2, r3
 801823c:	697b      	ldr	r3, [r7, #20]
 801823e:	4313      	orrs	r3, r2
 8018240:	617b      	str	r3, [r7, #20]
 8018242:	69fb      	ldr	r3, [r7, #28]
 8018244:	689b      	ldr	r3, [r3, #8]
 8018246:	697a      	ldr	r2, [r7, #20]
 8018248:	429a      	cmp	r2, r3
 801824a:	d000      	beq.n	801824e <lcp_ackci+0x24e>
 801824c:	e0e2      	b.n	8018414 <lcp_ackci+0x414>
    ACKCIVOID(CI_PCOMPRESSION, go->neg_pcompression);
 801824e:	69fb      	ldr	r3, [r7, #28]
 8018250:	781b      	ldrb	r3, [r3, #0]
 8018252:	2220      	movs	r2, #32
 8018254:	4013      	ands	r3, r2
 8018256:	b2db      	uxtb	r3, r3
 8018258:	2b00      	cmp	r3, #0
 801825a:	d01e      	beq.n	801829a <lcp_ackci+0x29a>
 801825c:	687b      	ldr	r3, [r7, #4]
 801825e:	3b02      	subs	r3, #2
 8018260:	607b      	str	r3, [r7, #4]
 8018262:	687b      	ldr	r3, [r7, #4]
 8018264:	2b00      	cmp	r3, #0
 8018266:	da00      	bge.n	801826a <lcp_ackci+0x26a>
 8018268:	e0d6      	b.n	8018418 <lcp_ackci+0x418>
 801826a:	68bb      	ldr	r3, [r7, #8]
 801826c:	1c5a      	adds	r2, r3, #1
 801826e:	60ba      	str	r2, [r7, #8]
 8018270:	211b      	movs	r1, #27
 8018272:	187a      	adds	r2, r7, r1
 8018274:	781b      	ldrb	r3, [r3, #0]
 8018276:	7013      	strb	r3, [r2, #0]
 8018278:	68bb      	ldr	r3, [r7, #8]
 801827a:	1c5a      	adds	r2, r3, #1
 801827c:	60ba      	str	r2, [r7, #8]
 801827e:	201a      	movs	r0, #26
 8018280:	183a      	adds	r2, r7, r0
 8018282:	781b      	ldrb	r3, [r3, #0]
 8018284:	7013      	strb	r3, [r2, #0]
 8018286:	183b      	adds	r3, r7, r0
 8018288:	781b      	ldrb	r3, [r3, #0]
 801828a:	2b02      	cmp	r3, #2
 801828c:	d000      	beq.n	8018290 <lcp_ackci+0x290>
 801828e:	e0c5      	b.n	801841c <lcp_ackci+0x41c>
 8018290:	187b      	adds	r3, r7, r1
 8018292:	781b      	ldrb	r3, [r3, #0]
 8018294:	2b07      	cmp	r3, #7
 8018296:	d000      	beq.n	801829a <lcp_ackci+0x29a>
 8018298:	e0c0      	b.n	801841c <lcp_ackci+0x41c>
    ACKCIVOID(CI_ACCOMPRESSION, go->neg_accompression);
 801829a:	69fb      	ldr	r3, [r7, #28]
 801829c:	781b      	ldrb	r3, [r3, #0]
 801829e:	2240      	movs	r2, #64	; 0x40
 80182a0:	4013      	ands	r3, r2
 80182a2:	b2db      	uxtb	r3, r3
 80182a4:	2b00      	cmp	r3, #0
 80182a6:	d01e      	beq.n	80182e6 <lcp_ackci+0x2e6>
 80182a8:	687b      	ldr	r3, [r7, #4]
 80182aa:	3b02      	subs	r3, #2
 80182ac:	607b      	str	r3, [r7, #4]
 80182ae:	687b      	ldr	r3, [r7, #4]
 80182b0:	2b00      	cmp	r3, #0
 80182b2:	da00      	bge.n	80182b6 <lcp_ackci+0x2b6>
 80182b4:	e0b4      	b.n	8018420 <lcp_ackci+0x420>
 80182b6:	68bb      	ldr	r3, [r7, #8]
 80182b8:	1c5a      	adds	r2, r3, #1
 80182ba:	60ba      	str	r2, [r7, #8]
 80182bc:	211b      	movs	r1, #27
 80182be:	187a      	adds	r2, r7, r1
 80182c0:	781b      	ldrb	r3, [r3, #0]
 80182c2:	7013      	strb	r3, [r2, #0]
 80182c4:	68bb      	ldr	r3, [r7, #8]
 80182c6:	1c5a      	adds	r2, r3, #1
 80182c8:	60ba      	str	r2, [r7, #8]
 80182ca:	201a      	movs	r0, #26
 80182cc:	183a      	adds	r2, r7, r0
 80182ce:	781b      	ldrb	r3, [r3, #0]
 80182d0:	7013      	strb	r3, [r2, #0]
 80182d2:	183b      	adds	r3, r7, r0
 80182d4:	781b      	ldrb	r3, [r3, #0]
 80182d6:	2b02      	cmp	r3, #2
 80182d8:	d000      	beq.n	80182dc <lcp_ackci+0x2dc>
 80182da:	e0a3      	b.n	8018424 <lcp_ackci+0x424>
 80182dc:	187b      	adds	r3, r7, r1
 80182de:	781b      	ldrb	r3, [r3, #0]
 80182e0:	2b08      	cmp	r3, #8
 80182e2:	d000      	beq.n	80182e6 <lcp_ackci+0x2e6>
 80182e4:	e09e      	b.n	8018424 <lcp_ackci+0x424>
#ifdef HAVE_MULTILINK
    ACKCISHORT(CI_MRRU, go->neg_mrru, go->mrru);
#endif /* HAVE_MULTILINK */
    ACKCIVOID(CI_SSNHF, go->neg_ssnhf);
 80182e6:	69fb      	ldr	r3, [r7, #28]
 80182e8:	785b      	ldrb	r3, [r3, #1]
 80182ea:	2201      	movs	r2, #1
 80182ec:	4013      	ands	r3, r2
 80182ee:	b2db      	uxtb	r3, r3
 80182f0:	2b00      	cmp	r3, #0
 80182f2:	d01e      	beq.n	8018332 <lcp_ackci+0x332>
 80182f4:	687b      	ldr	r3, [r7, #4]
 80182f6:	3b02      	subs	r3, #2
 80182f8:	607b      	str	r3, [r7, #4]
 80182fa:	687b      	ldr	r3, [r7, #4]
 80182fc:	2b00      	cmp	r3, #0
 80182fe:	da00      	bge.n	8018302 <lcp_ackci+0x302>
 8018300:	e092      	b.n	8018428 <lcp_ackci+0x428>
 8018302:	68bb      	ldr	r3, [r7, #8]
 8018304:	1c5a      	adds	r2, r3, #1
 8018306:	60ba      	str	r2, [r7, #8]
 8018308:	211b      	movs	r1, #27
 801830a:	187a      	adds	r2, r7, r1
 801830c:	781b      	ldrb	r3, [r3, #0]
 801830e:	7013      	strb	r3, [r2, #0]
 8018310:	68bb      	ldr	r3, [r7, #8]
 8018312:	1c5a      	adds	r2, r3, #1
 8018314:	60ba      	str	r2, [r7, #8]
 8018316:	201a      	movs	r0, #26
 8018318:	183a      	adds	r2, r7, r0
 801831a:	781b      	ldrb	r3, [r3, #0]
 801831c:	7013      	strb	r3, [r2, #0]
 801831e:	183b      	adds	r3, r7, r0
 8018320:	781b      	ldrb	r3, [r3, #0]
 8018322:	2b02      	cmp	r3, #2
 8018324:	d000      	beq.n	8018328 <lcp_ackci+0x328>
 8018326:	e081      	b.n	801842c <lcp_ackci+0x42c>
 8018328:	187b      	adds	r3, r7, r1
 801832a:	781b      	ldrb	r3, [r3, #0]
 801832c:	2b12      	cmp	r3, #18
 801832e:	d000      	beq.n	8018332 <lcp_ackci+0x332>
 8018330:	e07c      	b.n	801842c <lcp_ackci+0x42c>
    ACKCIENDP(CI_EPDISC, go->neg_endpoint, go->endpoint.class_,
 8018332:	69fb      	ldr	r3, [r7, #28]
 8018334:	785b      	ldrb	r3, [r3, #1]
 8018336:	2202      	movs	r2, #2
 8018338:	4013      	ands	r3, r2
 801833a:	b2db      	uxtb	r3, r3
 801833c:	2b00      	cmp	r3, #0
 801833e:	d04e      	beq.n	80183de <lcp_ackci+0x3de>
 8018340:	69fb      	ldr	r3, [r7, #28]
 8018342:	7b9b      	ldrb	r3, [r3, #14]
 8018344:	3303      	adds	r3, #3
 8018346:	687a      	ldr	r2, [r7, #4]
 8018348:	1ad3      	subs	r3, r2, r3
 801834a:	607b      	str	r3, [r7, #4]
 801834c:	687b      	ldr	r3, [r7, #4]
 801834e:	2b00      	cmp	r3, #0
 8018350:	da00      	bge.n	8018354 <lcp_ackci+0x354>
 8018352:	e06d      	b.n	8018430 <lcp_ackci+0x430>
 8018354:	68bb      	ldr	r3, [r7, #8]
 8018356:	1c5a      	adds	r2, r3, #1
 8018358:	60ba      	str	r2, [r7, #8]
 801835a:	211b      	movs	r1, #27
 801835c:	187a      	adds	r2, r7, r1
 801835e:	781b      	ldrb	r3, [r3, #0]
 8018360:	7013      	strb	r3, [r2, #0]
 8018362:	68bb      	ldr	r3, [r7, #8]
 8018364:	1c5a      	adds	r2, r3, #1
 8018366:	60ba      	str	r2, [r7, #8]
 8018368:	201a      	movs	r0, #26
 801836a:	183a      	adds	r2, r7, r0
 801836c:	781b      	ldrb	r3, [r3, #0]
 801836e:	7013      	strb	r3, [r2, #0]
 8018370:	183b      	adds	r3, r7, r0
 8018372:	781a      	ldrb	r2, [r3, #0]
 8018374:	69fb      	ldr	r3, [r7, #28]
 8018376:	7b9b      	ldrb	r3, [r3, #14]
 8018378:	3303      	adds	r3, #3
 801837a:	429a      	cmp	r2, r3
 801837c:	d15a      	bne.n	8018434 <lcp_ackci+0x434>
 801837e:	187b      	adds	r3, r7, r1
 8018380:	781b      	ldrb	r3, [r3, #0]
 8018382:	2b13      	cmp	r3, #19
 8018384:	d156      	bne.n	8018434 <lcp_ackci+0x434>
 8018386:	68bb      	ldr	r3, [r7, #8]
 8018388:	1c5a      	adds	r2, r3, #1
 801838a:	60ba      	str	r2, [r7, #8]
 801838c:	2113      	movs	r1, #19
 801838e:	187a      	adds	r2, r7, r1
 8018390:	781b      	ldrb	r3, [r3, #0]
 8018392:	7013      	strb	r3, [r2, #0]
 8018394:	69fb      	ldr	r3, [r7, #28]
 8018396:	7b5b      	ldrb	r3, [r3, #13]
 8018398:	187a      	adds	r2, r7, r1
 801839a:	7812      	ldrb	r2, [r2, #0]
 801839c:	429a      	cmp	r2, r3
 801839e:	d14b      	bne.n	8018438 <lcp_ackci+0x438>
 80183a0:	2300      	movs	r3, #0
 80183a2:	627b      	str	r3, [r7, #36]	; 0x24
 80183a4:	e015      	b.n	80183d2 <lcp_ackci+0x3d2>
 80183a6:	46c0      	nop			; (mov r8, r8)
 80183a8:	000005dc 	.word	0x000005dc
 80183ac:	68bb      	ldr	r3, [r7, #8]
 80183ae:	1c5a      	adds	r2, r3, #1
 80183b0:	60ba      	str	r2, [r7, #8]
 80183b2:	2113      	movs	r1, #19
 80183b4:	187a      	adds	r2, r7, r1
 80183b6:	781b      	ldrb	r3, [r3, #0]
 80183b8:	7013      	strb	r3, [r2, #0]
 80183ba:	69fa      	ldr	r2, [r7, #28]
 80183bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80183be:	18d3      	adds	r3, r2, r3
 80183c0:	330f      	adds	r3, #15
 80183c2:	781b      	ldrb	r3, [r3, #0]
 80183c4:	187a      	adds	r2, r7, r1
 80183c6:	7812      	ldrb	r2, [r2, #0]
 80183c8:	429a      	cmp	r2, r3
 80183ca:	d137      	bne.n	801843c <lcp_ackci+0x43c>
 80183cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80183ce:	3301      	adds	r3, #1
 80183d0:	627b      	str	r3, [r7, #36]	; 0x24
 80183d2:	69fb      	ldr	r3, [r7, #28]
 80183d4:	7b9b      	ldrb	r3, [r3, #14]
 80183d6:	001a      	movs	r2, r3
 80183d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80183da:	4293      	cmp	r3, r2
 80183dc:	dbe6      	blt.n	80183ac <lcp_ackci+0x3ac>
	      go->endpoint.value, go->endpoint.length);

    /*
     * If there are any remaining CIs, then this packet is bad.
     */
    if (len != 0)
 80183de:	687b      	ldr	r3, [r7, #4]
 80183e0:	2b00      	cmp	r3, #0
 80183e2:	d12d      	bne.n	8018440 <lcp_ackci+0x440>
	goto bad;
    return (1);
 80183e4:	2301      	movs	r3, #1
 80183e6:	e02d      	b.n	8018444 <lcp_ackci+0x444>
    ACKCISHORT(CI_MRU, go->neg_mru && go->mru != PPP_DEFMRU, go->mru);
 80183e8:	46c0      	nop			; (mov r8, r8)
 80183ea:	e02a      	b.n	8018442 <lcp_ackci+0x442>
 80183ec:	46c0      	nop			; (mov r8, r8)
 80183ee:	e028      	b.n	8018442 <lcp_ackci+0x442>
 80183f0:	46c0      	nop			; (mov r8, r8)
 80183f2:	e026      	b.n	8018442 <lcp_ackci+0x442>
    ACKCILONG(CI_ASYNCMAP, go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF,
 80183f4:	46c0      	nop			; (mov r8, r8)
 80183f6:	e024      	b.n	8018442 <lcp_ackci+0x442>
 80183f8:	46c0      	nop			; (mov r8, r8)
 80183fa:	e022      	b.n	8018442 <lcp_ackci+0x442>
 80183fc:	46c0      	nop			; (mov r8, r8)
 80183fe:	e020      	b.n	8018442 <lcp_ackci+0x442>
    ACKCICHAR(CI_CALLBACK, go->neg_cbcp, CBCP_OPT);
 8018400:	46c0      	nop			; (mov r8, r8)
 8018402:	e01e      	b.n	8018442 <lcp_ackci+0x442>
 8018404:	46c0      	nop			; (mov r8, r8)
 8018406:	e01c      	b.n	8018442 <lcp_ackci+0x442>
 8018408:	46c0      	nop			; (mov r8, r8)
 801840a:	e01a      	b.n	8018442 <lcp_ackci+0x442>
    ACKCILONG(CI_MAGICNUMBER, go->neg_magicnumber, go->magicnumber);
 801840c:	46c0      	nop			; (mov r8, r8)
 801840e:	e018      	b.n	8018442 <lcp_ackci+0x442>
 8018410:	46c0      	nop			; (mov r8, r8)
 8018412:	e016      	b.n	8018442 <lcp_ackci+0x442>
 8018414:	46c0      	nop			; (mov r8, r8)
 8018416:	e014      	b.n	8018442 <lcp_ackci+0x442>
    ACKCIVOID(CI_PCOMPRESSION, go->neg_pcompression);
 8018418:	46c0      	nop			; (mov r8, r8)
 801841a:	e012      	b.n	8018442 <lcp_ackci+0x442>
 801841c:	46c0      	nop			; (mov r8, r8)
 801841e:	e010      	b.n	8018442 <lcp_ackci+0x442>
    ACKCIVOID(CI_ACCOMPRESSION, go->neg_accompression);
 8018420:	46c0      	nop			; (mov r8, r8)
 8018422:	e00e      	b.n	8018442 <lcp_ackci+0x442>
 8018424:	46c0      	nop			; (mov r8, r8)
 8018426:	e00c      	b.n	8018442 <lcp_ackci+0x442>
    ACKCIVOID(CI_SSNHF, go->neg_ssnhf);
 8018428:	46c0      	nop			; (mov r8, r8)
 801842a:	e00a      	b.n	8018442 <lcp_ackci+0x442>
 801842c:	46c0      	nop			; (mov r8, r8)
 801842e:	e008      	b.n	8018442 <lcp_ackci+0x442>
    ACKCIENDP(CI_EPDISC, go->neg_endpoint, go->endpoint.class_,
 8018430:	46c0      	nop			; (mov r8, r8)
 8018432:	e006      	b.n	8018442 <lcp_ackci+0x442>
 8018434:	46c0      	nop			; (mov r8, r8)
 8018436:	e004      	b.n	8018442 <lcp_ackci+0x442>
 8018438:	46c0      	nop			; (mov r8, r8)
 801843a:	e002      	b.n	8018442 <lcp_ackci+0x442>
 801843c:	46c0      	nop			; (mov r8, r8)
 801843e:	e000      	b.n	8018442 <lcp_ackci+0x442>
	goto bad;
 8018440:	46c0      	nop			; (mov r8, r8)
bad:
    LCPDEBUG(("lcp_acki: received bad Ack!"));
    return (0);
 8018442:	2300      	movs	r3, #0
}
 8018444:	0018      	movs	r0, r3
 8018446:	46bd      	mov	sp, r7
 8018448:	b00a      	add	sp, #40	; 0x28
 801844a:	bd80      	pop	{r7, pc}

0801844c <lcp_nakci>:
 *
 * Returns:
 *	0 - Nak was bad.
 *	1 - Nak was good.
 */
static int lcp_nakci(fsm *f, u_char *p, int len, int treat_as_reject) {
 801844c:	b5b0      	push	{r4, r5, r7, lr}
 801844e:	b0a0      	sub	sp, #128	; 0x80
 8018450:	af00      	add	r7, sp, #0
 8018452:	60f8      	str	r0, [r7, #12]
 8018454:	60b9      	str	r1, [r7, #8]
 8018456:	607a      	str	r2, [r7, #4]
 8018458:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 801845a:	68fb      	ldr	r3, [r7, #12]
 801845c:	681b      	ldr	r3, [r3, #0]
 801845e:	67bb      	str	r3, [r7, #120]	; 0x78
    lcp_options *go = &pcb->lcp_gotoptions;
 8018460:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8018462:	3368      	adds	r3, #104	; 0x68
 8018464:	677b      	str	r3, [r7, #116]	; 0x74
    lcp_options *wo = &pcb->lcp_wantoptions;
 8018466:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8018468:	3344      	adds	r3, #68	; 0x44
 801846a:	673b      	str	r3, [r7, #112]	; 0x70
    u_char citype, cichar, *next;
    u_short cishort;
    u32_t cilong;
    lcp_options no;		/* options we've seen Naks for */
    lcp_options try_;		/* options to request next time */
    int looped_back = 0;
 801846c:	2300      	movs	r3, #0
 801846e:	67fb      	str	r3, [r7, #124]	; 0x7c
    int cilen;

    BZERO(&no, sizeof(no));
 8018470:	2438      	movs	r4, #56	; 0x38
 8018472:	193b      	adds	r3, r7, r4
 8018474:	2224      	movs	r2, #36	; 0x24
 8018476:	2100      	movs	r1, #0
 8018478:	0018      	movs	r0, r3
 801847a:	f004 fbcd 	bl	801cc18 <memset>
    try_ = *go;
 801847e:	2314      	movs	r3, #20
 8018480:	18fb      	adds	r3, r7, r3
 8018482:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8018484:	ca23      	ldmia	r2!, {r0, r1, r5}
 8018486:	c323      	stmia	r3!, {r0, r1, r5}
 8018488:	ca23      	ldmia	r2!, {r0, r1, r5}
 801848a:	c323      	stmia	r3!, {r0, r1, r5}
 801848c:	ca23      	ldmia	r2!, {r0, r1, r5}
 801848e:	c323      	stmia	r3!, {r0, r1, r5}
     * we want.  Therefore, accept any MRU less than what we asked for,
     * but then ignore the new value when setting the MRU in the kernel.
     * If they send us a bigger MRU than what we asked, accept it, up to
     * the limit of the default MRU we'd get if we didn't negotiate.
     */
    if (go->neg_mru && go->mru != PPP_DEFMRU) {
 8018490:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018492:	781b      	ldrb	r3, [r3, #0]
 8018494:	2204      	movs	r2, #4
 8018496:	4013      	ands	r3, r2
 8018498:	b2db      	uxtb	r3, r3
 801849a:	2b00      	cmp	r3, #0
 801849c:	d04a      	beq.n	8018534 <lcp_nakci+0xe8>
 801849e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80184a0:	885b      	ldrh	r3, [r3, #2]
 80184a2:	4a20      	ldr	r2, [pc, #128]	; (8018524 <lcp_nakci+0xd8>)
 80184a4:	4293      	cmp	r3, r2
 80184a6:	d045      	beq.n	8018534 <lcp_nakci+0xe8>
	NAKCISHORT(CI_MRU, neg_mru,
 80184a8:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80184aa:	781b      	ldrb	r3, [r3, #0]
 80184ac:	2204      	movs	r2, #4
 80184ae:	4013      	ands	r3, r2
 80184b0:	b2db      	uxtb	r3, r3
 80184b2:	2b00      	cmp	r3, #0
 80184b4:	d03e      	beq.n	8018534 <lcp_nakci+0xe8>
 80184b6:	687b      	ldr	r3, [r7, #4]
 80184b8:	2b03      	cmp	r3, #3
 80184ba:	dd3b      	ble.n	8018534 <lcp_nakci+0xe8>
 80184bc:	68bb      	ldr	r3, [r7, #8]
 80184be:	3301      	adds	r3, #1
 80184c0:	781b      	ldrb	r3, [r3, #0]
 80184c2:	2b04      	cmp	r3, #4
 80184c4:	d136      	bne.n	8018534 <lcp_nakci+0xe8>
 80184c6:	68bb      	ldr	r3, [r7, #8]
 80184c8:	781b      	ldrb	r3, [r3, #0]
 80184ca:	2b01      	cmp	r3, #1
 80184cc:	d132      	bne.n	8018534 <lcp_nakci+0xe8>
 80184ce:	687b      	ldr	r3, [r7, #4]
 80184d0:	3b04      	subs	r3, #4
 80184d2:	607b      	str	r3, [r7, #4]
 80184d4:	68bb      	ldr	r3, [r7, #8]
 80184d6:	3302      	adds	r3, #2
 80184d8:	60bb      	str	r3, [r7, #8]
 80184da:	68bb      	ldr	r3, [r7, #8]
 80184dc:	1c5a      	adds	r2, r3, #1
 80184de:	60ba      	str	r2, [r7, #8]
 80184e0:	781b      	ldrb	r3, [r3, #0]
 80184e2:	b29a      	uxth	r2, r3
 80184e4:	206e      	movs	r0, #110	; 0x6e
 80184e6:	183b      	adds	r3, r7, r0
 80184e8:	0212      	lsls	r2, r2, #8
 80184ea:	801a      	strh	r2, [r3, #0]
 80184ec:	68bb      	ldr	r3, [r7, #8]
 80184ee:	1c5a      	adds	r2, r3, #1
 80184f0:	60ba      	str	r2, [r7, #8]
 80184f2:	781b      	ldrb	r3, [r3, #0]
 80184f4:	b299      	uxth	r1, r3
 80184f6:	183b      	adds	r3, r7, r0
 80184f8:	183a      	adds	r2, r7, r0
 80184fa:	8812      	ldrh	r2, [r2, #0]
 80184fc:	430a      	orrs	r2, r1
 80184fe:	801a      	strh	r2, [r3, #0]
 8018500:	193b      	adds	r3, r7, r4
 8018502:	781a      	ldrb	r2, [r3, #0]
 8018504:	2104      	movs	r1, #4
 8018506:	430a      	orrs	r2, r1
 8018508:	701a      	strb	r2, [r3, #0]
 801850a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801850c:	885b      	ldrh	r3, [r3, #2]
 801850e:	183a      	adds	r2, r7, r0
 8018510:	8812      	ldrh	r2, [r2, #0]
 8018512:	429a      	cmp	r2, r3
 8018514:	d908      	bls.n	8018528 <lcp_nakci+0xdc>
 8018516:	183b      	adds	r3, r7, r0
 8018518:	881b      	ldrh	r3, [r3, #0]
 801851a:	4a02      	ldr	r2, [pc, #8]	; (8018524 <lcp_nakci+0xd8>)
 801851c:	4293      	cmp	r3, r2
 801851e:	d809      	bhi.n	8018534 <lcp_nakci+0xe8>
 8018520:	e002      	b.n	8018528 <lcp_nakci+0xdc>
 8018522:	46c0      	nop			; (mov r8, r8)
 8018524:	000005dc 	.word	0x000005dc
 8018528:	2314      	movs	r3, #20
 801852a:	18fb      	adds	r3, r7, r3
 801852c:	226e      	movs	r2, #110	; 0x6e
 801852e:	18ba      	adds	r2, r7, r2
 8018530:	8812      	ldrh	r2, [r2, #0]
 8018532:	805a      	strh	r2, [r3, #2]
    }

    /*
     * Add any characters they want to our (receive-side) asyncmap.
     */
    if (go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF) {
 8018534:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018536:	781b      	ldrb	r3, [r3, #0]
 8018538:	2208      	movs	r2, #8
 801853a:	4013      	ands	r3, r2
 801853c:	b2db      	uxtb	r3, r3
 801853e:	2b00      	cmp	r3, #0
 8018540:	d04d      	beq.n	80185de <lcp_nakci+0x192>
 8018542:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018544:	685b      	ldr	r3, [r3, #4]
 8018546:	3301      	adds	r3, #1
 8018548:	d049      	beq.n	80185de <lcp_nakci+0x192>
	NAKCILONG(CI_ASYNCMAP, neg_asyncmap,
 801854a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801854c:	781b      	ldrb	r3, [r3, #0]
 801854e:	2208      	movs	r2, #8
 8018550:	4013      	ands	r3, r2
 8018552:	b2db      	uxtb	r3, r3
 8018554:	2b00      	cmp	r3, #0
 8018556:	d042      	beq.n	80185de <lcp_nakci+0x192>
 8018558:	687b      	ldr	r3, [r7, #4]
 801855a:	2b05      	cmp	r3, #5
 801855c:	dd3f      	ble.n	80185de <lcp_nakci+0x192>
 801855e:	68bb      	ldr	r3, [r7, #8]
 8018560:	3301      	adds	r3, #1
 8018562:	781b      	ldrb	r3, [r3, #0]
 8018564:	2b06      	cmp	r3, #6
 8018566:	d13a      	bne.n	80185de <lcp_nakci+0x192>
 8018568:	68bb      	ldr	r3, [r7, #8]
 801856a:	781b      	ldrb	r3, [r3, #0]
 801856c:	2b02      	cmp	r3, #2
 801856e:	d136      	bne.n	80185de <lcp_nakci+0x192>
 8018570:	687b      	ldr	r3, [r7, #4]
 8018572:	3b06      	subs	r3, #6
 8018574:	607b      	str	r3, [r7, #4]
 8018576:	68bb      	ldr	r3, [r7, #8]
 8018578:	3302      	adds	r3, #2
 801857a:	60bb      	str	r3, [r7, #8]
 801857c:	68bb      	ldr	r3, [r7, #8]
 801857e:	1c5a      	adds	r2, r3, #1
 8018580:	60ba      	str	r2, [r7, #8]
 8018582:	781b      	ldrb	r3, [r3, #0]
 8018584:	021b      	lsls	r3, r3, #8
 8018586:	66bb      	str	r3, [r7, #104]	; 0x68
 8018588:	68bb      	ldr	r3, [r7, #8]
 801858a:	1c5a      	adds	r2, r3, #1
 801858c:	60ba      	str	r2, [r7, #8]
 801858e:	781b      	ldrb	r3, [r3, #0]
 8018590:	001a      	movs	r2, r3
 8018592:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018594:	4313      	orrs	r3, r2
 8018596:	66bb      	str	r3, [r7, #104]	; 0x68
 8018598:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801859a:	021b      	lsls	r3, r3, #8
 801859c:	66bb      	str	r3, [r7, #104]	; 0x68
 801859e:	68bb      	ldr	r3, [r7, #8]
 80185a0:	1c5a      	adds	r2, r3, #1
 80185a2:	60ba      	str	r2, [r7, #8]
 80185a4:	781b      	ldrb	r3, [r3, #0]
 80185a6:	001a      	movs	r2, r3
 80185a8:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80185aa:	4313      	orrs	r3, r2
 80185ac:	66bb      	str	r3, [r7, #104]	; 0x68
 80185ae:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80185b0:	021b      	lsls	r3, r3, #8
 80185b2:	66bb      	str	r3, [r7, #104]	; 0x68
 80185b4:	68bb      	ldr	r3, [r7, #8]
 80185b6:	1c5a      	adds	r2, r3, #1
 80185b8:	60ba      	str	r2, [r7, #8]
 80185ba:	781b      	ldrb	r3, [r3, #0]
 80185bc:	001a      	movs	r2, r3
 80185be:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80185c0:	4313      	orrs	r3, r2
 80185c2:	66bb      	str	r3, [r7, #104]	; 0x68
 80185c4:	2338      	movs	r3, #56	; 0x38
 80185c6:	18fb      	adds	r3, r7, r3
 80185c8:	781a      	ldrb	r2, [r3, #0]
 80185ca:	2108      	movs	r1, #8
 80185cc:	430a      	orrs	r2, r1
 80185ce:	701a      	strb	r2, [r3, #0]
 80185d0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80185d2:	685a      	ldr	r2, [r3, #4]
 80185d4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80185d6:	431a      	orrs	r2, r3
 80185d8:	2314      	movs	r3, #20
 80185da:	18fb      	adds	r3, r7, r3
 80185dc:	605a      	str	r2, [r3, #4]
#endif /* LQR_SUPPORT */

    /*
     * Only implementing CBCP...not the rest of the callback options
     */
    NAKCICHAR(CI_CALLBACK, neg_cbcp,
 80185de:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80185e0:	781b      	ldrb	r3, [r3, #0]
 80185e2:	227f      	movs	r2, #127	; 0x7f
 80185e4:	4393      	bics	r3, r2
 80185e6:	b2db      	uxtb	r3, r3
 80185e8:	2b00      	cmp	r3, #0
 80185ea:	d025      	beq.n	8018638 <lcp_nakci+0x1ec>
 80185ec:	687b      	ldr	r3, [r7, #4]
 80185ee:	2b02      	cmp	r3, #2
 80185f0:	dd22      	ble.n	8018638 <lcp_nakci+0x1ec>
 80185f2:	68bb      	ldr	r3, [r7, #8]
 80185f4:	3301      	adds	r3, #1
 80185f6:	781b      	ldrb	r3, [r3, #0]
 80185f8:	2b03      	cmp	r3, #3
 80185fa:	d11d      	bne.n	8018638 <lcp_nakci+0x1ec>
 80185fc:	68bb      	ldr	r3, [r7, #8]
 80185fe:	781b      	ldrb	r3, [r3, #0]
 8018600:	2b0d      	cmp	r3, #13
 8018602:	d119      	bne.n	8018638 <lcp_nakci+0x1ec>
 8018604:	687b      	ldr	r3, [r7, #4]
 8018606:	3b03      	subs	r3, #3
 8018608:	607b      	str	r3, [r7, #4]
 801860a:	68bb      	ldr	r3, [r7, #8]
 801860c:	3302      	adds	r3, #2
 801860e:	60bb      	str	r3, [r7, #8]
 8018610:	68bb      	ldr	r3, [r7, #8]
 8018612:	1c5a      	adds	r2, r3, #1
 8018614:	60ba      	str	r2, [r7, #8]
 8018616:	2267      	movs	r2, #103	; 0x67
 8018618:	18ba      	adds	r2, r7, r2
 801861a:	781b      	ldrb	r3, [r3, #0]
 801861c:	7013      	strb	r3, [r2, #0]
 801861e:	2338      	movs	r3, #56	; 0x38
 8018620:	18fb      	adds	r3, r7, r3
 8018622:	781a      	ldrb	r2, [r3, #0]
 8018624:	2180      	movs	r1, #128	; 0x80
 8018626:	4249      	negs	r1, r1
 8018628:	430a      	orrs	r2, r1
 801862a:	701a      	strb	r2, [r3, #0]
 801862c:	2314      	movs	r3, #20
 801862e:	18fb      	adds	r3, r7, r3
 8018630:	781a      	ldrb	r2, [r3, #0]
 8018632:	217f      	movs	r1, #127	; 0x7f
 8018634:	400a      	ands	r2, r1
 8018636:	701a      	strb	r2, [r3, #0]
              );

    /*
     * Check for a looped-back line.
     */
    NAKCILONG(CI_MAGICNUMBER, neg_magicnumber,
 8018638:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801863a:	781b      	ldrb	r3, [r3, #0]
 801863c:	2210      	movs	r2, #16
 801863e:	4013      	ands	r3, r2
 8018640:	b2db      	uxtb	r3, r3
 8018642:	2b00      	cmp	r3, #0
 8018644:	d043      	beq.n	80186ce <lcp_nakci+0x282>
 8018646:	687b      	ldr	r3, [r7, #4]
 8018648:	2b05      	cmp	r3, #5
 801864a:	dd40      	ble.n	80186ce <lcp_nakci+0x282>
 801864c:	68bb      	ldr	r3, [r7, #8]
 801864e:	3301      	adds	r3, #1
 8018650:	781b      	ldrb	r3, [r3, #0]
 8018652:	2b06      	cmp	r3, #6
 8018654:	d13b      	bne.n	80186ce <lcp_nakci+0x282>
 8018656:	68bb      	ldr	r3, [r7, #8]
 8018658:	781b      	ldrb	r3, [r3, #0]
 801865a:	2b05      	cmp	r3, #5
 801865c:	d137      	bne.n	80186ce <lcp_nakci+0x282>
 801865e:	687b      	ldr	r3, [r7, #4]
 8018660:	3b06      	subs	r3, #6
 8018662:	607b      	str	r3, [r7, #4]
 8018664:	68bb      	ldr	r3, [r7, #8]
 8018666:	3302      	adds	r3, #2
 8018668:	60bb      	str	r3, [r7, #8]
 801866a:	68bb      	ldr	r3, [r7, #8]
 801866c:	1c5a      	adds	r2, r3, #1
 801866e:	60ba      	str	r2, [r7, #8]
 8018670:	781b      	ldrb	r3, [r3, #0]
 8018672:	021b      	lsls	r3, r3, #8
 8018674:	66bb      	str	r3, [r7, #104]	; 0x68
 8018676:	68bb      	ldr	r3, [r7, #8]
 8018678:	1c5a      	adds	r2, r3, #1
 801867a:	60ba      	str	r2, [r7, #8]
 801867c:	781b      	ldrb	r3, [r3, #0]
 801867e:	001a      	movs	r2, r3
 8018680:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018682:	4313      	orrs	r3, r2
 8018684:	66bb      	str	r3, [r7, #104]	; 0x68
 8018686:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018688:	021b      	lsls	r3, r3, #8
 801868a:	66bb      	str	r3, [r7, #104]	; 0x68
 801868c:	68bb      	ldr	r3, [r7, #8]
 801868e:	1c5a      	adds	r2, r3, #1
 8018690:	60ba      	str	r2, [r7, #8]
 8018692:	781b      	ldrb	r3, [r3, #0]
 8018694:	001a      	movs	r2, r3
 8018696:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018698:	4313      	orrs	r3, r2
 801869a:	66bb      	str	r3, [r7, #104]	; 0x68
 801869c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801869e:	021b      	lsls	r3, r3, #8
 80186a0:	66bb      	str	r3, [r7, #104]	; 0x68
 80186a2:	68bb      	ldr	r3, [r7, #8]
 80186a4:	1c5a      	adds	r2, r3, #1
 80186a6:	60ba      	str	r2, [r7, #8]
 80186a8:	781b      	ldrb	r3, [r3, #0]
 80186aa:	001a      	movs	r2, r3
 80186ac:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80186ae:	4313      	orrs	r3, r2
 80186b0:	66bb      	str	r3, [r7, #104]	; 0x68
 80186b2:	2338      	movs	r3, #56	; 0x38
 80186b4:	18fb      	adds	r3, r7, r3
 80186b6:	781a      	ldrb	r2, [r3, #0]
 80186b8:	2110      	movs	r1, #16
 80186ba:	430a      	orrs	r2, r1
 80186bc:	701a      	strb	r2, [r3, #0]
 80186be:	f001 f91b 	bl	80198f8 <magic>
 80186c2:	0002      	movs	r2, r0
 80186c4:	2314      	movs	r3, #20
 80186c6:	18fb      	adds	r3, r7, r3
 80186c8:	609a      	str	r2, [r3, #8]
 80186ca:	2301      	movs	r3, #1
 80186cc:	67fb      	str	r3, [r7, #124]	; 0x7c
    /*
     * Peer shouldn't send Nak for protocol compression or
     * address/control compression requests; they should send
     * a Reject instead.  If they send a Nak, treat it as a Reject.
     */
    NAKCIVOID(CI_PCOMPRESSION, neg_pcompression);
 80186ce:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80186d0:	781b      	ldrb	r3, [r3, #0]
 80186d2:	2220      	movs	r2, #32
 80186d4:	4013      	ands	r3, r2
 80186d6:	b2db      	uxtb	r3, r3
 80186d8:	2b00      	cmp	r3, #0
 80186da:	d01d      	beq.n	8018718 <lcp_nakci+0x2cc>
 80186dc:	687b      	ldr	r3, [r7, #4]
 80186de:	2b01      	cmp	r3, #1
 80186e0:	dd1a      	ble.n	8018718 <lcp_nakci+0x2cc>
 80186e2:	68bb      	ldr	r3, [r7, #8]
 80186e4:	3301      	adds	r3, #1
 80186e6:	781b      	ldrb	r3, [r3, #0]
 80186e8:	2b02      	cmp	r3, #2
 80186ea:	d115      	bne.n	8018718 <lcp_nakci+0x2cc>
 80186ec:	68bb      	ldr	r3, [r7, #8]
 80186ee:	781b      	ldrb	r3, [r3, #0]
 80186f0:	2b07      	cmp	r3, #7
 80186f2:	d111      	bne.n	8018718 <lcp_nakci+0x2cc>
 80186f4:	687b      	ldr	r3, [r7, #4]
 80186f6:	3b02      	subs	r3, #2
 80186f8:	607b      	str	r3, [r7, #4]
 80186fa:	68bb      	ldr	r3, [r7, #8]
 80186fc:	3302      	adds	r3, #2
 80186fe:	60bb      	str	r3, [r7, #8]
 8018700:	2338      	movs	r3, #56	; 0x38
 8018702:	18fb      	adds	r3, r7, r3
 8018704:	781a      	ldrb	r2, [r3, #0]
 8018706:	2120      	movs	r1, #32
 8018708:	430a      	orrs	r2, r1
 801870a:	701a      	strb	r2, [r3, #0]
 801870c:	2314      	movs	r3, #20
 801870e:	18fb      	adds	r3, r7, r3
 8018710:	781a      	ldrb	r2, [r3, #0]
 8018712:	2120      	movs	r1, #32
 8018714:	438a      	bics	r2, r1
 8018716:	701a      	strb	r2, [r3, #0]
    NAKCIVOID(CI_ACCOMPRESSION, neg_accompression);
 8018718:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801871a:	781b      	ldrb	r3, [r3, #0]
 801871c:	2240      	movs	r2, #64	; 0x40
 801871e:	4013      	ands	r3, r2
 8018720:	b2db      	uxtb	r3, r3
 8018722:	2b00      	cmp	r3, #0
 8018724:	d01d      	beq.n	8018762 <lcp_nakci+0x316>
 8018726:	687b      	ldr	r3, [r7, #4]
 8018728:	2b01      	cmp	r3, #1
 801872a:	dd1a      	ble.n	8018762 <lcp_nakci+0x316>
 801872c:	68bb      	ldr	r3, [r7, #8]
 801872e:	3301      	adds	r3, #1
 8018730:	781b      	ldrb	r3, [r3, #0]
 8018732:	2b02      	cmp	r3, #2
 8018734:	d115      	bne.n	8018762 <lcp_nakci+0x316>
 8018736:	68bb      	ldr	r3, [r7, #8]
 8018738:	781b      	ldrb	r3, [r3, #0]
 801873a:	2b08      	cmp	r3, #8
 801873c:	d111      	bne.n	8018762 <lcp_nakci+0x316>
 801873e:	687b      	ldr	r3, [r7, #4]
 8018740:	3b02      	subs	r3, #2
 8018742:	607b      	str	r3, [r7, #4]
 8018744:	68bb      	ldr	r3, [r7, #8]
 8018746:	3302      	adds	r3, #2
 8018748:	60bb      	str	r3, [r7, #8]
 801874a:	2338      	movs	r3, #56	; 0x38
 801874c:	18fb      	adds	r3, r7, r3
 801874e:	781a      	ldrb	r2, [r3, #0]
 8018750:	2140      	movs	r1, #64	; 0x40
 8018752:	430a      	orrs	r2, r1
 8018754:	701a      	strb	r2, [r3, #0]
 8018756:	2314      	movs	r3, #20
 8018758:	18fb      	adds	r3, r7, r3
 801875a:	781a      	ldrb	r2, [r3, #0]
 801875c:	2140      	movs	r1, #64	; 0x40
 801875e:	438a      	bics	r2, r1
 8018760:	701a      	strb	r2, [r3, #0]

    /*
     * Nak for short sequence numbers shouldn't be sent, treat it
     * like a reject.
     */
    NAKCIVOID(CI_SSNHF, neg_ssnhf);
 8018762:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018764:	785b      	ldrb	r3, [r3, #1]
 8018766:	2201      	movs	r2, #1
 8018768:	4013      	ands	r3, r2
 801876a:	b2db      	uxtb	r3, r3
 801876c:	2b00      	cmp	r3, #0
 801876e:	d01d      	beq.n	80187ac <lcp_nakci+0x360>
 8018770:	687b      	ldr	r3, [r7, #4]
 8018772:	2b01      	cmp	r3, #1
 8018774:	dd1a      	ble.n	80187ac <lcp_nakci+0x360>
 8018776:	68bb      	ldr	r3, [r7, #8]
 8018778:	3301      	adds	r3, #1
 801877a:	781b      	ldrb	r3, [r3, #0]
 801877c:	2b02      	cmp	r3, #2
 801877e:	d115      	bne.n	80187ac <lcp_nakci+0x360>
 8018780:	68bb      	ldr	r3, [r7, #8]
 8018782:	781b      	ldrb	r3, [r3, #0]
 8018784:	2b12      	cmp	r3, #18
 8018786:	d111      	bne.n	80187ac <lcp_nakci+0x360>
 8018788:	687b      	ldr	r3, [r7, #4]
 801878a:	3b02      	subs	r3, #2
 801878c:	607b      	str	r3, [r7, #4]
 801878e:	68bb      	ldr	r3, [r7, #8]
 8018790:	3302      	adds	r3, #2
 8018792:	60bb      	str	r3, [r7, #8]
 8018794:	2338      	movs	r3, #56	; 0x38
 8018796:	18fb      	adds	r3, r7, r3
 8018798:	785a      	ldrb	r2, [r3, #1]
 801879a:	2101      	movs	r1, #1
 801879c:	430a      	orrs	r2, r1
 801879e:	705a      	strb	r2, [r3, #1]
 80187a0:	2314      	movs	r3, #20
 80187a2:	18fb      	adds	r3, r7, r3
 80187a4:	785a      	ldrb	r2, [r3, #1]
 80187a6:	2101      	movs	r1, #1
 80187a8:	438a      	bics	r2, r1
 80187aa:	705a      	strb	r2, [r3, #1]

    /*
     * Nak of the endpoint discriminator option is not permitted,
     * treat it like a reject.
     */
    NAKCIENDP(CI_EPDISC, neg_endpoint);
 80187ac:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80187ae:	785b      	ldrb	r3, [r3, #1]
 80187b0:	2202      	movs	r2, #2
 80187b2:	4013      	ands	r3, r2
 80187b4:	b2db      	uxtb	r3, r3
 80187b6:	2b00      	cmp	r3, #0
 80187b8:	d100      	bne.n	80187bc <lcp_nakci+0x370>
 80187ba:	e12b      	b.n	8018a14 <lcp_nakci+0x5c8>
 80187bc:	687b      	ldr	r3, [r7, #4]
 80187be:	2b02      	cmp	r3, #2
 80187c0:	dc00      	bgt.n	80187c4 <lcp_nakci+0x378>
 80187c2:	e127      	b.n	8018a14 <lcp_nakci+0x5c8>
 80187c4:	68bb      	ldr	r3, [r7, #8]
 80187c6:	781b      	ldrb	r3, [r3, #0]
 80187c8:	2b13      	cmp	r3, #19
 80187ca:	d000      	beq.n	80187ce <lcp_nakci+0x382>
 80187cc:	e122      	b.n	8018a14 <lcp_nakci+0x5c8>
 80187ce:	68bb      	ldr	r3, [r7, #8]
 80187d0:	3301      	adds	r3, #1
 80187d2:	781b      	ldrb	r3, [r3, #0]
 80187d4:	2b02      	cmp	r3, #2
 80187d6:	d800      	bhi.n	80187da <lcp_nakci+0x38e>
 80187d8:	e11c      	b.n	8018a14 <lcp_nakci+0x5c8>
 80187da:	68bb      	ldr	r3, [r7, #8]
 80187dc:	3301      	adds	r3, #1
 80187de:	781b      	ldrb	r3, [r3, #0]
 80187e0:	001a      	movs	r2, r3
 80187e2:	687b      	ldr	r3, [r7, #4]
 80187e4:	4293      	cmp	r3, r2
 80187e6:	da00      	bge.n	80187ea <lcp_nakci+0x39e>
 80187e8:	e114      	b.n	8018a14 <lcp_nakci+0x5c8>
 80187ea:	68bb      	ldr	r3, [r7, #8]
 80187ec:	3301      	adds	r3, #1
 80187ee:	781b      	ldrb	r3, [r3, #0]
 80187f0:	001a      	movs	r2, r3
 80187f2:	687b      	ldr	r3, [r7, #4]
 80187f4:	1a9b      	subs	r3, r3, r2
 80187f6:	607b      	str	r3, [r7, #4]
 80187f8:	68bb      	ldr	r3, [r7, #8]
 80187fa:	3301      	adds	r3, #1
 80187fc:	781b      	ldrb	r3, [r3, #0]
 80187fe:	001a      	movs	r2, r3
 8018800:	68bb      	ldr	r3, [r7, #8]
 8018802:	189b      	adds	r3, r3, r2
 8018804:	60bb      	str	r3, [r7, #8]
 8018806:	2338      	movs	r3, #56	; 0x38
 8018808:	18fb      	adds	r3, r7, r3
 801880a:	785a      	ldrb	r2, [r3, #1]
 801880c:	2102      	movs	r1, #2
 801880e:	430a      	orrs	r2, r1
 8018810:	705a      	strb	r2, [r3, #1]
 8018812:	2314      	movs	r3, #20
 8018814:	18fb      	adds	r3, r7, r3
 8018816:	785a      	ldrb	r2, [r3, #1]
 8018818:	2102      	movs	r1, #2
 801881a:	438a      	bics	r2, r1
 801881c:	705a      	strb	r2, [r3, #1]
     * For the quality protocol, the Nak means `ask me to send you quality
     * reports', but if we didn't ask for them, we don't want them.
     * An option we don't recognize represents the peer asking to
     * negotiate some option we don't support, so ignore it.
     */
    while (len >= CILEN_VOID) {
 801881e:	e0f9      	b.n	8018a14 <lcp_nakci+0x5c8>
	GETCHAR(citype, p);
 8018820:	68bb      	ldr	r3, [r7, #8]
 8018822:	1c5a      	adds	r2, r3, #1
 8018824:	60ba      	str	r2, [r7, #8]
 8018826:	2166      	movs	r1, #102	; 0x66
 8018828:	187a      	adds	r2, r7, r1
 801882a:	781b      	ldrb	r3, [r3, #0]
 801882c:	7013      	strb	r3, [r2, #0]
	GETCHAR(cilen, p);
 801882e:	68bb      	ldr	r3, [r7, #8]
 8018830:	1c5a      	adds	r2, r3, #1
 8018832:	60ba      	str	r2, [r7, #8]
 8018834:	781b      	ldrb	r3, [r3, #0]
 8018836:	663b      	str	r3, [r7, #96]	; 0x60
	if (cilen < CILEN_VOID || (len -= cilen) < 0)
 8018838:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801883a:	2b01      	cmp	r3, #1
 801883c:	dc00      	bgt.n	8018840 <lcp_nakci+0x3f4>
 801883e:	e120      	b.n	8018a82 <lcp_nakci+0x636>
 8018840:	687a      	ldr	r2, [r7, #4]
 8018842:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8018844:	1ad3      	subs	r3, r2, r3
 8018846:	607b      	str	r3, [r7, #4]
 8018848:	687b      	ldr	r3, [r7, #4]
 801884a:	2b00      	cmp	r3, #0
 801884c:	da00      	bge.n	8018850 <lcp_nakci+0x404>
 801884e:	e118      	b.n	8018a82 <lcp_nakci+0x636>
	    goto bad;
	next = p + cilen - 2;
 8018850:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8018852:	3b02      	subs	r3, #2
 8018854:	68ba      	ldr	r2, [r7, #8]
 8018856:	18d3      	adds	r3, r2, r3
 8018858:	65fb      	str	r3, [r7, #92]	; 0x5c

	switch (citype) {
 801885a:	187b      	adds	r3, r7, r1
 801885c:	781b      	ldrb	r3, [r3, #0]
 801885e:	2b13      	cmp	r3, #19
 8018860:	d900      	bls.n	8018864 <lcp_nakci+0x418>
 8018862:	e0ca      	b.n	80189fa <lcp_nakci+0x5ae>
 8018864:	009a      	lsls	r2, r3, #2
 8018866:	4b91      	ldr	r3, [pc, #580]	; (8018aac <lcp_nakci+0x660>)
 8018868:	18d3      	adds	r3, r2, r3
 801886a:	681b      	ldr	r3, [r3, #0]
 801886c:	469f      	mov	pc, r3
	case CI_MRU:
	    if ((go->neg_mru && go->mru != PPP_DEFMRU)
 801886e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018870:	781b      	ldrb	r3, [r3, #0]
 8018872:	2204      	movs	r2, #4
 8018874:	4013      	ands	r3, r2
 8018876:	b2db      	uxtb	r3, r3
 8018878:	2b00      	cmp	r3, #0
 801887a:	d005      	beq.n	8018888 <lcp_nakci+0x43c>
 801887c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801887e:	885b      	ldrh	r3, [r3, #2]
 8018880:	4a8b      	ldr	r2, [pc, #556]	; (8018ab0 <lcp_nakci+0x664>)
 8018882:	4293      	cmp	r3, r2
 8018884:	d000      	beq.n	8018888 <lcp_nakci+0x43c>
 8018886:	e0fe      	b.n	8018a86 <lcp_nakci+0x63a>
		|| no.neg_mru || cilen != CILEN_SHORT)
 8018888:	2338      	movs	r3, #56	; 0x38
 801888a:	18fb      	adds	r3, r7, r3
 801888c:	781b      	ldrb	r3, [r3, #0]
 801888e:	2204      	movs	r2, #4
 8018890:	4013      	ands	r3, r2
 8018892:	b2db      	uxtb	r3, r3
 8018894:	2b00      	cmp	r3, #0
 8018896:	d000      	beq.n	801889a <lcp_nakci+0x44e>
 8018898:	e0f5      	b.n	8018a86 <lcp_nakci+0x63a>
 801889a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801889c:	2b04      	cmp	r3, #4
 801889e:	d000      	beq.n	80188a2 <lcp_nakci+0x456>
 80188a0:	e0f1      	b.n	8018a86 <lcp_nakci+0x63a>
		goto bad;
	    GETSHORT(cishort, p);
 80188a2:	68bb      	ldr	r3, [r7, #8]
 80188a4:	1c5a      	adds	r2, r3, #1
 80188a6:	60ba      	str	r2, [r7, #8]
 80188a8:	781b      	ldrb	r3, [r3, #0]
 80188aa:	b29a      	uxth	r2, r3
 80188ac:	206e      	movs	r0, #110	; 0x6e
 80188ae:	183b      	adds	r3, r7, r0
 80188b0:	0212      	lsls	r2, r2, #8
 80188b2:	801a      	strh	r2, [r3, #0]
 80188b4:	68bb      	ldr	r3, [r7, #8]
 80188b6:	1c5a      	adds	r2, r3, #1
 80188b8:	60ba      	str	r2, [r7, #8]
 80188ba:	781b      	ldrb	r3, [r3, #0]
 80188bc:	b299      	uxth	r1, r3
 80188be:	183b      	adds	r3, r7, r0
 80188c0:	183a      	adds	r2, r7, r0
 80188c2:	8812      	ldrh	r2, [r2, #0]
 80188c4:	430a      	orrs	r2, r1
 80188c6:	801a      	strh	r2, [r3, #0]
	    if (cishort < PPP_DEFMRU) {
 80188c8:	183b      	adds	r3, r7, r0
 80188ca:	881b      	ldrh	r3, [r3, #0]
 80188cc:	4a79      	ldr	r2, [pc, #484]	; (8018ab4 <lcp_nakci+0x668>)
 80188ce:	4293      	cmp	r3, r2
 80188d0:	d900      	bls.n	80188d4 <lcp_nakci+0x488>
 80188d2:	e094      	b.n	80189fe <lcp_nakci+0x5b2>
		try_.neg_mru = 1;
 80188d4:	2414      	movs	r4, #20
 80188d6:	193b      	adds	r3, r7, r4
 80188d8:	781a      	ldrb	r2, [r3, #0]
 80188da:	2104      	movs	r1, #4
 80188dc:	430a      	orrs	r2, r1
 80188de:	701a      	strb	r2, [r3, #0]
		try_.mru = cishort;
 80188e0:	193b      	adds	r3, r7, r4
 80188e2:	183a      	adds	r2, r7, r0
 80188e4:	8812      	ldrh	r2, [r2, #0]
 80188e6:	805a      	strh	r2, [r3, #2]
	    }
	    break;
 80188e8:	e089      	b.n	80189fe <lcp_nakci+0x5b2>
	case CI_ASYNCMAP:
	    if ((go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF)
 80188ea:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80188ec:	781b      	ldrb	r3, [r3, #0]
 80188ee:	2208      	movs	r2, #8
 80188f0:	4013      	ands	r3, r2
 80188f2:	b2db      	uxtb	r3, r3
 80188f4:	2b00      	cmp	r3, #0
 80188f6:	d004      	beq.n	8018902 <lcp_nakci+0x4b6>
 80188f8:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80188fa:	685b      	ldr	r3, [r3, #4]
 80188fc:	3301      	adds	r3, #1
 80188fe:	d000      	beq.n	8018902 <lcp_nakci+0x4b6>
 8018900:	e0c3      	b.n	8018a8a <lcp_nakci+0x63e>
		|| no.neg_asyncmap || cilen != CILEN_LONG)
 8018902:	2338      	movs	r3, #56	; 0x38
 8018904:	18fb      	adds	r3, r7, r3
 8018906:	781b      	ldrb	r3, [r3, #0]
 8018908:	2208      	movs	r2, #8
 801890a:	4013      	ands	r3, r2
 801890c:	b2db      	uxtb	r3, r3
 801890e:	2b00      	cmp	r3, #0
 8018910:	d000      	beq.n	8018914 <lcp_nakci+0x4c8>
 8018912:	e0ba      	b.n	8018a8a <lcp_nakci+0x63e>
 8018914:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8018916:	2b06      	cmp	r3, #6
 8018918:	d100      	bne.n	801891c <lcp_nakci+0x4d0>
 801891a:	e072      	b.n	8018a02 <lcp_nakci+0x5b6>
		goto bad;
 801891c:	e0b5      	b.n	8018a8a <lcp_nakci+0x63e>
#endif /* EAP_SUPPORT */
		)
		goto bad;
	    break;
	case CI_MAGICNUMBER:
	    if (go->neg_magicnumber || no.neg_magicnumber ||
 801891e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018920:	781b      	ldrb	r3, [r3, #0]
 8018922:	2210      	movs	r2, #16
 8018924:	4013      	ands	r3, r2
 8018926:	b2db      	uxtb	r3, r3
 8018928:	2b00      	cmp	r3, #0
 801892a:	d000      	beq.n	801892e <lcp_nakci+0x4e2>
 801892c:	e0af      	b.n	8018a8e <lcp_nakci+0x642>
 801892e:	2338      	movs	r3, #56	; 0x38
 8018930:	18fb      	adds	r3, r7, r3
 8018932:	781b      	ldrb	r3, [r3, #0]
 8018934:	2210      	movs	r2, #16
 8018936:	4013      	ands	r3, r2
 8018938:	b2db      	uxtb	r3, r3
 801893a:	2b00      	cmp	r3, #0
 801893c:	d000      	beq.n	8018940 <lcp_nakci+0x4f4>
 801893e:	e0a6      	b.n	8018a8e <lcp_nakci+0x642>
 8018940:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8018942:	2b06      	cmp	r3, #6
 8018944:	d05f      	beq.n	8018a06 <lcp_nakci+0x5ba>
		cilen != CILEN_LONG)
		goto bad;
 8018946:	e0a2      	b.n	8018a8e <lcp_nakci+0x642>
	    break;
	case CI_PCOMPRESSION:
	    if (go->neg_pcompression || no.neg_pcompression
 8018948:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801894a:	781b      	ldrb	r3, [r3, #0]
 801894c:	2220      	movs	r2, #32
 801894e:	4013      	ands	r3, r2
 8018950:	b2db      	uxtb	r3, r3
 8018952:	2b00      	cmp	r3, #0
 8018954:	d000      	beq.n	8018958 <lcp_nakci+0x50c>
 8018956:	e09c      	b.n	8018a92 <lcp_nakci+0x646>
 8018958:	2338      	movs	r3, #56	; 0x38
 801895a:	18fb      	adds	r3, r7, r3
 801895c:	781b      	ldrb	r3, [r3, #0]
 801895e:	2220      	movs	r2, #32
 8018960:	4013      	ands	r3, r2
 8018962:	b2db      	uxtb	r3, r3
 8018964:	2b00      	cmp	r3, #0
 8018966:	d000      	beq.n	801896a <lcp_nakci+0x51e>
 8018968:	e093      	b.n	8018a92 <lcp_nakci+0x646>
		|| cilen != CILEN_VOID)
 801896a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801896c:	2b02      	cmp	r3, #2
 801896e:	d04c      	beq.n	8018a0a <lcp_nakci+0x5be>
		goto bad;
 8018970:	e08f      	b.n	8018a92 <lcp_nakci+0x646>
	    break;
	case CI_ACCOMPRESSION:
	    if (go->neg_accompression || no.neg_accompression
 8018972:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018974:	781b      	ldrb	r3, [r3, #0]
 8018976:	2240      	movs	r2, #64	; 0x40
 8018978:	4013      	ands	r3, r2
 801897a:	b2db      	uxtb	r3, r3
 801897c:	2b00      	cmp	r3, #0
 801897e:	d000      	beq.n	8018982 <lcp_nakci+0x536>
 8018980:	e089      	b.n	8018a96 <lcp_nakci+0x64a>
 8018982:	2338      	movs	r3, #56	; 0x38
 8018984:	18fb      	adds	r3, r7, r3
 8018986:	781b      	ldrb	r3, [r3, #0]
 8018988:	2240      	movs	r2, #64	; 0x40
 801898a:	4013      	ands	r3, r2
 801898c:	b2db      	uxtb	r3, r3
 801898e:	2b00      	cmp	r3, #0
 8018990:	d000      	beq.n	8018994 <lcp_nakci+0x548>
 8018992:	e080      	b.n	8018a96 <lcp_nakci+0x64a>
		|| cilen != CILEN_VOID)
 8018994:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8018996:	2b02      	cmp	r3, #2
 8018998:	d039      	beq.n	8018a0e <lcp_nakci+0x5c2>
		goto bad;
 801899a:	e07c      	b.n	8018a96 <lcp_nakci+0x64a>
	    if (go->neg_mrru || no.neg_mrru || cilen != CILEN_SHORT)
		goto bad;
	    break;
#endif /* HAVE_MULTILINK */
	case CI_SSNHF:
	    if (go->neg_ssnhf || no.neg_ssnhf || cilen != CILEN_VOID)
 801899c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801899e:	785b      	ldrb	r3, [r3, #1]
 80189a0:	2201      	movs	r2, #1
 80189a2:	4013      	ands	r3, r2
 80189a4:	b2db      	uxtb	r3, r3
 80189a6:	2b00      	cmp	r3, #0
 80189a8:	d000      	beq.n	80189ac <lcp_nakci+0x560>
 80189aa:	e076      	b.n	8018a9a <lcp_nakci+0x64e>
 80189ac:	2338      	movs	r3, #56	; 0x38
 80189ae:	18fb      	adds	r3, r7, r3
 80189b0:	785b      	ldrb	r3, [r3, #1]
 80189b2:	2201      	movs	r2, #1
 80189b4:	4013      	ands	r3, r2
 80189b6:	b2db      	uxtb	r3, r3
 80189b8:	2b00      	cmp	r3, #0
 80189ba:	d000      	beq.n	80189be <lcp_nakci+0x572>
 80189bc:	e06d      	b.n	8018a9a <lcp_nakci+0x64e>
 80189be:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80189c0:	2b02      	cmp	r3, #2
 80189c2:	d000      	beq.n	80189c6 <lcp_nakci+0x57a>
 80189c4:	e069      	b.n	8018a9a <lcp_nakci+0x64e>
		goto bad;
	    try_.neg_ssnhf = 1;
 80189c6:	2314      	movs	r3, #20
 80189c8:	18fb      	adds	r3, r7, r3
 80189ca:	785a      	ldrb	r2, [r3, #1]
 80189cc:	2101      	movs	r1, #1
 80189ce:	430a      	orrs	r2, r1
 80189d0:	705a      	strb	r2, [r3, #1]
	    break;
 80189d2:	e01d      	b.n	8018a10 <lcp_nakci+0x5c4>
	case CI_EPDISC:
	    if (go->neg_endpoint || no.neg_endpoint || cilen < CILEN_CHAR)
 80189d4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80189d6:	785b      	ldrb	r3, [r3, #1]
 80189d8:	2202      	movs	r2, #2
 80189da:	4013      	ands	r3, r2
 80189dc:	b2db      	uxtb	r3, r3
 80189de:	2b00      	cmp	r3, #0
 80189e0:	d15d      	bne.n	8018a9e <lcp_nakci+0x652>
 80189e2:	2338      	movs	r3, #56	; 0x38
 80189e4:	18fb      	adds	r3, r7, r3
 80189e6:	785b      	ldrb	r3, [r3, #1]
 80189e8:	2202      	movs	r2, #2
 80189ea:	4013      	ands	r3, r2
 80189ec:	b2db      	uxtb	r3, r3
 80189ee:	2b00      	cmp	r3, #0
 80189f0:	d155      	bne.n	8018a9e <lcp_nakci+0x652>
 80189f2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80189f4:	2b02      	cmp	r3, #2
 80189f6:	dd52      	ble.n	8018a9e <lcp_nakci+0x652>
		goto bad;
	    break;
 80189f8:	e00a      	b.n	8018a10 <lcp_nakci+0x5c4>
	default:
	    break;
 80189fa:	46c0      	nop			; (mov r8, r8)
 80189fc:	e008      	b.n	8018a10 <lcp_nakci+0x5c4>
	    break;
 80189fe:	46c0      	nop			; (mov r8, r8)
 8018a00:	e006      	b.n	8018a10 <lcp_nakci+0x5c4>
	    break;
 8018a02:	46c0      	nop			; (mov r8, r8)
 8018a04:	e004      	b.n	8018a10 <lcp_nakci+0x5c4>
	    break;
 8018a06:	46c0      	nop			; (mov r8, r8)
 8018a08:	e002      	b.n	8018a10 <lcp_nakci+0x5c4>
	    break;
 8018a0a:	46c0      	nop			; (mov r8, r8)
 8018a0c:	e000      	b.n	8018a10 <lcp_nakci+0x5c4>
	    break;
 8018a0e:	46c0      	nop			; (mov r8, r8)
	}
	p = next;
 8018a10:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8018a12:	60bb      	str	r3, [r7, #8]
    while (len >= CILEN_VOID) {
 8018a14:	687b      	ldr	r3, [r7, #4]
 8018a16:	2b01      	cmp	r3, #1
 8018a18:	dd00      	ble.n	8018a1c <lcp_nakci+0x5d0>
 8018a1a:	e701      	b.n	8018820 <lcp_nakci+0x3d4>

    /*
     * OK, the Nak is good.  Now we can update state.
     * If there are any options left we ignore them.
     */
    if (f->state != PPP_FSM_OPENED) {
 8018a1c:	68fb      	ldr	r3, [r7, #12]
 8018a1e:	7c1b      	ldrb	r3, [r3, #16]
 8018a20:	2b09      	cmp	r3, #9
 8018a22:	d02c      	beq.n	8018a7e <lcp_nakci+0x632>
	if (looped_back) {
 8018a24:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8018a26:	2b00      	cmp	r3, #0
 8018a28:	d01c      	beq.n	8018a64 <lcp_nakci+0x618>
	    if (++try_.numloops >= pcb->settings.lcp_loopbackfail) {
 8018a2a:	2114      	movs	r1, #20
 8018a2c:	187b      	adds	r3, r7, r1
 8018a2e:	7b1b      	ldrb	r3, [r3, #12]
 8018a30:	3301      	adds	r3, #1
 8018a32:	b2da      	uxtb	r2, r3
 8018a34:	187b      	adds	r3, r7, r1
 8018a36:	731a      	strb	r2, [r3, #12]
 8018a38:	187b      	adds	r3, r7, r1
 8018a3a:	7b1a      	ldrb	r2, [r3, #12]
 8018a3c:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8018a3e:	7a1b      	ldrb	r3, [r3, #8]
 8018a40:	429a      	cmp	r2, r3
 8018a42:	d313      	bcc.n	8018a6c <lcp_nakci+0x620>
		ppp_notice("Serial line is looped back.");
 8018a44:	4b1c      	ldr	r3, [pc, #112]	; (8018ab8 <lcp_nakci+0x66c>)
 8018a46:	0018      	movs	r0, r3
 8018a48:	f002 fd93 	bl	801b572 <ppp_notice>
		pcb->err_code = PPPERR_LOOPBACK;
 8018a4c:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8018a4e:	2225      	movs	r2, #37	; 0x25
 8018a50:	210c      	movs	r1, #12
 8018a52:	5499      	strb	r1, [r3, r2]
		lcp_close(f->pcb, "Loopback detected");
 8018a54:	68fb      	ldr	r3, [r7, #12]
 8018a56:	681b      	ldr	r3, [r3, #0]
 8018a58:	4a18      	ldr	r2, [pc, #96]	; (8018abc <lcp_nakci+0x670>)
 8018a5a:	0011      	movs	r1, r2
 8018a5c:	0018      	movs	r0, r3
 8018a5e:	f7fe ff03 	bl	8017868 <lcp_close>
 8018a62:	e003      	b.n	8018a6c <lcp_nakci+0x620>
	    }
	} else
	    try_.numloops = 0;
 8018a64:	2314      	movs	r3, #20
 8018a66:	18fb      	adds	r3, r7, r3
 8018a68:	2200      	movs	r2, #0
 8018a6a:	731a      	strb	r2, [r3, #12]
	*go = try_;
 8018a6c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018a6e:	2214      	movs	r2, #20
 8018a70:	18ba      	adds	r2, r7, r2
 8018a72:	ca13      	ldmia	r2!, {r0, r1, r4}
 8018a74:	c313      	stmia	r3!, {r0, r1, r4}
 8018a76:	ca13      	ldmia	r2!, {r0, r1, r4}
 8018a78:	c313      	stmia	r3!, {r0, r1, r4}
 8018a7a:	ca13      	ldmia	r2!, {r0, r1, r4}
 8018a7c:	c313      	stmia	r3!, {r0, r1, r4}
    }

    return 1;
 8018a7e:	2301      	movs	r3, #1
 8018a80:	e00f      	b.n	8018aa2 <lcp_nakci+0x656>
	    goto bad;
 8018a82:	46c0      	nop			; (mov r8, r8)
 8018a84:	e00c      	b.n	8018aa0 <lcp_nakci+0x654>
		goto bad;
 8018a86:	46c0      	nop			; (mov r8, r8)
 8018a88:	e00a      	b.n	8018aa0 <lcp_nakci+0x654>
		goto bad;
 8018a8a:	46c0      	nop			; (mov r8, r8)
 8018a8c:	e008      	b.n	8018aa0 <lcp_nakci+0x654>
		goto bad;
 8018a8e:	46c0      	nop			; (mov r8, r8)
 8018a90:	e006      	b.n	8018aa0 <lcp_nakci+0x654>
		goto bad;
 8018a92:	46c0      	nop			; (mov r8, r8)
 8018a94:	e004      	b.n	8018aa0 <lcp_nakci+0x654>
		goto bad;
 8018a96:	46c0      	nop			; (mov r8, r8)
 8018a98:	e002      	b.n	8018aa0 <lcp_nakci+0x654>
		goto bad;
 8018a9a:	46c0      	nop			; (mov r8, r8)
 8018a9c:	e000      	b.n	8018aa0 <lcp_nakci+0x654>
		goto bad;
 8018a9e:	46c0      	nop			; (mov r8, r8)

bad:
    LCPDEBUG(("lcp_nakci: received bad Nak!"));
    return 0;
 8018aa0:	2300      	movs	r3, #0
}
 8018aa2:	0018      	movs	r0, r3
 8018aa4:	46bd      	mov	sp, r7
 8018aa6:	b020      	add	sp, #128	; 0x80
 8018aa8:	bdb0      	pop	{r4, r5, r7, pc}
 8018aaa:	46c0      	nop			; (mov r8, r8)
 8018aac:	08022628 	.word	0x08022628
 8018ab0:	000005dc 	.word	0x000005dc
 8018ab4:	000005db 	.word	0x000005db
 8018ab8:	080219ac 	.word	0x080219ac
 8018abc:	080219c8 	.word	0x080219c8

08018ac0 <lcp_rejci>:
 *
 * Returns:
 *	0 - Reject was bad.
 *	1 - Reject was good.
 */
static int lcp_rejci(fsm *f, u_char *p, int len) {
 8018ac0:	b5b0      	push	{r4, r5, r7, lr}
 8018ac2:	b094      	sub	sp, #80	; 0x50
 8018ac4:	af00      	add	r7, sp, #0
 8018ac6:	60f8      	str	r0, [r7, #12]
 8018ac8:	60b9      	str	r1, [r7, #8]
 8018aca:	607a      	str	r2, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8018acc:	68fb      	ldr	r3, [r7, #12]
 8018ace:	681b      	ldr	r3, [r3, #0]
 8018ad0:	64bb      	str	r3, [r7, #72]	; 0x48
    lcp_options *go = &pcb->lcp_gotoptions;
 8018ad2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8018ad4:	3368      	adds	r3, #104	; 0x68
 8018ad6:	647b      	str	r3, [r7, #68]	; 0x44
    u_char cichar;
    u_short cishort;
    u32_t cilong;
    lcp_options try_;		/* options to request next time */

    try_ = *go;
 8018ad8:	2414      	movs	r4, #20
 8018ada:	193b      	adds	r3, r7, r4
 8018adc:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8018ade:	ca23      	ldmia	r2!, {r0, r1, r5}
 8018ae0:	c323      	stmia	r3!, {r0, r1, r5}
 8018ae2:	ca23      	ldmia	r2!, {r0, r1, r5}
 8018ae4:	c323      	stmia	r3!, {r0, r1, r5}
 8018ae6:	ca23      	ldmia	r2!, {r0, r1, r5}
 8018ae8:	c323      	stmia	r3!, {r0, r1, r5}
		goto bad; \
	} \
	try_.neg = 0; \
    }

    REJCISHORT(CI_MRU, neg_mru, go->mru);
 8018aea:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018aec:	781b      	ldrb	r3, [r3, #0]
 8018aee:	2204      	movs	r2, #4
 8018af0:	4013      	ands	r3, r2
 8018af2:	b2db      	uxtb	r3, r3
 8018af4:	2b00      	cmp	r3, #0
 8018af6:	d030      	beq.n	8018b5a <lcp_rejci+0x9a>
 8018af8:	687b      	ldr	r3, [r7, #4]
 8018afa:	2b03      	cmp	r3, #3
 8018afc:	dd2d      	ble.n	8018b5a <lcp_rejci+0x9a>
 8018afe:	68bb      	ldr	r3, [r7, #8]
 8018b00:	3301      	adds	r3, #1
 8018b02:	781b      	ldrb	r3, [r3, #0]
 8018b04:	2b04      	cmp	r3, #4
 8018b06:	d128      	bne.n	8018b5a <lcp_rejci+0x9a>
 8018b08:	68bb      	ldr	r3, [r7, #8]
 8018b0a:	781b      	ldrb	r3, [r3, #0]
 8018b0c:	2b01      	cmp	r3, #1
 8018b0e:	d124      	bne.n	8018b5a <lcp_rejci+0x9a>
 8018b10:	687b      	ldr	r3, [r7, #4]
 8018b12:	3b04      	subs	r3, #4
 8018b14:	607b      	str	r3, [r7, #4]
 8018b16:	68bb      	ldr	r3, [r7, #8]
 8018b18:	3302      	adds	r3, #2
 8018b1a:	60bb      	str	r3, [r7, #8]
 8018b1c:	68bb      	ldr	r3, [r7, #8]
 8018b1e:	1c5a      	adds	r2, r3, #1
 8018b20:	60ba      	str	r2, [r7, #8]
 8018b22:	781b      	ldrb	r3, [r3, #0]
 8018b24:	b29a      	uxth	r2, r3
 8018b26:	2042      	movs	r0, #66	; 0x42
 8018b28:	183b      	adds	r3, r7, r0
 8018b2a:	0212      	lsls	r2, r2, #8
 8018b2c:	801a      	strh	r2, [r3, #0]
 8018b2e:	68bb      	ldr	r3, [r7, #8]
 8018b30:	1c5a      	adds	r2, r3, #1
 8018b32:	60ba      	str	r2, [r7, #8]
 8018b34:	781b      	ldrb	r3, [r3, #0]
 8018b36:	b299      	uxth	r1, r3
 8018b38:	183b      	adds	r3, r7, r0
 8018b3a:	183a      	adds	r2, r7, r0
 8018b3c:	8812      	ldrh	r2, [r2, #0]
 8018b3e:	430a      	orrs	r2, r1
 8018b40:	801a      	strh	r2, [r3, #0]
 8018b42:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018b44:	885b      	ldrh	r3, [r3, #2]
 8018b46:	183a      	adds	r2, r7, r0
 8018b48:	8812      	ldrh	r2, [r2, #0]
 8018b4a:	429a      	cmp	r2, r3
 8018b4c:	d000      	beq.n	8018b50 <lcp_rejci+0x90>
 8018b4e:	e182      	b.n	8018e56 <lcp_rejci+0x396>
 8018b50:	193b      	adds	r3, r7, r4
 8018b52:	781a      	ldrb	r2, [r3, #0]
 8018b54:	2104      	movs	r1, #4
 8018b56:	438a      	bics	r2, r1
 8018b58:	701a      	strb	r2, [r3, #0]
    REJCILONG(CI_ASYNCMAP, neg_asyncmap, go->asyncmap);
 8018b5a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018b5c:	781b      	ldrb	r3, [r3, #0]
 8018b5e:	2208      	movs	r2, #8
 8018b60:	4013      	ands	r3, r2
 8018b62:	b2db      	uxtb	r3, r3
 8018b64:	2b00      	cmp	r3, #0
 8018b66:	d041      	beq.n	8018bec <lcp_rejci+0x12c>
 8018b68:	687b      	ldr	r3, [r7, #4]
 8018b6a:	2b05      	cmp	r3, #5
 8018b6c:	dd3e      	ble.n	8018bec <lcp_rejci+0x12c>
 8018b6e:	68bb      	ldr	r3, [r7, #8]
 8018b70:	3301      	adds	r3, #1
 8018b72:	781b      	ldrb	r3, [r3, #0]
 8018b74:	2b06      	cmp	r3, #6
 8018b76:	d139      	bne.n	8018bec <lcp_rejci+0x12c>
 8018b78:	68bb      	ldr	r3, [r7, #8]
 8018b7a:	781b      	ldrb	r3, [r3, #0]
 8018b7c:	2b02      	cmp	r3, #2
 8018b7e:	d135      	bne.n	8018bec <lcp_rejci+0x12c>
 8018b80:	687b      	ldr	r3, [r7, #4]
 8018b82:	3b06      	subs	r3, #6
 8018b84:	607b      	str	r3, [r7, #4]
 8018b86:	68bb      	ldr	r3, [r7, #8]
 8018b88:	3302      	adds	r3, #2
 8018b8a:	60bb      	str	r3, [r7, #8]
 8018b8c:	68bb      	ldr	r3, [r7, #8]
 8018b8e:	1c5a      	adds	r2, r3, #1
 8018b90:	60ba      	str	r2, [r7, #8]
 8018b92:	781b      	ldrb	r3, [r3, #0]
 8018b94:	021b      	lsls	r3, r3, #8
 8018b96:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018b98:	68bb      	ldr	r3, [r7, #8]
 8018b9a:	1c5a      	adds	r2, r3, #1
 8018b9c:	60ba      	str	r2, [r7, #8]
 8018b9e:	781b      	ldrb	r3, [r3, #0]
 8018ba0:	001a      	movs	r2, r3
 8018ba2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018ba4:	4313      	orrs	r3, r2
 8018ba6:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018ba8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018baa:	021b      	lsls	r3, r3, #8
 8018bac:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018bae:	68bb      	ldr	r3, [r7, #8]
 8018bb0:	1c5a      	adds	r2, r3, #1
 8018bb2:	60ba      	str	r2, [r7, #8]
 8018bb4:	781b      	ldrb	r3, [r3, #0]
 8018bb6:	001a      	movs	r2, r3
 8018bb8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018bba:	4313      	orrs	r3, r2
 8018bbc:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018bbe:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018bc0:	021b      	lsls	r3, r3, #8
 8018bc2:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018bc4:	68bb      	ldr	r3, [r7, #8]
 8018bc6:	1c5a      	adds	r2, r3, #1
 8018bc8:	60ba      	str	r2, [r7, #8]
 8018bca:	781b      	ldrb	r3, [r3, #0]
 8018bcc:	001a      	movs	r2, r3
 8018bce:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018bd0:	4313      	orrs	r3, r2
 8018bd2:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018bd4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018bd6:	685b      	ldr	r3, [r3, #4]
 8018bd8:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8018bda:	429a      	cmp	r2, r3
 8018bdc:	d000      	beq.n	8018be0 <lcp_rejci+0x120>
 8018bde:	e13c      	b.n	8018e5a <lcp_rejci+0x39a>
 8018be0:	2314      	movs	r3, #20
 8018be2:	18fb      	adds	r3, r7, r3
 8018be4:	781a      	ldrb	r2, [r3, #0]
 8018be6:	2108      	movs	r1, #8
 8018be8:	438a      	bics	r2, r1
 8018bea:	701a      	strb	r2, [r3, #0]
    }
#endif /* EAP_SUPPORT */
#if LQR_SUPPORT
    REJCILQR(CI_QUALITY, neg_lqr, go->lqr_period);
#endif /* LQR_SUPPORT */
    REJCICBCP(CI_CALLBACK, neg_cbcp, CBCP_OPT);
 8018bec:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018bee:	781b      	ldrb	r3, [r3, #0]
 8018bf0:	227f      	movs	r2, #127	; 0x7f
 8018bf2:	4393      	bics	r3, r2
 8018bf4:	b2db      	uxtb	r3, r3
 8018bf6:	2b00      	cmp	r3, #0
 8018bf8:	d023      	beq.n	8018c42 <lcp_rejci+0x182>
 8018bfa:	687b      	ldr	r3, [r7, #4]
 8018bfc:	2b02      	cmp	r3, #2
 8018bfe:	dd20      	ble.n	8018c42 <lcp_rejci+0x182>
 8018c00:	68bb      	ldr	r3, [r7, #8]
 8018c02:	3301      	adds	r3, #1
 8018c04:	781b      	ldrb	r3, [r3, #0]
 8018c06:	2b03      	cmp	r3, #3
 8018c08:	d11b      	bne.n	8018c42 <lcp_rejci+0x182>
 8018c0a:	68bb      	ldr	r3, [r7, #8]
 8018c0c:	781b      	ldrb	r3, [r3, #0]
 8018c0e:	2b0d      	cmp	r3, #13
 8018c10:	d117      	bne.n	8018c42 <lcp_rejci+0x182>
 8018c12:	687b      	ldr	r3, [r7, #4]
 8018c14:	3b03      	subs	r3, #3
 8018c16:	607b      	str	r3, [r7, #4]
 8018c18:	68bb      	ldr	r3, [r7, #8]
 8018c1a:	3302      	adds	r3, #2
 8018c1c:	60bb      	str	r3, [r7, #8]
 8018c1e:	68bb      	ldr	r3, [r7, #8]
 8018c20:	1c5a      	adds	r2, r3, #1
 8018c22:	60ba      	str	r2, [r7, #8]
 8018c24:	213b      	movs	r1, #59	; 0x3b
 8018c26:	187a      	adds	r2, r7, r1
 8018c28:	781b      	ldrb	r3, [r3, #0]
 8018c2a:	7013      	strb	r3, [r2, #0]
 8018c2c:	187b      	adds	r3, r7, r1
 8018c2e:	781b      	ldrb	r3, [r3, #0]
 8018c30:	2b06      	cmp	r3, #6
 8018c32:	d000      	beq.n	8018c36 <lcp_rejci+0x176>
 8018c34:	e113      	b.n	8018e5e <lcp_rejci+0x39e>
 8018c36:	2314      	movs	r3, #20
 8018c38:	18fb      	adds	r3, r7, r3
 8018c3a:	781a      	ldrb	r2, [r3, #0]
 8018c3c:	217f      	movs	r1, #127	; 0x7f
 8018c3e:	400a      	ands	r2, r1
 8018c40:	701a      	strb	r2, [r3, #0]
    REJCILONG(CI_MAGICNUMBER, neg_magicnumber, go->magicnumber);
 8018c42:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018c44:	781b      	ldrb	r3, [r3, #0]
 8018c46:	2210      	movs	r2, #16
 8018c48:	4013      	ands	r3, r2
 8018c4a:	b2db      	uxtb	r3, r3
 8018c4c:	2b00      	cmp	r3, #0
 8018c4e:	d041      	beq.n	8018cd4 <lcp_rejci+0x214>
 8018c50:	687b      	ldr	r3, [r7, #4]
 8018c52:	2b05      	cmp	r3, #5
 8018c54:	dd3e      	ble.n	8018cd4 <lcp_rejci+0x214>
 8018c56:	68bb      	ldr	r3, [r7, #8]
 8018c58:	3301      	adds	r3, #1
 8018c5a:	781b      	ldrb	r3, [r3, #0]
 8018c5c:	2b06      	cmp	r3, #6
 8018c5e:	d139      	bne.n	8018cd4 <lcp_rejci+0x214>
 8018c60:	68bb      	ldr	r3, [r7, #8]
 8018c62:	781b      	ldrb	r3, [r3, #0]
 8018c64:	2b05      	cmp	r3, #5
 8018c66:	d135      	bne.n	8018cd4 <lcp_rejci+0x214>
 8018c68:	687b      	ldr	r3, [r7, #4]
 8018c6a:	3b06      	subs	r3, #6
 8018c6c:	607b      	str	r3, [r7, #4]
 8018c6e:	68bb      	ldr	r3, [r7, #8]
 8018c70:	3302      	adds	r3, #2
 8018c72:	60bb      	str	r3, [r7, #8]
 8018c74:	68bb      	ldr	r3, [r7, #8]
 8018c76:	1c5a      	adds	r2, r3, #1
 8018c78:	60ba      	str	r2, [r7, #8]
 8018c7a:	781b      	ldrb	r3, [r3, #0]
 8018c7c:	021b      	lsls	r3, r3, #8
 8018c7e:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018c80:	68bb      	ldr	r3, [r7, #8]
 8018c82:	1c5a      	adds	r2, r3, #1
 8018c84:	60ba      	str	r2, [r7, #8]
 8018c86:	781b      	ldrb	r3, [r3, #0]
 8018c88:	001a      	movs	r2, r3
 8018c8a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018c8c:	4313      	orrs	r3, r2
 8018c8e:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018c90:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018c92:	021b      	lsls	r3, r3, #8
 8018c94:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018c96:	68bb      	ldr	r3, [r7, #8]
 8018c98:	1c5a      	adds	r2, r3, #1
 8018c9a:	60ba      	str	r2, [r7, #8]
 8018c9c:	781b      	ldrb	r3, [r3, #0]
 8018c9e:	001a      	movs	r2, r3
 8018ca0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018ca2:	4313      	orrs	r3, r2
 8018ca4:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018ca6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018ca8:	021b      	lsls	r3, r3, #8
 8018caa:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018cac:	68bb      	ldr	r3, [r7, #8]
 8018cae:	1c5a      	adds	r2, r3, #1
 8018cb0:	60ba      	str	r2, [r7, #8]
 8018cb2:	781b      	ldrb	r3, [r3, #0]
 8018cb4:	001a      	movs	r2, r3
 8018cb6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018cb8:	4313      	orrs	r3, r2
 8018cba:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018cbc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018cbe:	689b      	ldr	r3, [r3, #8]
 8018cc0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8018cc2:	429a      	cmp	r2, r3
 8018cc4:	d000      	beq.n	8018cc8 <lcp_rejci+0x208>
 8018cc6:	e0cc      	b.n	8018e62 <lcp_rejci+0x3a2>
 8018cc8:	2314      	movs	r3, #20
 8018cca:	18fb      	adds	r3, r7, r3
 8018ccc:	781a      	ldrb	r2, [r3, #0]
 8018cce:	2110      	movs	r1, #16
 8018cd0:	438a      	bics	r2, r1
 8018cd2:	701a      	strb	r2, [r3, #0]
    REJCIVOID(CI_PCOMPRESSION, neg_pcompression);
 8018cd4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018cd6:	781b      	ldrb	r3, [r3, #0]
 8018cd8:	2220      	movs	r2, #32
 8018cda:	4013      	ands	r3, r2
 8018cdc:	b2db      	uxtb	r3, r3
 8018cde:	2b00      	cmp	r3, #0
 8018ce0:	d017      	beq.n	8018d12 <lcp_rejci+0x252>
 8018ce2:	687b      	ldr	r3, [r7, #4]
 8018ce4:	2b01      	cmp	r3, #1
 8018ce6:	dd14      	ble.n	8018d12 <lcp_rejci+0x252>
 8018ce8:	68bb      	ldr	r3, [r7, #8]
 8018cea:	3301      	adds	r3, #1
 8018cec:	781b      	ldrb	r3, [r3, #0]
 8018cee:	2b02      	cmp	r3, #2
 8018cf0:	d10f      	bne.n	8018d12 <lcp_rejci+0x252>
 8018cf2:	68bb      	ldr	r3, [r7, #8]
 8018cf4:	781b      	ldrb	r3, [r3, #0]
 8018cf6:	2b07      	cmp	r3, #7
 8018cf8:	d10b      	bne.n	8018d12 <lcp_rejci+0x252>
 8018cfa:	687b      	ldr	r3, [r7, #4]
 8018cfc:	3b02      	subs	r3, #2
 8018cfe:	607b      	str	r3, [r7, #4]
 8018d00:	68bb      	ldr	r3, [r7, #8]
 8018d02:	3302      	adds	r3, #2
 8018d04:	60bb      	str	r3, [r7, #8]
 8018d06:	2314      	movs	r3, #20
 8018d08:	18fb      	adds	r3, r7, r3
 8018d0a:	781a      	ldrb	r2, [r3, #0]
 8018d0c:	2120      	movs	r1, #32
 8018d0e:	438a      	bics	r2, r1
 8018d10:	701a      	strb	r2, [r3, #0]
    REJCIVOID(CI_ACCOMPRESSION, neg_accompression);
 8018d12:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018d14:	781b      	ldrb	r3, [r3, #0]
 8018d16:	2240      	movs	r2, #64	; 0x40
 8018d18:	4013      	ands	r3, r2
 8018d1a:	b2db      	uxtb	r3, r3
 8018d1c:	2b00      	cmp	r3, #0
 8018d1e:	d017      	beq.n	8018d50 <lcp_rejci+0x290>
 8018d20:	687b      	ldr	r3, [r7, #4]
 8018d22:	2b01      	cmp	r3, #1
 8018d24:	dd14      	ble.n	8018d50 <lcp_rejci+0x290>
 8018d26:	68bb      	ldr	r3, [r7, #8]
 8018d28:	3301      	adds	r3, #1
 8018d2a:	781b      	ldrb	r3, [r3, #0]
 8018d2c:	2b02      	cmp	r3, #2
 8018d2e:	d10f      	bne.n	8018d50 <lcp_rejci+0x290>
 8018d30:	68bb      	ldr	r3, [r7, #8]
 8018d32:	781b      	ldrb	r3, [r3, #0]
 8018d34:	2b08      	cmp	r3, #8
 8018d36:	d10b      	bne.n	8018d50 <lcp_rejci+0x290>
 8018d38:	687b      	ldr	r3, [r7, #4]
 8018d3a:	3b02      	subs	r3, #2
 8018d3c:	607b      	str	r3, [r7, #4]
 8018d3e:	68bb      	ldr	r3, [r7, #8]
 8018d40:	3302      	adds	r3, #2
 8018d42:	60bb      	str	r3, [r7, #8]
 8018d44:	2314      	movs	r3, #20
 8018d46:	18fb      	adds	r3, r7, r3
 8018d48:	781a      	ldrb	r2, [r3, #0]
 8018d4a:	2140      	movs	r1, #64	; 0x40
 8018d4c:	438a      	bics	r2, r1
 8018d4e:	701a      	strb	r2, [r3, #0]
#ifdef HAVE_MULTILINK
    REJCISHORT(CI_MRRU, neg_mrru, go->mrru);
#endif /* HAVE_MULTILINK */
    REJCIVOID(CI_SSNHF, neg_ssnhf);
 8018d50:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018d52:	785b      	ldrb	r3, [r3, #1]
 8018d54:	2201      	movs	r2, #1
 8018d56:	4013      	ands	r3, r2
 8018d58:	b2db      	uxtb	r3, r3
 8018d5a:	2b00      	cmp	r3, #0
 8018d5c:	d017      	beq.n	8018d8e <lcp_rejci+0x2ce>
 8018d5e:	687b      	ldr	r3, [r7, #4]
 8018d60:	2b01      	cmp	r3, #1
 8018d62:	dd14      	ble.n	8018d8e <lcp_rejci+0x2ce>
 8018d64:	68bb      	ldr	r3, [r7, #8]
 8018d66:	3301      	adds	r3, #1
 8018d68:	781b      	ldrb	r3, [r3, #0]
 8018d6a:	2b02      	cmp	r3, #2
 8018d6c:	d10f      	bne.n	8018d8e <lcp_rejci+0x2ce>
 8018d6e:	68bb      	ldr	r3, [r7, #8]
 8018d70:	781b      	ldrb	r3, [r3, #0]
 8018d72:	2b12      	cmp	r3, #18
 8018d74:	d10b      	bne.n	8018d8e <lcp_rejci+0x2ce>
 8018d76:	687b      	ldr	r3, [r7, #4]
 8018d78:	3b02      	subs	r3, #2
 8018d7a:	607b      	str	r3, [r7, #4]
 8018d7c:	68bb      	ldr	r3, [r7, #8]
 8018d7e:	3302      	adds	r3, #2
 8018d80:	60bb      	str	r3, [r7, #8]
 8018d82:	2314      	movs	r3, #20
 8018d84:	18fb      	adds	r3, r7, r3
 8018d86:	785a      	ldrb	r2, [r3, #1]
 8018d88:	2101      	movs	r1, #1
 8018d8a:	438a      	bics	r2, r1
 8018d8c:	705a      	strb	r2, [r3, #1]
    REJCIENDP(CI_EPDISC, neg_endpoint, go->endpoint.class_,
 8018d8e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018d90:	785b      	ldrb	r3, [r3, #1]
 8018d92:	2202      	movs	r2, #2
 8018d94:	4013      	ands	r3, r2
 8018d96:	b2db      	uxtb	r3, r3
 8018d98:	2b00      	cmp	r3, #0
 8018d9a:	d04a      	beq.n	8018e32 <lcp_rejci+0x372>
 8018d9c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018d9e:	7b9b      	ldrb	r3, [r3, #14]
 8018da0:	3302      	adds	r3, #2
 8018da2:	687a      	ldr	r2, [r7, #4]
 8018da4:	429a      	cmp	r2, r3
 8018da6:	dd44      	ble.n	8018e32 <lcp_rejci+0x372>
 8018da8:	68bb      	ldr	r3, [r7, #8]
 8018daa:	781b      	ldrb	r3, [r3, #0]
 8018dac:	2b13      	cmp	r3, #19
 8018dae:	d140      	bne.n	8018e32 <lcp_rejci+0x372>
 8018db0:	68bb      	ldr	r3, [r7, #8]
 8018db2:	3301      	adds	r3, #1
 8018db4:	781b      	ldrb	r3, [r3, #0]
 8018db6:	001a      	movs	r2, r3
 8018db8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018dba:	7b9b      	ldrb	r3, [r3, #14]
 8018dbc:	3303      	adds	r3, #3
 8018dbe:	429a      	cmp	r2, r3
 8018dc0:	d137      	bne.n	8018e32 <lcp_rejci+0x372>
 8018dc2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018dc4:	7b9b      	ldrb	r3, [r3, #14]
 8018dc6:	3303      	adds	r3, #3
 8018dc8:	687a      	ldr	r2, [r7, #4]
 8018dca:	1ad3      	subs	r3, r2, r3
 8018dcc:	607b      	str	r3, [r7, #4]
 8018dce:	68bb      	ldr	r3, [r7, #8]
 8018dd0:	3302      	adds	r3, #2
 8018dd2:	60bb      	str	r3, [r7, #8]
 8018dd4:	68bb      	ldr	r3, [r7, #8]
 8018dd6:	1c5a      	adds	r2, r3, #1
 8018dd8:	60ba      	str	r2, [r7, #8]
 8018dda:	213b      	movs	r1, #59	; 0x3b
 8018ddc:	187a      	adds	r2, r7, r1
 8018dde:	781b      	ldrb	r3, [r3, #0]
 8018de0:	7013      	strb	r3, [r2, #0]
 8018de2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018de4:	7b5b      	ldrb	r3, [r3, #13]
 8018de6:	187a      	adds	r2, r7, r1
 8018de8:	7812      	ldrb	r2, [r2, #0]
 8018dea:	429a      	cmp	r2, r3
 8018dec:	d13b      	bne.n	8018e66 <lcp_rejci+0x3a6>
 8018dee:	2300      	movs	r3, #0
 8018df0:	64fb      	str	r3, [r7, #76]	; 0x4c
 8018df2:	e012      	b.n	8018e1a <lcp_rejci+0x35a>
 8018df4:	68bb      	ldr	r3, [r7, #8]
 8018df6:	1c5a      	adds	r2, r3, #1
 8018df8:	60ba      	str	r2, [r7, #8]
 8018dfa:	213b      	movs	r1, #59	; 0x3b
 8018dfc:	187a      	adds	r2, r7, r1
 8018dfe:	781b      	ldrb	r3, [r3, #0]
 8018e00:	7013      	strb	r3, [r2, #0]
 8018e02:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8018e04:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8018e06:	18d3      	adds	r3, r2, r3
 8018e08:	330f      	adds	r3, #15
 8018e0a:	781b      	ldrb	r3, [r3, #0]
 8018e0c:	187a      	adds	r2, r7, r1
 8018e0e:	7812      	ldrb	r2, [r2, #0]
 8018e10:	429a      	cmp	r2, r3
 8018e12:	d12a      	bne.n	8018e6a <lcp_rejci+0x3aa>
 8018e14:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8018e16:	3301      	adds	r3, #1
 8018e18:	64fb      	str	r3, [r7, #76]	; 0x4c
 8018e1a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018e1c:	7b9b      	ldrb	r3, [r3, #14]
 8018e1e:	001a      	movs	r2, r3
 8018e20:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8018e22:	4293      	cmp	r3, r2
 8018e24:	dbe6      	blt.n	8018df4 <lcp_rejci+0x334>
 8018e26:	2314      	movs	r3, #20
 8018e28:	18fb      	adds	r3, r7, r3
 8018e2a:	785a      	ldrb	r2, [r3, #1]
 8018e2c:	2102      	movs	r1, #2
 8018e2e:	438a      	bics	r2, r1
 8018e30:	705a      	strb	r2, [r3, #1]
	      go->endpoint.value, go->endpoint.length);

    /*
     * If there are any remaining CIs, then this packet is bad.
     */
    if (len != 0)
 8018e32:	687b      	ldr	r3, [r7, #4]
 8018e34:	2b00      	cmp	r3, #0
 8018e36:	d11a      	bne.n	8018e6e <lcp_rejci+0x3ae>
	goto bad;
    /*
     * Now we can update state.
     */
    if (f->state != PPP_FSM_OPENED)
 8018e38:	68fb      	ldr	r3, [r7, #12]
 8018e3a:	7c1b      	ldrb	r3, [r3, #16]
 8018e3c:	2b09      	cmp	r3, #9
 8018e3e:	d008      	beq.n	8018e52 <lcp_rejci+0x392>
	*go = try_;
 8018e40:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018e42:	2214      	movs	r2, #20
 8018e44:	18ba      	adds	r2, r7, r2
 8018e46:	ca13      	ldmia	r2!, {r0, r1, r4}
 8018e48:	c313      	stmia	r3!, {r0, r1, r4}
 8018e4a:	ca13      	ldmia	r2!, {r0, r1, r4}
 8018e4c:	c313      	stmia	r3!, {r0, r1, r4}
 8018e4e:	ca13      	ldmia	r2!, {r0, r1, r4}
 8018e50:	c313      	stmia	r3!, {r0, r1, r4}
    return 1;
 8018e52:	2301      	movs	r3, #1
 8018e54:	e00d      	b.n	8018e72 <lcp_rejci+0x3b2>
    REJCISHORT(CI_MRU, neg_mru, go->mru);
 8018e56:	46c0      	nop			; (mov r8, r8)
 8018e58:	e00a      	b.n	8018e70 <lcp_rejci+0x3b0>
    REJCILONG(CI_ASYNCMAP, neg_asyncmap, go->asyncmap);
 8018e5a:	46c0      	nop			; (mov r8, r8)
 8018e5c:	e008      	b.n	8018e70 <lcp_rejci+0x3b0>
    REJCICBCP(CI_CALLBACK, neg_cbcp, CBCP_OPT);
 8018e5e:	46c0      	nop			; (mov r8, r8)
 8018e60:	e006      	b.n	8018e70 <lcp_rejci+0x3b0>
    REJCILONG(CI_MAGICNUMBER, neg_magicnumber, go->magicnumber);
 8018e62:	46c0      	nop			; (mov r8, r8)
 8018e64:	e004      	b.n	8018e70 <lcp_rejci+0x3b0>
    REJCIENDP(CI_EPDISC, neg_endpoint, go->endpoint.class_,
 8018e66:	46c0      	nop			; (mov r8, r8)
 8018e68:	e002      	b.n	8018e70 <lcp_rejci+0x3b0>
 8018e6a:	46c0      	nop			; (mov r8, r8)
 8018e6c:	e000      	b.n	8018e70 <lcp_rejci+0x3b0>
	goto bad;
 8018e6e:	46c0      	nop			; (mov r8, r8)

bad:
    LCPDEBUG(("lcp_rejci: received bad Reject!"));
    return 0;
 8018e70:	2300      	movs	r3, #0
}
 8018e72:	0018      	movs	r0, r3
 8018e74:	46bd      	mov	sp, r7
 8018e76:	b014      	add	sp, #80	; 0x50
 8018e78:	bdb0      	pop	{r4, r5, r7, pc}
	...

08018e7c <lcp_reqci>:
 * CONFNAK; returns CONFREJ if it can't return CONFACK.
 *
 * inp = Requested CIs
 * lenp = Length of requested CIs
 */
static int lcp_reqci(fsm *f, u_char *inp, int *lenp, int reject_if_disagree) {
 8018e7c:	b580      	push	{r7, lr}
 8018e7e:	b096      	sub	sp, #88	; 0x58
 8018e80:	af00      	add	r7, sp, #0
 8018e82:	60f8      	str	r0, [r7, #12]
 8018e84:	60b9      	str	r1, [r7, #8]
 8018e86:	607a      	str	r2, [r7, #4]
 8018e88:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 8018e8a:	68fb      	ldr	r3, [r7, #12]
 8018e8c:	681b      	ldr	r3, [r3, #0]
 8018e8e:	637b      	str	r3, [r7, #52]	; 0x34
    lcp_options *go = &pcb->lcp_gotoptions;
 8018e90:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8018e92:	3368      	adds	r3, #104	; 0x68
 8018e94:	633b      	str	r3, [r7, #48]	; 0x30
    lcp_options *ho = &pcb->lcp_hisoptions;
 8018e96:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8018e98:	33b0      	adds	r3, #176	; 0xb0
 8018e9a:	62fb      	str	r3, [r7, #44]	; 0x2c
    lcp_options *ao = &pcb->lcp_allowoptions;
 8018e9c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8018e9e:	338c      	adds	r3, #140	; 0x8c
 8018ea0:	62bb      	str	r3, [r7, #40]	; 0x28
    u_char *cip, *next;		/* Pointer to current and next CIs */
    int cilen, citype, cichar;	/* Parsed len, type, char value */
    u_short cishort;		/* Parsed short value */
    u32_t cilong;		/* Parse long value */
    int rc = CONFACK;		/* Final packet return code */
 8018ea2:	2302      	movs	r3, #2
 8018ea4:	64bb      	str	r3, [r7, #72]	; 0x48
    int orc;			/* Individual option return code */
    u_char *p;			/* Pointer to next char to parse */
    u_char *rejp;		/* Pointer to next char in reject frame */
    struct pbuf *nakp;          /* Nak buffer */
    u_char *nakoutp;		/* Pointer to next char in Nak frame */
    int l = *lenp;		/* Length left */
 8018ea6:	687b      	ldr	r3, [r7, #4]
 8018ea8:	681b      	ldr	r3, [r3, #0]
 8018eaa:	63bb      	str	r3, [r7, #56]	; 0x38

    /*
     * Reset all his options.
     */
    BZERO(ho, sizeof(*ho));
 8018eac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8018eae:	2224      	movs	r2, #36	; 0x24
 8018eb0:	2100      	movs	r1, #0
 8018eb2:	0018      	movs	r0, r3
 8018eb4:	f003 feb0 	bl	801cc18 <memset>

    /*
     * Process all his options.
     */
    next = inp;
 8018eb8:	68bb      	ldr	r3, [r7, #8]
 8018eba:	657b      	str	r3, [r7, #84]	; 0x54
    nakp = pbuf_alloc(PBUF_RAW, (u16_t)(PPP_CTRL_PBUF_MAX_SIZE), PPP_CTRL_PBUF_TYPE);
 8018ebc:	23c1      	movs	r3, #193	; 0xc1
 8018ebe:	005a      	lsls	r2, r3, #1
 8018ec0:	2394      	movs	r3, #148	; 0x94
 8018ec2:	009b      	lsls	r3, r3, #2
 8018ec4:	0019      	movs	r1, r3
 8018ec6:	2000      	movs	r0, #0
 8018ec8:	f7f0 fb0a 	bl	80094e0 <pbuf_alloc>
 8018ecc:	0003      	movs	r3, r0
 8018ece:	627b      	str	r3, [r7, #36]	; 0x24
    if(NULL == nakp)
 8018ed0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018ed2:	2b00      	cmp	r3, #0
 8018ed4:	d101      	bne.n	8018eda <lcp_reqci+0x5e>
        return 0;
 8018ed6:	2300      	movs	r3, #0
 8018ed8:	e258      	b.n	801938c <lcp_reqci+0x510>
    if(nakp->tot_len != nakp->len) {
 8018eda:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018edc:	891a      	ldrh	r2, [r3, #8]
 8018ede:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018ee0:	895b      	ldrh	r3, [r3, #10]
 8018ee2:	429a      	cmp	r2, r3
 8018ee4:	d005      	beq.n	8018ef2 <lcp_reqci+0x76>
        pbuf_free(nakp);
 8018ee6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018ee8:	0018      	movs	r0, r3
 8018eea:	f7f0 fe71 	bl	8009bd0 <pbuf_free>
        return 0;
 8018eee:	2300      	movs	r3, #0
 8018ef0:	e24c      	b.n	801938c <lcp_reqci+0x510>
    }

    nakoutp = (u_char*)nakp->payload;
 8018ef2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018ef4:	685b      	ldr	r3, [r3, #4]
 8018ef6:	63fb      	str	r3, [r7, #60]	; 0x3c
    rejp = inp;
 8018ef8:	68bb      	ldr	r3, [r7, #8]
 8018efa:	643b      	str	r3, [r7, #64]	; 0x40
    while (l) {
 8018efc:	e213      	b.n	8019326 <lcp_reqci+0x4aa>
	orc = CONFACK;			/* Assume success */
 8018efe:	2302      	movs	r3, #2
 8018f00:	647b      	str	r3, [r7, #68]	; 0x44
	cip = p = next;			/* Remember begining of CI */
 8018f02:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8018f04:	623b      	str	r3, [r7, #32]
 8018f06:	6a3b      	ldr	r3, [r7, #32]
 8018f08:	61fb      	str	r3, [r7, #28]
	if (l < 2 ||			/* Not enough data for CI header or */
 8018f0a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8018f0c:	2b01      	cmp	r3, #1
 8018f0e:	dd0b      	ble.n	8018f28 <lcp_reqci+0xac>
	    p[1] < 2 ||			/*  CI length too small or */
 8018f10:	6a3b      	ldr	r3, [r7, #32]
 8018f12:	3301      	adds	r3, #1
 8018f14:	781b      	ldrb	r3, [r3, #0]
	if (l < 2 ||			/* Not enough data for CI header or */
 8018f16:	2b01      	cmp	r3, #1
 8018f18:	d906      	bls.n	8018f28 <lcp_reqci+0xac>
	    p[1] > l) {			/*  CI length too big? */
 8018f1a:	6a3b      	ldr	r3, [r7, #32]
 8018f1c:	3301      	adds	r3, #1
 8018f1e:	781b      	ldrb	r3, [r3, #0]
 8018f20:	001a      	movs	r2, r3
	    p[1] < 2 ||			/*  CI length too small or */
 8018f22:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8018f24:	4293      	cmp	r3, r2
 8018f26:	da08      	bge.n	8018f3a <lcp_reqci+0xbe>
	    LCPDEBUG(("lcp_reqci: bad CI length!"));
	    orc = CONFREJ;		/* Reject bad CI */
 8018f28:	2304      	movs	r3, #4
 8018f2a:	647b      	str	r3, [r7, #68]	; 0x44
	    cilen = l;			/* Reject till end of packet */
 8018f2c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8018f2e:	653b      	str	r3, [r7, #80]	; 0x50
	    l = 0;			/* Don't loop again */
 8018f30:	2300      	movs	r3, #0
 8018f32:	63bb      	str	r3, [r7, #56]	; 0x38
	    citype = 0;
 8018f34:	2300      	movs	r3, #0
 8018f36:	64fb      	str	r3, [r7, #76]	; 0x4c
	    goto endswitch;
 8018f38:	e1c4      	b.n	80192c4 <lcp_reqci+0x448>
	}
	GETCHAR(citype, p);		/* Parse CI type */
 8018f3a:	6a3b      	ldr	r3, [r7, #32]
 8018f3c:	1c5a      	adds	r2, r3, #1
 8018f3e:	623a      	str	r2, [r7, #32]
 8018f40:	781b      	ldrb	r3, [r3, #0]
 8018f42:	64fb      	str	r3, [r7, #76]	; 0x4c
	GETCHAR(cilen, p);		/* Parse CI length */
 8018f44:	6a3b      	ldr	r3, [r7, #32]
 8018f46:	1c5a      	adds	r2, r3, #1
 8018f48:	623a      	str	r2, [r7, #32]
 8018f4a:	781b      	ldrb	r3, [r3, #0]
 8018f4c:	653b      	str	r3, [r7, #80]	; 0x50
	l -= cilen;			/* Adjust remaining length */
 8018f4e:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8018f50:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8018f52:	1ad3      	subs	r3, r2, r3
 8018f54:	63bb      	str	r3, [r7, #56]	; 0x38
	next += cilen;			/* Step to next CI */
 8018f56:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8018f58:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8018f5a:	18d3      	adds	r3, r2, r3
 8018f5c:	657b      	str	r3, [r7, #84]	; 0x54
 8018f5e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8018f60:	2b13      	cmp	r3, #19
 8018f62:	d900      	bls.n	8018f66 <lcp_reqci+0xea>
 8018f64:	e1ab      	b.n	80192be <lcp_reqci+0x442>
 8018f66:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8018f68:	009a      	lsls	r2, r3, #2
 8018f6a:	4bda      	ldr	r3, [pc, #872]	; (80192d4 <lcp_reqci+0x458>)
 8018f6c:	18d3      	adds	r3, r2, r3
 8018f6e:	681b      	ldr	r3, [r3, #0]
 8018f70:	469f      	mov	pc, r3

	switch (citype) {		/* Check CI type */
	case CI_MRU:
	    if (!ao->neg_mru ||		/* Allow option? */
 8018f72:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018f74:	781b      	ldrb	r3, [r3, #0]
 8018f76:	2204      	movs	r2, #4
 8018f78:	4013      	ands	r3, r2
 8018f7a:	b2db      	uxtb	r3, r3
 8018f7c:	2b00      	cmp	r3, #0
 8018f7e:	d002      	beq.n	8018f86 <lcp_reqci+0x10a>
 8018f80:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8018f82:	2b04      	cmp	r3, #4
 8018f84:	d002      	beq.n	8018f8c <lcp_reqci+0x110>
		cilen != CILEN_SHORT) {	/* Check CI length */
		orc = CONFREJ;		/* Reject CI */
 8018f86:	2304      	movs	r3, #4
 8018f88:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 8018f8a:	e19b      	b.n	80192c4 <lcp_reqci+0x448>
	    }
	    GETSHORT(cishort, p);	/* Parse MRU */
 8018f8c:	6a3b      	ldr	r3, [r7, #32]
 8018f8e:	1c5a      	adds	r2, r3, #1
 8018f90:	623a      	str	r2, [r7, #32]
 8018f92:	781b      	ldrb	r3, [r3, #0]
 8018f94:	b29a      	uxth	r2, r3
 8018f96:	2012      	movs	r0, #18
 8018f98:	183b      	adds	r3, r7, r0
 8018f9a:	0212      	lsls	r2, r2, #8
 8018f9c:	801a      	strh	r2, [r3, #0]
 8018f9e:	6a3b      	ldr	r3, [r7, #32]
 8018fa0:	1c5a      	adds	r2, r3, #1
 8018fa2:	623a      	str	r2, [r7, #32]
 8018fa4:	781b      	ldrb	r3, [r3, #0]
 8018fa6:	b299      	uxth	r1, r3
 8018fa8:	183b      	adds	r3, r7, r0
 8018faa:	183a      	adds	r2, r7, r0
 8018fac:	8812      	ldrh	r2, [r2, #0]
 8018fae:	430a      	orrs	r2, r1
 8018fb0:	801a      	strh	r2, [r3, #0]
	    /*
	     * He must be able to receive at least our minimum.
	     * No need to check a maximum.  If he sends a large number,
	     * we'll just ignore it.
	     */
	    if (cishort < PPP_MINMRU) {
 8018fb2:	183b      	adds	r3, r7, r0
 8018fb4:	881b      	ldrh	r3, [r3, #0]
 8018fb6:	2b7f      	cmp	r3, #127	; 0x7f
 8018fb8:	d816      	bhi.n	8018fe8 <lcp_reqci+0x16c>
		orc = CONFNAK;		/* Nak CI */
 8018fba:	2303      	movs	r3, #3
 8018fbc:	647b      	str	r3, [r7, #68]	; 0x44
		PUTCHAR(CI_MRU, nakoutp);
 8018fbe:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018fc0:	1c5a      	adds	r2, r3, #1
 8018fc2:	63fa      	str	r2, [r7, #60]	; 0x3c
 8018fc4:	2201      	movs	r2, #1
 8018fc6:	701a      	strb	r2, [r3, #0]
		PUTCHAR(CILEN_SHORT, nakoutp);
 8018fc8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018fca:	1c5a      	adds	r2, r3, #1
 8018fcc:	63fa      	str	r2, [r7, #60]	; 0x3c
 8018fce:	2204      	movs	r2, #4
 8018fd0:	701a      	strb	r2, [r3, #0]
		PUTSHORT(PPP_MINMRU, nakoutp);	/* Give him a hint */
 8018fd2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018fd4:	1c5a      	adds	r2, r3, #1
 8018fd6:	63fa      	str	r2, [r7, #60]	; 0x3c
 8018fd8:	2200      	movs	r2, #0
 8018fda:	701a      	strb	r2, [r3, #0]
 8018fdc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018fde:	1c5a      	adds	r2, r3, #1
 8018fe0:	63fa      	str	r2, [r7, #60]	; 0x3c
 8018fe2:	2280      	movs	r2, #128	; 0x80
 8018fe4:	701a      	strb	r2, [r3, #0]
		break;
 8018fe6:	e16d      	b.n	80192c4 <lcp_reqci+0x448>
	    }
	    ho->neg_mru = 1;		/* Remember he sent MRU */
 8018fe8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8018fea:	781a      	ldrb	r2, [r3, #0]
 8018fec:	2104      	movs	r1, #4
 8018fee:	430a      	orrs	r2, r1
 8018ff0:	701a      	strb	r2, [r3, #0]
	    ho->mru = cishort;		/* And remember value */
 8018ff2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8018ff4:	2212      	movs	r2, #18
 8018ff6:	18ba      	adds	r2, r7, r2
 8018ff8:	8812      	ldrh	r2, [r2, #0]
 8018ffa:	805a      	strh	r2, [r3, #2]
	    break;
 8018ffc:	e162      	b.n	80192c4 <lcp_reqci+0x448>

	case CI_ASYNCMAP:
	    if (!ao->neg_asyncmap ||
 8018ffe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019000:	781b      	ldrb	r3, [r3, #0]
 8019002:	2208      	movs	r2, #8
 8019004:	4013      	ands	r3, r2
 8019006:	b2db      	uxtb	r3, r3
 8019008:	2b00      	cmp	r3, #0
 801900a:	d002      	beq.n	8019012 <lcp_reqci+0x196>
 801900c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801900e:	2b06      	cmp	r3, #6
 8019010:	d002      	beq.n	8019018 <lcp_reqci+0x19c>
		cilen != CILEN_LONG) {
		orc = CONFREJ;
 8019012:	2304      	movs	r3, #4
 8019014:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 8019016:	e155      	b.n	80192c4 <lcp_reqci+0x448>
	    }
	    GETLONG(cilong, p);
 8019018:	6a3b      	ldr	r3, [r7, #32]
 801901a:	1c5a      	adds	r2, r3, #1
 801901c:	623a      	str	r2, [r7, #32]
 801901e:	781b      	ldrb	r3, [r3, #0]
 8019020:	021b      	lsls	r3, r3, #8
 8019022:	617b      	str	r3, [r7, #20]
 8019024:	6a3b      	ldr	r3, [r7, #32]
 8019026:	1c5a      	adds	r2, r3, #1
 8019028:	623a      	str	r2, [r7, #32]
 801902a:	781b      	ldrb	r3, [r3, #0]
 801902c:	001a      	movs	r2, r3
 801902e:	697b      	ldr	r3, [r7, #20]
 8019030:	4313      	orrs	r3, r2
 8019032:	617b      	str	r3, [r7, #20]
 8019034:	697b      	ldr	r3, [r7, #20]
 8019036:	021b      	lsls	r3, r3, #8
 8019038:	617b      	str	r3, [r7, #20]
 801903a:	6a3b      	ldr	r3, [r7, #32]
 801903c:	1c5a      	adds	r2, r3, #1
 801903e:	623a      	str	r2, [r7, #32]
 8019040:	781b      	ldrb	r3, [r3, #0]
 8019042:	001a      	movs	r2, r3
 8019044:	697b      	ldr	r3, [r7, #20]
 8019046:	4313      	orrs	r3, r2
 8019048:	617b      	str	r3, [r7, #20]
 801904a:	697b      	ldr	r3, [r7, #20]
 801904c:	021b      	lsls	r3, r3, #8
 801904e:	617b      	str	r3, [r7, #20]
 8019050:	6a3b      	ldr	r3, [r7, #32]
 8019052:	1c5a      	adds	r2, r3, #1
 8019054:	623a      	str	r2, [r7, #32]
 8019056:	781b      	ldrb	r3, [r3, #0]
 8019058:	001a      	movs	r2, r3
 801905a:	697b      	ldr	r3, [r7, #20]
 801905c:	4313      	orrs	r3, r2
 801905e:	617b      	str	r3, [r7, #20]

	    /*
	     * Asyncmap must have set at least the bits
	     * which are set in lcp_allowoptions[unit].asyncmap.
	     */
	    if ((ao->asyncmap & ~cilong) != 0) {
 8019060:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019062:	685b      	ldr	r3, [r3, #4]
 8019064:	697a      	ldr	r2, [r7, #20]
 8019066:	43d2      	mvns	r2, r2
 8019068:	4013      	ands	r3, r2
 801906a:	d035      	beq.n	80190d8 <lcp_reqci+0x25c>
		orc = CONFNAK;
 801906c:	2303      	movs	r3, #3
 801906e:	647b      	str	r3, [r7, #68]	; 0x44
		PUTCHAR(CI_ASYNCMAP, nakoutp);
 8019070:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8019072:	1c5a      	adds	r2, r3, #1
 8019074:	63fa      	str	r2, [r7, #60]	; 0x3c
 8019076:	2202      	movs	r2, #2
 8019078:	701a      	strb	r2, [r3, #0]
		PUTCHAR(CILEN_LONG, nakoutp);
 801907a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801907c:	1c5a      	adds	r2, r3, #1
 801907e:	63fa      	str	r2, [r7, #60]	; 0x3c
 8019080:	2206      	movs	r2, #6
 8019082:	701a      	strb	r2, [r3, #0]
		PUTLONG(ao->asyncmap | cilong, nakoutp);
 8019084:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019086:	685a      	ldr	r2, [r3, #4]
 8019088:	697b      	ldr	r3, [r7, #20]
 801908a:	4313      	orrs	r3, r2
 801908c:	0e19      	lsrs	r1, r3, #24
 801908e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8019090:	1c5a      	adds	r2, r3, #1
 8019092:	63fa      	str	r2, [r7, #60]	; 0x3c
 8019094:	b2ca      	uxtb	r2, r1
 8019096:	701a      	strb	r2, [r3, #0]
 8019098:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801909a:	685a      	ldr	r2, [r3, #4]
 801909c:	697b      	ldr	r3, [r7, #20]
 801909e:	4313      	orrs	r3, r2
 80190a0:	0c19      	lsrs	r1, r3, #16
 80190a2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80190a4:	1c5a      	adds	r2, r3, #1
 80190a6:	63fa      	str	r2, [r7, #60]	; 0x3c
 80190a8:	b2ca      	uxtb	r2, r1
 80190aa:	701a      	strb	r2, [r3, #0]
 80190ac:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80190ae:	685a      	ldr	r2, [r3, #4]
 80190b0:	697b      	ldr	r3, [r7, #20]
 80190b2:	4313      	orrs	r3, r2
 80190b4:	0a19      	lsrs	r1, r3, #8
 80190b6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80190b8:	1c5a      	adds	r2, r3, #1
 80190ba:	63fa      	str	r2, [r7, #60]	; 0x3c
 80190bc:	b2ca      	uxtb	r2, r1
 80190be:	701a      	strb	r2, [r3, #0]
 80190c0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80190c2:	685b      	ldr	r3, [r3, #4]
 80190c4:	b2d9      	uxtb	r1, r3
 80190c6:	697b      	ldr	r3, [r7, #20]
 80190c8:	b2da      	uxtb	r2, r3
 80190ca:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80190cc:	1c58      	adds	r0, r3, #1
 80190ce:	63f8      	str	r0, [r7, #60]	; 0x3c
 80190d0:	430a      	orrs	r2, r1
 80190d2:	b2d2      	uxtb	r2, r2
 80190d4:	701a      	strb	r2, [r3, #0]
		break;
 80190d6:	e0f5      	b.n	80192c4 <lcp_reqci+0x448>
	    }
	    ho->neg_asyncmap = 1;
 80190d8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80190da:	781a      	ldrb	r2, [r3, #0]
 80190dc:	2108      	movs	r1, #8
 80190de:	430a      	orrs	r2, r1
 80190e0:	701a      	strb	r2, [r3, #0]
	    ho->asyncmap = cilong;
 80190e2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80190e4:	697a      	ldr	r2, [r7, #20]
 80190e6:	605a      	str	r2, [r3, #4]
	    break;
 80190e8:	e0ec      	b.n	80192c4 <lcp_reqci+0x448>
#endif /* EAP_SUPPORT */
		)) {
		/*
		 * Reject the option if we're not willing to authenticate.
		 */
		ppp_dbglog("No auth is possible");
 80190ea:	4b7b      	ldr	r3, [pc, #492]	; (80192d8 <lcp_reqci+0x45c>)
 80190ec:	0018      	movs	r0, r3
 80190ee:	f002 fa68 	bl	801b5c2 <ppp_dbglog>
		orc = CONFREJ;
 80190f2:	2304      	movs	r3, #4
 80190f4:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 80190f6:	e0e5      	b.n	80192c4 <lcp_reqci+0x448>
	    }
	    break;
#endif /* LQR_SUPPORT */

	case CI_MAGICNUMBER:
	    if (!(ao->neg_magicnumber || go->neg_magicnumber) ||
 80190f8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80190fa:	781b      	ldrb	r3, [r3, #0]
 80190fc:	2210      	movs	r2, #16
 80190fe:	4013      	ands	r3, r2
 8019100:	b2db      	uxtb	r3, r3
 8019102:	2b00      	cmp	r3, #0
 8019104:	d106      	bne.n	8019114 <lcp_reqci+0x298>
 8019106:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019108:	781b      	ldrb	r3, [r3, #0]
 801910a:	2210      	movs	r2, #16
 801910c:	4013      	ands	r3, r2
 801910e:	b2db      	uxtb	r3, r3
 8019110:	2b00      	cmp	r3, #0
 8019112:	d002      	beq.n	801911a <lcp_reqci+0x29e>
 8019114:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019116:	2b06      	cmp	r3, #6
 8019118:	d002      	beq.n	8019120 <lcp_reqci+0x2a4>
		cilen != CILEN_LONG) {
		orc = CONFREJ;
 801911a:	2304      	movs	r3, #4
 801911c:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 801911e:	e0d1      	b.n	80192c4 <lcp_reqci+0x448>
	    }
	    GETLONG(cilong, p);
 8019120:	6a3b      	ldr	r3, [r7, #32]
 8019122:	1c5a      	adds	r2, r3, #1
 8019124:	623a      	str	r2, [r7, #32]
 8019126:	781b      	ldrb	r3, [r3, #0]
 8019128:	021b      	lsls	r3, r3, #8
 801912a:	617b      	str	r3, [r7, #20]
 801912c:	6a3b      	ldr	r3, [r7, #32]
 801912e:	1c5a      	adds	r2, r3, #1
 8019130:	623a      	str	r2, [r7, #32]
 8019132:	781b      	ldrb	r3, [r3, #0]
 8019134:	001a      	movs	r2, r3
 8019136:	697b      	ldr	r3, [r7, #20]
 8019138:	4313      	orrs	r3, r2
 801913a:	617b      	str	r3, [r7, #20]
 801913c:	697b      	ldr	r3, [r7, #20]
 801913e:	021b      	lsls	r3, r3, #8
 8019140:	617b      	str	r3, [r7, #20]
 8019142:	6a3b      	ldr	r3, [r7, #32]
 8019144:	1c5a      	adds	r2, r3, #1
 8019146:	623a      	str	r2, [r7, #32]
 8019148:	781b      	ldrb	r3, [r3, #0]
 801914a:	001a      	movs	r2, r3
 801914c:	697b      	ldr	r3, [r7, #20]
 801914e:	4313      	orrs	r3, r2
 8019150:	617b      	str	r3, [r7, #20]
 8019152:	697b      	ldr	r3, [r7, #20]
 8019154:	021b      	lsls	r3, r3, #8
 8019156:	617b      	str	r3, [r7, #20]
 8019158:	6a3b      	ldr	r3, [r7, #32]
 801915a:	1c5a      	adds	r2, r3, #1
 801915c:	623a      	str	r2, [r7, #32]
 801915e:	781b      	ldrb	r3, [r3, #0]
 8019160:	001a      	movs	r2, r3
 8019162:	697b      	ldr	r3, [r7, #20]
 8019164:	4313      	orrs	r3, r2
 8019166:	617b      	str	r3, [r7, #20]

	    /*
	     * He must have a different magic number.
	     */
	    if (go->neg_magicnumber &&
 8019168:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801916a:	781b      	ldrb	r3, [r3, #0]
 801916c:	2210      	movs	r2, #16
 801916e:	4013      	ands	r3, r2
 8019170:	b2db      	uxtb	r3, r3
 8019172:	2b00      	cmp	r3, #0
 8019174:	d030      	beq.n	80191d8 <lcp_reqci+0x35c>
		cilong == go->magicnumber) {
 8019176:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019178:	689b      	ldr	r3, [r3, #8]
	    if (go->neg_magicnumber &&
 801917a:	697a      	ldr	r2, [r7, #20]
 801917c:	429a      	cmp	r2, r3
 801917e:	d12b      	bne.n	80191d8 <lcp_reqci+0x35c>
		cilong = magic();	/* Don't put magic() inside macro! */
 8019180:	f000 fbba 	bl	80198f8 <magic>
 8019184:	0003      	movs	r3, r0
 8019186:	617b      	str	r3, [r7, #20]
		orc = CONFNAK;
 8019188:	2303      	movs	r3, #3
 801918a:	647b      	str	r3, [r7, #68]	; 0x44
		PUTCHAR(CI_MAGICNUMBER, nakoutp);
 801918c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801918e:	1c5a      	adds	r2, r3, #1
 8019190:	63fa      	str	r2, [r7, #60]	; 0x3c
 8019192:	2205      	movs	r2, #5
 8019194:	701a      	strb	r2, [r3, #0]
		PUTCHAR(CILEN_LONG, nakoutp);
 8019196:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8019198:	1c5a      	adds	r2, r3, #1
 801919a:	63fa      	str	r2, [r7, #60]	; 0x3c
 801919c:	2206      	movs	r2, #6
 801919e:	701a      	strb	r2, [r3, #0]
		PUTLONG(cilong, nakoutp);
 80191a0:	697b      	ldr	r3, [r7, #20]
 80191a2:	0e19      	lsrs	r1, r3, #24
 80191a4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80191a6:	1c5a      	adds	r2, r3, #1
 80191a8:	63fa      	str	r2, [r7, #60]	; 0x3c
 80191aa:	b2ca      	uxtb	r2, r1
 80191ac:	701a      	strb	r2, [r3, #0]
 80191ae:	697b      	ldr	r3, [r7, #20]
 80191b0:	0c19      	lsrs	r1, r3, #16
 80191b2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80191b4:	1c5a      	adds	r2, r3, #1
 80191b6:	63fa      	str	r2, [r7, #60]	; 0x3c
 80191b8:	b2ca      	uxtb	r2, r1
 80191ba:	701a      	strb	r2, [r3, #0]
 80191bc:	697b      	ldr	r3, [r7, #20]
 80191be:	0a19      	lsrs	r1, r3, #8
 80191c0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80191c2:	1c5a      	adds	r2, r3, #1
 80191c4:	63fa      	str	r2, [r7, #60]	; 0x3c
 80191c6:	b2ca      	uxtb	r2, r1
 80191c8:	701a      	strb	r2, [r3, #0]
 80191ca:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80191cc:	1c5a      	adds	r2, r3, #1
 80191ce:	63fa      	str	r2, [r7, #60]	; 0x3c
 80191d0:	697a      	ldr	r2, [r7, #20]
 80191d2:	b2d2      	uxtb	r2, r2
 80191d4:	701a      	strb	r2, [r3, #0]
		break;
 80191d6:	e075      	b.n	80192c4 <lcp_reqci+0x448>
	    }
	    ho->neg_magicnumber = 1;
 80191d8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80191da:	781a      	ldrb	r2, [r3, #0]
 80191dc:	2110      	movs	r1, #16
 80191de:	430a      	orrs	r2, r1
 80191e0:	701a      	strb	r2, [r3, #0]
	    ho->magicnumber = cilong;
 80191e2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80191e4:	697a      	ldr	r2, [r7, #20]
 80191e6:	609a      	str	r2, [r3, #8]
	    break;
 80191e8:	e06c      	b.n	80192c4 <lcp_reqci+0x448>


	case CI_PCOMPRESSION:
	    if (!ao->neg_pcompression ||
 80191ea:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80191ec:	781b      	ldrb	r3, [r3, #0]
 80191ee:	2220      	movs	r2, #32
 80191f0:	4013      	ands	r3, r2
 80191f2:	b2db      	uxtb	r3, r3
 80191f4:	2b00      	cmp	r3, #0
 80191f6:	d002      	beq.n	80191fe <lcp_reqci+0x382>
 80191f8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80191fa:	2b02      	cmp	r3, #2
 80191fc:	d002      	beq.n	8019204 <lcp_reqci+0x388>
		cilen != CILEN_VOID) {
		orc = CONFREJ;
 80191fe:	2304      	movs	r3, #4
 8019200:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 8019202:	e05f      	b.n	80192c4 <lcp_reqci+0x448>
	    }
	    ho->neg_pcompression = 1;
 8019204:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019206:	781a      	ldrb	r2, [r3, #0]
 8019208:	2120      	movs	r1, #32
 801920a:	430a      	orrs	r2, r1
 801920c:	701a      	strb	r2, [r3, #0]
	    break;
 801920e:	e059      	b.n	80192c4 <lcp_reqci+0x448>

	case CI_ACCOMPRESSION:
	    if (!ao->neg_accompression ||
 8019210:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019212:	781b      	ldrb	r3, [r3, #0]
 8019214:	2240      	movs	r2, #64	; 0x40
 8019216:	4013      	ands	r3, r2
 8019218:	b2db      	uxtb	r3, r3
 801921a:	2b00      	cmp	r3, #0
 801921c:	d002      	beq.n	8019224 <lcp_reqci+0x3a8>
 801921e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019220:	2b02      	cmp	r3, #2
 8019222:	d002      	beq.n	801922a <lcp_reqci+0x3ae>
		cilen != CILEN_VOID) {
		orc = CONFREJ;
 8019224:	2304      	movs	r3, #4
 8019226:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 8019228:	e04c      	b.n	80192c4 <lcp_reqci+0x448>
	    }
	    ho->neg_accompression = 1;
 801922a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801922c:	781a      	ldrb	r2, [r3, #0]
 801922e:	2140      	movs	r1, #64	; 0x40
 8019230:	430a      	orrs	r2, r1
 8019232:	701a      	strb	r2, [r3, #0]
	    break;
 8019234:	e046      	b.n	80192c4 <lcp_reqci+0x448>
	    ho->mrru = cishort;
	    break;
#endif /* HAVE_MULTILINK */

	case CI_SSNHF:
	    if (!ao->neg_ssnhf
 8019236:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019238:	785b      	ldrb	r3, [r3, #1]
 801923a:	2201      	movs	r2, #1
 801923c:	4013      	ands	r3, r2
 801923e:	b2db      	uxtb	r3, r3
 8019240:	2b00      	cmp	r3, #0
 8019242:	d002      	beq.n	801924a <lcp_reqci+0x3ce>
#ifdef HAVE_MULTILINK
		|| !multilink
#endif /* HAVE_MULTILINK */
		|| cilen != CILEN_VOID) {
 8019244:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019246:	2b02      	cmp	r3, #2
 8019248:	d002      	beq.n	8019250 <lcp_reqci+0x3d4>
		orc = CONFREJ;
 801924a:	2304      	movs	r3, #4
 801924c:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 801924e:	e039      	b.n	80192c4 <lcp_reqci+0x448>
	    }
	    ho->neg_ssnhf = 1;
 8019250:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019252:	785a      	ldrb	r2, [r3, #1]
 8019254:	2101      	movs	r1, #1
 8019256:	430a      	orrs	r2, r1
 8019258:	705a      	strb	r2, [r3, #1]
	    break;
 801925a:	e033      	b.n	80192c4 <lcp_reqci+0x448>

	case CI_EPDISC:
	    if (!ao->neg_endpoint ||
 801925c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801925e:	785b      	ldrb	r3, [r3, #1]
 8019260:	2202      	movs	r2, #2
 8019262:	4013      	ands	r3, r2
 8019264:	b2db      	uxtb	r3, r3
 8019266:	2b00      	cmp	r3, #0
 8019268:	d005      	beq.n	8019276 <lcp_reqci+0x3fa>
 801926a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801926c:	2b02      	cmp	r3, #2
 801926e:	dd02      	ble.n	8019276 <lcp_reqci+0x3fa>
		cilen < CILEN_CHAR ||
 8019270:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019272:	2b17      	cmp	r3, #23
 8019274:	dd02      	ble.n	801927c <lcp_reqci+0x400>
		cilen > CILEN_CHAR + MAX_ENDP_LEN) {
		orc = CONFREJ;
 8019276:	2304      	movs	r3, #4
 8019278:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 801927a:	e023      	b.n	80192c4 <lcp_reqci+0x448>
	    }
	    GETCHAR(cichar, p);
 801927c:	6a3b      	ldr	r3, [r7, #32]
 801927e:	1c5a      	adds	r2, r3, #1
 8019280:	623a      	str	r2, [r7, #32]
 8019282:	781b      	ldrb	r3, [r3, #0]
 8019284:	61bb      	str	r3, [r7, #24]
	    cilen -= CILEN_CHAR;
 8019286:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019288:	3b03      	subs	r3, #3
 801928a:	653b      	str	r3, [r7, #80]	; 0x50
	    ho->neg_endpoint = 1;
 801928c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801928e:	785a      	ldrb	r2, [r3, #1]
 8019290:	2102      	movs	r1, #2
 8019292:	430a      	orrs	r2, r1
 8019294:	705a      	strb	r2, [r3, #1]
	    ho->endpoint.class_ = cichar;
 8019296:	69bb      	ldr	r3, [r7, #24]
 8019298:	b2da      	uxtb	r2, r3
 801929a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801929c:	735a      	strb	r2, [r3, #13]
	    ho->endpoint.length = cilen;
 801929e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80192a0:	b2da      	uxtb	r2, r3
 80192a2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80192a4:	739a      	strb	r2, [r3, #14]
	    MEMCPY(ho->endpoint.value, p, cilen);
 80192a6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80192a8:	330f      	adds	r3, #15
 80192aa:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80192ac:	6a39      	ldr	r1, [r7, #32]
 80192ae:	0018      	movs	r0, r3
 80192b0:	f003 fc96 	bl	801cbe0 <memcpy>
	    INCPTR(cilen, p);
 80192b4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80192b6:	6a3a      	ldr	r2, [r7, #32]
 80192b8:	18d3      	adds	r3, r2, r3
 80192ba:	623b      	str	r3, [r7, #32]
	    break;
 80192bc:	e002      	b.n	80192c4 <lcp_reqci+0x448>

	default:
	    LCPDEBUG(("lcp_reqci: rcvd unknown option %d", citype));
	    orc = CONFREJ;
 80192be:	2304      	movs	r3, #4
 80192c0:	647b      	str	r3, [r7, #68]	; 0x44
	    break;
 80192c2:	46c0      	nop			; (mov r8, r8)
	}

endswitch:
	if (orc == CONFACK &&		/* Good CI */
 80192c4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80192c6:	2b02      	cmp	r3, #2
 80192c8:	d108      	bne.n	80192dc <lcp_reqci+0x460>
 80192ca:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80192cc:	2b02      	cmp	r3, #2
 80192ce:	d005      	beq.n	80192dc <lcp_reqci+0x460>
	    rc != CONFACK)		/*  but prior CI wasnt? */
	    continue;			/* Don't send this one */
 80192d0:	e029      	b.n	8019326 <lcp_reqci+0x4aa>
 80192d2:	46c0      	nop			; (mov r8, r8)
 80192d4:	08022678 	.word	0x08022678
 80192d8:	080219dc 	.word	0x080219dc

	if (orc == CONFNAK) {		/* Nak this CI? */
 80192dc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80192de:	2b03      	cmp	r3, #3
 80192e0:	d10e      	bne.n	8019300 <lcp_reqci+0x484>
	    if (reject_if_disagree	/* Getting fed up with sending NAKs? */
 80192e2:	683b      	ldr	r3, [r7, #0]
 80192e4:	2b00      	cmp	r3, #0
 80192e6:	d005      	beq.n	80192f4 <lcp_reqci+0x478>
		&& citype != CI_MAGICNUMBER) {
 80192e8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80192ea:	2b05      	cmp	r3, #5
 80192ec:	d002      	beq.n	80192f4 <lcp_reqci+0x478>
		orc = CONFREJ;		/* Get tough if so */
 80192ee:	2304      	movs	r3, #4
 80192f0:	647b      	str	r3, [r7, #68]	; 0x44
 80192f2:	e005      	b.n	8019300 <lcp_reqci+0x484>
	    } else {
		if (rc == CONFREJ)	/* Rejecting prior CI? */
 80192f4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80192f6:	2b04      	cmp	r3, #4
 80192f8:	d100      	bne.n	80192fc <lcp_reqci+0x480>
		    continue;		/* Don't send this one */
 80192fa:	e014      	b.n	8019326 <lcp_reqci+0x4aa>
		rc = CONFNAK;
 80192fc:	2303      	movs	r3, #3
 80192fe:	64bb      	str	r3, [r7, #72]	; 0x48
	    }
	}
	if (orc == CONFREJ) {		/* Reject this CI */
 8019300:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8019302:	2b04      	cmp	r3, #4
 8019304:	d10f      	bne.n	8019326 <lcp_reqci+0x4aa>
	    rc = CONFREJ;
 8019306:	2304      	movs	r3, #4
 8019308:	64bb      	str	r3, [r7, #72]	; 0x48
	    if (cip != rejp)		/* Need to move rejected CI? */
 801930a:	69fa      	ldr	r2, [r7, #28]
 801930c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801930e:	429a      	cmp	r2, r3
 8019310:	d005      	beq.n	801931e <lcp_reqci+0x4a2>
		MEMCPY(rejp, cip, cilen); /* Move it */
 8019312:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8019314:	69f9      	ldr	r1, [r7, #28]
 8019316:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8019318:	0018      	movs	r0, r3
 801931a:	f003 fc61 	bl	801cbe0 <memcpy>
	    INCPTR(cilen, rejp);	/* Update output pointer */
 801931e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019320:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8019322:	18d3      	adds	r3, r2, r3
 8019324:	643b      	str	r3, [r7, #64]	; 0x40
    while (l) {
 8019326:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8019328:	2b00      	cmp	r3, #0
 801932a:	d000      	beq.n	801932e <lcp_reqci+0x4b2>
 801932c:	e5e7      	b.n	8018efe <lcp_reqci+0x82>
     * code would go here.  The extra NAKs would go at *nakoutp.
     * At present there are no cases where we want to ask the
     * peer to negotiate an option.
     */

    switch (rc) {
 801932e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8019330:	2b04      	cmp	r3, #4
 8019332:	d01f      	beq.n	8019374 <lcp_reqci+0x4f8>
 8019334:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8019336:	2b04      	cmp	r3, #4
 8019338:	dc22      	bgt.n	8019380 <lcp_reqci+0x504>
 801933a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801933c:	2b02      	cmp	r3, #2
 801933e:	d003      	beq.n	8019348 <lcp_reqci+0x4cc>
 8019340:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8019342:	2b03      	cmp	r3, #3
 8019344:	d006      	beq.n	8019354 <lcp_reqci+0x4d8>
	break;
    case CONFREJ:
	*lenp = rejp - inp;
	break;
    default:
	break;
 8019346:	e01b      	b.n	8019380 <lcp_reqci+0x504>
	*lenp = next - inp;
 8019348:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801934a:	68bb      	ldr	r3, [r7, #8]
 801934c:	1ad2      	subs	r2, r2, r3
 801934e:	687b      	ldr	r3, [r7, #4]
 8019350:	601a      	str	r2, [r3, #0]
	break;
 8019352:	e016      	b.n	8019382 <lcp_reqci+0x506>
	*lenp = nakoutp - (u_char*)nakp->payload;
 8019354:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019356:	685b      	ldr	r3, [r3, #4]
 8019358:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801935a:	1ad2      	subs	r2, r2, r3
 801935c:	687b      	ldr	r3, [r7, #4]
 801935e:	601a      	str	r2, [r3, #0]
	MEMCPY(inp, nakp->payload, *lenp);
 8019360:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019362:	6859      	ldr	r1, [r3, #4]
 8019364:	687b      	ldr	r3, [r7, #4]
 8019366:	681b      	ldr	r3, [r3, #0]
 8019368:	001a      	movs	r2, r3
 801936a:	68bb      	ldr	r3, [r7, #8]
 801936c:	0018      	movs	r0, r3
 801936e:	f003 fc37 	bl	801cbe0 <memcpy>
	break;
 8019372:	e006      	b.n	8019382 <lcp_reqci+0x506>
	*lenp = rejp - inp;
 8019374:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8019376:	68bb      	ldr	r3, [r7, #8]
 8019378:	1ad2      	subs	r2, r2, r3
 801937a:	687b      	ldr	r3, [r7, #4]
 801937c:	601a      	str	r2, [r3, #0]
	break;
 801937e:	e000      	b.n	8019382 <lcp_reqci+0x506>
	break;
 8019380:	46c0      	nop			; (mov r8, r8)
    }

    pbuf_free(nakp);
 8019382:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019384:	0018      	movs	r0, r3
 8019386:	f7f0 fc23 	bl	8009bd0 <pbuf_free>
    LCPDEBUG(("lcp_reqci: returning CONF%s.", CODENAME(rc)));
    return (rc);			/* Return final code */
 801938a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
}
 801938c:	0018      	movs	r0, r3
 801938e:	46bd      	mov	sp, r7
 8019390:	b016      	add	sp, #88	; 0x58
 8019392:	bd80      	pop	{r7, pc}

08019394 <lcp_up>:


/*
 * lcp_up - LCP has come UP.
 */
static void lcp_up(fsm *f) {
 8019394:	b590      	push	{r4, r7, lr}
 8019396:	b08d      	sub	sp, #52	; 0x34
 8019398:	af02      	add	r7, sp, #8
 801939a:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 801939c:	687b      	ldr	r3, [r7, #4]
 801939e:	681b      	ldr	r3, [r3, #0]
 80193a0:	627b      	str	r3, [r7, #36]	; 0x24
    lcp_options *wo = &pcb->lcp_wantoptions;
 80193a2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80193a4:	3344      	adds	r3, #68	; 0x44
 80193a6:	623b      	str	r3, [r7, #32]
    lcp_options *ho = &pcb->lcp_hisoptions;
 80193a8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80193aa:	33b0      	adds	r3, #176	; 0xb0
 80193ac:	61fb      	str	r3, [r7, #28]
    lcp_options *go = &pcb->lcp_gotoptions;
 80193ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80193b0:	3368      	adds	r3, #104	; 0x68
 80193b2:	61bb      	str	r3, [r7, #24]
    lcp_options *ao = &pcb->lcp_allowoptions;
 80193b4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80193b6:	338c      	adds	r3, #140	; 0x8c
 80193b8:	617b      	str	r3, [r7, #20]
    int mtu, mru;

    if (!go->neg_magicnumber)
 80193ba:	69bb      	ldr	r3, [r7, #24]
 80193bc:	781b      	ldrb	r3, [r3, #0]
 80193be:	2210      	movs	r2, #16
 80193c0:	4013      	ands	r3, r2
 80193c2:	b2db      	uxtb	r3, r3
 80193c4:	2b00      	cmp	r3, #0
 80193c6:	d102      	bne.n	80193ce <lcp_up+0x3a>
	go->magicnumber = 0;
 80193c8:	69bb      	ldr	r3, [r7, #24]
 80193ca:	2200      	movs	r2, #0
 80193cc:	609a      	str	r2, [r3, #8]
    if (!ho->neg_magicnumber)
 80193ce:	69fb      	ldr	r3, [r7, #28]
 80193d0:	781b      	ldrb	r3, [r3, #0]
 80193d2:	2210      	movs	r2, #16
 80193d4:	4013      	ands	r3, r2
 80193d6:	b2db      	uxtb	r3, r3
 80193d8:	2b00      	cmp	r3, #0
 80193da:	d102      	bne.n	80193e2 <lcp_up+0x4e>
	ho->magicnumber = 0;
 80193dc:	69fb      	ldr	r3, [r7, #28]
 80193de:	2200      	movs	r2, #0
 80193e0:	609a      	str	r2, [r3, #8]
     * the value we got in the negotiation.
     * Note on the MTU: the link MTU can be the MRU the peer wanted,
     * the interface MTU is set to the lowest of that, the
     * MTU we want to use, and our link MRU.
     */
    mtu = ho->neg_mru? ho->mru: PPP_MRU;
 80193e2:	69fb      	ldr	r3, [r7, #28]
 80193e4:	781b      	ldrb	r3, [r3, #0]
 80193e6:	2204      	movs	r2, #4
 80193e8:	4013      	ands	r3, r2
 80193ea:	b2db      	uxtb	r3, r3
 80193ec:	2b00      	cmp	r3, #0
 80193ee:	d002      	beq.n	80193f6 <lcp_up+0x62>
 80193f0:	69fb      	ldr	r3, [r7, #28]
 80193f2:	885b      	ldrh	r3, [r3, #2]
 80193f4:	e000      	b.n	80193f8 <lcp_up+0x64>
 80193f6:	4b42      	ldr	r3, [pc, #264]	; (8019500 <lcp_up+0x16c>)
 80193f8:	613b      	str	r3, [r7, #16]
    mru = go->neg_mru? LWIP_MAX(wo->mru, go->mru): PPP_MRU;
 80193fa:	69bb      	ldr	r3, [r7, #24]
 80193fc:	781b      	ldrb	r3, [r3, #0]
 80193fe:	2204      	movs	r2, #4
 8019400:	4013      	ands	r3, r2
 8019402:	b2db      	uxtb	r3, r3
 8019404:	2b00      	cmp	r3, #0
 8019406:	d00c      	beq.n	8019422 <lcp_up+0x8e>
 8019408:	69bb      	ldr	r3, [r7, #24]
 801940a:	885a      	ldrh	r2, [r3, #2]
 801940c:	6a3b      	ldr	r3, [r7, #32]
 801940e:	885b      	ldrh	r3, [r3, #2]
 8019410:	1c18      	adds	r0, r3, #0
 8019412:	1c11      	adds	r1, r2, #0
 8019414:	b28a      	uxth	r2, r1
 8019416:	b283      	uxth	r3, r0
 8019418:	429a      	cmp	r2, r3
 801941a:	d200      	bcs.n	801941e <lcp_up+0x8a>
 801941c:	1c01      	adds	r1, r0, #0
 801941e:	b28b      	uxth	r3, r1
 8019420:	e000      	b.n	8019424 <lcp_up+0x90>
 8019422:	4b37      	ldr	r3, [pc, #220]	; (8019500 <lcp_up+0x16c>)
 8019424:	60fb      	str	r3, [r7, #12]
#ifdef HAVE_MULTILINK
    if (!(multilink && go->neg_mrru && ho->neg_mrru))
#endif /* HAVE_MULTILINK */
	netif_set_mtu(pcb, LWIP_MIN(LWIP_MIN(mtu, mru), ao->mru));
 8019426:	697b      	ldr	r3, [r7, #20]
 8019428:	885b      	ldrh	r3, [r3, #2]
 801942a:	0019      	movs	r1, r3
 801942c:	693a      	ldr	r2, [r7, #16]
 801942e:	68fb      	ldr	r3, [r7, #12]
 8019430:	4293      	cmp	r3, r2
 8019432:	dd00      	ble.n	8019436 <lcp_up+0xa2>
 8019434:	0013      	movs	r3, r2
 8019436:	000a      	movs	r2, r1
 8019438:	429a      	cmp	r2, r3
 801943a:	dd00      	ble.n	801943e <lcp_up+0xaa>
 801943c:	001a      	movs	r2, r3
 801943e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019440:	0011      	movs	r1, r2
 8019442:	0018      	movs	r0, r3
 8019444:	f000 fefc 	bl	801a240 <netif_set_mtu>
    ppp_send_config(pcb, mtu,
		    (ho->neg_asyncmap? ho->asyncmap: 0xffffffff),
 8019448:	69fb      	ldr	r3, [r7, #28]
 801944a:	781b      	ldrb	r3, [r3, #0]
 801944c:	2208      	movs	r2, #8
 801944e:	4013      	ands	r3, r2
 8019450:	b2db      	uxtb	r3, r3
    ppp_send_config(pcb, mtu,
 8019452:	2b00      	cmp	r3, #0
 8019454:	d002      	beq.n	801945c <lcp_up+0xc8>
 8019456:	69fb      	ldr	r3, [r7, #28]
 8019458:	685a      	ldr	r2, [r3, #4]
 801945a:	e001      	b.n	8019460 <lcp_up+0xcc>
 801945c:	2301      	movs	r3, #1
 801945e:	425a      	negs	r2, r3
		    ho->neg_pcompression, ho->neg_accompression);
 8019460:	69fb      	ldr	r3, [r7, #28]
 8019462:	781b      	ldrb	r3, [r3, #0]
 8019464:	069b      	lsls	r3, r3, #26
 8019466:	0fdb      	lsrs	r3, r3, #31
 8019468:	b2db      	uxtb	r3, r3
    ppp_send_config(pcb, mtu,
 801946a:	001c      	movs	r4, r3
		    ho->neg_pcompression, ho->neg_accompression);
 801946c:	69fb      	ldr	r3, [r7, #28]
 801946e:	781b      	ldrb	r3, [r3, #0]
 8019470:	065b      	lsls	r3, r3, #25
 8019472:	0fdb      	lsrs	r3, r3, #31
 8019474:	b2db      	uxtb	r3, r3
    ppp_send_config(pcb, mtu,
 8019476:	6939      	ldr	r1, [r7, #16]
 8019478:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801947a:	9300      	str	r3, [sp, #0]
 801947c:	0023      	movs	r3, r4
 801947e:	f000 fdc1 	bl	801a004 <ppp_send_config>
    ppp_recv_config(pcb, mru,
		    (pcb->settings.lax_recv? 0: go->neg_asyncmap? go->asyncmap: 0xffffffff),
 8019482:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019484:	781b      	ldrb	r3, [r3, #0]
 8019486:	2208      	movs	r2, #8
 8019488:	4013      	ands	r3, r2
 801948a:	b2db      	uxtb	r3, r3
    ppp_recv_config(pcb, mru,
 801948c:	2b00      	cmp	r3, #0
 801948e:	d10c      	bne.n	80194aa <lcp_up+0x116>
		    (pcb->settings.lax_recv? 0: go->neg_asyncmap? go->asyncmap: 0xffffffff),
 8019490:	69bb      	ldr	r3, [r7, #24]
 8019492:	781b      	ldrb	r3, [r3, #0]
 8019494:	2208      	movs	r2, #8
 8019496:	4013      	ands	r3, r2
 8019498:	b2db      	uxtb	r3, r3
 801949a:	2b00      	cmp	r3, #0
 801949c:	d002      	beq.n	80194a4 <lcp_up+0x110>
 801949e:	69bb      	ldr	r3, [r7, #24]
 80194a0:	685a      	ldr	r2, [r3, #4]
 80194a2:	e003      	b.n	80194ac <lcp_up+0x118>
 80194a4:	2301      	movs	r3, #1
 80194a6:	425a      	negs	r2, r3
 80194a8:	e000      	b.n	80194ac <lcp_up+0x118>
    ppp_recv_config(pcb, mru,
 80194aa:	2200      	movs	r2, #0
		    go->neg_pcompression, go->neg_accompression);
 80194ac:	69bb      	ldr	r3, [r7, #24]
 80194ae:	781b      	ldrb	r3, [r3, #0]
 80194b0:	069b      	lsls	r3, r3, #26
 80194b2:	0fdb      	lsrs	r3, r3, #31
 80194b4:	b2db      	uxtb	r3, r3
    ppp_recv_config(pcb, mru,
 80194b6:	001c      	movs	r4, r3
		    go->neg_pcompression, go->neg_accompression);
 80194b8:	69bb      	ldr	r3, [r7, #24]
 80194ba:	781b      	ldrb	r3, [r3, #0]
 80194bc:	065b      	lsls	r3, r3, #25
 80194be:	0fdb      	lsrs	r3, r3, #31
 80194c0:	b2db      	uxtb	r3, r3
    ppp_recv_config(pcb, mru,
 80194c2:	68f9      	ldr	r1, [r7, #12]
 80194c4:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80194c6:	9300      	str	r3, [sp, #0]
 80194c8:	0023      	movs	r3, r4
 80194ca:	f000 fdb8 	bl	801a03e <ppp_recv_config>

    if (ho->neg_mru)
 80194ce:	69fb      	ldr	r3, [r7, #28]
 80194d0:	781b      	ldrb	r3, [r3, #0]
 80194d2:	2204      	movs	r2, #4
 80194d4:	4013      	ands	r3, r2
 80194d6:	b2db      	uxtb	r3, r3
 80194d8:	2b00      	cmp	r3, #0
 80194da:	d004      	beq.n	80194e6 <lcp_up+0x152>
	pcb->peer_mru = ho->mru;
 80194dc:	69fb      	ldr	r3, [r7, #28]
 80194de:	8859      	ldrh	r1, [r3, #2]
 80194e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80194e2:	22d4      	movs	r2, #212	; 0xd4
 80194e4:	5299      	strh	r1, [r3, r2]

    lcp_echo_lowerup(f->pcb);  /* Enable echo messages */
 80194e6:	687b      	ldr	r3, [r7, #4]
 80194e8:	681b      	ldr	r3, [r3, #0]
 80194ea:	0018      	movs	r0, r3
 80194ec:	f000 f9b0 	bl	8019850 <lcp_echo_lowerup>

    link_established(pcb);
 80194f0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80194f2:	0018      	movs	r0, r3
 80194f4:	f7fa fdc6 	bl	8014084 <link_established>
}
 80194f8:	46c0      	nop			; (mov r8, r8)
 80194fa:	46bd      	mov	sp, r7
 80194fc:	b00b      	add	sp, #44	; 0x2c
 80194fe:	bd90      	pop	{r4, r7, pc}
 8019500:	000005dc 	.word	0x000005dc

08019504 <lcp_down>:
/*
 * lcp_down - LCP has gone DOWN.
 *
 * Alert other protocols.
 */
static void lcp_down(fsm *f) {
 8019504:	b590      	push	{r4, r7, lr}
 8019506:	b087      	sub	sp, #28
 8019508:	af02      	add	r7, sp, #8
 801950a:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 801950c:	687b      	ldr	r3, [r7, #4]
 801950e:	681b      	ldr	r3, [r3, #0]
 8019510:	60fb      	str	r3, [r7, #12]
    lcp_options *go = &pcb->lcp_gotoptions;
 8019512:	68fb      	ldr	r3, [r7, #12]
 8019514:	3368      	adds	r3, #104	; 0x68
 8019516:	60bb      	str	r3, [r7, #8]

    lcp_echo_lowerdown(f->pcb);
 8019518:	687b      	ldr	r3, [r7, #4]
 801951a:	681b      	ldr	r3, [r3, #0]
 801951c:	0018      	movs	r0, r3
 801951e:	f000 f9b9 	bl	8019894 <lcp_echo_lowerdown>

    link_down(pcb);
 8019522:	68fb      	ldr	r3, [r7, #12]
 8019524:	0018      	movs	r0, r3
 8019526:	f7fa fd53 	bl	8013fd0 <link_down>

    ppp_send_config(pcb, PPP_MRU, 0xffffffff, 0, 0);
 801952a:	2301      	movs	r3, #1
 801952c:	425a      	negs	r2, r3
 801952e:	4916      	ldr	r1, [pc, #88]	; (8019588 <lcp_down+0x84>)
 8019530:	68f8      	ldr	r0, [r7, #12]
 8019532:	2300      	movs	r3, #0
 8019534:	9300      	str	r3, [sp, #0]
 8019536:	2300      	movs	r3, #0
 8019538:	f000 fd64 	bl	801a004 <ppp_send_config>
    ppp_recv_config(pcb, PPP_MRU,
		    (go->neg_asyncmap? go->asyncmap: 0xffffffff),
 801953c:	68bb      	ldr	r3, [r7, #8]
 801953e:	781b      	ldrb	r3, [r3, #0]
 8019540:	2208      	movs	r2, #8
 8019542:	4013      	ands	r3, r2
 8019544:	b2db      	uxtb	r3, r3
    ppp_recv_config(pcb, PPP_MRU,
 8019546:	2b00      	cmp	r3, #0
 8019548:	d002      	beq.n	8019550 <lcp_down+0x4c>
 801954a:	68bb      	ldr	r3, [r7, #8]
 801954c:	685a      	ldr	r2, [r3, #4]
 801954e:	e001      	b.n	8019554 <lcp_down+0x50>
 8019550:	2301      	movs	r3, #1
 8019552:	425a      	negs	r2, r3
		    go->neg_pcompression, go->neg_accompression);
 8019554:	68bb      	ldr	r3, [r7, #8]
 8019556:	781b      	ldrb	r3, [r3, #0]
 8019558:	069b      	lsls	r3, r3, #26
 801955a:	0fdb      	lsrs	r3, r3, #31
 801955c:	b2db      	uxtb	r3, r3
    ppp_recv_config(pcb, PPP_MRU,
 801955e:	001c      	movs	r4, r3
		    go->neg_pcompression, go->neg_accompression);
 8019560:	68bb      	ldr	r3, [r7, #8]
 8019562:	781b      	ldrb	r3, [r3, #0]
 8019564:	065b      	lsls	r3, r3, #25
 8019566:	0fdb      	lsrs	r3, r3, #31
 8019568:	b2db      	uxtb	r3, r3
    ppp_recv_config(pcb, PPP_MRU,
 801956a:	4907      	ldr	r1, [pc, #28]	; (8019588 <lcp_down+0x84>)
 801956c:	68f8      	ldr	r0, [r7, #12]
 801956e:	9300      	str	r3, [sp, #0]
 8019570:	0023      	movs	r3, r4
 8019572:	f000 fd64 	bl	801a03e <ppp_recv_config>
    pcb->peer_mru = PPP_MRU;
 8019576:	68fb      	ldr	r3, [r7, #12]
 8019578:	22d4      	movs	r2, #212	; 0xd4
 801957a:	4903      	ldr	r1, [pc, #12]	; (8019588 <lcp_down+0x84>)
 801957c:	5299      	strh	r1, [r3, r2]
}
 801957e:	46c0      	nop			; (mov r8, r8)
 8019580:	46bd      	mov	sp, r7
 8019582:	b005      	add	sp, #20
 8019584:	bd90      	pop	{r4, r7, pc}
 8019586:	46c0      	nop			; (mov r8, r8)
 8019588:	000005dc 	.word	0x000005dc

0801958c <lcp_starting>:


/*
 * lcp_starting - LCP needs the lower layer up.
 */
static void lcp_starting(fsm *f) {
 801958c:	b580      	push	{r7, lr}
 801958e:	b084      	sub	sp, #16
 8019590:	af00      	add	r7, sp, #0
 8019592:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8019594:	687b      	ldr	r3, [r7, #4]
 8019596:	681b      	ldr	r3, [r3, #0]
 8019598:	60fb      	str	r3, [r7, #12]
    link_required(pcb);
 801959a:	68fb      	ldr	r3, [r7, #12]
 801959c:	0018      	movs	r0, r3
 801959e:	f7fa fced 	bl	8013f7c <link_required>
}
 80195a2:	46c0      	nop			; (mov r8, r8)
 80195a4:	46bd      	mov	sp, r7
 80195a6:	b004      	add	sp, #16
 80195a8:	bd80      	pop	{r7, pc}

080195aa <lcp_finished>:


/*
 * lcp_finished - LCP has finished with the lower layer.
 */
static void lcp_finished(fsm *f) {
 80195aa:	b580      	push	{r7, lr}
 80195ac:	b084      	sub	sp, #16
 80195ae:	af00      	add	r7, sp, #0
 80195b0:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 80195b2:	687b      	ldr	r3, [r7, #4]
 80195b4:	681b      	ldr	r3, [r3, #0]
 80195b6:	60fb      	str	r3, [r7, #12]
    link_terminated(pcb);
 80195b8:	68fb      	ldr	r3, [r7, #12]
 80195ba:	0018      	movs	r0, r3
 80195bc:	f7fa fce6 	bl	8013f8c <link_terminated>
}
 80195c0:	46c0      	nop			; (mov r8, r8)
 80195c2:	46bd      	mov	sp, r7
 80195c4:	b004      	add	sp, #16
 80195c6:	bd80      	pop	{r7, pc}

080195c8 <LcpLinkFailure>:

/*
 * Time to shut down the link because there is nothing out there.
 */

static void LcpLinkFailure(fsm *f) {
 80195c8:	b580      	push	{r7, lr}
 80195ca:	b084      	sub	sp, #16
 80195cc:	af00      	add	r7, sp, #0
 80195ce:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 80195d0:	687b      	ldr	r3, [r7, #4]
 80195d2:	681b      	ldr	r3, [r3, #0]
 80195d4:	60fb      	str	r3, [r7, #12]
    if (f->state == PPP_FSM_OPENED) {
 80195d6:	687b      	ldr	r3, [r7, #4]
 80195d8:	7c1b      	ldrb	r3, [r3, #16]
 80195da:	2b09      	cmp	r3, #9
 80195dc:	d116      	bne.n	801960c <LcpLinkFailure+0x44>
	ppp_info("No response to %d echo-requests", pcb->lcp_echos_pending);
 80195de:	68fb      	ldr	r3, [r7, #12]
 80195e0:	22d6      	movs	r2, #214	; 0xd6
 80195e2:	5c9b      	ldrb	r3, [r3, r2]
 80195e4:	001a      	movs	r2, r3
 80195e6:	4b0b      	ldr	r3, [pc, #44]	; (8019614 <LcpLinkFailure+0x4c>)
 80195e8:	0011      	movs	r1, r2
 80195ea:	0018      	movs	r0, r3
 80195ec:	f001 ffd5 	bl	801b59a <ppp_info>
        ppp_notice("Serial link appears to be disconnected.");
 80195f0:	4b09      	ldr	r3, [pc, #36]	; (8019618 <LcpLinkFailure+0x50>)
 80195f2:	0018      	movs	r0, r3
 80195f4:	f001 ffbd 	bl	801b572 <ppp_notice>
	pcb->err_code = PPPERR_PEERDEAD;
 80195f8:	68fb      	ldr	r3, [r7, #12]
 80195fa:	2225      	movs	r2, #37	; 0x25
 80195fc:	2109      	movs	r1, #9
 80195fe:	5499      	strb	r1, [r3, r2]
	lcp_close(pcb, "Peer not responding");
 8019600:	4a06      	ldr	r2, [pc, #24]	; (801961c <LcpLinkFailure+0x54>)
 8019602:	68fb      	ldr	r3, [r7, #12]
 8019604:	0011      	movs	r1, r2
 8019606:	0018      	movs	r0, r3
 8019608:	f7fe f92e 	bl	8017868 <lcp_close>
    }
}
 801960c:	46c0      	nop			; (mov r8, r8)
 801960e:	46bd      	mov	sp, r7
 8019610:	b004      	add	sp, #16
 8019612:	bd80      	pop	{r7, pc}
 8019614:	080219f0 	.word	0x080219f0
 8019618:	08021a10 	.word	0x08021a10
 801961c:	08021a38 	.word	0x08021a38

08019620 <LcpEchoCheck>:

/*
 * Timer expired for the LCP echo requests from this process.
 */

static void LcpEchoCheck(fsm *f) {
 8019620:	b580      	push	{r7, lr}
 8019622:	b084      	sub	sp, #16
 8019624:	af00      	add	r7, sp, #0
 8019626:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8019628:	687b      	ldr	r3, [r7, #4]
 801962a:	681b      	ldr	r3, [r3, #0]
 801962c:	60fb      	str	r3, [r7, #12]

    LcpSendEchoRequest (f);
 801962e:	687b      	ldr	r3, [r7, #4]
 8019630:	0018      	movs	r0, r3
 8019632:	f000 f8ad 	bl	8019790 <LcpSendEchoRequest>
    if (f->state != PPP_FSM_OPENED)
 8019636:	687b      	ldr	r3, [r7, #4]
 8019638:	7c1b      	ldrb	r3, [r3, #16]
 801963a:	2b09      	cmp	r3, #9
 801963c:	d127      	bne.n	801968e <LcpEchoCheck+0x6e>
	return;

    /*
     * Start the timer for the next interval.
     */
    if (pcb->lcp_echo_timer_running)
 801963e:	68fb      	ldr	r3, [r7, #12]
 8019640:	2226      	movs	r2, #38	; 0x26
 8019642:	5c9b      	ldrb	r3, [r3, r2]
 8019644:	2210      	movs	r2, #16
 8019646:	4013      	ands	r3, r2
 8019648:	b2db      	uxtb	r3, r3
 801964a:	2b00      	cmp	r3, #0
 801964c:	d003      	beq.n	8019656 <LcpEchoCheck+0x36>
	ppp_warn("assertion lcp_echo_timer_running==0 failed");
 801964e:	4b12      	ldr	r3, [pc, #72]	; (8019698 <LcpEchoCheck+0x78>)
 8019650:	0018      	movs	r0, r3
 8019652:	f001 ff7a 	bl	801b54a <ppp_warn>
    TIMEOUT (LcpEchoTimeout, f, pcb->settings.lcp_echo_interval);
 8019656:	687a      	ldr	r2, [r7, #4]
 8019658:	4b10      	ldr	r3, [pc, #64]	; (801969c <LcpEchoCheck+0x7c>)
 801965a:	0011      	movs	r1, r2
 801965c:	0018      	movs	r0, r3
 801965e:	f7f8 fd53 	bl	8012108 <sys_untimeout>
 8019662:	68fb      	ldr	r3, [r7, #12]
 8019664:	7a5b      	ldrb	r3, [r3, #9]
 8019666:	001a      	movs	r2, r3
 8019668:	0013      	movs	r3, r2
 801966a:	015b      	lsls	r3, r3, #5
 801966c:	1a9b      	subs	r3, r3, r2
 801966e:	009b      	lsls	r3, r3, #2
 8019670:	189b      	adds	r3, r3, r2
 8019672:	00db      	lsls	r3, r3, #3
 8019674:	0018      	movs	r0, r3
 8019676:	687a      	ldr	r2, [r7, #4]
 8019678:	4b08      	ldr	r3, [pc, #32]	; (801969c <LcpEchoCheck+0x7c>)
 801967a:	0019      	movs	r1, r3
 801967c:	f7f8 fd1c 	bl	80120b8 <sys_timeout>
    pcb->lcp_echo_timer_running = 1;
 8019680:	68fb      	ldr	r3, [r7, #12]
 8019682:	2226      	movs	r2, #38	; 0x26
 8019684:	5c99      	ldrb	r1, [r3, r2]
 8019686:	2010      	movs	r0, #16
 8019688:	4301      	orrs	r1, r0
 801968a:	5499      	strb	r1, [r3, r2]
 801968c:	e000      	b.n	8019690 <LcpEchoCheck+0x70>
	return;
 801968e:	46c0      	nop			; (mov r8, r8)
}
 8019690:	46bd      	mov	sp, r7
 8019692:	b004      	add	sp, #16
 8019694:	bd80      	pop	{r7, pc}
 8019696:	46c0      	nop			; (mov r8, r8)
 8019698:	08021a4c 	.word	0x08021a4c
 801969c:	080196a1 	.word	0x080196a1

080196a0 <LcpEchoTimeout>:

/*
 * LcpEchoTimeout - Timer expired on the LCP echo
 */

static void LcpEchoTimeout(void *arg) {
 80196a0:	b580      	push	{r7, lr}
 80196a2:	b084      	sub	sp, #16
 80196a4:	af00      	add	r7, sp, #0
 80196a6:	6078      	str	r0, [r7, #4]
    fsm *f = (fsm*)arg;
 80196a8:	687b      	ldr	r3, [r7, #4]
 80196aa:	60fb      	str	r3, [r7, #12]
    ppp_pcb *pcb = f->pcb;
 80196ac:	68fb      	ldr	r3, [r7, #12]
 80196ae:	681b      	ldr	r3, [r3, #0]
 80196b0:	60bb      	str	r3, [r7, #8]
    if (pcb->lcp_echo_timer_running != 0) {
 80196b2:	68bb      	ldr	r3, [r7, #8]
 80196b4:	2226      	movs	r2, #38	; 0x26
 80196b6:	5c9b      	ldrb	r3, [r3, r2]
 80196b8:	2210      	movs	r2, #16
 80196ba:	4013      	ands	r3, r2
 80196bc:	b2db      	uxtb	r3, r3
 80196be:	2b00      	cmp	r3, #0
 80196c0:	d009      	beq.n	80196d6 <LcpEchoTimeout+0x36>
        pcb->lcp_echo_timer_running = 0;
 80196c2:	68bb      	ldr	r3, [r7, #8]
 80196c4:	2226      	movs	r2, #38	; 0x26
 80196c6:	5c99      	ldrb	r1, [r3, r2]
 80196c8:	2010      	movs	r0, #16
 80196ca:	4381      	bics	r1, r0
 80196cc:	5499      	strb	r1, [r3, r2]
        LcpEchoCheck ((fsm *) arg);
 80196ce:	687b      	ldr	r3, [r7, #4]
 80196d0:	0018      	movs	r0, r3
 80196d2:	f7ff ffa5 	bl	8019620 <LcpEchoCheck>
    }
}
 80196d6:	46c0      	nop			; (mov r8, r8)
 80196d8:	46bd      	mov	sp, r7
 80196da:	b004      	add	sp, #16
 80196dc:	bd80      	pop	{r7, pc}
	...

080196e0 <lcp_received_echo_reply>:

/*
 * LcpEchoReply - LCP has received a reply to the echo
 */

static void lcp_received_echo_reply(fsm *f, int id, u_char *inp, int len) {
 80196e0:	b580      	push	{r7, lr}
 80196e2:	b088      	sub	sp, #32
 80196e4:	af00      	add	r7, sp, #0
 80196e6:	60f8      	str	r0, [r7, #12]
 80196e8:	60b9      	str	r1, [r7, #8]
 80196ea:	607a      	str	r2, [r7, #4]
 80196ec:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 80196ee:	68fb      	ldr	r3, [r7, #12]
 80196f0:	681b      	ldr	r3, [r3, #0]
 80196f2:	61fb      	str	r3, [r7, #28]
    lcp_options *go = &pcb->lcp_gotoptions;
 80196f4:	69fb      	ldr	r3, [r7, #28]
 80196f6:	3368      	adds	r3, #104	; 0x68
 80196f8:	61bb      	str	r3, [r7, #24]
    u32_t magic_val;
    LWIP_UNUSED_ARG(id);

    /* Check the magic number - don't count replies from ourselves. */
    if (len < 4) {
 80196fa:	683b      	ldr	r3, [r7, #0]
 80196fc:	2b03      	cmp	r3, #3
 80196fe:	dc06      	bgt.n	801970e <lcp_received_echo_reply+0x2e>
	ppp_dbglog("lcp: received short Echo-Reply, length %d", len);
 8019700:	683a      	ldr	r2, [r7, #0]
 8019702:	4b21      	ldr	r3, [pc, #132]	; (8019788 <lcp_received_echo_reply+0xa8>)
 8019704:	0011      	movs	r1, r2
 8019706:	0018      	movs	r0, r3
 8019708:	f001 ff5b 	bl	801b5c2 <ppp_dbglog>
	return;
 801970c:	e038      	b.n	8019780 <lcp_received_echo_reply+0xa0>
    }
    GETLONG(magic_val, inp);
 801970e:	687b      	ldr	r3, [r7, #4]
 8019710:	1c5a      	adds	r2, r3, #1
 8019712:	607a      	str	r2, [r7, #4]
 8019714:	781b      	ldrb	r3, [r3, #0]
 8019716:	021b      	lsls	r3, r3, #8
 8019718:	617b      	str	r3, [r7, #20]
 801971a:	687b      	ldr	r3, [r7, #4]
 801971c:	1c5a      	adds	r2, r3, #1
 801971e:	607a      	str	r2, [r7, #4]
 8019720:	781b      	ldrb	r3, [r3, #0]
 8019722:	001a      	movs	r2, r3
 8019724:	697b      	ldr	r3, [r7, #20]
 8019726:	4313      	orrs	r3, r2
 8019728:	617b      	str	r3, [r7, #20]
 801972a:	697b      	ldr	r3, [r7, #20]
 801972c:	021b      	lsls	r3, r3, #8
 801972e:	617b      	str	r3, [r7, #20]
 8019730:	687b      	ldr	r3, [r7, #4]
 8019732:	1c5a      	adds	r2, r3, #1
 8019734:	607a      	str	r2, [r7, #4]
 8019736:	781b      	ldrb	r3, [r3, #0]
 8019738:	001a      	movs	r2, r3
 801973a:	697b      	ldr	r3, [r7, #20]
 801973c:	4313      	orrs	r3, r2
 801973e:	617b      	str	r3, [r7, #20]
 8019740:	697b      	ldr	r3, [r7, #20]
 8019742:	021b      	lsls	r3, r3, #8
 8019744:	617b      	str	r3, [r7, #20]
 8019746:	687b      	ldr	r3, [r7, #4]
 8019748:	1c5a      	adds	r2, r3, #1
 801974a:	607a      	str	r2, [r7, #4]
 801974c:	781b      	ldrb	r3, [r3, #0]
 801974e:	001a      	movs	r2, r3
 8019750:	697b      	ldr	r3, [r7, #20]
 8019752:	4313      	orrs	r3, r2
 8019754:	617b      	str	r3, [r7, #20]
    if (go->neg_magicnumber
 8019756:	69bb      	ldr	r3, [r7, #24]
 8019758:	781b      	ldrb	r3, [r3, #0]
 801975a:	2210      	movs	r2, #16
 801975c:	4013      	ands	r3, r2
 801975e:	b2db      	uxtb	r3, r3
 8019760:	2b00      	cmp	r3, #0
 8019762:	d009      	beq.n	8019778 <lcp_received_echo_reply+0x98>
	&& magic_val == go->magicnumber) {
 8019764:	69bb      	ldr	r3, [r7, #24]
 8019766:	689b      	ldr	r3, [r3, #8]
 8019768:	697a      	ldr	r2, [r7, #20]
 801976a:	429a      	cmp	r2, r3
 801976c:	d104      	bne.n	8019778 <lcp_received_echo_reply+0x98>
	ppp_warn("appear to have received our own echo-reply!");
 801976e:	4b07      	ldr	r3, [pc, #28]	; (801978c <lcp_received_echo_reply+0xac>)
 8019770:	0018      	movs	r0, r3
 8019772:	f001 feea 	bl	801b54a <ppp_warn>
	return;
 8019776:	e003      	b.n	8019780 <lcp_received_echo_reply+0xa0>
    }

    /* Reset the number of outstanding echo frames */
    pcb->lcp_echos_pending = 0;
 8019778:	69fb      	ldr	r3, [r7, #28]
 801977a:	22d6      	movs	r2, #214	; 0xd6
 801977c:	2100      	movs	r1, #0
 801977e:	5499      	strb	r1, [r3, r2]
}
 8019780:	46bd      	mov	sp, r7
 8019782:	b008      	add	sp, #32
 8019784:	bd80      	pop	{r7, pc}
 8019786:	46c0      	nop			; (mov r8, r8)
 8019788:	08021a78 	.word	0x08021a78
 801978c:	08021aa4 	.word	0x08021aa4

08019790 <LcpSendEchoRequest>:

/*
 * LcpSendEchoRequest - Send an echo request frame to the peer
 */

static void LcpSendEchoRequest(fsm *f) {
 8019790:	b590      	push	{r4, r7, lr}
 8019792:	b08b      	sub	sp, #44	; 0x2c
 8019794:	af02      	add	r7, sp, #8
 8019796:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8019798:	687b      	ldr	r3, [r7, #4]
 801979a:	681b      	ldr	r3, [r3, #0]
 801979c:	61fb      	str	r3, [r7, #28]
    lcp_options *go = &pcb->lcp_gotoptions;
 801979e:	69fb      	ldr	r3, [r7, #28]
 80197a0:	3368      	adds	r3, #104	; 0x68
 80197a2:	61bb      	str	r3, [r7, #24]
    u_char pkt[4], *pktp;

    /*
     * Detect the failure of the peer at this point.
     */
    if (pcb->settings.lcp_echo_fails != 0) {
 80197a4:	69fb      	ldr	r3, [r7, #28]
 80197a6:	7a9b      	ldrb	r3, [r3, #10]
 80197a8:	2b00      	cmp	r3, #0
 80197aa:	d00e      	beq.n	80197ca <LcpSendEchoRequest+0x3a>
        if (pcb->lcp_echos_pending >= pcb->settings.lcp_echo_fails) {
 80197ac:	69fb      	ldr	r3, [r7, #28]
 80197ae:	22d6      	movs	r2, #214	; 0xd6
 80197b0:	5c9a      	ldrb	r2, [r3, r2]
 80197b2:	69fb      	ldr	r3, [r7, #28]
 80197b4:	7a9b      	ldrb	r3, [r3, #10]
 80197b6:	429a      	cmp	r2, r3
 80197b8:	d307      	bcc.n	80197ca <LcpSendEchoRequest+0x3a>
            LcpLinkFailure(f);
 80197ba:	687b      	ldr	r3, [r7, #4]
 80197bc:	0018      	movs	r0, r3
 80197be:	f7ff ff03 	bl	80195c8 <LcpLinkFailure>
            pcb->lcp_echos_pending = 0;
 80197c2:	69fb      	ldr	r3, [r7, #28]
 80197c4:	22d6      	movs	r2, #214	; 0xd6
 80197c6:	2100      	movs	r1, #0
 80197c8:	5499      	strb	r1, [r3, r2]
#endif

    /*
     * Make and send the echo request frame.
     */
    if (f->state == PPP_FSM_OPENED) {
 80197ca:	687b      	ldr	r3, [r7, #4]
 80197cc:	7c1b      	ldrb	r3, [r3, #16]
 80197ce:	2b09      	cmp	r3, #9
 80197d0:	d13a      	bne.n	8019848 <LcpSendEchoRequest+0xb8>
        lcp_magic = go->magicnumber;
 80197d2:	69bb      	ldr	r3, [r7, #24]
 80197d4:	689b      	ldr	r3, [r3, #8]
 80197d6:	617b      	str	r3, [r7, #20]
	pktp = pkt;
 80197d8:	240c      	movs	r4, #12
 80197da:	193b      	adds	r3, r7, r4
 80197dc:	613b      	str	r3, [r7, #16]
	PUTLONG(lcp_magic, pktp);
 80197de:	697b      	ldr	r3, [r7, #20]
 80197e0:	0e19      	lsrs	r1, r3, #24
 80197e2:	693b      	ldr	r3, [r7, #16]
 80197e4:	1c5a      	adds	r2, r3, #1
 80197e6:	613a      	str	r2, [r7, #16]
 80197e8:	b2ca      	uxtb	r2, r1
 80197ea:	701a      	strb	r2, [r3, #0]
 80197ec:	697b      	ldr	r3, [r7, #20]
 80197ee:	0c19      	lsrs	r1, r3, #16
 80197f0:	693b      	ldr	r3, [r7, #16]
 80197f2:	1c5a      	adds	r2, r3, #1
 80197f4:	613a      	str	r2, [r7, #16]
 80197f6:	b2ca      	uxtb	r2, r1
 80197f8:	701a      	strb	r2, [r3, #0]
 80197fa:	697b      	ldr	r3, [r7, #20]
 80197fc:	0a19      	lsrs	r1, r3, #8
 80197fe:	693b      	ldr	r3, [r7, #16]
 8019800:	1c5a      	adds	r2, r3, #1
 8019802:	613a      	str	r2, [r7, #16]
 8019804:	b2ca      	uxtb	r2, r1
 8019806:	701a      	strb	r2, [r3, #0]
 8019808:	693b      	ldr	r3, [r7, #16]
 801980a:	1c5a      	adds	r2, r3, #1
 801980c:	613a      	str	r2, [r7, #16]
 801980e:	697a      	ldr	r2, [r7, #20]
 8019810:	b2d2      	uxtb	r2, r2
 8019812:	701a      	strb	r2, [r3, #0]
        fsm_sdata(f, ECHOREQ, pcb->lcp_echo_number++, pkt, pktp - pkt);
 8019814:	69fb      	ldr	r3, [r7, #28]
 8019816:	22d7      	movs	r2, #215	; 0xd7
 8019818:	5c9a      	ldrb	r2, [r3, r2]
 801981a:	1c53      	adds	r3, r2, #1
 801981c:	b2d8      	uxtb	r0, r3
 801981e:	69fb      	ldr	r3, [r7, #28]
 8019820:	21d7      	movs	r1, #215	; 0xd7
 8019822:	5458      	strb	r0, [r3, r1]
 8019824:	193b      	adds	r3, r7, r4
 8019826:	6939      	ldr	r1, [r7, #16]
 8019828:	1acb      	subs	r3, r1, r3
 801982a:	1939      	adds	r1, r7, r4
 801982c:	6878      	ldr	r0, [r7, #4]
 801982e:	9300      	str	r3, [sp, #0]
 8019830:	000b      	movs	r3, r1
 8019832:	2109      	movs	r1, #9
 8019834:	f7fb fc1e 	bl	8015074 <fsm_sdata>
	++pcb->lcp_echos_pending;
 8019838:	69fb      	ldr	r3, [r7, #28]
 801983a:	22d6      	movs	r2, #214	; 0xd6
 801983c:	5c9b      	ldrb	r3, [r3, r2]
 801983e:	3301      	adds	r3, #1
 8019840:	b2d9      	uxtb	r1, r3
 8019842:	69fb      	ldr	r3, [r7, #28]
 8019844:	22d6      	movs	r2, #214	; 0xd6
 8019846:	5499      	strb	r1, [r3, r2]
    }
}
 8019848:	46c0      	nop			; (mov r8, r8)
 801984a:	46bd      	mov	sp, r7
 801984c:	b009      	add	sp, #36	; 0x24
 801984e:	bd90      	pop	{r4, r7, pc}

08019850 <lcp_echo_lowerup>:

/*
 * lcp_echo_lowerup - Start the timer for the LCP frame
 */

static void lcp_echo_lowerup(ppp_pcb *pcb) {
 8019850:	b580      	push	{r7, lr}
 8019852:	b084      	sub	sp, #16
 8019854:	af00      	add	r7, sp, #0
 8019856:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->lcp_fsm;
 8019858:	687b      	ldr	r3, [r7, #4]
 801985a:	3328      	adds	r3, #40	; 0x28
 801985c:	60fb      	str	r3, [r7, #12]

    /* Clear the parameters for generating echo frames */
    pcb->lcp_echos_pending      = 0;
 801985e:	687b      	ldr	r3, [r7, #4]
 8019860:	22d6      	movs	r2, #214	; 0xd6
 8019862:	2100      	movs	r1, #0
 8019864:	5499      	strb	r1, [r3, r2]
    pcb->lcp_echo_number        = 0;
 8019866:	687b      	ldr	r3, [r7, #4]
 8019868:	22d7      	movs	r2, #215	; 0xd7
 801986a:	2100      	movs	r1, #0
 801986c:	5499      	strb	r1, [r3, r2]
    pcb->lcp_echo_timer_running = 0;
 801986e:	687b      	ldr	r3, [r7, #4]
 8019870:	2226      	movs	r2, #38	; 0x26
 8019872:	5c99      	ldrb	r1, [r3, r2]
 8019874:	2010      	movs	r0, #16
 8019876:	4381      	bics	r1, r0
 8019878:	5499      	strb	r1, [r3, r2]
  
    /* If a timeout interval is specified then start the timer */
    if (pcb->settings.lcp_echo_interval != 0)
 801987a:	687b      	ldr	r3, [r7, #4]
 801987c:	7a5b      	ldrb	r3, [r3, #9]
 801987e:	2b00      	cmp	r3, #0
 8019880:	d003      	beq.n	801988a <lcp_echo_lowerup+0x3a>
        LcpEchoCheck (f);
 8019882:	68fb      	ldr	r3, [r7, #12]
 8019884:	0018      	movs	r0, r3
 8019886:	f7ff fecb 	bl	8019620 <LcpEchoCheck>
}
 801988a:	46c0      	nop			; (mov r8, r8)
 801988c:	46bd      	mov	sp, r7
 801988e:	b004      	add	sp, #16
 8019890:	bd80      	pop	{r7, pc}
	...

08019894 <lcp_echo_lowerdown>:

/*
 * lcp_echo_lowerdown - Stop the timer for the LCP frame
 */

static void lcp_echo_lowerdown(ppp_pcb *pcb) {
 8019894:	b580      	push	{r7, lr}
 8019896:	b084      	sub	sp, #16
 8019898:	af00      	add	r7, sp, #0
 801989a:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->lcp_fsm;
 801989c:	687b      	ldr	r3, [r7, #4]
 801989e:	3328      	adds	r3, #40	; 0x28
 80198a0:	60fb      	str	r3, [r7, #12]

    if (pcb->lcp_echo_timer_running != 0) {
 80198a2:	687b      	ldr	r3, [r7, #4]
 80198a4:	2226      	movs	r2, #38	; 0x26
 80198a6:	5c9b      	ldrb	r3, [r3, r2]
 80198a8:	2210      	movs	r2, #16
 80198aa:	4013      	ands	r3, r2
 80198ac:	b2db      	uxtb	r3, r3
 80198ae:	2b00      	cmp	r3, #0
 80198b0:	d00b      	beq.n	80198ca <lcp_echo_lowerdown+0x36>
        UNTIMEOUT (LcpEchoTimeout, f);
 80198b2:	68fa      	ldr	r2, [r7, #12]
 80198b4:	4b07      	ldr	r3, [pc, #28]	; (80198d4 <lcp_echo_lowerdown+0x40>)
 80198b6:	0011      	movs	r1, r2
 80198b8:	0018      	movs	r0, r3
 80198ba:	f7f8 fc25 	bl	8012108 <sys_untimeout>
        pcb->lcp_echo_timer_running = 0;
 80198be:	687b      	ldr	r3, [r7, #4]
 80198c0:	2226      	movs	r2, #38	; 0x26
 80198c2:	5c99      	ldrb	r1, [r3, r2]
 80198c4:	2010      	movs	r0, #16
 80198c6:	4381      	bics	r1, r0
 80198c8:	5499      	strb	r1, [r3, r2]
    }
}
 80198ca:	46c0      	nop			; (mov r8, r8)
 80198cc:	46bd      	mov	sp, r7
 80198ce:	b004      	add	sp, #16
 80198d0:	bd80      	pop	{r7, pc}
 80198d2:	46c0      	nop			; (mov r8, r8)
 80198d4:	080196a1 	.word	0x080196a1

080198d8 <magic_randomize>:
 * this function is called at *truely random* times by the polling
 * and network functions.  Here we only get 16 bits of new random
 * value but we use the previous value to randomize the other 16
 * bits.
 */
void magic_randomize(void) {
 80198d8:	b580      	push	{r7, lr}
 80198da:	af00      	add	r7, sp, #0
    magic_randomized = !0;
    magic_init();
    /* The initialization function also updates the seed. */
  } else {
#endif /* LWIP_RAND */
    magic_randomseed += sys_jiffies();
 80198dc:	f003 f936 	bl	801cb4c <sys_jiffies>
 80198e0:	0002      	movs	r2, r0
 80198e2:	4b04      	ldr	r3, [pc, #16]	; (80198f4 <magic_randomize+0x1c>)
 80198e4:	681b      	ldr	r3, [r3, #0]
 80198e6:	18d2      	adds	r2, r2, r3
 80198e8:	4b02      	ldr	r3, [pc, #8]	; (80198f4 <magic_randomize+0x1c>)
 80198ea:	601a      	str	r2, [r3, #0]
#ifndef LWIP_RAND
  }
#endif /* LWIP_RAND */
}
 80198ec:	46c0      	nop			; (mov r8, r8)
 80198ee:	46bd      	mov	sp, r7
 80198f0:	bd80      	pop	{r7, pc}
 80198f2:	46c0      	nop			; (mov r8, r8)
 80198f4:	20001b84 	.word	0x20001b84

080198f8 <magic>:
 * seed which is randomized by truely random events.
 * Thus the numbers will be truely random unless there have been no
 * operator or network events in which case it will be pseudo random
 * seeded by the real time clock.
 */
u32_t magic(void) {
 80198f8:	b580      	push	{r7, lr}
 80198fa:	af00      	add	r7, sp, #0
#ifdef LWIP_RAND
  return LWIP_RAND() + magic_randomseed;
 80198fc:	f003 f90c 	bl	801cb18 <sys_rand>
 8019900:	0002      	movs	r2, r0
 8019902:	4b03      	ldr	r3, [pc, #12]	; (8019910 <magic+0x18>)
 8019904:	681b      	ldr	r3, [r3, #0]
 8019906:	18d3      	adds	r3, r2, r3
#else /* LWIP_RAND */
  return ((u32_t)rand() << 16) + (u32_t)rand() + magic_randomseed;
#endif /* LWIP_RAND */
}
 8019908:	0018      	movs	r0, r3
 801990a:	46bd      	mov	sp, r7
 801990c:	bd80      	pop	{r7, pc}
 801990e:	46c0      	nop			; (mov r8, r8)
 8019910:	20001b84 	.word	0x20001b84

08019914 <ppp_set_notify_phase_callback>:
  pcb->settings.refuse_mppe_128 = !!(flags & PPP_MPPE_REFUSE_128);
}
#endif /* MPPE_SUPPORT */

#if PPP_NOTIFY_PHASE
void ppp_set_notify_phase_callback(ppp_pcb *pcb, ppp_notify_phase_cb_fn notify_phase_cb) {
 8019914:	b580      	push	{r7, lr}
 8019916:	b082      	sub	sp, #8
 8019918:	af00      	add	r7, sp, #0
 801991a:	6078      	str	r0, [r7, #4]
 801991c:	6039      	str	r1, [r7, #0]
  pcb->notify_phase_cb = notify_phase_cb;
 801991e:	687b      	ldr	r3, [r7, #4]
 8019920:	683a      	ldr	r2, [r7, #0]
 8019922:	619a      	str	r2, [r3, #24]
  notify_phase_cb(pcb, pcb->phase, pcb->ctx_cb);
 8019924:	687b      	ldr	r3, [r7, #4]
 8019926:	2224      	movs	r2, #36	; 0x24
 8019928:	5c99      	ldrb	r1, [r3, r2]
 801992a:	687b      	ldr	r3, [r7, #4]
 801992c:	69da      	ldr	r2, [r3, #28]
 801992e:	6878      	ldr	r0, [r7, #4]
 8019930:	683b      	ldr	r3, [r7, #0]
 8019932:	4798      	blx	r3
}
 8019934:	46c0      	nop			; (mov r8, r8)
 8019936:	46bd      	mov	sp, r7
 8019938:	b002      	add	sp, #8
 801993a:	bd80      	pop	{r7, pc}

0801993c <ppp_connect>:
 * the connection.
 *
 * If this port connects to a modem, the modem connection must be
 * established before calling this.
 */
err_t ppp_connect(ppp_pcb *pcb, u16_t holdoff) {
 801993c:	b580      	push	{r7, lr}
 801993e:	b082      	sub	sp, #8
 8019940:	af00      	add	r7, sp, #0
 8019942:	6078      	str	r0, [r7, #4]
 8019944:	000a      	movs	r2, r1
 8019946:	1cbb      	adds	r3, r7, #2
 8019948:	801a      	strh	r2, [r3, #0]
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb->phase != PPP_PHASE_DEAD) {
 801994a:	687b      	ldr	r3, [r7, #4]
 801994c:	2224      	movs	r2, #36	; 0x24
 801994e:	5c9b      	ldrb	r3, [r3, r2]
 8019950:	2b00      	cmp	r3, #0
 8019952:	d002      	beq.n	801995a <ppp_connect+0x1e>
    return ERR_ALREADY;
 8019954:	2309      	movs	r3, #9
 8019956:	425b      	negs	r3, r3
 8019958:	e01f      	b.n	801999a <ppp_connect+0x5e>
  }

  PPPDEBUG(LOG_DEBUG, ("ppp_connect[%d]: holdoff=%d\n", pcb->netif->num, holdoff));

  magic_randomize();
 801995a:	f7ff ffbd 	bl	80198d8 <magic_randomize>

  if (holdoff == 0) {
 801995e:	1cbb      	adds	r3, r7, #2
 8019960:	881b      	ldrh	r3, [r3, #0]
 8019962:	2b00      	cmp	r3, #0
 8019964:	d105      	bne.n	8019972 <ppp_connect+0x36>
    ppp_do_connect(pcb);
 8019966:	687b      	ldr	r3, [r7, #4]
 8019968:	0018      	movs	r0, r3
 801996a:	f000 f8b1 	bl	8019ad0 <ppp_do_connect>
    return ERR_OK;
 801996e:	2300      	movs	r3, #0
 8019970:	e013      	b.n	801999a <ppp_connect+0x5e>
  }

  new_phase(pcb, PPP_PHASE_HOLDOFF);
 8019972:	687b      	ldr	r3, [r7, #4]
 8019974:	2102      	movs	r1, #2
 8019976:	0018      	movs	r0, r3
 8019978:	f000 fb29 	bl	8019fce <new_phase>
  sys_timeout((u32_t)(holdoff*1000), ppp_do_connect, pcb);
 801997c:	1cbb      	adds	r3, r7, #2
 801997e:	881a      	ldrh	r2, [r3, #0]
 8019980:	0013      	movs	r3, r2
 8019982:	015b      	lsls	r3, r3, #5
 8019984:	1a9b      	subs	r3, r3, r2
 8019986:	009b      	lsls	r3, r3, #2
 8019988:	189b      	adds	r3, r3, r2
 801998a:	00db      	lsls	r3, r3, #3
 801998c:	0018      	movs	r0, r3
 801998e:	687a      	ldr	r2, [r7, #4]
 8019990:	4b04      	ldr	r3, [pc, #16]	; (80199a4 <ppp_connect+0x68>)
 8019992:	0019      	movs	r1, r3
 8019994:	f7f8 fb90 	bl	80120b8 <sys_timeout>
  return ERR_OK;
 8019998:	2300      	movs	r3, #0
}
 801999a:	0018      	movs	r0, r3
 801999c:	46bd      	mov	sp, r7
 801999e:	b002      	add	sp, #8
 80199a0:	bd80      	pop	{r7, pc}
 80199a2:	46c0      	nop			; (mov r8, r8)
 80199a4:	08019ad1 	.word	0x08019ad1

080199a8 <ppp_close>:
 *
 * Return 0 on success, an error code on failure.
 */
err_t
ppp_close(ppp_pcb *pcb, u8_t nocarrier)
{
 80199a8:	b590      	push	{r4, r7, lr}
 80199aa:	b083      	sub	sp, #12
 80199ac:	af00      	add	r7, sp, #0
 80199ae:	6078      	str	r0, [r7, #4]
 80199b0:	000a      	movs	r2, r1
 80199b2:	1cfb      	adds	r3, r7, #3
 80199b4:	701a      	strb	r2, [r3, #0]
  LWIP_ASSERT_CORE_LOCKED();

  pcb->err_code = PPPERR_USER;
 80199b6:	687b      	ldr	r3, [r7, #4]
 80199b8:	2225      	movs	r2, #37	; 0x25
 80199ba:	2105      	movs	r1, #5
 80199bc:	5499      	strb	r1, [r3, r2]

  /* holdoff phase, cancel the reconnection */
  if (pcb->phase == PPP_PHASE_HOLDOFF) {
 80199be:	687b      	ldr	r3, [r7, #4]
 80199c0:	2224      	movs	r2, #36	; 0x24
 80199c2:	5c9b      	ldrb	r3, [r3, r2]
 80199c4:	2b02      	cmp	r3, #2
 80199c6:	d10a      	bne.n	80199de <ppp_close+0x36>
    sys_untimeout(ppp_do_connect, pcb);
 80199c8:	687a      	ldr	r2, [r7, #4]
 80199ca:	4b29      	ldr	r3, [pc, #164]	; (8019a70 <ppp_close+0xc8>)
 80199cc:	0011      	movs	r1, r2
 80199ce:	0018      	movs	r0, r3
 80199d0:	f7f8 fb9a 	bl	8012108 <sys_untimeout>
    new_phase(pcb, PPP_PHASE_DEAD);
 80199d4:	687b      	ldr	r3, [r7, #4]
 80199d6:	2100      	movs	r1, #0
 80199d8:	0018      	movs	r0, r3
 80199da:	f000 faf8 	bl	8019fce <new_phase>
  }

  /* dead phase, nothing to do, call the status callback to be consistent */
  if (pcb->phase == PPP_PHASE_DEAD) {
 80199de:	687b      	ldr	r3, [r7, #4]
 80199e0:	2224      	movs	r2, #36	; 0x24
 80199e2:	5c9b      	ldrb	r3, [r3, r2]
 80199e4:	2b00      	cmp	r3, #0
 80199e6:	d10c      	bne.n	8019a02 <ppp_close+0x5a>
    pcb->link_status_cb(pcb, pcb->err_code, pcb->ctx_cb);
 80199e8:	687b      	ldr	r3, [r7, #4]
 80199ea:	695c      	ldr	r4, [r3, #20]
 80199ec:	687b      	ldr	r3, [r7, #4]
 80199ee:	2225      	movs	r2, #37	; 0x25
 80199f0:	5c9b      	ldrb	r3, [r3, r2]
 80199f2:	0019      	movs	r1, r3
 80199f4:	687b      	ldr	r3, [r7, #4]
 80199f6:	69da      	ldr	r2, [r3, #28]
 80199f8:	687b      	ldr	r3, [r7, #4]
 80199fa:	0018      	movs	r0, r3
 80199fc:	47a0      	blx	r4
    return ERR_OK;
 80199fe:	2300      	movs	r3, #0
 8019a00:	e031      	b.n	8019a66 <ppp_close+0xbe>
  }

  /* Already terminating, nothing to do */
  if (pcb->phase >= PPP_PHASE_TERMINATE) {
 8019a02:	687b      	ldr	r3, [r7, #4]
 8019a04:	2224      	movs	r2, #36	; 0x24
 8019a06:	5c9b      	ldrb	r3, [r3, r2]
 8019a08:	2b0a      	cmp	r3, #10
 8019a0a:	d902      	bls.n	8019a12 <ppp_close+0x6a>
    return ERR_INPROGRESS;
 8019a0c:	2305      	movs	r3, #5
 8019a0e:	425b      	negs	r3, r3
 8019a10:	e029      	b.n	8019a66 <ppp_close+0xbe>
  }

  /* LCP not open, close link protocol */
  if (pcb->phase < PPP_PHASE_ESTABLISH) {
 8019a12:	687b      	ldr	r3, [r7, #4]
 8019a14:	2224      	movs	r2, #36	; 0x24
 8019a16:	5c9b      	ldrb	r3, [r3, r2]
 8019a18:	2b05      	cmp	r3, #5
 8019a1a:	d80a      	bhi.n	8019a32 <ppp_close+0x8a>
    new_phase(pcb, PPP_PHASE_DISCONNECT);
 8019a1c:	687b      	ldr	r3, [r7, #4]
 8019a1e:	210c      	movs	r1, #12
 8019a20:	0018      	movs	r0, r3
 8019a22:	f000 fad4 	bl	8019fce <new_phase>
    ppp_link_terminated(pcb);
 8019a26:	687b      	ldr	r3, [r7, #4]
 8019a28:	0018      	movs	r0, r3
 8019a2a:	f000 fac0 	bl	8019fae <ppp_link_terminated>
    return ERR_OK;
 8019a2e:	2300      	movs	r3, #0
 8019a30:	e019      	b.n	8019a66 <ppp_close+0xbe>
   * to prevent changing the PPP phase FSM in transition phases.
   *
   * Always using nocarrier = 0 is still recommended, this is going to
   * take a little longer time, but is a safer choice from FSM point of view.
   */
  if (nocarrier && pcb->phase == PPP_PHASE_RUNNING) {
 8019a32:	1cfb      	adds	r3, r7, #3
 8019a34:	781b      	ldrb	r3, [r3, #0]
 8019a36:	2b00      	cmp	r3, #0
 8019a38:	d00e      	beq.n	8019a58 <ppp_close+0xb0>
 8019a3a:	687b      	ldr	r3, [r7, #4]
 8019a3c:	2224      	movs	r2, #36	; 0x24
 8019a3e:	5c9b      	ldrb	r3, [r3, r2]
 8019a40:	2b0a      	cmp	r3, #10
 8019a42:	d109      	bne.n	8019a58 <ppp_close+0xb0>
    PPPDEBUG(LOG_DEBUG, ("ppp_close[%d]: carrier lost -> lcp_lowerdown\n", pcb->netif->num));
    lcp_lowerdown(pcb);
 8019a44:	687b      	ldr	r3, [r7, #4]
 8019a46:	0018      	movs	r0, r3
 8019a48:	f7fd ffb2 	bl	80179b0 <lcp_lowerdown>
    /* forced link termination, this will force link protocol to disconnect. */
    link_terminated(pcb);
 8019a4c:	687b      	ldr	r3, [r7, #4]
 8019a4e:	0018      	movs	r0, r3
 8019a50:	f7fa fa9c 	bl	8013f8c <link_terminated>
    return ERR_OK;
 8019a54:	2300      	movs	r3, #0
 8019a56:	e006      	b.n	8019a66 <ppp_close+0xbe>
  }

  /* Disconnect */
  PPPDEBUG(LOG_DEBUG, ("ppp_close[%d]: kill_link -> lcp_close\n", pcb->netif->num));
  /* LCP soft close request. */
  lcp_close(pcb, "User request");
 8019a58:	4a06      	ldr	r2, [pc, #24]	; (8019a74 <ppp_close+0xcc>)
 8019a5a:	687b      	ldr	r3, [r7, #4]
 8019a5c:	0011      	movs	r1, r2
 8019a5e:	0018      	movs	r0, r3
 8019a60:	f7fd ff02 	bl	8017868 <lcp_close>
  return ERR_OK;
 8019a64:	2300      	movs	r3, #0
}
 8019a66:	0018      	movs	r0, r3
 8019a68:	46bd      	mov	sp, r7
 8019a6a:	b003      	add	sp, #12
 8019a6c:	bd90      	pop	{r4, r7, pc}
 8019a6e:	46c0      	nop			; (mov r8, r8)
 8019a70:	08019ad1 	.word	0x08019ad1
 8019a74:	08021ad8 	.word	0x08021ad8

08019a78 <ppp_free>:
 * You must use ppp_close() before if you wish to terminate
 * an established PPP session.
 *
 * Return 0 on success, an error code on failure.
 */
err_t ppp_free(ppp_pcb *pcb) {
 8019a78:	b5b0      	push	{r4, r5, r7, lr}
 8019a7a:	b084      	sub	sp, #16
 8019a7c:	af00      	add	r7, sp, #0
 8019a7e:	6078      	str	r0, [r7, #4]
  err_t err;
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb->phase != PPP_PHASE_DEAD) {
 8019a80:	687b      	ldr	r3, [r7, #4]
 8019a82:	2224      	movs	r2, #36	; 0x24
 8019a84:	5c9b      	ldrb	r3, [r3, r2]
 8019a86:	2b00      	cmp	r3, #0
 8019a88:	d002      	beq.n	8019a90 <ppp_free+0x18>
    return ERR_CONN;
 8019a8a:	230b      	movs	r3, #11
 8019a8c:	425b      	negs	r3, r3
 8019a8e:	e019      	b.n	8019ac4 <ppp_free+0x4c>
  }

  PPPDEBUG(LOG_DEBUG, ("ppp_free[%d]\n", pcb->netif->num));

  netif_remove(pcb->netif);
 8019a90:	687b      	ldr	r3, [r7, #4]
 8019a92:	6a1b      	ldr	r3, [r3, #32]
 8019a94:	0018      	movs	r0, r3
 8019a96:	f7ef fb8f 	bl	80091b8 <netif_remove>

  err = pcb->link_cb->free(pcb, pcb->link_ctx_cb);
 8019a9a:	687b      	ldr	r3, [r7, #4]
 8019a9c:	68db      	ldr	r3, [r3, #12]
 8019a9e:	689a      	ldr	r2, [r3, #8]
 8019aa0:	687b      	ldr	r3, [r7, #4]
 8019aa2:	6919      	ldr	r1, [r3, #16]
 8019aa4:	250f      	movs	r5, #15
 8019aa6:	197c      	adds	r4, r7, r5
 8019aa8:	687b      	ldr	r3, [r7, #4]
 8019aaa:	0018      	movs	r0, r3
 8019aac:	4790      	blx	r2
 8019aae:	0003      	movs	r3, r0
 8019ab0:	7023      	strb	r3, [r4, #0]

  LWIP_MEMPOOL_FREE(PPP_PCB, pcb);
 8019ab2:	687a      	ldr	r2, [r7, #4]
 8019ab4:	4b05      	ldr	r3, [pc, #20]	; (8019acc <ppp_free+0x54>)
 8019ab6:	0011      	movs	r1, r2
 8019ab8:	0018      	movs	r0, r3
 8019aba:	f7ef f973 	bl	8008da4 <memp_free_pool>
  return err;
 8019abe:	197b      	adds	r3, r7, r5
 8019ac0:	781b      	ldrb	r3, [r3, #0]
 8019ac2:	b25b      	sxtb	r3, r3
}
 8019ac4:	0018      	movs	r0, r3
 8019ac6:	46bd      	mov	sp, r7
 8019ac8:	b004      	add	sp, #16
 8019aca:	bdb0      	pop	{r4, r5, r7, pc}
 8019acc:	080226c8 	.word	0x080226c8

08019ad0 <ppp_do_connect>:

/**********************************/
/*** LOCAL FUNCTION DEFINITIONS ***/
/**********************************/

static void ppp_do_connect(void *arg) {
 8019ad0:	b580      	push	{r7, lr}
 8019ad2:	b084      	sub	sp, #16
 8019ad4:	af00      	add	r7, sp, #0
 8019ad6:	6078      	str	r0, [r7, #4]
  ppp_pcb *pcb = (ppp_pcb*)arg;
 8019ad8:	687b      	ldr	r3, [r7, #4]
 8019ada:	60fb      	str	r3, [r7, #12]

  LWIP_ASSERT("pcb->phase == PPP_PHASE_DEAD || pcb->phase == PPP_PHASE_HOLDOFF", pcb->phase == PPP_PHASE_DEAD || pcb->phase == PPP_PHASE_HOLDOFF);
 8019adc:	68fb      	ldr	r3, [r7, #12]
 8019ade:	2224      	movs	r2, #36	; 0x24
 8019ae0:	5c9b      	ldrb	r3, [r3, r2]
 8019ae2:	2b00      	cmp	r3, #0
 8019ae4:	d00b      	beq.n	8019afe <ppp_do_connect+0x2e>
 8019ae6:	68fb      	ldr	r3, [r7, #12]
 8019ae8:	2224      	movs	r2, #36	; 0x24
 8019aea:	5c9b      	ldrb	r3, [r3, r2]
 8019aec:	2b02      	cmp	r3, #2
 8019aee:	d006      	beq.n	8019afe <ppp_do_connect+0x2e>
 8019af0:	4b0b      	ldr	r3, [pc, #44]	; (8019b20 <ppp_do_connect+0x50>)
 8019af2:	22ce      	movs	r2, #206	; 0xce
 8019af4:	32ff      	adds	r2, #255	; 0xff
 8019af6:	490b      	ldr	r1, [pc, #44]	; (8019b24 <ppp_do_connect+0x54>)
 8019af8:	480b      	ldr	r0, [pc, #44]	; (8019b28 <ppp_do_connect+0x58>)
 8019afa:	f7e8 feef 	bl	80028dc <app_debug_rtt_raw>

  new_phase(pcb, PPP_PHASE_INITIALIZE);
 8019afe:	68fb      	ldr	r3, [r7, #12]
 8019b00:	2103      	movs	r1, #3
 8019b02:	0018      	movs	r0, r3
 8019b04:	f000 fa63 	bl	8019fce <new_phase>
  pcb->link_cb->connect(pcb, pcb->link_ctx_cb);
 8019b08:	68fb      	ldr	r3, [r7, #12]
 8019b0a:	68db      	ldr	r3, [r3, #12]
 8019b0c:	681a      	ldr	r2, [r3, #0]
 8019b0e:	68fb      	ldr	r3, [r7, #12]
 8019b10:	6919      	ldr	r1, [r3, #16]
 8019b12:	68fb      	ldr	r3, [r7, #12]
 8019b14:	0018      	movs	r0, r3
 8019b16:	4790      	blx	r2
}
 8019b18:	46c0      	nop			; (mov r8, r8)
 8019b1a:	46bd      	mov	sp, r7
 8019b1c:	b004      	add	sp, #16
 8019b1e:	bd80      	pop	{r7, pc}
 8019b20:	08021ae8 	.word	0x08021ae8
 8019b24:	08021b14 	.word	0x08021b14
 8019b28:	08021b54 	.word	0x08021b54

08019b2c <ppp_netif_init_cb>:

/*
 * ppp_netif_init_cb - netif init callback
 */
static err_t ppp_netif_init_cb(struct netif *netif) {
 8019b2c:	b580      	push	{r7, lr}
 8019b2e:	b082      	sub	sp, #8
 8019b30:	af00      	add	r7, sp, #0
 8019b32:	6078      	str	r0, [r7, #4]
  netif->name[0] = 'p';
 8019b34:	687b      	ldr	r3, [r7, #4]
 8019b36:	2232      	movs	r2, #50	; 0x32
 8019b38:	2170      	movs	r1, #112	; 0x70
 8019b3a:	5499      	strb	r1, [r3, r2]
  netif->name[1] = 'p';
 8019b3c:	687b      	ldr	r3, [r7, #4]
 8019b3e:	2233      	movs	r2, #51	; 0x33
 8019b40:	2170      	movs	r1, #112	; 0x70
 8019b42:	5499      	strb	r1, [r3, r2]
#if PPP_IPV4_SUPPORT
  netif->output = ppp_netif_output_ip4;
 8019b44:	687b      	ldr	r3, [r7, #4]
 8019b46:	4a05      	ldr	r2, [pc, #20]	; (8019b5c <ppp_netif_init_cb+0x30>)
 8019b48:	615a      	str	r2, [r3, #20]
#endif /* PPP_IPV4_SUPPORT */
#if PPP_IPV6_SUPPORT
  netif->output_ip6 = ppp_netif_output_ip6;
#endif /* PPP_IPV6_SUPPORT */
  netif->flags = NETIF_FLAG_UP;
 8019b4a:	687b      	ldr	r3, [r7, #4]
 8019b4c:	2231      	movs	r2, #49	; 0x31
 8019b4e:	2101      	movs	r1, #1
 8019b50:	5499      	strb	r1, [r3, r2]
#if LWIP_NETIF_HOSTNAME
  /* @todo: Initialize interface hostname */
  /* netif_set_hostname(netif, "lwip"); */
#endif /* LWIP_NETIF_HOSTNAME */
  return ERR_OK;
 8019b52:	2300      	movs	r3, #0
}
 8019b54:	0018      	movs	r0, r3
 8019b56:	46bd      	mov	sp, r7
 8019b58:	b002      	add	sp, #8
 8019b5a:	bd80      	pop	{r7, pc}
 8019b5c:	08019b61 	.word	0x08019b61

08019b60 <ppp_netif_output_ip4>:

#if PPP_IPV4_SUPPORT
/*
 * Send an IPv4 packet on the given connection.
 */
static err_t ppp_netif_output_ip4(struct netif *netif, struct pbuf *pb, const ip4_addr_t *ipaddr) {
 8019b60:	b580      	push	{r7, lr}
 8019b62:	b084      	sub	sp, #16
 8019b64:	af00      	add	r7, sp, #0
 8019b66:	60f8      	str	r0, [r7, #12]
 8019b68:	60b9      	str	r1, [r7, #8]
 8019b6a:	607a      	str	r2, [r7, #4]
  LWIP_UNUSED_ARG(ipaddr);
  return ppp_netif_output(netif, pb, PPP_IP);
 8019b6c:	68b9      	ldr	r1, [r7, #8]
 8019b6e:	68fb      	ldr	r3, [r7, #12]
 8019b70:	2221      	movs	r2, #33	; 0x21
 8019b72:	0018      	movs	r0, r3
 8019b74:	f000 f805 	bl	8019b82 <ppp_netif_output>
 8019b78:	0003      	movs	r3, r0
}
 8019b7a:	0018      	movs	r0, r3
 8019b7c:	46bd      	mov	sp, r7
 8019b7e:	b004      	add	sp, #16
 8019b80:	bd80      	pop	{r7, pc}

08019b82 <ppp_netif_output>:
  LWIP_UNUSED_ARG(ipaddr);
  return ppp_netif_output(netif, pb, PPP_IPV6);
}
#endif /* PPP_IPV6_SUPPORT */

static err_t ppp_netif_output(struct netif *netif, struct pbuf *pb, u16_t protocol) {
 8019b82:	b5b0      	push	{r4, r5, r7, lr}
 8019b84:	b088      	sub	sp, #32
 8019b86:	af00      	add	r7, sp, #0
 8019b88:	60f8      	str	r0, [r7, #12]
 8019b8a:	60b9      	str	r1, [r7, #8]
 8019b8c:	1dbb      	adds	r3, r7, #6
 8019b8e:	801a      	strh	r2, [r3, #0]
  ppp_pcb *pcb = (ppp_pcb*)netif->state;
 8019b90:	68fb      	ldr	r3, [r7, #12]
 8019b92:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8019b94:	617b      	str	r3, [r7, #20]
  err_t err;
  struct pbuf *fpb = NULL;
 8019b96:	2300      	movs	r3, #0
 8019b98:	61bb      	str	r3, [r7, #24]

  /* Check that the link is up. */
  if (0
 8019b9a:	1dbb      	adds	r3, r7, #6
 8019b9c:	881b      	ldrh	r3, [r3, #0]
 8019b9e:	2b21      	cmp	r3, #33	; 0x21
 8019ba0:	d107      	bne.n	8019bb2 <ppp_netif_output+0x30>
#if PPP_IPV4_SUPPORT
      || (protocol == PPP_IP && !pcb->if4_up)
 8019ba2:	697b      	ldr	r3, [r7, #20]
 8019ba4:	2226      	movs	r2, #38	; 0x26
 8019ba6:	5c9b      	ldrb	r3, [r3, r2]
 8019ba8:	2208      	movs	r2, #8
 8019baa:	4013      	ands	r3, r2
 8019bac:	b2db      	uxtb	r3, r3
 8019bae:	2b00      	cmp	r3, #0
 8019bb0:	d03d      	beq.n	8019c2e <ppp_netif_output+0xac>
#if VJ_SUPPORT
  /*
   * Attempt Van Jacobson header compression if VJ is configured and
   * this is an IP packet.
   */
  if (protocol == PPP_IP && pcb->vj_enabled) {
 8019bb2:	1dbb      	adds	r3, r7, #6
 8019bb4:	881b      	ldrh	r3, [r3, #0]
 8019bb6:	2b21      	cmp	r3, #33	; 0x21
 8019bb8:	d127      	bne.n	8019c0a <ppp_netif_output+0x88>
 8019bba:	697b      	ldr	r3, [r7, #20]
 8019bbc:	2226      	movs	r2, #38	; 0x26
 8019bbe:	5c9b      	ldrb	r3, [r3, r2]
 8019bc0:	2220      	movs	r2, #32
 8019bc2:	4013      	ands	r3, r2
 8019bc4:	b2db      	uxtb	r3, r3
 8019bc6:	2b00      	cmp	r3, #0
 8019bc8:	d01f      	beq.n	8019c0a <ppp_netif_output+0x88>
    switch (vj_compress_tcp(&pcb->vj_comp, &pb)) {
 8019bca:	697b      	ldr	r3, [r7, #20]
 8019bcc:	33dc      	adds	r3, #220	; 0xdc
 8019bce:	2208      	movs	r2, #8
 8019bd0:	18ba      	adds	r2, r7, r2
 8019bd2:	0011      	movs	r1, r2
 8019bd4:	0018      	movs	r0, r3
 8019bd6:	f001 fd5f 	bl	801b698 <vj_compress_tcp>
 8019bda:	0003      	movs	r3, r0
 8019bdc:	2b80      	cmp	r3, #128	; 0x80
 8019bde:	d005      	beq.n	8019bec <ppp_netif_output+0x6a>
 8019be0:	dc10      	bgt.n	8019c04 <ppp_netif_output+0x82>
 8019be2:	2b40      	cmp	r3, #64	; 0x40
 8019be4:	d013      	beq.n	8019c0e <ppp_netif_output+0x8c>
 8019be6:	2b70      	cmp	r3, #112	; 0x70
 8019be8:	d006      	beq.n	8019bf8 <ppp_netif_output+0x76>
 8019bea:	e00b      	b.n	8019c04 <ppp_netif_output+0x82>
           protocol = PPP_IP; */
        break;
      case TYPE_COMPRESSED_TCP:
        /* vj_compress_tcp() returns a new allocated pbuf, indicate we should free
         * our duplicated pbuf later */
        fpb = pb;
 8019bec:	68bb      	ldr	r3, [r7, #8]
 8019bee:	61bb      	str	r3, [r7, #24]
        protocol = PPP_VJC_COMP;
 8019bf0:	1dbb      	adds	r3, r7, #6
 8019bf2:	222d      	movs	r2, #45	; 0x2d
 8019bf4:	801a      	strh	r2, [r3, #0]
        break;
 8019bf6:	e00b      	b.n	8019c10 <ppp_netif_output+0x8e>
      case TYPE_UNCOMPRESSED_TCP:
        /* vj_compress_tcp() returns a new allocated pbuf, indicate we should free
         * our duplicated pbuf later */
        fpb = pb;
 8019bf8:	68bb      	ldr	r3, [r7, #8]
 8019bfa:	61bb      	str	r3, [r7, #24]
        protocol = PPP_VJC_UNCOMP;
 8019bfc:	1dbb      	adds	r3, r7, #6
 8019bfe:	222f      	movs	r2, #47	; 0x2f
 8019c00:	801a      	strh	r2, [r3, #0]
        break;
 8019c02:	e005      	b.n	8019c10 <ppp_netif_output+0x8e>
      default:
        PPPDEBUG(LOG_WARNING, ("ppp_netif_output[%d]: bad IP packet\n", pcb->netif->num));
        LINK_STATS_INC(link.proterr);
        LINK_STATS_INC(link.drop);
        MIB2_STATS_NETIF_INC(pcb->netif, ifoutdiscards);
        return ERR_VAL;
 8019c04:	2306      	movs	r3, #6
 8019c06:	425b      	negs	r3, r3
 8019c08:	e021      	b.n	8019c4e <ppp_netif_output+0xcc>
    }
  }
 8019c0a:	46c0      	nop			; (mov r8, r8)
 8019c0c:	e000      	b.n	8019c10 <ppp_netif_output+0x8e>
        break;
 8019c0e:	46c0      	nop			; (mov r8, r8)
    PPPDEBUG(LOG_ERR, ("ppp_netif_output[%d]: bad CCP transmit method\n", pcb->netif->num));
    goto err_rte_drop; /* Cannot really happen, we only negotiate what we are able to do */
  }
#endif /* CCP_SUPPORT */

  err = pcb->link_cb->netif_output(pcb, pcb->link_ctx_cb, pb, protocol);
 8019c10:	697b      	ldr	r3, [r7, #20]
 8019c12:	68db      	ldr	r3, [r3, #12]
 8019c14:	691d      	ldr	r5, [r3, #16]
 8019c16:	697b      	ldr	r3, [r7, #20]
 8019c18:	6919      	ldr	r1, [r3, #16]
 8019c1a:	68ba      	ldr	r2, [r7, #8]
 8019c1c:	231f      	movs	r3, #31
 8019c1e:	18fc      	adds	r4, r7, r3
 8019c20:	1dbb      	adds	r3, r7, #6
 8019c22:	881b      	ldrh	r3, [r3, #0]
 8019c24:	6978      	ldr	r0, [r7, #20]
 8019c26:	47a8      	blx	r5
 8019c28:	0003      	movs	r3, r0
 8019c2a:	7023      	strb	r3, [r4, #0]
  goto err;
 8019c2c:	e004      	b.n	8019c38 <ppp_netif_output+0xb6>
    goto err_rte_drop;
 8019c2e:	46c0      	nop			; (mov r8, r8)

err_rte_drop:
  err = ERR_RTE;
 8019c30:	231f      	movs	r3, #31
 8019c32:	18fb      	adds	r3, r7, r3
 8019c34:	22fc      	movs	r2, #252	; 0xfc
 8019c36:	701a      	strb	r2, [r3, #0]
  LINK_STATS_INC(link.rterr);
  LINK_STATS_INC(link.drop);
  MIB2_STATS_NETIF_INC(netif, ifoutdiscards);
err:
  if (fpb) {
 8019c38:	69bb      	ldr	r3, [r7, #24]
 8019c3a:	2b00      	cmp	r3, #0
 8019c3c:	d003      	beq.n	8019c46 <ppp_netif_output+0xc4>
    pbuf_free(fpb);
 8019c3e:	69bb      	ldr	r3, [r7, #24]
 8019c40:	0018      	movs	r0, r3
 8019c42:	f7ef ffc5 	bl	8009bd0 <pbuf_free>
  }
  return err;
 8019c46:	231f      	movs	r3, #31
 8019c48:	18fb      	adds	r3, r7, r3
 8019c4a:	781b      	ldrb	r3, [r3, #0]
 8019c4c:	b25b      	sxtb	r3, r3
}
 8019c4e:	0018      	movs	r0, r3
 8019c50:	46bd      	mov	sp, r7
 8019c52:	b008      	add	sp, #32
 8019c54:	bdb0      	pop	{r4, r5, r7, pc}
	...

08019c58 <ppp_new>:
 * attempt to negotiate the LCP session.
 *
 * Return a new PPP connection control block pointer
 * on success or a null pointer on failure.
 */
ppp_pcb *ppp_new(struct netif *pppif, const struct link_callbacks *callbacks, void *link_ctx_cb, ppp_link_status_cb_fn link_status_cb, void *ctx_cb) {
 8019c58:	b590      	push	{r4, r7, lr}
 8019c5a:	b08d      	sub	sp, #52	; 0x34
 8019c5c:	af04      	add	r7, sp, #16
 8019c5e:	60f8      	str	r0, [r7, #12]
 8019c60:	60b9      	str	r1, [r7, #8]
 8019c62:	607a      	str	r2, [r7, #4]
 8019c64:	603b      	str	r3, [r7, #0]
  const struct protent *protp;
  int i;

  /* PPP is single-threaded: without a callback,
   * there is no way to know when the link is up. */
  if (link_status_cb == NULL) {
 8019c66:	683b      	ldr	r3, [r7, #0]
 8019c68:	2b00      	cmp	r3, #0
 8019c6a:	d101      	bne.n	8019c70 <ppp_new+0x18>
    return NULL;
 8019c6c:	2300      	movs	r3, #0
 8019c6e:	e065      	b.n	8019d3c <ppp_new+0xe4>
  }

  pcb = (ppp_pcb*)LWIP_MEMPOOL_ALLOC(PPP_PCB);
 8019c70:	4b34      	ldr	r3, [pc, #208]	; (8019d44 <ppp_new+0xec>)
 8019c72:	0018      	movs	r0, r3
 8019c74:	f7ef f82a 	bl	8008ccc <memp_malloc_pool>
 8019c78:	0003      	movs	r3, r0
 8019c7a:	61bb      	str	r3, [r7, #24]
  if (pcb == NULL) {
 8019c7c:	69bb      	ldr	r3, [r7, #24]
 8019c7e:	2b00      	cmp	r3, #0
 8019c80:	d101      	bne.n	8019c86 <ppp_new+0x2e>
    return NULL;
 8019c82:	2300      	movs	r3, #0
 8019c84:	e05a      	b.n	8019d3c <ppp_new+0xe4>
  }

  memset(pcb, 0, sizeof(ppp_pcb));
 8019c86:	4a30      	ldr	r2, [pc, #192]	; (8019d48 <ppp_new+0xf0>)
 8019c88:	69bb      	ldr	r3, [r7, #24]
 8019c8a:	2100      	movs	r1, #0
 8019c8c:	0018      	movs	r0, r3
 8019c8e:	f002 ffc3 	bl	801cc18 <memset>
  pcb->settings.eap_timeout_time = EAP_DEFTIMEOUT;
  pcb->settings.eap_max_transmits = EAP_DEFTRANSMITS;
#endif /* PPP_SERVER */
#endif /* EAP_SUPPORT */

  pcb->settings.lcp_loopbackfail = LCP_DEFLOOPBACKFAIL;
 8019c92:	69bb      	ldr	r3, [r7, #24]
 8019c94:	220a      	movs	r2, #10
 8019c96:	721a      	strb	r2, [r3, #8]
  pcb->settings.lcp_echo_interval = LCP_ECHOINTERVAL;
 8019c98:	69bb      	ldr	r3, [r7, #24]
 8019c9a:	2200      	movs	r2, #0
 8019c9c:	725a      	strb	r2, [r3, #9]
  pcb->settings.lcp_echo_fails = LCP_MAXECHOFAILS;
 8019c9e:	69bb      	ldr	r3, [r7, #24]
 8019ca0:	2203      	movs	r2, #3
 8019ca2:	729a      	strb	r2, [r3, #10]

  pcb->settings.fsm_timeout_time = FSM_DEFTIMEOUT;
 8019ca4:	69bb      	ldr	r3, [r7, #24]
 8019ca6:	2206      	movs	r2, #6
 8019ca8:	711a      	strb	r2, [r3, #4]
  pcb->settings.fsm_max_conf_req_transmits = FSM_DEFMAXCONFREQS;
 8019caa:	69bb      	ldr	r3, [r7, #24]
 8019cac:	220a      	movs	r2, #10
 8019cae:	715a      	strb	r2, [r3, #5]
  pcb->settings.fsm_max_term_transmits = FSM_DEFMAXTERMREQS;
 8019cb0:	69bb      	ldr	r3, [r7, #24]
 8019cb2:	2202      	movs	r2, #2
 8019cb4:	719a      	strb	r2, [r3, #6]
  pcb->settings.fsm_max_nak_loops = FSM_DEFMAXNAKLOOPS;
 8019cb6:	69bb      	ldr	r3, [r7, #24]
 8019cb8:	2205      	movs	r2, #5
 8019cba:	71da      	strb	r2, [r3, #7]

  pcb->netif = pppif;
 8019cbc:	69bb      	ldr	r3, [r7, #24]
 8019cbe:	68fa      	ldr	r2, [r7, #12]
 8019cc0:	621a      	str	r2, [r3, #32]
  MIB2_INIT_NETIF(pppif, snmp_ifType_ppp, 0);
  if (!netif_add(pcb->netif,
 8019cc2:	69bb      	ldr	r3, [r7, #24]
 8019cc4:	6a18      	ldr	r0, [r3, #32]
 8019cc6:	4c21      	ldr	r4, [pc, #132]	; (8019d4c <ppp_new+0xf4>)
 8019cc8:	4a21      	ldr	r2, [pc, #132]	; (8019d50 <ppp_new+0xf8>)
 8019cca:	4920      	ldr	r1, [pc, #128]	; (8019d4c <ppp_new+0xf4>)
 8019ccc:	2300      	movs	r3, #0
 8019cce:	9302      	str	r3, [sp, #8]
 8019cd0:	4b20      	ldr	r3, [pc, #128]	; (8019d54 <ppp_new+0xfc>)
 8019cd2:	9301      	str	r3, [sp, #4]
 8019cd4:	69bb      	ldr	r3, [r7, #24]
 8019cd6:	9300      	str	r3, [sp, #0]
 8019cd8:	0023      	movs	r3, r4
 8019cda:	f7ef f8af 	bl	8008e3c <netif_add>
 8019cde:	1e03      	subs	r3, r0, #0
 8019ce0:	d107      	bne.n	8019cf2 <ppp_new+0x9a>
#if LWIP_IPV4
                 IP4_ADDR_ANY4, IP4_ADDR_BROADCAST, IP4_ADDR_ANY4,
#endif /* LWIP_IPV4 */
                 (void *)pcb, ppp_netif_init_cb, NULL)) {
    LWIP_MEMPOOL_FREE(PPP_PCB, pcb);
 8019ce2:	69ba      	ldr	r2, [r7, #24]
 8019ce4:	4b17      	ldr	r3, [pc, #92]	; (8019d44 <ppp_new+0xec>)
 8019ce6:	0011      	movs	r1, r2
 8019ce8:	0018      	movs	r0, r3
 8019cea:	f7ef f85b 	bl	8008da4 <memp_free_pool>
    PPPDEBUG(LOG_ERR, ("ppp_new: netif_add failed\n"));
    return NULL;
 8019cee:	2300      	movs	r3, #0
 8019cf0:	e024      	b.n	8019d3c <ppp_new+0xe4>
  }

  pcb->link_cb = callbacks;
 8019cf2:	69bb      	ldr	r3, [r7, #24]
 8019cf4:	68ba      	ldr	r2, [r7, #8]
 8019cf6:	60da      	str	r2, [r3, #12]
  pcb->link_ctx_cb = link_ctx_cb;
 8019cf8:	69bb      	ldr	r3, [r7, #24]
 8019cfa:	687a      	ldr	r2, [r7, #4]
 8019cfc:	611a      	str	r2, [r3, #16]
  pcb->link_status_cb = link_status_cb;
 8019cfe:	69bb      	ldr	r3, [r7, #24]
 8019d00:	683a      	ldr	r2, [r7, #0]
 8019d02:	615a      	str	r2, [r3, #20]
  pcb->ctx_cb = ctx_cb;
 8019d04:	69bb      	ldr	r3, [r7, #24]
 8019d06:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8019d08:	61da      	str	r2, [r3, #28]

  /*
   * Initialize each protocol.
   */
  for (i = 0; (protp = protocols[i]) != NULL; ++i) {
 8019d0a:	2300      	movs	r3, #0
 8019d0c:	61fb      	str	r3, [r7, #28]
 8019d0e:	e007      	b.n	8019d20 <ppp_new+0xc8>
      (*protp->init)(pcb);
 8019d10:	697b      	ldr	r3, [r7, #20]
 8019d12:	685b      	ldr	r3, [r3, #4]
 8019d14:	69ba      	ldr	r2, [r7, #24]
 8019d16:	0010      	movs	r0, r2
 8019d18:	4798      	blx	r3
  for (i = 0; (protp = protocols[i]) != NULL; ++i) {
 8019d1a:	69fb      	ldr	r3, [r7, #28]
 8019d1c:	3301      	adds	r3, #1
 8019d1e:	61fb      	str	r3, [r7, #28]
 8019d20:	4b0d      	ldr	r3, [pc, #52]	; (8019d58 <ppp_new+0x100>)
 8019d22:	69fa      	ldr	r2, [r7, #28]
 8019d24:	0092      	lsls	r2, r2, #2
 8019d26:	58d3      	ldr	r3, [r2, r3]
 8019d28:	617b      	str	r3, [r7, #20]
 8019d2a:	697b      	ldr	r3, [r7, #20]
 8019d2c:	2b00      	cmp	r3, #0
 8019d2e:	d1ef      	bne.n	8019d10 <ppp_new+0xb8>
  }

  new_phase(pcb, PPP_PHASE_DEAD);
 8019d30:	69bb      	ldr	r3, [r7, #24]
 8019d32:	2100      	movs	r1, #0
 8019d34:	0018      	movs	r0, r3
 8019d36:	f000 f94a 	bl	8019fce <new_phase>
  return pcb;
 8019d3a:	69bb      	ldr	r3, [r7, #24]
}
 8019d3c:	0018      	movs	r0, r3
 8019d3e:	46bd      	mov	sp, r7
 8019d40:	b009      	add	sp, #36	; 0x24
 8019d42:	bd90      	pop	{r4, r7, pc}
 8019d44:	080226c8 	.word	0x080226c8
 8019d48:	00001264 	.word	0x00001264
 8019d4c:	0802246c 	.word	0x0802246c
 8019d50:	08022470 	.word	0x08022470
 8019d54:	08019b2d 	.word	0x08019b2d
 8019d58:	080226d8 	.word	0x080226d8

08019d5c <ppp_start>:

/** Initiate LCP open request */
void ppp_start(ppp_pcb *pcb) {
 8019d5c:	b580      	push	{r7, lr}
 8019d5e:	b082      	sub	sp, #8
 8019d60:	af00      	add	r7, sp, #0
 8019d62:	6078      	str	r0, [r7, #4]
  pcb->mppe_keys_set = 0;
  memset(&pcb->mppe_comp, 0, sizeof(pcb->mppe_comp));
  memset(&pcb->mppe_decomp, 0, sizeof(pcb->mppe_decomp));
#endif /* MPPE_SUPPORT */
#if VJ_SUPPORT
  vj_compress_init(&pcb->vj_comp);
 8019d64:	687b      	ldr	r3, [r7, #4]
 8019d66:	33dc      	adds	r3, #220	; 0xdc
 8019d68:	0018      	movs	r0, r3
 8019d6a:	f001 fc3e 	bl	801b5ea <vj_compress_init>
#endif /* VJ_SUPPORT */

  /* Start protocol */
  new_phase(pcb, PPP_PHASE_ESTABLISH);
 8019d6e:	687b      	ldr	r3, [r7, #4]
 8019d70:	2106      	movs	r1, #6
 8019d72:	0018      	movs	r0, r3
 8019d74:	f000 f92b 	bl	8019fce <new_phase>
  lcp_open(pcb);
 8019d78:	687b      	ldr	r3, [r7, #4]
 8019d7a:	0018      	movs	r0, r3
 8019d7c:	f7fd fd3e 	bl	80177fc <lcp_open>
  lcp_lowerup(pcb);
 8019d80:	687b      	ldr	r3, [r7, #4]
 8019d82:	0018      	movs	r0, r3
 8019d84:	f7fd fdb4 	bl	80178f0 <lcp_lowerup>
  PPPDEBUG(LOG_DEBUG, ("ppp_start[%d]: finished\n", pcb->netif->num));
}
 8019d88:	46c0      	nop			; (mov r8, r8)
 8019d8a:	46bd      	mov	sp, r7
 8019d8c:	b002      	add	sp, #8
 8019d8e:	bd80      	pop	{r7, pc}

08019d90 <ppp_link_end>:
  pcb->err_code = PPPERR_OPEN;
  pcb->link_status_cb(pcb, pcb->err_code, pcb->ctx_cb);
}

/** Called when link is normally down (i.e. it was asked to end) */
void ppp_link_end(ppp_pcb *pcb) {
 8019d90:	b590      	push	{r4, r7, lr}
 8019d92:	b083      	sub	sp, #12
 8019d94:	af00      	add	r7, sp, #0
 8019d96:	6078      	str	r0, [r7, #4]
  PPPDEBUG(LOG_DEBUG, ("ppp_link_end[%d]\n", pcb->netif->num));
  new_phase(pcb, PPP_PHASE_DEAD);
 8019d98:	687b      	ldr	r3, [r7, #4]
 8019d9a:	2100      	movs	r1, #0
 8019d9c:	0018      	movs	r0, r3
 8019d9e:	f000 f916 	bl	8019fce <new_phase>
  if (pcb->err_code == PPPERR_NONE) {
 8019da2:	687b      	ldr	r3, [r7, #4]
 8019da4:	2225      	movs	r2, #37	; 0x25
 8019da6:	5c9b      	ldrb	r3, [r3, r2]
 8019da8:	2b00      	cmp	r3, #0
 8019daa:	d103      	bne.n	8019db4 <ppp_link_end+0x24>
    pcb->err_code = PPPERR_CONNECT;
 8019dac:	687b      	ldr	r3, [r7, #4]
 8019dae:	2225      	movs	r2, #37	; 0x25
 8019db0:	2106      	movs	r1, #6
 8019db2:	5499      	strb	r1, [r3, r2]
  }
  pcb->link_status_cb(pcb, pcb->err_code, pcb->ctx_cb);
 8019db4:	687b      	ldr	r3, [r7, #4]
 8019db6:	695c      	ldr	r4, [r3, #20]
 8019db8:	687b      	ldr	r3, [r7, #4]
 8019dba:	2225      	movs	r2, #37	; 0x25
 8019dbc:	5c9b      	ldrb	r3, [r3, r2]
 8019dbe:	0019      	movs	r1, r3
 8019dc0:	687b      	ldr	r3, [r7, #4]
 8019dc2:	69da      	ldr	r2, [r3, #28]
 8019dc4:	687b      	ldr	r3, [r7, #4]
 8019dc6:	0018      	movs	r0, r3
 8019dc8:	47a0      	blx	r4
}
 8019dca:	46c0      	nop			; (mov r8, r8)
 8019dcc:	46bd      	mov	sp, r7
 8019dce:	b003      	add	sp, #12
 8019dd0:	bd90      	pop	{r4, r7, pc}
	...

08019dd4 <ppp_input>:

/*
 * Pass the processed input packet to the appropriate handler.
 * This function and all handlers run in the context of the tcpip_thread
 */
void ppp_input(ppp_pcb *pcb, struct pbuf *pb) {
 8019dd4:	b590      	push	{r4, r7, lr}
 8019dd6:	b087      	sub	sp, #28
 8019dd8:	af00      	add	r7, sp, #0
 8019dda:	6078      	str	r0, [r7, #4]
 8019ddc:	6039      	str	r1, [r7, #0]
  u16_t protocol;
#if PPP_DEBUG && PPP_PROTOCOLNAME
    const char *pname;
#endif /* PPP_DEBUG && PPP_PROTOCOLNAME */

  magic_randomize();
 8019dde:	f7ff fd7b 	bl	80198d8 <magic_randomize>

  if (pb->len < 2) {
 8019de2:	683b      	ldr	r3, [r7, #0]
 8019de4:	895b      	ldrh	r3, [r3, #10]
 8019de6:	2b01      	cmp	r3, #1
 8019de8:	d800      	bhi.n	8019dec <ppp_input+0x18>
 8019dea:	e0b6      	b.n	8019f5a <ppp_input+0x186>
    PPPDEBUG(LOG_ERR, ("ppp_input[%d]: packet too short\n", pcb->netif->num));
    goto drop;
  }
  protocol = (((u8_t *)pb->payload)[0] << 8) | ((u8_t*)pb->payload)[1];
 8019dec:	683b      	ldr	r3, [r7, #0]
 8019dee:	685b      	ldr	r3, [r3, #4]
 8019df0:	781b      	ldrb	r3, [r3, #0]
 8019df2:	021b      	lsls	r3, r3, #8
 8019df4:	b21a      	sxth	r2, r3
 8019df6:	683b      	ldr	r3, [r7, #0]
 8019df8:	685b      	ldr	r3, [r3, #4]
 8019dfa:	3301      	adds	r3, #1
 8019dfc:	781b      	ldrb	r3, [r3, #0]
 8019dfe:	b21b      	sxth	r3, r3
 8019e00:	4313      	orrs	r3, r2
 8019e02:	b21a      	sxth	r2, r3
 8019e04:	2412      	movs	r4, #18
 8019e06:	193b      	adds	r3, r7, r4
 8019e08:	801a      	strh	r2, [r3, #0]

#if PRINTPKT_SUPPORT
  ppp_dump_packet(pcb, "rcvd", (unsigned char *)pb->payload, pb->len);
#endif /* PRINTPKT_SUPPORT */

  pbuf_remove_header(pb, sizeof(protocol));
 8019e0a:	683b      	ldr	r3, [r7, #0]
 8019e0c:	2102      	movs	r1, #2
 8019e0e:	0018      	movs	r0, r3
 8019e10:	f7ef fe06 	bl	8009a20 <pbuf_remove_header>
  MIB2_STATS_NETIF_ADD(pcb->netif, ifinoctets, pb->tot_len);

  /*
   * Toss all non-LCP packets unless LCP is OPEN.
   */
  if (protocol != PPP_LCP && pcb->lcp_fsm.state != PPP_FSM_OPENED) {
 8019e14:	193b      	adds	r3, r7, r4
 8019e16:	881b      	ldrh	r3, [r3, #0]
 8019e18:	4a57      	ldr	r2, [pc, #348]	; (8019f78 <ppp_input+0x1a4>)
 8019e1a:	4293      	cmp	r3, r2
 8019e1c:	d009      	beq.n	8019e32 <ppp_input+0x5e>
 8019e1e:	687b      	ldr	r3, [r7, #4]
 8019e20:	2238      	movs	r2, #56	; 0x38
 8019e22:	5c9b      	ldrb	r3, [r3, r2]
 8019e24:	2b09      	cmp	r3, #9
 8019e26:	d004      	beq.n	8019e32 <ppp_input+0x5e>
    ppp_dbglog("Discarded non-LCP packet when LCP not open");
 8019e28:	4b54      	ldr	r3, [pc, #336]	; (8019f7c <ppp_input+0x1a8>)
 8019e2a:	0018      	movs	r0, r3
 8019e2c:	f001 fbc9 	bl	801b5c2 <ppp_dbglog>
    goto drop;
 8019e30:	e09a      	b.n	8019f68 <ppp_input+0x194>

  /*
   * Until we get past the authentication phase, toss all packets
   * except LCP, LQR and authentication packets.
   */
  if (pcb->phase <= PPP_PHASE_AUTHENTICATE
 8019e32:	687b      	ldr	r3, [r7, #4]
 8019e34:	2224      	movs	r2, #36	; 0x24
 8019e36:	5c9b      	ldrb	r3, [r3, r2]
 8019e38:	2b07      	cmp	r3, #7
 8019e3a:	d810      	bhi.n	8019e5e <ppp_input+0x8a>
   && !(protocol == PPP_LCP
 8019e3c:	2112      	movs	r1, #18
 8019e3e:	187b      	adds	r3, r7, r1
 8019e40:	881b      	ldrh	r3, [r3, #0]
 8019e42:	4a4d      	ldr	r2, [pc, #308]	; (8019f78 <ppp_input+0x1a4>)
 8019e44:	4293      	cmp	r3, r2
 8019e46:	d00a      	beq.n	8019e5e <ppp_input+0x8a>
#endif /* CHAP_SUPPORT */
#if EAP_SUPPORT
   || protocol == PPP_EAP
#endif /* EAP_SUPPORT */
   )) {
    ppp_dbglog("discarding proto 0x%x in phase %d", protocol, pcb->phase);
 8019e48:	187b      	adds	r3, r7, r1
 8019e4a:	8819      	ldrh	r1, [r3, #0]
 8019e4c:	687b      	ldr	r3, [r7, #4]
 8019e4e:	2224      	movs	r2, #36	; 0x24
 8019e50:	5c9b      	ldrb	r3, [r3, r2]
 8019e52:	001a      	movs	r2, r3
 8019e54:	4b4a      	ldr	r3, [pc, #296]	; (8019f80 <ppp_input+0x1ac>)
 8019e56:	0018      	movs	r0, r3
 8019e58:	f001 fbb3 	bl	801b5c2 <ppp_dbglog>
    goto drop;
 8019e5c:	e084      	b.n	8019f68 <ppp_input+0x194>
      pbuf_remove_header(pb, 2);
    }
  }
#endif /* CCP_SUPPORT */

  switch(protocol) {
 8019e5e:	2312      	movs	r3, #18
 8019e60:	18fb      	adds	r3, r7, r3
 8019e62:	881b      	ldrh	r3, [r3, #0]
 8019e64:	2b2f      	cmp	r3, #47	; 0x2f
 8019e66:	d027      	beq.n	8019eb8 <ppp_input+0xe4>
 8019e68:	dc3f      	bgt.n	8019eea <ppp_input+0x116>
 8019e6a:	2b21      	cmp	r3, #33	; 0x21
 8019e6c:	d002      	beq.n	8019e74 <ppp_input+0xa0>
 8019e6e:	2b2d      	cmp	r3, #45	; 0x2d
 8019e70:	d008      	beq.n	8019e84 <ppp_input+0xb0>
 8019e72:	e03a      	b.n	8019eea <ppp_input+0x116>

#if PPP_IPV4_SUPPORT
    case PPP_IP:            /* Internet Protocol */
      PPPDEBUG(LOG_INFO, ("ppp_input[%d]: ip in pbuf len=%d\n", pcb->netif->num, pb->tot_len));
      ip4_input(pb, pcb->netif);
 8019e74:	683a      	ldr	r2, [r7, #0]
 8019e76:	687b      	ldr	r3, [r7, #4]
 8019e78:	6a1b      	ldr	r3, [r3, #32]
 8019e7a:	0019      	movs	r1, r3
 8019e7c:	0010      	movs	r0, r2
 8019e7e:	f7f9 facb 	bl	8013418 <ip4_input>
      return;
 8019e82:	e075      	b.n	8019f70 <ppp_input+0x19c>
      /*
       * Clip off the VJ header and prepend the rebuilt TCP/IP header and
       * pass the result to IP.
       */
      PPPDEBUG(LOG_INFO, ("ppp_input[%d]: vj_comp in pbuf len=%d\n", pcb->netif->num, pb->tot_len));
      if (pcb->vj_enabled && vj_uncompress_tcp(&pb, &pcb->vj_comp) >= 0) {
 8019e84:	687b      	ldr	r3, [r7, #4]
 8019e86:	2226      	movs	r2, #38	; 0x26
 8019e88:	5c9b      	ldrb	r3, [r3, r2]
 8019e8a:	2220      	movs	r2, #32
 8019e8c:	4013      	ands	r3, r2
 8019e8e:	b2db      	uxtb	r3, r3
 8019e90:	2b00      	cmp	r3, #0
 8019e92:	d064      	beq.n	8019f5e <ppp_input+0x18a>
 8019e94:	687b      	ldr	r3, [r7, #4]
 8019e96:	33dc      	adds	r3, #220	; 0xdc
 8019e98:	001a      	movs	r2, r3
 8019e9a:	003b      	movs	r3, r7
 8019e9c:	0011      	movs	r1, r2
 8019e9e:	0018      	movs	r0, r3
 8019ea0:	f002 f8fe 	bl	801c0a0 <vj_uncompress_tcp>
 8019ea4:	1e03      	subs	r3, r0, #0
 8019ea6:	db5a      	blt.n	8019f5e <ppp_input+0x18a>
        ip4_input(pb, pcb->netif);
 8019ea8:	683a      	ldr	r2, [r7, #0]
 8019eaa:	687b      	ldr	r3, [r7, #4]
 8019eac:	6a1b      	ldr	r3, [r3, #32]
 8019eae:	0019      	movs	r1, r3
 8019eb0:	0010      	movs	r0, r2
 8019eb2:	f7f9 fab1 	bl	8013418 <ip4_input>
        return;
 8019eb6:	e05b      	b.n	8019f70 <ppp_input+0x19c>
      /*
       * Process the TCP/IP header for VJ header compression and then pass
       * the packet to IP.
       */
      PPPDEBUG(LOG_INFO, ("ppp_input[%d]: vj_un in pbuf len=%d\n", pcb->netif->num, pb->tot_len));
      if (pcb->vj_enabled && vj_uncompress_uncomp(pb, &pcb->vj_comp) >= 0) {
 8019eb8:	687b      	ldr	r3, [r7, #4]
 8019eba:	2226      	movs	r2, #38	; 0x26
 8019ebc:	5c9b      	ldrb	r3, [r3, r2]
 8019ebe:	2220      	movs	r2, #32
 8019ec0:	4013      	ands	r3, r2
 8019ec2:	b2db      	uxtb	r3, r3
 8019ec4:	2b00      	cmp	r3, #0
 8019ec6:	d04c      	beq.n	8019f62 <ppp_input+0x18e>
 8019ec8:	683a      	ldr	r2, [r7, #0]
 8019eca:	687b      	ldr	r3, [r7, #4]
 8019ecc:	33dc      	adds	r3, #220	; 0xdc
 8019ece:	0019      	movs	r1, r3
 8019ed0:	0010      	movs	r0, r2
 8019ed2:	f002 f877 	bl	801bfc4 <vj_uncompress_uncomp>
 8019ed6:	1e03      	subs	r3, r0, #0
 8019ed8:	db43      	blt.n	8019f62 <ppp_input+0x18e>
        ip4_input(pb, pcb->netif);
 8019eda:	683a      	ldr	r2, [r7, #0]
 8019edc:	687b      	ldr	r3, [r7, #4]
 8019ede:	6a1b      	ldr	r3, [r3, #32]
 8019ee0:	0019      	movs	r1, r3
 8019ee2:	0010      	movs	r0, r2
 8019ee4:	f7f9 fa98 	bl	8013418 <ip4_input>
        return;
 8019ee8:	e042      	b.n	8019f70 <ppp_input+0x19c>
      const struct protent *protp;

      /*
       * Upcall the proper protocol input routine.
       */
      for (i = 0; (protp = protocols[i]) != NULL; ++i) {
 8019eea:	2300      	movs	r3, #0
 8019eec:	617b      	str	r3, [r7, #20]
 8019eee:	e01b      	b.n	8019f28 <ppp_input+0x154>
        if (protp->protocol == protocol) {
 8019ef0:	68fb      	ldr	r3, [r7, #12]
 8019ef2:	881b      	ldrh	r3, [r3, #0]
 8019ef4:	2212      	movs	r2, #18
 8019ef6:	18ba      	adds	r2, r7, r2
 8019ef8:	8812      	ldrh	r2, [r2, #0]
 8019efa:	429a      	cmp	r2, r3
 8019efc:	d111      	bne.n	8019f22 <ppp_input+0x14e>
          pb = pbuf_coalesce(pb, PBUF_RAW);
 8019efe:	683b      	ldr	r3, [r7, #0]
 8019f00:	2100      	movs	r1, #0
 8019f02:	0018      	movs	r0, r3
 8019f04:	f7f0 fb1c 	bl	800a540 <pbuf_coalesce>
 8019f08:	0003      	movs	r3, r0
 8019f0a:	603b      	str	r3, [r7, #0]
          (*protp->input)(pcb, (u8_t*)pb->payload, pb->len);
 8019f0c:	68fb      	ldr	r3, [r7, #12]
 8019f0e:	689c      	ldr	r4, [r3, #8]
 8019f10:	683b      	ldr	r3, [r7, #0]
 8019f12:	6859      	ldr	r1, [r3, #4]
 8019f14:	683b      	ldr	r3, [r7, #0]
 8019f16:	895b      	ldrh	r3, [r3, #10]
 8019f18:	001a      	movs	r2, r3
 8019f1a:	687b      	ldr	r3, [r7, #4]
 8019f1c:	0018      	movs	r0, r3
 8019f1e:	47a0      	blx	r4
          goto out;
 8019f20:	e022      	b.n	8019f68 <ppp_input+0x194>
      for (i = 0; (protp = protocols[i]) != NULL; ++i) {
 8019f22:	697b      	ldr	r3, [r7, #20]
 8019f24:	3301      	adds	r3, #1
 8019f26:	617b      	str	r3, [r7, #20]
 8019f28:	4b16      	ldr	r3, [pc, #88]	; (8019f84 <ppp_input+0x1b0>)
 8019f2a:	697a      	ldr	r2, [r7, #20]
 8019f2c:	0092      	lsls	r2, r2, #2
 8019f2e:	58d3      	ldr	r3, [r2, r3]
 8019f30:	60fb      	str	r3, [r7, #12]
 8019f32:	68fb      	ldr	r3, [r7, #12]
 8019f34:	2b00      	cmp	r3, #0
 8019f36:	d1db      	bne.n	8019ef0 <ppp_input+0x11c>
        ppp_warn("Unsupported protocol '%s' (0x%x) received", pname, protocol);
      } else
#endif /* PPP_PROTOCOLNAME */
        ppp_warn("Unsupported protocol 0x%x received", protocol);
#endif /* PPP_DEBUG */
        if (pbuf_add_header(pb, sizeof(protocol))) {
 8019f38:	683b      	ldr	r3, [r7, #0]
 8019f3a:	2102      	movs	r1, #2
 8019f3c:	0018      	movs	r0, r3
 8019f3e:	f7ef fd5f 	bl	8009a00 <pbuf_add_header>
 8019f42:	1e03      	subs	r3, r0, #0
 8019f44:	d10f      	bne.n	8019f66 <ppp_input+0x192>
          PPPDEBUG(LOG_WARNING, ("ppp_input[%d]: Dropping (pbuf_add_header failed)\n", pcb->netif->num));
          goto drop;
        }
        lcp_sprotrej(pcb, (u8_t*)pb->payload, pb->len);
 8019f46:	683b      	ldr	r3, [r7, #0]
 8019f48:	6859      	ldr	r1, [r3, #4]
 8019f4a:	683b      	ldr	r3, [r7, #0]
 8019f4c:	895b      	ldrh	r3, [r3, #10]
 8019f4e:	001a      	movs	r2, r3
 8019f50:	687b      	ldr	r3, [r7, #4]
 8019f52:	0018      	movs	r0, r3
 8019f54:	f7fd fe6a 	bl	8017c2c <lcp_sprotrej>
      }
      break;
 8019f58:	e006      	b.n	8019f68 <ppp_input+0x194>
    goto drop;
 8019f5a:	46c0      	nop			; (mov r8, r8)
 8019f5c:	e004      	b.n	8019f68 <ppp_input+0x194>
      break;
 8019f5e:	46c0      	nop			; (mov r8, r8)
 8019f60:	e002      	b.n	8019f68 <ppp_input+0x194>
      break;
 8019f62:	46c0      	nop			; (mov r8, r8)
 8019f64:	e000      	b.n	8019f68 <ppp_input+0x194>
          goto drop;
 8019f66:	46c0      	nop			; (mov r8, r8)
drop:
  LINK_STATS_INC(link.drop);
  MIB2_STATS_NETIF_INC(pcb->netif, ifindiscards);

out:
  pbuf_free(pb);
 8019f68:	683b      	ldr	r3, [r7, #0]
 8019f6a:	0018      	movs	r0, r3
 8019f6c:	f7ef fe30 	bl	8009bd0 <pbuf_free>
}
 8019f70:	46bd      	mov	sp, r7
 8019f72:	b007      	add	sp, #28
 8019f74:	bd90      	pop	{r4, r7, pc}
 8019f76:	46c0      	nop			; (mov r8, r8)
 8019f78:	0000c021 	.word	0x0000c021
 8019f7c:	08021b80 	.word	0x08021b80
 8019f80:	08021bac 	.word	0x08021bac
 8019f84:	080226d8 	.word	0x080226d8

08019f88 <ppp_write>:
 *
 * IPv4 and IPv6 packets from lwIP are sent, respectively,
 * with ppp_netif_output_ip4() and ppp_netif_output_ip6()
 * functions (which are callbacks of the netif PPP interface).
 */
err_t ppp_write(ppp_pcb *pcb, struct pbuf *p) {
 8019f88:	b590      	push	{r4, r7, lr}
 8019f8a:	b083      	sub	sp, #12
 8019f8c:	af00      	add	r7, sp, #0
 8019f8e:	6078      	str	r0, [r7, #4]
 8019f90:	6039      	str	r1, [r7, #0]
#if PRINTPKT_SUPPORT
  ppp_dump_packet(pcb, "sent", (unsigned char *)p->payload+2, p->len-2);
#endif /* PRINTPKT_SUPPORT */
  return pcb->link_cb->write(pcb, pcb->link_ctx_cb, p);
 8019f92:	687b      	ldr	r3, [r7, #4]
 8019f94:	68db      	ldr	r3, [r3, #12]
 8019f96:	68dc      	ldr	r4, [r3, #12]
 8019f98:	687b      	ldr	r3, [r7, #4]
 8019f9a:	6919      	ldr	r1, [r3, #16]
 8019f9c:	683a      	ldr	r2, [r7, #0]
 8019f9e:	687b      	ldr	r3, [r7, #4]
 8019fa0:	0018      	movs	r0, r3
 8019fa2:	47a0      	blx	r4
 8019fa4:	0003      	movs	r3, r0
}
 8019fa6:	0018      	movs	r0, r3
 8019fa8:	46bd      	mov	sp, r7
 8019faa:	b003      	add	sp, #12
 8019fac:	bd90      	pop	{r4, r7, pc}

08019fae <ppp_link_terminated>:

void ppp_link_terminated(ppp_pcb *pcb) {
 8019fae:	b580      	push	{r7, lr}
 8019fb0:	b082      	sub	sp, #8
 8019fb2:	af00      	add	r7, sp, #0
 8019fb4:	6078      	str	r0, [r7, #4]
  PPPDEBUG(LOG_DEBUG, ("ppp_link_terminated[%d]\n", pcb->netif->num));
  pcb->link_cb->disconnect(pcb, pcb->link_ctx_cb);
 8019fb6:	687b      	ldr	r3, [r7, #4]
 8019fb8:	68db      	ldr	r3, [r3, #12]
 8019fba:	685a      	ldr	r2, [r3, #4]
 8019fbc:	687b      	ldr	r3, [r7, #4]
 8019fbe:	6919      	ldr	r1, [r3, #16]
 8019fc0:	687b      	ldr	r3, [r7, #4]
 8019fc2:	0018      	movs	r0, r3
 8019fc4:	4790      	blx	r2
  PPPDEBUG(LOG_DEBUG, ("ppp_link_terminated[%d]: finished.\n", pcb->netif->num));
}
 8019fc6:	46c0      	nop			; (mov r8, r8)
 8019fc8:	46bd      	mov	sp, r7
 8019fca:	b002      	add	sp, #8
 8019fcc:	bd80      	pop	{r7, pc}

08019fce <new_phase>:
 */

/*
 * new_phase - signal the start of a new phase of pppd's operation.
 */
void new_phase(ppp_pcb *pcb, int p) {
 8019fce:	b590      	push	{r4, r7, lr}
 8019fd0:	b083      	sub	sp, #12
 8019fd2:	af00      	add	r7, sp, #0
 8019fd4:	6078      	str	r0, [r7, #4]
 8019fd6:	6039      	str	r1, [r7, #0]
  pcb->phase = p;
 8019fd8:	683b      	ldr	r3, [r7, #0]
 8019fda:	b2d9      	uxtb	r1, r3
 8019fdc:	687b      	ldr	r3, [r7, #4]
 8019fde:	2224      	movs	r2, #36	; 0x24
 8019fe0:	5499      	strb	r1, [r3, r2]
  PPPDEBUG(LOG_DEBUG, ("ppp phase changed[%d]: phase=%d\n", pcb->netif->num, pcb->phase));
#if PPP_NOTIFY_PHASE
  if (pcb->notify_phase_cb != NULL) {
 8019fe2:	687b      	ldr	r3, [r7, #4]
 8019fe4:	699b      	ldr	r3, [r3, #24]
 8019fe6:	2b00      	cmp	r3, #0
 8019fe8:	d008      	beq.n	8019ffc <new_phase+0x2e>
    pcb->notify_phase_cb(pcb, p, pcb->ctx_cb);
 8019fea:	687b      	ldr	r3, [r7, #4]
 8019fec:	699c      	ldr	r4, [r3, #24]
 8019fee:	683b      	ldr	r3, [r7, #0]
 8019ff0:	b2d9      	uxtb	r1, r3
 8019ff2:	687b      	ldr	r3, [r7, #4]
 8019ff4:	69da      	ldr	r2, [r3, #28]
 8019ff6:	687b      	ldr	r3, [r7, #4]
 8019ff8:	0018      	movs	r0, r3
 8019ffa:	47a0      	blx	r4
  }
#endif /* PPP_NOTIFY_PHASE */
}
 8019ffc:	46c0      	nop			; (mov r8, r8)
 8019ffe:	46bd      	mov	sp, r7
 801a000:	b003      	add	sp, #12
 801a002:	bd90      	pop	{r4, r7, pc}

0801a004 <ppp_send_config>:

/*
 * ppp_send_config - configure the transmit-side characteristics of
 * the ppp interface.
 */
int ppp_send_config(ppp_pcb *pcb, int mtu, u32_t accm, int pcomp, int accomp) {
 801a004:	b5b0      	push	{r4, r5, r7, lr}
 801a006:	b086      	sub	sp, #24
 801a008:	af02      	add	r7, sp, #8
 801a00a:	60f8      	str	r0, [r7, #12]
 801a00c:	60b9      	str	r1, [r7, #8]
 801a00e:	607a      	str	r2, [r7, #4]
 801a010:	603b      	str	r3, [r7, #0]
  LWIP_UNUSED_ARG(mtu);
  /* pcb->mtu = mtu; -- set correctly with netif_set_mtu */

  if (pcb->link_cb->send_config) {
 801a012:	68fb      	ldr	r3, [r7, #12]
 801a014:	68db      	ldr	r3, [r3, #12]
 801a016:	695b      	ldr	r3, [r3, #20]
 801a018:	2b00      	cmp	r3, #0
 801a01a:	d00b      	beq.n	801a034 <ppp_send_config+0x30>
    pcb->link_cb->send_config(pcb, pcb->link_ctx_cb, accm, pcomp, accomp);
 801a01c:	68fb      	ldr	r3, [r7, #12]
 801a01e:	68db      	ldr	r3, [r3, #12]
 801a020:	695c      	ldr	r4, [r3, #20]
 801a022:	68fb      	ldr	r3, [r7, #12]
 801a024:	6919      	ldr	r1, [r3, #16]
 801a026:	683d      	ldr	r5, [r7, #0]
 801a028:	687a      	ldr	r2, [r7, #4]
 801a02a:	68f8      	ldr	r0, [r7, #12]
 801a02c:	6a3b      	ldr	r3, [r7, #32]
 801a02e:	9300      	str	r3, [sp, #0]
 801a030:	002b      	movs	r3, r5
 801a032:	47a0      	blx	r4
  }

  PPPDEBUG(LOG_INFO, ("ppp_send_config[%d]\n", pcb->netif->num) );
  return 0;
 801a034:	2300      	movs	r3, #0
}
 801a036:	0018      	movs	r0, r3
 801a038:	46bd      	mov	sp, r7
 801a03a:	b004      	add	sp, #16
 801a03c:	bdb0      	pop	{r4, r5, r7, pc}

0801a03e <ppp_recv_config>:

/*
 * ppp_recv_config - configure the receive-side characteristics of
 * the ppp interface.
 */
int ppp_recv_config(ppp_pcb *pcb, int mru, u32_t accm, int pcomp, int accomp) {
 801a03e:	b5b0      	push	{r4, r5, r7, lr}
 801a040:	b086      	sub	sp, #24
 801a042:	af02      	add	r7, sp, #8
 801a044:	60f8      	str	r0, [r7, #12]
 801a046:	60b9      	str	r1, [r7, #8]
 801a048:	607a      	str	r2, [r7, #4]
 801a04a:	603b      	str	r3, [r7, #0]
  LWIP_UNUSED_ARG(mru);

  if (pcb->link_cb->recv_config) {
 801a04c:	68fb      	ldr	r3, [r7, #12]
 801a04e:	68db      	ldr	r3, [r3, #12]
 801a050:	699b      	ldr	r3, [r3, #24]
 801a052:	2b00      	cmp	r3, #0
 801a054:	d00b      	beq.n	801a06e <ppp_recv_config+0x30>
    pcb->link_cb->recv_config(pcb, pcb->link_ctx_cb, accm, pcomp, accomp);
 801a056:	68fb      	ldr	r3, [r7, #12]
 801a058:	68db      	ldr	r3, [r3, #12]
 801a05a:	699c      	ldr	r4, [r3, #24]
 801a05c:	68fb      	ldr	r3, [r7, #12]
 801a05e:	6919      	ldr	r1, [r3, #16]
 801a060:	683d      	ldr	r5, [r7, #0]
 801a062:	687a      	ldr	r2, [r7, #4]
 801a064:	68f8      	ldr	r0, [r7, #12]
 801a066:	6a3b      	ldr	r3, [r7, #32]
 801a068:	9300      	str	r3, [sp, #0]
 801a06a:	002b      	movs	r3, r5
 801a06c:	47a0      	blx	r4
  }

  PPPDEBUG(LOG_INFO, ("ppp_recv_config[%d]\n", pcb->netif->num));
  return 0;
 801a06e:	2300      	movs	r3, #0
}
 801a070:	0018      	movs	r0, r3
 801a072:	46bd      	mov	sp, r7
 801a074:	b004      	add	sp, #16
 801a076:	bdb0      	pop	{r4, r5, r7, pc}

0801a078 <sifaddr>:

#if PPP_IPV4_SUPPORT
/*
 * sifaddr - Config the interface IP addresses and netmask.
 */
int sifaddr(ppp_pcb *pcb, u32_t our_adr, u32_t his_adr, u32_t netmask) {
 801a078:	b580      	push	{r7, lr}
 801a07a:	b088      	sub	sp, #32
 801a07c:	af00      	add	r7, sp, #0
 801a07e:	60f8      	str	r0, [r7, #12]
 801a080:	60b9      	str	r1, [r7, #8]
 801a082:	607a      	str	r2, [r7, #4]
 801a084:	603b      	str	r3, [r7, #0]
  ip4_addr_t ip, nm, gw;

  ip4_addr_set_u32(&ip, our_adr);
 801a086:	68bb      	ldr	r3, [r7, #8]
 801a088:	61fb      	str	r3, [r7, #28]
  ip4_addr_set_u32(&nm, netmask);
 801a08a:	683b      	ldr	r3, [r7, #0]
 801a08c:	61bb      	str	r3, [r7, #24]
  ip4_addr_set_u32(&gw, his_adr);
 801a08e:	687b      	ldr	r3, [r7, #4]
 801a090:	617b      	str	r3, [r7, #20]
  netif_set_addr(pcb->netif, &ip, &nm, &gw);
 801a092:	68fb      	ldr	r3, [r7, #12]
 801a094:	6a18      	ldr	r0, [r3, #32]
 801a096:	2314      	movs	r3, #20
 801a098:	18fb      	adds	r3, r7, r3
 801a09a:	2218      	movs	r2, #24
 801a09c:	18ba      	adds	r2, r7, r2
 801a09e:	211c      	movs	r1, #28
 801a0a0:	1879      	adds	r1, r7, r1
 801a0a2:	f7ef f83d 	bl	8009120 <netif_set_addr>
  return 1;
 801a0a6:	2301      	movs	r3, #1
}
 801a0a8:	0018      	movs	r0, r3
 801a0aa:	46bd      	mov	sp, r7
 801a0ac:	b008      	add	sp, #32
 801a0ae:	bd80      	pop	{r7, pc}

0801a0b0 <cifaddr>:
/********************************************************************
 *
 * cifaddr - Clear the interface IP addresses, and delete routes
 * through the interface if possible.
 */
int cifaddr(ppp_pcb *pcb, u32_t our_adr, u32_t his_adr) {
 801a0b0:	b580      	push	{r7, lr}
 801a0b2:	b084      	sub	sp, #16
 801a0b4:	af00      	add	r7, sp, #0
 801a0b6:	60f8      	str	r0, [r7, #12]
 801a0b8:	60b9      	str	r1, [r7, #8]
 801a0ba:	607a      	str	r2, [r7, #4]
  LWIP_UNUSED_ARG(our_adr);
  LWIP_UNUSED_ARG(his_adr);

  netif_set_addr(pcb->netif, IP4_ADDR_ANY4, IP4_ADDR_BROADCAST, IP4_ADDR_ANY4);
 801a0bc:	68fb      	ldr	r3, [r7, #12]
 801a0be:	6a18      	ldr	r0, [r3, #32]
 801a0c0:	4b04      	ldr	r3, [pc, #16]	; (801a0d4 <cifaddr+0x24>)
 801a0c2:	4a05      	ldr	r2, [pc, #20]	; (801a0d8 <cifaddr+0x28>)
 801a0c4:	4903      	ldr	r1, [pc, #12]	; (801a0d4 <cifaddr+0x24>)
 801a0c6:	f7ef f82b 	bl	8009120 <netif_set_addr>
  return 1;
 801a0ca:	2301      	movs	r3, #1
}
 801a0cc:	0018      	movs	r0, r3
 801a0ce:	46bd      	mov	sp, r7
 801a0d0:	b004      	add	sp, #16
 801a0d2:	bd80      	pop	{r7, pc}
 801a0d4:	0802246c 	.word	0x0802246c
 801a0d8:	08022470 	.word	0x08022470

0801a0dc <sdns>:

#if LWIP_DNS
/*
 * sdns - Config the DNS servers
 */
int sdns(ppp_pcb *pcb, u32_t ns1, u32_t ns2) {
 801a0dc:	b590      	push	{r4, r7, lr}
 801a0de:	b087      	sub	sp, #28
 801a0e0:	af00      	add	r7, sp, #0
 801a0e2:	60f8      	str	r0, [r7, #12]
 801a0e4:	60b9      	str	r1, [r7, #8]
 801a0e6:	607a      	str	r2, [r7, #4]
  ip_addr_t ns;
  LWIP_UNUSED_ARG(pcb);

  ip_addr_set_ip4_u32_val(ns, ns1);
 801a0e8:	68bb      	ldr	r3, [r7, #8]
 801a0ea:	617b      	str	r3, [r7, #20]
  dns_setserver(0, &ns);
 801a0ec:	2414      	movs	r4, #20
 801a0ee:	193b      	adds	r3, r7, r4
 801a0f0:	0019      	movs	r1, r3
 801a0f2:	2000      	movs	r0, #0
 801a0f4:	f7ec fe08 	bl	8006d08 <dns_setserver>
  ip_addr_set_ip4_u32_val(ns, ns2);
 801a0f8:	687b      	ldr	r3, [r7, #4]
 801a0fa:	617b      	str	r3, [r7, #20]
  dns_setserver(1, &ns);
 801a0fc:	193b      	adds	r3, r7, r4
 801a0fe:	0019      	movs	r1, r3
 801a100:	2001      	movs	r0, #1
 801a102:	f7ec fe01 	bl	8006d08 <dns_setserver>
  return 1;
 801a106:	2301      	movs	r3, #1
}
 801a108:	0018      	movs	r0, r3
 801a10a:	46bd      	mov	sp, r7
 801a10c:	b007      	add	sp, #28
 801a10e:	bd90      	pop	{r4, r7, pc}

0801a110 <cdns>:

/********************************************************************
 *
 * cdns - Clear the DNS servers
 */
int cdns(ppp_pcb *pcb, u32_t ns1, u32_t ns2) {
 801a110:	b580      	push	{r7, lr}
 801a112:	b086      	sub	sp, #24
 801a114:	af00      	add	r7, sp, #0
 801a116:	60f8      	str	r0, [r7, #12]
 801a118:	60b9      	str	r1, [r7, #8]
 801a11a:	607a      	str	r2, [r7, #4]
  const ip_addr_t *nsa;
  ip_addr_t nsb;
  LWIP_UNUSED_ARG(pcb);

  nsa = dns_getserver(0);
 801a11c:	2000      	movs	r0, #0
 801a11e:	f7ec fe19 	bl	8006d54 <dns_getserver>
 801a122:	0003      	movs	r3, r0
 801a124:	617b      	str	r3, [r7, #20]
  ip_addr_set_ip4_u32_val(nsb, ns1);
 801a126:	68bb      	ldr	r3, [r7, #8]
 801a128:	613b      	str	r3, [r7, #16]
  if (ip_addr_cmp(nsa, &nsb)) {
 801a12a:	697b      	ldr	r3, [r7, #20]
 801a12c:	681a      	ldr	r2, [r3, #0]
 801a12e:	693b      	ldr	r3, [r7, #16]
 801a130:	429a      	cmp	r2, r3
 801a132:	d104      	bne.n	801a13e <cdns+0x2e>
    dns_setserver(0, IP_ADDR_ANY);
 801a134:	4b0d      	ldr	r3, [pc, #52]	; (801a16c <cdns+0x5c>)
 801a136:	0019      	movs	r1, r3
 801a138:	2000      	movs	r0, #0
 801a13a:	f7ec fde5 	bl	8006d08 <dns_setserver>
  }
  nsa = dns_getserver(1);
 801a13e:	2001      	movs	r0, #1
 801a140:	f7ec fe08 	bl	8006d54 <dns_getserver>
 801a144:	0003      	movs	r3, r0
 801a146:	617b      	str	r3, [r7, #20]
  ip_addr_set_ip4_u32_val(nsb, ns2);
 801a148:	687b      	ldr	r3, [r7, #4]
 801a14a:	613b      	str	r3, [r7, #16]
  if (ip_addr_cmp(nsa, &nsb)) {
 801a14c:	697b      	ldr	r3, [r7, #20]
 801a14e:	681a      	ldr	r2, [r3, #0]
 801a150:	693b      	ldr	r3, [r7, #16]
 801a152:	429a      	cmp	r2, r3
 801a154:	d104      	bne.n	801a160 <cdns+0x50>
    dns_setserver(1, IP_ADDR_ANY);
 801a156:	4b05      	ldr	r3, [pc, #20]	; (801a16c <cdns+0x5c>)
 801a158:	0019      	movs	r1, r3
 801a15a:	2001      	movs	r0, #1
 801a15c:	f7ec fdd4 	bl	8006d08 <dns_setserver>
  }
  return 1;
 801a160:	2301      	movs	r3, #1
}
 801a162:	0018      	movs	r0, r3
 801a164:	46bd      	mov	sp, r7
 801a166:	b006      	add	sp, #24
 801a168:	bd80      	pop	{r7, pc}
 801a16a:	46c0      	nop			; (mov r8, r8)
 801a16c:	0802246c 	.word	0x0802246c

0801a170 <sifvjcomp>:
#if VJ_SUPPORT
/********************************************************************
 *
 * sifvjcomp - config tcp header compression
 */
int sifvjcomp(ppp_pcb *pcb, int vjcomp, int cidcomp, int maxcid) {
 801a170:	b590      	push	{r4, r7, lr}
 801a172:	b085      	sub	sp, #20
 801a174:	af00      	add	r7, sp, #0
 801a176:	60f8      	str	r0, [r7, #12]
 801a178:	60b9      	str	r1, [r7, #8]
 801a17a:	607a      	str	r2, [r7, #4]
 801a17c:	603b      	str	r3, [r7, #0]
  pcb->vj_enabled = vjcomp;
 801a17e:	68bb      	ldr	r3, [r7, #8]
 801a180:	1c1a      	adds	r2, r3, #0
 801a182:	2301      	movs	r3, #1
 801a184:	4013      	ands	r3, r2
 801a186:	b2d9      	uxtb	r1, r3
 801a188:	68fb      	ldr	r3, [r7, #12]
 801a18a:	2226      	movs	r2, #38	; 0x26
 801a18c:	2001      	movs	r0, #1
 801a18e:	4001      	ands	r1, r0
 801a190:	014c      	lsls	r4, r1, #5
 801a192:	5c99      	ldrb	r1, [r3, r2]
 801a194:	2020      	movs	r0, #32
 801a196:	4381      	bics	r1, r0
 801a198:	1c08      	adds	r0, r1, #0
 801a19a:	1c21      	adds	r1, r4, #0
 801a19c:	4301      	orrs	r1, r0
 801a19e:	5499      	strb	r1, [r3, r2]
  pcb->vj_comp.compressSlot = cidcomp;
 801a1a0:	687b      	ldr	r3, [r7, #4]
 801a1a2:	b2d9      	uxtb	r1, r3
 801a1a4:	68fb      	ldr	r3, [r7, #12]
 801a1a6:	22e5      	movs	r2, #229	; 0xe5
 801a1a8:	5499      	strb	r1, [r3, r2]
  pcb->vj_comp.maxSlotIndex = maxcid;
 801a1aa:	683b      	ldr	r3, [r7, #0]
 801a1ac:	b2d9      	uxtb	r1, r3
 801a1ae:	68fb      	ldr	r3, [r7, #12]
 801a1b0:	22e4      	movs	r2, #228	; 0xe4
 801a1b2:	5499      	strb	r1, [r3, r2]
  PPPDEBUG(LOG_INFO, ("sifvjcomp[%d]: VJ compress enable=%d slot=%d max slot=%d\n",
            pcb->netif->num, vjcomp, cidcomp, maxcid));
  return 0;
 801a1b4:	2300      	movs	r3, #0
}
 801a1b6:	0018      	movs	r0, r3
 801a1b8:	46bd      	mov	sp, r7
 801a1ba:	b005      	add	sp, #20
 801a1bc:	bd90      	pop	{r4, r7, pc}

0801a1be <sifup>:
#endif /* VJ_SUPPORT */

/*
 * sifup - Config the interface up and enable IP packets to pass.
 */
int sifup(ppp_pcb *pcb) {
 801a1be:	b590      	push	{r4, r7, lr}
 801a1c0:	b083      	sub	sp, #12
 801a1c2:	af00      	add	r7, sp, #0
 801a1c4:	6078      	str	r0, [r7, #4]
  pcb->if4_up = 1;
 801a1c6:	687b      	ldr	r3, [r7, #4]
 801a1c8:	2226      	movs	r2, #38	; 0x26
 801a1ca:	5c99      	ldrb	r1, [r3, r2]
 801a1cc:	2008      	movs	r0, #8
 801a1ce:	4301      	orrs	r1, r0
 801a1d0:	5499      	strb	r1, [r3, r2]
  pcb->err_code = PPPERR_NONE;
 801a1d2:	687b      	ldr	r3, [r7, #4]
 801a1d4:	2225      	movs	r2, #37	; 0x25
 801a1d6:	2100      	movs	r1, #0
 801a1d8:	5499      	strb	r1, [r3, r2]
  netif_set_link_up(pcb->netif);
 801a1da:	687b      	ldr	r3, [r7, #4]
 801a1dc:	6a1b      	ldr	r3, [r3, #32]
 801a1de:	0018      	movs	r0, r3
 801a1e0:	f7ef f89a 	bl	8009318 <netif_set_link_up>

  PPPDEBUG(LOG_DEBUG, ("sifup[%d]: err_code=%d\n", pcb->netif->num, pcb->err_code));
  pcb->link_status_cb(pcb, pcb->err_code, pcb->ctx_cb);
 801a1e4:	687b      	ldr	r3, [r7, #4]
 801a1e6:	695c      	ldr	r4, [r3, #20]
 801a1e8:	687b      	ldr	r3, [r7, #4]
 801a1ea:	2225      	movs	r2, #37	; 0x25
 801a1ec:	5c9b      	ldrb	r3, [r3, r2]
 801a1ee:	0019      	movs	r1, r3
 801a1f0:	687b      	ldr	r3, [r7, #4]
 801a1f2:	69da      	ldr	r2, [r3, #28]
 801a1f4:	687b      	ldr	r3, [r7, #4]
 801a1f6:	0018      	movs	r0, r3
 801a1f8:	47a0      	blx	r4
  return 1;
 801a1fa:	2301      	movs	r3, #1
}
 801a1fc:	0018      	movs	r0, r3
 801a1fe:	46bd      	mov	sp, r7
 801a200:	b003      	add	sp, #12
 801a202:	bd90      	pop	{r4, r7, pc}

0801a204 <sifdown>:
/********************************************************************
 *
 * sifdown - Disable the indicated protocol and config the interface
 *           down if there are no remaining protocols.
 */
int sifdown(ppp_pcb *pcb) {
 801a204:	b580      	push	{r7, lr}
 801a206:	b082      	sub	sp, #8
 801a208:	af00      	add	r7, sp, #0
 801a20a:	6078      	str	r0, [r7, #4]

  pcb->if4_up = 0;
 801a20c:	687b      	ldr	r3, [r7, #4]
 801a20e:	2226      	movs	r2, #38	; 0x26
 801a210:	5c99      	ldrb	r1, [r3, r2]
 801a212:	2008      	movs	r0, #8
 801a214:	4381      	bics	r1, r0
 801a216:	5499      	strb	r1, [r3, r2]
   /* set the interface down if IPv6 is down as well */
   && !pcb->if6_up
#endif /* PPP_IPV6_SUPPORT */
  ) {
    /* make sure the netif link callback is called */
    netif_set_link_down(pcb->netif);
 801a218:	687b      	ldr	r3, [r7, #4]
 801a21a:	6a1b      	ldr	r3, [r3, #32]
 801a21c:	0018      	movs	r0, r3
 801a21e:	f7ef f8ab 	bl	8009378 <netif_set_link_down>
  }
  PPPDEBUG(LOG_DEBUG, ("sifdown[%d]: err_code=%d\n", pcb->netif->num, pcb->err_code));
  return 1;
 801a222:	2301      	movs	r3, #1
}
 801a224:	0018      	movs	r0, r3
 801a226:	46bd      	mov	sp, r7
 801a228:	b002      	add	sp, #8
 801a22a:	bd80      	pop	{r7, pc}

0801a22c <get_mask>:
 * Here we scan through the system's list of interfaces, looking for
 * any non-point-to-point interfaces which might appear to be on the same
 * network as `addr'.  If we find any, we OR in their netmask to the
 * user-specified netmask.
 */
u32_t get_mask(u32_t addr) {
 801a22c:	b580      	push	{r7, lr}
 801a22e:	b082      	sub	sp, #8
 801a230:	af00      	add	r7, sp, #0
 801a232:	6078      	str	r0, [r7, #4]
   */
  /* return mask; */
  return mask;
#endif /* 0 */
  LWIP_UNUSED_ARG(addr);
  return IPADDR_BROADCAST;
 801a234:	2301      	movs	r3, #1
 801a236:	425b      	negs	r3, r3
}
 801a238:	0018      	movs	r0, r3
 801a23a:	46bd      	mov	sp, r7
 801a23c:	b002      	add	sp, #8
 801a23e:	bd80      	pop	{r7, pc}

0801a240 <netif_set_mtu>:
#endif /* DEMAND_SUPPORT */

/*
 * netif_set_mtu - set the MTU on the PPP network interface.
 */
void netif_set_mtu(ppp_pcb *pcb, int mtu) {
 801a240:	b580      	push	{r7, lr}
 801a242:	b082      	sub	sp, #8
 801a244:	af00      	add	r7, sp, #0
 801a246:	6078      	str	r0, [r7, #4]
 801a248:	6039      	str	r1, [r7, #0]

  pcb->netif->mtu = mtu;
 801a24a:	687b      	ldr	r3, [r7, #4]
 801a24c:	6a1b      	ldr	r3, [r3, #32]
 801a24e:	683a      	ldr	r2, [r7, #0]
 801a250:	b292      	uxth	r2, r2
 801a252:	851a      	strh	r2, [r3, #40]	; 0x28
  PPPDEBUG(LOG_INFO, ("netif_set_mtu[%d]: mtu=%d\n", pcb->netif->num, mtu));
}
 801a254:	46c0      	nop			; (mov r8, r8)
 801a256:	46bd      	mov	sp, r7
 801a258:	b002      	add	sp, #8
 801a25a:	bd80      	pop	{r7, pc}

0801a25c <pppos_create>:
 *
 * Return 0 on success, an error code on failure.
 */
ppp_pcb *pppos_create(struct netif *pppif, pppos_output_cb_fn output_cb,
       ppp_link_status_cb_fn link_status_cb, void *ctx_cb)
{
 801a25c:	b590      	push	{r4, r7, lr}
 801a25e:	b089      	sub	sp, #36	; 0x24
 801a260:	af02      	add	r7, sp, #8
 801a262:	60f8      	str	r0, [r7, #12]
 801a264:	60b9      	str	r1, [r7, #8]
 801a266:	607a      	str	r2, [r7, #4]
 801a268:	603b      	str	r3, [r7, #0]
  pppos_pcb *pppos;
  ppp_pcb *ppp;
  LWIP_ASSERT_CORE_LOCKED();

  pppos = (pppos_pcb *)LWIP_MEMPOOL_ALLOC(PPPOS_PCB);
 801a26a:	4b19      	ldr	r3, [pc, #100]	; (801a2d0 <pppos_create+0x74>)
 801a26c:	0018      	movs	r0, r3
 801a26e:	f7ee fd2d 	bl	8008ccc <memp_malloc_pool>
 801a272:	0003      	movs	r3, r0
 801a274:	617b      	str	r3, [r7, #20]
  if (pppos == NULL) {
 801a276:	697b      	ldr	r3, [r7, #20]
 801a278:	2b00      	cmp	r3, #0
 801a27a:	d101      	bne.n	801a280 <pppos_create+0x24>
    return NULL;
 801a27c:	2300      	movs	r3, #0
 801a27e:	e022      	b.n	801a2c6 <pppos_create+0x6a>
  }

  ppp = ppp_new(pppif, &pppos_callbacks, pppos, link_status_cb, ctx_cb);
 801a280:	687c      	ldr	r4, [r7, #4]
 801a282:	697a      	ldr	r2, [r7, #20]
 801a284:	4913      	ldr	r1, [pc, #76]	; (801a2d4 <pppos_create+0x78>)
 801a286:	68f8      	ldr	r0, [r7, #12]
 801a288:	683b      	ldr	r3, [r7, #0]
 801a28a:	9300      	str	r3, [sp, #0]
 801a28c:	0023      	movs	r3, r4
 801a28e:	f7ff fce3 	bl	8019c58 <ppp_new>
 801a292:	0003      	movs	r3, r0
 801a294:	613b      	str	r3, [r7, #16]
  if (ppp == NULL) {
 801a296:	693b      	ldr	r3, [r7, #16]
 801a298:	2b00      	cmp	r3, #0
 801a29a:	d107      	bne.n	801a2ac <pppos_create+0x50>
    LWIP_MEMPOOL_FREE(PPPOS_PCB, pppos);
 801a29c:	697a      	ldr	r2, [r7, #20]
 801a29e:	4b0c      	ldr	r3, [pc, #48]	; (801a2d0 <pppos_create+0x74>)
 801a2a0:	0011      	movs	r1, r2
 801a2a2:	0018      	movs	r0, r3
 801a2a4:	f7ee fd7e 	bl	8008da4 <memp_free_pool>
    return NULL;
 801a2a8:	2300      	movs	r3, #0
 801a2aa:	e00c      	b.n	801a2c6 <pppos_create+0x6a>
  }

  memset(pppos, 0, sizeof(pppos_pcb));
 801a2ac:	697b      	ldr	r3, [r7, #20]
 801a2ae:	2260      	movs	r2, #96	; 0x60
 801a2b0:	2100      	movs	r1, #0
 801a2b2:	0018      	movs	r0, r3
 801a2b4:	f002 fcb0 	bl	801cc18 <memset>
  pppos->ppp = ppp;
 801a2b8:	697b      	ldr	r3, [r7, #20]
 801a2ba:	693a      	ldr	r2, [r7, #16]
 801a2bc:	601a      	str	r2, [r3, #0]
  pppos->output_cb = output_cb;
 801a2be:	697b      	ldr	r3, [r7, #20]
 801a2c0:	68ba      	ldr	r2, [r7, #8]
 801a2c2:	605a      	str	r2, [r3, #4]
  return ppp;
 801a2c4:	693b      	ldr	r3, [r7, #16]
}
 801a2c6:	0018      	movs	r0, r3
 801a2c8:	46bd      	mov	sp, r7
 801a2ca:	b007      	add	sp, #28
 801a2cc:	bd90      	pop	{r4, r7, pc}
 801a2ce:	46c0      	nop			; (mov r8, r8)
 801a2d0:	080226e4 	.word	0x080226e4
 801a2d4:	080226f4 	.word	0x080226f4

0801a2d8 <pppos_write>:

/* Called by PPP core */
static err_t
pppos_write(ppp_pcb *ppp, void *ctx, struct pbuf *p)
{
 801a2d8:	b5f0      	push	{r4, r5, r6, r7, lr}
 801a2da:	b08d      	sub	sp, #52	; 0x34
 801a2dc:	af02      	add	r7, sp, #8
 801a2de:	60f8      	str	r0, [r7, #12]
 801a2e0:	60b9      	str	r1, [r7, #8]
 801a2e2:	607a      	str	r2, [r7, #4]
  pppos_pcb *pppos = (pppos_pcb *)ctx;
 801a2e4:	68bb      	ldr	r3, [r7, #8]
 801a2e6:	61fb      	str	r3, [r7, #28]
  LWIP_UNUSED_ARG(ppp);

  /* Grab an output buffer. Using PBUF_POOL here for tx is ok since the pbuf
     gets freed by 'pppos_output_last' before this function returns and thus
     cannot starve rx. */
  nb = pbuf_alloc(PBUF_RAW, 0, PBUF_POOL);
 801a2e8:	23c1      	movs	r3, #193	; 0xc1
 801a2ea:	005b      	lsls	r3, r3, #1
 801a2ec:	001a      	movs	r2, r3
 801a2ee:	2100      	movs	r1, #0
 801a2f0:	2000      	movs	r0, #0
 801a2f2:	f7ef f8f5 	bl	80094e0 <pbuf_alloc>
 801a2f6:	0003      	movs	r3, r0
 801a2f8:	61bb      	str	r3, [r7, #24]
  if (nb == NULL) {
 801a2fa:	69bb      	ldr	r3, [r7, #24]
 801a2fc:	2b00      	cmp	r3, #0
 801a2fe:	d106      	bne.n	801a30e <pppos_write+0x36>
    PPPDEBUG(LOG_WARNING, ("pppos_write[%d]: alloc fail\n", ppp->netif->num));
    LINK_STATS_INC(link.memerr);
    LINK_STATS_INC(link.drop);
    MIB2_STATS_NETIF_INC(ppp->netif, ifoutdiscards);
    pbuf_free(p);
 801a300:	687b      	ldr	r3, [r7, #4]
 801a302:	0018      	movs	r0, r3
 801a304:	f7ef fc64 	bl	8009bd0 <pbuf_free>
    return ERR_MEM;
 801a308:	2301      	movs	r3, #1
 801a30a:	425b      	negs	r3, r3
 801a30c:	e05f      	b.n	801a3ce <pppos_write+0xf6>
  }

  /* Set nb->tot_len to actual payload length */
  nb->tot_len = p->len;
 801a30e:	687b      	ldr	r3, [r7, #4]
 801a310:	895a      	ldrh	r2, [r3, #10]
 801a312:	69bb      	ldr	r3, [r7, #24]
 801a314:	811a      	strh	r2, [r3, #8]

  /* If the link has been idle, we'll send a fresh flag character to
   * flush any noise. */
  err = ERR_OK;
 801a316:	2421      	movs	r4, #33	; 0x21
 801a318:	193b      	adds	r3, r7, r4
 801a31a:	2200      	movs	r2, #0
 801a31c:	701a      	strb	r2, [r3, #0]
  if ((sys_now() - pppos->last_xmit) >= PPP_MAXIDLEFLAG) {
 801a31e:	f002 fc0d 	bl	801cb3c <sys_now>
 801a322:	0002      	movs	r2, r0
 801a324:	69fb      	ldr	r3, [r7, #28]
 801a326:	689b      	ldr	r3, [r3, #8]
 801a328:	1ad3      	subs	r3, r2, r3
 801a32a:	2b63      	cmp	r3, #99	; 0x63
 801a32c:	d90f      	bls.n	801a34e <pppos_write+0x76>
    err = pppos_output_append(pppos, err,  nb, PPP_FLAG, 0, NULL);
 801a32e:	0023      	movs	r3, r4
 801a330:	18fc      	adds	r4, r7, r3
 801a332:	69ba      	ldr	r2, [r7, #24]
 801a334:	18fb      	adds	r3, r7, r3
 801a336:	2100      	movs	r1, #0
 801a338:	5659      	ldrsb	r1, [r3, r1]
 801a33a:	69f8      	ldr	r0, [r7, #28]
 801a33c:	2300      	movs	r3, #0
 801a33e:	9301      	str	r3, [sp, #4]
 801a340:	2300      	movs	r3, #0
 801a342:	9300      	str	r3, [sp, #0]
 801a344:	237e      	movs	r3, #126	; 0x7e
 801a346:	f000 fbe3 	bl	801ab10 <pppos_output_append>
 801a34a:	0003      	movs	r3, r0
 801a34c:	7023      	strb	r3, [r4, #0]
  }

  /* Load output buffer. */
  fcs_out = PPP_INITFCS;
 801a34e:	2316      	movs	r3, #22
 801a350:	18fb      	adds	r3, r7, r3
 801a352:	2201      	movs	r2, #1
 801a354:	4252      	negs	r2, r2
 801a356:	801a      	strh	r2, [r3, #0]
  s = (u8_t*)p->payload;
 801a358:	687b      	ldr	r3, [r7, #4]
 801a35a:	685b      	ldr	r3, [r3, #4]
 801a35c:	627b      	str	r3, [r7, #36]	; 0x24
  n = p->len;
 801a35e:	2322      	movs	r3, #34	; 0x22
 801a360:	18fb      	adds	r3, r7, r3
 801a362:	687a      	ldr	r2, [r7, #4]
 801a364:	8952      	ldrh	r2, [r2, #10]
 801a366:	801a      	strh	r2, [r3, #0]
  while (n-- > 0) {
 801a368:	e014      	b.n	801a394 <pppos_write+0xbc>
    err = pppos_output_append(pppos, err,  nb, *s++, 1, &fcs_out);
 801a36a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a36c:	1c5a      	adds	r2, r3, #1
 801a36e:	627a      	str	r2, [r7, #36]	; 0x24
 801a370:	781d      	ldrb	r5, [r3, #0]
 801a372:	2321      	movs	r3, #33	; 0x21
 801a374:	18fc      	adds	r4, r7, r3
 801a376:	69ba      	ldr	r2, [r7, #24]
 801a378:	18fb      	adds	r3, r7, r3
 801a37a:	2100      	movs	r1, #0
 801a37c:	5659      	ldrsb	r1, [r3, r1]
 801a37e:	69f8      	ldr	r0, [r7, #28]
 801a380:	2316      	movs	r3, #22
 801a382:	18fb      	adds	r3, r7, r3
 801a384:	9301      	str	r3, [sp, #4]
 801a386:	2301      	movs	r3, #1
 801a388:	9300      	str	r3, [sp, #0]
 801a38a:	002b      	movs	r3, r5
 801a38c:	f000 fbc0 	bl	801ab10 <pppos_output_append>
 801a390:	0003      	movs	r3, r0
 801a392:	7023      	strb	r3, [r4, #0]
  while (n-- > 0) {
 801a394:	2222      	movs	r2, #34	; 0x22
 801a396:	18bb      	adds	r3, r7, r2
 801a398:	881b      	ldrh	r3, [r3, #0]
 801a39a:	18ba      	adds	r2, r7, r2
 801a39c:	1e59      	subs	r1, r3, #1
 801a39e:	8011      	strh	r1, [r2, #0]
 801a3a0:	2b00      	cmp	r3, #0
 801a3a2:	d1e2      	bne.n	801a36a <pppos_write+0x92>
  }

  err = pppos_output_last(pppos, err, nb, &fcs_out);
 801a3a4:	2621      	movs	r6, #33	; 0x21
 801a3a6:	19bc      	adds	r4, r7, r6
 801a3a8:	2316      	movs	r3, #22
 801a3aa:	18fd      	adds	r5, r7, r3
 801a3ac:	69ba      	ldr	r2, [r7, #24]
 801a3ae:	19bb      	adds	r3, r7, r6
 801a3b0:	2100      	movs	r1, #0
 801a3b2:	5659      	ldrsb	r1, [r3, r1]
 801a3b4:	69f8      	ldr	r0, [r7, #28]
 801a3b6:	002b      	movs	r3, r5
 801a3b8:	f000 fc44 	bl	801ac44 <pppos_output_last>
 801a3bc:	0003      	movs	r3, r0
 801a3be:	7023      	strb	r3, [r4, #0]
  if (err == ERR_OK) {
    PPPDEBUG(LOG_INFO, ("pppos_write[%d]: len=%d\n", ppp->netif->num, p->len));
  } else {
    PPPDEBUG(LOG_WARNING, ("pppos_write[%d]: output failed len=%d\n", ppp->netif->num, p->len));
  }
  pbuf_free(p);
 801a3c0:	687b      	ldr	r3, [r7, #4]
 801a3c2:	0018      	movs	r0, r3
 801a3c4:	f7ef fc04 	bl	8009bd0 <pbuf_free>
  return err;
 801a3c8:	19bb      	adds	r3, r7, r6
 801a3ca:	781b      	ldrb	r3, [r3, #0]
 801a3cc:	b25b      	sxtb	r3, r3
}
 801a3ce:	0018      	movs	r0, r3
 801a3d0:	46bd      	mov	sp, r7
 801a3d2:	b00b      	add	sp, #44	; 0x2c
 801a3d4:	bdf0      	pop	{r4, r5, r6, r7, pc}

0801a3d6 <pppos_netif_output>:

/* Called by PPP core */
static err_t
pppos_netif_output(ppp_pcb *ppp, void *ctx, struct pbuf *pb, u16_t protocol)
{
 801a3d6:	b5f0      	push	{r4, r5, r6, r7, lr}
 801a3d8:	b08d      	sub	sp, #52	; 0x34
 801a3da:	af02      	add	r7, sp, #8
 801a3dc:	60f8      	str	r0, [r7, #12]
 801a3de:	60b9      	str	r1, [r7, #8]
 801a3e0:	607a      	str	r2, [r7, #4]
 801a3e2:	001a      	movs	r2, r3
 801a3e4:	1cbb      	adds	r3, r7, #2
 801a3e6:	801a      	strh	r2, [r3, #0]
  pppos_pcb *pppos = (pppos_pcb *)ctx;
 801a3e8:	68bb      	ldr	r3, [r7, #8]
 801a3ea:	61bb      	str	r3, [r7, #24]
  LWIP_UNUSED_ARG(ppp);

  /* Grab an output buffer. Using PBUF_POOL here for tx is ok since the pbuf
     gets freed by 'pppos_output_last' before this function returns and thus
     cannot starve rx. */
  nb = pbuf_alloc(PBUF_RAW, 0, PBUF_POOL);
 801a3ec:	23c1      	movs	r3, #193	; 0xc1
 801a3ee:	005b      	lsls	r3, r3, #1
 801a3f0:	001a      	movs	r2, r3
 801a3f2:	2100      	movs	r1, #0
 801a3f4:	2000      	movs	r0, #0
 801a3f6:	f7ef f873 	bl	80094e0 <pbuf_alloc>
 801a3fa:	0003      	movs	r3, r0
 801a3fc:	617b      	str	r3, [r7, #20]
  if (nb == NULL) {
 801a3fe:	697b      	ldr	r3, [r7, #20]
 801a400:	2b00      	cmp	r3, #0
 801a402:	d102      	bne.n	801a40a <pppos_netif_output+0x34>
    PPPDEBUG(LOG_WARNING, ("pppos_netif_output[%d]: alloc fail\n", ppp->netif->num));
    LINK_STATS_INC(link.memerr);
    LINK_STATS_INC(link.drop);
    MIB2_STATS_NETIF_INC(ppp->netif, ifoutdiscards);
    return ERR_MEM;
 801a404:	2301      	movs	r3, #1
 801a406:	425b      	negs	r3, r3
 801a408:	e0c1      	b.n	801a58e <pppos_netif_output+0x1b8>
  }

  /* Set nb->tot_len to actual payload length */
  nb->tot_len = pb->tot_len;
 801a40a:	687b      	ldr	r3, [r7, #4]
 801a40c:	891a      	ldrh	r2, [r3, #8]
 801a40e:	697b      	ldr	r3, [r7, #20]
 801a410:	811a      	strh	r2, [r3, #8]

  /* If the link has been idle, we'll send a fresh flag character to
   * flush any noise. */
  err = ERR_OK;
 801a412:	2423      	movs	r4, #35	; 0x23
 801a414:	193b      	adds	r3, r7, r4
 801a416:	2200      	movs	r2, #0
 801a418:	701a      	strb	r2, [r3, #0]
  if ((sys_now() - pppos->last_xmit) >= PPP_MAXIDLEFLAG) {
 801a41a:	f002 fb8f 	bl	801cb3c <sys_now>
 801a41e:	0002      	movs	r2, r0
 801a420:	69bb      	ldr	r3, [r7, #24]
 801a422:	689b      	ldr	r3, [r3, #8]
 801a424:	1ad3      	subs	r3, r2, r3
 801a426:	2b63      	cmp	r3, #99	; 0x63
 801a428:	d90f      	bls.n	801a44a <pppos_netif_output+0x74>
    err = pppos_output_append(pppos, err,  nb, PPP_FLAG, 0, NULL);
 801a42a:	0023      	movs	r3, r4
 801a42c:	18fc      	adds	r4, r7, r3
 801a42e:	697a      	ldr	r2, [r7, #20]
 801a430:	18fb      	adds	r3, r7, r3
 801a432:	2100      	movs	r1, #0
 801a434:	5659      	ldrsb	r1, [r3, r1]
 801a436:	69b8      	ldr	r0, [r7, #24]
 801a438:	2300      	movs	r3, #0
 801a43a:	9301      	str	r3, [sp, #4]
 801a43c:	2300      	movs	r3, #0
 801a43e:	9300      	str	r3, [sp, #0]
 801a440:	237e      	movs	r3, #126	; 0x7e
 801a442:	f000 fb65 	bl	801ab10 <pppos_output_append>
 801a446:	0003      	movs	r3, r0
 801a448:	7023      	strb	r3, [r4, #0]
  }

  fcs_out = PPP_INITFCS;
 801a44a:	2612      	movs	r6, #18
 801a44c:	19bb      	adds	r3, r7, r6
 801a44e:	2201      	movs	r2, #1
 801a450:	4252      	negs	r2, r2
 801a452:	801a      	strh	r2, [r3, #0]
  if (!pppos->accomp) {
 801a454:	69bb      	ldr	r3, [r7, #24]
 801a456:	222c      	movs	r2, #44	; 0x2c
 801a458:	5c9b      	ldrb	r3, [r3, r2]
 801a45a:	2204      	movs	r2, #4
 801a45c:	4013      	ands	r3, r2
 801a45e:	b2db      	uxtb	r3, r3
 801a460:	2b00      	cmp	r3, #0
 801a462:	d11e      	bne.n	801a4a2 <pppos_netif_output+0xcc>
    err = pppos_output_append(pppos, err,  nb, PPP_ALLSTATIONS, 1, &fcs_out);
 801a464:	2523      	movs	r5, #35	; 0x23
 801a466:	197c      	adds	r4, r7, r5
 801a468:	697a      	ldr	r2, [r7, #20]
 801a46a:	197b      	adds	r3, r7, r5
 801a46c:	2100      	movs	r1, #0
 801a46e:	5659      	ldrsb	r1, [r3, r1]
 801a470:	69b8      	ldr	r0, [r7, #24]
 801a472:	19bb      	adds	r3, r7, r6
 801a474:	9301      	str	r3, [sp, #4]
 801a476:	2301      	movs	r3, #1
 801a478:	9300      	str	r3, [sp, #0]
 801a47a:	23ff      	movs	r3, #255	; 0xff
 801a47c:	f000 fb48 	bl	801ab10 <pppos_output_append>
 801a480:	0003      	movs	r3, r0
 801a482:	7023      	strb	r3, [r4, #0]
    err = pppos_output_append(pppos, err,  nb, PPP_UI, 1, &fcs_out);
 801a484:	197c      	adds	r4, r7, r5
 801a486:	697a      	ldr	r2, [r7, #20]
 801a488:	197b      	adds	r3, r7, r5
 801a48a:	2100      	movs	r1, #0
 801a48c:	5659      	ldrsb	r1, [r3, r1]
 801a48e:	69b8      	ldr	r0, [r7, #24]
 801a490:	19bb      	adds	r3, r7, r6
 801a492:	9301      	str	r3, [sp, #4]
 801a494:	2301      	movs	r3, #1
 801a496:	9300      	str	r3, [sp, #0]
 801a498:	2303      	movs	r3, #3
 801a49a:	f000 fb39 	bl	801ab10 <pppos_output_append>
 801a49e:	0003      	movs	r3, r0
 801a4a0:	7023      	strb	r3, [r4, #0]
  }
  if (!pppos->pcomp || protocol > 0xFF) {
 801a4a2:	69bb      	ldr	r3, [r7, #24]
 801a4a4:	222c      	movs	r2, #44	; 0x2c
 801a4a6:	5c9b      	ldrb	r3, [r3, r2]
 801a4a8:	2202      	movs	r2, #2
 801a4aa:	4013      	ands	r3, r2
 801a4ac:	b2db      	uxtb	r3, r3
 801a4ae:	2b00      	cmp	r3, #0
 801a4b0:	d003      	beq.n	801a4ba <pppos_netif_output+0xe4>
 801a4b2:	1cbb      	adds	r3, r7, #2
 801a4b4:	881b      	ldrh	r3, [r3, #0]
 801a4b6:	2bff      	cmp	r3, #255	; 0xff
 801a4b8:	d915      	bls.n	801a4e6 <pppos_netif_output+0x110>
    err = pppos_output_append(pppos, err,  nb, (protocol >> 8) & 0xFF, 1, &fcs_out);
 801a4ba:	1cbb      	adds	r3, r7, #2
 801a4bc:	881b      	ldrh	r3, [r3, #0]
 801a4be:	0a1b      	lsrs	r3, r3, #8
 801a4c0:	b29b      	uxth	r3, r3
 801a4c2:	b2dd      	uxtb	r5, r3
 801a4c4:	2323      	movs	r3, #35	; 0x23
 801a4c6:	18fc      	adds	r4, r7, r3
 801a4c8:	697a      	ldr	r2, [r7, #20]
 801a4ca:	18fb      	adds	r3, r7, r3
 801a4cc:	2100      	movs	r1, #0
 801a4ce:	5659      	ldrsb	r1, [r3, r1]
 801a4d0:	69b8      	ldr	r0, [r7, #24]
 801a4d2:	2312      	movs	r3, #18
 801a4d4:	18fb      	adds	r3, r7, r3
 801a4d6:	9301      	str	r3, [sp, #4]
 801a4d8:	2301      	movs	r3, #1
 801a4da:	9300      	str	r3, [sp, #0]
 801a4dc:	002b      	movs	r3, r5
 801a4de:	f000 fb17 	bl	801ab10 <pppos_output_append>
 801a4e2:	0003      	movs	r3, r0
 801a4e4:	7023      	strb	r3, [r4, #0]
  }
  err = pppos_output_append(pppos, err,  nb, protocol & 0xFF, 1, &fcs_out);
 801a4e6:	1cbb      	adds	r3, r7, #2
 801a4e8:	881b      	ldrh	r3, [r3, #0]
 801a4ea:	b2dd      	uxtb	r5, r3
 801a4ec:	2323      	movs	r3, #35	; 0x23
 801a4ee:	18fc      	adds	r4, r7, r3
 801a4f0:	697a      	ldr	r2, [r7, #20]
 801a4f2:	18fb      	adds	r3, r7, r3
 801a4f4:	2100      	movs	r1, #0
 801a4f6:	5659      	ldrsb	r1, [r3, r1]
 801a4f8:	69b8      	ldr	r0, [r7, #24]
 801a4fa:	2312      	movs	r3, #18
 801a4fc:	18fb      	adds	r3, r7, r3
 801a4fe:	9301      	str	r3, [sp, #4]
 801a500:	2301      	movs	r3, #1
 801a502:	9300      	str	r3, [sp, #0]
 801a504:	002b      	movs	r3, r5
 801a506:	f000 fb03 	bl	801ab10 <pppos_output_append>
 801a50a:	0003      	movs	r3, r0
 801a50c:	7023      	strb	r3, [r4, #0]

  /* Load packet. */
  for(p = pb; p; p = p->next) {
 801a50e:	687b      	ldr	r3, [r7, #4]
 801a510:	627b      	str	r3, [r7, #36]	; 0x24
 801a512:	e028      	b.n	801a566 <pppos_netif_output+0x190>
    u16_t n = p->len;
 801a514:	2320      	movs	r3, #32
 801a516:	18fb      	adds	r3, r7, r3
 801a518:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801a51a:	8952      	ldrh	r2, [r2, #10]
 801a51c:	801a      	strh	r2, [r3, #0]
    u8_t *s = (u8_t*)p->payload;
 801a51e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a520:	685b      	ldr	r3, [r3, #4]
 801a522:	61fb      	str	r3, [r7, #28]

    while (n-- > 0) {
 801a524:	e014      	b.n	801a550 <pppos_netif_output+0x17a>
      err = pppos_output_append(pppos, err,  nb, *s++, 1, &fcs_out);
 801a526:	69fb      	ldr	r3, [r7, #28]
 801a528:	1c5a      	adds	r2, r3, #1
 801a52a:	61fa      	str	r2, [r7, #28]
 801a52c:	781d      	ldrb	r5, [r3, #0]
 801a52e:	2323      	movs	r3, #35	; 0x23
 801a530:	18fc      	adds	r4, r7, r3
 801a532:	697a      	ldr	r2, [r7, #20]
 801a534:	18fb      	adds	r3, r7, r3
 801a536:	2100      	movs	r1, #0
 801a538:	5659      	ldrsb	r1, [r3, r1]
 801a53a:	69b8      	ldr	r0, [r7, #24]
 801a53c:	2312      	movs	r3, #18
 801a53e:	18fb      	adds	r3, r7, r3
 801a540:	9301      	str	r3, [sp, #4]
 801a542:	2301      	movs	r3, #1
 801a544:	9300      	str	r3, [sp, #0]
 801a546:	002b      	movs	r3, r5
 801a548:	f000 fae2 	bl	801ab10 <pppos_output_append>
 801a54c:	0003      	movs	r3, r0
 801a54e:	7023      	strb	r3, [r4, #0]
    while (n-- > 0) {
 801a550:	2220      	movs	r2, #32
 801a552:	18bb      	adds	r3, r7, r2
 801a554:	881b      	ldrh	r3, [r3, #0]
 801a556:	18ba      	adds	r2, r7, r2
 801a558:	1e59      	subs	r1, r3, #1
 801a55a:	8011      	strh	r1, [r2, #0]
 801a55c:	2b00      	cmp	r3, #0
 801a55e:	d1e2      	bne.n	801a526 <pppos_netif_output+0x150>
  for(p = pb; p; p = p->next) {
 801a560:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a562:	681b      	ldr	r3, [r3, #0]
 801a564:	627b      	str	r3, [r7, #36]	; 0x24
 801a566:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a568:	2b00      	cmp	r3, #0
 801a56a:	d1d3      	bne.n	801a514 <pppos_netif_output+0x13e>
    }
  }

  err = pppos_output_last(pppos, err, nb, &fcs_out);
 801a56c:	2623      	movs	r6, #35	; 0x23
 801a56e:	19bc      	adds	r4, r7, r6
 801a570:	2312      	movs	r3, #18
 801a572:	18fd      	adds	r5, r7, r3
 801a574:	697a      	ldr	r2, [r7, #20]
 801a576:	19bb      	adds	r3, r7, r6
 801a578:	2100      	movs	r1, #0
 801a57a:	5659      	ldrsb	r1, [r3, r1]
 801a57c:	69b8      	ldr	r0, [r7, #24]
 801a57e:	002b      	movs	r3, r5
 801a580:	f000 fb60 	bl	801ac44 <pppos_output_last>
 801a584:	0003      	movs	r3, r0
 801a586:	7023      	strb	r3, [r4, #0]
  if (err == ERR_OK) {
    PPPDEBUG(LOG_INFO, ("pppos_netif_output[%d]: proto=0x%"X16_F", len = %d\n", ppp->netif->num, protocol, pb->tot_len));
  } else {
    PPPDEBUG(LOG_WARNING, ("pppos_netif_output[%d]: output failed proto=0x%"X16_F", len = %d\n", ppp->netif->num, protocol, pb->tot_len));
  }
  return err;
 801a588:	19bb      	adds	r3, r7, r6
 801a58a:	781b      	ldrb	r3, [r3, #0]
 801a58c:	b25b      	sxtb	r3, r3
}
 801a58e:	0018      	movs	r0, r3
 801a590:	46bd      	mov	sp, r7
 801a592:	b00b      	add	sp, #44	; 0x2c
 801a594:	bdf0      	pop	{r4, r5, r6, r7, pc}

0801a596 <pppos_connect>:

static void
pppos_connect(ppp_pcb *ppp, void *ctx)
{
 801a596:	b580      	push	{r7, lr}
 801a598:	b084      	sub	sp, #16
 801a59a:	af00      	add	r7, sp, #0
 801a59c:	6078      	str	r0, [r7, #4]
 801a59e:	6039      	str	r1, [r7, #0]
  pppos_pcb *pppos = (pppos_pcb *)ctx;
 801a5a0:	683b      	ldr	r3, [r7, #0]
 801a5a2:	60fb      	str	r3, [r7, #12]
  /* input pbuf left over from last session? */
  pppos_input_free_current_packet(pppos);
#endif /* PPP_INPROC_IRQ_SAFE */

  /* reset PPPoS control block to its initial state */
  memset(&pppos->last_xmit, 0, sizeof(pppos_pcb) - offsetof(pppos_pcb, last_xmit));
 801a5a4:	68fb      	ldr	r3, [r7, #12]
 801a5a6:	3308      	adds	r3, #8
 801a5a8:	2258      	movs	r2, #88	; 0x58
 801a5aa:	2100      	movs	r1, #0
 801a5ac:	0018      	movs	r0, r3
 801a5ae:	f002 fb33 	bl	801cc18 <memset>

  /*
   * Default the in and out accm so that escape and flag characters
   * are always escaped.
   */
  pppos->in_accm[15] = 0x60; /* no need to protect since RX is not running */
 801a5b2:	68fb      	ldr	r3, [r7, #12]
 801a5b4:	223c      	movs	r2, #60	; 0x3c
 801a5b6:	2160      	movs	r1, #96	; 0x60
 801a5b8:	5499      	strb	r1, [r3, r2]
  pppos->out_accm[15] = 0x60;
 801a5ba:	68fb      	ldr	r3, [r7, #12]
 801a5bc:	2260      	movs	r2, #96	; 0x60
 801a5be:	76da      	strb	r2, [r3, #27]
  PPPOS_PROTECT(lev);
  pppos->open = 1;
 801a5c0:	68fb      	ldr	r3, [r7, #12]
 801a5c2:	222c      	movs	r2, #44	; 0x2c
 801a5c4:	5c99      	ldrb	r1, [r3, r2]
 801a5c6:	2001      	movs	r0, #1
 801a5c8:	4301      	orrs	r1, r0
 801a5ca:	5499      	strb	r1, [r3, r2]

  /*
   * Start the connection and handle incoming events (packet or timeout).
   */
  PPPDEBUG(LOG_INFO, ("pppos_connect: unit %d: connecting\n", ppp->netif->num));
  ppp_start(ppp); /* notify upper layers */
 801a5cc:	687b      	ldr	r3, [r7, #4]
 801a5ce:	0018      	movs	r0, r3
 801a5d0:	f7ff fbc4 	bl	8019d5c <ppp_start>
}
 801a5d4:	46c0      	nop			; (mov r8, r8)
 801a5d6:	46bd      	mov	sp, r7
 801a5d8:	b004      	add	sp, #16
 801a5da:	bd80      	pop	{r7, pc}

0801a5dc <pppos_disconnect>:
}
#endif /* PPP_SERVER */

static void
pppos_disconnect(ppp_pcb *ppp, void *ctx)
{
 801a5dc:	b580      	push	{r7, lr}
 801a5de:	b084      	sub	sp, #16
 801a5e0:	af00      	add	r7, sp, #0
 801a5e2:	6078      	str	r0, [r7, #4]
 801a5e4:	6039      	str	r1, [r7, #0]
  pppos_pcb *pppos = (pppos_pcb *)ctx;
 801a5e6:	683b      	ldr	r3, [r7, #0]
 801a5e8:	60fb      	str	r3, [r7, #12]
  PPPOS_DECL_PROTECT(lev);

  PPPOS_PROTECT(lev);
  pppos->open = 0;
 801a5ea:	68fb      	ldr	r3, [r7, #12]
 801a5ec:	222c      	movs	r2, #44	; 0x2c
 801a5ee:	5c99      	ldrb	r1, [r3, r2]
 801a5f0:	2001      	movs	r0, #1
 801a5f2:	4381      	bics	r1, r0
 801a5f4:	5499      	strb	r1, [r3, r2]
   * pppos_input_free_current_packet() here because
   * rx IRQ might still call pppos_input().
   */
#if !PPP_INPROC_IRQ_SAFE
  /* input pbuf left ? */
  pppos_input_free_current_packet(pppos);
 801a5f6:	68fb      	ldr	r3, [r7, #12]
 801a5f8:	0018      	movs	r0, r3
 801a5fa:	f000 fa50 	bl	801aa9e <pppos_input_free_current_packet>
#endif /* !PPP_INPROC_IRQ_SAFE */

  ppp_link_end(ppp); /* notify upper layers */
 801a5fe:	687b      	ldr	r3, [r7, #4]
 801a600:	0018      	movs	r0, r3
 801a602:	f7ff fbc5 	bl	8019d90 <ppp_link_end>
}
 801a606:	46c0      	nop			; (mov r8, r8)
 801a608:	46bd      	mov	sp, r7
 801a60a:	b004      	add	sp, #16
 801a60c:	bd80      	pop	{r7, pc}
	...

0801a610 <pppos_destroy>:

static err_t
pppos_destroy(ppp_pcb *ppp, void *ctx)
{
 801a610:	b580      	push	{r7, lr}
 801a612:	b084      	sub	sp, #16
 801a614:	af00      	add	r7, sp, #0
 801a616:	6078      	str	r0, [r7, #4]
 801a618:	6039      	str	r1, [r7, #0]
  pppos_pcb *pppos = (pppos_pcb *)ctx;
 801a61a:	683b      	ldr	r3, [r7, #0]
 801a61c:	60fb      	str	r3, [r7, #12]
#if PPP_INPROC_IRQ_SAFE
  /* input pbuf left ? */
  pppos_input_free_current_packet(pppos);
#endif /* PPP_INPROC_IRQ_SAFE */

  LWIP_MEMPOOL_FREE(PPPOS_PCB, pppos);
 801a61e:	68fa      	ldr	r2, [r7, #12]
 801a620:	4b04      	ldr	r3, [pc, #16]	; (801a634 <pppos_destroy+0x24>)
 801a622:	0011      	movs	r1, r2
 801a624:	0018      	movs	r0, r3
 801a626:	f7ee fbbd 	bl	8008da4 <memp_free_pool>
  return ERR_OK;
 801a62a:	2300      	movs	r3, #0
}
 801a62c:	0018      	movs	r0, r3
 801a62e:	46bd      	mov	sp, r7
 801a630:	b004      	add	sp, #16
 801a632:	bd80      	pop	{r7, pc}
 801a634:	080226e4 	.word	0x080226e4

0801a638 <pppos_input>:
 * @param s received data
 * @param l length of received data
 */
void
pppos_input(ppp_pcb *ppp, u8_t *s, int l)
{
 801a638:	b580      	push	{r7, lr}
 801a63a:	b08a      	sub	sp, #40	; 0x28
 801a63c:	af00      	add	r7, sp, #0
 801a63e:	60f8      	str	r0, [r7, #12]
 801a640:	60b9      	str	r1, [r7, #8]
 801a642:	607a      	str	r2, [r7, #4]
  pppos_pcb *pppos = (pppos_pcb *)ppp->link_ctx_cb;
 801a644:	68fb      	ldr	r3, [r7, #12]
 801a646:	691b      	ldr	r3, [r3, #16]
 801a648:	623b      	str	r3, [r7, #32]
#if !PPP_INPROC_IRQ_SAFE
  LWIP_ASSERT_CORE_LOCKED();
#endif

  PPPDEBUG(LOG_DEBUG, ("pppos_input[%d]: got %d bytes\n", ppp->netif->num, l));
  while (l-- > 0) {
 801a64a:	e1ae      	b.n	801a9aa <pppos_input+0x372>
    cur_char = *s++;
 801a64c:	68bb      	ldr	r3, [r7, #8]
 801a64e:	1c5a      	adds	r2, r3, #1
 801a650:	60ba      	str	r2, [r7, #8]
 801a652:	2027      	movs	r0, #39	; 0x27
 801a654:	183a      	adds	r2, r7, r0
 801a656:	781b      	ldrb	r3, [r3, #0]
 801a658:	7013      	strb	r3, [r2, #0]
    /* ppp_input can disconnect the interface, we need to abort to prevent a memory
     * leak if there are remaining bytes because pppos_connect and pppos_listen
     * functions expect input buffer to be free. Furthermore there are no real
     * reason to continue reading bytes if we are disconnected.
     */
    if (!pppos->open) {
 801a65a:	6a3b      	ldr	r3, [r7, #32]
 801a65c:	222c      	movs	r2, #44	; 0x2c
 801a65e:	5c9b      	ldrb	r3, [r3, r2]
 801a660:	2201      	movs	r2, #1
 801a662:	4013      	ands	r3, r2
 801a664:	b2db      	uxtb	r3, r3
 801a666:	2b00      	cmp	r3, #0
 801a668:	d100      	bne.n	801a66c <pppos_input+0x34>
 801a66a:	e1a5      	b.n	801a9b8 <pppos_input+0x380>
      PPPOS_UNPROTECT(lev);
      return;
    }
    escaped = ESCAPE_P(pppos->in_accm, cur_char);
 801a66c:	183b      	adds	r3, r7, r0
 801a66e:	781b      	ldrb	r3, [r3, #0]
 801a670:	08db      	lsrs	r3, r3, #3
 801a672:	b2db      	uxtb	r3, r3
 801a674:	0019      	movs	r1, r3
 801a676:	6a3b      	ldr	r3, [r7, #32]
 801a678:	222d      	movs	r2, #45	; 0x2d
 801a67a:	185b      	adds	r3, r3, r1
 801a67c:	189b      	adds	r3, r3, r2
 801a67e:	781b      	ldrb	r3, [r3, #0]
 801a680:	b25b      	sxtb	r3, r3
 801a682:	183a      	adds	r2, r7, r0
 801a684:	7812      	ldrb	r2, [r2, #0]
 801a686:	2107      	movs	r1, #7
 801a688:	400a      	ands	r2, r1
 801a68a:	2101      	movs	r1, #1
 801a68c:	4091      	lsls	r1, r2
 801a68e:	000a      	movs	r2, r1
 801a690:	b252      	sxtb	r2, r2
 801a692:	4013      	ands	r3, r2
 801a694:	b25a      	sxtb	r2, r3
 801a696:	211f      	movs	r1, #31
 801a698:	187b      	adds	r3, r7, r1
 801a69a:	701a      	strb	r2, [r3, #0]
    PPPOS_UNPROTECT(lev);
    /* Handle special characters. */
    if (escaped) {
 801a69c:	187b      	adds	r3, r7, r1
 801a69e:	781b      	ldrb	r3, [r3, #0]
 801a6a0:	2b00      	cmp	r3, #0
 801a6a2:	d100      	bne.n	801a6a6 <pppos_input+0x6e>
 801a6a4:	e086      	b.n	801a7b4 <pppos_input+0x17c>
      /* Check for escape sequences. */
      /* XXX Note that this does not handle an escaped 0x5d character which
       * would appear as an escape character.  Since this is an ASCII ']'
       * and there is no reason that I know of to escape it, I won't complicate
       * the code to handle this case. GLL */
      if (cur_char == PPP_ESCAPE) {
 801a6a6:	183b      	adds	r3, r7, r0
 801a6a8:	781b      	ldrb	r3, [r3, #0]
 801a6aa:	2b7d      	cmp	r3, #125	; 0x7d
 801a6ac:	d104      	bne.n	801a6b8 <pppos_input+0x80>
        pppos->in_escaped = 1;
 801a6ae:	6a3b      	ldr	r3, [r7, #32]
 801a6b0:	225d      	movs	r2, #93	; 0x5d
 801a6b2:	2101      	movs	r1, #1
 801a6b4:	5499      	strb	r1, [r3, r2]
 801a6b6:	e178      	b.n	801a9aa <pppos_input+0x372>
      /* Check for the flag character. */
      } else if (cur_char == PPP_FLAG) {
 801a6b8:	2327      	movs	r3, #39	; 0x27
 801a6ba:	18fb      	adds	r3, r7, r3
 801a6bc:	781b      	ldrb	r3, [r3, #0]
 801a6be:	2b7e      	cmp	r3, #126	; 0x7e
 801a6c0:	d000      	beq.n	801a6c4 <pppos_input+0x8c>
 801a6c2:	e172      	b.n	801a9aa <pppos_input+0x372>
        /* If this is just an extra flag character, ignore it. */
        if (pppos->in_state <= PDADDRESS) {
 801a6c4:	6a3b      	ldr	r3, [r7, #32]
 801a6c6:	225c      	movs	r2, #92	; 0x5c
 801a6c8:	5c9b      	ldrb	r3, [r3, r2]
 801a6ca:	2b02      	cmp	r3, #2
 801a6cc:	d964      	bls.n	801a798 <pppos_input+0x160>
          /* ignore it */;
        /* If we haven't received the packet header, drop what has come in. */
        } else if (pppos->in_state < PDDATA) {
 801a6ce:	6a3b      	ldr	r3, [r7, #32]
 801a6d0:	225c      	movs	r2, #92	; 0x5c
 801a6d2:	5c9b      	ldrb	r3, [r3, r2]
 801a6d4:	2b05      	cmp	r3, #5
 801a6d6:	d804      	bhi.n	801a6e2 <pppos_input+0xaa>
          PPPDEBUG(LOG_WARNING,
                   ("pppos_input[%d]: Dropping incomplete packet %d\n",
                    ppp->netif->num, pppos->in_state));
          LINK_STATS_INC(link.lenerr);
          pppos_input_drop(pppos);
 801a6d8:	6a3b      	ldr	r3, [r7, #32]
 801a6da:	0018      	movs	r0, r3
 801a6dc:	f000 fa05 	bl	801aaea <pppos_input_drop>
 801a6e0:	e05a      	b.n	801a798 <pppos_input+0x160>
        /* If the fcs is invalid, drop the packet. */
        } else if (pppos->in_fcs != PPP_GOODFCS) {
 801a6e2:	6a3b      	ldr	r3, [r7, #32]
 801a6e4:	225a      	movs	r2, #90	; 0x5a
 801a6e6:	5a9b      	ldrh	r3, [r3, r2]
 801a6e8:	4ab5      	ldr	r2, [pc, #724]	; (801a9c0 <pppos_input+0x388>)
 801a6ea:	4293      	cmp	r3, r2
 801a6ec:	d004      	beq.n	801a6f8 <pppos_input+0xc0>
          PPPDEBUG(LOG_INFO,
                   ("pppos_input[%d]: Dropping bad fcs 0x%"X16_F" proto=0x%"X16_F"\n",
                    ppp->netif->num, pppos->in_fcs, pppos->in_protocol));
          /* Note: If you get lots of these, check for UART frame errors or try different baud rate */
          LINK_STATS_INC(link.chkerr);
          pppos_input_drop(pppos);
 801a6ee:	6a3b      	ldr	r3, [r7, #32]
 801a6f0:	0018      	movs	r0, r3
 801a6f2:	f000 f9fa 	bl	801aaea <pppos_input_drop>
 801a6f6:	e04f      	b.n	801a798 <pppos_input+0x160>
        /* Otherwise it's a good packet so pass it on. */
        } else {
          struct pbuf *inp;
          /* Trim off the checksum. */
          if(pppos->in_tail->len > 2) {
 801a6f8:	6a3b      	ldr	r3, [r7, #32]
 801a6fa:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a6fc:	895b      	ldrh	r3, [r3, #10]
 801a6fe:	2b02      	cmp	r3, #2
 801a700:	d91c      	bls.n	801a73c <pppos_input+0x104>
            pppos->in_tail->len -= 2;
 801a702:	6a3b      	ldr	r3, [r7, #32]
 801a704:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a706:	895a      	ldrh	r2, [r3, #10]
 801a708:	6a3b      	ldr	r3, [r7, #32]
 801a70a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a70c:	3a02      	subs	r2, #2
 801a70e:	b292      	uxth	r2, r2
 801a710:	815a      	strh	r2, [r3, #10]

            pppos->in_tail->tot_len = pppos->in_tail->len;
 801a712:	6a3b      	ldr	r3, [r7, #32]
 801a714:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801a716:	6a3b      	ldr	r3, [r7, #32]
 801a718:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a71a:	8952      	ldrh	r2, [r2, #10]
 801a71c:	811a      	strh	r2, [r3, #8]
            if (pppos->in_tail != pppos->in_head) {
 801a71e:	6a3b      	ldr	r3, [r7, #32]
 801a720:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801a722:	6a3b      	ldr	r3, [r7, #32]
 801a724:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801a726:	429a      	cmp	r2, r3
 801a728:	d027      	beq.n	801a77a <pppos_input+0x142>
              pbuf_cat(pppos->in_head, pppos->in_tail);
 801a72a:	6a3b      	ldr	r3, [r7, #32]
 801a72c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 801a72e:	6a3b      	ldr	r3, [r7, #32]
 801a730:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a732:	0019      	movs	r1, r3
 801a734:	0010      	movs	r0, r2
 801a736:	f7ef fb2b 	bl	8009d90 <pbuf_cat>
 801a73a:	e01e      	b.n	801a77a <pppos_input+0x142>
            }
          } else {
            pppos->in_tail->tot_len = pppos->in_tail->len;
 801a73c:	6a3b      	ldr	r3, [r7, #32]
 801a73e:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801a740:	6a3b      	ldr	r3, [r7, #32]
 801a742:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a744:	8952      	ldrh	r2, [r2, #10]
 801a746:	811a      	strh	r2, [r3, #8]
            if (pppos->in_tail != pppos->in_head) {
 801a748:	6a3b      	ldr	r3, [r7, #32]
 801a74a:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801a74c:	6a3b      	ldr	r3, [r7, #32]
 801a74e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801a750:	429a      	cmp	r2, r3
 801a752:	d007      	beq.n	801a764 <pppos_input+0x12c>
              pbuf_cat(pppos->in_head, pppos->in_tail);
 801a754:	6a3b      	ldr	r3, [r7, #32]
 801a756:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 801a758:	6a3b      	ldr	r3, [r7, #32]
 801a75a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a75c:	0019      	movs	r1, r3
 801a75e:	0010      	movs	r0, r2
 801a760:	f7ef fb16 	bl	8009d90 <pbuf_cat>
            }

            pbuf_realloc(pppos->in_head, pppos->in_head->tot_len - 2);
 801a764:	6a3b      	ldr	r3, [r7, #32]
 801a766:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 801a768:	6a3b      	ldr	r3, [r7, #32]
 801a76a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801a76c:	891b      	ldrh	r3, [r3, #8]
 801a76e:	3b02      	subs	r3, #2
 801a770:	b29b      	uxth	r3, r3
 801a772:	0019      	movs	r1, r3
 801a774:	0010      	movs	r0, r2
 801a776:	f7ef f831 	bl	80097dc <pbuf_realloc>
          }

          /* Dispatch the packet thereby consuming it. */
          inp = pppos->in_head;
 801a77a:	6a3b      	ldr	r3, [r7, #32]
 801a77c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801a77e:	613b      	str	r3, [r7, #16]
          /* Packet consumed, release our references. */
          pppos->in_head = NULL;
 801a780:	6a3b      	ldr	r3, [r7, #32]
 801a782:	2200      	movs	r2, #0
 801a784:	651a      	str	r2, [r3, #80]	; 0x50
          pppos->in_tail = NULL;
 801a786:	6a3b      	ldr	r3, [r7, #32]
 801a788:	2200      	movs	r2, #0
 801a78a:	655a      	str	r2, [r3, #84]	; 0x54
            pbuf_free(inp);
            LINK_STATS_INC(link.drop);
            MIB2_STATS_NETIF_INC(ppp->netif, ifindiscards);
          }
#else /* PPP_INPROC_IRQ_SAFE */
          ppp_input(ppp, inp);
 801a78c:	693a      	ldr	r2, [r7, #16]
 801a78e:	68fb      	ldr	r3, [r7, #12]
 801a790:	0011      	movs	r1, r2
 801a792:	0018      	movs	r0, r3
 801a794:	f7ff fb1e 	bl	8019dd4 <ppp_input>
#endif /* PPP_INPROC_IRQ_SAFE */
        }

        /* Prepare for a new packet. */
        pppos->in_fcs = PPP_INITFCS;
 801a798:	6a3b      	ldr	r3, [r7, #32]
 801a79a:	225a      	movs	r2, #90	; 0x5a
 801a79c:	2101      	movs	r1, #1
 801a79e:	4249      	negs	r1, r1
 801a7a0:	5299      	strh	r1, [r3, r2]
        pppos->in_state = PDADDRESS;
 801a7a2:	6a3b      	ldr	r3, [r7, #32]
 801a7a4:	225c      	movs	r2, #92	; 0x5c
 801a7a6:	2102      	movs	r1, #2
 801a7a8:	5499      	strb	r1, [r3, r2]
        pppos->in_escaped = 0;
 801a7aa:	6a3b      	ldr	r3, [r7, #32]
 801a7ac:	225d      	movs	r2, #93	; 0x5d
 801a7ae:	2100      	movs	r1, #0
 801a7b0:	5499      	strb	r1, [r3, r2]
 801a7b2:	e0fa      	b.n	801a9aa <pppos_input+0x372>
                 ("pppos_input[%d]: Dropping ACCM char <%d>\n", ppp->netif->num, cur_char));
      }
    /* Process other characters. */
    } else {
      /* Unencode escaped characters. */
      if (pppos->in_escaped) {
 801a7b4:	6a3b      	ldr	r3, [r7, #32]
 801a7b6:	225d      	movs	r2, #93	; 0x5d
 801a7b8:	5c9b      	ldrb	r3, [r3, r2]
 801a7ba:	2b00      	cmp	r3, #0
 801a7bc:	d00a      	beq.n	801a7d4 <pppos_input+0x19c>
        pppos->in_escaped = 0;
 801a7be:	6a3b      	ldr	r3, [r7, #32]
 801a7c0:	225d      	movs	r2, #93	; 0x5d
 801a7c2:	2100      	movs	r1, #0
 801a7c4:	5499      	strb	r1, [r3, r2]
        cur_char ^= PPP_TRANS;
 801a7c6:	2227      	movs	r2, #39	; 0x27
 801a7c8:	18bb      	adds	r3, r7, r2
 801a7ca:	18ba      	adds	r2, r7, r2
 801a7cc:	7812      	ldrb	r2, [r2, #0]
 801a7ce:	2120      	movs	r1, #32
 801a7d0:	404a      	eors	r2, r1
 801a7d2:	701a      	strb	r2, [r3, #0]
      }

      /* Process character relative to current state. */
      switch(pppos->in_state) {
 801a7d4:	6a3b      	ldr	r3, [r7, #32]
 801a7d6:	225c      	movs	r2, #92	; 0x5c
 801a7d8:	5c9b      	ldrb	r3, [r3, r2]
 801a7da:	2b06      	cmp	r3, #6
 801a7dc:	d900      	bls.n	801a7e0 <pppos_input+0x1a8>
 801a7de:	e0ca      	b.n	801a976 <pppos_input+0x33e>
 801a7e0:	009a      	lsls	r2, r3, #2
 801a7e2:	4b78      	ldr	r3, [pc, #480]	; (801a9c4 <pppos_input+0x38c>)
 801a7e4:	18d3      	adds	r3, r2, r3
 801a7e6:	681b      	ldr	r3, [r3, #0]
 801a7e8:	469f      	mov	pc, r3
        case PDIDLE:                    /* Idle state - waiting. */
          /* Drop the character if it's not 0xff
           * we would have processed a flag character above. */
          if (cur_char != PPP_ALLSTATIONS) {
 801a7ea:	2327      	movs	r3, #39	; 0x27
 801a7ec:	18fb      	adds	r3, r7, r3
 801a7ee:	781b      	ldrb	r3, [r3, #0]
 801a7f0:	2bff      	cmp	r3, #255	; 0xff
 801a7f2:	d000      	beq.n	801a7f6 <pppos_input+0x1be>
 801a7f4:	e0c1      	b.n	801a97a <pppos_input+0x342>
          /* no break */
          /* Fall through */

        case PDSTART:                   /* Process start flag. */
          /* Prepare for a new packet. */
          pppos->in_fcs = PPP_INITFCS;
 801a7f6:	6a3b      	ldr	r3, [r7, #32]
 801a7f8:	225a      	movs	r2, #90	; 0x5a
 801a7fa:	2101      	movs	r1, #1
 801a7fc:	4249      	negs	r1, r1
 801a7fe:	5299      	strh	r1, [r3, r2]
          /* no break */
          /* Fall through */

        case PDADDRESS:                 /* Process address field. */
          if (cur_char == PPP_ALLSTATIONS) {
 801a800:	2327      	movs	r3, #39	; 0x27
 801a802:	18fb      	adds	r3, r7, r3
 801a804:	781b      	ldrb	r3, [r3, #0]
 801a806:	2bff      	cmp	r3, #255	; 0xff
 801a808:	d104      	bne.n	801a814 <pppos_input+0x1dc>
            pppos->in_state = PDCONTROL;
 801a80a:	6a3b      	ldr	r3, [r7, #32]
 801a80c:	225c      	movs	r2, #92	; 0x5c
 801a80e:	2103      	movs	r1, #3
 801a810:	5499      	strb	r1, [r3, r2]
            break;
 801a812:	e0b3      	b.n	801a97c <pppos_input+0x344>
          /* Else assume compressed address and control fields so
           * fall through to get the protocol... */
          /* Fall through */
        case PDCONTROL:                 /* Process control field. */
          /* If we don't get a valid control code, restart. */
          if (cur_char == PPP_UI) {
 801a814:	2327      	movs	r3, #39	; 0x27
 801a816:	18fb      	adds	r3, r7, r3
 801a818:	781b      	ldrb	r3, [r3, #0]
 801a81a:	2b03      	cmp	r3, #3
 801a81c:	d104      	bne.n	801a828 <pppos_input+0x1f0>
            pppos->in_state = PDPROTOCOL1;
 801a81e:	6a3b      	ldr	r3, [r7, #32]
 801a820:	225c      	movs	r2, #92	; 0x5c
 801a822:	2104      	movs	r1, #4
 801a824:	5499      	strb	r1, [r3, r2]
            break;
 801a826:	e0a9      	b.n	801a97c <pppos_input+0x344>
          /* Fall through */

      case PDPROTOCOL1:               /* Process protocol field 1. */
          /* If the lower bit is set, this is the end of the protocol
           * field. */
          if (cur_char & 1) {
 801a828:	2127      	movs	r1, #39	; 0x27
 801a82a:	187b      	adds	r3, r7, r1
 801a82c:	781b      	ldrb	r3, [r3, #0]
 801a82e:	2201      	movs	r2, #1
 801a830:	4013      	ands	r3, r2
 801a832:	d00a      	beq.n	801a84a <pppos_input+0x212>
            pppos->in_protocol = cur_char;
 801a834:	187b      	adds	r3, r7, r1
 801a836:	781b      	ldrb	r3, [r3, #0]
 801a838:	b299      	uxth	r1, r3
 801a83a:	6a3b      	ldr	r3, [r7, #32]
 801a83c:	2258      	movs	r2, #88	; 0x58
 801a83e:	5299      	strh	r1, [r3, r2]
            pppos->in_state = PDDATA;
 801a840:	6a3b      	ldr	r3, [r7, #32]
 801a842:	225c      	movs	r2, #92	; 0x5c
 801a844:	2106      	movs	r1, #6
 801a846:	5499      	strb	r1, [r3, r2]
          } else {
            pppos->in_protocol = (u16_t)cur_char << 8;
            pppos->in_state = PDPROTOCOL2;
          }
          break;
 801a848:	e098      	b.n	801a97c <pppos_input+0x344>
            pppos->in_protocol = (u16_t)cur_char << 8;
 801a84a:	2327      	movs	r3, #39	; 0x27
 801a84c:	18fb      	adds	r3, r7, r3
 801a84e:	781b      	ldrb	r3, [r3, #0]
 801a850:	b29b      	uxth	r3, r3
 801a852:	021b      	lsls	r3, r3, #8
 801a854:	b299      	uxth	r1, r3
 801a856:	6a3b      	ldr	r3, [r7, #32]
 801a858:	2258      	movs	r2, #88	; 0x58
 801a85a:	5299      	strh	r1, [r3, r2]
            pppos->in_state = PDPROTOCOL2;
 801a85c:	6a3b      	ldr	r3, [r7, #32]
 801a85e:	225c      	movs	r2, #92	; 0x5c
 801a860:	2105      	movs	r1, #5
 801a862:	5499      	strb	r1, [r3, r2]
          break;
 801a864:	e08a      	b.n	801a97c <pppos_input+0x344>
        case PDPROTOCOL2:               /* Process protocol field 2. */
          pppos->in_protocol |= cur_char;
 801a866:	6a3b      	ldr	r3, [r7, #32]
 801a868:	2258      	movs	r2, #88	; 0x58
 801a86a:	5a9a      	ldrh	r2, [r3, r2]
 801a86c:	2327      	movs	r3, #39	; 0x27
 801a86e:	18fb      	adds	r3, r7, r3
 801a870:	781b      	ldrb	r3, [r3, #0]
 801a872:	b29b      	uxth	r3, r3
 801a874:	4313      	orrs	r3, r2
 801a876:	b299      	uxth	r1, r3
 801a878:	6a3b      	ldr	r3, [r7, #32]
 801a87a:	2258      	movs	r2, #88	; 0x58
 801a87c:	5299      	strh	r1, [r3, r2]
          pppos->in_state = PDDATA;
 801a87e:	6a3b      	ldr	r3, [r7, #32]
 801a880:	225c      	movs	r2, #92	; 0x5c
 801a882:	2106      	movs	r1, #6
 801a884:	5499      	strb	r1, [r3, r2]
          break;
 801a886:	e079      	b.n	801a97c <pppos_input+0x344>
        case PDDATA:                    /* Process data byte. */
          /* Make space to receive processed data. */
          if (pppos->in_tail == NULL || pppos->in_tail->len == PBUF_POOL_BUFSIZE) {
 801a888:	6a3b      	ldr	r3, [r7, #32]
 801a88a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a88c:	2b00      	cmp	r3, #0
 801a88e:	d006      	beq.n	801a89e <pppos_input+0x266>
 801a890:	6a3b      	ldr	r3, [r7, #32]
 801a892:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a894:	895a      	ldrh	r2, [r3, #10]
 801a896:	2394      	movs	r3, #148	; 0x94
 801a898:	009b      	lsls	r3, r3, #2
 801a89a:	429a      	cmp	r2, r3
 801a89c:	d15b      	bne.n	801a956 <pppos_input+0x31e>
            u16_t pbuf_alloc_len;
            if (pppos->in_tail != NULL) {
 801a89e:	6a3b      	ldr	r3, [r7, #32]
 801a8a0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a8a2:	2b00      	cmp	r3, #0
 801a8a4:	d016      	beq.n	801a8d4 <pppos_input+0x29c>
              pppos->in_tail->tot_len = pppos->in_tail->len;
 801a8a6:	6a3b      	ldr	r3, [r7, #32]
 801a8a8:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801a8aa:	6a3b      	ldr	r3, [r7, #32]
 801a8ac:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a8ae:	8952      	ldrh	r2, [r2, #10]
 801a8b0:	811a      	strh	r2, [r3, #8]
              if (pppos->in_tail != pppos->in_head) {
 801a8b2:	6a3b      	ldr	r3, [r7, #32]
 801a8b4:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801a8b6:	6a3b      	ldr	r3, [r7, #32]
 801a8b8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801a8ba:	429a      	cmp	r2, r3
 801a8bc:	d00a      	beq.n	801a8d4 <pppos_input+0x29c>
                pbuf_cat(pppos->in_head, pppos->in_tail);
 801a8be:	6a3b      	ldr	r3, [r7, #32]
 801a8c0:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 801a8c2:	6a3b      	ldr	r3, [r7, #32]
 801a8c4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a8c6:	0019      	movs	r1, r3
 801a8c8:	0010      	movs	r0, r2
 801a8ca:	f7ef fa61 	bl	8009d90 <pbuf_cat>
                /* give up the in_tail reference now */
                pppos->in_tail = NULL;
 801a8ce:	6a3b      	ldr	r3, [r7, #32]
 801a8d0:	2200      	movs	r2, #0
 801a8d2:	655a      	str	r2, [r3, #84]	; 0x54
              }
            }
            /* If we haven't started a packet, we need a packet header. */
            pbuf_alloc_len = 0;
 801a8d4:	211c      	movs	r1, #28
 801a8d6:	187b      	adds	r3, r7, r1
 801a8d8:	2200      	movs	r2, #0
 801a8da:	801a      	strh	r2, [r3, #0]
             */
            if (pppos->in_head == NULL) {
              pbuf_alloc_len = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN;
            }
#endif /* IP_FORWARD || LWIP_IPV6_FORWARD */
            next_pbuf = pbuf_alloc(PBUF_RAW, pbuf_alloc_len, PBUF_POOL);
 801a8dc:	23c1      	movs	r3, #193	; 0xc1
 801a8de:	005a      	lsls	r2, r3, #1
 801a8e0:	187b      	adds	r3, r7, r1
 801a8e2:	881b      	ldrh	r3, [r3, #0]
 801a8e4:	0019      	movs	r1, r3
 801a8e6:	2000      	movs	r0, #0
 801a8e8:	f7ee fdfa 	bl	80094e0 <pbuf_alloc>
 801a8ec:	0003      	movs	r3, r0
 801a8ee:	61bb      	str	r3, [r7, #24]
            if (next_pbuf == NULL) {
 801a8f0:	69bb      	ldr	r3, [r7, #24]
 801a8f2:	2b00      	cmp	r3, #0
 801a8f4:	d108      	bne.n	801a908 <pppos_input+0x2d0>
              /* No free buffers.  Drop the input packet and let the
               * higher layers deal with it.  Continue processing
               * the received pbuf chain in case a new packet starts. */
              PPPDEBUG(LOG_ERR, ("pppos_input[%d]: NO FREE PBUFS!\n", ppp->netif->num));
              LINK_STATS_INC(link.memerr);
              pppos_input_drop(pppos);
 801a8f6:	6a3b      	ldr	r3, [r7, #32]
 801a8f8:	0018      	movs	r0, r3
 801a8fa:	f000 f8f6 	bl	801aaea <pppos_input_drop>
              pppos->in_state = PDSTART;  /* Wait for flag sequence. */
 801a8fe:	6a3b      	ldr	r3, [r7, #32]
 801a900:	225c      	movs	r2, #92	; 0x5c
 801a902:	2101      	movs	r1, #1
 801a904:	5499      	strb	r1, [r3, r2]
              break;
 801a906:	e039      	b.n	801a97c <pppos_input+0x344>
            }
            if (pppos->in_head == NULL) {
 801a908:	6a3b      	ldr	r3, [r7, #32]
 801a90a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801a90c:	2b00      	cmp	r3, #0
 801a90e:	d11f      	bne.n	801a950 <pppos_input+0x318>
              u8_t *payload = ((u8_t*)next_pbuf->payload) + pbuf_alloc_len;
 801a910:	69bb      	ldr	r3, [r7, #24]
 801a912:	685a      	ldr	r2, [r3, #4]
 801a914:	231c      	movs	r3, #28
 801a916:	18fb      	adds	r3, r7, r3
 801a918:	881b      	ldrh	r3, [r3, #0]
 801a91a:	18d3      	adds	r3, r2, r3
 801a91c:	617b      	str	r3, [r7, #20]
#if PPP_INPROC_IRQ_SAFE
              ((struct pppos_input_header*)payload)->ppp = ppp;
              payload += sizeof(struct pppos_input_header);
              next_pbuf->len += sizeof(struct pppos_input_header);
#endif /* PPP_INPROC_IRQ_SAFE */
              next_pbuf->len += sizeof(pppos->in_protocol);
 801a91e:	69bb      	ldr	r3, [r7, #24]
 801a920:	895b      	ldrh	r3, [r3, #10]
 801a922:	3302      	adds	r3, #2
 801a924:	b29a      	uxth	r2, r3
 801a926:	69bb      	ldr	r3, [r7, #24]
 801a928:	815a      	strh	r2, [r3, #10]
              *(payload++) = pppos->in_protocol >> 8;
 801a92a:	6a3b      	ldr	r3, [r7, #32]
 801a92c:	2258      	movs	r2, #88	; 0x58
 801a92e:	5a9b      	ldrh	r3, [r3, r2]
 801a930:	0a1b      	lsrs	r3, r3, #8
 801a932:	b299      	uxth	r1, r3
 801a934:	697b      	ldr	r3, [r7, #20]
 801a936:	1c5a      	adds	r2, r3, #1
 801a938:	617a      	str	r2, [r7, #20]
 801a93a:	b2ca      	uxtb	r2, r1
 801a93c:	701a      	strb	r2, [r3, #0]
              *(payload) = pppos->in_protocol & 0xFF;
 801a93e:	6a3b      	ldr	r3, [r7, #32]
 801a940:	2258      	movs	r2, #88	; 0x58
 801a942:	5a9b      	ldrh	r3, [r3, r2]
 801a944:	b2da      	uxtb	r2, r3
 801a946:	697b      	ldr	r3, [r7, #20]
 801a948:	701a      	strb	r2, [r3, #0]
              pppos->in_head = next_pbuf;
 801a94a:	6a3b      	ldr	r3, [r7, #32]
 801a94c:	69ba      	ldr	r2, [r7, #24]
 801a94e:	651a      	str	r2, [r3, #80]	; 0x50
            }
            pppos->in_tail = next_pbuf;
 801a950:	6a3b      	ldr	r3, [r7, #32]
 801a952:	69ba      	ldr	r2, [r7, #24]
 801a954:	655a      	str	r2, [r3, #84]	; 0x54
          }
          /* Load character into buffer. */
          ((u8_t*)pppos->in_tail->payload)[pppos->in_tail->len++] = cur_char;
 801a956:	6a3b      	ldr	r3, [r7, #32]
 801a958:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a95a:	6859      	ldr	r1, [r3, #4]
 801a95c:	6a3b      	ldr	r3, [r7, #32]
 801a95e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a960:	895a      	ldrh	r2, [r3, #10]
 801a962:	1c50      	adds	r0, r2, #1
 801a964:	b280      	uxth	r0, r0
 801a966:	8158      	strh	r0, [r3, #10]
 801a968:	0013      	movs	r3, r2
 801a96a:	18cb      	adds	r3, r1, r3
 801a96c:	2227      	movs	r2, #39	; 0x27
 801a96e:	18ba      	adds	r2, r7, r2
 801a970:	7812      	ldrb	r2, [r2, #0]
 801a972:	701a      	strb	r2, [r3, #0]
          break;
 801a974:	e002      	b.n	801a97c <pppos_input+0x344>
        default:
          break;
 801a976:	46c0      	nop			; (mov r8, r8)
 801a978:	e000      	b.n	801a97c <pppos_input+0x344>
            break;
 801a97a:	46c0      	nop			; (mov r8, r8)
      }

      /* update the frame check sequence number. */
      pppos->in_fcs = PPP_FCS(pppos->in_fcs, cur_char);
 801a97c:	6a3b      	ldr	r3, [r7, #32]
 801a97e:	225a      	movs	r2, #90	; 0x5a
 801a980:	5a9b      	ldrh	r3, [r3, r2]
 801a982:	0a1b      	lsrs	r3, r3, #8
 801a984:	b29a      	uxth	r2, r3
 801a986:	6a3b      	ldr	r3, [r7, #32]
 801a988:	215a      	movs	r1, #90	; 0x5a
 801a98a:	5a5b      	ldrh	r3, [r3, r1]
 801a98c:	0019      	movs	r1, r3
 801a98e:	2327      	movs	r3, #39	; 0x27
 801a990:	18fb      	adds	r3, r7, r3
 801a992:	781b      	ldrb	r3, [r3, #0]
 801a994:	404b      	eors	r3, r1
 801a996:	21ff      	movs	r1, #255	; 0xff
 801a998:	4019      	ands	r1, r3
 801a99a:	4b0b      	ldr	r3, [pc, #44]	; (801a9c8 <pppos_input+0x390>)
 801a99c:	0049      	lsls	r1, r1, #1
 801a99e:	5acb      	ldrh	r3, [r1, r3]
 801a9a0:	4053      	eors	r3, r2
 801a9a2:	b299      	uxth	r1, r3
 801a9a4:	6a3b      	ldr	r3, [r7, #32]
 801a9a6:	225a      	movs	r2, #90	; 0x5a
 801a9a8:	5299      	strh	r1, [r3, r2]
  while (l-- > 0) {
 801a9aa:	687b      	ldr	r3, [r7, #4]
 801a9ac:	1e5a      	subs	r2, r3, #1
 801a9ae:	607a      	str	r2, [r7, #4]
 801a9b0:	2b00      	cmp	r3, #0
 801a9b2:	dd00      	ble.n	801a9b6 <pppos_input+0x37e>
 801a9b4:	e64a      	b.n	801a64c <pppos_input+0x14>
 801a9b6:	e000      	b.n	801a9ba <pppos_input+0x382>
      return;
 801a9b8:	46c0      	nop			; (mov r8, r8)
    }
  } /* while (l-- > 0), all bytes processed */
}
 801a9ba:	46bd      	mov	sp, r7
 801a9bc:	b00a      	add	sp, #40	; 0x28
 801a9be:	bd80      	pop	{r7, pc}
 801a9c0:	0000f0b8 	.word	0x0000f0b8
 801a9c4:	08022910 	.word	0x08022910
 801a9c8:	08022710 	.word	0x08022710

0801a9cc <pppos_send_config>:
}
#endif /* PPP_INPROC_IRQ_SAFE */

static void
pppos_send_config(ppp_pcb *ppp, void *ctx, u32_t accm, int pcomp, int accomp)
{
 801a9cc:	b590      	push	{r4, r7, lr}
 801a9ce:	b087      	sub	sp, #28
 801a9d0:	af00      	add	r7, sp, #0
 801a9d2:	60f8      	str	r0, [r7, #12]
 801a9d4:	60b9      	str	r1, [r7, #8]
 801a9d6:	607a      	str	r2, [r7, #4]
 801a9d8:	603b      	str	r3, [r7, #0]
  int i;
  pppos_pcb *pppos = (pppos_pcb *)ctx;
 801a9da:	68bb      	ldr	r3, [r7, #8]
 801a9dc:	613b      	str	r3, [r7, #16]
  LWIP_UNUSED_ARG(ppp);

  pppos->pcomp = pcomp;
 801a9de:	683b      	ldr	r3, [r7, #0]
 801a9e0:	1c1a      	adds	r2, r3, #0
 801a9e2:	2301      	movs	r3, #1
 801a9e4:	4013      	ands	r3, r2
 801a9e6:	b2d9      	uxtb	r1, r3
 801a9e8:	693b      	ldr	r3, [r7, #16]
 801a9ea:	222c      	movs	r2, #44	; 0x2c
 801a9ec:	2001      	movs	r0, #1
 801a9ee:	4001      	ands	r1, r0
 801a9f0:	184c      	adds	r4, r1, r1
 801a9f2:	5c99      	ldrb	r1, [r3, r2]
 801a9f4:	2002      	movs	r0, #2
 801a9f6:	4381      	bics	r1, r0
 801a9f8:	1c08      	adds	r0, r1, #0
 801a9fa:	1c21      	adds	r1, r4, #0
 801a9fc:	4301      	orrs	r1, r0
 801a9fe:	5499      	strb	r1, [r3, r2]
  pppos->accomp = accomp;
 801aa00:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801aa02:	1c1a      	adds	r2, r3, #0
 801aa04:	2301      	movs	r3, #1
 801aa06:	4013      	ands	r3, r2
 801aa08:	b2d9      	uxtb	r1, r3
 801aa0a:	693b      	ldr	r3, [r7, #16]
 801aa0c:	222c      	movs	r2, #44	; 0x2c
 801aa0e:	2001      	movs	r0, #1
 801aa10:	4001      	ands	r1, r0
 801aa12:	008c      	lsls	r4, r1, #2
 801aa14:	5c99      	ldrb	r1, [r3, r2]
 801aa16:	2004      	movs	r0, #4
 801aa18:	4381      	bics	r1, r0
 801aa1a:	1c08      	adds	r0, r1, #0
 801aa1c:	1c21      	adds	r1, r4, #0
 801aa1e:	4301      	orrs	r1, r0
 801aa20:	5499      	strb	r1, [r3, r2]

  /* Load the ACCM bits for the 32 control codes. */
  for (i = 0; i < 32/8; i++) {
 801aa22:	2300      	movs	r3, #0
 801aa24:	617b      	str	r3, [r7, #20]
 801aa26:	e00e      	b.n	801aa46 <pppos_send_config+0x7a>
    pppos->out_accm[i] = (u8_t)((accm >> (8 * i)) & 0xFF);
 801aa28:	697b      	ldr	r3, [r7, #20]
 801aa2a:	00db      	lsls	r3, r3, #3
 801aa2c:	687a      	ldr	r2, [r7, #4]
 801aa2e:	40da      	lsrs	r2, r3
 801aa30:	0013      	movs	r3, r2
 801aa32:	b2d9      	uxtb	r1, r3
 801aa34:	693a      	ldr	r2, [r7, #16]
 801aa36:	697b      	ldr	r3, [r7, #20]
 801aa38:	18d3      	adds	r3, r2, r3
 801aa3a:	330c      	adds	r3, #12
 801aa3c:	1c0a      	adds	r2, r1, #0
 801aa3e:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < 32/8; i++) {
 801aa40:	697b      	ldr	r3, [r7, #20]
 801aa42:	3301      	adds	r3, #1
 801aa44:	617b      	str	r3, [r7, #20]
 801aa46:	697b      	ldr	r3, [r7, #20]
 801aa48:	2b03      	cmp	r3, #3
 801aa4a:	dded      	ble.n	801aa28 <pppos_send_config+0x5c>
  }

  PPPDEBUG(LOG_INFO, ("pppos_send_config[%d]: out_accm=%X %X %X %X\n",
            pppos->ppp->netif->num,
            pppos->out_accm[0], pppos->out_accm[1], pppos->out_accm[2], pppos->out_accm[3]));
}
 801aa4c:	46c0      	nop			; (mov r8, r8)
 801aa4e:	46c0      	nop			; (mov r8, r8)
 801aa50:	46bd      	mov	sp, r7
 801aa52:	b007      	add	sp, #28
 801aa54:	bd90      	pop	{r4, r7, pc}

0801aa56 <pppos_recv_config>:

static void
pppos_recv_config(ppp_pcb *ppp, void *ctx, u32_t accm, int pcomp, int accomp)
{
 801aa56:	b580      	push	{r7, lr}
 801aa58:	b086      	sub	sp, #24
 801aa5a:	af00      	add	r7, sp, #0
 801aa5c:	60f8      	str	r0, [r7, #12]
 801aa5e:	60b9      	str	r1, [r7, #8]
 801aa60:	607a      	str	r2, [r7, #4]
 801aa62:	603b      	str	r3, [r7, #0]
  int i;
  pppos_pcb *pppos = (pppos_pcb *)ctx;
 801aa64:	68bb      	ldr	r3, [r7, #8]
 801aa66:	613b      	str	r3, [r7, #16]
  LWIP_UNUSED_ARG(pcomp);
  LWIP_UNUSED_ARG(accomp);

  /* Load the ACCM bits for the 32 control codes. */
  PPPOS_PROTECT(lev);
  for (i = 0; i < 32 / 8; i++) {
 801aa68:	2300      	movs	r3, #0
 801aa6a:	617b      	str	r3, [r7, #20]
 801aa6c:	e00f      	b.n	801aa8e <pppos_recv_config+0x38>
    pppos->in_accm[i] = (u8_t)(accm >> (i * 8));
 801aa6e:	697b      	ldr	r3, [r7, #20]
 801aa70:	00db      	lsls	r3, r3, #3
 801aa72:	687a      	ldr	r2, [r7, #4]
 801aa74:	40da      	lsrs	r2, r3
 801aa76:	0013      	movs	r3, r2
 801aa78:	b2d8      	uxtb	r0, r3
 801aa7a:	693a      	ldr	r2, [r7, #16]
 801aa7c:	212d      	movs	r1, #45	; 0x2d
 801aa7e:	697b      	ldr	r3, [r7, #20]
 801aa80:	18d3      	adds	r3, r2, r3
 801aa82:	185b      	adds	r3, r3, r1
 801aa84:	1c02      	adds	r2, r0, #0
 801aa86:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < 32 / 8; i++) {
 801aa88:	697b      	ldr	r3, [r7, #20]
 801aa8a:	3301      	adds	r3, #1
 801aa8c:	617b      	str	r3, [r7, #20]
 801aa8e:	697b      	ldr	r3, [r7, #20]
 801aa90:	2b03      	cmp	r3, #3
 801aa92:	ddec      	ble.n	801aa6e <pppos_recv_config+0x18>
  PPPOS_UNPROTECT(lev);

  PPPDEBUG(LOG_INFO, ("pppos_recv_config[%d]: in_accm=%X %X %X %X\n",
            pppos->ppp->netif->num,
            pppos->in_accm[0], pppos->in_accm[1], pppos->in_accm[2], pppos->in_accm[3]));
}
 801aa94:	46c0      	nop			; (mov r8, r8)
 801aa96:	46c0      	nop			; (mov r8, r8)
 801aa98:	46bd      	mov	sp, r7
 801aa9a:	b006      	add	sp, #24
 801aa9c:	bd80      	pop	{r7, pc}

0801aa9e <pppos_input_free_current_packet>:
/*
 * Drop the input packet.
 */
static void
pppos_input_free_current_packet(pppos_pcb *pppos)
{
 801aa9e:	b580      	push	{r7, lr}
 801aaa0:	b082      	sub	sp, #8
 801aaa2:	af00      	add	r7, sp, #0
 801aaa4:	6078      	str	r0, [r7, #4]
  if (pppos->in_head != NULL) {
 801aaa6:	687b      	ldr	r3, [r7, #4]
 801aaa8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801aaaa:	2b00      	cmp	r3, #0
 801aaac:	d016      	beq.n	801aadc <pppos_input_free_current_packet+0x3e>
    if (pppos->in_tail && (pppos->in_tail != pppos->in_head)) {
 801aaae:	687b      	ldr	r3, [r7, #4]
 801aab0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801aab2:	2b00      	cmp	r3, #0
 801aab4:	d00a      	beq.n	801aacc <pppos_input_free_current_packet+0x2e>
 801aab6:	687b      	ldr	r3, [r7, #4]
 801aab8:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801aaba:	687b      	ldr	r3, [r7, #4]
 801aabc:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801aabe:	429a      	cmp	r2, r3
 801aac0:	d004      	beq.n	801aacc <pppos_input_free_current_packet+0x2e>
      pbuf_free(pppos->in_tail);
 801aac2:	687b      	ldr	r3, [r7, #4]
 801aac4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801aac6:	0018      	movs	r0, r3
 801aac8:	f7ef f882 	bl	8009bd0 <pbuf_free>
    }
    pbuf_free(pppos->in_head);
 801aacc:	687b      	ldr	r3, [r7, #4]
 801aace:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801aad0:	0018      	movs	r0, r3
 801aad2:	f7ef f87d 	bl	8009bd0 <pbuf_free>
    pppos->in_head = NULL;
 801aad6:	687b      	ldr	r3, [r7, #4]
 801aad8:	2200      	movs	r2, #0
 801aada:	651a      	str	r2, [r3, #80]	; 0x50
  }
  pppos->in_tail = NULL;
 801aadc:	687b      	ldr	r3, [r7, #4]
 801aade:	2200      	movs	r2, #0
 801aae0:	655a      	str	r2, [r3, #84]	; 0x54
}
 801aae2:	46c0      	nop			; (mov r8, r8)
 801aae4:	46bd      	mov	sp, r7
 801aae6:	b002      	add	sp, #8
 801aae8:	bd80      	pop	{r7, pc}

0801aaea <pppos_input_drop>:
/*
 * Drop the input packet and increase error counters.
 */
static void
pppos_input_drop(pppos_pcb *pppos)
{
 801aaea:	b580      	push	{r7, lr}
 801aaec:	b082      	sub	sp, #8
 801aaee:	af00      	add	r7, sp, #0
 801aaf0:	6078      	str	r0, [r7, #4]
#if 0
    PPPDEBUG(LOG_INFO, ("pppos_input_drop: %d:%.*H\n", pppos->in_head->len, min(60, pppos->in_head->len * 2), pppos->in_head->payload));
#endif
    PPPDEBUG(LOG_INFO, ("pppos_input_drop: pbuf len=%d, addr %p\n", pppos->in_head->len, (void*)pppos->in_head));
  }
  pppos_input_free_current_packet(pppos);
 801aaf2:	687b      	ldr	r3, [r7, #4]
 801aaf4:	0018      	movs	r0, r3
 801aaf6:	f7ff ffd2 	bl	801aa9e <pppos_input_free_current_packet>
#if VJ_SUPPORT
  vj_uncompress_err(&pppos->ppp->vj_comp);
 801aafa:	687b      	ldr	r3, [r7, #4]
 801aafc:	681b      	ldr	r3, [r3, #0]
 801aafe:	33dc      	adds	r3, #220	; 0xdc
 801ab00:	0018      	movs	r0, r3
 801ab02:	f001 fa4f 	bl	801bfa4 <vj_uncompress_err>
#endif /* VJ_SUPPORT */

  LINK_STATS_INC(link.drop);
  MIB2_STATS_NETIF_INC(pppos->ppp->netif, ifindiscards);
}
 801ab06:	46c0      	nop			; (mov r8, r8)
 801ab08:	46bd      	mov	sp, r7
 801ab0a:	b002      	add	sp, #8
 801ab0c:	bd80      	pop	{r7, pc}
	...

0801ab10 <pppos_output_append>:
 * If pbuf is full, send the pbuf and reuse it.
 * Return the current pbuf.
 */
static err_t
pppos_output_append(pppos_pcb *pppos, err_t err, struct pbuf *nb, u8_t c, u8_t accm, u16_t *fcs)
{
 801ab10:	b590      	push	{r4, r7, lr}
 801ab12:	b087      	sub	sp, #28
 801ab14:	af00      	add	r7, sp, #0
 801ab16:	60f8      	str	r0, [r7, #12]
 801ab18:	0008      	movs	r0, r1
 801ab1a:	607a      	str	r2, [r7, #4]
 801ab1c:	0019      	movs	r1, r3
 801ab1e:	240b      	movs	r4, #11
 801ab20:	193b      	adds	r3, r7, r4
 801ab22:	1c02      	adds	r2, r0, #0
 801ab24:	701a      	strb	r2, [r3, #0]
 801ab26:	230a      	movs	r3, #10
 801ab28:	18fb      	adds	r3, r7, r3
 801ab2a:	1c0a      	adds	r2, r1, #0
 801ab2c:	701a      	strb	r2, [r3, #0]
  if (err != ERR_OK) {
 801ab2e:	193b      	adds	r3, r7, r4
 801ab30:	781b      	ldrb	r3, [r3, #0]
 801ab32:	b25b      	sxtb	r3, r3
 801ab34:	2b00      	cmp	r3, #0
 801ab36:	d003      	beq.n	801ab40 <pppos_output_append+0x30>
    return err;
 801ab38:	193b      	adds	r3, r7, r4
 801ab3a:	781b      	ldrb	r3, [r3, #0]
 801ab3c:	b25b      	sxtb	r3, r3
 801ab3e:	e07a      	b.n	801ac36 <pppos_output_append+0x126>
  }

  /* Make sure there is room for the character and an escape code.
   * Sure we don't quite fill the buffer if the character doesn't
   * get escaped but is one character worth complicating this? */
  if ((PBUF_POOL_BUFSIZE - nb->len) < 2) {
 801ab40:	687b      	ldr	r3, [r7, #4]
 801ab42:	895b      	ldrh	r3, [r3, #10]
 801ab44:	001a      	movs	r2, r3
 801ab46:	2394      	movs	r3, #148	; 0x94
 801ab48:	009b      	lsls	r3, r3, #2
 801ab4a:	1a9b      	subs	r3, r3, r2
 801ab4c:	2b01      	cmp	r3, #1
 801ab4e:	d81a      	bhi.n	801ab86 <pppos_output_append+0x76>
    u32_t l = pppos->output_cb(pppos->ppp, (u8_t*)nb->payload, nb->len, pppos->ppp->ctx_cb);
 801ab50:	68fb      	ldr	r3, [r7, #12]
 801ab52:	685c      	ldr	r4, [r3, #4]
 801ab54:	68fb      	ldr	r3, [r7, #12]
 801ab56:	6818      	ldr	r0, [r3, #0]
 801ab58:	687b      	ldr	r3, [r7, #4]
 801ab5a:	6859      	ldr	r1, [r3, #4]
 801ab5c:	687b      	ldr	r3, [r7, #4]
 801ab5e:	895b      	ldrh	r3, [r3, #10]
 801ab60:	001a      	movs	r2, r3
 801ab62:	68fb      	ldr	r3, [r7, #12]
 801ab64:	681b      	ldr	r3, [r3, #0]
 801ab66:	69db      	ldr	r3, [r3, #28]
 801ab68:	47a0      	blx	r4
 801ab6a:	0003      	movs	r3, r0
 801ab6c:	617b      	str	r3, [r7, #20]
    if (l != nb->len) {
 801ab6e:	687b      	ldr	r3, [r7, #4]
 801ab70:	895b      	ldrh	r3, [r3, #10]
 801ab72:	001a      	movs	r2, r3
 801ab74:	697b      	ldr	r3, [r7, #20]
 801ab76:	4293      	cmp	r3, r2
 801ab78:	d002      	beq.n	801ab80 <pppos_output_append+0x70>
      return ERR_IF;
 801ab7a:	230c      	movs	r3, #12
 801ab7c:	425b      	negs	r3, r3
 801ab7e:	e05a      	b.n	801ac36 <pppos_output_append+0x126>
    }
    nb->len = 0;
 801ab80:	687b      	ldr	r3, [r7, #4]
 801ab82:	2200      	movs	r2, #0
 801ab84:	815a      	strh	r2, [r3, #10]
  }

  /* Update FCS before checking for special characters. */
  if (fcs) {
 801ab86:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801ab88:	2b00      	cmp	r3, #0
 801ab8a:	d013      	beq.n	801abb4 <pppos_output_append+0xa4>
    *fcs = PPP_FCS(*fcs, c);
 801ab8c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801ab8e:	881b      	ldrh	r3, [r3, #0]
 801ab90:	0a1b      	lsrs	r3, r3, #8
 801ab92:	b29a      	uxth	r2, r3
 801ab94:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801ab96:	881b      	ldrh	r3, [r3, #0]
 801ab98:	0019      	movs	r1, r3
 801ab9a:	230a      	movs	r3, #10
 801ab9c:	18fb      	adds	r3, r7, r3
 801ab9e:	781b      	ldrb	r3, [r3, #0]
 801aba0:	404b      	eors	r3, r1
 801aba2:	21ff      	movs	r1, #255	; 0xff
 801aba4:	4019      	ands	r1, r3
 801aba6:	4b26      	ldr	r3, [pc, #152]	; (801ac40 <pppos_output_append+0x130>)
 801aba8:	0049      	lsls	r1, r1, #1
 801abaa:	5acb      	ldrh	r3, [r1, r3]
 801abac:	4053      	eors	r3, r2
 801abae:	b29a      	uxth	r2, r3
 801abb0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801abb2:	801a      	strh	r2, [r3, #0]
  }

  /* Copy to output buffer escaping special characters. */
  if (accm && ESCAPE_P(pppos->out_accm, c)) {
 801abb4:	2328      	movs	r3, #40	; 0x28
 801abb6:	18fb      	adds	r3, r7, r3
 801abb8:	781b      	ldrb	r3, [r3, #0]
 801abba:	2b00      	cmp	r3, #0
 801abbc:	d02d      	beq.n	801ac1a <pppos_output_append+0x10a>
 801abbe:	240a      	movs	r4, #10
 801abc0:	193b      	adds	r3, r7, r4
 801abc2:	781b      	ldrb	r3, [r3, #0]
 801abc4:	08db      	lsrs	r3, r3, #3
 801abc6:	b2db      	uxtb	r3, r3
 801abc8:	001a      	movs	r2, r3
 801abca:	68fb      	ldr	r3, [r7, #12]
 801abcc:	189b      	adds	r3, r3, r2
 801abce:	7b1b      	ldrb	r3, [r3, #12]
 801abd0:	0019      	movs	r1, r3
 801abd2:	193b      	adds	r3, r7, r4
 801abd4:	781b      	ldrb	r3, [r3, #0]
 801abd6:	2207      	movs	r2, #7
 801abd8:	4013      	ands	r3, r2
 801abda:	4119      	asrs	r1, r3
 801abdc:	000b      	movs	r3, r1
 801abde:	2201      	movs	r2, #1
 801abe0:	4013      	ands	r3, r2
 801abe2:	d01a      	beq.n	801ac1a <pppos_output_append+0x10a>
    *((u8_t*)nb->payload + nb->len++) = PPP_ESCAPE;
 801abe4:	687b      	ldr	r3, [r7, #4]
 801abe6:	685a      	ldr	r2, [r3, #4]
 801abe8:	687b      	ldr	r3, [r7, #4]
 801abea:	895b      	ldrh	r3, [r3, #10]
 801abec:	1c59      	adds	r1, r3, #1
 801abee:	b288      	uxth	r0, r1
 801abf0:	6879      	ldr	r1, [r7, #4]
 801abf2:	8148      	strh	r0, [r1, #10]
 801abf4:	18d3      	adds	r3, r2, r3
 801abf6:	227d      	movs	r2, #125	; 0x7d
 801abf8:	701a      	strb	r2, [r3, #0]
    *((u8_t*)nb->payload + nb->len++) = c ^ PPP_TRANS;
 801abfa:	687b      	ldr	r3, [r7, #4]
 801abfc:	685a      	ldr	r2, [r3, #4]
 801abfe:	687b      	ldr	r3, [r7, #4]
 801ac00:	895b      	ldrh	r3, [r3, #10]
 801ac02:	1c59      	adds	r1, r3, #1
 801ac04:	b288      	uxth	r0, r1
 801ac06:	6879      	ldr	r1, [r7, #4]
 801ac08:	8148      	strh	r0, [r1, #10]
 801ac0a:	18d3      	adds	r3, r2, r3
 801ac0c:	193a      	adds	r2, r7, r4
 801ac0e:	7812      	ldrb	r2, [r2, #0]
 801ac10:	2120      	movs	r1, #32
 801ac12:	404a      	eors	r2, r1
 801ac14:	b2d2      	uxtb	r2, r2
 801ac16:	701a      	strb	r2, [r3, #0]
 801ac18:	e00c      	b.n	801ac34 <pppos_output_append+0x124>
  } else {
    *((u8_t*)nb->payload + nb->len++) = c;
 801ac1a:	687b      	ldr	r3, [r7, #4]
 801ac1c:	685a      	ldr	r2, [r3, #4]
 801ac1e:	687b      	ldr	r3, [r7, #4]
 801ac20:	895b      	ldrh	r3, [r3, #10]
 801ac22:	1c59      	adds	r1, r3, #1
 801ac24:	b288      	uxth	r0, r1
 801ac26:	6879      	ldr	r1, [r7, #4]
 801ac28:	8148      	strh	r0, [r1, #10]
 801ac2a:	18d3      	adds	r3, r2, r3
 801ac2c:	220a      	movs	r2, #10
 801ac2e:	18ba      	adds	r2, r7, r2
 801ac30:	7812      	ldrb	r2, [r2, #0]
 801ac32:	701a      	strb	r2, [r3, #0]
  }

  return ERR_OK;
 801ac34:	2300      	movs	r3, #0
}
 801ac36:	0018      	movs	r0, r3
 801ac38:	46bd      	mov	sp, r7
 801ac3a:	b007      	add	sp, #28
 801ac3c:	bd90      	pop	{r4, r7, pc}
 801ac3e:	46c0      	nop			; (mov r8, r8)
 801ac40:	08022710 	.word	0x08022710

0801ac44 <pppos_output_last>:

static err_t
pppos_output_last(pppos_pcb *pppos, err_t err, struct pbuf *nb, u16_t *fcs)
{
 801ac44:	b5f0      	push	{r4, r5, r6, r7, lr}
 801ac46:	b089      	sub	sp, #36	; 0x24
 801ac48:	af02      	add	r7, sp, #8
 801ac4a:	60f8      	str	r0, [r7, #12]
 801ac4c:	607a      	str	r2, [r7, #4]
 801ac4e:	603b      	str	r3, [r7, #0]
 801ac50:	260b      	movs	r6, #11
 801ac52:	19bb      	adds	r3, r7, r6
 801ac54:	1c0a      	adds	r2, r1, #0
 801ac56:	701a      	strb	r2, [r3, #0]
  ppp_pcb *ppp = pppos->ppp;
 801ac58:	68fb      	ldr	r3, [r7, #12]
 801ac5a:	681b      	ldr	r3, [r3, #0]
 801ac5c:	617b      	str	r3, [r7, #20]

  /* Add FCS and trailing flag. */
  err = pppos_output_append(pppos, err,  nb, ~(*fcs) & 0xFF, 1, NULL);
 801ac5e:	683b      	ldr	r3, [r7, #0]
 801ac60:	881b      	ldrh	r3, [r3, #0]
 801ac62:	b2db      	uxtb	r3, r3
 801ac64:	43db      	mvns	r3, r3
 801ac66:	b2dd      	uxtb	r5, r3
 801ac68:	19bc      	adds	r4, r7, r6
 801ac6a:	687a      	ldr	r2, [r7, #4]
 801ac6c:	19bb      	adds	r3, r7, r6
 801ac6e:	2100      	movs	r1, #0
 801ac70:	5659      	ldrsb	r1, [r3, r1]
 801ac72:	68f8      	ldr	r0, [r7, #12]
 801ac74:	2300      	movs	r3, #0
 801ac76:	9301      	str	r3, [sp, #4]
 801ac78:	2301      	movs	r3, #1
 801ac7a:	9300      	str	r3, [sp, #0]
 801ac7c:	002b      	movs	r3, r5
 801ac7e:	f7ff ff47 	bl	801ab10 <pppos_output_append>
 801ac82:	0003      	movs	r3, r0
 801ac84:	7023      	strb	r3, [r4, #0]
  err = pppos_output_append(pppos, err,  nb, (~(*fcs) >> 8) & 0xFF, 1, NULL);
 801ac86:	683b      	ldr	r3, [r7, #0]
 801ac88:	881b      	ldrh	r3, [r3, #0]
 801ac8a:	43db      	mvns	r3, r3
 801ac8c:	121b      	asrs	r3, r3, #8
 801ac8e:	b2dd      	uxtb	r5, r3
 801ac90:	19bc      	adds	r4, r7, r6
 801ac92:	687a      	ldr	r2, [r7, #4]
 801ac94:	19bb      	adds	r3, r7, r6
 801ac96:	2100      	movs	r1, #0
 801ac98:	5659      	ldrsb	r1, [r3, r1]
 801ac9a:	68f8      	ldr	r0, [r7, #12]
 801ac9c:	2300      	movs	r3, #0
 801ac9e:	9301      	str	r3, [sp, #4]
 801aca0:	2301      	movs	r3, #1
 801aca2:	9300      	str	r3, [sp, #0]
 801aca4:	002b      	movs	r3, r5
 801aca6:	f7ff ff33 	bl	801ab10 <pppos_output_append>
 801acaa:	0003      	movs	r3, r0
 801acac:	7023      	strb	r3, [r4, #0]
  err = pppos_output_append(pppos, err,  nb, PPP_FLAG, 0, NULL);
 801acae:	0035      	movs	r5, r6
 801acb0:	197c      	adds	r4, r7, r5
 801acb2:	687a      	ldr	r2, [r7, #4]
 801acb4:	197b      	adds	r3, r7, r5
 801acb6:	2100      	movs	r1, #0
 801acb8:	5659      	ldrsb	r1, [r3, r1]
 801acba:	68f8      	ldr	r0, [r7, #12]
 801acbc:	2300      	movs	r3, #0
 801acbe:	9301      	str	r3, [sp, #4]
 801acc0:	2300      	movs	r3, #0
 801acc2:	9300      	str	r3, [sp, #0]
 801acc4:	237e      	movs	r3, #126	; 0x7e
 801acc6:	f7ff ff23 	bl	801ab10 <pppos_output_append>
 801acca:	0003      	movs	r3, r0
 801accc:	7023      	strb	r3, [r4, #0]

  if (err != ERR_OK) {
 801acce:	197b      	adds	r3, r7, r5
 801acd0:	781b      	ldrb	r3, [r3, #0]
 801acd2:	b25b      	sxtb	r3, r3
 801acd4:	2b00      	cmp	r3, #0
 801acd6:	d125      	bne.n	801ad24 <pppos_output_last+0xe0>
    goto failed;
  }

  /* Send remaining buffer if not empty */
  if (nb->len > 0) {
 801acd8:	687b      	ldr	r3, [r7, #4]
 801acda:	895b      	ldrh	r3, [r3, #10]
 801acdc:	2b00      	cmp	r3, #0
 801acde:	d016      	beq.n	801ad0e <pppos_output_last+0xca>
    u32_t l = pppos->output_cb(ppp, (u8_t*)nb->payload, nb->len, ppp->ctx_cb);
 801ace0:	68fb      	ldr	r3, [r7, #12]
 801ace2:	685c      	ldr	r4, [r3, #4]
 801ace4:	687b      	ldr	r3, [r7, #4]
 801ace6:	6859      	ldr	r1, [r3, #4]
 801ace8:	687b      	ldr	r3, [r7, #4]
 801acea:	895b      	ldrh	r3, [r3, #10]
 801acec:	001a      	movs	r2, r3
 801acee:	697b      	ldr	r3, [r7, #20]
 801acf0:	69db      	ldr	r3, [r3, #28]
 801acf2:	6978      	ldr	r0, [r7, #20]
 801acf4:	47a0      	blx	r4
 801acf6:	0003      	movs	r3, r0
 801acf8:	613b      	str	r3, [r7, #16]
    if (l != nb->len) {
 801acfa:	687b      	ldr	r3, [r7, #4]
 801acfc:	895b      	ldrh	r3, [r3, #10]
 801acfe:	001a      	movs	r2, r3
 801ad00:	693b      	ldr	r3, [r7, #16]
 801ad02:	4293      	cmp	r3, r2
 801ad04:	d003      	beq.n	801ad0e <pppos_output_last+0xca>
      err = ERR_IF;
 801ad06:	197b      	adds	r3, r7, r5
 801ad08:	22f4      	movs	r2, #244	; 0xf4
 801ad0a:	701a      	strb	r2, [r3, #0]
      goto failed;
 801ad0c:	e00b      	b.n	801ad26 <pppos_output_last+0xe2>
    }
  }

  pppos->last_xmit = sys_now();
 801ad0e:	f001 ff15 	bl	801cb3c <sys_now>
 801ad12:	0002      	movs	r2, r0
 801ad14:	68fb      	ldr	r3, [r7, #12]
 801ad16:	609a      	str	r2, [r3, #8]
  MIB2_STATS_NETIF_ADD(ppp->netif, ifoutoctets, nb->tot_len);
  MIB2_STATS_NETIF_INC(ppp->netif, ifoutucastpkts);
  LINK_STATS_INC(link.xmit);
  pbuf_free(nb);
 801ad18:	687b      	ldr	r3, [r7, #4]
 801ad1a:	0018      	movs	r0, r3
 801ad1c:	f7ee ff58 	bl	8009bd0 <pbuf_free>
  return ERR_OK;
 801ad20:	2300      	movs	r3, #0
 801ad22:	e00b      	b.n	801ad3c <pppos_output_last+0xf8>
    goto failed;
 801ad24:	46c0      	nop			; (mov r8, r8)

failed:
  pppos->last_xmit = 0; /* prepend PPP_FLAG to next packet */
 801ad26:	68fb      	ldr	r3, [r7, #12]
 801ad28:	2200      	movs	r2, #0
 801ad2a:	609a      	str	r2, [r3, #8]
  LINK_STATS_INC(link.err);
  LINK_STATS_INC(link.drop);
  MIB2_STATS_NETIF_INC(ppp->netif, ifoutdiscards);
  pbuf_free(nb);
 801ad2c:	687b      	ldr	r3, [r7, #4]
 801ad2e:	0018      	movs	r0, r3
 801ad30:	f7ee ff4e 	bl	8009bd0 <pbuf_free>
  return err;
 801ad34:	230b      	movs	r3, #11
 801ad36:	18fb      	adds	r3, r7, r3
 801ad38:	781b      	ldrb	r3, [r3, #0]
 801ad3a:	b25b      	sxtb	r3, r3
}
 801ad3c:	0018      	movs	r0, r3
 801ad3e:	46bd      	mov	sp, r7
 801ad40:	b007      	add	sp, #28
 801ad42:	bdf0      	pop	{r4, r5, r6, r7, pc}

0801ad44 <ppp_slprintf>:
 * %m (error message), %v (visible string),
 * %q (quoted string), %t (current time) and %I (IP address) formats.
 * Doesn't do floating-point formats.
 * Returns the number of chars put into buf.
 */
int ppp_slprintf(char *buf, int buflen, const char *fmt, ...) {
 801ad44:	b40c      	push	{r2, r3}
 801ad46:	b580      	push	{r7, lr}
 801ad48:	b084      	sub	sp, #16
 801ad4a:	af00      	add	r7, sp, #0
 801ad4c:	6078      	str	r0, [r7, #4]
 801ad4e:	6039      	str	r1, [r7, #0]
    va_list args;
    int n;

    va_start(args, fmt);
 801ad50:	231c      	movs	r3, #28
 801ad52:	18fb      	adds	r3, r7, r3
 801ad54:	60bb      	str	r3, [r7, #8]
    n = ppp_vslprintf(buf, buflen, fmt, args);
 801ad56:	68bb      	ldr	r3, [r7, #8]
 801ad58:	69ba      	ldr	r2, [r7, #24]
 801ad5a:	6839      	ldr	r1, [r7, #0]
 801ad5c:	6878      	ldr	r0, [r7, #4]
 801ad5e:	f000 f80b 	bl	801ad78 <ppp_vslprintf>
 801ad62:	0003      	movs	r3, r0
 801ad64:	60fb      	str	r3, [r7, #12]
    va_end(args);
    return n;
 801ad66:	68fb      	ldr	r3, [r7, #12]
}
 801ad68:	0018      	movs	r0, r3
 801ad6a:	46bd      	mov	sp, r7
 801ad6c:	b004      	add	sp, #16
 801ad6e:	bc80      	pop	{r7}
 801ad70:	bc08      	pop	{r3}
 801ad72:	b002      	add	sp, #8
 801ad74:	4718      	bx	r3
	...

0801ad78 <ppp_vslprintf>:
/*
 * ppp_vslprintf - like ppp_slprintf, takes a va_list instead of a list of args.
 */
#define OUTCHAR(c)	(buflen > 0? (--buflen, *buf++ = (c)): 0)

int ppp_vslprintf(char *buf, int buflen, const char *fmt, va_list args) {
 801ad78:	b5f0      	push	{r4, r5, r6, r7, lr}
 801ad7a:	b0a1      	sub	sp, #132	; 0x84
 801ad7c:	af04      	add	r7, sp, #16
 801ad7e:	60f8      	str	r0, [r7, #12]
 801ad80:	60b9      	str	r1, [r7, #8]
 801ad82:	607a      	str	r2, [r7, #4]
 801ad84:	603b      	str	r3, [r7, #0]
    int c, i, n;
    int width, prec, fillch;
    int base, len, neg, quoted;
    unsigned long val = 0;
 801ad86:	2300      	movs	r3, #0
 801ad88:	64fb      	str	r3, [r7, #76]	; 0x4c
    static char hexchars[] = "0123456789abcdef";
#if PRINTPKT_SUPPORT
    struct buffer_info bufinfo;
#endif /* PRINTPKT_SUPPORT */

    buf0 = buf;
 801ad8a:	68fb      	ldr	r3, [r7, #12]
 801ad8c:	63fb      	str	r3, [r7, #60]	; 0x3c
    --buflen;
 801ad8e:	68bb      	ldr	r3, [r7, #8]
 801ad90:	3b01      	subs	r3, #1
 801ad92:	60bb      	str	r3, [r7, #8]
    while (buflen > 0) {
 801ad94:	f000 fb8b 	bl	801b4ae <ppp_vslprintf+0x736>
	for (f = fmt; *f != '%' && *f != 0; ++f)
 801ad98:	687b      	ldr	r3, [r7, #4]
 801ad9a:	64bb      	str	r3, [r7, #72]	; 0x48
 801ad9c:	e002      	b.n	801ada4 <ppp_vslprintf+0x2c>
 801ad9e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801ada0:	3301      	adds	r3, #1
 801ada2:	64bb      	str	r3, [r7, #72]	; 0x48
 801ada4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801ada6:	781b      	ldrb	r3, [r3, #0]
 801ada8:	2b25      	cmp	r3, #37	; 0x25
 801adaa:	d003      	beq.n	801adb4 <ppp_vslprintf+0x3c>
 801adac:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801adae:	781b      	ldrb	r3, [r3, #0]
 801adb0:	2b00      	cmp	r3, #0
 801adb2:	d1f4      	bne.n	801ad9e <ppp_vslprintf+0x26>
	    ;
	if (f > fmt) {
 801adb4:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801adb6:	687b      	ldr	r3, [r7, #4]
 801adb8:	429a      	cmp	r2, r3
 801adba:	d919      	bls.n	801adf0 <ppp_vslprintf+0x78>
	    len = f - fmt;
 801adbc:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801adbe:	687b      	ldr	r3, [r7, #4]
 801adc0:	1ad3      	subs	r3, r2, r3
 801adc2:	657b      	str	r3, [r7, #84]	; 0x54
	    if (len > buflen)
 801adc4:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801adc6:	68bb      	ldr	r3, [r7, #8]
 801adc8:	429a      	cmp	r2, r3
 801adca:	dd01      	ble.n	801add0 <ppp_vslprintf+0x58>
		len = buflen;
 801adcc:	68bb      	ldr	r3, [r7, #8]
 801adce:	657b      	str	r3, [r7, #84]	; 0x54
	    memcpy(buf, fmt, len);
 801add0:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801add2:	6879      	ldr	r1, [r7, #4]
 801add4:	68fb      	ldr	r3, [r7, #12]
 801add6:	0018      	movs	r0, r3
 801add8:	f001 ff02 	bl	801cbe0 <memcpy>
	    buf += len;
 801addc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801adde:	68fa      	ldr	r2, [r7, #12]
 801ade0:	18d3      	adds	r3, r2, r3
 801ade2:	60fb      	str	r3, [r7, #12]
	    buflen -= len;
 801ade4:	68ba      	ldr	r2, [r7, #8]
 801ade6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801ade8:	1ad3      	subs	r3, r2, r3
 801adea:	60bb      	str	r3, [r7, #8]
	    fmt = f;
 801adec:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801adee:	607b      	str	r3, [r7, #4]
	}
	if (*fmt == 0)
 801adf0:	687b      	ldr	r3, [r7, #4]
 801adf2:	781b      	ldrb	r3, [r3, #0]
 801adf4:	2b00      	cmp	r3, #0
 801adf6:	d101      	bne.n	801adfc <ppp_vslprintf+0x84>
 801adf8:	f000 fb5e 	bl	801b4b8 <ppp_vslprintf+0x740>
	    break;
	c = *++fmt;
 801adfc:	687b      	ldr	r3, [r7, #4]
 801adfe:	3301      	adds	r3, #1
 801ae00:	607b      	str	r3, [r7, #4]
 801ae02:	687b      	ldr	r3, [r7, #4]
 801ae04:	781b      	ldrb	r3, [r3, #0]
 801ae06:	66fb      	str	r3, [r7, #108]	; 0x6c
	width = 0;
 801ae08:	2300      	movs	r3, #0
 801ae0a:	667b      	str	r3, [r7, #100]	; 0x64
	prec = -1;
 801ae0c:	2301      	movs	r3, #1
 801ae0e:	425b      	negs	r3, r3
 801ae10:	663b      	str	r3, [r7, #96]	; 0x60
	fillch = ' ';
 801ae12:	2320      	movs	r3, #32
 801ae14:	65fb      	str	r3, [r7, #92]	; 0x5c
	if (c == '0') {
 801ae16:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801ae18:	2b30      	cmp	r3, #48	; 0x30
 801ae1a:	d107      	bne.n	801ae2c <ppp_vslprintf+0xb4>
	    fillch = '0';
 801ae1c:	2330      	movs	r3, #48	; 0x30
 801ae1e:	65fb      	str	r3, [r7, #92]	; 0x5c
	    c = *++fmt;
 801ae20:	687b      	ldr	r3, [r7, #4]
 801ae22:	3301      	adds	r3, #1
 801ae24:	607b      	str	r3, [r7, #4]
 801ae26:	687b      	ldr	r3, [r7, #4]
 801ae28:	781b      	ldrb	r3, [r3, #0]
 801ae2a:	66fb      	str	r3, [r7, #108]	; 0x6c
	}
	if (c == '*') {
 801ae2c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801ae2e:	2b2a      	cmp	r3, #42	; 0x2a
 801ae30:	d11b      	bne.n	801ae6a <ppp_vslprintf+0xf2>
	    width = va_arg(args, int);
 801ae32:	683b      	ldr	r3, [r7, #0]
 801ae34:	1d1a      	adds	r2, r3, #4
 801ae36:	603a      	str	r2, [r7, #0]
 801ae38:	681b      	ldr	r3, [r3, #0]
 801ae3a:	667b      	str	r3, [r7, #100]	; 0x64
	    c = *++fmt;
 801ae3c:	687b      	ldr	r3, [r7, #4]
 801ae3e:	3301      	adds	r3, #1
 801ae40:	607b      	str	r3, [r7, #4]
 801ae42:	687b      	ldr	r3, [r7, #4]
 801ae44:	781b      	ldrb	r3, [r3, #0]
 801ae46:	66fb      	str	r3, [r7, #108]	; 0x6c
 801ae48:	e019      	b.n	801ae7e <ppp_vslprintf+0x106>
	} else {
	    while (lwip_isdigit(c)) {
		width = width * 10 + c - '0';
 801ae4a:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 801ae4c:	0013      	movs	r3, r2
 801ae4e:	009b      	lsls	r3, r3, #2
 801ae50:	189b      	adds	r3, r3, r2
 801ae52:	005b      	lsls	r3, r3, #1
 801ae54:	001a      	movs	r2, r3
 801ae56:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801ae58:	18d3      	adds	r3, r2, r3
 801ae5a:	3b30      	subs	r3, #48	; 0x30
 801ae5c:	667b      	str	r3, [r7, #100]	; 0x64
		c = *++fmt;
 801ae5e:	687b      	ldr	r3, [r7, #4]
 801ae60:	3301      	adds	r3, #1
 801ae62:	607b      	str	r3, [r7, #4]
 801ae64:	687b      	ldr	r3, [r7, #4]
 801ae66:	781b      	ldrb	r3, [r3, #0]
 801ae68:	66fb      	str	r3, [r7, #108]	; 0x6c
	    while (lwip_isdigit(c)) {
 801ae6a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801ae6c:	b2db      	uxtb	r3, r3
 801ae6e:	1c5a      	adds	r2, r3, #1
 801ae70:	4bcf      	ldr	r3, [pc, #828]	; (801b1b0 <ppp_vslprintf+0x438>)
 801ae72:	18d3      	adds	r3, r2, r3
 801ae74:	781b      	ldrb	r3, [r3, #0]
 801ae76:	001a      	movs	r2, r3
 801ae78:	2304      	movs	r3, #4
 801ae7a:	4013      	ands	r3, r2
 801ae7c:	d1e5      	bne.n	801ae4a <ppp_vslprintf+0xd2>
	    }
	}
	if (c == '.') {
 801ae7e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801ae80:	2b2e      	cmp	r3, #46	; 0x2e
 801ae82:	d131      	bne.n	801aee8 <ppp_vslprintf+0x170>
	    c = *++fmt;
 801ae84:	687b      	ldr	r3, [r7, #4]
 801ae86:	3301      	adds	r3, #1
 801ae88:	607b      	str	r3, [r7, #4]
 801ae8a:	687b      	ldr	r3, [r7, #4]
 801ae8c:	781b      	ldrb	r3, [r3, #0]
 801ae8e:	66fb      	str	r3, [r7, #108]	; 0x6c
	    if (c == '*') {
 801ae90:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801ae92:	2b2a      	cmp	r3, #42	; 0x2a
 801ae94:	d10b      	bne.n	801aeae <ppp_vslprintf+0x136>
		prec = va_arg(args, int);
 801ae96:	683b      	ldr	r3, [r7, #0]
 801ae98:	1d1a      	adds	r2, r3, #4
 801ae9a:	603a      	str	r2, [r7, #0]
 801ae9c:	681b      	ldr	r3, [r3, #0]
 801ae9e:	663b      	str	r3, [r7, #96]	; 0x60
		c = *++fmt;
 801aea0:	687b      	ldr	r3, [r7, #4]
 801aea2:	3301      	adds	r3, #1
 801aea4:	607b      	str	r3, [r7, #4]
 801aea6:	687b      	ldr	r3, [r7, #4]
 801aea8:	781b      	ldrb	r3, [r3, #0]
 801aeaa:	66fb      	str	r3, [r7, #108]	; 0x6c
 801aeac:	e01c      	b.n	801aee8 <ppp_vslprintf+0x170>
	    } else {
		prec = 0;
 801aeae:	2300      	movs	r3, #0
 801aeb0:	663b      	str	r3, [r7, #96]	; 0x60
		while (lwip_isdigit(c)) {
 801aeb2:	e00f      	b.n	801aed4 <ppp_vslprintf+0x15c>
		    prec = prec * 10 + c - '0';
 801aeb4:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 801aeb6:	0013      	movs	r3, r2
 801aeb8:	009b      	lsls	r3, r3, #2
 801aeba:	189b      	adds	r3, r3, r2
 801aebc:	005b      	lsls	r3, r3, #1
 801aebe:	001a      	movs	r2, r3
 801aec0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801aec2:	18d3      	adds	r3, r2, r3
 801aec4:	3b30      	subs	r3, #48	; 0x30
 801aec6:	663b      	str	r3, [r7, #96]	; 0x60
		    c = *++fmt;
 801aec8:	687b      	ldr	r3, [r7, #4]
 801aeca:	3301      	adds	r3, #1
 801aecc:	607b      	str	r3, [r7, #4]
 801aece:	687b      	ldr	r3, [r7, #4]
 801aed0:	781b      	ldrb	r3, [r3, #0]
 801aed2:	66fb      	str	r3, [r7, #108]	; 0x6c
		while (lwip_isdigit(c)) {
 801aed4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801aed6:	b2db      	uxtb	r3, r3
 801aed8:	1c5a      	adds	r2, r3, #1
 801aeda:	4bb5      	ldr	r3, [pc, #724]	; (801b1b0 <ppp_vslprintf+0x438>)
 801aedc:	18d3      	adds	r3, r2, r3
 801aede:	781b      	ldrb	r3, [r3, #0]
 801aee0:	001a      	movs	r2, r3
 801aee2:	2304      	movs	r3, #4
 801aee4:	4013      	ands	r3, r2
 801aee6:	d1e5      	bne.n	801aeb4 <ppp_vslprintf+0x13c>
		}
	    }
	}
	str = 0;
 801aee8:	2300      	movs	r3, #0
 801aeea:	647b      	str	r3, [r7, #68]	; 0x44
	base = 0;
 801aeec:	2300      	movs	r3, #0
 801aeee:	65bb      	str	r3, [r7, #88]	; 0x58
	neg = 0;
 801aef0:	2300      	movs	r3, #0
 801aef2:	653b      	str	r3, [r7, #80]	; 0x50
	++fmt;
 801aef4:	687b      	ldr	r3, [r7, #4]
 801aef6:	3301      	adds	r3, #1
 801aef8:	607b      	str	r3, [r7, #4]
 801aefa:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801aefc:	3b42      	subs	r3, #66	; 0x42
 801aefe:	2b36      	cmp	r3, #54	; 0x36
 801af00:	d900      	bls.n	801af04 <ppp_vslprintf+0x18c>
 801af02:	e229      	b.n	801b358 <ppp_vslprintf+0x5e0>
 801af04:	009a      	lsls	r2, r3, #2
 801af06:	4bab      	ldr	r3, [pc, #684]	; (801b1b4 <ppp_vslprintf+0x43c>)
 801af08:	18d3      	adds	r3, r2, r3
 801af0a:	681b      	ldr	r3, [r3, #0]
 801af0c:	469f      	mov	pc, r3
	switch (c) {
	case 'l':
	    c = *fmt++;
 801af0e:	687b      	ldr	r3, [r7, #4]
 801af10:	1c5a      	adds	r2, r3, #1
 801af12:	607a      	str	r2, [r7, #4]
 801af14:	781b      	ldrb	r3, [r3, #0]
 801af16:	66fb      	str	r3, [r7, #108]	; 0x6c
 801af18:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801af1a:	2b64      	cmp	r3, #100	; 0x64
 801af1c:	d003      	beq.n	801af26 <ppp_vslprintf+0x1ae>
 801af1e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801af20:	2b75      	cmp	r3, #117	; 0x75
 801af22:	d010      	beq.n	801af46 <ppp_vslprintf+0x1ce>
 801af24:	e017      	b.n	801af56 <ppp_vslprintf+0x1de>
	    switch (c) {
	    case 'd':
		val = va_arg(args, long);
 801af26:	683b      	ldr	r3, [r7, #0]
 801af28:	1d1a      	adds	r2, r3, #4
 801af2a:	603a      	str	r2, [r7, #0]
 801af2c:	681b      	ldr	r3, [r3, #0]
 801af2e:	64fb      	str	r3, [r7, #76]	; 0x4c
		if ((long)val < 0) {
 801af30:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801af32:	2b00      	cmp	r3, #0
 801af34:	da04      	bge.n	801af40 <ppp_vslprintf+0x1c8>
		    neg = 1;
 801af36:	2301      	movs	r3, #1
 801af38:	653b      	str	r3, [r7, #80]	; 0x50
		    val = (unsigned long)-(long)val;
 801af3a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801af3c:	425b      	negs	r3, r3
 801af3e:	64fb      	str	r3, [r7, #76]	; 0x4c
		}
		base = 10;
 801af40:	230a      	movs	r3, #10
 801af42:	65bb      	str	r3, [r7, #88]	; 0x58
		break;
 801af44:	e021      	b.n	801af8a <ppp_vslprintf+0x212>
	    case 'u':
		val = va_arg(args, unsigned long);
 801af46:	683b      	ldr	r3, [r7, #0]
 801af48:	1d1a      	adds	r2, r3, #4
 801af4a:	603a      	str	r2, [r7, #0]
 801af4c:	681b      	ldr	r3, [r3, #0]
 801af4e:	64fb      	str	r3, [r7, #76]	; 0x4c
		base = 10;
 801af50:	230a      	movs	r3, #10
 801af52:	65bb      	str	r3, [r7, #88]	; 0x58
		break;
 801af54:	e019      	b.n	801af8a <ppp_vslprintf+0x212>
	    default:
		OUTCHAR('%');
 801af56:	68bb      	ldr	r3, [r7, #8]
 801af58:	2b00      	cmp	r3, #0
 801af5a:	dd07      	ble.n	801af6c <ppp_vslprintf+0x1f4>
 801af5c:	68bb      	ldr	r3, [r7, #8]
 801af5e:	3b01      	subs	r3, #1
 801af60:	60bb      	str	r3, [r7, #8]
 801af62:	68fb      	ldr	r3, [r7, #12]
 801af64:	1c5a      	adds	r2, r3, #1
 801af66:	60fa      	str	r2, [r7, #12]
 801af68:	2225      	movs	r2, #37	; 0x25
 801af6a:	701a      	strb	r2, [r3, #0]
		OUTCHAR('l');
 801af6c:	68bb      	ldr	r3, [r7, #8]
 801af6e:	2b00      	cmp	r3, #0
 801af70:	dd07      	ble.n	801af82 <ppp_vslprintf+0x20a>
 801af72:	68bb      	ldr	r3, [r7, #8]
 801af74:	3b01      	subs	r3, #1
 801af76:	60bb      	str	r3, [r7, #8]
 801af78:	68fb      	ldr	r3, [r7, #12]
 801af7a:	1c5a      	adds	r2, r3, #1
 801af7c:	60fa      	str	r2, [r7, #12]
 801af7e:	226c      	movs	r2, #108	; 0x6c
 801af80:	701a      	strb	r2, [r3, #0]
		--fmt;		/* so %lz outputs %lz etc. */
 801af82:	687b      	ldr	r3, [r7, #4]
 801af84:	3b01      	subs	r3, #1
 801af86:	607b      	str	r3, [r7, #4]
		continue;
 801af88:	e291      	b.n	801b4ae <ppp_vslprintf+0x736>
	    }
	    break;
 801af8a:	e1f4      	b.n	801b376 <ppp_vslprintf+0x5fe>
	case 'd':
	    i = va_arg(args, int);
 801af8c:	683b      	ldr	r3, [r7, #0]
 801af8e:	1d1a      	adds	r2, r3, #4
 801af90:	603a      	str	r2, [r7, #0]
 801af92:	681b      	ldr	r3, [r3, #0]
 801af94:	637b      	str	r3, [r7, #52]	; 0x34
	    if (i < 0) {
 801af96:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801af98:	2b00      	cmp	r3, #0
 801af9a:	da05      	bge.n	801afa8 <ppp_vslprintf+0x230>
		neg = 1;
 801af9c:	2301      	movs	r3, #1
 801af9e:	653b      	str	r3, [r7, #80]	; 0x50
		val = -i;
 801afa0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801afa2:	425b      	negs	r3, r3
 801afa4:	64fb      	str	r3, [r7, #76]	; 0x4c
 801afa6:	e001      	b.n	801afac <ppp_vslprintf+0x234>
	    } else
		val = i;
 801afa8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801afaa:	64fb      	str	r3, [r7, #76]	; 0x4c
	    base = 10;
 801afac:	230a      	movs	r3, #10
 801afae:	65bb      	str	r3, [r7, #88]	; 0x58
	    break;
 801afb0:	e1e1      	b.n	801b376 <ppp_vslprintf+0x5fe>
	case 'u':
	    val = va_arg(args, unsigned int);
 801afb2:	683b      	ldr	r3, [r7, #0]
 801afb4:	1d1a      	adds	r2, r3, #4
 801afb6:	603a      	str	r2, [r7, #0]
 801afb8:	681b      	ldr	r3, [r3, #0]
 801afba:	64fb      	str	r3, [r7, #76]	; 0x4c
	    base = 10;
 801afbc:	230a      	movs	r3, #10
 801afbe:	65bb      	str	r3, [r7, #88]	; 0x58
	    break;
 801afc0:	e1d9      	b.n	801b376 <ppp_vslprintf+0x5fe>
	case 'o':
	    val = va_arg(args, unsigned int);
 801afc2:	683b      	ldr	r3, [r7, #0]
 801afc4:	1d1a      	adds	r2, r3, #4
 801afc6:	603a      	str	r2, [r7, #0]
 801afc8:	681b      	ldr	r3, [r3, #0]
 801afca:	64fb      	str	r3, [r7, #76]	; 0x4c
	    base = 8;
 801afcc:	2308      	movs	r3, #8
 801afce:	65bb      	str	r3, [r7, #88]	; 0x58
	    break;
 801afd0:	e1d1      	b.n	801b376 <ppp_vslprintf+0x5fe>
	case 'x':
	case 'X':
	    val = va_arg(args, unsigned int);
 801afd2:	683b      	ldr	r3, [r7, #0]
 801afd4:	1d1a      	adds	r2, r3, #4
 801afd6:	603a      	str	r2, [r7, #0]
 801afd8:	681b      	ldr	r3, [r3, #0]
 801afda:	64fb      	str	r3, [r7, #76]	; 0x4c
	    base = 16;
 801afdc:	2310      	movs	r3, #16
 801afde:	65bb      	str	r3, [r7, #88]	; 0x58
	    break;
 801afe0:	e1c9      	b.n	801b376 <ppp_vslprintf+0x5fe>
	    base = 16;
	    neg = 2;
	    break;
#endif /* unused (and wrong on LLP64 systems) */
	case 's':
	    str = va_arg(args, char *);
 801afe2:	683b      	ldr	r3, [r7, #0]
 801afe4:	1d1a      	adds	r2, r3, #4
 801afe6:	603a      	str	r2, [r7, #0]
 801afe8:	681b      	ldr	r3, [r3, #0]
 801afea:	647b      	str	r3, [r7, #68]	; 0x44
	    break;
 801afec:	e1c3      	b.n	801b376 <ppp_vslprintf+0x5fe>
	case 'c':
	    num[0] = va_arg(args, int);
 801afee:	683b      	ldr	r3, [r7, #0]
 801aff0:	1d1a      	adds	r2, r3, #4
 801aff2:	603a      	str	r2, [r7, #0]
 801aff4:	681b      	ldr	r3, [r3, #0]
 801aff6:	b2da      	uxtb	r2, r3
 801aff8:	2110      	movs	r1, #16
 801affa:	187b      	adds	r3, r7, r1
 801affc:	701a      	strb	r2, [r3, #0]
	    num[1] = 0;
 801affe:	187b      	adds	r3, r7, r1
 801b000:	2200      	movs	r2, #0
 801b002:	705a      	strb	r2, [r3, #1]
	    str = num;
 801b004:	187b      	adds	r3, r7, r1
 801b006:	647b      	str	r3, [r7, #68]	; 0x44
	    break;
 801b008:	e1b5      	b.n	801b376 <ppp_vslprintf+0x5fe>
	case 'm':
	    str = strerror(errno);
	    break;
#endif /* do we always have strerror() in embedded ? */
	case 'I':
	    ip = va_arg(args, u32_t);
 801b00a:	683b      	ldr	r3, [r7, #0]
 801b00c:	1d1a      	adds	r2, r3, #4
 801b00e:	603a      	str	r2, [r7, #0]
 801b010:	681b      	ldr	r3, [r3, #0]
 801b012:	633b      	str	r3, [r7, #48]	; 0x30
	    ip = lwip_ntohl(ip);
 801b014:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b016:	0018      	movs	r0, r3
 801b018:	f7eb fe0c 	bl	8006c34 <lwip_htonl>
 801b01c:	0003      	movs	r3, r0
 801b01e:	633b      	str	r3, [r7, #48]	; 0x30
	    ppp_slprintf(num, sizeof(num), "%d.%d.%d.%d", (ip >> 24) & 0xff,
 801b020:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b022:	0e1d      	lsrs	r5, r3, #24
		     (ip >> 16) & 0xff, (ip >> 8) & 0xff, ip & 0xff);
 801b024:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b026:	0c1b      	lsrs	r3, r3, #16
	    ppp_slprintf(num, sizeof(num), "%d.%d.%d.%d", (ip >> 24) & 0xff,
 801b028:	22ff      	movs	r2, #255	; 0xff
 801b02a:	4013      	ands	r3, r2
		     (ip >> 16) & 0xff, (ip >> 8) & 0xff, ip & 0xff);
 801b02c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801b02e:	0a12      	lsrs	r2, r2, #8
	    ppp_slprintf(num, sizeof(num), "%d.%d.%d.%d", (ip >> 24) & 0xff,
 801b030:	21ff      	movs	r1, #255	; 0xff
 801b032:	400a      	ands	r2, r1
 801b034:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801b036:	20ff      	movs	r0, #255	; 0xff
 801b038:	4001      	ands	r1, r0
 801b03a:	4c5f      	ldr	r4, [pc, #380]	; (801b1b8 <ppp_vslprintf+0x440>)
 801b03c:	2610      	movs	r6, #16
 801b03e:	19b8      	adds	r0, r7, r6
 801b040:	9102      	str	r1, [sp, #8]
 801b042:	9201      	str	r2, [sp, #4]
 801b044:	9300      	str	r3, [sp, #0]
 801b046:	002b      	movs	r3, r5
 801b048:	0022      	movs	r2, r4
 801b04a:	2120      	movs	r1, #32
 801b04c:	f7ff fe7a 	bl	801ad44 <ppp_slprintf>
	    str = num;
 801b050:	19bb      	adds	r3, r7, r6
 801b052:	647b      	str	r3, [r7, #68]	; 0x44
	    break;
 801b054:	e18f      	b.n	801b376 <ppp_vslprintf+0x5fe>
	    str[15] = 0;	/* chop off year and newline */
	    break;
#endif /* need port */
	case 'v':		/* "visible" string */
	case 'q':		/* quoted string */
	    quoted = c == 'q';
 801b056:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b058:	3b71      	subs	r3, #113	; 0x71
 801b05a:	425a      	negs	r2, r3
 801b05c:	4153      	adcs	r3, r2
 801b05e:	b2db      	uxtb	r3, r3
 801b060:	63bb      	str	r3, [r7, #56]	; 0x38
	    p = va_arg(args, unsigned char *);
 801b062:	683b      	ldr	r3, [r7, #0]
 801b064:	1d1a      	adds	r2, r3, #4
 801b066:	603a      	str	r2, [r7, #0]
 801b068:	681b      	ldr	r3, [r3, #0]
 801b06a:	643b      	str	r3, [r7, #64]	; 0x40
	    if (p == NULL)
 801b06c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b06e:	2b00      	cmp	r3, #0
 801b070:	d101      	bne.n	801b076 <ppp_vslprintf+0x2fe>
		p = (const unsigned char *)"<NULL>";
 801b072:	4b52      	ldr	r3, [pc, #328]	; (801b1bc <ppp_vslprintf+0x444>)
 801b074:	643b      	str	r3, [r7, #64]	; 0x40
	    if (fillch == '0' && prec >= 0) {
 801b076:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801b078:	2b30      	cmp	r3, #48	; 0x30
 801b07a:	d105      	bne.n	801b088 <ppp_vslprintf+0x310>
 801b07c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801b07e:	2b00      	cmp	r3, #0
 801b080:	db02      	blt.n	801b088 <ppp_vslprintf+0x310>
		n = prec;
 801b082:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801b084:	66bb      	str	r3, [r7, #104]	; 0x68
 801b086:	e010      	b.n	801b0aa <ppp_vslprintf+0x332>
	    } else {
		n = strlen((const char *)p);
 801b088:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b08a:	0018      	movs	r0, r3
 801b08c:	f7e5 f83c 	bl	8000108 <strlen>
 801b090:	0003      	movs	r3, r0
 801b092:	66bb      	str	r3, [r7, #104]	; 0x68
		if (prec >= 0 && n > prec)
 801b094:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801b096:	2b00      	cmp	r3, #0
 801b098:	da00      	bge.n	801b09c <ppp_vslprintf+0x324>
 801b09a:	e113      	b.n	801b2c4 <ppp_vslprintf+0x54c>
 801b09c:	6eba      	ldr	r2, [r7, #104]	; 0x68
 801b09e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801b0a0:	429a      	cmp	r2, r3
 801b0a2:	dc00      	bgt.n	801b0a6 <ppp_vslprintf+0x32e>
 801b0a4:	e10e      	b.n	801b2c4 <ppp_vslprintf+0x54c>
		    n = prec;
 801b0a6:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801b0a8:	66bb      	str	r3, [r7, #104]	; 0x68
	    }
	    while (n > 0 && buflen > 0) {
 801b0aa:	e10b      	b.n	801b2c4 <ppp_vslprintf+0x54c>
		c = *p++;
 801b0ac:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b0ae:	1c5a      	adds	r2, r3, #1
 801b0b0:	643a      	str	r2, [r7, #64]	; 0x40
 801b0b2:	781b      	ldrb	r3, [r3, #0]
 801b0b4:	66fb      	str	r3, [r7, #108]	; 0x6c
		--n;
 801b0b6:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801b0b8:	3b01      	subs	r3, #1
 801b0ba:	66bb      	str	r3, [r7, #104]	; 0x68
		if (!quoted && c >= 0x80) {
 801b0bc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b0be:	2b00      	cmp	r3, #0
 801b0c0:	d11b      	bne.n	801b0fa <ppp_vslprintf+0x382>
 801b0c2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b0c4:	2b7f      	cmp	r3, #127	; 0x7f
 801b0c6:	dd18      	ble.n	801b0fa <ppp_vslprintf+0x382>
		    OUTCHAR('M');
 801b0c8:	68bb      	ldr	r3, [r7, #8]
 801b0ca:	2b00      	cmp	r3, #0
 801b0cc:	dd07      	ble.n	801b0de <ppp_vslprintf+0x366>
 801b0ce:	68bb      	ldr	r3, [r7, #8]
 801b0d0:	3b01      	subs	r3, #1
 801b0d2:	60bb      	str	r3, [r7, #8]
 801b0d4:	68fb      	ldr	r3, [r7, #12]
 801b0d6:	1c5a      	adds	r2, r3, #1
 801b0d8:	60fa      	str	r2, [r7, #12]
 801b0da:	224d      	movs	r2, #77	; 0x4d
 801b0dc:	701a      	strb	r2, [r3, #0]
		    OUTCHAR('-');
 801b0de:	68bb      	ldr	r3, [r7, #8]
 801b0e0:	2b00      	cmp	r3, #0
 801b0e2:	dd07      	ble.n	801b0f4 <ppp_vslprintf+0x37c>
 801b0e4:	68bb      	ldr	r3, [r7, #8]
 801b0e6:	3b01      	subs	r3, #1
 801b0e8:	60bb      	str	r3, [r7, #8]
 801b0ea:	68fb      	ldr	r3, [r7, #12]
 801b0ec:	1c5a      	adds	r2, r3, #1
 801b0ee:	60fa      	str	r2, [r7, #12]
 801b0f0:	222d      	movs	r2, #45	; 0x2d
 801b0f2:	701a      	strb	r2, [r3, #0]
		    c -= 0x80;
 801b0f4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b0f6:	3b80      	subs	r3, #128	; 0x80
 801b0f8:	66fb      	str	r3, [r7, #108]	; 0x6c
		}
		if (quoted && (c == '"' || c == '\\'))
 801b0fa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b0fc:	2b00      	cmp	r3, #0
 801b0fe:	d010      	beq.n	801b122 <ppp_vslprintf+0x3aa>
 801b100:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b102:	2b22      	cmp	r3, #34	; 0x22
 801b104:	d002      	beq.n	801b10c <ppp_vslprintf+0x394>
 801b106:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b108:	2b5c      	cmp	r3, #92	; 0x5c
 801b10a:	d10a      	bne.n	801b122 <ppp_vslprintf+0x3aa>
		    OUTCHAR('\\');
 801b10c:	68bb      	ldr	r3, [r7, #8]
 801b10e:	2b00      	cmp	r3, #0
 801b110:	dd07      	ble.n	801b122 <ppp_vslprintf+0x3aa>
 801b112:	68bb      	ldr	r3, [r7, #8]
 801b114:	3b01      	subs	r3, #1
 801b116:	60bb      	str	r3, [r7, #8]
 801b118:	68fb      	ldr	r3, [r7, #12]
 801b11a:	1c5a      	adds	r2, r3, #1
 801b11c:	60fa      	str	r2, [r7, #12]
 801b11e:	225c      	movs	r2, #92	; 0x5c
 801b120:	701a      	strb	r2, [r3, #0]
		if (c < 0x20 || (0x7f <= c && c < 0xa0)) {
 801b122:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b124:	2b1f      	cmp	r3, #31
 801b126:	dd07      	ble.n	801b138 <ppp_vslprintf+0x3c0>
 801b128:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b12a:	2b7e      	cmp	r3, #126	; 0x7e
 801b12c:	dc00      	bgt.n	801b130 <ppp_vslprintf+0x3b8>
 801b12e:	e0bd      	b.n	801b2ac <ppp_vslprintf+0x534>
 801b130:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b132:	2b9f      	cmp	r3, #159	; 0x9f
 801b134:	dd00      	ble.n	801b138 <ppp_vslprintf+0x3c0>
 801b136:	e0b9      	b.n	801b2ac <ppp_vslprintf+0x534>
		    if (quoted) {
 801b138:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b13a:	2b00      	cmp	r3, #0
 801b13c:	d100      	bne.n	801b140 <ppp_vslprintf+0x3c8>
 801b13e:	e081      	b.n	801b244 <ppp_vslprintf+0x4cc>
			OUTCHAR('\\');
 801b140:	68bb      	ldr	r3, [r7, #8]
 801b142:	2b00      	cmp	r3, #0
 801b144:	dd07      	ble.n	801b156 <ppp_vslprintf+0x3de>
 801b146:	68bb      	ldr	r3, [r7, #8]
 801b148:	3b01      	subs	r3, #1
 801b14a:	60bb      	str	r3, [r7, #8]
 801b14c:	68fb      	ldr	r3, [r7, #12]
 801b14e:	1c5a      	adds	r2, r3, #1
 801b150:	60fa      	str	r2, [r7, #12]
 801b152:	225c      	movs	r2, #92	; 0x5c
 801b154:	701a      	strb	r2, [r3, #0]
 801b156:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b158:	2b0c      	cmp	r3, #12
 801b15a:	d03e      	beq.n	801b1da <ppp_vslprintf+0x462>
 801b15c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b15e:	2b0c      	cmp	r3, #12
 801b160:	dc47      	bgt.n	801b1f2 <ppp_vslprintf+0x47a>
 801b162:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b164:	2b0a      	cmp	r3, #10
 801b166:	d015      	beq.n	801b194 <ppp_vslprintf+0x41c>
 801b168:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b16a:	2b0a      	cmp	r3, #10
 801b16c:	dc41      	bgt.n	801b1f2 <ppp_vslprintf+0x47a>
 801b16e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b170:	2b08      	cmp	r3, #8
 801b172:	d025      	beq.n	801b1c0 <ppp_vslprintf+0x448>
 801b174:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b176:	2b09      	cmp	r3, #9
 801b178:	d13b      	bne.n	801b1f2 <ppp_vslprintf+0x47a>
			switch (c) {
			case '\t':	OUTCHAR('t');	break;
 801b17a:	68bb      	ldr	r3, [r7, #8]
 801b17c:	2b00      	cmp	r3, #0
 801b17e:	dc00      	bgt.n	801b182 <ppp_vslprintf+0x40a>
 801b180:	e08c      	b.n	801b29c <ppp_vslprintf+0x524>
 801b182:	68bb      	ldr	r3, [r7, #8]
 801b184:	3b01      	subs	r3, #1
 801b186:	60bb      	str	r3, [r7, #8]
 801b188:	68fb      	ldr	r3, [r7, #12]
 801b18a:	1c5a      	adds	r2, r3, #1
 801b18c:	60fa      	str	r2, [r7, #12]
 801b18e:	2274      	movs	r2, #116	; 0x74
 801b190:	701a      	strb	r2, [r3, #0]
 801b192:	e083      	b.n	801b29c <ppp_vslprintf+0x524>
			case '\n':	OUTCHAR('n');	break;
 801b194:	68bb      	ldr	r3, [r7, #8]
 801b196:	2b00      	cmp	r3, #0
 801b198:	dc00      	bgt.n	801b19c <ppp_vslprintf+0x424>
 801b19a:	e081      	b.n	801b2a0 <ppp_vslprintf+0x528>
 801b19c:	68bb      	ldr	r3, [r7, #8]
 801b19e:	3b01      	subs	r3, #1
 801b1a0:	60bb      	str	r3, [r7, #8]
 801b1a2:	68fb      	ldr	r3, [r7, #12]
 801b1a4:	1c5a      	adds	r2, r3, #1
 801b1a6:	60fa      	str	r2, [r7, #12]
 801b1a8:	226e      	movs	r2, #110	; 0x6e
 801b1aa:	701a      	strb	r2, [r3, #0]
 801b1ac:	e078      	b.n	801b2a0 <ppp_vslprintf+0x528>
 801b1ae:	46c0      	nop			; (mov r8, r8)
 801b1b0:	08022a48 	.word	0x08022a48
 801b1b4:	0802292c 	.word	0x0802292c
 801b1b8:	08021bdc 	.word	0x08021bdc
 801b1bc:	08021be8 	.word	0x08021be8
			case '\b':	OUTCHAR('b');	break;
 801b1c0:	68bb      	ldr	r3, [r7, #8]
 801b1c2:	2b00      	cmp	r3, #0
 801b1c4:	dc00      	bgt.n	801b1c8 <ppp_vslprintf+0x450>
 801b1c6:	e06d      	b.n	801b2a4 <ppp_vslprintf+0x52c>
 801b1c8:	68bb      	ldr	r3, [r7, #8]
 801b1ca:	3b01      	subs	r3, #1
 801b1cc:	60bb      	str	r3, [r7, #8]
 801b1ce:	68fb      	ldr	r3, [r7, #12]
 801b1d0:	1c5a      	adds	r2, r3, #1
 801b1d2:	60fa      	str	r2, [r7, #12]
 801b1d4:	2262      	movs	r2, #98	; 0x62
 801b1d6:	701a      	strb	r2, [r3, #0]
 801b1d8:	e064      	b.n	801b2a4 <ppp_vslprintf+0x52c>
			case '\f':	OUTCHAR('f');	break;
 801b1da:	68bb      	ldr	r3, [r7, #8]
 801b1dc:	2b00      	cmp	r3, #0
 801b1de:	dd63      	ble.n	801b2a8 <ppp_vslprintf+0x530>
 801b1e0:	68bb      	ldr	r3, [r7, #8]
 801b1e2:	3b01      	subs	r3, #1
 801b1e4:	60bb      	str	r3, [r7, #8]
 801b1e6:	68fb      	ldr	r3, [r7, #12]
 801b1e8:	1c5a      	adds	r2, r3, #1
 801b1ea:	60fa      	str	r2, [r7, #12]
 801b1ec:	2266      	movs	r2, #102	; 0x66
 801b1ee:	701a      	strb	r2, [r3, #0]
 801b1f0:	e05a      	b.n	801b2a8 <ppp_vslprintf+0x530>
			default:
			    OUTCHAR('x');
 801b1f2:	68bb      	ldr	r3, [r7, #8]
 801b1f4:	2b00      	cmp	r3, #0
 801b1f6:	dd07      	ble.n	801b208 <ppp_vslprintf+0x490>
 801b1f8:	68bb      	ldr	r3, [r7, #8]
 801b1fa:	3b01      	subs	r3, #1
 801b1fc:	60bb      	str	r3, [r7, #8]
 801b1fe:	68fb      	ldr	r3, [r7, #12]
 801b200:	1c5a      	adds	r2, r3, #1
 801b202:	60fa      	str	r2, [r7, #12]
 801b204:	2278      	movs	r2, #120	; 0x78
 801b206:	701a      	strb	r2, [r3, #0]
			    OUTCHAR(hexchars[c >> 4]);
 801b208:	68bb      	ldr	r3, [r7, #8]
 801b20a:	2b00      	cmp	r3, #0
 801b20c:	dd0a      	ble.n	801b224 <ppp_vslprintf+0x4ac>
 801b20e:	68bb      	ldr	r3, [r7, #8]
 801b210:	3b01      	subs	r3, #1
 801b212:	60bb      	str	r3, [r7, #8]
 801b214:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b216:	111a      	asrs	r2, r3, #4
 801b218:	68fb      	ldr	r3, [r7, #12]
 801b21a:	1c59      	adds	r1, r3, #1
 801b21c:	60f9      	str	r1, [r7, #12]
 801b21e:	49ac      	ldr	r1, [pc, #688]	; (801b4d0 <ppp_vslprintf+0x758>)
 801b220:	5c8a      	ldrb	r2, [r1, r2]
 801b222:	701a      	strb	r2, [r3, #0]
			    OUTCHAR(hexchars[c & 0xf]);
 801b224:	68bb      	ldr	r3, [r7, #8]
 801b226:	2b00      	cmp	r3, #0
 801b228:	dd4c      	ble.n	801b2c4 <ppp_vslprintf+0x54c>
 801b22a:	68bb      	ldr	r3, [r7, #8]
 801b22c:	3b01      	subs	r3, #1
 801b22e:	60bb      	str	r3, [r7, #8]
 801b230:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b232:	220f      	movs	r2, #15
 801b234:	401a      	ands	r2, r3
 801b236:	68fb      	ldr	r3, [r7, #12]
 801b238:	1c59      	adds	r1, r3, #1
 801b23a:	60f9      	str	r1, [r7, #12]
 801b23c:	49a4      	ldr	r1, [pc, #656]	; (801b4d0 <ppp_vslprintf+0x758>)
 801b23e:	5c8a      	ldrb	r2, [r1, r2]
 801b240:	701a      	strb	r2, [r3, #0]
 801b242:	e03f      	b.n	801b2c4 <ppp_vslprintf+0x54c>
			}
		    } else {
			if (c == '\t')
 801b244:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b246:	2b09      	cmp	r3, #9
 801b248:	d10c      	bne.n	801b264 <ppp_vslprintf+0x4ec>
			    OUTCHAR(c);
 801b24a:	68bb      	ldr	r3, [r7, #8]
 801b24c:	2b00      	cmp	r3, #0
 801b24e:	dd39      	ble.n	801b2c4 <ppp_vslprintf+0x54c>
 801b250:	68bb      	ldr	r3, [r7, #8]
 801b252:	3b01      	subs	r3, #1
 801b254:	60bb      	str	r3, [r7, #8]
 801b256:	68fb      	ldr	r3, [r7, #12]
 801b258:	1c5a      	adds	r2, r3, #1
 801b25a:	60fa      	str	r2, [r7, #12]
 801b25c:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801b25e:	b2d2      	uxtb	r2, r2
 801b260:	701a      	strb	r2, [r3, #0]
 801b262:	e02f      	b.n	801b2c4 <ppp_vslprintf+0x54c>
			else {
			    OUTCHAR('^');
 801b264:	68bb      	ldr	r3, [r7, #8]
 801b266:	2b00      	cmp	r3, #0
 801b268:	dd07      	ble.n	801b27a <ppp_vslprintf+0x502>
 801b26a:	68bb      	ldr	r3, [r7, #8]
 801b26c:	3b01      	subs	r3, #1
 801b26e:	60bb      	str	r3, [r7, #8]
 801b270:	68fb      	ldr	r3, [r7, #12]
 801b272:	1c5a      	adds	r2, r3, #1
 801b274:	60fa      	str	r2, [r7, #12]
 801b276:	225e      	movs	r2, #94	; 0x5e
 801b278:	701a      	strb	r2, [r3, #0]
			    OUTCHAR(c ^ 0x40);
 801b27a:	68bb      	ldr	r3, [r7, #8]
 801b27c:	2b00      	cmp	r3, #0
 801b27e:	dd21      	ble.n	801b2c4 <ppp_vslprintf+0x54c>
 801b280:	68bb      	ldr	r3, [r7, #8]
 801b282:	3b01      	subs	r3, #1
 801b284:	60bb      	str	r3, [r7, #8]
 801b286:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b288:	b25b      	sxtb	r3, r3
 801b28a:	2240      	movs	r2, #64	; 0x40
 801b28c:	4053      	eors	r3, r2
 801b28e:	b259      	sxtb	r1, r3
 801b290:	68fb      	ldr	r3, [r7, #12]
 801b292:	1c5a      	adds	r2, r3, #1
 801b294:	60fa      	str	r2, [r7, #12]
 801b296:	b2ca      	uxtb	r2, r1
 801b298:	701a      	strb	r2, [r3, #0]
 801b29a:	e013      	b.n	801b2c4 <ppp_vslprintf+0x54c>
			case '\t':	OUTCHAR('t');	break;
 801b29c:	46c0      	nop			; (mov r8, r8)
 801b29e:	e011      	b.n	801b2c4 <ppp_vslprintf+0x54c>
			case '\n':	OUTCHAR('n');	break;
 801b2a0:	46c0      	nop			; (mov r8, r8)
 801b2a2:	e00f      	b.n	801b2c4 <ppp_vslprintf+0x54c>
			case '\b':	OUTCHAR('b');	break;
 801b2a4:	46c0      	nop			; (mov r8, r8)
 801b2a6:	e00d      	b.n	801b2c4 <ppp_vslprintf+0x54c>
			case '\f':	OUTCHAR('f');	break;
 801b2a8:	46c0      	nop			; (mov r8, r8)
		    if (quoted) {
 801b2aa:	e00b      	b.n	801b2c4 <ppp_vslprintf+0x54c>
			}
		    }
		} else
		    OUTCHAR(c);
 801b2ac:	68bb      	ldr	r3, [r7, #8]
 801b2ae:	2b00      	cmp	r3, #0
 801b2b0:	dd08      	ble.n	801b2c4 <ppp_vslprintf+0x54c>
 801b2b2:	68bb      	ldr	r3, [r7, #8]
 801b2b4:	3b01      	subs	r3, #1
 801b2b6:	60bb      	str	r3, [r7, #8]
 801b2b8:	68fb      	ldr	r3, [r7, #12]
 801b2ba:	1c5a      	adds	r2, r3, #1
 801b2bc:	60fa      	str	r2, [r7, #12]
 801b2be:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801b2c0:	b2d2      	uxtb	r2, r2
 801b2c2:	701a      	strb	r2, [r3, #0]
	    while (n > 0 && buflen > 0) {
 801b2c4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801b2c6:	2b00      	cmp	r3, #0
 801b2c8:	dc00      	bgt.n	801b2cc <ppp_vslprintf+0x554>
 801b2ca:	e0f0      	b.n	801b4ae <ppp_vslprintf+0x736>
 801b2cc:	68bb      	ldr	r3, [r7, #8]
 801b2ce:	2b00      	cmp	r3, #0
 801b2d0:	dd00      	ble.n	801b2d4 <ppp_vslprintf+0x55c>
 801b2d2:	e6eb      	b.n	801b0ac <ppp_vslprintf+0x334>
	    }
	    continue;
 801b2d4:	e0eb      	b.n	801b4ae <ppp_vslprintf+0x736>
	    buf = bufinfo.ptr;
	    buflen = bufinfo.len - 1;
	    continue;
#endif /* PRINTPKT_SUPPORT */
	case 'B':
	    p = va_arg(args, unsigned char *);
 801b2d6:	683b      	ldr	r3, [r7, #0]
 801b2d8:	1d1a      	adds	r2, r3, #4
 801b2da:	603a      	str	r2, [r7, #0]
 801b2dc:	681b      	ldr	r3, [r3, #0]
 801b2de:	643b      	str	r3, [r7, #64]	; 0x40
	    for (n = prec; n > 0; --n) {
 801b2e0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801b2e2:	66bb      	str	r3, [r7, #104]	; 0x68
 801b2e4:	e034      	b.n	801b350 <ppp_vslprintf+0x5d8>
		c = *p++;
 801b2e6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b2e8:	1c5a      	adds	r2, r3, #1
 801b2ea:	643a      	str	r2, [r7, #64]	; 0x40
 801b2ec:	781b      	ldrb	r3, [r3, #0]
 801b2ee:	66fb      	str	r3, [r7, #108]	; 0x6c
		if (fillch == ' ')
 801b2f0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801b2f2:	2b20      	cmp	r3, #32
 801b2f4:	d10a      	bne.n	801b30c <ppp_vslprintf+0x594>
		    OUTCHAR(' ');
 801b2f6:	68bb      	ldr	r3, [r7, #8]
 801b2f8:	2b00      	cmp	r3, #0
 801b2fa:	dd07      	ble.n	801b30c <ppp_vslprintf+0x594>
 801b2fc:	68bb      	ldr	r3, [r7, #8]
 801b2fe:	3b01      	subs	r3, #1
 801b300:	60bb      	str	r3, [r7, #8]
 801b302:	68fb      	ldr	r3, [r7, #12]
 801b304:	1c5a      	adds	r2, r3, #1
 801b306:	60fa      	str	r2, [r7, #12]
 801b308:	2220      	movs	r2, #32
 801b30a:	701a      	strb	r2, [r3, #0]
		OUTCHAR(hexchars[(c >> 4) & 0xf]);
 801b30c:	68bb      	ldr	r3, [r7, #8]
 801b30e:	2b00      	cmp	r3, #0
 801b310:	dd0c      	ble.n	801b32c <ppp_vslprintf+0x5b4>
 801b312:	68bb      	ldr	r3, [r7, #8]
 801b314:	3b01      	subs	r3, #1
 801b316:	60bb      	str	r3, [r7, #8]
 801b318:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b31a:	111b      	asrs	r3, r3, #4
 801b31c:	220f      	movs	r2, #15
 801b31e:	401a      	ands	r2, r3
 801b320:	68fb      	ldr	r3, [r7, #12]
 801b322:	1c59      	adds	r1, r3, #1
 801b324:	60f9      	str	r1, [r7, #12]
 801b326:	496a      	ldr	r1, [pc, #424]	; (801b4d0 <ppp_vslprintf+0x758>)
 801b328:	5c8a      	ldrb	r2, [r1, r2]
 801b32a:	701a      	strb	r2, [r3, #0]
		OUTCHAR(hexchars[c & 0xf]);
 801b32c:	68bb      	ldr	r3, [r7, #8]
 801b32e:	2b00      	cmp	r3, #0
 801b330:	dd0b      	ble.n	801b34a <ppp_vslprintf+0x5d2>
 801b332:	68bb      	ldr	r3, [r7, #8]
 801b334:	3b01      	subs	r3, #1
 801b336:	60bb      	str	r3, [r7, #8]
 801b338:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b33a:	220f      	movs	r2, #15
 801b33c:	401a      	ands	r2, r3
 801b33e:	68fb      	ldr	r3, [r7, #12]
 801b340:	1c59      	adds	r1, r3, #1
 801b342:	60f9      	str	r1, [r7, #12]
 801b344:	4962      	ldr	r1, [pc, #392]	; (801b4d0 <ppp_vslprintf+0x758>)
 801b346:	5c8a      	ldrb	r2, [r1, r2]
 801b348:	701a      	strb	r2, [r3, #0]
	    for (n = prec; n > 0; --n) {
 801b34a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801b34c:	3b01      	subs	r3, #1
 801b34e:	66bb      	str	r3, [r7, #104]	; 0x68
 801b350:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801b352:	2b00      	cmp	r3, #0
 801b354:	dcc7      	bgt.n	801b2e6 <ppp_vslprintf+0x56e>
	    }
	    continue;
 801b356:	e0aa      	b.n	801b4ae <ppp_vslprintf+0x736>
	default:
	    *buf++ = '%';
 801b358:	68fb      	ldr	r3, [r7, #12]
 801b35a:	1c5a      	adds	r2, r3, #1
 801b35c:	60fa      	str	r2, [r7, #12]
 801b35e:	2225      	movs	r2, #37	; 0x25
 801b360:	701a      	strb	r2, [r3, #0]
	    if (c != '%')
 801b362:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b364:	2b25      	cmp	r3, #37	; 0x25
 801b366:	d002      	beq.n	801b36e <ppp_vslprintf+0x5f6>
		--fmt;		/* so %z outputs %z etc. */
 801b368:	687b      	ldr	r3, [r7, #4]
 801b36a:	3b01      	subs	r3, #1
 801b36c:	607b      	str	r3, [r7, #4]
	    --buflen;
 801b36e:	68bb      	ldr	r3, [r7, #8]
 801b370:	3b01      	subs	r3, #1
 801b372:	60bb      	str	r3, [r7, #8]
	    continue;
 801b374:	e09b      	b.n	801b4ae <ppp_vslprintf+0x736>
	}
	if (base != 0) {
 801b376:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801b378:	2b00      	cmp	r3, #0
 801b37a:	d054      	beq.n	801b426 <ppp_vslprintf+0x6ae>
	    str = num + sizeof(num);
 801b37c:	2310      	movs	r3, #16
 801b37e:	18fb      	adds	r3, r7, r3
 801b380:	3320      	adds	r3, #32
 801b382:	647b      	str	r3, [r7, #68]	; 0x44
	    *--str = 0;
 801b384:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b386:	3b01      	subs	r3, #1
 801b388:	647b      	str	r3, [r7, #68]	; 0x44
 801b38a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b38c:	2200      	movs	r2, #0
 801b38e:	701a      	strb	r2, [r3, #0]
	    while (str > num + neg) {
 801b390:	e01e      	b.n	801b3d0 <ppp_vslprintf+0x658>
		*--str = hexchars[val % base];
 801b392:	6dba      	ldr	r2, [r7, #88]	; 0x58
 801b394:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b396:	0011      	movs	r1, r2
 801b398:	0018      	movs	r0, r3
 801b39a:	f7e4 ff4d 	bl	8000238 <__aeabi_uidivmod>
 801b39e:	000b      	movs	r3, r1
 801b3a0:	001a      	movs	r2, r3
 801b3a2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b3a4:	3b01      	subs	r3, #1
 801b3a6:	647b      	str	r3, [r7, #68]	; 0x44
 801b3a8:	4b49      	ldr	r3, [pc, #292]	; (801b4d0 <ppp_vslprintf+0x758>)
 801b3aa:	5c9a      	ldrb	r2, [r3, r2]
 801b3ac:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b3ae:	701a      	strb	r2, [r3, #0]
		val = val / base;
 801b3b0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801b3b2:	0019      	movs	r1, r3
 801b3b4:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 801b3b6:	f7e4 feb9 	bl	800012c <__udivsi3>
 801b3ba:	0003      	movs	r3, r0
 801b3bc:	64fb      	str	r3, [r7, #76]	; 0x4c
		if (--prec <= 0 && val == 0)
 801b3be:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801b3c0:	3b01      	subs	r3, #1
 801b3c2:	663b      	str	r3, [r7, #96]	; 0x60
 801b3c4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801b3c6:	2b00      	cmp	r3, #0
 801b3c8:	dc02      	bgt.n	801b3d0 <ppp_vslprintf+0x658>
 801b3ca:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b3cc:	2b00      	cmp	r3, #0
 801b3ce:	d007      	beq.n	801b3e0 <ppp_vslprintf+0x668>
	    while (str > num + neg) {
 801b3d0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801b3d2:	2210      	movs	r2, #16
 801b3d4:	18ba      	adds	r2, r7, r2
 801b3d6:	18d3      	adds	r3, r2, r3
 801b3d8:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801b3da:	429a      	cmp	r2, r3
 801b3dc:	d8d9      	bhi.n	801b392 <ppp_vslprintf+0x61a>
 801b3de:	e000      	b.n	801b3e2 <ppp_vslprintf+0x66a>
		    break;
 801b3e0:	46c0      	nop			; (mov r8, r8)
	    }
	    switch (neg) {
 801b3e2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801b3e4:	2b01      	cmp	r3, #1
 801b3e6:	d003      	beq.n	801b3f0 <ppp_vslprintf+0x678>
 801b3e8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801b3ea:	2b02      	cmp	r3, #2
 801b3ec:	d007      	beq.n	801b3fe <ppp_vslprintf+0x686>
	    case 2:
		*--str = 'x';
		*--str = '0';
		break;
	    default:
		break;
 801b3ee:	e013      	b.n	801b418 <ppp_vslprintf+0x6a0>
		*--str = '-';
 801b3f0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b3f2:	3b01      	subs	r3, #1
 801b3f4:	647b      	str	r3, [r7, #68]	; 0x44
 801b3f6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b3f8:	222d      	movs	r2, #45	; 0x2d
 801b3fa:	701a      	strb	r2, [r3, #0]
		break;
 801b3fc:	e00c      	b.n	801b418 <ppp_vslprintf+0x6a0>
		*--str = 'x';
 801b3fe:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b400:	3b01      	subs	r3, #1
 801b402:	647b      	str	r3, [r7, #68]	; 0x44
 801b404:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b406:	2278      	movs	r2, #120	; 0x78
 801b408:	701a      	strb	r2, [r3, #0]
		*--str = '0';
 801b40a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b40c:	3b01      	subs	r3, #1
 801b40e:	647b      	str	r3, [r7, #68]	; 0x44
 801b410:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b412:	2230      	movs	r2, #48	; 0x30
 801b414:	701a      	strb	r2, [r3, #0]
		break;
 801b416:	46c0      	nop			; (mov r8, r8)
	    }
	    len = num + sizeof(num) - 1 - str;
 801b418:	2310      	movs	r3, #16
 801b41a:	18fb      	adds	r3, r7, r3
 801b41c:	331f      	adds	r3, #31
 801b41e:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801b420:	1a9b      	subs	r3, r3, r2
 801b422:	657b      	str	r3, [r7, #84]	; 0x54
 801b424:	e00e      	b.n	801b444 <ppp_vslprintf+0x6cc>
	} else {
	    len = strlen(str);
 801b426:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b428:	0018      	movs	r0, r3
 801b42a:	f7e4 fe6d 	bl	8000108 <strlen>
 801b42e:	0003      	movs	r3, r0
 801b430:	657b      	str	r3, [r7, #84]	; 0x54
	    if (prec >= 0 && len > prec)
 801b432:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801b434:	2b00      	cmp	r3, #0
 801b436:	db05      	blt.n	801b444 <ppp_vslprintf+0x6cc>
 801b438:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801b43a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801b43c:	429a      	cmp	r2, r3
 801b43e:	dd01      	ble.n	801b444 <ppp_vslprintf+0x6cc>
		len = prec;
 801b440:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801b442:	657b      	str	r3, [r7, #84]	; 0x54
	}
	if (width > 0) {
 801b444:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801b446:	2b00      	cmp	r3, #0
 801b448:	dd1d      	ble.n	801b486 <ppp_vslprintf+0x70e>
	    if (width > buflen)
 801b44a:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 801b44c:	68bb      	ldr	r3, [r7, #8]
 801b44e:	429a      	cmp	r2, r3
 801b450:	dd01      	ble.n	801b456 <ppp_vslprintf+0x6de>
		width = buflen;
 801b452:	68bb      	ldr	r3, [r7, #8]
 801b454:	667b      	str	r3, [r7, #100]	; 0x64
	    if ((n = width - len) > 0) {
 801b456:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 801b458:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801b45a:	1ad3      	subs	r3, r2, r3
 801b45c:	66bb      	str	r3, [r7, #104]	; 0x68
 801b45e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801b460:	2b00      	cmp	r3, #0
 801b462:	dd10      	ble.n	801b486 <ppp_vslprintf+0x70e>
		buflen -= n;
 801b464:	68ba      	ldr	r2, [r7, #8]
 801b466:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801b468:	1ad3      	subs	r3, r2, r3
 801b46a:	60bb      	str	r3, [r7, #8]
		for (; n > 0; --n)
 801b46c:	e008      	b.n	801b480 <ppp_vslprintf+0x708>
		    *buf++ = fillch;
 801b46e:	68fb      	ldr	r3, [r7, #12]
 801b470:	1c5a      	adds	r2, r3, #1
 801b472:	60fa      	str	r2, [r7, #12]
 801b474:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 801b476:	b2d2      	uxtb	r2, r2
 801b478:	701a      	strb	r2, [r3, #0]
		for (; n > 0; --n)
 801b47a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801b47c:	3b01      	subs	r3, #1
 801b47e:	66bb      	str	r3, [r7, #104]	; 0x68
 801b480:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801b482:	2b00      	cmp	r3, #0
 801b484:	dcf3      	bgt.n	801b46e <ppp_vslprintf+0x6f6>
	    }
	}
	if (len > buflen)
 801b486:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801b488:	68bb      	ldr	r3, [r7, #8]
 801b48a:	429a      	cmp	r2, r3
 801b48c:	dd01      	ble.n	801b492 <ppp_vslprintf+0x71a>
	    len = buflen;
 801b48e:	68bb      	ldr	r3, [r7, #8]
 801b490:	657b      	str	r3, [r7, #84]	; 0x54
	memcpy(buf, str, len);
 801b492:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801b494:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801b496:	68fb      	ldr	r3, [r7, #12]
 801b498:	0018      	movs	r0, r3
 801b49a:	f001 fba1 	bl	801cbe0 <memcpy>
	buf += len;
 801b49e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801b4a0:	68fa      	ldr	r2, [r7, #12]
 801b4a2:	18d3      	adds	r3, r2, r3
 801b4a4:	60fb      	str	r3, [r7, #12]
	buflen -= len;
 801b4a6:	68ba      	ldr	r2, [r7, #8]
 801b4a8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801b4aa:	1ad3      	subs	r3, r2, r3
 801b4ac:	60bb      	str	r3, [r7, #8]
    while (buflen > 0) {
 801b4ae:	68bb      	ldr	r3, [r7, #8]
 801b4b0:	2b00      	cmp	r3, #0
 801b4b2:	dd00      	ble.n	801b4b6 <ppp_vslprintf+0x73e>
 801b4b4:	e470      	b.n	801ad98 <ppp_vslprintf+0x20>
 801b4b6:	e000      	b.n	801b4ba <ppp_vslprintf+0x742>
	    break;
 801b4b8:	46c0      	nop			; (mov r8, r8)
    }
    *buf = 0;
 801b4ba:	68fb      	ldr	r3, [r7, #12]
 801b4bc:	2200      	movs	r2, #0
 801b4be:	701a      	strb	r2, [r3, #0]
    return buf - buf0;
 801b4c0:	68fa      	ldr	r2, [r7, #12]
 801b4c2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801b4c4:	1ad3      	subs	r3, r2, r3
}
 801b4c6:	0018      	movs	r0, r3
 801b4c8:	46bd      	mov	sp, r7
 801b4ca:	b01d      	add	sp, #116	; 0x74
 801b4cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801b4ce:	46c0      	nop			; (mov r8, r8)
 801b4d0:	20000024 	.word	0x20000024

0801b4d4 <ppp_logit>:
}

/*
 * ppp_logit - does the hard work for fatal et al.
 */
static void ppp_logit(int level, const char *fmt, va_list args) {
 801b4d4:	b590      	push	{r4, r7, lr}
 801b4d6:	4c0c      	ldr	r4, [pc, #48]	; (801b508 <ppp_logit+0x34>)
 801b4d8:	44a5      	add	sp, r4
 801b4da:	af00      	add	r7, sp, #0
 801b4dc:	60f8      	str	r0, [r7, #12]
 801b4de:	60b9      	str	r1, [r7, #8]
 801b4e0:	607a      	str	r2, [r7, #4]
    char buf[1024];

    ppp_vslprintf(buf, sizeof(buf), fmt, args);
 801b4e2:	687b      	ldr	r3, [r7, #4]
 801b4e4:	68ba      	ldr	r2, [r7, #8]
 801b4e6:	2180      	movs	r1, #128	; 0x80
 801b4e8:	00c9      	lsls	r1, r1, #3
 801b4ea:	2410      	movs	r4, #16
 801b4ec:	1938      	adds	r0, r7, r4
 801b4ee:	f7ff fc43 	bl	801ad78 <ppp_vslprintf>
    ppp_log_write(level, buf);
 801b4f2:	193a      	adds	r2, r7, r4
 801b4f4:	68fb      	ldr	r3, [r7, #12]
 801b4f6:	0011      	movs	r1, r2
 801b4f8:	0018      	movs	r0, r3
 801b4fa:	f000 f809 	bl	801b510 <ppp_log_write>
}
 801b4fe:	46c0      	nop			; (mov r8, r8)
 801b500:	46bd      	mov	sp, r7
 801b502:	4b02      	ldr	r3, [pc, #8]	; (801b50c <ppp_logit+0x38>)
 801b504:	449d      	add	sp, r3
 801b506:	bd90      	pop	{r4, r7, pc}
 801b508:	fffffbec 	.word	0xfffffbec
 801b50c:	00000414 	.word	0x00000414

0801b510 <ppp_log_write>:

static void ppp_log_write(int level, char *buf) {
 801b510:	b580      	push	{r7, lr}
 801b512:	b082      	sub	sp, #8
 801b514:	af00      	add	r7, sp, #0
 801b516:	6078      	str	r0, [r7, #4]
 801b518:	6039      	str	r1, [r7, #0]
	if (write(log_to_fd, buf, n) != n
	    || write(log_to_fd, "\n", 1) != 1)
	    log_to_fd = -1;
    }
#endif
}
 801b51a:	46c0      	nop			; (mov r8, r8)
 801b51c:	46bd      	mov	sp, r7
 801b51e:	b002      	add	sp, #8
 801b520:	bd80      	pop	{r7, pc}

0801b522 <ppp_error>:
}

/*
 * ppp_error - log an error message.
 */
void ppp_error(const char *fmt, ...) {
 801b522:	b40f      	push	{r0, r1, r2, r3}
 801b524:	b580      	push	{r7, lr}
 801b526:	b082      	sub	sp, #8
 801b528:	af00      	add	r7, sp, #0
    va_list pvar;

    va_start(pvar, fmt);
 801b52a:	2314      	movs	r3, #20
 801b52c:	18fb      	adds	r3, r7, r3
 801b52e:	607b      	str	r3, [r7, #4]
    ppp_logit(LOG_ERR, fmt, pvar);
 801b530:	687a      	ldr	r2, [r7, #4]
 801b532:	693b      	ldr	r3, [r7, #16]
 801b534:	0019      	movs	r1, r3
 801b536:	2003      	movs	r0, #3
 801b538:	f7ff ffcc 	bl	801b4d4 <ppp_logit>
    va_end(pvar);
#if 0 /* UNUSED */
    ++error_count;
#endif /* UNUSED */
}
 801b53c:	46c0      	nop			; (mov r8, r8)
 801b53e:	46bd      	mov	sp, r7
 801b540:	b002      	add	sp, #8
 801b542:	bc80      	pop	{r7}
 801b544:	bc08      	pop	{r3}
 801b546:	b004      	add	sp, #16
 801b548:	4718      	bx	r3

0801b54a <ppp_warn>:

/*
 * ppp_warn - log a warning message.
 */
void ppp_warn(const char *fmt, ...) {
 801b54a:	b40f      	push	{r0, r1, r2, r3}
 801b54c:	b580      	push	{r7, lr}
 801b54e:	b082      	sub	sp, #8
 801b550:	af00      	add	r7, sp, #0
    va_list pvar;

    va_start(pvar, fmt);
 801b552:	2314      	movs	r3, #20
 801b554:	18fb      	adds	r3, r7, r3
 801b556:	607b      	str	r3, [r7, #4]
    ppp_logit(LOG_WARNING, fmt, pvar);
 801b558:	687a      	ldr	r2, [r7, #4]
 801b55a:	693b      	ldr	r3, [r7, #16]
 801b55c:	0019      	movs	r1, r3
 801b55e:	2001      	movs	r0, #1
 801b560:	f7ff ffb8 	bl	801b4d4 <ppp_logit>
    va_end(pvar);
}
 801b564:	46c0      	nop			; (mov r8, r8)
 801b566:	46bd      	mov	sp, r7
 801b568:	b002      	add	sp, #8
 801b56a:	bc80      	pop	{r7}
 801b56c:	bc08      	pop	{r3}
 801b56e:	b004      	add	sp, #16
 801b570:	4718      	bx	r3

0801b572 <ppp_notice>:

/*
 * ppp_notice - log a notice-level message.
 */
void ppp_notice(const char *fmt, ...) {
 801b572:	b40f      	push	{r0, r1, r2, r3}
 801b574:	b580      	push	{r7, lr}
 801b576:	b082      	sub	sp, #8
 801b578:	af00      	add	r7, sp, #0
    va_list pvar;

    va_start(pvar, fmt);
 801b57a:	2314      	movs	r3, #20
 801b57c:	18fb      	adds	r3, r7, r3
 801b57e:	607b      	str	r3, [r7, #4]
    ppp_logit(LOG_NOTICE, fmt, pvar);
 801b580:	687a      	ldr	r2, [r7, #4]
 801b582:	693b      	ldr	r3, [r7, #16]
 801b584:	0019      	movs	r1, r3
 801b586:	2001      	movs	r0, #1
 801b588:	f7ff ffa4 	bl	801b4d4 <ppp_logit>
    va_end(pvar);
}
 801b58c:	46c0      	nop			; (mov r8, r8)
 801b58e:	46bd      	mov	sp, r7
 801b590:	b002      	add	sp, #8
 801b592:	bc80      	pop	{r7}
 801b594:	bc08      	pop	{r3}
 801b596:	b004      	add	sp, #16
 801b598:	4718      	bx	r3

0801b59a <ppp_info>:

/*
 * ppp_info - log an informational message.
 */
void ppp_info(const char *fmt, ...) {
 801b59a:	b40f      	push	{r0, r1, r2, r3}
 801b59c:	b580      	push	{r7, lr}
 801b59e:	b082      	sub	sp, #8
 801b5a0:	af00      	add	r7, sp, #0
    va_list pvar;

    va_start(pvar, fmt);
 801b5a2:	2314      	movs	r3, #20
 801b5a4:	18fb      	adds	r3, r7, r3
 801b5a6:	607b      	str	r3, [r7, #4]
    ppp_logit(LOG_INFO, fmt, pvar);
 801b5a8:	687a      	ldr	r2, [r7, #4]
 801b5aa:	693b      	ldr	r3, [r7, #16]
 801b5ac:	0019      	movs	r1, r3
 801b5ae:	2000      	movs	r0, #0
 801b5b0:	f7ff ff90 	bl	801b4d4 <ppp_logit>
    va_end(pvar);
}
 801b5b4:	46c0      	nop			; (mov r8, r8)
 801b5b6:	46bd      	mov	sp, r7
 801b5b8:	b002      	add	sp, #8
 801b5ba:	bc80      	pop	{r7}
 801b5bc:	bc08      	pop	{r3}
 801b5be:	b004      	add	sp, #16
 801b5c0:	4718      	bx	r3

0801b5c2 <ppp_dbglog>:

/*
 * ppp_dbglog - log a debug message.
 */
void ppp_dbglog(const char *fmt, ...) {
 801b5c2:	b40f      	push	{r0, r1, r2, r3}
 801b5c4:	b580      	push	{r7, lr}
 801b5c6:	b082      	sub	sp, #8
 801b5c8:	af00      	add	r7, sp, #0
    va_list pvar;

    va_start(pvar, fmt);
 801b5ca:	2314      	movs	r3, #20
 801b5cc:	18fb      	adds	r3, r7, r3
 801b5ce:	607b      	str	r3, [r7, #4]
    ppp_logit(LOG_DEBUG, fmt, pvar);
 801b5d0:	687a      	ldr	r2, [r7, #4]
 801b5d2:	693b      	ldr	r3, [r7, #16]
 801b5d4:	0019      	movs	r1, r3
 801b5d6:	2000      	movs	r0, #0
 801b5d8:	f7ff ff7c 	bl	801b4d4 <ppp_logit>
    va_end(pvar);
}
 801b5dc:	46c0      	nop			; (mov r8, r8)
 801b5de:	46bd      	mov	sp, r7
 801b5e0:	b002      	add	sp, #8
 801b5e2:	bc80      	pop	{r7}
 801b5e4:	bc08      	pop	{r3}
 801b5e6:	b004      	add	sp, #16
 801b5e8:	4718      	bx	r3

0801b5ea <vj_compress_init>:
#define INCR(counter)
#endif

void
vj_compress_init(struct vjcompress *comp)
{
 801b5ea:	b580      	push	{r7, lr}
 801b5ec:	b084      	sub	sp, #16
 801b5ee:	af00      	add	r7, sp, #0
 801b5f0:	6078      	str	r0, [r7, #4]
  u8_t i;
  struct cstate *tstate = comp->tstate;
 801b5f2:	687b      	ldr	r3, [r7, #4]
 801b5f4:	330c      	adds	r3, #12
 801b5f6:	60bb      	str	r3, [r7, #8]

#if MAX_SLOTS == 0
  memset((char *)comp, 0, sizeof(*comp));
#endif
  comp->maxSlotIndex = MAX_SLOTS - 1;
 801b5f8:	687b      	ldr	r3, [r7, #4]
 801b5fa:	220f      	movs	r2, #15
 801b5fc:	721a      	strb	r2, [r3, #8]
  comp->compressSlot = 0;    /* Disable slot ID compression by default. */
 801b5fe:	687b      	ldr	r3, [r7, #4]
 801b600:	2200      	movs	r2, #0
 801b602:	725a      	strb	r2, [r3, #9]
  for (i = MAX_SLOTS - 1; i > 0; --i) {
 801b604:	230f      	movs	r3, #15
 801b606:	18fb      	adds	r3, r7, r3
 801b608:	220f      	movs	r2, #15
 801b60a:	701a      	strb	r2, [r3, #0]
 801b60c:	e025      	b.n	801b65a <vj_compress_init+0x70>
    tstate[i].cs_id = i;
 801b60e:	200f      	movs	r0, #15
 801b610:	183b      	adds	r3, r7, r0
 801b612:	781a      	ldrb	r2, [r3, #0]
 801b614:	0013      	movs	r3, r2
 801b616:	011b      	lsls	r3, r3, #4
 801b618:	189b      	adds	r3, r3, r2
 801b61a:	00db      	lsls	r3, r3, #3
 801b61c:	001a      	movs	r2, r3
 801b61e:	68bb      	ldr	r3, [r7, #8]
 801b620:	189b      	adds	r3, r3, r2
 801b622:	183a      	adds	r2, r7, r0
 801b624:	7812      	ldrb	r2, [r2, #0]
 801b626:	719a      	strb	r2, [r3, #6]
    tstate[i].cs_next = &tstate[i - 1];
 801b628:	183b      	adds	r3, r7, r0
 801b62a:	781a      	ldrb	r2, [r3, #0]
 801b62c:	0013      	movs	r3, r2
 801b62e:	011b      	lsls	r3, r3, #4
 801b630:	189b      	adds	r3, r3, r2
 801b632:	00db      	lsls	r3, r3, #3
 801b634:	3b88      	subs	r3, #136	; 0x88
 801b636:	0019      	movs	r1, r3
 801b638:	183b      	adds	r3, r7, r0
 801b63a:	781a      	ldrb	r2, [r3, #0]
 801b63c:	0013      	movs	r3, r2
 801b63e:	011b      	lsls	r3, r3, #4
 801b640:	189b      	adds	r3, r3, r2
 801b642:	00db      	lsls	r3, r3, #3
 801b644:	001a      	movs	r2, r3
 801b646:	68bb      	ldr	r3, [r7, #8]
 801b648:	189b      	adds	r3, r3, r2
 801b64a:	68ba      	ldr	r2, [r7, #8]
 801b64c:	1852      	adds	r2, r2, r1
 801b64e:	601a      	str	r2, [r3, #0]
  for (i = MAX_SLOTS - 1; i > 0; --i) {
 801b650:	183b      	adds	r3, r7, r0
 801b652:	183a      	adds	r2, r7, r0
 801b654:	7812      	ldrb	r2, [r2, #0]
 801b656:	3a01      	subs	r2, #1
 801b658:	701a      	strb	r2, [r3, #0]
 801b65a:	230f      	movs	r3, #15
 801b65c:	18fb      	adds	r3, r7, r3
 801b65e:	781b      	ldrb	r3, [r3, #0]
 801b660:	2b00      	cmp	r3, #0
 801b662:	d1d4      	bne.n	801b60e <vj_compress_init+0x24>
  }
  tstate[0].cs_next = &tstate[MAX_SLOTS - 1];
 801b664:	68bb      	ldr	r3, [r7, #8]
 801b666:	22ff      	movs	r2, #255	; 0xff
 801b668:	00d2      	lsls	r2, r2, #3
 801b66a:	189a      	adds	r2, r3, r2
 801b66c:	68bb      	ldr	r3, [r7, #8]
 801b66e:	601a      	str	r2, [r3, #0]
  tstate[0].cs_id = 0;
 801b670:	68bb      	ldr	r3, [r7, #8]
 801b672:	2200      	movs	r2, #0
 801b674:	719a      	strb	r2, [r3, #6]
  comp->last_cs = &tstate[0];
 801b676:	687b      	ldr	r3, [r7, #4]
 801b678:	68ba      	ldr	r2, [r7, #8]
 801b67a:	601a      	str	r2, [r3, #0]
  comp->last_recv = 255;
 801b67c:	687b      	ldr	r3, [r7, #4]
 801b67e:	22ff      	movs	r2, #255	; 0xff
 801b680:	711a      	strb	r2, [r3, #4]
  comp->last_xmit = 255;
 801b682:	687b      	ldr	r3, [r7, #4]
 801b684:	22ff      	movs	r2, #255	; 0xff
 801b686:	715a      	strb	r2, [r3, #5]
  comp->flags = VJF_TOSS;
 801b688:	687b      	ldr	r3, [r7, #4]
 801b68a:	2201      	movs	r2, #1
 801b68c:	80da      	strh	r2, [r3, #6]
}
 801b68e:	46c0      	nop			; (mov r8, r8)
 801b690:	46bd      	mov	sp, r7
 801b692:	b004      	add	sp, #16
 801b694:	bd80      	pop	{r7, pc}
	...

0801b698 <vj_compress_tcp>:
 * Return the VJ type code indicating whether or not the packet was
 * compressed.
 */
u8_t
vj_compress_tcp(struct vjcompress *comp, struct pbuf **pb)
{
 801b698:	b5b0      	push	{r4, r5, r7, lr}
 801b69a:	b094      	sub	sp, #80	; 0x50
 801b69c:	af00      	add	r7, sp, #0
 801b69e:	6078      	str	r0, [r7, #4]
 801b6a0:	6039      	str	r1, [r7, #0]
  struct pbuf *np = *pb;
 801b6a2:	683b      	ldr	r3, [r7, #0]
 801b6a4:	681b      	ldr	r3, [r3, #0]
 801b6a6:	63fb      	str	r3, [r7, #60]	; 0x3c
  struct ip_hdr *ip = (struct ip_hdr *)np->payload;
 801b6a8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801b6aa:	685b      	ldr	r3, [r3, #4]
 801b6ac:	63bb      	str	r3, [r7, #56]	; 0x38
  struct cstate *cs = comp->last_cs->cs_next;
 801b6ae:	687b      	ldr	r3, [r7, #4]
 801b6b0:	681b      	ldr	r3, [r3, #0]
 801b6b2:	681b      	ldr	r3, [r3, #0]
 801b6b4:	64fb      	str	r3, [r7, #76]	; 0x4c
  u16_t ilen = IPH_HL(ip);
 801b6b6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b6b8:	781b      	ldrb	r3, [r3, #0]
 801b6ba:	b29a      	uxth	r2, r3
 801b6bc:	2336      	movs	r3, #54	; 0x36
 801b6be:	18fb      	adds	r3, r7, r3
 801b6c0:	210f      	movs	r1, #15
 801b6c2:	400a      	ands	r2, r1
 801b6c4:	801a      	strh	r2, [r3, #0]
  u16_t hlen;
  struct tcp_hdr *oth;
  struct tcp_hdr *th;
  u16_t deltaS, deltaA = 0;
 801b6c6:	2348      	movs	r3, #72	; 0x48
 801b6c8:	18fb      	adds	r3, r7, r3
 801b6ca:	2200      	movs	r2, #0
 801b6cc:	801a      	strh	r2, [r3, #0]
  u32_t deltaL;
  u32_t changes = 0;
 801b6ce:	2300      	movs	r3, #0
 801b6d0:	647b      	str	r3, [r7, #68]	; 0x44
  u8_t new_seq[16];
  u8_t *cp = new_seq;
 801b6d2:	230c      	movs	r3, #12
 801b6d4:	18fb      	adds	r3, r7, r3
 801b6d6:	643b      	str	r3, [r7, #64]	; 0x40

  /*
   * Check that the packet is IP proto TCP.
   */
  if (IPH_PROTO(ip) != IP_PROTO_TCP) {
 801b6d8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b6da:	7a5b      	ldrb	r3, [r3, #9]
 801b6dc:	2b06      	cmp	r3, #6
 801b6de:	d002      	beq.n	801b6e6 <vj_compress_tcp+0x4e>
    return (TYPE_IP);
 801b6e0:	2340      	movs	r3, #64	; 0x40
 801b6e2:	f000 fc53 	bl	801bf8c <vj_compress_tcp+0x8f4>
  /*
   * Bail if this is an IP fragment or if the TCP packet isn't
   * `compressible' (i.e., ACK isn't set or some other control bit is
   * set).
   */
  if ((IPH_OFFSET(ip) & PP_HTONS(0x3fff)) || np->tot_len < 40) {
 801b6e6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b6e8:	799a      	ldrb	r2, [r3, #6]
 801b6ea:	79db      	ldrb	r3, [r3, #7]
 801b6ec:	021b      	lsls	r3, r3, #8
 801b6ee:	4313      	orrs	r3, r2
 801b6f0:	b29b      	uxth	r3, r3
 801b6f2:	001a      	movs	r2, r3
 801b6f4:	4b7c      	ldr	r3, [pc, #496]	; (801b8e8 <vj_compress_tcp+0x250>)
 801b6f6:	4013      	ands	r3, r2
 801b6f8:	d103      	bne.n	801b702 <vj_compress_tcp+0x6a>
 801b6fa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801b6fc:	891b      	ldrh	r3, [r3, #8]
 801b6fe:	2b27      	cmp	r3, #39	; 0x27
 801b700:	d802      	bhi.n	801b708 <vj_compress_tcp+0x70>
    return (TYPE_IP);
 801b702:	2340      	movs	r3, #64	; 0x40
 801b704:	f000 fc42 	bl	801bf8c <vj_compress_tcp+0x8f4>
  }
  th = (struct tcp_hdr *)&((struct vj_u32_t*)ip)[ilen];
 801b708:	2336      	movs	r3, #54	; 0x36
 801b70a:	18fb      	adds	r3, r7, r3
 801b70c:	881b      	ldrh	r3, [r3, #0]
 801b70e:	009b      	lsls	r3, r3, #2
 801b710:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801b712:	18d3      	adds	r3, r2, r3
 801b714:	633b      	str	r3, [r7, #48]	; 0x30
  if ((TCPH_FLAGS(th) & (TCP_SYN|TCP_FIN|TCP_RST|TCP_ACK)) != TCP_ACK) {
 801b716:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b718:	7b1a      	ldrb	r2, [r3, #12]
 801b71a:	7b5b      	ldrb	r3, [r3, #13]
 801b71c:	021b      	lsls	r3, r3, #8
 801b71e:	4313      	orrs	r3, r2
 801b720:	b29b      	uxth	r3, r3
 801b722:	0018      	movs	r0, r3
 801b724:	f7eb fa70 	bl	8006c08 <lwip_htons>
 801b728:	0003      	movs	r3, r0
 801b72a:	b2db      	uxtb	r3, r3
 801b72c:	001a      	movs	r2, r3
 801b72e:	2317      	movs	r3, #23
 801b730:	4013      	ands	r3, r2
 801b732:	2b10      	cmp	r3, #16
 801b734:	d002      	beq.n	801b73c <vj_compress_tcp+0xa4>
    return (TYPE_IP);
 801b736:	2340      	movs	r3, #64	; 0x40
 801b738:	f000 fc28 	bl	801bf8c <vj_compress_tcp+0x8f4>
  }

  /* Check that the TCP/IP headers are contained in the first buffer. */
  hlen = ilen + TCPH_HDRLEN(th);
 801b73c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b73e:	7b1a      	ldrb	r2, [r3, #12]
 801b740:	7b5b      	ldrb	r3, [r3, #13]
 801b742:	021b      	lsls	r3, r3, #8
 801b744:	4313      	orrs	r3, r2
 801b746:	b29b      	uxth	r3, r3
 801b748:	0018      	movs	r0, r3
 801b74a:	f7eb fa5d 	bl	8006c08 <lwip_htons>
 801b74e:	0003      	movs	r3, r0
 801b750:	0b1b      	lsrs	r3, r3, #12
 801b752:	b299      	uxth	r1, r3
 801b754:	202e      	movs	r0, #46	; 0x2e
 801b756:	183b      	adds	r3, r7, r0
 801b758:	2236      	movs	r2, #54	; 0x36
 801b75a:	18ba      	adds	r2, r7, r2
 801b75c:	8812      	ldrh	r2, [r2, #0]
 801b75e:	188a      	adds	r2, r1, r2
 801b760:	801a      	strh	r2, [r3, #0]
  hlen <<= 2;
 801b762:	0001      	movs	r1, r0
 801b764:	187b      	adds	r3, r7, r1
 801b766:	187a      	adds	r2, r7, r1
 801b768:	8812      	ldrh	r2, [r2, #0]
 801b76a:	0092      	lsls	r2, r2, #2
 801b76c:	801a      	strh	r2, [r3, #0]
  if (np->len < hlen) {
 801b76e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801b770:	895b      	ldrh	r3, [r3, #10]
 801b772:	187a      	adds	r2, r7, r1
 801b774:	8812      	ldrh	r2, [r2, #0]
 801b776:	429a      	cmp	r2, r3
 801b778:	d902      	bls.n	801b780 <vj_compress_tcp+0xe8>
    PPPDEBUG(LOG_INFO, ("vj_compress_tcp: header len %d spans buffers\n", hlen));
    return (TYPE_IP);
 801b77a:	2340      	movs	r3, #64	; 0x40
 801b77c:	f000 fc06 	bl	801bf8c <vj_compress_tcp+0x8f4>
  }

  /* TCP stack requires that we don't change the packet payload, therefore we copy
   * the whole packet before compression. */
  np = pbuf_clone(PBUF_RAW, PBUF_RAM, *pb);
 801b780:	683b      	ldr	r3, [r7, #0]
 801b782:	681a      	ldr	r2, [r3, #0]
 801b784:	23a0      	movs	r3, #160	; 0xa0
 801b786:	009b      	lsls	r3, r3, #2
 801b788:	0019      	movs	r1, r3
 801b78a:	2000      	movs	r0, #0
 801b78c:	f7ee fefe 	bl	800a58c <pbuf_clone>
 801b790:	0003      	movs	r3, r0
 801b792:	63fb      	str	r3, [r7, #60]	; 0x3c
  if (!np) {
 801b794:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801b796:	2b00      	cmp	r3, #0
 801b798:	d102      	bne.n	801b7a0 <vj_compress_tcp+0x108>
    return (TYPE_IP);
 801b79a:	2340      	movs	r3, #64	; 0x40
 801b79c:	f000 fbf6 	bl	801bf8c <vj_compress_tcp+0x8f4>
  }

  *pb = np;
 801b7a0:	683b      	ldr	r3, [r7, #0]
 801b7a2:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801b7a4:	601a      	str	r2, [r3, #0]
  ip = (struct ip_hdr *)np->payload;
 801b7a6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801b7a8:	685b      	ldr	r3, [r3, #4]
 801b7aa:	63bb      	str	r3, [r7, #56]	; 0x38
   * to locate (or create) the connection state.  Special case the
   * most recently used connection since it's most likely to be used
   * again & we don't have to do any reordering if it's used.
   */
  INCR(vjs_packets);
  if (!ip4_addr_cmp(&ip->src, &cs->cs_ip.src)
 801b7ac:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b7ae:	7b1a      	ldrb	r2, [r3, #12]
 801b7b0:	7b59      	ldrb	r1, [r3, #13]
 801b7b2:	0209      	lsls	r1, r1, #8
 801b7b4:	430a      	orrs	r2, r1
 801b7b6:	7b99      	ldrb	r1, [r3, #14]
 801b7b8:	0409      	lsls	r1, r1, #16
 801b7ba:	430a      	orrs	r2, r1
 801b7bc:	7bdb      	ldrb	r3, [r3, #15]
 801b7be:	061b      	lsls	r3, r3, #24
 801b7c0:	4313      	orrs	r3, r2
 801b7c2:	001a      	movs	r2, r3
 801b7c4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b7c6:	695b      	ldr	r3, [r3, #20]
 801b7c8:	429a      	cmp	r2, r3
 801b7ca:	d131      	bne.n	801b830 <vj_compress_tcp+0x198>
      || !ip4_addr_cmp(&ip->dest, &cs->cs_ip.dest)
 801b7cc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b7ce:	7c1a      	ldrb	r2, [r3, #16]
 801b7d0:	7c59      	ldrb	r1, [r3, #17]
 801b7d2:	0209      	lsls	r1, r1, #8
 801b7d4:	430a      	orrs	r2, r1
 801b7d6:	7c99      	ldrb	r1, [r3, #18]
 801b7d8:	0409      	lsls	r1, r1, #16
 801b7da:	430a      	orrs	r2, r1
 801b7dc:	7cdb      	ldrb	r3, [r3, #19]
 801b7de:	061b      	lsls	r3, r3, #24
 801b7e0:	4313      	orrs	r3, r2
 801b7e2:	001a      	movs	r2, r3
 801b7e4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b7e6:	699b      	ldr	r3, [r3, #24]
 801b7e8:	429a      	cmp	r2, r3
 801b7ea:	d121      	bne.n	801b830 <vj_compress_tcp+0x198>
      || (*(struct vj_u32_t*)th).v != (((struct vj_u32_t*)&cs->cs_ip)[IPH_HL(&cs->cs_ip)]).v) {
 801b7ec:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b7ee:	781a      	ldrb	r2, [r3, #0]
 801b7f0:	7859      	ldrb	r1, [r3, #1]
 801b7f2:	0209      	lsls	r1, r1, #8
 801b7f4:	430a      	orrs	r2, r1
 801b7f6:	7899      	ldrb	r1, [r3, #2]
 801b7f8:	0409      	lsls	r1, r1, #16
 801b7fa:	430a      	orrs	r2, r1
 801b7fc:	78db      	ldrb	r3, [r3, #3]
 801b7fe:	061b      	lsls	r3, r3, #24
 801b800:	4313      	orrs	r3, r2
 801b802:	0018      	movs	r0, r3
 801b804:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b806:	3308      	adds	r3, #8
 801b808:	001a      	movs	r2, r3
 801b80a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b80c:	7a1b      	ldrb	r3, [r3, #8]
 801b80e:	0019      	movs	r1, r3
 801b810:	230f      	movs	r3, #15
 801b812:	400b      	ands	r3, r1
 801b814:	009b      	lsls	r3, r3, #2
 801b816:	18d3      	adds	r3, r2, r3
 801b818:	781a      	ldrb	r2, [r3, #0]
 801b81a:	7859      	ldrb	r1, [r3, #1]
 801b81c:	0209      	lsls	r1, r1, #8
 801b81e:	430a      	orrs	r2, r1
 801b820:	7899      	ldrb	r1, [r3, #2]
 801b822:	0409      	lsls	r1, r1, #16
 801b824:	430a      	orrs	r2, r1
 801b826:	78db      	ldrb	r3, [r3, #3]
 801b828:	061b      	lsls	r3, r3, #24
 801b82a:	4313      	orrs	r3, r2
 801b82c:	4298      	cmp	r0, r3
 801b82e:	d068      	beq.n	801b902 <vj_compress_tcp+0x26a>
     * we want is almost always near the front, we locate
     * states via linear search.  If we don't find a state
     * for the datagram, the oldest state is (re-)used.
     */
    struct cstate *lcs;
    struct cstate *lastcs = comp->last_cs;
 801b830:	687b      	ldr	r3, [r7, #4]
 801b832:	681b      	ldr	r3, [r3, #0]
 801b834:	62bb      	str	r3, [r7, #40]	; 0x28

    do {
      lcs = cs; cs = cs->cs_next;
 801b836:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b838:	627b      	str	r3, [r7, #36]	; 0x24
 801b83a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b83c:	681b      	ldr	r3, [r3, #0]
 801b83e:	64fb      	str	r3, [r7, #76]	; 0x4c
      INCR(vjs_searches);
      if (ip4_addr_cmp(&ip->src, &cs->cs_ip.src)
 801b840:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b842:	7b1a      	ldrb	r2, [r3, #12]
 801b844:	7b59      	ldrb	r1, [r3, #13]
 801b846:	0209      	lsls	r1, r1, #8
 801b848:	430a      	orrs	r2, r1
 801b84a:	7b99      	ldrb	r1, [r3, #14]
 801b84c:	0409      	lsls	r1, r1, #16
 801b84e:	430a      	orrs	r2, r1
 801b850:	7bdb      	ldrb	r3, [r3, #15]
 801b852:	061b      	lsls	r3, r3, #24
 801b854:	4313      	orrs	r3, r2
 801b856:	001a      	movs	r2, r3
 801b858:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b85a:	695b      	ldr	r3, [r3, #20]
 801b85c:	429a      	cmp	r2, r3
 801b85e:	d131      	bne.n	801b8c4 <vj_compress_tcp+0x22c>
          && ip4_addr_cmp(&ip->dest, &cs->cs_ip.dest)
 801b860:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b862:	7c1a      	ldrb	r2, [r3, #16]
 801b864:	7c59      	ldrb	r1, [r3, #17]
 801b866:	0209      	lsls	r1, r1, #8
 801b868:	430a      	orrs	r2, r1
 801b86a:	7c99      	ldrb	r1, [r3, #18]
 801b86c:	0409      	lsls	r1, r1, #16
 801b86e:	430a      	orrs	r2, r1
 801b870:	7cdb      	ldrb	r3, [r3, #19]
 801b872:	061b      	lsls	r3, r3, #24
 801b874:	4313      	orrs	r3, r2
 801b876:	001a      	movs	r2, r3
 801b878:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b87a:	699b      	ldr	r3, [r3, #24]
 801b87c:	429a      	cmp	r2, r3
 801b87e:	d121      	bne.n	801b8c4 <vj_compress_tcp+0x22c>
          && (*(struct vj_u32_t*)th).v == (((struct vj_u32_t*)&cs->cs_ip)[IPH_HL(&cs->cs_ip)]).v) {
 801b880:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b882:	781a      	ldrb	r2, [r3, #0]
 801b884:	7859      	ldrb	r1, [r3, #1]
 801b886:	0209      	lsls	r1, r1, #8
 801b888:	430a      	orrs	r2, r1
 801b88a:	7899      	ldrb	r1, [r3, #2]
 801b88c:	0409      	lsls	r1, r1, #16
 801b88e:	430a      	orrs	r2, r1
 801b890:	78db      	ldrb	r3, [r3, #3]
 801b892:	061b      	lsls	r3, r3, #24
 801b894:	4313      	orrs	r3, r2
 801b896:	0018      	movs	r0, r3
 801b898:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b89a:	3308      	adds	r3, #8
 801b89c:	001a      	movs	r2, r3
 801b89e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b8a0:	7a1b      	ldrb	r3, [r3, #8]
 801b8a2:	0019      	movs	r1, r3
 801b8a4:	230f      	movs	r3, #15
 801b8a6:	400b      	ands	r3, r1
 801b8a8:	009b      	lsls	r3, r3, #2
 801b8aa:	18d3      	adds	r3, r2, r3
 801b8ac:	781a      	ldrb	r2, [r3, #0]
 801b8ae:	7859      	ldrb	r1, [r3, #1]
 801b8b0:	0209      	lsls	r1, r1, #8
 801b8b2:	430a      	orrs	r2, r1
 801b8b4:	7899      	ldrb	r1, [r3, #2]
 801b8b6:	0409      	lsls	r1, r1, #16
 801b8b8:	430a      	orrs	r2, r1
 801b8ba:	78db      	ldrb	r3, [r3, #3]
 801b8bc:	061b      	lsls	r3, r3, #24
 801b8be:	4313      	orrs	r3, r2
 801b8c0:	4298      	cmp	r0, r3
 801b8c2:	d007      	beq.n	801b8d4 <vj_compress_tcp+0x23c>
        goto found;
      }
    } while (cs != lastcs);
 801b8c4:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801b8c6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801b8c8:	429a      	cmp	r2, r3
 801b8ca:	d1b4      	bne.n	801b836 <vj_compress_tcp+0x19e>
     * Note that since the state list is circular, the oldest
     * state points to the newest and we only need to set
     * last_cs to update the lru linkage.
     */
    INCR(vjs_misses);
    comp->last_cs = lcs;
 801b8cc:	687b      	ldr	r3, [r7, #4]
 801b8ce:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801b8d0:	601a      	str	r2, [r3, #0]
    goto uncompressed;
 801b8d2:	e348      	b.n	801bf66 <vj_compress_tcp+0x8ce>
        goto found;
 801b8d4:	46c0      	nop			; (mov r8, r8)

    found:
    /*
     * Found it -- move to the front on the connection list.
     */
    if (cs == lastcs) {
 801b8d6:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801b8d8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801b8da:	429a      	cmp	r2, r3
 801b8dc:	d106      	bne.n	801b8ec <vj_compress_tcp+0x254>
      comp->last_cs = lcs;
 801b8de:	687b      	ldr	r3, [r7, #4]
 801b8e0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801b8e2:	601a      	str	r2, [r3, #0]
 801b8e4:	e00d      	b.n	801b902 <vj_compress_tcp+0x26a>
 801b8e6:	46c0      	nop			; (mov r8, r8)
 801b8e8:	0000ff3f 	.word	0x0000ff3f
    } else {
      lcs->cs_next = cs->cs_next;
 801b8ec:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b8ee:	681a      	ldr	r2, [r3, #0]
 801b8f0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b8f2:	601a      	str	r2, [r3, #0]
      cs->cs_next = lastcs->cs_next;
 801b8f4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801b8f6:	681a      	ldr	r2, [r3, #0]
 801b8f8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b8fa:	601a      	str	r2, [r3, #0]
      lastcs->cs_next = cs;
 801b8fc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801b8fe:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801b900:	601a      	str	r2, [r3, #0]
    }
  }

  oth = (struct tcp_hdr *)&((struct vj_u32_t*)&cs->cs_ip)[ilen];
 801b902:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b904:	3308      	adds	r3, #8
 801b906:	001a      	movs	r2, r3
 801b908:	2136      	movs	r1, #54	; 0x36
 801b90a:	187b      	adds	r3, r7, r1
 801b90c:	881b      	ldrh	r3, [r3, #0]
 801b90e:	009b      	lsls	r3, r3, #2
 801b910:	18d3      	adds	r3, r2, r3
 801b912:	623b      	str	r3, [r7, #32]
  deltaS = ilen;
 801b914:	254a      	movs	r5, #74	; 0x4a
 801b916:	197b      	adds	r3, r7, r5
 801b918:	187a      	adds	r2, r7, r1
 801b91a:	8812      	ldrh	r2, [r2, #0]
 801b91c:	801a      	strh	r2, [r3, #0]
   * header length.  The 5th line checks IP options, if any.  The 6th
   * line checks TCP options, if any.  If any of these things are
   * different between the previous & current datagram, we send the
   * current datagram `uncompressed'.
   */
  if ((((struct vj_u16_t*)ip)[0]).v != (((struct vj_u16_t*)&cs->cs_ip)[0]).v
 801b91e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b920:	781a      	ldrb	r2, [r3, #0]
 801b922:	785b      	ldrb	r3, [r3, #1]
 801b924:	021b      	lsls	r3, r3, #8
 801b926:	4313      	orrs	r3, r2
 801b928:	b29a      	uxth	r2, r3
 801b92a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b92c:	3308      	adds	r3, #8
 801b92e:	7819      	ldrb	r1, [r3, #0]
 801b930:	785b      	ldrb	r3, [r3, #1]
 801b932:	021b      	lsls	r3, r3, #8
 801b934:	430b      	orrs	r3, r1
 801b936:	b29b      	uxth	r3, r3
 801b938:	429a      	cmp	r2, r3
 801b93a:	d000      	beq.n	801b93e <vj_compress_tcp+0x2a6>
 801b93c:	e30a      	b.n	801bf54 <vj_compress_tcp+0x8bc>
      || (((struct vj_u16_t*)ip)[3]).v != (((struct vj_u16_t*)&cs->cs_ip)[3]).v
 801b93e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b940:	3306      	adds	r3, #6
 801b942:	781a      	ldrb	r2, [r3, #0]
 801b944:	785b      	ldrb	r3, [r3, #1]
 801b946:	021b      	lsls	r3, r3, #8
 801b948:	4313      	orrs	r3, r2
 801b94a:	b29a      	uxth	r2, r3
 801b94c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b94e:	3308      	adds	r3, #8
 801b950:	3306      	adds	r3, #6
 801b952:	7819      	ldrb	r1, [r3, #0]
 801b954:	785b      	ldrb	r3, [r3, #1]
 801b956:	021b      	lsls	r3, r3, #8
 801b958:	430b      	orrs	r3, r1
 801b95a:	b29b      	uxth	r3, r3
 801b95c:	429a      	cmp	r2, r3
 801b95e:	d000      	beq.n	801b962 <vj_compress_tcp+0x2ca>
 801b960:	e2f8      	b.n	801bf54 <vj_compress_tcp+0x8bc>
      || (((struct vj_u16_t*)ip)[4]).v != (((struct vj_u16_t*)&cs->cs_ip)[4]).v
 801b962:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b964:	3308      	adds	r3, #8
 801b966:	781a      	ldrb	r2, [r3, #0]
 801b968:	785b      	ldrb	r3, [r3, #1]
 801b96a:	021b      	lsls	r3, r3, #8
 801b96c:	4313      	orrs	r3, r2
 801b96e:	b29a      	uxth	r2, r3
 801b970:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b972:	3308      	adds	r3, #8
 801b974:	3308      	adds	r3, #8
 801b976:	7819      	ldrb	r1, [r3, #0]
 801b978:	785b      	ldrb	r3, [r3, #1]
 801b97a:	021b      	lsls	r3, r3, #8
 801b97c:	430b      	orrs	r3, r1
 801b97e:	b29b      	uxth	r3, r3
 801b980:	429a      	cmp	r2, r3
 801b982:	d000      	beq.n	801b986 <vj_compress_tcp+0x2ee>
 801b984:	e2e6      	b.n	801bf54 <vj_compress_tcp+0x8bc>
      || TCPH_HDRLEN(th) != TCPH_HDRLEN(oth)
 801b986:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b988:	7b1a      	ldrb	r2, [r3, #12]
 801b98a:	7b5b      	ldrb	r3, [r3, #13]
 801b98c:	021b      	lsls	r3, r3, #8
 801b98e:	4313      	orrs	r3, r2
 801b990:	b29b      	uxth	r3, r3
 801b992:	0018      	movs	r0, r3
 801b994:	f7eb f938 	bl	8006c08 <lwip_htons>
 801b998:	0003      	movs	r3, r0
 801b99a:	0b1b      	lsrs	r3, r3, #12
 801b99c:	b29c      	uxth	r4, r3
 801b99e:	6a3b      	ldr	r3, [r7, #32]
 801b9a0:	7b1a      	ldrb	r2, [r3, #12]
 801b9a2:	7b5b      	ldrb	r3, [r3, #13]
 801b9a4:	021b      	lsls	r3, r3, #8
 801b9a6:	4313      	orrs	r3, r2
 801b9a8:	b29b      	uxth	r3, r3
 801b9aa:	0018      	movs	r0, r3
 801b9ac:	f7eb f92c 	bl	8006c08 <lwip_htons>
 801b9b0:	0003      	movs	r3, r0
 801b9b2:	0b1b      	lsrs	r3, r3, #12
 801b9b4:	b29b      	uxth	r3, r3
 801b9b6:	429c      	cmp	r4, r3
 801b9b8:	d000      	beq.n	801b9bc <vj_compress_tcp+0x324>
 801b9ba:	e2cb      	b.n	801bf54 <vj_compress_tcp+0x8bc>
      || (deltaS > 5 && BCMP(ip + 1, &cs->cs_ip + 1, (deltaS - 5) << 2))
 801b9bc:	197b      	adds	r3, r7, r5
 801b9be:	881b      	ldrh	r3, [r3, #0]
 801b9c0:	2b05      	cmp	r3, #5
 801b9c2:	d910      	bls.n	801b9e6 <vj_compress_tcp+0x34e>
 801b9c4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b9c6:	3314      	adds	r3, #20
 801b9c8:	0018      	movs	r0, r3
 801b9ca:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b9cc:	3308      	adds	r3, #8
 801b9ce:	3314      	adds	r3, #20
 801b9d0:	0019      	movs	r1, r3
 801b9d2:	197b      	adds	r3, r7, r5
 801b9d4:	881b      	ldrh	r3, [r3, #0]
 801b9d6:	3b05      	subs	r3, #5
 801b9d8:	009b      	lsls	r3, r3, #2
 801b9da:	001a      	movs	r2, r3
 801b9dc:	f001 f8f2 	bl	801cbc4 <memcmp>
 801b9e0:	1e03      	subs	r3, r0, #0
 801b9e2:	d000      	beq.n	801b9e6 <vj_compress_tcp+0x34e>
 801b9e4:	e2b6      	b.n	801bf54 <vj_compress_tcp+0x8bc>
      || (TCPH_HDRLEN(th) > 5 && BCMP(th + 1, oth + 1, (TCPH_HDRLEN(th) - 5) << 2))) {
 801b9e6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b9e8:	7b1a      	ldrb	r2, [r3, #12]
 801b9ea:	7b5b      	ldrb	r3, [r3, #13]
 801b9ec:	021b      	lsls	r3, r3, #8
 801b9ee:	4313      	orrs	r3, r2
 801b9f0:	b29b      	uxth	r3, r3
 801b9f2:	0018      	movs	r0, r3
 801b9f4:	f7eb f908 	bl	8006c08 <lwip_htons>
 801b9f8:	0003      	movs	r3, r0
 801b9fa:	0b1b      	lsrs	r3, r3, #12
 801b9fc:	b29b      	uxth	r3, r3
 801b9fe:	2b05      	cmp	r3, #5
 801ba00:	d91b      	bls.n	801ba3a <vj_compress_tcp+0x3a2>
 801ba02:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ba04:	3314      	adds	r3, #20
 801ba06:	001c      	movs	r4, r3
 801ba08:	6a3b      	ldr	r3, [r7, #32]
 801ba0a:	3314      	adds	r3, #20
 801ba0c:	001d      	movs	r5, r3
 801ba0e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ba10:	7b1a      	ldrb	r2, [r3, #12]
 801ba12:	7b5b      	ldrb	r3, [r3, #13]
 801ba14:	021b      	lsls	r3, r3, #8
 801ba16:	4313      	orrs	r3, r2
 801ba18:	b29b      	uxth	r3, r3
 801ba1a:	0018      	movs	r0, r3
 801ba1c:	f7eb f8f4 	bl	8006c08 <lwip_htons>
 801ba20:	0003      	movs	r3, r0
 801ba22:	0b1b      	lsrs	r3, r3, #12
 801ba24:	b29b      	uxth	r3, r3
 801ba26:	3b05      	subs	r3, #5
 801ba28:	009b      	lsls	r3, r3, #2
 801ba2a:	001a      	movs	r2, r3
 801ba2c:	0029      	movs	r1, r5
 801ba2e:	0020      	movs	r0, r4
 801ba30:	f001 f8c8 	bl	801cbc4 <memcmp>
 801ba34:	1e03      	subs	r3, r0, #0
 801ba36:	d000      	beq.n	801ba3a <vj_compress_tcp+0x3a2>
 801ba38:	e28c      	b.n	801bf54 <vj_compress_tcp+0x8bc>
   * Figure out which of the changing fields changed.  The
   * receiver expects changes in the order: urgent, window,
   * ack, seq (the order minimizes the number of temporaries
   * needed in this section of code).
   */
  if (TCPH_FLAGS(th) & TCP_URG) {
 801ba3a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ba3c:	7b1a      	ldrb	r2, [r3, #12]
 801ba3e:	7b5b      	ldrb	r3, [r3, #13]
 801ba40:	021b      	lsls	r3, r3, #8
 801ba42:	4313      	orrs	r3, r2
 801ba44:	b29b      	uxth	r3, r3
 801ba46:	0018      	movs	r0, r3
 801ba48:	f7eb f8de 	bl	8006c08 <lwip_htons>
 801ba4c:	0003      	movs	r3, r0
 801ba4e:	b2db      	uxtb	r3, r3
 801ba50:	001a      	movs	r2, r3
 801ba52:	2320      	movs	r3, #32
 801ba54:	4013      	ands	r3, r2
 801ba56:	d038      	beq.n	801baca <vj_compress_tcp+0x432>
    deltaS = lwip_ntohs(th->urgp);
 801ba58:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ba5a:	7c9a      	ldrb	r2, [r3, #18]
 801ba5c:	7cdb      	ldrb	r3, [r3, #19]
 801ba5e:	021b      	lsls	r3, r3, #8
 801ba60:	4313      	orrs	r3, r2
 801ba62:	b29b      	uxth	r3, r3
 801ba64:	254a      	movs	r5, #74	; 0x4a
 801ba66:	197c      	adds	r4, r7, r5
 801ba68:	0018      	movs	r0, r3
 801ba6a:	f7eb f8cd 	bl	8006c08 <lwip_htons>
 801ba6e:	0003      	movs	r3, r0
 801ba70:	8023      	strh	r3, [r4, #0]
    ENCODEZ(deltaS);
 801ba72:	197b      	adds	r3, r7, r5
 801ba74:	881b      	ldrh	r3, [r3, #0]
 801ba76:	2bff      	cmp	r3, #255	; 0xff
 801ba78:	d803      	bhi.n	801ba82 <vj_compress_tcp+0x3ea>
 801ba7a:	197b      	adds	r3, r7, r5
 801ba7c:	881b      	ldrh	r3, [r3, #0]
 801ba7e:	2b00      	cmp	r3, #0
 801ba80:	d116      	bne.n	801bab0 <vj_compress_tcp+0x418>
 801ba82:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801ba84:	1c5a      	adds	r2, r3, #1
 801ba86:	643a      	str	r2, [r7, #64]	; 0x40
 801ba88:	2200      	movs	r2, #0
 801ba8a:	701a      	strb	r2, [r3, #0]
 801ba8c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801ba8e:	3301      	adds	r3, #1
 801ba90:	214a      	movs	r1, #74	; 0x4a
 801ba92:	187a      	adds	r2, r7, r1
 801ba94:	8812      	ldrh	r2, [r2, #0]
 801ba96:	b2d2      	uxtb	r2, r2
 801ba98:	701a      	strb	r2, [r3, #0]
 801ba9a:	187b      	adds	r3, r7, r1
 801ba9c:	881b      	ldrh	r3, [r3, #0]
 801ba9e:	0a1b      	lsrs	r3, r3, #8
 801baa0:	b29b      	uxth	r3, r3
 801baa2:	b2da      	uxtb	r2, r3
 801baa4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801baa6:	701a      	strb	r2, [r3, #0]
 801baa8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801baaa:	3302      	adds	r3, #2
 801baac:	643b      	str	r3, [r7, #64]	; 0x40
 801baae:	e007      	b.n	801bac0 <vj_compress_tcp+0x428>
 801bab0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bab2:	1c5a      	adds	r2, r3, #1
 801bab4:	643a      	str	r2, [r7, #64]	; 0x40
 801bab6:	224a      	movs	r2, #74	; 0x4a
 801bab8:	18ba      	adds	r2, r7, r2
 801baba:	8812      	ldrh	r2, [r2, #0]
 801babc:	b2d2      	uxtb	r2, r2
 801babe:	701a      	strb	r2, [r3, #0]
    changes |= NEW_U;
 801bac0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801bac2:	2201      	movs	r2, #1
 801bac4:	4313      	orrs	r3, r2
 801bac6:	647b      	str	r3, [r7, #68]	; 0x44
 801bac8:	e00e      	b.n	801bae8 <vj_compress_tcp+0x450>
  } else if (th->urgp != oth->urgp) {
 801baca:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801bacc:	7c9a      	ldrb	r2, [r3, #18]
 801bace:	7cdb      	ldrb	r3, [r3, #19]
 801bad0:	021b      	lsls	r3, r3, #8
 801bad2:	4313      	orrs	r3, r2
 801bad4:	b29a      	uxth	r2, r3
 801bad6:	6a3b      	ldr	r3, [r7, #32]
 801bad8:	7c99      	ldrb	r1, [r3, #18]
 801bada:	7cdb      	ldrb	r3, [r3, #19]
 801badc:	021b      	lsls	r3, r3, #8
 801bade:	430b      	orrs	r3, r1
 801bae0:	b29b      	uxth	r3, r3
 801bae2:	429a      	cmp	r2, r3
 801bae4:	d000      	beq.n	801bae8 <vj_compress_tcp+0x450>
 801bae6:	e237      	b.n	801bf58 <vj_compress_tcp+0x8c0>
     * doesn't prohibit the change so we have to deal
     * with it. */
    goto uncompressed;
  }

  if ((deltaS = (u16_t)(lwip_ntohs(th->wnd) - lwip_ntohs(oth->wnd))) != 0) {
 801bae8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801baea:	7b9a      	ldrb	r2, [r3, #14]
 801baec:	7bdb      	ldrb	r3, [r3, #15]
 801baee:	021b      	lsls	r3, r3, #8
 801baf0:	4313      	orrs	r3, r2
 801baf2:	b29b      	uxth	r3, r3
 801baf4:	0018      	movs	r0, r3
 801baf6:	f7eb f887 	bl	8006c08 <lwip_htons>
 801bafa:	0003      	movs	r3, r0
 801bafc:	001c      	movs	r4, r3
 801bafe:	6a3b      	ldr	r3, [r7, #32]
 801bb00:	7b9a      	ldrb	r2, [r3, #14]
 801bb02:	7bdb      	ldrb	r3, [r3, #15]
 801bb04:	021b      	lsls	r3, r3, #8
 801bb06:	4313      	orrs	r3, r2
 801bb08:	b29b      	uxth	r3, r3
 801bb0a:	0018      	movs	r0, r3
 801bb0c:	f7eb f87c 	bl	8006c08 <lwip_htons>
 801bb10:	0003      	movs	r3, r0
 801bb12:	001a      	movs	r2, r3
 801bb14:	214a      	movs	r1, #74	; 0x4a
 801bb16:	187b      	adds	r3, r7, r1
 801bb18:	1aa2      	subs	r2, r4, r2
 801bb1a:	801a      	strh	r2, [r3, #0]
 801bb1c:	187b      	adds	r3, r7, r1
 801bb1e:	881b      	ldrh	r3, [r3, #0]
 801bb20:	2b00      	cmp	r3, #0
 801bb22:	d025      	beq.n	801bb70 <vj_compress_tcp+0x4d8>
    ENCODE(deltaS);
 801bb24:	187b      	adds	r3, r7, r1
 801bb26:	881b      	ldrh	r3, [r3, #0]
 801bb28:	2bff      	cmp	r3, #255	; 0xff
 801bb2a:	d915      	bls.n	801bb58 <vj_compress_tcp+0x4c0>
 801bb2c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bb2e:	1c5a      	adds	r2, r3, #1
 801bb30:	643a      	str	r2, [r7, #64]	; 0x40
 801bb32:	2200      	movs	r2, #0
 801bb34:	701a      	strb	r2, [r3, #0]
 801bb36:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bb38:	3301      	adds	r3, #1
 801bb3a:	187a      	adds	r2, r7, r1
 801bb3c:	8812      	ldrh	r2, [r2, #0]
 801bb3e:	b2d2      	uxtb	r2, r2
 801bb40:	701a      	strb	r2, [r3, #0]
 801bb42:	187b      	adds	r3, r7, r1
 801bb44:	881b      	ldrh	r3, [r3, #0]
 801bb46:	0a1b      	lsrs	r3, r3, #8
 801bb48:	b29b      	uxth	r3, r3
 801bb4a:	b2da      	uxtb	r2, r3
 801bb4c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bb4e:	701a      	strb	r2, [r3, #0]
 801bb50:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bb52:	3302      	adds	r3, #2
 801bb54:	643b      	str	r3, [r7, #64]	; 0x40
 801bb56:	e007      	b.n	801bb68 <vj_compress_tcp+0x4d0>
 801bb58:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bb5a:	1c5a      	adds	r2, r3, #1
 801bb5c:	643a      	str	r2, [r7, #64]	; 0x40
 801bb5e:	224a      	movs	r2, #74	; 0x4a
 801bb60:	18ba      	adds	r2, r7, r2
 801bb62:	8812      	ldrh	r2, [r2, #0]
 801bb64:	b2d2      	uxtb	r2, r2
 801bb66:	701a      	strb	r2, [r3, #0]
    changes |= NEW_W;
 801bb68:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801bb6a:	2202      	movs	r2, #2
 801bb6c:	4313      	orrs	r3, r2
 801bb6e:	647b      	str	r3, [r7, #68]	; 0x44
  }

  if ((deltaL = lwip_ntohl(th->ackno) - lwip_ntohl(oth->ackno)) != 0) {
 801bb70:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801bb72:	7a1a      	ldrb	r2, [r3, #8]
 801bb74:	7a59      	ldrb	r1, [r3, #9]
 801bb76:	0209      	lsls	r1, r1, #8
 801bb78:	430a      	orrs	r2, r1
 801bb7a:	7a99      	ldrb	r1, [r3, #10]
 801bb7c:	0409      	lsls	r1, r1, #16
 801bb7e:	430a      	orrs	r2, r1
 801bb80:	7adb      	ldrb	r3, [r3, #11]
 801bb82:	061b      	lsls	r3, r3, #24
 801bb84:	4313      	orrs	r3, r2
 801bb86:	0018      	movs	r0, r3
 801bb88:	f7eb f854 	bl	8006c34 <lwip_htonl>
 801bb8c:	0004      	movs	r4, r0
 801bb8e:	6a3b      	ldr	r3, [r7, #32]
 801bb90:	7a1a      	ldrb	r2, [r3, #8]
 801bb92:	7a59      	ldrb	r1, [r3, #9]
 801bb94:	0209      	lsls	r1, r1, #8
 801bb96:	430a      	orrs	r2, r1
 801bb98:	7a99      	ldrb	r1, [r3, #10]
 801bb9a:	0409      	lsls	r1, r1, #16
 801bb9c:	430a      	orrs	r2, r1
 801bb9e:	7adb      	ldrb	r3, [r3, #11]
 801bba0:	061b      	lsls	r3, r3, #24
 801bba2:	4313      	orrs	r3, r2
 801bba4:	0018      	movs	r0, r3
 801bba6:	f7eb f845 	bl	8006c34 <lwip_htonl>
 801bbaa:	0003      	movs	r3, r0
 801bbac:	1ae3      	subs	r3, r4, r3
 801bbae:	61fb      	str	r3, [r7, #28]
 801bbb0:	69fb      	ldr	r3, [r7, #28]
 801bbb2:	2b00      	cmp	r3, #0
 801bbb4:	d02f      	beq.n	801bc16 <vj_compress_tcp+0x57e>
    if (deltaL > 0xffff) {
 801bbb6:	69fa      	ldr	r2, [r7, #28]
 801bbb8:	2380      	movs	r3, #128	; 0x80
 801bbba:	025b      	lsls	r3, r3, #9
 801bbbc:	429a      	cmp	r2, r3
 801bbbe:	d300      	bcc.n	801bbc2 <vj_compress_tcp+0x52a>
 801bbc0:	e1cc      	b.n	801bf5c <vj_compress_tcp+0x8c4>
      goto uncompressed;
    }
    deltaA = (u16_t)deltaL;
 801bbc2:	2148      	movs	r1, #72	; 0x48
 801bbc4:	187b      	adds	r3, r7, r1
 801bbc6:	69fa      	ldr	r2, [r7, #28]
 801bbc8:	801a      	strh	r2, [r3, #0]
    ENCODE(deltaA);
 801bbca:	187b      	adds	r3, r7, r1
 801bbcc:	881b      	ldrh	r3, [r3, #0]
 801bbce:	2bff      	cmp	r3, #255	; 0xff
 801bbd0:	d915      	bls.n	801bbfe <vj_compress_tcp+0x566>
 801bbd2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bbd4:	1c5a      	adds	r2, r3, #1
 801bbd6:	643a      	str	r2, [r7, #64]	; 0x40
 801bbd8:	2200      	movs	r2, #0
 801bbda:	701a      	strb	r2, [r3, #0]
 801bbdc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bbde:	3301      	adds	r3, #1
 801bbe0:	187a      	adds	r2, r7, r1
 801bbe2:	8812      	ldrh	r2, [r2, #0]
 801bbe4:	b2d2      	uxtb	r2, r2
 801bbe6:	701a      	strb	r2, [r3, #0]
 801bbe8:	187b      	adds	r3, r7, r1
 801bbea:	881b      	ldrh	r3, [r3, #0]
 801bbec:	0a1b      	lsrs	r3, r3, #8
 801bbee:	b29b      	uxth	r3, r3
 801bbf0:	b2da      	uxtb	r2, r3
 801bbf2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bbf4:	701a      	strb	r2, [r3, #0]
 801bbf6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bbf8:	3302      	adds	r3, #2
 801bbfa:	643b      	str	r3, [r7, #64]	; 0x40
 801bbfc:	e007      	b.n	801bc0e <vj_compress_tcp+0x576>
 801bbfe:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bc00:	1c5a      	adds	r2, r3, #1
 801bc02:	643a      	str	r2, [r7, #64]	; 0x40
 801bc04:	2248      	movs	r2, #72	; 0x48
 801bc06:	18ba      	adds	r2, r7, r2
 801bc08:	8812      	ldrh	r2, [r2, #0]
 801bc0a:	b2d2      	uxtb	r2, r2
 801bc0c:	701a      	strb	r2, [r3, #0]
    changes |= NEW_A;
 801bc0e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801bc10:	2204      	movs	r2, #4
 801bc12:	4313      	orrs	r3, r2
 801bc14:	647b      	str	r3, [r7, #68]	; 0x44
  }

  if ((deltaL = lwip_ntohl(th->seqno) - lwip_ntohl(oth->seqno)) != 0) {
 801bc16:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801bc18:	791a      	ldrb	r2, [r3, #4]
 801bc1a:	7959      	ldrb	r1, [r3, #5]
 801bc1c:	0209      	lsls	r1, r1, #8
 801bc1e:	430a      	orrs	r2, r1
 801bc20:	7999      	ldrb	r1, [r3, #6]
 801bc22:	0409      	lsls	r1, r1, #16
 801bc24:	430a      	orrs	r2, r1
 801bc26:	79db      	ldrb	r3, [r3, #7]
 801bc28:	061b      	lsls	r3, r3, #24
 801bc2a:	4313      	orrs	r3, r2
 801bc2c:	0018      	movs	r0, r3
 801bc2e:	f7eb f801 	bl	8006c34 <lwip_htonl>
 801bc32:	0004      	movs	r4, r0
 801bc34:	6a3b      	ldr	r3, [r7, #32]
 801bc36:	791a      	ldrb	r2, [r3, #4]
 801bc38:	7959      	ldrb	r1, [r3, #5]
 801bc3a:	0209      	lsls	r1, r1, #8
 801bc3c:	430a      	orrs	r2, r1
 801bc3e:	7999      	ldrb	r1, [r3, #6]
 801bc40:	0409      	lsls	r1, r1, #16
 801bc42:	430a      	orrs	r2, r1
 801bc44:	79db      	ldrb	r3, [r3, #7]
 801bc46:	061b      	lsls	r3, r3, #24
 801bc48:	4313      	orrs	r3, r2
 801bc4a:	0018      	movs	r0, r3
 801bc4c:	f7ea fff2 	bl	8006c34 <lwip_htonl>
 801bc50:	0003      	movs	r3, r0
 801bc52:	1ae3      	subs	r3, r4, r3
 801bc54:	61fb      	str	r3, [r7, #28]
 801bc56:	69fb      	ldr	r3, [r7, #28]
 801bc58:	2b00      	cmp	r3, #0
 801bc5a:	d02f      	beq.n	801bcbc <vj_compress_tcp+0x624>
    if (deltaL > 0xffff) {
 801bc5c:	69fa      	ldr	r2, [r7, #28]
 801bc5e:	2380      	movs	r3, #128	; 0x80
 801bc60:	025b      	lsls	r3, r3, #9
 801bc62:	429a      	cmp	r2, r3
 801bc64:	d300      	bcc.n	801bc68 <vj_compress_tcp+0x5d0>
 801bc66:	e17b      	b.n	801bf60 <vj_compress_tcp+0x8c8>
      goto uncompressed;
    }
    deltaS = (u16_t)deltaL;
 801bc68:	214a      	movs	r1, #74	; 0x4a
 801bc6a:	187b      	adds	r3, r7, r1
 801bc6c:	69fa      	ldr	r2, [r7, #28]
 801bc6e:	801a      	strh	r2, [r3, #0]
    ENCODE(deltaS);
 801bc70:	187b      	adds	r3, r7, r1
 801bc72:	881b      	ldrh	r3, [r3, #0]
 801bc74:	2bff      	cmp	r3, #255	; 0xff
 801bc76:	d915      	bls.n	801bca4 <vj_compress_tcp+0x60c>
 801bc78:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bc7a:	1c5a      	adds	r2, r3, #1
 801bc7c:	643a      	str	r2, [r7, #64]	; 0x40
 801bc7e:	2200      	movs	r2, #0
 801bc80:	701a      	strb	r2, [r3, #0]
 801bc82:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bc84:	3301      	adds	r3, #1
 801bc86:	187a      	adds	r2, r7, r1
 801bc88:	8812      	ldrh	r2, [r2, #0]
 801bc8a:	b2d2      	uxtb	r2, r2
 801bc8c:	701a      	strb	r2, [r3, #0]
 801bc8e:	187b      	adds	r3, r7, r1
 801bc90:	881b      	ldrh	r3, [r3, #0]
 801bc92:	0a1b      	lsrs	r3, r3, #8
 801bc94:	b29b      	uxth	r3, r3
 801bc96:	b2da      	uxtb	r2, r3
 801bc98:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bc9a:	701a      	strb	r2, [r3, #0]
 801bc9c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bc9e:	3302      	adds	r3, #2
 801bca0:	643b      	str	r3, [r7, #64]	; 0x40
 801bca2:	e007      	b.n	801bcb4 <vj_compress_tcp+0x61c>
 801bca4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bca6:	1c5a      	adds	r2, r3, #1
 801bca8:	643a      	str	r2, [r7, #64]	; 0x40
 801bcaa:	224a      	movs	r2, #74	; 0x4a
 801bcac:	18ba      	adds	r2, r7, r2
 801bcae:	8812      	ldrh	r2, [r2, #0]
 801bcb0:	b2d2      	uxtb	r2, r2
 801bcb2:	701a      	strb	r2, [r3, #0]
    changes |= NEW_S;
 801bcb4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801bcb6:	2208      	movs	r2, #8
 801bcb8:	4313      	orrs	r3, r2
 801bcba:	647b      	str	r3, [r7, #68]	; 0x44
 801bcbc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801bcbe:	2b0f      	cmp	r3, #15
 801bcc0:	d851      	bhi.n	801bd66 <vj_compress_tcp+0x6ce>
 801bcc2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801bcc4:	009a      	lsls	r2, r3, #2
 801bcc6:	4bb3      	ldr	r3, [pc, #716]	; (801bf94 <vj_compress_tcp+0x8fc>)
 801bcc8:	18d3      	adds	r3, r2, r3
 801bcca:	681b      	ldr	r3, [r3, #0]
 801bccc:	469f      	mov	pc, r3
     * an ack (normal on an interactive connection) and we send
     * it compressed.  Otherwise it's probably a retransmit,
     * retransmitted ack or window probe.  Send it uncompressed
     * in case the other side missed the compressed version.
     */
    if (IPH_LEN(ip) != IPH_LEN(&cs->cs_ip) &&
 801bcce:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801bcd0:	789a      	ldrb	r2, [r3, #2]
 801bcd2:	78db      	ldrb	r3, [r3, #3]
 801bcd4:	021b      	lsls	r3, r3, #8
 801bcd6:	4313      	orrs	r3, r2
 801bcd8:	b29a      	uxth	r2, r3
 801bcda:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bcdc:	895b      	ldrh	r3, [r3, #10]
 801bcde:	429a      	cmp	r2, r3
 801bce0:	d100      	bne.n	801bce4 <vj_compress_tcp+0x64c>
 801bce2:	e13f      	b.n	801bf64 <vj_compress_tcp+0x8cc>
      lwip_ntohs(IPH_LEN(&cs->cs_ip)) == hlen) {
 801bce4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bce6:	895b      	ldrh	r3, [r3, #10]
 801bce8:	0018      	movs	r0, r3
 801bcea:	f7ea ff8d 	bl	8006c08 <lwip_htons>
 801bcee:	0003      	movs	r3, r0
 801bcf0:	001a      	movs	r2, r3
    if (IPH_LEN(ip) != IPH_LEN(&cs->cs_ip) &&
 801bcf2:	232e      	movs	r3, #46	; 0x2e
 801bcf4:	18fb      	adds	r3, r7, r3
 801bcf6:	881b      	ldrh	r3, [r3, #0]
 801bcf8:	4293      	cmp	r3, r2
 801bcfa:	d000      	beq.n	801bcfe <vj_compress_tcp+0x666>
 801bcfc:	e132      	b.n	801bf64 <vj_compress_tcp+0x8cc>
      break;
 801bcfe:	e037      	b.n	801bd70 <vj_compress_tcp+0x6d8>
     * send packet uncompressed.
     */
    goto uncompressed;

  case NEW_S|NEW_A:
    if (deltaS == deltaA && deltaS == lwip_ntohs(IPH_LEN(&cs->cs_ip)) - hlen) {
 801bd00:	214a      	movs	r1, #74	; 0x4a
 801bd02:	187a      	adds	r2, r7, r1
 801bd04:	2348      	movs	r3, #72	; 0x48
 801bd06:	18fb      	adds	r3, r7, r3
 801bd08:	8812      	ldrh	r2, [r2, #0]
 801bd0a:	881b      	ldrh	r3, [r3, #0]
 801bd0c:	429a      	cmp	r2, r3
 801bd0e:	d12c      	bne.n	801bd6a <vj_compress_tcp+0x6d2>
 801bd10:	187b      	adds	r3, r7, r1
 801bd12:	881c      	ldrh	r4, [r3, #0]
 801bd14:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bd16:	895b      	ldrh	r3, [r3, #10]
 801bd18:	0018      	movs	r0, r3
 801bd1a:	f7ea ff75 	bl	8006c08 <lwip_htons>
 801bd1e:	0003      	movs	r3, r0
 801bd20:	001a      	movs	r2, r3
 801bd22:	232e      	movs	r3, #46	; 0x2e
 801bd24:	18fb      	adds	r3, r7, r3
 801bd26:	881b      	ldrh	r3, [r3, #0]
 801bd28:	1ad3      	subs	r3, r2, r3
 801bd2a:	429c      	cmp	r4, r3
 801bd2c:	d11d      	bne.n	801bd6a <vj_compress_tcp+0x6d2>
      /* special case for echoed terminal traffic */
      changes = SPECIAL_I;
 801bd2e:	230b      	movs	r3, #11
 801bd30:	647b      	str	r3, [r7, #68]	; 0x44
      cp = new_seq;
 801bd32:	230c      	movs	r3, #12
 801bd34:	18fb      	adds	r3, r7, r3
 801bd36:	643b      	str	r3, [r7, #64]	; 0x40
    }
    break;
 801bd38:	e017      	b.n	801bd6a <vj_compress_tcp+0x6d2>

  case NEW_S:
    if (deltaS == lwip_ntohs(IPH_LEN(&cs->cs_ip)) - hlen) {
 801bd3a:	234a      	movs	r3, #74	; 0x4a
 801bd3c:	18fb      	adds	r3, r7, r3
 801bd3e:	881c      	ldrh	r4, [r3, #0]
 801bd40:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bd42:	895b      	ldrh	r3, [r3, #10]
 801bd44:	0018      	movs	r0, r3
 801bd46:	f7ea ff5f 	bl	8006c08 <lwip_htons>
 801bd4a:	0003      	movs	r3, r0
 801bd4c:	001a      	movs	r2, r3
 801bd4e:	232e      	movs	r3, #46	; 0x2e
 801bd50:	18fb      	adds	r3, r7, r3
 801bd52:	881b      	ldrh	r3, [r3, #0]
 801bd54:	1ad3      	subs	r3, r2, r3
 801bd56:	429c      	cmp	r4, r3
 801bd58:	d109      	bne.n	801bd6e <vj_compress_tcp+0x6d6>
      /* special case for data xfer */
      changes = SPECIAL_D;
 801bd5a:	230f      	movs	r3, #15
 801bd5c:	647b      	str	r3, [r7, #68]	; 0x44
      cp = new_seq;
 801bd5e:	230c      	movs	r3, #12
 801bd60:	18fb      	adds	r3, r7, r3
 801bd62:	643b      	str	r3, [r7, #64]	; 0x40
    }
    break;
 801bd64:	e003      	b.n	801bd6e <vj_compress_tcp+0x6d6>
  default:
     break;
 801bd66:	46c0      	nop			; (mov r8, r8)
 801bd68:	e002      	b.n	801bd70 <vj_compress_tcp+0x6d8>
    break;
 801bd6a:	46c0      	nop			; (mov r8, r8)
 801bd6c:	e000      	b.n	801bd70 <vj_compress_tcp+0x6d8>
    break;
 801bd6e:	46c0      	nop			; (mov r8, r8)
  }

  deltaS = (u16_t)(lwip_ntohs(IPH_ID(ip)) - lwip_ntohs(IPH_ID(&cs->cs_ip)));
 801bd70:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801bd72:	791a      	ldrb	r2, [r3, #4]
 801bd74:	795b      	ldrb	r3, [r3, #5]
 801bd76:	021b      	lsls	r3, r3, #8
 801bd78:	4313      	orrs	r3, r2
 801bd7a:	b29b      	uxth	r3, r3
 801bd7c:	0018      	movs	r0, r3
 801bd7e:	f7ea ff43 	bl	8006c08 <lwip_htons>
 801bd82:	0003      	movs	r3, r0
 801bd84:	001c      	movs	r4, r3
 801bd86:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bd88:	899b      	ldrh	r3, [r3, #12]
 801bd8a:	0018      	movs	r0, r3
 801bd8c:	f7ea ff3c 	bl	8006c08 <lwip_htons>
 801bd90:	0003      	movs	r3, r0
 801bd92:	001a      	movs	r2, r3
 801bd94:	214a      	movs	r1, #74	; 0x4a
 801bd96:	187b      	adds	r3, r7, r1
 801bd98:	1aa2      	subs	r2, r4, r2
 801bd9a:	801a      	strh	r2, [r3, #0]
  if (deltaS != 1) {
 801bd9c:	187b      	adds	r3, r7, r1
 801bd9e:	881b      	ldrh	r3, [r3, #0]
 801bda0:	2b01      	cmp	r3, #1
 801bda2:	d02a      	beq.n	801bdfa <vj_compress_tcp+0x762>
    ENCODEZ(deltaS);
 801bda4:	187b      	adds	r3, r7, r1
 801bda6:	881b      	ldrh	r3, [r3, #0]
 801bda8:	2bff      	cmp	r3, #255	; 0xff
 801bdaa:	d803      	bhi.n	801bdb4 <vj_compress_tcp+0x71c>
 801bdac:	187b      	adds	r3, r7, r1
 801bdae:	881b      	ldrh	r3, [r3, #0]
 801bdb0:	2b00      	cmp	r3, #0
 801bdb2:	d116      	bne.n	801bde2 <vj_compress_tcp+0x74a>
 801bdb4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bdb6:	1c5a      	adds	r2, r3, #1
 801bdb8:	643a      	str	r2, [r7, #64]	; 0x40
 801bdba:	2200      	movs	r2, #0
 801bdbc:	701a      	strb	r2, [r3, #0]
 801bdbe:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bdc0:	3301      	adds	r3, #1
 801bdc2:	214a      	movs	r1, #74	; 0x4a
 801bdc4:	187a      	adds	r2, r7, r1
 801bdc6:	8812      	ldrh	r2, [r2, #0]
 801bdc8:	b2d2      	uxtb	r2, r2
 801bdca:	701a      	strb	r2, [r3, #0]
 801bdcc:	187b      	adds	r3, r7, r1
 801bdce:	881b      	ldrh	r3, [r3, #0]
 801bdd0:	0a1b      	lsrs	r3, r3, #8
 801bdd2:	b29b      	uxth	r3, r3
 801bdd4:	b2da      	uxtb	r2, r3
 801bdd6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bdd8:	701a      	strb	r2, [r3, #0]
 801bdda:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bddc:	3302      	adds	r3, #2
 801bdde:	643b      	str	r3, [r7, #64]	; 0x40
 801bde0:	e007      	b.n	801bdf2 <vj_compress_tcp+0x75a>
 801bde2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bde4:	1c5a      	adds	r2, r3, #1
 801bde6:	643a      	str	r2, [r7, #64]	; 0x40
 801bde8:	224a      	movs	r2, #74	; 0x4a
 801bdea:	18ba      	adds	r2, r7, r2
 801bdec:	8812      	ldrh	r2, [r2, #0]
 801bdee:	b2d2      	uxtb	r2, r2
 801bdf0:	701a      	strb	r2, [r3, #0]
    changes |= NEW_I;
 801bdf2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801bdf4:	2220      	movs	r2, #32
 801bdf6:	4313      	orrs	r3, r2
 801bdf8:	647b      	str	r3, [r7, #68]	; 0x44
  }
  if (TCPH_FLAGS(th) & TCP_PSH) {
 801bdfa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801bdfc:	7b1a      	ldrb	r2, [r3, #12]
 801bdfe:	7b5b      	ldrb	r3, [r3, #13]
 801be00:	021b      	lsls	r3, r3, #8
 801be02:	4313      	orrs	r3, r2
 801be04:	b29b      	uxth	r3, r3
 801be06:	0018      	movs	r0, r3
 801be08:	f7ea fefe 	bl	8006c08 <lwip_htons>
 801be0c:	0003      	movs	r3, r0
 801be0e:	b2db      	uxtb	r3, r3
 801be10:	001a      	movs	r2, r3
 801be12:	2308      	movs	r3, #8
 801be14:	4013      	ands	r3, r2
 801be16:	d003      	beq.n	801be20 <vj_compress_tcp+0x788>
    changes |= TCP_PUSH_BIT;
 801be18:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801be1a:	2210      	movs	r2, #16
 801be1c:	4313      	orrs	r3, r2
 801be1e:	647b      	str	r3, [r7, #68]	; 0x44
  }
  /*
   * Grab the cksum before we overwrite it below.  Then update our
   * state with this packet's header.
   */
  deltaA = lwip_ntohs(th->chksum);
 801be20:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801be22:	7c1a      	ldrb	r2, [r3, #16]
 801be24:	7c5b      	ldrb	r3, [r3, #17]
 801be26:	021b      	lsls	r3, r3, #8
 801be28:	4313      	orrs	r3, r2
 801be2a:	b29b      	uxth	r3, r3
 801be2c:	2248      	movs	r2, #72	; 0x48
 801be2e:	18bc      	adds	r4, r7, r2
 801be30:	0018      	movs	r0, r3
 801be32:	f7ea fee9 	bl	8006c08 <lwip_htons>
 801be36:	0003      	movs	r3, r0
 801be38:	8023      	strh	r3, [r4, #0]
  MEMCPY(&cs->cs_ip, ip, hlen);
 801be3a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801be3c:	3308      	adds	r3, #8
 801be3e:	0018      	movs	r0, r3
 801be40:	232e      	movs	r3, #46	; 0x2e
 801be42:	18fb      	adds	r3, r7, r3
 801be44:	881a      	ldrh	r2, [r3, #0]
 801be46:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801be48:	0019      	movs	r1, r3
 801be4a:	f000 fec9 	bl	801cbe0 <memcpy>
   * mask, one for the connection id and two for the tcp checksum.
   * So, (cp - new_seq) + 4 bytes of header are needed.  hlen is how
   * many bytes of the original packet to toss so subtract the two to
   * get the new packet size.
   */
  deltaS = (u16_t)(cp - new_seq);
 801be4e:	230c      	movs	r3, #12
 801be50:	18fb      	adds	r3, r7, r3
 801be52:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801be54:	1ad2      	subs	r2, r2, r3
 801be56:	234a      	movs	r3, #74	; 0x4a
 801be58:	18fb      	adds	r3, r7, r3
 801be5a:	801a      	strh	r2, [r3, #0]
  if (!comp->compressSlot || comp->last_xmit != cs->cs_id) {
 801be5c:	687b      	ldr	r3, [r7, #4]
 801be5e:	7a5b      	ldrb	r3, [r3, #9]
 801be60:	2b00      	cmp	r3, #0
 801be62:	d005      	beq.n	801be70 <vj_compress_tcp+0x7d8>
 801be64:	687b      	ldr	r3, [r7, #4]
 801be66:	795a      	ldrb	r2, [r3, #5]
 801be68:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801be6a:	799b      	ldrb	r3, [r3, #6]
 801be6c:	429a      	cmp	r2, r3
 801be6e:	d031      	beq.n	801bed4 <vj_compress_tcp+0x83c>
    comp->last_xmit = cs->cs_id;
 801be70:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801be72:	799a      	ldrb	r2, [r3, #6]
 801be74:	687b      	ldr	r3, [r7, #4]
 801be76:	715a      	strb	r2, [r3, #5]
    hlen -= deltaS + 4;
 801be78:	212e      	movs	r1, #46	; 0x2e
 801be7a:	187a      	adds	r2, r7, r1
 801be7c:	234a      	movs	r3, #74	; 0x4a
 801be7e:	18fb      	adds	r3, r7, r3
 801be80:	8812      	ldrh	r2, [r2, #0]
 801be82:	881b      	ldrh	r3, [r3, #0]
 801be84:	1ad3      	subs	r3, r2, r3
 801be86:	b29a      	uxth	r2, r3
 801be88:	187b      	adds	r3, r7, r1
 801be8a:	3a04      	subs	r2, #4
 801be8c:	801a      	strh	r2, [r3, #0]
    if (pbuf_remove_header(np, hlen)){
 801be8e:	187b      	adds	r3, r7, r1
 801be90:	881a      	ldrh	r2, [r3, #0]
 801be92:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801be94:	0011      	movs	r1, r2
 801be96:	0018      	movs	r0, r3
 801be98:	f7ed fdc2 	bl	8009a20 <pbuf_remove_header>
 801be9c:	1e03      	subs	r3, r0, #0
 801be9e:	d006      	beq.n	801beae <vj_compress_tcp+0x816>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_remove_header failed\n", 0);
 801bea0:	4b3d      	ldr	r3, [pc, #244]	; (801bf98 <vj_compress_tcp+0x900>)
 801bea2:	22ce      	movs	r2, #206	; 0xce
 801bea4:	0052      	lsls	r2, r2, #1
 801bea6:	493d      	ldr	r1, [pc, #244]	; (801bf9c <vj_compress_tcp+0x904>)
 801bea8:	483d      	ldr	r0, [pc, #244]	; (801bfa0 <vj_compress_tcp+0x908>)
 801beaa:	f7e6 fd17 	bl	80028dc <app_debug_rtt_raw>
    }
    cp = (u8_t*)np->payload;
 801beae:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801beb0:	685b      	ldr	r3, [r3, #4]
 801beb2:	643b      	str	r3, [r7, #64]	; 0x40
    *cp++ = (u8_t)(changes | NEW_C);
 801beb4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801beb6:	b2da      	uxtb	r2, r3
 801beb8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801beba:	1c59      	adds	r1, r3, #1
 801bebc:	6439      	str	r1, [r7, #64]	; 0x40
 801bebe:	2140      	movs	r1, #64	; 0x40
 801bec0:	430a      	orrs	r2, r1
 801bec2:	b2d2      	uxtb	r2, r2
 801bec4:	701a      	strb	r2, [r3, #0]
    *cp++ = cs->cs_id;
 801bec6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bec8:	1c5a      	adds	r2, r3, #1
 801beca:	643a      	str	r2, [r7, #64]	; 0x40
 801becc:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801bece:	7992      	ldrb	r2, [r2, #6]
 801bed0:	701a      	strb	r2, [r3, #0]
 801bed2:	e023      	b.n	801bf1c <vj_compress_tcp+0x884>
  } else {
    hlen -= deltaS + 3;
 801bed4:	212e      	movs	r1, #46	; 0x2e
 801bed6:	187a      	adds	r2, r7, r1
 801bed8:	234a      	movs	r3, #74	; 0x4a
 801beda:	18fb      	adds	r3, r7, r3
 801bedc:	8812      	ldrh	r2, [r2, #0]
 801bede:	881b      	ldrh	r3, [r3, #0]
 801bee0:	1ad3      	subs	r3, r2, r3
 801bee2:	b29a      	uxth	r2, r3
 801bee4:	187b      	adds	r3, r7, r1
 801bee6:	3a03      	subs	r2, #3
 801bee8:	801a      	strh	r2, [r3, #0]
    if (pbuf_remove_header(np, hlen)) {
 801beea:	187b      	adds	r3, r7, r1
 801beec:	881a      	ldrh	r2, [r3, #0]
 801beee:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801bef0:	0011      	movs	r1, r2
 801bef2:	0018      	movs	r0, r3
 801bef4:	f7ed fd94 	bl	8009a20 <pbuf_remove_header>
 801bef8:	1e03      	subs	r3, r0, #0
 801befa:	d006      	beq.n	801bf0a <vj_compress_tcp+0x872>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_remove_header failed\n", 0);
 801befc:	4b26      	ldr	r3, [pc, #152]	; (801bf98 <vj_compress_tcp+0x900>)
 801befe:	22a6      	movs	r2, #166	; 0xa6
 801bf00:	32ff      	adds	r2, #255	; 0xff
 801bf02:	4926      	ldr	r1, [pc, #152]	; (801bf9c <vj_compress_tcp+0x904>)
 801bf04:	4826      	ldr	r0, [pc, #152]	; (801bfa0 <vj_compress_tcp+0x908>)
 801bf06:	f7e6 fce9 	bl	80028dc <app_debug_rtt_raw>
    }
    cp = (u8_t*)np->payload;
 801bf0a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801bf0c:	685b      	ldr	r3, [r3, #4]
 801bf0e:	643b      	str	r3, [r7, #64]	; 0x40
    *cp++ = (u8_t)changes;
 801bf10:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bf12:	1c5a      	adds	r2, r3, #1
 801bf14:	643a      	str	r2, [r7, #64]	; 0x40
 801bf16:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801bf18:	b2d2      	uxtb	r2, r2
 801bf1a:	701a      	strb	r2, [r3, #0]
  }
  *cp++ = (u8_t)(deltaA >> 8);
 801bf1c:	2048      	movs	r0, #72	; 0x48
 801bf1e:	183b      	adds	r3, r7, r0
 801bf20:	881b      	ldrh	r3, [r3, #0]
 801bf22:	0a1b      	lsrs	r3, r3, #8
 801bf24:	b299      	uxth	r1, r3
 801bf26:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bf28:	1c5a      	adds	r2, r3, #1
 801bf2a:	643a      	str	r2, [r7, #64]	; 0x40
 801bf2c:	b2ca      	uxtb	r2, r1
 801bf2e:	701a      	strb	r2, [r3, #0]
  *cp++ = (u8_t)deltaA;
 801bf30:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bf32:	1c5a      	adds	r2, r3, #1
 801bf34:	643a      	str	r2, [r7, #64]	; 0x40
 801bf36:	183a      	adds	r2, r7, r0
 801bf38:	8812      	ldrh	r2, [r2, #0]
 801bf3a:	b2d2      	uxtb	r2, r2
 801bf3c:	701a      	strb	r2, [r3, #0]
  MEMCPY(cp, new_seq, deltaS);
 801bf3e:	234a      	movs	r3, #74	; 0x4a
 801bf40:	18fb      	adds	r3, r7, r3
 801bf42:	881a      	ldrh	r2, [r3, #0]
 801bf44:	230c      	movs	r3, #12
 801bf46:	18f9      	adds	r1, r7, r3
 801bf48:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bf4a:	0018      	movs	r0, r3
 801bf4c:	f000 fe48 	bl	801cbe0 <memcpy>
  INCR(vjs_compressed);
  return (TYPE_COMPRESSED_TCP);
 801bf50:	2380      	movs	r3, #128	; 0x80
 801bf52:	e01b      	b.n	801bf8c <vj_compress_tcp+0x8f4>
    goto uncompressed;
 801bf54:	46c0      	nop			; (mov r8, r8)
 801bf56:	e006      	b.n	801bf66 <vj_compress_tcp+0x8ce>
    goto uncompressed;
 801bf58:	46c0      	nop			; (mov r8, r8)
 801bf5a:	e004      	b.n	801bf66 <vj_compress_tcp+0x8ce>
      goto uncompressed;
 801bf5c:	46c0      	nop			; (mov r8, r8)
 801bf5e:	e002      	b.n	801bf66 <vj_compress_tcp+0x8ce>
      goto uncompressed;
 801bf60:	46c0      	nop			; (mov r8, r8)
 801bf62:	e000      	b.n	801bf66 <vj_compress_tcp+0x8ce>
    goto uncompressed;
 801bf64:	46c0      	nop			; (mov r8, r8)
   * Update connection state cs & send uncompressed packet (that is,
   * a regular ip/tcp packet but with the 'conversation id' we hope
   * to use on future compressed packets in the protocol field).
   */
uncompressed:
  MEMCPY(&cs->cs_ip, ip, hlen);
 801bf66:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bf68:	3308      	adds	r3, #8
 801bf6a:	0018      	movs	r0, r3
 801bf6c:	232e      	movs	r3, #46	; 0x2e
 801bf6e:	18fb      	adds	r3, r7, r3
 801bf70:	881a      	ldrh	r2, [r3, #0]
 801bf72:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801bf74:	0019      	movs	r1, r3
 801bf76:	f000 fe33 	bl	801cbe0 <memcpy>
  IPH_PROTO_SET(ip, cs->cs_id);
 801bf7a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bf7c:	799a      	ldrb	r2, [r3, #6]
 801bf7e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801bf80:	725a      	strb	r2, [r3, #9]
  comp->last_xmit = cs->cs_id;
 801bf82:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bf84:	799a      	ldrb	r2, [r3, #6]
 801bf86:	687b      	ldr	r3, [r7, #4]
 801bf88:	715a      	strb	r2, [r3, #5]
  return (TYPE_UNCOMPRESSED_TCP);
 801bf8a:	2370      	movs	r3, #112	; 0x70
}
 801bf8c:	0018      	movs	r0, r3
 801bf8e:	46bd      	mov	sp, r7
 801bf90:	b014      	add	sp, #80	; 0x50
 801bf92:	bdb0      	pop	{r4, r5, r7, pc}
 801bf94:	08022a08 	.word	0x08022a08
 801bf98:	08021c74 	.word	0x08021c74
 801bf9c:	08021ca0 	.word	0x08021ca0
 801bfa0:	08021cbc 	.word	0x08021cbc

0801bfa4 <vj_uncompress_err>:
/*
 * Called when we may have missed a packet.
 */
void
vj_uncompress_err(struct vjcompress *comp)
{
 801bfa4:	b580      	push	{r7, lr}
 801bfa6:	b082      	sub	sp, #8
 801bfa8:	af00      	add	r7, sp, #0
 801bfaa:	6078      	str	r0, [r7, #4]
  comp->flags |= VJF_TOSS;
 801bfac:	687b      	ldr	r3, [r7, #4]
 801bfae:	88db      	ldrh	r3, [r3, #6]
 801bfb0:	2201      	movs	r2, #1
 801bfb2:	4313      	orrs	r3, r2
 801bfb4:	b29a      	uxth	r2, r3
 801bfb6:	687b      	ldr	r3, [r7, #4]
 801bfb8:	80da      	strh	r2, [r3, #6]
  INCR(vjs_errorin);
}
 801bfba:	46c0      	nop			; (mov r8, r8)
 801bfbc:	46bd      	mov	sp, r7
 801bfbe:	b002      	add	sp, #8
 801bfc0:	bd80      	pop	{r7, pc}
	...

0801bfc4 <vj_uncompress_uncomp>:
 * "Uncompress" a packet of type TYPE_UNCOMPRESSED_TCP.
 * Return 0 on success, -1 on failure.
 */
int
vj_uncompress_uncomp(struct pbuf *nb, struct vjcompress *comp)
{
 801bfc4:	b580      	push	{r7, lr}
 801bfc6:	b086      	sub	sp, #24
 801bfc8:	af00      	add	r7, sp, #0
 801bfca:	6078      	str	r0, [r7, #4]
 801bfcc:	6039      	str	r1, [r7, #0]
  u32_t hlen;
  struct cstate *cs;
  struct ip_hdr *ip;

  ip = (struct ip_hdr *)nb->payload;
 801bfce:	687b      	ldr	r3, [r7, #4]
 801bfd0:	685b      	ldr	r3, [r3, #4]
 801bfd2:	617b      	str	r3, [r7, #20]
  hlen = IPH_HL(ip) << 2;
 801bfd4:	697b      	ldr	r3, [r7, #20]
 801bfd6:	781b      	ldrb	r3, [r3, #0]
 801bfd8:	009b      	lsls	r3, r3, #2
 801bfda:	001a      	movs	r2, r3
 801bfdc:	233c      	movs	r3, #60	; 0x3c
 801bfde:	4013      	ands	r3, r2
 801bfe0:	613b      	str	r3, [r7, #16]
  if (IPH_PROTO(ip) >= MAX_SLOTS
 801bfe2:	697b      	ldr	r3, [r7, #20]
 801bfe4:	7a5b      	ldrb	r3, [r3, #9]
 801bfe6:	2b0f      	cmp	r3, #15
 801bfe8:	d823      	bhi.n	801c032 <vj_uncompress_uncomp+0x6e>
      || hlen + sizeof(struct tcp_hdr) > nb->len
 801bfea:	693b      	ldr	r3, [r7, #16]
 801bfec:	3314      	adds	r3, #20
 801bfee:	687a      	ldr	r2, [r7, #4]
 801bff0:	8952      	ldrh	r2, [r2, #10]
 801bff2:	4293      	cmp	r3, r2
 801bff4:	d81d      	bhi.n	801c032 <vj_uncompress_uncomp+0x6e>
      || (hlen += TCPH_HDRLEN_BYTES((struct tcp_hdr *)&((char *)ip)[hlen]))
 801bff6:	697a      	ldr	r2, [r7, #20]
 801bff8:	693b      	ldr	r3, [r7, #16]
 801bffa:	18d3      	adds	r3, r2, r3
 801bffc:	7b1a      	ldrb	r2, [r3, #12]
 801bffe:	7b5b      	ldrb	r3, [r3, #13]
 801c000:	021b      	lsls	r3, r3, #8
 801c002:	4313      	orrs	r3, r2
 801c004:	b29b      	uxth	r3, r3
 801c006:	0018      	movs	r0, r3
 801c008:	f7ea fdfe 	bl	8006c08 <lwip_htons>
 801c00c:	0003      	movs	r3, r0
 801c00e:	0b1b      	lsrs	r3, r3, #12
 801c010:	b29b      	uxth	r3, r3
 801c012:	b2db      	uxtb	r3, r3
 801c014:	009b      	lsls	r3, r3, #2
 801c016:	b2db      	uxtb	r3, r3
 801c018:	001a      	movs	r2, r3
 801c01a:	693b      	ldr	r3, [r7, #16]
 801c01c:	189b      	adds	r3, r3, r2
 801c01e:	613b      	str	r3, [r7, #16]
          > nb->len
 801c020:	687b      	ldr	r3, [r7, #4]
 801c022:	895b      	ldrh	r3, [r3, #10]
 801c024:	001a      	movs	r2, r3
      || (hlen += TCPH_HDRLEN_BYTES((struct tcp_hdr *)&((char *)ip)[hlen]))
 801c026:	693b      	ldr	r3, [r7, #16]
 801c028:	4293      	cmp	r3, r2
 801c02a:	d802      	bhi.n	801c032 <vj_uncompress_uncomp+0x6e>
      || hlen > MAX_HDR) {
 801c02c:	693b      	ldr	r3, [r7, #16]
 801c02e:	2b80      	cmp	r3, #128	; 0x80
 801c030:	d906      	bls.n	801c040 <vj_uncompress_uncomp+0x7c>
    PPPDEBUG(LOG_INFO, ("vj_uncompress_uncomp: bad cid=%d, hlen=%d buflen=%d\n",
      IPH_PROTO(ip), hlen, nb->len));
    vj_uncompress_err(comp);
 801c032:	683b      	ldr	r3, [r7, #0]
 801c034:	0018      	movs	r0, r3
 801c036:	f7ff ffb5 	bl	801bfa4 <vj_uncompress_err>
    return -1;
 801c03a:	2301      	movs	r3, #1
 801c03c:	425b      	negs	r3, r3
 801c03e:	e029      	b.n	801c094 <vj_uncompress_uncomp+0xd0>
  }
  cs = &comp->rstate[comp->last_recv = IPH_PROTO(ip)];
 801c040:	697b      	ldr	r3, [r7, #20]
 801c042:	7a5a      	ldrb	r2, [r3, #9]
 801c044:	683b      	ldr	r3, [r7, #0]
 801c046:	711a      	strb	r2, [r3, #4]
 801c048:	683b      	ldr	r3, [r7, #0]
 801c04a:	791b      	ldrb	r3, [r3, #4]
 801c04c:	001a      	movs	r2, r3
 801c04e:	0013      	movs	r3, r2
 801c050:	011b      	lsls	r3, r3, #4
 801c052:	189b      	adds	r3, r3, r2
 801c054:	00db      	lsls	r3, r3, #3
 801c056:	4a11      	ldr	r2, [pc, #68]	; (801c09c <vj_uncompress_uncomp+0xd8>)
 801c058:	4694      	mov	ip, r2
 801c05a:	4463      	add	r3, ip
 801c05c:	683a      	ldr	r2, [r7, #0]
 801c05e:	18d3      	adds	r3, r2, r3
 801c060:	3304      	adds	r3, #4
 801c062:	60fb      	str	r3, [r7, #12]
  comp->flags &=~ VJF_TOSS;
 801c064:	683b      	ldr	r3, [r7, #0]
 801c066:	88db      	ldrh	r3, [r3, #6]
 801c068:	2201      	movs	r2, #1
 801c06a:	4393      	bics	r3, r2
 801c06c:	b29a      	uxth	r2, r3
 801c06e:	683b      	ldr	r3, [r7, #0]
 801c070:	80da      	strh	r2, [r3, #6]
  IPH_PROTO_SET(ip, IP_PROTO_TCP);
 801c072:	697b      	ldr	r3, [r7, #20]
 801c074:	2206      	movs	r2, #6
 801c076:	725a      	strb	r2, [r3, #9]
  /* copy from/to bigger buffers checked above instead of cs->cs_ip and ip
     just to help static code analysis to see this is correct ;-) */
  MEMCPY(&cs->cs_hdr, nb->payload, hlen);
 801c078:	68fb      	ldr	r3, [r7, #12]
 801c07a:	3308      	adds	r3, #8
 801c07c:	0018      	movs	r0, r3
 801c07e:	687b      	ldr	r3, [r7, #4]
 801c080:	685b      	ldr	r3, [r3, #4]
 801c082:	693a      	ldr	r2, [r7, #16]
 801c084:	0019      	movs	r1, r3
 801c086:	f000 fdab 	bl	801cbe0 <memcpy>
  cs->cs_hlen = (u16_t)hlen;
 801c08a:	693b      	ldr	r3, [r7, #16]
 801c08c:	b29a      	uxth	r2, r3
 801c08e:	68fb      	ldr	r3, [r7, #12]
 801c090:	809a      	strh	r2, [r3, #4]
  INCR(vjs_uncompressedin);
  return 0;
 801c092:	2300      	movs	r3, #0
}
 801c094:	0018      	movs	r0, r3
 801c096:	46bd      	mov	sp, r7
 801c098:	b006      	add	sp, #24
 801c09a:	bd80      	pop	{r7, pc}
 801c09c:	00000888 	.word	0x00000888

0801c0a0 <vj_uncompress_tcp>:
 * This procedure replaces the compressed header with the uncompressed
 * header and returns the length of the VJ header.
 */
int
vj_uncompress_tcp(struct pbuf **nb, struct vjcompress *comp)
{
 801c0a0:	b590      	push	{r4, r7, lr}
 801c0a2:	b095      	sub	sp, #84	; 0x54
 801c0a4:	af00      	add	r7, sp, #0
 801c0a6:	6078      	str	r0, [r7, #4]
 801c0a8:	6039      	str	r1, [r7, #0]
  u8_t *cp;
  struct tcp_hdr *th;
  struct cstate *cs;
  struct vj_u16_t *bp;
  struct pbuf *n0 = *nb;
 801c0aa:	687b      	ldr	r3, [r7, #4]
 801c0ac:	681b      	ldr	r3, [r3, #0]
 801c0ae:	647b      	str	r3, [r7, #68]	; 0x44
  u32_t tmp;
  u32_t vjlen, hlen, changes;

  INCR(vjs_compressedin);
  cp = (u8_t*)n0->payload;
 801c0b0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c0b2:	685b      	ldr	r3, [r3, #4]
 801c0b4:	64fb      	str	r3, [r7, #76]	; 0x4c
  changes = *cp++;
 801c0b6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c0b8:	1c5a      	adds	r2, r3, #1
 801c0ba:	64fa      	str	r2, [r7, #76]	; 0x4c
 801c0bc:	781b      	ldrb	r3, [r3, #0]
 801c0be:	63bb      	str	r3, [r7, #56]	; 0x38
  if (changes & NEW_C) {
 801c0c0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c0c2:	2240      	movs	r2, #64	; 0x40
 801c0c4:	4013      	ands	r3, r2
 801c0c6:	d013      	beq.n	801c0f0 <vj_uncompress_tcp+0x50>
    /*
     * Make sure the state index is in range, then grab the state.
     * If we have a good state index, clear the 'discard' flag.
     */
    if (*cp >= MAX_SLOTS) {
 801c0c8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c0ca:	781b      	ldrb	r3, [r3, #0]
 801c0cc:	2b0f      	cmp	r3, #15
 801c0ce:	d901      	bls.n	801c0d4 <vj_uncompress_tcp+0x34>
 801c0d0:	f000 fd00 	bl	801cad4 <vj_uncompress_tcp+0xa34>
      PPPDEBUG(LOG_INFO, ("vj_uncompress_tcp: bad cid=%d\n", *cp));
      goto bad;
    }

    comp->flags &=~ VJF_TOSS;
 801c0d4:	683b      	ldr	r3, [r7, #0]
 801c0d6:	88db      	ldrh	r3, [r3, #6]
 801c0d8:	2201      	movs	r2, #1
 801c0da:	4393      	bics	r3, r2
 801c0dc:	b29a      	uxth	r2, r3
 801c0de:	683b      	ldr	r3, [r7, #0]
 801c0e0:	80da      	strh	r2, [r3, #6]
    comp->last_recv = *cp++;
 801c0e2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c0e4:	1c5a      	adds	r2, r3, #1
 801c0e6:	64fa      	str	r2, [r7, #76]	; 0x4c
 801c0e8:	781a      	ldrb	r2, [r3, #0]
 801c0ea:	683b      	ldr	r3, [r7, #0]
 801c0ec:	711a      	strb	r2, [r3, #4]
 801c0ee:	e009      	b.n	801c104 <vj_uncompress_tcp+0x64>
    /*
     * this packet has an implicit state index.  If we've
     * had a line error since the last time we got an
     * explicit state index, we have to toss the packet.
     */
    if (comp->flags & VJF_TOSS) {
 801c0f0:	683b      	ldr	r3, [r7, #0]
 801c0f2:	88db      	ldrh	r3, [r3, #6]
 801c0f4:	001a      	movs	r2, r3
 801c0f6:	2301      	movs	r3, #1
 801c0f8:	4013      	ands	r3, r2
 801c0fa:	d003      	beq.n	801c104 <vj_uncompress_tcp+0x64>
      PPPDEBUG(LOG_INFO, ("vj_uncompress_tcp: tossing\n"));
      INCR(vjs_tossed);
      return (-1);
 801c0fc:	2301      	movs	r3, #1
 801c0fe:	425b      	negs	r3, r3
 801c100:	f000 fcf5 	bl	801caee <vj_uncompress_tcp+0xa4e>
    }
  }
  cs = &comp->rstate[comp->last_recv];
 801c104:	683b      	ldr	r3, [r7, #0]
 801c106:	791b      	ldrb	r3, [r3, #4]
 801c108:	001a      	movs	r2, r3
 801c10a:	0013      	movs	r3, r2
 801c10c:	011b      	lsls	r3, r3, #4
 801c10e:	189b      	adds	r3, r3, r2
 801c110:	00db      	lsls	r3, r3, #3
 801c112:	4ae9      	ldr	r2, [pc, #932]	; (801c4b8 <vj_uncompress_tcp+0x418>)
 801c114:	4694      	mov	ip, r2
 801c116:	4463      	add	r3, ip
 801c118:	683a      	ldr	r2, [r7, #0]
 801c11a:	18d3      	adds	r3, r2, r3
 801c11c:	3304      	adds	r3, #4
 801c11e:	637b      	str	r3, [r7, #52]	; 0x34
  hlen = IPH_HL(&cs->cs_ip) << 2;
 801c120:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c122:	7a1b      	ldrb	r3, [r3, #8]
 801c124:	009b      	lsls	r3, r3, #2
 801c126:	001a      	movs	r2, r3
 801c128:	233c      	movs	r3, #60	; 0x3c
 801c12a:	4013      	ands	r3, r2
 801c12c:	63fb      	str	r3, [r7, #60]	; 0x3c
  th = (struct tcp_hdr *)&((u8_t*)&cs->cs_ip)[hlen];
 801c12e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c130:	3308      	adds	r3, #8
 801c132:	001a      	movs	r2, r3
 801c134:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c136:	18d3      	adds	r3, r2, r3
 801c138:	633b      	str	r3, [r7, #48]	; 0x30
  th->chksum = lwip_htons((*cp << 8) | cp[1]);
 801c13a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c13c:	781b      	ldrb	r3, [r3, #0]
 801c13e:	021b      	lsls	r3, r3, #8
 801c140:	b21a      	sxth	r2, r3
 801c142:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c144:	3301      	adds	r3, #1
 801c146:	781b      	ldrb	r3, [r3, #0]
 801c148:	b21b      	sxth	r3, r3
 801c14a:	4313      	orrs	r3, r2
 801c14c:	b21b      	sxth	r3, r3
 801c14e:	b29b      	uxth	r3, r3
 801c150:	0018      	movs	r0, r3
 801c152:	f7ea fd59 	bl	8006c08 <lwip_htons>
 801c156:	0003      	movs	r3, r0
 801c158:	001a      	movs	r2, r3
 801c15a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c15c:	21ff      	movs	r1, #255	; 0xff
 801c15e:	4011      	ands	r1, r2
 801c160:	000c      	movs	r4, r1
 801c162:	7c19      	ldrb	r1, [r3, #16]
 801c164:	2000      	movs	r0, #0
 801c166:	4001      	ands	r1, r0
 801c168:	1c08      	adds	r0, r1, #0
 801c16a:	1c21      	adds	r1, r4, #0
 801c16c:	4301      	orrs	r1, r0
 801c16e:	7419      	strb	r1, [r3, #16]
 801c170:	0a12      	lsrs	r2, r2, #8
 801c172:	b290      	uxth	r0, r2
 801c174:	7c5a      	ldrb	r2, [r3, #17]
 801c176:	2100      	movs	r1, #0
 801c178:	400a      	ands	r2, r1
 801c17a:	1c11      	adds	r1, r2, #0
 801c17c:	1c02      	adds	r2, r0, #0
 801c17e:	430a      	orrs	r2, r1
 801c180:	745a      	strb	r2, [r3, #17]
  cp += 2;
 801c182:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c184:	3302      	adds	r3, #2
 801c186:	64fb      	str	r3, [r7, #76]	; 0x4c
  if (changes & TCP_PUSH_BIT) {
 801c188:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c18a:	2210      	movs	r2, #16
 801c18c:	4013      	ands	r3, r2
 801c18e:	d020      	beq.n	801c1d2 <vj_uncompress_tcp+0x132>
    TCPH_SET_FLAG(th, TCP_PSH);
 801c190:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c192:	7b1a      	ldrb	r2, [r3, #12]
 801c194:	7b5b      	ldrb	r3, [r3, #13]
 801c196:	021b      	lsls	r3, r3, #8
 801c198:	4313      	orrs	r3, r2
 801c19a:	b29c      	uxth	r4, r3
 801c19c:	2008      	movs	r0, #8
 801c19e:	f7ea fd33 	bl	8006c08 <lwip_htons>
 801c1a2:	0003      	movs	r3, r0
 801c1a4:	4323      	orrs	r3, r4
 801c1a6:	b29a      	uxth	r2, r3
 801c1a8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c1aa:	21ff      	movs	r1, #255	; 0xff
 801c1ac:	4011      	ands	r1, r2
 801c1ae:	000c      	movs	r4, r1
 801c1b0:	7b19      	ldrb	r1, [r3, #12]
 801c1b2:	2000      	movs	r0, #0
 801c1b4:	4001      	ands	r1, r0
 801c1b6:	1c08      	adds	r0, r1, #0
 801c1b8:	1c21      	adds	r1, r4, #0
 801c1ba:	4301      	orrs	r1, r0
 801c1bc:	7319      	strb	r1, [r3, #12]
 801c1be:	0a12      	lsrs	r2, r2, #8
 801c1c0:	b290      	uxth	r0, r2
 801c1c2:	7b5a      	ldrb	r2, [r3, #13]
 801c1c4:	2100      	movs	r1, #0
 801c1c6:	400a      	ands	r2, r1
 801c1c8:	1c11      	adds	r1, r2, #0
 801c1ca:	1c02      	adds	r2, r0, #0
 801c1cc:	430a      	orrs	r2, r1
 801c1ce:	735a      	strb	r2, [r3, #13]
 801c1d0:	e024      	b.n	801c21c <vj_uncompress_tcp+0x17c>
  } else {
    TCPH_UNSET_FLAG(th, TCP_PSH);
 801c1d2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c1d4:	7b1a      	ldrb	r2, [r3, #12]
 801c1d6:	7b5b      	ldrb	r3, [r3, #13]
 801c1d8:	021b      	lsls	r3, r3, #8
 801c1da:	4313      	orrs	r3, r2
 801c1dc:	b29b      	uxth	r3, r3
 801c1de:	b21c      	sxth	r4, r3
 801c1e0:	2008      	movs	r0, #8
 801c1e2:	f7ea fd11 	bl	8006c08 <lwip_htons>
 801c1e6:	0003      	movs	r3, r0
 801c1e8:	b21b      	sxth	r3, r3
 801c1ea:	43db      	mvns	r3, r3
 801c1ec:	b21b      	sxth	r3, r3
 801c1ee:	4023      	ands	r3, r4
 801c1f0:	b21b      	sxth	r3, r3
 801c1f2:	b29a      	uxth	r2, r3
 801c1f4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c1f6:	21ff      	movs	r1, #255	; 0xff
 801c1f8:	4011      	ands	r1, r2
 801c1fa:	000c      	movs	r4, r1
 801c1fc:	7b19      	ldrb	r1, [r3, #12]
 801c1fe:	2000      	movs	r0, #0
 801c200:	4001      	ands	r1, r0
 801c202:	1c08      	adds	r0, r1, #0
 801c204:	1c21      	adds	r1, r4, #0
 801c206:	4301      	orrs	r1, r0
 801c208:	7319      	strb	r1, [r3, #12]
 801c20a:	0a12      	lsrs	r2, r2, #8
 801c20c:	b290      	uxth	r0, r2
 801c20e:	7b5a      	ldrb	r2, [r3, #13]
 801c210:	2100      	movs	r1, #0
 801c212:	400a      	ands	r2, r1
 801c214:	1c11      	adds	r1, r2, #0
 801c216:	1c02      	adds	r2, r0, #0
 801c218:	430a      	orrs	r2, r1
 801c21a:	735a      	strb	r2, [r3, #13]
  }

  switch (changes & SPECIALS_MASK) {
 801c21c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c21e:	220f      	movs	r2, #15
 801c220:	4013      	ands	r3, r2
 801c222:	2b0b      	cmp	r3, #11
 801c224:	d003      	beq.n	801c22e <vj_uncompress_tcp+0x18e>
 801c226:	2b0f      	cmp	r3, #15
 801c228:	d100      	bne.n	801c22c <vj_uncompress_tcp+0x18c>
 801c22a:	e08c      	b.n	801c346 <vj_uncompress_tcp+0x2a6>
 801c22c:	e0d4      	b.n	801c3d8 <vj_uncompress_tcp+0x338>
  case SPECIAL_I:
    {
      u32_t i = lwip_ntohs(IPH_LEN(&cs->cs_ip)) - cs->cs_hlen;
 801c22e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c230:	895b      	ldrh	r3, [r3, #10]
 801c232:	0018      	movs	r0, r3
 801c234:	f7ea fce8 	bl	8006c08 <lwip_htons>
 801c238:	0003      	movs	r3, r0
 801c23a:	001a      	movs	r2, r3
 801c23c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c23e:	889b      	ldrh	r3, [r3, #4]
 801c240:	1ad3      	subs	r3, r2, r3
 801c242:	62fb      	str	r3, [r7, #44]	; 0x2c
      /* some compilers can't nest inline assembler.. */
      tmp = lwip_ntohl(th->ackno) + i;
 801c244:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c246:	7a1a      	ldrb	r2, [r3, #8]
 801c248:	7a59      	ldrb	r1, [r3, #9]
 801c24a:	0209      	lsls	r1, r1, #8
 801c24c:	430a      	orrs	r2, r1
 801c24e:	7a99      	ldrb	r1, [r3, #10]
 801c250:	0409      	lsls	r1, r1, #16
 801c252:	430a      	orrs	r2, r1
 801c254:	7adb      	ldrb	r3, [r3, #11]
 801c256:	061b      	lsls	r3, r3, #24
 801c258:	4313      	orrs	r3, r2
 801c25a:	0018      	movs	r0, r3
 801c25c:	f7ea fcea 	bl	8006c34 <lwip_htonl>
 801c260:	0002      	movs	r2, r0
 801c262:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801c264:	189b      	adds	r3, r3, r2
 801c266:	643b      	str	r3, [r7, #64]	; 0x40
      th->ackno = lwip_htonl(tmp);
 801c268:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c26a:	0018      	movs	r0, r3
 801c26c:	f7ea fce2 	bl	8006c34 <lwip_htonl>
 801c270:	0002      	movs	r2, r0
 801c272:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c274:	21ff      	movs	r1, #255	; 0xff
 801c276:	4011      	ands	r1, r2
 801c278:	000c      	movs	r4, r1
 801c27a:	7a19      	ldrb	r1, [r3, #8]
 801c27c:	2000      	movs	r0, #0
 801c27e:	4001      	ands	r1, r0
 801c280:	1c08      	adds	r0, r1, #0
 801c282:	1c21      	adds	r1, r4, #0
 801c284:	4301      	orrs	r1, r0
 801c286:	7219      	strb	r1, [r3, #8]
 801c288:	0a11      	lsrs	r1, r2, #8
 801c28a:	20ff      	movs	r0, #255	; 0xff
 801c28c:	4001      	ands	r1, r0
 801c28e:	000c      	movs	r4, r1
 801c290:	7a59      	ldrb	r1, [r3, #9]
 801c292:	2000      	movs	r0, #0
 801c294:	4001      	ands	r1, r0
 801c296:	1c08      	adds	r0, r1, #0
 801c298:	1c21      	adds	r1, r4, #0
 801c29a:	4301      	orrs	r1, r0
 801c29c:	7259      	strb	r1, [r3, #9]
 801c29e:	0c11      	lsrs	r1, r2, #16
 801c2a0:	20ff      	movs	r0, #255	; 0xff
 801c2a2:	4001      	ands	r1, r0
 801c2a4:	000c      	movs	r4, r1
 801c2a6:	7a99      	ldrb	r1, [r3, #10]
 801c2a8:	2000      	movs	r0, #0
 801c2aa:	4001      	ands	r1, r0
 801c2ac:	1c08      	adds	r0, r1, #0
 801c2ae:	1c21      	adds	r1, r4, #0
 801c2b0:	4301      	orrs	r1, r0
 801c2b2:	7299      	strb	r1, [r3, #10]
 801c2b4:	0e10      	lsrs	r0, r2, #24
 801c2b6:	7ada      	ldrb	r2, [r3, #11]
 801c2b8:	2100      	movs	r1, #0
 801c2ba:	400a      	ands	r2, r1
 801c2bc:	1c11      	adds	r1, r2, #0
 801c2be:	1c02      	adds	r2, r0, #0
 801c2c0:	430a      	orrs	r2, r1
 801c2c2:	72da      	strb	r2, [r3, #11]
      tmp = lwip_ntohl(th->seqno) + i;
 801c2c4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c2c6:	791a      	ldrb	r2, [r3, #4]
 801c2c8:	7959      	ldrb	r1, [r3, #5]
 801c2ca:	0209      	lsls	r1, r1, #8
 801c2cc:	430a      	orrs	r2, r1
 801c2ce:	7999      	ldrb	r1, [r3, #6]
 801c2d0:	0409      	lsls	r1, r1, #16
 801c2d2:	430a      	orrs	r2, r1
 801c2d4:	79db      	ldrb	r3, [r3, #7]
 801c2d6:	061b      	lsls	r3, r3, #24
 801c2d8:	4313      	orrs	r3, r2
 801c2da:	0018      	movs	r0, r3
 801c2dc:	f7ea fcaa 	bl	8006c34 <lwip_htonl>
 801c2e0:	0002      	movs	r2, r0
 801c2e2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801c2e4:	189b      	adds	r3, r3, r2
 801c2e6:	643b      	str	r3, [r7, #64]	; 0x40
      th->seqno = lwip_htonl(tmp);
 801c2e8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c2ea:	0018      	movs	r0, r3
 801c2ec:	f7ea fca2 	bl	8006c34 <lwip_htonl>
 801c2f0:	0002      	movs	r2, r0
 801c2f2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c2f4:	21ff      	movs	r1, #255	; 0xff
 801c2f6:	4011      	ands	r1, r2
 801c2f8:	000c      	movs	r4, r1
 801c2fa:	7919      	ldrb	r1, [r3, #4]
 801c2fc:	2000      	movs	r0, #0
 801c2fe:	4001      	ands	r1, r0
 801c300:	1c08      	adds	r0, r1, #0
 801c302:	1c21      	adds	r1, r4, #0
 801c304:	4301      	orrs	r1, r0
 801c306:	7119      	strb	r1, [r3, #4]
 801c308:	0a11      	lsrs	r1, r2, #8
 801c30a:	20ff      	movs	r0, #255	; 0xff
 801c30c:	4001      	ands	r1, r0
 801c30e:	000c      	movs	r4, r1
 801c310:	7959      	ldrb	r1, [r3, #5]
 801c312:	2000      	movs	r0, #0
 801c314:	4001      	ands	r1, r0
 801c316:	1c08      	adds	r0, r1, #0
 801c318:	1c21      	adds	r1, r4, #0
 801c31a:	4301      	orrs	r1, r0
 801c31c:	7159      	strb	r1, [r3, #5]
 801c31e:	0c11      	lsrs	r1, r2, #16
 801c320:	20ff      	movs	r0, #255	; 0xff
 801c322:	4001      	ands	r1, r0
 801c324:	000c      	movs	r4, r1
 801c326:	7999      	ldrb	r1, [r3, #6]
 801c328:	2000      	movs	r0, #0
 801c32a:	4001      	ands	r1, r0
 801c32c:	1c08      	adds	r0, r1, #0
 801c32e:	1c21      	adds	r1, r4, #0
 801c330:	4301      	orrs	r1, r0
 801c332:	7199      	strb	r1, [r3, #6]
 801c334:	0e10      	lsrs	r0, r2, #24
 801c336:	79da      	ldrb	r2, [r3, #7]
 801c338:	2100      	movs	r1, #0
 801c33a:	400a      	ands	r2, r1
 801c33c:	1c11      	adds	r1, r2, #0
 801c33e:	1c02      	adds	r2, r0, #0
 801c340:	430a      	orrs	r2, r1
 801c342:	71da      	strb	r2, [r3, #7]
    }
    break;
 801c344:	e27f      	b.n	801c846 <vj_uncompress_tcp+0x7a6>

  case SPECIAL_D:
    /* some compilers can't nest inline assembler.. */
    tmp = lwip_ntohl(th->seqno) + lwip_ntohs(IPH_LEN(&cs->cs_ip)) - cs->cs_hlen;
 801c346:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c348:	791a      	ldrb	r2, [r3, #4]
 801c34a:	7959      	ldrb	r1, [r3, #5]
 801c34c:	0209      	lsls	r1, r1, #8
 801c34e:	430a      	orrs	r2, r1
 801c350:	7999      	ldrb	r1, [r3, #6]
 801c352:	0409      	lsls	r1, r1, #16
 801c354:	430a      	orrs	r2, r1
 801c356:	79db      	ldrb	r3, [r3, #7]
 801c358:	061b      	lsls	r3, r3, #24
 801c35a:	4313      	orrs	r3, r2
 801c35c:	0018      	movs	r0, r3
 801c35e:	f7ea fc69 	bl	8006c34 <lwip_htonl>
 801c362:	0004      	movs	r4, r0
 801c364:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c366:	895b      	ldrh	r3, [r3, #10]
 801c368:	0018      	movs	r0, r3
 801c36a:	f7ea fc4d 	bl	8006c08 <lwip_htons>
 801c36e:	0003      	movs	r3, r0
 801c370:	18e3      	adds	r3, r4, r3
 801c372:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801c374:	8892      	ldrh	r2, [r2, #4]
 801c376:	1a9b      	subs	r3, r3, r2
 801c378:	643b      	str	r3, [r7, #64]	; 0x40
    th->seqno = lwip_htonl(tmp);
 801c37a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c37c:	0018      	movs	r0, r3
 801c37e:	f7ea fc59 	bl	8006c34 <lwip_htonl>
 801c382:	0002      	movs	r2, r0
 801c384:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c386:	21ff      	movs	r1, #255	; 0xff
 801c388:	4011      	ands	r1, r2
 801c38a:	000c      	movs	r4, r1
 801c38c:	7919      	ldrb	r1, [r3, #4]
 801c38e:	2000      	movs	r0, #0
 801c390:	4001      	ands	r1, r0
 801c392:	1c08      	adds	r0, r1, #0
 801c394:	1c21      	adds	r1, r4, #0
 801c396:	4301      	orrs	r1, r0
 801c398:	7119      	strb	r1, [r3, #4]
 801c39a:	0a11      	lsrs	r1, r2, #8
 801c39c:	20ff      	movs	r0, #255	; 0xff
 801c39e:	4001      	ands	r1, r0
 801c3a0:	000c      	movs	r4, r1
 801c3a2:	7959      	ldrb	r1, [r3, #5]
 801c3a4:	2000      	movs	r0, #0
 801c3a6:	4001      	ands	r1, r0
 801c3a8:	1c08      	adds	r0, r1, #0
 801c3aa:	1c21      	adds	r1, r4, #0
 801c3ac:	4301      	orrs	r1, r0
 801c3ae:	7159      	strb	r1, [r3, #5]
 801c3b0:	0c11      	lsrs	r1, r2, #16
 801c3b2:	20ff      	movs	r0, #255	; 0xff
 801c3b4:	4001      	ands	r1, r0
 801c3b6:	000c      	movs	r4, r1
 801c3b8:	7999      	ldrb	r1, [r3, #6]
 801c3ba:	2000      	movs	r0, #0
 801c3bc:	4001      	ands	r1, r0
 801c3be:	1c08      	adds	r0, r1, #0
 801c3c0:	1c21      	adds	r1, r4, #0
 801c3c2:	4301      	orrs	r1, r0
 801c3c4:	7199      	strb	r1, [r3, #6]
 801c3c6:	0e10      	lsrs	r0, r2, #24
 801c3c8:	79da      	ldrb	r2, [r3, #7]
 801c3ca:	2100      	movs	r1, #0
 801c3cc:	400a      	ands	r2, r1
 801c3ce:	1c11      	adds	r1, r2, #0
 801c3d0:	1c02      	adds	r2, r0, #0
 801c3d2:	430a      	orrs	r2, r1
 801c3d4:	71da      	strb	r2, [r3, #7]
    break;
 801c3d6:	e236      	b.n	801c846 <vj_uncompress_tcp+0x7a6>

  default:
    if (changes & NEW_U) {
 801c3d8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c3da:	2201      	movs	r2, #1
 801c3dc:	4013      	ands	r3, r2
 801c3de:	d06d      	beq.n	801c4bc <vj_uncompress_tcp+0x41c>
      TCPH_SET_FLAG(th, TCP_URG);
 801c3e0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c3e2:	7b1a      	ldrb	r2, [r3, #12]
 801c3e4:	7b5b      	ldrb	r3, [r3, #13]
 801c3e6:	021b      	lsls	r3, r3, #8
 801c3e8:	4313      	orrs	r3, r2
 801c3ea:	b29c      	uxth	r4, r3
 801c3ec:	2020      	movs	r0, #32
 801c3ee:	f7ea fc0b 	bl	8006c08 <lwip_htons>
 801c3f2:	0003      	movs	r3, r0
 801c3f4:	4323      	orrs	r3, r4
 801c3f6:	b29a      	uxth	r2, r3
 801c3f8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c3fa:	21ff      	movs	r1, #255	; 0xff
 801c3fc:	4011      	ands	r1, r2
 801c3fe:	000c      	movs	r4, r1
 801c400:	7b19      	ldrb	r1, [r3, #12]
 801c402:	2000      	movs	r0, #0
 801c404:	4001      	ands	r1, r0
 801c406:	1c08      	adds	r0, r1, #0
 801c408:	1c21      	adds	r1, r4, #0
 801c40a:	4301      	orrs	r1, r0
 801c40c:	7319      	strb	r1, [r3, #12]
 801c40e:	0a12      	lsrs	r2, r2, #8
 801c410:	b290      	uxth	r0, r2
 801c412:	7b5a      	ldrb	r2, [r3, #13]
 801c414:	2100      	movs	r1, #0
 801c416:	400a      	ands	r2, r1
 801c418:	1c11      	adds	r1, r2, #0
 801c41a:	1c02      	adds	r2, r0, #0
 801c41c:	430a      	orrs	r2, r1
 801c41e:	735a      	strb	r2, [r3, #13]
      DECODEU(th->urgp);
 801c420:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c422:	781b      	ldrb	r3, [r3, #0]
 801c424:	2b00      	cmp	r3, #0
 801c426:	d128      	bne.n	801c47a <vj_uncompress_tcp+0x3da>
 801c428:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c42a:	3301      	adds	r3, #1
 801c42c:	781b      	ldrb	r3, [r3, #0]
 801c42e:	021b      	lsls	r3, r3, #8
 801c430:	b21a      	sxth	r2, r3
 801c432:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c434:	3302      	adds	r3, #2
 801c436:	781b      	ldrb	r3, [r3, #0]
 801c438:	b21b      	sxth	r3, r3
 801c43a:	4313      	orrs	r3, r2
 801c43c:	b21b      	sxth	r3, r3
 801c43e:	b29b      	uxth	r3, r3
 801c440:	0018      	movs	r0, r3
 801c442:	f7ea fbe1 	bl	8006c08 <lwip_htons>
 801c446:	0003      	movs	r3, r0
 801c448:	001a      	movs	r2, r3
 801c44a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c44c:	21ff      	movs	r1, #255	; 0xff
 801c44e:	4011      	ands	r1, r2
 801c450:	000c      	movs	r4, r1
 801c452:	7c99      	ldrb	r1, [r3, #18]
 801c454:	2000      	movs	r0, #0
 801c456:	4001      	ands	r1, r0
 801c458:	1c08      	adds	r0, r1, #0
 801c45a:	1c21      	adds	r1, r4, #0
 801c45c:	4301      	orrs	r1, r0
 801c45e:	7499      	strb	r1, [r3, #18]
 801c460:	0a12      	lsrs	r2, r2, #8
 801c462:	b290      	uxth	r0, r2
 801c464:	7cda      	ldrb	r2, [r3, #19]
 801c466:	2100      	movs	r1, #0
 801c468:	400a      	ands	r2, r1
 801c46a:	1c11      	adds	r1, r2, #0
 801c46c:	1c02      	adds	r2, r0, #0
 801c46e:	430a      	orrs	r2, r1
 801c470:	74da      	strb	r2, [r3, #19]
 801c472:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c474:	3303      	adds	r3, #3
 801c476:	64fb      	str	r3, [r7, #76]	; 0x4c
 801c478:	e045      	b.n	801c506 <vj_uncompress_tcp+0x466>
 801c47a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c47c:	1c5a      	adds	r2, r3, #1
 801c47e:	64fa      	str	r2, [r7, #76]	; 0x4c
 801c480:	781b      	ldrb	r3, [r3, #0]
 801c482:	b29b      	uxth	r3, r3
 801c484:	0018      	movs	r0, r3
 801c486:	f7ea fbbf 	bl	8006c08 <lwip_htons>
 801c48a:	0003      	movs	r3, r0
 801c48c:	001a      	movs	r2, r3
 801c48e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c490:	21ff      	movs	r1, #255	; 0xff
 801c492:	4011      	ands	r1, r2
 801c494:	000c      	movs	r4, r1
 801c496:	7c99      	ldrb	r1, [r3, #18]
 801c498:	2000      	movs	r0, #0
 801c49a:	4001      	ands	r1, r0
 801c49c:	1c08      	adds	r0, r1, #0
 801c49e:	1c21      	adds	r1, r4, #0
 801c4a0:	4301      	orrs	r1, r0
 801c4a2:	7499      	strb	r1, [r3, #18]
 801c4a4:	0a12      	lsrs	r2, r2, #8
 801c4a6:	b290      	uxth	r0, r2
 801c4a8:	7cda      	ldrb	r2, [r3, #19]
 801c4aa:	2100      	movs	r1, #0
 801c4ac:	400a      	ands	r2, r1
 801c4ae:	1c11      	adds	r1, r2, #0
 801c4b0:	1c02      	adds	r2, r0, #0
 801c4b2:	430a      	orrs	r2, r1
 801c4b4:	74da      	strb	r2, [r3, #19]
 801c4b6:	e026      	b.n	801c506 <vj_uncompress_tcp+0x466>
 801c4b8:	00000888 	.word	0x00000888
    } else {
      TCPH_UNSET_FLAG(th, TCP_URG);
 801c4bc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c4be:	7b1a      	ldrb	r2, [r3, #12]
 801c4c0:	7b5b      	ldrb	r3, [r3, #13]
 801c4c2:	021b      	lsls	r3, r3, #8
 801c4c4:	4313      	orrs	r3, r2
 801c4c6:	b29b      	uxth	r3, r3
 801c4c8:	b21c      	sxth	r4, r3
 801c4ca:	2020      	movs	r0, #32
 801c4cc:	f7ea fb9c 	bl	8006c08 <lwip_htons>
 801c4d0:	0003      	movs	r3, r0
 801c4d2:	b21b      	sxth	r3, r3
 801c4d4:	43db      	mvns	r3, r3
 801c4d6:	b21b      	sxth	r3, r3
 801c4d8:	4023      	ands	r3, r4
 801c4da:	b21b      	sxth	r3, r3
 801c4dc:	b29a      	uxth	r2, r3
 801c4de:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c4e0:	21ff      	movs	r1, #255	; 0xff
 801c4e2:	4011      	ands	r1, r2
 801c4e4:	000c      	movs	r4, r1
 801c4e6:	7b19      	ldrb	r1, [r3, #12]
 801c4e8:	2000      	movs	r0, #0
 801c4ea:	4001      	ands	r1, r0
 801c4ec:	1c08      	adds	r0, r1, #0
 801c4ee:	1c21      	adds	r1, r4, #0
 801c4f0:	4301      	orrs	r1, r0
 801c4f2:	7319      	strb	r1, [r3, #12]
 801c4f4:	0a12      	lsrs	r2, r2, #8
 801c4f6:	b290      	uxth	r0, r2
 801c4f8:	7b5a      	ldrb	r2, [r3, #13]
 801c4fa:	2100      	movs	r1, #0
 801c4fc:	400a      	ands	r2, r1
 801c4fe:	1c11      	adds	r1, r2, #0
 801c500:	1c02      	adds	r2, r0, #0
 801c502:	430a      	orrs	r2, r1
 801c504:	735a      	strb	r2, [r3, #13]
    }
    if (changes & NEW_W) {
 801c506:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c508:	2202      	movs	r2, #2
 801c50a:	4013      	ands	r3, r2
 801c50c:	d06c      	beq.n	801c5e8 <vj_uncompress_tcp+0x548>
      DECODES(th->wnd);
 801c50e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c510:	781b      	ldrb	r3, [r3, #0]
 801c512:	2b00      	cmp	r3, #0
 801c514:	d139      	bne.n	801c58a <vj_uncompress_tcp+0x4ea>
 801c516:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c518:	7b9a      	ldrb	r2, [r3, #14]
 801c51a:	7bdb      	ldrb	r3, [r3, #15]
 801c51c:	021b      	lsls	r3, r3, #8
 801c51e:	4313      	orrs	r3, r2
 801c520:	b29b      	uxth	r3, r3
 801c522:	0018      	movs	r0, r3
 801c524:	f7ea fb70 	bl	8006c08 <lwip_htons>
 801c528:	0003      	movs	r3, r0
 801c52a:	0019      	movs	r1, r3
 801c52c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c52e:	3301      	adds	r3, #1
 801c530:	781b      	ldrb	r3, [r3, #0]
 801c532:	021b      	lsls	r3, r3, #8
 801c534:	b21a      	sxth	r2, r3
 801c536:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c538:	3302      	adds	r3, #2
 801c53a:	781b      	ldrb	r3, [r3, #0]
 801c53c:	b21b      	sxth	r3, r3
 801c53e:	4313      	orrs	r3, r2
 801c540:	b21b      	sxth	r3, r3
 801c542:	b29a      	uxth	r2, r3
 801c544:	2028      	movs	r0, #40	; 0x28
 801c546:	183b      	adds	r3, r7, r0
 801c548:	188a      	adds	r2, r1, r2
 801c54a:	801a      	strh	r2, [r3, #0]
 801c54c:	183b      	adds	r3, r7, r0
 801c54e:	881b      	ldrh	r3, [r3, #0]
 801c550:	0018      	movs	r0, r3
 801c552:	f7ea fb59 	bl	8006c08 <lwip_htons>
 801c556:	0003      	movs	r3, r0
 801c558:	001a      	movs	r2, r3
 801c55a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c55c:	21ff      	movs	r1, #255	; 0xff
 801c55e:	4011      	ands	r1, r2
 801c560:	000c      	movs	r4, r1
 801c562:	7b99      	ldrb	r1, [r3, #14]
 801c564:	2000      	movs	r0, #0
 801c566:	4001      	ands	r1, r0
 801c568:	1c08      	adds	r0, r1, #0
 801c56a:	1c21      	adds	r1, r4, #0
 801c56c:	4301      	orrs	r1, r0
 801c56e:	7399      	strb	r1, [r3, #14]
 801c570:	0a12      	lsrs	r2, r2, #8
 801c572:	b290      	uxth	r0, r2
 801c574:	7bda      	ldrb	r2, [r3, #15]
 801c576:	2100      	movs	r1, #0
 801c578:	400a      	ands	r2, r1
 801c57a:	1c11      	adds	r1, r2, #0
 801c57c:	1c02      	adds	r2, r0, #0
 801c57e:	430a      	orrs	r2, r1
 801c580:	73da      	strb	r2, [r3, #15]
 801c582:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c584:	3303      	adds	r3, #3
 801c586:	64fb      	str	r3, [r7, #76]	; 0x4c
 801c588:	e02e      	b.n	801c5e8 <vj_uncompress_tcp+0x548>
 801c58a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c58c:	7b9a      	ldrb	r2, [r3, #14]
 801c58e:	7bdb      	ldrb	r3, [r3, #15]
 801c590:	021b      	lsls	r3, r3, #8
 801c592:	4313      	orrs	r3, r2
 801c594:	b29b      	uxth	r3, r3
 801c596:	0018      	movs	r0, r3
 801c598:	f7ea fb36 	bl	8006c08 <lwip_htons>
 801c59c:	0003      	movs	r3, r0
 801c59e:	0019      	movs	r1, r3
 801c5a0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c5a2:	1c5a      	adds	r2, r3, #1
 801c5a4:	64fa      	str	r2, [r7, #76]	; 0x4c
 801c5a6:	781b      	ldrb	r3, [r3, #0]
 801c5a8:	b29a      	uxth	r2, r3
 801c5aa:	202a      	movs	r0, #42	; 0x2a
 801c5ac:	183b      	adds	r3, r7, r0
 801c5ae:	188a      	adds	r2, r1, r2
 801c5b0:	801a      	strh	r2, [r3, #0]
 801c5b2:	183b      	adds	r3, r7, r0
 801c5b4:	881b      	ldrh	r3, [r3, #0]
 801c5b6:	0018      	movs	r0, r3
 801c5b8:	f7ea fb26 	bl	8006c08 <lwip_htons>
 801c5bc:	0003      	movs	r3, r0
 801c5be:	001a      	movs	r2, r3
 801c5c0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c5c2:	21ff      	movs	r1, #255	; 0xff
 801c5c4:	4011      	ands	r1, r2
 801c5c6:	000c      	movs	r4, r1
 801c5c8:	7b99      	ldrb	r1, [r3, #14]
 801c5ca:	2000      	movs	r0, #0
 801c5cc:	4001      	ands	r1, r0
 801c5ce:	1c08      	adds	r0, r1, #0
 801c5d0:	1c21      	adds	r1, r4, #0
 801c5d2:	4301      	orrs	r1, r0
 801c5d4:	7399      	strb	r1, [r3, #14]
 801c5d6:	0a12      	lsrs	r2, r2, #8
 801c5d8:	b290      	uxth	r0, r2
 801c5da:	7bda      	ldrb	r2, [r3, #15]
 801c5dc:	2100      	movs	r1, #0
 801c5de:	400a      	ands	r2, r1
 801c5e0:	1c11      	adds	r1, r2, #0
 801c5e2:	1c02      	adds	r2, r0, #0
 801c5e4:	430a      	orrs	r2, r1
 801c5e6:	73da      	strb	r2, [r3, #15]
    }
    if (changes & NEW_A) {
 801c5e8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c5ea:	2204      	movs	r2, #4
 801c5ec:	4013      	ands	r3, r2
 801c5ee:	d100      	bne.n	801c5f2 <vj_uncompress_tcp+0x552>
 801c5f0:	e091      	b.n	801c716 <vj_uncompress_tcp+0x676>
      DECODEL(th->ackno);
 801c5f2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c5f4:	781b      	ldrb	r3, [r3, #0]
 801c5f6:	2b00      	cmp	r3, #0
 801c5f8:	d14a      	bne.n	801c690 <vj_uncompress_tcp+0x5f0>
 801c5fa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c5fc:	7a1a      	ldrb	r2, [r3, #8]
 801c5fe:	7a59      	ldrb	r1, [r3, #9]
 801c600:	0209      	lsls	r1, r1, #8
 801c602:	430a      	orrs	r2, r1
 801c604:	7a99      	ldrb	r1, [r3, #10]
 801c606:	0409      	lsls	r1, r1, #16
 801c608:	430a      	orrs	r2, r1
 801c60a:	7adb      	ldrb	r3, [r3, #11]
 801c60c:	061b      	lsls	r3, r3, #24
 801c60e:	4313      	orrs	r3, r2
 801c610:	0018      	movs	r0, r3
 801c612:	f7ea fb0f 	bl	8006c34 <lwip_htonl>
 801c616:	0001      	movs	r1, r0
 801c618:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c61a:	3301      	adds	r3, #1
 801c61c:	781b      	ldrb	r3, [r3, #0]
 801c61e:	021b      	lsls	r3, r3, #8
 801c620:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801c622:	3202      	adds	r2, #2
 801c624:	7812      	ldrb	r2, [r2, #0]
 801c626:	4313      	orrs	r3, r2
 801c628:	18cb      	adds	r3, r1, r3
 801c62a:	623b      	str	r3, [r7, #32]
 801c62c:	6a3b      	ldr	r3, [r7, #32]
 801c62e:	0018      	movs	r0, r3
 801c630:	f7ea fb00 	bl	8006c34 <lwip_htonl>
 801c634:	0002      	movs	r2, r0
 801c636:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c638:	21ff      	movs	r1, #255	; 0xff
 801c63a:	4011      	ands	r1, r2
 801c63c:	000c      	movs	r4, r1
 801c63e:	7a19      	ldrb	r1, [r3, #8]
 801c640:	2000      	movs	r0, #0
 801c642:	4001      	ands	r1, r0
 801c644:	1c08      	adds	r0, r1, #0
 801c646:	1c21      	adds	r1, r4, #0
 801c648:	4301      	orrs	r1, r0
 801c64a:	7219      	strb	r1, [r3, #8]
 801c64c:	0a11      	lsrs	r1, r2, #8
 801c64e:	20ff      	movs	r0, #255	; 0xff
 801c650:	4001      	ands	r1, r0
 801c652:	000c      	movs	r4, r1
 801c654:	7a59      	ldrb	r1, [r3, #9]
 801c656:	2000      	movs	r0, #0
 801c658:	4001      	ands	r1, r0
 801c65a:	1c08      	adds	r0, r1, #0
 801c65c:	1c21      	adds	r1, r4, #0
 801c65e:	4301      	orrs	r1, r0
 801c660:	7259      	strb	r1, [r3, #9]
 801c662:	0c11      	lsrs	r1, r2, #16
 801c664:	20ff      	movs	r0, #255	; 0xff
 801c666:	4001      	ands	r1, r0
 801c668:	000c      	movs	r4, r1
 801c66a:	7a99      	ldrb	r1, [r3, #10]
 801c66c:	2000      	movs	r0, #0
 801c66e:	4001      	ands	r1, r0
 801c670:	1c08      	adds	r0, r1, #0
 801c672:	1c21      	adds	r1, r4, #0
 801c674:	4301      	orrs	r1, r0
 801c676:	7299      	strb	r1, [r3, #10]
 801c678:	0e10      	lsrs	r0, r2, #24
 801c67a:	7ada      	ldrb	r2, [r3, #11]
 801c67c:	2100      	movs	r1, #0
 801c67e:	400a      	ands	r2, r1
 801c680:	1c11      	adds	r1, r2, #0
 801c682:	1c02      	adds	r2, r0, #0
 801c684:	430a      	orrs	r2, r1
 801c686:	72da      	strb	r2, [r3, #11]
 801c688:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c68a:	3303      	adds	r3, #3
 801c68c:	64fb      	str	r3, [r7, #76]	; 0x4c
 801c68e:	e042      	b.n	801c716 <vj_uncompress_tcp+0x676>
 801c690:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c692:	7a1a      	ldrb	r2, [r3, #8]
 801c694:	7a59      	ldrb	r1, [r3, #9]
 801c696:	0209      	lsls	r1, r1, #8
 801c698:	430a      	orrs	r2, r1
 801c69a:	7a99      	ldrb	r1, [r3, #10]
 801c69c:	0409      	lsls	r1, r1, #16
 801c69e:	430a      	orrs	r2, r1
 801c6a0:	7adb      	ldrb	r3, [r3, #11]
 801c6a2:	061b      	lsls	r3, r3, #24
 801c6a4:	4313      	orrs	r3, r2
 801c6a6:	0018      	movs	r0, r3
 801c6a8:	f7ea fac4 	bl	8006c34 <lwip_htonl>
 801c6ac:	0001      	movs	r1, r0
 801c6ae:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c6b0:	1c5a      	adds	r2, r3, #1
 801c6b2:	64fa      	str	r2, [r7, #76]	; 0x4c
 801c6b4:	781b      	ldrb	r3, [r3, #0]
 801c6b6:	18cb      	adds	r3, r1, r3
 801c6b8:	627b      	str	r3, [r7, #36]	; 0x24
 801c6ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c6bc:	0018      	movs	r0, r3
 801c6be:	f7ea fab9 	bl	8006c34 <lwip_htonl>
 801c6c2:	0002      	movs	r2, r0
 801c6c4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c6c6:	21ff      	movs	r1, #255	; 0xff
 801c6c8:	4011      	ands	r1, r2
 801c6ca:	000c      	movs	r4, r1
 801c6cc:	7a19      	ldrb	r1, [r3, #8]
 801c6ce:	2000      	movs	r0, #0
 801c6d0:	4001      	ands	r1, r0
 801c6d2:	1c08      	adds	r0, r1, #0
 801c6d4:	1c21      	adds	r1, r4, #0
 801c6d6:	4301      	orrs	r1, r0
 801c6d8:	7219      	strb	r1, [r3, #8]
 801c6da:	0a11      	lsrs	r1, r2, #8
 801c6dc:	20ff      	movs	r0, #255	; 0xff
 801c6de:	4001      	ands	r1, r0
 801c6e0:	000c      	movs	r4, r1
 801c6e2:	7a59      	ldrb	r1, [r3, #9]
 801c6e4:	2000      	movs	r0, #0
 801c6e6:	4001      	ands	r1, r0
 801c6e8:	1c08      	adds	r0, r1, #0
 801c6ea:	1c21      	adds	r1, r4, #0
 801c6ec:	4301      	orrs	r1, r0
 801c6ee:	7259      	strb	r1, [r3, #9]
 801c6f0:	0c11      	lsrs	r1, r2, #16
 801c6f2:	20ff      	movs	r0, #255	; 0xff
 801c6f4:	4001      	ands	r1, r0
 801c6f6:	000c      	movs	r4, r1
 801c6f8:	7a99      	ldrb	r1, [r3, #10]
 801c6fa:	2000      	movs	r0, #0
 801c6fc:	4001      	ands	r1, r0
 801c6fe:	1c08      	adds	r0, r1, #0
 801c700:	1c21      	adds	r1, r4, #0
 801c702:	4301      	orrs	r1, r0
 801c704:	7299      	strb	r1, [r3, #10]
 801c706:	0e10      	lsrs	r0, r2, #24
 801c708:	7ada      	ldrb	r2, [r3, #11]
 801c70a:	2100      	movs	r1, #0
 801c70c:	400a      	ands	r2, r1
 801c70e:	1c11      	adds	r1, r2, #0
 801c710:	1c02      	adds	r2, r0, #0
 801c712:	430a      	orrs	r2, r1
 801c714:	72da      	strb	r2, [r3, #11]
    }
    if (changes & NEW_S) {
 801c716:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c718:	2208      	movs	r2, #8
 801c71a:	4013      	ands	r3, r2
 801c71c:	d100      	bne.n	801c720 <vj_uncompress_tcp+0x680>
 801c71e:	e091      	b.n	801c844 <vj_uncompress_tcp+0x7a4>

    	DECODEL(th->seqno);
 801c720:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c722:	781b      	ldrb	r3, [r3, #0]
 801c724:	2b00      	cmp	r3, #0
 801c726:	d14a      	bne.n	801c7be <vj_uncompress_tcp+0x71e>
 801c728:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c72a:	791a      	ldrb	r2, [r3, #4]
 801c72c:	7959      	ldrb	r1, [r3, #5]
 801c72e:	0209      	lsls	r1, r1, #8
 801c730:	430a      	orrs	r2, r1
 801c732:	7999      	ldrb	r1, [r3, #6]
 801c734:	0409      	lsls	r1, r1, #16
 801c736:	430a      	orrs	r2, r1
 801c738:	79db      	ldrb	r3, [r3, #7]
 801c73a:	061b      	lsls	r3, r3, #24
 801c73c:	4313      	orrs	r3, r2
 801c73e:	0018      	movs	r0, r3
 801c740:	f7ea fa78 	bl	8006c34 <lwip_htonl>
 801c744:	0001      	movs	r1, r0
 801c746:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c748:	3301      	adds	r3, #1
 801c74a:	781b      	ldrb	r3, [r3, #0]
 801c74c:	021b      	lsls	r3, r3, #8
 801c74e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801c750:	3202      	adds	r2, #2
 801c752:	7812      	ldrb	r2, [r2, #0]
 801c754:	4313      	orrs	r3, r2
 801c756:	18cb      	adds	r3, r1, r3
 801c758:	61bb      	str	r3, [r7, #24]
 801c75a:	69bb      	ldr	r3, [r7, #24]
 801c75c:	0018      	movs	r0, r3
 801c75e:	f7ea fa69 	bl	8006c34 <lwip_htonl>
 801c762:	0002      	movs	r2, r0
 801c764:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c766:	21ff      	movs	r1, #255	; 0xff
 801c768:	4011      	ands	r1, r2
 801c76a:	000c      	movs	r4, r1
 801c76c:	7919      	ldrb	r1, [r3, #4]
 801c76e:	2000      	movs	r0, #0
 801c770:	4001      	ands	r1, r0
 801c772:	1c08      	adds	r0, r1, #0
 801c774:	1c21      	adds	r1, r4, #0
 801c776:	4301      	orrs	r1, r0
 801c778:	7119      	strb	r1, [r3, #4]
 801c77a:	0a11      	lsrs	r1, r2, #8
 801c77c:	20ff      	movs	r0, #255	; 0xff
 801c77e:	4001      	ands	r1, r0
 801c780:	000c      	movs	r4, r1
 801c782:	7959      	ldrb	r1, [r3, #5]
 801c784:	2000      	movs	r0, #0
 801c786:	4001      	ands	r1, r0
 801c788:	1c08      	adds	r0, r1, #0
 801c78a:	1c21      	adds	r1, r4, #0
 801c78c:	4301      	orrs	r1, r0
 801c78e:	7159      	strb	r1, [r3, #5]
 801c790:	0c11      	lsrs	r1, r2, #16
 801c792:	20ff      	movs	r0, #255	; 0xff
 801c794:	4001      	ands	r1, r0
 801c796:	000c      	movs	r4, r1
 801c798:	7999      	ldrb	r1, [r3, #6]
 801c79a:	2000      	movs	r0, #0
 801c79c:	4001      	ands	r1, r0
 801c79e:	1c08      	adds	r0, r1, #0
 801c7a0:	1c21      	adds	r1, r4, #0
 801c7a2:	4301      	orrs	r1, r0
 801c7a4:	7199      	strb	r1, [r3, #6]
 801c7a6:	0e10      	lsrs	r0, r2, #24
 801c7a8:	79da      	ldrb	r2, [r3, #7]
 801c7aa:	2100      	movs	r1, #0
 801c7ac:	400a      	ands	r2, r1
 801c7ae:	1c11      	adds	r1, r2, #0
 801c7b0:	1c02      	adds	r2, r0, #0
 801c7b2:	430a      	orrs	r2, r1
 801c7b4:	71da      	strb	r2, [r3, #7]
 801c7b6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c7b8:	3303      	adds	r3, #3
 801c7ba:	64fb      	str	r3, [r7, #76]	; 0x4c
    }
    break;
 801c7bc:	e042      	b.n	801c844 <vj_uncompress_tcp+0x7a4>
    	DECODEL(th->seqno);
 801c7be:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c7c0:	791a      	ldrb	r2, [r3, #4]
 801c7c2:	7959      	ldrb	r1, [r3, #5]
 801c7c4:	0209      	lsls	r1, r1, #8
 801c7c6:	430a      	orrs	r2, r1
 801c7c8:	7999      	ldrb	r1, [r3, #6]
 801c7ca:	0409      	lsls	r1, r1, #16
 801c7cc:	430a      	orrs	r2, r1
 801c7ce:	79db      	ldrb	r3, [r3, #7]
 801c7d0:	061b      	lsls	r3, r3, #24
 801c7d2:	4313      	orrs	r3, r2
 801c7d4:	0018      	movs	r0, r3
 801c7d6:	f7ea fa2d 	bl	8006c34 <lwip_htonl>
 801c7da:	0001      	movs	r1, r0
 801c7dc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c7de:	1c5a      	adds	r2, r3, #1
 801c7e0:	64fa      	str	r2, [r7, #76]	; 0x4c
 801c7e2:	781b      	ldrb	r3, [r3, #0]
 801c7e4:	18cb      	adds	r3, r1, r3
 801c7e6:	61fb      	str	r3, [r7, #28]
 801c7e8:	69fb      	ldr	r3, [r7, #28]
 801c7ea:	0018      	movs	r0, r3
 801c7ec:	f7ea fa22 	bl	8006c34 <lwip_htonl>
 801c7f0:	0002      	movs	r2, r0
 801c7f2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c7f4:	21ff      	movs	r1, #255	; 0xff
 801c7f6:	4011      	ands	r1, r2
 801c7f8:	000c      	movs	r4, r1
 801c7fa:	7919      	ldrb	r1, [r3, #4]
 801c7fc:	2000      	movs	r0, #0
 801c7fe:	4001      	ands	r1, r0
 801c800:	1c08      	adds	r0, r1, #0
 801c802:	1c21      	adds	r1, r4, #0
 801c804:	4301      	orrs	r1, r0
 801c806:	7119      	strb	r1, [r3, #4]
 801c808:	0a11      	lsrs	r1, r2, #8
 801c80a:	20ff      	movs	r0, #255	; 0xff
 801c80c:	4001      	ands	r1, r0
 801c80e:	000c      	movs	r4, r1
 801c810:	7959      	ldrb	r1, [r3, #5]
 801c812:	2000      	movs	r0, #0
 801c814:	4001      	ands	r1, r0
 801c816:	1c08      	adds	r0, r1, #0
 801c818:	1c21      	adds	r1, r4, #0
 801c81a:	4301      	orrs	r1, r0
 801c81c:	7159      	strb	r1, [r3, #5]
 801c81e:	0c11      	lsrs	r1, r2, #16
 801c820:	20ff      	movs	r0, #255	; 0xff
 801c822:	4001      	ands	r1, r0
 801c824:	000c      	movs	r4, r1
 801c826:	7999      	ldrb	r1, [r3, #6]
 801c828:	2000      	movs	r0, #0
 801c82a:	4001      	ands	r1, r0
 801c82c:	1c08      	adds	r0, r1, #0
 801c82e:	1c21      	adds	r1, r4, #0
 801c830:	4301      	orrs	r1, r0
 801c832:	7199      	strb	r1, [r3, #6]
 801c834:	0e10      	lsrs	r0, r2, #24
 801c836:	79da      	ldrb	r2, [r3, #7]
 801c838:	2100      	movs	r1, #0
 801c83a:	400a      	ands	r2, r1
 801c83c:	1c11      	adds	r1, r2, #0
 801c83e:	1c02      	adds	r2, r0, #0
 801c840:	430a      	orrs	r2, r1
 801c842:	71da      	strb	r2, [r3, #7]
    break;
 801c844:	46c0      	nop			; (mov r8, r8)
  }
  if (changes & NEW_I) {
 801c846:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c848:	2220      	movs	r2, #32
 801c84a:	4013      	ands	r3, r2
 801c84c:	d041      	beq.n	801c8d2 <vj_uncompress_tcp+0x832>
    DECODES(cs->cs_ip._id);
 801c84e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c850:	781b      	ldrb	r3, [r3, #0]
 801c852:	2b00      	cmp	r3, #0
 801c854:	d123      	bne.n	801c89e <vj_uncompress_tcp+0x7fe>
 801c856:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c858:	899b      	ldrh	r3, [r3, #12]
 801c85a:	0018      	movs	r0, r3
 801c85c:	f7ea f9d4 	bl	8006c08 <lwip_htons>
 801c860:	0003      	movs	r3, r0
 801c862:	0019      	movs	r1, r3
 801c864:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c866:	3301      	adds	r3, #1
 801c868:	781b      	ldrb	r3, [r3, #0]
 801c86a:	021b      	lsls	r3, r3, #8
 801c86c:	b21a      	sxth	r2, r3
 801c86e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c870:	3302      	adds	r3, #2
 801c872:	781b      	ldrb	r3, [r3, #0]
 801c874:	b21b      	sxth	r3, r3
 801c876:	4313      	orrs	r3, r2
 801c878:	b21b      	sxth	r3, r3
 801c87a:	b29a      	uxth	r2, r3
 801c87c:	2014      	movs	r0, #20
 801c87e:	183b      	adds	r3, r7, r0
 801c880:	188a      	adds	r2, r1, r2
 801c882:	801a      	strh	r2, [r3, #0]
 801c884:	183b      	adds	r3, r7, r0
 801c886:	881b      	ldrh	r3, [r3, #0]
 801c888:	0018      	movs	r0, r3
 801c88a:	f7ea f9bd 	bl	8006c08 <lwip_htons>
 801c88e:	0003      	movs	r3, r0
 801c890:	001a      	movs	r2, r3
 801c892:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c894:	819a      	strh	r2, [r3, #12]
 801c896:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c898:	3303      	adds	r3, #3
 801c89a:	64fb      	str	r3, [r7, #76]	; 0x4c
 801c89c:	e02c      	b.n	801c8f8 <vj_uncompress_tcp+0x858>
 801c89e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c8a0:	899b      	ldrh	r3, [r3, #12]
 801c8a2:	0018      	movs	r0, r3
 801c8a4:	f7ea f9b0 	bl	8006c08 <lwip_htons>
 801c8a8:	0003      	movs	r3, r0
 801c8aa:	0019      	movs	r1, r3
 801c8ac:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c8ae:	1c5a      	adds	r2, r3, #1
 801c8b0:	64fa      	str	r2, [r7, #76]	; 0x4c
 801c8b2:	781b      	ldrb	r3, [r3, #0]
 801c8b4:	b29a      	uxth	r2, r3
 801c8b6:	2016      	movs	r0, #22
 801c8b8:	183b      	adds	r3, r7, r0
 801c8ba:	188a      	adds	r2, r1, r2
 801c8bc:	801a      	strh	r2, [r3, #0]
 801c8be:	183b      	adds	r3, r7, r0
 801c8c0:	881b      	ldrh	r3, [r3, #0]
 801c8c2:	0018      	movs	r0, r3
 801c8c4:	f7ea f9a0 	bl	8006c08 <lwip_htons>
 801c8c8:	0003      	movs	r3, r0
 801c8ca:	001a      	movs	r2, r3
 801c8cc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c8ce:	819a      	strh	r2, [r3, #12]
 801c8d0:	e012      	b.n	801c8f8 <vj_uncompress_tcp+0x858>
  } else {
    IPH_ID_SET(&cs->cs_ip, lwip_ntohs(IPH_ID(&cs->cs_ip)) + 1);
 801c8d2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c8d4:	899b      	ldrh	r3, [r3, #12]
 801c8d6:	0018      	movs	r0, r3
 801c8d8:	f7ea f996 	bl	8006c08 <lwip_htons>
 801c8dc:	0003      	movs	r3, r0
 801c8de:	3301      	adds	r3, #1
 801c8e0:	b29a      	uxth	r2, r3
 801c8e2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c8e4:	819a      	strh	r2, [r3, #12]
    IPH_ID_SET(&cs->cs_ip, lwip_htons(IPH_ID(&cs->cs_ip)));
 801c8e6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c8e8:	899b      	ldrh	r3, [r3, #12]
 801c8ea:	0018      	movs	r0, r3
 801c8ec:	f7ea f98c 	bl	8006c08 <lwip_htons>
 801c8f0:	0003      	movs	r3, r0
 801c8f2:	001a      	movs	r2, r3
 801c8f4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c8f6:	819a      	strh	r2, [r3, #12]
  /*
   * At this point, cp points to the first byte of data in the
   * packet.  Fill in the IP total length and update the IP
   * header checksum.
   */
  vjlen = (u16_t)(cp - (u8_t*)n0->payload);
 801c8f8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c8fa:	685b      	ldr	r3, [r3, #4]
 801c8fc:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801c8fe:	1ad3      	subs	r3, r2, r3
 801c900:	b29b      	uxth	r3, r3
 801c902:	613b      	str	r3, [r7, #16]
  if (n0->len < vjlen) {
 801c904:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c906:	895b      	ldrh	r3, [r3, #10]
 801c908:	001a      	movs	r2, r3
 801c90a:	693b      	ldr	r3, [r7, #16]
 801c90c:	4293      	cmp	r3, r2
 801c90e:	d900      	bls.n	801c912 <vj_uncompress_tcp+0x872>
 801c910:	e0e2      	b.n	801cad8 <vj_uncompress_tcp+0xa38>
          n0->len, vjlen));
    goto bad;
  }

#if BYTE_ORDER == LITTLE_ENDIAN
  tmp = n0->tot_len - vjlen + cs->cs_hlen;
 801c912:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c914:	891b      	ldrh	r3, [r3, #8]
 801c916:	001a      	movs	r2, r3
 801c918:	693b      	ldr	r3, [r7, #16]
 801c91a:	1ad3      	subs	r3, r2, r3
 801c91c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801c91e:	8892      	ldrh	r2, [r2, #4]
 801c920:	189b      	adds	r3, r3, r2
 801c922:	643b      	str	r3, [r7, #64]	; 0x40
  IPH_LEN_SET(&cs->cs_ip, lwip_htons((u16_t)tmp));
 801c924:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c926:	b29b      	uxth	r3, r3
 801c928:	0018      	movs	r0, r3
 801c92a:	f7ea f96d 	bl	8006c08 <lwip_htons>
 801c92e:	0003      	movs	r3, r0
 801c930:	001a      	movs	r2, r3
 801c932:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c934:	815a      	strh	r2, [r3, #10]
#else
  IPH_LEN_SET(&cs->cs_ip, lwip_htons(n0->tot_len - vjlen + cs->cs_hlen));
#endif

  /* recompute the ip header checksum */
  bp = (struct vj_u16_t*) &cs->cs_ip;
 801c936:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c938:	3308      	adds	r3, #8
 801c93a:	64bb      	str	r3, [r7, #72]	; 0x48
  IPH_CHKSUM_SET(&cs->cs_ip, 0);
 801c93c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c93e:	2200      	movs	r2, #0
 801c940:	825a      	strh	r2, [r3, #18]
  for (tmp = 0; hlen > 0; hlen -= 2) {
 801c942:	2300      	movs	r3, #0
 801c944:	643b      	str	r3, [r7, #64]	; 0x40
 801c946:	e00e      	b.n	801c966 <vj_uncompress_tcp+0x8c6>
    tmp += (*bp++).v;
 801c948:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801c94a:	1c9a      	adds	r2, r3, #2
 801c94c:	64ba      	str	r2, [r7, #72]	; 0x48
 801c94e:	781a      	ldrb	r2, [r3, #0]
 801c950:	785b      	ldrb	r3, [r3, #1]
 801c952:	021b      	lsls	r3, r3, #8
 801c954:	4313      	orrs	r3, r2
 801c956:	b29b      	uxth	r3, r3
 801c958:	001a      	movs	r2, r3
 801c95a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c95c:	189b      	adds	r3, r3, r2
 801c95e:	643b      	str	r3, [r7, #64]	; 0x40
  for (tmp = 0; hlen > 0; hlen -= 2) {
 801c960:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c962:	3b02      	subs	r3, #2
 801c964:	63fb      	str	r3, [r7, #60]	; 0x3c
 801c966:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c968:	2b00      	cmp	r3, #0
 801c96a:	d1ed      	bne.n	801c948 <vj_uncompress_tcp+0x8a8>
  }
  tmp = (tmp & 0xffff) + (tmp >> 16);
 801c96c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c96e:	041b      	lsls	r3, r3, #16
 801c970:	0c1a      	lsrs	r2, r3, #16
 801c972:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c974:	0c1b      	lsrs	r3, r3, #16
 801c976:	18d3      	adds	r3, r2, r3
 801c978:	643b      	str	r3, [r7, #64]	; 0x40
  tmp = (tmp & 0xffff) + (tmp >> 16);
 801c97a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c97c:	041b      	lsls	r3, r3, #16
 801c97e:	0c1a      	lsrs	r2, r3, #16
 801c980:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c982:	0c1b      	lsrs	r3, r3, #16
 801c984:	18d3      	adds	r3, r2, r3
 801c986:	643b      	str	r3, [r7, #64]	; 0x40
  IPH_CHKSUM_SET(&cs->cs_ip,  (u16_t)(~tmp));
 801c988:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c98a:	b29b      	uxth	r3, r3
 801c98c:	43db      	mvns	r3, r3
 801c98e:	b29a      	uxth	r2, r3
 801c990:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c992:	825a      	strh	r2, [r3, #18]

  /* Remove the compressed header and prepend the uncompressed header. */
  if (pbuf_remove_header(n0, vjlen)) {
 801c994:	693a      	ldr	r2, [r7, #16]
 801c996:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c998:	0011      	movs	r1, r2
 801c99a:	0018      	movs	r0, r3
 801c99c:	f7ed f840 	bl	8009a20 <pbuf_remove_header>
 801c9a0:	1e03      	subs	r3, r0, #0
 801c9a2:	d006      	beq.n	801c9b2 <vj_uncompress_tcp+0x912>
    /* Can we cope with this failing?  Just assert for now */
    LWIP_ASSERT("pbuf_remove_header failed\n", 0);
 801c9a4:	4b54      	ldr	r3, [pc, #336]	; (801caf8 <vj_uncompress_tcp+0xa58>)
 801c9a6:	4a55      	ldr	r2, [pc, #340]	; (801cafc <vj_uncompress_tcp+0xa5c>)
 801c9a8:	4955      	ldr	r1, [pc, #340]	; (801cb00 <vj_uncompress_tcp+0xa60>)
 801c9aa:	4856      	ldr	r0, [pc, #344]	; (801cb04 <vj_uncompress_tcp+0xa64>)
 801c9ac:	f7e5 ff96 	bl	80028dc <app_debug_rtt_raw>
    goto bad;
 801c9b0:	e097      	b.n	801cae2 <vj_uncompress_tcp+0xa42>
  }

  if(LWIP_MEM_ALIGN(n0->payload) != n0->payload) {
 801c9b2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c9b4:	685b      	ldr	r3, [r3, #4]
 801c9b6:	3303      	adds	r3, #3
 801c9b8:	2203      	movs	r2, #3
 801c9ba:	4393      	bics	r3, r2
 801c9bc:	001a      	movs	r2, r3
 801c9be:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c9c0:	685b      	ldr	r3, [r3, #4]
 801c9c2:	429a      	cmp	r2, r3
 801c9c4:	d040      	beq.n	801ca48 <vj_uncompress_tcp+0x9a8>
     * the packet is being allocated with enough header space to be
     * forwarded (to Ethernet for example).
     */
    np = pbuf_alloc(PBUF_LINK, n0->len + cs->cs_hlen, PBUF_POOL);
#else /* IP_FORWARD */
    np = pbuf_alloc(PBUF_RAW, n0->len + cs->cs_hlen, PBUF_POOL);
 801c9c6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c9c8:	895a      	ldrh	r2, [r3, #10]
 801c9ca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c9cc:	889b      	ldrh	r3, [r3, #4]
 801c9ce:	18d3      	adds	r3, r2, r3
 801c9d0:	b29b      	uxth	r3, r3
 801c9d2:	22c1      	movs	r2, #193	; 0xc1
 801c9d4:	0052      	lsls	r2, r2, #1
 801c9d6:	0019      	movs	r1, r3
 801c9d8:	2000      	movs	r0, #0
 801c9da:	f7ec fd81 	bl	80094e0 <pbuf_alloc>
 801c9de:	0003      	movs	r3, r0
 801c9e0:	60fb      	str	r3, [r7, #12]
#endif /* IP_FORWARD */
    if(!np) {
 801c9e2:	68fb      	ldr	r3, [r7, #12]
 801c9e4:	2b00      	cmp	r3, #0
 801c9e6:	d100      	bne.n	801c9ea <vj_uncompress_tcp+0x94a>
 801c9e8:	e078      	b.n	801cadc <vj_uncompress_tcp+0xa3c>
      PPPDEBUG(LOG_WARNING, ("vj_uncompress_tcp: realign failed\n"));
      goto bad;
    }

    if (pbuf_remove_header(np, cs->cs_hlen)) {
 801c9ea:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c9ec:	889b      	ldrh	r3, [r3, #4]
 801c9ee:	001a      	movs	r2, r3
 801c9f0:	68fb      	ldr	r3, [r7, #12]
 801c9f2:	0011      	movs	r1, r2
 801c9f4:	0018      	movs	r0, r3
 801c9f6:	f7ed f813 	bl	8009a20 <pbuf_remove_header>
 801c9fa:	1e03      	subs	r3, r0, #0
 801c9fc:	d007      	beq.n	801ca0e <vj_uncompress_tcp+0x96e>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_remove_header failed\n", 0);
 801c9fe:	4b3e      	ldr	r3, [pc, #248]	; (801caf8 <vj_uncompress_tcp+0xa58>)
 801ca00:	22a2      	movs	r2, #162	; 0xa2
 801ca02:	0092      	lsls	r2, r2, #2
 801ca04:	493e      	ldr	r1, [pc, #248]	; (801cb00 <vj_uncompress_tcp+0xa60>)
 801ca06:	483f      	ldr	r0, [pc, #252]	; (801cb04 <vj_uncompress_tcp+0xa64>)
 801ca08:	f7e5 ff68 	bl	80028dc <app_debug_rtt_raw>
      goto bad;
 801ca0c:	e069      	b.n	801cae2 <vj_uncompress_tcp+0xa42>
    }

    pbuf_take(np, n0->payload, n0->len);
 801ca0e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801ca10:	6859      	ldr	r1, [r3, #4]
 801ca12:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801ca14:	895a      	ldrh	r2, [r3, #10]
 801ca16:	68fb      	ldr	r3, [r7, #12]
 801ca18:	0018      	movs	r0, r3
 801ca1a:	f7ed fc79 	bl	800a310 <pbuf_take>

    if(n0->next) {
 801ca1e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801ca20:	681b      	ldr	r3, [r3, #0]
 801ca22:	2b00      	cmp	r3, #0
 801ca24:	d00a      	beq.n	801ca3c <vj_uncompress_tcp+0x99c>
      pbuf_chain(np, n0->next);
 801ca26:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801ca28:	681a      	ldr	r2, [r3, #0]
 801ca2a:	68fb      	ldr	r3, [r7, #12]
 801ca2c:	0011      	movs	r1, r2
 801ca2e:	0018      	movs	r0, r3
 801ca30:	f7ed fa02 	bl	8009e38 <pbuf_chain>
      pbuf_dechain(n0);
 801ca34:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801ca36:	0018      	movs	r0, r3
 801ca38:	f7ed fa12 	bl	8009e60 <pbuf_dechain>
    }
    pbuf_free(n0);
 801ca3c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801ca3e:	0018      	movs	r0, r3
 801ca40:	f7ed f8c6 	bl	8009bd0 <pbuf_free>
    n0 = np;
 801ca44:	68fb      	ldr	r3, [r7, #12]
 801ca46:	647b      	str	r3, [r7, #68]	; 0x44
  }

  if (pbuf_add_header(n0, cs->cs_hlen)) {
 801ca48:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801ca4a:	889b      	ldrh	r3, [r3, #4]
 801ca4c:	001a      	movs	r2, r3
 801ca4e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801ca50:	0011      	movs	r1, r2
 801ca52:	0018      	movs	r0, r3
 801ca54:	f7ec ffd4 	bl	8009a00 <pbuf_add_header>
 801ca58:	1e03      	subs	r3, r0, #0
 801ca5a:	d020      	beq.n	801ca9e <vj_uncompress_tcp+0x9fe>
    struct pbuf *np;

    LWIP_ASSERT("vj_uncompress_tcp: cs->cs_hlen <= PBUF_POOL_BUFSIZE", cs->cs_hlen <= PBUF_POOL_BUFSIZE);
 801ca5c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801ca5e:	889a      	ldrh	r2, [r3, #4]
 801ca60:	2394      	movs	r3, #148	; 0x94
 801ca62:	009b      	lsls	r3, r3, #2
 801ca64:	429a      	cmp	r2, r3
 801ca66:	d905      	bls.n	801ca74 <vj_uncompress_tcp+0x9d4>
 801ca68:	4b23      	ldr	r3, [pc, #140]	; (801caf8 <vj_uncompress_tcp+0xa58>)
 801ca6a:	4a27      	ldr	r2, [pc, #156]	; (801cb08 <vj_uncompress_tcp+0xa68>)
 801ca6c:	4927      	ldr	r1, [pc, #156]	; (801cb0c <vj_uncompress_tcp+0xa6c>)
 801ca6e:	4825      	ldr	r0, [pc, #148]	; (801cb04 <vj_uncompress_tcp+0xa64>)
 801ca70:	f7e5 ff34 	bl	80028dc <app_debug_rtt_raw>
    np = pbuf_alloc(PBUF_RAW, cs->cs_hlen, PBUF_POOL);
 801ca74:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801ca76:	889b      	ldrh	r3, [r3, #4]
 801ca78:	22c1      	movs	r2, #193	; 0xc1
 801ca7a:	0052      	lsls	r2, r2, #1
 801ca7c:	0019      	movs	r1, r3
 801ca7e:	2000      	movs	r0, #0
 801ca80:	f7ec fd2e 	bl	80094e0 <pbuf_alloc>
 801ca84:	0003      	movs	r3, r0
 801ca86:	60bb      	str	r3, [r7, #8]
    if(!np) {
 801ca88:	68bb      	ldr	r3, [r7, #8]
 801ca8a:	2b00      	cmp	r3, #0
 801ca8c:	d028      	beq.n	801cae0 <vj_uncompress_tcp+0xa40>
      PPPDEBUG(LOG_WARNING, ("vj_uncompress_tcp: prepend failed\n"));
      goto bad;
    }
    pbuf_cat(np, n0);
 801ca8e:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801ca90:	68bb      	ldr	r3, [r7, #8]
 801ca92:	0011      	movs	r1, r2
 801ca94:	0018      	movs	r0, r3
 801ca96:	f7ed f97b 	bl	8009d90 <pbuf_cat>
    n0 = np;
 801ca9a:	68bb      	ldr	r3, [r7, #8]
 801ca9c:	647b      	str	r3, [r7, #68]	; 0x44
  }
  LWIP_ASSERT("n0->len >= cs->cs_hlen", n0->len >= cs->cs_hlen);
 801ca9e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801caa0:	895a      	ldrh	r2, [r3, #10]
 801caa2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801caa4:	889b      	ldrh	r3, [r3, #4]
 801caa6:	429a      	cmp	r2, r3
 801caa8:	d205      	bcs.n	801cab6 <vj_uncompress_tcp+0xa16>
 801caaa:	4b13      	ldr	r3, [pc, #76]	; (801caf8 <vj_uncompress_tcp+0xa58>)
 801caac:	4a18      	ldr	r2, [pc, #96]	; (801cb10 <vj_uncompress_tcp+0xa70>)
 801caae:	4919      	ldr	r1, [pc, #100]	; (801cb14 <vj_uncompress_tcp+0xa74>)
 801cab0:	4814      	ldr	r0, [pc, #80]	; (801cb04 <vj_uncompress_tcp+0xa64>)
 801cab2:	f7e5 ff13 	bl	80028dc <app_debug_rtt_raw>
  MEMCPY(n0->payload, &cs->cs_ip, cs->cs_hlen);
 801cab6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801cab8:	6858      	ldr	r0, [r3, #4]
 801caba:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cabc:	3308      	adds	r3, #8
 801cabe:	0019      	movs	r1, r3
 801cac0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cac2:	889b      	ldrh	r3, [r3, #4]
 801cac4:	001a      	movs	r2, r3
 801cac6:	f000 f88b 	bl	801cbe0 <memcpy>

  *nb = n0;
 801caca:	687b      	ldr	r3, [r7, #4]
 801cacc:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801cace:	601a      	str	r2, [r3, #0]

  return vjlen;
 801cad0:	693b      	ldr	r3, [r7, #16]
 801cad2:	e00c      	b.n	801caee <vj_uncompress_tcp+0xa4e>
      goto bad;
 801cad4:	46c0      	nop			; (mov r8, r8)
 801cad6:	e004      	b.n	801cae2 <vj_uncompress_tcp+0xa42>
    goto bad;
 801cad8:	46c0      	nop			; (mov r8, r8)
 801cada:	e002      	b.n	801cae2 <vj_uncompress_tcp+0xa42>
      goto bad;
 801cadc:	46c0      	nop			; (mov r8, r8)
 801cade:	e000      	b.n	801cae2 <vj_uncompress_tcp+0xa42>
      goto bad;
 801cae0:	46c0      	nop			; (mov r8, r8)

bad:
  vj_uncompress_err(comp);
 801cae2:	683b      	ldr	r3, [r7, #0]
 801cae4:	0018      	movs	r0, r3
 801cae6:	f7ff fa5d 	bl	801bfa4 <vj_uncompress_err>
  return (-1);
 801caea:	2301      	movs	r3, #1
 801caec:	425b      	negs	r3, r3
}
 801caee:	0018      	movs	r0, r3
 801caf0:	46bd      	mov	sp, r7
 801caf2:	b015      	add	sp, #84	; 0x54
 801caf4:	bd90      	pop	{r4, r7, pc}
 801caf6:	46c0      	nop			; (mov r8, r8)
 801caf8:	08021c74 	.word	0x08021c74
 801cafc:	00000271 	.word	0x00000271
 801cb00:	08021ca0 	.word	0x08021ca0
 801cb04:	08021cbc 	.word	0x08021cbc
 801cb08:	00000299 	.word	0x00000299
 801cb0c:	08021ce8 	.word	0x08021ce8
 801cb10:	000002a2 	.word	0x000002a2
 801cb14:	08021d1c 	.word	0x08021d1c

0801cb18 <sys_rand>:
 */



extern uint32_t sys_rand()
{
 801cb18:	b580      	push	{r7, lr}
 801cb1a:	af00      	add	r7, sp, #0
    return SysTick->VAL;
 801cb1c:	4b02      	ldr	r3, [pc, #8]	; (801cb28 <sys_rand+0x10>)
 801cb1e:	689b      	ldr	r3, [r3, #8]
}
 801cb20:	0018      	movs	r0, r3
 801cb22:	46bd      	mov	sp, r7
 801cb24:	bd80      	pop	{r7, pc}
 801cb26:	46c0      	nop			; (mov r8, r8)
 801cb28:	e000e010 	.word	0xe000e010

0801cb2c <sys_get_tick_ms>:

extern uint32_t sys_get_tick_ms()
{
 801cb2c:	b580      	push	{r7, lr}
 801cb2e:	af00      	add	r7, sp, #0
    return HAL_GetTick();
 801cb30:	f7e6 f84a 	bl	8002bc8 <HAL_GetTick>
 801cb34:	0003      	movs	r3, r0
}
 801cb36:	0018      	movs	r0, r3
 801cb38:	46bd      	mov	sp, r7
 801cb3a:	bd80      	pop	{r7, pc}

0801cb3c <sys_now>:



uint32_t sys_now(void)
{
 801cb3c:	b580      	push	{r7, lr}
 801cb3e:	af00      	add	r7, sp, #0
    return sys_get_tick_ms();
 801cb40:	f7ff fff4 	bl	801cb2c <sys_get_tick_ms>
 801cb44:	0003      	movs	r3, r0
}
 801cb46:	0018      	movs	r0, r3
 801cb48:	46bd      	mov	sp, r7
 801cb4a:	bd80      	pop	{r7, pc}

0801cb4c <sys_jiffies>:

/**
 * @brief Override LWIP weak function
 */
uint32_t sys_jiffies(void)
{
 801cb4c:	b580      	push	{r7, lr}
 801cb4e:	af00      	add	r7, sp, #0
    return sys_get_tick_ms();
 801cb50:	f7ff ffec 	bl	801cb2c <sys_get_tick_ms>
 801cb54:	0003      	movs	r3, r0
}
 801cb56:	0018      	movs	r0, r3
 801cb58:	46bd      	mov	sp, r7
 801cb5a:	bd80      	pop	{r7, pc}

0801cb5c <atoi>:
 801cb5c:	b510      	push	{r4, lr}
 801cb5e:	220a      	movs	r2, #10
 801cb60:	2100      	movs	r1, #0
 801cb62:	f000 fa07 	bl	801cf74 <strtol>
 801cb66:	bd10      	pop	{r4, pc}

0801cb68 <__libc_init_array>:
 801cb68:	b570      	push	{r4, r5, r6, lr}
 801cb6a:	2600      	movs	r6, #0
 801cb6c:	4d0c      	ldr	r5, [pc, #48]	; (801cba0 <__libc_init_array+0x38>)
 801cb6e:	4c0d      	ldr	r4, [pc, #52]	; (801cba4 <__libc_init_array+0x3c>)
 801cb70:	1b64      	subs	r4, r4, r5
 801cb72:	10a4      	asrs	r4, r4, #2
 801cb74:	42a6      	cmp	r6, r4
 801cb76:	d109      	bne.n	801cb8c <__libc_init_array+0x24>
 801cb78:	2600      	movs	r6, #0
 801cb7a:	f000 fd75 	bl	801d668 <_init>
 801cb7e:	4d0a      	ldr	r5, [pc, #40]	; (801cba8 <__libc_init_array+0x40>)
 801cb80:	4c0a      	ldr	r4, [pc, #40]	; (801cbac <__libc_init_array+0x44>)
 801cb82:	1b64      	subs	r4, r4, r5
 801cb84:	10a4      	asrs	r4, r4, #2
 801cb86:	42a6      	cmp	r6, r4
 801cb88:	d105      	bne.n	801cb96 <__libc_init_array+0x2e>
 801cb8a:	bd70      	pop	{r4, r5, r6, pc}
 801cb8c:	00b3      	lsls	r3, r6, #2
 801cb8e:	58eb      	ldr	r3, [r5, r3]
 801cb90:	4798      	blx	r3
 801cb92:	3601      	adds	r6, #1
 801cb94:	e7ee      	b.n	801cb74 <__libc_init_array+0xc>
 801cb96:	00b3      	lsls	r3, r6, #2
 801cb98:	58eb      	ldr	r3, [r5, r3]
 801cb9a:	4798      	blx	r3
 801cb9c:	3601      	adds	r6, #1
 801cb9e:	e7f2      	b.n	801cb86 <__libc_init_array+0x1e>
 801cba0:	08022be4 	.word	0x08022be4
 801cba4:	08022be4 	.word	0x08022be4
 801cba8:	08022be4 	.word	0x08022be4
 801cbac:	08022be8 	.word	0x08022be8

0801cbb0 <malloc>:
 801cbb0:	b510      	push	{r4, lr}
 801cbb2:	4b03      	ldr	r3, [pc, #12]	; (801cbc0 <malloc+0x10>)
 801cbb4:	0001      	movs	r1, r0
 801cbb6:	6818      	ldr	r0, [r3, #0]
 801cbb8:	f000 f880 	bl	801ccbc <_malloc_r>
 801cbbc:	bd10      	pop	{r4, pc}
 801cbbe:	46c0      	nop			; (mov r8, r8)
 801cbc0:	20000038 	.word	0x20000038

0801cbc4 <memcmp>:
 801cbc4:	b530      	push	{r4, r5, lr}
 801cbc6:	2400      	movs	r4, #0
 801cbc8:	3901      	subs	r1, #1
 801cbca:	42a2      	cmp	r2, r4
 801cbcc:	d101      	bne.n	801cbd2 <memcmp+0xe>
 801cbce:	2000      	movs	r0, #0
 801cbd0:	e005      	b.n	801cbde <memcmp+0x1a>
 801cbd2:	5d03      	ldrb	r3, [r0, r4]
 801cbd4:	3401      	adds	r4, #1
 801cbd6:	5d0d      	ldrb	r5, [r1, r4]
 801cbd8:	42ab      	cmp	r3, r5
 801cbda:	d0f6      	beq.n	801cbca <memcmp+0x6>
 801cbdc:	1b58      	subs	r0, r3, r5
 801cbde:	bd30      	pop	{r4, r5, pc}

0801cbe0 <memcpy>:
 801cbe0:	2300      	movs	r3, #0
 801cbe2:	b510      	push	{r4, lr}
 801cbe4:	429a      	cmp	r2, r3
 801cbe6:	d100      	bne.n	801cbea <memcpy+0xa>
 801cbe8:	bd10      	pop	{r4, pc}
 801cbea:	5ccc      	ldrb	r4, [r1, r3]
 801cbec:	54c4      	strb	r4, [r0, r3]
 801cbee:	3301      	adds	r3, #1
 801cbf0:	e7f8      	b.n	801cbe4 <memcpy+0x4>

0801cbf2 <memmove>:
 801cbf2:	b510      	push	{r4, lr}
 801cbf4:	4288      	cmp	r0, r1
 801cbf6:	d902      	bls.n	801cbfe <memmove+0xc>
 801cbf8:	188b      	adds	r3, r1, r2
 801cbfa:	4298      	cmp	r0, r3
 801cbfc:	d303      	bcc.n	801cc06 <memmove+0x14>
 801cbfe:	2300      	movs	r3, #0
 801cc00:	e007      	b.n	801cc12 <memmove+0x20>
 801cc02:	5c8b      	ldrb	r3, [r1, r2]
 801cc04:	5483      	strb	r3, [r0, r2]
 801cc06:	3a01      	subs	r2, #1
 801cc08:	d2fb      	bcs.n	801cc02 <memmove+0x10>
 801cc0a:	bd10      	pop	{r4, pc}
 801cc0c:	5ccc      	ldrb	r4, [r1, r3]
 801cc0e:	54c4      	strb	r4, [r0, r3]
 801cc10:	3301      	adds	r3, #1
 801cc12:	429a      	cmp	r2, r3
 801cc14:	d1fa      	bne.n	801cc0c <memmove+0x1a>
 801cc16:	e7f8      	b.n	801cc0a <memmove+0x18>

0801cc18 <memset>:
 801cc18:	0003      	movs	r3, r0
 801cc1a:	1882      	adds	r2, r0, r2
 801cc1c:	4293      	cmp	r3, r2
 801cc1e:	d100      	bne.n	801cc22 <memset+0xa>
 801cc20:	4770      	bx	lr
 801cc22:	7019      	strb	r1, [r3, #0]
 801cc24:	3301      	adds	r3, #1
 801cc26:	e7f9      	b.n	801cc1c <memset+0x4>

0801cc28 <_free_r>:
 801cc28:	b570      	push	{r4, r5, r6, lr}
 801cc2a:	0005      	movs	r5, r0
 801cc2c:	2900      	cmp	r1, #0
 801cc2e:	d010      	beq.n	801cc52 <_free_r+0x2a>
 801cc30:	1f0c      	subs	r4, r1, #4
 801cc32:	6823      	ldr	r3, [r4, #0]
 801cc34:	2b00      	cmp	r3, #0
 801cc36:	da00      	bge.n	801cc3a <_free_r+0x12>
 801cc38:	18e4      	adds	r4, r4, r3
 801cc3a:	0028      	movs	r0, r5
 801cc3c:	f000 f9e6 	bl	801d00c <__malloc_lock>
 801cc40:	4a1d      	ldr	r2, [pc, #116]	; (801ccb8 <_free_r+0x90>)
 801cc42:	6813      	ldr	r3, [r2, #0]
 801cc44:	2b00      	cmp	r3, #0
 801cc46:	d105      	bne.n	801cc54 <_free_r+0x2c>
 801cc48:	6063      	str	r3, [r4, #4]
 801cc4a:	6014      	str	r4, [r2, #0]
 801cc4c:	0028      	movs	r0, r5
 801cc4e:	f000 f9e5 	bl	801d01c <__malloc_unlock>
 801cc52:	bd70      	pop	{r4, r5, r6, pc}
 801cc54:	42a3      	cmp	r3, r4
 801cc56:	d908      	bls.n	801cc6a <_free_r+0x42>
 801cc58:	6821      	ldr	r1, [r4, #0]
 801cc5a:	1860      	adds	r0, r4, r1
 801cc5c:	4283      	cmp	r3, r0
 801cc5e:	d1f3      	bne.n	801cc48 <_free_r+0x20>
 801cc60:	6818      	ldr	r0, [r3, #0]
 801cc62:	685b      	ldr	r3, [r3, #4]
 801cc64:	1841      	adds	r1, r0, r1
 801cc66:	6021      	str	r1, [r4, #0]
 801cc68:	e7ee      	b.n	801cc48 <_free_r+0x20>
 801cc6a:	001a      	movs	r2, r3
 801cc6c:	685b      	ldr	r3, [r3, #4]
 801cc6e:	2b00      	cmp	r3, #0
 801cc70:	d001      	beq.n	801cc76 <_free_r+0x4e>
 801cc72:	42a3      	cmp	r3, r4
 801cc74:	d9f9      	bls.n	801cc6a <_free_r+0x42>
 801cc76:	6811      	ldr	r1, [r2, #0]
 801cc78:	1850      	adds	r0, r2, r1
 801cc7a:	42a0      	cmp	r0, r4
 801cc7c:	d10b      	bne.n	801cc96 <_free_r+0x6e>
 801cc7e:	6820      	ldr	r0, [r4, #0]
 801cc80:	1809      	adds	r1, r1, r0
 801cc82:	1850      	adds	r0, r2, r1
 801cc84:	6011      	str	r1, [r2, #0]
 801cc86:	4283      	cmp	r3, r0
 801cc88:	d1e0      	bne.n	801cc4c <_free_r+0x24>
 801cc8a:	6818      	ldr	r0, [r3, #0]
 801cc8c:	685b      	ldr	r3, [r3, #4]
 801cc8e:	1841      	adds	r1, r0, r1
 801cc90:	6011      	str	r1, [r2, #0]
 801cc92:	6053      	str	r3, [r2, #4]
 801cc94:	e7da      	b.n	801cc4c <_free_r+0x24>
 801cc96:	42a0      	cmp	r0, r4
 801cc98:	d902      	bls.n	801cca0 <_free_r+0x78>
 801cc9a:	230c      	movs	r3, #12
 801cc9c:	602b      	str	r3, [r5, #0]
 801cc9e:	e7d5      	b.n	801cc4c <_free_r+0x24>
 801cca0:	6821      	ldr	r1, [r4, #0]
 801cca2:	1860      	adds	r0, r4, r1
 801cca4:	4283      	cmp	r3, r0
 801cca6:	d103      	bne.n	801ccb0 <_free_r+0x88>
 801cca8:	6818      	ldr	r0, [r3, #0]
 801ccaa:	685b      	ldr	r3, [r3, #4]
 801ccac:	1841      	adds	r1, r0, r1
 801ccae:	6021      	str	r1, [r4, #0]
 801ccb0:	6063      	str	r3, [r4, #4]
 801ccb2:	6054      	str	r4, [r2, #4]
 801ccb4:	e7ca      	b.n	801cc4c <_free_r+0x24>
 801ccb6:	46c0      	nop			; (mov r8, r8)
 801ccb8:	20001b90 	.word	0x20001b90

0801ccbc <_malloc_r>:
 801ccbc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801ccbe:	2303      	movs	r3, #3
 801ccc0:	1ccd      	adds	r5, r1, #3
 801ccc2:	439d      	bics	r5, r3
 801ccc4:	3508      	adds	r5, #8
 801ccc6:	0006      	movs	r6, r0
 801ccc8:	2d0c      	cmp	r5, #12
 801ccca:	d21f      	bcs.n	801cd0c <_malloc_r+0x50>
 801cccc:	250c      	movs	r5, #12
 801ccce:	42a9      	cmp	r1, r5
 801ccd0:	d81e      	bhi.n	801cd10 <_malloc_r+0x54>
 801ccd2:	0030      	movs	r0, r6
 801ccd4:	f000 f99a 	bl	801d00c <__malloc_lock>
 801ccd8:	4925      	ldr	r1, [pc, #148]	; (801cd70 <_malloc_r+0xb4>)
 801ccda:	680a      	ldr	r2, [r1, #0]
 801ccdc:	0014      	movs	r4, r2
 801ccde:	2c00      	cmp	r4, #0
 801cce0:	d11a      	bne.n	801cd18 <_malloc_r+0x5c>
 801cce2:	4f24      	ldr	r7, [pc, #144]	; (801cd74 <_malloc_r+0xb8>)
 801cce4:	683b      	ldr	r3, [r7, #0]
 801cce6:	2b00      	cmp	r3, #0
 801cce8:	d104      	bne.n	801ccf4 <_malloc_r+0x38>
 801ccea:	0021      	movs	r1, r4
 801ccec:	0030      	movs	r0, r6
 801ccee:	f000 f843 	bl	801cd78 <_sbrk_r>
 801ccf2:	6038      	str	r0, [r7, #0]
 801ccf4:	0029      	movs	r1, r5
 801ccf6:	0030      	movs	r0, r6
 801ccf8:	f000 f83e 	bl	801cd78 <_sbrk_r>
 801ccfc:	1c43      	adds	r3, r0, #1
 801ccfe:	d12b      	bne.n	801cd58 <_malloc_r+0x9c>
 801cd00:	230c      	movs	r3, #12
 801cd02:	0030      	movs	r0, r6
 801cd04:	6033      	str	r3, [r6, #0]
 801cd06:	f000 f989 	bl	801d01c <__malloc_unlock>
 801cd0a:	e003      	b.n	801cd14 <_malloc_r+0x58>
 801cd0c:	2d00      	cmp	r5, #0
 801cd0e:	dade      	bge.n	801ccce <_malloc_r+0x12>
 801cd10:	230c      	movs	r3, #12
 801cd12:	6033      	str	r3, [r6, #0]
 801cd14:	2000      	movs	r0, #0
 801cd16:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801cd18:	6823      	ldr	r3, [r4, #0]
 801cd1a:	1b5b      	subs	r3, r3, r5
 801cd1c:	d419      	bmi.n	801cd52 <_malloc_r+0x96>
 801cd1e:	2b0b      	cmp	r3, #11
 801cd20:	d903      	bls.n	801cd2a <_malloc_r+0x6e>
 801cd22:	6023      	str	r3, [r4, #0]
 801cd24:	18e4      	adds	r4, r4, r3
 801cd26:	6025      	str	r5, [r4, #0]
 801cd28:	e003      	b.n	801cd32 <_malloc_r+0x76>
 801cd2a:	6863      	ldr	r3, [r4, #4]
 801cd2c:	42a2      	cmp	r2, r4
 801cd2e:	d10e      	bne.n	801cd4e <_malloc_r+0x92>
 801cd30:	600b      	str	r3, [r1, #0]
 801cd32:	0030      	movs	r0, r6
 801cd34:	f000 f972 	bl	801d01c <__malloc_unlock>
 801cd38:	0020      	movs	r0, r4
 801cd3a:	2207      	movs	r2, #7
 801cd3c:	300b      	adds	r0, #11
 801cd3e:	1d23      	adds	r3, r4, #4
 801cd40:	4390      	bics	r0, r2
 801cd42:	1ac2      	subs	r2, r0, r3
 801cd44:	4298      	cmp	r0, r3
 801cd46:	d0e6      	beq.n	801cd16 <_malloc_r+0x5a>
 801cd48:	1a1b      	subs	r3, r3, r0
 801cd4a:	50a3      	str	r3, [r4, r2]
 801cd4c:	e7e3      	b.n	801cd16 <_malloc_r+0x5a>
 801cd4e:	6053      	str	r3, [r2, #4]
 801cd50:	e7ef      	b.n	801cd32 <_malloc_r+0x76>
 801cd52:	0022      	movs	r2, r4
 801cd54:	6864      	ldr	r4, [r4, #4]
 801cd56:	e7c2      	b.n	801ccde <_malloc_r+0x22>
 801cd58:	2303      	movs	r3, #3
 801cd5a:	1cc4      	adds	r4, r0, #3
 801cd5c:	439c      	bics	r4, r3
 801cd5e:	42a0      	cmp	r0, r4
 801cd60:	d0e1      	beq.n	801cd26 <_malloc_r+0x6a>
 801cd62:	1a21      	subs	r1, r4, r0
 801cd64:	0030      	movs	r0, r6
 801cd66:	f000 f807 	bl	801cd78 <_sbrk_r>
 801cd6a:	1c43      	adds	r3, r0, #1
 801cd6c:	d1db      	bne.n	801cd26 <_malloc_r+0x6a>
 801cd6e:	e7c7      	b.n	801cd00 <_malloc_r+0x44>
 801cd70:	20001b90 	.word	0x20001b90
 801cd74:	20001b94 	.word	0x20001b94

0801cd78 <_sbrk_r>:
 801cd78:	2300      	movs	r3, #0
 801cd7a:	b570      	push	{r4, r5, r6, lr}
 801cd7c:	4d06      	ldr	r5, [pc, #24]	; (801cd98 <_sbrk_r+0x20>)
 801cd7e:	0004      	movs	r4, r0
 801cd80:	0008      	movs	r0, r1
 801cd82:	602b      	str	r3, [r5, #0]
 801cd84:	f7e3 fd50 	bl	8000828 <_sbrk>
 801cd88:	1c43      	adds	r3, r0, #1
 801cd8a:	d103      	bne.n	801cd94 <_sbrk_r+0x1c>
 801cd8c:	682b      	ldr	r3, [r5, #0]
 801cd8e:	2b00      	cmp	r3, #0
 801cd90:	d000      	beq.n	801cd94 <_sbrk_r+0x1c>
 801cd92:	6023      	str	r3, [r4, #0]
 801cd94:	bd70      	pop	{r4, r5, r6, pc}
 801cd96:	46c0      	nop			; (mov r8, r8)
 801cd98:	200041bc 	.word	0x200041bc

0801cd9c <sniprintf>:
 801cd9c:	b40c      	push	{r2, r3}
 801cd9e:	b530      	push	{r4, r5, lr}
 801cda0:	4b17      	ldr	r3, [pc, #92]	; (801ce00 <sniprintf+0x64>)
 801cda2:	000c      	movs	r4, r1
 801cda4:	681d      	ldr	r5, [r3, #0]
 801cda6:	b09d      	sub	sp, #116	; 0x74
 801cda8:	2900      	cmp	r1, #0
 801cdaa:	da08      	bge.n	801cdbe <sniprintf+0x22>
 801cdac:	238b      	movs	r3, #139	; 0x8b
 801cdae:	2001      	movs	r0, #1
 801cdb0:	602b      	str	r3, [r5, #0]
 801cdb2:	4240      	negs	r0, r0
 801cdb4:	b01d      	add	sp, #116	; 0x74
 801cdb6:	bc30      	pop	{r4, r5}
 801cdb8:	bc08      	pop	{r3}
 801cdba:	b002      	add	sp, #8
 801cdbc:	4718      	bx	r3
 801cdbe:	2382      	movs	r3, #130	; 0x82
 801cdc0:	466a      	mov	r2, sp
 801cdc2:	009b      	lsls	r3, r3, #2
 801cdc4:	8293      	strh	r3, [r2, #20]
 801cdc6:	2300      	movs	r3, #0
 801cdc8:	9002      	str	r0, [sp, #8]
 801cdca:	9006      	str	r0, [sp, #24]
 801cdcc:	4299      	cmp	r1, r3
 801cdce:	d000      	beq.n	801cdd2 <sniprintf+0x36>
 801cdd0:	1e4b      	subs	r3, r1, #1
 801cdd2:	9304      	str	r3, [sp, #16]
 801cdd4:	9307      	str	r3, [sp, #28]
 801cdd6:	2301      	movs	r3, #1
 801cdd8:	466a      	mov	r2, sp
 801cdda:	425b      	negs	r3, r3
 801cddc:	82d3      	strh	r3, [r2, #22]
 801cdde:	0028      	movs	r0, r5
 801cde0:	ab21      	add	r3, sp, #132	; 0x84
 801cde2:	9a20      	ldr	r2, [sp, #128]	; 0x80
 801cde4:	a902      	add	r1, sp, #8
 801cde6:	9301      	str	r3, [sp, #4]
 801cde8:	f000 f982 	bl	801d0f0 <_svfiprintf_r>
 801cdec:	1c43      	adds	r3, r0, #1
 801cdee:	da01      	bge.n	801cdf4 <sniprintf+0x58>
 801cdf0:	238b      	movs	r3, #139	; 0x8b
 801cdf2:	602b      	str	r3, [r5, #0]
 801cdf4:	2c00      	cmp	r4, #0
 801cdf6:	d0dd      	beq.n	801cdb4 <sniprintf+0x18>
 801cdf8:	2300      	movs	r3, #0
 801cdfa:	9a02      	ldr	r2, [sp, #8]
 801cdfc:	7013      	strb	r3, [r2, #0]
 801cdfe:	e7d9      	b.n	801cdb4 <sniprintf+0x18>
 801ce00:	20000038 	.word	0x20000038

0801ce04 <strncpy>:
 801ce04:	0003      	movs	r3, r0
 801ce06:	b530      	push	{r4, r5, lr}
 801ce08:	001d      	movs	r5, r3
 801ce0a:	2a00      	cmp	r2, #0
 801ce0c:	d006      	beq.n	801ce1c <strncpy+0x18>
 801ce0e:	780c      	ldrb	r4, [r1, #0]
 801ce10:	3a01      	subs	r2, #1
 801ce12:	3301      	adds	r3, #1
 801ce14:	702c      	strb	r4, [r5, #0]
 801ce16:	3101      	adds	r1, #1
 801ce18:	2c00      	cmp	r4, #0
 801ce1a:	d1f5      	bne.n	801ce08 <strncpy+0x4>
 801ce1c:	2100      	movs	r1, #0
 801ce1e:	189a      	adds	r2, r3, r2
 801ce20:	4293      	cmp	r3, r2
 801ce22:	d100      	bne.n	801ce26 <strncpy+0x22>
 801ce24:	bd30      	pop	{r4, r5, pc}
 801ce26:	7019      	strb	r1, [r3, #0]
 801ce28:	3301      	adds	r3, #1
 801ce2a:	e7f9      	b.n	801ce20 <strncpy+0x1c>

0801ce2c <strstr>:
 801ce2c:	780a      	ldrb	r2, [r1, #0]
 801ce2e:	b530      	push	{r4, r5, lr}
 801ce30:	2a00      	cmp	r2, #0
 801ce32:	d10c      	bne.n	801ce4e <strstr+0x22>
 801ce34:	bd30      	pop	{r4, r5, pc}
 801ce36:	429a      	cmp	r2, r3
 801ce38:	d108      	bne.n	801ce4c <strstr+0x20>
 801ce3a:	2301      	movs	r3, #1
 801ce3c:	5ccc      	ldrb	r4, [r1, r3]
 801ce3e:	2c00      	cmp	r4, #0
 801ce40:	d0f8      	beq.n	801ce34 <strstr+0x8>
 801ce42:	5cc5      	ldrb	r5, [r0, r3]
 801ce44:	42a5      	cmp	r5, r4
 801ce46:	d101      	bne.n	801ce4c <strstr+0x20>
 801ce48:	3301      	adds	r3, #1
 801ce4a:	e7f7      	b.n	801ce3c <strstr+0x10>
 801ce4c:	3001      	adds	r0, #1
 801ce4e:	7803      	ldrb	r3, [r0, #0]
 801ce50:	2b00      	cmp	r3, #0
 801ce52:	d1f0      	bne.n	801ce36 <strstr+0xa>
 801ce54:	0018      	movs	r0, r3
 801ce56:	e7ed      	b.n	801ce34 <strstr+0x8>

0801ce58 <_strtol_l.isra.0>:
 801ce58:	b5f0      	push	{r4, r5, r6, r7, lr}
 801ce5a:	b087      	sub	sp, #28
 801ce5c:	001e      	movs	r6, r3
 801ce5e:	9005      	str	r0, [sp, #20]
 801ce60:	9101      	str	r1, [sp, #4]
 801ce62:	9202      	str	r2, [sp, #8]
 801ce64:	2b01      	cmp	r3, #1
 801ce66:	d045      	beq.n	801cef4 <_strtol_l.isra.0+0x9c>
 801ce68:	0008      	movs	r0, r1
 801ce6a:	2b24      	cmp	r3, #36	; 0x24
 801ce6c:	d842      	bhi.n	801cef4 <_strtol_l.isra.0+0x9c>
 801ce6e:	4b3f      	ldr	r3, [pc, #252]	; (801cf6c <_strtol_l.isra.0+0x114>)
 801ce70:	2208      	movs	r2, #8
 801ce72:	469c      	mov	ip, r3
 801ce74:	0003      	movs	r3, r0
 801ce76:	4661      	mov	r1, ip
 801ce78:	781c      	ldrb	r4, [r3, #0]
 801ce7a:	1c45      	adds	r5, r0, #1
 801ce7c:	5d09      	ldrb	r1, [r1, r4]
 801ce7e:	0028      	movs	r0, r5
 801ce80:	000f      	movs	r7, r1
 801ce82:	4017      	ands	r7, r2
 801ce84:	4211      	tst	r1, r2
 801ce86:	d1f5      	bne.n	801ce74 <_strtol_l.isra.0+0x1c>
 801ce88:	2c2d      	cmp	r4, #45	; 0x2d
 801ce8a:	d13a      	bne.n	801cf02 <_strtol_l.isra.0+0xaa>
 801ce8c:	2701      	movs	r7, #1
 801ce8e:	782c      	ldrb	r4, [r5, #0]
 801ce90:	1c9d      	adds	r5, r3, #2
 801ce92:	2e00      	cmp	r6, #0
 801ce94:	d065      	beq.n	801cf62 <_strtol_l.isra.0+0x10a>
 801ce96:	2e10      	cmp	r6, #16
 801ce98:	d109      	bne.n	801ceae <_strtol_l.isra.0+0x56>
 801ce9a:	2c30      	cmp	r4, #48	; 0x30
 801ce9c:	d107      	bne.n	801ceae <_strtol_l.isra.0+0x56>
 801ce9e:	2220      	movs	r2, #32
 801cea0:	782b      	ldrb	r3, [r5, #0]
 801cea2:	4393      	bics	r3, r2
 801cea4:	2b58      	cmp	r3, #88	; 0x58
 801cea6:	d157      	bne.n	801cf58 <_strtol_l.isra.0+0x100>
 801cea8:	2610      	movs	r6, #16
 801ceaa:	786c      	ldrb	r4, [r5, #1]
 801ceac:	3502      	adds	r5, #2
 801ceae:	4b30      	ldr	r3, [pc, #192]	; (801cf70 <_strtol_l.isra.0+0x118>)
 801ceb0:	0031      	movs	r1, r6
 801ceb2:	18fb      	adds	r3, r7, r3
 801ceb4:	0018      	movs	r0, r3
 801ceb6:	9303      	str	r3, [sp, #12]
 801ceb8:	f7e3 f9be 	bl	8000238 <__aeabi_uidivmod>
 801cebc:	2300      	movs	r3, #0
 801cebe:	2201      	movs	r2, #1
 801cec0:	4684      	mov	ip, r0
 801cec2:	0018      	movs	r0, r3
 801cec4:	9104      	str	r1, [sp, #16]
 801cec6:	4252      	negs	r2, r2
 801cec8:	0021      	movs	r1, r4
 801ceca:	3930      	subs	r1, #48	; 0x30
 801cecc:	2909      	cmp	r1, #9
 801cece:	d81d      	bhi.n	801cf0c <_strtol_l.isra.0+0xb4>
 801ced0:	000c      	movs	r4, r1
 801ced2:	42a6      	cmp	r6, r4
 801ced4:	dd28      	ble.n	801cf28 <_strtol_l.isra.0+0xd0>
 801ced6:	2b00      	cmp	r3, #0
 801ced8:	db24      	blt.n	801cf24 <_strtol_l.isra.0+0xcc>
 801ceda:	0013      	movs	r3, r2
 801cedc:	4584      	cmp	ip, r0
 801cede:	d306      	bcc.n	801ceee <_strtol_l.isra.0+0x96>
 801cee0:	d102      	bne.n	801cee8 <_strtol_l.isra.0+0x90>
 801cee2:	9904      	ldr	r1, [sp, #16]
 801cee4:	42a1      	cmp	r1, r4
 801cee6:	db02      	blt.n	801ceee <_strtol_l.isra.0+0x96>
 801cee8:	2301      	movs	r3, #1
 801ceea:	4370      	muls	r0, r6
 801ceec:	1820      	adds	r0, r4, r0
 801ceee:	782c      	ldrb	r4, [r5, #0]
 801cef0:	3501      	adds	r5, #1
 801cef2:	e7e9      	b.n	801cec8 <_strtol_l.isra.0+0x70>
 801cef4:	f000 f882 	bl	801cffc <__errno>
 801cef8:	2316      	movs	r3, #22
 801cefa:	6003      	str	r3, [r0, #0]
 801cefc:	2000      	movs	r0, #0
 801cefe:	b007      	add	sp, #28
 801cf00:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801cf02:	2c2b      	cmp	r4, #43	; 0x2b
 801cf04:	d1c5      	bne.n	801ce92 <_strtol_l.isra.0+0x3a>
 801cf06:	782c      	ldrb	r4, [r5, #0]
 801cf08:	1c9d      	adds	r5, r3, #2
 801cf0a:	e7c2      	b.n	801ce92 <_strtol_l.isra.0+0x3a>
 801cf0c:	0021      	movs	r1, r4
 801cf0e:	3941      	subs	r1, #65	; 0x41
 801cf10:	2919      	cmp	r1, #25
 801cf12:	d801      	bhi.n	801cf18 <_strtol_l.isra.0+0xc0>
 801cf14:	3c37      	subs	r4, #55	; 0x37
 801cf16:	e7dc      	b.n	801ced2 <_strtol_l.isra.0+0x7a>
 801cf18:	0021      	movs	r1, r4
 801cf1a:	3961      	subs	r1, #97	; 0x61
 801cf1c:	2919      	cmp	r1, #25
 801cf1e:	d803      	bhi.n	801cf28 <_strtol_l.isra.0+0xd0>
 801cf20:	3c57      	subs	r4, #87	; 0x57
 801cf22:	e7d6      	b.n	801ced2 <_strtol_l.isra.0+0x7a>
 801cf24:	0013      	movs	r3, r2
 801cf26:	e7e2      	b.n	801ceee <_strtol_l.isra.0+0x96>
 801cf28:	2b00      	cmp	r3, #0
 801cf2a:	da09      	bge.n	801cf40 <_strtol_l.isra.0+0xe8>
 801cf2c:	2322      	movs	r3, #34	; 0x22
 801cf2e:	9a05      	ldr	r2, [sp, #20]
 801cf30:	9803      	ldr	r0, [sp, #12]
 801cf32:	6013      	str	r3, [r2, #0]
 801cf34:	9b02      	ldr	r3, [sp, #8]
 801cf36:	2b00      	cmp	r3, #0
 801cf38:	d0e1      	beq.n	801cefe <_strtol_l.isra.0+0xa6>
 801cf3a:	1e6b      	subs	r3, r5, #1
 801cf3c:	9301      	str	r3, [sp, #4]
 801cf3e:	e007      	b.n	801cf50 <_strtol_l.isra.0+0xf8>
 801cf40:	2f00      	cmp	r7, #0
 801cf42:	d000      	beq.n	801cf46 <_strtol_l.isra.0+0xee>
 801cf44:	4240      	negs	r0, r0
 801cf46:	9a02      	ldr	r2, [sp, #8]
 801cf48:	2a00      	cmp	r2, #0
 801cf4a:	d0d8      	beq.n	801cefe <_strtol_l.isra.0+0xa6>
 801cf4c:	2b00      	cmp	r3, #0
 801cf4e:	d1f4      	bne.n	801cf3a <_strtol_l.isra.0+0xe2>
 801cf50:	9b02      	ldr	r3, [sp, #8]
 801cf52:	9a01      	ldr	r2, [sp, #4]
 801cf54:	601a      	str	r2, [r3, #0]
 801cf56:	e7d2      	b.n	801cefe <_strtol_l.isra.0+0xa6>
 801cf58:	2430      	movs	r4, #48	; 0x30
 801cf5a:	2e00      	cmp	r6, #0
 801cf5c:	d1a7      	bne.n	801ceae <_strtol_l.isra.0+0x56>
 801cf5e:	3608      	adds	r6, #8
 801cf60:	e7a5      	b.n	801ceae <_strtol_l.isra.0+0x56>
 801cf62:	2c30      	cmp	r4, #48	; 0x30
 801cf64:	d09b      	beq.n	801ce9e <_strtol_l.isra.0+0x46>
 801cf66:	260a      	movs	r6, #10
 801cf68:	e7a1      	b.n	801ceae <_strtol_l.isra.0+0x56>
 801cf6a:	46c0      	nop			; (mov r8, r8)
 801cf6c:	08022a49 	.word	0x08022a49
 801cf70:	7fffffff 	.word	0x7fffffff

0801cf74 <strtol>:
 801cf74:	b510      	push	{r4, lr}
 801cf76:	0013      	movs	r3, r2
 801cf78:	000a      	movs	r2, r1
 801cf7a:	0001      	movs	r1, r0
 801cf7c:	4802      	ldr	r0, [pc, #8]	; (801cf88 <strtol+0x14>)
 801cf7e:	6800      	ldr	r0, [r0, #0]
 801cf80:	f7ff ff6a 	bl	801ce58 <_strtol_l.isra.0>
 801cf84:	bd10      	pop	{r4, pc}
 801cf86:	46c0      	nop			; (mov r8, r8)
 801cf88:	20000038 	.word	0x20000038

0801cf8c <_vsniprintf_r>:
 801cf8c:	b530      	push	{r4, r5, lr}
 801cf8e:	0014      	movs	r4, r2
 801cf90:	0005      	movs	r5, r0
 801cf92:	001a      	movs	r2, r3
 801cf94:	b09b      	sub	sp, #108	; 0x6c
 801cf96:	2c00      	cmp	r4, #0
 801cf98:	da05      	bge.n	801cfa6 <_vsniprintf_r+0x1a>
 801cf9a:	238b      	movs	r3, #139	; 0x8b
 801cf9c:	6003      	str	r3, [r0, #0]
 801cf9e:	2001      	movs	r0, #1
 801cfa0:	4240      	negs	r0, r0
 801cfa2:	b01b      	add	sp, #108	; 0x6c
 801cfa4:	bd30      	pop	{r4, r5, pc}
 801cfa6:	2382      	movs	r3, #130	; 0x82
 801cfa8:	4668      	mov	r0, sp
 801cfaa:	009b      	lsls	r3, r3, #2
 801cfac:	8183      	strh	r3, [r0, #12]
 801cfae:	2300      	movs	r3, #0
 801cfb0:	9100      	str	r1, [sp, #0]
 801cfb2:	9104      	str	r1, [sp, #16]
 801cfb4:	429c      	cmp	r4, r3
 801cfb6:	d000      	beq.n	801cfba <_vsniprintf_r+0x2e>
 801cfb8:	1e63      	subs	r3, r4, #1
 801cfba:	9302      	str	r3, [sp, #8]
 801cfbc:	9305      	str	r3, [sp, #20]
 801cfbe:	2301      	movs	r3, #1
 801cfc0:	4669      	mov	r1, sp
 801cfc2:	425b      	negs	r3, r3
 801cfc4:	81cb      	strh	r3, [r1, #14]
 801cfc6:	0028      	movs	r0, r5
 801cfc8:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 801cfca:	f000 f891 	bl	801d0f0 <_svfiprintf_r>
 801cfce:	1c43      	adds	r3, r0, #1
 801cfd0:	da01      	bge.n	801cfd6 <_vsniprintf_r+0x4a>
 801cfd2:	238b      	movs	r3, #139	; 0x8b
 801cfd4:	602b      	str	r3, [r5, #0]
 801cfd6:	2c00      	cmp	r4, #0
 801cfd8:	d0e3      	beq.n	801cfa2 <_vsniprintf_r+0x16>
 801cfda:	2300      	movs	r3, #0
 801cfdc:	9a00      	ldr	r2, [sp, #0]
 801cfde:	7013      	strb	r3, [r2, #0]
 801cfe0:	e7df      	b.n	801cfa2 <_vsniprintf_r+0x16>
	...

0801cfe4 <vsniprintf>:
 801cfe4:	b507      	push	{r0, r1, r2, lr}
 801cfe6:	9300      	str	r3, [sp, #0]
 801cfe8:	0013      	movs	r3, r2
 801cfea:	000a      	movs	r2, r1
 801cfec:	0001      	movs	r1, r0
 801cfee:	4802      	ldr	r0, [pc, #8]	; (801cff8 <vsniprintf+0x14>)
 801cff0:	6800      	ldr	r0, [r0, #0]
 801cff2:	f7ff ffcb 	bl	801cf8c <_vsniprintf_r>
 801cff6:	bd0e      	pop	{r1, r2, r3, pc}
 801cff8:	20000038 	.word	0x20000038

0801cffc <__errno>:
 801cffc:	4b01      	ldr	r3, [pc, #4]	; (801d004 <__errno+0x8>)
 801cffe:	6818      	ldr	r0, [r3, #0]
 801d000:	4770      	bx	lr
 801d002:	46c0      	nop			; (mov r8, r8)
 801d004:	20000038 	.word	0x20000038

0801d008 <__retarget_lock_acquire_recursive>:
 801d008:	4770      	bx	lr

0801d00a <__retarget_lock_release_recursive>:
 801d00a:	4770      	bx	lr

0801d00c <__malloc_lock>:
 801d00c:	b510      	push	{r4, lr}
 801d00e:	4802      	ldr	r0, [pc, #8]	; (801d018 <__malloc_lock+0xc>)
 801d010:	f7ff fffa 	bl	801d008 <__retarget_lock_acquire_recursive>
 801d014:	bd10      	pop	{r4, pc}
 801d016:	46c0      	nop			; (mov r8, r8)
 801d018:	200041c4 	.word	0x200041c4

0801d01c <__malloc_unlock>:
 801d01c:	b510      	push	{r4, lr}
 801d01e:	4802      	ldr	r0, [pc, #8]	; (801d028 <__malloc_unlock+0xc>)
 801d020:	f7ff fff3 	bl	801d00a <__retarget_lock_release_recursive>
 801d024:	bd10      	pop	{r4, pc}
 801d026:	46c0      	nop			; (mov r8, r8)
 801d028:	200041c4 	.word	0x200041c4

0801d02c <__ssputs_r>:
 801d02c:	b5f0      	push	{r4, r5, r6, r7, lr}
 801d02e:	688e      	ldr	r6, [r1, #8]
 801d030:	b085      	sub	sp, #20
 801d032:	0007      	movs	r7, r0
 801d034:	000c      	movs	r4, r1
 801d036:	9203      	str	r2, [sp, #12]
 801d038:	9301      	str	r3, [sp, #4]
 801d03a:	429e      	cmp	r6, r3
 801d03c:	d83c      	bhi.n	801d0b8 <__ssputs_r+0x8c>
 801d03e:	2390      	movs	r3, #144	; 0x90
 801d040:	898a      	ldrh	r2, [r1, #12]
 801d042:	00db      	lsls	r3, r3, #3
 801d044:	421a      	tst	r2, r3
 801d046:	d034      	beq.n	801d0b2 <__ssputs_r+0x86>
 801d048:	2503      	movs	r5, #3
 801d04a:	6909      	ldr	r1, [r1, #16]
 801d04c:	6823      	ldr	r3, [r4, #0]
 801d04e:	1a5b      	subs	r3, r3, r1
 801d050:	9302      	str	r3, [sp, #8]
 801d052:	6963      	ldr	r3, [r4, #20]
 801d054:	9802      	ldr	r0, [sp, #8]
 801d056:	435d      	muls	r5, r3
 801d058:	0feb      	lsrs	r3, r5, #31
 801d05a:	195d      	adds	r5, r3, r5
 801d05c:	9b01      	ldr	r3, [sp, #4]
 801d05e:	106d      	asrs	r5, r5, #1
 801d060:	3301      	adds	r3, #1
 801d062:	181b      	adds	r3, r3, r0
 801d064:	42ab      	cmp	r3, r5
 801d066:	d900      	bls.n	801d06a <__ssputs_r+0x3e>
 801d068:	001d      	movs	r5, r3
 801d06a:	0553      	lsls	r3, r2, #21
 801d06c:	d532      	bpl.n	801d0d4 <__ssputs_r+0xa8>
 801d06e:	0029      	movs	r1, r5
 801d070:	0038      	movs	r0, r7
 801d072:	f7ff fe23 	bl	801ccbc <_malloc_r>
 801d076:	1e06      	subs	r6, r0, #0
 801d078:	d109      	bne.n	801d08e <__ssputs_r+0x62>
 801d07a:	230c      	movs	r3, #12
 801d07c:	603b      	str	r3, [r7, #0]
 801d07e:	2340      	movs	r3, #64	; 0x40
 801d080:	2001      	movs	r0, #1
 801d082:	89a2      	ldrh	r2, [r4, #12]
 801d084:	4240      	negs	r0, r0
 801d086:	4313      	orrs	r3, r2
 801d088:	81a3      	strh	r3, [r4, #12]
 801d08a:	b005      	add	sp, #20
 801d08c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801d08e:	9a02      	ldr	r2, [sp, #8]
 801d090:	6921      	ldr	r1, [r4, #16]
 801d092:	f7ff fda5 	bl	801cbe0 <memcpy>
 801d096:	89a3      	ldrh	r3, [r4, #12]
 801d098:	4a14      	ldr	r2, [pc, #80]	; (801d0ec <__ssputs_r+0xc0>)
 801d09a:	401a      	ands	r2, r3
 801d09c:	2380      	movs	r3, #128	; 0x80
 801d09e:	4313      	orrs	r3, r2
 801d0a0:	81a3      	strh	r3, [r4, #12]
 801d0a2:	9b02      	ldr	r3, [sp, #8]
 801d0a4:	6126      	str	r6, [r4, #16]
 801d0a6:	18f6      	adds	r6, r6, r3
 801d0a8:	6026      	str	r6, [r4, #0]
 801d0aa:	6165      	str	r5, [r4, #20]
 801d0ac:	9e01      	ldr	r6, [sp, #4]
 801d0ae:	1aed      	subs	r5, r5, r3
 801d0b0:	60a5      	str	r5, [r4, #8]
 801d0b2:	9b01      	ldr	r3, [sp, #4]
 801d0b4:	429e      	cmp	r6, r3
 801d0b6:	d900      	bls.n	801d0ba <__ssputs_r+0x8e>
 801d0b8:	9e01      	ldr	r6, [sp, #4]
 801d0ba:	0032      	movs	r2, r6
 801d0bc:	9903      	ldr	r1, [sp, #12]
 801d0be:	6820      	ldr	r0, [r4, #0]
 801d0c0:	f7ff fd97 	bl	801cbf2 <memmove>
 801d0c4:	68a3      	ldr	r3, [r4, #8]
 801d0c6:	2000      	movs	r0, #0
 801d0c8:	1b9b      	subs	r3, r3, r6
 801d0ca:	60a3      	str	r3, [r4, #8]
 801d0cc:	6823      	ldr	r3, [r4, #0]
 801d0ce:	199e      	adds	r6, r3, r6
 801d0d0:	6026      	str	r6, [r4, #0]
 801d0d2:	e7da      	b.n	801d08a <__ssputs_r+0x5e>
 801d0d4:	002a      	movs	r2, r5
 801d0d6:	0038      	movs	r0, r7
 801d0d8:	f000 fa97 	bl	801d60a <_realloc_r>
 801d0dc:	1e06      	subs	r6, r0, #0
 801d0de:	d1e0      	bne.n	801d0a2 <__ssputs_r+0x76>
 801d0e0:	0038      	movs	r0, r7
 801d0e2:	6921      	ldr	r1, [r4, #16]
 801d0e4:	f7ff fda0 	bl	801cc28 <_free_r>
 801d0e8:	e7c7      	b.n	801d07a <__ssputs_r+0x4e>
 801d0ea:	46c0      	nop			; (mov r8, r8)
 801d0ec:	fffffb7f 	.word	0xfffffb7f

0801d0f0 <_svfiprintf_r>:
 801d0f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 801d0f2:	b0a1      	sub	sp, #132	; 0x84
 801d0f4:	9003      	str	r0, [sp, #12]
 801d0f6:	001d      	movs	r5, r3
 801d0f8:	898b      	ldrh	r3, [r1, #12]
 801d0fa:	000f      	movs	r7, r1
 801d0fc:	0016      	movs	r6, r2
 801d0fe:	061b      	lsls	r3, r3, #24
 801d100:	d511      	bpl.n	801d126 <_svfiprintf_r+0x36>
 801d102:	690b      	ldr	r3, [r1, #16]
 801d104:	2b00      	cmp	r3, #0
 801d106:	d10e      	bne.n	801d126 <_svfiprintf_r+0x36>
 801d108:	2140      	movs	r1, #64	; 0x40
 801d10a:	f7ff fdd7 	bl	801ccbc <_malloc_r>
 801d10e:	6038      	str	r0, [r7, #0]
 801d110:	6138      	str	r0, [r7, #16]
 801d112:	2800      	cmp	r0, #0
 801d114:	d105      	bne.n	801d122 <_svfiprintf_r+0x32>
 801d116:	230c      	movs	r3, #12
 801d118:	9a03      	ldr	r2, [sp, #12]
 801d11a:	3801      	subs	r0, #1
 801d11c:	6013      	str	r3, [r2, #0]
 801d11e:	b021      	add	sp, #132	; 0x84
 801d120:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801d122:	2340      	movs	r3, #64	; 0x40
 801d124:	617b      	str	r3, [r7, #20]
 801d126:	2300      	movs	r3, #0
 801d128:	ac08      	add	r4, sp, #32
 801d12a:	6163      	str	r3, [r4, #20]
 801d12c:	3320      	adds	r3, #32
 801d12e:	7663      	strb	r3, [r4, #25]
 801d130:	3310      	adds	r3, #16
 801d132:	76a3      	strb	r3, [r4, #26]
 801d134:	9507      	str	r5, [sp, #28]
 801d136:	0035      	movs	r5, r6
 801d138:	782b      	ldrb	r3, [r5, #0]
 801d13a:	2b00      	cmp	r3, #0
 801d13c:	d001      	beq.n	801d142 <_svfiprintf_r+0x52>
 801d13e:	2b25      	cmp	r3, #37	; 0x25
 801d140:	d147      	bne.n	801d1d2 <_svfiprintf_r+0xe2>
 801d142:	1bab      	subs	r3, r5, r6
 801d144:	9305      	str	r3, [sp, #20]
 801d146:	42b5      	cmp	r5, r6
 801d148:	d00c      	beq.n	801d164 <_svfiprintf_r+0x74>
 801d14a:	0032      	movs	r2, r6
 801d14c:	0039      	movs	r1, r7
 801d14e:	9803      	ldr	r0, [sp, #12]
 801d150:	f7ff ff6c 	bl	801d02c <__ssputs_r>
 801d154:	1c43      	adds	r3, r0, #1
 801d156:	d100      	bne.n	801d15a <_svfiprintf_r+0x6a>
 801d158:	e0ae      	b.n	801d2b8 <_svfiprintf_r+0x1c8>
 801d15a:	6962      	ldr	r2, [r4, #20]
 801d15c:	9b05      	ldr	r3, [sp, #20]
 801d15e:	4694      	mov	ip, r2
 801d160:	4463      	add	r3, ip
 801d162:	6163      	str	r3, [r4, #20]
 801d164:	782b      	ldrb	r3, [r5, #0]
 801d166:	2b00      	cmp	r3, #0
 801d168:	d100      	bne.n	801d16c <_svfiprintf_r+0x7c>
 801d16a:	e0a5      	b.n	801d2b8 <_svfiprintf_r+0x1c8>
 801d16c:	2201      	movs	r2, #1
 801d16e:	2300      	movs	r3, #0
 801d170:	4252      	negs	r2, r2
 801d172:	6062      	str	r2, [r4, #4]
 801d174:	a904      	add	r1, sp, #16
 801d176:	3254      	adds	r2, #84	; 0x54
 801d178:	1852      	adds	r2, r2, r1
 801d17a:	1c6e      	adds	r6, r5, #1
 801d17c:	6023      	str	r3, [r4, #0]
 801d17e:	60e3      	str	r3, [r4, #12]
 801d180:	60a3      	str	r3, [r4, #8]
 801d182:	7013      	strb	r3, [r2, #0]
 801d184:	65a3      	str	r3, [r4, #88]	; 0x58
 801d186:	2205      	movs	r2, #5
 801d188:	7831      	ldrb	r1, [r6, #0]
 801d18a:	4854      	ldr	r0, [pc, #336]	; (801d2dc <_svfiprintf_r+0x1ec>)
 801d18c:	f000 fa32 	bl	801d5f4 <memchr>
 801d190:	1c75      	adds	r5, r6, #1
 801d192:	2800      	cmp	r0, #0
 801d194:	d11f      	bne.n	801d1d6 <_svfiprintf_r+0xe6>
 801d196:	6822      	ldr	r2, [r4, #0]
 801d198:	06d3      	lsls	r3, r2, #27
 801d19a:	d504      	bpl.n	801d1a6 <_svfiprintf_r+0xb6>
 801d19c:	2353      	movs	r3, #83	; 0x53
 801d19e:	a904      	add	r1, sp, #16
 801d1a0:	185b      	adds	r3, r3, r1
 801d1a2:	2120      	movs	r1, #32
 801d1a4:	7019      	strb	r1, [r3, #0]
 801d1a6:	0713      	lsls	r3, r2, #28
 801d1a8:	d504      	bpl.n	801d1b4 <_svfiprintf_r+0xc4>
 801d1aa:	2353      	movs	r3, #83	; 0x53
 801d1ac:	a904      	add	r1, sp, #16
 801d1ae:	185b      	adds	r3, r3, r1
 801d1b0:	212b      	movs	r1, #43	; 0x2b
 801d1b2:	7019      	strb	r1, [r3, #0]
 801d1b4:	7833      	ldrb	r3, [r6, #0]
 801d1b6:	2b2a      	cmp	r3, #42	; 0x2a
 801d1b8:	d016      	beq.n	801d1e8 <_svfiprintf_r+0xf8>
 801d1ba:	0035      	movs	r5, r6
 801d1bc:	2100      	movs	r1, #0
 801d1be:	200a      	movs	r0, #10
 801d1c0:	68e3      	ldr	r3, [r4, #12]
 801d1c2:	782a      	ldrb	r2, [r5, #0]
 801d1c4:	1c6e      	adds	r6, r5, #1
 801d1c6:	3a30      	subs	r2, #48	; 0x30
 801d1c8:	2a09      	cmp	r2, #9
 801d1ca:	d94e      	bls.n	801d26a <_svfiprintf_r+0x17a>
 801d1cc:	2900      	cmp	r1, #0
 801d1ce:	d111      	bne.n	801d1f4 <_svfiprintf_r+0x104>
 801d1d0:	e017      	b.n	801d202 <_svfiprintf_r+0x112>
 801d1d2:	3501      	adds	r5, #1
 801d1d4:	e7b0      	b.n	801d138 <_svfiprintf_r+0x48>
 801d1d6:	4b41      	ldr	r3, [pc, #260]	; (801d2dc <_svfiprintf_r+0x1ec>)
 801d1d8:	6822      	ldr	r2, [r4, #0]
 801d1da:	1ac0      	subs	r0, r0, r3
 801d1dc:	2301      	movs	r3, #1
 801d1de:	4083      	lsls	r3, r0
 801d1e0:	4313      	orrs	r3, r2
 801d1e2:	002e      	movs	r6, r5
 801d1e4:	6023      	str	r3, [r4, #0]
 801d1e6:	e7ce      	b.n	801d186 <_svfiprintf_r+0x96>
 801d1e8:	9b07      	ldr	r3, [sp, #28]
 801d1ea:	1d19      	adds	r1, r3, #4
 801d1ec:	681b      	ldr	r3, [r3, #0]
 801d1ee:	9107      	str	r1, [sp, #28]
 801d1f0:	2b00      	cmp	r3, #0
 801d1f2:	db01      	blt.n	801d1f8 <_svfiprintf_r+0x108>
 801d1f4:	930b      	str	r3, [sp, #44]	; 0x2c
 801d1f6:	e004      	b.n	801d202 <_svfiprintf_r+0x112>
 801d1f8:	425b      	negs	r3, r3
 801d1fa:	60e3      	str	r3, [r4, #12]
 801d1fc:	2302      	movs	r3, #2
 801d1fe:	4313      	orrs	r3, r2
 801d200:	6023      	str	r3, [r4, #0]
 801d202:	782b      	ldrb	r3, [r5, #0]
 801d204:	2b2e      	cmp	r3, #46	; 0x2e
 801d206:	d10a      	bne.n	801d21e <_svfiprintf_r+0x12e>
 801d208:	786b      	ldrb	r3, [r5, #1]
 801d20a:	2b2a      	cmp	r3, #42	; 0x2a
 801d20c:	d135      	bne.n	801d27a <_svfiprintf_r+0x18a>
 801d20e:	9b07      	ldr	r3, [sp, #28]
 801d210:	3502      	adds	r5, #2
 801d212:	1d1a      	adds	r2, r3, #4
 801d214:	681b      	ldr	r3, [r3, #0]
 801d216:	9207      	str	r2, [sp, #28]
 801d218:	2b00      	cmp	r3, #0
 801d21a:	db2b      	blt.n	801d274 <_svfiprintf_r+0x184>
 801d21c:	9309      	str	r3, [sp, #36]	; 0x24
 801d21e:	4e30      	ldr	r6, [pc, #192]	; (801d2e0 <_svfiprintf_r+0x1f0>)
 801d220:	2203      	movs	r2, #3
 801d222:	0030      	movs	r0, r6
 801d224:	7829      	ldrb	r1, [r5, #0]
 801d226:	f000 f9e5 	bl	801d5f4 <memchr>
 801d22a:	2800      	cmp	r0, #0
 801d22c:	d006      	beq.n	801d23c <_svfiprintf_r+0x14c>
 801d22e:	2340      	movs	r3, #64	; 0x40
 801d230:	1b80      	subs	r0, r0, r6
 801d232:	4083      	lsls	r3, r0
 801d234:	6822      	ldr	r2, [r4, #0]
 801d236:	3501      	adds	r5, #1
 801d238:	4313      	orrs	r3, r2
 801d23a:	6023      	str	r3, [r4, #0]
 801d23c:	7829      	ldrb	r1, [r5, #0]
 801d23e:	2206      	movs	r2, #6
 801d240:	4828      	ldr	r0, [pc, #160]	; (801d2e4 <_svfiprintf_r+0x1f4>)
 801d242:	1c6e      	adds	r6, r5, #1
 801d244:	7621      	strb	r1, [r4, #24]
 801d246:	f000 f9d5 	bl	801d5f4 <memchr>
 801d24a:	2800      	cmp	r0, #0
 801d24c:	d03c      	beq.n	801d2c8 <_svfiprintf_r+0x1d8>
 801d24e:	4b26      	ldr	r3, [pc, #152]	; (801d2e8 <_svfiprintf_r+0x1f8>)
 801d250:	2b00      	cmp	r3, #0
 801d252:	d125      	bne.n	801d2a0 <_svfiprintf_r+0x1b0>
 801d254:	2207      	movs	r2, #7
 801d256:	9b07      	ldr	r3, [sp, #28]
 801d258:	3307      	adds	r3, #7
 801d25a:	4393      	bics	r3, r2
 801d25c:	3308      	adds	r3, #8
 801d25e:	9307      	str	r3, [sp, #28]
 801d260:	6963      	ldr	r3, [r4, #20]
 801d262:	9a04      	ldr	r2, [sp, #16]
 801d264:	189b      	adds	r3, r3, r2
 801d266:	6163      	str	r3, [r4, #20]
 801d268:	e765      	b.n	801d136 <_svfiprintf_r+0x46>
 801d26a:	4343      	muls	r3, r0
 801d26c:	0035      	movs	r5, r6
 801d26e:	2101      	movs	r1, #1
 801d270:	189b      	adds	r3, r3, r2
 801d272:	e7a6      	b.n	801d1c2 <_svfiprintf_r+0xd2>
 801d274:	2301      	movs	r3, #1
 801d276:	425b      	negs	r3, r3
 801d278:	e7d0      	b.n	801d21c <_svfiprintf_r+0x12c>
 801d27a:	2300      	movs	r3, #0
 801d27c:	200a      	movs	r0, #10
 801d27e:	001a      	movs	r2, r3
 801d280:	3501      	adds	r5, #1
 801d282:	6063      	str	r3, [r4, #4]
 801d284:	7829      	ldrb	r1, [r5, #0]
 801d286:	1c6e      	adds	r6, r5, #1
 801d288:	3930      	subs	r1, #48	; 0x30
 801d28a:	2909      	cmp	r1, #9
 801d28c:	d903      	bls.n	801d296 <_svfiprintf_r+0x1a6>
 801d28e:	2b00      	cmp	r3, #0
 801d290:	d0c5      	beq.n	801d21e <_svfiprintf_r+0x12e>
 801d292:	9209      	str	r2, [sp, #36]	; 0x24
 801d294:	e7c3      	b.n	801d21e <_svfiprintf_r+0x12e>
 801d296:	4342      	muls	r2, r0
 801d298:	0035      	movs	r5, r6
 801d29a:	2301      	movs	r3, #1
 801d29c:	1852      	adds	r2, r2, r1
 801d29e:	e7f1      	b.n	801d284 <_svfiprintf_r+0x194>
 801d2a0:	ab07      	add	r3, sp, #28
 801d2a2:	9300      	str	r3, [sp, #0]
 801d2a4:	003a      	movs	r2, r7
 801d2a6:	0021      	movs	r1, r4
 801d2a8:	4b10      	ldr	r3, [pc, #64]	; (801d2ec <_svfiprintf_r+0x1fc>)
 801d2aa:	9803      	ldr	r0, [sp, #12]
 801d2ac:	e000      	b.n	801d2b0 <_svfiprintf_r+0x1c0>
 801d2ae:	bf00      	nop
 801d2b0:	9004      	str	r0, [sp, #16]
 801d2b2:	9b04      	ldr	r3, [sp, #16]
 801d2b4:	3301      	adds	r3, #1
 801d2b6:	d1d3      	bne.n	801d260 <_svfiprintf_r+0x170>
 801d2b8:	89bb      	ldrh	r3, [r7, #12]
 801d2ba:	980d      	ldr	r0, [sp, #52]	; 0x34
 801d2bc:	065b      	lsls	r3, r3, #25
 801d2be:	d400      	bmi.n	801d2c2 <_svfiprintf_r+0x1d2>
 801d2c0:	e72d      	b.n	801d11e <_svfiprintf_r+0x2e>
 801d2c2:	2001      	movs	r0, #1
 801d2c4:	4240      	negs	r0, r0
 801d2c6:	e72a      	b.n	801d11e <_svfiprintf_r+0x2e>
 801d2c8:	ab07      	add	r3, sp, #28
 801d2ca:	9300      	str	r3, [sp, #0]
 801d2cc:	003a      	movs	r2, r7
 801d2ce:	0021      	movs	r1, r4
 801d2d0:	4b06      	ldr	r3, [pc, #24]	; (801d2ec <_svfiprintf_r+0x1fc>)
 801d2d2:	9803      	ldr	r0, [sp, #12]
 801d2d4:	f000 f87c 	bl	801d3d0 <_printf_i>
 801d2d8:	e7ea      	b.n	801d2b0 <_svfiprintf_r+0x1c0>
 801d2da:	46c0      	nop			; (mov r8, r8)
 801d2dc:	08022b49 	.word	0x08022b49
 801d2e0:	08022b4f 	.word	0x08022b4f
 801d2e4:	08022b53 	.word	0x08022b53
 801d2e8:	00000000 	.word	0x00000000
 801d2ec:	0801d02d 	.word	0x0801d02d

0801d2f0 <_printf_common>:
 801d2f0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 801d2f2:	0015      	movs	r5, r2
 801d2f4:	9301      	str	r3, [sp, #4]
 801d2f6:	688a      	ldr	r2, [r1, #8]
 801d2f8:	690b      	ldr	r3, [r1, #16]
 801d2fa:	000c      	movs	r4, r1
 801d2fc:	9000      	str	r0, [sp, #0]
 801d2fe:	4293      	cmp	r3, r2
 801d300:	da00      	bge.n	801d304 <_printf_common+0x14>
 801d302:	0013      	movs	r3, r2
 801d304:	0022      	movs	r2, r4
 801d306:	602b      	str	r3, [r5, #0]
 801d308:	3243      	adds	r2, #67	; 0x43
 801d30a:	7812      	ldrb	r2, [r2, #0]
 801d30c:	2a00      	cmp	r2, #0
 801d30e:	d001      	beq.n	801d314 <_printf_common+0x24>
 801d310:	3301      	adds	r3, #1
 801d312:	602b      	str	r3, [r5, #0]
 801d314:	6823      	ldr	r3, [r4, #0]
 801d316:	069b      	lsls	r3, r3, #26
 801d318:	d502      	bpl.n	801d320 <_printf_common+0x30>
 801d31a:	682b      	ldr	r3, [r5, #0]
 801d31c:	3302      	adds	r3, #2
 801d31e:	602b      	str	r3, [r5, #0]
 801d320:	6822      	ldr	r2, [r4, #0]
 801d322:	2306      	movs	r3, #6
 801d324:	0017      	movs	r7, r2
 801d326:	401f      	ands	r7, r3
 801d328:	421a      	tst	r2, r3
 801d32a:	d027      	beq.n	801d37c <_printf_common+0x8c>
 801d32c:	0023      	movs	r3, r4
 801d32e:	3343      	adds	r3, #67	; 0x43
 801d330:	781b      	ldrb	r3, [r3, #0]
 801d332:	1e5a      	subs	r2, r3, #1
 801d334:	4193      	sbcs	r3, r2
 801d336:	6822      	ldr	r2, [r4, #0]
 801d338:	0692      	lsls	r2, r2, #26
 801d33a:	d430      	bmi.n	801d39e <_printf_common+0xae>
 801d33c:	0022      	movs	r2, r4
 801d33e:	9901      	ldr	r1, [sp, #4]
 801d340:	9800      	ldr	r0, [sp, #0]
 801d342:	9e08      	ldr	r6, [sp, #32]
 801d344:	3243      	adds	r2, #67	; 0x43
 801d346:	47b0      	blx	r6
 801d348:	1c43      	adds	r3, r0, #1
 801d34a:	d025      	beq.n	801d398 <_printf_common+0xa8>
 801d34c:	2306      	movs	r3, #6
 801d34e:	6820      	ldr	r0, [r4, #0]
 801d350:	682a      	ldr	r2, [r5, #0]
 801d352:	68e1      	ldr	r1, [r4, #12]
 801d354:	2500      	movs	r5, #0
 801d356:	4003      	ands	r3, r0
 801d358:	2b04      	cmp	r3, #4
 801d35a:	d103      	bne.n	801d364 <_printf_common+0x74>
 801d35c:	1a8d      	subs	r5, r1, r2
 801d35e:	43eb      	mvns	r3, r5
 801d360:	17db      	asrs	r3, r3, #31
 801d362:	401d      	ands	r5, r3
 801d364:	68a3      	ldr	r3, [r4, #8]
 801d366:	6922      	ldr	r2, [r4, #16]
 801d368:	4293      	cmp	r3, r2
 801d36a:	dd01      	ble.n	801d370 <_printf_common+0x80>
 801d36c:	1a9b      	subs	r3, r3, r2
 801d36e:	18ed      	adds	r5, r5, r3
 801d370:	2700      	movs	r7, #0
 801d372:	42bd      	cmp	r5, r7
 801d374:	d120      	bne.n	801d3b8 <_printf_common+0xc8>
 801d376:	2000      	movs	r0, #0
 801d378:	e010      	b.n	801d39c <_printf_common+0xac>
 801d37a:	3701      	adds	r7, #1
 801d37c:	68e3      	ldr	r3, [r4, #12]
 801d37e:	682a      	ldr	r2, [r5, #0]
 801d380:	1a9b      	subs	r3, r3, r2
 801d382:	42bb      	cmp	r3, r7
 801d384:	ddd2      	ble.n	801d32c <_printf_common+0x3c>
 801d386:	0022      	movs	r2, r4
 801d388:	2301      	movs	r3, #1
 801d38a:	9901      	ldr	r1, [sp, #4]
 801d38c:	9800      	ldr	r0, [sp, #0]
 801d38e:	9e08      	ldr	r6, [sp, #32]
 801d390:	3219      	adds	r2, #25
 801d392:	47b0      	blx	r6
 801d394:	1c43      	adds	r3, r0, #1
 801d396:	d1f0      	bne.n	801d37a <_printf_common+0x8a>
 801d398:	2001      	movs	r0, #1
 801d39a:	4240      	negs	r0, r0
 801d39c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 801d39e:	2030      	movs	r0, #48	; 0x30
 801d3a0:	18e1      	adds	r1, r4, r3
 801d3a2:	3143      	adds	r1, #67	; 0x43
 801d3a4:	7008      	strb	r0, [r1, #0]
 801d3a6:	0021      	movs	r1, r4
 801d3a8:	1c5a      	adds	r2, r3, #1
 801d3aa:	3145      	adds	r1, #69	; 0x45
 801d3ac:	7809      	ldrb	r1, [r1, #0]
 801d3ae:	18a2      	adds	r2, r4, r2
 801d3b0:	3243      	adds	r2, #67	; 0x43
 801d3b2:	3302      	adds	r3, #2
 801d3b4:	7011      	strb	r1, [r2, #0]
 801d3b6:	e7c1      	b.n	801d33c <_printf_common+0x4c>
 801d3b8:	0022      	movs	r2, r4
 801d3ba:	2301      	movs	r3, #1
 801d3bc:	9901      	ldr	r1, [sp, #4]
 801d3be:	9800      	ldr	r0, [sp, #0]
 801d3c0:	9e08      	ldr	r6, [sp, #32]
 801d3c2:	321a      	adds	r2, #26
 801d3c4:	47b0      	blx	r6
 801d3c6:	1c43      	adds	r3, r0, #1
 801d3c8:	d0e6      	beq.n	801d398 <_printf_common+0xa8>
 801d3ca:	3701      	adds	r7, #1
 801d3cc:	e7d1      	b.n	801d372 <_printf_common+0x82>
	...

0801d3d0 <_printf_i>:
 801d3d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 801d3d2:	b08b      	sub	sp, #44	; 0x2c
 801d3d4:	9206      	str	r2, [sp, #24]
 801d3d6:	000a      	movs	r2, r1
 801d3d8:	3243      	adds	r2, #67	; 0x43
 801d3da:	9307      	str	r3, [sp, #28]
 801d3dc:	9005      	str	r0, [sp, #20]
 801d3de:	9204      	str	r2, [sp, #16]
 801d3e0:	7e0a      	ldrb	r2, [r1, #24]
 801d3e2:	000c      	movs	r4, r1
 801d3e4:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801d3e6:	2a78      	cmp	r2, #120	; 0x78
 801d3e8:	d806      	bhi.n	801d3f8 <_printf_i+0x28>
 801d3ea:	2a62      	cmp	r2, #98	; 0x62
 801d3ec:	d808      	bhi.n	801d400 <_printf_i+0x30>
 801d3ee:	2a00      	cmp	r2, #0
 801d3f0:	d100      	bne.n	801d3f4 <_printf_i+0x24>
 801d3f2:	e0c0      	b.n	801d576 <_printf_i+0x1a6>
 801d3f4:	2a58      	cmp	r2, #88	; 0x58
 801d3f6:	d052      	beq.n	801d49e <_printf_i+0xce>
 801d3f8:	0026      	movs	r6, r4
 801d3fa:	3642      	adds	r6, #66	; 0x42
 801d3fc:	7032      	strb	r2, [r6, #0]
 801d3fe:	e022      	b.n	801d446 <_printf_i+0x76>
 801d400:	0010      	movs	r0, r2
 801d402:	3863      	subs	r0, #99	; 0x63
 801d404:	2815      	cmp	r0, #21
 801d406:	d8f7      	bhi.n	801d3f8 <_printf_i+0x28>
 801d408:	f7e2 fe86 	bl	8000118 <__gnu_thumb1_case_shi>
 801d40c:	001f0016 	.word	0x001f0016
 801d410:	fff6fff6 	.word	0xfff6fff6
 801d414:	fff6fff6 	.word	0xfff6fff6
 801d418:	fff6001f 	.word	0xfff6001f
 801d41c:	fff6fff6 	.word	0xfff6fff6
 801d420:	00a8fff6 	.word	0x00a8fff6
 801d424:	009a0036 	.word	0x009a0036
 801d428:	fff6fff6 	.word	0xfff6fff6
 801d42c:	fff600b9 	.word	0xfff600b9
 801d430:	fff60036 	.word	0xfff60036
 801d434:	009efff6 	.word	0x009efff6
 801d438:	0026      	movs	r6, r4
 801d43a:	681a      	ldr	r2, [r3, #0]
 801d43c:	3642      	adds	r6, #66	; 0x42
 801d43e:	1d11      	adds	r1, r2, #4
 801d440:	6019      	str	r1, [r3, #0]
 801d442:	6813      	ldr	r3, [r2, #0]
 801d444:	7033      	strb	r3, [r6, #0]
 801d446:	2301      	movs	r3, #1
 801d448:	e0a7      	b.n	801d59a <_printf_i+0x1ca>
 801d44a:	6808      	ldr	r0, [r1, #0]
 801d44c:	6819      	ldr	r1, [r3, #0]
 801d44e:	1d0a      	adds	r2, r1, #4
 801d450:	0605      	lsls	r5, r0, #24
 801d452:	d50b      	bpl.n	801d46c <_printf_i+0x9c>
 801d454:	680d      	ldr	r5, [r1, #0]
 801d456:	601a      	str	r2, [r3, #0]
 801d458:	2d00      	cmp	r5, #0
 801d45a:	da03      	bge.n	801d464 <_printf_i+0x94>
 801d45c:	232d      	movs	r3, #45	; 0x2d
 801d45e:	9a04      	ldr	r2, [sp, #16]
 801d460:	426d      	negs	r5, r5
 801d462:	7013      	strb	r3, [r2, #0]
 801d464:	4b61      	ldr	r3, [pc, #388]	; (801d5ec <_printf_i+0x21c>)
 801d466:	270a      	movs	r7, #10
 801d468:	9303      	str	r3, [sp, #12]
 801d46a:	e032      	b.n	801d4d2 <_printf_i+0x102>
 801d46c:	680d      	ldr	r5, [r1, #0]
 801d46e:	601a      	str	r2, [r3, #0]
 801d470:	0641      	lsls	r1, r0, #25
 801d472:	d5f1      	bpl.n	801d458 <_printf_i+0x88>
 801d474:	b22d      	sxth	r5, r5
 801d476:	e7ef      	b.n	801d458 <_printf_i+0x88>
 801d478:	680d      	ldr	r5, [r1, #0]
 801d47a:	6819      	ldr	r1, [r3, #0]
 801d47c:	1d08      	adds	r0, r1, #4
 801d47e:	6018      	str	r0, [r3, #0]
 801d480:	062e      	lsls	r6, r5, #24
 801d482:	d501      	bpl.n	801d488 <_printf_i+0xb8>
 801d484:	680d      	ldr	r5, [r1, #0]
 801d486:	e003      	b.n	801d490 <_printf_i+0xc0>
 801d488:	066d      	lsls	r5, r5, #25
 801d48a:	d5fb      	bpl.n	801d484 <_printf_i+0xb4>
 801d48c:	680d      	ldr	r5, [r1, #0]
 801d48e:	b2ad      	uxth	r5, r5
 801d490:	4b56      	ldr	r3, [pc, #344]	; (801d5ec <_printf_i+0x21c>)
 801d492:	270a      	movs	r7, #10
 801d494:	9303      	str	r3, [sp, #12]
 801d496:	2a6f      	cmp	r2, #111	; 0x6f
 801d498:	d117      	bne.n	801d4ca <_printf_i+0xfa>
 801d49a:	2708      	movs	r7, #8
 801d49c:	e015      	b.n	801d4ca <_printf_i+0xfa>
 801d49e:	3145      	adds	r1, #69	; 0x45
 801d4a0:	700a      	strb	r2, [r1, #0]
 801d4a2:	4a52      	ldr	r2, [pc, #328]	; (801d5ec <_printf_i+0x21c>)
 801d4a4:	9203      	str	r2, [sp, #12]
 801d4a6:	681a      	ldr	r2, [r3, #0]
 801d4a8:	6821      	ldr	r1, [r4, #0]
 801d4aa:	ca20      	ldmia	r2!, {r5}
 801d4ac:	601a      	str	r2, [r3, #0]
 801d4ae:	0608      	lsls	r0, r1, #24
 801d4b0:	d550      	bpl.n	801d554 <_printf_i+0x184>
 801d4b2:	07cb      	lsls	r3, r1, #31
 801d4b4:	d502      	bpl.n	801d4bc <_printf_i+0xec>
 801d4b6:	2320      	movs	r3, #32
 801d4b8:	4319      	orrs	r1, r3
 801d4ba:	6021      	str	r1, [r4, #0]
 801d4bc:	2710      	movs	r7, #16
 801d4be:	2d00      	cmp	r5, #0
 801d4c0:	d103      	bne.n	801d4ca <_printf_i+0xfa>
 801d4c2:	2320      	movs	r3, #32
 801d4c4:	6822      	ldr	r2, [r4, #0]
 801d4c6:	439a      	bics	r2, r3
 801d4c8:	6022      	str	r2, [r4, #0]
 801d4ca:	0023      	movs	r3, r4
 801d4cc:	2200      	movs	r2, #0
 801d4ce:	3343      	adds	r3, #67	; 0x43
 801d4d0:	701a      	strb	r2, [r3, #0]
 801d4d2:	6863      	ldr	r3, [r4, #4]
 801d4d4:	60a3      	str	r3, [r4, #8]
 801d4d6:	2b00      	cmp	r3, #0
 801d4d8:	db03      	blt.n	801d4e2 <_printf_i+0x112>
 801d4da:	2204      	movs	r2, #4
 801d4dc:	6821      	ldr	r1, [r4, #0]
 801d4de:	4391      	bics	r1, r2
 801d4e0:	6021      	str	r1, [r4, #0]
 801d4e2:	2d00      	cmp	r5, #0
 801d4e4:	d102      	bne.n	801d4ec <_printf_i+0x11c>
 801d4e6:	9e04      	ldr	r6, [sp, #16]
 801d4e8:	2b00      	cmp	r3, #0
 801d4ea:	d00c      	beq.n	801d506 <_printf_i+0x136>
 801d4ec:	9e04      	ldr	r6, [sp, #16]
 801d4ee:	0028      	movs	r0, r5
 801d4f0:	0039      	movs	r1, r7
 801d4f2:	f7e2 fea1 	bl	8000238 <__aeabi_uidivmod>
 801d4f6:	9b03      	ldr	r3, [sp, #12]
 801d4f8:	3e01      	subs	r6, #1
 801d4fa:	5c5b      	ldrb	r3, [r3, r1]
 801d4fc:	7033      	strb	r3, [r6, #0]
 801d4fe:	002b      	movs	r3, r5
 801d500:	0005      	movs	r5, r0
 801d502:	429f      	cmp	r7, r3
 801d504:	d9f3      	bls.n	801d4ee <_printf_i+0x11e>
 801d506:	2f08      	cmp	r7, #8
 801d508:	d109      	bne.n	801d51e <_printf_i+0x14e>
 801d50a:	6823      	ldr	r3, [r4, #0]
 801d50c:	07db      	lsls	r3, r3, #31
 801d50e:	d506      	bpl.n	801d51e <_printf_i+0x14e>
 801d510:	6863      	ldr	r3, [r4, #4]
 801d512:	6922      	ldr	r2, [r4, #16]
 801d514:	4293      	cmp	r3, r2
 801d516:	dc02      	bgt.n	801d51e <_printf_i+0x14e>
 801d518:	2330      	movs	r3, #48	; 0x30
 801d51a:	3e01      	subs	r6, #1
 801d51c:	7033      	strb	r3, [r6, #0]
 801d51e:	9b04      	ldr	r3, [sp, #16]
 801d520:	1b9b      	subs	r3, r3, r6
 801d522:	6123      	str	r3, [r4, #16]
 801d524:	9b07      	ldr	r3, [sp, #28]
 801d526:	0021      	movs	r1, r4
 801d528:	9300      	str	r3, [sp, #0]
 801d52a:	9805      	ldr	r0, [sp, #20]
 801d52c:	9b06      	ldr	r3, [sp, #24]
 801d52e:	aa09      	add	r2, sp, #36	; 0x24
 801d530:	f7ff fede 	bl	801d2f0 <_printf_common>
 801d534:	1c43      	adds	r3, r0, #1
 801d536:	d135      	bne.n	801d5a4 <_printf_i+0x1d4>
 801d538:	2001      	movs	r0, #1
 801d53a:	4240      	negs	r0, r0
 801d53c:	b00b      	add	sp, #44	; 0x2c
 801d53e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801d540:	2220      	movs	r2, #32
 801d542:	6809      	ldr	r1, [r1, #0]
 801d544:	430a      	orrs	r2, r1
 801d546:	6022      	str	r2, [r4, #0]
 801d548:	0022      	movs	r2, r4
 801d54a:	2178      	movs	r1, #120	; 0x78
 801d54c:	3245      	adds	r2, #69	; 0x45
 801d54e:	7011      	strb	r1, [r2, #0]
 801d550:	4a27      	ldr	r2, [pc, #156]	; (801d5f0 <_printf_i+0x220>)
 801d552:	e7a7      	b.n	801d4a4 <_printf_i+0xd4>
 801d554:	0648      	lsls	r0, r1, #25
 801d556:	d5ac      	bpl.n	801d4b2 <_printf_i+0xe2>
 801d558:	b2ad      	uxth	r5, r5
 801d55a:	e7aa      	b.n	801d4b2 <_printf_i+0xe2>
 801d55c:	681a      	ldr	r2, [r3, #0]
 801d55e:	680d      	ldr	r5, [r1, #0]
 801d560:	1d10      	adds	r0, r2, #4
 801d562:	6949      	ldr	r1, [r1, #20]
 801d564:	6018      	str	r0, [r3, #0]
 801d566:	6813      	ldr	r3, [r2, #0]
 801d568:	062e      	lsls	r6, r5, #24
 801d56a:	d501      	bpl.n	801d570 <_printf_i+0x1a0>
 801d56c:	6019      	str	r1, [r3, #0]
 801d56e:	e002      	b.n	801d576 <_printf_i+0x1a6>
 801d570:	066d      	lsls	r5, r5, #25
 801d572:	d5fb      	bpl.n	801d56c <_printf_i+0x19c>
 801d574:	8019      	strh	r1, [r3, #0]
 801d576:	2300      	movs	r3, #0
 801d578:	9e04      	ldr	r6, [sp, #16]
 801d57a:	6123      	str	r3, [r4, #16]
 801d57c:	e7d2      	b.n	801d524 <_printf_i+0x154>
 801d57e:	681a      	ldr	r2, [r3, #0]
 801d580:	1d11      	adds	r1, r2, #4
 801d582:	6019      	str	r1, [r3, #0]
 801d584:	6816      	ldr	r6, [r2, #0]
 801d586:	2100      	movs	r1, #0
 801d588:	0030      	movs	r0, r6
 801d58a:	6862      	ldr	r2, [r4, #4]
 801d58c:	f000 f832 	bl	801d5f4 <memchr>
 801d590:	2800      	cmp	r0, #0
 801d592:	d001      	beq.n	801d598 <_printf_i+0x1c8>
 801d594:	1b80      	subs	r0, r0, r6
 801d596:	6060      	str	r0, [r4, #4]
 801d598:	6863      	ldr	r3, [r4, #4]
 801d59a:	6123      	str	r3, [r4, #16]
 801d59c:	2300      	movs	r3, #0
 801d59e:	9a04      	ldr	r2, [sp, #16]
 801d5a0:	7013      	strb	r3, [r2, #0]
 801d5a2:	e7bf      	b.n	801d524 <_printf_i+0x154>
 801d5a4:	6923      	ldr	r3, [r4, #16]
 801d5a6:	0032      	movs	r2, r6
 801d5a8:	9906      	ldr	r1, [sp, #24]
 801d5aa:	9805      	ldr	r0, [sp, #20]
 801d5ac:	9d07      	ldr	r5, [sp, #28]
 801d5ae:	47a8      	blx	r5
 801d5b0:	1c43      	adds	r3, r0, #1
 801d5b2:	d0c1      	beq.n	801d538 <_printf_i+0x168>
 801d5b4:	6823      	ldr	r3, [r4, #0]
 801d5b6:	079b      	lsls	r3, r3, #30
 801d5b8:	d415      	bmi.n	801d5e6 <_printf_i+0x216>
 801d5ba:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801d5bc:	68e0      	ldr	r0, [r4, #12]
 801d5be:	4298      	cmp	r0, r3
 801d5c0:	dabc      	bge.n	801d53c <_printf_i+0x16c>
 801d5c2:	0018      	movs	r0, r3
 801d5c4:	e7ba      	b.n	801d53c <_printf_i+0x16c>
 801d5c6:	0022      	movs	r2, r4
 801d5c8:	2301      	movs	r3, #1
 801d5ca:	9906      	ldr	r1, [sp, #24]
 801d5cc:	9805      	ldr	r0, [sp, #20]
 801d5ce:	9e07      	ldr	r6, [sp, #28]
 801d5d0:	3219      	adds	r2, #25
 801d5d2:	47b0      	blx	r6
 801d5d4:	1c43      	adds	r3, r0, #1
 801d5d6:	d0af      	beq.n	801d538 <_printf_i+0x168>
 801d5d8:	3501      	adds	r5, #1
 801d5da:	68e3      	ldr	r3, [r4, #12]
 801d5dc:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801d5de:	1a9b      	subs	r3, r3, r2
 801d5e0:	42ab      	cmp	r3, r5
 801d5e2:	dcf0      	bgt.n	801d5c6 <_printf_i+0x1f6>
 801d5e4:	e7e9      	b.n	801d5ba <_printf_i+0x1ea>
 801d5e6:	2500      	movs	r5, #0
 801d5e8:	e7f7      	b.n	801d5da <_printf_i+0x20a>
 801d5ea:	46c0      	nop			; (mov r8, r8)
 801d5ec:	08022b5a 	.word	0x08022b5a
 801d5f0:	08022b6b 	.word	0x08022b6b

0801d5f4 <memchr>:
 801d5f4:	b2c9      	uxtb	r1, r1
 801d5f6:	1882      	adds	r2, r0, r2
 801d5f8:	4290      	cmp	r0, r2
 801d5fa:	d101      	bne.n	801d600 <memchr+0xc>
 801d5fc:	2000      	movs	r0, #0
 801d5fe:	4770      	bx	lr
 801d600:	7803      	ldrb	r3, [r0, #0]
 801d602:	428b      	cmp	r3, r1
 801d604:	d0fb      	beq.n	801d5fe <memchr+0xa>
 801d606:	3001      	adds	r0, #1
 801d608:	e7f6      	b.n	801d5f8 <memchr+0x4>

0801d60a <_realloc_r>:
 801d60a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801d60c:	0007      	movs	r7, r0
 801d60e:	000d      	movs	r5, r1
 801d610:	0016      	movs	r6, r2
 801d612:	2900      	cmp	r1, #0
 801d614:	d105      	bne.n	801d622 <_realloc_r+0x18>
 801d616:	0011      	movs	r1, r2
 801d618:	f7ff fb50 	bl	801ccbc <_malloc_r>
 801d61c:	0004      	movs	r4, r0
 801d61e:	0020      	movs	r0, r4
 801d620:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801d622:	2a00      	cmp	r2, #0
 801d624:	d103      	bne.n	801d62e <_realloc_r+0x24>
 801d626:	f7ff faff 	bl	801cc28 <_free_r>
 801d62a:	0034      	movs	r4, r6
 801d62c:	e7f7      	b.n	801d61e <_realloc_r+0x14>
 801d62e:	f000 f812 	bl	801d656 <_malloc_usable_size_r>
 801d632:	002c      	movs	r4, r5
 801d634:	42b0      	cmp	r0, r6
 801d636:	d2f2      	bcs.n	801d61e <_realloc_r+0x14>
 801d638:	0031      	movs	r1, r6
 801d63a:	0038      	movs	r0, r7
 801d63c:	f7ff fb3e 	bl	801ccbc <_malloc_r>
 801d640:	1e04      	subs	r4, r0, #0
 801d642:	d0ec      	beq.n	801d61e <_realloc_r+0x14>
 801d644:	0029      	movs	r1, r5
 801d646:	0032      	movs	r2, r6
 801d648:	f7ff faca 	bl	801cbe0 <memcpy>
 801d64c:	0029      	movs	r1, r5
 801d64e:	0038      	movs	r0, r7
 801d650:	f7ff faea 	bl	801cc28 <_free_r>
 801d654:	e7e3      	b.n	801d61e <_realloc_r+0x14>

0801d656 <_malloc_usable_size_r>:
 801d656:	1f0b      	subs	r3, r1, #4
 801d658:	681b      	ldr	r3, [r3, #0]
 801d65a:	1f18      	subs	r0, r3, #4
 801d65c:	2b00      	cmp	r3, #0
 801d65e:	da01      	bge.n	801d664 <_malloc_usable_size_r+0xe>
 801d660:	580b      	ldr	r3, [r1, r0]
 801d662:	18c0      	adds	r0, r0, r3
 801d664:	4770      	bx	lr
	...

0801d668 <_init>:
 801d668:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801d66a:	46c0      	nop			; (mov r8, r8)
 801d66c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801d66e:	bc08      	pop	{r3}
 801d670:	469e      	mov	lr, r3
 801d672:	4770      	bx	lr

0801d674 <_fini>:
 801d674:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801d676:	46c0      	nop			; (mov r8, r8)
 801d678:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801d67a:	bc08      	pop	{r3}
 801d67c:	469e      	mov	lr, r3
 801d67e:	4770      	bx	lr

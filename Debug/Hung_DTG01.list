
Hung_DTG01.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000c0  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0001d8ac  080000c0  080000c0  000100c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000568c  0801d96c  0801d96c  0002d96c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08022ff8  08022ff8  0004009c  2**0
                  CONTENTS
  4 .ARM          00000008  08022ff8  08022ff8  00032ff8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  08023000  08023000  0004009c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08023000  08023000  00033000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08023004  08023004  00033004  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         0000009c  20000000  08023008  00040000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00003d98  2000009c  080230a4  0004009c  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  20003e34  080230a4  00043e34  2**0
                  ALLOC
 11 .ARM.attributes 00000028  00000000  00000000  0004009c  2**0
                  CONTENTS, READONLY
 12 .debug_info   0005405b  00000000  00000000  000400c4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 00008cfe  00000000  00000000  0009411f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00001ba8  00000000  00000000  0009ce20  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_ranges 00001ba0  00000000  00000000  0009e9c8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  000225b0  00000000  00000000  000a0568  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   00033248  00000000  00000000  000c2b18  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    00089d94  00000000  00000000  000f5d60  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000053  00000000  00000000  0017faf4  2**0
                  CONTENTS, READONLY
 20 .debug_frame  000065cc  00000000  00000000  0017fb48  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080000c0 <__do_global_dtors_aux>:
 80000c0:	b510      	push	{r4, lr}
 80000c2:	4c06      	ldr	r4, [pc, #24]	; (80000dc <__do_global_dtors_aux+0x1c>)
 80000c4:	7823      	ldrb	r3, [r4, #0]
 80000c6:	2b00      	cmp	r3, #0
 80000c8:	d107      	bne.n	80000da <__do_global_dtors_aux+0x1a>
 80000ca:	4b05      	ldr	r3, [pc, #20]	; (80000e0 <__do_global_dtors_aux+0x20>)
 80000cc:	2b00      	cmp	r3, #0
 80000ce:	d002      	beq.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d0:	4804      	ldr	r0, [pc, #16]	; (80000e4 <__do_global_dtors_aux+0x24>)
 80000d2:	e000      	b.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d4:	bf00      	nop
 80000d6:	2301      	movs	r3, #1
 80000d8:	7023      	strb	r3, [r4, #0]
 80000da:	bd10      	pop	{r4, pc}
 80000dc:	2000009c 	.word	0x2000009c
 80000e0:	00000000 	.word	0x00000000
 80000e4:	0801d954 	.word	0x0801d954

080000e8 <frame_dummy>:
 80000e8:	4b04      	ldr	r3, [pc, #16]	; (80000fc <frame_dummy+0x14>)
 80000ea:	b510      	push	{r4, lr}
 80000ec:	2b00      	cmp	r3, #0
 80000ee:	d003      	beq.n	80000f8 <frame_dummy+0x10>
 80000f0:	4903      	ldr	r1, [pc, #12]	; (8000100 <frame_dummy+0x18>)
 80000f2:	4804      	ldr	r0, [pc, #16]	; (8000104 <frame_dummy+0x1c>)
 80000f4:	e000      	b.n	80000f8 <frame_dummy+0x10>
 80000f6:	bf00      	nop
 80000f8:	bd10      	pop	{r4, pc}
 80000fa:	46c0      	nop			; (mov r8, r8)
 80000fc:	00000000 	.word	0x00000000
 8000100:	200000a0 	.word	0x200000a0
 8000104:	0801d954 	.word	0x0801d954

08000108 <strlen>:
 8000108:	2300      	movs	r3, #0
 800010a:	5cc2      	ldrb	r2, [r0, r3]
 800010c:	3301      	adds	r3, #1
 800010e:	2a00      	cmp	r2, #0
 8000110:	d1fb      	bne.n	800010a <strlen+0x2>
 8000112:	1e58      	subs	r0, r3, #1
 8000114:	4770      	bx	lr
	...

08000118 <__gnu_thumb1_case_shi>:
 8000118:	b403      	push	{r0, r1}
 800011a:	4671      	mov	r1, lr
 800011c:	0849      	lsrs	r1, r1, #1
 800011e:	0040      	lsls	r0, r0, #1
 8000120:	0049      	lsls	r1, r1, #1
 8000122:	5e09      	ldrsh	r1, [r1, r0]
 8000124:	0049      	lsls	r1, r1, #1
 8000126:	448e      	add	lr, r1
 8000128:	bc03      	pop	{r0, r1}
 800012a:	4770      	bx	lr

0800012c <__udivsi3>:
 800012c:	2200      	movs	r2, #0
 800012e:	0843      	lsrs	r3, r0, #1
 8000130:	428b      	cmp	r3, r1
 8000132:	d374      	bcc.n	800021e <__udivsi3+0xf2>
 8000134:	0903      	lsrs	r3, r0, #4
 8000136:	428b      	cmp	r3, r1
 8000138:	d35f      	bcc.n	80001fa <__udivsi3+0xce>
 800013a:	0a03      	lsrs	r3, r0, #8
 800013c:	428b      	cmp	r3, r1
 800013e:	d344      	bcc.n	80001ca <__udivsi3+0x9e>
 8000140:	0b03      	lsrs	r3, r0, #12
 8000142:	428b      	cmp	r3, r1
 8000144:	d328      	bcc.n	8000198 <__udivsi3+0x6c>
 8000146:	0c03      	lsrs	r3, r0, #16
 8000148:	428b      	cmp	r3, r1
 800014a:	d30d      	bcc.n	8000168 <__udivsi3+0x3c>
 800014c:	22ff      	movs	r2, #255	; 0xff
 800014e:	0209      	lsls	r1, r1, #8
 8000150:	ba12      	rev	r2, r2
 8000152:	0c03      	lsrs	r3, r0, #16
 8000154:	428b      	cmp	r3, r1
 8000156:	d302      	bcc.n	800015e <__udivsi3+0x32>
 8000158:	1212      	asrs	r2, r2, #8
 800015a:	0209      	lsls	r1, r1, #8
 800015c:	d065      	beq.n	800022a <__udivsi3+0xfe>
 800015e:	0b03      	lsrs	r3, r0, #12
 8000160:	428b      	cmp	r3, r1
 8000162:	d319      	bcc.n	8000198 <__udivsi3+0x6c>
 8000164:	e000      	b.n	8000168 <__udivsi3+0x3c>
 8000166:	0a09      	lsrs	r1, r1, #8
 8000168:	0bc3      	lsrs	r3, r0, #15
 800016a:	428b      	cmp	r3, r1
 800016c:	d301      	bcc.n	8000172 <__udivsi3+0x46>
 800016e:	03cb      	lsls	r3, r1, #15
 8000170:	1ac0      	subs	r0, r0, r3
 8000172:	4152      	adcs	r2, r2
 8000174:	0b83      	lsrs	r3, r0, #14
 8000176:	428b      	cmp	r3, r1
 8000178:	d301      	bcc.n	800017e <__udivsi3+0x52>
 800017a:	038b      	lsls	r3, r1, #14
 800017c:	1ac0      	subs	r0, r0, r3
 800017e:	4152      	adcs	r2, r2
 8000180:	0b43      	lsrs	r3, r0, #13
 8000182:	428b      	cmp	r3, r1
 8000184:	d301      	bcc.n	800018a <__udivsi3+0x5e>
 8000186:	034b      	lsls	r3, r1, #13
 8000188:	1ac0      	subs	r0, r0, r3
 800018a:	4152      	adcs	r2, r2
 800018c:	0b03      	lsrs	r3, r0, #12
 800018e:	428b      	cmp	r3, r1
 8000190:	d301      	bcc.n	8000196 <__udivsi3+0x6a>
 8000192:	030b      	lsls	r3, r1, #12
 8000194:	1ac0      	subs	r0, r0, r3
 8000196:	4152      	adcs	r2, r2
 8000198:	0ac3      	lsrs	r3, r0, #11
 800019a:	428b      	cmp	r3, r1
 800019c:	d301      	bcc.n	80001a2 <__udivsi3+0x76>
 800019e:	02cb      	lsls	r3, r1, #11
 80001a0:	1ac0      	subs	r0, r0, r3
 80001a2:	4152      	adcs	r2, r2
 80001a4:	0a83      	lsrs	r3, r0, #10
 80001a6:	428b      	cmp	r3, r1
 80001a8:	d301      	bcc.n	80001ae <__udivsi3+0x82>
 80001aa:	028b      	lsls	r3, r1, #10
 80001ac:	1ac0      	subs	r0, r0, r3
 80001ae:	4152      	adcs	r2, r2
 80001b0:	0a43      	lsrs	r3, r0, #9
 80001b2:	428b      	cmp	r3, r1
 80001b4:	d301      	bcc.n	80001ba <__udivsi3+0x8e>
 80001b6:	024b      	lsls	r3, r1, #9
 80001b8:	1ac0      	subs	r0, r0, r3
 80001ba:	4152      	adcs	r2, r2
 80001bc:	0a03      	lsrs	r3, r0, #8
 80001be:	428b      	cmp	r3, r1
 80001c0:	d301      	bcc.n	80001c6 <__udivsi3+0x9a>
 80001c2:	020b      	lsls	r3, r1, #8
 80001c4:	1ac0      	subs	r0, r0, r3
 80001c6:	4152      	adcs	r2, r2
 80001c8:	d2cd      	bcs.n	8000166 <__udivsi3+0x3a>
 80001ca:	09c3      	lsrs	r3, r0, #7
 80001cc:	428b      	cmp	r3, r1
 80001ce:	d301      	bcc.n	80001d4 <__udivsi3+0xa8>
 80001d0:	01cb      	lsls	r3, r1, #7
 80001d2:	1ac0      	subs	r0, r0, r3
 80001d4:	4152      	adcs	r2, r2
 80001d6:	0983      	lsrs	r3, r0, #6
 80001d8:	428b      	cmp	r3, r1
 80001da:	d301      	bcc.n	80001e0 <__udivsi3+0xb4>
 80001dc:	018b      	lsls	r3, r1, #6
 80001de:	1ac0      	subs	r0, r0, r3
 80001e0:	4152      	adcs	r2, r2
 80001e2:	0943      	lsrs	r3, r0, #5
 80001e4:	428b      	cmp	r3, r1
 80001e6:	d301      	bcc.n	80001ec <__udivsi3+0xc0>
 80001e8:	014b      	lsls	r3, r1, #5
 80001ea:	1ac0      	subs	r0, r0, r3
 80001ec:	4152      	adcs	r2, r2
 80001ee:	0903      	lsrs	r3, r0, #4
 80001f0:	428b      	cmp	r3, r1
 80001f2:	d301      	bcc.n	80001f8 <__udivsi3+0xcc>
 80001f4:	010b      	lsls	r3, r1, #4
 80001f6:	1ac0      	subs	r0, r0, r3
 80001f8:	4152      	adcs	r2, r2
 80001fa:	08c3      	lsrs	r3, r0, #3
 80001fc:	428b      	cmp	r3, r1
 80001fe:	d301      	bcc.n	8000204 <__udivsi3+0xd8>
 8000200:	00cb      	lsls	r3, r1, #3
 8000202:	1ac0      	subs	r0, r0, r3
 8000204:	4152      	adcs	r2, r2
 8000206:	0883      	lsrs	r3, r0, #2
 8000208:	428b      	cmp	r3, r1
 800020a:	d301      	bcc.n	8000210 <__udivsi3+0xe4>
 800020c:	008b      	lsls	r3, r1, #2
 800020e:	1ac0      	subs	r0, r0, r3
 8000210:	4152      	adcs	r2, r2
 8000212:	0843      	lsrs	r3, r0, #1
 8000214:	428b      	cmp	r3, r1
 8000216:	d301      	bcc.n	800021c <__udivsi3+0xf0>
 8000218:	004b      	lsls	r3, r1, #1
 800021a:	1ac0      	subs	r0, r0, r3
 800021c:	4152      	adcs	r2, r2
 800021e:	1a41      	subs	r1, r0, r1
 8000220:	d200      	bcs.n	8000224 <__udivsi3+0xf8>
 8000222:	4601      	mov	r1, r0
 8000224:	4152      	adcs	r2, r2
 8000226:	4610      	mov	r0, r2
 8000228:	4770      	bx	lr
 800022a:	e7ff      	b.n	800022c <__udivsi3+0x100>
 800022c:	b501      	push	{r0, lr}
 800022e:	2000      	movs	r0, #0
 8000230:	f000 f806 	bl	8000240 <__aeabi_idiv0>
 8000234:	bd02      	pop	{r1, pc}
 8000236:	46c0      	nop			; (mov r8, r8)

08000238 <__aeabi_uidivmod>:
 8000238:	2900      	cmp	r1, #0
 800023a:	d0f7      	beq.n	800022c <__udivsi3+0x100>
 800023c:	e776      	b.n	800012c <__udivsi3>
 800023e:	4770      	bx	lr

08000240 <__aeabi_idiv0>:
 8000240:	4770      	bx	lr
 8000242:	46c0      	nop			; (mov r8, r8)

08000244 <__aeabi_uldivmod>:
 8000244:	2b00      	cmp	r3, #0
 8000246:	d111      	bne.n	800026c <__aeabi_uldivmod+0x28>
 8000248:	2a00      	cmp	r2, #0
 800024a:	d10f      	bne.n	800026c <__aeabi_uldivmod+0x28>
 800024c:	2900      	cmp	r1, #0
 800024e:	d100      	bne.n	8000252 <__aeabi_uldivmod+0xe>
 8000250:	2800      	cmp	r0, #0
 8000252:	d002      	beq.n	800025a <__aeabi_uldivmod+0x16>
 8000254:	2100      	movs	r1, #0
 8000256:	43c9      	mvns	r1, r1
 8000258:	1c08      	adds	r0, r1, #0
 800025a:	b407      	push	{r0, r1, r2}
 800025c:	4802      	ldr	r0, [pc, #8]	; (8000268 <__aeabi_uldivmod+0x24>)
 800025e:	a102      	add	r1, pc, #8	; (adr r1, 8000268 <__aeabi_uldivmod+0x24>)
 8000260:	1840      	adds	r0, r0, r1
 8000262:	9002      	str	r0, [sp, #8]
 8000264:	bd03      	pop	{r0, r1, pc}
 8000266:	46c0      	nop			; (mov r8, r8)
 8000268:	ffffffd9 	.word	0xffffffd9
 800026c:	b403      	push	{r0, r1}
 800026e:	4668      	mov	r0, sp
 8000270:	b501      	push	{r0, lr}
 8000272:	9802      	ldr	r0, [sp, #8]
 8000274:	f000 f82e 	bl	80002d4 <__udivmoddi4>
 8000278:	9b01      	ldr	r3, [sp, #4]
 800027a:	469e      	mov	lr, r3
 800027c:	b002      	add	sp, #8
 800027e:	bc0c      	pop	{r2, r3}
 8000280:	4770      	bx	lr
 8000282:	46c0      	nop			; (mov r8, r8)

08000284 <__aeabi_lmul>:
 8000284:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000286:	0415      	lsls	r5, r2, #16
 8000288:	0c2d      	lsrs	r5, r5, #16
 800028a:	000f      	movs	r7, r1
 800028c:	0001      	movs	r1, r0
 800028e:	002e      	movs	r6, r5
 8000290:	46c6      	mov	lr, r8
 8000292:	4684      	mov	ip, r0
 8000294:	0400      	lsls	r0, r0, #16
 8000296:	0c14      	lsrs	r4, r2, #16
 8000298:	0c00      	lsrs	r0, r0, #16
 800029a:	0c09      	lsrs	r1, r1, #16
 800029c:	4346      	muls	r6, r0
 800029e:	434d      	muls	r5, r1
 80002a0:	4360      	muls	r0, r4
 80002a2:	4361      	muls	r1, r4
 80002a4:	1940      	adds	r0, r0, r5
 80002a6:	0c34      	lsrs	r4, r6, #16
 80002a8:	1824      	adds	r4, r4, r0
 80002aa:	b500      	push	{lr}
 80002ac:	42a5      	cmp	r5, r4
 80002ae:	d903      	bls.n	80002b8 <__aeabi_lmul+0x34>
 80002b0:	2080      	movs	r0, #128	; 0x80
 80002b2:	0240      	lsls	r0, r0, #9
 80002b4:	4680      	mov	r8, r0
 80002b6:	4441      	add	r1, r8
 80002b8:	0c25      	lsrs	r5, r4, #16
 80002ba:	186d      	adds	r5, r5, r1
 80002bc:	4661      	mov	r1, ip
 80002be:	4359      	muls	r1, r3
 80002c0:	437a      	muls	r2, r7
 80002c2:	0430      	lsls	r0, r6, #16
 80002c4:	1949      	adds	r1, r1, r5
 80002c6:	0424      	lsls	r4, r4, #16
 80002c8:	0c00      	lsrs	r0, r0, #16
 80002ca:	1820      	adds	r0, r4, r0
 80002cc:	1889      	adds	r1, r1, r2
 80002ce:	bc80      	pop	{r7}
 80002d0:	46b8      	mov	r8, r7
 80002d2:	bdf0      	pop	{r4, r5, r6, r7, pc}

080002d4 <__udivmoddi4>:
 80002d4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80002d6:	4657      	mov	r7, sl
 80002d8:	464e      	mov	r6, r9
 80002da:	4645      	mov	r5, r8
 80002dc:	46de      	mov	lr, fp
 80002de:	b5e0      	push	{r5, r6, r7, lr}
 80002e0:	0004      	movs	r4, r0
 80002e2:	000d      	movs	r5, r1
 80002e4:	4692      	mov	sl, r2
 80002e6:	4699      	mov	r9, r3
 80002e8:	b083      	sub	sp, #12
 80002ea:	428b      	cmp	r3, r1
 80002ec:	d830      	bhi.n	8000350 <__udivmoddi4+0x7c>
 80002ee:	d02d      	beq.n	800034c <__udivmoddi4+0x78>
 80002f0:	4649      	mov	r1, r9
 80002f2:	4650      	mov	r0, sl
 80002f4:	f000 f8ba 	bl	800046c <__clzdi2>
 80002f8:	0029      	movs	r1, r5
 80002fa:	0006      	movs	r6, r0
 80002fc:	0020      	movs	r0, r4
 80002fe:	f000 f8b5 	bl	800046c <__clzdi2>
 8000302:	1a33      	subs	r3, r6, r0
 8000304:	4698      	mov	r8, r3
 8000306:	3b20      	subs	r3, #32
 8000308:	469b      	mov	fp, r3
 800030a:	d433      	bmi.n	8000374 <__udivmoddi4+0xa0>
 800030c:	465a      	mov	r2, fp
 800030e:	4653      	mov	r3, sl
 8000310:	4093      	lsls	r3, r2
 8000312:	4642      	mov	r2, r8
 8000314:	001f      	movs	r7, r3
 8000316:	4653      	mov	r3, sl
 8000318:	4093      	lsls	r3, r2
 800031a:	001e      	movs	r6, r3
 800031c:	42af      	cmp	r7, r5
 800031e:	d83a      	bhi.n	8000396 <__udivmoddi4+0xc2>
 8000320:	42af      	cmp	r7, r5
 8000322:	d100      	bne.n	8000326 <__udivmoddi4+0x52>
 8000324:	e078      	b.n	8000418 <__udivmoddi4+0x144>
 8000326:	465b      	mov	r3, fp
 8000328:	1ba4      	subs	r4, r4, r6
 800032a:	41bd      	sbcs	r5, r7
 800032c:	2b00      	cmp	r3, #0
 800032e:	da00      	bge.n	8000332 <__udivmoddi4+0x5e>
 8000330:	e075      	b.n	800041e <__udivmoddi4+0x14a>
 8000332:	2200      	movs	r2, #0
 8000334:	2300      	movs	r3, #0
 8000336:	9200      	str	r2, [sp, #0]
 8000338:	9301      	str	r3, [sp, #4]
 800033a:	2301      	movs	r3, #1
 800033c:	465a      	mov	r2, fp
 800033e:	4093      	lsls	r3, r2
 8000340:	9301      	str	r3, [sp, #4]
 8000342:	2301      	movs	r3, #1
 8000344:	4642      	mov	r2, r8
 8000346:	4093      	lsls	r3, r2
 8000348:	9300      	str	r3, [sp, #0]
 800034a:	e028      	b.n	800039e <__udivmoddi4+0xca>
 800034c:	4282      	cmp	r2, r0
 800034e:	d9cf      	bls.n	80002f0 <__udivmoddi4+0x1c>
 8000350:	2200      	movs	r2, #0
 8000352:	2300      	movs	r3, #0
 8000354:	9200      	str	r2, [sp, #0]
 8000356:	9301      	str	r3, [sp, #4]
 8000358:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800035a:	2b00      	cmp	r3, #0
 800035c:	d001      	beq.n	8000362 <__udivmoddi4+0x8e>
 800035e:	601c      	str	r4, [r3, #0]
 8000360:	605d      	str	r5, [r3, #4]
 8000362:	9800      	ldr	r0, [sp, #0]
 8000364:	9901      	ldr	r1, [sp, #4]
 8000366:	b003      	add	sp, #12
 8000368:	bcf0      	pop	{r4, r5, r6, r7}
 800036a:	46bb      	mov	fp, r7
 800036c:	46b2      	mov	sl, r6
 800036e:	46a9      	mov	r9, r5
 8000370:	46a0      	mov	r8, r4
 8000372:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000374:	4642      	mov	r2, r8
 8000376:	2320      	movs	r3, #32
 8000378:	1a9b      	subs	r3, r3, r2
 800037a:	4652      	mov	r2, sl
 800037c:	40da      	lsrs	r2, r3
 800037e:	4641      	mov	r1, r8
 8000380:	0013      	movs	r3, r2
 8000382:	464a      	mov	r2, r9
 8000384:	408a      	lsls	r2, r1
 8000386:	0017      	movs	r7, r2
 8000388:	4642      	mov	r2, r8
 800038a:	431f      	orrs	r7, r3
 800038c:	4653      	mov	r3, sl
 800038e:	4093      	lsls	r3, r2
 8000390:	001e      	movs	r6, r3
 8000392:	42af      	cmp	r7, r5
 8000394:	d9c4      	bls.n	8000320 <__udivmoddi4+0x4c>
 8000396:	2200      	movs	r2, #0
 8000398:	2300      	movs	r3, #0
 800039a:	9200      	str	r2, [sp, #0]
 800039c:	9301      	str	r3, [sp, #4]
 800039e:	4643      	mov	r3, r8
 80003a0:	2b00      	cmp	r3, #0
 80003a2:	d0d9      	beq.n	8000358 <__udivmoddi4+0x84>
 80003a4:	07fb      	lsls	r3, r7, #31
 80003a6:	0872      	lsrs	r2, r6, #1
 80003a8:	431a      	orrs	r2, r3
 80003aa:	4646      	mov	r6, r8
 80003ac:	087b      	lsrs	r3, r7, #1
 80003ae:	e00e      	b.n	80003ce <__udivmoddi4+0xfa>
 80003b0:	42ab      	cmp	r3, r5
 80003b2:	d101      	bne.n	80003b8 <__udivmoddi4+0xe4>
 80003b4:	42a2      	cmp	r2, r4
 80003b6:	d80c      	bhi.n	80003d2 <__udivmoddi4+0xfe>
 80003b8:	1aa4      	subs	r4, r4, r2
 80003ba:	419d      	sbcs	r5, r3
 80003bc:	2001      	movs	r0, #1
 80003be:	1924      	adds	r4, r4, r4
 80003c0:	416d      	adcs	r5, r5
 80003c2:	2100      	movs	r1, #0
 80003c4:	3e01      	subs	r6, #1
 80003c6:	1824      	adds	r4, r4, r0
 80003c8:	414d      	adcs	r5, r1
 80003ca:	2e00      	cmp	r6, #0
 80003cc:	d006      	beq.n	80003dc <__udivmoddi4+0x108>
 80003ce:	42ab      	cmp	r3, r5
 80003d0:	d9ee      	bls.n	80003b0 <__udivmoddi4+0xdc>
 80003d2:	3e01      	subs	r6, #1
 80003d4:	1924      	adds	r4, r4, r4
 80003d6:	416d      	adcs	r5, r5
 80003d8:	2e00      	cmp	r6, #0
 80003da:	d1f8      	bne.n	80003ce <__udivmoddi4+0xfa>
 80003dc:	9800      	ldr	r0, [sp, #0]
 80003de:	9901      	ldr	r1, [sp, #4]
 80003e0:	465b      	mov	r3, fp
 80003e2:	1900      	adds	r0, r0, r4
 80003e4:	4169      	adcs	r1, r5
 80003e6:	2b00      	cmp	r3, #0
 80003e8:	db24      	blt.n	8000434 <__udivmoddi4+0x160>
 80003ea:	002b      	movs	r3, r5
 80003ec:	465a      	mov	r2, fp
 80003ee:	4644      	mov	r4, r8
 80003f0:	40d3      	lsrs	r3, r2
 80003f2:	002a      	movs	r2, r5
 80003f4:	40e2      	lsrs	r2, r4
 80003f6:	001c      	movs	r4, r3
 80003f8:	465b      	mov	r3, fp
 80003fa:	0015      	movs	r5, r2
 80003fc:	2b00      	cmp	r3, #0
 80003fe:	db2a      	blt.n	8000456 <__udivmoddi4+0x182>
 8000400:	0026      	movs	r6, r4
 8000402:	409e      	lsls	r6, r3
 8000404:	0033      	movs	r3, r6
 8000406:	0026      	movs	r6, r4
 8000408:	4647      	mov	r7, r8
 800040a:	40be      	lsls	r6, r7
 800040c:	0032      	movs	r2, r6
 800040e:	1a80      	subs	r0, r0, r2
 8000410:	4199      	sbcs	r1, r3
 8000412:	9000      	str	r0, [sp, #0]
 8000414:	9101      	str	r1, [sp, #4]
 8000416:	e79f      	b.n	8000358 <__udivmoddi4+0x84>
 8000418:	42a3      	cmp	r3, r4
 800041a:	d8bc      	bhi.n	8000396 <__udivmoddi4+0xc2>
 800041c:	e783      	b.n	8000326 <__udivmoddi4+0x52>
 800041e:	4642      	mov	r2, r8
 8000420:	2320      	movs	r3, #32
 8000422:	2100      	movs	r1, #0
 8000424:	1a9b      	subs	r3, r3, r2
 8000426:	2200      	movs	r2, #0
 8000428:	9100      	str	r1, [sp, #0]
 800042a:	9201      	str	r2, [sp, #4]
 800042c:	2201      	movs	r2, #1
 800042e:	40da      	lsrs	r2, r3
 8000430:	9201      	str	r2, [sp, #4]
 8000432:	e786      	b.n	8000342 <__udivmoddi4+0x6e>
 8000434:	4642      	mov	r2, r8
 8000436:	2320      	movs	r3, #32
 8000438:	1a9b      	subs	r3, r3, r2
 800043a:	002a      	movs	r2, r5
 800043c:	4646      	mov	r6, r8
 800043e:	409a      	lsls	r2, r3
 8000440:	0023      	movs	r3, r4
 8000442:	40f3      	lsrs	r3, r6
 8000444:	4644      	mov	r4, r8
 8000446:	4313      	orrs	r3, r2
 8000448:	002a      	movs	r2, r5
 800044a:	40e2      	lsrs	r2, r4
 800044c:	001c      	movs	r4, r3
 800044e:	465b      	mov	r3, fp
 8000450:	0015      	movs	r5, r2
 8000452:	2b00      	cmp	r3, #0
 8000454:	dad4      	bge.n	8000400 <__udivmoddi4+0x12c>
 8000456:	4642      	mov	r2, r8
 8000458:	002f      	movs	r7, r5
 800045a:	2320      	movs	r3, #32
 800045c:	0026      	movs	r6, r4
 800045e:	4097      	lsls	r7, r2
 8000460:	1a9b      	subs	r3, r3, r2
 8000462:	40de      	lsrs	r6, r3
 8000464:	003b      	movs	r3, r7
 8000466:	4333      	orrs	r3, r6
 8000468:	e7cd      	b.n	8000406 <__udivmoddi4+0x132>
 800046a:	46c0      	nop			; (mov r8, r8)

0800046c <__clzdi2>:
 800046c:	b510      	push	{r4, lr}
 800046e:	2900      	cmp	r1, #0
 8000470:	d103      	bne.n	800047a <__clzdi2+0xe>
 8000472:	f000 f807 	bl	8000484 <__clzsi2>
 8000476:	3020      	adds	r0, #32
 8000478:	e002      	b.n	8000480 <__clzdi2+0x14>
 800047a:	1c08      	adds	r0, r1, #0
 800047c:	f000 f802 	bl	8000484 <__clzsi2>
 8000480:	bd10      	pop	{r4, pc}
 8000482:	46c0      	nop			; (mov r8, r8)

08000484 <__clzsi2>:
 8000484:	211c      	movs	r1, #28
 8000486:	2301      	movs	r3, #1
 8000488:	041b      	lsls	r3, r3, #16
 800048a:	4298      	cmp	r0, r3
 800048c:	d301      	bcc.n	8000492 <__clzsi2+0xe>
 800048e:	0c00      	lsrs	r0, r0, #16
 8000490:	3910      	subs	r1, #16
 8000492:	0a1b      	lsrs	r3, r3, #8
 8000494:	4298      	cmp	r0, r3
 8000496:	d301      	bcc.n	800049c <__clzsi2+0x18>
 8000498:	0a00      	lsrs	r0, r0, #8
 800049a:	3908      	subs	r1, #8
 800049c:	091b      	lsrs	r3, r3, #4
 800049e:	4298      	cmp	r0, r3
 80004a0:	d301      	bcc.n	80004a6 <__clzsi2+0x22>
 80004a2:	0900      	lsrs	r0, r0, #4
 80004a4:	3904      	subs	r1, #4
 80004a6:	a202      	add	r2, pc, #8	; (adr r2, 80004b0 <__clzsi2+0x2c>)
 80004a8:	5c10      	ldrb	r0, [r2, r0]
 80004aa:	1840      	adds	r0, r0, r1
 80004ac:	4770      	bx	lr
 80004ae:	46c0      	nop			; (mov r8, r8)
 80004b0:	02020304 	.word	0x02020304
 80004b4:	01010101 	.word	0x01010101
	...

080004c0 <HAL_UART_RxCpltCallback>:
	"firmware",
	"abcd@1234",
	(uint32_t)21,
};
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
 80004c0:	b580      	push	{r7, lr}
 80004c2:	b082      	sub	sp, #8
 80004c4:	af00      	add	r7, sp, #0
 80004c6:	6078      	str	r0, [r7, #4]
//	m_rx_buff.data[m_rx_buff.index] = data ;
//	m_rx_buff.index++;

	RingBuffer_Push(&Rx_Buffer, data);
 80004c8:	4b08      	ldr	r3, [pc, #32]	; (80004ec <HAL_UART_RxCpltCallback+0x2c>)
 80004ca:	781a      	ldrb	r2, [r3, #0]
 80004cc:	4b08      	ldr	r3, [pc, #32]	; (80004f0 <HAL_UART_RxCpltCallback+0x30>)
 80004ce:	0011      	movs	r1, r2
 80004d0:	0018      	movs	r0, r3
 80004d2:	f002 fbc5 	bl	8002c60 <RingBuffer_Push>
	HAL_UART_Receive_IT(&huart1, &data, 1);
 80004d6:	4905      	ldr	r1, [pc, #20]	; (80004ec <HAL_UART_RxCpltCallback+0x2c>)
 80004d8:	4b06      	ldr	r3, [pc, #24]	; (80004f4 <HAL_UART_RxCpltCallback+0x34>)
 80004da:	2201      	movs	r2, #1
 80004dc:	0018      	movs	r0, r3
 80004de:	f003 fffb 	bl	80044d8 <HAL_UART_Receive_IT>
}
 80004e2:	46c0      	nop			; (mov r8, r8)
 80004e4:	46bd      	mov	sp, r7
 80004e6:	b002      	add	sp, #8
 80004e8:	bd80      	pop	{r7, pc}
 80004ea:	46c0      	nop			; (mov r8, r8)
 80004ec:	200000b8 	.word	0x200000b8
 80004f0:	20001898 	.word	0x20001898
 80004f4:	20001800 	.word	0x20001800

080004f8 <App_Main>:
static void dns_initialize(void);

void App_Main ()
{
 80004f8:	b580      	push	{r7, lr}
 80004fa:	af00      	add	r7, sp, #0
	// Note: Sá»­a NOPULL -> PULLUP:  GPIO_InitStruct.Pull = GPIO_PULLUP; de tranh loi nhan NULL truoc khi Power on EC200
	HAL_UART_Receive_IT(&huart1, &data, 1);
 80004fc:	490d      	ldr	r1, [pc, #52]	; (8000534 <App_Main+0x3c>)
 80004fe:	4b0e      	ldr	r3, [pc, #56]	; (8000538 <App_Main+0x40>)
 8000500:	2201      	movs	r2, #1
 8000502:	0018      	movs	r0, r3
 8000504:	f003 ffe8 	bl	80044d8 <HAL_UART_Receive_IT>

 	dns_initialize();
 8000508:	f000 f81e 	bl	8000548 <dns_initialize>
	//lwip_init();
	//MQTT_Client_Init(&MQTT_Cfg);
	//HTTP_Client_Init(&HTTP_Cfg);
	GSM_File_Handler_Init(&GSM_File_Handler_Cfg);
 800050c:	4b0b      	ldr	r3, [pc, #44]	; (800053c <App_Main+0x44>)
 800050e:	0018      	movs	r0, r3
 8000510:	f001 fc16 	bl	8001d40 <GSM_File_Handler_Init>
	DEBUG_INFO("Application started\r\n");
 8000514:	f01c fc80 	bl	801ce18 <sys_get_tick_ms>
 8000518:	0001      	movs	r1, r0
 800051a:	4a09      	ldr	r2, [pc, #36]	; (8000540 <App_Main+0x48>)
 800051c:	4b09      	ldr	r3, [pc, #36]	; (8000544 <App_Main+0x4c>)
 800051e:	0018      	movs	r0, r3
 8000520:	f002 fb52 	bl	8002bc8 <app_debug_rtt_raw>
	GMS_Hardware_Init();
 8000524:	f000 ffb6 	bl	8001494 <GMS_Hardware_Init>
	//UART_SendData(USART1, bf_send, sizeof(bf_send));
	while(1)
	{
		GSM_mnr_task();
 8000528:	f000 ffa8 	bl	800147c <GSM_mnr_task>
		//MQTT_Client_Polling_Task(NULL);
		HTTP_Client_Polling_Task(NULL);
 800052c:	2000      	movs	r0, #0
 800052e:	f005 fbc5 	bl	8005cbc <HTTP_Client_Polling_Task>
		GSM_mnr_task();
 8000532:	e7f9      	b.n	8000528 <App_Main+0x30>
 8000534:	200000b8 	.word	0x200000b8
 8000538:	20001800 	.word	0x20001800
 800053c:	20000000 	.word	0x20000000
 8000540:	0801d9f4 	.word	0x0801d9f4
 8000544:	0801d9f8 	.word	0x0801d9f8

08000548 <dns_initialize>:
	}
}

static void dns_initialize(void)
{
 8000548:	b580      	push	{r7, lr}
 800054a:	b082      	sub	sp, #8
 800054c:	af00      	add	r7, sp, #0
    ip_addr_t dns_server_0 = IPADDR4_INIT_BYTES(8, 8, 8, 8);
 800054e:	4b0a      	ldr	r3, [pc, #40]	; (8000578 <dns_initialize+0x30>)
 8000550:	607b      	str	r3, [r7, #4]
    ip_addr_t dns_server_1 = IPADDR4_INIT_BYTES(1, 1, 1, 1);
 8000552:	4b0a      	ldr	r3, [pc, #40]	; (800057c <dns_initialize+0x34>)
 8000554:	603b      	str	r3, [r7, #0]
    dns_setserver(0, &dns_server_0);
 8000556:	1d3b      	adds	r3, r7, #4
 8000558:	0019      	movs	r1, r3
 800055a:	2000      	movs	r0, #0
 800055c:	f006 fd4a 	bl	8006ff4 <dns_setserver>
    dns_setserver(1, &dns_server_1);
 8000560:	003b      	movs	r3, r7
 8000562:	0019      	movs	r1, r3
 8000564:	2001      	movs	r0, #1
 8000566:	f006 fd45 	bl	8006ff4 <dns_setserver>
    dns_init();
 800056a:	f006 fd3d 	bl	8006fe8 <dns_init>
}
 800056e:	46c0      	nop			; (mov r8, r8)
 8000570:	46bd      	mov	sp, r7
 8000572:	b002      	add	sp, #8
 8000574:	bd80      	pop	{r7, pc}
 8000576:	46c0      	nop			; (mov r8, r8)
 8000578:	08080808 	.word	0x08080808
 800057c:	01010101 	.word	0x01010101

08000580 <MX_GPIO_Init>:
        * Output
        * EVENT_OUT
        * EXTI
*/
void MX_GPIO_Init(void)
{
 8000580:	b590      	push	{r4, r7, lr}
 8000582:	b08b      	sub	sp, #44	; 0x2c
 8000584:	af00      	add	r7, sp, #0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000586:	2414      	movs	r4, #20
 8000588:	193b      	adds	r3, r7, r4
 800058a:	0018      	movs	r0, r3
 800058c:	2314      	movs	r3, #20
 800058e:	001a      	movs	r2, r3
 8000590:	2100      	movs	r1, #0
 8000592:	f01c fcb7 	bl	801cf04 <memset>

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8000596:	4b42      	ldr	r3, [pc, #264]	; (80006a0 <MX_GPIO_Init+0x120>)
 8000598:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800059a:	4b41      	ldr	r3, [pc, #260]	; (80006a0 <MX_GPIO_Init+0x120>)
 800059c:	2180      	movs	r1, #128	; 0x80
 800059e:	430a      	orrs	r2, r1
 80005a0:	62da      	str	r2, [r3, #44]	; 0x2c
 80005a2:	4b3f      	ldr	r3, [pc, #252]	; (80006a0 <MX_GPIO_Init+0x120>)
 80005a4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80005a6:	2280      	movs	r2, #128	; 0x80
 80005a8:	4013      	ands	r3, r2
 80005aa:	613b      	str	r3, [r7, #16]
 80005ac:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 80005ae:	4b3c      	ldr	r3, [pc, #240]	; (80006a0 <MX_GPIO_Init+0x120>)
 80005b0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80005b2:	4b3b      	ldr	r3, [pc, #236]	; (80006a0 <MX_GPIO_Init+0x120>)
 80005b4:	2104      	movs	r1, #4
 80005b6:	430a      	orrs	r2, r1
 80005b8:	62da      	str	r2, [r3, #44]	; 0x2c
 80005ba:	4b39      	ldr	r3, [pc, #228]	; (80006a0 <MX_GPIO_Init+0x120>)
 80005bc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80005be:	2204      	movs	r2, #4
 80005c0:	4013      	ands	r3, r2
 80005c2:	60fb      	str	r3, [r7, #12]
 80005c4:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80005c6:	4b36      	ldr	r3, [pc, #216]	; (80006a0 <MX_GPIO_Init+0x120>)
 80005c8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80005ca:	4b35      	ldr	r3, [pc, #212]	; (80006a0 <MX_GPIO_Init+0x120>)
 80005cc:	2101      	movs	r1, #1
 80005ce:	430a      	orrs	r2, r1
 80005d0:	62da      	str	r2, [r3, #44]	; 0x2c
 80005d2:	4b33      	ldr	r3, [pc, #204]	; (80006a0 <MX_GPIO_Init+0x120>)
 80005d4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80005d6:	2201      	movs	r2, #1
 80005d8:	4013      	ands	r3, r2
 80005da:	60bb      	str	r3, [r7, #8]
 80005dc:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 80005de:	4b30      	ldr	r3, [pc, #192]	; (80006a0 <MX_GPIO_Init+0x120>)
 80005e0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80005e2:	4b2f      	ldr	r3, [pc, #188]	; (80006a0 <MX_GPIO_Init+0x120>)
 80005e4:	2102      	movs	r1, #2
 80005e6:	430a      	orrs	r2, r1
 80005e8:	62da      	str	r2, [r3, #44]	; 0x2c
 80005ea:	4b2d      	ldr	r3, [pc, #180]	; (80006a0 <MX_GPIO_Init+0x120>)
 80005ec:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80005ee:	2202      	movs	r2, #2
 80005f0:	4013      	ands	r3, r2
 80005f2:	607b      	str	r3, [r7, #4]
 80005f4:	687b      	ldr	r3, [r7, #4]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOC, CHARGE_EN_Pin|EN_GSM_Pin, GPIO_PIN_RESET);
 80005f6:	4b2b      	ldr	r3, [pc, #172]	; (80006a4 <MX_GPIO_Init+0x124>)
 80005f8:	2200      	movs	r2, #0
 80005fa:	2150      	movs	r1, #80	; 0x50
 80005fc:	0018      	movs	r0, r3
 80005fe:	f002 ff6b 	bl	80034d8 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, GSM_PWKEY_Pin|GSM_EN_Pin, GPIO_PIN_RESET);
 8000602:	2381      	movs	r3, #129	; 0x81
 8000604:	0219      	lsls	r1, r3, #8
 8000606:	23a0      	movs	r3, #160	; 0xa0
 8000608:	05db      	lsls	r3, r3, #23
 800060a:	2200      	movs	r2, #0
 800060c:	0018      	movs	r0, r3
 800060e:	f002 ff63 	bl	80034d8 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GSM_RESET_GPIO_Port, GSM_RESET_Pin, GPIO_PIN_RESET);
 8000612:	2380      	movs	r3, #128	; 0x80
 8000614:	009b      	lsls	r3, r3, #2
 8000616:	4824      	ldr	r0, [pc, #144]	; (80006a8 <MX_GPIO_Init+0x128>)
 8000618:	2200      	movs	r2, #0
 800061a:	0019      	movs	r1, r3
 800061c:	f002 ff5c 	bl	80034d8 <HAL_GPIO_WritePin>

  /*Configure GPIO pins : PCPin PCPin */
  GPIO_InitStruct.Pin = CHARGE_EN_Pin|EN_GSM_Pin;
 8000620:	193b      	adds	r3, r7, r4
 8000622:	2250      	movs	r2, #80	; 0x50
 8000624:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000626:	193b      	adds	r3, r7, r4
 8000628:	2201      	movs	r2, #1
 800062a:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800062c:	193b      	adds	r3, r7, r4
 800062e:	2200      	movs	r2, #0
 8000630:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000632:	193b      	adds	r3, r7, r4
 8000634:	2200      	movs	r2, #0
 8000636:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000638:	193b      	adds	r3, r7, r4
 800063a:	4a1a      	ldr	r2, [pc, #104]	; (80006a4 <MX_GPIO_Init+0x124>)
 800063c:	0019      	movs	r1, r3
 800063e:	0010      	movs	r0, r2
 8000640:	f002 fdcc 	bl	80031dc <HAL_GPIO_Init>

  /*Configure GPIO pins : PAPin PAPin */
  GPIO_InitStruct.Pin = GSM_PWKEY_Pin|GSM_EN_Pin;
 8000644:	0021      	movs	r1, r4
 8000646:	187b      	adds	r3, r7, r1
 8000648:	2281      	movs	r2, #129	; 0x81
 800064a:	0212      	lsls	r2, r2, #8
 800064c:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800064e:	000c      	movs	r4, r1
 8000650:	193b      	adds	r3, r7, r4
 8000652:	2201      	movs	r2, #1
 8000654:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000656:	193b      	adds	r3, r7, r4
 8000658:	2200      	movs	r2, #0
 800065a:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800065c:	193b      	adds	r3, r7, r4
 800065e:	2200      	movs	r2, #0
 8000660:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000662:	193a      	adds	r2, r7, r4
 8000664:	23a0      	movs	r3, #160	; 0xa0
 8000666:	05db      	lsls	r3, r3, #23
 8000668:	0011      	movs	r1, r2
 800066a:	0018      	movs	r0, r3
 800066c:	f002 fdb6 	bl	80031dc <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = GSM_RESET_Pin;
 8000670:	0021      	movs	r1, r4
 8000672:	187b      	adds	r3, r7, r1
 8000674:	2280      	movs	r2, #128	; 0x80
 8000676:	0092      	lsls	r2, r2, #2
 8000678:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800067a:	187b      	adds	r3, r7, r1
 800067c:	2201      	movs	r2, #1
 800067e:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000680:	187b      	adds	r3, r7, r1
 8000682:	2200      	movs	r2, #0
 8000684:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000686:	187b      	adds	r3, r7, r1
 8000688:	2200      	movs	r2, #0
 800068a:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(GSM_RESET_GPIO_Port, &GPIO_InitStruct);
 800068c:	187b      	adds	r3, r7, r1
 800068e:	4a06      	ldr	r2, [pc, #24]	; (80006a8 <MX_GPIO_Init+0x128>)
 8000690:	0019      	movs	r1, r3
 8000692:	0010      	movs	r0, r2
 8000694:	f002 fda2 	bl	80031dc <HAL_GPIO_Init>

}
 8000698:	46c0      	nop			; (mov r8, r8)
 800069a:	46bd      	mov	sp, r7
 800069c:	b00b      	add	sp, #44	; 0x2c
 800069e:	bd90      	pop	{r4, r7, pc}
 80006a0:	40021000 	.word	0x40021000
 80006a4:	50000800 	.word	0x50000800
 80006a8:	50000400 	.word	0x50000400

080006ac <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 80006ac:	b580      	push	{r7, lr}
 80006ae:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 80006b0:	f002 fb9a 	bl	8002de8 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 80006b4:	f000 f808 	bl	80006c8 <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 80006b8:	f7ff ff62 	bl	8000580 <MX_GPIO_Init>
  MX_USART1_UART_Init();
 80006bc:	f000 f8f0 	bl	80008a0 <MX_USART1_UART_Init>
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
	  App_Main();
 80006c0:	f7ff ff1a 	bl	80004f8 <App_Main>
 80006c4:	e7fc      	b.n	80006c0 <main+0x14>
	...

080006c8 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 80006c8:	b590      	push	{r4, r7, lr}
 80006ca:	b09b      	sub	sp, #108	; 0x6c
 80006cc:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 80006ce:	2434      	movs	r4, #52	; 0x34
 80006d0:	193b      	adds	r3, r7, r4
 80006d2:	0018      	movs	r0, r3
 80006d4:	2334      	movs	r3, #52	; 0x34
 80006d6:	001a      	movs	r2, r3
 80006d8:	2100      	movs	r1, #0
 80006da:	f01c fc13 	bl	801cf04 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 80006de:	2320      	movs	r3, #32
 80006e0:	18fb      	adds	r3, r7, r3
 80006e2:	0018      	movs	r0, r3
 80006e4:	2314      	movs	r3, #20
 80006e6:	001a      	movs	r2, r3
 80006e8:	2100      	movs	r1, #0
 80006ea:	f01c fc0b 	bl	801cf04 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 80006ee:	003b      	movs	r3, r7
 80006f0:	0018      	movs	r0, r3
 80006f2:	2320      	movs	r3, #32
 80006f4:	001a      	movs	r2, r3
 80006f6:	2100      	movs	r1, #0
 80006f8:	f01c fc04 	bl	801cf04 <memset>

  /** Configure the main internal regulator output voltage
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 80006fc:	4b29      	ldr	r3, [pc, #164]	; (80007a4 <SystemClock_Config+0xdc>)
 80006fe:	681b      	ldr	r3, [r3, #0]
 8000700:	4a29      	ldr	r2, [pc, #164]	; (80007a8 <SystemClock_Config+0xe0>)
 8000702:	401a      	ands	r2, r3
 8000704:	4b27      	ldr	r3, [pc, #156]	; (80007a4 <SystemClock_Config+0xdc>)
 8000706:	2180      	movs	r1, #128	; 0x80
 8000708:	0109      	lsls	r1, r1, #4
 800070a:	430a      	orrs	r2, r1
 800070c:	601a      	str	r2, [r3, #0]
  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 800070e:	0021      	movs	r1, r4
 8000710:	187b      	adds	r3, r7, r1
 8000712:	2202      	movs	r2, #2
 8000714:	601a      	str	r2, [r3, #0]
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8000716:	187b      	adds	r3, r7, r1
 8000718:	2201      	movs	r2, #1
 800071a:	60da      	str	r2, [r3, #12]
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 800071c:	187b      	adds	r3, r7, r1
 800071e:	2210      	movs	r2, #16
 8000720:	611a      	str	r2, [r3, #16]
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8000722:	187b      	adds	r3, r7, r1
 8000724:	2202      	movs	r2, #2
 8000726:	625a      	str	r2, [r3, #36]	; 0x24
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
 8000728:	187b      	adds	r3, r7, r1
 800072a:	2200      	movs	r2, #0
 800072c:	629a      	str	r2, [r3, #40]	; 0x28
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLLMUL_4;
 800072e:	187b      	adds	r3, r7, r1
 8000730:	2280      	movs	r2, #128	; 0x80
 8000732:	02d2      	lsls	r2, r2, #11
 8000734:	62da      	str	r2, [r3, #44]	; 0x2c
  RCC_OscInitStruct.PLL.PLLDIV = RCC_PLLDIV_2;
 8000736:	187b      	adds	r3, r7, r1
 8000738:	2280      	movs	r2, #128	; 0x80
 800073a:	03d2      	lsls	r2, r2, #15
 800073c:	631a      	str	r2, [r3, #48]	; 0x30
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800073e:	187b      	adds	r3, r7, r1
 8000740:	0018      	movs	r0, r3
 8000742:	f002 fee7 	bl	8003514 <HAL_RCC_OscConfig>
 8000746:	1e03      	subs	r3, r0, #0
 8000748:	d001      	beq.n	800074e <SystemClock_Config+0x86>
  {
    Error_Handler();
 800074a:	f000 f82f 	bl	80007ac <Error_Handler>
  }
  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800074e:	2120      	movs	r1, #32
 8000750:	187b      	adds	r3, r7, r1
 8000752:	220f      	movs	r2, #15
 8000754:	601a      	str	r2, [r3, #0]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8000756:	187b      	adds	r3, r7, r1
 8000758:	2203      	movs	r2, #3
 800075a:	605a      	str	r2, [r3, #4]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 800075c:	187b      	adds	r3, r7, r1
 800075e:	2200      	movs	r2, #0
 8000760:	609a      	str	r2, [r3, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8000762:	187b      	adds	r3, r7, r1
 8000764:	2200      	movs	r2, #0
 8000766:	60da      	str	r2, [r3, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8000768:	187b      	adds	r3, r7, r1
 800076a:	2200      	movs	r2, #0
 800076c:	611a      	str	r2, [r3, #16]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 800076e:	187b      	adds	r3, r7, r1
 8000770:	2101      	movs	r1, #1
 8000772:	0018      	movs	r0, r3
 8000774:	f003 fa4a 	bl	8003c0c <HAL_RCC_ClockConfig>
 8000778:	1e03      	subs	r3, r0, #0
 800077a:	d001      	beq.n	8000780 <SystemClock_Config+0xb8>
  {
    Error_Handler();
 800077c:	f000 f816 	bl	80007ac <Error_Handler>
  }
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1;
 8000780:	003b      	movs	r3, r7
 8000782:	2201      	movs	r2, #1
 8000784:	601a      	str	r2, [r3, #0]
  PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
 8000786:	003b      	movs	r3, r7
 8000788:	2200      	movs	r2, #0
 800078a:	609a      	str	r2, [r3, #8]
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 800078c:	003b      	movs	r3, r7
 800078e:	0018      	movs	r0, r3
 8000790:	f003 fc60 	bl	8004054 <HAL_RCCEx_PeriphCLKConfig>
 8000794:	1e03      	subs	r3, r0, #0
 8000796:	d001      	beq.n	800079c <SystemClock_Config+0xd4>
  {
    Error_Handler();
 8000798:	f000 f808 	bl	80007ac <Error_Handler>
  }
}
 800079c:	46c0      	nop			; (mov r8, r8)
 800079e:	46bd      	mov	sp, r7
 80007a0:	b01b      	add	sp, #108	; 0x6c
 80007a2:	bd90      	pop	{r4, r7, pc}
 80007a4:	40007000 	.word	0x40007000
 80007a8:	ffffe7ff 	.word	0xffffe7ff

080007ac <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 80007ac:	b580      	push	{r7, lr}
 80007ae:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80007b0:	b672      	cpsid	i
}
 80007b2:	46c0      	nop			; (mov r8, r8)
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 80007b4:	e7fe      	b.n	80007b4 <Error_Handler+0x8>
	...

080007b8 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80007b8:	b580      	push	{r7, lr}
 80007ba:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80007bc:	4b07      	ldr	r3, [pc, #28]	; (80007dc <HAL_MspInit+0x24>)
 80007be:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80007c0:	4b06      	ldr	r3, [pc, #24]	; (80007dc <HAL_MspInit+0x24>)
 80007c2:	2101      	movs	r1, #1
 80007c4:	430a      	orrs	r2, r1
 80007c6:	635a      	str	r2, [r3, #52]	; 0x34
  __HAL_RCC_PWR_CLK_ENABLE();
 80007c8:	4b04      	ldr	r3, [pc, #16]	; (80007dc <HAL_MspInit+0x24>)
 80007ca:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80007cc:	4b03      	ldr	r3, [pc, #12]	; (80007dc <HAL_MspInit+0x24>)
 80007ce:	2180      	movs	r1, #128	; 0x80
 80007d0:	0549      	lsls	r1, r1, #21
 80007d2:	430a      	orrs	r2, r1
 80007d4:	639a      	str	r2, [r3, #56]	; 0x38
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80007d6:	46c0      	nop			; (mov r8, r8)
 80007d8:	46bd      	mov	sp, r7
 80007da:	bd80      	pop	{r7, pc}
 80007dc:	40021000 	.word	0x40021000

080007e0 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable Interrupt.
  */
void NMI_Handler(void)
{
 80007e0:	b580      	push	{r7, lr}
 80007e2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 80007e4:	e7fe      	b.n	80007e4 <NMI_Handler+0x4>

080007e6 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 80007e6:	b580      	push	{r7, lr}
 80007e8:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 80007ea:	e7fe      	b.n	80007ea <HardFault_Handler+0x4>

080007ec <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 80007ec:	b580      	push	{r7, lr}
 80007ee:	af00      	add	r7, sp, #0

  /* USER CODE END SVC_IRQn 0 */
  /* USER CODE BEGIN SVC_IRQn 1 */

  /* USER CODE END SVC_IRQn 1 */
}
 80007f0:	46c0      	nop			; (mov r8, r8)
 80007f2:	46bd      	mov	sp, r7
 80007f4:	bd80      	pop	{r7, pc}

080007f6 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 80007f6:	b580      	push	{r7, lr}
 80007f8:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 80007fa:	46c0      	nop			; (mov r8, r8)
 80007fc:	46bd      	mov	sp, r7
 80007fe:	bd80      	pop	{r7, pc}

08000800 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8000800:	b580      	push	{r7, lr}
 8000802:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8000804:	f002 fb44 	bl	8002e90 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8000808:	46c0      	nop			; (mov r8, r8)
 800080a:	46bd      	mov	sp, r7
 800080c:	bd80      	pop	{r7, pc}
	...

08000810 <USART1_IRQHandler>:

/**
  * @brief This function handles USART1 global interrupt / USART1 wake-up interrupt through EXTI line 25.
  */
void USART1_IRQHandler(void)
{
 8000810:	b580      	push	{r7, lr}
 8000812:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN USART1_IRQn 0 */
	/* Check RXNE flag value in ISR register */

  /* USER CODE END USART1_IRQn 0 */
  HAL_UART_IRQHandler(&huart1);
 8000814:	4b03      	ldr	r3, [pc, #12]	; (8000824 <USART1_IRQHandler+0x14>)
 8000816:	0018      	movs	r0, r3
 8000818:	f003 fec6 	bl	80045a8 <HAL_UART_IRQHandler>
  /* USER CODE BEGIN USART1_IRQn 1 */

  /* USER CODE END USART1_IRQn 1 */
}
 800081c:	46c0      	nop			; (mov r8, r8)
 800081e:	46bd      	mov	sp, r7
 8000820:	bd80      	pop	{r7, pc}
 8000822:	46c0      	nop			; (mov r8, r8)
 8000824:	20001800 	.word	0x20001800

08000828 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 8000828:	b580      	push	{r7, lr}
 800082a:	b086      	sub	sp, #24
 800082c:	af00      	add	r7, sp, #0
 800082e:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8000830:	4a13      	ldr	r2, [pc, #76]	; (8000880 <_sbrk+0x58>)
 8000832:	4b14      	ldr	r3, [pc, #80]	; (8000884 <_sbrk+0x5c>)
 8000834:	1ad3      	subs	r3, r2, r3
 8000836:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 8000838:	697b      	ldr	r3, [r7, #20]
 800083a:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 800083c:	4b12      	ldr	r3, [pc, #72]	; (8000888 <_sbrk+0x60>)
 800083e:	681b      	ldr	r3, [r3, #0]
 8000840:	2b00      	cmp	r3, #0
 8000842:	d102      	bne.n	800084a <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 8000844:	4b10      	ldr	r3, [pc, #64]	; (8000888 <_sbrk+0x60>)
 8000846:	4a11      	ldr	r2, [pc, #68]	; (800088c <_sbrk+0x64>)
 8000848:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 800084a:	4b0f      	ldr	r3, [pc, #60]	; (8000888 <_sbrk+0x60>)
 800084c:	681a      	ldr	r2, [r3, #0]
 800084e:	687b      	ldr	r3, [r7, #4]
 8000850:	18d3      	adds	r3, r2, r3
 8000852:	693a      	ldr	r2, [r7, #16]
 8000854:	429a      	cmp	r2, r3
 8000856:	d205      	bcs.n	8000864 <_sbrk+0x3c>
  {
    errno = ENOMEM;
 8000858:	4b0d      	ldr	r3, [pc, #52]	; (8000890 <_sbrk+0x68>)
 800085a:	220c      	movs	r2, #12
 800085c:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 800085e:	2301      	movs	r3, #1
 8000860:	425b      	negs	r3, r3
 8000862:	e009      	b.n	8000878 <_sbrk+0x50>
  }

  prev_heap_end = __sbrk_heap_end;
 8000864:	4b08      	ldr	r3, [pc, #32]	; (8000888 <_sbrk+0x60>)
 8000866:	681b      	ldr	r3, [r3, #0]
 8000868:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 800086a:	4b07      	ldr	r3, [pc, #28]	; (8000888 <_sbrk+0x60>)
 800086c:	681a      	ldr	r2, [r3, #0]
 800086e:	687b      	ldr	r3, [r7, #4]
 8000870:	18d2      	adds	r2, r2, r3
 8000872:	4b05      	ldr	r3, [pc, #20]	; (8000888 <_sbrk+0x60>)
 8000874:	601a      	str	r2, [r3, #0]

  return (void *)prev_heap_end;
 8000876:	68fb      	ldr	r3, [r7, #12]
}
 8000878:	0018      	movs	r0, r3
 800087a:	46bd      	mov	sp, r7
 800087c:	b006      	add	sp, #24
 800087e:	bd80      	pop	{r7, pc}
 8000880:	20005000 	.word	0x20005000
 8000884:	00000400 	.word	0x00000400
 8000888:	200000bc 	.word	0x200000bc
 800088c:	20003e38 	.word	0x20003e38
 8000890:	20003e24 	.word	0x20003e24

08000894 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 8000894:	b580      	push	{r7, lr}
 8000896:	af00      	add	r7, sp, #0
  /* Configure the Vector Table location add offset address ------------------*/
#if defined (USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 8000898:	46c0      	nop			; (mov r8, r8)
 800089a:	46bd      	mov	sp, r7
 800089c:	bd80      	pop	{r7, pc}
	...

080008a0 <MX_USART1_UART_Init>:
UART_HandleTypeDef huart1;

/* USART1 init function */

void MX_USART1_UART_Init(void)
{
 80008a0:	b580      	push	{r7, lr}
 80008a2:	af00      	add	r7, sp, #0
  /* USER CODE END USART1_Init 0 */

  /* USER CODE BEGIN USART1_Init 1 */

  /* USER CODE END USART1_Init 1 */
  huart1.Instance = USART1;
 80008a4:	4b14      	ldr	r3, [pc, #80]	; (80008f8 <MX_USART1_UART_Init+0x58>)
 80008a6:	4a15      	ldr	r2, [pc, #84]	; (80008fc <MX_USART1_UART_Init+0x5c>)
 80008a8:	601a      	str	r2, [r3, #0]
  huart1.Init.BaudRate = 115200;
 80008aa:	4b13      	ldr	r3, [pc, #76]	; (80008f8 <MX_USART1_UART_Init+0x58>)
 80008ac:	22e1      	movs	r2, #225	; 0xe1
 80008ae:	0252      	lsls	r2, r2, #9
 80008b0:	605a      	str	r2, [r3, #4]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 80008b2:	4b11      	ldr	r3, [pc, #68]	; (80008f8 <MX_USART1_UART_Init+0x58>)
 80008b4:	2200      	movs	r2, #0
 80008b6:	609a      	str	r2, [r3, #8]
  huart1.Init.StopBits = UART_STOPBITS_1;
 80008b8:	4b0f      	ldr	r3, [pc, #60]	; (80008f8 <MX_USART1_UART_Init+0x58>)
 80008ba:	2200      	movs	r2, #0
 80008bc:	60da      	str	r2, [r3, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
 80008be:	4b0e      	ldr	r3, [pc, #56]	; (80008f8 <MX_USART1_UART_Init+0x58>)
 80008c0:	2200      	movs	r2, #0
 80008c2:	611a      	str	r2, [r3, #16]
  huart1.Init.Mode = UART_MODE_TX_RX;
 80008c4:	4b0c      	ldr	r3, [pc, #48]	; (80008f8 <MX_USART1_UART_Init+0x58>)
 80008c6:	220c      	movs	r2, #12
 80008c8:	615a      	str	r2, [r3, #20]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 80008ca:	4b0b      	ldr	r3, [pc, #44]	; (80008f8 <MX_USART1_UART_Init+0x58>)
 80008cc:	2200      	movs	r2, #0
 80008ce:	619a      	str	r2, [r3, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 80008d0:	4b09      	ldr	r3, [pc, #36]	; (80008f8 <MX_USART1_UART_Init+0x58>)
 80008d2:	2200      	movs	r2, #0
 80008d4:	61da      	str	r2, [r3, #28]
  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 80008d6:	4b08      	ldr	r3, [pc, #32]	; (80008f8 <MX_USART1_UART_Init+0x58>)
 80008d8:	2200      	movs	r2, #0
 80008da:	621a      	str	r2, [r3, #32]
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 80008dc:	4b06      	ldr	r3, [pc, #24]	; (80008f8 <MX_USART1_UART_Init+0x58>)
 80008de:	2200      	movs	r2, #0
 80008e0:	625a      	str	r2, [r3, #36]	; 0x24
  if (HAL_UART_Init(&huart1) != HAL_OK)
 80008e2:	4b05      	ldr	r3, [pc, #20]	; (80008f8 <MX_USART1_UART_Init+0x58>)
 80008e4:	0018      	movs	r0, r3
 80008e6:	f003 fcfb 	bl	80042e0 <HAL_UART_Init>
 80008ea:	1e03      	subs	r3, r0, #0
 80008ec:	d001      	beq.n	80008f2 <MX_USART1_UART_Init+0x52>
  {
    Error_Handler();
 80008ee:	f7ff ff5d 	bl	80007ac <Error_Handler>
  }
  /* USER CODE BEGIN USART1_Init 2 */

  /* USER CODE END USART1_Init 2 */

}
 80008f2:	46c0      	nop			; (mov r8, r8)
 80008f4:	46bd      	mov	sp, r7
 80008f6:	bd80      	pop	{r7, pc}
 80008f8:	20001800 	.word	0x20001800
 80008fc:	40013800 	.word	0x40013800

08000900 <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 8000900:	b590      	push	{r4, r7, lr}
 8000902:	b089      	sub	sp, #36	; 0x24
 8000904:	af00      	add	r7, sp, #0
 8000906:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000908:	240c      	movs	r4, #12
 800090a:	193b      	adds	r3, r7, r4
 800090c:	0018      	movs	r0, r3
 800090e:	2314      	movs	r3, #20
 8000910:	001a      	movs	r2, r3
 8000912:	2100      	movs	r1, #0
 8000914:	f01c faf6 	bl	801cf04 <memset>
  if(uartHandle->Instance==USART1)
 8000918:	687b      	ldr	r3, [r7, #4]
 800091a:	681b      	ldr	r3, [r3, #0]
 800091c:	4a1c      	ldr	r2, [pc, #112]	; (8000990 <HAL_UART_MspInit+0x90>)
 800091e:	4293      	cmp	r3, r2
 8000920:	d132      	bne.n	8000988 <HAL_UART_MspInit+0x88>
  {
  /* USER CODE BEGIN USART1_MspInit 0 */

  /* USER CODE END USART1_MspInit 0 */
    /* USART1 clock enable */
    __HAL_RCC_USART1_CLK_ENABLE();
 8000922:	4b1c      	ldr	r3, [pc, #112]	; (8000994 <HAL_UART_MspInit+0x94>)
 8000924:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000926:	4b1b      	ldr	r3, [pc, #108]	; (8000994 <HAL_UART_MspInit+0x94>)
 8000928:	2180      	movs	r1, #128	; 0x80
 800092a:	01c9      	lsls	r1, r1, #7
 800092c:	430a      	orrs	r2, r1
 800092e:	635a      	str	r2, [r3, #52]	; 0x34

    __HAL_RCC_GPIOA_CLK_ENABLE();
 8000930:	4b18      	ldr	r3, [pc, #96]	; (8000994 <HAL_UART_MspInit+0x94>)
 8000932:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000934:	4b17      	ldr	r3, [pc, #92]	; (8000994 <HAL_UART_MspInit+0x94>)
 8000936:	2101      	movs	r1, #1
 8000938:	430a      	orrs	r2, r1
 800093a:	62da      	str	r2, [r3, #44]	; 0x2c
 800093c:	4b15      	ldr	r3, [pc, #84]	; (8000994 <HAL_UART_MspInit+0x94>)
 800093e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000940:	2201      	movs	r2, #1
 8000942:	4013      	ands	r3, r2
 8000944:	60bb      	str	r3, [r7, #8]
 8000946:	68bb      	ldr	r3, [r7, #8]
    /**USART1 GPIO Configuration
    PA9     ------> USART1_TX
    PA10     ------> USART1_RX
    */
    GPIO_InitStruct.Pin = MCU_TX0_Pin|MCU_RX0_Pin;
 8000948:	193b      	adds	r3, r7, r4
 800094a:	22c0      	movs	r2, #192	; 0xc0
 800094c:	00d2      	lsls	r2, r2, #3
 800094e:	601a      	str	r2, [r3, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000950:	0021      	movs	r1, r4
 8000952:	187b      	adds	r3, r7, r1
 8000954:	2202      	movs	r2, #2
 8000956:	605a      	str	r2, [r3, #4]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000958:	187b      	adds	r3, r7, r1
 800095a:	2200      	movs	r2, #0
 800095c:	609a      	str	r2, [r3, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800095e:	187b      	adds	r3, r7, r1
 8000960:	2203      	movs	r2, #3
 8000962:	60da      	str	r2, [r3, #12]
    GPIO_InitStruct.Alternate = GPIO_AF4_USART1;
 8000964:	187b      	adds	r3, r7, r1
 8000966:	2204      	movs	r2, #4
 8000968:	611a      	str	r2, [r3, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800096a:	187a      	adds	r2, r7, r1
 800096c:	23a0      	movs	r3, #160	; 0xa0
 800096e:	05db      	lsls	r3, r3, #23
 8000970:	0011      	movs	r1, r2
 8000972:	0018      	movs	r0, r3
 8000974:	f002 fc32 	bl	80031dc <HAL_GPIO_Init>

    /* USART1 interrupt Init */
    HAL_NVIC_SetPriority(USART1_IRQn, 1, 0);
 8000978:	2200      	movs	r2, #0
 800097a:	2101      	movs	r1, #1
 800097c:	201b      	movs	r0, #27
 800097e:	f002 fb73 	bl	8003068 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART1_IRQn);
 8000982:	201b      	movs	r0, #27
 8000984:	f002 fb85 	bl	8003092 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USART1_MspInit 1 */

  /* USER CODE END USART1_MspInit 1 */
  }
}
 8000988:	46c0      	nop			; (mov r8, r8)
 800098a:	46bd      	mov	sp, r7
 800098c:	b009      	add	sp, #36	; 0x24
 800098e:	bd90      	pop	{r4, r7, pc}
 8000990:	40013800 	.word	0x40013800
 8000994:	40021000 	.word	0x40021000

08000998 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
   ldr   r0, =_estack
 8000998:	480d      	ldr	r0, [pc, #52]	; (80009d0 <LoopForever+0x2>)
   mov   sp, r0          /* set stack pointer */
 800099a:	4685      	mov	sp, r0

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 800099c:	480d      	ldr	r0, [pc, #52]	; (80009d4 <LoopForever+0x6>)
  ldr r1, =_edata
 800099e:	490e      	ldr	r1, [pc, #56]	; (80009d8 <LoopForever+0xa>)
  ldr r2, =_sidata
 80009a0:	4a0e      	ldr	r2, [pc, #56]	; (80009dc <LoopForever+0xe>)
  movs r3, #0
 80009a2:	2300      	movs	r3, #0
  b LoopCopyDataInit
 80009a4:	e002      	b.n	80009ac <LoopCopyDataInit>

080009a6 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 80009a6:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 80009a8:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 80009aa:	3304      	adds	r3, #4

080009ac <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 80009ac:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 80009ae:	428c      	cmp	r4, r1
  bcc CopyDataInit
 80009b0:	d3f9      	bcc.n	80009a6 <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 80009b2:	4a0b      	ldr	r2, [pc, #44]	; (80009e0 <LoopForever+0x12>)
  ldr r4, =_ebss
 80009b4:	4c0b      	ldr	r4, [pc, #44]	; (80009e4 <LoopForever+0x16>)
  movs r3, #0
 80009b6:	2300      	movs	r3, #0
  b LoopFillZerobss
 80009b8:	e001      	b.n	80009be <LoopFillZerobss>

080009ba <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 80009ba:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 80009bc:	3204      	adds	r2, #4

080009be <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 80009be:	42a2      	cmp	r2, r4
  bcc FillZerobss
 80009c0:	d3fb      	bcc.n	80009ba <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit
 80009c2:	f7ff ff67 	bl	8000894 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 80009c6:	f01c fa45 	bl	801ce54 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 80009ca:	f7ff fe6f 	bl	80006ac <main>

080009ce <LoopForever>:

LoopForever:
    b LoopForever
 80009ce:	e7fe      	b.n	80009ce <LoopForever>
   ldr   r0, =_estack
 80009d0:	20005000 	.word	0x20005000
  ldr r0, =_sdata
 80009d4:	20000000 	.word	0x20000000
  ldr r1, =_edata
 80009d8:	2000009c 	.word	0x2000009c
  ldr r2, =_sidata
 80009dc:	08023008 	.word	0x08023008
  ldr r2, =_sbss
 80009e0:	2000009c 	.word	0x2000009c
  ldr r4, =_ebss
 80009e4:	20003e34 	.word	0x20003e34

080009e8 <ADC1_COMP_IRQHandler>:
 * @retval : None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 80009e8:	e7fe      	b.n	80009e8 <ADC1_COMP_IRQHandler>
	...

080009ec <__NVIC_SystemReset>:
/**
  \brief   System Reset
  \details Initiates a system reset request to reset the MCU.
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
 80009ec:	b580      	push	{r7, lr}
 80009ee:	af00      	add	r7, sp, #0
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 80009f0:	f3bf 8f4f 	dsb	sy
}
 80009f4:	46c0      	nop			; (mov r8, r8)
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 80009f6:	4b04      	ldr	r3, [pc, #16]	; (8000a08 <__NVIC_SystemReset+0x1c>)
 80009f8:	4a04      	ldr	r2, [pc, #16]	; (8000a0c <__NVIC_SystemReset+0x20>)
 80009fa:	60da      	str	r2, [r3, #12]
  __ASM volatile ("dsb 0xF":::"memory");
 80009fc:	f3bf 8f4f 	dsb	sy
}
 8000a00:	46c0      	nop			; (mov r8, r8)
                 SCB_AIRCR_SYSRESETREQ_Msk);
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 8000a02:	46c0      	nop			; (mov r8, r8)
 8000a04:	e7fd      	b.n	8000a02 <__NVIC_SystemReset+0x16>
 8000a06:	46c0      	nop			; (mov r8, r8)
 8000a08:	e000ed00 	.word	0xe000ed00
 8000a0c:	05fa0004 	.word	0x05fa0004

08000a10 <GSM_Config_Module>:
    {"ATD*99***1#\r\n", "CONNECT", "", "", "", 1000, 10, open_ppp_stack}, // Open ppp stack
    
};

void GSM_Config_Module (GSM_Response_Event_TypDef event, void *Resp_Buffer)
{
 8000a10:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000a12:	b089      	sub	sp, #36	; 0x24
 8000a14:	af04      	add	r7, sp, #16
 8000a16:	0002      	movs	r2, r0
 8000a18:	6039      	str	r1, [r7, #0]
 8000a1a:	1dfb      	adds	r3, r7, #7
 8000a1c:	701a      	strb	r2, [r3, #0]
    uint8_t TableIndex = GSM_Manager.step;
 8000a1e:	210f      	movs	r1, #15
 8000a20:	187b      	adds	r3, r7, r1
 8000a22:	4a4d      	ldr	r2, [pc, #308]	; (8000b58 <GSM_Config_Module+0x148>)
 8000a24:	7852      	ldrb	r2, [r2, #1]
 8000a26:	701a      	strb	r2, [r3, #0]
    const static uint8_t TableSize = sizeof(ATC_Table_Config_Module)/sizeof(ATC_Table_Config_Module[0]);
    if(TableIndex > TableSize)
 8000a28:	4b4c      	ldr	r3, [pc, #304]	; (8000b5c <GSM_Config_Module+0x14c>)
 8000a2a:	781b      	ldrb	r3, [r3, #0]
 8000a2c:	187a      	adds	r2, r7, r1
 8000a2e:	7812      	ldrb	r2, [r2, #0]
 8000a30:	429a      	cmp	r2, r3
 8000a32:	d900      	bls.n	8000a36 <GSM_Config_Module+0x26>
 8000a34:	e08b      	b.n	8000b4e <GSM_Config_Module+0x13e>
    {
        return;
    }
    DEBUG_PrintResult_ATC(ATC_Table_Config_Module[TableIndex-1].cmd, (event == GSM_EVENT_OK)?"[OK]":"[FAIL]");
 8000a36:	187b      	adds	r3, r7, r1
 8000a38:	781b      	ldrb	r3, [r3, #0]
 8000a3a:	1e5a      	subs	r2, r3, #1
 8000a3c:	4b48      	ldr	r3, [pc, #288]	; (8000b60 <GSM_Config_Module+0x150>)
 8000a3e:	0152      	lsls	r2, r2, #5
 8000a40:	58d2      	ldr	r2, [r2, r3]
 8000a42:	1dfb      	adds	r3, r7, #7
 8000a44:	781b      	ldrb	r3, [r3, #0]
 8000a46:	2b00      	cmp	r3, #0
 8000a48:	d101      	bne.n	8000a4e <GSM_Config_Module+0x3e>
 8000a4a:	4b46      	ldr	r3, [pc, #280]	; (8000b64 <GSM_Config_Module+0x154>)
 8000a4c:	e000      	b.n	8000a50 <GSM_Config_Module+0x40>
 8000a4e:	4b46      	ldr	r3, [pc, #280]	; (8000b68 <GSM_Config_Module+0x158>)
 8000a50:	0019      	movs	r1, r3
 8000a52:	0010      	movs	r0, r2
 8000a54:	f001 fee8 	bl	8002828 <DEBUG_PrintResult_ATC>
    if(event == GSM_EVENT_OK)
 8000a58:	1dfb      	adds	r3, r7, #7
 8000a5a:	781b      	ldrb	r3, [r3, #0]
 8000a5c:	2b00      	cmp	r3, #0
 8000a5e:	d172      	bne.n	8000b46 <GSM_Config_Module+0x136>
    {
        if(TableIndex < TableSize)
 8000a60:	4b3e      	ldr	r3, [pc, #248]	; (8000b5c <GSM_Config_Module+0x14c>)
 8000a62:	781b      	ldrb	r3, [r3, #0]
 8000a64:	210f      	movs	r1, #15
 8000a66:	187a      	adds	r2, r7, r1
 8000a68:	7812      	ldrb	r2, [r2, #0]
 8000a6a:	429a      	cmp	r2, r3
 8000a6c:	d215      	bcs.n	8000a9a <GSM_Config_Module+0x8a>
        {
        	//HAL_Delay(2000);
            GSM_SendCommand_AT(ATC_Table_Config_Module[TableIndex]);
 8000a6e:	187b      	adds	r3, r7, r1
 8000a70:	781b      	ldrb	r3, [r3, #0]
 8000a72:	4c3b      	ldr	r4, [pc, #236]	; (8000b60 <GSM_Config_Module+0x150>)
 8000a74:	015b      	lsls	r3, r3, #5
 8000a76:	2110      	movs	r1, #16
 8000a78:	18e2      	adds	r2, r4, r3
 8000a7a:	1851      	adds	r1, r2, r1
 8000a7c:	466a      	mov	r2, sp
 8000a7e:	c961      	ldmia	r1!, {r0, r5, r6}
 8000a80:	c261      	stmia	r2!, {r0, r5, r6}
 8000a82:	6809      	ldr	r1, [r1, #0]
 8000a84:	6011      	str	r1, [r2, #0]
 8000a86:	5918      	ldr	r0, [r3, r4]
 8000a88:	18e2      	adds	r2, r4, r3
 8000a8a:	6851      	ldr	r1, [r2, #4]
 8000a8c:	18e2      	adds	r2, r4, r3
 8000a8e:	6892      	ldr	r2, [r2, #8]
 8000a90:	18e3      	adds	r3, r4, r3
 8000a92:	68db      	ldr	r3, [r3, #12]
 8000a94:	f000 ff8e 	bl	80019b4 <GSM_SendCommand_AT>
 8000a98:	e04e      	b.n	8000b38 <GSM_Config_Module+0x128>
        }
        else
        {
            // Da Config Module xong
            GSM_Manager.step = 0;
 8000a9a:	4b2f      	ldr	r3, [pc, #188]	; (8000b58 <GSM_Config_Module+0x148>)
 8000a9c:	2200      	movs	r2, #0
 8000a9e:	705a      	strb	r2, [r3, #1]
            DEBUG_INFO("Config module DONE.\r\n");
 8000aa0:	f01c f9ba 	bl	801ce18 <sys_get_tick_ms>
 8000aa4:	0001      	movs	r1, r0
 8000aa6:	4a31      	ldr	r2, [pc, #196]	; (8000b6c <GSM_Config_Module+0x15c>)
 8000aa8:	4b31      	ldr	r3, [pc, #196]	; (8000b70 <GSM_Config_Module+0x160>)
 8000aaa:	0018      	movs	r0, r3
 8000aac:	f002 f88c 	bl	8002bc8 <app_debug_rtt_raw>
            //GSM_SendCommand_AT(ATC_Table_open_ppp_stack[0]);
            /* Set up File Send*/
            Multi_FileSendCfg.NumberFile = 3;
 8000ab0:	4b30      	ldr	r3, [pc, #192]	; (8000b74 <GSM_Config_Module+0x164>)
 8000ab2:	22c8      	movs	r2, #200	; 0xc8
 8000ab4:	2103      	movs	r1, #3
 8000ab6:	5499      	strb	r1, [r3, r2]
            Multi_FileSendCfg.File[0].Name = "test6.txt";
 8000ab8:	4b2e      	ldr	r3, [pc, #184]	; (8000b74 <GSM_Config_Module+0x164>)
 8000aba:	4a2f      	ldr	r2, [pc, #188]	; (8000b78 <GSM_Config_Module+0x168>)
 8000abc:	609a      	str	r2, [r3, #8]
            Multi_FileSendCfg.File[0].Data = "\r\nHello World!!! File6\r\n";
 8000abe:	4b2d      	ldr	r3, [pc, #180]	; (8000b74 <GSM_Config_Module+0x164>)
 8000ac0:	4a2e      	ldr	r2, [pc, #184]	; (8000b7c <GSM_Config_Module+0x16c>)
 8000ac2:	601a      	str	r2, [r3, #0]
            Multi_FileSendCfg.File[0].DataLength = strlen(Multi_FileSendCfg.File[0].Data);
 8000ac4:	4b2b      	ldr	r3, [pc, #172]	; (8000b74 <GSM_Config_Module+0x164>)
 8000ac6:	681b      	ldr	r3, [r3, #0]
 8000ac8:	0018      	movs	r0, r3
 8000aca:	f7ff fb1d 	bl	8000108 <strlen>
 8000ace:	0003      	movs	r3, r0
 8000ad0:	b29a      	uxth	r2, r3
 8000ad2:	4b28      	ldr	r3, [pc, #160]	; (8000b74 <GSM_Config_Module+0x164>)
 8000ad4:	809a      	strh	r2, [r3, #4]
            Multi_FileSendCfg.File[0].Directory = "/Test/";
 8000ad6:	4b27      	ldr	r3, [pc, #156]	; (8000b74 <GSM_Config_Module+0x164>)
 8000ad8:	4a29      	ldr	r2, [pc, #164]	; (8000b80 <GSM_Config_Module+0x170>)
 8000ada:	60da      	str	r2, [r3, #12]

            Multi_FileSendCfg.File[1].Name = "test2.txt";
 8000adc:	4b25      	ldr	r3, [pc, #148]	; (8000b74 <GSM_Config_Module+0x164>)
 8000ade:	4a29      	ldr	r2, [pc, #164]	; (8000b84 <GSM_Config_Module+0x174>)
 8000ae0:	61da      	str	r2, [r3, #28]
            Multi_FileSendCfg.File[1].Data = "\r\nHello World!!! File2\r\n";
 8000ae2:	4b24      	ldr	r3, [pc, #144]	; (8000b74 <GSM_Config_Module+0x164>)
 8000ae4:	4a28      	ldr	r2, [pc, #160]	; (8000b88 <GSM_Config_Module+0x178>)
 8000ae6:	615a      	str	r2, [r3, #20]
            Multi_FileSendCfg.File[1].DataLength = strlen(Multi_FileSendCfg.File[1].Data);
 8000ae8:	4b22      	ldr	r3, [pc, #136]	; (8000b74 <GSM_Config_Module+0x164>)
 8000aea:	695b      	ldr	r3, [r3, #20]
 8000aec:	0018      	movs	r0, r3
 8000aee:	f7ff fb0b 	bl	8000108 <strlen>
 8000af2:	0003      	movs	r3, r0
 8000af4:	b29a      	uxth	r2, r3
 8000af6:	4b1f      	ldr	r3, [pc, #124]	; (8000b74 <GSM_Config_Module+0x164>)
 8000af8:	831a      	strh	r2, [r3, #24]
            Multi_FileSendCfg.File[1].Directory = "/Test/";
 8000afa:	4b1e      	ldr	r3, [pc, #120]	; (8000b74 <GSM_Config_Module+0x164>)
 8000afc:	4a20      	ldr	r2, [pc, #128]	; (8000b80 <GSM_Config_Module+0x170>)
 8000afe:	621a      	str	r2, [r3, #32]

            Multi_FileSendCfg.File[2].Name = "test3.txt";
 8000b00:	4b1c      	ldr	r3, [pc, #112]	; (8000b74 <GSM_Config_Module+0x164>)
 8000b02:	4a22      	ldr	r2, [pc, #136]	; (8000b8c <GSM_Config_Module+0x17c>)
 8000b04:	631a      	str	r2, [r3, #48]	; 0x30
            Multi_FileSendCfg.File[2].Data = "\r\nHello World!!! File3\r\n";
 8000b06:	4b1b      	ldr	r3, [pc, #108]	; (8000b74 <GSM_Config_Module+0x164>)
 8000b08:	4a21      	ldr	r2, [pc, #132]	; (8000b90 <GSM_Config_Module+0x180>)
 8000b0a:	629a      	str	r2, [r3, #40]	; 0x28
            Multi_FileSendCfg.File[2].DataLength = strlen(Multi_FileSendCfg.File[2].Data);
 8000b0c:	4b19      	ldr	r3, [pc, #100]	; (8000b74 <GSM_Config_Module+0x164>)
 8000b0e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8000b10:	0018      	movs	r0, r3
 8000b12:	f7ff faf9 	bl	8000108 <strlen>
 8000b16:	0003      	movs	r3, r0
 8000b18:	b29a      	uxth	r2, r3
 8000b1a:	4b16      	ldr	r3, [pc, #88]	; (8000b74 <GSM_Config_Module+0x164>)
 8000b1c:	859a      	strh	r2, [r3, #44]	; 0x2c
            Multi_FileSendCfg.File[2].Directory = "/Test/";
 8000b1e:	4b15      	ldr	r3, [pc, #84]	; (8000b74 <GSM_Config_Module+0x164>)
 8000b20:	4a17      	ldr	r2, [pc, #92]	; (8000b80 <GSM_Config_Module+0x170>)
 8000b22:	635a      	str	r2, [r3, #52]	; 0x34

            GSM_Send_File(&Multi_FileSendCfg);
 8000b24:	4b13      	ldr	r3, [pc, #76]	; (8000b74 <GSM_Config_Module+0x164>)
 8000b26:	0018      	movs	r0, r3
 8000b28:	f001 fd74 	bl	8002614 <GSM_Send_File>
            FileDownload_Cfg.Name = "Readme.txt";
 8000b2c:	4b19      	ldr	r3, [pc, #100]	; (8000b94 <GSM_Config_Module+0x184>)
 8000b2e:	4a1a      	ldr	r2, [pc, #104]	; (8000b98 <GSM_Config_Module+0x188>)
 8000b30:	609a      	str	r2, [r3, #8]
            FileDownload_Cfg.Directory = "/Test/";
 8000b32:	4b18      	ldr	r3, [pc, #96]	; (8000b94 <GSM_Config_Module+0x184>)
 8000b34:	4a12      	ldr	r2, [pc, #72]	; (8000b80 <GSM_Config_Module+0x170>)
 8000b36:	60da      	str	r2, [r3, #12]
            //GSM_Download_File(&FileDownload_Cfg);
        }
        GSM_Manager.step++;
 8000b38:	4b07      	ldr	r3, [pc, #28]	; (8000b58 <GSM_Config_Module+0x148>)
 8000b3a:	785b      	ldrb	r3, [r3, #1]
 8000b3c:	3301      	adds	r3, #1
 8000b3e:	b2da      	uxtb	r2, r3
 8000b40:	4b05      	ldr	r3, [pc, #20]	; (8000b58 <GSM_Config_Module+0x148>)
 8000b42:	705a      	strb	r2, [r3, #1]
 8000b44:	e004      	b.n	8000b50 <GSM_Config_Module+0x140>
    }
    else //if(event == GSM_EVENT_TIMEOUT)
    {
        GSM_Manager_ChangeState(GSM_STATE_RESET);
 8000b46:	2001      	movs	r0, #1
 8000b48:	f000 fbfa 	bl	8001340 <GSM_Manager_ChangeState>
 8000b4c:	e000      	b.n	8000b50 <GSM_Config_Module+0x140>
        return;
 8000b4e:	46c0      	nop			; (mov r8, r8)
    }
}
 8000b50:	46bd      	mov	sp, r7
 8000b52:	b005      	add	sp, #20
 8000b54:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000b56:	46c0      	nop			; (mov r8, r8)
 8000b58:	20001884 	.word	0x20001884
 8000b5c:	0802251c 	.word	0x0802251c
 8000b60:	08022134 	.word	0x08022134
 8000b64:	0801dbac 	.word	0x0801dbac
 8000b68:	0801dbb4 	.word	0x0801dbb4
 8000b6c:	0801da5c 	.word	0x0801da5c
 8000b70:	0801dbbc 	.word	0x0801dbbc
 8000b74:	200000d8 	.word	0x200000d8
 8000b78:	0801dbec 	.word	0x0801dbec
 8000b7c:	0801dbf8 	.word	0x0801dbf8
 8000b80:	0801dc14 	.word	0x0801dc14
 8000b84:	0801dc1c 	.word	0x0801dc1c
 8000b88:	0801dc28 	.word	0x0801dc28
 8000b8c:	0801dc44 	.word	0x0801dc44
 8000b90:	0801dc50 	.word	0x0801dc50
 8000b94:	200001a4 	.word	0x200001a4
 8000b98:	0801dc6c 	.word	0x0801dc6c

08000b9c <open_ppp_stack>:
void open_ppp_stack(GSM_Response_Event_TypDef event, void *Resp_Buffer)
{
 8000b9c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000b9e:	b089      	sub	sp, #36	; 0x24
 8000ba0:	af04      	add	r7, sp, #16
 8000ba2:	0002      	movs	r2, r0
 8000ba4:	6039      	str	r1, [r7, #0]
 8000ba6:	1dfb      	adds	r3, r7, #7
 8000ba8:	701a      	strb	r2, [r3, #0]
    DEBUG_INFO("Open PPP stack step %d\r\n", GSM_Manager.step);
 8000baa:	f01c f935 	bl	801ce18 <sys_get_tick_ms>
 8000bae:	0001      	movs	r1, r0
 8000bb0:	4b40      	ldr	r3, [pc, #256]	; (8000cb4 <open_ppp_stack+0x118>)
 8000bb2:	785b      	ldrb	r3, [r3, #1]
 8000bb4:	4a40      	ldr	r2, [pc, #256]	; (8000cb8 <open_ppp_stack+0x11c>)
 8000bb6:	4841      	ldr	r0, [pc, #260]	; (8000cbc <open_ppp_stack+0x120>)
 8000bb8:	f002 f806 	bl	8002bc8 <app_debug_rtt_raw>
    uint8_t TableIndex = GSM_Manager.step;
 8000bbc:	210f      	movs	r1, #15
 8000bbe:	187b      	adds	r3, r7, r1
 8000bc0:	4a3c      	ldr	r2, [pc, #240]	; (8000cb4 <open_ppp_stack+0x118>)
 8000bc2:	7852      	ldrb	r2, [r2, #1]
 8000bc4:	701a      	strb	r2, [r3, #0]
    const static uint8_t TableSize = sizeof(ATC_Table_open_ppp_stack)/sizeof(ATC_Table_open_ppp_stack[0]);
    if(TableIndex > TableSize)
 8000bc6:	4b3e      	ldr	r3, [pc, #248]	; (8000cc0 <open_ppp_stack+0x124>)
 8000bc8:	781b      	ldrb	r3, [r3, #0]
 8000bca:	187a      	adds	r2, r7, r1
 8000bcc:	7812      	ldrb	r2, [r2, #0]
 8000bce:	429a      	cmp	r2, r3
 8000bd0:	d86c      	bhi.n	8000cac <open_ppp_stack+0x110>
    {
        return;
    }
    DEBUG_PrintResult_ATC(ATC_Table_open_ppp_stack[TableIndex-1].cmd, (event == GSM_EVENT_OK)?"[OK]":"[FAIL]");
 8000bd2:	187b      	adds	r3, r7, r1
 8000bd4:	781b      	ldrb	r3, [r3, #0]
 8000bd6:	1e5a      	subs	r2, r3, #1
 8000bd8:	4b3a      	ldr	r3, [pc, #232]	; (8000cc4 <open_ppp_stack+0x128>)
 8000bda:	0152      	lsls	r2, r2, #5
 8000bdc:	58d2      	ldr	r2, [r2, r3]
 8000bde:	1dfb      	adds	r3, r7, #7
 8000be0:	781b      	ldrb	r3, [r3, #0]
 8000be2:	2b00      	cmp	r3, #0
 8000be4:	d101      	bne.n	8000bea <open_ppp_stack+0x4e>
 8000be6:	4b38      	ldr	r3, [pc, #224]	; (8000cc8 <open_ppp_stack+0x12c>)
 8000be8:	e000      	b.n	8000bec <open_ppp_stack+0x50>
 8000bea:	4b38      	ldr	r3, [pc, #224]	; (8000ccc <open_ppp_stack+0x130>)
 8000bec:	0019      	movs	r1, r3
 8000bee:	0010      	movs	r0, r2
 8000bf0:	f001 fe1a 	bl	8002828 <DEBUG_PrintResult_ATC>
    if(event == GSM_EVENT_OK)
 8000bf4:	1dfb      	adds	r3, r7, #7
 8000bf6:	781b      	ldrb	r3, [r3, #0]
 8000bf8:	2b00      	cmp	r3, #0
 8000bfa:	d153      	bne.n	8000ca4 <open_ppp_stack+0x108>
    {
        if(TableIndex < TableSize)
 8000bfc:	4b30      	ldr	r3, [pc, #192]	; (8000cc0 <open_ppp_stack+0x124>)
 8000bfe:	781b      	ldrb	r3, [r3, #0]
 8000c00:	210f      	movs	r1, #15
 8000c02:	187a      	adds	r2, r7, r1
 8000c04:	7812      	ldrb	r2, [r2, #0]
 8000c06:	429a      	cmp	r2, r3
 8000c08:	d215      	bcs.n	8000c36 <open_ppp_stack+0x9a>
        {
            GSM_SendCommand_AT(ATC_Table_open_ppp_stack[TableIndex]);
 8000c0a:	187b      	adds	r3, r7, r1
 8000c0c:	781b      	ldrb	r3, [r3, #0]
 8000c0e:	4c2d      	ldr	r4, [pc, #180]	; (8000cc4 <open_ppp_stack+0x128>)
 8000c10:	015b      	lsls	r3, r3, #5
 8000c12:	2110      	movs	r1, #16
 8000c14:	18e2      	adds	r2, r4, r3
 8000c16:	1851      	adds	r1, r2, r1
 8000c18:	466a      	mov	r2, sp
 8000c1a:	c961      	ldmia	r1!, {r0, r5, r6}
 8000c1c:	c261      	stmia	r2!, {r0, r5, r6}
 8000c1e:	6809      	ldr	r1, [r1, #0]
 8000c20:	6011      	str	r1, [r2, #0]
 8000c22:	5918      	ldr	r0, [r3, r4]
 8000c24:	18e2      	adds	r2, r4, r3
 8000c26:	6851      	ldr	r1, [r2, #4]
 8000c28:	18e2      	adds	r2, r4, r3
 8000c2a:	6892      	ldr	r2, [r2, #8]
 8000c2c:	18e3      	adds	r3, r4, r3
 8000c2e:	68db      	ldr	r3, [r3, #12]
 8000c30:	f000 fec0 	bl	80019b4 <GSM_SendCommand_AT>
 8000c34:	e02f      	b.n	8000c96 <open_ppp_stack+0xfa>
        }
        else
        {
            GSM_Manager.mode = GSM_INTERNET_MODE_PPP_STACK;
 8000c36:	4b1f      	ldr	r3, [pc, #124]	; (8000cb4 <open_ppp_stack+0x118>)
 8000c38:	2201      	movs	r2, #1
 8000c3a:	709a      	strb	r2, [r3, #2]
            // Da CONNECT PPP thanh cong
            GSM_Manager_ChangeState(GSM_STATE_OK);
 8000c3c:	2002      	movs	r0, #2
 8000c3e:	f000 fb7f 	bl	8001340 <GSM_Manager_ChangeState>

            //Create PPP connection
            m_ppp_control_block = pppos_create(&m_ppp_netif, ppp_output_callback, ppp_link_status_cb, NULL);
 8000c42:	4a23      	ldr	r2, [pc, #140]	; (8000cd0 <open_ppp_stack+0x134>)
 8000c44:	4923      	ldr	r1, [pc, #140]	; (8000cd4 <open_ppp_stack+0x138>)
 8000c46:	4824      	ldr	r0, [pc, #144]	; (8000cd8 <open_ppp_stack+0x13c>)
 8000c48:	2300      	movs	r3, #0
 8000c4a:	f019 fc7d 	bl	801a548 <pppos_create>
 8000c4e:	0002      	movs	r2, r0
 8000c50:	4b22      	ldr	r3, [pc, #136]	; (8000cdc <open_ppp_stack+0x140>)
 8000c52:	601a      	str	r2, [r3, #0]
            if (m_ppp_control_block == NULL)
 8000c54:	4b21      	ldr	r3, [pc, #132]	; (8000cdc <open_ppp_stack+0x140>)
 8000c56:	681b      	ldr	r3, [r3, #0]
 8000c58:	2b00      	cmp	r3, #0
 8000c5a:	d109      	bne.n	8000c70 <open_ppp_stack+0xd4>
            {
                DEBUG_ERROR("Create PPP interface ERR!\r\n");
 8000c5c:	f01c f8dc 	bl	801ce18 <sys_get_tick_ms>
 8000c60:	0001      	movs	r1, r0
 8000c62:	4a15      	ldr	r2, [pc, #84]	; (8000cb8 <open_ppp_stack+0x11c>)
 8000c64:	4b1e      	ldr	r3, [pc, #120]	; (8000ce0 <open_ppp_stack+0x144>)
 8000c66:	0018      	movs	r0, r3
 8000c68:	f001 ffae 	bl	8002bc8 <app_debug_rtt_raw>
                //assert(0);
                // TODO handle memory error
                NVIC_SystemReset();
 8000c6c:	f7ff febe 	bl	80009ec <__NVIC_SystemReset>
            }

            /* Set this interface as default route */
            ppp_set_default(m_ppp_control_block);
 8000c70:	4b1a      	ldr	r3, [pc, #104]	; (8000cdc <open_ppp_stack+0x140>)
 8000c72:	681b      	ldr	r3, [r3, #0]
 8000c74:	6a1b      	ldr	r3, [r3, #32]
 8000c76:	0018      	movs	r0, r3
 8000c78:	f008 fc62 	bl	8009540 <netif_set_default>
            //ppp_set_auth(m_ppp_control_block, PPPAUTHTYPE_CHAP, "", "");
            ppp_set_notify_phase_callback(m_ppp_control_block, ppp_notify_phase_cb);
 8000c7c:	4b17      	ldr	r3, [pc, #92]	; (8000cdc <open_ppp_stack+0x140>)
 8000c7e:	681b      	ldr	r3, [r3, #0]
 8000c80:	4a18      	ldr	r2, [pc, #96]	; (8000ce4 <open_ppp_stack+0x148>)
 8000c82:	0011      	movs	r1, r2
 8000c84:	0018      	movs	r0, r3
 8000c86:	f018 ffbb 	bl	8019c00 <ppp_set_notify_phase_callback>
            ppp_connect(m_ppp_control_block, 0);
 8000c8a:	4b14      	ldr	r3, [pc, #80]	; (8000cdc <open_ppp_stack+0x140>)
 8000c8c:	681b      	ldr	r3, [r3, #0]
 8000c8e:	2100      	movs	r1, #0
 8000c90:	0018      	movs	r0, r3
 8000c92:	f018 ffc9 	bl	8019c28 <ppp_connect>
        }
        GSM_Manager.step++;
 8000c96:	4b07      	ldr	r3, [pc, #28]	; (8000cb4 <open_ppp_stack+0x118>)
 8000c98:	785b      	ldrb	r3, [r3, #1]
 8000c9a:	3301      	adds	r3, #1
 8000c9c:	b2da      	uxtb	r2, r3
 8000c9e:	4b05      	ldr	r3, [pc, #20]	; (8000cb4 <open_ppp_stack+0x118>)
 8000ca0:	705a      	strb	r2, [r3, #1]
 8000ca2:	e004      	b.n	8000cae <open_ppp_stack+0x112>
    }
    else //if(event == GSM_EVENT_TIMEOUT)
    {
        // Handle ERROR
        GSM_Manager_ChangeState(GSM_STATE_RESET);
 8000ca4:	2001      	movs	r0, #1
 8000ca6:	f000 fb4b 	bl	8001340 <GSM_Manager_ChangeState>
 8000caa:	e000      	b.n	8000cae <open_ppp_stack+0x112>
        return;
 8000cac:	46c0      	nop			; (mov r8, r8)
    }
}
 8000cae:	46bd      	mov	sp, r7
 8000cb0:	b005      	add	sp, #20
 8000cb2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000cb4:	20001884 	.word	0x20001884
 8000cb8:	0801da5c 	.word	0x0801da5c
 8000cbc:	0801dc78 	.word	0x0801dc78
 8000cc0:	0802251d 	.word	0x0802251d
 8000cc4:	08022434 	.word	0x08022434
 8000cc8:	0801dbac 	.word	0x0801dbac
 8000ccc:	0801dbb4 	.word	0x0801dbb4
 8000cd0:	08000ff1 	.word	0x08000ff1
 8000cd4:	08000f19 	.word	0x08000f19
 8000cd8:	200001b4 	.word	0x200001b4
 8000cdc:	200001f0 	.word	0x200001f0
 8000ce0:	0801dcac 	.word	0x0801dcac
 8000ce4:	08000df5 	.word	0x08000df5

08000ce8 <GSM_GET_IMEI_Buffer>:
void GSM_GET_IMEI_Buffer(GSM_Response_Event_TypDef event, void *Resp_Buffer)
{
 8000ce8:	b580      	push	{r7, lr}
 8000cea:	b082      	sub	sp, #8
 8000cec:	af00      	add	r7, sp, #0
 8000cee:	0002      	movs	r2, r0
 8000cf0:	6039      	str	r1, [r7, #0]
 8000cf2:	1dfb      	adds	r3, r7, #7
 8000cf4:	701a      	strb	r2, [r3, #0]
    if(event != GSM_EVENT_OK)
 8000cf6:	1dfb      	adds	r3, r7, #7
 8000cf8:	781b      	ldrb	r3, [r3, #0]
 8000cfa:	2b00      	cmp	r3, #0
 8000cfc:	d007      	beq.n	8000d0e <GSM_GET_IMEI_Buffer+0x26>
    {
        GSM_Config_Module(event, &Resp_Buffer);
 8000cfe:	003a      	movs	r2, r7
 8000d00:	1dfb      	adds	r3, r7, #7
 8000d02:	781b      	ldrb	r3, [r3, #0]
 8000d04:	0011      	movs	r1, r2
 8000d06:	0018      	movs	r0, r3
 8000d08:	f7ff fe82 	bl	8000a10 <GSM_Config_Module>
 8000d0c:	e02e      	b.n	8000d6c <GSM_GET_IMEI_Buffer+0x84>
    }
    else
    {
        if(strlen((char*)GSM_IMEI_Buffer) < 14)
 8000d0e:	4b19      	ldr	r3, [pc, #100]	; (8000d74 <GSM_GET_IMEI_Buffer+0x8c>)
 8000d10:	0018      	movs	r0, r3
 8000d12:	f7ff f9f9 	bl	8000108 <strlen>
 8000d16:	0003      	movs	r3, r0
 8000d18:	2b0d      	cmp	r3, #13
 8000d1a:	d820      	bhi.n	8000d5e <GSM_GET_IMEI_Buffer+0x76>
        {
            GSM_Utilities_Get_IMEI(Resp_Buffer, GSM_IMEI_Buffer, 16);
 8000d1c:	683b      	ldr	r3, [r7, #0]
 8000d1e:	4915      	ldr	r1, [pc, #84]	; (8000d74 <GSM_GET_IMEI_Buffer+0x8c>)
 8000d20:	2210      	movs	r2, #16
 8000d22:	0018      	movs	r0, r3
 8000d24:	f001 fca4 	bl	8002670 <GSM_Utilities_Get_IMEI>
            if(strlen((char*)GSM_IMEI_Buffer) < 15)
 8000d28:	4b12      	ldr	r3, [pc, #72]	; (8000d74 <GSM_GET_IMEI_Buffer+0x8c>)
 8000d2a:	0018      	movs	r0, r3
 8000d2c:	f7ff f9ec 	bl	8000108 <strlen>
 8000d30:	0003      	movs	r3, r0
 8000d32:	2b0e      	cmp	r3, #14
 8000d34:	d80b      	bhi.n	8000d4e <GSM_GET_IMEI_Buffer+0x66>
            {
                DEBUG_WARN("IMEI's invalid!\r\n");
 8000d36:	f01c f86f 	bl	801ce18 <sys_get_tick_ms>
 8000d3a:	0001      	movs	r1, r0
 8000d3c:	4a0e      	ldr	r2, [pc, #56]	; (8000d78 <GSM_GET_IMEI_Buffer+0x90>)
 8000d3e:	4b0f      	ldr	r3, [pc, #60]	; (8000d7c <GSM_GET_IMEI_Buffer+0x94>)
 8000d40:	0018      	movs	r0, r3
 8000d42:	f001 ff41 	bl	8002bc8 <app_debug_rtt_raw>
                GSM_Manager_ChangeState(GSM_STATE_RESET); // Cant get GSM imei, maybe gsm module error =>> Restart module
 8000d46:	2001      	movs	r0, #1
 8000d48:	f000 fafa 	bl	8001340 <GSM_Manager_ChangeState>
                return;
 8000d4c:	e00e      	b.n	8000d6c <GSM_GET_IMEI_Buffer+0x84>
            }
            else
            {
                DEBUG_INFO("GSM IMEI: %s\r\n", GSM_IMEI_Buffer);
 8000d4e:	f01c f863 	bl	801ce18 <sys_get_tick_ms>
 8000d52:	0001      	movs	r1, r0
 8000d54:	4b07      	ldr	r3, [pc, #28]	; (8000d74 <GSM_GET_IMEI_Buffer+0x8c>)
 8000d56:	4a08      	ldr	r2, [pc, #32]	; (8000d78 <GSM_GET_IMEI_Buffer+0x90>)
 8000d58:	4809      	ldr	r0, [pc, #36]	; (8000d80 <GSM_GET_IMEI_Buffer+0x98>)
 8000d5a:	f001 ff35 	bl	8002bc8 <app_debug_rtt_raw>
            }
        }
        GSM_Config_Module(event, &Resp_Buffer);
 8000d5e:	003a      	movs	r2, r7
 8000d60:	1dfb      	adds	r3, r7, #7
 8000d62:	781b      	ldrb	r3, [r3, #0]
 8000d64:	0011      	movs	r1, r2
 8000d66:	0018      	movs	r0, r3
 8000d68:	f7ff fe52 	bl	8000a10 <GSM_Config_Module>
    }
}
 8000d6c:	46bd      	mov	sp, r7
 8000d6e:	b002      	add	sp, #8
 8000d70:	bd80      	pop	{r7, pc}
 8000d72:	46c0      	nop			; (mov r8, r8)
 8000d74:	200000c0 	.word	0x200000c0
 8000d78:	0801da5c 	.word	0x0801da5c
 8000d7c:	0801dce4 	.word	0x0801dce4
 8000d80:	0801dd10 	.word	0x0801dd10

08000d84 <GSM_GET_Signal_Strength>:
void GSM_GET_Signal_Strength(GSM_Response_Event_TypDef event, void *Resp_Buffer)
{
 8000d84:	b580      	push	{r7, lr}
 8000d86:	b082      	sub	sp, #8
 8000d88:	af00      	add	r7, sp, #0
 8000d8a:	0002      	movs	r2, r0
 8000d8c:	6039      	str	r1, [r7, #0]
 8000d8e:	1dfb      	adds	r3, r7, #7
 8000d90:	701a      	strb	r2, [r3, #0]
    
    if(event != GSM_EVENT_OK)
 8000d92:	1dfb      	adds	r3, r7, #7
 8000d94:	781b      	ldrb	r3, [r3, #0]
 8000d96:	2b00      	cmp	r3, #0
 8000d98:	d007      	beq.n	8000daa <GSM_GET_Signal_Strength+0x26>
    {
        GSM_Config_Module(event, &Resp_Buffer);
 8000d9a:	003a      	movs	r2, r7
 8000d9c:	1dfb      	adds	r3, r7, #7
 8000d9e:	781b      	ldrb	r3, [r3, #0]
 8000da0:	0011      	movs	r1, r2
 8000da2:	0018      	movs	r0, r3
 8000da4:	f7ff fe34 	bl	8000a10 <GSM_Config_Module>
            gsm_utilities_get_signal_strength_from_buffer(Resp_Buffer, &GSM_Signal_Strength);
            DEBUG_INFO("GSM Signal strength: %d\r\n", GSM_Signal_Strength);
        }
        GSM_Config_Module(event, &Resp_Buffer);
    }
}
 8000da8:	e019      	b.n	8000dde <GSM_GET_Signal_Strength+0x5a>
        if(GSM_Signal_Strength == 0)
 8000daa:	4b0f      	ldr	r3, [pc, #60]	; (8000de8 <GSM_GET_Signal_Strength+0x64>)
 8000dac:	881b      	ldrh	r3, [r3, #0]
 8000dae:	2b00      	cmp	r3, #0
 8000db0:	d10e      	bne.n	8000dd0 <GSM_GET_Signal_Strength+0x4c>
            gsm_utilities_get_signal_strength_from_buffer(Resp_Buffer, &GSM_Signal_Strength);
 8000db2:	683b      	ldr	r3, [r7, #0]
 8000db4:	4a0c      	ldr	r2, [pc, #48]	; (8000de8 <GSM_GET_Signal_Strength+0x64>)
 8000db6:	0011      	movs	r1, r2
 8000db8:	0018      	movs	r0, r3
 8000dba:	f001 fc9d 	bl	80026f8 <gsm_utilities_get_signal_strength_from_buffer>
            DEBUG_INFO("GSM Signal strength: %d\r\n", GSM_Signal_Strength);
 8000dbe:	f01c f82b 	bl	801ce18 <sys_get_tick_ms>
 8000dc2:	0001      	movs	r1, r0
 8000dc4:	4b08      	ldr	r3, [pc, #32]	; (8000de8 <GSM_GET_Signal_Strength+0x64>)
 8000dc6:	881b      	ldrh	r3, [r3, #0]
 8000dc8:	4a08      	ldr	r2, [pc, #32]	; (8000dec <GSM_GET_Signal_Strength+0x68>)
 8000dca:	4809      	ldr	r0, [pc, #36]	; (8000df0 <GSM_GET_Signal_Strength+0x6c>)
 8000dcc:	f001 fefc 	bl	8002bc8 <app_debug_rtt_raw>
        GSM_Config_Module(event, &Resp_Buffer);
 8000dd0:	003a      	movs	r2, r7
 8000dd2:	1dfb      	adds	r3, r7, #7
 8000dd4:	781b      	ldrb	r3, [r3, #0]
 8000dd6:	0011      	movs	r1, r2
 8000dd8:	0018      	movs	r0, r3
 8000dda:	f7ff fe19 	bl	8000a10 <GSM_Config_Module>
}
 8000dde:	46c0      	nop			; (mov r8, r8)
 8000de0:	46bd      	mov	sp, r7
 8000de2:	b002      	add	sp, #8
 8000de4:	bd80      	pop	{r7, pc}
 8000de6:	46c0      	nop			; (mov r8, r8)
 8000de8:	200000d4 	.word	0x200000d4
 8000dec:	0801da5c 	.word	0x0801da5c
 8000df0:	0801dd38 	.word	0x0801dd38

08000df4 <ppp_notify_phase_cb>:
static void ppp_notify_phase_cb(ppp_pcb *pcb, u8_t phase, void *ctx)
{
 8000df4:	b580      	push	{r7, lr}
 8000df6:	b084      	sub	sp, #16
 8000df8:	af00      	add	r7, sp, #0
 8000dfa:	60f8      	str	r0, [r7, #12]
 8000dfc:	607a      	str	r2, [r7, #4]
 8000dfe:	200b      	movs	r0, #11
 8000e00:	183b      	adds	r3, r7, r0
 8000e02:	1c0a      	adds	r2, r1, #0
 8000e04:	701a      	strb	r2, [r3, #0]
    switch (phase)
 8000e06:	183b      	adds	r3, r7, r0
 8000e08:	781b      	ldrb	r3, [r3, #0]
 8000e0a:	2b0c      	cmp	r3, #12
 8000e0c:	d85b      	bhi.n	8000ec6 <ppp_notify_phase_cb+0xd2>
 8000e0e:	009a      	lsls	r2, r3, #2
 8000e10:	4b34      	ldr	r3, [pc, #208]	; (8000ee4 <ppp_notify_phase_cb+0xf0>)
 8000e12:	18d3      	adds	r3, r2, r3
 8000e14:	681b      	ldr	r3, [r3, #0]
 8000e16:	469f      	mov	pc, r3
    {
    /* Session is down (either permanently or briefly) */
    case PPP_PHASE_DEAD:
        DEBUG_INFO("PPP_PHASE_DEAD\r\n");
 8000e18:	f01b fffe 	bl	801ce18 <sys_get_tick_ms>
 8000e1c:	0001      	movs	r1, r0
 8000e1e:	4a32      	ldr	r2, [pc, #200]	; (8000ee8 <ppp_notify_phase_cb+0xf4>)
 8000e20:	4b32      	ldr	r3, [pc, #200]	; (8000eec <ppp_notify_phase_cb+0xf8>)
 8000e22:	0018      	movs	r0, r3
 8000e24:	f001 fed0 	bl	8002bc8 <app_debug_rtt_raw>
        GSM_Manager.ppp_phase = PPP_PHASE_DEAD;
 8000e28:	4b31      	ldr	r3, [pc, #196]	; (8000ef0 <ppp_notify_phase_cb+0xfc>)
 8000e2a:	2200      	movs	r2, #0
 8000e2c:	70da      	strb	r2, [r3, #3]
        break;
 8000e2e:	e055      	b.n	8000edc <ppp_notify_phase_cb+0xe8>

    /* We are between two sessions */
    case PPP_PHASE_HOLDOFF:
        DEBUG_INFO("PPP_PHASE_HOLDOFF\r\n");
 8000e30:	f01b fff2 	bl	801ce18 <sys_get_tick_ms>
 8000e34:	0001      	movs	r1, r0
 8000e36:	4a2c      	ldr	r2, [pc, #176]	; (8000ee8 <ppp_notify_phase_cb+0xf4>)
 8000e38:	4b2e      	ldr	r3, [pc, #184]	; (8000ef4 <ppp_notify_phase_cb+0x100>)
 8000e3a:	0018      	movs	r0, r3
 8000e3c:	f001 fec4 	bl	8002bc8 <app_debug_rtt_raw>
        GSM_Manager.ppp_phase = PPP_PHASE_HOLDOFF;
 8000e40:	4b2b      	ldr	r3, [pc, #172]	; (8000ef0 <ppp_notify_phase_cb+0xfc>)
 8000e42:	2202      	movs	r2, #2
 8000e44:	70da      	strb	r2, [r3, #3]
        break;
 8000e46:	e049      	b.n	8000edc <ppp_notify_phase_cb+0xe8>

    /* Session just started */
    case PPP_PHASE_INITIALIZE:
        DEBUG_INFO("PPP_PHASE_INITIALIZE\r\n");
 8000e48:	f01b ffe6 	bl	801ce18 <sys_get_tick_ms>
 8000e4c:	0001      	movs	r1, r0
 8000e4e:	4a26      	ldr	r2, [pc, #152]	; (8000ee8 <ppp_notify_phase_cb+0xf4>)
 8000e50:	4b29      	ldr	r3, [pc, #164]	; (8000ef8 <ppp_notify_phase_cb+0x104>)
 8000e52:	0018      	movs	r0, r3
 8000e54:	f001 feb8 	bl	8002bc8 <app_debug_rtt_raw>
        GSM_Manager.ppp_phase = PPP_PHASE_INITIALIZE;
 8000e58:	4b25      	ldr	r3, [pc, #148]	; (8000ef0 <ppp_notify_phase_cb+0xfc>)
 8000e5a:	2203      	movs	r2, #3
 8000e5c:	70da      	strb	r2, [r3, #3]
        break;
 8000e5e:	e03d      	b.n	8000edc <ppp_notify_phase_cb+0xe8>

    case PPP_PHASE_NETWORK:
        DEBUG_INFO("PPP_PHASE_NETWORK\r\n");
 8000e60:	f01b ffda 	bl	801ce18 <sys_get_tick_ms>
 8000e64:	0001      	movs	r1, r0
 8000e66:	4a20      	ldr	r2, [pc, #128]	; (8000ee8 <ppp_notify_phase_cb+0xf4>)
 8000e68:	4b24      	ldr	r3, [pc, #144]	; (8000efc <ppp_notify_phase_cb+0x108>)
 8000e6a:	0018      	movs	r0, r3
 8000e6c:	f001 feac 	bl	8002bc8 <app_debug_rtt_raw>
        break;
 8000e70:	e034      	b.n	8000edc <ppp_notify_phase_cb+0xe8>

    case PPP_PHASE_ESTABLISH:
        DEBUG_INFO("PPP_PHASE_ESTABLISH\r\n");
 8000e72:	f01b ffd1 	bl	801ce18 <sys_get_tick_ms>
 8000e76:	0001      	movs	r1, r0
 8000e78:	4a1b      	ldr	r2, [pc, #108]	; (8000ee8 <ppp_notify_phase_cb+0xf4>)
 8000e7a:	4b21      	ldr	r3, [pc, #132]	; (8000f00 <ppp_notify_phase_cb+0x10c>)
 8000e7c:	0018      	movs	r0, r3
 8000e7e:	f001 fea3 	bl	8002bc8 <app_debug_rtt_raw>
        break;
 8000e82:	e02b      	b.n	8000edc <ppp_notify_phase_cb+0xe8>

    /* Session is running */
    case PPP_PHASE_RUNNING:
        DEBUG_INFO("PPP_PHASE_RUNNING\r\n");
 8000e84:	f01b ffc8 	bl	801ce18 <sys_get_tick_ms>
 8000e88:	0001      	movs	r1, r0
 8000e8a:	4a17      	ldr	r2, [pc, #92]	; (8000ee8 <ppp_notify_phase_cb+0xf4>)
 8000e8c:	4b1d      	ldr	r3, [pc, #116]	; (8000f04 <ppp_notify_phase_cb+0x110>)
 8000e8e:	0018      	movs	r0, r3
 8000e90:	f001 fe9a 	bl	8002bc8 <app_debug_rtt_raw>
        GSM_Manager.ppp_phase = PPP_PHASE_RUNNING;
 8000e94:	4b16      	ldr	r3, [pc, #88]	; (8000ef0 <ppp_notify_phase_cb+0xfc>)
 8000e96:	220a      	movs	r2, #10
 8000e98:	70da      	strb	r2, [r3, #3]
        m_ppp_connected = true;
 8000e9a:	4b1b      	ldr	r3, [pc, #108]	; (8000f08 <ppp_notify_phase_cb+0x114>)
 8000e9c:	2201      	movs	r2, #1
 8000e9e:	701a      	strb	r2, [r3, #0]
        break;
 8000ea0:	e01c      	b.n	8000edc <ppp_notify_phase_cb+0xe8>

    case PPP_PHASE_TERMINATE:
        DEBUG_INFO("PPP_PHASE_TERMINATE\r\n");
 8000ea2:	f01b ffb9 	bl	801ce18 <sys_get_tick_ms>
 8000ea6:	0001      	movs	r1, r0
 8000ea8:	4a0f      	ldr	r2, [pc, #60]	; (8000ee8 <ppp_notify_phase_cb+0xf4>)
 8000eaa:	4b18      	ldr	r3, [pc, #96]	; (8000f0c <ppp_notify_phase_cb+0x118>)
 8000eac:	0018      	movs	r0, r3
 8000eae:	f001 fe8b 	bl	8002bc8 <app_debug_rtt_raw>
        break;
 8000eb2:	e013      	b.n	8000edc <ppp_notify_phase_cb+0xe8>

    case PPP_PHASE_DISCONNECT:
        DEBUG_INFO("PPP_PHASE_DISCONNECT\r\n");
 8000eb4:	f01b ffb0 	bl	801ce18 <sys_get_tick_ms>
 8000eb8:	0001      	movs	r1, r0
 8000eba:	4a0b      	ldr	r2, [pc, #44]	; (8000ee8 <ppp_notify_phase_cb+0xf4>)
 8000ebc:	4b14      	ldr	r3, [pc, #80]	; (8000f10 <ppp_notify_phase_cb+0x11c>)
 8000ebe:	0018      	movs	r0, r3
 8000ec0:	f001 fe82 	bl	8002bc8 <app_debug_rtt_raw>
        break;
 8000ec4:	e00a      	b.n	8000edc <ppp_notify_phase_cb+0xe8>

    default:
        DEBUG_INFO("Unknown PPP phase %d\r\n", phase);
 8000ec6:	f01b ffa7 	bl	801ce18 <sys_get_tick_ms>
 8000eca:	0001      	movs	r1, r0
 8000ecc:	230b      	movs	r3, #11
 8000ece:	18fb      	adds	r3, r7, r3
 8000ed0:	781b      	ldrb	r3, [r3, #0]
 8000ed2:	4a05      	ldr	r2, [pc, #20]	; (8000ee8 <ppp_notify_phase_cb+0xf4>)
 8000ed4:	480f      	ldr	r0, [pc, #60]	; (8000f14 <ppp_notify_phase_cb+0x120>)
 8000ed6:	f001 fe77 	bl	8002bc8 <app_debug_rtt_raw>
        break;
 8000eda:	46c0      	nop			; (mov r8, r8)
    }
}
 8000edc:	46c0      	nop			; (mov r8, r8)
 8000ede:	46bd      	mov	sp, r7
 8000ee0:	b004      	add	sp, #16
 8000ee2:	bd80      	pop	{r7, pc}
 8000ee4:	080224b4 	.word	0x080224b4
 8000ee8:	0801da5c 	.word	0x0801da5c
 8000eec:	0801dd6c 	.word	0x0801dd6c
 8000ef0:	20001884 	.word	0x20001884
 8000ef4:	0801dd98 	.word	0x0801dd98
 8000ef8:	0801ddc8 	.word	0x0801ddc8
 8000efc:	0801ddf8 	.word	0x0801ddf8
 8000f00:	0801de28 	.word	0x0801de28
 8000f04:	0801de58 	.word	0x0801de58
 8000f08:	200001f4 	.word	0x200001f4
 8000f0c:	0801de88 	.word	0x0801de88
 8000f10:	0801deb8 	.word	0x0801deb8
 8000f14:	0801dee8 	.word	0x0801dee8

08000f18 <ppp_output_callback>:
static uint32_t ppp_output_callback(ppp_pcb *pcb, u8_t *data, u32_t len, void *ctx)
{
 8000f18:	b580      	push	{r7, lr}
 8000f1a:	b084      	sub	sp, #16
 8000f1c:	af00      	add	r7, sp, #0
 8000f1e:	60f8      	str	r0, [r7, #12]
 8000f20:	60b9      	str	r1, [r7, #8]
 8000f22:	607a      	str	r2, [r7, #4]
 8000f24:	603b      	str	r3, [r7, #0]
    GSM_UART_TX( data, len, 1000);
 8000f26:	687b      	ldr	r3, [r7, #4]
 8000f28:	b29a      	uxth	r2, r3
 8000f2a:	23fa      	movs	r3, #250	; 0xfa
 8000f2c:	009b      	lsls	r3, r3, #2
 8000f2e:	68b9      	ldr	r1, [r7, #8]
 8000f30:	4803      	ldr	r0, [pc, #12]	; (8000f40 <ppp_output_callback+0x28>)
 8000f32:	f003 fa29 	bl	8004388 <HAL_UART_Transmit>
    return len;
 8000f36:	687b      	ldr	r3, [r7, #4]
}
 8000f38:	0018      	movs	r0, r3
 8000f3a:	46bd      	mov	sp, r7
 8000f3c:	b004      	add	sp, #16
 8000f3e:	bd80      	pop	{r7, pc}
 8000f40:	20001800 	.word	0x20001800

08000f44 <gsm_data_layer_get_ppp_control_block>:
void *gsm_data_layer_get_ppp_control_block(void)
{
 8000f44:	b580      	push	{r7, lr}
 8000f46:	af00      	add	r7, sp, #0
    return m_ppp_control_block;
 8000f48:	4b02      	ldr	r3, [pc, #8]	; (8000f54 <gsm_data_layer_get_ppp_control_block+0x10>)
 8000f4a:	681b      	ldr	r3, [r3, #0]
}
 8000f4c:	0018      	movs	r0, r3
 8000f4e:	46bd      	mov	sp, r7
 8000f50:	bd80      	pop	{r7, pc}
 8000f52:	46c0      	nop			; (mov r8, r8)
 8000f54:	200001f0 	.word	0x200001f0

08000f58 <initialize_stnp>:
static void initialize_stnp(void)
{
 8000f58:	b580      	push	{r7, lr}
 8000f5a:	af00      	add	r7, sp, #0
    static bool sntp_start = false;
    if (sntp_start == false)
 8000f5c:	4b0f      	ldr	r3, [pc, #60]	; (8000f9c <initialize_stnp+0x44>)
 8000f5e:	781b      	ldrb	r3, [r3, #0]
 8000f60:	2201      	movs	r2, #1
 8000f62:	4053      	eors	r3, r2
 8000f64:	b2db      	uxtb	r3, r3
 8000f66:	2b00      	cmp	r3, #0
 8000f68:	d014      	beq.n	8000f94 <initialize_stnp+0x3c>
    {
        sntp_start = true;
 8000f6a:	4b0c      	ldr	r3, [pc, #48]	; (8000f9c <initialize_stnp+0x44>)
 8000f6c:	2201      	movs	r2, #1
 8000f6e:	701a      	strb	r2, [r3, #0]
        DEBUG_INFO("Initialize stnp\r\n");
 8000f70:	f01b ff52 	bl	801ce18 <sys_get_tick_ms>
 8000f74:	0001      	movs	r1, r0
 8000f76:	4a0a      	ldr	r2, [pc, #40]	; (8000fa0 <initialize_stnp+0x48>)
 8000f78:	4b0a      	ldr	r3, [pc, #40]	; (8000fa4 <initialize_stnp+0x4c>)
 8000f7a:	0018      	movs	r0, r3
 8000f7c:	f001 fe24 	bl	8002bc8 <app_debug_rtt_raw>
        sntp_setoperatingmode(SNTP_OPMODE_POLL);
 8000f80:	2000      	movs	r0, #0
 8000f82:	f005 ff6b 	bl	8006e5c <sntp_setoperatingmode>
        sntp_setservername(0, "pool.ntp.org");
 8000f86:	4b08      	ldr	r3, [pc, #32]	; (8000fa8 <initialize_stnp+0x50>)
 8000f88:	0019      	movs	r1, r3
 8000f8a:	2000      	movs	r0, #0
 8000f8c:	f005 ff98 	bl	8006ec0 <sntp_setservername>
        sntp_init();
 8000f90:	f005 fefe 	bl	8006d90 <sntp_init>
    }
}
 8000f94:	46c0      	nop			; (mov r8, r8)
 8000f96:	46bd      	mov	sp, r7
 8000f98:	bd80      	pop	{r7, pc}
 8000f9a:	46c0      	nop			; (mov r8, r8)
 8000f9c:	200001f5 	.word	0x200001f5
 8000fa0:	0801da5c 	.word	0x0801da5c
 8000fa4:	0801df18 	.word	0x0801df18
 8000fa8:	0801df44 	.word	0x0801df44

08000fac <lwip_sntp_recv_callback>:

void lwip_sntp_recv_callback(uint32_t time)
{
 8000fac:	b580      	push	{r7, lr}
 8000fae:	b082      	sub	sp, #8
 8000fb0:	af00      	add	r7, sp, #0
 8000fb2:	6078      	str	r0, [r7, #4]
    if (time == 0)
 8000fb4:	687b      	ldr	r3, [r7, #4]
 8000fb6:	2b00      	cmp	r3, #0
 8000fb8:	d108      	bne.n	8000fcc <lwip_sntp_recv_callback+0x20>
    {
        DEBUG_WARN("NTP: Error, server not responding or bad response\r\n");
 8000fba:	f01b ff2d 	bl	801ce18 <sys_get_tick_ms>
 8000fbe:	0001      	movs	r1, r0
 8000fc0:	4a08      	ldr	r2, [pc, #32]	; (8000fe4 <lwip_sntp_recv_callback+0x38>)
 8000fc2:	4b09      	ldr	r3, [pc, #36]	; (8000fe8 <lwip_sntp_recv_callback+0x3c>)
 8000fc4:	0018      	movs	r0, r3
 8000fc6:	f001 fdff 	bl	8002bc8 <app_debug_rtt_raw>
    }
    else
    {
        DEBUG_INFO("NTP: %u seconds elapsed since 1.1.1970\r\n", time);
    }
}
 8000fca:	e007      	b.n	8000fdc <lwip_sntp_recv_callback+0x30>
        DEBUG_INFO("NTP: %u seconds elapsed since 1.1.1970\r\n", time);
 8000fcc:	f01b ff24 	bl	801ce18 <sys_get_tick_ms>
 8000fd0:	0001      	movs	r1, r0
 8000fd2:	687b      	ldr	r3, [r7, #4]
 8000fd4:	4a03      	ldr	r2, [pc, #12]	; (8000fe4 <lwip_sntp_recv_callback+0x38>)
 8000fd6:	4805      	ldr	r0, [pc, #20]	; (8000fec <lwip_sntp_recv_callback+0x40>)
 8000fd8:	f001 fdf6 	bl	8002bc8 <app_debug_rtt_raw>
}
 8000fdc:	46c0      	nop			; (mov r8, r8)
 8000fde:	46bd      	mov	sp, r7
 8000fe0:	b002      	add	sp, #8
 8000fe2:	bd80      	pop	{r7, pc}
 8000fe4:	0801da5c 	.word	0x0801da5c
 8000fe8:	0801df54 	.word	0x0801df54
 8000fec:	0801dfa4 	.word	0x0801dfa4

08000ff0 <ppp_link_status_cb>:
 * ===================
 *
 * PPP status callback is called on PPP status change (up, down, ...) from lwIP core thread
 */
static void ppp_link_status_cb(ppp_pcb *pcb, int err_code, void *ctx)
{
 8000ff0:	b590      	push	{r4, r7, lr}
 8000ff2:	b087      	sub	sp, #28
 8000ff4:	af00      	add	r7, sp, #0
 8000ff6:	60f8      	str	r0, [r7, #12]
 8000ff8:	60b9      	str	r1, [r7, #8]
 8000ffa:	607a      	str	r2, [r7, #4]
    struct netif *pppif = ppp_netif(pcb);
 8000ffc:	68fb      	ldr	r3, [r7, #12]
 8000ffe:	6a1b      	ldr	r3, [r3, #32]
 8001000:	617b      	str	r3, [r7, #20]
 8001002:	68bb      	ldr	r3, [r7, #8]
 8001004:	2b0c      	cmp	r3, #12
 8001006:	d900      	bls.n	800100a <ppp_link_status_cb+0x1a>
 8001008:	e0df      	b.n	80011ca <ppp_link_status_cb+0x1da>
 800100a:	68bb      	ldr	r3, [r7, #8]
 800100c:	009a      	lsls	r2, r3, #2
 800100e:	4b7c      	ldr	r3, [pc, #496]	; (8001200 <ppp_link_status_cb+0x210>)
 8001010:	18d3      	adds	r3, r2, r3
 8001012:	681b      	ldr	r3, [r3, #0]
 8001014:	469f      	mov	pc, r3
    {
#if LWIP_DNS
        const ip_addr_t *ns;
#endif /* LWIP_DNS */

        DEBUG_INFO("PPP Connected\r\n");
 8001016:	f01b feff 	bl	801ce18 <sys_get_tick_ms>
 800101a:	0001      	movs	r1, r0
 800101c:	4a79      	ldr	r2, [pc, #484]	; (8001204 <ppp_link_status_cb+0x214>)
 800101e:	4b7a      	ldr	r3, [pc, #488]	; (8001208 <ppp_link_status_cb+0x218>)
 8001020:	0018      	movs	r0, r3
 8001022:	f001 fdd1 	bl	8002bc8 <app_debug_rtt_raw>

#if PPP_IPV4_SUPPORT

        DEBUG_INFO("\tour_ipaddr    = %s\r\n", ipaddr_ntoa(&pppif->ip_addr));
 8001026:	f01b fef7 	bl	801ce18 <sys_get_tick_ms>
 800102a:	0004      	movs	r4, r0
 800102c:	697b      	ldr	r3, [r7, #20]
 800102e:	3304      	adds	r3, #4
 8001030:	0018      	movs	r0, r3
 8001032:	f013 f887 	bl	8014144 <ip4addr_ntoa>
 8001036:	0003      	movs	r3, r0
 8001038:	4a72      	ldr	r2, [pc, #456]	; (8001204 <ppp_link_status_cb+0x214>)
 800103a:	4874      	ldr	r0, [pc, #464]	; (800120c <ppp_link_status_cb+0x21c>)
 800103c:	0021      	movs	r1, r4
 800103e:	f001 fdc3 	bl	8002bc8 <app_debug_rtt_raw>
        DEBUG_INFO("\this_ipaddr    = %s\r\n", ipaddr_ntoa(&pppif->gw));
 8001042:	f01b fee9 	bl	801ce18 <sys_get_tick_ms>
 8001046:	0004      	movs	r4, r0
 8001048:	697b      	ldr	r3, [r7, #20]
 800104a:	330c      	adds	r3, #12
 800104c:	0018      	movs	r0, r3
 800104e:	f013 f879 	bl	8014144 <ip4addr_ntoa>
 8001052:	0003      	movs	r3, r0
 8001054:	4a6b      	ldr	r2, [pc, #428]	; (8001204 <ppp_link_status_cb+0x214>)
 8001056:	486e      	ldr	r0, [pc, #440]	; (8001210 <ppp_link_status_cb+0x220>)
 8001058:	0021      	movs	r1, r4
 800105a:	f001 fdb5 	bl	8002bc8 <app_debug_rtt_raw>
        DEBUG_INFO("\tnetmask       = %s\r\n", ipaddr_ntoa(&pppif->netmask));
 800105e:	f01b fedb 	bl	801ce18 <sys_get_tick_ms>
 8001062:	0004      	movs	r4, r0
 8001064:	697b      	ldr	r3, [r7, #20]
 8001066:	3308      	adds	r3, #8
 8001068:	0018      	movs	r0, r3
 800106a:	f013 f86b 	bl	8014144 <ip4addr_ntoa>
 800106e:	0003      	movs	r3, r0
 8001070:	4a64      	ldr	r2, [pc, #400]	; (8001204 <ppp_link_status_cb+0x214>)
 8001072:	4868      	ldr	r0, [pc, #416]	; (8001214 <ppp_link_status_cb+0x224>)
 8001074:	0021      	movs	r1, r4
 8001076:	f001 fda7 	bl	8002bc8 <app_debug_rtt_raw>
        HAL_Delay(1);
 800107a:	2001      	movs	r0, #1
 800107c:	f001 ff24 	bl	8002ec8 <HAL_Delay>

#if LWIP_DNS
        ns = dns_getserver(0);
 8001080:	2000      	movs	r0, #0
 8001082:	f005 ffdd 	bl	8007040 <dns_getserver>
 8001086:	0003      	movs	r3, r0
 8001088:	613b      	str	r3, [r7, #16]
        DEBUG_INFO("\tdns1          = %s\r\n", ipaddr_ntoa(ns));
 800108a:	f01b fec5 	bl	801ce18 <sys_get_tick_ms>
 800108e:	0004      	movs	r4, r0
 8001090:	693b      	ldr	r3, [r7, #16]
 8001092:	0018      	movs	r0, r3
 8001094:	f013 f856 	bl	8014144 <ip4addr_ntoa>
 8001098:	0003      	movs	r3, r0
 800109a:	4a5a      	ldr	r2, [pc, #360]	; (8001204 <ppp_link_status_cb+0x214>)
 800109c:	485e      	ldr	r0, [pc, #376]	; (8001218 <ppp_link_status_cb+0x228>)
 800109e:	0021      	movs	r1, r4
 80010a0:	f001 fd92 	bl	8002bc8 <app_debug_rtt_raw>
        ns = dns_getserver(1);
 80010a4:	2001      	movs	r0, #1
 80010a6:	f005 ffcb 	bl	8007040 <dns_getserver>
 80010aa:	0003      	movs	r3, r0
 80010ac:	613b      	str	r3, [r7, #16]
        DEBUG_INFO("\tdns2          = %s\r\n", ipaddr_ntoa(ns));
 80010ae:	f01b feb3 	bl	801ce18 <sys_get_tick_ms>
 80010b2:	0004      	movs	r4, r0
 80010b4:	693b      	ldr	r3, [r7, #16]
 80010b6:	0018      	movs	r0, r3
 80010b8:	f013 f844 	bl	8014144 <ip4addr_ntoa>
 80010bc:	0003      	movs	r3, r0
 80010be:	4a51      	ldr	r2, [pc, #324]	; (8001204 <ppp_link_status_cb+0x214>)
 80010c0:	4856      	ldr	r0, [pc, #344]	; (800121c <ppp_link_status_cb+0x22c>)
 80010c2:	0021      	movs	r1, r4
 80010c4:	f001 fd80 	bl	8002bc8 <app_debug_rtt_raw>
        HAL_Delay(1);
 80010c8:	2001      	movs	r0, #1
 80010ca:	f001 fefd 	bl	8002ec8 <HAL_Delay>
#endif /* PPP_IPV4_SUPPORT */

#if PPP_IPV6_SUPPORT
        DEBUG_INFO("\r   our6_ipaddr = %s\n", ip6addr_ntoa(netif_ip6_addr(pppif, 0)));
#endif /* PPP_IPV6_SUPPORT */
        break;
 80010ce:	e085      	b.n	80011dc <ppp_link_status_cb+0x1ec>
    }

    case PPPERR_PARAM:
    {
        DEBUG_INFO("status_cb: Invalid parameter\r\n");
 80010d0:	f01b fea2 	bl	801ce18 <sys_get_tick_ms>
 80010d4:	0001      	movs	r1, r0
 80010d6:	4a4b      	ldr	r2, [pc, #300]	; (8001204 <ppp_link_status_cb+0x214>)
 80010d8:	4b51      	ldr	r3, [pc, #324]	; (8001220 <ppp_link_status_cb+0x230>)
 80010da:	0018      	movs	r0, r3
 80010dc:	f001 fd74 	bl	8002bc8 <app_debug_rtt_raw>
        break;
 80010e0:	e07c      	b.n	80011dc <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_OPEN:
    {
        DEBUG_INFO("status_cb: Unable to open PPP session\r\n");
 80010e2:	f01b fe99 	bl	801ce18 <sys_get_tick_ms>
 80010e6:	0001      	movs	r1, r0
 80010e8:	4a46      	ldr	r2, [pc, #280]	; (8001204 <ppp_link_status_cb+0x214>)
 80010ea:	4b4e      	ldr	r3, [pc, #312]	; (8001224 <ppp_link_status_cb+0x234>)
 80010ec:	0018      	movs	r0, r3
 80010ee:	f001 fd6b 	bl	8002bc8 <app_debug_rtt_raw>
        break;
 80010f2:	e073      	b.n	80011dc <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_DEVICE:
    {
        DEBUG_INFO("status_cb: Invalid I/O device for PPP\r\n");
 80010f4:	f01b fe90 	bl	801ce18 <sys_get_tick_ms>
 80010f8:	0001      	movs	r1, r0
 80010fa:	4a42      	ldr	r2, [pc, #264]	; (8001204 <ppp_link_status_cb+0x214>)
 80010fc:	4b4a      	ldr	r3, [pc, #296]	; (8001228 <ppp_link_status_cb+0x238>)
 80010fe:	0018      	movs	r0, r3
 8001100:	f001 fd62 	bl	8002bc8 <app_debug_rtt_raw>
        break;
 8001104:	e06a      	b.n	80011dc <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_ALLOC:
    {
        DEBUG_INFO("status_cb: Unable to allocate resources\r\n");
 8001106:	f01b fe87 	bl	801ce18 <sys_get_tick_ms>
 800110a:	0001      	movs	r1, r0
 800110c:	4a3d      	ldr	r2, [pc, #244]	; (8001204 <ppp_link_status_cb+0x214>)
 800110e:	4b47      	ldr	r3, [pc, #284]	; (800122c <ppp_link_status_cb+0x23c>)
 8001110:	0018      	movs	r0, r3
 8001112:	f001 fd59 	bl	8002bc8 <app_debug_rtt_raw>
        break;
 8001116:	e061      	b.n	80011dc <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_USER: /* 5 */
    {
        /* ppp_close() was previously called, reconnect */
        DEBUG_INFO("status_cb: ppp is closed by user OK! Try to re-open...\r\n");
 8001118:	f01b fe7e 	bl	801ce18 <sys_get_tick_ms>
 800111c:	0001      	movs	r1, r0
 800111e:	4a39      	ldr	r2, [pc, #228]	; (8001204 <ppp_link_status_cb+0x214>)
 8001120:	4b43      	ldr	r3, [pc, #268]	; (8001230 <ppp_link_status_cb+0x240>)
 8001122:	0018      	movs	r0, r3
 8001124:	f001 fd50 	bl	8002bc8 <app_debug_rtt_raw>
        /* ppp_free(); -- can be called here */
        ppp_free(m_ppp_control_block);
 8001128:	4b42      	ldr	r3, [pc, #264]	; (8001234 <ppp_link_status_cb+0x244>)
 800112a:	681b      	ldr	r3, [r3, #0]
 800112c:	0018      	movs	r0, r3
 800112e:	f018 fe19 	bl	8019d64 <ppp_free>
        GSM_Manager_ChangeState(GSM_STATE_REOPEN_PPP);
 8001132:	2003      	movs	r0, #3
 8001134:	f000 f904 	bl	8001340 <GSM_Manager_ChangeState>
        break;
 8001138:	e050      	b.n	80011dc <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_CONNECT: /* 6 */
    {
        DEBUG_INFO("status_cb: Connection lost\r\n");
 800113a:	f01b fe6d 	bl	801ce18 <sys_get_tick_ms>
 800113e:	0001      	movs	r1, r0
 8001140:	4a30      	ldr	r2, [pc, #192]	; (8001204 <ppp_link_status_cb+0x214>)
 8001142:	4b3d      	ldr	r3, [pc, #244]	; (8001238 <ppp_link_status_cb+0x248>)
 8001144:	0018      	movs	r0, r3
 8001146:	f001 fd3f 	bl	8002bc8 <app_debug_rtt_raw>
        m_ppp_connected = false;
 800114a:	4b3c      	ldr	r3, [pc, #240]	; (800123c <ppp_link_status_cb+0x24c>)
 800114c:	2200      	movs	r2, #0
 800114e:	701a      	strb	r2, [r3, #0]
        ppp_close(m_ppp_control_block, 1);
 8001150:	4b38      	ldr	r3, [pc, #224]	; (8001234 <ppp_link_status_cb+0x244>)
 8001152:	681b      	ldr	r3, [r3, #0]
 8001154:	2101      	movs	r1, #1
 8001156:	0018      	movs	r0, r3
 8001158:	f018 fd9c 	bl	8019c94 <ppp_close>
        break;
 800115c:	e03e      	b.n	80011dc <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_AUTHFAIL:
    {
        DEBUG_INFO("status_cb: Failed authentication challenge\r\n");
 800115e:	f01b fe5b 	bl	801ce18 <sys_get_tick_ms>
 8001162:	0001      	movs	r1, r0
 8001164:	4a27      	ldr	r2, [pc, #156]	; (8001204 <ppp_link_status_cb+0x214>)
 8001166:	4b36      	ldr	r3, [pc, #216]	; (8001240 <ppp_link_status_cb+0x250>)
 8001168:	0018      	movs	r0, r3
 800116a:	f001 fd2d 	bl	8002bc8 <app_debug_rtt_raw>
        break;
 800116e:	e035      	b.n	80011dc <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_PROTOCOL:
    {
        DEBUG_INFO("status_cb: Failed to meet protocol\n");
 8001170:	f01b fe52 	bl	801ce18 <sys_get_tick_ms>
 8001174:	0001      	movs	r1, r0
 8001176:	4a23      	ldr	r2, [pc, #140]	; (8001204 <ppp_link_status_cb+0x214>)
 8001178:	4b32      	ldr	r3, [pc, #200]	; (8001244 <ppp_link_status_cb+0x254>)
 800117a:	0018      	movs	r0, r3
 800117c:	f001 fd24 	bl	8002bc8 <app_debug_rtt_raw>
        break;
 8001180:	e02c      	b.n	80011dc <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_PEERDEAD:
    {
        DEBUG_INFO("status_cb: Connection timeout\r\n");
 8001182:	f01b fe49 	bl	801ce18 <sys_get_tick_ms>
 8001186:	0001      	movs	r1, r0
 8001188:	4a1e      	ldr	r2, [pc, #120]	; (8001204 <ppp_link_status_cb+0x214>)
 800118a:	4b2f      	ldr	r3, [pc, #188]	; (8001248 <ppp_link_status_cb+0x258>)
 800118c:	0018      	movs	r0, r3
 800118e:	f001 fd1b 	bl	8002bc8 <app_debug_rtt_raw>
        break;
 8001192:	e023      	b.n	80011dc <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_IDLETIMEOUT:
    {
        DEBUG_INFO("status_cb: Idle Timeout\r\n");
 8001194:	f01b fe40 	bl	801ce18 <sys_get_tick_ms>
 8001198:	0001      	movs	r1, r0
 800119a:	4a1a      	ldr	r2, [pc, #104]	; (8001204 <ppp_link_status_cb+0x214>)
 800119c:	4b2b      	ldr	r3, [pc, #172]	; (800124c <ppp_link_status_cb+0x25c>)
 800119e:	0018      	movs	r0, r3
 80011a0:	f001 fd12 	bl	8002bc8 <app_debug_rtt_raw>
        break;
 80011a4:	e01a      	b.n	80011dc <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_CONNECTTIME:
    {
        DEBUG_INFO("status_cb: Max connect time reached\r\n");
 80011a6:	f01b fe37 	bl	801ce18 <sys_get_tick_ms>
 80011aa:	0001      	movs	r1, r0
 80011ac:	4a15      	ldr	r2, [pc, #84]	; (8001204 <ppp_link_status_cb+0x214>)
 80011ae:	4b28      	ldr	r3, [pc, #160]	; (8001250 <ppp_link_status_cb+0x260>)
 80011b0:	0018      	movs	r0, r3
 80011b2:	f001 fd09 	bl	8002bc8 <app_debug_rtt_raw>
        break;
 80011b6:	e011      	b.n	80011dc <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_LOOPBACK:
    {
        DEBUG_INFO("status_cb: Loopback detected\r\n");
 80011b8:	f01b fe2e 	bl	801ce18 <sys_get_tick_ms>
 80011bc:	0001      	movs	r1, r0
 80011be:	4a11      	ldr	r2, [pc, #68]	; (8001204 <ppp_link_status_cb+0x214>)
 80011c0:	4b24      	ldr	r3, [pc, #144]	; (8001254 <ppp_link_status_cb+0x264>)
 80011c2:	0018      	movs	r0, r3
 80011c4:	f001 fd00 	bl	8002bc8 <app_debug_rtt_raw>
        break;
 80011c8:	e008      	b.n	80011dc <ppp_link_status_cb+0x1ec>
    }
    default:
    {
        DEBUG_INFO("status_cb: Unknown error code %d\r\n", err_code);
 80011ca:	f01b fe25 	bl	801ce18 <sys_get_tick_ms>
 80011ce:	0001      	movs	r1, r0
 80011d0:	68bb      	ldr	r3, [r7, #8]
 80011d2:	4a0c      	ldr	r2, [pc, #48]	; (8001204 <ppp_link_status_cb+0x214>)
 80011d4:	4820      	ldr	r0, [pc, #128]	; (8001258 <ppp_link_status_cb+0x268>)
 80011d6:	f001 fcf7 	bl	8002bc8 <app_debug_rtt_raw>
        break;
 80011da:	46c0      	nop			; (mov r8, r8)
    /*
	* This should be in the switch case, this is put outside of the switch
	* case for example readability.
	*/

    if (err_code == PPPERR_NONE)
 80011dc:	68bb      	ldr	r3, [r7, #8]
 80011de:	2b00      	cmp	r3, #0
 80011e0:	d10a      	bne.n	80011f8 <ppp_link_status_cb+0x208>
    {
        DEBUG_INFO("PPP is opened OK\r\n");
 80011e2:	f01b fe19 	bl	801ce18 <sys_get_tick_ms>
 80011e6:	0001      	movs	r1, r0
 80011e8:	4a06      	ldr	r2, [pc, #24]	; (8001204 <ppp_link_status_cb+0x214>)
 80011ea:	4b1c      	ldr	r3, [pc, #112]	; (800125c <ppp_link_status_cb+0x26c>)
 80011ec:	0018      	movs	r0, r3
 80011ee:	f001 fceb 	bl	8002bc8 <app_debug_rtt_raw>
        initialize_stnp();
 80011f2:	f7ff feb1 	bl	8000f58 <initialize_stnp>
        return;
 80011f6:	46c0      	nop			; (mov r8, r8)
   * Try to reconnect in 30 seconds, if you need a modem chatscript you have
   * to do a much better signaling here ;-)
   */
    //  ppp_connect(pcb, 30);
    /* OR ppp_listen(pcb); */
}
 80011f8:	46bd      	mov	sp, r7
 80011fa:	b007      	add	sp, #28
 80011fc:	bd90      	pop	{r4, r7, pc}
 80011fe:	46c0      	nop			; (mov r8, r8)
 8001200:	080224e8 	.word	0x080224e8
 8001204:	0801da5c 	.word	0x0801da5c
 8001208:	0801dfe8 	.word	0x0801dfe8
 800120c:	0801e014 	.word	0x0801e014
 8001210:	0801e044 	.word	0x0801e044
 8001214:	0801e074 	.word	0x0801e074
 8001218:	0801e0a4 	.word	0x0801e0a4
 800121c:	0801e0d4 	.word	0x0801e0d4
 8001220:	0801e104 	.word	0x0801e104
 8001224:	0801e13c 	.word	0x0801e13c
 8001228:	0801e180 	.word	0x0801e180
 800122c:	0801e1c4 	.word	0x0801e1c4
 8001230:	0801e208 	.word	0x0801e208
 8001234:	200001f0 	.word	0x200001f0
 8001238:	0801e25c 	.word	0x0801e25c
 800123c:	200001f4 	.word	0x200001f4
 8001240:	0801e294 	.word	0x0801e294
 8001244:	0801e2dc 	.word	0x0801e2dc
 8001248:	0801e31c 	.word	0x0801e31c
 800124c:	0801e358 	.word	0x0801e358
 8001250:	0801e38c 	.word	0x0801e38c
 8001254:	0801e3cc 	.word	0x0801e3cc
 8001258:	0801e404 	.word	0x0801e404
 800125c:	0801e440 	.word	0x0801e440

08001260 <Polling_GSM_StateMachine>:
void Polling_GSM_StateMachine (void)
{
 8001260:	b5b0      	push	{r4, r5, r7, lr}
 8001262:	b086      	sub	sp, #24
 8001264:	af04      	add	r7, sp, #16
    static uint32_t last_tick = 0;
    uint32_t current_tick = sys_get_tick_ms();
 8001266:	f01b fdd7 	bl	801ce18 <sys_get_tick_ms>
 800126a:	0003      	movs	r3, r0
 800126c:	607b      	str	r3, [r7, #4]
    if(current_tick - last_tick >= (uint32_t)1000)
 800126e:	4b23      	ldr	r3, [pc, #140]	; (80012fc <Polling_GSM_StateMachine+0x9c>)
 8001270:	681b      	ldr	r3, [r3, #0]
 8001272:	687a      	ldr	r2, [r7, #4]
 8001274:	1ad2      	subs	r2, r2, r3
 8001276:	23fa      	movs	r3, #250	; 0xfa
 8001278:	009b      	lsls	r3, r3, #2
 800127a:	429a      	cmp	r2, r3
 800127c:	d332      	bcc.n	80012e4 <Polling_GSM_StateMachine+0x84>
    {
        last_tick = current_tick;
 800127e:	4b1f      	ldr	r3, [pc, #124]	; (80012fc <Polling_GSM_StateMachine+0x9c>)
 8001280:	687a      	ldr	r2, [r7, #4]
 8001282:	601a      	str	r2, [r3, #0]
        switch (GSM_Manager.state)
 8001284:	4b1e      	ldr	r3, [pc, #120]	; (8001300 <Polling_GSM_StateMachine+0xa0>)
 8001286:	781b      	ldrb	r3, [r3, #0]
 8001288:	2b03      	cmp	r3, #3
 800128a:	d02d      	beq.n	80012e8 <Polling_GSM_StateMachine+0x88>
 800128c:	dc20      	bgt.n	80012d0 <Polling_GSM_StateMachine+0x70>
 800128e:	2b02      	cmp	r3, #2
 8001290:	d02c      	beq.n	80012ec <Polling_GSM_StateMachine+0x8c>
 8001292:	dc1d      	bgt.n	80012d0 <Polling_GSM_StateMachine+0x70>
 8001294:	2b00      	cmp	r3, #0
 8001296:	d004      	beq.n	80012a2 <Polling_GSM_StateMachine+0x42>
 8001298:	2b01      	cmp	r3, #1
 800129a:	d119      	bne.n	80012d0 <Polling_GSM_StateMachine+0x70>
        {
            case GSM_STATE_RESET:
                GSM_Turn_on_Power();
 800129c:	f000 face 	bl	800183c <GSM_Turn_on_Power>
                break;
 80012a0:	e027      	b.n	80012f2 <Polling_GSM_StateMachine+0x92>
            case GSM_STATE_POWER_ON:
                if(GSM_Manager.step == 0)
 80012a2:	4b17      	ldr	r3, [pc, #92]	; (8001300 <Polling_GSM_StateMachine+0xa0>)
 80012a4:	785b      	ldrb	r3, [r3, #1]
 80012a6:	2b00      	cmp	r3, #0
 80012a8:	d122      	bne.n	80012f0 <Polling_GSM_StateMachine+0x90>
                {
                    GSM_Manager.step = 1;
 80012aa:	4b15      	ldr	r3, [pc, #84]	; (8001300 <Polling_GSM_StateMachine+0xa0>)
 80012ac:	2201      	movs	r2, #1
 80012ae:	705a      	strb	r2, [r3, #1]
                    GSM_SendCommand_AT(ATC_Table_Config_Module[0]);
 80012b0:	4b14      	ldr	r3, [pc, #80]	; (8001304 <Polling_GSM_StateMachine+0xa4>)
 80012b2:	466a      	mov	r2, sp
 80012b4:	0011      	movs	r1, r2
 80012b6:	001a      	movs	r2, r3
 80012b8:	3210      	adds	r2, #16
 80012ba:	ca31      	ldmia	r2!, {r0, r4, r5}
 80012bc:	c131      	stmia	r1!, {r0, r4, r5}
 80012be:	6812      	ldr	r2, [r2, #0]
 80012c0:	600a      	str	r2, [r1, #0]
 80012c2:	6818      	ldr	r0, [r3, #0]
 80012c4:	6859      	ldr	r1, [r3, #4]
 80012c6:	689a      	ldr	r2, [r3, #8]
 80012c8:	68db      	ldr	r3, [r3, #12]
 80012ca:	f000 fb73 	bl	80019b4 <GSM_SendCommand_AT>
                }
                break;
 80012ce:	e00f      	b.n	80012f0 <Polling_GSM_StateMachine+0x90>
                break;
            case GSM_STATE_REOPEN_PPP:

            	break;
            default:
                DEBUG_WARN("Unhandled state %d.\r\n", GSM_Manager.state);
 80012d0:	f01b fda2 	bl	801ce18 <sys_get_tick_ms>
 80012d4:	0001      	movs	r1, r0
 80012d6:	4b0a      	ldr	r3, [pc, #40]	; (8001300 <Polling_GSM_StateMachine+0xa0>)
 80012d8:	781b      	ldrb	r3, [r3, #0]
 80012da:	4a0b      	ldr	r2, [pc, #44]	; (8001308 <Polling_GSM_StateMachine+0xa8>)
 80012dc:	480b      	ldr	r0, [pc, #44]	; (800130c <Polling_GSM_StateMachine+0xac>)
 80012de:	f001 fc73 	bl	8002bc8 <app_debug_rtt_raw>
                break;
 80012e2:	e006      	b.n	80012f2 <Polling_GSM_StateMachine+0x92>
        }
    }
 80012e4:	46c0      	nop			; (mov r8, r8)
 80012e6:	e004      	b.n	80012f2 <Polling_GSM_StateMachine+0x92>
            	break;
 80012e8:	46c0      	nop			; (mov r8, r8)
 80012ea:	e002      	b.n	80012f2 <Polling_GSM_StateMachine+0x92>
                break;
 80012ec:	46c0      	nop			; (mov r8, r8)
 80012ee:	e000      	b.n	80012f2 <Polling_GSM_StateMachine+0x92>
                break;
 80012f0:	46c0      	nop			; (mov r8, r8)
}
 80012f2:	46c0      	nop			; (mov r8, r8)
 80012f4:	46bd      	mov	sp, r7
 80012f6:	b002      	add	sp, #8
 80012f8:	bdb0      	pop	{r4, r5, r7, pc}
 80012fa:	46c0      	nop			; (mov r8, r8)
 80012fc:	200001f8 	.word	0x200001f8
 8001300:	20001884 	.word	0x20001884
 8001304:	08022134 	.word	0x08022134
 8001308:	0801da5c 	.word	0x0801da5c
 800130c:	0801e46c 	.word	0x0801e46c

08001310 <gsm_is_in_ppp_mode>:
bool gsm_is_in_ppp_mode(void)
{
 8001310:	b580      	push	{r7, lr}
 8001312:	af00      	add	r7, sp, #0
    return GSM_Manager.mode == GSM_INTERNET_MODE_PPP_STACK? true : false;
 8001314:	4b04      	ldr	r3, [pc, #16]	; (8001328 <gsm_is_in_ppp_mode+0x18>)
 8001316:	789b      	ldrb	r3, [r3, #2]
 8001318:	3b01      	subs	r3, #1
 800131a:	425a      	negs	r2, r3
 800131c:	4153      	adcs	r3, r2
 800131e:	b2db      	uxtb	r3, r3
}
 8001320:	0018      	movs	r0, r3
 8001322:	46bd      	mov	sp, r7
 8001324:	bd80      	pop	{r7, pc}
 8001326:	46c0      	nop			; (mov r8, r8)
 8001328:	20001884 	.word	0x20001884

0800132c <gsm_data_layer_is_ppp_connected>:
bool gsm_data_layer_is_ppp_connected(void)
{
 800132c:	b580      	push	{r7, lr}
 800132e:	af00      	add	r7, sp, #0
    return m_ppp_connected;
 8001330:	4b02      	ldr	r3, [pc, #8]	; (800133c <gsm_data_layer_is_ppp_connected+0x10>)
 8001332:	781b      	ldrb	r3, [r3, #0]
}
 8001334:	0018      	movs	r0, r3
 8001336:	46bd      	mov	sp, r7
 8001338:	bd80      	pop	{r7, pc}
 800133a:	46c0      	nop			; (mov r8, r8)
 800133c:	200001f4 	.word	0x200001f4

08001340 <GSM_Manager_ChangeState>:


void GSM_Manager_ChangeState(Gsm_State_TypDef state)
{
 8001340:	b5b0      	push	{r4, r5, r7, lr}
 8001342:	b086      	sub	sp, #24
 8001344:	af04      	add	r7, sp, #16
 8001346:	0002      	movs	r2, r0
 8001348:	1dfb      	adds	r3, r7, #7
 800134a:	701a      	strb	r2, [r3, #0]
    GSM_Manager.state = state;
 800134c:	4b38      	ldr	r3, [pc, #224]	; (8001430 <GSM_Manager_ChangeState+0xf0>)
 800134e:	1dfa      	adds	r2, r7, #7
 8001350:	7812      	ldrb	r2, [r2, #0]
 8001352:	701a      	strb	r2, [r3, #0]
    GSM_Manager.step = 0;
 8001354:	4b36      	ldr	r3, [pc, #216]	; (8001430 <GSM_Manager_ChangeState+0xf0>)
 8001356:	2200      	movs	r2, #0
 8001358:	705a      	strb	r2, [r3, #1]
    DEBUG_INFO("Change GSM State to: ");
 800135a:	f01b fd5d 	bl	801ce18 <sys_get_tick_ms>
 800135e:	0001      	movs	r1, r0
 8001360:	4a34      	ldr	r2, [pc, #208]	; (8001434 <GSM_Manager_ChangeState+0xf4>)
 8001362:	4b35      	ldr	r3, [pc, #212]	; (8001438 <GSM_Manager_ChangeState+0xf8>)
 8001364:	0018      	movs	r0, r3
 8001366:	f001 fc2f 	bl	8002bc8 <app_debug_rtt_raw>
    switch (state)
 800136a:	1dfb      	adds	r3, r7, #7
 800136c:	781b      	ldrb	r3, [r3, #0]
 800136e:	2b03      	cmp	r3, #3
 8001370:	d033      	beq.n	80013da <GSM_Manager_ChangeState+0x9a>
 8001372:	dc55      	bgt.n	8001420 <GSM_Manager_ChangeState+0xe0>
 8001374:	2b02      	cmp	r3, #2
 8001376:	d005      	beq.n	8001384 <GSM_Manager_ChangeState+0x44>
 8001378:	dc52      	bgt.n	8001420 <GSM_Manager_ChangeState+0xe0>
 800137a:	2b00      	cmp	r3, #0
 800137c:	d026      	beq.n	80013cc <GSM_Manager_ChangeState+0x8c>
 800137e:	2b01      	cmp	r3, #1
 8001380:	d005      	beq.n	800138e <GSM_Manager_ChangeState+0x4e>
            GSM_HwLayer_Reset_Rx_Buffer(); // Reset USART RX buffer
            GSM_SendCommand_AT(ATC_Table_open_ppp_stack[0]);
        }
        break;
    default:
        break;
 8001382:	e04d      	b.n	8001420 <GSM_Manager_ChangeState+0xe0>
        DEBUG_RAW("OK\r\n");
 8001384:	4b2d      	ldr	r3, [pc, #180]	; (800143c <GSM_Manager_ChangeState+0xfc>)
 8001386:	0018      	movs	r0, r3
 8001388:	f001 fc1e 	bl	8002bc8 <app_debug_rtt_raw>
        break;
 800138c:	e04b      	b.n	8001426 <GSM_Manager_ChangeState+0xe6>
    	DEBUG_RAW("RESET\r\n");
 800138e:	4b2c      	ldr	r3, [pc, #176]	; (8001440 <GSM_Manager_ChangeState+0x100>)
 8001390:	0018      	movs	r0, r3
 8001392:	f001 fc19 	bl	8002bc8 <app_debug_rtt_raw>
        GSM_HwLayer_Reset_Rx_Buffer(); // Reset USART RX buffer
 8001396:	f000 fbfd 	bl	8001b94 <GSM_HwLayer_Reset_Rx_Buffer>
        GSM_Manager_ChangeInternetMode(GSM_INTERNET_MODE_AT_STACK);
 800139a:	2000      	movs	r0, #0
 800139c:	f000 f85e 	bl	800145c <GSM_Manager_ChangeInternetMode>
        HAL_GPIO_WritePin(EN_GSM_GPIO_Port,EN_GSM_Pin,0);    // Set GSM power en level to 0 = power off device
 80013a0:	4b28      	ldr	r3, [pc, #160]	; (8001444 <GSM_Manager_ChangeState+0x104>)
 80013a2:	2200      	movs	r2, #0
 80013a4:	2140      	movs	r1, #64	; 0x40
 80013a6:	0018      	movs	r0, r3
 80013a8:	f002 f896 	bl	80034d8 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GSM_RESET_GPIO_Port,GSM_RESET_Pin,1);  // Set GSM Reset pin to high
 80013ac:	2380      	movs	r3, #128	; 0x80
 80013ae:	009b      	lsls	r3, r3, #2
 80013b0:	4825      	ldr	r0, [pc, #148]	; (8001448 <GSM_Manager_ChangeState+0x108>)
 80013b2:	2201      	movs	r2, #1
 80013b4:	0019      	movs	r1, r3
 80013b6:	f002 f88f 	bl	80034d8 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GSM_PWKEY_GPIO_Port,GSM_PWKEY_Pin,0);  // Reset GSM power key pin
 80013ba:	2380      	movs	r3, #128	; 0x80
 80013bc:	0059      	lsls	r1, r3, #1
 80013be:	23a0      	movs	r3, #160	; 0xa0
 80013c0:	05db      	lsls	r3, r3, #23
 80013c2:	2200      	movs	r2, #0
 80013c4:	0018      	movs	r0, r3
 80013c6:	f002 f887 	bl	80034d8 <HAL_GPIO_WritePin>
        break;
 80013ca:	e02c      	b.n	8001426 <GSM_Manager_ChangeState+0xe6>
    	DEBUG_RAW("POWER ON\r\n");
 80013cc:	4b1f      	ldr	r3, [pc, #124]	; (800144c <GSM_Manager_ChangeState+0x10c>)
 80013ce:	0018      	movs	r0, r3
 80013d0:	f001 fbfa 	bl	8002bc8 <app_debug_rtt_raw>
        GSM_HwLayer_Reset_Rx_Buffer(); // Reset USART RX buffer
 80013d4:	f000 fbde 	bl	8001b94 <GSM_HwLayer_Reset_Rx_Buffer>
        break;
 80013d8:	e025      	b.n	8001426 <GSM_Manager_ChangeState+0xe6>
    	DEBUG_RAW("REOPEN PPP\r\n");
 80013da:	4b1d      	ldr	r3, [pc, #116]	; (8001450 <GSM_Manager_ChangeState+0x110>)
 80013dc:	0018      	movs	r0, r3
 80013de:	f001 fbf3 	bl	8002bc8 <app_debug_rtt_raw>
        if (GSM_Manager.step == 0)
 80013e2:	4b13      	ldr	r3, [pc, #76]	; (8001430 <GSM_Manager_ChangeState+0xf0>)
 80013e4:	785b      	ldrb	r3, [r3, #1]
 80013e6:	2b00      	cmp	r3, #0
 80013e8:	d11c      	bne.n	8001424 <GSM_Manager_ChangeState+0xe4>
            GSM_Manager.step = 1;
 80013ea:	4b11      	ldr	r3, [pc, #68]	; (8001430 <GSM_Manager_ChangeState+0xf0>)
 80013ec:	2201      	movs	r2, #1
 80013ee:	705a      	strb	r2, [r3, #1]
            m_ppp_connected = false;
 80013f0:	4b18      	ldr	r3, [pc, #96]	; (8001454 <GSM_Manager_ChangeState+0x114>)
 80013f2:	2200      	movs	r2, #0
 80013f4:	701a      	strb	r2, [r3, #0]
            GSM_Manager_ChangeInternetMode(GSM_INTERNET_MODE_AT_STACK);
 80013f6:	2000      	movs	r0, #0
 80013f8:	f000 f830 	bl	800145c <GSM_Manager_ChangeInternetMode>
            GSM_HwLayer_Reset_Rx_Buffer(); // Reset USART RX buffer
 80013fc:	f000 fbca 	bl	8001b94 <GSM_HwLayer_Reset_Rx_Buffer>
            GSM_SendCommand_AT(ATC_Table_open_ppp_stack[0]);
 8001400:	4b15      	ldr	r3, [pc, #84]	; (8001458 <GSM_Manager_ChangeState+0x118>)
 8001402:	466a      	mov	r2, sp
 8001404:	0011      	movs	r1, r2
 8001406:	001a      	movs	r2, r3
 8001408:	3210      	adds	r2, #16
 800140a:	ca31      	ldmia	r2!, {r0, r4, r5}
 800140c:	c131      	stmia	r1!, {r0, r4, r5}
 800140e:	6812      	ldr	r2, [r2, #0]
 8001410:	600a      	str	r2, [r1, #0]
 8001412:	6818      	ldr	r0, [r3, #0]
 8001414:	6859      	ldr	r1, [r3, #4]
 8001416:	689a      	ldr	r2, [r3, #8]
 8001418:	68db      	ldr	r3, [r3, #12]
 800141a:	f000 facb 	bl	80019b4 <GSM_SendCommand_AT>
        break;
 800141e:	e001      	b.n	8001424 <GSM_Manager_ChangeState+0xe4>
        break;
 8001420:	46c0      	nop			; (mov r8, r8)
 8001422:	e000      	b.n	8001426 <GSM_Manager_ChangeState+0xe6>
        break;
 8001424:	46c0      	nop			; (mov r8, r8)
    }
}
 8001426:	46c0      	nop			; (mov r8, r8)
 8001428:	46bd      	mov	sp, r7
 800142a:	b002      	add	sp, #8
 800142c:	bdb0      	pop	{r4, r5, r7, pc}
 800142e:	46c0      	nop			; (mov r8, r8)
 8001430:	20001884 	.word	0x20001884
 8001434:	0801da5c 	.word	0x0801da5c
 8001438:	0801e49c 	.word	0x0801e49c
 800143c:	0801da4c 	.word	0x0801da4c
 8001440:	0801e4cc 	.word	0x0801e4cc
 8001444:	50000800 	.word	0x50000800
 8001448:	50000400 	.word	0x50000400
 800144c:	0801e4d4 	.word	0x0801e4d4
 8001450:	0801e4e0 	.word	0x0801e4e0
 8001454:	200001f4 	.word	0x200001f4
 8001458:	08022434 	.word	0x08022434

0800145c <GSM_Manager_ChangeInternetMode>:
void GSM_Manager_ChangeInternetMode(gsm_internet_mode_t mode)
{
 800145c:	b580      	push	{r7, lr}
 800145e:	b082      	sub	sp, #8
 8001460:	af00      	add	r7, sp, #0
 8001462:	0002      	movs	r2, r0
 8001464:	1dfb      	adds	r3, r7, #7
 8001466:	701a      	strb	r2, [r3, #0]
    GSM_Manager.mode = mode;
 8001468:	4b03      	ldr	r3, [pc, #12]	; (8001478 <GSM_Manager_ChangeInternetMode+0x1c>)
 800146a:	1dfa      	adds	r2, r7, #7
 800146c:	7812      	ldrb	r2, [r2, #0]
 800146e:	709a      	strb	r2, [r3, #2]
}
 8001470:	46c0      	nop			; (mov r8, r8)
 8001472:	46bd      	mov	sp, r7
 8001474:	b002      	add	sp, #8
 8001476:	bd80      	pop	{r7, pc}
 8001478:	20001884 	.word	0x20001884

0800147c <GSM_mnr_task>:
void GSM_mnr_task(void)
{
 800147c:	b580      	push	{r7, lr}
 800147e:	af00      	add	r7, sp, #0
    GSM_Hardware_Layer_Run();
 8001480:	f000 f832 	bl	80014e8 <GSM_Hardware_Layer_Run>
    Polling_GSM_StateMachine();
 8001484:	f7ff feec 	bl	8001260 <Polling_GSM_StateMachine>
    GSM_Hardware_pppos_Polling();
 8001488:	f000 fb2c 	bl	8001ae4 <GSM_Hardware_pppos_Polling>
}
 800148c:	46c0      	nop			; (mov r8, r8)
 800148e:	46bd      	mov	sp, r7
 8001490:	bd80      	pop	{r7, pc}
	...

08001494 <GMS_Hardware_Init>:
static GSM_Hardware_atc_TypDef m_gsm_atc;
// Buffer for ppp
static GSM_Modem_Buffer_TypDef m_gsm_modem_buffer;

void GMS_Hardware_Init(void)
{
 8001494:	b580      	push	{r7, lr}
 8001496:	af00      	add	r7, sp, #0
	// Turn off power GSM
	HAL_GPIO_WritePin(EN_GSM_GPIO_Port,EN_GSM_Pin,0);
 8001498:	4b10      	ldr	r3, [pc, #64]	; (80014dc <GMS_Hardware_Init+0x48>)
 800149a:	2200      	movs	r2, #0
 800149c:	2140      	movs	r1, #64	; 0x40
 800149e:	0018      	movs	r0, r3
 80014a0:	f002 f81a 	bl	80034d8 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GSM_RESET_GPIO_Port,GSM_RESET_Pin,1);
 80014a4:	2380      	movs	r3, #128	; 0x80
 80014a6:	009b      	lsls	r3, r3, #2
 80014a8:	480d      	ldr	r0, [pc, #52]	; (80014e0 <GMS_Hardware_Init+0x4c>)
 80014aa:	2201      	movs	r2, #1
 80014ac:	0019      	movs	r1, r3
 80014ae:	f002 f813 	bl	80034d8 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GSM_PWKEY_GPIO_Port,GSM_PWKEY_Pin,0);
 80014b2:	2380      	movs	r3, #128	; 0x80
 80014b4:	0059      	lsls	r1, r3, #1
 80014b6:	23a0      	movs	r3, #160	; 0xa0
 80014b8:	05db      	lsls	r3, r3, #23
 80014ba:	2200      	movs	r2, #0
 80014bc:	0018      	movs	r0, r3
 80014be:	f002 f80b 	bl	80034d8 <HAL_GPIO_WritePin>
	//Init SEGGER RTT Debug
	SEGGER_RTT_Init();
 80014c2:	f001 fb79 	bl	8002bb8 <SEGGER_RTT_Init>
	// Cap phat bo nho cho RxRingBuffer
	RingBuffer_Init(&Rx_Buffer, 100);
 80014c6:	4b07      	ldr	r3, [pc, #28]	; (80014e4 <GMS_Hardware_Init+0x50>)
 80014c8:	2164      	movs	r1, #100	; 0x64
 80014ca:	0018      	movs	r0, r3
 80014cc:	f001 fbae 	bl	8002c2c <RingBuffer_Init>
	// Set default GMS State to GMS_STATE_RESET
	GSM_Manager_ChangeState(GSM_STATE_RESET);
 80014d0:	2001      	movs	r0, #1
 80014d2:	f7ff ff35 	bl	8001340 <GSM_Manager_ChangeState>
}
 80014d6:	46c0      	nop			; (mov r8, r8)
 80014d8:	46bd      	mov	sp, r7
 80014da:	bd80      	pop	{r7, pc}
 80014dc:	50000800 	.word	0x50000800
 80014e0:	50000400 	.word	0x50000400
 80014e4:	20001898 	.word	0x20001898

080014e8 <GSM_Hardware_Layer_Run>:
void GSM_Hardware_Layer_Run(void)
{
 80014e8:	b590      	push	{r4, r7, lr}
 80014ea:	b097      	sub	sp, #92	; 0x5c
 80014ec:	af02      	add	r7, sp, #8
	static uint32_t LastTick = 0;
	uint32_t Current_Tick = sys_get_tick_ms();
 80014ee:	f01b fc93 	bl	801ce18 <sys_get_tick_ms>
 80014f2:	0003      	movs	r3, r0
 80014f4:	64bb      	str	r3, [r7, #72]	; 0x48

	if(Current_Tick - LastTick < (uint32_t)5)
 80014f6:	4bc2      	ldr	r3, [pc, #776]	; (8001800 <GSM_Hardware_Layer_Run+0x318>)
 80014f8:	681b      	ldr	r3, [r3, #0]
 80014fa:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80014fc:	1ad3      	subs	r3, r2, r3
 80014fe:	2b04      	cmp	r3, #4
 8001500:	d800      	bhi.n	8001504 <GSM_Hardware_Layer_Run+0x1c>
 8001502:	e178      	b.n	80017f6 <GSM_Hardware_Layer_Run+0x30e>
	{
		return;
	}
	uint32_t diff = sys_get_tick_ms() - m_gsm_atc.atc.Last_time_send_atc_ms;
 8001504:	f01b fc88 	bl	801ce18 <sys_get_tick_ms>
 8001508:	0002      	movs	r2, r0
 800150a:	4bbe      	ldr	r3, [pc, #760]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 800150c:	699b      	ldr	r3, [r3, #24]
 800150e:	1ad3      	subs	r3, r2, r3
 8001510:	647b      	str	r3, [r7, #68]	; 0x44
	if(m_gsm_atc.atc.Timeout_atc_ms && diff >= m_gsm_atc.atc.Timeout_atc_ms)
 8001512:	4bbc      	ldr	r3, [pc, #752]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 8001514:	695b      	ldr	r3, [r3, #20]
 8001516:	2b00      	cmp	r3, #0
 8001518:	d100      	bne.n	800151c <GSM_Hardware_Layer_Run+0x34>
 800151a:	e07a      	b.n	8001612 <GSM_Hardware_Layer_Run+0x12a>
 800151c:	4bb9      	ldr	r3, [pc, #740]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 800151e:	695b      	ldr	r3, [r3, #20]
 8001520:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8001522:	429a      	cmp	r2, r3
 8001524:	d375      	bcc.n	8001612 <GSM_Hardware_Layer_Run+0x12a>
	{
		if(--m_gsm_atc.atc.Retry_Count_atc <= 0)
 8001526:	4bb7      	ldr	r3, [pc, #732]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 8001528:	7f1b      	ldrb	r3, [r3, #28]
 800152a:	3b01      	subs	r3, #1
 800152c:	b2da      	uxtb	r2, r3
 800152e:	4bb5      	ldr	r3, [pc, #724]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 8001530:	771a      	strb	r2, [r3, #28]
 8001532:	4bb4      	ldr	r3, [pc, #720]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 8001534:	7f1b      	ldrb	r3, [r3, #28]
 8001536:	2b00      	cmp	r3, #0
 8001538:	d11b      	bne.n	8001572 <GSM_Hardware_Layer_Run+0x8a>
		{
			m_gsm_atc.atc.Timeout_atc_ms = 0;
 800153a:	4bb2      	ldr	r3, [pc, #712]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 800153c:	2200      	movs	r2, #0
 800153e:	615a      	str	r2, [r3, #20]
			if(m_gsm_atc.atc.Send_at_Callback != NULL)
 8001540:	4ab0      	ldr	r2, [pc, #704]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 8001542:	2384      	movs	r3, #132	; 0x84
 8001544:	00db      	lsls	r3, r3, #3
 8001546:	58d3      	ldr	r3, [r2, r3]
 8001548:	2b00      	cmp	r3, #0
 800154a:	d006      	beq.n	800155a <GSM_Hardware_Layer_Run+0x72>
			{
				m_gsm_atc.atc.Send_at_Callback(GSM_EVENT_TIMEOUT,NULL);
 800154c:	4aad      	ldr	r2, [pc, #692]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 800154e:	2384      	movs	r3, #132	; 0x84
 8001550:	00db      	lsls	r3, r3, #3
 8001552:	58d3      	ldr	r3, [r2, r3]
 8001554:	2100      	movs	r1, #0
 8001556:	2001      	movs	r0, #1
 8001558:	4798      	blx	r3
			}
			memset(&m_gsm_atc.atc.Recv_Buffer.u8Buffer, 0, sizeof(m_gsm_atc.atc.Recv_Buffer.u8Buffer));
 800155a:	2380      	movs	r3, #128	; 0x80
 800155c:	00da      	lsls	r2, r3, #3
 800155e:	4baa      	ldr	r3, [pc, #680]	; (8001808 <GSM_Hardware_Layer_Run+0x320>)
 8001560:	2100      	movs	r1, #0
 8001562:	0018      	movs	r0, r3
 8001564:	f01b fcce 	bl	801cf04 <memset>
			m_gsm_atc.atc.Recv_Buffer.index = 0;
 8001568:	4ba6      	ldr	r3, [pc, #664]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 800156a:	4aa8      	ldr	r2, [pc, #672]	; (800180c <GSM_Hardware_Layer_Run+0x324>)
 800156c:	2100      	movs	r1, #0
 800156e:	5299      	strh	r1, [r3, r2]
 8001570:	e04f      	b.n	8001612 <GSM_Hardware_Layer_Run+0x12a>
		}
		else
		{
			char sub_cmd[64] = "";
 8001572:	1d3b      	adds	r3, r7, #4
 8001574:	2200      	movs	r2, #0
 8001576:	601a      	str	r2, [r3, #0]
 8001578:	3304      	adds	r3, #4
 800157a:	223c      	movs	r2, #60	; 0x3c
 800157c:	2100      	movs	r1, #0
 800157e:	0018      	movs	r0, r3
 8001580:	f01b fcc0 	bl	801cf04 <memset>
			strncpy(sub_cmd, m_gsm_atc.atc.cmd + 0, strlen(m_gsm_atc.atc.cmd) - 2);
 8001584:	4b9f      	ldr	r3, [pc, #636]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 8001586:	681c      	ldr	r4, [r3, #0]
 8001588:	4b9e      	ldr	r3, [pc, #632]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 800158a:	681b      	ldr	r3, [r3, #0]
 800158c:	0018      	movs	r0, r3
 800158e:	f7fe fdbb 	bl	8000108 <strlen>
 8001592:	0003      	movs	r3, r0
 8001594:	1e9a      	subs	r2, r3, #2
 8001596:	1d3b      	adds	r3, r7, #4
 8001598:	0021      	movs	r1, r4
 800159a:	0018      	movs	r0, r3
 800159c:	f01b fda8 	bl	801d0f0 <strncpy>
			DEBUG_WARN("Retry send [%s] %d.\r\n", sub_cmd, m_gsm_atc.atc.Retry_Count_atc);
 80015a0:	f01b fc3a 	bl	801ce18 <sys_get_tick_ms>
 80015a4:	0001      	movs	r1, r0
 80015a6:	4b97      	ldr	r3, [pc, #604]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 80015a8:	7f1b      	ldrb	r3, [r3, #28]
 80015aa:	001c      	movs	r4, r3
 80015ac:	1d3b      	adds	r3, r7, #4
 80015ae:	4a98      	ldr	r2, [pc, #608]	; (8001810 <GSM_Hardware_Layer_Run+0x328>)
 80015b0:	4898      	ldr	r0, [pc, #608]	; (8001814 <GSM_Hardware_Layer_Run+0x32c>)
 80015b2:	9400      	str	r4, [sp, #0]
 80015b4:	f001 fb08 	bl	8002bc8 <app_debug_rtt_raw>
			DEBUG_RAW("index = %d\r\n",m_gsm_atc.atc.Recv_Buffer.index);
 80015b8:	4b92      	ldr	r3, [pc, #584]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 80015ba:	4a94      	ldr	r2, [pc, #592]	; (800180c <GSM_Hardware_Layer_Run+0x324>)
 80015bc:	5a9b      	ldrh	r3, [r3, r2]
 80015be:	001a      	movs	r2, r3
 80015c0:	4b95      	ldr	r3, [pc, #596]	; (8001818 <GSM_Hardware_Layer_Run+0x330>)
 80015c2:	0011      	movs	r1, r2
 80015c4:	0018      	movs	r0, r3
 80015c6:	f001 faff 	bl	8002bc8 <app_debug_rtt_raw>
			DEBUG_RAW("%s\r\n", (char*)m_gsm_atc.atc.Recv_Buffer.u8Buffer);
 80015ca:	4a8f      	ldr	r2, [pc, #572]	; (8001808 <GSM_Hardware_Layer_Run+0x320>)
 80015cc:	4b93      	ldr	r3, [pc, #588]	; (800181c <GSM_Hardware_Layer_Run+0x334>)
 80015ce:	0011      	movs	r1, r2
 80015d0:	0018      	movs	r0, r3
 80015d2:	f001 faf9 	bl	8002bc8 <app_debug_rtt_raw>
			m_gsm_atc.atc.Last_time_send_atc_ms = sys_get_tick_ms();
 80015d6:	f01b fc1f 	bl	801ce18 <sys_get_tick_ms>
 80015da:	0002      	movs	r2, r0
 80015dc:	4b89      	ldr	r3, [pc, #548]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 80015de:	619a      	str	r2, [r3, #24]
			memset(&m_gsm_atc.atc.Recv_Buffer.u8Buffer, 0, sizeof(m_gsm_atc.atc.Recv_Buffer.u8Buffer));
 80015e0:	2380      	movs	r3, #128	; 0x80
 80015e2:	00da      	lsls	r2, r3, #3
 80015e4:	4b88      	ldr	r3, [pc, #544]	; (8001808 <GSM_Hardware_Layer_Run+0x320>)
 80015e6:	2100      	movs	r1, #0
 80015e8:	0018      	movs	r0, r3
 80015ea:	f01b fc8b 	bl	801cf04 <memset>
			m_gsm_atc.atc.Recv_Buffer.index = 0;
 80015ee:	4b85      	ldr	r3, [pc, #532]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 80015f0:	4a86      	ldr	r2, [pc, #536]	; (800180c <GSM_Hardware_Layer_Run+0x324>)
 80015f2:	2100      	movs	r1, #0
 80015f4:	5299      	strh	r1, [r3, r2]
			GSM_UART_TX((uint8_t*) m_gsm_atc.atc.cmd, strlen(m_gsm_atc.atc.cmd), 200);
 80015f6:	4b83      	ldr	r3, [pc, #524]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 80015f8:	681c      	ldr	r4, [r3, #0]
 80015fa:	4b82      	ldr	r3, [pc, #520]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 80015fc:	681b      	ldr	r3, [r3, #0]
 80015fe:	0018      	movs	r0, r3
 8001600:	f7fe fd82 	bl	8000108 <strlen>
 8001604:	0003      	movs	r3, r0
 8001606:	b29a      	uxth	r2, r3
 8001608:	4885      	ldr	r0, [pc, #532]	; (8001820 <GSM_Hardware_Layer_Run+0x338>)
 800160a:	23c8      	movs	r3, #200	; 0xc8
 800160c:	0021      	movs	r1, r4
 800160e:	f002 febb 	bl	8004388 <HAL_UART_Transmit>
		}
	}
	if(strlen(m_gsm_atc.atc.expect_resp) && strstr((char*)m_gsm_atc.atc.Recv_Buffer.u8Buffer, m_gsm_atc.atc.expect_resp))
 8001612:	4b7c      	ldr	r3, [pc, #496]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 8001614:	685b      	ldr	r3, [r3, #4]
 8001616:	781b      	ldrb	r3, [r3, #0]
 8001618:	2b00      	cmp	r3, #0
 800161a:	d06e      	beq.n	80016fa <GSM_Hardware_Layer_Run+0x212>
 800161c:	4b79      	ldr	r3, [pc, #484]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 800161e:	685a      	ldr	r2, [r3, #4]
 8001620:	4b79      	ldr	r3, [pc, #484]	; (8001808 <GSM_Hardware_Layer_Run+0x320>)
 8001622:	0011      	movs	r1, r2
 8001624:	0018      	movs	r0, r3
 8001626:	f01b fd77 	bl	801d118 <strstr>
 800162a:	1e03      	subs	r3, r0, #0
 800162c:	d065      	beq.n	80016fa <GSM_Hardware_Layer_Run+0x212>
	{
		bool do_callback = true;
 800162e:	244f      	movs	r4, #79	; 0x4f
 8001630:	193b      	adds	r3, r7, r4
 8001632:	2201      	movs	r2, #1
 8001634:	701a      	strb	r2, [r3, #0]
		if(m_gsm_atc.atc.expected_response_at_the_end && strlen(m_gsm_atc.atc.expected_response_at_the_end))
 8001636:	4b73      	ldr	r3, [pc, #460]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 8001638:	689b      	ldr	r3, [r3, #8]
 800163a:	2b00      	cmp	r3, #0
 800163c:	d03d      	beq.n	80016ba <GSM_Hardware_Layer_Run+0x1d2>
 800163e:	4b71      	ldr	r3, [pc, #452]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 8001640:	689b      	ldr	r3, [r3, #8]
 8001642:	781b      	ldrb	r3, [r3, #0]
 8001644:	2b00      	cmp	r3, #0
 8001646:	d038      	beq.n	80016ba <GSM_Hardware_Layer_Run+0x1d2>
		{
			Expect_len_compare = strlen(m_gsm_atc.atc.expected_response_at_the_end);
 8001648:	4b6e      	ldr	r3, [pc, #440]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 800164a:	689b      	ldr	r3, [r3, #8]
 800164c:	0018      	movs	r0, r3
 800164e:	f7fe fd5b 	bl	8000108 <strlen>
 8001652:	0002      	movs	r2, r0
 8001654:	4b73      	ldr	r3, [pc, #460]	; (8001824 <GSM_Hardware_Layer_Run+0x33c>)
 8001656:	601a      	str	r2, [r3, #0]
			Current_Response_len = strlen((char*)m_gsm_atc.atc.Recv_Buffer.u8Buffer);
 8001658:	4b6b      	ldr	r3, [pc, #428]	; (8001808 <GSM_Hardware_Layer_Run+0x320>)
 800165a:	0018      	movs	r0, r3
 800165c:	f7fe fd54 	bl	8000108 <strlen>
 8001660:	0002      	movs	r2, r0
 8001662:	4b71      	ldr	r3, [pc, #452]	; (8001828 <GSM_Hardware_Layer_Run+0x340>)
 8001664:	601a      	str	r2, [r3, #0]
			if(Expect_len_compare < Current_Response_len)
 8001666:	4b6f      	ldr	r3, [pc, #444]	; (8001824 <GSM_Hardware_Layer_Run+0x33c>)
 8001668:	681a      	ldr	r2, [r3, #0]
 800166a:	4b6f      	ldr	r3, [pc, #444]	; (8001828 <GSM_Hardware_Layer_Run+0x340>)
 800166c:	681b      	ldr	r3, [r3, #0]
 800166e:	429a      	cmp	r2, r3
 8001670:	d21f      	bcs.n	80016b2 <GSM_Hardware_Layer_Run+0x1ca>
			{
				p_compare_end_str = &m_gsm_atc.atc.Recv_Buffer.u8Buffer[Current_Response_len - Expect_len_compare];
 8001672:	4b6d      	ldr	r3, [pc, #436]	; (8001828 <GSM_Hardware_Layer_Run+0x340>)
 8001674:	681a      	ldr	r2, [r3, #0]
 8001676:	4b6b      	ldr	r3, [pc, #428]	; (8001824 <GSM_Hardware_Layer_Run+0x33c>)
 8001678:	681b      	ldr	r3, [r3, #0]
 800167a:	1ad3      	subs	r3, r2, r3
 800167c:	3318      	adds	r3, #24
 800167e:	001a      	movs	r2, r3
 8001680:	4b60      	ldr	r3, [pc, #384]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 8001682:	18d3      	adds	r3, r2, r3
 8001684:	1d9a      	adds	r2, r3, #6
 8001686:	4b69      	ldr	r3, [pc, #420]	; (800182c <GSM_Hardware_Layer_Run+0x344>)
 8001688:	601a      	str	r2, [r3, #0]
				if(memcmp(p_compare_end_str,m_gsm_atc.atc.expected_response_at_the_end,Expect_len_compare) == 0)
 800168a:	4b68      	ldr	r3, [pc, #416]	; (800182c <GSM_Hardware_Layer_Run+0x344>)
 800168c:	6818      	ldr	r0, [r3, #0]
 800168e:	4b5d      	ldr	r3, [pc, #372]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 8001690:	6899      	ldr	r1, [r3, #8]
 8001692:	4b64      	ldr	r3, [pc, #400]	; (8001824 <GSM_Hardware_Layer_Run+0x33c>)
 8001694:	681b      	ldr	r3, [r3, #0]
 8001696:	001a      	movs	r2, r3
 8001698:	f01b fc0a 	bl	801ceb0 <memcmp>
 800169c:	1e03      	subs	r3, r0, #0
 800169e:	d103      	bne.n	80016a8 <GSM_Hardware_Layer_Run+0x1c0>
				{
					// Compare thÃ nh cÃ´ng ÄuÃ´i Response
					do_callback = true;
 80016a0:	193b      	adds	r3, r7, r4
 80016a2:	2201      	movs	r2, #1
 80016a4:	701a      	strb	r2, [r3, #0]
 80016a6:	e008      	b.n	80016ba <GSM_Hardware_Layer_Run+0x1d2>
				}
				else
				{
					do_callback = false;
 80016a8:	234f      	movs	r3, #79	; 0x4f
 80016aa:	18fb      	adds	r3, r7, r3
 80016ac:	2200      	movs	r2, #0
 80016ae:	701a      	strb	r2, [r3, #0]
 80016b0:	e003      	b.n	80016ba <GSM_Hardware_Layer_Run+0x1d2>
				}
			}
			else
			{
				do_callback = false;
 80016b2:	234f      	movs	r3, #79	; 0x4f
 80016b4:	18fb      	adds	r3, r7, r3
 80016b6:	2200      	movs	r2, #0
 80016b8:	701a      	strb	r2, [r3, #0]
			}
		}
		if(do_callback == true)
 80016ba:	234f      	movs	r3, #79	; 0x4f
 80016bc:	18fb      	adds	r3, r7, r3
 80016be:	781b      	ldrb	r3, [r3, #0]
 80016c0:	2b00      	cmp	r3, #0
 80016c2:	d100      	bne.n	80016c6 <GSM_Hardware_Layer_Run+0x1de>
 80016c4:	e090      	b.n	80017e8 <GSM_Hardware_Layer_Run+0x300>
		{
			m_gsm_atc.atc.Timeout_atc_ms = 0;
 80016c6:	4b4f      	ldr	r3, [pc, #316]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 80016c8:	2200      	movs	r2, #0
 80016ca:	615a      	str	r2, [r3, #20]
			m_gsm_atc.atc.Retry_Count_atc = 0;
 80016cc:	4b4d      	ldr	r3, [pc, #308]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 80016ce:	2200      	movs	r2, #0
 80016d0:	771a      	strb	r2, [r3, #28]
			m_gsm_atc.atc.Send_at_Callback(GSM_EVENT_OK,m_gsm_atc.atc.Recv_Buffer.u8Buffer);
 80016d2:	4a4c      	ldr	r2, [pc, #304]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 80016d4:	2384      	movs	r3, #132	; 0x84
 80016d6:	00db      	lsls	r3, r3, #3
 80016d8:	58d3      	ldr	r3, [r2, r3]
 80016da:	4a4b      	ldr	r2, [pc, #300]	; (8001808 <GSM_Hardware_Layer_Run+0x320>)
 80016dc:	0011      	movs	r1, r2
 80016de:	2000      	movs	r0, #0
 80016e0:	4798      	blx	r3
			memset(&m_gsm_atc.atc.Recv_Buffer.u8Buffer, 0, sizeof(m_gsm_atc.atc.Recv_Buffer.u8Buffer));
 80016e2:	2380      	movs	r3, #128	; 0x80
 80016e4:	00da      	lsls	r2, r3, #3
 80016e6:	4b48      	ldr	r3, [pc, #288]	; (8001808 <GSM_Hardware_Layer_Run+0x320>)
 80016e8:	2100      	movs	r1, #0
 80016ea:	0018      	movs	r0, r3
 80016ec:	f01b fc0a 	bl	801cf04 <memset>
			m_gsm_atc.atc.Recv_Buffer.index = 0;
 80016f0:	4b44      	ldr	r3, [pc, #272]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 80016f2:	4a46      	ldr	r2, [pc, #280]	; (800180c <GSM_Hardware_Layer_Run+0x324>)
 80016f4:	2100      	movs	r1, #0
 80016f6:	5299      	strh	r1, [r3, r2]
	{
 80016f8:	e076      	b.n	80017e8 <GSM_Hardware_Layer_Run+0x300>
		}

	}
	else if(strlen(m_gsm_atc.atc.expect_error) && strstr((char*)m_gsm_atc.atc.Recv_Buffer.u8Buffer, m_gsm_atc.atc.expect_error))
 80016fa:	4b42      	ldr	r3, [pc, #264]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 80016fc:	68db      	ldr	r3, [r3, #12]
 80016fe:	781b      	ldrb	r3, [r3, #0]
 8001700:	2b00      	cmp	r3, #0
 8001702:	d100      	bne.n	8001706 <GSM_Hardware_Layer_Run+0x21e>
 8001704:	e071      	b.n	80017ea <GSM_Hardware_Layer_Run+0x302>
 8001706:	4b3f      	ldr	r3, [pc, #252]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 8001708:	68da      	ldr	r2, [r3, #12]
 800170a:	4b3f      	ldr	r3, [pc, #252]	; (8001808 <GSM_Hardware_Layer_Run+0x320>)
 800170c:	0011      	movs	r1, r2
 800170e:	0018      	movs	r0, r3
 8001710:	f01b fd02 	bl	801d118 <strstr>
 8001714:	1e03      	subs	r3, r0, #0
 8001716:	d068      	beq.n	80017ea <GSM_Hardware_Layer_Run+0x302>
	{
		bool do_callback = true;
 8001718:	244e      	movs	r4, #78	; 0x4e
 800171a:	193b      	adds	r3, r7, r4
 800171c:	2201      	movs	r2, #1
 800171e:	701a      	strb	r2, [r3, #0]
		if(m_gsm_atc.atc.expect_error_at_the_end && strlen(m_gsm_atc.atc.expect_error_at_the_end))
 8001720:	4b38      	ldr	r3, [pc, #224]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 8001722:	691b      	ldr	r3, [r3, #16]
 8001724:	2b00      	cmp	r3, #0
 8001726:	d03d      	beq.n	80017a4 <GSM_Hardware_Layer_Run+0x2bc>
 8001728:	4b36      	ldr	r3, [pc, #216]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 800172a:	691b      	ldr	r3, [r3, #16]
 800172c:	781b      	ldrb	r3, [r3, #0]
 800172e:	2b00      	cmp	r3, #0
 8001730:	d038      	beq.n	80017a4 <GSM_Hardware_Layer_Run+0x2bc>
		{
			Expect_len_compare_error_handle = strlen(m_gsm_atc.atc.expect_error_at_the_end);
 8001732:	4b34      	ldr	r3, [pc, #208]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 8001734:	691b      	ldr	r3, [r3, #16]
 8001736:	0018      	movs	r0, r3
 8001738:	f7fe fce6 	bl	8000108 <strlen>
 800173c:	0002      	movs	r2, r0
 800173e:	4b3c      	ldr	r3, [pc, #240]	; (8001830 <GSM_Hardware_Layer_Run+0x348>)
 8001740:	601a      	str	r2, [r3, #0]
			Current_Response_len_error_handle = strlen((char*)m_gsm_atc.atc.Recv_Buffer.u8Buffer);
 8001742:	4b31      	ldr	r3, [pc, #196]	; (8001808 <GSM_Hardware_Layer_Run+0x320>)
 8001744:	0018      	movs	r0, r3
 8001746:	f7fe fcdf 	bl	8000108 <strlen>
 800174a:	0002      	movs	r2, r0
 800174c:	4b39      	ldr	r3, [pc, #228]	; (8001834 <GSM_Hardware_Layer_Run+0x34c>)
 800174e:	601a      	str	r2, [r3, #0]
			if(Expect_len_compare_error_handle < Current_Response_len_error_handle)
 8001750:	4b37      	ldr	r3, [pc, #220]	; (8001830 <GSM_Hardware_Layer_Run+0x348>)
 8001752:	681a      	ldr	r2, [r3, #0]
 8001754:	4b37      	ldr	r3, [pc, #220]	; (8001834 <GSM_Hardware_Layer_Run+0x34c>)
 8001756:	681b      	ldr	r3, [r3, #0]
 8001758:	429a      	cmp	r2, r3
 800175a:	d21f      	bcs.n	800179c <GSM_Hardware_Layer_Run+0x2b4>
			{
				p_compare_end_str_error_handle = &m_gsm_atc.atc.Recv_Buffer.u8Buffer[Current_Response_len_error_handle - Expect_len_compare_error_handle];
 800175c:	4b35      	ldr	r3, [pc, #212]	; (8001834 <GSM_Hardware_Layer_Run+0x34c>)
 800175e:	681a      	ldr	r2, [r3, #0]
 8001760:	4b33      	ldr	r3, [pc, #204]	; (8001830 <GSM_Hardware_Layer_Run+0x348>)
 8001762:	681b      	ldr	r3, [r3, #0]
 8001764:	1ad3      	subs	r3, r2, r3
 8001766:	3318      	adds	r3, #24
 8001768:	001a      	movs	r2, r3
 800176a:	4b26      	ldr	r3, [pc, #152]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 800176c:	18d3      	adds	r3, r2, r3
 800176e:	1d9a      	adds	r2, r3, #6
 8001770:	4b31      	ldr	r3, [pc, #196]	; (8001838 <GSM_Hardware_Layer_Run+0x350>)
 8001772:	601a      	str	r2, [r3, #0]
				if(memcmp(p_compare_end_str_error_handle,m_gsm_atc.atc.expect_error_at_the_end,Expect_len_compare_error_handle))
 8001774:	4b30      	ldr	r3, [pc, #192]	; (8001838 <GSM_Hardware_Layer_Run+0x350>)
 8001776:	6818      	ldr	r0, [r3, #0]
 8001778:	4b22      	ldr	r3, [pc, #136]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 800177a:	6919      	ldr	r1, [r3, #16]
 800177c:	4b2c      	ldr	r3, [pc, #176]	; (8001830 <GSM_Hardware_Layer_Run+0x348>)
 800177e:	681b      	ldr	r3, [r3, #0]
 8001780:	001a      	movs	r2, r3
 8001782:	f01b fb95 	bl	801ceb0 <memcmp>
 8001786:	1e03      	subs	r3, r0, #0
 8001788:	d003      	beq.n	8001792 <GSM_Hardware_Layer_Run+0x2aa>
				{
					// Compare thÃ nh cÃ´ng ÄuÃ´i Response (trÆ°á»ng há»£p Response Error)
					do_callback = true;
 800178a:	193b      	adds	r3, r7, r4
 800178c:	2201      	movs	r2, #1
 800178e:	701a      	strb	r2, [r3, #0]
 8001790:	e008      	b.n	80017a4 <GSM_Hardware_Layer_Run+0x2bc>
				}
				else
				{
					do_callback = false;
 8001792:	234e      	movs	r3, #78	; 0x4e
 8001794:	18fb      	adds	r3, r7, r3
 8001796:	2200      	movs	r2, #0
 8001798:	701a      	strb	r2, [r3, #0]
 800179a:	e003      	b.n	80017a4 <GSM_Hardware_Layer_Run+0x2bc>
				}
			}
			else
			{
				do_callback = false;
 800179c:	234e      	movs	r3, #78	; 0x4e
 800179e:	18fb      	adds	r3, r7, r3
 80017a0:	2200      	movs	r2, #0
 80017a2:	701a      	strb	r2, [r3, #0]
			}
		}
		if(do_callback == true)
 80017a4:	234e      	movs	r3, #78	; 0x4e
 80017a6:	18fb      	adds	r3, r7, r3
 80017a8:	781b      	ldrb	r3, [r3, #0]
 80017aa:	2b00      	cmp	r3, #0
 80017ac:	d01d      	beq.n	80017ea <GSM_Hardware_Layer_Run+0x302>
		{
			m_gsm_atc.atc.Last_time_send_atc_ms = 0;
 80017ae:	4b15      	ldr	r3, [pc, #84]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 80017b0:	2200      	movs	r2, #0
 80017b2:	619a      	str	r2, [r3, #24]
			m_gsm_atc.atc.Timeout_atc_ms = 0;
 80017b4:	4b13      	ldr	r3, [pc, #76]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 80017b6:	2200      	movs	r2, #0
 80017b8:	615a      	str	r2, [r3, #20]
			m_gsm_atc.atc.Retry_Count_atc = 0;
 80017ba:	4b12      	ldr	r3, [pc, #72]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 80017bc:	2200      	movs	r2, #0
 80017be:	771a      	strb	r2, [r3, #28]
			m_gsm_atc.atc.Send_at_Callback(GSM_EVENT_ERROR,m_gsm_atc.atc.Recv_Buffer.u8Buffer);
 80017c0:	4a10      	ldr	r2, [pc, #64]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 80017c2:	2384      	movs	r3, #132	; 0x84
 80017c4:	00db      	lsls	r3, r3, #3
 80017c6:	58d3      	ldr	r3, [r2, r3]
 80017c8:	4a0f      	ldr	r2, [pc, #60]	; (8001808 <GSM_Hardware_Layer_Run+0x320>)
 80017ca:	0011      	movs	r1, r2
 80017cc:	2002      	movs	r0, #2
 80017ce:	4798      	blx	r3
			memset(&m_gsm_atc.atc.Recv_Buffer.u8Buffer, 0, sizeof(m_gsm_atc.atc.Recv_Buffer.u8Buffer));
 80017d0:	2380      	movs	r3, #128	; 0x80
 80017d2:	00da      	lsls	r2, r3, #3
 80017d4:	4b0c      	ldr	r3, [pc, #48]	; (8001808 <GSM_Hardware_Layer_Run+0x320>)
 80017d6:	2100      	movs	r1, #0
 80017d8:	0018      	movs	r0, r3
 80017da:	f01b fb93 	bl	801cf04 <memset>
			m_gsm_atc.atc.Recv_Buffer.index = 0;
 80017de:	4b09      	ldr	r3, [pc, #36]	; (8001804 <GSM_Hardware_Layer_Run+0x31c>)
 80017e0:	4a0a      	ldr	r2, [pc, #40]	; (800180c <GSM_Hardware_Layer_Run+0x324>)
 80017e2:	2100      	movs	r1, #0
 80017e4:	5299      	strh	r1, [r3, r2]
 80017e6:	e000      	b.n	80017ea <GSM_Hardware_Layer_Run+0x302>
	{
 80017e8:	46c0      	nop			; (mov r8, r8)
		}
	}
	LastTick = sys_get_tick_ms();
 80017ea:	f01b fb15 	bl	801ce18 <sys_get_tick_ms>
 80017ee:	0002      	movs	r2, r0
 80017f0:	4b03      	ldr	r3, [pc, #12]	; (8001800 <GSM_Hardware_Layer_Run+0x318>)
 80017f2:	601a      	str	r2, [r3, #0]
 80017f4:	e000      	b.n	80017f8 <GSM_Hardware_Layer_Run+0x310>
		return;
 80017f6:	46c0      	nop			; (mov r8, r8)
}
 80017f8:	46bd      	mov	sp, r7
 80017fa:	b015      	add	sp, #84	; 0x54
 80017fc:	bd90      	pop	{r4, r7, pc}
 80017fe:	46c0      	nop			; (mov r8, r8)
 8001800:	20000c24 	.word	0x20000c24
 8001804:	200001fc 	.word	0x200001fc
 8001808:	2000021a 	.word	0x2000021a
 800180c:	0000041e 	.word	0x0000041e
 8001810:	0801e4f0 	.word	0x0801e4f0
 8001814:	0801e4f4 	.word	0x0801e4f4
 8001818:	0801e524 	.word	0x0801e524
 800181c:	0801e534 	.word	0x0801e534
 8001820:	20001800 	.word	0x20001800
 8001824:	2000188c 	.word	0x2000188c
 8001828:	20001890 	.word	0x20001890
 800182c:	200018ac 	.word	0x200018ac
 8001830:	20001888 	.word	0x20001888
 8001834:	200018a8 	.word	0x200018a8
 8001838:	20001894 	.word	0x20001894

0800183c <GSM_Turn_on_Power>:
void GSM_Turn_on_Power(void)
{
 800183c:	b580      	push	{r7, lr}
 800183e:	af00      	add	r7, sp, #0
	static uint8_t step;
	DEBUG_INFO("GSM Hard reset step %d.\r\n", step);
 8001840:	f01b faea 	bl	801ce18 <sys_get_tick_ms>
 8001844:	0001      	movs	r1, r0
 8001846:	4b52      	ldr	r3, [pc, #328]	; (8001990 <GSM_Turn_on_Power+0x154>)
 8001848:	781b      	ldrb	r3, [r3, #0]
 800184a:	4a52      	ldr	r2, [pc, #328]	; (8001994 <GSM_Turn_on_Power+0x158>)
 800184c:	4852      	ldr	r0, [pc, #328]	; (8001998 <GSM_Turn_on_Power+0x15c>)
 800184e:	f001 f9bb 	bl	8002bc8 <app_debug_rtt_raw>
	switch (step)
 8001852:	4b4f      	ldr	r3, [pc, #316]	; (8001990 <GSM_Turn_on_Power+0x154>)
 8001854:	781b      	ldrb	r3, [r3, #0]
 8001856:	2b07      	cmp	r3, #7
 8001858:	d900      	bls.n	800185c <GSM_Turn_on_Power+0x20>
 800185a:	e094      	b.n	8001986 <GSM_Turn_on_Power+0x14a>
 800185c:	009a      	lsls	r2, r3, #2
 800185e:	4b4f      	ldr	r3, [pc, #316]	; (800199c <GSM_Turn_on_Power+0x160>)
 8001860:	18d3      	adds	r3, r2, r3
 8001862:	681b      	ldr	r3, [r3, #0]
 8001864:	469f      	mov	pc, r3
	{
		case 0:
			HAL_GPIO_WritePin(EN_GSM_GPIO_Port,EN_GSM_Pin,0);
 8001866:	4b4e      	ldr	r3, [pc, #312]	; (80019a0 <GSM_Turn_on_Power+0x164>)
 8001868:	2200      	movs	r2, #0
 800186a:	2140      	movs	r1, #64	; 0x40
 800186c:	0018      	movs	r0, r3
 800186e:	f001 fe33 	bl	80034d8 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(GSM_RESET_GPIO_Port,GSM_RESET_Pin,1);
 8001872:	2380      	movs	r3, #128	; 0x80
 8001874:	009b      	lsls	r3, r3, #2
 8001876:	484b      	ldr	r0, [pc, #300]	; (80019a4 <GSM_Turn_on_Power+0x168>)
 8001878:	2201      	movs	r2, #1
 800187a:	0019      	movs	r1, r3
 800187c:	f001 fe2c 	bl	80034d8 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(GSM_PWKEY_GPIO_Port,GSM_PWKEY_Pin,0);
 8001880:	2380      	movs	r3, #128	; 0x80
 8001882:	0059      	lsls	r1, r3, #1
 8001884:	23a0      	movs	r3, #160	; 0xa0
 8001886:	05db      	lsls	r3, r3, #23
 8001888:	2200      	movs	r2, #0
 800188a:	0018      	movs	r0, r3
 800188c:	f001 fe24 	bl	80034d8 <HAL_GPIO_WritePin>
			step++;
 8001890:	4b3f      	ldr	r3, [pc, #252]	; (8001990 <GSM_Turn_on_Power+0x154>)
 8001892:	781b      	ldrb	r3, [r3, #0]
 8001894:	3301      	adds	r3, #1
 8001896:	b2da      	uxtb	r2, r3
 8001898:	4b3d      	ldr	r3, [pc, #244]	; (8001990 <GSM_Turn_on_Power+0x154>)
 800189a:	701a      	strb	r2, [r3, #0]
			break;
 800189c:	e074      	b.n	8001988 <GSM_Turn_on_Power+0x14c>
		case 1:
			HAL_GPIO_WritePin(GSM_RESET_GPIO_Port,GSM_RESET_Pin,0);
 800189e:	2380      	movs	r3, #128	; 0x80
 80018a0:	009b      	lsls	r3, r3, #2
 80018a2:	4840      	ldr	r0, [pc, #256]	; (80019a4 <GSM_Turn_on_Power+0x168>)
 80018a4:	2200      	movs	r2, #0
 80018a6:	0019      	movs	r1, r3
 80018a8:	f001 fe16 	bl	80034d8 <HAL_GPIO_WritePin>
			DEBUG_INFO("GSM power on.\r\n");
 80018ac:	f01b fab4 	bl	801ce18 <sys_get_tick_ms>
 80018b0:	0001      	movs	r1, r0
 80018b2:	4a38      	ldr	r2, [pc, #224]	; (8001994 <GSM_Turn_on_Power+0x158>)
 80018b4:	4b3c      	ldr	r3, [pc, #240]	; (80019a8 <GSM_Turn_on_Power+0x16c>)
 80018b6:	0018      	movs	r0, r3
 80018b8:	f001 f986 	bl	8002bc8 <app_debug_rtt_raw>
			HAL_GPIO_WritePin(EN_GSM_GPIO_Port,EN_GSM_Pin,1);
 80018bc:	4b38      	ldr	r3, [pc, #224]	; (80019a0 <GSM_Turn_on_Power+0x164>)
 80018be:	2201      	movs	r2, #1
 80018c0:	2140      	movs	r1, #64	; 0x40
 80018c2:	0018      	movs	r0, r3
 80018c4:	f001 fe08 	bl	80034d8 <HAL_GPIO_WritePin>
			// Enable nguon 5V
			HAL_GPIO_WritePin(CHARGE_EN_GPIO_Port,CHARGE_EN_Pin,1);
 80018c8:	4b35      	ldr	r3, [pc, #212]	; (80019a0 <GSM_Turn_on_Power+0x164>)
 80018ca:	2201      	movs	r2, #1
 80018cc:	2110      	movs	r1, #16
 80018ce:	0018      	movs	r0, r3
 80018d0:	f001 fe02 	bl	80034d8 <HAL_GPIO_WritePin>
			// Enable nguon 4.2V
			HAL_GPIO_WritePin(GSM_EN_GPIO_Port,GSM_EN_Pin,1);
 80018d4:	2380      	movs	r3, #128	; 0x80
 80018d6:	0219      	lsls	r1, r3, #8
 80018d8:	23a0      	movs	r3, #160	; 0xa0
 80018da:	05db      	lsls	r3, r3, #23
 80018dc:	2201      	movs	r2, #1
 80018de:	0018      	movs	r0, r3
 80018e0:	f001 fdfa 	bl	80034d8 <HAL_GPIO_WritePin>
			step++;
 80018e4:	4b2a      	ldr	r3, [pc, #168]	; (8001990 <GSM_Turn_on_Power+0x154>)
 80018e6:	781b      	ldrb	r3, [r3, #0]
 80018e8:	3301      	adds	r3, #1
 80018ea:	b2da      	uxtb	r2, r3
 80018ec:	4b28      	ldr	r3, [pc, #160]	; (8001990 <GSM_Turn_on_Power+0x154>)
 80018ee:	701a      	strb	r2, [r3, #0]
			break;
 80018f0:	e04a      	b.n	8001988 <GSM_Turn_on_Power+0x14c>
		case 2:
			step++;
 80018f2:	4b27      	ldr	r3, [pc, #156]	; (8001990 <GSM_Turn_on_Power+0x154>)
 80018f4:	781b      	ldrb	r3, [r3, #0]
 80018f6:	3301      	adds	r3, #1
 80018f8:	b2da      	uxtb	r2, r3
 80018fa:	4b25      	ldr	r3, [pc, #148]	; (8001990 <GSM_Turn_on_Power+0x154>)
 80018fc:	701a      	strb	r2, [r3, #0]
			break;
 80018fe:	e043      	b.n	8001988 <GSM_Turn_on_Power+0x14c>
		case 3: 
			/* Generate pulse from (1-0-1) |_| to Power On module */
			DEBUG_INFO("Pulse power key.\r\n");
 8001900:	f01b fa8a 	bl	801ce18 <sys_get_tick_ms>
 8001904:	0001      	movs	r1, r0
 8001906:	4a23      	ldr	r2, [pc, #140]	; (8001994 <GSM_Turn_on_Power+0x158>)
 8001908:	4b28      	ldr	r3, [pc, #160]	; (80019ac <GSM_Turn_on_Power+0x170>)
 800190a:	0018      	movs	r0, r3
 800190c:	f001 f95c 	bl	8002bc8 <app_debug_rtt_raw>
			HAL_GPIO_WritePin(GSM_PWKEY_GPIO_Port,GSM_PWKEY_Pin,1);
 8001910:	2380      	movs	r3, #128	; 0x80
 8001912:	0059      	lsls	r1, r3, #1
 8001914:	23a0      	movs	r3, #160	; 0xa0
 8001916:	05db      	lsls	r3, r3, #23
 8001918:	2201      	movs	r2, #1
 800191a:	0018      	movs	r0, r3
 800191c:	f001 fddc 	bl	80034d8 <HAL_GPIO_WritePin>
			step++;
 8001920:	4b1b      	ldr	r3, [pc, #108]	; (8001990 <GSM_Turn_on_Power+0x154>)
 8001922:	781b      	ldrb	r3, [r3, #0]
 8001924:	3301      	adds	r3, #1
 8001926:	b2da      	uxtb	r2, r3
 8001928:	4b19      	ldr	r3, [pc, #100]	; (8001990 <GSM_Turn_on_Power+0x154>)
 800192a:	701a      	strb	r2, [r3, #0]
			break;
 800192c:	e02c      	b.n	8001988 <GSM_Turn_on_Power+0x14c>
		case 4:
			HAL_GPIO_WritePin(GSM_PWKEY_GPIO_Port,GSM_PWKEY_Pin,0);
 800192e:	2380      	movs	r3, #128	; 0x80
 8001930:	0059      	lsls	r1, r3, #1
 8001932:	23a0      	movs	r3, #160	; 0xa0
 8001934:	05db      	lsls	r3, r3, #23
 8001936:	2200      	movs	r2, #0
 8001938:	0018      	movs	r0, r3
 800193a:	f001 fdcd 	bl	80034d8 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(GSM_RESET_GPIO_Port,GSM_RESET_Pin,0);
 800193e:	2380      	movs	r3, #128	; 0x80
 8001940:	009b      	lsls	r3, r3, #2
 8001942:	4818      	ldr	r0, [pc, #96]	; (80019a4 <GSM_Turn_on_Power+0x168>)
 8001944:	2200      	movs	r2, #0
 8001946:	0019      	movs	r1, r3
 8001948:	f001 fdc6 	bl	80034d8 <HAL_GPIO_WritePin>
			step++;
 800194c:	4b10      	ldr	r3, [pc, #64]	; (8001990 <GSM_Turn_on_Power+0x154>)
 800194e:	781b      	ldrb	r3, [r3, #0]
 8001950:	3301      	adds	r3, #1
 8001952:	b2da      	uxtb	r2, r3
 8001954:	4b0e      	ldr	r3, [pc, #56]	; (8001990 <GSM_Turn_on_Power+0x154>)
 8001956:	701a      	strb	r2, [r3, #0]
			break;
 8001958:	e016      	b.n	8001988 <GSM_Turn_on_Power+0x14c>
		case 5:
		case 6:
			step++;
 800195a:	4b0d      	ldr	r3, [pc, #52]	; (8001990 <GSM_Turn_on_Power+0x154>)
 800195c:	781b      	ldrb	r3, [r3, #0]
 800195e:	3301      	adds	r3, #1
 8001960:	b2da      	uxtb	r2, r3
 8001962:	4b0b      	ldr	r3, [pc, #44]	; (8001990 <GSM_Turn_on_Power+0x154>)
 8001964:	701a      	strb	r2, [r3, #0]
			break;
 8001966:	e00f      	b.n	8001988 <GSM_Turn_on_Power+0x14c>
		case 7:
			step = 0;
 8001968:	4b09      	ldr	r3, [pc, #36]	; (8001990 <GSM_Turn_on_Power+0x154>)
 800196a:	2200      	movs	r2, #0
 800196c:	701a      	strb	r2, [r3, #0]
			DEBUG_INFO("GSM Hard reset DONE.\r\n");
 800196e:	f01b fa53 	bl	801ce18 <sys_get_tick_ms>
 8001972:	0001      	movs	r1, r0
 8001974:	4a07      	ldr	r2, [pc, #28]	; (8001994 <GSM_Turn_on_Power+0x158>)
 8001976:	4b0e      	ldr	r3, [pc, #56]	; (80019b0 <GSM_Turn_on_Power+0x174>)
 8001978:	0018      	movs	r0, r3
 800197a:	f001 f925 	bl	8002bc8 <app_debug_rtt_raw>
			GSM_Manager_ChangeState(GSM_STATE_POWER_ON); // GSM turn on Power Finish-> active GSM by AT Cmd
 800197e:	2000      	movs	r0, #0
 8001980:	f7ff fcde 	bl	8001340 <GSM_Manager_ChangeState>
			break;
 8001984:	e000      	b.n	8001988 <GSM_Turn_on_Power+0x14c>
		default:
		break;
 8001986:	46c0      	nop			; (mov r8, r8)
	}
}
 8001988:	46c0      	nop			; (mov r8, r8)
 800198a:	46bd      	mov	sp, r7
 800198c:	bd80      	pop	{r7, pc}
 800198e:	46c0      	nop			; (mov r8, r8)
 8001990:	20000c28 	.word	0x20000c28
 8001994:	0801e4f0 	.word	0x0801e4f0
 8001998:	0801e53c 	.word	0x0801e53c
 800199c:	08022520 	.word	0x08022520
 80019a0:	50000800 	.word	0x50000800
 80019a4:	50000400 	.word	0x50000400
 80019a8:	0801e570 	.word	0x0801e570
 80019ac:	0801e59c 	.word	0x0801e59c
 80019b0:	0801e5c8 	.word	0x0801e5c8

080019b4 <GSM_SendCommand_AT>:
void GSM_SendCommand_AT (GSM_ATCommand_Table_TypDef AT_Cmd)
{
 80019b4:	b084      	sub	sp, #16
 80019b6:	b5b0      	push	{r4, r5, r7, lr}
 80019b8:	af00      	add	r7, sp, #0
 80019ba:	2510      	movs	r5, #16
 80019bc:	197c      	adds	r4, r7, r5
 80019be:	6020      	str	r0, [r4, #0]
 80019c0:	6061      	str	r1, [r4, #4]
 80019c2:	60a2      	str	r2, [r4, #8]
 80019c4:	60e3      	str	r3, [r4, #12]
	if(AT_Cmd.Timeout_atc_ms == 0 || AT_Cmd.Send_at_Callback == NULL)
 80019c6:	002a      	movs	r2, r5
 80019c8:	18bb      	adds	r3, r7, r2
 80019ca:	695b      	ldr	r3, [r3, #20]
 80019cc:	2b00      	cmp	r3, #0
 80019ce:	d003      	beq.n	80019d8 <GSM_SendCommand_AT+0x24>
 80019d0:	18bb      	adds	r3, r7, r2
 80019d2:	69db      	ldr	r3, [r3, #28]
 80019d4:	2b00      	cmp	r3, #0
 80019d6:	d11c      	bne.n	8001a12 <GSM_SendCommand_AT+0x5e>
	{
		memset(&m_gsm_atc.atc.Recv_Buffer.u8Buffer, 0, sizeof(m_gsm_atc.atc.Recv_Buffer.u8Buffer));
 80019d8:	2380      	movs	r3, #128	; 0x80
 80019da:	00da      	lsls	r2, r3, #3
 80019dc:	4b34      	ldr	r3, [pc, #208]	; (8001ab0 <GSM_SendCommand_AT+0xfc>)
 80019de:	2100      	movs	r1, #0
 80019e0:	0018      	movs	r0, r3
 80019e2:	f01b fa8f 	bl	801cf04 <memset>
		m_gsm_atc.atc.Recv_Buffer.index = 0;
 80019e6:	4b33      	ldr	r3, [pc, #204]	; (8001ab4 <GSM_SendCommand_AT+0x100>)
 80019e8:	4a33      	ldr	r2, [pc, #204]	; (8001ab8 <GSM_SendCommand_AT+0x104>)
 80019ea:	2100      	movs	r1, #0
 80019ec:	5299      	strh	r1, [r3, r2]
		GSM_HwLayer_Reset_Rx_Buffer();
 80019ee:	f000 f8d1 	bl	8001b94 <GSM_HwLayer_Reset_Rx_Buffer>
		//HAL_UART_Transmit(&huart1, (uint8_t *)AT_Cmd.cmd, strlen(AT_Cmd.cmd), 200);
		GSM_UART_TX((uint8_t *)AT_Cmd.cmd, strlen(AT_Cmd.cmd), 200);
 80019f2:	2210      	movs	r2, #16
 80019f4:	18bb      	adds	r3, r7, r2
 80019f6:	681c      	ldr	r4, [r3, #0]
 80019f8:	18bb      	adds	r3, r7, r2
 80019fa:	681b      	ldr	r3, [r3, #0]
 80019fc:	0018      	movs	r0, r3
 80019fe:	f7fe fb83 	bl	8000108 <strlen>
 8001a02:	0003      	movs	r3, r0
 8001a04:	b29a      	uxth	r2, r3
 8001a06:	482d      	ldr	r0, [pc, #180]	; (8001abc <GSM_SendCommand_AT+0x108>)
 8001a08:	23c8      	movs	r3, #200	; 0xc8
 8001a0a:	0021      	movs	r1, r4
 8001a0c:	f002 fcbc 	bl	8004388 <HAL_UART_Transmit>
		return;
 8001a10:	e048      	b.n	8001aa4 <GSM_SendCommand_AT+0xf0>
	}
	if(strlen(AT_Cmd.cmd) < 64)
 8001a12:	2410      	movs	r4, #16
 8001a14:	193b      	adds	r3, r7, r4
 8001a16:	681b      	ldr	r3, [r3, #0]
 8001a18:	0018      	movs	r0, r3
 8001a1a:	f7fe fb75 	bl	8000108 <strlen>
	{

	}
	m_gsm_atc.atc.cmd = AT_Cmd.cmd;
 8001a1e:	193b      	adds	r3, r7, r4
 8001a20:	681a      	ldr	r2, [r3, #0]
 8001a22:	4b24      	ldr	r3, [pc, #144]	; (8001ab4 <GSM_SendCommand_AT+0x100>)
 8001a24:	601a      	str	r2, [r3, #0]
	m_gsm_atc.atc.expect_resp = AT_Cmd.expect_resp;
 8001a26:	193b      	adds	r3, r7, r4
 8001a28:	685a      	ldr	r2, [r3, #4]
 8001a2a:	4b22      	ldr	r3, [pc, #136]	; (8001ab4 <GSM_SendCommand_AT+0x100>)
 8001a2c:	605a      	str	r2, [r3, #4]
	m_gsm_atc.atc.expected_response_at_the_end = AT_Cmd.expected_response_at_the_end;
 8001a2e:	193b      	adds	r3, r7, r4
 8001a30:	689a      	ldr	r2, [r3, #8]
 8001a32:	4b20      	ldr	r3, [pc, #128]	; (8001ab4 <GSM_SendCommand_AT+0x100>)
 8001a34:	609a      	str	r2, [r3, #8]
	m_gsm_atc.atc.expect_error = AT_Cmd.expect_error;
 8001a36:	193b      	adds	r3, r7, r4
 8001a38:	68da      	ldr	r2, [r3, #12]
 8001a3a:	4b1e      	ldr	r3, [pc, #120]	; (8001ab4 <GSM_SendCommand_AT+0x100>)
 8001a3c:	60da      	str	r2, [r3, #12]
	m_gsm_atc.atc.expect_error_at_the_end = AT_Cmd.expect_error_at_the_end;
 8001a3e:	193b      	adds	r3, r7, r4
 8001a40:	691a      	ldr	r2, [r3, #16]
 8001a42:	4b1c      	ldr	r3, [pc, #112]	; (8001ab4 <GSM_SendCommand_AT+0x100>)
 8001a44:	611a      	str	r2, [r3, #16]
	m_gsm_atc.atc.Timeout_atc_ms = AT_Cmd.Timeout_atc_ms;
 8001a46:	193b      	adds	r3, r7, r4
 8001a48:	695a      	ldr	r2, [r3, #20]
 8001a4a:	4b1a      	ldr	r3, [pc, #104]	; (8001ab4 <GSM_SendCommand_AT+0x100>)
 8001a4c:	615a      	str	r2, [r3, #20]
	m_gsm_atc.atc.Last_time_send_atc_ms = sys_get_tick_ms();
 8001a4e:	f01b f9e3 	bl	801ce18 <sys_get_tick_ms>
 8001a52:	0002      	movs	r2, r0
 8001a54:	4b17      	ldr	r3, [pc, #92]	; (8001ab4 <GSM_SendCommand_AT+0x100>)
 8001a56:	619a      	str	r2, [r3, #24]
	m_gsm_atc.atc.Retry_Count_atc = AT_Cmd.Retry_Count_atc;
 8001a58:	193b      	adds	r3, r7, r4
 8001a5a:	7e1a      	ldrb	r2, [r3, #24]
 8001a5c:	4b15      	ldr	r3, [pc, #84]	; (8001ab4 <GSM_SendCommand_AT+0x100>)
 8001a5e:	771a      	strb	r2, [r3, #28]
	m_gsm_atc.atc.Send_at_Callback = AT_Cmd.Send_at_Callback;
 8001a60:	193b      	adds	r3, r7, r4
 8001a62:	69d9      	ldr	r1, [r3, #28]
 8001a64:	4a13      	ldr	r2, [pc, #76]	; (8001ab4 <GSM_SendCommand_AT+0x100>)
 8001a66:	2384      	movs	r3, #132	; 0x84
 8001a68:	00db      	lsls	r3, r3, #3
 8001a6a:	50d1      	str	r1, [r2, r3]

	memset(&m_gsm_atc.atc.Recv_Buffer.u8Buffer, 0, sizeof(m_gsm_atc.atc.Recv_Buffer.u8Buffer));
 8001a6c:	2380      	movs	r3, #128	; 0x80
 8001a6e:	00da      	lsls	r2, r3, #3
 8001a70:	4b0f      	ldr	r3, [pc, #60]	; (8001ab0 <GSM_SendCommand_AT+0xfc>)
 8001a72:	2100      	movs	r1, #0
 8001a74:	0018      	movs	r0, r3
 8001a76:	f01b fa45 	bl	801cf04 <memset>
	m_gsm_atc.atc.Recv_Buffer.index = 0;
 8001a7a:	4b0e      	ldr	r3, [pc, #56]	; (8001ab4 <GSM_SendCommand_AT+0x100>)
 8001a7c:	4a0e      	ldr	r2, [pc, #56]	; (8001ab8 <GSM_SendCommand_AT+0x104>)
 8001a7e:	2100      	movs	r1, #0
 8001a80:	5299      	strh	r1, [r3, r2]
	GSM_HwLayer_Reset_Rx_Buffer();
 8001a82:	f000 f887 	bl	8001b94 <GSM_HwLayer_Reset_Rx_Buffer>
	//HAL_UART_Transmit(&huart1, (uint8_t *)AT_Cmd.cmd, strlen(AT_Cmd.cmd), 200);
	GSM_UART_TX((uint8_t *)AT_Cmd.cmd, strlen(AT_Cmd.cmd), 200);
 8001a86:	0022      	movs	r2, r4
 8001a88:	18bb      	adds	r3, r7, r2
 8001a8a:	681c      	ldr	r4, [r3, #0]
 8001a8c:	18bb      	adds	r3, r7, r2
 8001a8e:	681b      	ldr	r3, [r3, #0]
 8001a90:	0018      	movs	r0, r3
 8001a92:	f7fe fb39 	bl	8000108 <strlen>
 8001a96:	0003      	movs	r3, r0
 8001a98:	b29a      	uxth	r2, r3
 8001a9a:	4808      	ldr	r0, [pc, #32]	; (8001abc <GSM_SendCommand_AT+0x108>)
 8001a9c:	23c8      	movs	r3, #200	; 0xc8
 8001a9e:	0021      	movs	r1, r4
 8001aa0:	f002 fc72 	bl	8004388 <HAL_UART_Transmit>

}
 8001aa4:	46bd      	mov	sp, r7
 8001aa6:	bcb0      	pop	{r4, r5, r7}
 8001aa8:	bc08      	pop	{r3}
 8001aaa:	b004      	add	sp, #16
 8001aac:	4718      	bx	r3
 8001aae:	46c0      	nop			; (mov r8, r8)
 8001ab0:	2000021a 	.word	0x2000021a
 8001ab4:	200001fc 	.word	0x200001fc
 8001ab8:	0000041e 	.word	0x0000041e
 8001abc:	20001800 	.word	0x20001800

08001ac0 <sio_read>:
uint32_t sio_read(sio_fd_t fd, u8_t *data, u32_t len)
{
 8001ac0:	b580      	push	{r7, lr}
 8001ac2:	b084      	sub	sp, #16
 8001ac4:	af00      	add	r7, sp, #0
 8001ac6:	60f8      	str	r0, [r7, #12]
 8001ac8:	60b9      	str	r1, [r7, #8]
 8001aca:	607a      	str	r2, [r7, #4]
    return GSM_Hardware_layer_Copy_ppp_Buffer(data, len);
 8001acc:	687a      	ldr	r2, [r7, #4]
 8001ace:	68bb      	ldr	r3, [r7, #8]
 8001ad0:	0011      	movs	r1, r2
 8001ad2:	0018      	movs	r0, r3
 8001ad4:	f000 f8fa 	bl	8001ccc <GSM_Hardware_layer_Copy_ppp_Buffer>
 8001ad8:	0003      	movs	r3, r0
}
 8001ada:	0018      	movs	r0, r3
 8001adc:	46bd      	mov	sp, r7
 8001ade:	b004      	add	sp, #16
 8001ae0:	bd80      	pop	{r7, pc}
	...

08001ae4 <GSM_Hardware_pppos_Polling>:
static uint8_t m_ppp_rx_buffer[512];
void GSM_Hardware_pppos_Polling(void)
{
 8001ae4:	b590      	push	{r4, r7, lr}
 8001ae6:	4c26      	ldr	r4, [pc, #152]	; (8001b80 <GSM_Hardware_pppos_Polling+0x9c>)
 8001ae8:	44a5      	add	sp, r4
 8001aea:	af00      	add	r7, sp, #0
    uint32_t sio_size;
    sys_check_timeouts();
 8001aec:	f010 fcbc 	bl	8012468 <sys_check_timeouts>
	uint8_t buffer[512] = {0};
 8001af0:	4b24      	ldr	r3, [pc, #144]	; (8001b84 <GSM_Hardware_pppos_Polling+0xa0>)
 8001af2:	2282      	movs	r2, #130	; 0x82
 8001af4:	0092      	lsls	r2, r2, #2
 8001af6:	4694      	mov	ip, r2
 8001af8:	44bc      	add	ip, r7
 8001afa:	4463      	add	r3, ip
 8001afc:	2200      	movs	r2, #0
 8001afe:	601a      	str	r2, [r3, #0]
 8001b00:	3304      	adds	r3, #4
 8001b02:	22fe      	movs	r2, #254	; 0xfe
 8001b04:	0052      	lsls	r2, r2, #1
 8001b06:	2100      	movs	r1, #0
 8001b08:	0018      	movs	r0, r3
 8001b0a:	f01b f9fb 	bl	801cf04 <memset>
	uint16_t dataLength = 0;
 8001b0e:	4b1e      	ldr	r3, [pc, #120]	; (8001b88 <GSM_Hardware_pppos_Polling+0xa4>)
 8001b10:	2282      	movs	r2, #130	; 0x82
 8001b12:	0092      	lsls	r2, r2, #2
 8001b14:	4694      	mov	ip, r2
 8001b16:	44bc      	add	ip, r7
 8001b18:	4463      	add	r3, ip
 8001b1a:	2200      	movs	r2, #0
 8001b1c:	801a      	strh	r2, [r3, #0]

	RingBuffer_GetBuffer(buffer, &dataLength, &Rx_Buffer);
 8001b1e:	4a1b      	ldr	r2, [pc, #108]	; (8001b8c <GSM_Hardware_pppos_Polling+0xa8>)
 8001b20:	1cb9      	adds	r1, r7, #2
 8001b22:	1d3b      	adds	r3, r7, #4
 8001b24:	0018      	movs	r0, r3
 8001b26:	f001 f906 	bl	8002d36 <RingBuffer_GetBuffer>
	GSM_HwLayer_Fill_Rx_Buffer(buffer, dataLength);
 8001b2a:	4b17      	ldr	r3, [pc, #92]	; (8001b88 <GSM_Hardware_pppos_Polling+0xa4>)
 8001b2c:	2282      	movs	r2, #130	; 0x82
 8001b2e:	0092      	lsls	r2, r2, #2
 8001b30:	4694      	mov	ip, r2
 8001b32:	44bc      	add	ip, r7
 8001b34:	4463      	add	r3, ip
 8001b36:	881b      	ldrh	r3, [r3, #0]
 8001b38:	001a      	movs	r2, r3
 8001b3a:	1d3b      	adds	r3, r7, #4
 8001b3c:	0011      	movs	r1, r2
 8001b3e:	0018      	movs	r0, r3
 8001b40:	f000 f84e 	bl	8001be0 <GSM_HwLayer_Fill_Rx_Buffer>

    sio_size = sio_read(0, m_ppp_rx_buffer, 512);
 8001b44:	2380      	movs	r3, #128	; 0x80
 8001b46:	009a      	lsls	r2, r3, #2
 8001b48:	4b11      	ldr	r3, [pc, #68]	; (8001b90 <GSM_Hardware_pppos_Polling+0xac>)
 8001b4a:	0019      	movs	r1, r3
 8001b4c:	2000      	movs	r0, #0
 8001b4e:	f7ff ffb7 	bl	8001ac0 <sio_read>
 8001b52:	0003      	movs	r3, r0
 8001b54:	2481      	movs	r4, #129	; 0x81
 8001b56:	00a4      	lsls	r4, r4, #2
 8001b58:	193a      	adds	r2, r7, r4
 8001b5a:	6013      	str	r3, [r2, #0]
	if(sio_size > 0)
 8001b5c:	193b      	adds	r3, r7, r4
 8001b5e:	681b      	ldr	r3, [r3, #0]
 8001b60:	2b00      	cmp	r3, #0
 8001b62:	d007      	beq.n	8001b74 <GSM_Hardware_pppos_Polling+0x90>
	{
		// Bypass data into ppp stack
		pppos_input(gsm_data_layer_get_ppp_control_block(), m_ppp_rx_buffer, sio_size);
 8001b64:	f7ff f9ee 	bl	8000f44 <gsm_data_layer_get_ppp_control_block>
 8001b68:	193b      	adds	r3, r7, r4
 8001b6a:	681a      	ldr	r2, [r3, #0]
 8001b6c:	4b08      	ldr	r3, [pc, #32]	; (8001b90 <GSM_Hardware_pppos_Polling+0xac>)
 8001b6e:	0019      	movs	r1, r3
 8001b70:	f018 fed8 	bl	801a924 <pppos_input>
	}

}
 8001b74:	46c0      	nop			; (mov r8, r8)
 8001b76:	46bd      	mov	sp, r7
 8001b78:	2383      	movs	r3, #131	; 0x83
 8001b7a:	009b      	lsls	r3, r3, #2
 8001b7c:	449d      	add	sp, r3
 8001b7e:	bd90      	pop	{r4, r7, pc}
 8001b80:	fffffdf4 	.word	0xfffffdf4
 8001b84:	fffffdfc 	.word	0xfffffdfc
 8001b88:	fffffdfa 	.word	0xfffffdfa
 8001b8c:	20001898 	.word	0x20001898
 8001b90:	20000a24 	.word	0x20000a24

08001b94 <GSM_HwLayer_Reset_Rx_Buffer>:
void GSM_HwLayer_Reset_Rx_Buffer(void)
{
 8001b94:	b580      	push	{r7, lr}
 8001b96:	af00      	add	r7, sp, #0
	memset(&m_gsm_atc.atc.Recv_Buffer.u8Buffer, 0, sizeof(m_gsm_atc.atc.Recv_Buffer.u8Buffer));
 8001b98:	2380      	movs	r3, #128	; 0x80
 8001b9a:	00da      	lsls	r2, r3, #3
 8001b9c:	4b0a      	ldr	r3, [pc, #40]	; (8001bc8 <GSM_HwLayer_Reset_Rx_Buffer+0x34>)
 8001b9e:	2100      	movs	r1, #0
 8001ba0:	0018      	movs	r0, r3
 8001ba2:	f01b f9af 	bl	801cf04 <memset>
	m_gsm_atc.atc.Recv_Buffer.index = 0;
 8001ba6:	4b09      	ldr	r3, [pc, #36]	; (8001bcc <GSM_HwLayer_Reset_Rx_Buffer+0x38>)
 8001ba8:	4a09      	ldr	r2, [pc, #36]	; (8001bd0 <GSM_HwLayer_Reset_Rx_Buffer+0x3c>)
 8001baa:	2100      	movs	r1, #0
 8001bac:	5299      	strh	r1, [r3, r2]
	memset(&m_gsm_modem_buffer, 0, sizeof(m_gsm_modem_buffer));
 8001bae:	4a09      	ldr	r2, [pc, #36]	; (8001bd4 <GSM_HwLayer_Reset_Rx_Buffer+0x40>)
 8001bb0:	4b09      	ldr	r3, [pc, #36]	; (8001bd8 <GSM_HwLayer_Reset_Rx_Buffer+0x44>)
 8001bb2:	2100      	movs	r1, #0
 8001bb4:	0018      	movs	r0, r3
 8001bb6:	f01b f9a5 	bl	801cf04 <memset>
	Erase_RingBuffer(&Rx_Buffer);
 8001bba:	4b08      	ldr	r3, [pc, #32]	; (8001bdc <GSM_HwLayer_Reset_Rx_Buffer+0x48>)
 8001bbc:	0018      	movs	r0, r3
 8001bbe:	f001 f906 	bl	8002dce <Erase_RingBuffer>
}
 8001bc2:	46c0      	nop			; (mov r8, r8)
 8001bc4:	46bd      	mov	sp, r7
 8001bc6:	bd80      	pop	{r7, pc}
 8001bc8:	2000021a 	.word	0x2000021a
 8001bcc:	200001fc 	.word	0x200001fc
 8001bd0:	0000041e 	.word	0x0000041e
 8001bd4:	00000404 	.word	0x00000404
 8001bd8:	20000620 	.word	0x20000620
 8001bdc:	20001898 	.word	0x20001898

08001be0 <GSM_HwLayer_Fill_Rx_Buffer>:
void GSM_HwLayer_Fill_Rx_Buffer(uint8_t* data, uint32_t length)
{
 8001be0:	b580      	push	{r7, lr}
 8001be2:	b084      	sub	sp, #16
 8001be4:	af00      	add	r7, sp, #0
 8001be6:	6078      	str	r0, [r7, #4]
 8001be8:	6039      	str	r1, [r7, #0]
	if(length)
 8001bea:	683b      	ldr	r3, [r7, #0]
 8001bec:	2b00      	cmp	r3, #0
 8001bee:	d060      	beq.n	8001cb2 <GSM_HwLayer_Fill_Rx_Buffer+0xd2>
	{
		// Device do not enter AT mode =>> bypass data into PPP stack
		if(gsm_is_in_ppp_mode())
 8001bf0:	f7ff fb8e 	bl	8001310 <gsm_is_in_ppp_mode>
 8001bf4:	1e03      	subs	r3, r0, #0
 8001bf6:	d028      	beq.n	8001c4a <GSM_HwLayer_Fill_Rx_Buffer+0x6a>
		{
			for(int CountByte = 0; CountByte < length; CountByte ++)
 8001bf8:	2300      	movs	r3, #0
 8001bfa:	60fb      	str	r3, [r7, #12]
 8001bfc:	e010      	b.n	8001c20 <GSM_HwLayer_Fill_Rx_Buffer+0x40>
			{
				m_gsm_modem_buffer.u8Buffer[m_gsm_modem_buffer.idx_in++] = data[CountByte];
 8001bfe:	68fb      	ldr	r3, [r7, #12]
 8001c00:	687a      	ldr	r2, [r7, #4]
 8001c02:	18d2      	adds	r2, r2, r3
 8001c04:	4b2c      	ldr	r3, [pc, #176]	; (8001cb8 <GSM_HwLayer_Fill_Rx_Buffer+0xd8>)
 8001c06:	881b      	ldrh	r3, [r3, #0]
 8001c08:	1c59      	adds	r1, r3, #1
 8001c0a:	b288      	uxth	r0, r1
 8001c0c:	492a      	ldr	r1, [pc, #168]	; (8001cb8 <GSM_HwLayer_Fill_Rx_Buffer+0xd8>)
 8001c0e:	8008      	strh	r0, [r1, #0]
 8001c10:	0019      	movs	r1, r3
 8001c12:	7812      	ldrb	r2, [r2, #0]
 8001c14:	4b28      	ldr	r3, [pc, #160]	; (8001cb8 <GSM_HwLayer_Fill_Rx_Buffer+0xd8>)
 8001c16:	185b      	adds	r3, r3, r1
 8001c18:	711a      	strb	r2, [r3, #4]
			for(int CountByte = 0; CountByte < length; CountByte ++)
 8001c1a:	68fb      	ldr	r3, [r7, #12]
 8001c1c:	3301      	adds	r3, #1
 8001c1e:	60fb      	str	r3, [r7, #12]
 8001c20:	68fb      	ldr	r3, [r7, #12]
 8001c22:	683a      	ldr	r2, [r7, #0]
 8001c24:	429a      	cmp	r2, r3
 8001c26:	d8ea      	bhi.n	8001bfe <GSM_HwLayer_Fill_Rx_Buffer+0x1e>
			}
			if(m_gsm_modem_buffer.idx_in >= GSM_PPP_MODEM_BUFFER_SIZE)
 8001c28:	4b23      	ldr	r3, [pc, #140]	; (8001cb8 <GSM_HwLayer_Fill_Rx_Buffer+0xd8>)
 8001c2a:	881a      	ldrh	r2, [r3, #0]
 8001c2c:	2380      	movs	r3, #128	; 0x80
 8001c2e:	00db      	lsls	r3, r3, #3
 8001c30:	429a      	cmp	r2, r3
 8001c32:	d302      	bcc.n	8001c3a <GSM_HwLayer_Fill_Rx_Buffer+0x5a>
			{
				m_gsm_modem_buffer.idx_in = 0;
 8001c34:	4b20      	ldr	r3, [pc, #128]	; (8001cb8 <GSM_HwLayer_Fill_Rx_Buffer+0xd8>)
 8001c36:	2200      	movs	r2, #0
 8001c38:	801a      	strh	r2, [r3, #0]
			}
			m_gsm_modem_buffer.u8Buffer[m_gsm_modem_buffer.idx_in] = 0;
 8001c3a:	4b1f      	ldr	r3, [pc, #124]	; (8001cb8 <GSM_HwLayer_Fill_Rx_Buffer+0xd8>)
 8001c3c:	881b      	ldrh	r3, [r3, #0]
 8001c3e:	001a      	movs	r2, r3
 8001c40:	4b1d      	ldr	r3, [pc, #116]	; (8001cb8 <GSM_HwLayer_Fill_Rx_Buffer+0xd8>)
 8001c42:	189b      	adds	r3, r3, r2
 8001c44:	2200      	movs	r2, #0
 8001c46:	711a      	strb	r2, [r3, #4]
 8001c48:	e033      	b.n	8001cb2 <GSM_HwLayer_Fill_Rx_Buffer+0xd2>
		}
		else
		{
			for(int CountByte = 0; CountByte < length; CountByte ++)
 8001c4a:	2300      	movs	r3, #0
 8001c4c:	60bb      	str	r3, [r7, #8]
 8001c4e:	e02c      	b.n	8001caa <GSM_HwLayer_Fill_Rx_Buffer+0xca>
			{
				m_gsm_atc.atc.Recv_Buffer.u8Buffer[m_gsm_atc.atc.Recv_Buffer.index] = data[CountByte];
 8001c50:	68bb      	ldr	r3, [r7, #8]
 8001c52:	687a      	ldr	r2, [r7, #4]
 8001c54:	18d3      	adds	r3, r2, r3
 8001c56:	4a19      	ldr	r2, [pc, #100]	; (8001cbc <GSM_HwLayer_Fill_Rx_Buffer+0xdc>)
 8001c58:	4919      	ldr	r1, [pc, #100]	; (8001cc0 <GSM_HwLayer_Fill_Rx_Buffer+0xe0>)
 8001c5a:	5a52      	ldrh	r2, [r2, r1]
 8001c5c:	0011      	movs	r1, r2
 8001c5e:	781a      	ldrb	r2, [r3, #0]
 8001c60:	4b16      	ldr	r3, [pc, #88]	; (8001cbc <GSM_HwLayer_Fill_Rx_Buffer+0xdc>)
 8001c62:	185b      	adds	r3, r3, r1
 8001c64:	779a      	strb	r2, [r3, #30]
				m_gsm_atc.atc.Recv_Buffer.index ++;
 8001c66:	4b15      	ldr	r3, [pc, #84]	; (8001cbc <GSM_HwLayer_Fill_Rx_Buffer+0xdc>)
 8001c68:	4a15      	ldr	r2, [pc, #84]	; (8001cc0 <GSM_HwLayer_Fill_Rx_Buffer+0xe0>)
 8001c6a:	5a9b      	ldrh	r3, [r3, r2]
 8001c6c:	3301      	adds	r3, #1
 8001c6e:	b299      	uxth	r1, r3
 8001c70:	4b12      	ldr	r3, [pc, #72]	; (8001cbc <GSM_HwLayer_Fill_Rx_Buffer+0xdc>)
 8001c72:	4a13      	ldr	r2, [pc, #76]	; (8001cc0 <GSM_HwLayer_Fill_Rx_Buffer+0xe0>)
 8001c74:	5299      	strh	r1, [r3, r2]
				if(m_gsm_atc.atc.Recv_Buffer.index >= GSM_ATC_BUFFER_SIZE)
 8001c76:	4b11      	ldr	r3, [pc, #68]	; (8001cbc <GSM_HwLayer_Fill_Rx_Buffer+0xdc>)
 8001c78:	4a11      	ldr	r2, [pc, #68]	; (8001cc0 <GSM_HwLayer_Fill_Rx_Buffer+0xe0>)
 8001c7a:	5a9a      	ldrh	r2, [r3, r2]
 8001c7c:	2380      	movs	r3, #128	; 0x80
 8001c7e:	00db      	lsls	r3, r3, #3
 8001c80:	429a      	cmp	r2, r3
 8001c82:	d30f      	bcc.n	8001ca4 <GSM_HwLayer_Fill_Rx_Buffer+0xc4>
				{
					DEBUG_ERROR("GSM ATC RX Buffer out of range!\r\n");
 8001c84:	f01b f8c8 	bl	801ce18 <sys_get_tick_ms>
 8001c88:	0001      	movs	r1, r0
 8001c8a:	4a0e      	ldr	r2, [pc, #56]	; (8001cc4 <GSM_HwLayer_Fill_Rx_Buffer+0xe4>)
 8001c8c:	4b0e      	ldr	r3, [pc, #56]	; (8001cc8 <GSM_HwLayer_Fill_Rx_Buffer+0xe8>)
 8001c8e:	0018      	movs	r0, r3
 8001c90:	f000 ff9a 	bl	8002bc8 <app_debug_rtt_raw>
                    m_gsm_atc.atc.Recv_Buffer.index = 0;
 8001c94:	4b09      	ldr	r3, [pc, #36]	; (8001cbc <GSM_HwLayer_Fill_Rx_Buffer+0xdc>)
 8001c96:	4a0a      	ldr	r2, [pc, #40]	; (8001cc0 <GSM_HwLayer_Fill_Rx_Buffer+0xe0>)
 8001c98:	2100      	movs	r1, #0
 8001c9a:	5299      	strh	r1, [r3, r2]
                    m_gsm_atc.atc.Recv_Buffer.u8Buffer[0] = 0;
 8001c9c:	4b07      	ldr	r3, [pc, #28]	; (8001cbc <GSM_HwLayer_Fill_Rx_Buffer+0xdc>)
 8001c9e:	2200      	movs	r2, #0
 8001ca0:	779a      	strb	r2, [r3, #30]
                    return;
 8001ca2:	e006      	b.n	8001cb2 <GSM_HwLayer_Fill_Rx_Buffer+0xd2>
			for(int CountByte = 0; CountByte < length; CountByte ++)
 8001ca4:	68bb      	ldr	r3, [r7, #8]
 8001ca6:	3301      	adds	r3, #1
 8001ca8:	60bb      	str	r3, [r7, #8]
 8001caa:	68bb      	ldr	r3, [r7, #8]
 8001cac:	683a      	ldr	r2, [r7, #0]
 8001cae:	429a      	cmp	r2, r3
 8001cb0:	d8ce      	bhi.n	8001c50 <GSM_HwLayer_Fill_Rx_Buffer+0x70>
				}
			}
		}
	}
}
 8001cb2:	46bd      	mov	sp, r7
 8001cb4:	b004      	add	sp, #16
 8001cb6:	bd80      	pop	{r7, pc}
 8001cb8:	20000620 	.word	0x20000620
 8001cbc:	200001fc 	.word	0x200001fc
 8001cc0:	0000041e 	.word	0x0000041e
 8001cc4:	0801e4f0 	.word	0x0801e4f0
 8001cc8:	0801e5f8 	.word	0x0801e5f8

08001ccc <GSM_Hardware_layer_Copy_ppp_Buffer>:
uint32_t GSM_Hardware_layer_Copy_ppp_Buffer(uint8_t* data, uint32_t length)
{
 8001ccc:	b580      	push	{r7, lr}
 8001cce:	b084      	sub	sp, #16
 8001cd0:	af00      	add	r7, sp, #0
 8001cd2:	6078      	str	r0, [r7, #4]
 8001cd4:	6039      	str	r1, [r7, #0]
	int CountByte = 0;
 8001cd6:	2300      	movs	r3, #0
 8001cd8:	60fb      	str	r3, [r7, #12]
	for(CountByte = 0; CountByte < length; CountByte++)
 8001cda:	2300      	movs	r3, #0
 8001cdc:	60fb      	str	r3, [r7, #12]
 8001cde:	e023      	b.n	8001d28 <GSM_Hardware_layer_Copy_ppp_Buffer+0x5c>
	{
		if(m_gsm_modem_buffer.idx_out == m_gsm_modem_buffer.idx_in)
 8001ce0:	4b16      	ldr	r3, [pc, #88]	; (8001d3c <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001ce2:	885a      	ldrh	r2, [r3, #2]
 8001ce4:	4b15      	ldr	r3, [pc, #84]	; (8001d3c <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001ce6:	881b      	ldrh	r3, [r3, #0]
 8001ce8:	429a      	cmp	r2, r3
 8001cea:	d101      	bne.n	8001cf0 <GSM_Hardware_layer_Copy_ppp_Buffer+0x24>
		{
			return CountByte; // Da quet het Buffer Modem
 8001cec:	68fb      	ldr	r3, [r7, #12]
 8001cee:	e020      	b.n	8001d32 <GSM_Hardware_layer_Copy_ppp_Buffer+0x66>
		}
		data[CountByte] = m_gsm_modem_buffer.u8Buffer[m_gsm_modem_buffer.idx_out];
 8001cf0:	4b12      	ldr	r3, [pc, #72]	; (8001d3c <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001cf2:	885b      	ldrh	r3, [r3, #2]
 8001cf4:	0019      	movs	r1, r3
 8001cf6:	68fb      	ldr	r3, [r7, #12]
 8001cf8:	687a      	ldr	r2, [r7, #4]
 8001cfa:	18d3      	adds	r3, r2, r3
 8001cfc:	4a0f      	ldr	r2, [pc, #60]	; (8001d3c <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001cfe:	1852      	adds	r2, r2, r1
 8001d00:	7912      	ldrb	r2, [r2, #4]
 8001d02:	701a      	strb	r2, [r3, #0]
		m_gsm_modem_buffer.idx_out ++;
 8001d04:	4b0d      	ldr	r3, [pc, #52]	; (8001d3c <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001d06:	885b      	ldrh	r3, [r3, #2]
 8001d08:	3301      	adds	r3, #1
 8001d0a:	b29a      	uxth	r2, r3
 8001d0c:	4b0b      	ldr	r3, [pc, #44]	; (8001d3c <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001d0e:	805a      	strh	r2, [r3, #2]
		if(m_gsm_modem_buffer.idx_out >= GSM_PPP_MODEM_BUFFER_SIZE)
 8001d10:	4b0a      	ldr	r3, [pc, #40]	; (8001d3c <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001d12:	885a      	ldrh	r2, [r3, #2]
 8001d14:	2380      	movs	r3, #128	; 0x80
 8001d16:	00db      	lsls	r3, r3, #3
 8001d18:	429a      	cmp	r2, r3
 8001d1a:	d302      	bcc.n	8001d22 <GSM_Hardware_layer_Copy_ppp_Buffer+0x56>
		{
			m_gsm_modem_buffer.idx_out = 0;
 8001d1c:	4b07      	ldr	r3, [pc, #28]	; (8001d3c <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001d1e:	2200      	movs	r2, #0
 8001d20:	805a      	strh	r2, [r3, #2]
	for(CountByte = 0; CountByte < length; CountByte++)
 8001d22:	68fb      	ldr	r3, [r7, #12]
 8001d24:	3301      	adds	r3, #1
 8001d26:	60fb      	str	r3, [r7, #12]
 8001d28:	68fb      	ldr	r3, [r7, #12]
 8001d2a:	683a      	ldr	r2, [r7, #0]
 8001d2c:	429a      	cmp	r2, r3
 8001d2e:	d8d7      	bhi.n	8001ce0 <GSM_Hardware_layer_Copy_ppp_Buffer+0x14>
		}
	}
	return CountByte;
 8001d30:	68fb      	ldr	r3, [r7, #12]
}
 8001d32:	0018      	movs	r0, r3
 8001d34:	46bd      	mov	sp, r7
 8001d36:	b004      	add	sp, #16
 8001d38:	bd80      	pop	{r7, pc}
 8001d3a:	46c0      	nop			; (mov r8, r8)
 8001d3c:	20000620 	.word	0x20000620

08001d40 <GSM_File_Handler_Init>:
    // Upload file via COM Port
    {Download_File_AT_Command, "+QFTPGET: ", "", "", "", 7000, 3, GSM_File_Download_Seq},
};

void GSM_File_Handler_Init(FTP_Config_TypDef* cfg)
{
 8001d40:	b5b0      	push	{r4, r5, r7, lr}
 8001d42:	b086      	sub	sp, #24
 8001d44:	af04      	add	r7, sp, #16
 8001d46:	6078      	str	r0, [r7, #4]
    memcpy(&File_Handler_Config, cfg, sizeof(FTP_Config_TypDef));
 8001d48:	6879      	ldr	r1, [r7, #4]
 8001d4a:	4b16      	ldr	r3, [pc, #88]	; (8001da4 <GSM_File_Handler_Init+0x64>)
 8001d4c:	2210      	movs	r2, #16
 8001d4e:	0018      	movs	r0, r3
 8001d50:	f01b f8bc 	bl	801cecc <memcpy>
    snprintf(Account_Info_AT_Command, sizeof(Account_Info_AT_Command), "%s%s%s%s%s",
 8001d54:	4b13      	ldr	r3, [pc, #76]	; (8001da4 <GSM_File_Handler_Init+0x64>)
 8001d56:	685a      	ldr	r2, [r3, #4]
 8001d58:	4b12      	ldr	r3, [pc, #72]	; (8001da4 <GSM_File_Handler_Init+0x64>)
 8001d5a:	689b      	ldr	r3, [r3, #8]
 8001d5c:	4d12      	ldr	r5, [pc, #72]	; (8001da8 <GSM_File_Handler_Init+0x68>)
 8001d5e:	4c13      	ldr	r4, [pc, #76]	; (8001dac <GSM_File_Handler_Init+0x6c>)
 8001d60:	4813      	ldr	r0, [pc, #76]	; (8001db0 <GSM_File_Handler_Init+0x70>)
 8001d62:	4914      	ldr	r1, [pc, #80]	; (8001db4 <GSM_File_Handler_Init+0x74>)
 8001d64:	9103      	str	r1, [sp, #12]
 8001d66:	9302      	str	r3, [sp, #8]
 8001d68:	4b13      	ldr	r3, [pc, #76]	; (8001db8 <GSM_File_Handler_Init+0x78>)
 8001d6a:	9301      	str	r3, [sp, #4]
 8001d6c:	9200      	str	r2, [sp, #0]
 8001d6e:	002b      	movs	r3, r5
 8001d70:	0022      	movs	r2, r4
 8001d72:	2146      	movs	r1, #70	; 0x46
 8001d74:	f01b f988 	bl	801d088 <sniprintf>
                                                                    "AT+QFTPCFG=\"account\",\"",
                                                                    File_Handler_Config.Username,
                                                                    "\",\"",
                                                                    File_Handler_Config.Password,
                                                                    "\"\r\n");
    snprintf(FTP_Server_Login_Info_AT_Command, sizeof(FTP_Server_Login_Info_AT_Command), "%s%s%s%lu%s",
 8001d78:	4b0a      	ldr	r3, [pc, #40]	; (8001da4 <GSM_File_Handler_Init+0x64>)
 8001d7a:	681a      	ldr	r2, [r3, #0]
 8001d7c:	4b09      	ldr	r3, [pc, #36]	; (8001da4 <GSM_File_Handler_Init+0x64>)
 8001d7e:	68db      	ldr	r3, [r3, #12]
 8001d80:	4d0e      	ldr	r5, [pc, #56]	; (8001dbc <GSM_File_Handler_Init+0x7c>)
 8001d82:	4c0f      	ldr	r4, [pc, #60]	; (8001dc0 <GSM_File_Handler_Init+0x80>)
 8001d84:	480f      	ldr	r0, [pc, #60]	; (8001dc4 <GSM_File_Handler_Init+0x84>)
 8001d86:	4910      	ldr	r1, [pc, #64]	; (8001dc8 <GSM_File_Handler_Init+0x88>)
 8001d88:	9103      	str	r1, [sp, #12]
 8001d8a:	9302      	str	r3, [sp, #8]
 8001d8c:	4b0f      	ldr	r3, [pc, #60]	; (8001dcc <GSM_File_Handler_Init+0x8c>)
 8001d8e:	9301      	str	r3, [sp, #4]
 8001d90:	9200      	str	r2, [sp, #0]
 8001d92:	002b      	movs	r3, r5
 8001d94:	0022      	movs	r2, r4
 8001d96:	2146      	movs	r1, #70	; 0x46
 8001d98:	f01b f976 	bl	801d088 <sniprintf>
                                                                    "AT+QFTPOPEN=\"",
                                                                    File_Handler_Config.Hostname,
                                                                    "\",",
                                                                    File_Handler_Config.Port,
                                                                    "\r\n");
}
 8001d9c:	46c0      	nop			; (mov r8, r8)
 8001d9e:	46bd      	mov	sp, r7
 8001da0:	b002      	add	sp, #8
 8001da2:	bdb0      	pop	{r4, r5, r7, pc}
 8001da4:	20000e10 	.word	0x20000e10
 8001da8:	0801e794 	.word	0x0801e794
 8001dac:	0801e7ac 	.word	0x0801e7ac
 8001db0:	20000c2c 	.word	0x20000c2c
 8001db4:	0801e7b8 	.word	0x0801e7b8
 8001db8:	0801e7bc 	.word	0x0801e7bc
 8001dbc:	0801e7c0 	.word	0x0801e7c0
 8001dc0:	0801e7d0 	.word	0x0801e7d0
 8001dc4:	20000c74 	.word	0x20000c74
 8001dc8:	0801e7dc 	.word	0x0801e7dc
 8001dcc:	0801e7e0 	.word	0x0801e7e0

08001dd0 <GSM_FileSend_Handler>:
// Xu ly File Send ( Neu File chua ton tai tren server-> tao moi, neu da ton tai -> append)
void GSM_FileSend_Handler(GSM_Response_Event_TypDef event, void *Resp_Buffer)
{
 8001dd0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001dd2:	b095      	sub	sp, #84	; 0x54
 8001dd4:	af06      	add	r7, sp, #24
 8001dd6:	0002      	movs	r2, r0
 8001dd8:	6039      	str	r1, [r7, #0]
 8001dda:	1dfb      	adds	r3, r7, #7
 8001ddc:	701a      	strb	r2, [r3, #0]
    static uint8_t step = 0;
    static uint8_t retry_count = 0;
    switch (step)
 8001dde:	4b8e      	ldr	r3, [pc, #568]	; (8002018 <GSM_FileSend_Handler+0x248>)
 8001de0:	781b      	ldrb	r3, [r3, #0]
 8001de2:	2b00      	cmp	r3, #0
 8001de4:	d003      	beq.n	8001dee <GSM_FileSend_Handler+0x1e>
 8001de6:	2b01      	cmp	r3, #1
 8001de8:	d100      	bne.n	8001dec <GSM_FileSend_Handler+0x1c>
 8001dea:	e086      	b.n	8001efa <GSM_FileSend_Handler+0x12a>
        {
            GSM_Manager_ChangeState(GSM_STATE_RESET);
        }
        break;
    default:
        break;
 8001dec:	e110      	b.n	8002010 <GSM_FileSend_Handler+0x240>
        if(event != GSM_EVENT_OK)
 8001dee:	1dfb      	adds	r3, r7, #7
 8001df0:	781b      	ldrb	r3, [r3, #0]
 8001df2:	2b00      	cmp	r3, #0
 8001df4:	d007      	beq.n	8001e06 <GSM_FileSend_Handler+0x36>
            GSM_File_Transfer_Seq(event, &Resp_Buffer);
 8001df6:	003a      	movs	r2, r7
 8001df8:	1dfb      	adds	r3, r7, #7
 8001dfa:	781b      	ldrb	r3, [r3, #0]
 8001dfc:	0011      	movs	r1, r2
 8001dfe:	0018      	movs	r0, r3
 8001e00:	f000 f9e6 	bl	80021d0 <GSM_File_Transfer_Seq>
        break;
 8001e04:	e104      	b.n	8002010 <GSM_FileSend_Handler+0x240>
            if(gsm_utilities_is_file_exist(FileSend_Info.File[FileSend_Info.FileID].Name, (char*)Resp_Buffer))
 8001e06:	4b85      	ldr	r3, [pc, #532]	; (800201c <GSM_FileSend_Handler+0x24c>)
 8001e08:	22c9      	movs	r2, #201	; 0xc9
 8001e0a:	5c9b      	ldrb	r3, [r3, r2]
 8001e0c:	0019      	movs	r1, r3
 8001e0e:	4a83      	ldr	r2, [pc, #524]	; (800201c <GSM_FileSend_Handler+0x24c>)
 8001e10:	000b      	movs	r3, r1
 8001e12:	009b      	lsls	r3, r3, #2
 8001e14:	185b      	adds	r3, r3, r1
 8001e16:	009b      	lsls	r3, r3, #2
 8001e18:	18d3      	adds	r3, r2, r3
 8001e1a:	3308      	adds	r3, #8
 8001e1c:	681b      	ldr	r3, [r3, #0]
 8001e1e:	683a      	ldr	r2, [r7, #0]
 8001e20:	0011      	movs	r1, r2
 8001e22:	0018      	movs	r0, r3
 8001e24:	f000 fcdf 	bl	80027e6 <gsm_utilities_is_file_exist>
 8001e28:	1e03      	subs	r3, r0, #0
 8001e2a:	d01e      	beq.n	8001e6a <GSM_FileSend_Handler+0x9a>
                GSM_ATCommand_Table_TypDef AT_Command = 
 8001e2c:	2108      	movs	r1, #8
 8001e2e:	187b      	adds	r3, r7, r1
 8001e30:	4a7b      	ldr	r2, [pc, #492]	; (8002020 <GSM_FileSend_Handler+0x250>)
 8001e32:	ca31      	ldmia	r2!, {r0, r4, r5}
 8001e34:	c331      	stmia	r3!, {r0, r4, r5}
 8001e36:	ca31      	ldmia	r2!, {r0, r4, r5}
 8001e38:	c331      	stmia	r3!, {r0, r4, r5}
 8001e3a:	ca11      	ldmia	r2!, {r0, r4}
 8001e3c:	c311      	stmia	r3!, {r0, r4}
                GSM_SendCommand_AT(AT_Command);
 8001e3e:	187b      	adds	r3, r7, r1
 8001e40:	466a      	mov	r2, sp
 8001e42:	0011      	movs	r1, r2
 8001e44:	001a      	movs	r2, r3
 8001e46:	3210      	adds	r2, #16
 8001e48:	ca31      	ldmia	r2!, {r0, r4, r5}
 8001e4a:	c131      	stmia	r1!, {r0, r4, r5}
 8001e4c:	6812      	ldr	r2, [r2, #0]
 8001e4e:	600a      	str	r2, [r1, #0]
 8001e50:	6818      	ldr	r0, [r3, #0]
 8001e52:	6859      	ldr	r1, [r3, #4]
 8001e54:	689a      	ldr	r2, [r3, #8]
 8001e56:	68db      	ldr	r3, [r3, #12]
 8001e58:	f7ff fdac 	bl	80019b4 <GSM_SendCommand_AT>
                step++;
 8001e5c:	4b6e      	ldr	r3, [pc, #440]	; (8002018 <GSM_FileSend_Handler+0x248>)
 8001e5e:	781b      	ldrb	r3, [r3, #0]
 8001e60:	3301      	adds	r3, #1
 8001e62:	b2da      	uxtb	r2, r3
 8001e64:	4b6c      	ldr	r3, [pc, #432]	; (8002018 <GSM_FileSend_Handler+0x248>)
 8001e66:	701a      	strb	r2, [r3, #0]
        break;
 8001e68:	e0d2      	b.n	8002010 <GSM_FileSend_Handler+0x240>
                if(++retry_count >= 3)
 8001e6a:	4b6e      	ldr	r3, [pc, #440]	; (8002024 <GSM_FileSend_Handler+0x254>)
 8001e6c:	781b      	ldrb	r3, [r3, #0]
 8001e6e:	3301      	adds	r3, #1
 8001e70:	b2da      	uxtb	r2, r3
 8001e72:	4b6c      	ldr	r3, [pc, #432]	; (8002024 <GSM_FileSend_Handler+0x254>)
 8001e74:	701a      	strb	r2, [r3, #0]
 8001e76:	4b6b      	ldr	r3, [pc, #428]	; (8002024 <GSM_FileSend_Handler+0x254>)
 8001e78:	781b      	ldrb	r3, [r3, #0]
 8001e7a:	2b02      	cmp	r3, #2
 8001e7c:	d92a      	bls.n	8001ed4 <GSM_FileSend_Handler+0x104>
                    retry_count = 0;
 8001e7e:	4b69      	ldr	r3, [pc, #420]	; (8002024 <GSM_FileSend_Handler+0x254>)
 8001e80:	2200      	movs	r2, #0
 8001e82:	701a      	strb	r2, [r3, #0]
                    FileSend_Info.File[FileSend_Info.FileID].Index = 0;
 8001e84:	4b65      	ldr	r3, [pc, #404]	; (800201c <GSM_FileSend_Handler+0x24c>)
 8001e86:	22c9      	movs	r2, #201	; 0xc9
 8001e88:	5c9b      	ldrb	r3, [r3, r2]
 8001e8a:	0019      	movs	r1, r3
 8001e8c:	4a63      	ldr	r2, [pc, #396]	; (800201c <GSM_FileSend_Handler+0x24c>)
 8001e8e:	000b      	movs	r3, r1
 8001e90:	009b      	lsls	r3, r3, #2
 8001e92:	185b      	adds	r3, r3, r1
 8001e94:	009b      	lsls	r3, r3, #2
 8001e96:	18d3      	adds	r3, r2, r3
 8001e98:	3310      	adds	r3, #16
 8001e9a:	2200      	movs	r2, #0
 8001e9c:	801a      	strh	r2, [r3, #0]
                    DEBUG_INFO("File does not exist -> Create new file: \"%s\"\r\n",
 8001e9e:	f01a ffbb 	bl	801ce18 <sys_get_tick_ms>
 8001ea2:	0001      	movs	r1, r0
 8001ea4:	4b5d      	ldr	r3, [pc, #372]	; (800201c <GSM_FileSend_Handler+0x24c>)
 8001ea6:	22c9      	movs	r2, #201	; 0xc9
 8001ea8:	5c9b      	ldrb	r3, [r3, r2]
 8001eaa:	0018      	movs	r0, r3
 8001eac:	4a5b      	ldr	r2, [pc, #364]	; (800201c <GSM_FileSend_Handler+0x24c>)
 8001eae:	0003      	movs	r3, r0
 8001eb0:	009b      	lsls	r3, r3, #2
 8001eb2:	181b      	adds	r3, r3, r0
 8001eb4:	009b      	lsls	r3, r3, #2
 8001eb6:	18d3      	adds	r3, r2, r3
 8001eb8:	3308      	adds	r3, #8
 8001eba:	681b      	ldr	r3, [r3, #0]
 8001ebc:	4a5a      	ldr	r2, [pc, #360]	; (8002028 <GSM_FileSend_Handler+0x258>)
 8001ebe:	485b      	ldr	r0, [pc, #364]	; (800202c <GSM_FileSend_Handler+0x25c>)
 8001ec0:	f000 fe82 	bl	8002bc8 <app_debug_rtt_raw>
                    GSM_File_Transfer_Seq(event, &Resp_Buffer);
 8001ec4:	003a      	movs	r2, r7
 8001ec6:	1dfb      	adds	r3, r7, #7
 8001ec8:	781b      	ldrb	r3, [r3, #0]
 8001eca:	0011      	movs	r1, r2
 8001ecc:	0018      	movs	r0, r3
 8001ece:	f000 f97f 	bl	80021d0 <GSM_File_Transfer_Seq>
        break;
 8001ed2:	e09d      	b.n	8002010 <GSM_FileSend_Handler+0x240>
                    File_Handler_Manager.step = 1;
 8001ed4:	4b56      	ldr	r3, [pc, #344]	; (8002030 <GSM_FileSend_Handler+0x260>)
 8001ed6:	2201      	movs	r2, #1
 8001ed8:	705a      	strb	r2, [r3, #1]
                    GSM_SendCommand_AT(ATC_Table_File_Tranfer[0]);
 8001eda:	4b56      	ldr	r3, [pc, #344]	; (8002034 <GSM_FileSend_Handler+0x264>)
 8001edc:	466a      	mov	r2, sp
 8001ede:	0011      	movs	r1, r2
 8001ee0:	001a      	movs	r2, r3
 8001ee2:	3210      	adds	r2, #16
 8001ee4:	ca31      	ldmia	r2!, {r0, r4, r5}
 8001ee6:	c131      	stmia	r1!, {r0, r4, r5}
 8001ee8:	6812      	ldr	r2, [r2, #0]
 8001eea:	600a      	str	r2, [r1, #0]
 8001eec:	6818      	ldr	r0, [r3, #0]
 8001eee:	6859      	ldr	r1, [r3, #4]
 8001ef0:	689a      	ldr	r2, [r3, #8]
 8001ef2:	68db      	ldr	r3, [r3, #12]
 8001ef4:	f7ff fd5e 	bl	80019b4 <GSM_SendCommand_AT>
        break;
 8001ef8:	e08a      	b.n	8002010 <GSM_FileSend_Handler+0x240>
        if(event == GSM_EVENT_OK)
 8001efa:	1dfb      	adds	r3, r7, #7
 8001efc:	781b      	ldrb	r3, [r3, #0]
 8001efe:	2b00      	cmp	r3, #0
 8001f00:	d000      	beq.n	8001f04 <GSM_FileSend_Handler+0x134>
 8001f02:	e081      	b.n	8002008 <GSM_FileSend_Handler+0x238>
            step = 0;
 8001f04:	4b44      	ldr	r3, [pc, #272]	; (8002018 <GSM_FileSend_Handler+0x248>)
 8001f06:	2200      	movs	r2, #0
 8001f08:	701a      	strb	r2, [r3, #0]
            char* substr = "+QFTPSIZE: 0,";
 8001f0a:	4b4b      	ldr	r3, [pc, #300]	; (8002038 <GSM_FileSend_Handler+0x268>)
 8001f0c:	637b      	str	r3, [r7, #52]	; 0x34
            char* result = strstr((char*)Resp_Buffer, substr);
 8001f0e:	683b      	ldr	r3, [r7, #0]
 8001f10:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8001f12:	0011      	movs	r1, r2
 8001f14:	0018      	movs	r0, r3
 8001f16:	f01b f8ff 	bl	801d118 <strstr>
 8001f1a:	0003      	movs	r3, r0
 8001f1c:	633b      	str	r3, [r7, #48]	; 0x30
            int position = result - (char*)Resp_Buffer;
 8001f1e:	683b      	ldr	r3, [r7, #0]
 8001f20:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8001f22:	1ad3      	subs	r3, r2, r3
 8001f24:	62fb      	str	r3, [r7, #44]	; 0x2c
            int FileLength = gsm_utilities_get_number_from_string (position + strlen(substr),
 8001f26:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8001f28:	0018      	movs	r0, r3
 8001f2a:	f7fe f8ed 	bl	8000108 <strlen>
 8001f2e:	0003      	movs	r3, r0
 8001f30:	b29a      	uxth	r2, r3
 8001f32:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001f34:	b29b      	uxth	r3, r3
 8001f36:	18d3      	adds	r3, r2, r3
 8001f38:	b29b      	uxth	r3, r3
 8001f3a:	683a      	ldr	r2, [r7, #0]
 8001f3c:	0011      	movs	r1, r2
 8001f3e:	0018      	movs	r0, r3
 8001f40:	f000 fbfc 	bl	800273c <gsm_utilities_get_number_from_string>
 8001f44:	0003      	movs	r3, r0
 8001f46:	62bb      	str	r3, [r7, #40]	; 0x28
            FileSend_Info.File[FileSend_Info.FileID].Index = FileLength;
 8001f48:	4b34      	ldr	r3, [pc, #208]	; (800201c <GSM_FileSend_Handler+0x24c>)
 8001f4a:	22c9      	movs	r2, #201	; 0xc9
 8001f4c:	5c9b      	ldrb	r3, [r3, r2]
 8001f4e:	0019      	movs	r1, r3
 8001f50:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001f52:	b298      	uxth	r0, r3
 8001f54:	4a31      	ldr	r2, [pc, #196]	; (800201c <GSM_FileSend_Handler+0x24c>)
 8001f56:	000b      	movs	r3, r1
 8001f58:	009b      	lsls	r3, r3, #2
 8001f5a:	185b      	adds	r3, r3, r1
 8001f5c:	009b      	lsls	r3, r3, #2
 8001f5e:	18d3      	adds	r3, r2, r3
 8001f60:	3310      	adds	r3, #16
 8001f62:	1c02      	adds	r2, r0, #0
 8001f64:	801a      	strh	r2, [r3, #0]
            DEBUG_INFO("File exist, size %d bytes.\r\n", FileSend_Info.File[FileSend_Info.FileID].Index);
 8001f66:	f01a ff57 	bl	801ce18 <sys_get_tick_ms>
 8001f6a:	0001      	movs	r1, r0
 8001f6c:	4b2b      	ldr	r3, [pc, #172]	; (800201c <GSM_FileSend_Handler+0x24c>)
 8001f6e:	22c9      	movs	r2, #201	; 0xc9
 8001f70:	5c9b      	ldrb	r3, [r3, r2]
 8001f72:	0018      	movs	r0, r3
 8001f74:	4a29      	ldr	r2, [pc, #164]	; (800201c <GSM_FileSend_Handler+0x24c>)
 8001f76:	0003      	movs	r3, r0
 8001f78:	009b      	lsls	r3, r3, #2
 8001f7a:	181b      	adds	r3, r3, r0
 8001f7c:	009b      	lsls	r3, r3, #2
 8001f7e:	18d3      	adds	r3, r2, r3
 8001f80:	3310      	adds	r3, #16
 8001f82:	881b      	ldrh	r3, [r3, #0]
 8001f84:	4a28      	ldr	r2, [pc, #160]	; (8002028 <GSM_FileSend_Handler+0x258>)
 8001f86:	482d      	ldr	r0, [pc, #180]	; (800203c <GSM_FileSend_Handler+0x26c>)
 8001f88:	f000 fe1e 	bl	8002bc8 <app_debug_rtt_raw>
                                                        FileSend_Info.File[FileSend_Info.FileID].Name,
 8001f8c:	4b23      	ldr	r3, [pc, #140]	; (800201c <GSM_FileSend_Handler+0x24c>)
 8001f8e:	22c9      	movs	r2, #201	; 0xc9
 8001f90:	5c9b      	ldrb	r3, [r3, r2]
 8001f92:	0019      	movs	r1, r3
            snprintf(Upload_File_AT_Command, sizeof(Upload_File_AT_Command), "%s%s%s%d%s%d%s",
 8001f94:	4a21      	ldr	r2, [pc, #132]	; (800201c <GSM_FileSend_Handler+0x24c>)
 8001f96:	000b      	movs	r3, r1
 8001f98:	009b      	lsls	r3, r3, #2
 8001f9a:	185b      	adds	r3, r3, r1
 8001f9c:	009b      	lsls	r3, r3, #2
 8001f9e:	18d3      	adds	r3, r2, r3
 8001fa0:	3308      	adds	r3, #8
 8001fa2:	681a      	ldr	r2, [r3, #0]
                                                        FileSend_Info.File[FileSend_Info.FileID].Index,
 8001fa4:	4b1d      	ldr	r3, [pc, #116]	; (800201c <GSM_FileSend_Handler+0x24c>)
 8001fa6:	21c9      	movs	r1, #201	; 0xc9
 8001fa8:	5c5b      	ldrb	r3, [r3, r1]
 8001faa:	0018      	movs	r0, r3
 8001fac:	491b      	ldr	r1, [pc, #108]	; (800201c <GSM_FileSend_Handler+0x24c>)
 8001fae:	0003      	movs	r3, r0
 8001fb0:	009b      	lsls	r3, r3, #2
 8001fb2:	181b      	adds	r3, r3, r0
 8001fb4:	009b      	lsls	r3, r3, #2
 8001fb6:	18cb      	adds	r3, r1, r3
 8001fb8:	3310      	adds	r3, #16
 8001fba:	881b      	ldrh	r3, [r3, #0]
            snprintf(Upload_File_AT_Command, sizeof(Upload_File_AT_Command), "%s%s%s%d%s%d%s",
 8001fbc:	001d      	movs	r5, r3
                                                        FileSend_Info.File[FileSend_Info.FileID].DataLength,
 8001fbe:	4b17      	ldr	r3, [pc, #92]	; (800201c <GSM_FileSend_Handler+0x24c>)
 8001fc0:	21c9      	movs	r1, #201	; 0xc9
 8001fc2:	5c5b      	ldrb	r3, [r3, r1]
 8001fc4:	0018      	movs	r0, r3
 8001fc6:	4915      	ldr	r1, [pc, #84]	; (800201c <GSM_FileSend_Handler+0x24c>)
 8001fc8:	0003      	movs	r3, r0
 8001fca:	009b      	lsls	r3, r3, #2
 8001fcc:	181b      	adds	r3, r3, r0
 8001fce:	009b      	lsls	r3, r3, #2
 8001fd0:	18cb      	adds	r3, r1, r3
 8001fd2:	3304      	adds	r3, #4
 8001fd4:	881b      	ldrh	r3, [r3, #0]
            snprintf(Upload_File_AT_Command, sizeof(Upload_File_AT_Command), "%s%s%s%d%s%d%s",
 8001fd6:	001e      	movs	r6, r3
 8001fd8:	4c19      	ldr	r4, [pc, #100]	; (8002040 <GSM_FileSend_Handler+0x270>)
 8001fda:	491a      	ldr	r1, [pc, #104]	; (8002044 <GSM_FileSend_Handler+0x274>)
 8001fdc:	481a      	ldr	r0, [pc, #104]	; (8002048 <GSM_FileSend_Handler+0x278>)
 8001fde:	4b1b      	ldr	r3, [pc, #108]	; (800204c <GSM_FileSend_Handler+0x27c>)
 8001fe0:	9305      	str	r3, [sp, #20]
 8001fe2:	9604      	str	r6, [sp, #16]
 8001fe4:	4b1a      	ldr	r3, [pc, #104]	; (8002050 <GSM_FileSend_Handler+0x280>)
 8001fe6:	9303      	str	r3, [sp, #12]
 8001fe8:	9502      	str	r5, [sp, #8]
 8001fea:	4b1a      	ldr	r3, [pc, #104]	; (8002054 <GSM_FileSend_Handler+0x284>)
 8001fec:	9301      	str	r3, [sp, #4]
 8001fee:	9200      	str	r2, [sp, #0]
 8001ff0:	0023      	movs	r3, r4
 8001ff2:	000a      	movs	r2, r1
 8001ff4:	2146      	movs	r1, #70	; 0x46
 8001ff6:	f01b f847 	bl	801d088 <sniprintf>
            GSM_File_Transfer_Seq(event, NULL);
 8001ffa:	1dfb      	adds	r3, r7, #7
 8001ffc:	781b      	ldrb	r3, [r3, #0]
 8001ffe:	2100      	movs	r1, #0
 8002000:	0018      	movs	r0, r3
 8002002:	f000 f8e5 	bl	80021d0 <GSM_File_Transfer_Seq>
        break;
 8002006:	e002      	b.n	800200e <GSM_FileSend_Handler+0x23e>
            GSM_Manager_ChangeState(GSM_STATE_RESET);
 8002008:	2001      	movs	r0, #1
 800200a:	f7ff f999 	bl	8001340 <GSM_Manager_ChangeState>
        break;
 800200e:	46c0      	nop			; (mov r8, r8)
    } 
}
 8002010:	46c0      	nop			; (mov r8, r8)
 8002012:	46bd      	mov	sp, r7
 8002014:	b00f      	add	sp, #60	; 0x3c
 8002016:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002018:	20000f00 	.word	0x20000f00
 800201c:	20000e24 	.word	0x20000e24
 8002020:	0801e8ac 	.word	0x0801e8ac
 8002024:	20000f01 	.word	0x20000f01
 8002028:	0801e640 	.word	0x0801e640
 800202c:	0801e7e4 	.word	0x0801e7e4
 8002030:	20000e20 	.word	0x20000e20
 8002034:	08022640 	.word	0x08022640
 8002038:	0801e82c 	.word	0x0801e82c
 800203c:	0801e83c 	.word	0x0801e83c
 8002040:	0801e874 	.word	0x0801e874
 8002044:	0801e884 	.word	0x0801e884
 8002048:	20000cbc 	.word	0x20000cbc
 800204c:	0801e894 	.word	0x0801e894
 8002050:	0801e89c 	.word	0x0801e89c
 8002054:	0801e8a0 	.word	0x0801e8a0

08002058 <GSM_Login_Server_Seq>:
void GSM_Login_Server_Seq(GSM_Response_Event_TypDef event, void *Resp_Buffer)
{
 8002058:	b5f0      	push	{r4, r5, r6, r7, lr}
 800205a:	b089      	sub	sp, #36	; 0x24
 800205c:	af04      	add	r7, sp, #16
 800205e:	0002      	movs	r2, r0
 8002060:	6039      	str	r1, [r7, #0]
 8002062:	1dfb      	adds	r3, r7, #7
 8002064:	701a      	strb	r2, [r3, #0]
    uint8_t TableIndex = File_Handler_Manager.step;
 8002066:	210f      	movs	r1, #15
 8002068:	187b      	adds	r3, r7, r1
 800206a:	4a4d      	ldr	r2, [pc, #308]	; (80021a0 <GSM_Login_Server_Seq+0x148>)
 800206c:	7852      	ldrb	r2, [r2, #1]
 800206e:	701a      	strb	r2, [r3, #0]
    const static uint8_t TableSize = sizeof(ATC_Table_Login_Server)/sizeof(ATC_Table_Login_Server[0]);
    if(TableIndex > TableSize)
 8002070:	4b4c      	ldr	r3, [pc, #304]	; (80021a4 <GSM_Login_Server_Seq+0x14c>)
 8002072:	781b      	ldrb	r3, [r3, #0]
 8002074:	187a      	adds	r2, r7, r1
 8002076:	7812      	ldrb	r2, [r2, #0]
 8002078:	429a      	cmp	r2, r3
 800207a:	d900      	bls.n	800207e <GSM_Login_Server_Seq+0x26>
 800207c:	e08c      	b.n	8002198 <GSM_Login_Server_Seq+0x140>
    {
        return;
    }
    DEBUG_PrintResult_ATC(ATC_Table_Login_Server[TableIndex-1].cmd, (event == GSM_EVENT_OK)?"[OK]":"[FAIL]");
 800207e:	187b      	adds	r3, r7, r1
 8002080:	781b      	ldrb	r3, [r3, #0]
 8002082:	1e5a      	subs	r2, r3, #1
 8002084:	4b48      	ldr	r3, [pc, #288]	; (80021a8 <GSM_Login_Server_Seq+0x150>)
 8002086:	0152      	lsls	r2, r2, #5
 8002088:	58d2      	ldr	r2, [r2, r3]
 800208a:	1dfb      	adds	r3, r7, #7
 800208c:	781b      	ldrb	r3, [r3, #0]
 800208e:	2b00      	cmp	r3, #0
 8002090:	d101      	bne.n	8002096 <GSM_Login_Server_Seq+0x3e>
 8002092:	4b46      	ldr	r3, [pc, #280]	; (80021ac <GSM_Login_Server_Seq+0x154>)
 8002094:	e000      	b.n	8002098 <GSM_Login_Server_Seq+0x40>
 8002096:	4b46      	ldr	r3, [pc, #280]	; (80021b0 <GSM_Login_Server_Seq+0x158>)
 8002098:	0019      	movs	r1, r3
 800209a:	0010      	movs	r0, r2
 800209c:	f000 fbc4 	bl	8002828 <DEBUG_PrintResult_ATC>
    //DEBUG_RAW("%s\r\n", (char*)Resp_Buffer);
    if(event == GSM_EVENT_OK)
 80020a0:	1dfb      	adds	r3, r7, #7
 80020a2:	781b      	ldrb	r3, [r3, #0]
 80020a4:	2b00      	cmp	r3, #0
 80020a6:	d173      	bne.n	8002190 <GSM_Login_Server_Seq+0x138>
    {
        if(TableIndex < TableSize)
 80020a8:	4b3e      	ldr	r3, [pc, #248]	; (80021a4 <GSM_Login_Server_Seq+0x14c>)
 80020aa:	781b      	ldrb	r3, [r3, #0]
 80020ac:	210f      	movs	r1, #15
 80020ae:	187a      	adds	r2, r7, r1
 80020b0:	7812      	ldrb	r2, [r2, #0]
 80020b2:	429a      	cmp	r2, r3
 80020b4:	d215      	bcs.n	80020e2 <GSM_Login_Server_Seq+0x8a>
        {
            GSM_SendCommand_AT(ATC_Table_Login_Server[TableIndex]);
 80020b6:	187b      	adds	r3, r7, r1
 80020b8:	781b      	ldrb	r3, [r3, #0]
 80020ba:	4c3b      	ldr	r4, [pc, #236]	; (80021a8 <GSM_Login_Server_Seq+0x150>)
 80020bc:	015b      	lsls	r3, r3, #5
 80020be:	2110      	movs	r1, #16
 80020c0:	18e2      	adds	r2, r4, r3
 80020c2:	1851      	adds	r1, r2, r1
 80020c4:	466a      	mov	r2, sp
 80020c6:	c961      	ldmia	r1!, {r0, r5, r6}
 80020c8:	c261      	stmia	r2!, {r0, r5, r6}
 80020ca:	6809      	ldr	r1, [r1, #0]
 80020cc:	6011      	str	r1, [r2, #0]
 80020ce:	5918      	ldr	r0, [r3, r4]
 80020d0:	18e2      	adds	r2, r4, r3
 80020d2:	6851      	ldr	r1, [r2, #4]
 80020d4:	18e2      	adds	r2, r4, r3
 80020d6:	6892      	ldr	r2, [r2, #8]
 80020d8:	18e3      	adds	r3, r4, r3
 80020da:	68db      	ldr	r3, [r3, #12]
 80020dc:	f7ff fc6a 	bl	80019b4 <GSM_SendCommand_AT>
 80020e0:	e04f      	b.n	8002182 <GSM_Login_Server_Seq+0x12a>
        }
        else
        {
            // Da Login Server xong
            File_Handler_Manager.step = 0;
 80020e2:	4b2f      	ldr	r3, [pc, #188]	; (80021a0 <GSM_Login_Server_Seq+0x148>)
 80020e4:	2200      	movs	r2, #0
 80020e6:	705a      	strb	r2, [r3, #1]
            DEBUG_INFO("Log in server DONE.\r\n");
 80020e8:	f01a fe96 	bl	801ce18 <sys_get_tick_ms>
 80020ec:	0001      	movs	r1, r0
 80020ee:	4a31      	ldr	r2, [pc, #196]	; (80021b4 <GSM_Login_Server_Seq+0x15c>)
 80020f0:	4b31      	ldr	r3, [pc, #196]	; (80021b8 <GSM_Login_Server_Seq+0x160>)
 80020f2:	0018      	movs	r0, r3
 80020f4:	f000 fd68 	bl	8002bc8 <app_debug_rtt_raw>
            if(File_Handler_Manager.mode == GSM_FILE_MODE_UPLOAD)
 80020f8:	4b29      	ldr	r3, [pc, #164]	; (80021a0 <GSM_Login_Server_Seq+0x148>)
 80020fa:	781b      	ldrb	r3, [r3, #0]
 80020fc:	2b00      	cmp	r3, #0
 80020fe:	d129      	bne.n	8002154 <GSM_Login_Server_Seq+0xfc>
            {
                // Chuyen sang Mode Upload
                FileSend_Info.FileID = 0;
 8002100:	4b2e      	ldr	r3, [pc, #184]	; (80021bc <GSM_Login_Server_Seq+0x164>)
 8002102:	22c9      	movs	r2, #201	; 0xc9
 8002104:	2100      	movs	r1, #0
 8002106:	5499      	strb	r1, [r3, r2]
                DEBUG_INFO("Start transferring file \"%s\".\r\n", FileSend_Info.File[0].Name);
 8002108:	f01a fe86 	bl	801ce18 <sys_get_tick_ms>
 800210c:	0001      	movs	r1, r0
 800210e:	4b2b      	ldr	r3, [pc, #172]	; (80021bc <GSM_Login_Server_Seq+0x164>)
 8002110:	689b      	ldr	r3, [r3, #8]
 8002112:	4a28      	ldr	r2, [pc, #160]	; (80021b4 <GSM_Login_Server_Seq+0x15c>)
 8002114:	482a      	ldr	r0, [pc, #168]	; (80021c0 <GSM_Login_Server_Seq+0x168>)
 8002116:	f000 fd57 	bl	8002bc8 <app_debug_rtt_raw>
                Add_FileTranfer_Info_to_AT_Command(&FileSend_Info.File[FileSend_Info.FileID]);
 800211a:	4b28      	ldr	r3, [pc, #160]	; (80021bc <GSM_Login_Server_Seq+0x164>)
 800211c:	22c9      	movs	r2, #201	; 0xc9
 800211e:	5c9b      	ldrb	r3, [r3, r2]
 8002120:	001a      	movs	r2, r3
 8002122:	0013      	movs	r3, r2
 8002124:	009b      	lsls	r3, r3, #2
 8002126:	189b      	adds	r3, r3, r2
 8002128:	009b      	lsls	r3, r3, #2
 800212a:	4a24      	ldr	r2, [pc, #144]	; (80021bc <GSM_Login_Server_Seq+0x164>)
 800212c:	189b      	adds	r3, r3, r2
 800212e:	0018      	movs	r0, r3
 8002130:	f000 f9dc 	bl	80024ec <Add_FileTranfer_Info_to_AT_Command>
                GSM_SendCommand_AT(ATC_Table_File_Tranfer[0]);
 8002134:	4b23      	ldr	r3, [pc, #140]	; (80021c4 <GSM_Login_Server_Seq+0x16c>)
 8002136:	466a      	mov	r2, sp
 8002138:	0011      	movs	r1, r2
 800213a:	001a      	movs	r2, r3
 800213c:	3210      	adds	r2, #16
 800213e:	ca31      	ldmia	r2!, {r0, r4, r5}
 8002140:	c131      	stmia	r1!, {r0, r4, r5}
 8002142:	6812      	ldr	r2, [r2, #0]
 8002144:	600a      	str	r2, [r1, #0]
 8002146:	6818      	ldr	r0, [r3, #0]
 8002148:	6859      	ldr	r1, [r3, #4]
 800214a:	689a      	ldr	r2, [r3, #8]
 800214c:	68db      	ldr	r3, [r3, #12]
 800214e:	f7ff fc31 	bl	80019b4 <GSM_SendCommand_AT>
 8002152:	e016      	b.n	8002182 <GSM_Login_Server_Seq+0x12a>
            }
            else if(File_Handler_Manager.mode == GSM_FILE_MODE_DOWNLOAD)
 8002154:	4b12      	ldr	r3, [pc, #72]	; (80021a0 <GSM_Login_Server_Seq+0x148>)
 8002156:	781b      	ldrb	r3, [r3, #0]
 8002158:	2b01      	cmp	r3, #1
 800215a:	d112      	bne.n	8002182 <GSM_Login_Server_Seq+0x12a>
            {
                // Chuyen sang Mode Download
            	Add_FileDownload_Info_to_AT_Command(&FileDownload_Info);
 800215c:	4b1a      	ldr	r3, [pc, #104]	; (80021c8 <GSM_Login_Server_Seq+0x170>)
 800215e:	0018      	movs	r0, r3
 8002160:	f000 fa28 	bl	80025b4 <Add_FileDownload_Info_to_AT_Command>
                GSM_SendCommand_AT(ATC_Table_File_Download[0]);
 8002164:	4b19      	ldr	r3, [pc, #100]	; (80021cc <GSM_Login_Server_Seq+0x174>)
 8002166:	466a      	mov	r2, sp
 8002168:	0011      	movs	r1, r2
 800216a:	001a      	movs	r2, r3
 800216c:	3210      	adds	r2, #16
 800216e:	ca31      	ldmia	r2!, {r0, r4, r5}
 8002170:	c131      	stmia	r1!, {r0, r4, r5}
 8002172:	6812      	ldr	r2, [r2, #0]
 8002174:	600a      	str	r2, [r1, #0]
 8002176:	6818      	ldr	r0, [r3, #0]
 8002178:	6859      	ldr	r1, [r3, #4]
 800217a:	689a      	ldr	r2, [r3, #8]
 800217c:	68db      	ldr	r3, [r3, #12]
 800217e:	f7ff fc19 	bl	80019b4 <GSM_SendCommand_AT>
            }
        }
        File_Handler_Manager.step++;
 8002182:	4b07      	ldr	r3, [pc, #28]	; (80021a0 <GSM_Login_Server_Seq+0x148>)
 8002184:	785b      	ldrb	r3, [r3, #1]
 8002186:	3301      	adds	r3, #1
 8002188:	b2da      	uxtb	r2, r3
 800218a:	4b05      	ldr	r3, [pc, #20]	; (80021a0 <GSM_Login_Server_Seq+0x148>)
 800218c:	705a      	strb	r2, [r3, #1]
 800218e:	e004      	b.n	800219a <GSM_Login_Server_Seq+0x142>
    }
    else //if(event == GSM_EVENT_TIMEOUT)
    {
        GSM_Manager_ChangeState(GSM_STATE_RESET);
 8002190:	2001      	movs	r0, #1
 8002192:	f7ff f8d5 	bl	8001340 <GSM_Manager_ChangeState>
 8002196:	e000      	b.n	800219a <GSM_Login_Server_Seq+0x142>
        return;
 8002198:	46c0      	nop			; (mov r8, r8)
    }
}
 800219a:	46bd      	mov	sp, r7
 800219c:	b005      	add	sp, #20
 800219e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80021a0:	20000e20 	.word	0x20000e20
 80021a4:	08022760 	.word	0x08022760
 80021a8:	08022540 	.word	0x08022540
 80021ac:	0801e8cc 	.word	0x0801e8cc
 80021b0:	0801e8d4 	.word	0x0801e8d4
 80021b4:	0801e640 	.word	0x0801e640
 80021b8:	0801e8dc 	.word	0x0801e8dc
 80021bc:	20000e24 	.word	0x20000e24
 80021c0:	0801e90c 	.word	0x0801e90c
 80021c4:	08022640 	.word	0x08022640
 80021c8:	20000ef0 	.word	0x20000ef0
 80021cc:	08022720 	.word	0x08022720

080021d0 <GSM_File_Transfer_Seq>:
void GSM_File_Transfer_Seq(GSM_Response_Event_TypDef event, void *Resp_Buffer)
{
 80021d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80021d2:	b08d      	sub	sp, #52	; 0x34
 80021d4:	af04      	add	r7, sp, #16
 80021d6:	0002      	movs	r2, r0
 80021d8:	6039      	str	r1, [r7, #0]
 80021da:	1dfb      	adds	r3, r7, #7
 80021dc:	701a      	strb	r2, [r3, #0]
    uint8_t TableIndex = File_Handler_Manager.step;
 80021de:	211f      	movs	r1, #31
 80021e0:	187b      	adds	r3, r7, r1
 80021e2:	4a69      	ldr	r2, [pc, #420]	; (8002388 <GSM_File_Transfer_Seq+0x1b8>)
 80021e4:	7852      	ldrb	r2, [r2, #1]
 80021e6:	701a      	strb	r2, [r3, #0]
    const static uint8_t TableSize = sizeof(ATC_Table_File_Tranfer)/sizeof(ATC_Table_File_Tranfer[0]);
    if(TableIndex > TableSize)
 80021e8:	4b68      	ldr	r3, [pc, #416]	; (800238c <GSM_File_Transfer_Seq+0x1bc>)
 80021ea:	781b      	ldrb	r3, [r3, #0]
 80021ec:	187a      	adds	r2, r7, r1
 80021ee:	7812      	ldrb	r2, [r2, #0]
 80021f0:	429a      	cmp	r2, r3
 80021f2:	d900      	bls.n	80021f6 <GSM_File_Transfer_Seq+0x26>
 80021f4:	e0c4      	b.n	8002380 <GSM_File_Transfer_Seq+0x1b0>
    {
        return;
    }
    DEBUG_PrintResult_ATC(ATC_Table_File_Tranfer[TableIndex-1].cmd, (event == GSM_EVENT_OK)?"[OK]":"[FAIL]");
 80021f6:	187b      	adds	r3, r7, r1
 80021f8:	781b      	ldrb	r3, [r3, #0]
 80021fa:	1e5a      	subs	r2, r3, #1
 80021fc:	4b64      	ldr	r3, [pc, #400]	; (8002390 <GSM_File_Transfer_Seq+0x1c0>)
 80021fe:	0152      	lsls	r2, r2, #5
 8002200:	58d2      	ldr	r2, [r2, r3]
 8002202:	1dfb      	adds	r3, r7, #7
 8002204:	781b      	ldrb	r3, [r3, #0]
 8002206:	2b00      	cmp	r3, #0
 8002208:	d101      	bne.n	800220e <GSM_File_Transfer_Seq+0x3e>
 800220a:	4b62      	ldr	r3, [pc, #392]	; (8002394 <GSM_File_Transfer_Seq+0x1c4>)
 800220c:	e000      	b.n	8002210 <GSM_File_Transfer_Seq+0x40>
 800220e:	4b62      	ldr	r3, [pc, #392]	; (8002398 <GSM_File_Transfer_Seq+0x1c8>)
 8002210:	0019      	movs	r1, r3
 8002212:	0010      	movs	r0, r2
 8002214:	f000 fb08 	bl	8002828 <DEBUG_PrintResult_ATC>
    //DEBUG_RAW("%s\r\n", (char*)Resp_Buffer);
    if(event == GSM_EVENT_OK)
 8002218:	1dfb      	adds	r3, r7, #7
 800221a:	781b      	ldrb	r3, [r3, #0]
 800221c:	2b00      	cmp	r3, #0
 800221e:	d000      	beq.n	8002222 <GSM_File_Transfer_Seq+0x52>
 8002220:	e0aa      	b.n	8002378 <GSM_File_Transfer_Seq+0x1a8>
    {
        if(TableIndex < TableSize)
 8002222:	4b5a      	ldr	r3, [pc, #360]	; (800238c <GSM_File_Transfer_Seq+0x1bc>)
 8002224:	781b      	ldrb	r3, [r3, #0]
 8002226:	211f      	movs	r1, #31
 8002228:	187a      	adds	r2, r7, r1
 800222a:	7812      	ldrb	r2, [r2, #0]
 800222c:	429a      	cmp	r2, r3
 800222e:	d215      	bcs.n	800225c <GSM_File_Transfer_Seq+0x8c>
        {
            GSM_SendCommand_AT(ATC_Table_File_Tranfer[TableIndex]);
 8002230:	187b      	adds	r3, r7, r1
 8002232:	781b      	ldrb	r3, [r3, #0]
 8002234:	4c56      	ldr	r4, [pc, #344]	; (8002390 <GSM_File_Transfer_Seq+0x1c0>)
 8002236:	015b      	lsls	r3, r3, #5
 8002238:	2110      	movs	r1, #16
 800223a:	18e2      	adds	r2, r4, r3
 800223c:	1851      	adds	r1, r2, r1
 800223e:	466a      	mov	r2, sp
 8002240:	c961      	ldmia	r1!, {r0, r5, r6}
 8002242:	c261      	stmia	r2!, {r0, r5, r6}
 8002244:	6809      	ldr	r1, [r1, #0]
 8002246:	6011      	str	r1, [r2, #0]
 8002248:	5918      	ldr	r0, [r3, r4]
 800224a:	18e2      	adds	r2, r4, r3
 800224c:	6851      	ldr	r1, [r2, #4]
 800224e:	18e2      	adds	r2, r4, r3
 8002250:	6892      	ldr	r2, [r2, #8]
 8002252:	18e3      	adds	r3, r4, r3
 8002254:	68db      	ldr	r3, [r3, #12]
 8002256:	f7ff fbad 	bl	80019b4 <GSM_SendCommand_AT>
 800225a:	e086      	b.n	800236a <GSM_File_Transfer_Seq+0x19a>
        }
        else
        {
            // Da Transfer File xong
            File_Handler_Manager.step = 0;
 800225c:	4b4a      	ldr	r3, [pc, #296]	; (8002388 <GSM_File_Transfer_Seq+0x1b8>)
 800225e:	2200      	movs	r2, #0
 8002260:	705a      	strb	r2, [r3, #1]
            // Caculate Length File vua Transfer base on Resp_Buffer
            char* substr = "+QFTPSIZE: 0,";
 8002262:	4b4e      	ldr	r3, [pc, #312]	; (800239c <GSM_File_Transfer_Seq+0x1cc>)
 8002264:	61bb      	str	r3, [r7, #24]
            char* result = strstr((char*)Resp_Buffer, substr);
 8002266:	69ba      	ldr	r2, [r7, #24]
 8002268:	683b      	ldr	r3, [r7, #0]
 800226a:	0011      	movs	r1, r2
 800226c:	0018      	movs	r0, r3
 800226e:	f01a ff53 	bl	801d118 <strstr>
 8002272:	0003      	movs	r3, r0
 8002274:	617b      	str	r3, [r7, #20]
            int position = result - (char*)Resp_Buffer;
 8002276:	697a      	ldr	r2, [r7, #20]
 8002278:	683b      	ldr	r3, [r7, #0]
 800227a:	1ad3      	subs	r3, r2, r3
 800227c:	613b      	str	r3, [r7, #16]
            int FileLength = gsm_utilities_get_number_from_string (position + strlen(substr),
 800227e:	69bb      	ldr	r3, [r7, #24]
 8002280:	0018      	movs	r0, r3
 8002282:	f7fd ff41 	bl	8000108 <strlen>
 8002286:	0003      	movs	r3, r0
 8002288:	b29a      	uxth	r2, r3
 800228a:	693b      	ldr	r3, [r7, #16]
 800228c:	b29b      	uxth	r3, r3
 800228e:	18d3      	adds	r3, r2, r3
 8002290:	b29b      	uxth	r3, r3
 8002292:	683a      	ldr	r2, [r7, #0]
 8002294:	0011      	movs	r1, r2
 8002296:	0018      	movs	r0, r3
 8002298:	f000 fa50 	bl	800273c <gsm_utilities_get_number_from_string>
 800229c:	0003      	movs	r3, r0
 800229e:	60fb      	str	r3, [r7, #12]
                                                                        (char*)Resp_Buffer);
            DEBUG_INFO("File %d: \"%s\" Transfer DONE, length %d bytes.\r\n",
 80022a0:	f01a fdba 	bl	801ce18 <sys_get_tick_ms>
 80022a4:	0005      	movs	r5, r0
 80022a6:	4b3e      	ldr	r3, [pc, #248]	; (80023a0 <GSM_File_Transfer_Seq+0x1d0>)
 80022a8:	22c9      	movs	r2, #201	; 0xc9
 80022aa:	5c9b      	ldrb	r3, [r3, r2]
 80022ac:	1c5c      	adds	r4, r3, #1
 80022ae:	4b3c      	ldr	r3, [pc, #240]	; (80023a0 <GSM_File_Transfer_Seq+0x1d0>)
 80022b0:	22c9      	movs	r2, #201	; 0xc9
 80022b2:	5c9b      	ldrb	r3, [r3, r2]
 80022b4:	0019      	movs	r1, r3
 80022b6:	4a3a      	ldr	r2, [pc, #232]	; (80023a0 <GSM_File_Transfer_Seq+0x1d0>)
 80022b8:	000b      	movs	r3, r1
 80022ba:	009b      	lsls	r3, r3, #2
 80022bc:	185b      	adds	r3, r3, r1
 80022be:	009b      	lsls	r3, r3, #2
 80022c0:	18d3      	adds	r3, r2, r3
 80022c2:	3308      	adds	r3, #8
 80022c4:	681b      	ldr	r3, [r3, #0]
 80022c6:	4937      	ldr	r1, [pc, #220]	; (80023a4 <GSM_File_Transfer_Seq+0x1d4>)
 80022c8:	4837      	ldr	r0, [pc, #220]	; (80023a8 <GSM_File_Transfer_Seq+0x1d8>)
 80022ca:	68fa      	ldr	r2, [r7, #12]
 80022cc:	9201      	str	r2, [sp, #4]
 80022ce:	9300      	str	r3, [sp, #0]
 80022d0:	0023      	movs	r3, r4
 80022d2:	000a      	movs	r2, r1
 80022d4:	0029      	movs	r1, r5
 80022d6:	f000 fc77 	bl	8002bc8 <app_debug_rtt_raw>
                                                            FileSend_Info.FileID + 1,
                                                            FileSend_Info.File[FileSend_Info.FileID].Name,
                                                            FileLength);
            // Bat dau chuyen sang transfer file tiep theo
            if(++FileSend_Info.FileID >= FileSend_Info.NumberFile)
 80022da:	4b31      	ldr	r3, [pc, #196]	; (80023a0 <GSM_File_Transfer_Seq+0x1d0>)
 80022dc:	22c9      	movs	r2, #201	; 0xc9
 80022de:	5c9b      	ldrb	r3, [r3, r2]
 80022e0:	3301      	adds	r3, #1
 80022e2:	b2d9      	uxtb	r1, r3
 80022e4:	4b2e      	ldr	r3, [pc, #184]	; (80023a0 <GSM_File_Transfer_Seq+0x1d0>)
 80022e6:	22c9      	movs	r2, #201	; 0xc9
 80022e8:	5499      	strb	r1, [r3, r2]
 80022ea:	4b2d      	ldr	r3, [pc, #180]	; (80023a0 <GSM_File_Transfer_Seq+0x1d0>)
 80022ec:	22c9      	movs	r2, #201	; 0xc9
 80022ee:	5c9a      	ldrb	r2, [r3, r2]
 80022f0:	4b2b      	ldr	r3, [pc, #172]	; (80023a0 <GSM_File_Transfer_Seq+0x1d0>)
 80022f2:	21c8      	movs	r1, #200	; 0xc8
 80022f4:	5c5b      	ldrb	r3, [r3, r1]
 80022f6:	429a      	cmp	r2, r3
 80022f8:	d308      	bcc.n	800230c <GSM_File_Transfer_Seq+0x13c>
            {
                DEBUG_INFO("All File Transfer DONE.\r\n");
 80022fa:	f01a fd8d 	bl	801ce18 <sys_get_tick_ms>
 80022fe:	0001      	movs	r1, r0
 8002300:	4a28      	ldr	r2, [pc, #160]	; (80023a4 <GSM_File_Transfer_Seq+0x1d4>)
 8002302:	4b2a      	ldr	r3, [pc, #168]	; (80023ac <GSM_File_Transfer_Seq+0x1dc>)
 8002304:	0018      	movs	r0, r3
 8002306:	f000 fc5f 	bl	8002bc8 <app_debug_rtt_raw>
 800230a:	e02e      	b.n	800236a <GSM_File_Transfer_Seq+0x19a>
            }
            else
            {
                DEBUG_INFO("Start transferring file \"%s\".\r\n",
 800230c:	f01a fd84 	bl	801ce18 <sys_get_tick_ms>
 8002310:	0001      	movs	r1, r0
 8002312:	4b23      	ldr	r3, [pc, #140]	; (80023a0 <GSM_File_Transfer_Seq+0x1d0>)
 8002314:	22c9      	movs	r2, #201	; 0xc9
 8002316:	5c9b      	ldrb	r3, [r3, r2]
 8002318:	0018      	movs	r0, r3
 800231a:	4a21      	ldr	r2, [pc, #132]	; (80023a0 <GSM_File_Transfer_Seq+0x1d0>)
 800231c:	0003      	movs	r3, r0
 800231e:	009b      	lsls	r3, r3, #2
 8002320:	181b      	adds	r3, r3, r0
 8002322:	009b      	lsls	r3, r3, #2
 8002324:	18d3      	adds	r3, r2, r3
 8002326:	3308      	adds	r3, #8
 8002328:	681b      	ldr	r3, [r3, #0]
 800232a:	4a1e      	ldr	r2, [pc, #120]	; (80023a4 <GSM_File_Transfer_Seq+0x1d4>)
 800232c:	4820      	ldr	r0, [pc, #128]	; (80023b0 <GSM_File_Transfer_Seq+0x1e0>)
 800232e:	f000 fc4b 	bl	8002bc8 <app_debug_rtt_raw>
                                                            FileSend_Info.File[FileSend_Info.FileID].Name);
                Add_FileTranfer_Info_to_AT_Command(&FileSend_Info.File[FileSend_Info.FileID]);
 8002332:	4b1b      	ldr	r3, [pc, #108]	; (80023a0 <GSM_File_Transfer_Seq+0x1d0>)
 8002334:	22c9      	movs	r2, #201	; 0xc9
 8002336:	5c9b      	ldrb	r3, [r3, r2]
 8002338:	001a      	movs	r2, r3
 800233a:	0013      	movs	r3, r2
 800233c:	009b      	lsls	r3, r3, #2
 800233e:	189b      	adds	r3, r3, r2
 8002340:	009b      	lsls	r3, r3, #2
 8002342:	4a17      	ldr	r2, [pc, #92]	; (80023a0 <GSM_File_Transfer_Seq+0x1d0>)
 8002344:	189b      	adds	r3, r3, r2
 8002346:	0018      	movs	r0, r3
 8002348:	f000 f8d0 	bl	80024ec <Add_FileTranfer_Info_to_AT_Command>
                GSM_SendCommand_AT(ATC_Table_File_Tranfer[0]);
 800234c:	4b10      	ldr	r3, [pc, #64]	; (8002390 <GSM_File_Transfer_Seq+0x1c0>)
 800234e:	466a      	mov	r2, sp
 8002350:	0011      	movs	r1, r2
 8002352:	001a      	movs	r2, r3
 8002354:	3210      	adds	r2, #16
 8002356:	ca31      	ldmia	r2!, {r0, r4, r5}
 8002358:	c131      	stmia	r1!, {r0, r4, r5}
 800235a:	6812      	ldr	r2, [r2, #0]
 800235c:	600a      	str	r2, [r1, #0]
 800235e:	6818      	ldr	r0, [r3, #0]
 8002360:	6859      	ldr	r1, [r3, #4]
 8002362:	689a      	ldr	r2, [r3, #8]
 8002364:	68db      	ldr	r3, [r3, #12]
 8002366:	f7ff fb25 	bl	80019b4 <GSM_SendCommand_AT>
            }
        }
        File_Handler_Manager.step++;
 800236a:	4b07      	ldr	r3, [pc, #28]	; (8002388 <GSM_File_Transfer_Seq+0x1b8>)
 800236c:	785b      	ldrb	r3, [r3, #1]
 800236e:	3301      	adds	r3, #1
 8002370:	b2da      	uxtb	r2, r3
 8002372:	4b05      	ldr	r3, [pc, #20]	; (8002388 <GSM_File_Transfer_Seq+0x1b8>)
 8002374:	705a      	strb	r2, [r3, #1]
 8002376:	e004      	b.n	8002382 <GSM_File_Transfer_Seq+0x1b2>
    }
    else //if(event == GSM_EVENT_TIMEOUT)
    {
        GSM_Manager_ChangeState(GSM_STATE_RESET);
 8002378:	2001      	movs	r0, #1
 800237a:	f7fe ffe1 	bl	8001340 <GSM_Manager_ChangeState>
 800237e:	e000      	b.n	8002382 <GSM_File_Transfer_Seq+0x1b2>
        return;
 8002380:	46c0      	nop			; (mov r8, r8)
    }
}
 8002382:	46bd      	mov	sp, r7
 8002384:	b009      	add	sp, #36	; 0x24
 8002386:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002388:	20000e20 	.word	0x20000e20
 800238c:	08022761 	.word	0x08022761
 8002390:	08022640 	.word	0x08022640
 8002394:	0801e8cc 	.word	0x0801e8cc
 8002398:	0801e8d4 	.word	0x0801e8d4
 800239c:	0801e82c 	.word	0x0801e82c
 80023a0:	20000e24 	.word	0x20000e24
 80023a4:	0801e640 	.word	0x0801e640
 80023a8:	0801e948 	.word	0x0801e948
 80023ac:	0801e994 	.word	0x0801e994
 80023b0:	0801e90c 	.word	0x0801e90c

080023b4 <GSM_File_Download_Seq>:
void GSM_File_Download_Seq(GSM_Response_Event_TypDef event, void *Resp_Buffer)
{
 80023b4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80023b6:	b08d      	sub	sp, #52	; 0x34
 80023b8:	af04      	add	r7, sp, #16
 80023ba:	0002      	movs	r2, r0
 80023bc:	6039      	str	r1, [r7, #0]
 80023be:	1dfb      	adds	r3, r7, #7
 80023c0:	701a      	strb	r2, [r3, #0]
    uint8_t TableIndex = File_Handler_Manager.step;
 80023c2:	211f      	movs	r1, #31
 80023c4:	187b      	adds	r3, r7, r1
 80023c6:	4a3f      	ldr	r2, [pc, #252]	; (80024c4 <GSM_File_Download_Seq+0x110>)
 80023c8:	7852      	ldrb	r2, [r2, #1]
 80023ca:	701a      	strb	r2, [r3, #0]
    const static uint8_t TableSize = sizeof(ATC_Table_File_Download)/sizeof(ATC_Table_File_Download[0]);
    if(TableIndex > TableSize)
 80023cc:	4b3e      	ldr	r3, [pc, #248]	; (80024c8 <GSM_File_Download_Seq+0x114>)
 80023ce:	781b      	ldrb	r3, [r3, #0]
 80023d0:	187a      	adds	r2, r7, r1
 80023d2:	7812      	ldrb	r2, [r2, #0]
 80023d4:	429a      	cmp	r2, r3
 80023d6:	d871      	bhi.n	80024bc <GSM_File_Download_Seq+0x108>
    {
        return;
    }
    DEBUG_PrintResult_ATC(ATC_Table_File_Download[TableIndex-1].cmd, (event == GSM_EVENT_OK)?"[OK]":"[FAIL]");
 80023d8:	187b      	adds	r3, r7, r1
 80023da:	781b      	ldrb	r3, [r3, #0]
 80023dc:	1e5a      	subs	r2, r3, #1
 80023de:	4b3b      	ldr	r3, [pc, #236]	; (80024cc <GSM_File_Download_Seq+0x118>)
 80023e0:	0152      	lsls	r2, r2, #5
 80023e2:	58d2      	ldr	r2, [r2, r3]
 80023e4:	1dfb      	adds	r3, r7, #7
 80023e6:	781b      	ldrb	r3, [r3, #0]
 80023e8:	2b00      	cmp	r3, #0
 80023ea:	d101      	bne.n	80023f0 <GSM_File_Download_Seq+0x3c>
 80023ec:	4b38      	ldr	r3, [pc, #224]	; (80024d0 <GSM_File_Download_Seq+0x11c>)
 80023ee:	e000      	b.n	80023f2 <GSM_File_Download_Seq+0x3e>
 80023f0:	4b38      	ldr	r3, [pc, #224]	; (80024d4 <GSM_File_Download_Seq+0x120>)
 80023f2:	0019      	movs	r1, r3
 80023f4:	0010      	movs	r0, r2
 80023f6:	f000 fa17 	bl	8002828 <DEBUG_PrintResult_ATC>
    DEBUG_RAW("%s\r\n", (char*)Resp_Buffer);
 80023fa:	683a      	ldr	r2, [r7, #0]
 80023fc:	4b36      	ldr	r3, [pc, #216]	; (80024d8 <GSM_File_Download_Seq+0x124>)
 80023fe:	0011      	movs	r1, r2
 8002400:	0018      	movs	r0, r3
 8002402:	f000 fbe1 	bl	8002bc8 <app_debug_rtt_raw>
    if(event == GSM_EVENT_OK)
 8002406:	1dfb      	adds	r3, r7, #7
 8002408:	781b      	ldrb	r3, [r3, #0]
 800240a:	2b00      	cmp	r3, #0
 800240c:	d152      	bne.n	80024b4 <GSM_File_Download_Seq+0x100>
    {
        if(TableIndex < TableSize)
 800240e:	4b2e      	ldr	r3, [pc, #184]	; (80024c8 <GSM_File_Download_Seq+0x114>)
 8002410:	781b      	ldrb	r3, [r3, #0]
 8002412:	211f      	movs	r1, #31
 8002414:	187a      	adds	r2, r7, r1
 8002416:	7812      	ldrb	r2, [r2, #0]
 8002418:	429a      	cmp	r2, r3
 800241a:	d215      	bcs.n	8002448 <GSM_File_Download_Seq+0x94>
        {
            GSM_SendCommand_AT(ATC_Table_File_Download[TableIndex]);
 800241c:	187b      	adds	r3, r7, r1
 800241e:	781b      	ldrb	r3, [r3, #0]
 8002420:	4c2a      	ldr	r4, [pc, #168]	; (80024cc <GSM_File_Download_Seq+0x118>)
 8002422:	015b      	lsls	r3, r3, #5
 8002424:	2110      	movs	r1, #16
 8002426:	18e2      	adds	r2, r4, r3
 8002428:	1851      	adds	r1, r2, r1
 800242a:	466a      	mov	r2, sp
 800242c:	c961      	ldmia	r1!, {r0, r5, r6}
 800242e:	c261      	stmia	r2!, {r0, r5, r6}
 8002430:	6809      	ldr	r1, [r1, #0]
 8002432:	6011      	str	r1, [r2, #0]
 8002434:	5918      	ldr	r0, [r3, r4]
 8002436:	18e2      	adds	r2, r4, r3
 8002438:	6851      	ldr	r1, [r2, #4]
 800243a:	18e2      	adds	r2, r4, r3
 800243c:	6892      	ldr	r2, [r2, #8]
 800243e:	18e3      	adds	r3, r4, r3
 8002440:	68db      	ldr	r3, [r3, #12]
 8002442:	f7ff fab7 	bl	80019b4 <GSM_SendCommand_AT>
 8002446:	e02e      	b.n	80024a6 <GSM_File_Download_Seq+0xf2>
        }
        else
        {
            // Da Download File xong
            File_Handler_Manager.step = 0;
 8002448:	4b1e      	ldr	r3, [pc, #120]	; (80024c4 <GSM_File_Download_Seq+0x110>)
 800244a:	2200      	movs	r2, #0
 800244c:	705a      	strb	r2, [r3, #1]
            // Caculate File Dowload Length base on Resp_Buffer
            char* substr = "+QFTPGET: 0,";
 800244e:	4b23      	ldr	r3, [pc, #140]	; (80024dc <GSM_File_Download_Seq+0x128>)
 8002450:	61bb      	str	r3, [r7, #24]
            char* result = strstr((char*)Resp_Buffer, substr);
 8002452:	69ba      	ldr	r2, [r7, #24]
 8002454:	683b      	ldr	r3, [r7, #0]
 8002456:	0011      	movs	r1, r2
 8002458:	0018      	movs	r0, r3
 800245a:	f01a fe5d 	bl	801d118 <strstr>
 800245e:	0003      	movs	r3, r0
 8002460:	617b      	str	r3, [r7, #20]
            int position = result - (char*)Resp_Buffer;
 8002462:	697a      	ldr	r2, [r7, #20]
 8002464:	683b      	ldr	r3, [r7, #0]
 8002466:	1ad3      	subs	r3, r2, r3
 8002468:	613b      	str	r3, [r7, #16]
            int FileLength = gsm_utilities_get_number_from_string (position + strlen(substr), (char*)Resp_Buffer);
 800246a:	69bb      	ldr	r3, [r7, #24]
 800246c:	0018      	movs	r0, r3
 800246e:	f7fd fe4b 	bl	8000108 <strlen>
 8002472:	0003      	movs	r3, r0
 8002474:	b29a      	uxth	r2, r3
 8002476:	693b      	ldr	r3, [r7, #16]
 8002478:	b29b      	uxth	r3, r3
 800247a:	18d3      	adds	r3, r2, r3
 800247c:	b29b      	uxth	r3, r3
 800247e:	683a      	ldr	r2, [r7, #0]
 8002480:	0011      	movs	r1, r2
 8002482:	0018      	movs	r0, r3
 8002484:	f000 f95a 	bl	800273c <gsm_utilities_get_number_from_string>
 8002488:	0003      	movs	r3, r0
 800248a:	60fb      	str	r3, [r7, #12]
            DEBUG_INFO("File \"%s\" Download DONE, length %d bytes.\r\n", FileDownload_Info.Name, FileLength);
 800248c:	f01a fcc4 	bl	801ce18 <sys_get_tick_ms>
 8002490:	0004      	movs	r4, r0
 8002492:	4b13      	ldr	r3, [pc, #76]	; (80024e0 <GSM_File_Download_Seq+0x12c>)
 8002494:	6899      	ldr	r1, [r3, #8]
 8002496:	4a13      	ldr	r2, [pc, #76]	; (80024e4 <GSM_File_Download_Seq+0x130>)
 8002498:	4813      	ldr	r0, [pc, #76]	; (80024e8 <GSM_File_Download_Seq+0x134>)
 800249a:	68fb      	ldr	r3, [r7, #12]
 800249c:	9300      	str	r3, [sp, #0]
 800249e:	000b      	movs	r3, r1
 80024a0:	0021      	movs	r1, r4
 80024a2:	f000 fb91 	bl	8002bc8 <app_debug_rtt_raw>

        }
        File_Handler_Manager.step++;
 80024a6:	4b07      	ldr	r3, [pc, #28]	; (80024c4 <GSM_File_Download_Seq+0x110>)
 80024a8:	785b      	ldrb	r3, [r3, #1]
 80024aa:	3301      	adds	r3, #1
 80024ac:	b2da      	uxtb	r2, r3
 80024ae:	4b05      	ldr	r3, [pc, #20]	; (80024c4 <GSM_File_Download_Seq+0x110>)
 80024b0:	705a      	strb	r2, [r3, #1]
 80024b2:	e004      	b.n	80024be <GSM_File_Download_Seq+0x10a>
    }
    else //if(event == GSM_EVENT_TIMEOUT)
    {
        GSM_Manager_ChangeState(GSM_STATE_RESET);
 80024b4:	2001      	movs	r0, #1
 80024b6:	f7fe ff43 	bl	8001340 <GSM_Manager_ChangeState>
 80024ba:	e000      	b.n	80024be <GSM_File_Download_Seq+0x10a>
        return;
 80024bc:	46c0      	nop			; (mov r8, r8)
    }
}
 80024be:	46bd      	mov	sp, r7
 80024c0:	b009      	add	sp, #36	; 0x24
 80024c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80024c4:	20000e20 	.word	0x20000e20
 80024c8:	08022762 	.word	0x08022762
 80024cc:	08022720 	.word	0x08022720
 80024d0:	0801e8cc 	.word	0x0801e8cc
 80024d4:	0801e8d4 	.word	0x0801e8d4
 80024d8:	0801e9c8 	.word	0x0801e9c8
 80024dc:	0801e9d0 	.word	0x0801e9d0
 80024e0:	20000ef0 	.word	0x20000ef0
 80024e4:	0801e640 	.word	0x0801e640
 80024e8:	0801e9e0 	.word	0x0801e9e0

080024ec <Add_FileTranfer_Info_to_AT_Command>:
void Add_FileTranfer_Info_to_AT_Command(GSM_FileSend_Info_TypDef *File_Info)
{
 80024ec:	b5f0      	push	{r4, r5, r6, r7, lr}
 80024ee:	b089      	sub	sp, #36	; 0x24
 80024f0:	af06      	add	r7, sp, #24
 80024f2:	6078      	str	r0, [r7, #4]
    // Set Upload File Name
    snprintf(Upload_File_AT_Command, sizeof(Upload_File_AT_Command), "%s%s%s%d%s%d%s",
 80024f4:	687b      	ldr	r3, [r7, #4]
 80024f6:	689b      	ldr	r3, [r3, #8]
                                                                "AT+QFTPPUT=\"",
                                                                File_Info->Name,
                                                                "\",\"COM:\",",
                                                                File_Info->Index,
 80024f8:	687a      	ldr	r2, [r7, #4]
 80024fa:	8a12      	ldrh	r2, [r2, #16]
    snprintf(Upload_File_AT_Command, sizeof(Upload_File_AT_Command), "%s%s%s%d%s%d%s",
 80024fc:	0015      	movs	r5, r2
                                                                ",",
                                                                File_Info->DataLength,
 80024fe:	687a      	ldr	r2, [r7, #4]
 8002500:	8892      	ldrh	r2, [r2, #4]
    snprintf(Upload_File_AT_Command, sizeof(Upload_File_AT_Command), "%s%s%s%d%s%d%s",
 8002502:	0016      	movs	r6, r2
 8002504:	4c1c      	ldr	r4, [pc, #112]	; (8002578 <Add_FileTranfer_Info_to_AT_Command+0x8c>)
 8002506:	491d      	ldr	r1, [pc, #116]	; (800257c <Add_FileTranfer_Info_to_AT_Command+0x90>)
 8002508:	481d      	ldr	r0, [pc, #116]	; (8002580 <Add_FileTranfer_Info_to_AT_Command+0x94>)
 800250a:	4a1e      	ldr	r2, [pc, #120]	; (8002584 <Add_FileTranfer_Info_to_AT_Command+0x98>)
 800250c:	9205      	str	r2, [sp, #20]
 800250e:	9604      	str	r6, [sp, #16]
 8002510:	4a1d      	ldr	r2, [pc, #116]	; (8002588 <Add_FileTranfer_Info_to_AT_Command+0x9c>)
 8002512:	9203      	str	r2, [sp, #12]
 8002514:	9502      	str	r5, [sp, #8]
 8002516:	4a1d      	ldr	r2, [pc, #116]	; (800258c <Add_FileTranfer_Info_to_AT_Command+0xa0>)
 8002518:	9201      	str	r2, [sp, #4]
 800251a:	9300      	str	r3, [sp, #0]
 800251c:	0023      	movs	r3, r4
 800251e:	000a      	movs	r2, r1
 8002520:	2146      	movs	r1, #70	; 0x46
 8002522:	f01a fdb1 	bl	801d088 <sniprintf>
    //                                                         "AT+QFTPPUT=\"",
    //                                                         FileSend_Info.Name,
    //                                                         "\",\"COM:\",",
    //                                                         "0,20,1\r\n");                                                     
    // Set File Data to Upload
    snprintf(Upload_File_Data, sizeof(Upload_File_Data), "%s%s", File_Info->Data, "\r\n");
 8002526:	687b      	ldr	r3, [r7, #4]
 8002528:	6819      	ldr	r1, [r3, #0]
 800252a:	4a19      	ldr	r2, [pc, #100]	; (8002590 <Add_FileTranfer_Info_to_AT_Command+0xa4>)
 800252c:	4819      	ldr	r0, [pc, #100]	; (8002594 <Add_FileTranfer_Info_to_AT_Command+0xa8>)
 800252e:	4b1a      	ldr	r3, [pc, #104]	; (8002598 <Add_FileTranfer_Info_to_AT_Command+0xac>)
 8002530:	9300      	str	r3, [sp, #0]
 8002532:	000b      	movs	r3, r1
 8002534:	2132      	movs	r1, #50	; 0x32
 8002536:	f01a fda7 	bl	801d088 <sniprintf>
    // Set Commamd Get File Size
    snprintf(Get_File_Size_AT_Command, sizeof(Get_File_Size_AT_Command), "%s%s%s",
 800253a:	687b      	ldr	r3, [r7, #4]
 800253c:	689b      	ldr	r3, [r3, #8]
 800253e:	4c17      	ldr	r4, [pc, #92]	; (800259c <Add_FileTranfer_Info_to_AT_Command+0xb0>)
 8002540:	4917      	ldr	r1, [pc, #92]	; (80025a0 <Add_FileTranfer_Info_to_AT_Command+0xb4>)
 8002542:	4818      	ldr	r0, [pc, #96]	; (80025a4 <Add_FileTranfer_Info_to_AT_Command+0xb8>)
 8002544:	4a18      	ldr	r2, [pc, #96]	; (80025a8 <Add_FileTranfer_Info_to_AT_Command+0xbc>)
 8002546:	9201      	str	r2, [sp, #4]
 8002548:	9300      	str	r3, [sp, #0]
 800254a:	0023      	movs	r3, r4
 800254c:	000a      	movs	r2, r1
 800254e:	2146      	movs	r1, #70	; 0x46
 8002550:	f01a fd9a 	bl	801d088 <sniprintf>
                                                                "AT+QFTPSIZE=\"",
                                                                File_Info->Name,
                                                                "\"\r\n");
    // Set File Directory
    snprintf(Set_Directory_AT_Command, sizeof(Set_Directory_AT_Command), "%s%s%s",
 8002554:	687b      	ldr	r3, [r7, #4]
 8002556:	68db      	ldr	r3, [r3, #12]
 8002558:	4c14      	ldr	r4, [pc, #80]	; (80025ac <Add_FileTranfer_Info_to_AT_Command+0xc0>)
 800255a:	4911      	ldr	r1, [pc, #68]	; (80025a0 <Add_FileTranfer_Info_to_AT_Command+0xb4>)
 800255c:	4814      	ldr	r0, [pc, #80]	; (80025b0 <Add_FileTranfer_Info_to_AT_Command+0xc4>)
 800255e:	4a12      	ldr	r2, [pc, #72]	; (80025a8 <Add_FileTranfer_Info_to_AT_Command+0xbc>)
 8002560:	9201      	str	r2, [sp, #4]
 8002562:	9300      	str	r3, [sp, #0]
 8002564:	0023      	movs	r3, r4
 8002566:	000a      	movs	r2, r1
 8002568:	2146      	movs	r1, #70	; 0x46
 800256a:	f01a fd8d 	bl	801d088 <sniprintf>
                                                                "AT+QFTPCWD=\"",
                                                                File_Info->Directory,
                                                                "\"\r\n");
}
 800256e:	46c0      	nop			; (mov r8, r8)
 8002570:	46bd      	mov	sp, r7
 8002572:	b003      	add	sp, #12
 8002574:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002576:	46c0      	nop			; (mov r8, r8)
 8002578:	0801e874 	.word	0x0801e874
 800257c:	0801e884 	.word	0x0801e884
 8002580:	20000cbc 	.word	0x20000cbc
 8002584:	0801e894 	.word	0x0801e894
 8002588:	0801e89c 	.word	0x0801e89c
 800258c:	0801e8a0 	.word	0x0801e8a0
 8002590:	0801ea28 	.word	0x0801ea28
 8002594:	20000ddc 	.word	0x20000ddc
 8002598:	0801e7dc 	.word	0x0801e7dc
 800259c:	0801ea30 	.word	0x0801ea30
 80025a0:	0801ea40 	.word	0x0801ea40
 80025a4:	20000d4c 	.word	0x20000d4c
 80025a8:	0801e7b8 	.word	0x0801e7b8
 80025ac:	0801ea48 	.word	0x0801ea48
 80025b0:	20000d94 	.word	0x20000d94

080025b4 <Add_FileDownload_Info_to_AT_Command>:
void Add_FileDownload_Info_to_AT_Command(GSM_FileDownload_Info_TypDef *File_Info)
{
 80025b4:	b590      	push	{r4, r7, lr}
 80025b6:	b085      	sub	sp, #20
 80025b8:	af02      	add	r7, sp, #8
 80025ba:	6078      	str	r0, [r7, #4]
    snprintf(Download_File_AT_Command, sizeof(Download_File_AT_Command), "%s%s%s",
 80025bc:	687b      	ldr	r3, [r7, #4]
 80025be:	689b      	ldr	r3, [r3, #8]
 80025c0:	4c0d      	ldr	r4, [pc, #52]	; (80025f8 <Add_FileDownload_Info_to_AT_Command+0x44>)
 80025c2:	490e      	ldr	r1, [pc, #56]	; (80025fc <Add_FileDownload_Info_to_AT_Command+0x48>)
 80025c4:	480e      	ldr	r0, [pc, #56]	; (8002600 <Add_FileDownload_Info_to_AT_Command+0x4c>)
 80025c6:	4a0f      	ldr	r2, [pc, #60]	; (8002604 <Add_FileDownload_Info_to_AT_Command+0x50>)
 80025c8:	9201      	str	r2, [sp, #4]
 80025ca:	9300      	str	r3, [sp, #0]
 80025cc:	0023      	movs	r3, r4
 80025ce:	000a      	movs	r2, r1
 80025d0:	2146      	movs	r1, #70	; 0x46
 80025d2:	f01a fd59 	bl	801d088 <sniprintf>
                                                                "AT+QFTPGET=\"",
                                                                File_Info->Name,
                                                                "\",\"COM:\"\r\n");
    // Set File Directory
    snprintf(Set_Directory_AT_Command, sizeof(Set_Directory_AT_Command), "%s%s%s",
 80025d6:	687b      	ldr	r3, [r7, #4]
 80025d8:	68db      	ldr	r3, [r3, #12]
 80025da:	4c0b      	ldr	r4, [pc, #44]	; (8002608 <Add_FileDownload_Info_to_AT_Command+0x54>)
 80025dc:	4907      	ldr	r1, [pc, #28]	; (80025fc <Add_FileDownload_Info_to_AT_Command+0x48>)
 80025de:	480b      	ldr	r0, [pc, #44]	; (800260c <Add_FileDownload_Info_to_AT_Command+0x58>)
 80025e0:	4a0b      	ldr	r2, [pc, #44]	; (8002610 <Add_FileDownload_Info_to_AT_Command+0x5c>)
 80025e2:	9201      	str	r2, [sp, #4]
 80025e4:	9300      	str	r3, [sp, #0]
 80025e6:	0023      	movs	r3, r4
 80025e8:	000a      	movs	r2, r1
 80025ea:	2146      	movs	r1, #70	; 0x46
 80025ec:	f01a fd4c 	bl	801d088 <sniprintf>
                                                                "AT+QFTPCWD=\"",
                                                                File_Info->Directory,
                                                                "\"\r\n");
}
 80025f0:	46c0      	nop			; (mov r8, r8)
 80025f2:	46bd      	mov	sp, r7
 80025f4:	b003      	add	sp, #12
 80025f6:	bd90      	pop	{r4, r7, pc}
 80025f8:	0801ea58 	.word	0x0801ea58
 80025fc:	0801ea40 	.word	0x0801ea40
 8002600:	20000d04 	.word	0x20000d04
 8002604:	0801ea68 	.word	0x0801ea68
 8002608:	0801ea48 	.word	0x0801ea48
 800260c:	20000d94 	.word	0x20000d94
 8002610:	0801e7b8 	.word	0x0801e7b8

08002614 <GSM_Send_File>:
void GSM_Send_File(GSM_Multi_FileSend_Info_TypDef *File_Info)
{
 8002614:	b5b0      	push	{r4, r5, r7, lr}
 8002616:	b086      	sub	sp, #24
 8002618:	af04      	add	r7, sp, #16
 800261a:	6078      	str	r0, [r7, #4]
    memcpy(&FileSend_Info, File_Info, sizeof(GSM_Multi_FileSend_Info_TypDef));
 800261c:	6879      	ldr	r1, [r7, #4]
 800261e:	4b11      	ldr	r3, [pc, #68]	; (8002664 <GSM_Send_File+0x50>)
 8002620:	22cc      	movs	r2, #204	; 0xcc
 8002622:	0018      	movs	r0, r3
 8002624:	f01a fc52 	bl	801cecc <memcpy>
    if(File_Handler_Manager.step == 0)
 8002628:	4b0f      	ldr	r3, [pc, #60]	; (8002668 <GSM_Send_File+0x54>)
 800262a:	785b      	ldrb	r3, [r3, #1]
 800262c:	2b00      	cmp	r3, #0
 800262e:	d114      	bne.n	800265a <GSM_Send_File+0x46>
    {
        File_Handler_Manager.step = 1;
 8002630:	4b0d      	ldr	r3, [pc, #52]	; (8002668 <GSM_Send_File+0x54>)
 8002632:	2201      	movs	r2, #1
 8002634:	705a      	strb	r2, [r3, #1]
        GSM_SendCommand_AT(ATC_Table_Login_Server[0]);
 8002636:	4b0d      	ldr	r3, [pc, #52]	; (800266c <GSM_Send_File+0x58>)
 8002638:	466a      	mov	r2, sp
 800263a:	0011      	movs	r1, r2
 800263c:	001a      	movs	r2, r3
 800263e:	3210      	adds	r2, #16
 8002640:	ca31      	ldmia	r2!, {r0, r4, r5}
 8002642:	c131      	stmia	r1!, {r0, r4, r5}
 8002644:	6812      	ldr	r2, [r2, #0]
 8002646:	600a      	str	r2, [r1, #0]
 8002648:	6818      	ldr	r0, [r3, #0]
 800264a:	6859      	ldr	r1, [r3, #4]
 800264c:	689a      	ldr	r2, [r3, #8]
 800264e:	68db      	ldr	r3, [r3, #12]
 8002650:	f7ff f9b0 	bl	80019b4 <GSM_SendCommand_AT>
        File_Handler_Manager.mode = GSM_FILE_MODE_UPLOAD;
 8002654:	4b04      	ldr	r3, [pc, #16]	; (8002668 <GSM_Send_File+0x54>)
 8002656:	2200      	movs	r2, #0
 8002658:	701a      	strb	r2, [r3, #0]
    }
}
 800265a:	46c0      	nop			; (mov r8, r8)
 800265c:	46bd      	mov	sp, r7
 800265e:	b002      	add	sp, #8
 8002660:	bdb0      	pop	{r4, r5, r7, pc}
 8002662:	46c0      	nop			; (mov r8, r8)
 8002664:	20000e24 	.word	0x20000e24
 8002668:	20000e20 	.word	0x20000e20
 800266c:	08022540 	.word	0x08022540

08002670 <GSM_Utilities_Get_IMEI>:
#include "gsm_utilities.h"

void GSM_Utilities_Get_IMEI(uint8_t *recv_Buffer, uint8_t* IMEI_Buffer, uint8_t Max_IMEI_Length)
{
 8002670:	b580      	push	{r7, lr}
 8002672:	b086      	sub	sp, #24
 8002674:	af00      	add	r7, sp, #0
 8002676:	60f8      	str	r0, [r7, #12]
 8002678:	60b9      	str	r1, [r7, #8]
 800267a:	1dfb      	adds	r3, r7, #7
 800267c:	701a      	strb	r2, [r3, #0]
    int IMEI_Index = 0;
 800267e:	2300      	movs	r3, #0
 8002680:	617b      	str	r3, [r7, #20]
    for(int CountByte = 0; CountByte < strlen((char*)recv_Buffer); CountByte++)
 8002682:	2300      	movs	r3, #0
 8002684:	613b      	str	r3, [r7, #16]
 8002686:	e025      	b.n	80026d4 <GSM_Utilities_Get_IMEI+0x64>
    {
        if((recv_Buffer[CountByte] >= '0') && (recv_Buffer[CountByte] <= '9'))
 8002688:	693b      	ldr	r3, [r7, #16]
 800268a:	68fa      	ldr	r2, [r7, #12]
 800268c:	18d3      	adds	r3, r2, r3
 800268e:	781b      	ldrb	r3, [r3, #0]
 8002690:	2b2f      	cmp	r3, #47	; 0x2f
 8002692:	d91c      	bls.n	80026ce <GSM_Utilities_Get_IMEI+0x5e>
 8002694:	693b      	ldr	r3, [r7, #16]
 8002696:	68fa      	ldr	r2, [r7, #12]
 8002698:	18d3      	adds	r3, r2, r3
 800269a:	781b      	ldrb	r3, [r3, #0]
 800269c:	2b39      	cmp	r3, #57	; 0x39
 800269e:	d816      	bhi.n	80026ce <GSM_Utilities_Get_IMEI+0x5e>
        {
            if(IMEI_Index < Max_IMEI_Length)
 80026a0:	1dfb      	adds	r3, r7, #7
 80026a2:	781b      	ldrb	r3, [r3, #0]
 80026a4:	697a      	ldr	r2, [r7, #20]
 80026a6:	429a      	cmp	r2, r3
 80026a8:	da0b      	bge.n	80026c2 <GSM_Utilities_Get_IMEI+0x52>
            {
                IMEI_Buffer[IMEI_Index++] = recv_Buffer[CountByte];
 80026aa:	693b      	ldr	r3, [r7, #16]
 80026ac:	68fa      	ldr	r2, [r7, #12]
 80026ae:	18d2      	adds	r2, r2, r3
 80026b0:	697b      	ldr	r3, [r7, #20]
 80026b2:	1c59      	adds	r1, r3, #1
 80026b4:	6179      	str	r1, [r7, #20]
 80026b6:	0019      	movs	r1, r3
 80026b8:	68bb      	ldr	r3, [r7, #8]
 80026ba:	185b      	adds	r3, r3, r1
 80026bc:	7812      	ldrb	r2, [r2, #0]
 80026be:	701a      	strb	r2, [r3, #0]
 80026c0:	e005      	b.n	80026ce <GSM_Utilities_Get_IMEI+0x5e>
            }
            else
            {
                IMEI_Buffer[IMEI_Index] = 0;
 80026c2:	697b      	ldr	r3, [r7, #20]
 80026c4:	68ba      	ldr	r2, [r7, #8]
 80026c6:	18d3      	adds	r3, r2, r3
 80026c8:	2200      	movs	r2, #0
 80026ca:	701a      	strb	r2, [r3, #0]
                break;
 80026cc:	e00a      	b.n	80026e4 <GSM_Utilities_Get_IMEI+0x74>
    for(int CountByte = 0; CountByte < strlen((char*)recv_Buffer); CountByte++)
 80026ce:	693b      	ldr	r3, [r7, #16]
 80026d0:	3301      	adds	r3, #1
 80026d2:	613b      	str	r3, [r7, #16]
 80026d4:	68fb      	ldr	r3, [r7, #12]
 80026d6:	0018      	movs	r0, r3
 80026d8:	f7fd fd16 	bl	8000108 <strlen>
 80026dc:	0002      	movs	r2, r0
 80026de:	693b      	ldr	r3, [r7, #16]
 80026e0:	429a      	cmp	r2, r3
 80026e2:	d8d1      	bhi.n	8002688 <GSM_Utilities_Get_IMEI+0x18>
            }
        }
    }
    IMEI_Buffer[IMEI_Index] = 0;
 80026e4:	697b      	ldr	r3, [r7, #20]
 80026e6:	68ba      	ldr	r2, [r7, #8]
 80026e8:	18d3      	adds	r3, r2, r3
 80026ea:	2200      	movs	r2, #0
 80026ec:	701a      	strb	r2, [r3, #0]
}
 80026ee:	46c0      	nop			; (mov r8, r8)
 80026f0:	46bd      	mov	sp, r7
 80026f2:	b006      	add	sp, #24
 80026f4:	bd80      	pop	{r7, pc}
	...

080026f8 <gsm_utilities_get_signal_strength_from_buffer>:
bool gsm_utilities_get_signal_strength_from_buffer(uint8_t *buffer, uint16_t *csq)
{
 80026f8:	b580      	push	{r7, lr}
 80026fa:	b084      	sub	sp, #16
 80026fc:	af00      	add	r7, sp, #0
 80026fe:	6078      	str	r0, [r7, #4]
 8002700:	6039      	str	r1, [r7, #0]
    char *tmp_buff = strstr((char *)buffer, "+CSQ:");
 8002702:	4a0d      	ldr	r2, [pc, #52]	; (8002738 <gsm_utilities_get_signal_strength_from_buffer+0x40>)
 8002704:	687b      	ldr	r3, [r7, #4]
 8002706:	0011      	movs	r1, r2
 8002708:	0018      	movs	r0, r3
 800270a:	f01a fd05 	bl	801d118 <strstr>
 800270e:	0003      	movs	r3, r0
 8002710:	60fb      	str	r3, [r7, #12]

    if (tmp_buff == NULL)
 8002712:	68fb      	ldr	r3, [r7, #12]
 8002714:	2b00      	cmp	r3, #0
 8002716:	d101      	bne.n	800271c <gsm_utilities_get_signal_strength_from_buffer+0x24>
    {
        return false;
 8002718:	2300      	movs	r3, #0
 800271a:	e009      	b.n	8002730 <gsm_utilities_get_signal_strength_from_buffer+0x38>
    }

    *csq = gsm_utilities_get_number_from_string((uint16_t)6, tmp_buff);
 800271c:	68fb      	ldr	r3, [r7, #12]
 800271e:	0019      	movs	r1, r3
 8002720:	2006      	movs	r0, #6
 8002722:	f000 f80b 	bl	800273c <gsm_utilities_get_number_from_string>
 8002726:	0003      	movs	r3, r0
 8002728:	001a      	movs	r2, r3
 800272a:	683b      	ldr	r3, [r7, #0]
 800272c:	801a      	strh	r2, [r3, #0]
    return true;
 800272e:	2301      	movs	r3, #1
}
 8002730:	0018      	movs	r0, r3
 8002732:	46bd      	mov	sp, r7
 8002734:	b004      	add	sp, #16
 8002736:	bd80      	pop	{r7, pc}
 8002738:	0801ea74 	.word	0x0801ea74

0800273c <gsm_utilities_get_number_from_string>:
 * 	Ham doc mot so trong chuoi bat dau tu dia chi nao do.
 *	Buffer = abc124mff thi gsm_utilities_get_number_from_string(3,Buffer) = 123
 *
 */
uint16_t gsm_utilities_get_number_from_string(uint16_t begin_index, char *buffer)
{
 800273c:	b590      	push	{r4, r7, lr}
 800273e:	b085      	sub	sp, #20
 8002740:	af00      	add	r7, sp, #0
 8002742:	0002      	movs	r2, r0
 8002744:	6039      	str	r1, [r7, #0]
 8002746:	1dbb      	adds	r3, r7, #6
 8002748:	801a      	strh	r2, [r3, #0]
    // assert(buffer);

	uint16_t value = 0;
 800274a:	230e      	movs	r3, #14
 800274c:	18fb      	adds	r3, r7, r3
 800274e:	2200      	movs	r2, #0
 8002750:	801a      	strh	r2, [r3, #0]
    uint16_t tmp = begin_index;
 8002752:	230c      	movs	r3, #12
 8002754:	18fb      	adds	r3, r7, r3
 8002756:	1dba      	adds	r2, r7, #6
 8002758:	8812      	ldrh	r2, [r2, #0]
 800275a:	801a      	strh	r2, [r3, #0]
    uint32_t len = strlen(buffer);
 800275c:	683b      	ldr	r3, [r7, #0]
 800275e:	0018      	movs	r0, r3
 8002760:	f7fd fcd2 	bl	8000108 <strlen>
 8002764:	0003      	movs	r3, r0
 8002766:	60bb      	str	r3, [r7, #8]
    while (buffer[tmp] && tmp < len)
 8002768:	e029      	b.n	80027be <gsm_utilities_get_number_from_string+0x82>
    {
        if (buffer[tmp] >= '0' && buffer[tmp] <= '9')
 800276a:	200c      	movs	r0, #12
 800276c:	183b      	adds	r3, r7, r0
 800276e:	881b      	ldrh	r3, [r3, #0]
 8002770:	683a      	ldr	r2, [r7, #0]
 8002772:	18d3      	adds	r3, r2, r3
 8002774:	781b      	ldrb	r3, [r3, #0]
 8002776:	2b2f      	cmp	r3, #47	; 0x2f
 8002778:	d92e      	bls.n	80027d8 <gsm_utilities_get_number_from_string+0x9c>
 800277a:	183b      	adds	r3, r7, r0
 800277c:	881b      	ldrh	r3, [r3, #0]
 800277e:	683a      	ldr	r2, [r7, #0]
 8002780:	18d3      	adds	r3, r2, r3
 8002782:	781b      	ldrb	r3, [r3, #0]
 8002784:	2b39      	cmp	r3, #57	; 0x39
 8002786:	d827      	bhi.n	80027d8 <gsm_utilities_get_number_from_string+0x9c>
        {
            value *= 10;
 8002788:	240e      	movs	r4, #14
 800278a:	193a      	adds	r2, r7, r4
 800278c:	193b      	adds	r3, r7, r4
 800278e:	881b      	ldrh	r3, [r3, #0]
 8002790:	1c19      	adds	r1, r3, #0
 8002792:	0089      	lsls	r1, r1, #2
 8002794:	18cb      	adds	r3, r1, r3
 8002796:	18db      	adds	r3, r3, r3
 8002798:	8013      	strh	r3, [r2, #0]
            value += buffer[tmp] - 48;
 800279a:	183b      	adds	r3, r7, r0
 800279c:	881b      	ldrh	r3, [r3, #0]
 800279e:	683a      	ldr	r2, [r7, #0]
 80027a0:	18d3      	adds	r3, r2, r3
 80027a2:	781b      	ldrb	r3, [r3, #0]
 80027a4:	b29a      	uxth	r2, r3
 80027a6:	193b      	adds	r3, r7, r4
 80027a8:	881b      	ldrh	r3, [r3, #0]
 80027aa:	18d3      	adds	r3, r2, r3
 80027ac:	b29a      	uxth	r2, r3
 80027ae:	193b      	adds	r3, r7, r4
 80027b0:	3a30      	subs	r2, #48	; 0x30
 80027b2:	801a      	strh	r2, [r3, #0]
        }
        else
        {
            break;
        }
        tmp++;
 80027b4:	183b      	adds	r3, r7, r0
 80027b6:	881a      	ldrh	r2, [r3, #0]
 80027b8:	183b      	adds	r3, r7, r0
 80027ba:	3201      	adds	r2, #1
 80027bc:	801a      	strh	r2, [r3, #0]
    while (buffer[tmp] && tmp < len)
 80027be:	210c      	movs	r1, #12
 80027c0:	187b      	adds	r3, r7, r1
 80027c2:	881b      	ldrh	r3, [r3, #0]
 80027c4:	683a      	ldr	r2, [r7, #0]
 80027c6:	18d3      	adds	r3, r2, r3
 80027c8:	781b      	ldrb	r3, [r3, #0]
 80027ca:	2b00      	cmp	r3, #0
 80027cc:	d004      	beq.n	80027d8 <gsm_utilities_get_number_from_string+0x9c>
 80027ce:	187b      	adds	r3, r7, r1
 80027d0:	881b      	ldrh	r3, [r3, #0]
 80027d2:	68ba      	ldr	r2, [r7, #8]
 80027d4:	429a      	cmp	r2, r3
 80027d6:	d8c8      	bhi.n	800276a <gsm_utilities_get_number_from_string+0x2e>
    }

    return value;
 80027d8:	230e      	movs	r3, #14
 80027da:	18fb      	adds	r3, r7, r3
 80027dc:	881b      	ldrh	r3, [r3, #0]
}
 80027de:	0018      	movs	r0, r3
 80027e0:	46bd      	mov	sp, r7
 80027e2:	b005      	add	sp, #20
 80027e4:	bd90      	pop	{r4, r7, pc}

080027e6 <gsm_utilities_is_file_exist>:
/*
 * 	Ham kiem tra xem ten file co ton tai trong RespBuffer hay khong
 *
 */
bool gsm_utilities_is_file_exist(char* FileName, char *buffer)
{
 80027e6:	b580      	push	{r7, lr}
 80027e8:	b082      	sub	sp, #8
 80027ea:	af00      	add	r7, sp, #0
 80027ec:	6078      	str	r0, [r7, #4]
 80027ee:	6039      	str	r1, [r7, #0]
    return (strlen(FileName) && strlen(buffer) && strstr(buffer, FileName));
 80027f0:	687b      	ldr	r3, [r7, #4]
 80027f2:	781b      	ldrb	r3, [r3, #0]
 80027f4:	2b00      	cmp	r3, #0
 80027f6:	d00d      	beq.n	8002814 <gsm_utilities_is_file_exist+0x2e>
 80027f8:	683b      	ldr	r3, [r7, #0]
 80027fa:	781b      	ldrb	r3, [r3, #0]
 80027fc:	2b00      	cmp	r3, #0
 80027fe:	d009      	beq.n	8002814 <gsm_utilities_is_file_exist+0x2e>
 8002800:	687a      	ldr	r2, [r7, #4]
 8002802:	683b      	ldr	r3, [r7, #0]
 8002804:	0011      	movs	r1, r2
 8002806:	0018      	movs	r0, r3
 8002808:	f01a fc86 	bl	801d118 <strstr>
 800280c:	1e03      	subs	r3, r0, #0
 800280e:	d001      	beq.n	8002814 <gsm_utilities_is_file_exist+0x2e>
 8002810:	2301      	movs	r3, #1
 8002812:	e000      	b.n	8002816 <gsm_utilities_is_file_exist+0x30>
 8002814:	2300      	movs	r3, #0
 8002816:	1c1a      	adds	r2, r3, #0
 8002818:	2301      	movs	r3, #1
 800281a:	4013      	ands	r3, r2
 800281c:	b2db      	uxtb	r3, r3
}
 800281e:	0018      	movs	r0, r3
 8002820:	46bd      	mov	sp, r7
 8002822:	b002      	add	sp, #8
 8002824:	bd80      	pop	{r7, pc}
	...

08002828 <DEBUG_PrintResult_ATC>:

void DEBUG_PrintResult_ATC(char* cmd, char* result)
{
 8002828:	b5b0      	push	{r4, r5, r7, lr}
 800282a:	b094      	sub	sp, #80	; 0x50
 800282c:	af02      	add	r7, sp, #8
 800282e:	6078      	str	r0, [r7, #4]
 8002830:	6039      	str	r1, [r7, #0]
    // In ket qua: "AT cmd: OK/FAIL " trong debug
    char sub_cmd[64] = "";
 8002832:	2408      	movs	r4, #8
 8002834:	193b      	adds	r3, r7, r4
 8002836:	2200      	movs	r2, #0
 8002838:	601a      	str	r2, [r3, #0]
 800283a:	3304      	adds	r3, #4
 800283c:	223c      	movs	r2, #60	; 0x3c
 800283e:	2100      	movs	r1, #0
 8002840:	0018      	movs	r0, r3
 8002842:	f01a fb5f 	bl	801cf04 <memset>
    strncpy(sub_cmd, cmd + 0, strlen(cmd) - 2);
 8002846:	687b      	ldr	r3, [r7, #4]
 8002848:	0018      	movs	r0, r3
 800284a:	f7fd fc5d 	bl	8000108 <strlen>
 800284e:	0003      	movs	r3, r0
 8002850:	1e9a      	subs	r2, r3, #2
 8002852:	6879      	ldr	r1, [r7, #4]
 8002854:	0025      	movs	r5, r4
 8002856:	193b      	adds	r3, r7, r4
 8002858:	0018      	movs	r0, r3
 800285a:	f01a fc49 	bl	801d0f0 <strncpy>
    DEBUG_INFO("%s : %s\r\n", sub_cmd, result);
 800285e:	f01a fadb 	bl	801ce18 <sys_get_tick_ms>
 8002862:	0004      	movs	r4, r0
 8002864:	1979      	adds	r1, r7, r5
 8002866:	4a06      	ldr	r2, [pc, #24]	; (8002880 <DEBUG_PrintResult_ATC+0x58>)
 8002868:	4806      	ldr	r0, [pc, #24]	; (8002884 <DEBUG_PrintResult_ATC+0x5c>)
 800286a:	683b      	ldr	r3, [r7, #0]
 800286c:	9300      	str	r3, [sp, #0]
 800286e:	000b      	movs	r3, r1
 8002870:	0021      	movs	r1, r4
 8002872:	f000 f9a9 	bl	8002bc8 <app_debug_rtt_raw>
}
 8002876:	46c0      	nop			; (mov r8, r8)
 8002878:	46bd      	mov	sp, r7
 800287a:	b012      	add	sp, #72	; 0x48
 800287c:	bdb0      	pop	{r4, r5, r7, pc}
 800287e:	46c0      	nop			; (mov r8, r8)
 8002880:	0801ea7c 	.word	0x0801ea7c
 8002884:	0801ea80 	.word	0x0801ea80

08002888 <_DoInit>:
                      _DoInit();                                                                     \
                    }                                                                                \
                  } while (0);                                                                       \
                }

static void _DoInit(void) {
 8002888:	b580      	push	{r7, lr}
 800288a:	b082      	sub	sp, #8
 800288c:	af00      	add	r7, sp, #0
  volatile SEGGER_RTT_CB* p;   // Volatile to make sure that compiler cannot change the order of accesses to the control block
  //
  // Initialize control block
  //
  p                     = (volatile SEGGER_RTT_CB*)((char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access control block uncached so that nothing in the cache ever becomes dirty and all changes are visible in HW directly
 800288e:	4b22      	ldr	r3, [pc, #136]	; (8002918 <_DoInit+0x90>)
 8002890:	607b      	str	r3, [r7, #4]
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
 8002892:	687b      	ldr	r3, [r7, #4]
 8002894:	2201      	movs	r2, #1
 8002896:	611a      	str	r2, [r3, #16]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
 8002898:	687b      	ldr	r3, [r7, #4]
 800289a:	2201      	movs	r2, #1
 800289c:	615a      	str	r2, [r3, #20]
  //
  // Initialize up buffer 0
  //
  p->aUp[0].sName         = "Terminal";
 800289e:	687b      	ldr	r3, [r7, #4]
 80028a0:	4a1e      	ldr	r2, [pc, #120]	; (800291c <_DoInit+0x94>)
 80028a2:	619a      	str	r2, [r3, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
 80028a4:	687b      	ldr	r3, [r7, #4]
 80028a6:	4a1e      	ldr	r2, [pc, #120]	; (8002920 <_DoInit+0x98>)
 80028a8:	61da      	str	r2, [r3, #28]
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
 80028aa:	687b      	ldr	r3, [r7, #4]
 80028ac:	2280      	movs	r2, #128	; 0x80
 80028ae:	0092      	lsls	r2, r2, #2
 80028b0:	621a      	str	r2, [r3, #32]
  p->aUp[0].RdOff         = 0u;
 80028b2:	687b      	ldr	r3, [r7, #4]
 80028b4:	2200      	movs	r2, #0
 80028b6:	629a      	str	r2, [r3, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
 80028b8:	687b      	ldr	r3, [r7, #4]
 80028ba:	2200      	movs	r2, #0
 80028bc:	625a      	str	r2, [r3, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
 80028be:	687b      	ldr	r3, [r7, #4]
 80028c0:	2200      	movs	r2, #0
 80028c2:	62da      	str	r2, [r3, #44]	; 0x2c
  //
  // Initialize down buffer 0
  //
  p->aDown[0].sName         = "Terminal";
 80028c4:	687b      	ldr	r3, [r7, #4]
 80028c6:	4a15      	ldr	r2, [pc, #84]	; (800291c <_DoInit+0x94>)
 80028c8:	631a      	str	r2, [r3, #48]	; 0x30
  p->aDown[0].pBuffer       = _acDownBuffer;
 80028ca:	687b      	ldr	r3, [r7, #4]
 80028cc:	4a15      	ldr	r2, [pc, #84]	; (8002924 <_DoInit+0x9c>)
 80028ce:	635a      	str	r2, [r3, #52]	; 0x34
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
 80028d0:	687b      	ldr	r3, [r7, #4]
 80028d2:	2240      	movs	r2, #64	; 0x40
 80028d4:	639a      	str	r2, [r3, #56]	; 0x38
  p->aDown[0].RdOff         = 0u;
 80028d6:	687b      	ldr	r3, [r7, #4]
 80028d8:	2200      	movs	r2, #0
 80028da:	641a      	str	r2, [r3, #64]	; 0x40
  p->aDown[0].WrOff         = 0u;
 80028dc:	687b      	ldr	r3, [r7, #4]
 80028de:	2200      	movs	r2, #0
 80028e0:	63da      	str	r2, [r3, #60]	; 0x3c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
 80028e2:	687b      	ldr	r3, [r7, #4]
 80028e4:	2200      	movs	r2, #0
 80028e6:	645a      	str	r2, [r3, #68]	; 0x44
  //
  // Finish initialization of the control block.
  // Copy Id string in three steps to make sure "SEGGER RTT" is not found
  // in initializer memory (usually flash) by J-Link
  //
  STRCPY((char*)&p->acID[7], "RTT");
 80028e8:	687b      	ldr	r3, [r7, #4]
 80028ea:	1dda      	adds	r2, r3, #7
 80028ec:	4b0e      	ldr	r3, [pc, #56]	; (8002928 <_DoInit+0xa0>)
 80028ee:	0010      	movs	r0, r2
 80028f0:	0019      	movs	r1, r3
 80028f2:	2304      	movs	r3, #4
 80028f4:	001a      	movs	r2, r3
 80028f6:	f01a fae9 	bl	801cecc <memcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
  STRCPY((char*)&p->acID[0], "SEGGER");
 80028fa:	687a      	ldr	r2, [r7, #4]
 80028fc:	4b0b      	ldr	r3, [pc, #44]	; (800292c <_DoInit+0xa4>)
 80028fe:	0010      	movs	r0, r2
 8002900:	0019      	movs	r1, r3
 8002902:	2307      	movs	r3, #7
 8002904:	001a      	movs	r2, r3
 8002906:	f01a fae1 	bl	801cecc <memcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
  p->acID[6] = ' ';
 800290a:	687b      	ldr	r3, [r7, #4]
 800290c:	2220      	movs	r2, #32
 800290e:	719a      	strb	r2, [r3, #6]
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
}
 8002910:	46c0      	nop			; (mov r8, r8)
 8002912:	46bd      	mov	sp, r7
 8002914:	b002      	add	sp, #8
 8002916:	bd80      	pop	{r7, pc}
 8002918:	200018b0 	.word	0x200018b0
 800291c:	0801eaa4 	.word	0x0801eaa4
 8002920:	20000f04 	.word	0x20000f04
 8002924:	20001104 	.word	0x20001104
 8002928:	0801eab0 	.word	0x0801eab0
 800292c:	0801eab4 	.word	0x0801eab4

08002930 <_WriteBlocking>:
*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
*
*  Return value
*    >= 0 - Number of bytes written into buffer.
*/
static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
 8002930:	b580      	push	{r7, lr}
 8002932:	b08a      	sub	sp, #40	; 0x28
 8002934:	af00      	add	r7, sp, #0
 8002936:	60f8      	str	r0, [r7, #12]
 8002938:	60b9      	str	r1, [r7, #8]
 800293a:	607a      	str	r2, [r7, #4]
  unsigned WrOff;
  volatile char* pDst;
  //
  // Write data to buffer and handle wrap-around if necessary
  //
  NumBytesWritten = 0u;
 800293c:	2300      	movs	r3, #0
 800293e:	623b      	str	r3, [r7, #32]
  WrOff = pRing->WrOff;
 8002940:	68fb      	ldr	r3, [r7, #12]
 8002942:	68db      	ldr	r3, [r3, #12]
 8002944:	61fb      	str	r3, [r7, #28]
  do {
    RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
 8002946:	68fb      	ldr	r3, [r7, #12]
 8002948:	691b      	ldr	r3, [r3, #16]
 800294a:	61bb      	str	r3, [r7, #24]
    if (RdOff > WrOff) {
 800294c:	69ba      	ldr	r2, [r7, #24]
 800294e:	69fb      	ldr	r3, [r7, #28]
 8002950:	429a      	cmp	r2, r3
 8002952:	d905      	bls.n	8002960 <_WriteBlocking+0x30>
      NumBytesToWrite = RdOff - WrOff - 1u;
 8002954:	69ba      	ldr	r2, [r7, #24]
 8002956:	69fb      	ldr	r3, [r7, #28]
 8002958:	1ad3      	subs	r3, r2, r3
 800295a:	3b01      	subs	r3, #1
 800295c:	627b      	str	r3, [r7, #36]	; 0x24
 800295e:	e007      	b.n	8002970 <_WriteBlocking+0x40>
    } else {
      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
 8002960:	68fb      	ldr	r3, [r7, #12]
 8002962:	689a      	ldr	r2, [r3, #8]
 8002964:	69b9      	ldr	r1, [r7, #24]
 8002966:	69fb      	ldr	r3, [r7, #28]
 8002968:	1acb      	subs	r3, r1, r3
 800296a:	18d3      	adds	r3, r2, r3
 800296c:	3b01      	subs	r3, #1
 800296e:	627b      	str	r3, [r7, #36]	; 0x24
    }
    NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
 8002970:	68fb      	ldr	r3, [r7, #12]
 8002972:	689a      	ldr	r2, [r3, #8]
 8002974:	69fb      	ldr	r3, [r7, #28]
 8002976:	1ad2      	subs	r2, r2, r3
 8002978:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800297a:	4293      	cmp	r3, r2
 800297c:	d900      	bls.n	8002980 <_WriteBlocking+0x50>
 800297e:	0013      	movs	r3, r2
 8002980:	627b      	str	r3, [r7, #36]	; 0x24
    NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
 8002982:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8002984:	687b      	ldr	r3, [r7, #4]
 8002986:	4293      	cmp	r3, r2
 8002988:	d900      	bls.n	800298c <_WriteBlocking+0x5c>
 800298a:	0013      	movs	r3, r2
 800298c:	627b      	str	r3, [r7, #36]	; 0x24
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
 800298e:	68fb      	ldr	r3, [r7, #12]
 8002990:	685a      	ldr	r2, [r3, #4]
 8002992:	69fb      	ldr	r3, [r7, #28]
 8002994:	18d3      	adds	r3, r2, r3
 8002996:	617b      	str	r3, [r7, #20]
    WrOff           += NumBytesToWrite;
    while (NumBytesToWrite--) {
      *pDst++ = *pBuffer++;
    };
#else
    SEGGER_RTT_MEMCPY((void*)pDst, pBuffer, NumBytesToWrite);
 8002998:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800299a:	68b9      	ldr	r1, [r7, #8]
 800299c:	697b      	ldr	r3, [r7, #20]
 800299e:	0018      	movs	r0, r3
 80029a0:	f01a fa94 	bl	801cecc <memcpy>
    NumBytesWritten += NumBytesToWrite;
 80029a4:	6a3a      	ldr	r2, [r7, #32]
 80029a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80029a8:	18d3      	adds	r3, r2, r3
 80029aa:	623b      	str	r3, [r7, #32]
    pBuffer         += NumBytesToWrite;
 80029ac:	68ba      	ldr	r2, [r7, #8]
 80029ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80029b0:	18d3      	adds	r3, r2, r3
 80029b2:	60bb      	str	r3, [r7, #8]
    NumBytes        -= NumBytesToWrite;
 80029b4:	687a      	ldr	r2, [r7, #4]
 80029b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80029b8:	1ad3      	subs	r3, r2, r3
 80029ba:	607b      	str	r3, [r7, #4]
    WrOff           += NumBytesToWrite;
 80029bc:	69fa      	ldr	r2, [r7, #28]
 80029be:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80029c0:	18d3      	adds	r3, r2, r3
 80029c2:	61fb      	str	r3, [r7, #28]
#endif
    if (WrOff == pRing->SizeOfBuffer) {
 80029c4:	68fb      	ldr	r3, [r7, #12]
 80029c6:	689b      	ldr	r3, [r3, #8]
 80029c8:	69fa      	ldr	r2, [r7, #28]
 80029ca:	429a      	cmp	r2, r3
 80029cc:	d101      	bne.n	80029d2 <_WriteBlocking+0xa2>
      WrOff = 0u;
 80029ce:	2300      	movs	r3, #0
 80029d0:	61fb      	str	r3, [r7, #28]
    }
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    pRing->WrOff = WrOff;
 80029d2:	68fb      	ldr	r3, [r7, #12]
 80029d4:	69fa      	ldr	r2, [r7, #28]
 80029d6:	60da      	str	r2, [r3, #12]
  } while (NumBytes);
 80029d8:	687b      	ldr	r3, [r7, #4]
 80029da:	2b00      	cmp	r3, #0
 80029dc:	d1b3      	bne.n	8002946 <_WriteBlocking+0x16>
  return NumBytesWritten;
 80029de:	6a3b      	ldr	r3, [r7, #32]
}
 80029e0:	0018      	movs	r0, r3
 80029e2:	46bd      	mov	sp, r7
 80029e4:	b00a      	add	sp, #40	; 0x28
 80029e6:	bd80      	pop	{r7, pc}

080029e8 <_WriteNoCheck>:
*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
*
*  Notes
*    (1) If there might not be enough space in the "Up"-buffer, call _WriteBlocking
*/
static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
 80029e8:	b580      	push	{r7, lr}
 80029ea:	b088      	sub	sp, #32
 80029ec:	af00      	add	r7, sp, #0
 80029ee:	60f8      	str	r0, [r7, #12]
 80029f0:	60b9      	str	r1, [r7, #8]
 80029f2:	607a      	str	r2, [r7, #4]
  unsigned NumBytesAtOnce;
  unsigned WrOff;
  unsigned Rem;
  volatile char* pDst;

  WrOff = pRing->WrOff;
 80029f4:	68fb      	ldr	r3, [r7, #12]
 80029f6:	68db      	ldr	r3, [r3, #12]
 80029f8:	61fb      	str	r3, [r7, #28]
  Rem = pRing->SizeOfBuffer - WrOff;
 80029fa:	68fb      	ldr	r3, [r7, #12]
 80029fc:	689a      	ldr	r2, [r3, #8]
 80029fe:	69fb      	ldr	r3, [r7, #28]
 8002a00:	1ad3      	subs	r3, r2, r3
 8002a02:	61bb      	str	r3, [r7, #24]
  if (Rem > NumBytes) {
 8002a04:	69ba      	ldr	r2, [r7, #24]
 8002a06:	687b      	ldr	r3, [r7, #4]
 8002a08:	429a      	cmp	r2, r3
 8002a0a:	d910      	bls.n	8002a2e <_WriteNoCheck+0x46>
    //
    // All data fits before wrap around
    //
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
 8002a0c:	68fb      	ldr	r3, [r7, #12]
 8002a0e:	685a      	ldr	r2, [r3, #4]
 8002a10:	69fb      	ldr	r3, [r7, #28]
 8002a12:	18d3      	adds	r3, r2, r3
 8002a14:	613b      	str	r3, [r7, #16]
      *pDst++ = *pData++;
    };
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    pRing->WrOff = WrOff;
#else
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytes);
 8002a16:	687a      	ldr	r2, [r7, #4]
 8002a18:	68b9      	ldr	r1, [r7, #8]
 8002a1a:	693b      	ldr	r3, [r7, #16]
 8002a1c:	0018      	movs	r0, r3
 8002a1e:	f01a fa55 	bl	801cecc <memcpy>
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    pRing->WrOff = WrOff + NumBytes;
 8002a22:	69fa      	ldr	r2, [r7, #28]
 8002a24:	687b      	ldr	r3, [r7, #4]
 8002a26:	18d2      	adds	r2, r2, r3
 8002a28:	68fb      	ldr	r3, [r7, #12]
 8002a2a:	60da      	str	r2, [r3, #12]
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    pRing->WrOff = NumBytesAtOnce;
#endif
  }
}
 8002a2c:	e01e      	b.n	8002a6c <_WriteNoCheck+0x84>
    NumBytesAtOnce = Rem;
 8002a2e:	69bb      	ldr	r3, [r7, #24]
 8002a30:	617b      	str	r3, [r7, #20]
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
 8002a32:	68fb      	ldr	r3, [r7, #12]
 8002a34:	685a      	ldr	r2, [r3, #4]
 8002a36:	69fb      	ldr	r3, [r7, #28]
 8002a38:	18d3      	adds	r3, r2, r3
 8002a3a:	613b      	str	r3, [r7, #16]
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytesAtOnce);
 8002a3c:	697a      	ldr	r2, [r7, #20]
 8002a3e:	68b9      	ldr	r1, [r7, #8]
 8002a40:	693b      	ldr	r3, [r7, #16]
 8002a42:	0018      	movs	r0, r3
 8002a44:	f01a fa42 	bl	801cecc <memcpy>
    NumBytesAtOnce = NumBytes - Rem;
 8002a48:	687a      	ldr	r2, [r7, #4]
 8002a4a:	69bb      	ldr	r3, [r7, #24]
 8002a4c:	1ad3      	subs	r3, r2, r3
 8002a4e:	617b      	str	r3, [r7, #20]
    pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
 8002a50:	68fb      	ldr	r3, [r7, #12]
 8002a52:	685b      	ldr	r3, [r3, #4]
 8002a54:	613b      	str	r3, [r7, #16]
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
 8002a56:	68ba      	ldr	r2, [r7, #8]
 8002a58:	69bb      	ldr	r3, [r7, #24]
 8002a5a:	18d1      	adds	r1, r2, r3
 8002a5c:	697a      	ldr	r2, [r7, #20]
 8002a5e:	693b      	ldr	r3, [r7, #16]
 8002a60:	0018      	movs	r0, r3
 8002a62:	f01a fa33 	bl	801cecc <memcpy>
    pRing->WrOff = NumBytesAtOnce;
 8002a66:	68fb      	ldr	r3, [r7, #12]
 8002a68:	697a      	ldr	r2, [r7, #20]
 8002a6a:	60da      	str	r2, [r3, #12]
}
 8002a6c:	46c0      	nop			; (mov r8, r8)
 8002a6e:	46bd      	mov	sp, r7
 8002a70:	b008      	add	sp, #32
 8002a72:	bd80      	pop	{r7, pc}

08002a74 <_GetAvailWriteSpace>:
*    pRing        Ring buffer to check.
*
*  Return value
*    Number of bytes that are free in the buffer.
*/
static unsigned _GetAvailWriteSpace(SEGGER_RTT_BUFFER_UP* pRing) {
 8002a74:	b580      	push	{r7, lr}
 8002a76:	b086      	sub	sp, #24
 8002a78:	af00      	add	r7, sp, #0
 8002a7a:	6078      	str	r0, [r7, #4]
  unsigned r;
  //
  // Avoid warnings regarding volatile access order.  It's not a problem
  // in this case, but dampen compiler enthusiasm.
  //
  RdOff = pRing->RdOff;
 8002a7c:	687b      	ldr	r3, [r7, #4]
 8002a7e:	691b      	ldr	r3, [r3, #16]
 8002a80:	613b      	str	r3, [r7, #16]
  WrOff = pRing->WrOff;
 8002a82:	687b      	ldr	r3, [r7, #4]
 8002a84:	68db      	ldr	r3, [r3, #12]
 8002a86:	60fb      	str	r3, [r7, #12]
  if (RdOff <= WrOff) {
 8002a88:	693a      	ldr	r2, [r7, #16]
 8002a8a:	68fb      	ldr	r3, [r7, #12]
 8002a8c:	429a      	cmp	r2, r3
 8002a8e:	d808      	bhi.n	8002aa2 <_GetAvailWriteSpace+0x2e>
    r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
 8002a90:	687b      	ldr	r3, [r7, #4]
 8002a92:	689a      	ldr	r2, [r3, #8]
 8002a94:	68fb      	ldr	r3, [r7, #12]
 8002a96:	1ad2      	subs	r2, r2, r3
 8002a98:	693b      	ldr	r3, [r7, #16]
 8002a9a:	18d3      	adds	r3, r2, r3
 8002a9c:	3b01      	subs	r3, #1
 8002a9e:	617b      	str	r3, [r7, #20]
 8002aa0:	e004      	b.n	8002aac <_GetAvailWriteSpace+0x38>
  } else {
    r = RdOff - WrOff - 1u;
 8002aa2:	693a      	ldr	r2, [r7, #16]
 8002aa4:	68fb      	ldr	r3, [r7, #12]
 8002aa6:	1ad3      	subs	r3, r2, r3
 8002aa8:	3b01      	subs	r3, #1
 8002aaa:	617b      	str	r3, [r7, #20]
  }
  return r;
 8002aac:	697b      	ldr	r3, [r7, #20]
}
 8002aae:	0018      	movs	r0, r3
 8002ab0:	46bd      	mov	sp, r7
 8002ab2:	b006      	add	sp, #24
 8002ab4:	bd80      	pop	{r7, pc}
	...

08002ab8 <SEGGER_RTT_WriteNoLock>:
*    (1) Data is stored according to buffer flags.
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
 8002ab8:	b580      	push	{r7, lr}
 8002aba:	b088      	sub	sp, #32
 8002abc:	af00      	add	r7, sp, #0
 8002abe:	60f8      	str	r0, [r7, #12]
 8002ac0:	60b9      	str	r1, [r7, #8]
 8002ac2:	607a      	str	r2, [r7, #4]
  const char*           pData;
  SEGGER_RTT_BUFFER_UP* pRing;
  //
  // Get "to-host" ring buffer.
  //
  pData = (const char *)pBuffer;
 8002ac4:	68bb      	ldr	r3, [r7, #8]
 8002ac6:	61bb      	str	r3, [r7, #24]
  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
 8002ac8:	68fb      	ldr	r3, [r7, #12]
 8002aca:	1c5a      	adds	r2, r3, #1
 8002acc:	0013      	movs	r3, r2
 8002ace:	005b      	lsls	r3, r3, #1
 8002ad0:	189b      	adds	r3, r3, r2
 8002ad2:	00db      	lsls	r3, r3, #3
 8002ad4:	4a23      	ldr	r2, [pc, #140]	; (8002b64 <SEGGER_RTT_WriteNoLock+0xac>)
 8002ad6:	189b      	adds	r3, r3, r2
 8002ad8:	617b      	str	r3, [r7, #20]
  //
  // How we output depends upon the mode...
  //
  switch (pRing->Flags) {
 8002ada:	697b      	ldr	r3, [r7, #20]
 8002adc:	695b      	ldr	r3, [r3, #20]
 8002ade:	2b02      	cmp	r3, #2
 8002ae0:	d02e      	beq.n	8002b40 <SEGGER_RTT_WriteNoLock+0x88>
 8002ae2:	d836      	bhi.n	8002b52 <SEGGER_RTT_WriteNoLock+0x9a>
 8002ae4:	2b00      	cmp	r3, #0
 8002ae6:	d002      	beq.n	8002aee <SEGGER_RTT_WriteNoLock+0x36>
 8002ae8:	2b01      	cmp	r3, #1
 8002aea:	d016      	beq.n	8002b1a <SEGGER_RTT_WriteNoLock+0x62>
 8002aec:	e031      	b.n	8002b52 <SEGGER_RTT_WriteNoLock+0x9a>
  case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
    //
    // If we are in skip mode and there is no space for the whole
    // of this output, don't bother.
    //
    Avail = _GetAvailWriteSpace(pRing);
 8002aee:	697b      	ldr	r3, [r7, #20]
 8002af0:	0018      	movs	r0, r3
 8002af2:	f7ff ffbf 	bl	8002a74 <_GetAvailWriteSpace>
 8002af6:	0003      	movs	r3, r0
 8002af8:	613b      	str	r3, [r7, #16]
    if (Avail < NumBytes) {
 8002afa:	693a      	ldr	r2, [r7, #16]
 8002afc:	687b      	ldr	r3, [r7, #4]
 8002afe:	429a      	cmp	r2, r3
 8002b00:	d202      	bcs.n	8002b08 <SEGGER_RTT_WriteNoLock+0x50>
      Status = 0u;
 8002b02:	2300      	movs	r3, #0
 8002b04:	61fb      	str	r3, [r7, #28]
    } else {
      Status = NumBytes;
      _WriteNoCheck(pRing, pData, NumBytes);
    }
    break;
 8002b06:	e027      	b.n	8002b58 <SEGGER_RTT_WriteNoLock+0xa0>
      Status = NumBytes;
 8002b08:	687b      	ldr	r3, [r7, #4]
 8002b0a:	61fb      	str	r3, [r7, #28]
      _WriteNoCheck(pRing, pData, NumBytes);
 8002b0c:	687a      	ldr	r2, [r7, #4]
 8002b0e:	69b9      	ldr	r1, [r7, #24]
 8002b10:	697b      	ldr	r3, [r7, #20]
 8002b12:	0018      	movs	r0, r3
 8002b14:	f7ff ff68 	bl	80029e8 <_WriteNoCheck>
    break;
 8002b18:	e01e      	b.n	8002b58 <SEGGER_RTT_WriteNoLock+0xa0>
  case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
    //
    // If we are in trim mode, trim to what we can output without blocking.
    //
    Avail = _GetAvailWriteSpace(pRing);
 8002b1a:	697b      	ldr	r3, [r7, #20]
 8002b1c:	0018      	movs	r0, r3
 8002b1e:	f7ff ffa9 	bl	8002a74 <_GetAvailWriteSpace>
 8002b22:	0003      	movs	r3, r0
 8002b24:	613b      	str	r3, [r7, #16]
    Status = Avail < NumBytes ? Avail : NumBytes;
 8002b26:	693a      	ldr	r2, [r7, #16]
 8002b28:	687b      	ldr	r3, [r7, #4]
 8002b2a:	4293      	cmp	r3, r2
 8002b2c:	d900      	bls.n	8002b30 <SEGGER_RTT_WriteNoLock+0x78>
 8002b2e:	0013      	movs	r3, r2
 8002b30:	61fb      	str	r3, [r7, #28]
    _WriteNoCheck(pRing, pData, Status);
 8002b32:	69fa      	ldr	r2, [r7, #28]
 8002b34:	69b9      	ldr	r1, [r7, #24]
 8002b36:	697b      	ldr	r3, [r7, #20]
 8002b38:	0018      	movs	r0, r3
 8002b3a:	f7ff ff55 	bl	80029e8 <_WriteNoCheck>
    break;
 8002b3e:	e00b      	b.n	8002b58 <SEGGER_RTT_WriteNoLock+0xa0>
  case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
    //
    // If we are in blocking mode, output everything.
    //
    Status = _WriteBlocking(pRing, pData, NumBytes);
 8002b40:	687a      	ldr	r2, [r7, #4]
 8002b42:	69b9      	ldr	r1, [r7, #24]
 8002b44:	697b      	ldr	r3, [r7, #20]
 8002b46:	0018      	movs	r0, r3
 8002b48:	f7ff fef2 	bl	8002930 <_WriteBlocking>
 8002b4c:	0003      	movs	r3, r0
 8002b4e:	61fb      	str	r3, [r7, #28]
    break;
 8002b50:	e002      	b.n	8002b58 <SEGGER_RTT_WriteNoLock+0xa0>
  default:
    Status = 0u;
 8002b52:	2300      	movs	r3, #0
 8002b54:	61fb      	str	r3, [r7, #28]
    break;
 8002b56:	46c0      	nop			; (mov r8, r8)
  }
  //
  // Finish up.
  //
  return Status;
 8002b58:	69fb      	ldr	r3, [r7, #28]
}
 8002b5a:	0018      	movs	r0, r3
 8002b5c:	46bd      	mov	sp, r7
 8002b5e:	b008      	add	sp, #32
 8002b60:	bd80      	pop	{r7, pc}
 8002b62:	46c0      	nop			; (mov r8, r8)
 8002b64:	200018b0 	.word	0x200018b0

08002b68 <SEGGER_RTT_Write>:
*    Number of bytes which have been stored in the "Up"-buffer.
*
*  Notes
*    (1) Data is stored according to buffer flags.
*/
unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
 8002b68:	b580      	push	{r7, lr}
 8002b6a:	b088      	sub	sp, #32
 8002b6c:	af00      	add	r7, sp, #0
 8002b6e:	60f8      	str	r0, [r7, #12]
 8002b70:	60b9      	str	r1, [r7, #8]
 8002b72:	607a      	str	r2, [r7, #4]
  unsigned Status;

  INIT();
 8002b74:	4b0f      	ldr	r3, [pc, #60]	; (8002bb4 <SEGGER_RTT_Write+0x4c>)
 8002b76:	61fb      	str	r3, [r7, #28]
 8002b78:	69fb      	ldr	r3, [r7, #28]
 8002b7a:	781b      	ldrb	r3, [r3, #0]
 8002b7c:	b2db      	uxtb	r3, r3
 8002b7e:	2b00      	cmp	r3, #0
 8002b80:	d101      	bne.n	8002b86 <SEGGER_RTT_Write+0x1e>
 8002b82:	f7ff fe81 	bl	8002888 <_DoInit>
  SEGGER_RTT_LOCK();
 8002b86:	f3ef 8310 	mrs	r3, PRIMASK
 8002b8a:	2101      	movs	r1, #1
 8002b8c:	f381 8810 	msr	PRIMASK, r1
 8002b90:	61bb      	str	r3, [r7, #24]
  Status = SEGGER_RTT_WriteNoLock(BufferIndex, pBuffer, NumBytes);  // Call the non-locking write function
 8002b92:	687a      	ldr	r2, [r7, #4]
 8002b94:	68b9      	ldr	r1, [r7, #8]
 8002b96:	68fb      	ldr	r3, [r7, #12]
 8002b98:	0018      	movs	r0, r3
 8002b9a:	f7ff ff8d 	bl	8002ab8 <SEGGER_RTT_WriteNoLock>
 8002b9e:	0003      	movs	r3, r0
 8002ba0:	617b      	str	r3, [r7, #20]
  SEGGER_RTT_UNLOCK();
 8002ba2:	69bb      	ldr	r3, [r7, #24]
 8002ba4:	f383 8810 	msr	PRIMASK, r3
  return Status;
 8002ba8:	697b      	ldr	r3, [r7, #20]
}
 8002baa:	0018      	movs	r0, r3
 8002bac:	46bd      	mov	sp, r7
 8002bae:	b008      	add	sp, #32
 8002bb0:	bd80      	pop	{r7, pc}
 8002bb2:	46c0      	nop			; (mov r8, r8)
 8002bb4:	200018b0 	.word	0x200018b0

08002bb8 <SEGGER_RTT_Init>:
*  Function description
*    Initializes the RTT Control Block.
*    Should be used in RAM targets, at start of the application.
*
*/
void SEGGER_RTT_Init (void) {
 8002bb8:	b580      	push	{r7, lr}
 8002bba:	af00      	add	r7, sp, #0
  _DoInit();
 8002bbc:	f7ff fe64 	bl	8002888 <_DoInit>
}
 8002bc0:	46c0      	nop			; (mov r8, r8)
 8002bc2:	46bd      	mov	sp, r7
 8002bc4:	bd80      	pop	{r7, pc}
	...

08002bc8 <app_debug_rtt_raw>:
    
    return n;
}

int32_t app_debug_rtt_raw(const char *fmt,...)
{
 8002bc8:	b40f      	push	{r0, r1, r2, r3}
 8002bca:	b580      	push	{r7, lr}
 8002bcc:	b084      	sub	sp, #16
 8002bce:	af00      	add	r7, sp, #0
    int32_t     n;

    char *p = &m_debug_buffer[0];
 8002bd0:	4b15      	ldr	r3, [pc, #84]	; (8002c28 <app_debug_rtt_raw+0x60>)
 8002bd2:	60fb      	str	r3, [r7, #12]
    int32_t size = SEGGER_RTT_PRINTF_BUFFER_SIZE;
 8002bd4:	2380      	movs	r3, #128	; 0x80
 8002bd6:	009b      	lsls	r3, r3, #2
 8002bd8:	60bb      	str	r3, [r7, #8]
    va_list args;

    va_start (args, fmt);
 8002bda:	231c      	movs	r3, #28
 8002bdc:	18fb      	adds	r3, r7, r3
 8002bde:	603b      	str	r3, [r7, #0]
    n = vsnprintf(p, size, fmt, args);
 8002be0:	68b9      	ldr	r1, [r7, #8]
 8002be2:	683b      	ldr	r3, [r7, #0]
 8002be4:	69ba      	ldr	r2, [r7, #24]
 8002be6:	68f8      	ldr	r0, [r7, #12]
 8002be8:	f01a fb72 	bl	801d2d0 <vsniprintf>
 8002bec:	0003      	movs	r3, r0
 8002bee:	607b      	str	r3, [r7, #4]
    if (n > (int)size) 
 8002bf0:	687a      	ldr	r2, [r7, #4]
 8002bf2:	68bb      	ldr	r3, [r7, #8]
 8002bf4:	429a      	cmp	r2, r3
 8002bf6:	dd06      	ble.n	8002c06 <app_debug_rtt_raw+0x3e>
    {
        SEGGER_RTT_Write(0, m_debug_buffer, size);
 8002bf8:	68ba      	ldr	r2, [r7, #8]
 8002bfa:	4b0b      	ldr	r3, [pc, #44]	; (8002c28 <app_debug_rtt_raw+0x60>)
 8002bfc:	0019      	movs	r1, r3
 8002bfe:	2000      	movs	r0, #0
 8002c00:	f7ff ffb2 	bl	8002b68 <SEGGER_RTT_Write>
 8002c04:	e008      	b.n	8002c18 <app_debug_rtt_raw+0x50>
    } 
    else if (n > 0) 
 8002c06:	687b      	ldr	r3, [r7, #4]
 8002c08:	2b00      	cmp	r3, #0
 8002c0a:	dd05      	ble.n	8002c18 <app_debug_rtt_raw+0x50>
    {
        SEGGER_RTT_Write(0, m_debug_buffer, n);
 8002c0c:	687a      	ldr	r2, [r7, #4]
 8002c0e:	4b06      	ldr	r3, [pc, #24]	; (8002c28 <app_debug_rtt_raw+0x60>)
 8002c10:	0019      	movs	r1, r3
 8002c12:	2000      	movs	r0, #0
 8002c14:	f7ff ffa8 	bl	8002b68 <SEGGER_RTT_Write>
    }
    va_end(args);
    
    return n;
 8002c18:	687b      	ldr	r3, [r7, #4]
}
 8002c1a:	0018      	movs	r0, r3
 8002c1c:	46bd      	mov	sp, r7
 8002c1e:	b004      	add	sp, #16
 8002c20:	bc80      	pop	{r7}
 8002c22:	bc08      	pop	{r3}
 8002c24:	b004      	add	sp, #16
 8002c26:	4718      	bx	r3
 8002c28:	20001144 	.word	0x20001144

08002c2c <RingBuffer_Init>:
#include "ringbuffer.h"


void RingBuffer_Init(RingBuffer_Types* ringbuffer, int BufferSize)
{
 8002c2c:	b580      	push	{r7, lr}
 8002c2e:	b082      	sub	sp, #8
 8002c30:	af00      	add	r7, sp, #0
 8002c32:	6078      	str	r0, [r7, #4]
 8002c34:	6039      	str	r1, [r7, #0]
    ringbuffer->BufferSize = BufferSize;
 8002c36:	687b      	ldr	r3, [r7, #4]
 8002c38:	683a      	ldr	r2, [r7, #0]
 8002c3a:	601a      	str	r2, [r3, #0]
    ringbuffer->Head = 0;
 8002c3c:	687b      	ldr	r3, [r7, #4]
 8002c3e:	2200      	movs	r2, #0
 8002c40:	605a      	str	r2, [r3, #4]
    ringbuffer->Tail = 0;
 8002c42:	687b      	ldr	r3, [r7, #4]
 8002c44:	2200      	movs	r2, #0
 8002c46:	609a      	str	r2, [r3, #8]
    ringbuffer->u8Buffer = (uint8_t*)malloc(BufferSize*sizeof(uint8_t));
 8002c48:	683b      	ldr	r3, [r7, #0]
 8002c4a:	0018      	movs	r0, r3
 8002c4c:	f01a f926 	bl	801ce9c <malloc>
 8002c50:	0003      	movs	r3, r0
 8002c52:	001a      	movs	r2, r3
 8002c54:	687b      	ldr	r3, [r7, #4]
 8002c56:	60da      	str	r2, [r3, #12]
}
 8002c58:	46c0      	nop			; (mov r8, r8)
 8002c5a:	46bd      	mov	sp, r7
 8002c5c:	b002      	add	sp, #8
 8002c5e:	bd80      	pop	{r7, pc}

08002c60 <RingBuffer_Push>:

// Day 1 Byte vÃ o RingBuffer
uint8_t RingBuffer_Push(RingBuffer_Types* ringbuffer, uint8_t BytePush)
{
 8002c60:	b580      	push	{r7, lr}
 8002c62:	b082      	sub	sp, #8
 8002c64:	af00      	add	r7, sp, #0
 8002c66:	6078      	str	r0, [r7, #4]
 8002c68:	000a      	movs	r2, r1
 8002c6a:	1cfb      	adds	r3, r7, #3
 8002c6c:	701a      	strb	r2, [r3, #0]
    if((ringbuffer->Head - ringbuffer->Tail == (ringbuffer->BufferSize - 1))
 8002c6e:	687b      	ldr	r3, [r7, #4]
 8002c70:	685a      	ldr	r2, [r3, #4]
 8002c72:	687b      	ldr	r3, [r7, #4]
 8002c74:	689b      	ldr	r3, [r3, #8]
 8002c76:	1ad2      	subs	r2, r2, r3
 8002c78:	687b      	ldr	r3, [r7, #4]
 8002c7a:	681b      	ldr	r3, [r3, #0]
 8002c7c:	3b01      	subs	r3, #1
 8002c7e:	429a      	cmp	r2, r3
 8002c80:	d009      	beq.n	8002c96 <RingBuffer_Push+0x36>
       || (ringbuffer->Tail - ringbuffer->Head == (ringbuffer->BufferSize - 1)))
 8002c82:	687b      	ldr	r3, [r7, #4]
 8002c84:	689a      	ldr	r2, [r3, #8]
 8002c86:	687b      	ldr	r3, [r7, #4]
 8002c88:	685b      	ldr	r3, [r3, #4]
 8002c8a:	1ad2      	subs	r2, r2, r3
 8002c8c:	687b      	ldr	r3, [r7, #4]
 8002c8e:	681b      	ldr	r3, [r3, #0]
 8002c90:	3b01      	subs	r3, #1
 8002c92:	429a      	cmp	r2, r3
 8002c94:	d101      	bne.n	8002c9a <RingBuffer_Push+0x3a>
       {
        return E_NOT_OK; // return E_NOT_OK khi bo nho Full
 8002c96:	2300      	movs	r3, #0
 8002c98:	e018      	b.n	8002ccc <RingBuffer_Push+0x6c>
       }
    ringbuffer->u8Buffer[ringbuffer->Head] = BytePush;
 8002c9a:	687b      	ldr	r3, [r7, #4]
 8002c9c:	68da      	ldr	r2, [r3, #12]
 8002c9e:	687b      	ldr	r3, [r7, #4]
 8002ca0:	685b      	ldr	r3, [r3, #4]
 8002ca2:	18d3      	adds	r3, r2, r3
 8002ca4:	1cfa      	adds	r2, r7, #3
 8002ca6:	7812      	ldrb	r2, [r2, #0]
 8002ca8:	701a      	strb	r2, [r3, #0]
    if(ringbuffer->Head == (ringbuffer->BufferSize - 1))
 8002caa:	687b      	ldr	r3, [r7, #4]
 8002cac:	685a      	ldr	r2, [r3, #4]
 8002cae:	687b      	ldr	r3, [r7, #4]
 8002cb0:	681b      	ldr	r3, [r3, #0]
 8002cb2:	3b01      	subs	r3, #1
 8002cb4:	429a      	cmp	r2, r3
 8002cb6:	d103      	bne.n	8002cc0 <RingBuffer_Push+0x60>
    {
        ringbuffer->Head = 0;
 8002cb8:	687b      	ldr	r3, [r7, #4]
 8002cba:	2200      	movs	r2, #0
 8002cbc:	605a      	str	r2, [r3, #4]
 8002cbe:	e004      	b.n	8002cca <RingBuffer_Push+0x6a>
    }
    else
    {
        ringbuffer->Head += 1;
 8002cc0:	687b      	ldr	r3, [r7, #4]
 8002cc2:	685b      	ldr	r3, [r3, #4]
 8002cc4:	1c5a      	adds	r2, r3, #1
 8002cc6:	687b      	ldr	r3, [r7, #4]
 8002cc8:	605a      	str	r2, [r3, #4]
    }
    return E_OK;
 8002cca:	2301      	movs	r3, #1
}
 8002ccc:	0018      	movs	r0, r3
 8002cce:	46bd      	mov	sp, r7
 8002cd0:	b002      	add	sp, #8
 8002cd2:	bd80      	pop	{r7, pc}

08002cd4 <RingBuffer_Pop>:

// Doc 1 byte tÆ° RingBuffer
uint8_t RingBuffer_Pop(RingBuffer_Types* ringbuffer)
{
 8002cd4:	b580      	push	{r7, lr}
 8002cd6:	b084      	sub	sp, #16
 8002cd8:	af00      	add	r7, sp, #0
 8002cda:	6078      	str	r0, [r7, #4]
    uint8_t BytePush = 0;
 8002cdc:	210f      	movs	r1, #15
 8002cde:	187b      	adds	r3, r7, r1
 8002ce0:	2200      	movs	r2, #0
 8002ce2:	701a      	strb	r2, [r3, #0]
    if(ringbuffer->Head == ringbuffer->Tail)
 8002ce4:	687b      	ldr	r3, [r7, #4]
 8002ce6:	685a      	ldr	r2, [r3, #4]
 8002ce8:	687b      	ldr	r3, [r7, #4]
 8002cea:	689b      	ldr	r3, [r3, #8]
 8002cec:	429a      	cmp	r2, r3
 8002cee:	d102      	bne.n	8002cf6 <RingBuffer_Pop+0x22>
    {
        return BytePush; // Return Null khi bo nho Empty
 8002cf0:	187b      	adds	r3, r7, r1
 8002cf2:	781b      	ldrb	r3, [r3, #0]
 8002cf4:	e01b      	b.n	8002d2e <RingBuffer_Pop+0x5a>
    }
    BytePush = ringbuffer->u8Buffer[ringbuffer->Tail];
 8002cf6:	687b      	ldr	r3, [r7, #4]
 8002cf8:	68da      	ldr	r2, [r3, #12]
 8002cfa:	687b      	ldr	r3, [r7, #4]
 8002cfc:	689b      	ldr	r3, [r3, #8]
 8002cfe:	18d2      	adds	r2, r2, r3
 8002d00:	230f      	movs	r3, #15
 8002d02:	18fb      	adds	r3, r7, r3
 8002d04:	7812      	ldrb	r2, [r2, #0]
 8002d06:	701a      	strb	r2, [r3, #0]
    if(ringbuffer->Tail == (ringbuffer->BufferSize - 1))
 8002d08:	687b      	ldr	r3, [r7, #4]
 8002d0a:	689a      	ldr	r2, [r3, #8]
 8002d0c:	687b      	ldr	r3, [r7, #4]
 8002d0e:	681b      	ldr	r3, [r3, #0]
 8002d10:	3b01      	subs	r3, #1
 8002d12:	429a      	cmp	r2, r3
 8002d14:	d103      	bne.n	8002d1e <RingBuffer_Pop+0x4a>
    {
        ringbuffer->Tail = 0;
 8002d16:	687b      	ldr	r3, [r7, #4]
 8002d18:	2200      	movs	r2, #0
 8002d1a:	609a      	str	r2, [r3, #8]
 8002d1c:	e004      	b.n	8002d28 <RingBuffer_Pop+0x54>
    }
    else
    {
        ringbuffer->Tail += 1;
 8002d1e:	687b      	ldr	r3, [r7, #4]
 8002d20:	689b      	ldr	r3, [r3, #8]
 8002d22:	1c5a      	adds	r2, r3, #1
 8002d24:	687b      	ldr	r3, [r7, #4]
 8002d26:	609a      	str	r2, [r3, #8]
    }
    return BytePush;
 8002d28:	230f      	movs	r3, #15
 8002d2a:	18fb      	adds	r3, r7, r3
 8002d2c:	781b      	ldrb	r3, [r3, #0]
}
 8002d2e:	0018      	movs	r0, r3
 8002d30:	46bd      	mov	sp, r7
 8002d32:	b004      	add	sp, #16
 8002d34:	bd80      	pop	{r7, pc}

08002d36 <RingBuffer_GetBuffer>:
// Doc toan bo du lieu trong RingBuffer gÃ¡n vÃ o return Buffer
void RingBuffer_GetBuffer(uint8_t* retBuffer, uint16_t* dataLength, RingBuffer_Types* ringbuffer)
{
 8002d36:	b590      	push	{r4, r7, lr}
 8002d38:	b087      	sub	sp, #28
 8002d3a:	af00      	add	r7, sp, #0
 8002d3c:	60f8      	str	r0, [r7, #12]
 8002d3e:	60b9      	str	r1, [r7, #8]
 8002d40:	607a      	str	r2, [r7, #4]
    int Num_Elements = RingBuffer_GetNumberElements(ringbuffer);
 8002d42:	687b      	ldr	r3, [r7, #4]
 8002d44:	0018      	movs	r0, r3
 8002d46:	f000 f821 	bl	8002d8c <RingBuffer_GetNumberElements>
 8002d4a:	0003      	movs	r3, r0
 8002d4c:	613b      	str	r3, [r7, #16]
    if(Num_Elements == 0)
 8002d4e:	693b      	ldr	r3, [r7, #16]
 8002d50:	2b00      	cmp	r3, #0
 8002d52:	d017      	beq.n	8002d84 <RingBuffer_GetBuffer+0x4e>
    {
    	return;
    }
    for(int CountByte = 0; CountByte < Num_Elements; CountByte ++)
 8002d54:	2300      	movs	r3, #0
 8002d56:	617b      	str	r3, [r7, #20]
 8002d58:	e00b      	b.n	8002d72 <RingBuffer_GetBuffer+0x3c>
    {
        retBuffer[CountByte] = RingBuffer_Pop(ringbuffer);
 8002d5a:	697b      	ldr	r3, [r7, #20]
 8002d5c:	68fa      	ldr	r2, [r7, #12]
 8002d5e:	18d4      	adds	r4, r2, r3
 8002d60:	687b      	ldr	r3, [r7, #4]
 8002d62:	0018      	movs	r0, r3
 8002d64:	f7ff ffb6 	bl	8002cd4 <RingBuffer_Pop>
 8002d68:	0003      	movs	r3, r0
 8002d6a:	7023      	strb	r3, [r4, #0]
    for(int CountByte = 0; CountByte < Num_Elements; CountByte ++)
 8002d6c:	697b      	ldr	r3, [r7, #20]
 8002d6e:	3301      	adds	r3, #1
 8002d70:	617b      	str	r3, [r7, #20]
 8002d72:	697a      	ldr	r2, [r7, #20]
 8002d74:	693b      	ldr	r3, [r7, #16]
 8002d76:	429a      	cmp	r2, r3
 8002d78:	dbef      	blt.n	8002d5a <RingBuffer_GetBuffer+0x24>
    }
    *dataLength = Num_Elements;
 8002d7a:	693b      	ldr	r3, [r7, #16]
 8002d7c:	b29a      	uxth	r2, r3
 8002d7e:	68bb      	ldr	r3, [r7, #8]
 8002d80:	801a      	strh	r2, [r3, #0]
 8002d82:	e000      	b.n	8002d86 <RingBuffer_GetBuffer+0x50>
    	return;
 8002d84:	46c0      	nop			; (mov r8, r8)
}
 8002d86:	46bd      	mov	sp, r7
 8002d88:	b007      	add	sp, #28
 8002d8a:	bd90      	pop	{r4, r7, pc}

08002d8c <RingBuffer_GetNumberElements>:

// Lay tong so byte du lieu trong RingBuffer
int RingBuffer_GetNumberElements(RingBuffer_Types* ringbuffer)
{
 8002d8c:	b580      	push	{r7, lr}
 8002d8e:	b084      	sub	sp, #16
 8002d90:	af00      	add	r7, sp, #0
 8002d92:	6078      	str	r0, [r7, #4]
    int Num_Element = 0;
 8002d94:	2300      	movs	r3, #0
 8002d96:	60fb      	str	r3, [r7, #12]
    if (ringbuffer->Head >= ringbuffer->Tail)
 8002d98:	687b      	ldr	r3, [r7, #4]
 8002d9a:	685a      	ldr	r2, [r3, #4]
 8002d9c:	687b      	ldr	r3, [r7, #4]
 8002d9e:	689b      	ldr	r3, [r3, #8]
 8002da0:	429a      	cmp	r2, r3
 8002da2:	db06      	blt.n	8002db2 <RingBuffer_GetNumberElements+0x26>
    {
        Num_Element = ringbuffer->Head - ringbuffer->Tail;
 8002da4:	687b      	ldr	r3, [r7, #4]
 8002da6:	685a      	ldr	r2, [r3, #4]
 8002da8:	687b      	ldr	r3, [r7, #4]
 8002daa:	689b      	ldr	r3, [r3, #8]
 8002dac:	1ad3      	subs	r3, r2, r3
 8002dae:	60fb      	str	r3, [r7, #12]
 8002db0:	e008      	b.n	8002dc4 <RingBuffer_GetNumberElements+0x38>
    }
    else
    {
        Num_Element = ringbuffer->BufferSize - ringbuffer->Tail + ringbuffer->Head;
 8002db2:	687b      	ldr	r3, [r7, #4]
 8002db4:	681a      	ldr	r2, [r3, #0]
 8002db6:	687b      	ldr	r3, [r7, #4]
 8002db8:	689b      	ldr	r3, [r3, #8]
 8002dba:	1ad2      	subs	r2, r2, r3
 8002dbc:	687b      	ldr	r3, [r7, #4]
 8002dbe:	685b      	ldr	r3, [r3, #4]
 8002dc0:	18d3      	adds	r3, r2, r3
 8002dc2:	60fb      	str	r3, [r7, #12]
    }
    return Num_Element;
 8002dc4:	68fb      	ldr	r3, [r7, #12]
}
 8002dc6:	0018      	movs	r0, r3
 8002dc8:	46bd      	mov	sp, r7
 8002dca:	b004      	add	sp, #16
 8002dcc:	bd80      	pop	{r7, pc}

08002dce <Erase_RingBuffer>:
// Xoa toan bo RingBuffer
void Erase_RingBuffer(RingBuffer_Types* ringbuffer)
{
 8002dce:	b580      	push	{r7, lr}
 8002dd0:	b082      	sub	sp, #8
 8002dd2:	af00      	add	r7, sp, #0
 8002dd4:	6078      	str	r0, [r7, #4]
    ringbuffer->Head = ringbuffer->Tail;
 8002dd6:	687b      	ldr	r3, [r7, #4]
 8002dd8:	689a      	ldr	r2, [r3, #8]
 8002dda:	687b      	ldr	r3, [r7, #4]
 8002ddc:	605a      	str	r2, [r3, #4]
}
 8002dde:	46c0      	nop			; (mov r8, r8)
 8002de0:	46bd      	mov	sp, r7
 8002de2:	b002      	add	sp, #8
 8002de4:	bd80      	pop	{r7, pc}
	...

08002de8 <HAL_Init>:
  *        In the default implementation,Systick is used as source of time base.
  *        the tick variable is incremented each 1ms in its ISR.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8002de8:	b580      	push	{r7, lr}
 8002dea:	b082      	sub	sp, #8
 8002dec:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
 8002dee:	1dfb      	adds	r3, r7, #7
 8002df0:	2200      	movs	r2, #0
 8002df2:	701a      	strb	r2, [r3, #0]
#if (BUFFER_CACHE_DISABLE != 0)
  __HAL_FLASH_BUFFER_CACHE_DISABLE();
#endif /* BUFFER_CACHE_DISABLE */

#if (PREREAD_ENABLE != 0)
  __HAL_FLASH_PREREAD_BUFFER_ENABLE();
 8002df4:	4b0b      	ldr	r3, [pc, #44]	; (8002e24 <HAL_Init+0x3c>)
 8002df6:	681a      	ldr	r2, [r3, #0]
 8002df8:	4b0a      	ldr	r3, [pc, #40]	; (8002e24 <HAL_Init+0x3c>)
 8002dfa:	2140      	movs	r1, #64	; 0x40
 8002dfc:	430a      	orrs	r2, r1
 8002dfe:	601a      	str	r2, [r3, #0]
#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif /* PREFETCH_ENABLE */

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8002e00:	2003      	movs	r0, #3
 8002e02:	f000 f811 	bl	8002e28 <HAL_InitTick>
 8002e06:	1e03      	subs	r3, r0, #0
 8002e08:	d003      	beq.n	8002e12 <HAL_Init+0x2a>
  {
    status = HAL_ERROR;
 8002e0a:	1dfb      	adds	r3, r7, #7
 8002e0c:	2201      	movs	r2, #1
 8002e0e:	701a      	strb	r2, [r3, #0]
 8002e10:	e001      	b.n	8002e16 <HAL_Init+0x2e>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
 8002e12:	f7fd fcd1 	bl	80007b8 <HAL_MspInit>
  }

  /* Return function status */
  return status;
 8002e16:	1dfb      	adds	r3, r7, #7
 8002e18:	781b      	ldrb	r3, [r3, #0]
}
 8002e1a:	0018      	movs	r0, r3
 8002e1c:	46bd      	mov	sp, r7
 8002e1e:	b002      	add	sp, #8
 8002e20:	bd80      	pop	{r7, pc}
 8002e22:	46c0      	nop			; (mov r8, r8)
 8002e24:	40022000 	.word	0x40022000

08002e28 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8002e28:	b590      	push	{r4, r7, lr}
 8002e2a:	b083      	sub	sp, #12
 8002e2c:	af00      	add	r7, sp, #0
 8002e2e:	6078      	str	r0, [r7, #4]
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8002e30:	4b14      	ldr	r3, [pc, #80]	; (8002e84 <HAL_InitTick+0x5c>)
 8002e32:	681c      	ldr	r4, [r3, #0]
 8002e34:	4b14      	ldr	r3, [pc, #80]	; (8002e88 <HAL_InitTick+0x60>)
 8002e36:	781b      	ldrb	r3, [r3, #0]
 8002e38:	0019      	movs	r1, r3
 8002e3a:	23fa      	movs	r3, #250	; 0xfa
 8002e3c:	0098      	lsls	r0, r3, #2
 8002e3e:	f7fd f975 	bl	800012c <__udivsi3>
 8002e42:	0003      	movs	r3, r0
 8002e44:	0019      	movs	r1, r3
 8002e46:	0020      	movs	r0, r4
 8002e48:	f7fd f970 	bl	800012c <__udivsi3>
 8002e4c:	0003      	movs	r3, r0
 8002e4e:	0018      	movs	r0, r3
 8002e50:	f000 f92f 	bl	80030b2 <HAL_SYSTICK_Config>
 8002e54:	1e03      	subs	r3, r0, #0
 8002e56:	d001      	beq.n	8002e5c <HAL_InitTick+0x34>
  {
    return HAL_ERROR;
 8002e58:	2301      	movs	r3, #1
 8002e5a:	e00f      	b.n	8002e7c <HAL_InitTick+0x54>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8002e5c:	687b      	ldr	r3, [r7, #4]
 8002e5e:	2b03      	cmp	r3, #3
 8002e60:	d80b      	bhi.n	8002e7a <HAL_InitTick+0x52>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8002e62:	6879      	ldr	r1, [r7, #4]
 8002e64:	2301      	movs	r3, #1
 8002e66:	425b      	negs	r3, r3
 8002e68:	2200      	movs	r2, #0
 8002e6a:	0018      	movs	r0, r3
 8002e6c:	f000 f8fc 	bl	8003068 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 8002e70:	4b06      	ldr	r3, [pc, #24]	; (8002e8c <HAL_InitTick+0x64>)
 8002e72:	687a      	ldr	r2, [r7, #4]
 8002e74:	601a      	str	r2, [r3, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
 8002e76:	2300      	movs	r3, #0
 8002e78:	e000      	b.n	8002e7c <HAL_InitTick+0x54>
    return HAL_ERROR;
 8002e7a:	2301      	movs	r3, #1
}
 8002e7c:	0018      	movs	r0, r3
 8002e7e:	46bd      	mov	sp, r7
 8002e80:	b003      	add	sp, #12
 8002e82:	bd90      	pop	{r4, r7, pc}
 8002e84:	20000010 	.word	0x20000010
 8002e88:	20000018 	.word	0x20000018
 8002e8c:	20000014 	.word	0x20000014

08002e90 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8002e90:	b580      	push	{r7, lr}
 8002e92:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 8002e94:	4b05      	ldr	r3, [pc, #20]	; (8002eac <HAL_IncTick+0x1c>)
 8002e96:	781b      	ldrb	r3, [r3, #0]
 8002e98:	001a      	movs	r2, r3
 8002e9a:	4b05      	ldr	r3, [pc, #20]	; (8002eb0 <HAL_IncTick+0x20>)
 8002e9c:	681b      	ldr	r3, [r3, #0]
 8002e9e:	18d2      	adds	r2, r2, r3
 8002ea0:	4b03      	ldr	r3, [pc, #12]	; (8002eb0 <HAL_IncTick+0x20>)
 8002ea2:	601a      	str	r2, [r3, #0]
}
 8002ea4:	46c0      	nop			; (mov r8, r8)
 8002ea6:	46bd      	mov	sp, r7
 8002ea8:	bd80      	pop	{r7, pc}
 8002eaa:	46c0      	nop			; (mov r8, r8)
 8002eac:	20000018 	.word	0x20000018
 8002eb0:	200018f8 	.word	0x200018f8

08002eb4 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 8002eb4:	b580      	push	{r7, lr}
 8002eb6:	af00      	add	r7, sp, #0
  return uwTick;
 8002eb8:	4b02      	ldr	r3, [pc, #8]	; (8002ec4 <HAL_GetTick+0x10>)
 8002eba:	681b      	ldr	r3, [r3, #0]
}
 8002ebc:	0018      	movs	r0, r3
 8002ebe:	46bd      	mov	sp, r7
 8002ec0:	bd80      	pop	{r7, pc}
 8002ec2:	46c0      	nop			; (mov r8, r8)
 8002ec4:	200018f8 	.word	0x200018f8

08002ec8 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8002ec8:	b580      	push	{r7, lr}
 8002eca:	b084      	sub	sp, #16
 8002ecc:	af00      	add	r7, sp, #0
 8002ece:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 8002ed0:	f7ff fff0 	bl	8002eb4 <HAL_GetTick>
 8002ed4:	0003      	movs	r3, r0
 8002ed6:	60bb      	str	r3, [r7, #8]
  uint32_t wait = Delay;
 8002ed8:	687b      	ldr	r3, [r7, #4]
 8002eda:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8002edc:	68fb      	ldr	r3, [r7, #12]
 8002ede:	3301      	adds	r3, #1
 8002ee0:	d005      	beq.n	8002eee <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
 8002ee2:	4b0a      	ldr	r3, [pc, #40]	; (8002f0c <HAL_Delay+0x44>)
 8002ee4:	781b      	ldrb	r3, [r3, #0]
 8002ee6:	001a      	movs	r2, r3
 8002ee8:	68fb      	ldr	r3, [r7, #12]
 8002eea:	189b      	adds	r3, r3, r2
 8002eec:	60fb      	str	r3, [r7, #12]
  }

  while((HAL_GetTick() - tickstart) < wait)
 8002eee:	46c0      	nop			; (mov r8, r8)
 8002ef0:	f7ff ffe0 	bl	8002eb4 <HAL_GetTick>
 8002ef4:	0002      	movs	r2, r0
 8002ef6:	68bb      	ldr	r3, [r7, #8]
 8002ef8:	1ad3      	subs	r3, r2, r3
 8002efa:	68fa      	ldr	r2, [r7, #12]
 8002efc:	429a      	cmp	r2, r3
 8002efe:	d8f7      	bhi.n	8002ef0 <HAL_Delay+0x28>
  {
  }
}
 8002f00:	46c0      	nop			; (mov r8, r8)
 8002f02:	46c0      	nop			; (mov r8, r8)
 8002f04:	46bd      	mov	sp, r7
 8002f06:	b004      	add	sp, #16
 8002f08:	bd80      	pop	{r7, pc}
 8002f0a:	46c0      	nop			; (mov r8, r8)
 8002f0c:	20000018 	.word	0x20000018

08002f10 <__NVIC_EnableIRQ>:
{
 8002f10:	b580      	push	{r7, lr}
 8002f12:	b082      	sub	sp, #8
 8002f14:	af00      	add	r7, sp, #0
 8002f16:	0002      	movs	r2, r0
 8002f18:	1dfb      	adds	r3, r7, #7
 8002f1a:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
 8002f1c:	1dfb      	adds	r3, r7, #7
 8002f1e:	781b      	ldrb	r3, [r3, #0]
 8002f20:	2b7f      	cmp	r3, #127	; 0x7f
 8002f22:	d809      	bhi.n	8002f38 <__NVIC_EnableIRQ+0x28>
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8002f24:	1dfb      	adds	r3, r7, #7
 8002f26:	781b      	ldrb	r3, [r3, #0]
 8002f28:	001a      	movs	r2, r3
 8002f2a:	231f      	movs	r3, #31
 8002f2c:	401a      	ands	r2, r3
 8002f2e:	4b04      	ldr	r3, [pc, #16]	; (8002f40 <__NVIC_EnableIRQ+0x30>)
 8002f30:	2101      	movs	r1, #1
 8002f32:	4091      	lsls	r1, r2
 8002f34:	000a      	movs	r2, r1
 8002f36:	601a      	str	r2, [r3, #0]
}
 8002f38:	46c0      	nop			; (mov r8, r8)
 8002f3a:	46bd      	mov	sp, r7
 8002f3c:	b002      	add	sp, #8
 8002f3e:	bd80      	pop	{r7, pc}
 8002f40:	e000e100 	.word	0xe000e100

08002f44 <__NVIC_SetPriority>:
{
 8002f44:	b590      	push	{r4, r7, lr}
 8002f46:	b083      	sub	sp, #12
 8002f48:	af00      	add	r7, sp, #0
 8002f4a:	0002      	movs	r2, r0
 8002f4c:	6039      	str	r1, [r7, #0]
 8002f4e:	1dfb      	adds	r3, r7, #7
 8002f50:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
 8002f52:	1dfb      	adds	r3, r7, #7
 8002f54:	781b      	ldrb	r3, [r3, #0]
 8002f56:	2b7f      	cmp	r3, #127	; 0x7f
 8002f58:	d828      	bhi.n	8002fac <__NVIC_SetPriority+0x68>
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8002f5a:	4a2f      	ldr	r2, [pc, #188]	; (8003018 <__NVIC_SetPriority+0xd4>)
 8002f5c:	1dfb      	adds	r3, r7, #7
 8002f5e:	781b      	ldrb	r3, [r3, #0]
 8002f60:	b25b      	sxtb	r3, r3
 8002f62:	089b      	lsrs	r3, r3, #2
 8002f64:	33c0      	adds	r3, #192	; 0xc0
 8002f66:	009b      	lsls	r3, r3, #2
 8002f68:	589b      	ldr	r3, [r3, r2]
 8002f6a:	1dfa      	adds	r2, r7, #7
 8002f6c:	7812      	ldrb	r2, [r2, #0]
 8002f6e:	0011      	movs	r1, r2
 8002f70:	2203      	movs	r2, #3
 8002f72:	400a      	ands	r2, r1
 8002f74:	00d2      	lsls	r2, r2, #3
 8002f76:	21ff      	movs	r1, #255	; 0xff
 8002f78:	4091      	lsls	r1, r2
 8002f7a:	000a      	movs	r2, r1
 8002f7c:	43d2      	mvns	r2, r2
 8002f7e:	401a      	ands	r2, r3
 8002f80:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 8002f82:	683b      	ldr	r3, [r7, #0]
 8002f84:	019b      	lsls	r3, r3, #6
 8002f86:	22ff      	movs	r2, #255	; 0xff
 8002f88:	401a      	ands	r2, r3
 8002f8a:	1dfb      	adds	r3, r7, #7
 8002f8c:	781b      	ldrb	r3, [r3, #0]
 8002f8e:	0018      	movs	r0, r3
 8002f90:	2303      	movs	r3, #3
 8002f92:	4003      	ands	r3, r0
 8002f94:	00db      	lsls	r3, r3, #3
 8002f96:	409a      	lsls	r2, r3
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8002f98:	481f      	ldr	r0, [pc, #124]	; (8003018 <__NVIC_SetPriority+0xd4>)
 8002f9a:	1dfb      	adds	r3, r7, #7
 8002f9c:	781b      	ldrb	r3, [r3, #0]
 8002f9e:	b25b      	sxtb	r3, r3
 8002fa0:	089b      	lsrs	r3, r3, #2
 8002fa2:	430a      	orrs	r2, r1
 8002fa4:	33c0      	adds	r3, #192	; 0xc0
 8002fa6:	009b      	lsls	r3, r3, #2
 8002fa8:	501a      	str	r2, [r3, r0]
}
 8002faa:	e031      	b.n	8003010 <__NVIC_SetPriority+0xcc>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8002fac:	4a1b      	ldr	r2, [pc, #108]	; (800301c <__NVIC_SetPriority+0xd8>)
 8002fae:	1dfb      	adds	r3, r7, #7
 8002fb0:	781b      	ldrb	r3, [r3, #0]
 8002fb2:	0019      	movs	r1, r3
 8002fb4:	230f      	movs	r3, #15
 8002fb6:	400b      	ands	r3, r1
 8002fb8:	3b08      	subs	r3, #8
 8002fba:	089b      	lsrs	r3, r3, #2
 8002fbc:	3306      	adds	r3, #6
 8002fbe:	009b      	lsls	r3, r3, #2
 8002fc0:	18d3      	adds	r3, r2, r3
 8002fc2:	3304      	adds	r3, #4
 8002fc4:	681b      	ldr	r3, [r3, #0]
 8002fc6:	1dfa      	adds	r2, r7, #7
 8002fc8:	7812      	ldrb	r2, [r2, #0]
 8002fca:	0011      	movs	r1, r2
 8002fcc:	2203      	movs	r2, #3
 8002fce:	400a      	ands	r2, r1
 8002fd0:	00d2      	lsls	r2, r2, #3
 8002fd2:	21ff      	movs	r1, #255	; 0xff
 8002fd4:	4091      	lsls	r1, r2
 8002fd6:	000a      	movs	r2, r1
 8002fd8:	43d2      	mvns	r2, r2
 8002fda:	401a      	ands	r2, r3
 8002fdc:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 8002fde:	683b      	ldr	r3, [r7, #0]
 8002fe0:	019b      	lsls	r3, r3, #6
 8002fe2:	22ff      	movs	r2, #255	; 0xff
 8002fe4:	401a      	ands	r2, r3
 8002fe6:	1dfb      	adds	r3, r7, #7
 8002fe8:	781b      	ldrb	r3, [r3, #0]
 8002fea:	0018      	movs	r0, r3
 8002fec:	2303      	movs	r3, #3
 8002fee:	4003      	ands	r3, r0
 8002ff0:	00db      	lsls	r3, r3, #3
 8002ff2:	409a      	lsls	r2, r3
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8002ff4:	4809      	ldr	r0, [pc, #36]	; (800301c <__NVIC_SetPriority+0xd8>)
 8002ff6:	1dfb      	adds	r3, r7, #7
 8002ff8:	781b      	ldrb	r3, [r3, #0]
 8002ffa:	001c      	movs	r4, r3
 8002ffc:	230f      	movs	r3, #15
 8002ffe:	4023      	ands	r3, r4
 8003000:	3b08      	subs	r3, #8
 8003002:	089b      	lsrs	r3, r3, #2
 8003004:	430a      	orrs	r2, r1
 8003006:	3306      	adds	r3, #6
 8003008:	009b      	lsls	r3, r3, #2
 800300a:	18c3      	adds	r3, r0, r3
 800300c:	3304      	adds	r3, #4
 800300e:	601a      	str	r2, [r3, #0]
}
 8003010:	46c0      	nop			; (mov r8, r8)
 8003012:	46bd      	mov	sp, r7
 8003014:	b003      	add	sp, #12
 8003016:	bd90      	pop	{r4, r7, pc}
 8003018:	e000e100 	.word	0xe000e100
 800301c:	e000ed00 	.word	0xe000ed00

08003020 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 8003020:	b580      	push	{r7, lr}
 8003022:	b082      	sub	sp, #8
 8003024:	af00      	add	r7, sp, #0
 8003026:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8003028:	687b      	ldr	r3, [r7, #4]
 800302a:	1e5a      	subs	r2, r3, #1
 800302c:	2380      	movs	r3, #128	; 0x80
 800302e:	045b      	lsls	r3, r3, #17
 8003030:	429a      	cmp	r2, r3
 8003032:	d301      	bcc.n	8003038 <SysTick_Config+0x18>
  {
    return (1UL);                                                   /* Reload value impossible */
 8003034:	2301      	movs	r3, #1
 8003036:	e010      	b.n	800305a <SysTick_Config+0x3a>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8003038:	4b0a      	ldr	r3, [pc, #40]	; (8003064 <SysTick_Config+0x44>)
 800303a:	687a      	ldr	r2, [r7, #4]
 800303c:	3a01      	subs	r2, #1
 800303e:	605a      	str	r2, [r3, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 8003040:	2301      	movs	r3, #1
 8003042:	425b      	negs	r3, r3
 8003044:	2103      	movs	r1, #3
 8003046:	0018      	movs	r0, r3
 8003048:	f7ff ff7c 	bl	8002f44 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800304c:	4b05      	ldr	r3, [pc, #20]	; (8003064 <SysTick_Config+0x44>)
 800304e:	2200      	movs	r2, #0
 8003050:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8003052:	4b04      	ldr	r3, [pc, #16]	; (8003064 <SysTick_Config+0x44>)
 8003054:	2207      	movs	r2, #7
 8003056:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8003058:	2300      	movs	r3, #0
}
 800305a:	0018      	movs	r0, r3
 800305c:	46bd      	mov	sp, r7
 800305e:	b002      	add	sp, #8
 8003060:	bd80      	pop	{r7, pc}
 8003062:	46c0      	nop			; (mov r8, r8)
 8003064:	e000e010 	.word	0xe000e010

08003068 <HAL_NVIC_SetPriority>:
  *         with stm32l0xx devices, this parameter is a dummy value and it is ignored, because 
  *         no subpriority supported in Cortex M0+ based products.   
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8003068:	b580      	push	{r7, lr}
 800306a:	b084      	sub	sp, #16
 800306c:	af00      	add	r7, sp, #0
 800306e:	60b9      	str	r1, [r7, #8]
 8003070:	607a      	str	r2, [r7, #4]
 8003072:	210f      	movs	r1, #15
 8003074:	187b      	adds	r3, r7, r1
 8003076:	1c02      	adds	r2, r0, #0
 8003078:	701a      	strb	r2, [r3, #0]
    /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn,PreemptPriority);
 800307a:	68ba      	ldr	r2, [r7, #8]
 800307c:	187b      	adds	r3, r7, r1
 800307e:	781b      	ldrb	r3, [r3, #0]
 8003080:	b25b      	sxtb	r3, r3
 8003082:	0011      	movs	r1, r2
 8003084:	0018      	movs	r0, r3
 8003086:	f7ff ff5d 	bl	8002f44 <__NVIC_SetPriority>
}
 800308a:	46c0      	nop			; (mov r8, r8)
 800308c:	46bd      	mov	sp, r7
 800308e:	b004      	add	sp, #16
 8003090:	bd80      	pop	{r7, pc}

08003092 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of  IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to stm32l0xx.h file)  
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8003092:	b580      	push	{r7, lr}
 8003094:	b082      	sub	sp, #8
 8003096:	af00      	add	r7, sp, #0
 8003098:	0002      	movs	r2, r0
 800309a:	1dfb      	adds	r3, r7, #7
 800309c:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 800309e:	1dfb      	adds	r3, r7, #7
 80030a0:	781b      	ldrb	r3, [r3, #0]
 80030a2:	b25b      	sxtb	r3, r3
 80030a4:	0018      	movs	r0, r3
 80030a6:	f7ff ff33 	bl	8002f10 <__NVIC_EnableIRQ>
}
 80030aa:	46c0      	nop			; (mov r8, r8)
 80030ac:	46bd      	mov	sp, r7
 80030ae:	b002      	add	sp, #8
 80030b0:	bd80      	pop	{r7, pc}

080030b2 <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 80030b2:	b580      	push	{r7, lr}
 80030b4:	b082      	sub	sp, #8
 80030b6:	af00      	add	r7, sp, #0
 80030b8:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 80030ba:	687b      	ldr	r3, [r7, #4]
 80030bc:	0018      	movs	r0, r3
 80030be:	f7ff ffaf 	bl	8003020 <SysTick_Config>
 80030c2:	0003      	movs	r3, r0
}
 80030c4:	0018      	movs	r0, r3
 80030c6:	46bd      	mov	sp, r7
 80030c8:	b002      	add	sp, #8
 80030ca:	bd80      	pop	{r7, pc}

080030cc <HAL_DMA_Abort>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
    * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
{
 80030cc:	b580      	push	{r7, lr}
 80030ce:	b084      	sub	sp, #16
 80030d0:	af00      	add	r7, sp, #0
 80030d2:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 80030d4:	230f      	movs	r3, #15
 80030d6:	18fb      	adds	r3, r7, r3
 80030d8:	2200      	movs	r2, #0
 80030da:	701a      	strb	r2, [r3, #0]

  /* Check the DMA peripheral state */
  if(hdma->State != HAL_DMA_STATE_BUSY)
 80030dc:	687b      	ldr	r3, [r7, #4]
 80030de:	2225      	movs	r2, #37	; 0x25
 80030e0:	5c9b      	ldrb	r3, [r3, r2]
 80030e2:	b2db      	uxtb	r3, r3
 80030e4:	2b02      	cmp	r3, #2
 80030e6:	d008      	beq.n	80030fa <HAL_DMA_Abort+0x2e>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 80030e8:	687b      	ldr	r3, [r7, #4]
 80030ea:	2204      	movs	r2, #4
 80030ec:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 80030ee:	687b      	ldr	r3, [r7, #4]
 80030f0:	2224      	movs	r2, #36	; 0x24
 80030f2:	2100      	movs	r1, #0
 80030f4:	5499      	strb	r1, [r3, r2]

    return HAL_ERROR;
 80030f6:	2301      	movs	r3, #1
 80030f8:	e024      	b.n	8003144 <HAL_DMA_Abort+0x78>
  }
  else
  {
    /* Disable DMA IT */
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 80030fa:	687b      	ldr	r3, [r7, #4]
 80030fc:	681b      	ldr	r3, [r3, #0]
 80030fe:	681a      	ldr	r2, [r3, #0]
 8003100:	687b      	ldr	r3, [r7, #4]
 8003102:	681b      	ldr	r3, [r3, #0]
 8003104:	210e      	movs	r1, #14
 8003106:	438a      	bics	r2, r1
 8003108:	601a      	str	r2, [r3, #0]

    /* Disable the channel */
    __HAL_DMA_DISABLE(hdma);
 800310a:	687b      	ldr	r3, [r7, #4]
 800310c:	681b      	ldr	r3, [r3, #0]
 800310e:	681a      	ldr	r2, [r3, #0]
 8003110:	687b      	ldr	r3, [r7, #4]
 8003112:	681b      	ldr	r3, [r3, #0]
 8003114:	2101      	movs	r1, #1
 8003116:	438a      	bics	r2, r1
 8003118:	601a      	str	r2, [r3, #0]

    /* Clear all flags */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
 800311a:	687b      	ldr	r3, [r7, #4]
 800311c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800311e:	221c      	movs	r2, #28
 8003120:	401a      	ands	r2, r3
 8003122:	687b      	ldr	r3, [r7, #4]
 8003124:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8003126:	2101      	movs	r1, #1
 8003128:	4091      	lsls	r1, r2
 800312a:	000a      	movs	r2, r1
 800312c:	605a      	str	r2, [r3, #4]

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
 800312e:	687b      	ldr	r3, [r7, #4]
 8003130:	2225      	movs	r2, #37	; 0x25
 8003132:	2101      	movs	r1, #1
 8003134:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 8003136:	687b      	ldr	r3, [r7, #4]
 8003138:	2224      	movs	r2, #36	; 0x24
 800313a:	2100      	movs	r1, #0
 800313c:	5499      	strb	r1, [r3, r2]

    return status;
 800313e:	230f      	movs	r3, #15
 8003140:	18fb      	adds	r3, r7, r3
 8003142:	781b      	ldrb	r3, [r3, #0]
  }
}
 8003144:	0018      	movs	r0, r3
 8003146:	46bd      	mov	sp, r7
 8003148:	b004      	add	sp, #16
 800314a:	bd80      	pop	{r7, pc}

0800314c <HAL_DMA_Abort_IT>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
 800314c:	b580      	push	{r7, lr}
 800314e:	b084      	sub	sp, #16
 8003150:	af00      	add	r7, sp, #0
 8003152:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8003154:	210f      	movs	r1, #15
 8003156:	187b      	adds	r3, r7, r1
 8003158:	2200      	movs	r2, #0
 800315a:	701a      	strb	r2, [r3, #0]

  if(HAL_DMA_STATE_BUSY != hdma->State)
 800315c:	687b      	ldr	r3, [r7, #4]
 800315e:	2225      	movs	r2, #37	; 0x25
 8003160:	5c9b      	ldrb	r3, [r3, r2]
 8003162:	b2db      	uxtb	r3, r3
 8003164:	2b02      	cmp	r3, #2
 8003166:	d006      	beq.n	8003176 <HAL_DMA_Abort_IT+0x2a>
  {
    /* no transfer ongoing */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8003168:	687b      	ldr	r3, [r7, #4]
 800316a:	2204      	movs	r2, #4
 800316c:	63da      	str	r2, [r3, #60]	; 0x3c

    status = HAL_ERROR;
 800316e:	187b      	adds	r3, r7, r1
 8003170:	2201      	movs	r2, #1
 8003172:	701a      	strb	r2, [r3, #0]
 8003174:	e02a      	b.n	80031cc <HAL_DMA_Abort_IT+0x80>
  }
  else
  {
    /* Disable DMA IT */
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8003176:	687b      	ldr	r3, [r7, #4]
 8003178:	681b      	ldr	r3, [r3, #0]
 800317a:	681a      	ldr	r2, [r3, #0]
 800317c:	687b      	ldr	r3, [r7, #4]
 800317e:	681b      	ldr	r3, [r3, #0]
 8003180:	210e      	movs	r1, #14
 8003182:	438a      	bics	r2, r1
 8003184:	601a      	str	r2, [r3, #0]

    /* Disable the channel */
    __HAL_DMA_DISABLE(hdma);
 8003186:	687b      	ldr	r3, [r7, #4]
 8003188:	681b      	ldr	r3, [r3, #0]
 800318a:	681a      	ldr	r2, [r3, #0]
 800318c:	687b      	ldr	r3, [r7, #4]
 800318e:	681b      	ldr	r3, [r3, #0]
 8003190:	2101      	movs	r1, #1
 8003192:	438a      	bics	r2, r1
 8003194:	601a      	str	r2, [r3, #0]

    /* Clear all flags */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
 8003196:	687b      	ldr	r3, [r7, #4]
 8003198:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800319a:	221c      	movs	r2, #28
 800319c:	401a      	ands	r2, r3
 800319e:	687b      	ldr	r3, [r7, #4]
 80031a0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80031a2:	2101      	movs	r1, #1
 80031a4:	4091      	lsls	r1, r2
 80031a6:	000a      	movs	r2, r1
 80031a8:	605a      	str	r2, [r3, #4]

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
 80031aa:	687b      	ldr	r3, [r7, #4]
 80031ac:	2225      	movs	r2, #37	; 0x25
 80031ae:	2101      	movs	r1, #1
 80031b0:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 80031b2:	687b      	ldr	r3, [r7, #4]
 80031b4:	2224      	movs	r2, #36	; 0x24
 80031b6:	2100      	movs	r1, #0
 80031b8:	5499      	strb	r1, [r3, r2]

    /* Call User Abort callback */
    if(hdma->XferAbortCallback != NULL)
 80031ba:	687b      	ldr	r3, [r7, #4]
 80031bc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80031be:	2b00      	cmp	r3, #0
 80031c0:	d004      	beq.n	80031cc <HAL_DMA_Abort_IT+0x80>
    {
      hdma->XferAbortCallback(hdma);
 80031c2:	687b      	ldr	r3, [r7, #4]
 80031c4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80031c6:	687a      	ldr	r2, [r7, #4]
 80031c8:	0010      	movs	r0, r2
 80031ca:	4798      	blx	r3
    }
  }
  return status;
 80031cc:	230f      	movs	r3, #15
 80031ce:	18fb      	adds	r3, r7, r3
 80031d0:	781b      	ldrb	r3, [r3, #0]
}
 80031d2:	0018      	movs	r0, r3
 80031d4:	46bd      	mov	sp, r7
 80031d6:	b004      	add	sp, #16
 80031d8:	bd80      	pop	{r7, pc}
	...

080031dc <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *                    the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 80031dc:	b580      	push	{r7, lr}
 80031de:	b086      	sub	sp, #24
 80031e0:	af00      	add	r7, sp, #0
 80031e2:	6078      	str	r0, [r7, #4]
 80031e4:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
 80031e6:	2300      	movs	r3, #0
 80031e8:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00U;
 80031ea:	2300      	movs	r3, #0
 80031ec:	60fb      	str	r3, [r7, #12]
  uint32_t temp = 0x00U;
 80031ee:	2300      	movs	r3, #0
 80031f0:	613b      	str	r3, [r7, #16]
  /* Check the parameters */
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx, (GPIO_Init->Pin)));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0)
 80031f2:	e155      	b.n	80034a0 <HAL_GPIO_Init+0x2c4>
  {
    /* Get the IO position */
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 80031f4:	683b      	ldr	r3, [r7, #0]
 80031f6:	681b      	ldr	r3, [r3, #0]
 80031f8:	2101      	movs	r1, #1
 80031fa:	697a      	ldr	r2, [r7, #20]
 80031fc:	4091      	lsls	r1, r2
 80031fe:	000a      	movs	r2, r1
 8003200:	4013      	ands	r3, r2
 8003202:	60fb      	str	r3, [r7, #12]

    if (iocurrent)
 8003204:	68fb      	ldr	r3, [r7, #12]
 8003206:	2b00      	cmp	r3, #0
 8003208:	d100      	bne.n	800320c <HAL_GPIO_Init+0x30>
 800320a:	e146      	b.n	800349a <HAL_GPIO_Init+0x2be>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) ||
 800320c:	683b      	ldr	r3, [r7, #0]
 800320e:	685b      	ldr	r3, [r3, #4]
 8003210:	2203      	movs	r2, #3
 8003212:	4013      	ands	r3, r2
 8003214:	2b01      	cmp	r3, #1
 8003216:	d005      	beq.n	8003224 <HAL_GPIO_Init+0x48>
          ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 8003218:	683b      	ldr	r3, [r7, #0]
 800321a:	685b      	ldr	r3, [r3, #4]
 800321c:	2203      	movs	r2, #3
 800321e:	4013      	ands	r3, r2
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) ||
 8003220:	2b02      	cmp	r3, #2
 8003222:	d130      	bne.n	8003286 <HAL_GPIO_Init+0xaa>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 8003224:	687b      	ldr	r3, [r7, #4]
 8003226:	689b      	ldr	r3, [r3, #8]
 8003228:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDER_OSPEED0 << (position * 2U));
 800322a:	697b      	ldr	r3, [r7, #20]
 800322c:	005b      	lsls	r3, r3, #1
 800322e:	2203      	movs	r2, #3
 8003230:	409a      	lsls	r2, r3
 8003232:	0013      	movs	r3, r2
 8003234:	43da      	mvns	r2, r3
 8003236:	693b      	ldr	r3, [r7, #16]
 8003238:	4013      	ands	r3, r2
 800323a:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * 2U));
 800323c:	683b      	ldr	r3, [r7, #0]
 800323e:	68da      	ldr	r2, [r3, #12]
 8003240:	697b      	ldr	r3, [r7, #20]
 8003242:	005b      	lsls	r3, r3, #1
 8003244:	409a      	lsls	r2, r3
 8003246:	0013      	movs	r3, r2
 8003248:	693a      	ldr	r2, [r7, #16]
 800324a:	4313      	orrs	r3, r2
 800324c:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
 800324e:	687b      	ldr	r3, [r7, #4]
 8003250:	693a      	ldr	r2, [r7, #16]
 8003252:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8003254:	687b      	ldr	r3, [r7, #4]
 8003256:	685b      	ldr	r3, [r3, #4]
 8003258:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 800325a:	2201      	movs	r2, #1
 800325c:	697b      	ldr	r3, [r7, #20]
 800325e:	409a      	lsls	r2, r3
 8003260:	0013      	movs	r3, r2
 8003262:	43da      	mvns	r2, r3
 8003264:	693b      	ldr	r3, [r7, #16]
 8003266:	4013      	ands	r3, r2
 8003268:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 800326a:	683b      	ldr	r3, [r7, #0]
 800326c:	685b      	ldr	r3, [r3, #4]
 800326e:	091b      	lsrs	r3, r3, #4
 8003270:	2201      	movs	r2, #1
 8003272:	401a      	ands	r2, r3
 8003274:	697b      	ldr	r3, [r7, #20]
 8003276:	409a      	lsls	r2, r3
 8003278:	0013      	movs	r3, r2
 800327a:	693a      	ldr	r2, [r7, #16]
 800327c:	4313      	orrs	r3, r2
 800327e:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
 8003280:	687b      	ldr	r3, [r7, #4]
 8003282:	693a      	ldr	r2, [r7, #16]
 8003284:	605a      	str	r2, [r3, #4]
      }

      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 8003286:	683b      	ldr	r3, [r7, #0]
 8003288:	685b      	ldr	r3, [r3, #4]
 800328a:	2203      	movs	r2, #3
 800328c:	4013      	ands	r3, r2
 800328e:	2b03      	cmp	r3, #3
 8003290:	d017      	beq.n	80032c2 <HAL_GPIO_Init+0xe6>
      {
        /* Check the Pull parameter */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
 8003292:	687b      	ldr	r3, [r7, #4]
 8003294:	68db      	ldr	r3, [r3, #12]
 8003296:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8003298:	697b      	ldr	r3, [r7, #20]
 800329a:	005b      	lsls	r3, r3, #1
 800329c:	2203      	movs	r2, #3
 800329e:	409a      	lsls	r2, r3
 80032a0:	0013      	movs	r3, r2
 80032a2:	43da      	mvns	r2, r3
 80032a4:	693b      	ldr	r3, [r7, #16]
 80032a6:	4013      	ands	r3, r2
 80032a8:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 80032aa:	683b      	ldr	r3, [r7, #0]
 80032ac:	689a      	ldr	r2, [r3, #8]
 80032ae:	697b      	ldr	r3, [r7, #20]
 80032b0:	005b      	lsls	r3, r3, #1
 80032b2:	409a      	lsls	r2, r3
 80032b4:	0013      	movs	r3, r2
 80032b6:	693a      	ldr	r2, [r7, #16]
 80032b8:	4313      	orrs	r3, r2
 80032ba:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
 80032bc:	687b      	ldr	r3, [r7, #4]
 80032be:	693a      	ldr	r2, [r7, #16]
 80032c0:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 80032c2:	683b      	ldr	r3, [r7, #0]
 80032c4:	685b      	ldr	r3, [r3, #4]
 80032c6:	2203      	movs	r2, #3
 80032c8:	4013      	ands	r3, r2
 80032ca:	2b02      	cmp	r3, #2
 80032cc:	d123      	bne.n	8003316 <HAL_GPIO_Init+0x13a>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 80032ce:	697b      	ldr	r3, [r7, #20]
 80032d0:	08da      	lsrs	r2, r3, #3
 80032d2:	687b      	ldr	r3, [r7, #4]
 80032d4:	3208      	adds	r2, #8
 80032d6:	0092      	lsls	r2, r2, #2
 80032d8:	58d3      	ldr	r3, [r2, r3]
 80032da:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFUL << ((uint32_t)(position & 0x07UL) * 4U));
 80032dc:	697b      	ldr	r3, [r7, #20]
 80032de:	2207      	movs	r2, #7
 80032e0:	4013      	ands	r3, r2
 80032e2:	009b      	lsls	r3, r3, #2
 80032e4:	220f      	movs	r2, #15
 80032e6:	409a      	lsls	r2, r3
 80032e8:	0013      	movs	r3, r2
 80032ea:	43da      	mvns	r2, r3
 80032ec:	693b      	ldr	r3, [r7, #16]
 80032ee:	4013      	ands	r3, r2
 80032f0:	613b      	str	r3, [r7, #16]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U));
 80032f2:	683b      	ldr	r3, [r7, #0]
 80032f4:	691a      	ldr	r2, [r3, #16]
 80032f6:	697b      	ldr	r3, [r7, #20]
 80032f8:	2107      	movs	r1, #7
 80032fa:	400b      	ands	r3, r1
 80032fc:	009b      	lsls	r3, r3, #2
 80032fe:	409a      	lsls	r2, r3
 8003300:	0013      	movs	r3, r2
 8003302:	693a      	ldr	r2, [r7, #16]
 8003304:	4313      	orrs	r3, r2
 8003306:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3U] = temp;
 8003308:	697b      	ldr	r3, [r7, #20]
 800330a:	08da      	lsrs	r2, r3, #3
 800330c:	687b      	ldr	r3, [r7, #4]
 800330e:	3208      	adds	r2, #8
 8003310:	0092      	lsls	r2, r2, #2
 8003312:	6939      	ldr	r1, [r7, #16]
 8003314:	50d1      	str	r1, [r2, r3]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8003316:	687b      	ldr	r3, [r7, #4]
 8003318:	681b      	ldr	r3, [r3, #0]
 800331a:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 800331c:	697b      	ldr	r3, [r7, #20]
 800331e:	005b      	lsls	r3, r3, #1
 8003320:	2203      	movs	r2, #3
 8003322:	409a      	lsls	r2, r3
 8003324:	0013      	movs	r3, r2
 8003326:	43da      	mvns	r2, r3
 8003328:	693b      	ldr	r3, [r7, #16]
 800332a:	4013      	ands	r3, r2
 800332c:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800332e:	683b      	ldr	r3, [r7, #0]
 8003330:	685b      	ldr	r3, [r3, #4]
 8003332:	2203      	movs	r2, #3
 8003334:	401a      	ands	r2, r3
 8003336:	697b      	ldr	r3, [r7, #20]
 8003338:	005b      	lsls	r3, r3, #1
 800333a:	409a      	lsls	r2, r3
 800333c:	0013      	movs	r3, r2
 800333e:	693a      	ldr	r2, [r7, #16]
 8003340:	4313      	orrs	r3, r2
 8003342:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
 8003344:	687b      	ldr	r3, [r7, #4]
 8003346:	693a      	ldr	r2, [r7, #16]
 8003348:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 800334a:	683b      	ldr	r3, [r7, #0]
 800334c:	685a      	ldr	r2, [r3, #4]
 800334e:	23c0      	movs	r3, #192	; 0xc0
 8003350:	029b      	lsls	r3, r3, #10
 8003352:	4013      	ands	r3, r2
 8003354:	d100      	bne.n	8003358 <HAL_GPIO_Init+0x17c>
 8003356:	e0a0      	b.n	800349a <HAL_GPIO_Init+0x2be>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8003358:	4b57      	ldr	r3, [pc, #348]	; (80034b8 <HAL_GPIO_Init+0x2dc>)
 800335a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800335c:	4b56      	ldr	r3, [pc, #344]	; (80034b8 <HAL_GPIO_Init+0x2dc>)
 800335e:	2101      	movs	r1, #1
 8003360:	430a      	orrs	r2, r1
 8003362:	635a      	str	r2, [r3, #52]	; 0x34

        temp = SYSCFG->EXTICR[position >> 2U];
 8003364:	4a55      	ldr	r2, [pc, #340]	; (80034bc <HAL_GPIO_Init+0x2e0>)
 8003366:	697b      	ldr	r3, [r7, #20]
 8003368:	089b      	lsrs	r3, r3, #2
 800336a:	3302      	adds	r3, #2
 800336c:	009b      	lsls	r3, r3, #2
 800336e:	589b      	ldr	r3, [r3, r2]
 8003370:	613b      	str	r3, [r7, #16]
        CLEAR_BIT(temp, (0x0FUL) << (4U * (position & 0x03U)));
 8003372:	697b      	ldr	r3, [r7, #20]
 8003374:	2203      	movs	r2, #3
 8003376:	4013      	ands	r3, r2
 8003378:	009b      	lsls	r3, r3, #2
 800337a:	220f      	movs	r2, #15
 800337c:	409a      	lsls	r2, r3
 800337e:	0013      	movs	r3, r2
 8003380:	43da      	mvns	r2, r3
 8003382:	693b      	ldr	r3, [r7, #16]
 8003384:	4013      	ands	r3, r2
 8003386:	613b      	str	r3, [r7, #16]
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03U)));
 8003388:	687a      	ldr	r2, [r7, #4]
 800338a:	23a0      	movs	r3, #160	; 0xa0
 800338c:	05db      	lsls	r3, r3, #23
 800338e:	429a      	cmp	r2, r3
 8003390:	d01f      	beq.n	80033d2 <HAL_GPIO_Init+0x1f6>
 8003392:	687b      	ldr	r3, [r7, #4]
 8003394:	4a4a      	ldr	r2, [pc, #296]	; (80034c0 <HAL_GPIO_Init+0x2e4>)
 8003396:	4293      	cmp	r3, r2
 8003398:	d019      	beq.n	80033ce <HAL_GPIO_Init+0x1f2>
 800339a:	687b      	ldr	r3, [r7, #4]
 800339c:	4a49      	ldr	r2, [pc, #292]	; (80034c4 <HAL_GPIO_Init+0x2e8>)
 800339e:	4293      	cmp	r3, r2
 80033a0:	d013      	beq.n	80033ca <HAL_GPIO_Init+0x1ee>
 80033a2:	687b      	ldr	r3, [r7, #4]
 80033a4:	4a48      	ldr	r2, [pc, #288]	; (80034c8 <HAL_GPIO_Init+0x2ec>)
 80033a6:	4293      	cmp	r3, r2
 80033a8:	d00d      	beq.n	80033c6 <HAL_GPIO_Init+0x1ea>
 80033aa:	687b      	ldr	r3, [r7, #4]
 80033ac:	4a47      	ldr	r2, [pc, #284]	; (80034cc <HAL_GPIO_Init+0x2f0>)
 80033ae:	4293      	cmp	r3, r2
 80033b0:	d007      	beq.n	80033c2 <HAL_GPIO_Init+0x1e6>
 80033b2:	687b      	ldr	r3, [r7, #4]
 80033b4:	4a46      	ldr	r2, [pc, #280]	; (80034d0 <HAL_GPIO_Init+0x2f4>)
 80033b6:	4293      	cmp	r3, r2
 80033b8:	d101      	bne.n	80033be <HAL_GPIO_Init+0x1e2>
 80033ba:	2305      	movs	r3, #5
 80033bc:	e00a      	b.n	80033d4 <HAL_GPIO_Init+0x1f8>
 80033be:	2306      	movs	r3, #6
 80033c0:	e008      	b.n	80033d4 <HAL_GPIO_Init+0x1f8>
 80033c2:	2304      	movs	r3, #4
 80033c4:	e006      	b.n	80033d4 <HAL_GPIO_Init+0x1f8>
 80033c6:	2303      	movs	r3, #3
 80033c8:	e004      	b.n	80033d4 <HAL_GPIO_Init+0x1f8>
 80033ca:	2302      	movs	r3, #2
 80033cc:	e002      	b.n	80033d4 <HAL_GPIO_Init+0x1f8>
 80033ce:	2301      	movs	r3, #1
 80033d0:	e000      	b.n	80033d4 <HAL_GPIO_Init+0x1f8>
 80033d2:	2300      	movs	r3, #0
 80033d4:	697a      	ldr	r2, [r7, #20]
 80033d6:	2103      	movs	r1, #3
 80033d8:	400a      	ands	r2, r1
 80033da:	0092      	lsls	r2, r2, #2
 80033dc:	4093      	lsls	r3, r2
 80033de:	693a      	ldr	r2, [r7, #16]
 80033e0:	4313      	orrs	r3, r2
 80033e2:	613b      	str	r3, [r7, #16]
        SYSCFG->EXTICR[position >> 2U] = temp;
 80033e4:	4935      	ldr	r1, [pc, #212]	; (80034bc <HAL_GPIO_Init+0x2e0>)
 80033e6:	697b      	ldr	r3, [r7, #20]
 80033e8:	089b      	lsrs	r3, r3, #2
 80033ea:	3302      	adds	r3, #2
 80033ec:	009b      	lsls	r3, r3, #2
 80033ee:	693a      	ldr	r2, [r7, #16]
 80033f0:	505a      	str	r2, [r3, r1]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 80033f2:	4b38      	ldr	r3, [pc, #224]	; (80034d4 <HAL_GPIO_Init+0x2f8>)
 80033f4:	681b      	ldr	r3, [r3, #0]
 80033f6:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 80033f8:	68fb      	ldr	r3, [r7, #12]
 80033fa:	43da      	mvns	r2, r3
 80033fc:	693b      	ldr	r3, [r7, #16]
 80033fe:	4013      	ands	r3, r2
 8003400:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 8003402:	683b      	ldr	r3, [r7, #0]
 8003404:	685a      	ldr	r2, [r3, #4]
 8003406:	2380      	movs	r3, #128	; 0x80
 8003408:	025b      	lsls	r3, r3, #9
 800340a:	4013      	ands	r3, r2
 800340c:	d003      	beq.n	8003416 <HAL_GPIO_Init+0x23a>
        {
          temp |= iocurrent;
 800340e:	693a      	ldr	r2, [r7, #16]
 8003410:	68fb      	ldr	r3, [r7, #12]
 8003412:	4313      	orrs	r3, r2
 8003414:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR = temp;
 8003416:	4b2f      	ldr	r3, [pc, #188]	; (80034d4 <HAL_GPIO_Init+0x2f8>)
 8003418:	693a      	ldr	r2, [r7, #16]
 800341a:	601a      	str	r2, [r3, #0]

        temp = EXTI->EMR;
 800341c:	4b2d      	ldr	r3, [pc, #180]	; (80034d4 <HAL_GPIO_Init+0x2f8>)
 800341e:	685b      	ldr	r3, [r3, #4]
 8003420:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 8003422:	68fb      	ldr	r3, [r7, #12]
 8003424:	43da      	mvns	r2, r3
 8003426:	693b      	ldr	r3, [r7, #16]
 8003428:	4013      	ands	r3, r2
 800342a:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 800342c:	683b      	ldr	r3, [r7, #0]
 800342e:	685a      	ldr	r2, [r3, #4]
 8003430:	2380      	movs	r3, #128	; 0x80
 8003432:	029b      	lsls	r3, r3, #10
 8003434:	4013      	ands	r3, r2
 8003436:	d003      	beq.n	8003440 <HAL_GPIO_Init+0x264>
        {
          temp |= iocurrent;
 8003438:	693a      	ldr	r2, [r7, #16]
 800343a:	68fb      	ldr	r3, [r7, #12]
 800343c:	4313      	orrs	r3, r2
 800343e:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR = temp;
 8003440:	4b24      	ldr	r3, [pc, #144]	; (80034d4 <HAL_GPIO_Init+0x2f8>)
 8003442:	693a      	ldr	r2, [r7, #16]
 8003444:	605a      	str	r2, [r3, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8003446:	4b23      	ldr	r3, [pc, #140]	; (80034d4 <HAL_GPIO_Init+0x2f8>)
 8003448:	689b      	ldr	r3, [r3, #8]
 800344a:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 800344c:	68fb      	ldr	r3, [r7, #12]
 800344e:	43da      	mvns	r2, r3
 8003450:	693b      	ldr	r3, [r7, #16]
 8003452:	4013      	ands	r3, r2
 8003454:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 8003456:	683b      	ldr	r3, [r7, #0]
 8003458:	685a      	ldr	r2, [r3, #4]
 800345a:	2380      	movs	r3, #128	; 0x80
 800345c:	035b      	lsls	r3, r3, #13
 800345e:	4013      	ands	r3, r2
 8003460:	d003      	beq.n	800346a <HAL_GPIO_Init+0x28e>
        {
          temp |= iocurrent;
 8003462:	693a      	ldr	r2, [r7, #16]
 8003464:	68fb      	ldr	r3, [r7, #12]
 8003466:	4313      	orrs	r3, r2
 8003468:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR = temp;
 800346a:	4b1a      	ldr	r3, [pc, #104]	; (80034d4 <HAL_GPIO_Init+0x2f8>)
 800346c:	693a      	ldr	r2, [r7, #16]
 800346e:	609a      	str	r2, [r3, #8]

        temp = EXTI->FTSR;
 8003470:	4b18      	ldr	r3, [pc, #96]	; (80034d4 <HAL_GPIO_Init+0x2f8>)
 8003472:	68db      	ldr	r3, [r3, #12]
 8003474:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 8003476:	68fb      	ldr	r3, [r7, #12]
 8003478:	43da      	mvns	r2, r3
 800347a:	693b      	ldr	r3, [r7, #16]
 800347c:	4013      	ands	r3, r2
 800347e:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 8003480:	683b      	ldr	r3, [r7, #0]
 8003482:	685a      	ldr	r2, [r3, #4]
 8003484:	2380      	movs	r3, #128	; 0x80
 8003486:	039b      	lsls	r3, r3, #14
 8003488:	4013      	ands	r3, r2
 800348a:	d003      	beq.n	8003494 <HAL_GPIO_Init+0x2b8>
        {
          temp |= iocurrent;
 800348c:	693a      	ldr	r2, [r7, #16]
 800348e:	68fb      	ldr	r3, [r7, #12]
 8003490:	4313      	orrs	r3, r2
 8003492:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR = temp;
 8003494:	4b0f      	ldr	r3, [pc, #60]	; (80034d4 <HAL_GPIO_Init+0x2f8>)
 8003496:	693a      	ldr	r2, [r7, #16]
 8003498:	60da      	str	r2, [r3, #12]
      }
    }
    position++;
 800349a:	697b      	ldr	r3, [r7, #20]
 800349c:	3301      	adds	r3, #1
 800349e:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0)
 80034a0:	683b      	ldr	r3, [r7, #0]
 80034a2:	681a      	ldr	r2, [r3, #0]
 80034a4:	697b      	ldr	r3, [r7, #20]
 80034a6:	40da      	lsrs	r2, r3
 80034a8:	1e13      	subs	r3, r2, #0
 80034aa:	d000      	beq.n	80034ae <HAL_GPIO_Init+0x2d2>
 80034ac:	e6a2      	b.n	80031f4 <HAL_GPIO_Init+0x18>
  }
}
 80034ae:	46c0      	nop			; (mov r8, r8)
 80034b0:	46c0      	nop			; (mov r8, r8)
 80034b2:	46bd      	mov	sp, r7
 80034b4:	b006      	add	sp, #24
 80034b6:	bd80      	pop	{r7, pc}
 80034b8:	40021000 	.word	0x40021000
 80034bc:	40010000 	.word	0x40010000
 80034c0:	50000400 	.word	0x50000400
 80034c4:	50000800 	.word	0x50000800
 80034c8:	50000c00 	.word	0x50000c00
 80034cc:	50001000 	.word	0x50001000
 80034d0:	50001c00 	.word	0x50001c00
 80034d4:	40010400 	.word	0x40010400

080034d8 <HAL_GPIO_WritePin>:
  *                        GPIO_PIN_RESET: to clear the port pin
  *                        GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 80034d8:	b580      	push	{r7, lr}
 80034da:	b082      	sub	sp, #8
 80034dc:	af00      	add	r7, sp, #0
 80034de:	6078      	str	r0, [r7, #4]
 80034e0:	0008      	movs	r0, r1
 80034e2:	0011      	movs	r1, r2
 80034e4:	1cbb      	adds	r3, r7, #2
 80034e6:	1c02      	adds	r2, r0, #0
 80034e8:	801a      	strh	r2, [r3, #0]
 80034ea:	1c7b      	adds	r3, r7, #1
 80034ec:	1c0a      	adds	r2, r1, #0
 80034ee:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx, GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 80034f0:	1c7b      	adds	r3, r7, #1
 80034f2:	781b      	ldrb	r3, [r3, #0]
 80034f4:	2b00      	cmp	r3, #0
 80034f6:	d004      	beq.n	8003502 <HAL_GPIO_WritePin+0x2a>
  {
    GPIOx->BSRR = GPIO_Pin;
 80034f8:	1cbb      	adds	r3, r7, #2
 80034fa:	881a      	ldrh	r2, [r3, #0]
 80034fc:	687b      	ldr	r3, [r7, #4]
 80034fe:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = GPIO_Pin ;
  }
}
 8003500:	e003      	b.n	800350a <HAL_GPIO_WritePin+0x32>
    GPIOx->BRR = GPIO_Pin ;
 8003502:	1cbb      	adds	r3, r7, #2
 8003504:	881a      	ldrh	r2, [r3, #0]
 8003506:	687b      	ldr	r3, [r7, #4]
 8003508:	629a      	str	r2, [r3, #40]	; 0x28
}
 800350a:	46c0      	nop			; (mov r8, r8)
 800350c:	46bd      	mov	sp, r7
 800350e:	b002      	add	sp, #8
 8003510:	bd80      	pop	{r7, pc}
	...

08003514 <HAL_RCC_OscConfig>:
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8003514:	b5b0      	push	{r4, r5, r7, lr}
 8003516:	b08a      	sub	sp, #40	; 0x28
 8003518:	af00      	add	r7, sp, #0
 800351a:	6078      	str	r0, [r7, #4]
  uint32_t hsi_state;
  HAL_StatusTypeDef status;
  uint32_t sysclk_source, pll_config;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 800351c:	687b      	ldr	r3, [r7, #4]
 800351e:	2b00      	cmp	r3, #0
 8003520:	d102      	bne.n	8003528 <HAL_RCC_OscConfig+0x14>
  {
    return HAL_ERROR;
 8003522:	2301      	movs	r3, #1
 8003524:	f000 fb6c 	bl	8003c00 <HAL_RCC_OscConfig+0x6ec>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8003528:	4bc8      	ldr	r3, [pc, #800]	; (800384c <HAL_RCC_OscConfig+0x338>)
 800352a:	68db      	ldr	r3, [r3, #12]
 800352c:	220c      	movs	r2, #12
 800352e:	4013      	ands	r3, r2
 8003530:	61fb      	str	r3, [r7, #28]
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 8003532:	4bc6      	ldr	r3, [pc, #792]	; (800384c <HAL_RCC_OscConfig+0x338>)
 8003534:	68da      	ldr	r2, [r3, #12]
 8003536:	2380      	movs	r3, #128	; 0x80
 8003538:	025b      	lsls	r3, r3, #9
 800353a:	4013      	ands	r3, r2
 800353c:	61bb      	str	r3, [r7, #24]

  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800353e:	687b      	ldr	r3, [r7, #4]
 8003540:	681b      	ldr	r3, [r3, #0]
 8003542:	2201      	movs	r2, #1
 8003544:	4013      	ands	r3, r2
 8003546:	d100      	bne.n	800354a <HAL_RCC_OscConfig+0x36>
 8003548:	e07d      	b.n	8003646 <HAL_RCC_OscConfig+0x132>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 800354a:	69fb      	ldr	r3, [r7, #28]
 800354c:	2b08      	cmp	r3, #8
 800354e:	d007      	beq.n	8003560 <HAL_RCC_OscConfig+0x4c>
       || ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSE)))
 8003550:	69fb      	ldr	r3, [r7, #28]
 8003552:	2b0c      	cmp	r3, #12
 8003554:	d112      	bne.n	800357c <HAL_RCC_OscConfig+0x68>
 8003556:	69ba      	ldr	r2, [r7, #24]
 8003558:	2380      	movs	r3, #128	; 0x80
 800355a:	025b      	lsls	r3, r3, #9
 800355c:	429a      	cmp	r2, r3
 800355e:	d10d      	bne.n	800357c <HAL_RCC_OscConfig+0x68>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8003560:	4bba      	ldr	r3, [pc, #744]	; (800384c <HAL_RCC_OscConfig+0x338>)
 8003562:	681a      	ldr	r2, [r3, #0]
 8003564:	2380      	movs	r3, #128	; 0x80
 8003566:	029b      	lsls	r3, r3, #10
 8003568:	4013      	ands	r3, r2
 800356a:	d100      	bne.n	800356e <HAL_RCC_OscConfig+0x5a>
 800356c:	e06a      	b.n	8003644 <HAL_RCC_OscConfig+0x130>
 800356e:	687b      	ldr	r3, [r7, #4]
 8003570:	685b      	ldr	r3, [r3, #4]
 8003572:	2b00      	cmp	r3, #0
 8003574:	d166      	bne.n	8003644 <HAL_RCC_OscConfig+0x130>
      {
        return HAL_ERROR;
 8003576:	2301      	movs	r3, #1
 8003578:	f000 fb42 	bl	8003c00 <HAL_RCC_OscConfig+0x6ec>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800357c:	687b      	ldr	r3, [r7, #4]
 800357e:	685a      	ldr	r2, [r3, #4]
 8003580:	2380      	movs	r3, #128	; 0x80
 8003582:	025b      	lsls	r3, r3, #9
 8003584:	429a      	cmp	r2, r3
 8003586:	d107      	bne.n	8003598 <HAL_RCC_OscConfig+0x84>
 8003588:	4bb0      	ldr	r3, [pc, #704]	; (800384c <HAL_RCC_OscConfig+0x338>)
 800358a:	681a      	ldr	r2, [r3, #0]
 800358c:	4baf      	ldr	r3, [pc, #700]	; (800384c <HAL_RCC_OscConfig+0x338>)
 800358e:	2180      	movs	r1, #128	; 0x80
 8003590:	0249      	lsls	r1, r1, #9
 8003592:	430a      	orrs	r2, r1
 8003594:	601a      	str	r2, [r3, #0]
 8003596:	e027      	b.n	80035e8 <HAL_RCC_OscConfig+0xd4>
 8003598:	687b      	ldr	r3, [r7, #4]
 800359a:	685a      	ldr	r2, [r3, #4]
 800359c:	23a0      	movs	r3, #160	; 0xa0
 800359e:	02db      	lsls	r3, r3, #11
 80035a0:	429a      	cmp	r2, r3
 80035a2:	d10e      	bne.n	80035c2 <HAL_RCC_OscConfig+0xae>
 80035a4:	4ba9      	ldr	r3, [pc, #676]	; (800384c <HAL_RCC_OscConfig+0x338>)
 80035a6:	681a      	ldr	r2, [r3, #0]
 80035a8:	4ba8      	ldr	r3, [pc, #672]	; (800384c <HAL_RCC_OscConfig+0x338>)
 80035aa:	2180      	movs	r1, #128	; 0x80
 80035ac:	02c9      	lsls	r1, r1, #11
 80035ae:	430a      	orrs	r2, r1
 80035b0:	601a      	str	r2, [r3, #0]
 80035b2:	4ba6      	ldr	r3, [pc, #664]	; (800384c <HAL_RCC_OscConfig+0x338>)
 80035b4:	681a      	ldr	r2, [r3, #0]
 80035b6:	4ba5      	ldr	r3, [pc, #660]	; (800384c <HAL_RCC_OscConfig+0x338>)
 80035b8:	2180      	movs	r1, #128	; 0x80
 80035ba:	0249      	lsls	r1, r1, #9
 80035bc:	430a      	orrs	r2, r1
 80035be:	601a      	str	r2, [r3, #0]
 80035c0:	e012      	b.n	80035e8 <HAL_RCC_OscConfig+0xd4>
 80035c2:	4ba2      	ldr	r3, [pc, #648]	; (800384c <HAL_RCC_OscConfig+0x338>)
 80035c4:	681a      	ldr	r2, [r3, #0]
 80035c6:	4ba1      	ldr	r3, [pc, #644]	; (800384c <HAL_RCC_OscConfig+0x338>)
 80035c8:	49a1      	ldr	r1, [pc, #644]	; (8003850 <HAL_RCC_OscConfig+0x33c>)
 80035ca:	400a      	ands	r2, r1
 80035cc:	601a      	str	r2, [r3, #0]
 80035ce:	4b9f      	ldr	r3, [pc, #636]	; (800384c <HAL_RCC_OscConfig+0x338>)
 80035d0:	681a      	ldr	r2, [r3, #0]
 80035d2:	2380      	movs	r3, #128	; 0x80
 80035d4:	025b      	lsls	r3, r3, #9
 80035d6:	4013      	ands	r3, r2
 80035d8:	60fb      	str	r3, [r7, #12]
 80035da:	68fb      	ldr	r3, [r7, #12]
 80035dc:	4b9b      	ldr	r3, [pc, #620]	; (800384c <HAL_RCC_OscConfig+0x338>)
 80035de:	681a      	ldr	r2, [r3, #0]
 80035e0:	4b9a      	ldr	r3, [pc, #616]	; (800384c <HAL_RCC_OscConfig+0x338>)
 80035e2:	499c      	ldr	r1, [pc, #624]	; (8003854 <HAL_RCC_OscConfig+0x340>)
 80035e4:	400a      	ands	r2, r1
 80035e6:	601a      	str	r2, [r3, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 80035e8:	687b      	ldr	r3, [r7, #4]
 80035ea:	685b      	ldr	r3, [r3, #4]
 80035ec:	2b00      	cmp	r3, #0
 80035ee:	d014      	beq.n	800361a <HAL_RCC_OscConfig+0x106>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80035f0:	f7ff fc60 	bl	8002eb4 <HAL_GetTick>
 80035f4:	0003      	movs	r3, r0
 80035f6:	617b      	str	r3, [r7, #20]

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 80035f8:	e008      	b.n	800360c <HAL_RCC_OscConfig+0xf8>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80035fa:	f7ff fc5b 	bl	8002eb4 <HAL_GetTick>
 80035fe:	0002      	movs	r2, r0
 8003600:	697b      	ldr	r3, [r7, #20]
 8003602:	1ad3      	subs	r3, r2, r3
 8003604:	2b64      	cmp	r3, #100	; 0x64
 8003606:	d901      	bls.n	800360c <HAL_RCC_OscConfig+0xf8>
          {
            return HAL_TIMEOUT;
 8003608:	2303      	movs	r3, #3
 800360a:	e2f9      	b.n	8003c00 <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 800360c:	4b8f      	ldr	r3, [pc, #572]	; (800384c <HAL_RCC_OscConfig+0x338>)
 800360e:	681a      	ldr	r2, [r3, #0]
 8003610:	2380      	movs	r3, #128	; 0x80
 8003612:	029b      	lsls	r3, r3, #10
 8003614:	4013      	ands	r3, r2
 8003616:	d0f0      	beq.n	80035fa <HAL_RCC_OscConfig+0xe6>
 8003618:	e015      	b.n	8003646 <HAL_RCC_OscConfig+0x132>
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800361a:	f7ff fc4b 	bl	8002eb4 <HAL_GetTick>
 800361e:	0003      	movs	r3, r0
 8003620:	617b      	str	r3, [r7, #20]

        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 8003622:	e008      	b.n	8003636 <HAL_RCC_OscConfig+0x122>
        {
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8003624:	f7ff fc46 	bl	8002eb4 <HAL_GetTick>
 8003628:	0002      	movs	r2, r0
 800362a:	697b      	ldr	r3, [r7, #20]
 800362c:	1ad3      	subs	r3, r2, r3
 800362e:	2b64      	cmp	r3, #100	; 0x64
 8003630:	d901      	bls.n	8003636 <HAL_RCC_OscConfig+0x122>
          {
            return HAL_TIMEOUT;
 8003632:	2303      	movs	r3, #3
 8003634:	e2e4      	b.n	8003c00 <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 8003636:	4b85      	ldr	r3, [pc, #532]	; (800384c <HAL_RCC_OscConfig+0x338>)
 8003638:	681a      	ldr	r2, [r3, #0]
 800363a:	2380      	movs	r3, #128	; 0x80
 800363c:	029b      	lsls	r3, r3, #10
 800363e:	4013      	ands	r3, r2
 8003640:	d1f0      	bne.n	8003624 <HAL_RCC_OscConfig+0x110>
 8003642:	e000      	b.n	8003646 <HAL_RCC_OscConfig+0x132>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8003644:	46c0      	nop			; (mov r8, r8)
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8003646:	687b      	ldr	r3, [r7, #4]
 8003648:	681b      	ldr	r3, [r3, #0]
 800364a:	2202      	movs	r2, #2
 800364c:	4013      	ands	r3, r2
 800364e:	d100      	bne.n	8003652 <HAL_RCC_OscConfig+0x13e>
 8003650:	e099      	b.n	8003786 <HAL_RCC_OscConfig+0x272>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    hsi_state = RCC_OscInitStruct->HSIState;
 8003652:	687b      	ldr	r3, [r7, #4]
 8003654:	68db      	ldr	r3, [r3, #12]
 8003656:	627b      	str	r3, [r7, #36]	; 0x24

#if defined(RCC_CR_HSIOUTEN)
    if((hsi_state & RCC_HSI_OUTEN) != 0U)
 8003658:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800365a:	2220      	movs	r2, #32
 800365c:	4013      	ands	r3, r2
 800365e:	d009      	beq.n	8003674 <HAL_RCC_OscConfig+0x160>
    {
      /* HSI Output enable for timer requested */
      SET_BIT(RCC->CR, RCC_CR_HSIOUTEN);
 8003660:	4b7a      	ldr	r3, [pc, #488]	; (800384c <HAL_RCC_OscConfig+0x338>)
 8003662:	681a      	ldr	r2, [r3, #0]
 8003664:	4b79      	ldr	r3, [pc, #484]	; (800384c <HAL_RCC_OscConfig+0x338>)
 8003666:	2120      	movs	r1, #32
 8003668:	430a      	orrs	r2, r1
 800366a:	601a      	str	r2, [r3, #0]

      hsi_state &= ~RCC_CR_HSIOUTEN;
 800366c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800366e:	2220      	movs	r2, #32
 8003670:	4393      	bics	r3, r2
 8003672:	627b      	str	r3, [r7, #36]	; 0x24
    }
#endif

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
 8003674:	69fb      	ldr	r3, [r7, #28]
 8003676:	2b04      	cmp	r3, #4
 8003678:	d005      	beq.n	8003686 <HAL_RCC_OscConfig+0x172>
       || ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSI)))
 800367a:	69fb      	ldr	r3, [r7, #28]
 800367c:	2b0c      	cmp	r3, #12
 800367e:	d13e      	bne.n	80036fe <HAL_RCC_OscConfig+0x1ea>
 8003680:	69bb      	ldr	r3, [r7, #24]
 8003682:	2b00      	cmp	r3, #0
 8003684:	d13b      	bne.n	80036fe <HAL_RCC_OscConfig+0x1ea>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (hsi_state == RCC_HSI_OFF))
 8003686:	4b71      	ldr	r3, [pc, #452]	; (800384c <HAL_RCC_OscConfig+0x338>)
 8003688:	681b      	ldr	r3, [r3, #0]
 800368a:	2204      	movs	r2, #4
 800368c:	4013      	ands	r3, r2
 800368e:	d004      	beq.n	800369a <HAL_RCC_OscConfig+0x186>
 8003690:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003692:	2b00      	cmp	r3, #0
 8003694:	d101      	bne.n	800369a <HAL_RCC_OscConfig+0x186>
      {
        return HAL_ERROR;
 8003696:	2301      	movs	r3, #1
 8003698:	e2b2      	b.n	8003c00 <HAL_RCC_OscConfig+0x6ec>
      }
      /* Otherwise, just the calibration and HSI or HSIdiv4 are allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800369a:	4b6c      	ldr	r3, [pc, #432]	; (800384c <HAL_RCC_OscConfig+0x338>)
 800369c:	685b      	ldr	r3, [r3, #4]
 800369e:	4a6e      	ldr	r2, [pc, #440]	; (8003858 <HAL_RCC_OscConfig+0x344>)
 80036a0:	4013      	ands	r3, r2
 80036a2:	0019      	movs	r1, r3
 80036a4:	687b      	ldr	r3, [r7, #4]
 80036a6:	691b      	ldr	r3, [r3, #16]
 80036a8:	021a      	lsls	r2, r3, #8
 80036aa:	4b68      	ldr	r3, [pc, #416]	; (800384c <HAL_RCC_OscConfig+0x338>)
 80036ac:	430a      	orrs	r2, r1
 80036ae:	605a      	str	r2, [r3, #4]

        /* Enable the Internal High Speed oscillator (HSI or HSIdiv4) */
        __HAL_RCC_HSI_CONFIG(hsi_state);
 80036b0:	4b66      	ldr	r3, [pc, #408]	; (800384c <HAL_RCC_OscConfig+0x338>)
 80036b2:	681b      	ldr	r3, [r3, #0]
 80036b4:	2209      	movs	r2, #9
 80036b6:	4393      	bics	r3, r2
 80036b8:	0019      	movs	r1, r3
 80036ba:	4b64      	ldr	r3, [pc, #400]	; (800384c <HAL_RCC_OscConfig+0x338>)
 80036bc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80036be:	430a      	orrs	r2, r1
 80036c0:	601a      	str	r2, [r3, #0]
      }

      /* Update the SystemCoreClock global variable */
      SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 80036c2:	f000 fbeb 	bl	8003e9c <HAL_RCC_GetSysClockFreq>
 80036c6:	0001      	movs	r1, r0
 80036c8:	4b60      	ldr	r3, [pc, #384]	; (800384c <HAL_RCC_OscConfig+0x338>)
 80036ca:	68db      	ldr	r3, [r3, #12]
 80036cc:	091b      	lsrs	r3, r3, #4
 80036ce:	220f      	movs	r2, #15
 80036d0:	4013      	ands	r3, r2
 80036d2:	4a62      	ldr	r2, [pc, #392]	; (800385c <HAL_RCC_OscConfig+0x348>)
 80036d4:	5cd3      	ldrb	r3, [r2, r3]
 80036d6:	000a      	movs	r2, r1
 80036d8:	40da      	lsrs	r2, r3
 80036da:	4b61      	ldr	r3, [pc, #388]	; (8003860 <HAL_RCC_OscConfig+0x34c>)
 80036dc:	601a      	str	r2, [r3, #0]

      /* Configure the source of time base considering new system clocks settings*/
      status = HAL_InitTick (uwTickPrio);
 80036de:	4b61      	ldr	r3, [pc, #388]	; (8003864 <HAL_RCC_OscConfig+0x350>)
 80036e0:	681b      	ldr	r3, [r3, #0]
 80036e2:	2513      	movs	r5, #19
 80036e4:	197c      	adds	r4, r7, r5
 80036e6:	0018      	movs	r0, r3
 80036e8:	f7ff fb9e 	bl	8002e28 <HAL_InitTick>
 80036ec:	0003      	movs	r3, r0
 80036ee:	7023      	strb	r3, [r4, #0]
      if(status != HAL_OK)
 80036f0:	197b      	adds	r3, r7, r5
 80036f2:	781b      	ldrb	r3, [r3, #0]
 80036f4:	2b00      	cmp	r3, #0
 80036f6:	d046      	beq.n	8003786 <HAL_RCC_OscConfig+0x272>
      {
        return status;
 80036f8:	197b      	adds	r3, r7, r5
 80036fa:	781b      	ldrb	r3, [r3, #0]
 80036fc:	e280      	b.n	8003c00 <HAL_RCC_OscConfig+0x6ec>
      }
    }
    else
    {
      /* Check the HSI State */
      if(hsi_state != RCC_HSI_OFF)
 80036fe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003700:	2b00      	cmp	r3, #0
 8003702:	d027      	beq.n	8003754 <HAL_RCC_OscConfig+0x240>
      {
        /* Enable the Internal High Speed oscillator (HSI or HSIdiv4) */
        __HAL_RCC_HSI_CONFIG(hsi_state);
 8003704:	4b51      	ldr	r3, [pc, #324]	; (800384c <HAL_RCC_OscConfig+0x338>)
 8003706:	681b      	ldr	r3, [r3, #0]
 8003708:	2209      	movs	r2, #9
 800370a:	4393      	bics	r3, r2
 800370c:	0019      	movs	r1, r3
 800370e:	4b4f      	ldr	r3, [pc, #316]	; (800384c <HAL_RCC_OscConfig+0x338>)
 8003710:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8003712:	430a      	orrs	r2, r1
 8003714:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8003716:	f7ff fbcd 	bl	8002eb4 <HAL_GetTick>
 800371a:	0003      	movs	r3, r0
 800371c:	617b      	str	r3, [r7, #20]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 800371e:	e008      	b.n	8003732 <HAL_RCC_OscConfig+0x21e>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8003720:	f7ff fbc8 	bl	8002eb4 <HAL_GetTick>
 8003724:	0002      	movs	r2, r0
 8003726:	697b      	ldr	r3, [r7, #20]
 8003728:	1ad3      	subs	r3, r2, r3
 800372a:	2b02      	cmp	r3, #2
 800372c:	d901      	bls.n	8003732 <HAL_RCC_OscConfig+0x21e>
          {
            return HAL_TIMEOUT;
 800372e:	2303      	movs	r3, #3
 8003730:	e266      	b.n	8003c00 <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8003732:	4b46      	ldr	r3, [pc, #280]	; (800384c <HAL_RCC_OscConfig+0x338>)
 8003734:	681b      	ldr	r3, [r3, #0]
 8003736:	2204      	movs	r2, #4
 8003738:	4013      	ands	r3, r2
 800373a:	d0f1      	beq.n	8003720 <HAL_RCC_OscConfig+0x20c>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800373c:	4b43      	ldr	r3, [pc, #268]	; (800384c <HAL_RCC_OscConfig+0x338>)
 800373e:	685b      	ldr	r3, [r3, #4]
 8003740:	4a45      	ldr	r2, [pc, #276]	; (8003858 <HAL_RCC_OscConfig+0x344>)
 8003742:	4013      	ands	r3, r2
 8003744:	0019      	movs	r1, r3
 8003746:	687b      	ldr	r3, [r7, #4]
 8003748:	691b      	ldr	r3, [r3, #16]
 800374a:	021a      	lsls	r2, r3, #8
 800374c:	4b3f      	ldr	r3, [pc, #252]	; (800384c <HAL_RCC_OscConfig+0x338>)
 800374e:	430a      	orrs	r2, r1
 8003750:	605a      	str	r2, [r3, #4]
 8003752:	e018      	b.n	8003786 <HAL_RCC_OscConfig+0x272>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8003754:	4b3d      	ldr	r3, [pc, #244]	; (800384c <HAL_RCC_OscConfig+0x338>)
 8003756:	681a      	ldr	r2, [r3, #0]
 8003758:	4b3c      	ldr	r3, [pc, #240]	; (800384c <HAL_RCC_OscConfig+0x338>)
 800375a:	2101      	movs	r1, #1
 800375c:	438a      	bics	r2, r1
 800375e:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8003760:	f7ff fba8 	bl	8002eb4 <HAL_GetTick>
 8003764:	0003      	movs	r3, r0
 8003766:	617b      	str	r3, [r7, #20]

        /* Wait till HSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 8003768:	e008      	b.n	800377c <HAL_RCC_OscConfig+0x268>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800376a:	f7ff fba3 	bl	8002eb4 <HAL_GetTick>
 800376e:	0002      	movs	r2, r0
 8003770:	697b      	ldr	r3, [r7, #20]
 8003772:	1ad3      	subs	r3, r2, r3
 8003774:	2b02      	cmp	r3, #2
 8003776:	d901      	bls.n	800377c <HAL_RCC_OscConfig+0x268>
          {
            return HAL_TIMEOUT;
 8003778:	2303      	movs	r3, #3
 800377a:	e241      	b.n	8003c00 <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 800377c:	4b33      	ldr	r3, [pc, #204]	; (800384c <HAL_RCC_OscConfig+0x338>)
 800377e:	681b      	ldr	r3, [r3, #0]
 8003780:	2204      	movs	r2, #4
 8003782:	4013      	ands	r3, r2
 8003784:	d1f1      	bne.n	800376a <HAL_RCC_OscConfig+0x256>
        }
      }
    }
  }
  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8003786:	687b      	ldr	r3, [r7, #4]
 8003788:	681b      	ldr	r3, [r3, #0]
 800378a:	2210      	movs	r2, #16
 800378c:	4013      	ands	r3, r2
 800378e:	d100      	bne.n	8003792 <HAL_RCC_OscConfig+0x27e>
 8003790:	e0a1      	b.n	80038d6 <HAL_RCC_OscConfig+0x3c2>
  {
    /* When the MSI is used as system clock it will not be disabled */
    if(sysclk_source == RCC_CFGR_SWS_MSI)
 8003792:	69fb      	ldr	r3, [r7, #28]
 8003794:	2b00      	cmp	r3, #0
 8003796:	d140      	bne.n	800381a <HAL_RCC_OscConfig+0x306>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 8003798:	4b2c      	ldr	r3, [pc, #176]	; (800384c <HAL_RCC_OscConfig+0x338>)
 800379a:	681a      	ldr	r2, [r3, #0]
 800379c:	2380      	movs	r3, #128	; 0x80
 800379e:	009b      	lsls	r3, r3, #2
 80037a0:	4013      	ands	r3, r2
 80037a2:	d005      	beq.n	80037b0 <HAL_RCC_OscConfig+0x29c>
 80037a4:	687b      	ldr	r3, [r7, #4]
 80037a6:	699b      	ldr	r3, [r3, #24]
 80037a8:	2b00      	cmp	r3, #0
 80037aa:	d101      	bne.n	80037b0 <HAL_RCC_OscConfig+0x29c>
      {
        return HAL_ERROR;
 80037ac:	2301      	movs	r3, #1
 80037ae:	e227      	b.n	8003c00 <HAL_RCC_OscConfig+0x6ec>
        /* Check MSICalibrationValue and MSIClockRange input parameters */
        assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
        assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

        /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 80037b0:	4b26      	ldr	r3, [pc, #152]	; (800384c <HAL_RCC_OscConfig+0x338>)
 80037b2:	685b      	ldr	r3, [r3, #4]
 80037b4:	4a2c      	ldr	r2, [pc, #176]	; (8003868 <HAL_RCC_OscConfig+0x354>)
 80037b6:	4013      	ands	r3, r2
 80037b8:	0019      	movs	r1, r3
 80037ba:	687b      	ldr	r3, [r7, #4]
 80037bc:	6a1a      	ldr	r2, [r3, #32]
 80037be:	4b23      	ldr	r3, [pc, #140]	; (800384c <HAL_RCC_OscConfig+0x338>)
 80037c0:	430a      	orrs	r2, r1
 80037c2:	605a      	str	r2, [r3, #4]
        /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80037c4:	4b21      	ldr	r3, [pc, #132]	; (800384c <HAL_RCC_OscConfig+0x338>)
 80037c6:	685b      	ldr	r3, [r3, #4]
 80037c8:	021b      	lsls	r3, r3, #8
 80037ca:	0a19      	lsrs	r1, r3, #8
 80037cc:	687b      	ldr	r3, [r7, #4]
 80037ce:	69db      	ldr	r3, [r3, #28]
 80037d0:	061a      	lsls	r2, r3, #24
 80037d2:	4b1e      	ldr	r3, [pc, #120]	; (800384c <HAL_RCC_OscConfig+0x338>)
 80037d4:	430a      	orrs	r2, r1
 80037d6:	605a      	str	r2, [r3, #4]


        /* Update the SystemCoreClock global variable */
        SystemCoreClock =  (32768U * (1UL << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_Pos) + 1U)))
 80037d8:	687b      	ldr	r3, [r7, #4]
 80037da:	6a1b      	ldr	r3, [r3, #32]
 80037dc:	0b5b      	lsrs	r3, r3, #13
 80037de:	3301      	adds	r3, #1
 80037e0:	2280      	movs	r2, #128	; 0x80
 80037e2:	0212      	lsls	r2, r2, #8
 80037e4:	409a      	lsls	r2, r3
                           >> AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos)];
 80037e6:	4b19      	ldr	r3, [pc, #100]	; (800384c <HAL_RCC_OscConfig+0x338>)
 80037e8:	68db      	ldr	r3, [r3, #12]
 80037ea:	091b      	lsrs	r3, r3, #4
 80037ec:	210f      	movs	r1, #15
 80037ee:	400b      	ands	r3, r1
 80037f0:	491a      	ldr	r1, [pc, #104]	; (800385c <HAL_RCC_OscConfig+0x348>)
 80037f2:	5ccb      	ldrb	r3, [r1, r3]
 80037f4:	40da      	lsrs	r2, r3
        SystemCoreClock =  (32768U * (1UL << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_Pos) + 1U)))
 80037f6:	4b1a      	ldr	r3, [pc, #104]	; (8003860 <HAL_RCC_OscConfig+0x34c>)
 80037f8:	601a      	str	r2, [r3, #0]

        /* Configure the source of time base considering new system clocks settings*/
        status = HAL_InitTick (uwTickPrio);
 80037fa:	4b1a      	ldr	r3, [pc, #104]	; (8003864 <HAL_RCC_OscConfig+0x350>)
 80037fc:	681b      	ldr	r3, [r3, #0]
 80037fe:	2513      	movs	r5, #19
 8003800:	197c      	adds	r4, r7, r5
 8003802:	0018      	movs	r0, r3
 8003804:	f7ff fb10 	bl	8002e28 <HAL_InitTick>
 8003808:	0003      	movs	r3, r0
 800380a:	7023      	strb	r3, [r4, #0]
        if(status != HAL_OK)
 800380c:	197b      	adds	r3, r7, r5
 800380e:	781b      	ldrb	r3, [r3, #0]
 8003810:	2b00      	cmp	r3, #0
 8003812:	d060      	beq.n	80038d6 <HAL_RCC_OscConfig+0x3c2>
        {
          return status;
 8003814:	197b      	adds	r3, r7, r5
 8003816:	781b      	ldrb	r3, [r3, #0]
 8003818:	e1f2      	b.n	8003c00 <HAL_RCC_OscConfig+0x6ec>
    {
      /* Check MSI State */
      assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));

      /* Check the MSI State */
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 800381a:	687b      	ldr	r3, [r7, #4]
 800381c:	699b      	ldr	r3, [r3, #24]
 800381e:	2b00      	cmp	r3, #0
 8003820:	d03f      	beq.n	80038a2 <HAL_RCC_OscConfig+0x38e>
      {
        /* Enable the Multi Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
 8003822:	4b0a      	ldr	r3, [pc, #40]	; (800384c <HAL_RCC_OscConfig+0x338>)
 8003824:	681a      	ldr	r2, [r3, #0]
 8003826:	4b09      	ldr	r3, [pc, #36]	; (800384c <HAL_RCC_OscConfig+0x338>)
 8003828:	2180      	movs	r1, #128	; 0x80
 800382a:	0049      	lsls	r1, r1, #1
 800382c:	430a      	orrs	r2, r1
 800382e:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8003830:	f7ff fb40 	bl	8002eb4 <HAL_GetTick>
 8003834:	0003      	movs	r3, r0
 8003836:	617b      	str	r3, [r7, #20]

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == 0U)
 8003838:	e018      	b.n	800386c <HAL_RCC_OscConfig+0x358>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 800383a:	f7ff fb3b 	bl	8002eb4 <HAL_GetTick>
 800383e:	0002      	movs	r2, r0
 8003840:	697b      	ldr	r3, [r7, #20]
 8003842:	1ad3      	subs	r3, r2, r3
 8003844:	2b02      	cmp	r3, #2
 8003846:	d911      	bls.n	800386c <HAL_RCC_OscConfig+0x358>
          {
            return HAL_TIMEOUT;
 8003848:	2303      	movs	r3, #3
 800384a:	e1d9      	b.n	8003c00 <HAL_RCC_OscConfig+0x6ec>
 800384c:	40021000 	.word	0x40021000
 8003850:	fffeffff 	.word	0xfffeffff
 8003854:	fffbffff 	.word	0xfffbffff
 8003858:	ffffe0ff 	.word	0xffffe0ff
 800385c:	08022110 	.word	0x08022110
 8003860:	20000010 	.word	0x20000010
 8003864:	20000014 	.word	0x20000014
 8003868:	ffff1fff 	.word	0xffff1fff
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == 0U)
 800386c:	4bc9      	ldr	r3, [pc, #804]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 800386e:	681a      	ldr	r2, [r3, #0]
 8003870:	2380      	movs	r3, #128	; 0x80
 8003872:	009b      	lsls	r3, r3, #2
 8003874:	4013      	ands	r3, r2
 8003876:	d0e0      	beq.n	800383a <HAL_RCC_OscConfig+0x326>
        /* Check MSICalibrationValue and MSIClockRange input parameters */
        assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
        assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

        /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8003878:	4bc6      	ldr	r3, [pc, #792]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 800387a:	685b      	ldr	r3, [r3, #4]
 800387c:	4ac6      	ldr	r2, [pc, #792]	; (8003b98 <HAL_RCC_OscConfig+0x684>)
 800387e:	4013      	ands	r3, r2
 8003880:	0019      	movs	r1, r3
 8003882:	687b      	ldr	r3, [r7, #4]
 8003884:	6a1a      	ldr	r2, [r3, #32]
 8003886:	4bc3      	ldr	r3, [pc, #780]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 8003888:	430a      	orrs	r2, r1
 800388a:	605a      	str	r2, [r3, #4]
         /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 800388c:	4bc1      	ldr	r3, [pc, #772]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 800388e:	685b      	ldr	r3, [r3, #4]
 8003890:	021b      	lsls	r3, r3, #8
 8003892:	0a19      	lsrs	r1, r3, #8
 8003894:	687b      	ldr	r3, [r7, #4]
 8003896:	69db      	ldr	r3, [r3, #28]
 8003898:	061a      	lsls	r2, r3, #24
 800389a:	4bbe      	ldr	r3, [pc, #760]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 800389c:	430a      	orrs	r2, r1
 800389e:	605a      	str	r2, [r3, #4]
 80038a0:	e019      	b.n	80038d6 <HAL_RCC_OscConfig+0x3c2>
      }
      else
      {
        /* Disable the Multi Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
 80038a2:	4bbc      	ldr	r3, [pc, #752]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 80038a4:	681a      	ldr	r2, [r3, #0]
 80038a6:	4bbb      	ldr	r3, [pc, #748]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 80038a8:	49bc      	ldr	r1, [pc, #752]	; (8003b9c <HAL_RCC_OscConfig+0x688>)
 80038aa:	400a      	ands	r2, r1
 80038ac:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80038ae:	f7ff fb01 	bl	8002eb4 <HAL_GetTick>
 80038b2:	0003      	movs	r3, r0
 80038b4:	617b      	str	r3, [r7, #20]

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != 0U)
 80038b6:	e008      	b.n	80038ca <HAL_RCC_OscConfig+0x3b6>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 80038b8:	f7ff fafc 	bl	8002eb4 <HAL_GetTick>
 80038bc:	0002      	movs	r2, r0
 80038be:	697b      	ldr	r3, [r7, #20]
 80038c0:	1ad3      	subs	r3, r2, r3
 80038c2:	2b02      	cmp	r3, #2
 80038c4:	d901      	bls.n	80038ca <HAL_RCC_OscConfig+0x3b6>
          {
            return HAL_TIMEOUT;
 80038c6:	2303      	movs	r3, #3
 80038c8:	e19a      	b.n	8003c00 <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != 0U)
 80038ca:	4bb2      	ldr	r3, [pc, #712]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 80038cc:	681a      	ldr	r2, [r3, #0]
 80038ce:	2380      	movs	r3, #128	; 0x80
 80038d0:	009b      	lsls	r3, r3, #2
 80038d2:	4013      	ands	r3, r2
 80038d4:	d1f0      	bne.n	80038b8 <HAL_RCC_OscConfig+0x3a4>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80038d6:	687b      	ldr	r3, [r7, #4]
 80038d8:	681b      	ldr	r3, [r3, #0]
 80038da:	2208      	movs	r2, #8
 80038dc:	4013      	ands	r3, r2
 80038de:	d036      	beq.n	800394e <HAL_RCC_OscConfig+0x43a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 80038e0:	687b      	ldr	r3, [r7, #4]
 80038e2:	695b      	ldr	r3, [r3, #20]
 80038e4:	2b00      	cmp	r3, #0
 80038e6:	d019      	beq.n	800391c <HAL_RCC_OscConfig+0x408>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 80038e8:	4baa      	ldr	r3, [pc, #680]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 80038ea:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80038ec:	4ba9      	ldr	r3, [pc, #676]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 80038ee:	2101      	movs	r1, #1
 80038f0:	430a      	orrs	r2, r1
 80038f2:	651a      	str	r2, [r3, #80]	; 0x50

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 80038f4:	f7ff fade 	bl	8002eb4 <HAL_GetTick>
 80038f8:	0003      	movs	r3, r0
 80038fa:	617b      	str	r3, [r7, #20]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 80038fc:	e008      	b.n	8003910 <HAL_RCC_OscConfig+0x3fc>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80038fe:	f7ff fad9 	bl	8002eb4 <HAL_GetTick>
 8003902:	0002      	movs	r2, r0
 8003904:	697b      	ldr	r3, [r7, #20]
 8003906:	1ad3      	subs	r3, r2, r3
 8003908:	2b02      	cmp	r3, #2
 800390a:	d901      	bls.n	8003910 <HAL_RCC_OscConfig+0x3fc>
        {
          return HAL_TIMEOUT;
 800390c:	2303      	movs	r3, #3
 800390e:	e177      	b.n	8003c00 <HAL_RCC_OscConfig+0x6ec>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 8003910:	4ba0      	ldr	r3, [pc, #640]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 8003912:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8003914:	2202      	movs	r2, #2
 8003916:	4013      	ands	r3, r2
 8003918:	d0f1      	beq.n	80038fe <HAL_RCC_OscConfig+0x3ea>
 800391a:	e018      	b.n	800394e <HAL_RCC_OscConfig+0x43a>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 800391c:	4b9d      	ldr	r3, [pc, #628]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 800391e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003920:	4b9c      	ldr	r3, [pc, #624]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 8003922:	2101      	movs	r1, #1
 8003924:	438a      	bics	r2, r1
 8003926:	651a      	str	r2, [r3, #80]	; 0x50

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8003928:	f7ff fac4 	bl	8002eb4 <HAL_GetTick>
 800392c:	0003      	movs	r3, r0
 800392e:	617b      	str	r3, [r7, #20]

      /* Wait till LSI is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 8003930:	e008      	b.n	8003944 <HAL_RCC_OscConfig+0x430>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8003932:	f7ff fabf 	bl	8002eb4 <HAL_GetTick>
 8003936:	0002      	movs	r2, r0
 8003938:	697b      	ldr	r3, [r7, #20]
 800393a:	1ad3      	subs	r3, r2, r3
 800393c:	2b02      	cmp	r3, #2
 800393e:	d901      	bls.n	8003944 <HAL_RCC_OscConfig+0x430>
        {
          return HAL_TIMEOUT;
 8003940:	2303      	movs	r3, #3
 8003942:	e15d      	b.n	8003c00 <HAL_RCC_OscConfig+0x6ec>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 8003944:	4b93      	ldr	r3, [pc, #588]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 8003946:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8003948:	2202      	movs	r2, #2
 800394a:	4013      	ands	r3, r2
 800394c:	d1f1      	bne.n	8003932 <HAL_RCC_OscConfig+0x41e>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800394e:	687b      	ldr	r3, [r7, #4]
 8003950:	681b      	ldr	r3, [r3, #0]
 8003952:	2204      	movs	r2, #4
 8003954:	4013      	ands	r3, r2
 8003956:	d100      	bne.n	800395a <HAL_RCC_OscConfig+0x446>
 8003958:	e0ae      	b.n	8003ab8 <HAL_RCC_OscConfig+0x5a4>
  {
    FlagStatus       pwrclkchanged = RESET;
 800395a:	2023      	movs	r0, #35	; 0x23
 800395c:	183b      	adds	r3, r7, r0
 800395e:	2200      	movs	r2, #0
 8003960:	701a      	strb	r2, [r3, #0]
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8003962:	4b8c      	ldr	r3, [pc, #560]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 8003964:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8003966:	2380      	movs	r3, #128	; 0x80
 8003968:	055b      	lsls	r3, r3, #21
 800396a:	4013      	ands	r3, r2
 800396c:	d109      	bne.n	8003982 <HAL_RCC_OscConfig+0x46e>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 800396e:	4b89      	ldr	r3, [pc, #548]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 8003970:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8003972:	4b88      	ldr	r3, [pc, #544]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 8003974:	2180      	movs	r1, #128	; 0x80
 8003976:	0549      	lsls	r1, r1, #21
 8003978:	430a      	orrs	r2, r1
 800397a:	639a      	str	r2, [r3, #56]	; 0x38
      pwrclkchanged = SET;
 800397c:	183b      	adds	r3, r7, r0
 800397e:	2201      	movs	r2, #1
 8003980:	701a      	strb	r2, [r3, #0]
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8003982:	4b87      	ldr	r3, [pc, #540]	; (8003ba0 <HAL_RCC_OscConfig+0x68c>)
 8003984:	681a      	ldr	r2, [r3, #0]
 8003986:	2380      	movs	r3, #128	; 0x80
 8003988:	005b      	lsls	r3, r3, #1
 800398a:	4013      	ands	r3, r2
 800398c:	d11a      	bne.n	80039c4 <HAL_RCC_OscConfig+0x4b0>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 800398e:	4b84      	ldr	r3, [pc, #528]	; (8003ba0 <HAL_RCC_OscConfig+0x68c>)
 8003990:	681a      	ldr	r2, [r3, #0]
 8003992:	4b83      	ldr	r3, [pc, #524]	; (8003ba0 <HAL_RCC_OscConfig+0x68c>)
 8003994:	2180      	movs	r1, #128	; 0x80
 8003996:	0049      	lsls	r1, r1, #1
 8003998:	430a      	orrs	r2, r1
 800399a:	601a      	str	r2, [r3, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 800399c:	f7ff fa8a 	bl	8002eb4 <HAL_GetTick>
 80039a0:	0003      	movs	r3, r0
 80039a2:	617b      	str	r3, [r7, #20]

      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80039a4:	e008      	b.n	80039b8 <HAL_RCC_OscConfig+0x4a4>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80039a6:	f7ff fa85 	bl	8002eb4 <HAL_GetTick>
 80039aa:	0002      	movs	r2, r0
 80039ac:	697b      	ldr	r3, [r7, #20]
 80039ae:	1ad3      	subs	r3, r2, r3
 80039b0:	2b64      	cmp	r3, #100	; 0x64
 80039b2:	d901      	bls.n	80039b8 <HAL_RCC_OscConfig+0x4a4>
        {
          return HAL_TIMEOUT;
 80039b4:	2303      	movs	r3, #3
 80039b6:	e123      	b.n	8003c00 <HAL_RCC_OscConfig+0x6ec>
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80039b8:	4b79      	ldr	r3, [pc, #484]	; (8003ba0 <HAL_RCC_OscConfig+0x68c>)
 80039ba:	681a      	ldr	r2, [r3, #0]
 80039bc:	2380      	movs	r3, #128	; 0x80
 80039be:	005b      	lsls	r3, r3, #1
 80039c0:	4013      	ands	r3, r2
 80039c2:	d0f0      	beq.n	80039a6 <HAL_RCC_OscConfig+0x492>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80039c4:	687b      	ldr	r3, [r7, #4]
 80039c6:	689a      	ldr	r2, [r3, #8]
 80039c8:	2380      	movs	r3, #128	; 0x80
 80039ca:	005b      	lsls	r3, r3, #1
 80039cc:	429a      	cmp	r2, r3
 80039ce:	d107      	bne.n	80039e0 <HAL_RCC_OscConfig+0x4cc>
 80039d0:	4b70      	ldr	r3, [pc, #448]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 80039d2:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80039d4:	4b6f      	ldr	r3, [pc, #444]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 80039d6:	2180      	movs	r1, #128	; 0x80
 80039d8:	0049      	lsls	r1, r1, #1
 80039da:	430a      	orrs	r2, r1
 80039dc:	651a      	str	r2, [r3, #80]	; 0x50
 80039de:	e031      	b.n	8003a44 <HAL_RCC_OscConfig+0x530>
 80039e0:	687b      	ldr	r3, [r7, #4]
 80039e2:	689b      	ldr	r3, [r3, #8]
 80039e4:	2b00      	cmp	r3, #0
 80039e6:	d10c      	bne.n	8003a02 <HAL_RCC_OscConfig+0x4ee>
 80039e8:	4b6a      	ldr	r3, [pc, #424]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 80039ea:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80039ec:	4b69      	ldr	r3, [pc, #420]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 80039ee:	496b      	ldr	r1, [pc, #428]	; (8003b9c <HAL_RCC_OscConfig+0x688>)
 80039f0:	400a      	ands	r2, r1
 80039f2:	651a      	str	r2, [r3, #80]	; 0x50
 80039f4:	4b67      	ldr	r3, [pc, #412]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 80039f6:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80039f8:	4b66      	ldr	r3, [pc, #408]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 80039fa:	496a      	ldr	r1, [pc, #424]	; (8003ba4 <HAL_RCC_OscConfig+0x690>)
 80039fc:	400a      	ands	r2, r1
 80039fe:	651a      	str	r2, [r3, #80]	; 0x50
 8003a00:	e020      	b.n	8003a44 <HAL_RCC_OscConfig+0x530>
 8003a02:	687b      	ldr	r3, [r7, #4]
 8003a04:	689a      	ldr	r2, [r3, #8]
 8003a06:	23a0      	movs	r3, #160	; 0xa0
 8003a08:	00db      	lsls	r3, r3, #3
 8003a0a:	429a      	cmp	r2, r3
 8003a0c:	d10e      	bne.n	8003a2c <HAL_RCC_OscConfig+0x518>
 8003a0e:	4b61      	ldr	r3, [pc, #388]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 8003a10:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003a12:	4b60      	ldr	r3, [pc, #384]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 8003a14:	2180      	movs	r1, #128	; 0x80
 8003a16:	00c9      	lsls	r1, r1, #3
 8003a18:	430a      	orrs	r2, r1
 8003a1a:	651a      	str	r2, [r3, #80]	; 0x50
 8003a1c:	4b5d      	ldr	r3, [pc, #372]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 8003a1e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003a20:	4b5c      	ldr	r3, [pc, #368]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 8003a22:	2180      	movs	r1, #128	; 0x80
 8003a24:	0049      	lsls	r1, r1, #1
 8003a26:	430a      	orrs	r2, r1
 8003a28:	651a      	str	r2, [r3, #80]	; 0x50
 8003a2a:	e00b      	b.n	8003a44 <HAL_RCC_OscConfig+0x530>
 8003a2c:	4b59      	ldr	r3, [pc, #356]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 8003a2e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003a30:	4b58      	ldr	r3, [pc, #352]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 8003a32:	495a      	ldr	r1, [pc, #360]	; (8003b9c <HAL_RCC_OscConfig+0x688>)
 8003a34:	400a      	ands	r2, r1
 8003a36:	651a      	str	r2, [r3, #80]	; 0x50
 8003a38:	4b56      	ldr	r3, [pc, #344]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 8003a3a:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003a3c:	4b55      	ldr	r3, [pc, #340]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 8003a3e:	4959      	ldr	r1, [pc, #356]	; (8003ba4 <HAL_RCC_OscConfig+0x690>)
 8003a40:	400a      	ands	r2, r1
 8003a42:	651a      	str	r2, [r3, #80]	; 0x50

    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8003a44:	687b      	ldr	r3, [r7, #4]
 8003a46:	689b      	ldr	r3, [r3, #8]
 8003a48:	2b00      	cmp	r3, #0
 8003a4a:	d015      	beq.n	8003a78 <HAL_RCC_OscConfig+0x564>
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8003a4c:	f7ff fa32 	bl	8002eb4 <HAL_GetTick>
 8003a50:	0003      	movs	r3, r0
 8003a52:	617b      	str	r3, [r7, #20]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8003a54:	e009      	b.n	8003a6a <HAL_RCC_OscConfig+0x556>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8003a56:	f7ff fa2d 	bl	8002eb4 <HAL_GetTick>
 8003a5a:	0002      	movs	r2, r0
 8003a5c:	697b      	ldr	r3, [r7, #20]
 8003a5e:	1ad3      	subs	r3, r2, r3
 8003a60:	4a51      	ldr	r2, [pc, #324]	; (8003ba8 <HAL_RCC_OscConfig+0x694>)
 8003a62:	4293      	cmp	r3, r2
 8003a64:	d901      	bls.n	8003a6a <HAL_RCC_OscConfig+0x556>
        {
          return HAL_TIMEOUT;
 8003a66:	2303      	movs	r3, #3
 8003a68:	e0ca      	b.n	8003c00 <HAL_RCC_OscConfig+0x6ec>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8003a6a:	4b4a      	ldr	r3, [pc, #296]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 8003a6c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003a6e:	2380      	movs	r3, #128	; 0x80
 8003a70:	009b      	lsls	r3, r3, #2
 8003a72:	4013      	ands	r3, r2
 8003a74:	d0ef      	beq.n	8003a56 <HAL_RCC_OscConfig+0x542>
 8003a76:	e014      	b.n	8003aa2 <HAL_RCC_OscConfig+0x58e>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8003a78:	f7ff fa1c 	bl	8002eb4 <HAL_GetTick>
 8003a7c:	0003      	movs	r3, r0
 8003a7e:	617b      	str	r3, [r7, #20]

      /* Wait till LSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 8003a80:	e009      	b.n	8003a96 <HAL_RCC_OscConfig+0x582>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8003a82:	f7ff fa17 	bl	8002eb4 <HAL_GetTick>
 8003a86:	0002      	movs	r2, r0
 8003a88:	697b      	ldr	r3, [r7, #20]
 8003a8a:	1ad3      	subs	r3, r2, r3
 8003a8c:	4a46      	ldr	r2, [pc, #280]	; (8003ba8 <HAL_RCC_OscConfig+0x694>)
 8003a8e:	4293      	cmp	r3, r2
 8003a90:	d901      	bls.n	8003a96 <HAL_RCC_OscConfig+0x582>
        {
          return HAL_TIMEOUT;
 8003a92:	2303      	movs	r3, #3
 8003a94:	e0b4      	b.n	8003c00 <HAL_RCC_OscConfig+0x6ec>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 8003a96:	4b3f      	ldr	r3, [pc, #252]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 8003a98:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003a9a:	2380      	movs	r3, #128	; 0x80
 8003a9c:	009b      	lsls	r3, r3, #2
 8003a9e:	4013      	ands	r3, r2
 8003aa0:	d1ef      	bne.n	8003a82 <HAL_RCC_OscConfig+0x56e>
        }
      }
    }

    /* Require to disable power clock if necessary */
    if(pwrclkchanged == SET)
 8003aa2:	2323      	movs	r3, #35	; 0x23
 8003aa4:	18fb      	adds	r3, r7, r3
 8003aa6:	781b      	ldrb	r3, [r3, #0]
 8003aa8:	2b01      	cmp	r3, #1
 8003aaa:	d105      	bne.n	8003ab8 <HAL_RCC_OscConfig+0x5a4>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8003aac:	4b39      	ldr	r3, [pc, #228]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 8003aae:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8003ab0:	4b38      	ldr	r3, [pc, #224]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 8003ab2:	493e      	ldr	r1, [pc, #248]	; (8003bac <HAL_RCC_OscConfig+0x698>)
 8003ab4:	400a      	ands	r2, r1
 8003ab6:	639a      	str	r2, [r3, #56]	; 0x38
#endif /* RCC_HSI48_SUPPORT */

  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8003ab8:	687b      	ldr	r3, [r7, #4]
 8003aba:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003abc:	2b00      	cmp	r3, #0
 8003abe:	d100      	bne.n	8003ac2 <HAL_RCC_OscConfig+0x5ae>
 8003ac0:	e09d      	b.n	8003bfe <HAL_RCC_OscConfig+0x6ea>
  {
    /* Check if the PLL is used as system clock or not */
    if(sysclk_source != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8003ac2:	69fb      	ldr	r3, [r7, #28]
 8003ac4:	2b0c      	cmp	r3, #12
 8003ac6:	d100      	bne.n	8003aca <HAL_RCC_OscConfig+0x5b6>
 8003ac8:	e076      	b.n	8003bb8 <HAL_RCC_OscConfig+0x6a4>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8003aca:	687b      	ldr	r3, [r7, #4]
 8003acc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003ace:	2b02      	cmp	r3, #2
 8003ad0:	d145      	bne.n	8003b5e <HAL_RCC_OscConfig+0x64a>
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
        assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
        assert_param(IS_RCC_PLL_DIV(RCC_OscInitStruct->PLL.PLLDIV));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8003ad2:	4b30      	ldr	r3, [pc, #192]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 8003ad4:	681a      	ldr	r2, [r3, #0]
 8003ad6:	4b2f      	ldr	r3, [pc, #188]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 8003ad8:	4935      	ldr	r1, [pc, #212]	; (8003bb0 <HAL_RCC_OscConfig+0x69c>)
 8003ada:	400a      	ands	r2, r1
 8003adc:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8003ade:	f7ff f9e9 	bl	8002eb4 <HAL_GetTick>
 8003ae2:	0003      	movs	r3, r0
 8003ae4:	617b      	str	r3, [r7, #20]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 8003ae6:	e008      	b.n	8003afa <HAL_RCC_OscConfig+0x5e6>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8003ae8:	f7ff f9e4 	bl	8002eb4 <HAL_GetTick>
 8003aec:	0002      	movs	r2, r0
 8003aee:	697b      	ldr	r3, [r7, #20]
 8003af0:	1ad3      	subs	r3, r2, r3
 8003af2:	2b02      	cmp	r3, #2
 8003af4:	d901      	bls.n	8003afa <HAL_RCC_OscConfig+0x5e6>
          {
            return HAL_TIMEOUT;
 8003af6:	2303      	movs	r3, #3
 8003af8:	e082      	b.n	8003c00 <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 8003afa:	4b26      	ldr	r3, [pc, #152]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 8003afc:	681a      	ldr	r2, [r3, #0]
 8003afe:	2380      	movs	r3, #128	; 0x80
 8003b00:	049b      	lsls	r3, r3, #18
 8003b02:	4013      	ands	r3, r2
 8003b04:	d1f0      	bne.n	8003ae8 <HAL_RCC_OscConfig+0x5d4>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8003b06:	4b23      	ldr	r3, [pc, #140]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 8003b08:	68db      	ldr	r3, [r3, #12]
 8003b0a:	4a2a      	ldr	r2, [pc, #168]	; (8003bb4 <HAL_RCC_OscConfig+0x6a0>)
 8003b0c:	4013      	ands	r3, r2
 8003b0e:	0019      	movs	r1, r3
 8003b10:	687b      	ldr	r3, [r7, #4]
 8003b12:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8003b14:	687b      	ldr	r3, [r7, #4]
 8003b16:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003b18:	431a      	orrs	r2, r3
 8003b1a:	687b      	ldr	r3, [r7, #4]
 8003b1c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8003b1e:	431a      	orrs	r2, r3
 8003b20:	4b1c      	ldr	r3, [pc, #112]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 8003b22:	430a      	orrs	r2, r1
 8003b24:	60da      	str	r2, [r3, #12]
                             RCC_OscInitStruct->PLL.PLLMUL,
                             RCC_OscInitStruct->PLL.PLLDIV);
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8003b26:	4b1b      	ldr	r3, [pc, #108]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 8003b28:	681a      	ldr	r2, [r3, #0]
 8003b2a:	4b1a      	ldr	r3, [pc, #104]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 8003b2c:	2180      	movs	r1, #128	; 0x80
 8003b2e:	0449      	lsls	r1, r1, #17
 8003b30:	430a      	orrs	r2, r1
 8003b32:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8003b34:	f7ff f9be 	bl	8002eb4 <HAL_GetTick>
 8003b38:	0003      	movs	r3, r0
 8003b3a:	617b      	str	r3, [r7, #20]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == 0U)
 8003b3c:	e008      	b.n	8003b50 <HAL_RCC_OscConfig+0x63c>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8003b3e:	f7ff f9b9 	bl	8002eb4 <HAL_GetTick>
 8003b42:	0002      	movs	r2, r0
 8003b44:	697b      	ldr	r3, [r7, #20]
 8003b46:	1ad3      	subs	r3, r2, r3
 8003b48:	2b02      	cmp	r3, #2
 8003b4a:	d901      	bls.n	8003b50 <HAL_RCC_OscConfig+0x63c>
          {
            return HAL_TIMEOUT;
 8003b4c:	2303      	movs	r3, #3
 8003b4e:	e057      	b.n	8003c00 <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == 0U)
 8003b50:	4b10      	ldr	r3, [pc, #64]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 8003b52:	681a      	ldr	r2, [r3, #0]
 8003b54:	2380      	movs	r3, #128	; 0x80
 8003b56:	049b      	lsls	r3, r3, #18
 8003b58:	4013      	ands	r3, r2
 8003b5a:	d0f0      	beq.n	8003b3e <HAL_RCC_OscConfig+0x62a>
 8003b5c:	e04f      	b.n	8003bfe <HAL_RCC_OscConfig+0x6ea>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8003b5e:	4b0d      	ldr	r3, [pc, #52]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 8003b60:	681a      	ldr	r2, [r3, #0]
 8003b62:	4b0c      	ldr	r3, [pc, #48]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 8003b64:	4912      	ldr	r1, [pc, #72]	; (8003bb0 <HAL_RCC_OscConfig+0x69c>)
 8003b66:	400a      	ands	r2, r1
 8003b68:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8003b6a:	f7ff f9a3 	bl	8002eb4 <HAL_GetTick>
 8003b6e:	0003      	movs	r3, r0
 8003b70:	617b      	str	r3, [r7, #20]

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 8003b72:	e008      	b.n	8003b86 <HAL_RCC_OscConfig+0x672>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8003b74:	f7ff f99e 	bl	8002eb4 <HAL_GetTick>
 8003b78:	0002      	movs	r2, r0
 8003b7a:	697b      	ldr	r3, [r7, #20]
 8003b7c:	1ad3      	subs	r3, r2, r3
 8003b7e:	2b02      	cmp	r3, #2
 8003b80:	d901      	bls.n	8003b86 <HAL_RCC_OscConfig+0x672>
          {
            return HAL_TIMEOUT;
 8003b82:	2303      	movs	r3, #3
 8003b84:	e03c      	b.n	8003c00 <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 8003b86:	4b03      	ldr	r3, [pc, #12]	; (8003b94 <HAL_RCC_OscConfig+0x680>)
 8003b88:	681a      	ldr	r2, [r3, #0]
 8003b8a:	2380      	movs	r3, #128	; 0x80
 8003b8c:	049b      	lsls	r3, r3, #18
 8003b8e:	4013      	ands	r3, r2
 8003b90:	d1f0      	bne.n	8003b74 <HAL_RCC_OscConfig+0x660>
 8003b92:	e034      	b.n	8003bfe <HAL_RCC_OscConfig+0x6ea>
 8003b94:	40021000 	.word	0x40021000
 8003b98:	ffff1fff 	.word	0xffff1fff
 8003b9c:	fffffeff 	.word	0xfffffeff
 8003ba0:	40007000 	.word	0x40007000
 8003ba4:	fffffbff 	.word	0xfffffbff
 8003ba8:	00001388 	.word	0x00001388
 8003bac:	efffffff 	.word	0xefffffff
 8003bb0:	feffffff 	.word	0xfeffffff
 8003bb4:	ff02ffff 	.word	0xff02ffff
      }
    }
    else
    {
      /* Check if there is a request to disable the PLL used as System clock source */
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 8003bb8:	687b      	ldr	r3, [r7, #4]
 8003bba:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003bbc:	2b01      	cmp	r3, #1
 8003bbe:	d101      	bne.n	8003bc4 <HAL_RCC_OscConfig+0x6b0>
      {
        return HAL_ERROR;
 8003bc0:	2301      	movs	r3, #1
 8003bc2:	e01d      	b.n	8003c00 <HAL_RCC_OscConfig+0x6ec>
      }
      else
      {
        /* Do not return HAL_ERROR if request repeats the current configuration */
        pll_config = RCC->CFGR;
 8003bc4:	4b10      	ldr	r3, [pc, #64]	; (8003c08 <HAL_RCC_OscConfig+0x6f4>)
 8003bc6:	68db      	ldr	r3, [r3, #12]
 8003bc8:	61bb      	str	r3, [r7, #24]
        if((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8003bca:	69ba      	ldr	r2, [r7, #24]
 8003bcc:	2380      	movs	r3, #128	; 0x80
 8003bce:	025b      	lsls	r3, r3, #9
 8003bd0:	401a      	ands	r2, r3
 8003bd2:	687b      	ldr	r3, [r7, #4]
 8003bd4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003bd6:	429a      	cmp	r2, r3
 8003bd8:	d10f      	bne.n	8003bfa <HAL_RCC_OscConfig+0x6e6>
           (READ_BIT(pll_config, RCC_CFGR_PLLMUL) != RCC_OscInitStruct->PLL.PLLMUL) ||
 8003bda:	69ba      	ldr	r2, [r7, #24]
 8003bdc:	23f0      	movs	r3, #240	; 0xf0
 8003bde:	039b      	lsls	r3, r3, #14
 8003be0:	401a      	ands	r2, r3
 8003be2:	687b      	ldr	r3, [r7, #4]
 8003be4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
        if((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8003be6:	429a      	cmp	r2, r3
 8003be8:	d107      	bne.n	8003bfa <HAL_RCC_OscConfig+0x6e6>
           (READ_BIT(pll_config, RCC_CFGR_PLLDIV) != RCC_OscInitStruct->PLL.PLLDIV))
 8003bea:	69ba      	ldr	r2, [r7, #24]
 8003bec:	23c0      	movs	r3, #192	; 0xc0
 8003bee:	041b      	lsls	r3, r3, #16
 8003bf0:	401a      	ands	r2, r3
 8003bf2:	687b      	ldr	r3, [r7, #4]
 8003bf4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
           (READ_BIT(pll_config, RCC_CFGR_PLLMUL) != RCC_OscInitStruct->PLL.PLLMUL) ||
 8003bf6:	429a      	cmp	r2, r3
 8003bf8:	d001      	beq.n	8003bfe <HAL_RCC_OscConfig+0x6ea>
        {
          return HAL_ERROR;
 8003bfa:	2301      	movs	r3, #1
 8003bfc:	e000      	b.n	8003c00 <HAL_RCC_OscConfig+0x6ec>
        }
      }
    }
  }
  return HAL_OK;
 8003bfe:	2300      	movs	r3, #0
}
 8003c00:	0018      	movs	r0, r3
 8003c02:	46bd      	mov	sp, r7
 8003c04:	b00a      	add	sp, #40	; 0x28
 8003c06:	bdb0      	pop	{r4, r5, r7, pc}
 8003c08:	40021000 	.word	0x40021000

08003c0c <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8003c0c:	b5b0      	push	{r4, r5, r7, lr}
 8003c0e:	b084      	sub	sp, #16
 8003c10:	af00      	add	r7, sp, #0
 8003c12:	6078      	str	r0, [r7, #4]
 8003c14:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  HAL_StatusTypeDef status;

  /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
 8003c16:	687b      	ldr	r3, [r7, #4]
 8003c18:	2b00      	cmp	r3, #0
 8003c1a:	d101      	bne.n	8003c20 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 8003c1c:	2301      	movs	r3, #1
 8003c1e:	e128      	b.n	8003e72 <HAL_RCC_ClockConfig+0x266>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
  must be correctly programmed according to the frequency of the CPU clock
  (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8003c20:	4b96      	ldr	r3, [pc, #600]	; (8003e7c <HAL_RCC_ClockConfig+0x270>)
 8003c22:	681b      	ldr	r3, [r3, #0]
 8003c24:	2201      	movs	r2, #1
 8003c26:	4013      	ands	r3, r2
 8003c28:	683a      	ldr	r2, [r7, #0]
 8003c2a:	429a      	cmp	r2, r3
 8003c2c:	d91e      	bls.n	8003c6c <HAL_RCC_ClockConfig+0x60>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8003c2e:	4b93      	ldr	r3, [pc, #588]	; (8003e7c <HAL_RCC_ClockConfig+0x270>)
 8003c30:	681b      	ldr	r3, [r3, #0]
 8003c32:	2201      	movs	r2, #1
 8003c34:	4393      	bics	r3, r2
 8003c36:	0019      	movs	r1, r3
 8003c38:	4b90      	ldr	r3, [pc, #576]	; (8003e7c <HAL_RCC_ClockConfig+0x270>)
 8003c3a:	683a      	ldr	r2, [r7, #0]
 8003c3c:	430a      	orrs	r2, r1
 8003c3e:	601a      	str	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by polling the FLASH_ACR register */
    tickstart = HAL_GetTick();
 8003c40:	f7ff f938 	bl	8002eb4 <HAL_GetTick>
 8003c44:	0003      	movs	r3, r0
 8003c46:	60fb      	str	r3, [r7, #12]

    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 8003c48:	e009      	b.n	8003c5e <HAL_RCC_ClockConfig+0x52>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8003c4a:	f7ff f933 	bl	8002eb4 <HAL_GetTick>
 8003c4e:	0002      	movs	r2, r0
 8003c50:	68fb      	ldr	r3, [r7, #12]
 8003c52:	1ad3      	subs	r3, r2, r3
 8003c54:	4a8a      	ldr	r2, [pc, #552]	; (8003e80 <HAL_RCC_ClockConfig+0x274>)
 8003c56:	4293      	cmp	r3, r2
 8003c58:	d901      	bls.n	8003c5e <HAL_RCC_ClockConfig+0x52>
      {
        return HAL_TIMEOUT;
 8003c5a:	2303      	movs	r3, #3
 8003c5c:	e109      	b.n	8003e72 <HAL_RCC_ClockConfig+0x266>
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 8003c5e:	4b87      	ldr	r3, [pc, #540]	; (8003e7c <HAL_RCC_ClockConfig+0x270>)
 8003c60:	681b      	ldr	r3, [r3, #0]
 8003c62:	2201      	movs	r2, #1
 8003c64:	4013      	ands	r3, r2
 8003c66:	683a      	ldr	r2, [r7, #0]
 8003c68:	429a      	cmp	r2, r3
 8003c6a:	d1ee      	bne.n	8003c4a <HAL_RCC_ClockConfig+0x3e>
      }
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8003c6c:	687b      	ldr	r3, [r7, #4]
 8003c6e:	681b      	ldr	r3, [r3, #0]
 8003c70:	2202      	movs	r2, #2
 8003c72:	4013      	ands	r3, r2
 8003c74:	d009      	beq.n	8003c8a <HAL_RCC_ClockConfig+0x7e>
  {
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8003c76:	4b83      	ldr	r3, [pc, #524]	; (8003e84 <HAL_RCC_ClockConfig+0x278>)
 8003c78:	68db      	ldr	r3, [r3, #12]
 8003c7a:	22f0      	movs	r2, #240	; 0xf0
 8003c7c:	4393      	bics	r3, r2
 8003c7e:	0019      	movs	r1, r3
 8003c80:	687b      	ldr	r3, [r7, #4]
 8003c82:	689a      	ldr	r2, [r3, #8]
 8003c84:	4b7f      	ldr	r3, [pc, #508]	; (8003e84 <HAL_RCC_ClockConfig+0x278>)
 8003c86:	430a      	orrs	r2, r1
 8003c88:	60da      	str	r2, [r3, #12]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8003c8a:	687b      	ldr	r3, [r7, #4]
 8003c8c:	681b      	ldr	r3, [r3, #0]
 8003c8e:	2201      	movs	r2, #1
 8003c90:	4013      	ands	r3, r2
 8003c92:	d100      	bne.n	8003c96 <HAL_RCC_ClockConfig+0x8a>
 8003c94:	e089      	b.n	8003daa <HAL_RCC_ClockConfig+0x19e>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8003c96:	687b      	ldr	r3, [r7, #4]
 8003c98:	685b      	ldr	r3, [r3, #4]
 8003c9a:	2b02      	cmp	r3, #2
 8003c9c:	d107      	bne.n	8003cae <HAL_RCC_ClockConfig+0xa2>
    {
      /* Check the HSE ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 8003c9e:	4b79      	ldr	r3, [pc, #484]	; (8003e84 <HAL_RCC_ClockConfig+0x278>)
 8003ca0:	681a      	ldr	r2, [r3, #0]
 8003ca2:	2380      	movs	r3, #128	; 0x80
 8003ca4:	029b      	lsls	r3, r3, #10
 8003ca6:	4013      	ands	r3, r2
 8003ca8:	d120      	bne.n	8003cec <HAL_RCC_ClockConfig+0xe0>
      {
        return HAL_ERROR;
 8003caa:	2301      	movs	r3, #1
 8003cac:	e0e1      	b.n	8003e72 <HAL_RCC_ClockConfig+0x266>
      }
    }
    /* PLL is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8003cae:	687b      	ldr	r3, [r7, #4]
 8003cb0:	685b      	ldr	r3, [r3, #4]
 8003cb2:	2b03      	cmp	r3, #3
 8003cb4:	d107      	bne.n	8003cc6 <HAL_RCC_ClockConfig+0xba>
    {
      /* Check the PLL ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 8003cb6:	4b73      	ldr	r3, [pc, #460]	; (8003e84 <HAL_RCC_ClockConfig+0x278>)
 8003cb8:	681a      	ldr	r2, [r3, #0]
 8003cba:	2380      	movs	r3, #128	; 0x80
 8003cbc:	049b      	lsls	r3, r3, #18
 8003cbe:	4013      	ands	r3, r2
 8003cc0:	d114      	bne.n	8003cec <HAL_RCC_ClockConfig+0xe0>
      {
        return HAL_ERROR;
 8003cc2:	2301      	movs	r3, #1
 8003cc4:	e0d5      	b.n	8003e72 <HAL_RCC_ClockConfig+0x266>
      }
    }
    /* HSI is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
 8003cc6:	687b      	ldr	r3, [r7, #4]
 8003cc8:	685b      	ldr	r3, [r3, #4]
 8003cca:	2b01      	cmp	r3, #1
 8003ccc:	d106      	bne.n	8003cdc <HAL_RCC_ClockConfig+0xd0>
    {
      /* Check the HSI ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8003cce:	4b6d      	ldr	r3, [pc, #436]	; (8003e84 <HAL_RCC_ClockConfig+0x278>)
 8003cd0:	681b      	ldr	r3, [r3, #0]
 8003cd2:	2204      	movs	r2, #4
 8003cd4:	4013      	ands	r3, r2
 8003cd6:	d109      	bne.n	8003cec <HAL_RCC_ClockConfig+0xe0>
      {
        return HAL_ERROR;
 8003cd8:	2301      	movs	r3, #1
 8003cda:	e0ca      	b.n	8003e72 <HAL_RCC_ClockConfig+0x266>
    }
    /* MSI is selected as System Clock Source */
    else
    {
      /* Check the MSI ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == 0U)
 8003cdc:	4b69      	ldr	r3, [pc, #420]	; (8003e84 <HAL_RCC_ClockConfig+0x278>)
 8003cde:	681a      	ldr	r2, [r3, #0]
 8003ce0:	2380      	movs	r3, #128	; 0x80
 8003ce2:	009b      	lsls	r3, r3, #2
 8003ce4:	4013      	ands	r3, r2
 8003ce6:	d101      	bne.n	8003cec <HAL_RCC_ClockConfig+0xe0>
      {
        return HAL_ERROR;
 8003ce8:	2301      	movs	r3, #1
 8003cea:	e0c2      	b.n	8003e72 <HAL_RCC_ClockConfig+0x266>
      }
    }
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8003cec:	4b65      	ldr	r3, [pc, #404]	; (8003e84 <HAL_RCC_ClockConfig+0x278>)
 8003cee:	68db      	ldr	r3, [r3, #12]
 8003cf0:	2203      	movs	r2, #3
 8003cf2:	4393      	bics	r3, r2
 8003cf4:	0019      	movs	r1, r3
 8003cf6:	687b      	ldr	r3, [r7, #4]
 8003cf8:	685a      	ldr	r2, [r3, #4]
 8003cfa:	4b62      	ldr	r3, [pc, #392]	; (8003e84 <HAL_RCC_ClockConfig+0x278>)
 8003cfc:	430a      	orrs	r2, r1
 8003cfe:	60da      	str	r2, [r3, #12]

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 8003d00:	f7ff f8d8 	bl	8002eb4 <HAL_GetTick>
 8003d04:	0003      	movs	r3, r0
 8003d06:	60fb      	str	r3, [r7, #12]

    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8003d08:	687b      	ldr	r3, [r7, #4]
 8003d0a:	685b      	ldr	r3, [r3, #4]
 8003d0c:	2b02      	cmp	r3, #2
 8003d0e:	d111      	bne.n	8003d34 <HAL_RCC_ClockConfig+0x128>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8003d10:	e009      	b.n	8003d26 <HAL_RCC_ClockConfig+0x11a>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8003d12:	f7ff f8cf 	bl	8002eb4 <HAL_GetTick>
 8003d16:	0002      	movs	r2, r0
 8003d18:	68fb      	ldr	r3, [r7, #12]
 8003d1a:	1ad3      	subs	r3, r2, r3
 8003d1c:	4a58      	ldr	r2, [pc, #352]	; (8003e80 <HAL_RCC_ClockConfig+0x274>)
 8003d1e:	4293      	cmp	r3, r2
 8003d20:	d901      	bls.n	8003d26 <HAL_RCC_ClockConfig+0x11a>
        {
          return HAL_TIMEOUT;
 8003d22:	2303      	movs	r3, #3
 8003d24:	e0a5      	b.n	8003e72 <HAL_RCC_ClockConfig+0x266>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8003d26:	4b57      	ldr	r3, [pc, #348]	; (8003e84 <HAL_RCC_ClockConfig+0x278>)
 8003d28:	68db      	ldr	r3, [r3, #12]
 8003d2a:	220c      	movs	r2, #12
 8003d2c:	4013      	ands	r3, r2
 8003d2e:	2b08      	cmp	r3, #8
 8003d30:	d1ef      	bne.n	8003d12 <HAL_RCC_ClockConfig+0x106>
 8003d32:	e03a      	b.n	8003daa <HAL_RCC_ClockConfig+0x19e>
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8003d34:	687b      	ldr	r3, [r7, #4]
 8003d36:	685b      	ldr	r3, [r3, #4]
 8003d38:	2b03      	cmp	r3, #3
 8003d3a:	d111      	bne.n	8003d60 <HAL_RCC_ClockConfig+0x154>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8003d3c:	e009      	b.n	8003d52 <HAL_RCC_ClockConfig+0x146>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8003d3e:	f7ff f8b9 	bl	8002eb4 <HAL_GetTick>
 8003d42:	0002      	movs	r2, r0
 8003d44:	68fb      	ldr	r3, [r7, #12]
 8003d46:	1ad3      	subs	r3, r2, r3
 8003d48:	4a4d      	ldr	r2, [pc, #308]	; (8003e80 <HAL_RCC_ClockConfig+0x274>)
 8003d4a:	4293      	cmp	r3, r2
 8003d4c:	d901      	bls.n	8003d52 <HAL_RCC_ClockConfig+0x146>
        {
          return HAL_TIMEOUT;
 8003d4e:	2303      	movs	r3, #3
 8003d50:	e08f      	b.n	8003e72 <HAL_RCC_ClockConfig+0x266>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8003d52:	4b4c      	ldr	r3, [pc, #304]	; (8003e84 <HAL_RCC_ClockConfig+0x278>)
 8003d54:	68db      	ldr	r3, [r3, #12]
 8003d56:	220c      	movs	r2, #12
 8003d58:	4013      	ands	r3, r2
 8003d5a:	2b0c      	cmp	r3, #12
 8003d5c:	d1ef      	bne.n	8003d3e <HAL_RCC_ClockConfig+0x132>
 8003d5e:	e024      	b.n	8003daa <HAL_RCC_ClockConfig+0x19e>
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
 8003d60:	687b      	ldr	r3, [r7, #4]
 8003d62:	685b      	ldr	r3, [r3, #4]
 8003d64:	2b01      	cmp	r3, #1
 8003d66:	d11b      	bne.n	8003da0 <HAL_RCC_ClockConfig+0x194>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 8003d68:	e009      	b.n	8003d7e <HAL_RCC_ClockConfig+0x172>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8003d6a:	f7ff f8a3 	bl	8002eb4 <HAL_GetTick>
 8003d6e:	0002      	movs	r2, r0
 8003d70:	68fb      	ldr	r3, [r7, #12]
 8003d72:	1ad3      	subs	r3, r2, r3
 8003d74:	4a42      	ldr	r2, [pc, #264]	; (8003e80 <HAL_RCC_ClockConfig+0x274>)
 8003d76:	4293      	cmp	r3, r2
 8003d78:	d901      	bls.n	8003d7e <HAL_RCC_ClockConfig+0x172>
        {
          return HAL_TIMEOUT;
 8003d7a:	2303      	movs	r3, #3
 8003d7c:	e079      	b.n	8003e72 <HAL_RCC_ClockConfig+0x266>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 8003d7e:	4b41      	ldr	r3, [pc, #260]	; (8003e84 <HAL_RCC_ClockConfig+0x278>)
 8003d80:	68db      	ldr	r3, [r3, #12]
 8003d82:	220c      	movs	r2, #12
 8003d84:	4013      	ands	r3, r2
 8003d86:	2b04      	cmp	r3, #4
 8003d88:	d1ef      	bne.n	8003d6a <HAL_RCC_ClockConfig+0x15e>
 8003d8a:	e00e      	b.n	8003daa <HAL_RCC_ClockConfig+0x19e>
    }
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8003d8c:	f7ff f892 	bl	8002eb4 <HAL_GetTick>
 8003d90:	0002      	movs	r2, r0
 8003d92:	68fb      	ldr	r3, [r7, #12]
 8003d94:	1ad3      	subs	r3, r2, r3
 8003d96:	4a3a      	ldr	r2, [pc, #232]	; (8003e80 <HAL_RCC_ClockConfig+0x274>)
 8003d98:	4293      	cmp	r3, r2
 8003d9a:	d901      	bls.n	8003da0 <HAL_RCC_ClockConfig+0x194>
        {
          return HAL_TIMEOUT;
 8003d9c:	2303      	movs	r3, #3
 8003d9e:	e068      	b.n	8003e72 <HAL_RCC_ClockConfig+0x266>
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
 8003da0:	4b38      	ldr	r3, [pc, #224]	; (8003e84 <HAL_RCC_ClockConfig+0x278>)
 8003da2:	68db      	ldr	r3, [r3, #12]
 8003da4:	220c      	movs	r2, #12
 8003da6:	4013      	ands	r3, r2
 8003da8:	d1f0      	bne.n	8003d8c <HAL_RCC_ClockConfig+0x180>
        }
      }
    }
  }
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8003daa:	4b34      	ldr	r3, [pc, #208]	; (8003e7c <HAL_RCC_ClockConfig+0x270>)
 8003dac:	681b      	ldr	r3, [r3, #0]
 8003dae:	2201      	movs	r2, #1
 8003db0:	4013      	ands	r3, r2
 8003db2:	683a      	ldr	r2, [r7, #0]
 8003db4:	429a      	cmp	r2, r3
 8003db6:	d21e      	bcs.n	8003df6 <HAL_RCC_ClockConfig+0x1ea>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8003db8:	4b30      	ldr	r3, [pc, #192]	; (8003e7c <HAL_RCC_ClockConfig+0x270>)
 8003dba:	681b      	ldr	r3, [r3, #0]
 8003dbc:	2201      	movs	r2, #1
 8003dbe:	4393      	bics	r3, r2
 8003dc0:	0019      	movs	r1, r3
 8003dc2:	4b2e      	ldr	r3, [pc, #184]	; (8003e7c <HAL_RCC_ClockConfig+0x270>)
 8003dc4:	683a      	ldr	r2, [r7, #0]
 8003dc6:	430a      	orrs	r2, r1
 8003dc8:	601a      	str	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by polling the FLASH_ACR register */
    tickstart = HAL_GetTick();
 8003dca:	f7ff f873 	bl	8002eb4 <HAL_GetTick>
 8003dce:	0003      	movs	r3, r0
 8003dd0:	60fb      	str	r3, [r7, #12]

    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 8003dd2:	e009      	b.n	8003de8 <HAL_RCC_ClockConfig+0x1dc>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8003dd4:	f7ff f86e 	bl	8002eb4 <HAL_GetTick>
 8003dd8:	0002      	movs	r2, r0
 8003dda:	68fb      	ldr	r3, [r7, #12]
 8003ddc:	1ad3      	subs	r3, r2, r3
 8003dde:	4a28      	ldr	r2, [pc, #160]	; (8003e80 <HAL_RCC_ClockConfig+0x274>)
 8003de0:	4293      	cmp	r3, r2
 8003de2:	d901      	bls.n	8003de8 <HAL_RCC_ClockConfig+0x1dc>
      {
        return HAL_TIMEOUT;
 8003de4:	2303      	movs	r3, #3
 8003de6:	e044      	b.n	8003e72 <HAL_RCC_ClockConfig+0x266>
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 8003de8:	4b24      	ldr	r3, [pc, #144]	; (8003e7c <HAL_RCC_ClockConfig+0x270>)
 8003dea:	681b      	ldr	r3, [r3, #0]
 8003dec:	2201      	movs	r2, #1
 8003dee:	4013      	ands	r3, r2
 8003df0:	683a      	ldr	r2, [r7, #0]
 8003df2:	429a      	cmp	r2, r3
 8003df4:	d1ee      	bne.n	8003dd4 <HAL_RCC_ClockConfig+0x1c8>
      }
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8003df6:	687b      	ldr	r3, [r7, #4]
 8003df8:	681b      	ldr	r3, [r3, #0]
 8003dfa:	2204      	movs	r2, #4
 8003dfc:	4013      	ands	r3, r2
 8003dfe:	d009      	beq.n	8003e14 <HAL_RCC_ClockConfig+0x208>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8003e00:	4b20      	ldr	r3, [pc, #128]	; (8003e84 <HAL_RCC_ClockConfig+0x278>)
 8003e02:	68db      	ldr	r3, [r3, #12]
 8003e04:	4a20      	ldr	r2, [pc, #128]	; (8003e88 <HAL_RCC_ClockConfig+0x27c>)
 8003e06:	4013      	ands	r3, r2
 8003e08:	0019      	movs	r1, r3
 8003e0a:	687b      	ldr	r3, [r7, #4]
 8003e0c:	68da      	ldr	r2, [r3, #12]
 8003e0e:	4b1d      	ldr	r3, [pc, #116]	; (8003e84 <HAL_RCC_ClockConfig+0x278>)
 8003e10:	430a      	orrs	r2, r1
 8003e12:	60da      	str	r2, [r3, #12]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8003e14:	687b      	ldr	r3, [r7, #4]
 8003e16:	681b      	ldr	r3, [r3, #0]
 8003e18:	2208      	movs	r2, #8
 8003e1a:	4013      	ands	r3, r2
 8003e1c:	d00a      	beq.n	8003e34 <HAL_RCC_ClockConfig+0x228>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8003e1e:	4b19      	ldr	r3, [pc, #100]	; (8003e84 <HAL_RCC_ClockConfig+0x278>)
 8003e20:	68db      	ldr	r3, [r3, #12]
 8003e22:	4a1a      	ldr	r2, [pc, #104]	; (8003e8c <HAL_RCC_ClockConfig+0x280>)
 8003e24:	4013      	ands	r3, r2
 8003e26:	0019      	movs	r1, r3
 8003e28:	687b      	ldr	r3, [r7, #4]
 8003e2a:	691b      	ldr	r3, [r3, #16]
 8003e2c:	00da      	lsls	r2, r3, #3
 8003e2e:	4b15      	ldr	r3, [pc, #84]	; (8003e84 <HAL_RCC_ClockConfig+0x278>)
 8003e30:	430a      	orrs	r2, r1
 8003e32:	60da      	str	r2, [r3, #12]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 8003e34:	f000 f832 	bl	8003e9c <HAL_RCC_GetSysClockFreq>
 8003e38:	0001      	movs	r1, r0
 8003e3a:	4b12      	ldr	r3, [pc, #72]	; (8003e84 <HAL_RCC_ClockConfig+0x278>)
 8003e3c:	68db      	ldr	r3, [r3, #12]
 8003e3e:	091b      	lsrs	r3, r3, #4
 8003e40:	220f      	movs	r2, #15
 8003e42:	4013      	ands	r3, r2
 8003e44:	4a12      	ldr	r2, [pc, #72]	; (8003e90 <HAL_RCC_ClockConfig+0x284>)
 8003e46:	5cd3      	ldrb	r3, [r2, r3]
 8003e48:	000a      	movs	r2, r1
 8003e4a:	40da      	lsrs	r2, r3
 8003e4c:	4b11      	ldr	r3, [pc, #68]	; (8003e94 <HAL_RCC_ClockConfig+0x288>)
 8003e4e:	601a      	str	r2, [r3, #0]

  /* Configure the source of time base considering new system clocks settings*/
  status = HAL_InitTick(uwTickPrio);
 8003e50:	4b11      	ldr	r3, [pc, #68]	; (8003e98 <HAL_RCC_ClockConfig+0x28c>)
 8003e52:	681b      	ldr	r3, [r3, #0]
 8003e54:	250b      	movs	r5, #11
 8003e56:	197c      	adds	r4, r7, r5
 8003e58:	0018      	movs	r0, r3
 8003e5a:	f7fe ffe5 	bl	8002e28 <HAL_InitTick>
 8003e5e:	0003      	movs	r3, r0
 8003e60:	7023      	strb	r3, [r4, #0]
  if(status != HAL_OK)
 8003e62:	197b      	adds	r3, r7, r5
 8003e64:	781b      	ldrb	r3, [r3, #0]
 8003e66:	2b00      	cmp	r3, #0
 8003e68:	d002      	beq.n	8003e70 <HAL_RCC_ClockConfig+0x264>
  {
    return status;
 8003e6a:	197b      	adds	r3, r7, r5
 8003e6c:	781b      	ldrb	r3, [r3, #0]
 8003e6e:	e000      	b.n	8003e72 <HAL_RCC_ClockConfig+0x266>
  }

  return HAL_OK;
 8003e70:	2300      	movs	r3, #0
}
 8003e72:	0018      	movs	r0, r3
 8003e74:	46bd      	mov	sp, r7
 8003e76:	b004      	add	sp, #16
 8003e78:	bdb0      	pop	{r4, r5, r7, pc}
 8003e7a:	46c0      	nop			; (mov r8, r8)
 8003e7c:	40022000 	.word	0x40022000
 8003e80:	00001388 	.word	0x00001388
 8003e84:	40021000 	.word	0x40021000
 8003e88:	fffff8ff 	.word	0xfffff8ff
 8003e8c:	ffffc7ff 	.word	0xffffc7ff
 8003e90:	08022110 	.word	0x08022110
 8003e94:	20000010 	.word	0x20000010
 8003e98:	20000014 	.word	0x20000014

08003e9c <HAL_RCC_GetSysClockFreq>:
  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8003e9c:	b5b0      	push	{r4, r5, r7, lr}
 8003e9e:	b08e      	sub	sp, #56	; 0x38
 8003ea0:	af00      	add	r7, sp, #0
  uint32_t tmpreg, pllm, plld, pllvco, msiclkrange;    /* no init needed */
  uint32_t sysclockfreq;

  tmpreg = RCC->CFGR;
 8003ea2:	4b4c      	ldr	r3, [pc, #304]	; (8003fd4 <HAL_RCC_GetSysClockFreq+0x138>)
 8003ea4:	68db      	ldr	r3, [r3, #12]
 8003ea6:	62fb      	str	r3, [r7, #44]	; 0x2c

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
 8003ea8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8003eaa:	230c      	movs	r3, #12
 8003eac:	4013      	ands	r3, r2
 8003eae:	2b0c      	cmp	r3, #12
 8003eb0:	d014      	beq.n	8003edc <HAL_RCC_GetSysClockFreq+0x40>
 8003eb2:	d900      	bls.n	8003eb6 <HAL_RCC_GetSysClockFreq+0x1a>
 8003eb4:	e07b      	b.n	8003fae <HAL_RCC_GetSysClockFreq+0x112>
 8003eb6:	2b04      	cmp	r3, #4
 8003eb8:	d002      	beq.n	8003ec0 <HAL_RCC_GetSysClockFreq+0x24>
 8003eba:	2b08      	cmp	r3, #8
 8003ebc:	d00b      	beq.n	8003ed6 <HAL_RCC_GetSysClockFreq+0x3a>
 8003ebe:	e076      	b.n	8003fae <HAL_RCC_GetSysClockFreq+0x112>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    {
      if ((RCC->CR & RCC_CR_HSIDIVF) != 0U)
 8003ec0:	4b44      	ldr	r3, [pc, #272]	; (8003fd4 <HAL_RCC_GetSysClockFreq+0x138>)
 8003ec2:	681b      	ldr	r3, [r3, #0]
 8003ec4:	2210      	movs	r2, #16
 8003ec6:	4013      	ands	r3, r2
 8003ec8:	d002      	beq.n	8003ed0 <HAL_RCC_GetSysClockFreq+0x34>
      {
        sysclockfreq =  (HSI_VALUE >> 2);
 8003eca:	4b43      	ldr	r3, [pc, #268]	; (8003fd8 <HAL_RCC_GetSysClockFreq+0x13c>)
 8003ecc:	633b      	str	r3, [r7, #48]	; 0x30
      }
      else
      {
        sysclockfreq =  HSI_VALUE;
      }
      break;
 8003ece:	e07c      	b.n	8003fca <HAL_RCC_GetSysClockFreq+0x12e>
        sysclockfreq =  HSI_VALUE;
 8003ed0:	4b42      	ldr	r3, [pc, #264]	; (8003fdc <HAL_RCC_GetSysClockFreq+0x140>)
 8003ed2:	633b      	str	r3, [r7, #48]	; 0x30
      break;
 8003ed4:	e079      	b.n	8003fca <HAL_RCC_GetSysClockFreq+0x12e>
    }
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
    {
      sysclockfreq = HSE_VALUE;
 8003ed6:	4b42      	ldr	r3, [pc, #264]	; (8003fe0 <HAL_RCC_GetSysClockFreq+0x144>)
 8003ed8:	633b      	str	r3, [r7, #48]	; 0x30
      break;
 8003eda:	e076      	b.n	8003fca <HAL_RCC_GetSysClockFreq+0x12e>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
    {
      pllm = PLLMulTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_Pos];
 8003edc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003ede:	0c9a      	lsrs	r2, r3, #18
 8003ee0:	230f      	movs	r3, #15
 8003ee2:	401a      	ands	r2, r3
 8003ee4:	4b3f      	ldr	r3, [pc, #252]	; (8003fe4 <HAL_RCC_GetSysClockFreq+0x148>)
 8003ee6:	5c9b      	ldrb	r3, [r3, r2]
 8003ee8:	62bb      	str	r3, [r7, #40]	; 0x28
      plld = ((uint32_t)(tmpreg & RCC_CFGR_PLLDIV) >> RCC_CFGR_PLLDIV_Pos) + 1U;
 8003eea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003eec:	0d9a      	lsrs	r2, r3, #22
 8003eee:	2303      	movs	r3, #3
 8003ef0:	4013      	ands	r3, r2
 8003ef2:	3301      	adds	r3, #1
 8003ef4:	627b      	str	r3, [r7, #36]	; 0x24
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8003ef6:	4b37      	ldr	r3, [pc, #220]	; (8003fd4 <HAL_RCC_GetSysClockFreq+0x138>)
 8003ef8:	68da      	ldr	r2, [r3, #12]
 8003efa:	2380      	movs	r3, #128	; 0x80
 8003efc:	025b      	lsls	r3, r3, #9
 8003efe:	4013      	ands	r3, r2
 8003f00:	d01a      	beq.n	8003f38 <HAL_RCC_GetSysClockFreq+0x9c>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t)(((uint64_t)HSE_VALUE * (uint64_t)pllm) / (uint64_t)plld);
 8003f02:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003f04:	61bb      	str	r3, [r7, #24]
 8003f06:	2300      	movs	r3, #0
 8003f08:	61fb      	str	r3, [r7, #28]
 8003f0a:	4a35      	ldr	r2, [pc, #212]	; (8003fe0 <HAL_RCC_GetSysClockFreq+0x144>)
 8003f0c:	2300      	movs	r3, #0
 8003f0e:	69b8      	ldr	r0, [r7, #24]
 8003f10:	69f9      	ldr	r1, [r7, #28]
 8003f12:	f7fc f9b7 	bl	8000284 <__aeabi_lmul>
 8003f16:	0002      	movs	r2, r0
 8003f18:	000b      	movs	r3, r1
 8003f1a:	0010      	movs	r0, r2
 8003f1c:	0019      	movs	r1, r3
 8003f1e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003f20:	613b      	str	r3, [r7, #16]
 8003f22:	2300      	movs	r3, #0
 8003f24:	617b      	str	r3, [r7, #20]
 8003f26:	693a      	ldr	r2, [r7, #16]
 8003f28:	697b      	ldr	r3, [r7, #20]
 8003f2a:	f7fc f98b 	bl	8000244 <__aeabi_uldivmod>
 8003f2e:	0002      	movs	r2, r0
 8003f30:	000b      	movs	r3, r1
 8003f32:	0013      	movs	r3, r2
 8003f34:	637b      	str	r3, [r7, #52]	; 0x34
 8003f36:	e037      	b.n	8003fa8 <HAL_RCC_GetSysClockFreq+0x10c>
      }
      else
      {
        if ((RCC->CR & RCC_CR_HSIDIVF) != 0U)
 8003f38:	4b26      	ldr	r3, [pc, #152]	; (8003fd4 <HAL_RCC_GetSysClockFreq+0x138>)
 8003f3a:	681b      	ldr	r3, [r3, #0]
 8003f3c:	2210      	movs	r2, #16
 8003f3e:	4013      	ands	r3, r2
 8003f40:	d01a      	beq.n	8003f78 <HAL_RCC_GetSysClockFreq+0xdc>
        {
          pllvco = (uint32_t)((((uint64_t)(HSI_VALUE >> 2)) * (uint64_t)pllm) / (uint64_t)plld);
 8003f42:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003f44:	60bb      	str	r3, [r7, #8]
 8003f46:	2300      	movs	r3, #0
 8003f48:	60fb      	str	r3, [r7, #12]
 8003f4a:	4a23      	ldr	r2, [pc, #140]	; (8003fd8 <HAL_RCC_GetSysClockFreq+0x13c>)
 8003f4c:	2300      	movs	r3, #0
 8003f4e:	68b8      	ldr	r0, [r7, #8]
 8003f50:	68f9      	ldr	r1, [r7, #12]
 8003f52:	f7fc f997 	bl	8000284 <__aeabi_lmul>
 8003f56:	0002      	movs	r2, r0
 8003f58:	000b      	movs	r3, r1
 8003f5a:	0010      	movs	r0, r2
 8003f5c:	0019      	movs	r1, r3
 8003f5e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003f60:	603b      	str	r3, [r7, #0]
 8003f62:	2300      	movs	r3, #0
 8003f64:	607b      	str	r3, [r7, #4]
 8003f66:	683a      	ldr	r2, [r7, #0]
 8003f68:	687b      	ldr	r3, [r7, #4]
 8003f6a:	f7fc f96b 	bl	8000244 <__aeabi_uldivmod>
 8003f6e:	0002      	movs	r2, r0
 8003f70:	000b      	movs	r3, r1
 8003f72:	0013      	movs	r3, r2
 8003f74:	637b      	str	r3, [r7, #52]	; 0x34
 8003f76:	e017      	b.n	8003fa8 <HAL_RCC_GetSysClockFreq+0x10c>
        }
        else
        {
         pllvco = (uint32_t)(((uint64_t)HSI_VALUE * (uint64_t)pllm) / (uint64_t)plld);
 8003f78:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003f7a:	0018      	movs	r0, r3
 8003f7c:	2300      	movs	r3, #0
 8003f7e:	0019      	movs	r1, r3
 8003f80:	4a16      	ldr	r2, [pc, #88]	; (8003fdc <HAL_RCC_GetSysClockFreq+0x140>)
 8003f82:	2300      	movs	r3, #0
 8003f84:	f7fc f97e 	bl	8000284 <__aeabi_lmul>
 8003f88:	0002      	movs	r2, r0
 8003f8a:	000b      	movs	r3, r1
 8003f8c:	0010      	movs	r0, r2
 8003f8e:	0019      	movs	r1, r3
 8003f90:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003f92:	001c      	movs	r4, r3
 8003f94:	2300      	movs	r3, #0
 8003f96:	001d      	movs	r5, r3
 8003f98:	0022      	movs	r2, r4
 8003f9a:	002b      	movs	r3, r5
 8003f9c:	f7fc f952 	bl	8000244 <__aeabi_uldivmod>
 8003fa0:	0002      	movs	r2, r0
 8003fa2:	000b      	movs	r3, r1
 8003fa4:	0013      	movs	r3, r2
 8003fa6:	637b      	str	r3, [r7, #52]	; 0x34
        }
      }
      sysclockfreq = pllvco;
 8003fa8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003faa:	633b      	str	r3, [r7, #48]	; 0x30
      break;
 8003fac:	e00d      	b.n	8003fca <HAL_RCC_GetSysClockFreq+0x12e>
    }
    case RCC_SYSCLKSOURCE_STATUS_MSI:  /* MSI used as system clock source */
    default: /* MSI used as system clock */
    {
      msiclkrange = (RCC->ICSCR & RCC_ICSCR_MSIRANGE ) >> RCC_ICSCR_MSIRANGE_Pos;
 8003fae:	4b09      	ldr	r3, [pc, #36]	; (8003fd4 <HAL_RCC_GetSysClockFreq+0x138>)
 8003fb0:	685b      	ldr	r3, [r3, #4]
 8003fb2:	0b5b      	lsrs	r3, r3, #13
 8003fb4:	2207      	movs	r2, #7
 8003fb6:	4013      	ands	r3, r2
 8003fb8:	623b      	str	r3, [r7, #32]
      sysclockfreq = (32768U * (1UL << (msiclkrange + 1U)));
 8003fba:	6a3b      	ldr	r3, [r7, #32]
 8003fbc:	3301      	adds	r3, #1
 8003fbe:	2280      	movs	r2, #128	; 0x80
 8003fc0:	0212      	lsls	r2, r2, #8
 8003fc2:	409a      	lsls	r2, r3
 8003fc4:	0013      	movs	r3, r2
 8003fc6:	633b      	str	r3, [r7, #48]	; 0x30
      break;
 8003fc8:	46c0      	nop			; (mov r8, r8)
    }
  }
  return sysclockfreq;
 8003fca:	6b3b      	ldr	r3, [r7, #48]	; 0x30
}
 8003fcc:	0018      	movs	r0, r3
 8003fce:	46bd      	mov	sp, r7
 8003fd0:	b00e      	add	sp, #56	; 0x38
 8003fd2:	bdb0      	pop	{r4, r5, r7, pc}
 8003fd4:	40021000 	.word	0x40021000
 8003fd8:	003d0900 	.word	0x003d0900
 8003fdc:	00f42400 	.word	0x00f42400
 8003fe0:	007a1200 	.word	0x007a1200
 8003fe4:	08022128 	.word	0x08022128

08003fe8 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8003fe8:	b580      	push	{r7, lr}
 8003fea:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 8003fec:	4b02      	ldr	r3, [pc, #8]	; (8003ff8 <HAL_RCC_GetHCLKFreq+0x10>)
 8003fee:	681b      	ldr	r3, [r3, #0]
}
 8003ff0:	0018      	movs	r0, r3
 8003ff2:	46bd      	mov	sp, r7
 8003ff4:	bd80      	pop	{r7, pc}
 8003ff6:	46c0      	nop			; (mov r8, r8)
 8003ff8:	20000010 	.word	0x20000010

08003ffc <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 8003ffc:	b580      	push	{r7, lr}
 8003ffe:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 8004000:	f7ff fff2 	bl	8003fe8 <HAL_RCC_GetHCLKFreq>
 8004004:	0001      	movs	r1, r0
 8004006:	4b06      	ldr	r3, [pc, #24]	; (8004020 <HAL_RCC_GetPCLK1Freq+0x24>)
 8004008:	68db      	ldr	r3, [r3, #12]
 800400a:	0a1b      	lsrs	r3, r3, #8
 800400c:	2207      	movs	r2, #7
 800400e:	4013      	ands	r3, r2
 8004010:	4a04      	ldr	r2, [pc, #16]	; (8004024 <HAL_RCC_GetPCLK1Freq+0x28>)
 8004012:	5cd3      	ldrb	r3, [r2, r3]
 8004014:	40d9      	lsrs	r1, r3
 8004016:	000b      	movs	r3, r1
}
 8004018:	0018      	movs	r0, r3
 800401a:	46bd      	mov	sp, r7
 800401c:	bd80      	pop	{r7, pc}
 800401e:	46c0      	nop			; (mov r8, r8)
 8004020:	40021000 	.word	0x40021000
 8004024:	08022120 	.word	0x08022120

08004028 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 8004028:	b580      	push	{r7, lr}
 800402a:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 800402c:	f7ff ffdc 	bl	8003fe8 <HAL_RCC_GetHCLKFreq>
 8004030:	0001      	movs	r1, r0
 8004032:	4b06      	ldr	r3, [pc, #24]	; (800404c <HAL_RCC_GetPCLK2Freq+0x24>)
 8004034:	68db      	ldr	r3, [r3, #12]
 8004036:	0adb      	lsrs	r3, r3, #11
 8004038:	2207      	movs	r2, #7
 800403a:	4013      	ands	r3, r2
 800403c:	4a04      	ldr	r2, [pc, #16]	; (8004050 <HAL_RCC_GetPCLK2Freq+0x28>)
 800403e:	5cd3      	ldrb	r3, [r2, r3]
 8004040:	40d9      	lsrs	r1, r3
 8004042:	000b      	movs	r3, r1
}
 8004044:	0018      	movs	r0, r3
 8004046:	46bd      	mov	sp, r7
 8004048:	bd80      	pop	{r7, pc}
 800404a:	46c0      	nop			; (mov r8, r8)
 800404c:	40021000 	.word	0x40021000
 8004050:	08022120 	.word	0x08022120

08004054 <HAL_RCCEx_PeriphCLKConfig>:
  * @retval HAL status
  * @note   If HAL_ERROR returned, first switch-OFF HSE clock oscillator with @ref HAL_RCC_OscConfig()
  *         to possibly update HSE divider.
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8004054:	b580      	push	{r7, lr}
 8004056:	b086      	sub	sp, #24
 8004058:	af00      	add	r7, sp, #0
 800405a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  uint32_t temp_reg;
  FlagStatus       pwrclkchanged = RESET;
 800405c:	2017      	movs	r0, #23
 800405e:	183b      	adds	r3, r7, r0
 8004060:	2200      	movs	r2, #0
 8004062:	701a      	strb	r2, [r3, #0]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*------------------------------- RTC/LCD Configuration ------------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8004064:	687b      	ldr	r3, [r7, #4]
 8004066:	681b      	ldr	r3, [r3, #0]
 8004068:	2220      	movs	r2, #32
 800406a:	4013      	ands	r3, r2
 800406c:	d100      	bne.n	8004070 <HAL_RCCEx_PeriphCLKConfig+0x1c>
 800406e:	e0c2      	b.n	80041f6 <HAL_RCCEx_PeriphCLKConfig+0x1a2>
#endif /* LCD */

    /* As soon as function is called to change RTC clock source, activation of the
       power domain is done. */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8004070:	4b91      	ldr	r3, [pc, #580]	; (80042b8 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8004072:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8004074:	2380      	movs	r3, #128	; 0x80
 8004076:	055b      	lsls	r3, r3, #21
 8004078:	4013      	ands	r3, r2
 800407a:	d109      	bne.n	8004090 <HAL_RCCEx_PeriphCLKConfig+0x3c>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 800407c:	4b8e      	ldr	r3, [pc, #568]	; (80042b8 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800407e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8004080:	4b8d      	ldr	r3, [pc, #564]	; (80042b8 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8004082:	2180      	movs	r1, #128	; 0x80
 8004084:	0549      	lsls	r1, r1, #21
 8004086:	430a      	orrs	r2, r1
 8004088:	639a      	str	r2, [r3, #56]	; 0x38
      pwrclkchanged = SET;
 800408a:	183b      	adds	r3, r7, r0
 800408c:	2201      	movs	r2, #1
 800408e:	701a      	strb	r2, [r3, #0]
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8004090:	4b8a      	ldr	r3, [pc, #552]	; (80042bc <HAL_RCCEx_PeriphCLKConfig+0x268>)
 8004092:	681a      	ldr	r2, [r3, #0]
 8004094:	2380      	movs	r3, #128	; 0x80
 8004096:	005b      	lsls	r3, r3, #1
 8004098:	4013      	ands	r3, r2
 800409a:	d11a      	bne.n	80040d2 <HAL_RCCEx_PeriphCLKConfig+0x7e>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 800409c:	4b87      	ldr	r3, [pc, #540]	; (80042bc <HAL_RCCEx_PeriphCLKConfig+0x268>)
 800409e:	681a      	ldr	r2, [r3, #0]
 80040a0:	4b86      	ldr	r3, [pc, #536]	; (80042bc <HAL_RCCEx_PeriphCLKConfig+0x268>)
 80040a2:	2180      	movs	r1, #128	; 0x80
 80040a4:	0049      	lsls	r1, r1, #1
 80040a6:	430a      	orrs	r2, r1
 80040a8:	601a      	str	r2, [r3, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 80040aa:	f7fe ff03 	bl	8002eb4 <HAL_GetTick>
 80040ae:	0003      	movs	r3, r0
 80040b0:	613b      	str	r3, [r7, #16]

      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80040b2:	e008      	b.n	80040c6 <HAL_RCCEx_PeriphCLKConfig+0x72>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80040b4:	f7fe fefe 	bl	8002eb4 <HAL_GetTick>
 80040b8:	0002      	movs	r2, r0
 80040ba:	693b      	ldr	r3, [r7, #16]
 80040bc:	1ad3      	subs	r3, r2, r3
 80040be:	2b64      	cmp	r3, #100	; 0x64
 80040c0:	d901      	bls.n	80040c6 <HAL_RCCEx_PeriphCLKConfig+0x72>
        {
          return HAL_TIMEOUT;
 80040c2:	2303      	movs	r3, #3
 80040c4:	e0f3      	b.n	80042ae <HAL_RCCEx_PeriphCLKConfig+0x25a>
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80040c6:	4b7d      	ldr	r3, [pc, #500]	; (80042bc <HAL_RCCEx_PeriphCLKConfig+0x268>)
 80040c8:	681a      	ldr	r2, [r3, #0]
 80040ca:	2380      	movs	r3, #128	; 0x80
 80040cc:	005b      	lsls	r3, r3, #1
 80040ce:	4013      	ands	r3, r2
 80040d0:	d0f0      	beq.n	80040b4 <HAL_RCCEx_PeriphCLKConfig+0x60>
        }
      }
    }

    /* Check if user wants to change HSE RTC prescaler whereas HSE is enabled */
    temp_reg = (RCC->CR & RCC_CR_RTCPRE);
 80040d2:	4b79      	ldr	r3, [pc, #484]	; (80042b8 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 80040d4:	681a      	ldr	r2, [r3, #0]
 80040d6:	23c0      	movs	r3, #192	; 0xc0
 80040d8:	039b      	lsls	r3, r3, #14
 80040da:	4013      	ands	r3, r2
 80040dc:	60fb      	str	r3, [r7, #12]
    if ((temp_reg != (PeriphClkInit->RTCClockSelection & RCC_CR_RTCPRE))
 80040de:	687b      	ldr	r3, [r7, #4]
 80040e0:	685a      	ldr	r2, [r3, #4]
 80040e2:	23c0      	movs	r3, #192	; 0xc0
 80040e4:	039b      	lsls	r3, r3, #14
 80040e6:	4013      	ands	r3, r2
 80040e8:	68fa      	ldr	r2, [r7, #12]
 80040ea:	429a      	cmp	r2, r3
 80040ec:	d013      	beq.n	8004116 <HAL_RCCEx_PeriphCLKConfig+0xc2>
#if defined (LCD)
     || (temp_reg != (PeriphClkInit->LCDClockSelection & RCC_CR_RTCPRE))
#endif /* LCD */
       )
    { /* Check HSE State */
      if ((PeriphClkInit->RTCClockSelection & RCC_CSR_RTCSEL) == RCC_CSR_RTCSEL_HSE)
 80040ee:	687b      	ldr	r3, [r7, #4]
 80040f0:	685a      	ldr	r2, [r3, #4]
 80040f2:	23c0      	movs	r3, #192	; 0xc0
 80040f4:	029b      	lsls	r3, r3, #10
 80040f6:	401a      	ands	r2, r3
 80040f8:	23c0      	movs	r3, #192	; 0xc0
 80040fa:	029b      	lsls	r3, r3, #10
 80040fc:	429a      	cmp	r2, r3
 80040fe:	d10a      	bne.n	8004116 <HAL_RCCEx_PeriphCLKConfig+0xc2>
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
 8004100:	4b6d      	ldr	r3, [pc, #436]	; (80042b8 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8004102:	681a      	ldr	r2, [r3, #0]
 8004104:	2380      	movs	r3, #128	; 0x80
 8004106:	029b      	lsls	r3, r3, #10
 8004108:	401a      	ands	r2, r3
 800410a:	2380      	movs	r3, #128	; 0x80
 800410c:	029b      	lsls	r3, r3, #10
 800410e:	429a      	cmp	r2, r3
 8004110:	d101      	bne.n	8004116 <HAL_RCCEx_PeriphCLKConfig+0xc2>
        {
          /* To update HSE divider, first switch-OFF HSE clock oscillator*/
          return HAL_ERROR;
 8004112:	2301      	movs	r3, #1
 8004114:	e0cb      	b.n	80042ae <HAL_RCCEx_PeriphCLKConfig+0x25a>
        }
      }
    }

    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */
    temp_reg = (RCC->CSR & RCC_CSR_RTCSEL);
 8004116:	4b68      	ldr	r3, [pc, #416]	; (80042b8 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8004118:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800411a:	23c0      	movs	r3, #192	; 0xc0
 800411c:	029b      	lsls	r3, r3, #10
 800411e:	4013      	ands	r3, r2
 8004120:	60fb      	str	r3, [r7, #12]

    if((temp_reg != 0x00000000U) && (((temp_reg != (PeriphClkInit->RTCClockSelection & RCC_CSR_RTCSEL)) \
 8004122:	68fb      	ldr	r3, [r7, #12]
 8004124:	2b00      	cmp	r3, #0
 8004126:	d03b      	beq.n	80041a0 <HAL_RCCEx_PeriphCLKConfig+0x14c>
 8004128:	687b      	ldr	r3, [r7, #4]
 800412a:	685a      	ldr	r2, [r3, #4]
 800412c:	23c0      	movs	r3, #192	; 0xc0
 800412e:	029b      	lsls	r3, r3, #10
 8004130:	4013      	ands	r3, r2
 8004132:	68fa      	ldr	r2, [r7, #12]
 8004134:	429a      	cmp	r2, r3
 8004136:	d033      	beq.n	80041a0 <HAL_RCCEx_PeriphCLKConfig+0x14c>
      && (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
 8004138:	687b      	ldr	r3, [r7, #4]
 800413a:	681b      	ldr	r3, [r3, #0]
 800413c:	2220      	movs	r2, #32
 800413e:	4013      	ands	r3, r2
 8004140:	d02e      	beq.n	80041a0 <HAL_RCCEx_PeriphCLKConfig+0x14c>
       && (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LCD) == RCC_PERIPHCLK_LCD))
#endif /* LCD */
     ))
    {
      /* Store the content of CSR register before the reset of Backup Domain */
      temp_reg = (RCC->CSR & ~(RCC_CSR_RTCSEL));
 8004142:	4b5d      	ldr	r3, [pc, #372]	; (80042b8 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8004144:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8004146:	4a5e      	ldr	r2, [pc, #376]	; (80042c0 <HAL_RCCEx_PeriphCLKConfig+0x26c>)
 8004148:	4013      	ands	r3, r2
 800414a:	60fb      	str	r3, [r7, #12]

      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 800414c:	4b5a      	ldr	r3, [pc, #360]	; (80042b8 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800414e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8004150:	4b59      	ldr	r3, [pc, #356]	; (80042b8 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8004152:	2180      	movs	r1, #128	; 0x80
 8004154:	0309      	lsls	r1, r1, #12
 8004156:	430a      	orrs	r2, r1
 8004158:	651a      	str	r2, [r3, #80]	; 0x50
      __HAL_RCC_BACKUPRESET_RELEASE();
 800415a:	4b57      	ldr	r3, [pc, #348]	; (80042b8 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800415c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800415e:	4b56      	ldr	r3, [pc, #344]	; (80042b8 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8004160:	4958      	ldr	r1, [pc, #352]	; (80042c4 <HAL_RCCEx_PeriphCLKConfig+0x270>)
 8004162:	400a      	ands	r2, r1
 8004164:	651a      	str	r2, [r3, #80]	; 0x50

      /* Restore the Content of CSR register */
      RCC->CSR = temp_reg;
 8004166:	4b54      	ldr	r3, [pc, #336]	; (80042b8 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8004168:	68fa      	ldr	r2, [r7, #12]
 800416a:	651a      	str	r2, [r3, #80]	; 0x50

       /* Wait for LSERDY if LSE was enabled */
      if (HAL_IS_BIT_SET(temp_reg, RCC_CSR_LSEON))
 800416c:	68fa      	ldr	r2, [r7, #12]
 800416e:	2380      	movs	r3, #128	; 0x80
 8004170:	005b      	lsls	r3, r3, #1
 8004172:	4013      	ands	r3, r2
 8004174:	d014      	beq.n	80041a0 <HAL_RCCEx_PeriphCLKConfig+0x14c>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8004176:	f7fe fe9d 	bl	8002eb4 <HAL_GetTick>
 800417a:	0003      	movs	r3, r0
 800417c:	613b      	str	r3, [r7, #16]

        /* Wait till LSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800417e:	e009      	b.n	8004194 <HAL_RCCEx_PeriphCLKConfig+0x140>
        {
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8004180:	f7fe fe98 	bl	8002eb4 <HAL_GetTick>
 8004184:	0002      	movs	r2, r0
 8004186:	693b      	ldr	r3, [r7, #16]
 8004188:	1ad3      	subs	r3, r2, r3
 800418a:	4a4f      	ldr	r2, [pc, #316]	; (80042c8 <HAL_RCCEx_PeriphCLKConfig+0x274>)
 800418c:	4293      	cmp	r3, r2
 800418e:	d901      	bls.n	8004194 <HAL_RCCEx_PeriphCLKConfig+0x140>
          {
            return HAL_TIMEOUT;
 8004190:	2303      	movs	r3, #3
 8004192:	e08c      	b.n	80042ae <HAL_RCCEx_PeriphCLKConfig+0x25a>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8004194:	4b48      	ldr	r3, [pc, #288]	; (80042b8 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8004196:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8004198:	2380      	movs	r3, #128	; 0x80
 800419a:	009b      	lsls	r3, r3, #2
 800419c:	4013      	ands	r3, r2
 800419e:	d0ef      	beq.n	8004180 <HAL_RCCEx_PeriphCLKConfig+0x12c>
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 80041a0:	687b      	ldr	r3, [r7, #4]
 80041a2:	685a      	ldr	r2, [r3, #4]
 80041a4:	23c0      	movs	r3, #192	; 0xc0
 80041a6:	029b      	lsls	r3, r3, #10
 80041a8:	401a      	ands	r2, r3
 80041aa:	23c0      	movs	r3, #192	; 0xc0
 80041ac:	029b      	lsls	r3, r3, #10
 80041ae:	429a      	cmp	r2, r3
 80041b0:	d10c      	bne.n	80041cc <HAL_RCCEx_PeriphCLKConfig+0x178>
 80041b2:	4b41      	ldr	r3, [pc, #260]	; (80042b8 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 80041b4:	681b      	ldr	r3, [r3, #0]
 80041b6:	4a45      	ldr	r2, [pc, #276]	; (80042cc <HAL_RCCEx_PeriphCLKConfig+0x278>)
 80041b8:	4013      	ands	r3, r2
 80041ba:	0019      	movs	r1, r3
 80041bc:	687b      	ldr	r3, [r7, #4]
 80041be:	685a      	ldr	r2, [r3, #4]
 80041c0:	23c0      	movs	r3, #192	; 0xc0
 80041c2:	039b      	lsls	r3, r3, #14
 80041c4:	401a      	ands	r2, r3
 80041c6:	4b3c      	ldr	r3, [pc, #240]	; (80042b8 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 80041c8:	430a      	orrs	r2, r1
 80041ca:	601a      	str	r2, [r3, #0]
 80041cc:	4b3a      	ldr	r3, [pc, #232]	; (80042b8 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 80041ce:	6d19      	ldr	r1, [r3, #80]	; 0x50
 80041d0:	687b      	ldr	r3, [r7, #4]
 80041d2:	685a      	ldr	r2, [r3, #4]
 80041d4:	23c0      	movs	r3, #192	; 0xc0
 80041d6:	029b      	lsls	r3, r3, #10
 80041d8:	401a      	ands	r2, r3
 80041da:	4b37      	ldr	r3, [pc, #220]	; (80042b8 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 80041dc:	430a      	orrs	r2, r1
 80041de:	651a      	str	r2, [r3, #80]	; 0x50

    /* Require to disable power clock if necessary */
    if(pwrclkchanged == SET)
 80041e0:	2317      	movs	r3, #23
 80041e2:	18fb      	adds	r3, r7, r3
 80041e4:	781b      	ldrb	r3, [r3, #0]
 80041e6:	2b01      	cmp	r3, #1
 80041e8:	d105      	bne.n	80041f6 <HAL_RCCEx_PeriphCLKConfig+0x1a2>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 80041ea:	4b33      	ldr	r3, [pc, #204]	; (80042b8 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 80041ec:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80041ee:	4b32      	ldr	r3, [pc, #200]	; (80042b8 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 80041f0:	4937      	ldr	r1, [pc, #220]	; (80042d0 <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 80041f2:	400a      	ands	r2, r1
 80041f4:	639a      	str	r2, [r3, #56]	; 0x38
    }
  }

#if defined (RCC_CCIPR_USART1SEL)
  /*------------------------------- USART1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 80041f6:	687b      	ldr	r3, [r7, #4]
 80041f8:	681b      	ldr	r3, [r3, #0]
 80041fa:	2201      	movs	r2, #1
 80041fc:	4013      	ands	r3, r2
 80041fe:	d009      	beq.n	8004214 <HAL_RCCEx_PeriphCLKConfig+0x1c0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8004200:	4b2d      	ldr	r3, [pc, #180]	; (80042b8 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8004202:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8004204:	2203      	movs	r2, #3
 8004206:	4393      	bics	r3, r2
 8004208:	0019      	movs	r1, r3
 800420a:	687b      	ldr	r3, [r7, #4]
 800420c:	689a      	ldr	r2, [r3, #8]
 800420e:	4b2a      	ldr	r3, [pc, #168]	; (80042b8 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8004210:	430a      	orrs	r2, r1
 8004212:	64da      	str	r2, [r3, #76]	; 0x4c
  }
#endif /* RCC_CCIPR_USART1SEL */

  /*----------------------------- USART2 Configuration --------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8004214:	687b      	ldr	r3, [r7, #4]
 8004216:	681b      	ldr	r3, [r3, #0]
 8004218:	2202      	movs	r2, #2
 800421a:	4013      	ands	r3, r2
 800421c:	d009      	beq.n	8004232 <HAL_RCCEx_PeriphCLKConfig+0x1de>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 800421e:	4b26      	ldr	r3, [pc, #152]	; (80042b8 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8004220:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8004222:	220c      	movs	r2, #12
 8004224:	4393      	bics	r3, r2
 8004226:	0019      	movs	r1, r3
 8004228:	687b      	ldr	r3, [r7, #4]
 800422a:	68da      	ldr	r2, [r3, #12]
 800422c:	4b22      	ldr	r3, [pc, #136]	; (80042b8 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800422e:	430a      	orrs	r2, r1
 8004230:	64da      	str	r2, [r3, #76]	; 0x4c
  }

  /*------------------------------ LPUART1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8004232:	687b      	ldr	r3, [r7, #4]
 8004234:	681b      	ldr	r3, [r3, #0]
 8004236:	2204      	movs	r2, #4
 8004238:	4013      	ands	r3, r2
 800423a:	d009      	beq.n	8004250 <HAL_RCCEx_PeriphCLKConfig+0x1fc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 800423c:	4b1e      	ldr	r3, [pc, #120]	; (80042b8 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800423e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8004240:	4a24      	ldr	r2, [pc, #144]	; (80042d4 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 8004242:	4013      	ands	r3, r2
 8004244:	0019      	movs	r1, r3
 8004246:	687b      	ldr	r3, [r7, #4]
 8004248:	691a      	ldr	r2, [r3, #16]
 800424a:	4b1b      	ldr	r3, [pc, #108]	; (80042b8 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800424c:	430a      	orrs	r2, r1
 800424e:	64da      	str	r2, [r3, #76]	; 0x4c
  }

  /*------------------------------ I2C1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8004250:	687b      	ldr	r3, [r7, #4]
 8004252:	681b      	ldr	r3, [r3, #0]
 8004254:	2208      	movs	r2, #8
 8004256:	4013      	ands	r3, r2
 8004258:	d009      	beq.n	800426e <HAL_RCCEx_PeriphCLKConfig+0x21a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 800425a:	4b17      	ldr	r3, [pc, #92]	; (80042b8 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800425c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800425e:	4a1e      	ldr	r2, [pc, #120]	; (80042d8 <HAL_RCCEx_PeriphCLKConfig+0x284>)
 8004260:	4013      	ands	r3, r2
 8004262:	0019      	movs	r1, r3
 8004264:	687b      	ldr	r3, [r7, #4]
 8004266:	695a      	ldr	r2, [r3, #20]
 8004268:	4b13      	ldr	r3, [pc, #76]	; (80042b8 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800426a:	430a      	orrs	r2, r1
 800426c:	64da      	str	r2, [r3, #76]	; 0x4c
  }

#if defined (RCC_CCIPR_I2C3SEL)
    /*------------------------------ I2C3 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 800426e:	687b      	ldr	r3, [r7, #4]
 8004270:	681a      	ldr	r2, [r3, #0]
 8004272:	2380      	movs	r3, #128	; 0x80
 8004274:	005b      	lsls	r3, r3, #1
 8004276:	4013      	ands	r3, r2
 8004278:	d009      	beq.n	800428e <HAL_RCCEx_PeriphCLKConfig+0x23a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 800427a:	4b0f      	ldr	r3, [pc, #60]	; (80042b8 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800427c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800427e:	4a10      	ldr	r2, [pc, #64]	; (80042c0 <HAL_RCCEx_PeriphCLKConfig+0x26c>)
 8004280:	4013      	ands	r3, r2
 8004282:	0019      	movs	r1, r3
 8004284:	687b      	ldr	r3, [r7, #4]
 8004286:	699a      	ldr	r2, [r3, #24]
 8004288:	4b0b      	ldr	r3, [pc, #44]	; (80042b8 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800428a:	430a      	orrs	r2, r1
 800428c:	64da      	str	r2, [r3, #76]	; 0x4c
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
  }
#endif /* USB */

  /*---------------------------- LPTIM1 configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 800428e:	687b      	ldr	r3, [r7, #4]
 8004290:	681b      	ldr	r3, [r3, #0]
 8004292:	2280      	movs	r2, #128	; 0x80
 8004294:	4013      	ands	r3, r2
 8004296:	d009      	beq.n	80042ac <HAL_RCCEx_PeriphCLKConfig+0x258>
  {
    assert_param(IS_RCC_LPTIMCLK(PeriphClkInit->LptimClockSelection));
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->LptimClockSelection);
 8004298:	4b07      	ldr	r3, [pc, #28]	; (80042b8 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800429a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800429c:	4a0f      	ldr	r2, [pc, #60]	; (80042dc <HAL_RCCEx_PeriphCLKConfig+0x288>)
 800429e:	4013      	ands	r3, r2
 80042a0:	0019      	movs	r1, r3
 80042a2:	687b      	ldr	r3, [r7, #4]
 80042a4:	69da      	ldr	r2, [r3, #28]
 80042a6:	4b04      	ldr	r3, [pc, #16]	; (80042b8 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 80042a8:	430a      	orrs	r2, r1
 80042aa:	64da      	str	r2, [r3, #76]	; 0x4c
  }

  return HAL_OK;
 80042ac:	2300      	movs	r3, #0
}
 80042ae:	0018      	movs	r0, r3
 80042b0:	46bd      	mov	sp, r7
 80042b2:	b006      	add	sp, #24
 80042b4:	bd80      	pop	{r7, pc}
 80042b6:	46c0      	nop			; (mov r8, r8)
 80042b8:	40021000 	.word	0x40021000
 80042bc:	40007000 	.word	0x40007000
 80042c0:	fffcffff 	.word	0xfffcffff
 80042c4:	fff7ffff 	.word	0xfff7ffff
 80042c8:	00001388 	.word	0x00001388
 80042cc:	ffcfffff 	.word	0xffcfffff
 80042d0:	efffffff 	.word	0xefffffff
 80042d4:	fffff3ff 	.word	0xfffff3ff
 80042d8:	ffffcfff 	.word	0xffffcfff
 80042dc:	fff3ffff 	.word	0xfff3ffff

080042e0 <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 80042e0:	b580      	push	{r7, lr}
 80042e2:	b082      	sub	sp, #8
 80042e4:	af00      	add	r7, sp, #0
 80042e6:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
 80042e8:	687b      	ldr	r3, [r7, #4]
 80042ea:	2b00      	cmp	r3, #0
 80042ec:	d101      	bne.n	80042f2 <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 80042ee:	2301      	movs	r3, #1
 80042f0:	e044      	b.n	800437c <HAL_UART_Init+0x9c>
  {
    /* Check the parameters */
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
  }

  if (huart->gState == HAL_UART_STATE_RESET)
 80042f2:	687b      	ldr	r3, [r7, #4]
 80042f4:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80042f6:	2b00      	cmp	r3, #0
 80042f8:	d107      	bne.n	800430a <HAL_UART_Init+0x2a>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 80042fa:	687b      	ldr	r3, [r7, #4]
 80042fc:	2274      	movs	r2, #116	; 0x74
 80042fe:	2100      	movs	r1, #0
 8004300:	5499      	strb	r1, [r3, r2]

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 8004302:	687b      	ldr	r3, [r7, #4]
 8004304:	0018      	movs	r0, r3
 8004306:	f7fc fafb 	bl	8000900 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
 800430a:	687b      	ldr	r3, [r7, #4]
 800430c:	2224      	movs	r2, #36	; 0x24
 800430e:	679a      	str	r2, [r3, #120]	; 0x78

  __HAL_UART_DISABLE(huart);
 8004310:	687b      	ldr	r3, [r7, #4]
 8004312:	681b      	ldr	r3, [r3, #0]
 8004314:	681a      	ldr	r2, [r3, #0]
 8004316:	687b      	ldr	r3, [r7, #4]
 8004318:	681b      	ldr	r3, [r3, #0]
 800431a:	2101      	movs	r1, #1
 800431c:	438a      	bics	r2, r1
 800431e:	601a      	str	r2, [r3, #0]

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
 8004320:	687b      	ldr	r3, [r7, #4]
 8004322:	0018      	movs	r0, r3
 8004324:	f000 fc36 	bl	8004b94 <UART_SetConfig>
 8004328:	0003      	movs	r3, r0
 800432a:	2b01      	cmp	r3, #1
 800432c:	d101      	bne.n	8004332 <HAL_UART_Init+0x52>
  {
    return HAL_ERROR;
 800432e:	2301      	movs	r3, #1
 8004330:	e024      	b.n	800437c <HAL_UART_Init+0x9c>
  }

  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 8004332:	687b      	ldr	r3, [r7, #4]
 8004334:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004336:	2b00      	cmp	r3, #0
 8004338:	d003      	beq.n	8004342 <HAL_UART_Init+0x62>
  {
    UART_AdvFeatureConfig(huart);
 800433a:	687b      	ldr	r3, [r7, #4]
 800433c:	0018      	movs	r0, r3
 800433e:	f000 fee7 	bl	8005110 <UART_AdvFeatureConfig>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8004342:	687b      	ldr	r3, [r7, #4]
 8004344:	681b      	ldr	r3, [r3, #0]
 8004346:	685a      	ldr	r2, [r3, #4]
 8004348:	687b      	ldr	r3, [r7, #4]
 800434a:	681b      	ldr	r3, [r3, #0]
 800434c:	490d      	ldr	r1, [pc, #52]	; (8004384 <HAL_UART_Init+0xa4>)
 800434e:	400a      	ands	r2, r1
 8004350:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8004352:	687b      	ldr	r3, [r7, #4]
 8004354:	681b      	ldr	r3, [r3, #0]
 8004356:	689a      	ldr	r2, [r3, #8]
 8004358:	687b      	ldr	r3, [r7, #4]
 800435a:	681b      	ldr	r3, [r3, #0]
 800435c:	212a      	movs	r1, #42	; 0x2a
 800435e:	438a      	bics	r2, r1
 8004360:	609a      	str	r2, [r3, #8]

  __HAL_UART_ENABLE(huart);
 8004362:	687b      	ldr	r3, [r7, #4]
 8004364:	681b      	ldr	r3, [r3, #0]
 8004366:	681a      	ldr	r2, [r3, #0]
 8004368:	687b      	ldr	r3, [r7, #4]
 800436a:	681b      	ldr	r3, [r3, #0]
 800436c:	2101      	movs	r1, #1
 800436e:	430a      	orrs	r2, r1
 8004370:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
 8004372:	687b      	ldr	r3, [r7, #4]
 8004374:	0018      	movs	r0, r3
 8004376:	f000 ff7f 	bl	8005278 <UART_CheckIdleState>
 800437a:	0003      	movs	r3, r0
}
 800437c:	0018      	movs	r0, r3
 800437e:	46bd      	mov	sp, r7
 8004380:	b002      	add	sp, #8
 8004382:	bd80      	pop	{r7, pc}
 8004384:	ffffb7ff 	.word	0xffffb7ff

08004388 <HAL_UART_Transmit>:
  * @param Size    Amount of data elements (u8 or u16) to be sent.
  * @param Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8004388:	b580      	push	{r7, lr}
 800438a:	b08a      	sub	sp, #40	; 0x28
 800438c:	af02      	add	r7, sp, #8
 800438e:	60f8      	str	r0, [r7, #12]
 8004390:	60b9      	str	r1, [r7, #8]
 8004392:	603b      	str	r3, [r7, #0]
 8004394:	1dbb      	adds	r3, r7, #6
 8004396:	801a      	strh	r2, [r3, #0]
  uint8_t  *pdata8bits;
  uint16_t *pdata16bits;
  uint32_t tickstart;

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 8004398:	68fb      	ldr	r3, [r7, #12]
 800439a:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800439c:	2b20      	cmp	r3, #32
 800439e:	d000      	beq.n	80043a2 <HAL_UART_Transmit+0x1a>
 80043a0:	e095      	b.n	80044ce <HAL_UART_Transmit+0x146>
  {
    if ((pData == NULL) || (Size == 0U))
 80043a2:	68bb      	ldr	r3, [r7, #8]
 80043a4:	2b00      	cmp	r3, #0
 80043a6:	d003      	beq.n	80043b0 <HAL_UART_Transmit+0x28>
 80043a8:	1dbb      	adds	r3, r7, #6
 80043aa:	881b      	ldrh	r3, [r3, #0]
 80043ac:	2b00      	cmp	r3, #0
 80043ae:	d101      	bne.n	80043b4 <HAL_UART_Transmit+0x2c>
    {
      return  HAL_ERROR;
 80043b0:	2301      	movs	r3, #1
 80043b2:	e08d      	b.n	80044d0 <HAL_UART_Transmit+0x148>
    }

    /* In case of 9bits/No Parity transfer, pData buffer provided as input parameter
       should be aligned on a u16 frontier, as data to be filled into TDR will be
       handled through a u16 cast. */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80043b4:	68fb      	ldr	r3, [r7, #12]
 80043b6:	689a      	ldr	r2, [r3, #8]
 80043b8:	2380      	movs	r3, #128	; 0x80
 80043ba:	015b      	lsls	r3, r3, #5
 80043bc:	429a      	cmp	r2, r3
 80043be:	d109      	bne.n	80043d4 <HAL_UART_Transmit+0x4c>
 80043c0:	68fb      	ldr	r3, [r7, #12]
 80043c2:	691b      	ldr	r3, [r3, #16]
 80043c4:	2b00      	cmp	r3, #0
 80043c6:	d105      	bne.n	80043d4 <HAL_UART_Transmit+0x4c>
    {
      if ((((uint32_t)pData) & 1U) != 0U)
 80043c8:	68bb      	ldr	r3, [r7, #8]
 80043ca:	2201      	movs	r2, #1
 80043cc:	4013      	ands	r3, r2
 80043ce:	d001      	beq.n	80043d4 <HAL_UART_Transmit+0x4c>
      {
        return  HAL_ERROR;
 80043d0:	2301      	movs	r3, #1
 80043d2:	e07d      	b.n	80044d0 <HAL_UART_Transmit+0x148>
      }
    }

    __HAL_LOCK(huart);
 80043d4:	68fb      	ldr	r3, [r7, #12]
 80043d6:	2274      	movs	r2, #116	; 0x74
 80043d8:	5c9b      	ldrb	r3, [r3, r2]
 80043da:	2b01      	cmp	r3, #1
 80043dc:	d101      	bne.n	80043e2 <HAL_UART_Transmit+0x5a>
 80043de:	2302      	movs	r3, #2
 80043e0:	e076      	b.n	80044d0 <HAL_UART_Transmit+0x148>
 80043e2:	68fb      	ldr	r3, [r7, #12]
 80043e4:	2274      	movs	r2, #116	; 0x74
 80043e6:	2101      	movs	r1, #1
 80043e8:	5499      	strb	r1, [r3, r2]

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 80043ea:	68fb      	ldr	r3, [r7, #12]
 80043ec:	2280      	movs	r2, #128	; 0x80
 80043ee:	2100      	movs	r1, #0
 80043f0:	5099      	str	r1, [r3, r2]
    huart->gState = HAL_UART_STATE_BUSY_TX;
 80043f2:	68fb      	ldr	r3, [r7, #12]
 80043f4:	2221      	movs	r2, #33	; 0x21
 80043f6:	679a      	str	r2, [r3, #120]	; 0x78

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
 80043f8:	f7fe fd5c 	bl	8002eb4 <HAL_GetTick>
 80043fc:	0003      	movs	r3, r0
 80043fe:	617b      	str	r3, [r7, #20]

    huart->TxXferSize  = Size;
 8004400:	68fb      	ldr	r3, [r7, #12]
 8004402:	1dba      	adds	r2, r7, #6
 8004404:	2150      	movs	r1, #80	; 0x50
 8004406:	8812      	ldrh	r2, [r2, #0]
 8004408:	525a      	strh	r2, [r3, r1]
    huart->TxXferCount = Size;
 800440a:	68fb      	ldr	r3, [r7, #12]
 800440c:	1dba      	adds	r2, r7, #6
 800440e:	2152      	movs	r1, #82	; 0x52
 8004410:	8812      	ldrh	r2, [r2, #0]
 8004412:	525a      	strh	r2, [r3, r1]

    /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8004414:	68fb      	ldr	r3, [r7, #12]
 8004416:	689a      	ldr	r2, [r3, #8]
 8004418:	2380      	movs	r3, #128	; 0x80
 800441a:	015b      	lsls	r3, r3, #5
 800441c:	429a      	cmp	r2, r3
 800441e:	d108      	bne.n	8004432 <HAL_UART_Transmit+0xaa>
 8004420:	68fb      	ldr	r3, [r7, #12]
 8004422:	691b      	ldr	r3, [r3, #16]
 8004424:	2b00      	cmp	r3, #0
 8004426:	d104      	bne.n	8004432 <HAL_UART_Transmit+0xaa>
    {
      pdata8bits  = NULL;
 8004428:	2300      	movs	r3, #0
 800442a:	61fb      	str	r3, [r7, #28]
      pdata16bits = (uint16_t *) pData;
 800442c:	68bb      	ldr	r3, [r7, #8]
 800442e:	61bb      	str	r3, [r7, #24]
 8004430:	e003      	b.n	800443a <HAL_UART_Transmit+0xb2>
    }
    else
    {
      pdata8bits  = pData;
 8004432:	68bb      	ldr	r3, [r7, #8]
 8004434:	61fb      	str	r3, [r7, #28]
      pdata16bits = NULL;
 8004436:	2300      	movs	r3, #0
 8004438:	61bb      	str	r3, [r7, #24]
    }

    __HAL_UNLOCK(huart);
 800443a:	68fb      	ldr	r3, [r7, #12]
 800443c:	2274      	movs	r2, #116	; 0x74
 800443e:	2100      	movs	r1, #0
 8004440:	5499      	strb	r1, [r3, r2]

    while (huart->TxXferCount > 0U)
 8004442:	e02c      	b.n	800449e <HAL_UART_Transmit+0x116>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 8004444:	697a      	ldr	r2, [r7, #20]
 8004446:	68f8      	ldr	r0, [r7, #12]
 8004448:	683b      	ldr	r3, [r7, #0]
 800444a:	9300      	str	r3, [sp, #0]
 800444c:	0013      	movs	r3, r2
 800444e:	2200      	movs	r2, #0
 8004450:	2180      	movs	r1, #128	; 0x80
 8004452:	f000 ff59 	bl	8005308 <UART_WaitOnFlagUntilTimeout>
 8004456:	1e03      	subs	r3, r0, #0
 8004458:	d001      	beq.n	800445e <HAL_UART_Transmit+0xd6>
      {
        return HAL_TIMEOUT;
 800445a:	2303      	movs	r3, #3
 800445c:	e038      	b.n	80044d0 <HAL_UART_Transmit+0x148>
      }
      if (pdata8bits == NULL)
 800445e:	69fb      	ldr	r3, [r7, #28]
 8004460:	2b00      	cmp	r3, #0
 8004462:	d10b      	bne.n	800447c <HAL_UART_Transmit+0xf4>
      {
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 8004464:	69bb      	ldr	r3, [r7, #24]
 8004466:	881b      	ldrh	r3, [r3, #0]
 8004468:	001a      	movs	r2, r3
 800446a:	68fb      	ldr	r3, [r7, #12]
 800446c:	681b      	ldr	r3, [r3, #0]
 800446e:	05d2      	lsls	r2, r2, #23
 8004470:	0dd2      	lsrs	r2, r2, #23
 8004472:	629a      	str	r2, [r3, #40]	; 0x28
        pdata16bits++;
 8004474:	69bb      	ldr	r3, [r7, #24]
 8004476:	3302      	adds	r3, #2
 8004478:	61bb      	str	r3, [r7, #24]
 800447a:	e007      	b.n	800448c <HAL_UART_Transmit+0x104>
      }
      else
      {
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 800447c:	69fb      	ldr	r3, [r7, #28]
 800447e:	781a      	ldrb	r2, [r3, #0]
 8004480:	68fb      	ldr	r3, [r7, #12]
 8004482:	681b      	ldr	r3, [r3, #0]
 8004484:	629a      	str	r2, [r3, #40]	; 0x28
        pdata8bits++;
 8004486:	69fb      	ldr	r3, [r7, #28]
 8004488:	3301      	adds	r3, #1
 800448a:	61fb      	str	r3, [r7, #28]
      }
      huart->TxXferCount--;
 800448c:	68fb      	ldr	r3, [r7, #12]
 800448e:	2252      	movs	r2, #82	; 0x52
 8004490:	5a9b      	ldrh	r3, [r3, r2]
 8004492:	b29b      	uxth	r3, r3
 8004494:	3b01      	subs	r3, #1
 8004496:	b299      	uxth	r1, r3
 8004498:	68fb      	ldr	r3, [r7, #12]
 800449a:	2252      	movs	r2, #82	; 0x52
 800449c:	5299      	strh	r1, [r3, r2]
    while (huart->TxXferCount > 0U)
 800449e:	68fb      	ldr	r3, [r7, #12]
 80044a0:	2252      	movs	r2, #82	; 0x52
 80044a2:	5a9b      	ldrh	r3, [r3, r2]
 80044a4:	b29b      	uxth	r3, r3
 80044a6:	2b00      	cmp	r3, #0
 80044a8:	d1cc      	bne.n	8004444 <HAL_UART_Transmit+0xbc>
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 80044aa:	697a      	ldr	r2, [r7, #20]
 80044ac:	68f8      	ldr	r0, [r7, #12]
 80044ae:	683b      	ldr	r3, [r7, #0]
 80044b0:	9300      	str	r3, [sp, #0]
 80044b2:	0013      	movs	r3, r2
 80044b4:	2200      	movs	r2, #0
 80044b6:	2140      	movs	r1, #64	; 0x40
 80044b8:	f000 ff26 	bl	8005308 <UART_WaitOnFlagUntilTimeout>
 80044bc:	1e03      	subs	r3, r0, #0
 80044be:	d001      	beq.n	80044c4 <HAL_UART_Transmit+0x13c>
    {
      return HAL_TIMEOUT;
 80044c0:	2303      	movs	r3, #3
 80044c2:	e005      	b.n	80044d0 <HAL_UART_Transmit+0x148>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
 80044c4:	68fb      	ldr	r3, [r7, #12]
 80044c6:	2220      	movs	r2, #32
 80044c8:	679a      	str	r2, [r3, #120]	; 0x78

    return HAL_OK;
 80044ca:	2300      	movs	r3, #0
 80044cc:	e000      	b.n	80044d0 <HAL_UART_Transmit+0x148>
  }
  else
  {
    return HAL_BUSY;
 80044ce:	2302      	movs	r3, #2
  }
}
 80044d0:	0018      	movs	r0, r3
 80044d2:	46bd      	mov	sp, r7
 80044d4:	b008      	add	sp, #32
 80044d6:	bd80      	pop	{r7, pc}

080044d8 <HAL_UART_Receive_IT>:
  * @param pData Pointer to data buffer (u8 or u16 data elements).
  * @param Size  Amount of data elements (u8 or u16) to be received.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 80044d8:	b580      	push	{r7, lr}
 80044da:	b088      	sub	sp, #32
 80044dc:	af00      	add	r7, sp, #0
 80044de:	60f8      	str	r0, [r7, #12]
 80044e0:	60b9      	str	r1, [r7, #8]
 80044e2:	1dbb      	adds	r3, r7, #6
 80044e4:	801a      	strh	r2, [r3, #0]
  /* Check that a Rx process is not already ongoing */
  if (huart->RxState == HAL_UART_STATE_READY)
 80044e6:	68fb      	ldr	r3, [r7, #12]
 80044e8:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80044ea:	2b20      	cmp	r3, #32
 80044ec:	d155      	bne.n	800459a <HAL_UART_Receive_IT+0xc2>
  {
    if ((pData == NULL) || (Size == 0U))
 80044ee:	68bb      	ldr	r3, [r7, #8]
 80044f0:	2b00      	cmp	r3, #0
 80044f2:	d003      	beq.n	80044fc <HAL_UART_Receive_IT+0x24>
 80044f4:	1dbb      	adds	r3, r7, #6
 80044f6:	881b      	ldrh	r3, [r3, #0]
 80044f8:	2b00      	cmp	r3, #0
 80044fa:	d101      	bne.n	8004500 <HAL_UART_Receive_IT+0x28>
    {
      return HAL_ERROR;
 80044fc:	2301      	movs	r3, #1
 80044fe:	e04d      	b.n	800459c <HAL_UART_Receive_IT+0xc4>
    }

    /* In case of 9bits/No Parity transfer, pData buffer provided as input parameter
       should be aligned on a u16 frontier, as data to be received from RDR will be
       handled through a u16 cast. */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8004500:	68fb      	ldr	r3, [r7, #12]
 8004502:	689a      	ldr	r2, [r3, #8]
 8004504:	2380      	movs	r3, #128	; 0x80
 8004506:	015b      	lsls	r3, r3, #5
 8004508:	429a      	cmp	r2, r3
 800450a:	d109      	bne.n	8004520 <HAL_UART_Receive_IT+0x48>
 800450c:	68fb      	ldr	r3, [r7, #12]
 800450e:	691b      	ldr	r3, [r3, #16]
 8004510:	2b00      	cmp	r3, #0
 8004512:	d105      	bne.n	8004520 <HAL_UART_Receive_IT+0x48>
    {
      if ((((uint32_t)pData) & 1U) != 0U)
 8004514:	68bb      	ldr	r3, [r7, #8]
 8004516:	2201      	movs	r2, #1
 8004518:	4013      	ands	r3, r2
 800451a:	d001      	beq.n	8004520 <HAL_UART_Receive_IT+0x48>
      {
        return  HAL_ERROR;
 800451c:	2301      	movs	r3, #1
 800451e:	e03d      	b.n	800459c <HAL_UART_Receive_IT+0xc4>
      }
    }

    __HAL_LOCK(huart);
 8004520:	68fb      	ldr	r3, [r7, #12]
 8004522:	2274      	movs	r2, #116	; 0x74
 8004524:	5c9b      	ldrb	r3, [r3, r2]
 8004526:	2b01      	cmp	r3, #1
 8004528:	d101      	bne.n	800452e <HAL_UART_Receive_IT+0x56>
 800452a:	2302      	movs	r3, #2
 800452c:	e036      	b.n	800459c <HAL_UART_Receive_IT+0xc4>
 800452e:	68fb      	ldr	r3, [r7, #12]
 8004530:	2274      	movs	r2, #116	; 0x74
 8004532:	2101      	movs	r1, #1
 8004534:	5499      	strb	r1, [r3, r2]

    /* Set Reception type to Standard reception */
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8004536:	68fb      	ldr	r3, [r7, #12]
 8004538:	2200      	movs	r2, #0
 800453a:	661a      	str	r2, [r3, #96]	; 0x60

    if (!(IS_LPUART_INSTANCE(huart->Instance)))
 800453c:	68fb      	ldr	r3, [r7, #12]
 800453e:	681b      	ldr	r3, [r3, #0]
 8004540:	4a18      	ldr	r2, [pc, #96]	; (80045a4 <HAL_UART_Receive_IT+0xcc>)
 8004542:	4293      	cmp	r3, r2
 8004544:	d020      	beq.n	8004588 <HAL_UART_Receive_IT+0xb0>
    {
      /* Check that USART RTOEN bit is set */
      if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 8004546:	68fb      	ldr	r3, [r7, #12]
 8004548:	681b      	ldr	r3, [r3, #0]
 800454a:	685a      	ldr	r2, [r3, #4]
 800454c:	2380      	movs	r3, #128	; 0x80
 800454e:	041b      	lsls	r3, r3, #16
 8004550:	4013      	ands	r3, r2
 8004552:	d019      	beq.n	8004588 <HAL_UART_Receive_IT+0xb0>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004554:	f3ef 8310 	mrs	r3, PRIMASK
 8004558:	613b      	str	r3, [r7, #16]
  return(result);
 800455a:	693b      	ldr	r3, [r7, #16]
      {
        /* Enable the UART Receiver Timeout Interrupt */
        ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 800455c:	61fb      	str	r3, [r7, #28]
 800455e:	2301      	movs	r3, #1
 8004560:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004562:	697b      	ldr	r3, [r7, #20]
 8004564:	f383 8810 	msr	PRIMASK, r3
}
 8004568:	46c0      	nop			; (mov r8, r8)
 800456a:	68fb      	ldr	r3, [r7, #12]
 800456c:	681b      	ldr	r3, [r3, #0]
 800456e:	681a      	ldr	r2, [r3, #0]
 8004570:	68fb      	ldr	r3, [r7, #12]
 8004572:	681b      	ldr	r3, [r3, #0]
 8004574:	2180      	movs	r1, #128	; 0x80
 8004576:	04c9      	lsls	r1, r1, #19
 8004578:	430a      	orrs	r2, r1
 800457a:	601a      	str	r2, [r3, #0]
 800457c:	69fb      	ldr	r3, [r7, #28]
 800457e:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004580:	69bb      	ldr	r3, [r7, #24]
 8004582:	f383 8810 	msr	PRIMASK, r3
}
 8004586:	46c0      	nop			; (mov r8, r8)
      }
    }

    return (UART_Start_Receive_IT(huart, pData, Size));
 8004588:	1dbb      	adds	r3, r7, #6
 800458a:	881a      	ldrh	r2, [r3, #0]
 800458c:	68b9      	ldr	r1, [r7, #8]
 800458e:	68fb      	ldr	r3, [r7, #12]
 8004590:	0018      	movs	r0, r3
 8004592:	f000 ff7d 	bl	8005490 <UART_Start_Receive_IT>
 8004596:	0003      	movs	r3, r0
 8004598:	e000      	b.n	800459c <HAL_UART_Receive_IT+0xc4>
  }
  else
  {
    return HAL_BUSY;
 800459a:	2302      	movs	r3, #2
  }
}
 800459c:	0018      	movs	r0, r3
 800459e:	46bd      	mov	sp, r7
 80045a0:	b008      	add	sp, #32
 80045a2:	bd80      	pop	{r7, pc}
 80045a4:	40004800 	.word	0x40004800

080045a8 <HAL_UART_IRQHandler>:
  * @brief Handle UART interrupt request.
  * @param huart UART handle.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
 80045a8:	b590      	push	{r4, r7, lr}
 80045aa:	b0ab      	sub	sp, #172	; 0xac
 80045ac:	af00      	add	r7, sp, #0
 80045ae:	6078      	str	r0, [r7, #4]
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 80045b0:	687b      	ldr	r3, [r7, #4]
 80045b2:	681b      	ldr	r3, [r3, #0]
 80045b4:	69db      	ldr	r3, [r3, #28]
 80045b6:	22a4      	movs	r2, #164	; 0xa4
 80045b8:	18b9      	adds	r1, r7, r2
 80045ba:	600b      	str	r3, [r1, #0]
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 80045bc:	687b      	ldr	r3, [r7, #4]
 80045be:	681b      	ldr	r3, [r3, #0]
 80045c0:	681b      	ldr	r3, [r3, #0]
 80045c2:	20a0      	movs	r0, #160	; 0xa0
 80045c4:	1839      	adds	r1, r7, r0
 80045c6:	600b      	str	r3, [r1, #0]
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 80045c8:	687b      	ldr	r3, [r7, #4]
 80045ca:	681b      	ldr	r3, [r3, #0]
 80045cc:	689b      	ldr	r3, [r3, #8]
 80045ce:	219c      	movs	r1, #156	; 0x9c
 80045d0:	1879      	adds	r1, r7, r1
 80045d2:	600b      	str	r3, [r1, #0]

  uint32_t errorflags;
  uint32_t errorcode;

  /* If no error occurs */
  errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE | USART_ISR_RTOF));
 80045d4:	0011      	movs	r1, r2
 80045d6:	18bb      	adds	r3, r7, r2
 80045d8:	681b      	ldr	r3, [r3, #0]
 80045da:	4a99      	ldr	r2, [pc, #612]	; (8004840 <HAL_UART_IRQHandler+0x298>)
 80045dc:	4013      	ands	r3, r2
 80045de:	2298      	movs	r2, #152	; 0x98
 80045e0:	18bc      	adds	r4, r7, r2
 80045e2:	6023      	str	r3, [r4, #0]
  if (errorflags == 0U)
 80045e4:	18bb      	adds	r3, r7, r2
 80045e6:	681b      	ldr	r3, [r3, #0]
 80045e8:	2b00      	cmp	r3, #0
 80045ea:	d114      	bne.n	8004616 <HAL_UART_IRQHandler+0x6e>
  {
    /* UART in mode Receiver ---------------------------------------------------*/
    if (((isrflags & USART_ISR_RXNE) != 0U)
 80045ec:	187b      	adds	r3, r7, r1
 80045ee:	681b      	ldr	r3, [r3, #0]
 80045f0:	2220      	movs	r2, #32
 80045f2:	4013      	ands	r3, r2
 80045f4:	d00f      	beq.n	8004616 <HAL_UART_IRQHandler+0x6e>
        && ((cr1its & USART_CR1_RXNEIE) != 0U))
 80045f6:	183b      	adds	r3, r7, r0
 80045f8:	681b      	ldr	r3, [r3, #0]
 80045fa:	2220      	movs	r2, #32
 80045fc:	4013      	ands	r3, r2
 80045fe:	d00a      	beq.n	8004616 <HAL_UART_IRQHandler+0x6e>
    {
      if (huart->RxISR != NULL)
 8004600:	687b      	ldr	r3, [r7, #4]
 8004602:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8004604:	2b00      	cmp	r3, #0
 8004606:	d100      	bne.n	800460a <HAL_UART_IRQHandler+0x62>
 8004608:	e298      	b.n	8004b3c <HAL_UART_IRQHandler+0x594>
      {
        huart->RxISR(huart);
 800460a:	687b      	ldr	r3, [r7, #4]
 800460c:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800460e:	687a      	ldr	r2, [r7, #4]
 8004610:	0010      	movs	r0, r2
 8004612:	4798      	blx	r3
      }
      return;
 8004614:	e292      	b.n	8004b3c <HAL_UART_IRQHandler+0x594>
    }
  }

  /* If some errors occur */
  if ((errorflags != 0U)
 8004616:	2398      	movs	r3, #152	; 0x98
 8004618:	18fb      	adds	r3, r7, r3
 800461a:	681b      	ldr	r3, [r3, #0]
 800461c:	2b00      	cmp	r3, #0
 800461e:	d100      	bne.n	8004622 <HAL_UART_IRQHandler+0x7a>
 8004620:	e114      	b.n	800484c <HAL_UART_IRQHandler+0x2a4>
      && (((cr3its & USART_CR3_EIE) != 0U)
 8004622:	239c      	movs	r3, #156	; 0x9c
 8004624:	18fb      	adds	r3, r7, r3
 8004626:	681b      	ldr	r3, [r3, #0]
 8004628:	2201      	movs	r2, #1
 800462a:	4013      	ands	r3, r2
 800462c:	d106      	bne.n	800463c <HAL_UART_IRQHandler+0x94>
          || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U)))
 800462e:	23a0      	movs	r3, #160	; 0xa0
 8004630:	18fb      	adds	r3, r7, r3
 8004632:	681b      	ldr	r3, [r3, #0]
 8004634:	4a83      	ldr	r2, [pc, #524]	; (8004844 <HAL_UART_IRQHandler+0x29c>)
 8004636:	4013      	ands	r3, r2
 8004638:	d100      	bne.n	800463c <HAL_UART_IRQHandler+0x94>
 800463a:	e107      	b.n	800484c <HAL_UART_IRQHandler+0x2a4>
  {
    /* UART parity error interrupt occurred -------------------------------------*/
    if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 800463c:	23a4      	movs	r3, #164	; 0xa4
 800463e:	18fb      	adds	r3, r7, r3
 8004640:	681b      	ldr	r3, [r3, #0]
 8004642:	2201      	movs	r2, #1
 8004644:	4013      	ands	r3, r2
 8004646:	d012      	beq.n	800466e <HAL_UART_IRQHandler+0xc6>
 8004648:	23a0      	movs	r3, #160	; 0xa0
 800464a:	18fb      	adds	r3, r7, r3
 800464c:	681a      	ldr	r2, [r3, #0]
 800464e:	2380      	movs	r3, #128	; 0x80
 8004650:	005b      	lsls	r3, r3, #1
 8004652:	4013      	ands	r3, r2
 8004654:	d00b      	beq.n	800466e <HAL_UART_IRQHandler+0xc6>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 8004656:	687b      	ldr	r3, [r7, #4]
 8004658:	681b      	ldr	r3, [r3, #0]
 800465a:	2201      	movs	r2, #1
 800465c:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_PE;
 800465e:	687b      	ldr	r3, [r7, #4]
 8004660:	2280      	movs	r2, #128	; 0x80
 8004662:	589b      	ldr	r3, [r3, r2]
 8004664:	2201      	movs	r2, #1
 8004666:	431a      	orrs	r2, r3
 8004668:	687b      	ldr	r3, [r7, #4]
 800466a:	2180      	movs	r1, #128	; 0x80
 800466c:	505a      	str	r2, [r3, r1]
    }

    /* UART frame error interrupt occurred --------------------------------------*/
    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 800466e:	23a4      	movs	r3, #164	; 0xa4
 8004670:	18fb      	adds	r3, r7, r3
 8004672:	681b      	ldr	r3, [r3, #0]
 8004674:	2202      	movs	r2, #2
 8004676:	4013      	ands	r3, r2
 8004678:	d011      	beq.n	800469e <HAL_UART_IRQHandler+0xf6>
 800467a:	239c      	movs	r3, #156	; 0x9c
 800467c:	18fb      	adds	r3, r7, r3
 800467e:	681b      	ldr	r3, [r3, #0]
 8004680:	2201      	movs	r2, #1
 8004682:	4013      	ands	r3, r2
 8004684:	d00b      	beq.n	800469e <HAL_UART_IRQHandler+0xf6>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 8004686:	687b      	ldr	r3, [r7, #4]
 8004688:	681b      	ldr	r3, [r3, #0]
 800468a:	2202      	movs	r2, #2
 800468c:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_FE;
 800468e:	687b      	ldr	r3, [r7, #4]
 8004690:	2280      	movs	r2, #128	; 0x80
 8004692:	589b      	ldr	r3, [r3, r2]
 8004694:	2204      	movs	r2, #4
 8004696:	431a      	orrs	r2, r3
 8004698:	687b      	ldr	r3, [r7, #4]
 800469a:	2180      	movs	r1, #128	; 0x80
 800469c:	505a      	str	r2, [r3, r1]
    }

    /* UART noise error interrupt occurred --------------------------------------*/
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 800469e:	23a4      	movs	r3, #164	; 0xa4
 80046a0:	18fb      	adds	r3, r7, r3
 80046a2:	681b      	ldr	r3, [r3, #0]
 80046a4:	2204      	movs	r2, #4
 80046a6:	4013      	ands	r3, r2
 80046a8:	d011      	beq.n	80046ce <HAL_UART_IRQHandler+0x126>
 80046aa:	239c      	movs	r3, #156	; 0x9c
 80046ac:	18fb      	adds	r3, r7, r3
 80046ae:	681b      	ldr	r3, [r3, #0]
 80046b0:	2201      	movs	r2, #1
 80046b2:	4013      	ands	r3, r2
 80046b4:	d00b      	beq.n	80046ce <HAL_UART_IRQHandler+0x126>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 80046b6:	687b      	ldr	r3, [r7, #4]
 80046b8:	681b      	ldr	r3, [r3, #0]
 80046ba:	2204      	movs	r2, #4
 80046bc:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_NE;
 80046be:	687b      	ldr	r3, [r7, #4]
 80046c0:	2280      	movs	r2, #128	; 0x80
 80046c2:	589b      	ldr	r3, [r3, r2]
 80046c4:	2202      	movs	r2, #2
 80046c6:	431a      	orrs	r2, r3
 80046c8:	687b      	ldr	r3, [r7, #4]
 80046ca:	2180      	movs	r1, #128	; 0x80
 80046cc:	505a      	str	r2, [r3, r1]
    }

    /* UART Over-Run interrupt occurred -----------------------------------------*/
    if (((isrflags & USART_ISR_ORE) != 0U)
 80046ce:	23a4      	movs	r3, #164	; 0xa4
 80046d0:	18fb      	adds	r3, r7, r3
 80046d2:	681b      	ldr	r3, [r3, #0]
 80046d4:	2208      	movs	r2, #8
 80046d6:	4013      	ands	r3, r2
 80046d8:	d017      	beq.n	800470a <HAL_UART_IRQHandler+0x162>
        && (((cr1its & USART_CR1_RXNEIE) != 0U) ||
 80046da:	23a0      	movs	r3, #160	; 0xa0
 80046dc:	18fb      	adds	r3, r7, r3
 80046de:	681b      	ldr	r3, [r3, #0]
 80046e0:	2220      	movs	r2, #32
 80046e2:	4013      	ands	r3, r2
 80046e4:	d105      	bne.n	80046f2 <HAL_UART_IRQHandler+0x14a>
            ((cr3its & USART_CR3_EIE) != 0U)))
 80046e6:	239c      	movs	r3, #156	; 0x9c
 80046e8:	18fb      	adds	r3, r7, r3
 80046ea:	681b      	ldr	r3, [r3, #0]
 80046ec:	2201      	movs	r2, #1
 80046ee:	4013      	ands	r3, r2
        && (((cr1its & USART_CR1_RXNEIE) != 0U) ||
 80046f0:	d00b      	beq.n	800470a <HAL_UART_IRQHandler+0x162>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 80046f2:	687b      	ldr	r3, [r7, #4]
 80046f4:	681b      	ldr	r3, [r3, #0]
 80046f6:	2208      	movs	r2, #8
 80046f8:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 80046fa:	687b      	ldr	r3, [r7, #4]
 80046fc:	2280      	movs	r2, #128	; 0x80
 80046fe:	589b      	ldr	r3, [r3, r2]
 8004700:	2208      	movs	r2, #8
 8004702:	431a      	orrs	r2, r3
 8004704:	687b      	ldr	r3, [r7, #4]
 8004706:	2180      	movs	r1, #128	; 0x80
 8004708:	505a      	str	r2, [r3, r1]
    }

    /* UART Receiver Timeout interrupt occurred ---------------------------------*/
    if (((isrflags & USART_ISR_RTOF) != 0U) && ((cr1its & USART_CR1_RTOIE) != 0U))
 800470a:	23a4      	movs	r3, #164	; 0xa4
 800470c:	18fb      	adds	r3, r7, r3
 800470e:	681a      	ldr	r2, [r3, #0]
 8004710:	2380      	movs	r3, #128	; 0x80
 8004712:	011b      	lsls	r3, r3, #4
 8004714:	4013      	ands	r3, r2
 8004716:	d013      	beq.n	8004740 <HAL_UART_IRQHandler+0x198>
 8004718:	23a0      	movs	r3, #160	; 0xa0
 800471a:	18fb      	adds	r3, r7, r3
 800471c:	681a      	ldr	r2, [r3, #0]
 800471e:	2380      	movs	r3, #128	; 0x80
 8004720:	04db      	lsls	r3, r3, #19
 8004722:	4013      	ands	r3, r2
 8004724:	d00c      	beq.n	8004740 <HAL_UART_IRQHandler+0x198>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 8004726:	687b      	ldr	r3, [r7, #4]
 8004728:	681b      	ldr	r3, [r3, #0]
 800472a:	2280      	movs	r2, #128	; 0x80
 800472c:	0112      	lsls	r2, r2, #4
 800472e:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_RTO;
 8004730:	687b      	ldr	r3, [r7, #4]
 8004732:	2280      	movs	r2, #128	; 0x80
 8004734:	589b      	ldr	r3, [r3, r2]
 8004736:	2220      	movs	r2, #32
 8004738:	431a      	orrs	r2, r3
 800473a:	687b      	ldr	r3, [r7, #4]
 800473c:	2180      	movs	r1, #128	; 0x80
 800473e:	505a      	str	r2, [r3, r1]
    }

    /* Call UART Error Call back function if need be ----------------------------*/
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 8004740:	687b      	ldr	r3, [r7, #4]
 8004742:	2280      	movs	r2, #128	; 0x80
 8004744:	589b      	ldr	r3, [r3, r2]
 8004746:	2b00      	cmp	r3, #0
 8004748:	d100      	bne.n	800474c <HAL_UART_IRQHandler+0x1a4>
 800474a:	e1f9      	b.n	8004b40 <HAL_UART_IRQHandler+0x598>
    {
      /* UART in mode Receiver --------------------------------------------------*/
      if (((isrflags & USART_ISR_RXNE) != 0U)
 800474c:	23a4      	movs	r3, #164	; 0xa4
 800474e:	18fb      	adds	r3, r7, r3
 8004750:	681b      	ldr	r3, [r3, #0]
 8004752:	2220      	movs	r2, #32
 8004754:	4013      	ands	r3, r2
 8004756:	d00e      	beq.n	8004776 <HAL_UART_IRQHandler+0x1ce>
          && ((cr1its & USART_CR1_RXNEIE) != 0U))
 8004758:	23a0      	movs	r3, #160	; 0xa0
 800475a:	18fb      	adds	r3, r7, r3
 800475c:	681b      	ldr	r3, [r3, #0]
 800475e:	2220      	movs	r2, #32
 8004760:	4013      	ands	r3, r2
 8004762:	d008      	beq.n	8004776 <HAL_UART_IRQHandler+0x1ce>
      {
        if (huart->RxISR != NULL)
 8004764:	687b      	ldr	r3, [r7, #4]
 8004766:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8004768:	2b00      	cmp	r3, #0
 800476a:	d004      	beq.n	8004776 <HAL_UART_IRQHandler+0x1ce>
        {
          huart->RxISR(huart);
 800476c:	687b      	ldr	r3, [r7, #4]
 800476e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8004770:	687a      	ldr	r2, [r7, #4]
 8004772:	0010      	movs	r0, r2
 8004774:	4798      	blx	r3
      /* If Error is to be considered as blocking :
          - Receiver Timeout error in Reception
          - Overrun error in Reception
          - any error occurs in DMA mode reception
      */
      errorcode = huart->ErrorCode;
 8004776:	687b      	ldr	r3, [r7, #4]
 8004778:	2280      	movs	r2, #128	; 0x80
 800477a:	589b      	ldr	r3, [r3, r2]
 800477c:	2194      	movs	r1, #148	; 0x94
 800477e:	187a      	adds	r2, r7, r1
 8004780:	6013      	str	r3, [r2, #0]
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8004782:	687b      	ldr	r3, [r7, #4]
 8004784:	681b      	ldr	r3, [r3, #0]
 8004786:	689b      	ldr	r3, [r3, #8]
 8004788:	2240      	movs	r2, #64	; 0x40
 800478a:	4013      	ands	r3, r2
 800478c:	2b40      	cmp	r3, #64	; 0x40
 800478e:	d004      	beq.n	800479a <HAL_UART_IRQHandler+0x1f2>
          ((errorcode & (HAL_UART_ERROR_RTO | HAL_UART_ERROR_ORE)) != 0U))
 8004790:	187b      	adds	r3, r7, r1
 8004792:	681b      	ldr	r3, [r3, #0]
 8004794:	2228      	movs	r2, #40	; 0x28
 8004796:	4013      	ands	r3, r2
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8004798:	d047      	beq.n	800482a <HAL_UART_IRQHandler+0x282>
      {
        /* Blocking error : transfer is aborted
           Set the UART state ready to be able to start again the process,
           Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
        UART_EndRxTransfer(huart);
 800479a:	687b      	ldr	r3, [r7, #4]
 800479c:	0018      	movs	r0, r3
 800479e:	f000 ff27 	bl	80055f0 <UART_EndRxTransfer>

        /* Disable the UART DMA Rx request if enabled */
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 80047a2:	687b      	ldr	r3, [r7, #4]
 80047a4:	681b      	ldr	r3, [r3, #0]
 80047a6:	689b      	ldr	r3, [r3, #8]
 80047a8:	2240      	movs	r2, #64	; 0x40
 80047aa:	4013      	ands	r3, r2
 80047ac:	2b40      	cmp	r3, #64	; 0x40
 80047ae:	d137      	bne.n	8004820 <HAL_UART_IRQHandler+0x278>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80047b0:	f3ef 8310 	mrs	r3, PRIMASK
 80047b4:	663b      	str	r3, [r7, #96]	; 0x60
  return(result);
 80047b6:	6e3b      	ldr	r3, [r7, #96]	; 0x60
        {
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 80047b8:	2090      	movs	r0, #144	; 0x90
 80047ba:	183a      	adds	r2, r7, r0
 80047bc:	6013      	str	r3, [r2, #0]
 80047be:	2301      	movs	r3, #1
 80047c0:	667b      	str	r3, [r7, #100]	; 0x64
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80047c2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80047c4:	f383 8810 	msr	PRIMASK, r3
}
 80047c8:	46c0      	nop			; (mov r8, r8)
 80047ca:	687b      	ldr	r3, [r7, #4]
 80047cc:	681b      	ldr	r3, [r3, #0]
 80047ce:	689a      	ldr	r2, [r3, #8]
 80047d0:	687b      	ldr	r3, [r7, #4]
 80047d2:	681b      	ldr	r3, [r3, #0]
 80047d4:	2140      	movs	r1, #64	; 0x40
 80047d6:	438a      	bics	r2, r1
 80047d8:	609a      	str	r2, [r3, #8]
 80047da:	183b      	adds	r3, r7, r0
 80047dc:	681b      	ldr	r3, [r3, #0]
 80047de:	66bb      	str	r3, [r7, #104]	; 0x68
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80047e0:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80047e2:	f383 8810 	msr	PRIMASK, r3
}
 80047e6:	46c0      	nop			; (mov r8, r8)

          /* Abort the UART DMA Rx channel */
          if (huart->hdmarx != NULL)
 80047e8:	687b      	ldr	r3, [r7, #4]
 80047ea:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80047ec:	2b00      	cmp	r3, #0
 80047ee:	d012      	beq.n	8004816 <HAL_UART_IRQHandler+0x26e>
          {
            /* Set the UART DMA Abort callback :
               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 80047f0:	687b      	ldr	r3, [r7, #4]
 80047f2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80047f4:	4a14      	ldr	r2, [pc, #80]	; (8004848 <HAL_UART_IRQHandler+0x2a0>)
 80047f6:	639a      	str	r2, [r3, #56]	; 0x38

            /* Abort DMA RX */
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 80047f8:	687b      	ldr	r3, [r7, #4]
 80047fa:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80047fc:	0018      	movs	r0, r3
 80047fe:	f7fe fca5 	bl	800314c <HAL_DMA_Abort_IT>
 8004802:	1e03      	subs	r3, r0, #0
 8004804:	d01a      	beq.n	800483c <HAL_UART_IRQHandler+0x294>
            {
              /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8004806:	687b      	ldr	r3, [r7, #4]
 8004808:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800480a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800480c:	687b      	ldr	r3, [r7, #4]
 800480e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8004810:	0018      	movs	r0, r3
 8004812:	4790      	blx	r2
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8004814:	e012      	b.n	800483c <HAL_UART_IRQHandler+0x294>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
            /*Call registered error callback*/
            huart->ErrorCallback(huart);
#else
            /*Call legacy weak error callback*/
            HAL_UART_ErrorCallback(huart);
 8004816:	687b      	ldr	r3, [r7, #4]
 8004818:	0018      	movs	r0, r3
 800481a:	f000 f9a7 	bl	8004b6c <HAL_UART_ErrorCallback>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800481e:	e00d      	b.n	800483c <HAL_UART_IRQHandler+0x294>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
          /*Call registered error callback*/
          huart->ErrorCallback(huart);
#else
          /*Call legacy weak error callback*/
          HAL_UART_ErrorCallback(huart);
 8004820:	687b      	ldr	r3, [r7, #4]
 8004822:	0018      	movs	r0, r3
 8004824:	f000 f9a2 	bl	8004b6c <HAL_UART_ErrorCallback>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8004828:	e008      	b.n	800483c <HAL_UART_IRQHandler+0x294>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered error callback*/
        huart->ErrorCallback(huart);
#else
        /*Call legacy weak error callback*/
        HAL_UART_ErrorCallback(huart);
 800482a:	687b      	ldr	r3, [r7, #4]
 800482c:	0018      	movs	r0, r3
 800482e:	f000 f99d 	bl	8004b6c <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 8004832:	687b      	ldr	r3, [r7, #4]
 8004834:	2280      	movs	r2, #128	; 0x80
 8004836:	2100      	movs	r1, #0
 8004838:	5099      	str	r1, [r3, r2]
      }
    }
    return;
 800483a:	e181      	b.n	8004b40 <HAL_UART_IRQHandler+0x598>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800483c:	46c0      	nop			; (mov r8, r8)
    return;
 800483e:	e17f      	b.n	8004b40 <HAL_UART_IRQHandler+0x598>
 8004840:	0000080f 	.word	0x0000080f
 8004844:	04000120 	.word	0x04000120
 8004848:	080056b5 	.word	0x080056b5

  } /* End if some error occurs */

  /* Check current reception Mode :
     If Reception till IDLE event has been selected : */
  if ((huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800484c:	687b      	ldr	r3, [r7, #4]
 800484e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8004850:	2b01      	cmp	r3, #1
 8004852:	d000      	beq.n	8004856 <HAL_UART_IRQHandler+0x2ae>
 8004854:	e133      	b.n	8004abe <HAL_UART_IRQHandler+0x516>
      && ((isrflags & USART_ISR_IDLE) != 0U)
 8004856:	23a4      	movs	r3, #164	; 0xa4
 8004858:	18fb      	adds	r3, r7, r3
 800485a:	681b      	ldr	r3, [r3, #0]
 800485c:	2210      	movs	r2, #16
 800485e:	4013      	ands	r3, r2
 8004860:	d100      	bne.n	8004864 <HAL_UART_IRQHandler+0x2bc>
 8004862:	e12c      	b.n	8004abe <HAL_UART_IRQHandler+0x516>
      && ((cr1its & USART_ISR_IDLE) != 0U))
 8004864:	23a0      	movs	r3, #160	; 0xa0
 8004866:	18fb      	adds	r3, r7, r3
 8004868:	681b      	ldr	r3, [r3, #0]
 800486a:	2210      	movs	r2, #16
 800486c:	4013      	ands	r3, r2
 800486e:	d100      	bne.n	8004872 <HAL_UART_IRQHandler+0x2ca>
 8004870:	e125      	b.n	8004abe <HAL_UART_IRQHandler+0x516>
  {
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8004872:	687b      	ldr	r3, [r7, #4]
 8004874:	681b      	ldr	r3, [r3, #0]
 8004876:	2210      	movs	r2, #16
 8004878:	621a      	str	r2, [r3, #32]

    /* Check if DMA mode is enabled in UART */
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800487a:	687b      	ldr	r3, [r7, #4]
 800487c:	681b      	ldr	r3, [r3, #0]
 800487e:	689b      	ldr	r3, [r3, #8]
 8004880:	2240      	movs	r2, #64	; 0x40
 8004882:	4013      	ands	r3, r2
 8004884:	2b40      	cmp	r3, #64	; 0x40
 8004886:	d000      	beq.n	800488a <HAL_UART_IRQHandler+0x2e2>
 8004888:	e09d      	b.n	80049c6 <HAL_UART_IRQHandler+0x41e>
    {
      /* DMA mode enabled */
      /* Check received length : If all expected data are received, do nothing,
         (DMA cplt callback will be called).
         Otherwise, if at least one data has already been received, IDLE event is to be notified to user */
      uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);
 800488a:	687b      	ldr	r3, [r7, #4]
 800488c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800488e:	681b      	ldr	r3, [r3, #0]
 8004890:	685a      	ldr	r2, [r3, #4]
 8004892:	217e      	movs	r1, #126	; 0x7e
 8004894:	187b      	adds	r3, r7, r1
 8004896:	801a      	strh	r2, [r3, #0]
      if ((nb_remaining_rx_data > 0U)
 8004898:	187b      	adds	r3, r7, r1
 800489a:	881b      	ldrh	r3, [r3, #0]
 800489c:	2b00      	cmp	r3, #0
 800489e:	d100      	bne.n	80048a2 <HAL_UART_IRQHandler+0x2fa>
 80048a0:	e150      	b.n	8004b44 <HAL_UART_IRQHandler+0x59c>
          && (nb_remaining_rx_data < huart->RxXferSize))
 80048a2:	687b      	ldr	r3, [r7, #4]
 80048a4:	2258      	movs	r2, #88	; 0x58
 80048a6:	5a9b      	ldrh	r3, [r3, r2]
 80048a8:	187a      	adds	r2, r7, r1
 80048aa:	8812      	ldrh	r2, [r2, #0]
 80048ac:	429a      	cmp	r2, r3
 80048ae:	d300      	bcc.n	80048b2 <HAL_UART_IRQHandler+0x30a>
 80048b0:	e148      	b.n	8004b44 <HAL_UART_IRQHandler+0x59c>
      {
        /* Reception is not complete */
        huart->RxXferCount = nb_remaining_rx_data;
 80048b2:	687b      	ldr	r3, [r7, #4]
 80048b4:	187a      	adds	r2, r7, r1
 80048b6:	215a      	movs	r1, #90	; 0x5a
 80048b8:	8812      	ldrh	r2, [r2, #0]
 80048ba:	525a      	strh	r2, [r3, r1]

        /* In Normal mode, end DMA xfer and HAL UART Rx process*/
        if (HAL_IS_BIT_CLR(huart->hdmarx->Instance->CCR, DMA_CCR_CIRC))
 80048bc:	687b      	ldr	r3, [r7, #4]
 80048be:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80048c0:	681b      	ldr	r3, [r3, #0]
 80048c2:	681b      	ldr	r3, [r3, #0]
 80048c4:	2220      	movs	r2, #32
 80048c6:	4013      	ands	r3, r2
 80048c8:	d16e      	bne.n	80049a8 <HAL_UART_IRQHandler+0x400>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80048ca:	f3ef 8310 	mrs	r3, PRIMASK
 80048ce:	633b      	str	r3, [r7, #48]	; 0x30
  return(result);
 80048d0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
        {
          /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 80048d2:	67bb      	str	r3, [r7, #120]	; 0x78
 80048d4:	2301      	movs	r3, #1
 80048d6:	637b      	str	r3, [r7, #52]	; 0x34
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80048d8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80048da:	f383 8810 	msr	PRIMASK, r3
}
 80048de:	46c0      	nop			; (mov r8, r8)
 80048e0:	687b      	ldr	r3, [r7, #4]
 80048e2:	681b      	ldr	r3, [r3, #0]
 80048e4:	681a      	ldr	r2, [r3, #0]
 80048e6:	687b      	ldr	r3, [r7, #4]
 80048e8:	681b      	ldr	r3, [r3, #0]
 80048ea:	499a      	ldr	r1, [pc, #616]	; (8004b54 <HAL_UART_IRQHandler+0x5ac>)
 80048ec:	400a      	ands	r2, r1
 80048ee:	601a      	str	r2, [r3, #0]
 80048f0:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80048f2:	63bb      	str	r3, [r7, #56]	; 0x38
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80048f4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80048f6:	f383 8810 	msr	PRIMASK, r3
}
 80048fa:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80048fc:	f3ef 8310 	mrs	r3, PRIMASK
 8004900:	63fb      	str	r3, [r7, #60]	; 0x3c
  return(result);
 8004902:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8004904:	677b      	str	r3, [r7, #116]	; 0x74
 8004906:	2301      	movs	r3, #1
 8004908:	643b      	str	r3, [r7, #64]	; 0x40
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800490a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800490c:	f383 8810 	msr	PRIMASK, r3
}
 8004910:	46c0      	nop			; (mov r8, r8)
 8004912:	687b      	ldr	r3, [r7, #4]
 8004914:	681b      	ldr	r3, [r3, #0]
 8004916:	689a      	ldr	r2, [r3, #8]
 8004918:	687b      	ldr	r3, [r7, #4]
 800491a:	681b      	ldr	r3, [r3, #0]
 800491c:	2101      	movs	r1, #1
 800491e:	438a      	bics	r2, r1
 8004920:	609a      	str	r2, [r3, #8]
 8004922:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8004924:	647b      	str	r3, [r7, #68]	; 0x44
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004926:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8004928:	f383 8810 	msr	PRIMASK, r3
}
 800492c:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800492e:	f3ef 8310 	mrs	r3, PRIMASK
 8004932:	64bb      	str	r3, [r7, #72]	; 0x48
  return(result);
 8004934:	6cbb      	ldr	r3, [r7, #72]	; 0x48

          /* Disable the DMA transfer for the receiver request by resetting the DMAR bit
             in the UART CR3 register */
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8004936:	673b      	str	r3, [r7, #112]	; 0x70
 8004938:	2301      	movs	r3, #1
 800493a:	64fb      	str	r3, [r7, #76]	; 0x4c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800493c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800493e:	f383 8810 	msr	PRIMASK, r3
}
 8004942:	46c0      	nop			; (mov r8, r8)
 8004944:	687b      	ldr	r3, [r7, #4]
 8004946:	681b      	ldr	r3, [r3, #0]
 8004948:	689a      	ldr	r2, [r3, #8]
 800494a:	687b      	ldr	r3, [r7, #4]
 800494c:	681b      	ldr	r3, [r3, #0]
 800494e:	2140      	movs	r1, #64	; 0x40
 8004950:	438a      	bics	r2, r1
 8004952:	609a      	str	r2, [r3, #8]
 8004954:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8004956:	653b      	str	r3, [r7, #80]	; 0x50
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004958:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800495a:	f383 8810 	msr	PRIMASK, r3
}
 800495e:	46c0      	nop			; (mov r8, r8)

          /* At end of Rx process, restore huart->RxState to Ready */
          huart->RxState = HAL_UART_STATE_READY;
 8004960:	687b      	ldr	r3, [r7, #4]
 8004962:	2220      	movs	r2, #32
 8004964:	67da      	str	r2, [r3, #124]	; 0x7c
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8004966:	687b      	ldr	r3, [r7, #4]
 8004968:	2200      	movs	r2, #0
 800496a:	661a      	str	r2, [r3, #96]	; 0x60
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800496c:	f3ef 8310 	mrs	r3, PRIMASK
 8004970:	657b      	str	r3, [r7, #84]	; 0x54
  return(result);
 8004972:	6d7b      	ldr	r3, [r7, #84]	; 0x54

          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8004974:	66fb      	str	r3, [r7, #108]	; 0x6c
 8004976:	2301      	movs	r3, #1
 8004978:	65bb      	str	r3, [r7, #88]	; 0x58
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800497a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800497c:	f383 8810 	msr	PRIMASK, r3
}
 8004980:	46c0      	nop			; (mov r8, r8)
 8004982:	687b      	ldr	r3, [r7, #4]
 8004984:	681b      	ldr	r3, [r3, #0]
 8004986:	681a      	ldr	r2, [r3, #0]
 8004988:	687b      	ldr	r3, [r7, #4]
 800498a:	681b      	ldr	r3, [r3, #0]
 800498c:	2110      	movs	r1, #16
 800498e:	438a      	bics	r2, r1
 8004990:	601a      	str	r2, [r3, #0]
 8004992:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8004994:	65fb      	str	r3, [r7, #92]	; 0x5c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004996:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8004998:	f383 8810 	msr	PRIMASK, r3
}
 800499c:	46c0      	nop			; (mov r8, r8)

          /* Last bytes received, so no need as the abort is immediate */
          (void)HAL_DMA_Abort(huart->hdmarx);
 800499e:	687b      	ldr	r3, [r7, #4]
 80049a0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80049a2:	0018      	movs	r0, r3
 80049a4:	f7fe fb92 	bl	80030cc <HAL_DMA_Abort>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
 80049a8:	687b      	ldr	r3, [r7, #4]
 80049aa:	2258      	movs	r2, #88	; 0x58
 80049ac:	5a9a      	ldrh	r2, [r3, r2]
 80049ae:	687b      	ldr	r3, [r7, #4]
 80049b0:	215a      	movs	r1, #90	; 0x5a
 80049b2:	5a5b      	ldrh	r3, [r3, r1]
 80049b4:	b29b      	uxth	r3, r3
 80049b6:	1ad3      	subs	r3, r2, r3
 80049b8:	b29a      	uxth	r2, r3
 80049ba:	687b      	ldr	r3, [r7, #4]
 80049bc:	0011      	movs	r1, r2
 80049be:	0018      	movs	r0, r3
 80049c0:	f000 f8dc 	bl	8004b7c <HAL_UARTEx_RxEventCallback>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
      }
      return;
 80049c4:	e0be      	b.n	8004b44 <HAL_UART_IRQHandler+0x59c>
    else
    {
      /* DMA mode not enabled */
      /* Check received length : If all expected data are received, do nothing.
         Otherwise, if at least one data has already been received, IDLE event is to be notified to user */
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 80049c6:	687b      	ldr	r3, [r7, #4]
 80049c8:	2258      	movs	r2, #88	; 0x58
 80049ca:	5a99      	ldrh	r1, [r3, r2]
 80049cc:	687b      	ldr	r3, [r7, #4]
 80049ce:	225a      	movs	r2, #90	; 0x5a
 80049d0:	5a9b      	ldrh	r3, [r3, r2]
 80049d2:	b29a      	uxth	r2, r3
 80049d4:	208e      	movs	r0, #142	; 0x8e
 80049d6:	183b      	adds	r3, r7, r0
 80049d8:	1a8a      	subs	r2, r1, r2
 80049da:	801a      	strh	r2, [r3, #0]
      if ((huart->RxXferCount > 0U)
 80049dc:	687b      	ldr	r3, [r7, #4]
 80049de:	225a      	movs	r2, #90	; 0x5a
 80049e0:	5a9b      	ldrh	r3, [r3, r2]
 80049e2:	b29b      	uxth	r3, r3
 80049e4:	2b00      	cmp	r3, #0
 80049e6:	d100      	bne.n	80049ea <HAL_UART_IRQHandler+0x442>
 80049e8:	e0ae      	b.n	8004b48 <HAL_UART_IRQHandler+0x5a0>
          && (nb_rx_data > 0U))
 80049ea:	183b      	adds	r3, r7, r0
 80049ec:	881b      	ldrh	r3, [r3, #0]
 80049ee:	2b00      	cmp	r3, #0
 80049f0:	d100      	bne.n	80049f4 <HAL_UART_IRQHandler+0x44c>
 80049f2:	e0a9      	b.n	8004b48 <HAL_UART_IRQHandler+0x5a0>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80049f4:	f3ef 8310 	mrs	r3, PRIMASK
 80049f8:	60fb      	str	r3, [r7, #12]
  return(result);
 80049fa:	68fb      	ldr	r3, [r7, #12]
      {
        /* Disable the UART Parity Error Interrupt and RXNE interrupts */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 80049fc:	2488      	movs	r4, #136	; 0x88
 80049fe:	193a      	adds	r2, r7, r4
 8004a00:	6013      	str	r3, [r2, #0]
 8004a02:	2301      	movs	r3, #1
 8004a04:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004a06:	693b      	ldr	r3, [r7, #16]
 8004a08:	f383 8810 	msr	PRIMASK, r3
}
 8004a0c:	46c0      	nop			; (mov r8, r8)
 8004a0e:	687b      	ldr	r3, [r7, #4]
 8004a10:	681b      	ldr	r3, [r3, #0]
 8004a12:	681a      	ldr	r2, [r3, #0]
 8004a14:	687b      	ldr	r3, [r7, #4]
 8004a16:	681b      	ldr	r3, [r3, #0]
 8004a18:	494f      	ldr	r1, [pc, #316]	; (8004b58 <HAL_UART_IRQHandler+0x5b0>)
 8004a1a:	400a      	ands	r2, r1
 8004a1c:	601a      	str	r2, [r3, #0]
 8004a1e:	193b      	adds	r3, r7, r4
 8004a20:	681b      	ldr	r3, [r3, #0]
 8004a22:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004a24:	697b      	ldr	r3, [r7, #20]
 8004a26:	f383 8810 	msr	PRIMASK, r3
}
 8004a2a:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004a2c:	f3ef 8310 	mrs	r3, PRIMASK
 8004a30:	61bb      	str	r3, [r7, #24]
  return(result);
 8004a32:	69bb      	ldr	r3, [r7, #24]

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8004a34:	2484      	movs	r4, #132	; 0x84
 8004a36:	193a      	adds	r2, r7, r4
 8004a38:	6013      	str	r3, [r2, #0]
 8004a3a:	2301      	movs	r3, #1
 8004a3c:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004a3e:	69fb      	ldr	r3, [r7, #28]
 8004a40:	f383 8810 	msr	PRIMASK, r3
}
 8004a44:	46c0      	nop			; (mov r8, r8)
 8004a46:	687b      	ldr	r3, [r7, #4]
 8004a48:	681b      	ldr	r3, [r3, #0]
 8004a4a:	689a      	ldr	r2, [r3, #8]
 8004a4c:	687b      	ldr	r3, [r7, #4]
 8004a4e:	681b      	ldr	r3, [r3, #0]
 8004a50:	2101      	movs	r1, #1
 8004a52:	438a      	bics	r2, r1
 8004a54:	609a      	str	r2, [r3, #8]
 8004a56:	193b      	adds	r3, r7, r4
 8004a58:	681b      	ldr	r3, [r3, #0]
 8004a5a:	623b      	str	r3, [r7, #32]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004a5c:	6a3b      	ldr	r3, [r7, #32]
 8004a5e:	f383 8810 	msr	PRIMASK, r3
}
 8004a62:	46c0      	nop			; (mov r8, r8)

        /* Rx process is completed, restore huart->RxState to Ready */
        huart->RxState = HAL_UART_STATE_READY;
 8004a64:	687b      	ldr	r3, [r7, #4]
 8004a66:	2220      	movs	r2, #32
 8004a68:	67da      	str	r2, [r3, #124]	; 0x7c
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8004a6a:	687b      	ldr	r3, [r7, #4]
 8004a6c:	2200      	movs	r2, #0
 8004a6e:	661a      	str	r2, [r3, #96]	; 0x60

        /* Clear RxISR function pointer */
        huart->RxISR = NULL;
 8004a70:	687b      	ldr	r3, [r7, #4]
 8004a72:	2200      	movs	r2, #0
 8004a74:	665a      	str	r2, [r3, #100]	; 0x64
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004a76:	f3ef 8310 	mrs	r3, PRIMASK
 8004a7a:	627b      	str	r3, [r7, #36]	; 0x24
  return(result);
 8004a7c:	6a7b      	ldr	r3, [r7, #36]	; 0x24

        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8004a7e:	2480      	movs	r4, #128	; 0x80
 8004a80:	193a      	adds	r2, r7, r4
 8004a82:	6013      	str	r3, [r2, #0]
 8004a84:	2301      	movs	r3, #1
 8004a86:	62bb      	str	r3, [r7, #40]	; 0x28
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004a88:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004a8a:	f383 8810 	msr	PRIMASK, r3
}
 8004a8e:	46c0      	nop			; (mov r8, r8)
 8004a90:	687b      	ldr	r3, [r7, #4]
 8004a92:	681b      	ldr	r3, [r3, #0]
 8004a94:	681a      	ldr	r2, [r3, #0]
 8004a96:	687b      	ldr	r3, [r7, #4]
 8004a98:	681b      	ldr	r3, [r3, #0]
 8004a9a:	2110      	movs	r1, #16
 8004a9c:	438a      	bics	r2, r1
 8004a9e:	601a      	str	r2, [r3, #0]
 8004aa0:	193b      	adds	r3, r7, r4
 8004aa2:	681b      	ldr	r3, [r3, #0]
 8004aa4:	62fb      	str	r3, [r7, #44]	; 0x2c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004aa6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004aa8:	f383 8810 	msr	PRIMASK, r3
}
 8004aac:	46c0      	nop			; (mov r8, r8)
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx complete callback*/
        huart->RxEventCallback(huart, nb_rx_data);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, nb_rx_data);
 8004aae:	183b      	adds	r3, r7, r0
 8004ab0:	881a      	ldrh	r2, [r3, #0]
 8004ab2:	687b      	ldr	r3, [r7, #4]
 8004ab4:	0011      	movs	r1, r2
 8004ab6:	0018      	movs	r0, r3
 8004ab8:	f000 f860 	bl	8004b7c <HAL_UARTEx_RxEventCallback>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
      }
      return;
 8004abc:	e044      	b.n	8004b48 <HAL_UART_IRQHandler+0x5a0>
    }
  }

  /* UART wakeup from Stop mode interrupt occurred ---------------------------*/
  if (((isrflags & USART_ISR_WUF) != 0U) && ((cr3its & USART_CR3_WUFIE) != 0U))
 8004abe:	23a4      	movs	r3, #164	; 0xa4
 8004ac0:	18fb      	adds	r3, r7, r3
 8004ac2:	681a      	ldr	r2, [r3, #0]
 8004ac4:	2380      	movs	r3, #128	; 0x80
 8004ac6:	035b      	lsls	r3, r3, #13
 8004ac8:	4013      	ands	r3, r2
 8004aca:	d010      	beq.n	8004aee <HAL_UART_IRQHandler+0x546>
 8004acc:	239c      	movs	r3, #156	; 0x9c
 8004ace:	18fb      	adds	r3, r7, r3
 8004ad0:	681a      	ldr	r2, [r3, #0]
 8004ad2:	2380      	movs	r3, #128	; 0x80
 8004ad4:	03db      	lsls	r3, r3, #15
 8004ad6:	4013      	ands	r3, r2
 8004ad8:	d009      	beq.n	8004aee <HAL_UART_IRQHandler+0x546>
  {
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
 8004ada:	687b      	ldr	r3, [r7, #4]
 8004adc:	681b      	ldr	r3, [r3, #0]
 8004ade:	2280      	movs	r2, #128	; 0x80
 8004ae0:	0352      	lsls	r2, r2, #13
 8004ae2:	621a      	str	r2, [r3, #32]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    /* Call registered Wakeup Callback */
    huart->WakeupCallback(huart);
#else
    /* Call legacy weak Wakeup Callback */
    HAL_UARTEx_WakeupCallback(huart);
 8004ae4:	687b      	ldr	r3, [r7, #4]
 8004ae6:	0018      	movs	r0, r3
 8004ae8:	f000 ff8e 	bl	8005a08 <HAL_UARTEx_WakeupCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
    return;
 8004aec:	e02f      	b.n	8004b4e <HAL_UART_IRQHandler+0x5a6>
  }

  /* UART in mode Transmitter ------------------------------------------------*/
  if (((isrflags & USART_ISR_TXE) != 0U)
 8004aee:	23a4      	movs	r3, #164	; 0xa4
 8004af0:	18fb      	adds	r3, r7, r3
 8004af2:	681b      	ldr	r3, [r3, #0]
 8004af4:	2280      	movs	r2, #128	; 0x80
 8004af6:	4013      	ands	r3, r2
 8004af8:	d00f      	beq.n	8004b1a <HAL_UART_IRQHandler+0x572>
      && ((cr1its & USART_CR1_TXEIE) != 0U))
 8004afa:	23a0      	movs	r3, #160	; 0xa0
 8004afc:	18fb      	adds	r3, r7, r3
 8004afe:	681b      	ldr	r3, [r3, #0]
 8004b00:	2280      	movs	r2, #128	; 0x80
 8004b02:	4013      	ands	r3, r2
 8004b04:	d009      	beq.n	8004b1a <HAL_UART_IRQHandler+0x572>
  {
    if (huart->TxISR != NULL)
 8004b06:	687b      	ldr	r3, [r7, #4]
 8004b08:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8004b0a:	2b00      	cmp	r3, #0
 8004b0c:	d01e      	beq.n	8004b4c <HAL_UART_IRQHandler+0x5a4>
    {
      huart->TxISR(huart);
 8004b0e:	687b      	ldr	r3, [r7, #4]
 8004b10:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8004b12:	687a      	ldr	r2, [r7, #4]
 8004b14:	0010      	movs	r0, r2
 8004b16:	4798      	blx	r3
    }
    return;
 8004b18:	e018      	b.n	8004b4c <HAL_UART_IRQHandler+0x5a4>
  }

  /* UART in mode Transmitter (transmission end) -----------------------------*/
  if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
 8004b1a:	23a4      	movs	r3, #164	; 0xa4
 8004b1c:	18fb      	adds	r3, r7, r3
 8004b1e:	681b      	ldr	r3, [r3, #0]
 8004b20:	2240      	movs	r2, #64	; 0x40
 8004b22:	4013      	ands	r3, r2
 8004b24:	d013      	beq.n	8004b4e <HAL_UART_IRQHandler+0x5a6>
 8004b26:	23a0      	movs	r3, #160	; 0xa0
 8004b28:	18fb      	adds	r3, r7, r3
 8004b2a:	681b      	ldr	r3, [r3, #0]
 8004b2c:	2240      	movs	r2, #64	; 0x40
 8004b2e:	4013      	ands	r3, r2
 8004b30:	d00d      	beq.n	8004b4e <HAL_UART_IRQHandler+0x5a6>
  {
    UART_EndTransmit_IT(huart);
 8004b32:	687b      	ldr	r3, [r7, #4]
 8004b34:	0018      	movs	r0, r3
 8004b36:	f000 fdd4 	bl	80056e2 <UART_EndTransmit_IT>
    return;
 8004b3a:	e008      	b.n	8004b4e <HAL_UART_IRQHandler+0x5a6>
      return;
 8004b3c:	46c0      	nop			; (mov r8, r8)
 8004b3e:	e006      	b.n	8004b4e <HAL_UART_IRQHandler+0x5a6>
    return;
 8004b40:	46c0      	nop			; (mov r8, r8)
 8004b42:	e004      	b.n	8004b4e <HAL_UART_IRQHandler+0x5a6>
      return;
 8004b44:	46c0      	nop			; (mov r8, r8)
 8004b46:	e002      	b.n	8004b4e <HAL_UART_IRQHandler+0x5a6>
      return;
 8004b48:	46c0      	nop			; (mov r8, r8)
 8004b4a:	e000      	b.n	8004b4e <HAL_UART_IRQHandler+0x5a6>
    return;
 8004b4c:	46c0      	nop			; (mov r8, r8)
  }

}
 8004b4e:	46bd      	mov	sp, r7
 8004b50:	b02b      	add	sp, #172	; 0xac
 8004b52:	bd90      	pop	{r4, r7, pc}
 8004b54:	fffffeff 	.word	0xfffffeff
 8004b58:	fffffedf 	.word	0xfffffedf

08004b5c <HAL_UART_TxCpltCallback>:
  * @brief Tx Transfer completed callback.
  * @param huart UART handle.
  * @retval None
  */
__weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
 8004b5c:	b580      	push	{r7, lr}
 8004b5e:	b082      	sub	sp, #8
 8004b60:	af00      	add	r7, sp, #0
 8004b62:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_TxCpltCallback can be implemented in the user file.
   */
}
 8004b64:	46c0      	nop			; (mov r8, r8)
 8004b66:	46bd      	mov	sp, r7
 8004b68:	b002      	add	sp, #8
 8004b6a:	bd80      	pop	{r7, pc}

08004b6c <HAL_UART_ErrorCallback>:
  * @brief  UART error callback.
  * @param  huart UART handle.
  * @retval None
  */
__weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
 8004b6c:	b580      	push	{r7, lr}
 8004b6e:	b082      	sub	sp, #8
 8004b70:	af00      	add	r7, sp, #0
 8004b72:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_ErrorCallback can be implemented in the user file.
   */
}
 8004b74:	46c0      	nop			; (mov r8, r8)
 8004b76:	46bd      	mov	sp, r7
 8004b78:	b002      	add	sp, #8
 8004b7a:	bd80      	pop	{r7, pc}

08004b7c <HAL_UARTEx_RxEventCallback>:
  * @param  Size  Number of data available in application reception buffer (indicates a position in
  *               reception buffer until which, data are available)
  * @retval None
  */
__weak void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
{
 8004b7c:	b580      	push	{r7, lr}
 8004b7e:	b082      	sub	sp, #8
 8004b80:	af00      	add	r7, sp, #0
 8004b82:	6078      	str	r0, [r7, #4]
 8004b84:	000a      	movs	r2, r1
 8004b86:	1cbb      	adds	r3, r7, #2
 8004b88:	801a      	strh	r2, [r3, #0]
  UNUSED(Size);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_RxEventCallback can be implemented in the user file.
   */
}
 8004b8a:	46c0      	nop			; (mov r8, r8)
 8004b8c:	46bd      	mov	sp, r7
 8004b8e:	b002      	add	sp, #8
 8004b90:	bd80      	pop	{r7, pc}
	...

08004b94 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 8004b94:	b5b0      	push	{r4, r5, r7, lr}
 8004b96:	b08e      	sub	sp, #56	; 0x38
 8004b98:	af00      	add	r7, sp, #0
 8004b9a:	61f8      	str	r0, [r7, #28]
  uint32_t tmpreg;
  uint16_t brrtemp;
  UART_ClockSourceTypeDef clocksource;
  uint32_t usartdiv;
  HAL_StatusTypeDef ret               = HAL_OK;
 8004b9c:	231a      	movs	r3, #26
 8004b9e:	2218      	movs	r2, #24
 8004ba0:	4694      	mov	ip, r2
 8004ba2:	44bc      	add	ip, r7
 8004ba4:	4463      	add	r3, ip
 8004ba6:	2200      	movs	r2, #0
 8004ba8:	701a      	strb	r2, [r3, #0]
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8004baa:	69fb      	ldr	r3, [r7, #28]
 8004bac:	689a      	ldr	r2, [r3, #8]
 8004bae:	69fb      	ldr	r3, [r7, #28]
 8004bb0:	691b      	ldr	r3, [r3, #16]
 8004bb2:	431a      	orrs	r2, r3
 8004bb4:	69fb      	ldr	r3, [r7, #28]
 8004bb6:	695b      	ldr	r3, [r3, #20]
 8004bb8:	431a      	orrs	r2, r3
 8004bba:	69fb      	ldr	r3, [r7, #28]
 8004bbc:	69db      	ldr	r3, [r3, #28]
 8004bbe:	4313      	orrs	r3, r2
 8004bc0:	637b      	str	r3, [r7, #52]	; 0x34
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8004bc2:	69fb      	ldr	r3, [r7, #28]
 8004bc4:	681b      	ldr	r3, [r3, #0]
 8004bc6:	681b      	ldr	r3, [r3, #0]
 8004bc8:	4ab0      	ldr	r2, [pc, #704]	; (8004e8c <UART_SetConfig+0x2f8>)
 8004bca:	4013      	ands	r3, r2
 8004bcc:	0019      	movs	r1, r3
 8004bce:	69fb      	ldr	r3, [r7, #28]
 8004bd0:	681b      	ldr	r3, [r3, #0]
 8004bd2:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8004bd4:	430a      	orrs	r2, r1
 8004bd6:	601a      	str	r2, [r3, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8004bd8:	69fb      	ldr	r3, [r7, #28]
 8004bda:	681b      	ldr	r3, [r3, #0]
 8004bdc:	685b      	ldr	r3, [r3, #4]
 8004bde:	4aac      	ldr	r2, [pc, #688]	; (8004e90 <UART_SetConfig+0x2fc>)
 8004be0:	4013      	ands	r3, r2
 8004be2:	0019      	movs	r1, r3
 8004be4:	69fb      	ldr	r3, [r7, #28]
 8004be6:	68da      	ldr	r2, [r3, #12]
 8004be8:	69fb      	ldr	r3, [r7, #28]
 8004bea:	681b      	ldr	r3, [r3, #0]
 8004bec:	430a      	orrs	r2, r1
 8004bee:	605a      	str	r2, [r3, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 8004bf0:	69fb      	ldr	r3, [r7, #28]
 8004bf2:	699b      	ldr	r3, [r3, #24]
 8004bf4:	637b      	str	r3, [r7, #52]	; 0x34

  if (!(UART_INSTANCE_LOWPOWER(huart)))
 8004bf6:	69fb      	ldr	r3, [r7, #28]
 8004bf8:	681b      	ldr	r3, [r3, #0]
 8004bfa:	4aa6      	ldr	r2, [pc, #664]	; (8004e94 <UART_SetConfig+0x300>)
 8004bfc:	4293      	cmp	r3, r2
 8004bfe:	d004      	beq.n	8004c0a <UART_SetConfig+0x76>
  {
    tmpreg |= huart->Init.OneBitSampling;
 8004c00:	69fb      	ldr	r3, [r7, #28]
 8004c02:	6a1b      	ldr	r3, [r3, #32]
 8004c04:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8004c06:	4313      	orrs	r3, r2
 8004c08:	637b      	str	r3, [r7, #52]	; 0x34
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8004c0a:	69fb      	ldr	r3, [r7, #28]
 8004c0c:	681b      	ldr	r3, [r3, #0]
 8004c0e:	689b      	ldr	r3, [r3, #8]
 8004c10:	4aa1      	ldr	r2, [pc, #644]	; (8004e98 <UART_SetConfig+0x304>)
 8004c12:	4013      	ands	r3, r2
 8004c14:	0019      	movs	r1, r3
 8004c16:	69fb      	ldr	r3, [r7, #28]
 8004c18:	681b      	ldr	r3, [r3, #0]
 8004c1a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8004c1c:	430a      	orrs	r2, r1
 8004c1e:	609a      	str	r2, [r3, #8]


  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 8004c20:	69fb      	ldr	r3, [r7, #28]
 8004c22:	681b      	ldr	r3, [r3, #0]
 8004c24:	4a9d      	ldr	r2, [pc, #628]	; (8004e9c <UART_SetConfig+0x308>)
 8004c26:	4293      	cmp	r3, r2
 8004c28:	d136      	bne.n	8004c98 <UART_SetConfig+0x104>
 8004c2a:	4b9d      	ldr	r3, [pc, #628]	; (8004ea0 <UART_SetConfig+0x30c>)
 8004c2c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8004c2e:	2203      	movs	r2, #3
 8004c30:	4013      	ands	r3, r2
 8004c32:	2b03      	cmp	r3, #3
 8004c34:	d020      	beq.n	8004c78 <UART_SetConfig+0xe4>
 8004c36:	d827      	bhi.n	8004c88 <UART_SetConfig+0xf4>
 8004c38:	2b02      	cmp	r3, #2
 8004c3a:	d00d      	beq.n	8004c58 <UART_SetConfig+0xc4>
 8004c3c:	d824      	bhi.n	8004c88 <UART_SetConfig+0xf4>
 8004c3e:	2b00      	cmp	r3, #0
 8004c40:	d002      	beq.n	8004c48 <UART_SetConfig+0xb4>
 8004c42:	2b01      	cmp	r3, #1
 8004c44:	d010      	beq.n	8004c68 <UART_SetConfig+0xd4>
 8004c46:	e01f      	b.n	8004c88 <UART_SetConfig+0xf4>
 8004c48:	231b      	movs	r3, #27
 8004c4a:	2218      	movs	r2, #24
 8004c4c:	4694      	mov	ip, r2
 8004c4e:	44bc      	add	ip, r7
 8004c50:	4463      	add	r3, ip
 8004c52:	2201      	movs	r2, #1
 8004c54:	701a      	strb	r2, [r3, #0]
 8004c56:	e0c5      	b.n	8004de4 <UART_SetConfig+0x250>
 8004c58:	231b      	movs	r3, #27
 8004c5a:	2218      	movs	r2, #24
 8004c5c:	4694      	mov	ip, r2
 8004c5e:	44bc      	add	ip, r7
 8004c60:	4463      	add	r3, ip
 8004c62:	2202      	movs	r2, #2
 8004c64:	701a      	strb	r2, [r3, #0]
 8004c66:	e0bd      	b.n	8004de4 <UART_SetConfig+0x250>
 8004c68:	231b      	movs	r3, #27
 8004c6a:	2218      	movs	r2, #24
 8004c6c:	4694      	mov	ip, r2
 8004c6e:	44bc      	add	ip, r7
 8004c70:	4463      	add	r3, ip
 8004c72:	2204      	movs	r2, #4
 8004c74:	701a      	strb	r2, [r3, #0]
 8004c76:	e0b5      	b.n	8004de4 <UART_SetConfig+0x250>
 8004c78:	231b      	movs	r3, #27
 8004c7a:	2218      	movs	r2, #24
 8004c7c:	4694      	mov	ip, r2
 8004c7e:	44bc      	add	ip, r7
 8004c80:	4463      	add	r3, ip
 8004c82:	2208      	movs	r2, #8
 8004c84:	701a      	strb	r2, [r3, #0]
 8004c86:	e0ad      	b.n	8004de4 <UART_SetConfig+0x250>
 8004c88:	231b      	movs	r3, #27
 8004c8a:	2218      	movs	r2, #24
 8004c8c:	4694      	mov	ip, r2
 8004c8e:	44bc      	add	ip, r7
 8004c90:	4463      	add	r3, ip
 8004c92:	2210      	movs	r2, #16
 8004c94:	701a      	strb	r2, [r3, #0]
 8004c96:	e0a5      	b.n	8004de4 <UART_SetConfig+0x250>
 8004c98:	69fb      	ldr	r3, [r7, #28]
 8004c9a:	681b      	ldr	r3, [r3, #0]
 8004c9c:	4a81      	ldr	r2, [pc, #516]	; (8004ea4 <UART_SetConfig+0x310>)
 8004c9e:	4293      	cmp	r3, r2
 8004ca0:	d136      	bne.n	8004d10 <UART_SetConfig+0x17c>
 8004ca2:	4b7f      	ldr	r3, [pc, #508]	; (8004ea0 <UART_SetConfig+0x30c>)
 8004ca4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8004ca6:	220c      	movs	r2, #12
 8004ca8:	4013      	ands	r3, r2
 8004caa:	2b0c      	cmp	r3, #12
 8004cac:	d020      	beq.n	8004cf0 <UART_SetConfig+0x15c>
 8004cae:	d827      	bhi.n	8004d00 <UART_SetConfig+0x16c>
 8004cb0:	2b08      	cmp	r3, #8
 8004cb2:	d00d      	beq.n	8004cd0 <UART_SetConfig+0x13c>
 8004cb4:	d824      	bhi.n	8004d00 <UART_SetConfig+0x16c>
 8004cb6:	2b00      	cmp	r3, #0
 8004cb8:	d002      	beq.n	8004cc0 <UART_SetConfig+0x12c>
 8004cba:	2b04      	cmp	r3, #4
 8004cbc:	d010      	beq.n	8004ce0 <UART_SetConfig+0x14c>
 8004cbe:	e01f      	b.n	8004d00 <UART_SetConfig+0x16c>
 8004cc0:	231b      	movs	r3, #27
 8004cc2:	2218      	movs	r2, #24
 8004cc4:	4694      	mov	ip, r2
 8004cc6:	44bc      	add	ip, r7
 8004cc8:	4463      	add	r3, ip
 8004cca:	2200      	movs	r2, #0
 8004ccc:	701a      	strb	r2, [r3, #0]
 8004cce:	e089      	b.n	8004de4 <UART_SetConfig+0x250>
 8004cd0:	231b      	movs	r3, #27
 8004cd2:	2218      	movs	r2, #24
 8004cd4:	4694      	mov	ip, r2
 8004cd6:	44bc      	add	ip, r7
 8004cd8:	4463      	add	r3, ip
 8004cda:	2202      	movs	r2, #2
 8004cdc:	701a      	strb	r2, [r3, #0]
 8004cde:	e081      	b.n	8004de4 <UART_SetConfig+0x250>
 8004ce0:	231b      	movs	r3, #27
 8004ce2:	2218      	movs	r2, #24
 8004ce4:	4694      	mov	ip, r2
 8004ce6:	44bc      	add	ip, r7
 8004ce8:	4463      	add	r3, ip
 8004cea:	2204      	movs	r2, #4
 8004cec:	701a      	strb	r2, [r3, #0]
 8004cee:	e079      	b.n	8004de4 <UART_SetConfig+0x250>
 8004cf0:	231b      	movs	r3, #27
 8004cf2:	2218      	movs	r2, #24
 8004cf4:	4694      	mov	ip, r2
 8004cf6:	44bc      	add	ip, r7
 8004cf8:	4463      	add	r3, ip
 8004cfa:	2208      	movs	r2, #8
 8004cfc:	701a      	strb	r2, [r3, #0]
 8004cfe:	e071      	b.n	8004de4 <UART_SetConfig+0x250>
 8004d00:	231b      	movs	r3, #27
 8004d02:	2218      	movs	r2, #24
 8004d04:	4694      	mov	ip, r2
 8004d06:	44bc      	add	ip, r7
 8004d08:	4463      	add	r3, ip
 8004d0a:	2210      	movs	r2, #16
 8004d0c:	701a      	strb	r2, [r3, #0]
 8004d0e:	e069      	b.n	8004de4 <UART_SetConfig+0x250>
 8004d10:	69fb      	ldr	r3, [r7, #28]
 8004d12:	681b      	ldr	r3, [r3, #0]
 8004d14:	4a64      	ldr	r2, [pc, #400]	; (8004ea8 <UART_SetConfig+0x314>)
 8004d16:	4293      	cmp	r3, r2
 8004d18:	d107      	bne.n	8004d2a <UART_SetConfig+0x196>
 8004d1a:	231b      	movs	r3, #27
 8004d1c:	2218      	movs	r2, #24
 8004d1e:	4694      	mov	ip, r2
 8004d20:	44bc      	add	ip, r7
 8004d22:	4463      	add	r3, ip
 8004d24:	2200      	movs	r2, #0
 8004d26:	701a      	strb	r2, [r3, #0]
 8004d28:	e05c      	b.n	8004de4 <UART_SetConfig+0x250>
 8004d2a:	69fb      	ldr	r3, [r7, #28]
 8004d2c:	681b      	ldr	r3, [r3, #0]
 8004d2e:	4a5f      	ldr	r2, [pc, #380]	; (8004eac <UART_SetConfig+0x318>)
 8004d30:	4293      	cmp	r3, r2
 8004d32:	d107      	bne.n	8004d44 <UART_SetConfig+0x1b0>
 8004d34:	231b      	movs	r3, #27
 8004d36:	2218      	movs	r2, #24
 8004d38:	4694      	mov	ip, r2
 8004d3a:	44bc      	add	ip, r7
 8004d3c:	4463      	add	r3, ip
 8004d3e:	2200      	movs	r2, #0
 8004d40:	701a      	strb	r2, [r3, #0]
 8004d42:	e04f      	b.n	8004de4 <UART_SetConfig+0x250>
 8004d44:	69fb      	ldr	r3, [r7, #28]
 8004d46:	681b      	ldr	r3, [r3, #0]
 8004d48:	4a52      	ldr	r2, [pc, #328]	; (8004e94 <UART_SetConfig+0x300>)
 8004d4a:	4293      	cmp	r3, r2
 8004d4c:	d143      	bne.n	8004dd6 <UART_SetConfig+0x242>
 8004d4e:	4b54      	ldr	r3, [pc, #336]	; (8004ea0 <UART_SetConfig+0x30c>)
 8004d50:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8004d52:	23c0      	movs	r3, #192	; 0xc0
 8004d54:	011b      	lsls	r3, r3, #4
 8004d56:	4013      	ands	r3, r2
 8004d58:	22c0      	movs	r2, #192	; 0xc0
 8004d5a:	0112      	lsls	r2, r2, #4
 8004d5c:	4293      	cmp	r3, r2
 8004d5e:	d02a      	beq.n	8004db6 <UART_SetConfig+0x222>
 8004d60:	22c0      	movs	r2, #192	; 0xc0
 8004d62:	0112      	lsls	r2, r2, #4
 8004d64:	4293      	cmp	r3, r2
 8004d66:	d82e      	bhi.n	8004dc6 <UART_SetConfig+0x232>
 8004d68:	2280      	movs	r2, #128	; 0x80
 8004d6a:	0112      	lsls	r2, r2, #4
 8004d6c:	4293      	cmp	r3, r2
 8004d6e:	d012      	beq.n	8004d96 <UART_SetConfig+0x202>
 8004d70:	2280      	movs	r2, #128	; 0x80
 8004d72:	0112      	lsls	r2, r2, #4
 8004d74:	4293      	cmp	r3, r2
 8004d76:	d826      	bhi.n	8004dc6 <UART_SetConfig+0x232>
 8004d78:	2b00      	cmp	r3, #0
 8004d7a:	d004      	beq.n	8004d86 <UART_SetConfig+0x1f2>
 8004d7c:	2280      	movs	r2, #128	; 0x80
 8004d7e:	00d2      	lsls	r2, r2, #3
 8004d80:	4293      	cmp	r3, r2
 8004d82:	d010      	beq.n	8004da6 <UART_SetConfig+0x212>
 8004d84:	e01f      	b.n	8004dc6 <UART_SetConfig+0x232>
 8004d86:	231b      	movs	r3, #27
 8004d88:	2218      	movs	r2, #24
 8004d8a:	4694      	mov	ip, r2
 8004d8c:	44bc      	add	ip, r7
 8004d8e:	4463      	add	r3, ip
 8004d90:	2200      	movs	r2, #0
 8004d92:	701a      	strb	r2, [r3, #0]
 8004d94:	e026      	b.n	8004de4 <UART_SetConfig+0x250>
 8004d96:	231b      	movs	r3, #27
 8004d98:	2218      	movs	r2, #24
 8004d9a:	4694      	mov	ip, r2
 8004d9c:	44bc      	add	ip, r7
 8004d9e:	4463      	add	r3, ip
 8004da0:	2202      	movs	r2, #2
 8004da2:	701a      	strb	r2, [r3, #0]
 8004da4:	e01e      	b.n	8004de4 <UART_SetConfig+0x250>
 8004da6:	231b      	movs	r3, #27
 8004da8:	2218      	movs	r2, #24
 8004daa:	4694      	mov	ip, r2
 8004dac:	44bc      	add	ip, r7
 8004dae:	4463      	add	r3, ip
 8004db0:	2204      	movs	r2, #4
 8004db2:	701a      	strb	r2, [r3, #0]
 8004db4:	e016      	b.n	8004de4 <UART_SetConfig+0x250>
 8004db6:	231b      	movs	r3, #27
 8004db8:	2218      	movs	r2, #24
 8004dba:	4694      	mov	ip, r2
 8004dbc:	44bc      	add	ip, r7
 8004dbe:	4463      	add	r3, ip
 8004dc0:	2208      	movs	r2, #8
 8004dc2:	701a      	strb	r2, [r3, #0]
 8004dc4:	e00e      	b.n	8004de4 <UART_SetConfig+0x250>
 8004dc6:	231b      	movs	r3, #27
 8004dc8:	2218      	movs	r2, #24
 8004dca:	4694      	mov	ip, r2
 8004dcc:	44bc      	add	ip, r7
 8004dce:	4463      	add	r3, ip
 8004dd0:	2210      	movs	r2, #16
 8004dd2:	701a      	strb	r2, [r3, #0]
 8004dd4:	e006      	b.n	8004de4 <UART_SetConfig+0x250>
 8004dd6:	231b      	movs	r3, #27
 8004dd8:	2218      	movs	r2, #24
 8004dda:	4694      	mov	ip, r2
 8004ddc:	44bc      	add	ip, r7
 8004dde:	4463      	add	r3, ip
 8004de0:	2210      	movs	r2, #16
 8004de2:	701a      	strb	r2, [r3, #0]

  /* Check LPUART instance */
  if (UART_INSTANCE_LOWPOWER(huart))
 8004de4:	69fb      	ldr	r3, [r7, #28]
 8004de6:	681b      	ldr	r3, [r3, #0]
 8004de8:	4a2a      	ldr	r2, [pc, #168]	; (8004e94 <UART_SetConfig+0x300>)
 8004dea:	4293      	cmp	r3, r2
 8004dec:	d000      	beq.n	8004df0 <UART_SetConfig+0x25c>
 8004dee:	e09e      	b.n	8004f2e <UART_SetConfig+0x39a>
  {
    /* Retrieve frequency clock */
    switch (clocksource)
 8004df0:	231b      	movs	r3, #27
 8004df2:	2218      	movs	r2, #24
 8004df4:	4694      	mov	ip, r2
 8004df6:	44bc      	add	ip, r7
 8004df8:	4463      	add	r3, ip
 8004dfa:	781b      	ldrb	r3, [r3, #0]
 8004dfc:	2b08      	cmp	r3, #8
 8004dfe:	d01d      	beq.n	8004e3c <UART_SetConfig+0x2a8>
 8004e00:	dc20      	bgt.n	8004e44 <UART_SetConfig+0x2b0>
 8004e02:	2b04      	cmp	r3, #4
 8004e04:	d015      	beq.n	8004e32 <UART_SetConfig+0x29e>
 8004e06:	dc1d      	bgt.n	8004e44 <UART_SetConfig+0x2b0>
 8004e08:	2b00      	cmp	r3, #0
 8004e0a:	d002      	beq.n	8004e12 <UART_SetConfig+0x27e>
 8004e0c:	2b02      	cmp	r3, #2
 8004e0e:	d005      	beq.n	8004e1c <UART_SetConfig+0x288>
 8004e10:	e018      	b.n	8004e44 <UART_SetConfig+0x2b0>
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 8004e12:	f7ff f8f3 	bl	8003ffc <HAL_RCC_GetPCLK1Freq>
 8004e16:	0003      	movs	r3, r0
 8004e18:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004e1a:	e01d      	b.n	8004e58 <UART_SetConfig+0x2c4>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8004e1c:	4b20      	ldr	r3, [pc, #128]	; (8004ea0 <UART_SetConfig+0x30c>)
 8004e1e:	681b      	ldr	r3, [r3, #0]
 8004e20:	2210      	movs	r2, #16
 8004e22:	4013      	ands	r3, r2
 8004e24:	d002      	beq.n	8004e2c <UART_SetConfig+0x298>
        {
          pclk = (uint32_t)(HSI_VALUE >> 2U);
 8004e26:	4b22      	ldr	r3, [pc, #136]	; (8004eb0 <UART_SetConfig+0x31c>)
 8004e28:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
 8004e2a:	e015      	b.n	8004e58 <UART_SetConfig+0x2c4>
          pclk = (uint32_t) HSI_VALUE;
 8004e2c:	4b21      	ldr	r3, [pc, #132]	; (8004eb4 <UART_SetConfig+0x320>)
 8004e2e:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004e30:	e012      	b.n	8004e58 <UART_SetConfig+0x2c4>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
 8004e32:	f7ff f833 	bl	8003e9c <HAL_RCC_GetSysClockFreq>
 8004e36:	0003      	movs	r3, r0
 8004e38:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004e3a:	e00d      	b.n	8004e58 <UART_SetConfig+0x2c4>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 8004e3c:	2380      	movs	r3, #128	; 0x80
 8004e3e:	021b      	lsls	r3, r3, #8
 8004e40:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004e42:	e009      	b.n	8004e58 <UART_SetConfig+0x2c4>
      default:
        pclk = 0U;
 8004e44:	2300      	movs	r3, #0
 8004e46:	62fb      	str	r3, [r7, #44]	; 0x2c
        ret = HAL_ERROR;
 8004e48:	231a      	movs	r3, #26
 8004e4a:	2218      	movs	r2, #24
 8004e4c:	4694      	mov	ip, r2
 8004e4e:	44bc      	add	ip, r7
 8004e50:	4463      	add	r3, ip
 8004e52:	2201      	movs	r2, #1
 8004e54:	701a      	strb	r2, [r3, #0]
        break;
 8004e56:	46c0      	nop			; (mov r8, r8)
    }

    /* If proper clock source reported */
    if (pclk != 0U)
 8004e58:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004e5a:	2b00      	cmp	r3, #0
 8004e5c:	d100      	bne.n	8004e60 <UART_SetConfig+0x2cc>
 8004e5e:	e13c      	b.n	80050da <UART_SetConfig+0x546>
    {
      /* No Prescaler applicable */
      /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ((pclk < (3U * huart->Init.BaudRate)) ||
 8004e60:	69fb      	ldr	r3, [r7, #28]
 8004e62:	685a      	ldr	r2, [r3, #4]
 8004e64:	0013      	movs	r3, r2
 8004e66:	005b      	lsls	r3, r3, #1
 8004e68:	189b      	adds	r3, r3, r2
 8004e6a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004e6c:	429a      	cmp	r2, r3
 8004e6e:	d305      	bcc.n	8004e7c <UART_SetConfig+0x2e8>
          (pclk > (4096U * huart->Init.BaudRate)))
 8004e70:	69fb      	ldr	r3, [r7, #28]
 8004e72:	685b      	ldr	r3, [r3, #4]
 8004e74:	031b      	lsls	r3, r3, #12
      if ((pclk < (3U * huart->Init.BaudRate)) ||
 8004e76:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004e78:	429a      	cmp	r2, r3
 8004e7a:	d91d      	bls.n	8004eb8 <UART_SetConfig+0x324>
      {
        ret = HAL_ERROR;
 8004e7c:	231a      	movs	r3, #26
 8004e7e:	2218      	movs	r2, #24
 8004e80:	4694      	mov	ip, r2
 8004e82:	44bc      	add	ip, r7
 8004e84:	4463      	add	r3, ip
 8004e86:	2201      	movs	r2, #1
 8004e88:	701a      	strb	r2, [r3, #0]
 8004e8a:	e126      	b.n	80050da <UART_SetConfig+0x546>
 8004e8c:	efff69f3 	.word	0xefff69f3
 8004e90:	ffffcfff 	.word	0xffffcfff
 8004e94:	40004800 	.word	0x40004800
 8004e98:	fffff4ff 	.word	0xfffff4ff
 8004e9c:	40013800 	.word	0x40013800
 8004ea0:	40021000 	.word	0x40021000
 8004ea4:	40004400 	.word	0x40004400
 8004ea8:	40004c00 	.word	0x40004c00
 8004eac:	40005000 	.word	0x40005000
 8004eb0:	003d0900 	.word	0x003d0900
 8004eb4:	00f42400 	.word	0x00f42400
      }
      else
      {
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate));
 8004eb8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004eba:	613b      	str	r3, [r7, #16]
 8004ebc:	2300      	movs	r3, #0
 8004ebe:	617b      	str	r3, [r7, #20]
 8004ec0:	6939      	ldr	r1, [r7, #16]
 8004ec2:	697a      	ldr	r2, [r7, #20]
 8004ec4:	000b      	movs	r3, r1
 8004ec6:	0e1b      	lsrs	r3, r3, #24
 8004ec8:	0010      	movs	r0, r2
 8004eca:	0205      	lsls	r5, r0, #8
 8004ecc:	431d      	orrs	r5, r3
 8004ece:	000b      	movs	r3, r1
 8004ed0:	021c      	lsls	r4, r3, #8
 8004ed2:	69fb      	ldr	r3, [r7, #28]
 8004ed4:	685b      	ldr	r3, [r3, #4]
 8004ed6:	085b      	lsrs	r3, r3, #1
 8004ed8:	60bb      	str	r3, [r7, #8]
 8004eda:	2300      	movs	r3, #0
 8004edc:	60fb      	str	r3, [r7, #12]
 8004ede:	68b8      	ldr	r0, [r7, #8]
 8004ee0:	68f9      	ldr	r1, [r7, #12]
 8004ee2:	1900      	adds	r0, r0, r4
 8004ee4:	4169      	adcs	r1, r5
 8004ee6:	69fb      	ldr	r3, [r7, #28]
 8004ee8:	685b      	ldr	r3, [r3, #4]
 8004eea:	603b      	str	r3, [r7, #0]
 8004eec:	2300      	movs	r3, #0
 8004eee:	607b      	str	r3, [r7, #4]
 8004ef0:	683a      	ldr	r2, [r7, #0]
 8004ef2:	687b      	ldr	r3, [r7, #4]
 8004ef4:	f7fb f9a6 	bl	8000244 <__aeabi_uldivmod>
 8004ef8:	0002      	movs	r2, r0
 8004efa:	000b      	movs	r3, r1
 8004efc:	0013      	movs	r3, r2
 8004efe:	62bb      	str	r3, [r7, #40]	; 0x28
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 8004f00:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8004f02:	23c0      	movs	r3, #192	; 0xc0
 8004f04:	009b      	lsls	r3, r3, #2
 8004f06:	429a      	cmp	r2, r3
 8004f08:	d309      	bcc.n	8004f1e <UART_SetConfig+0x38a>
 8004f0a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8004f0c:	2380      	movs	r3, #128	; 0x80
 8004f0e:	035b      	lsls	r3, r3, #13
 8004f10:	429a      	cmp	r2, r3
 8004f12:	d204      	bcs.n	8004f1e <UART_SetConfig+0x38a>
        {
          huart->Instance->BRR = usartdiv;
 8004f14:	69fb      	ldr	r3, [r7, #28]
 8004f16:	681b      	ldr	r3, [r3, #0]
 8004f18:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8004f1a:	60da      	str	r2, [r3, #12]
 8004f1c:	e0dd      	b.n	80050da <UART_SetConfig+0x546>
        }
        else
        {
          ret = HAL_ERROR;
 8004f1e:	231a      	movs	r3, #26
 8004f20:	2218      	movs	r2, #24
 8004f22:	4694      	mov	ip, r2
 8004f24:	44bc      	add	ip, r7
 8004f26:	4463      	add	r3, ip
 8004f28:	2201      	movs	r2, #1
 8004f2a:	701a      	strb	r2, [r3, #0]
 8004f2c:	e0d5      	b.n	80050da <UART_SetConfig+0x546>
        }
      } /* if ( (pclk < (3 * huart->Init.BaudRate) ) || (pclk > (4096 * huart->Init.BaudRate) )) */
    } /* if (pclk != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8004f2e:	69fb      	ldr	r3, [r7, #28]
 8004f30:	69da      	ldr	r2, [r3, #28]
 8004f32:	2380      	movs	r3, #128	; 0x80
 8004f34:	021b      	lsls	r3, r3, #8
 8004f36:	429a      	cmp	r2, r3
 8004f38:	d000      	beq.n	8004f3c <UART_SetConfig+0x3a8>
 8004f3a:	e074      	b.n	8005026 <UART_SetConfig+0x492>
  {
    switch (clocksource)
 8004f3c:	231b      	movs	r3, #27
 8004f3e:	2218      	movs	r2, #24
 8004f40:	4694      	mov	ip, r2
 8004f42:	44bc      	add	ip, r7
 8004f44:	4463      	add	r3, ip
 8004f46:	781b      	ldrb	r3, [r3, #0]
 8004f48:	2b08      	cmp	r3, #8
 8004f4a:	d822      	bhi.n	8004f92 <UART_SetConfig+0x3fe>
 8004f4c:	009a      	lsls	r2, r3, #2
 8004f4e:	4b6b      	ldr	r3, [pc, #428]	; (80050fc <UART_SetConfig+0x568>)
 8004f50:	18d3      	adds	r3, r2, r3
 8004f52:	681b      	ldr	r3, [r3, #0]
 8004f54:	469f      	mov	pc, r3
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 8004f56:	f7ff f851 	bl	8003ffc <HAL_RCC_GetPCLK1Freq>
 8004f5a:	0003      	movs	r3, r0
 8004f5c:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004f5e:	e022      	b.n	8004fa6 <UART_SetConfig+0x412>
      case UART_CLOCKSOURCE_PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
 8004f60:	f7ff f862 	bl	8004028 <HAL_RCC_GetPCLK2Freq>
 8004f64:	0003      	movs	r3, r0
 8004f66:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004f68:	e01d      	b.n	8004fa6 <UART_SetConfig+0x412>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8004f6a:	4b65      	ldr	r3, [pc, #404]	; (8005100 <UART_SetConfig+0x56c>)
 8004f6c:	681b      	ldr	r3, [r3, #0]
 8004f6e:	2210      	movs	r2, #16
 8004f70:	4013      	ands	r3, r2
 8004f72:	d002      	beq.n	8004f7a <UART_SetConfig+0x3e6>
        {
          pclk = (uint32_t)(HSI_VALUE >> 2U);
 8004f74:	4b63      	ldr	r3, [pc, #396]	; (8005104 <UART_SetConfig+0x570>)
 8004f76:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
 8004f78:	e015      	b.n	8004fa6 <UART_SetConfig+0x412>
          pclk = (uint32_t) HSI_VALUE;
 8004f7a:	4b63      	ldr	r3, [pc, #396]	; (8005108 <UART_SetConfig+0x574>)
 8004f7c:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004f7e:	e012      	b.n	8004fa6 <UART_SetConfig+0x412>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
 8004f80:	f7fe ff8c 	bl	8003e9c <HAL_RCC_GetSysClockFreq>
 8004f84:	0003      	movs	r3, r0
 8004f86:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004f88:	e00d      	b.n	8004fa6 <UART_SetConfig+0x412>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 8004f8a:	2380      	movs	r3, #128	; 0x80
 8004f8c:	021b      	lsls	r3, r3, #8
 8004f8e:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004f90:	e009      	b.n	8004fa6 <UART_SetConfig+0x412>
      default:
        pclk = 0U;
 8004f92:	2300      	movs	r3, #0
 8004f94:	62fb      	str	r3, [r7, #44]	; 0x2c
        ret = HAL_ERROR;
 8004f96:	231a      	movs	r3, #26
 8004f98:	2218      	movs	r2, #24
 8004f9a:	4694      	mov	ip, r2
 8004f9c:	44bc      	add	ip, r7
 8004f9e:	4463      	add	r3, ip
 8004fa0:	2201      	movs	r2, #1
 8004fa2:	701a      	strb	r2, [r3, #0]
        break;
 8004fa4:	46c0      	nop			; (mov r8, r8)
    }

    /* USARTDIV must be greater than or equal to 0d16 */
    if (pclk != 0U)
 8004fa6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004fa8:	2b00      	cmp	r3, #0
 8004faa:	d100      	bne.n	8004fae <UART_SetConfig+0x41a>
 8004fac:	e095      	b.n	80050da <UART_SetConfig+0x546>
    {
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate));
 8004fae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004fb0:	005a      	lsls	r2, r3, #1
 8004fb2:	69fb      	ldr	r3, [r7, #28]
 8004fb4:	685b      	ldr	r3, [r3, #4]
 8004fb6:	085b      	lsrs	r3, r3, #1
 8004fb8:	18d2      	adds	r2, r2, r3
 8004fba:	69fb      	ldr	r3, [r7, #28]
 8004fbc:	685b      	ldr	r3, [r3, #4]
 8004fbe:	0019      	movs	r1, r3
 8004fc0:	0010      	movs	r0, r2
 8004fc2:	f7fb f8b3 	bl	800012c <__udivsi3>
 8004fc6:	0003      	movs	r3, r0
 8004fc8:	b29b      	uxth	r3, r3
 8004fca:	62bb      	str	r3, [r7, #40]	; 0x28
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8004fcc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004fce:	2b0f      	cmp	r3, #15
 8004fd0:	d921      	bls.n	8005016 <UART_SetConfig+0x482>
 8004fd2:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8004fd4:	2380      	movs	r3, #128	; 0x80
 8004fd6:	025b      	lsls	r3, r3, #9
 8004fd8:	429a      	cmp	r2, r3
 8004fda:	d21c      	bcs.n	8005016 <UART_SetConfig+0x482>
      {
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 8004fdc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004fde:	b29a      	uxth	r2, r3
 8004fe0:	200e      	movs	r0, #14
 8004fe2:	2418      	movs	r4, #24
 8004fe4:	193b      	adds	r3, r7, r4
 8004fe6:	181b      	adds	r3, r3, r0
 8004fe8:	210f      	movs	r1, #15
 8004fea:	438a      	bics	r2, r1
 8004fec:	801a      	strh	r2, [r3, #0]
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8004fee:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004ff0:	085b      	lsrs	r3, r3, #1
 8004ff2:	b29b      	uxth	r3, r3
 8004ff4:	2207      	movs	r2, #7
 8004ff6:	4013      	ands	r3, r2
 8004ff8:	b299      	uxth	r1, r3
 8004ffa:	193b      	adds	r3, r7, r4
 8004ffc:	181b      	adds	r3, r3, r0
 8004ffe:	193a      	adds	r2, r7, r4
 8005000:	1812      	adds	r2, r2, r0
 8005002:	8812      	ldrh	r2, [r2, #0]
 8005004:	430a      	orrs	r2, r1
 8005006:	801a      	strh	r2, [r3, #0]
        huart->Instance->BRR = brrtemp;
 8005008:	69fb      	ldr	r3, [r7, #28]
 800500a:	681b      	ldr	r3, [r3, #0]
 800500c:	193a      	adds	r2, r7, r4
 800500e:	1812      	adds	r2, r2, r0
 8005010:	8812      	ldrh	r2, [r2, #0]
 8005012:	60da      	str	r2, [r3, #12]
 8005014:	e061      	b.n	80050da <UART_SetConfig+0x546>
      }
      else
      {
        ret = HAL_ERROR;
 8005016:	231a      	movs	r3, #26
 8005018:	2218      	movs	r2, #24
 800501a:	4694      	mov	ip, r2
 800501c:	44bc      	add	ip, r7
 800501e:	4463      	add	r3, ip
 8005020:	2201      	movs	r2, #1
 8005022:	701a      	strb	r2, [r3, #0]
 8005024:	e059      	b.n	80050da <UART_SetConfig+0x546>
      }
    }
  }
  else
  {
    switch (clocksource)
 8005026:	231b      	movs	r3, #27
 8005028:	2218      	movs	r2, #24
 800502a:	4694      	mov	ip, r2
 800502c:	44bc      	add	ip, r7
 800502e:	4463      	add	r3, ip
 8005030:	781b      	ldrb	r3, [r3, #0]
 8005032:	2b08      	cmp	r3, #8
 8005034:	d822      	bhi.n	800507c <UART_SetConfig+0x4e8>
 8005036:	009a      	lsls	r2, r3, #2
 8005038:	4b34      	ldr	r3, [pc, #208]	; (800510c <UART_SetConfig+0x578>)
 800503a:	18d3      	adds	r3, r2, r3
 800503c:	681b      	ldr	r3, [r3, #0]
 800503e:	469f      	mov	pc, r3
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 8005040:	f7fe ffdc 	bl	8003ffc <HAL_RCC_GetPCLK1Freq>
 8005044:	0003      	movs	r3, r0
 8005046:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8005048:	e022      	b.n	8005090 <UART_SetConfig+0x4fc>
      case UART_CLOCKSOURCE_PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
 800504a:	f7fe ffed 	bl	8004028 <HAL_RCC_GetPCLK2Freq>
 800504e:	0003      	movs	r3, r0
 8005050:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8005052:	e01d      	b.n	8005090 <UART_SetConfig+0x4fc>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8005054:	4b2a      	ldr	r3, [pc, #168]	; (8005100 <UART_SetConfig+0x56c>)
 8005056:	681b      	ldr	r3, [r3, #0]
 8005058:	2210      	movs	r2, #16
 800505a:	4013      	ands	r3, r2
 800505c:	d002      	beq.n	8005064 <UART_SetConfig+0x4d0>
        {
          pclk = (uint32_t)(HSI_VALUE >> 2U);
 800505e:	4b29      	ldr	r3, [pc, #164]	; (8005104 <UART_SetConfig+0x570>)
 8005060:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
 8005062:	e015      	b.n	8005090 <UART_SetConfig+0x4fc>
          pclk = (uint32_t) HSI_VALUE;
 8005064:	4b28      	ldr	r3, [pc, #160]	; (8005108 <UART_SetConfig+0x574>)
 8005066:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8005068:	e012      	b.n	8005090 <UART_SetConfig+0x4fc>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
 800506a:	f7fe ff17 	bl	8003e9c <HAL_RCC_GetSysClockFreq>
 800506e:	0003      	movs	r3, r0
 8005070:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8005072:	e00d      	b.n	8005090 <UART_SetConfig+0x4fc>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 8005074:	2380      	movs	r3, #128	; 0x80
 8005076:	021b      	lsls	r3, r3, #8
 8005078:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800507a:	e009      	b.n	8005090 <UART_SetConfig+0x4fc>
      default:
        pclk = 0U;
 800507c:	2300      	movs	r3, #0
 800507e:	62fb      	str	r3, [r7, #44]	; 0x2c
        ret = HAL_ERROR;
 8005080:	231a      	movs	r3, #26
 8005082:	2218      	movs	r2, #24
 8005084:	4694      	mov	ip, r2
 8005086:	44bc      	add	ip, r7
 8005088:	4463      	add	r3, ip
 800508a:	2201      	movs	r2, #1
 800508c:	701a      	strb	r2, [r3, #0]
        break;
 800508e:	46c0      	nop			; (mov r8, r8)
    }

    if (pclk != 0U)
 8005090:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005092:	2b00      	cmp	r3, #0
 8005094:	d021      	beq.n	80050da <UART_SetConfig+0x546>
    {
      /* USARTDIV must be greater than or equal to 0d16 */
      usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate));
 8005096:	69fb      	ldr	r3, [r7, #28]
 8005098:	685b      	ldr	r3, [r3, #4]
 800509a:	085a      	lsrs	r2, r3, #1
 800509c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800509e:	18d2      	adds	r2, r2, r3
 80050a0:	69fb      	ldr	r3, [r7, #28]
 80050a2:	685b      	ldr	r3, [r3, #4]
 80050a4:	0019      	movs	r1, r3
 80050a6:	0010      	movs	r0, r2
 80050a8:	f7fb f840 	bl	800012c <__udivsi3>
 80050ac:	0003      	movs	r3, r0
 80050ae:	b29b      	uxth	r3, r3
 80050b0:	62bb      	str	r3, [r7, #40]	; 0x28
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 80050b2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80050b4:	2b0f      	cmp	r3, #15
 80050b6:	d909      	bls.n	80050cc <UART_SetConfig+0x538>
 80050b8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80050ba:	2380      	movs	r3, #128	; 0x80
 80050bc:	025b      	lsls	r3, r3, #9
 80050be:	429a      	cmp	r2, r3
 80050c0:	d204      	bcs.n	80050cc <UART_SetConfig+0x538>
      {
        huart->Instance->BRR = usartdiv;
 80050c2:	69fb      	ldr	r3, [r7, #28]
 80050c4:	681b      	ldr	r3, [r3, #0]
 80050c6:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80050c8:	60da      	str	r2, [r3, #12]
 80050ca:	e006      	b.n	80050da <UART_SetConfig+0x546>
      }
      else
      {
        ret = HAL_ERROR;
 80050cc:	231a      	movs	r3, #26
 80050ce:	2218      	movs	r2, #24
 80050d0:	4694      	mov	ip, r2
 80050d2:	44bc      	add	ip, r7
 80050d4:	4463      	add	r3, ip
 80050d6:	2201      	movs	r2, #1
 80050d8:	701a      	strb	r2, [r3, #0]
    }
  }


  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 80050da:	69fb      	ldr	r3, [r7, #28]
 80050dc:	2200      	movs	r2, #0
 80050de:	665a      	str	r2, [r3, #100]	; 0x64
  huart->TxISR = NULL;
 80050e0:	69fb      	ldr	r3, [r7, #28]
 80050e2:	2200      	movs	r2, #0
 80050e4:	669a      	str	r2, [r3, #104]	; 0x68

  return ret;
 80050e6:	231a      	movs	r3, #26
 80050e8:	2218      	movs	r2, #24
 80050ea:	4694      	mov	ip, r2
 80050ec:	44bc      	add	ip, r7
 80050ee:	4463      	add	r3, ip
 80050f0:	781b      	ldrb	r3, [r3, #0]
}
 80050f2:	0018      	movs	r0, r3
 80050f4:	46bd      	mov	sp, r7
 80050f6:	b00e      	add	sp, #56	; 0x38
 80050f8:	bdb0      	pop	{r4, r5, r7, pc}
 80050fa:	46c0      	nop			; (mov r8, r8)
 80050fc:	08022764 	.word	0x08022764
 8005100:	40021000 	.word	0x40021000
 8005104:	003d0900 	.word	0x003d0900
 8005108:	00f42400 	.word	0x00f42400
 800510c:	08022788 	.word	0x08022788

08005110 <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
 8005110:	b580      	push	{r7, lr}
 8005112:	b082      	sub	sp, #8
 8005114:	af00      	add	r7, sp, #0
 8005116:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8005118:	687b      	ldr	r3, [r7, #4]
 800511a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800511c:	2201      	movs	r2, #1
 800511e:	4013      	ands	r3, r2
 8005120:	d00b      	beq.n	800513a <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 8005122:	687b      	ldr	r3, [r7, #4]
 8005124:	681b      	ldr	r3, [r3, #0]
 8005126:	685b      	ldr	r3, [r3, #4]
 8005128:	4a4a      	ldr	r2, [pc, #296]	; (8005254 <UART_AdvFeatureConfig+0x144>)
 800512a:	4013      	ands	r3, r2
 800512c:	0019      	movs	r1, r3
 800512e:	687b      	ldr	r3, [r7, #4]
 8005130:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8005132:	687b      	ldr	r3, [r7, #4]
 8005134:	681b      	ldr	r3, [r3, #0]
 8005136:	430a      	orrs	r2, r1
 8005138:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 800513a:	687b      	ldr	r3, [r7, #4]
 800513c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800513e:	2202      	movs	r2, #2
 8005140:	4013      	ands	r3, r2
 8005142:	d00b      	beq.n	800515c <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 8005144:	687b      	ldr	r3, [r7, #4]
 8005146:	681b      	ldr	r3, [r3, #0]
 8005148:	685b      	ldr	r3, [r3, #4]
 800514a:	4a43      	ldr	r2, [pc, #268]	; (8005258 <UART_AdvFeatureConfig+0x148>)
 800514c:	4013      	ands	r3, r2
 800514e:	0019      	movs	r1, r3
 8005150:	687b      	ldr	r3, [r7, #4]
 8005152:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005154:	687b      	ldr	r3, [r7, #4]
 8005156:	681b      	ldr	r3, [r3, #0]
 8005158:	430a      	orrs	r2, r1
 800515a:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 800515c:	687b      	ldr	r3, [r7, #4]
 800515e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8005160:	2204      	movs	r2, #4
 8005162:	4013      	ands	r3, r2
 8005164:	d00b      	beq.n	800517e <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 8005166:	687b      	ldr	r3, [r7, #4]
 8005168:	681b      	ldr	r3, [r3, #0]
 800516a:	685b      	ldr	r3, [r3, #4]
 800516c:	4a3b      	ldr	r2, [pc, #236]	; (800525c <UART_AdvFeatureConfig+0x14c>)
 800516e:	4013      	ands	r3, r2
 8005170:	0019      	movs	r1, r3
 8005172:	687b      	ldr	r3, [r7, #4]
 8005174:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8005176:	687b      	ldr	r3, [r7, #4]
 8005178:	681b      	ldr	r3, [r3, #0]
 800517a:	430a      	orrs	r2, r1
 800517c:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 800517e:	687b      	ldr	r3, [r7, #4]
 8005180:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8005182:	2208      	movs	r2, #8
 8005184:	4013      	ands	r3, r2
 8005186:	d00b      	beq.n	80051a0 <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 8005188:	687b      	ldr	r3, [r7, #4]
 800518a:	681b      	ldr	r3, [r3, #0]
 800518c:	685b      	ldr	r3, [r3, #4]
 800518e:	4a34      	ldr	r2, [pc, #208]	; (8005260 <UART_AdvFeatureConfig+0x150>)
 8005190:	4013      	ands	r3, r2
 8005192:	0019      	movs	r1, r3
 8005194:	687b      	ldr	r3, [r7, #4]
 8005196:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8005198:	687b      	ldr	r3, [r7, #4]
 800519a:	681b      	ldr	r3, [r3, #0]
 800519c:	430a      	orrs	r2, r1
 800519e:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 80051a0:	687b      	ldr	r3, [r7, #4]
 80051a2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80051a4:	2210      	movs	r2, #16
 80051a6:	4013      	ands	r3, r2
 80051a8:	d00b      	beq.n	80051c2 <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 80051aa:	687b      	ldr	r3, [r7, #4]
 80051ac:	681b      	ldr	r3, [r3, #0]
 80051ae:	689b      	ldr	r3, [r3, #8]
 80051b0:	4a2c      	ldr	r2, [pc, #176]	; (8005264 <UART_AdvFeatureConfig+0x154>)
 80051b2:	4013      	ands	r3, r2
 80051b4:	0019      	movs	r1, r3
 80051b6:	687b      	ldr	r3, [r7, #4]
 80051b8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80051ba:	687b      	ldr	r3, [r7, #4]
 80051bc:	681b      	ldr	r3, [r3, #0]
 80051be:	430a      	orrs	r2, r1
 80051c0:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 80051c2:	687b      	ldr	r3, [r7, #4]
 80051c4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80051c6:	2220      	movs	r2, #32
 80051c8:	4013      	ands	r3, r2
 80051ca:	d00b      	beq.n	80051e4 <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 80051cc:	687b      	ldr	r3, [r7, #4]
 80051ce:	681b      	ldr	r3, [r3, #0]
 80051d0:	689b      	ldr	r3, [r3, #8]
 80051d2:	4a25      	ldr	r2, [pc, #148]	; (8005268 <UART_AdvFeatureConfig+0x158>)
 80051d4:	4013      	ands	r3, r2
 80051d6:	0019      	movs	r1, r3
 80051d8:	687b      	ldr	r3, [r7, #4]
 80051da:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 80051dc:	687b      	ldr	r3, [r7, #4]
 80051de:	681b      	ldr	r3, [r3, #0]
 80051e0:	430a      	orrs	r2, r1
 80051e2:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 80051e4:	687b      	ldr	r3, [r7, #4]
 80051e6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80051e8:	2240      	movs	r2, #64	; 0x40
 80051ea:	4013      	ands	r3, r2
 80051ec:	d01d      	beq.n	800522a <UART_AdvFeatureConfig+0x11a>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 80051ee:	687b      	ldr	r3, [r7, #4]
 80051f0:	681b      	ldr	r3, [r3, #0]
 80051f2:	685b      	ldr	r3, [r3, #4]
 80051f4:	4a1d      	ldr	r2, [pc, #116]	; (800526c <UART_AdvFeatureConfig+0x15c>)
 80051f6:	4013      	ands	r3, r2
 80051f8:	0019      	movs	r1, r3
 80051fa:	687b      	ldr	r3, [r7, #4]
 80051fc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80051fe:	687b      	ldr	r3, [r7, #4]
 8005200:	681b      	ldr	r3, [r3, #0]
 8005202:	430a      	orrs	r2, r1
 8005204:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8005206:	687b      	ldr	r3, [r7, #4]
 8005208:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800520a:	2380      	movs	r3, #128	; 0x80
 800520c:	035b      	lsls	r3, r3, #13
 800520e:	429a      	cmp	r2, r3
 8005210:	d10b      	bne.n	800522a <UART_AdvFeatureConfig+0x11a>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 8005212:	687b      	ldr	r3, [r7, #4]
 8005214:	681b      	ldr	r3, [r3, #0]
 8005216:	685b      	ldr	r3, [r3, #4]
 8005218:	4a15      	ldr	r2, [pc, #84]	; (8005270 <UART_AdvFeatureConfig+0x160>)
 800521a:	4013      	ands	r3, r2
 800521c:	0019      	movs	r1, r3
 800521e:	687b      	ldr	r3, [r7, #4]
 8005220:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8005222:	687b      	ldr	r3, [r7, #4]
 8005224:	681b      	ldr	r3, [r3, #0]
 8005226:	430a      	orrs	r2, r1
 8005228:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 800522a:	687b      	ldr	r3, [r7, #4]
 800522c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800522e:	2280      	movs	r2, #128	; 0x80
 8005230:	4013      	ands	r3, r2
 8005232:	d00b      	beq.n	800524c <UART_AdvFeatureConfig+0x13c>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8005234:	687b      	ldr	r3, [r7, #4]
 8005236:	681b      	ldr	r3, [r3, #0]
 8005238:	685b      	ldr	r3, [r3, #4]
 800523a:	4a0e      	ldr	r2, [pc, #56]	; (8005274 <UART_AdvFeatureConfig+0x164>)
 800523c:	4013      	ands	r3, r2
 800523e:	0019      	movs	r1, r3
 8005240:	687b      	ldr	r3, [r7, #4]
 8005242:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8005244:	687b      	ldr	r3, [r7, #4]
 8005246:	681b      	ldr	r3, [r3, #0]
 8005248:	430a      	orrs	r2, r1
 800524a:	605a      	str	r2, [r3, #4]
  }
}
 800524c:	46c0      	nop			; (mov r8, r8)
 800524e:	46bd      	mov	sp, r7
 8005250:	b002      	add	sp, #8
 8005252:	bd80      	pop	{r7, pc}
 8005254:	fffdffff 	.word	0xfffdffff
 8005258:	fffeffff 	.word	0xfffeffff
 800525c:	fffbffff 	.word	0xfffbffff
 8005260:	ffff7fff 	.word	0xffff7fff
 8005264:	ffffefff 	.word	0xffffefff
 8005268:	ffffdfff 	.word	0xffffdfff
 800526c:	ffefffff 	.word	0xffefffff
 8005270:	ff9fffff 	.word	0xff9fffff
 8005274:	fff7ffff 	.word	0xfff7ffff

08005278 <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 8005278:	b580      	push	{r7, lr}
 800527a:	b086      	sub	sp, #24
 800527c:	af02      	add	r7, sp, #8
 800527e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8005280:	687b      	ldr	r3, [r7, #4]
 8005282:	2280      	movs	r2, #128	; 0x80
 8005284:	2100      	movs	r1, #0
 8005286:	5099      	str	r1, [r3, r2]

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
 8005288:	f7fd fe14 	bl	8002eb4 <HAL_GetTick>
 800528c:	0003      	movs	r3, r0
 800528e:	60fb      	str	r3, [r7, #12]

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8005290:	687b      	ldr	r3, [r7, #4]
 8005292:	681b      	ldr	r3, [r3, #0]
 8005294:	681b      	ldr	r3, [r3, #0]
 8005296:	2208      	movs	r2, #8
 8005298:	4013      	ands	r3, r2
 800529a:	2b08      	cmp	r3, #8
 800529c:	d10c      	bne.n	80052b8 <UART_CheckIdleState+0x40>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800529e:	68fb      	ldr	r3, [r7, #12]
 80052a0:	2280      	movs	r2, #128	; 0x80
 80052a2:	0391      	lsls	r1, r2, #14
 80052a4:	6878      	ldr	r0, [r7, #4]
 80052a6:	4a17      	ldr	r2, [pc, #92]	; (8005304 <UART_CheckIdleState+0x8c>)
 80052a8:	9200      	str	r2, [sp, #0]
 80052aa:	2200      	movs	r2, #0
 80052ac:	f000 f82c 	bl	8005308 <UART_WaitOnFlagUntilTimeout>
 80052b0:	1e03      	subs	r3, r0, #0
 80052b2:	d001      	beq.n	80052b8 <UART_CheckIdleState+0x40>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 80052b4:	2303      	movs	r3, #3
 80052b6:	e021      	b.n	80052fc <UART_CheckIdleState+0x84>
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 80052b8:	687b      	ldr	r3, [r7, #4]
 80052ba:	681b      	ldr	r3, [r3, #0]
 80052bc:	681b      	ldr	r3, [r3, #0]
 80052be:	2204      	movs	r2, #4
 80052c0:	4013      	ands	r3, r2
 80052c2:	2b04      	cmp	r3, #4
 80052c4:	d10c      	bne.n	80052e0 <UART_CheckIdleState+0x68>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 80052c6:	68fb      	ldr	r3, [r7, #12]
 80052c8:	2280      	movs	r2, #128	; 0x80
 80052ca:	03d1      	lsls	r1, r2, #15
 80052cc:	6878      	ldr	r0, [r7, #4]
 80052ce:	4a0d      	ldr	r2, [pc, #52]	; (8005304 <UART_CheckIdleState+0x8c>)
 80052d0:	9200      	str	r2, [sp, #0]
 80052d2:	2200      	movs	r2, #0
 80052d4:	f000 f818 	bl	8005308 <UART_WaitOnFlagUntilTimeout>
 80052d8:	1e03      	subs	r3, r0, #0
 80052da:	d001      	beq.n	80052e0 <UART_CheckIdleState+0x68>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 80052dc:	2303      	movs	r3, #3
 80052de:	e00d      	b.n	80052fc <UART_CheckIdleState+0x84>
    }
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
 80052e0:	687b      	ldr	r3, [r7, #4]
 80052e2:	2220      	movs	r2, #32
 80052e4:	679a      	str	r2, [r3, #120]	; 0x78
  huart->RxState = HAL_UART_STATE_READY;
 80052e6:	687b      	ldr	r3, [r7, #4]
 80052e8:	2220      	movs	r2, #32
 80052ea:	67da      	str	r2, [r3, #124]	; 0x7c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80052ec:	687b      	ldr	r3, [r7, #4]
 80052ee:	2200      	movs	r2, #0
 80052f0:	661a      	str	r2, [r3, #96]	; 0x60

  __HAL_UNLOCK(huart);
 80052f2:	687b      	ldr	r3, [r7, #4]
 80052f4:	2274      	movs	r2, #116	; 0x74
 80052f6:	2100      	movs	r1, #0
 80052f8:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 80052fa:	2300      	movs	r3, #0
}
 80052fc:	0018      	movs	r0, r3
 80052fe:	46bd      	mov	sp, r7
 8005300:	b004      	add	sp, #16
 8005302:	bd80      	pop	{r7, pc}
 8005304:	01ffffff 	.word	0x01ffffff

08005308 <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
 8005308:	b580      	push	{r7, lr}
 800530a:	b094      	sub	sp, #80	; 0x50
 800530c:	af00      	add	r7, sp, #0
 800530e:	60f8      	str	r0, [r7, #12]
 8005310:	60b9      	str	r1, [r7, #8]
 8005312:	603b      	str	r3, [r7, #0]
 8005314:	1dfb      	adds	r3, r7, #7
 8005316:	701a      	strb	r2, [r3, #0]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8005318:	e0a3      	b.n	8005462 <UART_WaitOnFlagUntilTimeout+0x15a>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800531a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800531c:	3301      	adds	r3, #1
 800531e:	d100      	bne.n	8005322 <UART_WaitOnFlagUntilTimeout+0x1a>
 8005320:	e09f      	b.n	8005462 <UART_WaitOnFlagUntilTimeout+0x15a>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8005322:	f7fd fdc7 	bl	8002eb4 <HAL_GetTick>
 8005326:	0002      	movs	r2, r0
 8005328:	683b      	ldr	r3, [r7, #0]
 800532a:	1ad3      	subs	r3, r2, r3
 800532c:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800532e:	429a      	cmp	r2, r3
 8005330:	d302      	bcc.n	8005338 <UART_WaitOnFlagUntilTimeout+0x30>
 8005332:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8005334:	2b00      	cmp	r3, #0
 8005336:	d13d      	bne.n	80053b4 <UART_WaitOnFlagUntilTimeout+0xac>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8005338:	f3ef 8310 	mrs	r3, PRIMASK
 800533c:	62bb      	str	r3, [r7, #40]	; 0x28
  return(result);
 800533e:	6abb      	ldr	r3, [r7, #40]	; 0x28
      {
        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error)
           interrupts for the interrupt process */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 8005340:	647b      	str	r3, [r7, #68]	; 0x44
 8005342:	2301      	movs	r3, #1
 8005344:	62fb      	str	r3, [r7, #44]	; 0x2c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005346:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005348:	f383 8810 	msr	PRIMASK, r3
}
 800534c:	46c0      	nop			; (mov r8, r8)
 800534e:	68fb      	ldr	r3, [r7, #12]
 8005350:	681b      	ldr	r3, [r3, #0]
 8005352:	681a      	ldr	r2, [r3, #0]
 8005354:	68fb      	ldr	r3, [r7, #12]
 8005356:	681b      	ldr	r3, [r3, #0]
 8005358:	494c      	ldr	r1, [pc, #304]	; (800548c <UART_WaitOnFlagUntilTimeout+0x184>)
 800535a:	400a      	ands	r2, r1
 800535c:	601a      	str	r2, [r3, #0]
 800535e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8005360:	633b      	str	r3, [r7, #48]	; 0x30
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005362:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005364:	f383 8810 	msr	PRIMASK, r3
}
 8005368:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800536a:	f3ef 8310 	mrs	r3, PRIMASK
 800536e:	637b      	str	r3, [r7, #52]	; 0x34
  return(result);
 8005370:	6b7b      	ldr	r3, [r7, #52]	; 0x34
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8005372:	643b      	str	r3, [r7, #64]	; 0x40
 8005374:	2301      	movs	r3, #1
 8005376:	63bb      	str	r3, [r7, #56]	; 0x38
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005378:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800537a:	f383 8810 	msr	PRIMASK, r3
}
 800537e:	46c0      	nop			; (mov r8, r8)
 8005380:	68fb      	ldr	r3, [r7, #12]
 8005382:	681b      	ldr	r3, [r3, #0]
 8005384:	689a      	ldr	r2, [r3, #8]
 8005386:	68fb      	ldr	r3, [r7, #12]
 8005388:	681b      	ldr	r3, [r3, #0]
 800538a:	2101      	movs	r1, #1
 800538c:	438a      	bics	r2, r1
 800538e:	609a      	str	r2, [r3, #8]
 8005390:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005392:	63fb      	str	r3, [r7, #60]	; 0x3c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005394:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8005396:	f383 8810 	msr	PRIMASK, r3
}
 800539a:	46c0      	nop			; (mov r8, r8)

        huart->gState = HAL_UART_STATE_READY;
 800539c:	68fb      	ldr	r3, [r7, #12]
 800539e:	2220      	movs	r2, #32
 80053a0:	679a      	str	r2, [r3, #120]	; 0x78
        huart->RxState = HAL_UART_STATE_READY;
 80053a2:	68fb      	ldr	r3, [r7, #12]
 80053a4:	2220      	movs	r2, #32
 80053a6:	67da      	str	r2, [r3, #124]	; 0x7c

        __HAL_UNLOCK(huart);
 80053a8:	68fb      	ldr	r3, [r7, #12]
 80053aa:	2274      	movs	r2, #116	; 0x74
 80053ac:	2100      	movs	r1, #0
 80053ae:	5499      	strb	r1, [r3, r2]

        return HAL_TIMEOUT;
 80053b0:	2303      	movs	r3, #3
 80053b2:	e067      	b.n	8005484 <UART_WaitOnFlagUntilTimeout+0x17c>
      }

      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 80053b4:	68fb      	ldr	r3, [r7, #12]
 80053b6:	681b      	ldr	r3, [r3, #0]
 80053b8:	681b      	ldr	r3, [r3, #0]
 80053ba:	2204      	movs	r2, #4
 80053bc:	4013      	ands	r3, r2
 80053be:	d050      	beq.n	8005462 <UART_WaitOnFlagUntilTimeout+0x15a>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 80053c0:	68fb      	ldr	r3, [r7, #12]
 80053c2:	681b      	ldr	r3, [r3, #0]
 80053c4:	69da      	ldr	r2, [r3, #28]
 80053c6:	2380      	movs	r3, #128	; 0x80
 80053c8:	011b      	lsls	r3, r3, #4
 80053ca:	401a      	ands	r2, r3
 80053cc:	2380      	movs	r3, #128	; 0x80
 80053ce:	011b      	lsls	r3, r3, #4
 80053d0:	429a      	cmp	r2, r3
 80053d2:	d146      	bne.n	8005462 <UART_WaitOnFlagUntilTimeout+0x15a>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 80053d4:	68fb      	ldr	r3, [r7, #12]
 80053d6:	681b      	ldr	r3, [r3, #0]
 80053d8:	2280      	movs	r2, #128	; 0x80
 80053da:	0112      	lsls	r2, r2, #4
 80053dc:	621a      	str	r2, [r3, #32]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80053de:	f3ef 8310 	mrs	r3, PRIMASK
 80053e2:	613b      	str	r3, [r7, #16]
  return(result);
 80053e4:	693b      	ldr	r3, [r7, #16]

          /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error)
             interrupts for the interrupt process */
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 80053e6:	64fb      	str	r3, [r7, #76]	; 0x4c
 80053e8:	2301      	movs	r3, #1
 80053ea:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80053ec:	697b      	ldr	r3, [r7, #20]
 80053ee:	f383 8810 	msr	PRIMASK, r3
}
 80053f2:	46c0      	nop			; (mov r8, r8)
 80053f4:	68fb      	ldr	r3, [r7, #12]
 80053f6:	681b      	ldr	r3, [r3, #0]
 80053f8:	681a      	ldr	r2, [r3, #0]
 80053fa:	68fb      	ldr	r3, [r7, #12]
 80053fc:	681b      	ldr	r3, [r3, #0]
 80053fe:	4923      	ldr	r1, [pc, #140]	; (800548c <UART_WaitOnFlagUntilTimeout+0x184>)
 8005400:	400a      	ands	r2, r1
 8005402:	601a      	str	r2, [r3, #0]
 8005404:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005406:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005408:	69bb      	ldr	r3, [r7, #24]
 800540a:	f383 8810 	msr	PRIMASK, r3
}
 800540e:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8005410:	f3ef 8310 	mrs	r3, PRIMASK
 8005414:	61fb      	str	r3, [r7, #28]
  return(result);
 8005416:	69fb      	ldr	r3, [r7, #28]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8005418:	64bb      	str	r3, [r7, #72]	; 0x48
 800541a:	2301      	movs	r3, #1
 800541c:	623b      	str	r3, [r7, #32]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800541e:	6a3b      	ldr	r3, [r7, #32]
 8005420:	f383 8810 	msr	PRIMASK, r3
}
 8005424:	46c0      	nop			; (mov r8, r8)
 8005426:	68fb      	ldr	r3, [r7, #12]
 8005428:	681b      	ldr	r3, [r3, #0]
 800542a:	689a      	ldr	r2, [r3, #8]
 800542c:	68fb      	ldr	r3, [r7, #12]
 800542e:	681b      	ldr	r3, [r3, #0]
 8005430:	2101      	movs	r1, #1
 8005432:	438a      	bics	r2, r1
 8005434:	609a      	str	r2, [r3, #8]
 8005436:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8005438:	627b      	str	r3, [r7, #36]	; 0x24
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800543a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800543c:	f383 8810 	msr	PRIMASK, r3
}
 8005440:	46c0      	nop			; (mov r8, r8)

          huart->gState = HAL_UART_STATE_READY;
 8005442:	68fb      	ldr	r3, [r7, #12]
 8005444:	2220      	movs	r2, #32
 8005446:	679a      	str	r2, [r3, #120]	; 0x78
          huart->RxState = HAL_UART_STATE_READY;
 8005448:	68fb      	ldr	r3, [r7, #12]
 800544a:	2220      	movs	r2, #32
 800544c:	67da      	str	r2, [r3, #124]	; 0x7c
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 800544e:	68fb      	ldr	r3, [r7, #12]
 8005450:	2280      	movs	r2, #128	; 0x80
 8005452:	2120      	movs	r1, #32
 8005454:	5099      	str	r1, [r3, r2]

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 8005456:	68fb      	ldr	r3, [r7, #12]
 8005458:	2274      	movs	r2, #116	; 0x74
 800545a:	2100      	movs	r1, #0
 800545c:	5499      	strb	r1, [r3, r2]

          return HAL_TIMEOUT;
 800545e:	2303      	movs	r3, #3
 8005460:	e010      	b.n	8005484 <UART_WaitOnFlagUntilTimeout+0x17c>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8005462:	68fb      	ldr	r3, [r7, #12]
 8005464:	681b      	ldr	r3, [r3, #0]
 8005466:	69db      	ldr	r3, [r3, #28]
 8005468:	68ba      	ldr	r2, [r7, #8]
 800546a:	4013      	ands	r3, r2
 800546c:	68ba      	ldr	r2, [r7, #8]
 800546e:	1ad3      	subs	r3, r2, r3
 8005470:	425a      	negs	r2, r3
 8005472:	4153      	adcs	r3, r2
 8005474:	b2db      	uxtb	r3, r3
 8005476:	001a      	movs	r2, r3
 8005478:	1dfb      	adds	r3, r7, #7
 800547a:	781b      	ldrb	r3, [r3, #0]
 800547c:	429a      	cmp	r2, r3
 800547e:	d100      	bne.n	8005482 <UART_WaitOnFlagUntilTimeout+0x17a>
 8005480:	e74b      	b.n	800531a <UART_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
 8005482:	2300      	movs	r3, #0
}
 8005484:	0018      	movs	r0, r3
 8005486:	46bd      	mov	sp, r7
 8005488:	b014      	add	sp, #80	; 0x50
 800548a:	bd80      	pop	{r7, pc}
 800548c:	fffffe5f 	.word	0xfffffe5f

08005490 <UART_Start_Receive_IT>:
  * @param  pData Pointer to data buffer (u8 or u16 data elements).
  * @param  Size  Amount of data elements (u8 or u16) to be received.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_Start_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 8005490:	b580      	push	{r7, lr}
 8005492:	b08c      	sub	sp, #48	; 0x30
 8005494:	af00      	add	r7, sp, #0
 8005496:	60f8      	str	r0, [r7, #12]
 8005498:	60b9      	str	r1, [r7, #8]
 800549a:	1dbb      	adds	r3, r7, #6
 800549c:	801a      	strh	r2, [r3, #0]
  huart->pRxBuffPtr  = pData;
 800549e:	68fb      	ldr	r3, [r7, #12]
 80054a0:	68ba      	ldr	r2, [r7, #8]
 80054a2:	655a      	str	r2, [r3, #84]	; 0x54
  huart->RxXferSize  = Size;
 80054a4:	68fb      	ldr	r3, [r7, #12]
 80054a6:	1dba      	adds	r2, r7, #6
 80054a8:	2158      	movs	r1, #88	; 0x58
 80054aa:	8812      	ldrh	r2, [r2, #0]
 80054ac:	525a      	strh	r2, [r3, r1]
  huart->RxXferCount = Size;
 80054ae:	68fb      	ldr	r3, [r7, #12]
 80054b0:	1dba      	adds	r2, r7, #6
 80054b2:	215a      	movs	r1, #90	; 0x5a
 80054b4:	8812      	ldrh	r2, [r2, #0]
 80054b6:	525a      	strh	r2, [r3, r1]
  huart->RxISR       = NULL;
 80054b8:	68fb      	ldr	r3, [r7, #12]
 80054ba:	2200      	movs	r2, #0
 80054bc:	665a      	str	r2, [r3, #100]	; 0x64

  /* Computation of UART mask to apply to RDR register */
  UART_MASK_COMPUTATION(huart);
 80054be:	68fb      	ldr	r3, [r7, #12]
 80054c0:	689a      	ldr	r2, [r3, #8]
 80054c2:	2380      	movs	r3, #128	; 0x80
 80054c4:	015b      	lsls	r3, r3, #5
 80054c6:	429a      	cmp	r2, r3
 80054c8:	d10d      	bne.n	80054e6 <UART_Start_Receive_IT+0x56>
 80054ca:	68fb      	ldr	r3, [r7, #12]
 80054cc:	691b      	ldr	r3, [r3, #16]
 80054ce:	2b00      	cmp	r3, #0
 80054d0:	d104      	bne.n	80054dc <UART_Start_Receive_IT+0x4c>
 80054d2:	68fb      	ldr	r3, [r7, #12]
 80054d4:	225c      	movs	r2, #92	; 0x5c
 80054d6:	4943      	ldr	r1, [pc, #268]	; (80055e4 <UART_Start_Receive_IT+0x154>)
 80054d8:	5299      	strh	r1, [r3, r2]
 80054da:	e02e      	b.n	800553a <UART_Start_Receive_IT+0xaa>
 80054dc:	68fb      	ldr	r3, [r7, #12]
 80054de:	225c      	movs	r2, #92	; 0x5c
 80054e0:	21ff      	movs	r1, #255	; 0xff
 80054e2:	5299      	strh	r1, [r3, r2]
 80054e4:	e029      	b.n	800553a <UART_Start_Receive_IT+0xaa>
 80054e6:	68fb      	ldr	r3, [r7, #12]
 80054e8:	689b      	ldr	r3, [r3, #8]
 80054ea:	2b00      	cmp	r3, #0
 80054ec:	d10d      	bne.n	800550a <UART_Start_Receive_IT+0x7a>
 80054ee:	68fb      	ldr	r3, [r7, #12]
 80054f0:	691b      	ldr	r3, [r3, #16]
 80054f2:	2b00      	cmp	r3, #0
 80054f4:	d104      	bne.n	8005500 <UART_Start_Receive_IT+0x70>
 80054f6:	68fb      	ldr	r3, [r7, #12]
 80054f8:	225c      	movs	r2, #92	; 0x5c
 80054fa:	21ff      	movs	r1, #255	; 0xff
 80054fc:	5299      	strh	r1, [r3, r2]
 80054fe:	e01c      	b.n	800553a <UART_Start_Receive_IT+0xaa>
 8005500:	68fb      	ldr	r3, [r7, #12]
 8005502:	225c      	movs	r2, #92	; 0x5c
 8005504:	217f      	movs	r1, #127	; 0x7f
 8005506:	5299      	strh	r1, [r3, r2]
 8005508:	e017      	b.n	800553a <UART_Start_Receive_IT+0xaa>
 800550a:	68fb      	ldr	r3, [r7, #12]
 800550c:	689a      	ldr	r2, [r3, #8]
 800550e:	2380      	movs	r3, #128	; 0x80
 8005510:	055b      	lsls	r3, r3, #21
 8005512:	429a      	cmp	r2, r3
 8005514:	d10d      	bne.n	8005532 <UART_Start_Receive_IT+0xa2>
 8005516:	68fb      	ldr	r3, [r7, #12]
 8005518:	691b      	ldr	r3, [r3, #16]
 800551a:	2b00      	cmp	r3, #0
 800551c:	d104      	bne.n	8005528 <UART_Start_Receive_IT+0x98>
 800551e:	68fb      	ldr	r3, [r7, #12]
 8005520:	225c      	movs	r2, #92	; 0x5c
 8005522:	217f      	movs	r1, #127	; 0x7f
 8005524:	5299      	strh	r1, [r3, r2]
 8005526:	e008      	b.n	800553a <UART_Start_Receive_IT+0xaa>
 8005528:	68fb      	ldr	r3, [r7, #12]
 800552a:	225c      	movs	r2, #92	; 0x5c
 800552c:	213f      	movs	r1, #63	; 0x3f
 800552e:	5299      	strh	r1, [r3, r2]
 8005530:	e003      	b.n	800553a <UART_Start_Receive_IT+0xaa>
 8005532:	68fb      	ldr	r3, [r7, #12]
 8005534:	225c      	movs	r2, #92	; 0x5c
 8005536:	2100      	movs	r1, #0
 8005538:	5299      	strh	r1, [r3, r2]

  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800553a:	68fb      	ldr	r3, [r7, #12]
 800553c:	2280      	movs	r2, #128	; 0x80
 800553e:	2100      	movs	r1, #0
 8005540:	5099      	str	r1, [r3, r2]
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 8005542:	68fb      	ldr	r3, [r7, #12]
 8005544:	2222      	movs	r2, #34	; 0x22
 8005546:	67da      	str	r2, [r3, #124]	; 0x7c
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8005548:	f3ef 8310 	mrs	r3, PRIMASK
 800554c:	61fb      	str	r3, [r7, #28]
  return(result);
 800554e:	69fb      	ldr	r3, [r7, #28]

  /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8005550:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005552:	2301      	movs	r3, #1
 8005554:	623b      	str	r3, [r7, #32]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005556:	6a3b      	ldr	r3, [r7, #32]
 8005558:	f383 8810 	msr	PRIMASK, r3
}
 800555c:	46c0      	nop			; (mov r8, r8)
 800555e:	68fb      	ldr	r3, [r7, #12]
 8005560:	681b      	ldr	r3, [r3, #0]
 8005562:	689a      	ldr	r2, [r3, #8]
 8005564:	68fb      	ldr	r3, [r7, #12]
 8005566:	681b      	ldr	r3, [r3, #0]
 8005568:	2101      	movs	r1, #1
 800556a:	430a      	orrs	r2, r1
 800556c:	609a      	str	r2, [r3, #8]
 800556e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005570:	627b      	str	r3, [r7, #36]	; 0x24
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005572:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005574:	f383 8810 	msr	PRIMASK, r3
}
 8005578:	46c0      	nop			; (mov r8, r8)

  /* Set the Rx ISR function pointer according to the data word length */
  if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800557a:	68fb      	ldr	r3, [r7, #12]
 800557c:	689a      	ldr	r2, [r3, #8]
 800557e:	2380      	movs	r3, #128	; 0x80
 8005580:	015b      	lsls	r3, r3, #5
 8005582:	429a      	cmp	r2, r3
 8005584:	d107      	bne.n	8005596 <UART_Start_Receive_IT+0x106>
 8005586:	68fb      	ldr	r3, [r7, #12]
 8005588:	691b      	ldr	r3, [r3, #16]
 800558a:	2b00      	cmp	r3, #0
 800558c:	d103      	bne.n	8005596 <UART_Start_Receive_IT+0x106>
  {
    huart->RxISR = UART_RxISR_16BIT;
 800558e:	68fb      	ldr	r3, [r7, #12]
 8005590:	4a15      	ldr	r2, [pc, #84]	; (80055e8 <UART_Start_Receive_IT+0x158>)
 8005592:	665a      	str	r2, [r3, #100]	; 0x64
 8005594:	e002      	b.n	800559c <UART_Start_Receive_IT+0x10c>
  }
  else
  {
    huart->RxISR = UART_RxISR_8BIT;
 8005596:	68fb      	ldr	r3, [r7, #12]
 8005598:	4a14      	ldr	r2, [pc, #80]	; (80055ec <UART_Start_Receive_IT+0x15c>)
 800559a:	665a      	str	r2, [r3, #100]	; 0x64
  }

  __HAL_UNLOCK(huart);
 800559c:	68fb      	ldr	r3, [r7, #12]
 800559e:	2274      	movs	r2, #116	; 0x74
 80055a0:	2100      	movs	r1, #0
 80055a2:	5499      	strb	r1, [r3, r2]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80055a4:	f3ef 8310 	mrs	r3, PRIMASK
 80055a8:	613b      	str	r3, [r7, #16]
  return(result);
 80055aa:	693b      	ldr	r3, [r7, #16]

  /* Enable the UART Parity Error interrupt and Data Register Not Empty interrupt */
  ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
 80055ac:	62bb      	str	r3, [r7, #40]	; 0x28
 80055ae:	2301      	movs	r3, #1
 80055b0:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80055b2:	697b      	ldr	r3, [r7, #20]
 80055b4:	f383 8810 	msr	PRIMASK, r3
}
 80055b8:	46c0      	nop			; (mov r8, r8)
 80055ba:	68fb      	ldr	r3, [r7, #12]
 80055bc:	681b      	ldr	r3, [r3, #0]
 80055be:	681a      	ldr	r2, [r3, #0]
 80055c0:	68fb      	ldr	r3, [r7, #12]
 80055c2:	681b      	ldr	r3, [r3, #0]
 80055c4:	2190      	movs	r1, #144	; 0x90
 80055c6:	0049      	lsls	r1, r1, #1
 80055c8:	430a      	orrs	r2, r1
 80055ca:	601a      	str	r2, [r3, #0]
 80055cc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80055ce:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80055d0:	69bb      	ldr	r3, [r7, #24]
 80055d2:	f383 8810 	msr	PRIMASK, r3
}
 80055d6:	46c0      	nop			; (mov r8, r8)
  return HAL_OK;
 80055d8:	2300      	movs	r3, #0
}
 80055da:	0018      	movs	r0, r3
 80055dc:	46bd      	mov	sp, r7
 80055de:	b00c      	add	sp, #48	; 0x30
 80055e0:	bd80      	pop	{r7, pc}
 80055e2:	46c0      	nop			; (mov r8, r8)
 80055e4:	000001ff 	.word	0x000001ff
 80055e8:	080058a1 	.word	0x080058a1
 80055ec:	08005739 	.word	0x08005739

080055f0 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 80055f0:	b580      	push	{r7, lr}
 80055f2:	b08e      	sub	sp, #56	; 0x38
 80055f4:	af00      	add	r7, sp, #0
 80055f6:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80055f8:	f3ef 8310 	mrs	r3, PRIMASK
 80055fc:	617b      	str	r3, [r7, #20]
  return(result);
 80055fe:	697b      	ldr	r3, [r7, #20]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8005600:	637b      	str	r3, [r7, #52]	; 0x34
 8005602:	2301      	movs	r3, #1
 8005604:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005606:	69bb      	ldr	r3, [r7, #24]
 8005608:	f383 8810 	msr	PRIMASK, r3
}
 800560c:	46c0      	nop			; (mov r8, r8)
 800560e:	687b      	ldr	r3, [r7, #4]
 8005610:	681b      	ldr	r3, [r3, #0]
 8005612:	681a      	ldr	r2, [r3, #0]
 8005614:	687b      	ldr	r3, [r7, #4]
 8005616:	681b      	ldr	r3, [r3, #0]
 8005618:	4925      	ldr	r1, [pc, #148]	; (80056b0 <UART_EndRxTransfer+0xc0>)
 800561a:	400a      	ands	r2, r1
 800561c:	601a      	str	r2, [r3, #0]
 800561e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8005620:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005622:	69fb      	ldr	r3, [r7, #28]
 8005624:	f383 8810 	msr	PRIMASK, r3
}
 8005628:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800562a:	f3ef 8310 	mrs	r3, PRIMASK
 800562e:	623b      	str	r3, [r7, #32]
  return(result);
 8005630:	6a3b      	ldr	r3, [r7, #32]
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8005632:	633b      	str	r3, [r7, #48]	; 0x30
 8005634:	2301      	movs	r3, #1
 8005636:	627b      	str	r3, [r7, #36]	; 0x24
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005638:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800563a:	f383 8810 	msr	PRIMASK, r3
}
 800563e:	46c0      	nop			; (mov r8, r8)
 8005640:	687b      	ldr	r3, [r7, #4]
 8005642:	681b      	ldr	r3, [r3, #0]
 8005644:	689a      	ldr	r2, [r3, #8]
 8005646:	687b      	ldr	r3, [r7, #4]
 8005648:	681b      	ldr	r3, [r3, #0]
 800564a:	2101      	movs	r1, #1
 800564c:	438a      	bics	r2, r1
 800564e:	609a      	str	r2, [r3, #8]
 8005650:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005652:	62bb      	str	r3, [r7, #40]	; 0x28
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005654:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005656:	f383 8810 	msr	PRIMASK, r3
}
 800565a:	46c0      	nop			; (mov r8, r8)

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800565c:	687b      	ldr	r3, [r7, #4]
 800565e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8005660:	2b01      	cmp	r3, #1
 8005662:	d118      	bne.n	8005696 <UART_EndRxTransfer+0xa6>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8005664:	f3ef 8310 	mrs	r3, PRIMASK
 8005668:	60bb      	str	r3, [r7, #8]
  return(result);
 800566a:	68bb      	ldr	r3, [r7, #8]
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800566c:	62fb      	str	r3, [r7, #44]	; 0x2c
 800566e:	2301      	movs	r3, #1
 8005670:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005672:	68fb      	ldr	r3, [r7, #12]
 8005674:	f383 8810 	msr	PRIMASK, r3
}
 8005678:	46c0      	nop			; (mov r8, r8)
 800567a:	687b      	ldr	r3, [r7, #4]
 800567c:	681b      	ldr	r3, [r3, #0]
 800567e:	681a      	ldr	r2, [r3, #0]
 8005680:	687b      	ldr	r3, [r7, #4]
 8005682:	681b      	ldr	r3, [r3, #0]
 8005684:	2110      	movs	r1, #16
 8005686:	438a      	bics	r2, r1
 8005688:	601a      	str	r2, [r3, #0]
 800568a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800568c:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800568e:	693b      	ldr	r3, [r7, #16]
 8005690:	f383 8810 	msr	PRIMASK, r3
}
 8005694:	46c0      	nop			; (mov r8, r8)
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 8005696:	687b      	ldr	r3, [r7, #4]
 8005698:	2220      	movs	r2, #32
 800569a:	67da      	str	r2, [r3, #124]	; 0x7c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800569c:	687b      	ldr	r3, [r7, #4]
 800569e:	2200      	movs	r2, #0
 80056a0:	661a      	str	r2, [r3, #96]	; 0x60

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 80056a2:	687b      	ldr	r3, [r7, #4]
 80056a4:	2200      	movs	r2, #0
 80056a6:	665a      	str	r2, [r3, #100]	; 0x64
}
 80056a8:	46c0      	nop			; (mov r8, r8)
 80056aa:	46bd      	mov	sp, r7
 80056ac:	b00e      	add	sp, #56	; 0x38
 80056ae:	bd80      	pop	{r7, pc}
 80056b0:	fffffedf 	.word	0xfffffedf

080056b4 <UART_DMAAbortOnError>:
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 80056b4:	b580      	push	{r7, lr}
 80056b6:	b084      	sub	sp, #16
 80056b8:	af00      	add	r7, sp, #0
 80056ba:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 80056bc:	687b      	ldr	r3, [r7, #4]
 80056be:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80056c0:	60fb      	str	r3, [r7, #12]
  huart->RxXferCount = 0U;
 80056c2:	68fb      	ldr	r3, [r7, #12]
 80056c4:	225a      	movs	r2, #90	; 0x5a
 80056c6:	2100      	movs	r1, #0
 80056c8:	5299      	strh	r1, [r3, r2]
  huart->TxXferCount = 0U;
 80056ca:	68fb      	ldr	r3, [r7, #12]
 80056cc:	2252      	movs	r2, #82	; 0x52
 80056ce:	2100      	movs	r1, #0
 80056d0:	5299      	strh	r1, [r3, r2]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 80056d2:	68fb      	ldr	r3, [r7, #12]
 80056d4:	0018      	movs	r0, r3
 80056d6:	f7ff fa49 	bl	8004b6c <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 80056da:	46c0      	nop			; (mov r8, r8)
 80056dc:	46bd      	mov	sp, r7
 80056de:	b004      	add	sp, #16
 80056e0:	bd80      	pop	{r7, pc}

080056e2 <UART_EndTransmit_IT>:
  * @param  huart pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
 80056e2:	b580      	push	{r7, lr}
 80056e4:	b086      	sub	sp, #24
 80056e6:	af00      	add	r7, sp, #0
 80056e8:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80056ea:	f3ef 8310 	mrs	r3, PRIMASK
 80056ee:	60bb      	str	r3, [r7, #8]
  return(result);
 80056f0:	68bb      	ldr	r3, [r7, #8]
  /* Disable the UART Transmit Complete Interrupt */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 80056f2:	617b      	str	r3, [r7, #20]
 80056f4:	2301      	movs	r3, #1
 80056f6:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80056f8:	68fb      	ldr	r3, [r7, #12]
 80056fa:	f383 8810 	msr	PRIMASK, r3
}
 80056fe:	46c0      	nop			; (mov r8, r8)
 8005700:	687b      	ldr	r3, [r7, #4]
 8005702:	681b      	ldr	r3, [r3, #0]
 8005704:	681a      	ldr	r2, [r3, #0]
 8005706:	687b      	ldr	r3, [r7, #4]
 8005708:	681b      	ldr	r3, [r3, #0]
 800570a:	2140      	movs	r1, #64	; 0x40
 800570c:	438a      	bics	r2, r1
 800570e:	601a      	str	r2, [r3, #0]
 8005710:	697b      	ldr	r3, [r7, #20]
 8005712:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005714:	693b      	ldr	r3, [r7, #16]
 8005716:	f383 8810 	msr	PRIMASK, r3
}
 800571a:	46c0      	nop			; (mov r8, r8)

  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 800571c:	687b      	ldr	r3, [r7, #4]
 800571e:	2220      	movs	r2, #32
 8005720:	679a      	str	r2, [r3, #120]	; 0x78

  /* Cleat TxISR function pointer */
  huart->TxISR = NULL;
 8005722:	687b      	ldr	r3, [r7, #4]
 8005724:	2200      	movs	r2, #0
 8005726:	669a      	str	r2, [r3, #104]	; 0x68
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx complete callback*/
  huart->TxCpltCallback(huart);
#else
  /*Call legacy weak Tx complete callback*/
  HAL_UART_TxCpltCallback(huart);
 8005728:	687b      	ldr	r3, [r7, #4]
 800572a:	0018      	movs	r0, r3
 800572c:	f7ff fa16 	bl	8004b5c <HAL_UART_TxCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 8005730:	46c0      	nop			; (mov r8, r8)
 8005732:	46bd      	mov	sp, r7
 8005734:	b006      	add	sp, #24
 8005736:	bd80      	pop	{r7, pc}

08005738 <UART_RxISR_8BIT>:
  * @brief RX interrupt handler for 7 or 8 bits data word length .
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_8BIT(UART_HandleTypeDef *huart)
{
 8005738:	b580      	push	{r7, lr}
 800573a:	b090      	sub	sp, #64	; 0x40
 800573c:	af00      	add	r7, sp, #0
 800573e:	6078      	str	r0, [r7, #4]
  uint16_t uhMask = huart->Mask;
 8005740:	203e      	movs	r0, #62	; 0x3e
 8005742:	183b      	adds	r3, r7, r0
 8005744:	687a      	ldr	r2, [r7, #4]
 8005746:	215c      	movs	r1, #92	; 0x5c
 8005748:	5a52      	ldrh	r2, [r2, r1]
 800574a:	801a      	strh	r2, [r3, #0]
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 800574c:	687b      	ldr	r3, [r7, #4]
 800574e:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8005750:	2b22      	cmp	r3, #34	; 0x22
 8005752:	d000      	beq.n	8005756 <UART_RxISR_8BIT+0x1e>
 8005754:	e095      	b.n	8005882 <UART_RxISR_8BIT+0x14a>
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8005756:	687b      	ldr	r3, [r7, #4]
 8005758:	681b      	ldr	r3, [r3, #0]
 800575a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800575c:	213c      	movs	r1, #60	; 0x3c
 800575e:	187b      	adds	r3, r7, r1
 8005760:	801a      	strh	r2, [r3, #0]
    *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 8005762:	187b      	adds	r3, r7, r1
 8005764:	881b      	ldrh	r3, [r3, #0]
 8005766:	b2da      	uxtb	r2, r3
 8005768:	183b      	adds	r3, r7, r0
 800576a:	881b      	ldrh	r3, [r3, #0]
 800576c:	b2d9      	uxtb	r1, r3
 800576e:	687b      	ldr	r3, [r7, #4]
 8005770:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8005772:	400a      	ands	r2, r1
 8005774:	b2d2      	uxtb	r2, r2
 8005776:	701a      	strb	r2, [r3, #0]
    huart->pRxBuffPtr++;
 8005778:	687b      	ldr	r3, [r7, #4]
 800577a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800577c:	1c5a      	adds	r2, r3, #1
 800577e:	687b      	ldr	r3, [r7, #4]
 8005780:	655a      	str	r2, [r3, #84]	; 0x54
    huart->RxXferCount--;
 8005782:	687b      	ldr	r3, [r7, #4]
 8005784:	225a      	movs	r2, #90	; 0x5a
 8005786:	5a9b      	ldrh	r3, [r3, r2]
 8005788:	b29b      	uxth	r3, r3
 800578a:	3b01      	subs	r3, #1
 800578c:	b299      	uxth	r1, r3
 800578e:	687b      	ldr	r3, [r7, #4]
 8005790:	225a      	movs	r2, #90	; 0x5a
 8005792:	5299      	strh	r1, [r3, r2]

    if (huart->RxXferCount == 0U)
 8005794:	687b      	ldr	r3, [r7, #4]
 8005796:	225a      	movs	r2, #90	; 0x5a
 8005798:	5a9b      	ldrh	r3, [r3, r2]
 800579a:	b29b      	uxth	r3, r3
 800579c:	2b00      	cmp	r3, #0
 800579e:	d178      	bne.n	8005892 <UART_RxISR_8BIT+0x15a>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80057a0:	f3ef 8310 	mrs	r3, PRIMASK
 80057a4:	61bb      	str	r3, [r7, #24]
  return(result);
 80057a6:	69bb      	ldr	r3, [r7, #24]
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupts */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 80057a8:	63bb      	str	r3, [r7, #56]	; 0x38
 80057aa:	2301      	movs	r3, #1
 80057ac:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80057ae:	69fb      	ldr	r3, [r7, #28]
 80057b0:	f383 8810 	msr	PRIMASK, r3
}
 80057b4:	46c0      	nop			; (mov r8, r8)
 80057b6:	687b      	ldr	r3, [r7, #4]
 80057b8:	681b      	ldr	r3, [r3, #0]
 80057ba:	681a      	ldr	r2, [r3, #0]
 80057bc:	687b      	ldr	r3, [r7, #4]
 80057be:	681b      	ldr	r3, [r3, #0]
 80057c0:	4936      	ldr	r1, [pc, #216]	; (800589c <UART_RxISR_8BIT+0x164>)
 80057c2:	400a      	ands	r2, r1
 80057c4:	601a      	str	r2, [r3, #0]
 80057c6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80057c8:	623b      	str	r3, [r7, #32]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80057ca:	6a3b      	ldr	r3, [r7, #32]
 80057cc:	f383 8810 	msr	PRIMASK, r3
}
 80057d0:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80057d2:	f3ef 8310 	mrs	r3, PRIMASK
 80057d6:	627b      	str	r3, [r7, #36]	; 0x24
  return(result);
 80057d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80057da:	637b      	str	r3, [r7, #52]	; 0x34
 80057dc:	2301      	movs	r3, #1
 80057de:	62bb      	str	r3, [r7, #40]	; 0x28
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80057e0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80057e2:	f383 8810 	msr	PRIMASK, r3
}
 80057e6:	46c0      	nop			; (mov r8, r8)
 80057e8:	687b      	ldr	r3, [r7, #4]
 80057ea:	681b      	ldr	r3, [r3, #0]
 80057ec:	689a      	ldr	r2, [r3, #8]
 80057ee:	687b      	ldr	r3, [r7, #4]
 80057f0:	681b      	ldr	r3, [r3, #0]
 80057f2:	2101      	movs	r1, #1
 80057f4:	438a      	bics	r2, r1
 80057f6:	609a      	str	r2, [r3, #8]
 80057f8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80057fa:	62fb      	str	r3, [r7, #44]	; 0x2c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80057fc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80057fe:	f383 8810 	msr	PRIMASK, r3
}
 8005802:	46c0      	nop			; (mov r8, r8)

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 8005804:	687b      	ldr	r3, [r7, #4]
 8005806:	2220      	movs	r2, #32
 8005808:	67da      	str	r2, [r3, #124]	; 0x7c

      /* Clear RxISR function pointer */
      huart->RxISR = NULL;
 800580a:	687b      	ldr	r3, [r7, #4]
 800580c:	2200      	movs	r2, #0
 800580e:	665a      	str	r2, [r3, #100]	; 0x64

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8005810:	687b      	ldr	r3, [r7, #4]
 8005812:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8005814:	2b01      	cmp	r3, #1
 8005816:	d12f      	bne.n	8005878 <UART_RxISR_8BIT+0x140>
      {
        /* Set reception type to Standard */
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8005818:	687b      	ldr	r3, [r7, #4]
 800581a:	2200      	movs	r2, #0
 800581c:	661a      	str	r2, [r3, #96]	; 0x60
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800581e:	f3ef 8310 	mrs	r3, PRIMASK
 8005822:	60fb      	str	r3, [r7, #12]
  return(result);
 8005824:	68fb      	ldr	r3, [r7, #12]

        /* Disable IDLE interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8005826:	633b      	str	r3, [r7, #48]	; 0x30
 8005828:	2301      	movs	r3, #1
 800582a:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800582c:	693b      	ldr	r3, [r7, #16]
 800582e:	f383 8810 	msr	PRIMASK, r3
}
 8005832:	46c0      	nop			; (mov r8, r8)
 8005834:	687b      	ldr	r3, [r7, #4]
 8005836:	681b      	ldr	r3, [r3, #0]
 8005838:	681a      	ldr	r2, [r3, #0]
 800583a:	687b      	ldr	r3, [r7, #4]
 800583c:	681b      	ldr	r3, [r3, #0]
 800583e:	2110      	movs	r1, #16
 8005840:	438a      	bics	r2, r1
 8005842:	601a      	str	r2, [r3, #0]
 8005844:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005846:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005848:	697b      	ldr	r3, [r7, #20]
 800584a:	f383 8810 	msr	PRIMASK, r3
}
 800584e:	46c0      	nop			; (mov r8, r8)

        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 8005850:	687b      	ldr	r3, [r7, #4]
 8005852:	681b      	ldr	r3, [r3, #0]
 8005854:	69db      	ldr	r3, [r3, #28]
 8005856:	2210      	movs	r2, #16
 8005858:	4013      	ands	r3, r2
 800585a:	2b10      	cmp	r3, #16
 800585c:	d103      	bne.n	8005866 <UART_RxISR_8BIT+0x12e>
        {
          /* Clear IDLE Flag */
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 800585e:	687b      	ldr	r3, [r7, #4]
 8005860:	681b      	ldr	r3, [r3, #0]
 8005862:	2210      	movs	r2, #16
 8005864:	621a      	str	r2, [r3, #32]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, huart->RxXferSize);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8005866:	687b      	ldr	r3, [r7, #4]
 8005868:	2258      	movs	r2, #88	; 0x58
 800586a:	5a9a      	ldrh	r2, [r3, r2]
 800586c:	687b      	ldr	r3, [r7, #4]
 800586e:	0011      	movs	r1, r2
 8005870:	0018      	movs	r0, r3
 8005872:	f7ff f983 	bl	8004b7c <HAL_UARTEx_RxEventCallback>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 8005876:	e00c      	b.n	8005892 <UART_RxISR_8BIT+0x15a>
        HAL_UART_RxCpltCallback(huart);
 8005878:	687b      	ldr	r3, [r7, #4]
 800587a:	0018      	movs	r0, r3
 800587c:	f7fa fe20 	bl	80004c0 <HAL_UART_RxCpltCallback>
}
 8005880:	e007      	b.n	8005892 <UART_RxISR_8BIT+0x15a>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8005882:	687b      	ldr	r3, [r7, #4]
 8005884:	681b      	ldr	r3, [r3, #0]
 8005886:	699a      	ldr	r2, [r3, #24]
 8005888:	687b      	ldr	r3, [r7, #4]
 800588a:	681b      	ldr	r3, [r3, #0]
 800588c:	2108      	movs	r1, #8
 800588e:	430a      	orrs	r2, r1
 8005890:	619a      	str	r2, [r3, #24]
}
 8005892:	46c0      	nop			; (mov r8, r8)
 8005894:	46bd      	mov	sp, r7
 8005896:	b010      	add	sp, #64	; 0x40
 8005898:	bd80      	pop	{r7, pc}
 800589a:	46c0      	nop			; (mov r8, r8)
 800589c:	fffffedf 	.word	0xfffffedf

080058a0 <UART_RxISR_16BIT>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_16BIT(UART_HandleTypeDef *huart)
{
 80058a0:	b580      	push	{r7, lr}
 80058a2:	b090      	sub	sp, #64	; 0x40
 80058a4:	af00      	add	r7, sp, #0
 80058a6:	6078      	str	r0, [r7, #4]
  uint16_t *tmp;
  uint16_t uhMask = huart->Mask;
 80058a8:	203e      	movs	r0, #62	; 0x3e
 80058aa:	183b      	adds	r3, r7, r0
 80058ac:	687a      	ldr	r2, [r7, #4]
 80058ae:	215c      	movs	r1, #92	; 0x5c
 80058b0:	5a52      	ldrh	r2, [r2, r1]
 80058b2:	801a      	strh	r2, [r3, #0]
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 80058b4:	687b      	ldr	r3, [r7, #4]
 80058b6:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80058b8:	2b22      	cmp	r3, #34	; 0x22
 80058ba:	d000      	beq.n	80058be <UART_RxISR_16BIT+0x1e>
 80058bc:	e095      	b.n	80059ea <UART_RxISR_16BIT+0x14a>
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 80058be:	687b      	ldr	r3, [r7, #4]
 80058c0:	681b      	ldr	r3, [r3, #0]
 80058c2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80058c4:	213c      	movs	r1, #60	; 0x3c
 80058c6:	187b      	adds	r3, r7, r1
 80058c8:	801a      	strh	r2, [r3, #0]
    tmp = (uint16_t *) huart->pRxBuffPtr ;
 80058ca:	687b      	ldr	r3, [r7, #4]
 80058cc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80058ce:	63bb      	str	r3, [r7, #56]	; 0x38
    *tmp = (uint16_t)(uhdata & uhMask);
 80058d0:	187b      	adds	r3, r7, r1
 80058d2:	183a      	adds	r2, r7, r0
 80058d4:	881b      	ldrh	r3, [r3, #0]
 80058d6:	8812      	ldrh	r2, [r2, #0]
 80058d8:	4013      	ands	r3, r2
 80058da:	b29a      	uxth	r2, r3
 80058dc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80058de:	801a      	strh	r2, [r3, #0]
    huart->pRxBuffPtr += 2U;
 80058e0:	687b      	ldr	r3, [r7, #4]
 80058e2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80058e4:	1c9a      	adds	r2, r3, #2
 80058e6:	687b      	ldr	r3, [r7, #4]
 80058e8:	655a      	str	r2, [r3, #84]	; 0x54
    huart->RxXferCount--;
 80058ea:	687b      	ldr	r3, [r7, #4]
 80058ec:	225a      	movs	r2, #90	; 0x5a
 80058ee:	5a9b      	ldrh	r3, [r3, r2]
 80058f0:	b29b      	uxth	r3, r3
 80058f2:	3b01      	subs	r3, #1
 80058f4:	b299      	uxth	r1, r3
 80058f6:	687b      	ldr	r3, [r7, #4]
 80058f8:	225a      	movs	r2, #90	; 0x5a
 80058fa:	5299      	strh	r1, [r3, r2]

    if (huart->RxXferCount == 0U)
 80058fc:	687b      	ldr	r3, [r7, #4]
 80058fe:	225a      	movs	r2, #90	; 0x5a
 8005900:	5a9b      	ldrh	r3, [r3, r2]
 8005902:	b29b      	uxth	r3, r3
 8005904:	2b00      	cmp	r3, #0
 8005906:	d178      	bne.n	80059fa <UART_RxISR_16BIT+0x15a>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8005908:	f3ef 8310 	mrs	r3, PRIMASK
 800590c:	617b      	str	r3, [r7, #20]
  return(result);
 800590e:	697b      	ldr	r3, [r7, #20]
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8005910:	637b      	str	r3, [r7, #52]	; 0x34
 8005912:	2301      	movs	r3, #1
 8005914:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005916:	69bb      	ldr	r3, [r7, #24]
 8005918:	f383 8810 	msr	PRIMASK, r3
}
 800591c:	46c0      	nop			; (mov r8, r8)
 800591e:	687b      	ldr	r3, [r7, #4]
 8005920:	681b      	ldr	r3, [r3, #0]
 8005922:	681a      	ldr	r2, [r3, #0]
 8005924:	687b      	ldr	r3, [r7, #4]
 8005926:	681b      	ldr	r3, [r3, #0]
 8005928:	4936      	ldr	r1, [pc, #216]	; (8005a04 <UART_RxISR_16BIT+0x164>)
 800592a:	400a      	ands	r2, r1
 800592c:	601a      	str	r2, [r3, #0]
 800592e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8005930:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005932:	69fb      	ldr	r3, [r7, #28]
 8005934:	f383 8810 	msr	PRIMASK, r3
}
 8005938:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800593a:	f3ef 8310 	mrs	r3, PRIMASK
 800593e:	623b      	str	r3, [r7, #32]
  return(result);
 8005940:	6a3b      	ldr	r3, [r7, #32]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8005942:	633b      	str	r3, [r7, #48]	; 0x30
 8005944:	2301      	movs	r3, #1
 8005946:	627b      	str	r3, [r7, #36]	; 0x24
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005948:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800594a:	f383 8810 	msr	PRIMASK, r3
}
 800594e:	46c0      	nop			; (mov r8, r8)
 8005950:	687b      	ldr	r3, [r7, #4]
 8005952:	681b      	ldr	r3, [r3, #0]
 8005954:	689a      	ldr	r2, [r3, #8]
 8005956:	687b      	ldr	r3, [r7, #4]
 8005958:	681b      	ldr	r3, [r3, #0]
 800595a:	2101      	movs	r1, #1
 800595c:	438a      	bics	r2, r1
 800595e:	609a      	str	r2, [r3, #8]
 8005960:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005962:	62bb      	str	r3, [r7, #40]	; 0x28
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005964:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005966:	f383 8810 	msr	PRIMASK, r3
}
 800596a:	46c0      	nop			; (mov r8, r8)

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 800596c:	687b      	ldr	r3, [r7, #4]
 800596e:	2220      	movs	r2, #32
 8005970:	67da      	str	r2, [r3, #124]	; 0x7c

      /* Clear RxISR function pointer */
      huart->RxISR = NULL;
 8005972:	687b      	ldr	r3, [r7, #4]
 8005974:	2200      	movs	r2, #0
 8005976:	665a      	str	r2, [r3, #100]	; 0x64

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8005978:	687b      	ldr	r3, [r7, #4]
 800597a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800597c:	2b01      	cmp	r3, #1
 800597e:	d12f      	bne.n	80059e0 <UART_RxISR_16BIT+0x140>
      {
        /* Set reception type to Standard */
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8005980:	687b      	ldr	r3, [r7, #4]
 8005982:	2200      	movs	r2, #0
 8005984:	661a      	str	r2, [r3, #96]	; 0x60
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8005986:	f3ef 8310 	mrs	r3, PRIMASK
 800598a:	60bb      	str	r3, [r7, #8]
  return(result);
 800598c:	68bb      	ldr	r3, [r7, #8]

        /* Disable IDLE interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800598e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005990:	2301      	movs	r3, #1
 8005992:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005994:	68fb      	ldr	r3, [r7, #12]
 8005996:	f383 8810 	msr	PRIMASK, r3
}
 800599a:	46c0      	nop			; (mov r8, r8)
 800599c:	687b      	ldr	r3, [r7, #4]
 800599e:	681b      	ldr	r3, [r3, #0]
 80059a0:	681a      	ldr	r2, [r3, #0]
 80059a2:	687b      	ldr	r3, [r7, #4]
 80059a4:	681b      	ldr	r3, [r3, #0]
 80059a6:	2110      	movs	r1, #16
 80059a8:	438a      	bics	r2, r1
 80059aa:	601a      	str	r2, [r3, #0]
 80059ac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80059ae:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80059b0:	693b      	ldr	r3, [r7, #16]
 80059b2:	f383 8810 	msr	PRIMASK, r3
}
 80059b6:	46c0      	nop			; (mov r8, r8)

        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 80059b8:	687b      	ldr	r3, [r7, #4]
 80059ba:	681b      	ldr	r3, [r3, #0]
 80059bc:	69db      	ldr	r3, [r3, #28]
 80059be:	2210      	movs	r2, #16
 80059c0:	4013      	ands	r3, r2
 80059c2:	2b10      	cmp	r3, #16
 80059c4:	d103      	bne.n	80059ce <UART_RxISR_16BIT+0x12e>
        {
          /* Clear IDLE Flag */
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 80059c6:	687b      	ldr	r3, [r7, #4]
 80059c8:	681b      	ldr	r3, [r3, #0]
 80059ca:	2210      	movs	r2, #16
 80059cc:	621a      	str	r2, [r3, #32]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, huart->RxXferSize);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 80059ce:	687b      	ldr	r3, [r7, #4]
 80059d0:	2258      	movs	r2, #88	; 0x58
 80059d2:	5a9a      	ldrh	r2, [r3, r2]
 80059d4:	687b      	ldr	r3, [r7, #4]
 80059d6:	0011      	movs	r1, r2
 80059d8:	0018      	movs	r0, r3
 80059da:	f7ff f8cf 	bl	8004b7c <HAL_UARTEx_RxEventCallback>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 80059de:	e00c      	b.n	80059fa <UART_RxISR_16BIT+0x15a>
        HAL_UART_RxCpltCallback(huart);
 80059e0:	687b      	ldr	r3, [r7, #4]
 80059e2:	0018      	movs	r0, r3
 80059e4:	f7fa fd6c 	bl	80004c0 <HAL_UART_RxCpltCallback>
}
 80059e8:	e007      	b.n	80059fa <UART_RxISR_16BIT+0x15a>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 80059ea:	687b      	ldr	r3, [r7, #4]
 80059ec:	681b      	ldr	r3, [r3, #0]
 80059ee:	699a      	ldr	r2, [r3, #24]
 80059f0:	687b      	ldr	r3, [r7, #4]
 80059f2:	681b      	ldr	r3, [r3, #0]
 80059f4:	2108      	movs	r1, #8
 80059f6:	430a      	orrs	r2, r1
 80059f8:	619a      	str	r2, [r3, #24]
}
 80059fa:	46c0      	nop			; (mov r8, r8)
 80059fc:	46bd      	mov	sp, r7
 80059fe:	b010      	add	sp, #64	; 0x40
 8005a00:	bd80      	pop	{r7, pc}
 8005a02:	46c0      	nop			; (mov r8, r8)
 8005a04:	fffffedf 	.word	0xfffffedf

08005a08 <HAL_UARTEx_WakeupCallback>:
  * @brief UART wakeup from Stop mode callback.
  * @param huart UART handle.
  * @retval None
  */
__weak void HAL_UARTEx_WakeupCallback(UART_HandleTypeDef *huart)
{
 8005a08:	b580      	push	{r7, lr}
 8005a0a:	b082      	sub	sp, #8
 8005a0c:	af00      	add	r7, sp, #0
 8005a0e:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_WakeupCallback can be implemented in the user file.
   */
}
 8005a10:	46c0      	nop			; (mov r8, r8)
 8005a12:	46bd      	mov	sp, r7
 8005a14:	b002      	add	sp, #8
 8005a16:	bd80      	pop	{r7, pc}

08005a18 <HTTP_Headers_Done_Callback>:
}
/**
 * @brief Header received done callback
 */
err_t HTTP_Headers_Done_Callback(httpc_state_t *connection, void *arg, struct pbuf *hdr, u16_t hdr_len, u32_t content_len)
{
 8005a18:	b580      	push	{r7, lr}
 8005a1a:	b084      	sub	sp, #16
 8005a1c:	af00      	add	r7, sp, #0
 8005a1e:	60f8      	str	r0, [r7, #12]
 8005a20:	60b9      	str	r1, [r7, #8]
 8005a22:	607a      	str	r2, [r7, #4]
 8005a24:	001a      	movs	r2, r3
 8005a26:	1cbb      	adds	r3, r7, #2
 8005a28:	801a      	strh	r2, [r3, #0]
    DEBUG_INFO("httpc_headers_callback, content length %d\r\n", content_len);
 8005a2a:	f017 f9f5 	bl	801ce18 <sys_get_tick_ms>
 8005a2e:	0001      	movs	r1, r0
 8005a30:	69bb      	ldr	r3, [r7, #24]
 8005a32:	4a0e      	ldr	r2, [pc, #56]	; (8005a6c <HTTP_Headers_Done_Callback+0x54>)
 8005a34:	480e      	ldr	r0, [pc, #56]	; (8005a70 <HTTP_Headers_Done_Callback+0x58>)
 8005a36:	f7fd f8c7 	bl	8002bc8 <app_debug_rtt_raw>
    //DEBUG_INFO("HTTP header %.*s\r\n", hdr->len, hdr->payload);

    if (content_len == 0xFFFFFFFF)
 8005a3a:	69bb      	ldr	r3, [r7, #24]
 8005a3c:	3301      	adds	r3, #1
 8005a3e:	d108      	bne.n	8005a52 <HTTP_Headers_Done_Callback+0x3a>
            Content length khÃ´ng há»£p lá», cÃ³ thá» cÃ³ nhá»¯ng lÃ­ do sau
            	- Trong header server tráº£ vá» khÃ´ng cÃ³ trÆ°á»ng "Content-Length"
            	- Server tráº£ vá» dáº¡ng stream data, dá»¯ liá»u káº¿t thÃºc khi server ÄÃ³ng káº¿t ná»i
            	- CÃ¡c lÃ­ do khÃ¡c
        */
        DEBUG_INFO("Invalid content length\r\n");
 8005a40:	f017 f9ea 	bl	801ce18 <sys_get_tick_ms>
 8005a44:	0001      	movs	r1, r0
 8005a46:	4a09      	ldr	r2, [pc, #36]	; (8005a6c <HTTP_Headers_Done_Callback+0x54>)
 8005a48:	4b0a      	ldr	r3, [pc, #40]	; (8005a74 <HTTP_Headers_Done_Callback+0x5c>)
 8005a4a:	0018      	movs	r0, r3
 8005a4c:	f7fd f8bc 	bl	8002bc8 <app_debug_rtt_raw>
 8005a50:	e007      	b.n	8005a62 <HTTP_Headers_Done_Callback+0x4a>
    }
    else
    {
        DEBUG_INFO("HTTP content length %u bytes\r\n", content_len);
 8005a52:	f017 f9e1 	bl	801ce18 <sys_get_tick_ms>
 8005a56:	0001      	movs	r1, r0
 8005a58:	69bb      	ldr	r3, [r7, #24]
 8005a5a:	4a04      	ldr	r2, [pc, #16]	; (8005a6c <HTTP_Headers_Done_Callback+0x54>)
 8005a5c:	4806      	ldr	r0, [pc, #24]	; (8005a78 <HTTP_Headers_Done_Callback+0x60>)
 8005a5e:	f7fd f8b3 	bl	8002bc8 <app_debug_rtt_raw>
    }

    return ERR_OK;
 8005a62:	2300      	movs	r3, #0
}
 8005a64:	0018      	movs	r0, r3
 8005a66:	46bd      	mov	sp, r7
 8005a68:	b004      	add	sp, #16
 8005a6a:	bd80      	pop	{r7, pc}
 8005a6c:	0801eabc 	.word	0x0801eabc
 8005a70:	0801eaf4 	.word	0x0801eaf4
 8005a74:	0801eb3c 	.word	0x0801eb3c
 8005a78:	0801eb70 	.word	0x0801eb70

08005a7c <HTTP_Result_Callback>:
/**
 * @brief Result transfer done callback
 */
static void HTTP_Result_Callback(void *arg, httpc_result_t httpc_result, u32_t rx_content_len, u32_t srv_res, err_t err)
{
 8005a7c:	b5b0      	push	{r4, r5, r7, lr}
 8005a7e:	b086      	sub	sp, #24
 8005a80:	af02      	add	r7, sp, #8
 8005a82:	60f8      	str	r0, [r7, #12]
 8005a84:	607a      	str	r2, [r7, #4]
 8005a86:	603b      	str	r3, [r7, #0]
 8005a88:	250b      	movs	r5, #11
 8005a8a:	197b      	adds	r3, r7, r5
 8005a8c:	1c0a      	adds	r2, r1, #0
 8005a8e:	701a      	strb	r2, [r3, #0]
    DEBUG_INFO("result: %d, content len: %d, status code: %d\r\n", httpc_result, rx_content_len, srv_res);
 8005a90:	f017 f9c2 	bl	801ce18 <sys_get_tick_ms>
 8005a94:	0004      	movs	r4, r0
 8005a96:	197b      	adds	r3, r7, r5
 8005a98:	7819      	ldrb	r1, [r3, #0]
 8005a9a:	4a1b      	ldr	r2, [pc, #108]	; (8005b08 <HTTP_Result_Callback+0x8c>)
 8005a9c:	481b      	ldr	r0, [pc, #108]	; (8005b0c <HTTP_Result_Callback+0x90>)
 8005a9e:	683b      	ldr	r3, [r7, #0]
 8005aa0:	9301      	str	r3, [sp, #4]
 8005aa2:	687b      	ldr	r3, [r7, #4]
 8005aa4:	9300      	str	r3, [sp, #0]
 8005aa6:	000b      	movs	r3, r1
 8005aa8:	0021      	movs	r1, r4
 8005aaa:	f7fd f88d 	bl	8002bc8 <app_debug_rtt_raw>
    switch (err)
 8005aae:	2320      	movs	r3, #32
 8005ab0:	18fb      	adds	r3, r7, r3
 8005ab2:	781b      	ldrb	r3, [r3, #0]
 8005ab4:	b25b      	sxtb	r3, r3
 8005ab6:	2b00      	cmp	r3, #0
 8005ab8:	d004      	beq.n	8005ac4 <HTTP_Result_Callback+0x48>
 8005aba:	db15      	blt.n	8005ae8 <HTTP_Result_Callback+0x6c>
 8005abc:	3b01      	subs	r3, #1
 8005abe:	2b08      	cmp	r3, #8
 8005ac0:	d812      	bhi.n	8005ae8 <HTTP_Result_Callback+0x6c>
 8005ac2:	e008      	b.n	8005ad6 <HTTP_Result_Callback+0x5a>
    {
        case HTTPC_RESULT_OK: /** File successfully received */
        {
            DEBUG_INFO("HTTPC_RESULT_OK\r\n");
 8005ac4:	f017 f9a8 	bl	801ce18 <sys_get_tick_ms>
 8005ac8:	0001      	movs	r1, r0
 8005aca:	4a0f      	ldr	r2, [pc, #60]	; (8005b08 <HTTP_Result_Callback+0x8c>)
 8005acc:	4b10      	ldr	r3, [pc, #64]	; (8005b10 <HTTP_Result_Callback+0x94>)
 8005ace:	0018      	movs	r0, r3
 8005ad0:	f7fd f87a 	bl	8002bc8 <app_debug_rtt_raw>
        }
            break;
 8005ad4:	e014      	b.n	8005b00 <HTTP_Result_Callback+0x84>
        case HTTPC_RESULT_ERR_MEM:         /** Local memory error */
                                           //break;
        case HTTPC_RESULT_LOCAL_ABORT:     /** Local abort */
                                           //break;
        case HTTPC_RESULT_ERR_CONTENT_LEN: /** Content length mismatch */
            DEBUG_ERROR("Error content length\r\n");
 8005ad6:	f017 f99f 	bl	801ce18 <sys_get_tick_ms>
 8005ada:	0001      	movs	r1, r0
 8005adc:	4a0a      	ldr	r2, [pc, #40]	; (8005b08 <HTTP_Result_Callback+0x8c>)
 8005ade:	4b0d      	ldr	r3, [pc, #52]	; (8005b14 <HTTP_Result_Callback+0x98>)
 8005ae0:	0018      	movs	r0, r3
 8005ae2:	f7fd f871 	bl	8002bc8 <app_debug_rtt_raw>
            break;
 8005ae6:	e00b      	b.n	8005b00 <HTTP_Result_Callback+0x84>

        default:
            DEBUG_INFO("httpc_result_callback error %d\r\n", err);
 8005ae8:	f017 f996 	bl	801ce18 <sys_get_tick_ms>
 8005aec:	0001      	movs	r1, r0
 8005aee:	2320      	movs	r3, #32
 8005af0:	18fb      	adds	r3, r7, r3
 8005af2:	781b      	ldrb	r3, [r3, #0]
 8005af4:	b25b      	sxtb	r3, r3
 8005af6:	4a04      	ldr	r2, [pc, #16]	; (8005b08 <HTTP_Result_Callback+0x8c>)
 8005af8:	4807      	ldr	r0, [pc, #28]	; (8005b18 <HTTP_Result_Callback+0x9c>)
 8005afa:	f7fd f865 	bl	8002bc8 <app_debug_rtt_raw>
            break;
 8005afe:	46c0      	nop			; (mov r8, r8)
    }
}
 8005b00:	46c0      	nop			; (mov r8, r8)
 8005b02:	46bd      	mov	sp, r7
 8005b04:	b004      	add	sp, #16
 8005b06:	bdb0      	pop	{r4, r5, r7, pc}
 8005b08:	0801eabc 	.word	0x0801eabc
 8005b0c:	0801eba8 	.word	0x0801eba8
 8005b10:	0801ebf0 	.word	0x0801ebf0
 8005b14:	0801ec1c 	.word	0x0801ec1c
 8005b18:	0801ec4c 	.word	0x0801ec4c

08005b1c <HTTP_File_Receive_Callback>:
 * @param pointer to PCB
 * @param pointer to incoming pbuf
 * @param state of incoming process
 */
static err_t HTTP_File_Receive_Callback(void *arg, struct tcp_pcb *tpcb, struct pbuf *data_recv, err_t err)
{
 8005b1c:	b590      	push	{r4, r7, lr}
 8005b1e:	b089      	sub	sp, #36	; 0x24
 8005b20:	af02      	add	r7, sp, #8
 8005b22:	60f8      	str	r0, [r7, #12]
 8005b24:	60b9      	str	r1, [r7, #8]
 8005b26:	607a      	str	r2, [r7, #4]
 8005b28:	001a      	movs	r2, r3
 8005b2a:	1cfb      	adds	r3, r7, #3
 8005b2c:	701a      	strb	r2, [r3, #0]
    // Náº¿u cÃ³ dá»¯ liá»u Äáº¿n, kiá»m tra buffer
    // Náº¿u buffer khÃ´ng há»£p lá» (NULL) thÃ¬ ÄÃ³ng káº¿t ná»i TCP
    if (data_recv)
 8005b2e:	687b      	ldr	r3, [r7, #4]
 8005b30:	2b00      	cmp	r3, #0
 8005b32:	d02c      	beq.n	8005b8e <HTTP_File_Receive_Callback+0x72>
    {
        struct pbuf *q;
        for (q = data_recv; q; q = q->next)
 8005b34:	687b      	ldr	r3, [r7, #4]
 8005b36:	617b      	str	r3, [r7, #20]
 8005b38:	e019      	b.n	8005b6e <HTTP_File_Receive_Callback+0x52>
        {
            // ÄÃ¢y lÃ  dá»¯ liá»u nháº­n vá», cÃ³ Äá» dÃ i báº±ng q->len, vÃ  data lÃ  q->payload
            DEBUG_INFO("HTTP data length %u\r\n", q->len);
 8005b3a:	f017 f96d 	bl	801ce18 <sys_get_tick_ms>
 8005b3e:	0001      	movs	r1, r0
 8005b40:	697b      	ldr	r3, [r7, #20]
 8005b42:	895b      	ldrh	r3, [r3, #10]
 8005b44:	4a1b      	ldr	r2, [pc, #108]	; (8005bb4 <HTTP_File_Receive_Callback+0x98>)
 8005b46:	481c      	ldr	r0, [pc, #112]	; (8005bb8 <HTTP_File_Receive_Callback+0x9c>)
 8005b48:	f7fd f83e 	bl	8002bc8 <app_debug_rtt_raw>
            DEBUG_INFO("HTTP data %.*s\r\n", q->len, q->payload);
 8005b4c:	f017 f964 	bl	801ce18 <sys_get_tick_ms>
 8005b50:	0001      	movs	r1, r0
 8005b52:	697b      	ldr	r3, [r7, #20]
 8005b54:	895b      	ldrh	r3, [r3, #10]
 8005b56:	001c      	movs	r4, r3
 8005b58:	697b      	ldr	r3, [r7, #20]
 8005b5a:	685b      	ldr	r3, [r3, #4]
 8005b5c:	4a15      	ldr	r2, [pc, #84]	; (8005bb4 <HTTP_File_Receive_Callback+0x98>)
 8005b5e:	4817      	ldr	r0, [pc, #92]	; (8005bbc <HTTP_File_Receive_Callback+0xa0>)
 8005b60:	9300      	str	r3, [sp, #0]
 8005b62:	0023      	movs	r3, r4
 8005b64:	f7fd f830 	bl	8002bc8 <app_debug_rtt_raw>
        for (q = data_recv; q; q = q->next)
 8005b68:	697b      	ldr	r3, [r7, #20]
 8005b6a:	681b      	ldr	r3, [r3, #0]
 8005b6c:	617b      	str	r3, [r7, #20]
 8005b6e:	697b      	ldr	r3, [r7, #20]
 8005b70:	2b00      	cmp	r3, #0
 8005b72:	d1e2      	bne.n	8005b3a <HTTP_File_Receive_Callback+0x1e>
        }
        tcp_recved(tpcb, data_recv->tot_len);
 8005b74:	687b      	ldr	r3, [r7, #4]
 8005b76:	891a      	ldrh	r2, [r3, #8]
 8005b78:	68bb      	ldr	r3, [r7, #8]
 8005b7a:	0011      	movs	r1, r2
 8005b7c:	0018      	movs	r0, r3
 8005b7e:	f005 fb77 	bl	800b270 <tcp_recved>
        pbuf_free(data_recv);
 8005b82:	687b      	ldr	r3, [r7, #4]
 8005b84:	0018      	movs	r0, r3
 8005b86:	f004 f999 	bl	8009ebc <pbuf_free>
        DEBUG_WARN("tcp_close\r\n");
        tcp_close(tpcb);
        return ERR_ABRT;
    }

    return ERR_OK;
 8005b8a:	2300      	movs	r3, #0
 8005b8c:	e00d      	b.n	8005baa <HTTP_File_Receive_Callback+0x8e>
        DEBUG_WARN("tcp_close\r\n");
 8005b8e:	f017 f943 	bl	801ce18 <sys_get_tick_ms>
 8005b92:	0001      	movs	r1, r0
 8005b94:	4a07      	ldr	r2, [pc, #28]	; (8005bb4 <HTTP_File_Receive_Callback+0x98>)
 8005b96:	4b0a      	ldr	r3, [pc, #40]	; (8005bc0 <HTTP_File_Receive_Callback+0xa4>)
 8005b98:	0018      	movs	r0, r3
 8005b9a:	f7fd f815 	bl	8002bc8 <app_debug_rtt_raw>
        tcp_close(tpcb);
 8005b9e:	68bb      	ldr	r3, [r7, #8]
 8005ba0:	0018      	movs	r0, r3
 8005ba2:	f005 fa07 	bl	800afb4 <tcp_close>
        return ERR_ABRT;
 8005ba6:	230d      	movs	r3, #13
 8005ba8:	425b      	negs	r3, r3
}
 8005baa:	0018      	movs	r0, r3
 8005bac:	46bd      	mov	sp, r7
 8005bae:	b007      	add	sp, #28
 8005bb0:	bd90      	pop	{r4, r7, pc}
 8005bb2:	46c0      	nop			; (mov r8, r8)
 8005bb4:	0801eabc 	.word	0x0801eabc
 8005bb8:	0801ec88 	.word	0x0801ec88
 8005bbc:	0801ecb8 	.word	0x0801ecb8
 8005bc0:	0801ece4 	.word	0x0801ece4

08005bc4 <HTTP_Config>:

void HTTP_Config(void)
{
 8005bc4:	b590      	push	{r4, r7, lr}
 8005bc6:	b083      	sub	sp, #12
 8005bc8:	af02      	add	r7, sp, #8
    /* Init Http connection params */
    HTTP_Connect_Settings.use_proxy = 0;
 8005bca:	4b0f      	ldr	r3, [pc, #60]	; (8005c08 <HTTP_Config+0x44>)
 8005bcc:	2200      	movs	r2, #0
 8005bce:	719a      	strb	r2, [r3, #6]
    HTTP_Connect_Settings.headers_done_fn = HTTP_Headers_Done_Callback;
 8005bd0:	4b0d      	ldr	r3, [pc, #52]	; (8005c08 <HTTP_Config+0x44>)
 8005bd2:	4a0e      	ldr	r2, [pc, #56]	; (8005c0c <HTTP_Config+0x48>)
 8005bd4:	60da      	str	r2, [r3, #12]
    HTTP_Connect_Settings.result_fn = HTTP_Result_Callback;
 8005bd6:	4b0c      	ldr	r3, [pc, #48]	; (8005c08 <HTTP_Config+0x44>)
 8005bd8:	4a0d      	ldr	r2, [pc, #52]	; (8005c10 <HTTP_Config+0x4c>)
 8005bda:	609a      	str	r2, [r3, #8]

    DEBUG_INFO("HTTP url %s%s, port %d\r\n", HTTP_Client_Config.Url,
 8005bdc:	f017 f91c 	bl	801ce18 <sys_get_tick_ms>
 8005be0:	0004      	movs	r4, r0
 8005be2:	4a0c      	ldr	r2, [pc, #48]	; (8005c14 <HTTP_Config+0x50>)
 8005be4:	2380      	movs	r3, #128	; 0x80
 8005be6:	005b      	lsls	r3, r3, #1
 8005be8:	5ad3      	ldrh	r3, [r2, r3]
 8005bea:	490a      	ldr	r1, [pc, #40]	; (8005c14 <HTTP_Config+0x50>)
 8005bec:	4a0a      	ldr	r2, [pc, #40]	; (8005c18 <HTTP_Config+0x54>)
 8005bee:	480b      	ldr	r0, [pc, #44]	; (8005c1c <HTTP_Config+0x58>)
 8005bf0:	9301      	str	r3, [sp, #4]
 8005bf2:	4b0b      	ldr	r3, [pc, #44]	; (8005c20 <HTTP_Config+0x5c>)
 8005bf4:	9300      	str	r3, [sp, #0]
 8005bf6:	000b      	movs	r3, r1
 8005bf8:	0021      	movs	r1, r4
 8005bfa:	f7fc ffe5 	bl	8002bc8 <app_debug_rtt_raw>
                                             HTTP_Client_Config.File,
                                             HTTP_Client_Config.Port);
}
 8005bfe:	46c0      	nop			; (mov r8, r8)
 8005c00:	46bd      	mov	sp, r7
 8005c02:	b001      	add	sp, #4
 8005c04:	bd90      	pop	{r4, r7, pc}
 8005c06:	46c0      	nop			; (mov r8, r8)
 8005c08:	20001548 	.word	0x20001548
 8005c0c:	08005a19 	.word	0x08005a19
 8005c10:	08005a7d 	.word	0x08005a7d
 8005c14:	20001344 	.word	0x20001344
 8005c18:	0801eabc 	.word	0x0801eabc
 8005c1c:	0801ed0c 	.word	0x0801ed0c
 8005c20:	20001446 	.word	0x20001446

08005c24 <HTTP_Get_Data>:
void HTTP_Get_Data(void)
{
 8005c24:	b5b0      	push	{r4, r5, r7, lr}
 8005c26:	b086      	sub	sp, #24
 8005c28:	af04      	add	r7, sp, #16
    // Káº¿t ná»i HTTP
    err_t err = httpc_get_file_dns((const char*)HTTP_Client_Config.Url,
 8005c2a:	4a1a      	ldr	r2, [pc, #104]	; (8005c94 <HTTP_Get_Data+0x70>)
 8005c2c:	2380      	movs	r3, #128	; 0x80
 8005c2e:	005b      	lsls	r3, r3, #1
 8005c30:	5ad1      	ldrh	r1, [r2, r3]
 8005c32:	1dfc      	adds	r4, r7, #7
 8005c34:	4d18      	ldr	r5, [pc, #96]	; (8005c98 <HTTP_Get_Data+0x74>)
 8005c36:	4a19      	ldr	r2, [pc, #100]	; (8005c9c <HTTP_Get_Data+0x78>)
 8005c38:	4816      	ldr	r0, [pc, #88]	; (8005c94 <HTTP_Get_Data+0x70>)
 8005c3a:	4b19      	ldr	r3, [pc, #100]	; (8005ca0 <HTTP_Get_Data+0x7c>)
 8005c3c:	9302      	str	r3, [sp, #8]
 8005c3e:	2300      	movs	r3, #0
 8005c40:	9301      	str	r3, [sp, #4]
 8005c42:	4b18      	ldr	r3, [pc, #96]	; (8005ca4 <HTTP_Get_Data+0x80>)
 8005c44:	9300      	str	r3, [sp, #0]
 8005c46:	002b      	movs	r3, r5
 8005c48:	f000 fe66 	bl	8006918 <httpc_get_file_dns>
 8005c4c:	0003      	movs	r3, r0
 8005c4e:	7023      	strb	r3, [r4, #0]
                                   HTTP_Client_Config.File,
                                   &HTTP_Connect_Settings,
                                   HTTP_File_Receive_Callback,
                                   NULL,
                                   &HTTP_Connection_State);
    HTTP_Connect_Settings.headers_done_fn = HTTP_Headers_Done_Callback;
 8005c50:	4b11      	ldr	r3, [pc, #68]	; (8005c98 <HTTP_Get_Data+0x74>)
 8005c52:	4a15      	ldr	r2, [pc, #84]	; (8005ca8 <HTTP_Get_Data+0x84>)
 8005c54:	60da      	str	r2, [r3, #12]
    HTTP_Connect_Settings.result_fn = HTTP_Result_Callback;
 8005c56:	4b10      	ldr	r3, [pc, #64]	; (8005c98 <HTTP_Get_Data+0x74>)
 8005c58:	4a14      	ldr	r2, [pc, #80]	; (8005cac <HTTP_Get_Data+0x88>)
 8005c5a:	609a      	str	r2, [r3, #8]
    if(err != ERR_OK)
 8005c5c:	1dfb      	adds	r3, r7, #7
 8005c5e:	781b      	ldrb	r3, [r3, #0]
 8005c60:	b25b      	sxtb	r3, r3
 8005c62:	2b00      	cmp	r3, #0
 8005c64:	d00a      	beq.n	8005c7c <HTTP_Get_Data+0x58>
    {
        DEBUG_INFO("HTTP Get File DNS return %d\r\n", err);
 8005c66:	f017 f8d7 	bl	801ce18 <sys_get_tick_ms>
 8005c6a:	0001      	movs	r1, r0
 8005c6c:	1dfb      	adds	r3, r7, #7
 8005c6e:	781b      	ldrb	r3, [r3, #0]
 8005c70:	b25b      	sxtb	r3, r3
 8005c72:	4a0f      	ldr	r2, [pc, #60]	; (8005cb0 <HTTP_Get_Data+0x8c>)
 8005c74:	480f      	ldr	r0, [pc, #60]	; (8005cb4 <HTTP_Get_Data+0x90>)
 8005c76:	f7fc ffa7 	bl	8002bc8 <app_debug_rtt_raw>
    {
        DEBUG_INFO("HTTP Get File DNS successfully\r\n");
        //HTTP_Manager.Step = HTTP_STEP_CONNECTED;
        //DEBUG_INFO("HTTP_STEP_CONNECTED.\r\n");
    }
}
 8005c7a:	e007      	b.n	8005c8c <HTTP_Get_Data+0x68>
        DEBUG_INFO("HTTP Get File DNS successfully\r\n");
 8005c7c:	f017 f8cc 	bl	801ce18 <sys_get_tick_ms>
 8005c80:	0001      	movs	r1, r0
 8005c82:	4a0b      	ldr	r2, [pc, #44]	; (8005cb0 <HTTP_Get_Data+0x8c>)
 8005c84:	4b0c      	ldr	r3, [pc, #48]	; (8005cb8 <HTTP_Get_Data+0x94>)
 8005c86:	0018      	movs	r0, r3
 8005c88:	f7fc ff9e 	bl	8002bc8 <app_debug_rtt_raw>
}
 8005c8c:	46c0      	nop			; (mov r8, r8)
 8005c8e:	46bd      	mov	sp, r7
 8005c90:	b002      	add	sp, #8
 8005c92:	bdb0      	pop	{r4, r5, r7, pc}
 8005c94:	20001344 	.word	0x20001344
 8005c98:	20001548 	.word	0x20001548
 8005c9c:	20001446 	.word	0x20001446
 8005ca0:	20001558 	.word	0x20001558
 8005ca4:	08005b1d 	.word	0x08005b1d
 8005ca8:	08005a19 	.word	0x08005a19
 8005cac:	08005a7d 	.word	0x08005a7d
 8005cb0:	0801eabc 	.word	0x0801eabc
 8005cb4:	0801ed40 	.word	0x0801ed40
 8005cb8:	0801ed78 	.word	0x0801ed78

08005cbc <HTTP_Client_Polling_Task>:
void HTTP_Client_Polling_Task(void *arg)
{
 8005cbc:	b580      	push	{r7, lr}
 8005cbe:	b084      	sub	sp, #16
 8005cc0:	af00      	add	r7, sp, #0
 8005cc2:	6078      	str	r0, [r7, #4]
    //static uint32_t Last_time_get_data = 0, tick = 0;
    static uint32_t Last_Tick = 0;
    uint32_t Current_Tick = sys_get_tick_ms();
 8005cc4:	f017 f8a8 	bl	801ce18 <sys_get_tick_ms>
 8005cc8:	0003      	movs	r3, r0
 8005cca:	60fb      	str	r3, [r7, #12]

    if((Current_Tick - Last_Tick) >= (uint32_t)1000)
 8005ccc:	4b34      	ldr	r3, [pc, #208]	; (8005da0 <HTTP_Client_Polling_Task+0xe4>)
 8005cce:	681b      	ldr	r3, [r3, #0]
 8005cd0:	68fa      	ldr	r2, [r7, #12]
 8005cd2:	1ad2      	subs	r2, r2, r3
 8005cd4:	23fa      	movs	r3, #250	; 0xfa
 8005cd6:	009b      	lsls	r3, r3, #2
 8005cd8:	429a      	cmp	r2, r3
 8005cda:	d359      	bcc.n	8005d90 <HTTP_Client_Polling_Task+0xd4>
    {
        Last_Tick = Current_Tick;
 8005cdc:	4b30      	ldr	r3, [pc, #192]	; (8005da0 <HTTP_Client_Polling_Task+0xe4>)
 8005cde:	68fa      	ldr	r2, [r7, #12]
 8005ce0:	601a      	str	r2, [r3, #0]
    else
    {
        return;
    }
    static bool HTTP_Allow = false;
    if(gsm_data_layer_is_ppp_connected())
 8005ce2:	f7fb fb23 	bl	800132c <gsm_data_layer_is_ppp_connected>
 8005ce6:	1e03      	subs	r3, r0, #0
 8005ce8:	d012      	beq.n	8005d10 <HTTP_Client_Polling_Task+0x54>
    {
        if(HTTP_Allow == false)
 8005cea:	4b2e      	ldr	r3, [pc, #184]	; (8005da4 <HTTP_Client_Polling_Task+0xe8>)
 8005cec:	781b      	ldrb	r3, [r3, #0]
 8005cee:	2201      	movs	r2, #1
 8005cf0:	4053      	eors	r3, r2
 8005cf2:	b2db      	uxtb	r3, r3
 8005cf4:	2b00      	cmp	r3, #0
 8005cf6:	d01a      	beq.n	8005d2e <HTTP_Client_Polling_Task+0x72>
        {
            HTTP_Allow = true;
 8005cf8:	4b2a      	ldr	r3, [pc, #168]	; (8005da4 <HTTP_Client_Polling_Task+0xe8>)
 8005cfa:	2201      	movs	r2, #1
 8005cfc:	701a      	strb	r2, [r3, #0]
            DEBUG_INFO("HTTP Thread started.\r\n");
 8005cfe:	f017 f88b 	bl	801ce18 <sys_get_tick_ms>
 8005d02:	0001      	movs	r1, r0
 8005d04:	4a28      	ldr	r2, [pc, #160]	; (8005da8 <HTTP_Client_Polling_Task+0xec>)
 8005d06:	4b29      	ldr	r3, [pc, #164]	; (8005dac <HTTP_Client_Polling_Task+0xf0>)
 8005d08:	0018      	movs	r0, r3
 8005d0a:	f7fc ff5d 	bl	8002bc8 <app_debug_rtt_raw>
 8005d0e:	e00e      	b.n	8005d2e <HTTP_Client_Polling_Task+0x72>
        }
    }
    else
    {
        if(HTTP_Allow == true)
 8005d10:	4b24      	ldr	r3, [pc, #144]	; (8005da4 <HTTP_Client_Polling_Task+0xe8>)
 8005d12:	781b      	ldrb	r3, [r3, #0]
 8005d14:	2b00      	cmp	r3, #0
 8005d16:	d00a      	beq.n	8005d2e <HTTP_Client_Polling_Task+0x72>
        {
            HTTP_Allow = false;
 8005d18:	4b22      	ldr	r3, [pc, #136]	; (8005da4 <HTTP_Client_Polling_Task+0xe8>)
 8005d1a:	2200      	movs	r2, #0
 8005d1c:	701a      	strb	r2, [r3, #0]
            DEBUG_INFO("HTTP Thread stopped.\r\n");
 8005d1e:	f017 f87b 	bl	801ce18 <sys_get_tick_ms>
 8005d22:	0001      	movs	r1, r0
 8005d24:	4a20      	ldr	r2, [pc, #128]	; (8005da8 <HTTP_Client_Polling_Task+0xec>)
 8005d26:	4b22      	ldr	r3, [pc, #136]	; (8005db0 <HTTP_Client_Polling_Task+0xf4>)
 8005d28:	0018      	movs	r0, r3
 8005d2a:	f7fc ff4d 	bl	8002bc8 <app_debug_rtt_raw>
        }
    }
    if(HTTP_Allow)
 8005d2e:	4b1d      	ldr	r3, [pc, #116]	; (8005da4 <HTTP_Client_Polling_Task+0xe8>)
 8005d30:	781b      	ldrb	r3, [r3, #0]
 8005d32:	2b00      	cmp	r3, #0
 8005d34:	d031      	beq.n	8005d9a <HTTP_Client_Polling_Task+0xde>
    {
        switch (HTTP_Manager.Step)
 8005d36:	4b1f      	ldr	r3, [pc, #124]	; (8005db4 <HTTP_Client_Polling_Task+0xf8>)
 8005d38:	781b      	ldrb	r3, [r3, #0]
 8005d3a:	2b03      	cmp	r3, #3
 8005d3c:	d02a      	beq.n	8005d94 <HTTP_Client_Polling_Task+0xd8>
 8005d3e:	dc2b      	bgt.n	8005d98 <HTTP_Client_Polling_Task+0xdc>
 8005d40:	2b02      	cmp	r3, #2
 8005d42:	d01f      	beq.n	8005d84 <HTTP_Client_Polling_Task+0xc8>
 8005d44:	dc28      	bgt.n	8005d98 <HTTP_Client_Polling_Task+0xdc>
 8005d46:	2b00      	cmp	r3, #0
 8005d48:	d002      	beq.n	8005d50 <HTTP_Client_Polling_Task+0x94>
 8005d4a:	2b01      	cmp	r3, #1
 8005d4c:	d00c      	beq.n	8005d68 <HTTP_Client_Polling_Task+0xac>
        case HTTP_STEP_CONNECTED:

            break;

        default:
            break;
 8005d4e:	e023      	b.n	8005d98 <HTTP_Client_Polling_Task+0xdc>
            HTTP_Manager.Step = HTTP_STEP_CONFIG;
 8005d50:	4b18      	ldr	r3, [pc, #96]	; (8005db4 <HTTP_Client_Polling_Task+0xf8>)
 8005d52:	2201      	movs	r2, #1
 8005d54:	701a      	strb	r2, [r3, #0]
            DEBUG_INFO("HTTP_STEP_CONFIG.\r\n");
 8005d56:	f017 f85f 	bl	801ce18 <sys_get_tick_ms>
 8005d5a:	0001      	movs	r1, r0
 8005d5c:	4a12      	ldr	r2, [pc, #72]	; (8005da8 <HTTP_Client_Polling_Task+0xec>)
 8005d5e:	4b16      	ldr	r3, [pc, #88]	; (8005db8 <HTTP_Client_Polling_Task+0xfc>)
 8005d60:	0018      	movs	r0, r3
 8005d62:	f7fc ff31 	bl	8002bc8 <app_debug_rtt_raw>
            break;
 8005d66:	e018      	b.n	8005d9a <HTTP_Client_Polling_Task+0xde>
            HTTP_Config();
 8005d68:	f7ff ff2c 	bl	8005bc4 <HTTP_Config>
            HTTP_Manager.Step = HTTP_STEP_CONNECTING;
 8005d6c:	4b11      	ldr	r3, [pc, #68]	; (8005db4 <HTTP_Client_Polling_Task+0xf8>)
 8005d6e:	2202      	movs	r2, #2
 8005d70:	701a      	strb	r2, [r3, #0]
            DEBUG_INFO("HTTP_STEP_CONNECTING.\r\n");
 8005d72:	f017 f851 	bl	801ce18 <sys_get_tick_ms>
 8005d76:	0001      	movs	r1, r0
 8005d78:	4a0b      	ldr	r2, [pc, #44]	; (8005da8 <HTTP_Client_Polling_Task+0xec>)
 8005d7a:	4b10      	ldr	r3, [pc, #64]	; (8005dbc <HTTP_Client_Polling_Task+0x100>)
 8005d7c:	0018      	movs	r0, r3
 8005d7e:	f7fc ff23 	bl	8002bc8 <app_debug_rtt_raw>
            break;
 8005d82:	e00a      	b.n	8005d9a <HTTP_Client_Polling_Task+0xde>
            HTTP_Get_Data();
 8005d84:	f7ff ff4e 	bl	8005c24 <HTTP_Get_Data>
            HTTP_Manager.Step = HTTP_STEP_CONNECTED;
 8005d88:	4b0a      	ldr	r3, [pc, #40]	; (8005db4 <HTTP_Client_Polling_Task+0xf8>)
 8005d8a:	2203      	movs	r2, #3
 8005d8c:	701a      	strb	r2, [r3, #0]
            break;
 8005d8e:	e004      	b.n	8005d9a <HTTP_Client_Polling_Task+0xde>
        return;
 8005d90:	46c0      	nop			; (mov r8, r8)
 8005d92:	e002      	b.n	8005d9a <HTTP_Client_Polling_Task+0xde>
            break;
 8005d94:	46c0      	nop			; (mov r8, r8)
 8005d96:	e000      	b.n	8005d9a <HTTP_Client_Polling_Task+0xde>
            break;
 8005d98:	46c0      	nop			; (mov r8, r8)
        }
    }
}
 8005d9a:	46bd      	mov	sp, r7
 8005d9c:	b004      	add	sp, #16
 8005d9e:	bd80      	pop	{r7, pc}
 8005da0:	20001560 	.word	0x20001560
 8005da4:	20001564 	.word	0x20001564
 8005da8:	0801eabc 	.word	0x0801eabc
 8005dac:	0801edb4 	.word	0x0801edb4
 8005db0:	0801ede4 	.word	0x0801ede4
 8005db4:	2000155c 	.word	0x2000155c
 8005db8:	0801ee14 	.word	0x0801ee14
 8005dbc:	0801ee44 	.word	0x0801ee44

08005dc0 <httpc_free_state>:
} httpc_state_t;

/** Free http client state and deallocate all resources within */
static err_t
httpc_free_state(httpc_state_t* req)
{
 8005dc0:	b5b0      	push	{r4, r5, r7, lr}
 8005dc2:	b084      	sub	sp, #16
 8005dc4:	af00      	add	r7, sp, #0
 8005dc6:	6078      	str	r0, [r7, #4]
  struct altcp_pcb* tpcb;

  if (req->request != NULL) {
 8005dc8:	687b      	ldr	r3, [r7, #4]
 8005dca:	691b      	ldr	r3, [r3, #16]
 8005dcc:	2b00      	cmp	r3, #0
 8005dce:	d007      	beq.n	8005de0 <httpc_free_state+0x20>
    pbuf_free(req->request);
 8005dd0:	687b      	ldr	r3, [r7, #4]
 8005dd2:	691b      	ldr	r3, [r3, #16]
 8005dd4:	0018      	movs	r0, r3
 8005dd6:	f004 f871 	bl	8009ebc <pbuf_free>
    req->request = NULL;
 8005dda:	687b      	ldr	r3, [r7, #4]
 8005ddc:	2200      	movs	r2, #0
 8005dde:	611a      	str	r2, [r3, #16]
  }
  if (req->rx_hdrs != NULL) {
 8005de0:	687b      	ldr	r3, [r7, #4]
 8005de2:	695b      	ldr	r3, [r3, #20]
 8005de4:	2b00      	cmp	r3, #0
 8005de6:	d007      	beq.n	8005df8 <httpc_free_state+0x38>
    pbuf_free(req->rx_hdrs);
 8005de8:	687b      	ldr	r3, [r7, #4]
 8005dea:	695b      	ldr	r3, [r3, #20]
 8005dec:	0018      	movs	r0, r3
 8005dee:	f004 f865 	bl	8009ebc <pbuf_free>
    req->rx_hdrs = NULL;
 8005df2:	687b      	ldr	r3, [r7, #4]
 8005df4:	2200      	movs	r2, #0
 8005df6:	615a      	str	r2, [r3, #20]
  }

  tpcb = req->pcb;
 8005df8:	687b      	ldr	r3, [r7, #4]
 8005dfa:	681b      	ldr	r3, [r3, #0]
 8005dfc:	60fb      	str	r3, [r7, #12]
  mem_free(req);
 8005dfe:	687b      	ldr	r3, [r7, #4]
 8005e00:	0018      	movs	r0, r3
 8005e02:	f002 fdd1 	bl	80089a8 <mem_free>
  req = NULL;
 8005e06:	2300      	movs	r3, #0
 8005e08:	607b      	str	r3, [r7, #4]

  if (tpcb != NULL) {
 8005e0a:	68fb      	ldr	r3, [r7, #12]
 8005e0c:	2b00      	cmp	r3, #0
 8005e0e:	d02d      	beq.n	8005e6c <httpc_free_state+0xac>
    err_t r;
    altcp_arg(tpcb, NULL);
 8005e10:	68fb      	ldr	r3, [r7, #12]
 8005e12:	2100      	movs	r1, #0
 8005e14:	0018      	movs	r0, r3
 8005e16:	f006 fae0 	bl	800c3da <tcp_arg>
    altcp_recv(tpcb, NULL);
 8005e1a:	68fb      	ldr	r3, [r7, #12]
 8005e1c:	2100      	movs	r1, #0
 8005e1e:	0018      	movs	r0, r3
 8005e20:	f006 faea 	bl	800c3f8 <tcp_recv>
    altcp_err(tpcb, NULL);
 8005e24:	68fb      	ldr	r3, [r7, #12]
 8005e26:	2100      	movs	r1, #0
 8005e28:	0018      	movs	r0, r3
 8005e2a:	f006 fb29 	bl	800c480 <tcp_err>
    altcp_poll(tpcb, NULL, 0);
 8005e2e:	68fb      	ldr	r3, [r7, #12]
 8005e30:	2200      	movs	r2, #0
 8005e32:	2100      	movs	r1, #0
 8005e34:	0018      	movs	r0, r3
 8005e36:	f006 fb45 	bl	800c4c4 <tcp_poll>
    altcp_sent(tpcb, NULL);
 8005e3a:	68fb      	ldr	r3, [r7, #12]
 8005e3c:	2100      	movs	r1, #0
 8005e3e:	0018      	movs	r0, r3
 8005e40:	f006 fafc 	bl	800c43c <tcp_sent>
    r = altcp_close(tpcb);
 8005e44:	250b      	movs	r5, #11
 8005e46:	197c      	adds	r4, r7, r5
 8005e48:	68fb      	ldr	r3, [r7, #12]
 8005e4a:	0018      	movs	r0, r3
 8005e4c:	f005 f8b2 	bl	800afb4 <tcp_close>
 8005e50:	0003      	movs	r3, r0
 8005e52:	7023      	strb	r3, [r4, #0]
    if (r != ERR_OK) {
 8005e54:	197b      	adds	r3, r7, r5
 8005e56:	781b      	ldrb	r3, [r3, #0]
 8005e58:	b25b      	sxtb	r3, r3
 8005e5a:	2b00      	cmp	r3, #0
 8005e5c:	d006      	beq.n	8005e6c <httpc_free_state+0xac>
      altcp_abort(tpcb);
 8005e5e:	68fb      	ldr	r3, [r7, #12]
 8005e60:	0018      	movs	r0, r3
 8005e62:	f005 f997 	bl	800b194 <tcp_abort>
      return ERR_ABRT;
 8005e66:	230d      	movs	r3, #13
 8005e68:	425b      	negs	r3, r3
 8005e6a:	e000      	b.n	8005e6e <httpc_free_state+0xae>
    }
  }
  return ERR_OK;
 8005e6c:	2300      	movs	r3, #0
}
 8005e6e:	0018      	movs	r0, r3
 8005e70:	46bd      	mov	sp, r7
 8005e72:	b004      	add	sp, #16
 8005e74:	bdb0      	pop	{r4, r5, r7, pc}

08005e76 <httpc_close>:

/** Close the connection: call finished callback and free the state */
static err_t
httpc_close(httpc_state_t* req, httpc_result_t result, u32_t server_response, err_t err)
{
 8005e76:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005e78:	b087      	sub	sp, #28
 8005e7a:	af02      	add	r7, sp, #8
 8005e7c:	60f8      	str	r0, [r7, #12]
 8005e7e:	0008      	movs	r0, r1
 8005e80:	607a      	str	r2, [r7, #4]
 8005e82:	0019      	movs	r1, r3
 8005e84:	260b      	movs	r6, #11
 8005e86:	19bb      	adds	r3, r7, r6
 8005e88:	1c02      	adds	r2, r0, #0
 8005e8a:	701a      	strb	r2, [r3, #0]
 8005e8c:	230a      	movs	r3, #10
 8005e8e:	18fb      	adds	r3, r7, r3
 8005e90:	1c0a      	adds	r2, r1, #0
 8005e92:	701a      	strb	r2, [r3, #0]
  if (req != NULL) {
 8005e94:	68fb      	ldr	r3, [r7, #12]
 8005e96:	2b00      	cmp	r3, #0
 8005e98:	d01f      	beq.n	8005eda <httpc_close+0x64>
    if (req->conn_settings != NULL) {
 8005e9a:	68fb      	ldr	r3, [r7, #12]
 8005e9c:	6a1b      	ldr	r3, [r3, #32]
 8005e9e:	2b00      	cmp	r3, #0
 8005ea0:	d015      	beq.n	8005ece <httpc_close+0x58>
      if (req->conn_settings->result_fn != NULL) {
 8005ea2:	68fb      	ldr	r3, [r7, #12]
 8005ea4:	6a1b      	ldr	r3, [r3, #32]
 8005ea6:	689b      	ldr	r3, [r3, #8]
 8005ea8:	2b00      	cmp	r3, #0
 8005eaa:	d010      	beq.n	8005ece <httpc_close+0x58>
        req->conn_settings->result_fn(req->callback_arg, result, req->rx_content_len, server_response, err);
 8005eac:	68fb      	ldr	r3, [r7, #12]
 8005eae:	6a1b      	ldr	r3, [r3, #32]
 8005eb0:	689c      	ldr	r4, [r3, #8]
 8005eb2:	68fb      	ldr	r3, [r7, #12]
 8005eb4:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8005eb6:	68fb      	ldr	r3, [r7, #12]
 8005eb8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8005eba:	687d      	ldr	r5, [r7, #4]
 8005ebc:	19bb      	adds	r3, r7, r6
 8005ebe:	7819      	ldrb	r1, [r3, #0]
 8005ec0:	230a      	movs	r3, #10
 8005ec2:	18fb      	adds	r3, r7, r3
 8005ec4:	781b      	ldrb	r3, [r3, #0]
 8005ec6:	b25b      	sxtb	r3, r3
 8005ec8:	9300      	str	r3, [sp, #0]
 8005eca:	002b      	movs	r3, r5
 8005ecc:	47a0      	blx	r4
      }
    }
    return httpc_free_state(req);
 8005ece:	68fb      	ldr	r3, [r7, #12]
 8005ed0:	0018      	movs	r0, r3
 8005ed2:	f7ff ff75 	bl	8005dc0 <httpc_free_state>
 8005ed6:	0003      	movs	r3, r0
 8005ed8:	e000      	b.n	8005edc <httpc_close+0x66>
  }
  return ERR_OK;
 8005eda:	2300      	movs	r3, #0
}
 8005edc:	0018      	movs	r0, r3
 8005ede:	46bd      	mov	sp, r7
 8005ee0:	b005      	add	sp, #20
 8005ee2:	bdf0      	pop	{r4, r5, r6, r7, pc}

08005ee4 <http_parse_response_status>:

/** Parse http header response line 1 */
static err_t
http_parse_response_status(struct pbuf *p, u16_t *http_version, u16_t *http_status, u16_t *http_status_str_offset)
{
 8005ee4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005ee6:	b08d      	sub	sp, #52	; 0x34
 8005ee8:	af00      	add	r7, sp, #0
 8005eea:	60f8      	str	r0, [r7, #12]
 8005eec:	60b9      	str	r1, [r7, #8]
 8005eee:	607a      	str	r2, [r7, #4]
 8005ef0:	603b      	str	r3, [r7, #0]
  u16_t end1 = pbuf_memfind(p, "\r\n", 2, 0);
 8005ef2:	252a      	movs	r5, #42	; 0x2a
 8005ef4:	197c      	adds	r4, r7, r5
 8005ef6:	4957      	ldr	r1, [pc, #348]	; (8006054 <http_parse_response_status+0x170>)
 8005ef8:	68f8      	ldr	r0, [r7, #12]
 8005efa:	2300      	movs	r3, #0
 8005efc:	2202      	movs	r2, #2
 8005efe:	f004 fde5 	bl	800aacc <pbuf_memfind>
 8005f02:	0003      	movs	r3, r0
 8005f04:	8023      	strh	r3, [r4, #0]
  if (end1 != 0xFFFF) {
 8005f06:	197b      	adds	r3, r7, r5
 8005f08:	881b      	ldrh	r3, [r3, #0]
 8005f0a:	4a53      	ldr	r2, [pc, #332]	; (8006058 <http_parse_response_status+0x174>)
 8005f0c:	4293      	cmp	r3, r2
 8005f0e:	d100      	bne.n	8005f12 <http_parse_response_status+0x2e>
 8005f10:	e099      	b.n	8006046 <http_parse_response_status+0x162>
    /* get parts of first line */
    u16_t space1, space2;
    space1 = pbuf_memfind(p, " ", 1, 0);
 8005f12:	2528      	movs	r5, #40	; 0x28
 8005f14:	197c      	adds	r4, r7, r5
 8005f16:	4951      	ldr	r1, [pc, #324]	; (800605c <http_parse_response_status+0x178>)
 8005f18:	68f8      	ldr	r0, [r7, #12]
 8005f1a:	2300      	movs	r3, #0
 8005f1c:	2201      	movs	r2, #1
 8005f1e:	f004 fdd5 	bl	800aacc <pbuf_memfind>
 8005f22:	0003      	movs	r3, r0
 8005f24:	8023      	strh	r3, [r4, #0]
    if (space1 != 0xFFFF) {
 8005f26:	197b      	adds	r3, r7, r5
 8005f28:	881b      	ldrh	r3, [r3, #0]
 8005f2a:	4a4b      	ldr	r2, [pc, #300]	; (8006058 <http_parse_response_status+0x174>)
 8005f2c:	4293      	cmp	r3, r2
 8005f2e:	d100      	bne.n	8005f32 <http_parse_response_status+0x4e>
 8005f30:	e089      	b.n	8006046 <http_parse_response_status+0x162>
      if ((pbuf_memcmp(p, 0, "HTTP/", 5) == 0)  && (pbuf_get_at(p, 6) == '.')) {
 8005f32:	4a4b      	ldr	r2, [pc, #300]	; (8006060 <http_parse_response_status+0x17c>)
 8005f34:	68f8      	ldr	r0, [r7, #12]
 8005f36:	2305      	movs	r3, #5
 8005f38:	2100      	movs	r1, #0
 8005f3a:	f004 fd47 	bl	800a9cc <pbuf_memcmp>
 8005f3e:	1e03      	subs	r3, r0, #0
 8005f40:	d000      	beq.n	8005f44 <http_parse_response_status+0x60>
 8005f42:	e080      	b.n	8006046 <http_parse_response_status+0x162>
 8005f44:	68fb      	ldr	r3, [r7, #12]
 8005f46:	2106      	movs	r1, #6
 8005f48:	0018      	movs	r0, r3
 8005f4a:	f004 fcd1 	bl	800a8f0 <pbuf_get_at>
 8005f4e:	0003      	movs	r3, r0
 8005f50:	2b2e      	cmp	r3, #46	; 0x2e
 8005f52:	d000      	beq.n	8005f56 <http_parse_response_status+0x72>
 8005f54:	e077      	b.n	8006046 <http_parse_response_status+0x162>
        char status_num[10];
        size_t status_num_len;
        /* parse http version */
        u16_t version = pbuf_get_at(p, 5) - '0';
 8005f56:	68fb      	ldr	r3, [r7, #12]
 8005f58:	2105      	movs	r1, #5
 8005f5a:	0018      	movs	r0, r3
 8005f5c:	f004 fcc8 	bl	800a8f0 <pbuf_get_at>
 8005f60:	0003      	movs	r3, r0
 8005f62:	b29a      	uxth	r2, r3
 8005f64:	2426      	movs	r4, #38	; 0x26
 8005f66:	193b      	adds	r3, r7, r4
 8005f68:	3a30      	subs	r2, #48	; 0x30
 8005f6a:	801a      	strh	r2, [r3, #0]
        version <<= 8;
 8005f6c:	193b      	adds	r3, r7, r4
 8005f6e:	193a      	adds	r2, r7, r4
 8005f70:	8812      	ldrh	r2, [r2, #0]
 8005f72:	0212      	lsls	r2, r2, #8
 8005f74:	801a      	strh	r2, [r3, #0]
        version |= pbuf_get_at(p, 7) - '0';
 8005f76:	68fb      	ldr	r3, [r7, #12]
 8005f78:	2107      	movs	r1, #7
 8005f7a:	0018      	movs	r0, r3
 8005f7c:	f004 fcb8 	bl	800a8f0 <pbuf_get_at>
 8005f80:	0003      	movs	r3, r0
 8005f82:	3b30      	subs	r3, #48	; 0x30
 8005f84:	b21a      	sxth	r2, r3
 8005f86:	193b      	adds	r3, r7, r4
 8005f88:	2100      	movs	r1, #0
 8005f8a:	5e5b      	ldrsh	r3, [r3, r1]
 8005f8c:	4313      	orrs	r3, r2
 8005f8e:	b21a      	sxth	r2, r3
 8005f90:	193b      	adds	r3, r7, r4
 8005f92:	801a      	strh	r2, [r3, #0]
        *http_version = version;
 8005f94:	68bb      	ldr	r3, [r7, #8]
 8005f96:	193a      	adds	r2, r7, r4
 8005f98:	8812      	ldrh	r2, [r2, #0]
 8005f9a:	801a      	strh	r2, [r3, #0]

        /* parse http status number */
        space2 = pbuf_memfind(p, " ", 1, space1 + 1);
 8005f9c:	197b      	adds	r3, r7, r5
 8005f9e:	881b      	ldrh	r3, [r3, #0]
 8005fa0:	3301      	adds	r3, #1
 8005fa2:	b29b      	uxth	r3, r3
 8005fa4:	2624      	movs	r6, #36	; 0x24
 8005fa6:	19bc      	adds	r4, r7, r6
 8005fa8:	492c      	ldr	r1, [pc, #176]	; (800605c <http_parse_response_status+0x178>)
 8005faa:	68f8      	ldr	r0, [r7, #12]
 8005fac:	2201      	movs	r2, #1
 8005fae:	f004 fd8d 	bl	800aacc <pbuf_memfind>
 8005fb2:	0003      	movs	r3, r0
 8005fb4:	8023      	strh	r3, [r4, #0]
        if (space2 != 0xFFFF) {
 8005fb6:	0031      	movs	r1, r6
 8005fb8:	187b      	adds	r3, r7, r1
 8005fba:	881b      	ldrh	r3, [r3, #0]
 8005fbc:	4a26      	ldr	r2, [pc, #152]	; (8006058 <http_parse_response_status+0x174>)
 8005fbe:	4293      	cmp	r3, r2
 8005fc0:	d00d      	beq.n	8005fde <http_parse_response_status+0xfa>
          *http_status_str_offset = space2 + 1;
 8005fc2:	187b      	adds	r3, r7, r1
 8005fc4:	881b      	ldrh	r3, [r3, #0]
 8005fc6:	3301      	adds	r3, #1
 8005fc8:	b29a      	uxth	r2, r3
 8005fca:	683b      	ldr	r3, [r7, #0]
 8005fcc:	801a      	strh	r2, [r3, #0]
          status_num_len = space2 - space1 - 1;
 8005fce:	187b      	adds	r3, r7, r1
 8005fd0:	881a      	ldrh	r2, [r3, #0]
 8005fd2:	197b      	adds	r3, r7, r5
 8005fd4:	881b      	ldrh	r3, [r3, #0]
 8005fd6:	1ad3      	subs	r3, r2, r3
 8005fd8:	3b01      	subs	r3, #1
 8005fda:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005fdc:	e008      	b.n	8005ff0 <http_parse_response_status+0x10c>
        } else {
          status_num_len = end1 - space1 - 1;
 8005fde:	232a      	movs	r3, #42	; 0x2a
 8005fe0:	18fb      	adds	r3, r7, r3
 8005fe2:	881a      	ldrh	r2, [r3, #0]
 8005fe4:	2328      	movs	r3, #40	; 0x28
 8005fe6:	18fb      	adds	r3, r7, r3
 8005fe8:	881b      	ldrh	r3, [r3, #0]
 8005fea:	1ad3      	subs	r3, r2, r3
 8005fec:	3b01      	subs	r3, #1
 8005fee:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
        memset(status_num, 0, sizeof(status_num));
 8005ff0:	2414      	movs	r4, #20
 8005ff2:	193b      	adds	r3, r7, r4
 8005ff4:	220a      	movs	r2, #10
 8005ff6:	2100      	movs	r1, #0
 8005ff8:	0018      	movs	r0, r3
 8005ffa:	f016 ff83 	bl	801cf04 <memset>
        if (pbuf_copy_partial(p, status_num, (u16_t)status_num_len, space1 + 1) == status_num_len) {
 8005ffe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006000:	b29a      	uxth	r2, r3
 8006002:	2328      	movs	r3, #40	; 0x28
 8006004:	18fb      	adds	r3, r7, r3
 8006006:	881b      	ldrh	r3, [r3, #0]
 8006008:	3301      	adds	r3, #1
 800600a:	b29b      	uxth	r3, r3
 800600c:	1939      	adds	r1, r7, r4
 800600e:	68f8      	ldr	r0, [r7, #12]
 8006010:	f004 fa1e 	bl	800a450 <pbuf_copy_partial>
 8006014:	0003      	movs	r3, r0
 8006016:	001a      	movs	r2, r3
 8006018:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800601a:	4293      	cmp	r3, r2
 800601c:	d113      	bne.n	8006046 <http_parse_response_status+0x162>
          int status = atoi(status_num);
 800601e:	193b      	adds	r3, r7, r4
 8006020:	0018      	movs	r0, r3
 8006022:	f016 ff11 	bl	801ce48 <atoi>
 8006026:	0003      	movs	r3, r0
 8006028:	623b      	str	r3, [r7, #32]
          if ((status > 0) && (status <= 0xFFFF)) {
 800602a:	6a3b      	ldr	r3, [r7, #32]
 800602c:	2b00      	cmp	r3, #0
 800602e:	dd0a      	ble.n	8006046 <http_parse_response_status+0x162>
 8006030:	6a3a      	ldr	r2, [r7, #32]
 8006032:	2380      	movs	r3, #128	; 0x80
 8006034:	025b      	lsls	r3, r3, #9
 8006036:	429a      	cmp	r2, r3
 8006038:	da05      	bge.n	8006046 <http_parse_response_status+0x162>
            *http_status = (u16_t)status;
 800603a:	6a3b      	ldr	r3, [r7, #32]
 800603c:	b29a      	uxth	r2, r3
 800603e:	687b      	ldr	r3, [r7, #4]
 8006040:	801a      	strh	r2, [r3, #0]
            return ERR_OK;
 8006042:	2300      	movs	r3, #0
 8006044:	e001      	b.n	800604a <http_parse_response_status+0x166>
          }
        }
      }
    }
  }
  return ERR_VAL;
 8006046:	2306      	movs	r3, #6
 8006048:	425b      	negs	r3, r3
}
 800604a:	0018      	movs	r0, r3
 800604c:	46bd      	mov	sp, r7
 800604e:	b00d      	add	sp, #52	; 0x34
 8006050:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006052:	46c0      	nop			; (mov r8, r8)
 8006054:	0801ee78 	.word	0x0801ee78
 8006058:	0000ffff 	.word	0x0000ffff
 800605c:	0801ee7c 	.word	0x0801ee7c
 8006060:	0801ee80 	.word	0x0801ee80

08006064 <http_wait_headers>:

/** Wait for all headers to be received, return its length and content-length (if available) */
static err_t
http_wait_headers(struct pbuf *p, u32_t *content_length, u16_t *total_header_len)
{
 8006064:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006066:	b08d      	sub	sp, #52	; 0x34
 8006068:	af00      	add	r7, sp, #0
 800606a:	60f8      	str	r0, [r7, #12]
 800606c:	60b9      	str	r1, [r7, #8]
 800606e:	607a      	str	r2, [r7, #4]
  u16_t end1 = pbuf_memfind(p, "\r\n\r\n", 4, 0);
 8006070:	252e      	movs	r5, #46	; 0x2e
 8006072:	197c      	adds	r4, r7, r5
 8006074:	4938      	ldr	r1, [pc, #224]	; (8006158 <http_wait_headers+0xf4>)
 8006076:	68f8      	ldr	r0, [r7, #12]
 8006078:	2300      	movs	r3, #0
 800607a:	2204      	movs	r2, #4
 800607c:	f004 fd26 	bl	800aacc <pbuf_memfind>
 8006080:	0003      	movs	r3, r0
 8006082:	8023      	strh	r3, [r4, #0]
  if (end1 < (0xFFFF - 2)) {
 8006084:	0029      	movs	r1, r5
 8006086:	187b      	adds	r3, r7, r1
 8006088:	881b      	ldrh	r3, [r3, #0]
 800608a:	4a34      	ldr	r2, [pc, #208]	; (800615c <http_wait_headers+0xf8>)
 800608c:	4293      	cmp	r3, r2
 800608e:	d85c      	bhi.n	800614a <http_wait_headers+0xe6>
    /* all headers received */
    /* check if we have a content length (@todo: case insensitive?) */
    u16_t content_len_hdr;
    *content_length = HTTPC_CONTENT_LEN_INVALID;
 8006090:	68bb      	ldr	r3, [r7, #8]
 8006092:	2201      	movs	r2, #1
 8006094:	4252      	negs	r2, r2
 8006096:	601a      	str	r2, [r3, #0]
    *total_header_len = end1 + 4;
 8006098:	187b      	adds	r3, r7, r1
 800609a:	881b      	ldrh	r3, [r3, #0]
 800609c:	3304      	adds	r3, #4
 800609e:	b29a      	uxth	r2, r3
 80060a0:	687b      	ldr	r3, [r7, #4]
 80060a2:	801a      	strh	r2, [r3, #0]

    content_len_hdr = pbuf_memfind(p, "Content-Length: ", 16, 0);
 80060a4:	252c      	movs	r5, #44	; 0x2c
 80060a6:	197c      	adds	r4, r7, r5
 80060a8:	492d      	ldr	r1, [pc, #180]	; (8006160 <http_wait_headers+0xfc>)
 80060aa:	68f8      	ldr	r0, [r7, #12]
 80060ac:	2300      	movs	r3, #0
 80060ae:	2210      	movs	r2, #16
 80060b0:	f004 fd0c 	bl	800aacc <pbuf_memfind>
 80060b4:	0003      	movs	r3, r0
 80060b6:	8023      	strh	r3, [r4, #0]
    if (content_len_hdr != 0xFFFF) {
 80060b8:	197b      	adds	r3, r7, r5
 80060ba:	881b      	ldrh	r3, [r3, #0]
 80060bc:	4a29      	ldr	r2, [pc, #164]	; (8006164 <http_wait_headers+0x100>)
 80060be:	4293      	cmp	r3, r2
 80060c0:	d041      	beq.n	8006146 <http_wait_headers+0xe2>
      u16_t content_len_line_end = pbuf_memfind(p, "\r\n", 2, content_len_hdr);
 80060c2:	262a      	movs	r6, #42	; 0x2a
 80060c4:	19bc      	adds	r4, r7, r6
 80060c6:	197b      	adds	r3, r7, r5
 80060c8:	881b      	ldrh	r3, [r3, #0]
 80060ca:	4927      	ldr	r1, [pc, #156]	; (8006168 <http_wait_headers+0x104>)
 80060cc:	68f8      	ldr	r0, [r7, #12]
 80060ce:	2202      	movs	r2, #2
 80060d0:	f004 fcfc 	bl	800aacc <pbuf_memfind>
 80060d4:	0003      	movs	r3, r0
 80060d6:	8023      	strh	r3, [r4, #0]
      if (content_len_line_end != 0xFFFF) {
 80060d8:	19bb      	adds	r3, r7, r6
 80060da:	881b      	ldrh	r3, [r3, #0]
 80060dc:	4a21      	ldr	r2, [pc, #132]	; (8006164 <http_wait_headers+0x100>)
 80060de:	4293      	cmp	r3, r2
 80060e0:	d031      	beq.n	8006146 <http_wait_headers+0xe2>
        char content_len_num[16];
        u16_t content_len_num_len = (u16_t)(content_len_line_end - content_len_hdr - 16);
 80060e2:	19ba      	adds	r2, r7, r6
 80060e4:	002c      	movs	r4, r5
 80060e6:	193b      	adds	r3, r7, r4
 80060e8:	8812      	ldrh	r2, [r2, #0]
 80060ea:	881b      	ldrh	r3, [r3, #0]
 80060ec:	1ad3      	subs	r3, r2, r3
 80060ee:	b29a      	uxth	r2, r3
 80060f0:	2528      	movs	r5, #40	; 0x28
 80060f2:	197b      	adds	r3, r7, r5
 80060f4:	3a10      	subs	r2, #16
 80060f6:	801a      	strh	r2, [r3, #0]
        memset(content_len_num, 0, sizeof(content_len_num));
 80060f8:	2614      	movs	r6, #20
 80060fa:	19bb      	adds	r3, r7, r6
 80060fc:	2210      	movs	r2, #16
 80060fe:	2100      	movs	r1, #0
 8006100:	0018      	movs	r0, r3
 8006102:	f016 feff 	bl	801cf04 <memset>
        if (pbuf_copy_partial(p, content_len_num, content_len_num_len, content_len_hdr + 16) == content_len_num_len) {
 8006106:	193b      	adds	r3, r7, r4
 8006108:	881b      	ldrh	r3, [r3, #0]
 800610a:	3310      	adds	r3, #16
 800610c:	b29c      	uxth	r4, r3
 800610e:	197b      	adds	r3, r7, r5
 8006110:	881a      	ldrh	r2, [r3, #0]
 8006112:	19b9      	adds	r1, r7, r6
 8006114:	68f8      	ldr	r0, [r7, #12]
 8006116:	0023      	movs	r3, r4
 8006118:	f004 f99a 	bl	800a450 <pbuf_copy_partial>
 800611c:	0003      	movs	r3, r0
 800611e:	001a      	movs	r2, r3
 8006120:	197b      	adds	r3, r7, r5
 8006122:	881b      	ldrh	r3, [r3, #0]
 8006124:	4293      	cmp	r3, r2
 8006126:	d10e      	bne.n	8006146 <http_wait_headers+0xe2>
          int len = atoi(content_len_num);
 8006128:	19bb      	adds	r3, r7, r6
 800612a:	0018      	movs	r0, r3
 800612c:	f016 fe8c 	bl	801ce48 <atoi>
 8006130:	0003      	movs	r3, r0
 8006132:	627b      	str	r3, [r7, #36]	; 0x24
          if ((len >= 0) && ((u32_t)len < HTTPC_CONTENT_LEN_INVALID)) {
 8006134:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006136:	2b00      	cmp	r3, #0
 8006138:	db05      	blt.n	8006146 <http_wait_headers+0xe2>
 800613a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800613c:	3301      	adds	r3, #1
 800613e:	d002      	beq.n	8006146 <http_wait_headers+0xe2>
            *content_length = (u32_t)len;
 8006140:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8006142:	68bb      	ldr	r3, [r7, #8]
 8006144:	601a      	str	r2, [r3, #0]
          }
        }
      }
    }
    return ERR_OK;
 8006146:	2300      	movs	r3, #0
 8006148:	e001      	b.n	800614e <http_wait_headers+0xea>
  }
  return ERR_VAL;
 800614a:	2306      	movs	r3, #6
 800614c:	425b      	negs	r3, r3
}
 800614e:	0018      	movs	r0, r3
 8006150:	46bd      	mov	sp, r7
 8006152:	b00d      	add	sp, #52	; 0x34
 8006154:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006156:	46c0      	nop			; (mov r8, r8)
 8006158:	0801ee88 	.word	0x0801ee88
 800615c:	0000fffc 	.word	0x0000fffc
 8006160:	0801ee90 	.word	0x0801ee90
 8006164:	0000ffff 	.word	0x0000ffff
 8006168:	0801ee78 	.word	0x0801ee78

0800616c <httpc_tcp_recv>:

/** http client tcp recv callback */
static err_t
httpc_tcp_recv(void *arg, struct altcp_pcb *pcb, struct pbuf *p, err_t r)
{
 800616c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800616e:	b08d      	sub	sp, #52	; 0x34
 8006170:	af02      	add	r7, sp, #8
 8006172:	60f8      	str	r0, [r7, #12]
 8006174:	60b9      	str	r1, [r7, #8]
 8006176:	607a      	str	r2, [r7, #4]
 8006178:	001a      	movs	r2, r3
 800617a:	1cfb      	adds	r3, r7, #3
 800617c:	701a      	strb	r2, [r3, #0]
  httpc_state_t* req = (httpc_state_t*)arg;
 800617e:	68fb      	ldr	r3, [r7, #12]
 8006180:	623b      	str	r3, [r7, #32]
  LWIP_UNUSED_ARG(r);

  if (p == NULL) {
 8006182:	687b      	ldr	r3, [r7, #4]
 8006184:	2b00      	cmp	r3, #0
 8006186:	d128      	bne.n	80061da <httpc_tcp_recv+0x6e>
    httpc_result_t result;
    if (req->parse_state != HTTPC_PARSE_RX_DATA) {
 8006188:	6a3b      	ldr	r3, [r7, #32]
 800618a:	2230      	movs	r2, #48	; 0x30
 800618c:	5c9b      	ldrb	r3, [r3, r2]
 800618e:	2b02      	cmp	r3, #2
 8006190:	d004      	beq.n	800619c <httpc_tcp_recv+0x30>
      /* did not get RX data yet */
      result = HTTPC_RESULT_ERR_CLOSED;
 8006192:	2327      	movs	r3, #39	; 0x27
 8006194:	18fb      	adds	r3, r7, r3
 8006196:	2204      	movs	r2, #4
 8006198:	701a      	strb	r2, [r3, #0]
 800619a:	e012      	b.n	80061c2 <httpc_tcp_recv+0x56>
    } else if ((req->hdr_content_len != HTTPC_CONTENT_LEN_INVALID) &&
 800619c:	6a3b      	ldr	r3, [r7, #32]
 800619e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80061a0:	3301      	adds	r3, #1
 80061a2:	d00a      	beq.n	80061ba <httpc_tcp_recv+0x4e>
      (req->hdr_content_len != req->rx_content_len)) {
 80061a4:	6a3b      	ldr	r3, [r7, #32]
 80061a6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80061a8:	6a3b      	ldr	r3, [r7, #32]
 80061aa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    } else if ((req->hdr_content_len != HTTPC_CONTENT_LEN_INVALID) &&
 80061ac:	429a      	cmp	r2, r3
 80061ae:	d004      	beq.n	80061ba <httpc_tcp_recv+0x4e>
      /* header has been received with content length but not all data received */
      result = HTTPC_RESULT_ERR_CONTENT_LEN;
 80061b0:	2327      	movs	r3, #39	; 0x27
 80061b2:	18fb      	adds	r3, r7, r3
 80061b4:	2209      	movs	r2, #9
 80061b6:	701a      	strb	r2, [r3, #0]
 80061b8:	e003      	b.n	80061c2 <httpc_tcp_recv+0x56>
    } else {
      /* receiving data and either all data received or no content length header */
      result = HTTPC_RESULT_OK;
 80061ba:	2327      	movs	r3, #39	; 0x27
 80061bc:	18fb      	adds	r3, r7, r3
 80061be:	2200      	movs	r2, #0
 80061c0:	701a      	strb	r2, [r3, #0]
    }
    return httpc_close(req, result, req->rx_status, ERR_OK);
 80061c2:	6a3b      	ldr	r3, [r7, #32]
 80061c4:	8b5b      	ldrh	r3, [r3, #26]
 80061c6:	001a      	movs	r2, r3
 80061c8:	2327      	movs	r3, #39	; 0x27
 80061ca:	18fb      	adds	r3, r7, r3
 80061cc:	7819      	ldrb	r1, [r3, #0]
 80061ce:	6a38      	ldr	r0, [r7, #32]
 80061d0:	2300      	movs	r3, #0
 80061d2:	f7ff fe50 	bl	8005e76 <httpc_close>
 80061d6:	0003      	movs	r3, r0
 80061d8:	e0bd      	b.n	8006356 <httpc_tcp_recv+0x1ea>
  }
  if (req->parse_state != HTTPC_PARSE_RX_DATA) {
 80061da:	6a3b      	ldr	r3, [r7, #32]
 80061dc:	2230      	movs	r2, #48	; 0x30
 80061de:	5c9b      	ldrb	r3, [r3, r2]
 80061e0:	2b02      	cmp	r3, #2
 80061e2:	d100      	bne.n	80061e6 <httpc_tcp_recv+0x7a>
 80061e4:	e08c      	b.n	8006300 <httpc_tcp_recv+0x194>
    if (req->rx_hdrs == NULL) {
 80061e6:	6a3b      	ldr	r3, [r7, #32]
 80061e8:	695b      	ldr	r3, [r3, #20]
 80061ea:	2b00      	cmp	r3, #0
 80061ec:	d103      	bne.n	80061f6 <httpc_tcp_recv+0x8a>
      req->rx_hdrs = p;
 80061ee:	6a3b      	ldr	r3, [r7, #32]
 80061f0:	687a      	ldr	r2, [r7, #4]
 80061f2:	615a      	str	r2, [r3, #20]
 80061f4:	e006      	b.n	8006204 <httpc_tcp_recv+0x98>
    } else {
      pbuf_cat(req->rx_hdrs, p);
 80061f6:	6a3b      	ldr	r3, [r7, #32]
 80061f8:	695b      	ldr	r3, [r3, #20]
 80061fa:	687a      	ldr	r2, [r7, #4]
 80061fc:	0011      	movs	r1, r2
 80061fe:	0018      	movs	r0, r3
 8006200:	f003 ff3c 	bl	800a07c <pbuf_cat>
    }
    if (req->parse_state == HTTPC_PARSE_WAIT_FIRST_LINE) {
 8006204:	6a3b      	ldr	r3, [r7, #32]
 8006206:	2230      	movs	r2, #48	; 0x30
 8006208:	5c9b      	ldrb	r3, [r3, r2]
 800620a:	2b00      	cmp	r3, #0
 800620c:	d118      	bne.n	8006240 <httpc_tcp_recv+0xd4>
      u16_t status_str_off;
      err_t err = http_parse_response_status(req->rx_hdrs, &req->rx_http_version, &req->rx_status, &status_str_off);
 800620e:	6a3b      	ldr	r3, [r7, #32]
 8006210:	6958      	ldr	r0, [r3, #20]
 8006212:	6a3b      	ldr	r3, [r7, #32]
 8006214:	3318      	adds	r3, #24
 8006216:	0019      	movs	r1, r3
 8006218:	6a3b      	ldr	r3, [r7, #32]
 800621a:	331a      	adds	r3, #26
 800621c:	001a      	movs	r2, r3
 800621e:	251f      	movs	r5, #31
 8006220:	197c      	adds	r4, r7, r5
 8006222:	2316      	movs	r3, #22
 8006224:	18fb      	adds	r3, r7, r3
 8006226:	f7ff fe5d 	bl	8005ee4 <http_parse_response_status>
 800622a:	0003      	movs	r3, r0
 800622c:	7023      	strb	r3, [r4, #0]
      if (err == ERR_OK) {
 800622e:	197b      	adds	r3, r7, r5
 8006230:	781b      	ldrb	r3, [r3, #0]
 8006232:	b25b      	sxtb	r3, r3
 8006234:	2b00      	cmp	r3, #0
 8006236:	d103      	bne.n	8006240 <httpc_tcp_recv+0xd4>
        /* don't care status string */
        req->parse_state = HTTPC_PARSE_WAIT_HEADERS;
 8006238:	6a3b      	ldr	r3, [r7, #32]
 800623a:	2230      	movs	r2, #48	; 0x30
 800623c:	2101      	movs	r1, #1
 800623e:	5499      	strb	r1, [r3, r2]
      }
    }
    if (req->parse_state == HTTPC_PARSE_WAIT_HEADERS) {
 8006240:	6a3b      	ldr	r3, [r7, #32]
 8006242:	2230      	movs	r2, #48	; 0x30
 8006244:	5c9b      	ldrb	r3, [r3, r2]
 8006246:	2b01      	cmp	r3, #1
 8006248:	d15a      	bne.n	8006300 <httpc_tcp_recv+0x194>
      u16_t total_header_len;
      err_t err = http_wait_headers(req->rx_hdrs, &req->hdr_content_len, &total_header_len);
 800624a:	6a3b      	ldr	r3, [r7, #32]
 800624c:	6958      	ldr	r0, [r3, #20]
 800624e:	6a3b      	ldr	r3, [r7, #32]
 8006250:	332c      	adds	r3, #44	; 0x2c
 8006252:	251e      	movs	r5, #30
 8006254:	197c      	adds	r4, r7, r5
 8006256:	2614      	movs	r6, #20
 8006258:	19ba      	adds	r2, r7, r6
 800625a:	0019      	movs	r1, r3
 800625c:	f7ff ff02 	bl	8006064 <http_wait_headers>
 8006260:	0003      	movs	r3, r0
 8006262:	7023      	strb	r3, [r4, #0]
      if (err == ERR_OK) {
 8006264:	002c      	movs	r4, r5
 8006266:	193b      	adds	r3, r7, r4
 8006268:	781b      	ldrb	r3, [r3, #0]
 800626a:	b25b      	sxtb	r3, r3
 800626c:	2b00      	cmp	r3, #0
 800626e:	d147      	bne.n	8006300 <httpc_tcp_recv+0x194>
        struct pbuf *q;
        /* full header received, send window update for header bytes and call into client callback */
        altcp_recved(pcb, total_header_len);
 8006270:	19bb      	adds	r3, r7, r6
 8006272:	881a      	ldrh	r2, [r3, #0]
 8006274:	68bb      	ldr	r3, [r7, #8]
 8006276:	0011      	movs	r1, r2
 8006278:	0018      	movs	r0, r3
 800627a:	f004 fff9 	bl	800b270 <tcp_recved>
        if (req->conn_settings) {
 800627e:	6a3b      	ldr	r3, [r7, #32]
 8006280:	6a1b      	ldr	r3, [r3, #32]
 8006282:	2b00      	cmp	r3, #0
 8006284:	d028      	beq.n	80062d8 <httpc_tcp_recv+0x16c>
          if (req->conn_settings->headers_done_fn) {
 8006286:	6a3b      	ldr	r3, [r7, #32]
 8006288:	6a1b      	ldr	r3, [r3, #32]
 800628a:	68db      	ldr	r3, [r3, #12]
 800628c:	2b00      	cmp	r3, #0
 800628e:	d023      	beq.n	80062d8 <httpc_tcp_recv+0x16c>
            err = req->conn_settings->headers_done_fn(req, req->callback_arg, req->rx_hdrs, total_header_len, req->hdr_content_len);
 8006290:	6a3b      	ldr	r3, [r7, #32]
 8006292:	6a1b      	ldr	r3, [r3, #32]
 8006294:	68dd      	ldr	r5, [r3, #12]
 8006296:	6a3b      	ldr	r3, [r7, #32]
 8006298:	6a59      	ldr	r1, [r3, #36]	; 0x24
 800629a:	6a3b      	ldr	r3, [r7, #32]
 800629c:	695a      	ldr	r2, [r3, #20]
 800629e:	19bb      	adds	r3, r7, r6
 80062a0:	881e      	ldrh	r6, [r3, #0]
 80062a2:	6a3b      	ldr	r3, [r7, #32]
 80062a4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80062a6:	193c      	adds	r4, r7, r4
 80062a8:	6a38      	ldr	r0, [r7, #32]
 80062aa:	9300      	str	r3, [sp, #0]
 80062ac:	0033      	movs	r3, r6
 80062ae:	47a8      	blx	r5
 80062b0:	0003      	movs	r3, r0
 80062b2:	7023      	strb	r3, [r4, #0]
            if (err != ERR_OK) {
 80062b4:	241e      	movs	r4, #30
 80062b6:	193b      	adds	r3, r7, r4
 80062b8:	781b      	ldrb	r3, [r3, #0]
 80062ba:	b25b      	sxtb	r3, r3
 80062bc:	2b00      	cmp	r3, #0
 80062be:	d00b      	beq.n	80062d8 <httpc_tcp_recv+0x16c>
              return httpc_close(req, HTTPC_RESULT_LOCAL_ABORT, req->rx_status, err);
 80062c0:	6a3b      	ldr	r3, [r7, #32]
 80062c2:	8b5b      	ldrh	r3, [r3, #26]
 80062c4:	001a      	movs	r2, r3
 80062c6:	193b      	adds	r3, r7, r4
 80062c8:	781b      	ldrb	r3, [r3, #0]
 80062ca:	b25b      	sxtb	r3, r3
 80062cc:	6a38      	ldr	r0, [r7, #32]
 80062ce:	2108      	movs	r1, #8
 80062d0:	f7ff fdd1 	bl	8005e76 <httpc_close>
 80062d4:	0003      	movs	r3, r0
 80062d6:	e03e      	b.n	8006356 <httpc_tcp_recv+0x1ea>
            }
          }
        }
        /* hide header bytes in pbuf */
        q = pbuf_free_header(req->rx_hdrs, total_header_len);
 80062d8:	6a3b      	ldr	r3, [r7, #32]
 80062da:	695a      	ldr	r2, [r3, #20]
 80062dc:	2314      	movs	r3, #20
 80062de:	18fb      	adds	r3, r7, r3
 80062e0:	881b      	ldrh	r3, [r3, #0]
 80062e2:	0019      	movs	r1, r3
 80062e4:	0010      	movs	r0, r2
 80062e6:	f003 fda6 	bl	8009e36 <pbuf_free_header>
 80062ea:	0003      	movs	r3, r0
 80062ec:	61bb      	str	r3, [r7, #24]
        p = q;
 80062ee:	69bb      	ldr	r3, [r7, #24]
 80062f0:	607b      	str	r3, [r7, #4]
        req->rx_hdrs = NULL;
 80062f2:	6a3b      	ldr	r3, [r7, #32]
 80062f4:	2200      	movs	r2, #0
 80062f6:	615a      	str	r2, [r3, #20]
        /* go on with data */
        req->parse_state = HTTPC_PARSE_RX_DATA;
 80062f8:	6a3b      	ldr	r3, [r7, #32]
 80062fa:	2230      	movs	r2, #48	; 0x30
 80062fc:	2102      	movs	r1, #2
 80062fe:	5499      	strb	r1, [r3, r2]
      }
    }
  }
  if ((p != NULL) && (req->parse_state == HTTPC_PARSE_RX_DATA)) {
 8006300:	687b      	ldr	r3, [r7, #4]
 8006302:	2b00      	cmp	r3, #0
 8006304:	d026      	beq.n	8006354 <httpc_tcp_recv+0x1e8>
 8006306:	6a3b      	ldr	r3, [r7, #32]
 8006308:	2230      	movs	r2, #48	; 0x30
 800630a:	5c9b      	ldrb	r3, [r3, r2]
 800630c:	2b02      	cmp	r3, #2
 800630e:	d121      	bne.n	8006354 <httpc_tcp_recv+0x1e8>
    req->rx_content_len += p->tot_len;
 8006310:	6a3b      	ldr	r3, [r7, #32]
 8006312:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006314:	687a      	ldr	r2, [r7, #4]
 8006316:	8912      	ldrh	r2, [r2, #8]
 8006318:	189a      	adds	r2, r3, r2
 800631a:	6a3b      	ldr	r3, [r7, #32]
 800631c:	629a      	str	r2, [r3, #40]	; 0x28
    if (req->recv_fn != NULL) {
 800631e:	6a3b      	ldr	r3, [r7, #32]
 8006320:	69db      	ldr	r3, [r3, #28]
 8006322:	2b00      	cmp	r3, #0
 8006324:	d00b      	beq.n	800633e <httpc_tcp_recv+0x1d2>
      /* directly return here: the connection migth already be aborted from the callback! */
      return req->recv_fn(req->callback_arg, pcb, p, r);
 8006326:	6a3b      	ldr	r3, [r7, #32]
 8006328:	69dc      	ldr	r4, [r3, #28]
 800632a:	6a3b      	ldr	r3, [r7, #32]
 800632c:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800632e:	1cfb      	adds	r3, r7, #3
 8006330:	781b      	ldrb	r3, [r3, #0]
 8006332:	b25b      	sxtb	r3, r3
 8006334:	687a      	ldr	r2, [r7, #4]
 8006336:	68b9      	ldr	r1, [r7, #8]
 8006338:	47a0      	blx	r4
 800633a:	0003      	movs	r3, r0
 800633c:	e00b      	b.n	8006356 <httpc_tcp_recv+0x1ea>
    } else {
      altcp_recved(pcb, p->tot_len);
 800633e:	687b      	ldr	r3, [r7, #4]
 8006340:	891a      	ldrh	r2, [r3, #8]
 8006342:	68bb      	ldr	r3, [r7, #8]
 8006344:	0011      	movs	r1, r2
 8006346:	0018      	movs	r0, r3
 8006348:	f004 ff92 	bl	800b270 <tcp_recved>
      pbuf_free(p);
 800634c:	687b      	ldr	r3, [r7, #4]
 800634e:	0018      	movs	r0, r3
 8006350:	f003 fdb4 	bl	8009ebc <pbuf_free>
    }
  }
  return ERR_OK;
 8006354:	2300      	movs	r3, #0
}
 8006356:	0018      	movs	r0, r3
 8006358:	46bd      	mov	sp, r7
 800635a:	b00b      	add	sp, #44	; 0x2c
 800635c:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800635e <httpc_tcp_err>:

/** http client tcp err callback */
static void
httpc_tcp_err(void *arg, err_t err)
{
 800635e:	b580      	push	{r7, lr}
 8006360:	b084      	sub	sp, #16
 8006362:	af00      	add	r7, sp, #0
 8006364:	6078      	str	r0, [r7, #4]
 8006366:	000a      	movs	r2, r1
 8006368:	1cfb      	adds	r3, r7, #3
 800636a:	701a      	strb	r2, [r3, #0]
  httpc_state_t* req = (httpc_state_t*)arg;
 800636c:	687b      	ldr	r3, [r7, #4]
 800636e:	60fb      	str	r3, [r7, #12]
  if (req != NULL) {
 8006370:	68fb      	ldr	r3, [r7, #12]
 8006372:	2b00      	cmp	r3, #0
 8006374:	d00a      	beq.n	800638c <httpc_tcp_err+0x2e>
    /* pcb has already been deallocated */
    req->pcb = NULL;
 8006376:	68fb      	ldr	r3, [r7, #12]
 8006378:	2200      	movs	r2, #0
 800637a:	601a      	str	r2, [r3, #0]
    httpc_close(req, HTTPC_RESULT_ERR_CLOSED, 0, err);
 800637c:	1cfb      	adds	r3, r7, #3
 800637e:	781b      	ldrb	r3, [r3, #0]
 8006380:	b25b      	sxtb	r3, r3
 8006382:	68f8      	ldr	r0, [r7, #12]
 8006384:	2200      	movs	r2, #0
 8006386:	2104      	movs	r1, #4
 8006388:	f7ff fd75 	bl	8005e76 <httpc_close>
  }
}
 800638c:	46c0      	nop			; (mov r8, r8)
 800638e:	46bd      	mov	sp, r7
 8006390:	b004      	add	sp, #16
 8006392:	bd80      	pop	{r7, pc}

08006394 <httpc_tcp_poll>:

/** http client tcp poll callback */
static err_t
httpc_tcp_poll(void *arg, struct altcp_pcb *pcb)
{
 8006394:	b580      	push	{r7, lr}
 8006396:	b084      	sub	sp, #16
 8006398:	af00      	add	r7, sp, #0
 800639a:	6078      	str	r0, [r7, #4]
 800639c:	6039      	str	r1, [r7, #0]
  /* implement timeout */
  httpc_state_t* req = (httpc_state_t*)arg;
 800639e:	687b      	ldr	r3, [r7, #4]
 80063a0:	60fb      	str	r3, [r7, #12]
  LWIP_UNUSED_ARG(pcb);
  if (req != NULL) {
 80063a2:	68fb      	ldr	r3, [r7, #12]
 80063a4:	2b00      	cmp	r3, #0
 80063a6:	d014      	beq.n	80063d2 <httpc_tcp_poll+0x3e>
    if (req->timeout_ticks) {
 80063a8:	68fb      	ldr	r3, [r7, #12]
 80063aa:	68db      	ldr	r3, [r3, #12]
 80063ac:	2b00      	cmp	r3, #0
 80063ae:	d004      	beq.n	80063ba <httpc_tcp_poll+0x26>
      req->timeout_ticks--;
 80063b0:	68fb      	ldr	r3, [r7, #12]
 80063b2:	68db      	ldr	r3, [r3, #12]
 80063b4:	1e5a      	subs	r2, r3, #1
 80063b6:	68fb      	ldr	r3, [r7, #12]
 80063b8:	60da      	str	r2, [r3, #12]
    }
    if (!req->timeout_ticks) {
 80063ba:	68fb      	ldr	r3, [r7, #12]
 80063bc:	68db      	ldr	r3, [r3, #12]
 80063be:	2b00      	cmp	r3, #0
 80063c0:	d107      	bne.n	80063d2 <httpc_tcp_poll+0x3e>
      return httpc_close(req, HTTPC_RESULT_ERR_TIMEOUT, 0, ERR_OK);
 80063c2:	68f8      	ldr	r0, [r7, #12]
 80063c4:	2300      	movs	r3, #0
 80063c6:	2200      	movs	r2, #0
 80063c8:	2105      	movs	r1, #5
 80063ca:	f7ff fd54 	bl	8005e76 <httpc_close>
 80063ce:	0003      	movs	r3, r0
 80063d0:	e000      	b.n	80063d4 <httpc_tcp_poll+0x40>
    }
  }
  return ERR_OK;
 80063d2:	2300      	movs	r3, #0
}
 80063d4:	0018      	movs	r0, r3
 80063d6:	46bd      	mov	sp, r7
 80063d8:	b004      	add	sp, #16
 80063da:	bd80      	pop	{r7, pc}

080063dc <httpc_tcp_sent>:

/** http client tcp sent callback */
static err_t
httpc_tcp_sent(void *arg, struct altcp_pcb *pcb, u16_t len)
{
 80063dc:	b580      	push	{r7, lr}
 80063de:	b084      	sub	sp, #16
 80063e0:	af00      	add	r7, sp, #0
 80063e2:	60f8      	str	r0, [r7, #12]
 80063e4:	60b9      	str	r1, [r7, #8]
 80063e6:	1dbb      	adds	r3, r7, #6
 80063e8:	801a      	strh	r2, [r3, #0]
  /* nothing to do here for now */
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(len);
  return ERR_OK;
 80063ea:	2300      	movs	r3, #0
}
 80063ec:	0018      	movs	r0, r3
 80063ee:	46bd      	mov	sp, r7
 80063f0:	b004      	add	sp, #16
 80063f2:	bd80      	pop	{r7, pc}

080063f4 <httpc_tcp_connected>:

/** http client tcp connected callback */
static err_t
httpc_tcp_connected(void *arg, struct altcp_pcb *pcb, err_t err)
{
 80063f4:	b5b0      	push	{r4, r5, r7, lr}
 80063f6:	b086      	sub	sp, #24
 80063f8:	af00      	add	r7, sp, #0
 80063fa:	60f8      	str	r0, [r7, #12]
 80063fc:	60b9      	str	r1, [r7, #8]
 80063fe:	1dfb      	adds	r3, r7, #7
 8006400:	701a      	strb	r2, [r3, #0]
  err_t r;
  httpc_state_t* req = (httpc_state_t*)arg;
 8006402:	68fb      	ldr	r3, [r7, #12]
 8006404:	617b      	str	r3, [r7, #20]
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  /* send request; last char is zero termination */
  r = altcp_write(req->pcb, req->request->payload, req->request->len - 1, TCP_WRITE_FLAG_COPY);
 8006406:	697b      	ldr	r3, [r7, #20]
 8006408:	6818      	ldr	r0, [r3, #0]
 800640a:	697b      	ldr	r3, [r7, #20]
 800640c:	691b      	ldr	r3, [r3, #16]
 800640e:	6859      	ldr	r1, [r3, #4]
 8006410:	697b      	ldr	r3, [r7, #20]
 8006412:	691b      	ldr	r3, [r3, #16]
 8006414:	895b      	ldrh	r3, [r3, #10]
 8006416:	3b01      	subs	r3, #1
 8006418:	b29a      	uxth	r2, r3
 800641a:	2513      	movs	r5, #19
 800641c:	197c      	adds	r4, r7, r5
 800641e:	2301      	movs	r3, #1
 8006420:	f009 fba4 	bl	800fb6c <tcp_write>
 8006424:	0003      	movs	r3, r0
 8006426:	7023      	strb	r3, [r4, #0]
  if (r != ERR_OK) {
 8006428:	197b      	adds	r3, r7, r5
 800642a:	781b      	ldrb	r3, [r3, #0]
 800642c:	b25b      	sxtb	r3, r3
 800642e:	2b00      	cmp	r3, #0
 8006430:	d009      	beq.n	8006446 <httpc_tcp_connected+0x52>
     /* could not write the single small request -> fail, don't retry */
     return httpc_close(req, HTTPC_RESULT_ERR_MEM, 0, r);
 8006432:	197b      	adds	r3, r7, r5
 8006434:	781b      	ldrb	r3, [r3, #0]
 8006436:	b25b      	sxtb	r3, r3
 8006438:	6978      	ldr	r0, [r7, #20]
 800643a:	2200      	movs	r2, #0
 800643c:	2107      	movs	r1, #7
 800643e:	f7ff fd1a 	bl	8005e76 <httpc_close>
 8006442:	0003      	movs	r3, r0
 8006444:	e00d      	b.n	8006462 <httpc_tcp_connected+0x6e>
  }
  /* everything written, we can free the request */
  pbuf_free(req->request);
 8006446:	697b      	ldr	r3, [r7, #20]
 8006448:	691b      	ldr	r3, [r3, #16]
 800644a:	0018      	movs	r0, r3
 800644c:	f003 fd36 	bl	8009ebc <pbuf_free>
  req->request = NULL;
 8006450:	697b      	ldr	r3, [r7, #20]
 8006452:	2200      	movs	r2, #0
 8006454:	611a      	str	r2, [r3, #16]

  altcp_output(req->pcb);
 8006456:	697b      	ldr	r3, [r7, #20]
 8006458:	681b      	ldr	r3, [r3, #0]
 800645a:	0018      	movs	r0, r3
 800645c:	f00a fc8e 	bl	8010d7c <tcp_output>
  return ERR_OK;
 8006460:	2300      	movs	r3, #0
}
 8006462:	0018      	movs	r0, r3
 8006464:	46bd      	mov	sp, r7
 8006466:	b006      	add	sp, #24
 8006468:	bdb0      	pop	{r4, r5, r7, pc}
	...

0800646c <httpc_get_internal_addr>:

/** Start the http request when the server IP addr is known */
static err_t
httpc_get_internal_addr(httpc_state_t* req, const ip_addr_t *ipaddr)
{
 800646c:	b5b0      	push	{r4, r5, r7, lr}
 800646e:	b084      	sub	sp, #16
 8006470:	af00      	add	r7, sp, #0
 8006472:	6078      	str	r0, [r7, #4]
 8006474:	6039      	str	r1, [r7, #0]
  err_t err;
  LWIP_ASSERT("req != NULL", req != NULL);
 8006476:	687b      	ldr	r3, [r7, #4]
 8006478:	2b00      	cmp	r3, #0
 800647a:	d106      	bne.n	800648a <httpc_get_internal_addr+0x1e>
 800647c:	4b19      	ldr	r3, [pc, #100]	; (80064e4 <httpc_get_internal_addr+0x78>)
 800647e:	22d2      	movs	r2, #210	; 0xd2
 8006480:	0052      	lsls	r2, r2, #1
 8006482:	4919      	ldr	r1, [pc, #100]	; (80064e8 <httpc_get_internal_addr+0x7c>)
 8006484:	4819      	ldr	r0, [pc, #100]	; (80064ec <httpc_get_internal_addr+0x80>)
 8006486:	f7fc fb9f 	bl	8002bc8 <app_debug_rtt_raw>

  if (&req->remote_addr != ipaddr) {
 800648a:	687b      	ldr	r3, [r7, #4]
 800648c:	3304      	adds	r3, #4
 800648e:	683a      	ldr	r2, [r7, #0]
 8006490:	429a      	cmp	r2, r3
 8006492:	d003      	beq.n	800649c <httpc_get_internal_addr+0x30>
    /* fill in remote addr if called externally */
    req->remote_addr = *ipaddr;
 8006494:	687b      	ldr	r3, [r7, #4]
 8006496:	683a      	ldr	r2, [r7, #0]
 8006498:	6812      	ldr	r2, [r2, #0]
 800649a:	605a      	str	r2, [r3, #4]
  }

  err = altcp_connect(req->pcb, &req->remote_addr, req->remote_port, httpc_tcp_connected);
 800649c:	687b      	ldr	r3, [r7, #4]
 800649e:	6818      	ldr	r0, [r3, #0]
 80064a0:	687b      	ldr	r3, [r7, #4]
 80064a2:	1d19      	adds	r1, r3, #4
 80064a4:	687b      	ldr	r3, [r7, #4]
 80064a6:	891a      	ldrh	r2, [r3, #8]
 80064a8:	250f      	movs	r5, #15
 80064aa:	197c      	adds	r4, r7, r5
 80064ac:	4b10      	ldr	r3, [pc, #64]	; (80064f0 <httpc_get_internal_addr+0x84>)
 80064ae:	f004 ff8b 	bl	800b3c8 <tcp_connect>
 80064b2:	0003      	movs	r3, r0
 80064b4:	7023      	strb	r3, [r4, #0]
  if (err == ERR_OK) {
 80064b6:	197b      	adds	r3, r7, r5
 80064b8:	781b      	ldrb	r3, [r3, #0]
 80064ba:	b25b      	sxtb	r3, r3
 80064bc:	2b00      	cmp	r3, #0
 80064be:	d101      	bne.n	80064c4 <httpc_get_internal_addr+0x58>
    return ERR_OK;
 80064c0:	2300      	movs	r3, #0
 80064c2:	e00b      	b.n	80064dc <httpc_get_internal_addr+0x70>
  }
  LWIP_DEBUGF(HTTPC_DEBUG_WARN_STATE, ("tcp_connect failed: %d\n", (int)err));
 80064c4:	240f      	movs	r4, #15
 80064c6:	193b      	adds	r3, r7, r4
 80064c8:	2200      	movs	r2, #0
 80064ca:	569a      	ldrsb	r2, [r3, r2]
 80064cc:	4b09      	ldr	r3, [pc, #36]	; (80064f4 <httpc_get_internal_addr+0x88>)
 80064ce:	0011      	movs	r1, r2
 80064d0:	0018      	movs	r0, r3
 80064d2:	f7fc fb79 	bl	8002bc8 <app_debug_rtt_raw>
  return err;
 80064d6:	193b      	adds	r3, r7, r4
 80064d8:	781b      	ldrb	r3, [r3, #0]
 80064da:	b25b      	sxtb	r3, r3
}
 80064dc:	0018      	movs	r0, r3
 80064de:	46bd      	mov	sp, r7
 80064e0:	b004      	add	sp, #16
 80064e2:	bdb0      	pop	{r4, r5, r7, pc}
 80064e4:	0801eea4 	.word	0x0801eea4
 80064e8:	0801eed8 	.word	0x0801eed8
 80064ec:	0801eee4 	.word	0x0801eee4
 80064f0:	080063f5 	.word	0x080063f5
 80064f4:	0801ef10 	.word	0x0801ef10

080064f8 <httpc_dns_found>:
/** DNS callback
 * If ipaddr is non-NULL, resolving succeeded and the request can be sent, otherwise it failed.
 */
static void
httpc_dns_found(const char* hostname, const ip_addr_t *ipaddr, void *arg)
{
 80064f8:	b5b0      	push	{r4, r5, r7, lr}
 80064fa:	b086      	sub	sp, #24
 80064fc:	af00      	add	r7, sp, #0
 80064fe:	60f8      	str	r0, [r7, #12]
 8006500:	60b9      	str	r1, [r7, #8]
 8006502:	607a      	str	r2, [r7, #4]
  httpc_state_t* req = (httpc_state_t*)arg;
 8006504:	687b      	ldr	r3, [r7, #4]
 8006506:	613b      	str	r3, [r7, #16]
  err_t err;
  httpc_result_t result;

  LWIP_UNUSED_ARG(hostname);

  if (ipaddr != NULL) {
 8006508:	68bb      	ldr	r3, [r7, #8]
 800650a:	2b00      	cmp	r3, #0
 800650c:	d013      	beq.n	8006536 <httpc_dns_found+0x3e>
    err = httpc_get_internal_addr(req, ipaddr);
 800650e:	2517      	movs	r5, #23
 8006510:	197c      	adds	r4, r7, r5
 8006512:	68ba      	ldr	r2, [r7, #8]
 8006514:	693b      	ldr	r3, [r7, #16]
 8006516:	0011      	movs	r1, r2
 8006518:	0018      	movs	r0, r3
 800651a:	f7ff ffa7 	bl	800646c <httpc_get_internal_addr>
 800651e:	0003      	movs	r3, r0
 8006520:	7023      	strb	r3, [r4, #0]
    if (err == ERR_OK) {
 8006522:	197b      	adds	r3, r7, r5
 8006524:	781b      	ldrb	r3, [r3, #0]
 8006526:	b25b      	sxtb	r3, r3
 8006528:	2b00      	cmp	r3, #0
 800652a:	d01f      	beq.n	800656c <httpc_dns_found+0x74>
      return;
    }
    result = HTTPC_RESULT_ERR_CONNECT;
 800652c:	2316      	movs	r3, #22
 800652e:	18fb      	adds	r3, r7, r3
 8006530:	2202      	movs	r2, #2
 8006532:	701a      	strb	r2, [r3, #0]
 8006534:	e00d      	b.n	8006552 <httpc_dns_found+0x5a>
  } else {
    LWIP_DEBUGF(HTTPC_DEBUG_WARN_STATE, ("httpc_dns_found: failed to resolve hostname: %s\n",
 8006536:	68fa      	ldr	r2, [r7, #12]
 8006538:	4b0e      	ldr	r3, [pc, #56]	; (8006574 <httpc_dns_found+0x7c>)
 800653a:	0011      	movs	r1, r2
 800653c:	0018      	movs	r0, r3
 800653e:	f7fc fb43 	bl	8002bc8 <app_debug_rtt_raw>
      hostname));
    result = HTTPC_RESULT_ERR_HOSTNAME;
 8006542:	2316      	movs	r3, #22
 8006544:	18fb      	adds	r3, r7, r3
 8006546:	2203      	movs	r2, #3
 8006548:	701a      	strb	r2, [r3, #0]
    err = ERR_ARG;
 800654a:	2317      	movs	r3, #23
 800654c:	18fb      	adds	r3, r7, r3
 800654e:	22f0      	movs	r2, #240	; 0xf0
 8006550:	701a      	strb	r2, [r3, #0]
  }
  httpc_close(req, result, 0, err);
 8006552:	2317      	movs	r3, #23
 8006554:	18fb      	adds	r3, r7, r3
 8006556:	2200      	movs	r2, #0
 8006558:	569a      	ldrsb	r2, [r3, r2]
 800655a:	2316      	movs	r3, #22
 800655c:	18fb      	adds	r3, r7, r3
 800655e:	7819      	ldrb	r1, [r3, #0]
 8006560:	6938      	ldr	r0, [r7, #16]
 8006562:	0013      	movs	r3, r2
 8006564:	2200      	movs	r2, #0
 8006566:	f7ff fc86 	bl	8005e76 <httpc_close>
 800656a:	e000      	b.n	800656e <httpc_dns_found+0x76>
      return;
 800656c:	46c0      	nop			; (mov r8, r8)
}
 800656e:	46bd      	mov	sp, r7
 8006570:	b006      	add	sp, #24
 8006572:	bdb0      	pop	{r4, r5, r7, pc}
 8006574:	0801ef28 	.word	0x0801ef28

08006578 <httpc_get_internal_dns>:
#endif /* LWIP_DNS */

/** Start the http request after converting 'server_name' to ip address (DNS or address string) */
static err_t
httpc_get_internal_dns(httpc_state_t* req, const char* server_name)
{
 8006578:	b5b0      	push	{r4, r5, r7, lr}
 800657a:	b084      	sub	sp, #16
 800657c:	af00      	add	r7, sp, #0
 800657e:	6078      	str	r0, [r7, #4]
 8006580:	6039      	str	r1, [r7, #0]
  err_t err;
  LWIP_ASSERT("req != NULL", req != NULL);
 8006582:	687b      	ldr	r3, [r7, #4]
 8006584:	2b00      	cmp	r3, #0
 8006586:	d106      	bne.n	8006596 <httpc_get_internal_dns+0x1e>
 8006588:	4b19      	ldr	r3, [pc, #100]	; (80065f0 <httpc_get_internal_dns+0x78>)
 800658a:	22d6      	movs	r2, #214	; 0xd6
 800658c:	32ff      	adds	r2, #255	; 0xff
 800658e:	4919      	ldr	r1, [pc, #100]	; (80065f4 <httpc_get_internal_dns+0x7c>)
 8006590:	4819      	ldr	r0, [pc, #100]	; (80065f8 <httpc_get_internal_dns+0x80>)
 8006592:	f7fc fb19 	bl	8002bc8 <app_debug_rtt_raw>

#if LWIP_DNS
  err = dns_gethostbyname(server_name, &req->remote_addr, httpc_dns_found, req);
 8006596:	687b      	ldr	r3, [r7, #4]
 8006598:	1d19      	adds	r1, r3, #4
 800659a:	250f      	movs	r5, #15
 800659c:	197c      	adds	r4, r7, r5
 800659e:	687b      	ldr	r3, [r7, #4]
 80065a0:	4a16      	ldr	r2, [pc, #88]	; (80065fc <httpc_get_internal_dns+0x84>)
 80065a2:	6838      	ldr	r0, [r7, #0]
 80065a4:	f001 fdac 	bl	8008100 <dns_gethostbyname>
 80065a8:	0003      	movs	r3, r0
 80065aa:	7023      	strb	r3, [r4, #0]
#else
  err = ipaddr_aton(server_name, &req->remote_addr) ? ERR_OK : ERR_ARG;
#endif

  if (err == ERR_OK) {
 80065ac:	0029      	movs	r1, r5
 80065ae:	187b      	adds	r3, r7, r1
 80065b0:	781b      	ldrb	r3, [r3, #0]
 80065b2:	b25b      	sxtb	r3, r3
 80065b4:	2b00      	cmp	r3, #0
 80065b6:	d10a      	bne.n	80065ce <httpc_get_internal_dns+0x56>
    /* cached or IP-string */
    err = httpc_get_internal_addr(req, &req->remote_addr);
 80065b8:	687b      	ldr	r3, [r7, #4]
 80065ba:	1d1a      	adds	r2, r3, #4
 80065bc:	187c      	adds	r4, r7, r1
 80065be:	687b      	ldr	r3, [r7, #4]
 80065c0:	0011      	movs	r1, r2
 80065c2:	0018      	movs	r0, r3
 80065c4:	f7ff ff52 	bl	800646c <httpc_get_internal_addr>
 80065c8:	0003      	movs	r3, r0
 80065ca:	7023      	strb	r3, [r4, #0]
 80065cc:	e007      	b.n	80065de <httpc_get_internal_dns+0x66>
  } else if (err == ERR_INPROGRESS) {
 80065ce:	230f      	movs	r3, #15
 80065d0:	18fb      	adds	r3, r7, r3
 80065d2:	781b      	ldrb	r3, [r3, #0]
 80065d4:	b25b      	sxtb	r3, r3
 80065d6:	3305      	adds	r3, #5
 80065d8:	d101      	bne.n	80065de <httpc_get_internal_dns+0x66>
    return ERR_OK;
 80065da:	2300      	movs	r3, #0
 80065dc:	e003      	b.n	80065e6 <httpc_get_internal_dns+0x6e>
  }
  return err;
 80065de:	230f      	movs	r3, #15
 80065e0:	18fb      	adds	r3, r7, r3
 80065e2:	781b      	ldrb	r3, [r3, #0]
 80065e4:	b25b      	sxtb	r3, r3
}
 80065e6:	0018      	movs	r0, r3
 80065e8:	46bd      	mov	sp, r7
 80065ea:	b004      	add	sp, #16
 80065ec:	bdb0      	pop	{r4, r5, r7, pc}
 80065ee:	46c0      	nop			; (mov r8, r8)
 80065f0:	0801eea4 	.word	0x0801eea4
 80065f4:	0801eed8 	.word	0x0801eed8
 80065f8:	0801eee4 	.word	0x0801eee4
 80065fc:	080064f9 	.word	0x080064f9

08006600 <httpc_create_request_string>:

static int
httpc_create_request_string(const httpc_connection_t *settings, const char* server_name, int server_port, const char* uri,
                            int use_host, char *buffer, size_t buffer_size)
{
 8006600:	b590      	push	{r4, r7, lr}
 8006602:	b089      	sub	sp, #36	; 0x24
 8006604:	af04      	add	r7, sp, #16
 8006606:	60f8      	str	r0, [r7, #12]
 8006608:	60b9      	str	r1, [r7, #8]
 800660a:	607a      	str	r2, [r7, #4]
 800660c:	603b      	str	r3, [r7, #0]
  if (settings->use_proxy) {
 800660e:	68fb      	ldr	r3, [r7, #12]
 8006610:	799b      	ldrb	r3, [r3, #6]
 8006612:	2b00      	cmp	r3, #0
 8006614:	d02c      	beq.n	8006670 <httpc_create_request_string+0x70>
    LWIP_ASSERT("server_name != NULL", server_name != NULL);
 8006616:	68bb      	ldr	r3, [r7, #8]
 8006618:	2b00      	cmp	r3, #0
 800661a:	d106      	bne.n	800662a <httpc_create_request_string+0x2a>
 800661c:	4b28      	ldr	r3, [pc, #160]	; (80066c0 <httpc_create_request_string+0xc0>)
 800661e:	22ec      	movs	r2, #236	; 0xec
 8006620:	32ff      	adds	r2, #255	; 0xff
 8006622:	4928      	ldr	r1, [pc, #160]	; (80066c4 <httpc_create_request_string+0xc4>)
 8006624:	4828      	ldr	r0, [pc, #160]	; (80066c8 <httpc_create_request_string+0xc8>)
 8006626:	f7fc facf 	bl	8002bc8 <app_debug_rtt_raw>
    if (server_port != HTTP_DEFAULT_PORT) {
 800662a:	687b      	ldr	r3, [r7, #4]
 800662c:	2b50      	cmp	r3, #80	; 0x50
 800662e:	d010      	beq.n	8006652 <httpc_create_request_string+0x52>
      return snprintf(buffer, buffer_size, HTTPC_REQ_11_PROXY_PORT_FORMAT(server_name, server_port, uri, server_name));
 8006630:	68bc      	ldr	r4, [r7, #8]
 8006632:	4a26      	ldr	r2, [pc, #152]	; (80066cc <httpc_create_request_string+0xcc>)
 8006634:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8006636:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8006638:	68bb      	ldr	r3, [r7, #8]
 800663a:	9303      	str	r3, [sp, #12]
 800663c:	4b24      	ldr	r3, [pc, #144]	; (80066d0 <httpc_create_request_string+0xd0>)
 800663e:	9302      	str	r3, [sp, #8]
 8006640:	683b      	ldr	r3, [r7, #0]
 8006642:	9301      	str	r3, [sp, #4]
 8006644:	687b      	ldr	r3, [r7, #4]
 8006646:	9300      	str	r3, [sp, #0]
 8006648:	0023      	movs	r3, r4
 800664a:	f016 fd1d 	bl	801d088 <sniprintf>
 800664e:	0003      	movs	r3, r0
 8006650:	e032      	b.n	80066b8 <httpc_create_request_string+0xb8>
    } else {
      return snprintf(buffer, buffer_size, HTTPC_REQ_11_PROXY_FORMAT(server_name, uri, server_name));
 8006652:	68bc      	ldr	r4, [r7, #8]
 8006654:	4a1f      	ldr	r2, [pc, #124]	; (80066d4 <httpc_create_request_string+0xd4>)
 8006656:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8006658:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800665a:	68bb      	ldr	r3, [r7, #8]
 800665c:	9302      	str	r3, [sp, #8]
 800665e:	4b1c      	ldr	r3, [pc, #112]	; (80066d0 <httpc_create_request_string+0xd0>)
 8006660:	9301      	str	r3, [sp, #4]
 8006662:	683b      	ldr	r3, [r7, #0]
 8006664:	9300      	str	r3, [sp, #0]
 8006666:	0023      	movs	r3, r4
 8006668:	f016 fd0e 	bl	801d088 <sniprintf>
 800666c:	0003      	movs	r3, r0
 800666e:	e023      	b.n	80066b8 <httpc_create_request_string+0xb8>
    }
  } else if (use_host) {
 8006670:	6a3b      	ldr	r3, [r7, #32]
 8006672:	2b00      	cmp	r3, #0
 8006674:	d016      	beq.n	80066a4 <httpc_create_request_string+0xa4>
    LWIP_ASSERT("server_name != NULL", server_name != NULL);
 8006676:	68bb      	ldr	r3, [r7, #8]
 8006678:	2b00      	cmp	r3, #0
 800667a:	d106      	bne.n	800668a <httpc_create_request_string+0x8a>
 800667c:	4b10      	ldr	r3, [pc, #64]	; (80066c0 <httpc_create_request_string+0xc0>)
 800667e:	22f9      	movs	r2, #249	; 0xf9
 8006680:	0052      	lsls	r2, r2, #1
 8006682:	4910      	ldr	r1, [pc, #64]	; (80066c4 <httpc_create_request_string+0xc4>)
 8006684:	4810      	ldr	r0, [pc, #64]	; (80066c8 <httpc_create_request_string+0xc8>)
 8006686:	f7fc fa9f 	bl	8002bc8 <app_debug_rtt_raw>
    return snprintf(buffer, buffer_size, HTTPC_REQ_11_HOST_FORMAT(uri, server_name));
 800668a:	683c      	ldr	r4, [r7, #0]
 800668c:	4a12      	ldr	r2, [pc, #72]	; (80066d8 <httpc_create_request_string+0xd8>)
 800668e:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8006690:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8006692:	68bb      	ldr	r3, [r7, #8]
 8006694:	9301      	str	r3, [sp, #4]
 8006696:	4b0e      	ldr	r3, [pc, #56]	; (80066d0 <httpc_create_request_string+0xd0>)
 8006698:	9300      	str	r3, [sp, #0]
 800669a:	0023      	movs	r3, r4
 800669c:	f016 fcf4 	bl	801d088 <sniprintf>
 80066a0:	0003      	movs	r3, r0
 80066a2:	e009      	b.n	80066b8 <httpc_create_request_string+0xb8>
  } else {
    return snprintf(buffer, buffer_size, HTTPC_REQ_11_FORMAT(uri));
 80066a4:	683c      	ldr	r4, [r7, #0]
 80066a6:	4a0d      	ldr	r2, [pc, #52]	; (80066dc <httpc_create_request_string+0xdc>)
 80066a8:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80066aa:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80066ac:	4b08      	ldr	r3, [pc, #32]	; (80066d0 <httpc_create_request_string+0xd0>)
 80066ae:	9300      	str	r3, [sp, #0]
 80066b0:	0023      	movs	r3, r4
 80066b2:	f016 fce9 	bl	801d088 <sniprintf>
 80066b6:	0003      	movs	r3, r0
  }
}
 80066b8:	0018      	movs	r0, r3
 80066ba:	46bd      	mov	sp, r7
 80066bc:	b005      	add	sp, #20
 80066be:	bd90      	pop	{r4, r7, pc}
 80066c0:	0801eea4 	.word	0x0801eea4
 80066c4:	0801ef5c 	.word	0x0801ef5c
 80066c8:	0801eee4 	.word	0x0801eee4
 80066cc:	0801ef70 	.word	0x0801ef70
 80066d0:	0801efcc 	.word	0x0801efcc
 80066d4:	0801f004 	.word	0x0801f004
 80066d8:	0801f05c 	.word	0x0801f05c
 80066dc:	0801f0ac 	.word	0x0801f0ac

080066e0 <httpc_init_connection_common>:

/** Initialize the connection struct */
static err_t
httpc_init_connection_common(httpc_state_t **connection, const httpc_connection_t *settings, const char* server_name,
                      u16_t server_port, const char* uri, altcp_recv_fn recv_fn, void* callback_arg, int use_host)
{
 80066e0:	b5b0      	push	{r4, r5, r7, lr}
 80066e2:	b08e      	sub	sp, #56	; 0x38
 80066e4:	af04      	add	r7, sp, #16
 80066e6:	60f8      	str	r0, [r7, #12]
 80066e8:	60b9      	str	r1, [r7, #8]
 80066ea:	607a      	str	r2, [r7, #4]
 80066ec:	001a      	movs	r2, r3
 80066ee:	1cbb      	adds	r3, r7, #2
 80066f0:	801a      	strh	r2, [r3, #0]
  httpc_state_t *req;
#if HTTPC_DEBUG_REQUEST
  size_t server_name_len, uri_len;
#endif

  LWIP_ASSERT("uri != NULL", uri != NULL);
 80066f2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80066f4:	2b00      	cmp	r3, #0
 80066f6:	d105      	bne.n	8006704 <httpc_init_connection_common+0x24>
 80066f8:	4b6f      	ldr	r3, [pc, #444]	; (80068b8 <httpc_init_connection_common+0x1d8>)
 80066fa:	4a70      	ldr	r2, [pc, #448]	; (80068bc <httpc_init_connection_common+0x1dc>)
 80066fc:	4970      	ldr	r1, [pc, #448]	; (80068c0 <httpc_init_connection_common+0x1e0>)
 80066fe:	4871      	ldr	r0, [pc, #452]	; (80068c4 <httpc_init_connection_common+0x1e4>)
 8006700:	f7fc fa62 	bl	8002bc8 <app_debug_rtt_raw>

  /* get request len */
  req_len = httpc_create_request_string(settings, server_name, server_port, uri, use_host, NULL, 0);
 8006704:	1cbb      	adds	r3, r7, #2
 8006706:	881a      	ldrh	r2, [r3, #0]
 8006708:	6bbc      	ldr	r4, [r7, #56]	; 0x38
 800670a:	6879      	ldr	r1, [r7, #4]
 800670c:	68b8      	ldr	r0, [r7, #8]
 800670e:	2300      	movs	r3, #0
 8006710:	9302      	str	r3, [sp, #8]
 8006712:	2300      	movs	r3, #0
 8006714:	9301      	str	r3, [sp, #4]
 8006716:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006718:	9300      	str	r3, [sp, #0]
 800671a:	0023      	movs	r3, r4
 800671c:	f7ff ff70 	bl	8006600 <httpc_create_request_string>
 8006720:	0003      	movs	r3, r0
 8006722:	627b      	str	r3, [r7, #36]	; 0x24
  if ((req_len < 0) || (req_len > 0xFFFF)) {
 8006724:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006726:	2b00      	cmp	r3, #0
 8006728:	db04      	blt.n	8006734 <httpc_init_connection_common+0x54>
 800672a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800672c:	2380      	movs	r3, #128	; 0x80
 800672e:	025b      	lsls	r3, r3, #9
 8006730:	429a      	cmp	r2, r3
 8006732:	db02      	blt.n	800673a <httpc_init_connection_common+0x5a>
    return ERR_VAL;
 8006734:	2306      	movs	r3, #6
 8006736:	425b      	negs	r3, r3
 8006738:	e0ba      	b.n	80068b0 <httpc_init_connection_common+0x1d0>
  }
  /* alloc state and request in one block */
  alloc_len = sizeof(httpc_state_t);
 800673a:	2334      	movs	r3, #52	; 0x34
 800673c:	623b      	str	r3, [r7, #32]
#if HTTPC_DEBUG_REQUEST
  server_name_len = server_name ? strlen(server_name) : 0;
  uri_len = strlen(uri);
  alloc_len += server_name_len + 1 + uri_len + 1;
#endif
  mem_alloc_len = (mem_size_t)alloc_len;
 800673e:	211e      	movs	r1, #30
 8006740:	187b      	adds	r3, r7, r1
 8006742:	6a3a      	ldr	r2, [r7, #32]
 8006744:	801a      	strh	r2, [r3, #0]
  if ((mem_alloc_len < alloc_len) || (req_len + 1 > 0xFFFF)) {
 8006746:	187b      	adds	r3, r7, r1
 8006748:	881b      	ldrh	r3, [r3, #0]
 800674a:	6a3a      	ldr	r2, [r7, #32]
 800674c:	429a      	cmp	r2, r3
 800674e:	d803      	bhi.n	8006758 <httpc_init_connection_common+0x78>
 8006750:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006752:	4a5d      	ldr	r2, [pc, #372]	; (80068c8 <httpc_init_connection_common+0x1e8>)
 8006754:	4293      	cmp	r3, r2
 8006756:	dd02      	ble.n	800675e <httpc_init_connection_common+0x7e>
    return ERR_VAL;
 8006758:	2306      	movs	r3, #6
 800675a:	425b      	negs	r3, r3
 800675c:	e0a8      	b.n	80068b0 <httpc_init_connection_common+0x1d0>
  }

  req = (httpc_state_t*)mem_malloc((mem_size_t)alloc_len);
 800675e:	6a3b      	ldr	r3, [r7, #32]
 8006760:	b29b      	uxth	r3, r3
 8006762:	0018      	movs	r0, r3
 8006764:	f002 fad2 	bl	8008d0c <mem_malloc>
 8006768:	0003      	movs	r3, r0
 800676a:	61bb      	str	r3, [r7, #24]
  if(req == NULL) {
 800676c:	69bb      	ldr	r3, [r7, #24]
 800676e:	2b00      	cmp	r3, #0
 8006770:	d102      	bne.n	8006778 <httpc_init_connection_common+0x98>
    return ERR_MEM;
 8006772:	2301      	movs	r3, #1
 8006774:	425b      	negs	r3, r3
 8006776:	e09b      	b.n	80068b0 <httpc_init_connection_common+0x1d0>
  }
  memset(req, 0, sizeof(httpc_state_t));
 8006778:	69bb      	ldr	r3, [r7, #24]
 800677a:	2234      	movs	r2, #52	; 0x34
 800677c:	2100      	movs	r1, #0
 800677e:	0018      	movs	r0, r3
 8006780:	f016 fbc0 	bl	801cf04 <memset>
  req->timeout_ticks = HTTPC_POLL_TIMEOUT;
 8006784:	69bb      	ldr	r3, [r7, #24]
 8006786:	221e      	movs	r2, #30
 8006788:	60da      	str	r2, [r3, #12]
  req->request = pbuf_alloc(PBUF_RAW, (u16_t)(req_len + 1), PBUF_RAM);
 800678a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800678c:	b29b      	uxth	r3, r3
 800678e:	3301      	adds	r3, #1
 8006790:	b29b      	uxth	r3, r3
 8006792:	22a0      	movs	r2, #160	; 0xa0
 8006794:	0092      	lsls	r2, r2, #2
 8006796:	0019      	movs	r1, r3
 8006798:	2000      	movs	r0, #0
 800679a:	f003 f817 	bl	80097cc <pbuf_alloc>
 800679e:	0002      	movs	r2, r0
 80067a0:	69bb      	ldr	r3, [r7, #24]
 80067a2:	611a      	str	r2, [r3, #16]
  if (req->request == NULL) {
 80067a4:	69bb      	ldr	r3, [r7, #24]
 80067a6:	691b      	ldr	r3, [r3, #16]
 80067a8:	2b00      	cmp	r3, #0
 80067aa:	d106      	bne.n	80067ba <httpc_init_connection_common+0xda>
    httpc_free_state(req);
 80067ac:	69bb      	ldr	r3, [r7, #24]
 80067ae:	0018      	movs	r0, r3
 80067b0:	f7ff fb06 	bl	8005dc0 <httpc_free_state>
    return ERR_MEM;
 80067b4:	2301      	movs	r3, #1
 80067b6:	425b      	negs	r3, r3
 80067b8:	e07a      	b.n	80068b0 <httpc_init_connection_common+0x1d0>
  }
  if (req->request->next != NULL) {
 80067ba:	69bb      	ldr	r3, [r7, #24]
 80067bc:	691b      	ldr	r3, [r3, #16]
 80067be:	681b      	ldr	r3, [r3, #0]
 80067c0:	2b00      	cmp	r3, #0
 80067c2:	d006      	beq.n	80067d2 <httpc_init_connection_common+0xf2>
    /* need a pbuf in one piece */
    httpc_free_state(req);
 80067c4:	69bb      	ldr	r3, [r7, #24]
 80067c6:	0018      	movs	r0, r3
 80067c8:	f7ff fafa 	bl	8005dc0 <httpc_free_state>
    return ERR_MEM;
 80067cc:	2301      	movs	r3, #1
 80067ce:	425b      	negs	r3, r3
 80067d0:	e06e      	b.n	80068b0 <httpc_init_connection_common+0x1d0>
  }
  req->hdr_content_len = HTTPC_CONTENT_LEN_INVALID;
 80067d2:	69bb      	ldr	r3, [r7, #24]
 80067d4:	2201      	movs	r2, #1
 80067d6:	4252      	negs	r2, r2
 80067d8:	62da      	str	r2, [r3, #44]	; 0x2c
    memcpy(req->server_name, server_name, server_name_len + 1);
  }
  req->uri = req->server_name + server_name_len + 1;
  memcpy(req->uri, uri, uri_len + 1);
#endif
  req->pcb = altcp_new(settings->altcp_allocator);
 80067da:	f005 fdf5 	bl	800c3c8 <tcp_new>
 80067de:	0002      	movs	r2, r0
 80067e0:	69bb      	ldr	r3, [r7, #24]
 80067e2:	601a      	str	r2, [r3, #0]
  if(req->pcb == NULL) {
 80067e4:	69bb      	ldr	r3, [r7, #24]
 80067e6:	681b      	ldr	r3, [r3, #0]
 80067e8:	2b00      	cmp	r3, #0
 80067ea:	d106      	bne.n	80067fa <httpc_init_connection_common+0x11a>
    httpc_free_state(req);
 80067ec:	69bb      	ldr	r3, [r7, #24]
 80067ee:	0018      	movs	r0, r3
 80067f0:	f7ff fae6 	bl	8005dc0 <httpc_free_state>
    return ERR_MEM;
 80067f4:	2301      	movs	r3, #1
 80067f6:	425b      	negs	r3, r3
 80067f8:	e05a      	b.n	80068b0 <httpc_init_connection_common+0x1d0>
  }
  req->remote_port = settings->use_proxy ? settings->proxy_port : server_port;
 80067fa:	68bb      	ldr	r3, [r7, #8]
 80067fc:	799b      	ldrb	r3, [r3, #6]
 80067fe:	2b00      	cmp	r3, #0
 8006800:	d002      	beq.n	8006808 <httpc_init_connection_common+0x128>
 8006802:	68bb      	ldr	r3, [r7, #8]
 8006804:	889b      	ldrh	r3, [r3, #4]
 8006806:	e001      	b.n	800680c <httpc_init_connection_common+0x12c>
 8006808:	1cbb      	adds	r3, r7, #2
 800680a:	881b      	ldrh	r3, [r3, #0]
 800680c:	69ba      	ldr	r2, [r7, #24]
 800680e:	8113      	strh	r3, [r2, #8]
  altcp_arg(req->pcb, req);
 8006810:	69bb      	ldr	r3, [r7, #24]
 8006812:	681b      	ldr	r3, [r3, #0]
 8006814:	69ba      	ldr	r2, [r7, #24]
 8006816:	0011      	movs	r1, r2
 8006818:	0018      	movs	r0, r3
 800681a:	f005 fdde 	bl	800c3da <tcp_arg>
  altcp_recv(req->pcb, httpc_tcp_recv);
 800681e:	69bb      	ldr	r3, [r7, #24]
 8006820:	681b      	ldr	r3, [r3, #0]
 8006822:	4a2a      	ldr	r2, [pc, #168]	; (80068cc <httpc_init_connection_common+0x1ec>)
 8006824:	0011      	movs	r1, r2
 8006826:	0018      	movs	r0, r3
 8006828:	f005 fde6 	bl	800c3f8 <tcp_recv>
  altcp_err(req->pcb, httpc_tcp_err);
 800682c:	69bb      	ldr	r3, [r7, #24]
 800682e:	681b      	ldr	r3, [r3, #0]
 8006830:	4a27      	ldr	r2, [pc, #156]	; (80068d0 <httpc_init_connection_common+0x1f0>)
 8006832:	0011      	movs	r1, r2
 8006834:	0018      	movs	r0, r3
 8006836:	f005 fe23 	bl	800c480 <tcp_err>
  altcp_poll(req->pcb, httpc_tcp_poll, HTTPC_POLL_INTERVAL);
 800683a:	69bb      	ldr	r3, [r7, #24]
 800683c:	681b      	ldr	r3, [r3, #0]
 800683e:	4925      	ldr	r1, [pc, #148]	; (80068d4 <httpc_init_connection_common+0x1f4>)
 8006840:	2201      	movs	r2, #1
 8006842:	0018      	movs	r0, r3
 8006844:	f005 fe3e 	bl	800c4c4 <tcp_poll>
  altcp_sent(req->pcb, httpc_tcp_sent);
 8006848:	69bb      	ldr	r3, [r7, #24]
 800684a:	681b      	ldr	r3, [r3, #0]
 800684c:	4a22      	ldr	r2, [pc, #136]	; (80068d8 <httpc_init_connection_common+0x1f8>)
 800684e:	0011      	movs	r1, r2
 8006850:	0018      	movs	r0, r3
 8006852:	f005 fdf3 	bl	800c43c <tcp_sent>

  /* set up request buffer */
  req_len2 = httpc_create_request_string(settings, server_name, server_port, uri, use_host,
 8006856:	1cbb      	adds	r3, r7, #2
 8006858:	881c      	ldrh	r4, [r3, #0]
    (char *)req->request->payload, req_len + 1);
 800685a:	69bb      	ldr	r3, [r7, #24]
 800685c:	691b      	ldr	r3, [r3, #16]
 800685e:	685b      	ldr	r3, [r3, #4]
 8006860:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8006862:	3201      	adds	r2, #1
  req_len2 = httpc_create_request_string(settings, server_name, server_port, uri, use_host,
 8006864:	0015      	movs	r5, r2
 8006866:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8006868:	6879      	ldr	r1, [r7, #4]
 800686a:	68b8      	ldr	r0, [r7, #8]
 800686c:	9502      	str	r5, [sp, #8]
 800686e:	9301      	str	r3, [sp, #4]
 8006870:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006872:	9300      	str	r3, [sp, #0]
 8006874:	0013      	movs	r3, r2
 8006876:	0022      	movs	r2, r4
 8006878:	f7ff fec2 	bl	8006600 <httpc_create_request_string>
 800687c:	0003      	movs	r3, r0
 800687e:	617b      	str	r3, [r7, #20]
  if (req_len2 != req_len) {
 8006880:	697a      	ldr	r2, [r7, #20]
 8006882:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006884:	429a      	cmp	r2, r3
 8006886:	d006      	beq.n	8006896 <httpc_init_connection_common+0x1b6>
    httpc_free_state(req);
 8006888:	69bb      	ldr	r3, [r7, #24]
 800688a:	0018      	movs	r0, r3
 800688c:	f7ff fa98 	bl	8005dc0 <httpc_free_state>
    return ERR_VAL;
 8006890:	2306      	movs	r3, #6
 8006892:	425b      	negs	r3, r3
 8006894:	e00c      	b.n	80068b0 <httpc_init_connection_common+0x1d0>
  }

  req->recv_fn = recv_fn;
 8006896:	69bb      	ldr	r3, [r7, #24]
 8006898:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800689a:	61da      	str	r2, [r3, #28]
  req->conn_settings = settings;
 800689c:	69bb      	ldr	r3, [r7, #24]
 800689e:	68ba      	ldr	r2, [r7, #8]
 80068a0:	621a      	str	r2, [r3, #32]
  req->callback_arg = callback_arg;
 80068a2:	69bb      	ldr	r3, [r7, #24]
 80068a4:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80068a6:	625a      	str	r2, [r3, #36]	; 0x24

  *connection = req;
 80068a8:	68fb      	ldr	r3, [r7, #12]
 80068aa:	69ba      	ldr	r2, [r7, #24]
 80068ac:	601a      	str	r2, [r3, #0]
  return ERR_OK;
 80068ae:	2300      	movs	r3, #0
}
 80068b0:	0018      	movs	r0, r3
 80068b2:	46bd      	mov	sp, r7
 80068b4:	b00a      	add	sp, #40	; 0x28
 80068b6:	bdb0      	pop	{r4, r5, r7, pc}
 80068b8:	0801eea4 	.word	0x0801eea4
 80068bc:	00000206 	.word	0x00000206
 80068c0:	0801f0f0 	.word	0x0801f0f0
 80068c4:	0801eee4 	.word	0x0801eee4
 80068c8:	0000fffe 	.word	0x0000fffe
 80068cc:	0800616d 	.word	0x0800616d
 80068d0:	0800635f 	.word	0x0800635f
 80068d4:	08006395 	.word	0x08006395
 80068d8:	080063dd 	.word	0x080063dd

080068dc <httpc_init_connection>:
 * Initialize the connection struct
 */
static err_t
httpc_init_connection(httpc_state_t **connection, const httpc_connection_t *settings, const char* server_name,
                      u16_t server_port, const char* uri, altcp_recv_fn recv_fn, void* callback_arg)
{
 80068dc:	b590      	push	{r4, r7, lr}
 80068de:	b089      	sub	sp, #36	; 0x24
 80068e0:	af04      	add	r7, sp, #16
 80068e2:	60f8      	str	r0, [r7, #12]
 80068e4:	60b9      	str	r1, [r7, #8]
 80068e6:	607a      	str	r2, [r7, #4]
 80068e8:	001a      	movs	r2, r3
 80068ea:	1cbb      	adds	r3, r7, #2
 80068ec:	801a      	strh	r2, [r3, #0]
  return httpc_init_connection_common(connection, settings, server_name, server_port, uri, recv_fn, callback_arg, 1);
 80068ee:	1cbb      	adds	r3, r7, #2
 80068f0:	881c      	ldrh	r4, [r3, #0]
 80068f2:	687a      	ldr	r2, [r7, #4]
 80068f4:	68b9      	ldr	r1, [r7, #8]
 80068f6:	68f8      	ldr	r0, [r7, #12]
 80068f8:	2301      	movs	r3, #1
 80068fa:	9303      	str	r3, [sp, #12]
 80068fc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80068fe:	9302      	str	r3, [sp, #8]
 8006900:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006902:	9301      	str	r3, [sp, #4]
 8006904:	6a3b      	ldr	r3, [r7, #32]
 8006906:	9300      	str	r3, [sp, #0]
 8006908:	0023      	movs	r3, r4
 800690a:	f7ff fee9 	bl	80066e0 <httpc_init_connection_common>
 800690e:	0003      	movs	r3, r0
}
 8006910:	0018      	movs	r0, r3
 8006912:	46bd      	mov	sp, r7
 8006914:	b005      	add	sp, #20
 8006916:	bd90      	pop	{r4, r7, pc}

08006918 <httpc_get_file_dns>:
 *         or an error code
 */
err_t
httpc_get_file_dns(const char* server_name, u16_t port, const char* uri, const httpc_connection_t *settings,
                   altcp_recv_fn recv_fn, void* callback_arg, httpc_state_t **connection)
{
 8006918:	b5f0      	push	{r4, r5, r6, r7, lr}
 800691a:	b08b      	sub	sp, #44	; 0x2c
 800691c:	af04      	add	r7, sp, #16
 800691e:	60f8      	str	r0, [r7, #12]
 8006920:	607a      	str	r2, [r7, #4]
 8006922:	603b      	str	r3, [r7, #0]
 8006924:	230a      	movs	r3, #10
 8006926:	18fb      	adds	r3, r7, r3
 8006928:	1c0a      	adds	r2, r1, #0
 800692a:	801a      	strh	r2, [r3, #0]
  err_t err;
  httpc_state_t* req;

  LWIP_ERROR("invalid parameters", (server_name != NULL) && (uri != NULL) && (recv_fn != NULL), return ERR_ARG;);
 800692c:	68fb      	ldr	r3, [r7, #12]
 800692e:	2b00      	cmp	r3, #0
 8006930:	d005      	beq.n	800693e <httpc_get_file_dns+0x26>
 8006932:	687b      	ldr	r3, [r7, #4]
 8006934:	2b00      	cmp	r3, #0
 8006936:	d002      	beq.n	800693e <httpc_get_file_dns+0x26>
 8006938:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800693a:	2b00      	cmp	r3, #0
 800693c:	d106      	bne.n	800694c <httpc_get_file_dns+0x34>
 800693e:	4b2b      	ldr	r3, [pc, #172]	; (80069ec <httpc_get_file_dns+0xd4>)
 8006940:	0018      	movs	r0, r3
 8006942:	f7fc f941 	bl	8002bc8 <app_debug_rtt_raw>
 8006946:	2310      	movs	r3, #16
 8006948:	425b      	negs	r3, r3
 800694a:	e04a      	b.n	80069e2 <httpc_get_file_dns+0xca>

  err = httpc_init_connection(&req, settings, server_name, port, uri, recv_fn, callback_arg);
 800694c:	2617      	movs	r6, #23
 800694e:	19bc      	adds	r4, r7, r6
 8006950:	230a      	movs	r3, #10
 8006952:	18fb      	adds	r3, r7, r3
 8006954:	881d      	ldrh	r5, [r3, #0]
 8006956:	68fa      	ldr	r2, [r7, #12]
 8006958:	6839      	ldr	r1, [r7, #0]
 800695a:	2310      	movs	r3, #16
 800695c:	18f8      	adds	r0, r7, r3
 800695e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8006960:	9302      	str	r3, [sp, #8]
 8006962:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8006964:	9301      	str	r3, [sp, #4]
 8006966:	687b      	ldr	r3, [r7, #4]
 8006968:	9300      	str	r3, [sp, #0]
 800696a:	002b      	movs	r3, r5
 800696c:	f7ff ffb6 	bl	80068dc <httpc_init_connection>
 8006970:	0003      	movs	r3, r0
 8006972:	7023      	strb	r3, [r4, #0]
  if (err != ERR_OK) {
 8006974:	19bb      	adds	r3, r7, r6
 8006976:	781b      	ldrb	r3, [r3, #0]
 8006978:	b25b      	sxtb	r3, r3
 800697a:	2b00      	cmp	r3, #0
 800697c:	d003      	beq.n	8006986 <httpc_get_file_dns+0x6e>
    return err;
 800697e:	19bb      	adds	r3, r7, r6
 8006980:	781b      	ldrb	r3, [r3, #0]
 8006982:	b25b      	sxtb	r3, r3
 8006984:	e02d      	b.n	80069e2 <httpc_get_file_dns+0xca>
  }

  if (settings->use_proxy) {
 8006986:	683b      	ldr	r3, [r7, #0]
 8006988:	799b      	ldrb	r3, [r3, #6]
 800698a:	2b00      	cmp	r3, #0
 800698c:	d00a      	beq.n	80069a4 <httpc_get_file_dns+0x8c>
    err = httpc_get_internal_addr(req, &settings->proxy_addr);
 800698e:	693b      	ldr	r3, [r7, #16]
 8006990:	683a      	ldr	r2, [r7, #0]
 8006992:	2117      	movs	r1, #23
 8006994:	187c      	adds	r4, r7, r1
 8006996:	0011      	movs	r1, r2
 8006998:	0018      	movs	r0, r3
 800699a:	f7ff fd67 	bl	800646c <httpc_get_internal_addr>
 800699e:	0003      	movs	r3, r0
 80069a0:	7023      	strb	r3, [r4, #0]
 80069a2:	e009      	b.n	80069b8 <httpc_get_file_dns+0xa0>
  } else {
    err = httpc_get_internal_dns(req, server_name);
 80069a4:	693b      	ldr	r3, [r7, #16]
 80069a6:	2217      	movs	r2, #23
 80069a8:	18bc      	adds	r4, r7, r2
 80069aa:	68fa      	ldr	r2, [r7, #12]
 80069ac:	0011      	movs	r1, r2
 80069ae:	0018      	movs	r0, r3
 80069b0:	f7ff fde2 	bl	8006578 <httpc_get_internal_dns>
 80069b4:	0003      	movs	r3, r0
 80069b6:	7023      	strb	r3, [r4, #0]
  }
  if(err != ERR_OK) {
 80069b8:	2417      	movs	r4, #23
 80069ba:	193b      	adds	r3, r7, r4
 80069bc:	781b      	ldrb	r3, [r3, #0]
 80069be:	b25b      	sxtb	r3, r3
 80069c0:	2b00      	cmp	r3, #0
 80069c2:	d007      	beq.n	80069d4 <httpc_get_file_dns+0xbc>
    httpc_free_state(req);
 80069c4:	693b      	ldr	r3, [r7, #16]
 80069c6:	0018      	movs	r0, r3
 80069c8:	f7ff f9fa 	bl	8005dc0 <httpc_free_state>
    return err;
 80069cc:	193b      	adds	r3, r7, r4
 80069ce:	781b      	ldrb	r3, [r3, #0]
 80069d0:	b25b      	sxtb	r3, r3
 80069d2:	e006      	b.n	80069e2 <httpc_get_file_dns+0xca>
  }

  if (connection != NULL) {
 80069d4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80069d6:	2b00      	cmp	r3, #0
 80069d8:	d002      	beq.n	80069e0 <httpc_get_file_dns+0xc8>
    *connection = req;
 80069da:	693a      	ldr	r2, [r7, #16]
 80069dc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80069de:	601a      	str	r2, [r3, #0]
  }
  return ERR_OK;
 80069e0:	2300      	movs	r3, #0
}
 80069e2:	0018      	movs	r0, r3
 80069e4:	46bd      	mov	sp, r7
 80069e6:	b007      	add	sp, #28
 80069e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80069ea:	46c0      	nop			; (mov r8, r8)
 80069ec:	0801f0fc 	.word	0x0801f0fc

080069f0 <sntp_process>:
/**
 * SNTP processing of received timestamp
 */
static void
sntp_process(const struct sntp_timestamps *timestamps)
{
 80069f0:	b580      	push	{r7, lr}
 80069f2:	b084      	sub	sp, #16
 80069f4:	af00      	add	r7, sp, #0
 80069f6:	6078      	str	r0, [r7, #4]
  s32_t sec;
  u32_t frac;

  sec  = (s32_t)lwip_ntohl(timestamps->xmit.sec);
 80069f8:	687b      	ldr	r3, [r7, #4]
 80069fa:	681b      	ldr	r3, [r3, #0]
 80069fc:	0018      	movs	r0, r3
 80069fe:	f000 fa8f 	bl	8006f20 <lwip_htonl>
 8006a02:	0003      	movs	r3, r0
 8006a04:	60fb      	str	r3, [r7, #12]
  frac = lwip_ntohl(timestamps->xmit.frac);
 8006a06:	687b      	ldr	r3, [r7, #4]
 8006a08:	685b      	ldr	r3, [r3, #4]
 8006a0a:	0018      	movs	r0, r3
 8006a0c:	f000 fa88 	bl	8006f20 <lwip_htonl>
 8006a10:	0003      	movs	r3, r0
 8006a12:	60bb      	str	r3, [r7, #8]
      frac = (u32_t)((u64_t)t4);
    }
  }
#endif /* SNTP_COMP_ROUNDTRIP */

  SNTP_SET_SYSTEM_TIME_NTP(sec, frac);
 8006a14:	68fb      	ldr	r3, [r7, #12]
 8006a16:	4a05      	ldr	r2, [pc, #20]	; (8006a2c <sntp_process+0x3c>)
 8006a18:	4694      	mov	ip, r2
 8006a1a:	4463      	add	r3, ip
 8006a1c:	0018      	movs	r0, r3
 8006a1e:	f7fa fac5 	bl	8000fac <lwip_sntp_recv_callback>
  LWIP_UNUSED_ARG(frac); /* might be unused if only seconds are set */
  LWIP_DEBUGF(SNTP_DEBUG_TRACE, ("sntp_process: %s, %" U32_F " us\n",
                                 sntp_format_time(sec), SNTP_FRAC_TO_US(frac)));
}
 8006a22:	46c0      	nop			; (mov r8, r8)
 8006a24:	46bd      	mov	sp, r7
 8006a26:	b004      	add	sp, #16
 8006a28:	bd80      	pop	{r7, pc}
 8006a2a:	46c0      	nop			; (mov r8, r8)
 8006a2c:	7c558180 	.word	0x7c558180

08006a30 <sntp_initialize_request>:
/**
 * Initialize request struct to be sent to server.
 */
static void
sntp_initialize_request(struct sntp_msg *req)
{
 8006a30:	b580      	push	{r7, lr}
 8006a32:	b082      	sub	sp, #8
 8006a34:	af00      	add	r7, sp, #0
 8006a36:	6078      	str	r0, [r7, #4]
  memset(req, 0, SNTP_MSG_LEN);
 8006a38:	687b      	ldr	r3, [r7, #4]
 8006a3a:	2230      	movs	r2, #48	; 0x30
 8006a3c:	2100      	movs	r1, #0
 8006a3e:	0018      	movs	r0, r3
 8006a40:	f016 fa60 	bl	801cf04 <memset>
  req->li_vn_mode = SNTP_LI_NO_WARNING | SNTP_VERSION | SNTP_MODE_CLIENT;
 8006a44:	687b      	ldr	r3, [r7, #4]
 8006a46:	2223      	movs	r2, #35	; 0x23
 8006a48:	701a      	strb	r2, [r3, #0]
# endif
    req->transmit_timestamp[0] = sec;
    req->transmit_timestamp[1] = frac;
  }
#endif /* SNTP_CHECK_RESPONSE >= 2 || SNTP_COMP_ROUNDTRIP */
}
 8006a4a:	46c0      	nop			; (mov r8, r8)
 8006a4c:	46bd      	mov	sp, r7
 8006a4e:	b002      	add	sp, #8
 8006a50:	bd80      	pop	{r7, pc}
	...

08006a54 <sntp_retry>:
 *
 * @param arg is unused (only necessary to conform to sys_timeout)
 */
static void
sntp_retry(void *arg)
{
 8006a54:	b580      	push	{r7, lr}
 8006a56:	b084      	sub	sp, #16
 8006a58:	af00      	add	r7, sp, #0
 8006a5a:	6078      	str	r0, [r7, #4]

  LWIP_DEBUGF(SNTP_DEBUG_STATE, ("sntp_retry: Next request will be sent in %"U32_F" ms\n",
                                 sntp_retry_timeout));

  /* set up a timer to send a retry and increase the retry delay */
  sys_untimeout(sntp_request, NULL);
 8006a5c:	4b12      	ldr	r3, [pc, #72]	; (8006aa8 <sntp_retry+0x54>)
 8006a5e:	2100      	movs	r1, #0
 8006a60:	0018      	movs	r0, r3
 8006a62:	f00b fcc7 	bl	80123f4 <sys_untimeout>
  sys_timeout(sntp_retry_timeout, sntp_request, NULL);
 8006a66:	4b11      	ldr	r3, [pc, #68]	; (8006aac <sntp_retry+0x58>)
 8006a68:	681b      	ldr	r3, [r3, #0]
 8006a6a:	490f      	ldr	r1, [pc, #60]	; (8006aa8 <sntp_retry+0x54>)
 8006a6c:	2200      	movs	r2, #0
 8006a6e:	0018      	movs	r0, r3
 8006a70:	f00b fc98 	bl	80123a4 <sys_timeout>

#if SNTP_RETRY_TIMEOUT_EXP
  {
    u32_t new_retry_timeout;
    /* increase the timeout for next retry */
    new_retry_timeout = sntp_retry_timeout << 1;
 8006a74:	4b0d      	ldr	r3, [pc, #52]	; (8006aac <sntp_retry+0x58>)
 8006a76:	681b      	ldr	r3, [r3, #0]
 8006a78:	005b      	lsls	r3, r3, #1
 8006a7a:	60fb      	str	r3, [r7, #12]
    /* limit to maximum timeout and prevent overflow */
    if ((new_retry_timeout <= SNTP_RETRY_TIMEOUT_MAX) &&
 8006a7c:	68fb      	ldr	r3, [r7, #12]
 8006a7e:	4a0c      	ldr	r2, [pc, #48]	; (8006ab0 <sntp_retry+0x5c>)
 8006a80:	4293      	cmp	r3, r2
 8006a82:	d808      	bhi.n	8006a96 <sntp_retry+0x42>
        (new_retry_timeout > sntp_retry_timeout)) {
 8006a84:	4b09      	ldr	r3, [pc, #36]	; (8006aac <sntp_retry+0x58>)
 8006a86:	681b      	ldr	r3, [r3, #0]
    if ((new_retry_timeout <= SNTP_RETRY_TIMEOUT_MAX) &&
 8006a88:	68fa      	ldr	r2, [r7, #12]
 8006a8a:	429a      	cmp	r2, r3
 8006a8c:	d903      	bls.n	8006a96 <sntp_retry+0x42>
      sntp_retry_timeout = new_retry_timeout;
 8006a8e:	4b07      	ldr	r3, [pc, #28]	; (8006aac <sntp_retry+0x58>)
 8006a90:	68fa      	ldr	r2, [r7, #12]
 8006a92:	601a      	str	r2, [r3, #0]
 8006a94:	e003      	b.n	8006a9e <sntp_retry+0x4a>
    } else {
      sntp_retry_timeout = SNTP_RETRY_TIMEOUT_MAX;
 8006a96:	4b05      	ldr	r3, [pc, #20]	; (8006aac <sntp_retry+0x58>)
 8006a98:	4a05      	ldr	r2, [pc, #20]	; (8006ab0 <sntp_retry+0x5c>)
 8006a9a:	601a      	str	r2, [r3, #0]
    }
  }
#endif /* SNTP_RETRY_TIMEOUT_EXP */
}
 8006a9c:	46c0      	nop			; (mov r8, r8)
 8006a9e:	46c0      	nop			; (mov r8, r8)
 8006aa0:	46bd      	mov	sp, r7
 8006aa2:	b004      	add	sp, #16
 8006aa4:	bd80      	pop	{r7, pc}
 8006aa6:	46c0      	nop			; (mov r8, r8)
 8006aa8:	08006ce5 	.word	0x08006ce5
 8006aac:	20001578 	.word	0x20001578
 8006ab0:	000249f0 	.word	0x000249f0

08006ab4 <sntp_recv>:
#endif /* SNTP_SUPPORT_MULTIPLE_SERVERS */

/** UDP recv callback for the sntp pcb */
static void
sntp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr, u16_t port)
{
 8006ab4:	b5b0      	push	{r4, r5, r7, lr}
 8006ab6:	b088      	sub	sp, #32
 8006ab8:	af00      	add	r7, sp, #0
 8006aba:	60f8      	str	r0, [r7, #12]
 8006abc:	60b9      	str	r1, [r7, #8]
 8006abe:	607a      	str	r2, [r7, #4]
 8006ac0:	603b      	str	r3, [r7, #0]
  err_t err;

  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);

  err = ERR_ARG;
 8006ac2:	231f      	movs	r3, #31
 8006ac4:	18fb      	adds	r3, r7, r3
 8006ac6:	22f0      	movs	r2, #240	; 0xf0
 8006ac8:	701a      	strb	r2, [r3, #0]
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
#endif /* SNTP_CHECK_RESPONSE >= 1 */
  {
    /* process the response */
    if (p->tot_len == SNTP_MSG_LEN) {
 8006aca:	687b      	ldr	r3, [r7, #4]
 8006acc:	891b      	ldrh	r3, [r3, #8]
 8006ace:	2b30      	cmp	r3, #48	; 0x30
 8006ad0:	d13e      	bne.n	8006b50 <sntp_recv+0x9c>
      mode = pbuf_get_at(p, SNTP_OFFSET_LI_VN_MODE) & SNTP_MODE_MASK;
 8006ad2:	687b      	ldr	r3, [r7, #4]
 8006ad4:	2100      	movs	r1, #0
 8006ad6:	0018      	movs	r0, r3
 8006ad8:	f003 ff0a 	bl	800a8f0 <pbuf_get_at>
 8006adc:	0003      	movs	r3, r0
 8006ade:	0019      	movs	r1, r3
 8006ae0:	201e      	movs	r0, #30
 8006ae2:	183b      	adds	r3, r7, r0
 8006ae4:	2207      	movs	r2, #7
 8006ae6:	400a      	ands	r2, r1
 8006ae8:	701a      	strb	r2, [r3, #0]
      /* if this is a SNTP response... */
      if (((sntp_opmode == SNTP_OPMODE_POLL)       && (mode == SNTP_MODE_SERVER)) ||
 8006aea:	4b3a      	ldr	r3, [pc, #232]	; (8006bd4 <sntp_recv+0x120>)
 8006aec:	781b      	ldrb	r3, [r3, #0]
 8006aee:	2b00      	cmp	r3, #0
 8006af0:	d103      	bne.n	8006afa <sntp_recv+0x46>
 8006af2:	183b      	adds	r3, r7, r0
 8006af4:	781b      	ldrb	r3, [r3, #0]
 8006af6:	2b04      	cmp	r3, #4
 8006af8:	d008      	beq.n	8006b0c <sntp_recv+0x58>
          ((sntp_opmode == SNTP_OPMODE_LISTENONLY) && (mode == SNTP_MODE_BROADCAST))) {
 8006afa:	4b36      	ldr	r3, [pc, #216]	; (8006bd4 <sntp_recv+0x120>)
 8006afc:	781b      	ldrb	r3, [r3, #0]
      if (((sntp_opmode == SNTP_OPMODE_POLL)       && (mode == SNTP_MODE_SERVER)) ||
 8006afe:	2b01      	cmp	r3, #1
 8006b00:	d122      	bne.n	8006b48 <sntp_recv+0x94>
          ((sntp_opmode == SNTP_OPMODE_LISTENONLY) && (mode == SNTP_MODE_BROADCAST))) {
 8006b02:	231e      	movs	r3, #30
 8006b04:	18fb      	adds	r3, r7, r3
 8006b06:	781b      	ldrb	r3, [r3, #0]
 8006b08:	2b05      	cmp	r3, #5
 8006b0a:	d11d      	bne.n	8006b48 <sntp_recv+0x94>
        stratum = pbuf_get_at(p, SNTP_OFFSET_STRATUM);
 8006b0c:	251d      	movs	r5, #29
 8006b0e:	197c      	adds	r4, r7, r5
 8006b10:	687b      	ldr	r3, [r7, #4]
 8006b12:	2101      	movs	r1, #1
 8006b14:	0018      	movs	r0, r3
 8006b16:	f003 feeb 	bl	800a8f0 <pbuf_get_at>
 8006b1a:	0003      	movs	r3, r0
 8006b1c:	7023      	strb	r3, [r4, #0]

        if (stratum == SNTP_STRATUM_KOD) {
 8006b1e:	197b      	adds	r3, r7, r5
 8006b20:	781b      	ldrb	r3, [r3, #0]
 8006b22:	2b00      	cmp	r3, #0
 8006b24:	d104      	bne.n	8006b30 <sntp_recv+0x7c>
          /* Kiss-of-death packet. Use another server or increase UPDATE_DELAY. */
          err = SNTP_ERR_KOD;
 8006b26:	231f      	movs	r3, #31
 8006b28:	18fb      	adds	r3, r7, r3
 8006b2a:	2201      	movs	r2, #1
 8006b2c:	701a      	strb	r2, [r3, #0]
        if (stratum == SNTP_STRATUM_KOD) {
 8006b2e:	e00f      	b.n	8006b50 <sntp_recv+0x9c>
          LWIP_DEBUGF(SNTP_DEBUG_STATE, ("sntp_recv: Received Kiss-of-Death\n"));
        } else {
          pbuf_copy_partial(p, &timestamps, sizeof(timestamps), SNTP_OFFSET_TIMESTAMPS);
 8006b30:	2310      	movs	r3, #16
 8006b32:	18f9      	adds	r1, r7, r3
 8006b34:	6878      	ldr	r0, [r7, #4]
 8006b36:	2328      	movs	r3, #40	; 0x28
 8006b38:	2208      	movs	r2, #8
 8006b3a:	f003 fc89 	bl	800a450 <pbuf_copy_partial>
          } else
#endif /* SNTP_CHECK_RESPONSE >= 2 */
            /* @todo: add code for SNTP_CHECK_RESPONSE >= 3 and >= 4 here */
          {
            /* correct answer */
            err = ERR_OK;
 8006b3e:	231f      	movs	r3, #31
 8006b40:	18fb      	adds	r3, r7, r3
 8006b42:	2200      	movs	r2, #0
 8006b44:	701a      	strb	r2, [r3, #0]
        if (stratum == SNTP_STRATUM_KOD) {
 8006b46:	e003      	b.n	8006b50 <sntp_recv+0x9c>
          }
        }
      } else {
        LWIP_DEBUGF(SNTP_DEBUG_WARN, ("sntp_recv: Invalid mode in response: %"U16_F"\n", (u16_t)mode));
        /* wait for correct response */
        err = ERR_TIMEOUT;
 8006b48:	231f      	movs	r3, #31
 8006b4a:	18fb      	adds	r3, r7, r3
 8006b4c:	22fd      	movs	r2, #253	; 0xfd
 8006b4e:	701a      	strb	r2, [r3, #0]
    /* packet from wrong remote address or port, wait for correct response */
    err = ERR_TIMEOUT;
  }
#endif /* SNTP_CHECK_RESPONSE >= 1 */

  pbuf_free(p);
 8006b50:	687b      	ldr	r3, [r7, #4]
 8006b52:	0018      	movs	r0, r3
 8006b54:	f003 f9b2 	bl	8009ebc <pbuf_free>

  if (err == ERR_OK) {
 8006b58:	231f      	movs	r3, #31
 8006b5a:	18fb      	adds	r3, r7, r3
 8006b5c:	781b      	ldrb	r3, [r3, #0]
 8006b5e:	b25b      	sxtb	r3, r3
 8006b60:	2b00      	cmp	r3, #0
 8006b62:	d125      	bne.n	8006bb0 <sntp_recv+0xfc>
    /* correct packet received: process it it */
    sntp_process(&timestamps);
 8006b64:	2310      	movs	r3, #16
 8006b66:	18fb      	adds	r3, r7, r3
 8006b68:	0018      	movs	r0, r3
 8006b6a:	f7ff ff41 	bl	80069f0 <sntp_process>

#if SNTP_MONITOR_SERVER_REACHABILITY
    /* indicate that server responded */
    sntp_servers[sntp_current_server].reachability |= 1;
 8006b6e:	4b1a      	ldr	r3, [pc, #104]	; (8006bd8 <sntp_recv+0x124>)
 8006b70:	7a1b      	ldrb	r3, [r3, #8]
 8006b72:	2201      	movs	r2, #1
 8006b74:	4313      	orrs	r3, r2
 8006b76:	b2da      	uxtb	r2, r3
 8006b78:	4b17      	ldr	r3, [pc, #92]	; (8006bd8 <sntp_recv+0x124>)
 8006b7a:	721a      	strb	r2, [r3, #8]
#endif /* SNTP_MONITOR_SERVER_REACHABILITY */
    /* Set up timeout for next request (only if poll response was received)*/
    if (sntp_opmode == SNTP_OPMODE_POLL) {
 8006b7c:	4b15      	ldr	r3, [pc, #84]	; (8006bd4 <sntp_recv+0x120>)
 8006b7e:	781b      	ldrb	r3, [r3, #0]
 8006b80:	2b00      	cmp	r3, #0
 8006b82:	d122      	bne.n	8006bca <sntp_recv+0x116>
      u32_t sntp_update_delay;
      sys_untimeout(sntp_try_next_server, NULL);
 8006b84:	4b15      	ldr	r3, [pc, #84]	; (8006bdc <sntp_recv+0x128>)
 8006b86:	2100      	movs	r1, #0
 8006b88:	0018      	movs	r0, r3
 8006b8a:	f00b fc33 	bl	80123f4 <sys_untimeout>
      sys_untimeout(sntp_request, NULL);
 8006b8e:	4b14      	ldr	r3, [pc, #80]	; (8006be0 <sntp_recv+0x12c>)
 8006b90:	2100      	movs	r1, #0
 8006b92:	0018      	movs	r0, r3
 8006b94:	f00b fc2e 	bl	80123f4 <sys_untimeout>

      /* Correct response, reset retry timeout */
      SNTP_RESET_RETRY_TIMEOUT();
 8006b98:	4b12      	ldr	r3, [pc, #72]	; (8006be4 <sntp_recv+0x130>)
 8006b9a:	4a13      	ldr	r2, [pc, #76]	; (8006be8 <sntp_recv+0x134>)
 8006b9c:	601a      	str	r2, [r3, #0]

      sntp_update_delay = (u32_t)SNTP_UPDATE_DELAY;
 8006b9e:	4b13      	ldr	r3, [pc, #76]	; (8006bec <sntp_recv+0x138>)
 8006ba0:	61bb      	str	r3, [r7, #24]
      sys_timeout(sntp_update_delay, sntp_request, NULL);
 8006ba2:	490f      	ldr	r1, [pc, #60]	; (8006be0 <sntp_recv+0x12c>)
 8006ba4:	69bb      	ldr	r3, [r7, #24]
 8006ba6:	2200      	movs	r2, #0
 8006ba8:	0018      	movs	r0, r3
 8006baa:	f00b fbfb 	bl	80123a4 <sys_timeout>
      sntp_try_next_server(NULL);
    }
  } else {
    /* ignore any broken packet, poll mode: retry after timeout to avoid flooding */
  }
}
 8006bae:	e00c      	b.n	8006bca <sntp_recv+0x116>
  } else if (err == SNTP_ERR_KOD) {
 8006bb0:	231f      	movs	r3, #31
 8006bb2:	18fb      	adds	r3, r7, r3
 8006bb4:	781b      	ldrb	r3, [r3, #0]
 8006bb6:	b25b      	sxtb	r3, r3
 8006bb8:	2b01      	cmp	r3, #1
 8006bba:	d106      	bne.n	8006bca <sntp_recv+0x116>
    if (sntp_opmode == SNTP_OPMODE_POLL) {
 8006bbc:	4b05      	ldr	r3, [pc, #20]	; (8006bd4 <sntp_recv+0x120>)
 8006bbe:	781b      	ldrb	r3, [r3, #0]
 8006bc0:	2b00      	cmp	r3, #0
 8006bc2:	d102      	bne.n	8006bca <sntp_recv+0x116>
      sntp_try_next_server(NULL);
 8006bc4:	2000      	movs	r0, #0
 8006bc6:	f7ff ff45 	bl	8006a54 <sntp_retry>
}
 8006bca:	46c0      	nop			; (mov r8, r8)
 8006bcc:	46bd      	mov	sp, r7
 8006bce:	b008      	add	sp, #32
 8006bd0:	bdb0      	pop	{r4, r5, r7, pc}
 8006bd2:	46c0      	nop			; (mov r8, r8)
 8006bd4:	20001565 	.word	0x20001565
 8006bd8:	2000156c 	.word	0x2000156c
 8006bdc:	08006a55 	.word	0x08006a55
 8006be0:	08006ce5 	.word	0x08006ce5
 8006be4:	20001578 	.word	0x20001578
 8006be8:	00003a98 	.word	0x00003a98
 8006bec:	0036ee80 	.word	0x0036ee80

08006bf0 <sntp_send_request>:
 *
 * @param server_addr resolved IP address of the SNTP server
 */
static void
sntp_send_request(const ip_addr_t *server_addr)
{
 8006bf0:	b580      	push	{r7, lr}
 8006bf2:	b084      	sub	sp, #16
 8006bf4:	af00      	add	r7, sp, #0
 8006bf6:	6078      	str	r0, [r7, #4]
  struct pbuf *p;

  LWIP_ASSERT("server_addr != NULL", server_addr != NULL);
 8006bf8:	687b      	ldr	r3, [r7, #4]
 8006bfa:	2b00      	cmp	r3, #0
 8006bfc:	d105      	bne.n	8006c0a <sntp_send_request+0x1a>
 8006bfe:	4b22      	ldr	r3, [pc, #136]	; (8006c88 <sntp_send_request+0x98>)
 8006c00:	4a22      	ldr	r2, [pc, #136]	; (8006c8c <sntp_send_request+0x9c>)
 8006c02:	4923      	ldr	r1, [pc, #140]	; (8006c90 <sntp_send_request+0xa0>)
 8006c04:	4823      	ldr	r0, [pc, #140]	; (8006c94 <sntp_send_request+0xa4>)
 8006c06:	f7fb ffdf 	bl	8002bc8 <app_debug_rtt_raw>

  p = pbuf_alloc(PBUF_TRANSPORT, SNTP_MSG_LEN, PBUF_RAM);
 8006c0a:	23a0      	movs	r3, #160	; 0xa0
 8006c0c:	009b      	lsls	r3, r3, #2
 8006c0e:	001a      	movs	r2, r3
 8006c10:	2130      	movs	r1, #48	; 0x30
 8006c12:	2038      	movs	r0, #56	; 0x38
 8006c14:	f002 fdda 	bl	80097cc <pbuf_alloc>
 8006c18:	0003      	movs	r3, r0
 8006c1a:	60fb      	str	r3, [r7, #12]
  if (p != NULL) {
 8006c1c:	68fb      	ldr	r3, [r7, #12]
 8006c1e:	2b00      	cmp	r3, #0
 8006c20:	d023      	beq.n	8006c6a <sntp_send_request+0x7a>
    struct sntp_msg *sntpmsg = (struct sntp_msg *)p->payload;
 8006c22:	68fb      	ldr	r3, [r7, #12]
 8006c24:	685b      	ldr	r3, [r3, #4]
 8006c26:	60bb      	str	r3, [r7, #8]
    LWIP_DEBUGF(SNTP_DEBUG_STATE, ("sntp_send_request: Sending request to server\n"));
    /* initialize request message */
    sntp_initialize_request(sntpmsg);
 8006c28:	68bb      	ldr	r3, [r7, #8]
 8006c2a:	0018      	movs	r0, r3
 8006c2c:	f7ff ff00 	bl	8006a30 <sntp_initialize_request>
    /* send request */
    udp_sendto(sntp_pcb, p, server_addr, SNTP_PORT);
 8006c30:	4b19      	ldr	r3, [pc, #100]	; (8006c98 <sntp_send_request+0xa8>)
 8006c32:	6818      	ldr	r0, [r3, #0]
 8006c34:	687a      	ldr	r2, [r7, #4]
 8006c36:	68f9      	ldr	r1, [r7, #12]
 8006c38:	237b      	movs	r3, #123	; 0x7b
 8006c3a:	f00b fe5d 	bl	80128f8 <udp_sendto>
    /* free the pbuf after sending it */
    pbuf_free(p);
 8006c3e:	68fb      	ldr	r3, [r7, #12]
 8006c40:	0018      	movs	r0, r3
 8006c42:	f003 f93b 	bl	8009ebc <pbuf_free>
#if SNTP_MONITOR_SERVER_REACHABILITY
    /* indicate new packet has been sent */
    sntp_servers[sntp_current_server].reachability <<= 1;
 8006c46:	4b15      	ldr	r3, [pc, #84]	; (8006c9c <sntp_send_request+0xac>)
 8006c48:	7a1b      	ldrb	r3, [r3, #8]
 8006c4a:	18db      	adds	r3, r3, r3
 8006c4c:	b2da      	uxtb	r2, r3
 8006c4e:	4b13      	ldr	r3, [pc, #76]	; (8006c9c <sntp_send_request+0xac>)
 8006c50:	721a      	strb	r2, [r3, #8]
#endif /* SNTP_MONITOR_SERVER_REACHABILITY */
    /* set up receive timeout: try next server or retry on timeout */
    sys_untimeout(sntp_try_next_server, NULL);
 8006c52:	4b13      	ldr	r3, [pc, #76]	; (8006ca0 <sntp_send_request+0xb0>)
 8006c54:	2100      	movs	r1, #0
 8006c56:	0018      	movs	r0, r3
 8006c58:	f00b fbcc 	bl	80123f4 <sys_untimeout>
    sys_timeout((u32_t)SNTP_RECV_TIMEOUT, sntp_try_next_server, NULL);
 8006c5c:	4b10      	ldr	r3, [pc, #64]	; (8006ca0 <sntp_send_request+0xb0>)
 8006c5e:	4811      	ldr	r0, [pc, #68]	; (8006ca4 <sntp_send_request+0xb4>)
 8006c60:	2200      	movs	r2, #0
 8006c62:	0019      	movs	r1, r3
 8006c64:	f00b fb9e 	bl	80123a4 <sys_timeout>
                                     (u32_t)SNTP_RETRY_TIMEOUT));
    /* out of memory: set up a timer to send a retry */
    sys_untimeout(sntp_request, NULL);
    sys_timeout((u32_t)SNTP_RETRY_TIMEOUT, sntp_request, NULL);
  }
}
 8006c68:	e00a      	b.n	8006c80 <sntp_send_request+0x90>
    sys_untimeout(sntp_request, NULL);
 8006c6a:	4b0f      	ldr	r3, [pc, #60]	; (8006ca8 <sntp_send_request+0xb8>)
 8006c6c:	2100      	movs	r1, #0
 8006c6e:	0018      	movs	r0, r3
 8006c70:	f00b fbc0 	bl	80123f4 <sys_untimeout>
    sys_timeout((u32_t)SNTP_RETRY_TIMEOUT, sntp_request, NULL);
 8006c74:	4b0c      	ldr	r3, [pc, #48]	; (8006ca8 <sntp_send_request+0xb8>)
 8006c76:	480b      	ldr	r0, [pc, #44]	; (8006ca4 <sntp_send_request+0xb4>)
 8006c78:	2200      	movs	r2, #0
 8006c7a:	0019      	movs	r1, r3
 8006c7c:	f00b fb92 	bl	80123a4 <sys_timeout>
}
 8006c80:	46c0      	nop			; (mov r8, r8)
 8006c82:	46bd      	mov	sp, r7
 8006c84:	b004      	add	sp, #16
 8006c86:	bd80      	pop	{r7, pc}
 8006c88:	0801f110 	.word	0x0801f110
 8006c8c:	00000223 	.word	0x00000223
 8006c90:	0801f13c 	.word	0x0801f13c
 8006c94:	0801f150 	.word	0x0801f150
 8006c98:	20001568 	.word	0x20001568
 8006c9c:	2000156c 	.word	0x2000156c
 8006ca0:	08006a55 	.word	0x08006a55
 8006ca4:	00003a98 	.word	0x00003a98
 8006ca8:	08006ce5 	.word	0x08006ce5

08006cac <sntp_dns_found>:
/**
 * DNS found callback when using DNS names as server address.
 */
static void
sntp_dns_found(const char *hostname, const ip_addr_t *ipaddr, void *arg)
{
 8006cac:	b580      	push	{r7, lr}
 8006cae:	b084      	sub	sp, #16
 8006cb0:	af00      	add	r7, sp, #0
 8006cb2:	60f8      	str	r0, [r7, #12]
 8006cb4:	60b9      	str	r1, [r7, #8]
 8006cb6:	607a      	str	r2, [r7, #4]
  LWIP_UNUSED_ARG(hostname);
  LWIP_UNUSED_ARG(arg);

  if (ipaddr != NULL) {
 8006cb8:	68bb      	ldr	r3, [r7, #8]
 8006cba:	2b00      	cmp	r3, #0
 8006cbc:	d008      	beq.n	8006cd0 <sntp_dns_found+0x24>
    /* Address resolved, send request */
    LWIP_DEBUGF(SNTP_DEBUG_STATE, ("sntp_dns_found: Server address resolved, sending request\n"));
    sntp_servers[sntp_current_server].addr = *ipaddr;
 8006cbe:	4b08      	ldr	r3, [pc, #32]	; (8006ce0 <sntp_dns_found+0x34>)
 8006cc0:	68ba      	ldr	r2, [r7, #8]
 8006cc2:	6812      	ldr	r2, [r2, #0]
 8006cc4:	605a      	str	r2, [r3, #4]
    sntp_send_request(ipaddr);
 8006cc6:	68bb      	ldr	r3, [r7, #8]
 8006cc8:	0018      	movs	r0, r3
 8006cca:	f7ff ff91 	bl	8006bf0 <sntp_send_request>
  } else {
    /* DNS resolving failed -> try another server */
    LWIP_DEBUGF(SNTP_DEBUG_WARN_STATE, ("sntp_dns_found: Failed to resolve server address resolved, trying next server\n"));
    sntp_try_next_server(NULL);
  }
}
 8006cce:	e002      	b.n	8006cd6 <sntp_dns_found+0x2a>
    sntp_try_next_server(NULL);
 8006cd0:	2000      	movs	r0, #0
 8006cd2:	f7ff febf 	bl	8006a54 <sntp_retry>
}
 8006cd6:	46c0      	nop			; (mov r8, r8)
 8006cd8:	46bd      	mov	sp, r7
 8006cda:	b004      	add	sp, #16
 8006cdc:	bd80      	pop	{r7, pc}
 8006cde:	46c0      	nop			; (mov r8, r8)
 8006ce0:	2000156c 	.word	0x2000156c

08006ce4 <sntp_request>:
 *
 * @param arg is unused (only necessary to conform to sys_timeout)
 */
static void
sntp_request(void *arg)
{
 8006ce4:	b5b0      	push	{r4, r5, r7, lr}
 8006ce6:	b084      	sub	sp, #16
 8006ce8:	af00      	add	r7, sp, #0
 8006cea:	6078      	str	r0, [r7, #4]

  LWIP_UNUSED_ARG(arg);

  /* initialize SNTP server address */
#if SNTP_SERVER_DNS
  if (sntp_servers[sntp_current_server].name) {
 8006cec:	4b24      	ldr	r3, [pc, #144]	; (8006d80 <sntp_request+0x9c>)
 8006cee:	681b      	ldr	r3, [r3, #0]
 8006cf0:	2b00      	cmp	r3, #0
 8006cf2:	d01c      	beq.n	8006d2e <sntp_request+0x4a>
    /* always resolve the name and rely on dns-internal caching & timeout */
    ip_addr_set_zero(&sntp_servers[sntp_current_server].addr);
 8006cf4:	4b22      	ldr	r3, [pc, #136]	; (8006d80 <sntp_request+0x9c>)
 8006cf6:	2200      	movs	r2, #0
 8006cf8:	605a      	str	r2, [r3, #4]
    err = dns_gethostbyname(sntp_servers[sntp_current_server].name, &sntp_server_address,
 8006cfa:	4b21      	ldr	r3, [pc, #132]	; (8006d80 <sntp_request+0x9c>)
 8006cfc:	6818      	ldr	r0, [r3, #0]
 8006cfe:	250f      	movs	r5, #15
 8006d00:	197c      	adds	r4, r7, r5
 8006d02:	4a20      	ldr	r2, [pc, #128]	; (8006d84 <sntp_request+0xa0>)
 8006d04:	2308      	movs	r3, #8
 8006d06:	18f9      	adds	r1, r7, r3
 8006d08:	2300      	movs	r3, #0
 8006d0a:	f001 f9f9 	bl	8008100 <dns_gethostbyname>
 8006d0e:	0003      	movs	r3, r0
 8006d10:	7023      	strb	r3, [r4, #0]
                            sntp_dns_found, NULL);
    if (err == ERR_INPROGRESS) {
 8006d12:	197b      	adds	r3, r7, r5
 8006d14:	781b      	ldrb	r3, [r3, #0]
 8006d16:	b25b      	sxtb	r3, r3
 8006d18:	3305      	adds	r3, #5
 8006d1a:	d02d      	beq.n	8006d78 <sntp_request+0x94>
      /* DNS request sent, wait for sntp_dns_found being called */
      LWIP_DEBUGF(SNTP_DEBUG_STATE, ("sntp_request: Waiting for server address to be resolved.\n"));
      return;
    } else if (err == ERR_OK) {
 8006d1c:	197b      	adds	r3, r7, r5
 8006d1e:	781b      	ldrb	r3, [r3, #0]
 8006d20:	b25b      	sxtb	r3, r3
 8006d22:	2b00      	cmp	r3, #0
 8006d24:	d110      	bne.n	8006d48 <sntp_request+0x64>
      sntp_servers[sntp_current_server].addr = sntp_server_address;
 8006d26:	4b16      	ldr	r3, [pc, #88]	; (8006d80 <sntp_request+0x9c>)
 8006d28:	68ba      	ldr	r2, [r7, #8]
 8006d2a:	605a      	str	r2, [r3, #4]
 8006d2c:	e00c      	b.n	8006d48 <sntp_request+0x64>
    }
  } else
#endif /* SNTP_SERVER_DNS */
  {
    sntp_server_address = sntp_servers[sntp_current_server].addr;
 8006d2e:	4b14      	ldr	r3, [pc, #80]	; (8006d80 <sntp_request+0x9c>)
 8006d30:	685b      	ldr	r3, [r3, #4]
 8006d32:	60bb      	str	r3, [r7, #8]
    err = (ip_addr_isany_val(sntp_server_address)) ? ERR_ARG : ERR_OK;
 8006d34:	68bb      	ldr	r3, [r7, #8]
 8006d36:	2b00      	cmp	r3, #0
 8006d38:	d102      	bne.n	8006d40 <sntp_request+0x5c>
 8006d3a:	2310      	movs	r3, #16
 8006d3c:	425a      	negs	r2, r3
 8006d3e:	e000      	b.n	8006d42 <sntp_request+0x5e>
 8006d40:	2200      	movs	r2, #0
 8006d42:	230f      	movs	r3, #15
 8006d44:	18fb      	adds	r3, r7, r3
 8006d46:	701a      	strb	r2, [r3, #0]
  }

  if (err == ERR_OK) {
 8006d48:	230f      	movs	r3, #15
 8006d4a:	18fb      	adds	r3, r7, r3
 8006d4c:	781b      	ldrb	r3, [r3, #0]
 8006d4e:	b25b      	sxtb	r3, r3
 8006d50:	2b00      	cmp	r3, #0
 8006d52:	d105      	bne.n	8006d60 <sntp_request+0x7c>
    LWIP_DEBUGF(SNTP_DEBUG_TRACE, ("sntp_request: current server address is %s\n",
                                   ipaddr_ntoa(&sntp_server_address)));
    sntp_send_request(&sntp_server_address);
 8006d54:	2308      	movs	r3, #8
 8006d56:	18fb      	adds	r3, r7, r3
 8006d58:	0018      	movs	r0, r3
 8006d5a:	f7ff ff49 	bl	8006bf0 <sntp_send_request>
 8006d5e:	e00c      	b.n	8006d7a <sntp_request+0x96>
  } else {
    /* address conversion failed, try another server */
    LWIP_DEBUGF(SNTP_DEBUG_WARN_STATE, ("sntp_request: Invalid server address, trying next server.\n"));
    sys_untimeout(sntp_try_next_server, NULL);
 8006d60:	4b09      	ldr	r3, [pc, #36]	; (8006d88 <sntp_request+0xa4>)
 8006d62:	2100      	movs	r1, #0
 8006d64:	0018      	movs	r0, r3
 8006d66:	f00b fb45 	bl	80123f4 <sys_untimeout>
    sys_timeout((u32_t)SNTP_RETRY_TIMEOUT, sntp_try_next_server, NULL);
 8006d6a:	4b07      	ldr	r3, [pc, #28]	; (8006d88 <sntp_request+0xa4>)
 8006d6c:	4807      	ldr	r0, [pc, #28]	; (8006d8c <sntp_request+0xa8>)
 8006d6e:	2200      	movs	r2, #0
 8006d70:	0019      	movs	r1, r3
 8006d72:	f00b fb17 	bl	80123a4 <sys_timeout>
 8006d76:	e000      	b.n	8006d7a <sntp_request+0x96>
      return;
 8006d78:	46c0      	nop			; (mov r8, r8)
  }
}
 8006d7a:	46bd      	mov	sp, r7
 8006d7c:	b004      	add	sp, #16
 8006d7e:	bdb0      	pop	{r4, r5, r7, pc}
 8006d80:	2000156c 	.word	0x2000156c
 8006d84:	08006cad 	.word	0x08006cad
 8006d88:	08006a55 	.word	0x08006a55
 8006d8c:	00003a98 	.word	0x00003a98

08006d90 <sntp_init>:
 * Initialize this module.
 * Send out request instantly or after SNTP_STARTUP_DELAY(_FUNC).
 */
void
sntp_init(void)
{
 8006d90:	b580      	push	{r7, lr}
 8006d92:	af00      	add	r7, sp, #0
#else
#error SNTP_SERVER_ADDRESS string not supported SNTP_SERVER_DNS==0
#endif
#endif /* SNTP_SERVER_ADDRESS */

  if (sntp_pcb == NULL) {
 8006d94:	4b25      	ldr	r3, [pc, #148]	; (8006e2c <sntp_init+0x9c>)
 8006d96:	681b      	ldr	r3, [r3, #0]
 8006d98:	2b00      	cmp	r3, #0
 8006d9a:	d144      	bne.n	8006e26 <sntp_init+0x96>
    sntp_pcb = udp_new_ip_type(IPADDR_TYPE_ANY);
 8006d9c:	202e      	movs	r0, #46	; 0x2e
 8006d9e:	f00c f922 	bl	8012fe6 <udp_new_ip_type>
 8006da2:	0002      	movs	r2, r0
 8006da4:	4b21      	ldr	r3, [pc, #132]	; (8006e2c <sntp_init+0x9c>)
 8006da6:	601a      	str	r2, [r3, #0]
    LWIP_ASSERT("Failed to allocate udp pcb for sntp client", sntp_pcb != NULL);
 8006da8:	4b20      	ldr	r3, [pc, #128]	; (8006e2c <sntp_init+0x9c>)
 8006daa:	681b      	ldr	r3, [r3, #0]
 8006dac:	2b00      	cmp	r3, #0
 8006dae:	d105      	bne.n	8006dbc <sntp_init+0x2c>
 8006db0:	4b1f      	ldr	r3, [pc, #124]	; (8006e30 <sntp_init+0xa0>)
 8006db2:	4a20      	ldr	r2, [pc, #128]	; (8006e34 <sntp_init+0xa4>)
 8006db4:	4920      	ldr	r1, [pc, #128]	; (8006e38 <sntp_init+0xa8>)
 8006db6:	4821      	ldr	r0, [pc, #132]	; (8006e3c <sntp_init+0xac>)
 8006db8:	f7fb ff06 	bl	8002bc8 <app_debug_rtt_raw>
    if (sntp_pcb != NULL) {
 8006dbc:	4b1b      	ldr	r3, [pc, #108]	; (8006e2c <sntp_init+0x9c>)
 8006dbe:	681b      	ldr	r3, [r3, #0]
 8006dc0:	2b00      	cmp	r3, #0
 8006dc2:	d030      	beq.n	8006e26 <sntp_init+0x96>
      udp_recv(sntp_pcb, sntp_recv, NULL);
 8006dc4:	4b19      	ldr	r3, [pc, #100]	; (8006e2c <sntp_init+0x9c>)
 8006dc6:	681b      	ldr	r3, [r3, #0]
 8006dc8:	491d      	ldr	r1, [pc, #116]	; (8006e40 <sntp_init+0xb0>)
 8006dca:	2200      	movs	r2, #0
 8006dcc:	0018      	movs	r0, r3
 8006dce:	f00c f89b 	bl	8012f08 <udp_recv>

      if (sntp_opmode == SNTP_OPMODE_POLL) {
 8006dd2:	4b1c      	ldr	r3, [pc, #112]	; (8006e44 <sntp_init+0xb4>)
 8006dd4:	781b      	ldrb	r3, [r3, #0]
 8006dd6:	2b00      	cmp	r3, #0
 8006dd8:	d111      	bne.n	8006dfe <sntp_init+0x6e>
        SNTP_RESET_RETRY_TIMEOUT();
 8006dda:	4b1b      	ldr	r3, [pc, #108]	; (8006e48 <sntp_init+0xb8>)
 8006ddc:	4a1b      	ldr	r2, [pc, #108]	; (8006e4c <sntp_init+0xbc>)
 8006dde:	601a      	str	r2, [r3, #0]
#if SNTP_STARTUP_DELAY
        sys_timeout((u32_t)SNTP_STARTUP_DELAY_FUNC, sntp_request, NULL);
 8006de0:	f016 f810 	bl	801ce04 <sys_rand>
 8006de4:	0003      	movs	r3, r0
 8006de6:	491a      	ldr	r1, [pc, #104]	; (8006e50 <sntp_init+0xc0>)
 8006de8:	0018      	movs	r0, r3
 8006dea:	f7f9 fa25 	bl	8000238 <__aeabi_uidivmod>
 8006dee:	000b      	movs	r3, r1
 8006df0:	0018      	movs	r0, r3
 8006df2:	4b18      	ldr	r3, [pc, #96]	; (8006e54 <sntp_init+0xc4>)
 8006df4:	2200      	movs	r2, #0
 8006df6:	0019      	movs	r1, r3
 8006df8:	f00b fad4 	bl	80123a4 <sys_timeout>
        ip_set_option(sntp_pcb, SOF_BROADCAST);
        udp_bind(sntp_pcb, IP_ANY_TYPE, SNTP_PORT);
      }
    }
  }
}
 8006dfc:	e013      	b.n	8006e26 <sntp_init+0x96>
      } else if (sntp_opmode == SNTP_OPMODE_LISTENONLY) {
 8006dfe:	4b11      	ldr	r3, [pc, #68]	; (8006e44 <sntp_init+0xb4>)
 8006e00:	781b      	ldrb	r3, [r3, #0]
 8006e02:	2b01      	cmp	r3, #1
 8006e04:	d10f      	bne.n	8006e26 <sntp_init+0x96>
        ip_set_option(sntp_pcb, SOF_BROADCAST);
 8006e06:	4b09      	ldr	r3, [pc, #36]	; (8006e2c <sntp_init+0x9c>)
 8006e08:	681b      	ldr	r3, [r3, #0]
 8006e0a:	7a5a      	ldrb	r2, [r3, #9]
 8006e0c:	4b07      	ldr	r3, [pc, #28]	; (8006e2c <sntp_init+0x9c>)
 8006e0e:	681b      	ldr	r3, [r3, #0]
 8006e10:	2120      	movs	r1, #32
 8006e12:	430a      	orrs	r2, r1
 8006e14:	b2d2      	uxtb	r2, r2
 8006e16:	725a      	strb	r2, [r3, #9]
        udp_bind(sntp_pcb, IP_ANY_TYPE, SNTP_PORT);
 8006e18:	4b04      	ldr	r3, [pc, #16]	; (8006e2c <sntp_init+0x9c>)
 8006e1a:	681b      	ldr	r3, [r3, #0]
 8006e1c:	490e      	ldr	r1, [pc, #56]	; (8006e58 <sntp_init+0xc8>)
 8006e1e:	227b      	movs	r2, #123	; 0x7b
 8006e20:	0018      	movs	r0, r3
 8006e22:	f00b ffd9 	bl	8012dd8 <udp_bind>
}
 8006e26:	46c0      	nop			; (mov r8, r8)
 8006e28:	46bd      	mov	sp, r7
 8006e2a:	bd80      	pop	{r7, pc}
 8006e2c:	20001568 	.word	0x20001568
 8006e30:	0801f110 	.word	0x0801f110
 8006e34:	0000029d 	.word	0x0000029d
 8006e38:	0801f17c 	.word	0x0801f17c
 8006e3c:	0801f150 	.word	0x0801f150
 8006e40:	08006ab5 	.word	0x08006ab5
 8006e44:	20001565 	.word	0x20001565
 8006e48:	20001578 	.word	0x20001578
 8006e4c:	00003a98 	.word	0x00003a98
 8006e50:	00001388 	.word	0x00001388
 8006e54:	08006ce5 	.word	0x08006ce5
 8006e58:	08022888 	.word	0x08022888

08006e5c <sntp_setoperatingmode>:
 * Sets the operating mode.
 * @param operating_mode one of the available operating modes
 */
void
sntp_setoperatingmode(u8_t operating_mode)
{
 8006e5c:	b580      	push	{r7, lr}
 8006e5e:	b082      	sub	sp, #8
 8006e60:	af00      	add	r7, sp, #0
 8006e62:	0002      	movs	r2, r0
 8006e64:	1dfb      	adds	r3, r7, #7
 8006e66:	701a      	strb	r2, [r3, #0]
  LWIP_ASSERT_CORE_LOCKED();
  LWIP_ASSERT("Invalid operating mode", operating_mode <= SNTP_OPMODE_LISTENONLY);
 8006e68:	1dfb      	adds	r3, r7, #7
 8006e6a:	781b      	ldrb	r3, [r3, #0]
 8006e6c:	2b01      	cmp	r3, #1
 8006e6e:	d906      	bls.n	8006e7e <sntp_setoperatingmode+0x22>
 8006e70:	4b0c      	ldr	r3, [pc, #48]	; (8006ea4 <sntp_setoperatingmode+0x48>)
 8006e72:	22b6      	movs	r2, #182	; 0xb6
 8006e74:	0092      	lsls	r2, r2, #2
 8006e76:	490c      	ldr	r1, [pc, #48]	; (8006ea8 <sntp_setoperatingmode+0x4c>)
 8006e78:	480c      	ldr	r0, [pc, #48]	; (8006eac <sntp_setoperatingmode+0x50>)
 8006e7a:	f7fb fea5 	bl	8002bc8 <app_debug_rtt_raw>
  LWIP_ASSERT("Operating mode must not be set while SNTP client is running", sntp_pcb == NULL);
 8006e7e:	4b0c      	ldr	r3, [pc, #48]	; (8006eb0 <sntp_setoperatingmode+0x54>)
 8006e80:	681b      	ldr	r3, [r3, #0]
 8006e82:	2b00      	cmp	r3, #0
 8006e84:	d005      	beq.n	8006e92 <sntp_setoperatingmode+0x36>
 8006e86:	4b07      	ldr	r3, [pc, #28]	; (8006ea4 <sntp_setoperatingmode+0x48>)
 8006e88:	4a0a      	ldr	r2, [pc, #40]	; (8006eb4 <sntp_setoperatingmode+0x58>)
 8006e8a:	490b      	ldr	r1, [pc, #44]	; (8006eb8 <sntp_setoperatingmode+0x5c>)
 8006e8c:	4807      	ldr	r0, [pc, #28]	; (8006eac <sntp_setoperatingmode+0x50>)
 8006e8e:	f7fb fe9b 	bl	8002bc8 <app_debug_rtt_raw>
  sntp_opmode = operating_mode;
 8006e92:	4b0a      	ldr	r3, [pc, #40]	; (8006ebc <sntp_setoperatingmode+0x60>)
 8006e94:	1dfa      	adds	r2, r7, #7
 8006e96:	7812      	ldrb	r2, [r2, #0]
 8006e98:	701a      	strb	r2, [r3, #0]
}
 8006e9a:	46c0      	nop			; (mov r8, r8)
 8006e9c:	46bd      	mov	sp, r7
 8006e9e:	b002      	add	sp, #8
 8006ea0:	bd80      	pop	{r7, pc}
 8006ea2:	46c0      	nop			; (mov r8, r8)
 8006ea4:	0801f110 	.word	0x0801f110
 8006ea8:	0801f1a8 	.word	0x0801f1a8
 8006eac:	0801f150 	.word	0x0801f150
 8006eb0:	20001568 	.word	0x20001568
 8006eb4:	000002d9 	.word	0x000002d9
 8006eb8:	0801f1c0 	.word	0x0801f1c0
 8006ebc:	20001565 	.word	0x20001565

08006ec0 <sntp_setservername>:
 * @param idx the index of the NTP server to set must be < SNTP_MAX_SERVERS
 * @param server DNS name of the NTP server to set, to be resolved at contact time
 */
void
sntp_setservername(u8_t idx, const char *server)
{
 8006ec0:	b580      	push	{r7, lr}
 8006ec2:	b082      	sub	sp, #8
 8006ec4:	af00      	add	r7, sp, #0
 8006ec6:	0002      	movs	r2, r0
 8006ec8:	6039      	str	r1, [r7, #0]
 8006eca:	1dfb      	adds	r3, r7, #7
 8006ecc:	701a      	strb	r2, [r3, #0]
  LWIP_ASSERT_CORE_LOCKED();
  if (idx < SNTP_MAX_SERVERS) {
 8006ece:	1dfb      	adds	r3, r7, #7
 8006ed0:	781b      	ldrb	r3, [r3, #0]
 8006ed2:	2b00      	cmp	r3, #0
 8006ed4:	d108      	bne.n	8006ee8 <sntp_setservername+0x28>
    sntp_servers[idx].name = server;
 8006ed6:	1dfb      	adds	r3, r7, #7
 8006ed8:	781a      	ldrb	r2, [r3, #0]
 8006eda:	4905      	ldr	r1, [pc, #20]	; (8006ef0 <sntp_setservername+0x30>)
 8006edc:	0013      	movs	r3, r2
 8006ede:	005b      	lsls	r3, r3, #1
 8006ee0:	189b      	adds	r3, r3, r2
 8006ee2:	009b      	lsls	r3, r3, #2
 8006ee4:	683a      	ldr	r2, [r7, #0]
 8006ee6:	505a      	str	r2, [r3, r1]
  }
}
 8006ee8:	46c0      	nop			; (mov r8, r8)
 8006eea:	46bd      	mov	sp, r7
 8006eec:	b002      	add	sp, #8
 8006eee:	bd80      	pop	{r7, pc}
 8006ef0:	2000156c 	.word	0x2000156c

08006ef4 <lwip_htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
lwip_htons(u16_t n)
{
 8006ef4:	b580      	push	{r7, lr}
 8006ef6:	b082      	sub	sp, #8
 8006ef8:	af00      	add	r7, sp, #0
 8006efa:	0002      	movs	r2, r0
 8006efc:	1dbb      	adds	r3, r7, #6
 8006efe:	801a      	strh	r2, [r3, #0]
  return PP_HTONS(n);
 8006f00:	1dbb      	adds	r3, r7, #6
 8006f02:	881b      	ldrh	r3, [r3, #0]
 8006f04:	021b      	lsls	r3, r3, #8
 8006f06:	b21a      	sxth	r2, r3
 8006f08:	1dbb      	adds	r3, r7, #6
 8006f0a:	881b      	ldrh	r3, [r3, #0]
 8006f0c:	0a1b      	lsrs	r3, r3, #8
 8006f0e:	b29b      	uxth	r3, r3
 8006f10:	b21b      	sxth	r3, r3
 8006f12:	4313      	orrs	r3, r2
 8006f14:	b21b      	sxth	r3, r3
 8006f16:	b29b      	uxth	r3, r3
}
 8006f18:	0018      	movs	r0, r3
 8006f1a:	46bd      	mov	sp, r7
 8006f1c:	b002      	add	sp, #8
 8006f1e:	bd80      	pop	{r7, pc}

08006f20 <lwip_htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
lwip_htonl(u32_t n)
{
 8006f20:	b580      	push	{r7, lr}
 8006f22:	b082      	sub	sp, #8
 8006f24:	af00      	add	r7, sp, #0
 8006f26:	6078      	str	r0, [r7, #4]
  return PP_HTONL(n);
 8006f28:	687b      	ldr	r3, [r7, #4]
 8006f2a:	061a      	lsls	r2, r3, #24
 8006f2c:	687b      	ldr	r3, [r7, #4]
 8006f2e:	0219      	lsls	r1, r3, #8
 8006f30:	23ff      	movs	r3, #255	; 0xff
 8006f32:	041b      	lsls	r3, r3, #16
 8006f34:	400b      	ands	r3, r1
 8006f36:	431a      	orrs	r2, r3
 8006f38:	687b      	ldr	r3, [r7, #4]
 8006f3a:	0a19      	lsrs	r1, r3, #8
 8006f3c:	23ff      	movs	r3, #255	; 0xff
 8006f3e:	021b      	lsls	r3, r3, #8
 8006f40:	400b      	ands	r3, r1
 8006f42:	431a      	orrs	r2, r3
 8006f44:	687b      	ldr	r3, [r7, #4]
 8006f46:	0e1b      	lsrs	r3, r3, #24
 8006f48:	4313      	orrs	r3, r2
}
 8006f4a:	0018      	movs	r0, r3
 8006f4c:	46bd      	mov	sp, r7
 8006f4e:	b002      	add	sp, #8
 8006f50:	bd80      	pop	{r7, pc}

08006f52 <lwip_strnicmp>:
 * lwIP default implementation for strnicmp() non-standard function.
 * This can be \#defined to strnicmp() depending on your platform port.
 */
int
lwip_strnicmp(const char *str1, const char *str2, size_t len)
{
 8006f52:	b5b0      	push	{r4, r5, r7, lr}
 8006f54:	b086      	sub	sp, #24
 8006f56:	af00      	add	r7, sp, #0
 8006f58:	60f8      	str	r0, [r7, #12]
 8006f5a:	60b9      	str	r1, [r7, #8]
 8006f5c:	607a      	str	r2, [r7, #4]
  char c1, c2;

  do {
    c1 = *str1++;
 8006f5e:	68fb      	ldr	r3, [r7, #12]
 8006f60:	1c5a      	adds	r2, r3, #1
 8006f62:	60fa      	str	r2, [r7, #12]
 8006f64:	2117      	movs	r1, #23
 8006f66:	187a      	adds	r2, r7, r1
 8006f68:	781b      	ldrb	r3, [r3, #0]
 8006f6a:	7013      	strb	r3, [r2, #0]
    c2 = *str2++;
 8006f6c:	68bb      	ldr	r3, [r7, #8]
 8006f6e:	1c5a      	adds	r2, r3, #1
 8006f70:	60ba      	str	r2, [r7, #8]
 8006f72:	2416      	movs	r4, #22
 8006f74:	193a      	adds	r2, r7, r4
 8006f76:	781b      	ldrb	r3, [r3, #0]
 8006f78:	7013      	strb	r3, [r2, #0]
    if (c1 != c2) {
 8006f7a:	187a      	adds	r2, r7, r1
 8006f7c:	193b      	adds	r3, r7, r4
 8006f7e:	7812      	ldrb	r2, [r2, #0]
 8006f80:	781b      	ldrb	r3, [r3, #0]
 8006f82:	429a      	cmp	r2, r3
 8006f84:	d020      	beq.n	8006fc8 <lwip_strnicmp+0x76>
      char c1_upc = c1 | 0x20;
 8006f86:	2015      	movs	r0, #21
 8006f88:	183b      	adds	r3, r7, r0
 8006f8a:	187a      	adds	r2, r7, r1
 8006f8c:	7812      	ldrb	r2, [r2, #0]
 8006f8e:	2120      	movs	r1, #32
 8006f90:	430a      	orrs	r2, r1
 8006f92:	701a      	strb	r2, [r3, #0]
      if ((c1_upc >= 'a') && (c1_upc <= 'z')) {
 8006f94:	183b      	adds	r3, r7, r0
 8006f96:	781b      	ldrb	r3, [r3, #0]
 8006f98:	2b60      	cmp	r3, #96	; 0x60
 8006f9a:	d912      	bls.n	8006fc2 <lwip_strnicmp+0x70>
 8006f9c:	183b      	adds	r3, r7, r0
 8006f9e:	781b      	ldrb	r3, [r3, #0]
 8006fa0:	2b7a      	cmp	r3, #122	; 0x7a
 8006fa2:	d80e      	bhi.n	8006fc2 <lwip_strnicmp+0x70>
        /* characters are not equal an one is in the alphabet range:
        downcase both chars and check again */
        char c2_upc = c2 | 0x20;
 8006fa4:	2514      	movs	r5, #20
 8006fa6:	197b      	adds	r3, r7, r5
 8006fa8:	193a      	adds	r2, r7, r4
 8006faa:	7812      	ldrb	r2, [r2, #0]
 8006fac:	2120      	movs	r1, #32
 8006fae:	430a      	orrs	r2, r1
 8006fb0:	701a      	strb	r2, [r3, #0]
        if (c1_upc != c2_upc) {
 8006fb2:	183a      	adds	r2, r7, r0
 8006fb4:	197b      	adds	r3, r7, r5
 8006fb6:	7812      	ldrb	r2, [r2, #0]
 8006fb8:	781b      	ldrb	r3, [r3, #0]
 8006fba:	429a      	cmp	r2, r3
 8006fbc:	d003      	beq.n	8006fc6 <lwip_strnicmp+0x74>
          /* still not equal */
          /* don't care for < or > */
          return 1;
 8006fbe:	2301      	movs	r3, #1
 8006fc0:	e00e      	b.n	8006fe0 <lwip_strnicmp+0x8e>
        }
      } else {
        /* characters are not equal but none is in the alphabet range */
        return 1;
 8006fc2:	2301      	movs	r3, #1
 8006fc4:	e00c      	b.n	8006fe0 <lwip_strnicmp+0x8e>
      if ((c1_upc >= 'a') && (c1_upc <= 'z')) {
 8006fc6:	46c0      	nop			; (mov r8, r8)
      }
    }
    len--;
 8006fc8:	687b      	ldr	r3, [r7, #4]
 8006fca:	3b01      	subs	r3, #1
 8006fcc:	607b      	str	r3, [r7, #4]
  } while ((len != 0) && (c1 != 0));
 8006fce:	687b      	ldr	r3, [r7, #4]
 8006fd0:	2b00      	cmp	r3, #0
 8006fd2:	d004      	beq.n	8006fde <lwip_strnicmp+0x8c>
 8006fd4:	2317      	movs	r3, #23
 8006fd6:	18fb      	adds	r3, r7, r3
 8006fd8:	781b      	ldrb	r3, [r3, #0]
 8006fda:	2b00      	cmp	r3, #0
 8006fdc:	d1bf      	bne.n	8006f5e <lwip_strnicmp+0xc>
  return 0;
 8006fde:	2300      	movs	r3, #0
}
 8006fe0:	0018      	movs	r0, r3
 8006fe2:	46bd      	mov	sp, r7
 8006fe4:	b006      	add	sp, #24
 8006fe6:	bdb0      	pop	{r4, r5, r7, pc}

08006fe8 <dns_init>:
 * Initialize the resolver: set up the UDP pcb and configure the default server
 * (if DNS_SERVER_ADDRESS is set).
 */
void
dns_init(void)
{
 8006fe8:	b580      	push	{r7, lr}
 8006fea:	af00      	add	r7, sp, #0
#endif

#if DNS_LOCAL_HOSTLIST
  dns_init_local();
#endif
}
 8006fec:	46c0      	nop			; (mov r8, r8)
 8006fee:	46bd      	mov	sp, r7
 8006ff0:	bd80      	pop	{r7, pc}
	...

08006ff4 <dns_setserver>:
 * @param numdns the index of the DNS server to set must be < DNS_MAX_SERVERS
 * @param dnsserver IP address of the DNS server to set
 */
void
dns_setserver(u8_t numdns, const ip_addr_t *dnsserver)
{
 8006ff4:	b580      	push	{r7, lr}
 8006ff6:	b082      	sub	sp, #8
 8006ff8:	af00      	add	r7, sp, #0
 8006ffa:	0002      	movs	r2, r0
 8006ffc:	6039      	str	r1, [r7, #0]
 8006ffe:	1dfb      	adds	r3, r7, #7
 8007000:	701a      	strb	r2, [r3, #0]
  if (numdns < DNS_MAX_SERVERS) {
 8007002:	1dfb      	adds	r3, r7, #7
 8007004:	781b      	ldrb	r3, [r3, #0]
 8007006:	2b01      	cmp	r3, #1
 8007008:	d811      	bhi.n	800702e <dns_setserver+0x3a>
    if (dnsserver != NULL) {
 800700a:	683b      	ldr	r3, [r7, #0]
 800700c:	2b00      	cmp	r3, #0
 800700e:	d007      	beq.n	8007020 <dns_setserver+0x2c>
      dns_servers[numdns] = (*dnsserver);
 8007010:	1dfb      	adds	r3, r7, #7
 8007012:	781b      	ldrb	r3, [r3, #0]
 8007014:	4a08      	ldr	r2, [pc, #32]	; (8007038 <dns_setserver+0x44>)
 8007016:	0099      	lsls	r1, r3, #2
 8007018:	683b      	ldr	r3, [r7, #0]
 800701a:	681b      	ldr	r3, [r3, #0]
 800701c:	508b      	str	r3, [r1, r2]
    } else {
      dns_servers[numdns] = *IP_ADDR_ANY;
    }
  }
}
 800701e:	e006      	b.n	800702e <dns_setserver+0x3a>
      dns_servers[numdns] = *IP_ADDR_ANY;
 8007020:	1dfb      	adds	r3, r7, #7
 8007022:	781b      	ldrb	r3, [r3, #0]
 8007024:	4a04      	ldr	r2, [pc, #16]	; (8007038 <dns_setserver+0x44>)
 8007026:	0099      	lsls	r1, r3, #2
 8007028:	4b04      	ldr	r3, [pc, #16]	; (800703c <dns_setserver+0x48>)
 800702a:	681b      	ldr	r3, [r3, #0]
 800702c:	508b      	str	r3, [r1, r2]
}
 800702e:	46c0      	nop			; (mov r8, r8)
 8007030:	46bd      	mov	sp, r7
 8007032:	b002      	add	sp, #8
 8007034:	bd80      	pop	{r7, pc}
 8007036:	46c0      	nop			; (mov r8, r8)
 8007038:	20001760 	.word	0x20001760
 800703c:	08022888 	.word	0x08022888

08007040 <dns_getserver>:
 * @return IP address of the indexed DNS server or "ip_addr_any" if the DNS
 *         server has not been configured.
 */
const ip_addr_t *
dns_getserver(u8_t numdns)
{
 8007040:	b580      	push	{r7, lr}
 8007042:	b082      	sub	sp, #8
 8007044:	af00      	add	r7, sp, #0
 8007046:	0002      	movs	r2, r0
 8007048:	1dfb      	adds	r3, r7, #7
 800704a:	701a      	strb	r2, [r3, #0]
  if (numdns < DNS_MAX_SERVERS) {
 800704c:	1dfb      	adds	r3, r7, #7
 800704e:	781b      	ldrb	r3, [r3, #0]
 8007050:	2b01      	cmp	r3, #1
 8007052:	d805      	bhi.n	8007060 <dns_getserver+0x20>
    return &dns_servers[numdns];
 8007054:	1dfb      	adds	r3, r7, #7
 8007056:	781b      	ldrb	r3, [r3, #0]
 8007058:	009a      	lsls	r2, r3, #2
 800705a:	4b04      	ldr	r3, [pc, #16]	; (800706c <dns_getserver+0x2c>)
 800705c:	18d3      	adds	r3, r2, r3
 800705e:	e000      	b.n	8007062 <dns_getserver+0x22>
  } else {
    return IP_ADDR_ANY;
 8007060:	4b03      	ldr	r3, [pc, #12]	; (8007070 <dns_getserver+0x30>)
  }
}
 8007062:	0018      	movs	r0, r3
 8007064:	46bd      	mov	sp, r7
 8007066:	b002      	add	sp, #8
 8007068:	bd80      	pop	{r7, pc}
 800706a:	46c0      	nop			; (mov r8, r8)
 800706c:	20001760 	.word	0x20001760
 8007070:	08022888 	.word	0x08022888

08007074 <dns_lookup>:
 *         was not found in the cached dns_table.
 * @return ERR_OK if found, ERR_ARG if not found
 */
static err_t
dns_lookup(const char *name, ip_addr_t *addr LWIP_DNS_ADDRTYPE_ARG(u8_t dns_addrtype))
{
 8007074:	b590      	push	{r4, r7, lr}
 8007076:	b085      	sub	sp, #20
 8007078:	af00      	add	r7, sp, #0
 800707a:	6078      	str	r0, [r7, #4]
 800707c:	6039      	str	r1, [r7, #0]
    return ERR_OK;
  }
#endif /* DNS_LOOKUP_LOCAL_EXTERN */

  /* Walk through name list, return entry if found. If not, return NULL. */
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 800707e:	230f      	movs	r3, #15
 8007080:	18fb      	adds	r3, r7, r3
 8007082:	2200      	movs	r2, #0
 8007084:	701a      	strb	r2, [r3, #0]
 8007086:	e034      	b.n	80070f2 <dns_lookup+0x7e>
    if ((dns_table[i].state == DNS_STATE_DONE) &&
 8007088:	240f      	movs	r4, #15
 800708a:	193b      	adds	r3, r7, r4
 800708c:	781a      	ldrb	r2, [r3, #0]
 800708e:	491e      	ldr	r1, [pc, #120]	; (8007108 <dns_lookup+0x94>)
 8007090:	0013      	movs	r3, r2
 8007092:	00db      	lsls	r3, r3, #3
 8007094:	189b      	adds	r3, r3, r2
 8007096:	011b      	lsls	r3, r3, #4
 8007098:	18cb      	adds	r3, r1, r3
 800709a:	330a      	adds	r3, #10
 800709c:	781b      	ldrb	r3, [r3, #0]
 800709e:	2b03      	cmp	r3, #3
 80070a0:	d121      	bne.n	80070e6 <dns_lookup+0x72>
        (lwip_strnicmp(name, dns_table[i].name, sizeof(dns_table[i].name)) == 0) &&
 80070a2:	193b      	adds	r3, r7, r4
 80070a4:	781a      	ldrb	r2, [r3, #0]
 80070a6:	0013      	movs	r3, r2
 80070a8:	00db      	lsls	r3, r3, #3
 80070aa:	189b      	adds	r3, r3, r2
 80070ac:	011b      	lsls	r3, r3, #4
 80070ae:	3310      	adds	r3, #16
 80070b0:	001a      	movs	r2, r3
 80070b2:	4b15      	ldr	r3, [pc, #84]	; (8007108 <dns_lookup+0x94>)
 80070b4:	18d1      	adds	r1, r2, r3
 80070b6:	687b      	ldr	r3, [r7, #4]
 80070b8:	2280      	movs	r2, #128	; 0x80
 80070ba:	0018      	movs	r0, r3
 80070bc:	f7ff ff49 	bl	8006f52 <lwip_strnicmp>
 80070c0:	1e03      	subs	r3, r0, #0
    if ((dns_table[i].state == DNS_STATE_DONE) &&
 80070c2:	d110      	bne.n	80070e6 <dns_lookup+0x72>
        LWIP_DNS_ADDRTYPE_MATCH_IP(dns_addrtype, dns_table[i].ipaddr)) {
      LWIP_DEBUGF(DNS_DEBUG, ("dns_lookup: \"%s\": found = ", name));
      ip_addr_debug_print_val(DNS_DEBUG, dns_table[i].ipaddr);
      LWIP_DEBUGF(DNS_DEBUG, ("\n"));
      if (addr) {
 80070c4:	683b      	ldr	r3, [r7, #0]
 80070c6:	2b00      	cmp	r3, #0
 80070c8:	d00b      	beq.n	80070e2 <dns_lookup+0x6e>
        ip_addr_copy(*addr, dns_table[i].ipaddr);
 80070ca:	193b      	adds	r3, r7, r4
 80070cc:	781a      	ldrb	r2, [r3, #0]
 80070ce:	490e      	ldr	r1, [pc, #56]	; (8007108 <dns_lookup+0x94>)
 80070d0:	0013      	movs	r3, r2
 80070d2:	00db      	lsls	r3, r3, #3
 80070d4:	189b      	adds	r3, r3, r2
 80070d6:	011b      	lsls	r3, r3, #4
 80070d8:	18cb      	adds	r3, r1, r3
 80070da:	3304      	adds	r3, #4
 80070dc:	681a      	ldr	r2, [r3, #0]
 80070de:	683b      	ldr	r3, [r7, #0]
 80070e0:	601a      	str	r2, [r3, #0]
      }
      return ERR_OK;
 80070e2:	2300      	movs	r3, #0
 80070e4:	e00c      	b.n	8007100 <dns_lookup+0x8c>
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 80070e6:	220f      	movs	r2, #15
 80070e8:	18bb      	adds	r3, r7, r2
 80070ea:	18ba      	adds	r2, r7, r2
 80070ec:	7812      	ldrb	r2, [r2, #0]
 80070ee:	3201      	adds	r2, #1
 80070f0:	701a      	strb	r2, [r3, #0]
 80070f2:	230f      	movs	r3, #15
 80070f4:	18fb      	adds	r3, r7, r3
 80070f6:	781b      	ldrb	r3, [r3, #0]
 80070f8:	2b02      	cmp	r3, #2
 80070fa:	d9c5      	bls.n	8007088 <dns_lookup+0x14>
    }
  }

  return ERR_ARG;
 80070fc:	2310      	movs	r3, #16
 80070fe:	425b      	negs	r3, r3
}
 8007100:	0018      	movs	r0, r3
 8007102:	46bd      	mov	sp, r7
 8007104:	b005      	add	sp, #20
 8007106:	bd90      	pop	{r4, r7, pc}
 8007108:	2000158c 	.word	0x2000158c

0800710c <dns_compare_name>:
 * @param start_offset offset into p where the name starts
 * @return 0xFFFF: names differ, other: names equal -> offset behind name
 */
static u16_t
dns_compare_name(const char *query, struct pbuf *p, u16_t start_offset)
{
 800710c:	b590      	push	{r4, r7, lr}
 800710e:	b089      	sub	sp, #36	; 0x24
 8007110:	af00      	add	r7, sp, #0
 8007112:	60f8      	str	r0, [r7, #12]
 8007114:	60b9      	str	r1, [r7, #8]
 8007116:	1dbb      	adds	r3, r7, #6
 8007118:	801a      	strh	r2, [r3, #0]
  int n;
  u16_t response_offset = start_offset;
 800711a:	231a      	movs	r3, #26
 800711c:	18fb      	adds	r3, r7, r3
 800711e:	1dba      	adds	r2, r7, #6
 8007120:	8812      	ldrh	r2, [r2, #0]
 8007122:	801a      	strh	r2, [r3, #0]

  do {
    n = pbuf_try_get_at(p, response_offset);
 8007124:	241a      	movs	r4, #26
 8007126:	193b      	adds	r3, r7, r4
 8007128:	881a      	ldrh	r2, [r3, #0]
 800712a:	68bb      	ldr	r3, [r7, #8]
 800712c:	0011      	movs	r1, r2
 800712e:	0018      	movs	r0, r3
 8007130:	f003 fbf9 	bl	800a926 <pbuf_try_get_at>
 8007134:	0003      	movs	r3, r0
 8007136:	61fb      	str	r3, [r7, #28]
    if ((n < 0) || (response_offset == 0xFFFF)) {
 8007138:	69fb      	ldr	r3, [r7, #28]
 800713a:	2b00      	cmp	r3, #0
 800713c:	db04      	blt.n	8007148 <dns_compare_name+0x3c>
 800713e:	193b      	adds	r3, r7, r4
 8007140:	881b      	ldrh	r3, [r3, #0]
 8007142:	4a48      	ldr	r2, [pc, #288]	; (8007264 <dns_compare_name+0x158>)
 8007144:	4293      	cmp	r3, r2
 8007146:	d101      	bne.n	800714c <dns_compare_name+0x40>
      /* error or overflow */
      return 0xFFFF;
 8007148:	4b46      	ldr	r3, [pc, #280]	; (8007264 <dns_compare_name+0x158>)
 800714a:	e087      	b.n	800725c <dns_compare_name+0x150>
    }
    response_offset++;
 800714c:	211a      	movs	r1, #26
 800714e:	187b      	adds	r3, r7, r1
 8007150:	881a      	ldrh	r2, [r3, #0]
 8007152:	187b      	adds	r3, r7, r1
 8007154:	3201      	adds	r2, #1
 8007156:	801a      	strh	r2, [r3, #0]
    /** @see RFC 1035 - 4.1.4. Message compression */
    if ((n & 0xc0) == 0xc0) {
 8007158:	69fb      	ldr	r3, [r7, #28]
 800715a:	22c0      	movs	r2, #192	; 0xc0
 800715c:	4013      	ands	r3, r2
 800715e:	2bc0      	cmp	r3, #192	; 0xc0
 8007160:	d156      	bne.n	8007210 <dns_compare_name+0x104>
      /* Compressed name: cannot be equal since we don't send them */
      return 0xFFFF;
 8007162:	4b40      	ldr	r3, [pc, #256]	; (8007264 <dns_compare_name+0x158>)
 8007164:	e07a      	b.n	800725c <dns_compare_name+0x150>
    } else {
      /* Not compressed name */
      while (n > 0) {
        int c = pbuf_try_get_at(p, response_offset);
 8007166:	231a      	movs	r3, #26
 8007168:	18fb      	adds	r3, r7, r3
 800716a:	881a      	ldrh	r2, [r3, #0]
 800716c:	68bb      	ldr	r3, [r7, #8]
 800716e:	0011      	movs	r1, r2
 8007170:	0018      	movs	r0, r3
 8007172:	f003 fbd8 	bl	800a926 <pbuf_try_get_at>
 8007176:	0003      	movs	r3, r0
 8007178:	617b      	str	r3, [r7, #20]
        if (c < 0) {
 800717a:	697b      	ldr	r3, [r7, #20]
 800717c:	2b00      	cmp	r3, #0
 800717e:	da01      	bge.n	8007184 <dns_compare_name+0x78>
          return 0xFFFF;
 8007180:	4b38      	ldr	r3, [pc, #224]	; (8007264 <dns_compare_name+0x158>)
 8007182:	e06b      	b.n	800725c <dns_compare_name+0x150>
        }
        if (lwip_tolower((*query)) != lwip_tolower((u8_t)c)) {
 8007184:	2113      	movs	r1, #19
 8007186:	187b      	adds	r3, r7, r1
 8007188:	68fa      	ldr	r2, [r7, #12]
 800718a:	7812      	ldrb	r2, [r2, #0]
 800718c:	701a      	strb	r2, [r3, #0]
 800718e:	187b      	adds	r3, r7, r1
 8007190:	781b      	ldrb	r3, [r3, #0]
 8007192:	1c5a      	adds	r2, r3, #1
 8007194:	4b34      	ldr	r3, [pc, #208]	; (8007268 <dns_compare_name+0x15c>)
 8007196:	18d3      	adds	r3, r2, r3
 8007198:	781b      	ldrb	r3, [r3, #0]
 800719a:	001a      	movs	r2, r3
 800719c:	2303      	movs	r3, #3
 800719e:	4013      	ands	r3, r2
 80071a0:	2b01      	cmp	r3, #1
 80071a2:	d104      	bne.n	80071ae <dns_compare_name+0xa2>
 80071a4:	187b      	adds	r3, r7, r1
 80071a6:	781b      	ldrb	r3, [r3, #0]
 80071a8:	3320      	adds	r3, #32
 80071aa:	001a      	movs	r2, r3
 80071ac:	e002      	b.n	80071b4 <dns_compare_name+0xa8>
 80071ae:	2313      	movs	r3, #19
 80071b0:	18fb      	adds	r3, r7, r3
 80071b2:	781a      	ldrb	r2, [r3, #0]
 80071b4:	2012      	movs	r0, #18
 80071b6:	183b      	adds	r3, r7, r0
 80071b8:	6979      	ldr	r1, [r7, #20]
 80071ba:	7019      	strb	r1, [r3, #0]
 80071bc:	183b      	adds	r3, r7, r0
 80071be:	781b      	ldrb	r3, [r3, #0]
 80071c0:	1c59      	adds	r1, r3, #1
 80071c2:	4b29      	ldr	r3, [pc, #164]	; (8007268 <dns_compare_name+0x15c>)
 80071c4:	18cb      	adds	r3, r1, r3
 80071c6:	781b      	ldrb	r3, [r3, #0]
 80071c8:	0019      	movs	r1, r3
 80071ca:	2303      	movs	r3, #3
 80071cc:	400b      	ands	r3, r1
 80071ce:	2b01      	cmp	r3, #1
 80071d0:	d103      	bne.n	80071da <dns_compare_name+0xce>
 80071d2:	183b      	adds	r3, r7, r0
 80071d4:	781b      	ldrb	r3, [r3, #0]
 80071d6:	3320      	adds	r3, #32
 80071d8:	e002      	b.n	80071e0 <dns_compare_name+0xd4>
 80071da:	2312      	movs	r3, #18
 80071dc:	18fb      	adds	r3, r7, r3
 80071de:	781b      	ldrb	r3, [r3, #0]
 80071e0:	429a      	cmp	r2, r3
 80071e2:	d001      	beq.n	80071e8 <dns_compare_name+0xdc>
          return 0xFFFF;
 80071e4:	4b1f      	ldr	r3, [pc, #124]	; (8007264 <dns_compare_name+0x158>)
 80071e6:	e039      	b.n	800725c <dns_compare_name+0x150>
        }
        if (response_offset == 0xFFFF) {
 80071e8:	231a      	movs	r3, #26
 80071ea:	18fb      	adds	r3, r7, r3
 80071ec:	881b      	ldrh	r3, [r3, #0]
 80071ee:	4a1d      	ldr	r2, [pc, #116]	; (8007264 <dns_compare_name+0x158>)
 80071f0:	4293      	cmp	r3, r2
 80071f2:	d101      	bne.n	80071f8 <dns_compare_name+0xec>
          /* would overflow */
          return 0xFFFF;
 80071f4:	4b1b      	ldr	r3, [pc, #108]	; (8007264 <dns_compare_name+0x158>)
 80071f6:	e031      	b.n	800725c <dns_compare_name+0x150>
        }
        response_offset++;
 80071f8:	211a      	movs	r1, #26
 80071fa:	187b      	adds	r3, r7, r1
 80071fc:	881a      	ldrh	r2, [r3, #0]
 80071fe:	187b      	adds	r3, r7, r1
 8007200:	3201      	adds	r2, #1
 8007202:	801a      	strh	r2, [r3, #0]
        ++query;
 8007204:	68fb      	ldr	r3, [r7, #12]
 8007206:	3301      	adds	r3, #1
 8007208:	60fb      	str	r3, [r7, #12]
        --n;
 800720a:	69fb      	ldr	r3, [r7, #28]
 800720c:	3b01      	subs	r3, #1
 800720e:	61fb      	str	r3, [r7, #28]
      while (n > 0) {
 8007210:	69fb      	ldr	r3, [r7, #28]
 8007212:	2b00      	cmp	r3, #0
 8007214:	dca7      	bgt.n	8007166 <dns_compare_name+0x5a>
      }
      ++query;
 8007216:	68fb      	ldr	r3, [r7, #12]
 8007218:	3301      	adds	r3, #1
 800721a:	60fb      	str	r3, [r7, #12]
    }
    n = pbuf_try_get_at(p, response_offset);
 800721c:	231a      	movs	r3, #26
 800721e:	18fb      	adds	r3, r7, r3
 8007220:	881a      	ldrh	r2, [r3, #0]
 8007222:	68bb      	ldr	r3, [r7, #8]
 8007224:	0011      	movs	r1, r2
 8007226:	0018      	movs	r0, r3
 8007228:	f003 fb7d 	bl	800a926 <pbuf_try_get_at>
 800722c:	0003      	movs	r3, r0
 800722e:	61fb      	str	r3, [r7, #28]
    if (n < 0) {
 8007230:	69fb      	ldr	r3, [r7, #28]
 8007232:	2b00      	cmp	r3, #0
 8007234:	da01      	bge.n	800723a <dns_compare_name+0x12e>
      return 0xFFFF;
 8007236:	4b0b      	ldr	r3, [pc, #44]	; (8007264 <dns_compare_name+0x158>)
 8007238:	e010      	b.n	800725c <dns_compare_name+0x150>
    }
  } while (n != 0);
 800723a:	69fb      	ldr	r3, [r7, #28]
 800723c:	2b00      	cmp	r3, #0
 800723e:	d000      	beq.n	8007242 <dns_compare_name+0x136>
 8007240:	e770      	b.n	8007124 <dns_compare_name+0x18>

  if (response_offset == 0xFFFF) {
 8007242:	231a      	movs	r3, #26
 8007244:	18fb      	adds	r3, r7, r3
 8007246:	881b      	ldrh	r3, [r3, #0]
 8007248:	4a06      	ldr	r2, [pc, #24]	; (8007264 <dns_compare_name+0x158>)
 800724a:	4293      	cmp	r3, r2
 800724c:	d101      	bne.n	8007252 <dns_compare_name+0x146>
    /* would overflow */
    return 0xFFFF;
 800724e:	4b05      	ldr	r3, [pc, #20]	; (8007264 <dns_compare_name+0x158>)
 8007250:	e004      	b.n	800725c <dns_compare_name+0x150>
  }
  return (u16_t)(response_offset + 1);
 8007252:	231a      	movs	r3, #26
 8007254:	18fb      	adds	r3, r7, r3
 8007256:	881b      	ldrh	r3, [r3, #0]
 8007258:	3301      	adds	r3, #1
 800725a:	b29b      	uxth	r3, r3
}
 800725c:	0018      	movs	r0, r3
 800725e:	46bd      	mov	sp, r7
 8007260:	b009      	add	sp, #36	; 0x24
 8007262:	bd90      	pop	{r4, r7, pc}
 8007264:	0000ffff 	.word	0x0000ffff
 8007268:	08022e64 	.word	0x08022e64

0800726c <dns_skip_name>:
 * @param query_idx start index into p pointing to encoded DNS name in the DNS server response
 * @return index to end of the name
 */
static u16_t
dns_skip_name(struct pbuf *p, u16_t query_idx)
{
 800726c:	b590      	push	{r4, r7, lr}
 800726e:	b085      	sub	sp, #20
 8007270:	af00      	add	r7, sp, #0
 8007272:	6078      	str	r0, [r7, #4]
 8007274:	000a      	movs	r2, r1
 8007276:	1cbb      	adds	r3, r7, #2
 8007278:	801a      	strh	r2, [r3, #0]
  int n;
  u16_t offset = query_idx;
 800727a:	230e      	movs	r3, #14
 800727c:	18fb      	adds	r3, r7, r3
 800727e:	1cba      	adds	r2, r7, #2
 8007280:	8812      	ldrh	r2, [r2, #0]
 8007282:	801a      	strh	r2, [r3, #0]

  do {
    n = pbuf_try_get_at(p, offset++);
 8007284:	240e      	movs	r4, #14
 8007286:	193b      	adds	r3, r7, r4
 8007288:	881b      	ldrh	r3, [r3, #0]
 800728a:	193a      	adds	r2, r7, r4
 800728c:	1c59      	adds	r1, r3, #1
 800728e:	8011      	strh	r1, [r2, #0]
 8007290:	687a      	ldr	r2, [r7, #4]
 8007292:	0019      	movs	r1, r3
 8007294:	0010      	movs	r0, r2
 8007296:	f003 fb46 	bl	800a926 <pbuf_try_get_at>
 800729a:	0003      	movs	r3, r0
 800729c:	60bb      	str	r3, [r7, #8]
    if ((n < 0) || (offset == 0)) {
 800729e:	68bb      	ldr	r3, [r7, #8]
 80072a0:	2b00      	cmp	r3, #0
 80072a2:	db03      	blt.n	80072ac <dns_skip_name+0x40>
 80072a4:	193b      	adds	r3, r7, r4
 80072a6:	881b      	ldrh	r3, [r3, #0]
 80072a8:	2b00      	cmp	r3, #0
 80072aa:	d101      	bne.n	80072b0 <dns_skip_name+0x44>
      return 0xFFFF;
 80072ac:	4b1e      	ldr	r3, [pc, #120]	; (8007328 <dns_skip_name+0xbc>)
 80072ae:	e037      	b.n	8007320 <dns_skip_name+0xb4>
    }
    /** @see RFC 1035 - 4.1.4. Message compression */
    if ((n & 0xc0) == 0xc0) {
 80072b0:	68bb      	ldr	r3, [r7, #8]
 80072b2:	22c0      	movs	r2, #192	; 0xc0
 80072b4:	4013      	ands	r3, r2
 80072b6:	2bc0      	cmp	r3, #192	; 0xc0
 80072b8:	d024      	beq.n	8007304 <dns_skip_name+0x98>
      /* Compressed name: since we only want to skip it (not check it), stop here */
      break;
    } else {
      /* Not compressed name */
      if (offset + n >= p->tot_len) {
 80072ba:	230e      	movs	r3, #14
 80072bc:	18fb      	adds	r3, r7, r3
 80072be:	881a      	ldrh	r2, [r3, #0]
 80072c0:	68bb      	ldr	r3, [r7, #8]
 80072c2:	18d3      	adds	r3, r2, r3
 80072c4:	687a      	ldr	r2, [r7, #4]
 80072c6:	8912      	ldrh	r2, [r2, #8]
 80072c8:	4293      	cmp	r3, r2
 80072ca:	db01      	blt.n	80072d0 <dns_skip_name+0x64>
        return 0xFFFF;
 80072cc:	4b16      	ldr	r3, [pc, #88]	; (8007328 <dns_skip_name+0xbc>)
 80072ce:	e027      	b.n	8007320 <dns_skip_name+0xb4>
      }
      offset = (u16_t)(offset + n);
 80072d0:	68bb      	ldr	r3, [r7, #8]
 80072d2:	b299      	uxth	r1, r3
 80072d4:	200e      	movs	r0, #14
 80072d6:	183b      	adds	r3, r7, r0
 80072d8:	183a      	adds	r2, r7, r0
 80072da:	8812      	ldrh	r2, [r2, #0]
 80072dc:	188a      	adds	r2, r1, r2
 80072de:	801a      	strh	r2, [r3, #0]
    }
    n = pbuf_try_get_at(p, offset);
 80072e0:	183b      	adds	r3, r7, r0
 80072e2:	881a      	ldrh	r2, [r3, #0]
 80072e4:	687b      	ldr	r3, [r7, #4]
 80072e6:	0011      	movs	r1, r2
 80072e8:	0018      	movs	r0, r3
 80072ea:	f003 fb1c 	bl	800a926 <pbuf_try_get_at>
 80072ee:	0003      	movs	r3, r0
 80072f0:	60bb      	str	r3, [r7, #8]
    if (n < 0) {
 80072f2:	68bb      	ldr	r3, [r7, #8]
 80072f4:	2b00      	cmp	r3, #0
 80072f6:	da01      	bge.n	80072fc <dns_skip_name+0x90>
      return 0xFFFF;
 80072f8:	4b0b      	ldr	r3, [pc, #44]	; (8007328 <dns_skip_name+0xbc>)
 80072fa:	e011      	b.n	8007320 <dns_skip_name+0xb4>
    }
  } while (n != 0);
 80072fc:	68bb      	ldr	r3, [r7, #8]
 80072fe:	2b00      	cmp	r3, #0
 8007300:	d1c0      	bne.n	8007284 <dns_skip_name+0x18>
 8007302:	e000      	b.n	8007306 <dns_skip_name+0x9a>
      break;
 8007304:	46c0      	nop			; (mov r8, r8)

  if (offset == 0xFFFF) {
 8007306:	230e      	movs	r3, #14
 8007308:	18fb      	adds	r3, r7, r3
 800730a:	881b      	ldrh	r3, [r3, #0]
 800730c:	4a06      	ldr	r2, [pc, #24]	; (8007328 <dns_skip_name+0xbc>)
 800730e:	4293      	cmp	r3, r2
 8007310:	d101      	bne.n	8007316 <dns_skip_name+0xaa>
    return 0xFFFF;
 8007312:	4b05      	ldr	r3, [pc, #20]	; (8007328 <dns_skip_name+0xbc>)
 8007314:	e004      	b.n	8007320 <dns_skip_name+0xb4>
  }
  return (u16_t)(offset + 1);
 8007316:	230e      	movs	r3, #14
 8007318:	18fb      	adds	r3, r7, r3
 800731a:	881b      	ldrh	r3, [r3, #0]
 800731c:	3301      	adds	r3, #1
 800731e:	b29b      	uxth	r3, r3
}
 8007320:	0018      	movs	r0, r3
 8007322:	46bd      	mov	sp, r7
 8007324:	b005      	add	sp, #20
 8007326:	bd90      	pop	{r4, r7, pc}
 8007328:	0000ffff 	.word	0x0000ffff

0800732c <dns_send>:
 * @param idx the DNS table entry index for which to send a request
 * @return ERR_OK if packet is sent; an err_t indicating the problem otherwise
 */
static err_t
dns_send(u8_t idx)
{
 800732c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800732e:	b091      	sub	sp, #68	; 0x44
 8007330:	af00      	add	r7, sp, #0
 8007332:	0002      	movs	r2, r0
 8007334:	1dfb      	adds	r3, r7, #7
 8007336:	701a      	strb	r2, [r3, #0]
  struct pbuf *p;
  u16_t query_idx, copy_len;
  const char *hostname, *hostname_part;
  u8_t n;
  u8_t pcb_idx;
  struct dns_table_entry *entry = &dns_table[idx];
 8007338:	1dfb      	adds	r3, r7, #7
 800733a:	781a      	ldrb	r2, [r3, #0]
 800733c:	0013      	movs	r3, r2
 800733e:	00db      	lsls	r3, r3, #3
 8007340:	189b      	adds	r3, r3, r2
 8007342:	011b      	lsls	r3, r3, #4
 8007344:	4a7e      	ldr	r2, [pc, #504]	; (8007540 <dns_send+0x214>)
 8007346:	189b      	adds	r3, r3, r2
 8007348:	633b      	str	r3, [r7, #48]	; 0x30

  LWIP_DEBUGF(DNS_DEBUG, ("dns_send: dns_servers[%"U16_F"] \"%s\": request\n",
                          (u16_t)(entry->server_idx), entry->name));
  LWIP_ASSERT("dns server out of array", entry->server_idx < DNS_MAX_SERVERS);
 800734a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800734c:	7adb      	ldrb	r3, [r3, #11]
 800734e:	2b01      	cmp	r3, #1
 8007350:	d905      	bls.n	800735e <dns_send+0x32>
 8007352:	4b7c      	ldr	r3, [pc, #496]	; (8007544 <dns_send+0x218>)
 8007354:	4a7c      	ldr	r2, [pc, #496]	; (8007548 <dns_send+0x21c>)
 8007356:	497d      	ldr	r1, [pc, #500]	; (800754c <dns_send+0x220>)
 8007358:	487d      	ldr	r0, [pc, #500]	; (8007550 <dns_send+0x224>)
 800735a:	f7fb fc35 	bl	8002bc8 <app_debug_rtt_raw>
  if (ip_addr_isany_val(dns_servers[entry->server_idx])
 800735e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007360:	7adb      	ldrb	r3, [r3, #11]
 8007362:	001a      	movs	r2, r3
 8007364:	4b7b      	ldr	r3, [pc, #492]	; (8007554 <dns_send+0x228>)
 8007366:	0092      	lsls	r2, r2, #2
 8007368:	58d3      	ldr	r3, [r2, r3]
 800736a:	2b00      	cmp	r3, #0
 800736c:	d10a      	bne.n	8007384 <dns_send+0x58>
      && !entry->is_mdns
#endif
     ) {
    /* DNS server not valid anymore, e.g. PPP netif has been shut down */
    /* call specified callback function if provided */
    dns_call_found(idx, NULL);
 800736e:	1dfb      	adds	r3, r7, #7
 8007370:	781b      	ldrb	r3, [r3, #0]
 8007372:	2100      	movs	r1, #0
 8007374:	0018      	movs	r0, r3
 8007376:	f000 f9a3 	bl	80076c0 <dns_call_found>
    /* flush this entry */
    entry->state = DNS_STATE_UNUSED;
 800737a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800737c:	2200      	movs	r2, #0
 800737e:	729a      	strb	r2, [r3, #10]
    return ERR_OK;
 8007380:	2300      	movs	r3, #0
 8007382:	e0d8      	b.n	8007536 <dns_send+0x20a>
  }

  /* if here, we have either a new query or a retry on a previous query to process */
  p = pbuf_alloc(PBUF_TRANSPORT, (u16_t)(SIZEOF_DNS_HDR + strlen(entry->name) + 2 +
 8007384:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007386:	3310      	adds	r3, #16
 8007388:	0018      	movs	r0, r3
 800738a:	f7f8 febd 	bl	8000108 <strlen>
 800738e:	0003      	movs	r3, r0
 8007390:	b29b      	uxth	r3, r3
 8007392:	3312      	adds	r3, #18
 8007394:	b29b      	uxth	r3, r3
 8007396:	22a0      	movs	r2, #160	; 0xa0
 8007398:	0092      	lsls	r2, r2, #2
 800739a:	0019      	movs	r1, r3
 800739c:	2038      	movs	r0, #56	; 0x38
 800739e:	f002 fa15 	bl	80097cc <pbuf_alloc>
 80073a2:	0003      	movs	r3, r0
 80073a4:	62fb      	str	r3, [r7, #44]	; 0x2c
                                         SIZEOF_DNS_QUERY), PBUF_RAM);
  if (p != NULL) {
 80073a6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80073a8:	2b00      	cmp	r3, #0
 80073aa:	d100      	bne.n	80073ae <dns_send+0x82>
 80073ac:	e0b3      	b.n	8007516 <dns_send+0x1ea>
    const ip_addr_t *dst;
    u16_t dst_port;
    /* fill dns header */
    memset(&hdr, 0, SIZEOF_DNS_HDR);
 80073ae:	2410      	movs	r4, #16
 80073b0:	193b      	adds	r3, r7, r4
 80073b2:	220c      	movs	r2, #12
 80073b4:	2100      	movs	r1, #0
 80073b6:	0018      	movs	r0, r3
 80073b8:	f015 fda4 	bl	801cf04 <memset>
    hdr.id = lwip_htons(entry->txid);
 80073bc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80073be:	891b      	ldrh	r3, [r3, #8]
 80073c0:	0018      	movs	r0, r3
 80073c2:	f7ff fd97 	bl	8006ef4 <lwip_htons>
 80073c6:	0003      	movs	r3, r0
 80073c8:	001a      	movs	r2, r3
 80073ca:	193b      	adds	r3, r7, r4
 80073cc:	801a      	strh	r2, [r3, #0]
    hdr.flags1 = DNS_FLAG1_RD;
 80073ce:	193b      	adds	r3, r7, r4
 80073d0:	2201      	movs	r2, #1
 80073d2:	709a      	strb	r2, [r3, #2]
    hdr.numquestions = PP_HTONS(1);
 80073d4:	193b      	adds	r3, r7, r4
 80073d6:	2280      	movs	r2, #128	; 0x80
 80073d8:	0052      	lsls	r2, r2, #1
 80073da:	809a      	strh	r2, [r3, #4]
    pbuf_take(p, &hdr, SIZEOF_DNS_HDR);
 80073dc:	1939      	adds	r1, r7, r4
 80073de:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80073e0:	220c      	movs	r2, #12
 80073e2:	0018      	movs	r0, r3
 80073e4:	f003 f90a 	bl	800a5fc <pbuf_take>
    hostname = entry->name;
 80073e8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80073ea:	3310      	adds	r3, #16
 80073ec:	63bb      	str	r3, [r7, #56]	; 0x38
    --hostname;
 80073ee:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80073f0:	3b01      	subs	r3, #1
 80073f2:	63bb      	str	r3, [r7, #56]	; 0x38

    /* convert hostname into suitable query format. */
    query_idx = SIZEOF_DNS_HDR;
 80073f4:	233c      	movs	r3, #60	; 0x3c
 80073f6:	18fb      	adds	r3, r7, r3
 80073f8:	220c      	movs	r2, #12
 80073fa:	801a      	strh	r2, [r3, #0]
    do {
      ++hostname;
 80073fc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80073fe:	3301      	adds	r3, #1
 8007400:	63bb      	str	r3, [r7, #56]	; 0x38
      hostname_part = hostname;
 8007402:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007404:	62bb      	str	r3, [r7, #40]	; 0x28
      for (n = 0; *hostname != '.' && *hostname != 0; ++hostname) {
 8007406:	2337      	movs	r3, #55	; 0x37
 8007408:	18fb      	adds	r3, r7, r3
 800740a:	2200      	movs	r2, #0
 800740c:	701a      	strb	r2, [r3, #0]
 800740e:	e008      	b.n	8007422 <dns_send+0xf6>
        ++n;
 8007410:	2237      	movs	r2, #55	; 0x37
 8007412:	18bb      	adds	r3, r7, r2
 8007414:	18ba      	adds	r2, r7, r2
 8007416:	7812      	ldrb	r2, [r2, #0]
 8007418:	3201      	adds	r2, #1
 800741a:	701a      	strb	r2, [r3, #0]
      for (n = 0; *hostname != '.' && *hostname != 0; ++hostname) {
 800741c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800741e:	3301      	adds	r3, #1
 8007420:	63bb      	str	r3, [r7, #56]	; 0x38
 8007422:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007424:	781b      	ldrb	r3, [r3, #0]
 8007426:	2b2e      	cmp	r3, #46	; 0x2e
 8007428:	d003      	beq.n	8007432 <dns_send+0x106>
 800742a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800742c:	781b      	ldrb	r3, [r3, #0]
 800742e:	2b00      	cmp	r3, #0
 8007430:	d1ee      	bne.n	8007410 <dns_send+0xe4>
      }
      copy_len = (u16_t)(hostname - hostname_part);
 8007432:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8007434:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007436:	1ad2      	subs	r2, r2, r3
 8007438:	2326      	movs	r3, #38	; 0x26
 800743a:	18fb      	adds	r3, r7, r3
 800743c:	801a      	strh	r2, [r3, #0]
      if (query_idx + n + 1 > 0xFFFF) {
 800743e:	253c      	movs	r5, #60	; 0x3c
 8007440:	197b      	adds	r3, r7, r5
 8007442:	881a      	ldrh	r2, [r3, #0]
 8007444:	2637      	movs	r6, #55	; 0x37
 8007446:	19bb      	adds	r3, r7, r6
 8007448:	781b      	ldrb	r3, [r3, #0]
 800744a:	18d3      	adds	r3, r2, r3
 800744c:	4a42      	ldr	r2, [pc, #264]	; (8007558 <dns_send+0x22c>)
 800744e:	4293      	cmp	r3, r2
 8007450:	dc6a      	bgt.n	8007528 <dns_send+0x1fc>
        /* u16_t overflow */
        goto overflow_return;
      }
      pbuf_put_at(p, query_idx, n);
 8007452:	19bb      	adds	r3, r7, r6
 8007454:	781a      	ldrb	r2, [r3, #0]
 8007456:	197b      	adds	r3, r7, r5
 8007458:	8819      	ldrh	r1, [r3, #0]
 800745a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800745c:	0018      	movs	r0, r3
 800745e:	f003 fa89 	bl	800a974 <pbuf_put_at>
      pbuf_take_at(p, hostname_part, copy_len, (u16_t)(query_idx + 1));
 8007462:	197b      	adds	r3, r7, r5
 8007464:	881b      	ldrh	r3, [r3, #0]
 8007466:	3301      	adds	r3, #1
 8007468:	b29c      	uxth	r4, r3
 800746a:	2326      	movs	r3, #38	; 0x26
 800746c:	18fb      	adds	r3, r7, r3
 800746e:	881a      	ldrh	r2, [r3, #0]
 8007470:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8007472:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8007474:	0023      	movs	r3, r4
 8007476:	f003 f951 	bl	800a71c <pbuf_take_at>
      query_idx = (u16_t)(query_idx + n + 1);
 800747a:	19bb      	adds	r3, r7, r6
 800747c:	781b      	ldrb	r3, [r3, #0]
 800747e:	b29a      	uxth	r2, r3
 8007480:	197b      	adds	r3, r7, r5
 8007482:	881b      	ldrh	r3, [r3, #0]
 8007484:	18d3      	adds	r3, r2, r3
 8007486:	b29a      	uxth	r2, r3
 8007488:	197b      	adds	r3, r7, r5
 800748a:	3201      	adds	r2, #1
 800748c:	801a      	strh	r2, [r3, #0]
    } while (*hostname != 0);
 800748e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007490:	781b      	ldrb	r3, [r3, #0]
 8007492:	2b00      	cmp	r3, #0
 8007494:	d1b2      	bne.n	80073fc <dns_send+0xd0>
    pbuf_put_at(p, query_idx, 0);
 8007496:	197b      	adds	r3, r7, r5
 8007498:	8819      	ldrh	r1, [r3, #0]
 800749a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800749c:	2200      	movs	r2, #0
 800749e:	0018      	movs	r0, r3
 80074a0:	f003 fa68 	bl	800a974 <pbuf_put_at>
    query_idx++;
 80074a4:	0029      	movs	r1, r5
 80074a6:	187b      	adds	r3, r7, r1
 80074a8:	881a      	ldrh	r2, [r3, #0]
 80074aa:	187b      	adds	r3, r7, r1
 80074ac:	3201      	adds	r2, #1
 80074ae:	801a      	strh	r2, [r3, #0]

    /* fill dns query */
    if (LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype)) {
      qry.type = PP_HTONS(DNS_RRTYPE_AAAA);
    } else {
      qry.type = PP_HTONS(DNS_RRTYPE_A);
 80074b0:	200c      	movs	r0, #12
 80074b2:	183b      	adds	r3, r7, r0
 80074b4:	2280      	movs	r2, #128	; 0x80
 80074b6:	0052      	lsls	r2, r2, #1
 80074b8:	801a      	strh	r2, [r3, #0]
    }
    qry.cls = PP_HTONS(DNS_RRCLASS_IN);
 80074ba:	183b      	adds	r3, r7, r0
 80074bc:	2280      	movs	r2, #128	; 0x80
 80074be:	0052      	lsls	r2, r2, #1
 80074c0:	805a      	strh	r2, [r3, #2]
    pbuf_take_at(p, &qry, SIZEOF_DNS_QUERY, query_idx);
 80074c2:	187b      	adds	r3, r7, r1
 80074c4:	881b      	ldrh	r3, [r3, #0]
 80074c6:	1839      	adds	r1, r7, r0
 80074c8:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80074ca:	2204      	movs	r2, #4
 80074cc:	f003 f926 	bl	800a71c <pbuf_take_at>

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) != 0)
    pcb_idx = entry->pcb_idx;
 80074d0:	2125      	movs	r1, #37	; 0x25
 80074d2:	187b      	adds	r3, r7, r1
 80074d4:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80074d6:	7bd2      	ldrb	r2, [r2, #15]
 80074d8:	701a      	strb	r2, [r3, #0]
      }
#endif
    } else
#endif /* LWIP_DNS_SUPPORT_MDNS_QUERIES */
    {
      dst_port = DNS_SERVER_PORT;
 80074da:	2522      	movs	r5, #34	; 0x22
 80074dc:	197b      	adds	r3, r7, r5
 80074de:	2235      	movs	r2, #53	; 0x35
 80074e0:	801a      	strh	r2, [r3, #0]
      dst = &dns_servers[entry->server_idx];
 80074e2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80074e4:	7adb      	ldrb	r3, [r3, #11]
 80074e6:	009a      	lsls	r2, r3, #2
 80074e8:	4b1a      	ldr	r3, [pc, #104]	; (8007554 <dns_send+0x228>)
 80074ea:	18d3      	adds	r3, r2, r3
 80074ec:	61fb      	str	r3, [r7, #28]
    }
    err = udp_sendto(dns_pcbs[pcb_idx], p, dst, dst_port);
 80074ee:	187b      	adds	r3, r7, r1
 80074f0:	781a      	ldrb	r2, [r3, #0]
 80074f2:	4b1a      	ldr	r3, [pc, #104]	; (800755c <dns_send+0x230>)
 80074f4:	0092      	lsls	r2, r2, #2
 80074f6:	58d0      	ldr	r0, [r2, r3]
 80074f8:	233f      	movs	r3, #63	; 0x3f
 80074fa:	18fc      	adds	r4, r7, r3
 80074fc:	197b      	adds	r3, r7, r5
 80074fe:	881b      	ldrh	r3, [r3, #0]
 8007500:	69fa      	ldr	r2, [r7, #28]
 8007502:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8007504:	f00b f9f8 	bl	80128f8 <udp_sendto>
 8007508:	0003      	movs	r3, r0
 800750a:	7023      	strb	r3, [r4, #0]

    /* free pbuf */
    pbuf_free(p);
 800750c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800750e:	0018      	movs	r0, r3
 8007510:	f002 fcd4 	bl	8009ebc <pbuf_free>
 8007514:	e003      	b.n	800751e <dns_send+0x1f2>
  } else {
    err = ERR_MEM;
 8007516:	233f      	movs	r3, #63	; 0x3f
 8007518:	18fb      	adds	r3, r7, r3
 800751a:	22ff      	movs	r2, #255	; 0xff
 800751c:	701a      	strb	r2, [r3, #0]
  }

  return err;
 800751e:	233f      	movs	r3, #63	; 0x3f
 8007520:	18fb      	adds	r3, r7, r3
 8007522:	781b      	ldrb	r3, [r3, #0]
 8007524:	b25b      	sxtb	r3, r3
 8007526:	e006      	b.n	8007536 <dns_send+0x20a>
        goto overflow_return;
 8007528:	46c0      	nop			; (mov r8, r8)
overflow_return:
  pbuf_free(p);
 800752a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800752c:	0018      	movs	r0, r3
 800752e:	f002 fcc5 	bl	8009ebc <pbuf_free>
  return ERR_VAL;
 8007532:	2306      	movs	r3, #6
 8007534:	425b      	negs	r3, r3
}
 8007536:	0018      	movs	r0, r3
 8007538:	46bd      	mov	sp, r7
 800753a:	b011      	add	sp, #68	; 0x44
 800753c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800753e:	46c0      	nop			; (mov r8, r8)
 8007540:	2000158c 	.word	0x2000158c
 8007544:	0801f1fc 	.word	0x0801f1fc
 8007548:	000002fa 	.word	0x000002fa
 800754c:	0801f224 	.word	0x0801f224
 8007550:	0801f23c 	.word	0x0801f23c
 8007554:	20001760 	.word	0x20001760
 8007558:	0000fffe 	.word	0x0000fffe
 800755c:	2000157c 	.word	0x2000157c

08007560 <dns_alloc_random_port>:

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) != 0)
static struct udp_pcb *
dns_alloc_random_port(void)
{
 8007560:	b590      	push	{r4, r7, lr}
 8007562:	b085      	sub	sp, #20
 8007564:	af00      	add	r7, sp, #0
  err_t err;
  struct udp_pcb *pcb;

  pcb = udp_new_ip_type(IPADDR_TYPE_ANY);
 8007566:	202e      	movs	r0, #46	; 0x2e
 8007568:	f00b fd3d 	bl	8012fe6 <udp_new_ip_type>
 800756c:	0003      	movs	r3, r0
 800756e:	60bb      	str	r3, [r7, #8]
  if (pcb == NULL) {
 8007570:	68bb      	ldr	r3, [r7, #8]
 8007572:	2b00      	cmp	r3, #0
 8007574:	d101      	bne.n	800757a <dns_alloc_random_port+0x1a>
    /* out of memory, have to reuse an existing pcb */
    return NULL;
 8007576:	2300      	movs	r3, #0
 8007578:	e032      	b.n	80075e0 <dns_alloc_random_port+0x80>
  }
  do {
    u16_t port = (u16_t)DNS_RAND_TXID();
 800757a:	f015 fc43 	bl	801ce04 <sys_rand>
 800757e:	0002      	movs	r2, r0
 8007580:	1dbb      	adds	r3, r7, #6
 8007582:	801a      	strh	r2, [r3, #0]
    if (DNS_PORT_ALLOWED(port)) {
 8007584:	1dbb      	adds	r3, r7, #6
 8007586:	881a      	ldrh	r2, [r3, #0]
 8007588:	2380      	movs	r3, #128	; 0x80
 800758a:	00db      	lsls	r3, r3, #3
 800758c:	429a      	cmp	r2, r3
 800758e:	d30b      	bcc.n	80075a8 <dns_alloc_random_port+0x48>
      err = udp_bind(pcb, IP_ANY_TYPE, port);
 8007590:	230f      	movs	r3, #15
 8007592:	18fc      	adds	r4, r7, r3
 8007594:	1dbb      	adds	r3, r7, #6
 8007596:	881a      	ldrh	r2, [r3, #0]
 8007598:	4913      	ldr	r1, [pc, #76]	; (80075e8 <dns_alloc_random_port+0x88>)
 800759a:	68bb      	ldr	r3, [r7, #8]
 800759c:	0018      	movs	r0, r3
 800759e:	f00b fc1b 	bl	8012dd8 <udp_bind>
 80075a2:	0003      	movs	r3, r0
 80075a4:	7023      	strb	r3, [r4, #0]
 80075a6:	e003      	b.n	80075b0 <dns_alloc_random_port+0x50>
    } else {
      /* this port is not allowed, try again */
      err = ERR_USE;
 80075a8:	230f      	movs	r3, #15
 80075aa:	18fb      	adds	r3, r7, r3
 80075ac:	22f8      	movs	r2, #248	; 0xf8
 80075ae:	701a      	strb	r2, [r3, #0]
    }
  } while (err == ERR_USE);
 80075b0:	220f      	movs	r2, #15
 80075b2:	18bb      	adds	r3, r7, r2
 80075b4:	781b      	ldrb	r3, [r3, #0]
 80075b6:	b25b      	sxtb	r3, r3
 80075b8:	3308      	adds	r3, #8
 80075ba:	d0de      	beq.n	800757a <dns_alloc_random_port+0x1a>
  if (err != ERR_OK) {
 80075bc:	18bb      	adds	r3, r7, r2
 80075be:	781b      	ldrb	r3, [r3, #0]
 80075c0:	b25b      	sxtb	r3, r3
 80075c2:	2b00      	cmp	r3, #0
 80075c4:	d005      	beq.n	80075d2 <dns_alloc_random_port+0x72>
    udp_remove(pcb);
 80075c6:	68bb      	ldr	r3, [r7, #8]
 80075c8:	0018      	movs	r0, r3
 80075ca:	f00b fcb7 	bl	8012f3c <udp_remove>
    return NULL;
 80075ce:	2300      	movs	r3, #0
 80075d0:	e006      	b.n	80075e0 <dns_alloc_random_port+0x80>
  }
  udp_recv(pcb, dns_recv, NULL);
 80075d2:	4906      	ldr	r1, [pc, #24]	; (80075ec <dns_alloc_random_port+0x8c>)
 80075d4:	68bb      	ldr	r3, [r7, #8]
 80075d6:	2200      	movs	r2, #0
 80075d8:	0018      	movs	r0, r3
 80075da:	f00b fc95 	bl	8012f08 <udp_recv>
  return pcb;
 80075de:	68bb      	ldr	r3, [r7, #8]
}
 80075e0:	0018      	movs	r0, r3
 80075e2:	46bd      	mov	sp, r7
 80075e4:	b005      	add	sp, #20
 80075e6:	bd90      	pop	{r4, r7, pc}
 80075e8:	08022888 	.word	0x08022888
 80075ec:	08007b0d 	.word	0x08007b0d

080075f0 <dns_alloc_pcb>:
 *
 * @return an index into dns_pcbs
 */
static u8_t
dns_alloc_pcb(void)
{
 80075f0:	b590      	push	{r4, r7, lr}
 80075f2:	b083      	sub	sp, #12
 80075f4:	af00      	add	r7, sp, #0
  u8_t i;
  u8_t idx;

  for (i = 0; i < DNS_MAX_SOURCE_PORTS; i++) {
 80075f6:	1dfb      	adds	r3, r7, #7
 80075f8:	2200      	movs	r2, #0
 80075fa:	701a      	strb	r2, [r3, #0]
 80075fc:	e00b      	b.n	8007616 <dns_alloc_pcb+0x26>
    if (dns_pcbs[i] == NULL) {
 80075fe:	1dfb      	adds	r3, r7, #7
 8007600:	781a      	ldrb	r2, [r3, #0]
 8007602:	4b2d      	ldr	r3, [pc, #180]	; (80076b8 <dns_alloc_pcb+0xc8>)
 8007604:	0092      	lsls	r2, r2, #2
 8007606:	58d3      	ldr	r3, [r2, r3]
 8007608:	2b00      	cmp	r3, #0
 800760a:	d009      	beq.n	8007620 <dns_alloc_pcb+0x30>
  for (i = 0; i < DNS_MAX_SOURCE_PORTS; i++) {
 800760c:	1dfb      	adds	r3, r7, #7
 800760e:	781a      	ldrb	r2, [r3, #0]
 8007610:	1dfb      	adds	r3, r7, #7
 8007612:	3201      	adds	r2, #1
 8007614:	701a      	strb	r2, [r3, #0]
 8007616:	1dfb      	adds	r3, r7, #7
 8007618:	781b      	ldrb	r3, [r3, #0]
 800761a:	2b02      	cmp	r3, #2
 800761c:	d9ef      	bls.n	80075fe <dns_alloc_pcb+0xe>
 800761e:	e000      	b.n	8007622 <dns_alloc_pcb+0x32>
      break;
 8007620:	46c0      	nop			; (mov r8, r8)
    }
  }
  if (i < DNS_MAX_SOURCE_PORTS) {
 8007622:	1dfb      	adds	r3, r7, #7
 8007624:	781b      	ldrb	r3, [r3, #0]
 8007626:	2b02      	cmp	r3, #2
 8007628:	d815      	bhi.n	8007656 <dns_alloc_pcb+0x66>
    dns_pcbs[i] = dns_alloc_random_port();
 800762a:	1dfb      	adds	r3, r7, #7
 800762c:	781c      	ldrb	r4, [r3, #0]
 800762e:	f7ff ff97 	bl	8007560 <dns_alloc_random_port>
 8007632:	0001      	movs	r1, r0
 8007634:	4b20      	ldr	r3, [pc, #128]	; (80076b8 <dns_alloc_pcb+0xc8>)
 8007636:	00a2      	lsls	r2, r4, #2
 8007638:	50d1      	str	r1, [r2, r3]
    if (dns_pcbs[i] != NULL) {
 800763a:	1dfb      	adds	r3, r7, #7
 800763c:	781a      	ldrb	r2, [r3, #0]
 800763e:	4b1e      	ldr	r3, [pc, #120]	; (80076b8 <dns_alloc_pcb+0xc8>)
 8007640:	0092      	lsls	r2, r2, #2
 8007642:	58d3      	ldr	r3, [r2, r3]
 8007644:	2b00      	cmp	r3, #0
 8007646:	d006      	beq.n	8007656 <dns_alloc_pcb+0x66>
      /* succeeded */
      dns_last_pcb_idx = i;
 8007648:	4b1c      	ldr	r3, [pc, #112]	; (80076bc <dns_alloc_pcb+0xcc>)
 800764a:	1dfa      	adds	r2, r7, #7
 800764c:	7812      	ldrb	r2, [r2, #0]
 800764e:	701a      	strb	r2, [r3, #0]
      return i;
 8007650:	1dfb      	adds	r3, r7, #7
 8007652:	781b      	ldrb	r3, [r3, #0]
 8007654:	e02c      	b.n	80076b0 <dns_alloc_pcb+0xc0>
    }
  }
  /* if we come here, creating a new UDP pcb failed, so we have to use
     an already existing one (so overflow is no issue) */
  for (i = 0, idx = (u8_t)(dns_last_pcb_idx + 1); i < DNS_MAX_SOURCE_PORTS; i++, idx++) {
 8007656:	1dfb      	adds	r3, r7, #7
 8007658:	2200      	movs	r2, #0
 800765a:	701a      	strb	r2, [r3, #0]
 800765c:	4b17      	ldr	r3, [pc, #92]	; (80076bc <dns_alloc_pcb+0xcc>)
 800765e:	781a      	ldrb	r2, [r3, #0]
 8007660:	1dbb      	adds	r3, r7, #6
 8007662:	3201      	adds	r2, #1
 8007664:	701a      	strb	r2, [r3, #0]
 8007666:	e01e      	b.n	80076a6 <dns_alloc_pcb+0xb6>
    if (idx >= DNS_MAX_SOURCE_PORTS) {
 8007668:	1dbb      	adds	r3, r7, #6
 800766a:	781b      	ldrb	r3, [r3, #0]
 800766c:	2b02      	cmp	r3, #2
 800766e:	d902      	bls.n	8007676 <dns_alloc_pcb+0x86>
      idx = 0;
 8007670:	1dbb      	adds	r3, r7, #6
 8007672:	2200      	movs	r2, #0
 8007674:	701a      	strb	r2, [r3, #0]
    }
    if (dns_pcbs[idx] != NULL) {
 8007676:	1dbb      	adds	r3, r7, #6
 8007678:	781a      	ldrb	r2, [r3, #0]
 800767a:	4b0f      	ldr	r3, [pc, #60]	; (80076b8 <dns_alloc_pcb+0xc8>)
 800767c:	0092      	lsls	r2, r2, #2
 800767e:	58d3      	ldr	r3, [r2, r3]
 8007680:	2b00      	cmp	r3, #0
 8007682:	d006      	beq.n	8007692 <dns_alloc_pcb+0xa2>
      dns_last_pcb_idx = idx;
 8007684:	4b0d      	ldr	r3, [pc, #52]	; (80076bc <dns_alloc_pcb+0xcc>)
 8007686:	1dba      	adds	r2, r7, #6
 8007688:	7812      	ldrb	r2, [r2, #0]
 800768a:	701a      	strb	r2, [r3, #0]
      return idx;
 800768c:	1dbb      	adds	r3, r7, #6
 800768e:	781b      	ldrb	r3, [r3, #0]
 8007690:	e00e      	b.n	80076b0 <dns_alloc_pcb+0xc0>
  for (i = 0, idx = (u8_t)(dns_last_pcb_idx + 1); i < DNS_MAX_SOURCE_PORTS; i++, idx++) {
 8007692:	1dfb      	adds	r3, r7, #7
 8007694:	781a      	ldrb	r2, [r3, #0]
 8007696:	1dfb      	adds	r3, r7, #7
 8007698:	3201      	adds	r2, #1
 800769a:	701a      	strb	r2, [r3, #0]
 800769c:	1dbb      	adds	r3, r7, #6
 800769e:	781a      	ldrb	r2, [r3, #0]
 80076a0:	1dbb      	adds	r3, r7, #6
 80076a2:	3201      	adds	r2, #1
 80076a4:	701a      	strb	r2, [r3, #0]
 80076a6:	1dfb      	adds	r3, r7, #7
 80076a8:	781b      	ldrb	r3, [r3, #0]
 80076aa:	2b02      	cmp	r3, #2
 80076ac:	d9dc      	bls.n	8007668 <dns_alloc_pcb+0x78>
    }
  }
  return DNS_MAX_SOURCE_PORTS;
 80076ae:	2303      	movs	r3, #3
}
 80076b0:	0018      	movs	r0, r3
 80076b2:	46bd      	mov	sp, r7
 80076b4:	b003      	add	sp, #12
 80076b6:	bd90      	pop	{r4, r7, pc}
 80076b8:	2000157c 	.word	0x2000157c
 80076bc:	20001588 	.word	0x20001588

080076c0 <dns_call_found>:
 * @param idx dns table index of the entry that is resolved or removed
 * @param addr IP address for the hostname (or NULL on error or memory shortage)
 */
static void
dns_call_found(u8_t idx, ip_addr_t *addr)
{
 80076c0:	b5b0      	push	{r4, r5, r7, lr}
 80076c2:	b084      	sub	sp, #16
 80076c4:	af00      	add	r7, sp, #0
 80076c6:	0002      	movs	r2, r0
 80076c8:	6039      	str	r1, [r7, #0]
 80076ca:	1dfb      	adds	r3, r7, #7
 80076cc:	701a      	strb	r2, [r3, #0]
    }
  }
#endif /* LWIP_IPV4 && LWIP_IPV6 */

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING) != 0)
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
 80076ce:	230f      	movs	r3, #15
 80076d0:	18fb      	adds	r3, r7, r3
 80076d2:	2200      	movs	r2, #0
 80076d4:	701a      	strb	r2, [r3, #0]
 80076d6:	e046      	b.n	8007766 <dns_call_found+0xa6>
    if (dns_requests[i].found && (dns_requests[i].dns_table_idx == idx)) {
 80076d8:	250f      	movs	r5, #15
 80076da:	197b      	adds	r3, r7, r5
 80076dc:	781a      	ldrb	r2, [r3, #0]
 80076de:	4964      	ldr	r1, [pc, #400]	; (8007870 <dns_call_found+0x1b0>)
 80076e0:	0013      	movs	r3, r2
 80076e2:	005b      	lsls	r3, r3, #1
 80076e4:	189b      	adds	r3, r3, r2
 80076e6:	009b      	lsls	r3, r3, #2
 80076e8:	585b      	ldr	r3, [r3, r1]
 80076ea:	2b00      	cmp	r3, #0
 80076ec:	d035      	beq.n	800775a <dns_call_found+0x9a>
 80076ee:	197b      	adds	r3, r7, r5
 80076f0:	781a      	ldrb	r2, [r3, #0]
 80076f2:	495f      	ldr	r1, [pc, #380]	; (8007870 <dns_call_found+0x1b0>)
 80076f4:	0013      	movs	r3, r2
 80076f6:	005b      	lsls	r3, r3, #1
 80076f8:	189b      	adds	r3, r3, r2
 80076fa:	009b      	lsls	r3, r3, #2
 80076fc:	18cb      	adds	r3, r1, r3
 80076fe:	3308      	adds	r3, #8
 8007700:	781b      	ldrb	r3, [r3, #0]
 8007702:	1dfa      	adds	r2, r7, #7
 8007704:	7812      	ldrb	r2, [r2, #0]
 8007706:	429a      	cmp	r2, r3
 8007708:	d127      	bne.n	800775a <dns_call_found+0x9a>
      (*dns_requests[i].found)(dns_table[idx].name, addr, dns_requests[i].arg);
 800770a:	197b      	adds	r3, r7, r5
 800770c:	781a      	ldrb	r2, [r3, #0]
 800770e:	4958      	ldr	r1, [pc, #352]	; (8007870 <dns_call_found+0x1b0>)
 8007710:	0013      	movs	r3, r2
 8007712:	005b      	lsls	r3, r3, #1
 8007714:	189b      	adds	r3, r3, r2
 8007716:	009b      	lsls	r3, r3, #2
 8007718:	585c      	ldr	r4, [r3, r1]
 800771a:	1dfb      	adds	r3, r7, #7
 800771c:	781a      	ldrb	r2, [r3, #0]
 800771e:	0013      	movs	r3, r2
 8007720:	00db      	lsls	r3, r3, #3
 8007722:	189b      	adds	r3, r3, r2
 8007724:	011b      	lsls	r3, r3, #4
 8007726:	3310      	adds	r3, #16
 8007728:	001a      	movs	r2, r3
 800772a:	4b52      	ldr	r3, [pc, #328]	; (8007874 <dns_call_found+0x1b4>)
 800772c:	18d0      	adds	r0, r2, r3
 800772e:	197b      	adds	r3, r7, r5
 8007730:	781a      	ldrb	r2, [r3, #0]
 8007732:	494f      	ldr	r1, [pc, #316]	; (8007870 <dns_call_found+0x1b0>)
 8007734:	0013      	movs	r3, r2
 8007736:	005b      	lsls	r3, r3, #1
 8007738:	189b      	adds	r3, r3, r2
 800773a:	009b      	lsls	r3, r3, #2
 800773c:	18cb      	adds	r3, r1, r3
 800773e:	3304      	adds	r3, #4
 8007740:	681a      	ldr	r2, [r3, #0]
 8007742:	683b      	ldr	r3, [r7, #0]
 8007744:	0019      	movs	r1, r3
 8007746:	47a0      	blx	r4
      /* flush this entry */
      dns_requests[i].found = NULL;
 8007748:	197b      	adds	r3, r7, r5
 800774a:	781a      	ldrb	r2, [r3, #0]
 800774c:	4948      	ldr	r1, [pc, #288]	; (8007870 <dns_call_found+0x1b0>)
 800774e:	0013      	movs	r3, r2
 8007750:	005b      	lsls	r3, r3, #1
 8007752:	189b      	adds	r3, r3, r2
 8007754:	009b      	lsls	r3, r3, #2
 8007756:	2200      	movs	r2, #0
 8007758:	505a      	str	r2, [r3, r1]
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
 800775a:	210f      	movs	r1, #15
 800775c:	187b      	adds	r3, r7, r1
 800775e:	781a      	ldrb	r2, [r3, #0]
 8007760:	187b      	adds	r3, r7, r1
 8007762:	3201      	adds	r2, #1
 8007764:	701a      	strb	r2, [r3, #0]
 8007766:	220f      	movs	r2, #15
 8007768:	18bb      	adds	r3, r7, r2
 800776a:	781b      	ldrb	r3, [r3, #0]
 800776c:	2b02      	cmp	r3, #2
 800776e:	d9b3      	bls.n	80076d8 <dns_call_found+0x18>
  }
  dns_requests[idx].found = NULL;
#endif
#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) != 0)
  /* close the pcb used unless other request are using it */
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
 8007770:	18bb      	adds	r3, r7, r2
 8007772:	2200      	movs	r2, #0
 8007774:	701a      	strb	r2, [r3, #0]
 8007776:	e03b      	b.n	80077f0 <dns_call_found+0x130>
    if (i == idx) {
 8007778:	200f      	movs	r0, #15
 800777a:	183a      	adds	r2, r7, r0
 800777c:	1dfb      	adds	r3, r7, #7
 800777e:	7812      	ldrb	r2, [r2, #0]
 8007780:	781b      	ldrb	r3, [r3, #0]
 8007782:	429a      	cmp	r2, r3
 8007784:	d02d      	beq.n	80077e2 <dns_call_found+0x122>
      continue; /* only check other requests */
    }
    if (dns_table[i].state == DNS_STATE_ASKING) {
 8007786:	183b      	adds	r3, r7, r0
 8007788:	781a      	ldrb	r2, [r3, #0]
 800778a:	493a      	ldr	r1, [pc, #232]	; (8007874 <dns_call_found+0x1b4>)
 800778c:	0013      	movs	r3, r2
 800778e:	00db      	lsls	r3, r3, #3
 8007790:	189b      	adds	r3, r3, r2
 8007792:	011b      	lsls	r3, r3, #4
 8007794:	18cb      	adds	r3, r1, r3
 8007796:	330a      	adds	r3, #10
 8007798:	781b      	ldrb	r3, [r3, #0]
 800779a:	2b02      	cmp	r3, #2
 800779c:	d122      	bne.n	80077e4 <dns_call_found+0x124>
      if (dns_table[i].pcb_idx == dns_table[idx].pcb_idx) {
 800779e:	183b      	adds	r3, r7, r0
 80077a0:	781a      	ldrb	r2, [r3, #0]
 80077a2:	4934      	ldr	r1, [pc, #208]	; (8007874 <dns_call_found+0x1b4>)
 80077a4:	0013      	movs	r3, r2
 80077a6:	00db      	lsls	r3, r3, #3
 80077a8:	189b      	adds	r3, r3, r2
 80077aa:	011b      	lsls	r3, r3, #4
 80077ac:	18cb      	adds	r3, r1, r3
 80077ae:	330f      	adds	r3, #15
 80077b0:	7819      	ldrb	r1, [r3, #0]
 80077b2:	1dfb      	adds	r3, r7, #7
 80077b4:	781a      	ldrb	r2, [r3, #0]
 80077b6:	482f      	ldr	r0, [pc, #188]	; (8007874 <dns_call_found+0x1b4>)
 80077b8:	0013      	movs	r3, r2
 80077ba:	00db      	lsls	r3, r3, #3
 80077bc:	189b      	adds	r3, r3, r2
 80077be:	011b      	lsls	r3, r3, #4
 80077c0:	18c3      	adds	r3, r0, r3
 80077c2:	330f      	adds	r3, #15
 80077c4:	781b      	ldrb	r3, [r3, #0]
 80077c6:	4299      	cmp	r1, r3
 80077c8:	d10c      	bne.n	80077e4 <dns_call_found+0x124>
        /* another request is still using the same pcb */
        dns_table[idx].pcb_idx = DNS_MAX_SOURCE_PORTS;
 80077ca:	1dfb      	adds	r3, r7, #7
 80077cc:	781a      	ldrb	r2, [r3, #0]
 80077ce:	4929      	ldr	r1, [pc, #164]	; (8007874 <dns_call_found+0x1b4>)
 80077d0:	0013      	movs	r3, r2
 80077d2:	00db      	lsls	r3, r3, #3
 80077d4:	189b      	adds	r3, r3, r2
 80077d6:	011b      	lsls	r3, r3, #4
 80077d8:	18cb      	adds	r3, r1, r3
 80077da:	330f      	adds	r3, #15
 80077dc:	2203      	movs	r2, #3
 80077de:	701a      	strb	r2, [r3, #0]
        break;
 80077e0:	e00b      	b.n	80077fa <dns_call_found+0x13a>
      continue; /* only check other requests */
 80077e2:	46c0      	nop			; (mov r8, r8)
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
 80077e4:	210f      	movs	r1, #15
 80077e6:	187b      	adds	r3, r7, r1
 80077e8:	781a      	ldrb	r2, [r3, #0]
 80077ea:	187b      	adds	r3, r7, r1
 80077ec:	3201      	adds	r2, #1
 80077ee:	701a      	strb	r2, [r3, #0]
 80077f0:	230f      	movs	r3, #15
 80077f2:	18fb      	adds	r3, r7, r3
 80077f4:	781b      	ldrb	r3, [r3, #0]
 80077f6:	2b02      	cmp	r3, #2
 80077f8:	d9be      	bls.n	8007778 <dns_call_found+0xb8>
      }
    }
  }
  if (dns_table[idx].pcb_idx < DNS_MAX_SOURCE_PORTS) {
 80077fa:	1dfb      	adds	r3, r7, #7
 80077fc:	781a      	ldrb	r2, [r3, #0]
 80077fe:	491d      	ldr	r1, [pc, #116]	; (8007874 <dns_call_found+0x1b4>)
 8007800:	0013      	movs	r3, r2
 8007802:	00db      	lsls	r3, r3, #3
 8007804:	189b      	adds	r3, r3, r2
 8007806:	011b      	lsls	r3, r3, #4
 8007808:	18cb      	adds	r3, r1, r3
 800780a:	330f      	adds	r3, #15
 800780c:	781b      	ldrb	r3, [r3, #0]
 800780e:	2b02      	cmp	r3, #2
 8007810:	d82a      	bhi.n	8007868 <dns_call_found+0x1a8>
    /* if we come here, the pcb is not used any more and can be removed */
    udp_remove(dns_pcbs[dns_table[idx].pcb_idx]);
 8007812:	1dfb      	adds	r3, r7, #7
 8007814:	781a      	ldrb	r2, [r3, #0]
 8007816:	4917      	ldr	r1, [pc, #92]	; (8007874 <dns_call_found+0x1b4>)
 8007818:	0013      	movs	r3, r2
 800781a:	00db      	lsls	r3, r3, #3
 800781c:	189b      	adds	r3, r3, r2
 800781e:	011b      	lsls	r3, r3, #4
 8007820:	18cb      	adds	r3, r1, r3
 8007822:	330f      	adds	r3, #15
 8007824:	781b      	ldrb	r3, [r3, #0]
 8007826:	001a      	movs	r2, r3
 8007828:	4b13      	ldr	r3, [pc, #76]	; (8007878 <dns_call_found+0x1b8>)
 800782a:	0092      	lsls	r2, r2, #2
 800782c:	58d3      	ldr	r3, [r2, r3]
 800782e:	0018      	movs	r0, r3
 8007830:	f00b fb84 	bl	8012f3c <udp_remove>
    dns_pcbs[dns_table[idx].pcb_idx] = NULL;
 8007834:	1dfb      	adds	r3, r7, #7
 8007836:	781a      	ldrb	r2, [r3, #0]
 8007838:	490e      	ldr	r1, [pc, #56]	; (8007874 <dns_call_found+0x1b4>)
 800783a:	0013      	movs	r3, r2
 800783c:	00db      	lsls	r3, r3, #3
 800783e:	189b      	adds	r3, r3, r2
 8007840:	011b      	lsls	r3, r3, #4
 8007842:	18cb      	adds	r3, r1, r3
 8007844:	330f      	adds	r3, #15
 8007846:	781b      	ldrb	r3, [r3, #0]
 8007848:	001a      	movs	r2, r3
 800784a:	4b0b      	ldr	r3, [pc, #44]	; (8007878 <dns_call_found+0x1b8>)
 800784c:	0092      	lsls	r2, r2, #2
 800784e:	2100      	movs	r1, #0
 8007850:	50d1      	str	r1, [r2, r3]
    dns_table[idx].pcb_idx = DNS_MAX_SOURCE_PORTS;
 8007852:	1dfb      	adds	r3, r7, #7
 8007854:	781a      	ldrb	r2, [r3, #0]
 8007856:	4907      	ldr	r1, [pc, #28]	; (8007874 <dns_call_found+0x1b4>)
 8007858:	0013      	movs	r3, r2
 800785a:	00db      	lsls	r3, r3, #3
 800785c:	189b      	adds	r3, r3, r2
 800785e:	011b      	lsls	r3, r3, #4
 8007860:	18cb      	adds	r3, r1, r3
 8007862:	330f      	adds	r3, #15
 8007864:	2203      	movs	r2, #3
 8007866:	701a      	strb	r2, [r3, #0]
  }
#endif
}
 8007868:	46c0      	nop			; (mov r8, r8)
 800786a:	46bd      	mov	sp, r7
 800786c:	b004      	add	sp, #16
 800786e:	bdb0      	pop	{r4, r5, r7, pc}
 8007870:	2000173c 	.word	0x2000173c
 8007874:	2000158c 	.word	0x2000158c
 8007878:	2000157c 	.word	0x2000157c

0800787c <dns_create_txid>:

/* Create a query transmission ID that is unique for all outstanding queries */
static u16_t
dns_create_txid(void)
{
 800787c:	b580      	push	{r7, lr}
 800787e:	b082      	sub	sp, #8
 8007880:	af00      	add	r7, sp, #0
  u16_t txid;
  u8_t i;

again:
  txid = (u16_t)DNS_RAND_TXID();
 8007882:	f015 fabf 	bl	801ce04 <sys_rand>
 8007886:	0002      	movs	r2, r0
 8007888:	1d3b      	adds	r3, r7, #4
 800788a:	801a      	strh	r2, [r3, #0]

  /* check whether the ID is unique */
  for (i = 0; i < DNS_TABLE_SIZE; i++) {
 800788c:	1dfb      	adds	r3, r7, #7
 800788e:	2200      	movs	r2, #0
 8007890:	701a      	strb	r2, [r3, #0]
 8007892:	e01f      	b.n	80078d4 <dns_create_txid+0x58>
    if ((dns_table[i].state == DNS_STATE_ASKING) &&
 8007894:	1dfb      	adds	r3, r7, #7
 8007896:	781a      	ldrb	r2, [r3, #0]
 8007898:	4913      	ldr	r1, [pc, #76]	; (80078e8 <dns_create_txid+0x6c>)
 800789a:	0013      	movs	r3, r2
 800789c:	00db      	lsls	r3, r3, #3
 800789e:	189b      	adds	r3, r3, r2
 80078a0:	011b      	lsls	r3, r3, #4
 80078a2:	18cb      	adds	r3, r1, r3
 80078a4:	330a      	adds	r3, #10
 80078a6:	781b      	ldrb	r3, [r3, #0]
 80078a8:	2b02      	cmp	r3, #2
 80078aa:	d10e      	bne.n	80078ca <dns_create_txid+0x4e>
        (dns_table[i].txid == txid)) {
 80078ac:	1dfb      	adds	r3, r7, #7
 80078ae:	781a      	ldrb	r2, [r3, #0]
 80078b0:	490d      	ldr	r1, [pc, #52]	; (80078e8 <dns_create_txid+0x6c>)
 80078b2:	0013      	movs	r3, r2
 80078b4:	00db      	lsls	r3, r3, #3
 80078b6:	189b      	adds	r3, r3, r2
 80078b8:	011b      	lsls	r3, r3, #4
 80078ba:	18cb      	adds	r3, r1, r3
 80078bc:	3308      	adds	r3, #8
 80078be:	881b      	ldrh	r3, [r3, #0]
    if ((dns_table[i].state == DNS_STATE_ASKING) &&
 80078c0:	1d3a      	adds	r2, r7, #4
 80078c2:	8812      	ldrh	r2, [r2, #0]
 80078c4:	429a      	cmp	r2, r3
 80078c6:	d100      	bne.n	80078ca <dns_create_txid+0x4e>
      /* ID already used by another pending query */
      goto again;
 80078c8:	e7db      	b.n	8007882 <dns_create_txid+0x6>
  for (i = 0; i < DNS_TABLE_SIZE; i++) {
 80078ca:	1dfb      	adds	r3, r7, #7
 80078cc:	781a      	ldrb	r2, [r3, #0]
 80078ce:	1dfb      	adds	r3, r7, #7
 80078d0:	3201      	adds	r2, #1
 80078d2:	701a      	strb	r2, [r3, #0]
 80078d4:	1dfb      	adds	r3, r7, #7
 80078d6:	781b      	ldrb	r3, [r3, #0]
 80078d8:	2b02      	cmp	r3, #2
 80078da:	d9db      	bls.n	8007894 <dns_create_txid+0x18>
    }
  }

  return txid;
 80078dc:	1d3b      	adds	r3, r7, #4
 80078de:	881b      	ldrh	r3, [r3, #0]
}
 80078e0:	0018      	movs	r0, r3
 80078e2:	46bd      	mov	sp, r7
 80078e4:	b002      	add	sp, #8
 80078e6:	bd80      	pop	{r7, pc}
 80078e8:	2000158c 	.word	0x2000158c

080078ec <dns_backupserver_available>:
/**
 * Check whether there are other backup DNS servers available to try
 */
static u8_t
dns_backupserver_available(struct dns_table_entry *pentry)
{
 80078ec:	b580      	push	{r7, lr}
 80078ee:	b084      	sub	sp, #16
 80078f0:	af00      	add	r7, sp, #0
 80078f2:	6078      	str	r0, [r7, #4]
  u8_t ret = 0;
 80078f4:	210f      	movs	r1, #15
 80078f6:	187b      	adds	r3, r7, r1
 80078f8:	2200      	movs	r2, #0
 80078fa:	701a      	strb	r2, [r3, #0]

  if (pentry) {
 80078fc:	687b      	ldr	r3, [r7, #4]
 80078fe:	2b00      	cmp	r3, #0
 8007900:	d00e      	beq.n	8007920 <dns_backupserver_available+0x34>
    if ((pentry->server_idx + 1 < DNS_MAX_SERVERS) && !ip_addr_isany_val(dns_servers[pentry->server_idx + 1])) {
 8007902:	687b      	ldr	r3, [r7, #4]
 8007904:	7adb      	ldrb	r3, [r3, #11]
 8007906:	2b00      	cmp	r3, #0
 8007908:	d10a      	bne.n	8007920 <dns_backupserver_available+0x34>
 800790a:	687b      	ldr	r3, [r7, #4]
 800790c:	7adb      	ldrb	r3, [r3, #11]
 800790e:	1c5a      	adds	r2, r3, #1
 8007910:	4b07      	ldr	r3, [pc, #28]	; (8007930 <dns_backupserver_available+0x44>)
 8007912:	0092      	lsls	r2, r2, #2
 8007914:	58d3      	ldr	r3, [r2, r3]
 8007916:	2b00      	cmp	r3, #0
 8007918:	d002      	beq.n	8007920 <dns_backupserver_available+0x34>
      ret = 1;
 800791a:	187b      	adds	r3, r7, r1
 800791c:	2201      	movs	r2, #1
 800791e:	701a      	strb	r2, [r3, #0]
    }
  }

  return ret;
 8007920:	230f      	movs	r3, #15
 8007922:	18fb      	adds	r3, r7, r3
 8007924:	781b      	ldrb	r3, [r3, #0]
}
 8007926:	0018      	movs	r0, r3
 8007928:	46bd      	mov	sp, r7
 800792a:	b004      	add	sp, #16
 800792c:	bd80      	pop	{r7, pc}
 800792e:	46c0      	nop			; (mov r8, r8)
 8007930:	20001760 	.word	0x20001760

08007934 <dns_check_entry>:
 *
 * @param i index of the dns_table entry to check
 */
static void
dns_check_entry(u8_t i)
{
 8007934:	b590      	push	{r4, r7, lr}
 8007936:	b085      	sub	sp, #20
 8007938:	af00      	add	r7, sp, #0
 800793a:	0002      	movs	r2, r0
 800793c:	1dfb      	adds	r3, r7, #7
 800793e:	701a      	strb	r2, [r3, #0]
  err_t err;
  struct dns_table_entry *entry = &dns_table[i];
 8007940:	1dfb      	adds	r3, r7, #7
 8007942:	781a      	ldrb	r2, [r3, #0]
 8007944:	0013      	movs	r3, r2
 8007946:	00db      	lsls	r3, r3, #3
 8007948:	189b      	adds	r3, r3, r2
 800794a:	011b      	lsls	r3, r3, #4
 800794c:	4a4b      	ldr	r2, [pc, #300]	; (8007a7c <dns_check_entry+0x148>)
 800794e:	189b      	adds	r3, r3, r2
 8007950:	60fb      	str	r3, [r7, #12]

  LWIP_ASSERT("array index out of bounds", i < DNS_TABLE_SIZE);
 8007952:	1dfb      	adds	r3, r7, #7
 8007954:	781b      	ldrb	r3, [r3, #0]
 8007956:	2b02      	cmp	r3, #2
 8007958:	d905      	bls.n	8007966 <dns_check_entry+0x32>
 800795a:	4b49      	ldr	r3, [pc, #292]	; (8007a80 <dns_check_entry+0x14c>)
 800795c:	4a49      	ldr	r2, [pc, #292]	; (8007a84 <dns_check_entry+0x150>)
 800795e:	494a      	ldr	r1, [pc, #296]	; (8007a88 <dns_check_entry+0x154>)
 8007960:	484a      	ldr	r0, [pc, #296]	; (8007a8c <dns_check_entry+0x158>)
 8007962:	f7fb f931 	bl	8002bc8 <app_debug_rtt_raw>

  switch (entry->state) {
 8007966:	68fb      	ldr	r3, [r7, #12]
 8007968:	7a9b      	ldrb	r3, [r3, #10]
 800796a:	2b03      	cmp	r3, #3
 800796c:	d065      	beq.n	8007a3a <dns_check_entry+0x106>
 800796e:	dd00      	ble.n	8007972 <dns_check_entry+0x3e>
 8007970:	e074      	b.n	8007a5c <dns_check_entry+0x128>
 8007972:	2b02      	cmp	r3, #2
 8007974:	d022      	beq.n	80079bc <dns_check_entry+0x88>
 8007976:	dd00      	ble.n	800797a <dns_check_entry+0x46>
 8007978:	e070      	b.n	8007a5c <dns_check_entry+0x128>
 800797a:	2b00      	cmp	r3, #0
 800797c:	d100      	bne.n	8007980 <dns_check_entry+0x4c>
 800797e:	e074      	b.n	8007a6a <dns_check_entry+0x136>
 8007980:	2b01      	cmp	r3, #1
 8007982:	d16b      	bne.n	8007a5c <dns_check_entry+0x128>
    case DNS_STATE_NEW:
      /* initialize new entry */
      entry->txid = dns_create_txid();
 8007984:	f7ff ff7a 	bl	800787c <dns_create_txid>
 8007988:	0003      	movs	r3, r0
 800798a:	001a      	movs	r2, r3
 800798c:	68fb      	ldr	r3, [r7, #12]
 800798e:	811a      	strh	r2, [r3, #8]
      entry->state = DNS_STATE_ASKING;
 8007990:	68fb      	ldr	r3, [r7, #12]
 8007992:	2202      	movs	r2, #2
 8007994:	729a      	strb	r2, [r3, #10]
      entry->server_idx = 0;
 8007996:	68fb      	ldr	r3, [r7, #12]
 8007998:	2200      	movs	r2, #0
 800799a:	72da      	strb	r2, [r3, #11]
      entry->tmr = 1;
 800799c:	68fb      	ldr	r3, [r7, #12]
 800799e:	2201      	movs	r2, #1
 80079a0:	731a      	strb	r2, [r3, #12]
      entry->retries = 0;
 80079a2:	68fb      	ldr	r3, [r7, #12]
 80079a4:	2200      	movs	r2, #0
 80079a6:	735a      	strb	r2, [r3, #13]

      /* send DNS packet for this entry */
      err = dns_send(i);
 80079a8:	230b      	movs	r3, #11
 80079aa:	18fc      	adds	r4, r7, r3
 80079ac:	1dfb      	adds	r3, r7, #7
 80079ae:	781b      	ldrb	r3, [r3, #0]
 80079b0:	0018      	movs	r0, r3
 80079b2:	f7ff fcbb 	bl	800732c <dns_send>
 80079b6:	0003      	movs	r3, r0
 80079b8:	7023      	strb	r3, [r4, #0]
      if (err != ERR_OK) {
        LWIP_DEBUGF(DNS_DEBUG | LWIP_DBG_LEVEL_WARNING,
                    ("dns_send returned error: %s\n", lwip_strerr(err)));
      }
      break;
 80079ba:	e05b      	b.n	8007a74 <dns_check_entry+0x140>
    case DNS_STATE_ASKING:
      if (--entry->tmr == 0) {
 80079bc:	68fb      	ldr	r3, [r7, #12]
 80079be:	7b1b      	ldrb	r3, [r3, #12]
 80079c0:	3b01      	subs	r3, #1
 80079c2:	b2da      	uxtb	r2, r3
 80079c4:	68fb      	ldr	r3, [r7, #12]
 80079c6:	731a      	strb	r2, [r3, #12]
 80079c8:	68fb      	ldr	r3, [r7, #12]
 80079ca:	7b1b      	ldrb	r3, [r3, #12]
 80079cc:	2b00      	cmp	r3, #0
 80079ce:	d14e      	bne.n	8007a6e <dns_check_entry+0x13a>
        if (++entry->retries == DNS_MAX_RETRIES) {
 80079d0:	68fb      	ldr	r3, [r7, #12]
 80079d2:	7b5b      	ldrb	r3, [r3, #13]
 80079d4:	3301      	adds	r3, #1
 80079d6:	b2da      	uxtb	r2, r3
 80079d8:	68fb      	ldr	r3, [r7, #12]
 80079da:	735a      	strb	r2, [r3, #13]
 80079dc:	68fb      	ldr	r3, [r7, #12]
 80079de:	7b5b      	ldrb	r3, [r3, #13]
 80079e0:	2b04      	cmp	r3, #4
 80079e2:	d11c      	bne.n	8007a1e <dns_check_entry+0xea>
          if (dns_backupserver_available(entry)
 80079e4:	68fb      	ldr	r3, [r7, #12]
 80079e6:	0018      	movs	r0, r3
 80079e8:	f7ff ff80 	bl	80078ec <dns_backupserver_available>
 80079ec:	1e03      	subs	r3, r0, #0
 80079ee:	d00c      	beq.n	8007a0a <dns_check_entry+0xd6>
#if LWIP_DNS_SUPPORT_MDNS_QUERIES
              && !entry->is_mdns
#endif /* LWIP_DNS_SUPPORT_MDNS_QUERIES */
             ) {
            /* change of server */
            entry->server_idx++;
 80079f0:	68fb      	ldr	r3, [r7, #12]
 80079f2:	7adb      	ldrb	r3, [r3, #11]
 80079f4:	3301      	adds	r3, #1
 80079f6:	b2da      	uxtb	r2, r3
 80079f8:	68fb      	ldr	r3, [r7, #12]
 80079fa:	72da      	strb	r2, [r3, #11]
            entry->tmr = 1;
 80079fc:	68fb      	ldr	r3, [r7, #12]
 80079fe:	2201      	movs	r2, #1
 8007a00:	731a      	strb	r2, [r3, #12]
            entry->retries = 0;
 8007a02:	68fb      	ldr	r3, [r7, #12]
 8007a04:	2200      	movs	r2, #0
 8007a06:	735a      	strb	r2, [r3, #13]
 8007a08:	e00d      	b.n	8007a26 <dns_check_entry+0xf2>
          } else {
            LWIP_DEBUGF(DNS_DEBUG, ("dns_check_entry: \"%s\": timeout\n", entry->name));
            /* call specified callback function if provided */
            dns_call_found(i, NULL);
 8007a0a:	1dfb      	adds	r3, r7, #7
 8007a0c:	781b      	ldrb	r3, [r3, #0]
 8007a0e:	2100      	movs	r1, #0
 8007a10:	0018      	movs	r0, r3
 8007a12:	f7ff fe55 	bl	80076c0 <dns_call_found>
            /* flush this entry */
            entry->state = DNS_STATE_UNUSED;
 8007a16:	68fb      	ldr	r3, [r7, #12]
 8007a18:	2200      	movs	r2, #0
 8007a1a:	729a      	strb	r2, [r3, #10]
            break;
 8007a1c:	e02a      	b.n	8007a74 <dns_check_entry+0x140>
          }
        } else {
          /* wait longer for the next retry */
          entry->tmr = entry->retries;
 8007a1e:	68fb      	ldr	r3, [r7, #12]
 8007a20:	7b5a      	ldrb	r2, [r3, #13]
 8007a22:	68fb      	ldr	r3, [r7, #12]
 8007a24:	731a      	strb	r2, [r3, #12]
        }

        /* send DNS packet for this entry */
        err = dns_send(i);
 8007a26:	230b      	movs	r3, #11
 8007a28:	18fc      	adds	r4, r7, r3
 8007a2a:	1dfb      	adds	r3, r7, #7
 8007a2c:	781b      	ldrb	r3, [r3, #0]
 8007a2e:	0018      	movs	r0, r3
 8007a30:	f7ff fc7c 	bl	800732c <dns_send>
 8007a34:	0003      	movs	r3, r0
 8007a36:	7023      	strb	r3, [r4, #0]
        if (err != ERR_OK) {
          LWIP_DEBUGF(DNS_DEBUG | LWIP_DBG_LEVEL_WARNING,
                      ("dns_send returned error: %s\n", lwip_strerr(err)));
        }
      }
      break;
 8007a38:	e019      	b.n	8007a6e <dns_check_entry+0x13a>
    case DNS_STATE_DONE:
      /* if the time to live is nul */
      if ((entry->ttl == 0) || (--entry->ttl == 0)) {
 8007a3a:	68fb      	ldr	r3, [r7, #12]
 8007a3c:	681b      	ldr	r3, [r3, #0]
 8007a3e:	2b00      	cmp	r3, #0
 8007a40:	d008      	beq.n	8007a54 <dns_check_entry+0x120>
 8007a42:	68fb      	ldr	r3, [r7, #12]
 8007a44:	681b      	ldr	r3, [r3, #0]
 8007a46:	1e5a      	subs	r2, r3, #1
 8007a48:	68fb      	ldr	r3, [r7, #12]
 8007a4a:	601a      	str	r2, [r3, #0]
 8007a4c:	68fb      	ldr	r3, [r7, #12]
 8007a4e:	681b      	ldr	r3, [r3, #0]
 8007a50:	2b00      	cmp	r3, #0
 8007a52:	d10e      	bne.n	8007a72 <dns_check_entry+0x13e>
        LWIP_DEBUGF(DNS_DEBUG, ("dns_check_entry: \"%s\": flush\n", entry->name));
        /* flush this entry, there cannot be any related pending entries in this state */
        entry->state = DNS_STATE_UNUSED;
 8007a54:	68fb      	ldr	r3, [r7, #12]
 8007a56:	2200      	movs	r2, #0
 8007a58:	729a      	strb	r2, [r3, #10]
      }
      break;
 8007a5a:	e00a      	b.n	8007a72 <dns_check_entry+0x13e>
    case DNS_STATE_UNUSED:
      /* nothing to do */
      break;
    default:
      LWIP_ASSERT("unknown dns_table entry state:", 0);
 8007a5c:	4b08      	ldr	r3, [pc, #32]	; (8007a80 <dns_check_entry+0x14c>)
 8007a5e:	4a0c      	ldr	r2, [pc, #48]	; (8007a90 <dns_check_entry+0x15c>)
 8007a60:	490c      	ldr	r1, [pc, #48]	; (8007a94 <dns_check_entry+0x160>)
 8007a62:	480a      	ldr	r0, [pc, #40]	; (8007a8c <dns_check_entry+0x158>)
 8007a64:	f7fb f8b0 	bl	8002bc8 <app_debug_rtt_raw>
      break;
 8007a68:	e004      	b.n	8007a74 <dns_check_entry+0x140>
      break;
 8007a6a:	46c0      	nop			; (mov r8, r8)
 8007a6c:	e002      	b.n	8007a74 <dns_check_entry+0x140>
      break;
 8007a6e:	46c0      	nop			; (mov r8, r8)
 8007a70:	e000      	b.n	8007a74 <dns_check_entry+0x140>
      break;
 8007a72:	46c0      	nop			; (mov r8, r8)
  }
}
 8007a74:	46c0      	nop			; (mov r8, r8)
 8007a76:	46bd      	mov	sp, r7
 8007a78:	b005      	add	sp, #20
 8007a7a:	bd90      	pop	{r4, r7, pc}
 8007a7c:	2000158c 	.word	0x2000158c
 8007a80:	0801f1fc 	.word	0x0801f1fc
 8007a84:	0000041c 	.word	0x0000041c
 8007a88:	0801f268 	.word	0x0801f268
 8007a8c:	0801f23c 	.word	0x0801f23c
 8007a90:	0000045b 	.word	0x0000045b
 8007a94:	0801f284 	.word	0x0801f284

08007a98 <dns_correct_response>:
/**
 * Save TTL and call dns_call_found for correct response.
 */
static void
dns_correct_response(u8_t idx, u32_t ttl)
{
 8007a98:	b580      	push	{r7, lr}
 8007a9a:	b084      	sub	sp, #16
 8007a9c:	af00      	add	r7, sp, #0
 8007a9e:	0002      	movs	r2, r0
 8007aa0:	6039      	str	r1, [r7, #0]
 8007aa2:	1dfb      	adds	r3, r7, #7
 8007aa4:	701a      	strb	r2, [r3, #0]
  struct dns_table_entry *entry = &dns_table[idx];
 8007aa6:	1dfb      	adds	r3, r7, #7
 8007aa8:	781a      	ldrb	r2, [r3, #0]
 8007aaa:	0013      	movs	r3, r2
 8007aac:	00db      	lsls	r3, r3, #3
 8007aae:	189b      	adds	r3, r3, r2
 8007ab0:	011b      	lsls	r3, r3, #4
 8007ab2:	4a14      	ldr	r2, [pc, #80]	; (8007b04 <dns_correct_response+0x6c>)
 8007ab4:	189b      	adds	r3, r3, r2
 8007ab6:	60fb      	str	r3, [r7, #12]

  entry->state = DNS_STATE_DONE;
 8007ab8:	68fb      	ldr	r3, [r7, #12]
 8007aba:	2203      	movs	r2, #3
 8007abc:	729a      	strb	r2, [r3, #10]
  LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response = ", entry->name));
  ip_addr_debug_print_val(DNS_DEBUG, entry->ipaddr);
  LWIP_DEBUGF(DNS_DEBUG, ("\n"));

  /* read the answer resource record's TTL, and maximize it if needed */
  entry->ttl = ttl;
 8007abe:	68fb      	ldr	r3, [r7, #12]
 8007ac0:	683a      	ldr	r2, [r7, #0]
 8007ac2:	601a      	str	r2, [r3, #0]
  if (entry->ttl > DNS_MAX_TTL) {
 8007ac4:	68fb      	ldr	r3, [r7, #12]
 8007ac6:	681b      	ldr	r3, [r3, #0]
 8007ac8:	4a0f      	ldr	r2, [pc, #60]	; (8007b08 <dns_correct_response+0x70>)
 8007aca:	4293      	cmp	r3, r2
 8007acc:	d902      	bls.n	8007ad4 <dns_correct_response+0x3c>
    entry->ttl = DNS_MAX_TTL;
 8007ace:	68fb      	ldr	r3, [r7, #12]
 8007ad0:	4a0d      	ldr	r2, [pc, #52]	; (8007b08 <dns_correct_response+0x70>)
 8007ad2:	601a      	str	r2, [r3, #0]
  }
  dns_call_found(idx, &entry->ipaddr);
 8007ad4:	68fb      	ldr	r3, [r7, #12]
 8007ad6:	1d1a      	adds	r2, r3, #4
 8007ad8:	1dfb      	adds	r3, r7, #7
 8007ada:	781b      	ldrb	r3, [r3, #0]
 8007adc:	0011      	movs	r1, r2
 8007ade:	0018      	movs	r0, r3
 8007ae0:	f7ff fdee 	bl	80076c0 <dns_call_found>

  if (entry->ttl == 0) {
 8007ae4:	68fb      	ldr	r3, [r7, #12]
 8007ae6:	681b      	ldr	r3, [r3, #0]
 8007ae8:	2b00      	cmp	r3, #0
 8007aea:	d106      	bne.n	8007afa <dns_correct_response+0x62>
    /* RFC 883, page 29: "Zero values are
       interpreted to mean that the RR can only be used for the
       transaction in progress, and should not be cached."
       -> flush this entry now */
    /* entry reused during callback? */
    if (entry->state == DNS_STATE_DONE) {
 8007aec:	68fb      	ldr	r3, [r7, #12]
 8007aee:	7a9b      	ldrb	r3, [r3, #10]
 8007af0:	2b03      	cmp	r3, #3
 8007af2:	d102      	bne.n	8007afa <dns_correct_response+0x62>
      entry->state = DNS_STATE_UNUSED;
 8007af4:	68fb      	ldr	r3, [r7, #12]
 8007af6:	2200      	movs	r2, #0
 8007af8:	729a      	strb	r2, [r3, #10]
    }
  }
}
 8007afa:	46c0      	nop			; (mov r8, r8)
 8007afc:	46bd      	mov	sp, r7
 8007afe:	b004      	add	sp, #16
 8007b00:	bd80      	pop	{r7, pc}
 8007b02:	46c0      	nop			; (mov r8, r8)
 8007b04:	2000158c 	.word	0x2000158c
 8007b08:	00093a80 	.word	0x00093a80

08007b0c <dns_recv>:
/**
 * Receive input function for DNS response packets arriving for the dns UDP pcb.
 */
static void
dns_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr, u16_t port)
{
 8007b0c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007b0e:	b091      	sub	sp, #68	; 0x44
 8007b10:	af00      	add	r7, sp, #0
 8007b12:	60f8      	str	r0, [r7, #12]
 8007b14:	60b9      	str	r1, [r7, #8]
 8007b16:	607a      	str	r2, [r7, #4]
 8007b18:	603b      	str	r3, [r7, #0]
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(port);

  /* is the dns message big enough ? */
  if (p->tot_len < (SIZEOF_DNS_HDR + SIZEOF_DNS_QUERY)) {
 8007b1a:	687b      	ldr	r3, [r7, #4]
 8007b1c:	891b      	ldrh	r3, [r3, #8]
 8007b1e:	2b0f      	cmp	r3, #15
 8007b20:	d800      	bhi.n	8007b24 <dns_recv+0x18>
 8007b22:	e162      	b.n	8007dea <dns_recv+0x2de>
    /* free pbuf and return */
    goto ignore_packet;
  }

  /* copy dns payload inside static buffer for processing */
  if (pbuf_copy_partial(p, &hdr, SIZEOF_DNS_HDR, 0) == SIZEOF_DNS_HDR) {
 8007b24:	2424      	movs	r4, #36	; 0x24
 8007b26:	1939      	adds	r1, r7, r4
 8007b28:	6878      	ldr	r0, [r7, #4]
 8007b2a:	2300      	movs	r3, #0
 8007b2c:	220c      	movs	r2, #12
 8007b2e:	f002 fc8f 	bl	800a450 <pbuf_copy_partial>
 8007b32:	0003      	movs	r3, r0
 8007b34:	2b0c      	cmp	r3, #12
 8007b36:	d000      	beq.n	8007b3a <dns_recv+0x2e>
 8007b38:	e159      	b.n	8007dee <dns_recv+0x2e2>
    /* Match the ID in the DNS header with the name table. */
    txid = lwip_htons(hdr.id);
 8007b3a:	193b      	adds	r3, r7, r4
 8007b3c:	881b      	ldrh	r3, [r3, #0]
 8007b3e:	2238      	movs	r2, #56	; 0x38
 8007b40:	18bc      	adds	r4, r7, r2
 8007b42:	0018      	movs	r0, r3
 8007b44:	f7ff f9d6 	bl	8006ef4 <lwip_htons>
 8007b48:	0003      	movs	r3, r0
 8007b4a:	8023      	strh	r3, [r4, #0]
    for (i = 0; i < DNS_TABLE_SIZE; i++) {
 8007b4c:	233b      	movs	r3, #59	; 0x3b
 8007b4e:	18fb      	adds	r3, r7, r3
 8007b50:	2200      	movs	r2, #0
 8007b52:	701a      	strb	r2, [r3, #0]
 8007b54:	e142      	b.n	8007ddc <dns_recv+0x2d0>
      struct dns_table_entry *entry = &dns_table[i];
 8007b56:	233b      	movs	r3, #59	; 0x3b
 8007b58:	18fb      	adds	r3, r7, r3
 8007b5a:	781a      	ldrb	r2, [r3, #0]
 8007b5c:	0013      	movs	r3, r2
 8007b5e:	00db      	lsls	r3, r3, #3
 8007b60:	189b      	adds	r3, r3, r2
 8007b62:	011b      	lsls	r3, r3, #4
 8007b64:	4ab2      	ldr	r2, [pc, #712]	; (8007e30 <dns_recv+0x324>)
 8007b66:	189b      	adds	r3, r3, r2
 8007b68:	637b      	str	r3, [r7, #52]	; 0x34
      if ((entry->state == DNS_STATE_ASKING) &&
 8007b6a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007b6c:	7a9b      	ldrb	r3, [r3, #10]
 8007b6e:	2b02      	cmp	r3, #2
 8007b70:	d000      	beq.n	8007b74 <dns_recv+0x68>
 8007b72:	e12d      	b.n	8007dd0 <dns_recv+0x2c4>
          (entry->txid == txid)) {
 8007b74:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007b76:	891b      	ldrh	r3, [r3, #8]
      if ((entry->state == DNS_STATE_ASKING) &&
 8007b78:	2238      	movs	r2, #56	; 0x38
 8007b7a:	18ba      	adds	r2, r7, r2
 8007b7c:	8812      	ldrh	r2, [r2, #0]
 8007b7e:	429a      	cmp	r2, r3
 8007b80:	d000      	beq.n	8007b84 <dns_recv+0x78>
 8007b82:	e125      	b.n	8007dd0 <dns_recv+0x2c4>

        /* We only care about the question(s) and the answers. The authrr
           and the extrarr are simply discarded. */
        nquestions = lwip_htons(hdr.numquestions);
 8007b84:	2624      	movs	r6, #36	; 0x24
 8007b86:	19bb      	adds	r3, r7, r6
 8007b88:	889b      	ldrh	r3, [r3, #4]
 8007b8a:	2532      	movs	r5, #50	; 0x32
 8007b8c:	197c      	adds	r4, r7, r5
 8007b8e:	0018      	movs	r0, r3
 8007b90:	f7ff f9b0 	bl	8006ef4 <lwip_htons>
 8007b94:	0003      	movs	r3, r0
 8007b96:	8023      	strh	r3, [r4, #0]
        nanswers   = lwip_htons(hdr.numanswers);
 8007b98:	19bb      	adds	r3, r7, r6
 8007b9a:	88db      	ldrh	r3, [r3, #6]
 8007b9c:	223e      	movs	r2, #62	; 0x3e
 8007b9e:	18bc      	adds	r4, r7, r2
 8007ba0:	0018      	movs	r0, r3
 8007ba2:	f7ff f9a7 	bl	8006ef4 <lwip_htons>
 8007ba6:	0003      	movs	r3, r0
 8007ba8:	8023      	strh	r3, [r4, #0]

        /* Check for correct response. */
        if ((hdr.flags1 & DNS_FLAG1_RESPONSE) == 0) {
 8007baa:	19bb      	adds	r3, r7, r6
 8007bac:	789b      	ldrb	r3, [r3, #2]
 8007bae:	b25b      	sxtb	r3, r3
 8007bb0:	2b00      	cmp	r3, #0
 8007bb2:	db00      	blt.n	8007bb6 <dns_recv+0xaa>
 8007bb4:	e11d      	b.n	8007df2 <dns_recv+0x2e6>
          LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": not a response\n", entry->name));
          goto ignore_packet; /* ignore this packet */
        }
        if (nquestions != 1) {
 8007bb6:	197b      	adds	r3, r7, r5
 8007bb8:	881b      	ldrh	r3, [r3, #0]
 8007bba:	2b01      	cmp	r3, #1
 8007bbc:	d000      	beq.n	8007bc0 <dns_recv+0xb4>
 8007bbe:	e11a      	b.n	8007df6 <dns_recv+0x2ea>
        if (!entry->is_mdns)
#endif /* LWIP_DNS_SUPPORT_MDNS_QUERIES */
        {
          /* Check whether response comes from the same network address to which the
             question was sent. (RFC 5452) */
          if (!ip_addr_cmp(addr, &dns_servers[entry->server_idx])) {
 8007bc0:	683b      	ldr	r3, [r7, #0]
 8007bc2:	681a      	ldr	r2, [r3, #0]
 8007bc4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007bc6:	7adb      	ldrb	r3, [r3, #11]
 8007bc8:	0019      	movs	r1, r3
 8007bca:	4b9a      	ldr	r3, [pc, #616]	; (8007e34 <dns_recv+0x328>)
 8007bcc:	0089      	lsls	r1, r1, #2
 8007bce:	58cb      	ldr	r3, [r1, r3]
 8007bd0:	429a      	cmp	r2, r3
 8007bd2:	d000      	beq.n	8007bd6 <dns_recv+0xca>
 8007bd4:	e111      	b.n	8007dfa <dns_recv+0x2ee>
          }
        }

        /* Check if the name in the "question" part match with the name in the entry and
           skip it if equal. */
        res_idx = dns_compare_name(entry->name, p, SIZEOF_DNS_HDR);
 8007bd6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007bd8:	3310      	adds	r3, #16
 8007bda:	253c      	movs	r5, #60	; 0x3c
 8007bdc:	197c      	adds	r4, r7, r5
 8007bde:	6879      	ldr	r1, [r7, #4]
 8007be0:	220c      	movs	r2, #12
 8007be2:	0018      	movs	r0, r3
 8007be4:	f7ff fa92 	bl	800710c <dns_compare_name>
 8007be8:	0003      	movs	r3, r0
 8007bea:	8023      	strh	r3, [r4, #0]
        if (res_idx == 0xFFFF) {
 8007bec:	002c      	movs	r4, r5
 8007bee:	193b      	adds	r3, r7, r4
 8007bf0:	881b      	ldrh	r3, [r3, #0]
 8007bf2:	4a91      	ldr	r2, [pc, #580]	; (8007e38 <dns_recv+0x32c>)
 8007bf4:	4293      	cmp	r3, r2
 8007bf6:	d100      	bne.n	8007bfa <dns_recv+0xee>
 8007bf8:	e101      	b.n	8007dfe <dns_recv+0x2f2>
          LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response not match to query\n", entry->name));
          goto ignore_packet; /* ignore this packet */
        }

        /* check if "question" part matches the request */
        if (pbuf_copy_partial(p, &qry, SIZEOF_DNS_QUERY, res_idx) != SIZEOF_DNS_QUERY) {
 8007bfa:	193b      	adds	r3, r7, r4
 8007bfc:	881b      	ldrh	r3, [r3, #0]
 8007bfe:	2514      	movs	r5, #20
 8007c00:	1979      	adds	r1, r7, r5
 8007c02:	6878      	ldr	r0, [r7, #4]
 8007c04:	2204      	movs	r2, #4
 8007c06:	f002 fc23 	bl	800a450 <pbuf_copy_partial>
 8007c0a:	0003      	movs	r3, r0
 8007c0c:	2b04      	cmp	r3, #4
 8007c0e:	d000      	beq.n	8007c12 <dns_recv+0x106>
 8007c10:	e0f7      	b.n	8007e02 <dns_recv+0x2f6>
          goto ignore_packet; /* ignore this packet */
        }
        if ((qry.cls != PP_HTONS(DNS_RRCLASS_IN)) ||
 8007c12:	197b      	adds	r3, r7, r5
 8007c14:	885a      	ldrh	r2, [r3, #2]
 8007c16:	2380      	movs	r3, #128	; 0x80
 8007c18:	005b      	lsls	r3, r3, #1
 8007c1a:	429a      	cmp	r2, r3
 8007c1c:	d000      	beq.n	8007c20 <dns_recv+0x114>
 8007c1e:	e0f2      	b.n	8007e06 <dns_recv+0x2fa>
            (LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype) && (qry.type != PP_HTONS(DNS_RRTYPE_AAAA))) ||
            (!LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype) && (qry.type != PP_HTONS(DNS_RRTYPE_A)))) {
 8007c20:	197b      	adds	r3, r7, r5
 8007c22:	881a      	ldrh	r2, [r3, #0]
            (LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype) && (qry.type != PP_HTONS(DNS_RRTYPE_AAAA))) ||
 8007c24:	2380      	movs	r3, #128	; 0x80
 8007c26:	005b      	lsls	r3, r3, #1
 8007c28:	429a      	cmp	r2, r3
 8007c2a:	d000      	beq.n	8007c2e <dns_recv+0x122>
 8007c2c:	e0eb      	b.n	8007e06 <dns_recv+0x2fa>
          LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response not match to query\n", entry->name));
          goto ignore_packet; /* ignore this packet */
        }
        /* skip the rest of the "question" part */
        if (res_idx + SIZEOF_DNS_QUERY > 0xFFFF) {
 8007c2e:	193b      	adds	r3, r7, r4
 8007c30:	881b      	ldrh	r3, [r3, #0]
 8007c32:	4a82      	ldr	r2, [pc, #520]	; (8007e3c <dns_recv+0x330>)
 8007c34:	4293      	cmp	r3, r2
 8007c36:	d900      	bls.n	8007c3a <dns_recv+0x12e>
 8007c38:	e0e7      	b.n	8007e0a <dns_recv+0x2fe>
          goto ignore_packet;
        }
        res_idx = (u16_t)(res_idx + SIZEOF_DNS_QUERY);
 8007c3a:	193b      	adds	r3, r7, r4
 8007c3c:	193a      	adds	r2, r7, r4
 8007c3e:	8812      	ldrh	r2, [r2, #0]
 8007c40:	3204      	adds	r2, #4
 8007c42:	801a      	strh	r2, [r3, #0]

        /* Check for error. If so, call callback to inform. */
        if (hdr.flags2 & DNS_FLAG2_ERR_MASK) {
 8007c44:	19bb      	adds	r3, r7, r6
 8007c46:	78db      	ldrb	r3, [r3, #3]
 8007c48:	001a      	movs	r2, r3
 8007c4a:	230f      	movs	r3, #15
 8007c4c:	4013      	ands	r3, r2
 8007c4e:	d100      	bne.n	8007c52 <dns_recv+0x146>
 8007c50:	e09a      	b.n	8007d88 <dns_recv+0x27c>
          LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": error in flags\n", entry->name));

          /* if there is another backup DNS server to try
           * then don't stop the DNS request
           */
          if (dns_backupserver_available(entry)) {
 8007c52:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007c54:	0018      	movs	r0, r3
 8007c56:	f7ff fe49 	bl	80078ec <dns_backupserver_available>
 8007c5a:	1e03      	subs	r3, r0, #0
 8007c5c:	d100      	bne.n	8007c60 <dns_recv+0x154>
 8007c5e:	e0a0      	b.n	8007da2 <dns_recv+0x296>
            /* avoid retrying the same server */
            entry->retries = DNS_MAX_RETRIES-1;
 8007c60:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007c62:	2203      	movs	r2, #3
 8007c64:	735a      	strb	r2, [r3, #13]
            entry->tmr     = 1;
 8007c66:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007c68:	2201      	movs	r2, #1
 8007c6a:	731a      	strb	r2, [r3, #12]

            /* contact next available server for this entry */
            dns_check_entry(i);
 8007c6c:	233b      	movs	r3, #59	; 0x3b
 8007c6e:	18fb      	adds	r3, r7, r3
 8007c70:	781b      	ldrb	r3, [r3, #0]
 8007c72:	0018      	movs	r0, r3
 8007c74:	f7ff fe5e 	bl	8007934 <dns_check_entry>

            goto ignore_packet;
 8007c78:	e0d2      	b.n	8007e20 <dns_recv+0x314>
          }
        } else {
          while ((nanswers > 0) && (res_idx < p->tot_len)) {
            /* skip answer resource record's host name */
            res_idx = dns_skip_name(p, res_idx);
 8007c7a:	253c      	movs	r5, #60	; 0x3c
 8007c7c:	197c      	adds	r4, r7, r5
 8007c7e:	197b      	adds	r3, r7, r5
 8007c80:	881a      	ldrh	r2, [r3, #0]
 8007c82:	687b      	ldr	r3, [r7, #4]
 8007c84:	0011      	movs	r1, r2
 8007c86:	0018      	movs	r0, r3
 8007c88:	f7ff faf0 	bl	800726c <dns_skip_name>
 8007c8c:	0003      	movs	r3, r0
 8007c8e:	8023      	strh	r3, [r4, #0]
            if (res_idx == 0xFFFF) {
 8007c90:	002c      	movs	r4, r5
 8007c92:	193b      	adds	r3, r7, r4
 8007c94:	881b      	ldrh	r3, [r3, #0]
 8007c96:	4a68      	ldr	r2, [pc, #416]	; (8007e38 <dns_recv+0x32c>)
 8007c98:	4293      	cmp	r3, r2
 8007c9a:	d100      	bne.n	8007c9e <dns_recv+0x192>
 8007c9c:	e0b7      	b.n	8007e0e <dns_recv+0x302>
              goto ignore_packet; /* ignore this packet */
            }

            /* Check for IP address type and Internet class. Others are discarded. */
            if (pbuf_copy_partial(p, &ans, SIZEOF_DNS_ANSWER, res_idx) != SIZEOF_DNS_ANSWER) {
 8007c9e:	193b      	adds	r3, r7, r4
 8007ca0:	881b      	ldrh	r3, [r3, #0]
 8007ca2:	2518      	movs	r5, #24
 8007ca4:	1979      	adds	r1, r7, r5
 8007ca6:	6878      	ldr	r0, [r7, #4]
 8007ca8:	220a      	movs	r2, #10
 8007caa:	f002 fbd1 	bl	800a450 <pbuf_copy_partial>
 8007cae:	0003      	movs	r3, r0
 8007cb0:	2b0a      	cmp	r3, #10
 8007cb2:	d000      	beq.n	8007cb6 <dns_recv+0x1aa>
 8007cb4:	e0ad      	b.n	8007e12 <dns_recv+0x306>
              goto ignore_packet; /* ignore this packet */
            }
            if (res_idx + SIZEOF_DNS_ANSWER > 0xFFFF) {
 8007cb6:	193b      	adds	r3, r7, r4
 8007cb8:	881b      	ldrh	r3, [r3, #0]
 8007cba:	4a61      	ldr	r2, [pc, #388]	; (8007e40 <dns_recv+0x334>)
 8007cbc:	4293      	cmp	r3, r2
 8007cbe:	d900      	bls.n	8007cc2 <dns_recv+0x1b6>
 8007cc0:	e0a9      	b.n	8007e16 <dns_recv+0x30a>
              goto ignore_packet;
            }
            res_idx = (u16_t)(res_idx + SIZEOF_DNS_ANSWER);
 8007cc2:	193b      	adds	r3, r7, r4
 8007cc4:	0021      	movs	r1, r4
 8007cc6:	193a      	adds	r2, r7, r4
 8007cc8:	8812      	ldrh	r2, [r2, #0]
 8007cca:	320a      	adds	r2, #10
 8007ccc:	801a      	strh	r2, [r3, #0]

            if (ans.cls == PP_HTONS(DNS_RRCLASS_IN)) {
 8007cce:	002c      	movs	r4, r5
 8007cd0:	193b      	adds	r3, r7, r4
 8007cd2:	885a      	ldrh	r2, [r3, #2]
 8007cd4:	2380      	movs	r3, #128	; 0x80
 8007cd6:	005b      	lsls	r3, r3, #1
 8007cd8:	429a      	cmp	r2, r3
 8007cda:	d134      	bne.n	8007d46 <dns_recv+0x23a>
#if LWIP_IPV4
              if ((ans.type == PP_HTONS(DNS_RRTYPE_A)) && (ans.len == PP_HTONS(sizeof(ip4_addr_t)))) {
 8007cdc:	193b      	adds	r3, r7, r4
 8007cde:	881a      	ldrh	r2, [r3, #0]
 8007ce0:	2380      	movs	r3, #128	; 0x80
 8007ce2:	005b      	lsls	r3, r3, #1
 8007ce4:	429a      	cmp	r2, r3
 8007ce6:	d12e      	bne.n	8007d46 <dns_recv+0x23a>
 8007ce8:	193b      	adds	r3, r7, r4
 8007cea:	891a      	ldrh	r2, [r3, #8]
 8007cec:	2380      	movs	r3, #128	; 0x80
 8007cee:	00db      	lsls	r3, r3, #3
 8007cf0:	429a      	cmp	r2, r3
 8007cf2:	d128      	bne.n	8007d46 <dns_recv+0x23a>
                if (!LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype))
#endif /* LWIP_IPV4 && LWIP_IPV6 */
                {
                  ip4_addr_t ip4addr;
                  /* read the IP address after answer resource record's header */
                  if (pbuf_copy_partial(p, &ip4addr, sizeof(ip4_addr_t), res_idx) != sizeof(ip4_addr_t)) {
 8007cf4:	187b      	adds	r3, r7, r1
 8007cf6:	881b      	ldrh	r3, [r3, #0]
 8007cf8:	2210      	movs	r2, #16
 8007cfa:	18b9      	adds	r1, r7, r2
 8007cfc:	6878      	ldr	r0, [r7, #4]
 8007cfe:	2204      	movs	r2, #4
 8007d00:	f002 fba6 	bl	800a450 <pbuf_copy_partial>
 8007d04:	0003      	movs	r3, r0
 8007d06:	2b04      	cmp	r3, #4
 8007d08:	d000      	beq.n	8007d0c <dns_recv+0x200>
 8007d0a:	e086      	b.n	8007e1a <dns_recv+0x30e>
                    goto ignore_packet; /* ignore this packet */
                  }
                  ip_addr_copy_from_ip4(dns_table[i].ipaddr, ip4addr);
 8007d0c:	253b      	movs	r5, #59	; 0x3b
 8007d0e:	197b      	adds	r3, r7, r5
 8007d10:	781a      	ldrb	r2, [r3, #0]
 8007d12:	6939      	ldr	r1, [r7, #16]
 8007d14:	4846      	ldr	r0, [pc, #280]	; (8007e30 <dns_recv+0x324>)
 8007d16:	0013      	movs	r3, r2
 8007d18:	00db      	lsls	r3, r3, #3
 8007d1a:	189b      	adds	r3, r3, r2
 8007d1c:	011b      	lsls	r3, r3, #4
 8007d1e:	18c3      	adds	r3, r0, r3
 8007d20:	3304      	adds	r3, #4
 8007d22:	6019      	str	r1, [r3, #0]
                  pbuf_free(p);
 8007d24:	687b      	ldr	r3, [r7, #4]
 8007d26:	0018      	movs	r0, r3
 8007d28:	f002 f8c8 	bl	8009ebc <pbuf_free>
                  /* handle correct response */
                  dns_correct_response(i, lwip_ntohl(ans.ttl));
 8007d2c:	193b      	adds	r3, r7, r4
 8007d2e:	685b      	ldr	r3, [r3, #4]
 8007d30:	0018      	movs	r0, r3
 8007d32:	f7ff f8f5 	bl	8006f20 <lwip_htonl>
 8007d36:	0002      	movs	r2, r0
 8007d38:	197b      	adds	r3, r7, r5
 8007d3a:	781b      	ldrb	r3, [r3, #0]
 8007d3c:	0011      	movs	r1, r2
 8007d3e:	0018      	movs	r0, r3
 8007d40:	f7ff feaa 	bl	8007a98 <dns_correct_response>
 8007d44:	e071      	b.n	8007e2a <dns_recv+0x31e>
                }
              }
#endif /* LWIP_IPV6 */
            }
            /* skip this answer */
            if ((int)(res_idx + lwip_htons(ans.len)) > 0xFFFF) {
 8007d46:	253c      	movs	r5, #60	; 0x3c
 8007d48:	197b      	adds	r3, r7, r5
 8007d4a:	881c      	ldrh	r4, [r3, #0]
 8007d4c:	2618      	movs	r6, #24
 8007d4e:	19bb      	adds	r3, r7, r6
 8007d50:	891b      	ldrh	r3, [r3, #8]
 8007d52:	0018      	movs	r0, r3
 8007d54:	f7ff f8ce 	bl	8006ef4 <lwip_htons>
 8007d58:	0003      	movs	r3, r0
 8007d5a:	18e2      	adds	r2, r4, r3
 8007d5c:	2380      	movs	r3, #128	; 0x80
 8007d5e:	025b      	lsls	r3, r3, #9
 8007d60:	429a      	cmp	r2, r3
 8007d62:	da5c      	bge.n	8007e1e <dns_recv+0x312>
              goto ignore_packet; /* ignore this packet */
            }
            res_idx = (u16_t)(res_idx + lwip_htons(ans.len));
 8007d64:	19bb      	adds	r3, r7, r6
 8007d66:	891b      	ldrh	r3, [r3, #8]
 8007d68:	0018      	movs	r0, r3
 8007d6a:	f7ff f8c3 	bl	8006ef4 <lwip_htons>
 8007d6e:	0003      	movs	r3, r0
 8007d70:	0019      	movs	r1, r3
 8007d72:	197b      	adds	r3, r7, r5
 8007d74:	197a      	adds	r2, r7, r5
 8007d76:	8812      	ldrh	r2, [r2, #0]
 8007d78:	188a      	adds	r2, r1, r2
 8007d7a:	801a      	strh	r2, [r3, #0]
            --nanswers;
 8007d7c:	223e      	movs	r2, #62	; 0x3e
 8007d7e:	18bb      	adds	r3, r7, r2
 8007d80:	18ba      	adds	r2, r7, r2
 8007d82:	8812      	ldrh	r2, [r2, #0]
 8007d84:	3a01      	subs	r2, #1
 8007d86:	801a      	strh	r2, [r3, #0]
          while ((nanswers > 0) && (res_idx < p->tot_len)) {
 8007d88:	233e      	movs	r3, #62	; 0x3e
 8007d8a:	18fb      	adds	r3, r7, r3
 8007d8c:	881b      	ldrh	r3, [r3, #0]
 8007d8e:	2b00      	cmp	r3, #0
 8007d90:	d007      	beq.n	8007da2 <dns_recv+0x296>
 8007d92:	687b      	ldr	r3, [r7, #4]
 8007d94:	891b      	ldrh	r3, [r3, #8]
 8007d96:	223c      	movs	r2, #60	; 0x3c
 8007d98:	18ba      	adds	r2, r7, r2
 8007d9a:	8812      	ldrh	r2, [r2, #0]
 8007d9c:	429a      	cmp	r2, r3
 8007d9e:	d200      	bcs.n	8007da2 <dns_recv+0x296>
 8007da0:	e76b      	b.n	8007c7a <dns_recv+0x16e>
          }
#endif /* LWIP_IPV4 && LWIP_IPV6 */
          LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": error in response\n", entry->name));
        }
        /* call callback to indicate error, clean up memory and return */
        pbuf_free(p);
 8007da2:	687b      	ldr	r3, [r7, #4]
 8007da4:	0018      	movs	r0, r3
 8007da6:	f002 f889 	bl	8009ebc <pbuf_free>
        dns_call_found(i, NULL);
 8007daa:	243b      	movs	r4, #59	; 0x3b
 8007dac:	193b      	adds	r3, r7, r4
 8007dae:	781b      	ldrb	r3, [r3, #0]
 8007db0:	2100      	movs	r1, #0
 8007db2:	0018      	movs	r0, r3
 8007db4:	f7ff fc84 	bl	80076c0 <dns_call_found>
        dns_table[i].state = DNS_STATE_UNUSED;
 8007db8:	193b      	adds	r3, r7, r4
 8007dba:	781a      	ldrb	r2, [r3, #0]
 8007dbc:	491c      	ldr	r1, [pc, #112]	; (8007e30 <dns_recv+0x324>)
 8007dbe:	0013      	movs	r3, r2
 8007dc0:	00db      	lsls	r3, r3, #3
 8007dc2:	189b      	adds	r3, r3, r2
 8007dc4:	011b      	lsls	r3, r3, #4
 8007dc6:	18cb      	adds	r3, r1, r3
 8007dc8:	330a      	adds	r3, #10
 8007dca:	2200      	movs	r2, #0
 8007dcc:	701a      	strb	r2, [r3, #0]
        return;
 8007dce:	e02c      	b.n	8007e2a <dns_recv+0x31e>
    for (i = 0; i < DNS_TABLE_SIZE; i++) {
 8007dd0:	213b      	movs	r1, #59	; 0x3b
 8007dd2:	187b      	adds	r3, r7, r1
 8007dd4:	781a      	ldrb	r2, [r3, #0]
 8007dd6:	187b      	adds	r3, r7, r1
 8007dd8:	3201      	adds	r2, #1
 8007dda:	701a      	strb	r2, [r3, #0]
 8007ddc:	233b      	movs	r3, #59	; 0x3b
 8007dde:	18fb      	adds	r3, r7, r3
 8007de0:	781b      	ldrb	r3, [r3, #0]
 8007de2:	2b02      	cmp	r3, #2
 8007de4:	d800      	bhi.n	8007de8 <dns_recv+0x2dc>
 8007de6:	e6b6      	b.n	8007b56 <dns_recv+0x4a>
      }
    }
  }

ignore_packet:
 8007de8:	e001      	b.n	8007dee <dns_recv+0x2e2>
    goto ignore_packet;
 8007dea:	46c0      	nop			; (mov r8, r8)
 8007dec:	e018      	b.n	8007e20 <dns_recv+0x314>
ignore_packet:
 8007dee:	46c0      	nop			; (mov r8, r8)
 8007df0:	e016      	b.n	8007e20 <dns_recv+0x314>
          goto ignore_packet; /* ignore this packet */
 8007df2:	46c0      	nop			; (mov r8, r8)
 8007df4:	e014      	b.n	8007e20 <dns_recv+0x314>
          goto ignore_packet; /* ignore this packet */
 8007df6:	46c0      	nop			; (mov r8, r8)
 8007df8:	e012      	b.n	8007e20 <dns_recv+0x314>
            goto ignore_packet; /* ignore this packet */
 8007dfa:	46c0      	nop			; (mov r8, r8)
 8007dfc:	e010      	b.n	8007e20 <dns_recv+0x314>
          goto ignore_packet; /* ignore this packet */
 8007dfe:	46c0      	nop			; (mov r8, r8)
 8007e00:	e00e      	b.n	8007e20 <dns_recv+0x314>
          goto ignore_packet; /* ignore this packet */
 8007e02:	46c0      	nop			; (mov r8, r8)
 8007e04:	e00c      	b.n	8007e20 <dns_recv+0x314>
          goto ignore_packet; /* ignore this packet */
 8007e06:	46c0      	nop			; (mov r8, r8)
 8007e08:	e00a      	b.n	8007e20 <dns_recv+0x314>
          goto ignore_packet;
 8007e0a:	46c0      	nop			; (mov r8, r8)
 8007e0c:	e008      	b.n	8007e20 <dns_recv+0x314>
              goto ignore_packet; /* ignore this packet */
 8007e0e:	46c0      	nop			; (mov r8, r8)
 8007e10:	e006      	b.n	8007e20 <dns_recv+0x314>
              goto ignore_packet; /* ignore this packet */
 8007e12:	46c0      	nop			; (mov r8, r8)
 8007e14:	e004      	b.n	8007e20 <dns_recv+0x314>
              goto ignore_packet;
 8007e16:	46c0      	nop			; (mov r8, r8)
 8007e18:	e002      	b.n	8007e20 <dns_recv+0x314>
                    goto ignore_packet; /* ignore this packet */
 8007e1a:	46c0      	nop			; (mov r8, r8)
 8007e1c:	e000      	b.n	8007e20 <dns_recv+0x314>
              goto ignore_packet; /* ignore this packet */
 8007e1e:	46c0      	nop			; (mov r8, r8)
  /* deallocate memory and return */
  pbuf_free(p);
 8007e20:	687b      	ldr	r3, [r7, #4]
 8007e22:	0018      	movs	r0, r3
 8007e24:	f002 f84a 	bl	8009ebc <pbuf_free>
  return;
 8007e28:	46c0      	nop			; (mov r8, r8)
}
 8007e2a:	46bd      	mov	sp, r7
 8007e2c:	b011      	add	sp, #68	; 0x44
 8007e2e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007e30:	2000158c 	.word	0x2000158c
 8007e34:	20001760 	.word	0x20001760
 8007e38:	0000ffff 	.word	0x0000ffff
 8007e3c:	0000fffb 	.word	0x0000fffb
 8007e40:	0000fff5 	.word	0x0000fff5

08007e44 <dns_enqueue>:
 * @return err_t return code.
 */
static err_t
dns_enqueue(const char *name, size_t hostnamelen, dns_found_callback found,
            void *callback_arg LWIP_DNS_ADDRTYPE_ARG(u8_t dns_addrtype) LWIP_DNS_ISMDNS_ARG(u8_t is_mdns))
{
 8007e44:	b590      	push	{r4, r7, lr}
 8007e46:	b08b      	sub	sp, #44	; 0x2c
 8007e48:	af00      	add	r7, sp, #0
 8007e4a:	60f8      	str	r0, [r7, #12]
 8007e4c:	60b9      	str	r1, [r7, #8]
 8007e4e:	607a      	str	r2, [r7, #4]
 8007e50:	603b      	str	r3, [r7, #0]
  u8_t i;
  u8_t lseq, lseqi;
  struct dns_table_entry *entry = NULL;
 8007e52:	2300      	movs	r3, #0
 8007e54:	623b      	str	r3, [r7, #32]
  struct dns_req_entry *req;

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING) != 0)
  u8_t r;
  /* check for duplicate entries */
  for (i = 0; i < DNS_TABLE_SIZE; i++) {
 8007e56:	2327      	movs	r3, #39	; 0x27
 8007e58:	18fb      	adds	r3, r7, r3
 8007e5a:	2200      	movs	r2, #0
 8007e5c:	701a      	strb	r2, [r3, #0]
 8007e5e:	e062      	b.n	8007f26 <dns_enqueue+0xe2>
    if ((dns_table[i].state == DNS_STATE_ASKING) &&
 8007e60:	2027      	movs	r0, #39	; 0x27
 8007e62:	183b      	adds	r3, r7, r0
 8007e64:	781a      	ldrb	r2, [r3, #0]
 8007e66:	49a3      	ldr	r1, [pc, #652]	; (80080f4 <dns_enqueue+0x2b0>)
 8007e68:	0013      	movs	r3, r2
 8007e6a:	00db      	lsls	r3, r3, #3
 8007e6c:	189b      	adds	r3, r3, r2
 8007e6e:	011b      	lsls	r3, r3, #4
 8007e70:	18cb      	adds	r3, r1, r3
 8007e72:	330a      	adds	r3, #10
 8007e74:	781b      	ldrb	r3, [r3, #0]
 8007e76:	2b02      	cmp	r3, #2
 8007e78:	d14f      	bne.n	8007f1a <dns_enqueue+0xd6>
        (lwip_strnicmp(name, dns_table[i].name, sizeof(dns_table[i].name)) == 0)) {
 8007e7a:	183b      	adds	r3, r7, r0
 8007e7c:	781a      	ldrb	r2, [r3, #0]
 8007e7e:	0013      	movs	r3, r2
 8007e80:	00db      	lsls	r3, r3, #3
 8007e82:	189b      	adds	r3, r3, r2
 8007e84:	011b      	lsls	r3, r3, #4
 8007e86:	3310      	adds	r3, #16
 8007e88:	001a      	movs	r2, r3
 8007e8a:	4b9a      	ldr	r3, [pc, #616]	; (80080f4 <dns_enqueue+0x2b0>)
 8007e8c:	18d1      	adds	r1, r2, r3
 8007e8e:	68fb      	ldr	r3, [r7, #12]
 8007e90:	2280      	movs	r2, #128	; 0x80
 8007e92:	0018      	movs	r0, r3
 8007e94:	f7ff f85d 	bl	8006f52 <lwip_strnicmp>
 8007e98:	1e03      	subs	r3, r0, #0
    if ((dns_table[i].state == DNS_STATE_ASKING) &&
 8007e9a:	d13e      	bne.n	8007f1a <dns_enqueue+0xd6>
           for the same host should not be that common */
        continue;
      }
#endif /* LWIP_IPV4 && LWIP_IPV6 */
      /* this is a duplicate entry, find a free request entry */
      for (r = 0; r < DNS_MAX_REQUESTS; r++) {
 8007e9c:	231b      	movs	r3, #27
 8007e9e:	18fb      	adds	r3, r7, r3
 8007ea0:	2200      	movs	r2, #0
 8007ea2:	701a      	strb	r2, [r3, #0]
 8007ea4:	e034      	b.n	8007f10 <dns_enqueue+0xcc>
        if (dns_requests[r].found == 0) {
 8007ea6:	201b      	movs	r0, #27
 8007ea8:	183b      	adds	r3, r7, r0
 8007eaa:	781a      	ldrb	r2, [r3, #0]
 8007eac:	4992      	ldr	r1, [pc, #584]	; (80080f8 <dns_enqueue+0x2b4>)
 8007eae:	0013      	movs	r3, r2
 8007eb0:	005b      	lsls	r3, r3, #1
 8007eb2:	189b      	adds	r3, r3, r2
 8007eb4:	009b      	lsls	r3, r3, #2
 8007eb6:	585b      	ldr	r3, [r3, r1]
 8007eb8:	2b00      	cmp	r3, #0
 8007eba:	d123      	bne.n	8007f04 <dns_enqueue+0xc0>
          dns_requests[r].found = found;
 8007ebc:	183b      	adds	r3, r7, r0
 8007ebe:	781a      	ldrb	r2, [r3, #0]
 8007ec0:	498d      	ldr	r1, [pc, #564]	; (80080f8 <dns_enqueue+0x2b4>)
 8007ec2:	0013      	movs	r3, r2
 8007ec4:	005b      	lsls	r3, r3, #1
 8007ec6:	189b      	adds	r3, r3, r2
 8007ec8:	009b      	lsls	r3, r3, #2
 8007eca:	687a      	ldr	r2, [r7, #4]
 8007ecc:	505a      	str	r2, [r3, r1]
          dns_requests[r].arg = callback_arg;
 8007ece:	183b      	adds	r3, r7, r0
 8007ed0:	781a      	ldrb	r2, [r3, #0]
 8007ed2:	4989      	ldr	r1, [pc, #548]	; (80080f8 <dns_enqueue+0x2b4>)
 8007ed4:	0013      	movs	r3, r2
 8007ed6:	005b      	lsls	r3, r3, #1
 8007ed8:	189b      	adds	r3, r3, r2
 8007eda:	009b      	lsls	r3, r3, #2
 8007edc:	18cb      	adds	r3, r1, r3
 8007ede:	3304      	adds	r3, #4
 8007ee0:	683a      	ldr	r2, [r7, #0]
 8007ee2:	601a      	str	r2, [r3, #0]
          dns_requests[r].dns_table_idx = i;
 8007ee4:	183b      	adds	r3, r7, r0
 8007ee6:	781a      	ldrb	r2, [r3, #0]
 8007ee8:	4983      	ldr	r1, [pc, #524]	; (80080f8 <dns_enqueue+0x2b4>)
 8007eea:	0013      	movs	r3, r2
 8007eec:	005b      	lsls	r3, r3, #1
 8007eee:	189b      	adds	r3, r3, r2
 8007ef0:	009b      	lsls	r3, r3, #2
 8007ef2:	18cb      	adds	r3, r1, r3
 8007ef4:	3308      	adds	r3, #8
 8007ef6:	2227      	movs	r2, #39	; 0x27
 8007ef8:	18ba      	adds	r2, r7, r2
 8007efa:	7812      	ldrb	r2, [r2, #0]
 8007efc:	701a      	strb	r2, [r3, #0]
          LWIP_DNS_SET_ADDRTYPE(dns_requests[r].reqaddrtype, dns_addrtype);
          LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": duplicate request\n", name));
          return ERR_INPROGRESS;
 8007efe:	2305      	movs	r3, #5
 8007f00:	425b      	negs	r3, r3
 8007f02:	e0f3      	b.n	80080ec <dns_enqueue+0x2a8>
      for (r = 0; r < DNS_MAX_REQUESTS; r++) {
 8007f04:	211b      	movs	r1, #27
 8007f06:	187b      	adds	r3, r7, r1
 8007f08:	781a      	ldrb	r2, [r3, #0]
 8007f0a:	187b      	adds	r3, r7, r1
 8007f0c:	3201      	adds	r2, #1
 8007f0e:	701a      	strb	r2, [r3, #0]
 8007f10:	231b      	movs	r3, #27
 8007f12:	18fb      	adds	r3, r7, r3
 8007f14:	781b      	ldrb	r3, [r3, #0]
 8007f16:	2b02      	cmp	r3, #2
 8007f18:	d9c5      	bls.n	8007ea6 <dns_enqueue+0x62>
  for (i = 0; i < DNS_TABLE_SIZE; i++) {
 8007f1a:	2127      	movs	r1, #39	; 0x27
 8007f1c:	187b      	adds	r3, r7, r1
 8007f1e:	781a      	ldrb	r2, [r3, #0]
 8007f20:	187b      	adds	r3, r7, r1
 8007f22:	3201      	adds	r2, #1
 8007f24:	701a      	strb	r2, [r3, #0]
 8007f26:	2127      	movs	r1, #39	; 0x27
 8007f28:	187b      	adds	r3, r7, r1
 8007f2a:	781b      	ldrb	r3, [r3, #0]
 8007f2c:	2b02      	cmp	r3, #2
 8007f2e:	d997      	bls.n	8007e60 <dns_enqueue+0x1c>
  }
  /* no duplicate entries found */
#endif

  /* search an unused entry, or the oldest one */
  lseq = 0;
 8007f30:	2326      	movs	r3, #38	; 0x26
 8007f32:	18fb      	adds	r3, r7, r3
 8007f34:	2200      	movs	r2, #0
 8007f36:	701a      	strb	r2, [r3, #0]
  lseqi = DNS_TABLE_SIZE;
 8007f38:	2325      	movs	r3, #37	; 0x25
 8007f3a:	18fb      	adds	r3, r7, r3
 8007f3c:	2203      	movs	r2, #3
 8007f3e:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 8007f40:	187b      	adds	r3, r7, r1
 8007f42:	2200      	movs	r2, #0
 8007f44:	701a      	strb	r2, [r3, #0]
 8007f46:	e030      	b.n	8007faa <dns_enqueue+0x166>
    entry = &dns_table[i];
 8007f48:	2427      	movs	r4, #39	; 0x27
 8007f4a:	193b      	adds	r3, r7, r4
 8007f4c:	781a      	ldrb	r2, [r3, #0]
 8007f4e:	0013      	movs	r3, r2
 8007f50:	00db      	lsls	r3, r3, #3
 8007f52:	189b      	adds	r3, r3, r2
 8007f54:	011b      	lsls	r3, r3, #4
 8007f56:	4a67      	ldr	r2, [pc, #412]	; (80080f4 <dns_enqueue+0x2b0>)
 8007f58:	189b      	adds	r3, r3, r2
 8007f5a:	623b      	str	r3, [r7, #32]
    /* is it an unused entry ? */
    if (entry->state == DNS_STATE_UNUSED) {
 8007f5c:	6a3b      	ldr	r3, [r7, #32]
 8007f5e:	7a9b      	ldrb	r3, [r3, #10]
 8007f60:	2b00      	cmp	r3, #0
 8007f62:	d028      	beq.n	8007fb6 <dns_enqueue+0x172>
      break;
    }
    /* check if this is the oldest completed entry */
    if (entry->state == DNS_STATE_DONE) {
 8007f64:	6a3b      	ldr	r3, [r7, #32]
 8007f66:	7a9b      	ldrb	r3, [r3, #10]
 8007f68:	2b03      	cmp	r3, #3
 8007f6a:	d118      	bne.n	8007f9e <dns_enqueue+0x15a>
      u8_t age = (u8_t)(dns_seqno - entry->seqno);
 8007f6c:	4b63      	ldr	r3, [pc, #396]	; (80080fc <dns_enqueue+0x2b8>)
 8007f6e:	7819      	ldrb	r1, [r3, #0]
 8007f70:	6a3b      	ldr	r3, [r7, #32]
 8007f72:	7b9a      	ldrb	r2, [r3, #14]
 8007f74:	201a      	movs	r0, #26
 8007f76:	183b      	adds	r3, r7, r0
 8007f78:	1a8a      	subs	r2, r1, r2
 8007f7a:	701a      	strb	r2, [r3, #0]
      if (age > lseq) {
 8007f7c:	0001      	movs	r1, r0
 8007f7e:	187a      	adds	r2, r7, r1
 8007f80:	2026      	movs	r0, #38	; 0x26
 8007f82:	183b      	adds	r3, r7, r0
 8007f84:	7812      	ldrb	r2, [r2, #0]
 8007f86:	781b      	ldrb	r3, [r3, #0]
 8007f88:	429a      	cmp	r2, r3
 8007f8a:	d908      	bls.n	8007f9e <dns_enqueue+0x15a>
        lseq = age;
 8007f8c:	183b      	adds	r3, r7, r0
 8007f8e:	187a      	adds	r2, r7, r1
 8007f90:	7812      	ldrb	r2, [r2, #0]
 8007f92:	701a      	strb	r2, [r3, #0]
        lseqi = i;
 8007f94:	2325      	movs	r3, #37	; 0x25
 8007f96:	18fb      	adds	r3, r7, r3
 8007f98:	193a      	adds	r2, r7, r4
 8007f9a:	7812      	ldrb	r2, [r2, #0]
 8007f9c:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 8007f9e:	2227      	movs	r2, #39	; 0x27
 8007fa0:	18bb      	adds	r3, r7, r2
 8007fa2:	18ba      	adds	r2, r7, r2
 8007fa4:	7812      	ldrb	r2, [r2, #0]
 8007fa6:	3201      	adds	r2, #1
 8007fa8:	701a      	strb	r2, [r3, #0]
 8007faa:	2327      	movs	r3, #39	; 0x27
 8007fac:	18fb      	adds	r3, r7, r3
 8007fae:	781b      	ldrb	r3, [r3, #0]
 8007fb0:	2b02      	cmp	r3, #2
 8007fb2:	d9c9      	bls.n	8007f48 <dns_enqueue+0x104>
 8007fb4:	e000      	b.n	8007fb8 <dns_enqueue+0x174>
      break;
 8007fb6:	46c0      	nop			; (mov r8, r8)
      }
    }
  }

  /* if we don't have found an unused entry, use the oldest completed one */
  if (i == DNS_TABLE_SIZE) {
 8007fb8:	2327      	movs	r3, #39	; 0x27
 8007fba:	18fb      	adds	r3, r7, r3
 8007fbc:	781b      	ldrb	r3, [r3, #0]
 8007fbe:	2b03      	cmp	r3, #3
 8007fc0:	d122      	bne.n	8008008 <dns_enqueue+0x1c4>
    if ((lseqi >= DNS_TABLE_SIZE) || (dns_table[lseqi].state != DNS_STATE_DONE)) {
 8007fc2:	2225      	movs	r2, #37	; 0x25
 8007fc4:	18bb      	adds	r3, r7, r2
 8007fc6:	781b      	ldrb	r3, [r3, #0]
 8007fc8:	2b02      	cmp	r3, #2
 8007fca:	d80b      	bhi.n	8007fe4 <dns_enqueue+0x1a0>
 8007fcc:	18bb      	adds	r3, r7, r2
 8007fce:	781a      	ldrb	r2, [r3, #0]
 8007fd0:	4948      	ldr	r1, [pc, #288]	; (80080f4 <dns_enqueue+0x2b0>)
 8007fd2:	0013      	movs	r3, r2
 8007fd4:	00db      	lsls	r3, r3, #3
 8007fd6:	189b      	adds	r3, r3, r2
 8007fd8:	011b      	lsls	r3, r3, #4
 8007fda:	18cb      	adds	r3, r1, r3
 8007fdc:	330a      	adds	r3, #10
 8007fde:	781b      	ldrb	r3, [r3, #0]
 8007fe0:	2b03      	cmp	r3, #3
 8007fe2:	d002      	beq.n	8007fea <dns_enqueue+0x1a6>
      /* no entry can be used now, table is full */
      LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": DNS entries table is full\n", name));
      return ERR_MEM;
 8007fe4:	2301      	movs	r3, #1
 8007fe6:	425b      	negs	r3, r3
 8007fe8:	e080      	b.n	80080ec <dns_enqueue+0x2a8>
    } else {
      /* use the oldest completed one */
      i = lseqi;
 8007fea:	2127      	movs	r1, #39	; 0x27
 8007fec:	187b      	adds	r3, r7, r1
 8007fee:	2225      	movs	r2, #37	; 0x25
 8007ff0:	18ba      	adds	r2, r7, r2
 8007ff2:	7812      	ldrb	r2, [r2, #0]
 8007ff4:	701a      	strb	r2, [r3, #0]
      entry = &dns_table[i];
 8007ff6:	187b      	adds	r3, r7, r1
 8007ff8:	781a      	ldrb	r2, [r3, #0]
 8007ffa:	0013      	movs	r3, r2
 8007ffc:	00db      	lsls	r3, r3, #3
 8007ffe:	189b      	adds	r3, r3, r2
 8008000:	011b      	lsls	r3, r3, #4
 8008002:	4a3c      	ldr	r2, [pc, #240]	; (80080f4 <dns_enqueue+0x2b0>)
 8008004:	189b      	adds	r3, r3, r2
 8008006:	623b      	str	r3, [r7, #32]
    }
  }

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING) != 0)
  /* find a free request entry */
  req = NULL;
 8008008:	2300      	movs	r3, #0
 800800a:	61fb      	str	r3, [r7, #28]
  for (r = 0; r < DNS_MAX_REQUESTS; r++) {
 800800c:	231b      	movs	r3, #27
 800800e:	18fb      	adds	r3, r7, r3
 8008010:	2200      	movs	r2, #0
 8008012:	701a      	strb	r2, [r3, #0]
 8008014:	e01a      	b.n	800804c <dns_enqueue+0x208>
    if (dns_requests[r].found == NULL) {
 8008016:	201b      	movs	r0, #27
 8008018:	183b      	adds	r3, r7, r0
 800801a:	781a      	ldrb	r2, [r3, #0]
 800801c:	4936      	ldr	r1, [pc, #216]	; (80080f8 <dns_enqueue+0x2b4>)
 800801e:	0013      	movs	r3, r2
 8008020:	005b      	lsls	r3, r3, #1
 8008022:	189b      	adds	r3, r3, r2
 8008024:	009b      	lsls	r3, r3, #2
 8008026:	585b      	ldr	r3, [r3, r1]
 8008028:	2b00      	cmp	r3, #0
 800802a:	d109      	bne.n	8008040 <dns_enqueue+0x1fc>
      req = &dns_requests[r];
 800802c:	183b      	adds	r3, r7, r0
 800802e:	781a      	ldrb	r2, [r3, #0]
 8008030:	0013      	movs	r3, r2
 8008032:	005b      	lsls	r3, r3, #1
 8008034:	189b      	adds	r3, r3, r2
 8008036:	009b      	lsls	r3, r3, #2
 8008038:	4a2f      	ldr	r2, [pc, #188]	; (80080f8 <dns_enqueue+0x2b4>)
 800803a:	189b      	adds	r3, r3, r2
 800803c:	61fb      	str	r3, [r7, #28]
      break;
 800803e:	e00a      	b.n	8008056 <dns_enqueue+0x212>
  for (r = 0; r < DNS_MAX_REQUESTS; r++) {
 8008040:	211b      	movs	r1, #27
 8008042:	187b      	adds	r3, r7, r1
 8008044:	781a      	ldrb	r2, [r3, #0]
 8008046:	187b      	adds	r3, r7, r1
 8008048:	3201      	adds	r2, #1
 800804a:	701a      	strb	r2, [r3, #0]
 800804c:	231b      	movs	r3, #27
 800804e:	18fb      	adds	r3, r7, r3
 8008050:	781b      	ldrb	r3, [r3, #0]
 8008052:	2b02      	cmp	r3, #2
 8008054:	d9df      	bls.n	8008016 <dns_enqueue+0x1d2>
    }
  }
  if (req == NULL) {
 8008056:	69fb      	ldr	r3, [r7, #28]
 8008058:	2b00      	cmp	r3, #0
 800805a:	d102      	bne.n	8008062 <dns_enqueue+0x21e>
    /* no request entry can be used now, table is full */
    LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": DNS request entries table is full\n", name));
    return ERR_MEM;
 800805c:	2301      	movs	r3, #1
 800805e:	425b      	negs	r3, r3
 8008060:	e044      	b.n	80080ec <dns_enqueue+0x2a8>
  }
  req->dns_table_idx = i;
 8008062:	69fb      	ldr	r3, [r7, #28]
 8008064:	2227      	movs	r2, #39	; 0x27
 8008066:	18ba      	adds	r2, r7, r2
 8008068:	7812      	ldrb	r2, [r2, #0]
 800806a:	721a      	strb	r2, [r3, #8]

  /* use this entry */
  LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": use DNS entry %"U16_F"\n", name, (u16_t)(i)));

  /* fill the entry */
  entry->state = DNS_STATE_NEW;
 800806c:	6a3b      	ldr	r3, [r7, #32]
 800806e:	2201      	movs	r2, #1
 8008070:	729a      	strb	r2, [r3, #10]
  entry->seqno = dns_seqno;
 8008072:	4b22      	ldr	r3, [pc, #136]	; (80080fc <dns_enqueue+0x2b8>)
 8008074:	781a      	ldrb	r2, [r3, #0]
 8008076:	6a3b      	ldr	r3, [r7, #32]
 8008078:	739a      	strb	r2, [r3, #14]
  LWIP_DNS_SET_ADDRTYPE(entry->reqaddrtype, dns_addrtype);
  LWIP_DNS_SET_ADDRTYPE(req->reqaddrtype, dns_addrtype);
  req->found = found;
 800807a:	69fb      	ldr	r3, [r7, #28]
 800807c:	687a      	ldr	r2, [r7, #4]
 800807e:	601a      	str	r2, [r3, #0]
  req->arg   = callback_arg;
 8008080:	69fb      	ldr	r3, [r7, #28]
 8008082:	683a      	ldr	r2, [r7, #0]
 8008084:	605a      	str	r2, [r3, #4]
  namelen = LWIP_MIN(hostnamelen, DNS_MAX_NAME_LENGTH - 1);
 8008086:	68bb      	ldr	r3, [r7, #8]
 8008088:	2b7f      	cmp	r3, #127	; 0x7f
 800808a:	d900      	bls.n	800808e <dns_enqueue+0x24a>
 800808c:	237f      	movs	r3, #127	; 0x7f
 800808e:	617b      	str	r3, [r7, #20]
  MEMCPY(entry->name, name, namelen);
 8008090:	6a3b      	ldr	r3, [r7, #32]
 8008092:	3310      	adds	r3, #16
 8008094:	697a      	ldr	r2, [r7, #20]
 8008096:	68f9      	ldr	r1, [r7, #12]
 8008098:	0018      	movs	r0, r3
 800809a:	f014 ff17 	bl	801cecc <memcpy>
  entry->name[namelen] = 0;
 800809e:	6a3a      	ldr	r2, [r7, #32]
 80080a0:	697b      	ldr	r3, [r7, #20]
 80080a2:	18d3      	adds	r3, r2, r3
 80080a4:	3310      	adds	r3, #16
 80080a6:	2200      	movs	r2, #0
 80080a8:	701a      	strb	r2, [r3, #0]

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) != 0)
  entry->pcb_idx = dns_alloc_pcb();
 80080aa:	f7ff faa1 	bl	80075f0 <dns_alloc_pcb>
 80080ae:	0003      	movs	r3, r0
 80080b0:	001a      	movs	r2, r3
 80080b2:	6a3b      	ldr	r3, [r7, #32]
 80080b4:	73da      	strb	r2, [r3, #15]
  if (entry->pcb_idx >= DNS_MAX_SOURCE_PORTS) {
 80080b6:	6a3b      	ldr	r3, [r7, #32]
 80080b8:	7bdb      	ldrb	r3, [r3, #15]
 80080ba:	2b02      	cmp	r3, #2
 80080bc:	d908      	bls.n	80080d0 <dns_enqueue+0x28c>
    /* failed to get a UDP pcb */
    LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": failed to allocate a pcb\n", name));
    entry->state = DNS_STATE_UNUSED;
 80080be:	6a3b      	ldr	r3, [r7, #32]
 80080c0:	2200      	movs	r2, #0
 80080c2:	729a      	strb	r2, [r3, #10]
    req->found = NULL;
 80080c4:	69fb      	ldr	r3, [r7, #28]
 80080c6:	2200      	movs	r2, #0
 80080c8:	601a      	str	r2, [r3, #0]
    return ERR_MEM;
 80080ca:	2301      	movs	r3, #1
 80080cc:	425b      	negs	r3, r3
 80080ce:	e00d      	b.n	80080ec <dns_enqueue+0x2a8>

#if LWIP_DNS_SUPPORT_MDNS_QUERIES
  entry->is_mdns = is_mdns;
#endif

  dns_seqno++;
 80080d0:	4b0a      	ldr	r3, [pc, #40]	; (80080fc <dns_enqueue+0x2b8>)
 80080d2:	781b      	ldrb	r3, [r3, #0]
 80080d4:	3301      	adds	r3, #1
 80080d6:	b2da      	uxtb	r2, r3
 80080d8:	4b08      	ldr	r3, [pc, #32]	; (80080fc <dns_enqueue+0x2b8>)
 80080da:	701a      	strb	r2, [r3, #0]

  /* force to send query without waiting timer */
  dns_check_entry(i);
 80080dc:	2327      	movs	r3, #39	; 0x27
 80080de:	18fb      	adds	r3, r7, r3
 80080e0:	781b      	ldrb	r3, [r3, #0]
 80080e2:	0018      	movs	r0, r3
 80080e4:	f7ff fc26 	bl	8007934 <dns_check_entry>

  /* dns query is enqueued */
  return ERR_INPROGRESS;
 80080e8:	2305      	movs	r3, #5
 80080ea:	425b      	negs	r3, r3
}
 80080ec:	0018      	movs	r0, r3
 80080ee:	46bd      	mov	sp, r7
 80080f0:	b00b      	add	sp, #44	; 0x2c
 80080f2:	bd90      	pop	{r4, r7, pc}
 80080f4:	2000158c 	.word	0x2000158c
 80080f8:	2000173c 	.word	0x2000173c
 80080fc:	20001589 	.word	0x20001589

08008100 <dns_gethostbyname>:
 * @return a err_t return code.
 */
err_t
dns_gethostbyname(const char *hostname, ip_addr_t *addr, dns_found_callback found,
                  void *callback_arg)
{
 8008100:	b590      	push	{r4, r7, lr}
 8008102:	b087      	sub	sp, #28
 8008104:	af02      	add	r7, sp, #8
 8008106:	60f8      	str	r0, [r7, #12]
 8008108:	60b9      	str	r1, [r7, #8]
 800810a:	607a      	str	r2, [r7, #4]
 800810c:	603b      	str	r3, [r7, #0]
  return dns_gethostbyname_addrtype(hostname, addr, found, callback_arg, LWIP_DNS_ADDRTYPE_DEFAULT);
 800810e:	683b      	ldr	r3, [r7, #0]
 8008110:	687a      	ldr	r2, [r7, #4]
 8008112:	68b9      	ldr	r1, [r7, #8]
 8008114:	68f8      	ldr	r0, [r7, #12]
 8008116:	2400      	movs	r4, #0
 8008118:	9400      	str	r4, [sp, #0]
 800811a:	f000 f805 	bl	8008128 <dns_gethostbyname_addrtype>
 800811e:	0003      	movs	r3, r0
}
 8008120:	0018      	movs	r0, r3
 8008122:	46bd      	mov	sp, r7
 8008124:	b005      	add	sp, #20
 8008126:	bd90      	pop	{r4, r7, pc}

08008128 <dns_gethostbyname_addrtype>:
 *                     - LWIP_DNS_ADDRTYPE_IPV6: try to resolve IPv6 only
 */
err_t
dns_gethostbyname_addrtype(const char *hostname, ip_addr_t *addr, dns_found_callback found,
                           void *callback_arg, u8_t dns_addrtype)
{
 8008128:	b580      	push	{r7, lr}
 800812a:	b086      	sub	sp, #24
 800812c:	af00      	add	r7, sp, #0
 800812e:	60f8      	str	r0, [r7, #12]
 8008130:	60b9      	str	r1, [r7, #8]
 8008132:	607a      	str	r2, [r7, #4]
 8008134:	603b      	str	r3, [r7, #0]
#if LWIP_DNS_SUPPORT_MDNS_QUERIES
  u8_t is_mdns;
#endif
  /* not initialized or no valid server yet, or invalid addr pointer
   * or invalid hostname or invalid hostname length */
  if ((addr == NULL) ||
 8008136:	68bb      	ldr	r3, [r7, #8]
 8008138:	2b00      	cmp	r3, #0
 800813a:	d006      	beq.n	800814a <dns_gethostbyname_addrtype+0x22>
 800813c:	68fb      	ldr	r3, [r7, #12]
 800813e:	2b00      	cmp	r3, #0
 8008140:	d003      	beq.n	800814a <dns_gethostbyname_addrtype+0x22>
      (!hostname) || (!hostname[0])) {
 8008142:	68fb      	ldr	r3, [r7, #12]
 8008144:	781b      	ldrb	r3, [r3, #0]
 8008146:	2b00      	cmp	r3, #0
 8008148:	d102      	bne.n	8008150 <dns_gethostbyname_addrtype+0x28>
    return ERR_ARG;
 800814a:	2310      	movs	r3, #16
 800814c:	425b      	negs	r3, r3
 800814e:	e02d      	b.n	80081ac <dns_gethostbyname_addrtype+0x84>
#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) == 0)
  if (dns_pcbs[0] == NULL) {
    return ERR_ARG;
  }
#endif
  hostnamelen = strlen(hostname);
 8008150:	68fb      	ldr	r3, [r7, #12]
 8008152:	0018      	movs	r0, r3
 8008154:	f7f7 ffd8 	bl	8000108 <strlen>
 8008158:	0003      	movs	r3, r0
 800815a:	617b      	str	r3, [r7, #20]
  if (hostnamelen >= DNS_MAX_NAME_LENGTH) {
 800815c:	697b      	ldr	r3, [r7, #20]
 800815e:	2b7f      	cmp	r3, #127	; 0x7f
 8008160:	d902      	bls.n	8008168 <dns_gethostbyname_addrtype+0x40>
    LWIP_DEBUGF(DNS_DEBUG, ("dns_gethostbyname: name too long to resolve"));
    return ERR_ARG;
 8008162:	2310      	movs	r3, #16
 8008164:	425b      	negs	r3, r3
 8008166:	e021      	b.n	80081ac <dns_gethostbyname_addrtype+0x84>
    return ERR_OK;
  }
#endif /* LWIP_HAVE_LOOPIF */

  /* host name already in octet notation? set ip addr and return ERR_OK */
  if (ipaddr_aton(hostname, addr)) {
 8008168:	68ba      	ldr	r2, [r7, #8]
 800816a:	68fb      	ldr	r3, [r7, #12]
 800816c:	0011      	movs	r1, r2
 800816e:	0018      	movs	r0, r3
 8008170:	f00b fe92 	bl	8013e98 <ip4addr_aton>
 8008174:	1e03      	subs	r3, r0, #0
 8008176:	d001      	beq.n	800817c <dns_gethostbyname_addrtype+0x54>
#if LWIP_IPV4 && LWIP_IPV6
    if ((IP_IS_V6(addr) && (dns_addrtype != LWIP_DNS_ADDRTYPE_IPV4)) ||
        (IP_IS_V4(addr) && (dns_addrtype != LWIP_DNS_ADDRTYPE_IPV6)))
#endif /* LWIP_IPV4 && LWIP_IPV6 */
    {
      return ERR_OK;
 8008178:	2300      	movs	r3, #0
 800817a:	e017      	b.n	80081ac <dns_gethostbyname_addrtype+0x84>
    }
  }
  /* already have this address cached? */
  if (dns_lookup(hostname, addr LWIP_DNS_ADDRTYPE_ARG(dns_addrtype)) == ERR_OK) {
 800817c:	68ba      	ldr	r2, [r7, #8]
 800817e:	68fb      	ldr	r3, [r7, #12]
 8008180:	0011      	movs	r1, r2
 8008182:	0018      	movs	r0, r3
 8008184:	f7fe ff76 	bl	8007074 <dns_lookup>
 8008188:	1e03      	subs	r3, r0, #0
 800818a:	d101      	bne.n	8008190 <dns_gethostbyname_addrtype+0x68>
    return ERR_OK;
 800818c:	2300      	movs	r3, #0
 800818e:	e00d      	b.n	80081ac <dns_gethostbyname_addrtype+0x84>

  if (!is_mdns)
#endif /* LWIP_DNS_SUPPORT_MDNS_QUERIES */
  {
    /* prevent calling found callback if no server is set, return error instead */
    if (ip_addr_isany_val(dns_servers[0])) {
 8008190:	4b08      	ldr	r3, [pc, #32]	; (80081b4 <dns_gethostbyname_addrtype+0x8c>)
 8008192:	681b      	ldr	r3, [r3, #0]
 8008194:	2b00      	cmp	r3, #0
 8008196:	d102      	bne.n	800819e <dns_gethostbyname_addrtype+0x76>
      return ERR_VAL;
 8008198:	2306      	movs	r3, #6
 800819a:	425b      	negs	r3, r3
 800819c:	e006      	b.n	80081ac <dns_gethostbyname_addrtype+0x84>
    }
  }

  /* queue query with specified callback */
  return dns_enqueue(hostname, hostnamelen, found, callback_arg LWIP_DNS_ADDRTYPE_ARG(dns_addrtype)
 800819e:	683b      	ldr	r3, [r7, #0]
 80081a0:	687a      	ldr	r2, [r7, #4]
 80081a2:	6979      	ldr	r1, [r7, #20]
 80081a4:	68f8      	ldr	r0, [r7, #12]
 80081a6:	f7ff fe4d 	bl	8007e44 <dns_enqueue>
 80081aa:	0003      	movs	r3, r0
                     LWIP_DNS_ISMDNS_ARG(is_mdns));
}
 80081ac:	0018      	movs	r0, r3
 80081ae:	46bd      	mov	sp, r7
 80081b0:	b006      	add	sp, #24
 80081b2:	bd80      	pop	{r7, pc}
 80081b4:	20001760 	.word	0x20001760

080081b8 <lwip_standard_chksum>:
 * @param len length of data to be summed
 * @return host order (!) lwip checksum (non-inverted Internet sum)
 */
u16_t
lwip_standard_chksum(const void *dataptr, int len)
{
 80081b8:	b580      	push	{r7, lr}
 80081ba:	b088      	sub	sp, #32
 80081bc:	af00      	add	r7, sp, #0
 80081be:	6078      	str	r0, [r7, #4]
 80081c0:	6039      	str	r1, [r7, #0]
  const u8_t *pb = (const u8_t *)dataptr;
 80081c2:	687b      	ldr	r3, [r7, #4]
 80081c4:	61fb      	str	r3, [r7, #28]
  const u16_t *ps;
  u16_t t = 0;
 80081c6:	210e      	movs	r1, #14
 80081c8:	187b      	adds	r3, r7, r1
 80081ca:	2200      	movs	r2, #0
 80081cc:	801a      	strh	r2, [r3, #0]
  u32_t sum = 0;
 80081ce:	2300      	movs	r3, #0
 80081d0:	617b      	str	r3, [r7, #20]
  int odd = ((mem_ptr_t)pb & 1);
 80081d2:	69fb      	ldr	r3, [r7, #28]
 80081d4:	2201      	movs	r2, #1
 80081d6:	4013      	ands	r3, r2
 80081d8:	613b      	str	r3, [r7, #16]

  /* Get aligned to u16_t */
  if (odd && len > 0) {
 80081da:	693b      	ldr	r3, [r7, #16]
 80081dc:	2b00      	cmp	r3, #0
 80081de:	d00c      	beq.n	80081fa <lwip_standard_chksum+0x42>
 80081e0:	683b      	ldr	r3, [r7, #0]
 80081e2:	2b00      	cmp	r3, #0
 80081e4:	dd09      	ble.n	80081fa <lwip_standard_chksum+0x42>
    ((u8_t *)&t)[1] = *pb++;
 80081e6:	69fa      	ldr	r2, [r7, #28]
 80081e8:	1c53      	adds	r3, r2, #1
 80081ea:	61fb      	str	r3, [r7, #28]
 80081ec:	187b      	adds	r3, r7, r1
 80081ee:	3301      	adds	r3, #1
 80081f0:	7812      	ldrb	r2, [r2, #0]
 80081f2:	701a      	strb	r2, [r3, #0]
    len--;
 80081f4:	683b      	ldr	r3, [r7, #0]
 80081f6:	3b01      	subs	r3, #1
 80081f8:	603b      	str	r3, [r7, #0]
  }

  /* Add the bulk of the data */
  ps = (const u16_t *)(const void *)pb;
 80081fa:	69fb      	ldr	r3, [r7, #28]
 80081fc:	61bb      	str	r3, [r7, #24]
  while (len > 1) {
 80081fe:	e00a      	b.n	8008216 <lwip_standard_chksum+0x5e>
    sum += *ps++;
 8008200:	69bb      	ldr	r3, [r7, #24]
 8008202:	1c9a      	adds	r2, r3, #2
 8008204:	61ba      	str	r2, [r7, #24]
 8008206:	881b      	ldrh	r3, [r3, #0]
 8008208:	001a      	movs	r2, r3
 800820a:	697b      	ldr	r3, [r7, #20]
 800820c:	189b      	adds	r3, r3, r2
 800820e:	617b      	str	r3, [r7, #20]
    len -= 2;
 8008210:	683b      	ldr	r3, [r7, #0]
 8008212:	3b02      	subs	r3, #2
 8008214:	603b      	str	r3, [r7, #0]
  while (len > 1) {
 8008216:	683b      	ldr	r3, [r7, #0]
 8008218:	2b01      	cmp	r3, #1
 800821a:	dcf1      	bgt.n	8008200 <lwip_standard_chksum+0x48>
  }

  /* Consume left-over byte, if any */
  if (len > 0) {
 800821c:	683b      	ldr	r3, [r7, #0]
 800821e:	2b00      	cmp	r3, #0
 8008220:	dd04      	ble.n	800822c <lwip_standard_chksum+0x74>
    ((u8_t *)&t)[0] = *(const u8_t *)ps;
 8008222:	230e      	movs	r3, #14
 8008224:	18fb      	adds	r3, r7, r3
 8008226:	69ba      	ldr	r2, [r7, #24]
 8008228:	7812      	ldrb	r2, [r2, #0]
 800822a:	701a      	strb	r2, [r3, #0]
  }

  /* Add end bytes */
  sum += t;
 800822c:	230e      	movs	r3, #14
 800822e:	18fb      	adds	r3, r7, r3
 8008230:	881b      	ldrh	r3, [r3, #0]
 8008232:	001a      	movs	r2, r3
 8008234:	697b      	ldr	r3, [r7, #20]
 8008236:	189b      	adds	r3, r3, r2
 8008238:	617b      	str	r3, [r7, #20]

  /* Fold 32-bit sum to 16 bits
     calling this twice is probably faster than if statements... */
  sum = FOLD_U32T(sum);
 800823a:	697b      	ldr	r3, [r7, #20]
 800823c:	0c1a      	lsrs	r2, r3, #16
 800823e:	697b      	ldr	r3, [r7, #20]
 8008240:	041b      	lsls	r3, r3, #16
 8008242:	0c1b      	lsrs	r3, r3, #16
 8008244:	18d3      	adds	r3, r2, r3
 8008246:	617b      	str	r3, [r7, #20]
  sum = FOLD_U32T(sum);
 8008248:	697b      	ldr	r3, [r7, #20]
 800824a:	0c1a      	lsrs	r2, r3, #16
 800824c:	697b      	ldr	r3, [r7, #20]
 800824e:	041b      	lsls	r3, r3, #16
 8008250:	0c1b      	lsrs	r3, r3, #16
 8008252:	18d3      	adds	r3, r2, r3
 8008254:	617b      	str	r3, [r7, #20]

  /* Swap if alignment was odd */
  if (odd) {
 8008256:	693b      	ldr	r3, [r7, #16]
 8008258:	2b00      	cmp	r3, #0
 800825a:	d009      	beq.n	8008270 <lwip_standard_chksum+0xb8>
    sum = SWAP_BYTES_IN_WORD(sum);
 800825c:	697b      	ldr	r3, [r7, #20]
 800825e:	021b      	lsls	r3, r3, #8
 8008260:	041b      	lsls	r3, r3, #16
 8008262:	0c1a      	lsrs	r2, r3, #16
 8008264:	697b      	ldr	r3, [r7, #20]
 8008266:	0a1b      	lsrs	r3, r3, #8
 8008268:	21ff      	movs	r1, #255	; 0xff
 800826a:	400b      	ands	r3, r1
 800826c:	4313      	orrs	r3, r2
 800826e:	617b      	str	r3, [r7, #20]
  }

  return (u16_t)sum;
 8008270:	697b      	ldr	r3, [r7, #20]
 8008272:	b29b      	uxth	r3, r3
}
 8008274:	0018      	movs	r0, r3
 8008276:	46bd      	mov	sp, r7
 8008278:	b008      	add	sp, #32
 800827a:	bd80      	pop	{r7, pc}

0800827c <inet_cksum_pseudo_base>:
#endif

/** Parts of the pseudo checksum which are common to IPv4 and IPv6 */
static u16_t
inet_cksum_pseudo_base(struct pbuf *p, u8_t proto, u16_t proto_len, u32_t acc)
{
 800827c:	b580      	push	{r7, lr}
 800827e:	b086      	sub	sp, #24
 8008280:	af00      	add	r7, sp, #0
 8008282:	60f8      	str	r0, [r7, #12]
 8008284:	0008      	movs	r0, r1
 8008286:	0011      	movs	r1, r2
 8008288:	607b      	str	r3, [r7, #4]
 800828a:	230b      	movs	r3, #11
 800828c:	18fb      	adds	r3, r7, r3
 800828e:	1c02      	adds	r2, r0, #0
 8008290:	701a      	strb	r2, [r3, #0]
 8008292:	2308      	movs	r3, #8
 8008294:	18fb      	adds	r3, r7, r3
 8008296:	1c0a      	adds	r2, r1, #0
 8008298:	801a      	strh	r2, [r3, #0]
  struct pbuf *q;
  int swapped = 0;
 800829a:	2300      	movs	r3, #0
 800829c:	613b      	str	r3, [r7, #16]

  /* iterate through all pbuf in chain */
  for (q = p; q != NULL; q = q->next) {
 800829e:	68fb      	ldr	r3, [r7, #12]
 80082a0:	617b      	str	r3, [r7, #20]
 80082a2:	e02c      	b.n	80082fe <inet_cksum_pseudo_base+0x82>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
                             (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
 80082a4:	697b      	ldr	r3, [r7, #20]
 80082a6:	685a      	ldr	r2, [r3, #4]
 80082a8:	697b      	ldr	r3, [r7, #20]
 80082aa:	895b      	ldrh	r3, [r3, #10]
 80082ac:	0019      	movs	r1, r3
 80082ae:	0010      	movs	r0, r2
 80082b0:	f7ff ff82 	bl	80081b8 <lwip_standard_chksum>
 80082b4:	0003      	movs	r3, r0
 80082b6:	001a      	movs	r2, r3
 80082b8:	687b      	ldr	r3, [r7, #4]
 80082ba:	189b      	adds	r3, r3, r2
 80082bc:	607b      	str	r3, [r7, #4]
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
 80082be:	687b      	ldr	r3, [r7, #4]
 80082c0:	0c1a      	lsrs	r2, r3, #16
 80082c2:	687b      	ldr	r3, [r7, #4]
 80082c4:	041b      	lsls	r3, r3, #16
 80082c6:	0c1b      	lsrs	r3, r3, #16
 80082c8:	18d3      	adds	r3, r2, r3
 80082ca:	607b      	str	r3, [r7, #4]
    if (q->len % 2 != 0) {
 80082cc:	697b      	ldr	r3, [r7, #20]
 80082ce:	895b      	ldrh	r3, [r3, #10]
 80082d0:	2201      	movs	r2, #1
 80082d2:	4013      	ands	r3, r2
 80082d4:	b29b      	uxth	r3, r3
 80082d6:	2b00      	cmp	r3, #0
 80082d8:	d00e      	beq.n	80082f8 <inet_cksum_pseudo_base+0x7c>
      swapped = !swapped;
 80082da:	693b      	ldr	r3, [r7, #16]
 80082dc:	425a      	negs	r2, r3
 80082de:	4153      	adcs	r3, r2
 80082e0:	b2db      	uxtb	r3, r3
 80082e2:	613b      	str	r3, [r7, #16]
      acc = SWAP_BYTES_IN_WORD(acc);
 80082e4:	687b      	ldr	r3, [r7, #4]
 80082e6:	021b      	lsls	r3, r3, #8
 80082e8:	041b      	lsls	r3, r3, #16
 80082ea:	0c1a      	lsrs	r2, r3, #16
 80082ec:	687b      	ldr	r3, [r7, #4]
 80082ee:	0a1b      	lsrs	r3, r3, #8
 80082f0:	21ff      	movs	r1, #255	; 0xff
 80082f2:	400b      	ands	r3, r1
 80082f4:	4313      	orrs	r3, r2
 80082f6:	607b      	str	r3, [r7, #4]
  for (q = p; q != NULL; q = q->next) {
 80082f8:	697b      	ldr	r3, [r7, #20]
 80082fa:	681b      	ldr	r3, [r3, #0]
 80082fc:	617b      	str	r3, [r7, #20]
 80082fe:	697b      	ldr	r3, [r7, #20]
 8008300:	2b00      	cmp	r3, #0
 8008302:	d1cf      	bne.n	80082a4 <inet_cksum_pseudo_base+0x28>
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
 8008304:	693b      	ldr	r3, [r7, #16]
 8008306:	2b00      	cmp	r3, #0
 8008308:	d009      	beq.n	800831e <inet_cksum_pseudo_base+0xa2>
    acc = SWAP_BYTES_IN_WORD(acc);
 800830a:	687b      	ldr	r3, [r7, #4]
 800830c:	021b      	lsls	r3, r3, #8
 800830e:	041b      	lsls	r3, r3, #16
 8008310:	0c1a      	lsrs	r2, r3, #16
 8008312:	687b      	ldr	r3, [r7, #4]
 8008314:	0a1b      	lsrs	r3, r3, #8
 8008316:	21ff      	movs	r1, #255	; 0xff
 8008318:	400b      	ands	r3, r1
 800831a:	4313      	orrs	r3, r2
 800831c:	607b      	str	r3, [r7, #4]
  }

  acc += (u32_t)lwip_htons((u16_t)proto);
 800831e:	230b      	movs	r3, #11
 8008320:	18fb      	adds	r3, r7, r3
 8008322:	781b      	ldrb	r3, [r3, #0]
 8008324:	b29b      	uxth	r3, r3
 8008326:	0018      	movs	r0, r3
 8008328:	f7fe fde4 	bl	8006ef4 <lwip_htons>
 800832c:	0003      	movs	r3, r0
 800832e:	001a      	movs	r2, r3
 8008330:	687b      	ldr	r3, [r7, #4]
 8008332:	189b      	adds	r3, r3, r2
 8008334:	607b      	str	r3, [r7, #4]
  acc += (u32_t)lwip_htons(proto_len);
 8008336:	2308      	movs	r3, #8
 8008338:	18fb      	adds	r3, r7, r3
 800833a:	881b      	ldrh	r3, [r3, #0]
 800833c:	0018      	movs	r0, r3
 800833e:	f7fe fdd9 	bl	8006ef4 <lwip_htons>
 8008342:	0003      	movs	r3, r0
 8008344:	001a      	movs	r2, r3
 8008346:	687b      	ldr	r3, [r7, #4]
 8008348:	189b      	adds	r3, r3, r2
 800834a:	607b      	str	r3, [r7, #4]

  /* Fold 32-bit sum to 16 bits
     calling this twice is probably faster than if statements... */
  acc = FOLD_U32T(acc);
 800834c:	687b      	ldr	r3, [r7, #4]
 800834e:	0c1a      	lsrs	r2, r3, #16
 8008350:	687b      	ldr	r3, [r7, #4]
 8008352:	041b      	lsls	r3, r3, #16
 8008354:	0c1b      	lsrs	r3, r3, #16
 8008356:	18d3      	adds	r3, r2, r3
 8008358:	607b      	str	r3, [r7, #4]
  acc = FOLD_U32T(acc);
 800835a:	687b      	ldr	r3, [r7, #4]
 800835c:	0c1a      	lsrs	r2, r3, #16
 800835e:	687b      	ldr	r3, [r7, #4]
 8008360:	041b      	lsls	r3, r3, #16
 8008362:	0c1b      	lsrs	r3, r3, #16
 8008364:	18d3      	adds	r3, r2, r3
 8008366:	607b      	str	r3, [r7, #4]
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
 8008368:	687b      	ldr	r3, [r7, #4]
 800836a:	b29b      	uxth	r3, r3
 800836c:	43db      	mvns	r3, r3
 800836e:	b29b      	uxth	r3, r3
}
 8008370:	0018      	movs	r0, r3
 8008372:	46bd      	mov	sp, r7
 8008374:	b006      	add	sp, #24
 8008376:	bd80      	pop	{r7, pc}

08008378 <inet_chksum_pseudo>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pseudo(struct pbuf *p, u8_t proto, u16_t proto_len,
                   const ip4_addr_t *src, const ip4_addr_t *dest)
{
 8008378:	b5b0      	push	{r4, r5, r7, lr}
 800837a:	b086      	sub	sp, #24
 800837c:	af00      	add	r7, sp, #0
 800837e:	60f8      	str	r0, [r7, #12]
 8008380:	0008      	movs	r0, r1
 8008382:	0011      	movs	r1, r2
 8008384:	607b      	str	r3, [r7, #4]
 8008386:	250b      	movs	r5, #11
 8008388:	197b      	adds	r3, r7, r5
 800838a:	1c02      	adds	r2, r0, #0
 800838c:	701a      	strb	r2, [r3, #0]
 800838e:	2008      	movs	r0, #8
 8008390:	183b      	adds	r3, r7, r0
 8008392:	1c0a      	adds	r2, r1, #0
 8008394:	801a      	strh	r2, [r3, #0]
  u32_t acc;
  u32_t addr;

  addr = ip4_addr_get_u32(src);
 8008396:	687b      	ldr	r3, [r7, #4]
 8008398:	681b      	ldr	r3, [r3, #0]
 800839a:	617b      	str	r3, [r7, #20]
  acc = (addr & 0xffffUL);
 800839c:	697b      	ldr	r3, [r7, #20]
 800839e:	041b      	lsls	r3, r3, #16
 80083a0:	0c1b      	lsrs	r3, r3, #16
 80083a2:	613b      	str	r3, [r7, #16]
  acc = (u32_t)(acc + ((addr >> 16) & 0xffffUL));
 80083a4:	697b      	ldr	r3, [r7, #20]
 80083a6:	0c1b      	lsrs	r3, r3, #16
 80083a8:	693a      	ldr	r2, [r7, #16]
 80083aa:	18d3      	adds	r3, r2, r3
 80083ac:	613b      	str	r3, [r7, #16]
  addr = ip4_addr_get_u32(dest);
 80083ae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80083b0:	681b      	ldr	r3, [r3, #0]
 80083b2:	617b      	str	r3, [r7, #20]
  acc = (u32_t)(acc + (addr & 0xffffUL));
 80083b4:	697b      	ldr	r3, [r7, #20]
 80083b6:	041b      	lsls	r3, r3, #16
 80083b8:	0c1b      	lsrs	r3, r3, #16
 80083ba:	693a      	ldr	r2, [r7, #16]
 80083bc:	18d3      	adds	r3, r2, r3
 80083be:	613b      	str	r3, [r7, #16]
  acc = (u32_t)(acc + ((addr >> 16) & 0xffffUL));
 80083c0:	697b      	ldr	r3, [r7, #20]
 80083c2:	0c1b      	lsrs	r3, r3, #16
 80083c4:	693a      	ldr	r2, [r7, #16]
 80083c6:	18d3      	adds	r3, r2, r3
 80083c8:	613b      	str	r3, [r7, #16]
  /* fold down to 16 bits */
  acc = FOLD_U32T(acc);
 80083ca:	693b      	ldr	r3, [r7, #16]
 80083cc:	0c1a      	lsrs	r2, r3, #16
 80083ce:	693b      	ldr	r3, [r7, #16]
 80083d0:	041b      	lsls	r3, r3, #16
 80083d2:	0c1b      	lsrs	r3, r3, #16
 80083d4:	18d3      	adds	r3, r2, r3
 80083d6:	613b      	str	r3, [r7, #16]
  acc = FOLD_U32T(acc);
 80083d8:	693b      	ldr	r3, [r7, #16]
 80083da:	0c1a      	lsrs	r2, r3, #16
 80083dc:	693b      	ldr	r3, [r7, #16]
 80083de:	041b      	lsls	r3, r3, #16
 80083e0:	0c1b      	lsrs	r3, r3, #16
 80083e2:	18d3      	adds	r3, r2, r3
 80083e4:	613b      	str	r3, [r7, #16]

  return inet_cksum_pseudo_base(p, proto, proto_len, acc);
 80083e6:	693c      	ldr	r4, [r7, #16]
 80083e8:	183b      	adds	r3, r7, r0
 80083ea:	881a      	ldrh	r2, [r3, #0]
 80083ec:	197b      	adds	r3, r7, r5
 80083ee:	7819      	ldrb	r1, [r3, #0]
 80083f0:	68f8      	ldr	r0, [r7, #12]
 80083f2:	0023      	movs	r3, r4
 80083f4:	f7ff ff42 	bl	800827c <inet_cksum_pseudo_base>
 80083f8:	0003      	movs	r3, r0
}
 80083fa:	0018      	movs	r0, r3
 80083fc:	46bd      	mov	sp, r7
 80083fe:	b006      	add	sp, #24
 8008400:	bdb0      	pop	{r4, r5, r7, pc}

08008402 <ip_chksum_pseudo>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
ip_chksum_pseudo(struct pbuf *p, u8_t proto, u16_t proto_len,
                 const ip_addr_t *src, const ip_addr_t *dest)
{
 8008402:	b5b0      	push	{r4, r5, r7, lr}
 8008404:	b086      	sub	sp, #24
 8008406:	af02      	add	r7, sp, #8
 8008408:	60f8      	str	r0, [r7, #12]
 800840a:	0008      	movs	r0, r1
 800840c:	0011      	movs	r1, r2
 800840e:	607b      	str	r3, [r7, #4]
 8008410:	250b      	movs	r5, #11
 8008412:	197b      	adds	r3, r7, r5
 8008414:	1c02      	adds	r2, r0, #0
 8008416:	701a      	strb	r2, [r3, #0]
 8008418:	2008      	movs	r0, #8
 800841a:	183b      	adds	r3, r7, r0
 800841c:	1c0a      	adds	r2, r1, #0
 800841e:	801a      	strh	r2, [r3, #0]
#if LWIP_IPV4 && LWIP_IPV6
  else
#endif /* LWIP_IPV4 && LWIP_IPV6 */
#if LWIP_IPV4
  {
    return inet_chksum_pseudo(p, proto, proto_len, ip_2_ip4(src), ip_2_ip4(dest));
 8008420:	687c      	ldr	r4, [r7, #4]
 8008422:	183b      	adds	r3, r7, r0
 8008424:	881a      	ldrh	r2, [r3, #0]
 8008426:	197b      	adds	r3, r7, r5
 8008428:	7819      	ldrb	r1, [r3, #0]
 800842a:	68f8      	ldr	r0, [r7, #12]
 800842c:	6a3b      	ldr	r3, [r7, #32]
 800842e:	9300      	str	r3, [sp, #0]
 8008430:	0023      	movs	r3, r4
 8008432:	f7ff ffa1 	bl	8008378 <inet_chksum_pseudo>
 8008436:	0003      	movs	r3, r0
  }
#endif /* LWIP_IPV4 */
}
 8008438:	0018      	movs	r0, r3
 800843a:	46bd      	mov	sp, r7
 800843c:	b004      	add	sp, #16
 800843e:	bdb0      	pop	{r4, r5, r7, pc}

08008440 <inet_cksum_pseudo_partial_base>:

/** Parts of the pseudo checksum which are common to IPv4 and IPv6 */
static u16_t
inet_cksum_pseudo_partial_base(struct pbuf *p, u8_t proto, u16_t proto_len,
                               u16_t chksum_len, u32_t acc)
{
 8008440:	b590      	push	{r4, r7, lr}
 8008442:	b089      	sub	sp, #36	; 0x24
 8008444:	af00      	add	r7, sp, #0
 8008446:	60f8      	str	r0, [r7, #12]
 8008448:	000c      	movs	r4, r1
 800844a:	0010      	movs	r0, r2
 800844c:	0019      	movs	r1, r3
 800844e:	230b      	movs	r3, #11
 8008450:	18fb      	adds	r3, r7, r3
 8008452:	1c22      	adds	r2, r4, #0
 8008454:	701a      	strb	r2, [r3, #0]
 8008456:	2308      	movs	r3, #8
 8008458:	18fb      	adds	r3, r7, r3
 800845a:	1c02      	adds	r2, r0, #0
 800845c:	801a      	strh	r2, [r3, #0]
 800845e:	1dbb      	adds	r3, r7, #6
 8008460:	1c0a      	adds	r2, r1, #0
 8008462:	801a      	strh	r2, [r3, #0]
  struct pbuf *q;
  int swapped = 0;
 8008464:	2300      	movs	r3, #0
 8008466:	61bb      	str	r3, [r7, #24]
  u16_t chklen;

  /* iterate through all pbuf in chain */
  for (q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
 8008468:	68fb      	ldr	r3, [r7, #12]
 800846a:	61fb      	str	r3, [r7, #28]
 800846c:	e04f      	b.n	800850e <inet_cksum_pseudo_partial_base+0xce>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
                             (void *)q, (void *)q->next));
    chklen = q->len;
 800846e:	2116      	movs	r1, #22
 8008470:	187b      	adds	r3, r7, r1
 8008472:	69fa      	ldr	r2, [r7, #28]
 8008474:	8952      	ldrh	r2, [r2, #10]
 8008476:	801a      	strh	r2, [r3, #0]
    if (chklen > chksum_len) {
 8008478:	187a      	adds	r2, r7, r1
 800847a:	1dbb      	adds	r3, r7, #6
 800847c:	8812      	ldrh	r2, [r2, #0]
 800847e:	881b      	ldrh	r3, [r3, #0]
 8008480:	429a      	cmp	r2, r3
 8008482:	d903      	bls.n	800848c <inet_cksum_pseudo_partial_base+0x4c>
      chklen = chksum_len;
 8008484:	187b      	adds	r3, r7, r1
 8008486:	1dba      	adds	r2, r7, #6
 8008488:	8812      	ldrh	r2, [r2, #0]
 800848a:	801a      	strh	r2, [r3, #0]
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
 800848c:	69fb      	ldr	r3, [r7, #28]
 800848e:	685a      	ldr	r2, [r3, #4]
 8008490:	2416      	movs	r4, #22
 8008492:	193b      	adds	r3, r7, r4
 8008494:	881b      	ldrh	r3, [r3, #0]
 8008496:	0019      	movs	r1, r3
 8008498:	0010      	movs	r0, r2
 800849a:	f7ff fe8d 	bl	80081b8 <lwip_standard_chksum>
 800849e:	0003      	movs	r3, r0
 80084a0:	001a      	movs	r2, r3
 80084a2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80084a4:	189b      	adds	r3, r3, r2
 80084a6:	633b      	str	r3, [r7, #48]	; 0x30
    chksum_len = (u16_t)(chksum_len - chklen);
 80084a8:	1dbb      	adds	r3, r7, #6
 80084aa:	1db9      	adds	r1, r7, #6
 80084ac:	193a      	adds	r2, r7, r4
 80084ae:	8809      	ldrh	r1, [r1, #0]
 80084b0:	8812      	ldrh	r2, [r2, #0]
 80084b2:	1a8a      	subs	r2, r1, r2
 80084b4:	801a      	strh	r2, [r3, #0]
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
 80084b6:	1dbb      	adds	r3, r7, #6
 80084b8:	881b      	ldrh	r3, [r3, #0]
 80084ba:	4a35      	ldr	r2, [pc, #212]	; (8008590 <inet_cksum_pseudo_partial_base+0x150>)
 80084bc:	4293      	cmp	r3, r2
 80084be:	d906      	bls.n	80084ce <inet_cksum_pseudo_partial_base+0x8e>
 80084c0:	4b34      	ldr	r3, [pc, #208]	; (8008594 <inet_cksum_pseudo_partial_base+0x154>)
 80084c2:	22d0      	movs	r2, #208	; 0xd0
 80084c4:	0052      	lsls	r2, r2, #1
 80084c6:	4934      	ldr	r1, [pc, #208]	; (8008598 <inet_cksum_pseudo_partial_base+0x158>)
 80084c8:	4834      	ldr	r0, [pc, #208]	; (800859c <inet_cksum_pseudo_partial_base+0x15c>)
 80084ca:	f7fa fb7d 	bl	8002bc8 <app_debug_rtt_raw>
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
 80084ce:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80084d0:	0c1a      	lsrs	r2, r3, #16
 80084d2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80084d4:	041b      	lsls	r3, r3, #16
 80084d6:	0c1b      	lsrs	r3, r3, #16
 80084d8:	18d3      	adds	r3, r2, r3
 80084da:	633b      	str	r3, [r7, #48]	; 0x30
    if (q->len % 2 != 0) {
 80084dc:	69fb      	ldr	r3, [r7, #28]
 80084de:	895b      	ldrh	r3, [r3, #10]
 80084e0:	2201      	movs	r2, #1
 80084e2:	4013      	ands	r3, r2
 80084e4:	b29b      	uxth	r3, r3
 80084e6:	2b00      	cmp	r3, #0
 80084e8:	d00e      	beq.n	8008508 <inet_cksum_pseudo_partial_base+0xc8>
      swapped = !swapped;
 80084ea:	69bb      	ldr	r3, [r7, #24]
 80084ec:	425a      	negs	r2, r3
 80084ee:	4153      	adcs	r3, r2
 80084f0:	b2db      	uxtb	r3, r3
 80084f2:	61bb      	str	r3, [r7, #24]
      acc = SWAP_BYTES_IN_WORD(acc);
 80084f4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80084f6:	021b      	lsls	r3, r3, #8
 80084f8:	041b      	lsls	r3, r3, #16
 80084fa:	0c1a      	lsrs	r2, r3, #16
 80084fc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80084fe:	0a1b      	lsrs	r3, r3, #8
 8008500:	21ff      	movs	r1, #255	; 0xff
 8008502:	400b      	ands	r3, r1
 8008504:	4313      	orrs	r3, r2
 8008506:	633b      	str	r3, [r7, #48]	; 0x30
  for (q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
 8008508:	69fb      	ldr	r3, [r7, #28]
 800850a:	681b      	ldr	r3, [r3, #0]
 800850c:	61fb      	str	r3, [r7, #28]
 800850e:	69fb      	ldr	r3, [r7, #28]
 8008510:	2b00      	cmp	r3, #0
 8008512:	d003      	beq.n	800851c <inet_cksum_pseudo_partial_base+0xdc>
 8008514:	1dbb      	adds	r3, r7, #6
 8008516:	881b      	ldrh	r3, [r3, #0]
 8008518:	2b00      	cmp	r3, #0
 800851a:	d1a8      	bne.n	800846e <inet_cksum_pseudo_partial_base+0x2e>
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
 800851c:	69bb      	ldr	r3, [r7, #24]
 800851e:	2b00      	cmp	r3, #0
 8008520:	d009      	beq.n	8008536 <inet_cksum_pseudo_partial_base+0xf6>
    acc = SWAP_BYTES_IN_WORD(acc);
 8008522:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008524:	021b      	lsls	r3, r3, #8
 8008526:	041b      	lsls	r3, r3, #16
 8008528:	0c1a      	lsrs	r2, r3, #16
 800852a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800852c:	0a1b      	lsrs	r3, r3, #8
 800852e:	21ff      	movs	r1, #255	; 0xff
 8008530:	400b      	ands	r3, r1
 8008532:	4313      	orrs	r3, r2
 8008534:	633b      	str	r3, [r7, #48]	; 0x30
  }

  acc += (u32_t)lwip_htons((u16_t)proto);
 8008536:	230b      	movs	r3, #11
 8008538:	18fb      	adds	r3, r7, r3
 800853a:	781b      	ldrb	r3, [r3, #0]
 800853c:	b29b      	uxth	r3, r3
 800853e:	0018      	movs	r0, r3
 8008540:	f7fe fcd8 	bl	8006ef4 <lwip_htons>
 8008544:	0003      	movs	r3, r0
 8008546:	001a      	movs	r2, r3
 8008548:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800854a:	189b      	adds	r3, r3, r2
 800854c:	633b      	str	r3, [r7, #48]	; 0x30
  acc += (u32_t)lwip_htons(proto_len);
 800854e:	2308      	movs	r3, #8
 8008550:	18fb      	adds	r3, r7, r3
 8008552:	881b      	ldrh	r3, [r3, #0]
 8008554:	0018      	movs	r0, r3
 8008556:	f7fe fccd 	bl	8006ef4 <lwip_htons>
 800855a:	0003      	movs	r3, r0
 800855c:	001a      	movs	r2, r3
 800855e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008560:	189b      	adds	r3, r3, r2
 8008562:	633b      	str	r3, [r7, #48]	; 0x30

  /* Fold 32-bit sum to 16 bits
     calling this twice is probably faster than if statements... */
  acc = FOLD_U32T(acc);
 8008564:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008566:	0c1a      	lsrs	r2, r3, #16
 8008568:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800856a:	041b      	lsls	r3, r3, #16
 800856c:	0c1b      	lsrs	r3, r3, #16
 800856e:	18d3      	adds	r3, r2, r3
 8008570:	633b      	str	r3, [r7, #48]	; 0x30
  acc = FOLD_U32T(acc);
 8008572:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008574:	0c1a      	lsrs	r2, r3, #16
 8008576:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008578:	041b      	lsls	r3, r3, #16
 800857a:	0c1b      	lsrs	r3, r3, #16
 800857c:	18d3      	adds	r3, r2, r3
 800857e:	633b      	str	r3, [r7, #48]	; 0x30
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
 8008580:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008582:	b29b      	uxth	r3, r3
 8008584:	43db      	mvns	r3, r3
 8008586:	b29b      	uxth	r3, r3
}
 8008588:	0018      	movs	r0, r3
 800858a:	46bd      	mov	sp, r7
 800858c:	b009      	add	sp, #36	; 0x24
 800858e:	bd90      	pop	{r4, r7, pc}
 8008590:	00007ffe 	.word	0x00007ffe
 8008594:	0801f2a4 	.word	0x0801f2a4
 8008598:	0801f2d4 	.word	0x0801f2d4
 800859c:	0801f2e0 	.word	0x0801f2e0

080085a0 <inet_chksum_pseudo_partial>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p, u8_t proto, u16_t proto_len,
                           u16_t chksum_len, const ip4_addr_t *src, const ip4_addr_t *dest)
{
 80085a0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80085a2:	b089      	sub	sp, #36	; 0x24
 80085a4:	af02      	add	r7, sp, #8
 80085a6:	60f8      	str	r0, [r7, #12]
 80085a8:	000c      	movs	r4, r1
 80085aa:	0010      	movs	r0, r2
 80085ac:	0019      	movs	r1, r3
 80085ae:	250b      	movs	r5, #11
 80085b0:	197b      	adds	r3, r7, r5
 80085b2:	1c22      	adds	r2, r4, #0
 80085b4:	701a      	strb	r2, [r3, #0]
 80085b6:	2608      	movs	r6, #8
 80085b8:	19bb      	adds	r3, r7, r6
 80085ba:	1c02      	adds	r2, r0, #0
 80085bc:	801a      	strh	r2, [r3, #0]
 80085be:	1dbb      	adds	r3, r7, #6
 80085c0:	1c0a      	adds	r2, r1, #0
 80085c2:	801a      	strh	r2, [r3, #0]
  u32_t acc;
  u32_t addr;

  addr = ip4_addr_get_u32(src);
 80085c4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80085c6:	681b      	ldr	r3, [r3, #0]
 80085c8:	617b      	str	r3, [r7, #20]
  acc = (addr & 0xffffUL);
 80085ca:	697b      	ldr	r3, [r7, #20]
 80085cc:	041b      	lsls	r3, r3, #16
 80085ce:	0c1b      	lsrs	r3, r3, #16
 80085d0:	613b      	str	r3, [r7, #16]
  acc = (u32_t)(acc + ((addr >> 16) & 0xffffUL));
 80085d2:	697b      	ldr	r3, [r7, #20]
 80085d4:	0c1b      	lsrs	r3, r3, #16
 80085d6:	693a      	ldr	r2, [r7, #16]
 80085d8:	18d3      	adds	r3, r2, r3
 80085da:	613b      	str	r3, [r7, #16]
  addr = ip4_addr_get_u32(dest);
 80085dc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80085de:	681b      	ldr	r3, [r3, #0]
 80085e0:	617b      	str	r3, [r7, #20]
  acc = (u32_t)(acc + (addr & 0xffffUL));
 80085e2:	697b      	ldr	r3, [r7, #20]
 80085e4:	041b      	lsls	r3, r3, #16
 80085e6:	0c1b      	lsrs	r3, r3, #16
 80085e8:	693a      	ldr	r2, [r7, #16]
 80085ea:	18d3      	adds	r3, r2, r3
 80085ec:	613b      	str	r3, [r7, #16]
  acc = (u32_t)(acc + ((addr >> 16) & 0xffffUL));
 80085ee:	697b      	ldr	r3, [r7, #20]
 80085f0:	0c1b      	lsrs	r3, r3, #16
 80085f2:	693a      	ldr	r2, [r7, #16]
 80085f4:	18d3      	adds	r3, r2, r3
 80085f6:	613b      	str	r3, [r7, #16]
  /* fold down to 16 bits */
  acc = FOLD_U32T(acc);
 80085f8:	693b      	ldr	r3, [r7, #16]
 80085fa:	0c1a      	lsrs	r2, r3, #16
 80085fc:	693b      	ldr	r3, [r7, #16]
 80085fe:	041b      	lsls	r3, r3, #16
 8008600:	0c1b      	lsrs	r3, r3, #16
 8008602:	18d3      	adds	r3, r2, r3
 8008604:	613b      	str	r3, [r7, #16]
  acc = FOLD_U32T(acc);
 8008606:	693b      	ldr	r3, [r7, #16]
 8008608:	0c1a      	lsrs	r2, r3, #16
 800860a:	693b      	ldr	r3, [r7, #16]
 800860c:	041b      	lsls	r3, r3, #16
 800860e:	0c1b      	lsrs	r3, r3, #16
 8008610:	18d3      	adds	r3, r2, r3
 8008612:	613b      	str	r3, [r7, #16]

  return inet_cksum_pseudo_partial_base(p, proto, proto_len, chksum_len, acc);
 8008614:	1dbb      	adds	r3, r7, #6
 8008616:	881c      	ldrh	r4, [r3, #0]
 8008618:	19bb      	adds	r3, r7, r6
 800861a:	881a      	ldrh	r2, [r3, #0]
 800861c:	197b      	adds	r3, r7, r5
 800861e:	7819      	ldrb	r1, [r3, #0]
 8008620:	68f8      	ldr	r0, [r7, #12]
 8008622:	693b      	ldr	r3, [r7, #16]
 8008624:	9300      	str	r3, [sp, #0]
 8008626:	0023      	movs	r3, r4
 8008628:	f7ff ff0a 	bl	8008440 <inet_cksum_pseudo_partial_base>
 800862c:	0003      	movs	r3, r0
}
 800862e:	0018      	movs	r0, r3
 8008630:	46bd      	mov	sp, r7
 8008632:	b007      	add	sp, #28
 8008634:	bdf0      	pop	{r4, r5, r6, r7, pc}

08008636 <ip_chksum_pseudo_partial>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
ip_chksum_pseudo_partial(struct pbuf *p, u8_t proto, u16_t proto_len,
                         u16_t chksum_len, const ip_addr_t *src, const ip_addr_t *dest)
{
 8008636:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008638:	b087      	sub	sp, #28
 800863a:	af02      	add	r7, sp, #8
 800863c:	60f8      	str	r0, [r7, #12]
 800863e:	000c      	movs	r4, r1
 8008640:	0010      	movs	r0, r2
 8008642:	0019      	movs	r1, r3
 8008644:	250b      	movs	r5, #11
 8008646:	197b      	adds	r3, r7, r5
 8008648:	1c22      	adds	r2, r4, #0
 800864a:	701a      	strb	r2, [r3, #0]
 800864c:	2608      	movs	r6, #8
 800864e:	19bb      	adds	r3, r7, r6
 8008650:	1c02      	adds	r2, r0, #0
 8008652:	801a      	strh	r2, [r3, #0]
 8008654:	1dbb      	adds	r3, r7, #6
 8008656:	1c0a      	adds	r2, r1, #0
 8008658:	801a      	strh	r2, [r3, #0]
#if LWIP_IPV4 && LWIP_IPV6
  else
#endif /* LWIP_IPV4 && LWIP_IPV6 */
#if LWIP_IPV4
  {
    return inet_chksum_pseudo_partial(p, proto, proto_len, chksum_len, ip_2_ip4(src), ip_2_ip4(dest));
 800865a:	1dbb      	adds	r3, r7, #6
 800865c:	881c      	ldrh	r4, [r3, #0]
 800865e:	19bb      	adds	r3, r7, r6
 8008660:	881a      	ldrh	r2, [r3, #0]
 8008662:	197b      	adds	r3, r7, r5
 8008664:	7819      	ldrb	r1, [r3, #0]
 8008666:	68f8      	ldr	r0, [r7, #12]
 8008668:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800866a:	9301      	str	r3, [sp, #4]
 800866c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800866e:	9300      	str	r3, [sp, #0]
 8008670:	0023      	movs	r3, r4
 8008672:	f7ff ff95 	bl	80085a0 <inet_chksum_pseudo_partial>
 8008676:	0003      	movs	r3, r0
  }
#endif /* LWIP_IPV4 */
}
 8008678:	0018      	movs	r0, r3
 800867a:	46bd      	mov	sp, r7
 800867c:	b005      	add	sp, #20
 800867e:	bdf0      	pop	{r4, r5, r6, r7, pc}

08008680 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(const void *dataptr, u16_t len)
{
 8008680:	b580      	push	{r7, lr}
 8008682:	b082      	sub	sp, #8
 8008684:	af00      	add	r7, sp, #0
 8008686:	6078      	str	r0, [r7, #4]
 8008688:	000a      	movs	r2, r1
 800868a:	1cbb      	adds	r3, r7, #2
 800868c:	801a      	strh	r2, [r3, #0]
  return (u16_t)~(unsigned int)LWIP_CHKSUM(dataptr, len);
 800868e:	1cbb      	adds	r3, r7, #2
 8008690:	881a      	ldrh	r2, [r3, #0]
 8008692:	687b      	ldr	r3, [r7, #4]
 8008694:	0011      	movs	r1, r2
 8008696:	0018      	movs	r0, r3
 8008698:	f7ff fd8e 	bl	80081b8 <lwip_standard_chksum>
 800869c:	0003      	movs	r3, r0
 800869e:	43db      	mvns	r3, r3
 80086a0:	b29b      	uxth	r3, r3
}
 80086a2:	0018      	movs	r0, r3
 80086a4:	46bd      	mov	sp, r7
 80086a6:	b002      	add	sp, #8
 80086a8:	bd80      	pop	{r7, pc}

080086aa <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
 80086aa:	b580      	push	{r7, lr}
 80086ac:	b086      	sub	sp, #24
 80086ae:	af00      	add	r7, sp, #0
 80086b0:	6078      	str	r0, [r7, #4]
  u32_t acc;
  struct pbuf *q;
  int swapped = 0;
 80086b2:	2300      	movs	r3, #0
 80086b4:	60fb      	str	r3, [r7, #12]

  acc = 0;
 80086b6:	2300      	movs	r3, #0
 80086b8:	617b      	str	r3, [r7, #20]
  for (q = p; q != NULL; q = q->next) {
 80086ba:	687b      	ldr	r3, [r7, #4]
 80086bc:	613b      	str	r3, [r7, #16]
 80086be:	e02c      	b.n	800871a <inet_chksum_pbuf+0x70>
    acc += LWIP_CHKSUM(q->payload, q->len);
 80086c0:	693b      	ldr	r3, [r7, #16]
 80086c2:	685a      	ldr	r2, [r3, #4]
 80086c4:	693b      	ldr	r3, [r7, #16]
 80086c6:	895b      	ldrh	r3, [r3, #10]
 80086c8:	0019      	movs	r1, r3
 80086ca:	0010      	movs	r0, r2
 80086cc:	f7ff fd74 	bl	80081b8 <lwip_standard_chksum>
 80086d0:	0003      	movs	r3, r0
 80086d2:	001a      	movs	r2, r3
 80086d4:	697b      	ldr	r3, [r7, #20]
 80086d6:	189b      	adds	r3, r3, r2
 80086d8:	617b      	str	r3, [r7, #20]
    acc = FOLD_U32T(acc);
 80086da:	697b      	ldr	r3, [r7, #20]
 80086dc:	0c1a      	lsrs	r2, r3, #16
 80086de:	697b      	ldr	r3, [r7, #20]
 80086e0:	041b      	lsls	r3, r3, #16
 80086e2:	0c1b      	lsrs	r3, r3, #16
 80086e4:	18d3      	adds	r3, r2, r3
 80086e6:	617b      	str	r3, [r7, #20]
    if (q->len % 2 != 0) {
 80086e8:	693b      	ldr	r3, [r7, #16]
 80086ea:	895b      	ldrh	r3, [r3, #10]
 80086ec:	2201      	movs	r2, #1
 80086ee:	4013      	ands	r3, r2
 80086f0:	b29b      	uxth	r3, r3
 80086f2:	2b00      	cmp	r3, #0
 80086f4:	d00e      	beq.n	8008714 <inet_chksum_pbuf+0x6a>
      swapped = !swapped;
 80086f6:	68fb      	ldr	r3, [r7, #12]
 80086f8:	425a      	negs	r2, r3
 80086fa:	4153      	adcs	r3, r2
 80086fc:	b2db      	uxtb	r3, r3
 80086fe:	60fb      	str	r3, [r7, #12]
      acc = SWAP_BYTES_IN_WORD(acc);
 8008700:	697b      	ldr	r3, [r7, #20]
 8008702:	021b      	lsls	r3, r3, #8
 8008704:	041b      	lsls	r3, r3, #16
 8008706:	0c1a      	lsrs	r2, r3, #16
 8008708:	697b      	ldr	r3, [r7, #20]
 800870a:	0a1b      	lsrs	r3, r3, #8
 800870c:	21ff      	movs	r1, #255	; 0xff
 800870e:	400b      	ands	r3, r1
 8008710:	4313      	orrs	r3, r2
 8008712:	617b      	str	r3, [r7, #20]
  for (q = p; q != NULL; q = q->next) {
 8008714:	693b      	ldr	r3, [r7, #16]
 8008716:	681b      	ldr	r3, [r3, #0]
 8008718:	613b      	str	r3, [r7, #16]
 800871a:	693b      	ldr	r3, [r7, #16]
 800871c:	2b00      	cmp	r3, #0
 800871e:	d1cf      	bne.n	80086c0 <inet_chksum_pbuf+0x16>
    }
  }

  if (swapped) {
 8008720:	68fb      	ldr	r3, [r7, #12]
 8008722:	2b00      	cmp	r3, #0
 8008724:	d009      	beq.n	800873a <inet_chksum_pbuf+0x90>
    acc = SWAP_BYTES_IN_WORD(acc);
 8008726:	697b      	ldr	r3, [r7, #20]
 8008728:	021b      	lsls	r3, r3, #8
 800872a:	041b      	lsls	r3, r3, #16
 800872c:	0c1a      	lsrs	r2, r3, #16
 800872e:	697b      	ldr	r3, [r7, #20]
 8008730:	0a1b      	lsrs	r3, r3, #8
 8008732:	21ff      	movs	r1, #255	; 0xff
 8008734:	400b      	ands	r3, r1
 8008736:	4313      	orrs	r3, r2
 8008738:	617b      	str	r3, [r7, #20]
  }
  return (u16_t)~(acc & 0xffffUL);
 800873a:	697b      	ldr	r3, [r7, #20]
 800873c:	b29b      	uxth	r3, r3
 800873e:	43db      	mvns	r3, r3
 8008740:	b29b      	uxth	r3, r3
}
 8008742:	0018      	movs	r0, r3
 8008744:	46bd      	mov	sp, r7
 8008746:	b006      	add	sp, #24
 8008748:	bd80      	pop	{r7, pc}

0800874a <lwip_chksum_copy>:
 * For architectures with big caches, data might still be in cache when
 * generating the checksum after copying.
 */
u16_t
lwip_chksum_copy(void *dst, const void *src, u16_t len)
{
 800874a:	b580      	push	{r7, lr}
 800874c:	b084      	sub	sp, #16
 800874e:	af00      	add	r7, sp, #0
 8008750:	60f8      	str	r0, [r7, #12]
 8008752:	60b9      	str	r1, [r7, #8]
 8008754:	1dbb      	adds	r3, r7, #6
 8008756:	801a      	strh	r2, [r3, #0]
  MEMCPY(dst, src, len);
 8008758:	1dbb      	adds	r3, r7, #6
 800875a:	881a      	ldrh	r2, [r3, #0]
 800875c:	68b9      	ldr	r1, [r7, #8]
 800875e:	68fb      	ldr	r3, [r7, #12]
 8008760:	0018      	movs	r0, r3
 8008762:	f014 fbb3 	bl	801cecc <memcpy>
  return LWIP_CHKSUM(dst, len);
 8008766:	1dbb      	adds	r3, r7, #6
 8008768:	881a      	ldrh	r2, [r3, #0]
 800876a:	68fb      	ldr	r3, [r7, #12]
 800876c:	0011      	movs	r1, r2
 800876e:	0018      	movs	r0, r3
 8008770:	f7ff fd22 	bl	80081b8 <lwip_standard_chksum>
 8008774:	0003      	movs	r3, r0
}
 8008776:	0018      	movs	r0, r3
 8008778:	46bd      	mov	sp, r7
 800877a:	b004      	add	sp, #16
 800877c:	bd80      	pop	{r7, pc}
	...

08008780 <ptr_to_mem>:
#define mem_overflow_check_element(mem)
#endif /* MEM_OVERFLOW_CHECK */

static struct mem *
ptr_to_mem(mem_size_t ptr)
{
 8008780:	b580      	push	{r7, lr}
 8008782:	b082      	sub	sp, #8
 8008784:	af00      	add	r7, sp, #0
 8008786:	0002      	movs	r2, r0
 8008788:	1dbb      	adds	r3, r7, #6
 800878a:	801a      	strh	r2, [r3, #0]
  return (struct mem *)(void *)&ram[ptr];
 800878c:	4b04      	ldr	r3, [pc, #16]	; (80087a0 <ptr_to_mem+0x20>)
 800878e:	681a      	ldr	r2, [r3, #0]
 8008790:	1dbb      	adds	r3, r7, #6
 8008792:	881b      	ldrh	r3, [r3, #0]
 8008794:	18d3      	adds	r3, r2, r3
}
 8008796:	0018      	movs	r0, r3
 8008798:	46bd      	mov	sp, r7
 800879a:	b002      	add	sp, #8
 800879c:	bd80      	pop	{r7, pc}
 800879e:	46c0      	nop			; (mov r8, r8)
 80087a0:	20001768 	.word	0x20001768

080087a4 <mem_to_ptr>:

static mem_size_t
mem_to_ptr(void *mem)
{
 80087a4:	b580      	push	{r7, lr}
 80087a6:	b082      	sub	sp, #8
 80087a8:	af00      	add	r7, sp, #0
 80087aa:	6078      	str	r0, [r7, #4]
  return (mem_size_t)((u8_t *)mem - ram);
 80087ac:	4b04      	ldr	r3, [pc, #16]	; (80087c0 <mem_to_ptr+0x1c>)
 80087ae:	681b      	ldr	r3, [r3, #0]
 80087b0:	687a      	ldr	r2, [r7, #4]
 80087b2:	1ad3      	subs	r3, r2, r3
 80087b4:	b29b      	uxth	r3, r3
}
 80087b6:	0018      	movs	r0, r3
 80087b8:	46bd      	mov	sp, r7
 80087ba:	b002      	add	sp, #8
 80087bc:	bd80      	pop	{r7, pc}
 80087be:	46c0      	nop			; (mov r8, r8)
 80087c0:	20001768 	.word	0x20001768

080087c4 <plug_holes>:
 * This assumes access to the heap is protected by the calling function
 * already.
 */
static void
plug_holes(struct mem *mem)
{
 80087c4:	b590      	push	{r4, r7, lr}
 80087c6:	b085      	sub	sp, #20
 80087c8:	af00      	add	r7, sp, #0
 80087ca:	6078      	str	r0, [r7, #4]
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
 80087cc:	4b49      	ldr	r3, [pc, #292]	; (80088f4 <plug_holes+0x130>)
 80087ce:	681b      	ldr	r3, [r3, #0]
 80087d0:	687a      	ldr	r2, [r7, #4]
 80087d2:	429a      	cmp	r2, r3
 80087d4:	d206      	bcs.n	80087e4 <plug_holes+0x20>
 80087d6:	4b48      	ldr	r3, [pc, #288]	; (80088f8 <plug_holes+0x134>)
 80087d8:	22e0      	movs	r2, #224	; 0xe0
 80087da:	32ff      	adds	r2, #255	; 0xff
 80087dc:	4947      	ldr	r1, [pc, #284]	; (80088fc <plug_holes+0x138>)
 80087de:	4848      	ldr	r0, [pc, #288]	; (8008900 <plug_holes+0x13c>)
 80087e0:	f7fa f9f2 	bl	8002bc8 <app_debug_rtt_raw>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
 80087e4:	4b47      	ldr	r3, [pc, #284]	; (8008904 <plug_holes+0x140>)
 80087e6:	681b      	ldr	r3, [r3, #0]
 80087e8:	687a      	ldr	r2, [r7, #4]
 80087ea:	429a      	cmp	r2, r3
 80087ec:	d306      	bcc.n	80087fc <plug_holes+0x38>
 80087ee:	4b42      	ldr	r3, [pc, #264]	; (80088f8 <plug_holes+0x134>)
 80087f0:	22f0      	movs	r2, #240	; 0xf0
 80087f2:	0052      	lsls	r2, r2, #1
 80087f4:	4944      	ldr	r1, [pc, #272]	; (8008908 <plug_holes+0x144>)
 80087f6:	4842      	ldr	r0, [pc, #264]	; (8008900 <plug_holes+0x13c>)
 80087f8:	f7fa f9e6 	bl	8002bc8 <app_debug_rtt_raw>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
 80087fc:	687b      	ldr	r3, [r7, #4]
 80087fe:	791b      	ldrb	r3, [r3, #4]
 8008800:	2b00      	cmp	r3, #0
 8008802:	d006      	beq.n	8008812 <plug_holes+0x4e>
 8008804:	4b3c      	ldr	r3, [pc, #240]	; (80088f8 <plug_holes+0x134>)
 8008806:	22e2      	movs	r2, #226	; 0xe2
 8008808:	32ff      	adds	r2, #255	; 0xff
 800880a:	4940      	ldr	r1, [pc, #256]	; (800890c <plug_holes+0x148>)
 800880c:	483c      	ldr	r0, [pc, #240]	; (8008900 <plug_holes+0x13c>)
 800880e:	f7fa f9db 	bl	8002bc8 <app_debug_rtt_raw>

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
 8008812:	687b      	ldr	r3, [r7, #4]
 8008814:	881a      	ldrh	r2, [r3, #0]
 8008816:	2380      	movs	r3, #128	; 0x80
 8008818:	00db      	lsls	r3, r3, #3
 800881a:	429a      	cmp	r2, r3
 800881c:	d906      	bls.n	800882c <plug_holes+0x68>
 800881e:	4b36      	ldr	r3, [pc, #216]	; (80088f8 <plug_holes+0x134>)
 8008820:	22f2      	movs	r2, #242	; 0xf2
 8008822:	0052      	lsls	r2, r2, #1
 8008824:	493a      	ldr	r1, [pc, #232]	; (8008910 <plug_holes+0x14c>)
 8008826:	4836      	ldr	r0, [pc, #216]	; (8008900 <plug_holes+0x13c>)
 8008828:	f7fa f9ce 	bl	8002bc8 <app_debug_rtt_raw>

  nmem = ptr_to_mem(mem->next);
 800882c:	687b      	ldr	r3, [r7, #4]
 800882e:	881b      	ldrh	r3, [r3, #0]
 8008830:	0018      	movs	r0, r3
 8008832:	f7ff ffa5 	bl	8008780 <ptr_to_mem>
 8008836:	0003      	movs	r3, r0
 8008838:	60fb      	str	r3, [r7, #12]
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
 800883a:	687a      	ldr	r2, [r7, #4]
 800883c:	68fb      	ldr	r3, [r7, #12]
 800883e:	429a      	cmp	r2, r3
 8008840:	d026      	beq.n	8008890 <plug_holes+0xcc>
 8008842:	68fb      	ldr	r3, [r7, #12]
 8008844:	791b      	ldrb	r3, [r3, #4]
 8008846:	2b00      	cmp	r3, #0
 8008848:	d122      	bne.n	8008890 <plug_holes+0xcc>
 800884a:	4b2e      	ldr	r3, [pc, #184]	; (8008904 <plug_holes+0x140>)
 800884c:	681b      	ldr	r3, [r3, #0]
 800884e:	68fa      	ldr	r2, [r7, #12]
 8008850:	429a      	cmp	r2, r3
 8008852:	d01d      	beq.n	8008890 <plug_holes+0xcc>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
 8008854:	4b2f      	ldr	r3, [pc, #188]	; (8008914 <plug_holes+0x150>)
 8008856:	681b      	ldr	r3, [r3, #0]
 8008858:	68fa      	ldr	r2, [r7, #12]
 800885a:	429a      	cmp	r2, r3
 800885c:	d102      	bne.n	8008864 <plug_holes+0xa0>
      lfree = mem;
 800885e:	4b2d      	ldr	r3, [pc, #180]	; (8008914 <plug_holes+0x150>)
 8008860:	687a      	ldr	r2, [r7, #4]
 8008862:	601a      	str	r2, [r3, #0]
    }
    mem->next = nmem->next;
 8008864:	68fb      	ldr	r3, [r7, #12]
 8008866:	881a      	ldrh	r2, [r3, #0]
 8008868:	687b      	ldr	r3, [r7, #4]
 800886a:	801a      	strh	r2, [r3, #0]
    if (nmem->next != MEM_SIZE_ALIGNED) {
 800886c:	68fb      	ldr	r3, [r7, #12]
 800886e:	881a      	ldrh	r2, [r3, #0]
 8008870:	2380      	movs	r3, #128	; 0x80
 8008872:	00db      	lsls	r3, r3, #3
 8008874:	429a      	cmp	r2, r3
 8008876:	d00b      	beq.n	8008890 <plug_holes+0xcc>
      ptr_to_mem(nmem->next)->prev = mem_to_ptr(mem);
 8008878:	68fb      	ldr	r3, [r7, #12]
 800887a:	881b      	ldrh	r3, [r3, #0]
 800887c:	0018      	movs	r0, r3
 800887e:	f7ff ff7f 	bl	8008780 <ptr_to_mem>
 8008882:	0004      	movs	r4, r0
 8008884:	687b      	ldr	r3, [r7, #4]
 8008886:	0018      	movs	r0, r3
 8008888:	f7ff ff8c 	bl	80087a4 <mem_to_ptr>
 800888c:	0003      	movs	r3, r0
 800888e:	8063      	strh	r3, [r4, #2]
    }
  }

  /* plug hole backward */
  pmem = ptr_to_mem(mem->prev);
 8008890:	687b      	ldr	r3, [r7, #4]
 8008892:	885b      	ldrh	r3, [r3, #2]
 8008894:	0018      	movs	r0, r3
 8008896:	f7ff ff73 	bl	8008780 <ptr_to_mem>
 800889a:	0003      	movs	r3, r0
 800889c:	60bb      	str	r3, [r7, #8]
  if (pmem != mem && pmem->used == 0) {
 800889e:	68ba      	ldr	r2, [r7, #8]
 80088a0:	687b      	ldr	r3, [r7, #4]
 80088a2:	429a      	cmp	r2, r3
 80088a4:	d021      	beq.n	80088ea <plug_holes+0x126>
 80088a6:	68bb      	ldr	r3, [r7, #8]
 80088a8:	791b      	ldrb	r3, [r3, #4]
 80088aa:	2b00      	cmp	r3, #0
 80088ac:	d11d      	bne.n	80088ea <plug_holes+0x126>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
 80088ae:	4b19      	ldr	r3, [pc, #100]	; (8008914 <plug_holes+0x150>)
 80088b0:	681b      	ldr	r3, [r3, #0]
 80088b2:	687a      	ldr	r2, [r7, #4]
 80088b4:	429a      	cmp	r2, r3
 80088b6:	d102      	bne.n	80088be <plug_holes+0xfa>
      lfree = pmem;
 80088b8:	4b16      	ldr	r3, [pc, #88]	; (8008914 <plug_holes+0x150>)
 80088ba:	68ba      	ldr	r2, [r7, #8]
 80088bc:	601a      	str	r2, [r3, #0]
    }
    pmem->next = mem->next;
 80088be:	687b      	ldr	r3, [r7, #4]
 80088c0:	881a      	ldrh	r2, [r3, #0]
 80088c2:	68bb      	ldr	r3, [r7, #8]
 80088c4:	801a      	strh	r2, [r3, #0]
    if (mem->next != MEM_SIZE_ALIGNED) {
 80088c6:	687b      	ldr	r3, [r7, #4]
 80088c8:	881a      	ldrh	r2, [r3, #0]
 80088ca:	2380      	movs	r3, #128	; 0x80
 80088cc:	00db      	lsls	r3, r3, #3
 80088ce:	429a      	cmp	r2, r3
 80088d0:	d00b      	beq.n	80088ea <plug_holes+0x126>
      ptr_to_mem(mem->next)->prev = mem_to_ptr(pmem);
 80088d2:	687b      	ldr	r3, [r7, #4]
 80088d4:	881b      	ldrh	r3, [r3, #0]
 80088d6:	0018      	movs	r0, r3
 80088d8:	f7ff ff52 	bl	8008780 <ptr_to_mem>
 80088dc:	0004      	movs	r4, r0
 80088de:	68bb      	ldr	r3, [r7, #8]
 80088e0:	0018      	movs	r0, r3
 80088e2:	f7ff ff5f 	bl	80087a4 <mem_to_ptr>
 80088e6:	0003      	movs	r3, r0
 80088e8:	8063      	strh	r3, [r4, #2]
    }
  }
}
 80088ea:	46c0      	nop			; (mov r8, r8)
 80088ec:	46bd      	mov	sp, r7
 80088ee:	b005      	add	sp, #20
 80088f0:	bd90      	pop	{r4, r7, pc}
 80088f2:	46c0      	nop			; (mov r8, r8)
 80088f4:	20001768 	.word	0x20001768
 80088f8:	0801f30c 	.word	0x0801f30c
 80088fc:	0801f334 	.word	0x0801f334
 8008900:	0801f34c 	.word	0x0801f34c
 8008904:	2000176c 	.word	0x2000176c
 8008908:	0801f378 	.word	0x0801f378
 800890c:	0801f394 	.word	0x0801f394
 8008910:	0801f3b0 	.word	0x0801f3b0
 8008914:	20001770 	.word	0x20001770

08008918 <mem_link_valid>:
/* Check if a struct mem is correctly linked.
 * If not, double-free is a possible reason.
 */
static int
mem_link_valid(struct mem *mem)
{
 8008918:	b5b0      	push	{r4, r5, r7, lr}
 800891a:	b086      	sub	sp, #24
 800891c:	af00      	add	r7, sp, #0
 800891e:	6078      	str	r0, [r7, #4]
  struct mem *nmem, *pmem;
  mem_size_t rmem_idx;
  rmem_idx = mem_to_ptr(mem);
 8008920:	2516      	movs	r5, #22
 8008922:	197c      	adds	r4, r7, r5
 8008924:	687b      	ldr	r3, [r7, #4]
 8008926:	0018      	movs	r0, r3
 8008928:	f7ff ff3c 	bl	80087a4 <mem_to_ptr>
 800892c:	0003      	movs	r3, r0
 800892e:	8023      	strh	r3, [r4, #0]
  nmem = ptr_to_mem(mem->next);
 8008930:	687b      	ldr	r3, [r7, #4]
 8008932:	881b      	ldrh	r3, [r3, #0]
 8008934:	0018      	movs	r0, r3
 8008936:	f7ff ff23 	bl	8008780 <ptr_to_mem>
 800893a:	0003      	movs	r3, r0
 800893c:	613b      	str	r3, [r7, #16]
  pmem = ptr_to_mem(mem->prev);
 800893e:	687b      	ldr	r3, [r7, #4]
 8008940:	885b      	ldrh	r3, [r3, #2]
 8008942:	0018      	movs	r0, r3
 8008944:	f7ff ff1c 	bl	8008780 <ptr_to_mem>
 8008948:	0003      	movs	r3, r0
 800894a:	60fb      	str	r3, [r7, #12]
  if ((mem->next > MEM_SIZE_ALIGNED) || (mem->prev > MEM_SIZE_ALIGNED) ||
 800894c:	687b      	ldr	r3, [r7, #4]
 800894e:	881a      	ldrh	r2, [r3, #0]
 8008950:	2380      	movs	r3, #128	; 0x80
 8008952:	00db      	lsls	r3, r3, #3
 8008954:	429a      	cmp	r2, r3
 8008956:	d81d      	bhi.n	8008994 <mem_link_valid+0x7c>
 8008958:	687b      	ldr	r3, [r7, #4]
 800895a:	885a      	ldrh	r2, [r3, #2]
 800895c:	2380      	movs	r3, #128	; 0x80
 800895e:	00db      	lsls	r3, r3, #3
 8008960:	429a      	cmp	r2, r3
 8008962:	d817      	bhi.n	8008994 <mem_link_valid+0x7c>
      ((mem->prev != rmem_idx) && (pmem->next != rmem_idx)) ||
 8008964:	687b      	ldr	r3, [r7, #4]
 8008966:	885b      	ldrh	r3, [r3, #2]
  if ((mem->next > MEM_SIZE_ALIGNED) || (mem->prev > MEM_SIZE_ALIGNED) ||
 8008968:	197a      	adds	r2, r7, r5
 800896a:	8812      	ldrh	r2, [r2, #0]
 800896c:	429a      	cmp	r2, r3
 800896e:	d005      	beq.n	800897c <mem_link_valid+0x64>
      ((mem->prev != rmem_idx) && (pmem->next != rmem_idx)) ||
 8008970:	68fb      	ldr	r3, [r7, #12]
 8008972:	881b      	ldrh	r3, [r3, #0]
 8008974:	197a      	adds	r2, r7, r5
 8008976:	8812      	ldrh	r2, [r2, #0]
 8008978:	429a      	cmp	r2, r3
 800897a:	d10b      	bne.n	8008994 <mem_link_valid+0x7c>
      ((nmem != ram_end) && (nmem->prev != rmem_idx))) {
 800897c:	4b09      	ldr	r3, [pc, #36]	; (80089a4 <mem_link_valid+0x8c>)
 800897e:	681b      	ldr	r3, [r3, #0]
      ((mem->prev != rmem_idx) && (pmem->next != rmem_idx)) ||
 8008980:	693a      	ldr	r2, [r7, #16]
 8008982:	429a      	cmp	r2, r3
 8008984:	d008      	beq.n	8008998 <mem_link_valid+0x80>
      ((nmem != ram_end) && (nmem->prev != rmem_idx))) {
 8008986:	693b      	ldr	r3, [r7, #16]
 8008988:	885b      	ldrh	r3, [r3, #2]
 800898a:	2216      	movs	r2, #22
 800898c:	18ba      	adds	r2, r7, r2
 800898e:	8812      	ldrh	r2, [r2, #0]
 8008990:	429a      	cmp	r2, r3
 8008992:	d001      	beq.n	8008998 <mem_link_valid+0x80>
    return 0;
 8008994:	2300      	movs	r3, #0
 8008996:	e000      	b.n	800899a <mem_link_valid+0x82>
  }
  return 1;
 8008998:	2301      	movs	r3, #1
}
 800899a:	0018      	movs	r0, r3
 800899c:	46bd      	mov	sp, r7
 800899e:	b006      	add	sp, #24
 80089a0:	bdb0      	pop	{r4, r5, r7, pc}
 80089a2:	46c0      	nop			; (mov r8, r8)
 80089a4:	2000176c 	.word	0x2000176c

080089a8 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
 80089a8:	b580      	push	{r7, lr}
 80089aa:	b084      	sub	sp, #16
 80089ac:	af00      	add	r7, sp, #0
 80089ae:	6078      	str	r0, [r7, #4]
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
 80089b0:	687b      	ldr	r3, [r7, #4]
 80089b2:	2b00      	cmp	r3, #0
 80089b4:	d049      	beq.n	8008a4a <mem_free+0xa2>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  if ((((mem_ptr_t)rmem) & (MEM_ALIGNMENT - 1)) != 0) {
 80089b6:	687b      	ldr	r3, [r7, #4]
 80089b8:	2203      	movs	r2, #3
 80089ba:	4013      	ands	r3, r2
 80089bc:	d006      	beq.n	80089cc <mem_free+0x24>
    LWIP_MEM_ILLEGAL_FREE("mem_free: sanity check alignment");
 80089be:	4b25      	ldr	r3, [pc, #148]	; (8008a54 <mem_free+0xac>)
 80089c0:	4a25      	ldr	r2, [pc, #148]	; (8008a58 <mem_free+0xb0>)
 80089c2:	4926      	ldr	r1, [pc, #152]	; (8008a5c <mem_free+0xb4>)
 80089c4:	4826      	ldr	r0, [pc, #152]	; (8008a60 <mem_free+0xb8>)
 80089c6:	f7fa f8ff 	bl	8002bc8 <app_debug_rtt_raw>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: sanity check alignment\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
    return;
 80089ca:	e03f      	b.n	8008a4c <mem_free+0xa4>
  }

  /* Get the corresponding struct mem: */
  /* cast through void* to get rid of alignment warnings */
  mem = (struct mem *)(void *)((u8_t *)rmem - (SIZEOF_STRUCT_MEM + MEM_SANITY_OFFSET));
 80089cc:	687b      	ldr	r3, [r7, #4]
 80089ce:	3b08      	subs	r3, #8
 80089d0:	60fb      	str	r3, [r7, #12]

  if ((u8_t *)mem < ram || (u8_t *)rmem + MIN_SIZE_ALIGNED > (u8_t *)ram_end) {
 80089d2:	4b24      	ldr	r3, [pc, #144]	; (8008a64 <mem_free+0xbc>)
 80089d4:	681b      	ldr	r3, [r3, #0]
 80089d6:	68fa      	ldr	r2, [r7, #12]
 80089d8:	429a      	cmp	r2, r3
 80089da:	d306      	bcc.n	80089ea <mem_free+0x42>
 80089dc:	687b      	ldr	r3, [r7, #4]
 80089de:	330c      	adds	r3, #12
 80089e0:	001a      	movs	r2, r3
 80089e2:	4b21      	ldr	r3, [pc, #132]	; (8008a68 <mem_free+0xc0>)
 80089e4:	681b      	ldr	r3, [r3, #0]
 80089e6:	429a      	cmp	r2, r3
 80089e8:	d906      	bls.n	80089f8 <mem_free+0x50>
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory");
 80089ea:	4b1a      	ldr	r3, [pc, #104]	; (8008a54 <mem_free+0xac>)
 80089ec:	4a1f      	ldr	r2, [pc, #124]	; (8008a6c <mem_free+0xc4>)
 80089ee:	4920      	ldr	r1, [pc, #128]	; (8008a70 <mem_free+0xc8>)
 80089f0:	481b      	ldr	r0, [pc, #108]	; (8008a60 <mem_free+0xb8>)
 80089f2:	f7fa f8e9 	bl	8002bc8 <app_debug_rtt_raw>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
    return;
 80089f6:	e029      	b.n	8008a4c <mem_free+0xa4>
  mem_overflow_check_element(mem);
#endif
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* mem has to be in a used state */
  if (!mem->used) {
 80089f8:	68fb      	ldr	r3, [r7, #12]
 80089fa:	791b      	ldrb	r3, [r3, #4]
 80089fc:	2b00      	cmp	r3, #0
 80089fe:	d107      	bne.n	8008a10 <mem_free+0x68>
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory: double free");
 8008a00:	4b14      	ldr	r3, [pc, #80]	; (8008a54 <mem_free+0xac>)
 8008a02:	22a3      	movs	r2, #163	; 0xa3
 8008a04:	0092      	lsls	r2, r2, #2
 8008a06:	491b      	ldr	r1, [pc, #108]	; (8008a74 <mem_free+0xcc>)
 8008a08:	4815      	ldr	r0, [pc, #84]	; (8008a60 <mem_free+0xb8>)
 8008a0a:	f7fa f8dd 	bl	8002bc8 <app_debug_rtt_raw>
    LWIP_MEM_FREE_UNPROTECT();
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory: double free?\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
    return;
 8008a0e:	e01d      	b.n	8008a4c <mem_free+0xa4>
  }

  if (!mem_link_valid(mem)) {
 8008a10:	68fb      	ldr	r3, [r7, #12]
 8008a12:	0018      	movs	r0, r3
 8008a14:	f7ff ff80 	bl	8008918 <mem_link_valid>
 8008a18:	1e03      	subs	r3, r0, #0
 8008a1a:	d106      	bne.n	8008a2a <mem_free+0x82>
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory: non-linked: double free");
 8008a1c:	4b0d      	ldr	r3, [pc, #52]	; (8008a54 <mem_free+0xac>)
 8008a1e:	4a16      	ldr	r2, [pc, #88]	; (8008a78 <mem_free+0xd0>)
 8008a20:	4916      	ldr	r1, [pc, #88]	; (8008a7c <mem_free+0xd4>)
 8008a22:	480f      	ldr	r0, [pc, #60]	; (8008a60 <mem_free+0xb8>)
 8008a24:	f7fa f8d0 	bl	8002bc8 <app_debug_rtt_raw>
    LWIP_MEM_FREE_UNPROTECT();
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory: non-linked: double free?\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
    return;
 8008a28:	e010      	b.n	8008a4c <mem_free+0xa4>
  }

  /* mem is now unused. */
  mem->used = 0;
 8008a2a:	68fb      	ldr	r3, [r7, #12]
 8008a2c:	2200      	movs	r2, #0
 8008a2e:	711a      	strb	r2, [r3, #4]

  if (mem < lfree) {
 8008a30:	4b13      	ldr	r3, [pc, #76]	; (8008a80 <mem_free+0xd8>)
 8008a32:	681b      	ldr	r3, [r3, #0]
 8008a34:	68fa      	ldr	r2, [r7, #12]
 8008a36:	429a      	cmp	r2, r3
 8008a38:	d202      	bcs.n	8008a40 <mem_free+0x98>
    /* the newly freed struct is now the lowest */
    lfree = mem;
 8008a3a:	4b11      	ldr	r3, [pc, #68]	; (8008a80 <mem_free+0xd8>)
 8008a3c:	68fa      	ldr	r2, [r7, #12]
 8008a3e:	601a      	str	r2, [r3, #0]
  }

  MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));

  /* finally, see if prev or next are free also */
  plug_holes(mem);
 8008a40:	68fb      	ldr	r3, [r7, #12]
 8008a42:	0018      	movs	r0, r3
 8008a44:	f7ff febe 	bl	80087c4 <plug_holes>
 8008a48:	e000      	b.n	8008a4c <mem_free+0xa4>
    return;
 8008a4a:	46c0      	nop			; (mov r8, r8)
  MEM_SANITY();
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
 8008a4c:	46bd      	mov	sp, r7
 8008a4e:	b004      	add	sp, #16
 8008a50:	bd80      	pop	{r7, pc}
 8008a52:	46c0      	nop			; (mov r8, r8)
 8008a54:	0801f30c 	.word	0x0801f30c
 8008a58:	00000273 	.word	0x00000273
 8008a5c:	0801f3dc 	.word	0x0801f3dc
 8008a60:	0801f34c 	.word	0x0801f34c
 8008a64:	20001768 	.word	0x20001768
 8008a68:	2000176c 	.word	0x2000176c
 8008a6c:	0000027f 	.word	0x0000027f
 8008a70:	0801f400 	.word	0x0801f400
 8008a74:	0801f41c 	.word	0x0801f41c
 8008a78:	00000295 	.word	0x00000295
 8008a7c:	0801f444 	.word	0x0801f444
 8008a80:	20001770 	.word	0x20001770

08008a84 <mem_trim>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_trim(void *rmem, mem_size_t new_size)
{
 8008a84:	b5b0      	push	{r4, r5, r7, lr}
 8008a86:	b088      	sub	sp, #32
 8008a88:	af00      	add	r7, sp, #0
 8008a8a:	6078      	str	r0, [r7, #4]
 8008a8c:	000a      	movs	r2, r1
 8008a8e:	1cbb      	adds	r3, r7, #2
 8008a90:	801a      	strh	r2, [r3, #0]
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = (mem_size_t)LWIP_MEM_ALIGN_SIZE(new_size);
 8008a92:	1cbb      	adds	r3, r7, #2
 8008a94:	881b      	ldrh	r3, [r3, #0]
 8008a96:	3303      	adds	r3, #3
 8008a98:	b29a      	uxth	r2, r3
 8008a9a:	201e      	movs	r0, #30
 8008a9c:	183b      	adds	r3, r7, r0
 8008a9e:	2103      	movs	r1, #3
 8008aa0:	438a      	bics	r2, r1
 8008aa2:	801a      	strh	r2, [r3, #0]
  if (newsize < MIN_SIZE_ALIGNED) {
 8008aa4:	183b      	adds	r3, r7, r0
 8008aa6:	881b      	ldrh	r3, [r3, #0]
 8008aa8:	2b0b      	cmp	r3, #11
 8008aaa:	d802      	bhi.n	8008ab2 <mem_trim+0x2e>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
 8008aac:	183b      	adds	r3, r7, r0
 8008aae:	220c      	movs	r2, #12
 8008ab0:	801a      	strh	r2, [r3, #0]
  }
#if MEM_OVERFLOW_CHECK
  newsize += MEM_SANITY_REGION_BEFORE_ALIGNED + MEM_SANITY_REGION_AFTER_ALIGNED;
#endif
  if ((newsize > MEM_SIZE_ALIGNED) || (newsize < new_size)) {
 8008ab2:	211e      	movs	r1, #30
 8008ab4:	187b      	adds	r3, r7, r1
 8008ab6:	881a      	ldrh	r2, [r3, #0]
 8008ab8:	2380      	movs	r3, #128	; 0x80
 8008aba:	00db      	lsls	r3, r3, #3
 8008abc:	429a      	cmp	r2, r3
 8008abe:	d805      	bhi.n	8008acc <mem_trim+0x48>
 8008ac0:	187a      	adds	r2, r7, r1
 8008ac2:	1cbb      	adds	r3, r7, #2
 8008ac4:	8812      	ldrh	r2, [r2, #0]
 8008ac6:	881b      	ldrh	r3, [r3, #0]
 8008ac8:	429a      	cmp	r2, r3
 8008aca:	d201      	bcs.n	8008ad0 <mem_trim+0x4c>
    return NULL;
 8008acc:	2300      	movs	r3, #0
 8008ace:	e102      	b.n	8008cd6 <mem_trim+0x252>
  }

  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 8008ad0:	4b83      	ldr	r3, [pc, #524]	; (8008ce0 <mem_trim+0x25c>)
 8008ad2:	681b      	ldr	r3, [r3, #0]
 8008ad4:	687a      	ldr	r2, [r7, #4]
 8008ad6:	429a      	cmp	r2, r3
 8008ad8:	d304      	bcc.n	8008ae4 <mem_trim+0x60>
 8008ada:	4b82      	ldr	r3, [pc, #520]	; (8008ce4 <mem_trim+0x260>)
 8008adc:	681b      	ldr	r3, [r3, #0]
 8008ade:	687a      	ldr	r2, [r7, #4]
 8008ae0:	429a      	cmp	r2, r3
 8008ae2:	d305      	bcc.n	8008af0 <mem_trim+0x6c>
 8008ae4:	4b80      	ldr	r3, [pc, #512]	; (8008ce8 <mem_trim+0x264>)
 8008ae6:	4a81      	ldr	r2, [pc, #516]	; (8008cec <mem_trim+0x268>)
 8008ae8:	4981      	ldr	r1, [pc, #516]	; (8008cf0 <mem_trim+0x26c>)
 8008aea:	4882      	ldr	r0, [pc, #520]	; (8008cf4 <mem_trim+0x270>)
 8008aec:	f7fa f86c 	bl	8002bc8 <app_debug_rtt_raw>
              (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 8008af0:	4b7b      	ldr	r3, [pc, #492]	; (8008ce0 <mem_trim+0x25c>)
 8008af2:	681b      	ldr	r3, [r3, #0]
 8008af4:	687a      	ldr	r2, [r7, #4]
 8008af6:	429a      	cmp	r2, r3
 8008af8:	d304      	bcc.n	8008b04 <mem_trim+0x80>
 8008afa:	4b7a      	ldr	r3, [pc, #488]	; (8008ce4 <mem_trim+0x260>)
 8008afc:	681b      	ldr	r3, [r3, #0]
 8008afe:	687a      	ldr	r2, [r7, #4]
 8008b00:	429a      	cmp	r2, r3
 8008b02:	d301      	bcc.n	8008b08 <mem_trim+0x84>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_trim: illegal memory\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
    return rmem;
 8008b04:	687b      	ldr	r3, [r7, #4]
 8008b06:	e0e6      	b.n	8008cd6 <mem_trim+0x252>
  }
  /* Get the corresponding struct mem ... */
  /* cast through void* to get rid of alignment warnings */
  mem = (struct mem *)(void *)((u8_t *)rmem - (SIZEOF_STRUCT_MEM + MEM_SANITY_OFFSET));
 8008b08:	687b      	ldr	r3, [r7, #4]
 8008b0a:	3b08      	subs	r3, #8
 8008b0c:	61bb      	str	r3, [r7, #24]
#if MEM_OVERFLOW_CHECK
  mem_overflow_check_element(mem);
#endif
  /* ... and its offset pointer */
  ptr = mem_to_ptr(mem);
 8008b0e:	2516      	movs	r5, #22
 8008b10:	197c      	adds	r4, r7, r5
 8008b12:	69bb      	ldr	r3, [r7, #24]
 8008b14:	0018      	movs	r0, r3
 8008b16:	f7ff fe45 	bl	80087a4 <mem_to_ptr>
 8008b1a:	0003      	movs	r3, r0
 8008b1c:	8023      	strh	r3, [r4, #0]

  size = (mem_size_t)((mem_size_t)(mem->next - ptr) - (SIZEOF_STRUCT_MEM + MEM_SANITY_OVERHEAD));
 8008b1e:	69bb      	ldr	r3, [r7, #24]
 8008b20:	881a      	ldrh	r2, [r3, #0]
 8008b22:	197b      	adds	r3, r7, r5
 8008b24:	881b      	ldrh	r3, [r3, #0]
 8008b26:	1ad3      	subs	r3, r2, r3
 8008b28:	b29a      	uxth	r2, r3
 8008b2a:	2114      	movs	r1, #20
 8008b2c:	187b      	adds	r3, r7, r1
 8008b2e:	3a08      	subs	r2, #8
 8008b30:	801a      	strh	r2, [r3, #0]
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
 8008b32:	231e      	movs	r3, #30
 8008b34:	18fa      	adds	r2, r7, r3
 8008b36:	187b      	adds	r3, r7, r1
 8008b38:	8812      	ldrh	r2, [r2, #0]
 8008b3a:	881b      	ldrh	r3, [r3, #0]
 8008b3c:	429a      	cmp	r2, r3
 8008b3e:	d906      	bls.n	8008b4e <mem_trim+0xca>
 8008b40:	4b69      	ldr	r3, [pc, #420]	; (8008ce8 <mem_trim+0x264>)
 8008b42:	22b9      	movs	r2, #185	; 0xb9
 8008b44:	0092      	lsls	r2, r2, #2
 8008b46:	496c      	ldr	r1, [pc, #432]	; (8008cf8 <mem_trim+0x274>)
 8008b48:	486a      	ldr	r0, [pc, #424]	; (8008cf4 <mem_trim+0x270>)
 8008b4a:	f7fa f83d 	bl	8002bc8 <app_debug_rtt_raw>
  if (newsize > size) {
 8008b4e:	231e      	movs	r3, #30
 8008b50:	18fa      	adds	r2, r7, r3
 8008b52:	2314      	movs	r3, #20
 8008b54:	18fb      	adds	r3, r7, r3
 8008b56:	8812      	ldrh	r2, [r2, #0]
 8008b58:	881b      	ldrh	r3, [r3, #0]
 8008b5a:	429a      	cmp	r2, r3
 8008b5c:	d901      	bls.n	8008b62 <mem_trim+0xde>
    /* not supported */
    return NULL;
 8008b5e:	2300      	movs	r3, #0
 8008b60:	e0b9      	b.n	8008cd6 <mem_trim+0x252>
  }
  if (newsize == size) {
 8008b62:	231e      	movs	r3, #30
 8008b64:	18fa      	adds	r2, r7, r3
 8008b66:	2314      	movs	r3, #20
 8008b68:	18fb      	adds	r3, r7, r3
 8008b6a:	8812      	ldrh	r2, [r2, #0]
 8008b6c:	881b      	ldrh	r3, [r3, #0]
 8008b6e:	429a      	cmp	r2, r3
 8008b70:	d101      	bne.n	8008b76 <mem_trim+0xf2>
    /* No change in size, simply return */
    return rmem;
 8008b72:	687b      	ldr	r3, [r7, #4]
 8008b74:	e0af      	b.n	8008cd6 <mem_trim+0x252>
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();

  mem2 = ptr_to_mem(mem->next);
 8008b76:	69bb      	ldr	r3, [r7, #24]
 8008b78:	881b      	ldrh	r3, [r3, #0]
 8008b7a:	0018      	movs	r0, r3
 8008b7c:	f7ff fe00 	bl	8008780 <ptr_to_mem>
 8008b80:	0003      	movs	r3, r0
 8008b82:	613b      	str	r3, [r7, #16]
  if (mem2->used == 0) {
 8008b84:	693b      	ldr	r3, [r7, #16]
 8008b86:	791b      	ldrb	r3, [r3, #4]
 8008b88:	2b00      	cmp	r3, #0
 8008b8a:	d152      	bne.n	8008c32 <mem_trim+0x1ae>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    LWIP_ASSERT("invalid next ptr", mem->next != MEM_SIZE_ALIGNED);
 8008b8c:	69bb      	ldr	r3, [r7, #24]
 8008b8e:	881a      	ldrh	r2, [r3, #0]
 8008b90:	2380      	movs	r3, #128	; 0x80
 8008b92:	00db      	lsls	r3, r3, #3
 8008b94:	429a      	cmp	r2, r3
 8008b96:	d105      	bne.n	8008ba4 <mem_trim+0x120>
 8008b98:	4b53      	ldr	r3, [pc, #332]	; (8008ce8 <mem_trim+0x264>)
 8008b9a:	4a58      	ldr	r2, [pc, #352]	; (8008cfc <mem_trim+0x278>)
 8008b9c:	4958      	ldr	r1, [pc, #352]	; (8008d00 <mem_trim+0x27c>)
 8008b9e:	4855      	ldr	r0, [pc, #340]	; (8008cf4 <mem_trim+0x270>)
 8008ba0:	f7fa f812 	bl	8002bc8 <app_debug_rtt_raw>
    /* remember the old next pointer */
    next = mem2->next;
 8008ba4:	230c      	movs	r3, #12
 8008ba6:	18fb      	adds	r3, r7, r3
 8008ba8:	693a      	ldr	r2, [r7, #16]
 8008baa:	8812      	ldrh	r2, [r2, #0]
 8008bac:	801a      	strh	r2, [r3, #0]
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + newsize);
 8008bae:	2316      	movs	r3, #22
 8008bb0:	18fa      	adds	r2, r7, r3
 8008bb2:	231e      	movs	r3, #30
 8008bb4:	18fb      	adds	r3, r7, r3
 8008bb6:	8812      	ldrh	r2, [r2, #0]
 8008bb8:	881b      	ldrh	r3, [r3, #0]
 8008bba:	18d3      	adds	r3, r2, r3
 8008bbc:	b29a      	uxth	r2, r3
 8008bbe:	210e      	movs	r1, #14
 8008bc0:	187b      	adds	r3, r7, r1
 8008bc2:	3208      	adds	r2, #8
 8008bc4:	801a      	strh	r2, [r3, #0]
    if (lfree == mem2) {
 8008bc6:	4b4f      	ldr	r3, [pc, #316]	; (8008d04 <mem_trim+0x280>)
 8008bc8:	681b      	ldr	r3, [r3, #0]
 8008bca:	693a      	ldr	r2, [r7, #16]
 8008bcc:	429a      	cmp	r2, r3
 8008bce:	d107      	bne.n	8008be0 <mem_trim+0x15c>
      lfree = ptr_to_mem(ptr2);
 8008bd0:	187b      	adds	r3, r7, r1
 8008bd2:	881b      	ldrh	r3, [r3, #0]
 8008bd4:	0018      	movs	r0, r3
 8008bd6:	f7ff fdd3 	bl	8008780 <ptr_to_mem>
 8008bda:	0002      	movs	r2, r0
 8008bdc:	4b49      	ldr	r3, [pc, #292]	; (8008d04 <mem_trim+0x280>)
 8008bde:	601a      	str	r2, [r3, #0]
    }
    mem2 = ptr_to_mem(ptr2);
 8008be0:	240e      	movs	r4, #14
 8008be2:	193b      	adds	r3, r7, r4
 8008be4:	881b      	ldrh	r3, [r3, #0]
 8008be6:	0018      	movs	r0, r3
 8008be8:	f7ff fdca 	bl	8008780 <ptr_to_mem>
 8008bec:	0003      	movs	r3, r0
 8008bee:	613b      	str	r3, [r7, #16]
    mem2->used = 0;
 8008bf0:	693b      	ldr	r3, [r7, #16]
 8008bf2:	2200      	movs	r2, #0
 8008bf4:	711a      	strb	r2, [r3, #4]
    /* restore the next pointer */
    mem2->next = next;
 8008bf6:	693b      	ldr	r3, [r7, #16]
 8008bf8:	220c      	movs	r2, #12
 8008bfa:	18ba      	adds	r2, r7, r2
 8008bfc:	8812      	ldrh	r2, [r2, #0]
 8008bfe:	801a      	strh	r2, [r3, #0]
    /* link it back to mem */
    mem2->prev = ptr;
 8008c00:	693b      	ldr	r3, [r7, #16]
 8008c02:	2216      	movs	r2, #22
 8008c04:	18ba      	adds	r2, r7, r2
 8008c06:	8812      	ldrh	r2, [r2, #0]
 8008c08:	805a      	strh	r2, [r3, #2]
    /* link mem to it */
    mem->next = ptr2;
 8008c0a:	69bb      	ldr	r3, [r7, #24]
 8008c0c:	193a      	adds	r2, r7, r4
 8008c0e:	8812      	ldrh	r2, [r2, #0]
 8008c10:	801a      	strh	r2, [r3, #0]
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
 8008c12:	693b      	ldr	r3, [r7, #16]
 8008c14:	881a      	ldrh	r2, [r3, #0]
 8008c16:	2380      	movs	r3, #128	; 0x80
 8008c18:	00db      	lsls	r3, r3, #3
 8008c1a:	429a      	cmp	r2, r3
 8008c1c:	d05a      	beq.n	8008cd4 <mem_trim+0x250>
      ptr_to_mem(mem2->next)->prev = ptr2;
 8008c1e:	693b      	ldr	r3, [r7, #16]
 8008c20:	881b      	ldrh	r3, [r3, #0]
 8008c22:	0018      	movs	r0, r3
 8008c24:	f7ff fdac 	bl	8008780 <ptr_to_mem>
 8008c28:	0002      	movs	r2, r0
 8008c2a:	193b      	adds	r3, r7, r4
 8008c2c:	881b      	ldrh	r3, [r3, #0]
 8008c2e:	8053      	strh	r3, [r2, #2]
 8008c30:	e050      	b.n	8008cd4 <mem_trim+0x250>
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
 8008c32:	211e      	movs	r1, #30
 8008c34:	187b      	adds	r3, r7, r1
 8008c36:	881b      	ldrh	r3, [r3, #0]
 8008c38:	3314      	adds	r3, #20
 8008c3a:	001a      	movs	r2, r3
 8008c3c:	2314      	movs	r3, #20
 8008c3e:	18fb      	adds	r3, r7, r3
 8008c40:	881b      	ldrh	r3, [r3, #0]
 8008c42:	429a      	cmp	r2, r3
 8008c44:	d846      	bhi.n	8008cd4 <mem_trim+0x250>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + newsize);
 8008c46:	2316      	movs	r3, #22
 8008c48:	18fa      	adds	r2, r7, r3
 8008c4a:	187b      	adds	r3, r7, r1
 8008c4c:	8812      	ldrh	r2, [r2, #0]
 8008c4e:	881b      	ldrh	r3, [r3, #0]
 8008c50:	18d3      	adds	r3, r2, r3
 8008c52:	b29a      	uxth	r2, r3
 8008c54:	230e      	movs	r3, #14
 8008c56:	18fb      	adds	r3, r7, r3
 8008c58:	3208      	adds	r2, #8
 8008c5a:	801a      	strh	r2, [r3, #0]
    LWIP_ASSERT("invalid next ptr", mem->next != MEM_SIZE_ALIGNED);
 8008c5c:	69bb      	ldr	r3, [r7, #24]
 8008c5e:	881a      	ldrh	r2, [r3, #0]
 8008c60:	2380      	movs	r3, #128	; 0x80
 8008c62:	00db      	lsls	r3, r3, #3
 8008c64:	429a      	cmp	r2, r3
 8008c66:	d105      	bne.n	8008c74 <mem_trim+0x1f0>
 8008c68:	4b1f      	ldr	r3, [pc, #124]	; (8008ce8 <mem_trim+0x264>)
 8008c6a:	4a27      	ldr	r2, [pc, #156]	; (8008d08 <mem_trim+0x284>)
 8008c6c:	4924      	ldr	r1, [pc, #144]	; (8008d00 <mem_trim+0x27c>)
 8008c6e:	4821      	ldr	r0, [pc, #132]	; (8008cf4 <mem_trim+0x270>)
 8008c70:	f7f9 ffaa 	bl	8002bc8 <app_debug_rtt_raw>
    mem2 = ptr_to_mem(ptr2);
 8008c74:	230e      	movs	r3, #14
 8008c76:	18fb      	adds	r3, r7, r3
 8008c78:	881b      	ldrh	r3, [r3, #0]
 8008c7a:	0018      	movs	r0, r3
 8008c7c:	f7ff fd80 	bl	8008780 <ptr_to_mem>
 8008c80:	0003      	movs	r3, r0
 8008c82:	613b      	str	r3, [r7, #16]
    if (mem2 < lfree) {
 8008c84:	4b1f      	ldr	r3, [pc, #124]	; (8008d04 <mem_trim+0x280>)
 8008c86:	681b      	ldr	r3, [r3, #0]
 8008c88:	693a      	ldr	r2, [r7, #16]
 8008c8a:	429a      	cmp	r2, r3
 8008c8c:	d202      	bcs.n	8008c94 <mem_trim+0x210>
      lfree = mem2;
 8008c8e:	4b1d      	ldr	r3, [pc, #116]	; (8008d04 <mem_trim+0x280>)
 8008c90:	693a      	ldr	r2, [r7, #16]
 8008c92:	601a      	str	r2, [r3, #0]
    }
    mem2->used = 0;
 8008c94:	693b      	ldr	r3, [r7, #16]
 8008c96:	2200      	movs	r2, #0
 8008c98:	711a      	strb	r2, [r3, #4]
    mem2->next = mem->next;
 8008c9a:	69bb      	ldr	r3, [r7, #24]
 8008c9c:	881a      	ldrh	r2, [r3, #0]
 8008c9e:	693b      	ldr	r3, [r7, #16]
 8008ca0:	801a      	strh	r2, [r3, #0]
    mem2->prev = ptr;
 8008ca2:	693b      	ldr	r3, [r7, #16]
 8008ca4:	2216      	movs	r2, #22
 8008ca6:	18ba      	adds	r2, r7, r2
 8008ca8:	8812      	ldrh	r2, [r2, #0]
 8008caa:	805a      	strh	r2, [r3, #2]
    mem->next = ptr2;
 8008cac:	69bb      	ldr	r3, [r7, #24]
 8008cae:	240e      	movs	r4, #14
 8008cb0:	193a      	adds	r2, r7, r4
 8008cb2:	8812      	ldrh	r2, [r2, #0]
 8008cb4:	801a      	strh	r2, [r3, #0]
    if (mem2->next != MEM_SIZE_ALIGNED) {
 8008cb6:	693b      	ldr	r3, [r7, #16]
 8008cb8:	881a      	ldrh	r2, [r3, #0]
 8008cba:	2380      	movs	r3, #128	; 0x80
 8008cbc:	00db      	lsls	r3, r3, #3
 8008cbe:	429a      	cmp	r2, r3
 8008cc0:	d008      	beq.n	8008cd4 <mem_trim+0x250>
      ptr_to_mem(mem2->next)->prev = ptr2;
 8008cc2:	693b      	ldr	r3, [r7, #16]
 8008cc4:	881b      	ldrh	r3, [r3, #0]
 8008cc6:	0018      	movs	r0, r3
 8008cc8:	f7ff fd5a 	bl	8008780 <ptr_to_mem>
 8008ccc:	0002      	movs	r2, r0
 8008cce:	193b      	adds	r3, r7, r4
 8008cd0:	881b      	ldrh	r3, [r3, #0]
 8008cd2:	8053      	strh	r3, [r2, #2]
  MEM_SANITY();
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
 8008cd4:	687b      	ldr	r3, [r7, #4]
}
 8008cd6:	0018      	movs	r0, r3
 8008cd8:	46bd      	mov	sp, r7
 8008cda:	b008      	add	sp, #32
 8008cdc:	bdb0      	pop	{r4, r5, r7, pc}
 8008cde:	46c0      	nop			; (mov r8, r8)
 8008ce0:	20001768 	.word	0x20001768
 8008ce4:	2000176c 	.word	0x2000176c
 8008ce8:	0801f30c 	.word	0x0801f30c
 8008cec:	000002d1 	.word	0x000002d1
 8008cf0:	0801f478 	.word	0x0801f478
 8008cf4:	0801f34c 	.word	0x0801f34c
 8008cf8:	0801f490 	.word	0x0801f490
 8008cfc:	000002f5 	.word	0x000002f5
 8008d00:	0801f4b0 	.word	0x0801f4b0
 8008d04:	20001770 	.word	0x20001770
 8008d08:	00000316 	.word	0x00000316

08008d0c <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size_in)
{
 8008d0c:	b590      	push	{r4, r7, lr}
 8008d0e:	b089      	sub	sp, #36	; 0x24
 8008d10:	af00      	add	r7, sp, #0
 8008d12:	0002      	movs	r2, r0
 8008d14:	1dbb      	adds	r3, r7, #6
 8008d16:	801a      	strh	r2, [r3, #0]
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size_in == 0) {
 8008d18:	1dbb      	adds	r3, r7, #6
 8008d1a:	881b      	ldrh	r3, [r3, #0]
 8008d1c:	2b00      	cmp	r3, #0
 8008d1e:	d101      	bne.n	8008d24 <mem_malloc+0x18>
    return NULL;
 8008d20:	2300      	movs	r3, #0
 8008d22:	e101      	b.n	8008f28 <mem_malloc+0x21c>
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = (mem_size_t)LWIP_MEM_ALIGN_SIZE(size_in);
 8008d24:	1dbb      	adds	r3, r7, #6
 8008d26:	881b      	ldrh	r3, [r3, #0]
 8008d28:	3303      	adds	r3, #3
 8008d2a:	b29a      	uxth	r2, r3
 8008d2c:	201c      	movs	r0, #28
 8008d2e:	183b      	adds	r3, r7, r0
 8008d30:	2103      	movs	r1, #3
 8008d32:	438a      	bics	r2, r1
 8008d34:	801a      	strh	r2, [r3, #0]
  if (size < MIN_SIZE_ALIGNED) {
 8008d36:	183b      	adds	r3, r7, r0
 8008d38:	881b      	ldrh	r3, [r3, #0]
 8008d3a:	2b0b      	cmp	r3, #11
 8008d3c:	d802      	bhi.n	8008d44 <mem_malloc+0x38>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
 8008d3e:	183b      	adds	r3, r7, r0
 8008d40:	220c      	movs	r2, #12
 8008d42:	801a      	strh	r2, [r3, #0]
  }
#if MEM_OVERFLOW_CHECK
  size += MEM_SANITY_REGION_BEFORE_ALIGNED + MEM_SANITY_REGION_AFTER_ALIGNED;
#endif
  if ((size > MEM_SIZE_ALIGNED) || (size < size_in)) {
 8008d44:	211c      	movs	r1, #28
 8008d46:	187b      	adds	r3, r7, r1
 8008d48:	881a      	ldrh	r2, [r3, #0]
 8008d4a:	2380      	movs	r3, #128	; 0x80
 8008d4c:	00db      	lsls	r3, r3, #3
 8008d4e:	429a      	cmp	r2, r3
 8008d50:	d805      	bhi.n	8008d5e <mem_malloc+0x52>
 8008d52:	187a      	adds	r2, r7, r1
 8008d54:	1dbb      	adds	r3, r7, #6
 8008d56:	8812      	ldrh	r2, [r2, #0]
 8008d58:	881b      	ldrh	r3, [r3, #0]
 8008d5a:	429a      	cmp	r2, r3
 8008d5c:	d201      	bcs.n	8008d62 <mem_malloc+0x56>
    return NULL;
 8008d5e:	2300      	movs	r3, #0
 8008d60:	e0e2      	b.n	8008f28 <mem_malloc+0x21c>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = mem_to_ptr(lfree); ptr < MEM_SIZE_ALIGNED - size;
 8008d62:	4b73      	ldr	r3, [pc, #460]	; (8008f30 <mem_malloc+0x224>)
 8008d64:	681b      	ldr	r3, [r3, #0]
 8008d66:	221e      	movs	r2, #30
 8008d68:	18bc      	adds	r4, r7, r2
 8008d6a:	0018      	movs	r0, r3
 8008d6c:	f7ff fd1a 	bl	80087a4 <mem_to_ptr>
 8008d70:	0003      	movs	r3, r0
 8008d72:	8023      	strh	r3, [r4, #0]
 8008d74:	e0cb      	b.n	8008f0e <mem_malloc+0x202>
         ptr = ptr_to_mem(ptr)->next) {
      mem = ptr_to_mem(ptr);
 8008d76:	241e      	movs	r4, #30
 8008d78:	193b      	adds	r3, r7, r4
 8008d7a:	881b      	ldrh	r3, [r3, #0]
 8008d7c:	0018      	movs	r0, r3
 8008d7e:	f7ff fcff 	bl	8008780 <ptr_to_mem>
 8008d82:	0003      	movs	r3, r0
 8008d84:	617b      	str	r3, [r7, #20]
        local_mem_free_count = 1;
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
 8008d86:	697b      	ldr	r3, [r7, #20]
 8008d88:	791b      	ldrb	r3, [r3, #4]
 8008d8a:	2b00      	cmp	r3, #0
 8008d8c:	d000      	beq.n	8008d90 <mem_malloc+0x84>
 8008d8e:	e0b4      	b.n	8008efa <mem_malloc+0x1ee>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 8008d90:	697b      	ldr	r3, [r7, #20]
 8008d92:	881b      	ldrh	r3, [r3, #0]
 8008d94:	001a      	movs	r2, r3
 8008d96:	0021      	movs	r1, r4
 8008d98:	187b      	adds	r3, r7, r1
 8008d9a:	881b      	ldrh	r3, [r3, #0]
 8008d9c:	1ad3      	subs	r3, r2, r3
 8008d9e:	3b08      	subs	r3, #8
 8008da0:	001a      	movs	r2, r3
 8008da2:	201c      	movs	r0, #28
 8008da4:	183b      	adds	r3, r7, r0
 8008da6:	881b      	ldrh	r3, [r3, #0]
      if ((!mem->used) &&
 8008da8:	429a      	cmp	r2, r3
 8008daa:	d200      	bcs.n	8008dae <mem_malloc+0xa2>
 8008dac:	e0a5      	b.n	8008efa <mem_malloc+0x1ee>
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
 8008dae:	697b      	ldr	r3, [r7, #20]
 8008db0:	881b      	ldrh	r3, [r3, #0]
 8008db2:	001a      	movs	r2, r3
 8008db4:	187b      	adds	r3, r7, r1
 8008db6:	881b      	ldrh	r3, [r3, #0]
 8008db8:	1ad3      	subs	r3, r2, r3
 8008dba:	3b08      	subs	r3, #8
 8008dbc:	001a      	movs	r2, r3
 8008dbe:	183b      	adds	r3, r7, r0
 8008dc0:	881b      	ldrh	r3, [r3, #0]
 8008dc2:	3314      	adds	r3, #20
 8008dc4:	429a      	cmp	r2, r3
 8008dc6:	d340      	bcc.n	8008e4a <mem_malloc+0x13e>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + size);
 8008dc8:	187a      	adds	r2, r7, r1
 8008dca:	183b      	adds	r3, r7, r0
 8008dcc:	8812      	ldrh	r2, [r2, #0]
 8008dce:	881b      	ldrh	r3, [r3, #0]
 8008dd0:	18d3      	adds	r3, r2, r3
 8008dd2:	b29a      	uxth	r2, r3
 8008dd4:	2112      	movs	r1, #18
 8008dd6:	187b      	adds	r3, r7, r1
 8008dd8:	3208      	adds	r2, #8
 8008dda:	801a      	strh	r2, [r3, #0]
          LWIP_ASSERT("invalid next ptr",ptr2 != MEM_SIZE_ALIGNED);
 8008ddc:	187b      	adds	r3, r7, r1
 8008dde:	881a      	ldrh	r2, [r3, #0]
 8008de0:	2380      	movs	r3, #128	; 0x80
 8008de2:	00db      	lsls	r3, r3, #3
 8008de4:	429a      	cmp	r2, r3
 8008de6:	d105      	bne.n	8008df4 <mem_malloc+0xe8>
 8008de8:	4b52      	ldr	r3, [pc, #328]	; (8008f34 <mem_malloc+0x228>)
 8008dea:	4a53      	ldr	r2, [pc, #332]	; (8008f38 <mem_malloc+0x22c>)
 8008dec:	4953      	ldr	r1, [pc, #332]	; (8008f3c <mem_malloc+0x230>)
 8008dee:	4854      	ldr	r0, [pc, #336]	; (8008f40 <mem_malloc+0x234>)
 8008df0:	f7f9 feea 	bl	8002bc8 <app_debug_rtt_raw>
          /* create mem2 struct */
          mem2 = ptr_to_mem(ptr2);
 8008df4:	2412      	movs	r4, #18
 8008df6:	193b      	adds	r3, r7, r4
 8008df8:	881b      	ldrh	r3, [r3, #0]
 8008dfa:	0018      	movs	r0, r3
 8008dfc:	f7ff fcc0 	bl	8008780 <ptr_to_mem>
 8008e00:	0003      	movs	r3, r0
 8008e02:	60fb      	str	r3, [r7, #12]
          mem2->used = 0;
 8008e04:	68fb      	ldr	r3, [r7, #12]
 8008e06:	2200      	movs	r2, #0
 8008e08:	711a      	strb	r2, [r3, #4]
          mem2->next = mem->next;
 8008e0a:	697b      	ldr	r3, [r7, #20]
 8008e0c:	881a      	ldrh	r2, [r3, #0]
 8008e0e:	68fb      	ldr	r3, [r7, #12]
 8008e10:	801a      	strh	r2, [r3, #0]
          mem2->prev = ptr;
 8008e12:	68fb      	ldr	r3, [r7, #12]
 8008e14:	221e      	movs	r2, #30
 8008e16:	18ba      	adds	r2, r7, r2
 8008e18:	8812      	ldrh	r2, [r2, #0]
 8008e1a:	805a      	strh	r2, [r3, #2]
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
 8008e1c:	697b      	ldr	r3, [r7, #20]
 8008e1e:	193a      	adds	r2, r7, r4
 8008e20:	8812      	ldrh	r2, [r2, #0]
 8008e22:	801a      	strh	r2, [r3, #0]
          mem->used = 1;
 8008e24:	697b      	ldr	r3, [r7, #20]
 8008e26:	2201      	movs	r2, #1
 8008e28:	711a      	strb	r2, [r3, #4]

          if (mem2->next != MEM_SIZE_ALIGNED) {
 8008e2a:	68fb      	ldr	r3, [r7, #12]
 8008e2c:	881a      	ldrh	r2, [r3, #0]
 8008e2e:	2380      	movs	r3, #128	; 0x80
 8008e30:	00db      	lsls	r3, r3, #3
 8008e32:	429a      	cmp	r2, r3
 8008e34:	d00c      	beq.n	8008e50 <mem_malloc+0x144>
            ptr_to_mem(mem2->next)->prev = ptr2;
 8008e36:	68fb      	ldr	r3, [r7, #12]
 8008e38:	881b      	ldrh	r3, [r3, #0]
 8008e3a:	0018      	movs	r0, r3
 8008e3c:	f7ff fca0 	bl	8008780 <ptr_to_mem>
 8008e40:	0002      	movs	r2, r0
 8008e42:	193b      	adds	r3, r7, r4
 8008e44:	881b      	ldrh	r3, [r3, #0]
 8008e46:	8053      	strh	r3, [r2, #2]
 8008e48:	e002      	b.n	8008e50 <mem_malloc+0x144>
           * take care of this).
           * -> near fit or exact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
 8008e4a:	697b      	ldr	r3, [r7, #20]
 8008e4c:	2201      	movs	r2, #1
 8008e4e:	711a      	strb	r2, [r3, #4]
          MEM_STATS_INC_USED(used, mem->next - mem_to_ptr(mem));
        }
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
 8008e50:	4b37      	ldr	r3, [pc, #220]	; (8008f30 <mem_malloc+0x224>)
 8008e52:	681b      	ldr	r3, [r3, #0]
 8008e54:	697a      	ldr	r2, [r7, #20]
 8008e56:	429a      	cmp	r2, r3
 8008e58:	d127      	bne.n	8008eaa <mem_malloc+0x19e>
          struct mem *cur = lfree;
 8008e5a:	4b35      	ldr	r3, [pc, #212]	; (8008f30 <mem_malloc+0x224>)
 8008e5c:	681b      	ldr	r3, [r3, #0]
 8008e5e:	61bb      	str	r3, [r7, #24]
          /* Find next free block after mem and update lowest free pointer */
          while (cur->used && cur != ram_end) {
 8008e60:	e006      	b.n	8008e70 <mem_malloc+0x164>
              /* If mem_free or mem_trim have run, we have to restart since they
                 could have altered our current struct mem or lfree. */
              goto mem_malloc_adjust_lfree;
            }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
            cur = ptr_to_mem(cur->next);
 8008e62:	69bb      	ldr	r3, [r7, #24]
 8008e64:	881b      	ldrh	r3, [r3, #0]
 8008e66:	0018      	movs	r0, r3
 8008e68:	f7ff fc8a 	bl	8008780 <ptr_to_mem>
 8008e6c:	0003      	movs	r3, r0
 8008e6e:	61bb      	str	r3, [r7, #24]
          while (cur->used && cur != ram_end) {
 8008e70:	69bb      	ldr	r3, [r7, #24]
 8008e72:	791b      	ldrb	r3, [r3, #4]
 8008e74:	2b00      	cmp	r3, #0
 8008e76:	d004      	beq.n	8008e82 <mem_malloc+0x176>
 8008e78:	4b32      	ldr	r3, [pc, #200]	; (8008f44 <mem_malloc+0x238>)
 8008e7a:	681b      	ldr	r3, [r3, #0]
 8008e7c:	69ba      	ldr	r2, [r7, #24]
 8008e7e:	429a      	cmp	r2, r3
 8008e80:	d1ef      	bne.n	8008e62 <mem_malloc+0x156>
          }
          lfree = cur;
 8008e82:	4b2b      	ldr	r3, [pc, #172]	; (8008f30 <mem_malloc+0x224>)
 8008e84:	69ba      	ldr	r2, [r7, #24]
 8008e86:	601a      	str	r2, [r3, #0]
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
 8008e88:	4b29      	ldr	r3, [pc, #164]	; (8008f30 <mem_malloc+0x224>)
 8008e8a:	681a      	ldr	r2, [r3, #0]
 8008e8c:	4b2d      	ldr	r3, [pc, #180]	; (8008f44 <mem_malloc+0x238>)
 8008e8e:	681b      	ldr	r3, [r3, #0]
 8008e90:	429a      	cmp	r2, r3
 8008e92:	d00a      	beq.n	8008eaa <mem_malloc+0x19e>
 8008e94:	4b26      	ldr	r3, [pc, #152]	; (8008f30 <mem_malloc+0x224>)
 8008e96:	681b      	ldr	r3, [r3, #0]
 8008e98:	791b      	ldrb	r3, [r3, #4]
 8008e9a:	2b00      	cmp	r3, #0
 8008e9c:	d005      	beq.n	8008eaa <mem_malloc+0x19e>
 8008e9e:	4b25      	ldr	r3, [pc, #148]	; (8008f34 <mem_malloc+0x228>)
 8008ea0:	4a29      	ldr	r2, [pc, #164]	; (8008f48 <mem_malloc+0x23c>)
 8008ea2:	492a      	ldr	r1, [pc, #168]	; (8008f4c <mem_malloc+0x240>)
 8008ea4:	4826      	ldr	r0, [pc, #152]	; (8008f40 <mem_malloc+0x234>)
 8008ea6:	f7f9 fe8f 	bl	8002bc8 <app_debug_rtt_raw>
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_mutex_unlock(&mem_mutex);
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
 8008eaa:	231c      	movs	r3, #28
 8008eac:	18fb      	adds	r3, r7, r3
 8008eae:	881a      	ldrh	r2, [r3, #0]
 8008eb0:	697b      	ldr	r3, [r7, #20]
 8008eb2:	18d3      	adds	r3, r2, r3
 8008eb4:	3308      	adds	r3, #8
 8008eb6:	001a      	movs	r2, r3
 8008eb8:	4b22      	ldr	r3, [pc, #136]	; (8008f44 <mem_malloc+0x238>)
 8008eba:	681b      	ldr	r3, [r3, #0]
 8008ebc:	429a      	cmp	r2, r3
 8008ebe:	d905      	bls.n	8008ecc <mem_malloc+0x1c0>
 8008ec0:	4b1c      	ldr	r3, [pc, #112]	; (8008f34 <mem_malloc+0x228>)
 8008ec2:	4a23      	ldr	r2, [pc, #140]	; (8008f50 <mem_malloc+0x244>)
 8008ec4:	4923      	ldr	r1, [pc, #140]	; (8008f54 <mem_malloc+0x248>)
 8008ec6:	481e      	ldr	r0, [pc, #120]	; (8008f40 <mem_malloc+0x234>)
 8008ec8:	f7f9 fe7e 	bl	8002bc8 <app_debug_rtt_raw>
                    (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
 8008ecc:	697b      	ldr	r3, [r7, #20]
 8008ece:	2203      	movs	r2, #3
 8008ed0:	4013      	ands	r3, r2
 8008ed2:	d005      	beq.n	8008ee0 <mem_malloc+0x1d4>
 8008ed4:	4b17      	ldr	r3, [pc, #92]	; (8008f34 <mem_malloc+0x228>)
 8008ed6:	4a20      	ldr	r2, [pc, #128]	; (8008f58 <mem_malloc+0x24c>)
 8008ed8:	4920      	ldr	r1, [pc, #128]	; (8008f5c <mem_malloc+0x250>)
 8008eda:	4819      	ldr	r0, [pc, #100]	; (8008f40 <mem_malloc+0x234>)
 8008edc:	f7f9 fe74 	bl	8002bc8 <app_debug_rtt_raw>
                    ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
 8008ee0:	697b      	ldr	r3, [r7, #20]
 8008ee2:	2203      	movs	r2, #3
 8008ee4:	4013      	ands	r3, r2
 8008ee6:	d005      	beq.n	8008ef4 <mem_malloc+0x1e8>
 8008ee8:	4b12      	ldr	r3, [pc, #72]	; (8008f34 <mem_malloc+0x228>)
 8008eea:	4a1d      	ldr	r2, [pc, #116]	; (8008f60 <mem_malloc+0x254>)
 8008eec:	491d      	ldr	r1, [pc, #116]	; (8008f64 <mem_malloc+0x258>)
 8008eee:	4814      	ldr	r0, [pc, #80]	; (8008f40 <mem_malloc+0x234>)
 8008ef0:	f7f9 fe6a 	bl	8002bc8 <app_debug_rtt_raw>

#if MEM_OVERFLOW_CHECK
        mem_overflow_init_element(mem, size_in);
#endif
        MEM_SANITY();
        return (u8_t *)mem + SIZEOF_STRUCT_MEM + MEM_SANITY_OFFSET;
 8008ef4:	697b      	ldr	r3, [r7, #20]
 8008ef6:	3308      	adds	r3, #8
 8008ef8:	e016      	b.n	8008f28 <mem_malloc+0x21c>
         ptr = ptr_to_mem(ptr)->next) {
 8008efa:	241e      	movs	r4, #30
 8008efc:	193b      	adds	r3, r7, r4
 8008efe:	881b      	ldrh	r3, [r3, #0]
 8008f00:	0018      	movs	r0, r3
 8008f02:	f7ff fc3d 	bl	8008780 <ptr_to_mem>
 8008f06:	0002      	movs	r2, r0
 8008f08:	193b      	adds	r3, r7, r4
 8008f0a:	8812      	ldrh	r2, [r2, #0]
 8008f0c:	801a      	strh	r2, [r3, #0]
    for (ptr = mem_to_ptr(lfree); ptr < MEM_SIZE_ALIGNED - size;
 8008f0e:	231e      	movs	r3, #30
 8008f10:	18fb      	adds	r3, r7, r3
 8008f12:	881a      	ldrh	r2, [r3, #0]
 8008f14:	231c      	movs	r3, #28
 8008f16:	18fb      	adds	r3, r7, r3
 8008f18:	881b      	ldrh	r3, [r3, #0]
 8008f1a:	2180      	movs	r1, #128	; 0x80
 8008f1c:	00c9      	lsls	r1, r1, #3
 8008f1e:	1acb      	subs	r3, r1, r3
 8008f20:	429a      	cmp	r2, r3
 8008f22:	d200      	bcs.n	8008f26 <mem_malloc+0x21a>
 8008f24:	e727      	b.n	8008d76 <mem_malloc+0x6a>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  return NULL;
 8008f26:	2300      	movs	r3, #0
}
 8008f28:	0018      	movs	r0, r3
 8008f2a:	46bd      	mov	sp, r7
 8008f2c:	b009      	add	sp, #36	; 0x24
 8008f2e:	bd90      	pop	{r4, r7, pc}
 8008f30:	20001770 	.word	0x20001770
 8008f34:	0801f30c 	.word	0x0801f30c
 8008f38:	00000387 	.word	0x00000387
 8008f3c:	0801f4b0 	.word	0x0801f4b0
 8008f40:	0801f34c 	.word	0x0801f34c
 8008f44:	2000176c 	.word	0x2000176c
 8008f48:	000003b5 	.word	0x000003b5
 8008f4c:	0801f4c4 	.word	0x0801f4c4
 8008f50:	000003b9 	.word	0x000003b9
 8008f54:	0801f4e0 	.word	0x0801f4e0
 8008f58:	000003bb 	.word	0x000003bb
 8008f5c:	0801f510 	.word	0x0801f510
 8008f60:	000003bd 	.word	0x000003bd
 8008f64:	0801f540 	.word	0x0801f540

08008f68 <do_memp_malloc_pool>:
#if !MEMP_OVERFLOW_CHECK
do_memp_malloc_pool(const struct memp_desc *desc)
#else
do_memp_malloc_pool_fn(const struct memp_desc *desc, const char *file, const int line)
#endif
{
 8008f68:	b580      	push	{r7, lr}
 8008f6a:	b084      	sub	sp, #16
 8008f6c:	af00      	add	r7, sp, #0
 8008f6e:	6078      	str	r0, [r7, #4]
  memp = (struct memp *)mem_malloc(MEMP_SIZE + MEMP_ALIGN_SIZE(desc->size));
  SYS_ARCH_PROTECT(old_level);
#else /* MEMP_MEM_MALLOC */
  SYS_ARCH_PROTECT(old_level);

  memp = *desc->tab;
 8008f70:	687b      	ldr	r3, [r7, #4]
 8008f72:	68db      	ldr	r3, [r3, #12]
 8008f74:	681b      	ldr	r3, [r3, #0]
 8008f76:	60fb      	str	r3, [r7, #12]
#endif /* MEMP_MEM_MALLOC */

  if (memp != NULL) {
 8008f78:	68fb      	ldr	r3, [r7, #12]
 8008f7a:	2b00      	cmp	r3, #0
 8008f7c:	d011      	beq.n	8008fa2 <do_memp_malloc_pool+0x3a>
#if !MEMP_MEM_MALLOC
#if MEMP_OVERFLOW_CHECK == 1
    memp_overflow_check_element(memp, desc);
#endif /* MEMP_OVERFLOW_CHECK */

    *desc->tab = memp->next;
 8008f7e:	687b      	ldr	r3, [r7, #4]
 8008f80:	68db      	ldr	r3, [r3, #12]
 8008f82:	68fa      	ldr	r2, [r7, #12]
 8008f84:	6812      	ldr	r2, [r2, #0]
 8008f86:	601a      	str	r2, [r3, #0]
    memp->line = line;
#if MEMP_MEM_MALLOC
    memp_overflow_init_element(memp, desc);
#endif /* MEMP_MEM_MALLOC */
#endif /* MEMP_OVERFLOW_CHECK */
    LWIP_ASSERT("memp_malloc: memp properly aligned",
 8008f88:	68fb      	ldr	r3, [r7, #12]
 8008f8a:	2203      	movs	r2, #3
 8008f8c:	4013      	ands	r3, r2
 8008f8e:	d006      	beq.n	8008f9e <do_memp_malloc_pool+0x36>
 8008f90:	4b06      	ldr	r3, [pc, #24]	; (8008fac <do_memp_malloc_pool+0x44>)
 8008f92:	228c      	movs	r2, #140	; 0x8c
 8008f94:	0052      	lsls	r2, r2, #1
 8008f96:	4906      	ldr	r1, [pc, #24]	; (8008fb0 <do_memp_malloc_pool+0x48>)
 8008f98:	4806      	ldr	r0, [pc, #24]	; (8008fb4 <do_memp_malloc_pool+0x4c>)
 8008f9a:	f7f9 fe15 	bl	8002bc8 <app_debug_rtt_raw>
      desc->stats->max = desc->stats->used;
    }
#endif
    SYS_ARCH_UNPROTECT(old_level);
    /* cast through u8_t* to get rid of alignment warnings */
    return ((u8_t *)memp + MEMP_SIZE);
 8008f9e:	68fb      	ldr	r3, [r7, #12]
 8008fa0:	e000      	b.n	8008fa4 <do_memp_malloc_pool+0x3c>
#endif
    SYS_ARCH_UNPROTECT(old_level);
    LWIP_DEBUGF(MEMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("memp_malloc: out of memory in pool %s\n", desc->desc));
  }

  return NULL;
 8008fa2:	2300      	movs	r3, #0
}
 8008fa4:	0018      	movs	r0, r3
 8008fa6:	46bd      	mov	sp, r7
 8008fa8:	b004      	add	sp, #16
 8008faa:	bd80      	pop	{r7, pc}
 8008fac:	0801f5b4 	.word	0x0801f5b4
 8008fb0:	0801f5dc 	.word	0x0801f5dc
 8008fb4:	0801f600 	.word	0x0801f600

08008fb8 <memp_malloc_pool>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc_pool(const struct memp_desc *desc)
#else
memp_malloc_pool_fn(const struct memp_desc *desc, const char *file, const int line)
#endif
{
 8008fb8:	b580      	push	{r7, lr}
 8008fba:	b082      	sub	sp, #8
 8008fbc:	af00      	add	r7, sp, #0
 8008fbe:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("invalid pool desc", desc != NULL);
 8008fc0:	687b      	ldr	r3, [r7, #4]
 8008fc2:	2b00      	cmp	r3, #0
 8008fc4:	d106      	bne.n	8008fd4 <memp_malloc_pool+0x1c>
 8008fc6:	4b0a      	ldr	r3, [pc, #40]	; (8008ff0 <memp_malloc_pool+0x38>)
 8008fc8:	229e      	movs	r2, #158	; 0x9e
 8008fca:	0052      	lsls	r2, r2, #1
 8008fcc:	4909      	ldr	r1, [pc, #36]	; (8008ff4 <memp_malloc_pool+0x3c>)
 8008fce:	480a      	ldr	r0, [pc, #40]	; (8008ff8 <memp_malloc_pool+0x40>)
 8008fd0:	f7f9 fdfa 	bl	8002bc8 <app_debug_rtt_raw>
  if (desc == NULL) {
 8008fd4:	687b      	ldr	r3, [r7, #4]
 8008fd6:	2b00      	cmp	r3, #0
 8008fd8:	d101      	bne.n	8008fde <memp_malloc_pool+0x26>
    return NULL;
 8008fda:	2300      	movs	r3, #0
 8008fdc:	e004      	b.n	8008fe8 <memp_malloc_pool+0x30>
  }

#if !MEMP_OVERFLOW_CHECK
  return do_memp_malloc_pool(desc);
 8008fde:	687b      	ldr	r3, [r7, #4]
 8008fe0:	0018      	movs	r0, r3
 8008fe2:	f7ff ffc1 	bl	8008f68 <do_memp_malloc_pool>
 8008fe6:	0003      	movs	r3, r0
#else
  return do_memp_malloc_pool_fn(desc, file, line);
#endif
}
 8008fe8:	0018      	movs	r0, r3
 8008fea:	46bd      	mov	sp, r7
 8008fec:	b002      	add	sp, #8
 8008fee:	bd80      	pop	{r7, pc}
 8008ff0:	0801f5b4 	.word	0x0801f5b4
 8008ff4:	0801f62c 	.word	0x0801f62c
 8008ff8:	0801f600 	.word	0x0801f600

08008ffc <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char *file, const int line)
#endif
{
 8008ffc:	b580      	push	{r7, lr}
 8008ffe:	b084      	sub	sp, #16
 8009000:	af00      	add	r7, sp, #0
 8009002:	0002      	movs	r2, r0
 8009004:	1dfb      	adds	r3, r7, #7
 8009006:	701a      	strb	r2, [r3, #0]
  void *memp;
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 8009008:	1dfb      	adds	r3, r7, #7
 800900a:	781b      	ldrb	r3, [r3, #0]
 800900c:	2b06      	cmp	r3, #6
 800900e:	d905      	bls.n	800901c <memp_malloc+0x20>
 8009010:	4b0a      	ldr	r3, [pc, #40]	; (800903c <memp_malloc+0x40>)
 8009012:	0018      	movs	r0, r3
 8009014:	f7f9 fdd8 	bl	8002bc8 <app_debug_rtt_raw>
 8009018:	2300      	movs	r3, #0
 800901a:	e00a      	b.n	8009032 <memp_malloc+0x36>
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

#if !MEMP_OVERFLOW_CHECK
  memp = do_memp_malloc_pool(memp_pools[type]);
 800901c:	1dfb      	adds	r3, r7, #7
 800901e:	781a      	ldrb	r2, [r3, #0]
 8009020:	4b07      	ldr	r3, [pc, #28]	; (8009040 <memp_malloc+0x44>)
 8009022:	0092      	lsls	r2, r2, #2
 8009024:	58d3      	ldr	r3, [r2, r3]
 8009026:	0018      	movs	r0, r3
 8009028:	f7ff ff9e 	bl	8008f68 <do_memp_malloc_pool>
 800902c:	0003      	movs	r3, r0
 800902e:	60fb      	str	r3, [r7, #12]
#else
  memp = do_memp_malloc_pool_fn(memp_pools[type], file, line);
#endif

  return memp;
 8009030:	68fb      	ldr	r3, [r7, #12]
}
 8009032:	0018      	movs	r0, r3
 8009034:	46bd      	mov	sp, r7
 8009036:	b004      	add	sp, #16
 8009038:	bd80      	pop	{r7, pc}
 800903a:	46c0      	nop			; (mov r8, r8)
 800903c:	0801f640 	.word	0x0801f640
 8009040:	0802281c 	.word	0x0802281c

08009044 <do_memp_free_pool>:

static void
do_memp_free_pool(const struct memp_desc *desc, void *mem)
{
 8009044:	b580      	push	{r7, lr}
 8009046:	b084      	sub	sp, #16
 8009048:	af00      	add	r7, sp, #0
 800904a:	6078      	str	r0, [r7, #4]
 800904c:	6039      	str	r1, [r7, #0]
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  LWIP_ASSERT("memp_free: mem properly aligned",
 800904e:	683b      	ldr	r3, [r7, #0]
 8009050:	2203      	movs	r2, #3
 8009052:	4013      	ands	r3, r2
 8009054:	d006      	beq.n	8009064 <do_memp_free_pool+0x20>
 8009056:	4b0b      	ldr	r3, [pc, #44]	; (8009084 <do_memp_free_pool+0x40>)
 8009058:	22b6      	movs	r2, #182	; 0xb6
 800905a:	0052      	lsls	r2, r2, #1
 800905c:	490a      	ldr	r1, [pc, #40]	; (8009088 <do_memp_free_pool+0x44>)
 800905e:	480b      	ldr	r0, [pc, #44]	; (800908c <do_memp_free_pool+0x48>)
 8009060:	f7f9 fdb2 	bl	8002bc8 <app_debug_rtt_raw>
              ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  /* cast through void* to get rid of alignment warnings */
  memp = (struct memp *)(void *)((u8_t *)mem - MEMP_SIZE);
 8009064:	683b      	ldr	r3, [r7, #0]
 8009066:	60fb      	str	r3, [r7, #12]
#if MEMP_MEM_MALLOC
  LWIP_UNUSED_ARG(desc);
  SYS_ARCH_UNPROTECT(old_level);
  mem_free(memp);
#else /* MEMP_MEM_MALLOC */
  memp->next = *desc->tab;
 8009068:	687b      	ldr	r3, [r7, #4]
 800906a:	68db      	ldr	r3, [r3, #12]
 800906c:	681a      	ldr	r2, [r3, #0]
 800906e:	68fb      	ldr	r3, [r7, #12]
 8009070:	601a      	str	r2, [r3, #0]
  *desc->tab = memp;
 8009072:	687b      	ldr	r3, [r7, #4]
 8009074:	68db      	ldr	r3, [r3, #12]
 8009076:	68fa      	ldr	r2, [r7, #12]
 8009078:	601a      	str	r2, [r3, #0]
  LWIP_ASSERT("memp sanity", memp_sanity(desc));
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
#endif /* !MEMP_MEM_MALLOC */
}
 800907a:	46c0      	nop			; (mov r8, r8)
 800907c:	46bd      	mov	sp, r7
 800907e:	b004      	add	sp, #16
 8009080:	bd80      	pop	{r7, pc}
 8009082:	46c0      	nop			; (mov r8, r8)
 8009084:	0801f5b4 	.word	0x0801f5b4
 8009088:	0801f660 	.word	0x0801f660
 800908c:	0801f600 	.word	0x0801f600

08009090 <memp_free_pool>:
 * @param desc the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free_pool(const struct memp_desc *desc, void *mem)
{
 8009090:	b580      	push	{r7, lr}
 8009092:	b082      	sub	sp, #8
 8009094:	af00      	add	r7, sp, #0
 8009096:	6078      	str	r0, [r7, #4]
 8009098:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT("invalid pool desc", desc != NULL);
 800909a:	687b      	ldr	r3, [r7, #4]
 800909c:	2b00      	cmp	r3, #0
 800909e:	d106      	bne.n	80090ae <memp_free_pool+0x1e>
 80090a0:	4b0b      	ldr	r3, [pc, #44]	; (80090d0 <memp_free_pool+0x40>)
 80090a2:	2296      	movs	r2, #150	; 0x96
 80090a4:	32ff      	adds	r2, #255	; 0xff
 80090a6:	490b      	ldr	r1, [pc, #44]	; (80090d4 <memp_free_pool+0x44>)
 80090a8:	480b      	ldr	r0, [pc, #44]	; (80090d8 <memp_free_pool+0x48>)
 80090aa:	f7f9 fd8d 	bl	8002bc8 <app_debug_rtt_raw>
  if ((desc == NULL) || (mem == NULL)) {
 80090ae:	687b      	ldr	r3, [r7, #4]
 80090b0:	2b00      	cmp	r3, #0
 80090b2:	d009      	beq.n	80090c8 <memp_free_pool+0x38>
 80090b4:	683b      	ldr	r3, [r7, #0]
 80090b6:	2b00      	cmp	r3, #0
 80090b8:	d006      	beq.n	80090c8 <memp_free_pool+0x38>
    return;
  }

  do_memp_free_pool(desc, mem);
 80090ba:	683a      	ldr	r2, [r7, #0]
 80090bc:	687b      	ldr	r3, [r7, #4]
 80090be:	0011      	movs	r1, r2
 80090c0:	0018      	movs	r0, r3
 80090c2:	f7ff ffbf 	bl	8009044 <do_memp_free_pool>
 80090c6:	e000      	b.n	80090ca <memp_free_pool+0x3a>
    return;
 80090c8:	46c0      	nop			; (mov r8, r8)
}
 80090ca:	46bd      	mov	sp, r7
 80090cc:	b002      	add	sp, #8
 80090ce:	bd80      	pop	{r7, pc}
 80090d0:	0801f5b4 	.word	0x0801f5b4
 80090d4:	0801f62c 	.word	0x0801f62c
 80090d8:	0801f600 	.word	0x0801f600

080090dc <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
 80090dc:	b580      	push	{r7, lr}
 80090de:	b082      	sub	sp, #8
 80090e0:	af00      	add	r7, sp, #0
 80090e2:	0002      	movs	r2, r0
 80090e4:	6039      	str	r1, [r7, #0]
 80090e6:	1dfb      	adds	r3, r7, #7
 80090e8:	701a      	strb	r2, [r3, #0]
#ifdef LWIP_HOOK_MEMP_AVAILABLE
  struct memp *old_first;
#endif

  LWIP_ERROR("memp_free: type < MEMP_MAX", (type < MEMP_MAX), return;);
 80090ea:	1dfb      	adds	r3, r7, #7
 80090ec:	781b      	ldrb	r3, [r3, #0]
 80090ee:	2b06      	cmp	r3, #6
 80090f0:	d904      	bls.n	80090fc <memp_free+0x20>
 80090f2:	4b0b      	ldr	r3, [pc, #44]	; (8009120 <memp_free+0x44>)
 80090f4:	0018      	movs	r0, r3
 80090f6:	f7f9 fd67 	bl	8002bc8 <app_debug_rtt_raw>
 80090fa:	e00e      	b.n	800911a <memp_free+0x3e>

  if (mem == NULL) {
 80090fc:	683b      	ldr	r3, [r7, #0]
 80090fe:	2b00      	cmp	r3, #0
 8009100:	d00a      	beq.n	8009118 <memp_free+0x3c>

#ifdef LWIP_HOOK_MEMP_AVAILABLE
  old_first = *memp_pools[type]->tab;
#endif

  do_memp_free_pool(memp_pools[type], mem);
 8009102:	1dfb      	adds	r3, r7, #7
 8009104:	781a      	ldrb	r2, [r3, #0]
 8009106:	4b07      	ldr	r3, [pc, #28]	; (8009124 <memp_free+0x48>)
 8009108:	0092      	lsls	r2, r2, #2
 800910a:	58d3      	ldr	r3, [r2, r3]
 800910c:	683a      	ldr	r2, [r7, #0]
 800910e:	0011      	movs	r1, r2
 8009110:	0018      	movs	r0, r3
 8009112:	f7ff ff97 	bl	8009044 <do_memp_free_pool>
 8009116:	e000      	b.n	800911a <memp_free+0x3e>
    return;
 8009118:	46c0      	nop			; (mov r8, r8)
#ifdef LWIP_HOOK_MEMP_AVAILABLE
  if (old_first == NULL) {
    LWIP_HOOK_MEMP_AVAILABLE(type);
  }
#endif
}
 800911a:	46bd      	mov	sp, r7
 800911c:	b002      	add	sp, #8
 800911e:	bd80      	pop	{r7, pc}
 8009120:	0801f680 	.word	0x0801f680
 8009124:	0802281c 	.word	0x0802281c

08009128 <netif_add>:
netif_add(struct netif *netif,
#if LWIP_IPV4
          const ip4_addr_t *ipaddr, const ip4_addr_t *netmask, const ip4_addr_t *gw,
#endif /* LWIP_IPV4 */
          void *state, netif_init_fn init, netif_input_fn input)
{
 8009128:	b580      	push	{r7, lr}
 800912a:	b086      	sub	sp, #24
 800912c:	af00      	add	r7, sp, #0
 800912e:	60f8      	str	r0, [r7, #12]
 8009130:	60b9      	str	r1, [r7, #8]
 8009132:	607a      	str	r2, [r7, #4]
 8009134:	603b      	str	r3, [r7, #0]
    LWIP_ASSERT("single netif already set", 0);
    return NULL;
  }
#endif

  LWIP_ERROR("netif_add: invalid netif", netif != NULL, return NULL);
 8009136:	68fb      	ldr	r3, [r7, #12]
 8009138:	2b00      	cmp	r3, #0
 800913a:	d105      	bne.n	8009148 <netif_add+0x20>
 800913c:	4b57      	ldr	r3, [pc, #348]	; (800929c <netif_add+0x174>)
 800913e:	0018      	movs	r0, r3
 8009140:	f7f9 fd42 	bl	8002bc8 <app_debug_rtt_raw>
 8009144:	2300      	movs	r3, #0
 8009146:	e0a5      	b.n	8009294 <netif_add+0x16c>
  LWIP_ERROR("netif_add: No init function given", init != NULL, return NULL);
 8009148:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800914a:	2b00      	cmp	r3, #0
 800914c:	d105      	bne.n	800915a <netif_add+0x32>
 800914e:	4b54      	ldr	r3, [pc, #336]	; (80092a0 <netif_add+0x178>)
 8009150:	0018      	movs	r0, r3
 8009152:	f7f9 fd39 	bl	8002bc8 <app_debug_rtt_raw>
 8009156:	2300      	movs	r3, #0
 8009158:	e09c      	b.n	8009294 <netif_add+0x16c>

#if LWIP_IPV4
  if (ipaddr == NULL) {
 800915a:	68bb      	ldr	r3, [r7, #8]
 800915c:	2b00      	cmp	r3, #0
 800915e:	d101      	bne.n	8009164 <netif_add+0x3c>
    ipaddr = ip_2_ip4(IP4_ADDR_ANY);
 8009160:	4b50      	ldr	r3, [pc, #320]	; (80092a4 <netif_add+0x17c>)
 8009162:	60bb      	str	r3, [r7, #8]
  }
  if (netmask == NULL) {
 8009164:	687b      	ldr	r3, [r7, #4]
 8009166:	2b00      	cmp	r3, #0
 8009168:	d101      	bne.n	800916e <netif_add+0x46>
    netmask = ip_2_ip4(IP4_ADDR_ANY);
 800916a:	4b4e      	ldr	r3, [pc, #312]	; (80092a4 <netif_add+0x17c>)
 800916c:	607b      	str	r3, [r7, #4]
  }
  if (gw == NULL) {
 800916e:	683b      	ldr	r3, [r7, #0]
 8009170:	2b00      	cmp	r3, #0
 8009172:	d101      	bne.n	8009178 <netif_add+0x50>
    gw = ip_2_ip4(IP4_ADDR_ANY);
 8009174:	4b4b      	ldr	r3, [pc, #300]	; (80092a4 <netif_add+0x17c>)
 8009176:	603b      	str	r3, [r7, #0]
  }

  /* reset new interface configuration state */
  ip_addr_set_zero_ip4(&netif->ip_addr);
 8009178:	68fb      	ldr	r3, [r7, #12]
 800917a:	2200      	movs	r2, #0
 800917c:	605a      	str	r2, [r3, #4]
  ip_addr_set_zero_ip4(&netif->netmask);
 800917e:	68fb      	ldr	r3, [r7, #12]
 8009180:	2200      	movs	r2, #0
 8009182:	609a      	str	r2, [r3, #8]
  ip_addr_set_zero_ip4(&netif->gw);
 8009184:	68fb      	ldr	r3, [r7, #12]
 8009186:	2200      	movs	r2, #0
 8009188:	60da      	str	r2, [r3, #12]
  netif->output = netif_null_output_ip4;
 800918a:	68fb      	ldr	r3, [r7, #12]
 800918c:	4a46      	ldr	r2, [pc, #280]	; (80092a8 <netif_add+0x180>)
 800918e:	615a      	str	r2, [r3, #20]
#endif /* LWIP_IPV6_ADDRESS_LIFETIMES */
  }
  netif->output_ip6 = netif_null_output_ip6;
#endif /* LWIP_IPV6 */
  NETIF_SET_CHECKSUM_CTRL(netif, NETIF_CHECKSUM_ENABLE_ALL);
  netif->mtu = 0;
 8009190:	68fb      	ldr	r3, [r7, #12]
 8009192:	2200      	movs	r2, #0
 8009194:	851a      	strh	r2, [r3, #40]	; 0x28
  netif->flags = 0;
 8009196:	68fb      	ldr	r3, [r7, #12]
 8009198:	2231      	movs	r2, #49	; 0x31
 800919a:	2100      	movs	r1, #0
 800919c:	5499      	strb	r1, [r3, r2]
  netif->ip6_autoconfig_enabled = 0;
#endif /* LWIP_IPV6_AUTOCONFIG */
  nd6_restart_netif(netif);
#endif /* LWIP_IPV6 */
#if LWIP_NETIF_STATUS_CALLBACK
  netif->status_callback = NULL;
 800919e:	68fb      	ldr	r3, [r7, #12]
 80091a0:	2200      	movs	r2, #0
 80091a2:	61da      	str	r2, [r3, #28]
#endif /* LWIP_NETIF_STATUS_CALLBACK */
#if LWIP_NETIF_LINK_CALLBACK
  netif->link_callback = NULL;
 80091a4:	68fb      	ldr	r3, [r7, #12]
 80091a6:	2200      	movs	r2, #0
 80091a8:	621a      	str	r2, [r3, #32]
#if LWIP_IPV6 && LWIP_IPV6_MLD
  netif->mld_mac_filter = NULL;
#endif /* LWIP_IPV6 && LWIP_IPV6_MLD */

  /* remember netif specific state information data */
  netif->state = state;
 80091aa:	68fb      	ldr	r3, [r7, #12]
 80091ac:	6a3a      	ldr	r2, [r7, #32]
 80091ae:	625a      	str	r2, [r3, #36]	; 0x24
  netif->num = netif_num;
 80091b0:	4b3e      	ldr	r3, [pc, #248]	; (80092ac <netif_add+0x184>)
 80091b2:	7819      	ldrb	r1, [r3, #0]
 80091b4:	68fb      	ldr	r3, [r7, #12]
 80091b6:	2234      	movs	r2, #52	; 0x34
 80091b8:	5499      	strb	r1, [r3, r2]
  netif->input = input;
 80091ba:	68fb      	ldr	r3, [r7, #12]
 80091bc:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80091be:	611a      	str	r2, [r3, #16]

  NETIF_RESET_HINTS(netif);
 80091c0:	68fb      	ldr	r3, [r7, #12]
 80091c2:	2200      	movs	r2, #0
 80091c4:	639a      	str	r2, [r3, #56]	; 0x38
  netif->reschedule_poll = 0;
#endif /* LWIP_NETIF_LOOPBACK_MULTITHREADING */
#endif /* ENABLE_LOOPBACK */

#if LWIP_IPV4
  netif_set_addr(netif, ipaddr, netmask, gw);
 80091c6:	683b      	ldr	r3, [r7, #0]
 80091c8:	687a      	ldr	r2, [r7, #4]
 80091ca:	68b9      	ldr	r1, [r7, #8]
 80091cc:	68f8      	ldr	r0, [r7, #12]
 80091ce:	f000 f91d 	bl	800940c <netif_set_addr>
#endif /* LWIP_IPV4 */

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
 80091d2:	68fa      	ldr	r2, [r7, #12]
 80091d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80091d6:	0010      	movs	r0, r2
 80091d8:	4798      	blx	r3
 80091da:	1e03      	subs	r3, r0, #0
 80091dc:	d001      	beq.n	80091e2 <netif_add+0xba>
    return NULL;
 80091de:	2300      	movs	r3, #0
 80091e0:	e058      	b.n	8009294 <netif_add+0x16c>
     */
  {
    struct netif *netif2;
    int num_netifs;
    do {
      if (netif->num == 255) {
 80091e2:	68fb      	ldr	r3, [r7, #12]
 80091e4:	2234      	movs	r2, #52	; 0x34
 80091e6:	5c9b      	ldrb	r3, [r3, r2]
 80091e8:	2bff      	cmp	r3, #255	; 0xff
 80091ea:	d103      	bne.n	80091f4 <netif_add+0xcc>
        netif->num = 0;
 80091ec:	68fb      	ldr	r3, [r7, #12]
 80091ee:	2234      	movs	r2, #52	; 0x34
 80091f0:	2100      	movs	r1, #0
 80091f2:	5499      	strb	r1, [r3, r2]
      }
      num_netifs = 0;
 80091f4:	2300      	movs	r3, #0
 80091f6:	613b      	str	r3, [r7, #16]
      for (netif2 = netif_list; netif2 != NULL; netif2 = netif2->next) {
 80091f8:	4b2d      	ldr	r3, [pc, #180]	; (80092b0 <netif_add+0x188>)
 80091fa:	681b      	ldr	r3, [r3, #0]
 80091fc:	617b      	str	r3, [r7, #20]
 80091fe:	e02b      	b.n	8009258 <netif_add+0x130>
        LWIP_ASSERT("netif already added", netif2 != netif);
 8009200:	697a      	ldr	r2, [r7, #20]
 8009202:	68fb      	ldr	r3, [r7, #12]
 8009204:	429a      	cmp	r2, r3
 8009206:	d106      	bne.n	8009216 <netif_add+0xee>
 8009208:	4b2a      	ldr	r3, [pc, #168]	; (80092b4 <netif_add+0x18c>)
 800920a:	22c7      	movs	r2, #199	; 0xc7
 800920c:	0052      	lsls	r2, r2, #1
 800920e:	492a      	ldr	r1, [pc, #168]	; (80092b8 <netif_add+0x190>)
 8009210:	482a      	ldr	r0, [pc, #168]	; (80092bc <netif_add+0x194>)
 8009212:	f7f9 fcd9 	bl	8002bc8 <app_debug_rtt_raw>
        num_netifs++;
 8009216:	693b      	ldr	r3, [r7, #16]
 8009218:	3301      	adds	r3, #1
 800921a:	613b      	str	r3, [r7, #16]
        LWIP_ASSERT("too many netifs, max. supported number is 255", num_netifs <= 255);
 800921c:	693b      	ldr	r3, [r7, #16]
 800921e:	2bff      	cmp	r3, #255	; 0xff
 8009220:	dd06      	ble.n	8009230 <netif_add+0x108>
 8009222:	4b24      	ldr	r3, [pc, #144]	; (80092b4 <netif_add+0x18c>)
 8009224:	22c8      	movs	r2, #200	; 0xc8
 8009226:	0052      	lsls	r2, r2, #1
 8009228:	4925      	ldr	r1, [pc, #148]	; (80092c0 <netif_add+0x198>)
 800922a:	4824      	ldr	r0, [pc, #144]	; (80092bc <netif_add+0x194>)
 800922c:	f7f9 fccc 	bl	8002bc8 <app_debug_rtt_raw>
        if (netif2->num == netif->num) {
 8009230:	697b      	ldr	r3, [r7, #20]
 8009232:	2234      	movs	r2, #52	; 0x34
 8009234:	5c9a      	ldrb	r2, [r3, r2]
 8009236:	68fb      	ldr	r3, [r7, #12]
 8009238:	2134      	movs	r1, #52	; 0x34
 800923a:	5c5b      	ldrb	r3, [r3, r1]
 800923c:	429a      	cmp	r2, r3
 800923e:	d108      	bne.n	8009252 <netif_add+0x12a>
          netif->num++;
 8009240:	68fb      	ldr	r3, [r7, #12]
 8009242:	2234      	movs	r2, #52	; 0x34
 8009244:	5c9b      	ldrb	r3, [r3, r2]
 8009246:	3301      	adds	r3, #1
 8009248:	b2d9      	uxtb	r1, r3
 800924a:	68fb      	ldr	r3, [r7, #12]
 800924c:	2234      	movs	r2, #52	; 0x34
 800924e:	5499      	strb	r1, [r3, r2]
          break;
 8009250:	e005      	b.n	800925e <netif_add+0x136>
      for (netif2 = netif_list; netif2 != NULL; netif2 = netif2->next) {
 8009252:	697b      	ldr	r3, [r7, #20]
 8009254:	681b      	ldr	r3, [r3, #0]
 8009256:	617b      	str	r3, [r7, #20]
 8009258:	697b      	ldr	r3, [r7, #20]
 800925a:	2b00      	cmp	r3, #0
 800925c:	d1d0      	bne.n	8009200 <netif_add+0xd8>
        }
      }
    } while (netif2 != NULL);
 800925e:	697b      	ldr	r3, [r7, #20]
 8009260:	2b00      	cmp	r3, #0
 8009262:	d1be      	bne.n	80091e2 <netif_add+0xba>
  }
  if (netif->num == 254) {
 8009264:	68fb      	ldr	r3, [r7, #12]
 8009266:	2234      	movs	r2, #52	; 0x34
 8009268:	5c9b      	ldrb	r3, [r3, r2]
 800926a:	2bfe      	cmp	r3, #254	; 0xfe
 800926c:	d103      	bne.n	8009276 <netif_add+0x14e>
    netif_num = 0;
 800926e:	4b0f      	ldr	r3, [pc, #60]	; (80092ac <netif_add+0x184>)
 8009270:	2200      	movs	r2, #0
 8009272:	701a      	strb	r2, [r3, #0]
 8009274:	e006      	b.n	8009284 <netif_add+0x15c>
  } else {
    netif_num = (u8_t)(netif->num + 1);
 8009276:	68fb      	ldr	r3, [r7, #12]
 8009278:	2234      	movs	r2, #52	; 0x34
 800927a:	5c9b      	ldrb	r3, [r3, r2]
 800927c:	3301      	adds	r3, #1
 800927e:	b2da      	uxtb	r2, r3
 8009280:	4b0a      	ldr	r3, [pc, #40]	; (80092ac <netif_add+0x184>)
 8009282:	701a      	strb	r2, [r3, #0]
  }

  /* add this netif to the list */
  netif->next = netif_list;
 8009284:	4b0a      	ldr	r3, [pc, #40]	; (80092b0 <netif_add+0x188>)
 8009286:	681a      	ldr	r2, [r3, #0]
 8009288:	68fb      	ldr	r3, [r7, #12]
 800928a:	601a      	str	r2, [r3, #0]
  netif_list = netif;
 800928c:	4b08      	ldr	r3, [pc, #32]	; (80092b0 <netif_add+0x188>)
 800928e:	68fa      	ldr	r2, [r7, #12]
 8009290:	601a      	str	r2, [r3, #0]
#endif /* LWIP_IPV4 */
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));

  netif_invoke_ext_callback(netif, LWIP_NSC_NETIF_ADDED, NULL);

  return netif;
 8009292:	68fb      	ldr	r3, [r7, #12]
}
 8009294:	0018      	movs	r0, r3
 8009296:	46bd      	mov	sp, r7
 8009298:	b006      	add	sp, #24
 800929a:	bd80      	pop	{r7, pc}
 800929c:	0801f728 	.word	0x0801f728
 80092a0:	0801f744 	.word	0x0801f744
 80092a4:	08022888 	.word	0x08022888
 80092a8:	080096b9 	.word	0x080096b9
 80092ac:	20001790 	.word	0x20001790
 80092b0:	20002b2c 	.word	0x20002b2c
 80092b4:	0801f69c 	.word	0x0801f69c
 80092b8:	0801f768 	.word	0x0801f768
 80092bc:	0801f6e0 	.word	0x0801f6e0
 80092c0:	0801f77c 	.word	0x0801f77c

080092c4 <netif_do_ip_addr_changed>:

static void
netif_do_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_addr)
{
 80092c4:	b580      	push	{r7, lr}
 80092c6:	b082      	sub	sp, #8
 80092c8:	af00      	add	r7, sp, #0
 80092ca:	6078      	str	r0, [r7, #4]
 80092cc:	6039      	str	r1, [r7, #0]
#if LWIP_TCP
  tcp_netif_ip_addr_changed(old_addr, new_addr);
 80092ce:	683a      	ldr	r2, [r7, #0]
 80092d0:	687b      	ldr	r3, [r7, #4]
 80092d2:	0011      	movs	r1, r2
 80092d4:	0018      	movs	r0, r3
 80092d6:	f003 fab5 	bl	800c844 <tcp_netif_ip_addr_changed>
#endif /* LWIP_TCP */
#if LWIP_UDP
  udp_netif_ip_addr_changed(old_addr, new_addr);
 80092da:	683a      	ldr	r2, [r7, #0]
 80092dc:	687b      	ldr	r3, [r7, #4]
 80092de:	0011      	movs	r1, r2
 80092e0:	0018      	movs	r0, r3
 80092e2:	f009 fe8f 	bl	8013004 <udp_netif_ip_addr_changed>
#endif /* LWIP_UDP */
#if LWIP_RAW
  raw_netif_ip_addr_changed(old_addr, new_addr);
#endif /* LWIP_RAW */
}
 80092e6:	46c0      	nop			; (mov r8, r8)
 80092e8:	46bd      	mov	sp, r7
 80092ea:	b002      	add	sp, #8
 80092ec:	bd80      	pop	{r7, pc}
	...

080092f0 <netif_do_set_ipaddr>:

#if LWIP_IPV4
static int
netif_do_set_ipaddr(struct netif *netif, const ip4_addr_t *ipaddr, ip_addr_t *old_addr)
{
 80092f0:	b580      	push	{r7, lr}
 80092f2:	b086      	sub	sp, #24
 80092f4:	af00      	add	r7, sp, #0
 80092f6:	60f8      	str	r0, [r7, #12]
 80092f8:	60b9      	str	r1, [r7, #8]
 80092fa:	607a      	str	r2, [r7, #4]
  LWIP_ASSERT("invalid pointer", ipaddr != NULL);
 80092fc:	68bb      	ldr	r3, [r7, #8]
 80092fe:	2b00      	cmp	r3, #0
 8009300:	d106      	bne.n	8009310 <netif_do_set_ipaddr+0x20>
 8009302:	4b22      	ldr	r3, [pc, #136]	; (800938c <netif_do_set_ipaddr+0x9c>)
 8009304:	22e7      	movs	r2, #231	; 0xe7
 8009306:	0052      	lsls	r2, r2, #1
 8009308:	4921      	ldr	r1, [pc, #132]	; (8009390 <netif_do_set_ipaddr+0xa0>)
 800930a:	4822      	ldr	r0, [pc, #136]	; (8009394 <netif_do_set_ipaddr+0xa4>)
 800930c:	f7f9 fc5c 	bl	8002bc8 <app_debug_rtt_raw>
  LWIP_ASSERT("invalid pointer", old_addr != NULL);
 8009310:	687b      	ldr	r3, [r7, #4]
 8009312:	2b00      	cmp	r3, #0
 8009314:	d106      	bne.n	8009324 <netif_do_set_ipaddr+0x34>
 8009316:	4b1d      	ldr	r3, [pc, #116]	; (800938c <netif_do_set_ipaddr+0x9c>)
 8009318:	22d0      	movs	r2, #208	; 0xd0
 800931a:	32ff      	adds	r2, #255	; 0xff
 800931c:	491c      	ldr	r1, [pc, #112]	; (8009390 <netif_do_set_ipaddr+0xa0>)
 800931e:	481d      	ldr	r0, [pc, #116]	; (8009394 <netif_do_set_ipaddr+0xa4>)
 8009320:	f7f9 fc52 	bl	8002bc8 <app_debug_rtt_raw>

  /* address is actually being changed? */
  if (ip4_addr_cmp(ipaddr, netif_ip4_addr(netif)) == 0) {
 8009324:	68bb      	ldr	r3, [r7, #8]
 8009326:	681a      	ldr	r2, [r3, #0]
 8009328:	68fb      	ldr	r3, [r7, #12]
 800932a:	3304      	adds	r3, #4
 800932c:	681b      	ldr	r3, [r3, #0]
 800932e:	429a      	cmp	r2, r3
 8009330:	d027      	beq.n	8009382 <netif_do_set_ipaddr+0x92>
    ip_addr_t new_addr;
    *ip_2_ip4(&new_addr) = *ipaddr;
 8009332:	68bb      	ldr	r3, [r7, #8]
 8009334:	681b      	ldr	r3, [r3, #0]
 8009336:	617b      	str	r3, [r7, #20]
    IP_SET_TYPE_VAL(new_addr, IPADDR_TYPE_V4);

    ip_addr_copy(*old_addr, *netif_ip_addr4(netif));
 8009338:	68fb      	ldr	r3, [r7, #12]
 800933a:	3304      	adds	r3, #4
 800933c:	681a      	ldr	r2, [r3, #0]
 800933e:	687b      	ldr	r3, [r7, #4]
 8009340:	601a      	str	r2, [r3, #0]

    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    netif_do_ip_addr_changed(old_addr, &new_addr);
 8009342:	2314      	movs	r3, #20
 8009344:	18fa      	adds	r2, r7, r3
 8009346:	687b      	ldr	r3, [r7, #4]
 8009348:	0011      	movs	r1, r2
 800934a:	0018      	movs	r0, r3
 800934c:	f7ff ffba 	bl	80092c4 <netif_do_ip_addr_changed>

    mib2_remove_ip4(netif);
    mib2_remove_route_ip4(0, netif);
    /* set new IP address to netif */
    ip4_addr_set(ip_2_ip4(&netif->ip_addr), ipaddr);
 8009350:	68bb      	ldr	r3, [r7, #8]
 8009352:	2b00      	cmp	r3, #0
 8009354:	d002      	beq.n	800935c <netif_do_set_ipaddr+0x6c>
 8009356:	68bb      	ldr	r3, [r7, #8]
 8009358:	681a      	ldr	r2, [r3, #0]
 800935a:	e000      	b.n	800935e <netif_do_set_ipaddr+0x6e>
 800935c:	2200      	movs	r2, #0
 800935e:	68fb      	ldr	r3, [r7, #12]
 8009360:	605a      	str	r2, [r3, #4]
    IP_SET_TYPE_VAL(netif->ip_addr, IPADDR_TYPE_V4);
    mib2_add_ip4(netif);
    mib2_add_route_ip4(0, netif);

    netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4);
 8009362:	68fb      	ldr	r3, [r7, #12]
 8009364:	2101      	movs	r1, #1
 8009366:	0018      	movs	r0, r3
 8009368:	f000 f8f8 	bl	800955c <netif_issue_reports>

    NETIF_STATUS_CALLBACK(netif);
 800936c:	68fb      	ldr	r3, [r7, #12]
 800936e:	69db      	ldr	r3, [r3, #28]
 8009370:	2b00      	cmp	r3, #0
 8009372:	d004      	beq.n	800937e <netif_do_set_ipaddr+0x8e>
 8009374:	68fb      	ldr	r3, [r7, #12]
 8009376:	69db      	ldr	r3, [r3, #28]
 8009378:	68fa      	ldr	r2, [r7, #12]
 800937a:	0010      	movs	r0, r2
 800937c:	4798      	blx	r3
    return 1; /* address changed */
 800937e:	2301      	movs	r3, #1
 8009380:	e000      	b.n	8009384 <netif_do_set_ipaddr+0x94>
  }
  return 0; /* address unchanged */
 8009382:	2300      	movs	r3, #0
}
 8009384:	0018      	movs	r0, r3
 8009386:	46bd      	mov	sp, r7
 8009388:	b006      	add	sp, #24
 800938a:	bd80      	pop	{r7, pc}
 800938c:	0801f69c 	.word	0x0801f69c
 8009390:	0801f7ac 	.word	0x0801f7ac
 8009394:	0801f6e0 	.word	0x0801f6e0

08009398 <netif_do_set_netmask>:
  }
}

static int
netif_do_set_netmask(struct netif *netif, const ip4_addr_t *netmask, ip_addr_t *old_nm)
{
 8009398:	b580      	push	{r7, lr}
 800939a:	b084      	sub	sp, #16
 800939c:	af00      	add	r7, sp, #0
 800939e:	60f8      	str	r0, [r7, #12]
 80093a0:	60b9      	str	r1, [r7, #8]
 80093a2:	607a      	str	r2, [r7, #4]
  /* address is actually being changed? */
  if (ip4_addr_cmp(netmask, netif_ip4_netmask(netif)) == 0) {
 80093a4:	68bb      	ldr	r3, [r7, #8]
 80093a6:	681a      	ldr	r2, [r3, #0]
 80093a8:	68fb      	ldr	r3, [r7, #12]
 80093aa:	3308      	adds	r3, #8
 80093ac:	681b      	ldr	r3, [r3, #0]
 80093ae:	429a      	cmp	r2, r3
 80093b0:	d00a      	beq.n	80093c8 <netif_do_set_netmask+0x30>
#else
    LWIP_UNUSED_ARG(old_nm);
#endif
    mib2_remove_route_ip4(0, netif);
    /* set new netmask to netif */
    ip4_addr_set(ip_2_ip4(&netif->netmask), netmask);
 80093b2:	68bb      	ldr	r3, [r7, #8]
 80093b4:	2b00      	cmp	r3, #0
 80093b6:	d002      	beq.n	80093be <netif_do_set_netmask+0x26>
 80093b8:	68bb      	ldr	r3, [r7, #8]
 80093ba:	681a      	ldr	r2, [r3, #0]
 80093bc:	e000      	b.n	80093c0 <netif_do_set_netmask+0x28>
 80093be:	2200      	movs	r2, #0
 80093c0:	68fb      	ldr	r3, [r7, #12]
 80093c2:	609a      	str	r2, [r3, #8]
                netif->name[0], netif->name[1],
                ip4_addr1_16(netif_ip4_netmask(netif)),
                ip4_addr2_16(netif_ip4_netmask(netif)),
                ip4_addr3_16(netif_ip4_netmask(netif)),
                ip4_addr4_16(netif_ip4_netmask(netif))));
    return 1; /* netmask changed */
 80093c4:	2301      	movs	r3, #1
 80093c6:	e000      	b.n	80093ca <netif_do_set_netmask+0x32>
  }
  return 0; /* netmask unchanged */
 80093c8:	2300      	movs	r3, #0
}
 80093ca:	0018      	movs	r0, r3
 80093cc:	46bd      	mov	sp, r7
 80093ce:	b004      	add	sp, #16
 80093d0:	bd80      	pop	{r7, pc}

080093d2 <netif_do_set_gw>:
  }
}

static int
netif_do_set_gw(struct netif *netif, const ip4_addr_t *gw, ip_addr_t *old_gw)
{
 80093d2:	b580      	push	{r7, lr}
 80093d4:	b084      	sub	sp, #16
 80093d6:	af00      	add	r7, sp, #0
 80093d8:	60f8      	str	r0, [r7, #12]
 80093da:	60b9      	str	r1, [r7, #8]
 80093dc:	607a      	str	r2, [r7, #4]
  /* address is actually being changed? */
  if (ip4_addr_cmp(gw, netif_ip4_gw(netif)) == 0) {
 80093de:	68bb      	ldr	r3, [r7, #8]
 80093e0:	681a      	ldr	r2, [r3, #0]
 80093e2:	68fb      	ldr	r3, [r7, #12]
 80093e4:	330c      	adds	r3, #12
 80093e6:	681b      	ldr	r3, [r3, #0]
 80093e8:	429a      	cmp	r2, r3
 80093ea:	d00a      	beq.n	8009402 <netif_do_set_gw+0x30>
    ip_addr_copy(*old_gw, *netif_ip_gw4(netif));
#else
    LWIP_UNUSED_ARG(old_gw);
#endif

    ip4_addr_set(ip_2_ip4(&netif->gw), gw);
 80093ec:	68bb      	ldr	r3, [r7, #8]
 80093ee:	2b00      	cmp	r3, #0
 80093f0:	d002      	beq.n	80093f8 <netif_do_set_gw+0x26>
 80093f2:	68bb      	ldr	r3, [r7, #8]
 80093f4:	681a      	ldr	r2, [r3, #0]
 80093f6:	e000      	b.n	80093fa <netif_do_set_gw+0x28>
 80093f8:	2200      	movs	r2, #0
 80093fa:	68fb      	ldr	r3, [r7, #12]
 80093fc:	60da      	str	r2, [r3, #12]
                netif->name[0], netif->name[1],
                ip4_addr1_16(netif_ip4_gw(netif)),
                ip4_addr2_16(netif_ip4_gw(netif)),
                ip4_addr3_16(netif_ip4_gw(netif)),
                ip4_addr4_16(netif_ip4_gw(netif))));
    return 1; /* gateway changed */
 80093fe:	2301      	movs	r3, #1
 8009400:	e000      	b.n	8009404 <netif_do_set_gw+0x32>
  }
  return 0; /* gateway unchanged */
 8009402:	2300      	movs	r3, #0
}
 8009404:	0018      	movs	r0, r3
 8009406:	46bd      	mov	sp, r7
 8009408:	b004      	add	sp, #16
 800940a:	bd80      	pop	{r7, pc}

0800940c <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, const ip4_addr_t *ipaddr, const ip4_addr_t *netmask,
               const ip4_addr_t *gw)
{
 800940c:	b580      	push	{r7, lr}
 800940e:	b088      	sub	sp, #32
 8009410:	af00      	add	r7, sp, #0
 8009412:	60f8      	str	r0, [r7, #12]
 8009414:	60b9      	str	r1, [r7, #8]
 8009416:	607a      	str	r2, [r7, #4]
 8009418:	603b      	str	r3, [r7, #0]
  ip_addr_t old_nm_val;
  ip_addr_t old_gw_val;
  ip_addr_t *old_nm = &old_nm_val;
  ip_addr_t *old_gw = &old_gw_val;
#else
  ip_addr_t *old_nm = NULL;
 800941a:	2300      	movs	r3, #0
 800941c:	61fb      	str	r3, [r7, #28]
  ip_addr_t *old_gw = NULL;
 800941e:	2300      	movs	r3, #0
 8009420:	61bb      	str	r3, [r7, #24]
  int remove;

  LWIP_ASSERT_CORE_LOCKED();

  /* Don't propagate NULL pointer (IPv4 ANY) to subsequent functions */
  if (ipaddr == NULL) {
 8009422:	68bb      	ldr	r3, [r7, #8]
 8009424:	2b00      	cmp	r3, #0
 8009426:	d101      	bne.n	800942c <netif_set_addr+0x20>
    ipaddr = IP4_ADDR_ANY4;
 8009428:	4b1d      	ldr	r3, [pc, #116]	; (80094a0 <netif_set_addr+0x94>)
 800942a:	60bb      	str	r3, [r7, #8]
  }
  if (netmask == NULL) {
 800942c:	687b      	ldr	r3, [r7, #4]
 800942e:	2b00      	cmp	r3, #0
 8009430:	d101      	bne.n	8009436 <netif_set_addr+0x2a>
    netmask = IP4_ADDR_ANY4;
 8009432:	4b1b      	ldr	r3, [pc, #108]	; (80094a0 <netif_set_addr+0x94>)
 8009434:	607b      	str	r3, [r7, #4]
  }
  if (gw == NULL) {
 8009436:	683b      	ldr	r3, [r7, #0]
 8009438:	2b00      	cmp	r3, #0
 800943a:	d101      	bne.n	8009440 <netif_set_addr+0x34>
    gw = IP4_ADDR_ANY4;
 800943c:	4b18      	ldr	r3, [pc, #96]	; (80094a0 <netif_set_addr+0x94>)
 800943e:	603b      	str	r3, [r7, #0]
  }

  remove = ip4_addr_isany(ipaddr);
 8009440:	68bb      	ldr	r3, [r7, #8]
 8009442:	2b00      	cmp	r3, #0
 8009444:	d003      	beq.n	800944e <netif_set_addr+0x42>
 8009446:	68bb      	ldr	r3, [r7, #8]
 8009448:	681b      	ldr	r3, [r3, #0]
 800944a:	2b00      	cmp	r3, #0
 800944c:	d101      	bne.n	8009452 <netif_set_addr+0x46>
 800944e:	2301      	movs	r3, #1
 8009450:	e000      	b.n	8009454 <netif_set_addr+0x48>
 8009452:	2300      	movs	r3, #0
 8009454:	617b      	str	r3, [r7, #20]
  if (remove) {
 8009456:	697b      	ldr	r3, [r7, #20]
 8009458:	2b00      	cmp	r3, #0
 800945a:	d006      	beq.n	800946a <netif_set_addr+0x5e>
    /* when removing an address, we have to remove it *before* changing netmask/gw
       to ensure that tcp RST segment can be sent correctly */
    if (netif_do_set_ipaddr(netif, ipaddr, &old_addr)) {
 800945c:	2310      	movs	r3, #16
 800945e:	18fa      	adds	r2, r7, r3
 8009460:	68b9      	ldr	r1, [r7, #8]
 8009462:	68fb      	ldr	r3, [r7, #12]
 8009464:	0018      	movs	r0, r3
 8009466:	f7ff ff43 	bl	80092f0 <netif_do_set_ipaddr>
      change_reason |= LWIP_NSC_IPV4_ADDRESS_CHANGED;
      cb_args.ipv4_changed.old_address = &old_addr;
#endif
    }
  }
  if (netif_do_set_netmask(netif, netmask, old_nm)) {
 800946a:	69fa      	ldr	r2, [r7, #28]
 800946c:	6879      	ldr	r1, [r7, #4]
 800946e:	68fb      	ldr	r3, [r7, #12]
 8009470:	0018      	movs	r0, r3
 8009472:	f7ff ff91 	bl	8009398 <netif_do_set_netmask>
#if LWIP_NETIF_EXT_STATUS_CALLBACK
    change_reason |= LWIP_NSC_IPV4_NETMASK_CHANGED;
    cb_args.ipv4_changed.old_netmask = old_nm;
#endif
  }
  if (netif_do_set_gw(netif, gw, old_gw)) {
 8009476:	69ba      	ldr	r2, [r7, #24]
 8009478:	6839      	ldr	r1, [r7, #0]
 800947a:	68fb      	ldr	r3, [r7, #12]
 800947c:	0018      	movs	r0, r3
 800947e:	f7ff ffa8 	bl	80093d2 <netif_do_set_gw>
#if LWIP_NETIF_EXT_STATUS_CALLBACK
    change_reason |= LWIP_NSC_IPV4_GATEWAY_CHANGED;
    cb_args.ipv4_changed.old_gw = old_gw;
#endif
  }
  if (!remove) {
 8009482:	697b      	ldr	r3, [r7, #20]
 8009484:	2b00      	cmp	r3, #0
 8009486:	d106      	bne.n	8009496 <netif_set_addr+0x8a>
    /* set ipaddr last to ensure netmask/gw have been set when status callback is called */
    if (netif_do_set_ipaddr(netif, ipaddr, &old_addr)) {
 8009488:	2310      	movs	r3, #16
 800948a:	18fa      	adds	r2, r7, r3
 800948c:	68b9      	ldr	r1, [r7, #8]
 800948e:	68fb      	ldr	r3, [r7, #12]
 8009490:	0018      	movs	r0, r3
 8009492:	f7ff ff2d 	bl	80092f0 <netif_do_set_ipaddr>
  if (change_reason != LWIP_NSC_NONE) {
    change_reason |= LWIP_NSC_IPV4_SETTINGS_CHANGED;
    netif_invoke_ext_callback(netif, change_reason, &cb_args);
  }
#endif
}
 8009496:	46c0      	nop			; (mov r8, r8)
 8009498:	46bd      	mov	sp, r7
 800949a:	b008      	add	sp, #32
 800949c:	bd80      	pop	{r7, pc}
 800949e:	46c0      	nop			; (mov r8, r8)
 80094a0:	08022888 	.word	0x08022888

080094a4 <netif_remove>:
 *
 * @param netif the network interface to remove
 */
void
netif_remove(struct netif *netif)
{
 80094a4:	b580      	push	{r7, lr}
 80094a6:	b084      	sub	sp, #16
 80094a8:	af00      	add	r7, sp, #0
 80094aa:	6078      	str	r0, [r7, #4]
  int i;
#endif

  LWIP_ASSERT_CORE_LOCKED();

  if (netif == NULL) {
 80094ac:	687b      	ldr	r3, [r7, #4]
 80094ae:	2b00      	cmp	r3, #0
 80094b0:	d03e      	beq.n	8009530 <netif_remove+0x8c>
  }

  netif_invoke_ext_callback(netif, LWIP_NSC_NETIF_REMOVED, NULL);

#if LWIP_IPV4
  if (!ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 80094b2:	687b      	ldr	r3, [r7, #4]
 80094b4:	3304      	adds	r3, #4
 80094b6:	681b      	ldr	r3, [r3, #0]
 80094b8:	2b00      	cmp	r3, #0
 80094ba:	d005      	beq.n	80094c8 <netif_remove+0x24>
    netif_do_ip_addr_changed(netif_ip_addr4(netif), NULL);
 80094bc:	687b      	ldr	r3, [r7, #4]
 80094be:	3304      	adds	r3, #4
 80094c0:	2100      	movs	r1, #0
 80094c2:	0018      	movs	r0, r3
 80094c4:	f7ff fefe 	bl	80092c4 <netif_do_ip_addr_changed>
#if LWIP_IPV6_MLD
  /* stop MLD processing */
  mld6_stop(netif);
#endif /* LWIP_IPV6_MLD */
#endif /* LWIP_IPV6 */
  if (netif_is_up(netif)) {
 80094c8:	687b      	ldr	r3, [r7, #4]
 80094ca:	2231      	movs	r2, #49	; 0x31
 80094cc:	5c9b      	ldrb	r3, [r3, r2]
 80094ce:	1c1a      	adds	r2, r3, #0
 80094d0:	2301      	movs	r3, #1
 80094d2:	4013      	ands	r3, r2
 80094d4:	b2db      	uxtb	r3, r3
 80094d6:	2b00      	cmp	r3, #0
 80094d8:	d003      	beq.n	80094e2 <netif_remove+0x3e>
    /* set netif down before removing (call callback function) */
    netif_set_down(netif);
 80094da:	687b      	ldr	r3, [r7, #4]
 80094dc:	0018      	movs	r0, r3
 80094de:	f000 f867 	bl	80095b0 <netif_set_down>
  }

  mib2_remove_ip4(netif);

  /* this netif is default? */
  if (netif_default == netif) {
 80094e2:	4b15      	ldr	r3, [pc, #84]	; (8009538 <netif_remove+0x94>)
 80094e4:	681b      	ldr	r3, [r3, #0]
 80094e6:	687a      	ldr	r2, [r7, #4]
 80094e8:	429a      	cmp	r2, r3
 80094ea:	d102      	bne.n	80094f2 <netif_remove+0x4e>
    /* reset default netif */
    netif_set_default(NULL);
 80094ec:	2000      	movs	r0, #0
 80094ee:	f000 f827 	bl	8009540 <netif_set_default>
  }
#if !LWIP_SINGLE_NETIF
  /*  is it the first netif? */
  if (netif_list == netif) {
 80094f2:	4b12      	ldr	r3, [pc, #72]	; (800953c <netif_remove+0x98>)
 80094f4:	681b      	ldr	r3, [r3, #0]
 80094f6:	687a      	ldr	r2, [r7, #4]
 80094f8:	429a      	cmp	r2, r3
 80094fa:	d104      	bne.n	8009506 <netif_remove+0x62>
    netif_list = netif->next;
 80094fc:	687b      	ldr	r3, [r7, #4]
 80094fe:	681a      	ldr	r2, [r3, #0]
 8009500:	4b0e      	ldr	r3, [pc, #56]	; (800953c <netif_remove+0x98>)
 8009502:	601a      	str	r2, [r3, #0]
 8009504:	e015      	b.n	8009532 <netif_remove+0x8e>
  } else {
    /*  look for netif further down the list */
    struct netif *tmp_netif;
    NETIF_FOREACH(tmp_netif) {
 8009506:	4b0d      	ldr	r3, [pc, #52]	; (800953c <netif_remove+0x98>)
 8009508:	681b      	ldr	r3, [r3, #0]
 800950a:	60fb      	str	r3, [r7, #12]
 800950c:	e00c      	b.n	8009528 <netif_remove+0x84>
      if (tmp_netif->next == netif) {
 800950e:	68fb      	ldr	r3, [r7, #12]
 8009510:	681b      	ldr	r3, [r3, #0]
 8009512:	687a      	ldr	r2, [r7, #4]
 8009514:	429a      	cmp	r2, r3
 8009516:	d104      	bne.n	8009522 <netif_remove+0x7e>
        tmp_netif->next = netif->next;
 8009518:	687b      	ldr	r3, [r7, #4]
 800951a:	681a      	ldr	r2, [r3, #0]
 800951c:	68fb      	ldr	r3, [r7, #12]
 800951e:	601a      	str	r2, [r3, #0]
        break;
 8009520:	e007      	b.n	8009532 <netif_remove+0x8e>
    NETIF_FOREACH(tmp_netif) {
 8009522:	68fb      	ldr	r3, [r7, #12]
 8009524:	681b      	ldr	r3, [r3, #0]
 8009526:	60fb      	str	r3, [r7, #12]
 8009528:	68fb      	ldr	r3, [r7, #12]
 800952a:	2b00      	cmp	r3, #0
 800952c:	d1ef      	bne.n	800950e <netif_remove+0x6a>
 800952e:	e000      	b.n	8009532 <netif_remove+0x8e>
    return;
 8009530:	46c0      	nop			; (mov r8, r8)
  if (netif->remove_callback) {
    netif->remove_callback(netif);
  }
#endif /* LWIP_NETIF_REMOVE_CALLBACK */
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
 8009532:	46bd      	mov	sp, r7
 8009534:	b004      	add	sp, #16
 8009536:	bd80      	pop	{r7, pc}
 8009538:	20002b30 	.word	0x20002b30
 800953c:	20002b2c 	.word	0x20002b2c

08009540 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
 8009540:	b580      	push	{r7, lr}
 8009542:	b082      	sub	sp, #8
 8009544:	af00      	add	r7, sp, #0
 8009546:	6078      	str	r0, [r7, #4]
    mib2_remove_route_ip4(1, netif);
  } else {
    /* install default route */
    mib2_add_route_ip4(1, netif);
  }
  netif_default = netif;
 8009548:	4b03      	ldr	r3, [pc, #12]	; (8009558 <netif_set_default+0x18>)
 800954a:	687a      	ldr	r2, [r7, #4]
 800954c:	601a      	str	r2, [r3, #0]
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
                            netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
 800954e:	46c0      	nop			; (mov r8, r8)
 8009550:	46bd      	mov	sp, r7
 8009552:	b002      	add	sp, #8
 8009554:	bd80      	pop	{r7, pc}
 8009556:	46c0      	nop			; (mov r8, r8)
 8009558:	20002b30 	.word	0x20002b30

0800955c <netif_issue_reports>:

/** Send ARP/IGMP/MLD/RS events, e.g. on link-up/netif-up or addr-change
 */
static void
netif_issue_reports(struct netif *netif, u8_t report_type)
{
 800955c:	b580      	push	{r7, lr}
 800955e:	b082      	sub	sp, #8
 8009560:	af00      	add	r7, sp, #0
 8009562:	6078      	str	r0, [r7, #4]
 8009564:	000a      	movs	r2, r1
 8009566:	1cfb      	adds	r3, r7, #3
 8009568:	701a      	strb	r2, [r3, #0]
  LWIP_ASSERT("netif_issue_reports: invalid netif", netif != NULL);
 800956a:	687b      	ldr	r3, [r7, #4]
 800956c:	2b00      	cmp	r3, #0
 800956e:	d106      	bne.n	800957e <netif_issue_reports+0x22>
 8009570:	4b0c      	ldr	r3, [pc, #48]	; (80095a4 <netif_issue_reports+0x48>)
 8009572:	22dc      	movs	r2, #220	; 0xdc
 8009574:	0092      	lsls	r2, r2, #2
 8009576:	490c      	ldr	r1, [pc, #48]	; (80095a8 <netif_issue_reports+0x4c>)
 8009578:	480c      	ldr	r0, [pc, #48]	; (80095ac <netif_issue_reports+0x50>)
 800957a:	f7f9 fb25 	bl	8002bc8 <app_debug_rtt_raw>

  /* Only send reports when both link and admin states are up */
  if (!(netif->flags & NETIF_FLAG_LINK_UP) ||
 800957e:	687b      	ldr	r3, [r7, #4]
 8009580:	2231      	movs	r2, #49	; 0x31
 8009582:	5c9b      	ldrb	r3, [r3, r2]
 8009584:	001a      	movs	r2, r3
 8009586:	2304      	movs	r3, #4
 8009588:	4013      	ands	r3, r2
 800958a:	d007      	beq.n	800959c <netif_issue_reports+0x40>
      !(netif->flags & NETIF_FLAG_UP)) {
 800958c:	687b      	ldr	r3, [r7, #4]
 800958e:	2231      	movs	r2, #49	; 0x31
 8009590:	5c9b      	ldrb	r3, [r3, r2]
 8009592:	001a      	movs	r2, r3
 8009594:	2301      	movs	r3, #1
 8009596:	4013      	ands	r3, r2
  if (!(netif->flags & NETIF_FLAG_LINK_UP) ||
 8009598:	d000      	beq.n	800959c <netif_issue_reports+0x40>
 800959a:	e000      	b.n	800959e <netif_issue_reports+0x42>
    return;
 800959c:	46c0      	nop			; (mov r8, r8)
    /* send mld memberships */
    mld6_report_groups(netif);
#endif /* LWIP_IPV6_MLD */
  }
#endif /* LWIP_IPV6 */
}
 800959e:	46bd      	mov	sp, r7
 80095a0:	b002      	add	sp, #8
 80095a2:	bd80      	pop	{r7, pc}
 80095a4:	0801f69c 	.word	0x0801f69c
 80095a8:	0801f838 	.word	0x0801f838
 80095ac:	0801f6e0 	.word	0x0801f6e0

080095b0 <netif_set_down>:
 * @ingroup netif
 * Bring an interface down, disabling any traffic processing.
 */
void
netif_set_down(struct netif *netif)
{
 80095b0:	b580      	push	{r7, lr}
 80095b2:	b082      	sub	sp, #8
 80095b4:	af00      	add	r7, sp, #0
 80095b6:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif_set_down: invalid netif", netif != NULL, return);
 80095b8:	687b      	ldr	r3, [r7, #4]
 80095ba:	2b00      	cmp	r3, #0
 80095bc:	d104      	bne.n	80095c8 <netif_set_down+0x18>
 80095be:	4b10      	ldr	r3, [pc, #64]	; (8009600 <netif_set_down+0x50>)
 80095c0:	0018      	movs	r0, r3
 80095c2:	f7f9 fb01 	bl	8002bc8 <app_debug_rtt_raw>
 80095c6:	e018      	b.n	80095fa <netif_set_down+0x4a>

  if (netif->flags & NETIF_FLAG_UP) {
 80095c8:	687b      	ldr	r3, [r7, #4]
 80095ca:	2231      	movs	r2, #49	; 0x31
 80095cc:	5c9b      	ldrb	r3, [r3, r2]
 80095ce:	001a      	movs	r2, r3
 80095d0:	2301      	movs	r3, #1
 80095d2:	4013      	ands	r3, r2
 80095d4:	d011      	beq.n	80095fa <netif_set_down+0x4a>
      args.status_changed.state = 0;
      netif_invoke_ext_callback(netif, LWIP_NSC_STATUS_CHANGED, &args);
    }
#endif

    netif_clear_flags(netif, NETIF_FLAG_UP);
 80095d6:	687b      	ldr	r3, [r7, #4]
 80095d8:	2231      	movs	r2, #49	; 0x31
 80095da:	5c9b      	ldrb	r3, [r3, r2]
 80095dc:	2201      	movs	r2, #1
 80095de:	4393      	bics	r3, r2
 80095e0:	b2d9      	uxtb	r1, r3
 80095e2:	687b      	ldr	r3, [r7, #4]
 80095e4:	2231      	movs	r2, #49	; 0x31
 80095e6:	5499      	strb	r1, [r3, r2]

#if LWIP_IPV6
    nd6_cleanup_netif(netif);
#endif /* LWIP_IPV6 */

    NETIF_STATUS_CALLBACK(netif);
 80095e8:	687b      	ldr	r3, [r7, #4]
 80095ea:	69db      	ldr	r3, [r3, #28]
 80095ec:	2b00      	cmp	r3, #0
 80095ee:	d004      	beq.n	80095fa <netif_set_down+0x4a>
 80095f0:	687b      	ldr	r3, [r7, #4]
 80095f2:	69db      	ldr	r3, [r3, #28]
 80095f4:	687a      	ldr	r2, [r7, #4]
 80095f6:	0010      	movs	r0, r2
 80095f8:	4798      	blx	r3
  }
}
 80095fa:	46bd      	mov	sp, r7
 80095fc:	b002      	add	sp, #8
 80095fe:	bd80      	pop	{r7, pc}
 8009600:	0801f85c 	.word	0x0801f85c

08009604 <netif_set_link_up>:
 * @ingroup netif
 * Called by a driver when its link goes up
 */
void
netif_set_link_up(struct netif *netif)
{
 8009604:	b580      	push	{r7, lr}
 8009606:	b082      	sub	sp, #8
 8009608:	af00      	add	r7, sp, #0
 800960a:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif_set_link_up: invalid netif", netif != NULL, return);
 800960c:	687b      	ldr	r3, [r7, #4]
 800960e:	2b00      	cmp	r3, #0
 8009610:	d104      	bne.n	800961c <netif_set_link_up+0x18>
 8009612:	4b13      	ldr	r3, [pc, #76]	; (8009660 <netif_set_link_up+0x5c>)
 8009614:	0018      	movs	r0, r3
 8009616:	f7f9 fad7 	bl	8002bc8 <app_debug_rtt_raw>
 800961a:	e01d      	b.n	8009658 <netif_set_link_up+0x54>

  if (!(netif->flags & NETIF_FLAG_LINK_UP)) {
 800961c:	687b      	ldr	r3, [r7, #4]
 800961e:	2231      	movs	r2, #49	; 0x31
 8009620:	5c9b      	ldrb	r3, [r3, r2]
 8009622:	001a      	movs	r2, r3
 8009624:	2304      	movs	r3, #4
 8009626:	4013      	ands	r3, r2
 8009628:	d116      	bne.n	8009658 <netif_set_link_up+0x54>
    netif_set_flags(netif, NETIF_FLAG_LINK_UP);
 800962a:	687b      	ldr	r3, [r7, #4]
 800962c:	2231      	movs	r2, #49	; 0x31
 800962e:	5c9b      	ldrb	r3, [r3, r2]
 8009630:	2204      	movs	r2, #4
 8009632:	4313      	orrs	r3, r2
 8009634:	b2d9      	uxtb	r1, r3
 8009636:	687b      	ldr	r3, [r7, #4]
 8009638:	2231      	movs	r2, #49	; 0x31
 800963a:	5499      	strb	r1, [r3, r2]

#if LWIP_AUTOIP
    autoip_network_changed(netif);
#endif /* LWIP_AUTOIP */

    netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4 | NETIF_REPORT_TYPE_IPV6);
 800963c:	687b      	ldr	r3, [r7, #4]
 800963e:	2103      	movs	r1, #3
 8009640:	0018      	movs	r0, r3
 8009642:	f7ff ff8b 	bl	800955c <netif_issue_reports>
#if LWIP_IPV6
    nd6_restart_netif(netif);
#endif /* LWIP_IPV6 */

    NETIF_LINK_CALLBACK(netif);
 8009646:	687b      	ldr	r3, [r7, #4]
 8009648:	6a1b      	ldr	r3, [r3, #32]
 800964a:	2b00      	cmp	r3, #0
 800964c:	d004      	beq.n	8009658 <netif_set_link_up+0x54>
 800964e:	687b      	ldr	r3, [r7, #4]
 8009650:	6a1b      	ldr	r3, [r3, #32]
 8009652:	687a      	ldr	r2, [r7, #4]
 8009654:	0010      	movs	r0, r2
 8009656:	4798      	blx	r3
      args.link_changed.state = 1;
      netif_invoke_ext_callback(netif, LWIP_NSC_LINK_CHANGED, &args);
    }
#endif
  }
}
 8009658:	46bd      	mov	sp, r7
 800965a:	b002      	add	sp, #8
 800965c:	bd80      	pop	{r7, pc}
 800965e:	46c0      	nop			; (mov r8, r8)
 8009660:	0801f87c 	.word	0x0801f87c

08009664 <netif_set_link_down>:
 * @ingroup netif
 * Called by a driver when its link goes down
 */
void
netif_set_link_down(struct netif *netif)
{
 8009664:	b580      	push	{r7, lr}
 8009666:	b082      	sub	sp, #8
 8009668:	af00      	add	r7, sp, #0
 800966a:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif_set_link_down: invalid netif", netif != NULL, return);
 800966c:	687b      	ldr	r3, [r7, #4]
 800966e:	2b00      	cmp	r3, #0
 8009670:	d104      	bne.n	800967c <netif_set_link_down+0x18>
 8009672:	4b10      	ldr	r3, [pc, #64]	; (80096b4 <netif_set_link_down+0x50>)
 8009674:	0018      	movs	r0, r3
 8009676:	f7f9 faa7 	bl	8002bc8 <app_debug_rtt_raw>
 800967a:	e018      	b.n	80096ae <netif_set_link_down+0x4a>

  if (netif->flags & NETIF_FLAG_LINK_UP) {
 800967c:	687b      	ldr	r3, [r7, #4]
 800967e:	2231      	movs	r2, #49	; 0x31
 8009680:	5c9b      	ldrb	r3, [r3, r2]
 8009682:	001a      	movs	r2, r3
 8009684:	2304      	movs	r3, #4
 8009686:	4013      	ands	r3, r2
 8009688:	d011      	beq.n	80096ae <netif_set_link_down+0x4a>
    netif_clear_flags(netif, NETIF_FLAG_LINK_UP);
 800968a:	687b      	ldr	r3, [r7, #4]
 800968c:	2231      	movs	r2, #49	; 0x31
 800968e:	5c9b      	ldrb	r3, [r3, r2]
 8009690:	2204      	movs	r2, #4
 8009692:	4393      	bics	r3, r2
 8009694:	b2d9      	uxtb	r1, r3
 8009696:	687b      	ldr	r3, [r7, #4]
 8009698:	2231      	movs	r2, #49	; 0x31
 800969a:	5499      	strb	r1, [r3, r2]
#if LWIP_IPV6 && LWIP_ND6_ALLOW_RA_UPDATES
    netif->mtu6 = netif->mtu;
#endif

    NETIF_LINK_CALLBACK(netif);
 800969c:	687b      	ldr	r3, [r7, #4]
 800969e:	6a1b      	ldr	r3, [r3, #32]
 80096a0:	2b00      	cmp	r3, #0
 80096a2:	d004      	beq.n	80096ae <netif_set_link_down+0x4a>
 80096a4:	687b      	ldr	r3, [r7, #4]
 80096a6:	6a1b      	ldr	r3, [r3, #32]
 80096a8:	687a      	ldr	r2, [r7, #4]
 80096aa:	0010      	movs	r0, r2
 80096ac:	4798      	blx	r3
      args.link_changed.state = 0;
      netif_invoke_ext_callback(netif, LWIP_NSC_LINK_CHANGED, &args);
    }
#endif
  }
}
 80096ae:	46bd      	mov	sp, r7
 80096b0:	b002      	add	sp, #8
 80096b2:	bd80      	pop	{r7, pc}
 80096b4:	0801f8a0 	.word	0x0801f8a0

080096b8 <netif_null_output_ip4>:
#if LWIP_IPV4
/** Dummy IPv4 output function for netifs not supporting IPv4
 */
static err_t
netif_null_output_ip4(struct netif *netif, struct pbuf *p, const ip4_addr_t *ipaddr)
{
 80096b8:	b580      	push	{r7, lr}
 80096ba:	b084      	sub	sp, #16
 80096bc:	af00      	add	r7, sp, #0
 80096be:	60f8      	str	r0, [r7, #12]
 80096c0:	60b9      	str	r1, [r7, #8]
 80096c2:	607a      	str	r2, [r7, #4]
  LWIP_UNUSED_ARG(netif);
  LWIP_UNUSED_ARG(p);
  LWIP_UNUSED_ARG(ipaddr);

  return ERR_IF;
 80096c4:	230c      	movs	r3, #12
 80096c6:	425b      	negs	r3, r3
}
 80096c8:	0018      	movs	r0, r3
 80096ca:	46bd      	mov	sp, r7
 80096cc:	b004      	add	sp, #16
 80096ce:	bd80      	pop	{r7, pc}

080096d0 <netif_get_by_index>:
*
* @param idx index of netif to find
*/
struct netif *
netif_get_by_index(u8_t idx)
{
 80096d0:	b580      	push	{r7, lr}
 80096d2:	b084      	sub	sp, #16
 80096d4:	af00      	add	r7, sp, #0
 80096d6:	0002      	movs	r2, r0
 80096d8:	1dfb      	adds	r3, r7, #7
 80096da:	701a      	strb	r2, [r3, #0]
  struct netif *netif;

  LWIP_ASSERT_CORE_LOCKED();

  if (idx != NETIF_NO_INDEX) {
 80096dc:	1dfb      	adds	r3, r7, #7
 80096de:	781b      	ldrb	r3, [r3, #0]
 80096e0:	2b00      	cmp	r3, #0
 80096e2:	d014      	beq.n	800970e <netif_get_by_index+0x3e>
    NETIF_FOREACH(netif) {
 80096e4:	4b0c      	ldr	r3, [pc, #48]	; (8009718 <netif_get_by_index+0x48>)
 80096e6:	681b      	ldr	r3, [r3, #0]
 80096e8:	60fb      	str	r3, [r7, #12]
 80096ea:	e00d      	b.n	8009708 <netif_get_by_index+0x38>
      if (idx == netif_get_index(netif)) {
 80096ec:	68fb      	ldr	r3, [r7, #12]
 80096ee:	2234      	movs	r2, #52	; 0x34
 80096f0:	5c9b      	ldrb	r3, [r3, r2]
 80096f2:	3301      	adds	r3, #1
 80096f4:	b2db      	uxtb	r3, r3
 80096f6:	1dfa      	adds	r2, r7, #7
 80096f8:	7812      	ldrb	r2, [r2, #0]
 80096fa:	429a      	cmp	r2, r3
 80096fc:	d101      	bne.n	8009702 <netif_get_by_index+0x32>
        return netif; /* found! */
 80096fe:	68fb      	ldr	r3, [r7, #12]
 8009700:	e006      	b.n	8009710 <netif_get_by_index+0x40>
    NETIF_FOREACH(netif) {
 8009702:	68fb      	ldr	r3, [r7, #12]
 8009704:	681b      	ldr	r3, [r3, #0]
 8009706:	60fb      	str	r3, [r7, #12]
 8009708:	68fb      	ldr	r3, [r7, #12]
 800970a:	2b00      	cmp	r3, #0
 800970c:	d1ee      	bne.n	80096ec <netif_get_by_index+0x1c>
      }
    }
  }

  return NULL;
 800970e:	2300      	movs	r3, #0
}
 8009710:	0018      	movs	r0, r3
 8009712:	46bd      	mov	sp, r7
 8009714:	b004      	add	sp, #16
 8009716:	bd80      	pop	{r7, pc}
 8009718:	20002b2c 	.word	0x20002b2c

0800971c <pbuf_free_ooseq>:
#if !NO_SYS
static
#endif /* !NO_SYS */
void
pbuf_free_ooseq(void)
{
 800971c:	b580      	push	{r7, lr}
 800971e:	b082      	sub	sp, #8
 8009720:	af00      	add	r7, sp, #0
  struct tcp_pcb *pcb;
  SYS_ARCH_SET(pbuf_free_ooseq_pending, 0);
 8009722:	4b0c      	ldr	r3, [pc, #48]	; (8009754 <pbuf_free_ooseq+0x38>)
 8009724:	2200      	movs	r2, #0
 8009726:	701a      	strb	r2, [r3, #0]

  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
 8009728:	4b0b      	ldr	r3, [pc, #44]	; (8009758 <pbuf_free_ooseq+0x3c>)
 800972a:	681b      	ldr	r3, [r3, #0]
 800972c:	607b      	str	r3, [r7, #4]
 800972e:	e00b      	b.n	8009748 <pbuf_free_ooseq+0x2c>
    if (pcb->ooseq != NULL) {
 8009730:	687b      	ldr	r3, [r7, #4]
 8009732:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8009734:	2b00      	cmp	r3, #0
 8009736:	d004      	beq.n	8009742 <pbuf_free_ooseq+0x26>
      /** Free the ooseq pbufs of one PCB only */
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free_ooseq: freeing out-of-sequence pbufs\n"));
      tcp_free_ooseq(pcb);
 8009738:	687b      	ldr	r3, [r7, #4]
 800973a:	0018      	movs	r0, r3
 800973c:	f003 f8c2 	bl	800c8c4 <tcp_free_ooseq>
      return;
 8009740:	e005      	b.n	800974e <pbuf_free_ooseq+0x32>
  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
 8009742:	687b      	ldr	r3, [r7, #4]
 8009744:	691b      	ldr	r3, [r3, #16]
 8009746:	607b      	str	r3, [r7, #4]
 8009748:	687b      	ldr	r3, [r7, #4]
 800974a:	2b00      	cmp	r3, #0
 800974c:	d1f0      	bne.n	8009730 <pbuf_free_ooseq+0x14>
    }
  }
}
 800974e:	46bd      	mov	sp, r7
 8009750:	b002      	add	sp, #8
 8009752:	bd80      	pop	{r7, pc}
 8009754:	20002b34 	.word	0x20002b34
 8009758:	20002b3c 	.word	0x20002b3c

0800975c <pbuf_pool_is_empty>:
#endif /* !NO_SYS */

/** Queue a call to pbuf_free_ooseq if not already queued. */
static void
pbuf_pool_is_empty(void)
{
 800975c:	b580      	push	{r7, lr}
 800975e:	af00      	add	r7, sp, #0
#ifndef PBUF_POOL_FREE_OOSEQ_QUEUE_CALL
  SYS_ARCH_SET(pbuf_free_ooseq_pending, 1);
 8009760:	4b02      	ldr	r3, [pc, #8]	; (800976c <pbuf_pool_is_empty+0x10>)
 8009762:	2201      	movs	r2, #1
 8009764:	701a      	strb	r2, [r3, #0]
  if (!queued) {
    /* queue a call to pbuf_free_ooseq if not already queued */
    PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
  }
#endif /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
}
 8009766:	46c0      	nop			; (mov r8, r8)
 8009768:	46bd      	mov	sp, r7
 800976a:	bd80      	pop	{r7, pc}
 800976c:	20002b34 	.word	0x20002b34

08009770 <pbuf_init_alloced_pbuf>:
#endif /* !LWIP_TCP || !TCP_QUEUE_OOSEQ || !PBUF_POOL_FREE_OOSEQ */

/* Initialize members of struct pbuf after allocation */
static void
pbuf_init_alloced_pbuf(struct pbuf *p, void *payload, u16_t tot_len, u16_t len, pbuf_type type, u8_t flags)
{
 8009770:	b580      	push	{r7, lr}
 8009772:	b084      	sub	sp, #16
 8009774:	af00      	add	r7, sp, #0
 8009776:	60f8      	str	r0, [r7, #12]
 8009778:	60b9      	str	r1, [r7, #8]
 800977a:	0019      	movs	r1, r3
 800977c:	1dbb      	adds	r3, r7, #6
 800977e:	801a      	strh	r2, [r3, #0]
 8009780:	1d3b      	adds	r3, r7, #4
 8009782:	1c0a      	adds	r2, r1, #0
 8009784:	801a      	strh	r2, [r3, #0]
  p->next = NULL;
 8009786:	68fb      	ldr	r3, [r7, #12]
 8009788:	2200      	movs	r2, #0
 800978a:	601a      	str	r2, [r3, #0]
  p->payload = payload;
 800978c:	68fb      	ldr	r3, [r7, #12]
 800978e:	68ba      	ldr	r2, [r7, #8]
 8009790:	605a      	str	r2, [r3, #4]
  p->tot_len = tot_len;
 8009792:	68fb      	ldr	r3, [r7, #12]
 8009794:	1dba      	adds	r2, r7, #6
 8009796:	8812      	ldrh	r2, [r2, #0]
 8009798:	811a      	strh	r2, [r3, #8]
  p->len = len;
 800979a:	68fb      	ldr	r3, [r7, #12]
 800979c:	1d3a      	adds	r2, r7, #4
 800979e:	8812      	ldrh	r2, [r2, #0]
 80097a0:	815a      	strh	r2, [r3, #10]
  p->type_internal = (u8_t)type;
 80097a2:	2318      	movs	r3, #24
 80097a4:	18fb      	adds	r3, r7, r3
 80097a6:	881b      	ldrh	r3, [r3, #0]
 80097a8:	b2da      	uxtb	r2, r3
 80097aa:	68fb      	ldr	r3, [r7, #12]
 80097ac:	731a      	strb	r2, [r3, #12]
  p->flags = flags;
 80097ae:	68fb      	ldr	r3, [r7, #12]
 80097b0:	221c      	movs	r2, #28
 80097b2:	18ba      	adds	r2, r7, r2
 80097b4:	7812      	ldrb	r2, [r2, #0]
 80097b6:	735a      	strb	r2, [r3, #13]
  p->ref = 1;
 80097b8:	68fb      	ldr	r3, [r7, #12]
 80097ba:	2201      	movs	r2, #1
 80097bc:	739a      	strb	r2, [r3, #14]
  p->if_idx = NETIF_NO_INDEX;
 80097be:	68fb      	ldr	r3, [r7, #12]
 80097c0:	2200      	movs	r2, #0
 80097c2:	73da      	strb	r2, [r3, #15]
}
 80097c4:	46c0      	nop			; (mov r8, r8)
 80097c6:	46bd      	mov	sp, r7
 80097c8:	b004      	add	sp, #16
 80097ca:	bd80      	pop	{r7, pc}

080097cc <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
 80097cc:	b590      	push	{r4, r7, lr}
 80097ce:	b08d      	sub	sp, #52	; 0x34
 80097d0:	af02      	add	r7, sp, #8
 80097d2:	0004      	movs	r4, r0
 80097d4:	0008      	movs	r0, r1
 80097d6:	0011      	movs	r1, r2
 80097d8:	1dfb      	adds	r3, r7, #7
 80097da:	1c22      	adds	r2, r4, #0
 80097dc:	701a      	strb	r2, [r3, #0]
 80097de:	1d3b      	adds	r3, r7, #4
 80097e0:	1c02      	adds	r2, r0, #0
 80097e2:	801a      	strh	r2, [r3, #0]
 80097e4:	1cbb      	adds	r3, r7, #2
 80097e6:	1c0a      	adds	r2, r1, #0
 80097e8:	801a      	strh	r2, [r3, #0]
  struct pbuf *p;
  u16_t offset = (u16_t)layer;
 80097ea:	2322      	movs	r3, #34	; 0x22
 80097ec:	18fb      	adds	r3, r7, r3
 80097ee:	1dfa      	adds	r2, r7, #7
 80097f0:	7812      	ldrb	r2, [r2, #0]
 80097f2:	801a      	strh	r2, [r3, #0]
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));

  switch (type) {
 80097f4:	1cbb      	adds	r3, r7, #2
 80097f6:	881b      	ldrh	r3, [r3, #0]
 80097f8:	22a0      	movs	r2, #160	; 0xa0
 80097fa:	0092      	lsls	r2, r2, #2
 80097fc:	4293      	cmp	r3, r2
 80097fe:	d100      	bne.n	8009802 <pbuf_alloc+0x36>
 8009800:	e0a8      	b.n	8009954 <pbuf_alloc+0x188>
 8009802:	22a0      	movs	r2, #160	; 0xa0
 8009804:	0092      	lsls	r2, r2, #2
 8009806:	4293      	cmp	r3, r2
 8009808:	dd00      	ble.n	800980c <pbuf_alloc+0x40>
 800980a:	e103      	b.n	8009a14 <pbuf_alloc+0x248>
 800980c:	22c1      	movs	r2, #193	; 0xc1
 800980e:	0052      	lsls	r2, r2, #1
 8009810:	4293      	cmp	r3, r2
 8009812:	d014      	beq.n	800983e <pbuf_alloc+0x72>
 8009814:	22c1      	movs	r2, #193	; 0xc1
 8009816:	0052      	lsls	r2, r2, #1
 8009818:	4293      	cmp	r3, r2
 800981a:	dd00      	ble.n	800981e <pbuf_alloc+0x52>
 800981c:	e0fa      	b.n	8009a14 <pbuf_alloc+0x248>
 800981e:	2b01      	cmp	r3, #1
 8009820:	d002      	beq.n	8009828 <pbuf_alloc+0x5c>
 8009822:	2b41      	cmp	r3, #65	; 0x41
 8009824:	d000      	beq.n	8009828 <pbuf_alloc+0x5c>
 8009826:	e0f5      	b.n	8009a14 <pbuf_alloc+0x248>
    case PBUF_REF: /* fall through */
    case PBUF_ROM:
      p = pbuf_alloc_reference(NULL, length, type);
 8009828:	1cbb      	adds	r3, r7, #2
 800982a:	881a      	ldrh	r2, [r3, #0]
 800982c:	1d3b      	adds	r3, r7, #4
 800982e:	881b      	ldrh	r3, [r3, #0]
 8009830:	0019      	movs	r1, r3
 8009832:	2000      	movs	r0, #0
 8009834:	f000 f90a 	bl	8009a4c <pbuf_alloc_reference>
 8009838:	0003      	movs	r3, r0
 800983a:	627b      	str	r3, [r7, #36]	; 0x24
      break;
 800983c:	e0f4      	b.n	8009a28 <pbuf_alloc+0x25c>
    case PBUF_POOL: {
      struct pbuf *q, *last;
      u16_t rem_len; /* remaining length */
      p = NULL;
 800983e:	2300      	movs	r3, #0
 8009840:	627b      	str	r3, [r7, #36]	; 0x24
      last = NULL;
 8009842:	2300      	movs	r3, #0
 8009844:	61fb      	str	r3, [r7, #28]
      rem_len = length;
 8009846:	231a      	movs	r3, #26
 8009848:	18fb      	adds	r3, r7, r3
 800984a:	1d3a      	adds	r2, r7, #4
 800984c:	8812      	ldrh	r2, [r2, #0]
 800984e:	801a      	strh	r2, [r3, #0]
      do {
        u16_t qlen;
        q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 8009850:	2006      	movs	r0, #6
 8009852:	f7ff fbd3 	bl	8008ffc <memp_malloc>
 8009856:	0003      	movs	r3, r0
 8009858:	613b      	str	r3, [r7, #16]
        if (q == NULL) {
 800985a:	693b      	ldr	r3, [r7, #16]
 800985c:	2b00      	cmp	r3, #0
 800985e:	d10a      	bne.n	8009876 <pbuf_alloc+0xaa>
          PBUF_POOL_IS_EMPTY();
 8009860:	f7ff ff7c 	bl	800975c <pbuf_pool_is_empty>
          /* free chain so far allocated */
          if (p) {
 8009864:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009866:	2b00      	cmp	r3, #0
 8009868:	d003      	beq.n	8009872 <pbuf_alloc+0xa6>
            pbuf_free(p);
 800986a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800986c:	0018      	movs	r0, r3
 800986e:	f000 fb25 	bl	8009ebc <pbuf_free>
          }
          /* bail out unsuccessfully */
          return NULL;
 8009872:	2300      	movs	r3, #0
 8009874:	e0d9      	b.n	8009a2a <pbuf_alloc+0x25e>
        }
        qlen = LWIP_MIN(rem_len, (u16_t)(PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)));
 8009876:	2322      	movs	r3, #34	; 0x22
 8009878:	18fb      	adds	r3, r7, r3
 800987a:	881b      	ldrh	r3, [r3, #0]
 800987c:	3303      	adds	r3, #3
 800987e:	b29b      	uxth	r3, r3
 8009880:	2203      	movs	r2, #3
 8009882:	4393      	bics	r3, r2
 8009884:	b29b      	uxth	r3, r3
 8009886:	2294      	movs	r2, #148	; 0x94
 8009888:	0092      	lsls	r2, r2, #2
 800988a:	1ad3      	subs	r3, r2, r3
 800988c:	b299      	uxth	r1, r3
 800988e:	230e      	movs	r3, #14
 8009890:	18fa      	adds	r2, r7, r3
 8009892:	231a      	movs	r3, #26
 8009894:	18fb      	adds	r3, r7, r3
 8009896:	1c0c      	adds	r4, r1, #0
 8009898:	881b      	ldrh	r3, [r3, #0]
 800989a:	b298      	uxth	r0, r3
 800989c:	b2a1      	uxth	r1, r4
 800989e:	4288      	cmp	r0, r1
 80098a0:	d900      	bls.n	80098a4 <pbuf_alloc+0xd8>
 80098a2:	1c23      	adds	r3, r4, #0
 80098a4:	8013      	strh	r3, [r2, #0]
        pbuf_init_alloced_pbuf(q, LWIP_MEM_ALIGN((void *)((u8_t *)q + SIZEOF_STRUCT_PBUF + offset)),
 80098a6:	2322      	movs	r3, #34	; 0x22
 80098a8:	18fb      	adds	r3, r7, r3
 80098aa:	881b      	ldrh	r3, [r3, #0]
 80098ac:	3310      	adds	r3, #16
 80098ae:	693a      	ldr	r2, [r7, #16]
 80098b0:	18d3      	adds	r3, r2, r3
 80098b2:	3303      	adds	r3, #3
 80098b4:	2203      	movs	r2, #3
 80098b6:	4393      	bics	r3, r2
 80098b8:	001c      	movs	r4, r3
 80098ba:	230e      	movs	r3, #14
 80098bc:	18fb      	adds	r3, r7, r3
 80098be:	8819      	ldrh	r1, [r3, #0]
 80098c0:	231a      	movs	r3, #26
 80098c2:	18fb      	adds	r3, r7, r3
 80098c4:	881a      	ldrh	r2, [r3, #0]
 80098c6:	6938      	ldr	r0, [r7, #16]
 80098c8:	2300      	movs	r3, #0
 80098ca:	9301      	str	r3, [sp, #4]
 80098cc:	1cbb      	adds	r3, r7, #2
 80098ce:	881b      	ldrh	r3, [r3, #0]
 80098d0:	9300      	str	r3, [sp, #0]
 80098d2:	000b      	movs	r3, r1
 80098d4:	0021      	movs	r1, r4
 80098d6:	f7ff ff4b 	bl	8009770 <pbuf_init_alloced_pbuf>
                               rem_len, qlen, type, 0);
        LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
 80098da:	693b      	ldr	r3, [r7, #16]
 80098dc:	685b      	ldr	r3, [r3, #4]
 80098de:	001a      	movs	r2, r3
 80098e0:	2303      	movs	r3, #3
 80098e2:	4013      	ands	r3, r2
 80098e4:	d006      	beq.n	80098f4 <pbuf_alloc+0x128>
 80098e6:	4b53      	ldr	r3, [pc, #332]	; (8009a34 <pbuf_alloc+0x268>)
 80098e8:	2280      	movs	r2, #128	; 0x80
 80098ea:	0052      	lsls	r2, r2, #1
 80098ec:	4952      	ldr	r1, [pc, #328]	; (8009a38 <pbuf_alloc+0x26c>)
 80098ee:	4853      	ldr	r0, [pc, #332]	; (8009a3c <pbuf_alloc+0x270>)
 80098f0:	f7f9 f96a 	bl	8002bc8 <app_debug_rtt_raw>
                    ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
        LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
 80098f4:	2322      	movs	r3, #34	; 0x22
 80098f6:	18fb      	adds	r3, r7, r3
 80098f8:	881b      	ldrh	r3, [r3, #0]
 80098fa:	3303      	adds	r3, #3
 80098fc:	2203      	movs	r2, #3
 80098fe:	4393      	bics	r3, r2
 8009900:	001a      	movs	r2, r3
 8009902:	2394      	movs	r3, #148	; 0x94
 8009904:	009b      	lsls	r3, r3, #2
 8009906:	429a      	cmp	r2, r3
 8009908:	d106      	bne.n	8009918 <pbuf_alloc+0x14c>
 800990a:	4b4a      	ldr	r3, [pc, #296]	; (8009a34 <pbuf_alloc+0x268>)
 800990c:	2281      	movs	r2, #129	; 0x81
 800990e:	0052      	lsls	r2, r2, #1
 8009910:	494b      	ldr	r1, [pc, #300]	; (8009a40 <pbuf_alloc+0x274>)
 8009912:	484a      	ldr	r0, [pc, #296]	; (8009a3c <pbuf_alloc+0x270>)
 8009914:	f7f9 f958 	bl	8002bc8 <app_debug_rtt_raw>
                    (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
        if (p == NULL) {
 8009918:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800991a:	2b00      	cmp	r3, #0
 800991c:	d102      	bne.n	8009924 <pbuf_alloc+0x158>
          /* allocated head of pbuf chain (into p) */
          p = q;
 800991e:	693b      	ldr	r3, [r7, #16]
 8009920:	627b      	str	r3, [r7, #36]	; 0x24
 8009922:	e002      	b.n	800992a <pbuf_alloc+0x15e>
        } else {
          /* make previous pbuf point to this pbuf */
          last->next = q;
 8009924:	69fb      	ldr	r3, [r7, #28]
 8009926:	693a      	ldr	r2, [r7, #16]
 8009928:	601a      	str	r2, [r3, #0]
        }
        last = q;
 800992a:	693b      	ldr	r3, [r7, #16]
 800992c:	61fb      	str	r3, [r7, #28]
        rem_len = (u16_t)(rem_len - qlen);
 800992e:	201a      	movs	r0, #26
 8009930:	183b      	adds	r3, r7, r0
 8009932:	1839      	adds	r1, r7, r0
 8009934:	220e      	movs	r2, #14
 8009936:	18ba      	adds	r2, r7, r2
 8009938:	8809      	ldrh	r1, [r1, #0]
 800993a:	8812      	ldrh	r2, [r2, #0]
 800993c:	1a8a      	subs	r2, r1, r2
 800993e:	801a      	strh	r2, [r3, #0]
        offset = 0;
 8009940:	2322      	movs	r3, #34	; 0x22
 8009942:	18fb      	adds	r3, r7, r3
 8009944:	2200      	movs	r2, #0
 8009946:	801a      	strh	r2, [r3, #0]
      } while (rem_len > 0);
 8009948:	183b      	adds	r3, r7, r0
 800994a:	881b      	ldrh	r3, [r3, #0]
 800994c:	2b00      	cmp	r3, #0
 800994e:	d000      	beq.n	8009952 <pbuf_alloc+0x186>
 8009950:	e77e      	b.n	8009850 <pbuf_alloc+0x84>
      break;
 8009952:	e069      	b.n	8009a28 <pbuf_alloc+0x25c>
    }
    case PBUF_RAM: {
      mem_size_t payload_len = (mem_size_t)(LWIP_MEM_ALIGN_SIZE(offset) + LWIP_MEM_ALIGN_SIZE(length));
 8009954:	2322      	movs	r3, #34	; 0x22
 8009956:	18fb      	adds	r3, r7, r3
 8009958:	881b      	ldrh	r3, [r3, #0]
 800995a:	3303      	adds	r3, #3
 800995c:	b29b      	uxth	r3, r3
 800995e:	2203      	movs	r2, #3
 8009960:	4393      	bics	r3, r2
 8009962:	b299      	uxth	r1, r3
 8009964:	1d3b      	adds	r3, r7, #4
 8009966:	881b      	ldrh	r3, [r3, #0]
 8009968:	3303      	adds	r3, #3
 800996a:	b29b      	uxth	r3, r3
 800996c:	2203      	movs	r2, #3
 800996e:	4393      	bics	r3, r2
 8009970:	b29a      	uxth	r2, r3
 8009972:	2018      	movs	r0, #24
 8009974:	183b      	adds	r3, r7, r0
 8009976:	188a      	adds	r2, r1, r2
 8009978:	801a      	strh	r2, [r3, #0]
      mem_size_t alloc_len = (mem_size_t)(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF) + payload_len);
 800997a:	2416      	movs	r4, #22
 800997c:	193b      	adds	r3, r7, r4
 800997e:	183a      	adds	r2, r7, r0
 8009980:	8812      	ldrh	r2, [r2, #0]
 8009982:	3210      	adds	r2, #16
 8009984:	801a      	strh	r2, [r3, #0]

      /* bug #50040: Check for integer overflow when calculating alloc_len */
      if ((payload_len < LWIP_MEM_ALIGN_SIZE(length)) ||
 8009986:	183b      	adds	r3, r7, r0
 8009988:	881a      	ldrh	r2, [r3, #0]
 800998a:	1d3b      	adds	r3, r7, #4
 800998c:	881b      	ldrh	r3, [r3, #0]
 800998e:	3303      	adds	r3, #3
 8009990:	2103      	movs	r1, #3
 8009992:	438b      	bics	r3, r1
 8009994:	429a      	cmp	r2, r3
 8009996:	d308      	bcc.n	80099aa <pbuf_alloc+0x1de>
          (alloc_len < LWIP_MEM_ALIGN_SIZE(length))) {
 8009998:	193b      	adds	r3, r7, r4
 800999a:	881a      	ldrh	r2, [r3, #0]
 800999c:	1d3b      	adds	r3, r7, #4
 800999e:	881b      	ldrh	r3, [r3, #0]
 80099a0:	3303      	adds	r3, #3
 80099a2:	2103      	movs	r1, #3
 80099a4:	438b      	bics	r3, r1
      if ((payload_len < LWIP_MEM_ALIGN_SIZE(length)) ||
 80099a6:	429a      	cmp	r2, r3
 80099a8:	d201      	bcs.n	80099ae <pbuf_alloc+0x1e2>
        return NULL;
 80099aa:	2300      	movs	r3, #0
 80099ac:	e03d      	b.n	8009a2a <pbuf_alloc+0x25e>
      }

      /* If pbuf is to be allocated in RAM, allocate memory for it. */
      p = (struct pbuf *)mem_malloc(alloc_len);
 80099ae:	2316      	movs	r3, #22
 80099b0:	18fb      	adds	r3, r7, r3
 80099b2:	881b      	ldrh	r3, [r3, #0]
 80099b4:	0018      	movs	r0, r3
 80099b6:	f7ff f9a9 	bl	8008d0c <mem_malloc>
 80099ba:	0003      	movs	r3, r0
 80099bc:	627b      	str	r3, [r7, #36]	; 0x24
      if (p == NULL) {
 80099be:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80099c0:	2b00      	cmp	r3, #0
 80099c2:	d101      	bne.n	80099c8 <pbuf_alloc+0x1fc>
        return NULL;
 80099c4:	2300      	movs	r3, #0
 80099c6:	e030      	b.n	8009a2a <pbuf_alloc+0x25e>
      }
      pbuf_init_alloced_pbuf(p, LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset)),
 80099c8:	2322      	movs	r3, #34	; 0x22
 80099ca:	18fb      	adds	r3, r7, r3
 80099cc:	881b      	ldrh	r3, [r3, #0]
 80099ce:	3310      	adds	r3, #16
 80099d0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80099d2:	18d3      	adds	r3, r2, r3
 80099d4:	3303      	adds	r3, #3
 80099d6:	2203      	movs	r2, #3
 80099d8:	4393      	bics	r3, r2
 80099da:	001c      	movs	r4, r3
 80099dc:	1d3b      	adds	r3, r7, #4
 80099de:	8819      	ldrh	r1, [r3, #0]
 80099e0:	1d3b      	adds	r3, r7, #4
 80099e2:	881a      	ldrh	r2, [r3, #0]
 80099e4:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80099e6:	2300      	movs	r3, #0
 80099e8:	9301      	str	r3, [sp, #4]
 80099ea:	1cbb      	adds	r3, r7, #2
 80099ec:	881b      	ldrh	r3, [r3, #0]
 80099ee:	9300      	str	r3, [sp, #0]
 80099f0:	000b      	movs	r3, r1
 80099f2:	0021      	movs	r1, r4
 80099f4:	f7ff febc 	bl	8009770 <pbuf_init_alloced_pbuf>
                             length, length, type, 0);
      LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
 80099f8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80099fa:	685b      	ldr	r3, [r3, #4]
 80099fc:	001a      	movs	r2, r3
 80099fe:	2303      	movs	r3, #3
 8009a00:	4013      	ands	r3, r2
 8009a02:	d010      	beq.n	8009a26 <pbuf_alloc+0x25a>
 8009a04:	4b0b      	ldr	r3, [pc, #44]	; (8009a34 <pbuf_alloc+0x268>)
 8009a06:	2291      	movs	r2, #145	; 0x91
 8009a08:	0052      	lsls	r2, r2, #1
 8009a0a:	490e      	ldr	r1, [pc, #56]	; (8009a44 <pbuf_alloc+0x278>)
 8009a0c:	480b      	ldr	r0, [pc, #44]	; (8009a3c <pbuf_alloc+0x270>)
 8009a0e:	f7f9 f8db 	bl	8002bc8 <app_debug_rtt_raw>
                  ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
      break;
 8009a12:	e008      	b.n	8009a26 <pbuf_alloc+0x25a>
    }
    default:
      LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
 8009a14:	4b07      	ldr	r3, [pc, #28]	; (8009a34 <pbuf_alloc+0x268>)
 8009a16:	2228      	movs	r2, #40	; 0x28
 8009a18:	32ff      	adds	r2, #255	; 0xff
 8009a1a:	490b      	ldr	r1, [pc, #44]	; (8009a48 <pbuf_alloc+0x27c>)
 8009a1c:	4807      	ldr	r0, [pc, #28]	; (8009a3c <pbuf_alloc+0x270>)
 8009a1e:	f7f9 f8d3 	bl	8002bc8 <app_debug_rtt_raw>
      return NULL;
 8009a22:	2300      	movs	r3, #0
 8009a24:	e001      	b.n	8009a2a <pbuf_alloc+0x25e>
      break;
 8009a26:	46c0      	nop			; (mov r8, r8)
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
 8009a28:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 8009a2a:	0018      	movs	r0, r3
 8009a2c:	46bd      	mov	sp, r7
 8009a2e:	b00b      	add	sp, #44	; 0x2c
 8009a30:	bd90      	pop	{r4, r7, pc}
 8009a32:	46c0      	nop			; (mov r8, r8)
 8009a34:	0801f8c4 	.word	0x0801f8c4
 8009a38:	0801f8ec 	.word	0x0801f8ec
 8009a3c:	0801f91c 	.word	0x0801f91c
 8009a40:	0801f948 	.word	0x0801f948
 8009a44:	0801f97c 	.word	0x0801f97c
 8009a48:	0801f9a8 	.word	0x0801f9a8

08009a4c <pbuf_alloc_reference>:
 *
 * @return the allocated pbuf.
 */
struct pbuf *
pbuf_alloc_reference(void *payload, u16_t length, pbuf_type type)
{
 8009a4c:	b590      	push	{r4, r7, lr}
 8009a4e:	b087      	sub	sp, #28
 8009a50:	af02      	add	r7, sp, #8
 8009a52:	6078      	str	r0, [r7, #4]
 8009a54:	0008      	movs	r0, r1
 8009a56:	0011      	movs	r1, r2
 8009a58:	1cbb      	adds	r3, r7, #2
 8009a5a:	1c02      	adds	r2, r0, #0
 8009a5c:	801a      	strh	r2, [r3, #0]
 8009a5e:	003b      	movs	r3, r7
 8009a60:	1c0a      	adds	r2, r1, #0
 8009a62:	801a      	strh	r2, [r3, #0]
  struct pbuf *p;
  LWIP_ASSERT("invalid pbuf_type", (type == PBUF_REF) || (type == PBUF_ROM));
 8009a64:	003b      	movs	r3, r7
 8009a66:	881b      	ldrh	r3, [r3, #0]
 8009a68:	2b41      	cmp	r3, #65	; 0x41
 8009a6a:	d00a      	beq.n	8009a82 <pbuf_alloc_reference+0x36>
 8009a6c:	003b      	movs	r3, r7
 8009a6e:	881b      	ldrh	r3, [r3, #0]
 8009a70:	2b01      	cmp	r3, #1
 8009a72:	d006      	beq.n	8009a82 <pbuf_alloc_reference+0x36>
 8009a74:	4b11      	ldr	r3, [pc, #68]	; (8009abc <pbuf_alloc_reference+0x70>)
 8009a76:	22a5      	movs	r2, #165	; 0xa5
 8009a78:	0052      	lsls	r2, r2, #1
 8009a7a:	4911      	ldr	r1, [pc, #68]	; (8009ac0 <pbuf_alloc_reference+0x74>)
 8009a7c:	4811      	ldr	r0, [pc, #68]	; (8009ac4 <pbuf_alloc_reference+0x78>)
 8009a7e:	f7f9 f8a3 	bl	8002bc8 <app_debug_rtt_raw>
  /* only allocate memory for the pbuf structure */
  p = (struct pbuf *)memp_malloc(MEMP_PBUF);
 8009a82:	2005      	movs	r0, #5
 8009a84:	f7ff faba 	bl	8008ffc <memp_malloc>
 8009a88:	0003      	movs	r3, r0
 8009a8a:	60fb      	str	r3, [r7, #12]
  if (p == NULL) {
 8009a8c:	68fb      	ldr	r3, [r7, #12]
 8009a8e:	2b00      	cmp	r3, #0
 8009a90:	d101      	bne.n	8009a96 <pbuf_alloc_reference+0x4a>
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                ("pbuf_alloc_reference: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                 (type == PBUF_ROM) ? "ROM" : "REF"));
    return NULL;
 8009a92:	2300      	movs	r3, #0
 8009a94:	e00e      	b.n	8009ab4 <pbuf_alloc_reference+0x68>
  }
  pbuf_init_alloced_pbuf(p, payload, length, length, type, 0);
 8009a96:	1cbb      	adds	r3, r7, #2
 8009a98:	881c      	ldrh	r4, [r3, #0]
 8009a9a:	1cbb      	adds	r3, r7, #2
 8009a9c:	881a      	ldrh	r2, [r3, #0]
 8009a9e:	6879      	ldr	r1, [r7, #4]
 8009aa0:	68f8      	ldr	r0, [r7, #12]
 8009aa2:	2300      	movs	r3, #0
 8009aa4:	9301      	str	r3, [sp, #4]
 8009aa6:	003b      	movs	r3, r7
 8009aa8:	881b      	ldrh	r3, [r3, #0]
 8009aaa:	9300      	str	r3, [sp, #0]
 8009aac:	0023      	movs	r3, r4
 8009aae:	f7ff fe5f 	bl	8009770 <pbuf_init_alloced_pbuf>
  return p;
 8009ab2:	68fb      	ldr	r3, [r7, #12]
}
 8009ab4:	0018      	movs	r0, r3
 8009ab6:	46bd      	mov	sp, r7
 8009ab8:	b005      	add	sp, #20
 8009aba:	bd90      	pop	{r4, r7, pc}
 8009abc:	0801f8c4 	.word	0x0801f8c4
 8009ac0:	0801f9c4 	.word	0x0801f9c4
 8009ac4:	0801f91c 	.word	0x0801f91c

08009ac8 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
 8009ac8:	b580      	push	{r7, lr}
 8009aca:	b084      	sub	sp, #16
 8009acc:	af00      	add	r7, sp, #0
 8009ace:	6078      	str	r0, [r7, #4]
 8009ad0:	000a      	movs	r2, r1
 8009ad2:	1cbb      	adds	r3, r7, #2
 8009ad4:	801a      	strh	r2, [r3, #0]
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  u16_t shrink;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
 8009ad6:	687b      	ldr	r3, [r7, #4]
 8009ad8:	2b00      	cmp	r3, #0
 8009ada:	d106      	bne.n	8009aea <pbuf_realloc+0x22>
 8009adc:	4b44      	ldr	r3, [pc, #272]	; (8009bf0 <pbuf_realloc+0x128>)
 8009ade:	22cc      	movs	r2, #204	; 0xcc
 8009ae0:	0052      	lsls	r2, r2, #1
 8009ae2:	4944      	ldr	r1, [pc, #272]	; (8009bf4 <pbuf_realloc+0x12c>)
 8009ae4:	4844      	ldr	r0, [pc, #272]	; (8009bf8 <pbuf_realloc+0x130>)
 8009ae6:	f7f9 f86f 	bl	8002bc8 <app_debug_rtt_raw>

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
 8009aea:	687b      	ldr	r3, [r7, #4]
 8009aec:	891b      	ldrh	r3, [r3, #8]
 8009aee:	1cba      	adds	r2, r7, #2
 8009af0:	8812      	ldrh	r2, [r2, #0]
 8009af2:	429a      	cmp	r2, r3
 8009af4:	d300      	bcc.n	8009af8 <pbuf_realloc+0x30>
 8009af6:	e076      	b.n	8009be6 <pbuf_realloc+0x11e>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  shrink = (u16_t)(p->tot_len - new_len);
 8009af8:	687b      	ldr	r3, [r7, #4]
 8009afa:	8919      	ldrh	r1, [r3, #8]
 8009afc:	2308      	movs	r3, #8
 8009afe:	18fb      	adds	r3, r7, r3
 8009b00:	1cba      	adds	r2, r7, #2
 8009b02:	8812      	ldrh	r2, [r2, #0]
 8009b04:	1a8a      	subs	r2, r1, r2
 8009b06:	801a      	strh	r2, [r3, #0]

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
 8009b08:	230a      	movs	r3, #10
 8009b0a:	18fb      	adds	r3, r7, r3
 8009b0c:	1cba      	adds	r2, r7, #2
 8009b0e:	8812      	ldrh	r2, [r2, #0]
 8009b10:	801a      	strh	r2, [r3, #0]
  q = p;
 8009b12:	687b      	ldr	r3, [r7, #4]
 8009b14:	60fb      	str	r3, [r7, #12]
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
 8009b16:	e01d      	b.n	8009b54 <pbuf_realloc+0x8c>
    /* decrease remaining length by pbuf length */
    rem_len = (u16_t)(rem_len - q->len);
 8009b18:	68fb      	ldr	r3, [r7, #12]
 8009b1a:	895a      	ldrh	r2, [r3, #10]
 8009b1c:	210a      	movs	r1, #10
 8009b1e:	187b      	adds	r3, r7, r1
 8009b20:	1879      	adds	r1, r7, r1
 8009b22:	8809      	ldrh	r1, [r1, #0]
 8009b24:	1a8a      	subs	r2, r1, r2
 8009b26:	801a      	strh	r2, [r3, #0]
    /* decrease total length indicator */
    q->tot_len = (u16_t)(q->tot_len - shrink);
 8009b28:	68fb      	ldr	r3, [r7, #12]
 8009b2a:	891a      	ldrh	r2, [r3, #8]
 8009b2c:	2308      	movs	r3, #8
 8009b2e:	18fb      	adds	r3, r7, r3
 8009b30:	881b      	ldrh	r3, [r3, #0]
 8009b32:	1ad3      	subs	r3, r2, r3
 8009b34:	b29a      	uxth	r2, r3
 8009b36:	68fb      	ldr	r3, [r7, #12]
 8009b38:	811a      	strh	r2, [r3, #8]
    /* proceed to next pbuf in chain */
    q = q->next;
 8009b3a:	68fb      	ldr	r3, [r7, #12]
 8009b3c:	681b      	ldr	r3, [r3, #0]
 8009b3e:	60fb      	str	r3, [r7, #12]
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
 8009b40:	68fb      	ldr	r3, [r7, #12]
 8009b42:	2b00      	cmp	r3, #0
 8009b44:	d106      	bne.n	8009b54 <pbuf_realloc+0x8c>
 8009b46:	4b2a      	ldr	r3, [pc, #168]	; (8009bf0 <pbuf_realloc+0x128>)
 8009b48:	22b0      	movs	r2, #176	; 0xb0
 8009b4a:	32ff      	adds	r2, #255	; 0xff
 8009b4c:	492b      	ldr	r1, [pc, #172]	; (8009bfc <pbuf_realloc+0x134>)
 8009b4e:	482a      	ldr	r0, [pc, #168]	; (8009bf8 <pbuf_realloc+0x130>)
 8009b50:	f7f9 f83a 	bl	8002bc8 <app_debug_rtt_raw>
  while (rem_len > q->len) {
 8009b54:	68fb      	ldr	r3, [r7, #12]
 8009b56:	895b      	ldrh	r3, [r3, #10]
 8009b58:	210a      	movs	r1, #10
 8009b5a:	187a      	adds	r2, r7, r1
 8009b5c:	8812      	ldrh	r2, [r2, #0]
 8009b5e:	429a      	cmp	r2, r3
 8009b60:	d8da      	bhi.n	8009b18 <pbuf_realloc+0x50>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if (pbuf_match_allocsrc(q, PBUF_TYPE_ALLOC_SRC_MASK_STD_HEAP) && (rem_len != q->len)
 8009b62:	68fb      	ldr	r3, [r7, #12]
 8009b64:	7b1b      	ldrb	r3, [r3, #12]
 8009b66:	001a      	movs	r2, r3
 8009b68:	230f      	movs	r3, #15
 8009b6a:	4013      	ands	r3, r2
 8009b6c:	d125      	bne.n	8009bba <pbuf_realloc+0xf2>
 8009b6e:	68fb      	ldr	r3, [r7, #12]
 8009b70:	895b      	ldrh	r3, [r3, #10]
 8009b72:	187a      	adds	r2, r7, r1
 8009b74:	8812      	ldrh	r2, [r2, #0]
 8009b76:	429a      	cmp	r2, r3
 8009b78:	d01f      	beq.n	8009bba <pbuf_realloc+0xf2>
#if LWIP_SUPPORT_CUSTOM_PBUF
      && ((q->flags & PBUF_FLAG_IS_CUSTOM) == 0)
 8009b7a:	68fb      	ldr	r3, [r7, #12]
 8009b7c:	7b5b      	ldrb	r3, [r3, #13]
 8009b7e:	001a      	movs	r2, r3
 8009b80:	2302      	movs	r3, #2
 8009b82:	4013      	ands	r3, r2
 8009b84:	d119      	bne.n	8009bba <pbuf_realloc+0xf2>
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
     ) {
    /* reallocate and adjust the length of the pbuf that will be split */
    q = (struct pbuf *)mem_trim(q, (mem_size_t)(((u8_t *)q->payload - (u8_t *)q) + rem_len));
 8009b86:	68fb      	ldr	r3, [r7, #12]
 8009b88:	685a      	ldr	r2, [r3, #4]
 8009b8a:	68fb      	ldr	r3, [r7, #12]
 8009b8c:	1ad3      	subs	r3, r2, r3
 8009b8e:	b29a      	uxth	r2, r3
 8009b90:	187b      	adds	r3, r7, r1
 8009b92:	881b      	ldrh	r3, [r3, #0]
 8009b94:	18d3      	adds	r3, r2, r3
 8009b96:	b29a      	uxth	r2, r3
 8009b98:	68fb      	ldr	r3, [r7, #12]
 8009b9a:	0011      	movs	r1, r2
 8009b9c:	0018      	movs	r0, r3
 8009b9e:	f7fe ff71 	bl	8008a84 <mem_trim>
 8009ba2:	0003      	movs	r3, r0
 8009ba4:	60fb      	str	r3, [r7, #12]
    LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
 8009ba6:	68fb      	ldr	r3, [r7, #12]
 8009ba8:	2b00      	cmp	r3, #0
 8009baa:	d106      	bne.n	8009bba <pbuf_realloc+0xf2>
 8009bac:	4b10      	ldr	r3, [pc, #64]	; (8009bf0 <pbuf_realloc+0x128>)
 8009bae:	22be      	movs	r2, #190	; 0xbe
 8009bb0:	32ff      	adds	r2, #255	; 0xff
 8009bb2:	4913      	ldr	r1, [pc, #76]	; (8009c00 <pbuf_realloc+0x138>)
 8009bb4:	4810      	ldr	r0, [pc, #64]	; (8009bf8 <pbuf_realloc+0x130>)
 8009bb6:	f7f9 f807 	bl	8002bc8 <app_debug_rtt_raw>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
 8009bba:	68fb      	ldr	r3, [r7, #12]
 8009bbc:	220a      	movs	r2, #10
 8009bbe:	18ba      	adds	r2, r7, r2
 8009bc0:	8812      	ldrh	r2, [r2, #0]
 8009bc2:	815a      	strh	r2, [r3, #10]
  q->tot_len = q->len;
 8009bc4:	68fb      	ldr	r3, [r7, #12]
 8009bc6:	895a      	ldrh	r2, [r3, #10]
 8009bc8:	68fb      	ldr	r3, [r7, #12]
 8009bca:	811a      	strh	r2, [r3, #8]

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
 8009bcc:	68fb      	ldr	r3, [r7, #12]
 8009bce:	681b      	ldr	r3, [r3, #0]
 8009bd0:	2b00      	cmp	r3, #0
 8009bd2:	d004      	beq.n	8009bde <pbuf_realloc+0x116>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
 8009bd4:	68fb      	ldr	r3, [r7, #12]
 8009bd6:	681b      	ldr	r3, [r3, #0]
 8009bd8:	0018      	movs	r0, r3
 8009bda:	f000 f96f 	bl	8009ebc <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
 8009bde:	68fb      	ldr	r3, [r7, #12]
 8009be0:	2200      	movs	r2, #0
 8009be2:	601a      	str	r2, [r3, #0]
 8009be4:	e000      	b.n	8009be8 <pbuf_realloc+0x120>
    return;
 8009be6:	46c0      	nop			; (mov r8, r8)

}
 8009be8:	46bd      	mov	sp, r7
 8009bea:	b004      	add	sp, #16
 8009bec:	bd80      	pop	{r7, pc}
 8009bee:	46c0      	nop			; (mov r8, r8)
 8009bf0:	0801f8c4 	.word	0x0801f8c4
 8009bf4:	0801f9d8 	.word	0x0801f9d8
 8009bf8:	0801f91c 	.word	0x0801f91c
 8009bfc:	0801f9f0 	.word	0x0801f9f0
 8009c00:	0801fa08 	.word	0x0801fa08

08009c04 <pbuf_add_header_impl>:
 * @return non-zero on failure, zero on success.
 *
 */
static u8_t
pbuf_add_header_impl(struct pbuf *p, size_t header_size_increment, u8_t force)
{
 8009c04:	b580      	push	{r7, lr}
 8009c06:	b086      	sub	sp, #24
 8009c08:	af00      	add	r7, sp, #0
 8009c0a:	60f8      	str	r0, [r7, #12]
 8009c0c:	60b9      	str	r1, [r7, #8]
 8009c0e:	1dfb      	adds	r3, r7, #7
 8009c10:	701a      	strb	r2, [r3, #0]
  u16_t type_internal;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
 8009c12:	68fb      	ldr	r3, [r7, #12]
 8009c14:	2b00      	cmp	r3, #0
 8009c16:	d106      	bne.n	8009c26 <pbuf_add_header_impl+0x22>
 8009c18:	4b31      	ldr	r3, [pc, #196]	; (8009ce0 <pbuf_add_header_impl+0xdc>)
 8009c1a:	22e0      	movs	r2, #224	; 0xe0
 8009c1c:	32ff      	adds	r2, #255	; 0xff
 8009c1e:	4931      	ldr	r1, [pc, #196]	; (8009ce4 <pbuf_add_header_impl+0xe0>)
 8009c20:	4831      	ldr	r0, [pc, #196]	; (8009ce8 <pbuf_add_header_impl+0xe4>)
 8009c22:	f7f8 ffd1 	bl	8002bc8 <app_debug_rtt_raw>
  if ((p == NULL) || (header_size_increment > 0xFFFF)) {
 8009c26:	68fb      	ldr	r3, [r7, #12]
 8009c28:	2b00      	cmp	r3, #0
 8009c2a:	d004      	beq.n	8009c36 <pbuf_add_header_impl+0x32>
 8009c2c:	68ba      	ldr	r2, [r7, #8]
 8009c2e:	2380      	movs	r3, #128	; 0x80
 8009c30:	025b      	lsls	r3, r3, #9
 8009c32:	429a      	cmp	r2, r3
 8009c34:	d301      	bcc.n	8009c3a <pbuf_add_header_impl+0x36>
    return 1;
 8009c36:	2301      	movs	r3, #1
 8009c38:	e04d      	b.n	8009cd6 <pbuf_add_header_impl+0xd2>
  }
  if (header_size_increment == 0) {
 8009c3a:	68bb      	ldr	r3, [r7, #8]
 8009c3c:	2b00      	cmp	r3, #0
 8009c3e:	d101      	bne.n	8009c44 <pbuf_add_header_impl+0x40>
    return 0;
 8009c40:	2300      	movs	r3, #0
 8009c42:	e048      	b.n	8009cd6 <pbuf_add_header_impl+0xd2>
  }

  increment_magnitude = (u16_t)header_size_increment;
 8009c44:	2112      	movs	r1, #18
 8009c46:	187b      	adds	r3, r7, r1
 8009c48:	68ba      	ldr	r2, [r7, #8]
 8009c4a:	801a      	strh	r2, [r3, #0]
  /* Do not allow tot_len to wrap as a result. */
  if ((u16_t)(increment_magnitude + p->tot_len) < increment_magnitude) {
 8009c4c:	68fb      	ldr	r3, [r7, #12]
 8009c4e:	891a      	ldrh	r2, [r3, #8]
 8009c50:	187b      	adds	r3, r7, r1
 8009c52:	881b      	ldrh	r3, [r3, #0]
 8009c54:	18d3      	adds	r3, r2, r3
 8009c56:	b29b      	uxth	r3, r3
 8009c58:	187a      	adds	r2, r7, r1
 8009c5a:	8812      	ldrh	r2, [r2, #0]
 8009c5c:	429a      	cmp	r2, r3
 8009c5e:	d901      	bls.n	8009c64 <pbuf_add_header_impl+0x60>
    return 1;
 8009c60:	2301      	movs	r3, #1
 8009c62:	e038      	b.n	8009cd6 <pbuf_add_header_impl+0xd2>
  }

  type_internal = p->type_internal;
 8009c64:	68fb      	ldr	r3, [r7, #12]
 8009c66:	7b1a      	ldrb	r2, [r3, #12]
 8009c68:	2110      	movs	r1, #16
 8009c6a:	187b      	adds	r3, r7, r1
 8009c6c:	801a      	strh	r2, [r3, #0]

  /* pbuf types containing payloads? */
  if (type_internal & PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS) {
 8009c6e:	187b      	adds	r3, r7, r1
 8009c70:	881b      	ldrh	r3, [r3, #0]
 8009c72:	2280      	movs	r2, #128	; 0x80
 8009c74:	4013      	ands	r3, r2
 8009c76:	d00c      	beq.n	8009c92 <pbuf_add_header_impl+0x8e>
    /* set new payload pointer */
    payload = (u8_t *)p->payload - header_size_increment;
 8009c78:	68fb      	ldr	r3, [r7, #12]
 8009c7a:	685a      	ldr	r2, [r3, #4]
 8009c7c:	68bb      	ldr	r3, [r7, #8]
 8009c7e:	425b      	negs	r3, r3
 8009c80:	18d3      	adds	r3, r2, r3
 8009c82:	617b      	str	r3, [r7, #20]
    /* boundary check fails? */
    if ((u8_t *)payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
 8009c84:	68fb      	ldr	r3, [r7, #12]
 8009c86:	3310      	adds	r3, #16
 8009c88:	697a      	ldr	r2, [r7, #20]
 8009c8a:	429a      	cmp	r2, r3
 8009c8c:	d20e      	bcs.n	8009cac <pbuf_add_header_impl+0xa8>
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE,
                   ("pbuf_add_header: failed as %p < %p (not enough space for new header size)\n",
                    (void *)payload, (void *)((u8_t *)p + SIZEOF_STRUCT_PBUF)));
      /* bail out unsuccessfully */
      return 1;
 8009c8e:	2301      	movs	r3, #1
 8009c90:	e021      	b.n	8009cd6 <pbuf_add_header_impl+0xd2>
    }
    /* pbuf types referring to external payloads? */
  } else {
    /* hide a header in the payload? */
    if (force) {
 8009c92:	1dfb      	adds	r3, r7, #7
 8009c94:	781b      	ldrb	r3, [r3, #0]
 8009c96:	2b00      	cmp	r3, #0
 8009c98:	d006      	beq.n	8009ca8 <pbuf_add_header_impl+0xa4>
      payload = (u8_t *)p->payload - header_size_increment;
 8009c9a:	68fb      	ldr	r3, [r7, #12]
 8009c9c:	685a      	ldr	r2, [r3, #4]
 8009c9e:	68bb      	ldr	r3, [r7, #8]
 8009ca0:	425b      	negs	r3, r3
 8009ca2:	18d3      	adds	r3, r2, r3
 8009ca4:	617b      	str	r3, [r7, #20]
 8009ca6:	e001      	b.n	8009cac <pbuf_add_header_impl+0xa8>
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccessfully */
      return 1;
 8009ca8:	2301      	movs	r3, #1
 8009caa:	e014      	b.n	8009cd6 <pbuf_add_header_impl+0xd2>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_add_header: old %p new %p (%"U16_F")\n",
              (void *)p->payload, (void *)payload, increment_magnitude));

  /* modify pbuf fields */
  p->payload = payload;
 8009cac:	68fb      	ldr	r3, [r7, #12]
 8009cae:	697a      	ldr	r2, [r7, #20]
 8009cb0:	605a      	str	r2, [r3, #4]
  p->len = (u16_t)(p->len + increment_magnitude);
 8009cb2:	68fb      	ldr	r3, [r7, #12]
 8009cb4:	895a      	ldrh	r2, [r3, #10]
 8009cb6:	2112      	movs	r1, #18
 8009cb8:	187b      	adds	r3, r7, r1
 8009cba:	881b      	ldrh	r3, [r3, #0]
 8009cbc:	18d3      	adds	r3, r2, r3
 8009cbe:	b29a      	uxth	r2, r3
 8009cc0:	68fb      	ldr	r3, [r7, #12]
 8009cc2:	815a      	strh	r2, [r3, #10]
  p->tot_len = (u16_t)(p->tot_len + increment_magnitude);
 8009cc4:	68fb      	ldr	r3, [r7, #12]
 8009cc6:	891a      	ldrh	r2, [r3, #8]
 8009cc8:	187b      	adds	r3, r7, r1
 8009cca:	881b      	ldrh	r3, [r3, #0]
 8009ccc:	18d3      	adds	r3, r2, r3
 8009cce:	b29a      	uxth	r2, r3
 8009cd0:	68fb      	ldr	r3, [r7, #12]
 8009cd2:	811a      	strh	r2, [r3, #8]


  return 0;
 8009cd4:	2300      	movs	r3, #0
}
 8009cd6:	0018      	movs	r0, r3
 8009cd8:	46bd      	mov	sp, r7
 8009cda:	b006      	add	sp, #24
 8009cdc:	bd80      	pop	{r7, pc}
 8009cde:	46c0      	nop			; (mov r8, r8)
 8009ce0:	0801f8c4 	.word	0x0801f8c4
 8009ce4:	0801fa24 	.word	0x0801fa24
 8009ce8:	0801f91c 	.word	0x0801f91c

08009cec <pbuf_add_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_add_header(struct pbuf *p, size_t header_size_increment)
{
 8009cec:	b580      	push	{r7, lr}
 8009cee:	b082      	sub	sp, #8
 8009cf0:	af00      	add	r7, sp, #0
 8009cf2:	6078      	str	r0, [r7, #4]
 8009cf4:	6039      	str	r1, [r7, #0]
  return pbuf_add_header_impl(p, header_size_increment, 0);
 8009cf6:	6839      	ldr	r1, [r7, #0]
 8009cf8:	687b      	ldr	r3, [r7, #4]
 8009cfa:	2200      	movs	r2, #0
 8009cfc:	0018      	movs	r0, r3
 8009cfe:	f7ff ff81 	bl	8009c04 <pbuf_add_header_impl>
 8009d02:	0003      	movs	r3, r0
}
 8009d04:	0018      	movs	r0, r3
 8009d06:	46bd      	mov	sp, r7
 8009d08:	b002      	add	sp, #8
 8009d0a:	bd80      	pop	{r7, pc}

08009d0c <pbuf_remove_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_remove_header(struct pbuf *p, size_t header_size_decrement)
{
 8009d0c:	b580      	push	{r7, lr}
 8009d0e:	b084      	sub	sp, #16
 8009d10:	af00      	add	r7, sp, #0
 8009d12:	6078      	str	r0, [r7, #4]
 8009d14:	6039      	str	r1, [r7, #0]
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
 8009d16:	687b      	ldr	r3, [r7, #4]
 8009d18:	2b00      	cmp	r3, #0
 8009d1a:	d105      	bne.n	8009d28 <pbuf_remove_header+0x1c>
 8009d1c:	4b21      	ldr	r3, [pc, #132]	; (8009da4 <pbuf_remove_header+0x98>)
 8009d1e:	4a22      	ldr	r2, [pc, #136]	; (8009da8 <pbuf_remove_header+0x9c>)
 8009d20:	4922      	ldr	r1, [pc, #136]	; (8009dac <pbuf_remove_header+0xa0>)
 8009d22:	4823      	ldr	r0, [pc, #140]	; (8009db0 <pbuf_remove_header+0xa4>)
 8009d24:	f7f8 ff50 	bl	8002bc8 <app_debug_rtt_raw>
  if ((p == NULL) || (header_size_decrement > 0xFFFF)) {
 8009d28:	687b      	ldr	r3, [r7, #4]
 8009d2a:	2b00      	cmp	r3, #0
 8009d2c:	d004      	beq.n	8009d38 <pbuf_remove_header+0x2c>
 8009d2e:	683a      	ldr	r2, [r7, #0]
 8009d30:	2380      	movs	r3, #128	; 0x80
 8009d32:	025b      	lsls	r3, r3, #9
 8009d34:	429a      	cmp	r2, r3
 8009d36:	d301      	bcc.n	8009d3c <pbuf_remove_header+0x30>
    return 1;
 8009d38:	2301      	movs	r3, #1
 8009d3a:	e02f      	b.n	8009d9c <pbuf_remove_header+0x90>
  }
  if (header_size_decrement == 0) {
 8009d3c:	683b      	ldr	r3, [r7, #0]
 8009d3e:	2b00      	cmp	r3, #0
 8009d40:	d101      	bne.n	8009d46 <pbuf_remove_header+0x3a>
    return 0;
 8009d42:	2300      	movs	r3, #0
 8009d44:	e02a      	b.n	8009d9c <pbuf_remove_header+0x90>
  }

  increment_magnitude = (u16_t)header_size_decrement;
 8009d46:	210e      	movs	r1, #14
 8009d48:	187b      	adds	r3, r7, r1
 8009d4a:	683a      	ldr	r2, [r7, #0]
 8009d4c:	801a      	strh	r2, [r3, #0]
  /* Check that we aren't going to move off the end of the pbuf */
  LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 8009d4e:	687b      	ldr	r3, [r7, #4]
 8009d50:	895b      	ldrh	r3, [r3, #10]
 8009d52:	187a      	adds	r2, r7, r1
 8009d54:	8812      	ldrh	r2, [r2, #0]
 8009d56:	429a      	cmp	r2, r3
 8009d58:	d905      	bls.n	8009d66 <pbuf_remove_header+0x5a>
 8009d5a:	4b16      	ldr	r3, [pc, #88]	; (8009db4 <pbuf_remove_header+0xa8>)
 8009d5c:	0018      	movs	r0, r3
 8009d5e:	f7f8 ff33 	bl	8002bc8 <app_debug_rtt_raw>
 8009d62:	2301      	movs	r3, #1
 8009d64:	e01a      	b.n	8009d9c <pbuf_remove_header+0x90>

  /* remember current payload pointer */
  payload = p->payload;
 8009d66:	687b      	ldr	r3, [r7, #4]
 8009d68:	685b      	ldr	r3, [r3, #4]
 8009d6a:	60bb      	str	r3, [r7, #8]
  LWIP_UNUSED_ARG(payload); /* only used in LWIP_DEBUGF below */

  /* increase payload pointer (guarded by length check above) */
  p->payload = (u8_t *)p->payload + header_size_decrement;
 8009d6c:	687b      	ldr	r3, [r7, #4]
 8009d6e:	685a      	ldr	r2, [r3, #4]
 8009d70:	683b      	ldr	r3, [r7, #0]
 8009d72:	18d2      	adds	r2, r2, r3
 8009d74:	687b      	ldr	r3, [r7, #4]
 8009d76:	605a      	str	r2, [r3, #4]
  /* modify pbuf length fields */
  p->len = (u16_t)(p->len - increment_magnitude);
 8009d78:	687b      	ldr	r3, [r7, #4]
 8009d7a:	895a      	ldrh	r2, [r3, #10]
 8009d7c:	210e      	movs	r1, #14
 8009d7e:	187b      	adds	r3, r7, r1
 8009d80:	881b      	ldrh	r3, [r3, #0]
 8009d82:	1ad3      	subs	r3, r2, r3
 8009d84:	b29a      	uxth	r2, r3
 8009d86:	687b      	ldr	r3, [r7, #4]
 8009d88:	815a      	strh	r2, [r3, #10]
  p->tot_len = (u16_t)(p->tot_len - increment_magnitude);
 8009d8a:	687b      	ldr	r3, [r7, #4]
 8009d8c:	891a      	ldrh	r2, [r3, #8]
 8009d8e:	187b      	adds	r3, r7, r1
 8009d90:	881b      	ldrh	r3, [r3, #0]
 8009d92:	1ad3      	subs	r3, r2, r3
 8009d94:	b29a      	uxth	r2, r3
 8009d96:	687b      	ldr	r3, [r7, #4]
 8009d98:	811a      	strh	r2, [r3, #8]

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_remove_header: old %p new %p (%"U16_F")\n",
              (void *)payload, (void *)p->payload, increment_magnitude));

  return 0;
 8009d9a:	2300      	movs	r3, #0
}
 8009d9c:	0018      	movs	r0, r3
 8009d9e:	46bd      	mov	sp, r7
 8009da0:	b004      	add	sp, #16
 8009da2:	bd80      	pop	{r7, pc}
 8009da4:	0801f8c4 	.word	0x0801f8c4
 8009da8:	0000024b 	.word	0x0000024b
 8009dac:	0801fa24 	.word	0x0801fa24
 8009db0:	0801f91c 	.word	0x0801f91c
 8009db4:	0801fa30 	.word	0x0801fa30

08009db8 <pbuf_header_impl>:

static u8_t
pbuf_header_impl(struct pbuf *p, s16_t header_size_increment, u8_t force)
{
 8009db8:	b580      	push	{r7, lr}
 8009dba:	b082      	sub	sp, #8
 8009dbc:	af00      	add	r7, sp, #0
 8009dbe:	6078      	str	r0, [r7, #4]
 8009dc0:	0008      	movs	r0, r1
 8009dc2:	0011      	movs	r1, r2
 8009dc4:	1cbb      	adds	r3, r7, #2
 8009dc6:	1c02      	adds	r2, r0, #0
 8009dc8:	801a      	strh	r2, [r3, #0]
 8009dca:	1c7b      	adds	r3, r7, #1
 8009dcc:	1c0a      	adds	r2, r1, #0
 8009dce:	701a      	strb	r2, [r3, #0]
  if (header_size_increment < 0) {
 8009dd0:	1cbb      	adds	r3, r7, #2
 8009dd2:	2200      	movs	r2, #0
 8009dd4:	5e9b      	ldrsh	r3, [r3, r2]
 8009dd6:	2b00      	cmp	r3, #0
 8009dd8:	da0b      	bge.n	8009df2 <pbuf_header_impl+0x3a>
    return pbuf_remove_header(p, (size_t) - header_size_increment);
 8009dda:	1cbb      	adds	r3, r7, #2
 8009ddc:	2200      	movs	r2, #0
 8009dde:	5e9b      	ldrsh	r3, [r3, r2]
 8009de0:	425b      	negs	r3, r3
 8009de2:	001a      	movs	r2, r3
 8009de4:	687b      	ldr	r3, [r7, #4]
 8009de6:	0011      	movs	r1, r2
 8009de8:	0018      	movs	r0, r3
 8009dea:	f7ff ff8f 	bl	8009d0c <pbuf_remove_header>
 8009dee:	0003      	movs	r3, r0
 8009df0:	e009      	b.n	8009e06 <pbuf_header_impl+0x4e>
  } else {
    return pbuf_add_header_impl(p, (size_t)header_size_increment, force);
 8009df2:	1cbb      	adds	r3, r7, #2
 8009df4:	2100      	movs	r1, #0
 8009df6:	5e59      	ldrsh	r1, [r3, r1]
 8009df8:	1c7b      	adds	r3, r7, #1
 8009dfa:	781a      	ldrb	r2, [r3, #0]
 8009dfc:	687b      	ldr	r3, [r7, #4]
 8009dfe:	0018      	movs	r0, r3
 8009e00:	f7ff ff00 	bl	8009c04 <pbuf_add_header_impl>
 8009e04:	0003      	movs	r3, r0
  }
}
 8009e06:	0018      	movs	r0, r3
 8009e08:	46bd      	mov	sp, r7
 8009e0a:	b002      	add	sp, #8
 8009e0c:	bd80      	pop	{r7, pc}

08009e0e <pbuf_header_force>:
 * Same as pbuf_header but does not check if 'header_size > 0' is allowed.
 * This is used internally only, to allow PBUF_REF for RX.
 */
u8_t
pbuf_header_force(struct pbuf *p, s16_t header_size_increment)
{
 8009e0e:	b580      	push	{r7, lr}
 8009e10:	b082      	sub	sp, #8
 8009e12:	af00      	add	r7, sp, #0
 8009e14:	6078      	str	r0, [r7, #4]
 8009e16:	000a      	movs	r2, r1
 8009e18:	1cbb      	adds	r3, r7, #2
 8009e1a:	801a      	strh	r2, [r3, #0]
  return pbuf_header_impl(p, header_size_increment, 1);
 8009e1c:	1cbb      	adds	r3, r7, #2
 8009e1e:	2100      	movs	r1, #0
 8009e20:	5e59      	ldrsh	r1, [r3, r1]
 8009e22:	687b      	ldr	r3, [r7, #4]
 8009e24:	2201      	movs	r2, #1
 8009e26:	0018      	movs	r0, r3
 8009e28:	f7ff ffc6 	bl	8009db8 <pbuf_header_impl>
 8009e2c:	0003      	movs	r3, r0
}
 8009e2e:	0018      	movs	r0, r3
 8009e30:	46bd      	mov	sp, r7
 8009e32:	b002      	add	sp, #8
 8009e34:	bd80      	pop	{r7, pc}

08009e36 <pbuf_free_header>:
 *                   takes an u16_t not s16_t!
 * @return the new head pbuf
 */
struct pbuf *
pbuf_free_header(struct pbuf *q, u16_t size)
{
 8009e36:	b590      	push	{r4, r7, lr}
 8009e38:	b087      	sub	sp, #28
 8009e3a:	af00      	add	r7, sp, #0
 8009e3c:	6078      	str	r0, [r7, #4]
 8009e3e:	000a      	movs	r2, r1
 8009e40:	1cbb      	adds	r3, r7, #2
 8009e42:	801a      	strh	r2, [r3, #0]
  struct pbuf *p = q;
 8009e44:	687b      	ldr	r3, [r7, #4]
 8009e46:	617b      	str	r3, [r7, #20]
  u16_t free_left = size;
 8009e48:	2312      	movs	r3, #18
 8009e4a:	18fb      	adds	r3, r7, r3
 8009e4c:	1cba      	adds	r2, r7, #2
 8009e4e:	8812      	ldrh	r2, [r2, #0]
 8009e50:	801a      	strh	r2, [r3, #0]
  while (free_left && p) {
 8009e52:	e025      	b.n	8009ea0 <pbuf_free_header+0x6a>
    if (free_left >= p->len) {
 8009e54:	697b      	ldr	r3, [r7, #20]
 8009e56:	895b      	ldrh	r3, [r3, #10]
 8009e58:	2112      	movs	r1, #18
 8009e5a:	187a      	adds	r2, r7, r1
 8009e5c:	8812      	ldrh	r2, [r2, #0]
 8009e5e:	429a      	cmp	r2, r3
 8009e60:	d313      	bcc.n	8009e8a <pbuf_free_header+0x54>
      struct pbuf *f = p;
 8009e62:	697b      	ldr	r3, [r7, #20]
 8009e64:	60fb      	str	r3, [r7, #12]
      free_left = (u16_t)(free_left - p->len);
 8009e66:	697b      	ldr	r3, [r7, #20]
 8009e68:	895a      	ldrh	r2, [r3, #10]
 8009e6a:	187b      	adds	r3, r7, r1
 8009e6c:	1879      	adds	r1, r7, r1
 8009e6e:	8809      	ldrh	r1, [r1, #0]
 8009e70:	1a8a      	subs	r2, r1, r2
 8009e72:	801a      	strh	r2, [r3, #0]
      p = p->next;
 8009e74:	697b      	ldr	r3, [r7, #20]
 8009e76:	681b      	ldr	r3, [r3, #0]
 8009e78:	617b      	str	r3, [r7, #20]
      f->next = 0;
 8009e7a:	68fb      	ldr	r3, [r7, #12]
 8009e7c:	2200      	movs	r2, #0
 8009e7e:	601a      	str	r2, [r3, #0]
      pbuf_free(f);
 8009e80:	68fb      	ldr	r3, [r7, #12]
 8009e82:	0018      	movs	r0, r3
 8009e84:	f000 f81a 	bl	8009ebc <pbuf_free>
 8009e88:	e00a      	b.n	8009ea0 <pbuf_free_header+0x6a>
    } else {
      pbuf_remove_header(p, free_left);
 8009e8a:	2412      	movs	r4, #18
 8009e8c:	193b      	adds	r3, r7, r4
 8009e8e:	881a      	ldrh	r2, [r3, #0]
 8009e90:	697b      	ldr	r3, [r7, #20]
 8009e92:	0011      	movs	r1, r2
 8009e94:	0018      	movs	r0, r3
 8009e96:	f7ff ff39 	bl	8009d0c <pbuf_remove_header>
      free_left = 0;
 8009e9a:	193b      	adds	r3, r7, r4
 8009e9c:	2200      	movs	r2, #0
 8009e9e:	801a      	strh	r2, [r3, #0]
  while (free_left && p) {
 8009ea0:	2312      	movs	r3, #18
 8009ea2:	18fb      	adds	r3, r7, r3
 8009ea4:	881b      	ldrh	r3, [r3, #0]
 8009ea6:	2b00      	cmp	r3, #0
 8009ea8:	d002      	beq.n	8009eb0 <pbuf_free_header+0x7a>
 8009eaa:	697b      	ldr	r3, [r7, #20]
 8009eac:	2b00      	cmp	r3, #0
 8009eae:	d1d1      	bne.n	8009e54 <pbuf_free_header+0x1e>
    }
  }
  return p;
 8009eb0:	697b      	ldr	r3, [r7, #20]
}
 8009eb2:	0018      	movs	r0, r3
 8009eb4:	46bd      	mov	sp, r7
 8009eb6:	b007      	add	sp, #28
 8009eb8:	bd90      	pop	{r4, r7, pc}
	...

08009ebc <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
 8009ebc:	b580      	push	{r7, lr}
 8009ebe:	b086      	sub	sp, #24
 8009ec0:	af00      	add	r7, sp, #0
 8009ec2:	6078      	str	r0, [r7, #4]
  u8_t alloc_src;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
 8009ec4:	687b      	ldr	r3, [r7, #4]
 8009ec6:	2b00      	cmp	r3, #0
 8009ec8:	d10b      	bne.n	8009ee2 <pbuf_free+0x26>
    LWIP_ASSERT("p != NULL", p != NULL);
 8009eca:	687b      	ldr	r3, [r7, #4]
 8009ecc:	2b00      	cmp	r3, #0
 8009ece:	d106      	bne.n	8009ede <pbuf_free+0x22>
 8009ed0:	4b41      	ldr	r3, [pc, #260]	; (8009fd8 <pbuf_free+0x11c>)
 8009ed2:	22b7      	movs	r2, #183	; 0xb7
 8009ed4:	0092      	lsls	r2, r2, #2
 8009ed6:	4941      	ldr	r1, [pc, #260]	; (8009fdc <pbuf_free+0x120>)
 8009ed8:	4841      	ldr	r0, [pc, #260]	; (8009fe0 <pbuf_free+0x124>)
 8009eda:	f7f8 fe75 	bl	8002bc8 <app_debug_rtt_raw>
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                ("pbuf_free(p == NULL) was called.\n"));
    return 0;
 8009ede:	2300      	movs	r3, #0
 8009ee0:	e076      	b.n	8009fd0 <pbuf_free+0x114>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  count = 0;
 8009ee2:	2317      	movs	r3, #23
 8009ee4:	18fb      	adds	r3, r7, r3
 8009ee6:	2200      	movs	r2, #0
 8009ee8:	701a      	strb	r2, [r3, #0]
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
 8009eea:	e06b      	b.n	8009fc4 <pbuf_free+0x108>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
 8009eec:	687b      	ldr	r3, [r7, #4]
 8009eee:	7b9b      	ldrb	r3, [r3, #14]
 8009ef0:	2b00      	cmp	r3, #0
 8009ef2:	d105      	bne.n	8009f00 <pbuf_free+0x44>
 8009ef4:	4b38      	ldr	r3, [pc, #224]	; (8009fd8 <pbuf_free+0x11c>)
 8009ef6:	4a3b      	ldr	r2, [pc, #236]	; (8009fe4 <pbuf_free+0x128>)
 8009ef8:	493b      	ldr	r1, [pc, #236]	; (8009fe8 <pbuf_free+0x12c>)
 8009efa:	4839      	ldr	r0, [pc, #228]	; (8009fe0 <pbuf_free+0x124>)
 8009efc:	f7f8 fe64 	bl	8002bc8 <app_debug_rtt_raw>
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
 8009f00:	687b      	ldr	r3, [r7, #4]
 8009f02:	7b9b      	ldrb	r3, [r3, #14]
 8009f04:	3b01      	subs	r3, #1
 8009f06:	b2da      	uxtb	r2, r3
 8009f08:	687b      	ldr	r3, [r7, #4]
 8009f0a:	739a      	strb	r2, [r3, #14]
 8009f0c:	2116      	movs	r1, #22
 8009f0e:	187b      	adds	r3, r7, r1
 8009f10:	687a      	ldr	r2, [r7, #4]
 8009f12:	7b92      	ldrb	r2, [r2, #14]
 8009f14:	701a      	strb	r2, [r3, #0]
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
 8009f16:	187b      	adds	r3, r7, r1
 8009f18:	781b      	ldrb	r3, [r3, #0]
 8009f1a:	2b00      	cmp	r3, #0
 8009f1c:	d150      	bne.n	8009fc0 <pbuf_free+0x104>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
 8009f1e:	687b      	ldr	r3, [r7, #4]
 8009f20:	681b      	ldr	r3, [r3, #0]
 8009f22:	613b      	str	r3, [r7, #16]
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      alloc_src = pbuf_get_allocsrc(p);
 8009f24:	687b      	ldr	r3, [r7, #4]
 8009f26:	7b1a      	ldrb	r2, [r3, #12]
 8009f28:	230f      	movs	r3, #15
 8009f2a:	18fb      	adds	r3, r7, r3
 8009f2c:	210f      	movs	r1, #15
 8009f2e:	400a      	ands	r2, r1
 8009f30:	701a      	strb	r2, [r3, #0]
#if LWIP_SUPPORT_CUSTOM_PBUF
      /* is this a custom pbuf? */
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
 8009f32:	687b      	ldr	r3, [r7, #4]
 8009f34:	7b5b      	ldrb	r3, [r3, #13]
 8009f36:	001a      	movs	r2, r3
 8009f38:	2302      	movs	r3, #2
 8009f3a:	4013      	ands	r3, r2
 8009f3c:	d011      	beq.n	8009f62 <pbuf_free+0xa6>
        struct pbuf_custom *pc = (struct pbuf_custom *)p;
 8009f3e:	687b      	ldr	r3, [r7, #4]
 8009f40:	60bb      	str	r3, [r7, #8]
        LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
 8009f42:	68bb      	ldr	r3, [r7, #8]
 8009f44:	691b      	ldr	r3, [r3, #16]
 8009f46:	2b00      	cmp	r3, #0
 8009f48:	d105      	bne.n	8009f56 <pbuf_free+0x9a>
 8009f4a:	4b23      	ldr	r3, [pc, #140]	; (8009fd8 <pbuf_free+0x11c>)
 8009f4c:	4a27      	ldr	r2, [pc, #156]	; (8009fec <pbuf_free+0x130>)
 8009f4e:	4928      	ldr	r1, [pc, #160]	; (8009ff0 <pbuf_free+0x134>)
 8009f50:	4823      	ldr	r0, [pc, #140]	; (8009fe0 <pbuf_free+0x124>)
 8009f52:	f7f8 fe39 	bl	8002bc8 <app_debug_rtt_raw>
        pc->custom_free_function(p);
 8009f56:	68bb      	ldr	r3, [r7, #8]
 8009f58:	691b      	ldr	r3, [r3, #16]
 8009f5a:	687a      	ldr	r2, [r7, #4]
 8009f5c:	0010      	movs	r0, r2
 8009f5e:	4798      	blx	r3
 8009f60:	e025      	b.n	8009fae <pbuf_free+0xf2>
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (alloc_src == PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF_POOL) {
 8009f62:	230f      	movs	r3, #15
 8009f64:	18fb      	adds	r3, r7, r3
 8009f66:	781b      	ldrb	r3, [r3, #0]
 8009f68:	2b02      	cmp	r3, #2
 8009f6a:	d105      	bne.n	8009f78 <pbuf_free+0xbc>
          memp_free(MEMP_PBUF_POOL, p);
 8009f6c:	687b      	ldr	r3, [r7, #4]
 8009f6e:	0019      	movs	r1, r3
 8009f70:	2006      	movs	r0, #6
 8009f72:	f7ff f8b3 	bl	80090dc <memp_free>
 8009f76:	e01a      	b.n	8009fae <pbuf_free+0xf2>
          /* is this a ROM or RAM referencing pbuf? */
        } else if (alloc_src == PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF) {
 8009f78:	230f      	movs	r3, #15
 8009f7a:	18fb      	adds	r3, r7, r3
 8009f7c:	781b      	ldrb	r3, [r3, #0]
 8009f7e:	2b01      	cmp	r3, #1
 8009f80:	d105      	bne.n	8009f8e <pbuf_free+0xd2>
          memp_free(MEMP_PBUF, p);
 8009f82:	687b      	ldr	r3, [r7, #4]
 8009f84:	0019      	movs	r1, r3
 8009f86:	2005      	movs	r0, #5
 8009f88:	f7ff f8a8 	bl	80090dc <memp_free>
 8009f8c:	e00f      	b.n	8009fae <pbuf_free+0xf2>
          /* type == PBUF_RAM */
        } else if (alloc_src == PBUF_TYPE_ALLOC_SRC_MASK_STD_HEAP) {
 8009f8e:	230f      	movs	r3, #15
 8009f90:	18fb      	adds	r3, r7, r3
 8009f92:	781b      	ldrb	r3, [r3, #0]
 8009f94:	2b00      	cmp	r3, #0
 8009f96:	d104      	bne.n	8009fa2 <pbuf_free+0xe6>
          mem_free(p);
 8009f98:	687b      	ldr	r3, [r7, #4]
 8009f9a:	0018      	movs	r0, r3
 8009f9c:	f7fe fd04 	bl	80089a8 <mem_free>
 8009fa0:	e005      	b.n	8009fae <pbuf_free+0xf2>
        } else {
          /* @todo: support freeing other types */
          LWIP_ASSERT("invalid pbuf type", 0);
 8009fa2:	4b0d      	ldr	r3, [pc, #52]	; (8009fd8 <pbuf_free+0x11c>)
 8009fa4:	4a13      	ldr	r2, [pc, #76]	; (8009ff4 <pbuf_free+0x138>)
 8009fa6:	4914      	ldr	r1, [pc, #80]	; (8009ff8 <pbuf_free+0x13c>)
 8009fa8:	480d      	ldr	r0, [pc, #52]	; (8009fe0 <pbuf_free+0x124>)
 8009faa:	f7f8 fe0d 	bl	8002bc8 <app_debug_rtt_raw>
        }
      }
      count++;
 8009fae:	2117      	movs	r1, #23
 8009fb0:	187b      	adds	r3, r7, r1
 8009fb2:	781a      	ldrb	r2, [r3, #0]
 8009fb4:	187b      	adds	r3, r7, r1
 8009fb6:	3201      	adds	r2, #1
 8009fb8:	701a      	strb	r2, [r3, #0]
      /* proceed to next pbuf */
      p = q;
 8009fba:	693b      	ldr	r3, [r7, #16]
 8009fbc:	607b      	str	r3, [r7, #4]
 8009fbe:	e001      	b.n	8009fc4 <pbuf_free+0x108>
      /* p->ref > 0, this pbuf is still referenced to */
      /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, (u16_t)ref));
      /* stop walking through the chain */
      p = NULL;
 8009fc0:	2300      	movs	r3, #0
 8009fc2:	607b      	str	r3, [r7, #4]
  while (p != NULL) {
 8009fc4:	687b      	ldr	r3, [r7, #4]
 8009fc6:	2b00      	cmp	r3, #0
 8009fc8:	d190      	bne.n	8009eec <pbuf_free+0x30>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
 8009fca:	2317      	movs	r3, #23
 8009fcc:	18fb      	adds	r3, r7, r3
 8009fce:	781b      	ldrb	r3, [r3, #0]
}
 8009fd0:	0018      	movs	r0, r3
 8009fd2:	46bd      	mov	sp, r7
 8009fd4:	b006      	add	sp, #24
 8009fd6:	bd80      	pop	{r7, pc}
 8009fd8:	0801f8c4 	.word	0x0801f8c4
 8009fdc:	0801fa24 	.word	0x0801fa24
 8009fe0:	0801f91c 	.word	0x0801f91c
 8009fe4:	000002f1 	.word	0x000002f1
 8009fe8:	0801fa50 	.word	0x0801fa50
 8009fec:	000002ff 	.word	0x000002ff
 8009ff0:	0801fa68 	.word	0x0801fa68
 8009ff4:	0000030f 	.word	0x0000030f
 8009ff8:	0801fa8c 	.word	0x0801fa8c

08009ffc <pbuf_clen>:
 * @param p first pbuf of chain
 * @return the number of pbufs in a chain
 */
u16_t
pbuf_clen(const struct pbuf *p)
{
 8009ffc:	b580      	push	{r7, lr}
 8009ffe:	b084      	sub	sp, #16
 800a000:	af00      	add	r7, sp, #0
 800a002:	6078      	str	r0, [r7, #4]
  u16_t len;

  len = 0;
 800a004:	230e      	movs	r3, #14
 800a006:	18fb      	adds	r3, r7, r3
 800a008:	2200      	movs	r2, #0
 800a00a:	801a      	strh	r2, [r3, #0]
  while (p != NULL) {
 800a00c:	e008      	b.n	800a020 <pbuf_clen+0x24>
    ++len;
 800a00e:	220e      	movs	r2, #14
 800a010:	18bb      	adds	r3, r7, r2
 800a012:	18ba      	adds	r2, r7, r2
 800a014:	8812      	ldrh	r2, [r2, #0]
 800a016:	3201      	adds	r2, #1
 800a018:	801a      	strh	r2, [r3, #0]
    p = p->next;
 800a01a:	687b      	ldr	r3, [r7, #4]
 800a01c:	681b      	ldr	r3, [r3, #0]
 800a01e:	607b      	str	r3, [r7, #4]
  while (p != NULL) {
 800a020:	687b      	ldr	r3, [r7, #4]
 800a022:	2b00      	cmp	r3, #0
 800a024:	d1f3      	bne.n	800a00e <pbuf_clen+0x12>
  }
  return len;
 800a026:	230e      	movs	r3, #14
 800a028:	18fb      	adds	r3, r7, r3
 800a02a:	881b      	ldrh	r3, [r3, #0]
}
 800a02c:	0018      	movs	r0, r3
 800a02e:	46bd      	mov	sp, r7
 800a030:	b004      	add	sp, #16
 800a032:	bd80      	pop	{r7, pc}

0800a034 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
 800a034:	b580      	push	{r7, lr}
 800a036:	b082      	sub	sp, #8
 800a038:	af00      	add	r7, sp, #0
 800a03a:	6078      	str	r0, [r7, #4]
  /* pbuf given? */
  if (p != NULL) {
 800a03c:	687b      	ldr	r3, [r7, #4]
 800a03e:	2b00      	cmp	r3, #0
 800a040:	d00f      	beq.n	800a062 <pbuf_ref+0x2e>
    SYS_ARCH_SET(p->ref, (LWIP_PBUF_REF_T)(p->ref + 1));
 800a042:	687b      	ldr	r3, [r7, #4]
 800a044:	7b9b      	ldrb	r3, [r3, #14]
 800a046:	3301      	adds	r3, #1
 800a048:	b2da      	uxtb	r2, r3
 800a04a:	687b      	ldr	r3, [r7, #4]
 800a04c:	739a      	strb	r2, [r3, #14]
    LWIP_ASSERT("pbuf ref overflow", p->ref > 0);
 800a04e:	687b      	ldr	r3, [r7, #4]
 800a050:	7b9b      	ldrb	r3, [r3, #14]
 800a052:	2b00      	cmp	r3, #0
 800a054:	d105      	bne.n	800a062 <pbuf_ref+0x2e>
 800a056:	4b05      	ldr	r3, [pc, #20]	; (800a06c <pbuf_ref+0x38>)
 800a058:	4a05      	ldr	r2, [pc, #20]	; (800a070 <pbuf_ref+0x3c>)
 800a05a:	4906      	ldr	r1, [pc, #24]	; (800a074 <pbuf_ref+0x40>)
 800a05c:	4806      	ldr	r0, [pc, #24]	; (800a078 <pbuf_ref+0x44>)
 800a05e:	f7f8 fdb3 	bl	8002bc8 <app_debug_rtt_raw>
  }
}
 800a062:	46c0      	nop			; (mov r8, r8)
 800a064:	46bd      	mov	sp, r7
 800a066:	b002      	add	sp, #8
 800a068:	bd80      	pop	{r7, pc}
 800a06a:	46c0      	nop			; (mov r8, r8)
 800a06c:	0801f8c4 	.word	0x0801f8c4
 800a070:	00000342 	.word	0x00000342
 800a074:	0801faa0 	.word	0x0801faa0
 800a078:	0801f91c 	.word	0x0801f91c

0800a07c <pbuf_cat>:
 *
 * @see pbuf_chain()
 */
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
 800a07c:	b580      	push	{r7, lr}
 800a07e:	b084      	sub	sp, #16
 800a080:	af00      	add	r7, sp, #0
 800a082:	6078      	str	r0, [r7, #4]
 800a084:	6039      	str	r1, [r7, #0]
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 800a086:	687b      	ldr	r3, [r7, #4]
 800a088:	2b00      	cmp	r3, #0
 800a08a:	d002      	beq.n	800a092 <pbuf_cat+0x16>
 800a08c:	683b      	ldr	r3, [r7, #0]
 800a08e:	2b00      	cmp	r3, #0
 800a090:	d104      	bne.n	800a09c <pbuf_cat+0x20>
 800a092:	4b1d      	ldr	r3, [pc, #116]	; (800a108 <pbuf_cat+0x8c>)
 800a094:	0018      	movs	r0, r3
 800a096:	f7f8 fd97 	bl	8002bc8 <app_debug_rtt_raw>
 800a09a:	e032      	b.n	800a102 <pbuf_cat+0x86>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 800a09c:	687b      	ldr	r3, [r7, #4]
 800a09e:	60fb      	str	r3, [r7, #12]
 800a0a0:	e00a      	b.n	800a0b8 <pbuf_cat+0x3c>
    /* add total length of second chain to all totals of first chain */
    p->tot_len = (u16_t)(p->tot_len + t->tot_len);
 800a0a2:	68fb      	ldr	r3, [r7, #12]
 800a0a4:	891a      	ldrh	r2, [r3, #8]
 800a0a6:	683b      	ldr	r3, [r7, #0]
 800a0a8:	891b      	ldrh	r3, [r3, #8]
 800a0aa:	18d3      	adds	r3, r2, r3
 800a0ac:	b29a      	uxth	r2, r3
 800a0ae:	68fb      	ldr	r3, [r7, #12]
 800a0b0:	811a      	strh	r2, [r3, #8]
  for (p = h; p->next != NULL; p = p->next) {
 800a0b2:	68fb      	ldr	r3, [r7, #12]
 800a0b4:	681b      	ldr	r3, [r3, #0]
 800a0b6:	60fb      	str	r3, [r7, #12]
 800a0b8:	68fb      	ldr	r3, [r7, #12]
 800a0ba:	681b      	ldr	r3, [r3, #0]
 800a0bc:	2b00      	cmp	r3, #0
 800a0be:	d1f0      	bne.n	800a0a2 <pbuf_cat+0x26>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
 800a0c0:	68fb      	ldr	r3, [r7, #12]
 800a0c2:	891a      	ldrh	r2, [r3, #8]
 800a0c4:	68fb      	ldr	r3, [r7, #12]
 800a0c6:	895b      	ldrh	r3, [r3, #10]
 800a0c8:	429a      	cmp	r2, r3
 800a0ca:	d005      	beq.n	800a0d8 <pbuf_cat+0x5c>
 800a0cc:	4b0f      	ldr	r3, [pc, #60]	; (800a10c <pbuf_cat+0x90>)
 800a0ce:	4a10      	ldr	r2, [pc, #64]	; (800a110 <pbuf_cat+0x94>)
 800a0d0:	4910      	ldr	r1, [pc, #64]	; (800a114 <pbuf_cat+0x98>)
 800a0d2:	4811      	ldr	r0, [pc, #68]	; (800a118 <pbuf_cat+0x9c>)
 800a0d4:	f7f8 fd78 	bl	8002bc8 <app_debug_rtt_raw>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
 800a0d8:	68fb      	ldr	r3, [r7, #12]
 800a0da:	681b      	ldr	r3, [r3, #0]
 800a0dc:	2b00      	cmp	r3, #0
 800a0de:	d005      	beq.n	800a0ec <pbuf_cat+0x70>
 800a0e0:	4b0a      	ldr	r3, [pc, #40]	; (800a10c <pbuf_cat+0x90>)
 800a0e2:	4a0e      	ldr	r2, [pc, #56]	; (800a11c <pbuf_cat+0xa0>)
 800a0e4:	490e      	ldr	r1, [pc, #56]	; (800a120 <pbuf_cat+0xa4>)
 800a0e6:	480c      	ldr	r0, [pc, #48]	; (800a118 <pbuf_cat+0x9c>)
 800a0e8:	f7f8 fd6e 	bl	8002bc8 <app_debug_rtt_raw>
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len = (u16_t)(p->tot_len + t->tot_len);
 800a0ec:	68fb      	ldr	r3, [r7, #12]
 800a0ee:	891a      	ldrh	r2, [r3, #8]
 800a0f0:	683b      	ldr	r3, [r7, #0]
 800a0f2:	891b      	ldrh	r3, [r3, #8]
 800a0f4:	18d3      	adds	r3, r2, r3
 800a0f6:	b29a      	uxth	r2, r3
 800a0f8:	68fb      	ldr	r3, [r7, #12]
 800a0fa:	811a      	strh	r2, [r3, #8]
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
 800a0fc:	68fb      	ldr	r3, [r7, #12]
 800a0fe:	683a      	ldr	r2, [r7, #0]
 800a100:	601a      	str	r2, [r3, #0]
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
 800a102:	46bd      	mov	sp, r7
 800a104:	b004      	add	sp, #16
 800a106:	bd80      	pop	{r7, pc}
 800a108:	0801fab4 	.word	0x0801fab4
 800a10c:	0801f8c4 	.word	0x0801f8c4
 800a110:	00000362 	.word	0x00000362
 800a114:	0801faec 	.word	0x0801faec
 800a118:	0801f91c 	.word	0x0801f91c
 800a11c:	00000363 	.word	0x00000363
 800a120:	0801fb1c 	.word	0x0801fb1c

0800a124 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
 800a124:	b580      	push	{r7, lr}
 800a126:	b082      	sub	sp, #8
 800a128:	af00      	add	r7, sp, #0
 800a12a:	6078      	str	r0, [r7, #4]
 800a12c:	6039      	str	r1, [r7, #0]
  pbuf_cat(h, t);
 800a12e:	683a      	ldr	r2, [r7, #0]
 800a130:	687b      	ldr	r3, [r7, #4]
 800a132:	0011      	movs	r1, r2
 800a134:	0018      	movs	r0, r3
 800a136:	f7ff ffa1 	bl	800a07c <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
 800a13a:	683b      	ldr	r3, [r7, #0]
 800a13c:	0018      	movs	r0, r3
 800a13e:	f7ff ff79 	bl	800a034 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
 800a142:	46c0      	nop			; (mov r8, r8)
 800a144:	46bd      	mov	sp, r7
 800a146:	b002      	add	sp, #8
 800a148:	bd80      	pop	{r7, pc}
	...

0800a14c <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
 800a14c:	b590      	push	{r4, r7, lr}
 800a14e:	b085      	sub	sp, #20
 800a150:	af00      	add	r7, sp, #0
 800a152:	6078      	str	r0, [r7, #4]
  struct pbuf *q;
  u8_t tail_gone = 1;
 800a154:	230f      	movs	r3, #15
 800a156:	18fb      	adds	r3, r7, r3
 800a158:	2201      	movs	r2, #1
 800a15a:	701a      	strb	r2, [r3, #0]
  /* tail */
  q = p->next;
 800a15c:	687b      	ldr	r3, [r7, #4]
 800a15e:	681b      	ldr	r3, [r3, #0]
 800a160:	60bb      	str	r3, [r7, #8]
  /* pbuf has successor in chain? */
  if (q != NULL) {
 800a162:	68bb      	ldr	r3, [r7, #8]
 800a164:	2b00      	cmp	r3, #0
 800a166:	d027      	beq.n	800a1b8 <pbuf_dechain+0x6c>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
 800a168:	68bb      	ldr	r3, [r7, #8]
 800a16a:	891b      	ldrh	r3, [r3, #8]
 800a16c:	001a      	movs	r2, r3
 800a16e:	687b      	ldr	r3, [r7, #4]
 800a170:	891b      	ldrh	r3, [r3, #8]
 800a172:	0019      	movs	r1, r3
 800a174:	687b      	ldr	r3, [r7, #4]
 800a176:	895b      	ldrh	r3, [r3, #10]
 800a178:	1acb      	subs	r3, r1, r3
 800a17a:	429a      	cmp	r2, r3
 800a17c:	d005      	beq.n	800a18a <pbuf_dechain+0x3e>
 800a17e:	4b1a      	ldr	r3, [pc, #104]	; (800a1e8 <pbuf_dechain+0x9c>)
 800a180:	4a1a      	ldr	r2, [pc, #104]	; (800a1ec <pbuf_dechain+0xa0>)
 800a182:	491b      	ldr	r1, [pc, #108]	; (800a1f0 <pbuf_dechain+0xa4>)
 800a184:	481b      	ldr	r0, [pc, #108]	; (800a1f4 <pbuf_dechain+0xa8>)
 800a186:	f7f8 fd1f 	bl	8002bc8 <app_debug_rtt_raw>
    /* enforce invariant if assertion is disabled */
    q->tot_len = (u16_t)(p->tot_len - p->len);
 800a18a:	687b      	ldr	r3, [r7, #4]
 800a18c:	891a      	ldrh	r2, [r3, #8]
 800a18e:	687b      	ldr	r3, [r7, #4]
 800a190:	895b      	ldrh	r3, [r3, #10]
 800a192:	1ad3      	subs	r3, r2, r3
 800a194:	b29a      	uxth	r2, r3
 800a196:	68bb      	ldr	r3, [r7, #8]
 800a198:	811a      	strh	r2, [r3, #8]
    /* decouple pbuf from remainder */
    p->next = NULL;
 800a19a:	687b      	ldr	r3, [r7, #4]
 800a19c:	2200      	movs	r2, #0
 800a19e:	601a      	str	r2, [r3, #0]
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
 800a1a0:	687b      	ldr	r3, [r7, #4]
 800a1a2:	895a      	ldrh	r2, [r3, #10]
 800a1a4:	687b      	ldr	r3, [r7, #4]
 800a1a6:	811a      	strh	r2, [r3, #8]
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
 800a1a8:	230f      	movs	r3, #15
 800a1aa:	18fc      	adds	r4, r7, r3
 800a1ac:	68bb      	ldr	r3, [r7, #8]
 800a1ae:	0018      	movs	r0, r3
 800a1b0:	f7ff fe84 	bl	8009ebc <pbuf_free>
 800a1b4:	0003      	movs	r3, r0
 800a1b6:	7023      	strb	r3, [r4, #0]
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
 800a1b8:	687b      	ldr	r3, [r7, #4]
 800a1ba:	891a      	ldrh	r2, [r3, #8]
 800a1bc:	687b      	ldr	r3, [r7, #4]
 800a1be:	895b      	ldrh	r3, [r3, #10]
 800a1c0:	429a      	cmp	r2, r3
 800a1c2:	d005      	beq.n	800a1d0 <pbuf_dechain+0x84>
 800a1c4:	4b08      	ldr	r3, [pc, #32]	; (800a1e8 <pbuf_dechain+0x9c>)
 800a1c6:	4a0c      	ldr	r2, [pc, #48]	; (800a1f8 <pbuf_dechain+0xac>)
 800a1c8:	490c      	ldr	r1, [pc, #48]	; (800a1fc <pbuf_dechain+0xb0>)
 800a1ca:	480a      	ldr	r0, [pc, #40]	; (800a1f4 <pbuf_dechain+0xa8>)
 800a1cc:	f7f8 fcfc 	bl	8002bc8 <app_debug_rtt_raw>
  return ((tail_gone > 0) ? NULL : q);
 800a1d0:	230f      	movs	r3, #15
 800a1d2:	18fb      	adds	r3, r7, r3
 800a1d4:	781b      	ldrb	r3, [r3, #0]
 800a1d6:	2b00      	cmp	r3, #0
 800a1d8:	d101      	bne.n	800a1de <pbuf_dechain+0x92>
 800a1da:	68bb      	ldr	r3, [r7, #8]
 800a1dc:	e000      	b.n	800a1e0 <pbuf_dechain+0x94>
 800a1de:	2300      	movs	r3, #0
}
 800a1e0:	0018      	movs	r0, r3
 800a1e2:	46bd      	mov	sp, r7
 800a1e4:	b005      	add	sp, #20
 800a1e6:	bd90      	pop	{r4, r7, pc}
 800a1e8:	0801f8c4 	.word	0x0801f8c4
 800a1ec:	00000399 	.word	0x00000399
 800a1f0:	0801fb2c 	.word	0x0801fb2c
 800a1f4:	0801f91c 	.word	0x0801f91c
 800a1f8:	000003aa 	.word	0x000003aa
 800a1fc:	0801fb50 	.word	0x0801fb50

0800a200 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, const struct pbuf *p_from)
{
 800a200:	b580      	push	{r7, lr}
 800a202:	b082      	sub	sp, #8
 800a204:	af00      	add	r7, sp, #0
 800a206:	6078      	str	r0, [r7, #4]
 800a208:	6039      	str	r1, [r7, #0]
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
              (const void *)p_to, (const void *)p_from));

  LWIP_ERROR("pbuf_copy: invalid source", p_from != NULL, return ERR_ARG;);
 800a20a:	683b      	ldr	r3, [r7, #0]
 800a20c:	2b00      	cmp	r3, #0
 800a20e:	d106      	bne.n	800a21e <pbuf_copy+0x1e>
 800a210:	4b09      	ldr	r3, [pc, #36]	; (800a238 <pbuf_copy+0x38>)
 800a212:	0018      	movs	r0, r3
 800a214:	f7f8 fcd8 	bl	8002bc8 <app_debug_rtt_raw>
 800a218:	2310      	movs	r3, #16
 800a21a:	425b      	negs	r3, r3
 800a21c:	e007      	b.n	800a22e <pbuf_copy+0x2e>
  return pbuf_copy_partial_pbuf(p_to, p_from, p_from->tot_len, 0);
 800a21e:	683b      	ldr	r3, [r7, #0]
 800a220:	891a      	ldrh	r2, [r3, #8]
 800a222:	6839      	ldr	r1, [r7, #0]
 800a224:	6878      	ldr	r0, [r7, #4]
 800a226:	2300      	movs	r3, #0
 800a228:	f000 f808 	bl	800a23c <pbuf_copy_partial_pbuf>
 800a22c:	0003      	movs	r3, r0
}
 800a22e:	0018      	movs	r0, r3
 800a230:	46bd      	mov	sp, r7
 800a232:	b002      	add	sp, #8
 800a234:	bd80      	pop	{r7, pc}
 800a236:	46c0      	nop			; (mov r8, r8)
 800a238:	0801fb68 	.word	0x0801fb68

0800a23c <pbuf_copy_partial_pbuf>:
 *                 or p_to is not big enough to hold copy_len at offset
 *         ERR_VAL if any of the pbufs are part of a queue
 */
err_t
pbuf_copy_partial_pbuf(struct pbuf *p_to, const struct pbuf *p_from, u16_t copy_len, u16_t offset)
{
 800a23c:	b590      	push	{r4, r7, lr}
 800a23e:	b089      	sub	sp, #36	; 0x24
 800a240:	af00      	add	r7, sp, #0
 800a242:	60f8      	str	r0, [r7, #12]
 800a244:	60b9      	str	r1, [r7, #8]
 800a246:	0019      	movs	r1, r3
 800a248:	1dbb      	adds	r3, r7, #6
 800a24a:	801a      	strh	r2, [r3, #0]
 800a24c:	1d3b      	adds	r3, r7, #4
 800a24e:	1c0a      	adds	r2, r1, #0
 800a250:	801a      	strh	r2, [r3, #0]
  size_t offset_to = offset, offset_from = 0, len_calc;
 800a252:	1d3b      	adds	r3, r7, #4
 800a254:	881b      	ldrh	r3, [r3, #0]
 800a256:	61fb      	str	r3, [r7, #28]
 800a258:	2300      	movs	r3, #0
 800a25a:	61bb      	str	r3, [r7, #24]

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy_partial_pbuf(%p, %p, %"U16_F", %"U16_F")\n",
              (const void *)p_to, (const void *)p_from, copy_len, offset));

  /* is the copy_len in range? */
  LWIP_ERROR("pbuf_copy_partial_pbuf: copy_len bigger than source", ((p_from != NULL) &&
 800a25c:	68bb      	ldr	r3, [r7, #8]
 800a25e:	2b00      	cmp	r3, #0
 800a260:	d005      	beq.n	800a26e <pbuf_copy_partial_pbuf+0x32>
 800a262:	68bb      	ldr	r3, [r7, #8]
 800a264:	891b      	ldrh	r3, [r3, #8]
 800a266:	1dba      	adds	r2, r7, #6
 800a268:	8812      	ldrh	r2, [r2, #0]
 800a26a:	429a      	cmp	r2, r3
 800a26c:	d906      	bls.n	800a27c <pbuf_copy_partial_pbuf+0x40>
 800a26e:	4b6d      	ldr	r3, [pc, #436]	; (800a424 <pbuf_copy_partial_pbuf+0x1e8>)
 800a270:	0018      	movs	r0, r3
 800a272:	f7f8 fca9 	bl	8002bc8 <app_debug_rtt_raw>
 800a276:	2310      	movs	r3, #16
 800a278:	425b      	negs	r3, r3
 800a27a:	e0cf      	b.n	800a41c <pbuf_copy_partial_pbuf+0x1e0>
             (p_from->tot_len >= copy_len)), return ERR_ARG;);
  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy_partial_pbuf: target not big enough", ((p_to != NULL) &&
 800a27c:	68fb      	ldr	r3, [r7, #12]
 800a27e:	2b00      	cmp	r3, #0
 800a280:	d009      	beq.n	800a296 <pbuf_copy_partial_pbuf+0x5a>
 800a282:	68fb      	ldr	r3, [r7, #12]
 800a284:	891b      	ldrh	r3, [r3, #8]
 800a286:	0019      	movs	r1, r3
 800a288:	1d3b      	adds	r3, r7, #4
 800a28a:	881a      	ldrh	r2, [r3, #0]
 800a28c:	1dbb      	adds	r3, r7, #6
 800a28e:	881b      	ldrh	r3, [r3, #0]
 800a290:	18d3      	adds	r3, r2, r3
 800a292:	4299      	cmp	r1, r3
 800a294:	da06      	bge.n	800a2a4 <pbuf_copy_partial_pbuf+0x68>
 800a296:	4b64      	ldr	r3, [pc, #400]	; (800a428 <pbuf_copy_partial_pbuf+0x1ec>)
 800a298:	0018      	movs	r0, r3
 800a29a:	f7f8 fc95 	bl	8002bc8 <app_debug_rtt_raw>
 800a29e:	2310      	movs	r3, #16
 800a2a0:	425b      	negs	r3, r3
 800a2a2:	e0bb      	b.n	800a41c <pbuf_copy_partial_pbuf+0x1e0>
             (p_to->tot_len >= (offset + copy_len))), return ERR_ARG;);

  /* iterate through pbuf chain */
  do {
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
 800a2a4:	68fb      	ldr	r3, [r7, #12]
 800a2a6:	895b      	ldrh	r3, [r3, #10]
 800a2a8:	001a      	movs	r2, r3
 800a2aa:	69fb      	ldr	r3, [r7, #28]
 800a2ac:	1ad2      	subs	r2, r2, r3
 800a2ae:	68bb      	ldr	r3, [r7, #8]
 800a2b0:	895b      	ldrh	r3, [r3, #10]
 800a2b2:	0019      	movs	r1, r3
 800a2b4:	69bb      	ldr	r3, [r7, #24]
 800a2b6:	1acb      	subs	r3, r1, r3
 800a2b8:	429a      	cmp	r2, r3
 800a2ba:	d306      	bcc.n	800a2ca <pbuf_copy_partial_pbuf+0x8e>
      /* complete current p_from fits into current p_to */
      len_calc = p_from->len - offset_from;
 800a2bc:	68bb      	ldr	r3, [r7, #8]
 800a2be:	895b      	ldrh	r3, [r3, #10]
 800a2c0:	001a      	movs	r2, r3
 800a2c2:	69bb      	ldr	r3, [r7, #24]
 800a2c4:	1ad3      	subs	r3, r2, r3
 800a2c6:	617b      	str	r3, [r7, #20]
 800a2c8:	e005      	b.n	800a2d6 <pbuf_copy_partial_pbuf+0x9a>
    } else {
      /* current p_from does not fit into current p_to */
      len_calc = p_to->len - offset_to;
 800a2ca:	68fb      	ldr	r3, [r7, #12]
 800a2cc:	895b      	ldrh	r3, [r3, #10]
 800a2ce:	001a      	movs	r2, r3
 800a2d0:	69fb      	ldr	r3, [r7, #28]
 800a2d2:	1ad3      	subs	r3, r2, r3
 800a2d4:	617b      	str	r3, [r7, #20]
    }
    len = (u16_t)LWIP_MIN(copy_len, len_calc);
 800a2d6:	1dbb      	adds	r3, r7, #6
 800a2d8:	881b      	ldrh	r3, [r3, #0]
 800a2da:	697a      	ldr	r2, [r7, #20]
 800a2dc:	429a      	cmp	r2, r3
 800a2de:	d802      	bhi.n	800a2e6 <pbuf_copy_partial_pbuf+0xaa>
 800a2e0:	697b      	ldr	r3, [r7, #20]
 800a2e2:	b29b      	uxth	r3, r3
 800a2e4:	e001      	b.n	800a2ea <pbuf_copy_partial_pbuf+0xae>
 800a2e6:	1dbb      	adds	r3, r7, #6
 800a2e8:	881b      	ldrh	r3, [r3, #0]
 800a2ea:	2412      	movs	r4, #18
 800a2ec:	193a      	adds	r2, r7, r4
 800a2ee:	8013      	strh	r3, [r2, #0]
    MEMCPY((u8_t *)p_to->payload + offset_to, (u8_t *)p_from->payload + offset_from, len);
 800a2f0:	68fb      	ldr	r3, [r7, #12]
 800a2f2:	685a      	ldr	r2, [r3, #4]
 800a2f4:	69fb      	ldr	r3, [r7, #28]
 800a2f6:	18d0      	adds	r0, r2, r3
 800a2f8:	68bb      	ldr	r3, [r7, #8]
 800a2fa:	685a      	ldr	r2, [r3, #4]
 800a2fc:	69bb      	ldr	r3, [r7, #24]
 800a2fe:	18d1      	adds	r1, r2, r3
 800a300:	193b      	adds	r3, r7, r4
 800a302:	881b      	ldrh	r3, [r3, #0]
 800a304:	001a      	movs	r2, r3
 800a306:	f012 fde1 	bl	801cecc <memcpy>
    offset_to += len;
 800a30a:	193b      	adds	r3, r7, r4
 800a30c:	881b      	ldrh	r3, [r3, #0]
 800a30e:	69fa      	ldr	r2, [r7, #28]
 800a310:	18d3      	adds	r3, r2, r3
 800a312:	61fb      	str	r3, [r7, #28]
    offset_from += len;
 800a314:	193b      	adds	r3, r7, r4
 800a316:	881b      	ldrh	r3, [r3, #0]
 800a318:	69ba      	ldr	r2, [r7, #24]
 800a31a:	18d3      	adds	r3, r2, r3
 800a31c:	61bb      	str	r3, [r7, #24]
    copy_len -= len;
 800a31e:	1dbb      	adds	r3, r7, #6
 800a320:	1db9      	adds	r1, r7, #6
 800a322:	193a      	adds	r2, r7, r4
 800a324:	8809      	ldrh	r1, [r1, #0]
 800a326:	8812      	ldrh	r2, [r2, #0]
 800a328:	1a8a      	subs	r2, r1, r2
 800a32a:	801a      	strh	r2, [r3, #0]
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 800a32c:	68fb      	ldr	r3, [r7, #12]
 800a32e:	895b      	ldrh	r3, [r3, #10]
 800a330:	001a      	movs	r2, r3
 800a332:	69fb      	ldr	r3, [r7, #28]
 800a334:	4293      	cmp	r3, r2
 800a336:	d905      	bls.n	800a344 <pbuf_copy_partial_pbuf+0x108>
 800a338:	4b3c      	ldr	r3, [pc, #240]	; (800a42c <pbuf_copy_partial_pbuf+0x1f0>)
 800a33a:	4a3d      	ldr	r2, [pc, #244]	; (800a430 <pbuf_copy_partial_pbuf+0x1f4>)
 800a33c:	493d      	ldr	r1, [pc, #244]	; (800a434 <pbuf_copy_partial_pbuf+0x1f8>)
 800a33e:	483e      	ldr	r0, [pc, #248]	; (800a438 <pbuf_copy_partial_pbuf+0x1fc>)
 800a340:	f7f8 fc42 	bl	8002bc8 <app_debug_rtt_raw>
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
 800a344:	68bb      	ldr	r3, [r7, #8]
 800a346:	895b      	ldrh	r3, [r3, #10]
 800a348:	001a      	movs	r2, r3
 800a34a:	69bb      	ldr	r3, [r7, #24]
 800a34c:	4293      	cmp	r3, r2
 800a34e:	d905      	bls.n	800a35c <pbuf_copy_partial_pbuf+0x120>
 800a350:	4b36      	ldr	r3, [pc, #216]	; (800a42c <pbuf_copy_partial_pbuf+0x1f0>)
 800a352:	4a3a      	ldr	r2, [pc, #232]	; (800a43c <pbuf_copy_partial_pbuf+0x200>)
 800a354:	493a      	ldr	r1, [pc, #232]	; (800a440 <pbuf_copy_partial_pbuf+0x204>)
 800a356:	4838      	ldr	r0, [pc, #224]	; (800a438 <pbuf_copy_partial_pbuf+0x1fc>)
 800a358:	f7f8 fc36 	bl	8002bc8 <app_debug_rtt_raw>
    if (offset_from >= p_from->len) {
 800a35c:	68bb      	ldr	r3, [r7, #8]
 800a35e:	895b      	ldrh	r3, [r3, #10]
 800a360:	001a      	movs	r2, r3
 800a362:	69bb      	ldr	r3, [r7, #24]
 800a364:	4293      	cmp	r3, r2
 800a366:	d312      	bcc.n	800a38e <pbuf_copy_partial_pbuf+0x152>
      /* on to next p_from (if any) */
      offset_from = 0;
 800a368:	2300      	movs	r3, #0
 800a36a:	61bb      	str	r3, [r7, #24]
      p_from = p_from->next;
 800a36c:	68bb      	ldr	r3, [r7, #8]
 800a36e:	681b      	ldr	r3, [r3, #0]
 800a370:	60bb      	str	r3, [r7, #8]
      LWIP_ERROR("p_from != NULL", (p_from != NULL) || (copy_len == 0), return ERR_ARG;);
 800a372:	68bb      	ldr	r3, [r7, #8]
 800a374:	2b00      	cmp	r3, #0
 800a376:	d10a      	bne.n	800a38e <pbuf_copy_partial_pbuf+0x152>
 800a378:	1dbb      	adds	r3, r7, #6
 800a37a:	881b      	ldrh	r3, [r3, #0]
 800a37c:	2b00      	cmp	r3, #0
 800a37e:	d006      	beq.n	800a38e <pbuf_copy_partial_pbuf+0x152>
 800a380:	4b30      	ldr	r3, [pc, #192]	; (800a444 <pbuf_copy_partial_pbuf+0x208>)
 800a382:	0018      	movs	r0, r3
 800a384:	f7f8 fc20 	bl	8002bc8 <app_debug_rtt_raw>
 800a388:	2310      	movs	r3, #16
 800a38a:	425b      	negs	r3, r3
 800a38c:	e046      	b.n	800a41c <pbuf_copy_partial_pbuf+0x1e0>
    }
    if (offset_to == p_to->len) {
 800a38e:	68fb      	ldr	r3, [r7, #12]
 800a390:	895b      	ldrh	r3, [r3, #10]
 800a392:	001a      	movs	r2, r3
 800a394:	69fb      	ldr	r3, [r7, #28]
 800a396:	4293      	cmp	r3, r2
 800a398:	d112      	bne.n	800a3c0 <pbuf_copy_partial_pbuf+0x184>
      /* on to next p_to (if any) */
      offset_to = 0;
 800a39a:	2300      	movs	r3, #0
 800a39c:	61fb      	str	r3, [r7, #28]
      p_to = p_to->next;
 800a39e:	68fb      	ldr	r3, [r7, #12]
 800a3a0:	681b      	ldr	r3, [r3, #0]
 800a3a2:	60fb      	str	r3, [r7, #12]
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (copy_len == 0), return ERR_ARG;);
 800a3a4:	68fb      	ldr	r3, [r7, #12]
 800a3a6:	2b00      	cmp	r3, #0
 800a3a8:	d10a      	bne.n	800a3c0 <pbuf_copy_partial_pbuf+0x184>
 800a3aa:	1dbb      	adds	r3, r7, #6
 800a3ac:	881b      	ldrh	r3, [r3, #0]
 800a3ae:	2b00      	cmp	r3, #0
 800a3b0:	d006      	beq.n	800a3c0 <pbuf_copy_partial_pbuf+0x184>
 800a3b2:	4b25      	ldr	r3, [pc, #148]	; (800a448 <pbuf_copy_partial_pbuf+0x20c>)
 800a3b4:	0018      	movs	r0, r3
 800a3b6:	f7f8 fc07 	bl	8002bc8 <app_debug_rtt_raw>
 800a3ba:	2310      	movs	r3, #16
 800a3bc:	425b      	negs	r3, r3
 800a3be:	e02d      	b.n	800a41c <pbuf_copy_partial_pbuf+0x1e0>
    }

    if ((p_from != NULL) && (p_from->len == p_from->tot_len)) {
 800a3c0:	68bb      	ldr	r3, [r7, #8]
 800a3c2:	2b00      	cmp	r3, #0
 800a3c4:	d010      	beq.n	800a3e8 <pbuf_copy_partial_pbuf+0x1ac>
 800a3c6:	68bb      	ldr	r3, [r7, #8]
 800a3c8:	895a      	ldrh	r2, [r3, #10]
 800a3ca:	68bb      	ldr	r3, [r7, #8]
 800a3cc:	891b      	ldrh	r3, [r3, #8]
 800a3ce:	429a      	cmp	r2, r3
 800a3d0:	d10a      	bne.n	800a3e8 <pbuf_copy_partial_pbuf+0x1ac>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy_partial_pbuf() does not allow packet queues!",
 800a3d2:	68bb      	ldr	r3, [r7, #8]
 800a3d4:	681b      	ldr	r3, [r3, #0]
 800a3d6:	2b00      	cmp	r3, #0
 800a3d8:	d006      	beq.n	800a3e8 <pbuf_copy_partial_pbuf+0x1ac>
 800a3da:	4b1c      	ldr	r3, [pc, #112]	; (800a44c <pbuf_copy_partial_pbuf+0x210>)
 800a3dc:	0018      	movs	r0, r3
 800a3de:	f7f8 fbf3 	bl	8002bc8 <app_debug_rtt_raw>
 800a3e2:	2306      	movs	r3, #6
 800a3e4:	425b      	negs	r3, r3
 800a3e6:	e019      	b.n	800a41c <pbuf_copy_partial_pbuf+0x1e0>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if ((p_to != NULL) && (p_to->len == p_to->tot_len)) {
 800a3e8:	68fb      	ldr	r3, [r7, #12]
 800a3ea:	2b00      	cmp	r3, #0
 800a3ec:	d010      	beq.n	800a410 <pbuf_copy_partial_pbuf+0x1d4>
 800a3ee:	68fb      	ldr	r3, [r7, #12]
 800a3f0:	895a      	ldrh	r2, [r3, #10]
 800a3f2:	68fb      	ldr	r3, [r7, #12]
 800a3f4:	891b      	ldrh	r3, [r3, #8]
 800a3f6:	429a      	cmp	r2, r3
 800a3f8:	d10a      	bne.n	800a410 <pbuf_copy_partial_pbuf+0x1d4>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy_partial_pbuf() does not allow packet queues!",
 800a3fa:	68fb      	ldr	r3, [r7, #12]
 800a3fc:	681b      	ldr	r3, [r3, #0]
 800a3fe:	2b00      	cmp	r3, #0
 800a400:	d006      	beq.n	800a410 <pbuf_copy_partial_pbuf+0x1d4>
 800a402:	4b12      	ldr	r3, [pc, #72]	; (800a44c <pbuf_copy_partial_pbuf+0x210>)
 800a404:	0018      	movs	r0, r3
 800a406:	f7f8 fbdf 	bl	8002bc8 <app_debug_rtt_raw>
 800a40a:	2306      	movs	r3, #6
 800a40c:	425b      	negs	r3, r3
 800a40e:	e005      	b.n	800a41c <pbuf_copy_partial_pbuf+0x1e0>
                 (p_to->next == NULL), return ERR_VAL;);
    }
  } while (copy_len);
 800a410:	1dbb      	adds	r3, r7, #6
 800a412:	881b      	ldrh	r3, [r3, #0]
 800a414:	2b00      	cmp	r3, #0
 800a416:	d000      	beq.n	800a41a <pbuf_copy_partial_pbuf+0x1de>
 800a418:	e744      	b.n	800a2a4 <pbuf_copy_partial_pbuf+0x68>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy_partial_pbuf: copy complete.\n"));
  return ERR_OK;
 800a41a:	2300      	movs	r3, #0
}
 800a41c:	0018      	movs	r0, r3
 800a41e:	46bd      	mov	sp, r7
 800a420:	b009      	add	sp, #36	; 0x24
 800a422:	bd90      	pop	{r4, r7, pc}
 800a424:	0801fb84 	.word	0x0801fb84
 800a428:	0801fbb8 	.word	0x0801fbb8
 800a42c:	0801f8c4 	.word	0x0801f8c4
 800a430:	000003fa 	.word	0x000003fa
 800a434:	0801fbe8 	.word	0x0801fbe8
 800a438:	0801f91c 	.word	0x0801f91c
 800a43c:	000003fb 	.word	0x000003fb
 800a440:	0801fc00 	.word	0x0801fc00
 800a444:	0801fc1c 	.word	0x0801fc1c
 800a448:	0801fc2c 	.word	0x0801fc2c
 800a44c:	0801fc3c 	.word	0x0801fc3c

0800a450 <pbuf_copy_partial>:
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t
pbuf_copy_partial(const struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
 800a450:	b5b0      	push	{r4, r5, r7, lr}
 800a452:	b088      	sub	sp, #32
 800a454:	af00      	add	r7, sp, #0
 800a456:	60f8      	str	r0, [r7, #12]
 800a458:	60b9      	str	r1, [r7, #8]
 800a45a:	0019      	movs	r1, r3
 800a45c:	1dbb      	adds	r3, r7, #6
 800a45e:	801a      	strh	r2, [r3, #0]
 800a460:	1d3b      	adds	r3, r7, #4
 800a462:	1c0a      	adds	r2, r1, #0
 800a464:	801a      	strh	r2, [r3, #0]
  const struct pbuf *p;
  u16_t left = 0;
 800a466:	231a      	movs	r3, #26
 800a468:	18fb      	adds	r3, r7, r3
 800a46a:	2200      	movs	r2, #0
 800a46c:	801a      	strh	r2, [r3, #0]
  u16_t buf_copy_len;
  u16_t copied_total = 0;
 800a46e:	2316      	movs	r3, #22
 800a470:	18fb      	adds	r3, r7, r3
 800a472:	2200      	movs	r2, #0
 800a474:	801a      	strh	r2, [r3, #0]

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 800a476:	68fb      	ldr	r3, [r7, #12]
 800a478:	2b00      	cmp	r3, #0
 800a47a:	d105      	bne.n	800a488 <pbuf_copy_partial+0x38>
 800a47c:	4b38      	ldr	r3, [pc, #224]	; (800a560 <pbuf_copy_partial+0x110>)
 800a47e:	0018      	movs	r0, r3
 800a480:	f7f8 fba2 	bl	8002bc8 <app_debug_rtt_raw>
 800a484:	2300      	movs	r3, #0
 800a486:	e066      	b.n	800a556 <pbuf_copy_partial+0x106>
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 800a488:	68bb      	ldr	r3, [r7, #8]
 800a48a:	2b00      	cmp	r3, #0
 800a48c:	d105      	bne.n	800a49a <pbuf_copy_partial+0x4a>
 800a48e:	4b35      	ldr	r3, [pc, #212]	; (800a564 <pbuf_copy_partial+0x114>)
 800a490:	0018      	movs	r0, r3
 800a492:	f7f8 fb99 	bl	8002bc8 <app_debug_rtt_raw>
 800a496:	2300      	movs	r3, #0
 800a498:	e05d      	b.n	800a556 <pbuf_copy_partial+0x106>

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for (p = buf; len != 0 && p != NULL; p = p->next) {
 800a49a:	68fb      	ldr	r3, [r7, #12]
 800a49c:	61fb      	str	r3, [r7, #28]
 800a49e:	e050      	b.n	800a542 <pbuf_copy_partial+0xf2>
    if ((offset != 0) && (offset >= p->len)) {
 800a4a0:	1d3b      	adds	r3, r7, #4
 800a4a2:	881b      	ldrh	r3, [r3, #0]
 800a4a4:	2b00      	cmp	r3, #0
 800a4a6:	d00d      	beq.n	800a4c4 <pbuf_copy_partial+0x74>
 800a4a8:	69fb      	ldr	r3, [r7, #28]
 800a4aa:	895b      	ldrh	r3, [r3, #10]
 800a4ac:	1d3a      	adds	r2, r7, #4
 800a4ae:	8812      	ldrh	r2, [r2, #0]
 800a4b0:	429a      	cmp	r2, r3
 800a4b2:	d307      	bcc.n	800a4c4 <pbuf_copy_partial+0x74>
      /* don't copy from this buffer -> on to the next */
      offset = (u16_t)(offset - p->len);
 800a4b4:	69fb      	ldr	r3, [r7, #28]
 800a4b6:	895a      	ldrh	r2, [r3, #10]
 800a4b8:	1d3b      	adds	r3, r7, #4
 800a4ba:	1d39      	adds	r1, r7, #4
 800a4bc:	8809      	ldrh	r1, [r1, #0]
 800a4be:	1a8a      	subs	r2, r1, r2
 800a4c0:	801a      	strh	r2, [r3, #0]
 800a4c2:	e03b      	b.n	800a53c <pbuf_copy_partial+0xec>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = (u16_t)(p->len - offset);
 800a4c4:	69fb      	ldr	r3, [r7, #28]
 800a4c6:	8959      	ldrh	r1, [r3, #10]
 800a4c8:	2018      	movs	r0, #24
 800a4ca:	183b      	adds	r3, r7, r0
 800a4cc:	1d3a      	adds	r2, r7, #4
 800a4ce:	8812      	ldrh	r2, [r2, #0]
 800a4d0:	1a8a      	subs	r2, r1, r2
 800a4d2:	801a      	strh	r2, [r3, #0]
      if (buf_copy_len > len) {
 800a4d4:	183a      	adds	r2, r7, r0
 800a4d6:	1dbb      	adds	r3, r7, #6
 800a4d8:	8812      	ldrh	r2, [r2, #0]
 800a4da:	881b      	ldrh	r3, [r3, #0]
 800a4dc:	429a      	cmp	r2, r3
 800a4de:	d903      	bls.n	800a4e8 <pbuf_copy_partial+0x98>
        buf_copy_len = len;
 800a4e0:	183b      	adds	r3, r7, r0
 800a4e2:	1dba      	adds	r2, r7, #6
 800a4e4:	8812      	ldrh	r2, [r2, #0]
 800a4e6:	801a      	strh	r2, [r3, #0]
      }
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char *)dataptr)[left], &((char *)p->payload)[offset], buf_copy_len);
 800a4e8:	251a      	movs	r5, #26
 800a4ea:	197b      	adds	r3, r7, r5
 800a4ec:	881b      	ldrh	r3, [r3, #0]
 800a4ee:	68ba      	ldr	r2, [r7, #8]
 800a4f0:	18d0      	adds	r0, r2, r3
 800a4f2:	69fb      	ldr	r3, [r7, #28]
 800a4f4:	685a      	ldr	r2, [r3, #4]
 800a4f6:	1d3b      	adds	r3, r7, #4
 800a4f8:	881b      	ldrh	r3, [r3, #0]
 800a4fa:	18d1      	adds	r1, r2, r3
 800a4fc:	2418      	movs	r4, #24
 800a4fe:	193b      	adds	r3, r7, r4
 800a500:	881b      	ldrh	r3, [r3, #0]
 800a502:	001a      	movs	r2, r3
 800a504:	f012 fce2 	bl	801cecc <memcpy>
      copied_total = (u16_t)(copied_total + buf_copy_len);
 800a508:	2216      	movs	r2, #22
 800a50a:	18bb      	adds	r3, r7, r2
 800a50c:	18b9      	adds	r1, r7, r2
 800a50e:	0020      	movs	r0, r4
 800a510:	183a      	adds	r2, r7, r0
 800a512:	8809      	ldrh	r1, [r1, #0]
 800a514:	8812      	ldrh	r2, [r2, #0]
 800a516:	188a      	adds	r2, r1, r2
 800a518:	801a      	strh	r2, [r3, #0]
      left = (u16_t)(left + buf_copy_len);
 800a51a:	197b      	adds	r3, r7, r5
 800a51c:	1979      	adds	r1, r7, r5
 800a51e:	183a      	adds	r2, r7, r0
 800a520:	8809      	ldrh	r1, [r1, #0]
 800a522:	8812      	ldrh	r2, [r2, #0]
 800a524:	188a      	adds	r2, r1, r2
 800a526:	801a      	strh	r2, [r3, #0]
      len = (u16_t)(len - buf_copy_len);
 800a528:	1dbb      	adds	r3, r7, #6
 800a52a:	1db9      	adds	r1, r7, #6
 800a52c:	183a      	adds	r2, r7, r0
 800a52e:	8809      	ldrh	r1, [r1, #0]
 800a530:	8812      	ldrh	r2, [r2, #0]
 800a532:	1a8a      	subs	r2, r1, r2
 800a534:	801a      	strh	r2, [r3, #0]
      offset = 0;
 800a536:	1d3b      	adds	r3, r7, #4
 800a538:	2200      	movs	r2, #0
 800a53a:	801a      	strh	r2, [r3, #0]
  for (p = buf; len != 0 && p != NULL; p = p->next) {
 800a53c:	69fb      	ldr	r3, [r7, #28]
 800a53e:	681b      	ldr	r3, [r3, #0]
 800a540:	61fb      	str	r3, [r7, #28]
 800a542:	1dbb      	adds	r3, r7, #6
 800a544:	881b      	ldrh	r3, [r3, #0]
 800a546:	2b00      	cmp	r3, #0
 800a548:	d002      	beq.n	800a550 <pbuf_copy_partial+0x100>
 800a54a:	69fb      	ldr	r3, [r7, #28]
 800a54c:	2b00      	cmp	r3, #0
 800a54e:	d1a7      	bne.n	800a4a0 <pbuf_copy_partial+0x50>
    }
  }
  return copied_total;
 800a550:	2316      	movs	r3, #22
 800a552:	18fb      	adds	r3, r7, r3
 800a554:	881b      	ldrh	r3, [r3, #0]
}
 800a556:	0018      	movs	r0, r3
 800a558:	46bd      	mov	sp, r7
 800a55a:	b008      	add	sp, #32
 800a55c:	bdb0      	pop	{r4, r5, r7, pc}
 800a55e:	46c0      	nop			; (mov r8, r8)
 800a560:	0801fc74 	.word	0x0801fc74
 800a564:	0801fc94 	.word	0x0801fc94

0800a568 <pbuf_skip_const>:
#endif /* LWIP_TCP && TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */

/* Actual implementation of pbuf_skip() but returning const pointer... */
static const struct pbuf *
pbuf_skip_const(const struct pbuf *in, u16_t in_offset, u16_t *out_offset)
{
 800a568:	b580      	push	{r7, lr}
 800a56a:	b086      	sub	sp, #24
 800a56c:	af00      	add	r7, sp, #0
 800a56e:	60f8      	str	r0, [r7, #12]
 800a570:	607a      	str	r2, [r7, #4]
 800a572:	200a      	movs	r0, #10
 800a574:	183b      	adds	r3, r7, r0
 800a576:	1c0a      	adds	r2, r1, #0
 800a578:	801a      	strh	r2, [r3, #0]
  u16_t offset_left = in_offset;
 800a57a:	2316      	movs	r3, #22
 800a57c:	18fb      	adds	r3, r7, r3
 800a57e:	183a      	adds	r2, r7, r0
 800a580:	8812      	ldrh	r2, [r2, #0]
 800a582:	801a      	strh	r2, [r3, #0]
  const struct pbuf *q = in;
 800a584:	68fb      	ldr	r3, [r7, #12]
 800a586:	613b      	str	r3, [r7, #16]

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= offset_left)) {
 800a588:	e00a      	b.n	800a5a0 <pbuf_skip_const+0x38>
    offset_left = (u16_t)(offset_left - q->len);
 800a58a:	693b      	ldr	r3, [r7, #16]
 800a58c:	895a      	ldrh	r2, [r3, #10]
 800a58e:	2116      	movs	r1, #22
 800a590:	187b      	adds	r3, r7, r1
 800a592:	1879      	adds	r1, r7, r1
 800a594:	8809      	ldrh	r1, [r1, #0]
 800a596:	1a8a      	subs	r2, r1, r2
 800a598:	801a      	strh	r2, [r3, #0]
    q = q->next;
 800a59a:	693b      	ldr	r3, [r7, #16]
 800a59c:	681b      	ldr	r3, [r3, #0]
 800a59e:	613b      	str	r3, [r7, #16]
  while ((q != NULL) && (q->len <= offset_left)) {
 800a5a0:	693b      	ldr	r3, [r7, #16]
 800a5a2:	2b00      	cmp	r3, #0
 800a5a4:	d006      	beq.n	800a5b4 <pbuf_skip_const+0x4c>
 800a5a6:	693b      	ldr	r3, [r7, #16]
 800a5a8:	895b      	ldrh	r3, [r3, #10]
 800a5aa:	2216      	movs	r2, #22
 800a5ac:	18ba      	adds	r2, r7, r2
 800a5ae:	8812      	ldrh	r2, [r2, #0]
 800a5b0:	429a      	cmp	r2, r3
 800a5b2:	d2ea      	bcs.n	800a58a <pbuf_skip_const+0x22>
  }
  if (out_offset != NULL) {
 800a5b4:	687b      	ldr	r3, [r7, #4]
 800a5b6:	2b00      	cmp	r3, #0
 800a5b8:	d004      	beq.n	800a5c4 <pbuf_skip_const+0x5c>
    *out_offset = offset_left;
 800a5ba:	687b      	ldr	r3, [r7, #4]
 800a5bc:	2216      	movs	r2, #22
 800a5be:	18ba      	adds	r2, r7, r2
 800a5c0:	8812      	ldrh	r2, [r2, #0]
 800a5c2:	801a      	strh	r2, [r3, #0]
  }
  return q;
 800a5c4:	693b      	ldr	r3, [r7, #16]
}
 800a5c6:	0018      	movs	r0, r3
 800a5c8:	46bd      	mov	sp, r7
 800a5ca:	b006      	add	sp, #24
 800a5cc:	bd80      	pop	{r7, pc}

0800a5ce <pbuf_skip>:
 * @param out_offset resulting offset in the returned pbuf
 * @return the pbuf in the queue where the offset is
 */
struct pbuf *
pbuf_skip(struct pbuf *in, u16_t in_offset, u16_t *out_offset)
{
 800a5ce:	b580      	push	{r7, lr}
 800a5d0:	b086      	sub	sp, #24
 800a5d2:	af00      	add	r7, sp, #0
 800a5d4:	60f8      	str	r0, [r7, #12]
 800a5d6:	607a      	str	r2, [r7, #4]
 800a5d8:	200a      	movs	r0, #10
 800a5da:	183b      	adds	r3, r7, r0
 800a5dc:	1c0a      	adds	r2, r1, #0
 800a5de:	801a      	strh	r2, [r3, #0]
  const struct pbuf *out = pbuf_skip_const(in, in_offset, out_offset);
 800a5e0:	687a      	ldr	r2, [r7, #4]
 800a5e2:	183b      	adds	r3, r7, r0
 800a5e4:	8819      	ldrh	r1, [r3, #0]
 800a5e6:	68fb      	ldr	r3, [r7, #12]
 800a5e8:	0018      	movs	r0, r3
 800a5ea:	f7ff ffbd 	bl	800a568 <pbuf_skip_const>
 800a5ee:	0003      	movs	r3, r0
 800a5f0:	617b      	str	r3, [r7, #20]
  return LWIP_CONST_CAST(struct pbuf *, out);
 800a5f2:	697b      	ldr	r3, [r7, #20]
}
 800a5f4:	0018      	movs	r0, r3
 800a5f6:	46bd      	mov	sp, r7
 800a5f8:	b006      	add	sp, #24
 800a5fa:	bd80      	pop	{r7, pc}

0800a5fc <pbuf_take>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
{
 800a5fc:	b580      	push	{r7, lr}
 800a5fe:	b088      	sub	sp, #32
 800a600:	af00      	add	r7, sp, #0
 800a602:	60f8      	str	r0, [r7, #12]
 800a604:	60b9      	str	r1, [r7, #8]
 800a606:	1dbb      	adds	r3, r7, #6
 800a608:	801a      	strh	r2, [r3, #0]
  struct pbuf *p;
  size_t buf_copy_len;
  size_t total_copy_len = len;
 800a60a:	1dbb      	adds	r3, r7, #6
 800a60c:	881b      	ldrh	r3, [r3, #0]
 800a60e:	617b      	str	r3, [r7, #20]
  size_t copied_total = 0;
 800a610:	2300      	movs	r3, #0
 800a612:	613b      	str	r3, [r7, #16]

  LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return ERR_ARG;);
 800a614:	68fb      	ldr	r3, [r7, #12]
 800a616:	2b00      	cmp	r3, #0
 800a618:	d106      	bne.n	800a628 <pbuf_take+0x2c>
 800a61a:	4b37      	ldr	r3, [pc, #220]	; (800a6f8 <pbuf_take+0xfc>)
 800a61c:	0018      	movs	r0, r3
 800a61e:	f7f8 fad3 	bl	8002bc8 <app_debug_rtt_raw>
 800a622:	2310      	movs	r3, #16
 800a624:	425b      	negs	r3, r3
 800a626:	e062      	b.n	800a6ee <pbuf_take+0xf2>
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
 800a628:	68bb      	ldr	r3, [r7, #8]
 800a62a:	2b00      	cmp	r3, #0
 800a62c:	d106      	bne.n	800a63c <pbuf_take+0x40>
 800a62e:	4b33      	ldr	r3, [pc, #204]	; (800a6fc <pbuf_take+0x100>)
 800a630:	0018      	movs	r0, r3
 800a632:	f7f8 fac9 	bl	8002bc8 <app_debug_rtt_raw>
 800a636:	2310      	movs	r3, #16
 800a638:	425b      	negs	r3, r3
 800a63a:	e058      	b.n	800a6ee <pbuf_take+0xf2>
  LWIP_ERROR("pbuf_take: buf not large enough", (buf->tot_len >= len), return ERR_MEM;);
 800a63c:	68fb      	ldr	r3, [r7, #12]
 800a63e:	891b      	ldrh	r3, [r3, #8]
 800a640:	1dba      	adds	r2, r7, #6
 800a642:	8812      	ldrh	r2, [r2, #0]
 800a644:	429a      	cmp	r2, r3
 800a646:	d906      	bls.n	800a656 <pbuf_take+0x5a>
 800a648:	4b2d      	ldr	r3, [pc, #180]	; (800a700 <pbuf_take+0x104>)
 800a64a:	0018      	movs	r0, r3
 800a64c:	f7f8 fabc 	bl	8002bc8 <app_debug_rtt_raw>
 800a650:	2301      	movs	r3, #1
 800a652:	425b      	negs	r3, r3
 800a654:	e04b      	b.n	800a6ee <pbuf_take+0xf2>

  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
 800a656:	68fb      	ldr	r3, [r7, #12]
 800a658:	2b00      	cmp	r3, #0
 800a65a:	d008      	beq.n	800a66e <pbuf_take+0x72>
 800a65c:	68bb      	ldr	r3, [r7, #8]
 800a65e:	2b00      	cmp	r3, #0
 800a660:	d005      	beq.n	800a66e <pbuf_take+0x72>
 800a662:	68fb      	ldr	r3, [r7, #12]
 800a664:	891b      	ldrh	r3, [r3, #8]
 800a666:	1dba      	adds	r2, r7, #6
 800a668:	8812      	ldrh	r2, [r2, #0]
 800a66a:	429a      	cmp	r2, r3
 800a66c:	d902      	bls.n	800a674 <pbuf_take+0x78>
    return ERR_ARG;
 800a66e:	2310      	movs	r3, #16
 800a670:	425b      	negs	r3, r3
 800a672:	e03c      	b.n	800a6ee <pbuf_take+0xf2>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for (p = buf; total_copy_len != 0; p = p->next) {
 800a674:	68fb      	ldr	r3, [r7, #12]
 800a676:	61fb      	str	r3, [r7, #28]
 800a678:	e027      	b.n	800a6ca <pbuf_take+0xce>
    LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
 800a67a:	69fb      	ldr	r3, [r7, #28]
 800a67c:	2b00      	cmp	r3, #0
 800a67e:	d105      	bne.n	800a68c <pbuf_take+0x90>
 800a680:	4b20      	ldr	r3, [pc, #128]	; (800a704 <pbuf_take+0x108>)
 800a682:	4a21      	ldr	r2, [pc, #132]	; (800a708 <pbuf_take+0x10c>)
 800a684:	4921      	ldr	r1, [pc, #132]	; (800a70c <pbuf_take+0x110>)
 800a686:	4822      	ldr	r0, [pc, #136]	; (800a710 <pbuf_take+0x114>)
 800a688:	f7f8 fa9e 	bl	8002bc8 <app_debug_rtt_raw>
    buf_copy_len = total_copy_len;
 800a68c:	697b      	ldr	r3, [r7, #20]
 800a68e:	61bb      	str	r3, [r7, #24]
    if (buf_copy_len > p->len) {
 800a690:	69fb      	ldr	r3, [r7, #28]
 800a692:	895b      	ldrh	r3, [r3, #10]
 800a694:	001a      	movs	r2, r3
 800a696:	69bb      	ldr	r3, [r7, #24]
 800a698:	4293      	cmp	r3, r2
 800a69a:	d902      	bls.n	800a6a2 <pbuf_take+0xa6>
      /* this pbuf cannot hold all remaining data */
      buf_copy_len = p->len;
 800a69c:	69fb      	ldr	r3, [r7, #28]
 800a69e:	895b      	ldrh	r3, [r3, #10]
 800a6a0:	61bb      	str	r3, [r7, #24]
    }
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((const char *)dataptr)[copied_total], buf_copy_len);
 800a6a2:	69fb      	ldr	r3, [r7, #28]
 800a6a4:	6858      	ldr	r0, [r3, #4]
 800a6a6:	68ba      	ldr	r2, [r7, #8]
 800a6a8:	693b      	ldr	r3, [r7, #16]
 800a6aa:	18d3      	adds	r3, r2, r3
 800a6ac:	69ba      	ldr	r2, [r7, #24]
 800a6ae:	0019      	movs	r1, r3
 800a6b0:	f012 fc0c 	bl	801cecc <memcpy>
    total_copy_len -= buf_copy_len;
 800a6b4:	697a      	ldr	r2, [r7, #20]
 800a6b6:	69bb      	ldr	r3, [r7, #24]
 800a6b8:	1ad3      	subs	r3, r2, r3
 800a6ba:	617b      	str	r3, [r7, #20]
    copied_total += buf_copy_len;
 800a6bc:	693a      	ldr	r2, [r7, #16]
 800a6be:	69bb      	ldr	r3, [r7, #24]
 800a6c0:	18d3      	adds	r3, r2, r3
 800a6c2:	613b      	str	r3, [r7, #16]
  for (p = buf; total_copy_len != 0; p = p->next) {
 800a6c4:	69fb      	ldr	r3, [r7, #28]
 800a6c6:	681b      	ldr	r3, [r3, #0]
 800a6c8:	61fb      	str	r3, [r7, #28]
 800a6ca:	697b      	ldr	r3, [r7, #20]
 800a6cc:	2b00      	cmp	r3, #0
 800a6ce:	d1d4      	bne.n	800a67a <pbuf_take+0x7e>
  }
  LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
 800a6d0:	697b      	ldr	r3, [r7, #20]
 800a6d2:	2b00      	cmp	r3, #0
 800a6d4:	d104      	bne.n	800a6e0 <pbuf_take+0xe4>
 800a6d6:	1dbb      	adds	r3, r7, #6
 800a6d8:	881b      	ldrh	r3, [r3, #0]
 800a6da:	693a      	ldr	r2, [r7, #16]
 800a6dc:	429a      	cmp	r2, r3
 800a6de:	d005      	beq.n	800a6ec <pbuf_take+0xf0>
 800a6e0:	4b08      	ldr	r3, [pc, #32]	; (800a704 <pbuf_take+0x108>)
 800a6e2:	4a0c      	ldr	r2, [pc, #48]	; (800a714 <pbuf_take+0x118>)
 800a6e4:	490c      	ldr	r1, [pc, #48]	; (800a718 <pbuf_take+0x11c>)
 800a6e6:	480a      	ldr	r0, [pc, #40]	; (800a710 <pbuf_take+0x114>)
 800a6e8:	f7f8 fa6e 	bl	8002bc8 <app_debug_rtt_raw>
  return ERR_OK;
 800a6ec:	2300      	movs	r3, #0
}
 800a6ee:	0018      	movs	r0, r3
 800a6f0:	46bd      	mov	sp, r7
 800a6f2:	b008      	add	sp, #32
 800a6f4:	bd80      	pop	{r7, pc}
 800a6f6:	46c0      	nop			; (mov r8, r8)
 800a6f8:	0801fd04 	.word	0x0801fd04
 800a6fc:	0801fd1c 	.word	0x0801fd1c
 800a700:	0801fd38 	.word	0x0801fd38
 800a704:	0801f8c4 	.word	0x0801f8c4
 800a708:	000004df 	.word	0x000004df
 800a70c:	0801fd58 	.word	0x0801fd58
 800a710:	0801f91c 	.word	0x0801f91c
 800a714:	000004ea 	.word	0x000004ea
 800a718:	0801fd70 	.word	0x0801fd70

0800a71c <pbuf_take_at>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take_at(struct pbuf *buf, const void *dataptr, u16_t len, u16_t offset)
{
 800a71c:	b590      	push	{r4, r7, lr}
 800a71e:	b089      	sub	sp, #36	; 0x24
 800a720:	af00      	add	r7, sp, #0
 800a722:	60f8      	str	r0, [r7, #12]
 800a724:	60b9      	str	r1, [r7, #8]
 800a726:	0019      	movs	r1, r3
 800a728:	1dbb      	adds	r3, r7, #6
 800a72a:	801a      	strh	r2, [r3, #0]
 800a72c:	1d3b      	adds	r3, r7, #4
 800a72e:	1c0a      	adds	r2, r1, #0
 800a730:	801a      	strh	r2, [r3, #0]
  u16_t target_offset;
  struct pbuf *q = pbuf_skip(buf, offset, &target_offset);
 800a732:	2410      	movs	r4, #16
 800a734:	193a      	adds	r2, r7, r4
 800a736:	1d3b      	adds	r3, r7, #4
 800a738:	8819      	ldrh	r1, [r3, #0]
 800a73a:	68fb      	ldr	r3, [r7, #12]
 800a73c:	0018      	movs	r0, r3
 800a73e:	f7ff ff46 	bl	800a5ce <pbuf_skip>
 800a742:	0003      	movs	r3, r0
 800a744:	61fb      	str	r3, [r7, #28]

  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->tot_len >= target_offset + len)) {
 800a746:	69fb      	ldr	r3, [r7, #28]
 800a748:	2b00      	cmp	r3, #0
 800a74a:	d060      	beq.n	800a80e <pbuf_take_at+0xf2>
 800a74c:	69fb      	ldr	r3, [r7, #28]
 800a74e:	891b      	ldrh	r3, [r3, #8]
 800a750:	001a      	movs	r2, r3
 800a752:	0020      	movs	r0, r4
 800a754:	183b      	adds	r3, r7, r0
 800a756:	881b      	ldrh	r3, [r3, #0]
 800a758:	0019      	movs	r1, r3
 800a75a:	1dbb      	adds	r3, r7, #6
 800a75c:	881b      	ldrh	r3, [r3, #0]
 800a75e:	18cb      	adds	r3, r1, r3
 800a760:	429a      	cmp	r2, r3
 800a762:	db54      	blt.n	800a80e <pbuf_take_at+0xf2>
    u16_t remaining_len = len;
 800a764:	231a      	movs	r3, #26
 800a766:	18fb      	adds	r3, r7, r3
 800a768:	1dba      	adds	r2, r7, #6
 800a76a:	8812      	ldrh	r2, [r2, #0]
 800a76c:	801a      	strh	r2, [r3, #0]
    const u8_t *src_ptr = (const u8_t *)dataptr;
 800a76e:	68bb      	ldr	r3, [r7, #8]
 800a770:	617b      	str	r3, [r7, #20]
    /* copy the part that goes into the first pbuf */
    u16_t first_copy_len;
    LWIP_ASSERT("check pbuf_skip result", target_offset < q->len);
 800a772:	69fb      	ldr	r3, [r7, #28]
 800a774:	895a      	ldrh	r2, [r3, #10]
 800a776:	183b      	adds	r3, r7, r0
 800a778:	881b      	ldrh	r3, [r3, #0]
 800a77a:	429a      	cmp	r2, r3
 800a77c:	d805      	bhi.n	800a78a <pbuf_take_at+0x6e>
 800a77e:	4b27      	ldr	r3, [pc, #156]	; (800a81c <pbuf_take_at+0x100>)
 800a780:	4a27      	ldr	r2, [pc, #156]	; (800a820 <pbuf_take_at+0x104>)
 800a782:	4928      	ldr	r1, [pc, #160]	; (800a824 <pbuf_take_at+0x108>)
 800a784:	4828      	ldr	r0, [pc, #160]	; (800a828 <pbuf_take_at+0x10c>)
 800a786:	f7f8 fa1f 	bl	8002bc8 <app_debug_rtt_raw>
    first_copy_len = (u16_t)LWIP_MIN(q->len - target_offset, len);
 800a78a:	69fb      	ldr	r3, [r7, #28]
 800a78c:	895b      	ldrh	r3, [r3, #10]
 800a78e:	001a      	movs	r2, r3
 800a790:	2110      	movs	r1, #16
 800a792:	187b      	adds	r3, r7, r1
 800a794:	881b      	ldrh	r3, [r3, #0]
 800a796:	1ad2      	subs	r2, r2, r3
 800a798:	1dbb      	adds	r3, r7, #6
 800a79a:	881b      	ldrh	r3, [r3, #0]
 800a79c:	429a      	cmp	r2, r3
 800a79e:	da06      	bge.n	800a7ae <pbuf_take_at+0x92>
 800a7a0:	69fb      	ldr	r3, [r7, #28]
 800a7a2:	895a      	ldrh	r2, [r3, #10]
 800a7a4:	187b      	adds	r3, r7, r1
 800a7a6:	881b      	ldrh	r3, [r3, #0]
 800a7a8:	1ad3      	subs	r3, r2, r3
 800a7aa:	b29b      	uxth	r3, r3
 800a7ac:	e001      	b.n	800a7b2 <pbuf_take_at+0x96>
 800a7ae:	1dbb      	adds	r3, r7, #6
 800a7b0:	881b      	ldrh	r3, [r3, #0]
 800a7b2:	2112      	movs	r1, #18
 800a7b4:	187a      	adds	r2, r7, r1
 800a7b6:	8013      	strh	r3, [r2, #0]
    MEMCPY(((u8_t *)q->payload) + target_offset, dataptr, first_copy_len);
 800a7b8:	69fb      	ldr	r3, [r7, #28]
 800a7ba:	685b      	ldr	r3, [r3, #4]
 800a7bc:	2210      	movs	r2, #16
 800a7be:	18ba      	adds	r2, r7, r2
 800a7c0:	8812      	ldrh	r2, [r2, #0]
 800a7c2:	1898      	adds	r0, r3, r2
 800a7c4:	000c      	movs	r4, r1
 800a7c6:	187b      	adds	r3, r7, r1
 800a7c8:	881a      	ldrh	r2, [r3, #0]
 800a7ca:	68bb      	ldr	r3, [r7, #8]
 800a7cc:	0019      	movs	r1, r3
 800a7ce:	f012 fb7d 	bl	801cecc <memcpy>
    remaining_len = (u16_t)(remaining_len - first_copy_len);
 800a7d2:	201a      	movs	r0, #26
 800a7d4:	183b      	adds	r3, r7, r0
 800a7d6:	1839      	adds	r1, r7, r0
 800a7d8:	193a      	adds	r2, r7, r4
 800a7da:	8809      	ldrh	r1, [r1, #0]
 800a7dc:	8812      	ldrh	r2, [r2, #0]
 800a7de:	1a8a      	subs	r2, r1, r2
 800a7e0:	801a      	strh	r2, [r3, #0]
    src_ptr += first_copy_len;
 800a7e2:	193b      	adds	r3, r7, r4
 800a7e4:	881b      	ldrh	r3, [r3, #0]
 800a7e6:	697a      	ldr	r2, [r7, #20]
 800a7e8:	18d3      	adds	r3, r2, r3
 800a7ea:	617b      	str	r3, [r7, #20]
    if (remaining_len > 0) {
 800a7ec:	0002      	movs	r2, r0
 800a7ee:	18bb      	adds	r3, r7, r2
 800a7f0:	881b      	ldrh	r3, [r3, #0]
 800a7f2:	2b00      	cmp	r3, #0
 800a7f4:	d009      	beq.n	800a80a <pbuf_take_at+0xee>
      return pbuf_take(q->next, src_ptr, remaining_len);
 800a7f6:	69fb      	ldr	r3, [r7, #28]
 800a7f8:	6818      	ldr	r0, [r3, #0]
 800a7fa:	18bb      	adds	r3, r7, r2
 800a7fc:	881a      	ldrh	r2, [r3, #0]
 800a7fe:	697b      	ldr	r3, [r7, #20]
 800a800:	0019      	movs	r1, r3
 800a802:	f7ff fefb 	bl	800a5fc <pbuf_take>
 800a806:	0003      	movs	r3, r0
 800a808:	e003      	b.n	800a812 <pbuf_take_at+0xf6>
    }
    return ERR_OK;
 800a80a:	2300      	movs	r3, #0
 800a80c:	e001      	b.n	800a812 <pbuf_take_at+0xf6>
  }
  return ERR_MEM;
 800a80e:	2301      	movs	r3, #1
 800a810:	425b      	negs	r3, r3
}
 800a812:	0018      	movs	r0, r3
 800a814:	46bd      	mov	sp, r7
 800a816:	b009      	add	sp, #36	; 0x24
 800a818:	bd90      	pop	{r4, r7, pc}
 800a81a:	46c0      	nop			; (mov r8, r8)
 800a81c:	0801f8c4 	.word	0x0801f8c4
 800a820:	00000505 	.word	0x00000505
 800a824:	0801fd88 	.word	0x0801fd88
 800a828:	0801f91c 	.word	0x0801f91c

0800a82c <pbuf_coalesce>:
 * @return a new, single pbuf (p->next is NULL)
 *         or the old pbuf if allocation fails
 */
struct pbuf *
pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
{
 800a82c:	b580      	push	{r7, lr}
 800a82e:	b084      	sub	sp, #16
 800a830:	af00      	add	r7, sp, #0
 800a832:	6078      	str	r0, [r7, #4]
 800a834:	000a      	movs	r2, r1
 800a836:	1cfb      	adds	r3, r7, #3
 800a838:	701a      	strb	r2, [r3, #0]
  struct pbuf *q;
  if (p->next == NULL) {
 800a83a:	687b      	ldr	r3, [r7, #4]
 800a83c:	681b      	ldr	r3, [r3, #0]
 800a83e:	2b00      	cmp	r3, #0
 800a840:	d101      	bne.n	800a846 <pbuf_coalesce+0x1a>
    return p;
 800a842:	687b      	ldr	r3, [r7, #4]
 800a844:	e013      	b.n	800a86e <pbuf_coalesce+0x42>
  }
  q = pbuf_clone(layer, PBUF_RAM, p);
 800a846:	687a      	ldr	r2, [r7, #4]
 800a848:	23a0      	movs	r3, #160	; 0xa0
 800a84a:	0099      	lsls	r1, r3, #2
 800a84c:	1cfb      	adds	r3, r7, #3
 800a84e:	781b      	ldrb	r3, [r3, #0]
 800a850:	0018      	movs	r0, r3
 800a852:	f000 f811 	bl	800a878 <pbuf_clone>
 800a856:	0003      	movs	r3, r0
 800a858:	60fb      	str	r3, [r7, #12]
  if (q == NULL) {
 800a85a:	68fb      	ldr	r3, [r7, #12]
 800a85c:	2b00      	cmp	r3, #0
 800a85e:	d101      	bne.n	800a864 <pbuf_coalesce+0x38>
    /* @todo: what do we do now? */
    return p;
 800a860:	687b      	ldr	r3, [r7, #4]
 800a862:	e004      	b.n	800a86e <pbuf_coalesce+0x42>
  }
  pbuf_free(p);
 800a864:	687b      	ldr	r3, [r7, #4]
 800a866:	0018      	movs	r0, r3
 800a868:	f7ff fb28 	bl	8009ebc <pbuf_free>
  return q;
 800a86c:	68fb      	ldr	r3, [r7, #12]
}
 800a86e:	0018      	movs	r0, r3
 800a870:	46bd      	mov	sp, r7
 800a872:	b004      	add	sp, #16
 800a874:	bd80      	pop	{r7, pc}
	...

0800a878 <pbuf_clone>:
 *
 * @return a new pbuf or NULL if allocation fails
 */
struct pbuf *
pbuf_clone(pbuf_layer layer, pbuf_type type, struct pbuf *p)
{
 800a878:	b5b0      	push	{r4, r5, r7, lr}
 800a87a:	b084      	sub	sp, #16
 800a87c:	af00      	add	r7, sp, #0
 800a87e:	603a      	str	r2, [r7, #0]
 800a880:	1dfb      	adds	r3, r7, #7
 800a882:	1c02      	adds	r2, r0, #0
 800a884:	701a      	strb	r2, [r3, #0]
 800a886:	1d3b      	adds	r3, r7, #4
 800a888:	1c0a      	adds	r2, r1, #0
 800a88a:	801a      	strh	r2, [r3, #0]
  struct pbuf *q;
  err_t err;
  q = pbuf_alloc(layer, p->tot_len, type);
 800a88c:	683b      	ldr	r3, [r7, #0]
 800a88e:	8919      	ldrh	r1, [r3, #8]
 800a890:	1d3b      	adds	r3, r7, #4
 800a892:	881a      	ldrh	r2, [r3, #0]
 800a894:	1dfb      	adds	r3, r7, #7
 800a896:	781b      	ldrb	r3, [r3, #0]
 800a898:	0018      	movs	r0, r3
 800a89a:	f7fe ff97 	bl	80097cc <pbuf_alloc>
 800a89e:	0003      	movs	r3, r0
 800a8a0:	60fb      	str	r3, [r7, #12]
  if (q == NULL) {
 800a8a2:	68fb      	ldr	r3, [r7, #12]
 800a8a4:	2b00      	cmp	r3, #0
 800a8a6:	d101      	bne.n	800a8ac <pbuf_clone+0x34>
    return NULL;
 800a8a8:	2300      	movs	r3, #0
 800a8aa:	e015      	b.n	800a8d8 <pbuf_clone+0x60>
  }
  err = pbuf_copy(q, p);
 800a8ac:	250b      	movs	r5, #11
 800a8ae:	197c      	adds	r4, r7, r5
 800a8b0:	683a      	ldr	r2, [r7, #0]
 800a8b2:	68fb      	ldr	r3, [r7, #12]
 800a8b4:	0011      	movs	r1, r2
 800a8b6:	0018      	movs	r0, r3
 800a8b8:	f7ff fca2 	bl	800a200 <pbuf_copy>
 800a8bc:	0003      	movs	r3, r0
 800a8be:	7023      	strb	r3, [r4, #0]
  LWIP_UNUSED_ARG(err); /* in case of LWIP_NOASSERT */
  LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
 800a8c0:	197b      	adds	r3, r7, r5
 800a8c2:	781b      	ldrb	r3, [r3, #0]
 800a8c4:	b25b      	sxtb	r3, r3
 800a8c6:	2b00      	cmp	r3, #0
 800a8c8:	d005      	beq.n	800a8d6 <pbuf_clone+0x5e>
 800a8ca:	4b05      	ldr	r3, [pc, #20]	; (800a8e0 <pbuf_clone+0x68>)
 800a8cc:	4a05      	ldr	r2, [pc, #20]	; (800a8e4 <pbuf_clone+0x6c>)
 800a8ce:	4906      	ldr	r1, [pc, #24]	; (800a8e8 <pbuf_clone+0x70>)
 800a8d0:	4806      	ldr	r0, [pc, #24]	; (800a8ec <pbuf_clone+0x74>)
 800a8d2:	f7f8 f979 	bl	8002bc8 <app_debug_rtt_raw>
  return q;
 800a8d6:	68fb      	ldr	r3, [r7, #12]
}
 800a8d8:	0018      	movs	r0, r3
 800a8da:	46bd      	mov	sp, r7
 800a8dc:	b004      	add	sp, #16
 800a8de:	bdb0      	pop	{r4, r5, r7, pc}
 800a8e0:	0801f8c4 	.word	0x0801f8c4
 800a8e4:	00000546 	.word	0x00000546
 800a8e8:	0801fda0 	.word	0x0801fda0
 800a8ec:	0801f91c 	.word	0x0801f91c

0800a8f0 <pbuf_get_at>:
 * @param offset offset into p of the byte to return
 * @return byte at an offset into p OR ZERO IF 'offset' >= p->tot_len
 */
u8_t
pbuf_get_at(const struct pbuf *p, u16_t offset)
{
 800a8f0:	b580      	push	{r7, lr}
 800a8f2:	b084      	sub	sp, #16
 800a8f4:	af00      	add	r7, sp, #0
 800a8f6:	6078      	str	r0, [r7, #4]
 800a8f8:	000a      	movs	r2, r1
 800a8fa:	1cbb      	adds	r3, r7, #2
 800a8fc:	801a      	strh	r2, [r3, #0]
  int ret = pbuf_try_get_at(p, offset);
 800a8fe:	1cbb      	adds	r3, r7, #2
 800a900:	881a      	ldrh	r2, [r3, #0]
 800a902:	687b      	ldr	r3, [r7, #4]
 800a904:	0011      	movs	r1, r2
 800a906:	0018      	movs	r0, r3
 800a908:	f000 f80d 	bl	800a926 <pbuf_try_get_at>
 800a90c:	0003      	movs	r3, r0
 800a90e:	60fb      	str	r3, [r7, #12]
  if (ret >= 0) {
 800a910:	68fb      	ldr	r3, [r7, #12]
 800a912:	2b00      	cmp	r3, #0
 800a914:	db02      	blt.n	800a91c <pbuf_get_at+0x2c>
    return (u8_t)ret;
 800a916:	68fb      	ldr	r3, [r7, #12]
 800a918:	b2db      	uxtb	r3, r3
 800a91a:	e000      	b.n	800a91e <pbuf_get_at+0x2e>
  }
  return 0;
 800a91c:	2300      	movs	r3, #0
}
 800a91e:	0018      	movs	r0, r3
 800a920:	46bd      	mov	sp, r7
 800a922:	b004      	add	sp, #16
 800a924:	bd80      	pop	{r7, pc}

0800a926 <pbuf_try_get_at>:
 * @param offset offset into p of the byte to return
 * @return byte at an offset into p [0..0xFF] OR negative if 'offset' >= p->tot_len
 */
int
pbuf_try_get_at(const struct pbuf *p, u16_t offset)
{
 800a926:	b590      	push	{r4, r7, lr}
 800a928:	b085      	sub	sp, #20
 800a92a:	af00      	add	r7, sp, #0
 800a92c:	6078      	str	r0, [r7, #4]
 800a92e:	000a      	movs	r2, r1
 800a930:	1cbb      	adds	r3, r7, #2
 800a932:	801a      	strh	r2, [r3, #0]
  u16_t q_idx;
  const struct pbuf *q = pbuf_skip_const(p, offset, &q_idx);
 800a934:	240a      	movs	r4, #10
 800a936:	193a      	adds	r2, r7, r4
 800a938:	1cbb      	adds	r3, r7, #2
 800a93a:	8819      	ldrh	r1, [r3, #0]
 800a93c:	687b      	ldr	r3, [r7, #4]
 800a93e:	0018      	movs	r0, r3
 800a940:	f7ff fe12 	bl	800a568 <pbuf_skip_const>
 800a944:	0003      	movs	r3, r0
 800a946:	60fb      	str	r3, [r7, #12]

  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > q_idx)) {
 800a948:	68fb      	ldr	r3, [r7, #12]
 800a94a:	2b00      	cmp	r3, #0
 800a94c:	d00c      	beq.n	800a968 <pbuf_try_get_at+0x42>
 800a94e:	68fb      	ldr	r3, [r7, #12]
 800a950:	895a      	ldrh	r2, [r3, #10]
 800a952:	193b      	adds	r3, r7, r4
 800a954:	881b      	ldrh	r3, [r3, #0]
 800a956:	429a      	cmp	r2, r3
 800a958:	d906      	bls.n	800a968 <pbuf_try_get_at+0x42>
    return ((u8_t *)q->payload)[q_idx];
 800a95a:	68fb      	ldr	r3, [r7, #12]
 800a95c:	685b      	ldr	r3, [r3, #4]
 800a95e:	193a      	adds	r2, r7, r4
 800a960:	8812      	ldrh	r2, [r2, #0]
 800a962:	189b      	adds	r3, r3, r2
 800a964:	781b      	ldrb	r3, [r3, #0]
 800a966:	e001      	b.n	800a96c <pbuf_try_get_at+0x46>
  }
  return -1;
 800a968:	2301      	movs	r3, #1
 800a96a:	425b      	negs	r3, r3
}
 800a96c:	0018      	movs	r0, r3
 800a96e:	46bd      	mov	sp, r7
 800a970:	b005      	add	sp, #20
 800a972:	bd90      	pop	{r4, r7, pc}

0800a974 <pbuf_put_at>:
 * @param offset offset into p of the byte to write
 * @param data byte to write at an offset into p
 */
void
pbuf_put_at(struct pbuf *p, u16_t offset, u8_t data)
{
 800a974:	b590      	push	{r4, r7, lr}
 800a976:	b085      	sub	sp, #20
 800a978:	af00      	add	r7, sp, #0
 800a97a:	6078      	str	r0, [r7, #4]
 800a97c:	0008      	movs	r0, r1
 800a97e:	0011      	movs	r1, r2
 800a980:	1cbb      	adds	r3, r7, #2
 800a982:	1c02      	adds	r2, r0, #0
 800a984:	801a      	strh	r2, [r3, #0]
 800a986:	1c7b      	adds	r3, r7, #1
 800a988:	1c0a      	adds	r2, r1, #0
 800a98a:	701a      	strb	r2, [r3, #0]
  u16_t q_idx;
  struct pbuf *q = pbuf_skip(p, offset, &q_idx);
 800a98c:	240a      	movs	r4, #10
 800a98e:	193a      	adds	r2, r7, r4
 800a990:	1cbb      	adds	r3, r7, #2
 800a992:	8819      	ldrh	r1, [r3, #0]
 800a994:	687b      	ldr	r3, [r7, #4]
 800a996:	0018      	movs	r0, r3
 800a998:	f7ff fe19 	bl	800a5ce <pbuf_skip>
 800a99c:	0003      	movs	r3, r0
 800a99e:	60fb      	str	r3, [r7, #12]

  /* write requested data if pbuf is OK */
  if ((q != NULL) && (q->len > q_idx)) {
 800a9a0:	68fb      	ldr	r3, [r7, #12]
 800a9a2:	2b00      	cmp	r3, #0
 800a9a4:	d00d      	beq.n	800a9c2 <pbuf_put_at+0x4e>
 800a9a6:	68fb      	ldr	r3, [r7, #12]
 800a9a8:	895a      	ldrh	r2, [r3, #10]
 800a9aa:	193b      	adds	r3, r7, r4
 800a9ac:	881b      	ldrh	r3, [r3, #0]
 800a9ae:	429a      	cmp	r2, r3
 800a9b0:	d907      	bls.n	800a9c2 <pbuf_put_at+0x4e>
    ((u8_t *)q->payload)[q_idx] = data;
 800a9b2:	68fb      	ldr	r3, [r7, #12]
 800a9b4:	685b      	ldr	r3, [r3, #4]
 800a9b6:	193a      	adds	r2, r7, r4
 800a9b8:	8812      	ldrh	r2, [r2, #0]
 800a9ba:	189b      	adds	r3, r3, r2
 800a9bc:	1c7a      	adds	r2, r7, #1
 800a9be:	7812      	ldrb	r2, [r2, #0]
 800a9c0:	701a      	strb	r2, [r3, #0]
  }
}
 800a9c2:	46c0      	nop			; (mov r8, r8)
 800a9c4:	46bd      	mov	sp, r7
 800a9c6:	b005      	add	sp, #20
 800a9c8:	bd90      	pop	{r4, r7, pc}
	...

0800a9cc <pbuf_memcmp>:
 * @return zero if equal, nonzero otherwise
 *         (0xffff if p is too short, diffoffset+1 otherwise)
 */
u16_t
pbuf_memcmp(const struct pbuf *p, u16_t offset, const void *s2, u16_t n)
{
 800a9cc:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a9ce:	b089      	sub	sp, #36	; 0x24
 800a9d0:	af00      	add	r7, sp, #0
 800a9d2:	60f8      	str	r0, [r7, #12]
 800a9d4:	0008      	movs	r0, r1
 800a9d6:	607a      	str	r2, [r7, #4]
 800a9d8:	0019      	movs	r1, r3
 800a9da:	240a      	movs	r4, #10
 800a9dc:	193b      	adds	r3, r7, r4
 800a9de:	1c02      	adds	r2, r0, #0
 800a9e0:	801a      	strh	r2, [r3, #0]
 800a9e2:	2008      	movs	r0, #8
 800a9e4:	183b      	adds	r3, r7, r0
 800a9e6:	1c0a      	adds	r2, r1, #0
 800a9e8:	801a      	strh	r2, [r3, #0]
  u16_t start = offset;
 800a9ea:	231e      	movs	r3, #30
 800a9ec:	18fb      	adds	r3, r7, r3
 800a9ee:	193a      	adds	r2, r7, r4
 800a9f0:	8812      	ldrh	r2, [r2, #0]
 800a9f2:	801a      	strh	r2, [r3, #0]
  const struct pbuf *q = p;
 800a9f4:	68fb      	ldr	r3, [r7, #12]
 800a9f6:	61bb      	str	r3, [r7, #24]
  u16_t i;

  /* pbuf long enough to perform check? */
  if (p->tot_len < (offset + n)) {
 800a9f8:	68fb      	ldr	r3, [r7, #12]
 800a9fa:	891b      	ldrh	r3, [r3, #8]
 800a9fc:	0019      	movs	r1, r3
 800a9fe:	193b      	adds	r3, r7, r4
 800aa00:	881a      	ldrh	r2, [r3, #0]
 800aa02:	183b      	adds	r3, r7, r0
 800aa04:	881b      	ldrh	r3, [r3, #0]
 800aa06:	18d3      	adds	r3, r2, r3
 800aa08:	4299      	cmp	r1, r3
 800aa0a:	da0c      	bge.n	800aa26 <pbuf_memcmp+0x5a>
    return 0xffff;
 800aa0c:	4b2d      	ldr	r3, [pc, #180]	; (800aac4 <pbuf_memcmp+0xf8>)
 800aa0e:	e054      	b.n	800aaba <pbuf_memcmp+0xee>
  }

  /* get the correct pbuf from chain. We know it succeeds because of p->tot_len check above. */
  while ((q != NULL) && (q->len <= start)) {
    start = (u16_t)(start - q->len);
 800aa10:	69bb      	ldr	r3, [r7, #24]
 800aa12:	895a      	ldrh	r2, [r3, #10]
 800aa14:	211e      	movs	r1, #30
 800aa16:	187b      	adds	r3, r7, r1
 800aa18:	1879      	adds	r1, r7, r1
 800aa1a:	8809      	ldrh	r1, [r1, #0]
 800aa1c:	1a8a      	subs	r2, r1, r2
 800aa1e:	801a      	strh	r2, [r3, #0]
    q = q->next;
 800aa20:	69bb      	ldr	r3, [r7, #24]
 800aa22:	681b      	ldr	r3, [r3, #0]
 800aa24:	61bb      	str	r3, [r7, #24]
  while ((q != NULL) && (q->len <= start)) {
 800aa26:	69bb      	ldr	r3, [r7, #24]
 800aa28:	2b00      	cmp	r3, #0
 800aa2a:	d006      	beq.n	800aa3a <pbuf_memcmp+0x6e>
 800aa2c:	69bb      	ldr	r3, [r7, #24]
 800aa2e:	895b      	ldrh	r3, [r3, #10]
 800aa30:	221e      	movs	r2, #30
 800aa32:	18ba      	adds	r2, r7, r2
 800aa34:	8812      	ldrh	r2, [r2, #0]
 800aa36:	429a      	cmp	r2, r3
 800aa38:	d2ea      	bcs.n	800aa10 <pbuf_memcmp+0x44>
  }

  /* return requested data if pbuf is OK */
  for (i = 0; i < n; i++) {
 800aa3a:	2316      	movs	r3, #22
 800aa3c:	18fb      	adds	r3, r7, r3
 800aa3e:	2200      	movs	r2, #0
 800aa40:	801a      	strh	r2, [r3, #0]
 800aa42:	e031      	b.n	800aaa8 <pbuf_memcmp+0xdc>
    /* We know pbuf_get_at() succeeds because of p->tot_len check above. */
    u8_t a = pbuf_get_at(q, (u16_t)(start + i));
 800aa44:	231e      	movs	r3, #30
 800aa46:	18fa      	adds	r2, r7, r3
 800aa48:	2516      	movs	r5, #22
 800aa4a:	197b      	adds	r3, r7, r5
 800aa4c:	8812      	ldrh	r2, [r2, #0]
 800aa4e:	881b      	ldrh	r3, [r3, #0]
 800aa50:	18d3      	adds	r3, r2, r3
 800aa52:	b29a      	uxth	r2, r3
 800aa54:	2615      	movs	r6, #21
 800aa56:	19bc      	adds	r4, r7, r6
 800aa58:	69bb      	ldr	r3, [r7, #24]
 800aa5a:	0011      	movs	r1, r2
 800aa5c:	0018      	movs	r0, r3
 800aa5e:	f7ff ff47 	bl	800a8f0 <pbuf_get_at>
 800aa62:	0003      	movs	r3, r0
 800aa64:	7023      	strb	r3, [r4, #0]
    u8_t b = ((const u8_t *)s2)[i];
 800aa66:	0029      	movs	r1, r5
 800aa68:	187b      	adds	r3, r7, r1
 800aa6a:	881b      	ldrh	r3, [r3, #0]
 800aa6c:	687a      	ldr	r2, [r7, #4]
 800aa6e:	18d2      	adds	r2, r2, r3
 800aa70:	2014      	movs	r0, #20
 800aa72:	183b      	adds	r3, r7, r0
 800aa74:	7812      	ldrb	r2, [r2, #0]
 800aa76:	701a      	strb	r2, [r3, #0]
    if (a != b) {
 800aa78:	19ba      	adds	r2, r7, r6
 800aa7a:	183b      	adds	r3, r7, r0
 800aa7c:	7812      	ldrb	r2, [r2, #0]
 800aa7e:	781b      	ldrb	r3, [r3, #0]
 800aa80:	429a      	cmp	r2, r3
 800aa82:	d00b      	beq.n	800aa9c <pbuf_memcmp+0xd0>
      return (u16_t)LWIP_MIN(i + 1, 0xFFFF);
 800aa84:	187b      	adds	r3, r7, r1
 800aa86:	881b      	ldrh	r3, [r3, #0]
 800aa88:	b29a      	uxth	r2, r3
 800aa8a:	490f      	ldr	r1, [pc, #60]	; (800aac8 <pbuf_memcmp+0xfc>)
 800aa8c:	428a      	cmp	r2, r1
 800aa8e:	d901      	bls.n	800aa94 <pbuf_memcmp+0xc8>
 800aa90:	2302      	movs	r3, #2
 800aa92:	425b      	negs	r3, r3
 800aa94:	b29b      	uxth	r3, r3
 800aa96:	3301      	adds	r3, #1
 800aa98:	b29b      	uxth	r3, r3
 800aa9a:	e00e      	b.n	800aaba <pbuf_memcmp+0xee>
  for (i = 0; i < n; i++) {
 800aa9c:	2116      	movs	r1, #22
 800aa9e:	187b      	adds	r3, r7, r1
 800aaa0:	881a      	ldrh	r2, [r3, #0]
 800aaa2:	187b      	adds	r3, r7, r1
 800aaa4:	3201      	adds	r2, #1
 800aaa6:	801a      	strh	r2, [r3, #0]
 800aaa8:	2316      	movs	r3, #22
 800aaaa:	18fa      	adds	r2, r7, r3
 800aaac:	2308      	movs	r3, #8
 800aaae:	18fb      	adds	r3, r7, r3
 800aab0:	8812      	ldrh	r2, [r2, #0]
 800aab2:	881b      	ldrh	r3, [r3, #0]
 800aab4:	429a      	cmp	r2, r3
 800aab6:	d3c5      	bcc.n	800aa44 <pbuf_memcmp+0x78>
    }
  }
  return 0;
 800aab8:	2300      	movs	r3, #0
}
 800aaba:	0018      	movs	r0, r3
 800aabc:	46bd      	mov	sp, r7
 800aabe:	b009      	add	sp, #36	; 0x24
 800aac0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800aac2:	46c0      	nop			; (mov r8, r8)
 800aac4:	0000ffff 	.word	0x0000ffff
 800aac8:	0000fffe 	.word	0x0000fffe

0800aacc <pbuf_memfind>:
 * @param start_offset offset into p at which to start searching
 * @return 0xFFFF if substr was not found in p or the index where it was found
 */
u16_t
pbuf_memfind(const struct pbuf *p, const void *mem, u16_t mem_len, u16_t start_offset)
{
 800aacc:	b5f0      	push	{r4, r5, r6, r7, lr}
 800aace:	b087      	sub	sp, #28
 800aad0:	af00      	add	r7, sp, #0
 800aad2:	60f8      	str	r0, [r7, #12]
 800aad4:	60b9      	str	r1, [r7, #8]
 800aad6:	0019      	movs	r1, r3
 800aad8:	1dbb      	adds	r3, r7, #6
 800aada:	801a      	strh	r2, [r3, #0]
 800aadc:	1d3b      	adds	r3, r7, #4
 800aade:	1c0a      	adds	r2, r1, #0
 800aae0:	801a      	strh	r2, [r3, #0]
  u16_t i;
  u16_t max_cmp_start = (u16_t)(p->tot_len - mem_len);
 800aae2:	68fb      	ldr	r3, [r7, #12]
 800aae4:	8919      	ldrh	r1, [r3, #8]
 800aae6:	2314      	movs	r3, #20
 800aae8:	18fb      	adds	r3, r7, r3
 800aaea:	1dba      	adds	r2, r7, #6
 800aaec:	8812      	ldrh	r2, [r2, #0]
 800aaee:	1a8a      	subs	r2, r1, r2
 800aaf0:	801a      	strh	r2, [r3, #0]
  if (p->tot_len >= mem_len + start_offset) {
 800aaf2:	68fb      	ldr	r3, [r7, #12]
 800aaf4:	891b      	ldrh	r3, [r3, #8]
 800aaf6:	0019      	movs	r1, r3
 800aaf8:	1dbb      	adds	r3, r7, #6
 800aafa:	881a      	ldrh	r2, [r3, #0]
 800aafc:	1d3b      	adds	r3, r7, #4
 800aafe:	881b      	ldrh	r3, [r3, #0]
 800ab00:	18d3      	adds	r3, r2, r3
 800ab02:	4299      	cmp	r1, r3
 800ab04:	db29      	blt.n	800ab5a <pbuf_memfind+0x8e>
    for (i = start_offset; i <= max_cmp_start; i++) {
 800ab06:	2316      	movs	r3, #22
 800ab08:	18fb      	adds	r3, r7, r3
 800ab0a:	1d3a      	adds	r2, r7, #4
 800ab0c:	8812      	ldrh	r2, [r2, #0]
 800ab0e:	801a      	strh	r2, [r3, #0]
 800ab10:	e01b      	b.n	800ab4a <pbuf_memfind+0x7e>
      u16_t plus = pbuf_memcmp(p, i, mem, mem_len);
 800ab12:	2612      	movs	r6, #18
 800ab14:	19bc      	adds	r4, r7, r6
 800ab16:	1dbb      	adds	r3, r7, #6
 800ab18:	881d      	ldrh	r5, [r3, #0]
 800ab1a:	68ba      	ldr	r2, [r7, #8]
 800ab1c:	2316      	movs	r3, #22
 800ab1e:	18fb      	adds	r3, r7, r3
 800ab20:	8819      	ldrh	r1, [r3, #0]
 800ab22:	68f8      	ldr	r0, [r7, #12]
 800ab24:	002b      	movs	r3, r5
 800ab26:	f7ff ff51 	bl	800a9cc <pbuf_memcmp>
 800ab2a:	0003      	movs	r3, r0
 800ab2c:	8023      	strh	r3, [r4, #0]
      if (plus == 0) {
 800ab2e:	19bb      	adds	r3, r7, r6
 800ab30:	881b      	ldrh	r3, [r3, #0]
 800ab32:	2b00      	cmp	r3, #0
 800ab34:	d103      	bne.n	800ab3e <pbuf_memfind+0x72>
        return i;
 800ab36:	2316      	movs	r3, #22
 800ab38:	18fb      	adds	r3, r7, r3
 800ab3a:	881b      	ldrh	r3, [r3, #0]
 800ab3c:	e00e      	b.n	800ab5c <pbuf_memfind+0x90>
    for (i = start_offset; i <= max_cmp_start; i++) {
 800ab3e:	2116      	movs	r1, #22
 800ab40:	187b      	adds	r3, r7, r1
 800ab42:	881a      	ldrh	r2, [r3, #0]
 800ab44:	187b      	adds	r3, r7, r1
 800ab46:	3201      	adds	r2, #1
 800ab48:	801a      	strh	r2, [r3, #0]
 800ab4a:	2316      	movs	r3, #22
 800ab4c:	18fa      	adds	r2, r7, r3
 800ab4e:	2314      	movs	r3, #20
 800ab50:	18fb      	adds	r3, r7, r3
 800ab52:	8812      	ldrh	r2, [r2, #0]
 800ab54:	881b      	ldrh	r3, [r3, #0]
 800ab56:	429a      	cmp	r2, r3
 800ab58:	d9db      	bls.n	800ab12 <pbuf_memfind+0x46>
      }
    }
  }
  return 0xFFFF;
 800ab5a:	4b02      	ldr	r3, [pc, #8]	; (800ab64 <pbuf_memfind+0x98>)
}
 800ab5c:	0018      	movs	r0, r3
 800ab5e:	46bd      	mov	sp, r7
 800ab60:	b007      	add	sp, #28
 800ab62:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800ab64:	0000ffff 	.word	0x0000ffff

0800ab68 <tcp_free>:
}

/** Free a tcp pcb */
void
tcp_free(struct tcp_pcb *pcb)
{
 800ab68:	b580      	push	{r7, lr}
 800ab6a:	b082      	sub	sp, #8
 800ab6c:	af00      	add	r7, sp, #0
 800ab6e:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_free: LISTEN", pcb->state != LISTEN);
 800ab70:	687b      	ldr	r3, [r7, #4]
 800ab72:	7e1b      	ldrb	r3, [r3, #24]
 800ab74:	2b01      	cmp	r3, #1
 800ab76:	d105      	bne.n	800ab84 <tcp_free+0x1c>
 800ab78:	4b07      	ldr	r3, [pc, #28]	; (800ab98 <tcp_free+0x30>)
 800ab7a:	4908      	ldr	r1, [pc, #32]	; (800ab9c <tcp_free+0x34>)
 800ab7c:	4808      	ldr	r0, [pc, #32]	; (800aba0 <tcp_free+0x38>)
 800ab7e:	22d4      	movs	r2, #212	; 0xd4
 800ab80:	f7f8 f822 	bl	8002bc8 <app_debug_rtt_raw>
#if LWIP_TCP_PCB_NUM_EXT_ARGS
  tcp_ext_arg_invoke_callbacks_destroyed(pcb->ext_args);
#endif
  memp_free(MEMP_TCP_PCB, pcb);
 800ab84:	687b      	ldr	r3, [r7, #4]
 800ab86:	0019      	movs	r1, r3
 800ab88:	2001      	movs	r0, #1
 800ab8a:	f7fe faa7 	bl	80090dc <memp_free>
}
 800ab8e:	46c0      	nop			; (mov r8, r8)
 800ab90:	46bd      	mov	sp, r7
 800ab92:	b002      	add	sp, #8
 800ab94:	bd80      	pop	{r7, pc}
 800ab96:	46c0      	nop			; (mov r8, r8)
 800ab98:	0801fe58 	.word	0x0801fe58
 800ab9c:	0801fe80 	.word	0x0801fe80
 800aba0:	0801fe94 	.word	0x0801fe94

0800aba4 <tcp_free_listen>:

/** Free a tcp listen pcb */
static void
tcp_free_listen(struct tcp_pcb *pcb)
{
 800aba4:	b580      	push	{r7, lr}
 800aba6:	b082      	sub	sp, #8
 800aba8:	af00      	add	r7, sp, #0
 800abaa:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_free_listen: !LISTEN", pcb->state != LISTEN);
 800abac:	687b      	ldr	r3, [r7, #4]
 800abae:	7e1b      	ldrb	r3, [r3, #24]
 800abb0:	2b01      	cmp	r3, #1
 800abb2:	d105      	bne.n	800abc0 <tcp_free_listen+0x1c>
 800abb4:	4b07      	ldr	r3, [pc, #28]	; (800abd4 <tcp_free_listen+0x30>)
 800abb6:	4908      	ldr	r1, [pc, #32]	; (800abd8 <tcp_free_listen+0x34>)
 800abb8:	4808      	ldr	r0, [pc, #32]	; (800abdc <tcp_free_listen+0x38>)
 800abba:	22df      	movs	r2, #223	; 0xdf
 800abbc:	f7f8 f804 	bl	8002bc8 <app_debug_rtt_raw>
#if LWIP_TCP_PCB_NUM_EXT_ARGS
  tcp_ext_arg_invoke_callbacks_destroyed(pcb->ext_args);
#endif
  memp_free(MEMP_TCP_PCB_LISTEN, pcb);
 800abc0:	687b      	ldr	r3, [r7, #4]
 800abc2:	0019      	movs	r1, r3
 800abc4:	2002      	movs	r0, #2
 800abc6:	f7fe fa89 	bl	80090dc <memp_free>
}
 800abca:	46c0      	nop			; (mov r8, r8)
 800abcc:	46bd      	mov	sp, r7
 800abce:	b002      	add	sp, #8
 800abd0:	bd80      	pop	{r7, pc}
 800abd2:	46c0      	nop			; (mov r8, r8)
 800abd4:	0801fe58 	.word	0x0801fe58
 800abd8:	0801fec0 	.word	0x0801fec0
 800abdc:	0801fe94 	.word	0x0801fe94

0800abe0 <tcp_tmr>:
/**
 * Called periodically to dispatch TCP timers.
 */
void
tcp_tmr(void)
{
 800abe0:	b580      	push	{r7, lr}
 800abe2:	af00      	add	r7, sp, #0
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
 800abe4:	f001 f8d0 	bl	800bd88 <tcp_fasttmr>

  if (++tcp_timer & 1) {
 800abe8:	4b08      	ldr	r3, [pc, #32]	; (800ac0c <tcp_tmr+0x2c>)
 800abea:	781b      	ldrb	r3, [r3, #0]
 800abec:	3301      	adds	r3, #1
 800abee:	b2da      	uxtb	r2, r3
 800abf0:	4b06      	ldr	r3, [pc, #24]	; (800ac0c <tcp_tmr+0x2c>)
 800abf2:	701a      	strb	r2, [r3, #0]
 800abf4:	4b05      	ldr	r3, [pc, #20]	; (800ac0c <tcp_tmr+0x2c>)
 800abf6:	781b      	ldrb	r3, [r3, #0]
 800abf8:	001a      	movs	r2, r3
 800abfa:	2301      	movs	r3, #1
 800abfc:	4013      	ands	r3, r2
 800abfe:	d001      	beq.n	800ac04 <tcp_tmr+0x24>
    /* Call tcp_slowtmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
 800ac00:	f000 fd36 	bl	800b670 <tcp_slowtmr>
  }
}
 800ac04:	46c0      	nop			; (mov r8, r8)
 800ac06:	46bd      	mov	sp, r7
 800ac08:	bd80      	pop	{r7, pc}
 800ac0a:	46c0      	nop			; (mov r8, r8)
 800ac0c:	20001791 	.word	0x20001791

0800ac10 <tcp_remove_listener>:
/** Called when a listen pcb is closed. Iterates one pcb list and removes the
 * closed listener pcb from pcb->listener if matching.
 */
static void
tcp_remove_listener(struct tcp_pcb *list, struct tcp_pcb_listen *lpcb)
{
 800ac10:	b580      	push	{r7, lr}
 800ac12:	b084      	sub	sp, #16
 800ac14:	af00      	add	r7, sp, #0
 800ac16:	6078      	str	r0, [r7, #4]
 800ac18:	6039      	str	r1, [r7, #0]
  struct tcp_pcb *pcb;

  LWIP_ASSERT("tcp_remove_listener: invalid listener", lpcb != NULL);
 800ac1a:	683b      	ldr	r3, [r7, #0]
 800ac1c:	2b00      	cmp	r3, #0
 800ac1e:	d105      	bne.n	800ac2c <tcp_remove_listener+0x1c>
 800ac20:	4b0e      	ldr	r3, [pc, #56]	; (800ac5c <tcp_remove_listener+0x4c>)
 800ac22:	490f      	ldr	r1, [pc, #60]	; (800ac60 <tcp_remove_listener+0x50>)
 800ac24:	480f      	ldr	r0, [pc, #60]	; (800ac64 <tcp_remove_listener+0x54>)
 800ac26:	22ff      	movs	r2, #255	; 0xff
 800ac28:	f7f7 ffce 	bl	8002bc8 <app_debug_rtt_raw>

  for (pcb = list; pcb != NULL; pcb = pcb->next) {
 800ac2c:	687b      	ldr	r3, [r7, #4]
 800ac2e:	60fb      	str	r3, [r7, #12]
 800ac30:	e00c      	b.n	800ac4c <tcp_remove_listener+0x3c>
    if (pcb->listener == lpcb) {
 800ac32:	68fb      	ldr	r3, [r7, #12]
 800ac34:	2280      	movs	r2, #128	; 0x80
 800ac36:	589b      	ldr	r3, [r3, r2]
 800ac38:	683a      	ldr	r2, [r7, #0]
 800ac3a:	429a      	cmp	r2, r3
 800ac3c:	d103      	bne.n	800ac46 <tcp_remove_listener+0x36>
      pcb->listener = NULL;
 800ac3e:	68fb      	ldr	r3, [r7, #12]
 800ac40:	2280      	movs	r2, #128	; 0x80
 800ac42:	2100      	movs	r1, #0
 800ac44:	5099      	str	r1, [r3, r2]
  for (pcb = list; pcb != NULL; pcb = pcb->next) {
 800ac46:	68fb      	ldr	r3, [r7, #12]
 800ac48:	691b      	ldr	r3, [r3, #16]
 800ac4a:	60fb      	str	r3, [r7, #12]
 800ac4c:	68fb      	ldr	r3, [r7, #12]
 800ac4e:	2b00      	cmp	r3, #0
 800ac50:	d1ef      	bne.n	800ac32 <tcp_remove_listener+0x22>
    }
  }
}
 800ac52:	46c0      	nop			; (mov r8, r8)
 800ac54:	46c0      	nop			; (mov r8, r8)
 800ac56:	46bd      	mov	sp, r7
 800ac58:	b004      	add	sp, #16
 800ac5a:	bd80      	pop	{r7, pc}
 800ac5c:	0801fe58 	.word	0x0801fe58
 800ac60:	0801fedc 	.word	0x0801fedc
 800ac64:	0801fe94 	.word	0x0801fe94

0800ac68 <tcp_listen_closed>:
/** Called when a listen pcb is closed. Iterates all pcb lists and removes the
 * closed listener pcb from pcb->listener if matching.
 */
static void
tcp_listen_closed(struct tcp_pcb *pcb)
{
 800ac68:	b580      	push	{r7, lr}
 800ac6a:	b084      	sub	sp, #16
 800ac6c:	af00      	add	r7, sp, #0
 800ac6e:	6078      	str	r0, [r7, #4]
#if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
  size_t i;
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
 800ac70:	687b      	ldr	r3, [r7, #4]
 800ac72:	2b00      	cmp	r3, #0
 800ac74:	d106      	bne.n	800ac84 <tcp_listen_closed+0x1c>
 800ac76:	4b15      	ldr	r3, [pc, #84]	; (800accc <tcp_listen_closed+0x64>)
 800ac78:	2212      	movs	r2, #18
 800ac7a:	32ff      	adds	r2, #255	; 0xff
 800ac7c:	4914      	ldr	r1, [pc, #80]	; (800acd0 <tcp_listen_closed+0x68>)
 800ac7e:	4815      	ldr	r0, [pc, #84]	; (800acd4 <tcp_listen_closed+0x6c>)
 800ac80:	f7f7 ffa2 	bl	8002bc8 <app_debug_rtt_raw>
  LWIP_ASSERT("pcb->state == LISTEN", pcb->state == LISTEN);
 800ac84:	687b      	ldr	r3, [r7, #4]
 800ac86:	7e1b      	ldrb	r3, [r3, #24]
 800ac88:	2b01      	cmp	r3, #1
 800ac8a:	d006      	beq.n	800ac9a <tcp_listen_closed+0x32>
 800ac8c:	4b0f      	ldr	r3, [pc, #60]	; (800accc <tcp_listen_closed+0x64>)
 800ac8e:	2289      	movs	r2, #137	; 0x89
 800ac90:	0052      	lsls	r2, r2, #1
 800ac92:	4911      	ldr	r1, [pc, #68]	; (800acd8 <tcp_listen_closed+0x70>)
 800ac94:	480f      	ldr	r0, [pc, #60]	; (800acd4 <tcp_listen_closed+0x6c>)
 800ac96:	f7f7 ff97 	bl	8002bc8 <app_debug_rtt_raw>
  for (i = 1; i < LWIP_ARRAYSIZE(tcp_pcb_lists); i++) {
 800ac9a:	2301      	movs	r3, #1
 800ac9c:	60fb      	str	r3, [r7, #12]
 800ac9e:	e00c      	b.n	800acba <tcp_listen_closed+0x52>
    tcp_remove_listener(*tcp_pcb_lists[i], (struct tcp_pcb_listen *)pcb);
 800aca0:	4b0e      	ldr	r3, [pc, #56]	; (800acdc <tcp_listen_closed+0x74>)
 800aca2:	68fa      	ldr	r2, [r7, #12]
 800aca4:	0092      	lsls	r2, r2, #2
 800aca6:	58d3      	ldr	r3, [r2, r3]
 800aca8:	681b      	ldr	r3, [r3, #0]
 800acaa:	687a      	ldr	r2, [r7, #4]
 800acac:	0011      	movs	r1, r2
 800acae:	0018      	movs	r0, r3
 800acb0:	f7ff ffae 	bl	800ac10 <tcp_remove_listener>
  for (i = 1; i < LWIP_ARRAYSIZE(tcp_pcb_lists); i++) {
 800acb4:	68fb      	ldr	r3, [r7, #12]
 800acb6:	3301      	adds	r3, #1
 800acb8:	60fb      	str	r3, [r7, #12]
 800acba:	68fb      	ldr	r3, [r7, #12]
 800acbc:	2b03      	cmp	r3, #3
 800acbe:	d9ef      	bls.n	800aca0 <tcp_listen_closed+0x38>
  }
#endif
  LWIP_UNUSED_ARG(pcb);
}
 800acc0:	46c0      	nop			; (mov r8, r8)
 800acc2:	46c0      	nop			; (mov r8, r8)
 800acc4:	46bd      	mov	sp, r7
 800acc6:	b004      	add	sp, #16
 800acc8:	bd80      	pop	{r7, pc}
 800acca:	46c0      	nop			; (mov r8, r8)
 800accc:	0801fe58 	.word	0x0801fe58
 800acd0:	0801ff04 	.word	0x0801ff04
 800acd4:	0801fe94 	.word	0x0801fe94
 800acd8:	0801ff10 	.word	0x0801ff10
 800acdc:	08022850 	.word	0x08022850

0800ace0 <tcp_close_shutdown>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
static err_t
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
 800ace0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ace2:	b089      	sub	sp, #36	; 0x24
 800ace4:	af04      	add	r7, sp, #16
 800ace6:	6078      	str	r0, [r7, #4]
 800ace8:	000a      	movs	r2, r1
 800acea:	1cfb      	adds	r3, r7, #3
 800acec:	701a      	strb	r2, [r3, #0]
  LWIP_ASSERT("tcp_close_shutdown: invalid pcb", pcb != NULL);
 800acee:	687b      	ldr	r3, [r7, #4]
 800acf0:	2b00      	cmp	r3, #0
 800acf2:	d106      	bne.n	800ad02 <tcp_close_shutdown+0x22>
 800acf4:	4b69      	ldr	r3, [pc, #420]	; (800ae9c <tcp_close_shutdown+0x1bc>)
 800acf6:	22af      	movs	r2, #175	; 0xaf
 800acf8:	0052      	lsls	r2, r2, #1
 800acfa:	4969      	ldr	r1, [pc, #420]	; (800aea0 <tcp_close_shutdown+0x1c0>)
 800acfc:	4869      	ldr	r0, [pc, #420]	; (800aea4 <tcp_close_shutdown+0x1c4>)
 800acfe:	f7f7 ff63 	bl	8002bc8 <app_debug_rtt_raw>

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
 800ad02:	1cfb      	adds	r3, r7, #3
 800ad04:	781b      	ldrb	r3, [r3, #0]
 800ad06:	2b00      	cmp	r3, #0
 800ad08:	d100      	bne.n	800ad0c <tcp_close_shutdown+0x2c>
 800ad0a:	e069      	b.n	800ade0 <tcp_close_shutdown+0x100>
 800ad0c:	687b      	ldr	r3, [r7, #4]
 800ad0e:	7e1b      	ldrb	r3, [r3, #24]
 800ad10:	2b04      	cmp	r3, #4
 800ad12:	d003      	beq.n	800ad1c <tcp_close_shutdown+0x3c>
 800ad14:	687b      	ldr	r3, [r7, #4]
 800ad16:	7e1b      	ldrb	r3, [r3, #24]
 800ad18:	2b07      	cmp	r3, #7
 800ad1a:	d161      	bne.n	800ade0 <tcp_close_shutdown+0x100>
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND_MAX(pcb))) {
 800ad1c:	687b      	ldr	r3, [r7, #4]
 800ad1e:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800ad20:	2b00      	cmp	r3, #0
 800ad22:	d105      	bne.n	800ad30 <tcp_close_shutdown+0x50>
 800ad24:	687b      	ldr	r3, [r7, #4]
 800ad26:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800ad28:	2386      	movs	r3, #134	; 0x86
 800ad2a:	00db      	lsls	r3, r3, #3
 800ad2c:	429a      	cmp	r2, r3
 800ad2e:	d057      	beq.n	800ade0 <tcp_close_shutdown+0x100>
      /* Not all data received by application, send RST to tell the remote
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
 800ad30:	687b      	ldr	r3, [r7, #4]
 800ad32:	8bdb      	ldrh	r3, [r3, #30]
 800ad34:	001a      	movs	r2, r3
 800ad36:	2310      	movs	r3, #16
 800ad38:	4013      	ands	r3, r2
 800ad3a:	d106      	bne.n	800ad4a <tcp_close_shutdown+0x6a>
 800ad3c:	4b57      	ldr	r3, [pc, #348]	; (800ae9c <tcp_close_shutdown+0x1bc>)
 800ad3e:	22b2      	movs	r2, #178	; 0xb2
 800ad40:	0052      	lsls	r2, r2, #1
 800ad42:	4959      	ldr	r1, [pc, #356]	; (800aea8 <tcp_close_shutdown+0x1c8>)
 800ad44:	4857      	ldr	r0, [pc, #348]	; (800aea4 <tcp_close_shutdown+0x1c4>)
 800ad46:	f7f7 ff3f 	bl	8002bc8 <app_debug_rtt_raw>

      /* don't call tcp_abort here: we must not deallocate the pcb since
         that might not be expected when calling tcp_close */
      tcp_rst(pcb, pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 800ad4a:	687b      	ldr	r3, [r7, #4]
 800ad4c:	6d5c      	ldr	r4, [r3, #84]	; 0x54
 800ad4e:	687b      	ldr	r3, [r7, #4]
 800ad50:	6a9d      	ldr	r5, [r3, #40]	; 0x28
 800ad52:	687e      	ldr	r6, [r7, #4]
 800ad54:	687b      	ldr	r3, [r7, #4]
 800ad56:	3304      	adds	r3, #4
 800ad58:	687a      	ldr	r2, [r7, #4]
 800ad5a:	8b52      	ldrh	r2, [r2, #26]
 800ad5c:	6879      	ldr	r1, [r7, #4]
 800ad5e:	8b89      	ldrh	r1, [r1, #28]
 800ad60:	6878      	ldr	r0, [r7, #4]
 800ad62:	9102      	str	r1, [sp, #8]
 800ad64:	9201      	str	r2, [sp, #4]
 800ad66:	9300      	str	r3, [sp, #0]
 800ad68:	0033      	movs	r3, r6
 800ad6a:	002a      	movs	r2, r5
 800ad6c:	0021      	movs	r1, r4
 800ad6e:	f007 f859 	bl	8011e24 <tcp_rst>
              pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
 800ad72:	687b      	ldr	r3, [r7, #4]
 800ad74:	0018      	movs	r0, r3
 800ad76:	f001 fbd5 	bl	800c524 <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 800ad7a:	4b4c      	ldr	r3, [pc, #304]	; (800aeac <tcp_close_shutdown+0x1cc>)
 800ad7c:	681b      	ldr	r3, [r3, #0]
 800ad7e:	687a      	ldr	r2, [r7, #4]
 800ad80:	429a      	cmp	r2, r3
 800ad82:	d105      	bne.n	800ad90 <tcp_close_shutdown+0xb0>
 800ad84:	4b49      	ldr	r3, [pc, #292]	; (800aeac <tcp_close_shutdown+0x1cc>)
 800ad86:	681b      	ldr	r3, [r3, #0]
 800ad88:	691a      	ldr	r2, [r3, #16]
 800ad8a:	4b48      	ldr	r3, [pc, #288]	; (800aeac <tcp_close_shutdown+0x1cc>)
 800ad8c:	601a      	str	r2, [r3, #0]
 800ad8e:	e013      	b.n	800adb8 <tcp_close_shutdown+0xd8>
 800ad90:	4b46      	ldr	r3, [pc, #280]	; (800aeac <tcp_close_shutdown+0x1cc>)
 800ad92:	681b      	ldr	r3, [r3, #0]
 800ad94:	60fb      	str	r3, [r7, #12]
 800ad96:	e00c      	b.n	800adb2 <tcp_close_shutdown+0xd2>
 800ad98:	68fb      	ldr	r3, [r7, #12]
 800ad9a:	691b      	ldr	r3, [r3, #16]
 800ad9c:	687a      	ldr	r2, [r7, #4]
 800ad9e:	429a      	cmp	r2, r3
 800ada0:	d104      	bne.n	800adac <tcp_close_shutdown+0xcc>
 800ada2:	687b      	ldr	r3, [r7, #4]
 800ada4:	691a      	ldr	r2, [r3, #16]
 800ada6:	68fb      	ldr	r3, [r7, #12]
 800ada8:	611a      	str	r2, [r3, #16]
 800adaa:	e005      	b.n	800adb8 <tcp_close_shutdown+0xd8>
 800adac:	68fb      	ldr	r3, [r7, #12]
 800adae:	691b      	ldr	r3, [r3, #16]
 800adb0:	60fb      	str	r3, [r7, #12]
 800adb2:	68fb      	ldr	r3, [r7, #12]
 800adb4:	2b00      	cmp	r3, #0
 800adb6:	d1ef      	bne.n	800ad98 <tcp_close_shutdown+0xb8>
 800adb8:	687b      	ldr	r3, [r7, #4]
 800adba:	2200      	movs	r2, #0
 800adbc:	611a      	str	r2, [r3, #16]
 800adbe:	4b3c      	ldr	r3, [pc, #240]	; (800aeb0 <tcp_close_shutdown+0x1d0>)
 800adc0:	2201      	movs	r2, #1
 800adc2:	701a      	strb	r2, [r3, #0]
      /* Deallocate the pcb since we already sent a RST for it */
      if (tcp_input_pcb == pcb) {
 800adc4:	4b3b      	ldr	r3, [pc, #236]	; (800aeb4 <tcp_close_shutdown+0x1d4>)
 800adc6:	681b      	ldr	r3, [r3, #0]
 800adc8:	687a      	ldr	r2, [r7, #4]
 800adca:	429a      	cmp	r2, r3
 800adcc:	d102      	bne.n	800add4 <tcp_close_shutdown+0xf4>
        /* prevent using a deallocated pcb: free it from tcp_input later */
        tcp_trigger_input_pcb_close();
 800adce:	f004 fc25 	bl	800f61c <tcp_trigger_input_pcb_close>
 800add2:	e003      	b.n	800addc <tcp_close_shutdown+0xfc>
      } else {
        tcp_free(pcb);
 800add4:	687b      	ldr	r3, [r7, #4]
 800add6:	0018      	movs	r0, r3
 800add8:	f7ff fec6 	bl	800ab68 <tcp_free>
      }
      return ERR_OK;
 800addc:	2300      	movs	r3, #0
 800adde:	e058      	b.n	800ae92 <tcp_close_shutdown+0x1b2>
    }
  }

  /* - states which free the pcb are handled here,
     - states which send FIN and change state are handled in tcp_close_shutdown_fin() */
  switch (pcb->state) {
 800ade0:	687b      	ldr	r3, [r7, #4]
 800ade2:	7e1b      	ldrb	r3, [r3, #24]
 800ade4:	2b02      	cmp	r3, #2
 800ade6:	d03f      	beq.n	800ae68 <tcp_close_shutdown+0x188>
 800ade8:	dc4c      	bgt.n	800ae84 <tcp_close_shutdown+0x1a4>
 800adea:	2b00      	cmp	r3, #0
 800adec:	d002      	beq.n	800adf4 <tcp_close_shutdown+0x114>
 800adee:	2b01      	cmp	r3, #1
 800adf0:	d02b      	beq.n	800ae4a <tcp_close_shutdown+0x16a>
 800adf2:	e047      	b.n	800ae84 <tcp_close_shutdown+0x1a4>
       * and the user needs some way to free it should the need arise.
       * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
       * or for a pcb that has been used and then entered the CLOSED state
       * is erroneous, but this should never happen as the pcb has in those cases
       * been freed, and so any remaining handles are bogus. */
      if (pcb->local_port != 0) {
 800adf4:	687b      	ldr	r3, [r7, #4]
 800adf6:	8b5b      	ldrh	r3, [r3, #26]
 800adf8:	2b00      	cmp	r3, #0
 800adfa:	d021      	beq.n	800ae40 <tcp_close_shutdown+0x160>
        TCP_RMV(&tcp_bound_pcbs, pcb);
 800adfc:	4b2e      	ldr	r3, [pc, #184]	; (800aeb8 <tcp_close_shutdown+0x1d8>)
 800adfe:	681b      	ldr	r3, [r3, #0]
 800ae00:	687a      	ldr	r2, [r7, #4]
 800ae02:	429a      	cmp	r2, r3
 800ae04:	d105      	bne.n	800ae12 <tcp_close_shutdown+0x132>
 800ae06:	4b2c      	ldr	r3, [pc, #176]	; (800aeb8 <tcp_close_shutdown+0x1d8>)
 800ae08:	681b      	ldr	r3, [r3, #0]
 800ae0a:	691a      	ldr	r2, [r3, #16]
 800ae0c:	4b2a      	ldr	r3, [pc, #168]	; (800aeb8 <tcp_close_shutdown+0x1d8>)
 800ae0e:	601a      	str	r2, [r3, #0]
 800ae10:	e013      	b.n	800ae3a <tcp_close_shutdown+0x15a>
 800ae12:	4b29      	ldr	r3, [pc, #164]	; (800aeb8 <tcp_close_shutdown+0x1d8>)
 800ae14:	681b      	ldr	r3, [r3, #0]
 800ae16:	60bb      	str	r3, [r7, #8]
 800ae18:	e00c      	b.n	800ae34 <tcp_close_shutdown+0x154>
 800ae1a:	68bb      	ldr	r3, [r7, #8]
 800ae1c:	691b      	ldr	r3, [r3, #16]
 800ae1e:	687a      	ldr	r2, [r7, #4]
 800ae20:	429a      	cmp	r2, r3
 800ae22:	d104      	bne.n	800ae2e <tcp_close_shutdown+0x14e>
 800ae24:	687b      	ldr	r3, [r7, #4]
 800ae26:	691a      	ldr	r2, [r3, #16]
 800ae28:	68bb      	ldr	r3, [r7, #8]
 800ae2a:	611a      	str	r2, [r3, #16]
 800ae2c:	e005      	b.n	800ae3a <tcp_close_shutdown+0x15a>
 800ae2e:	68bb      	ldr	r3, [r7, #8]
 800ae30:	691b      	ldr	r3, [r3, #16]
 800ae32:	60bb      	str	r3, [r7, #8]
 800ae34:	68bb      	ldr	r3, [r7, #8]
 800ae36:	2b00      	cmp	r3, #0
 800ae38:	d1ef      	bne.n	800ae1a <tcp_close_shutdown+0x13a>
 800ae3a:	687b      	ldr	r3, [r7, #4]
 800ae3c:	2200      	movs	r2, #0
 800ae3e:	611a      	str	r2, [r3, #16]
      }
      tcp_free(pcb);
 800ae40:	687b      	ldr	r3, [r7, #4]
 800ae42:	0018      	movs	r0, r3
 800ae44:	f7ff fe90 	bl	800ab68 <tcp_free>
      break;
 800ae48:	e022      	b.n	800ae90 <tcp_close_shutdown+0x1b0>
    case LISTEN:
      tcp_listen_closed(pcb);
 800ae4a:	687b      	ldr	r3, [r7, #4]
 800ae4c:	0018      	movs	r0, r3
 800ae4e:	f7ff ff0b 	bl	800ac68 <tcp_listen_closed>
      tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
 800ae52:	687a      	ldr	r2, [r7, #4]
 800ae54:	4b19      	ldr	r3, [pc, #100]	; (800aebc <tcp_close_shutdown+0x1dc>)
 800ae56:	0011      	movs	r1, r2
 800ae58:	0018      	movs	r0, r3
 800ae5a:	f001 fbad 	bl	800c5b8 <tcp_pcb_remove>
      tcp_free_listen(pcb);
 800ae5e:	687b      	ldr	r3, [r7, #4]
 800ae60:	0018      	movs	r0, r3
 800ae62:	f7ff fe9f 	bl	800aba4 <tcp_free_listen>
      break;
 800ae66:	e013      	b.n	800ae90 <tcp_close_shutdown+0x1b0>
    case SYN_SENT:
      TCP_PCB_REMOVE_ACTIVE(pcb);
 800ae68:	687a      	ldr	r2, [r7, #4]
 800ae6a:	4b10      	ldr	r3, [pc, #64]	; (800aeac <tcp_close_shutdown+0x1cc>)
 800ae6c:	0011      	movs	r1, r2
 800ae6e:	0018      	movs	r0, r3
 800ae70:	f001 fba2 	bl	800c5b8 <tcp_pcb_remove>
 800ae74:	4b0e      	ldr	r3, [pc, #56]	; (800aeb0 <tcp_close_shutdown+0x1d0>)
 800ae76:	2201      	movs	r2, #1
 800ae78:	701a      	strb	r2, [r3, #0]
      tcp_free(pcb);
 800ae7a:	687b      	ldr	r3, [r7, #4]
 800ae7c:	0018      	movs	r0, r3
 800ae7e:	f7ff fe73 	bl	800ab68 <tcp_free>
      MIB2_STATS_INC(mib2.tcpattemptfails);
      break;
 800ae82:	e005      	b.n	800ae90 <tcp_close_shutdown+0x1b0>
    default:
      return tcp_close_shutdown_fin(pcb);
 800ae84:	687b      	ldr	r3, [r7, #4]
 800ae86:	0018      	movs	r0, r3
 800ae88:	f000 f81a 	bl	800aec0 <tcp_close_shutdown_fin>
 800ae8c:	0003      	movs	r3, r0
 800ae8e:	e000      	b.n	800ae92 <tcp_close_shutdown+0x1b2>
  }
  return ERR_OK;
 800ae90:	2300      	movs	r3, #0
}
 800ae92:	0018      	movs	r0, r3
 800ae94:	46bd      	mov	sp, r7
 800ae96:	b005      	add	sp, #20
 800ae98:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800ae9a:	46c0      	nop			; (mov r8, r8)
 800ae9c:	0801fe58 	.word	0x0801fe58
 800aea0:	0801ff28 	.word	0x0801ff28
 800aea4:	0801fe94 	.word	0x0801fe94
 800aea8:	0801ff48 	.word	0x0801ff48
 800aeac:	20002b3c 	.word	0x20002b3c
 800aeb0:	20002b38 	.word	0x20002b38
 800aeb4:	20002b50 	.word	0x20002b50
 800aeb8:	20002b48 	.word	0x20002b48
 800aebc:	20002b44 	.word	0x20002b44

0800aec0 <tcp_close_shutdown_fin>:

static err_t
tcp_close_shutdown_fin(struct tcp_pcb *pcb)
{
 800aec0:	b5b0      	push	{r4, r5, r7, lr}
 800aec2:	b084      	sub	sp, #16
 800aec4:	af00      	add	r7, sp, #0
 800aec6:	6078      	str	r0, [r7, #4]
  err_t err;
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
 800aec8:	687b      	ldr	r3, [r7, #4]
 800aeca:	2b00      	cmp	r3, #0
 800aecc:	d106      	bne.n	800aedc <tcp_close_shutdown_fin+0x1c>
 800aece:	4b36      	ldr	r3, [pc, #216]	; (800afa8 <tcp_close_shutdown_fin+0xe8>)
 800aed0:	22ce      	movs	r2, #206	; 0xce
 800aed2:	0052      	lsls	r2, r2, #1
 800aed4:	4935      	ldr	r1, [pc, #212]	; (800afac <tcp_close_shutdown_fin+0xec>)
 800aed6:	4836      	ldr	r0, [pc, #216]	; (800afb0 <tcp_close_shutdown_fin+0xf0>)
 800aed8:	f7f7 fe76 	bl	8002bc8 <app_debug_rtt_raw>

  switch (pcb->state) {
 800aedc:	687b      	ldr	r3, [r7, #4]
 800aede:	7e1b      	ldrb	r3, [r3, #24]
 800aee0:	2b07      	cmp	r3, #7
 800aee2:	d027      	beq.n	800af34 <tcp_close_shutdown_fin+0x74>
 800aee4:	dc37      	bgt.n	800af56 <tcp_close_shutdown_fin+0x96>
 800aee6:	2b03      	cmp	r3, #3
 800aee8:	d002      	beq.n	800aef0 <tcp_close_shutdown_fin+0x30>
 800aeea:	2b04      	cmp	r3, #4
 800aeec:	d011      	beq.n	800af12 <tcp_close_shutdown_fin+0x52>
 800aeee:	e032      	b.n	800af56 <tcp_close_shutdown_fin+0x96>
    case SYN_RCVD:
      err = tcp_send_fin(pcb);
 800aef0:	250f      	movs	r5, #15
 800aef2:	197c      	adds	r4, r7, r5
 800aef4:	687b      	ldr	r3, [r7, #4]
 800aef6:	0018      	movs	r0, r3
 800aef8:	f005 fdd0 	bl	8010a9c <tcp_send_fin>
 800aefc:	0003      	movs	r3, r0
 800aefe:	7023      	strb	r3, [r4, #0]
      if (err == ERR_OK) {
 800af00:	197b      	adds	r3, r7, r5
 800af02:	781b      	ldrb	r3, [r3, #0]
 800af04:	b25b      	sxtb	r3, r3
 800af06:	2b00      	cmp	r3, #0
 800af08:	d127      	bne.n	800af5a <tcp_close_shutdown_fin+0x9a>
        tcp_backlog_accepted(pcb);
        MIB2_STATS_INC(mib2.tcpattemptfails);
        pcb->state = FIN_WAIT_1;
 800af0a:	687b      	ldr	r3, [r7, #4]
 800af0c:	2205      	movs	r2, #5
 800af0e:	761a      	strb	r2, [r3, #24]
      }
      break;
 800af10:	e023      	b.n	800af5a <tcp_close_shutdown_fin+0x9a>
    case ESTABLISHED:
      err = tcp_send_fin(pcb);
 800af12:	250f      	movs	r5, #15
 800af14:	197c      	adds	r4, r7, r5
 800af16:	687b      	ldr	r3, [r7, #4]
 800af18:	0018      	movs	r0, r3
 800af1a:	f005 fdbf 	bl	8010a9c <tcp_send_fin>
 800af1e:	0003      	movs	r3, r0
 800af20:	7023      	strb	r3, [r4, #0]
      if (err == ERR_OK) {
 800af22:	197b      	adds	r3, r7, r5
 800af24:	781b      	ldrb	r3, [r3, #0]
 800af26:	b25b      	sxtb	r3, r3
 800af28:	2b00      	cmp	r3, #0
 800af2a:	d118      	bne.n	800af5e <tcp_close_shutdown_fin+0x9e>
        MIB2_STATS_INC(mib2.tcpestabresets);
        pcb->state = FIN_WAIT_1;
 800af2c:	687b      	ldr	r3, [r7, #4]
 800af2e:	2205      	movs	r2, #5
 800af30:	761a      	strb	r2, [r3, #24]
      }
      break;
 800af32:	e014      	b.n	800af5e <tcp_close_shutdown_fin+0x9e>
    case CLOSE_WAIT:
      err = tcp_send_fin(pcb);
 800af34:	250f      	movs	r5, #15
 800af36:	197c      	adds	r4, r7, r5
 800af38:	687b      	ldr	r3, [r7, #4]
 800af3a:	0018      	movs	r0, r3
 800af3c:	f005 fdae 	bl	8010a9c <tcp_send_fin>
 800af40:	0003      	movs	r3, r0
 800af42:	7023      	strb	r3, [r4, #0]
      if (err == ERR_OK) {
 800af44:	197b      	adds	r3, r7, r5
 800af46:	781b      	ldrb	r3, [r3, #0]
 800af48:	b25b      	sxtb	r3, r3
 800af4a:	2b00      	cmp	r3, #0
 800af4c:	d109      	bne.n	800af62 <tcp_close_shutdown_fin+0xa2>
        MIB2_STATS_INC(mib2.tcpestabresets);
        pcb->state = LAST_ACK;
 800af4e:	687b      	ldr	r3, [r7, #4]
 800af50:	2209      	movs	r2, #9
 800af52:	761a      	strb	r2, [r3, #24]
      }
      break;
 800af54:	e005      	b.n	800af62 <tcp_close_shutdown_fin+0xa2>
    default:
      /* Has already been closed, do nothing. */
      return ERR_OK;
 800af56:	2300      	movs	r3, #0
 800af58:	e022      	b.n	800afa0 <tcp_close_shutdown_fin+0xe0>
      break;
 800af5a:	46c0      	nop			; (mov r8, r8)
 800af5c:	e002      	b.n	800af64 <tcp_close_shutdown_fin+0xa4>
      break;
 800af5e:	46c0      	nop			; (mov r8, r8)
 800af60:	e000      	b.n	800af64 <tcp_close_shutdown_fin+0xa4>
      break;
 800af62:	46c0      	nop			; (mov r8, r8)
  }

  if (err == ERR_OK) {
 800af64:	230f      	movs	r3, #15
 800af66:	18fb      	adds	r3, r7, r3
 800af68:	781b      	ldrb	r3, [r3, #0]
 800af6a:	b25b      	sxtb	r3, r3
 800af6c:	2b00      	cmp	r3, #0
 800af6e:	d104      	bne.n	800af7a <tcp_close_shutdown_fin+0xba>
    /* To ensure all data has been sent when tcp_close returns, we have
       to make sure tcp_output doesn't fail.
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    tcp_output(pcb);
 800af70:	687b      	ldr	r3, [r7, #4]
 800af72:	0018      	movs	r0, r3
 800af74:	f005 ff02 	bl	8010d7c <tcp_output>
 800af78:	e00e      	b.n	800af98 <tcp_close_shutdown_fin+0xd8>
  } else if (err == ERR_MEM) {
 800af7a:	230f      	movs	r3, #15
 800af7c:	18fb      	adds	r3, r7, r3
 800af7e:	781b      	ldrb	r3, [r3, #0]
 800af80:	b25b      	sxtb	r3, r3
 800af82:	3301      	adds	r3, #1
 800af84:	d108      	bne.n	800af98 <tcp_close_shutdown_fin+0xd8>
    /* Mark this pcb for closing. Closing is retried from tcp_tmr. */
    tcp_set_flags(pcb, TF_CLOSEPEND);
 800af86:	687b      	ldr	r3, [r7, #4]
 800af88:	8bdb      	ldrh	r3, [r3, #30]
 800af8a:	2208      	movs	r2, #8
 800af8c:	4313      	orrs	r3, r2
 800af8e:	b29a      	uxth	r2, r3
 800af90:	687b      	ldr	r3, [r7, #4]
 800af92:	83da      	strh	r2, [r3, #30]
    /* We have to return ERR_OK from here to indicate to the callers that this
       pcb should not be used any more as it will be freed soon via tcp_tmr.
       This is OK here since sending FIN does not guarantee a time frime for
       actually freeing the pcb, either (it is left in closure states for
       remote ACK or timeout) */
    return ERR_OK;
 800af94:	2300      	movs	r3, #0
 800af96:	e003      	b.n	800afa0 <tcp_close_shutdown_fin+0xe0>
  }
  return err;
 800af98:	230f      	movs	r3, #15
 800af9a:	18fb      	adds	r3, r7, r3
 800af9c:	781b      	ldrb	r3, [r3, #0]
 800af9e:	b25b      	sxtb	r3, r3
}
 800afa0:	0018      	movs	r0, r3
 800afa2:	46bd      	mov	sp, r7
 800afa4:	b004      	add	sp, #16
 800afa6:	bdb0      	pop	{r4, r5, r7, pc}
 800afa8:	0801fe58 	.word	0x0801fe58
 800afac:	0801ff04 	.word	0x0801ff04
 800afb0:	0801fe94 	.word	0x0801fe94

0800afb4 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
 800afb4:	b580      	push	{r7, lr}
 800afb6:	b082      	sub	sp, #8
 800afb8:	af00      	add	r7, sp, #0
 800afba:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_close: invalid pcb", pcb != NULL, return ERR_ARG);
 800afbc:	687b      	ldr	r3, [r7, #4]
 800afbe:	2b00      	cmp	r3, #0
 800afc0:	d106      	bne.n	800afd0 <tcp_close+0x1c>
 800afc2:	4b0e      	ldr	r3, [pc, #56]	; (800affc <tcp_close+0x48>)
 800afc4:	0018      	movs	r0, r3
 800afc6:	f7f7 fdff 	bl	8002bc8 <app_debug_rtt_raw>
 800afca:	2310      	movs	r3, #16
 800afcc:	425b      	negs	r3, r3
 800afce:	e010      	b.n	800aff2 <tcp_close+0x3e>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));

  tcp_debug_print_state(pcb->state);

  if (pcb->state != LISTEN) {
 800afd0:	687b      	ldr	r3, [r7, #4]
 800afd2:	7e1b      	ldrb	r3, [r3, #24]
 800afd4:	2b01      	cmp	r3, #1
 800afd6:	d006      	beq.n	800afe6 <tcp_close+0x32>
    /* Set a flag not to receive any more data... */
    tcp_set_flags(pcb, TF_RXCLOSED);
 800afd8:	687b      	ldr	r3, [r7, #4]
 800afda:	8bdb      	ldrh	r3, [r3, #30]
 800afdc:	2210      	movs	r2, #16
 800afde:	4313      	orrs	r3, r2
 800afe0:	b29a      	uxth	r2, r3
 800afe2:	687b      	ldr	r3, [r7, #4]
 800afe4:	83da      	strh	r2, [r3, #30]
  }
  /* ... and close */
  return tcp_close_shutdown(pcb, 1);
 800afe6:	687b      	ldr	r3, [r7, #4]
 800afe8:	2101      	movs	r1, #1
 800afea:	0018      	movs	r0, r3
 800afec:	f7ff fe78 	bl	800ace0 <tcp_close_shutdown>
 800aff0:	0003      	movs	r3, r0
}
 800aff2:	0018      	movs	r0, r3
 800aff4:	46bd      	mov	sp, r7
 800aff6:	b002      	add	sp, #8
 800aff8:	bd80      	pop	{r7, pc}
 800affa:	46c0      	nop			; (mov r8, r8)
 800affc:	0801ff64 	.word	0x0801ff64

0800b000 <tcp_abandon>:
 * @param pcb the tcp_pcb to abort
 * @param reset boolean to indicate whether a reset should be sent
 */
void
tcp_abandon(struct tcp_pcb *pcb, int reset)
{
 800b000:	b5b0      	push	{r4, r5, r7, lr}
 800b002:	b08e      	sub	sp, #56	; 0x38
 800b004:	af04      	add	r7, sp, #16
 800b006:	6078      	str	r0, [r7, #4]
 800b008:	6039      	str	r1, [r7, #0]
#endif /* LWIP_CALLBACK_API */
  void *errf_arg;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_abandon: invalid pcb", pcb != NULL, return);
 800b00a:	687b      	ldr	r3, [r7, #4]
 800b00c:	2b00      	cmp	r3, #0
 800b00e:	d104      	bne.n	800b01a <tcp_abandon+0x1a>
 800b010:	4b58      	ldr	r3, [pc, #352]	; (800b174 <tcp_abandon+0x174>)
 800b012:	0018      	movs	r0, r3
 800b014:	f7f7 fdd8 	bl	8002bc8 <app_debug_rtt_raw>
 800b018:	e0a9      	b.n	800b16e <tcp_abandon+0x16e>

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
 800b01a:	687b      	ldr	r3, [r7, #4]
 800b01c:	7e1b      	ldrb	r3, [r3, #24]
 800b01e:	2b01      	cmp	r3, #1
 800b020:	d106      	bne.n	800b030 <tcp_abandon+0x30>
 800b022:	4b55      	ldr	r3, [pc, #340]	; (800b178 <tcp_abandon+0x178>)
 800b024:	2290      	movs	r2, #144	; 0x90
 800b026:	0092      	lsls	r2, r2, #2
 800b028:	4954      	ldr	r1, [pc, #336]	; (800b17c <tcp_abandon+0x17c>)
 800b02a:	4855      	ldr	r0, [pc, #340]	; (800b180 <tcp_abandon+0x180>)
 800b02c:	f7f7 fdcc 	bl	8002bc8 <app_debug_rtt_raw>
              pcb->state != LISTEN);
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
 800b030:	687b      	ldr	r3, [r7, #4]
 800b032:	7e1b      	ldrb	r3, [r3, #24]
 800b034:	2b0a      	cmp	r3, #10
 800b036:	d10a      	bne.n	800b04e <tcp_abandon+0x4e>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
 800b038:	687a      	ldr	r2, [r7, #4]
 800b03a:	4b52      	ldr	r3, [pc, #328]	; (800b184 <tcp_abandon+0x184>)
 800b03c:	0011      	movs	r1, r2
 800b03e:	0018      	movs	r0, r3
 800b040:	f001 faba 	bl	800c5b8 <tcp_pcb_remove>
    tcp_free(pcb);
 800b044:	687b      	ldr	r3, [r7, #4]
 800b046:	0018      	movs	r0, r3
 800b048:	f7ff fd8e 	bl	800ab68 <tcp_free>
 800b04c:	e08f      	b.n	800b16e <tcp_abandon+0x16e>
  } else {
    int send_rst = 0;
 800b04e:	2300      	movs	r3, #0
 800b050:	627b      	str	r3, [r7, #36]	; 0x24
    u16_t local_port = 0;
 800b052:	2322      	movs	r3, #34	; 0x22
 800b054:	18fb      	adds	r3, r7, r3
 800b056:	2200      	movs	r2, #0
 800b058:	801a      	strh	r2, [r3, #0]
    enum tcp_state last_state;
    seqno = pcb->snd_nxt;
 800b05a:	687b      	ldr	r3, [r7, #4]
 800b05c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800b05e:	61bb      	str	r3, [r7, #24]
    ackno = pcb->rcv_nxt;
 800b060:	687b      	ldr	r3, [r7, #4]
 800b062:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b064:	617b      	str	r3, [r7, #20]
#if LWIP_CALLBACK_API
    errf = pcb->errf;
 800b066:	687b      	ldr	r3, [r7, #4]
 800b068:	2294      	movs	r2, #148	; 0x94
 800b06a:	589b      	ldr	r3, [r3, r2]
 800b06c:	613b      	str	r3, [r7, #16]
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
 800b06e:	687b      	ldr	r3, [r7, #4]
 800b070:	695b      	ldr	r3, [r3, #20]
 800b072:	60fb      	str	r3, [r7, #12]
    if (pcb->state == CLOSED) {
 800b074:	687b      	ldr	r3, [r7, #4]
 800b076:	7e1b      	ldrb	r3, [r3, #24]
 800b078:	2b00      	cmp	r3, #0
 800b07a:	d126      	bne.n	800b0ca <tcp_abandon+0xca>
      if (pcb->local_port != 0) {
 800b07c:	687b      	ldr	r3, [r7, #4]
 800b07e:	8b5b      	ldrh	r3, [r3, #26]
 800b080:	2b00      	cmp	r3, #0
 800b082:	d032      	beq.n	800b0ea <tcp_abandon+0xea>
        /* bound, not yet opened */
        TCP_RMV(&tcp_bound_pcbs, pcb);
 800b084:	4b40      	ldr	r3, [pc, #256]	; (800b188 <tcp_abandon+0x188>)
 800b086:	681b      	ldr	r3, [r3, #0]
 800b088:	687a      	ldr	r2, [r7, #4]
 800b08a:	429a      	cmp	r2, r3
 800b08c:	d105      	bne.n	800b09a <tcp_abandon+0x9a>
 800b08e:	4b3e      	ldr	r3, [pc, #248]	; (800b188 <tcp_abandon+0x188>)
 800b090:	681b      	ldr	r3, [r3, #0]
 800b092:	691a      	ldr	r2, [r3, #16]
 800b094:	4b3c      	ldr	r3, [pc, #240]	; (800b188 <tcp_abandon+0x188>)
 800b096:	601a      	str	r2, [r3, #0]
 800b098:	e013      	b.n	800b0c2 <tcp_abandon+0xc2>
 800b09a:	4b3b      	ldr	r3, [pc, #236]	; (800b188 <tcp_abandon+0x188>)
 800b09c:	681b      	ldr	r3, [r3, #0]
 800b09e:	61fb      	str	r3, [r7, #28]
 800b0a0:	e00c      	b.n	800b0bc <tcp_abandon+0xbc>
 800b0a2:	69fb      	ldr	r3, [r7, #28]
 800b0a4:	691b      	ldr	r3, [r3, #16]
 800b0a6:	687a      	ldr	r2, [r7, #4]
 800b0a8:	429a      	cmp	r2, r3
 800b0aa:	d104      	bne.n	800b0b6 <tcp_abandon+0xb6>
 800b0ac:	687b      	ldr	r3, [r7, #4]
 800b0ae:	691a      	ldr	r2, [r3, #16]
 800b0b0:	69fb      	ldr	r3, [r7, #28]
 800b0b2:	611a      	str	r2, [r3, #16]
 800b0b4:	e005      	b.n	800b0c2 <tcp_abandon+0xc2>
 800b0b6:	69fb      	ldr	r3, [r7, #28]
 800b0b8:	691b      	ldr	r3, [r3, #16]
 800b0ba:	61fb      	str	r3, [r7, #28]
 800b0bc:	69fb      	ldr	r3, [r7, #28]
 800b0be:	2b00      	cmp	r3, #0
 800b0c0:	d1ef      	bne.n	800b0a2 <tcp_abandon+0xa2>
 800b0c2:	687b      	ldr	r3, [r7, #4]
 800b0c4:	2200      	movs	r2, #0
 800b0c6:	611a      	str	r2, [r3, #16]
 800b0c8:	e00f      	b.n	800b0ea <tcp_abandon+0xea>
      }
    } else {
      send_rst = reset;
 800b0ca:	683b      	ldr	r3, [r7, #0]
 800b0cc:	627b      	str	r3, [r7, #36]	; 0x24
      local_port = pcb->local_port;
 800b0ce:	2322      	movs	r3, #34	; 0x22
 800b0d0:	18fb      	adds	r3, r7, r3
 800b0d2:	687a      	ldr	r2, [r7, #4]
 800b0d4:	8b52      	ldrh	r2, [r2, #26]
 800b0d6:	801a      	strh	r2, [r3, #0]
      TCP_PCB_REMOVE_ACTIVE(pcb);
 800b0d8:	687a      	ldr	r2, [r7, #4]
 800b0da:	4b2c      	ldr	r3, [pc, #176]	; (800b18c <tcp_abandon+0x18c>)
 800b0dc:	0011      	movs	r1, r2
 800b0de:	0018      	movs	r0, r3
 800b0e0:	f001 fa6a 	bl	800c5b8 <tcp_pcb_remove>
 800b0e4:	4b2a      	ldr	r3, [pc, #168]	; (800b190 <tcp_abandon+0x190>)
 800b0e6:	2201      	movs	r2, #1
 800b0e8:	701a      	strb	r2, [r3, #0]
    }
    if (pcb->unacked != NULL) {
 800b0ea:	687b      	ldr	r3, [r7, #4]
 800b0ec:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800b0ee:	2b00      	cmp	r3, #0
 800b0f0:	d004      	beq.n	800b0fc <tcp_abandon+0xfc>
      tcp_segs_free(pcb->unacked);
 800b0f2:	687b      	ldr	r3, [r7, #4]
 800b0f4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800b0f6:	0018      	movs	r0, r3
 800b0f8:	f000 ff36 	bl	800bf68 <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
 800b0fc:	687b      	ldr	r3, [r7, #4]
 800b0fe:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800b100:	2b00      	cmp	r3, #0
 800b102:	d004      	beq.n	800b10e <tcp_abandon+0x10e>
      tcp_segs_free(pcb->unsent);
 800b104:	687b      	ldr	r3, [r7, #4]
 800b106:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800b108:	0018      	movs	r0, r3
 800b10a:	f000 ff2d 	bl	800bf68 <tcp_segs_free>
    }
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
 800b10e:	687b      	ldr	r3, [r7, #4]
 800b110:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800b112:	2b00      	cmp	r3, #0
 800b114:	d004      	beq.n	800b120 <tcp_abandon+0x120>
      tcp_segs_free(pcb->ooseq);
 800b116:	687b      	ldr	r3, [r7, #4]
 800b118:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800b11a:	0018      	movs	r0, r3
 800b11c:	f000 ff24 	bl	800bf68 <tcp_segs_free>
    }
#endif /* TCP_QUEUE_OOSEQ */
    tcp_backlog_accepted(pcb);
    if (send_rst) {
 800b120:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b122:	2b00      	cmp	r3, #0
 800b124:	d011      	beq.n	800b14a <tcp_abandon+0x14a>
      LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
      tcp_rst(pcb, seqno, ackno, &pcb->local_ip, &pcb->remote_ip, local_port, pcb->remote_port);
 800b126:	687d      	ldr	r5, [r7, #4]
 800b128:	687b      	ldr	r3, [r7, #4]
 800b12a:	3304      	adds	r3, #4
 800b12c:	687a      	ldr	r2, [r7, #4]
 800b12e:	8b92      	ldrh	r2, [r2, #28]
 800b130:	697c      	ldr	r4, [r7, #20]
 800b132:	69b9      	ldr	r1, [r7, #24]
 800b134:	6878      	ldr	r0, [r7, #4]
 800b136:	9202      	str	r2, [sp, #8]
 800b138:	2222      	movs	r2, #34	; 0x22
 800b13a:	18ba      	adds	r2, r7, r2
 800b13c:	8812      	ldrh	r2, [r2, #0]
 800b13e:	9201      	str	r2, [sp, #4]
 800b140:	9300      	str	r3, [sp, #0]
 800b142:	002b      	movs	r3, r5
 800b144:	0022      	movs	r2, r4
 800b146:	f006 fe6d 	bl	8011e24 <tcp_rst>
    }
    last_state = pcb->state;
 800b14a:	230b      	movs	r3, #11
 800b14c:	18fb      	adds	r3, r7, r3
 800b14e:	687a      	ldr	r2, [r7, #4]
 800b150:	7e12      	ldrb	r2, [r2, #24]
 800b152:	701a      	strb	r2, [r3, #0]
    tcp_free(pcb);
 800b154:	687b      	ldr	r3, [r7, #4]
 800b156:	0018      	movs	r0, r3
 800b158:	f7ff fd06 	bl	800ab68 <tcp_free>
    TCP_EVENT_ERR(last_state, errf, errf_arg, ERR_ABRT);
 800b15c:	693b      	ldr	r3, [r7, #16]
 800b15e:	2b00      	cmp	r3, #0
 800b160:	d005      	beq.n	800b16e <tcp_abandon+0x16e>
 800b162:	230d      	movs	r3, #13
 800b164:	4259      	negs	r1, r3
 800b166:	68fa      	ldr	r2, [r7, #12]
 800b168:	693b      	ldr	r3, [r7, #16]
 800b16a:	0010      	movs	r0, r2
 800b16c:	4798      	blx	r3
  }
}
 800b16e:	46bd      	mov	sp, r7
 800b170:	b00a      	add	sp, #40	; 0x28
 800b172:	bdb0      	pop	{r4, r5, r7, pc}
 800b174:	0801ff98 	.word	0x0801ff98
 800b178:	0801fe58 	.word	0x0801fe58
 800b17c:	0801ffb4 	.word	0x0801ffb4
 800b180:	0801fe94 	.word	0x0801fe94
 800b184:	20002b4c 	.word	0x20002b4c
 800b188:	20002b48 	.word	0x20002b48
 800b18c:	20002b3c 	.word	0x20002b3c
 800b190:	20002b38 	.word	0x20002b38

0800b194 <tcp_abort>:
 *
 * @param pcb the tcp pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
 800b194:	b580      	push	{r7, lr}
 800b196:	b082      	sub	sp, #8
 800b198:	af00      	add	r7, sp, #0
 800b19a:	6078      	str	r0, [r7, #4]
  tcp_abandon(pcb, 1);
 800b19c:	687b      	ldr	r3, [r7, #4]
 800b19e:	2101      	movs	r1, #1
 800b1a0:	0018      	movs	r0, r3
 800b1a2:	f7ff ff2d 	bl	800b000 <tcp_abandon>
}
 800b1a6:	46c0      	nop			; (mov r8, r8)
 800b1a8:	46bd      	mov	sp, r7
 800b1aa:	b002      	add	sp, #8
 800b1ac:	bd80      	pop	{r7, pc}
	...

0800b1b0 <tcp_update_rcv_ann_wnd>:
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t
tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
 800b1b0:	b580      	push	{r7, lr}
 800b1b2:	b084      	sub	sp, #16
 800b1b4:	af00      	add	r7, sp, #0
 800b1b6:	6078      	str	r0, [r7, #4]
  u32_t new_right_edge;

  LWIP_ASSERT("tcp_update_rcv_ann_wnd: invalid pcb", pcb != NULL);
 800b1b8:	687b      	ldr	r3, [r7, #4]
 800b1ba:	2b00      	cmp	r3, #0
 800b1bc:	d105      	bne.n	800b1ca <tcp_update_rcv_ann_wnd+0x1a>
 800b1be:	4b26      	ldr	r3, [pc, #152]	; (800b258 <tcp_update_rcv_ann_wnd+0xa8>)
 800b1c0:	4a26      	ldr	r2, [pc, #152]	; (800b25c <tcp_update_rcv_ann_wnd+0xac>)
 800b1c2:	4927      	ldr	r1, [pc, #156]	; (800b260 <tcp_update_rcv_ann_wnd+0xb0>)
 800b1c4:	4827      	ldr	r0, [pc, #156]	; (800b264 <tcp_update_rcv_ann_wnd+0xb4>)
 800b1c6:	f7f7 fcff 	bl	8002bc8 <app_debug_rtt_raw>
  new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 800b1ca:	687b      	ldr	r3, [r7, #4]
 800b1cc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b1ce:	687a      	ldr	r2, [r7, #4]
 800b1d0:	8d92      	ldrh	r2, [r2, #44]	; 0x2c
 800b1d2:	189b      	adds	r3, r3, r2
 800b1d4:	60fb      	str	r3, [r7, #12]

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 800b1d6:	687b      	ldr	r3, [r7, #4]
 800b1d8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b1da:	687a      	ldr	r2, [r7, #4]
 800b1dc:	8ed2      	ldrh	r2, [r2, #54]	; 0x36
 800b1de:	1c10      	adds	r0, r2, #0
 800b1e0:	b281      	uxth	r1, r0
 800b1e2:	2286      	movs	r2, #134	; 0x86
 800b1e4:	0092      	lsls	r2, r2, #2
 800b1e6:	4291      	cmp	r1, r2
 800b1e8:	d902      	bls.n	800b1f0 <tcp_update_rcv_ann_wnd+0x40>
 800b1ea:	2286      	movs	r2, #134	; 0x86
 800b1ec:	0092      	lsls	r2, r2, #2
 800b1ee:	1c10      	adds	r0, r2, #0
 800b1f0:	b282      	uxth	r2, r0
 800b1f2:	189b      	adds	r3, r3, r2
 800b1f4:	68fa      	ldr	r2, [r7, #12]
 800b1f6:	1ad3      	subs	r3, r2, r3
 800b1f8:	d408      	bmi.n	800b20c <tcp_update_rcv_ann_wnd+0x5c>
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
 800b1fa:	687b      	ldr	r3, [r7, #4]
 800b1fc:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800b1fe:	687b      	ldr	r3, [r7, #4]
 800b200:	85da      	strh	r2, [r3, #46]	; 0x2e
    return new_right_edge - pcb->rcv_ann_right_edge;
 800b202:	687b      	ldr	r3, [r7, #4]
 800b204:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b206:	68fa      	ldr	r2, [r7, #12]
 800b208:	1ad3      	subs	r3, r2, r3
 800b20a:	e020      	b.n	800b24e <tcp_update_rcv_ann_wnd+0x9e>
  } else {
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
 800b20c:	687b      	ldr	r3, [r7, #4]
 800b20e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800b210:	687b      	ldr	r3, [r7, #4]
 800b212:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b214:	1ad3      	subs	r3, r2, r3
 800b216:	2b00      	cmp	r3, #0
 800b218:	dd03      	ble.n	800b222 <tcp_update_rcv_ann_wnd+0x72>
      /* Can happen due to other end sending out of advertised window,
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
 800b21a:	687b      	ldr	r3, [r7, #4]
 800b21c:	2200      	movs	r2, #0
 800b21e:	85da      	strh	r2, [r3, #46]	; 0x2e
 800b220:	e014      	b.n	800b24c <tcp_update_rcv_ann_wnd+0x9c>
    } else {
      /* keep the right edge of window constant */
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
 800b222:	687b      	ldr	r3, [r7, #4]
 800b224:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800b226:	687b      	ldr	r3, [r7, #4]
 800b228:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b22a:	1ad3      	subs	r3, r2, r3
 800b22c:	60bb      	str	r3, [r7, #8]
#if !LWIP_WND_SCALE
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
 800b22e:	68ba      	ldr	r2, [r7, #8]
 800b230:	2380      	movs	r3, #128	; 0x80
 800b232:	025b      	lsls	r3, r3, #9
 800b234:	429a      	cmp	r2, r3
 800b236:	d305      	bcc.n	800b244 <tcp_update_rcv_ann_wnd+0x94>
 800b238:	4b07      	ldr	r3, [pc, #28]	; (800b258 <tcp_update_rcv_ann_wnd+0xa8>)
 800b23a:	4a0b      	ldr	r2, [pc, #44]	; (800b268 <tcp_update_rcv_ann_wnd+0xb8>)
 800b23c:	490b      	ldr	r1, [pc, #44]	; (800b26c <tcp_update_rcv_ann_wnd+0xbc>)
 800b23e:	4809      	ldr	r0, [pc, #36]	; (800b264 <tcp_update_rcv_ann_wnd+0xb4>)
 800b240:	f7f7 fcc2 	bl	8002bc8 <app_debug_rtt_raw>
#endif
      pcb->rcv_ann_wnd = (tcpwnd_size_t)new_rcv_ann_wnd;
 800b244:	68bb      	ldr	r3, [r7, #8]
 800b246:	b29a      	uxth	r2, r3
 800b248:	687b      	ldr	r3, [r7, #4]
 800b24a:	85da      	strh	r2, [r3, #46]	; 0x2e
    }
    return 0;
 800b24c:	2300      	movs	r3, #0
  }
}
 800b24e:	0018      	movs	r0, r3
 800b250:	46bd      	mov	sp, r7
 800b252:	b004      	add	sp, #16
 800b254:	bd80      	pop	{r7, pc}
 800b256:	46c0      	nop			; (mov r8, r8)
 800b258:	0801fe58 	.word	0x0801fe58
 800b25c:	000003a7 	.word	0x000003a7
 800b260:	080200b0 	.word	0x080200b0
 800b264:	0801fe94 	.word	0x0801fe94
 800b268:	000003b7 	.word	0x000003b7
 800b26c:	080200d4 	.word	0x080200d4

0800b270 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
 800b270:	b580      	push	{r7, lr}
 800b272:	b084      	sub	sp, #16
 800b274:	af00      	add	r7, sp, #0
 800b276:	6078      	str	r0, [r7, #4]
 800b278:	000a      	movs	r2, r1
 800b27a:	1cbb      	adds	r3, r7, #2
 800b27c:	801a      	strh	r2, [r3, #0]
  u32_t wnd_inflation;
  tcpwnd_size_t rcv_wnd;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_recved: invalid pcb", pcb != NULL, return);
 800b27e:	687b      	ldr	r3, [r7, #4]
 800b280:	2b00      	cmp	r3, #0
 800b282:	d104      	bne.n	800b28e <tcp_recved+0x1e>
 800b284:	4b23      	ldr	r3, [pc, #140]	; (800b314 <tcp_recved+0xa4>)
 800b286:	0018      	movs	r0, r3
 800b288:	f7f7 fc9e 	bl	8002bc8 <app_debug_rtt_raw>
 800b28c:	e03e      	b.n	800b30c <tcp_recved+0x9c>

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
 800b28e:	687b      	ldr	r3, [r7, #4]
 800b290:	7e1b      	ldrb	r3, [r3, #24]
 800b292:	2b01      	cmp	r3, #1
 800b294:	d105      	bne.n	800b2a2 <tcp_recved+0x32>
 800b296:	4b20      	ldr	r3, [pc, #128]	; (800b318 <tcp_recved+0xa8>)
 800b298:	4a20      	ldr	r2, [pc, #128]	; (800b31c <tcp_recved+0xac>)
 800b29a:	4921      	ldr	r1, [pc, #132]	; (800b320 <tcp_recved+0xb0>)
 800b29c:	4821      	ldr	r0, [pc, #132]	; (800b324 <tcp_recved+0xb4>)
 800b29e:	f7f7 fc93 	bl	8002bc8 <app_debug_rtt_raw>
              pcb->state != LISTEN);

  rcv_wnd = (tcpwnd_size_t)(pcb->rcv_wnd + len);
 800b2a2:	687b      	ldr	r3, [r7, #4]
 800b2a4:	8d99      	ldrh	r1, [r3, #44]	; 0x2c
 800b2a6:	200e      	movs	r0, #14
 800b2a8:	183b      	adds	r3, r7, r0
 800b2aa:	1cba      	adds	r2, r7, #2
 800b2ac:	8812      	ldrh	r2, [r2, #0]
 800b2ae:	188a      	adds	r2, r1, r2
 800b2b0:	801a      	strh	r2, [r3, #0]
  if ((rcv_wnd > TCP_WND_MAX(pcb)) || (rcv_wnd < pcb->rcv_wnd)) {
 800b2b2:	0001      	movs	r1, r0
 800b2b4:	187b      	adds	r3, r7, r1
 800b2b6:	881a      	ldrh	r2, [r3, #0]
 800b2b8:	2386      	movs	r3, #134	; 0x86
 800b2ba:	00db      	lsls	r3, r3, #3
 800b2bc:	429a      	cmp	r2, r3
 800b2be:	d805      	bhi.n	800b2cc <tcp_recved+0x5c>
 800b2c0:	687b      	ldr	r3, [r7, #4]
 800b2c2:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 800b2c4:	187a      	adds	r2, r7, r1
 800b2c6:	8812      	ldrh	r2, [r2, #0]
 800b2c8:	429a      	cmp	r2, r3
 800b2ca:	d204      	bcs.n	800b2d6 <tcp_recved+0x66>
    /* window got too big or tcpwnd_size_t overflow */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: window got too big or tcpwnd_size_t overflow\n"));
    pcb->rcv_wnd = TCP_WND_MAX(pcb);
 800b2cc:	687b      	ldr	r3, [r7, #4]
 800b2ce:	2286      	movs	r2, #134	; 0x86
 800b2d0:	00d2      	lsls	r2, r2, #3
 800b2d2:	859a      	strh	r2, [r3, #44]	; 0x2c
 800b2d4:	e004      	b.n	800b2e0 <tcp_recved+0x70>
  } else  {
    pcb->rcv_wnd = rcv_wnd;
 800b2d6:	687b      	ldr	r3, [r7, #4]
 800b2d8:	220e      	movs	r2, #14
 800b2da:	18ba      	adds	r2, r7, r2
 800b2dc:	8812      	ldrh	r2, [r2, #0]
 800b2de:	859a      	strh	r2, [r3, #44]	; 0x2c
  }

  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
 800b2e0:	687b      	ldr	r3, [r7, #4]
 800b2e2:	0018      	movs	r0, r3
 800b2e4:	f7ff ff64 	bl	800b1b0 <tcp_update_rcv_ann_wnd>
 800b2e8:	0003      	movs	r3, r0
 800b2ea:	60bb      	str	r3, [r7, #8]

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
 800b2ec:	68ba      	ldr	r2, [r7, #8]
 800b2ee:	2386      	movs	r3, #134	; 0x86
 800b2f0:	005b      	lsls	r3, r3, #1
 800b2f2:	429a      	cmp	r2, r3
 800b2f4:	d30a      	bcc.n	800b30c <tcp_recved+0x9c>
    tcp_ack_now(pcb);
 800b2f6:	687b      	ldr	r3, [r7, #4]
 800b2f8:	8bdb      	ldrh	r3, [r3, #30]
 800b2fa:	2202      	movs	r2, #2
 800b2fc:	4313      	orrs	r3, r2
 800b2fe:	b29a      	uxth	r2, r3
 800b300:	687b      	ldr	r3, [r7, #4]
 800b302:	83da      	strh	r2, [r3, #30]
    tcp_output(pcb);
 800b304:	687b      	ldr	r3, [r7, #4]
 800b306:	0018      	movs	r0, r3
 800b308:	f005 fd38 	bl	8010d7c <tcp_output>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: received %"U16_F" bytes, wnd %"TCPWNDSIZE_F" (%"TCPWNDSIZE_F").\n",
                          len, pcb->rcv_wnd, (u16_t)(TCP_WND_MAX(pcb) - pcb->rcv_wnd)));
}
 800b30c:	46bd      	mov	sp, r7
 800b30e:	b004      	add	sp, #16
 800b310:	bd80      	pop	{r7, pc}
 800b312:	46c0      	nop			; (mov r8, r8)
 800b314:	080200f0 	.word	0x080200f0
 800b318:	0801fe58 	.word	0x0801fe58
 800b31c:	000003d3 	.word	0x000003d3
 800b320:	08020108 	.word	0x08020108
 800b324:	0801fe94 	.word	0x0801fe94

0800b328 <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
 800b328:	b580      	push	{r7, lr}
 800b32a:	b082      	sub	sp, #8
 800b32c:	af00      	add	r7, sp, #0
  u8_t i;
  u16_t n = 0;
 800b32e:	1d3b      	adds	r3, r7, #4
 800b330:	2200      	movs	r2, #0
 800b332:	801a      	strh	r2, [r3, #0]
  struct tcp_pcb *pcb;

again:
  tcp_port++;
 800b334:	4b20      	ldr	r3, [pc, #128]	; (800b3b8 <tcp_new_port+0x90>)
 800b336:	881b      	ldrh	r3, [r3, #0]
 800b338:	3301      	adds	r3, #1
 800b33a:	b29a      	uxth	r2, r3
 800b33c:	4b1e      	ldr	r3, [pc, #120]	; (800b3b8 <tcp_new_port+0x90>)
 800b33e:	801a      	strh	r2, [r3, #0]
  if (tcp_port == TCP_LOCAL_PORT_RANGE_END) {
 800b340:	4b1d      	ldr	r3, [pc, #116]	; (800b3b8 <tcp_new_port+0x90>)
 800b342:	881b      	ldrh	r3, [r3, #0]
 800b344:	4a1d      	ldr	r2, [pc, #116]	; (800b3bc <tcp_new_port+0x94>)
 800b346:	4293      	cmp	r3, r2
 800b348:	d102      	bne.n	800b350 <tcp_new_port+0x28>
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
 800b34a:	4b1b      	ldr	r3, [pc, #108]	; (800b3b8 <tcp_new_port+0x90>)
 800b34c:	4a1c      	ldr	r2, [pc, #112]	; (800b3c0 <tcp_new_port+0x98>)
 800b34e:	801a      	strh	r2, [r3, #0]
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
 800b350:	1dfb      	adds	r3, r7, #7
 800b352:	2200      	movs	r2, #0
 800b354:	701a      	strb	r2, [r3, #0]
 800b356:	e025      	b.n	800b3a4 <tcp_new_port+0x7c>
    for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 800b358:	1dfb      	adds	r3, r7, #7
 800b35a:	781a      	ldrb	r2, [r3, #0]
 800b35c:	4b19      	ldr	r3, [pc, #100]	; (800b3c4 <tcp_new_port+0x9c>)
 800b35e:	0092      	lsls	r2, r2, #2
 800b360:	58d3      	ldr	r3, [r2, r3]
 800b362:	681b      	ldr	r3, [r3, #0]
 800b364:	603b      	str	r3, [r7, #0]
 800b366:	e015      	b.n	800b394 <tcp_new_port+0x6c>
      if (pcb->local_port == tcp_port) {
 800b368:	683b      	ldr	r3, [r7, #0]
 800b36a:	8b5a      	ldrh	r2, [r3, #26]
 800b36c:	4b12      	ldr	r3, [pc, #72]	; (800b3b8 <tcp_new_port+0x90>)
 800b36e:	881b      	ldrh	r3, [r3, #0]
 800b370:	429a      	cmp	r2, r3
 800b372:	d10c      	bne.n	800b38e <tcp_new_port+0x66>
        n++;
 800b374:	1d3b      	adds	r3, r7, #4
 800b376:	881a      	ldrh	r2, [r3, #0]
 800b378:	1d3b      	adds	r3, r7, #4
 800b37a:	3201      	adds	r2, #1
 800b37c:	801a      	strh	r2, [r3, #0]
        if (n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
 800b37e:	1d3b      	adds	r3, r7, #4
 800b380:	881a      	ldrh	r2, [r3, #0]
 800b382:	2380      	movs	r3, #128	; 0x80
 800b384:	01db      	lsls	r3, r3, #7
 800b386:	429a      	cmp	r2, r3
 800b388:	d3d4      	bcc.n	800b334 <tcp_new_port+0xc>
          return 0;
 800b38a:	2300      	movs	r3, #0
 800b38c:	e010      	b.n	800b3b0 <tcp_new_port+0x88>
    for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 800b38e:	683b      	ldr	r3, [r7, #0]
 800b390:	691b      	ldr	r3, [r3, #16]
 800b392:	603b      	str	r3, [r7, #0]
 800b394:	683b      	ldr	r3, [r7, #0]
 800b396:	2b00      	cmp	r3, #0
 800b398:	d1e6      	bne.n	800b368 <tcp_new_port+0x40>
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
 800b39a:	1dfb      	adds	r3, r7, #7
 800b39c:	781a      	ldrb	r2, [r3, #0]
 800b39e:	1dfb      	adds	r3, r7, #7
 800b3a0:	3201      	adds	r2, #1
 800b3a2:	701a      	strb	r2, [r3, #0]
 800b3a4:	1dfb      	adds	r3, r7, #7
 800b3a6:	781b      	ldrb	r3, [r3, #0]
 800b3a8:	2b03      	cmp	r3, #3
 800b3aa:	d9d5      	bls.n	800b358 <tcp_new_port+0x30>
        }
        goto again;
      }
    }
  }
  return tcp_port;
 800b3ac:	4b02      	ldr	r3, [pc, #8]	; (800b3b8 <tcp_new_port+0x90>)
 800b3ae:	881b      	ldrh	r3, [r3, #0]
}
 800b3b0:	0018      	movs	r0, r3
 800b3b2:	46bd      	mov	sp, r7
 800b3b4:	b002      	add	sp, #8
 800b3b6:	bd80      	pop	{r7, pc}
 800b3b8:	2000001a 	.word	0x2000001a
 800b3bc:	0000ffff 	.word	0x0000ffff
 800b3c0:	ffffc000 	.word	0xffffc000
 800b3c4:	08022850 	.word	0x08022850

0800b3c8 <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port,
            tcp_connected_fn connected)
{
 800b3c8:	b5b0      	push	{r4, r5, r7, lr}
 800b3ca:	b08c      	sub	sp, #48	; 0x30
 800b3cc:	af00      	add	r7, sp, #0
 800b3ce:	60f8      	str	r0, [r7, #12]
 800b3d0:	60b9      	str	r1, [r7, #8]
 800b3d2:	603b      	str	r3, [r7, #0]
 800b3d4:	1dbb      	adds	r3, r7, #6
 800b3d6:	801a      	strh	r2, [r3, #0]
  struct netif *netif = NULL;
 800b3d8:	2300      	movs	r3, #0
 800b3da:	62fb      	str	r3, [r7, #44]	; 0x2c
  u32_t iss;
  u16_t old_local_port;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_connect: invalid pcb", pcb != NULL, return ERR_ARG);
 800b3dc:	68fb      	ldr	r3, [r7, #12]
 800b3de:	2b00      	cmp	r3, #0
 800b3e0:	d106      	bne.n	800b3f0 <tcp_connect+0x28>
 800b3e2:	4b9c      	ldr	r3, [pc, #624]	; (800b654 <tcp_connect+0x28c>)
 800b3e4:	0018      	movs	r0, r3
 800b3e6:	f7f7 fbef 	bl	8002bc8 <app_debug_rtt_raw>
 800b3ea:	2310      	movs	r3, #16
 800b3ec:	425b      	negs	r3, r3
 800b3ee:	e12d      	b.n	800b64c <tcp_connect+0x284>
  LWIP_ERROR("tcp_connect: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
 800b3f0:	68bb      	ldr	r3, [r7, #8]
 800b3f2:	2b00      	cmp	r3, #0
 800b3f4:	d106      	bne.n	800b404 <tcp_connect+0x3c>
 800b3f6:	4b98      	ldr	r3, [pc, #608]	; (800b658 <tcp_connect+0x290>)
 800b3f8:	0018      	movs	r0, r3
 800b3fa:	f7f7 fbe5 	bl	8002bc8 <app_debug_rtt_raw>
 800b3fe:	2310      	movs	r3, #16
 800b400:	425b      	negs	r3, r3
 800b402:	e123      	b.n	800b64c <tcp_connect+0x284>

  LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
 800b404:	68fb      	ldr	r3, [r7, #12]
 800b406:	7e1b      	ldrb	r3, [r3, #24]
 800b408:	2b00      	cmp	r3, #0
 800b40a:	d006      	beq.n	800b41a <tcp_connect+0x52>
 800b40c:	4b93      	ldr	r3, [pc, #588]	; (800b65c <tcp_connect+0x294>)
 800b40e:	0018      	movs	r0, r3
 800b410:	f7f7 fbda 	bl	8002bc8 <app_debug_rtt_raw>
 800b414:	230a      	movs	r3, #10
 800b416:	425b      	negs	r3, r3
 800b418:	e118      	b.n	800b64c <tcp_connect+0x284>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  ip_addr_set(&pcb->remote_ip, ipaddr);
 800b41a:	68bb      	ldr	r3, [r7, #8]
 800b41c:	2b00      	cmp	r3, #0
 800b41e:	d002      	beq.n	800b426 <tcp_connect+0x5e>
 800b420:	68bb      	ldr	r3, [r7, #8]
 800b422:	681a      	ldr	r2, [r3, #0]
 800b424:	e000      	b.n	800b428 <tcp_connect+0x60>
 800b426:	2200      	movs	r2, #0
 800b428:	68fb      	ldr	r3, [r7, #12]
 800b42a:	605a      	str	r2, [r3, #4]
  pcb->remote_port = port;
 800b42c:	68fb      	ldr	r3, [r7, #12]
 800b42e:	1dba      	adds	r2, r7, #6
 800b430:	8812      	ldrh	r2, [r2, #0]
 800b432:	839a      	strh	r2, [r3, #28]

  if (pcb->netif_idx != NETIF_NO_INDEX) {
 800b434:	68fb      	ldr	r3, [r7, #12]
 800b436:	7a1b      	ldrb	r3, [r3, #8]
 800b438:	2b00      	cmp	r3, #0
 800b43a:	d007      	beq.n	800b44c <tcp_connect+0x84>
    netif = netif_get_by_index(pcb->netif_idx);
 800b43c:	68fb      	ldr	r3, [r7, #12]
 800b43e:	7a1b      	ldrb	r3, [r3, #8]
 800b440:	0018      	movs	r0, r3
 800b442:	f7fe f945 	bl	80096d0 <netif_get_by_index>
 800b446:	0003      	movs	r3, r0
 800b448:	62fb      	str	r3, [r7, #44]	; 0x2c
 800b44a:	e006      	b.n	800b45a <tcp_connect+0x92>
  } else {
    /* check if we have a route to the remote host */
    netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
 800b44c:	68fb      	ldr	r3, [r7, #12]
 800b44e:	3304      	adds	r3, #4
 800b450:	0018      	movs	r0, r3
 800b452:	f008 f8bb 	bl	80135cc <ip4_route>
 800b456:	0003      	movs	r3, r0
 800b458:	62fb      	str	r3, [r7, #44]	; 0x2c
  }
  if (netif == NULL) {
 800b45a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b45c:	2b00      	cmp	r3, #0
 800b45e:	d102      	bne.n	800b466 <tcp_connect+0x9e>
    /* Don't even try to send a SYN packet if we have no route since that will fail. */
    return ERR_RTE;
 800b460:	2304      	movs	r3, #4
 800b462:	425b      	negs	r3, r3
 800b464:	e0f2      	b.n	800b64c <tcp_connect+0x284>
  }

  /* check if local IP has been assigned to pcb, if not, get one */
  if (ip_addr_isany(&pcb->local_ip)) {
 800b466:	68fb      	ldr	r3, [r7, #12]
 800b468:	2b00      	cmp	r3, #0
 800b46a:	d003      	beq.n	800b474 <tcp_connect+0xac>
 800b46c:	68fb      	ldr	r3, [r7, #12]
 800b46e:	681b      	ldr	r3, [r3, #0]
 800b470:	2b00      	cmp	r3, #0
 800b472:	d111      	bne.n	800b498 <tcp_connect+0xd0>
    const ip_addr_t *local_ip = ip_netif_get_local_ip(netif, ipaddr);
 800b474:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b476:	2b00      	cmp	r3, #0
 800b478:	d002      	beq.n	800b480 <tcp_connect+0xb8>
 800b47a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b47c:	3304      	adds	r3, #4
 800b47e:	e000      	b.n	800b482 <tcp_connect+0xba>
 800b480:	2300      	movs	r3, #0
 800b482:	61fb      	str	r3, [r7, #28]
    if (local_ip == NULL) {
 800b484:	69fb      	ldr	r3, [r7, #28]
 800b486:	2b00      	cmp	r3, #0
 800b488:	d102      	bne.n	800b490 <tcp_connect+0xc8>
      return ERR_RTE;
 800b48a:	2304      	movs	r3, #4
 800b48c:	425b      	negs	r3, r3
 800b48e:	e0dd      	b.n	800b64c <tcp_connect+0x284>
    }
    ip_addr_copy(pcb->local_ip, *local_ip);
 800b490:	69fb      	ldr	r3, [r7, #28]
 800b492:	681a      	ldr	r2, [r3, #0]
 800b494:	68fb      	ldr	r3, [r7, #12]
 800b496:	601a      	str	r2, [r3, #0]
      ip6_addr_lacks_zone(ip_2_ip6(&pcb->remote_ip), IP6_UNICAST)) {
    ip6_addr_assign_zone(ip_2_ip6(&pcb->remote_ip), IP6_UNICAST, netif);
  }
#endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */

  old_local_port = pcb->local_port;
 800b498:	231a      	movs	r3, #26
 800b49a:	18fb      	adds	r3, r7, r3
 800b49c:	68fa      	ldr	r2, [r7, #12]
 800b49e:	8b52      	ldrh	r2, [r2, #26]
 800b4a0:	801a      	strh	r2, [r3, #0]
  if (pcb->local_port == 0) {
 800b4a2:	68fb      	ldr	r3, [r7, #12]
 800b4a4:	8b5b      	ldrh	r3, [r3, #26]
 800b4a6:	2b00      	cmp	r3, #0
 800b4a8:	d10c      	bne.n	800b4c4 <tcp_connect+0xfc>
    pcb->local_port = tcp_new_port();
 800b4aa:	f7ff ff3d 	bl	800b328 <tcp_new_port>
 800b4ae:	0003      	movs	r3, r0
 800b4b0:	001a      	movs	r2, r3
 800b4b2:	68fb      	ldr	r3, [r7, #12]
 800b4b4:	835a      	strh	r2, [r3, #26]
    if (pcb->local_port == 0) {
 800b4b6:	68fb      	ldr	r3, [r7, #12]
 800b4b8:	8b5b      	ldrh	r3, [r3, #26]
 800b4ba:	2b00      	cmp	r3, #0
 800b4bc:	d139      	bne.n	800b532 <tcp_connect+0x16a>
      return ERR_BUF;
 800b4be:	2302      	movs	r3, #2
 800b4c0:	425b      	negs	r3, r3
 800b4c2:	e0c3      	b.n	800b64c <tcp_connect+0x284>
    }
  } else {
#if SO_REUSE
    if (ip_get_option(pcb, SOF_REUSEADDR)) {
 800b4c4:	68fb      	ldr	r3, [r7, #12]
 800b4c6:	7a5b      	ldrb	r3, [r3, #9]
 800b4c8:	001a      	movs	r2, r3
 800b4ca:	2304      	movs	r3, #4
 800b4cc:	4013      	ands	r3, r2
 800b4ce:	d030      	beq.n	800b532 <tcp_connect+0x16a>
      /* Since SOF_REUSEADDR allows reusing a local address, we have to make sure
         now that the 5-tuple is unique. */
      struct tcp_pcb *cpcb;
      int i;
      /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
      for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
 800b4d0:	2302      	movs	r3, #2
 800b4d2:	627b      	str	r3, [r7, #36]	; 0x24
 800b4d4:	e02a      	b.n	800b52c <tcp_connect+0x164>
        for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 800b4d6:	4b62      	ldr	r3, [pc, #392]	; (800b660 <tcp_connect+0x298>)
 800b4d8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b4da:	0092      	lsls	r2, r2, #2
 800b4dc:	58d3      	ldr	r3, [r2, r3]
 800b4de:	681b      	ldr	r3, [r3, #0]
 800b4e0:	62bb      	str	r3, [r7, #40]	; 0x28
 800b4e2:	e01d      	b.n	800b520 <tcp_connect+0x158>
          if ((cpcb->local_port == pcb->local_port) &&
 800b4e4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b4e6:	8b5a      	ldrh	r2, [r3, #26]
 800b4e8:	68fb      	ldr	r3, [r7, #12]
 800b4ea:	8b5b      	ldrh	r3, [r3, #26]
 800b4ec:	429a      	cmp	r2, r3
 800b4ee:	d114      	bne.n	800b51a <tcp_connect+0x152>
              (cpcb->remote_port == port) &&
 800b4f0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b4f2:	8b9b      	ldrh	r3, [r3, #28]
          if ((cpcb->local_port == pcb->local_port) &&
 800b4f4:	1dba      	adds	r2, r7, #6
 800b4f6:	8812      	ldrh	r2, [r2, #0]
 800b4f8:	429a      	cmp	r2, r3
 800b4fa:	d10e      	bne.n	800b51a <tcp_connect+0x152>
              ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
 800b4fc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b4fe:	681a      	ldr	r2, [r3, #0]
 800b500:	68fb      	ldr	r3, [r7, #12]
 800b502:	681b      	ldr	r3, [r3, #0]
              (cpcb->remote_port == port) &&
 800b504:	429a      	cmp	r2, r3
 800b506:	d108      	bne.n	800b51a <tcp_connect+0x152>
              ip_addr_cmp(&cpcb->remote_ip, ipaddr)) {
 800b508:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b50a:	685a      	ldr	r2, [r3, #4]
 800b50c:	68bb      	ldr	r3, [r7, #8]
 800b50e:	681b      	ldr	r3, [r3, #0]
              ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
 800b510:	429a      	cmp	r2, r3
 800b512:	d102      	bne.n	800b51a <tcp_connect+0x152>
            /* linux returns EISCONN here, but ERR_USE should be OK for us */
            return ERR_USE;
 800b514:	2308      	movs	r3, #8
 800b516:	425b      	negs	r3, r3
 800b518:	e098      	b.n	800b64c <tcp_connect+0x284>
        for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 800b51a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b51c:	691b      	ldr	r3, [r3, #16]
 800b51e:	62bb      	str	r3, [r7, #40]	; 0x28
 800b520:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b522:	2b00      	cmp	r3, #0
 800b524:	d1de      	bne.n	800b4e4 <tcp_connect+0x11c>
      for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
 800b526:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b528:	3301      	adds	r3, #1
 800b52a:	627b      	str	r3, [r7, #36]	; 0x24
 800b52c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b52e:	2b03      	cmp	r3, #3
 800b530:	ddd1      	ble.n	800b4d6 <tcp_connect+0x10e>
      }
    }
#endif /* SO_REUSE */
  }

  iss = tcp_next_iss(pcb);
 800b532:	68fb      	ldr	r3, [r7, #12]
 800b534:	0018      	movs	r0, r3
 800b536:	f001 f8d9 	bl	800c6ec <tcp_next_iss>
 800b53a:	0003      	movs	r3, r0
 800b53c:	617b      	str	r3, [r7, #20]
  pcb->rcv_nxt = 0;
 800b53e:	68fb      	ldr	r3, [r7, #12]
 800b540:	2200      	movs	r2, #0
 800b542:	629a      	str	r2, [r3, #40]	; 0x28
  pcb->snd_nxt = iss;
 800b544:	68fb      	ldr	r3, [r7, #12]
 800b546:	697a      	ldr	r2, [r7, #20]
 800b548:	655a      	str	r2, [r3, #84]	; 0x54
  pcb->lastack = iss - 1;
 800b54a:	697b      	ldr	r3, [r7, #20]
 800b54c:	1e5a      	subs	r2, r3, #1
 800b54e:	68fb      	ldr	r3, [r7, #12]
 800b550:	649a      	str	r2, [r3, #72]	; 0x48
  pcb->snd_wl2 = iss - 1;
 800b552:	697b      	ldr	r3, [r7, #20]
 800b554:	1e5a      	subs	r2, r3, #1
 800b556:	68fb      	ldr	r3, [r7, #12]
 800b558:	65da      	str	r2, [r3, #92]	; 0x5c
  pcb->snd_lbb = iss - 1;
 800b55a:	697b      	ldr	r3, [r7, #20]
 800b55c:	1e5a      	subs	r2, r3, #1
 800b55e:	68fb      	ldr	r3, [r7, #12]
 800b560:	661a      	str	r2, [r3, #96]	; 0x60
  /* Start with a window that does not need scaling. When window scaling is
     enabled and used, the window is enlarged when both sides agree on scaling. */
  pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
 800b562:	68fb      	ldr	r3, [r7, #12]
 800b564:	2286      	movs	r2, #134	; 0x86
 800b566:	00d2      	lsls	r2, r2, #3
 800b568:	85da      	strh	r2, [r3, #46]	; 0x2e
 800b56a:	68fb      	ldr	r3, [r7, #12]
 800b56c:	8dda      	ldrh	r2, [r3, #46]	; 0x2e
 800b56e:	68fb      	ldr	r3, [r7, #12]
 800b570:	859a      	strh	r2, [r3, #44]	; 0x2c
  pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 800b572:	68fb      	ldr	r3, [r7, #12]
 800b574:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800b576:	68fb      	ldr	r3, [r7, #12]
 800b578:	631a      	str	r2, [r3, #48]	; 0x30
  pcb->snd_wnd = TCP_WND;
 800b57a:	68fb      	ldr	r3, [r7, #12]
 800b57c:	2264      	movs	r2, #100	; 0x64
 800b57e:	2186      	movs	r1, #134	; 0x86
 800b580:	00c9      	lsls	r1, r1, #3
 800b582:	5299      	strh	r1, [r3, r2]
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = INITIAL_MSS;
 800b584:	68fb      	ldr	r3, [r7, #12]
 800b586:	2286      	movs	r2, #134	; 0x86
 800b588:	0092      	lsls	r2, r2, #2
 800b58a:	86da      	strh	r2, [r3, #54]	; 0x36
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss_netif(pcb->mss, netif, &pcb->remote_ip);
 800b58c:	68fb      	ldr	r3, [r7, #12]
 800b58e:	8ed8      	ldrh	r0, [r3, #54]	; 0x36
 800b590:	68fb      	ldr	r3, [r7, #12]
 800b592:	1d1a      	adds	r2, r3, #4
 800b594:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b596:	0019      	movs	r1, r3
 800b598:	f001 f8ce 	bl	800c738 <tcp_eff_send_mss_netif>
 800b59c:	0003      	movs	r3, r0
 800b59e:	001a      	movs	r2, r3
 800b5a0:	68fb      	ldr	r3, [r7, #12]
 800b5a2:	86da      	strh	r2, [r3, #54]	; 0x36
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
 800b5a4:	68fb      	ldr	r3, [r7, #12]
 800b5a6:	224c      	movs	r2, #76	; 0x4c
 800b5a8:	2101      	movs	r1, #1
 800b5aa:	5299      	strh	r1, [r3, r2]
#if LWIP_CALLBACK_API
  pcb->connected = connected;
 800b5ac:	68fb      	ldr	r3, [r7, #12]
 800b5ae:	218c      	movs	r1, #140	; 0x8c
 800b5b0:	683a      	ldr	r2, [r7, #0]
 800b5b2:	505a      	str	r2, [r3, r1]
#else /* LWIP_CALLBACK_API */
  LWIP_UNUSED_ARG(connected);
#endif /* LWIP_CALLBACK_API */

  /* Send a SYN together with the MSS option. */
  ret = tcp_enqueue_flags(pcb, TCP_SYN);
 800b5b4:	2513      	movs	r5, #19
 800b5b6:	197c      	adds	r4, r7, r5
 800b5b8:	68fb      	ldr	r3, [r7, #12]
 800b5ba:	2102      	movs	r1, #2
 800b5bc:	0018      	movs	r0, r3
 800b5be:	f005 fad7 	bl	8010b70 <tcp_enqueue_flags>
 800b5c2:	0003      	movs	r3, r0
 800b5c4:	7023      	strb	r3, [r4, #0]
  if (ret == ERR_OK) {
 800b5c6:	197b      	adds	r3, r7, r5
 800b5c8:	781b      	ldrb	r3, [r3, #0]
 800b5ca:	b25b      	sxtb	r3, r3
 800b5cc:	2b00      	cmp	r3, #0
 800b5ce:	d139      	bne.n	800b644 <tcp_connect+0x27c>
    /* SYN segment was enqueued, changed the pcbs state now */
    pcb->state = SYN_SENT;
 800b5d0:	68fb      	ldr	r3, [r7, #12]
 800b5d2:	2202      	movs	r2, #2
 800b5d4:	761a      	strb	r2, [r3, #24]
    if (old_local_port != 0) {
 800b5d6:	231a      	movs	r3, #26
 800b5d8:	18fb      	adds	r3, r7, r3
 800b5da:	881b      	ldrh	r3, [r3, #0]
 800b5dc:	2b00      	cmp	r3, #0
 800b5de:	d021      	beq.n	800b624 <tcp_connect+0x25c>
      TCP_RMV(&tcp_bound_pcbs, pcb);
 800b5e0:	4b20      	ldr	r3, [pc, #128]	; (800b664 <tcp_connect+0x29c>)
 800b5e2:	681b      	ldr	r3, [r3, #0]
 800b5e4:	68fa      	ldr	r2, [r7, #12]
 800b5e6:	429a      	cmp	r2, r3
 800b5e8:	d105      	bne.n	800b5f6 <tcp_connect+0x22e>
 800b5ea:	4b1e      	ldr	r3, [pc, #120]	; (800b664 <tcp_connect+0x29c>)
 800b5ec:	681b      	ldr	r3, [r3, #0]
 800b5ee:	691a      	ldr	r2, [r3, #16]
 800b5f0:	4b1c      	ldr	r3, [pc, #112]	; (800b664 <tcp_connect+0x29c>)
 800b5f2:	601a      	str	r2, [r3, #0]
 800b5f4:	e013      	b.n	800b61e <tcp_connect+0x256>
 800b5f6:	4b1b      	ldr	r3, [pc, #108]	; (800b664 <tcp_connect+0x29c>)
 800b5f8:	681b      	ldr	r3, [r3, #0]
 800b5fa:	623b      	str	r3, [r7, #32]
 800b5fc:	e00c      	b.n	800b618 <tcp_connect+0x250>
 800b5fe:	6a3b      	ldr	r3, [r7, #32]
 800b600:	691b      	ldr	r3, [r3, #16]
 800b602:	68fa      	ldr	r2, [r7, #12]
 800b604:	429a      	cmp	r2, r3
 800b606:	d104      	bne.n	800b612 <tcp_connect+0x24a>
 800b608:	68fb      	ldr	r3, [r7, #12]
 800b60a:	691a      	ldr	r2, [r3, #16]
 800b60c:	6a3b      	ldr	r3, [r7, #32]
 800b60e:	611a      	str	r2, [r3, #16]
 800b610:	e005      	b.n	800b61e <tcp_connect+0x256>
 800b612:	6a3b      	ldr	r3, [r7, #32]
 800b614:	691b      	ldr	r3, [r3, #16]
 800b616:	623b      	str	r3, [r7, #32]
 800b618:	6a3b      	ldr	r3, [r7, #32]
 800b61a:	2b00      	cmp	r3, #0
 800b61c:	d1ef      	bne.n	800b5fe <tcp_connect+0x236>
 800b61e:	68fb      	ldr	r3, [r7, #12]
 800b620:	2200      	movs	r2, #0
 800b622:	611a      	str	r2, [r3, #16]
    }
    TCP_REG_ACTIVE(pcb);
 800b624:	4b10      	ldr	r3, [pc, #64]	; (800b668 <tcp_connect+0x2a0>)
 800b626:	681a      	ldr	r2, [r3, #0]
 800b628:	68fb      	ldr	r3, [r7, #12]
 800b62a:	611a      	str	r2, [r3, #16]
 800b62c:	4b0e      	ldr	r3, [pc, #56]	; (800b668 <tcp_connect+0x2a0>)
 800b62e:	68fa      	ldr	r2, [r7, #12]
 800b630:	601a      	str	r2, [r3, #0]
 800b632:	f006 fe21 	bl	8012278 <tcp_timer_needed>
 800b636:	4b0d      	ldr	r3, [pc, #52]	; (800b66c <tcp_connect+0x2a4>)
 800b638:	2201      	movs	r2, #1
 800b63a:	701a      	strb	r2, [r3, #0]
    MIB2_STATS_INC(mib2.tcpactiveopens);

    tcp_output(pcb);
 800b63c:	68fb      	ldr	r3, [r7, #12]
 800b63e:	0018      	movs	r0, r3
 800b640:	f005 fb9c 	bl	8010d7c <tcp_output>
  }
  return ret;
 800b644:	2313      	movs	r3, #19
 800b646:	18fb      	adds	r3, r7, r3
 800b648:	781b      	ldrb	r3, [r3, #0]
 800b64a:	b25b      	sxtb	r3, r3
}
 800b64c:	0018      	movs	r0, r3
 800b64e:	46bd      	mov	sp, r7
 800b650:	b00c      	add	sp, #48	; 0x30
 800b652:	bdb0      	pop	{r4, r5, r7, pc}
 800b654:	08020130 	.word	0x08020130
 800b658:	0802014c 	.word	0x0802014c
 800b65c:	08020168 	.word	0x08020168
 800b660:	08022850 	.word	0x08022850
 800b664:	20002b48 	.word	0x20002b48
 800b668:	20002b3c 	.word	0x20002b3c
 800b66c:	20002b38 	.word	0x20002b38

0800b670 <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
 800b670:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b672:	b091      	sub	sp, #68	; 0x44
 800b674:	af04      	add	r7, sp, #16
  tcpwnd_size_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;
 800b676:	2325      	movs	r3, #37	; 0x25
 800b678:	18fb      	adds	r3, r7, r3
 800b67a:	2200      	movs	r2, #0
 800b67c:	701a      	strb	r2, [r3, #0]

  ++tcp_ticks;
 800b67e:	4b9c      	ldr	r3, [pc, #624]	; (800b8f0 <tcp_slowtmr+0x280>)
 800b680:	681b      	ldr	r3, [r3, #0]
 800b682:	1c5a      	adds	r2, r3, #1
 800b684:	4b9a      	ldr	r3, [pc, #616]	; (800b8f0 <tcp_slowtmr+0x280>)
 800b686:	601a      	str	r2, [r3, #0]
  ++tcp_timer_ctr;
 800b688:	4b9a      	ldr	r3, [pc, #616]	; (800b8f4 <tcp_slowtmr+0x284>)
 800b68a:	781b      	ldrb	r3, [r3, #0]
 800b68c:	3301      	adds	r3, #1
 800b68e:	b2da      	uxtb	r2, r3
 800b690:	4b98      	ldr	r3, [pc, #608]	; (800b8f4 <tcp_slowtmr+0x284>)
 800b692:	701a      	strb	r2, [r3, #0]

tcp_slowtmr_start:
  /* Steps through all of the active PCBs. */
  prev = NULL;
 800b694:	2300      	movs	r3, #0
 800b696:	62bb      	str	r3, [r7, #40]	; 0x28
  pcb = tcp_active_pcbs;
 800b698:	4b97      	ldr	r3, [pc, #604]	; (800b8f8 <tcp_slowtmr+0x288>)
 800b69a:	681b      	ldr	r3, [r3, #0]
 800b69c:	62fb      	str	r3, [r7, #44]	; 0x2c
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
 800b69e:	e2e2      	b.n	800bc66 <tcp_slowtmr+0x5f6>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
 800b6a0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b6a2:	7e1b      	ldrb	r3, [r3, #24]
 800b6a4:	2b00      	cmp	r3, #0
 800b6a6:	d105      	bne.n	800b6b4 <tcp_slowtmr+0x44>
 800b6a8:	4b94      	ldr	r3, [pc, #592]	; (800b8fc <tcp_slowtmr+0x28c>)
 800b6aa:	4a95      	ldr	r2, [pc, #596]	; (800b900 <tcp_slowtmr+0x290>)
 800b6ac:	4995      	ldr	r1, [pc, #596]	; (800b904 <tcp_slowtmr+0x294>)
 800b6ae:	4896      	ldr	r0, [pc, #600]	; (800b908 <tcp_slowtmr+0x298>)
 800b6b0:	f7f7 fa8a 	bl	8002bc8 <app_debug_rtt_raw>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
 800b6b4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b6b6:	7e1b      	ldrb	r3, [r3, #24]
 800b6b8:	2b01      	cmp	r3, #1
 800b6ba:	d106      	bne.n	800b6ca <tcp_slowtmr+0x5a>
 800b6bc:	4b8f      	ldr	r3, [pc, #572]	; (800b8fc <tcp_slowtmr+0x28c>)
 800b6be:	2298      	movs	r2, #152	; 0x98
 800b6c0:	00d2      	lsls	r2, r2, #3
 800b6c2:	4992      	ldr	r1, [pc, #584]	; (800b90c <tcp_slowtmr+0x29c>)
 800b6c4:	4890      	ldr	r0, [pc, #576]	; (800b908 <tcp_slowtmr+0x298>)
 800b6c6:	f7f7 fa7f 	bl	8002bc8 <app_debug_rtt_raw>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
 800b6ca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b6cc:	7e1b      	ldrb	r3, [r3, #24]
 800b6ce:	2b0a      	cmp	r3, #10
 800b6d0:	d105      	bne.n	800b6de <tcp_slowtmr+0x6e>
 800b6d2:	4b8a      	ldr	r3, [pc, #552]	; (800b8fc <tcp_slowtmr+0x28c>)
 800b6d4:	4a8e      	ldr	r2, [pc, #568]	; (800b910 <tcp_slowtmr+0x2a0>)
 800b6d6:	498f      	ldr	r1, [pc, #572]	; (800b914 <tcp_slowtmr+0x2a4>)
 800b6d8:	488b      	ldr	r0, [pc, #556]	; (800b908 <tcp_slowtmr+0x298>)
 800b6da:	f7f7 fa75 	bl	8002bc8 <app_debug_rtt_raw>
    if (pcb->last_timer == tcp_timer_ctr) {
 800b6de:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b6e0:	2222      	movs	r2, #34	; 0x22
 800b6e2:	5c9a      	ldrb	r2, [r3, r2]
 800b6e4:	4b83      	ldr	r3, [pc, #524]	; (800b8f4 <tcp_slowtmr+0x284>)
 800b6e6:	781b      	ldrb	r3, [r3, #0]
 800b6e8:	429a      	cmp	r2, r3
 800b6ea:	d105      	bne.n	800b6f8 <tcp_slowtmr+0x88>
      /* skip this pcb, we have already processed it */
      prev = pcb;
 800b6ec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b6ee:	62bb      	str	r3, [r7, #40]	; 0x28
      pcb = pcb->next;
 800b6f0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b6f2:	691b      	ldr	r3, [r3, #16]
 800b6f4:	62fb      	str	r3, [r7, #44]	; 0x2c
      continue;
 800b6f6:	e2b6      	b.n	800bc66 <tcp_slowtmr+0x5f6>
    }
    pcb->last_timer = tcp_timer_ctr;
 800b6f8:	4b7e      	ldr	r3, [pc, #504]	; (800b8f4 <tcp_slowtmr+0x284>)
 800b6fa:	7819      	ldrb	r1, [r3, #0]
 800b6fc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b6fe:	2222      	movs	r2, #34	; 0x22
 800b700:	5499      	strb	r1, [r3, r2]

    pcb_remove = 0;
 800b702:	2127      	movs	r1, #39	; 0x27
 800b704:	187b      	adds	r3, r7, r1
 800b706:	2200      	movs	r2, #0
 800b708:	701a      	strb	r2, [r3, #0]
    pcb_reset = 0;
 800b70a:	2326      	movs	r3, #38	; 0x26
 800b70c:	18fb      	adds	r3, r7, r3
 800b70e:	2200      	movs	r2, #0
 800b710:	701a      	strb	r2, [r3, #0]

    if (pcb->state == SYN_SENT && pcb->nrtx >= TCP_SYNMAXRTX) {
 800b712:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b714:	7e1b      	ldrb	r3, [r3, #24]
 800b716:	2b02      	cmp	r3, #2
 800b718:	d10a      	bne.n	800b730 <tcp_slowtmr+0xc0>
 800b71a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b71c:	2246      	movs	r2, #70	; 0x46
 800b71e:	5c9b      	ldrb	r3, [r3, r2]
 800b720:	2b05      	cmp	r3, #5
 800b722:	d905      	bls.n	800b730 <tcp_slowtmr+0xc0>
      ++pcb_remove;
 800b724:	187b      	adds	r3, r7, r1
 800b726:	187a      	adds	r2, r7, r1
 800b728:	7812      	ldrb	r2, [r2, #0]
 800b72a:	3201      	adds	r2, #1
 800b72c:	701a      	strb	r2, [r3, #0]
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
 800b72e:	e13f      	b.n	800b9b0 <tcp_slowtmr+0x340>
    } else if (pcb->nrtx >= TCP_MAXRTX) {
 800b730:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b732:	2246      	movs	r2, #70	; 0x46
 800b734:	5c9b      	ldrb	r3, [r3, r2]
 800b736:	2b0b      	cmp	r3, #11
 800b738:	d906      	bls.n	800b748 <tcp_slowtmr+0xd8>
      ++pcb_remove;
 800b73a:	2227      	movs	r2, #39	; 0x27
 800b73c:	18bb      	adds	r3, r7, r2
 800b73e:	18ba      	adds	r2, r7, r2
 800b740:	7812      	ldrb	r2, [r2, #0]
 800b742:	3201      	adds	r2, #1
 800b744:	701a      	strb	r2, [r3, #0]
 800b746:	e133      	b.n	800b9b0 <tcp_slowtmr+0x340>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
 800b748:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b74a:	22a5      	movs	r2, #165	; 0xa5
 800b74c:	5c9b      	ldrb	r3, [r3, r2]
 800b74e:	2b00      	cmp	r3, #0
 800b750:	d100      	bne.n	800b754 <tcp_slowtmr+0xe4>
 800b752:	e079      	b.n	800b848 <tcp_slowtmr+0x1d8>
        LWIP_ASSERT("tcp_slowtimr: persist ticking with in-flight data", pcb->unacked == NULL);
 800b754:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b756:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800b758:	2b00      	cmp	r3, #0
 800b75a:	d005      	beq.n	800b768 <tcp_slowtmr+0xf8>
 800b75c:	4b67      	ldr	r3, [pc, #412]	; (800b8fc <tcp_slowtmr+0x28c>)
 800b75e:	4a6e      	ldr	r2, [pc, #440]	; (800b918 <tcp_slowtmr+0x2a8>)
 800b760:	496e      	ldr	r1, [pc, #440]	; (800b91c <tcp_slowtmr+0x2ac>)
 800b762:	4869      	ldr	r0, [pc, #420]	; (800b908 <tcp_slowtmr+0x298>)
 800b764:	f7f7 fa30 	bl	8002bc8 <app_debug_rtt_raw>
        LWIP_ASSERT("tcp_slowtimr: persist ticking with empty send buffer", pcb->unsent != NULL);
 800b768:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b76a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800b76c:	2b00      	cmp	r3, #0
 800b76e:	d105      	bne.n	800b77c <tcp_slowtmr+0x10c>
 800b770:	4b62      	ldr	r3, [pc, #392]	; (800b8fc <tcp_slowtmr+0x28c>)
 800b772:	4a6b      	ldr	r2, [pc, #428]	; (800b920 <tcp_slowtmr+0x2b0>)
 800b774:	496b      	ldr	r1, [pc, #428]	; (800b924 <tcp_slowtmr+0x2b4>)
 800b776:	4864      	ldr	r0, [pc, #400]	; (800b908 <tcp_slowtmr+0x298>)
 800b778:	f7f7 fa26 	bl	8002bc8 <app_debug_rtt_raw>
        if (pcb->persist_probe >= TCP_MAXRTX) {
 800b77c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b77e:	22a6      	movs	r2, #166	; 0xa6
 800b780:	5c9b      	ldrb	r3, [r3, r2]
 800b782:	2b0b      	cmp	r3, #11
 800b784:	d906      	bls.n	800b794 <tcp_slowtmr+0x124>
          ++pcb_remove; /* max probes reached */
 800b786:	2227      	movs	r2, #39	; 0x27
 800b788:	18bb      	adds	r3, r7, r2
 800b78a:	18ba      	adds	r2, r7, r2
 800b78c:	7812      	ldrb	r2, [r2, #0]
 800b78e:	3201      	adds	r2, #1
 800b790:	701a      	strb	r2, [r3, #0]
 800b792:	e10d      	b.n	800b9b0 <tcp_slowtmr+0x340>
        } else {
          u8_t backoff_cnt = tcp_persist_backoff[pcb->persist_backoff - 1];
 800b794:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b796:	22a5      	movs	r2, #165	; 0xa5
 800b798:	5c9b      	ldrb	r3, [r3, r2]
 800b79a:	1e5a      	subs	r2, r3, #1
 800b79c:	2011      	movs	r0, #17
 800b79e:	183b      	adds	r3, r7, r0
 800b7a0:	4961      	ldr	r1, [pc, #388]	; (800b928 <tcp_slowtmr+0x2b8>)
 800b7a2:	5c8a      	ldrb	r2, [r1, r2]
 800b7a4:	701a      	strb	r2, [r3, #0]
          if (pcb->persist_cnt < backoff_cnt) {
 800b7a6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b7a8:	22a4      	movs	r2, #164	; 0xa4
 800b7aa:	5c9b      	ldrb	r3, [r3, r2]
 800b7ac:	183a      	adds	r2, r7, r0
 800b7ae:	7812      	ldrb	r2, [r2, #0]
 800b7b0:	429a      	cmp	r2, r3
 800b7b2:	d907      	bls.n	800b7c4 <tcp_slowtmr+0x154>
            pcb->persist_cnt++;
 800b7b4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b7b6:	22a4      	movs	r2, #164	; 0xa4
 800b7b8:	5c9b      	ldrb	r3, [r3, r2]
 800b7ba:	3301      	adds	r3, #1
 800b7bc:	b2d9      	uxtb	r1, r3
 800b7be:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b7c0:	22a4      	movs	r2, #164	; 0xa4
 800b7c2:	5499      	strb	r1, [r3, r2]
          }
          if (pcb->persist_cnt >= backoff_cnt) {
 800b7c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b7c6:	22a4      	movs	r2, #164	; 0xa4
 800b7c8:	5c9b      	ldrb	r3, [r3, r2]
 800b7ca:	2211      	movs	r2, #17
 800b7cc:	18ba      	adds	r2, r7, r2
 800b7ce:	7812      	ldrb	r2, [r2, #0]
 800b7d0:	429a      	cmp	r2, r3
 800b7d2:	d900      	bls.n	800b7d6 <tcp_slowtmr+0x166>
 800b7d4:	e0ec      	b.n	800b9b0 <tcp_slowtmr+0x340>
            int next_slot = 1; /* increment timer to next slot */
 800b7d6:	2301      	movs	r3, #1
 800b7d8:	623b      	str	r3, [r7, #32]
            /* If snd_wnd is zero, send 1 byte probes */
            if (pcb->snd_wnd == 0) {
 800b7da:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b7dc:	2264      	movs	r2, #100	; 0x64
 800b7de:	5a9b      	ldrh	r3, [r3, r2]
 800b7e0:	2b00      	cmp	r3, #0
 800b7e2:	d108      	bne.n	800b7f6 <tcp_slowtmr+0x186>
              if (tcp_zero_window_probe(pcb) != ERR_OK) {
 800b7e4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b7e6:	0018      	movs	r0, r3
 800b7e8:	f006 fc3c 	bl	8012064 <tcp_zero_window_probe>
 800b7ec:	1e03      	subs	r3, r0, #0
 800b7ee:	d014      	beq.n	800b81a <tcp_slowtmr+0x1aa>
                next_slot = 0; /* try probe again with current slot */
 800b7f0:	2300      	movs	r3, #0
 800b7f2:	623b      	str	r3, [r7, #32]
 800b7f4:	e011      	b.n	800b81a <tcp_slowtmr+0x1aa>
              }
              /* snd_wnd not fully closed, split unsent head and fill window */
            } else {
              if (tcp_split_unsent_seg(pcb, (u16_t)pcb->snd_wnd) == ERR_OK) {
 800b7f6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b7f8:	2264      	movs	r2, #100	; 0x64
 800b7fa:	5a9a      	ldrh	r2, [r3, r2]
 800b7fc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b7fe:	0011      	movs	r1, r2
 800b800:	0018      	movs	r0, r3
 800b802:	f004 ff0f 	bl	8010624 <tcp_split_unsent_seg>
 800b806:	1e03      	subs	r3, r0, #0
 800b808:	d107      	bne.n	800b81a <tcp_slowtmr+0x1aa>
                if (tcp_output(pcb) == ERR_OK) {
 800b80a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b80c:	0018      	movs	r0, r3
 800b80e:	f005 fab5 	bl	8010d7c <tcp_output>
 800b812:	1e03      	subs	r3, r0, #0
 800b814:	d101      	bne.n	800b81a <tcp_slowtmr+0x1aa>
                  /* sending will cancel persist timer, else retry with current slot */
                  next_slot = 0;
 800b816:	2300      	movs	r3, #0
 800b818:	623b      	str	r3, [r7, #32]
                }
              }
            }
            if (next_slot) {
 800b81a:	6a3b      	ldr	r3, [r7, #32]
 800b81c:	2b00      	cmp	r3, #0
 800b81e:	d100      	bne.n	800b822 <tcp_slowtmr+0x1b2>
 800b820:	e0c6      	b.n	800b9b0 <tcp_slowtmr+0x340>
              pcb->persist_cnt = 0;
 800b822:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b824:	22a4      	movs	r2, #164	; 0xa4
 800b826:	2100      	movs	r1, #0
 800b828:	5499      	strb	r1, [r3, r2]
              if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
 800b82a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b82c:	22a5      	movs	r2, #165	; 0xa5
 800b82e:	5c9b      	ldrb	r3, [r3, r2]
 800b830:	2b06      	cmp	r3, #6
 800b832:	d900      	bls.n	800b836 <tcp_slowtmr+0x1c6>
 800b834:	e0bc      	b.n	800b9b0 <tcp_slowtmr+0x340>
                pcb->persist_backoff++;
 800b836:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b838:	22a5      	movs	r2, #165	; 0xa5
 800b83a:	5c9b      	ldrb	r3, [r3, r2]
 800b83c:	3301      	adds	r3, #1
 800b83e:	b2d9      	uxtb	r1, r3
 800b840:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b842:	22a5      	movs	r2, #165	; 0xa5
 800b844:	5499      	strb	r1, [r3, r2]
 800b846:	e0b3      	b.n	800b9b0 <tcp_slowtmr+0x340>
            }
          }
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if ((pcb->rtime >= 0) && (pcb->rtime < 0x7FFF)) {
 800b848:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b84a:	2234      	movs	r2, #52	; 0x34
 800b84c:	5e9b      	ldrsh	r3, [r3, r2]
 800b84e:	2b00      	cmp	r3, #0
 800b850:	db0e      	blt.n	800b870 <tcp_slowtmr+0x200>
 800b852:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b854:	2234      	movs	r2, #52	; 0x34
 800b856:	5e9b      	ldrsh	r3, [r3, r2]
 800b858:	4a34      	ldr	r2, [pc, #208]	; (800b92c <tcp_slowtmr+0x2bc>)
 800b85a:	4293      	cmp	r3, r2
 800b85c:	d008      	beq.n	800b870 <tcp_slowtmr+0x200>
          ++pcb->rtime;
 800b85e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b860:	2234      	movs	r2, #52	; 0x34
 800b862:	5e9b      	ldrsh	r3, [r3, r2]
 800b864:	b29b      	uxth	r3, r3
 800b866:	3301      	adds	r3, #1
 800b868:	b29b      	uxth	r3, r3
 800b86a:	b21a      	sxth	r2, r3
 800b86c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b86e:	869a      	strh	r2, [r3, #52]	; 0x34
        }

        if (pcb->rtime >= pcb->rto) {
 800b870:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b872:	2234      	movs	r2, #52	; 0x34
 800b874:	5e9a      	ldrsh	r2, [r3, r2]
 800b876:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b878:	2144      	movs	r1, #68	; 0x44
 800b87a:	5e5b      	ldrsh	r3, [r3, r1]
 800b87c:	429a      	cmp	r2, r3
 800b87e:	da00      	bge.n	800b882 <tcp_slowtmr+0x212>
 800b880:	e096      	b.n	800b9b0 <tcp_slowtmr+0x340>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));
          /* If prepare phase fails but we have unsent data but no unacked data,
             still execute the backoff calculations below, as this means we somehow
             failed to send segment. */
          if ((tcp_rexmit_rto_prepare(pcb) == ERR_OK) || ((pcb->unacked == NULL) && (pcb->unsent != NULL))) {
 800b882:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b884:	0018      	movs	r0, r3
 800b886:	f005 fed3 	bl	8011630 <tcp_rexmit_rto_prepare>
 800b88a:	1e03      	subs	r3, r0, #0
 800b88c:	d009      	beq.n	800b8a2 <tcp_slowtmr+0x232>
 800b88e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b890:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800b892:	2b00      	cmp	r3, #0
 800b894:	d000      	beq.n	800b898 <tcp_slowtmr+0x228>
 800b896:	e08b      	b.n	800b9b0 <tcp_slowtmr+0x340>
 800b898:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b89a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800b89c:	2b00      	cmp	r3, #0
 800b89e:	d100      	bne.n	800b8a2 <tcp_slowtmr+0x232>
 800b8a0:	e086      	b.n	800b9b0 <tcp_slowtmr+0x340>
            /* Double retransmission time-out unless we are trying to
             * connect to somebody (i.e., we are in SYN_SENT). */
            if (pcb->state != SYN_SENT) {
 800b8a2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b8a4:	7e1b      	ldrb	r3, [r3, #24]
 800b8a6:	2b02      	cmp	r3, #2
 800b8a8:	d04a      	beq.n	800b940 <tcp_slowtmr+0x2d0>
              u8_t backoff_idx = LWIP_MIN(pcb->nrtx, sizeof(tcp_backoff) - 1);
 800b8aa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b8ac:	2246      	movs	r2, #70	; 0x46
 800b8ae:	5c9b      	ldrb	r3, [r3, r2]
 800b8b0:	221b      	movs	r2, #27
 800b8b2:	18ba      	adds	r2, r7, r2
 800b8b4:	b2d9      	uxtb	r1, r3
 800b8b6:	290c      	cmp	r1, #12
 800b8b8:	d900      	bls.n	800b8bc <tcp_slowtmr+0x24c>
 800b8ba:	230c      	movs	r3, #12
 800b8bc:	7013      	strb	r3, [r2, #0]
              int calc_rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[backoff_idx];
 800b8be:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b8c0:	2240      	movs	r2, #64	; 0x40
 800b8c2:	5e9b      	ldrsh	r3, [r3, r2]
 800b8c4:	10db      	asrs	r3, r3, #3
 800b8c6:	b21b      	sxth	r3, r3
 800b8c8:	0019      	movs	r1, r3
 800b8ca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b8cc:	2242      	movs	r2, #66	; 0x42
 800b8ce:	5e9b      	ldrsh	r3, [r3, r2]
 800b8d0:	18cb      	adds	r3, r1, r3
 800b8d2:	221b      	movs	r2, #27
 800b8d4:	18ba      	adds	r2, r7, r2
 800b8d6:	7812      	ldrb	r2, [r2, #0]
 800b8d8:	4915      	ldr	r1, [pc, #84]	; (800b930 <tcp_slowtmr+0x2c0>)
 800b8da:	5c8a      	ldrb	r2, [r1, r2]
 800b8dc:	4093      	lsls	r3, r2
 800b8de:	617b      	str	r3, [r7, #20]
              pcb->rto = (s16_t)LWIP_MIN(calc_rto, 0x7FFF);
 800b8e0:	697b      	ldr	r3, [r7, #20]
 800b8e2:	4a14      	ldr	r2, [pc, #80]	; (800b934 <tcp_slowtmr+0x2c4>)
 800b8e4:	4293      	cmp	r3, r2
 800b8e6:	dc27      	bgt.n	800b938 <tcp_slowtmr+0x2c8>
 800b8e8:	697b      	ldr	r3, [r7, #20]
 800b8ea:	b21a      	sxth	r2, r3
 800b8ec:	e025      	b.n	800b93a <tcp_slowtmr+0x2ca>
 800b8ee:	46c0      	nop			; (mov r8, r8)
 800b8f0:	20002b40 	.word	0x20002b40
 800b8f4:	20001792 	.word	0x20001792
 800b8f8:	20002b3c 	.word	0x20002b3c
 800b8fc:	0801fe58 	.word	0x0801fe58
 800b900:	000004bf 	.word	0x000004bf
 800b904:	08020198 	.word	0x08020198
 800b908:	0801fe94 	.word	0x0801fe94
 800b90c:	080201c4 	.word	0x080201c4
 800b910:	000004c1 	.word	0x000004c1
 800b914:	080201f0 	.word	0x080201f0
 800b918:	000004d5 	.word	0x000004d5
 800b91c:	08020220 	.word	0x08020220
 800b920:	000004d6 	.word	0x000004d6
 800b924:	08020254 	.word	0x08020254
 800b928:	08022848 	.word	0x08022848
 800b92c:	00007fff 	.word	0x00007fff
 800b930:	08022838 	.word	0x08022838
 800b934:	00007ffe 	.word	0x00007ffe
 800b938:	4ad0      	ldr	r2, [pc, #832]	; (800bc7c <tcp_slowtmr+0x60c>)
 800b93a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b93c:	2144      	movs	r1, #68	; 0x44
 800b93e:	525a      	strh	r2, [r3, r1]
            }

            /* Reset the retransmission timer. */
            pcb->rtime = 0;
 800b940:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b942:	2200      	movs	r2, #0
 800b944:	869a      	strh	r2, [r3, #52]	; 0x34

            /* Reduce congestion window and ssthresh. */
            eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
 800b946:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b948:	2264      	movs	r2, #100	; 0x64
 800b94a:	5a99      	ldrh	r1, [r3, r2]
 800b94c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b94e:	224c      	movs	r2, #76	; 0x4c
 800b950:	5a9b      	ldrh	r3, [r3, r2]
 800b952:	2212      	movs	r2, #18
 800b954:	18ba      	adds	r2, r7, r2
 800b956:	1c1c      	adds	r4, r3, #0
 800b958:	1c0b      	adds	r3, r1, #0
 800b95a:	b298      	uxth	r0, r3
 800b95c:	b2a1      	uxth	r1, r4
 800b95e:	4288      	cmp	r0, r1
 800b960:	d900      	bls.n	800b964 <tcp_slowtmr+0x2f4>
 800b962:	1c23      	adds	r3, r4, #0
 800b964:	8013      	strh	r3, [r2, #0]
            pcb->ssthresh = eff_wnd >> 1;
 800b966:	2312      	movs	r3, #18
 800b968:	18fb      	adds	r3, r7, r3
 800b96a:	881b      	ldrh	r3, [r3, #0]
 800b96c:	085b      	lsrs	r3, r3, #1
 800b96e:	b299      	uxth	r1, r3
 800b970:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b972:	224e      	movs	r2, #78	; 0x4e
 800b974:	5299      	strh	r1, [r3, r2]
            if (pcb->ssthresh < (tcpwnd_size_t)(pcb->mss << 1)) {
 800b976:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b978:	224e      	movs	r2, #78	; 0x4e
 800b97a:	5a9a      	ldrh	r2, [r3, r2]
 800b97c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b97e:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800b980:	18db      	adds	r3, r3, r3
 800b982:	b29b      	uxth	r3, r3
 800b984:	429a      	cmp	r2, r3
 800b986:	d206      	bcs.n	800b996 <tcp_slowtmr+0x326>
              pcb->ssthresh = (tcpwnd_size_t)(pcb->mss << 1);
 800b988:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b98a:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800b98c:	18db      	adds	r3, r3, r3
 800b98e:	b299      	uxth	r1, r3
 800b990:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b992:	224e      	movs	r2, #78	; 0x4e
 800b994:	5299      	strh	r1, [r3, r2]
            }
            pcb->cwnd = pcb->mss;
 800b996:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b998:	8ed9      	ldrh	r1, [r3, #54]	; 0x36
 800b99a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b99c:	224c      	movs	r2, #76	; 0x4c
 800b99e:	5299      	strh	r1, [r3, r2]
            LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: cwnd %"TCPWNDSIZE_F
                                         " ssthresh %"TCPWNDSIZE_F"\n",
                                         pcb->cwnd, pcb->ssthresh));
            pcb->bytes_acked = 0;
 800b9a0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b9a2:	226e      	movs	r2, #110	; 0x6e
 800b9a4:	2100      	movs	r1, #0
 800b9a6:	5299      	strh	r1, [r3, r2]

            /* The following needs to be called AFTER cwnd is set to one
               mss - STJ */
            tcp_rexmit_rto_commit(pcb);
 800b9a8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b9aa:	0018      	movs	r0, r3
 800b9ac:	f005 fec8 	bl	8011740 <tcp_rexmit_rto_commit>
          }
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
 800b9b0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b9b2:	7e1b      	ldrb	r3, [r3, #24]
 800b9b4:	2b06      	cmp	r3, #6
 800b9b6:	d112      	bne.n	800b9de <tcp_slowtmr+0x36e>
      /* If this PCB is in FIN_WAIT_2 because of SHUT_WR don't let it time out. */
      if (pcb->flags & TF_RXCLOSED) {
 800b9b8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b9ba:	8bdb      	ldrh	r3, [r3, #30]
 800b9bc:	001a      	movs	r2, r3
 800b9be:	2310      	movs	r3, #16
 800b9c0:	4013      	ands	r3, r2
 800b9c2:	d00c      	beq.n	800b9de <tcp_slowtmr+0x36e>
        /* PCB was fully closed (either through close() or SHUT_RDWR):
           normal FIN-WAIT timeout handling. */
        if ((u32_t)(tcp_ticks - pcb->tmr) >
 800b9c4:	4bae      	ldr	r3, [pc, #696]	; (800bc80 <tcp_slowtmr+0x610>)
 800b9c6:	681a      	ldr	r2, [r3, #0]
 800b9c8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b9ca:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b9cc:	1ad3      	subs	r3, r2, r3
 800b9ce:	2b14      	cmp	r3, #20
 800b9d0:	d905      	bls.n	800b9de <tcp_slowtmr+0x36e>
            TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
          ++pcb_remove;
 800b9d2:	2227      	movs	r2, #39	; 0x27
 800b9d4:	18bb      	adds	r3, r7, r2
 800b9d6:	18ba      	adds	r2, r7, r2
 800b9d8:	7812      	ldrb	r2, [r2, #0]
 800b9da:	3201      	adds	r2, #1
 800b9dc:	701a      	strb	r2, [r3, #0]
        }
      }
    }

    /* Check if KEEPALIVE should be sent */
    if (ip_get_option(pcb, SOF_KEEPALIVE) &&
 800b9de:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b9e0:	7a5b      	ldrb	r3, [r3, #9]
 800b9e2:	001a      	movs	r2, r3
 800b9e4:	2308      	movs	r3, #8
 800b9e6:	4013      	ands	r3, r2
 800b9e8:	d05a      	beq.n	800baa0 <tcp_slowtmr+0x430>
        ((pcb->state == ESTABLISHED) ||
 800b9ea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b9ec:	7e1b      	ldrb	r3, [r3, #24]
    if (ip_get_option(pcb, SOF_KEEPALIVE) &&
 800b9ee:	2b04      	cmp	r3, #4
 800b9f0:	d003      	beq.n	800b9fa <tcp_slowtmr+0x38a>
         (pcb->state == CLOSE_WAIT))) {
 800b9f2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b9f4:	7e1b      	ldrb	r3, [r3, #24]
        ((pcb->state == ESTABLISHED) ||
 800b9f6:	2b07      	cmp	r3, #7
 800b9f8:	d152      	bne.n	800baa0 <tcp_slowtmr+0x430>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 800b9fa:	4ba1      	ldr	r3, [pc, #644]	; (800bc80 <tcp_slowtmr+0x610>)
 800b9fc:	681a      	ldr	r2, [r3, #0]
 800b9fe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ba00:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ba02:	1ad4      	subs	r4, r2, r3
          (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL) {
 800ba04:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ba06:	2298      	movs	r2, #152	; 0x98
 800ba08:	589a      	ldr	r2, [r3, r2]
 800ba0a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ba0c:	21a0      	movs	r1, #160	; 0xa0
 800ba0e:	585b      	ldr	r3, [r3, r1]
 800ba10:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800ba12:	209c      	movs	r0, #156	; 0x9c
 800ba14:	5809      	ldr	r1, [r1, r0]
 800ba16:	434b      	muls	r3, r1
 800ba18:	18d3      	adds	r3, r2, r3
 800ba1a:	22fa      	movs	r2, #250	; 0xfa
 800ba1c:	0091      	lsls	r1, r2, #2
 800ba1e:	0018      	movs	r0, r3
 800ba20:	f7f4 fb84 	bl	800012c <__udivsi3>
 800ba24:	0003      	movs	r3, r0
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 800ba26:	429c      	cmp	r4, r3
 800ba28:	d90c      	bls.n	800ba44 <tcp_slowtmr+0x3d4>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to "));
        ip_addr_debug_print_val(TCP_DEBUG, pcb->remote_ip);
        LWIP_DEBUGF(TCP_DEBUG, ("\n"));

        ++pcb_remove;
 800ba2a:	2227      	movs	r2, #39	; 0x27
 800ba2c:	18bb      	adds	r3, r7, r2
 800ba2e:	18ba      	adds	r2, r7, r2
 800ba30:	7812      	ldrb	r2, [r2, #0]
 800ba32:	3201      	adds	r2, #1
 800ba34:	701a      	strb	r2, [r3, #0]
        ++pcb_reset;
 800ba36:	2226      	movs	r2, #38	; 0x26
 800ba38:	18bb      	adds	r3, r7, r2
 800ba3a:	18ba      	adds	r2, r7, r2
 800ba3c:	7812      	ldrb	r2, [r2, #0]
 800ba3e:	3201      	adds	r2, #1
 800ba40:	701a      	strb	r2, [r3, #0]
 800ba42:	e02d      	b.n	800baa0 <tcp_slowtmr+0x430>
      } else if ((u32_t)(tcp_ticks - pcb->tmr) >
 800ba44:	4b8e      	ldr	r3, [pc, #568]	; (800bc80 <tcp_slowtmr+0x610>)
 800ba46:	681a      	ldr	r2, [r3, #0]
 800ba48:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ba4a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ba4c:	1ad4      	subs	r4, r2, r3
                 (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
 800ba4e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ba50:	2298      	movs	r2, #152	; 0x98
 800ba52:	589a      	ldr	r2, [r3, r2]
 800ba54:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ba56:	21a7      	movs	r1, #167	; 0xa7
 800ba58:	5c5b      	ldrb	r3, [r3, r1]
 800ba5a:	0018      	movs	r0, r3
 800ba5c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ba5e:	219c      	movs	r1, #156	; 0x9c
 800ba60:	585b      	ldr	r3, [r3, r1]
 800ba62:	4343      	muls	r3, r0
 800ba64:	18d3      	adds	r3, r2, r3
                 / TCP_SLOW_INTERVAL) {
 800ba66:	22fa      	movs	r2, #250	; 0xfa
 800ba68:	0091      	lsls	r1, r2, #2
 800ba6a:	0018      	movs	r0, r3
 800ba6c:	f7f4 fb5e 	bl	800012c <__udivsi3>
 800ba70:	0003      	movs	r3, r0
      } else if ((u32_t)(tcp_ticks - pcb->tmr) >
 800ba72:	429c      	cmp	r4, r3
 800ba74:	d914      	bls.n	800baa0 <tcp_slowtmr+0x430>
        err = tcp_keepalive(pcb);
 800ba76:	2525      	movs	r5, #37	; 0x25
 800ba78:	197c      	adds	r4, r7, r5
 800ba7a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ba7c:	0018      	movs	r0, r3
 800ba7e:	f006 faa7 	bl	8011fd0 <tcp_keepalive>
 800ba82:	0003      	movs	r3, r0
 800ba84:	7023      	strb	r3, [r4, #0]
        if (err == ERR_OK) {
 800ba86:	197b      	adds	r3, r7, r5
 800ba88:	781b      	ldrb	r3, [r3, #0]
 800ba8a:	b25b      	sxtb	r3, r3
 800ba8c:	2b00      	cmp	r3, #0
 800ba8e:	d107      	bne.n	800baa0 <tcp_slowtmr+0x430>
          pcb->keep_cnt_sent++;
 800ba90:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ba92:	22a7      	movs	r2, #167	; 0xa7
 800ba94:	5c9b      	ldrb	r3, [r3, r2]
 800ba96:	3301      	adds	r3, #1
 800ba98:	b2d9      	uxtb	r1, r3
 800ba9a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ba9c:	22a7      	movs	r2, #167	; 0xa7
 800ba9e:	5499      	strb	r1, [r3, r2]

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL &&
 800baa0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800baa2:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800baa4:	2b00      	cmp	r3, #0
 800baa6:	d012      	beq.n	800bace <tcp_slowtmr+0x45e>
        (tcp_ticks - pcb->tmr >= (u32_t)pcb->rto * TCP_OOSEQ_TIMEOUT)) {
 800baa8:	4b75      	ldr	r3, [pc, #468]	; (800bc80 <tcp_slowtmr+0x610>)
 800baaa:	681a      	ldr	r2, [r3, #0]
 800baac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800baae:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800bab0:	1ad2      	subs	r2, r2, r3
 800bab2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bab4:	2144      	movs	r1, #68	; 0x44
 800bab6:	5e5b      	ldrsh	r3, [r3, r1]
 800bab8:	0019      	movs	r1, r3
 800baba:	000b      	movs	r3, r1
 800babc:	005b      	lsls	r3, r3, #1
 800babe:	185b      	adds	r3, r3, r1
 800bac0:	005b      	lsls	r3, r3, #1
    if (pcb->ooseq != NULL &&
 800bac2:	429a      	cmp	r2, r3
 800bac4:	d303      	bcc.n	800bace <tcp_slowtmr+0x45e>
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
      tcp_free_ooseq(pcb);
 800bac6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bac8:	0018      	movs	r0, r3
 800baca:	f000 fefb 	bl	800c8c4 <tcp_free_ooseq>
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
 800bace:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bad0:	7e1b      	ldrb	r3, [r3, #24]
 800bad2:	2b03      	cmp	r3, #3
 800bad4:	d10c      	bne.n	800baf0 <tcp_slowtmr+0x480>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 800bad6:	4b6a      	ldr	r3, [pc, #424]	; (800bc80 <tcp_slowtmr+0x610>)
 800bad8:	681a      	ldr	r2, [r3, #0]
 800bada:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800badc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800bade:	1ad3      	subs	r3, r2, r3
 800bae0:	2b14      	cmp	r3, #20
 800bae2:	d905      	bls.n	800baf0 <tcp_slowtmr+0x480>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
 800bae4:	2227      	movs	r2, #39	; 0x27
 800bae6:	18bb      	adds	r3, r7, r2
 800bae8:	18ba      	adds	r2, r7, r2
 800baea:	7812      	ldrb	r2, [r2, #0]
 800baec:	3201      	adds	r2, #1
 800baee:	701a      	strb	r2, [r3, #0]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
 800baf0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800baf2:	7e1b      	ldrb	r3, [r3, #24]
 800baf4:	2b09      	cmp	r3, #9
 800baf6:	d10c      	bne.n	800bb12 <tcp_slowtmr+0x4a2>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 800baf8:	4b61      	ldr	r3, [pc, #388]	; (800bc80 <tcp_slowtmr+0x610>)
 800bafa:	681a      	ldr	r2, [r3, #0]
 800bafc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bafe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800bb00:	1ad3      	subs	r3, r2, r3
 800bb02:	2b78      	cmp	r3, #120	; 0x78
 800bb04:	d905      	bls.n	800bb12 <tcp_slowtmr+0x4a2>
        ++pcb_remove;
 800bb06:	2227      	movs	r2, #39	; 0x27
 800bb08:	18bb      	adds	r3, r7, r2
 800bb0a:	18ba      	adds	r2, r7, r2
 800bb0c:	7812      	ldrb	r2, [r2, #0]
 800bb0e:	3201      	adds	r2, #1
 800bb10:	701a      	strb	r2, [r3, #0]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
 800bb12:	2327      	movs	r3, #39	; 0x27
 800bb14:	18fb      	adds	r3, r7, r3
 800bb16:	781b      	ldrb	r3, [r3, #0]
 800bb18:	2b00      	cmp	r3, #0
 800bb1a:	d063      	beq.n	800bbe4 <tcp_slowtmr+0x574>
      struct tcp_pcb *pcb2;
#if LWIP_CALLBACK_API
      tcp_err_fn err_fn = pcb->errf;
 800bb1c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bb1e:	2294      	movs	r2, #148	; 0x94
 800bb20:	589b      	ldr	r3, [r3, r2]
 800bb22:	60fb      	str	r3, [r7, #12]
#endif /* LWIP_CALLBACK_API */
      void *err_arg;
      enum tcp_state last_state;
      tcp_pcb_purge(pcb);
 800bb24:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bb26:	0018      	movs	r0, r3
 800bb28:	f000 fcfc 	bl	800c524 <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
 800bb2c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bb2e:	2b00      	cmp	r3, #0
 800bb30:	d00f      	beq.n	800bb52 <tcp_slowtmr+0x4e2>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
 800bb32:	4b54      	ldr	r3, [pc, #336]	; (800bc84 <tcp_slowtmr+0x614>)
 800bb34:	681b      	ldr	r3, [r3, #0]
 800bb36:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800bb38:	429a      	cmp	r2, r3
 800bb3a:	d105      	bne.n	800bb48 <tcp_slowtmr+0x4d8>
 800bb3c:	4b52      	ldr	r3, [pc, #328]	; (800bc88 <tcp_slowtmr+0x618>)
 800bb3e:	4a53      	ldr	r2, [pc, #332]	; (800bc8c <tcp_slowtmr+0x61c>)
 800bb40:	4953      	ldr	r1, [pc, #332]	; (800bc90 <tcp_slowtmr+0x620>)
 800bb42:	4854      	ldr	r0, [pc, #336]	; (800bc94 <tcp_slowtmr+0x624>)
 800bb44:	f7f7 f840 	bl	8002bc8 <app_debug_rtt_raw>
        prev->next = pcb->next;
 800bb48:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bb4a:	691a      	ldr	r2, [r3, #16]
 800bb4c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bb4e:	611a      	str	r2, [r3, #16]
 800bb50:	e00e      	b.n	800bb70 <tcp_slowtmr+0x500>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
 800bb52:	4b4c      	ldr	r3, [pc, #304]	; (800bc84 <tcp_slowtmr+0x614>)
 800bb54:	681b      	ldr	r3, [r3, #0]
 800bb56:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800bb58:	429a      	cmp	r2, r3
 800bb5a:	d005      	beq.n	800bb68 <tcp_slowtmr+0x4f8>
 800bb5c:	4b4a      	ldr	r3, [pc, #296]	; (800bc88 <tcp_slowtmr+0x618>)
 800bb5e:	4a4e      	ldr	r2, [pc, #312]	; (800bc98 <tcp_slowtmr+0x628>)
 800bb60:	494e      	ldr	r1, [pc, #312]	; (800bc9c <tcp_slowtmr+0x62c>)
 800bb62:	484c      	ldr	r0, [pc, #304]	; (800bc94 <tcp_slowtmr+0x624>)
 800bb64:	f7f7 f830 	bl	8002bc8 <app_debug_rtt_raw>
        tcp_active_pcbs = pcb->next;
 800bb68:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bb6a:	691a      	ldr	r2, [r3, #16]
 800bb6c:	4b45      	ldr	r3, [pc, #276]	; (800bc84 <tcp_slowtmr+0x614>)
 800bb6e:	601a      	str	r2, [r3, #0]
      }

      if (pcb_reset) {
 800bb70:	2326      	movs	r3, #38	; 0x26
 800bb72:	18fb      	adds	r3, r7, r3
 800bb74:	781b      	ldrb	r3, [r3, #0]
 800bb76:	2b00      	cmp	r3, #0
 800bb78:	d013      	beq.n	800bba2 <tcp_slowtmr+0x532>
        tcp_rst(pcb, pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 800bb7a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bb7c:	6d5c      	ldr	r4, [r3, #84]	; 0x54
 800bb7e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bb80:	6a9d      	ldr	r5, [r3, #40]	; 0x28
 800bb82:	6afe      	ldr	r6, [r7, #44]	; 0x2c
 800bb84:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bb86:	3304      	adds	r3, #4
 800bb88:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800bb8a:	8b52      	ldrh	r2, [r2, #26]
 800bb8c:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800bb8e:	8b89      	ldrh	r1, [r1, #28]
 800bb90:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800bb92:	9102      	str	r1, [sp, #8]
 800bb94:	9201      	str	r2, [sp, #4]
 800bb96:	9300      	str	r3, [sp, #0]
 800bb98:	0033      	movs	r3, r6
 800bb9a:	002a      	movs	r2, r5
 800bb9c:	0021      	movs	r1, r4
 800bb9e:	f006 f941 	bl	8011e24 <tcp_rst>
                pcb->local_port, pcb->remote_port);
      }

      err_arg = pcb->callback_arg;
 800bba2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bba4:	695b      	ldr	r3, [r3, #20]
 800bba6:	60bb      	str	r3, [r7, #8]
      last_state = pcb->state;
 800bba8:	1dfb      	adds	r3, r7, #7
 800bbaa:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800bbac:	7e12      	ldrb	r2, [r2, #24]
 800bbae:	701a      	strb	r2, [r3, #0]
      pcb2 = pcb;
 800bbb0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bbb2:	603b      	str	r3, [r7, #0]
      pcb = pcb->next;
 800bbb4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bbb6:	691b      	ldr	r3, [r3, #16]
 800bbb8:	62fb      	str	r3, [r7, #44]	; 0x2c
      tcp_free(pcb2);
 800bbba:	683b      	ldr	r3, [r7, #0]
 800bbbc:	0018      	movs	r0, r3
 800bbbe:	f7fe ffd3 	bl	800ab68 <tcp_free>

      tcp_active_pcbs_changed = 0;
 800bbc2:	4b37      	ldr	r3, [pc, #220]	; (800bca0 <tcp_slowtmr+0x630>)
 800bbc4:	2200      	movs	r2, #0
 800bbc6:	701a      	strb	r2, [r3, #0]
      TCP_EVENT_ERR(last_state, err_fn, err_arg, ERR_ABRT);
 800bbc8:	68fb      	ldr	r3, [r7, #12]
 800bbca:	2b00      	cmp	r3, #0
 800bbcc:	d005      	beq.n	800bbda <tcp_slowtmr+0x56a>
 800bbce:	230d      	movs	r3, #13
 800bbd0:	4259      	negs	r1, r3
 800bbd2:	68ba      	ldr	r2, [r7, #8]
 800bbd4:	68fb      	ldr	r3, [r7, #12]
 800bbd6:	0010      	movs	r0, r2
 800bbd8:	4798      	blx	r3
      if (tcp_active_pcbs_changed) {
 800bbda:	4b31      	ldr	r3, [pc, #196]	; (800bca0 <tcp_slowtmr+0x630>)
 800bbdc:	781b      	ldrb	r3, [r3, #0]
 800bbde:	2b00      	cmp	r3, #0
 800bbe0:	d041      	beq.n	800bc66 <tcp_slowtmr+0x5f6>
        goto tcp_slowtmr_start;
 800bbe2:	e557      	b.n	800b694 <tcp_slowtmr+0x24>
      }
    } else {
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
 800bbe4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bbe6:	62bb      	str	r3, [r7, #40]	; 0x28
      pcb = pcb->next;
 800bbe8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bbea:	691b      	ldr	r3, [r3, #16]
 800bbec:	62fb      	str	r3, [r7, #44]	; 0x2c

      /* We check if we should poll the connection. */
      ++prev->polltmr;
 800bbee:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bbf0:	2220      	movs	r2, #32
 800bbf2:	5c9b      	ldrb	r3, [r3, r2]
 800bbf4:	3301      	adds	r3, #1
 800bbf6:	b2d9      	uxtb	r1, r3
 800bbf8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bbfa:	2220      	movs	r2, #32
 800bbfc:	5499      	strb	r1, [r3, r2]
      if (prev->polltmr >= prev->pollinterval) {
 800bbfe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bc00:	2220      	movs	r2, #32
 800bc02:	5c9a      	ldrb	r2, [r3, r2]
 800bc04:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bc06:	2121      	movs	r1, #33	; 0x21
 800bc08:	5c5b      	ldrb	r3, [r3, r1]
 800bc0a:	429a      	cmp	r2, r3
 800bc0c:	d32b      	bcc.n	800bc66 <tcp_slowtmr+0x5f6>
        prev->polltmr = 0;
 800bc0e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bc10:	2220      	movs	r2, #32
 800bc12:	2100      	movs	r1, #0
 800bc14:	5499      	strb	r1, [r3, r2]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        tcp_active_pcbs_changed = 0;
 800bc16:	4b22      	ldr	r3, [pc, #136]	; (800bca0 <tcp_slowtmr+0x630>)
 800bc18:	2200      	movs	r2, #0
 800bc1a:	701a      	strb	r2, [r3, #0]
        TCP_EVENT_POLL(prev, err);
 800bc1c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bc1e:	2290      	movs	r2, #144	; 0x90
 800bc20:	589b      	ldr	r3, [r3, r2]
 800bc22:	2b00      	cmp	r3, #0
 800bc24:	d00c      	beq.n	800bc40 <tcp_slowtmr+0x5d0>
 800bc26:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bc28:	2290      	movs	r2, #144	; 0x90
 800bc2a:	589a      	ldr	r2, [r3, r2]
 800bc2c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bc2e:	695b      	ldr	r3, [r3, #20]
 800bc30:	2125      	movs	r1, #37	; 0x25
 800bc32:	187c      	adds	r4, r7, r1
 800bc34:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800bc36:	0018      	movs	r0, r3
 800bc38:	4790      	blx	r2
 800bc3a:	0003      	movs	r3, r0
 800bc3c:	7023      	strb	r3, [r4, #0]
 800bc3e:	e003      	b.n	800bc48 <tcp_slowtmr+0x5d8>
 800bc40:	2325      	movs	r3, #37	; 0x25
 800bc42:	18fb      	adds	r3, r7, r3
 800bc44:	2200      	movs	r2, #0
 800bc46:	701a      	strb	r2, [r3, #0]
        if (tcp_active_pcbs_changed) {
 800bc48:	4b15      	ldr	r3, [pc, #84]	; (800bca0 <tcp_slowtmr+0x630>)
 800bc4a:	781b      	ldrb	r3, [r3, #0]
 800bc4c:	2b00      	cmp	r3, #0
 800bc4e:	d000      	beq.n	800bc52 <tcp_slowtmr+0x5e2>
          goto tcp_slowtmr_start;
 800bc50:	e520      	b.n	800b694 <tcp_slowtmr+0x24>
        }
        /* if err == ERR_ABRT, 'prev' is already deallocated */
        if (err == ERR_OK) {
 800bc52:	2325      	movs	r3, #37	; 0x25
 800bc54:	18fb      	adds	r3, r7, r3
 800bc56:	781b      	ldrb	r3, [r3, #0]
 800bc58:	b25b      	sxtb	r3, r3
 800bc5a:	2b00      	cmp	r3, #0
 800bc5c:	d103      	bne.n	800bc66 <tcp_slowtmr+0x5f6>
          tcp_output(prev);
 800bc5e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bc60:	0018      	movs	r0, r3
 800bc62:	f005 f88b 	bl	8010d7c <tcp_output>
  while (pcb != NULL) {
 800bc66:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bc68:	2b00      	cmp	r3, #0
 800bc6a:	d000      	beq.n	800bc6e <tcp_slowtmr+0x5fe>
 800bc6c:	e518      	b.n	800b6a0 <tcp_slowtmr+0x30>
    }
  }


  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
 800bc6e:	2300      	movs	r3, #0
 800bc70:	62bb      	str	r3, [r7, #40]	; 0x28
  pcb = tcp_tw_pcbs;
 800bc72:	4b0c      	ldr	r3, [pc, #48]	; (800bca4 <tcp_slowtmr+0x634>)
 800bc74:	681b      	ldr	r3, [r3, #0]
 800bc76:	62fb      	str	r3, [r7, #44]	; 0x2c
  while (pcb != NULL) {
 800bc78:	e06b      	b.n	800bd52 <tcp_slowtmr+0x6e2>
 800bc7a:	46c0      	nop			; (mov r8, r8)
 800bc7c:	00007fff 	.word	0x00007fff
 800bc80:	20002b40 	.word	0x20002b40
 800bc84:	20002b3c 	.word	0x20002b3c
 800bc88:	0801fe58 	.word	0x0801fe58
 800bc8c:	0000056e 	.word	0x0000056e
 800bc90:	0802028c 	.word	0x0802028c
 800bc94:	0801fe94 	.word	0x0801fe94
 800bc98:	00000572 	.word	0x00000572
 800bc9c:	080202b8 	.word	0x080202b8
 800bca0:	20002b38 	.word	0x20002b38
 800bca4:	20002b4c 	.word	0x20002b4c
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 800bca8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bcaa:	7e1b      	ldrb	r3, [r3, #24]
 800bcac:	2b0a      	cmp	r3, #10
 800bcae:	d005      	beq.n	800bcbc <tcp_slowtmr+0x64c>
 800bcb0:	4b2c      	ldr	r3, [pc, #176]	; (800bd64 <tcp_slowtmr+0x6f4>)
 800bcb2:	4a2d      	ldr	r2, [pc, #180]	; (800bd68 <tcp_slowtmr+0x6f8>)
 800bcb4:	492d      	ldr	r1, [pc, #180]	; (800bd6c <tcp_slowtmr+0x6fc>)
 800bcb6:	482e      	ldr	r0, [pc, #184]	; (800bd70 <tcp_slowtmr+0x700>)
 800bcb8:	f7f6 ff86 	bl	8002bc8 <app_debug_rtt_raw>
    pcb_remove = 0;
 800bcbc:	2127      	movs	r1, #39	; 0x27
 800bcbe:	187b      	adds	r3, r7, r1
 800bcc0:	2200      	movs	r2, #0
 800bcc2:	701a      	strb	r2, [r3, #0]

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 800bcc4:	4b2b      	ldr	r3, [pc, #172]	; (800bd74 <tcp_slowtmr+0x704>)
 800bcc6:	681a      	ldr	r2, [r3, #0]
 800bcc8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bcca:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800bccc:	1ad3      	subs	r3, r2, r3
 800bcce:	2b78      	cmp	r3, #120	; 0x78
 800bcd0:	d904      	bls.n	800bcdc <tcp_slowtmr+0x66c>
      ++pcb_remove;
 800bcd2:	187b      	adds	r3, r7, r1
 800bcd4:	187a      	adds	r2, r7, r1
 800bcd6:	7812      	ldrb	r2, [r2, #0]
 800bcd8:	3201      	adds	r2, #1
 800bcda:	701a      	strb	r2, [r3, #0]
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
 800bcdc:	2327      	movs	r3, #39	; 0x27
 800bcde:	18fb      	adds	r3, r7, r3
 800bce0:	781b      	ldrb	r3, [r3, #0]
 800bce2:	2b00      	cmp	r3, #0
 800bce4:	d030      	beq.n	800bd48 <tcp_slowtmr+0x6d8>
      struct tcp_pcb *pcb2;
      tcp_pcb_purge(pcb);
 800bce6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bce8:	0018      	movs	r0, r3
 800bcea:	f000 fc1b 	bl	800c524 <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
 800bcee:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bcf0:	2b00      	cmp	r3, #0
 800bcf2:	d010      	beq.n	800bd16 <tcp_slowtmr+0x6a6>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
 800bcf4:	4b20      	ldr	r3, [pc, #128]	; (800bd78 <tcp_slowtmr+0x708>)
 800bcf6:	681b      	ldr	r3, [r3, #0]
 800bcf8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800bcfa:	429a      	cmp	r2, r3
 800bcfc:	d106      	bne.n	800bd0c <tcp_slowtmr+0x69c>
 800bcfe:	4b19      	ldr	r3, [pc, #100]	; (800bd64 <tcp_slowtmr+0x6f4>)
 800bd00:	22b6      	movs	r2, #182	; 0xb6
 800bd02:	00d2      	lsls	r2, r2, #3
 800bd04:	491d      	ldr	r1, [pc, #116]	; (800bd7c <tcp_slowtmr+0x70c>)
 800bd06:	481a      	ldr	r0, [pc, #104]	; (800bd70 <tcp_slowtmr+0x700>)
 800bd08:	f7f6 ff5e 	bl	8002bc8 <app_debug_rtt_raw>
        prev->next = pcb->next;
 800bd0c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bd0e:	691a      	ldr	r2, [r3, #16]
 800bd10:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bd12:	611a      	str	r2, [r3, #16]
 800bd14:	e00e      	b.n	800bd34 <tcp_slowtmr+0x6c4>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
 800bd16:	4b18      	ldr	r3, [pc, #96]	; (800bd78 <tcp_slowtmr+0x708>)
 800bd18:	681b      	ldr	r3, [r3, #0]
 800bd1a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800bd1c:	429a      	cmp	r2, r3
 800bd1e:	d005      	beq.n	800bd2c <tcp_slowtmr+0x6bc>
 800bd20:	4b10      	ldr	r3, [pc, #64]	; (800bd64 <tcp_slowtmr+0x6f4>)
 800bd22:	4a17      	ldr	r2, [pc, #92]	; (800bd80 <tcp_slowtmr+0x710>)
 800bd24:	4917      	ldr	r1, [pc, #92]	; (800bd84 <tcp_slowtmr+0x714>)
 800bd26:	4812      	ldr	r0, [pc, #72]	; (800bd70 <tcp_slowtmr+0x700>)
 800bd28:	f7f6 ff4e 	bl	8002bc8 <app_debug_rtt_raw>
        tcp_tw_pcbs = pcb->next;
 800bd2c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bd2e:	691a      	ldr	r2, [r3, #16]
 800bd30:	4b11      	ldr	r3, [pc, #68]	; (800bd78 <tcp_slowtmr+0x708>)
 800bd32:	601a      	str	r2, [r3, #0]
      }
      pcb2 = pcb;
 800bd34:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bd36:	61fb      	str	r3, [r7, #28]
      pcb = pcb->next;
 800bd38:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bd3a:	691b      	ldr	r3, [r3, #16]
 800bd3c:	62fb      	str	r3, [r7, #44]	; 0x2c
      tcp_free(pcb2);
 800bd3e:	69fb      	ldr	r3, [r7, #28]
 800bd40:	0018      	movs	r0, r3
 800bd42:	f7fe ff11 	bl	800ab68 <tcp_free>
 800bd46:	e004      	b.n	800bd52 <tcp_slowtmr+0x6e2>
    } else {
      prev = pcb;
 800bd48:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bd4a:	62bb      	str	r3, [r7, #40]	; 0x28
      pcb = pcb->next;
 800bd4c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bd4e:	691b      	ldr	r3, [r3, #16]
 800bd50:	62fb      	str	r3, [r7, #44]	; 0x2c
  while (pcb != NULL) {
 800bd52:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bd54:	2b00      	cmp	r3, #0
 800bd56:	d1a7      	bne.n	800bca8 <tcp_slowtmr+0x638>
    }
  }
}
 800bd58:	46c0      	nop			; (mov r8, r8)
 800bd5a:	46c0      	nop			; (mov r8, r8)
 800bd5c:	46bd      	mov	sp, r7
 800bd5e:	b00d      	add	sp, #52	; 0x34
 800bd60:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800bd62:	46c0      	nop			; (mov r8, r8)
 800bd64:	0801fe58 	.word	0x0801fe58
 800bd68:	000005a2 	.word	0x000005a2
 800bd6c:	080202e4 	.word	0x080202e4
 800bd70:	0801fe94 	.word	0x0801fe94
 800bd74:	20002b40 	.word	0x20002b40
 800bd78:	20002b4c 	.word	0x20002b4c
 800bd7c:	08020314 	.word	0x08020314
 800bd80:	000005b4 	.word	0x000005b4
 800bd84:	0802033c 	.word	0x0802033c

0800bd88 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
 800bd88:	b580      	push	{r7, lr}
 800bd8a:	b082      	sub	sp, #8
 800bd8c:	af00      	add	r7, sp, #0
  struct tcp_pcb *pcb;

  ++tcp_timer_ctr;
 800bd8e:	4b30      	ldr	r3, [pc, #192]	; (800be50 <tcp_fasttmr+0xc8>)
 800bd90:	781b      	ldrb	r3, [r3, #0]
 800bd92:	3301      	adds	r3, #1
 800bd94:	b2da      	uxtb	r2, r3
 800bd96:	4b2e      	ldr	r3, [pc, #184]	; (800be50 <tcp_fasttmr+0xc8>)
 800bd98:	701a      	strb	r2, [r3, #0]

tcp_fasttmr_start:
  pcb = tcp_active_pcbs;
 800bd9a:	4b2e      	ldr	r3, [pc, #184]	; (800be54 <tcp_fasttmr+0xcc>)
 800bd9c:	681b      	ldr	r3, [r3, #0]
 800bd9e:	607b      	str	r3, [r7, #4]

  while (pcb != NULL) {
 800bda0:	e04d      	b.n	800be3e <tcp_fasttmr+0xb6>
    if (pcb->last_timer != tcp_timer_ctr) {
 800bda2:	687b      	ldr	r3, [r7, #4]
 800bda4:	2222      	movs	r2, #34	; 0x22
 800bda6:	5c9a      	ldrb	r2, [r3, r2]
 800bda8:	4b29      	ldr	r3, [pc, #164]	; (800be50 <tcp_fasttmr+0xc8>)
 800bdaa:	781b      	ldrb	r3, [r3, #0]
 800bdac:	429a      	cmp	r2, r3
 800bdae:	d043      	beq.n	800be38 <tcp_fasttmr+0xb0>
      struct tcp_pcb *next;
      pcb->last_timer = tcp_timer_ctr;
 800bdb0:	4b27      	ldr	r3, [pc, #156]	; (800be50 <tcp_fasttmr+0xc8>)
 800bdb2:	7819      	ldrb	r1, [r3, #0]
 800bdb4:	687b      	ldr	r3, [r7, #4]
 800bdb6:	2222      	movs	r2, #34	; 0x22
 800bdb8:	5499      	strb	r1, [r3, r2]
      /* send delayed ACKs */
      if (pcb->flags & TF_ACK_DELAY) {
 800bdba:	687b      	ldr	r3, [r7, #4]
 800bdbc:	8bdb      	ldrh	r3, [r3, #30]
 800bdbe:	001a      	movs	r2, r3
 800bdc0:	2301      	movs	r3, #1
 800bdc2:	4013      	ands	r3, r2
 800bdc4:	d011      	beq.n	800bdea <tcp_fasttmr+0x62>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
        tcp_ack_now(pcb);
 800bdc6:	687b      	ldr	r3, [r7, #4]
 800bdc8:	8bdb      	ldrh	r3, [r3, #30]
 800bdca:	2202      	movs	r2, #2
 800bdcc:	4313      	orrs	r3, r2
 800bdce:	b29a      	uxth	r2, r3
 800bdd0:	687b      	ldr	r3, [r7, #4]
 800bdd2:	83da      	strh	r2, [r3, #30]
        tcp_output(pcb);
 800bdd4:	687b      	ldr	r3, [r7, #4]
 800bdd6:	0018      	movs	r0, r3
 800bdd8:	f004 ffd0 	bl	8010d7c <tcp_output>
        tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 800bddc:	687b      	ldr	r3, [r7, #4]
 800bdde:	8bdb      	ldrh	r3, [r3, #30]
 800bde0:	2203      	movs	r2, #3
 800bde2:	4393      	bics	r3, r2
 800bde4:	b29a      	uxth	r2, r3
 800bde6:	687b      	ldr	r3, [r7, #4]
 800bde8:	83da      	strh	r2, [r3, #30]
      }
      /* send pending FIN */
      if (pcb->flags & TF_CLOSEPEND) {
 800bdea:	687b      	ldr	r3, [r7, #4]
 800bdec:	8bdb      	ldrh	r3, [r3, #30]
 800bdee:	001a      	movs	r2, r3
 800bdf0:	2308      	movs	r3, #8
 800bdf2:	4013      	ands	r3, r2
 800bdf4:	d00a      	beq.n	800be0c <tcp_fasttmr+0x84>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: pending FIN\n"));
        tcp_clear_flags(pcb, TF_CLOSEPEND);
 800bdf6:	687b      	ldr	r3, [r7, #4]
 800bdf8:	8bdb      	ldrh	r3, [r3, #30]
 800bdfa:	2208      	movs	r2, #8
 800bdfc:	4393      	bics	r3, r2
 800bdfe:	b29a      	uxth	r2, r3
 800be00:	687b      	ldr	r3, [r7, #4]
 800be02:	83da      	strh	r2, [r3, #30]
        tcp_close_shutdown_fin(pcb);
 800be04:	687b      	ldr	r3, [r7, #4]
 800be06:	0018      	movs	r0, r3
 800be08:	f7ff f85a 	bl	800aec0 <tcp_close_shutdown_fin>
      }

      next = pcb->next;
 800be0c:	687b      	ldr	r3, [r7, #4]
 800be0e:	691b      	ldr	r3, [r3, #16]
 800be10:	603b      	str	r3, [r7, #0]

      /* If there is data which was previously "refused" by upper layer */
      if (pcb->refused_data != NULL) {
 800be12:	687b      	ldr	r3, [r7, #4]
 800be14:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800be16:	2b00      	cmp	r3, #0
 800be18:	d00b      	beq.n	800be32 <tcp_fasttmr+0xaa>
        tcp_active_pcbs_changed = 0;
 800be1a:	4b0f      	ldr	r3, [pc, #60]	; (800be58 <tcp_fasttmr+0xd0>)
 800be1c:	2200      	movs	r2, #0
 800be1e:	701a      	strb	r2, [r3, #0]
        tcp_process_refused_data(pcb);
 800be20:	687b      	ldr	r3, [r7, #4]
 800be22:	0018      	movs	r0, r3
 800be24:	f000 f81a 	bl	800be5c <tcp_process_refused_data>
        if (tcp_active_pcbs_changed) {
 800be28:	4b0b      	ldr	r3, [pc, #44]	; (800be58 <tcp_fasttmr+0xd0>)
 800be2a:	781b      	ldrb	r3, [r3, #0]
 800be2c:	2b00      	cmp	r3, #0
 800be2e:	d000      	beq.n	800be32 <tcp_fasttmr+0xaa>
          /* application callback has changed the pcb list: restart the loop */
          goto tcp_fasttmr_start;
 800be30:	e7b3      	b.n	800bd9a <tcp_fasttmr+0x12>
        }
      }
      pcb = next;
 800be32:	683b      	ldr	r3, [r7, #0]
 800be34:	607b      	str	r3, [r7, #4]
 800be36:	e002      	b.n	800be3e <tcp_fasttmr+0xb6>
    } else {
      pcb = pcb->next;
 800be38:	687b      	ldr	r3, [r7, #4]
 800be3a:	691b      	ldr	r3, [r3, #16]
 800be3c:	607b      	str	r3, [r7, #4]
  while (pcb != NULL) {
 800be3e:	687b      	ldr	r3, [r7, #4]
 800be40:	2b00      	cmp	r3, #0
 800be42:	d1ae      	bne.n	800bda2 <tcp_fasttmr+0x1a>
    }
  }
}
 800be44:	46c0      	nop			; (mov r8, r8)
 800be46:	46c0      	nop			; (mov r8, r8)
 800be48:	46bd      	mov	sp, r7
 800be4a:	b002      	add	sp, #8
 800be4c:	bd80      	pop	{r7, pc}
 800be4e:	46c0      	nop			; (mov r8, r8)
 800be50:	20001792 	.word	0x20001792
 800be54:	20002b3c 	.word	0x20002b3c
 800be58:	20002b38 	.word	0x20002b38

0800be5c <tcp_process_refused_data>:
}

/** Pass pcb->refused_data to the recv callback */
err_t
tcp_process_refused_data(struct tcp_pcb *pcb)
{
 800be5c:	b5b0      	push	{r4, r5, r7, lr}
 800be5e:	b084      	sub	sp, #16
 800be60:	af00      	add	r7, sp, #0
 800be62:	6078      	str	r0, [r7, #4]
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
  struct pbuf *rest;
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */

  LWIP_ERROR("tcp_process_refused_data: invalid pcb", pcb != NULL, return ERR_ARG);
 800be64:	687b      	ldr	r3, [r7, #4]
 800be66:	2b00      	cmp	r3, #0
 800be68:	d106      	bne.n	800be78 <tcp_process_refused_data+0x1c>
 800be6a:	4b3e      	ldr	r3, [pc, #248]	; (800bf64 <tcp_process_refused_data+0x108>)
 800be6c:	0018      	movs	r0, r3
 800be6e:	f7f6 feab 	bl	8002bc8 <app_debug_rtt_raw>
 800be72:	2310      	movs	r3, #16
 800be74:	425b      	negs	r3, r3
 800be76:	e070      	b.n	800bf5a <tcp_process_refused_data+0xfe>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
  while (pcb->refused_data != NULL)
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
  {
    err_t err;
    u8_t refused_flags = pcb->refused_data->flags;
 800be78:	687b      	ldr	r3, [r7, #4]
 800be7a:	6fda      	ldr	r2, [r3, #124]	; 0x7c
 800be7c:	230e      	movs	r3, #14
 800be7e:	18fb      	adds	r3, r7, r3
 800be80:	7b52      	ldrb	r2, [r2, #13]
 800be82:	701a      	strb	r2, [r3, #0]
    /* set pcb->refused_data to NULL in case the callback frees it and then
       closes the pcb */
    struct pbuf *refused_data = pcb->refused_data;
 800be84:	687b      	ldr	r3, [r7, #4]
 800be86:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800be88:	60bb      	str	r3, [r7, #8]
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
    pbuf_split_64k(refused_data, &rest);
    pcb->refused_data = rest;
#else /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
    pcb->refused_data = NULL;
 800be8a:	687b      	ldr	r3, [r7, #4]
 800be8c:	2200      	movs	r2, #0
 800be8e:	67da      	str	r2, [r3, #124]	; 0x7c
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
    /* Notify again application with data previously received. */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
    TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 800be90:	687b      	ldr	r3, [r7, #4]
 800be92:	2288      	movs	r2, #136	; 0x88
 800be94:	589b      	ldr	r3, [r3, r2]
 800be96:	2b00      	cmp	r3, #0
 800be98:	d00d      	beq.n	800beb6 <tcp_process_refused_data+0x5a>
 800be9a:	687b      	ldr	r3, [r7, #4]
 800be9c:	2288      	movs	r2, #136	; 0x88
 800be9e:	589d      	ldr	r5, [r3, r2]
 800bea0:	687b      	ldr	r3, [r7, #4]
 800bea2:	6958      	ldr	r0, [r3, #20]
 800bea4:	230f      	movs	r3, #15
 800bea6:	18fc      	adds	r4, r7, r3
 800bea8:	68ba      	ldr	r2, [r7, #8]
 800beaa:	6879      	ldr	r1, [r7, #4]
 800beac:	2300      	movs	r3, #0
 800beae:	47a8      	blx	r5
 800beb0:	0003      	movs	r3, r0
 800beb2:	7023      	strb	r3, [r4, #0]
 800beb4:	e009      	b.n	800beca <tcp_process_refused_data+0x6e>
 800beb6:	230f      	movs	r3, #15
 800beb8:	18fc      	adds	r4, r7, r3
 800beba:	68ba      	ldr	r2, [r7, #8]
 800bebc:	6879      	ldr	r1, [r7, #4]
 800bebe:	2300      	movs	r3, #0
 800bec0:	2000      	movs	r0, #0
 800bec2:	f000 f8b1 	bl	800c028 <tcp_recv_null>
 800bec6:	0003      	movs	r3, r0
 800bec8:	7023      	strb	r3, [r4, #0]
    if (err == ERR_OK) {
 800beca:	230f      	movs	r3, #15
 800becc:	18fb      	adds	r3, r7, r3
 800bece:	781b      	ldrb	r3, [r3, #0]
 800bed0:	b25b      	sxtb	r3, r3
 800bed2:	2b00      	cmp	r3, #0
 800bed4:	d131      	bne.n	800bf3a <tcp_process_refused_data+0xde>
      /* did refused_data include a FIN? */
      if ((refused_flags & PBUF_FLAG_TCP_FIN)
 800bed6:	230e      	movs	r3, #14
 800bed8:	18fb      	adds	r3, r7, r3
 800beda:	781b      	ldrb	r3, [r3, #0]
 800bedc:	2220      	movs	r2, #32
 800bede:	4013      	ands	r3, r2
 800bee0:	d03a      	beq.n	800bf58 <tcp_process_refused_data+0xfc>
          && (rest == NULL)
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
         ) {
        /* correct rcv_wnd as the application won't call tcp_recved()
           for the FIN's seqno */
        if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
 800bee2:	687b      	ldr	r3, [r7, #4]
 800bee4:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800bee6:	2386      	movs	r3, #134	; 0x86
 800bee8:	00db      	lsls	r3, r3, #3
 800beea:	429a      	cmp	r2, r3
 800beec:	d005      	beq.n	800befa <tcp_process_refused_data+0x9e>
          pcb->rcv_wnd++;
 800beee:	687b      	ldr	r3, [r7, #4]
 800bef0:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 800bef2:	3301      	adds	r3, #1
 800bef4:	b29a      	uxth	r2, r3
 800bef6:	687b      	ldr	r3, [r7, #4]
 800bef8:	859a      	strh	r2, [r3, #44]	; 0x2c
        }
        TCP_EVENT_CLOSED(pcb, err);
 800befa:	687b      	ldr	r3, [r7, #4]
 800befc:	2288      	movs	r2, #136	; 0x88
 800befe:	589b      	ldr	r3, [r3, r2]
 800bf00:	2b00      	cmp	r3, #0
 800bf02:	d00d      	beq.n	800bf20 <tcp_process_refused_data+0xc4>
 800bf04:	687b      	ldr	r3, [r7, #4]
 800bf06:	2288      	movs	r2, #136	; 0x88
 800bf08:	589d      	ldr	r5, [r3, r2]
 800bf0a:	687b      	ldr	r3, [r7, #4]
 800bf0c:	6958      	ldr	r0, [r3, #20]
 800bf0e:	230f      	movs	r3, #15
 800bf10:	18fc      	adds	r4, r7, r3
 800bf12:	6879      	ldr	r1, [r7, #4]
 800bf14:	2300      	movs	r3, #0
 800bf16:	2200      	movs	r2, #0
 800bf18:	47a8      	blx	r5
 800bf1a:	0003      	movs	r3, r0
 800bf1c:	7023      	strb	r3, [r4, #0]
 800bf1e:	e003      	b.n	800bf28 <tcp_process_refused_data+0xcc>
 800bf20:	230f      	movs	r3, #15
 800bf22:	18fb      	adds	r3, r7, r3
 800bf24:	2200      	movs	r2, #0
 800bf26:	701a      	strb	r2, [r3, #0]
        if (err == ERR_ABRT) {
 800bf28:	230f      	movs	r3, #15
 800bf2a:	18fb      	adds	r3, r7, r3
 800bf2c:	781b      	ldrb	r3, [r3, #0]
 800bf2e:	b25b      	sxtb	r3, r3
 800bf30:	330d      	adds	r3, #13
 800bf32:	d111      	bne.n	800bf58 <tcp_process_refused_data+0xfc>
          return ERR_ABRT;
 800bf34:	230d      	movs	r3, #13
 800bf36:	425b      	negs	r3, r3
 800bf38:	e00f      	b.n	800bf5a <tcp_process_refused_data+0xfe>
        }
      }
    } else if (err == ERR_ABRT) {
 800bf3a:	230f      	movs	r3, #15
 800bf3c:	18fb      	adds	r3, r7, r3
 800bf3e:	781b      	ldrb	r3, [r3, #0]
 800bf40:	b25b      	sxtb	r3, r3
 800bf42:	330d      	adds	r3, #13
 800bf44:	d102      	bne.n	800bf4c <tcp_process_refused_data+0xf0>
      /* if err == ERR_ABRT, 'pcb' is already deallocated */
      /* Drop incoming packets because pcb is "full" (only if the incoming
         segment contains data). */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
      return ERR_ABRT;
 800bf46:	230d      	movs	r3, #13
 800bf48:	425b      	negs	r3, r3
 800bf4a:	e006      	b.n	800bf5a <tcp_process_refused_data+0xfe>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
      if (rest != NULL) {
        pbuf_cat(refused_data, rest);
      }
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
      pcb->refused_data = refused_data;
 800bf4c:	687b      	ldr	r3, [r7, #4]
 800bf4e:	68ba      	ldr	r2, [r7, #8]
 800bf50:	67da      	str	r2, [r3, #124]	; 0x7c
      return ERR_INPROGRESS;
 800bf52:	2305      	movs	r3, #5
 800bf54:	425b      	negs	r3, r3
 800bf56:	e000      	b.n	800bf5a <tcp_process_refused_data+0xfe>
    }
  }
  return ERR_OK;
 800bf58:	2300      	movs	r3, #0
}
 800bf5a:	0018      	movs	r0, r3
 800bf5c:	46bd      	mov	sp, r7
 800bf5e:	b004      	add	sp, #16
 800bf60:	bdb0      	pop	{r4, r5, r7, pc}
 800bf62:	46c0      	nop			; (mov r8, r8)
 800bf64:	08020364 	.word	0x08020364

0800bf68 <tcp_segs_free>:
 *
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
 800bf68:	b580      	push	{r7, lr}
 800bf6a:	b084      	sub	sp, #16
 800bf6c:	af00      	add	r7, sp, #0
 800bf6e:	6078      	str	r0, [r7, #4]
  while (seg != NULL) {
 800bf70:	e008      	b.n	800bf84 <tcp_segs_free+0x1c>
    struct tcp_seg *next = seg->next;
 800bf72:	687b      	ldr	r3, [r7, #4]
 800bf74:	681b      	ldr	r3, [r3, #0]
 800bf76:	60fb      	str	r3, [r7, #12]
    tcp_seg_free(seg);
 800bf78:	687b      	ldr	r3, [r7, #4]
 800bf7a:	0018      	movs	r0, r3
 800bf7c:	f000 f80a 	bl	800bf94 <tcp_seg_free>
    seg = next;
 800bf80:	68fb      	ldr	r3, [r7, #12]
 800bf82:	607b      	str	r3, [r7, #4]
  while (seg != NULL) {
 800bf84:	687b      	ldr	r3, [r7, #4]
 800bf86:	2b00      	cmp	r3, #0
 800bf88:	d1f3      	bne.n	800bf72 <tcp_segs_free+0xa>
  }
}
 800bf8a:	46c0      	nop			; (mov r8, r8)
 800bf8c:	46c0      	nop			; (mov r8, r8)
 800bf8e:	46bd      	mov	sp, r7
 800bf90:	b004      	add	sp, #16
 800bf92:	bd80      	pop	{r7, pc}

0800bf94 <tcp_seg_free>:
 *
 * @param seg single tcp_seg to free
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
 800bf94:	b580      	push	{r7, lr}
 800bf96:	b082      	sub	sp, #8
 800bf98:	af00      	add	r7, sp, #0
 800bf9a:	6078      	str	r0, [r7, #4]
  if (seg != NULL) {
 800bf9c:	687b      	ldr	r3, [r7, #4]
 800bf9e:	2b00      	cmp	r3, #0
 800bfa0:	d00d      	beq.n	800bfbe <tcp_seg_free+0x2a>
    if (seg->p != NULL) {
 800bfa2:	687b      	ldr	r3, [r7, #4]
 800bfa4:	685b      	ldr	r3, [r3, #4]
 800bfa6:	2b00      	cmp	r3, #0
 800bfa8:	d004      	beq.n	800bfb4 <tcp_seg_free+0x20>
      pbuf_free(seg->p);
 800bfaa:	687b      	ldr	r3, [r7, #4]
 800bfac:	685b      	ldr	r3, [r3, #4]
 800bfae:	0018      	movs	r0, r3
 800bfb0:	f7fd ff84 	bl	8009ebc <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 800bfb4:	687b      	ldr	r3, [r7, #4]
 800bfb6:	0019      	movs	r1, r3
 800bfb8:	2003      	movs	r0, #3
 800bfba:	f7fd f88f 	bl	80090dc <memp_free>
  }
}
 800bfbe:	46c0      	nop			; (mov r8, r8)
 800bfc0:	46bd      	mov	sp, r7
 800bfc2:	b002      	add	sp, #8
 800bfc4:	bd80      	pop	{r7, pc}
	...

0800bfc8 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
 800bfc8:	b580      	push	{r7, lr}
 800bfca:	b084      	sub	sp, #16
 800bfcc:	af00      	add	r7, sp, #0
 800bfce:	6078      	str	r0, [r7, #4]
  struct tcp_seg *cseg;

  LWIP_ASSERT("tcp_seg_copy: invalid seg", seg != NULL);
 800bfd0:	687b      	ldr	r3, [r7, #4]
 800bfd2:	2b00      	cmp	r3, #0
 800bfd4:	d105      	bne.n	800bfe2 <tcp_seg_copy+0x1a>
 800bfd6:	4b10      	ldr	r3, [pc, #64]	; (800c018 <tcp_seg_copy+0x50>)
 800bfd8:	4a10      	ldr	r2, [pc, #64]	; (800c01c <tcp_seg_copy+0x54>)
 800bfda:	4911      	ldr	r1, [pc, #68]	; (800c020 <tcp_seg_copy+0x58>)
 800bfdc:	4811      	ldr	r0, [pc, #68]	; (800c024 <tcp_seg_copy+0x5c>)
 800bfde:	f7f6 fdf3 	bl	8002bc8 <app_debug_rtt_raw>

  cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
 800bfe2:	2003      	movs	r0, #3
 800bfe4:	f7fd f80a 	bl	8008ffc <memp_malloc>
 800bfe8:	0003      	movs	r3, r0
 800bfea:	60fb      	str	r3, [r7, #12]
  if (cseg == NULL) {
 800bfec:	68fb      	ldr	r3, [r7, #12]
 800bfee:	2b00      	cmp	r3, #0
 800bff0:	d101      	bne.n	800bff6 <tcp_seg_copy+0x2e>
    return NULL;
 800bff2:	2300      	movs	r3, #0
 800bff4:	e00b      	b.n	800c00e <tcp_seg_copy+0x46>
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg));
 800bff6:	6879      	ldr	r1, [r7, #4]
 800bff8:	68fb      	ldr	r3, [r7, #12]
 800bffa:	2214      	movs	r2, #20
 800bffc:	0018      	movs	r0, r3
 800bffe:	f010 ff65 	bl	801cecc <memcpy>
  pbuf_ref(cseg->p);
 800c002:	68fb      	ldr	r3, [r7, #12]
 800c004:	685b      	ldr	r3, [r3, #4]
 800c006:	0018      	movs	r0, r3
 800c008:	f7fe f814 	bl	800a034 <pbuf_ref>
  return cseg;
 800c00c:	68fb      	ldr	r3, [r7, #12]
}
 800c00e:	0018      	movs	r0, r3
 800c010:	46bd      	mov	sp, r7
 800c012:	b004      	add	sp, #16
 800c014:	bd80      	pop	{r7, pc}
 800c016:	46c0      	nop			; (mov r8, r8)
 800c018:	0801fe58 	.word	0x0801fe58
 800c01c:	00000683 	.word	0x00000683
 800c020:	080203a8 	.word	0x080203a8
 800c024:	0801fe94 	.word	0x0801fe94

0800c028 <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
 800c028:	b580      	push	{r7, lr}
 800c02a:	b084      	sub	sp, #16
 800c02c:	af00      	add	r7, sp, #0
 800c02e:	60f8      	str	r0, [r7, #12]
 800c030:	60b9      	str	r1, [r7, #8]
 800c032:	607a      	str	r2, [r7, #4]
 800c034:	001a      	movs	r2, r3
 800c036:	1cfb      	adds	r3, r7, #3
 800c038:	701a      	strb	r2, [r3, #0]
  LWIP_UNUSED_ARG(arg);

  LWIP_ERROR("tcp_recv_null: invalid pcb", pcb != NULL, return ERR_ARG);
 800c03a:	68bb      	ldr	r3, [r7, #8]
 800c03c:	2b00      	cmp	r3, #0
 800c03e:	d106      	bne.n	800c04e <tcp_recv_null+0x26>
 800c040:	4b12      	ldr	r3, [pc, #72]	; (800c08c <tcp_recv_null+0x64>)
 800c042:	0018      	movs	r0, r3
 800c044:	f7f6 fdc0 	bl	8002bc8 <app_debug_rtt_raw>
 800c048:	2310      	movs	r3, #16
 800c04a:	425b      	negs	r3, r3
 800c04c:	e01a      	b.n	800c084 <tcp_recv_null+0x5c>

  if (p != NULL) {
 800c04e:	687b      	ldr	r3, [r7, #4]
 800c050:	2b00      	cmp	r3, #0
 800c052:	d00b      	beq.n	800c06c <tcp_recv_null+0x44>
    tcp_recved(pcb, p->tot_len);
 800c054:	687b      	ldr	r3, [r7, #4]
 800c056:	891a      	ldrh	r2, [r3, #8]
 800c058:	68bb      	ldr	r3, [r7, #8]
 800c05a:	0011      	movs	r1, r2
 800c05c:	0018      	movs	r0, r3
 800c05e:	f7ff f907 	bl	800b270 <tcp_recved>
    pbuf_free(p);
 800c062:	687b      	ldr	r3, [r7, #4]
 800c064:	0018      	movs	r0, r3
 800c066:	f7fd ff29 	bl	8009ebc <pbuf_free>
 800c06a:	e00a      	b.n	800c082 <tcp_recv_null+0x5a>
  } else if (err == ERR_OK) {
 800c06c:	1cfb      	adds	r3, r7, #3
 800c06e:	781b      	ldrb	r3, [r3, #0]
 800c070:	b25b      	sxtb	r3, r3
 800c072:	2b00      	cmp	r3, #0
 800c074:	d105      	bne.n	800c082 <tcp_recv_null+0x5a>
    return tcp_close(pcb);
 800c076:	68bb      	ldr	r3, [r7, #8]
 800c078:	0018      	movs	r0, r3
 800c07a:	f7fe ff9b 	bl	800afb4 <tcp_close>
 800c07e:	0003      	movs	r3, r0
 800c080:	e000      	b.n	800c084 <tcp_recv_null+0x5c>
  }
  return ERR_OK;
 800c082:	2300      	movs	r3, #0
}
 800c084:	0018      	movs	r0, r3
 800c086:	46bd      	mov	sp, r7
 800c088:	b004      	add	sp, #16
 800c08a:	bd80      	pop	{r7, pc}
 800c08c:	080203c4 	.word	0x080203c4

0800c090 <tcp_kill_prio>:
 *
 * @param prio minimum priority
 */
static void
tcp_kill_prio(u8_t prio)
{
 800c090:	b580      	push	{r7, lr}
 800c092:	b086      	sub	sp, #24
 800c094:	af00      	add	r7, sp, #0
 800c096:	0002      	movs	r2, r0
 800c098:	1dfb      	adds	r3, r7, #7
 800c09a:	701a      	strb	r2, [r3, #0]
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;

  mprio = LWIP_MIN(TCP_PRIO_MAX, prio);
 800c09c:	1dfb      	adds	r3, r7, #7
 800c09e:	781b      	ldrb	r3, [r3, #0]
 800c0a0:	b25b      	sxtb	r3, r3
 800c0a2:	2b00      	cmp	r3, #0
 800c0a4:	db02      	blt.n	800c0ac <tcp_kill_prio+0x1c>
 800c0a6:	1dfb      	adds	r3, r7, #7
 800c0a8:	781a      	ldrb	r2, [r3, #0]
 800c0aa:	e000      	b.n	800c0ae <tcp_kill_prio+0x1e>
 800c0ac:	227f      	movs	r2, #127	; 0x7f
 800c0ae:	210b      	movs	r1, #11
 800c0b0:	187b      	adds	r3, r7, r1
 800c0b2:	701a      	strb	r2, [r3, #0]

  /* We want to kill connections with a lower prio, so bail out if 
   * supplied prio is 0 - there can never be a lower prio
   */
  if (mprio == 0) {
 800c0b4:	187b      	adds	r3, r7, r1
 800c0b6:	781b      	ldrb	r3, [r3, #0]
 800c0b8:	2b00      	cmp	r3, #0
 800c0ba:	d03c      	beq.n	800c136 <tcp_kill_prio+0xa6>
  /* We only want kill connections with a lower prio, so decrement prio by one 
   * and start searching for oldest connection with same or lower priority than mprio.
   * We want to find the connections with the lowest possible prio, and among
   * these the one with the longest inactivity time.
   */
  mprio--;
 800c0bc:	187b      	adds	r3, r7, r1
 800c0be:	781a      	ldrb	r2, [r3, #0]
 800c0c0:	187b      	adds	r3, r7, r1
 800c0c2:	3a01      	subs	r2, #1
 800c0c4:	701a      	strb	r2, [r3, #0]

  inactivity = 0;
 800c0c6:	2300      	movs	r3, #0
 800c0c8:	60fb      	str	r3, [r7, #12]
  inactive = NULL;
 800c0ca:	2300      	movs	r3, #0
 800c0cc:	613b      	str	r3, [r7, #16]
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800c0ce:	4b1c      	ldr	r3, [pc, #112]	; (800c140 <tcp_kill_prio+0xb0>)
 800c0d0:	681b      	ldr	r3, [r3, #0]
 800c0d2:	617b      	str	r3, [r7, #20]
 800c0d4:	e024      	b.n	800c120 <tcp_kill_prio+0x90>
        /* lower prio is always a kill candidate */
    if ((pcb->prio < mprio) ||
 800c0d6:	697b      	ldr	r3, [r7, #20]
 800c0d8:	7e5b      	ldrb	r3, [r3, #25]
 800c0da:	210b      	movs	r1, #11
 800c0dc:	187a      	adds	r2, r7, r1
 800c0de:	7812      	ldrb	r2, [r2, #0]
 800c0e0:	429a      	cmp	r2, r3
 800c0e2:	d80d      	bhi.n	800c100 <tcp_kill_prio+0x70>
        /* longer inactivity is also a kill candidate */
        ((pcb->prio == mprio) && ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity))) {
 800c0e4:	697b      	ldr	r3, [r7, #20]
 800c0e6:	7e5b      	ldrb	r3, [r3, #25]
    if ((pcb->prio < mprio) ||
 800c0e8:	187a      	adds	r2, r7, r1
 800c0ea:	7812      	ldrb	r2, [r2, #0]
 800c0ec:	429a      	cmp	r2, r3
 800c0ee:	d114      	bne.n	800c11a <tcp_kill_prio+0x8a>
        ((pcb->prio == mprio) && ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity))) {
 800c0f0:	4b14      	ldr	r3, [pc, #80]	; (800c144 <tcp_kill_prio+0xb4>)
 800c0f2:	681a      	ldr	r2, [r3, #0]
 800c0f4:	697b      	ldr	r3, [r7, #20]
 800c0f6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c0f8:	1ad3      	subs	r3, r2, r3
 800c0fa:	68fa      	ldr	r2, [r7, #12]
 800c0fc:	429a      	cmp	r2, r3
 800c0fe:	d80c      	bhi.n	800c11a <tcp_kill_prio+0x8a>
      inactivity = tcp_ticks - pcb->tmr;
 800c100:	4b10      	ldr	r3, [pc, #64]	; (800c144 <tcp_kill_prio+0xb4>)
 800c102:	681a      	ldr	r2, [r3, #0]
 800c104:	697b      	ldr	r3, [r7, #20]
 800c106:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c108:	1ad3      	subs	r3, r2, r3
 800c10a:	60fb      	str	r3, [r7, #12]
      inactive   = pcb;
 800c10c:	697b      	ldr	r3, [r7, #20]
 800c10e:	613b      	str	r3, [r7, #16]
      mprio      = pcb->prio;
 800c110:	230b      	movs	r3, #11
 800c112:	18fb      	adds	r3, r7, r3
 800c114:	697a      	ldr	r2, [r7, #20]
 800c116:	7e52      	ldrb	r2, [r2, #25]
 800c118:	701a      	strb	r2, [r3, #0]
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800c11a:	697b      	ldr	r3, [r7, #20]
 800c11c:	691b      	ldr	r3, [r3, #16]
 800c11e:	617b      	str	r3, [r7, #20]
 800c120:	697b      	ldr	r3, [r7, #20]
 800c122:	2b00      	cmp	r3, #0
 800c124:	d1d7      	bne.n	800c0d6 <tcp_kill_prio+0x46>
    }
  }
  if (inactive != NULL) {
 800c126:	693b      	ldr	r3, [r7, #16]
 800c128:	2b00      	cmp	r3, #0
 800c12a:	d005      	beq.n	800c138 <tcp_kill_prio+0xa8>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
                            (void *)inactive, inactivity));
    tcp_abort(inactive);
 800c12c:	693b      	ldr	r3, [r7, #16]
 800c12e:	0018      	movs	r0, r3
 800c130:	f7ff f830 	bl	800b194 <tcp_abort>
 800c134:	e000      	b.n	800c138 <tcp_kill_prio+0xa8>
    return;
 800c136:	46c0      	nop			; (mov r8, r8)
  }
}
 800c138:	46bd      	mov	sp, r7
 800c13a:	b006      	add	sp, #24
 800c13c:	bd80      	pop	{r7, pc}
 800c13e:	46c0      	nop			; (mov r8, r8)
 800c140:	20002b3c 	.word	0x20002b3c
 800c144:	20002b40 	.word	0x20002b40

0800c148 <tcp_kill_state>:
 * Kills the oldest connection that is in specific state.
 * Called from tcp_alloc() for LAST_ACK and CLOSING if no more connections are available.
 */
static void
tcp_kill_state(enum tcp_state state)
{
 800c148:	b580      	push	{r7, lr}
 800c14a:	b086      	sub	sp, #24
 800c14c:	af00      	add	r7, sp, #0
 800c14e:	0002      	movs	r2, r0
 800c150:	1dfb      	adds	r3, r7, #7
 800c152:	701a      	strb	r2, [r3, #0]
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  LWIP_ASSERT("invalid state", (state == CLOSING) || (state == LAST_ACK));
 800c154:	1dfb      	adds	r3, r7, #7
 800c156:	781b      	ldrb	r3, [r3, #0]
 800c158:	2b08      	cmp	r3, #8
 800c15a:	d009      	beq.n	800c170 <tcp_kill_state+0x28>
 800c15c:	1dfb      	adds	r3, r7, #7
 800c15e:	781b      	ldrb	r3, [r3, #0]
 800c160:	2b09      	cmp	r3, #9
 800c162:	d005      	beq.n	800c170 <tcp_kill_state+0x28>
 800c164:	4b1a      	ldr	r3, [pc, #104]	; (800c1d0 <tcp_kill_state+0x88>)
 800c166:	4a1b      	ldr	r2, [pc, #108]	; (800c1d4 <tcp_kill_state+0x8c>)
 800c168:	491b      	ldr	r1, [pc, #108]	; (800c1d8 <tcp_kill_state+0x90>)
 800c16a:	481c      	ldr	r0, [pc, #112]	; (800c1dc <tcp_kill_state+0x94>)
 800c16c:	f7f6 fd2c 	bl	8002bc8 <app_debug_rtt_raw>

  inactivity = 0;
 800c170:	2300      	movs	r3, #0
 800c172:	60fb      	str	r3, [r7, #12]
  inactive = NULL;
 800c174:	2300      	movs	r3, #0
 800c176:	613b      	str	r3, [r7, #16]
  /* Go through the list of active pcbs and get the oldest pcb that is in state
     CLOSING/LAST_ACK. */
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800c178:	4b19      	ldr	r3, [pc, #100]	; (800c1e0 <tcp_kill_state+0x98>)
 800c17a:	681b      	ldr	r3, [r3, #0]
 800c17c:	617b      	str	r3, [r7, #20]
 800c17e:	e018      	b.n	800c1b2 <tcp_kill_state+0x6a>
    if (pcb->state == state) {
 800c180:	697b      	ldr	r3, [r7, #20]
 800c182:	7e1b      	ldrb	r3, [r3, #24]
 800c184:	1dfa      	adds	r2, r7, #7
 800c186:	7812      	ldrb	r2, [r2, #0]
 800c188:	429a      	cmp	r2, r3
 800c18a:	d10f      	bne.n	800c1ac <tcp_kill_state+0x64>
      if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 800c18c:	4b15      	ldr	r3, [pc, #84]	; (800c1e4 <tcp_kill_state+0x9c>)
 800c18e:	681a      	ldr	r2, [r3, #0]
 800c190:	697b      	ldr	r3, [r7, #20]
 800c192:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c194:	1ad3      	subs	r3, r2, r3
 800c196:	68fa      	ldr	r2, [r7, #12]
 800c198:	429a      	cmp	r2, r3
 800c19a:	d807      	bhi.n	800c1ac <tcp_kill_state+0x64>
        inactivity = tcp_ticks - pcb->tmr;
 800c19c:	4b11      	ldr	r3, [pc, #68]	; (800c1e4 <tcp_kill_state+0x9c>)
 800c19e:	681a      	ldr	r2, [r3, #0]
 800c1a0:	697b      	ldr	r3, [r7, #20]
 800c1a2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c1a4:	1ad3      	subs	r3, r2, r3
 800c1a6:	60fb      	str	r3, [r7, #12]
        inactive = pcb;
 800c1a8:	697b      	ldr	r3, [r7, #20]
 800c1aa:	613b      	str	r3, [r7, #16]
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800c1ac:	697b      	ldr	r3, [r7, #20]
 800c1ae:	691b      	ldr	r3, [r3, #16]
 800c1b0:	617b      	str	r3, [r7, #20]
 800c1b2:	697b      	ldr	r3, [r7, #20]
 800c1b4:	2b00      	cmp	r3, #0
 800c1b6:	d1e3      	bne.n	800c180 <tcp_kill_state+0x38>
      }
    }
  }
  if (inactive != NULL) {
 800c1b8:	693b      	ldr	r3, [r7, #16]
 800c1ba:	2b00      	cmp	r3, #0
 800c1bc:	d004      	beq.n	800c1c8 <tcp_kill_state+0x80>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_closing: killing oldest %s PCB %p (%"S32_F")\n",
                            tcp_state_str[state], (void *)inactive, inactivity));
    /* Don't send a RST, since no data is lost. */
    tcp_abandon(inactive, 0);
 800c1be:	693b      	ldr	r3, [r7, #16]
 800c1c0:	2100      	movs	r1, #0
 800c1c2:	0018      	movs	r0, r3
 800c1c4:	f7fe ff1c 	bl	800b000 <tcp_abandon>
  }
}
 800c1c8:	46c0      	nop			; (mov r8, r8)
 800c1ca:	46bd      	mov	sp, r7
 800c1cc:	b006      	add	sp, #24
 800c1ce:	bd80      	pop	{r7, pc}
 800c1d0:	0801fe58 	.word	0x0801fe58
 800c1d4:	000006de 	.word	0x000006de
 800c1d8:	080203e0 	.word	0x080203e0
 800c1dc:	0801fe94 	.word	0x0801fe94
 800c1e0:	20002b3c 	.word	0x20002b3c
 800c1e4:	20002b40 	.word	0x20002b40

0800c1e8 <tcp_kill_timewait>:
 * Kills the oldest connection that is in TIME_WAIT state.
 * Called from tcp_alloc() if no more connections are available.
 */
static void
tcp_kill_timewait(void)
{
 800c1e8:	b580      	push	{r7, lr}
 800c1ea:	b084      	sub	sp, #16
 800c1ec:	af00      	add	r7, sp, #0
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
 800c1ee:	2300      	movs	r3, #0
 800c1f0:	607b      	str	r3, [r7, #4]
  inactive = NULL;
 800c1f2:	2300      	movs	r3, #0
 800c1f4:	60bb      	str	r3, [r7, #8]
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800c1f6:	4b12      	ldr	r3, [pc, #72]	; (800c240 <tcp_kill_timewait+0x58>)
 800c1f8:	681b      	ldr	r3, [r3, #0]
 800c1fa:	60fb      	str	r3, [r7, #12]
 800c1fc:	e012      	b.n	800c224 <tcp_kill_timewait+0x3c>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 800c1fe:	4b11      	ldr	r3, [pc, #68]	; (800c244 <tcp_kill_timewait+0x5c>)
 800c200:	681a      	ldr	r2, [r3, #0]
 800c202:	68fb      	ldr	r3, [r7, #12]
 800c204:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c206:	1ad3      	subs	r3, r2, r3
 800c208:	687a      	ldr	r2, [r7, #4]
 800c20a:	429a      	cmp	r2, r3
 800c20c:	d807      	bhi.n	800c21e <tcp_kill_timewait+0x36>
      inactivity = tcp_ticks - pcb->tmr;
 800c20e:	4b0d      	ldr	r3, [pc, #52]	; (800c244 <tcp_kill_timewait+0x5c>)
 800c210:	681a      	ldr	r2, [r3, #0]
 800c212:	68fb      	ldr	r3, [r7, #12]
 800c214:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c216:	1ad3      	subs	r3, r2, r3
 800c218:	607b      	str	r3, [r7, #4]
      inactive = pcb;
 800c21a:	68fb      	ldr	r3, [r7, #12]
 800c21c:	60bb      	str	r3, [r7, #8]
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800c21e:	68fb      	ldr	r3, [r7, #12]
 800c220:	691b      	ldr	r3, [r3, #16]
 800c222:	60fb      	str	r3, [r7, #12]
 800c224:	68fb      	ldr	r3, [r7, #12]
 800c226:	2b00      	cmp	r3, #0
 800c228:	d1e9      	bne.n	800c1fe <tcp_kill_timewait+0x16>
    }
  }
  if (inactive != NULL) {
 800c22a:	68bb      	ldr	r3, [r7, #8]
 800c22c:	2b00      	cmp	r3, #0
 800c22e:	d003      	beq.n	800c238 <tcp_kill_timewait+0x50>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
                            (void *)inactive, inactivity));
    tcp_abort(inactive);
 800c230:	68bb      	ldr	r3, [r7, #8]
 800c232:	0018      	movs	r0, r3
 800c234:	f7fe ffae 	bl	800b194 <tcp_abort>
  }
}
 800c238:	46c0      	nop			; (mov r8, r8)
 800c23a:	46bd      	mov	sp, r7
 800c23c:	b004      	add	sp, #16
 800c23e:	bd80      	pop	{r7, pc}
 800c240:	20002b4c 	.word	0x20002b4c
 800c244:	20002b40 	.word	0x20002b40

0800c248 <tcp_handle_closepend>:
 * now send the FIN (which failed before), the pcb might be in a state that is
 * OK for us to now free it.
 */
static void
tcp_handle_closepend(void)
{
 800c248:	b580      	push	{r7, lr}
 800c24a:	b082      	sub	sp, #8
 800c24c:	af00      	add	r7, sp, #0
  struct tcp_pcb *pcb = tcp_active_pcbs;
 800c24e:	4b11      	ldr	r3, [pc, #68]	; (800c294 <tcp_handle_closepend+0x4c>)
 800c250:	681b      	ldr	r3, [r3, #0]
 800c252:	607b      	str	r3, [r7, #4]

  while (pcb != NULL) {
 800c254:	e015      	b.n	800c282 <tcp_handle_closepend+0x3a>
    struct tcp_pcb *next = pcb->next;
 800c256:	687b      	ldr	r3, [r7, #4]
 800c258:	691b      	ldr	r3, [r3, #16]
 800c25a:	603b      	str	r3, [r7, #0]
    /* send pending FIN */
    if (pcb->flags & TF_CLOSEPEND) {
 800c25c:	687b      	ldr	r3, [r7, #4]
 800c25e:	8bdb      	ldrh	r3, [r3, #30]
 800c260:	001a      	movs	r2, r3
 800c262:	2308      	movs	r3, #8
 800c264:	4013      	ands	r3, r2
 800c266:	d00a      	beq.n	800c27e <tcp_handle_closepend+0x36>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_handle_closepend: pending FIN\n"));
      tcp_clear_flags(pcb, TF_CLOSEPEND);
 800c268:	687b      	ldr	r3, [r7, #4]
 800c26a:	8bdb      	ldrh	r3, [r3, #30]
 800c26c:	2208      	movs	r2, #8
 800c26e:	4393      	bics	r3, r2
 800c270:	b29a      	uxth	r2, r3
 800c272:	687b      	ldr	r3, [r7, #4]
 800c274:	83da      	strh	r2, [r3, #30]
      tcp_close_shutdown_fin(pcb);
 800c276:	687b      	ldr	r3, [r7, #4]
 800c278:	0018      	movs	r0, r3
 800c27a:	f7fe fe21 	bl	800aec0 <tcp_close_shutdown_fin>
    }
    pcb = next;
 800c27e:	683b      	ldr	r3, [r7, #0]
 800c280:	607b      	str	r3, [r7, #4]
  while (pcb != NULL) {
 800c282:	687b      	ldr	r3, [r7, #4]
 800c284:	2b00      	cmp	r3, #0
 800c286:	d1e6      	bne.n	800c256 <tcp_handle_closepend+0xe>
  }
}
 800c288:	46c0      	nop			; (mov r8, r8)
 800c28a:	46c0      	nop			; (mov r8, r8)
 800c28c:	46bd      	mov	sp, r7
 800c28e:	b002      	add	sp, #8
 800c290:	bd80      	pop	{r7, pc}
 800c292:	46c0      	nop			; (mov r8, r8)
 800c294:	20002b3c 	.word	0x20002b3c

0800c298 <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
 800c298:	b580      	push	{r7, lr}
 800c29a:	b084      	sub	sp, #16
 800c29c:	af00      	add	r7, sp, #0
 800c29e:	0002      	movs	r2, r0
 800c2a0:	1dfb      	adds	r3, r7, #7
 800c2a2:	701a      	strb	r2, [r3, #0]
  struct tcp_pcb *pcb;

  LWIP_ASSERT_CORE_LOCKED();

  pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800c2a4:	2001      	movs	r0, #1
 800c2a6:	f7fc fea9 	bl	8008ffc <memp_malloc>
 800c2aa:	0003      	movs	r3, r0
 800c2ac:	60fb      	str	r3, [r7, #12]
  if (pcb == NULL) {
 800c2ae:	68fb      	ldr	r3, [r7, #12]
 800c2b0:	2b00      	cmp	r3, #0
 800c2b2:	d12b      	bne.n	800c30c <tcp_alloc+0x74>
    /* Try to send FIN for all pcbs stuck in TF_CLOSEPEND first */
    tcp_handle_closepend();
 800c2b4:	f7ff ffc8 	bl	800c248 <tcp_handle_closepend>

    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
 800c2b8:	f7ff ff96 	bl	800c1e8 <tcp_kill_timewait>
    /* Try to allocate a tcp_pcb again. */
    pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800c2bc:	2001      	movs	r0, #1
 800c2be:	f7fc fe9d 	bl	8008ffc <memp_malloc>
 800c2c2:	0003      	movs	r3, r0
 800c2c4:	60fb      	str	r3, [r7, #12]
    if (pcb == NULL) {
 800c2c6:	68fb      	ldr	r3, [r7, #12]
 800c2c8:	2b00      	cmp	r3, #0
 800c2ca:	d11f      	bne.n	800c30c <tcp_alloc+0x74>
      /* Try killing oldest connection in LAST-ACK (these wouldn't go to TIME-WAIT). */
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest LAST-ACK connection\n"));
      tcp_kill_state(LAST_ACK);
 800c2cc:	2009      	movs	r0, #9
 800c2ce:	f7ff ff3b 	bl	800c148 <tcp_kill_state>
      /* Try to allocate a tcp_pcb again. */
      pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800c2d2:	2001      	movs	r0, #1
 800c2d4:	f7fc fe92 	bl	8008ffc <memp_malloc>
 800c2d8:	0003      	movs	r3, r0
 800c2da:	60fb      	str	r3, [r7, #12]
      if (pcb == NULL) {
 800c2dc:	68fb      	ldr	r3, [r7, #12]
 800c2de:	2b00      	cmp	r3, #0
 800c2e0:	d114      	bne.n	800c30c <tcp_alloc+0x74>
        /* Try killing oldest connection in CLOSING. */
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest CLOSING connection\n"));
        tcp_kill_state(CLOSING);
 800c2e2:	2008      	movs	r0, #8
 800c2e4:	f7ff ff30 	bl	800c148 <tcp_kill_state>
        /* Try to allocate a tcp_pcb again. */
        pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800c2e8:	2001      	movs	r0, #1
 800c2ea:	f7fc fe87 	bl	8008ffc <memp_malloc>
 800c2ee:	0003      	movs	r3, r0
 800c2f0:	60fb      	str	r3, [r7, #12]
        if (pcb == NULL) {
 800c2f2:	68fb      	ldr	r3, [r7, #12]
 800c2f4:	2b00      	cmp	r3, #0
 800c2f6:	d109      	bne.n	800c30c <tcp_alloc+0x74>
          /* Try killing oldest active connection with lower priority than the new one. */
          LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing oldest connection with prio lower than %d\n", prio));
          tcp_kill_prio(prio);
 800c2f8:	1dfb      	adds	r3, r7, #7
 800c2fa:	781b      	ldrb	r3, [r3, #0]
 800c2fc:	0018      	movs	r0, r3
 800c2fe:	f7ff fec7 	bl	800c090 <tcp_kill_prio>
          /* Try to allocate a tcp_pcb again. */
          pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800c302:	2001      	movs	r0, #1
 800c304:	f7fc fe7a 	bl	8008ffc <memp_malloc>
 800c308:	0003      	movs	r3, r0
 800c30a:	60fb      	str	r3, [r7, #12]
    if (pcb != NULL) {
      /* adjust err stats: memp_malloc failed above */
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
    }
  }
  if (pcb != NULL) {
 800c30c:	68fb      	ldr	r3, [r7, #12]
 800c30e:	2b00      	cmp	r3, #0
 800c310:	d04c      	beq.n	800c3ac <tcp_alloc+0x114>
    /* zero out the whole pcb, so there is no need to initialize members to zero */
    memset(pcb, 0, sizeof(struct tcp_pcb));
 800c312:	68fb      	ldr	r3, [r7, #12]
 800c314:	22a8      	movs	r2, #168	; 0xa8
 800c316:	2100      	movs	r1, #0
 800c318:	0018      	movs	r0, r3
 800c31a:	f010 fdf3 	bl	801cf04 <memset>
    pcb->prio = prio;
 800c31e:	68fb      	ldr	r3, [r7, #12]
 800c320:	1dfa      	adds	r2, r7, #7
 800c322:	7812      	ldrb	r2, [r2, #0]
 800c324:	765a      	strb	r2, [r3, #25]
    pcb->snd_buf = TCP_SND_BUF;
 800c326:	68fb      	ldr	r3, [r7, #12]
 800c328:	2268      	movs	r2, #104	; 0x68
 800c32a:	2186      	movs	r1, #134	; 0x86
 800c32c:	00c9      	lsls	r1, r1, #3
 800c32e:	5299      	strh	r1, [r3, r2]
    /* Start with a window that does not need scaling. When window scaling is
       enabled and used, the window is enlarged when both sides agree on scaling. */
    pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
 800c330:	68fb      	ldr	r3, [r7, #12]
 800c332:	2286      	movs	r2, #134	; 0x86
 800c334:	00d2      	lsls	r2, r2, #3
 800c336:	85da      	strh	r2, [r3, #46]	; 0x2e
 800c338:	68fb      	ldr	r3, [r7, #12]
 800c33a:	8dda      	ldrh	r2, [r3, #46]	; 0x2e
 800c33c:	68fb      	ldr	r3, [r7, #12]
 800c33e:	859a      	strh	r2, [r3, #44]	; 0x2c
    pcb->ttl = TCP_TTL;
 800c340:	68fb      	ldr	r3, [r7, #12]
 800c342:	22ff      	movs	r2, #255	; 0xff
 800c344:	72da      	strb	r2, [r3, #11]
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = INITIAL_MSS;
 800c346:	68fb      	ldr	r3, [r7, #12]
 800c348:	2286      	movs	r2, #134	; 0x86
 800c34a:	0092      	lsls	r2, r2, #2
 800c34c:	86da      	strh	r2, [r3, #54]	; 0x36
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
 800c34e:	68fb      	ldr	r3, [r7, #12]
 800c350:	2244      	movs	r2, #68	; 0x44
 800c352:	2103      	movs	r1, #3
 800c354:	5299      	strh	r1, [r3, r2]
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
 800c356:	68fb      	ldr	r3, [r7, #12]
 800c358:	2242      	movs	r2, #66	; 0x42
 800c35a:	2103      	movs	r1, #3
 800c35c:	5299      	strh	r1, [r3, r2]
    pcb->rtime = -1;
 800c35e:	68fb      	ldr	r3, [r7, #12]
 800c360:	2201      	movs	r2, #1
 800c362:	4252      	negs	r2, r2
 800c364:	869a      	strh	r2, [r3, #52]	; 0x34
    pcb->cwnd = 1;
 800c366:	68fb      	ldr	r3, [r7, #12]
 800c368:	224c      	movs	r2, #76	; 0x4c
 800c36a:	2101      	movs	r1, #1
 800c36c:	5299      	strh	r1, [r3, r2]
    pcb->tmr = tcp_ticks;
 800c36e:	4b12      	ldr	r3, [pc, #72]	; (800c3b8 <tcp_alloc+0x120>)
 800c370:	681a      	ldr	r2, [r3, #0]
 800c372:	68fb      	ldr	r3, [r7, #12]
 800c374:	625a      	str	r2, [r3, #36]	; 0x24
    pcb->last_timer = tcp_timer_ctr;
 800c376:	4b11      	ldr	r3, [pc, #68]	; (800c3bc <tcp_alloc+0x124>)
 800c378:	7819      	ldrb	r1, [r3, #0]
 800c37a:	68fb      	ldr	r3, [r7, #12]
 800c37c:	2222      	movs	r2, #34	; 0x22
 800c37e:	5499      	strb	r1, [r3, r2]
    of using the largest advertised receive window.  We've seen complications with
    receiving TCPs that use window scaling and/or window auto-tuning where the
    initial advertised window is very small and then grows rapidly once the
    connection is established. To avoid these complications, we set ssthresh to the
    largest effective cwnd (amount of in-flight data) that the sender can have. */
    pcb->ssthresh = TCP_SND_BUF;
 800c380:	68fb      	ldr	r3, [r7, #12]
 800c382:	224e      	movs	r2, #78	; 0x4e
 800c384:	2186      	movs	r1, #134	; 0x86
 800c386:	00c9      	lsls	r1, r1, #3
 800c388:	5299      	strh	r1, [r3, r2]

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
 800c38a:	68fb      	ldr	r3, [r7, #12]
 800c38c:	2188      	movs	r1, #136	; 0x88
 800c38e:	4a0c      	ldr	r2, [pc, #48]	; (800c3c0 <tcp_alloc+0x128>)
 800c390:	505a      	str	r2, [r3, r1]
#endif /* LWIP_CALLBACK_API */

    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
 800c392:	68fb      	ldr	r3, [r7, #12]
 800c394:	2298      	movs	r2, #152	; 0x98
 800c396:	490b      	ldr	r1, [pc, #44]	; (800c3c4 <tcp_alloc+0x12c>)
 800c398:	5099      	str	r1, [r3, r2]

#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
 800c39a:	68fb      	ldr	r3, [r7, #12]
 800c39c:	219c      	movs	r1, #156	; 0x9c
 800c39e:	22fa      	movs	r2, #250	; 0xfa
 800c3a0:	00d2      	lsls	r2, r2, #3
 800c3a2:	505a      	str	r2, [r3, r1]
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
 800c3a4:	68fb      	ldr	r3, [r7, #12]
 800c3a6:	22a0      	movs	r2, #160	; 0xa0
 800c3a8:	2109      	movs	r1, #9
 800c3aa:	5099      	str	r1, [r3, r2]
#endif /* LWIP_TCP_KEEPALIVE */
  }
  return pcb;
 800c3ac:	68fb      	ldr	r3, [r7, #12]
}
 800c3ae:	0018      	movs	r0, r3
 800c3b0:	46bd      	mov	sp, r7
 800c3b2:	b004      	add	sp, #16
 800c3b4:	bd80      	pop	{r7, pc}
 800c3b6:	46c0      	nop			; (mov r8, r8)
 800c3b8:	20002b40 	.word	0x20002b40
 800c3bc:	20001792 	.word	0x20001792
 800c3c0:	0800c029 	.word	0x0800c029
 800c3c4:	00002710 	.word	0x00002710

0800c3c8 <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
 800c3c8:	b580      	push	{r7, lr}
 800c3ca:	af00      	add	r7, sp, #0
  return tcp_alloc(TCP_PRIO_NORMAL);
 800c3cc:	2040      	movs	r0, #64	; 0x40
 800c3ce:	f7ff ff63 	bl	800c298 <tcp_alloc>
 800c3d2:	0003      	movs	r3, r0
}
 800c3d4:	0018      	movs	r0, r3
 800c3d6:	46bd      	mov	sp, r7
 800c3d8:	bd80      	pop	{r7, pc}

0800c3da <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{
 800c3da:	b580      	push	{r7, lr}
 800c3dc:	b082      	sub	sp, #8
 800c3de:	af00      	add	r7, sp, #0
 800c3e0:	6078      	str	r0, [r7, #4]
 800c3e2:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT_CORE_LOCKED();
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  if (pcb != NULL) {
 800c3e4:	687b      	ldr	r3, [r7, #4]
 800c3e6:	2b00      	cmp	r3, #0
 800c3e8:	d002      	beq.n	800c3f0 <tcp_arg+0x16>
    pcb->callback_arg = arg;
 800c3ea:	687b      	ldr	r3, [r7, #4]
 800c3ec:	683a      	ldr	r2, [r7, #0]
 800c3ee:	615a      	str	r2, [r3, #20]
  }
}
 800c3f0:	46c0      	nop			; (mov r8, r8)
 800c3f2:	46bd      	mov	sp, r7
 800c3f4:	b002      	add	sp, #8
 800c3f6:	bd80      	pop	{r7, pc}

0800c3f8 <tcp_recv>:
 * @param pcb tcp_pcb to set the recv callback
 * @param recv callback function to call for this pcb when data is received
 */
void
tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
 800c3f8:	b580      	push	{r7, lr}
 800c3fa:	b082      	sub	sp, #8
 800c3fc:	af00      	add	r7, sp, #0
 800c3fe:	6078      	str	r0, [r7, #4]
 800c400:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb != NULL) {
 800c402:	687b      	ldr	r3, [r7, #4]
 800c404:	2b00      	cmp	r3, #0
 800c406:	d00d      	beq.n	800c424 <tcp_recv+0x2c>
    LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
 800c408:	687b      	ldr	r3, [r7, #4]
 800c40a:	7e1b      	ldrb	r3, [r3, #24]
 800c40c:	2b01      	cmp	r3, #1
 800c40e:	d105      	bne.n	800c41c <tcp_recv+0x24>
 800c410:	4b06      	ldr	r3, [pc, #24]	; (800c42c <tcp_recv+0x34>)
 800c412:	4a07      	ldr	r2, [pc, #28]	; (800c430 <tcp_recv+0x38>)
 800c414:	4907      	ldr	r1, [pc, #28]	; (800c434 <tcp_recv+0x3c>)
 800c416:	4808      	ldr	r0, [pc, #32]	; (800c438 <tcp_recv+0x40>)
 800c418:	f7f6 fbd6 	bl	8002bc8 <app_debug_rtt_raw>
    pcb->recv = recv;
 800c41c:	687b      	ldr	r3, [r7, #4]
 800c41e:	2188      	movs	r1, #136	; 0x88
 800c420:	683a      	ldr	r2, [r7, #0]
 800c422:	505a      	str	r2, [r3, r1]
  }
}
 800c424:	46c0      	nop			; (mov r8, r8)
 800c426:	46bd      	mov	sp, r7
 800c428:	b002      	add	sp, #8
 800c42a:	bd80      	pop	{r7, pc}
 800c42c:	0801fe58 	.word	0x0801fe58
 800c430:	000007e2 	.word	0x000007e2
 800c434:	080203f0 	.word	0x080203f0
 800c438:	0801fe94 	.word	0x0801fe94

0800c43c <tcp_sent>:
 * @param pcb tcp_pcb to set the sent callback
 * @param sent callback function to call for this pcb when data is successfully sent
 */
void
tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
 800c43c:	b580      	push	{r7, lr}
 800c43e:	b082      	sub	sp, #8
 800c440:	af00      	add	r7, sp, #0
 800c442:	6078      	str	r0, [r7, #4]
 800c444:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb != NULL) {
 800c446:	687b      	ldr	r3, [r7, #4]
 800c448:	2b00      	cmp	r3, #0
 800c44a:	d00d      	beq.n	800c468 <tcp_sent+0x2c>
    LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
 800c44c:	687b      	ldr	r3, [r7, #4]
 800c44e:	7e1b      	ldrb	r3, [r3, #24]
 800c450:	2b01      	cmp	r3, #1
 800c452:	d105      	bne.n	800c460 <tcp_sent+0x24>
 800c454:	4b06      	ldr	r3, [pc, #24]	; (800c470 <tcp_sent+0x34>)
 800c456:	4a07      	ldr	r2, [pc, #28]	; (800c474 <tcp_sent+0x38>)
 800c458:	4907      	ldr	r1, [pc, #28]	; (800c478 <tcp_sent+0x3c>)
 800c45a:	4808      	ldr	r0, [pc, #32]	; (800c47c <tcp_sent+0x40>)
 800c45c:	f7f6 fbb4 	bl	8002bc8 <app_debug_rtt_raw>
    pcb->sent = sent;
 800c460:	687b      	ldr	r3, [r7, #4]
 800c462:	2184      	movs	r1, #132	; 0x84
 800c464:	683a      	ldr	r2, [r7, #0]
 800c466:	505a      	str	r2, [r3, r1]
  }
}
 800c468:	46c0      	nop			; (mov r8, r8)
 800c46a:	46bd      	mov	sp, r7
 800c46c:	b002      	add	sp, #8
 800c46e:	bd80      	pop	{r7, pc}
 800c470:	0801fe58 	.word	0x0801fe58
 800c474:	000007f6 	.word	0x000007f6
 800c478:	08020418 	.word	0x08020418
 800c47c:	0801fe94 	.word	0x0801fe94

0800c480 <tcp_err>:
 * @param err callback function to call for this pcb when a fatal error
 *        has occurred on the connection
 */
void
tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
 800c480:	b580      	push	{r7, lr}
 800c482:	b082      	sub	sp, #8
 800c484:	af00      	add	r7, sp, #0
 800c486:	6078      	str	r0, [r7, #4]
 800c488:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb != NULL) {
 800c48a:	687b      	ldr	r3, [r7, #4]
 800c48c:	2b00      	cmp	r3, #0
 800c48e:	d00e      	beq.n	800c4ae <tcp_err+0x2e>
    LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
 800c490:	687b      	ldr	r3, [r7, #4]
 800c492:	7e1b      	ldrb	r3, [r3, #24]
 800c494:	2b01      	cmp	r3, #1
 800c496:	d106      	bne.n	800c4a6 <tcp_err+0x26>
 800c498:	4b07      	ldr	r3, [pc, #28]	; (800c4b8 <tcp_err+0x38>)
 800c49a:	2281      	movs	r2, #129	; 0x81
 800c49c:	0112      	lsls	r2, r2, #4
 800c49e:	4907      	ldr	r1, [pc, #28]	; (800c4bc <tcp_err+0x3c>)
 800c4a0:	4807      	ldr	r0, [pc, #28]	; (800c4c0 <tcp_err+0x40>)
 800c4a2:	f7f6 fb91 	bl	8002bc8 <app_debug_rtt_raw>
    pcb->errf = err;
 800c4a6:	687b      	ldr	r3, [r7, #4]
 800c4a8:	2194      	movs	r1, #148	; 0x94
 800c4aa:	683a      	ldr	r2, [r7, #0]
 800c4ac:	505a      	str	r2, [r3, r1]
  }
}
 800c4ae:	46c0      	nop			; (mov r8, r8)
 800c4b0:	46bd      	mov	sp, r7
 800c4b2:	b002      	add	sp, #8
 800c4b4:	bd80      	pop	{r7, pc}
 800c4b6:	46c0      	nop			; (mov r8, r8)
 800c4b8:	0801fe58 	.word	0x0801fe58
 800c4bc:	08020440 	.word	0x08020440
 800c4c0:	0801fe94 	.word	0x0801fe94

0800c4c4 <tcp_poll>:
 * the application may use the polling functionality to call tcp_write()
 * again when the connection has been idle for a while.
 */
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
 800c4c4:	b580      	push	{r7, lr}
 800c4c6:	b084      	sub	sp, #16
 800c4c8:	af00      	add	r7, sp, #0
 800c4ca:	60f8      	str	r0, [r7, #12]
 800c4cc:	60b9      	str	r1, [r7, #8]
 800c4ce:	1dfb      	adds	r3, r7, #7
 800c4d0:	701a      	strb	r2, [r3, #0]
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_poll: invalid pcb", pcb != NULL, return);
 800c4d2:	68fb      	ldr	r3, [r7, #12]
 800c4d4:	2b00      	cmp	r3, #0
 800c4d6:	d104      	bne.n	800c4e2 <tcp_poll+0x1e>
 800c4d8:	4b0d      	ldr	r3, [pc, #52]	; (800c510 <tcp_poll+0x4c>)
 800c4da:	0018      	movs	r0, r3
 800c4dc:	f7f6 fb74 	bl	8002bc8 <app_debug_rtt_raw>
 800c4e0:	e012      	b.n	800c508 <tcp_poll+0x44>
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
 800c4e2:	68fb      	ldr	r3, [r7, #12]
 800c4e4:	7e1b      	ldrb	r3, [r3, #24]
 800c4e6:	2b01      	cmp	r3, #1
 800c4e8:	d105      	bne.n	800c4f6 <tcp_poll+0x32>
 800c4ea:	4b0a      	ldr	r3, [pc, #40]	; (800c514 <tcp_poll+0x50>)
 800c4ec:	4a0a      	ldr	r2, [pc, #40]	; (800c518 <tcp_poll+0x54>)
 800c4ee:	490b      	ldr	r1, [pc, #44]	; (800c51c <tcp_poll+0x58>)
 800c4f0:	480b      	ldr	r0, [pc, #44]	; (800c520 <tcp_poll+0x5c>)
 800c4f2:	f7f6 fb69 	bl	8002bc8 <app_debug_rtt_raw>

#if LWIP_CALLBACK_API
  pcb->poll = poll;
 800c4f6:	68fb      	ldr	r3, [r7, #12]
 800c4f8:	2190      	movs	r1, #144	; 0x90
 800c4fa:	68ba      	ldr	r2, [r7, #8]
 800c4fc:	505a      	str	r2, [r3, r1]
#else /* LWIP_CALLBACK_API */
  LWIP_UNUSED_ARG(poll);
#endif /* LWIP_CALLBACK_API */
  pcb->pollinterval = interval;
 800c4fe:	68fb      	ldr	r3, [r7, #12]
 800c500:	1dfa      	adds	r2, r7, #7
 800c502:	2121      	movs	r1, #33	; 0x21
 800c504:	7812      	ldrb	r2, [r2, #0]
 800c506:	545a      	strb	r2, [r3, r1]
}
 800c508:	46bd      	mov	sp, r7
 800c50a:	b004      	add	sp, #16
 800c50c:	bd80      	pop	{r7, pc}
 800c50e:	46c0      	nop			; (mov r8, r8)
 800c510:	08020468 	.word	0x08020468
 800c514:	0801fe58 	.word	0x0801fe58
 800c518:	00000842 	.word	0x00000842
 800c51c:	08020480 	.word	0x08020480
 800c520:	0801fe94 	.word	0x0801fe94

0800c524 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
 800c524:	b580      	push	{r7, lr}
 800c526:	b082      	sub	sp, #8
 800c528:	af00      	add	r7, sp, #0
 800c52a:	6078      	str	r0, [r7, #4]
  LWIP_ERROR("tcp_pcb_purge: invalid pcb", pcb != NULL, return);
 800c52c:	687b      	ldr	r3, [r7, #4]
 800c52e:	2b00      	cmp	r3, #0
 800c530:	d104      	bne.n	800c53c <tcp_pcb_purge+0x18>
 800c532:	4b20      	ldr	r3, [pc, #128]	; (800c5b4 <tcp_pcb_purge+0x90>)
 800c534:	0018      	movs	r0, r3
 800c536:	f7f6 fb47 	bl	8002bc8 <app_debug_rtt_raw>
 800c53a:	e038      	b.n	800c5ae <tcp_pcb_purge+0x8a>

  if (pcb->state != CLOSED &&
 800c53c:	687b      	ldr	r3, [r7, #4]
 800c53e:	7e1b      	ldrb	r3, [r3, #24]
 800c540:	2b00      	cmp	r3, #0
 800c542:	d034      	beq.n	800c5ae <tcp_pcb_purge+0x8a>
      pcb->state != TIME_WAIT &&
 800c544:	687b      	ldr	r3, [r7, #4]
 800c546:	7e1b      	ldrb	r3, [r3, #24]
  if (pcb->state != CLOSED &&
 800c548:	2b0a      	cmp	r3, #10
 800c54a:	d030      	beq.n	800c5ae <tcp_pcb_purge+0x8a>
      pcb->state != LISTEN) {
 800c54c:	687b      	ldr	r3, [r7, #4]
 800c54e:	7e1b      	ldrb	r3, [r3, #24]
      pcb->state != TIME_WAIT &&
 800c550:	2b01      	cmp	r3, #1
 800c552:	d02c      	beq.n	800c5ae <tcp_pcb_purge+0x8a>

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    tcp_backlog_accepted(pcb);

    if (pcb->refused_data != NULL) {
 800c554:	687b      	ldr	r3, [r7, #4]
 800c556:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800c558:	2b00      	cmp	r3, #0
 800c55a:	d007      	beq.n	800c56c <tcp_pcb_purge+0x48>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
 800c55c:	687b      	ldr	r3, [r7, #4]
 800c55e:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800c560:	0018      	movs	r0, r3
 800c562:	f7fd fcab 	bl	8009ebc <pbuf_free>
      pcb->refused_data = NULL;
 800c566:	687b      	ldr	r3, [r7, #4]
 800c568:	2200      	movs	r2, #0
 800c56a:	67da      	str	r2, [r3, #124]	; 0x7c
    }
    if (pcb->unacked != NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->unacked\n"));
    }
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
 800c56c:	687b      	ldr	r3, [r7, #4]
 800c56e:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800c570:	2b00      	cmp	r3, #0
 800c572:	d003      	beq.n	800c57c <tcp_pcb_purge+0x58>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
      tcp_free_ooseq(pcb);
 800c574:	687b      	ldr	r3, [r7, #4]
 800c576:	0018      	movs	r0, r3
 800c578:	f000 f9a4 	bl	800c8c4 <tcp_free_ooseq>
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
 800c57c:	687b      	ldr	r3, [r7, #4]
 800c57e:	2201      	movs	r2, #1
 800c580:	4252      	negs	r2, r2
 800c582:	869a      	strh	r2, [r3, #52]	; 0x34

    tcp_segs_free(pcb->unsent);
 800c584:	687b      	ldr	r3, [r7, #4]
 800c586:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800c588:	0018      	movs	r0, r3
 800c58a:	f7ff fced 	bl	800bf68 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
 800c58e:	687b      	ldr	r3, [r7, #4]
 800c590:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800c592:	0018      	movs	r0, r3
 800c594:	f7ff fce8 	bl	800bf68 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
 800c598:	687b      	ldr	r3, [r7, #4]
 800c59a:	2200      	movs	r2, #0
 800c59c:	671a      	str	r2, [r3, #112]	; 0x70
 800c59e:	687b      	ldr	r3, [r7, #4]
 800c5a0:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800c5a2:	687b      	ldr	r3, [r7, #4]
 800c5a4:	675a      	str	r2, [r3, #116]	; 0x74
#if TCP_OVERSIZE
    pcb->unsent_oversize = 0;
 800c5a6:	687b      	ldr	r3, [r7, #4]
 800c5a8:	226c      	movs	r2, #108	; 0x6c
 800c5aa:	2100      	movs	r1, #0
 800c5ac:	5299      	strh	r1, [r3, r2]
#endif /* TCP_OVERSIZE */
  }
}
 800c5ae:	46bd      	mov	sp, r7
 800c5b0:	b002      	add	sp, #8
 800c5b2:	bd80      	pop	{r7, pc}
 800c5b4:	080204a0 	.word	0x080204a0

0800c5b8 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
 800c5b8:	b580      	push	{r7, lr}
 800c5ba:	b084      	sub	sp, #16
 800c5bc:	af00      	add	r7, sp, #0
 800c5be:	6078      	str	r0, [r7, #4]
 800c5c0:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT("tcp_pcb_remove: invalid pcb", pcb != NULL);
 800c5c2:	683b      	ldr	r3, [r7, #0]
 800c5c4:	2b00      	cmp	r3, #0
 800c5c6:	d105      	bne.n	800c5d4 <tcp_pcb_remove+0x1c>
 800c5c8:	4b3c      	ldr	r3, [pc, #240]	; (800c6bc <tcp_pcb_remove+0x104>)
 800c5ca:	4a3d      	ldr	r2, [pc, #244]	; (800c6c0 <tcp_pcb_remove+0x108>)
 800c5cc:	493d      	ldr	r1, [pc, #244]	; (800c6c4 <tcp_pcb_remove+0x10c>)
 800c5ce:	483e      	ldr	r0, [pc, #248]	; (800c6c8 <tcp_pcb_remove+0x110>)
 800c5d0:	f7f6 fafa 	bl	8002bc8 <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_pcb_remove: invalid pcblist", pcblist != NULL);
 800c5d4:	687b      	ldr	r3, [r7, #4]
 800c5d6:	2b00      	cmp	r3, #0
 800c5d8:	d105      	bne.n	800c5e6 <tcp_pcb_remove+0x2e>
 800c5da:	4b38      	ldr	r3, [pc, #224]	; (800c6bc <tcp_pcb_remove+0x104>)
 800c5dc:	4a3b      	ldr	r2, [pc, #236]	; (800c6cc <tcp_pcb_remove+0x114>)
 800c5de:	493c      	ldr	r1, [pc, #240]	; (800c6d0 <tcp_pcb_remove+0x118>)
 800c5e0:	4839      	ldr	r0, [pc, #228]	; (800c6c8 <tcp_pcb_remove+0x110>)
 800c5e2:	f7f6 faf1 	bl	8002bc8 <app_debug_rtt_raw>

  TCP_RMV(pcblist, pcb);
 800c5e6:	687b      	ldr	r3, [r7, #4]
 800c5e8:	681b      	ldr	r3, [r3, #0]
 800c5ea:	683a      	ldr	r2, [r7, #0]
 800c5ec:	429a      	cmp	r2, r3
 800c5ee:	d105      	bne.n	800c5fc <tcp_pcb_remove+0x44>
 800c5f0:	687b      	ldr	r3, [r7, #4]
 800c5f2:	681b      	ldr	r3, [r3, #0]
 800c5f4:	691a      	ldr	r2, [r3, #16]
 800c5f6:	687b      	ldr	r3, [r7, #4]
 800c5f8:	601a      	str	r2, [r3, #0]
 800c5fa:	e013      	b.n	800c624 <tcp_pcb_remove+0x6c>
 800c5fc:	687b      	ldr	r3, [r7, #4]
 800c5fe:	681b      	ldr	r3, [r3, #0]
 800c600:	60fb      	str	r3, [r7, #12]
 800c602:	e00c      	b.n	800c61e <tcp_pcb_remove+0x66>
 800c604:	68fb      	ldr	r3, [r7, #12]
 800c606:	691b      	ldr	r3, [r3, #16]
 800c608:	683a      	ldr	r2, [r7, #0]
 800c60a:	429a      	cmp	r2, r3
 800c60c:	d104      	bne.n	800c618 <tcp_pcb_remove+0x60>
 800c60e:	683b      	ldr	r3, [r7, #0]
 800c610:	691a      	ldr	r2, [r3, #16]
 800c612:	68fb      	ldr	r3, [r7, #12]
 800c614:	611a      	str	r2, [r3, #16]
 800c616:	e005      	b.n	800c624 <tcp_pcb_remove+0x6c>
 800c618:	68fb      	ldr	r3, [r7, #12]
 800c61a:	691b      	ldr	r3, [r3, #16]
 800c61c:	60fb      	str	r3, [r7, #12]
 800c61e:	68fb      	ldr	r3, [r7, #12]
 800c620:	2b00      	cmp	r3, #0
 800c622:	d1ef      	bne.n	800c604 <tcp_pcb_remove+0x4c>
 800c624:	683b      	ldr	r3, [r7, #0]
 800c626:	2200      	movs	r2, #0
 800c628:	611a      	str	r2, [r3, #16]

  tcp_pcb_purge(pcb);
 800c62a:	683b      	ldr	r3, [r7, #0]
 800c62c:	0018      	movs	r0, r3
 800c62e:	f7ff ff79 	bl	800c524 <tcp_pcb_purge>

  /* if there is an outstanding delayed ACKs, send it */
  if ((pcb->state != TIME_WAIT) &&
 800c632:	683b      	ldr	r3, [r7, #0]
 800c634:	7e1b      	ldrb	r3, [r3, #24]
 800c636:	2b0a      	cmp	r3, #10
 800c638:	d014      	beq.n	800c664 <tcp_pcb_remove+0xac>
      (pcb->state != LISTEN) &&
 800c63a:	683b      	ldr	r3, [r7, #0]
 800c63c:	7e1b      	ldrb	r3, [r3, #24]
  if ((pcb->state != TIME_WAIT) &&
 800c63e:	2b01      	cmp	r3, #1
 800c640:	d010      	beq.n	800c664 <tcp_pcb_remove+0xac>
      (pcb->flags & TF_ACK_DELAY)) {
 800c642:	683b      	ldr	r3, [r7, #0]
 800c644:	8bdb      	ldrh	r3, [r3, #30]
 800c646:	001a      	movs	r2, r3
 800c648:	2301      	movs	r3, #1
 800c64a:	4013      	ands	r3, r2
      (pcb->state != LISTEN) &&
 800c64c:	d00a      	beq.n	800c664 <tcp_pcb_remove+0xac>
    tcp_ack_now(pcb);
 800c64e:	683b      	ldr	r3, [r7, #0]
 800c650:	8bdb      	ldrh	r3, [r3, #30]
 800c652:	2202      	movs	r2, #2
 800c654:	4313      	orrs	r3, r2
 800c656:	b29a      	uxth	r2, r3
 800c658:	683b      	ldr	r3, [r7, #0]
 800c65a:	83da      	strh	r2, [r3, #30]
    tcp_output(pcb);
 800c65c:	683b      	ldr	r3, [r7, #0]
 800c65e:	0018      	movs	r0, r3
 800c660:	f004 fb8c 	bl	8010d7c <tcp_output>
  }

  if (pcb->state != LISTEN) {
 800c664:	683b      	ldr	r3, [r7, #0]
 800c666:	7e1b      	ldrb	r3, [r3, #24]
 800c668:	2b01      	cmp	r3, #1
 800c66a:	d01d      	beq.n	800c6a8 <tcp_pcb_remove+0xf0>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
 800c66c:	683b      	ldr	r3, [r7, #0]
 800c66e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800c670:	2b00      	cmp	r3, #0
 800c672:	d005      	beq.n	800c680 <tcp_pcb_remove+0xc8>
 800c674:	4b11      	ldr	r3, [pc, #68]	; (800c6bc <tcp_pcb_remove+0x104>)
 800c676:	4a17      	ldr	r2, [pc, #92]	; (800c6d4 <tcp_pcb_remove+0x11c>)
 800c678:	4917      	ldr	r1, [pc, #92]	; (800c6d8 <tcp_pcb_remove+0x120>)
 800c67a:	4813      	ldr	r0, [pc, #76]	; (800c6c8 <tcp_pcb_remove+0x110>)
 800c67c:	f7f6 faa4 	bl	8002bc8 <app_debug_rtt_raw>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
 800c680:	683b      	ldr	r3, [r7, #0]
 800c682:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800c684:	2b00      	cmp	r3, #0
 800c686:	d005      	beq.n	800c694 <tcp_pcb_remove+0xdc>
 800c688:	4b0c      	ldr	r3, [pc, #48]	; (800c6bc <tcp_pcb_remove+0x104>)
 800c68a:	4a14      	ldr	r2, [pc, #80]	; (800c6dc <tcp_pcb_remove+0x124>)
 800c68c:	4914      	ldr	r1, [pc, #80]	; (800c6e0 <tcp_pcb_remove+0x128>)
 800c68e:	480e      	ldr	r0, [pc, #56]	; (800c6c8 <tcp_pcb_remove+0x110>)
 800c690:	f7f6 fa9a 	bl	8002bc8 <app_debug_rtt_raw>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
 800c694:	683b      	ldr	r3, [r7, #0]
 800c696:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800c698:	2b00      	cmp	r3, #0
 800c69a:	d005      	beq.n	800c6a8 <tcp_pcb_remove+0xf0>
 800c69c:	4b07      	ldr	r3, [pc, #28]	; (800c6bc <tcp_pcb_remove+0x104>)
 800c69e:	4a11      	ldr	r2, [pc, #68]	; (800c6e4 <tcp_pcb_remove+0x12c>)
 800c6a0:	4911      	ldr	r1, [pc, #68]	; (800c6e8 <tcp_pcb_remove+0x130>)
 800c6a2:	4809      	ldr	r0, [pc, #36]	; (800c6c8 <tcp_pcb_remove+0x110>)
 800c6a4:	f7f6 fa90 	bl	8002bc8 <app_debug_rtt_raw>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
 800c6a8:	683b      	ldr	r3, [r7, #0]
 800c6aa:	2200      	movs	r2, #0
 800c6ac:	761a      	strb	r2, [r3, #24]
  /* reset the local port to prevent the pcb from being 'bound' */
  pcb->local_port = 0;
 800c6ae:	683b      	ldr	r3, [r7, #0]
 800c6b0:	2200      	movs	r2, #0
 800c6b2:	835a      	strh	r2, [r3, #26]

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
 800c6b4:	46c0      	nop			; (mov r8, r8)
 800c6b6:	46bd      	mov	sp, r7
 800c6b8:	b004      	add	sp, #16
 800c6ba:	bd80      	pop	{r7, pc}
 800c6bc:	0801fe58 	.word	0x0801fe58
 800c6c0:	00000887 	.word	0x00000887
 800c6c4:	080204bc 	.word	0x080204bc
 800c6c8:	0801fe94 	.word	0x0801fe94
 800c6cc:	00000888 	.word	0x00000888
 800c6d0:	080204d8 	.word	0x080204d8
 800c6d4:	00000897 	.word	0x00000897
 800c6d8:	080204f8 	.word	0x080204f8
 800c6dc:	00000898 	.word	0x00000898
 800c6e0:	08020510 	.word	0x08020510
 800c6e4:	0000089a 	.word	0x0000089a
 800c6e8:	0802052c 	.word	0x0802052c

0800c6ec <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(struct tcp_pcb *pcb)
{
 800c6ec:	b580      	push	{r7, lr}
 800c6ee:	b082      	sub	sp, #8
 800c6f0:	af00      	add	r7, sp, #0
 800c6f2:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_next_iss: invalid pcb", pcb != NULL);
  return LWIP_HOOK_TCP_ISN(&pcb->local_ip, pcb->local_port, &pcb->remote_ip, pcb->remote_port);
#else /* LWIP_HOOK_TCP_ISN */
  static u32_t iss = 6510;

  LWIP_ASSERT("tcp_next_iss: invalid pcb", pcb != NULL);
 800c6f4:	687b      	ldr	r3, [r7, #4]
 800c6f6:	2b00      	cmp	r3, #0
 800c6f8:	d105      	bne.n	800c706 <tcp_next_iss+0x1a>
 800c6fa:	4b09      	ldr	r3, [pc, #36]	; (800c720 <tcp_next_iss+0x34>)
 800c6fc:	4a09      	ldr	r2, [pc, #36]	; (800c724 <tcp_next_iss+0x38>)
 800c6fe:	490a      	ldr	r1, [pc, #40]	; (800c728 <tcp_next_iss+0x3c>)
 800c700:	480a      	ldr	r0, [pc, #40]	; (800c72c <tcp_next_iss+0x40>)
 800c702:	f7f6 fa61 	bl	8002bc8 <app_debug_rtt_raw>
  LWIP_UNUSED_ARG(pcb);

  iss += tcp_ticks;       /* XXX */
 800c706:	4b0a      	ldr	r3, [pc, #40]	; (800c730 <tcp_next_iss+0x44>)
 800c708:	681a      	ldr	r2, [r3, #0]
 800c70a:	4b0a      	ldr	r3, [pc, #40]	; (800c734 <tcp_next_iss+0x48>)
 800c70c:	681b      	ldr	r3, [r3, #0]
 800c70e:	18d2      	adds	r2, r2, r3
 800c710:	4b07      	ldr	r3, [pc, #28]	; (800c730 <tcp_next_iss+0x44>)
 800c712:	601a      	str	r2, [r3, #0]
  return iss;
 800c714:	4b06      	ldr	r3, [pc, #24]	; (800c730 <tcp_next_iss+0x44>)
 800c716:	681b      	ldr	r3, [r3, #0]
#endif /* LWIP_HOOK_TCP_ISN */
}
 800c718:	0018      	movs	r0, r3
 800c71a:	46bd      	mov	sp, r7
 800c71c:	b002      	add	sp, #8
 800c71e:	bd80      	pop	{r7, pc}
 800c720:	0801fe58 	.word	0x0801fe58
 800c724:	000008b3 	.word	0x000008b3
 800c728:	08020544 	.word	0x08020544
 800c72c:	0801fe94 	.word	0x0801fe94
 800c730:	2000001c 	.word	0x2000001c
 800c734:	20002b40 	.word	0x20002b40

0800c738 <tcp_eff_send_mss_netif>:
 * by calculating the minimum of TCP_MSS and the mtu (if set) of the target
 * netif (if not NULL).
 */
u16_t
tcp_eff_send_mss_netif(u16_t sendmss, struct netif *outif, const ip_addr_t *dest)
{
 800c738:	b590      	push	{r4, r7, lr}
 800c73a:	b087      	sub	sp, #28
 800c73c:	af00      	add	r7, sp, #0
 800c73e:	60b9      	str	r1, [r7, #8]
 800c740:	607a      	str	r2, [r7, #4]
 800c742:	230e      	movs	r3, #14
 800c744:	18fb      	adds	r3, r7, r3
 800c746:	1c02      	adds	r2, r0, #0
 800c748:	801a      	strh	r2, [r3, #0]
  u16_t mss_s;
  u16_t mtu;

  LWIP_UNUSED_ARG(dest); /* in case IPv6 is disabled */

  LWIP_ASSERT("tcp_eff_send_mss_netif: invalid dst_ip", dest != NULL);
 800c74a:	687b      	ldr	r3, [r7, #4]
 800c74c:	2b00      	cmp	r3, #0
 800c74e:	d105      	bne.n	800c75c <tcp_eff_send_mss_netif+0x24>
 800c750:	4b1e      	ldr	r3, [pc, #120]	; (800c7cc <tcp_eff_send_mss_netif+0x94>)
 800c752:	4a1f      	ldr	r2, [pc, #124]	; (800c7d0 <tcp_eff_send_mss_netif+0x98>)
 800c754:	491f      	ldr	r1, [pc, #124]	; (800c7d4 <tcp_eff_send_mss_netif+0x9c>)
 800c756:	4820      	ldr	r0, [pc, #128]	; (800c7d8 <tcp_eff_send_mss_netif+0xa0>)
 800c758:	f7f6 fa36 	bl	8002bc8 <app_debug_rtt_raw>
  else
#endif /* LWIP_IPV4 */
#endif /* LWIP_IPV6 */
#if LWIP_IPV4
  {
    if (outif == NULL) {
 800c75c:	68bb      	ldr	r3, [r7, #8]
 800c75e:	2b00      	cmp	r3, #0
 800c760:	d103      	bne.n	800c76a <tcp_eff_send_mss_netif+0x32>
      return sendmss;
 800c762:	230e      	movs	r3, #14
 800c764:	18fb      	adds	r3, r7, r3
 800c766:	881b      	ldrh	r3, [r3, #0]
 800c768:	e02c      	b.n	800c7c4 <tcp_eff_send_mss_netif+0x8c>
    }
    mtu = outif->mtu;
 800c76a:	2116      	movs	r1, #22
 800c76c:	187b      	adds	r3, r7, r1
 800c76e:	68ba      	ldr	r2, [r7, #8]
 800c770:	8d12      	ldrh	r2, [r2, #40]	; 0x28
 800c772:	801a      	strh	r2, [r3, #0]
  }
#endif /* LWIP_IPV4 */

  if (mtu != 0) {
 800c774:	187b      	adds	r3, r7, r1
 800c776:	881b      	ldrh	r3, [r3, #0]
 800c778:	2b00      	cmp	r3, #0
 800c77a:	d020      	beq.n	800c7be <tcp_eff_send_mss_netif+0x86>
    else
#endif /* LWIP_IPV4 */
#endif /* LWIP_IPV6 */
#if LWIP_IPV4
    {
      offset = IP_HLEN + TCP_HLEN;
 800c77c:	2014      	movs	r0, #20
 800c77e:	183b      	adds	r3, r7, r0
 800c780:	2228      	movs	r2, #40	; 0x28
 800c782:	801a      	strh	r2, [r3, #0]
    }
#endif /* LWIP_IPV4 */
    mss_s = (mtu > offset) ? (u16_t)(mtu - offset) : 0;
 800c784:	187a      	adds	r2, r7, r1
 800c786:	183b      	adds	r3, r7, r0
 800c788:	8812      	ldrh	r2, [r2, #0]
 800c78a:	881b      	ldrh	r3, [r3, #0]
 800c78c:	429a      	cmp	r2, r3
 800c78e:	d906      	bls.n	800c79e <tcp_eff_send_mss_netif+0x66>
 800c790:	187a      	adds	r2, r7, r1
 800c792:	183b      	adds	r3, r7, r0
 800c794:	8812      	ldrh	r2, [r2, #0]
 800c796:	881b      	ldrh	r3, [r3, #0]
 800c798:	1ad3      	subs	r3, r2, r3
 800c79a:	b29a      	uxth	r2, r3
 800c79c:	e000      	b.n	800c7a0 <tcp_eff_send_mss_netif+0x68>
 800c79e:	2200      	movs	r2, #0
 800c7a0:	2112      	movs	r1, #18
 800c7a2:	187b      	adds	r3, r7, r1
 800c7a4:	801a      	strh	r2, [r3, #0]
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * We correct for TCP options in tcp_write(), and don't support IP options.
     */
    sendmss = LWIP_MIN(sendmss, mss_s);
 800c7a6:	200e      	movs	r0, #14
 800c7a8:	183a      	adds	r2, r7, r0
 800c7aa:	187b      	adds	r3, r7, r1
 800c7ac:	1839      	adds	r1, r7, r0
 800c7ae:	880c      	ldrh	r4, [r1, #0]
 800c7b0:	881b      	ldrh	r3, [r3, #0]
 800c7b2:	b298      	uxth	r0, r3
 800c7b4:	b2a1      	uxth	r1, r4
 800c7b6:	4288      	cmp	r0, r1
 800c7b8:	d900      	bls.n	800c7bc <tcp_eff_send_mss_netif+0x84>
 800c7ba:	1c23      	adds	r3, r4, #0
 800c7bc:	8013      	strh	r3, [r2, #0]
  }
  return sendmss;
 800c7be:	230e      	movs	r3, #14
 800c7c0:	18fb      	adds	r3, r7, r3
 800c7c2:	881b      	ldrh	r3, [r3, #0]
}
 800c7c4:	0018      	movs	r0, r3
 800c7c6:	46bd      	mov	sp, r7
 800c7c8:	b007      	add	sp, #28
 800c7ca:	bd90      	pop	{r4, r7, pc}
 800c7cc:	0801fe58 	.word	0x0801fe58
 800c7d0:	000008c9 	.word	0x000008c9
 800c7d4:	08020560 	.word	0x08020560
 800c7d8:	0801fe94 	.word	0x0801fe94

0800c7dc <tcp_netif_ip_addr_changed_pcblist>:
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

/** Helper function for tcp_netif_ip_addr_changed() that iterates a pcb list */
static void
tcp_netif_ip_addr_changed_pcblist(const ip_addr_t *old_addr, struct tcp_pcb *pcb_list)
{
 800c7dc:	b580      	push	{r7, lr}
 800c7de:	b084      	sub	sp, #16
 800c7e0:	af00      	add	r7, sp, #0
 800c7e2:	6078      	str	r0, [r7, #4]
 800c7e4:	6039      	str	r1, [r7, #0]
  struct tcp_pcb *pcb;
  pcb = pcb_list;
 800c7e6:	683b      	ldr	r3, [r7, #0]
 800c7e8:	60fb      	str	r3, [r7, #12]

  LWIP_ASSERT("tcp_netif_ip_addr_changed_pcblist: invalid old_addr", old_addr != NULL);
 800c7ea:	687b      	ldr	r3, [r7, #4]
 800c7ec:	2b00      	cmp	r3, #0
 800c7ee:	d119      	bne.n	800c824 <tcp_netif_ip_addr_changed_pcblist+0x48>
 800c7f0:	4b10      	ldr	r3, [pc, #64]	; (800c834 <tcp_netif_ip_addr_changed_pcblist+0x58>)
 800c7f2:	4a11      	ldr	r2, [pc, #68]	; (800c838 <tcp_netif_ip_addr_changed_pcblist+0x5c>)
 800c7f4:	4911      	ldr	r1, [pc, #68]	; (800c83c <tcp_netif_ip_addr_changed_pcblist+0x60>)
 800c7f6:	4812      	ldr	r0, [pc, #72]	; (800c840 <tcp_netif_ip_addr_changed_pcblist+0x64>)
 800c7f8:	f7f6 f9e6 	bl	8002bc8 <app_debug_rtt_raw>

  while (pcb != NULL) {
 800c7fc:	e012      	b.n	800c824 <tcp_netif_ip_addr_changed_pcblist+0x48>
    /* PCB bound to current local interface address? */
    if (ip_addr_cmp(&pcb->local_ip, old_addr)
 800c7fe:	68fb      	ldr	r3, [r7, #12]
 800c800:	681a      	ldr	r2, [r3, #0]
 800c802:	687b      	ldr	r3, [r7, #4]
 800c804:	681b      	ldr	r3, [r3, #0]
 800c806:	429a      	cmp	r2, r3
 800c808:	d109      	bne.n	800c81e <tcp_netif_ip_addr_changed_pcblist+0x42>
        /* connections to link-local addresses must persist (RFC3927 ch. 1.9) */
        && (!IP_IS_V4_VAL(pcb->local_ip) || !ip4_addr_islinklocal(ip_2_ip4(&pcb->local_ip)))
#endif /* LWIP_AUTOIP */
       ) {
      /* this connection must be aborted */
      struct tcp_pcb *next = pcb->next;
 800c80a:	68fb      	ldr	r3, [r7, #12]
 800c80c:	691b      	ldr	r3, [r3, #16]
 800c80e:	60bb      	str	r3, [r7, #8]
      LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
      tcp_abort(pcb);
 800c810:	68fb      	ldr	r3, [r7, #12]
 800c812:	0018      	movs	r0, r3
 800c814:	f7fe fcbe 	bl	800b194 <tcp_abort>
      pcb = next;
 800c818:	68bb      	ldr	r3, [r7, #8]
 800c81a:	60fb      	str	r3, [r7, #12]
 800c81c:	e002      	b.n	800c824 <tcp_netif_ip_addr_changed_pcblist+0x48>
    } else {
      pcb = pcb->next;
 800c81e:	68fb      	ldr	r3, [r7, #12]
 800c820:	691b      	ldr	r3, [r3, #16]
 800c822:	60fb      	str	r3, [r7, #12]
  while (pcb != NULL) {
 800c824:	68fb      	ldr	r3, [r7, #12]
 800c826:	2b00      	cmp	r3, #0
 800c828:	d1e9      	bne.n	800c7fe <tcp_netif_ip_addr_changed_pcblist+0x22>
    }
  }
}
 800c82a:	46c0      	nop			; (mov r8, r8)
 800c82c:	46c0      	nop			; (mov r8, r8)
 800c82e:	46bd      	mov	sp, r7
 800c830:	b004      	add	sp, #16
 800c832:	bd80      	pop	{r7, pc}
 800c834:	0801fe58 	.word	0x0801fe58
 800c838:	00000904 	.word	0x00000904
 800c83c:	08020588 	.word	0x08020588
 800c840:	0801fe94 	.word	0x0801fe94

0800c844 <tcp_netif_ip_addr_changed>:
 * @param old_addr IP address of the netif before change
 * @param new_addr IP address of the netif after change or NULL if netif has been removed
 */
void
tcp_netif_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_addr)
{
 800c844:	b580      	push	{r7, lr}
 800c846:	b084      	sub	sp, #16
 800c848:	af00      	add	r7, sp, #0
 800c84a:	6078      	str	r0, [r7, #4]
 800c84c:	6039      	str	r1, [r7, #0]
  struct tcp_pcb_listen *lpcb;

  if (!ip_addr_isany(old_addr)) {
 800c84e:	687b      	ldr	r3, [r7, #4]
 800c850:	2b00      	cmp	r3, #0
 800c852:	d02c      	beq.n	800c8ae <tcp_netif_ip_addr_changed+0x6a>
 800c854:	687b      	ldr	r3, [r7, #4]
 800c856:	681b      	ldr	r3, [r3, #0]
 800c858:	2b00      	cmp	r3, #0
 800c85a:	d028      	beq.n	800c8ae <tcp_netif_ip_addr_changed+0x6a>
    tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_active_pcbs);
 800c85c:	4b16      	ldr	r3, [pc, #88]	; (800c8b8 <tcp_netif_ip_addr_changed+0x74>)
 800c85e:	681a      	ldr	r2, [r3, #0]
 800c860:	687b      	ldr	r3, [r7, #4]
 800c862:	0011      	movs	r1, r2
 800c864:	0018      	movs	r0, r3
 800c866:	f7ff ffb9 	bl	800c7dc <tcp_netif_ip_addr_changed_pcblist>
    tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_bound_pcbs);
 800c86a:	4b14      	ldr	r3, [pc, #80]	; (800c8bc <tcp_netif_ip_addr_changed+0x78>)
 800c86c:	681a      	ldr	r2, [r3, #0]
 800c86e:	687b      	ldr	r3, [r7, #4]
 800c870:	0011      	movs	r1, r2
 800c872:	0018      	movs	r0, r3
 800c874:	f7ff ffb2 	bl	800c7dc <tcp_netif_ip_addr_changed_pcblist>

    if (!ip_addr_isany(new_addr)) {
 800c878:	683b      	ldr	r3, [r7, #0]
 800c87a:	2b00      	cmp	r3, #0
 800c87c:	d017      	beq.n	800c8ae <tcp_netif_ip_addr_changed+0x6a>
 800c87e:	683b      	ldr	r3, [r7, #0]
 800c880:	681b      	ldr	r3, [r3, #0]
 800c882:	2b00      	cmp	r3, #0
 800c884:	d013      	beq.n	800c8ae <tcp_netif_ip_addr_changed+0x6a>
      /* PCB bound to current local interface address? */
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 800c886:	4b0e      	ldr	r3, [pc, #56]	; (800c8c0 <tcp_netif_ip_addr_changed+0x7c>)
 800c888:	681b      	ldr	r3, [r3, #0]
 800c88a:	60fb      	str	r3, [r7, #12]
 800c88c:	e00c      	b.n	800c8a8 <tcp_netif_ip_addr_changed+0x64>
        /* PCB bound to current local interface address? */
        if (ip_addr_cmp(&lpcb->local_ip, old_addr)) {
 800c88e:	68fb      	ldr	r3, [r7, #12]
 800c890:	681a      	ldr	r2, [r3, #0]
 800c892:	687b      	ldr	r3, [r7, #4]
 800c894:	681b      	ldr	r3, [r3, #0]
 800c896:	429a      	cmp	r2, r3
 800c898:	d103      	bne.n	800c8a2 <tcp_netif_ip_addr_changed+0x5e>
          /* The PCB is listening to the old ipaddr and
            * is set to listen to the new one instead */
          ip_addr_copy(lpcb->local_ip, *new_addr);
 800c89a:	683b      	ldr	r3, [r7, #0]
 800c89c:	681a      	ldr	r2, [r3, #0]
 800c89e:	68fb      	ldr	r3, [r7, #12]
 800c8a0:	601a      	str	r2, [r3, #0]
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 800c8a2:	68fb      	ldr	r3, [r7, #12]
 800c8a4:	691b      	ldr	r3, [r3, #16]
 800c8a6:	60fb      	str	r3, [r7, #12]
 800c8a8:	68fb      	ldr	r3, [r7, #12]
 800c8aa:	2b00      	cmp	r3, #0
 800c8ac:	d1ef      	bne.n	800c88e <tcp_netif_ip_addr_changed+0x4a>
        }
      }
    }
  }
}
 800c8ae:	46c0      	nop			; (mov r8, r8)
 800c8b0:	46bd      	mov	sp, r7
 800c8b2:	b004      	add	sp, #16
 800c8b4:	bd80      	pop	{r7, pc}
 800c8b6:	46c0      	nop			; (mov r8, r8)
 800c8b8:	20002b3c 	.word	0x20002b3c
 800c8bc:	20002b48 	.word	0x20002b48
 800c8c0:	20002b44 	.word	0x20002b44

0800c8c4 <tcp_free_ooseq>:

#if TCP_QUEUE_OOSEQ
/* Free all ooseq pbufs (and possibly reset SACK state) */
void
tcp_free_ooseq(struct tcp_pcb *pcb)
{
 800c8c4:	b580      	push	{r7, lr}
 800c8c6:	b082      	sub	sp, #8
 800c8c8:	af00      	add	r7, sp, #0
 800c8ca:	6078      	str	r0, [r7, #4]
  if (pcb->ooseq) {
 800c8cc:	687b      	ldr	r3, [r7, #4]
 800c8ce:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800c8d0:	2b00      	cmp	r3, #0
 800c8d2:	d007      	beq.n	800c8e4 <tcp_free_ooseq+0x20>
    tcp_segs_free(pcb->ooseq);
 800c8d4:	687b      	ldr	r3, [r7, #4]
 800c8d6:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800c8d8:	0018      	movs	r0, r3
 800c8da:	f7ff fb45 	bl	800bf68 <tcp_segs_free>
    pcb->ooseq = NULL;
 800c8de:	687b      	ldr	r3, [r7, #4]
 800c8e0:	2200      	movs	r2, #0
 800c8e2:	679a      	str	r2, [r3, #120]	; 0x78
#if LWIP_TCP_SACK_OUT
    memset(pcb->rcv_sacks, 0, sizeof(pcb->rcv_sacks));
#endif /* LWIP_TCP_SACK_OUT */
  }
}
 800c8e4:	46c0      	nop			; (mov r8, r8)
 800c8e6:	46bd      	mov	sp, r7
 800c8e8:	b002      	add	sp, #8
 800c8ea:	bd80      	pop	{r7, pc}

0800c8ec <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the TCP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
 800c8ec:	b5f0      	push	{r4, r5, r6, r7, lr}
 800c8ee:	b08f      	sub	sp, #60	; 0x3c
 800c8f0:	af04      	add	r7, sp, #16
 800c8f2:	6078      	str	r0, [r7, #4]
 800c8f4:	6039      	str	r1, [r7, #0]
  struct tcp_pcb *pcb, *prev;
  struct tcp_pcb_listen *lpcb;
#if SO_REUSE
  struct tcp_pcb *lpcb_prev = NULL;
 800c8f6:	2300      	movs	r3, #0
 800c8f8:	61bb      	str	r3, [r7, #24]
  struct tcp_pcb_listen *lpcb_any = NULL;
 800c8fa:	2300      	movs	r3, #0
 800c8fc:	617b      	str	r3, [r7, #20]
  u8_t hdrlen_bytes;
  err_t err;

  LWIP_UNUSED_ARG(inp);
  LWIP_ASSERT_CORE_LOCKED();
  LWIP_ASSERT("tcp_input: invalid pbuf", p != NULL);
 800c8fe:	687b      	ldr	r3, [r7, #4]
 800c900:	2b00      	cmp	r3, #0
 800c902:	d105      	bne.n	800c910 <tcp_input+0x24>
 800c904:	4b3a      	ldr	r3, [pc, #232]	; (800c9f0 <tcp_input+0x104>)
 800c906:	493b      	ldr	r1, [pc, #236]	; (800c9f4 <tcp_input+0x108>)
 800c908:	483b      	ldr	r0, [pc, #236]	; (800c9f8 <tcp_input+0x10c>)
 800c90a:	2283      	movs	r2, #131	; 0x83
 800c90c:	f7f6 f95c 	bl	8002bc8 <app_debug_rtt_raw>
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  MIB2_STATS_INC(mib2.tcpinsegs);

  tcphdr = (struct tcp_hdr *)p->payload;
 800c910:	687b      	ldr	r3, [r7, #4]
 800c912:	685a      	ldr	r2, [r3, #4]
 800c914:	4b39      	ldr	r3, [pc, #228]	; (800c9fc <tcp_input+0x110>)
 800c916:	601a      	str	r2, [r3, #0]
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* Check that TCP header fits in payload */
  if (p->len < TCP_HLEN) {
 800c918:	687b      	ldr	r3, [r7, #4]
 800c91a:	895b      	ldrh	r3, [r3, #10]
 800c91c:	2b13      	cmp	r3, #19
 800c91e:	d801      	bhi.n	800c924 <tcp_input+0x38>
 800c920:	f000 fd03 	bl	800d32a <tcp_input+0xa3e>
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||
 800c924:	4b36      	ldr	r3, [pc, #216]	; (800ca00 <tcp_input+0x114>)
 800c926:	695a      	ldr	r2, [r3, #20]
 800c928:	4b35      	ldr	r3, [pc, #212]	; (800ca00 <tcp_input+0x114>)
 800c92a:	681b      	ldr	r3, [r3, #0]
 800c92c:	0019      	movs	r1, r3
 800c92e:	0010      	movs	r0, r2
 800c930:	f007 fa74 	bl	8013e1c <ip4_addr_isbroadcast_u32>
 800c934:	1e03      	subs	r3, r0, #0
 800c936:	d001      	beq.n	800c93c <tcp_input+0x50>
 800c938:	f000 fcf9 	bl	800d32e <tcp_input+0xa42>
      ip_addr_ismulticast(ip_current_dest_addr())) {
 800c93c:	4b30      	ldr	r3, [pc, #192]	; (800ca00 <tcp_input+0x114>)
 800c93e:	695b      	ldr	r3, [r3, #20]
 800c940:	22f0      	movs	r2, #240	; 0xf0
 800c942:	4013      	ands	r3, r2
  if (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||
 800c944:	2be0      	cmp	r3, #224	; 0xe0
 800c946:	d101      	bne.n	800c94c <tcp_input+0x60>
 800c948:	f000 fcf1 	bl	800d32e <tcp_input+0xa42>
  }

#if CHECKSUM_CHECK_TCP
  IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_TCP) {
    /* Verify TCP checksum. */
    u16_t chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
 800c94c:	687b      	ldr	r3, [r7, #4]
 800c94e:	891a      	ldrh	r2, [r3, #8]
 800c950:	2510      	movs	r5, #16
 800c952:	197c      	adds	r4, r7, r5
 800c954:	492b      	ldr	r1, [pc, #172]	; (800ca04 <tcp_input+0x118>)
 800c956:	6878      	ldr	r0, [r7, #4]
 800c958:	4b2b      	ldr	r3, [pc, #172]	; (800ca08 <tcp_input+0x11c>)
 800c95a:	9300      	str	r3, [sp, #0]
 800c95c:	000b      	movs	r3, r1
 800c95e:	2106      	movs	r1, #6
 800c960:	f7fb fd4f 	bl	8008402 <ip_chksum_pseudo>
 800c964:	0003      	movs	r3, r0
 800c966:	8023      	strh	r3, [r4, #0]
                                    ip_current_src_addr(), ip_current_dest_addr());
    if (chksum != 0) {
 800c968:	197b      	adds	r3, r7, r5
 800c96a:	881b      	ldrh	r3, [r3, #0]
 800c96c:	2b00      	cmp	r3, #0
 800c96e:	d001      	beq.n	800c974 <tcp_input+0x88>
 800c970:	f000 fcdf 	bl	800d332 <tcp_input+0xa46>
    }
  }
#endif /* CHECKSUM_CHECK_TCP */

  /* sanity-check header length */
  hdrlen_bytes = TCPH_HDRLEN_BYTES(tcphdr);
 800c974:	4b21      	ldr	r3, [pc, #132]	; (800c9fc <tcp_input+0x110>)
 800c976:	681b      	ldr	r3, [r3, #0]
 800c978:	7b1a      	ldrb	r2, [r3, #12]
 800c97a:	7b5b      	ldrb	r3, [r3, #13]
 800c97c:	021b      	lsls	r3, r3, #8
 800c97e:	4313      	orrs	r3, r2
 800c980:	b29b      	uxth	r3, r3
 800c982:	0018      	movs	r0, r3
 800c984:	f7fa fab6 	bl	8006ef4 <lwip_htons>
 800c988:	0003      	movs	r3, r0
 800c98a:	0b1b      	lsrs	r3, r3, #12
 800c98c:	b29b      	uxth	r3, r3
 800c98e:	b2da      	uxtb	r2, r3
 800c990:	210f      	movs	r1, #15
 800c992:	187b      	adds	r3, r7, r1
 800c994:	0092      	lsls	r2, r2, #2
 800c996:	701a      	strb	r2, [r3, #0]
  if ((hdrlen_bytes < TCP_HLEN) || (hdrlen_bytes > p->tot_len)) {
 800c998:	187b      	adds	r3, r7, r1
 800c99a:	781b      	ldrb	r3, [r3, #0]
 800c99c:	2b13      	cmp	r3, #19
 800c99e:	d801      	bhi.n	800c9a4 <tcp_input+0xb8>
 800c9a0:	f000 fcc9 	bl	800d336 <tcp_input+0xa4a>
 800c9a4:	187b      	adds	r3, r7, r1
 800c9a6:	781b      	ldrb	r3, [r3, #0]
 800c9a8:	b29a      	uxth	r2, r3
 800c9aa:	687b      	ldr	r3, [r7, #4]
 800c9ac:	891b      	ldrh	r3, [r3, #8]
 800c9ae:	429a      	cmp	r2, r3
 800c9b0:	d901      	bls.n	800c9b6 <tcp_input+0xca>
 800c9b2:	f000 fcc0 	bl	800d336 <tcp_input+0xa4a>
    goto dropped;
  }

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  tcphdr_optlen = (u16_t)(hdrlen_bytes - TCP_HLEN);
 800c9b6:	187b      	adds	r3, r7, r1
 800c9b8:	781b      	ldrb	r3, [r3, #0]
 800c9ba:	b29b      	uxth	r3, r3
 800c9bc:	3b14      	subs	r3, #20
 800c9be:	b29a      	uxth	r2, r3
 800c9c0:	4b12      	ldr	r3, [pc, #72]	; (800ca0c <tcp_input+0x120>)
 800c9c2:	801a      	strh	r2, [r3, #0]
  tcphdr_opt2 = NULL;
 800c9c4:	4b12      	ldr	r3, [pc, #72]	; (800ca10 <tcp_input+0x124>)
 800c9c6:	2200      	movs	r2, #0
 800c9c8:	601a      	str	r2, [r3, #0]
  if (p->len >= hdrlen_bytes) {
 800c9ca:	687b      	ldr	r3, [r7, #4]
 800c9cc:	895a      	ldrh	r2, [r3, #10]
 800c9ce:	187b      	adds	r3, r7, r1
 800c9d0:	781b      	ldrb	r3, [r3, #0]
 800c9d2:	b29b      	uxth	r3, r3
 800c9d4:	429a      	cmp	r2, r3
 800c9d6:	d31f      	bcc.n	800ca18 <tcp_input+0x12c>
    /* all options are in the first pbuf */
    tcphdr_opt1len = tcphdr_optlen;
 800c9d8:	4b0c      	ldr	r3, [pc, #48]	; (800ca0c <tcp_input+0x120>)
 800c9da:	881a      	ldrh	r2, [r3, #0]
 800c9dc:	4b0d      	ldr	r3, [pc, #52]	; (800ca14 <tcp_input+0x128>)
 800c9de:	801a      	strh	r2, [r3, #0]
    pbuf_remove_header(p, hdrlen_bytes); /* cannot fail */
 800c9e0:	187b      	adds	r3, r7, r1
 800c9e2:	781a      	ldrb	r2, [r3, #0]
 800c9e4:	687b      	ldr	r3, [r7, #4]
 800c9e6:	0011      	movs	r1, r2
 800c9e8:	0018      	movs	r0, r3
 800c9ea:	f7fd f98f 	bl	8009d0c <pbuf_remove_header>
 800c9ee:	e06b      	b.n	800cac8 <tcp_input+0x1dc>
 800c9f0:	080205bc 	.word	0x080205bc
 800c9f4:	080205e4 	.word	0x080205e4
 800c9f8:	080205fc 	.word	0x080205fc
 800c9fc:	200017a8 	.word	0x200017a8
 800ca00:	200018fc 	.word	0x200018fc
 800ca04:	2000190c 	.word	0x2000190c
 800ca08:	20001910 	.word	0x20001910
 800ca0c:	200017ac 	.word	0x200017ac
 800ca10:	200017b0 	.word	0x200017b0
 800ca14:	200017ae 	.word	0x200017ae
  } else {
    u16_t opt2len;
    /* TCP header fits into first pbuf, options don't - data is in the next pbuf */
    /* there must be a next pbuf, due to hdrlen_bytes sanity check above */
    LWIP_ASSERT("p->next != NULL", p->next != NULL);
 800ca18:	687b      	ldr	r3, [r7, #4]
 800ca1a:	681b      	ldr	r3, [r3, #0]
 800ca1c:	2b00      	cmp	r3, #0
 800ca1e:	d105      	bne.n	800ca2c <tcp_input+0x140>
 800ca20:	4bd0      	ldr	r3, [pc, #832]	; (800cd64 <tcp_input+0x478>)
 800ca22:	49d1      	ldr	r1, [pc, #836]	; (800cd68 <tcp_input+0x47c>)
 800ca24:	48d1      	ldr	r0, [pc, #836]	; (800cd6c <tcp_input+0x480>)
 800ca26:	22c2      	movs	r2, #194	; 0xc2
 800ca28:	f7f6 f8ce 	bl	8002bc8 <app_debug_rtt_raw>

    /* advance over the TCP header (cannot fail) */
    pbuf_remove_header(p, TCP_HLEN);
 800ca2c:	687b      	ldr	r3, [r7, #4]
 800ca2e:	2114      	movs	r1, #20
 800ca30:	0018      	movs	r0, r3
 800ca32:	f7fd f96b 	bl	8009d0c <pbuf_remove_header>

    /* determine how long the first and second parts of the options are */
    tcphdr_opt1len = p->len;
 800ca36:	687b      	ldr	r3, [r7, #4]
 800ca38:	895a      	ldrh	r2, [r3, #10]
 800ca3a:	4bcd      	ldr	r3, [pc, #820]	; (800cd70 <tcp_input+0x484>)
 800ca3c:	801a      	strh	r2, [r3, #0]
    opt2len = (u16_t)(tcphdr_optlen - tcphdr_opt1len);
 800ca3e:	4bcd      	ldr	r3, [pc, #820]	; (800cd74 <tcp_input+0x488>)
 800ca40:	8819      	ldrh	r1, [r3, #0]
 800ca42:	4bcb      	ldr	r3, [pc, #812]	; (800cd70 <tcp_input+0x484>)
 800ca44:	881a      	ldrh	r2, [r3, #0]
 800ca46:	240c      	movs	r4, #12
 800ca48:	193b      	adds	r3, r7, r4
 800ca4a:	1a8a      	subs	r2, r1, r2
 800ca4c:	801a      	strh	r2, [r3, #0]

    /* options continue in the next pbuf: set p to zero length and hide the
        options in the next pbuf (adjusting p->tot_len) */
    pbuf_remove_header(p, tcphdr_opt1len);
 800ca4e:	4bc8      	ldr	r3, [pc, #800]	; (800cd70 <tcp_input+0x484>)
 800ca50:	881b      	ldrh	r3, [r3, #0]
 800ca52:	001a      	movs	r2, r3
 800ca54:	687b      	ldr	r3, [r7, #4]
 800ca56:	0011      	movs	r1, r2
 800ca58:	0018      	movs	r0, r3
 800ca5a:	f7fd f957 	bl	8009d0c <pbuf_remove_header>

    /* check that the options fit in the second pbuf */
    if (opt2len > p->next->len) {
 800ca5e:	687b      	ldr	r3, [r7, #4]
 800ca60:	681b      	ldr	r3, [r3, #0]
 800ca62:	895b      	ldrh	r3, [r3, #10]
 800ca64:	193a      	adds	r2, r7, r4
 800ca66:	8812      	ldrh	r2, [r2, #0]
 800ca68:	429a      	cmp	r2, r3
 800ca6a:	d901      	bls.n	800ca70 <tcp_input+0x184>
 800ca6c:	f000 fc65 	bl	800d33a <tcp_input+0xa4e>
      TCP_STATS_INC(tcp.lenerr);
      goto dropped;
    }

    /* remember the pointer to the second part of the options */
    tcphdr_opt2 = (u8_t *)p->next->payload;
 800ca70:	687b      	ldr	r3, [r7, #4]
 800ca72:	681b      	ldr	r3, [r3, #0]
 800ca74:	685a      	ldr	r2, [r3, #4]
 800ca76:	4bc0      	ldr	r3, [pc, #768]	; (800cd78 <tcp_input+0x48c>)
 800ca78:	601a      	str	r2, [r3, #0]

    /* advance p->next to point after the options, and manually
        adjust p->tot_len to keep it consistent with the changed p->next */
    pbuf_remove_header(p->next, opt2len);
 800ca7a:	687b      	ldr	r3, [r7, #4]
 800ca7c:	681a      	ldr	r2, [r3, #0]
 800ca7e:	193b      	adds	r3, r7, r4
 800ca80:	881b      	ldrh	r3, [r3, #0]
 800ca82:	0019      	movs	r1, r3
 800ca84:	0010      	movs	r0, r2
 800ca86:	f7fd f941 	bl	8009d0c <pbuf_remove_header>
    p->tot_len = (u16_t)(p->tot_len - opt2len);
 800ca8a:	687b      	ldr	r3, [r7, #4]
 800ca8c:	891a      	ldrh	r2, [r3, #8]
 800ca8e:	193b      	adds	r3, r7, r4
 800ca90:	881b      	ldrh	r3, [r3, #0]
 800ca92:	1ad3      	subs	r3, r2, r3
 800ca94:	b29a      	uxth	r2, r3
 800ca96:	687b      	ldr	r3, [r7, #4]
 800ca98:	811a      	strh	r2, [r3, #8]

    LWIP_ASSERT("p->len == 0", p->len == 0);
 800ca9a:	687b      	ldr	r3, [r7, #4]
 800ca9c:	895b      	ldrh	r3, [r3, #10]
 800ca9e:	2b00      	cmp	r3, #0
 800caa0:	d005      	beq.n	800caae <tcp_input+0x1c2>
 800caa2:	4bb0      	ldr	r3, [pc, #704]	; (800cd64 <tcp_input+0x478>)
 800caa4:	49b5      	ldr	r1, [pc, #724]	; (800cd7c <tcp_input+0x490>)
 800caa6:	48b1      	ldr	r0, [pc, #708]	; (800cd6c <tcp_input+0x480>)
 800caa8:	22df      	movs	r2, #223	; 0xdf
 800caaa:	f7f6 f88d 	bl	8002bc8 <app_debug_rtt_raw>
    LWIP_ASSERT("p->tot_len == p->next->tot_len", p->tot_len == p->next->tot_len);
 800caae:	687b      	ldr	r3, [r7, #4]
 800cab0:	891a      	ldrh	r2, [r3, #8]
 800cab2:	687b      	ldr	r3, [r7, #4]
 800cab4:	681b      	ldr	r3, [r3, #0]
 800cab6:	891b      	ldrh	r3, [r3, #8]
 800cab8:	429a      	cmp	r2, r3
 800caba:	d005      	beq.n	800cac8 <tcp_input+0x1dc>
 800cabc:	4ba9      	ldr	r3, [pc, #676]	; (800cd64 <tcp_input+0x478>)
 800cabe:	49b0      	ldr	r1, [pc, #704]	; (800cd80 <tcp_input+0x494>)
 800cac0:	48aa      	ldr	r0, [pc, #680]	; (800cd6c <tcp_input+0x480>)
 800cac2:	22e0      	movs	r2, #224	; 0xe0
 800cac4:	f7f6 f880 	bl	8002bc8 <app_debug_rtt_raw>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = lwip_ntohs(tcphdr->src);
 800cac8:	4bae      	ldr	r3, [pc, #696]	; (800cd84 <tcp_input+0x498>)
 800caca:	681b      	ldr	r3, [r3, #0]
 800cacc:	781a      	ldrb	r2, [r3, #0]
 800cace:	785b      	ldrb	r3, [r3, #1]
 800cad0:	021b      	lsls	r3, r3, #8
 800cad2:	4313      	orrs	r3, r2
 800cad4:	b29a      	uxth	r2, r3
 800cad6:	4bab      	ldr	r3, [pc, #684]	; (800cd84 <tcp_input+0x498>)
 800cad8:	681c      	ldr	r4, [r3, #0]
 800cada:	0010      	movs	r0, r2
 800cadc:	f7fa fa0a 	bl	8006ef4 <lwip_htons>
 800cae0:	0003      	movs	r3, r0
 800cae2:	22ff      	movs	r2, #255	; 0xff
 800cae4:	401a      	ands	r2, r3
 800cae6:	0010      	movs	r0, r2
 800cae8:	7822      	ldrb	r2, [r4, #0]
 800caea:	2100      	movs	r1, #0
 800caec:	400a      	ands	r2, r1
 800caee:	1c11      	adds	r1, r2, #0
 800caf0:	1c02      	adds	r2, r0, #0
 800caf2:	430a      	orrs	r2, r1
 800caf4:	7022      	strb	r2, [r4, #0]
 800caf6:	0a1b      	lsrs	r3, r3, #8
 800caf8:	b299      	uxth	r1, r3
 800cafa:	7863      	ldrb	r3, [r4, #1]
 800cafc:	2200      	movs	r2, #0
 800cafe:	4013      	ands	r3, r2
 800cb00:	1c1a      	adds	r2, r3, #0
 800cb02:	1c0b      	adds	r3, r1, #0
 800cb04:	4313      	orrs	r3, r2
 800cb06:	7063      	strb	r3, [r4, #1]
  tcphdr->dest = lwip_ntohs(tcphdr->dest);
 800cb08:	4b9e      	ldr	r3, [pc, #632]	; (800cd84 <tcp_input+0x498>)
 800cb0a:	681b      	ldr	r3, [r3, #0]
 800cb0c:	789a      	ldrb	r2, [r3, #2]
 800cb0e:	78db      	ldrb	r3, [r3, #3]
 800cb10:	021b      	lsls	r3, r3, #8
 800cb12:	4313      	orrs	r3, r2
 800cb14:	b29a      	uxth	r2, r3
 800cb16:	4b9b      	ldr	r3, [pc, #620]	; (800cd84 <tcp_input+0x498>)
 800cb18:	681c      	ldr	r4, [r3, #0]
 800cb1a:	0010      	movs	r0, r2
 800cb1c:	f7fa f9ea 	bl	8006ef4 <lwip_htons>
 800cb20:	0003      	movs	r3, r0
 800cb22:	22ff      	movs	r2, #255	; 0xff
 800cb24:	401a      	ands	r2, r3
 800cb26:	0010      	movs	r0, r2
 800cb28:	78a2      	ldrb	r2, [r4, #2]
 800cb2a:	2100      	movs	r1, #0
 800cb2c:	400a      	ands	r2, r1
 800cb2e:	1c11      	adds	r1, r2, #0
 800cb30:	1c02      	adds	r2, r0, #0
 800cb32:	430a      	orrs	r2, r1
 800cb34:	70a2      	strb	r2, [r4, #2]
 800cb36:	0a1b      	lsrs	r3, r3, #8
 800cb38:	b299      	uxth	r1, r3
 800cb3a:	78e3      	ldrb	r3, [r4, #3]
 800cb3c:	2200      	movs	r2, #0
 800cb3e:	4013      	ands	r3, r2
 800cb40:	1c1a      	adds	r2, r3, #0
 800cb42:	1c0b      	adds	r3, r1, #0
 800cb44:	4313      	orrs	r3, r2
 800cb46:	70e3      	strb	r3, [r4, #3]
  seqno = tcphdr->seqno = lwip_ntohl(tcphdr->seqno);
 800cb48:	4b8e      	ldr	r3, [pc, #568]	; (800cd84 <tcp_input+0x498>)
 800cb4a:	681b      	ldr	r3, [r3, #0]
 800cb4c:	791a      	ldrb	r2, [r3, #4]
 800cb4e:	7959      	ldrb	r1, [r3, #5]
 800cb50:	0209      	lsls	r1, r1, #8
 800cb52:	430a      	orrs	r2, r1
 800cb54:	7999      	ldrb	r1, [r3, #6]
 800cb56:	0409      	lsls	r1, r1, #16
 800cb58:	430a      	orrs	r2, r1
 800cb5a:	79db      	ldrb	r3, [r3, #7]
 800cb5c:	061b      	lsls	r3, r3, #24
 800cb5e:	4313      	orrs	r3, r2
 800cb60:	001a      	movs	r2, r3
 800cb62:	4b88      	ldr	r3, [pc, #544]	; (800cd84 <tcp_input+0x498>)
 800cb64:	681c      	ldr	r4, [r3, #0]
 800cb66:	0010      	movs	r0, r2
 800cb68:	f7fa f9da 	bl	8006f20 <lwip_htonl>
 800cb6c:	0003      	movs	r3, r0
 800cb6e:	22ff      	movs	r2, #255	; 0xff
 800cb70:	401a      	ands	r2, r3
 800cb72:	0010      	movs	r0, r2
 800cb74:	7922      	ldrb	r2, [r4, #4]
 800cb76:	2100      	movs	r1, #0
 800cb78:	400a      	ands	r2, r1
 800cb7a:	1c11      	adds	r1, r2, #0
 800cb7c:	1c02      	adds	r2, r0, #0
 800cb7e:	430a      	orrs	r2, r1
 800cb80:	7122      	strb	r2, [r4, #4]
 800cb82:	0a1a      	lsrs	r2, r3, #8
 800cb84:	21ff      	movs	r1, #255	; 0xff
 800cb86:	400a      	ands	r2, r1
 800cb88:	0010      	movs	r0, r2
 800cb8a:	7962      	ldrb	r2, [r4, #5]
 800cb8c:	2100      	movs	r1, #0
 800cb8e:	400a      	ands	r2, r1
 800cb90:	1c11      	adds	r1, r2, #0
 800cb92:	1c02      	adds	r2, r0, #0
 800cb94:	430a      	orrs	r2, r1
 800cb96:	7162      	strb	r2, [r4, #5]
 800cb98:	0c1a      	lsrs	r2, r3, #16
 800cb9a:	21ff      	movs	r1, #255	; 0xff
 800cb9c:	400a      	ands	r2, r1
 800cb9e:	0010      	movs	r0, r2
 800cba0:	79a2      	ldrb	r2, [r4, #6]
 800cba2:	2100      	movs	r1, #0
 800cba4:	400a      	ands	r2, r1
 800cba6:	1c11      	adds	r1, r2, #0
 800cba8:	1c02      	adds	r2, r0, #0
 800cbaa:	430a      	orrs	r2, r1
 800cbac:	71a2      	strb	r2, [r4, #6]
 800cbae:	0e19      	lsrs	r1, r3, #24
 800cbb0:	79e3      	ldrb	r3, [r4, #7]
 800cbb2:	2200      	movs	r2, #0
 800cbb4:	4013      	ands	r3, r2
 800cbb6:	1c1a      	adds	r2, r3, #0
 800cbb8:	1c0b      	adds	r3, r1, #0
 800cbba:	4313      	orrs	r3, r2
 800cbbc:	71e3      	strb	r3, [r4, #7]
 800cbbe:	7923      	ldrb	r3, [r4, #4]
 800cbc0:	7962      	ldrb	r2, [r4, #5]
 800cbc2:	0212      	lsls	r2, r2, #8
 800cbc4:	4313      	orrs	r3, r2
 800cbc6:	79a2      	ldrb	r2, [r4, #6]
 800cbc8:	0412      	lsls	r2, r2, #16
 800cbca:	4313      	orrs	r3, r2
 800cbcc:	79e2      	ldrb	r2, [r4, #7]
 800cbce:	0612      	lsls	r2, r2, #24
 800cbd0:	4313      	orrs	r3, r2
 800cbd2:	001a      	movs	r2, r3
 800cbd4:	4b6c      	ldr	r3, [pc, #432]	; (800cd88 <tcp_input+0x49c>)
 800cbd6:	601a      	str	r2, [r3, #0]
  ackno = tcphdr->ackno = lwip_ntohl(tcphdr->ackno);
 800cbd8:	4b6a      	ldr	r3, [pc, #424]	; (800cd84 <tcp_input+0x498>)
 800cbda:	681b      	ldr	r3, [r3, #0]
 800cbdc:	7a1a      	ldrb	r2, [r3, #8]
 800cbde:	7a59      	ldrb	r1, [r3, #9]
 800cbe0:	0209      	lsls	r1, r1, #8
 800cbe2:	430a      	orrs	r2, r1
 800cbe4:	7a99      	ldrb	r1, [r3, #10]
 800cbe6:	0409      	lsls	r1, r1, #16
 800cbe8:	430a      	orrs	r2, r1
 800cbea:	7adb      	ldrb	r3, [r3, #11]
 800cbec:	061b      	lsls	r3, r3, #24
 800cbee:	4313      	orrs	r3, r2
 800cbf0:	001a      	movs	r2, r3
 800cbf2:	4b64      	ldr	r3, [pc, #400]	; (800cd84 <tcp_input+0x498>)
 800cbf4:	681c      	ldr	r4, [r3, #0]
 800cbf6:	0010      	movs	r0, r2
 800cbf8:	f7fa f992 	bl	8006f20 <lwip_htonl>
 800cbfc:	0003      	movs	r3, r0
 800cbfe:	22ff      	movs	r2, #255	; 0xff
 800cc00:	401a      	ands	r2, r3
 800cc02:	0010      	movs	r0, r2
 800cc04:	7a22      	ldrb	r2, [r4, #8]
 800cc06:	2100      	movs	r1, #0
 800cc08:	400a      	ands	r2, r1
 800cc0a:	1c11      	adds	r1, r2, #0
 800cc0c:	1c02      	adds	r2, r0, #0
 800cc0e:	430a      	orrs	r2, r1
 800cc10:	7222      	strb	r2, [r4, #8]
 800cc12:	0a1a      	lsrs	r2, r3, #8
 800cc14:	21ff      	movs	r1, #255	; 0xff
 800cc16:	400a      	ands	r2, r1
 800cc18:	0010      	movs	r0, r2
 800cc1a:	7a62      	ldrb	r2, [r4, #9]
 800cc1c:	2100      	movs	r1, #0
 800cc1e:	400a      	ands	r2, r1
 800cc20:	1c11      	adds	r1, r2, #0
 800cc22:	1c02      	adds	r2, r0, #0
 800cc24:	430a      	orrs	r2, r1
 800cc26:	7262      	strb	r2, [r4, #9]
 800cc28:	0c1a      	lsrs	r2, r3, #16
 800cc2a:	21ff      	movs	r1, #255	; 0xff
 800cc2c:	400a      	ands	r2, r1
 800cc2e:	0010      	movs	r0, r2
 800cc30:	7aa2      	ldrb	r2, [r4, #10]
 800cc32:	2100      	movs	r1, #0
 800cc34:	400a      	ands	r2, r1
 800cc36:	1c11      	adds	r1, r2, #0
 800cc38:	1c02      	adds	r2, r0, #0
 800cc3a:	430a      	orrs	r2, r1
 800cc3c:	72a2      	strb	r2, [r4, #10]
 800cc3e:	0e19      	lsrs	r1, r3, #24
 800cc40:	7ae3      	ldrb	r3, [r4, #11]
 800cc42:	2200      	movs	r2, #0
 800cc44:	4013      	ands	r3, r2
 800cc46:	1c1a      	adds	r2, r3, #0
 800cc48:	1c0b      	adds	r3, r1, #0
 800cc4a:	4313      	orrs	r3, r2
 800cc4c:	72e3      	strb	r3, [r4, #11]
 800cc4e:	7a23      	ldrb	r3, [r4, #8]
 800cc50:	7a62      	ldrb	r2, [r4, #9]
 800cc52:	0212      	lsls	r2, r2, #8
 800cc54:	4313      	orrs	r3, r2
 800cc56:	7aa2      	ldrb	r2, [r4, #10]
 800cc58:	0412      	lsls	r2, r2, #16
 800cc5a:	4313      	orrs	r3, r2
 800cc5c:	7ae2      	ldrb	r2, [r4, #11]
 800cc5e:	0612      	lsls	r2, r2, #24
 800cc60:	4313      	orrs	r3, r2
 800cc62:	001a      	movs	r2, r3
 800cc64:	4b49      	ldr	r3, [pc, #292]	; (800cd8c <tcp_input+0x4a0>)
 800cc66:	601a      	str	r2, [r3, #0]
  tcphdr->wnd = lwip_ntohs(tcphdr->wnd);
 800cc68:	4b46      	ldr	r3, [pc, #280]	; (800cd84 <tcp_input+0x498>)
 800cc6a:	681b      	ldr	r3, [r3, #0]
 800cc6c:	7b9a      	ldrb	r2, [r3, #14]
 800cc6e:	7bdb      	ldrb	r3, [r3, #15]
 800cc70:	021b      	lsls	r3, r3, #8
 800cc72:	4313      	orrs	r3, r2
 800cc74:	b29a      	uxth	r2, r3
 800cc76:	4b43      	ldr	r3, [pc, #268]	; (800cd84 <tcp_input+0x498>)
 800cc78:	681c      	ldr	r4, [r3, #0]
 800cc7a:	0010      	movs	r0, r2
 800cc7c:	f7fa f93a 	bl	8006ef4 <lwip_htons>
 800cc80:	0003      	movs	r3, r0
 800cc82:	22ff      	movs	r2, #255	; 0xff
 800cc84:	401a      	ands	r2, r3
 800cc86:	0010      	movs	r0, r2
 800cc88:	7ba2      	ldrb	r2, [r4, #14]
 800cc8a:	2100      	movs	r1, #0
 800cc8c:	400a      	ands	r2, r1
 800cc8e:	1c11      	adds	r1, r2, #0
 800cc90:	1c02      	adds	r2, r0, #0
 800cc92:	430a      	orrs	r2, r1
 800cc94:	73a2      	strb	r2, [r4, #14]
 800cc96:	0a1b      	lsrs	r3, r3, #8
 800cc98:	b299      	uxth	r1, r3
 800cc9a:	7be3      	ldrb	r3, [r4, #15]
 800cc9c:	2200      	movs	r2, #0
 800cc9e:	4013      	ands	r3, r2
 800cca0:	1c1a      	adds	r2, r3, #0
 800cca2:	1c0b      	adds	r3, r1, #0
 800cca4:	4313      	orrs	r3, r2
 800cca6:	73e3      	strb	r3, [r4, #15]

  flags = TCPH_FLAGS(tcphdr);
 800cca8:	4b36      	ldr	r3, [pc, #216]	; (800cd84 <tcp_input+0x498>)
 800ccaa:	681b      	ldr	r3, [r3, #0]
 800ccac:	7b1a      	ldrb	r2, [r3, #12]
 800ccae:	7b5b      	ldrb	r3, [r3, #13]
 800ccb0:	021b      	lsls	r3, r3, #8
 800ccb2:	4313      	orrs	r3, r2
 800ccb4:	b29b      	uxth	r3, r3
 800ccb6:	0018      	movs	r0, r3
 800ccb8:	f7fa f91c 	bl	8006ef4 <lwip_htons>
 800ccbc:	0003      	movs	r3, r0
 800ccbe:	b2db      	uxtb	r3, r3
 800ccc0:	223f      	movs	r2, #63	; 0x3f
 800ccc2:	4013      	ands	r3, r2
 800ccc4:	b2da      	uxtb	r2, r3
 800ccc6:	4b32      	ldr	r3, [pc, #200]	; (800cd90 <tcp_input+0x4a4>)
 800ccc8:	701a      	strb	r2, [r3, #0]
  tcplen = p->tot_len;
 800ccca:	687b      	ldr	r3, [r7, #4]
 800cccc:	891a      	ldrh	r2, [r3, #8]
 800ccce:	4b31      	ldr	r3, [pc, #196]	; (800cd94 <tcp_input+0x4a8>)
 800ccd0:	801a      	strh	r2, [r3, #0]
  if (flags & (TCP_FIN | TCP_SYN)) {
 800ccd2:	4b2f      	ldr	r3, [pc, #188]	; (800cd90 <tcp_input+0x4a4>)
 800ccd4:	781b      	ldrb	r3, [r3, #0]
 800ccd6:	001a      	movs	r2, r3
 800ccd8:	2303      	movs	r3, #3
 800ccda:	4013      	ands	r3, r2
 800ccdc:	d00c      	beq.n	800ccf8 <tcp_input+0x40c>
    tcplen++;
 800ccde:	4b2d      	ldr	r3, [pc, #180]	; (800cd94 <tcp_input+0x4a8>)
 800cce0:	881b      	ldrh	r3, [r3, #0]
 800cce2:	3301      	adds	r3, #1
 800cce4:	b29a      	uxth	r2, r3
 800cce6:	4b2b      	ldr	r3, [pc, #172]	; (800cd94 <tcp_input+0x4a8>)
 800cce8:	801a      	strh	r2, [r3, #0]
    if (tcplen < p->tot_len) {
 800ccea:	687b      	ldr	r3, [r7, #4]
 800ccec:	891a      	ldrh	r2, [r3, #8]
 800ccee:	4b29      	ldr	r3, [pc, #164]	; (800cd94 <tcp_input+0x4a8>)
 800ccf0:	881b      	ldrh	r3, [r3, #0]
 800ccf2:	429a      	cmp	r2, r3
 800ccf4:	d900      	bls.n	800ccf8 <tcp_input+0x40c>
 800ccf6:	e322      	b.n	800d33e <tcp_input+0xa52>
    }
  }

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
 800ccf8:	2300      	movs	r3, #0
 800ccfa:	627b      	str	r3, [r7, #36]	; 0x24

  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800ccfc:	4b26      	ldr	r3, [pc, #152]	; (800cd98 <tcp_input+0x4ac>)
 800ccfe:	681b      	ldr	r3, [r3, #0]
 800cd00:	623b      	str	r3, [r7, #32]
 800cd02:	e0a1      	b.n	800ce48 <tcp_input+0x55c>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
 800cd04:	6a3b      	ldr	r3, [r7, #32]
 800cd06:	7e1b      	ldrb	r3, [r3, #24]
 800cd08:	2b00      	cmp	r3, #0
 800cd0a:	d105      	bne.n	800cd18 <tcp_input+0x42c>
 800cd0c:	4b15      	ldr	r3, [pc, #84]	; (800cd64 <tcp_input+0x478>)
 800cd0e:	4923      	ldr	r1, [pc, #140]	; (800cd9c <tcp_input+0x4b0>)
 800cd10:	4816      	ldr	r0, [pc, #88]	; (800cd6c <tcp_input+0x480>)
 800cd12:	22fb      	movs	r2, #251	; 0xfb
 800cd14:	f7f5 ff58 	bl	8002bc8 <app_debug_rtt_raw>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
 800cd18:	6a3b      	ldr	r3, [r7, #32]
 800cd1a:	7e1b      	ldrb	r3, [r3, #24]
 800cd1c:	2b0a      	cmp	r3, #10
 800cd1e:	d105      	bne.n	800cd2c <tcp_input+0x440>
 800cd20:	4b10      	ldr	r3, [pc, #64]	; (800cd64 <tcp_input+0x478>)
 800cd22:	491f      	ldr	r1, [pc, #124]	; (800cda0 <tcp_input+0x4b4>)
 800cd24:	4811      	ldr	r0, [pc, #68]	; (800cd6c <tcp_input+0x480>)
 800cd26:	22fc      	movs	r2, #252	; 0xfc
 800cd28:	f7f5 ff4e 	bl	8002bc8 <app_debug_rtt_raw>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
 800cd2c:	6a3b      	ldr	r3, [r7, #32]
 800cd2e:	7e1b      	ldrb	r3, [r3, #24]
 800cd30:	2b01      	cmp	r3, #1
 800cd32:	d105      	bne.n	800cd40 <tcp_input+0x454>
 800cd34:	4b0b      	ldr	r3, [pc, #44]	; (800cd64 <tcp_input+0x478>)
 800cd36:	491b      	ldr	r1, [pc, #108]	; (800cda4 <tcp_input+0x4b8>)
 800cd38:	480c      	ldr	r0, [pc, #48]	; (800cd6c <tcp_input+0x480>)
 800cd3a:	22fd      	movs	r2, #253	; 0xfd
 800cd3c:	f7f5 ff44 	bl	8002bc8 <app_debug_rtt_raw>

    /* check if PCB is bound to specific netif */
    if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 800cd40:	6a3b      	ldr	r3, [r7, #32]
 800cd42:	7a1b      	ldrb	r3, [r3, #8]
 800cd44:	2b00      	cmp	r3, #0
 800cd46:	d031      	beq.n	800cdac <tcp_input+0x4c0>
        (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 800cd48:	6a3b      	ldr	r3, [r7, #32]
 800cd4a:	7a1a      	ldrb	r2, [r3, #8]
 800cd4c:	4b16      	ldr	r3, [pc, #88]	; (800cda8 <tcp_input+0x4bc>)
 800cd4e:	685b      	ldr	r3, [r3, #4]
 800cd50:	2134      	movs	r1, #52	; 0x34
 800cd52:	5c5b      	ldrb	r3, [r3, r1]
 800cd54:	3301      	adds	r3, #1
 800cd56:	b2db      	uxtb	r3, r3
    if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 800cd58:	429a      	cmp	r2, r3
 800cd5a:	d027      	beq.n	800cdac <tcp_input+0x4c0>
      prev = pcb;
 800cd5c:	6a3b      	ldr	r3, [r7, #32]
 800cd5e:	627b      	str	r3, [r7, #36]	; 0x24
      continue;
 800cd60:	e06f      	b.n	800ce42 <tcp_input+0x556>
 800cd62:	46c0      	nop			; (mov r8, r8)
 800cd64:	080205bc 	.word	0x080205bc
 800cd68:	08020628 	.word	0x08020628
 800cd6c:	080205fc 	.word	0x080205fc
 800cd70:	200017ae 	.word	0x200017ae
 800cd74:	200017ac 	.word	0x200017ac
 800cd78:	200017b0 	.word	0x200017b0
 800cd7c:	08020638 	.word	0x08020638
 800cd80:	08020644 	.word	0x08020644
 800cd84:	200017a8 	.word	0x200017a8
 800cd88:	200017b8 	.word	0x200017b8
 800cd8c:	200017bc 	.word	0x200017bc
 800cd90:	200017c4 	.word	0x200017c4
 800cd94:	200017c2 	.word	0x200017c2
 800cd98:	20002b3c 	.word	0x20002b3c
 800cd9c:	08020664 	.word	0x08020664
 800cda0:	0802068c 	.word	0x0802068c
 800cda4:	080206b8 	.word	0x080206b8
 800cda8:	200018fc 	.word	0x200018fc
    }

    if (pcb->remote_port == tcphdr->src &&
 800cdac:	6a3b      	ldr	r3, [r7, #32]
 800cdae:	8b9a      	ldrh	r2, [r3, #28]
 800cdb0:	4bcb      	ldr	r3, [pc, #812]	; (800d0e0 <tcp_input+0x7f4>)
 800cdb2:	681b      	ldr	r3, [r3, #0]
 800cdb4:	7819      	ldrb	r1, [r3, #0]
 800cdb6:	785b      	ldrb	r3, [r3, #1]
 800cdb8:	021b      	lsls	r3, r3, #8
 800cdba:	430b      	orrs	r3, r1
 800cdbc:	b29b      	uxth	r3, r3
 800cdbe:	429a      	cmp	r2, r3
 800cdc0:	d13d      	bne.n	800ce3e <tcp_input+0x552>
        pcb->local_port == tcphdr->dest &&
 800cdc2:	6a3b      	ldr	r3, [r7, #32]
 800cdc4:	8b5a      	ldrh	r2, [r3, #26]
 800cdc6:	4bc6      	ldr	r3, [pc, #792]	; (800d0e0 <tcp_input+0x7f4>)
 800cdc8:	681b      	ldr	r3, [r3, #0]
 800cdca:	7899      	ldrb	r1, [r3, #2]
 800cdcc:	78db      	ldrb	r3, [r3, #3]
 800cdce:	021b      	lsls	r3, r3, #8
 800cdd0:	430b      	orrs	r3, r1
 800cdd2:	b29b      	uxth	r3, r3
    if (pcb->remote_port == tcphdr->src &&
 800cdd4:	429a      	cmp	r2, r3
 800cdd6:	d132      	bne.n	800ce3e <tcp_input+0x552>
        ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 800cdd8:	6a3b      	ldr	r3, [r7, #32]
 800cdda:	685a      	ldr	r2, [r3, #4]
 800cddc:	4bc1      	ldr	r3, [pc, #772]	; (800d0e4 <tcp_input+0x7f8>)
 800cdde:	691b      	ldr	r3, [r3, #16]
        pcb->local_port == tcphdr->dest &&
 800cde0:	429a      	cmp	r2, r3
 800cde2:	d12c      	bne.n	800ce3e <tcp_input+0x552>
        ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 800cde4:	6a3b      	ldr	r3, [r7, #32]
 800cde6:	681a      	ldr	r2, [r3, #0]
 800cde8:	4bbe      	ldr	r3, [pc, #760]	; (800d0e4 <tcp_input+0x7f8>)
 800cdea:	695b      	ldr	r3, [r3, #20]
        ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 800cdec:	429a      	cmp	r2, r3
 800cdee:	d126      	bne.n	800ce3e <tcp_input+0x552>
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
 800cdf0:	6a3b      	ldr	r3, [r7, #32]
 800cdf2:	691b      	ldr	r3, [r3, #16]
 800cdf4:	6a3a      	ldr	r2, [r7, #32]
 800cdf6:	429a      	cmp	r2, r3
 800cdf8:	d106      	bne.n	800ce08 <tcp_input+0x51c>
 800cdfa:	4bbb      	ldr	r3, [pc, #748]	; (800d0e8 <tcp_input+0x7fc>)
 800cdfc:	220e      	movs	r2, #14
 800cdfe:	32ff      	adds	r2, #255	; 0xff
 800ce00:	49ba      	ldr	r1, [pc, #744]	; (800d0ec <tcp_input+0x800>)
 800ce02:	48bb      	ldr	r0, [pc, #748]	; (800d0f0 <tcp_input+0x804>)
 800ce04:	f7f5 fee0 	bl	8002bc8 <app_debug_rtt_raw>
      if (prev != NULL) {
 800ce08:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ce0a:	2b00      	cmp	r3, #0
 800ce0c:	d00a      	beq.n	800ce24 <tcp_input+0x538>
        prev->next = pcb->next;
 800ce0e:	6a3b      	ldr	r3, [r7, #32]
 800ce10:	691a      	ldr	r2, [r3, #16]
 800ce12:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ce14:	611a      	str	r2, [r3, #16]
        pcb->next = tcp_active_pcbs;
 800ce16:	4bb7      	ldr	r3, [pc, #732]	; (800d0f4 <tcp_input+0x808>)
 800ce18:	681a      	ldr	r2, [r3, #0]
 800ce1a:	6a3b      	ldr	r3, [r7, #32]
 800ce1c:	611a      	str	r2, [r3, #16]
        tcp_active_pcbs = pcb;
 800ce1e:	4bb5      	ldr	r3, [pc, #724]	; (800d0f4 <tcp_input+0x808>)
 800ce20:	6a3a      	ldr	r2, [r7, #32]
 800ce22:	601a      	str	r2, [r3, #0]
      } else {
        TCP_STATS_INC(tcp.cachehit);
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
 800ce24:	6a3b      	ldr	r3, [r7, #32]
 800ce26:	691b      	ldr	r3, [r3, #16]
 800ce28:	6a3a      	ldr	r2, [r7, #32]
 800ce2a:	429a      	cmp	r2, r3
 800ce2c:	d111      	bne.n	800ce52 <tcp_input+0x566>
 800ce2e:	4bae      	ldr	r3, [pc, #696]	; (800d0e8 <tcp_input+0x7fc>)
 800ce30:	2216      	movs	r2, #22
 800ce32:	32ff      	adds	r2, #255	; 0xff
 800ce34:	49b0      	ldr	r1, [pc, #704]	; (800d0f8 <tcp_input+0x80c>)
 800ce36:	48ae      	ldr	r0, [pc, #696]	; (800d0f0 <tcp_input+0x804>)
 800ce38:	f7f5 fec6 	bl	8002bc8 <app_debug_rtt_raw>
      break;
 800ce3c:	e009      	b.n	800ce52 <tcp_input+0x566>
    }
    prev = pcb;
 800ce3e:	6a3b      	ldr	r3, [r7, #32]
 800ce40:	627b      	str	r3, [r7, #36]	; 0x24
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800ce42:	6a3b      	ldr	r3, [r7, #32]
 800ce44:	691b      	ldr	r3, [r3, #16]
 800ce46:	623b      	str	r3, [r7, #32]
 800ce48:	6a3b      	ldr	r3, [r7, #32]
 800ce4a:	2b00      	cmp	r3, #0
 800ce4c:	d000      	beq.n	800ce50 <tcp_input+0x564>
 800ce4e:	e759      	b.n	800cd04 <tcp_input+0x418>
 800ce50:	e000      	b.n	800ce54 <tcp_input+0x568>
      break;
 800ce52:	46c0      	nop			; (mov r8, r8)
  }

  if (pcb == NULL) {
 800ce54:	6a3b      	ldr	r3, [r7, #32]
 800ce56:	2b00      	cmp	r3, #0
 800ce58:	d000      	beq.n	800ce5c <tcp_input+0x570>
 800ce5a:	e0ac      	b.n	800cfb6 <tcp_input+0x6ca>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800ce5c:	4ba7      	ldr	r3, [pc, #668]	; (800d0fc <tcp_input+0x810>)
 800ce5e:	681b      	ldr	r3, [r3, #0]
 800ce60:	623b      	str	r3, [r7, #32]
 800ce62:	e047      	b.n	800cef4 <tcp_input+0x608>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 800ce64:	6a3b      	ldr	r3, [r7, #32]
 800ce66:	7e1b      	ldrb	r3, [r3, #24]
 800ce68:	2b0a      	cmp	r3, #10
 800ce6a:	d006      	beq.n	800ce7a <tcp_input+0x58e>
 800ce6c:	4b9e      	ldr	r3, [pc, #632]	; (800d0e8 <tcp_input+0x7fc>)
 800ce6e:	2220      	movs	r2, #32
 800ce70:	32ff      	adds	r2, #255	; 0xff
 800ce72:	49a3      	ldr	r1, [pc, #652]	; (800d100 <tcp_input+0x814>)
 800ce74:	489e      	ldr	r0, [pc, #632]	; (800d0f0 <tcp_input+0x804>)
 800ce76:	f7f5 fea7 	bl	8002bc8 <app_debug_rtt_raw>

      /* check if PCB is bound to specific netif */
      if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 800ce7a:	6a3b      	ldr	r3, [r7, #32]
 800ce7c:	7a1b      	ldrb	r3, [r3, #8]
 800ce7e:	2b00      	cmp	r3, #0
 800ce80:	d009      	beq.n	800ce96 <tcp_input+0x5aa>
          (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 800ce82:	6a3b      	ldr	r3, [r7, #32]
 800ce84:	7a1a      	ldrb	r2, [r3, #8]
 800ce86:	4b97      	ldr	r3, [pc, #604]	; (800d0e4 <tcp_input+0x7f8>)
 800ce88:	685b      	ldr	r3, [r3, #4]
 800ce8a:	2134      	movs	r1, #52	; 0x34
 800ce8c:	5c5b      	ldrb	r3, [r3, r1]
 800ce8e:	3301      	adds	r3, #1
 800ce90:	b2db      	uxtb	r3, r3
      if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 800ce92:	429a      	cmp	r2, r3
 800ce94:	d12a      	bne.n	800ceec <tcp_input+0x600>
        continue;
      }

      if (pcb->remote_port == tcphdr->src &&
 800ce96:	6a3b      	ldr	r3, [r7, #32]
 800ce98:	8b9a      	ldrh	r2, [r3, #28]
 800ce9a:	4b91      	ldr	r3, [pc, #580]	; (800d0e0 <tcp_input+0x7f4>)
 800ce9c:	681b      	ldr	r3, [r3, #0]
 800ce9e:	7819      	ldrb	r1, [r3, #0]
 800cea0:	785b      	ldrb	r3, [r3, #1]
 800cea2:	021b      	lsls	r3, r3, #8
 800cea4:	430b      	orrs	r3, r1
 800cea6:	b29b      	uxth	r3, r3
 800cea8:	429a      	cmp	r2, r3
 800ceaa:	d120      	bne.n	800ceee <tcp_input+0x602>
          pcb->local_port == tcphdr->dest &&
 800ceac:	6a3b      	ldr	r3, [r7, #32]
 800ceae:	8b5a      	ldrh	r2, [r3, #26]
 800ceb0:	4b8b      	ldr	r3, [pc, #556]	; (800d0e0 <tcp_input+0x7f4>)
 800ceb2:	681b      	ldr	r3, [r3, #0]
 800ceb4:	7899      	ldrb	r1, [r3, #2]
 800ceb6:	78db      	ldrb	r3, [r3, #3]
 800ceb8:	021b      	lsls	r3, r3, #8
 800ceba:	430b      	orrs	r3, r1
 800cebc:	b29b      	uxth	r3, r3
      if (pcb->remote_port == tcphdr->src &&
 800cebe:	429a      	cmp	r2, r3
 800cec0:	d115      	bne.n	800ceee <tcp_input+0x602>
          ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 800cec2:	6a3b      	ldr	r3, [r7, #32]
 800cec4:	685a      	ldr	r2, [r3, #4]
 800cec6:	4b87      	ldr	r3, [pc, #540]	; (800d0e4 <tcp_input+0x7f8>)
 800cec8:	691b      	ldr	r3, [r3, #16]
          pcb->local_port == tcphdr->dest &&
 800ceca:	429a      	cmp	r2, r3
 800cecc:	d10f      	bne.n	800ceee <tcp_input+0x602>
          ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 800cece:	6a3b      	ldr	r3, [r7, #32]
 800ced0:	681a      	ldr	r2, [r3, #0]
 800ced2:	4b84      	ldr	r3, [pc, #528]	; (800d0e4 <tcp_input+0x7f8>)
 800ced4:	695b      	ldr	r3, [r3, #20]
          ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 800ced6:	429a      	cmp	r2, r3
 800ced8:	d109      	bne.n	800ceee <tcp_input+0x602>
#ifdef LWIP_HOOK_TCP_INPACKET_PCB
        if (LWIP_HOOK_TCP_INPACKET_PCB(pcb, tcphdr, tcphdr_optlen, tcphdr_opt1len,
                                       tcphdr_opt2, p) == ERR_OK)
#endif
        {
          tcp_timewait_input(pcb);
 800ceda:	6a3b      	ldr	r3, [r7, #32]
 800cedc:	0018      	movs	r0, r3
 800cede:	f000 fbb5 	bl	800d64c <tcp_timewait_input>
        }
        pbuf_free(p);
 800cee2:	687b      	ldr	r3, [r7, #4]
 800cee4:	0018      	movs	r0, r3
 800cee6:	f7fc ffe9 	bl	8009ebc <pbuf_free>
        return;
 800ceea:	e22f      	b.n	800d34c <tcp_input+0xa60>
        continue;
 800ceec:	46c0      	nop			; (mov r8, r8)
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800ceee:	6a3b      	ldr	r3, [r7, #32]
 800cef0:	691b      	ldr	r3, [r3, #16]
 800cef2:	623b      	str	r3, [r7, #32]
 800cef4:	6a3b      	ldr	r3, [r7, #32]
 800cef6:	2b00      	cmp	r3, #0
 800cef8:	d1b4      	bne.n	800ce64 <tcp_input+0x578>
      }
    }

    /* Finally, if we still did not get a match, we check all PCBs that
       are LISTENing for incoming connections. */
    prev = NULL;
 800cefa:	2300      	movs	r3, #0
 800cefc:	627b      	str	r3, [r7, #36]	; 0x24
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 800cefe:	4b81      	ldr	r3, [pc, #516]	; (800d104 <tcp_input+0x818>)
 800cf00:	681b      	ldr	r3, [r3, #0]
 800cf02:	61fb      	str	r3, [r7, #28]
 800cf04:	e031      	b.n	800cf6a <tcp_input+0x67e>
      /* check if PCB is bound to specific netif */
      if ((lpcb->netif_idx != NETIF_NO_INDEX) &&
 800cf06:	69fb      	ldr	r3, [r7, #28]
 800cf08:	7a1b      	ldrb	r3, [r3, #8]
 800cf0a:	2b00      	cmp	r3, #0
 800cf0c:	d00c      	beq.n	800cf28 <tcp_input+0x63c>
          (lpcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 800cf0e:	69fb      	ldr	r3, [r7, #28]
 800cf10:	7a1a      	ldrb	r2, [r3, #8]
 800cf12:	4b74      	ldr	r3, [pc, #464]	; (800d0e4 <tcp_input+0x7f8>)
 800cf14:	685b      	ldr	r3, [r3, #4]
 800cf16:	2134      	movs	r1, #52	; 0x34
 800cf18:	5c5b      	ldrb	r3, [r3, r1]
 800cf1a:	3301      	adds	r3, #1
 800cf1c:	b2db      	uxtb	r3, r3
      if ((lpcb->netif_idx != NETIF_NO_INDEX) &&
 800cf1e:	429a      	cmp	r2, r3
 800cf20:	d002      	beq.n	800cf28 <tcp_input+0x63c>
        prev = (struct tcp_pcb *)lpcb;
 800cf22:	69fb      	ldr	r3, [r7, #28]
 800cf24:	627b      	str	r3, [r7, #36]	; 0x24
        continue;
 800cf26:	e01d      	b.n	800cf64 <tcp_input+0x678>
      }

      if (lpcb->local_port == tcphdr->dest) {
 800cf28:	69fb      	ldr	r3, [r7, #28]
 800cf2a:	8b5a      	ldrh	r2, [r3, #26]
 800cf2c:	4b6c      	ldr	r3, [pc, #432]	; (800d0e0 <tcp_input+0x7f4>)
 800cf2e:	681b      	ldr	r3, [r3, #0]
 800cf30:	7899      	ldrb	r1, [r3, #2]
 800cf32:	78db      	ldrb	r3, [r3, #3]
 800cf34:	021b      	lsls	r3, r3, #8
 800cf36:	430b      	orrs	r3, r1
 800cf38:	b29b      	uxth	r3, r3
 800cf3a:	429a      	cmp	r2, r3
 800cf3c:	d110      	bne.n	800cf60 <tcp_input+0x674>
          lpcb_prev = prev;
#else /* SO_REUSE */
          break;
#endif /* SO_REUSE */
        } else if (IP_ADDR_PCB_VERSION_MATCH_EXACT(lpcb, ip_current_dest_addr())) {
          if (ip_addr_cmp(&lpcb->local_ip, ip_current_dest_addr())) {
 800cf3e:	69fb      	ldr	r3, [r7, #28]
 800cf40:	681a      	ldr	r2, [r3, #0]
 800cf42:	4b68      	ldr	r3, [pc, #416]	; (800d0e4 <tcp_input+0x7f8>)
 800cf44:	695b      	ldr	r3, [r3, #20]
 800cf46:	429a      	cmp	r2, r3
 800cf48:	d013      	beq.n	800cf72 <tcp_input+0x686>
            /* found an exact match */
            break;
          } else if (ip_addr_isany(&lpcb->local_ip)) {
 800cf4a:	69fb      	ldr	r3, [r7, #28]
 800cf4c:	2b00      	cmp	r3, #0
 800cf4e:	d003      	beq.n	800cf58 <tcp_input+0x66c>
 800cf50:	69fb      	ldr	r3, [r7, #28]
 800cf52:	681b      	ldr	r3, [r3, #0]
 800cf54:	2b00      	cmp	r3, #0
 800cf56:	d103      	bne.n	800cf60 <tcp_input+0x674>
            /* found an ANY-match */
#if SO_REUSE
            lpcb_any = lpcb;
 800cf58:	69fb      	ldr	r3, [r7, #28]
 800cf5a:	617b      	str	r3, [r7, #20]
            lpcb_prev = prev;
 800cf5c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cf5e:	61bb      	str	r3, [r7, #24]
            break;
#endif /* SO_REUSE */
          }
        }
      }
      prev = (struct tcp_pcb *)lpcb;
 800cf60:	69fb      	ldr	r3, [r7, #28]
 800cf62:	627b      	str	r3, [r7, #36]	; 0x24
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 800cf64:	69fb      	ldr	r3, [r7, #28]
 800cf66:	691b      	ldr	r3, [r3, #16]
 800cf68:	61fb      	str	r3, [r7, #28]
 800cf6a:	69fb      	ldr	r3, [r7, #28]
 800cf6c:	2b00      	cmp	r3, #0
 800cf6e:	d1ca      	bne.n	800cf06 <tcp_input+0x61a>
 800cf70:	e000      	b.n	800cf74 <tcp_input+0x688>
            break;
 800cf72:	46c0      	nop			; (mov r8, r8)
    }
#if SO_REUSE
    /* first try specific local IP */
    if (lpcb == NULL) {
 800cf74:	69fb      	ldr	r3, [r7, #28]
 800cf76:	2b00      	cmp	r3, #0
 800cf78:	d103      	bne.n	800cf82 <tcp_input+0x696>
      /* only pass to ANY if no specific local IP has been found */
      lpcb = lpcb_any;
 800cf7a:	697b      	ldr	r3, [r7, #20]
 800cf7c:	61fb      	str	r3, [r7, #28]
      prev = lpcb_prev;
 800cf7e:	69bb      	ldr	r3, [r7, #24]
 800cf80:	627b      	str	r3, [r7, #36]	; 0x24
    }
#endif /* SO_REUSE */
    if (lpcb != NULL) {
 800cf82:	69fb      	ldr	r3, [r7, #28]
 800cf84:	2b00      	cmp	r3, #0
 800cf86:	d016      	beq.n	800cfb6 <tcp_input+0x6ca>
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      if (prev != NULL) {
 800cf88:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cf8a:	2b00      	cmp	r3, #0
 800cf8c:	d00a      	beq.n	800cfa4 <tcp_input+0x6b8>
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
 800cf8e:	69fb      	ldr	r3, [r7, #28]
 800cf90:	691a      	ldr	r2, [r3, #16]
 800cf92:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cf94:	611a      	str	r2, [r3, #16]
        /* our successor is the remainder of the listening list */
        lpcb->next = tcp_listen_pcbs.listen_pcbs;
 800cf96:	4b5b      	ldr	r3, [pc, #364]	; (800d104 <tcp_input+0x818>)
 800cf98:	681a      	ldr	r2, [r3, #0]
 800cf9a:	69fb      	ldr	r3, [r7, #28]
 800cf9c:	611a      	str	r2, [r3, #16]
        /* put this listening pcb at the head of the listening list */
        tcp_listen_pcbs.listen_pcbs = lpcb;
 800cf9e:	4b59      	ldr	r3, [pc, #356]	; (800d104 <tcp_input+0x818>)
 800cfa0:	69fa      	ldr	r2, [r7, #28]
 800cfa2:	601a      	str	r2, [r3, #0]
#ifdef LWIP_HOOK_TCP_INPACKET_PCB
      if (LWIP_HOOK_TCP_INPACKET_PCB((struct tcp_pcb *)lpcb, tcphdr, tcphdr_optlen,
                                     tcphdr_opt1len, tcphdr_opt2, p) == ERR_OK)
#endif
      {
        tcp_listen_input(lpcb);
 800cfa4:	69fb      	ldr	r3, [r7, #28]
 800cfa6:	0018      	movs	r0, r3
 800cfa8:	f000 fa34 	bl	800d414 <tcp_listen_input>
      }
      pbuf_free(p);
 800cfac:	687b      	ldr	r3, [r7, #4]
 800cfae:	0018      	movs	r0, r3
 800cfb0:	f7fc ff84 	bl	8009ebc <pbuf_free>
      return;
 800cfb4:	e1ca      	b.n	800d34c <tcp_input+0xa60>
      tcphdr_opt1len, tcphdr_opt2, p) != ERR_OK) {
    pbuf_free(p);
    return;
  }
#endif
  if (pcb != NULL) {
 800cfb6:	6a3b      	ldr	r3, [r7, #32]
 800cfb8:	2b00      	cmp	r3, #0
 800cfba:	d100      	bne.n	800cfbe <tcp_input+0x6d2>
 800cfbc:	e17f      	b.n	800d2be <tcp_input+0x9d2>
#if TCP_INPUT_DEBUG
    tcp_debug_print_state(pcb->state);
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
 800cfbe:	4b52      	ldr	r3, [pc, #328]	; (800d108 <tcp_input+0x81c>)
 800cfc0:	2200      	movs	r2, #0
 800cfc2:	601a      	str	r2, [r3, #0]
    inseg.len = p->tot_len;
 800cfc4:	687b      	ldr	r3, [r7, #4]
 800cfc6:	891a      	ldrh	r2, [r3, #8]
 800cfc8:	4b4f      	ldr	r3, [pc, #316]	; (800d108 <tcp_input+0x81c>)
 800cfca:	811a      	strh	r2, [r3, #8]
    inseg.p = p;
 800cfcc:	4b4e      	ldr	r3, [pc, #312]	; (800d108 <tcp_input+0x81c>)
 800cfce:	687a      	ldr	r2, [r7, #4]
 800cfd0:	605a      	str	r2, [r3, #4]
    inseg.tcphdr = tcphdr;
 800cfd2:	4b43      	ldr	r3, [pc, #268]	; (800d0e0 <tcp_input+0x7f4>)
 800cfd4:	681a      	ldr	r2, [r3, #0]
 800cfd6:	4b4c      	ldr	r3, [pc, #304]	; (800d108 <tcp_input+0x81c>)
 800cfd8:	611a      	str	r2, [r3, #16]

    recv_data = NULL;
 800cfda:	4b4c      	ldr	r3, [pc, #304]	; (800d10c <tcp_input+0x820>)
 800cfdc:	2200      	movs	r2, #0
 800cfde:	601a      	str	r2, [r3, #0]
    recv_flags = 0;
 800cfe0:	4b4b      	ldr	r3, [pc, #300]	; (800d110 <tcp_input+0x824>)
 800cfe2:	2200      	movs	r2, #0
 800cfe4:	701a      	strb	r2, [r3, #0]
    recv_acked = 0;
 800cfe6:	4b4b      	ldr	r3, [pc, #300]	; (800d114 <tcp_input+0x828>)
 800cfe8:	2200      	movs	r2, #0
 800cfea:	801a      	strh	r2, [r3, #0]

    if (flags & TCP_PSH) {
 800cfec:	4b4a      	ldr	r3, [pc, #296]	; (800d118 <tcp_input+0x82c>)
 800cfee:	781b      	ldrb	r3, [r3, #0]
 800cff0:	001a      	movs	r2, r3
 800cff2:	2308      	movs	r3, #8
 800cff4:	4013      	ands	r3, r2
 800cff6:	d006      	beq.n	800d006 <tcp_input+0x71a>
      p->flags |= PBUF_FLAG_PUSH;
 800cff8:	687b      	ldr	r3, [r7, #4]
 800cffa:	7b5b      	ldrb	r3, [r3, #13]
 800cffc:	2201      	movs	r2, #1
 800cffe:	4313      	orrs	r3, r2
 800d000:	b2da      	uxtb	r2, r3
 800d002:	687b      	ldr	r3, [r7, #4]
 800d004:	735a      	strb	r2, [r3, #13]
    }

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
 800d006:	6a3b      	ldr	r3, [r7, #32]
 800d008:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800d00a:	2b00      	cmp	r3, #0
 800d00c:	d018      	beq.n	800d040 <tcp_input+0x754>
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 800d00e:	6a3b      	ldr	r3, [r7, #32]
 800d010:	0018      	movs	r0, r3
 800d012:	f7fe ff23 	bl	800be5c <tcp_process_refused_data>
 800d016:	0003      	movs	r3, r0
 800d018:	330d      	adds	r3, #13
 800d01a:	d007      	beq.n	800d02c <tcp_input+0x740>
          ((pcb->refused_data != NULL) && (tcplen > 0))) {
 800d01c:	6a3b      	ldr	r3, [r7, #32]
 800d01e:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 800d020:	2b00      	cmp	r3, #0
 800d022:	d00d      	beq.n	800d040 <tcp_input+0x754>
          ((pcb->refused_data != NULL) && (tcplen > 0))) {
 800d024:	4b3d      	ldr	r3, [pc, #244]	; (800d11c <tcp_input+0x830>)
 800d026:	881b      	ldrh	r3, [r3, #0]
 800d028:	2b00      	cmp	r3, #0
 800d02a:	d009      	beq.n	800d040 <tcp_input+0x754>
        /* pcb has been aborted or refused data is still refused and the new
           segment contains data */
        if (pcb->rcv_ann_wnd == 0) {
 800d02c:	6a3b      	ldr	r3, [r7, #32]
 800d02e:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
 800d030:	2b00      	cmp	r3, #0
 800d032:	d000      	beq.n	800d036 <tcp_input+0x74a>
 800d034:	e123      	b.n	800d27e <tcp_input+0x992>
          /* this is a zero-window probe, we respond to it with current RCV.NXT
          and drop the data segment */
          tcp_send_empty_ack(pcb);
 800d036:	6a3b      	ldr	r3, [r7, #32]
 800d038:	0018      	movs	r0, r3
 800d03a:	f004 ff53 	bl	8011ee4 <tcp_send_empty_ack>
        }
        TCP_STATS_INC(tcp.drop);
        MIB2_STATS_INC(mib2.tcpinerrs);
        goto aborted;
 800d03e:	e11e      	b.n	800d27e <tcp_input+0x992>
      }
    }
    tcp_input_pcb = pcb;
 800d040:	4b37      	ldr	r3, [pc, #220]	; (800d120 <tcp_input+0x834>)
 800d042:	6a3a      	ldr	r2, [r7, #32]
 800d044:	601a      	str	r2, [r3, #0]
    err = tcp_process(pcb);
 800d046:	2513      	movs	r5, #19
 800d048:	197c      	adds	r4, r7, r5
 800d04a:	6a3b      	ldr	r3, [r7, #32]
 800d04c:	0018      	movs	r0, r3
 800d04e:	f000 fb81 	bl	800d754 <tcp_process>
 800d052:	0003      	movs	r3, r0
 800d054:	7023      	strb	r3, [r4, #0]
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
 800d056:	197b      	adds	r3, r7, r5
 800d058:	781b      	ldrb	r3, [r3, #0]
 800d05a:	b25b      	sxtb	r3, r3
 800d05c:	330d      	adds	r3, #13
 800d05e:	d100      	bne.n	800d062 <tcp_input+0x776>
 800d060:	e10f      	b.n	800d282 <tcp_input+0x996>
      if (recv_flags & TF_RESET) {
 800d062:	4b2b      	ldr	r3, [pc, #172]	; (800d110 <tcp_input+0x824>)
 800d064:	781b      	ldrb	r3, [r3, #0]
 800d066:	001a      	movs	r2, r3
 800d068:	2308      	movs	r3, #8
 800d06a:	4013      	ands	r3, r2
 800d06c:	d018      	beq.n	800d0a0 <tcp_input+0x7b4>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_RST);
 800d06e:	6a3b      	ldr	r3, [r7, #32]
 800d070:	2294      	movs	r2, #148	; 0x94
 800d072:	589b      	ldr	r3, [r3, r2]
 800d074:	2b00      	cmp	r3, #0
 800d076:	d008      	beq.n	800d08a <tcp_input+0x79e>
 800d078:	6a3b      	ldr	r3, [r7, #32]
 800d07a:	2294      	movs	r2, #148	; 0x94
 800d07c:	589a      	ldr	r2, [r3, r2]
 800d07e:	6a3b      	ldr	r3, [r7, #32]
 800d080:	695b      	ldr	r3, [r3, #20]
 800d082:	210e      	movs	r1, #14
 800d084:	4249      	negs	r1, r1
 800d086:	0018      	movs	r0, r3
 800d088:	4790      	blx	r2
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
 800d08a:	6a3a      	ldr	r2, [r7, #32]
 800d08c:	4b19      	ldr	r3, [pc, #100]	; (800d0f4 <tcp_input+0x808>)
 800d08e:	0011      	movs	r1, r2
 800d090:	0018      	movs	r0, r3
 800d092:	f7ff fa91 	bl	800c5b8 <tcp_pcb_remove>
        tcp_free(pcb);
 800d096:	6a3b      	ldr	r3, [r7, #32]
 800d098:	0018      	movs	r0, r3
 800d09a:	f7fd fd65 	bl	800ab68 <tcp_free>
 800d09e:	e0fb      	b.n	800d298 <tcp_input+0x9ac>
      } else {
        err = ERR_OK;
 800d0a0:	2113      	movs	r1, #19
 800d0a2:	187b      	adds	r3, r7, r1
 800d0a4:	2200      	movs	r2, #0
 800d0a6:	701a      	strb	r2, [r3, #0]
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (recv_acked > 0) {
 800d0a8:	4b1a      	ldr	r3, [pc, #104]	; (800d114 <tcp_input+0x828>)
 800d0aa:	881b      	ldrh	r3, [r3, #0]
 800d0ac:	2b00      	cmp	r3, #0
 800d0ae:	d047      	beq.n	800d140 <tcp_input+0x854>
          while (acked > 0) {
            acked16 = (u16_t)LWIP_MIN(acked, 0xffffu);
            acked -= acked16;
#else
          {
            acked16 = recv_acked;
 800d0b0:	260a      	movs	r6, #10
 800d0b2:	19bb      	adds	r3, r7, r6
 800d0b4:	4a17      	ldr	r2, [pc, #92]	; (800d114 <tcp_input+0x828>)
 800d0b6:	8812      	ldrh	r2, [r2, #0]
 800d0b8:	801a      	strh	r2, [r3, #0]
#endif
            TCP_EVENT_SENT(pcb, (u16_t)acked16, err);
 800d0ba:	6a3b      	ldr	r3, [r7, #32]
 800d0bc:	2284      	movs	r2, #132	; 0x84
 800d0be:	589b      	ldr	r3, [r3, r2]
 800d0c0:	2b00      	cmp	r3, #0
 800d0c2:	d02f      	beq.n	800d124 <tcp_input+0x838>
 800d0c4:	6a3b      	ldr	r3, [r7, #32]
 800d0c6:	2284      	movs	r2, #132	; 0x84
 800d0c8:	589d      	ldr	r5, [r3, r2]
 800d0ca:	6a3b      	ldr	r3, [r7, #32]
 800d0cc:	6958      	ldr	r0, [r3, #20]
 800d0ce:	187c      	adds	r4, r7, r1
 800d0d0:	19bb      	adds	r3, r7, r6
 800d0d2:	881a      	ldrh	r2, [r3, #0]
 800d0d4:	6a3b      	ldr	r3, [r7, #32]
 800d0d6:	0019      	movs	r1, r3
 800d0d8:	47a8      	blx	r5
 800d0da:	0003      	movs	r3, r0
 800d0dc:	7023      	strb	r3, [r4, #0]
 800d0de:	e025      	b.n	800d12c <tcp_input+0x840>
 800d0e0:	200017a8 	.word	0x200017a8
 800d0e4:	200018fc 	.word	0x200018fc
 800d0e8:	080205bc 	.word	0x080205bc
 800d0ec:	080206e0 	.word	0x080206e0
 800d0f0:	080205fc 	.word	0x080205fc
 800d0f4:	20002b3c 	.word	0x20002b3c
 800d0f8:	0802070c 	.word	0x0802070c
 800d0fc:	20002b4c 	.word	0x20002b4c
 800d100:	08020738 	.word	0x08020738
 800d104:	20002b44 	.word	0x20002b44
 800d108:	20001794 	.word	0x20001794
 800d10c:	200017c8 	.word	0x200017c8
 800d110:	200017c5 	.word	0x200017c5
 800d114:	200017c0 	.word	0x200017c0
 800d118:	200017c4 	.word	0x200017c4
 800d11c:	200017c2 	.word	0x200017c2
 800d120:	20002b50 	.word	0x20002b50
 800d124:	2313      	movs	r3, #19
 800d126:	18fb      	adds	r3, r7, r3
 800d128:	2200      	movs	r2, #0
 800d12a:	701a      	strb	r2, [r3, #0]
            if (err == ERR_ABRT) {
 800d12c:	2313      	movs	r3, #19
 800d12e:	18fb      	adds	r3, r7, r3
 800d130:	781b      	ldrb	r3, [r3, #0]
 800d132:	b25b      	sxtb	r3, r3
 800d134:	330d      	adds	r3, #13
 800d136:	d100      	bne.n	800d13a <tcp_input+0x84e>
 800d138:	e0a5      	b.n	800d286 <tcp_input+0x99a>
              goto aborted;
            }
          }
          recv_acked = 0;
 800d13a:	4b86      	ldr	r3, [pc, #536]	; (800d354 <tcp_input+0xa68>)
 800d13c:	2200      	movs	r2, #0
 800d13e:	801a      	strh	r2, [r3, #0]
        }
        if (tcp_input_delayed_close(pcb)) {
 800d140:	6a3b      	ldr	r3, [r7, #32]
 800d142:	0018      	movs	r0, r3
 800d144:	f000 f922 	bl	800d38c <tcp_input_delayed_close>
 800d148:	1e03      	subs	r3, r0, #0
 800d14a:	d000      	beq.n	800d14e <tcp_input+0x862>
 800d14c:	e09d      	b.n	800d28a <tcp_input+0x99e>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
        while (recv_data != NULL) {
          struct pbuf *rest = NULL;
          pbuf_split_64k(recv_data, &rest);
#else /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
        if (recv_data != NULL) {
 800d14e:	4b82      	ldr	r3, [pc, #520]	; (800d358 <tcp_input+0xa6c>)
 800d150:	681b      	ldr	r3, [r3, #0]
 800d152:	2b00      	cmp	r3, #0
 800d154:	d048      	beq.n	800d1e8 <tcp_input+0x8fc>
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */

          LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
 800d156:	6a3b      	ldr	r3, [r7, #32]
 800d158:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800d15a:	2b00      	cmp	r3, #0
 800d15c:	d006      	beq.n	800d16c <tcp_input+0x880>
 800d15e:	4b7f      	ldr	r3, [pc, #508]	; (800d35c <tcp_input+0xa70>)
 800d160:	22f3      	movs	r2, #243	; 0xf3
 800d162:	0052      	lsls	r2, r2, #1
 800d164:	497e      	ldr	r1, [pc, #504]	; (800d360 <tcp_input+0xa74>)
 800d166:	487f      	ldr	r0, [pc, #508]	; (800d364 <tcp_input+0xa78>)
 800d168:	f7f5 fd2e 	bl	8002bc8 <app_debug_rtt_raw>
          if (pcb->flags & TF_RXCLOSED) {
 800d16c:	6a3b      	ldr	r3, [r7, #32]
 800d16e:	8bdb      	ldrh	r3, [r3, #30]
 800d170:	001a      	movs	r2, r3
 800d172:	2310      	movs	r3, #16
 800d174:	4013      	ands	r3, r2
 800d176:	d009      	beq.n	800d18c <tcp_input+0x8a0>
            /* received data although already closed -> abort (send RST) to
               notify the remote host that not all data has been processed */
            pbuf_free(recv_data);
 800d178:	4b77      	ldr	r3, [pc, #476]	; (800d358 <tcp_input+0xa6c>)
 800d17a:	681b      	ldr	r3, [r3, #0]
 800d17c:	0018      	movs	r0, r3
 800d17e:	f7fc fe9d 	bl	8009ebc <pbuf_free>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
            if (rest != NULL) {
              pbuf_free(rest);
            }
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
            tcp_abort(pcb);
 800d182:	6a3b      	ldr	r3, [r7, #32]
 800d184:	0018      	movs	r0, r3
 800d186:	f7fe f805 	bl	800b194 <tcp_abort>
            goto aborted;
 800d18a:	e085      	b.n	800d298 <tcp_input+0x9ac>
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 800d18c:	6a3b      	ldr	r3, [r7, #32]
 800d18e:	2288      	movs	r2, #136	; 0x88
 800d190:	589b      	ldr	r3, [r3, r2]
 800d192:	2b00      	cmp	r3, #0
 800d194:	d00e      	beq.n	800d1b4 <tcp_input+0x8c8>
 800d196:	6a3b      	ldr	r3, [r7, #32]
 800d198:	2288      	movs	r2, #136	; 0x88
 800d19a:	589d      	ldr	r5, [r3, r2]
 800d19c:	6a3b      	ldr	r3, [r7, #32]
 800d19e:	6958      	ldr	r0, [r3, #20]
 800d1a0:	4b6d      	ldr	r3, [pc, #436]	; (800d358 <tcp_input+0xa6c>)
 800d1a2:	681a      	ldr	r2, [r3, #0]
 800d1a4:	2313      	movs	r3, #19
 800d1a6:	18fc      	adds	r4, r7, r3
 800d1a8:	6a39      	ldr	r1, [r7, #32]
 800d1aa:	2300      	movs	r3, #0
 800d1ac:	47a8      	blx	r5
 800d1ae:	0003      	movs	r3, r0
 800d1b0:	7023      	strb	r3, [r4, #0]
 800d1b2:	e00a      	b.n	800d1ca <tcp_input+0x8de>
 800d1b4:	4b68      	ldr	r3, [pc, #416]	; (800d358 <tcp_input+0xa6c>)
 800d1b6:	681a      	ldr	r2, [r3, #0]
 800d1b8:	2313      	movs	r3, #19
 800d1ba:	18fc      	adds	r4, r7, r3
 800d1bc:	6a39      	ldr	r1, [r7, #32]
 800d1be:	2300      	movs	r3, #0
 800d1c0:	2000      	movs	r0, #0
 800d1c2:	f7fe ff31 	bl	800c028 <tcp_recv_null>
 800d1c6:	0003      	movs	r3, r0
 800d1c8:	7023      	strb	r3, [r4, #0]
          if (err == ERR_ABRT) {
 800d1ca:	2213      	movs	r2, #19
 800d1cc:	18bb      	adds	r3, r7, r2
 800d1ce:	781b      	ldrb	r3, [r3, #0]
 800d1d0:	b25b      	sxtb	r3, r3
 800d1d2:	330d      	adds	r3, #13
 800d1d4:	d05b      	beq.n	800d28e <tcp_input+0x9a2>
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
            goto aborted;
          }

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
 800d1d6:	18bb      	adds	r3, r7, r2
 800d1d8:	781b      	ldrb	r3, [r3, #0]
 800d1da:	b25b      	sxtb	r3, r3
 800d1dc:	2b00      	cmp	r3, #0
 800d1de:	d003      	beq.n	800d1e8 <tcp_input+0x8fc>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
            if (rest != NULL) {
              pbuf_cat(recv_data, rest);
            }
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
            pcb->refused_data = recv_data;
 800d1e0:	4b5d      	ldr	r3, [pc, #372]	; (800d358 <tcp_input+0xa6c>)
 800d1e2:	681a      	ldr	r2, [r3, #0]
 800d1e4:	6a3b      	ldr	r3, [r7, #32]
 800d1e6:	67da      	str	r2, [r3, #124]	; 0x7c
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
 800d1e8:	4b5f      	ldr	r3, [pc, #380]	; (800d368 <tcp_input+0xa7c>)
 800d1ea:	781b      	ldrb	r3, [r3, #0]
 800d1ec:	001a      	movs	r2, r3
 800d1ee:	2320      	movs	r3, #32
 800d1f0:	4013      	ands	r3, r2
 800d1f2:	d036      	beq.n	800d262 <tcp_input+0x976>
          if (pcb->refused_data != NULL) {
 800d1f4:	6a3b      	ldr	r3, [r7, #32]
 800d1f6:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800d1f8:	2b00      	cmp	r3, #0
 800d1fa:	d009      	beq.n	800d210 <tcp_input+0x924>
            /* Delay this if we have refused data. */
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
 800d1fc:	6a3b      	ldr	r3, [r7, #32]
 800d1fe:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800d200:	7b5a      	ldrb	r2, [r3, #13]
 800d202:	6a3b      	ldr	r3, [r7, #32]
 800d204:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800d206:	2120      	movs	r1, #32
 800d208:	430a      	orrs	r2, r1
 800d20a:	b2d2      	uxtb	r2, r2
 800d20c:	735a      	strb	r2, [r3, #13]
 800d20e:	e028      	b.n	800d262 <tcp_input+0x976>
          } else {
            /* correct rcv_wnd as the application won't call tcp_recved()
               for the FIN's seqno */
            if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
 800d210:	6a3b      	ldr	r3, [r7, #32]
 800d212:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800d214:	2386      	movs	r3, #134	; 0x86
 800d216:	00db      	lsls	r3, r3, #3
 800d218:	429a      	cmp	r2, r3
 800d21a:	d005      	beq.n	800d228 <tcp_input+0x93c>
              pcb->rcv_wnd++;
 800d21c:	6a3b      	ldr	r3, [r7, #32]
 800d21e:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 800d220:	3301      	adds	r3, #1
 800d222:	b29a      	uxth	r2, r3
 800d224:	6a3b      	ldr	r3, [r7, #32]
 800d226:	859a      	strh	r2, [r3, #44]	; 0x2c
            }
            TCP_EVENT_CLOSED(pcb, err);
 800d228:	6a3b      	ldr	r3, [r7, #32]
 800d22a:	2288      	movs	r2, #136	; 0x88
 800d22c:	589b      	ldr	r3, [r3, r2]
 800d22e:	2b00      	cmp	r3, #0
 800d230:	d00d      	beq.n	800d24e <tcp_input+0x962>
 800d232:	6a3b      	ldr	r3, [r7, #32]
 800d234:	2288      	movs	r2, #136	; 0x88
 800d236:	589d      	ldr	r5, [r3, r2]
 800d238:	6a3b      	ldr	r3, [r7, #32]
 800d23a:	6958      	ldr	r0, [r3, #20]
 800d23c:	2313      	movs	r3, #19
 800d23e:	18fc      	adds	r4, r7, r3
 800d240:	6a39      	ldr	r1, [r7, #32]
 800d242:	2300      	movs	r3, #0
 800d244:	2200      	movs	r2, #0
 800d246:	47a8      	blx	r5
 800d248:	0003      	movs	r3, r0
 800d24a:	7023      	strb	r3, [r4, #0]
 800d24c:	e003      	b.n	800d256 <tcp_input+0x96a>
 800d24e:	2313      	movs	r3, #19
 800d250:	18fb      	adds	r3, r7, r3
 800d252:	2200      	movs	r2, #0
 800d254:	701a      	strb	r2, [r3, #0]
            if (err == ERR_ABRT) {
 800d256:	2313      	movs	r3, #19
 800d258:	18fb      	adds	r3, r7, r3
 800d25a:	781b      	ldrb	r3, [r3, #0]
 800d25c:	b25b      	sxtb	r3, r3
 800d25e:	330d      	adds	r3, #13
 800d260:	d017      	beq.n	800d292 <tcp_input+0x9a6>
              goto aborted;
            }
          }
        }

        tcp_input_pcb = NULL;
 800d262:	4b42      	ldr	r3, [pc, #264]	; (800d36c <tcp_input+0xa80>)
 800d264:	2200      	movs	r2, #0
 800d266:	601a      	str	r2, [r3, #0]
        if (tcp_input_delayed_close(pcb)) {
 800d268:	6a3b      	ldr	r3, [r7, #32]
 800d26a:	0018      	movs	r0, r3
 800d26c:	f000 f88e 	bl	800d38c <tcp_input_delayed_close>
 800d270:	1e03      	subs	r3, r0, #0
 800d272:	d110      	bne.n	800d296 <tcp_input+0x9aa>
          goto aborted;
        }
        /* Try to send something out. */
        tcp_output(pcb);
 800d274:	6a3b      	ldr	r3, [r7, #32]
 800d276:	0018      	movs	r0, r3
 800d278:	f003 fd80 	bl	8010d7c <tcp_output>
 800d27c:	e00c      	b.n	800d298 <tcp_input+0x9ac>
        goto aborted;
 800d27e:	46c0      	nop			; (mov r8, r8)
 800d280:	e00a      	b.n	800d298 <tcp_input+0x9ac>
#endif /* TCP_INPUT_DEBUG */
      }
    }
    /* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).
       Below this line, 'pcb' may not be dereferenced! */
aborted:
 800d282:	46c0      	nop			; (mov r8, r8)
 800d284:	e008      	b.n	800d298 <tcp_input+0x9ac>
              goto aborted;
 800d286:	46c0      	nop			; (mov r8, r8)
 800d288:	e006      	b.n	800d298 <tcp_input+0x9ac>
          goto aborted;
 800d28a:	46c0      	nop			; (mov r8, r8)
 800d28c:	e004      	b.n	800d298 <tcp_input+0x9ac>
            goto aborted;
 800d28e:	46c0      	nop			; (mov r8, r8)
 800d290:	e002      	b.n	800d298 <tcp_input+0x9ac>
              goto aborted;
 800d292:	46c0      	nop			; (mov r8, r8)
 800d294:	e000      	b.n	800d298 <tcp_input+0x9ac>
          goto aborted;
 800d296:	46c0      	nop			; (mov r8, r8)
    tcp_input_pcb = NULL;
 800d298:	4b34      	ldr	r3, [pc, #208]	; (800d36c <tcp_input+0xa80>)
 800d29a:	2200      	movs	r2, #0
 800d29c:	601a      	str	r2, [r3, #0]
    recv_data = NULL;
 800d29e:	4b2e      	ldr	r3, [pc, #184]	; (800d358 <tcp_input+0xa6c>)
 800d2a0:	2200      	movs	r2, #0
 800d2a2:	601a      	str	r2, [r3, #0]

    /* give up our reference to inseg.p */
    if (inseg.p != NULL) {
 800d2a4:	4b32      	ldr	r3, [pc, #200]	; (800d370 <tcp_input+0xa84>)
 800d2a6:	685b      	ldr	r3, [r3, #4]
 800d2a8:	2b00      	cmp	r3, #0
 800d2aa:	d04e      	beq.n	800d34a <tcp_input+0xa5e>
      pbuf_free(inseg.p);
 800d2ac:	4b30      	ldr	r3, [pc, #192]	; (800d370 <tcp_input+0xa84>)
 800d2ae:	685b      	ldr	r3, [r3, #4]
 800d2b0:	0018      	movs	r0, r3
 800d2b2:	f7fc fe03 	bl	8009ebc <pbuf_free>
      inseg.p = NULL;
 800d2b6:	4b2e      	ldr	r3, [pc, #184]	; (800d370 <tcp_input+0xa84>)
 800d2b8:	2200      	movs	r2, #0
 800d2ba:	605a      	str	r2, [r3, #4]
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
 800d2bc:	e045      	b.n	800d34a <tcp_input+0xa5e>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
 800d2be:	4b2d      	ldr	r3, [pc, #180]	; (800d374 <tcp_input+0xa88>)
 800d2c0:	681b      	ldr	r3, [r3, #0]
 800d2c2:	7b1a      	ldrb	r2, [r3, #12]
 800d2c4:	7b5b      	ldrb	r3, [r3, #13]
 800d2c6:	021b      	lsls	r3, r3, #8
 800d2c8:	4313      	orrs	r3, r2
 800d2ca:	b29b      	uxth	r3, r3
 800d2cc:	0018      	movs	r0, r3
 800d2ce:	f7f9 fe11 	bl	8006ef4 <lwip_htons>
 800d2d2:	0003      	movs	r3, r0
 800d2d4:	b2db      	uxtb	r3, r3
 800d2d6:	001a      	movs	r2, r3
 800d2d8:	2304      	movs	r3, #4
 800d2da:	4013      	ands	r3, r2
 800d2dc:	d120      	bne.n	800d320 <tcp_input+0xa34>
      tcp_rst(NULL, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d2de:	4b26      	ldr	r3, [pc, #152]	; (800d378 <tcp_input+0xa8c>)
 800d2e0:	6818      	ldr	r0, [r3, #0]
 800d2e2:	4b26      	ldr	r3, [pc, #152]	; (800d37c <tcp_input+0xa90>)
 800d2e4:	881b      	ldrh	r3, [r3, #0]
 800d2e6:	001a      	movs	r2, r3
 800d2e8:	4b25      	ldr	r3, [pc, #148]	; (800d380 <tcp_input+0xa94>)
 800d2ea:	681b      	ldr	r3, [r3, #0]
 800d2ec:	18d4      	adds	r4, r2, r3
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800d2ee:	4b21      	ldr	r3, [pc, #132]	; (800d374 <tcp_input+0xa88>)
 800d2f0:	681b      	ldr	r3, [r3, #0]
      tcp_rst(NULL, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d2f2:	789a      	ldrb	r2, [r3, #2]
 800d2f4:	78db      	ldrb	r3, [r3, #3]
 800d2f6:	021b      	lsls	r3, r3, #8
 800d2f8:	4313      	orrs	r3, r2
 800d2fa:	b29a      	uxth	r2, r3
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800d2fc:	4b1d      	ldr	r3, [pc, #116]	; (800d374 <tcp_input+0xa88>)
 800d2fe:	681b      	ldr	r3, [r3, #0]
      tcp_rst(NULL, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d300:	7819      	ldrb	r1, [r3, #0]
 800d302:	785b      	ldrb	r3, [r3, #1]
 800d304:	021b      	lsls	r3, r3, #8
 800d306:	430b      	orrs	r3, r1
 800d308:	b29b      	uxth	r3, r3
 800d30a:	491e      	ldr	r1, [pc, #120]	; (800d384 <tcp_input+0xa98>)
 800d30c:	9302      	str	r3, [sp, #8]
 800d30e:	9201      	str	r2, [sp, #4]
 800d310:	4b1d      	ldr	r3, [pc, #116]	; (800d388 <tcp_input+0xa9c>)
 800d312:	9300      	str	r3, [sp, #0]
 800d314:	000b      	movs	r3, r1
 800d316:	0022      	movs	r2, r4
 800d318:	0001      	movs	r1, r0
 800d31a:	2000      	movs	r0, #0
 800d31c:	f004 fd82 	bl	8011e24 <tcp_rst>
    pbuf_free(p);
 800d320:	687b      	ldr	r3, [r7, #4]
 800d322:	0018      	movs	r0, r3
 800d324:	f7fc fdca 	bl	8009ebc <pbuf_free>
  return;
 800d328:	e00f      	b.n	800d34a <tcp_input+0xa5e>
    goto dropped;
 800d32a:	46c0      	nop			; (mov r8, r8)
 800d32c:	e008      	b.n	800d340 <tcp_input+0xa54>
    goto dropped;
 800d32e:	46c0      	nop			; (mov r8, r8)
 800d330:	e006      	b.n	800d340 <tcp_input+0xa54>
      goto dropped;
 800d332:	46c0      	nop			; (mov r8, r8)
 800d334:	e004      	b.n	800d340 <tcp_input+0xa54>
    goto dropped;
 800d336:	46c0      	nop			; (mov r8, r8)
 800d338:	e002      	b.n	800d340 <tcp_input+0xa54>
      goto dropped;
 800d33a:	46c0      	nop			; (mov r8, r8)
 800d33c:	e000      	b.n	800d340 <tcp_input+0xa54>
      goto dropped;
 800d33e:	46c0      	nop			; (mov r8, r8)
dropped:
  TCP_STATS_INC(tcp.drop);
  MIB2_STATS_INC(mib2.tcpinerrs);
  pbuf_free(p);
 800d340:	687b      	ldr	r3, [r7, #4]
 800d342:	0018      	movs	r0, r3
 800d344:	f7fc fdba 	bl	8009ebc <pbuf_free>
 800d348:	e000      	b.n	800d34c <tcp_input+0xa60>
  return;
 800d34a:	46c0      	nop			; (mov r8, r8)
}
 800d34c:	46bd      	mov	sp, r7
 800d34e:	b00b      	add	sp, #44	; 0x2c
 800d350:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800d352:	46c0      	nop			; (mov r8, r8)
 800d354:	200017c0 	.word	0x200017c0
 800d358:	200017c8 	.word	0x200017c8
 800d35c:	080205bc 	.word	0x080205bc
 800d360:	08020768 	.word	0x08020768
 800d364:	080205fc 	.word	0x080205fc
 800d368:	200017c5 	.word	0x200017c5
 800d36c:	20002b50 	.word	0x20002b50
 800d370:	20001794 	.word	0x20001794
 800d374:	200017a8 	.word	0x200017a8
 800d378:	200017bc 	.word	0x200017bc
 800d37c:	200017c2 	.word	0x200017c2
 800d380:	200017b8 	.word	0x200017b8
 800d384:	20001910 	.word	0x20001910
 800d388:	2000190c 	.word	0x2000190c

0800d38c <tcp_input_delayed_close>:
 * any more.
 * @returns 1 if the pcb has been closed and deallocated, 0 otherwise
 */
static int
tcp_input_delayed_close(struct tcp_pcb *pcb)
{
 800d38c:	b580      	push	{r7, lr}
 800d38e:	b082      	sub	sp, #8
 800d390:	af00      	add	r7, sp, #0
 800d392:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_input_delayed_close: invalid pcb", pcb != NULL);
 800d394:	687b      	ldr	r3, [r7, #4]
 800d396:	2b00      	cmp	r3, #0
 800d398:	d105      	bne.n	800d3a6 <tcp_input_delayed_close+0x1a>
 800d39a:	4b18      	ldr	r3, [pc, #96]	; (800d3fc <tcp_input_delayed_close+0x70>)
 800d39c:	4a18      	ldr	r2, [pc, #96]	; (800d400 <tcp_input_delayed_close+0x74>)
 800d39e:	4919      	ldr	r1, [pc, #100]	; (800d404 <tcp_input_delayed_close+0x78>)
 800d3a0:	4819      	ldr	r0, [pc, #100]	; (800d408 <tcp_input_delayed_close+0x7c>)
 800d3a2:	f7f5 fc11 	bl	8002bc8 <app_debug_rtt_raw>

  if (recv_flags & TF_CLOSED) {
 800d3a6:	4b19      	ldr	r3, [pc, #100]	; (800d40c <tcp_input_delayed_close+0x80>)
 800d3a8:	781b      	ldrb	r3, [r3, #0]
 800d3aa:	001a      	movs	r2, r3
 800d3ac:	2310      	movs	r3, #16
 800d3ae:	4013      	ands	r3, r2
 800d3b0:	d01f      	beq.n	800d3f2 <tcp_input_delayed_close+0x66>
    /* The connection has been closed and we will deallocate the
        PCB. */
    if (!(pcb->flags & TF_RXCLOSED)) {
 800d3b2:	687b      	ldr	r3, [r7, #4]
 800d3b4:	8bdb      	ldrh	r3, [r3, #30]
 800d3b6:	001a      	movs	r2, r3
 800d3b8:	2310      	movs	r3, #16
 800d3ba:	4013      	ands	r3, r2
 800d3bc:	d10d      	bne.n	800d3da <tcp_input_delayed_close+0x4e>
      /* Connection closed although the application has only shut down the
          tx side: call the PCB's err callback and indicate the closure to
          ensure the application doesn't continue using the PCB. */
      TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_CLSD);
 800d3be:	687b      	ldr	r3, [r7, #4]
 800d3c0:	2294      	movs	r2, #148	; 0x94
 800d3c2:	589b      	ldr	r3, [r3, r2]
 800d3c4:	2b00      	cmp	r3, #0
 800d3c6:	d008      	beq.n	800d3da <tcp_input_delayed_close+0x4e>
 800d3c8:	687b      	ldr	r3, [r7, #4]
 800d3ca:	2294      	movs	r2, #148	; 0x94
 800d3cc:	589a      	ldr	r2, [r3, r2]
 800d3ce:	687b      	ldr	r3, [r7, #4]
 800d3d0:	695b      	ldr	r3, [r3, #20]
 800d3d2:	210f      	movs	r1, #15
 800d3d4:	4249      	negs	r1, r1
 800d3d6:	0018      	movs	r0, r3
 800d3d8:	4790      	blx	r2
    }
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
 800d3da:	687a      	ldr	r2, [r7, #4]
 800d3dc:	4b0c      	ldr	r3, [pc, #48]	; (800d410 <tcp_input_delayed_close+0x84>)
 800d3de:	0011      	movs	r1, r2
 800d3e0:	0018      	movs	r0, r3
 800d3e2:	f7ff f8e9 	bl	800c5b8 <tcp_pcb_remove>
    tcp_free(pcb);
 800d3e6:	687b      	ldr	r3, [r7, #4]
 800d3e8:	0018      	movs	r0, r3
 800d3ea:	f7fd fbbd 	bl	800ab68 <tcp_free>
    return 1;
 800d3ee:	2301      	movs	r3, #1
 800d3f0:	e000      	b.n	800d3f4 <tcp_input_delayed_close+0x68>
  }
  return 0;
 800d3f2:	2300      	movs	r3, #0
}
 800d3f4:	0018      	movs	r0, r3
 800d3f6:	46bd      	mov	sp, r7
 800d3f8:	b002      	add	sp, #8
 800d3fa:	bd80      	pop	{r7, pc}
 800d3fc:	080205bc 	.word	0x080205bc
 800d400:	0000025a 	.word	0x0000025a
 800d404:	08020784 	.word	0x08020784
 800d408:	080205fc 	.word	0x080205fc
 800d40c:	200017c5 	.word	0x200017c5
 800d410:	20002b3c 	.word	0x20002b3c

0800d414 <tcp_listen_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static void
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
 800d414:	b5b0      	push	{r4, r5, r7, lr}
 800d416:	b08a      	sub	sp, #40	; 0x28
 800d418:	af04      	add	r7, sp, #16
 800d41a:	6078      	str	r0, [r7, #4]
  struct tcp_pcb *npcb;
  u32_t iss;
  err_t rc;

  if (flags & TCP_RST) {
 800d41c:	4b7d      	ldr	r3, [pc, #500]	; (800d614 <tcp_listen_input+0x200>)
 800d41e:	781b      	ldrb	r3, [r3, #0]
 800d420:	001a      	movs	r2, r3
 800d422:	2304      	movs	r3, #4
 800d424:	4013      	ands	r3, r2
 800d426:	d000      	beq.n	800d42a <tcp_listen_input+0x16>
 800d428:	e0ee      	b.n	800d608 <tcp_listen_input+0x1f4>
    /* An incoming RST should be ignored. Return. */
    return;
  }

  LWIP_ASSERT("tcp_listen_input: invalid pcb", pcb != NULL);
 800d42a:	687b      	ldr	r3, [r7, #4]
 800d42c:	2b00      	cmp	r3, #0
 800d42e:	d105      	bne.n	800d43c <tcp_listen_input+0x28>
 800d430:	4b79      	ldr	r3, [pc, #484]	; (800d618 <tcp_listen_input+0x204>)
 800d432:	4a7a      	ldr	r2, [pc, #488]	; (800d61c <tcp_listen_input+0x208>)
 800d434:	497a      	ldr	r1, [pc, #488]	; (800d620 <tcp_listen_input+0x20c>)
 800d436:	487b      	ldr	r0, [pc, #492]	; (800d624 <tcp_listen_input+0x210>)
 800d438:	f7f5 fbc6 	bl	8002bc8 <app_debug_rtt_raw>

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
 800d43c:	4b75      	ldr	r3, [pc, #468]	; (800d614 <tcp_listen_input+0x200>)
 800d43e:	781b      	ldrb	r3, [r3, #0]
 800d440:	001a      	movs	r2, r3
 800d442:	2310      	movs	r3, #16
 800d444:	4013      	ands	r3, r2
 800d446:	d021      	beq.n	800d48c <tcp_listen_input+0x78>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst((const struct tcp_pcb *)pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d448:	4b77      	ldr	r3, [pc, #476]	; (800d628 <tcp_listen_input+0x214>)
 800d44a:	681c      	ldr	r4, [r3, #0]
 800d44c:	4b77      	ldr	r3, [pc, #476]	; (800d62c <tcp_listen_input+0x218>)
 800d44e:	881b      	ldrh	r3, [r3, #0]
 800d450:	001a      	movs	r2, r3
 800d452:	4b77      	ldr	r3, [pc, #476]	; (800d630 <tcp_listen_input+0x21c>)
 800d454:	681b      	ldr	r3, [r3, #0]
 800d456:	18d5      	adds	r5, r2, r3
            ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800d458:	4b76      	ldr	r3, [pc, #472]	; (800d634 <tcp_listen_input+0x220>)
 800d45a:	681b      	ldr	r3, [r3, #0]
    tcp_rst((const struct tcp_pcb *)pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d45c:	789a      	ldrb	r2, [r3, #2]
 800d45e:	78db      	ldrb	r3, [r3, #3]
 800d460:	021b      	lsls	r3, r3, #8
 800d462:	4313      	orrs	r3, r2
 800d464:	b29a      	uxth	r2, r3
            ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800d466:	4b73      	ldr	r3, [pc, #460]	; (800d634 <tcp_listen_input+0x220>)
 800d468:	681b      	ldr	r3, [r3, #0]
    tcp_rst((const struct tcp_pcb *)pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d46a:	7819      	ldrb	r1, [r3, #0]
 800d46c:	785b      	ldrb	r3, [r3, #1]
 800d46e:	021b      	lsls	r3, r3, #8
 800d470:	430b      	orrs	r3, r1
 800d472:	b29b      	uxth	r3, r3
 800d474:	4970      	ldr	r1, [pc, #448]	; (800d638 <tcp_listen_input+0x224>)
 800d476:	6878      	ldr	r0, [r7, #4]
 800d478:	9302      	str	r3, [sp, #8]
 800d47a:	9201      	str	r2, [sp, #4]
 800d47c:	4b6f      	ldr	r3, [pc, #444]	; (800d63c <tcp_listen_input+0x228>)
 800d47e:	9300      	str	r3, [sp, #0]
 800d480:	000b      	movs	r3, r1
 800d482:	002a      	movs	r2, r5
 800d484:	0021      	movs	r1, r4
 800d486:	f004 fccd 	bl	8011e24 <tcp_rst>
      tcp_abandon(npcb, 0);
      return;
    }
    tcp_output(npcb);
  }
  return;
 800d48a:	e0bf      	b.n	800d60c <tcp_listen_input+0x1f8>
  } else if (flags & TCP_SYN) {
 800d48c:	4b61      	ldr	r3, [pc, #388]	; (800d614 <tcp_listen_input+0x200>)
 800d48e:	781b      	ldrb	r3, [r3, #0]
 800d490:	001a      	movs	r2, r3
 800d492:	2302      	movs	r3, #2
 800d494:	4013      	ands	r3, r2
 800d496:	d100      	bne.n	800d49a <tcp_listen_input+0x86>
 800d498:	e0b8      	b.n	800d60c <tcp_listen_input+0x1f8>
    npcb = tcp_alloc(pcb->prio);
 800d49a:	687b      	ldr	r3, [r7, #4]
 800d49c:	7e5b      	ldrb	r3, [r3, #25]
 800d49e:	0018      	movs	r0, r3
 800d4a0:	f7fe fefa 	bl	800c298 <tcp_alloc>
 800d4a4:	0003      	movs	r3, r0
 800d4a6:	617b      	str	r3, [r7, #20]
    if (npcb == NULL) {
 800d4a8:	697b      	ldr	r3, [r7, #20]
 800d4aa:	2b00      	cmp	r3, #0
 800d4ac:	d116      	bne.n	800d4dc <tcp_listen_input+0xc8>
      TCP_EVENT_ACCEPT(pcb, NULL, pcb->callback_arg, ERR_MEM, err);
 800d4ae:	687b      	ldr	r3, [r7, #4]
 800d4b0:	69db      	ldr	r3, [r3, #28]
 800d4b2:	2b00      	cmp	r3, #0
 800d4b4:	d00d      	beq.n	800d4d2 <tcp_listen_input+0xbe>
 800d4b6:	687b      	ldr	r3, [r7, #4]
 800d4b8:	69dd      	ldr	r5, [r3, #28]
 800d4ba:	687b      	ldr	r3, [r7, #4]
 800d4bc:	695b      	ldr	r3, [r3, #20]
 800d4be:	220e      	movs	r2, #14
 800d4c0:	18bc      	adds	r4, r7, r2
 800d4c2:	2201      	movs	r2, #1
 800d4c4:	4252      	negs	r2, r2
 800d4c6:	2100      	movs	r1, #0
 800d4c8:	0018      	movs	r0, r3
 800d4ca:	47a8      	blx	r5
 800d4cc:	0003      	movs	r3, r0
 800d4ce:	7023      	strb	r3, [r4, #0]
      return;
 800d4d0:	e09d      	b.n	800d60e <tcp_listen_input+0x1fa>
      TCP_EVENT_ACCEPT(pcb, NULL, pcb->callback_arg, ERR_MEM, err);
 800d4d2:	230e      	movs	r3, #14
 800d4d4:	18fb      	adds	r3, r7, r3
 800d4d6:	22f0      	movs	r2, #240	; 0xf0
 800d4d8:	701a      	strb	r2, [r3, #0]
      return;
 800d4da:	e098      	b.n	800d60e <tcp_listen_input+0x1fa>
    ip_addr_copy(npcb->local_ip, *ip_current_dest_addr());
 800d4dc:	4b58      	ldr	r3, [pc, #352]	; (800d640 <tcp_listen_input+0x22c>)
 800d4de:	695a      	ldr	r2, [r3, #20]
 800d4e0:	697b      	ldr	r3, [r7, #20]
 800d4e2:	601a      	str	r2, [r3, #0]
    ip_addr_copy(npcb->remote_ip, *ip_current_src_addr());
 800d4e4:	4b56      	ldr	r3, [pc, #344]	; (800d640 <tcp_listen_input+0x22c>)
 800d4e6:	691a      	ldr	r2, [r3, #16]
 800d4e8:	697b      	ldr	r3, [r7, #20]
 800d4ea:	605a      	str	r2, [r3, #4]
    npcb->local_port = pcb->local_port;
 800d4ec:	687b      	ldr	r3, [r7, #4]
 800d4ee:	8b5a      	ldrh	r2, [r3, #26]
 800d4f0:	697b      	ldr	r3, [r7, #20]
 800d4f2:	835a      	strh	r2, [r3, #26]
    npcb->remote_port = tcphdr->src;
 800d4f4:	4b4f      	ldr	r3, [pc, #316]	; (800d634 <tcp_listen_input+0x220>)
 800d4f6:	681b      	ldr	r3, [r3, #0]
 800d4f8:	781a      	ldrb	r2, [r3, #0]
 800d4fa:	785b      	ldrb	r3, [r3, #1]
 800d4fc:	021b      	lsls	r3, r3, #8
 800d4fe:	4313      	orrs	r3, r2
 800d500:	b29a      	uxth	r2, r3
 800d502:	697b      	ldr	r3, [r7, #20]
 800d504:	839a      	strh	r2, [r3, #28]
    npcb->state = SYN_RCVD;
 800d506:	697b      	ldr	r3, [r7, #20]
 800d508:	2203      	movs	r2, #3
 800d50a:	761a      	strb	r2, [r3, #24]
    npcb->rcv_nxt = seqno + 1;
 800d50c:	4b48      	ldr	r3, [pc, #288]	; (800d630 <tcp_listen_input+0x21c>)
 800d50e:	681b      	ldr	r3, [r3, #0]
 800d510:	1c5a      	adds	r2, r3, #1
 800d512:	697b      	ldr	r3, [r7, #20]
 800d514:	629a      	str	r2, [r3, #40]	; 0x28
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
 800d516:	697b      	ldr	r3, [r7, #20]
 800d518:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800d51a:	697b      	ldr	r3, [r7, #20]
 800d51c:	631a      	str	r2, [r3, #48]	; 0x30
    iss = tcp_next_iss(npcb);
 800d51e:	697b      	ldr	r3, [r7, #20]
 800d520:	0018      	movs	r0, r3
 800d522:	f7ff f8e3 	bl	800c6ec <tcp_next_iss>
 800d526:	0003      	movs	r3, r0
 800d528:	613b      	str	r3, [r7, #16]
    npcb->snd_wl2 = iss;
 800d52a:	697b      	ldr	r3, [r7, #20]
 800d52c:	693a      	ldr	r2, [r7, #16]
 800d52e:	65da      	str	r2, [r3, #92]	; 0x5c
    npcb->snd_nxt = iss;
 800d530:	697b      	ldr	r3, [r7, #20]
 800d532:	693a      	ldr	r2, [r7, #16]
 800d534:	655a      	str	r2, [r3, #84]	; 0x54
    npcb->lastack = iss;
 800d536:	697b      	ldr	r3, [r7, #20]
 800d538:	693a      	ldr	r2, [r7, #16]
 800d53a:	649a      	str	r2, [r3, #72]	; 0x48
    npcb->snd_lbb = iss;
 800d53c:	697b      	ldr	r3, [r7, #20]
 800d53e:	693a      	ldr	r2, [r7, #16]
 800d540:	661a      	str	r2, [r3, #96]	; 0x60
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
 800d542:	4b3b      	ldr	r3, [pc, #236]	; (800d630 <tcp_listen_input+0x21c>)
 800d544:	681b      	ldr	r3, [r3, #0]
 800d546:	1e5a      	subs	r2, r3, #1
 800d548:	697b      	ldr	r3, [r7, #20]
 800d54a:	659a      	str	r2, [r3, #88]	; 0x58
    npcb->callback_arg = pcb->callback_arg;
 800d54c:	687b      	ldr	r3, [r7, #4]
 800d54e:	695a      	ldr	r2, [r3, #20]
 800d550:	697b      	ldr	r3, [r7, #20]
 800d552:	615a      	str	r2, [r3, #20]
    npcb->listener = pcb;
 800d554:	697b      	ldr	r3, [r7, #20]
 800d556:	2180      	movs	r1, #128	; 0x80
 800d558:	687a      	ldr	r2, [r7, #4]
 800d55a:	505a      	str	r2, [r3, r1]
    npcb->so_options = pcb->so_options & SOF_INHERITED;
 800d55c:	687b      	ldr	r3, [r7, #4]
 800d55e:	7a5b      	ldrb	r3, [r3, #9]
 800d560:	220c      	movs	r2, #12
 800d562:	4013      	ands	r3, r2
 800d564:	b2da      	uxtb	r2, r3
 800d566:	697b      	ldr	r3, [r7, #20]
 800d568:	725a      	strb	r2, [r3, #9]
    npcb->netif_idx = pcb->netif_idx;
 800d56a:	687b      	ldr	r3, [r7, #4]
 800d56c:	7a1a      	ldrb	r2, [r3, #8]
 800d56e:	697b      	ldr	r3, [r7, #20]
 800d570:	721a      	strb	r2, [r3, #8]
    TCP_REG_ACTIVE(npcb);
 800d572:	4b34      	ldr	r3, [pc, #208]	; (800d644 <tcp_listen_input+0x230>)
 800d574:	681a      	ldr	r2, [r3, #0]
 800d576:	697b      	ldr	r3, [r7, #20]
 800d578:	611a      	str	r2, [r3, #16]
 800d57a:	4b32      	ldr	r3, [pc, #200]	; (800d644 <tcp_listen_input+0x230>)
 800d57c:	697a      	ldr	r2, [r7, #20]
 800d57e:	601a      	str	r2, [r3, #0]
 800d580:	f004 fe7a 	bl	8012278 <tcp_timer_needed>
 800d584:	4b30      	ldr	r3, [pc, #192]	; (800d648 <tcp_listen_input+0x234>)
 800d586:	2201      	movs	r2, #1
 800d588:	701a      	strb	r2, [r3, #0]
    tcp_parseopt(npcb);
 800d58a:	697b      	ldr	r3, [r7, #20]
 800d58c:	0018      	movs	r0, r3
 800d58e:	f001 ffbf 	bl	800f510 <tcp_parseopt>
    npcb->snd_wnd = tcphdr->wnd;
 800d592:	4b28      	ldr	r3, [pc, #160]	; (800d634 <tcp_listen_input+0x220>)
 800d594:	681b      	ldr	r3, [r3, #0]
 800d596:	7b9a      	ldrb	r2, [r3, #14]
 800d598:	7bdb      	ldrb	r3, [r3, #15]
 800d59a:	021b      	lsls	r3, r3, #8
 800d59c:	4313      	orrs	r3, r2
 800d59e:	b299      	uxth	r1, r3
 800d5a0:	697b      	ldr	r3, [r7, #20]
 800d5a2:	2264      	movs	r2, #100	; 0x64
 800d5a4:	5299      	strh	r1, [r3, r2]
    npcb->snd_wnd_max = npcb->snd_wnd;
 800d5a6:	697b      	ldr	r3, [r7, #20]
 800d5a8:	2264      	movs	r2, #100	; 0x64
 800d5aa:	5a99      	ldrh	r1, [r3, r2]
 800d5ac:	697b      	ldr	r3, [r7, #20]
 800d5ae:	2266      	movs	r2, #102	; 0x66
 800d5b0:	5299      	strh	r1, [r3, r2]
    npcb->mss = tcp_eff_send_mss(npcb->mss, &npcb->local_ip, &npcb->remote_ip);
 800d5b2:	697b      	ldr	r3, [r7, #20]
 800d5b4:	8edc      	ldrh	r4, [r3, #54]	; 0x36
 800d5b6:	697b      	ldr	r3, [r7, #20]
 800d5b8:	3304      	adds	r3, #4
 800d5ba:	0018      	movs	r0, r3
 800d5bc:	f006 f806 	bl	80135cc <ip4_route>
 800d5c0:	0001      	movs	r1, r0
 800d5c2:	697b      	ldr	r3, [r7, #20]
 800d5c4:	3304      	adds	r3, #4
 800d5c6:	001a      	movs	r2, r3
 800d5c8:	0020      	movs	r0, r4
 800d5ca:	f7ff f8b5 	bl	800c738 <tcp_eff_send_mss_netif>
 800d5ce:	0003      	movs	r3, r0
 800d5d0:	001a      	movs	r2, r3
 800d5d2:	697b      	ldr	r3, [r7, #20]
 800d5d4:	86da      	strh	r2, [r3, #54]	; 0x36
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
 800d5d6:	250f      	movs	r5, #15
 800d5d8:	197c      	adds	r4, r7, r5
 800d5da:	697b      	ldr	r3, [r7, #20]
 800d5dc:	2112      	movs	r1, #18
 800d5de:	0018      	movs	r0, r3
 800d5e0:	f003 fac6 	bl	8010b70 <tcp_enqueue_flags>
 800d5e4:	0003      	movs	r3, r0
 800d5e6:	7023      	strb	r3, [r4, #0]
    if (rc != ERR_OK) {
 800d5e8:	197b      	adds	r3, r7, r5
 800d5ea:	781b      	ldrb	r3, [r3, #0]
 800d5ec:	b25b      	sxtb	r3, r3
 800d5ee:	2b00      	cmp	r3, #0
 800d5f0:	d005      	beq.n	800d5fe <tcp_listen_input+0x1ea>
      tcp_abandon(npcb, 0);
 800d5f2:	697b      	ldr	r3, [r7, #20]
 800d5f4:	2100      	movs	r1, #0
 800d5f6:	0018      	movs	r0, r3
 800d5f8:	f7fd fd02 	bl	800b000 <tcp_abandon>
      return;
 800d5fc:	e007      	b.n	800d60e <tcp_listen_input+0x1fa>
    tcp_output(npcb);
 800d5fe:	697b      	ldr	r3, [r7, #20]
 800d600:	0018      	movs	r0, r3
 800d602:	f003 fbbb 	bl	8010d7c <tcp_output>
  return;
 800d606:	e001      	b.n	800d60c <tcp_listen_input+0x1f8>
    return;
 800d608:	46c0      	nop			; (mov r8, r8)
 800d60a:	e000      	b.n	800d60e <tcp_listen_input+0x1fa>
  return;
 800d60c:	46c0      	nop			; (mov r8, r8)
}
 800d60e:	46bd      	mov	sp, r7
 800d610:	b006      	add	sp, #24
 800d612:	bdb0      	pop	{r4, r5, r7, pc}
 800d614:	200017c4 	.word	0x200017c4
 800d618:	080205bc 	.word	0x080205bc
 800d61c:	00000281 	.word	0x00000281
 800d620:	080207ac 	.word	0x080207ac
 800d624:	080205fc 	.word	0x080205fc
 800d628:	200017bc 	.word	0x200017bc
 800d62c:	200017c2 	.word	0x200017c2
 800d630:	200017b8 	.word	0x200017b8
 800d634:	200017a8 	.word	0x200017a8
 800d638:	20001910 	.word	0x20001910
 800d63c:	2000190c 	.word	0x2000190c
 800d640:	200018fc 	.word	0x200018fc
 800d644:	20002b3c 	.word	0x20002b3c
 800d648:	20002b38 	.word	0x20002b38

0800d64c <tcp_timewait_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static void
tcp_timewait_input(struct tcp_pcb *pcb)
{
 800d64c:	b5b0      	push	{r4, r5, r7, lr}
 800d64e:	b086      	sub	sp, #24
 800d650:	af04      	add	r7, sp, #16
 800d652:	6078      	str	r0, [r7, #4]
  /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
  /* RFC 793 3.9 Event Processing - Segment Arrives:
   * - first check sequence number - we skip that one in TIME_WAIT (always
   *   acceptable since we only send ACKs)
   * - second check the RST bit (... return) */
  if (flags & TCP_RST) {
 800d654:	4b33      	ldr	r3, [pc, #204]	; (800d724 <tcp_timewait_input+0xd8>)
 800d656:	781b      	ldrb	r3, [r3, #0]
 800d658:	001a      	movs	r2, r3
 800d65a:	2304      	movs	r3, #4
 800d65c:	4013      	ands	r3, r2
 800d65e:	d15a      	bne.n	800d716 <tcp_timewait_input+0xca>
    return;
  }

  LWIP_ASSERT("tcp_timewait_input: invalid pcb", pcb != NULL);
 800d660:	687b      	ldr	r3, [r7, #4]
 800d662:	2b00      	cmp	r3, #0
 800d664:	d105      	bne.n	800d672 <tcp_timewait_input+0x26>
 800d666:	4b30      	ldr	r3, [pc, #192]	; (800d728 <tcp_timewait_input+0xdc>)
 800d668:	4a30      	ldr	r2, [pc, #192]	; (800d72c <tcp_timewait_input+0xe0>)
 800d66a:	4931      	ldr	r1, [pc, #196]	; (800d730 <tcp_timewait_input+0xe4>)
 800d66c:	4831      	ldr	r0, [pc, #196]	; (800d734 <tcp_timewait_input+0xe8>)
 800d66e:	f7f5 faab 	bl	8002bc8 <app_debug_rtt_raw>

  /* - fourth, check the SYN bit, */
  if (flags & TCP_SYN) {
 800d672:	4b2c      	ldr	r3, [pc, #176]	; (800d724 <tcp_timewait_input+0xd8>)
 800d674:	781b      	ldrb	r3, [r3, #0]
 800d676:	001a      	movs	r2, r3
 800d678:	2302      	movs	r3, #2
 800d67a:	4013      	ands	r3, r2
 800d67c:	d031      	beq.n	800d6e2 <tcp_timewait_input+0x96>
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd)) {
 800d67e:	4b2e      	ldr	r3, [pc, #184]	; (800d738 <tcp_timewait_input+0xec>)
 800d680:	681a      	ldr	r2, [r3, #0]
 800d682:	687b      	ldr	r3, [r7, #4]
 800d684:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800d686:	1ad3      	subs	r3, r2, r3
 800d688:	d435      	bmi.n	800d6f6 <tcp_timewait_input+0xaa>
 800d68a:	4b2b      	ldr	r3, [pc, #172]	; (800d738 <tcp_timewait_input+0xec>)
 800d68c:	681a      	ldr	r2, [r3, #0]
 800d68e:	687b      	ldr	r3, [r7, #4]
 800d690:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800d692:	6879      	ldr	r1, [r7, #4]
 800d694:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
 800d696:	185b      	adds	r3, r3, r1
 800d698:	1ad3      	subs	r3, r2, r3
 800d69a:	2b00      	cmp	r3, #0
 800d69c:	dc2b      	bgt.n	800d6f6 <tcp_timewait_input+0xaa>
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d69e:	4b27      	ldr	r3, [pc, #156]	; (800d73c <tcp_timewait_input+0xf0>)
 800d6a0:	681c      	ldr	r4, [r3, #0]
 800d6a2:	4b27      	ldr	r3, [pc, #156]	; (800d740 <tcp_timewait_input+0xf4>)
 800d6a4:	881b      	ldrh	r3, [r3, #0]
 800d6a6:	001a      	movs	r2, r3
 800d6a8:	4b23      	ldr	r3, [pc, #140]	; (800d738 <tcp_timewait_input+0xec>)
 800d6aa:	681b      	ldr	r3, [r3, #0]
 800d6ac:	18d5      	adds	r5, r2, r3
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800d6ae:	4b25      	ldr	r3, [pc, #148]	; (800d744 <tcp_timewait_input+0xf8>)
 800d6b0:	681b      	ldr	r3, [r3, #0]
      tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d6b2:	789a      	ldrb	r2, [r3, #2]
 800d6b4:	78db      	ldrb	r3, [r3, #3]
 800d6b6:	021b      	lsls	r3, r3, #8
 800d6b8:	4313      	orrs	r3, r2
 800d6ba:	b29a      	uxth	r2, r3
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800d6bc:	4b21      	ldr	r3, [pc, #132]	; (800d744 <tcp_timewait_input+0xf8>)
 800d6be:	681b      	ldr	r3, [r3, #0]
      tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d6c0:	7819      	ldrb	r1, [r3, #0]
 800d6c2:	785b      	ldrb	r3, [r3, #1]
 800d6c4:	021b      	lsls	r3, r3, #8
 800d6c6:	430b      	orrs	r3, r1
 800d6c8:	b29b      	uxth	r3, r3
 800d6ca:	491f      	ldr	r1, [pc, #124]	; (800d748 <tcp_timewait_input+0xfc>)
 800d6cc:	6878      	ldr	r0, [r7, #4]
 800d6ce:	9302      	str	r3, [sp, #8]
 800d6d0:	9201      	str	r2, [sp, #4]
 800d6d2:	4b1e      	ldr	r3, [pc, #120]	; (800d74c <tcp_timewait_input+0x100>)
 800d6d4:	9300      	str	r3, [sp, #0]
 800d6d6:	000b      	movs	r3, r1
 800d6d8:	002a      	movs	r2, r5
 800d6da:	0021      	movs	r1, r4
 800d6dc:	f004 fba2 	bl	8011e24 <tcp_rst>
      return;
 800d6e0:	e01c      	b.n	800d71c <tcp_timewait_input+0xd0>
    }
  } else if (flags & TCP_FIN) {
 800d6e2:	4b10      	ldr	r3, [pc, #64]	; (800d724 <tcp_timewait_input+0xd8>)
 800d6e4:	781b      	ldrb	r3, [r3, #0]
 800d6e6:	001a      	movs	r2, r3
 800d6e8:	2301      	movs	r3, #1
 800d6ea:	4013      	ands	r3, r2
 800d6ec:	d003      	beq.n	800d6f6 <tcp_timewait_input+0xaa>
    /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
         Restart the 2 MSL time-wait timeout.*/
    pcb->tmr = tcp_ticks;
 800d6ee:	4b18      	ldr	r3, [pc, #96]	; (800d750 <tcp_timewait_input+0x104>)
 800d6f0:	681a      	ldr	r2, [r3, #0]
 800d6f2:	687b      	ldr	r3, [r7, #4]
 800d6f4:	625a      	str	r2, [r3, #36]	; 0x24
  }

  if ((tcplen > 0)) {
 800d6f6:	4b12      	ldr	r3, [pc, #72]	; (800d740 <tcp_timewait_input+0xf4>)
 800d6f8:	881b      	ldrh	r3, [r3, #0]
 800d6fa:	2b00      	cmp	r3, #0
 800d6fc:	d00d      	beq.n	800d71a <tcp_timewait_input+0xce>
    /* Acknowledge data, FIN or out-of-window SYN */
    tcp_ack_now(pcb);
 800d6fe:	687b      	ldr	r3, [r7, #4]
 800d700:	8bdb      	ldrh	r3, [r3, #30]
 800d702:	2202      	movs	r2, #2
 800d704:	4313      	orrs	r3, r2
 800d706:	b29a      	uxth	r2, r3
 800d708:	687b      	ldr	r3, [r7, #4]
 800d70a:	83da      	strh	r2, [r3, #30]
    tcp_output(pcb);
 800d70c:	687b      	ldr	r3, [r7, #4]
 800d70e:	0018      	movs	r0, r3
 800d710:	f003 fb34 	bl	8010d7c <tcp_output>
  }
  return;
 800d714:	e001      	b.n	800d71a <tcp_timewait_input+0xce>
    return;
 800d716:	46c0      	nop			; (mov r8, r8)
 800d718:	e000      	b.n	800d71c <tcp_timewait_input+0xd0>
  return;
 800d71a:	46c0      	nop			; (mov r8, r8)
}
 800d71c:	46bd      	mov	sp, r7
 800d71e:	b002      	add	sp, #8
 800d720:	bdb0      	pop	{r4, r5, r7, pc}
 800d722:	46c0      	nop			; (mov r8, r8)
 800d724:	200017c4 	.word	0x200017c4
 800d728:	080205bc 	.word	0x080205bc
 800d72c:	000002ee 	.word	0x000002ee
 800d730:	080207cc 	.word	0x080207cc
 800d734:	080205fc 	.word	0x080205fc
 800d738:	200017b8 	.word	0x200017b8
 800d73c:	200017bc 	.word	0x200017bc
 800d740:	200017c2 	.word	0x200017c2
 800d744:	200017a8 	.word	0x200017a8
 800d748:	20001910 	.word	0x20001910
 800d74c:	2000190c 	.word	0x2000190c
 800d750:	20002b40 	.word	0x20002b40

0800d754 <tcp_process>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
 800d754:	b5b0      	push	{r4, r5, r7, lr}
 800d756:	b08c      	sub	sp, #48	; 0x30
 800d758:	af04      	add	r7, sp, #16
 800d75a:	6078      	str	r0, [r7, #4]
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
 800d75c:	231f      	movs	r3, #31
 800d75e:	18fb      	adds	r3, r7, r3
 800d760:	2200      	movs	r2, #0
 800d762:	701a      	strb	r2, [r3, #0]
  err_t err;

  err = ERR_OK;
 800d764:	231e      	movs	r3, #30
 800d766:	18fb      	adds	r3, r7, r3
 800d768:	2200      	movs	r2, #0
 800d76a:	701a      	strb	r2, [r3, #0]

  LWIP_ASSERT("tcp_process: invalid pcb", pcb != NULL);
 800d76c:	687b      	ldr	r3, [r7, #4]
 800d76e:	2b00      	cmp	r3, #0
 800d770:	d106      	bne.n	800d780 <tcp_process+0x2c>
 800d772:	4bd4      	ldr	r3, [pc, #848]	; (800dac4 <tcp_process+0x370>)
 800d774:	22c7      	movs	r2, #199	; 0xc7
 800d776:	0092      	lsls	r2, r2, #2
 800d778:	49d3      	ldr	r1, [pc, #844]	; (800dac8 <tcp_process+0x374>)
 800d77a:	48d4      	ldr	r0, [pc, #848]	; (800dacc <tcp_process+0x378>)
 800d77c:	f7f5 fa24 	bl	8002bc8 <app_debug_rtt_raw>

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
 800d780:	4bd3      	ldr	r3, [pc, #844]	; (800dad0 <tcp_process+0x37c>)
 800d782:	781b      	ldrb	r3, [r3, #0]
 800d784:	001a      	movs	r2, r3
 800d786:	2304      	movs	r3, #4
 800d788:	4013      	ands	r3, r2
 800d78a:	d055      	beq.n	800d838 <tcp_process+0xe4>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
 800d78c:	687b      	ldr	r3, [r7, #4]
 800d78e:	7e1b      	ldrb	r3, [r3, #24]
 800d790:	2b02      	cmp	r3, #2
 800d792:	d10a      	bne.n	800d7aa <tcp_process+0x56>
      /* "In the SYN-SENT state (a RST received in response to an initial SYN),
          the RST is acceptable if the ACK field acknowledges the SYN." */
      if (ackno == pcb->snd_nxt) {
 800d794:	687b      	ldr	r3, [r7, #4]
 800d796:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800d798:	4bce      	ldr	r3, [pc, #824]	; (800dad4 <tcp_process+0x380>)
 800d79a:	681b      	ldr	r3, [r3, #0]
 800d79c:	429a      	cmp	r2, r3
 800d79e:	d126      	bne.n	800d7ee <tcp_process+0x9a>
        acceptable = 1;
 800d7a0:	231f      	movs	r3, #31
 800d7a2:	18fb      	adds	r3, r7, r3
 800d7a4:	2201      	movs	r2, #1
 800d7a6:	701a      	strb	r2, [r3, #0]
 800d7a8:	e021      	b.n	800d7ee <tcp_process+0x9a>
      }
    } else {
      /* "In all states except SYN-SENT, all reset (RST) segments are validated
          by checking their SEQ-fields." */
      if (seqno == pcb->rcv_nxt) {
 800d7aa:	687b      	ldr	r3, [r7, #4]
 800d7ac:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800d7ae:	4bca      	ldr	r3, [pc, #808]	; (800dad8 <tcp_process+0x384>)
 800d7b0:	681b      	ldr	r3, [r3, #0]
 800d7b2:	429a      	cmp	r2, r3
 800d7b4:	d104      	bne.n	800d7c0 <tcp_process+0x6c>
        acceptable = 1;
 800d7b6:	231f      	movs	r3, #31
 800d7b8:	18fb      	adds	r3, r7, r3
 800d7ba:	2201      	movs	r2, #1
 800d7bc:	701a      	strb	r2, [r3, #0]
 800d7be:	e016      	b.n	800d7ee <tcp_process+0x9a>
      } else  if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
 800d7c0:	4bc5      	ldr	r3, [pc, #788]	; (800dad8 <tcp_process+0x384>)
 800d7c2:	681a      	ldr	r2, [r3, #0]
 800d7c4:	687b      	ldr	r3, [r7, #4]
 800d7c6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800d7c8:	1ad3      	subs	r3, r2, r3
 800d7ca:	d410      	bmi.n	800d7ee <tcp_process+0x9a>
 800d7cc:	4bc2      	ldr	r3, [pc, #776]	; (800dad8 <tcp_process+0x384>)
 800d7ce:	681a      	ldr	r2, [r3, #0]
 800d7d0:	687b      	ldr	r3, [r7, #4]
 800d7d2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800d7d4:	6879      	ldr	r1, [r7, #4]
 800d7d6:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
 800d7d8:	185b      	adds	r3, r3, r1
 800d7da:	1ad3      	subs	r3, r2, r3
 800d7dc:	2b00      	cmp	r3, #0
 800d7de:	dc06      	bgt.n	800d7ee <tcp_process+0x9a>
                                  pcb->rcv_nxt + pcb->rcv_wnd)) {
        /* If the sequence number is inside the window, we send a challenge ACK
           and wait for a re-send with matching sequence number.
           This follows RFC 5961 section 3.2 and addresses CVE-2004-0230
           (RST spoofing attack), which is present in RFC 793 RST handling. */
        tcp_ack_now(pcb);
 800d7e0:	687b      	ldr	r3, [r7, #4]
 800d7e2:	8bdb      	ldrh	r3, [r3, #30]
 800d7e4:	2202      	movs	r2, #2
 800d7e6:	4313      	orrs	r3, r2
 800d7e8:	b29a      	uxth	r2, r3
 800d7ea:	687b      	ldr	r3, [r7, #4]
 800d7ec:	83da      	strh	r2, [r3, #30]
      }
    }

    if (acceptable) {
 800d7ee:	231f      	movs	r3, #31
 800d7f0:	18fb      	adds	r3, r7, r3
 800d7f2:	781b      	ldrb	r3, [r3, #0]
 800d7f4:	2b00      	cmp	r3, #0
 800d7f6:	d01c      	beq.n	800d832 <tcp_process+0xde>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
 800d7f8:	687b      	ldr	r3, [r7, #4]
 800d7fa:	7e1b      	ldrb	r3, [r3, #24]
 800d7fc:	2b00      	cmp	r3, #0
 800d7fe:	d106      	bne.n	800d80e <tcp_process+0xba>
 800d800:	4bb0      	ldr	r3, [pc, #704]	; (800dac4 <tcp_process+0x370>)
 800d802:	22ce      	movs	r2, #206	; 0xce
 800d804:	0092      	lsls	r2, r2, #2
 800d806:	49b5      	ldr	r1, [pc, #724]	; (800dadc <tcp_process+0x388>)
 800d808:	48b0      	ldr	r0, [pc, #704]	; (800dacc <tcp_process+0x378>)
 800d80a:	f7f5 f9dd 	bl	8002bc8 <app_debug_rtt_raw>
      recv_flags |= TF_RESET;
 800d80e:	4bb4      	ldr	r3, [pc, #720]	; (800dae0 <tcp_process+0x38c>)
 800d810:	781b      	ldrb	r3, [r3, #0]
 800d812:	2208      	movs	r2, #8
 800d814:	4313      	orrs	r3, r2
 800d816:	b2da      	uxtb	r2, r3
 800d818:	4bb1      	ldr	r3, [pc, #708]	; (800dae0 <tcp_process+0x38c>)
 800d81a:	701a      	strb	r2, [r3, #0]
      tcp_clear_flags(pcb, TF_ACK_DELAY);
 800d81c:	687b      	ldr	r3, [r7, #4]
 800d81e:	8bdb      	ldrh	r3, [r3, #30]
 800d820:	2201      	movs	r2, #1
 800d822:	4393      	bics	r3, r2
 800d824:	b29a      	uxth	r2, r3
 800d826:	687b      	ldr	r3, [r7, #4]
 800d828:	83da      	strh	r2, [r3, #30]
      return ERR_RST;
 800d82a:	230e      	movs	r3, #14
 800d82c:	425b      	negs	r3, r3
 800d82e:	f000 fbb1 	bl	800df94 <tcp_process+0x840>
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
                                    seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
                              seqno, pcb->rcv_nxt));
      return ERR_OK;
 800d832:	2300      	movs	r3, #0
 800d834:	f000 fbae 	bl	800df94 <tcp_process+0x840>
    }
  }

  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) {
 800d838:	4ba5      	ldr	r3, [pc, #660]	; (800dad0 <tcp_process+0x37c>)
 800d83a:	781b      	ldrb	r3, [r3, #0]
 800d83c:	001a      	movs	r2, r3
 800d83e:	2302      	movs	r3, #2
 800d840:	4013      	ands	r3, r2
 800d842:	d011      	beq.n	800d868 <tcp_process+0x114>
 800d844:	687b      	ldr	r3, [r7, #4]
 800d846:	7e1b      	ldrb	r3, [r3, #24]
 800d848:	2b02      	cmp	r3, #2
 800d84a:	d00d      	beq.n	800d868 <tcp_process+0x114>
 800d84c:	687b      	ldr	r3, [r7, #4]
 800d84e:	7e1b      	ldrb	r3, [r3, #24]
 800d850:	2b03      	cmp	r3, #3
 800d852:	d009      	beq.n	800d868 <tcp_process+0x114>
    /* Cope with new connection attempt after remote end crashed */
    tcp_ack_now(pcb);
 800d854:	687b      	ldr	r3, [r7, #4]
 800d856:	8bdb      	ldrh	r3, [r3, #30]
 800d858:	2202      	movs	r2, #2
 800d85a:	4313      	orrs	r3, r2
 800d85c:	b29a      	uxth	r2, r3
 800d85e:	687b      	ldr	r3, [r7, #4]
 800d860:	83da      	strh	r2, [r3, #30]
    return ERR_OK;
 800d862:	2300      	movs	r3, #0
 800d864:	f000 fb96 	bl	800df94 <tcp_process+0x840>
  }

  if ((pcb->flags & TF_RXCLOSED) == 0) {
 800d868:	687b      	ldr	r3, [r7, #4]
 800d86a:	8bdb      	ldrh	r3, [r3, #30]
 800d86c:	001a      	movs	r2, r3
 800d86e:	2310      	movs	r3, #16
 800d870:	4013      	ands	r3, r2
 800d872:	d103      	bne.n	800d87c <tcp_process+0x128>
    /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
    pcb->tmr = tcp_ticks;
 800d874:	4b9b      	ldr	r3, [pc, #620]	; (800dae4 <tcp_process+0x390>)
 800d876:	681a      	ldr	r2, [r3, #0]
 800d878:	687b      	ldr	r3, [r7, #4]
 800d87a:	625a      	str	r2, [r3, #36]	; 0x24
  }
  pcb->keep_cnt_sent = 0;
 800d87c:	687b      	ldr	r3, [r7, #4]
 800d87e:	22a7      	movs	r2, #167	; 0xa7
 800d880:	2100      	movs	r1, #0
 800d882:	5499      	strb	r1, [r3, r2]
  pcb->persist_probe = 0;
 800d884:	687b      	ldr	r3, [r7, #4]
 800d886:	22a6      	movs	r2, #166	; 0xa6
 800d888:	2100      	movs	r1, #0
 800d88a:	5499      	strb	r1, [r3, r2]

  tcp_parseopt(pcb);
 800d88c:	687b      	ldr	r3, [r7, #4]
 800d88e:	0018      	movs	r0, r3
 800d890:	f001 fe3e 	bl	800f510 <tcp_parseopt>

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
 800d894:	687b      	ldr	r3, [r7, #4]
 800d896:	7e1b      	ldrb	r3, [r3, #24]
 800d898:	2b09      	cmp	r3, #9
 800d89a:	d901      	bls.n	800d8a0 <tcp_process+0x14c>
 800d89c:	f000 fb6a 	bl	800df74 <tcp_process+0x820>
 800d8a0:	009a      	lsls	r2, r3, #2
 800d8a2:	4b91      	ldr	r3, [pc, #580]	; (800dae8 <tcp_process+0x394>)
 800d8a4:	18d3      	adds	r3, r2, r3
 800d8a6:	681b      	ldr	r3, [r3, #0]
 800d8a8:	469f      	mov	pc, r3
    case SYN_SENT:
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %s %"U32_F"\n",
                                    ackno, pcb->snd_nxt, pcb->unacked ? "" : " empty:",
                                    pcb->unacked ? lwip_ntohl(pcb->unacked->tcphdr->seqno) : 0));
      /* received SYN ACK with expected sequence number? */
      if ((flags & TCP_ACK) && (flags & TCP_SYN)
 800d8aa:	4b89      	ldr	r3, [pc, #548]	; (800dad0 <tcp_process+0x37c>)
 800d8ac:	781b      	ldrb	r3, [r3, #0]
 800d8ae:	001a      	movs	r2, r3
 800d8b0:	2310      	movs	r3, #16
 800d8b2:	4013      	ands	r3, r2
 800d8b4:	d100      	bne.n	800d8b8 <tcp_process+0x164>
 800d8b6:	e0cf      	b.n	800da58 <tcp_process+0x304>
 800d8b8:	4b85      	ldr	r3, [pc, #532]	; (800dad0 <tcp_process+0x37c>)
 800d8ba:	781b      	ldrb	r3, [r3, #0]
 800d8bc:	001a      	movs	r2, r3
 800d8be:	2302      	movs	r3, #2
 800d8c0:	4013      	ands	r3, r2
 800d8c2:	d100      	bne.n	800d8c6 <tcp_process+0x172>
 800d8c4:	e0c8      	b.n	800da58 <tcp_process+0x304>
          && (ackno == pcb->lastack + 1)) {
 800d8c6:	687b      	ldr	r3, [r7, #4]
 800d8c8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800d8ca:	1c5a      	adds	r2, r3, #1
 800d8cc:	4b81      	ldr	r3, [pc, #516]	; (800dad4 <tcp_process+0x380>)
 800d8ce:	681b      	ldr	r3, [r3, #0]
 800d8d0:	429a      	cmp	r2, r3
 800d8d2:	d000      	beq.n	800d8d6 <tcp_process+0x182>
 800d8d4:	e0c0      	b.n	800da58 <tcp_process+0x304>
        pcb->rcv_nxt = seqno + 1;
 800d8d6:	4b80      	ldr	r3, [pc, #512]	; (800dad8 <tcp_process+0x384>)
 800d8d8:	681b      	ldr	r3, [r3, #0]
 800d8da:	1c5a      	adds	r2, r3, #1
 800d8dc:	687b      	ldr	r3, [r7, #4]
 800d8de:	629a      	str	r2, [r3, #40]	; 0x28
        pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 800d8e0:	687b      	ldr	r3, [r7, #4]
 800d8e2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800d8e4:	687b      	ldr	r3, [r7, #4]
 800d8e6:	631a      	str	r2, [r3, #48]	; 0x30
        pcb->lastack = ackno;
 800d8e8:	4b7a      	ldr	r3, [pc, #488]	; (800dad4 <tcp_process+0x380>)
 800d8ea:	681a      	ldr	r2, [r3, #0]
 800d8ec:	687b      	ldr	r3, [r7, #4]
 800d8ee:	649a      	str	r2, [r3, #72]	; 0x48
        pcb->snd_wnd = tcphdr->wnd;
 800d8f0:	4b7e      	ldr	r3, [pc, #504]	; (800daec <tcp_process+0x398>)
 800d8f2:	681b      	ldr	r3, [r3, #0]
 800d8f4:	7b9a      	ldrb	r2, [r3, #14]
 800d8f6:	7bdb      	ldrb	r3, [r3, #15]
 800d8f8:	021b      	lsls	r3, r3, #8
 800d8fa:	4313      	orrs	r3, r2
 800d8fc:	b299      	uxth	r1, r3
 800d8fe:	687b      	ldr	r3, [r7, #4]
 800d900:	2264      	movs	r2, #100	; 0x64
 800d902:	5299      	strh	r1, [r3, r2]
        pcb->snd_wnd_max = pcb->snd_wnd;
 800d904:	687b      	ldr	r3, [r7, #4]
 800d906:	2264      	movs	r2, #100	; 0x64
 800d908:	5a99      	ldrh	r1, [r3, r2]
 800d90a:	687b      	ldr	r3, [r7, #4]
 800d90c:	2266      	movs	r2, #102	; 0x66
 800d90e:	5299      	strh	r1, [r3, r2]
        pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
 800d910:	4b71      	ldr	r3, [pc, #452]	; (800dad8 <tcp_process+0x384>)
 800d912:	681b      	ldr	r3, [r3, #0]
 800d914:	1e5a      	subs	r2, r3, #1
 800d916:	687b      	ldr	r3, [r7, #4]
 800d918:	659a      	str	r2, [r3, #88]	; 0x58
        pcb->state = ESTABLISHED;
 800d91a:	687b      	ldr	r3, [r7, #4]
 800d91c:	2204      	movs	r2, #4
 800d91e:	761a      	strb	r2, [r3, #24]

#if TCP_CALCULATE_EFF_SEND_MSS
        pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip);
 800d920:	687b      	ldr	r3, [r7, #4]
 800d922:	8edc      	ldrh	r4, [r3, #54]	; 0x36
 800d924:	687b      	ldr	r3, [r7, #4]
 800d926:	3304      	adds	r3, #4
 800d928:	0018      	movs	r0, r3
 800d92a:	f005 fe4f 	bl	80135cc <ip4_route>
 800d92e:	0001      	movs	r1, r0
 800d930:	687b      	ldr	r3, [r7, #4]
 800d932:	3304      	adds	r3, #4
 800d934:	001a      	movs	r2, r3
 800d936:	0020      	movs	r0, r4
 800d938:	f7fe fefe 	bl	800c738 <tcp_eff_send_mss_netif>
 800d93c:	0003      	movs	r3, r0
 800d93e:	001a      	movs	r2, r3
 800d940:	687b      	ldr	r3, [r7, #4]
 800d942:	86da      	strh	r2, [r3, #54]	; 0x36
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

        pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
 800d944:	687b      	ldr	r3, [r7, #4]
 800d946:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800d948:	009a      	lsls	r2, r3, #2
 800d94a:	687b      	ldr	r3, [r7, #4]
 800d94c:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800d94e:	005b      	lsls	r3, r3, #1
 800d950:	4967      	ldr	r1, [pc, #412]	; (800daf0 <tcp_process+0x39c>)
 800d952:	428b      	cmp	r3, r1
 800d954:	d200      	bcs.n	800d958 <tcp_process+0x204>
 800d956:	4b66      	ldr	r3, [pc, #408]	; (800daf0 <tcp_process+0x39c>)
 800d958:	429a      	cmp	r2, r3
 800d95a:	d204      	bcs.n	800d966 <tcp_process+0x212>
 800d95c:	687b      	ldr	r3, [r7, #4]
 800d95e:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800d960:	009b      	lsls	r3, r3, #2
 800d962:	b29b      	uxth	r3, r3
 800d964:	e00b      	b.n	800d97e <tcp_process+0x22a>
 800d966:	687b      	ldr	r3, [r7, #4]
 800d968:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800d96a:	005b      	lsls	r3, r3, #1
 800d96c:	4a60      	ldr	r2, [pc, #384]	; (800daf0 <tcp_process+0x39c>)
 800d96e:	4293      	cmp	r3, r2
 800d970:	d904      	bls.n	800d97c <tcp_process+0x228>
 800d972:	687b      	ldr	r3, [r7, #4]
 800d974:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800d976:	18db      	adds	r3, r3, r3
 800d978:	b29b      	uxth	r3, r3
 800d97a:	e000      	b.n	800d97e <tcp_process+0x22a>
 800d97c:	4b5c      	ldr	r3, [pc, #368]	; (800daf0 <tcp_process+0x39c>)
 800d97e:	687a      	ldr	r2, [r7, #4]
 800d980:	214c      	movs	r1, #76	; 0x4c
 800d982:	5253      	strh	r3, [r2, r1]
        LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SENT): cwnd %"TCPWNDSIZE_F
                                     " ssthresh %"TCPWNDSIZE_F"\n",
                                     pcb->cwnd, pcb->ssthresh));
        LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
 800d984:	687b      	ldr	r3, [r7, #4]
 800d986:	226a      	movs	r2, #106	; 0x6a
 800d988:	5a9b      	ldrh	r3, [r3, r2]
 800d98a:	2b00      	cmp	r3, #0
 800d98c:	d105      	bne.n	800d99a <tcp_process+0x246>
 800d98e:	4b4d      	ldr	r3, [pc, #308]	; (800dac4 <tcp_process+0x370>)
 800d990:	4a58      	ldr	r2, [pc, #352]	; (800daf4 <tcp_process+0x3a0>)
 800d992:	4959      	ldr	r1, [pc, #356]	; (800daf8 <tcp_process+0x3a4>)
 800d994:	484d      	ldr	r0, [pc, #308]	; (800dacc <tcp_process+0x378>)
 800d996:	f7f5 f917 	bl	8002bc8 <app_debug_rtt_raw>
        --pcb->snd_queuelen;
 800d99a:	687b      	ldr	r3, [r7, #4]
 800d99c:	226a      	movs	r2, #106	; 0x6a
 800d99e:	5a9b      	ldrh	r3, [r3, r2]
 800d9a0:	3b01      	subs	r3, #1
 800d9a2:	b299      	uxth	r1, r3
 800d9a4:	687b      	ldr	r3, [r7, #4]
 800d9a6:	226a      	movs	r2, #106	; 0x6a
 800d9a8:	5299      	strh	r1, [r3, r2]
        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"TCPWNDSIZE_F"\n", (tcpwnd_size_t)pcb->snd_queuelen));
        rseg = pcb->unacked;
 800d9aa:	687b      	ldr	r3, [r7, #4]
 800d9ac:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800d9ae:	617b      	str	r3, [r7, #20]
        if (rseg == NULL) {
 800d9b0:	697b      	ldr	r3, [r7, #20]
 800d9b2:	2b00      	cmp	r3, #0
 800d9b4:	d110      	bne.n	800d9d8 <tcp_process+0x284>
          /* might happen if tcp_output fails in tcp_rexmit_rto()
             in which case the segment is on the unsent list */
          rseg = pcb->unsent;
 800d9b6:	687b      	ldr	r3, [r7, #4]
 800d9b8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d9ba:	617b      	str	r3, [r7, #20]
          LWIP_ASSERT("no segment to free", rseg != NULL);
 800d9bc:	697b      	ldr	r3, [r7, #20]
 800d9be:	2b00      	cmp	r3, #0
 800d9c0:	d105      	bne.n	800d9ce <tcp_process+0x27a>
 800d9c2:	4b40      	ldr	r3, [pc, #256]	; (800dac4 <tcp_process+0x370>)
 800d9c4:	4a4d      	ldr	r2, [pc, #308]	; (800dafc <tcp_process+0x3a8>)
 800d9c6:	494e      	ldr	r1, [pc, #312]	; (800db00 <tcp_process+0x3ac>)
 800d9c8:	4840      	ldr	r0, [pc, #256]	; (800dacc <tcp_process+0x378>)
 800d9ca:	f7f5 f8fd 	bl	8002bc8 <app_debug_rtt_raw>
          pcb->unsent = rseg->next;
 800d9ce:	697b      	ldr	r3, [r7, #20]
 800d9d0:	681a      	ldr	r2, [r3, #0]
 800d9d2:	687b      	ldr	r3, [r7, #4]
 800d9d4:	671a      	str	r2, [r3, #112]	; 0x70
 800d9d6:	e003      	b.n	800d9e0 <tcp_process+0x28c>
        } else {
          pcb->unacked = rseg->next;
 800d9d8:	697b      	ldr	r3, [r7, #20]
 800d9da:	681a      	ldr	r2, [r3, #0]
 800d9dc:	687b      	ldr	r3, [r7, #4]
 800d9de:	675a      	str	r2, [r3, #116]	; 0x74
        }
        tcp_seg_free(rseg);
 800d9e0:	697b      	ldr	r3, [r7, #20]
 800d9e2:	0018      	movs	r0, r3
 800d9e4:	f7fe fad6 	bl	800bf94 <tcp_seg_free>

        /* If there's nothing left to acknowledge, stop the retransmit
           timer, otherwise reset it to start again */
        if (pcb->unacked == NULL) {
 800d9e8:	687b      	ldr	r3, [r7, #4]
 800d9ea:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800d9ec:	2b00      	cmp	r3, #0
 800d9ee:	d104      	bne.n	800d9fa <tcp_process+0x2a6>
          pcb->rtime = -1;
 800d9f0:	687b      	ldr	r3, [r7, #4]
 800d9f2:	2201      	movs	r2, #1
 800d9f4:	4252      	negs	r2, r2
 800d9f6:	869a      	strh	r2, [r3, #52]	; 0x34
 800d9f8:	e006      	b.n	800da08 <tcp_process+0x2b4>
        } else {
          pcb->rtime = 0;
 800d9fa:	687b      	ldr	r3, [r7, #4]
 800d9fc:	2200      	movs	r2, #0
 800d9fe:	869a      	strh	r2, [r3, #52]	; 0x34
          pcb->nrtx = 0;
 800da00:	687b      	ldr	r3, [r7, #4]
 800da02:	2246      	movs	r2, #70	; 0x46
 800da04:	2100      	movs	r1, #0
 800da06:	5499      	strb	r1, [r3, r2]
        }

        /* Call the user specified function to call when successfully
         * connected. */
        TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
 800da08:	687b      	ldr	r3, [r7, #4]
 800da0a:	228c      	movs	r2, #140	; 0x8c
 800da0c:	589b      	ldr	r3, [r3, r2]
 800da0e:	2b00      	cmp	r3, #0
 800da10:	d00d      	beq.n	800da2e <tcp_process+0x2da>
 800da12:	687b      	ldr	r3, [r7, #4]
 800da14:	228c      	movs	r2, #140	; 0x8c
 800da16:	589d      	ldr	r5, [r3, r2]
 800da18:	687b      	ldr	r3, [r7, #4]
 800da1a:	695b      	ldr	r3, [r3, #20]
 800da1c:	221e      	movs	r2, #30
 800da1e:	18bc      	adds	r4, r7, r2
 800da20:	6879      	ldr	r1, [r7, #4]
 800da22:	2200      	movs	r2, #0
 800da24:	0018      	movs	r0, r3
 800da26:	47a8      	blx	r5
 800da28:	0003      	movs	r3, r0
 800da2a:	7023      	strb	r3, [r4, #0]
 800da2c:	e003      	b.n	800da36 <tcp_process+0x2e2>
 800da2e:	231e      	movs	r3, #30
 800da30:	18fb      	adds	r3, r7, r3
 800da32:	2200      	movs	r2, #0
 800da34:	701a      	strb	r2, [r3, #0]
        if (err == ERR_ABRT) {
 800da36:	231e      	movs	r3, #30
 800da38:	18fb      	adds	r3, r7, r3
 800da3a:	781b      	ldrb	r3, [r3, #0]
 800da3c:	b25b      	sxtb	r3, r3
 800da3e:	330d      	adds	r3, #13
 800da40:	d102      	bne.n	800da48 <tcp_process+0x2f4>
          return ERR_ABRT;
 800da42:	230d      	movs	r3, #13
 800da44:	425b      	negs	r3, r3
 800da46:	e2a5      	b.n	800df94 <tcp_process+0x840>
        }
        tcp_ack_now(pcb);
 800da48:	687b      	ldr	r3, [r7, #4]
 800da4a:	8bdb      	ldrh	r3, [r3, #30]
 800da4c:	2202      	movs	r2, #2
 800da4e:	4313      	orrs	r3, r2
 800da50:	b29a      	uxth	r2, r3
 800da52:	687b      	ldr	r3, [r7, #4]
 800da54:	83da      	strh	r2, [r3, #30]
        if (pcb->nrtx < TCP_SYNMAXRTX) {
          pcb->rtime = 0;
          tcp_rexmit_rto(pcb);
        }
      }
      break;
 800da56:	e28f      	b.n	800df78 <tcp_process+0x824>
      else if (flags & TCP_ACK) {
 800da58:	4b1d      	ldr	r3, [pc, #116]	; (800dad0 <tcp_process+0x37c>)
 800da5a:	781b      	ldrb	r3, [r3, #0]
 800da5c:	001a      	movs	r2, r3
 800da5e:	2310      	movs	r3, #16
 800da60:	4013      	ands	r3, r2
 800da62:	d100      	bne.n	800da66 <tcp_process+0x312>
 800da64:	e288      	b.n	800df78 <tcp_process+0x824>
        tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800da66:	4b1b      	ldr	r3, [pc, #108]	; (800dad4 <tcp_process+0x380>)
 800da68:	681c      	ldr	r4, [r3, #0]
 800da6a:	4b26      	ldr	r3, [pc, #152]	; (800db04 <tcp_process+0x3b0>)
 800da6c:	881b      	ldrh	r3, [r3, #0]
 800da6e:	001a      	movs	r2, r3
 800da70:	4b19      	ldr	r3, [pc, #100]	; (800dad8 <tcp_process+0x384>)
 800da72:	681b      	ldr	r3, [r3, #0]
 800da74:	18d5      	adds	r5, r2, r3
                ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800da76:	4b1d      	ldr	r3, [pc, #116]	; (800daec <tcp_process+0x398>)
 800da78:	681b      	ldr	r3, [r3, #0]
        tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800da7a:	789a      	ldrb	r2, [r3, #2]
 800da7c:	78db      	ldrb	r3, [r3, #3]
 800da7e:	021b      	lsls	r3, r3, #8
 800da80:	4313      	orrs	r3, r2
 800da82:	b29a      	uxth	r2, r3
                ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800da84:	4b19      	ldr	r3, [pc, #100]	; (800daec <tcp_process+0x398>)
 800da86:	681b      	ldr	r3, [r3, #0]
        tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800da88:	7819      	ldrb	r1, [r3, #0]
 800da8a:	785b      	ldrb	r3, [r3, #1]
 800da8c:	021b      	lsls	r3, r3, #8
 800da8e:	430b      	orrs	r3, r1
 800da90:	b29b      	uxth	r3, r3
 800da92:	491d      	ldr	r1, [pc, #116]	; (800db08 <tcp_process+0x3b4>)
 800da94:	6878      	ldr	r0, [r7, #4]
 800da96:	9302      	str	r3, [sp, #8]
 800da98:	9201      	str	r2, [sp, #4]
 800da9a:	4b1c      	ldr	r3, [pc, #112]	; (800db0c <tcp_process+0x3b8>)
 800da9c:	9300      	str	r3, [sp, #0]
 800da9e:	000b      	movs	r3, r1
 800daa0:	002a      	movs	r2, r5
 800daa2:	0021      	movs	r1, r4
 800daa4:	f004 f9be 	bl	8011e24 <tcp_rst>
        if (pcb->nrtx < TCP_SYNMAXRTX) {
 800daa8:	687b      	ldr	r3, [r7, #4]
 800daaa:	2246      	movs	r2, #70	; 0x46
 800daac:	5c9b      	ldrb	r3, [r3, r2]
 800daae:	2b05      	cmp	r3, #5
 800dab0:	d900      	bls.n	800dab4 <tcp_process+0x360>
 800dab2:	e261      	b.n	800df78 <tcp_process+0x824>
          pcb->rtime = 0;
 800dab4:	687b      	ldr	r3, [r7, #4]
 800dab6:	2200      	movs	r2, #0
 800dab8:	869a      	strh	r2, [r3, #52]	; 0x34
          tcp_rexmit_rto(pcb);
 800daba:	687b      	ldr	r3, [r7, #4]
 800dabc:	0018      	movs	r0, r3
 800dabe:	f003 fe69 	bl	8011794 <tcp_rexmit_rto>
      break;
 800dac2:	e259      	b.n	800df78 <tcp_process+0x824>
 800dac4:	080205bc 	.word	0x080205bc
 800dac8:	080207ec 	.word	0x080207ec
 800dacc:	080205fc 	.word	0x080205fc
 800dad0:	200017c4 	.word	0x200017c4
 800dad4:	200017bc 	.word	0x200017bc
 800dad8:	200017b8 	.word	0x200017b8
 800dadc:	08020808 	.word	0x08020808
 800dae0:	200017c5 	.word	0x200017c5
 800dae4:	20002b40 	.word	0x20002b40
 800dae8:	08022860 	.word	0x08022860
 800daec:	200017a8 	.word	0x200017a8
 800daf0:	0000111c 	.word	0x0000111c
 800daf4:	0000036d 	.word	0x0000036d
 800daf8:	08020828 	.word	0x08020828
 800dafc:	00000375 	.word	0x00000375
 800db00:	08020840 	.word	0x08020840
 800db04:	200017c2 	.word	0x200017c2
 800db08:	20001910 	.word	0x20001910
 800db0c:	2000190c 	.word	0x2000190c
    case SYN_RCVD:
      if (flags & TCP_ACK) {
 800db10:	4bc7      	ldr	r3, [pc, #796]	; (800de30 <tcp_process+0x6dc>)
 800db12:	781b      	ldrb	r3, [r3, #0]
 800db14:	001a      	movs	r2, r3
 800db16:	2310      	movs	r3, #16
 800db18:	4013      	ands	r3, r2
 800db1a:	d100      	bne.n	800db1e <tcp_process+0x3ca>
 800db1c:	e0b5      	b.n	800dc8a <tcp_process+0x536>
        /* expected ACK number? */
        if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 800db1e:	4bc5      	ldr	r3, [pc, #788]	; (800de34 <tcp_process+0x6e0>)
 800db20:	681a      	ldr	r2, [r3, #0]
 800db22:	687b      	ldr	r3, [r7, #4]
 800db24:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800db26:	1ad3      	subs	r3, r2, r3
 800db28:	3b01      	subs	r3, #1
 800db2a:	2b00      	cmp	r3, #0
 800db2c:	da00      	bge.n	800db30 <tcp_process+0x3dc>
 800db2e:	e08a      	b.n	800dc46 <tcp_process+0x4f2>
 800db30:	4bc0      	ldr	r3, [pc, #768]	; (800de34 <tcp_process+0x6e0>)
 800db32:	681a      	ldr	r2, [r3, #0]
 800db34:	687b      	ldr	r3, [r7, #4]
 800db36:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800db38:	1ad3      	subs	r3, r2, r3
 800db3a:	2b00      	cmp	r3, #0
 800db3c:	dd00      	ble.n	800db40 <tcp_process+0x3ec>
 800db3e:	e082      	b.n	800dc46 <tcp_process+0x4f2>
          pcb->state = ESTABLISHED;
 800db40:	687b      	ldr	r3, [r7, #4]
 800db42:	2204      	movs	r2, #4
 800db44:	761a      	strb	r2, [r3, #24]
          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
          if (pcb->listener == NULL) {
 800db46:	687b      	ldr	r3, [r7, #4]
 800db48:	2280      	movs	r2, #128	; 0x80
 800db4a:	589b      	ldr	r3, [r3, r2]
 800db4c:	2b00      	cmp	r3, #0
 800db4e:	d104      	bne.n	800db5a <tcp_process+0x406>
            /* listen pcb might be closed by now */
            err = ERR_VAL;
 800db50:	231e      	movs	r3, #30
 800db52:	18fb      	adds	r3, r7, r3
 800db54:	22fa      	movs	r2, #250	; 0xfa
 800db56:	701a      	strb	r2, [r3, #0]
 800db58:	e024      	b.n	800dba4 <tcp_process+0x450>
          } else
#endif /* LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG */
          {
#if LWIP_CALLBACK_API
            LWIP_ASSERT("pcb->listener->accept != NULL", pcb->listener->accept != NULL);
 800db5a:	687b      	ldr	r3, [r7, #4]
 800db5c:	2280      	movs	r2, #128	; 0x80
 800db5e:	589b      	ldr	r3, [r3, r2]
 800db60:	69db      	ldr	r3, [r3, #28]
 800db62:	2b00      	cmp	r3, #0
 800db64:	d105      	bne.n	800db72 <tcp_process+0x41e>
 800db66:	4bb4      	ldr	r3, [pc, #720]	; (800de38 <tcp_process+0x6e4>)
 800db68:	4ab4      	ldr	r2, [pc, #720]	; (800de3c <tcp_process+0x6e8>)
 800db6a:	49b5      	ldr	r1, [pc, #724]	; (800de40 <tcp_process+0x6ec>)
 800db6c:	48b5      	ldr	r0, [pc, #724]	; (800de44 <tcp_process+0x6f0>)
 800db6e:	f7f5 f82b 	bl	8002bc8 <app_debug_rtt_raw>
#endif
            tcp_backlog_accepted(pcb);
            /* Call the accept function. */
            TCP_EVENT_ACCEPT(pcb->listener, pcb, pcb->callback_arg, ERR_OK, err);
 800db72:	687b      	ldr	r3, [r7, #4]
 800db74:	2280      	movs	r2, #128	; 0x80
 800db76:	589b      	ldr	r3, [r3, r2]
 800db78:	69db      	ldr	r3, [r3, #28]
 800db7a:	2b00      	cmp	r3, #0
 800db7c:	d00e      	beq.n	800db9c <tcp_process+0x448>
 800db7e:	687b      	ldr	r3, [r7, #4]
 800db80:	2280      	movs	r2, #128	; 0x80
 800db82:	589b      	ldr	r3, [r3, r2]
 800db84:	69dd      	ldr	r5, [r3, #28]
 800db86:	687b      	ldr	r3, [r7, #4]
 800db88:	695b      	ldr	r3, [r3, #20]
 800db8a:	221e      	movs	r2, #30
 800db8c:	18bc      	adds	r4, r7, r2
 800db8e:	6879      	ldr	r1, [r7, #4]
 800db90:	2200      	movs	r2, #0
 800db92:	0018      	movs	r0, r3
 800db94:	47a8      	blx	r5
 800db96:	0003      	movs	r3, r0
 800db98:	7023      	strb	r3, [r4, #0]
 800db9a:	e003      	b.n	800dba4 <tcp_process+0x450>
 800db9c:	231e      	movs	r3, #30
 800db9e:	18fb      	adds	r3, r7, r3
 800dba0:	22f0      	movs	r2, #240	; 0xf0
 800dba2:	701a      	strb	r2, [r3, #0]
          }
          if (err != ERR_OK) {
 800dba4:	221e      	movs	r2, #30
 800dba6:	18bb      	adds	r3, r7, r2
 800dba8:	781b      	ldrb	r3, [r3, #0]
 800dbaa:	b25b      	sxtb	r3, r3
 800dbac:	2b00      	cmp	r3, #0
 800dbae:	d00b      	beq.n	800dbc8 <tcp_process+0x474>
            /* If the accept function returns with an error, we abort
             * the connection. */
            /* Already aborted? */
            if (err != ERR_ABRT) {
 800dbb0:	18bb      	adds	r3, r7, r2
 800dbb2:	781b      	ldrb	r3, [r3, #0]
 800dbb4:	b25b      	sxtb	r3, r3
 800dbb6:	330d      	adds	r3, #13
 800dbb8:	d003      	beq.n	800dbc2 <tcp_process+0x46e>
              tcp_abort(pcb);
 800dbba:	687b      	ldr	r3, [r7, #4]
 800dbbc:	0018      	movs	r0, r3
 800dbbe:	f7fd fae9 	bl	800b194 <tcp_abort>
            }
            return ERR_ABRT;
 800dbc2:	230d      	movs	r3, #13
 800dbc4:	425b      	negs	r3, r3
 800dbc6:	e1e5      	b.n	800df94 <tcp_process+0x840>
          }
          /* If there was any data contained within this ACK,
           * we'd better pass it on to the application as well. */
          tcp_receive(pcb);
 800dbc8:	687b      	ldr	r3, [r7, #4]
 800dbca:	0018      	movs	r0, r3
 800dbcc:	f000 fb42 	bl	800e254 <tcp_receive>

          /* Prevent ACK for SYN to generate a sent event */
          if (recv_acked != 0) {
 800dbd0:	4b9d      	ldr	r3, [pc, #628]	; (800de48 <tcp_process+0x6f4>)
 800dbd2:	881b      	ldrh	r3, [r3, #0]
 800dbd4:	2b00      	cmp	r3, #0
 800dbd6:	d005      	beq.n	800dbe4 <tcp_process+0x490>
            recv_acked--;
 800dbd8:	4b9b      	ldr	r3, [pc, #620]	; (800de48 <tcp_process+0x6f4>)
 800dbda:	881b      	ldrh	r3, [r3, #0]
 800dbdc:	3b01      	subs	r3, #1
 800dbde:	b29a      	uxth	r2, r3
 800dbe0:	4b99      	ldr	r3, [pc, #612]	; (800de48 <tcp_process+0x6f4>)
 800dbe2:	801a      	strh	r2, [r3, #0]
          }

          pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
 800dbe4:	687b      	ldr	r3, [r7, #4]
 800dbe6:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800dbe8:	009a      	lsls	r2, r3, #2
 800dbea:	687b      	ldr	r3, [r7, #4]
 800dbec:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800dbee:	005b      	lsls	r3, r3, #1
 800dbf0:	4996      	ldr	r1, [pc, #600]	; (800de4c <tcp_process+0x6f8>)
 800dbf2:	428b      	cmp	r3, r1
 800dbf4:	d200      	bcs.n	800dbf8 <tcp_process+0x4a4>
 800dbf6:	4b95      	ldr	r3, [pc, #596]	; (800de4c <tcp_process+0x6f8>)
 800dbf8:	429a      	cmp	r2, r3
 800dbfa:	d204      	bcs.n	800dc06 <tcp_process+0x4b2>
 800dbfc:	687b      	ldr	r3, [r7, #4]
 800dbfe:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800dc00:	009b      	lsls	r3, r3, #2
 800dc02:	b29b      	uxth	r3, r3
 800dc04:	e00b      	b.n	800dc1e <tcp_process+0x4ca>
 800dc06:	687b      	ldr	r3, [r7, #4]
 800dc08:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800dc0a:	005b      	lsls	r3, r3, #1
 800dc0c:	4a8f      	ldr	r2, [pc, #572]	; (800de4c <tcp_process+0x6f8>)
 800dc0e:	4293      	cmp	r3, r2
 800dc10:	d904      	bls.n	800dc1c <tcp_process+0x4c8>
 800dc12:	687b      	ldr	r3, [r7, #4]
 800dc14:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800dc16:	18db      	adds	r3, r3, r3
 800dc18:	b29b      	uxth	r3, r3
 800dc1a:	e000      	b.n	800dc1e <tcp_process+0x4ca>
 800dc1c:	4b8b      	ldr	r3, [pc, #556]	; (800de4c <tcp_process+0x6f8>)
 800dc1e:	687a      	ldr	r2, [r7, #4]
 800dc20:	214c      	movs	r1, #76	; 0x4c
 800dc22:	5253      	strh	r3, [r2, r1]
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SYN_RCVD): cwnd %"TCPWNDSIZE_F
                                       " ssthresh %"TCPWNDSIZE_F"\n",
                                       pcb->cwnd, pcb->ssthresh));

          if (recv_flags & TF_GOT_FIN) {
 800dc24:	4b8a      	ldr	r3, [pc, #552]	; (800de50 <tcp_process+0x6fc>)
 800dc26:	781b      	ldrb	r3, [r3, #0]
 800dc28:	001a      	movs	r2, r3
 800dc2a:	2320      	movs	r3, #32
 800dc2c:	4013      	ands	r3, r2
 800dc2e:	d040      	beq.n	800dcb2 <tcp_process+0x55e>
            tcp_ack_now(pcb);
 800dc30:	687b      	ldr	r3, [r7, #4]
 800dc32:	8bdb      	ldrh	r3, [r3, #30]
 800dc34:	2202      	movs	r2, #2
 800dc36:	4313      	orrs	r3, r2
 800dc38:	b29a      	uxth	r2, r3
 800dc3a:	687b      	ldr	r3, [r7, #4]
 800dc3c:	83da      	strh	r2, [r3, #30]
            pcb->state = CLOSE_WAIT;
 800dc3e:	687b      	ldr	r3, [r7, #4]
 800dc40:	2207      	movs	r2, #7
 800dc42:	761a      	strb	r2, [r3, #24]
          if (recv_flags & TF_GOT_FIN) {
 800dc44:	e035      	b.n	800dcb2 <tcp_process+0x55e>
          }
        } else {
          /* incorrect ACK number, send RST */
          tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800dc46:	4b7b      	ldr	r3, [pc, #492]	; (800de34 <tcp_process+0x6e0>)
 800dc48:	681c      	ldr	r4, [r3, #0]
 800dc4a:	4b82      	ldr	r3, [pc, #520]	; (800de54 <tcp_process+0x700>)
 800dc4c:	881b      	ldrh	r3, [r3, #0]
 800dc4e:	001a      	movs	r2, r3
 800dc50:	4b81      	ldr	r3, [pc, #516]	; (800de58 <tcp_process+0x704>)
 800dc52:	681b      	ldr	r3, [r3, #0]
 800dc54:	18d5      	adds	r5, r2, r3
                  ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800dc56:	4b81      	ldr	r3, [pc, #516]	; (800de5c <tcp_process+0x708>)
 800dc58:	681b      	ldr	r3, [r3, #0]
          tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800dc5a:	789a      	ldrb	r2, [r3, #2]
 800dc5c:	78db      	ldrb	r3, [r3, #3]
 800dc5e:	021b      	lsls	r3, r3, #8
 800dc60:	4313      	orrs	r3, r2
 800dc62:	b29a      	uxth	r2, r3
                  ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800dc64:	4b7d      	ldr	r3, [pc, #500]	; (800de5c <tcp_process+0x708>)
 800dc66:	681b      	ldr	r3, [r3, #0]
          tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800dc68:	7819      	ldrb	r1, [r3, #0]
 800dc6a:	785b      	ldrb	r3, [r3, #1]
 800dc6c:	021b      	lsls	r3, r3, #8
 800dc6e:	430b      	orrs	r3, r1
 800dc70:	b29b      	uxth	r3, r3
 800dc72:	497b      	ldr	r1, [pc, #492]	; (800de60 <tcp_process+0x70c>)
 800dc74:	6878      	ldr	r0, [r7, #4]
 800dc76:	9302      	str	r3, [sp, #8]
 800dc78:	9201      	str	r2, [sp, #4]
 800dc7a:	4b7a      	ldr	r3, [pc, #488]	; (800de64 <tcp_process+0x710>)
 800dc7c:	9300      	str	r3, [sp, #0]
 800dc7e:	000b      	movs	r3, r1
 800dc80:	002a      	movs	r2, r5
 800dc82:	0021      	movs	r1, r4
 800dc84:	f004 f8ce 	bl	8011e24 <tcp_rst>
        }
      } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
        /* Looks like another copy of the SYN - retransmit our SYN-ACK */
        tcp_rexmit(pcb);
      }
      break;
 800dc88:	e178      	b.n	800df7c <tcp_process+0x828>
      } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
 800dc8a:	4b69      	ldr	r3, [pc, #420]	; (800de30 <tcp_process+0x6dc>)
 800dc8c:	781b      	ldrb	r3, [r3, #0]
 800dc8e:	001a      	movs	r2, r3
 800dc90:	2302      	movs	r3, #2
 800dc92:	4013      	ands	r3, r2
 800dc94:	d100      	bne.n	800dc98 <tcp_process+0x544>
 800dc96:	e171      	b.n	800df7c <tcp_process+0x828>
 800dc98:	687b      	ldr	r3, [r7, #4]
 800dc9a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800dc9c:	1e5a      	subs	r2, r3, #1
 800dc9e:	4b6e      	ldr	r3, [pc, #440]	; (800de58 <tcp_process+0x704>)
 800dca0:	681b      	ldr	r3, [r3, #0]
 800dca2:	429a      	cmp	r2, r3
 800dca4:	d000      	beq.n	800dca8 <tcp_process+0x554>
 800dca6:	e169      	b.n	800df7c <tcp_process+0x828>
        tcp_rexmit(pcb);
 800dca8:	687b      	ldr	r3, [r7, #4]
 800dcaa:	0018      	movs	r0, r3
 800dcac:	f003 fd96 	bl	80117dc <tcp_rexmit>
      break;
 800dcb0:	e164      	b.n	800df7c <tcp_process+0x828>
 800dcb2:	e163      	b.n	800df7c <tcp_process+0x828>
    case CLOSE_WAIT:
    /* FALLTHROUGH */
    case ESTABLISHED:
      tcp_receive(pcb);
 800dcb4:	687b      	ldr	r3, [r7, #4]
 800dcb6:	0018      	movs	r0, r3
 800dcb8:	f000 facc 	bl	800e254 <tcp_receive>
      if (recv_flags & TF_GOT_FIN) { /* passive close */
 800dcbc:	4b64      	ldr	r3, [pc, #400]	; (800de50 <tcp_process+0x6fc>)
 800dcbe:	781b      	ldrb	r3, [r3, #0]
 800dcc0:	001a      	movs	r2, r3
 800dcc2:	2320      	movs	r3, #32
 800dcc4:	4013      	ands	r3, r2
 800dcc6:	d100      	bne.n	800dcca <tcp_process+0x576>
 800dcc8:	e15a      	b.n	800df80 <tcp_process+0x82c>
        tcp_ack_now(pcb);
 800dcca:	687b      	ldr	r3, [r7, #4]
 800dccc:	8bdb      	ldrh	r3, [r3, #30]
 800dcce:	2202      	movs	r2, #2
 800dcd0:	4313      	orrs	r3, r2
 800dcd2:	b29a      	uxth	r2, r3
 800dcd4:	687b      	ldr	r3, [r7, #4]
 800dcd6:	83da      	strh	r2, [r3, #30]
        pcb->state = CLOSE_WAIT;
 800dcd8:	687b      	ldr	r3, [r7, #4]
 800dcda:	2207      	movs	r2, #7
 800dcdc:	761a      	strb	r2, [r3, #24]
      }
      break;
 800dcde:	e14f      	b.n	800df80 <tcp_process+0x82c>
    case FIN_WAIT_1:
      tcp_receive(pcb);
 800dce0:	687b      	ldr	r3, [r7, #4]
 800dce2:	0018      	movs	r0, r3
 800dce4:	f000 fab6 	bl	800e254 <tcp_receive>
      if (recv_flags & TF_GOT_FIN) {
 800dce8:	4b59      	ldr	r3, [pc, #356]	; (800de50 <tcp_process+0x6fc>)
 800dcea:	781b      	ldrb	r3, [r3, #0]
 800dcec:	001a      	movs	r2, r3
 800dcee:	2320      	movs	r3, #32
 800dcf0:	4013      	ands	r3, r2
 800dcf2:	d057      	beq.n	800dda4 <tcp_process+0x650>
        if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 800dcf4:	4b4e      	ldr	r3, [pc, #312]	; (800de30 <tcp_process+0x6dc>)
 800dcf6:	781b      	ldrb	r3, [r3, #0]
 800dcf8:	001a      	movs	r2, r3
 800dcfa:	2310      	movs	r3, #16
 800dcfc:	4013      	ands	r3, r2
 800dcfe:	d046      	beq.n	800dd8e <tcp_process+0x63a>
 800dd00:	687b      	ldr	r3, [r7, #4]
 800dd02:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800dd04:	4b4b      	ldr	r3, [pc, #300]	; (800de34 <tcp_process+0x6e0>)
 800dd06:	681b      	ldr	r3, [r3, #0]
 800dd08:	429a      	cmp	r2, r3
 800dd0a:	d140      	bne.n	800dd8e <tcp_process+0x63a>
            pcb->unsent == NULL) {
 800dd0c:	687b      	ldr	r3, [r7, #4]
 800dd0e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
        if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 800dd10:	2b00      	cmp	r3, #0
 800dd12:	d13c      	bne.n	800dd8e <tcp_process+0x63a>
          LWIP_DEBUGF(TCP_DEBUG,
                      ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
          tcp_ack_now(pcb);
 800dd14:	687b      	ldr	r3, [r7, #4]
 800dd16:	8bdb      	ldrh	r3, [r3, #30]
 800dd18:	2202      	movs	r2, #2
 800dd1a:	4313      	orrs	r3, r2
 800dd1c:	b29a      	uxth	r2, r3
 800dd1e:	687b      	ldr	r3, [r7, #4]
 800dd20:	83da      	strh	r2, [r3, #30]
          tcp_pcb_purge(pcb);
 800dd22:	687b      	ldr	r3, [r7, #4]
 800dd24:	0018      	movs	r0, r3
 800dd26:	f7fe fbfd 	bl	800c524 <tcp_pcb_purge>
          TCP_RMV_ACTIVE(pcb);
 800dd2a:	4b4f      	ldr	r3, [pc, #316]	; (800de68 <tcp_process+0x714>)
 800dd2c:	681b      	ldr	r3, [r3, #0]
 800dd2e:	687a      	ldr	r2, [r7, #4]
 800dd30:	429a      	cmp	r2, r3
 800dd32:	d105      	bne.n	800dd40 <tcp_process+0x5ec>
 800dd34:	4b4c      	ldr	r3, [pc, #304]	; (800de68 <tcp_process+0x714>)
 800dd36:	681b      	ldr	r3, [r3, #0]
 800dd38:	691a      	ldr	r2, [r3, #16]
 800dd3a:	4b4b      	ldr	r3, [pc, #300]	; (800de68 <tcp_process+0x714>)
 800dd3c:	601a      	str	r2, [r3, #0]
 800dd3e:	e013      	b.n	800dd68 <tcp_process+0x614>
 800dd40:	4b49      	ldr	r3, [pc, #292]	; (800de68 <tcp_process+0x714>)
 800dd42:	681b      	ldr	r3, [r3, #0]
 800dd44:	613b      	str	r3, [r7, #16]
 800dd46:	e00c      	b.n	800dd62 <tcp_process+0x60e>
 800dd48:	693b      	ldr	r3, [r7, #16]
 800dd4a:	691b      	ldr	r3, [r3, #16]
 800dd4c:	687a      	ldr	r2, [r7, #4]
 800dd4e:	429a      	cmp	r2, r3
 800dd50:	d104      	bne.n	800dd5c <tcp_process+0x608>
 800dd52:	687b      	ldr	r3, [r7, #4]
 800dd54:	691a      	ldr	r2, [r3, #16]
 800dd56:	693b      	ldr	r3, [r7, #16]
 800dd58:	611a      	str	r2, [r3, #16]
 800dd5a:	e005      	b.n	800dd68 <tcp_process+0x614>
 800dd5c:	693b      	ldr	r3, [r7, #16]
 800dd5e:	691b      	ldr	r3, [r3, #16]
 800dd60:	613b      	str	r3, [r7, #16]
 800dd62:	693b      	ldr	r3, [r7, #16]
 800dd64:	2b00      	cmp	r3, #0
 800dd66:	d1ef      	bne.n	800dd48 <tcp_process+0x5f4>
 800dd68:	687b      	ldr	r3, [r7, #4]
 800dd6a:	2200      	movs	r2, #0
 800dd6c:	611a      	str	r2, [r3, #16]
 800dd6e:	4b3f      	ldr	r3, [pc, #252]	; (800de6c <tcp_process+0x718>)
 800dd70:	2201      	movs	r2, #1
 800dd72:	701a      	strb	r2, [r3, #0]
          pcb->state = TIME_WAIT;
 800dd74:	687b      	ldr	r3, [r7, #4]
 800dd76:	220a      	movs	r2, #10
 800dd78:	761a      	strb	r2, [r3, #24]
          TCP_REG(&tcp_tw_pcbs, pcb);
 800dd7a:	4b3d      	ldr	r3, [pc, #244]	; (800de70 <tcp_process+0x71c>)
 800dd7c:	681a      	ldr	r2, [r3, #0]
 800dd7e:	687b      	ldr	r3, [r7, #4]
 800dd80:	611a      	str	r2, [r3, #16]
 800dd82:	4b3b      	ldr	r3, [pc, #236]	; (800de70 <tcp_process+0x71c>)
 800dd84:	687a      	ldr	r2, [r7, #4]
 800dd86:	601a      	str	r2, [r3, #0]
 800dd88:	f004 fa76 	bl	8012278 <tcp_timer_needed>
        }
      } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
                 pcb->unsent == NULL) {
        pcb->state = FIN_WAIT_2;
      }
      break;
 800dd8c:	e0fa      	b.n	800df84 <tcp_process+0x830>
          tcp_ack_now(pcb);
 800dd8e:	687b      	ldr	r3, [r7, #4]
 800dd90:	8bdb      	ldrh	r3, [r3, #30]
 800dd92:	2202      	movs	r2, #2
 800dd94:	4313      	orrs	r3, r2
 800dd96:	b29a      	uxth	r2, r3
 800dd98:	687b      	ldr	r3, [r7, #4]
 800dd9a:	83da      	strh	r2, [r3, #30]
          pcb->state = CLOSING;
 800dd9c:	687b      	ldr	r3, [r7, #4]
 800dd9e:	2208      	movs	r2, #8
 800dda0:	761a      	strb	r2, [r3, #24]
      break;
 800dda2:	e0ef      	b.n	800df84 <tcp_process+0x830>
      } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 800dda4:	4b22      	ldr	r3, [pc, #136]	; (800de30 <tcp_process+0x6dc>)
 800dda6:	781b      	ldrb	r3, [r3, #0]
 800dda8:	001a      	movs	r2, r3
 800ddaa:	2310      	movs	r3, #16
 800ddac:	4013      	ands	r3, r2
 800ddae:	d100      	bne.n	800ddb2 <tcp_process+0x65e>
 800ddb0:	e0e8      	b.n	800df84 <tcp_process+0x830>
 800ddb2:	687b      	ldr	r3, [r7, #4]
 800ddb4:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800ddb6:	4b1f      	ldr	r3, [pc, #124]	; (800de34 <tcp_process+0x6e0>)
 800ddb8:	681b      	ldr	r3, [r3, #0]
 800ddba:	429a      	cmp	r2, r3
 800ddbc:	d000      	beq.n	800ddc0 <tcp_process+0x66c>
 800ddbe:	e0e1      	b.n	800df84 <tcp_process+0x830>
                 pcb->unsent == NULL) {
 800ddc0:	687b      	ldr	r3, [r7, #4]
 800ddc2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
      } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 800ddc4:	2b00      	cmp	r3, #0
 800ddc6:	d000      	beq.n	800ddca <tcp_process+0x676>
 800ddc8:	e0dc      	b.n	800df84 <tcp_process+0x830>
        pcb->state = FIN_WAIT_2;
 800ddca:	687b      	ldr	r3, [r7, #4]
 800ddcc:	2206      	movs	r2, #6
 800ddce:	761a      	strb	r2, [r3, #24]
      break;
 800ddd0:	e0d8      	b.n	800df84 <tcp_process+0x830>
    case FIN_WAIT_2:
      tcp_receive(pcb);
 800ddd2:	687b      	ldr	r3, [r7, #4]
 800ddd4:	0018      	movs	r0, r3
 800ddd6:	f000 fa3d 	bl	800e254 <tcp_receive>
      if (recv_flags & TF_GOT_FIN) {
 800ddda:	4b1d      	ldr	r3, [pc, #116]	; (800de50 <tcp_process+0x6fc>)
 800dddc:	781b      	ldrb	r3, [r3, #0]
 800ddde:	001a      	movs	r2, r3
 800dde0:	2320      	movs	r3, #32
 800dde2:	4013      	ands	r3, r2
 800dde4:	d100      	bne.n	800dde8 <tcp_process+0x694>
 800dde6:	e0cf      	b.n	800df88 <tcp_process+0x834>
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
 800dde8:	687b      	ldr	r3, [r7, #4]
 800ddea:	8bdb      	ldrh	r3, [r3, #30]
 800ddec:	2202      	movs	r2, #2
 800ddee:	4313      	orrs	r3, r2
 800ddf0:	b29a      	uxth	r2, r3
 800ddf2:	687b      	ldr	r3, [r7, #4]
 800ddf4:	83da      	strh	r2, [r3, #30]
        tcp_pcb_purge(pcb);
 800ddf6:	687b      	ldr	r3, [r7, #4]
 800ddf8:	0018      	movs	r0, r3
 800ddfa:	f7fe fb93 	bl	800c524 <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
 800ddfe:	4b1a      	ldr	r3, [pc, #104]	; (800de68 <tcp_process+0x714>)
 800de00:	681b      	ldr	r3, [r3, #0]
 800de02:	687a      	ldr	r2, [r7, #4]
 800de04:	429a      	cmp	r2, r3
 800de06:	d105      	bne.n	800de14 <tcp_process+0x6c0>
 800de08:	4b17      	ldr	r3, [pc, #92]	; (800de68 <tcp_process+0x714>)
 800de0a:	681b      	ldr	r3, [r3, #0]
 800de0c:	691a      	ldr	r2, [r3, #16]
 800de0e:	4b16      	ldr	r3, [pc, #88]	; (800de68 <tcp_process+0x714>)
 800de10:	601a      	str	r2, [r3, #0]
 800de12:	e035      	b.n	800de80 <tcp_process+0x72c>
 800de14:	4b14      	ldr	r3, [pc, #80]	; (800de68 <tcp_process+0x714>)
 800de16:	681b      	ldr	r3, [r3, #0]
 800de18:	60fb      	str	r3, [r7, #12]
 800de1a:	e02e      	b.n	800de7a <tcp_process+0x726>
 800de1c:	68fb      	ldr	r3, [r7, #12]
 800de1e:	691b      	ldr	r3, [r3, #16]
 800de20:	687a      	ldr	r2, [r7, #4]
 800de22:	429a      	cmp	r2, r3
 800de24:	d126      	bne.n	800de74 <tcp_process+0x720>
 800de26:	687b      	ldr	r3, [r7, #4]
 800de28:	691a      	ldr	r2, [r3, #16]
 800de2a:	68fb      	ldr	r3, [r7, #12]
 800de2c:	611a      	str	r2, [r3, #16]
 800de2e:	e027      	b.n	800de80 <tcp_process+0x72c>
 800de30:	200017c4 	.word	0x200017c4
 800de34:	200017bc 	.word	0x200017bc
 800de38:	080205bc 	.word	0x080205bc
 800de3c:	000003a9 	.word	0x000003a9
 800de40:	08020854 	.word	0x08020854
 800de44:	080205fc 	.word	0x080205fc
 800de48:	200017c0 	.word	0x200017c0
 800de4c:	0000111c 	.word	0x0000111c
 800de50:	200017c5 	.word	0x200017c5
 800de54:	200017c2 	.word	0x200017c2
 800de58:	200017b8 	.word	0x200017b8
 800de5c:	200017a8 	.word	0x200017a8
 800de60:	20001910 	.word	0x20001910
 800de64:	2000190c 	.word	0x2000190c
 800de68:	20002b3c 	.word	0x20002b3c
 800de6c:	20002b38 	.word	0x20002b38
 800de70:	20002b4c 	.word	0x20002b4c
 800de74:	68fb      	ldr	r3, [r7, #12]
 800de76:	691b      	ldr	r3, [r3, #16]
 800de78:	60fb      	str	r3, [r7, #12]
 800de7a:	68fb      	ldr	r3, [r7, #12]
 800de7c:	2b00      	cmp	r3, #0
 800de7e:	d1cd      	bne.n	800de1c <tcp_process+0x6c8>
 800de80:	687b      	ldr	r3, [r7, #4]
 800de82:	2200      	movs	r2, #0
 800de84:	611a      	str	r2, [r3, #16]
 800de86:	4b45      	ldr	r3, [pc, #276]	; (800df9c <tcp_process+0x848>)
 800de88:	2201      	movs	r2, #1
 800de8a:	701a      	strb	r2, [r3, #0]
        pcb->state = TIME_WAIT;
 800de8c:	687b      	ldr	r3, [r7, #4]
 800de8e:	220a      	movs	r2, #10
 800de90:	761a      	strb	r2, [r3, #24]
        TCP_REG(&tcp_tw_pcbs, pcb);
 800de92:	4b43      	ldr	r3, [pc, #268]	; (800dfa0 <tcp_process+0x84c>)
 800de94:	681a      	ldr	r2, [r3, #0]
 800de96:	687b      	ldr	r3, [r7, #4]
 800de98:	611a      	str	r2, [r3, #16]
 800de9a:	4b41      	ldr	r3, [pc, #260]	; (800dfa0 <tcp_process+0x84c>)
 800de9c:	687a      	ldr	r2, [r7, #4]
 800de9e:	601a      	str	r2, [r3, #0]
 800dea0:	f004 f9ea 	bl	8012278 <tcp_timer_needed>
      }
      break;
 800dea4:	e070      	b.n	800df88 <tcp_process+0x834>
    case CLOSING:
      tcp_receive(pcb);
 800dea6:	687b      	ldr	r3, [r7, #4]
 800dea8:	0018      	movs	r0, r3
 800deaa:	f000 f9d3 	bl	800e254 <tcp_receive>
      if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
 800deae:	4b3d      	ldr	r3, [pc, #244]	; (800dfa4 <tcp_process+0x850>)
 800deb0:	781b      	ldrb	r3, [r3, #0]
 800deb2:	001a      	movs	r2, r3
 800deb4:	2310      	movs	r3, #16
 800deb6:	4013      	ands	r3, r2
 800deb8:	d100      	bne.n	800debc <tcp_process+0x768>
 800deba:	e067      	b.n	800df8c <tcp_process+0x838>
 800debc:	687b      	ldr	r3, [r7, #4]
 800debe:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800dec0:	4b39      	ldr	r3, [pc, #228]	; (800dfa8 <tcp_process+0x854>)
 800dec2:	681b      	ldr	r3, [r3, #0]
 800dec4:	429a      	cmp	r2, r3
 800dec6:	d161      	bne.n	800df8c <tcp_process+0x838>
 800dec8:	687b      	ldr	r3, [r7, #4]
 800deca:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800decc:	2b00      	cmp	r3, #0
 800dece:	d15d      	bne.n	800df8c <tcp_process+0x838>
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_pcb_purge(pcb);
 800ded0:	687b      	ldr	r3, [r7, #4]
 800ded2:	0018      	movs	r0, r3
 800ded4:	f7fe fb26 	bl	800c524 <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
 800ded8:	4b34      	ldr	r3, [pc, #208]	; (800dfac <tcp_process+0x858>)
 800deda:	681b      	ldr	r3, [r3, #0]
 800dedc:	687a      	ldr	r2, [r7, #4]
 800dede:	429a      	cmp	r2, r3
 800dee0:	d105      	bne.n	800deee <tcp_process+0x79a>
 800dee2:	4b32      	ldr	r3, [pc, #200]	; (800dfac <tcp_process+0x858>)
 800dee4:	681b      	ldr	r3, [r3, #0]
 800dee6:	691a      	ldr	r2, [r3, #16]
 800dee8:	4b30      	ldr	r3, [pc, #192]	; (800dfac <tcp_process+0x858>)
 800deea:	601a      	str	r2, [r3, #0]
 800deec:	e013      	b.n	800df16 <tcp_process+0x7c2>
 800deee:	4b2f      	ldr	r3, [pc, #188]	; (800dfac <tcp_process+0x858>)
 800def0:	681b      	ldr	r3, [r3, #0]
 800def2:	61bb      	str	r3, [r7, #24]
 800def4:	e00c      	b.n	800df10 <tcp_process+0x7bc>
 800def6:	69bb      	ldr	r3, [r7, #24]
 800def8:	691b      	ldr	r3, [r3, #16]
 800defa:	687a      	ldr	r2, [r7, #4]
 800defc:	429a      	cmp	r2, r3
 800defe:	d104      	bne.n	800df0a <tcp_process+0x7b6>
 800df00:	687b      	ldr	r3, [r7, #4]
 800df02:	691a      	ldr	r2, [r3, #16]
 800df04:	69bb      	ldr	r3, [r7, #24]
 800df06:	611a      	str	r2, [r3, #16]
 800df08:	e005      	b.n	800df16 <tcp_process+0x7c2>
 800df0a:	69bb      	ldr	r3, [r7, #24]
 800df0c:	691b      	ldr	r3, [r3, #16]
 800df0e:	61bb      	str	r3, [r7, #24]
 800df10:	69bb      	ldr	r3, [r7, #24]
 800df12:	2b00      	cmp	r3, #0
 800df14:	d1ef      	bne.n	800def6 <tcp_process+0x7a2>
 800df16:	687b      	ldr	r3, [r7, #4]
 800df18:	2200      	movs	r2, #0
 800df1a:	611a      	str	r2, [r3, #16]
 800df1c:	4b1f      	ldr	r3, [pc, #124]	; (800df9c <tcp_process+0x848>)
 800df1e:	2201      	movs	r2, #1
 800df20:	701a      	strb	r2, [r3, #0]
        pcb->state = TIME_WAIT;
 800df22:	687b      	ldr	r3, [r7, #4]
 800df24:	220a      	movs	r2, #10
 800df26:	761a      	strb	r2, [r3, #24]
        TCP_REG(&tcp_tw_pcbs, pcb);
 800df28:	4b1d      	ldr	r3, [pc, #116]	; (800dfa0 <tcp_process+0x84c>)
 800df2a:	681a      	ldr	r2, [r3, #0]
 800df2c:	687b      	ldr	r3, [r7, #4]
 800df2e:	611a      	str	r2, [r3, #16]
 800df30:	4b1b      	ldr	r3, [pc, #108]	; (800dfa0 <tcp_process+0x84c>)
 800df32:	687a      	ldr	r2, [r7, #4]
 800df34:	601a      	str	r2, [r3, #0]
 800df36:	f004 f99f 	bl	8012278 <tcp_timer_needed>
      }
      break;
 800df3a:	e027      	b.n	800df8c <tcp_process+0x838>
    case LAST_ACK:
      tcp_receive(pcb);
 800df3c:	687b      	ldr	r3, [r7, #4]
 800df3e:	0018      	movs	r0, r3
 800df40:	f000 f988 	bl	800e254 <tcp_receive>
      if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
 800df44:	4b17      	ldr	r3, [pc, #92]	; (800dfa4 <tcp_process+0x850>)
 800df46:	781b      	ldrb	r3, [r3, #0]
 800df48:	001a      	movs	r2, r3
 800df4a:	2310      	movs	r3, #16
 800df4c:	4013      	ands	r3, r2
 800df4e:	d01f      	beq.n	800df90 <tcp_process+0x83c>
 800df50:	687b      	ldr	r3, [r7, #4]
 800df52:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800df54:	4b14      	ldr	r3, [pc, #80]	; (800dfa8 <tcp_process+0x854>)
 800df56:	681b      	ldr	r3, [r3, #0]
 800df58:	429a      	cmp	r2, r3
 800df5a:	d119      	bne.n	800df90 <tcp_process+0x83c>
 800df5c:	687b      	ldr	r3, [r7, #4]
 800df5e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800df60:	2b00      	cmp	r3, #0
 800df62:	d115      	bne.n	800df90 <tcp_process+0x83c>
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
        recv_flags |= TF_CLOSED;
 800df64:	4b12      	ldr	r3, [pc, #72]	; (800dfb0 <tcp_process+0x85c>)
 800df66:	781b      	ldrb	r3, [r3, #0]
 800df68:	2210      	movs	r2, #16
 800df6a:	4313      	orrs	r3, r2
 800df6c:	b2da      	uxtb	r2, r3
 800df6e:	4b10      	ldr	r3, [pc, #64]	; (800dfb0 <tcp_process+0x85c>)
 800df70:	701a      	strb	r2, [r3, #0]
      }
      break;
 800df72:	e00d      	b.n	800df90 <tcp_process+0x83c>
    default:
      break;
 800df74:	46c0      	nop			; (mov r8, r8)
 800df76:	e00c      	b.n	800df92 <tcp_process+0x83e>
      break;
 800df78:	46c0      	nop			; (mov r8, r8)
 800df7a:	e00a      	b.n	800df92 <tcp_process+0x83e>
      break;
 800df7c:	46c0      	nop			; (mov r8, r8)
 800df7e:	e008      	b.n	800df92 <tcp_process+0x83e>
      break;
 800df80:	46c0      	nop			; (mov r8, r8)
 800df82:	e006      	b.n	800df92 <tcp_process+0x83e>
      break;
 800df84:	46c0      	nop			; (mov r8, r8)
 800df86:	e004      	b.n	800df92 <tcp_process+0x83e>
      break;
 800df88:	46c0      	nop			; (mov r8, r8)
 800df8a:	e002      	b.n	800df92 <tcp_process+0x83e>
      break;
 800df8c:	46c0      	nop			; (mov r8, r8)
 800df8e:	e000      	b.n	800df92 <tcp_process+0x83e>
      break;
 800df90:	46c0      	nop			; (mov r8, r8)
  }
  return ERR_OK;
 800df92:	2300      	movs	r3, #0
}
 800df94:	0018      	movs	r0, r3
 800df96:	46bd      	mov	sp, r7
 800df98:	b008      	add	sp, #32
 800df9a:	bdb0      	pop	{r4, r5, r7, pc}
 800df9c:	20002b38 	.word	0x20002b38
 800dfa0:	20002b4c 	.word	0x20002b4c
 800dfa4:	200017c4 	.word	0x200017c4
 800dfa8:	200017bc 	.word	0x200017bc
 800dfac:	20002b3c 	.word	0x20002b3c
 800dfb0:	200017c5 	.word	0x200017c5

0800dfb4 <tcp_oos_insert_segment>:
 *
 * Called from tcp_receive()
 */
static void
tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
{
 800dfb4:	b590      	push	{r4, r7, lr}
 800dfb6:	b085      	sub	sp, #20
 800dfb8:	af00      	add	r7, sp, #0
 800dfba:	6078      	str	r0, [r7, #4]
 800dfbc:	6039      	str	r1, [r7, #0]
  struct tcp_seg *old_seg;

  LWIP_ASSERT("tcp_oos_insert_segment: invalid cseg", cseg != NULL);
 800dfbe:	687b      	ldr	r3, [r7, #4]
 800dfc0:	2b00      	cmp	r3, #0
 800dfc2:	d106      	bne.n	800dfd2 <tcp_oos_insert_segment+0x1e>
 800dfc4:	4b57      	ldr	r3, [pc, #348]	; (800e124 <tcp_oos_insert_segment+0x170>)
 800dfc6:	2284      	movs	r2, #132	; 0x84
 800dfc8:	00d2      	lsls	r2, r2, #3
 800dfca:	4957      	ldr	r1, [pc, #348]	; (800e128 <tcp_oos_insert_segment+0x174>)
 800dfcc:	4857      	ldr	r0, [pc, #348]	; (800e12c <tcp_oos_insert_segment+0x178>)
 800dfce:	f7f4 fdfb 	bl	8002bc8 <app_debug_rtt_raw>

  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 800dfd2:	687b      	ldr	r3, [r7, #4]
 800dfd4:	691b      	ldr	r3, [r3, #16]
 800dfd6:	7b1a      	ldrb	r2, [r3, #12]
 800dfd8:	7b5b      	ldrb	r3, [r3, #13]
 800dfda:	021b      	lsls	r3, r3, #8
 800dfdc:	4313      	orrs	r3, r2
 800dfde:	b29b      	uxth	r3, r3
 800dfe0:	0018      	movs	r0, r3
 800dfe2:	f7f8 ff87 	bl	8006ef4 <lwip_htons>
 800dfe6:	0003      	movs	r3, r0
 800dfe8:	b2db      	uxtb	r3, r3
 800dfea:	001a      	movs	r2, r3
 800dfec:	2301      	movs	r3, #1
 800dfee:	4013      	ands	r3, r2
 800dff0:	d042      	beq.n	800e078 <tcp_oos_insert_segment+0xc4>
    /* received segment overlaps all following segments */
    tcp_segs_free(next);
 800dff2:	683b      	ldr	r3, [r7, #0]
 800dff4:	0018      	movs	r0, r3
 800dff6:	f7fd ffb7 	bl	800bf68 <tcp_segs_free>
    next = NULL;
 800dffa:	2300      	movs	r3, #0
 800dffc:	603b      	str	r3, [r7, #0]
 800dffe:	e08a      	b.n	800e116 <tcp_oos_insert_segment+0x162>
       oos queue may have segments with FIN flag */
    while (next &&
           TCP_SEQ_GEQ((seqno + cseg->len),
                       (next->tcphdr->seqno + next->len))) {
      /* cseg with FIN already processed */
      if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 800e000:	683b      	ldr	r3, [r7, #0]
 800e002:	691b      	ldr	r3, [r3, #16]
 800e004:	7b1a      	ldrb	r2, [r3, #12]
 800e006:	7b5b      	ldrb	r3, [r3, #13]
 800e008:	021b      	lsls	r3, r3, #8
 800e00a:	4313      	orrs	r3, r2
 800e00c:	b29b      	uxth	r3, r3
 800e00e:	0018      	movs	r0, r3
 800e010:	f7f8 ff70 	bl	8006ef4 <lwip_htons>
 800e014:	0003      	movs	r3, r0
 800e016:	b2db      	uxtb	r3, r3
 800e018:	001a      	movs	r2, r3
 800e01a:	2301      	movs	r3, #1
 800e01c:	4013      	ands	r3, r2
 800e01e:	d022      	beq.n	800e066 <tcp_oos_insert_segment+0xb2>
        TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
 800e020:	687b      	ldr	r3, [r7, #4]
 800e022:	691b      	ldr	r3, [r3, #16]
 800e024:	7b1a      	ldrb	r2, [r3, #12]
 800e026:	7b5b      	ldrb	r3, [r3, #13]
 800e028:	021b      	lsls	r3, r3, #8
 800e02a:	4313      	orrs	r3, r2
 800e02c:	b29c      	uxth	r4, r3
 800e02e:	2001      	movs	r0, #1
 800e030:	f7f8 ff60 	bl	8006ef4 <lwip_htons>
 800e034:	0003      	movs	r3, r0
 800e036:	001a      	movs	r2, r3
 800e038:	687b      	ldr	r3, [r7, #4]
 800e03a:	691b      	ldr	r3, [r3, #16]
 800e03c:	4322      	orrs	r2, r4
 800e03e:	b292      	uxth	r2, r2
 800e040:	21ff      	movs	r1, #255	; 0xff
 800e042:	4011      	ands	r1, r2
 800e044:	000c      	movs	r4, r1
 800e046:	7b19      	ldrb	r1, [r3, #12]
 800e048:	2000      	movs	r0, #0
 800e04a:	4001      	ands	r1, r0
 800e04c:	1c08      	adds	r0, r1, #0
 800e04e:	1c21      	adds	r1, r4, #0
 800e050:	4301      	orrs	r1, r0
 800e052:	7319      	strb	r1, [r3, #12]
 800e054:	0a12      	lsrs	r2, r2, #8
 800e056:	b290      	uxth	r0, r2
 800e058:	7b5a      	ldrb	r2, [r3, #13]
 800e05a:	2100      	movs	r1, #0
 800e05c:	400a      	ands	r2, r1
 800e05e:	1c11      	adds	r1, r2, #0
 800e060:	1c02      	adds	r2, r0, #0
 800e062:	430a      	orrs	r2, r1
 800e064:	735a      	strb	r2, [r3, #13]
      }
      old_seg = next;
 800e066:	683b      	ldr	r3, [r7, #0]
 800e068:	60fb      	str	r3, [r7, #12]
      next = next->next;
 800e06a:	683b      	ldr	r3, [r7, #0]
 800e06c:	681b      	ldr	r3, [r3, #0]
 800e06e:	603b      	str	r3, [r7, #0]
      tcp_seg_free(old_seg);
 800e070:	68fb      	ldr	r3, [r7, #12]
 800e072:	0018      	movs	r0, r3
 800e074:	f7fd ff8e 	bl	800bf94 <tcp_seg_free>
    while (next &&
 800e078:	683b      	ldr	r3, [r7, #0]
 800e07a:	2b00      	cmp	r3, #0
 800e07c:	d017      	beq.n	800e0ae <tcp_oos_insert_segment+0xfa>
           TCP_SEQ_GEQ((seqno + cseg->len),
 800e07e:	687b      	ldr	r3, [r7, #4]
 800e080:	891b      	ldrh	r3, [r3, #8]
 800e082:	001a      	movs	r2, r3
 800e084:	4b2a      	ldr	r3, [pc, #168]	; (800e130 <tcp_oos_insert_segment+0x17c>)
 800e086:	681b      	ldr	r3, [r3, #0]
 800e088:	18d2      	adds	r2, r2, r3
 800e08a:	683b      	ldr	r3, [r7, #0]
 800e08c:	691b      	ldr	r3, [r3, #16]
 800e08e:	7919      	ldrb	r1, [r3, #4]
 800e090:	7958      	ldrb	r0, [r3, #5]
 800e092:	0200      	lsls	r0, r0, #8
 800e094:	4301      	orrs	r1, r0
 800e096:	7998      	ldrb	r0, [r3, #6]
 800e098:	0400      	lsls	r0, r0, #16
 800e09a:	4301      	orrs	r1, r0
 800e09c:	79db      	ldrb	r3, [r3, #7]
 800e09e:	061b      	lsls	r3, r3, #24
 800e0a0:	430b      	orrs	r3, r1
 800e0a2:	0019      	movs	r1, r3
 800e0a4:	683b      	ldr	r3, [r7, #0]
 800e0a6:	891b      	ldrh	r3, [r3, #8]
 800e0a8:	18cb      	adds	r3, r1, r3
 800e0aa:	1ad3      	subs	r3, r2, r3
    while (next &&
 800e0ac:	d5a8      	bpl.n	800e000 <tcp_oos_insert_segment+0x4c>
    }
    if (next &&
 800e0ae:	683b      	ldr	r3, [r7, #0]
 800e0b0:	2b00      	cmp	r3, #0
 800e0b2:	d030      	beq.n	800e116 <tcp_oos_insert_segment+0x162>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
 800e0b4:	687b      	ldr	r3, [r7, #4]
 800e0b6:	891b      	ldrh	r3, [r3, #8]
 800e0b8:	001a      	movs	r2, r3
 800e0ba:	4b1d      	ldr	r3, [pc, #116]	; (800e130 <tcp_oos_insert_segment+0x17c>)
 800e0bc:	681b      	ldr	r3, [r3, #0]
 800e0be:	18d2      	adds	r2, r2, r3
 800e0c0:	683b      	ldr	r3, [r7, #0]
 800e0c2:	691b      	ldr	r3, [r3, #16]
 800e0c4:	7919      	ldrb	r1, [r3, #4]
 800e0c6:	7958      	ldrb	r0, [r3, #5]
 800e0c8:	0200      	lsls	r0, r0, #8
 800e0ca:	4301      	orrs	r1, r0
 800e0cc:	7998      	ldrb	r0, [r3, #6]
 800e0ce:	0400      	lsls	r0, r0, #16
 800e0d0:	4301      	orrs	r1, r0
 800e0d2:	79db      	ldrb	r3, [r3, #7]
 800e0d4:	061b      	lsls	r3, r3, #24
 800e0d6:	430b      	orrs	r3, r1
 800e0d8:	1ad3      	subs	r3, r2, r3
    if (next &&
 800e0da:	2b00      	cmp	r3, #0
 800e0dc:	dd1b      	ble.n	800e116 <tcp_oos_insert_segment+0x162>
      /* We need to trim the incoming segment. */
      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
 800e0de:	683b      	ldr	r3, [r7, #0]
 800e0e0:	691b      	ldr	r3, [r3, #16]
 800e0e2:	791a      	ldrb	r2, [r3, #4]
 800e0e4:	7959      	ldrb	r1, [r3, #5]
 800e0e6:	0209      	lsls	r1, r1, #8
 800e0e8:	430a      	orrs	r2, r1
 800e0ea:	7999      	ldrb	r1, [r3, #6]
 800e0ec:	0409      	lsls	r1, r1, #16
 800e0ee:	430a      	orrs	r2, r1
 800e0f0:	79db      	ldrb	r3, [r3, #7]
 800e0f2:	061b      	lsls	r3, r3, #24
 800e0f4:	4313      	orrs	r3, r2
 800e0f6:	b29a      	uxth	r2, r3
 800e0f8:	4b0d      	ldr	r3, [pc, #52]	; (800e130 <tcp_oos_insert_segment+0x17c>)
 800e0fa:	681b      	ldr	r3, [r3, #0]
 800e0fc:	b29b      	uxth	r3, r3
 800e0fe:	1ad3      	subs	r3, r2, r3
 800e100:	b29a      	uxth	r2, r3
 800e102:	687b      	ldr	r3, [r7, #4]
 800e104:	811a      	strh	r2, [r3, #8]
      pbuf_realloc(cseg->p, cseg->len);
 800e106:	687b      	ldr	r3, [r7, #4]
 800e108:	685a      	ldr	r2, [r3, #4]
 800e10a:	687b      	ldr	r3, [r7, #4]
 800e10c:	891b      	ldrh	r3, [r3, #8]
 800e10e:	0019      	movs	r1, r3
 800e110:	0010      	movs	r0, r2
 800e112:	f7fb fcd9 	bl	8009ac8 <pbuf_realloc>
    }
  }
  cseg->next = next;
 800e116:	687b      	ldr	r3, [r7, #4]
 800e118:	683a      	ldr	r2, [r7, #0]
 800e11a:	601a      	str	r2, [r3, #0]
}
 800e11c:	46c0      	nop			; (mov r8, r8)
 800e11e:	46bd      	mov	sp, r7
 800e120:	b005      	add	sp, #20
 800e122:	bd90      	pop	{r4, r7, pc}
 800e124:	080205bc 	.word	0x080205bc
 800e128:	08020874 	.word	0x08020874
 800e12c:	080205fc 	.word	0x080205fc
 800e130:	200017b8 	.word	0x200017b8

0800e134 <tcp_free_acked_segments>:

/** Remove segments from a list if the incoming ACK acknowledges them */
static struct tcp_seg *
tcp_free_acked_segments(struct tcp_pcb *pcb, struct tcp_seg *seg_list, const char *dbg_list_name,
                        struct tcp_seg *dbg_other_seg_list)
{
 800e134:	b5b0      	push	{r4, r5, r7, lr}
 800e136:	b086      	sub	sp, #24
 800e138:	af00      	add	r7, sp, #0
 800e13a:	60f8      	str	r0, [r7, #12]
 800e13c:	60b9      	str	r1, [r7, #8]
 800e13e:	607a      	str	r2, [r7, #4]
 800e140:	603b      	str	r3, [r7, #0]
  u16_t clen;

  LWIP_UNUSED_ARG(dbg_list_name);
  LWIP_UNUSED_ARG(dbg_other_seg_list);

  while (seg_list != NULL &&
 800e142:	e043      	b.n	800e1cc <tcp_free_acked_segments+0x98>
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->%s\n",
                                  lwip_ntohl(seg_list->tcphdr->seqno),
                                  lwip_ntohl(seg_list->tcphdr->seqno) + TCP_TCPLEN(seg_list),
                                  dbg_list_name));

    next = seg_list;
 800e144:	68bb      	ldr	r3, [r7, #8]
 800e146:	617b      	str	r3, [r7, #20]
    seg_list = seg_list->next;
 800e148:	68bb      	ldr	r3, [r7, #8]
 800e14a:	681b      	ldr	r3, [r3, #0]
 800e14c:	60bb      	str	r3, [r7, #8]

    clen = pbuf_clen(next->p);
 800e14e:	697b      	ldr	r3, [r7, #20]
 800e150:	685b      	ldr	r3, [r3, #4]
 800e152:	2512      	movs	r5, #18
 800e154:	197c      	adds	r4, r7, r5
 800e156:	0018      	movs	r0, r3
 800e158:	f7fb ff50 	bl	8009ffc <pbuf_clen>
 800e15c:	0003      	movs	r3, r0
 800e15e:	8023      	strh	r3, [r4, #0]
    LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"TCPWNDSIZE_F" ... ",
                                 (tcpwnd_size_t)pcb->snd_queuelen));
    LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= clen));
 800e160:	68fb      	ldr	r3, [r7, #12]
 800e162:	226a      	movs	r2, #106	; 0x6a
 800e164:	5a9b      	ldrh	r3, [r3, r2]
 800e166:	197a      	adds	r2, r7, r5
 800e168:	8812      	ldrh	r2, [r2, #0]
 800e16a:	429a      	cmp	r2, r3
 800e16c:	d906      	bls.n	800e17c <tcp_free_acked_segments+0x48>
 800e16e:	4b32      	ldr	r3, [pc, #200]	; (800e238 <tcp_free_acked_segments+0x104>)
 800e170:	228b      	movs	r2, #139	; 0x8b
 800e172:	00d2      	lsls	r2, r2, #3
 800e174:	4931      	ldr	r1, [pc, #196]	; (800e23c <tcp_free_acked_segments+0x108>)
 800e176:	4832      	ldr	r0, [pc, #200]	; (800e240 <tcp_free_acked_segments+0x10c>)
 800e178:	f7f4 fd26 	bl	8002bc8 <app_debug_rtt_raw>

    pcb->snd_queuelen = (u16_t)(pcb->snd_queuelen - clen);
 800e17c:	68fb      	ldr	r3, [r7, #12]
 800e17e:	226a      	movs	r2, #106	; 0x6a
 800e180:	5a9a      	ldrh	r2, [r3, r2]
 800e182:	2312      	movs	r3, #18
 800e184:	18fb      	adds	r3, r7, r3
 800e186:	881b      	ldrh	r3, [r3, #0]
 800e188:	1ad3      	subs	r3, r2, r3
 800e18a:	b299      	uxth	r1, r3
 800e18c:	68fb      	ldr	r3, [r7, #12]
 800e18e:	226a      	movs	r2, #106	; 0x6a
 800e190:	5299      	strh	r1, [r3, r2]
    recv_acked = (tcpwnd_size_t)(recv_acked + next->len);
 800e192:	697b      	ldr	r3, [r7, #20]
 800e194:	891a      	ldrh	r2, [r3, #8]
 800e196:	4b2b      	ldr	r3, [pc, #172]	; (800e244 <tcp_free_acked_segments+0x110>)
 800e198:	881b      	ldrh	r3, [r3, #0]
 800e19a:	18d3      	adds	r3, r2, r3
 800e19c:	b29a      	uxth	r2, r3
 800e19e:	4b29      	ldr	r3, [pc, #164]	; (800e244 <tcp_free_acked_segments+0x110>)
 800e1a0:	801a      	strh	r2, [r3, #0]
    tcp_seg_free(next);
 800e1a2:	697b      	ldr	r3, [r7, #20]
 800e1a4:	0018      	movs	r0, r3
 800e1a6:	f7fd fef5 	bl	800bf94 <tcp_seg_free>

    LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"TCPWNDSIZE_F" (after freeing %s)\n",
                                 (tcpwnd_size_t)pcb->snd_queuelen,
                                 dbg_list_name));
    if (pcb->snd_queuelen != 0) {
 800e1aa:	68fb      	ldr	r3, [r7, #12]
 800e1ac:	226a      	movs	r2, #106	; 0x6a
 800e1ae:	5a9b      	ldrh	r3, [r3, r2]
 800e1b0:	2b00      	cmp	r3, #0
 800e1b2:	d00b      	beq.n	800e1cc <tcp_free_acked_segments+0x98>
      LWIP_ASSERT("tcp_receive: valid queue length",
 800e1b4:	68bb      	ldr	r3, [r7, #8]
 800e1b6:	2b00      	cmp	r3, #0
 800e1b8:	d108      	bne.n	800e1cc <tcp_free_acked_segments+0x98>
 800e1ba:	683b      	ldr	r3, [r7, #0]
 800e1bc:	2b00      	cmp	r3, #0
 800e1be:	d105      	bne.n	800e1cc <tcp_free_acked_segments+0x98>
 800e1c0:	4b1d      	ldr	r3, [pc, #116]	; (800e238 <tcp_free_acked_segments+0x104>)
 800e1c2:	4a21      	ldr	r2, [pc, #132]	; (800e248 <tcp_free_acked_segments+0x114>)
 800e1c4:	4921      	ldr	r1, [pc, #132]	; (800e24c <tcp_free_acked_segments+0x118>)
 800e1c6:	481e      	ldr	r0, [pc, #120]	; (800e240 <tcp_free_acked_segments+0x10c>)
 800e1c8:	f7f4 fcfe 	bl	8002bc8 <app_debug_rtt_raw>
  while (seg_list != NULL &&
 800e1cc:	68bb      	ldr	r3, [r7, #8]
 800e1ce:	2b00      	cmp	r3, #0
 800e1d0:	d02c      	beq.n	800e22c <tcp_free_acked_segments+0xf8>
         TCP_SEQ_LEQ(lwip_ntohl(seg_list->tcphdr->seqno) +
 800e1d2:	68bb      	ldr	r3, [r7, #8]
 800e1d4:	691b      	ldr	r3, [r3, #16]
 800e1d6:	791a      	ldrb	r2, [r3, #4]
 800e1d8:	7959      	ldrb	r1, [r3, #5]
 800e1da:	0209      	lsls	r1, r1, #8
 800e1dc:	430a      	orrs	r2, r1
 800e1de:	7999      	ldrb	r1, [r3, #6]
 800e1e0:	0409      	lsls	r1, r1, #16
 800e1e2:	430a      	orrs	r2, r1
 800e1e4:	79db      	ldrb	r3, [r3, #7]
 800e1e6:	061b      	lsls	r3, r3, #24
 800e1e8:	4313      	orrs	r3, r2
 800e1ea:	0018      	movs	r0, r3
 800e1ec:	f7f8 fe98 	bl	8006f20 <lwip_htonl>
 800e1f0:	0004      	movs	r4, r0
 800e1f2:	68bb      	ldr	r3, [r7, #8]
 800e1f4:	891b      	ldrh	r3, [r3, #8]
 800e1f6:	001d      	movs	r5, r3
 800e1f8:	68bb      	ldr	r3, [r7, #8]
 800e1fa:	691b      	ldr	r3, [r3, #16]
 800e1fc:	7b1a      	ldrb	r2, [r3, #12]
 800e1fe:	7b5b      	ldrb	r3, [r3, #13]
 800e200:	021b      	lsls	r3, r3, #8
 800e202:	4313      	orrs	r3, r2
 800e204:	b29b      	uxth	r3, r3
 800e206:	0018      	movs	r0, r3
 800e208:	f7f8 fe74 	bl	8006ef4 <lwip_htons>
 800e20c:	0003      	movs	r3, r0
 800e20e:	b2db      	uxtb	r3, r3
 800e210:	001a      	movs	r2, r3
 800e212:	2303      	movs	r3, #3
 800e214:	4013      	ands	r3, r2
 800e216:	d001      	beq.n	800e21c <tcp_free_acked_segments+0xe8>
 800e218:	2301      	movs	r3, #1
 800e21a:	e000      	b.n	800e21e <tcp_free_acked_segments+0xea>
 800e21c:	2300      	movs	r3, #0
 800e21e:	195b      	adds	r3, r3, r5
 800e220:	18e2      	adds	r2, r4, r3
 800e222:	4b0b      	ldr	r3, [pc, #44]	; (800e250 <tcp_free_acked_segments+0x11c>)
 800e224:	681b      	ldr	r3, [r3, #0]
 800e226:	1ad3      	subs	r3, r2, r3
  while (seg_list != NULL &&
 800e228:	2b00      	cmp	r3, #0
 800e22a:	dd8b      	ble.n	800e144 <tcp_free_acked_segments+0x10>
                  seg_list != NULL || dbg_other_seg_list != NULL);
    }
  }
  return seg_list;
 800e22c:	68bb      	ldr	r3, [r7, #8]
}
 800e22e:	0018      	movs	r0, r3
 800e230:	46bd      	mov	sp, r7
 800e232:	b006      	add	sp, #24
 800e234:	bdb0      	pop	{r4, r5, r7, pc}
 800e236:	46c0      	nop			; (mov r8, r8)
 800e238:	080205bc 	.word	0x080205bc
 800e23c:	0802089c 	.word	0x0802089c
 800e240:	080205fc 	.word	0x080205fc
 800e244:	200017c0 	.word	0x200017c0
 800e248:	00000462 	.word	0x00000462
 800e24c:	080208c4 	.word	0x080208c4
 800e250:	200017bc 	.word	0x200017bc

0800e254 <tcp_receive>:
 *
 * Called from tcp_process().
 */
static void
tcp_receive(struct tcp_pcb *pcb)
{
 800e254:	b5b0      	push	{r4, r5, r7, lr}
 800e256:	b094      	sub	sp, #80	; 0x50
 800e258:	af00      	add	r7, sp, #0
 800e25a:	6078      	str	r0, [r7, #4]
  s16_t m;
  u32_t right_wnd_edge;
  int found_dupack = 0;
 800e25c:	2300      	movs	r3, #0
 800e25e:	64bb      	str	r3, [r7, #72]	; 0x48

  LWIP_ASSERT("tcp_receive: invalid pcb", pcb != NULL);
 800e260:	687b      	ldr	r3, [r7, #4]
 800e262:	2b00      	cmp	r3, #0
 800e264:	d105      	bne.n	800e272 <tcp_receive+0x1e>
 800e266:	4bba      	ldr	r3, [pc, #744]	; (800e550 <tcp_receive+0x2fc>)
 800e268:	4aba      	ldr	r2, [pc, #744]	; (800e554 <tcp_receive+0x300>)
 800e26a:	49bb      	ldr	r1, [pc, #748]	; (800e558 <tcp_receive+0x304>)
 800e26c:	48bb      	ldr	r0, [pc, #748]	; (800e55c <tcp_receive+0x308>)
 800e26e:	f7f4 fcab 	bl	8002bc8 <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 800e272:	687b      	ldr	r3, [r7, #4]
 800e274:	7e1b      	ldrb	r3, [r3, #24]
 800e276:	2b03      	cmp	r3, #3
 800e278:	d805      	bhi.n	800e286 <tcp_receive+0x32>
 800e27a:	4bb5      	ldr	r3, [pc, #724]	; (800e550 <tcp_receive+0x2fc>)
 800e27c:	4ab8      	ldr	r2, [pc, #736]	; (800e560 <tcp_receive+0x30c>)
 800e27e:	49b9      	ldr	r1, [pc, #740]	; (800e564 <tcp_receive+0x310>)
 800e280:	48b6      	ldr	r0, [pc, #728]	; (800e55c <tcp_receive+0x308>)
 800e282:	f7f4 fca1 	bl	8002bc8 <app_debug_rtt_raw>

  if (flags & TCP_ACK) {
 800e286:	4bb8      	ldr	r3, [pc, #736]	; (800e568 <tcp_receive+0x314>)
 800e288:	781b      	ldrb	r3, [r3, #0]
 800e28a:	001a      	movs	r2, r3
 800e28c:	2310      	movs	r3, #16
 800e28e:	4013      	ands	r3, r2
 800e290:	d100      	bne.n	800e294 <tcp_receive+0x40>
 800e292:	e294      	b.n	800e7be <tcp_receive+0x56a>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 800e294:	687b      	ldr	r3, [r7, #4]
 800e296:	2264      	movs	r2, #100	; 0x64
 800e298:	5a9b      	ldrh	r3, [r3, r2]
 800e29a:	001a      	movs	r2, r3
 800e29c:	687b      	ldr	r3, [r7, #4]
 800e29e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800e2a0:	18d3      	adds	r3, r2, r3
 800e2a2:	633b      	str	r3, [r7, #48]	; 0x30

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 800e2a4:	687b      	ldr	r3, [r7, #4]
 800e2a6:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800e2a8:	4bb0      	ldr	r3, [pc, #704]	; (800e56c <tcp_receive+0x318>)
 800e2aa:	681b      	ldr	r3, [r3, #0]
 800e2ac:	1ad3      	subs	r3, r2, r3
 800e2ae:	d41d      	bmi.n	800e2ec <tcp_receive+0x98>
        (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 800e2b0:	687b      	ldr	r3, [r7, #4]
 800e2b2:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800e2b4:	4bad      	ldr	r3, [pc, #692]	; (800e56c <tcp_receive+0x318>)
 800e2b6:	681b      	ldr	r3, [r3, #0]
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 800e2b8:	429a      	cmp	r2, r3
 800e2ba:	d105      	bne.n	800e2c8 <tcp_receive+0x74>
        (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 800e2bc:	687b      	ldr	r3, [r7, #4]
 800e2be:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 800e2c0:	4bab      	ldr	r3, [pc, #684]	; (800e570 <tcp_receive+0x31c>)
 800e2c2:	681b      	ldr	r3, [r3, #0]
 800e2c4:	1ad3      	subs	r3, r2, r3
 800e2c6:	d411      	bmi.n	800e2ec <tcp_receive+0x98>
        (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
 800e2c8:	687b      	ldr	r3, [r7, #4]
 800e2ca:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 800e2cc:	4ba8      	ldr	r3, [pc, #672]	; (800e570 <tcp_receive+0x31c>)
 800e2ce:	681b      	ldr	r3, [r3, #0]
        (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 800e2d0:	429a      	cmp	r2, r3
 800e2d2:	d12b      	bne.n	800e32c <tcp_receive+0xd8>
        (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
 800e2d4:	4ba7      	ldr	r3, [pc, #668]	; (800e574 <tcp_receive+0x320>)
 800e2d6:	681b      	ldr	r3, [r3, #0]
 800e2d8:	7b9a      	ldrb	r2, [r3, #14]
 800e2da:	7bdb      	ldrb	r3, [r3, #15]
 800e2dc:	021b      	lsls	r3, r3, #8
 800e2de:	4313      	orrs	r3, r2
 800e2e0:	b29a      	uxth	r2, r3
 800e2e2:	687b      	ldr	r3, [r7, #4]
 800e2e4:	2164      	movs	r1, #100	; 0x64
 800e2e6:	5a5b      	ldrh	r3, [r3, r1]
 800e2e8:	429a      	cmp	r2, r3
 800e2ea:	d91f      	bls.n	800e32c <tcp_receive+0xd8>
      pcb->snd_wnd = SND_WND_SCALE(pcb, tcphdr->wnd);
 800e2ec:	4ba1      	ldr	r3, [pc, #644]	; (800e574 <tcp_receive+0x320>)
 800e2ee:	681b      	ldr	r3, [r3, #0]
 800e2f0:	7b9a      	ldrb	r2, [r3, #14]
 800e2f2:	7bdb      	ldrb	r3, [r3, #15]
 800e2f4:	021b      	lsls	r3, r3, #8
 800e2f6:	4313      	orrs	r3, r2
 800e2f8:	b299      	uxth	r1, r3
 800e2fa:	687b      	ldr	r3, [r7, #4]
 800e2fc:	2264      	movs	r2, #100	; 0x64
 800e2fe:	5299      	strh	r1, [r3, r2]
      /* keep track of the biggest window announced by the remote host to calculate
         the maximum segment size */
      if (pcb->snd_wnd_max < pcb->snd_wnd) {
 800e300:	687b      	ldr	r3, [r7, #4]
 800e302:	2266      	movs	r2, #102	; 0x66
 800e304:	5a9a      	ldrh	r2, [r3, r2]
 800e306:	687b      	ldr	r3, [r7, #4]
 800e308:	2164      	movs	r1, #100	; 0x64
 800e30a:	5a5b      	ldrh	r3, [r3, r1]
 800e30c:	429a      	cmp	r2, r3
 800e30e:	d205      	bcs.n	800e31c <tcp_receive+0xc8>
        pcb->snd_wnd_max = pcb->snd_wnd;
 800e310:	687b      	ldr	r3, [r7, #4]
 800e312:	2264      	movs	r2, #100	; 0x64
 800e314:	5a99      	ldrh	r1, [r3, r2]
 800e316:	687b      	ldr	r3, [r7, #4]
 800e318:	2266      	movs	r2, #102	; 0x66
 800e31a:	5299      	strh	r1, [r3, r2]
      }
      pcb->snd_wl1 = seqno;
 800e31c:	4b93      	ldr	r3, [pc, #588]	; (800e56c <tcp_receive+0x318>)
 800e31e:	681a      	ldr	r2, [r3, #0]
 800e320:	687b      	ldr	r3, [r7, #4]
 800e322:	659a      	str	r2, [r3, #88]	; 0x58
      pcb->snd_wl2 = ackno;
 800e324:	4b92      	ldr	r3, [pc, #584]	; (800e570 <tcp_receive+0x31c>)
 800e326:	681a      	ldr	r2, [r3, #0]
 800e328:	687b      	ldr	r3, [r7, #4]
 800e32a:	65da      	str	r2, [r3, #92]	; 0x5c
     * If it only passes 1, should reset dupack counter
     *
     */

    /* Clause 1 */
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
 800e32c:	4b90      	ldr	r3, [pc, #576]	; (800e570 <tcp_receive+0x31c>)
 800e32e:	681a      	ldr	r2, [r3, #0]
 800e330:	687b      	ldr	r3, [r7, #4]
 800e332:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800e334:	1ad3      	subs	r3, r2, r3
 800e336:	2b00      	cmp	r3, #0
 800e338:	dc59      	bgt.n	800e3ee <tcp_receive+0x19a>
      /* Clause 2 */
      if (tcplen == 0) {
 800e33a:	4b8f      	ldr	r3, [pc, #572]	; (800e578 <tcp_receive+0x324>)
 800e33c:	881b      	ldrh	r3, [r3, #0]
 800e33e:	2b00      	cmp	r3, #0
 800e340:	d14c      	bne.n	800e3dc <tcp_receive+0x188>
        /* Clause 3 */
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge) {
 800e342:	687b      	ldr	r3, [r7, #4]
 800e344:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800e346:	687a      	ldr	r2, [r7, #4]
 800e348:	2164      	movs	r1, #100	; 0x64
 800e34a:	5a52      	ldrh	r2, [r2, r1]
 800e34c:	189b      	adds	r3, r3, r2
 800e34e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800e350:	429a      	cmp	r2, r3
 800e352:	d143      	bne.n	800e3dc <tcp_receive+0x188>
          /* Clause 4 */
          if (pcb->rtime >= 0) {
 800e354:	687b      	ldr	r3, [r7, #4]
 800e356:	2234      	movs	r2, #52	; 0x34
 800e358:	5e9b      	ldrsh	r3, [r3, r2]
 800e35a:	2b00      	cmp	r3, #0
 800e35c:	db3e      	blt.n	800e3dc <tcp_receive+0x188>
            /* Clause 5 */
            if (pcb->lastack == ackno) {
 800e35e:	687b      	ldr	r3, [r7, #4]
 800e360:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800e362:	4b83      	ldr	r3, [pc, #524]	; (800e570 <tcp_receive+0x31c>)
 800e364:	681b      	ldr	r3, [r3, #0]
 800e366:	429a      	cmp	r2, r3
 800e368:	d138      	bne.n	800e3dc <tcp_receive+0x188>
              found_dupack = 1;
 800e36a:	2301      	movs	r3, #1
 800e36c:	64bb      	str	r3, [r7, #72]	; 0x48
              if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
 800e36e:	687b      	ldr	r3, [r7, #4]
 800e370:	2247      	movs	r2, #71	; 0x47
 800e372:	5c9b      	ldrb	r3, [r3, r2]
 800e374:	2bff      	cmp	r3, #255	; 0xff
 800e376:	d007      	beq.n	800e388 <tcp_receive+0x134>
                ++pcb->dupacks;
 800e378:	687b      	ldr	r3, [r7, #4]
 800e37a:	2247      	movs	r2, #71	; 0x47
 800e37c:	5c9b      	ldrb	r3, [r3, r2]
 800e37e:	3301      	adds	r3, #1
 800e380:	b2d9      	uxtb	r1, r3
 800e382:	687b      	ldr	r3, [r7, #4]
 800e384:	2247      	movs	r2, #71	; 0x47
 800e386:	5499      	strb	r1, [r3, r2]
              }
              if (pcb->dupacks > 3) {
 800e388:	687b      	ldr	r3, [r7, #4]
 800e38a:	2247      	movs	r2, #71	; 0x47
 800e38c:	5c9b      	ldrb	r3, [r3, r2]
 800e38e:	2b03      	cmp	r3, #3
 800e390:	d91b      	bls.n	800e3ca <tcp_receive+0x176>
                /* Inflate the congestion window */
                TCP_WND_INC(pcb->cwnd, pcb->mss);
 800e392:	687b      	ldr	r3, [r7, #4]
 800e394:	224c      	movs	r2, #76	; 0x4c
 800e396:	5a9a      	ldrh	r2, [r3, r2]
 800e398:	687b      	ldr	r3, [r7, #4]
 800e39a:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800e39c:	18d3      	adds	r3, r2, r3
 800e39e:	b29a      	uxth	r2, r3
 800e3a0:	687b      	ldr	r3, [r7, #4]
 800e3a2:	214c      	movs	r1, #76	; 0x4c
 800e3a4:	5a5b      	ldrh	r3, [r3, r1]
 800e3a6:	429a      	cmp	r2, r3
 800e3a8:	d30a      	bcc.n	800e3c0 <tcp_receive+0x16c>
 800e3aa:	687b      	ldr	r3, [r7, #4]
 800e3ac:	224c      	movs	r2, #76	; 0x4c
 800e3ae:	5a9a      	ldrh	r2, [r3, r2]
 800e3b0:	687b      	ldr	r3, [r7, #4]
 800e3b2:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800e3b4:	18d3      	adds	r3, r2, r3
 800e3b6:	b299      	uxth	r1, r3
 800e3b8:	687b      	ldr	r3, [r7, #4]
 800e3ba:	224c      	movs	r2, #76	; 0x4c
 800e3bc:	5299      	strh	r1, [r3, r2]
 800e3be:	e004      	b.n	800e3ca <tcp_receive+0x176>
 800e3c0:	687b      	ldr	r3, [r7, #4]
 800e3c2:	224c      	movs	r2, #76	; 0x4c
 800e3c4:	2101      	movs	r1, #1
 800e3c6:	4249      	negs	r1, r1
 800e3c8:	5299      	strh	r1, [r3, r2]
              }
              if (pcb->dupacks >= 3) {
 800e3ca:	687b      	ldr	r3, [r7, #4]
 800e3cc:	2247      	movs	r2, #71	; 0x47
 800e3ce:	5c9b      	ldrb	r3, [r3, r2]
 800e3d0:	2b02      	cmp	r3, #2
 800e3d2:	d903      	bls.n	800e3dc <tcp_receive+0x188>
                /* Do fast retransmit (checked via TF_INFR, not via dupacks count) */
                tcp_rexmit_fast(pcb);
 800e3d4:	687b      	ldr	r3, [r7, #4]
 800e3d6:	0018      	movs	r0, r3
 800e3d8:	f003 fa7e 	bl	80118d8 <tcp_rexmit_fast>
          }
        }
      }
      /* If Clause (1) or more is true, but not a duplicate ack, reset
       * count of consecutive duplicate acks */
      if (!found_dupack) {
 800e3dc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800e3de:	2b00      	cmp	r3, #0
 800e3e0:	d000      	beq.n	800e3e4 <tcp_receive+0x190>
 800e3e2:	e188      	b.n	800e6f6 <tcp_receive+0x4a2>
        pcb->dupacks = 0;
 800e3e4:	687b      	ldr	r3, [r7, #4]
 800e3e6:	2247      	movs	r2, #71	; 0x47
 800e3e8:	2100      	movs	r1, #0
 800e3ea:	5499      	strb	r1, [r3, r2]
 800e3ec:	e183      	b.n	800e6f6 <tcp_receive+0x4a2>
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 800e3ee:	4b60      	ldr	r3, [pc, #384]	; (800e570 <tcp_receive+0x31c>)
 800e3f0:	681a      	ldr	r2, [r3, #0]
 800e3f2:	687b      	ldr	r3, [r7, #4]
 800e3f4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800e3f6:	1ad3      	subs	r3, r2, r3
 800e3f8:	3b01      	subs	r3, #1
 800e3fa:	2b00      	cmp	r3, #0
 800e3fc:	da00      	bge.n	800e400 <tcp_receive+0x1ac>
 800e3fe:	e174      	b.n	800e6ea <tcp_receive+0x496>
 800e400:	4b5b      	ldr	r3, [pc, #364]	; (800e570 <tcp_receive+0x31c>)
 800e402:	681a      	ldr	r2, [r3, #0]
 800e404:	687b      	ldr	r3, [r7, #4]
 800e406:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800e408:	1ad3      	subs	r3, r2, r3
 800e40a:	2b00      	cmp	r3, #0
 800e40c:	dd00      	ble.n	800e410 <tcp_receive+0x1bc>
 800e40e:	e16c      	b.n	800e6ea <tcp_receive+0x496>
      tcpwnd_size_t acked;

      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
 800e410:	687b      	ldr	r3, [r7, #4]
 800e412:	8bdb      	ldrh	r3, [r3, #30]
 800e414:	001a      	movs	r2, r3
 800e416:	2304      	movs	r3, #4
 800e418:	4013      	ands	r3, r2
 800e41a:	d010      	beq.n	800e43e <tcp_receive+0x1ea>
        tcp_clear_flags(pcb, TF_INFR);
 800e41c:	687b      	ldr	r3, [r7, #4]
 800e41e:	8bdb      	ldrh	r3, [r3, #30]
 800e420:	2204      	movs	r2, #4
 800e422:	4393      	bics	r3, r2
 800e424:	b29a      	uxth	r2, r3
 800e426:	687b      	ldr	r3, [r7, #4]
 800e428:	83da      	strh	r2, [r3, #30]
        pcb->cwnd = pcb->ssthresh;
 800e42a:	687b      	ldr	r3, [r7, #4]
 800e42c:	224e      	movs	r2, #78	; 0x4e
 800e42e:	5a99      	ldrh	r1, [r3, r2]
 800e430:	687b      	ldr	r3, [r7, #4]
 800e432:	224c      	movs	r2, #76	; 0x4c
 800e434:	5299      	strh	r1, [r3, r2]
        pcb->bytes_acked = 0;
 800e436:	687b      	ldr	r3, [r7, #4]
 800e438:	226e      	movs	r2, #110	; 0x6e
 800e43a:	2100      	movs	r1, #0
 800e43c:	5299      	strh	r1, [r3, r2]
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
 800e43e:	687b      	ldr	r3, [r7, #4]
 800e440:	2246      	movs	r2, #70	; 0x46
 800e442:	2100      	movs	r1, #0
 800e444:	5499      	strb	r1, [r3, r2]

      /* Reset the retransmission time-out. */
      pcb->rto = (s16_t)((pcb->sa >> 3) + pcb->sv);
 800e446:	687b      	ldr	r3, [r7, #4]
 800e448:	2240      	movs	r2, #64	; 0x40
 800e44a:	5e9b      	ldrsh	r3, [r3, r2]
 800e44c:	10db      	asrs	r3, r3, #3
 800e44e:	b21b      	sxth	r3, r3
 800e450:	b29a      	uxth	r2, r3
 800e452:	687b      	ldr	r3, [r7, #4]
 800e454:	2142      	movs	r1, #66	; 0x42
 800e456:	5e5b      	ldrsh	r3, [r3, r1]
 800e458:	b29b      	uxth	r3, r3
 800e45a:	18d3      	adds	r3, r2, r3
 800e45c:	b29b      	uxth	r3, r3
 800e45e:	b219      	sxth	r1, r3
 800e460:	687b      	ldr	r3, [r7, #4]
 800e462:	2244      	movs	r2, #68	; 0x44
 800e464:	5299      	strh	r1, [r3, r2]

      /* Record how much data this ACK acks */
      acked = (tcpwnd_size_t)(ackno - pcb->lastack);
 800e466:	4b42      	ldr	r3, [pc, #264]	; (800e570 <tcp_receive+0x31c>)
 800e468:	681b      	ldr	r3, [r3, #0]
 800e46a:	b299      	uxth	r1, r3
 800e46c:	687b      	ldr	r3, [r7, #4]
 800e46e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800e470:	b29a      	uxth	r2, r3
 800e472:	232e      	movs	r3, #46	; 0x2e
 800e474:	18fb      	adds	r3, r7, r3
 800e476:	1a8a      	subs	r2, r1, r2
 800e478:	801a      	strh	r2, [r3, #0]

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
 800e47a:	687b      	ldr	r3, [r7, #4]
 800e47c:	2247      	movs	r2, #71	; 0x47
 800e47e:	2100      	movs	r1, #0
 800e480:	5499      	strb	r1, [r3, r2]
      pcb->lastack = ackno;
 800e482:	4b3b      	ldr	r3, [pc, #236]	; (800e570 <tcp_receive+0x31c>)
 800e484:	681a      	ldr	r2, [r3, #0]
 800e486:	687b      	ldr	r3, [r7, #4]
 800e488:	649a      	str	r2, [r3, #72]	; 0x48

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
 800e48a:	687b      	ldr	r3, [r7, #4]
 800e48c:	7e1b      	ldrb	r3, [r3, #24]
 800e48e:	2b03      	cmp	r3, #3
 800e490:	d800      	bhi.n	800e494 <tcp_receive+0x240>
 800e492:	e0a7      	b.n	800e5e4 <tcp_receive+0x390>
        if (pcb->cwnd < pcb->ssthresh) {
 800e494:	687b      	ldr	r3, [r7, #4]
 800e496:	224c      	movs	r2, #76	; 0x4c
 800e498:	5a9a      	ldrh	r2, [r3, r2]
 800e49a:	687b      	ldr	r3, [r7, #4]
 800e49c:	214e      	movs	r1, #78	; 0x4e
 800e49e:	5a5b      	ldrh	r3, [r3, r1]
 800e4a0:	429a      	cmp	r2, r3
 800e4a2:	d23d      	bcs.n	800e520 <tcp_receive+0x2cc>
          tcpwnd_size_t increase;
          /* limit to 1 SMSS segment during period following RTO */
          u8_t num_seg = (pcb->flags & TF_RTO) ? 1 : 2;
 800e4a4:	687b      	ldr	r3, [r7, #4]
 800e4a6:	8bdb      	ldrh	r3, [r3, #30]
 800e4a8:	001a      	movs	r2, r3
 800e4aa:	2380      	movs	r3, #128	; 0x80
 800e4ac:	011b      	lsls	r3, r3, #4
 800e4ae:	4013      	ands	r3, r2
 800e4b0:	d001      	beq.n	800e4b6 <tcp_receive+0x262>
 800e4b2:	2201      	movs	r2, #1
 800e4b4:	e000      	b.n	800e4b8 <tcp_receive+0x264>
 800e4b6:	2202      	movs	r2, #2
 800e4b8:	212d      	movs	r1, #45	; 0x2d
 800e4ba:	187b      	adds	r3, r7, r1
 800e4bc:	701a      	strb	r2, [r3, #0]
          /* RFC 3465, section 2.2 Slow Start */
          increase = LWIP_MIN(acked, (tcpwnd_size_t)(num_seg * pcb->mss));
 800e4be:	187b      	adds	r3, r7, r1
 800e4c0:	781b      	ldrb	r3, [r3, #0]
 800e4c2:	b29b      	uxth	r3, r3
 800e4c4:	687a      	ldr	r2, [r7, #4]
 800e4c6:	8ed2      	ldrh	r2, [r2, #54]	; 0x36
 800e4c8:	4353      	muls	r3, r2
 800e4ca:	b299      	uxth	r1, r3
 800e4cc:	232a      	movs	r3, #42	; 0x2a
 800e4ce:	18fa      	adds	r2, r7, r3
 800e4d0:	232e      	movs	r3, #46	; 0x2e
 800e4d2:	18fb      	adds	r3, r7, r3
 800e4d4:	1c0c      	adds	r4, r1, #0
 800e4d6:	881b      	ldrh	r3, [r3, #0]
 800e4d8:	b298      	uxth	r0, r3
 800e4da:	b2a1      	uxth	r1, r4
 800e4dc:	4288      	cmp	r0, r1
 800e4de:	d900      	bls.n	800e4e2 <tcp_receive+0x28e>
 800e4e0:	1c23      	adds	r3, r4, #0
 800e4e2:	8013      	strh	r3, [r2, #0]
          TCP_WND_INC(pcb->cwnd, increase);
 800e4e4:	687b      	ldr	r3, [r7, #4]
 800e4e6:	224c      	movs	r2, #76	; 0x4c
 800e4e8:	5a9a      	ldrh	r2, [r3, r2]
 800e4ea:	202a      	movs	r0, #42	; 0x2a
 800e4ec:	183b      	adds	r3, r7, r0
 800e4ee:	881b      	ldrh	r3, [r3, #0]
 800e4f0:	18d3      	adds	r3, r2, r3
 800e4f2:	b29a      	uxth	r2, r3
 800e4f4:	687b      	ldr	r3, [r7, #4]
 800e4f6:	214c      	movs	r1, #76	; 0x4c
 800e4f8:	5a5b      	ldrh	r3, [r3, r1]
 800e4fa:	429a      	cmp	r2, r3
 800e4fc:	d30a      	bcc.n	800e514 <tcp_receive+0x2c0>
 800e4fe:	687b      	ldr	r3, [r7, #4]
 800e500:	224c      	movs	r2, #76	; 0x4c
 800e502:	5a9a      	ldrh	r2, [r3, r2]
 800e504:	183b      	adds	r3, r7, r0
 800e506:	881b      	ldrh	r3, [r3, #0]
 800e508:	18d3      	adds	r3, r2, r3
 800e50a:	b299      	uxth	r1, r3
 800e50c:	687b      	ldr	r3, [r7, #4]
 800e50e:	224c      	movs	r2, #76	; 0x4c
 800e510:	5299      	strh	r1, [r3, r2]
 800e512:	e067      	b.n	800e5e4 <tcp_receive+0x390>
 800e514:	687b      	ldr	r3, [r7, #4]
 800e516:	224c      	movs	r2, #76	; 0x4c
 800e518:	2101      	movs	r1, #1
 800e51a:	4249      	negs	r1, r1
 800e51c:	5299      	strh	r1, [r3, r2]
 800e51e:	e061      	b.n	800e5e4 <tcp_receive+0x390>
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"TCPWNDSIZE_F"\n", pcb->cwnd));
        } else {
          /* RFC 3465, section 2.1 Congestion Avoidance */
          TCP_WND_INC(pcb->bytes_acked, acked);
 800e520:	687b      	ldr	r3, [r7, #4]
 800e522:	226e      	movs	r2, #110	; 0x6e
 800e524:	5a9a      	ldrh	r2, [r3, r2]
 800e526:	202e      	movs	r0, #46	; 0x2e
 800e528:	183b      	adds	r3, r7, r0
 800e52a:	881b      	ldrh	r3, [r3, #0]
 800e52c:	18d3      	adds	r3, r2, r3
 800e52e:	b29a      	uxth	r2, r3
 800e530:	687b      	ldr	r3, [r7, #4]
 800e532:	216e      	movs	r1, #110	; 0x6e
 800e534:	5a5b      	ldrh	r3, [r3, r1]
 800e536:	429a      	cmp	r2, r3
 800e538:	d320      	bcc.n	800e57c <tcp_receive+0x328>
 800e53a:	687b      	ldr	r3, [r7, #4]
 800e53c:	226e      	movs	r2, #110	; 0x6e
 800e53e:	5a9a      	ldrh	r2, [r3, r2]
 800e540:	183b      	adds	r3, r7, r0
 800e542:	881b      	ldrh	r3, [r3, #0]
 800e544:	18d3      	adds	r3, r2, r3
 800e546:	b299      	uxth	r1, r3
 800e548:	687b      	ldr	r3, [r7, #4]
 800e54a:	226e      	movs	r2, #110	; 0x6e
 800e54c:	5299      	strh	r1, [r3, r2]
 800e54e:	e01a      	b.n	800e586 <tcp_receive+0x332>
 800e550:	080205bc 	.word	0x080205bc
 800e554:	0000047c 	.word	0x0000047c
 800e558:	080208e4 	.word	0x080208e4
 800e55c:	080205fc 	.word	0x080205fc
 800e560:	0000047d 	.word	0x0000047d
 800e564:	08020900 	.word	0x08020900
 800e568:	200017c4 	.word	0x200017c4
 800e56c:	200017b8 	.word	0x200017b8
 800e570:	200017bc 	.word	0x200017bc
 800e574:	200017a8 	.word	0x200017a8
 800e578:	200017c2 	.word	0x200017c2
 800e57c:	687b      	ldr	r3, [r7, #4]
 800e57e:	226e      	movs	r2, #110	; 0x6e
 800e580:	2101      	movs	r1, #1
 800e582:	4249      	negs	r1, r1
 800e584:	5299      	strh	r1, [r3, r2]
          if (pcb->bytes_acked >= pcb->cwnd) {
 800e586:	687b      	ldr	r3, [r7, #4]
 800e588:	226e      	movs	r2, #110	; 0x6e
 800e58a:	5a9a      	ldrh	r2, [r3, r2]
 800e58c:	687b      	ldr	r3, [r7, #4]
 800e58e:	214c      	movs	r1, #76	; 0x4c
 800e590:	5a5b      	ldrh	r3, [r3, r1]
 800e592:	429a      	cmp	r2, r3
 800e594:	d326      	bcc.n	800e5e4 <tcp_receive+0x390>
            pcb->bytes_acked = (tcpwnd_size_t)(pcb->bytes_acked - pcb->cwnd);
 800e596:	687b      	ldr	r3, [r7, #4]
 800e598:	226e      	movs	r2, #110	; 0x6e
 800e59a:	5a9a      	ldrh	r2, [r3, r2]
 800e59c:	687b      	ldr	r3, [r7, #4]
 800e59e:	214c      	movs	r1, #76	; 0x4c
 800e5a0:	5a5b      	ldrh	r3, [r3, r1]
 800e5a2:	1ad3      	subs	r3, r2, r3
 800e5a4:	b299      	uxth	r1, r3
 800e5a6:	687b      	ldr	r3, [r7, #4]
 800e5a8:	226e      	movs	r2, #110	; 0x6e
 800e5aa:	5299      	strh	r1, [r3, r2]
            TCP_WND_INC(pcb->cwnd, pcb->mss);
 800e5ac:	687b      	ldr	r3, [r7, #4]
 800e5ae:	224c      	movs	r2, #76	; 0x4c
 800e5b0:	5a9a      	ldrh	r2, [r3, r2]
 800e5b2:	687b      	ldr	r3, [r7, #4]
 800e5b4:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800e5b6:	18d3      	adds	r3, r2, r3
 800e5b8:	b29a      	uxth	r2, r3
 800e5ba:	687b      	ldr	r3, [r7, #4]
 800e5bc:	214c      	movs	r1, #76	; 0x4c
 800e5be:	5a5b      	ldrh	r3, [r3, r1]
 800e5c0:	429a      	cmp	r2, r3
 800e5c2:	d30a      	bcc.n	800e5da <tcp_receive+0x386>
 800e5c4:	687b      	ldr	r3, [r7, #4]
 800e5c6:	224c      	movs	r2, #76	; 0x4c
 800e5c8:	5a9a      	ldrh	r2, [r3, r2]
 800e5ca:	687b      	ldr	r3, [r7, #4]
 800e5cc:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800e5ce:	18d3      	adds	r3, r2, r3
 800e5d0:	b299      	uxth	r1, r3
 800e5d2:	687b      	ldr	r3, [r7, #4]
 800e5d4:	224c      	movs	r2, #76	; 0x4c
 800e5d6:	5299      	strh	r1, [r3, r2]
 800e5d8:	e004      	b.n	800e5e4 <tcp_receive+0x390>
 800e5da:	687b      	ldr	r3, [r7, #4]
 800e5dc:	224c      	movs	r2, #76	; 0x4c
 800e5de:	2101      	movs	r1, #1
 800e5e0:	4249      	negs	r1, r1
 800e5e2:	5299      	strh	r1, [r3, r2]
                                    pcb->unacked != NULL ?
                                    lwip_ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked) : 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowledges them. */
      pcb->unacked = tcp_free_acked_segments(pcb, pcb->unacked, "unacked", pcb->unsent);
 800e5e4:	687b      	ldr	r3, [r7, #4]
 800e5e6:	6f59      	ldr	r1, [r3, #116]	; 0x74
 800e5e8:	687b      	ldr	r3, [r7, #4]
 800e5ea:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800e5ec:	4acf      	ldr	r2, [pc, #828]	; (800e92c <tcp_receive+0x6d8>)
 800e5ee:	6878      	ldr	r0, [r7, #4]
 800e5f0:	f7ff fda0 	bl	800e134 <tcp_free_acked_segments>
 800e5f4:	0002      	movs	r2, r0
 800e5f6:	687b      	ldr	r3, [r7, #4]
 800e5f8:	675a      	str	r2, [r3, #116]	; 0x74
         on the list are acknowledged by the ACK. This may seem
         strange since an "unsent" segment shouldn't be acked. The
         rationale is that lwIP puts all outstanding segments on the
         ->unsent list after a retransmission, so these segments may
         in fact have been sent once. */
      pcb->unsent = tcp_free_acked_segments(pcb, pcb->unsent, "unsent", pcb->unacked);
 800e5fa:	687b      	ldr	r3, [r7, #4]
 800e5fc:	6f19      	ldr	r1, [r3, #112]	; 0x70
 800e5fe:	687b      	ldr	r3, [r7, #4]
 800e600:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800e602:	4acb      	ldr	r2, [pc, #812]	; (800e930 <tcp_receive+0x6dc>)
 800e604:	6878      	ldr	r0, [r7, #4]
 800e606:	f7ff fd95 	bl	800e134 <tcp_free_acked_segments>
 800e60a:	0002      	movs	r2, r0
 800e60c:	687b      	ldr	r3, [r7, #4]
 800e60e:	671a      	str	r2, [r3, #112]	; 0x70

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if (pcb->unacked == NULL) {
 800e610:	687b      	ldr	r3, [r7, #4]
 800e612:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800e614:	2b00      	cmp	r3, #0
 800e616:	d104      	bne.n	800e622 <tcp_receive+0x3ce>
        pcb->rtime = -1;
 800e618:	687b      	ldr	r3, [r7, #4]
 800e61a:	2201      	movs	r2, #1
 800e61c:	4252      	negs	r2, r2
 800e61e:	869a      	strh	r2, [r3, #52]	; 0x34
 800e620:	e002      	b.n	800e628 <tcp_receive+0x3d4>
      } else {
        pcb->rtime = 0;
 800e622:	687b      	ldr	r3, [r7, #4]
 800e624:	2200      	movs	r2, #0
 800e626:	869a      	strh	r2, [r3, #52]	; 0x34
      }

      pcb->polltmr = 0;
 800e628:	687b      	ldr	r3, [r7, #4]
 800e62a:	2220      	movs	r2, #32
 800e62c:	2100      	movs	r1, #0
 800e62e:	5499      	strb	r1, [r3, r2]

#if TCP_OVERSIZE
      if (pcb->unsent == NULL) {
 800e630:	687b      	ldr	r3, [r7, #4]
 800e632:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800e634:	2b00      	cmp	r3, #0
 800e636:	d103      	bne.n	800e640 <tcp_receive+0x3ec>
        pcb->unsent_oversize = 0;
 800e638:	687b      	ldr	r3, [r7, #4]
 800e63a:	226c      	movs	r2, #108	; 0x6c
 800e63c:	2100      	movs	r1, #0
 800e63e:	5299      	strh	r1, [r3, r2]
        /* Inform neighbor reachability of forward progress. */
        nd6_reachability_hint(ip6_current_src_addr());
      }
#endif /* LWIP_IPV6 && LWIP_ND6_TCP_REACHABILITY_HINTS*/

      pcb->snd_buf = (tcpwnd_size_t)(pcb->snd_buf + recv_acked);
 800e640:	687b      	ldr	r3, [r7, #4]
 800e642:	2268      	movs	r2, #104	; 0x68
 800e644:	5a9a      	ldrh	r2, [r3, r2]
 800e646:	4bbb      	ldr	r3, [pc, #748]	; (800e934 <tcp_receive+0x6e0>)
 800e648:	881b      	ldrh	r3, [r3, #0]
 800e64a:	18d3      	adds	r3, r2, r3
 800e64c:	b299      	uxth	r1, r3
 800e64e:	687b      	ldr	r3, [r7, #4]
 800e650:	2268      	movs	r2, #104	; 0x68
 800e652:	5299      	strh	r1, [r3, r2]
      /* check if this ACK ends our retransmission of in-flight data */
      if (pcb->flags & TF_RTO) {
 800e654:	687b      	ldr	r3, [r7, #4]
 800e656:	8bdb      	ldrh	r3, [r3, #30]
 800e658:	001a      	movs	r2, r3
 800e65a:	2380      	movs	r3, #128	; 0x80
 800e65c:	011b      	lsls	r3, r3, #4
 800e65e:	4013      	ands	r3, r2
 800e660:	d048      	beq.n	800e6f4 <tcp_receive+0x4a0>
        /* RTO is done if
            1) both queues are empty or
            2) unacked is empty and unsent head contains data not part of RTO or
            3) unacked head contains data not part of RTO */
        if (pcb->unacked == NULL) {
 800e662:	687b      	ldr	r3, [r7, #4]
 800e664:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800e666:	2b00      	cmp	r3, #0
 800e668:	d121      	bne.n	800e6ae <tcp_receive+0x45a>
          if ((pcb->unsent == NULL) ||
 800e66a:	687b      	ldr	r3, [r7, #4]
 800e66c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800e66e:	2b00      	cmp	r3, #0
 800e670:	d015      	beq.n	800e69e <tcp_receive+0x44a>
              (TCP_SEQ_LEQ(pcb->rto_end, lwip_ntohl(pcb->unsent->tcphdr->seqno)))) {
 800e672:	687b      	ldr	r3, [r7, #4]
 800e674:	6d1c      	ldr	r4, [r3, #80]	; 0x50
 800e676:	687b      	ldr	r3, [r7, #4]
 800e678:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800e67a:	691b      	ldr	r3, [r3, #16]
 800e67c:	791a      	ldrb	r2, [r3, #4]
 800e67e:	7959      	ldrb	r1, [r3, #5]
 800e680:	0209      	lsls	r1, r1, #8
 800e682:	430a      	orrs	r2, r1
 800e684:	7999      	ldrb	r1, [r3, #6]
 800e686:	0409      	lsls	r1, r1, #16
 800e688:	430a      	orrs	r2, r1
 800e68a:	79db      	ldrb	r3, [r3, #7]
 800e68c:	061b      	lsls	r3, r3, #24
 800e68e:	4313      	orrs	r3, r2
 800e690:	0018      	movs	r0, r3
 800e692:	f7f8 fc45 	bl	8006f20 <lwip_htonl>
 800e696:	0003      	movs	r3, r0
 800e698:	1ae3      	subs	r3, r4, r3
          if ((pcb->unsent == NULL) ||
 800e69a:	2b00      	cmp	r3, #0
 800e69c:	dc2a      	bgt.n	800e6f4 <tcp_receive+0x4a0>
            tcp_clear_flags(pcb, TF_RTO);
 800e69e:	687b      	ldr	r3, [r7, #4]
 800e6a0:	8bdb      	ldrh	r3, [r3, #30]
 800e6a2:	4aa5      	ldr	r2, [pc, #660]	; (800e938 <tcp_receive+0x6e4>)
 800e6a4:	4013      	ands	r3, r2
 800e6a6:	b29a      	uxth	r2, r3
 800e6a8:	687b      	ldr	r3, [r7, #4]
 800e6aa:	83da      	strh	r2, [r3, #30]
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 800e6ac:	e022      	b.n	800e6f4 <tcp_receive+0x4a0>
          }
        } else if (TCP_SEQ_LEQ(pcb->rto_end, lwip_ntohl(pcb->unacked->tcphdr->seqno))) {
 800e6ae:	687b      	ldr	r3, [r7, #4]
 800e6b0:	6d1c      	ldr	r4, [r3, #80]	; 0x50
 800e6b2:	687b      	ldr	r3, [r7, #4]
 800e6b4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800e6b6:	691b      	ldr	r3, [r3, #16]
 800e6b8:	791a      	ldrb	r2, [r3, #4]
 800e6ba:	7959      	ldrb	r1, [r3, #5]
 800e6bc:	0209      	lsls	r1, r1, #8
 800e6be:	430a      	orrs	r2, r1
 800e6c0:	7999      	ldrb	r1, [r3, #6]
 800e6c2:	0409      	lsls	r1, r1, #16
 800e6c4:	430a      	orrs	r2, r1
 800e6c6:	79db      	ldrb	r3, [r3, #7]
 800e6c8:	061b      	lsls	r3, r3, #24
 800e6ca:	4313      	orrs	r3, r2
 800e6cc:	0018      	movs	r0, r3
 800e6ce:	f7f8 fc27 	bl	8006f20 <lwip_htonl>
 800e6d2:	0003      	movs	r3, r0
 800e6d4:	1ae3      	subs	r3, r4, r3
 800e6d6:	2b00      	cmp	r3, #0
 800e6d8:	dc0c      	bgt.n	800e6f4 <tcp_receive+0x4a0>
          tcp_clear_flags(pcb, TF_RTO);
 800e6da:	687b      	ldr	r3, [r7, #4]
 800e6dc:	8bdb      	ldrh	r3, [r3, #30]
 800e6de:	4a96      	ldr	r2, [pc, #600]	; (800e938 <tcp_receive+0x6e4>)
 800e6e0:	4013      	ands	r3, r2
 800e6e2:	b29a      	uxth	r2, r3
 800e6e4:	687b      	ldr	r3, [r7, #4]
 800e6e6:	83da      	strh	r2, [r3, #30]
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 800e6e8:	e004      	b.n	800e6f4 <tcp_receive+0x4a0>
        }
      }
      /* End of ACK for new data processing. */
    } else {
      /* Out of sequence ACK, didn't really ack anything */
      tcp_send_empty_ack(pcb);
 800e6ea:	687b      	ldr	r3, [r7, #4]
 800e6ec:	0018      	movs	r0, r3
 800e6ee:	f003 fbf9 	bl	8011ee4 <tcp_send_empty_ack>
 800e6f2:	e000      	b.n	800e6f6 <tcp_receive+0x4a2>
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 800e6f4:	46c0      	nop			; (mov r8, r8)
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
 800e6f6:	687b      	ldr	r3, [r7, #4]
 800e6f8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800e6fa:	2b00      	cmp	r3, #0
 800e6fc:	d05f      	beq.n	800e7be <tcp_receive+0x56a>
 800e6fe:	687b      	ldr	r3, [r7, #4]
 800e700:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800e702:	4b8e      	ldr	r3, [pc, #568]	; (800e93c <tcp_receive+0x6e8>)
 800e704:	681b      	ldr	r3, [r3, #0]
 800e706:	1ad3      	subs	r3, r2, r3
 800e708:	d559      	bpl.n	800e7be <tcp_receive+0x56a>
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
 800e70a:	4b8d      	ldr	r3, [pc, #564]	; (800e940 <tcp_receive+0x6ec>)
 800e70c:	681b      	ldr	r3, [r3, #0]
 800e70e:	b29a      	uxth	r2, r3
 800e710:	687b      	ldr	r3, [r7, #4]
 800e712:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800e714:	b29b      	uxth	r3, r3
 800e716:	1ad3      	subs	r3, r2, r3
 800e718:	b29a      	uxth	r2, r3
 800e71a:	204e      	movs	r0, #78	; 0x4e
 800e71c:	183b      	adds	r3, r7, r0
 800e71e:	801a      	strh	r2, [r3, #0]

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, (u16_t)(m * TCP_SLOW_INTERVAL)));

      /* This is taken directly from VJs original code in his paper */
      m = (s16_t)(m - (pcb->sa >> 3));
 800e720:	183b      	adds	r3, r7, r0
 800e722:	881a      	ldrh	r2, [r3, #0]
 800e724:	687b      	ldr	r3, [r7, #4]
 800e726:	2140      	movs	r1, #64	; 0x40
 800e728:	5e5b      	ldrsh	r3, [r3, r1]
 800e72a:	10db      	asrs	r3, r3, #3
 800e72c:	b21b      	sxth	r3, r3
 800e72e:	b29b      	uxth	r3, r3
 800e730:	1ad3      	subs	r3, r2, r3
 800e732:	b29a      	uxth	r2, r3
 800e734:	183b      	adds	r3, r7, r0
 800e736:	801a      	strh	r2, [r3, #0]
      pcb->sa = (s16_t)(pcb->sa + m);
 800e738:	687b      	ldr	r3, [r7, #4]
 800e73a:	2240      	movs	r2, #64	; 0x40
 800e73c:	5e9b      	ldrsh	r3, [r3, r2]
 800e73e:	b29a      	uxth	r2, r3
 800e740:	183b      	adds	r3, r7, r0
 800e742:	881b      	ldrh	r3, [r3, #0]
 800e744:	18d3      	adds	r3, r2, r3
 800e746:	b29b      	uxth	r3, r3
 800e748:	b219      	sxth	r1, r3
 800e74a:	687b      	ldr	r3, [r7, #4]
 800e74c:	2240      	movs	r2, #64	; 0x40
 800e74e:	5299      	strh	r1, [r3, r2]
      if (m < 0) {
 800e750:	183b      	adds	r3, r7, r0
 800e752:	2200      	movs	r2, #0
 800e754:	5e9b      	ldrsh	r3, [r3, r2]
 800e756:	2b00      	cmp	r3, #0
 800e758:	da05      	bge.n	800e766 <tcp_receive+0x512>
        m = (s16_t) - m;
 800e75a:	183b      	adds	r3, r7, r0
 800e75c:	881b      	ldrh	r3, [r3, #0]
 800e75e:	425b      	negs	r3, r3
 800e760:	b29a      	uxth	r2, r3
 800e762:	183b      	adds	r3, r7, r0
 800e764:	801a      	strh	r2, [r3, #0]
      }
      m = (s16_t)(m - (pcb->sv >> 2));
 800e766:	204e      	movs	r0, #78	; 0x4e
 800e768:	183b      	adds	r3, r7, r0
 800e76a:	881a      	ldrh	r2, [r3, #0]
 800e76c:	687b      	ldr	r3, [r7, #4]
 800e76e:	2142      	movs	r1, #66	; 0x42
 800e770:	5e5b      	ldrsh	r3, [r3, r1]
 800e772:	109b      	asrs	r3, r3, #2
 800e774:	b21b      	sxth	r3, r3
 800e776:	b29b      	uxth	r3, r3
 800e778:	1ad3      	subs	r3, r2, r3
 800e77a:	b29a      	uxth	r2, r3
 800e77c:	183b      	adds	r3, r7, r0
 800e77e:	801a      	strh	r2, [r3, #0]
      pcb->sv = (s16_t)(pcb->sv + m);
 800e780:	687b      	ldr	r3, [r7, #4]
 800e782:	2242      	movs	r2, #66	; 0x42
 800e784:	5e9b      	ldrsh	r3, [r3, r2]
 800e786:	b29a      	uxth	r2, r3
 800e788:	183b      	adds	r3, r7, r0
 800e78a:	881b      	ldrh	r3, [r3, #0]
 800e78c:	18d3      	adds	r3, r2, r3
 800e78e:	b29b      	uxth	r3, r3
 800e790:	b219      	sxth	r1, r3
 800e792:	687b      	ldr	r3, [r7, #4]
 800e794:	2242      	movs	r2, #66	; 0x42
 800e796:	5299      	strh	r1, [r3, r2]
      pcb->rto = (s16_t)((pcb->sa >> 3) + pcb->sv);
 800e798:	687b      	ldr	r3, [r7, #4]
 800e79a:	2240      	movs	r2, #64	; 0x40
 800e79c:	5e9b      	ldrsh	r3, [r3, r2]
 800e79e:	10db      	asrs	r3, r3, #3
 800e7a0:	b21b      	sxth	r3, r3
 800e7a2:	b29a      	uxth	r2, r3
 800e7a4:	687b      	ldr	r3, [r7, #4]
 800e7a6:	2142      	movs	r1, #66	; 0x42
 800e7a8:	5e5b      	ldrsh	r3, [r3, r1]
 800e7aa:	b29b      	uxth	r3, r3
 800e7ac:	18d3      	adds	r3, r2, r3
 800e7ae:	b29b      	uxth	r3, r3
 800e7b0:	b219      	sxth	r1, r3
 800e7b2:	687b      	ldr	r3, [r7, #4]
 800e7b4:	2244      	movs	r2, #68	; 0x44
 800e7b6:	5299      	strh	r1, [r3, r2]

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, (u16_t)(pcb->rto * TCP_SLOW_INTERVAL)));

      pcb->rttest = 0;
 800e7b8:	687b      	ldr	r3, [r7, #4]
 800e7ba:	2200      	movs	r2, #0
 800e7bc:	639a      	str	r2, [r3, #56]	; 0x38

  /* If the incoming segment contains data, we must process it
     further unless the pcb already received a FIN.
     (RFC 793, chapter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
     LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
  if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
 800e7be:	4b61      	ldr	r3, [pc, #388]	; (800e944 <tcp_receive+0x6f0>)
 800e7c0:	881b      	ldrh	r3, [r3, #0]
 800e7c2:	2b00      	cmp	r3, #0
 800e7c4:	d101      	bne.n	800e7ca <tcp_receive+0x576>
 800e7c6:	f000 fe3b 	bl	800f440 <tcp_receive+0x11ec>
 800e7ca:	687b      	ldr	r3, [r7, #4]
 800e7cc:	7e1b      	ldrb	r3, [r3, #24]
 800e7ce:	2b06      	cmp	r3, #6
 800e7d0:	d901      	bls.n	800e7d6 <tcp_receive+0x582>
 800e7d2:	f000 fe35 	bl	800f440 <tcp_receive+0x11ec>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
 800e7d6:	687b      	ldr	r3, [r7, #4]
 800e7d8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800e7da:	4b5b      	ldr	r3, [pc, #364]	; (800e948 <tcp_receive+0x6f4>)
 800e7dc:	681b      	ldr	r3, [r3, #0]
 800e7de:	1ad3      	subs	r3, r2, r3
 800e7e0:	3b01      	subs	r3, #1
 800e7e2:	2b00      	cmp	r3, #0
 800e7e4:	da00      	bge.n	800e7e8 <tcp_receive+0x594>
 800e7e6:	e0c3      	b.n	800e970 <tcp_receive+0x71c>
 800e7e8:	687b      	ldr	r3, [r7, #4]
 800e7ea:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800e7ec:	4b55      	ldr	r3, [pc, #340]	; (800e944 <tcp_receive+0x6f0>)
 800e7ee:	881b      	ldrh	r3, [r3, #0]
 800e7f0:	0019      	movs	r1, r3
 800e7f2:	4b55      	ldr	r3, [pc, #340]	; (800e948 <tcp_receive+0x6f4>)
 800e7f4:	681b      	ldr	r3, [r3, #0]
 800e7f6:	18cb      	adds	r3, r1, r3
 800e7f8:	1ad3      	subs	r3, r2, r3
 800e7fa:	3301      	adds	r3, #1
 800e7fc:	2b00      	cmp	r3, #0
 800e7fe:	dd00      	ble.n	800e802 <tcp_receive+0x5ae>
 800e800:	e0b6      	b.n	800e970 <tcp_receive+0x71c>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      struct pbuf *p = inseg.p;
 800e802:	4b52      	ldr	r3, [pc, #328]	; (800e94c <tcp_receive+0x6f8>)
 800e804:	685b      	ldr	r3, [r3, #4]
 800e806:	647b      	str	r3, [r7, #68]	; 0x44
      u32_t off32 = pcb->rcv_nxt - seqno;
 800e808:	687b      	ldr	r3, [r7, #4]
 800e80a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800e80c:	4b4e      	ldr	r3, [pc, #312]	; (800e948 <tcp_receive+0x6f4>)
 800e80e:	681b      	ldr	r3, [r3, #0]
 800e810:	1ad3      	subs	r3, r2, r3
 800e812:	627b      	str	r3, [r7, #36]	; 0x24
      u16_t new_tot_len, off;
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
 800e814:	4b4d      	ldr	r3, [pc, #308]	; (800e94c <tcp_receive+0x6f8>)
 800e816:	685b      	ldr	r3, [r3, #4]
 800e818:	2b00      	cmp	r3, #0
 800e81a:	d105      	bne.n	800e828 <tcp_receive+0x5d4>
 800e81c:	4b4c      	ldr	r3, [pc, #304]	; (800e950 <tcp_receive+0x6fc>)
 800e81e:	4a4d      	ldr	r2, [pc, #308]	; (800e954 <tcp_receive+0x700>)
 800e820:	494d      	ldr	r1, [pc, #308]	; (800e958 <tcp_receive+0x704>)
 800e822:	484e      	ldr	r0, [pc, #312]	; (800e95c <tcp_receive+0x708>)
 800e824:	f7f4 f9d0 	bl	8002bc8 <app_debug_rtt_raw>
      LWIP_ASSERT("insane offset!", (off32 < 0xffff));
 800e828:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e82a:	4a4d      	ldr	r2, [pc, #308]	; (800e960 <tcp_receive+0x70c>)
 800e82c:	4293      	cmp	r3, r2
 800e82e:	d905      	bls.n	800e83c <tcp_receive+0x5e8>
 800e830:	4b47      	ldr	r3, [pc, #284]	; (800e950 <tcp_receive+0x6fc>)
 800e832:	4a4c      	ldr	r2, [pc, #304]	; (800e964 <tcp_receive+0x710>)
 800e834:	494c      	ldr	r1, [pc, #304]	; (800e968 <tcp_receive+0x714>)
 800e836:	4849      	ldr	r0, [pc, #292]	; (800e95c <tcp_receive+0x708>)
 800e838:	f7f4 f9c6 	bl	8002bc8 <app_debug_rtt_raw>
      off = (u16_t)off32;
 800e83c:	2142      	movs	r1, #66	; 0x42
 800e83e:	187b      	adds	r3, r7, r1
 800e840:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800e842:	801a      	strh	r2, [r3, #0]
      LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
 800e844:	4b41      	ldr	r3, [pc, #260]	; (800e94c <tcp_receive+0x6f8>)
 800e846:	685b      	ldr	r3, [r3, #4]
 800e848:	891b      	ldrh	r3, [r3, #8]
 800e84a:	187a      	adds	r2, r7, r1
 800e84c:	8812      	ldrh	r2, [r2, #0]
 800e84e:	429a      	cmp	r2, r3
 800e850:	d906      	bls.n	800e860 <tcp_receive+0x60c>
 800e852:	4b3f      	ldr	r3, [pc, #252]	; (800e950 <tcp_receive+0x6fc>)
 800e854:	22b3      	movs	r2, #179	; 0xb3
 800e856:	00d2      	lsls	r2, r2, #3
 800e858:	4944      	ldr	r1, [pc, #272]	; (800e96c <tcp_receive+0x718>)
 800e85a:	4840      	ldr	r0, [pc, #256]	; (800e95c <tcp_receive+0x708>)
 800e85c:	f7f4 f9b4 	bl	8002bc8 <app_debug_rtt_raw>
      inseg.len -= off;
 800e860:	4b3a      	ldr	r3, [pc, #232]	; (800e94c <tcp_receive+0x6f8>)
 800e862:	891a      	ldrh	r2, [r3, #8]
 800e864:	2042      	movs	r0, #66	; 0x42
 800e866:	183b      	adds	r3, r7, r0
 800e868:	881b      	ldrh	r3, [r3, #0]
 800e86a:	1ad3      	subs	r3, r2, r3
 800e86c:	b29a      	uxth	r2, r3
 800e86e:	4b37      	ldr	r3, [pc, #220]	; (800e94c <tcp_receive+0x6f8>)
 800e870:	811a      	strh	r2, [r3, #8]
      new_tot_len = (u16_t)(inseg.p->tot_len - off);
 800e872:	4b36      	ldr	r3, [pc, #216]	; (800e94c <tcp_receive+0x6f8>)
 800e874:	685b      	ldr	r3, [r3, #4]
 800e876:	8919      	ldrh	r1, [r3, #8]
 800e878:	2322      	movs	r3, #34	; 0x22
 800e87a:	18fb      	adds	r3, r7, r3
 800e87c:	183a      	adds	r2, r7, r0
 800e87e:	8812      	ldrh	r2, [r2, #0]
 800e880:	1a8a      	subs	r2, r1, r2
 800e882:	801a      	strh	r2, [r3, #0]
      while (p->len < off) {
 800e884:	e012      	b.n	800e8ac <tcp_receive+0x658>
        off -= p->len;
 800e886:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e888:	895a      	ldrh	r2, [r3, #10]
 800e88a:	2142      	movs	r1, #66	; 0x42
 800e88c:	187b      	adds	r3, r7, r1
 800e88e:	1879      	adds	r1, r7, r1
 800e890:	8809      	ldrh	r1, [r1, #0]
 800e892:	1a8a      	subs	r2, r1, r2
 800e894:	801a      	strh	r2, [r3, #0]
        /* all pbufs up to and including this one have len==0, so tot_len is equal */
        p->tot_len = new_tot_len;
 800e896:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e898:	2222      	movs	r2, #34	; 0x22
 800e89a:	18ba      	adds	r2, r7, r2
 800e89c:	8812      	ldrh	r2, [r2, #0]
 800e89e:	811a      	strh	r2, [r3, #8]
        p->len = 0;
 800e8a0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e8a2:	2200      	movs	r2, #0
 800e8a4:	815a      	strh	r2, [r3, #10]
        p = p->next;
 800e8a6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e8a8:	681b      	ldr	r3, [r3, #0]
 800e8aa:	647b      	str	r3, [r7, #68]	; 0x44
      while (p->len < off) {
 800e8ac:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e8ae:	895b      	ldrh	r3, [r3, #10]
 800e8b0:	2142      	movs	r1, #66	; 0x42
 800e8b2:	187a      	adds	r2, r7, r1
 800e8b4:	8812      	ldrh	r2, [r2, #0]
 800e8b6:	429a      	cmp	r2, r3
 800e8b8:	d8e5      	bhi.n	800e886 <tcp_receive+0x632>
      }
      /* cannot fail... */
      pbuf_remove_header(p, off);
 800e8ba:	187b      	adds	r3, r7, r1
 800e8bc:	881a      	ldrh	r2, [r3, #0]
 800e8be:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e8c0:	0011      	movs	r1, r2
 800e8c2:	0018      	movs	r0, r3
 800e8c4:	f7fb fa22 	bl	8009d0c <pbuf_remove_header>
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
 800e8c8:	687b      	ldr	r3, [r7, #4]
 800e8ca:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800e8cc:	4b1e      	ldr	r3, [pc, #120]	; (800e948 <tcp_receive+0x6f4>)
 800e8ce:	601a      	str	r2, [r3, #0]
 800e8d0:	4b1e      	ldr	r3, [pc, #120]	; (800e94c <tcp_receive+0x6f8>)
 800e8d2:	691b      	ldr	r3, [r3, #16]
 800e8d4:	4a1c      	ldr	r2, [pc, #112]	; (800e948 <tcp_receive+0x6f4>)
 800e8d6:	6812      	ldr	r2, [r2, #0]
 800e8d8:	21ff      	movs	r1, #255	; 0xff
 800e8da:	4011      	ands	r1, r2
 800e8dc:	000c      	movs	r4, r1
 800e8de:	7919      	ldrb	r1, [r3, #4]
 800e8e0:	2000      	movs	r0, #0
 800e8e2:	4001      	ands	r1, r0
 800e8e4:	1c08      	adds	r0, r1, #0
 800e8e6:	1c21      	adds	r1, r4, #0
 800e8e8:	4301      	orrs	r1, r0
 800e8ea:	7119      	strb	r1, [r3, #4]
 800e8ec:	0a11      	lsrs	r1, r2, #8
 800e8ee:	20ff      	movs	r0, #255	; 0xff
 800e8f0:	4001      	ands	r1, r0
 800e8f2:	000c      	movs	r4, r1
 800e8f4:	7959      	ldrb	r1, [r3, #5]
 800e8f6:	2000      	movs	r0, #0
 800e8f8:	4001      	ands	r1, r0
 800e8fa:	1c08      	adds	r0, r1, #0
 800e8fc:	1c21      	adds	r1, r4, #0
 800e8fe:	4301      	orrs	r1, r0
 800e900:	7159      	strb	r1, [r3, #5]
 800e902:	0c11      	lsrs	r1, r2, #16
 800e904:	20ff      	movs	r0, #255	; 0xff
 800e906:	4001      	ands	r1, r0
 800e908:	000c      	movs	r4, r1
 800e90a:	7999      	ldrb	r1, [r3, #6]
 800e90c:	2000      	movs	r0, #0
 800e90e:	4001      	ands	r1, r0
 800e910:	1c08      	adds	r0, r1, #0
 800e912:	1c21      	adds	r1, r4, #0
 800e914:	4301      	orrs	r1, r0
 800e916:	7199      	strb	r1, [r3, #6]
 800e918:	0e10      	lsrs	r0, r2, #24
 800e91a:	79da      	ldrb	r2, [r3, #7]
 800e91c:	2100      	movs	r1, #0
 800e91e:	400a      	ands	r2, r1
 800e920:	1c11      	adds	r1, r2, #0
 800e922:	1c02      	adds	r2, r0, #0
 800e924:	430a      	orrs	r2, r1
 800e926:	71da      	strb	r2, [r3, #7]
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
 800e928:	e02f      	b.n	800e98a <tcp_receive+0x736>
 800e92a:	46c0      	nop			; (mov r8, r8)
 800e92c:	0802091c 	.word	0x0802091c
 800e930:	08020924 	.word	0x08020924
 800e934:	200017c0 	.word	0x200017c0
 800e938:	fffff7ff 	.word	0xfffff7ff
 800e93c:	200017bc 	.word	0x200017bc
 800e940:	20002b40 	.word	0x20002b40
 800e944:	200017c2 	.word	0x200017c2
 800e948:	200017b8 	.word	0x200017b8
 800e94c:	20001794 	.word	0x20001794
 800e950:	080205bc 	.word	0x080205bc
 800e954:	00000595 	.word	0x00000595
 800e958:	0802092c 	.word	0x0802092c
 800e95c:	080205fc 	.word	0x080205fc
 800e960:	0000fffe 	.word	0x0000fffe
 800e964:	00000596 	.word	0x00000596
 800e968:	0802093c 	.word	0x0802093c
 800e96c:	0802094c 	.word	0x0802094c
    } else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
 800e970:	4bb0      	ldr	r3, [pc, #704]	; (800ec34 <tcp_receive+0x9e0>)
 800e972:	681a      	ldr	r2, [r3, #0]
 800e974:	687b      	ldr	r3, [r7, #4]
 800e976:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800e978:	1ad3      	subs	r3, r2, r3
 800e97a:	d506      	bpl.n	800e98a <tcp_receive+0x736>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
 800e97c:	687b      	ldr	r3, [r7, #4]
 800e97e:	8bdb      	ldrh	r3, [r3, #30]
 800e980:	2202      	movs	r2, #2
 800e982:	4313      	orrs	r3, r2
 800e984:	b29a      	uxth	r2, r3
 800e986:	687b      	ldr	r3, [r7, #4]
 800e988:	83da      	strh	r2, [r3, #30]
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
 800e98a:	4baa      	ldr	r3, [pc, #680]	; (800ec34 <tcp_receive+0x9e0>)
 800e98c:	681a      	ldr	r2, [r3, #0]
 800e98e:	687b      	ldr	r3, [r7, #4]
 800e990:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800e992:	1ad3      	subs	r3, r2, r3
 800e994:	d501      	bpl.n	800e99a <tcp_receive+0x746>
 800e996:	f000 fd4d 	bl	800f434 <tcp_receive+0x11e0>
 800e99a:	4ba6      	ldr	r3, [pc, #664]	; (800ec34 <tcp_receive+0x9e0>)
 800e99c:	681a      	ldr	r2, [r3, #0]
 800e99e:	687b      	ldr	r3, [r7, #4]
 800e9a0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800e9a2:	6879      	ldr	r1, [r7, #4]
 800e9a4:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
 800e9a6:	185b      	adds	r3, r3, r1
 800e9a8:	1ad3      	subs	r3, r2, r3
 800e9aa:	3301      	adds	r3, #1
 800e9ac:	2b00      	cmp	r3, #0
 800e9ae:	dd01      	ble.n	800e9b4 <tcp_receive+0x760>
 800e9b0:	f000 fd40 	bl	800f434 <tcp_receive+0x11e0>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
      if (pcb->rcv_nxt == seqno) {
 800e9b4:	687b      	ldr	r3, [r7, #4]
 800e9b6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800e9b8:	4b9e      	ldr	r3, [pc, #632]	; (800ec34 <tcp_receive+0x9e0>)
 800e9ba:	681b      	ldr	r3, [r3, #0]
 800e9bc:	429a      	cmp	r2, r3
 800e9be:	d000      	beq.n	800e9c2 <tcp_receive+0x76e>
 800e9c0:	e337      	b.n	800f032 <tcp_receive+0xdde>
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
        tcplen = TCP_TCPLEN(&inseg);
 800e9c2:	4b9d      	ldr	r3, [pc, #628]	; (800ec38 <tcp_receive+0x9e4>)
 800e9c4:	891c      	ldrh	r4, [r3, #8]
 800e9c6:	4b9c      	ldr	r3, [pc, #624]	; (800ec38 <tcp_receive+0x9e4>)
 800e9c8:	691b      	ldr	r3, [r3, #16]
 800e9ca:	7b1a      	ldrb	r2, [r3, #12]
 800e9cc:	7b5b      	ldrb	r3, [r3, #13]
 800e9ce:	021b      	lsls	r3, r3, #8
 800e9d0:	4313      	orrs	r3, r2
 800e9d2:	b29b      	uxth	r3, r3
 800e9d4:	0018      	movs	r0, r3
 800e9d6:	f7f8 fa8d 	bl	8006ef4 <lwip_htons>
 800e9da:	0003      	movs	r3, r0
 800e9dc:	b2db      	uxtb	r3, r3
 800e9de:	001a      	movs	r2, r3
 800e9e0:	2303      	movs	r3, #3
 800e9e2:	4013      	ands	r3, r2
 800e9e4:	d001      	beq.n	800e9ea <tcp_receive+0x796>
 800e9e6:	2301      	movs	r3, #1
 800e9e8:	e000      	b.n	800e9ec <tcp_receive+0x798>
 800e9ea:	2300      	movs	r3, #0
 800e9ec:	191b      	adds	r3, r3, r4
 800e9ee:	b29a      	uxth	r2, r3
 800e9f0:	4b92      	ldr	r3, [pc, #584]	; (800ec3c <tcp_receive+0x9e8>)
 800e9f2:	801a      	strh	r2, [r3, #0]

        if (tcplen > pcb->rcv_wnd) {
 800e9f4:	687b      	ldr	r3, [r7, #4]
 800e9f6:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800e9f8:	4b90      	ldr	r3, [pc, #576]	; (800ec3c <tcp_receive+0x9e8>)
 800e9fa:	881b      	ldrh	r3, [r3, #0]
 800e9fc:	429a      	cmp	r2, r3
 800e9fe:	d300      	bcc.n	800ea02 <tcp_receive+0x7ae>
 800ea00:	e095      	b.n	800eb2e <tcp_receive+0x8da>
          LWIP_DEBUGF(TCP_INPUT_DEBUG,
                      ("tcp_receive: other end overran receive window"
                       "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                       seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 800ea02:	4b8d      	ldr	r3, [pc, #564]	; (800ec38 <tcp_receive+0x9e4>)
 800ea04:	691b      	ldr	r3, [r3, #16]
 800ea06:	7b1a      	ldrb	r2, [r3, #12]
 800ea08:	7b5b      	ldrb	r3, [r3, #13]
 800ea0a:	021b      	lsls	r3, r3, #8
 800ea0c:	4313      	orrs	r3, r2
 800ea0e:	b29b      	uxth	r3, r3
 800ea10:	0018      	movs	r0, r3
 800ea12:	f7f8 fa6f 	bl	8006ef4 <lwip_htons>
 800ea16:	0003      	movs	r3, r0
 800ea18:	b2db      	uxtb	r3, r3
 800ea1a:	001a      	movs	r2, r3
 800ea1c:	2301      	movs	r3, #1
 800ea1e:	4013      	ands	r3, r2
 800ea20:	d037      	beq.n	800ea92 <tcp_receive+0x83e>
            /* Must remove the FIN from the header as we're trimming
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) & ~(unsigned int)TCP_FIN);
 800ea22:	4b85      	ldr	r3, [pc, #532]	; (800ec38 <tcp_receive+0x9e4>)
 800ea24:	691b      	ldr	r3, [r3, #16]
 800ea26:	7b1a      	ldrb	r2, [r3, #12]
 800ea28:	7b5b      	ldrb	r3, [r3, #13]
 800ea2a:	021b      	lsls	r3, r3, #8
 800ea2c:	4313      	orrs	r3, r2
 800ea2e:	b29b      	uxth	r3, r3
 800ea30:	b21b      	sxth	r3, r3
 800ea32:	4a83      	ldr	r2, [pc, #524]	; (800ec40 <tcp_receive+0x9ec>)
 800ea34:	4013      	ands	r3, r2
 800ea36:	b21c      	sxth	r4, r3
 800ea38:	4b7f      	ldr	r3, [pc, #508]	; (800ec38 <tcp_receive+0x9e4>)
 800ea3a:	691b      	ldr	r3, [r3, #16]
 800ea3c:	7b1a      	ldrb	r2, [r3, #12]
 800ea3e:	7b5b      	ldrb	r3, [r3, #13]
 800ea40:	021b      	lsls	r3, r3, #8
 800ea42:	4313      	orrs	r3, r2
 800ea44:	b29b      	uxth	r3, r3
 800ea46:	0018      	movs	r0, r3
 800ea48:	f7f8 fa54 	bl	8006ef4 <lwip_htons>
 800ea4c:	0003      	movs	r3, r0
 800ea4e:	b2db      	uxtb	r3, r3
 800ea50:	b29b      	uxth	r3, r3
 800ea52:	223e      	movs	r2, #62	; 0x3e
 800ea54:	4013      	ands	r3, r2
 800ea56:	b29b      	uxth	r3, r3
 800ea58:	0018      	movs	r0, r3
 800ea5a:	f7f8 fa4b 	bl	8006ef4 <lwip_htons>
 800ea5e:	0003      	movs	r3, r0
 800ea60:	b21b      	sxth	r3, r3
 800ea62:	4323      	orrs	r3, r4
 800ea64:	b21a      	sxth	r2, r3
 800ea66:	4b74      	ldr	r3, [pc, #464]	; (800ec38 <tcp_receive+0x9e4>)
 800ea68:	691b      	ldr	r3, [r3, #16]
 800ea6a:	b292      	uxth	r2, r2
 800ea6c:	21ff      	movs	r1, #255	; 0xff
 800ea6e:	4011      	ands	r1, r2
 800ea70:	000c      	movs	r4, r1
 800ea72:	7b19      	ldrb	r1, [r3, #12]
 800ea74:	2000      	movs	r0, #0
 800ea76:	4001      	ands	r1, r0
 800ea78:	1c08      	adds	r0, r1, #0
 800ea7a:	1c21      	adds	r1, r4, #0
 800ea7c:	4301      	orrs	r1, r0
 800ea7e:	7319      	strb	r1, [r3, #12]
 800ea80:	0a12      	lsrs	r2, r2, #8
 800ea82:	b290      	uxth	r0, r2
 800ea84:	7b5a      	ldrb	r2, [r3, #13]
 800ea86:	2100      	movs	r1, #0
 800ea88:	400a      	ands	r2, r1
 800ea8a:	1c11      	adds	r1, r2, #0
 800ea8c:	1c02      	adds	r2, r0, #0
 800ea8e:	430a      	orrs	r2, r1
 800ea90:	735a      	strb	r2, [r3, #13]
          }
          /* Adjust length of segment to fit in the window. */
          TCPWND_CHECK16(pcb->rcv_wnd);
          inseg.len = (u16_t)pcb->rcv_wnd;
 800ea92:	687b      	ldr	r3, [r7, #4]
 800ea94:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800ea96:	4b68      	ldr	r3, [pc, #416]	; (800ec38 <tcp_receive+0x9e4>)
 800ea98:	811a      	strh	r2, [r3, #8]
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 800ea9a:	4b67      	ldr	r3, [pc, #412]	; (800ec38 <tcp_receive+0x9e4>)
 800ea9c:	691b      	ldr	r3, [r3, #16]
 800ea9e:	7b1a      	ldrb	r2, [r3, #12]
 800eaa0:	7b5b      	ldrb	r3, [r3, #13]
 800eaa2:	021b      	lsls	r3, r3, #8
 800eaa4:	4313      	orrs	r3, r2
 800eaa6:	b29b      	uxth	r3, r3
 800eaa8:	0018      	movs	r0, r3
 800eaaa:	f7f8 fa23 	bl	8006ef4 <lwip_htons>
 800eaae:	0003      	movs	r3, r0
 800eab0:	b2db      	uxtb	r3, r3
 800eab2:	001a      	movs	r2, r3
 800eab4:	2302      	movs	r3, #2
 800eab6:	4013      	ands	r3, r2
 800eab8:	d005      	beq.n	800eac6 <tcp_receive+0x872>
            inseg.len -= 1;
 800eaba:	4b5f      	ldr	r3, [pc, #380]	; (800ec38 <tcp_receive+0x9e4>)
 800eabc:	891b      	ldrh	r3, [r3, #8]
 800eabe:	3b01      	subs	r3, #1
 800eac0:	b29a      	uxth	r2, r3
 800eac2:	4b5d      	ldr	r3, [pc, #372]	; (800ec38 <tcp_receive+0x9e4>)
 800eac4:	811a      	strh	r2, [r3, #8]
          }
          pbuf_realloc(inseg.p, inseg.len);
 800eac6:	4b5c      	ldr	r3, [pc, #368]	; (800ec38 <tcp_receive+0x9e4>)
 800eac8:	685a      	ldr	r2, [r3, #4]
 800eaca:	4b5b      	ldr	r3, [pc, #364]	; (800ec38 <tcp_receive+0x9e4>)
 800eacc:	891b      	ldrh	r3, [r3, #8]
 800eace:	0019      	movs	r1, r3
 800ead0:	0010      	movs	r0, r2
 800ead2:	f7fa fff9 	bl	8009ac8 <pbuf_realloc>
          tcplen = TCP_TCPLEN(&inseg);
 800ead6:	4b58      	ldr	r3, [pc, #352]	; (800ec38 <tcp_receive+0x9e4>)
 800ead8:	891c      	ldrh	r4, [r3, #8]
 800eada:	4b57      	ldr	r3, [pc, #348]	; (800ec38 <tcp_receive+0x9e4>)
 800eadc:	691b      	ldr	r3, [r3, #16]
 800eade:	7b1a      	ldrb	r2, [r3, #12]
 800eae0:	7b5b      	ldrb	r3, [r3, #13]
 800eae2:	021b      	lsls	r3, r3, #8
 800eae4:	4313      	orrs	r3, r2
 800eae6:	b29b      	uxth	r3, r3
 800eae8:	0018      	movs	r0, r3
 800eaea:	f7f8 fa03 	bl	8006ef4 <lwip_htons>
 800eaee:	0003      	movs	r3, r0
 800eaf0:	b2db      	uxtb	r3, r3
 800eaf2:	001a      	movs	r2, r3
 800eaf4:	2303      	movs	r3, #3
 800eaf6:	4013      	ands	r3, r2
 800eaf8:	d001      	beq.n	800eafe <tcp_receive+0x8aa>
 800eafa:	2301      	movs	r3, #1
 800eafc:	e000      	b.n	800eb00 <tcp_receive+0x8ac>
 800eafe:	2300      	movs	r3, #0
 800eb00:	191b      	adds	r3, r3, r4
 800eb02:	b29a      	uxth	r2, r3
 800eb04:	4b4d      	ldr	r3, [pc, #308]	; (800ec3c <tcp_receive+0x9e8>)
 800eb06:	801a      	strh	r2, [r3, #0]
          LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 800eb08:	4b4c      	ldr	r3, [pc, #304]	; (800ec3c <tcp_receive+0x9e8>)
 800eb0a:	881b      	ldrh	r3, [r3, #0]
 800eb0c:	001a      	movs	r2, r3
 800eb0e:	4b49      	ldr	r3, [pc, #292]	; (800ec34 <tcp_receive+0x9e0>)
 800eb10:	681b      	ldr	r3, [r3, #0]
 800eb12:	18d2      	adds	r2, r2, r3
 800eb14:	687b      	ldr	r3, [r7, #4]
 800eb16:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800eb18:	6879      	ldr	r1, [r7, #4]
 800eb1a:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
 800eb1c:	185b      	adds	r3, r3, r1
 800eb1e:	429a      	cmp	r2, r3
 800eb20:	d005      	beq.n	800eb2e <tcp_receive+0x8da>
 800eb22:	4b48      	ldr	r3, [pc, #288]	; (800ec44 <tcp_receive+0x9f0>)
 800eb24:	4a48      	ldr	r2, [pc, #288]	; (800ec48 <tcp_receive+0x9f4>)
 800eb26:	4949      	ldr	r1, [pc, #292]	; (800ec4c <tcp_receive+0x9f8>)
 800eb28:	4849      	ldr	r0, [pc, #292]	; (800ec50 <tcp_receive+0x9fc>)
 800eb2a:	f7f4 f84d 	bl	8002bc8 <app_debug_rtt_raw>
        }
#if TCP_QUEUE_OOSEQ
        /* Received in-sequence data, adjust ooseq data if:
           - FIN has been received or
           - inseq overlaps with ooseq */
        if (pcb->ooseq != NULL) {
 800eb2e:	687b      	ldr	r3, [r7, #4]
 800eb30:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800eb32:	2b00      	cmp	r3, #0
 800eb34:	d100      	bne.n	800eb38 <tcp_receive+0x8e4>
 800eb36:	e138      	b.n	800edaa <tcp_receive+0xb56>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 800eb38:	4b3f      	ldr	r3, [pc, #252]	; (800ec38 <tcp_receive+0x9e4>)
 800eb3a:	691b      	ldr	r3, [r3, #16]
 800eb3c:	7b1a      	ldrb	r2, [r3, #12]
 800eb3e:	7b5b      	ldrb	r3, [r3, #13]
 800eb40:	021b      	lsls	r3, r3, #8
 800eb42:	4313      	orrs	r3, r2
 800eb44:	b29b      	uxth	r3, r3
 800eb46:	0018      	movs	r0, r3
 800eb48:	f7f8 f9d4 	bl	8006ef4 <lwip_htons>
 800eb4c:	0003      	movs	r3, r0
 800eb4e:	b2db      	uxtb	r3, r3
 800eb50:	001a      	movs	r2, r3
 800eb52:	2301      	movs	r3, #1
 800eb54:	4013      	ands	r3, r2
 800eb56:	d011      	beq.n	800eb7c <tcp_receive+0x928>
            LWIP_DEBUGF(TCP_INPUT_DEBUG,
                        ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
            /* Received in-order FIN means anything that was received
             * out of order must now have been received in-order, so
             * bin the ooseq queue */
            while (pcb->ooseq != NULL) {
 800eb58:	e00b      	b.n	800eb72 <tcp_receive+0x91e>
              struct tcp_seg *old_ooseq = pcb->ooseq;
 800eb5a:	687b      	ldr	r3, [r7, #4]
 800eb5c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800eb5e:	60fb      	str	r3, [r7, #12]
              pcb->ooseq = pcb->ooseq->next;
 800eb60:	687b      	ldr	r3, [r7, #4]
 800eb62:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800eb64:	681a      	ldr	r2, [r3, #0]
 800eb66:	687b      	ldr	r3, [r7, #4]
 800eb68:	679a      	str	r2, [r3, #120]	; 0x78
              tcp_seg_free(old_ooseq);
 800eb6a:	68fb      	ldr	r3, [r7, #12]
 800eb6c:	0018      	movs	r0, r3
 800eb6e:	f7fd fa11 	bl	800bf94 <tcp_seg_free>
            while (pcb->ooseq != NULL) {
 800eb72:	687b      	ldr	r3, [r7, #4]
 800eb74:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800eb76:	2b00      	cmp	r3, #0
 800eb78:	d1ef      	bne.n	800eb5a <tcp_receive+0x906>
 800eb7a:	e116      	b.n	800edaa <tcp_receive+0xb56>
            }
          } else {
            struct tcp_seg *next = pcb->ooseq;
 800eb7c:	687b      	ldr	r3, [r7, #4]
 800eb7e:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800eb80:	63fb      	str	r3, [r7, #60]	; 0x3c
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
 800eb82:	e075      	b.n	800ec70 <tcp_receive+0xa1c>
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              struct tcp_seg *tmp;
              /* inseg cannot have FIN here (already processed above) */
              if ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0 &&
 800eb84:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800eb86:	691b      	ldr	r3, [r3, #16]
 800eb88:	7b1a      	ldrb	r2, [r3, #12]
 800eb8a:	7b5b      	ldrb	r3, [r3, #13]
 800eb8c:	021b      	lsls	r3, r3, #8
 800eb8e:	4313      	orrs	r3, r2
 800eb90:	b29b      	uxth	r3, r3
 800eb92:	0018      	movs	r0, r3
 800eb94:	f7f8 f9ae 	bl	8006ef4 <lwip_htons>
 800eb98:	0003      	movs	r3, r0
 800eb9a:	b2db      	uxtb	r3, r3
 800eb9c:	001a      	movs	r2, r3
 800eb9e:	2301      	movs	r3, #1
 800eba0:	4013      	ands	r3, r2
 800eba2:	d05c      	beq.n	800ec5e <tcp_receive+0xa0a>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
 800eba4:	4b24      	ldr	r3, [pc, #144]	; (800ec38 <tcp_receive+0x9e4>)
 800eba6:	691b      	ldr	r3, [r3, #16]
 800eba8:	7b1a      	ldrb	r2, [r3, #12]
 800ebaa:	7b5b      	ldrb	r3, [r3, #13]
 800ebac:	021b      	lsls	r3, r3, #8
 800ebae:	4313      	orrs	r3, r2
 800ebb0:	b29b      	uxth	r3, r3
 800ebb2:	0018      	movs	r0, r3
 800ebb4:	f7f8 f99e 	bl	8006ef4 <lwip_htons>
 800ebb8:	0003      	movs	r3, r0
 800ebba:	b2db      	uxtb	r3, r3
 800ebbc:	001a      	movs	r2, r3
 800ebbe:	2302      	movs	r3, #2
 800ebc0:	4013      	ands	r3, r2
              if ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0 &&
 800ebc2:	d14c      	bne.n	800ec5e <tcp_receive+0xa0a>
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
 800ebc4:	4b1c      	ldr	r3, [pc, #112]	; (800ec38 <tcp_receive+0x9e4>)
 800ebc6:	691b      	ldr	r3, [r3, #16]
 800ebc8:	7b1a      	ldrb	r2, [r3, #12]
 800ebca:	7b5b      	ldrb	r3, [r3, #13]
 800ebcc:	021b      	lsls	r3, r3, #8
 800ebce:	4313      	orrs	r3, r2
 800ebd0:	b29c      	uxth	r4, r3
 800ebd2:	2001      	movs	r0, #1
 800ebd4:	f7f8 f98e 	bl	8006ef4 <lwip_htons>
 800ebd8:	0003      	movs	r3, r0
 800ebda:	001a      	movs	r2, r3
 800ebdc:	4b16      	ldr	r3, [pc, #88]	; (800ec38 <tcp_receive+0x9e4>)
 800ebde:	691b      	ldr	r3, [r3, #16]
 800ebe0:	4322      	orrs	r2, r4
 800ebe2:	b292      	uxth	r2, r2
 800ebe4:	21ff      	movs	r1, #255	; 0xff
 800ebe6:	4011      	ands	r1, r2
 800ebe8:	000c      	movs	r4, r1
 800ebea:	7b19      	ldrb	r1, [r3, #12]
 800ebec:	2000      	movs	r0, #0
 800ebee:	4001      	ands	r1, r0
 800ebf0:	1c08      	adds	r0, r1, #0
 800ebf2:	1c21      	adds	r1, r4, #0
 800ebf4:	4301      	orrs	r1, r0
 800ebf6:	7319      	strb	r1, [r3, #12]
 800ebf8:	0a12      	lsrs	r2, r2, #8
 800ebfa:	b290      	uxth	r0, r2
 800ebfc:	7b5a      	ldrb	r2, [r3, #13]
 800ebfe:	2100      	movs	r1, #0
 800ec00:	400a      	ands	r2, r1
 800ec02:	1c11      	adds	r1, r2, #0
 800ec04:	1c02      	adds	r2, r0, #0
 800ec06:	430a      	orrs	r2, r1
 800ec08:	735a      	strb	r2, [r3, #13]
                tcplen = TCP_TCPLEN(&inseg);
 800ec0a:	4b0b      	ldr	r3, [pc, #44]	; (800ec38 <tcp_receive+0x9e4>)
 800ec0c:	891c      	ldrh	r4, [r3, #8]
 800ec0e:	4b0a      	ldr	r3, [pc, #40]	; (800ec38 <tcp_receive+0x9e4>)
 800ec10:	691b      	ldr	r3, [r3, #16]
 800ec12:	7b1a      	ldrb	r2, [r3, #12]
 800ec14:	7b5b      	ldrb	r3, [r3, #13]
 800ec16:	021b      	lsls	r3, r3, #8
 800ec18:	4313      	orrs	r3, r2
 800ec1a:	b29b      	uxth	r3, r3
 800ec1c:	0018      	movs	r0, r3
 800ec1e:	f7f8 f969 	bl	8006ef4 <lwip_htons>
 800ec22:	0003      	movs	r3, r0
 800ec24:	b2db      	uxtb	r3, r3
 800ec26:	001a      	movs	r2, r3
 800ec28:	2303      	movs	r3, #3
 800ec2a:	4013      	ands	r3, r2
 800ec2c:	d012      	beq.n	800ec54 <tcp_receive+0xa00>
 800ec2e:	2301      	movs	r3, #1
 800ec30:	e011      	b.n	800ec56 <tcp_receive+0xa02>
 800ec32:	46c0      	nop			; (mov r8, r8)
 800ec34:	200017b8 	.word	0x200017b8
 800ec38:	20001794 	.word	0x20001794
 800ec3c:	200017c2 	.word	0x200017c2
 800ec40:	ffffc0ff 	.word	0xffffc0ff
 800ec44:	080205bc 	.word	0x080205bc
 800ec48:	000005cc 	.word	0x000005cc
 800ec4c:	0802095c 	.word	0x0802095c
 800ec50:	080205fc 	.word	0x080205fc
 800ec54:	2300      	movs	r3, #0
 800ec56:	191b      	adds	r3, r3, r4
 800ec58:	b29a      	uxth	r2, r3
 800ec5a:	4bb9      	ldr	r3, [pc, #740]	; (800ef40 <tcp_receive+0xcec>)
 800ec5c:	801a      	strh	r2, [r3, #0]
              }
              tmp = next;
 800ec5e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ec60:	613b      	str	r3, [r7, #16]
              next = next->next;
 800ec62:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ec64:	681b      	ldr	r3, [r3, #0]
 800ec66:	63fb      	str	r3, [r7, #60]	; 0x3c
              tcp_seg_free(tmp);
 800ec68:	693b      	ldr	r3, [r7, #16]
 800ec6a:	0018      	movs	r0, r3
 800ec6c:	f7fd f992 	bl	800bf94 <tcp_seg_free>
            while (next &&
 800ec70:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ec72:	2b00      	cmp	r3, #0
 800ec74:	d018      	beq.n	800eca8 <tcp_receive+0xa54>
                   TCP_SEQ_GEQ(seqno + tcplen,
 800ec76:	4bb2      	ldr	r3, [pc, #712]	; (800ef40 <tcp_receive+0xcec>)
 800ec78:	881b      	ldrh	r3, [r3, #0]
 800ec7a:	001a      	movs	r2, r3
 800ec7c:	4bb1      	ldr	r3, [pc, #708]	; (800ef44 <tcp_receive+0xcf0>)
 800ec7e:	681b      	ldr	r3, [r3, #0]
 800ec80:	18d2      	adds	r2, r2, r3
 800ec82:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ec84:	691b      	ldr	r3, [r3, #16]
 800ec86:	7919      	ldrb	r1, [r3, #4]
 800ec88:	7958      	ldrb	r0, [r3, #5]
 800ec8a:	0200      	lsls	r0, r0, #8
 800ec8c:	4301      	orrs	r1, r0
 800ec8e:	7998      	ldrb	r0, [r3, #6]
 800ec90:	0400      	lsls	r0, r0, #16
 800ec92:	4301      	orrs	r1, r0
 800ec94:	79db      	ldrb	r3, [r3, #7]
 800ec96:	061b      	lsls	r3, r3, #24
 800ec98:	430b      	orrs	r3, r1
 800ec9a:	0019      	movs	r1, r3
 800ec9c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ec9e:	891b      	ldrh	r3, [r3, #8]
 800eca0:	18cb      	adds	r3, r1, r3
 800eca2:	1ad3      	subs	r3, r2, r3
            while (next &&
 800eca4:	d400      	bmi.n	800eca8 <tcp_receive+0xa54>
 800eca6:	e76d      	b.n	800eb84 <tcp_receive+0x930>
            }
            /* Now trim right side of inseg if it overlaps with the first
             * segment on ooseq */
            if (next &&
 800eca8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ecaa:	2b00      	cmp	r3, #0
 800ecac:	d100      	bne.n	800ecb0 <tcp_receive+0xa5c>
 800ecae:	e079      	b.n	800eda4 <tcp_receive+0xb50>
                TCP_SEQ_GT(seqno + tcplen,
 800ecb0:	4ba3      	ldr	r3, [pc, #652]	; (800ef40 <tcp_receive+0xcec>)
 800ecb2:	881b      	ldrh	r3, [r3, #0]
 800ecb4:	001a      	movs	r2, r3
 800ecb6:	4ba3      	ldr	r3, [pc, #652]	; (800ef44 <tcp_receive+0xcf0>)
 800ecb8:	681b      	ldr	r3, [r3, #0]
 800ecba:	18d2      	adds	r2, r2, r3
 800ecbc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ecbe:	691b      	ldr	r3, [r3, #16]
 800ecc0:	7919      	ldrb	r1, [r3, #4]
 800ecc2:	7958      	ldrb	r0, [r3, #5]
 800ecc4:	0200      	lsls	r0, r0, #8
 800ecc6:	4301      	orrs	r1, r0
 800ecc8:	7998      	ldrb	r0, [r3, #6]
 800ecca:	0400      	lsls	r0, r0, #16
 800eccc:	4301      	orrs	r1, r0
 800ecce:	79db      	ldrb	r3, [r3, #7]
 800ecd0:	061b      	lsls	r3, r3, #24
 800ecd2:	430b      	orrs	r3, r1
 800ecd4:	1ad3      	subs	r3, r2, r3
            if (next &&
 800ecd6:	2b00      	cmp	r3, #0
 800ecd8:	dd64      	ble.n	800eda4 <tcp_receive+0xb50>
                           next->tcphdr->seqno)) {
              /* inseg cannot have FIN here (already processed above) */
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
 800ecda:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ecdc:	691b      	ldr	r3, [r3, #16]
 800ecde:	791a      	ldrb	r2, [r3, #4]
 800ece0:	7959      	ldrb	r1, [r3, #5]
 800ece2:	0209      	lsls	r1, r1, #8
 800ece4:	430a      	orrs	r2, r1
 800ece6:	7999      	ldrb	r1, [r3, #6]
 800ece8:	0409      	lsls	r1, r1, #16
 800ecea:	430a      	orrs	r2, r1
 800ecec:	79db      	ldrb	r3, [r3, #7]
 800ecee:	061b      	lsls	r3, r3, #24
 800ecf0:	4313      	orrs	r3, r2
 800ecf2:	b29a      	uxth	r2, r3
 800ecf4:	4b93      	ldr	r3, [pc, #588]	; (800ef44 <tcp_receive+0xcf0>)
 800ecf6:	681b      	ldr	r3, [r3, #0]
 800ecf8:	b29b      	uxth	r3, r3
 800ecfa:	1ad3      	subs	r3, r2, r3
 800ecfc:	b29a      	uxth	r2, r3
 800ecfe:	4b92      	ldr	r3, [pc, #584]	; (800ef48 <tcp_receive+0xcf4>)
 800ed00:	811a      	strh	r2, [r3, #8]
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 800ed02:	4b91      	ldr	r3, [pc, #580]	; (800ef48 <tcp_receive+0xcf4>)
 800ed04:	691b      	ldr	r3, [r3, #16]
 800ed06:	7b1a      	ldrb	r2, [r3, #12]
 800ed08:	7b5b      	ldrb	r3, [r3, #13]
 800ed0a:	021b      	lsls	r3, r3, #8
 800ed0c:	4313      	orrs	r3, r2
 800ed0e:	b29b      	uxth	r3, r3
 800ed10:	0018      	movs	r0, r3
 800ed12:	f7f8 f8ef 	bl	8006ef4 <lwip_htons>
 800ed16:	0003      	movs	r3, r0
 800ed18:	b2db      	uxtb	r3, r3
 800ed1a:	001a      	movs	r2, r3
 800ed1c:	2302      	movs	r3, #2
 800ed1e:	4013      	ands	r3, r2
 800ed20:	d005      	beq.n	800ed2e <tcp_receive+0xada>
                inseg.len -= 1;
 800ed22:	4b89      	ldr	r3, [pc, #548]	; (800ef48 <tcp_receive+0xcf4>)
 800ed24:	891b      	ldrh	r3, [r3, #8]
 800ed26:	3b01      	subs	r3, #1
 800ed28:	b29a      	uxth	r2, r3
 800ed2a:	4b87      	ldr	r3, [pc, #540]	; (800ef48 <tcp_receive+0xcf4>)
 800ed2c:	811a      	strh	r2, [r3, #8]
              }
              pbuf_realloc(inseg.p, inseg.len);
 800ed2e:	4b86      	ldr	r3, [pc, #536]	; (800ef48 <tcp_receive+0xcf4>)
 800ed30:	685a      	ldr	r2, [r3, #4]
 800ed32:	4b85      	ldr	r3, [pc, #532]	; (800ef48 <tcp_receive+0xcf4>)
 800ed34:	891b      	ldrh	r3, [r3, #8]
 800ed36:	0019      	movs	r1, r3
 800ed38:	0010      	movs	r0, r2
 800ed3a:	f7fa fec5 	bl	8009ac8 <pbuf_realloc>
              tcplen = TCP_TCPLEN(&inseg);
 800ed3e:	4b82      	ldr	r3, [pc, #520]	; (800ef48 <tcp_receive+0xcf4>)
 800ed40:	891c      	ldrh	r4, [r3, #8]
 800ed42:	4b81      	ldr	r3, [pc, #516]	; (800ef48 <tcp_receive+0xcf4>)
 800ed44:	691b      	ldr	r3, [r3, #16]
 800ed46:	7b1a      	ldrb	r2, [r3, #12]
 800ed48:	7b5b      	ldrb	r3, [r3, #13]
 800ed4a:	021b      	lsls	r3, r3, #8
 800ed4c:	4313      	orrs	r3, r2
 800ed4e:	b29b      	uxth	r3, r3
 800ed50:	0018      	movs	r0, r3
 800ed52:	f7f8 f8cf 	bl	8006ef4 <lwip_htons>
 800ed56:	0003      	movs	r3, r0
 800ed58:	b2db      	uxtb	r3, r3
 800ed5a:	001a      	movs	r2, r3
 800ed5c:	2303      	movs	r3, #3
 800ed5e:	4013      	ands	r3, r2
 800ed60:	d001      	beq.n	800ed66 <tcp_receive+0xb12>
 800ed62:	2301      	movs	r3, #1
 800ed64:	e000      	b.n	800ed68 <tcp_receive+0xb14>
 800ed66:	2300      	movs	r3, #0
 800ed68:	191b      	adds	r3, r3, r4
 800ed6a:	b29a      	uxth	r2, r3
 800ed6c:	4b74      	ldr	r3, [pc, #464]	; (800ef40 <tcp_receive+0xcec>)
 800ed6e:	801a      	strh	r2, [r3, #0]
              LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
 800ed70:	4b73      	ldr	r3, [pc, #460]	; (800ef40 <tcp_receive+0xcec>)
 800ed72:	881b      	ldrh	r3, [r3, #0]
 800ed74:	001a      	movs	r2, r3
 800ed76:	4b73      	ldr	r3, [pc, #460]	; (800ef44 <tcp_receive+0xcf0>)
 800ed78:	681b      	ldr	r3, [r3, #0]
 800ed7a:	18d2      	adds	r2, r2, r3
 800ed7c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ed7e:	691b      	ldr	r3, [r3, #16]
 800ed80:	7919      	ldrb	r1, [r3, #4]
 800ed82:	7958      	ldrb	r0, [r3, #5]
 800ed84:	0200      	lsls	r0, r0, #8
 800ed86:	4301      	orrs	r1, r0
 800ed88:	7998      	ldrb	r0, [r3, #6]
 800ed8a:	0400      	lsls	r0, r0, #16
 800ed8c:	4301      	orrs	r1, r0
 800ed8e:	79db      	ldrb	r3, [r3, #7]
 800ed90:	061b      	lsls	r3, r3, #24
 800ed92:	430b      	orrs	r3, r1
 800ed94:	429a      	cmp	r2, r3
 800ed96:	d005      	beq.n	800eda4 <tcp_receive+0xb50>
 800ed98:	4b6c      	ldr	r3, [pc, #432]	; (800ef4c <tcp_receive+0xcf8>)
 800ed9a:	4a6d      	ldr	r2, [pc, #436]	; (800ef50 <tcp_receive+0xcfc>)
 800ed9c:	496d      	ldr	r1, [pc, #436]	; (800ef54 <tcp_receive+0xd00>)
 800ed9e:	486e      	ldr	r0, [pc, #440]	; (800ef58 <tcp_receive+0xd04>)
 800eda0:	f7f3 ff12 	bl	8002bc8 <app_debug_rtt_raw>
                          (seqno + tcplen) == next->tcphdr->seqno);
            }
            pcb->ooseq = next;
 800eda4:	687b      	ldr	r3, [r7, #4]
 800eda6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800eda8:	679a      	str	r2, [r3, #120]	; 0x78
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;
 800edaa:	4b65      	ldr	r3, [pc, #404]	; (800ef40 <tcp_receive+0xcec>)
 800edac:	881b      	ldrh	r3, [r3, #0]
 800edae:	001a      	movs	r2, r3
 800edb0:	4b64      	ldr	r3, [pc, #400]	; (800ef44 <tcp_receive+0xcf0>)
 800edb2:	681b      	ldr	r3, [r3, #0]
 800edb4:	18d2      	adds	r2, r2, r3
 800edb6:	687b      	ldr	r3, [r7, #4]
 800edb8:	629a      	str	r2, [r3, #40]	; 0x28

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
 800edba:	687b      	ldr	r3, [r7, #4]
 800edbc:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800edbe:	4b60      	ldr	r3, [pc, #384]	; (800ef40 <tcp_receive+0xcec>)
 800edc0:	881b      	ldrh	r3, [r3, #0]
 800edc2:	429a      	cmp	r2, r3
 800edc4:	d206      	bcs.n	800edd4 <tcp_receive+0xb80>
 800edc6:	4b61      	ldr	r3, [pc, #388]	; (800ef4c <tcp_receive+0xcf8>)
 800edc8:	22c1      	movs	r2, #193	; 0xc1
 800edca:	00d2      	lsls	r2, r2, #3
 800edcc:	4963      	ldr	r1, [pc, #396]	; (800ef5c <tcp_receive+0xd08>)
 800edce:	4862      	ldr	r0, [pc, #392]	; (800ef58 <tcp_receive+0xd04>)
 800edd0:	f7f3 fefa 	bl	8002bc8 <app_debug_rtt_raw>
        pcb->rcv_wnd -= tcplen;
 800edd4:	687b      	ldr	r3, [r7, #4]
 800edd6:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800edd8:	4b59      	ldr	r3, [pc, #356]	; (800ef40 <tcp_receive+0xcec>)
 800edda:	881b      	ldrh	r3, [r3, #0]
 800eddc:	1ad3      	subs	r3, r2, r3
 800edde:	b29a      	uxth	r2, r3
 800ede0:	687b      	ldr	r3, [r7, #4]
 800ede2:	859a      	strh	r2, [r3, #44]	; 0x2c

        tcp_update_rcv_ann_wnd(pcb);
 800ede4:	687b      	ldr	r3, [r7, #4]
 800ede6:	0018      	movs	r0, r3
 800ede8:	f7fc f9e2 	bl	800b1b0 <tcp_update_rcv_ann_wnd>
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
 800edec:	4b56      	ldr	r3, [pc, #344]	; (800ef48 <tcp_receive+0xcf4>)
 800edee:	685b      	ldr	r3, [r3, #4]
 800edf0:	891b      	ldrh	r3, [r3, #8]
 800edf2:	2b00      	cmp	r3, #0
 800edf4:	d006      	beq.n	800ee04 <tcp_receive+0xbb0>
          recv_data = inseg.p;
 800edf6:	4b54      	ldr	r3, [pc, #336]	; (800ef48 <tcp_receive+0xcf4>)
 800edf8:	685a      	ldr	r2, [r3, #4]
 800edfa:	4b59      	ldr	r3, [pc, #356]	; (800ef60 <tcp_receive+0xd0c>)
 800edfc:	601a      	str	r2, [r3, #0]
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
 800edfe:	4b52      	ldr	r3, [pc, #328]	; (800ef48 <tcp_receive+0xcf4>)
 800ee00:	2200      	movs	r2, #0
 800ee02:	605a      	str	r2, [r3, #4]
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 800ee04:	4b50      	ldr	r3, [pc, #320]	; (800ef48 <tcp_receive+0xcf4>)
 800ee06:	691b      	ldr	r3, [r3, #16]
 800ee08:	7b1a      	ldrb	r2, [r3, #12]
 800ee0a:	7b5b      	ldrb	r3, [r3, #13]
 800ee0c:	021b      	lsls	r3, r3, #8
 800ee0e:	4313      	orrs	r3, r2
 800ee10:	b29b      	uxth	r3, r3
 800ee12:	0018      	movs	r0, r3
 800ee14:	f7f8 f86e 	bl	8006ef4 <lwip_htons>
 800ee18:	0003      	movs	r3, r0
 800ee1a:	b2db      	uxtb	r3, r3
 800ee1c:	001a      	movs	r2, r3
 800ee1e:	2301      	movs	r3, #1
 800ee20:	4013      	ands	r3, r2
 800ee22:	d100      	bne.n	800ee26 <tcp_receive+0xbd2>
 800ee24:	e0d1      	b.n	800efca <tcp_receive+0xd76>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags |= TF_GOT_FIN;
 800ee26:	4b4f      	ldr	r3, [pc, #316]	; (800ef64 <tcp_receive+0xd10>)
 800ee28:	781b      	ldrb	r3, [r3, #0]
 800ee2a:	2220      	movs	r2, #32
 800ee2c:	4313      	orrs	r3, r2
 800ee2e:	b2da      	uxtb	r2, r3
 800ee30:	4b4c      	ldr	r3, [pc, #304]	; (800ef64 <tcp_receive+0xd10>)
 800ee32:	701a      	strb	r2, [r3, #0]
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
 800ee34:	e0c9      	b.n	800efca <tcp_receive+0xd76>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          struct tcp_seg *cseg = pcb->ooseq;
 800ee36:	687b      	ldr	r3, [r7, #4]
 800ee38:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800ee3a:	60bb      	str	r3, [r7, #8]
          seqno = pcb->ooseq->tcphdr->seqno;
 800ee3c:	687b      	ldr	r3, [r7, #4]
 800ee3e:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800ee40:	691b      	ldr	r3, [r3, #16]
 800ee42:	791a      	ldrb	r2, [r3, #4]
 800ee44:	7959      	ldrb	r1, [r3, #5]
 800ee46:	0209      	lsls	r1, r1, #8
 800ee48:	430a      	orrs	r2, r1
 800ee4a:	7999      	ldrb	r1, [r3, #6]
 800ee4c:	0409      	lsls	r1, r1, #16
 800ee4e:	430a      	orrs	r2, r1
 800ee50:	79db      	ldrb	r3, [r3, #7]
 800ee52:	061b      	lsls	r3, r3, #24
 800ee54:	4313      	orrs	r3, r2
 800ee56:	001a      	movs	r2, r3
 800ee58:	4b3a      	ldr	r3, [pc, #232]	; (800ef44 <tcp_receive+0xcf0>)
 800ee5a:	601a      	str	r2, [r3, #0]

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
 800ee5c:	68bb      	ldr	r3, [r7, #8]
 800ee5e:	891b      	ldrh	r3, [r3, #8]
 800ee60:	001c      	movs	r4, r3
 800ee62:	68bb      	ldr	r3, [r7, #8]
 800ee64:	691b      	ldr	r3, [r3, #16]
 800ee66:	7b1a      	ldrb	r2, [r3, #12]
 800ee68:	7b5b      	ldrb	r3, [r3, #13]
 800ee6a:	021b      	lsls	r3, r3, #8
 800ee6c:	4313      	orrs	r3, r2
 800ee6e:	b29b      	uxth	r3, r3
 800ee70:	0018      	movs	r0, r3
 800ee72:	f7f8 f83f 	bl	8006ef4 <lwip_htons>
 800ee76:	0003      	movs	r3, r0
 800ee78:	b2db      	uxtb	r3, r3
 800ee7a:	001a      	movs	r2, r3
 800ee7c:	2303      	movs	r3, #3
 800ee7e:	4013      	ands	r3, r2
 800ee80:	d001      	beq.n	800ee86 <tcp_receive+0xc32>
 800ee82:	2301      	movs	r3, #1
 800ee84:	e000      	b.n	800ee88 <tcp_receive+0xc34>
 800ee86:	2300      	movs	r3, #0
 800ee88:	191a      	adds	r2, r3, r4
 800ee8a:	687b      	ldr	r3, [r7, #4]
 800ee8c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ee8e:	18d2      	adds	r2, r2, r3
 800ee90:	687b      	ldr	r3, [r7, #4]
 800ee92:	629a      	str	r2, [r3, #40]	; 0x28
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
 800ee94:	687b      	ldr	r3, [r7, #4]
 800ee96:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 800ee98:	001c      	movs	r4, r3
 800ee9a:	68bb      	ldr	r3, [r7, #8]
 800ee9c:	891b      	ldrh	r3, [r3, #8]
 800ee9e:	001d      	movs	r5, r3
 800eea0:	68bb      	ldr	r3, [r7, #8]
 800eea2:	691b      	ldr	r3, [r3, #16]
 800eea4:	7b1a      	ldrb	r2, [r3, #12]
 800eea6:	7b5b      	ldrb	r3, [r3, #13]
 800eea8:	021b      	lsls	r3, r3, #8
 800eeaa:	4313      	orrs	r3, r2
 800eeac:	b29b      	uxth	r3, r3
 800eeae:	0018      	movs	r0, r3
 800eeb0:	f7f8 f820 	bl	8006ef4 <lwip_htons>
 800eeb4:	0003      	movs	r3, r0
 800eeb6:	b2db      	uxtb	r3, r3
 800eeb8:	001a      	movs	r2, r3
 800eeba:	2303      	movs	r3, #3
 800eebc:	4013      	ands	r3, r2
 800eebe:	d001      	beq.n	800eec4 <tcp_receive+0xc70>
 800eec0:	2301      	movs	r3, #1
 800eec2:	e000      	b.n	800eec6 <tcp_receive+0xc72>
 800eec4:	2300      	movs	r3, #0
 800eec6:	195b      	adds	r3, r3, r5
 800eec8:	429c      	cmp	r4, r3
 800eeca:	d205      	bcs.n	800eed8 <tcp_receive+0xc84>
 800eecc:	4b1f      	ldr	r3, [pc, #124]	; (800ef4c <tcp_receive+0xcf8>)
 800eece:	4a26      	ldr	r2, [pc, #152]	; (800ef68 <tcp_receive+0xd14>)
 800eed0:	4926      	ldr	r1, [pc, #152]	; (800ef6c <tcp_receive+0xd18>)
 800eed2:	4821      	ldr	r0, [pc, #132]	; (800ef58 <tcp_receive+0xd04>)
 800eed4:	f7f3 fe78 	bl	8002bc8 <app_debug_rtt_raw>
                      pcb->rcv_wnd >= TCP_TCPLEN(cseg));
          pcb->rcv_wnd -= TCP_TCPLEN(cseg);
 800eed8:	68bb      	ldr	r3, [r7, #8]
 800eeda:	891b      	ldrh	r3, [r3, #8]
 800eedc:	001c      	movs	r4, r3
 800eede:	68bb      	ldr	r3, [r7, #8]
 800eee0:	691b      	ldr	r3, [r3, #16]
 800eee2:	7b1a      	ldrb	r2, [r3, #12]
 800eee4:	7b5b      	ldrb	r3, [r3, #13]
 800eee6:	021b      	lsls	r3, r3, #8
 800eee8:	4313      	orrs	r3, r2
 800eeea:	b29b      	uxth	r3, r3
 800eeec:	0018      	movs	r0, r3
 800eeee:	f7f8 f801 	bl	8006ef4 <lwip_htons>
 800eef2:	0003      	movs	r3, r0
 800eef4:	b2db      	uxtb	r3, r3
 800eef6:	001a      	movs	r2, r3
 800eef8:	2303      	movs	r3, #3
 800eefa:	4013      	ands	r3, r2
 800eefc:	d001      	beq.n	800ef02 <tcp_receive+0xcae>
 800eefe:	2301      	movs	r3, #1
 800ef00:	e000      	b.n	800ef04 <tcp_receive+0xcb0>
 800ef02:	2300      	movs	r3, #0
 800ef04:	1919      	adds	r1, r3, r4
 800ef06:	687b      	ldr	r3, [r7, #4]
 800ef08:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800ef0a:	b28b      	uxth	r3, r1
 800ef0c:	1ad3      	subs	r3, r2, r3
 800ef0e:	b29a      	uxth	r2, r3
 800ef10:	687b      	ldr	r3, [r7, #4]
 800ef12:	859a      	strh	r2, [r3, #44]	; 0x2c

          tcp_update_rcv_ann_wnd(pcb);
 800ef14:	687b      	ldr	r3, [r7, #4]
 800ef16:	0018      	movs	r0, r3
 800ef18:	f7fc f94a 	bl	800b1b0 <tcp_update_rcv_ann_wnd>

          if (cseg->p->tot_len > 0) {
 800ef1c:	68bb      	ldr	r3, [r7, #8]
 800ef1e:	685b      	ldr	r3, [r3, #4]
 800ef20:	891b      	ldrh	r3, [r3, #8]
 800ef22:	2b00      	cmp	r3, #0
 800ef24:	d02b      	beq.n	800ef7e <tcp_receive+0xd2a>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            /* With window scaling, this can overflow recv_data->tot_len, but
               that's not a problem since we explicitly fix that before passing
               recv_data to the application. */
            if (recv_data) {
 800ef26:	4b0e      	ldr	r3, [pc, #56]	; (800ef60 <tcp_receive+0xd0c>)
 800ef28:	681b      	ldr	r3, [r3, #0]
 800ef2a:	2b00      	cmp	r3, #0
 800ef2c:	d020      	beq.n	800ef70 <tcp_receive+0xd1c>
              pbuf_cat(recv_data, cseg->p);
 800ef2e:	4b0c      	ldr	r3, [pc, #48]	; (800ef60 <tcp_receive+0xd0c>)
 800ef30:	681a      	ldr	r2, [r3, #0]
 800ef32:	68bb      	ldr	r3, [r7, #8]
 800ef34:	685b      	ldr	r3, [r3, #4]
 800ef36:	0019      	movs	r1, r3
 800ef38:	0010      	movs	r0, r2
 800ef3a:	f7fb f89f 	bl	800a07c <pbuf_cat>
 800ef3e:	e01b      	b.n	800ef78 <tcp_receive+0xd24>
 800ef40:	200017c2 	.word	0x200017c2
 800ef44:	200017b8 	.word	0x200017b8
 800ef48:	20001794 	.word	0x20001794
 800ef4c:	080205bc 	.word	0x080205bc
 800ef50:	000005fd 	.word	0x000005fd
 800ef54:	08020994 	.word	0x08020994
 800ef58:	080205fc 	.word	0x080205fc
 800ef5c:	080209d0 	.word	0x080209d0
 800ef60:	200017c8 	.word	0x200017c8
 800ef64:	200017c5 	.word	0x200017c5
 800ef68:	0000062c 	.word	0x0000062c
 800ef6c:	080209f0 	.word	0x080209f0
            } else {
              recv_data = cseg->p;
 800ef70:	68bb      	ldr	r3, [r7, #8]
 800ef72:	685a      	ldr	r2, [r3, #4]
 800ef74:	4b9a      	ldr	r3, [pc, #616]	; (800f1e0 <tcp_receive+0xf8c>)
 800ef76:	601a      	str	r2, [r3, #0]
            }
            cseg->p = NULL;
 800ef78:	68bb      	ldr	r3, [r7, #8]
 800ef7a:	2200      	movs	r2, #0
 800ef7c:	605a      	str	r2, [r3, #4]
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 800ef7e:	68bb      	ldr	r3, [r7, #8]
 800ef80:	691b      	ldr	r3, [r3, #16]
 800ef82:	7b1a      	ldrb	r2, [r3, #12]
 800ef84:	7b5b      	ldrb	r3, [r3, #13]
 800ef86:	021b      	lsls	r3, r3, #8
 800ef88:	4313      	orrs	r3, r2
 800ef8a:	b29b      	uxth	r3, r3
 800ef8c:	0018      	movs	r0, r3
 800ef8e:	f7f7 ffb1 	bl	8006ef4 <lwip_htons>
 800ef92:	0003      	movs	r3, r0
 800ef94:	b2db      	uxtb	r3, r3
 800ef96:	001a      	movs	r2, r3
 800ef98:	2301      	movs	r3, #1
 800ef9a:	4013      	ands	r3, r2
 800ef9c:	d00d      	beq.n	800efba <tcp_receive+0xd66>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags |= TF_GOT_FIN;
 800ef9e:	4b91      	ldr	r3, [pc, #580]	; (800f1e4 <tcp_receive+0xf90>)
 800efa0:	781b      	ldrb	r3, [r3, #0]
 800efa2:	2220      	movs	r2, #32
 800efa4:	4313      	orrs	r3, r2
 800efa6:	b2da      	uxtb	r2, r3
 800efa8:	4b8e      	ldr	r3, [pc, #568]	; (800f1e4 <tcp_receive+0xf90>)
 800efaa:	701a      	strb	r2, [r3, #0]
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
 800efac:	687b      	ldr	r3, [r7, #4]
 800efae:	7e1b      	ldrb	r3, [r3, #24]
 800efb0:	2b04      	cmp	r3, #4
 800efb2:	d102      	bne.n	800efba <tcp_receive+0xd66>
              pcb->state = CLOSE_WAIT;
 800efb4:	687b      	ldr	r3, [r7, #4]
 800efb6:	2207      	movs	r2, #7
 800efb8:	761a      	strb	r2, [r3, #24]
            }
          }

          pcb->ooseq = cseg->next;
 800efba:	68bb      	ldr	r3, [r7, #8]
 800efbc:	681a      	ldr	r2, [r3, #0]
 800efbe:	687b      	ldr	r3, [r7, #4]
 800efc0:	679a      	str	r2, [r3, #120]	; 0x78
          tcp_seg_free(cseg);
 800efc2:	68bb      	ldr	r3, [r7, #8]
 800efc4:	0018      	movs	r0, r3
 800efc6:	f7fc ffe5 	bl	800bf94 <tcp_seg_free>
        while (pcb->ooseq != NULL &&
 800efca:	687b      	ldr	r3, [r7, #4]
 800efcc:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800efce:	2b00      	cmp	r3, #0
 800efd0:	d012      	beq.n	800eff8 <tcp_receive+0xda4>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
 800efd2:	687b      	ldr	r3, [r7, #4]
 800efd4:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800efd6:	691b      	ldr	r3, [r3, #16]
 800efd8:	791a      	ldrb	r2, [r3, #4]
 800efda:	7959      	ldrb	r1, [r3, #5]
 800efdc:	0209      	lsls	r1, r1, #8
 800efde:	430a      	orrs	r2, r1
 800efe0:	7999      	ldrb	r1, [r3, #6]
 800efe2:	0409      	lsls	r1, r1, #16
 800efe4:	430a      	orrs	r2, r1
 800efe6:	79db      	ldrb	r3, [r3, #7]
 800efe8:	061b      	lsls	r3, r3, #24
 800efea:	4313      	orrs	r3, r2
 800efec:	001a      	movs	r2, r3
 800efee:	687b      	ldr	r3, [r7, #4]
 800eff0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
        while (pcb->ooseq != NULL &&
 800eff2:	429a      	cmp	r2, r3
 800eff4:	d100      	bne.n	800eff8 <tcp_receive+0xda4>
 800eff6:	e71e      	b.n	800ee36 <tcp_receive+0xbe2>
#endif /* LWIP_TCP_SACK_OUT */
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
 800eff8:	687b      	ldr	r3, [r7, #4]
 800effa:	8bdb      	ldrh	r3, [r3, #30]
 800effc:	001a      	movs	r2, r3
 800effe:	2301      	movs	r3, #1
 800f000:	4013      	ands	r3, r2
 800f002:	d00e      	beq.n	800f022 <tcp_receive+0xdce>
 800f004:	687b      	ldr	r3, [r7, #4]
 800f006:	8bdb      	ldrh	r3, [r3, #30]
 800f008:	2201      	movs	r2, #1
 800f00a:	4393      	bics	r3, r2
 800f00c:	b29a      	uxth	r2, r3
 800f00e:	687b      	ldr	r3, [r7, #4]
 800f010:	83da      	strh	r2, [r3, #30]
 800f012:	687b      	ldr	r3, [r7, #4]
 800f014:	8bdb      	ldrh	r3, [r3, #30]
 800f016:	2202      	movs	r2, #2
 800f018:	4313      	orrs	r3, r2
 800f01a:	b29a      	uxth	r2, r3
 800f01c:	687b      	ldr	r3, [r7, #4]
 800f01e:	83da      	strh	r2, [r3, #30]
      if (pcb->rcv_nxt == seqno) {
 800f020:	e20d      	b.n	800f43e <tcp_receive+0x11ea>
        tcp_ack(pcb);
 800f022:	687b      	ldr	r3, [r7, #4]
 800f024:	8bdb      	ldrh	r3, [r3, #30]
 800f026:	2201      	movs	r2, #1
 800f028:	4313      	orrs	r3, r2
 800f02a:	b29a      	uxth	r2, r3
 800f02c:	687b      	ldr	r3, [r7, #4]
 800f02e:	83da      	strh	r2, [r3, #30]
      if (pcb->rcv_nxt == seqno) {
 800f030:	e205      	b.n	800f43e <tcp_receive+0x11ea>
      } else {
        /* We get here if the incoming segment is out-of-sequence. */

#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
 800f032:	687b      	ldr	r3, [r7, #4]
 800f034:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800f036:	2b00      	cmp	r3, #0
 800f038:	d107      	bne.n	800f04a <tcp_receive+0xdf6>
          pcb->ooseq = tcp_seg_copy(&inseg);
 800f03a:	4b6b      	ldr	r3, [pc, #428]	; (800f1e8 <tcp_receive+0xf94>)
 800f03c:	0018      	movs	r0, r3
 800f03e:	f7fc ffc3 	bl	800bfc8 <tcp_seg_copy>
 800f042:	0002      	movs	r2, r0
 800f044:	687b      	ldr	r3, [r7, #4]
 800f046:	679a      	str	r2, [r3, #120]	; 0x78
 800f048:	e1ef      	b.n	800f42a <tcp_receive+0x11d6>
#if LWIP_TCP_SACK_OUT
          /* This is the left edge of the lowest possible SACK range.
             It may start before the newly received segment (possibly adjusted below). */
          u32_t sackbeg = TCP_SEQ_LT(seqno, pcb->ooseq->tcphdr->seqno) ? seqno : pcb->ooseq->tcphdr->seqno;
#endif /* LWIP_TCP_SACK_OUT */
          struct tcp_seg *next, *prev = NULL;
 800f04a:	2300      	movs	r3, #0
 800f04c:	637b      	str	r3, [r7, #52]	; 0x34
          for (next = pcb->ooseq; next != NULL; next = next->next) {
 800f04e:	687b      	ldr	r3, [r7, #4]
 800f050:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800f052:	63bb      	str	r3, [r7, #56]	; 0x38
 800f054:	e1d9      	b.n	800f40a <tcp_receive+0x11b6>
            if (seqno == next->tcphdr->seqno) {
 800f056:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f058:	691b      	ldr	r3, [r3, #16]
 800f05a:	791a      	ldrb	r2, [r3, #4]
 800f05c:	7959      	ldrb	r1, [r3, #5]
 800f05e:	0209      	lsls	r1, r1, #8
 800f060:	430a      	orrs	r2, r1
 800f062:	7999      	ldrb	r1, [r3, #6]
 800f064:	0409      	lsls	r1, r1, #16
 800f066:	430a      	orrs	r2, r1
 800f068:	79db      	ldrb	r3, [r3, #7]
 800f06a:	061b      	lsls	r3, r3, #24
 800f06c:	4313      	orrs	r3, r2
 800f06e:	001a      	movs	r2, r3
 800f070:	4b5e      	ldr	r3, [pc, #376]	; (800f1ec <tcp_receive+0xf98>)
 800f072:	681b      	ldr	r3, [r3, #0]
 800f074:	429a      	cmp	r2, r3
 800f076:	d121      	bne.n	800f0bc <tcp_receive+0xe68>
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
 800f078:	4b5b      	ldr	r3, [pc, #364]	; (800f1e8 <tcp_receive+0xf94>)
 800f07a:	891a      	ldrh	r2, [r3, #8]
 800f07c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f07e:	891b      	ldrh	r3, [r3, #8]
 800f080:	429a      	cmp	r2, r3
 800f082:	d800      	bhi.n	800f086 <tcp_receive+0xe32>
 800f084:	e1c6      	b.n	800f414 <tcp_receive+0x11c0>
                /* The incoming segment is larger than the old
                   segment. We replace some segments with the new
                   one. */
                struct tcp_seg *cseg = tcp_seg_copy(&inseg);
 800f086:	4b58      	ldr	r3, [pc, #352]	; (800f1e8 <tcp_receive+0xf94>)
 800f088:	0018      	movs	r0, r3
 800f08a:	f7fc ff9d 	bl	800bfc8 <tcp_seg_copy>
 800f08e:	0003      	movs	r3, r0
 800f090:	617b      	str	r3, [r7, #20]
                if (cseg != NULL) {
 800f092:	697b      	ldr	r3, [r7, #20]
 800f094:	2b00      	cmp	r3, #0
 800f096:	d100      	bne.n	800f09a <tcp_receive+0xe46>
 800f098:	e1be      	b.n	800f418 <tcp_receive+0x11c4>
                  if (prev != NULL) {
 800f09a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f09c:	2b00      	cmp	r3, #0
 800f09e:	d003      	beq.n	800f0a8 <tcp_receive+0xe54>
                    prev->next = cseg;
 800f0a0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f0a2:	697a      	ldr	r2, [r7, #20]
 800f0a4:	601a      	str	r2, [r3, #0]
 800f0a6:	e002      	b.n	800f0ae <tcp_receive+0xe5a>
                  } else {
                    pcb->ooseq = cseg;
 800f0a8:	687b      	ldr	r3, [r7, #4]
 800f0aa:	697a      	ldr	r2, [r7, #20]
 800f0ac:	679a      	str	r2, [r3, #120]	; 0x78
                  }
                  tcp_oos_insert_segment(cseg, next);
 800f0ae:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800f0b0:	697b      	ldr	r3, [r7, #20]
 800f0b2:	0011      	movs	r1, r2
 800f0b4:	0018      	movs	r0, r3
 800f0b6:	f7fe ff7d 	bl	800dfb4 <tcp_oos_insert_segment>
                }
                break;
 800f0ba:	e1ad      	b.n	800f418 <tcp_receive+0x11c4>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
 800f0bc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f0be:	2b00      	cmp	r3, #0
 800f0c0:	d124      	bne.n	800f10c <tcp_receive+0xeb8>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
 800f0c2:	4b4a      	ldr	r3, [pc, #296]	; (800f1ec <tcp_receive+0xf98>)
 800f0c4:	681a      	ldr	r2, [r3, #0]
 800f0c6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f0c8:	691b      	ldr	r3, [r3, #16]
 800f0ca:	7919      	ldrb	r1, [r3, #4]
 800f0cc:	7958      	ldrb	r0, [r3, #5]
 800f0ce:	0200      	lsls	r0, r0, #8
 800f0d0:	4301      	orrs	r1, r0
 800f0d2:	7998      	ldrb	r0, [r3, #6]
 800f0d4:	0400      	lsls	r0, r0, #16
 800f0d6:	4301      	orrs	r1, r0
 800f0d8:	79db      	ldrb	r3, [r3, #7]
 800f0da:	061b      	lsls	r3, r3, #24
 800f0dc:	430b      	orrs	r3, r1
 800f0de:	1ad3      	subs	r3, r2, r3
 800f0e0:	d400      	bmi.n	800f0e4 <tcp_receive+0xe90>
 800f0e2:	e085      	b.n	800f1f0 <tcp_receive+0xf9c>
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */
                  struct tcp_seg *cseg = tcp_seg_copy(&inseg);
 800f0e4:	4b40      	ldr	r3, [pc, #256]	; (800f1e8 <tcp_receive+0xf94>)
 800f0e6:	0018      	movs	r0, r3
 800f0e8:	f7fc ff6e 	bl	800bfc8 <tcp_seg_copy>
 800f0ec:	0003      	movs	r3, r0
 800f0ee:	61bb      	str	r3, [r7, #24]
                  if (cseg != NULL) {
 800f0f0:	69bb      	ldr	r3, [r7, #24]
 800f0f2:	2b00      	cmp	r3, #0
 800f0f4:	d100      	bne.n	800f0f8 <tcp_receive+0xea4>
 800f0f6:	e191      	b.n	800f41c <tcp_receive+0x11c8>
                    pcb->ooseq = cseg;
 800f0f8:	687b      	ldr	r3, [r7, #4]
 800f0fa:	69ba      	ldr	r2, [r7, #24]
 800f0fc:	679a      	str	r2, [r3, #120]	; 0x78
                    tcp_oos_insert_segment(cseg, next);
 800f0fe:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800f100:	69bb      	ldr	r3, [r7, #24]
 800f102:	0011      	movs	r1, r2
 800f104:	0018      	movs	r0, r3
 800f106:	f7fe ff55 	bl	800dfb4 <tcp_oos_insert_segment>
                  }
                  break;
 800f10a:	e187      	b.n	800f41c <tcp_receive+0x11c8>
                }
              } else {
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno + 1, next->tcphdr->seqno - 1)) {
 800f10c:	4b37      	ldr	r3, [pc, #220]	; (800f1ec <tcp_receive+0xf98>)
 800f10e:	681a      	ldr	r2, [r3, #0]
 800f110:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f112:	691b      	ldr	r3, [r3, #16]
 800f114:	7919      	ldrb	r1, [r3, #4]
 800f116:	7958      	ldrb	r0, [r3, #5]
 800f118:	0200      	lsls	r0, r0, #8
 800f11a:	4301      	orrs	r1, r0
 800f11c:	7998      	ldrb	r0, [r3, #6]
 800f11e:	0400      	lsls	r0, r0, #16
 800f120:	4301      	orrs	r1, r0
 800f122:	79db      	ldrb	r3, [r3, #7]
 800f124:	061b      	lsls	r3, r3, #24
 800f126:	430b      	orrs	r3, r1
 800f128:	1ad3      	subs	r3, r2, r3
 800f12a:	3b01      	subs	r3, #1
 800f12c:	2b00      	cmp	r3, #0
 800f12e:	db5f      	blt.n	800f1f0 <tcp_receive+0xf9c>
 800f130:	4b2e      	ldr	r3, [pc, #184]	; (800f1ec <tcp_receive+0xf98>)
 800f132:	681a      	ldr	r2, [r3, #0]
 800f134:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f136:	691b      	ldr	r3, [r3, #16]
 800f138:	7919      	ldrb	r1, [r3, #4]
 800f13a:	7958      	ldrb	r0, [r3, #5]
 800f13c:	0200      	lsls	r0, r0, #8
 800f13e:	4301      	orrs	r1, r0
 800f140:	7998      	ldrb	r0, [r3, #6]
 800f142:	0400      	lsls	r0, r0, #16
 800f144:	4301      	orrs	r1, r0
 800f146:	79db      	ldrb	r3, [r3, #7]
 800f148:	061b      	lsls	r3, r3, #24
 800f14a:	430b      	orrs	r3, r1
 800f14c:	1ad3      	subs	r3, r2, r3
 800f14e:	3301      	adds	r3, #1
 800f150:	2b00      	cmp	r3, #0
 800f152:	dc4d      	bgt.n	800f1f0 <tcp_receive+0xf9c>
                  /* The sequence number of the incoming segment is in
                     between the sequence numbers of the previous and
                     the next segment on ->ooseq. We trim trim the previous
                     segment, delete next segments that included in received segment
                     and trim received, if needed. */
                  struct tcp_seg *cseg = tcp_seg_copy(&inseg);
 800f154:	4b24      	ldr	r3, [pc, #144]	; (800f1e8 <tcp_receive+0xf94>)
 800f156:	0018      	movs	r0, r3
 800f158:	f7fc ff36 	bl	800bfc8 <tcp_seg_copy>
 800f15c:	0003      	movs	r3, r0
 800f15e:	61fb      	str	r3, [r7, #28]
                  if (cseg != NULL) {
 800f160:	69fb      	ldr	r3, [r7, #28]
 800f162:	2b00      	cmp	r3, #0
 800f164:	d100      	bne.n	800f168 <tcp_receive+0xf14>
 800f166:	e15b      	b.n	800f420 <tcp_receive+0x11cc>
                    if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
 800f168:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f16a:	691b      	ldr	r3, [r3, #16]
 800f16c:	791a      	ldrb	r2, [r3, #4]
 800f16e:	7959      	ldrb	r1, [r3, #5]
 800f170:	0209      	lsls	r1, r1, #8
 800f172:	430a      	orrs	r2, r1
 800f174:	7999      	ldrb	r1, [r3, #6]
 800f176:	0409      	lsls	r1, r1, #16
 800f178:	430a      	orrs	r2, r1
 800f17a:	79db      	ldrb	r3, [r3, #7]
 800f17c:	061b      	lsls	r3, r3, #24
 800f17e:	4313      	orrs	r3, r2
 800f180:	001a      	movs	r2, r3
 800f182:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f184:	891b      	ldrh	r3, [r3, #8]
 800f186:	18d2      	adds	r2, r2, r3
 800f188:	4b18      	ldr	r3, [pc, #96]	; (800f1ec <tcp_receive+0xf98>)
 800f18a:	681b      	ldr	r3, [r3, #0]
 800f18c:	1ad3      	subs	r3, r2, r3
 800f18e:	2b00      	cmp	r3, #0
 800f190:	dd1b      	ble.n	800f1ca <tcp_receive+0xf76>
                      /* We need to trim the prev segment. */
                      prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
 800f192:	4b16      	ldr	r3, [pc, #88]	; (800f1ec <tcp_receive+0xf98>)
 800f194:	681b      	ldr	r3, [r3, #0]
 800f196:	b29a      	uxth	r2, r3
 800f198:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f19a:	691b      	ldr	r3, [r3, #16]
 800f19c:	7919      	ldrb	r1, [r3, #4]
 800f19e:	7958      	ldrb	r0, [r3, #5]
 800f1a0:	0200      	lsls	r0, r0, #8
 800f1a2:	4301      	orrs	r1, r0
 800f1a4:	7998      	ldrb	r0, [r3, #6]
 800f1a6:	0400      	lsls	r0, r0, #16
 800f1a8:	4301      	orrs	r1, r0
 800f1aa:	79db      	ldrb	r3, [r3, #7]
 800f1ac:	061b      	lsls	r3, r3, #24
 800f1ae:	430b      	orrs	r3, r1
 800f1b0:	b29b      	uxth	r3, r3
 800f1b2:	1ad3      	subs	r3, r2, r3
 800f1b4:	b29a      	uxth	r2, r3
 800f1b6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f1b8:	811a      	strh	r2, [r3, #8]
                      pbuf_realloc(prev->p, prev->len);
 800f1ba:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f1bc:	685a      	ldr	r2, [r3, #4]
 800f1be:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f1c0:	891b      	ldrh	r3, [r3, #8]
 800f1c2:	0019      	movs	r1, r3
 800f1c4:	0010      	movs	r0, r2
 800f1c6:	f7fa fc7f 	bl	8009ac8 <pbuf_realloc>
                    }
                    prev->next = cseg;
 800f1ca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f1cc:	69fa      	ldr	r2, [r7, #28]
 800f1ce:	601a      	str	r2, [r3, #0]
                    tcp_oos_insert_segment(cseg, next);
 800f1d0:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800f1d2:	69fb      	ldr	r3, [r7, #28]
 800f1d4:	0011      	movs	r1, r2
 800f1d6:	0018      	movs	r0, r3
 800f1d8:	f7fe feec 	bl	800dfb4 <tcp_oos_insert_segment>
                  }
                  break;
 800f1dc:	e120      	b.n	800f420 <tcp_receive+0x11cc>
 800f1de:	46c0      	nop			; (mov r8, r8)
 800f1e0:	200017c8 	.word	0x200017c8
 800f1e4:	200017c5 	.word	0x200017c5
 800f1e8:	20001794 	.word	0x20001794
 800f1ec:	200017b8 	.word	0x200017b8
#endif /* LWIP_TCP_SACK_OUT */

              /* We don't use 'prev' below, so let's set it to current 'next'.
                 This way even if we break the loop below, 'prev' will be pointing
                 at the segment right in front of the newly added one. */
              prev = next;
 800f1f0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f1f2:	637b      	str	r3, [r7, #52]	; 0x34

              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
 800f1f4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f1f6:	681b      	ldr	r3, [r3, #0]
 800f1f8:	2b00      	cmp	r3, #0
 800f1fa:	d000      	beq.n	800f1fe <tcp_receive+0xfaa>
 800f1fc:	e102      	b.n	800f404 <tcp_receive+0x11b0>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
 800f1fe:	4b9f      	ldr	r3, [pc, #636]	; (800f47c <tcp_receive+0x1228>)
 800f200:	681a      	ldr	r2, [r3, #0]
 800f202:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f204:	691b      	ldr	r3, [r3, #16]
 800f206:	7919      	ldrb	r1, [r3, #4]
 800f208:	7958      	ldrb	r0, [r3, #5]
 800f20a:	0200      	lsls	r0, r0, #8
 800f20c:	4301      	orrs	r1, r0
 800f20e:	7998      	ldrb	r0, [r3, #6]
 800f210:	0400      	lsls	r0, r0, #16
 800f212:	4301      	orrs	r1, r0
 800f214:	79db      	ldrb	r3, [r3, #7]
 800f216:	061b      	lsls	r3, r3, #24
 800f218:	430b      	orrs	r3, r1
 800f21a:	1ad3      	subs	r3, r2, r3
              if (next->next == NULL &&
 800f21c:	2b00      	cmp	r3, #0
 800f21e:	dc00      	bgt.n	800f222 <tcp_receive+0xfce>
 800f220:	e0f0      	b.n	800f404 <tcp_receive+0x11b0>
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 800f222:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f224:	691b      	ldr	r3, [r3, #16]
 800f226:	7b1a      	ldrb	r2, [r3, #12]
 800f228:	7b5b      	ldrb	r3, [r3, #13]
 800f22a:	021b      	lsls	r3, r3, #8
 800f22c:	4313      	orrs	r3, r2
 800f22e:	b29b      	uxth	r3, r3
 800f230:	0018      	movs	r0, r3
 800f232:	f7f7 fe5f 	bl	8006ef4 <lwip_htons>
 800f236:	0003      	movs	r3, r0
 800f238:	b2db      	uxtb	r3, r3
 800f23a:	001a      	movs	r2, r3
 800f23c:	2301      	movs	r3, #1
 800f23e:	4013      	ands	r3, r2
 800f240:	d000      	beq.n	800f244 <tcp_receive+0xff0>
 800f242:	e0ef      	b.n	800f424 <tcp_receive+0x11d0>
                  /* segment "next" already contains all data */
                  break;
                }
                next->next = tcp_seg_copy(&inseg);
 800f244:	4b8e      	ldr	r3, [pc, #568]	; (800f480 <tcp_receive+0x122c>)
 800f246:	0018      	movs	r0, r3
 800f248:	f7fc febe 	bl	800bfc8 <tcp_seg_copy>
 800f24c:	0002      	movs	r2, r0
 800f24e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f250:	601a      	str	r2, [r3, #0]
                if (next->next != NULL) {
 800f252:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f254:	681b      	ldr	r3, [r3, #0]
 800f256:	2b00      	cmp	r3, #0
 800f258:	d100      	bne.n	800f25c <tcp_receive+0x1008>
 800f25a:	e0e5      	b.n	800f428 <tcp_receive+0x11d4>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
 800f25c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f25e:	691b      	ldr	r3, [r3, #16]
 800f260:	791a      	ldrb	r2, [r3, #4]
 800f262:	7959      	ldrb	r1, [r3, #5]
 800f264:	0209      	lsls	r1, r1, #8
 800f266:	430a      	orrs	r2, r1
 800f268:	7999      	ldrb	r1, [r3, #6]
 800f26a:	0409      	lsls	r1, r1, #16
 800f26c:	430a      	orrs	r2, r1
 800f26e:	79db      	ldrb	r3, [r3, #7]
 800f270:	061b      	lsls	r3, r3, #24
 800f272:	4313      	orrs	r3, r2
 800f274:	001a      	movs	r2, r3
 800f276:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f278:	891b      	ldrh	r3, [r3, #8]
 800f27a:	18d2      	adds	r2, r2, r3
 800f27c:	4b7f      	ldr	r3, [pc, #508]	; (800f47c <tcp_receive+0x1228>)
 800f27e:	681b      	ldr	r3, [r3, #0]
 800f280:	1ad3      	subs	r3, r2, r3
 800f282:	2b00      	cmp	r3, #0
 800f284:	dd1b      	ble.n	800f2be <tcp_receive+0x106a>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
 800f286:	4b7d      	ldr	r3, [pc, #500]	; (800f47c <tcp_receive+0x1228>)
 800f288:	681b      	ldr	r3, [r3, #0]
 800f28a:	b29a      	uxth	r2, r3
 800f28c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f28e:	691b      	ldr	r3, [r3, #16]
 800f290:	7919      	ldrb	r1, [r3, #4]
 800f292:	7958      	ldrb	r0, [r3, #5]
 800f294:	0200      	lsls	r0, r0, #8
 800f296:	4301      	orrs	r1, r0
 800f298:	7998      	ldrb	r0, [r3, #6]
 800f29a:	0400      	lsls	r0, r0, #16
 800f29c:	4301      	orrs	r1, r0
 800f29e:	79db      	ldrb	r3, [r3, #7]
 800f2a0:	061b      	lsls	r3, r3, #24
 800f2a2:	430b      	orrs	r3, r1
 800f2a4:	b29b      	uxth	r3, r3
 800f2a6:	1ad3      	subs	r3, r2, r3
 800f2a8:	b29a      	uxth	r2, r3
 800f2aa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f2ac:	811a      	strh	r2, [r3, #8]
                    pbuf_realloc(next->p, next->len);
 800f2ae:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f2b0:	685a      	ldr	r2, [r3, #4]
 800f2b2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f2b4:	891b      	ldrh	r3, [r3, #8]
 800f2b6:	0019      	movs	r1, r3
 800f2b8:	0010      	movs	r0, r2
 800f2ba:	f7fa fc05 	bl	8009ac8 <pbuf_realloc>
                  }
                  /* check if the remote side overruns our receive window */
                  if (TCP_SEQ_GT((u32_t)tcplen + seqno, pcb->rcv_nxt + (u32_t)pcb->rcv_wnd)) {
 800f2be:	4b71      	ldr	r3, [pc, #452]	; (800f484 <tcp_receive+0x1230>)
 800f2c0:	881b      	ldrh	r3, [r3, #0]
 800f2c2:	001a      	movs	r2, r3
 800f2c4:	4b6d      	ldr	r3, [pc, #436]	; (800f47c <tcp_receive+0x1228>)
 800f2c6:	681b      	ldr	r3, [r3, #0]
 800f2c8:	18d2      	adds	r2, r2, r3
 800f2ca:	687b      	ldr	r3, [r7, #4]
 800f2cc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800f2ce:	6879      	ldr	r1, [r7, #4]
 800f2d0:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
 800f2d2:	185b      	adds	r3, r3, r1
 800f2d4:	1ad3      	subs	r3, r2, r3
 800f2d6:	2b00      	cmp	r3, #0
 800f2d8:	dc00      	bgt.n	800f2dc <tcp_receive+0x1088>
 800f2da:	e0a5      	b.n	800f428 <tcp_receive+0x11d4>
                    LWIP_DEBUGF(TCP_INPUT_DEBUG,
                                ("tcp_receive: other end overran receive window"
                                 "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                                 seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
                    if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
 800f2dc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f2de:	681b      	ldr	r3, [r3, #0]
 800f2e0:	691b      	ldr	r3, [r3, #16]
 800f2e2:	7b1a      	ldrb	r2, [r3, #12]
 800f2e4:	7b5b      	ldrb	r3, [r3, #13]
 800f2e6:	021b      	lsls	r3, r3, #8
 800f2e8:	4313      	orrs	r3, r2
 800f2ea:	b29b      	uxth	r3, r3
 800f2ec:	0018      	movs	r0, r3
 800f2ee:	f7f7 fe01 	bl	8006ef4 <lwip_htons>
 800f2f2:	0003      	movs	r3, r0
 800f2f4:	b2db      	uxtb	r3, r3
 800f2f6:	001a      	movs	r2, r3
 800f2f8:	2301      	movs	r3, #1
 800f2fa:	4013      	ands	r3, r2
 800f2fc:	d03a      	beq.n	800f374 <tcp_receive+0x1120>
                      /* Must remove the FIN from the header as we're trimming
                       * that byte of sequence-space from the packet */
                      TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) & ~TCP_FIN);
 800f2fe:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f300:	681b      	ldr	r3, [r3, #0]
 800f302:	691b      	ldr	r3, [r3, #16]
 800f304:	7b1a      	ldrb	r2, [r3, #12]
 800f306:	7b5b      	ldrb	r3, [r3, #13]
 800f308:	021b      	lsls	r3, r3, #8
 800f30a:	4313      	orrs	r3, r2
 800f30c:	b29b      	uxth	r3, r3
 800f30e:	b21b      	sxth	r3, r3
 800f310:	4a5d      	ldr	r2, [pc, #372]	; (800f488 <tcp_receive+0x1234>)
 800f312:	4013      	ands	r3, r2
 800f314:	b21c      	sxth	r4, r3
 800f316:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f318:	681b      	ldr	r3, [r3, #0]
 800f31a:	691b      	ldr	r3, [r3, #16]
 800f31c:	7b1a      	ldrb	r2, [r3, #12]
 800f31e:	7b5b      	ldrb	r3, [r3, #13]
 800f320:	021b      	lsls	r3, r3, #8
 800f322:	4313      	orrs	r3, r2
 800f324:	b29b      	uxth	r3, r3
 800f326:	0018      	movs	r0, r3
 800f328:	f7f7 fde4 	bl	8006ef4 <lwip_htons>
 800f32c:	0003      	movs	r3, r0
 800f32e:	b2db      	uxtb	r3, r3
 800f330:	b29b      	uxth	r3, r3
 800f332:	223e      	movs	r2, #62	; 0x3e
 800f334:	4013      	ands	r3, r2
 800f336:	b29b      	uxth	r3, r3
 800f338:	0018      	movs	r0, r3
 800f33a:	f7f7 fddb 	bl	8006ef4 <lwip_htons>
 800f33e:	0003      	movs	r3, r0
 800f340:	b21b      	sxth	r3, r3
 800f342:	4323      	orrs	r3, r4
 800f344:	b21a      	sxth	r2, r3
 800f346:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f348:	681b      	ldr	r3, [r3, #0]
 800f34a:	691b      	ldr	r3, [r3, #16]
 800f34c:	b292      	uxth	r2, r2
 800f34e:	21ff      	movs	r1, #255	; 0xff
 800f350:	4011      	ands	r1, r2
 800f352:	000c      	movs	r4, r1
 800f354:	7b19      	ldrb	r1, [r3, #12]
 800f356:	2000      	movs	r0, #0
 800f358:	4001      	ands	r1, r0
 800f35a:	1c08      	adds	r0, r1, #0
 800f35c:	1c21      	adds	r1, r4, #0
 800f35e:	4301      	orrs	r1, r0
 800f360:	7319      	strb	r1, [r3, #12]
 800f362:	0a12      	lsrs	r2, r2, #8
 800f364:	b290      	uxth	r0, r2
 800f366:	7b5a      	ldrb	r2, [r3, #13]
 800f368:	2100      	movs	r1, #0
 800f36a:	400a      	ands	r2, r1
 800f36c:	1c11      	adds	r1, r2, #0
 800f36e:	1c02      	adds	r2, r0, #0
 800f370:	430a      	orrs	r2, r1
 800f372:	735a      	strb	r2, [r3, #13]
                    }
                    /* Adjust length of segment to fit in the window. */
                    next->next->len = (u16_t)(pcb->rcv_nxt + pcb->rcv_wnd - seqno);
 800f374:	687b      	ldr	r3, [r7, #4]
 800f376:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800f378:	b29a      	uxth	r2, r3
 800f37a:	687b      	ldr	r3, [r7, #4]
 800f37c:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 800f37e:	18d3      	adds	r3, r2, r3
 800f380:	b299      	uxth	r1, r3
 800f382:	4b3e      	ldr	r3, [pc, #248]	; (800f47c <tcp_receive+0x1228>)
 800f384:	681b      	ldr	r3, [r3, #0]
 800f386:	b29a      	uxth	r2, r3
 800f388:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f38a:	681b      	ldr	r3, [r3, #0]
 800f38c:	1a8a      	subs	r2, r1, r2
 800f38e:	b292      	uxth	r2, r2
 800f390:	811a      	strh	r2, [r3, #8]
                    pbuf_realloc(next->next->p, next->next->len);
 800f392:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f394:	681b      	ldr	r3, [r3, #0]
 800f396:	685a      	ldr	r2, [r3, #4]
 800f398:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f39a:	681b      	ldr	r3, [r3, #0]
 800f39c:	891b      	ldrh	r3, [r3, #8]
 800f39e:	0019      	movs	r1, r3
 800f3a0:	0010      	movs	r0, r2
 800f3a2:	f7fa fb91 	bl	8009ac8 <pbuf_realloc>
                    tcplen = TCP_TCPLEN(next->next);
 800f3a6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f3a8:	681b      	ldr	r3, [r3, #0]
 800f3aa:	891c      	ldrh	r4, [r3, #8]
 800f3ac:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f3ae:	681b      	ldr	r3, [r3, #0]
 800f3b0:	691b      	ldr	r3, [r3, #16]
 800f3b2:	7b1a      	ldrb	r2, [r3, #12]
 800f3b4:	7b5b      	ldrb	r3, [r3, #13]
 800f3b6:	021b      	lsls	r3, r3, #8
 800f3b8:	4313      	orrs	r3, r2
 800f3ba:	b29b      	uxth	r3, r3
 800f3bc:	0018      	movs	r0, r3
 800f3be:	f7f7 fd99 	bl	8006ef4 <lwip_htons>
 800f3c2:	0003      	movs	r3, r0
 800f3c4:	b2db      	uxtb	r3, r3
 800f3c6:	001a      	movs	r2, r3
 800f3c8:	2303      	movs	r3, #3
 800f3ca:	4013      	ands	r3, r2
 800f3cc:	d001      	beq.n	800f3d2 <tcp_receive+0x117e>
 800f3ce:	2301      	movs	r3, #1
 800f3d0:	e000      	b.n	800f3d4 <tcp_receive+0x1180>
 800f3d2:	2300      	movs	r3, #0
 800f3d4:	191b      	adds	r3, r3, r4
 800f3d6:	b29a      	uxth	r2, r3
 800f3d8:	4b2a      	ldr	r3, [pc, #168]	; (800f484 <tcp_receive+0x1230>)
 800f3da:	801a      	strh	r2, [r3, #0]
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 800f3dc:	4b29      	ldr	r3, [pc, #164]	; (800f484 <tcp_receive+0x1230>)
 800f3de:	881b      	ldrh	r3, [r3, #0]
 800f3e0:	001a      	movs	r2, r3
 800f3e2:	4b26      	ldr	r3, [pc, #152]	; (800f47c <tcp_receive+0x1228>)
 800f3e4:	681b      	ldr	r3, [r3, #0]
 800f3e6:	18d2      	adds	r2, r2, r3
 800f3e8:	687b      	ldr	r3, [r7, #4]
 800f3ea:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800f3ec:	6879      	ldr	r1, [r7, #4]
 800f3ee:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
 800f3f0:	185b      	adds	r3, r3, r1
 800f3f2:	429a      	cmp	r2, r3
 800f3f4:	d018      	beq.n	800f428 <tcp_receive+0x11d4>
 800f3f6:	4b25      	ldr	r3, [pc, #148]	; (800f48c <tcp_receive+0x1238>)
 800f3f8:	4a25      	ldr	r2, [pc, #148]	; (800f490 <tcp_receive+0x123c>)
 800f3fa:	4926      	ldr	r1, [pc, #152]	; (800f494 <tcp_receive+0x1240>)
 800f3fc:	4826      	ldr	r0, [pc, #152]	; (800f498 <tcp_receive+0x1244>)
 800f3fe:	f7f3 fbe3 	bl	8002bc8 <app_debug_rtt_raw>
                                (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
                  }
                }
                break;
 800f402:	e011      	b.n	800f428 <tcp_receive+0x11d4>
          for (next = pcb->ooseq; next != NULL; next = next->next) {
 800f404:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f406:	681b      	ldr	r3, [r3, #0]
 800f408:	63bb      	str	r3, [r7, #56]	; 0x38
 800f40a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f40c:	2b00      	cmp	r3, #0
 800f40e:	d000      	beq.n	800f412 <tcp_receive+0x11be>
 800f410:	e621      	b.n	800f056 <tcp_receive+0xe02>
 800f412:	e00a      	b.n	800f42a <tcp_receive+0x11d6>
                break;
 800f414:	46c0      	nop			; (mov r8, r8)
 800f416:	e008      	b.n	800f42a <tcp_receive+0x11d6>
                break;
 800f418:	46c0      	nop			; (mov r8, r8)
 800f41a:	e006      	b.n	800f42a <tcp_receive+0x11d6>
                  break;
 800f41c:	46c0      	nop			; (mov r8, r8)
 800f41e:	e004      	b.n	800f42a <tcp_receive+0x11d6>
                  break;
 800f420:	46c0      	nop			; (mov r8, r8)
 800f422:	e002      	b.n	800f42a <tcp_receive+0x11d6>
                  break;
 800f424:	46c0      	nop			; (mov r8, r8)
 800f426:	e000      	b.n	800f42a <tcp_receive+0x11d6>
                break;
 800f428:	46c0      	nop			; (mov r8, r8)
#endif /* TCP_OOSEQ_BYTES_LIMIT || TCP_OOSEQ_PBUFS_LIMIT */
#endif /* TCP_QUEUE_OOSEQ */

        /* We send the ACK packet after we've (potentially) dealt with SACKs,
           so they can be included in the acknowledgment. */
        tcp_send_empty_ack(pcb);
 800f42a:	687b      	ldr	r3, [r7, #4]
 800f42c:	0018      	movs	r0, r3
 800f42e:	f002 fd59 	bl	8011ee4 <tcp_send_empty_ack>
      if (pcb->rcv_nxt == seqno) {
 800f432:	e004      	b.n	800f43e <tcp_receive+0x11ea>
      }
    } else {
      /* The incoming segment is not within the window. */
      tcp_send_empty_ack(pcb);
 800f434:	687b      	ldr	r3, [r7, #4]
 800f436:	0018      	movs	r0, r3
 800f438:	f002 fd54 	bl	8011ee4 <tcp_send_empty_ack>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
 800f43c:	e019      	b.n	800f472 <tcp_receive+0x121e>
 800f43e:	e018      	b.n	800f472 <tcp_receive+0x121e>
    }
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    if (!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
 800f440:	4b0e      	ldr	r3, [pc, #56]	; (800f47c <tcp_receive+0x1228>)
 800f442:	681a      	ldr	r2, [r3, #0]
 800f444:	687b      	ldr	r3, [r7, #4]
 800f446:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800f448:	1ad3      	subs	r3, r2, r3
 800f44a:	d40a      	bmi.n	800f462 <tcp_receive+0x120e>
 800f44c:	4b0b      	ldr	r3, [pc, #44]	; (800f47c <tcp_receive+0x1228>)
 800f44e:	681a      	ldr	r2, [r3, #0]
 800f450:	687b      	ldr	r3, [r7, #4]
 800f452:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800f454:	6879      	ldr	r1, [r7, #4]
 800f456:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
 800f458:	185b      	adds	r3, r3, r1
 800f45a:	1ad3      	subs	r3, r2, r3
 800f45c:	3301      	adds	r3, #1
 800f45e:	2b00      	cmp	r3, #0
 800f460:	dd07      	ble.n	800f472 <tcp_receive+0x121e>
      tcp_ack_now(pcb);
 800f462:	687b      	ldr	r3, [r7, #4]
 800f464:	8bdb      	ldrh	r3, [r3, #30]
 800f466:	2202      	movs	r2, #2
 800f468:	4313      	orrs	r3, r2
 800f46a:	b29a      	uxth	r2, r3
 800f46c:	687b      	ldr	r3, [r7, #4]
 800f46e:	83da      	strh	r2, [r3, #30]
    }
  }
}
 800f470:	e7ff      	b.n	800f472 <tcp_receive+0x121e>
 800f472:	46c0      	nop			; (mov r8, r8)
 800f474:	46bd      	mov	sp, r7
 800f476:	b014      	add	sp, #80	; 0x50
 800f478:	bdb0      	pop	{r4, r5, r7, pc}
 800f47a:	46c0      	nop			; (mov r8, r8)
 800f47c:	200017b8 	.word	0x200017b8
 800f480:	20001794 	.word	0x20001794
 800f484:	200017c2 	.word	0x200017c2
 800f488:	ffffc0ff 	.word	0xffffc0ff
 800f48c:	080205bc 	.word	0x080205bc
 800f490:	000006f9 	.word	0x000006f9
 800f494:	0802095c 	.word	0x0802095c
 800f498:	080205fc 	.word	0x080205fc

0800f49c <tcp_get_next_optbyte>:

static u8_t
tcp_get_next_optbyte(void)
{
 800f49c:	b580      	push	{r7, lr}
 800f49e:	b082      	sub	sp, #8
 800f4a0:	af00      	add	r7, sp, #0
  u16_t optidx = tcp_optidx++;
 800f4a2:	4b17      	ldr	r3, [pc, #92]	; (800f500 <tcp_get_next_optbyte+0x64>)
 800f4a4:	881b      	ldrh	r3, [r3, #0]
 800f4a6:	1c5a      	adds	r2, r3, #1
 800f4a8:	b291      	uxth	r1, r2
 800f4aa:	4a15      	ldr	r2, [pc, #84]	; (800f500 <tcp_get_next_optbyte+0x64>)
 800f4ac:	8011      	strh	r1, [r2, #0]
 800f4ae:	1dba      	adds	r2, r7, #6
 800f4b0:	8013      	strh	r3, [r2, #0]
  if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 800f4b2:	4b14      	ldr	r3, [pc, #80]	; (800f504 <tcp_get_next_optbyte+0x68>)
 800f4b4:	681b      	ldr	r3, [r3, #0]
 800f4b6:	2b00      	cmp	r3, #0
 800f4b8:	d005      	beq.n	800f4c6 <tcp_get_next_optbyte+0x2a>
 800f4ba:	4b13      	ldr	r3, [pc, #76]	; (800f508 <tcp_get_next_optbyte+0x6c>)
 800f4bc:	881b      	ldrh	r3, [r3, #0]
 800f4be:	1dba      	adds	r2, r7, #6
 800f4c0:	8812      	ldrh	r2, [r2, #0]
 800f4c2:	429a      	cmp	r2, r3
 800f4c4:	d209      	bcs.n	800f4da <tcp_get_next_optbyte+0x3e>
    u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
 800f4c6:	4b11      	ldr	r3, [pc, #68]	; (800f50c <tcp_get_next_optbyte+0x70>)
 800f4c8:	681b      	ldr	r3, [r3, #0]
 800f4ca:	3314      	adds	r3, #20
 800f4cc:	603b      	str	r3, [r7, #0]
    return opts[optidx];
 800f4ce:	1dbb      	adds	r3, r7, #6
 800f4d0:	881b      	ldrh	r3, [r3, #0]
 800f4d2:	683a      	ldr	r2, [r7, #0]
 800f4d4:	18d3      	adds	r3, r2, r3
 800f4d6:	781b      	ldrb	r3, [r3, #0]
 800f4d8:	e00e      	b.n	800f4f8 <tcp_get_next_optbyte+0x5c>
  } else {
    u8_t idx = (u8_t)(optidx - tcphdr_opt1len);
 800f4da:	1dbb      	adds	r3, r7, #6
 800f4dc:	881b      	ldrh	r3, [r3, #0]
 800f4de:	b2d9      	uxtb	r1, r3
 800f4e0:	4b09      	ldr	r3, [pc, #36]	; (800f508 <tcp_get_next_optbyte+0x6c>)
 800f4e2:	881b      	ldrh	r3, [r3, #0]
 800f4e4:	b2da      	uxtb	r2, r3
 800f4e6:	1d7b      	adds	r3, r7, #5
 800f4e8:	1a8a      	subs	r2, r1, r2
 800f4ea:	701a      	strb	r2, [r3, #0]
    return tcphdr_opt2[idx];
 800f4ec:	4b05      	ldr	r3, [pc, #20]	; (800f504 <tcp_get_next_optbyte+0x68>)
 800f4ee:	681a      	ldr	r2, [r3, #0]
 800f4f0:	1d7b      	adds	r3, r7, #5
 800f4f2:	781b      	ldrb	r3, [r3, #0]
 800f4f4:	18d3      	adds	r3, r2, r3
 800f4f6:	781b      	ldrb	r3, [r3, #0]
  }
}
 800f4f8:	0018      	movs	r0, r3
 800f4fa:	46bd      	mov	sp, r7
 800f4fc:	b002      	add	sp, #8
 800f4fe:	bd80      	pop	{r7, pc}
 800f500:	200017b4 	.word	0x200017b4
 800f504:	200017b0 	.word	0x200017b0
 800f508:	200017ae 	.word	0x200017ae
 800f50c:	200017a8 	.word	0x200017a8

0800f510 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
 800f510:	b5b0      	push	{r4, r5, r7, lr}
 800f512:	b084      	sub	sp, #16
 800f514:	af00      	add	r7, sp, #0
 800f516:	6078      	str	r0, [r7, #4]
  u16_t mss;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  LWIP_ASSERT("tcp_parseopt: invalid pcb", pcb != NULL);
 800f518:	687b      	ldr	r3, [r7, #4]
 800f51a:	2b00      	cmp	r3, #0
 800f51c:	d105      	bne.n	800f52a <tcp_parseopt+0x1a>
 800f51e:	4b39      	ldr	r3, [pc, #228]	; (800f604 <tcp_parseopt+0xf4>)
 800f520:	4a39      	ldr	r2, [pc, #228]	; (800f608 <tcp_parseopt+0xf8>)
 800f522:	493a      	ldr	r1, [pc, #232]	; (800f60c <tcp_parseopt+0xfc>)
 800f524:	483a      	ldr	r0, [pc, #232]	; (800f610 <tcp_parseopt+0x100>)
 800f526:	f7f3 fb4f 	bl	8002bc8 <app_debug_rtt_raw>

  /* Parse the TCP MSS option, if present. */
  if (tcphdr_optlen != 0) {
 800f52a:	4b3a      	ldr	r3, [pc, #232]	; (800f614 <tcp_parseopt+0x104>)
 800f52c:	881b      	ldrh	r3, [r3, #0]
 800f52e:	2b00      	cmp	r3, #0
 800f530:	d100      	bne.n	800f534 <tcp_parseopt+0x24>
 800f532:	e064      	b.n	800f5fe <tcp_parseopt+0xee>
    for (tcp_optidx = 0; tcp_optidx < tcphdr_optlen; ) {
 800f534:	4b38      	ldr	r3, [pc, #224]	; (800f618 <tcp_parseopt+0x108>)
 800f536:	2200      	movs	r2, #0
 800f538:	801a      	strh	r2, [r3, #0]
 800f53a:	e054      	b.n	800f5e6 <tcp_parseopt+0xd6>
      u8_t opt = tcp_get_next_optbyte();
 800f53c:	250f      	movs	r5, #15
 800f53e:	197c      	adds	r4, r7, r5
 800f540:	f7ff ffac 	bl	800f49c <tcp_get_next_optbyte>
 800f544:	0003      	movs	r3, r0
 800f546:	7023      	strb	r3, [r4, #0]
      switch (opt) {
 800f548:	197b      	adds	r3, r7, r5
 800f54a:	781b      	ldrb	r3, [r3, #0]
 800f54c:	2b02      	cmp	r3, #2
 800f54e:	d005      	beq.n	800f55c <tcp_parseopt+0x4c>
 800f550:	dc33      	bgt.n	800f5ba <tcp_parseopt+0xaa>
 800f552:	2b00      	cmp	r3, #0
 800f554:	d04e      	beq.n	800f5f4 <tcp_parseopt+0xe4>
 800f556:	2b01      	cmp	r3, #1
 800f558:	d12f      	bne.n	800f5ba <tcp_parseopt+0xaa>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
          return;
        case LWIP_TCP_OPT_NOP:
          /* NOP option. */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
          break;
 800f55a:	e044      	b.n	800f5e6 <tcp_parseopt+0xd6>
        case LWIP_TCP_OPT_MSS:
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
          if (tcp_get_next_optbyte() != LWIP_TCP_OPT_LEN_MSS || (tcp_optidx - 2 + LWIP_TCP_OPT_LEN_MSS) > tcphdr_optlen) {
 800f55c:	f7ff ff9e 	bl	800f49c <tcp_get_next_optbyte>
 800f560:	0003      	movs	r3, r0
 800f562:	2b04      	cmp	r3, #4
 800f564:	d148      	bne.n	800f5f8 <tcp_parseopt+0xe8>
 800f566:	4b2c      	ldr	r3, [pc, #176]	; (800f618 <tcp_parseopt+0x108>)
 800f568:	881b      	ldrh	r3, [r3, #0]
 800f56a:	3301      	adds	r3, #1
 800f56c:	4a29      	ldr	r2, [pc, #164]	; (800f614 <tcp_parseopt+0x104>)
 800f56e:	8812      	ldrh	r2, [r2, #0]
 800f570:	4293      	cmp	r3, r2
 800f572:	da41      	bge.n	800f5f8 <tcp_parseopt+0xe8>
            /* Bad length */
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
            return;
          }
          /* An MSS option with the right option length. */
          mss = (u16_t)(tcp_get_next_optbyte() << 8);
 800f574:	f7ff ff92 	bl	800f49c <tcp_get_next_optbyte>
 800f578:	0003      	movs	r3, r0
 800f57a:	b29a      	uxth	r2, r3
 800f57c:	240c      	movs	r4, #12
 800f57e:	193b      	adds	r3, r7, r4
 800f580:	0212      	lsls	r2, r2, #8
 800f582:	801a      	strh	r2, [r3, #0]
          mss |= tcp_get_next_optbyte();
 800f584:	f7ff ff8a 	bl	800f49c <tcp_get_next_optbyte>
 800f588:	0003      	movs	r3, r0
 800f58a:	b299      	uxth	r1, r3
 800f58c:	193b      	adds	r3, r7, r4
 800f58e:	193a      	adds	r2, r7, r4
 800f590:	8812      	ldrh	r2, [r2, #0]
 800f592:	430a      	orrs	r2, r1
 800f594:	801a      	strh	r2, [r3, #0]
          /* Limit the mss to the configured TCP_MSS and prevent division by zero */
          pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 800f596:	193b      	adds	r3, r7, r4
 800f598:	881a      	ldrh	r2, [r3, #0]
 800f59a:	2386      	movs	r3, #134	; 0x86
 800f59c:	009b      	lsls	r3, r3, #2
 800f59e:	429a      	cmp	r2, r3
 800f5a0:	d806      	bhi.n	800f5b0 <tcp_parseopt+0xa0>
 800f5a2:	193b      	adds	r3, r7, r4
 800f5a4:	881b      	ldrh	r3, [r3, #0]
 800f5a6:	2b00      	cmp	r3, #0
 800f5a8:	d002      	beq.n	800f5b0 <tcp_parseopt+0xa0>
 800f5aa:	193b      	adds	r3, r7, r4
 800f5ac:	881b      	ldrh	r3, [r3, #0]
 800f5ae:	e001      	b.n	800f5b4 <tcp_parseopt+0xa4>
 800f5b0:	2386      	movs	r3, #134	; 0x86
 800f5b2:	009b      	lsls	r3, r3, #2
 800f5b4:	687a      	ldr	r2, [r7, #4]
 800f5b6:	86d3      	strh	r3, [r2, #54]	; 0x36
          break;
 800f5b8:	e015      	b.n	800f5e6 <tcp_parseopt+0xd6>
          }
          break;
#endif /* LWIP_TCP_SACK_OUT */
        default:
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
          data = tcp_get_next_optbyte();
 800f5ba:	250b      	movs	r5, #11
 800f5bc:	197c      	adds	r4, r7, r5
 800f5be:	f7ff ff6d 	bl	800f49c <tcp_get_next_optbyte>
 800f5c2:	0003      	movs	r3, r0
 800f5c4:	7023      	strb	r3, [r4, #0]
          if (data < 2) {
 800f5c6:	002a      	movs	r2, r5
 800f5c8:	18bb      	adds	r3, r7, r2
 800f5ca:	781b      	ldrb	r3, [r3, #0]
 800f5cc:	2b01      	cmp	r3, #1
 800f5ce:	d915      	bls.n	800f5fc <tcp_parseopt+0xec>
               and we don't process them further. */
            return;
          }
          /* All other options have a length field, so that we easily
             can skip past them. */
          tcp_optidx += data - 2;
 800f5d0:	18bb      	adds	r3, r7, r2
 800f5d2:	781b      	ldrb	r3, [r3, #0]
 800f5d4:	b29a      	uxth	r2, r3
 800f5d6:	4b10      	ldr	r3, [pc, #64]	; (800f618 <tcp_parseopt+0x108>)
 800f5d8:	881b      	ldrh	r3, [r3, #0]
 800f5da:	18d3      	adds	r3, r2, r3
 800f5dc:	b29b      	uxth	r3, r3
 800f5de:	3b02      	subs	r3, #2
 800f5e0:	b29a      	uxth	r2, r3
 800f5e2:	4b0d      	ldr	r3, [pc, #52]	; (800f618 <tcp_parseopt+0x108>)
 800f5e4:	801a      	strh	r2, [r3, #0]
    for (tcp_optidx = 0; tcp_optidx < tcphdr_optlen; ) {
 800f5e6:	4b0c      	ldr	r3, [pc, #48]	; (800f618 <tcp_parseopt+0x108>)
 800f5e8:	881a      	ldrh	r2, [r3, #0]
 800f5ea:	4b0a      	ldr	r3, [pc, #40]	; (800f614 <tcp_parseopt+0x104>)
 800f5ec:	881b      	ldrh	r3, [r3, #0]
 800f5ee:	429a      	cmp	r2, r3
 800f5f0:	d3a4      	bcc.n	800f53c <tcp_parseopt+0x2c>
 800f5f2:	e004      	b.n	800f5fe <tcp_parseopt+0xee>
          return;
 800f5f4:	46c0      	nop			; (mov r8, r8)
 800f5f6:	e002      	b.n	800f5fe <tcp_parseopt+0xee>
            return;
 800f5f8:	46c0      	nop			; (mov r8, r8)
 800f5fa:	e000      	b.n	800f5fe <tcp_parseopt+0xee>
            return;
 800f5fc:	46c0      	nop			; (mov r8, r8)
      }
    }
  }
}
 800f5fe:	46bd      	mov	sp, r7
 800f600:	b004      	add	sp, #16
 800f602:	bdb0      	pop	{r4, r5, r7, pc}
 800f604:	080205bc 	.word	0x080205bc
 800f608:	0000077e 	.word	0x0000077e
 800f60c:	08020a18 	.word	0x08020a18
 800f610:	080205fc 	.word	0x080205fc
 800f614:	200017ac 	.word	0x200017ac
 800f618:	200017b4 	.word	0x200017b4

0800f61c <tcp_trigger_input_pcb_close>:

void
tcp_trigger_input_pcb_close(void)
{
 800f61c:	b580      	push	{r7, lr}
 800f61e:	af00      	add	r7, sp, #0
  recv_flags |= TF_CLOSED;
 800f620:	4b04      	ldr	r3, [pc, #16]	; (800f634 <tcp_trigger_input_pcb_close+0x18>)
 800f622:	781b      	ldrb	r3, [r3, #0]
 800f624:	2210      	movs	r2, #16
 800f626:	4313      	orrs	r3, r2
 800f628:	b2da      	uxtb	r2, r3
 800f62a:	4b02      	ldr	r3, [pc, #8]	; (800f634 <tcp_trigger_input_pcb_close+0x18>)
 800f62c:	701a      	strb	r2, [r3, #0]
}
 800f62e:	46c0      	nop			; (mov r8, r8)
 800f630:	46bd      	mov	sp, r7
 800f632:	bd80      	pop	{r7, pc}
 800f634:	200017c5 	.word	0x200017c5

0800f638 <tcp_route>:
static err_t tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb, struct netif *netif);

/* tcp_route: common code that returns a fixed bound netif or calls ip_route */
static struct netif *
tcp_route(const struct tcp_pcb *pcb, const ip_addr_t *src, const ip_addr_t *dst)
{
 800f638:	b580      	push	{r7, lr}
 800f63a:	b084      	sub	sp, #16
 800f63c:	af00      	add	r7, sp, #0
 800f63e:	60f8      	str	r0, [r7, #12]
 800f640:	60b9      	str	r1, [r7, #8]
 800f642:	607a      	str	r2, [r7, #4]
  LWIP_UNUSED_ARG(src); /* in case IPv4-only and source-based routing is disabled */

  if ((pcb != NULL) && (pcb->netif_idx != NETIF_NO_INDEX)) {
 800f644:	68fb      	ldr	r3, [r7, #12]
 800f646:	2b00      	cmp	r3, #0
 800f648:	d00a      	beq.n	800f660 <tcp_route+0x28>
 800f64a:	68fb      	ldr	r3, [r7, #12]
 800f64c:	7a1b      	ldrb	r3, [r3, #8]
 800f64e:	2b00      	cmp	r3, #0
 800f650:	d006      	beq.n	800f660 <tcp_route+0x28>
    return netif_get_by_index(pcb->netif_idx);
 800f652:	68fb      	ldr	r3, [r7, #12]
 800f654:	7a1b      	ldrb	r3, [r3, #8]
 800f656:	0018      	movs	r0, r3
 800f658:	f7fa f83a 	bl	80096d0 <netif_get_by_index>
 800f65c:	0003      	movs	r3, r0
 800f65e:	e004      	b.n	800f66a <tcp_route+0x32>
  } else {
    return ip_route(src, dst);
 800f660:	687b      	ldr	r3, [r7, #4]
 800f662:	0018      	movs	r0, r3
 800f664:	f003 ffb2 	bl	80135cc <ip4_route>
 800f668:	0003      	movs	r3, r0
  }
}
 800f66a:	0018      	movs	r0, r3
 800f66c:	46bd      	mov	sp, r7
 800f66e:	b004      	add	sp, #16
 800f670:	bd80      	pop	{r7, pc}
	...

0800f674 <tcp_create_segment>:
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *
tcp_create_segment(const struct tcp_pcb *pcb, struct pbuf *p, u8_t hdrflags, u32_t seqno, u8_t optflags)
{
 800f674:	b590      	push	{r4, r7, lr}
 800f676:	b087      	sub	sp, #28
 800f678:	af00      	add	r7, sp, #0
 800f67a:	60f8      	str	r0, [r7, #12]
 800f67c:	60b9      	str	r1, [r7, #8]
 800f67e:	603b      	str	r3, [r7, #0]
 800f680:	1dfb      	adds	r3, r7, #7
 800f682:	701a      	strb	r2, [r3, #0]
  struct tcp_seg *seg;
  u8_t optlen;

  LWIP_ASSERT("tcp_create_segment: invalid pcb", pcb != NULL);
 800f684:	68fb      	ldr	r3, [r7, #12]
 800f686:	2b00      	cmp	r3, #0
 800f688:	d105      	bne.n	800f696 <tcp_create_segment+0x22>
 800f68a:	4b86      	ldr	r3, [pc, #536]	; (800f8a4 <tcp_create_segment+0x230>)
 800f68c:	4986      	ldr	r1, [pc, #536]	; (800f8a8 <tcp_create_segment+0x234>)
 800f68e:	4887      	ldr	r0, [pc, #540]	; (800f8ac <tcp_create_segment+0x238>)
 800f690:	22a3      	movs	r2, #163	; 0xa3
 800f692:	f7f3 fa99 	bl	8002bc8 <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_create_segment: invalid pbuf", p != NULL);
 800f696:	68bb      	ldr	r3, [r7, #8]
 800f698:	2b00      	cmp	r3, #0
 800f69a:	d105      	bne.n	800f6a8 <tcp_create_segment+0x34>
 800f69c:	4b81      	ldr	r3, [pc, #516]	; (800f8a4 <tcp_create_segment+0x230>)
 800f69e:	4984      	ldr	r1, [pc, #528]	; (800f8b0 <tcp_create_segment+0x23c>)
 800f6a0:	4882      	ldr	r0, [pc, #520]	; (800f8ac <tcp_create_segment+0x238>)
 800f6a2:	22a4      	movs	r2, #164	; 0xa4
 800f6a4:	f7f3 fa90 	bl	8002bc8 <app_debug_rtt_raw>

  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
 800f6a8:	2328      	movs	r3, #40	; 0x28
 800f6aa:	18fb      	adds	r3, r7, r3
 800f6ac:	781b      	ldrb	r3, [r3, #0]
 800f6ae:	009b      	lsls	r3, r3, #2
 800f6b0:	b2da      	uxtb	r2, r3
 800f6b2:	2317      	movs	r3, #23
 800f6b4:	18fb      	adds	r3, r7, r3
 800f6b6:	2104      	movs	r1, #4
 800f6b8:	400a      	ands	r2, r1
 800f6ba:	701a      	strb	r2, [r3, #0]

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 800f6bc:	2003      	movs	r0, #3
 800f6be:	f7f9 fc9d 	bl	8008ffc <memp_malloc>
 800f6c2:	0003      	movs	r3, r0
 800f6c4:	613b      	str	r3, [r7, #16]
 800f6c6:	693b      	ldr	r3, [r7, #16]
 800f6c8:	2b00      	cmp	r3, #0
 800f6ca:	d105      	bne.n	800f6d8 <tcp_create_segment+0x64>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
 800f6cc:	68bb      	ldr	r3, [r7, #8]
 800f6ce:	0018      	movs	r0, r3
 800f6d0:	f7fa fbf4 	bl	8009ebc <pbuf_free>
    return NULL;
 800f6d4:	2300      	movs	r3, #0
 800f6d6:	e0e1      	b.n	800f89c <tcp_create_segment+0x228>
  }
  seg->flags = optflags;
 800f6d8:	693a      	ldr	r2, [r7, #16]
 800f6da:	2328      	movs	r3, #40	; 0x28
 800f6dc:	18fb      	adds	r3, r7, r3
 800f6de:	781b      	ldrb	r3, [r3, #0]
 800f6e0:	73d3      	strb	r3, [r2, #15]
  seg->next = NULL;
 800f6e2:	693b      	ldr	r3, [r7, #16]
 800f6e4:	2200      	movs	r2, #0
 800f6e6:	601a      	str	r2, [r3, #0]
  seg->p = p;
 800f6e8:	693b      	ldr	r3, [r7, #16]
 800f6ea:	68ba      	ldr	r2, [r7, #8]
 800f6ec:	605a      	str	r2, [r3, #4]
  LWIP_ASSERT("p->tot_len >= optlen", p->tot_len >= optlen);
 800f6ee:	68bb      	ldr	r3, [r7, #8]
 800f6f0:	891a      	ldrh	r2, [r3, #8]
 800f6f2:	2317      	movs	r3, #23
 800f6f4:	18fb      	adds	r3, r7, r3
 800f6f6:	781b      	ldrb	r3, [r3, #0]
 800f6f8:	b29b      	uxth	r3, r3
 800f6fa:	429a      	cmp	r2, r3
 800f6fc:	d205      	bcs.n	800f70a <tcp_create_segment+0x96>
 800f6fe:	4b69      	ldr	r3, [pc, #420]	; (800f8a4 <tcp_create_segment+0x230>)
 800f700:	496c      	ldr	r1, [pc, #432]	; (800f8b4 <tcp_create_segment+0x240>)
 800f702:	486a      	ldr	r0, [pc, #424]	; (800f8ac <tcp_create_segment+0x238>)
 800f704:	22b0      	movs	r2, #176	; 0xb0
 800f706:	f7f3 fa5f 	bl	8002bc8 <app_debug_rtt_raw>
  seg->len = p->tot_len - optlen;
 800f70a:	68bb      	ldr	r3, [r7, #8]
 800f70c:	891a      	ldrh	r2, [r3, #8]
 800f70e:	2317      	movs	r3, #23
 800f710:	18fb      	adds	r3, r7, r3
 800f712:	781b      	ldrb	r3, [r3, #0]
 800f714:	b29b      	uxth	r3, r3
 800f716:	1ad3      	subs	r3, r2, r3
 800f718:	b29a      	uxth	r2, r3
 800f71a:	693b      	ldr	r3, [r7, #16]
 800f71c:	811a      	strh	r2, [r3, #8]
#if TCP_OVERSIZE_DBGCHECK
  seg->oversize_left = 0;
 800f71e:	693b      	ldr	r3, [r7, #16]
 800f720:	2200      	movs	r2, #0
 800f722:	815a      	strh	r2, [r3, #10]
#endif /* TCP_OVERSIZE_DBGCHECK */
#if TCP_CHECKSUM_ON_COPY
  seg->chksum = 0;
 800f724:	693b      	ldr	r3, [r7, #16]
 800f726:	2200      	movs	r2, #0
 800f728:	819a      	strh	r2, [r3, #12]
  seg->chksum_swapped = 0;
 800f72a:	693b      	ldr	r3, [r7, #16]
 800f72c:	2200      	movs	r2, #0
 800f72e:	739a      	strb	r2, [r3, #14]
  /* check optflags */
  LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
 800f730:	2328      	movs	r3, #40	; 0x28
 800f732:	18fb      	adds	r3, r7, r3
 800f734:	781b      	ldrb	r3, [r3, #0]
 800f736:	2204      	movs	r2, #4
 800f738:	4013      	ands	r3, r2
 800f73a:	d005      	beq.n	800f748 <tcp_create_segment+0xd4>
 800f73c:	4b59      	ldr	r3, [pc, #356]	; (800f8a4 <tcp_create_segment+0x230>)
 800f73e:	495e      	ldr	r1, [pc, #376]	; (800f8b8 <tcp_create_segment+0x244>)
 800f740:	485a      	ldr	r0, [pc, #360]	; (800f8ac <tcp_create_segment+0x238>)
 800f742:	22b9      	movs	r2, #185	; 0xb9
 800f744:	f7f3 fa40 	bl	8002bc8 <app_debug_rtt_raw>
              (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_add_header(p, TCP_HLEN)) {
 800f748:	68bb      	ldr	r3, [r7, #8]
 800f74a:	2114      	movs	r1, #20
 800f74c:	0018      	movs	r0, r3
 800f74e:	f7fa facd 	bl	8009cec <pbuf_add_header>
 800f752:	1e03      	subs	r3, r0, #0
 800f754:	d005      	beq.n	800f762 <tcp_create_segment+0xee>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
 800f756:	693b      	ldr	r3, [r7, #16]
 800f758:	0018      	movs	r0, r3
 800f75a:	f7fc fc1b 	bl	800bf94 <tcp_seg_free>
    return NULL;
 800f75e:	2300      	movs	r3, #0
 800f760:	e09c      	b.n	800f89c <tcp_create_segment+0x228>
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 800f762:	693b      	ldr	r3, [r7, #16]
 800f764:	685b      	ldr	r3, [r3, #4]
 800f766:	685a      	ldr	r2, [r3, #4]
 800f768:	693b      	ldr	r3, [r7, #16]
 800f76a:	611a      	str	r2, [r3, #16]
  seg->tcphdr->src = lwip_htons(pcb->local_port);
 800f76c:	68fb      	ldr	r3, [r7, #12]
 800f76e:	8b5a      	ldrh	r2, [r3, #26]
 800f770:	693b      	ldr	r3, [r7, #16]
 800f772:	691c      	ldr	r4, [r3, #16]
 800f774:	0010      	movs	r0, r2
 800f776:	f7f7 fbbd 	bl	8006ef4 <lwip_htons>
 800f77a:	0003      	movs	r3, r0
 800f77c:	22ff      	movs	r2, #255	; 0xff
 800f77e:	401a      	ands	r2, r3
 800f780:	0010      	movs	r0, r2
 800f782:	7822      	ldrb	r2, [r4, #0]
 800f784:	2100      	movs	r1, #0
 800f786:	400a      	ands	r2, r1
 800f788:	1c11      	adds	r1, r2, #0
 800f78a:	1c02      	adds	r2, r0, #0
 800f78c:	430a      	orrs	r2, r1
 800f78e:	7022      	strb	r2, [r4, #0]
 800f790:	0a1b      	lsrs	r3, r3, #8
 800f792:	b299      	uxth	r1, r3
 800f794:	7863      	ldrb	r3, [r4, #1]
 800f796:	2200      	movs	r2, #0
 800f798:	4013      	ands	r3, r2
 800f79a:	1c1a      	adds	r2, r3, #0
 800f79c:	1c0b      	adds	r3, r1, #0
 800f79e:	4313      	orrs	r3, r2
 800f7a0:	7063      	strb	r3, [r4, #1]
  seg->tcphdr->dest = lwip_htons(pcb->remote_port);
 800f7a2:	68fb      	ldr	r3, [r7, #12]
 800f7a4:	8b9a      	ldrh	r2, [r3, #28]
 800f7a6:	693b      	ldr	r3, [r7, #16]
 800f7a8:	691c      	ldr	r4, [r3, #16]
 800f7aa:	0010      	movs	r0, r2
 800f7ac:	f7f7 fba2 	bl	8006ef4 <lwip_htons>
 800f7b0:	0003      	movs	r3, r0
 800f7b2:	22ff      	movs	r2, #255	; 0xff
 800f7b4:	401a      	ands	r2, r3
 800f7b6:	0010      	movs	r0, r2
 800f7b8:	78a2      	ldrb	r2, [r4, #2]
 800f7ba:	2100      	movs	r1, #0
 800f7bc:	400a      	ands	r2, r1
 800f7be:	1c11      	adds	r1, r2, #0
 800f7c0:	1c02      	adds	r2, r0, #0
 800f7c2:	430a      	orrs	r2, r1
 800f7c4:	70a2      	strb	r2, [r4, #2]
 800f7c6:	0a1b      	lsrs	r3, r3, #8
 800f7c8:	b299      	uxth	r1, r3
 800f7ca:	78e3      	ldrb	r3, [r4, #3]
 800f7cc:	2200      	movs	r2, #0
 800f7ce:	4013      	ands	r3, r2
 800f7d0:	1c1a      	adds	r2, r3, #0
 800f7d2:	1c0b      	adds	r3, r1, #0
 800f7d4:	4313      	orrs	r3, r2
 800f7d6:	70e3      	strb	r3, [r4, #3]
  seg->tcphdr->seqno = lwip_htonl(seqno);
 800f7d8:	693b      	ldr	r3, [r7, #16]
 800f7da:	691c      	ldr	r4, [r3, #16]
 800f7dc:	683b      	ldr	r3, [r7, #0]
 800f7de:	0018      	movs	r0, r3
 800f7e0:	f7f7 fb9e 	bl	8006f20 <lwip_htonl>
 800f7e4:	0003      	movs	r3, r0
 800f7e6:	22ff      	movs	r2, #255	; 0xff
 800f7e8:	401a      	ands	r2, r3
 800f7ea:	0010      	movs	r0, r2
 800f7ec:	7922      	ldrb	r2, [r4, #4]
 800f7ee:	2100      	movs	r1, #0
 800f7f0:	400a      	ands	r2, r1
 800f7f2:	1c11      	adds	r1, r2, #0
 800f7f4:	1c02      	adds	r2, r0, #0
 800f7f6:	430a      	orrs	r2, r1
 800f7f8:	7122      	strb	r2, [r4, #4]
 800f7fa:	0a1a      	lsrs	r2, r3, #8
 800f7fc:	21ff      	movs	r1, #255	; 0xff
 800f7fe:	400a      	ands	r2, r1
 800f800:	0010      	movs	r0, r2
 800f802:	7962      	ldrb	r2, [r4, #5]
 800f804:	2100      	movs	r1, #0
 800f806:	400a      	ands	r2, r1
 800f808:	1c11      	adds	r1, r2, #0
 800f80a:	1c02      	adds	r2, r0, #0
 800f80c:	430a      	orrs	r2, r1
 800f80e:	7162      	strb	r2, [r4, #5]
 800f810:	0c1a      	lsrs	r2, r3, #16
 800f812:	21ff      	movs	r1, #255	; 0xff
 800f814:	400a      	ands	r2, r1
 800f816:	0010      	movs	r0, r2
 800f818:	79a2      	ldrb	r2, [r4, #6]
 800f81a:	2100      	movs	r1, #0
 800f81c:	400a      	ands	r2, r1
 800f81e:	1c11      	adds	r1, r2, #0
 800f820:	1c02      	adds	r2, r0, #0
 800f822:	430a      	orrs	r2, r1
 800f824:	71a2      	strb	r2, [r4, #6]
 800f826:	0e19      	lsrs	r1, r3, #24
 800f828:	79e3      	ldrb	r3, [r4, #7]
 800f82a:	2200      	movs	r2, #0
 800f82c:	4013      	ands	r3, r2
 800f82e:	1c1a      	adds	r2, r3, #0
 800f830:	1c0b      	adds	r3, r1, #0
 800f832:	4313      	orrs	r3, r2
 800f834:	71e3      	strb	r3, [r4, #7]
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), hdrflags);
 800f836:	2317      	movs	r3, #23
 800f838:	18fb      	adds	r3, r7, r3
 800f83a:	781b      	ldrb	r3, [r3, #0]
 800f83c:	089b      	lsrs	r3, r3, #2
 800f83e:	b2db      	uxtb	r3, r3
 800f840:	b29b      	uxth	r3, r3
 800f842:	3305      	adds	r3, #5
 800f844:	b29b      	uxth	r3, r3
 800f846:	031b      	lsls	r3, r3, #12
 800f848:	b29a      	uxth	r2, r3
 800f84a:	1dfb      	adds	r3, r7, #7
 800f84c:	781b      	ldrb	r3, [r3, #0]
 800f84e:	b29b      	uxth	r3, r3
 800f850:	4313      	orrs	r3, r2
 800f852:	b29a      	uxth	r2, r3
 800f854:	693b      	ldr	r3, [r7, #16]
 800f856:	691c      	ldr	r4, [r3, #16]
 800f858:	0010      	movs	r0, r2
 800f85a:	f7f7 fb4b 	bl	8006ef4 <lwip_htons>
 800f85e:	0003      	movs	r3, r0
 800f860:	22ff      	movs	r2, #255	; 0xff
 800f862:	401a      	ands	r2, r3
 800f864:	0010      	movs	r0, r2
 800f866:	7b22      	ldrb	r2, [r4, #12]
 800f868:	2100      	movs	r1, #0
 800f86a:	400a      	ands	r2, r1
 800f86c:	1c11      	adds	r1, r2, #0
 800f86e:	1c02      	adds	r2, r0, #0
 800f870:	430a      	orrs	r2, r1
 800f872:	7322      	strb	r2, [r4, #12]
 800f874:	0a1b      	lsrs	r3, r3, #8
 800f876:	b299      	uxth	r1, r3
 800f878:	7b63      	ldrb	r3, [r4, #13]
 800f87a:	2200      	movs	r2, #0
 800f87c:	4013      	ands	r3, r2
 800f87e:	1c1a      	adds	r2, r3, #0
 800f880:	1c0b      	adds	r3, r1, #0
 800f882:	4313      	orrs	r3, r2
 800f884:	7363      	strb	r3, [r4, #13]
  /* wnd and chksum are set in tcp_output */
  seg->tcphdr->urgp = 0;
 800f886:	693b      	ldr	r3, [r7, #16]
 800f888:	691b      	ldr	r3, [r3, #16]
 800f88a:	7c9a      	ldrb	r2, [r3, #18]
 800f88c:	2100      	movs	r1, #0
 800f88e:	400a      	ands	r2, r1
 800f890:	749a      	strb	r2, [r3, #18]
 800f892:	7cda      	ldrb	r2, [r3, #19]
 800f894:	2100      	movs	r1, #0
 800f896:	400a      	ands	r2, r1
 800f898:	74da      	strb	r2, [r3, #19]
  return seg;
 800f89a:	693b      	ldr	r3, [r7, #16]
}
 800f89c:	0018      	movs	r0, r3
 800f89e:	46bd      	mov	sp, r7
 800f8a0:	b007      	add	sp, #28
 800f8a2:	bd90      	pop	{r4, r7, pc}
 800f8a4:	08020a34 	.word	0x08020a34
 800f8a8:	08020a60 	.word	0x08020a60
 800f8ac:	08020a80 	.word	0x08020a80
 800f8b0:	08020aac 	.word	0x08020aac
 800f8b4:	08020ad0 	.word	0x08020ad0
 800f8b8:	08020ae8 	.word	0x08020ae8

0800f8bc <tcp_pbuf_prealloc>:
#if TCP_OVERSIZE
static struct pbuf *
tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
                  u16_t *oversize, const struct tcp_pcb *pcb, u8_t apiflags,
                  u8_t first_seg)
{
 800f8bc:	b590      	push	{r4, r7, lr}
 800f8be:	b087      	sub	sp, #28
 800f8c0:	af00      	add	r7, sp, #0
 800f8c2:	0004      	movs	r4, r0
 800f8c4:	0008      	movs	r0, r1
 800f8c6:	0011      	movs	r1, r2
 800f8c8:	607b      	str	r3, [r7, #4]
 800f8ca:	230f      	movs	r3, #15
 800f8cc:	18fb      	adds	r3, r7, r3
 800f8ce:	1c22      	adds	r2, r4, #0
 800f8d0:	701a      	strb	r2, [r3, #0]
 800f8d2:	240c      	movs	r4, #12
 800f8d4:	193b      	adds	r3, r7, r4
 800f8d6:	1c02      	adds	r2, r0, #0
 800f8d8:	801a      	strh	r2, [r3, #0]
 800f8da:	230a      	movs	r3, #10
 800f8dc:	18fb      	adds	r3, r7, r3
 800f8de:	1c0a      	adds	r2, r1, #0
 800f8e0:	801a      	strh	r2, [r3, #0]
  struct pbuf *p;
  u16_t alloc = length;
 800f8e2:	2316      	movs	r3, #22
 800f8e4:	18fb      	adds	r3, r7, r3
 800f8e6:	193a      	adds	r2, r7, r4
 800f8e8:	8812      	ldrh	r2, [r2, #0]
 800f8ea:	801a      	strh	r2, [r3, #0]

  LWIP_ASSERT("tcp_pbuf_prealloc: invalid oversize", oversize != NULL);
 800f8ec:	687b      	ldr	r3, [r7, #4]
 800f8ee:	2b00      	cmp	r3, #0
 800f8f0:	d105      	bne.n	800f8fe <tcp_pbuf_prealloc+0x42>
 800f8f2:	4b3a      	ldr	r3, [pc, #232]	; (800f9dc <tcp_pbuf_prealloc+0x120>)
 800f8f4:	493a      	ldr	r1, [pc, #232]	; (800f9e0 <tcp_pbuf_prealloc+0x124>)
 800f8f6:	483b      	ldr	r0, [pc, #236]	; (800f9e4 <tcp_pbuf_prealloc+0x128>)
 800f8f8:	22e8      	movs	r2, #232	; 0xe8
 800f8fa:	f7f3 f965 	bl	8002bc8 <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_pbuf_prealloc: invalid pcb", pcb != NULL);
 800f8fe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f900:	2b00      	cmp	r3, #0
 800f902:	d105      	bne.n	800f910 <tcp_pbuf_prealloc+0x54>
 800f904:	4b35      	ldr	r3, [pc, #212]	; (800f9dc <tcp_pbuf_prealloc+0x120>)
 800f906:	4938      	ldr	r1, [pc, #224]	; (800f9e8 <tcp_pbuf_prealloc+0x12c>)
 800f908:	4836      	ldr	r0, [pc, #216]	; (800f9e4 <tcp_pbuf_prealloc+0x128>)
 800f90a:	22e9      	movs	r2, #233	; 0xe9
 800f90c:	f7f3 f95c 	bl	8002bc8 <app_debug_rtt_raw>
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(apiflags);
  LWIP_UNUSED_ARG(first_seg);
  alloc = max_length;
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (length < max_length) {
 800f910:	230c      	movs	r3, #12
 800f912:	18fa      	adds	r2, r7, r3
 800f914:	230a      	movs	r3, #10
 800f916:	18fb      	adds	r3, r7, r3
 800f918:	8812      	ldrh	r2, [r2, #0]
 800f91a:	881b      	ldrh	r3, [r3, #0]
 800f91c:	429a      	cmp	r2, r3
 800f91e:	d22a      	bcs.n	800f976 <tcp_pbuf_prealloc+0xba>
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
 800f920:	232c      	movs	r3, #44	; 0x2c
 800f922:	18fb      	adds	r3, r7, r3
 800f924:	781b      	ldrb	r3, [r3, #0]
 800f926:	2202      	movs	r2, #2
 800f928:	4013      	ands	r3, r2
 800f92a:	d112      	bne.n	800f952 <tcp_pbuf_prealloc+0x96>
        (!(pcb->flags & TF_NODELAY) &&
 800f92c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f92e:	8bdb      	ldrh	r3, [r3, #30]
 800f930:	001a      	movs	r2, r3
 800f932:	2340      	movs	r3, #64	; 0x40
 800f934:	4013      	ands	r3, r2
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
 800f936:	d11e      	bne.n	800f976 <tcp_pbuf_prealloc+0xba>
        (!(pcb->flags & TF_NODELAY) &&
 800f938:	2330      	movs	r3, #48	; 0x30
 800f93a:	18fb      	adds	r3, r7, r3
 800f93c:	781b      	ldrb	r3, [r3, #0]
 800f93e:	2b00      	cmp	r3, #0
 800f940:	d007      	beq.n	800f952 <tcp_pbuf_prealloc+0x96>
         (!first_seg ||
          pcb->unsent != NULL ||
 800f942:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f944:	6f1b      	ldr	r3, [r3, #112]	; 0x70
         (!first_seg ||
 800f946:	2b00      	cmp	r3, #0
 800f948:	d103      	bne.n	800f952 <tcp_pbuf_prealloc+0x96>
          pcb->unacked != NULL))) {
 800f94a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f94c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
          pcb->unsent != NULL ||
 800f94e:	2b00      	cmp	r3, #0
 800f950:	d011      	beq.n	800f976 <tcp_pbuf_prealloc+0xba>
      alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(TCP_OVERSIZE_CALC_LENGTH(length)));
 800f952:	230c      	movs	r3, #12
 800f954:	18fb      	adds	r3, r7, r3
 800f956:	881b      	ldrh	r3, [r3, #0]
 800f958:	4a24      	ldr	r2, [pc, #144]	; (800f9ec <tcp_pbuf_prealloc+0x130>)
 800f95a:	4694      	mov	ip, r2
 800f95c:	4463      	add	r3, ip
 800f95e:	2203      	movs	r2, #3
 800f960:	4393      	bics	r3, r2
 800f962:	001a      	movs	r2, r3
 800f964:	230a      	movs	r3, #10
 800f966:	18fb      	adds	r3, r7, r3
 800f968:	881b      	ldrh	r3, [r3, #0]
 800f96a:	429a      	cmp	r2, r3
 800f96c:	d900      	bls.n	800f970 <tcp_pbuf_prealloc+0xb4>
 800f96e:	001a      	movs	r2, r3
 800f970:	2316      	movs	r3, #22
 800f972:	18fb      	adds	r3, r7, r3
 800f974:	801a      	strh	r2, [r3, #0]
    }
  }
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
 800f976:	23a0      	movs	r3, #160	; 0xa0
 800f978:	009a      	lsls	r2, r3, #2
 800f97a:	2316      	movs	r3, #22
 800f97c:	18fb      	adds	r3, r7, r3
 800f97e:	8819      	ldrh	r1, [r3, #0]
 800f980:	230f      	movs	r3, #15
 800f982:	18fb      	adds	r3, r7, r3
 800f984:	781b      	ldrb	r3, [r3, #0]
 800f986:	0018      	movs	r0, r3
 800f988:	f7f9 ff20 	bl	80097cc <pbuf_alloc>
 800f98c:	0003      	movs	r3, r0
 800f98e:	613b      	str	r3, [r7, #16]
  if (p == NULL) {
 800f990:	693b      	ldr	r3, [r7, #16]
 800f992:	2b00      	cmp	r3, #0
 800f994:	d101      	bne.n	800f99a <tcp_pbuf_prealloc+0xde>
    return NULL;
 800f996:	2300      	movs	r3, #0
 800f998:	e01c      	b.n	800f9d4 <tcp_pbuf_prealloc+0x118>
  }
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
 800f99a:	693b      	ldr	r3, [r7, #16]
 800f99c:	681b      	ldr	r3, [r3, #0]
 800f99e:	2b00      	cmp	r3, #0
 800f9a0:	d006      	beq.n	800f9b0 <tcp_pbuf_prealloc+0xf4>
 800f9a2:	4b0e      	ldr	r3, [pc, #56]	; (800f9dc <tcp_pbuf_prealloc+0x120>)
 800f9a4:	220c      	movs	r2, #12
 800f9a6:	32ff      	adds	r2, #255	; 0xff
 800f9a8:	4911      	ldr	r1, [pc, #68]	; (800f9f0 <tcp_pbuf_prealloc+0x134>)
 800f9aa:	480e      	ldr	r0, [pc, #56]	; (800f9e4 <tcp_pbuf_prealloc+0x128>)
 800f9ac:	f7f3 f90c 	bl	8002bc8 <app_debug_rtt_raw>
  *oversize = p->len - length;
 800f9b0:	693b      	ldr	r3, [r7, #16]
 800f9b2:	895a      	ldrh	r2, [r3, #10]
 800f9b4:	210c      	movs	r1, #12
 800f9b6:	187b      	adds	r3, r7, r1
 800f9b8:	881b      	ldrh	r3, [r3, #0]
 800f9ba:	1ad3      	subs	r3, r2, r3
 800f9bc:	b29a      	uxth	r2, r3
 800f9be:	687b      	ldr	r3, [r7, #4]
 800f9c0:	801a      	strh	r2, [r3, #0]
  /* trim p->len to the currently used size */
  p->len = p->tot_len = length;
 800f9c2:	693b      	ldr	r3, [r7, #16]
 800f9c4:	187a      	adds	r2, r7, r1
 800f9c6:	8812      	ldrh	r2, [r2, #0]
 800f9c8:	811a      	strh	r2, [r3, #8]
 800f9ca:	693b      	ldr	r3, [r7, #16]
 800f9cc:	891a      	ldrh	r2, [r3, #8]
 800f9ce:	693b      	ldr	r3, [r7, #16]
 800f9d0:	815a      	strh	r2, [r3, #10]
  return p;
 800f9d2:	693b      	ldr	r3, [r7, #16]
}
 800f9d4:	0018      	movs	r0, r3
 800f9d6:	46bd      	mov	sp, r7
 800f9d8:	b007      	add	sp, #28
 800f9da:	bd90      	pop	{r4, r7, pc}
 800f9dc:	08020a34 	.word	0x08020a34
 800f9e0:	08020b1c 	.word	0x08020b1c
 800f9e4:	08020a80 	.word	0x08020a80
 800f9e8:	08020b40 	.word	0x08020b40
 800f9ec:	0000021b 	.word	0x0000021b
 800f9f0:	08020b60 	.word	0x08020b60

0800f9f4 <tcp_seg_add_chksum>:
 * Called by tcp_write and tcp_split_unsent_seg.
 */
static void
tcp_seg_add_chksum(u16_t chksum, u16_t len, u16_t *seg_chksum,
                   u8_t *seg_chksum_swapped)
{
 800f9f4:	b5b0      	push	{r4, r5, r7, lr}
 800f9f6:	b086      	sub	sp, #24
 800f9f8:	af00      	add	r7, sp, #0
 800f9fa:	60ba      	str	r2, [r7, #8]
 800f9fc:	607b      	str	r3, [r7, #4]
 800f9fe:	240e      	movs	r4, #14
 800fa00:	193b      	adds	r3, r7, r4
 800fa02:	1c02      	adds	r2, r0, #0
 800fa04:	801a      	strh	r2, [r3, #0]
 800fa06:	250c      	movs	r5, #12
 800fa08:	197b      	adds	r3, r7, r5
 800fa0a:	1c0a      	adds	r2, r1, #0
 800fa0c:	801a      	strh	r2, [r3, #0]
  u32_t helper;
  /* add chksum to old chksum and fold to u16_t */
  helper = chksum + *seg_chksum;
 800fa0e:	0020      	movs	r0, r4
 800fa10:	183b      	adds	r3, r7, r0
 800fa12:	881b      	ldrh	r3, [r3, #0]
 800fa14:	68ba      	ldr	r2, [r7, #8]
 800fa16:	8812      	ldrh	r2, [r2, #0]
 800fa18:	189b      	adds	r3, r3, r2
 800fa1a:	617b      	str	r3, [r7, #20]
  chksum = FOLD_U32T(helper);
 800fa1c:	697b      	ldr	r3, [r7, #20]
 800fa1e:	0c1b      	lsrs	r3, r3, #16
 800fa20:	b299      	uxth	r1, r3
 800fa22:	697b      	ldr	r3, [r7, #20]
 800fa24:	b29a      	uxth	r2, r3
 800fa26:	183b      	adds	r3, r7, r0
 800fa28:	188a      	adds	r2, r1, r2
 800fa2a:	801a      	strh	r2, [r3, #0]
  if ((len & 1) != 0) {
 800fa2c:	197b      	adds	r3, r7, r5
 800fa2e:	881b      	ldrh	r3, [r3, #0]
 800fa30:	2201      	movs	r2, #1
 800fa32:	4013      	ands	r3, r2
 800fa34:	d013      	beq.n	800fa5e <tcp_seg_add_chksum+0x6a>
    *seg_chksum_swapped = 1 - *seg_chksum_swapped;
 800fa36:	687b      	ldr	r3, [r7, #4]
 800fa38:	781b      	ldrb	r3, [r3, #0]
 800fa3a:	2201      	movs	r2, #1
 800fa3c:	1ad3      	subs	r3, r2, r3
 800fa3e:	b2da      	uxtb	r2, r3
 800fa40:	687b      	ldr	r3, [r7, #4]
 800fa42:	701a      	strb	r2, [r3, #0]
    chksum = SWAP_BYTES_IN_WORD(chksum);
 800fa44:	183b      	adds	r3, r7, r0
 800fa46:	881b      	ldrh	r3, [r3, #0]
 800fa48:	021b      	lsls	r3, r3, #8
 800fa4a:	b21a      	sxth	r2, r3
 800fa4c:	183b      	adds	r3, r7, r0
 800fa4e:	881b      	ldrh	r3, [r3, #0]
 800fa50:	0a1b      	lsrs	r3, r3, #8
 800fa52:	b29b      	uxth	r3, r3
 800fa54:	b21b      	sxth	r3, r3
 800fa56:	4313      	orrs	r3, r2
 800fa58:	b21a      	sxth	r2, r3
 800fa5a:	183b      	adds	r3, r7, r0
 800fa5c:	801a      	strh	r2, [r3, #0]
  }
  *seg_chksum = chksum;
 800fa5e:	68bb      	ldr	r3, [r7, #8]
 800fa60:	220e      	movs	r2, #14
 800fa62:	18ba      	adds	r2, r7, r2
 800fa64:	8812      	ldrh	r2, [r2, #0]
 800fa66:	801a      	strh	r2, [r3, #0]
}
 800fa68:	46c0      	nop			; (mov r8, r8)
 800fa6a:	46bd      	mov	sp, r7
 800fa6c:	b006      	add	sp, #24
 800fa6e:	bdb0      	pop	{r4, r5, r7, pc}

0800fa70 <tcp_write_checks>:
 * @param len length of data to send (checked agains snd_buf)
 * @return ERR_OK if tcp_write is allowed to proceed, another err_t otherwise
 */
static err_t
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
 800fa70:	b580      	push	{r7, lr}
 800fa72:	b082      	sub	sp, #8
 800fa74:	af00      	add	r7, sp, #0
 800fa76:	6078      	str	r0, [r7, #4]
 800fa78:	000a      	movs	r2, r1
 800fa7a:	1cbb      	adds	r3, r7, #2
 800fa7c:	801a      	strh	r2, [r3, #0]
  LWIP_ASSERT("tcp_write_checks: invalid pcb", pcb != NULL);
 800fa7e:	687b      	ldr	r3, [r7, #4]
 800fa80:	2b00      	cmp	r3, #0
 800fa82:	d106      	bne.n	800fa92 <tcp_write_checks+0x22>
 800fa84:	4b34      	ldr	r3, [pc, #208]	; (800fb58 <tcp_write_checks+0xe8>)
 800fa86:	2234      	movs	r2, #52	; 0x34
 800fa88:	32ff      	adds	r2, #255	; 0xff
 800fa8a:	4934      	ldr	r1, [pc, #208]	; (800fb5c <tcp_write_checks+0xec>)
 800fa8c:	4834      	ldr	r0, [pc, #208]	; (800fb60 <tcp_write_checks+0xf0>)
 800fa8e:	f7f3 f89b 	bl	8002bc8 <app_debug_rtt_raw>

  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
 800fa92:	687b      	ldr	r3, [r7, #4]
 800fa94:	7e1b      	ldrb	r3, [r3, #24]
 800fa96:	2b04      	cmp	r3, #4
 800fa98:	d00e      	beq.n	800fab8 <tcp_write_checks+0x48>
      (pcb->state != CLOSE_WAIT) &&
 800fa9a:	687b      	ldr	r3, [r7, #4]
 800fa9c:	7e1b      	ldrb	r3, [r3, #24]
  if ((pcb->state != ESTABLISHED) &&
 800fa9e:	2b07      	cmp	r3, #7
 800faa0:	d00a      	beq.n	800fab8 <tcp_write_checks+0x48>
      (pcb->state != SYN_SENT) &&
 800faa2:	687b      	ldr	r3, [r7, #4]
 800faa4:	7e1b      	ldrb	r3, [r3, #24]
      (pcb->state != CLOSE_WAIT) &&
 800faa6:	2b02      	cmp	r3, #2
 800faa8:	d006      	beq.n	800fab8 <tcp_write_checks+0x48>
      (pcb->state != SYN_RCVD)) {
 800faaa:	687b      	ldr	r3, [r7, #4]
 800faac:	7e1b      	ldrb	r3, [r3, #24]
      (pcb->state != SYN_SENT) &&
 800faae:	2b03      	cmp	r3, #3
 800fab0:	d002      	beq.n	800fab8 <tcp_write_checks+0x48>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
 800fab2:	230b      	movs	r3, #11
 800fab4:	425b      	negs	r3, r3
 800fab6:	e04a      	b.n	800fb4e <tcp_write_checks+0xde>
  } else if (len == 0) {
 800fab8:	1cbb      	adds	r3, r7, #2
 800faba:	881b      	ldrh	r3, [r3, #0]
 800fabc:	2b00      	cmp	r3, #0
 800fabe:	d101      	bne.n	800fac4 <tcp_write_checks+0x54>
    return ERR_OK;
 800fac0:	2300      	movs	r3, #0
 800fac2:	e044      	b.n	800fb4e <tcp_write_checks+0xde>
  }

  /* fail on too much data */
  if (len > pcb->snd_buf) {
 800fac4:	687b      	ldr	r3, [r7, #4]
 800fac6:	2268      	movs	r2, #104	; 0x68
 800fac8:	5a9b      	ldrh	r3, [r3, r2]
 800faca:	1cba      	adds	r2, r7, #2
 800facc:	8812      	ldrh	r2, [r2, #0]
 800face:	429a      	cmp	r2, r3
 800fad0:	d909      	bls.n	800fae6 <tcp_write_checks+0x76>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("tcp_write: too much data (len=%"U16_F" > snd_buf=%"TCPWNDSIZE_F")\n",
                len, pcb->snd_buf));
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
 800fad2:	687b      	ldr	r3, [r7, #4]
 800fad4:	8bdb      	ldrh	r3, [r3, #30]
 800fad6:	2280      	movs	r2, #128	; 0x80
 800fad8:	4313      	orrs	r3, r2
 800fada:	b29a      	uxth	r2, r3
 800fadc:	687b      	ldr	r3, [r7, #4]
 800fade:	83da      	strh	r2, [r3, #30]
    return ERR_MEM;
 800fae0:	2301      	movs	r3, #1
 800fae2:	425b      	negs	r3, r3
 800fae4:	e033      	b.n	800fb4e <tcp_write_checks+0xde>
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"TCPWNDSIZE_F"\n", (tcpwnd_size_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  /* check for configured max queuelen and possible overflow */
  if (pcb->snd_queuelen >= LWIP_MIN(TCP_SND_QUEUELEN, (TCP_SNDQUEUELEN_OVERFLOW + 1))) {
 800fae6:	687b      	ldr	r3, [r7, #4]
 800fae8:	226a      	movs	r2, #106	; 0x6a
 800faea:	5a9b      	ldrh	r3, [r3, r2]
 800faec:	2b07      	cmp	r3, #7
 800faee:	d909      	bls.n	800fb04 <tcp_write_checks+0x94>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("tcp_write: too long queue %"U16_F" (max %"U16_F")\n",
                pcb->snd_queuelen, (u16_t)TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
 800faf0:	687b      	ldr	r3, [r7, #4]
 800faf2:	8bdb      	ldrh	r3, [r3, #30]
 800faf4:	2280      	movs	r2, #128	; 0x80
 800faf6:	4313      	orrs	r3, r2
 800faf8:	b29a      	uxth	r2, r3
 800fafa:	687b      	ldr	r3, [r7, #4]
 800fafc:	83da      	strh	r2, [r3, #30]
    return ERR_MEM;
 800fafe:	2301      	movs	r3, #1
 800fb00:	425b      	negs	r3, r3
 800fb02:	e024      	b.n	800fb4e <tcp_write_checks+0xde>
  }
  if (pcb->snd_queuelen != 0) {
 800fb04:	687b      	ldr	r3, [r7, #4]
 800fb06:	226a      	movs	r2, #106	; 0x6a
 800fb08:	5a9b      	ldrh	r3, [r3, r2]
 800fb0a:	2b00      	cmp	r3, #0
 800fb0c:	d00f      	beq.n	800fb2e <tcp_write_checks+0xbe>
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
 800fb0e:	687b      	ldr	r3, [r7, #4]
 800fb10:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800fb12:	2b00      	cmp	r3, #0
 800fb14:	d11a      	bne.n	800fb4c <tcp_write_checks+0xdc>
 800fb16:	687b      	ldr	r3, [r7, #4]
 800fb18:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800fb1a:	2b00      	cmp	r3, #0
 800fb1c:	d116      	bne.n	800fb4c <tcp_write_checks+0xdc>
 800fb1e:	4b0e      	ldr	r3, [pc, #56]	; (800fb58 <tcp_write_checks+0xe8>)
 800fb20:	2256      	movs	r2, #86	; 0x56
 800fb22:	32ff      	adds	r2, #255	; 0xff
 800fb24:	490f      	ldr	r1, [pc, #60]	; (800fb64 <tcp_write_checks+0xf4>)
 800fb26:	480e      	ldr	r0, [pc, #56]	; (800fb60 <tcp_write_checks+0xf0>)
 800fb28:	f7f3 f84e 	bl	8002bc8 <app_debug_rtt_raw>
 800fb2c:	e00e      	b.n	800fb4c <tcp_write_checks+0xdc>
                pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
 800fb2e:	687b      	ldr	r3, [r7, #4]
 800fb30:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800fb32:	2b00      	cmp	r3, #0
 800fb34:	d103      	bne.n	800fb3e <tcp_write_checks+0xce>
 800fb36:	687b      	ldr	r3, [r7, #4]
 800fb38:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800fb3a:	2b00      	cmp	r3, #0
 800fb3c:	d006      	beq.n	800fb4c <tcp_write_checks+0xdc>
 800fb3e:	4b06      	ldr	r3, [pc, #24]	; (800fb58 <tcp_write_checks+0xe8>)
 800fb40:	22ac      	movs	r2, #172	; 0xac
 800fb42:	0052      	lsls	r2, r2, #1
 800fb44:	4908      	ldr	r1, [pc, #32]	; (800fb68 <tcp_write_checks+0xf8>)
 800fb46:	4806      	ldr	r0, [pc, #24]	; (800fb60 <tcp_write_checks+0xf0>)
 800fb48:	f7f3 f83e 	bl	8002bc8 <app_debug_rtt_raw>
                pcb->unacked == NULL && pcb->unsent == NULL);
  }
  return ERR_OK;
 800fb4c:	2300      	movs	r3, #0
}
 800fb4e:	0018      	movs	r0, r3
 800fb50:	46bd      	mov	sp, r7
 800fb52:	b002      	add	sp, #8
 800fb54:	bd80      	pop	{r7, pc}
 800fb56:	46c0      	nop			; (mov r8, r8)
 800fb58:	08020a34 	.word	0x08020a34
 800fb5c:	08020b74 	.word	0x08020b74
 800fb60:	08020a80 	.word	0x08020a80
 800fb64:	08020b94 	.word	0x08020b94
 800fb68:	08020bd0 	.word	0x08020bd0

0800fb6c <tcp_write>:
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will not be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
 800fb6c:	b5b0      	push	{r4, r5, r7, lr}
 800fb6e:	b09e      	sub	sp, #120	; 0x78
 800fb70:	af04      	add	r7, sp, #16
 800fb72:	60f8      	str	r0, [r7, #12]
 800fb74:	60b9      	str	r1, [r7, #8]
 800fb76:	0019      	movs	r1, r3
 800fb78:	1dbb      	adds	r3, r7, #6
 800fb7a:	801a      	strh	r2, [r3, #0]
 800fb7c:	1d7b      	adds	r3, r7, #5
 800fb7e:	1c0a      	adds	r2, r1, #0
 800fb80:	701a      	strb	r2, [r3, #0]
  struct pbuf *concat_p = NULL;
 800fb82:	2300      	movs	r3, #0
 800fb84:	64bb      	str	r3, [r7, #72]	; 0x48
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 800fb86:	2300      	movs	r3, #0
 800fb88:	64fb      	str	r3, [r7, #76]	; 0x4c
 800fb8a:	2300      	movs	r3, #0
 800fb8c:	65fb      	str	r3, [r7, #92]	; 0x5c
 800fb8e:	2300      	movs	r3, #0
 800fb90:	65bb      	str	r3, [r7, #88]	; 0x58
 800fb92:	2300      	movs	r3, #0
 800fb94:	657b      	str	r3, [r7, #84]	; 0x54
  u16_t pos = 0; /* position in 'arg' data */
 800fb96:	2352      	movs	r3, #82	; 0x52
 800fb98:	18fb      	adds	r3, r7, r3
 800fb9a:	2200      	movs	r2, #0
 800fb9c:	801a      	strh	r2, [r3, #0]
  u16_t queuelen;
  u8_t optlen;
  u8_t optflags = 0;
 800fb9e:	2333      	movs	r3, #51	; 0x33
 800fba0:	18fb      	adds	r3, r7, r3
 800fba2:	2200      	movs	r2, #0
 800fba4:	701a      	strb	r2, [r3, #0]
#if TCP_OVERSIZE
  u16_t oversize = 0;
 800fba6:	231e      	movs	r3, #30
 800fba8:	18fb      	adds	r3, r7, r3
 800fbaa:	2200      	movs	r2, #0
 800fbac:	801a      	strh	r2, [r3, #0]
  u16_t oversize_used = 0;
 800fbae:	2362      	movs	r3, #98	; 0x62
 800fbb0:	18fb      	adds	r3, r7, r3
 800fbb2:	2200      	movs	r2, #0
 800fbb4:	801a      	strh	r2, [r3, #0]
#if TCP_OVERSIZE_DBGCHECK
  u16_t oversize_add = 0;
 800fbb6:	2366      	movs	r3, #102	; 0x66
 800fbb8:	18fb      	adds	r3, r7, r3
 800fbba:	2200      	movs	r2, #0
 800fbbc:	801a      	strh	r2, [r3, #0]
#endif /* TCP_OVERSIZE_DBGCHECK*/
#endif /* TCP_OVERSIZE */
  u16_t extendlen = 0;
 800fbbe:	2364      	movs	r3, #100	; 0x64
 800fbc0:	18fb      	adds	r3, r7, r3
 800fbc2:	2200      	movs	r2, #0
 800fbc4:	801a      	strh	r2, [r3, #0]
#if TCP_CHECKSUM_ON_COPY
  u16_t concat_chksum = 0;
 800fbc6:	231c      	movs	r3, #28
 800fbc8:	18fb      	adds	r3, r7, r3
 800fbca:	2200      	movs	r2, #0
 800fbcc:	801a      	strh	r2, [r3, #0]
  u8_t concat_chksum_swapped = 0;
 800fbce:	231b      	movs	r3, #27
 800fbd0:	18fb      	adds	r3, r7, r3
 800fbd2:	2200      	movs	r2, #0
 800fbd4:	701a      	strb	r2, [r3, #0]
  u16_t concat_chksummed = 0;
 800fbd6:	2346      	movs	r3, #70	; 0x46
 800fbd8:	18fb      	adds	r3, r7, r3
 800fbda:	2200      	movs	r2, #0
 800fbdc:	801a      	strh	r2, [r3, #0]
#endif /* TCP_CHECKSUM_ON_COPY */
  err_t err;
  u16_t mss_local;

  LWIP_ERROR("tcp_write: invalid pcb", pcb != NULL, return ERR_ARG);
 800fbde:	68fb      	ldr	r3, [r7, #12]
 800fbe0:	2b00      	cmp	r3, #0
 800fbe2:	d107      	bne.n	800fbf4 <tcp_write+0x88>
 800fbe4:	4bca      	ldr	r3, [pc, #808]	; (800ff10 <tcp_write+0x3a4>)
 800fbe6:	0018      	movs	r0, r3
 800fbe8:	f7f2 ffee 	bl	8002bc8 <app_debug_rtt_raw>
 800fbec:	2310      	movs	r3, #16
 800fbee:	425b      	negs	r3, r3
 800fbf0:	f000 fcfb 	bl	80105ea <tcp_write+0xa7e>

  /* don't allocate segments bigger than half the maximum window we ever received */
  mss_local = LWIP_MIN(pcb->mss, TCPWND_MIN16(pcb->snd_wnd_max / 2));
 800fbf4:	68fb      	ldr	r3, [r7, #12]
 800fbf6:	2266      	movs	r2, #102	; 0x66
 800fbf8:	5a9b      	ldrh	r3, [r3, r2]
 800fbfa:	085b      	lsrs	r3, r3, #1
 800fbfc:	b299      	uxth	r1, r3
 800fbfe:	68fb      	ldr	r3, [r7, #12]
 800fc00:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800fc02:	2230      	movs	r2, #48	; 0x30
 800fc04:	18ba      	adds	r2, r7, r2
 800fc06:	1c1c      	adds	r4, r3, #0
 800fc08:	1c0b      	adds	r3, r1, #0
 800fc0a:	b298      	uxth	r0, r3
 800fc0c:	b2a1      	uxth	r1, r4
 800fc0e:	4288      	cmp	r0, r1
 800fc10:	d900      	bls.n	800fc14 <tcp_write+0xa8>
 800fc12:	1c23      	adds	r3, r4, #0
 800fc14:	8013      	strh	r3, [r2, #0]
  mss_local = mss_local ? mss_local : pcb->mss;
 800fc16:	2330      	movs	r3, #48	; 0x30
 800fc18:	18fb      	adds	r3, r7, r3
 800fc1a:	881b      	ldrh	r3, [r3, #0]
 800fc1c:	2b00      	cmp	r3, #0
 800fc1e:	d102      	bne.n	800fc26 <tcp_write+0xba>
 800fc20:	68fb      	ldr	r3, [r7, #12]
 800fc22:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800fc24:	e002      	b.n	800fc2c <tcp_write+0xc0>
 800fc26:	2330      	movs	r3, #48	; 0x30
 800fc28:	18fb      	adds	r3, r7, r3
 800fc2a:	881b      	ldrh	r3, [r3, #0]
 800fc2c:	2230      	movs	r2, #48	; 0x30
 800fc2e:	18ba      	adds	r2, r7, r2
 800fc30:	8013      	strh	r3, [r2, #0]
  apiflags |= TCP_WRITE_FLAG_COPY;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
                                 (void *)pcb, arg, len, (u16_t)apiflags));
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)",
 800fc32:	68bb      	ldr	r3, [r7, #8]
 800fc34:	2b00      	cmp	r3, #0
 800fc36:	d107      	bne.n	800fc48 <tcp_write+0xdc>
 800fc38:	4bb6      	ldr	r3, [pc, #728]	; (800ff14 <tcp_write+0x3a8>)
 800fc3a:	0018      	movs	r0, r3
 800fc3c:	f7f2 ffc4 	bl	8002bc8 <app_debug_rtt_raw>
 800fc40:	2310      	movs	r3, #16
 800fc42:	425b      	negs	r3, r3
 800fc44:	f000 fcd1 	bl	80105ea <tcp_write+0xa7e>
             arg != NULL, return ERR_ARG;);

  err = tcp_write_checks(pcb, len);
 800fc48:	252f      	movs	r5, #47	; 0x2f
 800fc4a:	197c      	adds	r4, r7, r5
 800fc4c:	1dbb      	adds	r3, r7, #6
 800fc4e:	881a      	ldrh	r2, [r3, #0]
 800fc50:	68fb      	ldr	r3, [r7, #12]
 800fc52:	0011      	movs	r1, r2
 800fc54:	0018      	movs	r0, r3
 800fc56:	f7ff ff0b 	bl	800fa70 <tcp_write_checks>
 800fc5a:	0003      	movs	r3, r0
 800fc5c:	7023      	strb	r3, [r4, #0]
  if (err != ERR_OK) {
 800fc5e:	197b      	adds	r3, r7, r5
 800fc60:	781b      	ldrb	r3, [r3, #0]
 800fc62:	b25b      	sxtb	r3, r3
 800fc64:	2b00      	cmp	r3, #0
 800fc66:	d004      	beq.n	800fc72 <tcp_write+0x106>
    return err;
 800fc68:	197b      	adds	r3, r7, r5
 800fc6a:	781b      	ldrb	r3, [r3, #0]
 800fc6c:	b25b      	sxtb	r3, r3
 800fc6e:	f000 fcbc 	bl	80105ea <tcp_write+0xa7e>
  }
  queuelen = pcb->snd_queuelen;
 800fc72:	2350      	movs	r3, #80	; 0x50
 800fc74:	18fb      	adds	r3, r7, r3
 800fc76:	68fa      	ldr	r2, [r7, #12]
 800fc78:	216a      	movs	r1, #106	; 0x6a
 800fc7a:	5a52      	ldrh	r2, [r2, r1]
 800fc7c:	801a      	strh	r2, [r3, #0]
    /* ensure that segments can hold at least one data byte... */
    mss_local = LWIP_MAX(mss_local, LWIP_TCP_OPT_LEN_TS + 1);
  } else
#endif /* LWIP_TCP_TIMESTAMPS */
  {
    optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
 800fc7e:	232e      	movs	r3, #46	; 0x2e
 800fc80:	18fb      	adds	r3, r7, r3
 800fc82:	2200      	movs	r2, #0
 800fc84:	701a      	strb	r2, [r3, #0]
   *
   * pos records progress as data is segmented.
   */

  /* Find the tail of the unsent queue. */
  if (pcb->unsent != NULL) {
 800fc86:	68fb      	ldr	r3, [r7, #12]
 800fc88:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800fc8a:	2b00      	cmp	r3, #0
 800fc8c:	d100      	bne.n	800fc90 <tcp_write+0x124>
 800fc8e:	e19e      	b.n	800ffce <tcp_write+0x462>
    u16_t space;
    u16_t unsent_optlen;

    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 800fc90:	68fb      	ldr	r3, [r7, #12]
 800fc92:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800fc94:	64fb      	str	r3, [r7, #76]	; 0x4c
 800fc96:	e002      	b.n	800fc9e <tcp_write+0x132>
         last_unsent = last_unsent->next);
 800fc98:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fc9a:	681b      	ldr	r3, [r3, #0]
 800fc9c:	64fb      	str	r3, [r7, #76]	; 0x4c
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 800fc9e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fca0:	681b      	ldr	r3, [r3, #0]
 800fca2:	2b00      	cmp	r3, #0
 800fca4:	d1f8      	bne.n	800fc98 <tcp_write+0x12c>

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(last_unsent->flags, pcb);
 800fca6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fca8:	7bdb      	ldrb	r3, [r3, #15]
 800fcaa:	009b      	lsls	r3, r3, #2
 800fcac:	b29a      	uxth	r2, r3
 800fcae:	202c      	movs	r0, #44	; 0x2c
 800fcb0:	183b      	adds	r3, r7, r0
 800fcb2:	2104      	movs	r1, #4
 800fcb4:	400a      	ands	r2, r1
 800fcb6:	801a      	strh	r2, [r3, #0]
    LWIP_ASSERT("mss_local is too small", mss_local >= last_unsent->len + unsent_optlen);
 800fcb8:	2330      	movs	r3, #48	; 0x30
 800fcba:	18fb      	adds	r3, r7, r3
 800fcbc:	881a      	ldrh	r2, [r3, #0]
 800fcbe:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fcc0:	891b      	ldrh	r3, [r3, #8]
 800fcc2:	0019      	movs	r1, r3
 800fcc4:	183b      	adds	r3, r7, r0
 800fcc6:	881b      	ldrh	r3, [r3, #0]
 800fcc8:	18cb      	adds	r3, r1, r3
 800fcca:	429a      	cmp	r2, r3
 800fccc:	da06      	bge.n	800fcdc <tcp_write+0x170>
 800fcce:	4b92      	ldr	r3, [pc, #584]	; (800ff18 <tcp_write+0x3ac>)
 800fcd0:	22f3      	movs	r2, #243	; 0xf3
 800fcd2:	0052      	lsls	r2, r2, #1
 800fcd4:	4991      	ldr	r1, [pc, #580]	; (800ff1c <tcp_write+0x3b0>)
 800fcd6:	4892      	ldr	r0, [pc, #584]	; (800ff20 <tcp_write+0x3b4>)
 800fcd8:	f7f2 ff76 	bl	8002bc8 <app_debug_rtt_raw>
    space = mss_local - (last_unsent->len + unsent_optlen);
 800fcdc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fcde:	891a      	ldrh	r2, [r3, #8]
 800fce0:	232c      	movs	r3, #44	; 0x2c
 800fce2:	18fb      	adds	r3, r7, r3
 800fce4:	881b      	ldrh	r3, [r3, #0]
 800fce6:	18d3      	adds	r3, r2, r3
 800fce8:	b29a      	uxth	r2, r3
 800fcea:	2344      	movs	r3, #68	; 0x44
 800fcec:	18fb      	adds	r3, r7, r3
 800fcee:	2130      	movs	r1, #48	; 0x30
 800fcf0:	1879      	adds	r1, r7, r1
 800fcf2:	8809      	ldrh	r1, [r1, #0]
 800fcf4:	1a8a      	subs	r2, r1, r2
 800fcf6:	801a      	strh	r2, [r3, #0]
     * function.
     */
#if TCP_OVERSIZE
#if TCP_OVERSIZE_DBGCHECK
    /* check that pcb->unsent_oversize matches last_unsent->oversize_left */
    LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
 800fcf8:	68fb      	ldr	r3, [r7, #12]
 800fcfa:	226c      	movs	r2, #108	; 0x6c
 800fcfc:	5a9a      	ldrh	r2, [r3, r2]
 800fcfe:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fd00:	895b      	ldrh	r3, [r3, #10]
 800fd02:	429a      	cmp	r2, r3
 800fd04:	d006      	beq.n	800fd14 <tcp_write+0x1a8>
 800fd06:	4b84      	ldr	r3, [pc, #528]	; (800ff18 <tcp_write+0x3ac>)
 800fd08:	22f4      	movs	r2, #244	; 0xf4
 800fd0a:	32ff      	adds	r2, #255	; 0xff
 800fd0c:	4985      	ldr	r1, [pc, #532]	; (800ff24 <tcp_write+0x3b8>)
 800fd0e:	4884      	ldr	r0, [pc, #528]	; (800ff20 <tcp_write+0x3b4>)
 800fd10:	f7f2 ff5a 	bl	8002bc8 <app_debug_rtt_raw>
                pcb->unsent_oversize == last_unsent->oversize_left);
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
 800fd14:	68fb      	ldr	r3, [r7, #12]
 800fd16:	226c      	movs	r2, #108	; 0x6c
 800fd18:	5a9a      	ldrh	r2, [r3, r2]
 800fd1a:	211e      	movs	r1, #30
 800fd1c:	187b      	adds	r3, r7, r1
 800fd1e:	801a      	strh	r2, [r3, #0]
    if (oversize > 0) {
 800fd20:	000a      	movs	r2, r1
 800fd22:	18bb      	adds	r3, r7, r2
 800fd24:	881b      	ldrh	r3, [r3, #0]
 800fd26:	2b00      	cmp	r3, #0
 800fd28:	d041      	beq.n	800fdae <tcp_write+0x242>
      LWIP_ASSERT("inconsistent oversize vs. space", oversize <= space);
 800fd2a:	18bb      	adds	r3, r7, r2
 800fd2c:	881b      	ldrh	r3, [r3, #0]
 800fd2e:	2244      	movs	r2, #68	; 0x44
 800fd30:	18ba      	adds	r2, r7, r2
 800fd32:	8812      	ldrh	r2, [r2, #0]
 800fd34:	429a      	cmp	r2, r3
 800fd36:	d206      	bcs.n	800fd46 <tcp_write+0x1da>
 800fd38:	4b77      	ldr	r3, [pc, #476]	; (800ff18 <tcp_write+0x3ac>)
 800fd3a:	22fc      	movs	r2, #252	; 0xfc
 800fd3c:	0052      	lsls	r2, r2, #1
 800fd3e:	497a      	ldr	r1, [pc, #488]	; (800ff28 <tcp_write+0x3bc>)
 800fd40:	4877      	ldr	r0, [pc, #476]	; (800ff20 <tcp_write+0x3b4>)
 800fd42:	f7f2 ff41 	bl	8002bc8 <app_debug_rtt_raw>
      seg = last_unsent;
 800fd46:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fd48:	65fb      	str	r3, [r7, #92]	; 0x5c
      oversize_used = LWIP_MIN(space, LWIP_MIN(oversize, len));
 800fd4a:	231e      	movs	r3, #30
 800fd4c:	18fb      	adds	r3, r7, r3
 800fd4e:	881a      	ldrh	r2, [r3, #0]
 800fd50:	1dbb      	adds	r3, r7, #6
 800fd52:	1c10      	adds	r0, r2, #0
 800fd54:	881b      	ldrh	r3, [r3, #0]
 800fd56:	b299      	uxth	r1, r3
 800fd58:	b282      	uxth	r2, r0
 800fd5a:	4291      	cmp	r1, r2
 800fd5c:	d900      	bls.n	800fd60 <tcp_write+0x1f4>
 800fd5e:	1c03      	adds	r3, r0, #0
 800fd60:	b299      	uxth	r1, r3
 800fd62:	2362      	movs	r3, #98	; 0x62
 800fd64:	18fa      	adds	r2, r7, r3
 800fd66:	2344      	movs	r3, #68	; 0x44
 800fd68:	18fb      	adds	r3, r7, r3
 800fd6a:	1c0c      	adds	r4, r1, #0
 800fd6c:	881b      	ldrh	r3, [r3, #0]
 800fd6e:	b298      	uxth	r0, r3
 800fd70:	b2a1      	uxth	r1, r4
 800fd72:	4288      	cmp	r0, r1
 800fd74:	d900      	bls.n	800fd78 <tcp_write+0x20c>
 800fd76:	1c23      	adds	r3, r4, #0
 800fd78:	8013      	strh	r3, [r2, #0]
      pos += oversize_used;
 800fd7a:	2252      	movs	r2, #82	; 0x52
 800fd7c:	18bb      	adds	r3, r7, r2
 800fd7e:	18b9      	adds	r1, r7, r2
 800fd80:	2062      	movs	r0, #98	; 0x62
 800fd82:	183a      	adds	r2, r7, r0
 800fd84:	8809      	ldrh	r1, [r1, #0]
 800fd86:	8812      	ldrh	r2, [r2, #0]
 800fd88:	188a      	adds	r2, r1, r2
 800fd8a:	801a      	strh	r2, [r3, #0]
      oversize -= oversize_used;
 800fd8c:	211e      	movs	r1, #30
 800fd8e:	187b      	adds	r3, r7, r1
 800fd90:	881a      	ldrh	r2, [r3, #0]
 800fd92:	183b      	adds	r3, r7, r0
 800fd94:	881b      	ldrh	r3, [r3, #0]
 800fd96:	1ad3      	subs	r3, r2, r3
 800fd98:	b29a      	uxth	r2, r3
 800fd9a:	187b      	adds	r3, r7, r1
 800fd9c:	801a      	strh	r2, [r3, #0]
      space -= oversize_used;
 800fd9e:	2244      	movs	r2, #68	; 0x44
 800fda0:	18bb      	adds	r3, r7, r2
 800fda2:	18b9      	adds	r1, r7, r2
 800fda4:	183a      	adds	r2, r7, r0
 800fda6:	8809      	ldrh	r1, [r1, #0]
 800fda8:	8812      	ldrh	r2, [r2, #0]
 800fdaa:	1a8a      	subs	r2, r1, r2
 800fdac:	801a      	strh	r2, [r3, #0]
    }
    /* now we are either finished or oversize is zero */
    LWIP_ASSERT("inconsistent oversize vs. len", (oversize == 0) || (pos == len));
 800fdae:	231e      	movs	r3, #30
 800fdb0:	18fb      	adds	r3, r7, r3
 800fdb2:	881b      	ldrh	r3, [r3, #0]
 800fdb4:	2b00      	cmp	r3, #0
 800fdb6:	d00d      	beq.n	800fdd4 <tcp_write+0x268>
 800fdb8:	2352      	movs	r3, #82	; 0x52
 800fdba:	18fa      	adds	r2, r7, r3
 800fdbc:	1dbb      	adds	r3, r7, #6
 800fdbe:	8812      	ldrh	r2, [r2, #0]
 800fdc0:	881b      	ldrh	r3, [r3, #0]
 800fdc2:	429a      	cmp	r2, r3
 800fdc4:	d006      	beq.n	800fdd4 <tcp_write+0x268>
 800fdc6:	4b54      	ldr	r3, [pc, #336]	; (800ff18 <tcp_write+0x3ac>)
 800fdc8:	2280      	movs	r2, #128	; 0x80
 800fdca:	0092      	lsls	r2, r2, #2
 800fdcc:	4957      	ldr	r1, [pc, #348]	; (800ff2c <tcp_write+0x3c0>)
 800fdce:	4854      	ldr	r0, [pc, #336]	; (800ff20 <tcp_write+0x3b4>)
 800fdd0:	f7f2 fefa 	bl	8002bc8 <app_debug_rtt_raw>
     *
     * This phase is skipped for LWIP_NETIF_TX_SINGLE_PBUF as we could only execute
     * it after rexmit puts a segment from unacked to unsent and at this point,
     * oversize info is lost.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
 800fdd4:	2152      	movs	r1, #82	; 0x52
 800fdd6:	187a      	adds	r2, r7, r1
 800fdd8:	1dbb      	adds	r3, r7, #6
 800fdda:	8812      	ldrh	r2, [r2, #0]
 800fddc:	881b      	ldrh	r3, [r3, #0]
 800fdde:	429a      	cmp	r2, r3
 800fde0:	d300      	bcc.n	800fde4 <tcp_write+0x278>
 800fde2:	e23b      	b.n	801025c <tcp_write+0x6f0>
 800fde4:	2044      	movs	r0, #68	; 0x44
 800fde6:	183b      	adds	r3, r7, r0
 800fde8:	881b      	ldrh	r3, [r3, #0]
 800fdea:	2b00      	cmp	r3, #0
 800fdec:	d100      	bne.n	800fdf0 <tcp_write+0x284>
 800fdee:	e235      	b.n	801025c <tcp_write+0x6f0>
 800fdf0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fdf2:	891b      	ldrh	r3, [r3, #8]
 800fdf4:	2b00      	cmp	r3, #0
 800fdf6:	d100      	bne.n	800fdfa <tcp_write+0x28e>
 800fdf8:	e230      	b.n	801025c <tcp_write+0x6f0>
      u16_t seglen = LWIP_MIN(space, len - pos);
 800fdfa:	1dbb      	adds	r3, r7, #6
 800fdfc:	881a      	ldrh	r2, [r3, #0]
 800fdfe:	187b      	adds	r3, r7, r1
 800fe00:	881b      	ldrh	r3, [r3, #0]
 800fe02:	1ad2      	subs	r2, r2, r3
 800fe04:	183b      	adds	r3, r7, r0
 800fe06:	881b      	ldrh	r3, [r3, #0]
 800fe08:	429a      	cmp	r2, r3
 800fe0a:	dd00      	ble.n	800fe0e <tcp_write+0x2a2>
 800fe0c:	001a      	movs	r2, r3
 800fe0e:	242a      	movs	r4, #42	; 0x2a
 800fe10:	193b      	adds	r3, r7, r4
 800fe12:	801a      	strh	r2, [r3, #0]
      seg = last_unsent;
 800fe14:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fe16:	65fb      	str	r3, [r7, #92]	; 0x5c

      /* Create a pbuf with a copy or reference to seglen bytes. We
       * can use PBUF_RAW here since the data appears in the middle of
       * a segment. A header will never be prepended. */
      if (apiflags & TCP_WRITE_FLAG_COPY) {
 800fe18:	1d7b      	adds	r3, r7, #5
 800fe1a:	781b      	ldrb	r3, [r3, #0]
 800fe1c:	2201      	movs	r2, #1
 800fe1e:	4013      	ands	r3, r2
 800fe20:	d04b      	beq.n	800feba <tcp_write+0x34e>
        /* Data is copied */
        if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
 800fe22:	251e      	movs	r5, #30
 800fe24:	1978      	adds	r0, r7, r5
 800fe26:	2344      	movs	r3, #68	; 0x44
 800fe28:	18fb      	adds	r3, r7, r3
 800fe2a:	881a      	ldrh	r2, [r3, #0]
 800fe2c:	193b      	adds	r3, r7, r4
 800fe2e:	8819      	ldrh	r1, [r3, #0]
 800fe30:	2301      	movs	r3, #1
 800fe32:	9302      	str	r3, [sp, #8]
 800fe34:	1d7b      	adds	r3, r7, #5
 800fe36:	781b      	ldrb	r3, [r3, #0]
 800fe38:	9301      	str	r3, [sp, #4]
 800fe3a:	68fb      	ldr	r3, [r7, #12]
 800fe3c:	9300      	str	r3, [sp, #0]
 800fe3e:	0003      	movs	r3, r0
 800fe40:	2000      	movs	r0, #0
 800fe42:	f7ff fd3b 	bl	800f8bc <tcp_pbuf_prealloc>
 800fe46:	0003      	movs	r3, r0
 800fe48:	64bb      	str	r3, [r7, #72]	; 0x48
 800fe4a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800fe4c:	2b00      	cmp	r3, #0
 800fe4e:	d101      	bne.n	800fe54 <tcp_write+0x2e8>
 800fe50:	f000 fb98 	bl	8010584 <tcp_write+0xa18>
                      ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n",
                       seglen));
          goto memerr;
        }
#if TCP_OVERSIZE_DBGCHECK
        oversize_add = oversize;
 800fe54:	2366      	movs	r3, #102	; 0x66
 800fe56:	18fb      	adds	r3, r7, r3
 800fe58:	197a      	adds	r2, r7, r5
 800fe5a:	8812      	ldrh	r2, [r2, #0]
 800fe5c:	801a      	strh	r2, [r3, #0]
#endif /* TCP_OVERSIZE_DBGCHECK */
        TCP_DATA_COPY2(concat_p->payload, (const u8_t *)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
 800fe5e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800fe60:	6858      	ldr	r0, [r3, #4]
 800fe62:	2352      	movs	r3, #82	; 0x52
 800fe64:	18fb      	adds	r3, r7, r3
 800fe66:	881b      	ldrh	r3, [r3, #0]
 800fe68:	68ba      	ldr	r2, [r7, #8]
 800fe6a:	18d1      	adds	r1, r2, r3
 800fe6c:	0025      	movs	r5, r4
 800fe6e:	193b      	adds	r3, r7, r4
 800fe70:	881b      	ldrh	r3, [r3, #0]
 800fe72:	001a      	movs	r2, r3
 800fe74:	f7f8 fc69 	bl	800874a <lwip_chksum_copy>
 800fe78:	0003      	movs	r3, r0
 800fe7a:	001c      	movs	r4, r3
 800fe7c:	231b      	movs	r3, #27
 800fe7e:	18f8      	adds	r0, r7, r3
 800fe80:	231c      	movs	r3, #28
 800fe82:	18fa      	adds	r2, r7, r3
 800fe84:	197b      	adds	r3, r7, r5
 800fe86:	8819      	ldrh	r1, [r3, #0]
 800fe88:	0003      	movs	r3, r0
 800fe8a:	0020      	movs	r0, r4
 800fe8c:	f7ff fdb2 	bl	800f9f4 <tcp_seg_add_chksum>
#if TCP_CHECKSUM_ON_COPY
        concat_chksummed += seglen;
 800fe90:	2246      	movs	r2, #70	; 0x46
 800fe92:	18bb      	adds	r3, r7, r2
 800fe94:	18b9      	adds	r1, r7, r2
 800fe96:	197a      	adds	r2, r7, r5
 800fe98:	8809      	ldrh	r1, [r1, #0]
 800fe9a:	8812      	ldrh	r2, [r2, #0]
 800fe9c:	188a      	adds	r2, r1, r2
 800fe9e:	801a      	strh	r2, [r3, #0]
#endif /* TCP_CHECKSUM_ON_COPY */
        queuelen += pbuf_clen(concat_p);
 800fea0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800fea2:	0018      	movs	r0, r3
 800fea4:	f7fa f8aa 	bl	8009ffc <pbuf_clen>
 800fea8:	0003      	movs	r3, r0
 800feaa:	0019      	movs	r1, r3
 800feac:	2250      	movs	r2, #80	; 0x50
 800feae:	18bb      	adds	r3, r7, r2
 800feb0:	18ba      	adds	r2, r7, r2
 800feb2:	8812      	ldrh	r2, [r2, #0]
 800feb4:	188a      	adds	r2, r1, r2
 800feb6:	801a      	strh	r2, [r3, #0]
 800feb8:	e07f      	b.n	800ffba <tcp_write+0x44e>
      } else {
        /* Data is not copied */
        /* If the last unsent pbuf is of type PBUF_ROM, try to extend it. */
        struct pbuf *p;
        for (p = last_unsent->p; p->next != NULL; p = p->next);
 800feba:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800febc:	685b      	ldr	r3, [r3, #4]
 800febe:	643b      	str	r3, [r7, #64]	; 0x40
 800fec0:	e002      	b.n	800fec8 <tcp_write+0x35c>
 800fec2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800fec4:	681b      	ldr	r3, [r3, #0]
 800fec6:	643b      	str	r3, [r7, #64]	; 0x40
 800fec8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800feca:	681b      	ldr	r3, [r3, #0]
 800fecc:	2b00      	cmp	r3, #0
 800fece:	d1f8      	bne.n	800fec2 <tcp_write+0x356>
        if (((p->type_internal & (PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS | PBUF_TYPE_FLAG_DATA_VOLATILE)) == 0) &&
 800fed0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800fed2:	7b1b      	ldrb	r3, [r3, #12]
 800fed4:	001a      	movs	r2, r3
 800fed6:	23c0      	movs	r3, #192	; 0xc0
 800fed8:	4013      	ands	r3, r2
 800feda:	d12d      	bne.n	800ff38 <tcp_write+0x3cc>
            (const u8_t *)p->payload + p->len == (const u8_t *)arg) {
 800fedc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800fede:	685b      	ldr	r3, [r3, #4]
 800fee0:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800fee2:	8952      	ldrh	r2, [r2, #10]
 800fee4:	189b      	adds	r3, r3, r2
        if (((p->type_internal & (PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS | PBUF_TYPE_FLAG_DATA_VOLATILE)) == 0) &&
 800fee6:	68ba      	ldr	r2, [r7, #8]
 800fee8:	429a      	cmp	r2, r3
 800feea:	d125      	bne.n	800ff38 <tcp_write+0x3cc>
          LWIP_ASSERT("tcp_write: ROM pbufs cannot be oversized", pos == 0);
 800feec:	2352      	movs	r3, #82	; 0x52
 800feee:	18fb      	adds	r3, r7, r3
 800fef0:	881b      	ldrh	r3, [r3, #0]
 800fef2:	2b00      	cmp	r3, #0
 800fef4:	d005      	beq.n	800ff02 <tcp_write+0x396>
 800fef6:	4b08      	ldr	r3, [pc, #32]	; (800ff18 <tcp_write+0x3ac>)
 800fef8:	4a0d      	ldr	r2, [pc, #52]	; (800ff30 <tcp_write+0x3c4>)
 800fefa:	490e      	ldr	r1, [pc, #56]	; (800ff34 <tcp_write+0x3c8>)
 800fefc:	4808      	ldr	r0, [pc, #32]	; (800ff20 <tcp_write+0x3b4>)
 800fefe:	f7f2 fe63 	bl	8002bc8 <app_debug_rtt_raw>
          extendlen = seglen;
 800ff02:	2364      	movs	r3, #100	; 0x64
 800ff04:	18fb      	adds	r3, r7, r3
 800ff06:	222a      	movs	r2, #42	; 0x2a
 800ff08:	18ba      	adds	r2, r7, r2
 800ff0a:	8812      	ldrh	r2, [r2, #0]
 800ff0c:	801a      	strh	r2, [r3, #0]
 800ff0e:	e034      	b.n	800ff7a <tcp_write+0x40e>
 800ff10:	08020c04 	.word	0x08020c04
 800ff14:	08020c1c 	.word	0x08020c1c
 800ff18:	08020a34 	.word	0x08020a34
 800ff1c:	08020c50 	.word	0x08020c50
 800ff20:	08020a80 	.word	0x08020a80
 800ff24:	08020c68 	.word	0x08020c68
 800ff28:	08020c98 	.word	0x08020c98
 800ff2c:	08020cb8 	.word	0x08020cb8
 800ff30:	00000231 	.word	0x00000231
 800ff34:	08020cd8 	.word	0x08020cd8
        } else {
          if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
 800ff38:	232a      	movs	r3, #42	; 0x2a
 800ff3a:	18fb      	adds	r3, r7, r3
 800ff3c:	881b      	ldrh	r3, [r3, #0]
 800ff3e:	2201      	movs	r2, #1
 800ff40:	0019      	movs	r1, r3
 800ff42:	2000      	movs	r0, #0
 800ff44:	f7f9 fc42 	bl	80097cc <pbuf_alloc>
 800ff48:	0003      	movs	r3, r0
 800ff4a:	64bb      	str	r3, [r7, #72]	; 0x48
 800ff4c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ff4e:	2b00      	cmp	r3, #0
 800ff50:	d100      	bne.n	800ff54 <tcp_write+0x3e8>
 800ff52:	e319      	b.n	8010588 <tcp_write+0xa1c>
            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                        ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
            goto memerr;
          }
          /* reference the non-volatile payload data */
          ((struct pbuf_rom *)concat_p)->payload = (const u8_t *)arg + pos;
 800ff54:	2352      	movs	r3, #82	; 0x52
 800ff56:	18fb      	adds	r3, r7, r3
 800ff58:	881b      	ldrh	r3, [r3, #0]
 800ff5a:	68ba      	ldr	r2, [r7, #8]
 800ff5c:	18d2      	adds	r2, r2, r3
 800ff5e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ff60:	605a      	str	r2, [r3, #4]
          queuelen += pbuf_clen(concat_p);
 800ff62:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ff64:	0018      	movs	r0, r3
 800ff66:	f7fa f849 	bl	8009ffc <pbuf_clen>
 800ff6a:	0003      	movs	r3, r0
 800ff6c:	0019      	movs	r1, r3
 800ff6e:	2250      	movs	r2, #80	; 0x50
 800ff70:	18bb      	adds	r3, r7, r2
 800ff72:	18ba      	adds	r2, r7, r2
 800ff74:	8812      	ldrh	r2, [r2, #0]
 800ff76:	188a      	adds	r2, r1, r2
 800ff78:	801a      	strh	r2, [r3, #0]
        }
#if TCP_CHECKSUM_ON_COPY
        /* calculate the checksum of nocopy-data */
        tcp_seg_add_chksum(~inet_chksum((const u8_t *)arg + pos, seglen), seglen,
 800ff7a:	2352      	movs	r3, #82	; 0x52
 800ff7c:	18fb      	adds	r3, r7, r3
 800ff7e:	881b      	ldrh	r3, [r3, #0]
 800ff80:	68ba      	ldr	r2, [r7, #8]
 800ff82:	18d2      	adds	r2, r2, r3
 800ff84:	252a      	movs	r5, #42	; 0x2a
 800ff86:	197b      	adds	r3, r7, r5
 800ff88:	881b      	ldrh	r3, [r3, #0]
 800ff8a:	0019      	movs	r1, r3
 800ff8c:	0010      	movs	r0, r2
 800ff8e:	f7f8 fb77 	bl	8008680 <inet_chksum>
 800ff92:	0003      	movs	r3, r0
 800ff94:	43db      	mvns	r3, r3
 800ff96:	b298      	uxth	r0, r3
 800ff98:	231b      	movs	r3, #27
 800ff9a:	18fc      	adds	r4, r7, r3
 800ff9c:	231c      	movs	r3, #28
 800ff9e:	18fa      	adds	r2, r7, r3
 800ffa0:	197b      	adds	r3, r7, r5
 800ffa2:	8819      	ldrh	r1, [r3, #0]
 800ffa4:	0023      	movs	r3, r4
 800ffa6:	f7ff fd25 	bl	800f9f4 <tcp_seg_add_chksum>
                           &concat_chksum, &concat_chksum_swapped);
        concat_chksummed += seglen;
 800ffaa:	2246      	movs	r2, #70	; 0x46
 800ffac:	18bb      	adds	r3, r7, r2
 800ffae:	18b9      	adds	r1, r7, r2
 800ffb0:	197a      	adds	r2, r7, r5
 800ffb2:	8809      	ldrh	r1, [r1, #0]
 800ffb4:	8812      	ldrh	r2, [r2, #0]
 800ffb6:	188a      	adds	r2, r1, r2
 800ffb8:	801a      	strh	r2, [r3, #0]
#endif /* TCP_CHECKSUM_ON_COPY */
      }

      pos += seglen;
 800ffba:	2252      	movs	r2, #82	; 0x52
 800ffbc:	18bb      	adds	r3, r7, r2
 800ffbe:	18b9      	adds	r1, r7, r2
 800ffc0:	222a      	movs	r2, #42	; 0x2a
 800ffc2:	18ba      	adds	r2, r7, r2
 800ffc4:	8809      	ldrh	r1, [r1, #0]
 800ffc6:	8812      	ldrh	r2, [r2, #0]
 800ffc8:	188a      	adds	r2, r1, r2
 800ffca:	801a      	strh	r2, [r3, #0]
 800ffcc:	e146      	b.n	801025c <tcp_write+0x6f0>
    }
#endif /* !LWIP_NETIF_TX_SINGLE_PBUF */
  } else {
#if TCP_OVERSIZE
    LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
 800ffce:	68fb      	ldr	r3, [r7, #12]
 800ffd0:	226c      	movs	r2, #108	; 0x6c
 800ffd2:	5a9b      	ldrh	r3, [r3, r2]
 800ffd4:	2b00      	cmp	r3, #0
 800ffd6:	d100      	bne.n	800ffda <tcp_write+0x46e>
 800ffd8:	e140      	b.n	801025c <tcp_write+0x6f0>
 800ffda:	4bb1      	ldr	r3, [pc, #708]	; (80102a0 <tcp_write+0x734>)
 800ffdc:	4ab1      	ldr	r2, [pc, #708]	; (80102a4 <tcp_write+0x738>)
 800ffde:	49b2      	ldr	r1, [pc, #712]	; (80102a8 <tcp_write+0x73c>)
 800ffe0:	48b2      	ldr	r0, [pc, #712]	; (80102ac <tcp_write+0x740>)
 800ffe2:	f7f2 fdf1 	bl	8002bc8 <app_debug_rtt_raw>
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
 800ffe6:	e139      	b.n	801025c <tcp_write+0x6f0>
    struct pbuf *p;
    u16_t left = len - pos;
 800ffe8:	2028      	movs	r0, #40	; 0x28
 800ffea:	183b      	adds	r3, r7, r0
 800ffec:	1db9      	adds	r1, r7, #6
 800ffee:	2252      	movs	r2, #82	; 0x52
 800fff0:	18ba      	adds	r2, r7, r2
 800fff2:	8809      	ldrh	r1, [r1, #0]
 800fff4:	8812      	ldrh	r2, [r2, #0]
 800fff6:	1a8a      	subs	r2, r1, r2
 800fff8:	801a      	strh	r2, [r3, #0]
    u16_t max_len = mss_local - optlen;
 800fffa:	232e      	movs	r3, #46	; 0x2e
 800fffc:	18fb      	adds	r3, r7, r3
 800fffe:	781b      	ldrb	r3, [r3, #0]
 8010000:	b29a      	uxth	r2, r3
 8010002:	2426      	movs	r4, #38	; 0x26
 8010004:	193b      	adds	r3, r7, r4
 8010006:	2130      	movs	r1, #48	; 0x30
 8010008:	1879      	adds	r1, r7, r1
 801000a:	8809      	ldrh	r1, [r1, #0]
 801000c:	1a8a      	subs	r2, r1, r2
 801000e:	801a      	strh	r2, [r3, #0]
    u16_t seglen = LWIP_MIN(left, max_len);
 8010010:	2324      	movs	r3, #36	; 0x24
 8010012:	18fa      	adds	r2, r7, r3
 8010014:	193b      	adds	r3, r7, r4
 8010016:	1839      	adds	r1, r7, r0
 8010018:	880c      	ldrh	r4, [r1, #0]
 801001a:	881b      	ldrh	r3, [r3, #0]
 801001c:	b298      	uxth	r0, r3
 801001e:	b2a1      	uxth	r1, r4
 8010020:	4288      	cmp	r0, r1
 8010022:	d900      	bls.n	8010026 <tcp_write+0x4ba>
 8010024:	1c23      	adds	r3, r4, #0
 8010026:	8013      	strh	r3, [r2, #0]
#if TCP_CHECKSUM_ON_COPY
    u16_t chksum = 0;
 8010028:	2318      	movs	r3, #24
 801002a:	18fb      	adds	r3, r7, r3
 801002c:	2200      	movs	r2, #0
 801002e:	801a      	strh	r2, [r3, #0]
    u8_t chksum_swapped = 0;
 8010030:	2317      	movs	r3, #23
 8010032:	18fb      	adds	r3, r7, r3
 8010034:	2200      	movs	r2, #0
 8010036:	701a      	strb	r2, [r3, #0]
#endif /* TCP_CHECKSUM_ON_COPY */

    if (apiflags & TCP_WRITE_FLAG_COPY) {
 8010038:	1d7b      	adds	r3, r7, #5
 801003a:	781b      	ldrb	r3, [r3, #0]
 801003c:	2201      	movs	r2, #1
 801003e:	4013      	ands	r3, r2
 8010040:	d04c      	beq.n	80100dc <tcp_write+0x570>
      /* If copy is set, memory should be allocated and data copied
       * into pbuf */
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
 8010042:	232e      	movs	r3, #46	; 0x2e
 8010044:	18fb      	adds	r3, r7, r3
 8010046:	781b      	ldrb	r3, [r3, #0]
 8010048:	b29a      	uxth	r2, r3
 801004a:	2524      	movs	r5, #36	; 0x24
 801004c:	197b      	adds	r3, r7, r5
 801004e:	881b      	ldrh	r3, [r3, #0]
 8010050:	18d3      	adds	r3, r2, r3
 8010052:	b299      	uxth	r1, r3
 8010054:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010056:	425a      	negs	r2, r3
 8010058:	4153      	adcs	r3, r2
 801005a:	b2db      	uxtb	r3, r3
 801005c:	001c      	movs	r4, r3
 801005e:	231e      	movs	r3, #30
 8010060:	18f8      	adds	r0, r7, r3
 8010062:	2330      	movs	r3, #48	; 0x30
 8010064:	18fb      	adds	r3, r7, r3
 8010066:	881a      	ldrh	r2, [r3, #0]
 8010068:	9402      	str	r4, [sp, #8]
 801006a:	1d7b      	adds	r3, r7, #5
 801006c:	781b      	ldrb	r3, [r3, #0]
 801006e:	9301      	str	r3, [sp, #4]
 8010070:	68fb      	ldr	r3, [r7, #12]
 8010072:	9300      	str	r3, [sp, #0]
 8010074:	0003      	movs	r3, r0
 8010076:	2038      	movs	r0, #56	; 0x38
 8010078:	f7ff fc20 	bl	800f8bc <tcp_pbuf_prealloc>
 801007c:	0003      	movs	r3, r0
 801007e:	63fb      	str	r3, [r7, #60]	; 0x3c
 8010080:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010082:	2b00      	cmp	r3, #0
 8010084:	d100      	bne.n	8010088 <tcp_write+0x51c>
 8010086:	e281      	b.n	801058c <tcp_write+0xa20>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
 8010088:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801008a:	895b      	ldrh	r3, [r3, #10]
 801008c:	197a      	adds	r2, r7, r5
 801008e:	8812      	ldrh	r2, [r2, #0]
 8010090:	429a      	cmp	r2, r3
 8010092:	d905      	bls.n	80100a0 <tcp_write+0x534>
 8010094:	4b82      	ldr	r3, [pc, #520]	; (80102a0 <tcp_write+0x734>)
 8010096:	4a86      	ldr	r2, [pc, #536]	; (80102b0 <tcp_write+0x744>)
 8010098:	4986      	ldr	r1, [pc, #536]	; (80102b4 <tcp_write+0x748>)
 801009a:	4884      	ldr	r0, [pc, #528]	; (80102ac <tcp_write+0x740>)
 801009c:	f7f2 fd94 	bl	8002bc8 <app_debug_rtt_raw>
                  (p->len >= seglen));
      TCP_DATA_COPY2((char *)p->payload + optlen, (const u8_t *)arg + pos, seglen, &chksum, &chksum_swapped);
 80100a0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80100a2:	685a      	ldr	r2, [r3, #4]
 80100a4:	232e      	movs	r3, #46	; 0x2e
 80100a6:	18fb      	adds	r3, r7, r3
 80100a8:	781b      	ldrb	r3, [r3, #0]
 80100aa:	18d0      	adds	r0, r2, r3
 80100ac:	2352      	movs	r3, #82	; 0x52
 80100ae:	18fb      	adds	r3, r7, r3
 80100b0:	881b      	ldrh	r3, [r3, #0]
 80100b2:	68ba      	ldr	r2, [r7, #8]
 80100b4:	18d1      	adds	r1, r2, r3
 80100b6:	2524      	movs	r5, #36	; 0x24
 80100b8:	197b      	adds	r3, r7, r5
 80100ba:	881b      	ldrh	r3, [r3, #0]
 80100bc:	001a      	movs	r2, r3
 80100be:	f7f8 fb44 	bl	800874a <lwip_chksum_copy>
 80100c2:	0003      	movs	r3, r0
 80100c4:	001c      	movs	r4, r3
 80100c6:	2317      	movs	r3, #23
 80100c8:	18f8      	adds	r0, r7, r3
 80100ca:	2318      	movs	r3, #24
 80100cc:	18fa      	adds	r2, r7, r3
 80100ce:	197b      	adds	r3, r7, r5
 80100d0:	8819      	ldrh	r1, [r3, #0]
 80100d2:	0003      	movs	r3, r0
 80100d4:	0020      	movs	r0, r4
 80100d6:	f7ff fc8d 	bl	800f9f4 <tcp_seg_add_chksum>
 80100da:	e061      	b.n	80101a0 <tcp_write+0x634>
       * sent out on the link (as it has to be ACKed by the remote
       * party) we can safely use PBUF_ROM instead of PBUF_REF here.
       */
      struct pbuf *p2;
#if TCP_OVERSIZE
      LWIP_ASSERT("oversize == 0", oversize == 0);
 80100dc:	231e      	movs	r3, #30
 80100de:	18fb      	adds	r3, r7, r3
 80100e0:	881b      	ldrh	r3, [r3, #0]
 80100e2:	2b00      	cmp	r3, #0
 80100e4:	d005      	beq.n	80100f2 <tcp_write+0x586>
 80100e6:	4b6e      	ldr	r3, [pc, #440]	; (80102a0 <tcp_write+0x734>)
 80100e8:	4a73      	ldr	r2, [pc, #460]	; (80102b8 <tcp_write+0x74c>)
 80100ea:	4974      	ldr	r1, [pc, #464]	; (80102bc <tcp_write+0x750>)
 80100ec:	486f      	ldr	r0, [pc, #444]	; (80102ac <tcp_write+0x740>)
 80100ee:	f7f2 fd6b 	bl	8002bc8 <app_debug_rtt_raw>
#endif /* TCP_OVERSIZE */
      if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
 80100f2:	2424      	movs	r4, #36	; 0x24
 80100f4:	193b      	adds	r3, r7, r4
 80100f6:	881b      	ldrh	r3, [r3, #0]
 80100f8:	2201      	movs	r2, #1
 80100fa:	0019      	movs	r1, r3
 80100fc:	2038      	movs	r0, #56	; 0x38
 80100fe:	f7f9 fb65 	bl	80097cc <pbuf_alloc>
 8010102:	0003      	movs	r3, r0
 8010104:	623b      	str	r3, [r7, #32]
 8010106:	6a3b      	ldr	r3, [r7, #32]
 8010108:	2b00      	cmp	r3, #0
 801010a:	d100      	bne.n	801010e <tcp_write+0x5a2>
 801010c:	e240      	b.n	8010590 <tcp_write+0xa24>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
#if TCP_CHECKSUM_ON_COPY
      /* calculate the checksum of nocopy-data */
      chksum = ~inet_chksum((const u8_t *)arg + pos, seglen);
 801010e:	2352      	movs	r3, #82	; 0x52
 8010110:	18fb      	adds	r3, r7, r3
 8010112:	881b      	ldrh	r3, [r3, #0]
 8010114:	68ba      	ldr	r2, [r7, #8]
 8010116:	18d2      	adds	r2, r2, r3
 8010118:	193b      	adds	r3, r7, r4
 801011a:	881b      	ldrh	r3, [r3, #0]
 801011c:	0019      	movs	r1, r3
 801011e:	0010      	movs	r0, r2
 8010120:	f7f8 faae 	bl	8008680 <inet_chksum>
 8010124:	0003      	movs	r3, r0
 8010126:	43db      	mvns	r3, r3
 8010128:	b29a      	uxth	r2, r3
 801012a:	2118      	movs	r1, #24
 801012c:	187b      	adds	r3, r7, r1
 801012e:	801a      	strh	r2, [r3, #0]
      if (seglen & 1) {
 8010130:	193b      	adds	r3, r7, r4
 8010132:	881b      	ldrh	r3, [r3, #0]
 8010134:	2201      	movs	r2, #1
 8010136:	4013      	ands	r3, r2
 8010138:	d011      	beq.n	801015e <tcp_write+0x5f2>
        chksum_swapped = 1;
 801013a:	2317      	movs	r3, #23
 801013c:	18fb      	adds	r3, r7, r3
 801013e:	2201      	movs	r2, #1
 8010140:	701a      	strb	r2, [r3, #0]
        chksum = SWAP_BYTES_IN_WORD(chksum);
 8010142:	187b      	adds	r3, r7, r1
 8010144:	881b      	ldrh	r3, [r3, #0]
 8010146:	021b      	lsls	r3, r3, #8
 8010148:	b21a      	sxth	r2, r3
 801014a:	187b      	adds	r3, r7, r1
 801014c:	881b      	ldrh	r3, [r3, #0]
 801014e:	0a1b      	lsrs	r3, r3, #8
 8010150:	b29b      	uxth	r3, r3
 8010152:	b21b      	sxth	r3, r3
 8010154:	4313      	orrs	r3, r2
 8010156:	b21b      	sxth	r3, r3
 8010158:	b29a      	uxth	r2, r3
 801015a:	187b      	adds	r3, r7, r1
 801015c:	801a      	strh	r2, [r3, #0]
      }
#endif /* TCP_CHECKSUM_ON_COPY */
      /* reference the non-volatile payload data */
      ((struct pbuf_rom *)p2)->payload = (const u8_t *)arg + pos;
 801015e:	2352      	movs	r3, #82	; 0x52
 8010160:	18fb      	adds	r3, r7, r3
 8010162:	881b      	ldrh	r3, [r3, #0]
 8010164:	68ba      	ldr	r2, [r7, #8]
 8010166:	18d2      	adds	r2, r2, r3
 8010168:	6a3b      	ldr	r3, [r7, #32]
 801016a:	605a      	str	r2, [r3, #4]

      /* Second, allocate a pbuf for the headers. */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 801016c:	232e      	movs	r3, #46	; 0x2e
 801016e:	18fb      	adds	r3, r7, r3
 8010170:	781b      	ldrb	r3, [r3, #0]
 8010172:	b29b      	uxth	r3, r3
 8010174:	22a0      	movs	r2, #160	; 0xa0
 8010176:	0092      	lsls	r2, r2, #2
 8010178:	0019      	movs	r1, r3
 801017a:	2038      	movs	r0, #56	; 0x38
 801017c:	f7f9 fb26 	bl	80097cc <pbuf_alloc>
 8010180:	0003      	movs	r3, r0
 8010182:	63fb      	str	r3, [r7, #60]	; 0x3c
 8010184:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010186:	2b00      	cmp	r3, #0
 8010188:	d104      	bne.n	8010194 <tcp_write+0x628>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p2);
 801018a:	6a3b      	ldr	r3, [r7, #32]
 801018c:	0018      	movs	r0, r3
 801018e:	f7f9 fe95 	bl	8009ebc <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: could not allocate memory for header pbuf\n"));
        goto memerr;
 8010192:	e200      	b.n	8010596 <tcp_write+0xa2a>
      }
      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(p/*header*/, p2/*data*/);
 8010194:	6a3a      	ldr	r2, [r7, #32]
 8010196:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010198:	0011      	movs	r1, r2
 801019a:	0018      	movs	r0, r3
 801019c:	f7f9 ff6e 	bl	800a07c <pbuf_cat>
    }

    queuelen += pbuf_clen(p);
 80101a0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80101a2:	0018      	movs	r0, r3
 80101a4:	f7f9 ff2a 	bl	8009ffc <pbuf_clen>
 80101a8:	0003      	movs	r3, r0
 80101aa:	0019      	movs	r1, r3
 80101ac:	2050      	movs	r0, #80	; 0x50
 80101ae:	183b      	adds	r3, r7, r0
 80101b0:	183a      	adds	r2, r7, r0
 80101b2:	8812      	ldrh	r2, [r2, #0]
 80101b4:	188a      	adds	r2, r1, r2
 80101b6:	801a      	strh	r2, [r3, #0]

    /* Now that there are more segments queued, we check again if the
     * length of the queue exceeds the configured maximum or
     * overflows. */
    if (queuelen > LWIP_MIN(TCP_SND_QUEUELEN, TCP_SNDQUEUELEN_OVERFLOW)) {
 80101b8:	183b      	adds	r3, r7, r0
 80101ba:	881b      	ldrh	r3, [r3, #0]
 80101bc:	2b08      	cmp	r3, #8
 80101be:	d904      	bls.n	80101ca <tcp_write+0x65e>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: queue too long %"U16_F" (%d)\n",
                  queuelen, (int)TCP_SND_QUEUELEN));
      pbuf_free(p);
 80101c0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80101c2:	0018      	movs	r0, r3
 80101c4:	f7f9 fe7a 	bl	8009ebc <pbuf_free>
      goto memerr;
 80101c8:	e1e5      	b.n	8010596 <tcp_write+0xa2a>
    }

    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
 80101ca:	68fb      	ldr	r3, [r7, #12]
 80101cc:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80101ce:	2352      	movs	r3, #82	; 0x52
 80101d0:	18fb      	adds	r3, r7, r3
 80101d2:	881b      	ldrh	r3, [r3, #0]
 80101d4:	18d2      	adds	r2, r2, r3
 80101d6:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 80101d8:	68f8      	ldr	r0, [r7, #12]
 80101da:	2333      	movs	r3, #51	; 0x33
 80101dc:	18fb      	adds	r3, r7, r3
 80101de:	781b      	ldrb	r3, [r3, #0]
 80101e0:	9300      	str	r3, [sp, #0]
 80101e2:	0013      	movs	r3, r2
 80101e4:	2200      	movs	r2, #0
 80101e6:	f7ff fa45 	bl	800f674 <tcp_create_segment>
 80101ea:	0003      	movs	r3, r0
 80101ec:	65fb      	str	r3, [r7, #92]	; 0x5c
 80101ee:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80101f0:	2b00      	cmp	r3, #0
 80101f2:	d100      	bne.n	80101f6 <tcp_write+0x68a>
 80101f4:	e1ce      	b.n	8010594 <tcp_write+0xa28>
      goto memerr;
    }
#if TCP_OVERSIZE_DBGCHECK
    seg->oversize_left = oversize;
 80101f6:	231e      	movs	r3, #30
 80101f8:	18fb      	adds	r3, r7, r3
 80101fa:	881a      	ldrh	r2, [r3, #0]
 80101fc:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80101fe:	815a      	strh	r2, [r3, #10]
#endif /* TCP_OVERSIZE_DBGCHECK */
#if TCP_CHECKSUM_ON_COPY
    seg->chksum = chksum;
 8010200:	2318      	movs	r3, #24
 8010202:	18fb      	adds	r3, r7, r3
 8010204:	881a      	ldrh	r2, [r3, #0]
 8010206:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010208:	819a      	strh	r2, [r3, #12]
    seg->chksum_swapped = chksum_swapped;
 801020a:	2317      	movs	r3, #23
 801020c:	18fb      	adds	r3, r7, r3
 801020e:	781a      	ldrb	r2, [r3, #0]
 8010210:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010212:	739a      	strb	r2, [r3, #14]
    seg->flags |= TF_SEG_DATA_CHECKSUMMED;
 8010214:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010216:	7bdb      	ldrb	r3, [r3, #15]
 8010218:	2204      	movs	r2, #4
 801021a:	4313      	orrs	r3, r2
 801021c:	b2da      	uxtb	r2, r3
 801021e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010220:	73da      	strb	r2, [r3, #15]
#endif /* TCP_CHECKSUM_ON_COPY */

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
 8010222:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010224:	2b00      	cmp	r3, #0
 8010226:	d102      	bne.n	801022e <tcp_write+0x6c2>
      queue = seg;
 8010228:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801022a:	657b      	str	r3, [r7, #84]	; 0x54
 801022c:	e00b      	b.n	8010246 <tcp_write+0x6da>
    } else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
 801022e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010230:	2b00      	cmp	r3, #0
 8010232:	d105      	bne.n	8010240 <tcp_write+0x6d4>
 8010234:	4b1a      	ldr	r3, [pc, #104]	; (80102a0 <tcp_write+0x734>)
 8010236:	4a22      	ldr	r2, [pc, #136]	; (80102c0 <tcp_write+0x754>)
 8010238:	4922      	ldr	r1, [pc, #136]	; (80102c4 <tcp_write+0x758>)
 801023a:	481c      	ldr	r0, [pc, #112]	; (80102ac <tcp_write+0x740>)
 801023c:	f7f2 fcc4 	bl	8002bc8 <app_debug_rtt_raw>
      prev_seg->next = seg;
 8010240:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010242:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8010244:	601a      	str	r2, [r3, #0]
    }
    /* remember last segment of to-be-queued data for next iteration */
    prev_seg = seg;
 8010246:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010248:	65bb      	str	r3, [r7, #88]	; 0x58

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
                lwip_ntohl(seg->tcphdr->seqno),
                lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));

    pos += seglen;
 801024a:	2252      	movs	r2, #82	; 0x52
 801024c:	18bb      	adds	r3, r7, r2
 801024e:	18b9      	adds	r1, r7, r2
 8010250:	2224      	movs	r2, #36	; 0x24
 8010252:	18ba      	adds	r2, r7, r2
 8010254:	8809      	ldrh	r1, [r1, #0]
 8010256:	8812      	ldrh	r2, [r2, #0]
 8010258:	188a      	adds	r2, r1, r2
 801025a:	801a      	strh	r2, [r3, #0]
  while (pos < len) {
 801025c:	2352      	movs	r3, #82	; 0x52
 801025e:	18fa      	adds	r2, r7, r3
 8010260:	1dbb      	adds	r3, r7, #6
 8010262:	8812      	ldrh	r2, [r2, #0]
 8010264:	881b      	ldrh	r3, [r3, #0]
 8010266:	429a      	cmp	r2, r3
 8010268:	d200      	bcs.n	801026c <tcp_write+0x700>
 801026a:	e6bd      	b.n	800ffe8 <tcp_write+0x47c>
  /*
   * All three segmentation phases were successful. We can commit the
   * transaction.
   */
#if TCP_OVERSIZE_DBGCHECK
  if ((last_unsent != NULL) && (oversize_add != 0)) {
 801026c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801026e:	2b00      	cmp	r3, #0
 8010270:	d00c      	beq.n	801028c <tcp_write+0x720>
 8010272:	2166      	movs	r1, #102	; 0x66
 8010274:	187b      	adds	r3, r7, r1
 8010276:	881b      	ldrh	r3, [r3, #0]
 8010278:	2b00      	cmp	r3, #0
 801027a:	d007      	beq.n	801028c <tcp_write+0x720>
    last_unsent->oversize_left += oversize_add;
 801027c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801027e:	895a      	ldrh	r2, [r3, #10]
 8010280:	187b      	adds	r3, r7, r1
 8010282:	881b      	ldrh	r3, [r3, #0]
 8010284:	18d3      	adds	r3, r2, r3
 8010286:	b29a      	uxth	r2, r3
 8010288:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801028a:	815a      	strh	r2, [r3, #10]
  /*
   * Phase 1: If data has been added to the preallocated tail of
   * last_unsent, we update the length fields of the pbuf chain.
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
 801028c:	2362      	movs	r3, #98	; 0x62
 801028e:	18fb      	adds	r3, r7, r3
 8010290:	881b      	ldrh	r3, [r3, #0]
 8010292:	2b00      	cmp	r3, #0
 8010294:	d100      	bne.n	8010298 <tcp_write+0x72c>
 8010296:	e071      	b.n	801037c <tcp_write+0x810>
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
 8010298:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801029a:	685b      	ldr	r3, [r3, #4]
 801029c:	63bb      	str	r3, [r7, #56]	; 0x38
 801029e:	e04c      	b.n	801033a <tcp_write+0x7ce>
 80102a0:	08020a34 	.word	0x08020a34
 80102a4:	0000024a 	.word	0x0000024a
 80102a8:	08020d04 	.word	0x08020d04
 80102ac:	08020a80 	.word	0x08020a80
 80102b0:	00000266 	.word	0x00000266
 80102b4:	08020d34 	.word	0x08020d34
 80102b8:	00000271 	.word	0x00000271
 80102bc:	08020d74 	.word	0x08020d74
 80102c0:	000002ab 	.word	0x000002ab
 80102c4:	08020d84 	.word	0x08020d84
      p->tot_len += oversize_used;
 80102c8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80102ca:	891a      	ldrh	r2, [r3, #8]
 80102cc:	2162      	movs	r1, #98	; 0x62
 80102ce:	187b      	adds	r3, r7, r1
 80102d0:	881b      	ldrh	r3, [r3, #0]
 80102d2:	18d3      	adds	r3, r2, r3
 80102d4:	b29a      	uxth	r2, r3
 80102d6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80102d8:	811a      	strh	r2, [r3, #8]
      if (p->next == NULL) {
 80102da:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80102dc:	681b      	ldr	r3, [r3, #0]
 80102de:	2b00      	cmp	r3, #0
 80102e0:	d128      	bne.n	8010334 <tcp_write+0x7c8>
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
 80102e2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80102e4:	685b      	ldr	r3, [r3, #4]
 80102e6:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80102e8:	8952      	ldrh	r2, [r2, #10]
 80102ea:	1898      	adds	r0, r3, r2
 80102ec:	000d      	movs	r5, r1
 80102ee:	197b      	adds	r3, r7, r5
 80102f0:	881a      	ldrh	r2, [r3, #0]
 80102f2:	68bb      	ldr	r3, [r7, #8]
 80102f4:	0019      	movs	r1, r3
 80102f6:	f7f8 fa28 	bl	800874a <lwip_chksum_copy>
 80102fa:	0003      	movs	r3, r0
 80102fc:	001c      	movs	r4, r3
 80102fe:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010300:	330c      	adds	r3, #12
 8010302:	001a      	movs	r2, r3
 8010304:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010306:	330e      	adds	r3, #14
 8010308:	0018      	movs	r0, r3
 801030a:	197b      	adds	r3, r7, r5
 801030c:	8819      	ldrh	r1, [r3, #0]
 801030e:	0003      	movs	r3, r0
 8010310:	0020      	movs	r0, r4
 8010312:	f7ff fb6f 	bl	800f9f4 <tcp_seg_add_chksum>
 8010316:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010318:	7bdb      	ldrb	r3, [r3, #15]
 801031a:	2204      	movs	r2, #4
 801031c:	4313      	orrs	r3, r2
 801031e:	b2da      	uxtb	r2, r3
 8010320:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010322:	73da      	strb	r2, [r3, #15]
        p->len += oversize_used;
 8010324:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010326:	895a      	ldrh	r2, [r3, #10]
 8010328:	197b      	adds	r3, r7, r5
 801032a:	881b      	ldrh	r3, [r3, #0]
 801032c:	18d3      	adds	r3, r2, r3
 801032e:	b29a      	uxth	r2, r3
 8010330:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010332:	815a      	strh	r2, [r3, #10]
    for (p = last_unsent->p; p; p = p->next) {
 8010334:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010336:	681b      	ldr	r3, [r3, #0]
 8010338:	63bb      	str	r3, [r7, #56]	; 0x38
 801033a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801033c:	2b00      	cmp	r3, #0
 801033e:	d1c3      	bne.n	80102c8 <tcp_write+0x75c>
      }
    }
    last_unsent->len += oversize_used;
 8010340:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010342:	891a      	ldrh	r2, [r3, #8]
 8010344:	2162      	movs	r1, #98	; 0x62
 8010346:	187b      	adds	r3, r7, r1
 8010348:	881b      	ldrh	r3, [r3, #0]
 801034a:	18d3      	adds	r3, r2, r3
 801034c:	b29a      	uxth	r2, r3
 801034e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010350:	811a      	strh	r2, [r3, #8]
#if TCP_OVERSIZE_DBGCHECK
    LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
 8010352:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010354:	895b      	ldrh	r3, [r3, #10]
 8010356:	187a      	adds	r2, r7, r1
 8010358:	8812      	ldrh	r2, [r2, #0]
 801035a:	429a      	cmp	r2, r3
 801035c:	d905      	bls.n	801036a <tcp_write+0x7fe>
 801035e:	4ba5      	ldr	r3, [pc, #660]	; (80105f4 <tcp_write+0xa88>)
 8010360:	4aa5      	ldr	r2, [pc, #660]	; (80105f8 <tcp_write+0xa8c>)
 8010362:	49a6      	ldr	r1, [pc, #664]	; (80105fc <tcp_write+0xa90>)
 8010364:	48a6      	ldr	r0, [pc, #664]	; (8010600 <tcp_write+0xa94>)
 8010366:	f7f2 fc2f 	bl	8002bc8 <app_debug_rtt_raw>
                last_unsent->oversize_left >= oversize_used);
    last_unsent->oversize_left -= oversize_used;
 801036a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801036c:	895a      	ldrh	r2, [r3, #10]
 801036e:	2362      	movs	r3, #98	; 0x62
 8010370:	18fb      	adds	r3, r7, r3
 8010372:	881b      	ldrh	r3, [r3, #0]
 8010374:	1ad3      	subs	r3, r2, r3
 8010376:	b29a      	uxth	r2, r3
 8010378:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801037a:	815a      	strh	r2, [r3, #10]
#endif /* TCP_OVERSIZE_DBGCHECK */
  }
  pcb->unsent_oversize = oversize;
 801037c:	231e      	movs	r3, #30
 801037e:	18fb      	adds	r3, r7, r3
 8010380:	8819      	ldrh	r1, [r3, #0]
 8010382:	68fb      	ldr	r3, [r7, #12]
 8010384:	226c      	movs	r2, #108	; 0x6c
 8010386:	5299      	strh	r1, [r3, r2]

  /*
   * Phase 2: concat_p can be concatenated onto last_unsent->p, unless we
   * determined that the last ROM pbuf can be extended to include the new data.
   */
  if (concat_p != NULL) {
 8010388:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801038a:	2b00      	cmp	r3, #0
 801038c:	d019      	beq.n	80103c2 <tcp_write+0x856>
    LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
 801038e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010390:	2b00      	cmp	r3, #0
 8010392:	d106      	bne.n	80103a2 <tcp_write+0x836>
 8010394:	4b97      	ldr	r3, [pc, #604]	; (80105f4 <tcp_write+0xa88>)
 8010396:	22b8      	movs	r2, #184	; 0xb8
 8010398:	0092      	lsls	r2, r2, #2
 801039a:	499a      	ldr	r1, [pc, #616]	; (8010604 <tcp_write+0xa98>)
 801039c:	4898      	ldr	r0, [pc, #608]	; (8010600 <tcp_write+0xa94>)
 801039e:	f7f2 fc13 	bl	8002bc8 <app_debug_rtt_raw>
                (last_unsent != NULL));
    pbuf_cat(last_unsent->p, concat_p);
 80103a2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80103a4:	685b      	ldr	r3, [r3, #4]
 80103a6:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80103a8:	0011      	movs	r1, r2
 80103aa:	0018      	movs	r0, r3
 80103ac:	f7f9 fe66 	bl	800a07c <pbuf_cat>
    last_unsent->len += concat_p->tot_len;
 80103b0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80103b2:	891a      	ldrh	r2, [r3, #8]
 80103b4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80103b6:	891b      	ldrh	r3, [r3, #8]
 80103b8:	18d3      	adds	r3, r2, r3
 80103ba:	b29a      	uxth	r2, r3
 80103bc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80103be:	811a      	strh	r2, [r3, #8]
 80103c0:	e03e      	b.n	8010440 <tcp_write+0x8d4>
  } else if (extendlen > 0) {
 80103c2:	2364      	movs	r3, #100	; 0x64
 80103c4:	18fb      	adds	r3, r7, r3
 80103c6:	881b      	ldrh	r3, [r3, #0]
 80103c8:	2b00      	cmp	r3, #0
 80103ca:	d039      	beq.n	8010440 <tcp_write+0x8d4>
    struct pbuf *p;
    LWIP_ASSERT("tcp_write: extension of reference requires reference",
 80103cc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80103ce:	2b00      	cmp	r3, #0
 80103d0:	d003      	beq.n	80103da <tcp_write+0x86e>
 80103d2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80103d4:	685b      	ldr	r3, [r3, #4]
 80103d6:	2b00      	cmp	r3, #0
 80103d8:	d105      	bne.n	80103e6 <tcp_write+0x87a>
 80103da:	4b86      	ldr	r3, [pc, #536]	; (80105f4 <tcp_write+0xa88>)
 80103dc:	4a8a      	ldr	r2, [pc, #552]	; (8010608 <tcp_write+0xa9c>)
 80103de:	498b      	ldr	r1, [pc, #556]	; (801060c <tcp_write+0xaa0>)
 80103e0:	4887      	ldr	r0, [pc, #540]	; (8010600 <tcp_write+0xa94>)
 80103e2:	f7f2 fbf1 	bl	8002bc8 <app_debug_rtt_raw>
                last_unsent != NULL && last_unsent->p != NULL);
    for (p = last_unsent->p; p->next != NULL; p = p->next) {
 80103e6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80103e8:	685b      	ldr	r3, [r3, #4]
 80103ea:	637b      	str	r3, [r7, #52]	; 0x34
 80103ec:	e00b      	b.n	8010406 <tcp_write+0x89a>
      p->tot_len += extendlen;
 80103ee:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80103f0:	891a      	ldrh	r2, [r3, #8]
 80103f2:	2364      	movs	r3, #100	; 0x64
 80103f4:	18fb      	adds	r3, r7, r3
 80103f6:	881b      	ldrh	r3, [r3, #0]
 80103f8:	18d3      	adds	r3, r2, r3
 80103fa:	b29a      	uxth	r2, r3
 80103fc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80103fe:	811a      	strh	r2, [r3, #8]
    for (p = last_unsent->p; p->next != NULL; p = p->next) {
 8010400:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010402:	681b      	ldr	r3, [r3, #0]
 8010404:	637b      	str	r3, [r7, #52]	; 0x34
 8010406:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010408:	681b      	ldr	r3, [r3, #0]
 801040a:	2b00      	cmp	r3, #0
 801040c:	d1ef      	bne.n	80103ee <tcp_write+0x882>
    }
    p->tot_len += extendlen;
 801040e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010410:	891a      	ldrh	r2, [r3, #8]
 8010412:	2164      	movs	r1, #100	; 0x64
 8010414:	187b      	adds	r3, r7, r1
 8010416:	881b      	ldrh	r3, [r3, #0]
 8010418:	18d3      	adds	r3, r2, r3
 801041a:	b29a      	uxth	r2, r3
 801041c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801041e:	811a      	strh	r2, [r3, #8]
    p->len += extendlen;
 8010420:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010422:	895a      	ldrh	r2, [r3, #10]
 8010424:	187b      	adds	r3, r7, r1
 8010426:	881b      	ldrh	r3, [r3, #0]
 8010428:	18d3      	adds	r3, r2, r3
 801042a:	b29a      	uxth	r2, r3
 801042c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801042e:	815a      	strh	r2, [r3, #10]
    last_unsent->len += extendlen;
 8010430:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010432:	891a      	ldrh	r2, [r3, #8]
 8010434:	187b      	adds	r3, r7, r1
 8010436:	881b      	ldrh	r3, [r3, #0]
 8010438:	18d3      	adds	r3, r2, r3
 801043a:	b29a      	uxth	r2, r3
 801043c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801043e:	811a      	strh	r2, [r3, #8]
  }

#if TCP_CHECKSUM_ON_COPY
  if (concat_chksummed) {
 8010440:	2346      	movs	r3, #70	; 0x46
 8010442:	18fb      	adds	r3, r7, r3
 8010444:	881b      	ldrh	r3, [r3, #0]
 8010446:	2b00      	cmp	r3, #0
 8010448:	d037      	beq.n	80104ba <tcp_write+0x94e>
    LWIP_ASSERT("tcp_write: concat checksum needs concatenated data",
 801044a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801044c:	2b00      	cmp	r3, #0
 801044e:	d10a      	bne.n	8010466 <tcp_write+0x8fa>
 8010450:	2364      	movs	r3, #100	; 0x64
 8010452:	18fb      	adds	r3, r7, r3
 8010454:	881b      	ldrh	r3, [r3, #0]
 8010456:	2b00      	cmp	r3, #0
 8010458:	d105      	bne.n	8010466 <tcp_write+0x8fa>
 801045a:	4b66      	ldr	r3, [pc, #408]	; (80105f4 <tcp_write+0xa88>)
 801045c:	4a6c      	ldr	r2, [pc, #432]	; (8010610 <tcp_write+0xaa4>)
 801045e:	496d      	ldr	r1, [pc, #436]	; (8010614 <tcp_write+0xaa8>)
 8010460:	4867      	ldr	r0, [pc, #412]	; (8010600 <tcp_write+0xa94>)
 8010462:	f7f2 fbb1 	bl	8002bc8 <app_debug_rtt_raw>
                concat_p != NULL || extendlen > 0);
    /*if concat checksumm swapped - swap it back */
    if (concat_chksum_swapped) {
 8010466:	231b      	movs	r3, #27
 8010468:	18fb      	adds	r3, r7, r3
 801046a:	781b      	ldrb	r3, [r3, #0]
 801046c:	2b00      	cmp	r3, #0
 801046e:	d00e      	beq.n	801048e <tcp_write+0x922>
      concat_chksum = SWAP_BYTES_IN_WORD(concat_chksum);
 8010470:	211c      	movs	r1, #28
 8010472:	187b      	adds	r3, r7, r1
 8010474:	881b      	ldrh	r3, [r3, #0]
 8010476:	021b      	lsls	r3, r3, #8
 8010478:	b21a      	sxth	r2, r3
 801047a:	187b      	adds	r3, r7, r1
 801047c:	881b      	ldrh	r3, [r3, #0]
 801047e:	0a1b      	lsrs	r3, r3, #8
 8010480:	b29b      	uxth	r3, r3
 8010482:	b21b      	sxth	r3, r3
 8010484:	4313      	orrs	r3, r2
 8010486:	b21b      	sxth	r3, r3
 8010488:	b29a      	uxth	r2, r3
 801048a:	187b      	adds	r3, r7, r1
 801048c:	801a      	strh	r2, [r3, #0]
    }
    tcp_seg_add_chksum(concat_chksum, concat_chksummed, &last_unsent->chksum,
 801048e:	231c      	movs	r3, #28
 8010490:	18fb      	adds	r3, r7, r3
 8010492:	8818      	ldrh	r0, [r3, #0]
 8010494:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010496:	330c      	adds	r3, #12
 8010498:	001a      	movs	r2, r3
 801049a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801049c:	330e      	adds	r3, #14
 801049e:	001c      	movs	r4, r3
 80104a0:	2346      	movs	r3, #70	; 0x46
 80104a2:	18fb      	adds	r3, r7, r3
 80104a4:	8819      	ldrh	r1, [r3, #0]
 80104a6:	0023      	movs	r3, r4
 80104a8:	f7ff faa4 	bl	800f9f4 <tcp_seg_add_chksum>
                       &last_unsent->chksum_swapped);
    last_unsent->flags |= TF_SEG_DATA_CHECKSUMMED;
 80104ac:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80104ae:	7bdb      	ldrb	r3, [r3, #15]
 80104b0:	2204      	movs	r2, #4
 80104b2:	4313      	orrs	r3, r2
 80104b4:	b2da      	uxtb	r2, r3
 80104b6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80104b8:	73da      	strb	r2, [r3, #15]

  /*
   * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
   * is harmless
   */
  if (last_unsent == NULL) {
 80104ba:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80104bc:	2b00      	cmp	r3, #0
 80104be:	d103      	bne.n	80104c8 <tcp_write+0x95c>
    pcb->unsent = queue;
 80104c0:	68fb      	ldr	r3, [r7, #12]
 80104c2:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 80104c4:	671a      	str	r2, [r3, #112]	; 0x70
 80104c6:	e002      	b.n	80104ce <tcp_write+0x962>
  } else {
    last_unsent->next = queue;
 80104c8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80104ca:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 80104cc:	601a      	str	r2, [r3, #0]
  }

  /*
   * Finally update the pcb state.
   */
  pcb->snd_lbb += len;
 80104ce:	68fb      	ldr	r3, [r7, #12]
 80104d0:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80104d2:	1dbb      	adds	r3, r7, #6
 80104d4:	881b      	ldrh	r3, [r3, #0]
 80104d6:	18d2      	adds	r2, r2, r3
 80104d8:	68fb      	ldr	r3, [r7, #12]
 80104da:	661a      	str	r2, [r3, #96]	; 0x60
  pcb->snd_buf -= len;
 80104dc:	68fb      	ldr	r3, [r7, #12]
 80104de:	2268      	movs	r2, #104	; 0x68
 80104e0:	5a9a      	ldrh	r2, [r3, r2]
 80104e2:	1dbb      	adds	r3, r7, #6
 80104e4:	881b      	ldrh	r3, [r3, #0]
 80104e6:	1ad3      	subs	r3, r2, r3
 80104e8:	b299      	uxth	r1, r3
 80104ea:	68fb      	ldr	r3, [r7, #12]
 80104ec:	2268      	movs	r2, #104	; 0x68
 80104ee:	5299      	strh	r1, [r3, r2]
  pcb->snd_queuelen = queuelen;
 80104f0:	68fb      	ldr	r3, [r7, #12]
 80104f2:	2250      	movs	r2, #80	; 0x50
 80104f4:	18ba      	adds	r2, r7, r2
 80104f6:	216a      	movs	r1, #106	; 0x6a
 80104f8:	8812      	ldrh	r2, [r2, #0]
 80104fa:	525a      	strh	r2, [r3, r1]

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: %"S16_F" (after enqueued)\n",
                               pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
 80104fc:	68fb      	ldr	r3, [r7, #12]
 80104fe:	226a      	movs	r2, #106	; 0x6a
 8010500:	5a9b      	ldrh	r3, [r3, r2]
 8010502:	2b00      	cmp	r3, #0
 8010504:	d00d      	beq.n	8010522 <tcp_write+0x9b6>
    LWIP_ASSERT("tcp_write: valid queue length",
 8010506:	68fb      	ldr	r3, [r7, #12]
 8010508:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 801050a:	2b00      	cmp	r3, #0
 801050c:	d109      	bne.n	8010522 <tcp_write+0x9b6>
 801050e:	68fb      	ldr	r3, [r7, #12]
 8010510:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010512:	2b00      	cmp	r3, #0
 8010514:	d105      	bne.n	8010522 <tcp_write+0x9b6>
 8010516:	4b37      	ldr	r3, [pc, #220]	; (80105f4 <tcp_write+0xa88>)
 8010518:	4a3f      	ldr	r2, [pc, #252]	; (8010618 <tcp_write+0xaac>)
 801051a:	4940      	ldr	r1, [pc, #256]	; (801061c <tcp_write+0xab0>)
 801051c:	4838      	ldr	r0, [pc, #224]	; (8010600 <tcp_write+0xa94>)
 801051e:	f7f2 fb53 	bl	8002bc8 <app_debug_rtt_raw>
                pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued. */
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE) == 0)) {
 8010522:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010524:	2b00      	cmp	r3, #0
 8010526:	d02b      	beq.n	8010580 <tcp_write+0xa14>
 8010528:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801052a:	691b      	ldr	r3, [r3, #16]
 801052c:	2b00      	cmp	r3, #0
 801052e:	d027      	beq.n	8010580 <tcp_write+0xa14>
 8010530:	1d7b      	adds	r3, r7, #5
 8010532:	781b      	ldrb	r3, [r3, #0]
 8010534:	2202      	movs	r2, #2
 8010536:	4013      	ands	r3, r2
 8010538:	d122      	bne.n	8010580 <tcp_write+0xa14>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
 801053a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801053c:	691b      	ldr	r3, [r3, #16]
 801053e:	7b1a      	ldrb	r2, [r3, #12]
 8010540:	7b5b      	ldrb	r3, [r3, #13]
 8010542:	021b      	lsls	r3, r3, #8
 8010544:	4313      	orrs	r3, r2
 8010546:	b29c      	uxth	r4, r3
 8010548:	2008      	movs	r0, #8
 801054a:	f7f6 fcd3 	bl	8006ef4 <lwip_htons>
 801054e:	0003      	movs	r3, r0
 8010550:	001a      	movs	r2, r3
 8010552:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010554:	691b      	ldr	r3, [r3, #16]
 8010556:	4322      	orrs	r2, r4
 8010558:	b292      	uxth	r2, r2
 801055a:	21ff      	movs	r1, #255	; 0xff
 801055c:	4011      	ands	r1, r2
 801055e:	000c      	movs	r4, r1
 8010560:	7b19      	ldrb	r1, [r3, #12]
 8010562:	2000      	movs	r0, #0
 8010564:	4001      	ands	r1, r0
 8010566:	1c08      	adds	r0, r1, #0
 8010568:	1c21      	adds	r1, r4, #0
 801056a:	4301      	orrs	r1, r0
 801056c:	7319      	strb	r1, [r3, #12]
 801056e:	0a12      	lsrs	r2, r2, #8
 8010570:	b290      	uxth	r0, r2
 8010572:	7b5a      	ldrb	r2, [r3, #13]
 8010574:	2100      	movs	r1, #0
 8010576:	400a      	ands	r2, r1
 8010578:	1c11      	adds	r1, r2, #0
 801057a:	1c02      	adds	r2, r0, #0
 801057c:	430a      	orrs	r2, r1
 801057e:	735a      	strb	r2, [r3, #13]
  }

  return ERR_OK;
 8010580:	2300      	movs	r3, #0
 8010582:	e032      	b.n	80105ea <tcp_write+0xa7e>
          goto memerr;
 8010584:	46c0      	nop			; (mov r8, r8)
 8010586:	e006      	b.n	8010596 <tcp_write+0xa2a>
            goto memerr;
 8010588:	46c0      	nop			; (mov r8, r8)
 801058a:	e004      	b.n	8010596 <tcp_write+0xa2a>
        goto memerr;
 801058c:	46c0      	nop			; (mov r8, r8)
 801058e:	e002      	b.n	8010596 <tcp_write+0xa2a>
        goto memerr;
 8010590:	46c0      	nop			; (mov r8, r8)
 8010592:	e000      	b.n	8010596 <tcp_write+0xa2a>
      goto memerr;
 8010594:	46c0      	nop			; (mov r8, r8)
memerr:
  tcp_set_flags(pcb, TF_NAGLEMEMERR);
 8010596:	68fb      	ldr	r3, [r7, #12]
 8010598:	8bdb      	ldrh	r3, [r3, #30]
 801059a:	2280      	movs	r2, #128	; 0x80
 801059c:	4313      	orrs	r3, r2
 801059e:	b29a      	uxth	r2, r3
 80105a0:	68fb      	ldr	r3, [r7, #12]
 80105a2:	83da      	strh	r2, [r3, #30]
  TCP_STATS_INC(tcp.memerr);

  if (concat_p != NULL) {
 80105a4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80105a6:	2b00      	cmp	r3, #0
 80105a8:	d003      	beq.n	80105b2 <tcp_write+0xa46>
    pbuf_free(concat_p);
 80105aa:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80105ac:	0018      	movs	r0, r3
 80105ae:	f7f9 fc85 	bl	8009ebc <pbuf_free>
  }
  if (queue != NULL) {
 80105b2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80105b4:	2b00      	cmp	r3, #0
 80105b6:	d003      	beq.n	80105c0 <tcp_write+0xa54>
    tcp_segs_free(queue);
 80105b8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80105ba:	0018      	movs	r0, r3
 80105bc:	f7fb fcd4 	bl	800bf68 <tcp_segs_free>
  }
  if (pcb->snd_queuelen != 0) {
 80105c0:	68fb      	ldr	r3, [r7, #12]
 80105c2:	226a      	movs	r2, #106	; 0x6a
 80105c4:	5a9b      	ldrh	r3, [r3, r2]
 80105c6:	2b00      	cmp	r3, #0
 80105c8:	d00d      	beq.n	80105e6 <tcp_write+0xa7a>
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
 80105ca:	68fb      	ldr	r3, [r7, #12]
 80105cc:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80105ce:	2b00      	cmp	r3, #0
 80105d0:	d109      	bne.n	80105e6 <tcp_write+0xa7a>
 80105d2:	68fb      	ldr	r3, [r7, #12]
 80105d4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80105d6:	2b00      	cmp	r3, #0
 80105d8:	d105      	bne.n	80105e6 <tcp_write+0xa7a>
 80105da:	4b06      	ldr	r3, [pc, #24]	; (80105f4 <tcp_write+0xa88>)
 80105dc:	4a10      	ldr	r2, [pc, #64]	; (8010620 <tcp_write+0xab4>)
 80105de:	490f      	ldr	r1, [pc, #60]	; (801061c <tcp_write+0xab0>)
 80105e0:	4807      	ldr	r0, [pc, #28]	; (8010600 <tcp_write+0xa94>)
 80105e2:	f7f2 faf1 	bl	8002bc8 <app_debug_rtt_raw>
                pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
 80105e6:	2301      	movs	r3, #1
 80105e8:	425b      	negs	r3, r3
}
 80105ea:	0018      	movs	r0, r3
 80105ec:	46bd      	mov	sp, r7
 80105ee:	b01a      	add	sp, #104	; 0x68
 80105f0:	bdb0      	pop	{r4, r5, r7, pc}
 80105f2:	46c0      	nop			; (mov r8, r8)
 80105f4:	08020a34 	.word	0x08020a34
 80105f8:	000002d3 	.word	0x000002d3
 80105fc:	08020d98 	.word	0x08020d98
 8010600:	08020a80 	.word	0x08020a80
 8010604:	08020dc4 	.word	0x08020dc4
 8010608:	000002e6 	.word	0x000002e6
 801060c:	08020dfc 	.word	0x08020dfc
 8010610:	000002f2 	.word	0x000002f2
 8010614:	08020e34 	.word	0x08020e34
 8010618:	00000312 	.word	0x00000312
 801061c:	08020e68 	.word	0x08020e68
 8010620:	00000327 	.word	0x00000327

08010624 <tcp_split_unsent_seg>:
 * @param pcb the tcp_pcb for which to split the unsent head
 * @param split the amount of payload to remain in the head
 */
err_t
tcp_split_unsent_seg(struct tcp_pcb *pcb, u16_t split)
{
 8010624:	b5f0      	push	{r4, r5, r6, r7, lr}
 8010626:	b08d      	sub	sp, #52	; 0x34
 8010628:	af02      	add	r7, sp, #8
 801062a:	6078      	str	r0, [r7, #4]
 801062c:	000a      	movs	r2, r1
 801062e:	1cbb      	adds	r3, r7, #2
 8010630:	801a      	strh	r2, [r3, #0]
  struct tcp_seg *seg = NULL, *useg = NULL;
 8010632:	2300      	movs	r3, #0
 8010634:	61fb      	str	r3, [r7, #28]
 8010636:	2300      	movs	r3, #0
 8010638:	613b      	str	r3, [r7, #16]
  struct pbuf *p = NULL;
 801063a:	2300      	movs	r3, #0
 801063c:	623b      	str	r3, [r7, #32]
  u8_t split_flags;
  u8_t remainder_flags;
  u16_t remainder;
  u16_t offset;
#if TCP_CHECKSUM_ON_COPY
  u16_t chksum = 0;
 801063e:	230a      	movs	r3, #10
 8010640:	18fb      	adds	r3, r7, r3
 8010642:	2200      	movs	r2, #0
 8010644:	801a      	strh	r2, [r3, #0]
  u8_t chksum_swapped = 0;
 8010646:	2309      	movs	r3, #9
 8010648:	18fb      	adds	r3, r7, r3
 801064a:	2200      	movs	r2, #0
 801064c:	701a      	strb	r2, [r3, #0]
  struct pbuf *q;
#endif /* TCP_CHECKSUM_ON_COPY */

  LWIP_ASSERT("tcp_split_unsent_seg: invalid pcb", pcb != NULL);
 801064e:	687b      	ldr	r3, [r7, #4]
 8010650:	2b00      	cmp	r3, #0
 8010652:	d105      	bne.n	8010660 <tcp_split_unsent_seg+0x3c>
 8010654:	4bd2      	ldr	r3, [pc, #840]	; (80109a0 <tcp_split_unsent_seg+0x37c>)
 8010656:	4ad3      	ldr	r2, [pc, #844]	; (80109a4 <tcp_split_unsent_seg+0x380>)
 8010658:	49d3      	ldr	r1, [pc, #844]	; (80109a8 <tcp_split_unsent_seg+0x384>)
 801065a:	48d4      	ldr	r0, [pc, #848]	; (80109ac <tcp_split_unsent_seg+0x388>)
 801065c:	f7f2 fab4 	bl	8002bc8 <app_debug_rtt_raw>

  useg = pcb->unsent;
 8010660:	687b      	ldr	r3, [r7, #4]
 8010662:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010664:	613b      	str	r3, [r7, #16]
  if (useg == NULL) {
 8010666:	693b      	ldr	r3, [r7, #16]
 8010668:	2b00      	cmp	r3, #0
 801066a:	d102      	bne.n	8010672 <tcp_split_unsent_seg+0x4e>
    return ERR_MEM;
 801066c:	2301      	movs	r3, #1
 801066e:	425b      	negs	r3, r3
 8010670:	e207      	b.n	8010a82 <tcp_split_unsent_seg+0x45e>
  }

  if (split == 0) {
 8010672:	1cbb      	adds	r3, r7, #2
 8010674:	881b      	ldrh	r3, [r3, #0]
 8010676:	2b00      	cmp	r3, #0
 8010678:	d108      	bne.n	801068c <tcp_split_unsent_seg+0x68>
    LWIP_ASSERT("Can't split segment into length 0", 0);
 801067a:	4bc9      	ldr	r3, [pc, #804]	; (80109a0 <tcp_split_unsent_seg+0x37c>)
 801067c:	4acc      	ldr	r2, [pc, #816]	; (80109b0 <tcp_split_unsent_seg+0x38c>)
 801067e:	49cd      	ldr	r1, [pc, #820]	; (80109b4 <tcp_split_unsent_seg+0x390>)
 8010680:	48ca      	ldr	r0, [pc, #808]	; (80109ac <tcp_split_unsent_seg+0x388>)
 8010682:	f7f2 faa1 	bl	8002bc8 <app_debug_rtt_raw>
    return ERR_VAL;
 8010686:	2306      	movs	r3, #6
 8010688:	425b      	negs	r3, r3
 801068a:	e1fa      	b.n	8010a82 <tcp_split_unsent_seg+0x45e>
  }

  if (useg->len <= split) {
 801068c:	693b      	ldr	r3, [r7, #16]
 801068e:	891b      	ldrh	r3, [r3, #8]
 8010690:	1cba      	adds	r2, r7, #2
 8010692:	8812      	ldrh	r2, [r2, #0]
 8010694:	429a      	cmp	r2, r3
 8010696:	d301      	bcc.n	801069c <tcp_split_unsent_seg+0x78>
    return ERR_OK;
 8010698:	2300      	movs	r3, #0
 801069a:	e1f2      	b.n	8010a82 <tcp_split_unsent_seg+0x45e>
  }

  LWIP_ASSERT("split <= mss", split <= pcb->mss);
 801069c:	687b      	ldr	r3, [r7, #4]
 801069e:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 80106a0:	1cba      	adds	r2, r7, #2
 80106a2:	8812      	ldrh	r2, [r2, #0]
 80106a4:	429a      	cmp	r2, r3
 80106a6:	d905      	bls.n	80106b4 <tcp_split_unsent_seg+0x90>
 80106a8:	4bbd      	ldr	r3, [pc, #756]	; (80109a0 <tcp_split_unsent_seg+0x37c>)
 80106aa:	4ac3      	ldr	r2, [pc, #780]	; (80109b8 <tcp_split_unsent_seg+0x394>)
 80106ac:	49c3      	ldr	r1, [pc, #780]	; (80109bc <tcp_split_unsent_seg+0x398>)
 80106ae:	48bf      	ldr	r0, [pc, #764]	; (80109ac <tcp_split_unsent_seg+0x388>)
 80106b0:	f7f2 fa8a 	bl	8002bc8 <app_debug_rtt_raw>
  LWIP_ASSERT("useg->len > 0", useg->len > 0);
 80106b4:	693b      	ldr	r3, [r7, #16]
 80106b6:	891b      	ldrh	r3, [r3, #8]
 80106b8:	2b00      	cmp	r3, #0
 80106ba:	d106      	bne.n	80106ca <tcp_split_unsent_seg+0xa6>
 80106bc:	4bb8      	ldr	r3, [pc, #736]	; (80109a0 <tcp_split_unsent_seg+0x37c>)
 80106be:	22d7      	movs	r2, #215	; 0xd7
 80106c0:	0092      	lsls	r2, r2, #2
 80106c2:	49bf      	ldr	r1, [pc, #764]	; (80109c0 <tcp_split_unsent_seg+0x39c>)
 80106c4:	48b9      	ldr	r0, [pc, #740]	; (80109ac <tcp_split_unsent_seg+0x388>)
 80106c6:	f7f2 fa7f 	bl	8002bc8 <app_debug_rtt_raw>
   * to split this packet so we may actually exceed the max value by
   * one!
   */
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: split_unsent_seg: %u\n", (unsigned int)pcb->snd_queuelen));

  optflags = useg->flags;
 80106ca:	200f      	movs	r0, #15
 80106cc:	183b      	adds	r3, r7, r0
 80106ce:	693a      	ldr	r2, [r7, #16]
 80106d0:	7bd2      	ldrb	r2, [r2, #15]
 80106d2:	701a      	strb	r2, [r3, #0]
#if TCP_CHECKSUM_ON_COPY
  /* Remove since checksum is not stored until after tcp_create_segment() */
  optflags &= ~TF_SEG_DATA_CHECKSUMMED;
 80106d4:	183b      	adds	r3, r7, r0
 80106d6:	183a      	adds	r2, r7, r0
 80106d8:	7812      	ldrb	r2, [r2, #0]
 80106da:	2104      	movs	r1, #4
 80106dc:	438a      	bics	r2, r1
 80106de:	701a      	strb	r2, [r3, #0]
#endif /* TCP_CHECKSUM_ON_COPY */
  optlen = LWIP_TCP_OPT_LENGTH(optflags);
 80106e0:	183b      	adds	r3, r7, r0
 80106e2:	781b      	ldrb	r3, [r3, #0]
 80106e4:	009b      	lsls	r3, r3, #2
 80106e6:	b2da      	uxtb	r2, r3
 80106e8:	240e      	movs	r4, #14
 80106ea:	193b      	adds	r3, r7, r4
 80106ec:	2104      	movs	r1, #4
 80106ee:	400a      	ands	r2, r1
 80106f0:	701a      	strb	r2, [r3, #0]
  remainder = useg->len - split;
 80106f2:	693b      	ldr	r3, [r7, #16]
 80106f4:	8919      	ldrh	r1, [r3, #8]
 80106f6:	250c      	movs	r5, #12
 80106f8:	197b      	adds	r3, r7, r5
 80106fa:	1cba      	adds	r2, r7, #2
 80106fc:	8812      	ldrh	r2, [r2, #0]
 80106fe:	1a8a      	subs	r2, r1, r2
 8010700:	801a      	strh	r2, [r3, #0]

  /* Create new pbuf for the remainder of the split */
  p = pbuf_alloc(PBUF_TRANSPORT, remainder + optlen, PBUF_RAM);
 8010702:	193b      	adds	r3, r7, r4
 8010704:	781b      	ldrb	r3, [r3, #0]
 8010706:	b29a      	uxth	r2, r3
 8010708:	197b      	adds	r3, r7, r5
 801070a:	881b      	ldrh	r3, [r3, #0]
 801070c:	18d3      	adds	r3, r2, r3
 801070e:	b29b      	uxth	r3, r3
 8010710:	22a0      	movs	r2, #160	; 0xa0
 8010712:	0092      	lsls	r2, r2, #2
 8010714:	0019      	movs	r1, r3
 8010716:	2038      	movs	r0, #56	; 0x38
 8010718:	f7f9 f858 	bl	80097cc <pbuf_alloc>
 801071c:	0003      	movs	r3, r0
 801071e:	623b      	str	r3, [r7, #32]
  if (p == NULL) {
 8010720:	6a3b      	ldr	r3, [r7, #32]
 8010722:	2b00      	cmp	r3, #0
 8010724:	d100      	bne.n	8010728 <tcp_split_unsent_seg+0x104>
 8010726:	e197      	b.n	8010a58 <tcp_split_unsent_seg+0x434>
                ("tcp_split_unsent_seg: could not allocate memory for pbuf remainder %u\n", remainder));
    goto memerr;
  }

  /* Offset into the original pbuf is past TCP/IP headers, options, and split amount */
  offset = useg->p->tot_len - useg->len + split;
 8010728:	693b      	ldr	r3, [r7, #16]
 801072a:	685b      	ldr	r3, [r3, #4]
 801072c:	891a      	ldrh	r2, [r3, #8]
 801072e:	693b      	ldr	r3, [r7, #16]
 8010730:	891b      	ldrh	r3, [r3, #8]
 8010732:	1ad3      	subs	r3, r2, r3
 8010734:	b299      	uxth	r1, r3
 8010736:	2318      	movs	r3, #24
 8010738:	18fb      	adds	r3, r7, r3
 801073a:	1cba      	adds	r2, r7, #2
 801073c:	8812      	ldrh	r2, [r2, #0]
 801073e:	188a      	adds	r2, r1, r2
 8010740:	801a      	strh	r2, [r3, #0]
  /* Copy remainder into new pbuf, headers and options will not be filled out */
  if (pbuf_copy_partial(useg->p, (u8_t *)p->payload + optlen, remainder, offset ) != remainder) {
 8010742:	693b      	ldr	r3, [r7, #16]
 8010744:	6858      	ldr	r0, [r3, #4]
 8010746:	6a3b      	ldr	r3, [r7, #32]
 8010748:	685a      	ldr	r2, [r3, #4]
 801074a:	0026      	movs	r6, r4
 801074c:	193b      	adds	r3, r7, r4
 801074e:	781b      	ldrb	r3, [r3, #0]
 8010750:	18d1      	adds	r1, r2, r3
 8010752:	2318      	movs	r3, #24
 8010754:	18fb      	adds	r3, r7, r3
 8010756:	881c      	ldrh	r4, [r3, #0]
 8010758:	197b      	adds	r3, r7, r5
 801075a:	881a      	ldrh	r2, [r3, #0]
 801075c:	0023      	movs	r3, r4
 801075e:	f7f9 fe77 	bl	800a450 <pbuf_copy_partial>
 8010762:	0003      	movs	r3, r0
 8010764:	001a      	movs	r2, r3
 8010766:	197b      	adds	r3, r7, r5
 8010768:	881b      	ldrh	r3, [r3, #0]
 801076a:	4293      	cmp	r3, r2
 801076c:	d000      	beq.n	8010770 <tcp_split_unsent_seg+0x14c>
 801076e:	e175      	b.n	8010a5c <tcp_split_unsent_seg+0x438>
                ("tcp_split_unsent_seg: could not copy pbuf remainder %u\n", remainder));
    goto memerr;
  }
#if TCP_CHECKSUM_ON_COPY
  /* calculate the checksum on remainder data */
  tcp_seg_add_chksum(~inet_chksum((const u8_t *)p->payload + optlen, remainder), remainder,
 8010770:	6a3b      	ldr	r3, [r7, #32]
 8010772:	685a      	ldr	r2, [r3, #4]
 8010774:	19bb      	adds	r3, r7, r6
 8010776:	781b      	ldrb	r3, [r3, #0]
 8010778:	18d2      	adds	r2, r2, r3
 801077a:	197b      	adds	r3, r7, r5
 801077c:	881b      	ldrh	r3, [r3, #0]
 801077e:	0019      	movs	r1, r3
 8010780:	0010      	movs	r0, r2
 8010782:	f7f7 ff7d 	bl	8008680 <inet_chksum>
 8010786:	0003      	movs	r3, r0
 8010788:	43db      	mvns	r3, r3
 801078a:	b298      	uxth	r0, r3
 801078c:	2309      	movs	r3, #9
 801078e:	18fc      	adds	r4, r7, r3
 8010790:	230a      	movs	r3, #10
 8010792:	18fa      	adds	r2, r7, r3
 8010794:	197b      	adds	r3, r7, r5
 8010796:	8819      	ldrh	r1, [r3, #0]
 8010798:	0023      	movs	r3, r4
 801079a:	f7ff f92b 	bl	800f9f4 <tcp_seg_add_chksum>
#endif /* TCP_CHECKSUM_ON_COPY */

  /* Options are created when calling tcp_output() */

  /* Migrate flags from original segment */
  split_flags = TCPH_FLAGS(useg->tcphdr);
 801079e:	693b      	ldr	r3, [r7, #16]
 80107a0:	691b      	ldr	r3, [r3, #16]
 80107a2:	7b1a      	ldrb	r2, [r3, #12]
 80107a4:	7b5b      	ldrb	r3, [r3, #13]
 80107a6:	021b      	lsls	r3, r3, #8
 80107a8:	4313      	orrs	r3, r2
 80107aa:	b29b      	uxth	r3, r3
 80107ac:	0018      	movs	r0, r3
 80107ae:	f7f6 fba1 	bl	8006ef4 <lwip_htons>
 80107b2:	0003      	movs	r3, r0
 80107b4:	b2da      	uxtb	r2, r3
 80107b6:	2027      	movs	r0, #39	; 0x27
 80107b8:	183b      	adds	r3, r7, r0
 80107ba:	213f      	movs	r1, #63	; 0x3f
 80107bc:	400a      	ands	r2, r1
 80107be:	701a      	strb	r2, [r3, #0]
  remainder_flags = 0; /* ACK added in tcp_output() */
 80107c0:	241b      	movs	r4, #27
 80107c2:	193b      	adds	r3, r7, r4
 80107c4:	2200      	movs	r2, #0
 80107c6:	701a      	strb	r2, [r3, #0]

  if (split_flags & TCP_PSH) {
 80107c8:	183b      	adds	r3, r7, r0
 80107ca:	781b      	ldrb	r3, [r3, #0]
 80107cc:	2208      	movs	r2, #8
 80107ce:	4013      	ands	r3, r2
 80107d0:	d00b      	beq.n	80107ea <tcp_split_unsent_seg+0x1c6>
    split_flags &= ~TCP_PSH;
 80107d2:	183b      	adds	r3, r7, r0
 80107d4:	183a      	adds	r2, r7, r0
 80107d6:	7812      	ldrb	r2, [r2, #0]
 80107d8:	2108      	movs	r1, #8
 80107da:	438a      	bics	r2, r1
 80107dc:	701a      	strb	r2, [r3, #0]
    remainder_flags |= TCP_PSH;
 80107de:	193b      	adds	r3, r7, r4
 80107e0:	193a      	adds	r2, r7, r4
 80107e2:	7812      	ldrb	r2, [r2, #0]
 80107e4:	2108      	movs	r1, #8
 80107e6:	430a      	orrs	r2, r1
 80107e8:	701a      	strb	r2, [r3, #0]
  }
  if (split_flags & TCP_FIN) {
 80107ea:	2127      	movs	r1, #39	; 0x27
 80107ec:	187b      	adds	r3, r7, r1
 80107ee:	781b      	ldrb	r3, [r3, #0]
 80107f0:	2201      	movs	r2, #1
 80107f2:	4013      	ands	r3, r2
 80107f4:	d00c      	beq.n	8010810 <tcp_split_unsent_seg+0x1ec>
    split_flags &= ~TCP_FIN;
 80107f6:	187b      	adds	r3, r7, r1
 80107f8:	187a      	adds	r2, r7, r1
 80107fa:	7812      	ldrb	r2, [r2, #0]
 80107fc:	2101      	movs	r1, #1
 80107fe:	438a      	bics	r2, r1
 8010800:	701a      	strb	r2, [r3, #0]
    remainder_flags |= TCP_FIN;
 8010802:	221b      	movs	r2, #27
 8010804:	18bb      	adds	r3, r7, r2
 8010806:	18ba      	adds	r2, r7, r2
 8010808:	7812      	ldrb	r2, [r2, #0]
 801080a:	2101      	movs	r1, #1
 801080c:	430a      	orrs	r2, r1
 801080e:	701a      	strb	r2, [r3, #0]
  }
  /* SYN should be left on split, RST should not be present with data */

  seg = tcp_create_segment(pcb, p, remainder_flags, lwip_ntohl(useg->tcphdr->seqno) + split, optflags);
 8010810:	693b      	ldr	r3, [r7, #16]
 8010812:	691b      	ldr	r3, [r3, #16]
 8010814:	791a      	ldrb	r2, [r3, #4]
 8010816:	7959      	ldrb	r1, [r3, #5]
 8010818:	0209      	lsls	r1, r1, #8
 801081a:	430a      	orrs	r2, r1
 801081c:	7999      	ldrb	r1, [r3, #6]
 801081e:	0409      	lsls	r1, r1, #16
 8010820:	430a      	orrs	r2, r1
 8010822:	79db      	ldrb	r3, [r3, #7]
 8010824:	061b      	lsls	r3, r3, #24
 8010826:	4313      	orrs	r3, r2
 8010828:	0018      	movs	r0, r3
 801082a:	f7f6 fb79 	bl	8006f20 <lwip_htonl>
 801082e:	0002      	movs	r2, r0
 8010830:	1cbb      	adds	r3, r7, #2
 8010832:	881b      	ldrh	r3, [r3, #0]
 8010834:	18d4      	adds	r4, r2, r3
 8010836:	231b      	movs	r3, #27
 8010838:	18fb      	adds	r3, r7, r3
 801083a:	781a      	ldrb	r2, [r3, #0]
 801083c:	6a39      	ldr	r1, [r7, #32]
 801083e:	6878      	ldr	r0, [r7, #4]
 8010840:	230f      	movs	r3, #15
 8010842:	18fb      	adds	r3, r7, r3
 8010844:	781b      	ldrb	r3, [r3, #0]
 8010846:	9300      	str	r3, [sp, #0]
 8010848:	0023      	movs	r3, r4
 801084a:	f7fe ff13 	bl	800f674 <tcp_create_segment>
 801084e:	0003      	movs	r3, r0
 8010850:	61fb      	str	r3, [r7, #28]
  if (seg == NULL) {
 8010852:	69fb      	ldr	r3, [r7, #28]
 8010854:	2b00      	cmp	r3, #0
 8010856:	d102      	bne.n	801085e <tcp_split_unsent_seg+0x23a>
    p = NULL; /* Freed by tcp_create_segment */
 8010858:	2300      	movs	r3, #0
 801085a:	623b      	str	r3, [r7, #32]
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                ("tcp_split_unsent_seg: could not create new TCP segment\n"));
    goto memerr;
 801085c:	e0ff      	b.n	8010a5e <tcp_split_unsent_seg+0x43a>
  }

#if TCP_CHECKSUM_ON_COPY
  seg->chksum = chksum;
 801085e:	230a      	movs	r3, #10
 8010860:	18fb      	adds	r3, r7, r3
 8010862:	881a      	ldrh	r2, [r3, #0]
 8010864:	69fb      	ldr	r3, [r7, #28]
 8010866:	819a      	strh	r2, [r3, #12]
  seg->chksum_swapped = chksum_swapped;
 8010868:	2309      	movs	r3, #9
 801086a:	18fb      	adds	r3, r7, r3
 801086c:	781a      	ldrb	r2, [r3, #0]
 801086e:	69fb      	ldr	r3, [r7, #28]
 8010870:	739a      	strb	r2, [r3, #14]
  seg->flags |= TF_SEG_DATA_CHECKSUMMED;
 8010872:	69fb      	ldr	r3, [r7, #28]
 8010874:	7bdb      	ldrb	r3, [r3, #15]
 8010876:	2204      	movs	r2, #4
 8010878:	4313      	orrs	r3, r2
 801087a:	b2da      	uxtb	r2, r3
 801087c:	69fb      	ldr	r3, [r7, #28]
 801087e:	73da      	strb	r2, [r3, #15]
#endif /* TCP_CHECKSUM_ON_COPY */

  /* Remove this segment from the queue since trimming it may free pbufs */
  pcb->snd_queuelen -= pbuf_clen(useg->p);
 8010880:	693b      	ldr	r3, [r7, #16]
 8010882:	685b      	ldr	r3, [r3, #4]
 8010884:	0018      	movs	r0, r3
 8010886:	f7f9 fbb9 	bl	8009ffc <pbuf_clen>
 801088a:	0003      	movs	r3, r0
 801088c:	0019      	movs	r1, r3
 801088e:	687b      	ldr	r3, [r7, #4]
 8010890:	226a      	movs	r2, #106	; 0x6a
 8010892:	5a9b      	ldrh	r3, [r3, r2]
 8010894:	1a5b      	subs	r3, r3, r1
 8010896:	b299      	uxth	r1, r3
 8010898:	687b      	ldr	r3, [r7, #4]
 801089a:	226a      	movs	r2, #106	; 0x6a
 801089c:	5299      	strh	r1, [r3, r2]

  /* Trim the original pbuf into our split size.  At this point our remainder segment must be setup
  successfully because we are modifying the original segment */
  pbuf_realloc(useg->p, useg->p->tot_len - remainder);
 801089e:	693b      	ldr	r3, [r7, #16]
 80108a0:	6858      	ldr	r0, [r3, #4]
 80108a2:	693b      	ldr	r3, [r7, #16]
 80108a4:	685b      	ldr	r3, [r3, #4]
 80108a6:	891a      	ldrh	r2, [r3, #8]
 80108a8:	240c      	movs	r4, #12
 80108aa:	193b      	adds	r3, r7, r4
 80108ac:	881b      	ldrh	r3, [r3, #0]
 80108ae:	1ad3      	subs	r3, r2, r3
 80108b0:	b29b      	uxth	r3, r3
 80108b2:	0019      	movs	r1, r3
 80108b4:	f7f9 f908 	bl	8009ac8 <pbuf_realloc>
  useg->len -= remainder;
 80108b8:	693b      	ldr	r3, [r7, #16]
 80108ba:	891a      	ldrh	r2, [r3, #8]
 80108bc:	193b      	adds	r3, r7, r4
 80108be:	881b      	ldrh	r3, [r3, #0]
 80108c0:	1ad3      	subs	r3, r2, r3
 80108c2:	b29a      	uxth	r2, r3
 80108c4:	693b      	ldr	r3, [r7, #16]
 80108c6:	811a      	strh	r2, [r3, #8]
  TCPH_SET_FLAG(useg->tcphdr, split_flags);
 80108c8:	693b      	ldr	r3, [r7, #16]
 80108ca:	691b      	ldr	r3, [r3, #16]
 80108cc:	7b1a      	ldrb	r2, [r3, #12]
 80108ce:	7b5b      	ldrb	r3, [r3, #13]
 80108d0:	021b      	lsls	r3, r3, #8
 80108d2:	4313      	orrs	r3, r2
 80108d4:	b29c      	uxth	r4, r3
 80108d6:	2327      	movs	r3, #39	; 0x27
 80108d8:	18fb      	adds	r3, r7, r3
 80108da:	781b      	ldrb	r3, [r3, #0]
 80108dc:	b29b      	uxth	r3, r3
 80108de:	0018      	movs	r0, r3
 80108e0:	f7f6 fb08 	bl	8006ef4 <lwip_htons>
 80108e4:	0003      	movs	r3, r0
 80108e6:	001a      	movs	r2, r3
 80108e8:	693b      	ldr	r3, [r7, #16]
 80108ea:	691b      	ldr	r3, [r3, #16]
 80108ec:	4322      	orrs	r2, r4
 80108ee:	b292      	uxth	r2, r2
 80108f0:	21ff      	movs	r1, #255	; 0xff
 80108f2:	4011      	ands	r1, r2
 80108f4:	000c      	movs	r4, r1
 80108f6:	7b19      	ldrb	r1, [r3, #12]
 80108f8:	2000      	movs	r0, #0
 80108fa:	4001      	ands	r1, r0
 80108fc:	1c08      	adds	r0, r1, #0
 80108fe:	1c21      	adds	r1, r4, #0
 8010900:	4301      	orrs	r1, r0
 8010902:	7319      	strb	r1, [r3, #12]
 8010904:	0a12      	lsrs	r2, r2, #8
 8010906:	b290      	uxth	r0, r2
 8010908:	7b5a      	ldrb	r2, [r3, #13]
 801090a:	2100      	movs	r1, #0
 801090c:	400a      	ands	r2, r1
 801090e:	1c11      	adds	r1, r2, #0
 8010910:	1c02      	adds	r2, r0, #0
 8010912:	430a      	orrs	r2, r1
 8010914:	735a      	strb	r2, [r3, #13]
#if TCP_OVERSIZE_DBGCHECK
  /* By trimming, realloc may have actually shrunk the pbuf, so clear oversize_left */
  useg->oversize_left = 0;
 8010916:	693b      	ldr	r3, [r7, #16]
 8010918:	2200      	movs	r2, #0
 801091a:	815a      	strh	r2, [r3, #10]
#endif /* TCP_OVERSIZE_DBGCHECK */

  /* Add back to the queue with new trimmed pbuf */
  pcb->snd_queuelen += pbuf_clen(useg->p);
 801091c:	693b      	ldr	r3, [r7, #16]
 801091e:	685b      	ldr	r3, [r3, #4]
 8010920:	0018      	movs	r0, r3
 8010922:	f7f9 fb6b 	bl	8009ffc <pbuf_clen>
 8010926:	0003      	movs	r3, r0
 8010928:	0019      	movs	r1, r3
 801092a:	687b      	ldr	r3, [r7, #4]
 801092c:	226a      	movs	r2, #106	; 0x6a
 801092e:	5a9b      	ldrh	r3, [r3, r2]
 8010930:	18cb      	adds	r3, r1, r3
 8010932:	b299      	uxth	r1, r3
 8010934:	687b      	ldr	r3, [r7, #4]
 8010936:	226a      	movs	r2, #106	; 0x6a
 8010938:	5299      	strh	r1, [r3, r2]

#if TCP_CHECKSUM_ON_COPY
  /* The checksum on the split segment is now incorrect. We need to re-run it over the split */
  useg->chksum = 0;
 801093a:	693b      	ldr	r3, [r7, #16]
 801093c:	2200      	movs	r2, #0
 801093e:	819a      	strh	r2, [r3, #12]
  useg->chksum_swapped = 0;
 8010940:	693b      	ldr	r3, [r7, #16]
 8010942:	2200      	movs	r2, #0
 8010944:	739a      	strb	r2, [r3, #14]
  q = useg->p;
 8010946:	693b      	ldr	r3, [r7, #16]
 8010948:	685b      	ldr	r3, [r3, #4]
 801094a:	617b      	str	r3, [r7, #20]
  offset = q->tot_len - useg->len; /* Offset due to exposed headers */
 801094c:	697b      	ldr	r3, [r7, #20]
 801094e:	8919      	ldrh	r1, [r3, #8]
 8010950:	693b      	ldr	r3, [r7, #16]
 8010952:	891a      	ldrh	r2, [r3, #8]
 8010954:	2318      	movs	r3, #24
 8010956:	18fb      	adds	r3, r7, r3
 8010958:	1a8a      	subs	r2, r1, r2
 801095a:	801a      	strh	r2, [r3, #0]

  /* Advance to the pbuf where the offset ends */
  while (q != NULL && offset > q->len) {
 801095c:	e00a      	b.n	8010974 <tcp_split_unsent_seg+0x350>
    offset -= q->len;
 801095e:	697b      	ldr	r3, [r7, #20]
 8010960:	895a      	ldrh	r2, [r3, #10]
 8010962:	2118      	movs	r1, #24
 8010964:	187b      	adds	r3, r7, r1
 8010966:	1879      	adds	r1, r7, r1
 8010968:	8809      	ldrh	r1, [r1, #0]
 801096a:	1a8a      	subs	r2, r1, r2
 801096c:	801a      	strh	r2, [r3, #0]
    q = q->next;
 801096e:	697b      	ldr	r3, [r7, #20]
 8010970:	681b      	ldr	r3, [r3, #0]
 8010972:	617b      	str	r3, [r7, #20]
  while (q != NULL && offset > q->len) {
 8010974:	697b      	ldr	r3, [r7, #20]
 8010976:	2b00      	cmp	r3, #0
 8010978:	d006      	beq.n	8010988 <tcp_split_unsent_seg+0x364>
 801097a:	697b      	ldr	r3, [r7, #20]
 801097c:	895b      	ldrh	r3, [r3, #10]
 801097e:	2218      	movs	r2, #24
 8010980:	18ba      	adds	r2, r7, r2
 8010982:	8812      	ldrh	r2, [r2, #0]
 8010984:	429a      	cmp	r2, r3
 8010986:	d8ea      	bhi.n	801095e <tcp_split_unsent_seg+0x33a>
  }
  LWIP_ASSERT("Found start of payload pbuf", q != NULL);
 8010988:	697b      	ldr	r3, [r7, #20]
 801098a:	2b00      	cmp	r3, #0
 801098c:	d141      	bne.n	8010a12 <tcp_split_unsent_seg+0x3ee>
 801098e:	4b04      	ldr	r3, [pc, #16]	; (80109a0 <tcp_split_unsent_seg+0x37c>)
 8010990:	22ef      	movs	r2, #239	; 0xef
 8010992:	0092      	lsls	r2, r2, #2
 8010994:	490b      	ldr	r1, [pc, #44]	; (80109c4 <tcp_split_unsent_seg+0x3a0>)
 8010996:	4805      	ldr	r0, [pc, #20]	; (80109ac <tcp_split_unsent_seg+0x388>)
 8010998:	f7f2 f916 	bl	8002bc8 <app_debug_rtt_raw>
  /* Checksum the first payload pbuf accounting for offset, then other pbufs are all payload */
  for (; q != NULL; offset = 0, q = q->next) {
 801099c:	e039      	b.n	8010a12 <tcp_split_unsent_seg+0x3ee>
 801099e:	46c0      	nop			; (mov r8, r8)
 80109a0:	08020a34 	.word	0x08020a34
 80109a4:	0000034b 	.word	0x0000034b
 80109a8:	08020e88 	.word	0x08020e88
 80109ac:	08020a80 	.word	0x08020a80
 80109b0:	00000353 	.word	0x00000353
 80109b4:	08020eac 	.word	0x08020eac
 80109b8:	0000035b 	.word	0x0000035b
 80109bc:	08020ed0 	.word	0x08020ed0
 80109c0:	08020ee0 	.word	0x08020ee0
 80109c4:	08020ef0 	.word	0x08020ef0
    tcp_seg_add_chksum(~inet_chksum((const u8_t *)q->payload + offset, q->len - offset), q->len - offset,
 80109c8:	697b      	ldr	r3, [r7, #20]
 80109ca:	685a      	ldr	r2, [r3, #4]
 80109cc:	2418      	movs	r4, #24
 80109ce:	193b      	adds	r3, r7, r4
 80109d0:	881b      	ldrh	r3, [r3, #0]
 80109d2:	18d0      	adds	r0, r2, r3
 80109d4:	697b      	ldr	r3, [r7, #20]
 80109d6:	895a      	ldrh	r2, [r3, #10]
 80109d8:	193b      	adds	r3, r7, r4
 80109da:	881b      	ldrh	r3, [r3, #0]
 80109dc:	1ad3      	subs	r3, r2, r3
 80109de:	b29b      	uxth	r3, r3
 80109e0:	0019      	movs	r1, r3
 80109e2:	f7f7 fe4d 	bl	8008680 <inet_chksum>
 80109e6:	0003      	movs	r3, r0
 80109e8:	43db      	mvns	r3, r3
 80109ea:	b298      	uxth	r0, r3
 80109ec:	697b      	ldr	r3, [r7, #20]
 80109ee:	895a      	ldrh	r2, [r3, #10]
 80109f0:	193b      	adds	r3, r7, r4
 80109f2:	881b      	ldrh	r3, [r3, #0]
 80109f4:	1ad3      	subs	r3, r2, r3
 80109f6:	b299      	uxth	r1, r3
 80109f8:	693b      	ldr	r3, [r7, #16]
 80109fa:	330c      	adds	r3, #12
 80109fc:	001a      	movs	r2, r3
 80109fe:	693b      	ldr	r3, [r7, #16]
 8010a00:	330e      	adds	r3, #14
 8010a02:	f7fe fff7 	bl	800f9f4 <tcp_seg_add_chksum>
  for (; q != NULL; offset = 0, q = q->next) {
 8010a06:	193b      	adds	r3, r7, r4
 8010a08:	2200      	movs	r2, #0
 8010a0a:	801a      	strh	r2, [r3, #0]
 8010a0c:	697b      	ldr	r3, [r7, #20]
 8010a0e:	681b      	ldr	r3, [r3, #0]
 8010a10:	617b      	str	r3, [r7, #20]
 8010a12:	697b      	ldr	r3, [r7, #20]
 8010a14:	2b00      	cmp	r3, #0
 8010a16:	d1d7      	bne.n	80109c8 <tcp_split_unsent_seg+0x3a4>
#endif /* TCP_CHECKSUM_ON_COPY */

  /* Update number of segments on the queues. Note that length now may
   * exceed TCP_SND_QUEUELEN! We don't have to touch pcb->snd_buf
   * because the total amount of data is constant when packet is split */
  pcb->snd_queuelen += pbuf_clen(seg->p);
 8010a18:	69fb      	ldr	r3, [r7, #28]
 8010a1a:	685b      	ldr	r3, [r3, #4]
 8010a1c:	0018      	movs	r0, r3
 8010a1e:	f7f9 faed 	bl	8009ffc <pbuf_clen>
 8010a22:	0003      	movs	r3, r0
 8010a24:	0019      	movs	r1, r3
 8010a26:	687b      	ldr	r3, [r7, #4]
 8010a28:	226a      	movs	r2, #106	; 0x6a
 8010a2a:	5a9b      	ldrh	r3, [r3, r2]
 8010a2c:	18cb      	adds	r3, r1, r3
 8010a2e:	b299      	uxth	r1, r3
 8010a30:	687b      	ldr	r3, [r7, #4]
 8010a32:	226a      	movs	r2, #106	; 0x6a
 8010a34:	5299      	strh	r1, [r3, r2]

  /* Finally insert remainder into queue after split (which stays head) */
  seg->next = useg->next;
 8010a36:	693b      	ldr	r3, [r7, #16]
 8010a38:	681a      	ldr	r2, [r3, #0]
 8010a3a:	69fb      	ldr	r3, [r7, #28]
 8010a3c:	601a      	str	r2, [r3, #0]
  useg->next = seg;
 8010a3e:	693b      	ldr	r3, [r7, #16]
 8010a40:	69fa      	ldr	r2, [r7, #28]
 8010a42:	601a      	str	r2, [r3, #0]

#if TCP_OVERSIZE
  /* If remainder is last segment on the unsent, ensure we clear the oversize amount
   * because the remainder is always sized to the exact remaining amount */
  if (seg->next == NULL) {
 8010a44:	69fb      	ldr	r3, [r7, #28]
 8010a46:	681b      	ldr	r3, [r3, #0]
 8010a48:	2b00      	cmp	r3, #0
 8010a4a:	d103      	bne.n	8010a54 <tcp_split_unsent_seg+0x430>
    pcb->unsent_oversize = 0;
 8010a4c:	687b      	ldr	r3, [r7, #4]
 8010a4e:	226c      	movs	r2, #108	; 0x6c
 8010a50:	2100      	movs	r1, #0
 8010a52:	5299      	strh	r1, [r3, r2]
  }
#endif /* TCP_OVERSIZE */

  return ERR_OK;
 8010a54:	2300      	movs	r3, #0
 8010a56:	e014      	b.n	8010a82 <tcp_split_unsent_seg+0x45e>
    goto memerr;
 8010a58:	46c0      	nop			; (mov r8, r8)
 8010a5a:	e000      	b.n	8010a5e <tcp_split_unsent_seg+0x43a>
    goto memerr;
 8010a5c:	46c0      	nop			; (mov r8, r8)
memerr:
  TCP_STATS_INC(tcp.memerr);

  LWIP_ASSERT("seg == NULL", seg == NULL);
 8010a5e:	69fb      	ldr	r3, [r7, #28]
 8010a60:	2b00      	cmp	r3, #0
 8010a62:	d005      	beq.n	8010a70 <tcp_split_unsent_seg+0x44c>
 8010a64:	4b09      	ldr	r3, [pc, #36]	; (8010a8c <tcp_split_unsent_seg+0x468>)
 8010a66:	4a0a      	ldr	r2, [pc, #40]	; (8010a90 <tcp_split_unsent_seg+0x46c>)
 8010a68:	490a      	ldr	r1, [pc, #40]	; (8010a94 <tcp_split_unsent_seg+0x470>)
 8010a6a:	480b      	ldr	r0, [pc, #44]	; (8010a98 <tcp_split_unsent_seg+0x474>)
 8010a6c:	f7f2 f8ac 	bl	8002bc8 <app_debug_rtt_raw>
  if (p != NULL) {
 8010a70:	6a3b      	ldr	r3, [r7, #32]
 8010a72:	2b00      	cmp	r3, #0
 8010a74:	d003      	beq.n	8010a7e <tcp_split_unsent_seg+0x45a>
    pbuf_free(p);
 8010a76:	6a3b      	ldr	r3, [r7, #32]
 8010a78:	0018      	movs	r0, r3
 8010a7a:	f7f9 fa1f 	bl	8009ebc <pbuf_free>
  }

  return ERR_MEM;
 8010a7e:	2301      	movs	r3, #1
 8010a80:	425b      	negs	r3, r3
}
 8010a82:	0018      	movs	r0, r3
 8010a84:	46bd      	mov	sp, r7
 8010a86:	b00b      	add	sp, #44	; 0x2c
 8010a88:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8010a8a:	46c0      	nop			; (mov r8, r8)
 8010a8c:	08020a34 	.word	0x08020a34
 8010a90:	000003d9 	.word	0x000003d9
 8010a94:	08020f0c 	.word	0x08020f0c
 8010a98:	08020a80 	.word	0x08020a80

08010a9c <tcp_send_fin>:
 * @param pcb the tcp_pcb over which to send a segment
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_fin(struct tcp_pcb *pcb)
{
 8010a9c:	b590      	push	{r4, r7, lr}
 8010a9e:	b085      	sub	sp, #20
 8010aa0:	af00      	add	r7, sp, #0
 8010aa2:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_send_fin: invalid pcb", pcb != NULL);
 8010aa4:	687b      	ldr	r3, [r7, #4]
 8010aa6:	2b00      	cmp	r3, #0
 8010aa8:	d106      	bne.n	8010ab8 <tcp_send_fin+0x1c>
 8010aaa:	4b2e      	ldr	r3, [pc, #184]	; (8010b64 <tcp_send_fin+0xc8>)
 8010aac:	22fb      	movs	r2, #251	; 0xfb
 8010aae:	0092      	lsls	r2, r2, #2
 8010ab0:	492d      	ldr	r1, [pc, #180]	; (8010b68 <tcp_send_fin+0xcc>)
 8010ab2:	482e      	ldr	r0, [pc, #184]	; (8010b6c <tcp_send_fin+0xd0>)
 8010ab4:	f7f2 f888 	bl	8002bc8 <app_debug_rtt_raw>

  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
 8010ab8:	687b      	ldr	r3, [r7, #4]
 8010aba:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010abc:	2b00      	cmp	r3, #0
 8010abe:	d046      	beq.n	8010b4e <tcp_send_fin+0xb2>
    struct tcp_seg *last_unsent;
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 8010ac0:	687b      	ldr	r3, [r7, #4]
 8010ac2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010ac4:	60fb      	str	r3, [r7, #12]
 8010ac6:	e002      	b.n	8010ace <tcp_send_fin+0x32>
         last_unsent = last_unsent->next);
 8010ac8:	68fb      	ldr	r3, [r7, #12]
 8010aca:	681b      	ldr	r3, [r3, #0]
 8010acc:	60fb      	str	r3, [r7, #12]
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 8010ace:	68fb      	ldr	r3, [r7, #12]
 8010ad0:	681b      	ldr	r3, [r3, #0]
 8010ad2:	2b00      	cmp	r3, #0
 8010ad4:	d1f8      	bne.n	8010ac8 <tcp_send_fin+0x2c>

    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
 8010ad6:	68fb      	ldr	r3, [r7, #12]
 8010ad8:	691b      	ldr	r3, [r3, #16]
 8010ada:	7b1a      	ldrb	r2, [r3, #12]
 8010adc:	7b5b      	ldrb	r3, [r3, #13]
 8010ade:	021b      	lsls	r3, r3, #8
 8010ae0:	4313      	orrs	r3, r2
 8010ae2:	b29b      	uxth	r3, r3
 8010ae4:	0018      	movs	r0, r3
 8010ae6:	f7f6 fa05 	bl	8006ef4 <lwip_htons>
 8010aea:	0003      	movs	r3, r0
 8010aec:	b2db      	uxtb	r3, r3
 8010aee:	001a      	movs	r2, r3
 8010af0:	2307      	movs	r3, #7
 8010af2:	4013      	ands	r3, r2
 8010af4:	d12b      	bne.n	8010b4e <tcp_send_fin+0xb2>
      /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
 8010af6:	68fb      	ldr	r3, [r7, #12]
 8010af8:	691b      	ldr	r3, [r3, #16]
 8010afa:	7b1a      	ldrb	r2, [r3, #12]
 8010afc:	7b5b      	ldrb	r3, [r3, #13]
 8010afe:	021b      	lsls	r3, r3, #8
 8010b00:	4313      	orrs	r3, r2
 8010b02:	b29c      	uxth	r4, r3
 8010b04:	2001      	movs	r0, #1
 8010b06:	f7f6 f9f5 	bl	8006ef4 <lwip_htons>
 8010b0a:	0003      	movs	r3, r0
 8010b0c:	001a      	movs	r2, r3
 8010b0e:	68fb      	ldr	r3, [r7, #12]
 8010b10:	691b      	ldr	r3, [r3, #16]
 8010b12:	4322      	orrs	r2, r4
 8010b14:	b292      	uxth	r2, r2
 8010b16:	21ff      	movs	r1, #255	; 0xff
 8010b18:	4011      	ands	r1, r2
 8010b1a:	000c      	movs	r4, r1
 8010b1c:	7b19      	ldrb	r1, [r3, #12]
 8010b1e:	2000      	movs	r0, #0
 8010b20:	4001      	ands	r1, r0
 8010b22:	1c08      	adds	r0, r1, #0
 8010b24:	1c21      	adds	r1, r4, #0
 8010b26:	4301      	orrs	r1, r0
 8010b28:	7319      	strb	r1, [r3, #12]
 8010b2a:	0a12      	lsrs	r2, r2, #8
 8010b2c:	b290      	uxth	r0, r2
 8010b2e:	7b5a      	ldrb	r2, [r3, #13]
 8010b30:	2100      	movs	r1, #0
 8010b32:	400a      	ands	r2, r1
 8010b34:	1c11      	adds	r1, r2, #0
 8010b36:	1c02      	adds	r2, r0, #0
 8010b38:	430a      	orrs	r2, r1
 8010b3a:	735a      	strb	r2, [r3, #13]
      tcp_set_flags(pcb, TF_FIN);
 8010b3c:	687b      	ldr	r3, [r7, #4]
 8010b3e:	8bdb      	ldrh	r3, [r3, #30]
 8010b40:	2220      	movs	r2, #32
 8010b42:	4313      	orrs	r3, r2
 8010b44:	b29a      	uxth	r2, r3
 8010b46:	687b      	ldr	r3, [r7, #4]
 8010b48:	83da      	strh	r2, [r3, #30]
      return ERR_OK;
 8010b4a:	2300      	movs	r3, #0
 8010b4c:	e005      	b.n	8010b5a <tcp_send_fin+0xbe>
    }
  }
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue_flags(pcb, TCP_FIN);
 8010b4e:	687b      	ldr	r3, [r7, #4]
 8010b50:	2101      	movs	r1, #1
 8010b52:	0018      	movs	r0, r3
 8010b54:	f000 f80c 	bl	8010b70 <tcp_enqueue_flags>
 8010b58:	0003      	movs	r3, r0
}
 8010b5a:	0018      	movs	r0, r3
 8010b5c:	46bd      	mov	sp, r7
 8010b5e:	b005      	add	sp, #20
 8010b60:	bd90      	pop	{r4, r7, pc}
 8010b62:	46c0      	nop			; (mov r8, r8)
 8010b64:	08020a34 	.word	0x08020a34
 8010b68:	08020f18 	.word	0x08020f18
 8010b6c:	08020a80 	.word	0x08020a80

08010b70 <tcp_enqueue_flags>:
 * @param pcb Protocol control block for the TCP connection.
 * @param flags TCP header flags to set in the outgoing segment.
 */
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
 8010b70:	b590      	push	{r4, r7, lr}
 8010b72:	b089      	sub	sp, #36	; 0x24
 8010b74:	af02      	add	r7, sp, #8
 8010b76:	6078      	str	r0, [r7, #4]
 8010b78:	000a      	movs	r2, r1
 8010b7a:	1cfb      	adds	r3, r7, #3
 8010b7c:	701a      	strb	r2, [r3, #0]
  struct pbuf *p;
  struct tcp_seg *seg;
  u8_t optflags = 0;
 8010b7e:	2317      	movs	r3, #23
 8010b80:	18fb      	adds	r3, r7, r3
 8010b82:	2200      	movs	r2, #0
 8010b84:	701a      	strb	r2, [r3, #0]
  u8_t optlen = 0;
 8010b86:	2316      	movs	r3, #22
 8010b88:	18fb      	adds	r3, r7, r3
 8010b8a:	2200      	movs	r2, #0
 8010b8c:	701a      	strb	r2, [r3, #0]

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
 8010b8e:	1cfb      	adds	r3, r7, #3
 8010b90:	781b      	ldrb	r3, [r3, #0]
 8010b92:	2203      	movs	r2, #3
 8010b94:	4013      	ands	r3, r2
 8010b96:	d105      	bne.n	8010ba4 <tcp_enqueue_flags+0x34>
 8010b98:	4b6a      	ldr	r3, [pc, #424]	; (8010d44 <tcp_enqueue_flags+0x1d4>)
 8010b9a:	4a6b      	ldr	r2, [pc, #428]	; (8010d48 <tcp_enqueue_flags+0x1d8>)
 8010b9c:	496b      	ldr	r1, [pc, #428]	; (8010d4c <tcp_enqueue_flags+0x1dc>)
 8010b9e:	486c      	ldr	r0, [pc, #432]	; (8010d50 <tcp_enqueue_flags+0x1e0>)
 8010ba0:	f7f2 f812 	bl	8002bc8 <app_debug_rtt_raw>
              (flags & (TCP_SYN | TCP_FIN)) != 0);
  LWIP_ASSERT("tcp_enqueue_flags: invalid pcb", pcb != NULL);
 8010ba4:	687b      	ldr	r3, [r7, #4]
 8010ba6:	2b00      	cmp	r3, #0
 8010ba8:	d105      	bne.n	8010bb6 <tcp_enqueue_flags+0x46>
 8010baa:	4b66      	ldr	r3, [pc, #408]	; (8010d44 <tcp_enqueue_flags+0x1d4>)
 8010bac:	4a69      	ldr	r2, [pc, #420]	; (8010d54 <tcp_enqueue_flags+0x1e4>)
 8010bae:	496a      	ldr	r1, [pc, #424]	; (8010d58 <tcp_enqueue_flags+0x1e8>)
 8010bb0:	4867      	ldr	r0, [pc, #412]	; (8010d50 <tcp_enqueue_flags+0x1e0>)
 8010bb2:	f7f2 f809 	bl	8002bc8 <app_debug_rtt_raw>

  /* No need to check pcb->snd_queuelen if only SYN or FIN are allowed! */

  /* Get options for this segment. This is a special case since this is the
     only place where a SYN can be sent. */
  if (flags & TCP_SYN) {
 8010bb6:	1cfb      	adds	r3, r7, #3
 8010bb8:	781b      	ldrb	r3, [r3, #0]
 8010bba:	2202      	movs	r2, #2
 8010bbc:	4013      	ands	r3, r2
 8010bbe:	d003      	beq.n	8010bc8 <tcp_enqueue_flags+0x58>
    optflags = TF_SEG_OPTS_MSS;
 8010bc0:	2317      	movs	r3, #23
 8010bc2:	18fb      	adds	r3, r7, r3
 8010bc4:	2201      	movs	r2, #1
 8010bc6:	701a      	strb	r2, [r3, #0]
    /* Make sure the timestamp option is only included in data segments if we
       agreed about it with the remote host (and in active open SYN segments). */
    optflags |= TF_SEG_OPTS_TS;
  }
#endif /* LWIP_TCP_TIMESTAMPS */
  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
 8010bc8:	2317      	movs	r3, #23
 8010bca:	18fb      	adds	r3, r7, r3
 8010bcc:	781b      	ldrb	r3, [r3, #0]
 8010bce:	009b      	lsls	r3, r3, #2
 8010bd0:	b2da      	uxtb	r2, r3
 8010bd2:	2016      	movs	r0, #22
 8010bd4:	183b      	adds	r3, r7, r0
 8010bd6:	2104      	movs	r1, #4
 8010bd8:	400a      	ands	r2, r1
 8010bda:	701a      	strb	r2, [r3, #0]

  /* Allocate pbuf with room for TCP header + options */
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 8010bdc:	183b      	adds	r3, r7, r0
 8010bde:	781b      	ldrb	r3, [r3, #0]
 8010be0:	b29b      	uxth	r3, r3
 8010be2:	22a0      	movs	r2, #160	; 0xa0
 8010be4:	0092      	lsls	r2, r2, #2
 8010be6:	0019      	movs	r1, r3
 8010be8:	2038      	movs	r0, #56	; 0x38
 8010bea:	f7f8 fdef 	bl	80097cc <pbuf_alloc>
 8010bee:	0003      	movs	r3, r0
 8010bf0:	60fb      	str	r3, [r7, #12]
 8010bf2:	68fb      	ldr	r3, [r7, #12]
 8010bf4:	2b00      	cmp	r3, #0
 8010bf6:	d109      	bne.n	8010c0c <tcp_enqueue_flags+0x9c>
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
 8010bf8:	687b      	ldr	r3, [r7, #4]
 8010bfa:	8bdb      	ldrh	r3, [r3, #30]
 8010bfc:	2280      	movs	r2, #128	; 0x80
 8010bfe:	4313      	orrs	r3, r2
 8010c00:	b29a      	uxth	r2, r3
 8010c02:	687b      	ldr	r3, [r7, #4]
 8010c04:	83da      	strh	r2, [r3, #30]
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
 8010c06:	2301      	movs	r3, #1
 8010c08:	425b      	negs	r3, r3
 8010c0a:	e097      	b.n	8010d3c <tcp_enqueue_flags+0x1cc>
  }
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
 8010c0c:	68fb      	ldr	r3, [r7, #12]
 8010c0e:	895a      	ldrh	r2, [r3, #10]
 8010c10:	2316      	movs	r3, #22
 8010c12:	18fb      	adds	r3, r7, r3
 8010c14:	781b      	ldrb	r3, [r3, #0]
 8010c16:	b29b      	uxth	r3, r3
 8010c18:	429a      	cmp	r2, r3
 8010c1a:	d205      	bcs.n	8010c28 <tcp_enqueue_flags+0xb8>
 8010c1c:	4b49      	ldr	r3, [pc, #292]	; (8010d44 <tcp_enqueue_flags+0x1d4>)
 8010c1e:	4a4f      	ldr	r2, [pc, #316]	; (8010d5c <tcp_enqueue_flags+0x1ec>)
 8010c20:	494f      	ldr	r1, [pc, #316]	; (8010d60 <tcp_enqueue_flags+0x1f0>)
 8010c22:	484b      	ldr	r0, [pc, #300]	; (8010d50 <tcp_enqueue_flags+0x1e0>)
 8010c24:	f7f1 ffd0 	bl	8002bc8 <app_debug_rtt_raw>
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
 8010c28:	687b      	ldr	r3, [r7, #4]
 8010c2a:	6e1c      	ldr	r4, [r3, #96]	; 0x60
 8010c2c:	1cfb      	adds	r3, r7, #3
 8010c2e:	781a      	ldrb	r2, [r3, #0]
 8010c30:	68f9      	ldr	r1, [r7, #12]
 8010c32:	6878      	ldr	r0, [r7, #4]
 8010c34:	2317      	movs	r3, #23
 8010c36:	18fb      	adds	r3, r7, r3
 8010c38:	781b      	ldrb	r3, [r3, #0]
 8010c3a:	9300      	str	r3, [sp, #0]
 8010c3c:	0023      	movs	r3, r4
 8010c3e:	f7fe fd19 	bl	800f674 <tcp_create_segment>
 8010c42:	0003      	movs	r3, r0
 8010c44:	60bb      	str	r3, [r7, #8]
 8010c46:	68bb      	ldr	r3, [r7, #8]
 8010c48:	2b00      	cmp	r3, #0
 8010c4a:	d109      	bne.n	8010c60 <tcp_enqueue_flags+0xf0>
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
 8010c4c:	687b      	ldr	r3, [r7, #4]
 8010c4e:	8bdb      	ldrh	r3, [r3, #30]
 8010c50:	2280      	movs	r2, #128	; 0x80
 8010c52:	4313      	orrs	r3, r2
 8010c54:	b29a      	uxth	r2, r3
 8010c56:	687b      	ldr	r3, [r7, #4]
 8010c58:	83da      	strh	r2, [r3, #30]
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
 8010c5a:	2301      	movs	r3, #1
 8010c5c:	425b      	negs	r3, r3
 8010c5e:	e06d      	b.n	8010d3c <tcp_enqueue_flags+0x1cc>
  }
  LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % LWIP_MIN(MEM_ALIGNMENT, 4)) == 0);
 8010c60:	68bb      	ldr	r3, [r7, #8]
 8010c62:	691b      	ldr	r3, [r3, #16]
 8010c64:	001a      	movs	r2, r3
 8010c66:	2303      	movs	r3, #3
 8010c68:	4013      	ands	r3, r2
 8010c6a:	d005      	beq.n	8010c78 <tcp_enqueue_flags+0x108>
 8010c6c:	4b35      	ldr	r3, [pc, #212]	; (8010d44 <tcp_enqueue_flags+0x1d4>)
 8010c6e:	4a3d      	ldr	r2, [pc, #244]	; (8010d64 <tcp_enqueue_flags+0x1f4>)
 8010c70:	493d      	ldr	r1, [pc, #244]	; (8010d68 <tcp_enqueue_flags+0x1f8>)
 8010c72:	4837      	ldr	r0, [pc, #220]	; (8010d50 <tcp_enqueue_flags+0x1e0>)
 8010c74:	f7f1 ffa8 	bl	8002bc8 <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
 8010c78:	68bb      	ldr	r3, [r7, #8]
 8010c7a:	891b      	ldrh	r3, [r3, #8]
 8010c7c:	2b00      	cmp	r3, #0
 8010c7e:	d005      	beq.n	8010c8c <tcp_enqueue_flags+0x11c>
 8010c80:	4b30      	ldr	r3, [pc, #192]	; (8010d44 <tcp_enqueue_flags+0x1d4>)
 8010c82:	4a3a      	ldr	r2, [pc, #232]	; (8010d6c <tcp_enqueue_flags+0x1fc>)
 8010c84:	493a      	ldr	r1, [pc, #232]	; (8010d70 <tcp_enqueue_flags+0x200>)
 8010c86:	4832      	ldr	r0, [pc, #200]	; (8010d50 <tcp_enqueue_flags+0x1e0>)
 8010c88:	f7f1 ff9e 	bl	8002bc8 <app_debug_rtt_raw>
               lwip_ntohl(seg->tcphdr->seqno),
               lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
 8010c8c:	687b      	ldr	r3, [r7, #4]
 8010c8e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010c90:	2b00      	cmp	r3, #0
 8010c92:	d103      	bne.n	8010c9c <tcp_enqueue_flags+0x12c>
    pcb->unsent = seg;
 8010c94:	687b      	ldr	r3, [r7, #4]
 8010c96:	68ba      	ldr	r2, [r7, #8]
 8010c98:	671a      	str	r2, [r3, #112]	; 0x70
 8010c9a:	e00d      	b.n	8010cb8 <tcp_enqueue_flags+0x148>
  } else {
    struct tcp_seg *useg;
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
 8010c9c:	687b      	ldr	r3, [r7, #4]
 8010c9e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010ca0:	613b      	str	r3, [r7, #16]
 8010ca2:	e002      	b.n	8010caa <tcp_enqueue_flags+0x13a>
 8010ca4:	693b      	ldr	r3, [r7, #16]
 8010ca6:	681b      	ldr	r3, [r3, #0]
 8010ca8:	613b      	str	r3, [r7, #16]
 8010caa:	693b      	ldr	r3, [r7, #16]
 8010cac:	681b      	ldr	r3, [r3, #0]
 8010cae:	2b00      	cmp	r3, #0
 8010cb0:	d1f8      	bne.n	8010ca4 <tcp_enqueue_flags+0x134>
    useg->next = seg;
 8010cb2:	693b      	ldr	r3, [r7, #16]
 8010cb4:	68ba      	ldr	r2, [r7, #8]
 8010cb6:	601a      	str	r2, [r3, #0]
  }
#if TCP_OVERSIZE
  /* The new unsent tail has no space */
  pcb->unsent_oversize = 0;
 8010cb8:	687b      	ldr	r3, [r7, #4]
 8010cba:	226c      	movs	r2, #108	; 0x6c
 8010cbc:	2100      	movs	r1, #0
 8010cbe:	5299      	strh	r1, [r3, r2]
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
 8010cc0:	1cfb      	adds	r3, r7, #3
 8010cc2:	781b      	ldrb	r3, [r3, #0]
 8010cc4:	2202      	movs	r2, #2
 8010cc6:	4013      	ands	r3, r2
 8010cc8:	d104      	bne.n	8010cd4 <tcp_enqueue_flags+0x164>
 8010cca:	1cfb      	adds	r3, r7, #3
 8010ccc:	781b      	ldrb	r3, [r3, #0]
 8010cce:	2201      	movs	r2, #1
 8010cd0:	4013      	ands	r3, r2
 8010cd2:	d004      	beq.n	8010cde <tcp_enqueue_flags+0x16e>
    pcb->snd_lbb++;
 8010cd4:	687b      	ldr	r3, [r7, #4]
 8010cd6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8010cd8:	1c5a      	adds	r2, r3, #1
 8010cda:	687b      	ldr	r3, [r7, #4]
 8010cdc:	661a      	str	r2, [r3, #96]	; 0x60
    /* optlen does not influence snd_buf */
  }
  if (flags & TCP_FIN) {
 8010cde:	1cfb      	adds	r3, r7, #3
 8010ce0:	781b      	ldrb	r3, [r3, #0]
 8010ce2:	2201      	movs	r2, #1
 8010ce4:	4013      	ands	r3, r2
 8010ce6:	d006      	beq.n	8010cf6 <tcp_enqueue_flags+0x186>
    tcp_set_flags(pcb, TF_FIN);
 8010ce8:	687b      	ldr	r3, [r7, #4]
 8010cea:	8bdb      	ldrh	r3, [r3, #30]
 8010cec:	2220      	movs	r2, #32
 8010cee:	4313      	orrs	r3, r2
 8010cf0:	b29a      	uxth	r2, r3
 8010cf2:	687b      	ldr	r3, [r7, #4]
 8010cf4:	83da      	strh	r2, [r3, #30]
  }

  /* update number of segments on the queues */
  pcb->snd_queuelen += pbuf_clen(seg->p);
 8010cf6:	68bb      	ldr	r3, [r7, #8]
 8010cf8:	685b      	ldr	r3, [r3, #4]
 8010cfa:	0018      	movs	r0, r3
 8010cfc:	f7f9 f97e 	bl	8009ffc <pbuf_clen>
 8010d00:	0003      	movs	r3, r0
 8010d02:	0019      	movs	r1, r3
 8010d04:	687b      	ldr	r3, [r7, #4]
 8010d06:	226a      	movs	r2, #106	; 0x6a
 8010d08:	5a9b      	ldrh	r3, [r3, r2]
 8010d0a:	18cb      	adds	r3, r1, r3
 8010d0c:	b299      	uxth	r1, r3
 8010d0e:	687b      	ldr	r3, [r7, #4]
 8010d10:	226a      	movs	r2, #106	; 0x6a
 8010d12:	5299      	strh	r1, [r3, r2]
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
 8010d14:	687b      	ldr	r3, [r7, #4]
 8010d16:	226a      	movs	r2, #106	; 0x6a
 8010d18:	5a9b      	ldrh	r3, [r3, r2]
 8010d1a:	2b00      	cmp	r3, #0
 8010d1c:	d00d      	beq.n	8010d3a <tcp_enqueue_flags+0x1ca>
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
 8010d1e:	687b      	ldr	r3, [r7, #4]
 8010d20:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8010d22:	2b00      	cmp	r3, #0
 8010d24:	d109      	bne.n	8010d3a <tcp_enqueue_flags+0x1ca>
 8010d26:	687b      	ldr	r3, [r7, #4]
 8010d28:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010d2a:	2b00      	cmp	r3, #0
 8010d2c:	d105      	bne.n	8010d3a <tcp_enqueue_flags+0x1ca>
 8010d2e:	4b05      	ldr	r3, [pc, #20]	; (8010d44 <tcp_enqueue_flags+0x1d4>)
 8010d30:	4a10      	ldr	r2, [pc, #64]	; (8010d74 <tcp_enqueue_flags+0x204>)
 8010d32:	4911      	ldr	r1, [pc, #68]	; (8010d78 <tcp_enqueue_flags+0x208>)
 8010d34:	4806      	ldr	r0, [pc, #24]	; (8010d50 <tcp_enqueue_flags+0x1e0>)
 8010d36:	f7f1 ff47 	bl	8002bc8 <app_debug_rtt_raw>
                pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
 8010d3a:	2300      	movs	r3, #0
}
 8010d3c:	0018      	movs	r0, r3
 8010d3e:	46bd      	mov	sp, r7
 8010d40:	b007      	add	sp, #28
 8010d42:	bd90      	pop	{r4, r7, pc}
 8010d44:	08020a34 	.word	0x08020a34
 8010d48:	00000412 	.word	0x00000412
 8010d4c:	08020f34 	.word	0x08020f34
 8010d50:	08020a80 	.word	0x08020a80
 8010d54:	00000414 	.word	0x00000414
 8010d58:	08020f8c 	.word	0x08020f8c
 8010d5c:	0000043a 	.word	0x0000043a
 8010d60:	08020fac 	.word	0x08020fac
 8010d64:	00000443 	.word	0x00000443
 8010d68:	08020fe8 	.word	0x08020fe8
 8010d6c:	00000444 	.word	0x00000444
 8010d70:	08021000 	.word	0x08021000
 8010d74:	00000466 	.word	0x00000466
 8010d78:	0802102c 	.word	0x0802102c

08010d7c <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
 8010d7c:	b5b0      	push	{r4, r5, r7, lr}
 8010d7e:	b08a      	sub	sp, #40	; 0x28
 8010d80:	af00      	add	r7, sp, #0
 8010d82:	6078      	str	r0, [r7, #4]
  s16_t i = 0;
#endif /* TCP_CWND_DEBUG */

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ASSERT("tcp_output: invalid pcb", pcb != NULL);
 8010d84:	687b      	ldr	r3, [r7, #4]
 8010d86:	2b00      	cmp	r3, #0
 8010d88:	d105      	bne.n	8010d96 <tcp_output+0x1a>
 8010d8a:	4bcb      	ldr	r3, [pc, #812]	; (80110b8 <tcp_output+0x33c>)
 8010d8c:	4acb      	ldr	r2, [pc, #812]	; (80110bc <tcp_output+0x340>)
 8010d8e:	49cc      	ldr	r1, [pc, #816]	; (80110c0 <tcp_output+0x344>)
 8010d90:	48cc      	ldr	r0, [pc, #816]	; (80110c4 <tcp_output+0x348>)
 8010d92:	f7f1 ff19 	bl	8002bc8 <app_debug_rtt_raw>
  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_output for listen-pcbs",
 8010d96:	687b      	ldr	r3, [r7, #4]
 8010d98:	7e1b      	ldrb	r3, [r3, #24]
 8010d9a:	2b01      	cmp	r3, #1
 8010d9c:	d105      	bne.n	8010daa <tcp_output+0x2e>
 8010d9e:	4bc6      	ldr	r3, [pc, #792]	; (80110b8 <tcp_output+0x33c>)
 8010da0:	4ac9      	ldr	r2, [pc, #804]	; (80110c8 <tcp_output+0x34c>)
 8010da2:	49ca      	ldr	r1, [pc, #808]	; (80110cc <tcp_output+0x350>)
 8010da4:	48c7      	ldr	r0, [pc, #796]	; (80110c4 <tcp_output+0x348>)
 8010da6:	f7f1 ff0f 	bl	8002bc8 <app_debug_rtt_raw>

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
 8010daa:	4bc9      	ldr	r3, [pc, #804]	; (80110d0 <tcp_output+0x354>)
 8010dac:	681b      	ldr	r3, [r3, #0]
 8010dae:	687a      	ldr	r2, [r7, #4]
 8010db0:	429a      	cmp	r2, r3
 8010db2:	d101      	bne.n	8010db8 <tcp_output+0x3c>
    return ERR_OK;
 8010db4:	2300      	movs	r3, #0
 8010db6:	e23d      	b.n	8011234 <tcp_output+0x4b8>
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
 8010db8:	687b      	ldr	r3, [r7, #4]
 8010dba:	224c      	movs	r2, #76	; 0x4c
 8010dbc:	5a99      	ldrh	r1, [r3, r2]
 8010dbe:	687b      	ldr	r3, [r7, #4]
 8010dc0:	2264      	movs	r2, #100	; 0x64
 8010dc2:	5a9b      	ldrh	r3, [r3, r2]
 8010dc4:	1c18      	adds	r0, r3, #0
 8010dc6:	b28a      	uxth	r2, r1
 8010dc8:	b283      	uxth	r3, r0
 8010dca:	429a      	cmp	r2, r3
 8010dcc:	d900      	bls.n	8010dd0 <tcp_output+0x54>
 8010dce:	1c01      	adds	r1, r0, #0
 8010dd0:	b28b      	uxth	r3, r1
 8010dd2:	61bb      	str	r3, [r7, #24]

  seg = pcb->unsent;
 8010dd4:	687b      	ldr	r3, [r7, #4]
 8010dd6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010dd8:	627b      	str	r3, [r7, #36]	; 0x24

  if (seg == NULL) {
 8010dda:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010ddc:	2b00      	cmp	r3, #0
 8010dde:	d10c      	bne.n	8010dfa <tcp_output+0x7e>
                                 ", seg == NULL, ack %"U32_F"\n",
                                 pcb->snd_wnd, pcb->cwnd, wnd, pcb->lastack));

    /* If the TF_ACK_NOW flag is set and the ->unsent queue is empty, construct
     * an empty ACK segment and send it. */
    if (pcb->flags & TF_ACK_NOW) {
 8010de0:	687b      	ldr	r3, [r7, #4]
 8010de2:	8bdb      	ldrh	r3, [r3, #30]
 8010de4:	001a      	movs	r2, r3
 8010de6:	2302      	movs	r3, #2
 8010de8:	4013      	ands	r3, r2
 8010dea:	d100      	bne.n	8010dee <tcp_output+0x72>
 8010dec:	e215      	b.n	801121a <tcp_output+0x49e>
      return tcp_send_empty_ack(pcb);
 8010dee:	687b      	ldr	r3, [r7, #4]
 8010df0:	0018      	movs	r0, r3
 8010df2:	f001 f877 	bl	8011ee4 <tcp_send_empty_ack>
 8010df6:	0003      	movs	r3, r0
 8010df8:	e21c      	b.n	8011234 <tcp_output+0x4b8>
                 pcb->snd_wnd, pcb->cwnd, wnd,
                 lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 lwip_ntohl(seg->tcphdr->seqno), pcb->lastack));
  }

  netif = tcp_route(pcb, &pcb->local_ip, &pcb->remote_ip);
 8010dfa:	6879      	ldr	r1, [r7, #4]
 8010dfc:	687b      	ldr	r3, [r7, #4]
 8010dfe:	1d1a      	adds	r2, r3, #4
 8010e00:	687b      	ldr	r3, [r7, #4]
 8010e02:	0018      	movs	r0, r3
 8010e04:	f7fe fc18 	bl	800f638 <tcp_route>
 8010e08:	0003      	movs	r3, r0
 8010e0a:	617b      	str	r3, [r7, #20]
  if (netif == NULL) {
 8010e0c:	697b      	ldr	r3, [r7, #20]
 8010e0e:	2b00      	cmp	r3, #0
 8010e10:	d102      	bne.n	8010e18 <tcp_output+0x9c>
    return ERR_RTE;
 8010e12:	2304      	movs	r3, #4
 8010e14:	425b      	negs	r3, r3
 8010e16:	e20d      	b.n	8011234 <tcp_output+0x4b8>
  }

  /* If we don't have a local IP address, we get one from netif */
  if (ip_addr_isany(&pcb->local_ip)) {
 8010e18:	687b      	ldr	r3, [r7, #4]
 8010e1a:	2b00      	cmp	r3, #0
 8010e1c:	d003      	beq.n	8010e26 <tcp_output+0xaa>
 8010e1e:	687b      	ldr	r3, [r7, #4]
 8010e20:	681b      	ldr	r3, [r3, #0]
 8010e22:	2b00      	cmp	r3, #0
 8010e24:	d111      	bne.n	8010e4a <tcp_output+0xce>
    const ip_addr_t *local_ip = ip_netif_get_local_ip(netif, &pcb->remote_ip);
 8010e26:	697b      	ldr	r3, [r7, #20]
 8010e28:	2b00      	cmp	r3, #0
 8010e2a:	d002      	beq.n	8010e32 <tcp_output+0xb6>
 8010e2c:	697b      	ldr	r3, [r7, #20]
 8010e2e:	3304      	adds	r3, #4
 8010e30:	e000      	b.n	8010e34 <tcp_output+0xb8>
 8010e32:	2300      	movs	r3, #0
 8010e34:	613b      	str	r3, [r7, #16]
    if (local_ip == NULL) {
 8010e36:	693b      	ldr	r3, [r7, #16]
 8010e38:	2b00      	cmp	r3, #0
 8010e3a:	d102      	bne.n	8010e42 <tcp_output+0xc6>
      return ERR_RTE;
 8010e3c:	2304      	movs	r3, #4
 8010e3e:	425b      	negs	r3, r3
 8010e40:	e1f8      	b.n	8011234 <tcp_output+0x4b8>
    }
    ip_addr_copy(pcb->local_ip, *local_ip);
 8010e42:	693b      	ldr	r3, [r7, #16]
 8010e44:	681a      	ldr	r2, [r3, #0]
 8010e46:	687b      	ldr	r3, [r7, #4]
 8010e48:	601a      	str	r2, [r3, #0]
  }

  /* Handle the current segment not fitting within the window */
  if (lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd) {
 8010e4a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010e4c:	691b      	ldr	r3, [r3, #16]
 8010e4e:	791a      	ldrb	r2, [r3, #4]
 8010e50:	7959      	ldrb	r1, [r3, #5]
 8010e52:	0209      	lsls	r1, r1, #8
 8010e54:	430a      	orrs	r2, r1
 8010e56:	7999      	ldrb	r1, [r3, #6]
 8010e58:	0409      	lsls	r1, r1, #16
 8010e5a:	430a      	orrs	r2, r1
 8010e5c:	79db      	ldrb	r3, [r3, #7]
 8010e5e:	061b      	lsls	r3, r3, #24
 8010e60:	4313      	orrs	r3, r2
 8010e62:	0018      	movs	r0, r3
 8010e64:	f7f6 f85c 	bl	8006f20 <lwip_htonl>
 8010e68:	0002      	movs	r2, r0
 8010e6a:	687b      	ldr	r3, [r7, #4]
 8010e6c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8010e6e:	1ad3      	subs	r3, r2, r3
 8010e70:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8010e72:	8912      	ldrh	r2, [r2, #8]
 8010e74:	189b      	adds	r3, r3, r2
 8010e76:	69ba      	ldr	r2, [r7, #24]
 8010e78:	429a      	cmp	r2, r3
 8010e7a:	d228      	bcs.n	8010ece <tcp_output+0x152>
     * within the remaining (could be 0) send window and RTO timer is not running (we
     * have no in-flight data). If window is still too small after persist timer fires,
     * then we split the segment. We don't consider the congestion window since a cwnd
     * smaller than 1 SMSS implies in-flight data
     */
    if (wnd == pcb->snd_wnd && pcb->unacked == NULL && pcb->persist_backoff == 0) {
 8010e7c:	687b      	ldr	r3, [r7, #4]
 8010e7e:	2264      	movs	r2, #100	; 0x64
 8010e80:	5a9b      	ldrh	r3, [r3, r2]
 8010e82:	001a      	movs	r2, r3
 8010e84:	69bb      	ldr	r3, [r7, #24]
 8010e86:	4293      	cmp	r3, r2
 8010e88:	d114      	bne.n	8010eb4 <tcp_output+0x138>
 8010e8a:	687b      	ldr	r3, [r7, #4]
 8010e8c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8010e8e:	2b00      	cmp	r3, #0
 8010e90:	d110      	bne.n	8010eb4 <tcp_output+0x138>
 8010e92:	687b      	ldr	r3, [r7, #4]
 8010e94:	22a5      	movs	r2, #165	; 0xa5
 8010e96:	5c9b      	ldrb	r3, [r3, r2]
 8010e98:	2b00      	cmp	r3, #0
 8010e9a:	d10b      	bne.n	8010eb4 <tcp_output+0x138>
      pcb->persist_cnt = 0;
 8010e9c:	687b      	ldr	r3, [r7, #4]
 8010e9e:	22a4      	movs	r2, #164	; 0xa4
 8010ea0:	2100      	movs	r1, #0
 8010ea2:	5499      	strb	r1, [r3, r2]
      pcb->persist_backoff = 1;
 8010ea4:	687b      	ldr	r3, [r7, #4]
 8010ea6:	22a5      	movs	r2, #165	; 0xa5
 8010ea8:	2101      	movs	r1, #1
 8010eaa:	5499      	strb	r1, [r3, r2]
      pcb->persist_probe = 0;
 8010eac:	687b      	ldr	r3, [r7, #4]
 8010eae:	22a6      	movs	r2, #166	; 0xa6
 8010eb0:	2100      	movs	r1, #0
 8010eb2:	5499      	strb	r1, [r3, r2]
    }
    /* We need an ACK, but can't send data now, so send an empty ACK */
    if (pcb->flags & TF_ACK_NOW) {
 8010eb4:	687b      	ldr	r3, [r7, #4]
 8010eb6:	8bdb      	ldrh	r3, [r3, #30]
 8010eb8:	001a      	movs	r2, r3
 8010eba:	2302      	movs	r3, #2
 8010ebc:	4013      	ands	r3, r2
 8010ebe:	d100      	bne.n	8010ec2 <tcp_output+0x146>
 8010ec0:	e1ad      	b.n	801121e <tcp_output+0x4a2>
      return tcp_send_empty_ack(pcb);
 8010ec2:	687b      	ldr	r3, [r7, #4]
 8010ec4:	0018      	movs	r0, r3
 8010ec6:	f001 f80d 	bl	8011ee4 <tcp_send_empty_ack>
 8010eca:	0003      	movs	r3, r0
 8010ecc:	e1b2      	b.n	8011234 <tcp_output+0x4b8>
    }
    goto output_done;
  }
  /* Stop persist timer, above conditions are not active */
  pcb->persist_backoff = 0;
 8010ece:	687b      	ldr	r3, [r7, #4]
 8010ed0:	22a5      	movs	r2, #165	; 0xa5
 8010ed2:	2100      	movs	r1, #0
 8010ed4:	5499      	strb	r1, [r3, r2]

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
 8010ed6:	687b      	ldr	r3, [r7, #4]
 8010ed8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8010eda:	623b      	str	r3, [r7, #32]
  if (useg != NULL) {
 8010edc:	6a3b      	ldr	r3, [r7, #32]
 8010ede:	2b00      	cmp	r3, #0
 8010ee0:	d100      	bne.n	8010ee4 <tcp_output+0x168>
 8010ee2:	e172      	b.n	80111ca <tcp_output+0x44e>
    for (; useg->next != NULL; useg = useg->next);
 8010ee4:	e002      	b.n	8010eec <tcp_output+0x170>
 8010ee6:	6a3b      	ldr	r3, [r7, #32]
 8010ee8:	681b      	ldr	r3, [r3, #0]
 8010eea:	623b      	str	r3, [r7, #32]
 8010eec:	6a3b      	ldr	r3, [r7, #32]
 8010eee:	681b      	ldr	r3, [r3, #0]
 8010ef0:	2b00      	cmp	r3, #0
 8010ef2:	d1f8      	bne.n	8010ee6 <tcp_output+0x16a>
  }
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 8010ef4:	e169      	b.n	80111ca <tcp_output+0x44e>
         lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!",
 8010ef6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010ef8:	691b      	ldr	r3, [r3, #16]
 8010efa:	7b1a      	ldrb	r2, [r3, #12]
 8010efc:	7b5b      	ldrb	r3, [r3, #13]
 8010efe:	021b      	lsls	r3, r3, #8
 8010f00:	4313      	orrs	r3, r2
 8010f02:	b29b      	uxth	r3, r3
 8010f04:	0018      	movs	r0, r3
 8010f06:	f7f5 fff5 	bl	8006ef4 <lwip_htons>
 8010f0a:	0003      	movs	r3, r0
 8010f0c:	b2db      	uxtb	r3, r3
 8010f0e:	001a      	movs	r2, r3
 8010f10:	2304      	movs	r3, #4
 8010f12:	4013      	ands	r3, r2
 8010f14:	d005      	beq.n	8010f22 <tcp_output+0x1a6>
 8010f16:	4b68      	ldr	r3, [pc, #416]	; (80110b8 <tcp_output+0x33c>)
 8010f18:	4a6e      	ldr	r2, [pc, #440]	; (80110d4 <tcp_output+0x358>)
 8010f1a:	496f      	ldr	r1, [pc, #444]	; (80110d8 <tcp_output+0x35c>)
 8010f1c:	4869      	ldr	r0, [pc, #420]	; (80110c4 <tcp_output+0x348>)
 8010f1e:	f7f1 fe53 	bl	8002bc8 <app_debug_rtt_raw>
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if ((tcp_do_output_nagle(pcb) == 0) &&
 8010f22:	687b      	ldr	r3, [r7, #4]
 8010f24:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8010f26:	2b00      	cmp	r3, #0
 8010f28:	d01f      	beq.n	8010f6a <tcp_output+0x1ee>
 8010f2a:	687b      	ldr	r3, [r7, #4]
 8010f2c:	8bdb      	ldrh	r3, [r3, #30]
 8010f2e:	001a      	movs	r2, r3
 8010f30:	2344      	movs	r3, #68	; 0x44
 8010f32:	4013      	ands	r3, r2
 8010f34:	d119      	bne.n	8010f6a <tcp_output+0x1ee>
 8010f36:	687b      	ldr	r3, [r7, #4]
 8010f38:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010f3a:	2b00      	cmp	r3, #0
 8010f3c:	d00b      	beq.n	8010f56 <tcp_output+0x1da>
 8010f3e:	687b      	ldr	r3, [r7, #4]
 8010f40:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010f42:	681b      	ldr	r3, [r3, #0]
 8010f44:	2b00      	cmp	r3, #0
 8010f46:	d110      	bne.n	8010f6a <tcp_output+0x1ee>
 8010f48:	687b      	ldr	r3, [r7, #4]
 8010f4a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010f4c:	891a      	ldrh	r2, [r3, #8]
 8010f4e:	687b      	ldr	r3, [r7, #4]
 8010f50:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8010f52:	429a      	cmp	r2, r3
 8010f54:	d209      	bcs.n	8010f6a <tcp_output+0x1ee>
 8010f56:	687b      	ldr	r3, [r7, #4]
 8010f58:	2268      	movs	r2, #104	; 0x68
 8010f5a:	5a9b      	ldrh	r3, [r3, r2]
 8010f5c:	2b00      	cmp	r3, #0
 8010f5e:	d004      	beq.n	8010f6a <tcp_output+0x1ee>
 8010f60:	687b      	ldr	r3, [r7, #4]
 8010f62:	226a      	movs	r2, #106	; 0x6a
 8010f64:	5a9b      	ldrh	r3, [r3, r2]
 8010f66:	2b07      	cmp	r3, #7
 8010f68:	d901      	bls.n	8010f6e <tcp_output+0x1f2>
 8010f6a:	2301      	movs	r3, #1
 8010f6c:	e000      	b.n	8010f70 <tcp_output+0x1f4>
 8010f6e:	2300      	movs	r3, #0
 8010f70:	2b00      	cmp	r3, #0
 8010f72:	d106      	bne.n	8010f82 <tcp_output+0x206>
        ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)) {
 8010f74:	687b      	ldr	r3, [r7, #4]
 8010f76:	8bdb      	ldrh	r3, [r3, #30]
 8010f78:	001a      	movs	r2, r3
 8010f7a:	23a0      	movs	r3, #160	; 0xa0
 8010f7c:	4013      	ands	r3, r2
    if ((tcp_do_output_nagle(pcb) == 0) &&
 8010f7e:	d100      	bne.n	8010f82 <tcp_output+0x206>
 8010f80:	e141      	b.n	8011206 <tcp_output+0x48a>
                                 pcb->lastack,
                                 lwip_ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    if (pcb->state != SYN_SENT) {
 8010f82:	687b      	ldr	r3, [r7, #4]
 8010f84:	7e1b      	ldrb	r3, [r3, #24]
 8010f86:	2b02      	cmp	r3, #2
 8010f88:	d022      	beq.n	8010fd0 <tcp_output+0x254>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
 8010f8a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010f8c:	691b      	ldr	r3, [r3, #16]
 8010f8e:	7b1a      	ldrb	r2, [r3, #12]
 8010f90:	7b5b      	ldrb	r3, [r3, #13]
 8010f92:	021b      	lsls	r3, r3, #8
 8010f94:	4313      	orrs	r3, r2
 8010f96:	b29c      	uxth	r4, r3
 8010f98:	2010      	movs	r0, #16
 8010f9a:	f7f5 ffab 	bl	8006ef4 <lwip_htons>
 8010f9e:	0003      	movs	r3, r0
 8010fa0:	001a      	movs	r2, r3
 8010fa2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010fa4:	691b      	ldr	r3, [r3, #16]
 8010fa6:	4322      	orrs	r2, r4
 8010fa8:	b292      	uxth	r2, r2
 8010faa:	21ff      	movs	r1, #255	; 0xff
 8010fac:	4011      	ands	r1, r2
 8010fae:	000c      	movs	r4, r1
 8010fb0:	7b19      	ldrb	r1, [r3, #12]
 8010fb2:	2000      	movs	r0, #0
 8010fb4:	4001      	ands	r1, r0
 8010fb6:	1c08      	adds	r0, r1, #0
 8010fb8:	1c21      	adds	r1, r4, #0
 8010fba:	4301      	orrs	r1, r0
 8010fbc:	7319      	strb	r1, [r3, #12]
 8010fbe:	0a12      	lsrs	r2, r2, #8
 8010fc0:	b290      	uxth	r0, r2
 8010fc2:	7b5a      	ldrb	r2, [r3, #13]
 8010fc4:	2100      	movs	r1, #0
 8010fc6:	400a      	ands	r2, r1
 8010fc8:	1c11      	adds	r1, r2, #0
 8010fca:	1c02      	adds	r2, r0, #0
 8010fcc:	430a      	orrs	r2, r1
 8010fce:	735a      	strb	r2, [r3, #13]
    }

    err = tcp_output_segment(seg, pcb, netif);
 8010fd0:	250f      	movs	r5, #15
 8010fd2:	197c      	adds	r4, r7, r5
 8010fd4:	697a      	ldr	r2, [r7, #20]
 8010fd6:	6879      	ldr	r1, [r7, #4]
 8010fd8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010fda:	0018      	movs	r0, r3
 8010fdc:	f000 f950 	bl	8011280 <tcp_output_segment>
 8010fe0:	0003      	movs	r3, r0
 8010fe2:	7023      	strb	r3, [r4, #0]
    if (err != ERR_OK) {
 8010fe4:	0029      	movs	r1, r5
 8010fe6:	187b      	adds	r3, r7, r1
 8010fe8:	781b      	ldrb	r3, [r3, #0]
 8010fea:	b25b      	sxtb	r3, r3
 8010fec:	2b00      	cmp	r3, #0
 8010fee:	d00a      	beq.n	8011006 <tcp_output+0x28a>
      /* segment could not be sent, for whatever reason */
      tcp_set_flags(pcb, TF_NAGLEMEMERR);
 8010ff0:	687b      	ldr	r3, [r7, #4]
 8010ff2:	8bdb      	ldrh	r3, [r3, #30]
 8010ff4:	2280      	movs	r2, #128	; 0x80
 8010ff6:	4313      	orrs	r3, r2
 8010ff8:	b29a      	uxth	r2, r3
 8010ffa:	687b      	ldr	r3, [r7, #4]
 8010ffc:	83da      	strh	r2, [r3, #30]
      return err;
 8010ffe:	187b      	adds	r3, r7, r1
 8011000:	781b      	ldrb	r3, [r3, #0]
 8011002:	b25b      	sxtb	r3, r3
 8011004:	e116      	b.n	8011234 <tcp_output+0x4b8>
    }
#if TCP_OVERSIZE_DBGCHECK
    seg->oversize_left = 0;
 8011006:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011008:	2200      	movs	r2, #0
 801100a:	815a      	strh	r2, [r3, #10]
#endif /* TCP_OVERSIZE_DBGCHECK */
    pcb->unsent = seg->next;
 801100c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801100e:	681a      	ldr	r2, [r3, #0]
 8011010:	687b      	ldr	r3, [r7, #4]
 8011012:	671a      	str	r2, [r3, #112]	; 0x70
    if (pcb->state != SYN_SENT) {
 8011014:	687b      	ldr	r3, [r7, #4]
 8011016:	7e1b      	ldrb	r3, [r3, #24]
 8011018:	2b02      	cmp	r3, #2
 801101a:	d006      	beq.n	801102a <tcp_output+0x2ae>
      tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 801101c:	687b      	ldr	r3, [r7, #4]
 801101e:	8bdb      	ldrh	r3, [r3, #30]
 8011020:	2203      	movs	r2, #3
 8011022:	4393      	bics	r3, r2
 8011024:	b29a      	uxth	r2, r3
 8011026:	687b      	ldr	r3, [r7, #4]
 8011028:	83da      	strh	r2, [r3, #30]
    }
    snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 801102a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801102c:	691b      	ldr	r3, [r3, #16]
 801102e:	791a      	ldrb	r2, [r3, #4]
 8011030:	7959      	ldrb	r1, [r3, #5]
 8011032:	0209      	lsls	r1, r1, #8
 8011034:	430a      	orrs	r2, r1
 8011036:	7999      	ldrb	r1, [r3, #6]
 8011038:	0409      	lsls	r1, r1, #16
 801103a:	430a      	orrs	r2, r1
 801103c:	79db      	ldrb	r3, [r3, #7]
 801103e:	061b      	lsls	r3, r3, #24
 8011040:	4313      	orrs	r3, r2
 8011042:	0018      	movs	r0, r3
 8011044:	f7f5 ff6c 	bl	8006f20 <lwip_htonl>
 8011048:	0004      	movs	r4, r0
 801104a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801104c:	891b      	ldrh	r3, [r3, #8]
 801104e:	001d      	movs	r5, r3
 8011050:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011052:	691b      	ldr	r3, [r3, #16]
 8011054:	7b1a      	ldrb	r2, [r3, #12]
 8011056:	7b5b      	ldrb	r3, [r3, #13]
 8011058:	021b      	lsls	r3, r3, #8
 801105a:	4313      	orrs	r3, r2
 801105c:	b29b      	uxth	r3, r3
 801105e:	0018      	movs	r0, r3
 8011060:	f7f5 ff48 	bl	8006ef4 <lwip_htons>
 8011064:	0003      	movs	r3, r0
 8011066:	b2db      	uxtb	r3, r3
 8011068:	001a      	movs	r2, r3
 801106a:	2303      	movs	r3, #3
 801106c:	4013      	ands	r3, r2
 801106e:	d001      	beq.n	8011074 <tcp_output+0x2f8>
 8011070:	2301      	movs	r3, #1
 8011072:	e000      	b.n	8011076 <tcp_output+0x2fa>
 8011074:	2300      	movs	r3, #0
 8011076:	195b      	adds	r3, r3, r5
 8011078:	18e3      	adds	r3, r4, r3
 801107a:	60bb      	str	r3, [r7, #8]
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 801107c:	687b      	ldr	r3, [r7, #4]
 801107e:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8011080:	68bb      	ldr	r3, [r7, #8]
 8011082:	1ad3      	subs	r3, r2, r3
 8011084:	d502      	bpl.n	801108c <tcp_output+0x310>
      pcb->snd_nxt = snd_nxt;
 8011086:	687b      	ldr	r3, [r7, #4]
 8011088:	68ba      	ldr	r2, [r7, #8]
 801108a:	655a      	str	r2, [r3, #84]	; 0x54
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
 801108c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801108e:	891b      	ldrh	r3, [r3, #8]
 8011090:	001c      	movs	r4, r3
 8011092:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011094:	691b      	ldr	r3, [r3, #16]
 8011096:	7b1a      	ldrb	r2, [r3, #12]
 8011098:	7b5b      	ldrb	r3, [r3, #13]
 801109a:	021b      	lsls	r3, r3, #8
 801109c:	4313      	orrs	r3, r2
 801109e:	b29b      	uxth	r3, r3
 80110a0:	0018      	movs	r0, r3
 80110a2:	f7f5 ff27 	bl	8006ef4 <lwip_htons>
 80110a6:	0003      	movs	r3, r0
 80110a8:	b2db      	uxtb	r3, r3
 80110aa:	001a      	movs	r2, r3
 80110ac:	2303      	movs	r3, #3
 80110ae:	4013      	ands	r3, r2
 80110b0:	d014      	beq.n	80110dc <tcp_output+0x360>
 80110b2:	2301      	movs	r3, #1
 80110b4:	e013      	b.n	80110de <tcp_output+0x362>
 80110b6:	46c0      	nop			; (mov r8, r8)
 80110b8:	08020a34 	.word	0x08020a34
 80110bc:	000004e2 	.word	0x000004e2
 80110c0:	08021054 	.word	0x08021054
 80110c4:	08020a80 	.word	0x08020a80
 80110c8:	000004e4 	.word	0x000004e4
 80110cc:	0802106c 	.word	0x0802106c
 80110d0:	20002b50 	.word	0x20002b50
 80110d4:	00000537 	.word	0x00000537
 80110d8:	08021094 	.word	0x08021094
 80110dc:	2300      	movs	r3, #0
 80110de:	191b      	adds	r3, r3, r4
 80110e0:	2b00      	cmp	r3, #0
 80110e2:	d06b      	beq.n	80111bc <tcp_output+0x440>
      seg->next = NULL;
 80110e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80110e6:	2200      	movs	r2, #0
 80110e8:	601a      	str	r2, [r3, #0]
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
 80110ea:	687b      	ldr	r3, [r7, #4]
 80110ec:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80110ee:	2b00      	cmp	r3, #0
 80110f0:	d105      	bne.n	80110fe <tcp_output+0x382>
        pcb->unacked = seg;
 80110f2:	687b      	ldr	r3, [r7, #4]
 80110f4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80110f6:	675a      	str	r2, [r3, #116]	; 0x74
        useg = seg;
 80110f8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80110fa:	623b      	str	r3, [r7, #32]
 80110fc:	e062      	b.n	80111c4 <tcp_output+0x448>
        /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(lwip_ntohl(seg->tcphdr->seqno), lwip_ntohl(useg->tcphdr->seqno))) {
 80110fe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011100:	691b      	ldr	r3, [r3, #16]
 8011102:	791a      	ldrb	r2, [r3, #4]
 8011104:	7959      	ldrb	r1, [r3, #5]
 8011106:	0209      	lsls	r1, r1, #8
 8011108:	430a      	orrs	r2, r1
 801110a:	7999      	ldrb	r1, [r3, #6]
 801110c:	0409      	lsls	r1, r1, #16
 801110e:	430a      	orrs	r2, r1
 8011110:	79db      	ldrb	r3, [r3, #7]
 8011112:	061b      	lsls	r3, r3, #24
 8011114:	4313      	orrs	r3, r2
 8011116:	0018      	movs	r0, r3
 8011118:	f7f5 ff02 	bl	8006f20 <lwip_htonl>
 801111c:	0004      	movs	r4, r0
 801111e:	6a3b      	ldr	r3, [r7, #32]
 8011120:	691b      	ldr	r3, [r3, #16]
 8011122:	791a      	ldrb	r2, [r3, #4]
 8011124:	7959      	ldrb	r1, [r3, #5]
 8011126:	0209      	lsls	r1, r1, #8
 8011128:	430a      	orrs	r2, r1
 801112a:	7999      	ldrb	r1, [r3, #6]
 801112c:	0409      	lsls	r1, r1, #16
 801112e:	430a      	orrs	r2, r1
 8011130:	79db      	ldrb	r3, [r3, #7]
 8011132:	061b      	lsls	r3, r3, #24
 8011134:	4313      	orrs	r3, r2
 8011136:	0018      	movs	r0, r3
 8011138:	f7f5 fef2 	bl	8006f20 <lwip_htonl>
 801113c:	0003      	movs	r3, r0
 801113e:	1ae3      	subs	r3, r4, r3
 8011140:	d535      	bpl.n	80111ae <tcp_output+0x432>
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
 8011142:	687b      	ldr	r3, [r7, #4]
 8011144:	3374      	adds	r3, #116	; 0x74
 8011146:	61fb      	str	r3, [r7, #28]
          while (*cur_seg &&
 8011148:	e002      	b.n	8011150 <tcp_output+0x3d4>
                 TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
            cur_seg = &((*cur_seg)->next );
 801114a:	69fb      	ldr	r3, [r7, #28]
 801114c:	681b      	ldr	r3, [r3, #0]
 801114e:	61fb      	str	r3, [r7, #28]
          while (*cur_seg &&
 8011150:	69fb      	ldr	r3, [r7, #28]
 8011152:	681b      	ldr	r3, [r3, #0]
 8011154:	2b00      	cmp	r3, #0
 8011156:	d022      	beq.n	801119e <tcp_output+0x422>
                 TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
 8011158:	69fb      	ldr	r3, [r7, #28]
 801115a:	681b      	ldr	r3, [r3, #0]
 801115c:	691b      	ldr	r3, [r3, #16]
 801115e:	791a      	ldrb	r2, [r3, #4]
 8011160:	7959      	ldrb	r1, [r3, #5]
 8011162:	0209      	lsls	r1, r1, #8
 8011164:	430a      	orrs	r2, r1
 8011166:	7999      	ldrb	r1, [r3, #6]
 8011168:	0409      	lsls	r1, r1, #16
 801116a:	430a      	orrs	r2, r1
 801116c:	79db      	ldrb	r3, [r3, #7]
 801116e:	061b      	lsls	r3, r3, #24
 8011170:	4313      	orrs	r3, r2
 8011172:	0018      	movs	r0, r3
 8011174:	f7f5 fed4 	bl	8006f20 <lwip_htonl>
 8011178:	0004      	movs	r4, r0
 801117a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801117c:	691b      	ldr	r3, [r3, #16]
 801117e:	791a      	ldrb	r2, [r3, #4]
 8011180:	7959      	ldrb	r1, [r3, #5]
 8011182:	0209      	lsls	r1, r1, #8
 8011184:	430a      	orrs	r2, r1
 8011186:	7999      	ldrb	r1, [r3, #6]
 8011188:	0409      	lsls	r1, r1, #16
 801118a:	430a      	orrs	r2, r1
 801118c:	79db      	ldrb	r3, [r3, #7]
 801118e:	061b      	lsls	r3, r3, #24
 8011190:	4313      	orrs	r3, r2
 8011192:	0018      	movs	r0, r3
 8011194:	f7f5 fec4 	bl	8006f20 <lwip_htonl>
 8011198:	0003      	movs	r3, r0
 801119a:	1ae3      	subs	r3, r4, r3
          while (*cur_seg &&
 801119c:	d4d5      	bmi.n	801114a <tcp_output+0x3ce>
          }
          seg->next = (*cur_seg);
 801119e:	69fb      	ldr	r3, [r7, #28]
 80111a0:	681a      	ldr	r2, [r3, #0]
 80111a2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80111a4:	601a      	str	r2, [r3, #0]
          (*cur_seg) = seg;
 80111a6:	69fb      	ldr	r3, [r7, #28]
 80111a8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80111aa:	601a      	str	r2, [r3, #0]
 80111ac:	e00a      	b.n	80111c4 <tcp_output+0x448>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
 80111ae:	6a3b      	ldr	r3, [r7, #32]
 80111b0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80111b2:	601a      	str	r2, [r3, #0]
          useg = useg->next;
 80111b4:	6a3b      	ldr	r3, [r7, #32]
 80111b6:	681b      	ldr	r3, [r3, #0]
 80111b8:	623b      	str	r3, [r7, #32]
 80111ba:	e003      	b.n	80111c4 <tcp_output+0x448>
        }
      }
      /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
 80111bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80111be:	0018      	movs	r0, r3
 80111c0:	f7fa fee8 	bl	800bf94 <tcp_seg_free>
    }
    seg = pcb->unsent;
 80111c4:	687b      	ldr	r3, [r7, #4]
 80111c6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80111c8:	627b      	str	r3, [r7, #36]	; 0x24
  while (seg != NULL &&
 80111ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80111cc:	2b00      	cmp	r3, #0
 80111ce:	d01b      	beq.n	8011208 <tcp_output+0x48c>
         lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
 80111d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80111d2:	691b      	ldr	r3, [r3, #16]
 80111d4:	791a      	ldrb	r2, [r3, #4]
 80111d6:	7959      	ldrb	r1, [r3, #5]
 80111d8:	0209      	lsls	r1, r1, #8
 80111da:	430a      	orrs	r2, r1
 80111dc:	7999      	ldrb	r1, [r3, #6]
 80111de:	0409      	lsls	r1, r1, #16
 80111e0:	430a      	orrs	r2, r1
 80111e2:	79db      	ldrb	r3, [r3, #7]
 80111e4:	061b      	lsls	r3, r3, #24
 80111e6:	4313      	orrs	r3, r2
 80111e8:	0018      	movs	r0, r3
 80111ea:	f7f5 fe99 	bl	8006f20 <lwip_htonl>
 80111ee:	0002      	movs	r2, r0
 80111f0:	687b      	ldr	r3, [r7, #4]
 80111f2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80111f4:	1ad3      	subs	r3, r2, r3
 80111f6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80111f8:	8912      	ldrh	r2, [r2, #8]
 80111fa:	189b      	adds	r3, r3, r2
  while (seg != NULL &&
 80111fc:	69ba      	ldr	r2, [r7, #24]
 80111fe:	429a      	cmp	r2, r3
 8011200:	d300      	bcc.n	8011204 <tcp_output+0x488>
 8011202:	e678      	b.n	8010ef6 <tcp_output+0x17a>
 8011204:	e000      	b.n	8011208 <tcp_output+0x48c>
      break;
 8011206:	46c0      	nop			; (mov r8, r8)
  }
#if TCP_OVERSIZE
  if (pcb->unsent == NULL) {
 8011208:	687b      	ldr	r3, [r7, #4]
 801120a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801120c:	2b00      	cmp	r3, #0
 801120e:	d108      	bne.n	8011222 <tcp_output+0x4a6>
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
 8011210:	687b      	ldr	r3, [r7, #4]
 8011212:	226c      	movs	r2, #108	; 0x6c
 8011214:	2100      	movs	r1, #0
 8011216:	5299      	strh	r1, [r3, r2]
 8011218:	e004      	b.n	8011224 <tcp_output+0x4a8>
    goto output_done;
 801121a:	46c0      	nop			; (mov r8, r8)
 801121c:	e002      	b.n	8011224 <tcp_output+0x4a8>
    goto output_done;
 801121e:	46c0      	nop			; (mov r8, r8)
 8011220:	e000      	b.n	8011224 <tcp_output+0x4a8>
  }
#endif /* TCP_OVERSIZE */

output_done:
 8011222:	46c0      	nop			; (mov r8, r8)
  tcp_clear_flags(pcb, TF_NAGLEMEMERR);
 8011224:	687b      	ldr	r3, [r7, #4]
 8011226:	8bdb      	ldrh	r3, [r3, #30]
 8011228:	2280      	movs	r2, #128	; 0x80
 801122a:	4393      	bics	r3, r2
 801122c:	b29a      	uxth	r2, r3
 801122e:	687b      	ldr	r3, [r7, #4]
 8011230:	83da      	strh	r2, [r3, #30]
  return ERR_OK;
 8011232:	2300      	movs	r3, #0
}
 8011234:	0018      	movs	r0, r3
 8011236:	46bd      	mov	sp, r7
 8011238:	b00a      	add	sp, #40	; 0x28
 801123a:	bdb0      	pop	{r4, r5, r7, pc}

0801123c <tcp_output_segment_busy>:
 * @arg seg the tcp segment to check
 * @return 1 if ref != 1, 0 if ref == 1
 */
static int
tcp_output_segment_busy(const struct tcp_seg *seg)
{
 801123c:	b580      	push	{r7, lr}
 801123e:	b082      	sub	sp, #8
 8011240:	af00      	add	r7, sp, #0
 8011242:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_output_segment_busy: invalid seg", seg != NULL);
 8011244:	687b      	ldr	r3, [r7, #4]
 8011246:	2b00      	cmp	r3, #0
 8011248:	d105      	bne.n	8011256 <tcp_output_segment_busy+0x1a>
 801124a:	4b09      	ldr	r3, [pc, #36]	; (8011270 <tcp_output_segment_busy+0x34>)
 801124c:	4a09      	ldr	r2, [pc, #36]	; (8011274 <tcp_output_segment_busy+0x38>)
 801124e:	490a      	ldr	r1, [pc, #40]	; (8011278 <tcp_output_segment_busy+0x3c>)
 8011250:	480a      	ldr	r0, [pc, #40]	; (801127c <tcp_output_segment_busy+0x40>)
 8011252:	f7f1 fcb9 	bl	8002bc8 <app_debug_rtt_raw>

  /* We only need to check the first pbuf here:
     If a pbuf is queued for transmission, a driver calls pbuf_ref(),
     which only changes the ref count of the first pbuf */
  if (seg->p->ref != 1) {
 8011256:	687b      	ldr	r3, [r7, #4]
 8011258:	685b      	ldr	r3, [r3, #4]
 801125a:	7b9b      	ldrb	r3, [r3, #14]
 801125c:	2b01      	cmp	r3, #1
 801125e:	d001      	beq.n	8011264 <tcp_output_segment_busy+0x28>
    /* other reference found */
    return 1;
 8011260:	2301      	movs	r3, #1
 8011262:	e000      	b.n	8011266 <tcp_output_segment_busy+0x2a>
  }
  /* no other references found */
  return 0;
 8011264:	2300      	movs	r3, #0
}
 8011266:	0018      	movs	r0, r3
 8011268:	46bd      	mov	sp, r7
 801126a:	b002      	add	sp, #8
 801126c:	bd80      	pop	{r7, pc}
 801126e:	46c0      	nop			; (mov r8, r8)
 8011270:	08020a34 	.word	0x08020a34
 8011274:	0000059b 	.word	0x0000059b
 8011278:	080210ac 	.word	0x080210ac
 801127c:	08020a80 	.word	0x08020a80

08011280 <tcp_output_segment>:
 * @param pcb the tcp_pcb for the TCP connection used to send the segment
 * @param netif the netif used to send the segment
 */
static err_t
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb, struct netif *netif)
{
 8011280:	b5f0      	push	{r4, r5, r6, r7, lr}
 8011282:	b08f      	sub	sp, #60	; 0x3c
 8011284:	af04      	add	r7, sp, #16
 8011286:	60f8      	str	r0, [r7, #12]
 8011288:	60b9      	str	r1, [r7, #8]
 801128a:	607a      	str	r2, [r7, #4]
  err_t err;
  u16_t len;
  u32_t *opts;
#if TCP_CHECKSUM_ON_COPY
  int seg_chksum_was_swapped = 0;
 801128c:	2300      	movs	r3, #0
 801128e:	623b      	str	r3, [r7, #32]
#endif

  LWIP_ASSERT("tcp_output_segment: invalid seg", seg != NULL);
 8011290:	68fb      	ldr	r3, [r7, #12]
 8011292:	2b00      	cmp	r3, #0
 8011294:	d105      	bne.n	80112a2 <tcp_output_segment+0x22>
 8011296:	4bda      	ldr	r3, [pc, #872]	; (8011600 <tcp_output_segment+0x380>)
 8011298:	4ada      	ldr	r2, [pc, #872]	; (8011604 <tcp_output_segment+0x384>)
 801129a:	49db      	ldr	r1, [pc, #876]	; (8011608 <tcp_output_segment+0x388>)
 801129c:	48db      	ldr	r0, [pc, #876]	; (801160c <tcp_output_segment+0x38c>)
 801129e:	f7f1 fc93 	bl	8002bc8 <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_output_segment: invalid pcb", pcb != NULL);
 80112a2:	68bb      	ldr	r3, [r7, #8]
 80112a4:	2b00      	cmp	r3, #0
 80112a6:	d105      	bne.n	80112b4 <tcp_output_segment+0x34>
 80112a8:	4bd5      	ldr	r3, [pc, #852]	; (8011600 <tcp_output_segment+0x380>)
 80112aa:	4ad9      	ldr	r2, [pc, #868]	; (8011610 <tcp_output_segment+0x390>)
 80112ac:	49d9      	ldr	r1, [pc, #868]	; (8011614 <tcp_output_segment+0x394>)
 80112ae:	48d7      	ldr	r0, [pc, #860]	; (801160c <tcp_output_segment+0x38c>)
 80112b0:	f7f1 fc8a 	bl	8002bc8 <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_output_segment: invalid netif", netif != NULL);
 80112b4:	687b      	ldr	r3, [r7, #4]
 80112b6:	2b00      	cmp	r3, #0
 80112b8:	d105      	bne.n	80112c6 <tcp_output_segment+0x46>
 80112ba:	4bd1      	ldr	r3, [pc, #836]	; (8011600 <tcp_output_segment+0x380>)
 80112bc:	4ad6      	ldr	r2, [pc, #856]	; (8011618 <tcp_output_segment+0x398>)
 80112be:	49d7      	ldr	r1, [pc, #860]	; (801161c <tcp_output_segment+0x39c>)
 80112c0:	48d2      	ldr	r0, [pc, #840]	; (801160c <tcp_output_segment+0x38c>)
 80112c2:	f7f1 fc81 	bl	8002bc8 <app_debug_rtt_raw>

  if (tcp_output_segment_busy(seg)) {
 80112c6:	68fb      	ldr	r3, [r7, #12]
 80112c8:	0018      	movs	r0, r3
 80112ca:	f7ff ffb7 	bl	801123c <tcp_output_segment_busy>
 80112ce:	1e03      	subs	r3, r0, #0
 80112d0:	d001      	beq.n	80112d6 <tcp_output_segment+0x56>
    /* This should not happen: rexmit functions should have checked this.
       However, since this function modifies p->len, we must not continue in this case. */
    LWIP_DEBUGF(TCP_RTO_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_output_segment: segment busy\n"));
    return ERR_OK;
 80112d2:	2300      	movs	r3, #0
 80112d4:	e190      	b.n	80115f8 <tcp_output_segment+0x378>
  }

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = lwip_htonl(pcb->rcv_nxt);
 80112d6:	68bb      	ldr	r3, [r7, #8]
 80112d8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80112da:	68fb      	ldr	r3, [r7, #12]
 80112dc:	691c      	ldr	r4, [r3, #16]
 80112de:	0010      	movs	r0, r2
 80112e0:	f7f5 fe1e 	bl	8006f20 <lwip_htonl>
 80112e4:	0003      	movs	r3, r0
 80112e6:	22ff      	movs	r2, #255	; 0xff
 80112e8:	401a      	ands	r2, r3
 80112ea:	0010      	movs	r0, r2
 80112ec:	7a22      	ldrb	r2, [r4, #8]
 80112ee:	2100      	movs	r1, #0
 80112f0:	400a      	ands	r2, r1
 80112f2:	1c11      	adds	r1, r2, #0
 80112f4:	1c02      	adds	r2, r0, #0
 80112f6:	430a      	orrs	r2, r1
 80112f8:	7222      	strb	r2, [r4, #8]
 80112fa:	0a1a      	lsrs	r2, r3, #8
 80112fc:	21ff      	movs	r1, #255	; 0xff
 80112fe:	400a      	ands	r2, r1
 8011300:	0010      	movs	r0, r2
 8011302:	7a62      	ldrb	r2, [r4, #9]
 8011304:	2100      	movs	r1, #0
 8011306:	400a      	ands	r2, r1
 8011308:	1c11      	adds	r1, r2, #0
 801130a:	1c02      	adds	r2, r0, #0
 801130c:	430a      	orrs	r2, r1
 801130e:	7262      	strb	r2, [r4, #9]
 8011310:	0c1a      	lsrs	r2, r3, #16
 8011312:	21ff      	movs	r1, #255	; 0xff
 8011314:	400a      	ands	r2, r1
 8011316:	0010      	movs	r0, r2
 8011318:	7aa2      	ldrb	r2, [r4, #10]
 801131a:	2100      	movs	r1, #0
 801131c:	400a      	ands	r2, r1
 801131e:	1c11      	adds	r1, r2, #0
 8011320:	1c02      	adds	r2, r0, #0
 8011322:	430a      	orrs	r2, r1
 8011324:	72a2      	strb	r2, [r4, #10]
 8011326:	0e19      	lsrs	r1, r3, #24
 8011328:	7ae3      	ldrb	r3, [r4, #11]
 801132a:	2200      	movs	r2, #0
 801132c:	4013      	ands	r3, r2
 801132e:	1c1a      	adds	r2, r3, #0
 8011330:	1c0b      	adds	r3, r1, #0
 8011332:	4313      	orrs	r3, r2
 8011334:	72e3      	strb	r3, [r4, #11]
       the window scale option) is never scaled. */
    seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(pcb->rcv_ann_wnd));
  } else
#endif /* LWIP_WND_SCALE */
  {
    seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
 8011336:	68bb      	ldr	r3, [r7, #8]
 8011338:	8dda      	ldrh	r2, [r3, #46]	; 0x2e
 801133a:	68fb      	ldr	r3, [r7, #12]
 801133c:	691c      	ldr	r4, [r3, #16]
 801133e:	0010      	movs	r0, r2
 8011340:	f7f5 fdd8 	bl	8006ef4 <lwip_htons>
 8011344:	0003      	movs	r3, r0
 8011346:	22ff      	movs	r2, #255	; 0xff
 8011348:	401a      	ands	r2, r3
 801134a:	0010      	movs	r0, r2
 801134c:	7ba2      	ldrb	r2, [r4, #14]
 801134e:	2100      	movs	r1, #0
 8011350:	400a      	ands	r2, r1
 8011352:	1c11      	adds	r1, r2, #0
 8011354:	1c02      	adds	r2, r0, #0
 8011356:	430a      	orrs	r2, r1
 8011358:	73a2      	strb	r2, [r4, #14]
 801135a:	0a1b      	lsrs	r3, r3, #8
 801135c:	b299      	uxth	r1, r3
 801135e:	7be3      	ldrb	r3, [r4, #15]
 8011360:	2200      	movs	r2, #0
 8011362:	4013      	ands	r3, r2
 8011364:	1c1a      	adds	r2, r3, #0
 8011366:	1c0b      	adds	r3, r1, #0
 8011368:	4313      	orrs	r3, r2
 801136a:	73e3      	strb	r3, [r4, #15]
  }

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 801136c:	68bb      	ldr	r3, [r7, #8]
 801136e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8011370:	68ba      	ldr	r2, [r7, #8]
 8011372:	8dd2      	ldrh	r2, [r2, #46]	; 0x2e
 8011374:	189a      	adds	r2, r3, r2
 8011376:	68bb      	ldr	r3, [r7, #8]
 8011378:	631a      	str	r2, [r3, #48]	; 0x30

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  /* cast through void* to get rid of alignment warnings */
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
 801137a:	68fb      	ldr	r3, [r7, #12]
 801137c:	691b      	ldr	r3, [r3, #16]
 801137e:	3314      	adds	r3, #20
 8011380:	627b      	str	r3, [r7, #36]	; 0x24
  if (seg->flags & TF_SEG_OPTS_MSS) {
 8011382:	68fb      	ldr	r3, [r7, #12]
 8011384:	7bdb      	ldrb	r3, [r3, #15]
 8011386:	001a      	movs	r2, r3
 8011388:	2301      	movs	r3, #1
 801138a:	4013      	ands	r3, r2
 801138c:	d019      	beq.n	80113c2 <tcp_output_segment+0x142>
    u16_t mss;
#if TCP_CALCULATE_EFF_SEND_MSS
    mss = tcp_eff_send_mss_netif(TCP_MSS, netif, &pcb->remote_ip);
 801138e:	68bb      	ldr	r3, [r7, #8]
 8011390:	1d1a      	adds	r2, r3, #4
 8011392:	251e      	movs	r5, #30
 8011394:	197c      	adds	r4, r7, r5
 8011396:	6879      	ldr	r1, [r7, #4]
 8011398:	2386      	movs	r3, #134	; 0x86
 801139a:	009b      	lsls	r3, r3, #2
 801139c:	0018      	movs	r0, r3
 801139e:	f7fb f9cb 	bl	800c738 <tcp_eff_send_mss_netif>
 80113a2:	0003      	movs	r3, r0
 80113a4:	8023      	strh	r3, [r4, #0]
#else /* TCP_CALCULATE_EFF_SEND_MSS */
    mss = TCP_MSS;
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
    *opts = TCP_BUILD_MSS_OPTION(mss);
 80113a6:	197b      	adds	r3, r7, r5
 80113a8:	881b      	ldrh	r3, [r3, #0]
 80113aa:	2281      	movs	r2, #129	; 0x81
 80113ac:	0492      	lsls	r2, r2, #18
 80113ae:	4313      	orrs	r3, r2
 80113b0:	0018      	movs	r0, r3
 80113b2:	f7f5 fdb5 	bl	8006f20 <lwip_htonl>
 80113b6:	0002      	movs	r2, r0
 80113b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80113ba:	601a      	str	r2, [r3, #0]
    opts += 1;
 80113bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80113be:	3304      	adds	r3, #4
 80113c0:	627b      	str	r3, [r7, #36]	; 0x24
  }
#endif

  /* Set retransmission timer running if it is not currently enabled
     This must be set before checking the route. */
  if (pcb->rtime < 0) {
 80113c2:	68bb      	ldr	r3, [r7, #8]
 80113c4:	2234      	movs	r2, #52	; 0x34
 80113c6:	5e9b      	ldrsh	r3, [r3, r2]
 80113c8:	2b00      	cmp	r3, #0
 80113ca:	da02      	bge.n	80113d2 <tcp_output_segment+0x152>
    pcb->rtime = 0;
 80113cc:	68bb      	ldr	r3, [r7, #8]
 80113ce:	2200      	movs	r2, #0
 80113d0:	869a      	strh	r2, [r3, #52]	; 0x34
  }

  if (pcb->rttest == 0) {
 80113d2:	68bb      	ldr	r3, [r7, #8]
 80113d4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80113d6:	2b00      	cmp	r3, #0
 80113d8:	d115      	bne.n	8011406 <tcp_output_segment+0x186>
    pcb->rttest = tcp_ticks;
 80113da:	4b91      	ldr	r3, [pc, #580]	; (8011620 <tcp_output_segment+0x3a0>)
 80113dc:	681a      	ldr	r2, [r3, #0]
 80113de:	68bb      	ldr	r3, [r7, #8]
 80113e0:	639a      	str	r2, [r3, #56]	; 0x38
    pcb->rtseq = lwip_ntohl(seg->tcphdr->seqno);
 80113e2:	68fb      	ldr	r3, [r7, #12]
 80113e4:	691b      	ldr	r3, [r3, #16]
 80113e6:	791a      	ldrb	r2, [r3, #4]
 80113e8:	7959      	ldrb	r1, [r3, #5]
 80113ea:	0209      	lsls	r1, r1, #8
 80113ec:	430a      	orrs	r2, r1
 80113ee:	7999      	ldrb	r1, [r3, #6]
 80113f0:	0409      	lsls	r1, r1, #16
 80113f2:	430a      	orrs	r2, r1
 80113f4:	79db      	ldrb	r3, [r3, #7]
 80113f6:	061b      	lsls	r3, r3, #24
 80113f8:	4313      	orrs	r3, r2
 80113fa:	0018      	movs	r0, r3
 80113fc:	f7f5 fd90 	bl	8006f20 <lwip_htonl>
 8011400:	0002      	movs	r2, r0
 8011402:	68bb      	ldr	r3, [r7, #8]
 8011404:	63da      	str	r2, [r3, #60]	; 0x3c
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
                                 lwip_htonl(seg->tcphdr->seqno), lwip_htonl(seg->tcphdr->seqno) +
                                 seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 8011406:	68fb      	ldr	r3, [r7, #12]
 8011408:	691a      	ldr	r2, [r3, #16]
 801140a:	68fb      	ldr	r3, [r7, #12]
 801140c:	685b      	ldr	r3, [r3, #4]
 801140e:	685b      	ldr	r3, [r3, #4]
 8011410:	1ad2      	subs	r2, r2, r3
 8011412:	201c      	movs	r0, #28
 8011414:	183b      	adds	r3, r7, r0
 8011416:	801a      	strh	r2, [r3, #0]
  if (len == 0) {
    /** Exclude retransmitted segments from this count. */
    MIB2_STATS_INC(mib2.tcpoutsegs);
  }

  seg->p->len -= len;
 8011418:	68fb      	ldr	r3, [r7, #12]
 801141a:	685b      	ldr	r3, [r3, #4]
 801141c:	8959      	ldrh	r1, [r3, #10]
 801141e:	68fb      	ldr	r3, [r7, #12]
 8011420:	685b      	ldr	r3, [r3, #4]
 8011422:	183a      	adds	r2, r7, r0
 8011424:	8812      	ldrh	r2, [r2, #0]
 8011426:	1a8a      	subs	r2, r1, r2
 8011428:	b292      	uxth	r2, r2
 801142a:	815a      	strh	r2, [r3, #10]
  seg->p->tot_len -= len;
 801142c:	68fb      	ldr	r3, [r7, #12]
 801142e:	685b      	ldr	r3, [r3, #4]
 8011430:	8919      	ldrh	r1, [r3, #8]
 8011432:	68fb      	ldr	r3, [r7, #12]
 8011434:	685b      	ldr	r3, [r3, #4]
 8011436:	183a      	adds	r2, r7, r0
 8011438:	8812      	ldrh	r2, [r2, #0]
 801143a:	1a8a      	subs	r2, r1, r2
 801143c:	b292      	uxth	r2, r2
 801143e:	811a      	strh	r2, [r3, #8]

  seg->p->payload = seg->tcphdr;
 8011440:	68fb      	ldr	r3, [r7, #12]
 8011442:	685b      	ldr	r3, [r3, #4]
 8011444:	68fa      	ldr	r2, [r7, #12]
 8011446:	6912      	ldr	r2, [r2, #16]
 8011448:	605a      	str	r2, [r3, #4]

  seg->tcphdr->chksum = 0;
 801144a:	68fb      	ldr	r3, [r7, #12]
 801144c:	691b      	ldr	r3, [r3, #16]
 801144e:	7c1a      	ldrb	r2, [r3, #16]
 8011450:	2100      	movs	r1, #0
 8011452:	400a      	ands	r2, r1
 8011454:	741a      	strb	r2, [r3, #16]
 8011456:	7c5a      	ldrb	r2, [r3, #17]
 8011458:	2100      	movs	r1, #0
 801145a:	400a      	ands	r2, r1
 801145c:	745a      	strb	r2, [r3, #17]

#ifdef LWIP_HOOK_TCP_OUT_ADD_TCPOPTS
  opts = LWIP_HOOK_TCP_OUT_ADD_TCPOPTS(seg->p, seg->tcphdr, pcb, opts);
#endif
  LWIP_ASSERT("options not filled", (u8_t *)opts == ((u8_t *)(seg->tcphdr + 1)) + LWIP_TCP_OPT_LENGTH_SEGMENT(seg->flags, pcb));
 801145e:	68fb      	ldr	r3, [r7, #12]
 8011460:	691b      	ldr	r3, [r3, #16]
 8011462:	3314      	adds	r3, #20
 8011464:	001a      	movs	r2, r3
 8011466:	68fb      	ldr	r3, [r7, #12]
 8011468:	7bdb      	ldrb	r3, [r3, #15]
 801146a:	009b      	lsls	r3, r3, #2
 801146c:	2104      	movs	r1, #4
 801146e:	400b      	ands	r3, r1
 8011470:	18d3      	adds	r3, r2, r3
 8011472:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8011474:	429a      	cmp	r2, r3
 8011476:	d005      	beq.n	8011484 <tcp_output_segment+0x204>
 8011478:	4b61      	ldr	r3, [pc, #388]	; (8011600 <tcp_output_segment+0x380>)
 801147a:	4a6a      	ldr	r2, [pc, #424]	; (8011624 <tcp_output_segment+0x3a4>)
 801147c:	496a      	ldr	r1, [pc, #424]	; (8011628 <tcp_output_segment+0x3a8>)
 801147e:	4863      	ldr	r0, [pc, #396]	; (801160c <tcp_output_segment+0x38c>)
 8011480:	f7f1 fba2 	bl	8002bc8 <app_debug_rtt_raw>
    u32_t acc;
#if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
    u16_t chksum_slow = ip_chksum_pseudo(seg->p, IP_PROTO_TCP,
                                         seg->p->tot_len, &pcb->local_ip, &pcb->remote_ip);
#endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
    if ((seg->flags & TF_SEG_DATA_CHECKSUMMED) == 0) {
 8011484:	68fb      	ldr	r3, [r7, #12]
 8011486:	7bdb      	ldrb	r3, [r3, #15]
 8011488:	001a      	movs	r2, r3
 801148a:	2304      	movs	r3, #4
 801148c:	4013      	ands	r3, r2
 801148e:	d11c      	bne.n	80114ca <tcp_output_segment+0x24a>
      LWIP_ASSERT("data included but not checksummed",
 8011490:	68fb      	ldr	r3, [r7, #12]
 8011492:	685b      	ldr	r3, [r3, #4]
 8011494:	891c      	ldrh	r4, [r3, #8]
 8011496:	68fb      	ldr	r3, [r7, #12]
 8011498:	691b      	ldr	r3, [r3, #16]
 801149a:	7b1a      	ldrb	r2, [r3, #12]
 801149c:	7b5b      	ldrb	r3, [r3, #13]
 801149e:	021b      	lsls	r3, r3, #8
 80114a0:	4313      	orrs	r3, r2
 80114a2:	b29b      	uxth	r3, r3
 80114a4:	0018      	movs	r0, r3
 80114a6:	f7f5 fd25 	bl	8006ef4 <lwip_htons>
 80114aa:	0003      	movs	r3, r0
 80114ac:	0b1b      	lsrs	r3, r3, #12
 80114ae:	b29b      	uxth	r3, r3
 80114b0:	b2db      	uxtb	r3, r3
 80114b2:	009b      	lsls	r3, r3, #2
 80114b4:	b2db      	uxtb	r3, r3
 80114b6:	b29b      	uxth	r3, r3
 80114b8:	429c      	cmp	r4, r3
 80114ba:	d006      	beq.n	80114ca <tcp_output_segment+0x24a>
 80114bc:	4b50      	ldr	r3, [pc, #320]	; (8011600 <tcp_output_segment+0x380>)
 80114be:	22c5      	movs	r2, #197	; 0xc5
 80114c0:	00d2      	lsls	r2, r2, #3
 80114c2:	495a      	ldr	r1, [pc, #360]	; (801162c <tcp_output_segment+0x3ac>)
 80114c4:	4851      	ldr	r0, [pc, #324]	; (801160c <tcp_output_segment+0x38c>)
 80114c6:	f7f1 fb7f 	bl	8002bc8 <app_debug_rtt_raw>
                  seg->p->tot_len == TCPH_HDRLEN_BYTES(seg->tcphdr));
    }

    /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
    acc = ip_chksum_pseudo_partial(seg->p, IP_PROTO_TCP,
 80114ca:	68fb      	ldr	r3, [r7, #12]
 80114cc:	685c      	ldr	r4, [r3, #4]
                                   seg->p->tot_len, TCPH_HDRLEN_BYTES(seg->tcphdr), &pcb->local_ip, &pcb->remote_ip);
 80114ce:	68fb      	ldr	r3, [r7, #12]
 80114d0:	685b      	ldr	r3, [r3, #4]
    acc = ip_chksum_pseudo_partial(seg->p, IP_PROTO_TCP,
 80114d2:	891d      	ldrh	r5, [r3, #8]
                                   seg->p->tot_len, TCPH_HDRLEN_BYTES(seg->tcphdr), &pcb->local_ip, &pcb->remote_ip);
 80114d4:	68fb      	ldr	r3, [r7, #12]
 80114d6:	691b      	ldr	r3, [r3, #16]
 80114d8:	7b1a      	ldrb	r2, [r3, #12]
 80114da:	7b5b      	ldrb	r3, [r3, #13]
 80114dc:	021b      	lsls	r3, r3, #8
 80114de:	4313      	orrs	r3, r2
 80114e0:	b29b      	uxth	r3, r3
 80114e2:	0018      	movs	r0, r3
 80114e4:	f7f5 fd06 	bl	8006ef4 <lwip_htons>
 80114e8:	0003      	movs	r3, r0
 80114ea:	0b1b      	lsrs	r3, r3, #12
 80114ec:	b29b      	uxth	r3, r3
 80114ee:	b2db      	uxtb	r3, r3
 80114f0:	009b      	lsls	r3, r3, #2
 80114f2:	b2db      	uxtb	r3, r3
    acc = ip_chksum_pseudo_partial(seg->p, IP_PROTO_TCP,
 80114f4:	b299      	uxth	r1, r3
                                   seg->p->tot_len, TCPH_HDRLEN_BYTES(seg->tcphdr), &pcb->local_ip, &pcb->remote_ip);
 80114f6:	68bb      	ldr	r3, [r7, #8]
 80114f8:	68ba      	ldr	r2, [r7, #8]
 80114fa:	3204      	adds	r2, #4
    acc = ip_chksum_pseudo_partial(seg->p, IP_PROTO_TCP,
 80114fc:	9201      	str	r2, [sp, #4]
 80114fe:	9300      	str	r3, [sp, #0]
 8011500:	000b      	movs	r3, r1
 8011502:	002a      	movs	r2, r5
 8011504:	2106      	movs	r1, #6
 8011506:	0020      	movs	r0, r4
 8011508:	f7f7 f895 	bl	8008636 <ip_chksum_pseudo_partial>
 801150c:	0003      	movs	r3, r0
 801150e:	61bb      	str	r3, [r7, #24]
    /* add payload checksum */
    if (seg->chksum_swapped) {
 8011510:	68fb      	ldr	r3, [r7, #12]
 8011512:	7b9b      	ldrb	r3, [r3, #14]
 8011514:	2b00      	cmp	r3, #0
 8011516:	d012      	beq.n	801153e <tcp_output_segment+0x2be>
      seg_chksum_was_swapped = 1;
 8011518:	2301      	movs	r3, #1
 801151a:	623b      	str	r3, [r7, #32]
      seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
 801151c:	68fb      	ldr	r3, [r7, #12]
 801151e:	899b      	ldrh	r3, [r3, #12]
 8011520:	021b      	lsls	r3, r3, #8
 8011522:	b21a      	sxth	r2, r3
 8011524:	68fb      	ldr	r3, [r7, #12]
 8011526:	899b      	ldrh	r3, [r3, #12]
 8011528:	0a1b      	lsrs	r3, r3, #8
 801152a:	b29b      	uxth	r3, r3
 801152c:	b21b      	sxth	r3, r3
 801152e:	4313      	orrs	r3, r2
 8011530:	b21b      	sxth	r3, r3
 8011532:	b29a      	uxth	r2, r3
 8011534:	68fb      	ldr	r3, [r7, #12]
 8011536:	819a      	strh	r2, [r3, #12]
      seg->chksum_swapped = 0;
 8011538:	68fb      	ldr	r3, [r7, #12]
 801153a:	2200      	movs	r2, #0
 801153c:	739a      	strb	r2, [r3, #14]
    }
    acc = (u16_t)~acc + seg->chksum;
 801153e:	69bb      	ldr	r3, [r7, #24]
 8011540:	b29b      	uxth	r3, r3
 8011542:	43db      	mvns	r3, r3
 8011544:	b29b      	uxth	r3, r3
 8011546:	001a      	movs	r2, r3
 8011548:	68fb      	ldr	r3, [r7, #12]
 801154a:	899b      	ldrh	r3, [r3, #12]
 801154c:	18d3      	adds	r3, r2, r3
 801154e:	61bb      	str	r3, [r7, #24]
    seg->tcphdr->chksum = (u16_t)~FOLD_U32T(acc);
 8011550:	69bb      	ldr	r3, [r7, #24]
 8011552:	0c1b      	lsrs	r3, r3, #16
 8011554:	b29a      	uxth	r2, r3
 8011556:	69bb      	ldr	r3, [r7, #24]
 8011558:	b29b      	uxth	r3, r3
 801155a:	18d3      	adds	r3, r2, r3
 801155c:	b29a      	uxth	r2, r3
 801155e:	68fb      	ldr	r3, [r7, #12]
 8011560:	691b      	ldr	r3, [r3, #16]
 8011562:	43d2      	mvns	r2, r2
 8011564:	b292      	uxth	r2, r2
 8011566:	21ff      	movs	r1, #255	; 0xff
 8011568:	4011      	ands	r1, r2
 801156a:	000c      	movs	r4, r1
 801156c:	7c19      	ldrb	r1, [r3, #16]
 801156e:	2000      	movs	r0, #0
 8011570:	4001      	ands	r1, r0
 8011572:	1c08      	adds	r0, r1, #0
 8011574:	1c21      	adds	r1, r4, #0
 8011576:	4301      	orrs	r1, r0
 8011578:	7419      	strb	r1, [r3, #16]
 801157a:	0a12      	lsrs	r2, r2, #8
 801157c:	b290      	uxth	r0, r2
 801157e:	7c5a      	ldrb	r2, [r3, #17]
 8011580:	2100      	movs	r1, #0
 8011582:	400a      	ands	r2, r1
 8011584:	1c11      	adds	r1, r2, #0
 8011586:	1c02      	adds	r2, r0, #0
 8011588:	430a      	orrs	r2, r1
 801158a:	745a      	strb	r2, [r3, #17]
#endif /* TCP_CHECKSUM_ON_COPY */
  }
#endif /* CHECKSUM_GEN_TCP */
  TCP_STATS_INC(tcp.xmit);

  NETIF_SET_HINTS(netif, &(pcb->netif_hints));
 801158c:	68bb      	ldr	r3, [r7, #8]
 801158e:	330c      	adds	r3, #12
 8011590:	001a      	movs	r2, r3
 8011592:	687b      	ldr	r3, [r7, #4]
 8011594:	639a      	str	r2, [r3, #56]	; 0x38
  err = ip_output_if(seg->p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
 8011596:	68fb      	ldr	r3, [r7, #12]
 8011598:	6858      	ldr	r0, [r3, #4]
 801159a:	68b9      	ldr	r1, [r7, #8]
 801159c:	68bb      	ldr	r3, [r7, #8]
 801159e:	1d1d      	adds	r5, r3, #4
 80115a0:	68bb      	ldr	r3, [r7, #8]
 80115a2:	7ade      	ldrb	r6, [r3, #11]
 80115a4:	68bb      	ldr	r3, [r7, #8]
 80115a6:	7a9b      	ldrb	r3, [r3, #10]
 80115a8:	2217      	movs	r2, #23
 80115aa:	18bc      	adds	r4, r7, r2
 80115ac:	687a      	ldr	r2, [r7, #4]
 80115ae:	9202      	str	r2, [sp, #8]
 80115b0:	2206      	movs	r2, #6
 80115b2:	9201      	str	r2, [sp, #4]
 80115b4:	9300      	str	r3, [sp, #0]
 80115b6:	0033      	movs	r3, r6
 80115b8:	002a      	movs	r2, r5
 80115ba:	f002 fa09 	bl	80139d0 <ip4_output_if>
 80115be:	0003      	movs	r3, r0
 80115c0:	7023      	strb	r3, [r4, #0]
                     pcb->tos, IP_PROTO_TCP, netif);
  NETIF_RESET_HINTS(netif);
 80115c2:	687b      	ldr	r3, [r7, #4]
 80115c4:	2200      	movs	r2, #0
 80115c6:	639a      	str	r2, [r3, #56]	; 0x38

#if TCP_CHECKSUM_ON_COPY
  if (seg_chksum_was_swapped) {
 80115c8:	6a3b      	ldr	r3, [r7, #32]
 80115ca:	2b00      	cmp	r3, #0
 80115cc:	d010      	beq.n	80115f0 <tcp_output_segment+0x370>
    /* if data is added to this segment later, chksum needs to be swapped,
       so restore this now */
    seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
 80115ce:	68fb      	ldr	r3, [r7, #12]
 80115d0:	899b      	ldrh	r3, [r3, #12]
 80115d2:	021b      	lsls	r3, r3, #8
 80115d4:	b21a      	sxth	r2, r3
 80115d6:	68fb      	ldr	r3, [r7, #12]
 80115d8:	899b      	ldrh	r3, [r3, #12]
 80115da:	0a1b      	lsrs	r3, r3, #8
 80115dc:	b29b      	uxth	r3, r3
 80115de:	b21b      	sxth	r3, r3
 80115e0:	4313      	orrs	r3, r2
 80115e2:	b21b      	sxth	r3, r3
 80115e4:	b29a      	uxth	r2, r3
 80115e6:	68fb      	ldr	r3, [r7, #12]
 80115e8:	819a      	strh	r2, [r3, #12]
    seg->chksum_swapped = 1;
 80115ea:	68fb      	ldr	r3, [r7, #12]
 80115ec:	2201      	movs	r2, #1
 80115ee:	739a      	strb	r2, [r3, #14]
  }
#endif

  return err;
 80115f0:	2317      	movs	r3, #23
 80115f2:	18fb      	adds	r3, r7, r3
 80115f4:	781b      	ldrb	r3, [r3, #0]
 80115f6:	b25b      	sxtb	r3, r3
}
 80115f8:	0018      	movs	r0, r3
 80115fa:	46bd      	mov	sp, r7
 80115fc:	b00b      	add	sp, #44	; 0x2c
 80115fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8011600:	08020a34 	.word	0x08020a34
 8011604:	000005b9 	.word	0x000005b9
 8011608:	080210d4 	.word	0x080210d4
 801160c:	08020a80 	.word	0x08020a80
 8011610:	000005ba 	.word	0x000005ba
 8011614:	080210f4 	.word	0x080210f4
 8011618:	000005bb 	.word	0x000005bb
 801161c:	08021114 	.word	0x08021114
 8011620:	20002b40 	.word	0x20002b40
 8011624:	0000061d 	.word	0x0000061d
 8011628:	08021138 	.word	0x08021138
 801162c:	0802114c 	.word	0x0802114c

08011630 <tcp_rexmit_rto_prepare>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
err_t
tcp_rexmit_rto_prepare(struct tcp_pcb *pcb)
{
 8011630:	b5b0      	push	{r4, r5, r7, lr}
 8011632:	b084      	sub	sp, #16
 8011634:	af00      	add	r7, sp, #0
 8011636:	6078      	str	r0, [r7, #4]
  struct tcp_seg *seg;

  LWIP_ASSERT("tcp_rexmit_rto_prepare: invalid pcb", pcb != NULL);
 8011638:	687b      	ldr	r3, [r7, #4]
 801163a:	2b00      	cmp	r3, #0
 801163c:	d105      	bne.n	801164a <tcp_rexmit_rto_prepare+0x1a>
 801163e:	4b3c      	ldr	r3, [pc, #240]	; (8011730 <tcp_rexmit_rto_prepare+0x100>)
 8011640:	4a3c      	ldr	r2, [pc, #240]	; (8011734 <tcp_rexmit_rto_prepare+0x104>)
 8011642:	493d      	ldr	r1, [pc, #244]	; (8011738 <tcp_rexmit_rto_prepare+0x108>)
 8011644:	483d      	ldr	r0, [pc, #244]	; (801173c <tcp_rexmit_rto_prepare+0x10c>)
 8011646:	f7f1 fabf 	bl	8002bc8 <app_debug_rtt_raw>

  if (pcb->unacked == NULL) {
 801164a:	687b      	ldr	r3, [r7, #4]
 801164c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 801164e:	2b00      	cmp	r3, #0
 8011650:	d102      	bne.n	8011658 <tcp_rexmit_rto_prepare+0x28>
    return ERR_VAL;
 8011652:	2306      	movs	r3, #6
 8011654:	425b      	negs	r3, r3
 8011656:	e066      	b.n	8011726 <tcp_rexmit_rto_prepare+0xf6>

  /* Move all unacked segments to the head of the unsent queue.
     However, give up if any of the unsent pbufs are still referenced by the
     netif driver due to deferred transmission. No point loading the link further
     if it is struggling to flush its buffered writes. */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next) {
 8011658:	687b      	ldr	r3, [r7, #4]
 801165a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 801165c:	60fb      	str	r3, [r7, #12]
 801165e:	e00b      	b.n	8011678 <tcp_rexmit_rto_prepare+0x48>
    if (tcp_output_segment_busy(seg)) {
 8011660:	68fb      	ldr	r3, [r7, #12]
 8011662:	0018      	movs	r0, r3
 8011664:	f7ff fdea 	bl	801123c <tcp_output_segment_busy>
 8011668:	1e03      	subs	r3, r0, #0
 801166a:	d002      	beq.n	8011672 <tcp_rexmit_rto_prepare+0x42>
      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_rexmit_rto: segment busy\n"));
      return ERR_VAL;
 801166c:	2306      	movs	r3, #6
 801166e:	425b      	negs	r3, r3
 8011670:	e059      	b.n	8011726 <tcp_rexmit_rto_prepare+0xf6>
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next) {
 8011672:	68fb      	ldr	r3, [r7, #12]
 8011674:	681b      	ldr	r3, [r3, #0]
 8011676:	60fb      	str	r3, [r7, #12]
 8011678:	68fb      	ldr	r3, [r7, #12]
 801167a:	681b      	ldr	r3, [r3, #0]
 801167c:	2b00      	cmp	r3, #0
 801167e:	d1ef      	bne.n	8011660 <tcp_rexmit_rto_prepare+0x30>
    }
  }
  if (tcp_output_segment_busy(seg)) {
 8011680:	68fb      	ldr	r3, [r7, #12]
 8011682:	0018      	movs	r0, r3
 8011684:	f7ff fdda 	bl	801123c <tcp_output_segment_busy>
 8011688:	1e03      	subs	r3, r0, #0
 801168a:	d002      	beq.n	8011692 <tcp_rexmit_rto_prepare+0x62>
    LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_rexmit_rto: segment busy\n"));
    return ERR_VAL;
 801168c:	2306      	movs	r3, #6
 801168e:	425b      	negs	r3, r3
 8011690:	e049      	b.n	8011726 <tcp_rexmit_rto_prepare+0xf6>
  }
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
 8011692:	687b      	ldr	r3, [r7, #4]
 8011694:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8011696:	68fb      	ldr	r3, [r7, #12]
 8011698:	601a      	str	r2, [r3, #0]
#if TCP_OVERSIZE_DBGCHECK
  /* if last unsent changed, we need to update unsent_oversize */
  if (pcb->unsent == NULL) {
 801169a:	687b      	ldr	r3, [r7, #4]
 801169c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801169e:	2b00      	cmp	r3, #0
 80116a0:	d104      	bne.n	80116ac <tcp_rexmit_rto_prepare+0x7c>
    pcb->unsent_oversize = seg->oversize_left;
 80116a2:	68fb      	ldr	r3, [r7, #12]
 80116a4:	8959      	ldrh	r1, [r3, #10]
 80116a6:	687b      	ldr	r3, [r7, #4]
 80116a8:	226c      	movs	r2, #108	; 0x6c
 80116aa:	5299      	strh	r1, [r3, r2]
  }
#endif /* TCP_OVERSIZE_DBGCHECK */
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
 80116ac:	687b      	ldr	r3, [r7, #4]
 80116ae:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 80116b0:	687b      	ldr	r3, [r7, #4]
 80116b2:	671a      	str	r2, [r3, #112]	; 0x70
  /* unacked queue is now empty */
  pcb->unacked = NULL;
 80116b4:	687b      	ldr	r3, [r7, #4]
 80116b6:	2200      	movs	r2, #0
 80116b8:	675a      	str	r2, [r3, #116]	; 0x74

  /* Mark RTO in-progress */
  tcp_set_flags(pcb, TF_RTO);
 80116ba:	687b      	ldr	r3, [r7, #4]
 80116bc:	8bdb      	ldrh	r3, [r3, #30]
 80116be:	2280      	movs	r2, #128	; 0x80
 80116c0:	0112      	lsls	r2, r2, #4
 80116c2:	4313      	orrs	r3, r2
 80116c4:	b29a      	uxth	r2, r3
 80116c6:	687b      	ldr	r3, [r7, #4]
 80116c8:	83da      	strh	r2, [r3, #30]
  /* Record the next byte following retransmit */
  pcb->rto_end = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 80116ca:	68fb      	ldr	r3, [r7, #12]
 80116cc:	691b      	ldr	r3, [r3, #16]
 80116ce:	791a      	ldrb	r2, [r3, #4]
 80116d0:	7959      	ldrb	r1, [r3, #5]
 80116d2:	0209      	lsls	r1, r1, #8
 80116d4:	430a      	orrs	r2, r1
 80116d6:	7999      	ldrb	r1, [r3, #6]
 80116d8:	0409      	lsls	r1, r1, #16
 80116da:	430a      	orrs	r2, r1
 80116dc:	79db      	ldrb	r3, [r3, #7]
 80116de:	061b      	lsls	r3, r3, #24
 80116e0:	4313      	orrs	r3, r2
 80116e2:	0018      	movs	r0, r3
 80116e4:	f7f5 fc1c 	bl	8006f20 <lwip_htonl>
 80116e8:	0004      	movs	r4, r0
 80116ea:	68fb      	ldr	r3, [r7, #12]
 80116ec:	891b      	ldrh	r3, [r3, #8]
 80116ee:	001d      	movs	r5, r3
 80116f0:	68fb      	ldr	r3, [r7, #12]
 80116f2:	691b      	ldr	r3, [r3, #16]
 80116f4:	7b1a      	ldrb	r2, [r3, #12]
 80116f6:	7b5b      	ldrb	r3, [r3, #13]
 80116f8:	021b      	lsls	r3, r3, #8
 80116fa:	4313      	orrs	r3, r2
 80116fc:	b29b      	uxth	r3, r3
 80116fe:	0018      	movs	r0, r3
 8011700:	f7f5 fbf8 	bl	8006ef4 <lwip_htons>
 8011704:	0003      	movs	r3, r0
 8011706:	b2db      	uxtb	r3, r3
 8011708:	001a      	movs	r2, r3
 801170a:	2303      	movs	r3, #3
 801170c:	4013      	ands	r3, r2
 801170e:	d001      	beq.n	8011714 <tcp_rexmit_rto_prepare+0xe4>
 8011710:	2301      	movs	r3, #1
 8011712:	e000      	b.n	8011716 <tcp_rexmit_rto_prepare+0xe6>
 8011714:	2300      	movs	r3, #0
 8011716:	195b      	adds	r3, r3, r5
 8011718:	18e2      	adds	r2, r4, r3
 801171a:	687b      	ldr	r3, [r7, #4]
 801171c:	651a      	str	r2, [r3, #80]	; 0x50
  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
 801171e:	687b      	ldr	r3, [r7, #4]
 8011720:	2200      	movs	r2, #0
 8011722:	639a      	str	r2, [r3, #56]	; 0x38

  return ERR_OK;
 8011724:	2300      	movs	r3, #0
}
 8011726:	0018      	movs	r0, r3
 8011728:	46bd      	mov	sp, r7
 801172a:	b004      	add	sp, #16
 801172c:	bdb0      	pop	{r4, r5, r7, pc}
 801172e:	46c0      	nop			; (mov r8, r8)
 8011730:	08020a34 	.word	0x08020a34
 8011734:	00000664 	.word	0x00000664
 8011738:	08021170 	.word	0x08021170
 801173c:	08020a80 	.word	0x08020a80

08011740 <tcp_rexmit_rto_commit>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto_commit(struct tcp_pcb *pcb)
{
 8011740:	b580      	push	{r7, lr}
 8011742:	b082      	sub	sp, #8
 8011744:	af00      	add	r7, sp, #0
 8011746:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_rexmit_rto_commit: invalid pcb", pcb != NULL);
 8011748:	687b      	ldr	r3, [r7, #4]
 801174a:	2b00      	cmp	r3, #0
 801174c:	d105      	bne.n	801175a <tcp_rexmit_rto_commit+0x1a>
 801174e:	4b0d      	ldr	r3, [pc, #52]	; (8011784 <tcp_rexmit_rto_commit+0x44>)
 8011750:	4a0d      	ldr	r2, [pc, #52]	; (8011788 <tcp_rexmit_rto_commit+0x48>)
 8011752:	490e      	ldr	r1, [pc, #56]	; (801178c <tcp_rexmit_rto_commit+0x4c>)
 8011754:	480e      	ldr	r0, [pc, #56]	; (8011790 <tcp_rexmit_rto_commit+0x50>)
 8011756:	f7f1 fa37 	bl	8002bc8 <app_debug_rtt_raw>

  /* increment number of retransmissions */
  if (pcb->nrtx < 0xFF) {
 801175a:	687b      	ldr	r3, [r7, #4]
 801175c:	2246      	movs	r2, #70	; 0x46
 801175e:	5c9b      	ldrb	r3, [r3, r2]
 8011760:	2bff      	cmp	r3, #255	; 0xff
 8011762:	d007      	beq.n	8011774 <tcp_rexmit_rto_commit+0x34>
    ++pcb->nrtx;
 8011764:	687b      	ldr	r3, [r7, #4]
 8011766:	2246      	movs	r2, #70	; 0x46
 8011768:	5c9b      	ldrb	r3, [r3, r2]
 801176a:	3301      	adds	r3, #1
 801176c:	b2d9      	uxtb	r1, r3
 801176e:	687b      	ldr	r3, [r7, #4]
 8011770:	2246      	movs	r2, #70	; 0x46
 8011772:	5499      	strb	r1, [r3, r2]
  }
  /* Do the actual retransmission */
  tcp_output(pcb);
 8011774:	687b      	ldr	r3, [r7, #4]
 8011776:	0018      	movs	r0, r3
 8011778:	f7ff fb00 	bl	8010d7c <tcp_output>
}
 801177c:	46c0      	nop			; (mov r8, r8)
 801177e:	46bd      	mov	sp, r7
 8011780:	b002      	add	sp, #8
 8011782:	bd80      	pop	{r7, pc}
 8011784:	08020a34 	.word	0x08020a34
 8011788:	00000699 	.word	0x00000699
 801178c:	08021194 	.word	0x08021194
 8011790:	08020a80 	.word	0x08020a80

08011794 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
 8011794:	b580      	push	{r7, lr}
 8011796:	b082      	sub	sp, #8
 8011798:	af00      	add	r7, sp, #0
 801179a:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_rexmit_rto: invalid pcb", pcb != NULL);
 801179c:	687b      	ldr	r3, [r7, #4]
 801179e:	2b00      	cmp	r3, #0
 80117a0:	d105      	bne.n	80117ae <tcp_rexmit_rto+0x1a>
 80117a2:	4b0a      	ldr	r3, [pc, #40]	; (80117cc <tcp_rexmit_rto+0x38>)
 80117a4:	4a0a      	ldr	r2, [pc, #40]	; (80117d0 <tcp_rexmit_rto+0x3c>)
 80117a6:	490b      	ldr	r1, [pc, #44]	; (80117d4 <tcp_rexmit_rto+0x40>)
 80117a8:	480b      	ldr	r0, [pc, #44]	; (80117d8 <tcp_rexmit_rto+0x44>)
 80117aa:	f7f1 fa0d 	bl	8002bc8 <app_debug_rtt_raw>

  if (tcp_rexmit_rto_prepare(pcb) == ERR_OK) {
 80117ae:	687b      	ldr	r3, [r7, #4]
 80117b0:	0018      	movs	r0, r3
 80117b2:	f7ff ff3d 	bl	8011630 <tcp_rexmit_rto_prepare>
 80117b6:	1e03      	subs	r3, r0, #0
 80117b8:	d103      	bne.n	80117c2 <tcp_rexmit_rto+0x2e>
    tcp_rexmit_rto_commit(pcb);
 80117ba:	687b      	ldr	r3, [r7, #4]
 80117bc:	0018      	movs	r0, r3
 80117be:	f7ff ffbf 	bl	8011740 <tcp_rexmit_rto_commit>
  }
}
 80117c2:	46c0      	nop			; (mov r8, r8)
 80117c4:	46bd      	mov	sp, r7
 80117c6:	b002      	add	sp, #8
 80117c8:	bd80      	pop	{r7, pc}
 80117ca:	46c0      	nop			; (mov r8, r8)
 80117cc:	08020a34 	.word	0x08020a34
 80117d0:	000006ae 	.word	0x000006ae
 80117d4:	080211b8 	.word	0x080211b8
 80117d8:	08020a80 	.word	0x08020a80

080117dc <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
err_t
tcp_rexmit(struct tcp_pcb *pcb)
{
 80117dc:	b590      	push	{r4, r7, lr}
 80117de:	b085      	sub	sp, #20
 80117e0:	af00      	add	r7, sp, #0
 80117e2:	6078      	str	r0, [r7, #4]
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  LWIP_ASSERT("tcp_rexmit: invalid pcb", pcb != NULL);
 80117e4:	687b      	ldr	r3, [r7, #4]
 80117e6:	2b00      	cmp	r3, #0
 80117e8:	d105      	bne.n	80117f6 <tcp_rexmit+0x1a>
 80117ea:	4b37      	ldr	r3, [pc, #220]	; (80118c8 <tcp_rexmit+0xec>)
 80117ec:	4a37      	ldr	r2, [pc, #220]	; (80118cc <tcp_rexmit+0xf0>)
 80117ee:	4938      	ldr	r1, [pc, #224]	; (80118d0 <tcp_rexmit+0xf4>)
 80117f0:	4838      	ldr	r0, [pc, #224]	; (80118d4 <tcp_rexmit+0xf8>)
 80117f2:	f7f1 f9e9 	bl	8002bc8 <app_debug_rtt_raw>

  if (pcb->unacked == NULL) {
 80117f6:	687b      	ldr	r3, [r7, #4]
 80117f8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80117fa:	2b00      	cmp	r3, #0
 80117fc:	d102      	bne.n	8011804 <tcp_rexmit+0x28>
    return ERR_VAL;
 80117fe:	2306      	movs	r3, #6
 8011800:	425b      	negs	r3, r3
 8011802:	e05d      	b.n	80118c0 <tcp_rexmit+0xe4>
  }

  seg = pcb->unacked;
 8011804:	687b      	ldr	r3, [r7, #4]
 8011806:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8011808:	60bb      	str	r3, [r7, #8]

  /* Give up if the segment is still referenced by the netif driver
     due to deferred transmission. */
  if (tcp_output_segment_busy(seg)) {
 801180a:	68bb      	ldr	r3, [r7, #8]
 801180c:	0018      	movs	r0, r3
 801180e:	f7ff fd15 	bl	801123c <tcp_output_segment_busy>
 8011812:	1e03      	subs	r3, r0, #0
 8011814:	d002      	beq.n	801181c <tcp_rexmit+0x40>
    LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_rexmit busy\n"));
    return ERR_VAL;
 8011816:	2306      	movs	r3, #6
 8011818:	425b      	negs	r3, r3
 801181a:	e051      	b.n	80118c0 <tcp_rexmit+0xe4>
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  pcb->unacked = seg->next;
 801181c:	68bb      	ldr	r3, [r7, #8]
 801181e:	681a      	ldr	r2, [r3, #0]
 8011820:	687b      	ldr	r3, [r7, #4]
 8011822:	675a      	str	r2, [r3, #116]	; 0x74

  cur_seg = &(pcb->unsent);
 8011824:	687b      	ldr	r3, [r7, #4]
 8011826:	3370      	adds	r3, #112	; 0x70
 8011828:	60fb      	str	r3, [r7, #12]
  while (*cur_seg &&
 801182a:	e002      	b.n	8011832 <tcp_rexmit+0x56>
         TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
    cur_seg = &((*cur_seg)->next );
 801182c:	68fb      	ldr	r3, [r7, #12]
 801182e:	681b      	ldr	r3, [r3, #0]
 8011830:	60fb      	str	r3, [r7, #12]
  while (*cur_seg &&
 8011832:	68fb      	ldr	r3, [r7, #12]
 8011834:	681b      	ldr	r3, [r3, #0]
 8011836:	2b00      	cmp	r3, #0
 8011838:	d022      	beq.n	8011880 <tcp_rexmit+0xa4>
         TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
 801183a:	68fb      	ldr	r3, [r7, #12]
 801183c:	681b      	ldr	r3, [r3, #0]
 801183e:	691b      	ldr	r3, [r3, #16]
 8011840:	791a      	ldrb	r2, [r3, #4]
 8011842:	7959      	ldrb	r1, [r3, #5]
 8011844:	0209      	lsls	r1, r1, #8
 8011846:	430a      	orrs	r2, r1
 8011848:	7999      	ldrb	r1, [r3, #6]
 801184a:	0409      	lsls	r1, r1, #16
 801184c:	430a      	orrs	r2, r1
 801184e:	79db      	ldrb	r3, [r3, #7]
 8011850:	061b      	lsls	r3, r3, #24
 8011852:	4313      	orrs	r3, r2
 8011854:	0018      	movs	r0, r3
 8011856:	f7f5 fb63 	bl	8006f20 <lwip_htonl>
 801185a:	0004      	movs	r4, r0
 801185c:	68bb      	ldr	r3, [r7, #8]
 801185e:	691b      	ldr	r3, [r3, #16]
 8011860:	791a      	ldrb	r2, [r3, #4]
 8011862:	7959      	ldrb	r1, [r3, #5]
 8011864:	0209      	lsls	r1, r1, #8
 8011866:	430a      	orrs	r2, r1
 8011868:	7999      	ldrb	r1, [r3, #6]
 801186a:	0409      	lsls	r1, r1, #16
 801186c:	430a      	orrs	r2, r1
 801186e:	79db      	ldrb	r3, [r3, #7]
 8011870:	061b      	lsls	r3, r3, #24
 8011872:	4313      	orrs	r3, r2
 8011874:	0018      	movs	r0, r3
 8011876:	f7f5 fb53 	bl	8006f20 <lwip_htonl>
 801187a:	0003      	movs	r3, r0
 801187c:	1ae3      	subs	r3, r4, r3
  while (*cur_seg &&
 801187e:	d4d5      	bmi.n	801182c <tcp_rexmit+0x50>
  }
  seg->next = *cur_seg;
 8011880:	68fb      	ldr	r3, [r7, #12]
 8011882:	681a      	ldr	r2, [r3, #0]
 8011884:	68bb      	ldr	r3, [r7, #8]
 8011886:	601a      	str	r2, [r3, #0]
  *cur_seg = seg;
 8011888:	68fb      	ldr	r3, [r7, #12]
 801188a:	68ba      	ldr	r2, [r7, #8]
 801188c:	601a      	str	r2, [r3, #0]
#if TCP_OVERSIZE
  if (seg->next == NULL) {
 801188e:	68bb      	ldr	r3, [r7, #8]
 8011890:	681b      	ldr	r3, [r3, #0]
 8011892:	2b00      	cmp	r3, #0
 8011894:	d103      	bne.n	801189e <tcp_rexmit+0xc2>
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
 8011896:	687b      	ldr	r3, [r7, #4]
 8011898:	226c      	movs	r2, #108	; 0x6c
 801189a:	2100      	movs	r1, #0
 801189c:	5299      	strh	r1, [r3, r2]
  }
#endif /* TCP_OVERSIZE */

  if (pcb->nrtx < 0xFF) {
 801189e:	687b      	ldr	r3, [r7, #4]
 80118a0:	2246      	movs	r2, #70	; 0x46
 80118a2:	5c9b      	ldrb	r3, [r3, r2]
 80118a4:	2bff      	cmp	r3, #255	; 0xff
 80118a6:	d007      	beq.n	80118b8 <tcp_rexmit+0xdc>
    ++pcb->nrtx;
 80118a8:	687b      	ldr	r3, [r7, #4]
 80118aa:	2246      	movs	r2, #70	; 0x46
 80118ac:	5c9b      	ldrb	r3, [r3, r2]
 80118ae:	3301      	adds	r3, #1
 80118b0:	b2d9      	uxtb	r1, r3
 80118b2:	687b      	ldr	r3, [r7, #4]
 80118b4:	2246      	movs	r2, #70	; 0x46
 80118b6:	5499      	strb	r1, [r3, r2]
  }

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
 80118b8:	687b      	ldr	r3, [r7, #4]
 80118ba:	2200      	movs	r2, #0
 80118bc:	639a      	str	r2, [r3, #56]	; 0x38

  /* Do the actual retransmission. */
  MIB2_STATS_INC(mib2.tcpretranssegs);
  /* No need to call tcp_output: we are always called from tcp_input()
     and thus tcp_output directly returns. */
  return ERR_OK;
 80118be:	2300      	movs	r3, #0
}
 80118c0:	0018      	movs	r0, r3
 80118c2:	46bd      	mov	sp, r7
 80118c4:	b005      	add	sp, #20
 80118c6:	bd90      	pop	{r4, r7, pc}
 80118c8:	08020a34 	.word	0x08020a34
 80118cc:	000006c2 	.word	0x000006c2
 80118d0:	080211d4 	.word	0x080211d4
 80118d4:	08020a80 	.word	0x08020a80

080118d8 <tcp_rexmit_fast>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
 80118d8:	b580      	push	{r7, lr}
 80118da:	b082      	sub	sp, #8
 80118dc:	af00      	add	r7, sp, #0
 80118de:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_rexmit_fast: invalid pcb", pcb != NULL);
 80118e0:	687b      	ldr	r3, [r7, #4]
 80118e2:	2b00      	cmp	r3, #0
 80118e4:	d105      	bne.n	80118f2 <tcp_rexmit_fast+0x1a>
 80118e6:	4b2c      	ldr	r3, [pc, #176]	; (8011998 <tcp_rexmit_fast+0xc0>)
 80118e8:	4a2c      	ldr	r2, [pc, #176]	; (801199c <tcp_rexmit_fast+0xc4>)
 80118ea:	492d      	ldr	r1, [pc, #180]	; (80119a0 <tcp_rexmit_fast+0xc8>)
 80118ec:	482d      	ldr	r0, [pc, #180]	; (80119a4 <tcp_rexmit_fast+0xcc>)
 80118ee:	f7f1 f96b 	bl	8002bc8 <app_debug_rtt_raw>

  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
 80118f2:	687b      	ldr	r3, [r7, #4]
 80118f4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80118f6:	2b00      	cmp	r3, #0
 80118f8:	d049      	beq.n	801198e <tcp_rexmit_fast+0xb6>
 80118fa:	687b      	ldr	r3, [r7, #4]
 80118fc:	8bdb      	ldrh	r3, [r3, #30]
 80118fe:	001a      	movs	r2, r3
 8011900:	2304      	movs	r3, #4
 8011902:	4013      	ands	r3, r2
 8011904:	d143      	bne.n	801198e <tcp_rexmit_fast+0xb6>
    LWIP_DEBUGF(TCP_FR_DEBUG,
                ("tcp_receive: dupacks %"U16_F" (%"U32_F
                 "), fast retransmit %"U32_F"\n",
                 (u16_t)pcb->dupacks, pcb->lastack,
                 lwip_ntohl(pcb->unacked->tcphdr->seqno)));
    if (tcp_rexmit(pcb) == ERR_OK) {
 8011906:	687b      	ldr	r3, [r7, #4]
 8011908:	0018      	movs	r0, r3
 801190a:	f7ff ff67 	bl	80117dc <tcp_rexmit>
 801190e:	1e03      	subs	r3, r0, #0
 8011910:	d13d      	bne.n	801198e <tcp_rexmit_fast+0xb6>
      /* Set ssthresh to half of the minimum of the current
       * cwnd and the advertised window */
      pcb->ssthresh = LWIP_MIN(pcb->cwnd, pcb->snd_wnd) / 2;
 8011912:	687b      	ldr	r3, [r7, #4]
 8011914:	2264      	movs	r2, #100	; 0x64
 8011916:	5a99      	ldrh	r1, [r3, r2]
 8011918:	687b      	ldr	r3, [r7, #4]
 801191a:	224c      	movs	r2, #76	; 0x4c
 801191c:	5a9b      	ldrh	r3, [r3, r2]
 801191e:	1c18      	adds	r0, r3, #0
 8011920:	b28a      	uxth	r2, r1
 8011922:	b283      	uxth	r3, r0
 8011924:	429a      	cmp	r2, r3
 8011926:	d900      	bls.n	801192a <tcp_rexmit_fast+0x52>
 8011928:	1c01      	adds	r1, r0, #0
 801192a:	b28b      	uxth	r3, r1
 801192c:	2b00      	cmp	r3, #0
 801192e:	da00      	bge.n	8011932 <tcp_rexmit_fast+0x5a>
 8011930:	3301      	adds	r3, #1
 8011932:	105b      	asrs	r3, r3, #1
 8011934:	b299      	uxth	r1, r3
 8011936:	687b      	ldr	r3, [r7, #4]
 8011938:	224e      	movs	r2, #78	; 0x4e
 801193a:	5299      	strh	r1, [r3, r2]

      /* The minimum value for ssthresh should be 2 MSS */
      if (pcb->ssthresh < (2U * pcb->mss)) {
 801193c:	687b      	ldr	r3, [r7, #4]
 801193e:	224e      	movs	r2, #78	; 0x4e
 8011940:	5a9b      	ldrh	r3, [r3, r2]
 8011942:	001a      	movs	r2, r3
 8011944:	687b      	ldr	r3, [r7, #4]
 8011946:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8011948:	005b      	lsls	r3, r3, #1
 801194a:	429a      	cmp	r2, r3
 801194c:	d206      	bcs.n	801195c <tcp_rexmit_fast+0x84>
        LWIP_DEBUGF(TCP_FR_DEBUG,
                    ("tcp_receive: The minimum value for ssthresh %"TCPWNDSIZE_F
                     " should be min 2 mss %"U16_F"...\n",
                     pcb->ssthresh, (u16_t)(2 * pcb->mss)));
        pcb->ssthresh = 2 * pcb->mss;
 801194e:	687b      	ldr	r3, [r7, #4]
 8011950:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8011952:	18db      	adds	r3, r3, r3
 8011954:	b299      	uxth	r1, r3
 8011956:	687b      	ldr	r3, [r7, #4]
 8011958:	224e      	movs	r2, #78	; 0x4e
 801195a:	5299      	strh	r1, [r3, r2]
      }

      pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
 801195c:	687b      	ldr	r3, [r7, #4]
 801195e:	224e      	movs	r2, #78	; 0x4e
 8011960:	5a9a      	ldrh	r2, [r3, r2]
 8011962:	687b      	ldr	r3, [r7, #4]
 8011964:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8011966:	1c19      	adds	r1, r3, #0
 8011968:	1c0b      	adds	r3, r1, #0
 801196a:	18db      	adds	r3, r3, r3
 801196c:	185b      	adds	r3, r3, r1
 801196e:	b29b      	uxth	r3, r3
 8011970:	18d3      	adds	r3, r2, r3
 8011972:	b299      	uxth	r1, r3
 8011974:	687b      	ldr	r3, [r7, #4]
 8011976:	224c      	movs	r2, #76	; 0x4c
 8011978:	5299      	strh	r1, [r3, r2]
      tcp_set_flags(pcb, TF_INFR);
 801197a:	687b      	ldr	r3, [r7, #4]
 801197c:	8bdb      	ldrh	r3, [r3, #30]
 801197e:	2204      	movs	r2, #4
 8011980:	4313      	orrs	r3, r2
 8011982:	b29a      	uxth	r2, r3
 8011984:	687b      	ldr	r3, [r7, #4]
 8011986:	83da      	strh	r2, [r3, #30]

      /* Reset the retransmission timer to prevent immediate rto retransmissions */
      pcb->rtime = 0;
 8011988:	687b      	ldr	r3, [r7, #4]
 801198a:	2200      	movs	r2, #0
 801198c:	869a      	strh	r2, [r3, #52]	; 0x34
    }
  }
}
 801198e:	46c0      	nop			; (mov r8, r8)
 8011990:	46bd      	mov	sp, r7
 8011992:	b002      	add	sp, #8
 8011994:	bd80      	pop	{r7, pc}
 8011996:	46c0      	nop			; (mov r8, r8)
 8011998:	08020a34 	.word	0x08020a34
 801199c:	000006fa 	.word	0x000006fa
 80119a0:	080211ec 	.word	0x080211ec
 80119a4:	08020a80 	.word	0x08020a80

080119a8 <tcp_output_alloc_header_common>:

static struct pbuf *
tcp_output_alloc_header_common(u32_t ackno, u16_t optlen, u16_t datalen,
                        u32_t seqno_be /* already in network byte order */,
                        u16_t src_port, u16_t dst_port, u8_t flags, u16_t wnd)
{
 80119a8:	b590      	push	{r4, r7, lr}
 80119aa:	b087      	sub	sp, #28
 80119ac:	af00      	add	r7, sp, #0
 80119ae:	60f8      	str	r0, [r7, #12]
 80119b0:	0008      	movs	r0, r1
 80119b2:	0011      	movs	r1, r2
 80119b4:	607b      	str	r3, [r7, #4]
 80119b6:	240a      	movs	r4, #10
 80119b8:	193b      	adds	r3, r7, r4
 80119ba:	1c02      	adds	r2, r0, #0
 80119bc:	801a      	strh	r2, [r3, #0]
 80119be:	2008      	movs	r0, #8
 80119c0:	183b      	adds	r3, r7, r0
 80119c2:	1c0a      	adds	r2, r1, #0
 80119c4:	801a      	strh	r2, [r3, #0]
  struct tcp_hdr *tcphdr;
  struct pbuf *p;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 80119c6:	193a      	adds	r2, r7, r4
 80119c8:	183b      	adds	r3, r7, r0
 80119ca:	8812      	ldrh	r2, [r2, #0]
 80119cc:	881b      	ldrh	r3, [r3, #0]
 80119ce:	18d3      	adds	r3, r2, r3
 80119d0:	b29b      	uxth	r3, r3
 80119d2:	3314      	adds	r3, #20
 80119d4:	b29b      	uxth	r3, r3
 80119d6:	22a0      	movs	r2, #160	; 0xa0
 80119d8:	0092      	lsls	r2, r2, #2
 80119da:	0019      	movs	r1, r3
 80119dc:	2024      	movs	r0, #36	; 0x24
 80119de:	f7f7 fef5 	bl	80097cc <pbuf_alloc>
 80119e2:	0003      	movs	r3, r0
 80119e4:	617b      	str	r3, [r7, #20]
  if (p != NULL) {
 80119e6:	697b      	ldr	r3, [r7, #20]
 80119e8:	2b00      	cmp	r3, #0
 80119ea:	d100      	bne.n	80119ee <tcp_output_alloc_header_common+0x46>
 80119ec:	e0f0      	b.n	8011bd0 <tcp_output_alloc_header_common+0x228>
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
 80119ee:	193b      	adds	r3, r7, r4
 80119f0:	881b      	ldrh	r3, [r3, #0]
 80119f2:	3313      	adds	r3, #19
 80119f4:	697a      	ldr	r2, [r7, #20]
 80119f6:	8952      	ldrh	r2, [r2, #10]
 80119f8:	4293      	cmp	r3, r2
 80119fa:	db05      	blt.n	8011a08 <tcp_output_alloc_header_common+0x60>
 80119fc:	4b77      	ldr	r3, [pc, #476]	; (8011bdc <tcp_output_alloc_header_common+0x234>)
 80119fe:	4a78      	ldr	r2, [pc, #480]	; (8011be0 <tcp_output_alloc_header_common+0x238>)
 8011a00:	4978      	ldr	r1, [pc, #480]	; (8011be4 <tcp_output_alloc_header_common+0x23c>)
 8011a02:	4879      	ldr	r0, [pc, #484]	; (8011be8 <tcp_output_alloc_header_common+0x240>)
 8011a04:	f7f1 f8e0 	bl	8002bc8 <app_debug_rtt_raw>
                (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
 8011a08:	697b      	ldr	r3, [r7, #20]
 8011a0a:	685b      	ldr	r3, [r3, #4]
 8011a0c:	613b      	str	r3, [r7, #16]
    tcphdr->src = lwip_htons(src_port);
 8011a0e:	2328      	movs	r3, #40	; 0x28
 8011a10:	18fb      	adds	r3, r7, r3
 8011a12:	881b      	ldrh	r3, [r3, #0]
 8011a14:	0018      	movs	r0, r3
 8011a16:	f7f5 fa6d 	bl	8006ef4 <lwip_htons>
 8011a1a:	0003      	movs	r3, r0
 8011a1c:	001a      	movs	r2, r3
 8011a1e:	693b      	ldr	r3, [r7, #16]
 8011a20:	21ff      	movs	r1, #255	; 0xff
 8011a22:	4011      	ands	r1, r2
 8011a24:	000c      	movs	r4, r1
 8011a26:	7819      	ldrb	r1, [r3, #0]
 8011a28:	2000      	movs	r0, #0
 8011a2a:	4001      	ands	r1, r0
 8011a2c:	1c08      	adds	r0, r1, #0
 8011a2e:	1c21      	adds	r1, r4, #0
 8011a30:	4301      	orrs	r1, r0
 8011a32:	7019      	strb	r1, [r3, #0]
 8011a34:	0a12      	lsrs	r2, r2, #8
 8011a36:	b290      	uxth	r0, r2
 8011a38:	785a      	ldrb	r2, [r3, #1]
 8011a3a:	2100      	movs	r1, #0
 8011a3c:	400a      	ands	r2, r1
 8011a3e:	1c11      	adds	r1, r2, #0
 8011a40:	1c02      	adds	r2, r0, #0
 8011a42:	430a      	orrs	r2, r1
 8011a44:	705a      	strb	r2, [r3, #1]
    tcphdr->dest = lwip_htons(dst_port);
 8011a46:	232c      	movs	r3, #44	; 0x2c
 8011a48:	18fb      	adds	r3, r7, r3
 8011a4a:	881b      	ldrh	r3, [r3, #0]
 8011a4c:	0018      	movs	r0, r3
 8011a4e:	f7f5 fa51 	bl	8006ef4 <lwip_htons>
 8011a52:	0003      	movs	r3, r0
 8011a54:	001a      	movs	r2, r3
 8011a56:	693b      	ldr	r3, [r7, #16]
 8011a58:	21ff      	movs	r1, #255	; 0xff
 8011a5a:	4011      	ands	r1, r2
 8011a5c:	000c      	movs	r4, r1
 8011a5e:	7899      	ldrb	r1, [r3, #2]
 8011a60:	2000      	movs	r0, #0
 8011a62:	4001      	ands	r1, r0
 8011a64:	1c08      	adds	r0, r1, #0
 8011a66:	1c21      	adds	r1, r4, #0
 8011a68:	4301      	orrs	r1, r0
 8011a6a:	7099      	strb	r1, [r3, #2]
 8011a6c:	0a12      	lsrs	r2, r2, #8
 8011a6e:	b290      	uxth	r0, r2
 8011a70:	78da      	ldrb	r2, [r3, #3]
 8011a72:	2100      	movs	r1, #0
 8011a74:	400a      	ands	r2, r1
 8011a76:	1c11      	adds	r1, r2, #0
 8011a78:	1c02      	adds	r2, r0, #0
 8011a7a:	430a      	orrs	r2, r1
 8011a7c:	70da      	strb	r2, [r3, #3]
    tcphdr->seqno = seqno_be;
 8011a7e:	693b      	ldr	r3, [r7, #16]
 8011a80:	1d3a      	adds	r2, r7, #4
 8011a82:	7810      	ldrb	r0, [r2, #0]
 8011a84:	791a      	ldrb	r2, [r3, #4]
 8011a86:	2100      	movs	r1, #0
 8011a88:	400a      	ands	r2, r1
 8011a8a:	1c11      	adds	r1, r2, #0
 8011a8c:	1c02      	adds	r2, r0, #0
 8011a8e:	430a      	orrs	r2, r1
 8011a90:	711a      	strb	r2, [r3, #4]
 8011a92:	1d7a      	adds	r2, r7, #5
 8011a94:	7810      	ldrb	r0, [r2, #0]
 8011a96:	795a      	ldrb	r2, [r3, #5]
 8011a98:	2100      	movs	r1, #0
 8011a9a:	400a      	ands	r2, r1
 8011a9c:	1c11      	adds	r1, r2, #0
 8011a9e:	1c02      	adds	r2, r0, #0
 8011aa0:	430a      	orrs	r2, r1
 8011aa2:	715a      	strb	r2, [r3, #5]
 8011aa4:	1dba      	adds	r2, r7, #6
 8011aa6:	7810      	ldrb	r0, [r2, #0]
 8011aa8:	799a      	ldrb	r2, [r3, #6]
 8011aaa:	2100      	movs	r1, #0
 8011aac:	400a      	ands	r2, r1
 8011aae:	1c11      	adds	r1, r2, #0
 8011ab0:	1c02      	adds	r2, r0, #0
 8011ab2:	430a      	orrs	r2, r1
 8011ab4:	719a      	strb	r2, [r3, #6]
 8011ab6:	1dfa      	adds	r2, r7, #7
 8011ab8:	7810      	ldrb	r0, [r2, #0]
 8011aba:	79da      	ldrb	r2, [r3, #7]
 8011abc:	2100      	movs	r1, #0
 8011abe:	400a      	ands	r2, r1
 8011ac0:	1c11      	adds	r1, r2, #0
 8011ac2:	1c02      	adds	r2, r0, #0
 8011ac4:	430a      	orrs	r2, r1
 8011ac6:	71da      	strb	r2, [r3, #7]
    tcphdr->ackno = lwip_htonl(ackno);
 8011ac8:	68fb      	ldr	r3, [r7, #12]
 8011aca:	0018      	movs	r0, r3
 8011acc:	f7f5 fa28 	bl	8006f20 <lwip_htonl>
 8011ad0:	0002      	movs	r2, r0
 8011ad2:	693b      	ldr	r3, [r7, #16]
 8011ad4:	21ff      	movs	r1, #255	; 0xff
 8011ad6:	4011      	ands	r1, r2
 8011ad8:	000c      	movs	r4, r1
 8011ada:	7a19      	ldrb	r1, [r3, #8]
 8011adc:	2000      	movs	r0, #0
 8011ade:	4001      	ands	r1, r0
 8011ae0:	1c08      	adds	r0, r1, #0
 8011ae2:	1c21      	adds	r1, r4, #0
 8011ae4:	4301      	orrs	r1, r0
 8011ae6:	7219      	strb	r1, [r3, #8]
 8011ae8:	0a11      	lsrs	r1, r2, #8
 8011aea:	20ff      	movs	r0, #255	; 0xff
 8011aec:	4001      	ands	r1, r0
 8011aee:	000c      	movs	r4, r1
 8011af0:	7a59      	ldrb	r1, [r3, #9]
 8011af2:	2000      	movs	r0, #0
 8011af4:	4001      	ands	r1, r0
 8011af6:	1c08      	adds	r0, r1, #0
 8011af8:	1c21      	adds	r1, r4, #0
 8011afa:	4301      	orrs	r1, r0
 8011afc:	7259      	strb	r1, [r3, #9]
 8011afe:	0c11      	lsrs	r1, r2, #16
 8011b00:	20ff      	movs	r0, #255	; 0xff
 8011b02:	4001      	ands	r1, r0
 8011b04:	000c      	movs	r4, r1
 8011b06:	7a99      	ldrb	r1, [r3, #10]
 8011b08:	2000      	movs	r0, #0
 8011b0a:	4001      	ands	r1, r0
 8011b0c:	1c08      	adds	r0, r1, #0
 8011b0e:	1c21      	adds	r1, r4, #0
 8011b10:	4301      	orrs	r1, r0
 8011b12:	7299      	strb	r1, [r3, #10]
 8011b14:	0e10      	lsrs	r0, r2, #24
 8011b16:	7ada      	ldrb	r2, [r3, #11]
 8011b18:	2100      	movs	r1, #0
 8011b1a:	400a      	ands	r2, r1
 8011b1c:	1c11      	adds	r1, r2, #0
 8011b1e:	1c02      	adds	r2, r0, #0
 8011b20:	430a      	orrs	r2, r1
 8011b22:	72da      	strb	r2, [r3, #11]
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), flags);
 8011b24:	230a      	movs	r3, #10
 8011b26:	18fb      	adds	r3, r7, r3
 8011b28:	881b      	ldrh	r3, [r3, #0]
 8011b2a:	089b      	lsrs	r3, r3, #2
 8011b2c:	b29b      	uxth	r3, r3
 8011b2e:	3305      	adds	r3, #5
 8011b30:	b29b      	uxth	r3, r3
 8011b32:	031b      	lsls	r3, r3, #12
 8011b34:	b29a      	uxth	r2, r3
 8011b36:	2330      	movs	r3, #48	; 0x30
 8011b38:	18fb      	adds	r3, r7, r3
 8011b3a:	781b      	ldrb	r3, [r3, #0]
 8011b3c:	b29b      	uxth	r3, r3
 8011b3e:	4313      	orrs	r3, r2
 8011b40:	b29b      	uxth	r3, r3
 8011b42:	0018      	movs	r0, r3
 8011b44:	f7f5 f9d6 	bl	8006ef4 <lwip_htons>
 8011b48:	0003      	movs	r3, r0
 8011b4a:	001a      	movs	r2, r3
 8011b4c:	693b      	ldr	r3, [r7, #16]
 8011b4e:	21ff      	movs	r1, #255	; 0xff
 8011b50:	4011      	ands	r1, r2
 8011b52:	000c      	movs	r4, r1
 8011b54:	7b19      	ldrb	r1, [r3, #12]
 8011b56:	2000      	movs	r0, #0
 8011b58:	4001      	ands	r1, r0
 8011b5a:	1c08      	adds	r0, r1, #0
 8011b5c:	1c21      	adds	r1, r4, #0
 8011b5e:	4301      	orrs	r1, r0
 8011b60:	7319      	strb	r1, [r3, #12]
 8011b62:	0a12      	lsrs	r2, r2, #8
 8011b64:	b290      	uxth	r0, r2
 8011b66:	7b5a      	ldrb	r2, [r3, #13]
 8011b68:	2100      	movs	r1, #0
 8011b6a:	400a      	ands	r2, r1
 8011b6c:	1c11      	adds	r1, r2, #0
 8011b6e:	1c02      	adds	r2, r0, #0
 8011b70:	430a      	orrs	r2, r1
 8011b72:	735a      	strb	r2, [r3, #13]
    tcphdr->wnd = lwip_htons(wnd);
 8011b74:	2334      	movs	r3, #52	; 0x34
 8011b76:	18fb      	adds	r3, r7, r3
 8011b78:	881b      	ldrh	r3, [r3, #0]
 8011b7a:	0018      	movs	r0, r3
 8011b7c:	f7f5 f9ba 	bl	8006ef4 <lwip_htons>
 8011b80:	0003      	movs	r3, r0
 8011b82:	001a      	movs	r2, r3
 8011b84:	693b      	ldr	r3, [r7, #16]
 8011b86:	21ff      	movs	r1, #255	; 0xff
 8011b88:	4011      	ands	r1, r2
 8011b8a:	000c      	movs	r4, r1
 8011b8c:	7b99      	ldrb	r1, [r3, #14]
 8011b8e:	2000      	movs	r0, #0
 8011b90:	4001      	ands	r1, r0
 8011b92:	1c08      	adds	r0, r1, #0
 8011b94:	1c21      	adds	r1, r4, #0
 8011b96:	4301      	orrs	r1, r0
 8011b98:	7399      	strb	r1, [r3, #14]
 8011b9a:	0a12      	lsrs	r2, r2, #8
 8011b9c:	b290      	uxth	r0, r2
 8011b9e:	7bda      	ldrb	r2, [r3, #15]
 8011ba0:	2100      	movs	r1, #0
 8011ba2:	400a      	ands	r2, r1
 8011ba4:	1c11      	adds	r1, r2, #0
 8011ba6:	1c02      	adds	r2, r0, #0
 8011ba8:	430a      	orrs	r2, r1
 8011baa:	73da      	strb	r2, [r3, #15]
    tcphdr->chksum = 0;
 8011bac:	693b      	ldr	r3, [r7, #16]
 8011bae:	7c1a      	ldrb	r2, [r3, #16]
 8011bb0:	2100      	movs	r1, #0
 8011bb2:	400a      	ands	r2, r1
 8011bb4:	741a      	strb	r2, [r3, #16]
 8011bb6:	7c5a      	ldrb	r2, [r3, #17]
 8011bb8:	2100      	movs	r1, #0
 8011bba:	400a      	ands	r2, r1
 8011bbc:	745a      	strb	r2, [r3, #17]
    tcphdr->urgp = 0;
 8011bbe:	693b      	ldr	r3, [r7, #16]
 8011bc0:	7c9a      	ldrb	r2, [r3, #18]
 8011bc2:	2100      	movs	r1, #0
 8011bc4:	400a      	ands	r2, r1
 8011bc6:	749a      	strb	r2, [r3, #18]
 8011bc8:	7cda      	ldrb	r2, [r3, #19]
 8011bca:	2100      	movs	r1, #0
 8011bcc:	400a      	ands	r2, r1
 8011bce:	74da      	strb	r2, [r3, #19]
  }
  return p;
 8011bd0:	697b      	ldr	r3, [r7, #20]
}
 8011bd2:	0018      	movs	r0, r3
 8011bd4:	46bd      	mov	sp, r7
 8011bd6:	b007      	add	sp, #28
 8011bd8:	bd90      	pop	{r4, r7, pc}
 8011bda:	46c0      	nop			; (mov r8, r8)
 8011bdc:	08020a34 	.word	0x08020a34
 8011be0:	00000724 	.word	0x00000724
 8011be4:	0802120c 	.word	0x0802120c
 8011be8:	08020a80 	.word	0x08020a80

08011bec <tcp_output_alloc_header>:
 * @return pbuf with p->payload being the tcp_hdr
 */
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
                        u32_t seqno_be /* already in network byte order */)
{
 8011bec:	b5f0      	push	{r4, r5, r6, r7, lr}
 8011bee:	b08b      	sub	sp, #44	; 0x2c
 8011bf0:	af04      	add	r7, sp, #16
 8011bf2:	60f8      	str	r0, [r7, #12]
 8011bf4:	0008      	movs	r0, r1
 8011bf6:	0011      	movs	r1, r2
 8011bf8:	607b      	str	r3, [r7, #4]
 8011bfa:	230a      	movs	r3, #10
 8011bfc:	18fb      	adds	r3, r7, r3
 8011bfe:	1c02      	adds	r2, r0, #0
 8011c00:	801a      	strh	r2, [r3, #0]
 8011c02:	2308      	movs	r3, #8
 8011c04:	18fb      	adds	r3, r7, r3
 8011c06:	1c0a      	adds	r2, r1, #0
 8011c08:	801a      	strh	r2, [r3, #0]
  struct pbuf *p;

  LWIP_ASSERT("tcp_output_alloc_header: invalid pcb", pcb != NULL);
 8011c0a:	68fb      	ldr	r3, [r7, #12]
 8011c0c:	2b00      	cmp	r3, #0
 8011c0e:	d105      	bne.n	8011c1c <tcp_output_alloc_header+0x30>
 8011c10:	4b18      	ldr	r3, [pc, #96]	; (8011c74 <tcp_output_alloc_header+0x88>)
 8011c12:	4a19      	ldr	r2, [pc, #100]	; (8011c78 <tcp_output_alloc_header+0x8c>)
 8011c14:	4919      	ldr	r1, [pc, #100]	; (8011c7c <tcp_output_alloc_header+0x90>)
 8011c16:	481a      	ldr	r0, [pc, #104]	; (8011c80 <tcp_output_alloc_header+0x94>)
 8011c18:	f7f0 ffd6 	bl	8002bc8 <app_debug_rtt_raw>

  p = tcp_output_alloc_header_common(pcb->rcv_nxt, optlen, datalen,
 8011c1c:	68fb      	ldr	r3, [r7, #12]
 8011c1e:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 8011c20:	68fb      	ldr	r3, [r7, #12]
 8011c22:	8b5b      	ldrh	r3, [r3, #26]
 8011c24:	68fa      	ldr	r2, [r7, #12]
 8011c26:	8b92      	ldrh	r2, [r2, #28]
 8011c28:	68f9      	ldr	r1, [r7, #12]
 8011c2a:	8dc9      	ldrh	r1, [r1, #46]	; 0x2e
 8011c2c:	687e      	ldr	r6, [r7, #4]
 8011c2e:	2008      	movs	r0, #8
 8011c30:	1838      	adds	r0, r7, r0
 8011c32:	8805      	ldrh	r5, [r0, #0]
 8011c34:	200a      	movs	r0, #10
 8011c36:	1838      	adds	r0, r7, r0
 8011c38:	8800      	ldrh	r0, [r0, #0]
 8011c3a:	9103      	str	r1, [sp, #12]
 8011c3c:	2110      	movs	r1, #16
 8011c3e:	9102      	str	r1, [sp, #8]
 8011c40:	9201      	str	r2, [sp, #4]
 8011c42:	9300      	str	r3, [sp, #0]
 8011c44:	0033      	movs	r3, r6
 8011c46:	002a      	movs	r2, r5
 8011c48:	0001      	movs	r1, r0
 8011c4a:	0020      	movs	r0, r4
 8011c4c:	f7ff feac 	bl	80119a8 <tcp_output_alloc_header_common>
 8011c50:	0003      	movs	r3, r0
 8011c52:	617b      	str	r3, [r7, #20]
    seqno_be, pcb->local_port, pcb->remote_port, TCP_ACK,
    TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
  if (p != NULL) {
 8011c54:	697b      	ldr	r3, [r7, #20]
 8011c56:	2b00      	cmp	r3, #0
 8011c58:	d006      	beq.n	8011c68 <tcp_output_alloc_header+0x7c>
    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 8011c5a:	68fb      	ldr	r3, [r7, #12]
 8011c5c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8011c5e:	68fa      	ldr	r2, [r7, #12]
 8011c60:	8dd2      	ldrh	r2, [r2, #46]	; 0x2e
 8011c62:	189a      	adds	r2, r3, r2
 8011c64:	68fb      	ldr	r3, [r7, #12]
 8011c66:	631a      	str	r2, [r3, #48]	; 0x30
  }
  return p;
 8011c68:	697b      	ldr	r3, [r7, #20]
}
 8011c6a:	0018      	movs	r0, r3
 8011c6c:	46bd      	mov	sp, r7
 8011c6e:	b007      	add	sp, #28
 8011c70:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8011c72:	46c0      	nop			; (mov r8, r8)
 8011c74:	08020a34 	.word	0x08020a34
 8011c78:	00000743 	.word	0x00000743
 8011c7c:	0802123c 	.word	0x0802123c
 8011c80:	08020a80 	.word	0x08020a80

08011c84 <tcp_output_fill_options>:

/* Fill in options for control segments */
static void
tcp_output_fill_options(const struct tcp_pcb *pcb, struct pbuf *p, u8_t optflags, u8_t num_sacks)
{
 8011c84:	b580      	push	{r7, lr}
 8011c86:	b088      	sub	sp, #32
 8011c88:	af00      	add	r7, sp, #0
 8011c8a:	60f8      	str	r0, [r7, #12]
 8011c8c:	60b9      	str	r1, [r7, #8]
 8011c8e:	0019      	movs	r1, r3
 8011c90:	1dfb      	adds	r3, r7, #7
 8011c92:	701a      	strb	r2, [r3, #0]
 8011c94:	1dbb      	adds	r3, r7, #6
 8011c96:	1c0a      	adds	r2, r1, #0
 8011c98:	701a      	strb	r2, [r3, #0]
  struct tcp_hdr *tcphdr;
  u32_t *opts;
  u16_t sacks_len = 0;
 8011c9a:	231e      	movs	r3, #30
 8011c9c:	18fb      	adds	r3, r7, r3
 8011c9e:	2200      	movs	r2, #0
 8011ca0:	801a      	strh	r2, [r3, #0]

  LWIP_ASSERT("tcp_output_fill_options: invalid pbuf", p != NULL);
 8011ca2:	68bb      	ldr	r3, [r7, #8]
 8011ca4:	2b00      	cmp	r3, #0
 8011ca6:	d105      	bne.n	8011cb4 <tcp_output_fill_options+0x30>
 8011ca8:	4b13      	ldr	r3, [pc, #76]	; (8011cf8 <tcp_output_fill_options+0x74>)
 8011caa:	4a14      	ldr	r2, [pc, #80]	; (8011cfc <tcp_output_fill_options+0x78>)
 8011cac:	4914      	ldr	r1, [pc, #80]	; (8011d00 <tcp_output_fill_options+0x7c>)
 8011cae:	4815      	ldr	r0, [pc, #84]	; (8011d04 <tcp_output_fill_options+0x80>)
 8011cb0:	f7f0 ff8a 	bl	8002bc8 <app_debug_rtt_raw>

  tcphdr = (struct tcp_hdr *)p->payload;
 8011cb4:	68bb      	ldr	r3, [r7, #8]
 8011cb6:	685b      	ldr	r3, [r3, #4]
 8011cb8:	61bb      	str	r3, [r7, #24]
  opts = (u32_t *)(void *)(tcphdr + 1);
 8011cba:	69bb      	ldr	r3, [r7, #24]
 8011cbc:	3314      	adds	r3, #20
 8011cbe:	617b      	str	r3, [r7, #20]
  opts = LWIP_HOOK_TCP_OUT_ADD_TCPOPTS(p, tcphdr, pcb, opts);
#endif

  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(sacks_len);
  LWIP_ASSERT("options not filled", (u8_t *)opts == ((u8_t *)(tcphdr + 1)) + sacks_len * 4 + LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb));
 8011cc0:	69bb      	ldr	r3, [r7, #24]
 8011cc2:	3314      	adds	r3, #20
 8011cc4:	001a      	movs	r2, r3
 8011cc6:	231e      	movs	r3, #30
 8011cc8:	18fb      	adds	r3, r7, r3
 8011cca:	881b      	ldrh	r3, [r3, #0]
 8011ccc:	009b      	lsls	r3, r3, #2
 8011cce:	0018      	movs	r0, r3
 8011cd0:	1dfb      	adds	r3, r7, #7
 8011cd2:	781b      	ldrb	r3, [r3, #0]
 8011cd4:	009b      	lsls	r3, r3, #2
 8011cd6:	2104      	movs	r1, #4
 8011cd8:	400b      	ands	r3, r1
 8011cda:	18c3      	adds	r3, r0, r3
 8011cdc:	18d3      	adds	r3, r2, r3
 8011cde:	697a      	ldr	r2, [r7, #20]
 8011ce0:	429a      	cmp	r2, r3
 8011ce2:	d005      	beq.n	8011cf0 <tcp_output_fill_options+0x6c>
 8011ce4:	4b04      	ldr	r3, [pc, #16]	; (8011cf8 <tcp_output_fill_options+0x74>)
 8011ce6:	4a08      	ldr	r2, [pc, #32]	; (8011d08 <tcp_output_fill_options+0x84>)
 8011ce8:	4908      	ldr	r1, [pc, #32]	; (8011d0c <tcp_output_fill_options+0x88>)
 8011cea:	4806      	ldr	r0, [pc, #24]	; (8011d04 <tcp_output_fill_options+0x80>)
 8011cec:	f7f0 ff6c 	bl	8002bc8 <app_debug_rtt_raw>
  LWIP_UNUSED_ARG(optflags); /* for LWIP_NOASSERT */
  LWIP_UNUSED_ARG(opts); /* for LWIP_NOASSERT */
}
 8011cf0:	46c0      	nop			; (mov r8, r8)
 8011cf2:	46bd      	mov	sp, r7
 8011cf4:	b008      	add	sp, #32
 8011cf6:	bd80      	pop	{r7, pc}
 8011cf8:	08020a34 	.word	0x08020a34
 8011cfc:	00000757 	.word	0x00000757
 8011d00:	08021264 	.word	0x08021264
 8011d04:	08020a80 	.word	0x08020a80
 8011d08:	00000776 	.word	0x00000776
 8011d0c:	08021138 	.word	0x08021138

08011d10 <tcp_output_control_segment>:
 * header checksum and calling ip_output_if while handling netif hints and stats.
 */
static err_t
tcp_output_control_segment(const struct tcp_pcb *pcb, struct pbuf *p,
                           const ip_addr_t *src, const ip_addr_t *dst)
{
 8011d10:	b5b0      	push	{r4, r5, r7, lr}
 8011d12:	b08c      	sub	sp, #48	; 0x30
 8011d14:	af04      	add	r7, sp, #16
 8011d16:	60f8      	str	r0, [r7, #12]
 8011d18:	60b9      	str	r1, [r7, #8]
 8011d1a:	607a      	str	r2, [r7, #4]
 8011d1c:	603b      	str	r3, [r7, #0]
  err_t err;
  struct netif *netif;

  LWIP_ASSERT("tcp_output_control_segment: invalid pbuf", p != NULL);
 8011d1e:	68bb      	ldr	r3, [r7, #8]
 8011d20:	2b00      	cmp	r3, #0
 8011d22:	d106      	bne.n	8011d32 <tcp_output_control_segment+0x22>
 8011d24:	4b3c      	ldr	r3, [pc, #240]	; (8011e18 <tcp_output_control_segment+0x108>)
 8011d26:	22f1      	movs	r2, #241	; 0xf1
 8011d28:	00d2      	lsls	r2, r2, #3
 8011d2a:	493c      	ldr	r1, [pc, #240]	; (8011e1c <tcp_output_control_segment+0x10c>)
 8011d2c:	483c      	ldr	r0, [pc, #240]	; (8011e20 <tcp_output_control_segment+0x110>)
 8011d2e:	f7f0 ff4b 	bl	8002bc8 <app_debug_rtt_raw>

  netif = tcp_route(pcb, src, dst);
 8011d32:	683a      	ldr	r2, [r7, #0]
 8011d34:	6879      	ldr	r1, [r7, #4]
 8011d36:	68fb      	ldr	r3, [r7, #12]
 8011d38:	0018      	movs	r0, r3
 8011d3a:	f7fd fc7d 	bl	800f638 <tcp_route>
 8011d3e:	0003      	movs	r3, r0
 8011d40:	61bb      	str	r3, [r7, #24]
  if (netif == NULL) {
 8011d42:	69bb      	ldr	r3, [r7, #24]
 8011d44:	2b00      	cmp	r3, #0
 8011d46:	d104      	bne.n	8011d52 <tcp_output_control_segment+0x42>
    err = ERR_RTE;
 8011d48:	231f      	movs	r3, #31
 8011d4a:	18fb      	adds	r3, r7, r3
 8011d4c:	22fc      	movs	r2, #252	; 0xfc
 8011d4e:	701a      	strb	r2, [r3, #0]
 8011d50:	e055      	b.n	8011dfe <tcp_output_control_segment+0xee>
  } else {
    u8_t ttl, tos;
#if CHECKSUM_GEN_TCP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_TCP) {
      struct tcp_hdr *tcphdr = (struct tcp_hdr *)p->payload;
 8011d52:	68bb      	ldr	r3, [r7, #8]
 8011d54:	685b      	ldr	r3, [r3, #4]
 8011d56:	617b      	str	r3, [r7, #20]
      tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
 8011d58:	68bb      	ldr	r3, [r7, #8]
 8011d5a:	891a      	ldrh	r2, [r3, #8]
 8011d5c:	6879      	ldr	r1, [r7, #4]
 8011d5e:	68b8      	ldr	r0, [r7, #8]
 8011d60:	683b      	ldr	r3, [r7, #0]
 8011d62:	9300      	str	r3, [sp, #0]
 8011d64:	000b      	movs	r3, r1
 8011d66:	2106      	movs	r1, #6
 8011d68:	f7f6 fb4b 	bl	8008402 <ip_chksum_pseudo>
 8011d6c:	0003      	movs	r3, r0
 8011d6e:	001a      	movs	r2, r3
 8011d70:	697b      	ldr	r3, [r7, #20]
 8011d72:	21ff      	movs	r1, #255	; 0xff
 8011d74:	4011      	ands	r1, r2
 8011d76:	000c      	movs	r4, r1
 8011d78:	7c19      	ldrb	r1, [r3, #16]
 8011d7a:	2000      	movs	r0, #0
 8011d7c:	4001      	ands	r1, r0
 8011d7e:	1c08      	adds	r0, r1, #0
 8011d80:	1c21      	adds	r1, r4, #0
 8011d82:	4301      	orrs	r1, r0
 8011d84:	7419      	strb	r1, [r3, #16]
 8011d86:	0a12      	lsrs	r2, r2, #8
 8011d88:	b290      	uxth	r0, r2
 8011d8a:	7c5a      	ldrb	r2, [r3, #17]
 8011d8c:	2100      	movs	r1, #0
 8011d8e:	400a      	ands	r2, r1
 8011d90:	1c11      	adds	r1, r2, #0
 8011d92:	1c02      	adds	r2, r0, #0
 8011d94:	430a      	orrs	r2, r1
 8011d96:	745a      	strb	r2, [r3, #17]
                                        src, dst);
    }
#endif
    if (pcb != NULL) {
 8011d98:	68fb      	ldr	r3, [r7, #12]
 8011d9a:	2b00      	cmp	r3, #0
 8011d9c:	d00f      	beq.n	8011dbe <tcp_output_control_segment+0xae>
      NETIF_SET_HINTS(netif, LWIP_CONST_CAST(struct netif_hint*, &(pcb->netif_hints)));
 8011d9e:	68fb      	ldr	r3, [r7, #12]
 8011da0:	330c      	adds	r3, #12
 8011da2:	001a      	movs	r2, r3
 8011da4:	69bb      	ldr	r3, [r7, #24]
 8011da6:	639a      	str	r2, [r3, #56]	; 0x38
      ttl = pcb->ttl;
 8011da8:	231e      	movs	r3, #30
 8011daa:	18fb      	adds	r3, r7, r3
 8011dac:	68fa      	ldr	r2, [r7, #12]
 8011dae:	7ad2      	ldrb	r2, [r2, #11]
 8011db0:	701a      	strb	r2, [r3, #0]
      tos = pcb->tos;
 8011db2:	231d      	movs	r3, #29
 8011db4:	18fb      	adds	r3, r7, r3
 8011db6:	68fa      	ldr	r2, [r7, #12]
 8011db8:	7a92      	ldrb	r2, [r2, #10]
 8011dba:	701a      	strb	r2, [r3, #0]
 8011dbc:	e007      	b.n	8011dce <tcp_output_control_segment+0xbe>
    } else {
      /* Send output with hardcoded TTL/HL since we have no access to the pcb */
      ttl = TCP_TTL;
 8011dbe:	231e      	movs	r3, #30
 8011dc0:	18fb      	adds	r3, r7, r3
 8011dc2:	22ff      	movs	r2, #255	; 0xff
 8011dc4:	701a      	strb	r2, [r3, #0]
      tos = 0;
 8011dc6:	231d      	movs	r3, #29
 8011dc8:	18fb      	adds	r3, r7, r3
 8011dca:	2200      	movs	r2, #0
 8011dcc:	701a      	strb	r2, [r3, #0]
    }
    TCP_STATS_INC(tcp.xmit);
    err = ip_output_if(p, src, dst, ttl, tos, IP_PROTO_TCP, netif);
 8011dce:	231f      	movs	r3, #31
 8011dd0:	18fc      	adds	r4, r7, r3
 8011dd2:	231e      	movs	r3, #30
 8011dd4:	18fb      	adds	r3, r7, r3
 8011dd6:	781d      	ldrb	r5, [r3, #0]
 8011dd8:	683a      	ldr	r2, [r7, #0]
 8011dda:	6879      	ldr	r1, [r7, #4]
 8011ddc:	68b8      	ldr	r0, [r7, #8]
 8011dde:	69bb      	ldr	r3, [r7, #24]
 8011de0:	9302      	str	r3, [sp, #8]
 8011de2:	2306      	movs	r3, #6
 8011de4:	9301      	str	r3, [sp, #4]
 8011de6:	231d      	movs	r3, #29
 8011de8:	18fb      	adds	r3, r7, r3
 8011dea:	781b      	ldrb	r3, [r3, #0]
 8011dec:	9300      	str	r3, [sp, #0]
 8011dee:	002b      	movs	r3, r5
 8011df0:	f001 fdee 	bl	80139d0 <ip4_output_if>
 8011df4:	0003      	movs	r3, r0
 8011df6:	7023      	strb	r3, [r4, #0]
    NETIF_RESET_HINTS(netif);
 8011df8:	69bb      	ldr	r3, [r7, #24]
 8011dfa:	2200      	movs	r2, #0
 8011dfc:	639a      	str	r2, [r3, #56]	; 0x38
  }
  pbuf_free(p);
 8011dfe:	68bb      	ldr	r3, [r7, #8]
 8011e00:	0018      	movs	r0, r3
 8011e02:	f7f8 f85b 	bl	8009ebc <pbuf_free>
  return err;
 8011e06:	231f      	movs	r3, #31
 8011e08:	18fb      	adds	r3, r7, r3
 8011e0a:	781b      	ldrb	r3, [r3, #0]
 8011e0c:	b25b      	sxtb	r3, r3
}
 8011e0e:	0018      	movs	r0, r3
 8011e10:	46bd      	mov	sp, r7
 8011e12:	b008      	add	sp, #32
 8011e14:	bdb0      	pop	{r4, r5, r7, pc}
 8011e16:	46c0      	nop			; (mov r8, r8)
 8011e18:	08020a34 	.word	0x08020a34
 8011e1c:	0802128c 	.word	0x0802128c
 8011e20:	08020a80 	.word	0x08020a80

08011e24 <tcp_rst>:
 */
void
tcp_rst(const struct tcp_pcb *pcb, u32_t seqno, u32_t ackno,
        const ip_addr_t *local_ip, const ip_addr_t *remote_ip,
        u16_t local_port, u16_t remote_port)
{
 8011e24:	b5b0      	push	{r4, r5, r7, lr}
 8011e26:	b08a      	sub	sp, #40	; 0x28
 8011e28:	af04      	add	r7, sp, #16
 8011e2a:	60f8      	str	r0, [r7, #12]
 8011e2c:	60b9      	str	r1, [r7, #8]
 8011e2e:	607a      	str	r2, [r7, #4]
 8011e30:	603b      	str	r3, [r7, #0]
  struct pbuf *p;
  u16_t wnd;
  u8_t optlen;

  LWIP_ASSERT("tcp_rst: invalid local_ip", local_ip != NULL);
 8011e32:	683b      	ldr	r3, [r7, #0]
 8011e34:	2b00      	cmp	r3, #0
 8011e36:	d105      	bne.n	8011e44 <tcp_rst+0x20>
 8011e38:	4b23      	ldr	r3, [pc, #140]	; (8011ec8 <tcp_rst+0xa4>)
 8011e3a:	4a24      	ldr	r2, [pc, #144]	; (8011ecc <tcp_rst+0xa8>)
 8011e3c:	4924      	ldr	r1, [pc, #144]	; (8011ed0 <tcp_rst+0xac>)
 8011e3e:	4825      	ldr	r0, [pc, #148]	; (8011ed4 <tcp_rst+0xb0>)
 8011e40:	f7f0 fec2 	bl	8002bc8 <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_rst: invalid remote_ip", remote_ip != NULL);
 8011e44:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011e46:	2b00      	cmp	r3, #0
 8011e48:	d105      	bne.n	8011e56 <tcp_rst+0x32>
 8011e4a:	4b1f      	ldr	r3, [pc, #124]	; (8011ec8 <tcp_rst+0xa4>)
 8011e4c:	4a22      	ldr	r2, [pc, #136]	; (8011ed8 <tcp_rst+0xb4>)
 8011e4e:	4923      	ldr	r1, [pc, #140]	; (8011edc <tcp_rst+0xb8>)
 8011e50:	4820      	ldr	r0, [pc, #128]	; (8011ed4 <tcp_rst+0xb0>)
 8011e52:	f7f0 feb9 	bl	8002bc8 <app_debug_rtt_raw>

  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
 8011e56:	2117      	movs	r1, #23
 8011e58:	187b      	adds	r3, r7, r1
 8011e5a:	2200      	movs	r2, #0
 8011e5c:	701a      	strb	r2, [r3, #0]

#if LWIP_WND_SCALE
  wnd = PP_HTONS(((TCP_WND >> TCP_RCV_SCALE) & 0xFFFF));
#else
  wnd = PP_HTONS(TCP_WND);
 8011e5e:	2514      	movs	r5, #20
 8011e60:	197b      	adds	r3, r7, r5
 8011e62:	4a1f      	ldr	r2, [pc, #124]	; (8011ee0 <tcp_rst+0xbc>)
 8011e64:	801a      	strh	r2, [r3, #0]
#endif

  p = tcp_output_alloc_header_common(ackno, optlen, 0, lwip_htonl(seqno), local_port,
 8011e66:	187b      	adds	r3, r7, r1
 8011e68:	781b      	ldrb	r3, [r3, #0]
 8011e6a:	b29c      	uxth	r4, r3
 8011e6c:	68bb      	ldr	r3, [r7, #8]
 8011e6e:	0018      	movs	r0, r3
 8011e70:	f7f5 f856 	bl	8006f20 <lwip_htonl>
 8011e74:	0002      	movs	r2, r0
 8011e76:	6878      	ldr	r0, [r7, #4]
 8011e78:	197b      	adds	r3, r7, r5
 8011e7a:	881b      	ldrh	r3, [r3, #0]
 8011e7c:	9303      	str	r3, [sp, #12]
 8011e7e:	2314      	movs	r3, #20
 8011e80:	9302      	str	r3, [sp, #8]
 8011e82:	2330      	movs	r3, #48	; 0x30
 8011e84:	18fb      	adds	r3, r7, r3
 8011e86:	881b      	ldrh	r3, [r3, #0]
 8011e88:	9301      	str	r3, [sp, #4]
 8011e8a:	232c      	movs	r3, #44	; 0x2c
 8011e8c:	18fb      	adds	r3, r7, r3
 8011e8e:	881b      	ldrh	r3, [r3, #0]
 8011e90:	9300      	str	r3, [sp, #0]
 8011e92:	0013      	movs	r3, r2
 8011e94:	2200      	movs	r2, #0
 8011e96:	0021      	movs	r1, r4
 8011e98:	f7ff fd86 	bl	80119a8 <tcp_output_alloc_header_common>
 8011e9c:	0003      	movs	r3, r0
 8011e9e:	613b      	str	r3, [r7, #16]
    remote_port, TCP_RST | TCP_ACK, wnd);
  if (p == NULL) {
 8011ea0:	693b      	ldr	r3, [r7, #16]
 8011ea2:	2b00      	cmp	r3, #0
 8011ea4:	d00c      	beq.n	8011ec0 <tcp_rst+0x9c>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
    return;
  }
  tcp_output_fill_options(pcb, p, 0, 0);
 8011ea6:	6939      	ldr	r1, [r7, #16]
 8011ea8:	68f8      	ldr	r0, [r7, #12]
 8011eaa:	2300      	movs	r3, #0
 8011eac:	2200      	movs	r2, #0
 8011eae:	f7ff fee9 	bl	8011c84 <tcp_output_fill_options>

  MIB2_STATS_INC(mib2.tcpoutrsts);

  tcp_output_control_segment(pcb, p, local_ip, remote_ip);
 8011eb2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011eb4:	683a      	ldr	r2, [r7, #0]
 8011eb6:	6939      	ldr	r1, [r7, #16]
 8011eb8:	68f8      	ldr	r0, [r7, #12]
 8011eba:	f7ff ff29 	bl	8011d10 <tcp_output_control_segment>
 8011ebe:	e000      	b.n	8011ec2 <tcp_rst+0x9e>
    return;
 8011ec0:	46c0      	nop			; (mov r8, r8)
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
 8011ec2:	46bd      	mov	sp, r7
 8011ec4:	b006      	add	sp, #24
 8011ec6:	bdb0      	pop	{r4, r5, r7, pc}
 8011ec8:	08020a34 	.word	0x08020a34
 8011ecc:	000007c5 	.word	0x000007c5
 8011ed0:	080212b8 	.word	0x080212b8
 8011ed4:	08020a80 	.word	0x08020a80
 8011ed8:	000007c6 	.word	0x000007c6
 8011edc:	080212d4 	.word	0x080212d4
 8011ee0:	00003004 	.word	0x00003004

08011ee4 <tcp_send_empty_ack>:
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
 8011ee4:	b5b0      	push	{r4, r5, r7, lr}
 8011ee6:	b086      	sub	sp, #24
 8011ee8:	af00      	add	r7, sp, #0
 8011eea:	6078      	str	r0, [r7, #4]
  err_t err;
  struct pbuf *p;
  u8_t optlen, optflags = 0;
 8011eec:	2317      	movs	r3, #23
 8011eee:	18fb      	adds	r3, r7, r3
 8011ef0:	2200      	movs	r2, #0
 8011ef2:	701a      	strb	r2, [r3, #0]
  u8_t num_sacks = 0;
 8011ef4:	2316      	movs	r3, #22
 8011ef6:	18fb      	adds	r3, r7, r3
 8011ef8:	2200      	movs	r2, #0
 8011efa:	701a      	strb	r2, [r3, #0]

  LWIP_ASSERT("tcp_send_empty_ack: invalid pcb", pcb != NULL);
 8011efc:	687b      	ldr	r3, [r7, #4]
 8011efe:	2b00      	cmp	r3, #0
 8011f00:	d105      	bne.n	8011f0e <tcp_send_empty_ack+0x2a>
 8011f02:	4b2f      	ldr	r3, [pc, #188]	; (8011fc0 <tcp_send_empty_ack+0xdc>)
 8011f04:	4a2f      	ldr	r2, [pc, #188]	; (8011fc4 <tcp_send_empty_ack+0xe0>)
 8011f06:	4930      	ldr	r1, [pc, #192]	; (8011fc8 <tcp_send_empty_ack+0xe4>)
 8011f08:	4830      	ldr	r0, [pc, #192]	; (8011fcc <tcp_send_empty_ack+0xe8>)
 8011f0a:	f7f0 fe5d 	bl	8002bc8 <app_debug_rtt_raw>
#if LWIP_TCP_TIMESTAMPS
  if (pcb->flags & TF_TIMESTAMP) {
    optflags = TF_SEG_OPTS_TS;
  }
#endif
  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
 8011f0e:	2317      	movs	r3, #23
 8011f10:	18fb      	adds	r3, r7, r3
 8011f12:	781b      	ldrb	r3, [r3, #0]
 8011f14:	009b      	lsls	r3, r3, #2
 8011f16:	b2da      	uxtb	r2, r3
 8011f18:	2015      	movs	r0, #21
 8011f1a:	183b      	adds	r3, r7, r0
 8011f1c:	2104      	movs	r1, #4
 8011f1e:	400a      	ands	r2, r1
 8011f20:	701a      	strb	r2, [r3, #0]
  if ((num_sacks = tcp_get_num_sacks(pcb, optlen)) > 0) {
    optlen += 4 + num_sacks * 8; /* 4 bytes for header (including 2*NOP), plus 8B for each SACK */
  }
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, lwip_htonl(pcb->snd_nxt));
 8011f22:	183b      	adds	r3, r7, r0
 8011f24:	781b      	ldrb	r3, [r3, #0]
 8011f26:	b29c      	uxth	r4, r3
 8011f28:	687b      	ldr	r3, [r7, #4]
 8011f2a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8011f2c:	0018      	movs	r0, r3
 8011f2e:	f7f4 fff7 	bl	8006f20 <lwip_htonl>
 8011f32:	0003      	movs	r3, r0
 8011f34:	6878      	ldr	r0, [r7, #4]
 8011f36:	2200      	movs	r2, #0
 8011f38:	0021      	movs	r1, r4
 8011f3a:	f7ff fe57 	bl	8011bec <tcp_output_alloc_header>
 8011f3e:	0003      	movs	r3, r0
 8011f40:	613b      	str	r3, [r7, #16]
  if (p == NULL) {
 8011f42:	693b      	ldr	r3, [r7, #16]
 8011f44:	2b00      	cmp	r3, #0
 8011f46:	d109      	bne.n	8011f5c <tcp_send_empty_ack+0x78>
    /* let tcp_fasttmr retry sending this ACK */
    tcp_set_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 8011f48:	687b      	ldr	r3, [r7, #4]
 8011f4a:	8bdb      	ldrh	r3, [r3, #30]
 8011f4c:	2203      	movs	r2, #3
 8011f4e:	4313      	orrs	r3, r2
 8011f50:	b29a      	uxth	r2, r3
 8011f52:	687b      	ldr	r3, [r7, #4]
 8011f54:	83da      	strh	r2, [r3, #30]
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
 8011f56:	2302      	movs	r3, #2
 8011f58:	425b      	negs	r3, r3
 8011f5a:	e02d      	b.n	8011fb8 <tcp_send_empty_ack+0xd4>
  }
  tcp_output_fill_options(pcb, p, optflags, num_sacks);
 8011f5c:	2316      	movs	r3, #22
 8011f5e:	18fb      	adds	r3, r7, r3
 8011f60:	781c      	ldrb	r4, [r3, #0]
 8011f62:	2317      	movs	r3, #23
 8011f64:	18fb      	adds	r3, r7, r3
 8011f66:	781a      	ldrb	r2, [r3, #0]
 8011f68:	6939      	ldr	r1, [r7, #16]
 8011f6a:	6878      	ldr	r0, [r7, #4]
 8011f6c:	0023      	movs	r3, r4
 8011f6e:	f7ff fe89 	bl	8011c84 <tcp_output_fill_options>
  pcb->ts_lastacksent = pcb->rcv_nxt;
#endif

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG,
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
 8011f72:	687a      	ldr	r2, [r7, #4]
 8011f74:	687b      	ldr	r3, [r7, #4]
 8011f76:	3304      	adds	r3, #4
 8011f78:	250f      	movs	r5, #15
 8011f7a:	197c      	adds	r4, r7, r5
 8011f7c:	6939      	ldr	r1, [r7, #16]
 8011f7e:	6878      	ldr	r0, [r7, #4]
 8011f80:	f7ff fec6 	bl	8011d10 <tcp_output_control_segment>
 8011f84:	0003      	movs	r3, r0
 8011f86:	7023      	strb	r3, [r4, #0]
  if (err != ERR_OK) {
 8011f88:	197b      	adds	r3, r7, r5
 8011f8a:	781b      	ldrb	r3, [r3, #0]
 8011f8c:	b25b      	sxtb	r3, r3
 8011f8e:	2b00      	cmp	r3, #0
 8011f90:	d007      	beq.n	8011fa2 <tcp_send_empty_ack+0xbe>
    /* let tcp_fasttmr retry sending this ACK */
    tcp_set_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 8011f92:	687b      	ldr	r3, [r7, #4]
 8011f94:	8bdb      	ldrh	r3, [r3, #30]
 8011f96:	2203      	movs	r2, #3
 8011f98:	4313      	orrs	r3, r2
 8011f9a:	b29a      	uxth	r2, r3
 8011f9c:	687b      	ldr	r3, [r7, #4]
 8011f9e:	83da      	strh	r2, [r3, #30]
 8011fa0:	e006      	b.n	8011fb0 <tcp_send_empty_ack+0xcc>
  } else {
    /* remove ACK flags from the PCB, as we sent an empty ACK now */
    tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 8011fa2:	687b      	ldr	r3, [r7, #4]
 8011fa4:	8bdb      	ldrh	r3, [r3, #30]
 8011fa6:	2203      	movs	r2, #3
 8011fa8:	4393      	bics	r3, r2
 8011faa:	b29a      	uxth	r2, r3
 8011fac:	687b      	ldr	r3, [r7, #4]
 8011fae:	83da      	strh	r2, [r3, #30]
  }

  return err;
 8011fb0:	230f      	movs	r3, #15
 8011fb2:	18fb      	adds	r3, r7, r3
 8011fb4:	781b      	ldrb	r3, [r3, #0]
 8011fb6:	b25b      	sxtb	r3, r3
}
 8011fb8:	0018      	movs	r0, r3
 8011fba:	46bd      	mov	sp, r7
 8011fbc:	b006      	add	sp, #24
 8011fbe:	bdb0      	pop	{r4, r5, r7, pc}
 8011fc0:	08020a34 	.word	0x08020a34
 8011fc4:	000007eb 	.word	0x000007eb
 8011fc8:	080212f0 	.word	0x080212f0
 8011fcc:	08020a80 	.word	0x08020a80

08011fd0 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
err_t
tcp_keepalive(struct tcp_pcb *pcb)
{
 8011fd0:	b5b0      	push	{r4, r5, r7, lr}
 8011fd2:	b084      	sub	sp, #16
 8011fd4:	af00      	add	r7, sp, #0
 8011fd6:	6078      	str	r0, [r7, #4]
  err_t err;
  struct pbuf *p;
  u8_t optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
 8011fd8:	230a      	movs	r3, #10
 8011fda:	18fb      	adds	r3, r7, r3
 8011fdc:	2200      	movs	r2, #0
 8011fde:	701a      	strb	r2, [r3, #0]

  LWIP_ASSERT("tcp_keepalive: invalid pcb", pcb != NULL);
 8011fe0:	687b      	ldr	r3, [r7, #4]
 8011fe2:	2b00      	cmp	r3, #0
 8011fe4:	d105      	bne.n	8011ff2 <tcp_keepalive+0x22>
 8011fe6:	4b1b      	ldr	r3, [pc, #108]	; (8012054 <tcp_keepalive+0x84>)
 8011fe8:	4a1b      	ldr	r2, [pc, #108]	; (8012058 <tcp_keepalive+0x88>)
 8011fea:	491c      	ldr	r1, [pc, #112]	; (801205c <tcp_keepalive+0x8c>)
 8011fec:	481c      	ldr	r0, [pc, #112]	; (8012060 <tcp_keepalive+0x90>)
 8011fee:	f7f0 fdeb 	bl	8002bc8 <app_debug_rtt_raw>
  LWIP_DEBUGF(TCP_DEBUG, ("\n"));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
                          tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));

  p = tcp_output_alloc_header(pcb, optlen, 0, lwip_htonl(pcb->snd_nxt - 1));
 8011ff2:	230a      	movs	r3, #10
 8011ff4:	18fb      	adds	r3, r7, r3
 8011ff6:	781b      	ldrb	r3, [r3, #0]
 8011ff8:	b29c      	uxth	r4, r3
 8011ffa:	687b      	ldr	r3, [r7, #4]
 8011ffc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8011ffe:	3b01      	subs	r3, #1
 8012000:	0018      	movs	r0, r3
 8012002:	f7f4 ff8d 	bl	8006f20 <lwip_htonl>
 8012006:	0003      	movs	r3, r0
 8012008:	6878      	ldr	r0, [r7, #4]
 801200a:	2200      	movs	r2, #0
 801200c:	0021      	movs	r1, r4
 801200e:	f7ff fded 	bl	8011bec <tcp_output_alloc_header>
 8012012:	0003      	movs	r3, r0
 8012014:	60fb      	str	r3, [r7, #12]
  if (p == NULL) {
 8012016:	68fb      	ldr	r3, [r7, #12]
 8012018:	2b00      	cmp	r3, #0
 801201a:	d102      	bne.n	8012022 <tcp_keepalive+0x52>
    LWIP_DEBUGF(TCP_DEBUG,
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return ERR_MEM;
 801201c:	2301      	movs	r3, #1
 801201e:	425b      	negs	r3, r3
 8012020:	e013      	b.n	801204a <tcp_keepalive+0x7a>
  }
  tcp_output_fill_options(pcb, p, 0, 0);
 8012022:	68f9      	ldr	r1, [r7, #12]
 8012024:	6878      	ldr	r0, [r7, #4]
 8012026:	2300      	movs	r3, #0
 8012028:	2200      	movs	r2, #0
 801202a:	f7ff fe2b 	bl	8011c84 <tcp_output_fill_options>
  err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
 801202e:	687a      	ldr	r2, [r7, #4]
 8012030:	687b      	ldr	r3, [r7, #4]
 8012032:	3304      	adds	r3, #4
 8012034:	250b      	movs	r5, #11
 8012036:	197c      	adds	r4, r7, r5
 8012038:	68f9      	ldr	r1, [r7, #12]
 801203a:	6878      	ldr	r0, [r7, #4]
 801203c:	f7ff fe68 	bl	8011d10 <tcp_output_control_segment>
 8012040:	0003      	movs	r3, r0
 8012042:	7023      	strb	r3, [r4, #0]

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F" err %d.\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
  return err;
 8012044:	197b      	adds	r3, r7, r5
 8012046:	781b      	ldrb	r3, [r3, #0]
 8012048:	b25b      	sxtb	r3, r3
}
 801204a:	0018      	movs	r0, r3
 801204c:	46bd      	mov	sp, r7
 801204e:	b004      	add	sp, #16
 8012050:	bdb0      	pop	{r4, r5, r7, pc}
 8012052:	46c0      	nop			; (mov r8, r8)
 8012054:	08020a34 	.word	0x08020a34
 8012058:	00000825 	.word	0x00000825
 801205c:	08021310 	.word	0x08021310
 8012060:	08020a80 	.word	0x08020a80

08012064 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
err_t
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
 8012064:	b5b0      	push	{r4, r5, r7, lr}
 8012066:	b08a      	sub	sp, #40	; 0x28
 8012068:	af00      	add	r7, sp, #0
 801206a:	6078      	str	r0, [r7, #4]
  struct tcp_hdr *tcphdr;
  struct tcp_seg *seg;
  u16_t len;
  u8_t is_fin;
  u32_t snd_nxt;
  u8_t optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
 801206c:	2313      	movs	r3, #19
 801206e:	18fb      	adds	r3, r7, r3
 8012070:	2200      	movs	r2, #0
 8012072:	701a      	strb	r2, [r3, #0]

  LWIP_ASSERT("tcp_zero_window_probe: invalid pcb", pcb != NULL);
 8012074:	687b      	ldr	r3, [r7, #4]
 8012076:	2b00      	cmp	r3, #0
 8012078:	d106      	bne.n	8012088 <tcp_zero_window_probe+0x24>
 801207a:	4b68      	ldr	r3, [pc, #416]	; (801221c <tcp_zero_window_probe+0x1b8>)
 801207c:	2285      	movs	r2, #133	; 0x85
 801207e:	0112      	lsls	r2, r2, #4
 8012080:	4967      	ldr	r1, [pc, #412]	; (8012220 <tcp_zero_window_probe+0x1bc>)
 8012082:	4868      	ldr	r0, [pc, #416]	; (8012224 <tcp_zero_window_probe+0x1c0>)
 8012084:	f7f0 fda0 	bl	8002bc8 <app_debug_rtt_raw>
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
               tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));

  /* Only consider unsent, persist timer should be off when there is data in-flight */
  seg = pcb->unsent;
 8012088:	687b      	ldr	r3, [r7, #4]
 801208a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801208c:	627b      	str	r3, [r7, #36]	; 0x24
  if (seg == NULL) {
 801208e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012090:	2b00      	cmp	r3, #0
 8012092:	d101      	bne.n	8012098 <tcp_zero_window_probe+0x34>
    /* Not expected, persist timer should be off when the send buffer is empty */
    return ERR_OK;
 8012094:	2300      	movs	r3, #0
 8012096:	e0bc      	b.n	8012212 <tcp_zero_window_probe+0x1ae>

  /* increment probe count. NOTE: we record probe even if it fails
     to actually transmit due to an error. This ensures memory exhaustion/
     routing problem doesn't leave a zero-window pcb as an indefinite zombie.
     RTO mechanism has similar behavior, see pcb->nrtx */
  if (pcb->persist_probe < 0xFF) {
 8012098:	687b      	ldr	r3, [r7, #4]
 801209a:	22a6      	movs	r2, #166	; 0xa6
 801209c:	5c9b      	ldrb	r3, [r3, r2]
 801209e:	2bff      	cmp	r3, #255	; 0xff
 80120a0:	d007      	beq.n	80120b2 <tcp_zero_window_probe+0x4e>
    ++pcb->persist_probe;
 80120a2:	687b      	ldr	r3, [r7, #4]
 80120a4:	22a6      	movs	r2, #166	; 0xa6
 80120a6:	5c9b      	ldrb	r3, [r3, r2]
 80120a8:	3301      	adds	r3, #1
 80120aa:	b2d9      	uxtb	r1, r3
 80120ac:	687b      	ldr	r3, [r7, #4]
 80120ae:	22a6      	movs	r2, #166	; 0xa6
 80120b0:	5499      	strb	r1, [r3, r2]
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 80120b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80120b4:	691b      	ldr	r3, [r3, #16]
 80120b6:	7b1a      	ldrb	r2, [r3, #12]
 80120b8:	7b5b      	ldrb	r3, [r3, #13]
 80120ba:	021b      	lsls	r3, r3, #8
 80120bc:	4313      	orrs	r3, r2
 80120be:	b29b      	uxth	r3, r3
 80120c0:	0018      	movs	r0, r3
 80120c2:	f7f4 ff17 	bl	8006ef4 <lwip_htons>
 80120c6:	0003      	movs	r3, r0
 80120c8:	b2db      	uxtb	r3, r3
 80120ca:	001a      	movs	r2, r3
 80120cc:	2301      	movs	r3, #1
 80120ce:	4013      	ands	r3, r2
 80120d0:	d005      	beq.n	80120de <tcp_zero_window_probe+0x7a>
 80120d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80120d4:	891b      	ldrh	r3, [r3, #8]
 80120d6:	2b00      	cmp	r3, #0
 80120d8:	d101      	bne.n	80120de <tcp_zero_window_probe+0x7a>
 80120da:	2201      	movs	r2, #1
 80120dc:	e000      	b.n	80120e0 <tcp_zero_window_probe+0x7c>
 80120de:	2200      	movs	r2, #0
 80120e0:	2123      	movs	r1, #35	; 0x23
 80120e2:	187b      	adds	r3, r7, r1
 80120e4:	701a      	strb	r2, [r3, #0]
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;
 80120e6:	187b      	adds	r3, r7, r1
 80120e8:	781b      	ldrb	r3, [r3, #0]
 80120ea:	425a      	negs	r2, r3
 80120ec:	4153      	adcs	r3, r2
 80120ee:	b2da      	uxtb	r2, r3
 80120f0:	2020      	movs	r0, #32
 80120f2:	183b      	adds	r3, r7, r0
 80120f4:	801a      	strh	r2, [r3, #0]

  p = tcp_output_alloc_header(pcb, optlen, len, seg->tcphdr->seqno);
 80120f6:	2313      	movs	r3, #19
 80120f8:	18fb      	adds	r3, r7, r3
 80120fa:	781b      	ldrb	r3, [r3, #0]
 80120fc:	b29c      	uxth	r4, r3
 80120fe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012100:	691b      	ldr	r3, [r3, #16]
 8012102:	791a      	ldrb	r2, [r3, #4]
 8012104:	7959      	ldrb	r1, [r3, #5]
 8012106:	0209      	lsls	r1, r1, #8
 8012108:	430a      	orrs	r2, r1
 801210a:	7999      	ldrb	r1, [r3, #6]
 801210c:	0409      	lsls	r1, r1, #16
 801210e:	430a      	orrs	r2, r1
 8012110:	79db      	ldrb	r3, [r3, #7]
 8012112:	061b      	lsls	r3, r3, #24
 8012114:	4313      	orrs	r3, r2
 8012116:	0019      	movs	r1, r3
 8012118:	183b      	adds	r3, r7, r0
 801211a:	881a      	ldrh	r2, [r3, #0]
 801211c:	6878      	ldr	r0, [r7, #4]
 801211e:	000b      	movs	r3, r1
 8012120:	0021      	movs	r1, r4
 8012122:	f7ff fd63 	bl	8011bec <tcp_output_alloc_header>
 8012126:	0003      	movs	r3, r0
 8012128:	61fb      	str	r3, [r7, #28]
  if (p == NULL) {
 801212a:	69fb      	ldr	r3, [r7, #28]
 801212c:	2b00      	cmp	r3, #0
 801212e:	d102      	bne.n	8012136 <tcp_zero_window_probe+0xd2>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return ERR_MEM;
 8012130:	2301      	movs	r3, #1
 8012132:	425b      	negs	r3, r3
 8012134:	e06d      	b.n	8012212 <tcp_zero_window_probe+0x1ae>
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 8012136:	69fb      	ldr	r3, [r7, #28]
 8012138:	685b      	ldr	r3, [r3, #4]
 801213a:	61bb      	str	r3, [r7, #24]

  if (is_fin) {
 801213c:	2323      	movs	r3, #35	; 0x23
 801213e:	18fb      	adds	r3, r7, r3
 8012140:	781b      	ldrb	r3, [r3, #0]
 8012142:	2b00      	cmp	r3, #0
 8012144:	d026      	beq.n	8012194 <tcp_zero_window_probe+0x130>
    /* FIN segment, no data */
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
 8012146:	69bb      	ldr	r3, [r7, #24]
 8012148:	7b1a      	ldrb	r2, [r3, #12]
 801214a:	7b5b      	ldrb	r3, [r3, #13]
 801214c:	021b      	lsls	r3, r3, #8
 801214e:	4313      	orrs	r3, r2
 8012150:	b29b      	uxth	r3, r3
 8012152:	b21b      	sxth	r3, r3
 8012154:	4a34      	ldr	r2, [pc, #208]	; (8012228 <tcp_zero_window_probe+0x1c4>)
 8012156:	4013      	ands	r3, r2
 8012158:	b21c      	sxth	r4, r3
 801215a:	2011      	movs	r0, #17
 801215c:	f7f4 feca 	bl	8006ef4 <lwip_htons>
 8012160:	0003      	movs	r3, r0
 8012162:	b21b      	sxth	r3, r3
 8012164:	4323      	orrs	r3, r4
 8012166:	b21b      	sxth	r3, r3
 8012168:	b29a      	uxth	r2, r3
 801216a:	69bb      	ldr	r3, [r7, #24]
 801216c:	21ff      	movs	r1, #255	; 0xff
 801216e:	4011      	ands	r1, r2
 8012170:	000c      	movs	r4, r1
 8012172:	7b19      	ldrb	r1, [r3, #12]
 8012174:	2000      	movs	r0, #0
 8012176:	4001      	ands	r1, r0
 8012178:	1c08      	adds	r0, r1, #0
 801217a:	1c21      	adds	r1, r4, #0
 801217c:	4301      	orrs	r1, r0
 801217e:	7319      	strb	r1, [r3, #12]
 8012180:	0a12      	lsrs	r2, r2, #8
 8012182:	b290      	uxth	r0, r2
 8012184:	7b5a      	ldrb	r2, [r3, #13]
 8012186:	2100      	movs	r1, #0
 8012188:	400a      	ands	r2, r1
 801218a:	1c11      	adds	r1, r2, #0
 801218c:	1c02      	adds	r2, r0, #0
 801218e:	430a      	orrs	r2, r1
 8012190:	735a      	strb	r2, [r3, #13]
 8012192:	e010      	b.n	80121b6 <tcp_zero_window_probe+0x152>
  } else {
    /* Data segment, copy in one byte from the head of the unacked queue */
    char *d = ((char *)p->payload + TCP_HLEN);
 8012194:	69fb      	ldr	r3, [r7, #28]
 8012196:	685b      	ldr	r3, [r3, #4]
 8012198:	3314      	adds	r3, #20
 801219a:	617b      	str	r3, [r7, #20]
    /* Depending on whether the segment has already been sent (unacked) or not
       (unsent), seg->p->payload points to the IP header or TCP header.
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
 801219c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801219e:	6858      	ldr	r0, [r3, #4]
 80121a0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80121a2:	685b      	ldr	r3, [r3, #4]
 80121a4:	891a      	ldrh	r2, [r3, #8]
 80121a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80121a8:	891b      	ldrh	r3, [r3, #8]
 80121aa:	1ad3      	subs	r3, r2, r3
 80121ac:	b29b      	uxth	r3, r3
 80121ae:	6979      	ldr	r1, [r7, #20]
 80121b0:	2201      	movs	r2, #1
 80121b2:	f7f8 f94d 	bl	800a450 <pbuf_copy_partial>
  }

  /* The byte may be acknowledged without the window being opened. */
  snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + 1;
 80121b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80121b8:	691b      	ldr	r3, [r3, #16]
 80121ba:	791a      	ldrb	r2, [r3, #4]
 80121bc:	7959      	ldrb	r1, [r3, #5]
 80121be:	0209      	lsls	r1, r1, #8
 80121c0:	430a      	orrs	r2, r1
 80121c2:	7999      	ldrb	r1, [r3, #6]
 80121c4:	0409      	lsls	r1, r1, #16
 80121c6:	430a      	orrs	r2, r1
 80121c8:	79db      	ldrb	r3, [r3, #7]
 80121ca:	061b      	lsls	r3, r3, #24
 80121cc:	4313      	orrs	r3, r2
 80121ce:	0018      	movs	r0, r3
 80121d0:	f7f4 fea6 	bl	8006f20 <lwip_htonl>
 80121d4:	0003      	movs	r3, r0
 80121d6:	3301      	adds	r3, #1
 80121d8:	60fb      	str	r3, [r7, #12]
  if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 80121da:	687b      	ldr	r3, [r7, #4]
 80121dc:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80121de:	68fb      	ldr	r3, [r7, #12]
 80121e0:	1ad3      	subs	r3, r2, r3
 80121e2:	d502      	bpl.n	80121ea <tcp_zero_window_probe+0x186>
    pcb->snd_nxt = snd_nxt;
 80121e4:	687b      	ldr	r3, [r7, #4]
 80121e6:	68fa      	ldr	r2, [r7, #12]
 80121e8:	655a      	str	r2, [r3, #84]	; 0x54
  }
  tcp_output_fill_options(pcb, p, 0, 0);
 80121ea:	69f9      	ldr	r1, [r7, #28]
 80121ec:	6878      	ldr	r0, [r7, #4]
 80121ee:	2300      	movs	r3, #0
 80121f0:	2200      	movs	r2, #0
 80121f2:	f7ff fd47 	bl	8011c84 <tcp_output_fill_options>

  err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
 80121f6:	687a      	ldr	r2, [r7, #4]
 80121f8:	687b      	ldr	r3, [r7, #4]
 80121fa:	3304      	adds	r3, #4
 80121fc:	250b      	movs	r5, #11
 80121fe:	197c      	adds	r4, r7, r5
 8012200:	69f9      	ldr	r1, [r7, #28]
 8012202:	6878      	ldr	r0, [r7, #4]
 8012204:	f7ff fd84 	bl	8011d10 <tcp_output_control_segment>
 8012208:	0003      	movs	r3, r0
 801220a:	7023      	strb	r3, [r4, #0]

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F" err %d.\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
  return err;
 801220c:	197b      	adds	r3, r7, r5
 801220e:	781b      	ldrb	r3, [r3, #0]
 8012210:	b25b      	sxtb	r3, r3
}
 8012212:	0018      	movs	r0, r3
 8012214:	46bd      	mov	sp, r7
 8012216:	b00a      	add	sp, #40	; 0x28
 8012218:	bdb0      	pop	{r4, r5, r7, pc}
 801221a:	46c0      	nop			; (mov r8, r8)
 801221c:	08020a34 	.word	0x08020a34
 8012220:	0802132c 	.word	0x0802132c
 8012224:	08020a80 	.word	0x08020a80
 8012228:	ffffc0ff 	.word	0xffffc0ff

0801222c <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
 801222c:	b580      	push	{r7, lr}
 801222e:	b082      	sub	sp, #8
 8012230:	af00      	add	r7, sp, #0
 8012232:	6078      	str	r0, [r7, #4]
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
 8012234:	f7f8 fcd4 	bl	800abe0 <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
 8012238:	4b0b      	ldr	r3, [pc, #44]	; (8012268 <tcpip_tcp_timer+0x3c>)
 801223a:	681b      	ldr	r3, [r3, #0]
 801223c:	2b00      	cmp	r3, #0
 801223e:	d103      	bne.n	8012248 <tcpip_tcp_timer+0x1c>
 8012240:	4b0a      	ldr	r3, [pc, #40]	; (801226c <tcpip_tcp_timer+0x40>)
 8012242:	681b      	ldr	r3, [r3, #0]
 8012244:	2b00      	cmp	r3, #0
 8012246:	d007      	beq.n	8012258 <tcpip_tcp_timer+0x2c>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 8012248:	4909      	ldr	r1, [pc, #36]	; (8012270 <tcpip_tcp_timer+0x44>)
 801224a:	23fa      	movs	r3, #250	; 0xfa
 801224c:	005b      	lsls	r3, r3, #1
 801224e:	2200      	movs	r2, #0
 8012250:	0018      	movs	r0, r3
 8012252:	f000 f8a7 	bl	80123a4 <sys_timeout>
 8012256:	e003      	b.n	8012260 <tcpip_tcp_timer+0x34>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
 8012258:	4b06      	ldr	r3, [pc, #24]	; (8012274 <tcpip_tcp_timer+0x48>)
 801225a:	2200      	movs	r2, #0
 801225c:	601a      	str	r2, [r3, #0]
  }
}
 801225e:	46c0      	nop			; (mov r8, r8)
 8012260:	46c0      	nop			; (mov r8, r8)
 8012262:	46bd      	mov	sp, r7
 8012264:	b002      	add	sp, #8
 8012266:	bd80      	pop	{r7, pc}
 8012268:	20002b3c 	.word	0x20002b3c
 801226c:	20002b4c 	.word	0x20002b4c
 8012270:	0801222d 	.word	0x0801222d
 8012274:	200017d4 	.word	0x200017d4

08012278 <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
 8012278:	b580      	push	{r7, lr}
 801227a:	af00      	add	r7, sp, #0
  LWIP_ASSERT_CORE_LOCKED();

  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
 801227c:	4b0c      	ldr	r3, [pc, #48]	; (80122b0 <tcp_timer_needed+0x38>)
 801227e:	681b      	ldr	r3, [r3, #0]
 8012280:	2b00      	cmp	r3, #0
 8012282:	d111      	bne.n	80122a8 <tcp_timer_needed+0x30>
 8012284:	4b0b      	ldr	r3, [pc, #44]	; (80122b4 <tcp_timer_needed+0x3c>)
 8012286:	681b      	ldr	r3, [r3, #0]
 8012288:	2b00      	cmp	r3, #0
 801228a:	d103      	bne.n	8012294 <tcp_timer_needed+0x1c>
 801228c:	4b0a      	ldr	r3, [pc, #40]	; (80122b8 <tcp_timer_needed+0x40>)
 801228e:	681b      	ldr	r3, [r3, #0]
 8012290:	2b00      	cmp	r3, #0
 8012292:	d009      	beq.n	80122a8 <tcp_timer_needed+0x30>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
 8012294:	4b06      	ldr	r3, [pc, #24]	; (80122b0 <tcp_timer_needed+0x38>)
 8012296:	2201      	movs	r2, #1
 8012298:	601a      	str	r2, [r3, #0]
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 801229a:	4908      	ldr	r1, [pc, #32]	; (80122bc <tcp_timer_needed+0x44>)
 801229c:	23fa      	movs	r3, #250	; 0xfa
 801229e:	005b      	lsls	r3, r3, #1
 80122a0:	2200      	movs	r2, #0
 80122a2:	0018      	movs	r0, r3
 80122a4:	f000 f87e 	bl	80123a4 <sys_timeout>
  }
}
 80122a8:	46c0      	nop			; (mov r8, r8)
 80122aa:	46bd      	mov	sp, r7
 80122ac:	bd80      	pop	{r7, pc}
 80122ae:	46c0      	nop			; (mov r8, r8)
 80122b0:	200017d4 	.word	0x200017d4
 80122b4:	20002b3c 	.word	0x20002b3c
 80122b8:	20002b4c 	.word	0x20002b4c
 80122bc:	0801222d 	.word	0x0801222d

080122c0 <sys_timeout_abs>:
#if LWIP_DEBUG_TIMERNAMES
sys_timeout_abs(u32_t abs_time, sys_timeout_handler handler, void *arg, const char *handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
sys_timeout_abs(u32_t abs_time, sys_timeout_handler handler, void *arg)
#endif
{
 80122c0:	b580      	push	{r7, lr}
 80122c2:	b086      	sub	sp, #24
 80122c4:	af00      	add	r7, sp, #0
 80122c6:	60f8      	str	r0, [r7, #12]
 80122c8:	60b9      	str	r1, [r7, #8]
 80122ca:	607a      	str	r2, [r7, #4]
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
 80122cc:	2004      	movs	r0, #4
 80122ce:	f7f6 fe95 	bl	8008ffc <memp_malloc>
 80122d2:	0003      	movs	r3, r0
 80122d4:	613b      	str	r3, [r7, #16]
  if (timeout == NULL) {
 80122d6:	693b      	ldr	r3, [r7, #16]
 80122d8:	2b00      	cmp	r3, #0
 80122da:	d109      	bne.n	80122f0 <sys_timeout_abs+0x30>
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
 80122dc:	693b      	ldr	r3, [r7, #16]
 80122de:	2b00      	cmp	r3, #0
 80122e0:	d153      	bne.n	801238a <sys_timeout_abs+0xca>
 80122e2:	4b2c      	ldr	r3, [pc, #176]	; (8012394 <sys_timeout_abs+0xd4>)
 80122e4:	492c      	ldr	r1, [pc, #176]	; (8012398 <sys_timeout_abs+0xd8>)
 80122e6:	482d      	ldr	r0, [pc, #180]	; (801239c <sys_timeout_abs+0xdc>)
 80122e8:	22be      	movs	r2, #190	; 0xbe
 80122ea:	f7f0 fc6d 	bl	8002bc8 <app_debug_rtt_raw>
    return;
 80122ee:	e04c      	b.n	801238a <sys_timeout_abs+0xca>
  }

  timeout->next = NULL;
 80122f0:	693b      	ldr	r3, [r7, #16]
 80122f2:	2200      	movs	r2, #0
 80122f4:	601a      	str	r2, [r3, #0]
  timeout->h = handler;
 80122f6:	693b      	ldr	r3, [r7, #16]
 80122f8:	68ba      	ldr	r2, [r7, #8]
 80122fa:	609a      	str	r2, [r3, #8]
  timeout->arg = arg;
 80122fc:	693b      	ldr	r3, [r7, #16]
 80122fe:	687a      	ldr	r2, [r7, #4]
 8012300:	60da      	str	r2, [r3, #12]
  timeout->time = abs_time;
 8012302:	693b      	ldr	r3, [r7, #16]
 8012304:	68fa      	ldr	r2, [r7, #12]
 8012306:	605a      	str	r2, [r3, #4]
  timeout->handler_name = handler_name;
  LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p abs_time=%"U32_F" handler=%s arg=%p\n",
                             (void *)timeout, abs_time, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

  if (next_timeout == NULL) {
 8012308:	4b25      	ldr	r3, [pc, #148]	; (80123a0 <sys_timeout_abs+0xe0>)
 801230a:	681b      	ldr	r3, [r3, #0]
 801230c:	2b00      	cmp	r3, #0
 801230e:	d103      	bne.n	8012318 <sys_timeout_abs+0x58>
    next_timeout = timeout;
 8012310:	4b23      	ldr	r3, [pc, #140]	; (80123a0 <sys_timeout_abs+0xe0>)
 8012312:	693a      	ldr	r2, [r7, #16]
 8012314:	601a      	str	r2, [r3, #0]
    return;
 8012316:	e039      	b.n	801238c <sys_timeout_abs+0xcc>
  }
  if (TIME_LESS_THAN(timeout->time, next_timeout->time)) {
 8012318:	693b      	ldr	r3, [r7, #16]
 801231a:	685a      	ldr	r2, [r3, #4]
 801231c:	4b20      	ldr	r3, [pc, #128]	; (80123a0 <sys_timeout_abs+0xe0>)
 801231e:	681b      	ldr	r3, [r3, #0]
 8012320:	685b      	ldr	r3, [r3, #4]
 8012322:	1ad3      	subs	r3, r2, r3
 8012324:	0fdb      	lsrs	r3, r3, #31
 8012326:	1c1a      	adds	r2, r3, #0
 8012328:	2301      	movs	r3, #1
 801232a:	4013      	ands	r3, r2
 801232c:	b2db      	uxtb	r3, r3
 801232e:	2b00      	cmp	r3, #0
 8012330:	d007      	beq.n	8012342 <sys_timeout_abs+0x82>
    timeout->next = next_timeout;
 8012332:	4b1b      	ldr	r3, [pc, #108]	; (80123a0 <sys_timeout_abs+0xe0>)
 8012334:	681a      	ldr	r2, [r3, #0]
 8012336:	693b      	ldr	r3, [r7, #16]
 8012338:	601a      	str	r2, [r3, #0]
    next_timeout = timeout;
 801233a:	4b19      	ldr	r3, [pc, #100]	; (80123a0 <sys_timeout_abs+0xe0>)
 801233c:	693a      	ldr	r2, [r7, #16]
 801233e:	601a      	str	r2, [r3, #0]
 8012340:	e024      	b.n	801238c <sys_timeout_abs+0xcc>
  } else {
    for (t = next_timeout; t != NULL; t = t->next) {
 8012342:	4b17      	ldr	r3, [pc, #92]	; (80123a0 <sys_timeout_abs+0xe0>)
 8012344:	681b      	ldr	r3, [r3, #0]
 8012346:	617b      	str	r3, [r7, #20]
 8012348:	e01b      	b.n	8012382 <sys_timeout_abs+0xc2>
      if ((t->next == NULL) || TIME_LESS_THAN(timeout->time, t->next->time)) {
 801234a:	697b      	ldr	r3, [r7, #20]
 801234c:	681b      	ldr	r3, [r3, #0]
 801234e:	2b00      	cmp	r3, #0
 8012350:	d00c      	beq.n	801236c <sys_timeout_abs+0xac>
 8012352:	693b      	ldr	r3, [r7, #16]
 8012354:	685a      	ldr	r2, [r3, #4]
 8012356:	697b      	ldr	r3, [r7, #20]
 8012358:	681b      	ldr	r3, [r3, #0]
 801235a:	685b      	ldr	r3, [r3, #4]
 801235c:	1ad3      	subs	r3, r2, r3
 801235e:	0fdb      	lsrs	r3, r3, #31
 8012360:	1c1a      	adds	r2, r3, #0
 8012362:	2301      	movs	r3, #1
 8012364:	4013      	ands	r3, r2
 8012366:	b2db      	uxtb	r3, r3
 8012368:	2b00      	cmp	r3, #0
 801236a:	d007      	beq.n	801237c <sys_timeout_abs+0xbc>
        timeout->next = t->next;
 801236c:	697b      	ldr	r3, [r7, #20]
 801236e:	681a      	ldr	r2, [r3, #0]
 8012370:	693b      	ldr	r3, [r7, #16]
 8012372:	601a      	str	r2, [r3, #0]
        t->next = timeout;
 8012374:	697b      	ldr	r3, [r7, #20]
 8012376:	693a      	ldr	r2, [r7, #16]
 8012378:	601a      	str	r2, [r3, #0]
        break;
 801237a:	e007      	b.n	801238c <sys_timeout_abs+0xcc>
    for (t = next_timeout; t != NULL; t = t->next) {
 801237c:	697b      	ldr	r3, [r7, #20]
 801237e:	681b      	ldr	r3, [r3, #0]
 8012380:	617b      	str	r3, [r7, #20]
 8012382:	697b      	ldr	r3, [r7, #20]
 8012384:	2b00      	cmp	r3, #0
 8012386:	d1e0      	bne.n	801234a <sys_timeout_abs+0x8a>
 8012388:	e000      	b.n	801238c <sys_timeout_abs+0xcc>
    return;
 801238a:	46c0      	nop			; (mov r8, r8)
      }
    }
  }
}
 801238c:	46bd      	mov	sp, r7
 801238e:	b006      	add	sp, #24
 8012390:	bd80      	pop	{r7, pc}
 8012392:	46c0      	nop			; (mov r8, r8)
 8012394:	08021350 	.word	0x08021350
 8012398:	0802137c 	.word	0x0802137c
 801239c:	080213bc 	.word	0x080213bc
 80123a0:	200017cc 	.word	0x200017cc

080123a4 <sys_timeout>:
sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char *handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
void
sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
 80123a4:	b580      	push	{r7, lr}
 80123a6:	b086      	sub	sp, #24
 80123a8:	af00      	add	r7, sp, #0
 80123aa:	60f8      	str	r0, [r7, #12]
 80123ac:	60b9      	str	r1, [r7, #8]
 80123ae:	607a      	str	r2, [r7, #4]
  u32_t next_timeout_time;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ASSERT("Timeout time too long, max is LWIP_UINT32_MAX/4 msecs", msecs <= (LWIP_UINT32_MAX / 4));
 80123b0:	68fa      	ldr	r2, [r7, #12]
 80123b2:	2380      	movs	r3, #128	; 0x80
 80123b4:	05db      	lsls	r3, r3, #23
 80123b6:	429a      	cmp	r2, r3
 80123b8:	d306      	bcc.n	80123c8 <sys_timeout+0x24>
 80123ba:	4b0b      	ldr	r3, [pc, #44]	; (80123e8 <sys_timeout+0x44>)
 80123bc:	222a      	movs	r2, #42	; 0x2a
 80123be:	32ff      	adds	r2, #255	; 0xff
 80123c0:	490a      	ldr	r1, [pc, #40]	; (80123ec <sys_timeout+0x48>)
 80123c2:	480b      	ldr	r0, [pc, #44]	; (80123f0 <sys_timeout+0x4c>)
 80123c4:	f7f0 fc00 	bl	8002bc8 <app_debug_rtt_raw>

  next_timeout_time = (u32_t)(sys_now() + msecs); /* overflow handled by TIME_LESS_THAN macro */ 
 80123c8:	f00a fd2e 	bl	801ce28 <sys_now>
 80123cc:	0002      	movs	r2, r0
 80123ce:	68fb      	ldr	r3, [r7, #12]
 80123d0:	189b      	adds	r3, r3, r2
 80123d2:	617b      	str	r3, [r7, #20]

#if LWIP_DEBUG_TIMERNAMES
  sys_timeout_abs(next_timeout_time, handler, arg, handler_name);
#else
  sys_timeout_abs(next_timeout_time, handler, arg);
 80123d4:	687a      	ldr	r2, [r7, #4]
 80123d6:	68b9      	ldr	r1, [r7, #8]
 80123d8:	697b      	ldr	r3, [r7, #20]
 80123da:	0018      	movs	r0, r3
 80123dc:	f7ff ff70 	bl	80122c0 <sys_timeout_abs>
#endif
}
 80123e0:	46c0      	nop			; (mov r8, r8)
 80123e2:	46bd      	mov	sp, r7
 80123e4:	b006      	add	sp, #24
 80123e6:	bd80      	pop	{r7, pc}
 80123e8:	08021350 	.word	0x08021350
 80123ec:	080213e8 	.word	0x080213e8
 80123f0:	080213bc 	.word	0x080213bc

080123f4 <sys_untimeout>:
 * @param handler callback function that would be called by the timeout
 * @param arg callback argument that would be passed to handler
*/
void
sys_untimeout(sys_timeout_handler handler, void *arg)
{
 80123f4:	b580      	push	{r7, lr}
 80123f6:	b084      	sub	sp, #16
 80123f8:	af00      	add	r7, sp, #0
 80123fa:	6078      	str	r0, [r7, #4]
 80123fc:	6039      	str	r1, [r7, #0]
  struct sys_timeo *prev_t, *t;

  LWIP_ASSERT_CORE_LOCKED();

  if (next_timeout == NULL) {
 80123fe:	4b19      	ldr	r3, [pc, #100]	; (8012464 <sys_untimeout+0x70>)
 8012400:	681b      	ldr	r3, [r3, #0]
 8012402:	2b00      	cmp	r3, #0
 8012404:	d02a      	beq.n	801245c <sys_untimeout+0x68>
    return;
  }

  for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
 8012406:	4b17      	ldr	r3, [pc, #92]	; (8012464 <sys_untimeout+0x70>)
 8012408:	681b      	ldr	r3, [r3, #0]
 801240a:	60bb      	str	r3, [r7, #8]
 801240c:	2300      	movs	r3, #0
 801240e:	60fb      	str	r3, [r7, #12]
 8012410:	e020      	b.n	8012454 <sys_untimeout+0x60>
    if ((t->h == handler) && (t->arg == arg)) {
 8012412:	68bb      	ldr	r3, [r7, #8]
 8012414:	689b      	ldr	r3, [r3, #8]
 8012416:	687a      	ldr	r2, [r7, #4]
 8012418:	429a      	cmp	r2, r3
 801241a:	d116      	bne.n	801244a <sys_untimeout+0x56>
 801241c:	68bb      	ldr	r3, [r7, #8]
 801241e:	68db      	ldr	r3, [r3, #12]
 8012420:	683a      	ldr	r2, [r7, #0]
 8012422:	429a      	cmp	r2, r3
 8012424:	d111      	bne.n	801244a <sys_untimeout+0x56>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL) {
 8012426:	68fb      	ldr	r3, [r7, #12]
 8012428:	2b00      	cmp	r3, #0
 801242a:	d104      	bne.n	8012436 <sys_untimeout+0x42>
        next_timeout = t->next;
 801242c:	68bb      	ldr	r3, [r7, #8]
 801242e:	681a      	ldr	r2, [r3, #0]
 8012430:	4b0c      	ldr	r3, [pc, #48]	; (8012464 <sys_untimeout+0x70>)
 8012432:	601a      	str	r2, [r3, #0]
 8012434:	e003      	b.n	801243e <sys_untimeout+0x4a>
      } else {
        prev_t->next = t->next;
 8012436:	68bb      	ldr	r3, [r7, #8]
 8012438:	681a      	ldr	r2, [r3, #0]
 801243a:	68fb      	ldr	r3, [r7, #12]
 801243c:	601a      	str	r2, [r3, #0]
      }
      memp_free(MEMP_SYS_TIMEOUT, t);
 801243e:	68bb      	ldr	r3, [r7, #8]
 8012440:	0019      	movs	r1, r3
 8012442:	2004      	movs	r0, #4
 8012444:	f7f6 fe4a 	bl	80090dc <memp_free>
      return;
 8012448:	e009      	b.n	801245e <sys_untimeout+0x6a>
  for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
 801244a:	68bb      	ldr	r3, [r7, #8]
 801244c:	60fb      	str	r3, [r7, #12]
 801244e:	68bb      	ldr	r3, [r7, #8]
 8012450:	681b      	ldr	r3, [r3, #0]
 8012452:	60bb      	str	r3, [r7, #8]
 8012454:	68bb      	ldr	r3, [r7, #8]
 8012456:	2b00      	cmp	r3, #0
 8012458:	d1db      	bne.n	8012412 <sys_untimeout+0x1e>
    }
  }
  return;
 801245a:	e000      	b.n	801245e <sys_untimeout+0x6a>
    return;
 801245c:	46c0      	nop			; (mov r8, r8)
}
 801245e:	46bd      	mov	sp, r7
 8012460:	b004      	add	sp, #16
 8012462:	bd80      	pop	{r7, pc}
 8012464:	200017cc 	.word	0x200017cc

08012468 <sys_check_timeouts>:
 *
 * Must be called periodically from your main loop.
 */
void
sys_check_timeouts(void)
{
 8012468:	b580      	push	{r7, lr}
 801246a:	b084      	sub	sp, #16
 801246c:	af00      	add	r7, sp, #0
  u32_t now;

  LWIP_ASSERT_CORE_LOCKED();

  /* Process only timers expired at the start of the function. */
  now = sys_now();
 801246e:	f00a fcdb 	bl	801ce28 <sys_now>
 8012472:	0003      	movs	r3, r0
 8012474:	60fb      	str	r3, [r7, #12]
  do {
    struct sys_timeo *tmptimeout;
    sys_timeout_handler handler;
    void *arg;

    PBUF_CHECK_FREE_OOSEQ();
 8012476:	4b1c      	ldr	r3, [pc, #112]	; (80124e8 <sys_check_timeouts+0x80>)
 8012478:	781b      	ldrb	r3, [r3, #0]
 801247a:	b2db      	uxtb	r3, r3
 801247c:	2b00      	cmp	r3, #0
 801247e:	d001      	beq.n	8012484 <sys_check_timeouts+0x1c>
 8012480:	f7f7 f94c 	bl	800971c <pbuf_free_ooseq>

    tmptimeout = next_timeout;
 8012484:	4b19      	ldr	r3, [pc, #100]	; (80124ec <sys_check_timeouts+0x84>)
 8012486:	681b      	ldr	r3, [r3, #0]
 8012488:	60bb      	str	r3, [r7, #8]
    if (tmptimeout == NULL) {
 801248a:	68bb      	ldr	r3, [r7, #8]
 801248c:	2b00      	cmp	r3, #0
 801248e:	d025      	beq.n	80124dc <sys_check_timeouts+0x74>
      return;
    }

    if (TIME_LESS_THAN(now, tmptimeout->time)) {
 8012490:	68bb      	ldr	r3, [r7, #8]
 8012492:	685b      	ldr	r3, [r3, #4]
 8012494:	68fa      	ldr	r2, [r7, #12]
 8012496:	1ad3      	subs	r3, r2, r3
 8012498:	0fdb      	lsrs	r3, r3, #31
 801249a:	1c1a      	adds	r2, r3, #0
 801249c:	2301      	movs	r3, #1
 801249e:	4013      	ands	r3, r2
 80124a0:	b2db      	uxtb	r3, r3
 80124a2:	2b00      	cmp	r3, #0
 80124a4:	d11c      	bne.n	80124e0 <sys_check_timeouts+0x78>
      return;
    }

    /* Timeout has expired */
    next_timeout = tmptimeout->next;
 80124a6:	68bb      	ldr	r3, [r7, #8]
 80124a8:	681a      	ldr	r2, [r3, #0]
 80124aa:	4b10      	ldr	r3, [pc, #64]	; (80124ec <sys_check_timeouts+0x84>)
 80124ac:	601a      	str	r2, [r3, #0]
    handler = tmptimeout->h;
 80124ae:	68bb      	ldr	r3, [r7, #8]
 80124b0:	689b      	ldr	r3, [r3, #8]
 80124b2:	607b      	str	r3, [r7, #4]
    arg = tmptimeout->arg;
 80124b4:	68bb      	ldr	r3, [r7, #8]
 80124b6:	68db      	ldr	r3, [r3, #12]
 80124b8:	603b      	str	r3, [r7, #0]
    current_timeout_due_time = tmptimeout->time;
 80124ba:	68bb      	ldr	r3, [r7, #8]
 80124bc:	685a      	ldr	r2, [r3, #4]
 80124be:	4b0c      	ldr	r3, [pc, #48]	; (80124f0 <sys_check_timeouts+0x88>)
 80124c0:	601a      	str	r2, [r3, #0]
    if (handler != NULL) {
      LWIP_DEBUGF(TIMERS_DEBUG, ("sct calling h=%s t=%"U32_F" arg=%p\n",
                                 tmptimeout->handler_name, sys_now() - tmptimeout->time, arg));
    }
#endif /* LWIP_DEBUG_TIMERNAMES */
    memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
 80124c2:	68bb      	ldr	r3, [r7, #8]
 80124c4:	0019      	movs	r1, r3
 80124c6:	2004      	movs	r0, #4
 80124c8:	f7f6 fe08 	bl	80090dc <memp_free>
    if (handler != NULL) {
 80124cc:	687b      	ldr	r3, [r7, #4]
 80124ce:	2b00      	cmp	r3, #0
 80124d0:	d0d1      	beq.n	8012476 <sys_check_timeouts+0xe>
      handler(arg);
 80124d2:	683a      	ldr	r2, [r7, #0]
 80124d4:	687b      	ldr	r3, [r7, #4]
 80124d6:	0010      	movs	r0, r2
 80124d8:	4798      	blx	r3
  do {
 80124da:	e7cc      	b.n	8012476 <sys_check_timeouts+0xe>
      return;
 80124dc:	46c0      	nop			; (mov r8, r8)
 80124de:	e000      	b.n	80124e2 <sys_check_timeouts+0x7a>
      return;
 80124e0:	46c0      	nop			; (mov r8, r8)
    }
    LWIP_TCPIP_THREAD_ALIVE();

    /* Repeat until all expired timers have been called */
  } while (1);
}
 80124e2:	46bd      	mov	sp, r7
 80124e4:	b004      	add	sp, #16
 80124e6:	bd80      	pop	{r7, pc}
 80124e8:	20002b34 	.word	0x20002b34
 80124ec:	200017cc 	.word	0x200017cc
 80124f0:	200017d0 	.word	0x200017d0

080124f4 <udp_new_port>:
 *
 * @return a new (free) local UDP port number
 */
static u16_t
udp_new_port(void)
{
 80124f4:	b580      	push	{r7, lr}
 80124f6:	b082      	sub	sp, #8
 80124f8:	af00      	add	r7, sp, #0
  u16_t n = 0;
 80124fa:	1dbb      	adds	r3, r7, #6
 80124fc:	2200      	movs	r2, #0
 80124fe:	801a      	strh	r2, [r3, #0]
  struct udp_pcb *pcb;

again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
 8012500:	4b17      	ldr	r3, [pc, #92]	; (8012560 <udp_new_port+0x6c>)
 8012502:	881b      	ldrh	r3, [r3, #0]
 8012504:	1c5a      	adds	r2, r3, #1
 8012506:	b291      	uxth	r1, r2
 8012508:	4a15      	ldr	r2, [pc, #84]	; (8012560 <udp_new_port+0x6c>)
 801250a:	8011      	strh	r1, [r2, #0]
 801250c:	4a15      	ldr	r2, [pc, #84]	; (8012564 <udp_new_port+0x70>)
 801250e:	4293      	cmp	r3, r2
 8012510:	d102      	bne.n	8012518 <udp_new_port+0x24>
    udp_port = UDP_LOCAL_PORT_RANGE_START;
 8012512:	4b13      	ldr	r3, [pc, #76]	; (8012560 <udp_new_port+0x6c>)
 8012514:	4a14      	ldr	r2, [pc, #80]	; (8012568 <udp_new_port+0x74>)
 8012516:	801a      	strh	r2, [r3, #0]
  }
  /* Check all PCBs. */
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8012518:	4b14      	ldr	r3, [pc, #80]	; (801256c <udp_new_port+0x78>)
 801251a:	681b      	ldr	r3, [r3, #0]
 801251c:	603b      	str	r3, [r7, #0]
 801251e:	e015      	b.n	801254c <udp_new_port+0x58>
    if (pcb->local_port == udp_port) {
 8012520:	683b      	ldr	r3, [r7, #0]
 8012522:	8ada      	ldrh	r2, [r3, #22]
 8012524:	4b0e      	ldr	r3, [pc, #56]	; (8012560 <udp_new_port+0x6c>)
 8012526:	881b      	ldrh	r3, [r3, #0]
 8012528:	429a      	cmp	r2, r3
 801252a:	d10c      	bne.n	8012546 <udp_new_port+0x52>
      if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
 801252c:	1dbb      	adds	r3, r7, #6
 801252e:	1dba      	adds	r2, r7, #6
 8012530:	8812      	ldrh	r2, [r2, #0]
 8012532:	3201      	adds	r2, #1
 8012534:	801a      	strh	r2, [r3, #0]
 8012536:	1dbb      	adds	r3, r7, #6
 8012538:	881a      	ldrh	r2, [r3, #0]
 801253a:	2380      	movs	r3, #128	; 0x80
 801253c:	01db      	lsls	r3, r3, #7
 801253e:	429a      	cmp	r2, r3
 8012540:	d3de      	bcc.n	8012500 <udp_new_port+0xc>
        return 0;
 8012542:	2300      	movs	r3, #0
 8012544:	e007      	b.n	8012556 <udp_new_port+0x62>
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8012546:	683b      	ldr	r3, [r7, #0]
 8012548:	691b      	ldr	r3, [r3, #16]
 801254a:	603b      	str	r3, [r7, #0]
 801254c:	683b      	ldr	r3, [r7, #0]
 801254e:	2b00      	cmp	r3, #0
 8012550:	d1e6      	bne.n	8012520 <udp_new_port+0x2c>
      }
      goto again;
    }
  }
  return udp_port;
 8012552:	4b03      	ldr	r3, [pc, #12]	; (8012560 <udp_new_port+0x6c>)
 8012554:	881b      	ldrh	r3, [r3, #0]
}
 8012556:	0018      	movs	r0, r3
 8012558:	46bd      	mov	sp, r7
 801255a:	b002      	add	sp, #8
 801255c:	bd80      	pop	{r7, pc}
 801255e:	46c0      	nop			; (mov r8, r8)
 8012560:	20000020 	.word	0x20000020
 8012564:	0000ffff 	.word	0x0000ffff
 8012568:	ffffc000 	.word	0xffffc000
 801256c:	20002b54 	.word	0x20002b54

08012570 <udp_input_local_match>:
 * @param broadcast 1 if his is an IPv4 broadcast (global or subnet-only), 0 otherwise (only used for IPv4)
 * @return 1 on match, 0 otherwise
 */
static u8_t
udp_input_local_match(struct udp_pcb *pcb, struct netif *inp, u8_t broadcast)
{
 8012570:	b580      	push	{r7, lr}
 8012572:	b084      	sub	sp, #16
 8012574:	af00      	add	r7, sp, #0
 8012576:	60f8      	str	r0, [r7, #12]
 8012578:	60b9      	str	r1, [r7, #8]
 801257a:	1dfb      	adds	r3, r7, #7
 801257c:	701a      	strb	r2, [r3, #0]
  LWIP_UNUSED_ARG(inp);       /* in IPv6 only case */
  LWIP_UNUSED_ARG(broadcast); /* in IPv6 only case */

  LWIP_ASSERT("udp_input_local_match: invalid pcb", pcb != NULL);
 801257e:	68fb      	ldr	r3, [r7, #12]
 8012580:	2b00      	cmp	r3, #0
 8012582:	d105      	bne.n	8012590 <udp_input_local_match+0x20>
 8012584:	4b26      	ldr	r3, [pc, #152]	; (8012620 <udp_input_local_match+0xb0>)
 8012586:	4927      	ldr	r1, [pc, #156]	; (8012624 <udp_input_local_match+0xb4>)
 8012588:	4827      	ldr	r0, [pc, #156]	; (8012628 <udp_input_local_match+0xb8>)
 801258a:	2287      	movs	r2, #135	; 0x87
 801258c:	f7f0 fb1c 	bl	8002bc8 <app_debug_rtt_raw>
  LWIP_ASSERT("udp_input_local_match: invalid netif", inp != NULL);
 8012590:	68bb      	ldr	r3, [r7, #8]
 8012592:	2b00      	cmp	r3, #0
 8012594:	d105      	bne.n	80125a2 <udp_input_local_match+0x32>
 8012596:	4b22      	ldr	r3, [pc, #136]	; (8012620 <udp_input_local_match+0xb0>)
 8012598:	4924      	ldr	r1, [pc, #144]	; (801262c <udp_input_local_match+0xbc>)
 801259a:	4823      	ldr	r0, [pc, #140]	; (8012628 <udp_input_local_match+0xb8>)
 801259c:	2288      	movs	r2, #136	; 0x88
 801259e:	f7f0 fb13 	bl	8002bc8 <app_debug_rtt_raw>

  /* check if PCB is bound to specific netif */
  if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 80125a2:	68fb      	ldr	r3, [r7, #12]
 80125a4:	7a1b      	ldrb	r3, [r3, #8]
 80125a6:	2b00      	cmp	r3, #0
 80125a8:	d00b      	beq.n	80125c2 <udp_input_local_match+0x52>
      (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 80125aa:	68fb      	ldr	r3, [r7, #12]
 80125ac:	7a1a      	ldrb	r2, [r3, #8]
 80125ae:	4b20      	ldr	r3, [pc, #128]	; (8012630 <udp_input_local_match+0xc0>)
 80125b0:	685b      	ldr	r3, [r3, #4]
 80125b2:	2134      	movs	r1, #52	; 0x34
 80125b4:	5c5b      	ldrb	r3, [r3, r1]
 80125b6:	3301      	adds	r3, #1
 80125b8:	b2db      	uxtb	r3, r3
  if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 80125ba:	429a      	cmp	r2, r3
 80125bc:	d001      	beq.n	80125c2 <udp_input_local_match+0x52>
    return 0;
 80125be:	2300      	movs	r3, #0
 80125c0:	e02a      	b.n	8012618 <udp_input_local_match+0xa8>
  /* Only need to check PCB if incoming IP version matches PCB IP version */
  if (IP_ADDR_PCB_VERSION_MATCH_EXACT(pcb, ip_current_dest_addr())) {
#if LWIP_IPV4
    /* Special case: IPv4 broadcast: all or broadcasts in my subnet
     * Note: broadcast variable can only be 1 if it is an IPv4 broadcast */
    if (broadcast != 0) {
 80125c2:	1dfb      	adds	r3, r7, #7
 80125c4:	781b      	ldrb	r3, [r3, #0]
 80125c6:	2b00      	cmp	r3, #0
 80125c8:	d016      	beq.n	80125f8 <udp_input_local_match+0x88>
#if IP_SOF_BROADCAST_RECV
      if (ip_get_option(pcb, SOF_BROADCAST))
#endif /* IP_SOF_BROADCAST_RECV */
      {
        if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 80125ca:	68fb      	ldr	r3, [r7, #12]
 80125cc:	2b00      	cmp	r3, #0
 80125ce:	d011      	beq.n	80125f4 <udp_input_local_match+0x84>
 80125d0:	68fb      	ldr	r3, [r7, #12]
 80125d2:	681b      	ldr	r3, [r3, #0]
 80125d4:	2b00      	cmp	r3, #0
 80125d6:	d00d      	beq.n	80125f4 <udp_input_local_match+0x84>
            ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
 80125d8:	4b15      	ldr	r3, [pc, #84]	; (8012630 <udp_input_local_match+0xc0>)
 80125da:	695b      	ldr	r3, [r3, #20]
        if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 80125dc:	3301      	adds	r3, #1
 80125de:	d009      	beq.n	80125f4 <udp_input_local_match+0x84>
            ip4_addr_netcmp(ip_2_ip4(&pcb->local_ip), ip4_current_dest_addr(), netif_ip4_netmask(inp))) {
 80125e0:	68fb      	ldr	r3, [r7, #12]
 80125e2:	681a      	ldr	r2, [r3, #0]
 80125e4:	4b12      	ldr	r3, [pc, #72]	; (8012630 <udp_input_local_match+0xc0>)
 80125e6:	695b      	ldr	r3, [r3, #20]
 80125e8:	405a      	eors	r2, r3
 80125ea:	68bb      	ldr	r3, [r7, #8]
 80125ec:	3308      	adds	r3, #8
 80125ee:	681b      	ldr	r3, [r3, #0]
 80125f0:	4013      	ands	r3, r2
            ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
 80125f2:	d110      	bne.n	8012616 <udp_input_local_match+0xa6>
          return 1;
 80125f4:	2301      	movs	r3, #1
 80125f6:	e00f      	b.n	8012618 <udp_input_local_match+0xa8>
        }
      }
    } else
#endif /* LWIP_IPV4 */
      /* Handle IPv4 and IPv6: all or exact match */
      if (ip_addr_isany(&pcb->local_ip) || ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 80125f8:	68fb      	ldr	r3, [r7, #12]
 80125fa:	2b00      	cmp	r3, #0
 80125fc:	d009      	beq.n	8012612 <udp_input_local_match+0xa2>
 80125fe:	68fb      	ldr	r3, [r7, #12]
 8012600:	681b      	ldr	r3, [r3, #0]
 8012602:	2b00      	cmp	r3, #0
 8012604:	d005      	beq.n	8012612 <udp_input_local_match+0xa2>
 8012606:	68fb      	ldr	r3, [r7, #12]
 8012608:	681a      	ldr	r2, [r3, #0]
 801260a:	4b09      	ldr	r3, [pc, #36]	; (8012630 <udp_input_local_match+0xc0>)
 801260c:	695b      	ldr	r3, [r3, #20]
 801260e:	429a      	cmp	r2, r3
 8012610:	d101      	bne.n	8012616 <udp_input_local_match+0xa6>
        return 1;
 8012612:	2301      	movs	r3, #1
 8012614:	e000      	b.n	8012618 <udp_input_local_match+0xa8>
      }
  }

  return 0;
 8012616:	2300      	movs	r3, #0
}
 8012618:	0018      	movs	r0, r3
 801261a:	46bd      	mov	sp, r7
 801261c:	b004      	add	sp, #16
 801261e:	bd80      	pop	{r7, pc}
 8012620:	08021434 	.word	0x08021434
 8012624:	0802145c 	.word	0x0802145c
 8012628:	08021480 	.word	0x08021480
 801262c:	080214ac 	.word	0x080214ac
 8012630:	200018fc 	.word	0x200018fc

08012634 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
 8012634:	b5b0      	push	{r4, r5, r7, lr}
 8012636:	b08c      	sub	sp, #48	; 0x30
 8012638:	af02      	add	r7, sp, #8
 801263a:	6078      	str	r0, [r7, #4]
 801263c:	6039      	str	r1, [r7, #0]
  struct udp_hdr *udphdr;
  struct udp_pcb *pcb, *prev;
  struct udp_pcb *uncon_pcb;
  u16_t src, dest;
  u8_t broadcast;
  u8_t for_us = 0;
 801263e:	231b      	movs	r3, #27
 8012640:	18fb      	adds	r3, r7, r3
 8012642:	2200      	movs	r2, #0
 8012644:	701a      	strb	r2, [r3, #0]

  LWIP_UNUSED_ARG(inp);

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ASSERT("udp_input: invalid pbuf", p != NULL);
 8012646:	687b      	ldr	r3, [r7, #4]
 8012648:	2b00      	cmp	r3, #0
 801264a:	d105      	bne.n	8012658 <udp_input+0x24>
 801264c:	4ba1      	ldr	r3, [pc, #644]	; (80128d4 <udp_input+0x2a0>)
 801264e:	49a2      	ldr	r1, [pc, #648]	; (80128d8 <udp_input+0x2a4>)
 8012650:	48a2      	ldr	r0, [pc, #648]	; (80128dc <udp_input+0x2a8>)
 8012652:	22cf      	movs	r2, #207	; 0xcf
 8012654:	f7f0 fab8 	bl	8002bc8 <app_debug_rtt_raw>
  LWIP_ASSERT("udp_input: invalid netif", inp != NULL);
 8012658:	683b      	ldr	r3, [r7, #0]
 801265a:	2b00      	cmp	r3, #0
 801265c:	d105      	bne.n	801266a <udp_input+0x36>
 801265e:	4b9d      	ldr	r3, [pc, #628]	; (80128d4 <udp_input+0x2a0>)
 8012660:	499f      	ldr	r1, [pc, #636]	; (80128e0 <udp_input+0x2ac>)
 8012662:	489e      	ldr	r0, [pc, #632]	; (80128dc <udp_input+0x2a8>)
 8012664:	22d0      	movs	r2, #208	; 0xd0
 8012666:	f7f0 faaf 	bl	8002bc8 <app_debug_rtt_raw>
  PERF_START;

  UDP_STATS_INC(udp.recv);

  /* Check minimum length (UDP header) */
  if (p->len < UDP_HLEN) {
 801266a:	687b      	ldr	r3, [r7, #4]
 801266c:	895b      	ldrh	r3, [r3, #10]
 801266e:	2b07      	cmp	r3, #7
 8012670:	d804      	bhi.n	801267c <udp_input+0x48>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    MIB2_STATS_INC(mib2.udpinerrors);
    pbuf_free(p);
 8012672:	687b      	ldr	r3, [r7, #4]
 8012674:	0018      	movs	r0, r3
 8012676:	f7f7 fc21 	bl	8009ebc <pbuf_free>
    goto end;
 801267a:	e121      	b.n	80128c0 <udp_input+0x28c>
  }

  udphdr = (struct udp_hdr *)p->payload;
 801267c:	687b      	ldr	r3, [r7, #4]
 801267e:	685b      	ldr	r3, [r3, #4]
 8012680:	617b      	str	r3, [r7, #20]

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif());
 8012682:	4b98      	ldr	r3, [pc, #608]	; (80128e4 <udp_input+0x2b0>)
 8012684:	695a      	ldr	r2, [r3, #20]
 8012686:	4b97      	ldr	r3, [pc, #604]	; (80128e4 <udp_input+0x2b0>)
 8012688:	681b      	ldr	r3, [r3, #0]
 801268a:	2113      	movs	r1, #19
 801268c:	187c      	adds	r4, r7, r1
 801268e:	0019      	movs	r1, r3
 8012690:	0010      	movs	r0, r2
 8012692:	f001 fbc3 	bl	8013e1c <ip4_addr_isbroadcast_u32>
 8012696:	0003      	movs	r3, r0
 8012698:	7023      	strb	r3, [r4, #0]

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = lwip_ntohs(udphdr->src);
 801269a:	697b      	ldr	r3, [r7, #20]
 801269c:	781a      	ldrb	r2, [r3, #0]
 801269e:	785b      	ldrb	r3, [r3, #1]
 80126a0:	021b      	lsls	r3, r3, #8
 80126a2:	4313      	orrs	r3, r2
 80126a4:	b29b      	uxth	r3, r3
 80126a6:	2210      	movs	r2, #16
 80126a8:	18bc      	adds	r4, r7, r2
 80126aa:	0018      	movs	r0, r3
 80126ac:	f7f4 fc22 	bl	8006ef4 <lwip_htons>
 80126b0:	0003      	movs	r3, r0
 80126b2:	8023      	strh	r3, [r4, #0]
  dest = lwip_ntohs(udphdr->dest);
 80126b4:	697b      	ldr	r3, [r7, #20]
 80126b6:	789a      	ldrb	r2, [r3, #2]
 80126b8:	78db      	ldrb	r3, [r3, #3]
 80126ba:	021b      	lsls	r3, r3, #8
 80126bc:	4313      	orrs	r3, r2
 80126be:	b29b      	uxth	r3, r3
 80126c0:	220e      	movs	r2, #14
 80126c2:	18bc      	adds	r4, r7, r2
 80126c4:	0018      	movs	r0, r3
 80126c6:	f7f4 fc15 	bl	8006ef4 <lwip_htons>
 80126ca:	0003      	movs	r3, r0
 80126cc:	8023      	strh	r3, [r4, #0]
  ip_addr_debug_print_val(UDP_DEBUG, *ip_current_dest_addr());
  LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F") <-- (", lwip_ntohs(udphdr->dest)));
  ip_addr_debug_print_val(UDP_DEBUG, *ip_current_src_addr());
  LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F")\n", lwip_ntohs(udphdr->src)));

  pcb = NULL;
 80126ce:	2300      	movs	r3, #0
 80126d0:	61fb      	str	r3, [r7, #28]
  prev = NULL;
 80126d2:	2300      	movs	r3, #0
 80126d4:	623b      	str	r3, [r7, #32]
  uncon_pcb = NULL;
 80126d6:	2300      	movs	r3, #0
 80126d8:	627b      	str	r3, [r7, #36]	; 0x24
  /* Iterate through the UDP pcb list for a matching pcb.
   * 'Perfect match' pcbs (connected to the remote port & ip address) are
   * preferred. If no perfect match is found, the first unconnected pcb that
   * matches the local port and ip address gets the datagram. */
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 80126da:	4b83      	ldr	r3, [pc, #524]	; (80128e8 <udp_input+0x2b4>)
 80126dc:	681b      	ldr	r3, [r3, #0]
 80126de:	61fb      	str	r3, [r7, #28]
 80126e0:	e066      	b.n	80127b0 <udp_input+0x17c>
    LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F") <-- (", pcb->local_port));
    ip_addr_debug_print_val(UDP_DEBUG, pcb->remote_ip);
    LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F")\n", pcb->remote_port));

    /* compare PCB local addr+port to UDP destination addr+port */
    if ((pcb->local_port == dest) &&
 80126e2:	69fb      	ldr	r3, [r7, #28]
 80126e4:	8adb      	ldrh	r3, [r3, #22]
 80126e6:	220e      	movs	r2, #14
 80126e8:	18ba      	adds	r2, r7, r2
 80126ea:	8812      	ldrh	r2, [r2, #0]
 80126ec:	429a      	cmp	r2, r3
 80126ee:	d15a      	bne.n	80127a6 <udp_input+0x172>
        (udp_input_local_match(pcb, inp, broadcast) != 0)) {
 80126f0:	2313      	movs	r3, #19
 80126f2:	18fb      	adds	r3, r7, r3
 80126f4:	781a      	ldrb	r2, [r3, #0]
 80126f6:	6839      	ldr	r1, [r7, #0]
 80126f8:	69fb      	ldr	r3, [r7, #28]
 80126fa:	0018      	movs	r0, r3
 80126fc:	f7ff ff38 	bl	8012570 <udp_input_local_match>
 8012700:	1e03      	subs	r3, r0, #0
    if ((pcb->local_port == dest) &&
 8012702:	d050      	beq.n	80127a6 <udp_input+0x172>
      if ((pcb->flags & UDP_FLAGS_CONNECTED) == 0) {
 8012704:	69fb      	ldr	r3, [r7, #28]
 8012706:	7d1b      	ldrb	r3, [r3, #20]
 8012708:	001a      	movs	r2, r3
 801270a:	2304      	movs	r3, #4
 801270c:	4013      	ands	r3, r2
 801270e:	d12a      	bne.n	8012766 <udp_input+0x132>
        if (uncon_pcb == NULL) {
 8012710:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012712:	2b00      	cmp	r3, #0
 8012714:	d102      	bne.n	801271c <udp_input+0xe8>
          /* the first unconnected matching PCB */
          uncon_pcb = pcb;
 8012716:	69fb      	ldr	r3, [r7, #28]
 8012718:	627b      	str	r3, [r7, #36]	; 0x24
 801271a:	e024      	b.n	8012766 <udp_input+0x132>
#if LWIP_IPV4
        } else if (broadcast && ip4_current_dest_addr()->addr == IPADDR_BROADCAST) {
 801271c:	2313      	movs	r3, #19
 801271e:	18fb      	adds	r3, r7, r3
 8012720:	781b      	ldrb	r3, [r3, #0]
 8012722:	2b00      	cmp	r3, #0
 8012724:	d014      	beq.n	8012750 <udp_input+0x11c>
 8012726:	4b6f      	ldr	r3, [pc, #444]	; (80128e4 <udp_input+0x2b0>)
 8012728:	695b      	ldr	r3, [r3, #20]
 801272a:	3301      	adds	r3, #1
 801272c:	d110      	bne.n	8012750 <udp_input+0x11c>
          /* global broadcast address (only valid for IPv4; match was checked before) */
          if (!IP_IS_V4_VAL(uncon_pcb->local_ip) || !ip4_addr_cmp(ip_2_ip4(&uncon_pcb->local_ip), netif_ip4_addr(inp))) {
 801272e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012730:	681a      	ldr	r2, [r3, #0]
 8012732:	683b      	ldr	r3, [r7, #0]
 8012734:	3304      	adds	r3, #4
 8012736:	681b      	ldr	r3, [r3, #0]
 8012738:	429a      	cmp	r2, r3
 801273a:	d013      	beq.n	8012764 <udp_input+0x130>
            /* uncon_pcb does not match the input netif, check this pcb */
            if (IP_IS_V4_VAL(pcb->local_ip) && ip4_addr_cmp(ip_2_ip4(&pcb->local_ip), netif_ip4_addr(inp))) {
 801273c:	69fb      	ldr	r3, [r7, #28]
 801273e:	681a      	ldr	r2, [r3, #0]
 8012740:	683b      	ldr	r3, [r7, #0]
 8012742:	3304      	adds	r3, #4
 8012744:	681b      	ldr	r3, [r3, #0]
 8012746:	429a      	cmp	r2, r3
 8012748:	d10c      	bne.n	8012764 <udp_input+0x130>
              /* better match */
              uncon_pcb = pcb;
 801274a:	69fb      	ldr	r3, [r7, #28]
 801274c:	627b      	str	r3, [r7, #36]	; 0x24
          if (!IP_IS_V4_VAL(uncon_pcb->local_ip) || !ip4_addr_cmp(ip_2_ip4(&uncon_pcb->local_ip), netif_ip4_addr(inp))) {
 801274e:	e009      	b.n	8012764 <udp_input+0x130>
            }
          }
#endif /* LWIP_IPV4 */
        }
#if SO_REUSE
        else if (!ip_addr_isany(&pcb->local_ip)) {
 8012750:	69fb      	ldr	r3, [r7, #28]
 8012752:	2b00      	cmp	r3, #0
 8012754:	d007      	beq.n	8012766 <udp_input+0x132>
 8012756:	69fb      	ldr	r3, [r7, #28]
 8012758:	681b      	ldr	r3, [r3, #0]
 801275a:	2b00      	cmp	r3, #0
 801275c:	d003      	beq.n	8012766 <udp_input+0x132>
          /* prefer specific IPs over catch-all */
          uncon_pcb = pcb;
 801275e:	69fb      	ldr	r3, [r7, #28]
 8012760:	627b      	str	r3, [r7, #36]	; 0x24
 8012762:	e000      	b.n	8012766 <udp_input+0x132>
          if (!IP_IS_V4_VAL(uncon_pcb->local_ip) || !ip4_addr_cmp(ip_2_ip4(&uncon_pcb->local_ip), netif_ip4_addr(inp))) {
 8012764:	46c0      	nop			; (mov r8, r8)
        }
#endif /* SO_REUSE */
      }

      /* compare PCB remote addr+port to UDP source addr+port */
      if ((pcb->remote_port == src) &&
 8012766:	69fb      	ldr	r3, [r7, #28]
 8012768:	8b1b      	ldrh	r3, [r3, #24]
 801276a:	2210      	movs	r2, #16
 801276c:	18ba      	adds	r2, r7, r2
 801276e:	8812      	ldrh	r2, [r2, #0]
 8012770:	429a      	cmp	r2, r3
 8012772:	d118      	bne.n	80127a6 <udp_input+0x172>
          (ip_addr_isany_val(pcb->remote_ip) ||
 8012774:	69fb      	ldr	r3, [r7, #28]
 8012776:	685b      	ldr	r3, [r3, #4]
      if ((pcb->remote_port == src) &&
 8012778:	2b00      	cmp	r3, #0
 801277a:	d005      	beq.n	8012788 <udp_input+0x154>
           ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()))) {
 801277c:	69fb      	ldr	r3, [r7, #28]
 801277e:	685a      	ldr	r2, [r3, #4]
 8012780:	4b58      	ldr	r3, [pc, #352]	; (80128e4 <udp_input+0x2b0>)
 8012782:	691b      	ldr	r3, [r3, #16]
          (ip_addr_isany_val(pcb->remote_ip) ||
 8012784:	429a      	cmp	r2, r3
 8012786:	d10e      	bne.n	80127a6 <udp_input+0x172>
        /* the first fully matching PCB */
        if (prev != NULL) {
 8012788:	6a3b      	ldr	r3, [r7, #32]
 801278a:	2b00      	cmp	r3, #0
 801278c:	d014      	beq.n	80127b8 <udp_input+0x184>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
 801278e:	69fb      	ldr	r3, [r7, #28]
 8012790:	691a      	ldr	r2, [r3, #16]
 8012792:	6a3b      	ldr	r3, [r7, #32]
 8012794:	611a      	str	r2, [r3, #16]
          pcb->next = udp_pcbs;
 8012796:	4b54      	ldr	r3, [pc, #336]	; (80128e8 <udp_input+0x2b4>)
 8012798:	681a      	ldr	r2, [r3, #0]
 801279a:	69fb      	ldr	r3, [r7, #28]
 801279c:	611a      	str	r2, [r3, #16]
          udp_pcbs = pcb;
 801279e:	4b52      	ldr	r3, [pc, #328]	; (80128e8 <udp_input+0x2b4>)
 80127a0:	69fa      	ldr	r2, [r7, #28]
 80127a2:	601a      	str	r2, [r3, #0]
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
 80127a4:	e008      	b.n	80127b8 <udp_input+0x184>
      }
    }

    prev = pcb;
 80127a6:	69fb      	ldr	r3, [r7, #28]
 80127a8:	623b      	str	r3, [r7, #32]
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 80127aa:	69fb      	ldr	r3, [r7, #28]
 80127ac:	691b      	ldr	r3, [r3, #16]
 80127ae:	61fb      	str	r3, [r7, #28]
 80127b0:	69fb      	ldr	r3, [r7, #28]
 80127b2:	2b00      	cmp	r3, #0
 80127b4:	d195      	bne.n	80126e2 <udp_input+0xae>
 80127b6:	e000      	b.n	80127ba <udp_input+0x186>
        break;
 80127b8:	46c0      	nop			; (mov r8, r8)
  }
  /* no fully matching pcb found? then look for an unconnected pcb */
  if (pcb == NULL) {
 80127ba:	69fb      	ldr	r3, [r7, #28]
 80127bc:	2b00      	cmp	r3, #0
 80127be:	d101      	bne.n	80127c4 <udp_input+0x190>
    pcb = uncon_pcb;
 80127c0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80127c2:	61fb      	str	r3, [r7, #28]
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL) {
 80127c4:	69fb      	ldr	r3, [r7, #28]
 80127c6:	2b00      	cmp	r3, #0
 80127c8:	d004      	beq.n	80127d4 <udp_input+0x1a0>
    for_us = 1;
 80127ca:	231b      	movs	r3, #27
 80127cc:	18fb      	adds	r3, r7, r3
 80127ce:	2201      	movs	r2, #1
 80127d0:	701a      	strb	r2, [r3, #0]
 80127d2:	e00b      	b.n	80127ec <udp_input+0x1b8>
      for_us = netif_get_ip6_addr_match(inp, ip6_current_dest_addr()) >= 0;
    }
#endif /* LWIP_IPV6 */
#if LWIP_IPV4
    if (!ip_current_is_v6()) {
      for_us = ip4_addr_cmp(netif_ip4_addr(inp), ip4_current_dest_addr());
 80127d4:	683b      	ldr	r3, [r7, #0]
 80127d6:	3304      	adds	r3, #4
 80127d8:	681a      	ldr	r2, [r3, #0]
 80127da:	4b42      	ldr	r3, [pc, #264]	; (80128e4 <udp_input+0x2b0>)
 80127dc:	695b      	ldr	r3, [r3, #20]
 80127de:	1ad3      	subs	r3, r2, r3
 80127e0:	425a      	negs	r2, r3
 80127e2:	4153      	adcs	r3, r2
 80127e4:	b2da      	uxtb	r2, r3
 80127e6:	231b      	movs	r3, #27
 80127e8:	18fb      	adds	r3, r7, r3
 80127ea:	701a      	strb	r2, [r3, #0]
    }
#endif /* LWIP_IPV4 */
  }

  if (for_us) {
 80127ec:	231b      	movs	r3, #27
 80127ee:	18fb      	adds	r3, r7, r3
 80127f0:	781b      	ldrb	r3, [r3, #0]
 80127f2:	2b00      	cmp	r3, #0
 80127f4:	d05f      	beq.n	80128b6 <udp_input+0x282>
          goto chkerr;
        }
      } else
#endif /* LWIP_UDPLITE */
      {
        if (udphdr->chksum != 0) {
 80127f6:	697b      	ldr	r3, [r7, #20]
 80127f8:	799a      	ldrb	r2, [r3, #6]
 80127fa:	79db      	ldrb	r3, [r3, #7]
 80127fc:	021b      	lsls	r3, r3, #8
 80127fe:	4313      	orrs	r3, r2
 8012800:	b29b      	uxth	r3, r3
 8012802:	2b00      	cmp	r3, #0
 8012804:	d00b      	beq.n	801281e <udp_input+0x1ea>
          if (ip_chksum_pseudo(p, IP_PROTO_UDP, p->tot_len,
 8012806:	687b      	ldr	r3, [r7, #4]
 8012808:	891a      	ldrh	r2, [r3, #8]
 801280a:	4938      	ldr	r1, [pc, #224]	; (80128ec <udp_input+0x2b8>)
 801280c:	6878      	ldr	r0, [r7, #4]
 801280e:	4b38      	ldr	r3, [pc, #224]	; (80128f0 <udp_input+0x2bc>)
 8012810:	9300      	str	r3, [sp, #0]
 8012812:	000b      	movs	r3, r1
 8012814:	2111      	movs	r1, #17
 8012816:	f7f5 fdf4 	bl	8008402 <ip_chksum_pseudo>
 801281a:	1e03      	subs	r3, r0, #0
 801281c:	d151      	bne.n	80128c2 <udp_input+0x28e>
          }
        }
      }
    }
#endif /* CHECKSUM_CHECK_UDP */
    if (pbuf_remove_header(p, UDP_HLEN)) {
 801281e:	687b      	ldr	r3, [r7, #4]
 8012820:	2108      	movs	r1, #8
 8012822:	0018      	movs	r0, r3
 8012824:	f7f7 fa72 	bl	8009d0c <pbuf_remove_header>
 8012828:	1e03      	subs	r3, r0, #0
 801282a:	d00b      	beq.n	8012844 <udp_input+0x210>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_remove_header failed\n", 0);
 801282c:	4b29      	ldr	r3, [pc, #164]	; (80128d4 <udp_input+0x2a0>)
 801282e:	22b8      	movs	r2, #184	; 0xb8
 8012830:	0052      	lsls	r2, r2, #1
 8012832:	4930      	ldr	r1, [pc, #192]	; (80128f4 <udp_input+0x2c0>)
 8012834:	4829      	ldr	r0, [pc, #164]	; (80128dc <udp_input+0x2a8>)
 8012836:	f7f0 f9c7 	bl	8002bc8 <app_debug_rtt_raw>
      UDP_STATS_INC(udp.drop);
      MIB2_STATS_INC(mib2.udpinerrors);
      pbuf_free(p);
 801283a:	687b      	ldr	r3, [r7, #4]
 801283c:	0018      	movs	r0, r3
 801283e:	f7f7 fb3d 	bl	8009ebc <pbuf_free>
      goto end;
 8012842:	e03d      	b.n	80128c0 <udp_input+0x28c>
    }

    if (pcb != NULL) {
 8012844:	69fb      	ldr	r3, [r7, #28]
 8012846:	2b00      	cmp	r3, #0
 8012848:	d016      	beq.n	8012878 <udp_input+0x244>
          }
        }
      }
#endif /* SO_REUSE && SO_REUSE_RXTOALL */
      /* callback */
      if (pcb->recv != NULL) {
 801284a:	69fb      	ldr	r3, [r7, #28]
 801284c:	69db      	ldr	r3, [r3, #28]
 801284e:	2b00      	cmp	r3, #0
 8012850:	d00d      	beq.n	801286e <udp_input+0x23a>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
 8012852:	69fb      	ldr	r3, [r7, #28]
 8012854:	69dc      	ldr	r4, [r3, #28]
 8012856:	69fb      	ldr	r3, [r7, #28]
 8012858:	6a18      	ldr	r0, [r3, #32]
 801285a:	4d24      	ldr	r5, [pc, #144]	; (80128ec <udp_input+0x2b8>)
 801285c:	687a      	ldr	r2, [r7, #4]
 801285e:	69f9      	ldr	r1, [r7, #28]
 8012860:	2310      	movs	r3, #16
 8012862:	18fb      	adds	r3, r7, r3
 8012864:	881b      	ldrh	r3, [r3, #0]
 8012866:	9300      	str	r3, [sp, #0]
 8012868:	002b      	movs	r3, r5
 801286a:	47a0      	blx	r4
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
  return;
 801286c:	e02e      	b.n	80128cc <udp_input+0x298>
        pbuf_free(p);
 801286e:	687b      	ldr	r3, [r7, #4]
 8012870:	0018      	movs	r0, r3
 8012872:	f7f7 fb23 	bl	8009ebc <pbuf_free>
        goto end;
 8012876:	e023      	b.n	80128c0 <udp_input+0x28c>
      if (!broadcast && !ip_addr_ismulticast(ip_current_dest_addr())) {
 8012878:	2313      	movs	r3, #19
 801287a:	18fb      	adds	r3, r7, r3
 801287c:	781b      	ldrb	r3, [r3, #0]
 801287e:	2b00      	cmp	r3, #0
 8012880:	d114      	bne.n	80128ac <udp_input+0x278>
 8012882:	4b18      	ldr	r3, [pc, #96]	; (80128e4 <udp_input+0x2b0>)
 8012884:	695b      	ldr	r3, [r3, #20]
 8012886:	22f0      	movs	r2, #240	; 0xf0
 8012888:	4013      	ands	r3, r2
 801288a:	2be0      	cmp	r3, #224	; 0xe0
 801288c:	d00e      	beq.n	80128ac <udp_input+0x278>
        pbuf_header_force(p, (s16_t)(ip_current_header_tot_len() + UDP_HLEN));
 801288e:	4b15      	ldr	r3, [pc, #84]	; (80128e4 <udp_input+0x2b0>)
 8012890:	899b      	ldrh	r3, [r3, #12]
 8012892:	3308      	adds	r3, #8
 8012894:	b29b      	uxth	r3, r3
 8012896:	b21a      	sxth	r2, r3
 8012898:	687b      	ldr	r3, [r7, #4]
 801289a:	0011      	movs	r1, r2
 801289c:	0018      	movs	r0, r3
 801289e:	f7f7 fab6 	bl	8009e0e <pbuf_header_force>
        icmp_port_unreach(ip_current_is_v6(), p);
 80128a2:	687b      	ldr	r3, [r7, #4]
 80128a4:	2103      	movs	r1, #3
 80128a6:	0018      	movs	r0, r3
 80128a8:	f000 fdc0 	bl	801342c <icmp_dest_unreach>
      pbuf_free(p);
 80128ac:	687b      	ldr	r3, [r7, #4]
 80128ae:	0018      	movs	r0, r3
 80128b0:	f7f7 fb04 	bl	8009ebc <pbuf_free>
  return;
 80128b4:	e00a      	b.n	80128cc <udp_input+0x298>
    pbuf_free(p);
 80128b6:	687b      	ldr	r3, [r7, #4]
 80128b8:	0018      	movs	r0, r3
 80128ba:	f7f7 faff 	bl	8009ebc <pbuf_free>
  return;
 80128be:	e005      	b.n	80128cc <udp_input+0x298>
 80128c0:	e004      	b.n	80128cc <udp_input+0x298>
            goto chkerr;
 80128c2:	46c0      	nop			; (mov r8, r8)
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
              ("udp_input: UDP (or UDP Lite) datagram discarded due to failing checksum\n"));
  UDP_STATS_INC(udp.chkerr);
  UDP_STATS_INC(udp.drop);
  MIB2_STATS_INC(mib2.udpinerrors);
  pbuf_free(p);
 80128c4:	687b      	ldr	r3, [r7, #4]
 80128c6:	0018      	movs	r0, r3
 80128c8:	f7f7 faf8 	bl	8009ebc <pbuf_free>
  PERF_STOP("udp_input");
#endif /* CHECKSUM_CHECK_UDP */
}
 80128cc:	46bd      	mov	sp, r7
 80128ce:	b00a      	add	sp, #40	; 0x28
 80128d0:	bdb0      	pop	{r4, r5, r7, pc}
 80128d2:	46c0      	nop			; (mov r8, r8)
 80128d4:	08021434 	.word	0x08021434
 80128d8:	080214d4 	.word	0x080214d4
 80128dc:	08021480 	.word	0x08021480
 80128e0:	080214ec 	.word	0x080214ec
 80128e4:	200018fc 	.word	0x200018fc
 80128e8:	20002b54 	.word	0x20002b54
 80128ec:	2000190c 	.word	0x2000190c
 80128f0:	20001910 	.word	0x20001910
 80128f4:	08021508 	.word	0x08021508

080128f8 <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
           const ip_addr_t *dst_ip, u16_t dst_port)
{
 80128f8:	b590      	push	{r4, r7, lr}
 80128fa:	b087      	sub	sp, #28
 80128fc:	af02      	add	r7, sp, #8
 80128fe:	60f8      	str	r0, [r7, #12]
 8012900:	60b9      	str	r1, [r7, #8]
 8012902:	607a      	str	r2, [r7, #4]
 8012904:	001a      	movs	r2, r3
 8012906:	1cbb      	adds	r3, r7, #2
 8012908:	801a      	strh	r2, [r3, #0]
#if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
  return udp_sendto_chksum(pcb, p, dst_ip, dst_port, 0, 0);
 801290a:	1cbb      	adds	r3, r7, #2
 801290c:	881b      	ldrh	r3, [r3, #0]
 801290e:	687a      	ldr	r2, [r7, #4]
 8012910:	68b9      	ldr	r1, [r7, #8]
 8012912:	68f8      	ldr	r0, [r7, #12]
 8012914:	2400      	movs	r4, #0
 8012916:	9401      	str	r4, [sp, #4]
 8012918:	2400      	movs	r4, #0
 801291a:	9400      	str	r4, [sp, #0]
 801291c:	f000 f806 	bl	801292c <udp_sendto_chksum>
 8012920:	0003      	movs	r3, r0
}
 8012922:	0018      	movs	r0, r3
 8012924:	46bd      	mov	sp, r7
 8012926:	b005      	add	sp, #20
 8012928:	bd90      	pop	{r4, r7, pc}
	...

0801292c <udp_sendto_chksum>:
/** @ingroup udp_raw
 * Same as udp_sendto(), but with checksum */
err_t
udp_sendto_chksum(struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip,
                  u16_t dst_port, u8_t have_chksum, u16_t chksum)
{
 801292c:	b590      	push	{r4, r7, lr}
 801292e:	b08b      	sub	sp, #44	; 0x2c
 8012930:	af04      	add	r7, sp, #16
 8012932:	60f8      	str	r0, [r7, #12]
 8012934:	60b9      	str	r1, [r7, #8]
 8012936:	607a      	str	r2, [r7, #4]
 8012938:	001a      	movs	r2, r3
 801293a:	1cbb      	adds	r3, r7, #2
 801293c:	801a      	strh	r2, [r3, #0]
#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
  struct netif *netif;

  LWIP_ERROR("udp_sendto: invalid pcb", pcb != NULL, return ERR_ARG);
 801293e:	68fb      	ldr	r3, [r7, #12]
 8012940:	2b00      	cmp	r3, #0
 8012942:	d106      	bne.n	8012952 <udp_sendto_chksum+0x26>
 8012944:	4b24      	ldr	r3, [pc, #144]	; (80129d8 <udp_sendto_chksum+0xac>)
 8012946:	0018      	movs	r0, r3
 8012948:	f7f0 f93e 	bl	8002bc8 <app_debug_rtt_raw>
 801294c:	2310      	movs	r3, #16
 801294e:	425b      	negs	r3, r3
 8012950:	e03e      	b.n	80129d0 <udp_sendto_chksum+0xa4>
  LWIP_ERROR("udp_sendto: invalid pbuf", p != NULL, return ERR_ARG);
 8012952:	68bb      	ldr	r3, [r7, #8]
 8012954:	2b00      	cmp	r3, #0
 8012956:	d106      	bne.n	8012966 <udp_sendto_chksum+0x3a>
 8012958:	4b20      	ldr	r3, [pc, #128]	; (80129dc <udp_sendto_chksum+0xb0>)
 801295a:	0018      	movs	r0, r3
 801295c:	f7f0 f934 	bl	8002bc8 <app_debug_rtt_raw>
 8012960:	2310      	movs	r3, #16
 8012962:	425b      	negs	r3, r3
 8012964:	e034      	b.n	80129d0 <udp_sendto_chksum+0xa4>
  LWIP_ERROR("udp_sendto: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 8012966:	687b      	ldr	r3, [r7, #4]
 8012968:	2b00      	cmp	r3, #0
 801296a:	d106      	bne.n	801297a <udp_sendto_chksum+0x4e>
 801296c:	4b1c      	ldr	r3, [pc, #112]	; (80129e0 <udp_sendto_chksum+0xb4>)
 801296e:	0018      	movs	r0, r3
 8012970:	f7f0 f92a 	bl	8002bc8 <app_debug_rtt_raw>
 8012974:	2310      	movs	r3, #16
 8012976:	425b      	negs	r3, r3
 8012978:	e02a      	b.n	80129d0 <udp_sendto_chksum+0xa4>
    return ERR_VAL;
  }

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send\n"));

  if (pcb->netif_idx != NETIF_NO_INDEX) {
 801297a:	68fb      	ldr	r3, [r7, #12]
 801297c:	7a1b      	ldrb	r3, [r3, #8]
 801297e:	2b00      	cmp	r3, #0
 8012980:	d007      	beq.n	8012992 <udp_sendto_chksum+0x66>
    netif = netif_get_by_index(pcb->netif_idx);
 8012982:	68fb      	ldr	r3, [r7, #12]
 8012984:	7a1b      	ldrb	r3, [r3, #8]
 8012986:	0018      	movs	r0, r3
 8012988:	f7f6 fea2 	bl	80096d0 <netif_get_by_index>
 801298c:	0003      	movs	r3, r0
 801298e:	617b      	str	r3, [r7, #20]
 8012990:	e005      	b.n	801299e <udp_sendto_chksum+0x72>

    if (netif == NULL)
#endif /* LWIP_MULTICAST_TX_OPTIONS */
    {
      /* find the outgoing network interface for this packet */
      netif = ip_route(&pcb->local_ip, dst_ip);
 8012992:	687b      	ldr	r3, [r7, #4]
 8012994:	0018      	movs	r0, r3
 8012996:	f000 fe19 	bl	80135cc <ip4_route>
 801299a:	0003      	movs	r3, r0
 801299c:	617b      	str	r3, [r7, #20]
    }
  }

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
 801299e:	697b      	ldr	r3, [r7, #20]
 80129a0:	2b00      	cmp	r3, #0
 80129a2:	d102      	bne.n	80129aa <udp_sendto_chksum+0x7e>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to "));
    ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, dst_ip);
    LWIP_DEBUGF(UDP_DEBUG, ("\n"));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
 80129a4:	2304      	movs	r3, #4
 80129a6:	425b      	negs	r3, r3
 80129a8:	e012      	b.n	80129d0 <udp_sendto_chksum+0xa4>
  }
#if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
  return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum);
 80129aa:	1cbb      	adds	r3, r7, #2
 80129ac:	881c      	ldrh	r4, [r3, #0]
 80129ae:	687a      	ldr	r2, [r7, #4]
 80129b0:	68b9      	ldr	r1, [r7, #8]
 80129b2:	68f8      	ldr	r0, [r7, #12]
 80129b4:	232c      	movs	r3, #44	; 0x2c
 80129b6:	18fb      	adds	r3, r7, r3
 80129b8:	881b      	ldrh	r3, [r3, #0]
 80129ba:	9302      	str	r3, [sp, #8]
 80129bc:	2328      	movs	r3, #40	; 0x28
 80129be:	18fb      	adds	r3, r7, r3
 80129c0:	781b      	ldrb	r3, [r3, #0]
 80129c2:	9301      	str	r3, [sp, #4]
 80129c4:	697b      	ldr	r3, [r7, #20]
 80129c6:	9300      	str	r3, [sp, #0]
 80129c8:	0023      	movs	r3, r4
 80129ca:	f000 f80b 	bl	80129e4 <udp_sendto_if_chksum>
 80129ce:	0003      	movs	r3, r0
#else /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
}
 80129d0:	0018      	movs	r0, r3
 80129d2:	46bd      	mov	sp, r7
 80129d4:	b007      	add	sp, #28
 80129d6:	bd90      	pop	{r4, r7, pc}
 80129d8:	08021594 	.word	0x08021594
 80129dc:	080215ac 	.word	0x080215ac
 80129e0:	080215c8 	.word	0x080215c8

080129e4 <udp_sendto_if_chksum>:
/** Same as udp_sendto_if(), but with checksum */
err_t
udp_sendto_if_chksum(struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip,
                     u16_t dst_port, struct netif *netif, u8_t have_chksum,
                     u16_t chksum)
{
 80129e4:	b590      	push	{r4, r7, lr}
 80129e6:	b08b      	sub	sp, #44	; 0x2c
 80129e8:	af04      	add	r7, sp, #16
 80129ea:	60f8      	str	r0, [r7, #12]
 80129ec:	60b9      	str	r1, [r7, #8]
 80129ee:	607a      	str	r2, [r7, #4]
 80129f0:	001a      	movs	r2, r3
 80129f2:	1cbb      	adds	r3, r7, #2
 80129f4:	801a      	strh	r2, [r3, #0]
#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
  const ip_addr_t *src_ip;

  LWIP_ERROR("udp_sendto_if: invalid pcb", pcb != NULL, return ERR_ARG);
 80129f6:	68fb      	ldr	r3, [r7, #12]
 80129f8:	2b00      	cmp	r3, #0
 80129fa:	d106      	bne.n	8012a0a <udp_sendto_if_chksum+0x26>
 80129fc:	4b2d      	ldr	r3, [pc, #180]	; (8012ab4 <udp_sendto_if_chksum+0xd0>)
 80129fe:	0018      	movs	r0, r3
 8012a00:	f7f0 f8e2 	bl	8002bc8 <app_debug_rtt_raw>
 8012a04:	2310      	movs	r3, #16
 8012a06:	425b      	negs	r3, r3
 8012a08:	e04f      	b.n	8012aaa <udp_sendto_if_chksum+0xc6>
  LWIP_ERROR("udp_sendto_if: invalid pbuf", p != NULL, return ERR_ARG);
 8012a0a:	68bb      	ldr	r3, [r7, #8]
 8012a0c:	2b00      	cmp	r3, #0
 8012a0e:	d106      	bne.n	8012a1e <udp_sendto_if_chksum+0x3a>
 8012a10:	4b29      	ldr	r3, [pc, #164]	; (8012ab8 <udp_sendto_if_chksum+0xd4>)
 8012a12:	0018      	movs	r0, r3
 8012a14:	f7f0 f8d8 	bl	8002bc8 <app_debug_rtt_raw>
 8012a18:	2310      	movs	r3, #16
 8012a1a:	425b      	negs	r3, r3
 8012a1c:	e045      	b.n	8012aaa <udp_sendto_if_chksum+0xc6>
  LWIP_ERROR("udp_sendto_if: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 8012a1e:	687b      	ldr	r3, [r7, #4]
 8012a20:	2b00      	cmp	r3, #0
 8012a22:	d106      	bne.n	8012a32 <udp_sendto_if_chksum+0x4e>
 8012a24:	4b25      	ldr	r3, [pc, #148]	; (8012abc <udp_sendto_if_chksum+0xd8>)
 8012a26:	0018      	movs	r0, r3
 8012a28:	f7f0 f8ce 	bl	8002bc8 <app_debug_rtt_raw>
 8012a2c:	2310      	movs	r3, #16
 8012a2e:	425b      	negs	r3, r3
 8012a30:	e03b      	b.n	8012aaa <udp_sendto_if_chksum+0xc6>
  LWIP_ERROR("udp_sendto_if: invalid netif", netif != NULL, return ERR_ARG);
 8012a32:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012a34:	2b00      	cmp	r3, #0
 8012a36:	d106      	bne.n	8012a46 <udp_sendto_if_chksum+0x62>
 8012a38:	4b21      	ldr	r3, [pc, #132]	; (8012ac0 <udp_sendto_if_chksum+0xdc>)
 8012a3a:	0018      	movs	r0, r3
 8012a3c:	f7f0 f8c4 	bl	8002bc8 <app_debug_rtt_raw>
 8012a40:	2310      	movs	r3, #16
 8012a42:	425b      	negs	r3, r3
 8012a44:	e031      	b.n	8012aaa <udp_sendto_if_chksum+0xc6>
#endif /* LWIP_IPV6 */
#if LWIP_IPV4 && LWIP_IPV6
  else
#endif /* LWIP_IPV4 && LWIP_IPV6 */
#if LWIP_IPV4
    if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 8012a46:	68fb      	ldr	r3, [r7, #12]
 8012a48:	2b00      	cmp	r3, #0
 8012a4a:	d009      	beq.n	8012a60 <udp_sendto_if_chksum+0x7c>
 8012a4c:	68fb      	ldr	r3, [r7, #12]
 8012a4e:	681b      	ldr	r3, [r3, #0]
 8012a50:	2b00      	cmp	r3, #0
 8012a52:	d005      	beq.n	8012a60 <udp_sendto_if_chksum+0x7c>
        ip4_addr_ismulticast(ip_2_ip4(&pcb->local_ip))) {
 8012a54:	68fb      	ldr	r3, [r7, #12]
 8012a56:	681b      	ldr	r3, [r3, #0]
 8012a58:	22f0      	movs	r2, #240	; 0xf0
 8012a5a:	4013      	ands	r3, r2
    if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 8012a5c:	2be0      	cmp	r3, #224	; 0xe0
 8012a5e:	d103      	bne.n	8012a68 <udp_sendto_if_chksum+0x84>
      /* if the local_ip is any or multicast
       * use the outgoing network interface IP address as source address */
      src_ip = netif_ip_addr4(netif);
 8012a60:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012a62:	3304      	adds	r3, #4
 8012a64:	617b      	str	r3, [r7, #20]
 8012a66:	e00b      	b.n	8012a80 <udp_sendto_if_chksum+0x9c>
    } else {
      /* check if UDP PCB local IP address is correct
       * this could be an old address if netif->ip_addr has changed */
      if (!ip4_addr_cmp(ip_2_ip4(&(pcb->local_ip)), netif_ip4_addr(netif))) {
 8012a68:	68fb      	ldr	r3, [r7, #12]
 8012a6a:	681a      	ldr	r2, [r3, #0]
 8012a6c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012a6e:	3304      	adds	r3, #4
 8012a70:	681b      	ldr	r3, [r3, #0]
 8012a72:	429a      	cmp	r2, r3
 8012a74:	d002      	beq.n	8012a7c <udp_sendto_if_chksum+0x98>
        /* local_ip doesn't match, drop the packet */
        return ERR_RTE;
 8012a76:	2304      	movs	r3, #4
 8012a78:	425b      	negs	r3, r3
 8012a7a:	e016      	b.n	8012aaa <udp_sendto_if_chksum+0xc6>
      }
      /* use UDP PCB local IP address as source address */
      src_ip = &pcb->local_ip;
 8012a7c:	68fb      	ldr	r3, [r7, #12]
 8012a7e:	617b      	str	r3, [r7, #20]
    }
#endif /* LWIP_IPV4 */
#if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
  return udp_sendto_if_src_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum, src_ip);
 8012a80:	1cbb      	adds	r3, r7, #2
 8012a82:	881c      	ldrh	r4, [r3, #0]
 8012a84:	687a      	ldr	r2, [r7, #4]
 8012a86:	68b9      	ldr	r1, [r7, #8]
 8012a88:	68f8      	ldr	r0, [r7, #12]
 8012a8a:	697b      	ldr	r3, [r7, #20]
 8012a8c:	9303      	str	r3, [sp, #12]
 8012a8e:	2330      	movs	r3, #48	; 0x30
 8012a90:	18fb      	adds	r3, r7, r3
 8012a92:	881b      	ldrh	r3, [r3, #0]
 8012a94:	9302      	str	r3, [sp, #8]
 8012a96:	232c      	movs	r3, #44	; 0x2c
 8012a98:	18fb      	adds	r3, r7, r3
 8012a9a:	781b      	ldrb	r3, [r3, #0]
 8012a9c:	9301      	str	r3, [sp, #4]
 8012a9e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012aa0:	9300      	str	r3, [sp, #0]
 8012aa2:	0023      	movs	r3, r4
 8012aa4:	f000 f80e 	bl	8012ac4 <udp_sendto_if_src_chksum>
 8012aa8:	0003      	movs	r3, r0
#else /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
  return udp_sendto_if_src(pcb, p, dst_ip, dst_port, netif, src_ip);
#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
}
 8012aaa:	0018      	movs	r0, r3
 8012aac:	46bd      	mov	sp, r7
 8012aae:	b007      	add	sp, #28
 8012ab0:	bd90      	pop	{r4, r7, pc}
 8012ab2:	46c0      	nop			; (mov r8, r8)
 8012ab4:	080215e4 	.word	0x080215e4
 8012ab8:	08021600 	.word	0x08021600
 8012abc:	0802161c 	.word	0x0802161c
 8012ac0:	0802163c 	.word	0x0802163c

08012ac4 <udp_sendto_if_src_chksum>:
/** Same as udp_sendto_if_src(), but with checksum */
err_t
udp_sendto_if_src_chksum(struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip,
                         u16_t dst_port, struct netif *netif, u8_t have_chksum,
                         u16_t chksum, const ip_addr_t *src_ip)
{
 8012ac4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8012ac6:	b08f      	sub	sp, #60	; 0x3c
 8012ac8:	af04      	add	r7, sp, #16
 8012aca:	60f8      	str	r0, [r7, #12]
 8012acc:	60b9      	str	r1, [r7, #8]
 8012ace:	607a      	str	r2, [r7, #4]
 8012ad0:	001a      	movs	r2, r3
 8012ad2:	1cbb      	adds	r3, r7, #2
 8012ad4:	801a      	strh	r2, [r3, #0]
  u8_t ip_proto;
  u8_t ttl;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_sendto_if_src: invalid pcb", pcb != NULL, return ERR_ARG);
 8012ad6:	68fb      	ldr	r3, [r7, #12]
 8012ad8:	2b00      	cmp	r3, #0
 8012ada:	d106      	bne.n	8012aea <udp_sendto_if_src_chksum+0x26>
 8012adc:	4bb4      	ldr	r3, [pc, #720]	; (8012db0 <udp_sendto_if_src_chksum+0x2ec>)
 8012ade:	0018      	movs	r0, r3
 8012ae0:	f7f0 f872 	bl	8002bc8 <app_debug_rtt_raw>
 8012ae4:	2310      	movs	r3, #16
 8012ae6:	425b      	negs	r3, r3
 8012ae8:	e15d      	b.n	8012da6 <udp_sendto_if_src_chksum+0x2e2>
  LWIP_ERROR("udp_sendto_if_src: invalid pbuf", p != NULL, return ERR_ARG);
 8012aea:	68bb      	ldr	r3, [r7, #8]
 8012aec:	2b00      	cmp	r3, #0
 8012aee:	d106      	bne.n	8012afe <udp_sendto_if_src_chksum+0x3a>
 8012af0:	4bb0      	ldr	r3, [pc, #704]	; (8012db4 <udp_sendto_if_src_chksum+0x2f0>)
 8012af2:	0018      	movs	r0, r3
 8012af4:	f7f0 f868 	bl	8002bc8 <app_debug_rtt_raw>
 8012af8:	2310      	movs	r3, #16
 8012afa:	425b      	negs	r3, r3
 8012afc:	e153      	b.n	8012da6 <udp_sendto_if_src_chksum+0x2e2>
  LWIP_ERROR("udp_sendto_if_src: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 8012afe:	687b      	ldr	r3, [r7, #4]
 8012b00:	2b00      	cmp	r3, #0
 8012b02:	d106      	bne.n	8012b12 <udp_sendto_if_src_chksum+0x4e>
 8012b04:	4bac      	ldr	r3, [pc, #688]	; (8012db8 <udp_sendto_if_src_chksum+0x2f4>)
 8012b06:	0018      	movs	r0, r3
 8012b08:	f7f0 f85e 	bl	8002bc8 <app_debug_rtt_raw>
 8012b0c:	2310      	movs	r3, #16
 8012b0e:	425b      	negs	r3, r3
 8012b10:	e149      	b.n	8012da6 <udp_sendto_if_src_chksum+0x2e2>
  LWIP_ERROR("udp_sendto_if_src: invalid src_ip", src_ip != NULL, return ERR_ARG);
 8012b12:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8012b14:	2b00      	cmp	r3, #0
 8012b16:	d106      	bne.n	8012b26 <udp_sendto_if_src_chksum+0x62>
 8012b18:	4ba8      	ldr	r3, [pc, #672]	; (8012dbc <udp_sendto_if_src_chksum+0x2f8>)
 8012b1a:	0018      	movs	r0, r3
 8012b1c:	f7f0 f854 	bl	8002bc8 <app_debug_rtt_raw>
 8012b20:	2310      	movs	r3, #16
 8012b22:	425b      	negs	r3, r3
 8012b24:	e13f      	b.n	8012da6 <udp_sendto_if_src_chksum+0x2e2>
  LWIP_ERROR("udp_sendto_if_src: invalid netif", netif != NULL, return ERR_ARG);
 8012b26:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8012b28:	2b00      	cmp	r3, #0
 8012b2a:	d106      	bne.n	8012b3a <udp_sendto_if_src_chksum+0x76>
 8012b2c:	4ba4      	ldr	r3, [pc, #656]	; (8012dc0 <udp_sendto_if_src_chksum+0x2fc>)
 8012b2e:	0018      	movs	r0, r3
 8012b30:	f7f0 f84a 	bl	8002bc8 <app_debug_rtt_raw>
 8012b34:	2310      	movs	r3, #16
 8012b36:	425b      	negs	r3, r3
 8012b38:	e135      	b.n	8012da6 <udp_sendto_if_src_chksum+0x2e2>
    return ERR_VAL;
  }
#endif /* LWIP_IPV4 && IP_SOF_BROADCAST */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
 8012b3a:	68fb      	ldr	r3, [r7, #12]
 8012b3c:	8adb      	ldrh	r3, [r3, #22]
 8012b3e:	2b00      	cmp	r3, #0
 8012b40:	d113      	bne.n	8012b6a <udp_sendto_if_src_chksum+0xa6>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 8012b42:	68f9      	ldr	r1, [r7, #12]
 8012b44:	68fb      	ldr	r3, [r7, #12]
 8012b46:	8ada      	ldrh	r2, [r3, #22]
 8012b48:	251f      	movs	r5, #31
 8012b4a:	197c      	adds	r4, r7, r5
 8012b4c:	68fb      	ldr	r3, [r7, #12]
 8012b4e:	0018      	movs	r0, r3
 8012b50:	f000 f942 	bl	8012dd8 <udp_bind>
 8012b54:	0003      	movs	r3, r0
 8012b56:	7023      	strb	r3, [r4, #0]
    if (err != ERR_OK) {
 8012b58:	197b      	adds	r3, r7, r5
 8012b5a:	781b      	ldrb	r3, [r3, #0]
 8012b5c:	b25b      	sxtb	r3, r3
 8012b5e:	2b00      	cmp	r3, #0
 8012b60:	d003      	beq.n	8012b6a <udp_sendto_if_src_chksum+0xa6>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind failed\n"));
      return err;
 8012b62:	197b      	adds	r3, r7, r5
 8012b64:	781b      	ldrb	r3, [r3, #0]
 8012b66:	b25b      	sxtb	r3, r3
 8012b68:	e11d      	b.n	8012da6 <udp_sendto_if_src_chksum+0x2e2>
    }
  }

  /* packet too large to add a UDP header without causing an overflow? */
  if ((u16_t)(p->tot_len + UDP_HLEN) < p->tot_len) {
 8012b6a:	68bb      	ldr	r3, [r7, #8]
 8012b6c:	891b      	ldrh	r3, [r3, #8]
 8012b6e:	4a95      	ldr	r2, [pc, #596]	; (8012dc4 <udp_sendto_if_src_chksum+0x300>)
 8012b70:	4293      	cmp	r3, r2
 8012b72:	d902      	bls.n	8012b7a <udp_sendto_if_src_chksum+0xb6>
    return ERR_MEM;
 8012b74:	2301      	movs	r3, #1
 8012b76:	425b      	negs	r3, r3
 8012b78:	e115      	b.n	8012da6 <udp_sendto_if_src_chksum+0x2e2>
  }
  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_add_header(p, UDP_HLEN)) {
 8012b7a:	68bb      	ldr	r3, [r7, #8]
 8012b7c:	2108      	movs	r1, #8
 8012b7e:	0018      	movs	r0, r3
 8012b80:	f7f7 f8b4 	bl	8009cec <pbuf_add_header>
 8012b84:	1e03      	subs	r3, r0, #0
 8012b86:	d019      	beq.n	8012bbc <udp_sendto_if_src_chksum+0xf8>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
 8012b88:	23a0      	movs	r3, #160	; 0xa0
 8012b8a:	009b      	lsls	r3, r3, #2
 8012b8c:	001a      	movs	r2, r3
 8012b8e:	2108      	movs	r1, #8
 8012b90:	2024      	movs	r0, #36	; 0x24
 8012b92:	f7f6 fe1b 	bl	80097cc <pbuf_alloc>
 8012b96:	0003      	movs	r3, r0
 8012b98:	623b      	str	r3, [r7, #32]
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
 8012b9a:	6a3b      	ldr	r3, [r7, #32]
 8012b9c:	2b00      	cmp	r3, #0
 8012b9e:	d102      	bne.n	8012ba6 <udp_sendto_if_src_chksum+0xe2>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
 8012ba0:	2301      	movs	r3, #1
 8012ba2:	425b      	negs	r3, r3
 8012ba4:	e0ff      	b.n	8012da6 <udp_sendto_if_src_chksum+0x2e2>
    }
    if (p->tot_len != 0) {
 8012ba6:	68bb      	ldr	r3, [r7, #8]
 8012ba8:	891b      	ldrh	r3, [r3, #8]
 8012baa:	2b00      	cmp	r3, #0
 8012bac:	d008      	beq.n	8012bc0 <udp_sendto_if_src_chksum+0xfc>
      /* chain header q in front of given pbuf p (only if p contains data) */
      pbuf_chain(q, p);
 8012bae:	68ba      	ldr	r2, [r7, #8]
 8012bb0:	6a3b      	ldr	r3, [r7, #32]
 8012bb2:	0011      	movs	r1, r2
 8012bb4:	0018      	movs	r0, r3
 8012bb6:	f7f7 fab5 	bl	800a124 <pbuf_chain>
 8012bba:	e001      	b.n	8012bc0 <udp_sendto_if_src_chksum+0xfc>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
 8012bbc:	68bb      	ldr	r3, [r7, #8]
 8012bbe:	623b      	str	r3, [r7, #32]
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
 8012bc0:	6a3b      	ldr	r3, [r7, #32]
 8012bc2:	895b      	ldrh	r3, [r3, #10]
 8012bc4:	2b07      	cmp	r3, #7
 8012bc6:	d805      	bhi.n	8012bd4 <udp_sendto_if_src_chksum+0x110>
 8012bc8:	4b7f      	ldr	r3, [pc, #508]	; (8012dc8 <udp_sendto_if_src_chksum+0x304>)
 8012bca:	4a80      	ldr	r2, [pc, #512]	; (8012dcc <udp_sendto_if_src_chksum+0x308>)
 8012bcc:	4980      	ldr	r1, [pc, #512]	; (8012dd0 <udp_sendto_if_src_chksum+0x30c>)
 8012bce:	4881      	ldr	r0, [pc, #516]	; (8012dd4 <udp_sendto_if_src_chksum+0x310>)
 8012bd0:	f7ef fffa 	bl	8002bc8 <app_debug_rtt_raw>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = (struct udp_hdr *)q->payload;
 8012bd4:	6a3b      	ldr	r3, [r7, #32]
 8012bd6:	685b      	ldr	r3, [r3, #4]
 8012bd8:	61bb      	str	r3, [r7, #24]
  udphdr->src = lwip_htons(pcb->local_port);
 8012bda:	68fb      	ldr	r3, [r7, #12]
 8012bdc:	8adb      	ldrh	r3, [r3, #22]
 8012bde:	0018      	movs	r0, r3
 8012be0:	f7f4 f988 	bl	8006ef4 <lwip_htons>
 8012be4:	0003      	movs	r3, r0
 8012be6:	001a      	movs	r2, r3
 8012be8:	69bb      	ldr	r3, [r7, #24]
 8012bea:	21ff      	movs	r1, #255	; 0xff
 8012bec:	4011      	ands	r1, r2
 8012bee:	000c      	movs	r4, r1
 8012bf0:	7819      	ldrb	r1, [r3, #0]
 8012bf2:	2000      	movs	r0, #0
 8012bf4:	4001      	ands	r1, r0
 8012bf6:	1c08      	adds	r0, r1, #0
 8012bf8:	1c21      	adds	r1, r4, #0
 8012bfa:	4301      	orrs	r1, r0
 8012bfc:	7019      	strb	r1, [r3, #0]
 8012bfe:	0a12      	lsrs	r2, r2, #8
 8012c00:	b290      	uxth	r0, r2
 8012c02:	785a      	ldrb	r2, [r3, #1]
 8012c04:	2100      	movs	r1, #0
 8012c06:	400a      	ands	r2, r1
 8012c08:	1c11      	adds	r1, r2, #0
 8012c0a:	1c02      	adds	r2, r0, #0
 8012c0c:	430a      	orrs	r2, r1
 8012c0e:	705a      	strb	r2, [r3, #1]
  udphdr->dest = lwip_htons(dst_port);
 8012c10:	1cbb      	adds	r3, r7, #2
 8012c12:	881b      	ldrh	r3, [r3, #0]
 8012c14:	0018      	movs	r0, r3
 8012c16:	f7f4 f96d 	bl	8006ef4 <lwip_htons>
 8012c1a:	0003      	movs	r3, r0
 8012c1c:	001a      	movs	r2, r3
 8012c1e:	69bb      	ldr	r3, [r7, #24]
 8012c20:	21ff      	movs	r1, #255	; 0xff
 8012c22:	4011      	ands	r1, r2
 8012c24:	000c      	movs	r4, r1
 8012c26:	7899      	ldrb	r1, [r3, #2]
 8012c28:	2000      	movs	r0, #0
 8012c2a:	4001      	ands	r1, r0
 8012c2c:	1c08      	adds	r0, r1, #0
 8012c2e:	1c21      	adds	r1, r4, #0
 8012c30:	4301      	orrs	r1, r0
 8012c32:	7099      	strb	r1, [r3, #2]
 8012c34:	0a12      	lsrs	r2, r2, #8
 8012c36:	b290      	uxth	r0, r2
 8012c38:	78da      	ldrb	r2, [r3, #3]
 8012c3a:	2100      	movs	r1, #0
 8012c3c:	400a      	ands	r2, r1
 8012c3e:	1c11      	adds	r1, r2, #0
 8012c40:	1c02      	adds	r2, r0, #0
 8012c42:	430a      	orrs	r2, r1
 8012c44:	70da      	strb	r2, [r3, #3]
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000;
 8012c46:	69bb      	ldr	r3, [r7, #24]
 8012c48:	799a      	ldrb	r2, [r3, #6]
 8012c4a:	2100      	movs	r1, #0
 8012c4c:	400a      	ands	r2, r1
 8012c4e:	719a      	strb	r2, [r3, #6]
 8012c50:	79da      	ldrb	r2, [r3, #7]
 8012c52:	2100      	movs	r1, #0
 8012c54:	400a      	ands	r2, r1
 8012c56:	71da      	strb	r2, [r3, #7]
    ip_proto = IP_PROTO_UDPLITE;
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = lwip_htons(q->tot_len);
 8012c58:	6a3b      	ldr	r3, [r7, #32]
 8012c5a:	891b      	ldrh	r3, [r3, #8]
 8012c5c:	0018      	movs	r0, r3
 8012c5e:	f7f4 f949 	bl	8006ef4 <lwip_htons>
 8012c62:	0003      	movs	r3, r0
 8012c64:	001a      	movs	r2, r3
 8012c66:	69bb      	ldr	r3, [r7, #24]
 8012c68:	21ff      	movs	r1, #255	; 0xff
 8012c6a:	4011      	ands	r1, r2
 8012c6c:	000c      	movs	r4, r1
 8012c6e:	7919      	ldrb	r1, [r3, #4]
 8012c70:	2000      	movs	r0, #0
 8012c72:	4001      	ands	r1, r0
 8012c74:	1c08      	adds	r0, r1, #0
 8012c76:	1c21      	adds	r1, r4, #0
 8012c78:	4301      	orrs	r1, r0
 8012c7a:	7119      	strb	r1, [r3, #4]
 8012c7c:	0a12      	lsrs	r2, r2, #8
 8012c7e:	b290      	uxth	r0, r2
 8012c80:	795a      	ldrb	r2, [r3, #5]
 8012c82:	2100      	movs	r1, #0
 8012c84:	400a      	ands	r2, r1
 8012c86:	1c11      	adds	r1, r2, #0
 8012c88:	1c02      	adds	r2, r0, #0
 8012c8a:	430a      	orrs	r2, r1
 8012c8c:	715a      	strb	r2, [r3, #5]
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_UDP) {
      /* Checksum is mandatory over IPv6. */
      if (IP_IS_V6(dst_ip) || (pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
 8012c8e:	68fb      	ldr	r3, [r7, #12]
 8012c90:	7d1b      	ldrb	r3, [r3, #20]
 8012c92:	001a      	movs	r2, r3
 8012c94:	2301      	movs	r3, #1
 8012c96:	4013      	ands	r3, r2
 8012c98:	d150      	bne.n	8012d3c <udp_sendto_if_src_chksum+0x278>
        u16_t udpchksum;
#if LWIP_CHECKSUM_ON_COPY
        if (have_chksum) {
 8012c9a:	2344      	movs	r3, #68	; 0x44
 8012c9c:	18fb      	adds	r3, r7, r3
 8012c9e:	781b      	ldrb	r3, [r3, #0]
 8012ca0:	2b00      	cmp	r3, #0
 8012ca2:	d021      	beq.n	8012ce8 <udp_sendto_if_src_chksum+0x224>
          u32_t acc;
          udpchksum = ip_chksum_pseudo_partial(q, IP_PROTO_UDP,
 8012ca4:	6a3b      	ldr	r3, [r7, #32]
 8012ca6:	891a      	ldrh	r2, [r3, #8]
 8012ca8:	2526      	movs	r5, #38	; 0x26
 8012caa:	197c      	adds	r4, r7, r5
 8012cac:	6a38      	ldr	r0, [r7, #32]
 8012cae:	687b      	ldr	r3, [r7, #4]
 8012cb0:	9301      	str	r3, [sp, #4]
 8012cb2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8012cb4:	9300      	str	r3, [sp, #0]
 8012cb6:	2308      	movs	r3, #8
 8012cb8:	2111      	movs	r1, #17
 8012cba:	f7f5 fcbc 	bl	8008636 <ip_chksum_pseudo_partial>
 8012cbe:	0003      	movs	r3, r0
 8012cc0:	8023      	strh	r3, [r4, #0]
                                               q->tot_len, UDP_HLEN, src_ip, dst_ip);
          acc = udpchksum + (u16_t)~(chksum);
 8012cc2:	0028      	movs	r0, r5
 8012cc4:	183b      	adds	r3, r7, r0
 8012cc6:	881b      	ldrh	r3, [r3, #0]
 8012cc8:	2248      	movs	r2, #72	; 0x48
 8012cca:	18ba      	adds	r2, r7, r2
 8012ccc:	8812      	ldrh	r2, [r2, #0]
 8012cce:	43d2      	mvns	r2, r2
 8012cd0:	b292      	uxth	r2, r2
 8012cd2:	189b      	adds	r3, r3, r2
 8012cd4:	617b      	str	r3, [r7, #20]
          udpchksum = FOLD_U32T(acc);
 8012cd6:	697b      	ldr	r3, [r7, #20]
 8012cd8:	0c1b      	lsrs	r3, r3, #16
 8012cda:	b299      	uxth	r1, r3
 8012cdc:	697b      	ldr	r3, [r7, #20]
 8012cde:	b29a      	uxth	r2, r3
 8012ce0:	183b      	adds	r3, r7, r0
 8012ce2:	188a      	adds	r2, r1, r2
 8012ce4:	801a      	strh	r2, [r3, #0]
 8012ce6:	e00d      	b.n	8012d04 <udp_sendto_if_src_chksum+0x240>
        } else
#endif /* LWIP_CHECKSUM_ON_COPY */
        {
          udpchksum = ip_chksum_pseudo(q, IP_PROTO_UDP, q->tot_len,
 8012ce8:	6a3b      	ldr	r3, [r7, #32]
 8012cea:	891a      	ldrh	r2, [r3, #8]
 8012cec:	2326      	movs	r3, #38	; 0x26
 8012cee:	18fc      	adds	r4, r7, r3
 8012cf0:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 8012cf2:	6a38      	ldr	r0, [r7, #32]
 8012cf4:	687b      	ldr	r3, [r7, #4]
 8012cf6:	9300      	str	r3, [sp, #0]
 8012cf8:	000b      	movs	r3, r1
 8012cfa:	2111      	movs	r1, #17
 8012cfc:	f7f5 fb81 	bl	8008402 <ip_chksum_pseudo>
 8012d00:	0003      	movs	r3, r0
 8012d02:	8023      	strh	r3, [r4, #0]
                                       src_ip, dst_ip);
        }

        /* chksum zero must become 0xffff, as zero means 'no checksum' */
        if (udpchksum == 0x0000) {
 8012d04:	2226      	movs	r2, #38	; 0x26
 8012d06:	18bb      	adds	r3, r7, r2
 8012d08:	881b      	ldrh	r3, [r3, #0]
 8012d0a:	2b00      	cmp	r3, #0
 8012d0c:	d103      	bne.n	8012d16 <udp_sendto_if_src_chksum+0x252>
          udpchksum = 0xffff;
 8012d0e:	18bb      	adds	r3, r7, r2
 8012d10:	2201      	movs	r2, #1
 8012d12:	4252      	negs	r2, r2
 8012d14:	801a      	strh	r2, [r3, #0]
        }
        udphdr->chksum = udpchksum;
 8012d16:	69bb      	ldr	r3, [r7, #24]
 8012d18:	2226      	movs	r2, #38	; 0x26
 8012d1a:	18ba      	adds	r2, r7, r2
 8012d1c:	7814      	ldrb	r4, [r2, #0]
 8012d1e:	7999      	ldrb	r1, [r3, #6]
 8012d20:	2000      	movs	r0, #0
 8012d22:	4001      	ands	r1, r0
 8012d24:	1c08      	adds	r0, r1, #0
 8012d26:	1c21      	adds	r1, r4, #0
 8012d28:	4301      	orrs	r1, r0
 8012d2a:	7199      	strb	r1, [r3, #6]
 8012d2c:	7850      	ldrb	r0, [r2, #1]
 8012d2e:	79da      	ldrb	r2, [r3, #7]
 8012d30:	2100      	movs	r1, #0
 8012d32:	400a      	ands	r2, r1
 8012d34:	1c11      	adds	r1, r2, #0
 8012d36:	1c02      	adds	r2, r0, #0
 8012d38:	430a      	orrs	r2, r1
 8012d3a:	71da      	strb	r2, [r3, #7]
      }
    }
#endif /* CHECKSUM_GEN_UDP */
    ip_proto = IP_PROTO_UDP;
 8012d3c:	2313      	movs	r3, #19
 8012d3e:	18fb      	adds	r3, r7, r3
 8012d40:	2211      	movs	r2, #17
 8012d42:	701a      	strb	r2, [r3, #0]

  /* Determine TTL to use */
#if LWIP_MULTICAST_TX_OPTIONS
  ttl = (ip_addr_ismulticast(dst_ip) ? udp_get_multicast_ttl(pcb) : pcb->ttl);
#else /* LWIP_MULTICAST_TX_OPTIONS */
  ttl = pcb->ttl;
 8012d44:	2112      	movs	r1, #18
 8012d46:	187b      	adds	r3, r7, r1
 8012d48:	68fa      	ldr	r2, [r7, #12]
 8012d4a:	7ad2      	ldrb	r2, [r2, #11]
 8012d4c:	701a      	strb	r2, [r3, #0]
#endif /* LWIP_MULTICAST_TX_OPTIONS */

  LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04"X16_F"\n", udphdr->chksum));
  LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,0x%02"X16_F",)\n", (u16_t)ip_proto));
  /* output to IP */
  NETIF_SET_HINTS(netif, &(pcb->netif_hints));
 8012d4e:	68fb      	ldr	r3, [r7, #12]
 8012d50:	330c      	adds	r3, #12
 8012d52:	001a      	movs	r2, r3
 8012d54:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8012d56:	639a      	str	r2, [r3, #56]	; 0x38
  err = ip_output_if_src(q, src_ip, dst_ip, ttl, pcb->tos, ip_proto, netif);
 8012d58:	68fb      	ldr	r3, [r7, #12]
 8012d5a:	7a9b      	ldrb	r3, [r3, #10]
 8012d5c:	201f      	movs	r0, #31
 8012d5e:	183c      	adds	r4, r7, r0
 8012d60:	187a      	adds	r2, r7, r1
 8012d62:	7816      	ldrb	r6, [r2, #0]
 8012d64:	687d      	ldr	r5, [r7, #4]
 8012d66:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 8012d68:	6a38      	ldr	r0, [r7, #32]
 8012d6a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8012d6c:	9202      	str	r2, [sp, #8]
 8012d6e:	2213      	movs	r2, #19
 8012d70:	18ba      	adds	r2, r7, r2
 8012d72:	7812      	ldrb	r2, [r2, #0]
 8012d74:	9201      	str	r2, [sp, #4]
 8012d76:	9300      	str	r3, [sp, #0]
 8012d78:	0033      	movs	r3, r6
 8012d7a:	002a      	movs	r2, r5
 8012d7c:	f000 fe58 	bl	8013a30 <ip4_output_if_src>
 8012d80:	0003      	movs	r3, r0
 8012d82:	7023      	strb	r3, [r4, #0]
  NETIF_RESET_HINTS(netif);
 8012d84:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8012d86:	2200      	movs	r2, #0
 8012d88:	639a      	str	r2, [r3, #56]	; 0x38

  /* @todo: must this be increased even if error occurred? */
  MIB2_STATS_INC(mib2.udpoutdatagrams);

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
 8012d8a:	6a3a      	ldr	r2, [r7, #32]
 8012d8c:	68bb      	ldr	r3, [r7, #8]
 8012d8e:	429a      	cmp	r2, r3
 8012d90:	d005      	beq.n	8012d9e <udp_sendto_if_src_chksum+0x2da>
    /* free the header pbuf */
    pbuf_free(q);
 8012d92:	6a3b      	ldr	r3, [r7, #32]
 8012d94:	0018      	movs	r0, r3
 8012d96:	f7f7 f891 	bl	8009ebc <pbuf_free>
    q = NULL;
 8012d9a:	2300      	movs	r3, #0
 8012d9c:	623b      	str	r3, [r7, #32]
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
 8012d9e:	231f      	movs	r3, #31
 8012da0:	18fb      	adds	r3, r7, r3
 8012da2:	781b      	ldrb	r3, [r3, #0]
 8012da4:	b25b      	sxtb	r3, r3
}
 8012da6:	0018      	movs	r0, r3
 8012da8:	46bd      	mov	sp, r7
 8012daa:	b00b      	add	sp, #44	; 0x2c
 8012dac:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8012dae:	46c0      	nop			; (mov r8, r8)
 8012db0:	0802165c 	.word	0x0802165c
 8012db4:	0802167c 	.word	0x0802167c
 8012db8:	0802169c 	.word	0x0802169c
 8012dbc:	080216c0 	.word	0x080216c0
 8012dc0:	080216e4 	.word	0x080216e4
 8012dc4:	0000fff7 	.word	0x0000fff7
 8012dc8:	08021434 	.word	0x08021434
 8012dcc:	0000030d 	.word	0x0000030d
 8012dd0:	08021708 	.word	0x08021708
 8012dd4:	08021480 	.word	0x08021480

08012dd8 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
{
 8012dd8:	b590      	push	{r4, r7, lr}
 8012dda:	b087      	sub	sp, #28
 8012ddc:	af00      	add	r7, sp, #0
 8012dde:	60f8      	str	r0, [r7, #12]
 8012de0:	60b9      	str	r1, [r7, #8]
 8012de2:	1dbb      	adds	r3, r7, #6
 8012de4:	801a      	strh	r2, [r3, #0]

  LWIP_ASSERT_CORE_LOCKED();

#if LWIP_IPV4
  /* Don't propagate NULL pointer (IPv4 ANY) to subsequent functions */
  if (ipaddr == NULL) {
 8012de6:	68bb      	ldr	r3, [r7, #8]
 8012de8:	2b00      	cmp	r3, #0
 8012dea:	d101      	bne.n	8012df0 <udp_bind+0x18>
    ipaddr = IP4_ADDR_ANY;
 8012dec:	4b43      	ldr	r3, [pc, #268]	; (8012efc <udp_bind+0x124>)
 8012dee:	60bb      	str	r3, [r7, #8]
  }
#else /* LWIP_IPV4 */
  LWIP_ERROR("udp_bind: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
#endif /* LWIP_IPV4 */

  LWIP_ERROR("udp_bind: invalid pcb", pcb != NULL, return ERR_ARG);
 8012df0:	68fb      	ldr	r3, [r7, #12]
 8012df2:	2b00      	cmp	r3, #0
 8012df4:	d106      	bne.n	8012e04 <udp_bind+0x2c>
 8012df6:	4b42      	ldr	r3, [pc, #264]	; (8012f00 <udp_bind+0x128>)
 8012df8:	0018      	movs	r0, r3
 8012dfa:	f7ef fee5 	bl	8002bc8 <app_debug_rtt_raw>
 8012dfe:	2310      	movs	r3, #16
 8012e00:	425b      	negs	r3, r3
 8012e02:	e077      	b.n	8012ef4 <udp_bind+0x11c>

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_TRACE, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
 8012e04:	2313      	movs	r3, #19
 8012e06:	18fb      	adds	r3, r7, r3
 8012e08:	2200      	movs	r2, #0
 8012e0a:	701a      	strb	r2, [r3, #0]
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8012e0c:	4b3d      	ldr	r3, [pc, #244]	; (8012f04 <udp_bind+0x12c>)
 8012e0e:	681b      	ldr	r3, [r3, #0]
 8012e10:	617b      	str	r3, [r7, #20]
 8012e12:	e00b      	b.n	8012e2c <udp_bind+0x54>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
 8012e14:	68fa      	ldr	r2, [r7, #12]
 8012e16:	697b      	ldr	r3, [r7, #20]
 8012e18:	429a      	cmp	r2, r3
 8012e1a:	d104      	bne.n	8012e26 <udp_bind+0x4e>
      rebind = 1;
 8012e1c:	2313      	movs	r3, #19
 8012e1e:	18fb      	adds	r3, r7, r3
 8012e20:	2201      	movs	r2, #1
 8012e22:	701a      	strb	r2, [r3, #0]
      break;
 8012e24:	e005      	b.n	8012e32 <udp_bind+0x5a>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8012e26:	697b      	ldr	r3, [r7, #20]
 8012e28:	691b      	ldr	r3, [r3, #16]
 8012e2a:	617b      	str	r3, [r7, #20]
 8012e2c:	697b      	ldr	r3, [r7, #20]
 8012e2e:	2b00      	cmp	r3, #0
 8012e30:	d1f0      	bne.n	8012e14 <udp_bind+0x3c>
    ipaddr = &zoned_ipaddr;
  }
#endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */

  /* no port specified? */
  if (port == 0) {
 8012e32:	1dbb      	adds	r3, r7, #6
 8012e34:	881b      	ldrh	r3, [r3, #0]
 8012e36:	2b00      	cmp	r3, #0
 8012e38:	d10b      	bne.n	8012e52 <udp_bind+0x7a>
    port = udp_new_port();
 8012e3a:	1dbc      	adds	r4, r7, #6
 8012e3c:	f7ff fb5a 	bl	80124f4 <udp_new_port>
 8012e40:	0003      	movs	r3, r0
 8012e42:	8023      	strh	r3, [r4, #0]
    if (port == 0) {
 8012e44:	1dbb      	adds	r3, r7, #6
 8012e46:	881b      	ldrh	r3, [r3, #0]
 8012e48:	2b00      	cmp	r3, #0
 8012e4a:	d139      	bne.n	8012ec0 <udp_bind+0xe8>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
 8012e4c:	2308      	movs	r3, #8
 8012e4e:	425b      	negs	r3, r3
 8012e50:	e050      	b.n	8012ef4 <udp_bind+0x11c>
    }
  } else {
    for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8012e52:	4b2c      	ldr	r3, [pc, #176]	; (8012f04 <udp_bind+0x12c>)
 8012e54:	681b      	ldr	r3, [r3, #0]
 8012e56:	617b      	str	r3, [r7, #20]
 8012e58:	e02f      	b.n	8012eba <udp_bind+0xe2>
      if (pcb != ipcb) {
 8012e5a:	68fa      	ldr	r2, [r7, #12]
 8012e5c:	697b      	ldr	r3, [r7, #20]
 8012e5e:	429a      	cmp	r2, r3
 8012e60:	d028      	beq.n	8012eb4 <udp_bind+0xdc>
        /* By default, we don't allow to bind to a port that any other udp
           PCB is already bound to, unless *all* PCBs with that port have tha
           REUSEADDR flag set. */
#if SO_REUSE
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
 8012e62:	68fb      	ldr	r3, [r7, #12]
 8012e64:	7a5b      	ldrb	r3, [r3, #9]
 8012e66:	001a      	movs	r2, r3
 8012e68:	2304      	movs	r3, #4
 8012e6a:	4013      	ands	r3, r2
 8012e6c:	d005      	beq.n	8012e7a <udp_bind+0xa2>
            !ip_get_option(ipcb, SOF_REUSEADDR))
 8012e6e:	697b      	ldr	r3, [r7, #20]
 8012e70:	7a5b      	ldrb	r3, [r3, #9]
 8012e72:	001a      	movs	r2, r3
 8012e74:	2304      	movs	r3, #4
 8012e76:	4013      	ands	r3, r2
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
 8012e78:	d11c      	bne.n	8012eb4 <udp_bind+0xdc>
#endif /* SO_REUSE */
        {
          /* port matches that of PCB in list and REUSEADDR not set -> reject */
          if ((ipcb->local_port == port) &&
 8012e7a:	697b      	ldr	r3, [r7, #20]
 8012e7c:	8adb      	ldrh	r3, [r3, #22]
 8012e7e:	1dba      	adds	r2, r7, #6
 8012e80:	8812      	ldrh	r2, [r2, #0]
 8012e82:	429a      	cmp	r2, r3
 8012e84:	d116      	bne.n	8012eb4 <udp_bind+0xdc>
              (((IP_GET_TYPE(&ipcb->local_ip) == IP_GET_TYPE(ipaddr)) &&
              /* IP address matches or any IP used? */
              (ip_addr_cmp(&ipcb->local_ip, ipaddr) ||
 8012e86:	697b      	ldr	r3, [r7, #20]
 8012e88:	681a      	ldr	r2, [r3, #0]
 8012e8a:	68bb      	ldr	r3, [r7, #8]
 8012e8c:	681b      	ldr	r3, [r3, #0]
          if ((ipcb->local_port == port) &&
 8012e8e:	429a      	cmp	r2, r3
 8012e90:	d00d      	beq.n	8012eae <udp_bind+0xd6>
              (ip_addr_cmp(&ipcb->local_ip, ipaddr) ||
 8012e92:	68bb      	ldr	r3, [r7, #8]
 8012e94:	2b00      	cmp	r3, #0
 8012e96:	d00a      	beq.n	8012eae <udp_bind+0xd6>
              ip_addr_isany(ipaddr) ||
 8012e98:	68bb      	ldr	r3, [r7, #8]
 8012e9a:	681b      	ldr	r3, [r3, #0]
 8012e9c:	2b00      	cmp	r3, #0
 8012e9e:	d006      	beq.n	8012eae <udp_bind+0xd6>
              ip_addr_isany(&ipcb->local_ip))) ||
 8012ea0:	697b      	ldr	r3, [r7, #20]
              (IP_GET_TYPE(&ipcb->local_ip) == IPADDR_TYPE_ANY) ||
 8012ea2:	2b00      	cmp	r3, #0
 8012ea4:	d003      	beq.n	8012eae <udp_bind+0xd6>
              ip_addr_isany(&ipcb->local_ip))) ||
 8012ea6:	697b      	ldr	r3, [r7, #20]
 8012ea8:	681b      	ldr	r3, [r3, #0]
 8012eaa:	2b00      	cmp	r3, #0
 8012eac:	d102      	bne.n	8012eb4 <udp_bind+0xdc>
              (IP_GET_TYPE(ipaddr) == IPADDR_TYPE_ANY))) {
            /* other PCB already binds to this local IP and port */
            LWIP_DEBUGF(UDP_DEBUG,
                        ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
            return ERR_USE;
 8012eae:	2308      	movs	r3, #8
 8012eb0:	425b      	negs	r3, r3
 8012eb2:	e01f      	b.n	8012ef4 <udp_bind+0x11c>
    for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8012eb4:	697b      	ldr	r3, [r7, #20]
 8012eb6:	691b      	ldr	r3, [r3, #16]
 8012eb8:	617b      	str	r3, [r7, #20]
 8012eba:	697b      	ldr	r3, [r7, #20]
 8012ebc:	2b00      	cmp	r3, #0
 8012ebe:	d1cc      	bne.n	8012e5a <udp_bind+0x82>
        }
      }
    }
  }

  ip_addr_set_ipaddr(&pcb->local_ip, ipaddr);
 8012ec0:	68bb      	ldr	r3, [r7, #8]
 8012ec2:	2b00      	cmp	r3, #0
 8012ec4:	d002      	beq.n	8012ecc <udp_bind+0xf4>
 8012ec6:	68bb      	ldr	r3, [r7, #8]
 8012ec8:	681a      	ldr	r2, [r3, #0]
 8012eca:	e000      	b.n	8012ece <udp_bind+0xf6>
 8012ecc:	2200      	movs	r2, #0
 8012ece:	68fb      	ldr	r3, [r7, #12]
 8012ed0:	601a      	str	r2, [r3, #0]

  pcb->local_port = port;
 8012ed2:	68fb      	ldr	r3, [r7, #12]
 8012ed4:	1dba      	adds	r2, r7, #6
 8012ed6:	8812      	ldrh	r2, [r2, #0]
 8012ed8:	82da      	strh	r2, [r3, #22]
  mib2_udp_bind(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
 8012eda:	2313      	movs	r3, #19
 8012edc:	18fb      	adds	r3, r7, r3
 8012ede:	781b      	ldrb	r3, [r3, #0]
 8012ee0:	2b00      	cmp	r3, #0
 8012ee2:	d106      	bne.n	8012ef2 <udp_bind+0x11a>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
 8012ee4:	4b07      	ldr	r3, [pc, #28]	; (8012f04 <udp_bind+0x12c>)
 8012ee6:	681a      	ldr	r2, [r3, #0]
 8012ee8:	68fb      	ldr	r3, [r7, #12]
 8012eea:	611a      	str	r2, [r3, #16]
    udp_pcbs = pcb;
 8012eec:	4b05      	ldr	r3, [pc, #20]	; (8012f04 <udp_bind+0x12c>)
 8012eee:	68fa      	ldr	r2, [r7, #12]
 8012ef0:	601a      	str	r2, [r3, #0]
  }
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("udp_bind: bound to "));
  ip_addr_debug_print_val(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, pcb->local_ip);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, (", port %"U16_F")\n", pcb->local_port));
  return ERR_OK;
 8012ef2:	2300      	movs	r3, #0
}
 8012ef4:	0018      	movs	r0, r3
 8012ef6:	46bd      	mov	sp, r7
 8012ef8:	b007      	add	sp, #28
 8012efa:	bd90      	pop	{r4, r7, pc}
 8012efc:	08022888 	.word	0x08022888
 8012f00:	08021738 	.word	0x08021738
 8012f04:	20002b54 	.word	0x20002b54

08012f08 <udp_recv>:
 * @param recv function pointer of the callback function
 * @param recv_arg additional argument to pass to the callback function
 */
void
udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
 8012f08:	b580      	push	{r7, lr}
 8012f0a:	b084      	sub	sp, #16
 8012f0c:	af00      	add	r7, sp, #0
 8012f0e:	60f8      	str	r0, [r7, #12]
 8012f10:	60b9      	str	r1, [r7, #8]
 8012f12:	607a      	str	r2, [r7, #4]
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_recv: invalid pcb", pcb != NULL, return);
 8012f14:	68fb      	ldr	r3, [r7, #12]
 8012f16:	2b00      	cmp	r3, #0
 8012f18:	d104      	bne.n	8012f24 <udp_recv+0x1c>
 8012f1a:	4b07      	ldr	r3, [pc, #28]	; (8012f38 <udp_recv+0x30>)
 8012f1c:	0018      	movs	r0, r3
 8012f1e:	f7ef fe53 	bl	8002bc8 <app_debug_rtt_raw>
 8012f22:	e005      	b.n	8012f30 <udp_recv+0x28>

  /* remember recv() callback and user data */
  pcb->recv = recv;
 8012f24:	68fb      	ldr	r3, [r7, #12]
 8012f26:	68ba      	ldr	r2, [r7, #8]
 8012f28:	61da      	str	r2, [r3, #28]
  pcb->recv_arg = recv_arg;
 8012f2a:	68fb      	ldr	r3, [r7, #12]
 8012f2c:	687a      	ldr	r2, [r7, #4]
 8012f2e:	621a      	str	r2, [r3, #32]
}
 8012f30:	46bd      	mov	sp, r7
 8012f32:	b004      	add	sp, #16
 8012f34:	bd80      	pop	{r7, pc}
 8012f36:	46c0      	nop			; (mov r8, r8)
 8012f38:	080217a4 	.word	0x080217a4

08012f3c <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
 8012f3c:	b580      	push	{r7, lr}
 8012f3e:	b084      	sub	sp, #16
 8012f40:	af00      	add	r7, sp, #0
 8012f42:	6078      	str	r0, [r7, #4]
  struct udp_pcb *pcb2;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_remove: invalid pcb", pcb != NULL, return);
 8012f44:	687b      	ldr	r3, [r7, #4]
 8012f46:	2b00      	cmp	r3, #0
 8012f48:	d104      	bne.n	8012f54 <udp_remove+0x18>
 8012f4a:	4b18      	ldr	r3, [pc, #96]	; (8012fac <udp_remove+0x70>)
 8012f4c:	0018      	movs	r0, r3
 8012f4e:	f7ef fe3b 	bl	8002bc8 <app_debug_rtt_raw>
 8012f52:	e027      	b.n	8012fa4 <udp_remove+0x68>

  mib2_udp_unbind(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
 8012f54:	4b16      	ldr	r3, [pc, #88]	; (8012fb0 <udp_remove+0x74>)
 8012f56:	681b      	ldr	r3, [r3, #0]
 8012f58:	687a      	ldr	r2, [r7, #4]
 8012f5a:	429a      	cmp	r2, r3
 8012f5c:	d105      	bne.n	8012f6a <udp_remove+0x2e>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
 8012f5e:	4b14      	ldr	r3, [pc, #80]	; (8012fb0 <udp_remove+0x74>)
 8012f60:	681b      	ldr	r3, [r3, #0]
 8012f62:	691a      	ldr	r2, [r3, #16]
 8012f64:	4b12      	ldr	r3, [pc, #72]	; (8012fb0 <udp_remove+0x74>)
 8012f66:	601a      	str	r2, [r3, #0]
 8012f68:	e017      	b.n	8012f9a <udp_remove+0x5e>
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 8012f6a:	4b11      	ldr	r3, [pc, #68]	; (8012fb0 <udp_remove+0x74>)
 8012f6c:	681b      	ldr	r3, [r3, #0]
 8012f6e:	60fb      	str	r3, [r7, #12]
 8012f70:	e010      	b.n	8012f94 <udp_remove+0x58>
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
 8012f72:	68fb      	ldr	r3, [r7, #12]
 8012f74:	691b      	ldr	r3, [r3, #16]
 8012f76:	2b00      	cmp	r3, #0
 8012f78:	d009      	beq.n	8012f8e <udp_remove+0x52>
 8012f7a:	68fb      	ldr	r3, [r7, #12]
 8012f7c:	691b      	ldr	r3, [r3, #16]
 8012f7e:	687a      	ldr	r2, [r7, #4]
 8012f80:	429a      	cmp	r2, r3
 8012f82:	d104      	bne.n	8012f8e <udp_remove+0x52>
        /* remove pcb from list */
        pcb2->next = pcb->next;
 8012f84:	687b      	ldr	r3, [r7, #4]
 8012f86:	691a      	ldr	r2, [r3, #16]
 8012f88:	68fb      	ldr	r3, [r7, #12]
 8012f8a:	611a      	str	r2, [r3, #16]
        break;
 8012f8c:	e005      	b.n	8012f9a <udp_remove+0x5e>
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 8012f8e:	68fb      	ldr	r3, [r7, #12]
 8012f90:	691b      	ldr	r3, [r3, #16]
 8012f92:	60fb      	str	r3, [r7, #12]
 8012f94:	68fb      	ldr	r3, [r7, #12]
 8012f96:	2b00      	cmp	r3, #0
 8012f98:	d1eb      	bne.n	8012f72 <udp_remove+0x36>
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
 8012f9a:	687b      	ldr	r3, [r7, #4]
 8012f9c:	0019      	movs	r1, r3
 8012f9e:	2000      	movs	r0, #0
 8012fa0:	f7f6 f89c 	bl	80090dc <memp_free>
}
 8012fa4:	46bd      	mov	sp, r7
 8012fa6:	b004      	add	sp, #16
 8012fa8:	bd80      	pop	{r7, pc}
 8012faa:	46c0      	nop			; (mov r8, r8)
 8012fac:	080217bc 	.word	0x080217bc
 8012fb0:	20002b54 	.word	0x20002b54

08012fb4 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
 8012fb4:	b580      	push	{r7, lr}
 8012fb6:	b082      	sub	sp, #8
 8012fb8:	af00      	add	r7, sp, #0
  struct udp_pcb *pcb;

  LWIP_ASSERT_CORE_LOCKED();

  pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
 8012fba:	2000      	movs	r0, #0
 8012fbc:	f7f6 f81e 	bl	8008ffc <memp_malloc>
 8012fc0:	0003      	movs	r3, r0
 8012fc2:	607b      	str	r3, [r7, #4]
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
 8012fc4:	687b      	ldr	r3, [r7, #4]
 8012fc6:	2b00      	cmp	r3, #0
 8012fc8:	d008      	beq.n	8012fdc <udp_new+0x28>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
 8012fca:	687b      	ldr	r3, [r7, #4]
 8012fcc:	2224      	movs	r2, #36	; 0x24
 8012fce:	2100      	movs	r1, #0
 8012fd0:	0018      	movs	r0, r3
 8012fd2:	f009 ff97 	bl	801cf04 <memset>
    pcb->ttl = UDP_TTL;
 8012fd6:	687b      	ldr	r3, [r7, #4]
 8012fd8:	22ff      	movs	r2, #255	; 0xff
 8012fda:	72da      	strb	r2, [r3, #11]
#if LWIP_MULTICAST_TX_OPTIONS
    udp_set_multicast_ttl(pcb, UDP_TTL);
#endif /* LWIP_MULTICAST_TX_OPTIONS */
  }
  return pcb;
 8012fdc:	687b      	ldr	r3, [r7, #4]
}
 8012fde:	0018      	movs	r0, r3
 8012fe0:	46bd      	mov	sp, r7
 8012fe2:	b002      	add	sp, #8
 8012fe4:	bd80      	pop	{r7, pc}

08012fe6 <udp_new_ip_type>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new_ip_type(u8_t type)
{
 8012fe6:	b580      	push	{r7, lr}
 8012fe8:	b084      	sub	sp, #16
 8012fea:	af00      	add	r7, sp, #0
 8012fec:	0002      	movs	r2, r0
 8012fee:	1dfb      	adds	r3, r7, #7
 8012ff0:	701a      	strb	r2, [r3, #0]
  struct udp_pcb *pcb;

  LWIP_ASSERT_CORE_LOCKED();

  pcb = udp_new();
 8012ff2:	f7ff ffdf 	bl	8012fb4 <udp_new>
 8012ff6:	0003      	movs	r3, r0
 8012ff8:	60fb      	str	r3, [r7, #12]
    IP_SET_TYPE_VAL(pcb->remote_ip, type);
  }
#else
  LWIP_UNUSED_ARG(type);
#endif /* LWIP_IPV4 && LWIP_IPV6 */
  return pcb;
 8012ffa:	68fb      	ldr	r3, [r7, #12]
}
 8012ffc:	0018      	movs	r0, r3
 8012ffe:	46bd      	mov	sp, r7
 8013000:	b004      	add	sp, #16
 8013002:	bd80      	pop	{r7, pc}

08013004 <udp_netif_ip_addr_changed>:
 *
 * @param old_addr IP address of the netif before change
 * @param new_addr IP address of the netif after change
 */
void udp_netif_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_addr)
{
 8013004:	b580      	push	{r7, lr}
 8013006:	b084      	sub	sp, #16
 8013008:	af00      	add	r7, sp, #0
 801300a:	6078      	str	r0, [r7, #4]
 801300c:	6039      	str	r1, [r7, #0]
  struct udp_pcb *upcb;

  if (!ip_addr_isany(old_addr) && !ip_addr_isany(new_addr)) {
 801300e:	687b      	ldr	r3, [r7, #4]
 8013010:	2b00      	cmp	r3, #0
 8013012:	d01e      	beq.n	8013052 <udp_netif_ip_addr_changed+0x4e>
 8013014:	687b      	ldr	r3, [r7, #4]
 8013016:	681b      	ldr	r3, [r3, #0]
 8013018:	2b00      	cmp	r3, #0
 801301a:	d01a      	beq.n	8013052 <udp_netif_ip_addr_changed+0x4e>
 801301c:	683b      	ldr	r3, [r7, #0]
 801301e:	2b00      	cmp	r3, #0
 8013020:	d017      	beq.n	8013052 <udp_netif_ip_addr_changed+0x4e>
 8013022:	683b      	ldr	r3, [r7, #0]
 8013024:	681b      	ldr	r3, [r3, #0]
 8013026:	2b00      	cmp	r3, #0
 8013028:	d013      	beq.n	8013052 <udp_netif_ip_addr_changed+0x4e>
    for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
 801302a:	4b0c      	ldr	r3, [pc, #48]	; (801305c <udp_netif_ip_addr_changed+0x58>)
 801302c:	681b      	ldr	r3, [r3, #0]
 801302e:	60fb      	str	r3, [r7, #12]
 8013030:	e00c      	b.n	801304c <udp_netif_ip_addr_changed+0x48>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&upcb->local_ip, old_addr)) {
 8013032:	68fb      	ldr	r3, [r7, #12]
 8013034:	681a      	ldr	r2, [r3, #0]
 8013036:	687b      	ldr	r3, [r7, #4]
 8013038:	681b      	ldr	r3, [r3, #0]
 801303a:	429a      	cmp	r2, r3
 801303c:	d103      	bne.n	8013046 <udp_netif_ip_addr_changed+0x42>
        /* The PCB is bound to the old ipaddr and
         * is set to bound to the new one instead */
        ip_addr_copy(upcb->local_ip, *new_addr);
 801303e:	683b      	ldr	r3, [r7, #0]
 8013040:	681a      	ldr	r2, [r3, #0]
 8013042:	68fb      	ldr	r3, [r7, #12]
 8013044:	601a      	str	r2, [r3, #0]
    for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
 8013046:	68fb      	ldr	r3, [r7, #12]
 8013048:	691b      	ldr	r3, [r3, #16]
 801304a:	60fb      	str	r3, [r7, #12]
 801304c:	68fb      	ldr	r3, [r7, #12]
 801304e:	2b00      	cmp	r3, #0
 8013050:	d1ef      	bne.n	8013032 <udp_netif_ip_addr_changed+0x2e>
      }
    }
  }
}
 8013052:	46c0      	nop			; (mov r8, r8)
 8013054:	46bd      	mov	sp, r7
 8013056:	b004      	add	sp, #16
 8013058:	bd80      	pop	{r7, pc}
 801305a:	46c0      	nop			; (mov r8, r8)
 801305c:	20002b54 	.word	0x20002b54

08013060 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the icmp header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
 8013060:	b590      	push	{r4, r7, lr}
 8013062:	b08f      	sub	sp, #60	; 0x3c
 8013064:	af04      	add	r7, sp, #16
 8013066:	6078      	str	r0, [r7, #4]
 8013068:	6039      	str	r1, [r7, #0]
  const ip4_addr_t *src;

  ICMP_STATS_INC(icmp.recv);
  MIB2_STATS_INC(mib2.icmpinmsgs);

  iphdr_in = ip4_current_header();
 801306a:	4bde      	ldr	r3, [pc, #888]	; (80133e4 <icmp_input+0x384>)
 801306c:	689b      	ldr	r3, [r3, #8]
 801306e:	627b      	str	r3, [r7, #36]	; 0x24
  hlen = IPH_HL_BYTES(iphdr_in);
 8013070:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013072:	781b      	ldrb	r3, [r3, #0]
 8013074:	220f      	movs	r2, #15
 8013076:	4013      	ands	r3, r2
 8013078:	b2db      	uxtb	r3, r3
 801307a:	009b      	lsls	r3, r3, #2
 801307c:	b2da      	uxtb	r2, r3
 801307e:	2122      	movs	r1, #34	; 0x22
 8013080:	187b      	adds	r3, r7, r1
 8013082:	801a      	strh	r2, [r3, #0]
  if (hlen < IP_HLEN) {
 8013084:	187b      	adds	r3, r7, r1
 8013086:	881b      	ldrh	r3, [r3, #0]
 8013088:	2b13      	cmp	r3, #19
 801308a:	d800      	bhi.n	801308e <icmp_input+0x2e>
 801308c:	e1a5      	b.n	80133da <icmp_input+0x37a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short IP header (%"S16_F" bytes) received\n", hlen));
    goto lenerr;
  }
  if (p->len < sizeof(u16_t) * 2) {
 801308e:	687b      	ldr	r3, [r7, #4]
 8013090:	895b      	ldrh	r3, [r3, #10]
 8013092:	2b03      	cmp	r3, #3
 8013094:	d800      	bhi.n	8013098 <icmp_input+0x38>
 8013096:	e1a2      	b.n	80133de <icmp_input+0x37e>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
 8013098:	687b      	ldr	r3, [r7, #4]
 801309a:	685a      	ldr	r2, [r3, #4]
 801309c:	2121      	movs	r1, #33	; 0x21
 801309e:	187b      	adds	r3, r7, r1
 80130a0:	7812      	ldrb	r2, [r2, #0]
 80130a2:	701a      	strb	r2, [r3, #0]
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload) + 1);
 80130a4:	687b      	ldr	r3, [r7, #4]
 80130a6:	685a      	ldr	r2, [r3, #4]
 80130a8:	2320      	movs	r3, #32
 80130aa:	18fb      	adds	r3, r7, r3
 80130ac:	7852      	ldrb	r2, [r2, #1]
 80130ae:	701a      	strb	r2, [r3, #0]
  /* if debug is enabled but debug statement below is somehow disabled: */
  LWIP_UNUSED_ARG(code);
#endif /* LWIP_DEBUG */
  switch (type) {
 80130b0:	187b      	adds	r3, r7, r1
 80130b2:	781b      	ldrb	r3, [r3, #0]
 80130b4:	2b00      	cmp	r3, #0
 80130b6:	d100      	bne.n	80130ba <icmp_input+0x5a>
 80130b8:	e187      	b.n	80133ca <icmp_input+0x36a>
 80130ba:	2b08      	cmp	r3, #8
 80130bc:	d000      	beq.n	80130c0 <icmp_input+0x60>
 80130be:	e187      	b.n	80133d0 <icmp_input+0x370>
         (as obviously, an echo request has been sent, too). */
      MIB2_STATS_INC(mib2.icmpinechoreps);
      break;
    case ICMP_ECHO:
      MIB2_STATS_INC(mib2.icmpinechos);
      src = ip4_current_dest_addr();
 80130c0:	4bc9      	ldr	r3, [pc, #804]	; (80133e8 <icmp_input+0x388>)
 80130c2:	61fb      	str	r3, [r7, #28]
      /* multicast destination address? */
      if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
 80130c4:	4bc7      	ldr	r3, [pc, #796]	; (80133e4 <icmp_input+0x384>)
 80130c6:	695b      	ldr	r3, [r3, #20]
 80130c8:	22f0      	movs	r2, #240	; 0xf0
 80130ca:	4013      	ands	r3, r2
 80130cc:	2be0      	cmp	r3, #224	; 0xe0
 80130ce:	d100      	bne.n	80130d2 <icmp_input+0x72>
 80130d0:	e19c      	b.n	801340c <icmp_input+0x3ac>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast pings\n"));
        goto icmperr;
#endif /* LWIP_MULTICAST_PING */
      }
      /* broadcast destination address? */
      if (ip4_addr_isbroadcast(ip4_current_dest_addr(), ip_current_netif())) {
 80130d2:	4bc4      	ldr	r3, [pc, #784]	; (80133e4 <icmp_input+0x384>)
 80130d4:	695a      	ldr	r2, [r3, #20]
 80130d6:	4bc3      	ldr	r3, [pc, #780]	; (80133e4 <icmp_input+0x384>)
 80130d8:	681b      	ldr	r3, [r3, #0]
 80130da:	0019      	movs	r1, r3
 80130dc:	0010      	movs	r0, r2
 80130de:	f000 fe9d 	bl	8013e1c <ip4_addr_isbroadcast_u32>
 80130e2:	1e03      	subs	r3, r0, #0
 80130e4:	d000      	beq.n	80130e8 <icmp_input+0x88>
 80130e6:	e193      	b.n	8013410 <icmp_input+0x3b0>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to broadcast pings\n"));
        goto icmperr;
#endif /* LWIP_BROADCAST_PING */
      }
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
      if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
 80130e8:	687b      	ldr	r3, [r7, #4]
 80130ea:	891b      	ldrh	r3, [r3, #8]
 80130ec:	2b07      	cmp	r3, #7
 80130ee:	d800      	bhi.n	80130f2 <icmp_input+0x92>
 80130f0:	e186      	b.n	8013400 <icmp_input+0x3a0>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
        goto lenerr;
      }
#if CHECKSUM_CHECK_ICMP
      IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_ICMP) {
        if (inet_chksum_pbuf(p) != 0) {
 80130f2:	687b      	ldr	r3, [r7, #4]
 80130f4:	0018      	movs	r0, r3
 80130f6:	f7f5 fad8 	bl	80086aa <inet_chksum_pbuf>
 80130fa:	1e03      	subs	r3, r0, #0
 80130fc:	d004      	beq.n	8013108 <icmp_input+0xa8>
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
          pbuf_free(p);
 80130fe:	687b      	ldr	r3, [r7, #4]
 8013100:	0018      	movs	r0, r3
 8013102:	f7f6 fedb 	bl	8009ebc <pbuf_free>
          ICMP_STATS_INC(icmp.chkerr);
          MIB2_STATS_INC(mib2.icmpinerrors);
          return;
 8013106:	e18d      	b.n	8013424 <icmp_input+0x3c4>
        }
      }
#endif
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
      if (pbuf_add_header(p, hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN)) {
 8013108:	2422      	movs	r4, #34	; 0x22
 801310a:	193b      	adds	r3, r7, r4
 801310c:	881b      	ldrh	r3, [r3, #0]
 801310e:	3310      	adds	r3, #16
 8013110:	001a      	movs	r2, r3
 8013112:	687b      	ldr	r3, [r7, #4]
 8013114:	0011      	movs	r1, r2
 8013116:	0018      	movs	r0, r3
 8013118:	f7f6 fde8 	bl	8009cec <pbuf_add_header>
 801311c:	1e03      	subs	r3, r0, #0
 801311e:	d05a      	beq.n	80131d6 <icmp_input+0x176>
        /* p is not big enough to contain link headers
         * allocate a new one and copy p into it
         */
        struct pbuf *r;
        u16_t alloc_len = (u16_t)(p->tot_len + hlen);
 8013120:	687b      	ldr	r3, [r7, #4]
 8013122:	8919      	ldrh	r1, [r3, #8]
 8013124:	201a      	movs	r0, #26
 8013126:	183b      	adds	r3, r7, r0
 8013128:	193a      	adds	r2, r7, r4
 801312a:	8812      	ldrh	r2, [r2, #0]
 801312c:	188a      	adds	r2, r1, r2
 801312e:	801a      	strh	r2, [r3, #0]
        if (alloc_len < p->tot_len) {
 8013130:	687b      	ldr	r3, [r7, #4]
 8013132:	891b      	ldrh	r3, [r3, #8]
 8013134:	183a      	adds	r2, r7, r0
 8013136:	8812      	ldrh	r2, [r2, #0]
 8013138:	429a      	cmp	r2, r3
 801313a:	d200      	bcs.n	801313e <icmp_input+0xde>
 801313c:	e16a      	b.n	8013414 <icmp_input+0x3b4>
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed (tot_len overflow)\n"));
          goto icmperr;
        }
        /* allocate new packet buffer with space for link headers */
        r = pbuf_alloc(PBUF_LINK, alloc_len, PBUF_RAM);
 801313e:	23a0      	movs	r3, #160	; 0xa0
 8013140:	009a      	lsls	r2, r3, #2
 8013142:	183b      	adds	r3, r7, r0
 8013144:	881b      	ldrh	r3, [r3, #0]
 8013146:	0019      	movs	r1, r3
 8013148:	2010      	movs	r0, #16
 801314a:	f7f6 fb3f 	bl	80097cc <pbuf_alloc>
 801314e:	0003      	movs	r3, r0
 8013150:	617b      	str	r3, [r7, #20]
        if (r == NULL) {
 8013152:	697b      	ldr	r3, [r7, #20]
 8013154:	2b00      	cmp	r3, #0
 8013156:	d100      	bne.n	801315a <icmp_input+0xfa>
 8013158:	e15e      	b.n	8013418 <icmp_input+0x3b8>
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
          goto icmperr;
        }
        if (r->len < hlen + sizeof(struct icmp_echo_hdr)) {
 801315a:	697b      	ldr	r3, [r7, #20]
 801315c:	895b      	ldrh	r3, [r3, #10]
 801315e:	001a      	movs	r2, r3
 8013160:	193b      	adds	r3, r7, r4
 8013162:	881b      	ldrh	r3, [r3, #0]
 8013164:	3308      	adds	r3, #8
 8013166:	429a      	cmp	r2, r3
 8013168:	d204      	bcs.n	8013174 <icmp_input+0x114>
          LWIP_DEBUGF(ICMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("first pbuf cannot hold the ICMP header"));
          pbuf_free(r);
 801316a:	697b      	ldr	r3, [r7, #20]
 801316c:	0018      	movs	r0, r3
 801316e:	f7f6 fea5 	bl	8009ebc <pbuf_free>
          goto icmperr;
 8013172:	e152      	b.n	801341a <icmp_input+0x3ba>
        }
        /* copy the ip header */
        MEMCPY(r->payload, iphdr_in, hlen);
 8013174:	697b      	ldr	r3, [r7, #20]
 8013176:	6858      	ldr	r0, [r3, #4]
 8013178:	2422      	movs	r4, #34	; 0x22
 801317a:	193b      	adds	r3, r7, r4
 801317c:	881a      	ldrh	r2, [r3, #0]
 801317e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013180:	0019      	movs	r1, r3
 8013182:	f009 fea3 	bl	801cecc <memcpy>
        /* switch r->payload back to icmp header (cannot fail) */
        if (pbuf_remove_header(r, hlen)) {
 8013186:	193b      	adds	r3, r7, r4
 8013188:	881a      	ldrh	r2, [r3, #0]
 801318a:	697b      	ldr	r3, [r7, #20]
 801318c:	0011      	movs	r1, r2
 801318e:	0018      	movs	r0, r3
 8013190:	f7f6 fdbc 	bl	8009d0c <pbuf_remove_header>
 8013194:	1e03      	subs	r3, r0, #0
 8013196:	d00a      	beq.n	80131ae <icmp_input+0x14e>
          LWIP_ASSERT("icmp_input: moving r->payload to icmp header failed\n", 0);
 8013198:	4b94      	ldr	r3, [pc, #592]	; (80133ec <icmp_input+0x38c>)
 801319a:	4995      	ldr	r1, [pc, #596]	; (80133f0 <icmp_input+0x390>)
 801319c:	4895      	ldr	r0, [pc, #596]	; (80133f4 <icmp_input+0x394>)
 801319e:	22b6      	movs	r2, #182	; 0xb6
 80131a0:	f7ef fd12 	bl	8002bc8 <app_debug_rtt_raw>
          pbuf_free(r);
 80131a4:	697b      	ldr	r3, [r7, #20]
 80131a6:	0018      	movs	r0, r3
 80131a8:	f7f6 fe88 	bl	8009ebc <pbuf_free>
          goto icmperr;
 80131ac:	e135      	b.n	801341a <icmp_input+0x3ba>
        }
        /* copy the rest of the packet without ip header */
        if (pbuf_copy(r, p) != ERR_OK) {
 80131ae:	687a      	ldr	r2, [r7, #4]
 80131b0:	697b      	ldr	r3, [r7, #20]
 80131b2:	0011      	movs	r1, r2
 80131b4:	0018      	movs	r0, r3
 80131b6:	f7f7 f823 	bl	800a200 <pbuf_copy>
 80131ba:	1e03      	subs	r3, r0, #0
 80131bc:	d004      	beq.n	80131c8 <icmp_input+0x168>
          LWIP_DEBUGF(ICMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("icmp_input: copying to new pbuf failed"));
          pbuf_free(r);
 80131be:	697b      	ldr	r3, [r7, #20]
 80131c0:	0018      	movs	r0, r3
 80131c2:	f7f6 fe7b 	bl	8009ebc <pbuf_free>
          goto icmperr;
 80131c6:	e128      	b.n	801341a <icmp_input+0x3ba>
        }
        /* free the original p */
        pbuf_free(p);
 80131c8:	687b      	ldr	r3, [r7, #4]
 80131ca:	0018      	movs	r0, r3
 80131cc:	f7f6 fe76 	bl	8009ebc <pbuf_free>
        /* we now have an identical copy of p that has room for link headers */
        p = r;
 80131d0:	697b      	ldr	r3, [r7, #20]
 80131d2:	607b      	str	r3, [r7, #4]
 80131d4:	e012      	b.n	80131fc <icmp_input+0x19c>
      } else {
        /* restore p->payload to point to icmp header (cannot fail) */
        if (pbuf_remove_header(p, hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN)) {
 80131d6:	2322      	movs	r3, #34	; 0x22
 80131d8:	18fb      	adds	r3, r7, r3
 80131da:	881b      	ldrh	r3, [r3, #0]
 80131dc:	3310      	adds	r3, #16
 80131de:	001a      	movs	r2, r3
 80131e0:	687b      	ldr	r3, [r7, #4]
 80131e2:	0011      	movs	r1, r2
 80131e4:	0018      	movs	r0, r3
 80131e6:	f7f6 fd91 	bl	8009d0c <pbuf_remove_header>
 80131ea:	1e03      	subs	r3, r0, #0
 80131ec:	d006      	beq.n	80131fc <icmp_input+0x19c>
          LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
 80131ee:	4b7f      	ldr	r3, [pc, #508]	; (80133ec <icmp_input+0x38c>)
 80131f0:	4981      	ldr	r1, [pc, #516]	; (80133f8 <icmp_input+0x398>)
 80131f2:	4880      	ldr	r0, [pc, #512]	; (80133f4 <icmp_input+0x394>)
 80131f4:	22c7      	movs	r2, #199	; 0xc7
 80131f6:	f7ef fce7 	bl	8002bc8 <app_debug_rtt_raw>
          goto icmperr;
 80131fa:	e10e      	b.n	801341a <icmp_input+0x3ba>
      }
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
      /* At this point, all checks are OK. */
      /* We generate an answer by switching the dest and src ip addresses,
       * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
      iecho = (struct icmp_echo_hdr *)p->payload;
 80131fc:	687b      	ldr	r3, [r7, #4]
 80131fe:	685b      	ldr	r3, [r3, #4]
 8013200:	613b      	str	r3, [r7, #16]
      if (pbuf_add_header(p, hlen)) {
 8013202:	2322      	movs	r3, #34	; 0x22
 8013204:	18fb      	adds	r3, r7, r3
 8013206:	881a      	ldrh	r2, [r3, #0]
 8013208:	687b      	ldr	r3, [r7, #4]
 801320a:	0011      	movs	r1, r2
 801320c:	0018      	movs	r0, r3
 801320e:	f7f6 fd6d 	bl	8009cec <pbuf_add_header>
 8013212:	1e03      	subs	r3, r0, #0
 8013214:	d000      	beq.n	8013218 <icmp_input+0x1b8>
 8013216:	e0da      	b.n	80133ce <icmp_input+0x36e>
        LWIP_DEBUGF(ICMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Can't move over header in packet"));
      } else {
        err_t ret;
        struct ip_hdr *iphdr = (struct ip_hdr *)p->payload;
 8013218:	687b      	ldr	r3, [r7, #4]
 801321a:	685b      	ldr	r3, [r3, #4]
 801321c:	60fb      	str	r3, [r7, #12]
        ip4_addr_copy(iphdr->src, *src);
 801321e:	69fb      	ldr	r3, [r7, #28]
 8013220:	681a      	ldr	r2, [r3, #0]
 8013222:	68fb      	ldr	r3, [r7, #12]
 8013224:	21ff      	movs	r1, #255	; 0xff
 8013226:	4011      	ands	r1, r2
 8013228:	000c      	movs	r4, r1
 801322a:	7b19      	ldrb	r1, [r3, #12]
 801322c:	2000      	movs	r0, #0
 801322e:	4001      	ands	r1, r0
 8013230:	1c08      	adds	r0, r1, #0
 8013232:	1c21      	adds	r1, r4, #0
 8013234:	4301      	orrs	r1, r0
 8013236:	7319      	strb	r1, [r3, #12]
 8013238:	0a11      	lsrs	r1, r2, #8
 801323a:	20ff      	movs	r0, #255	; 0xff
 801323c:	4001      	ands	r1, r0
 801323e:	000c      	movs	r4, r1
 8013240:	7b59      	ldrb	r1, [r3, #13]
 8013242:	2000      	movs	r0, #0
 8013244:	4001      	ands	r1, r0
 8013246:	1c08      	adds	r0, r1, #0
 8013248:	1c21      	adds	r1, r4, #0
 801324a:	4301      	orrs	r1, r0
 801324c:	7359      	strb	r1, [r3, #13]
 801324e:	0c11      	lsrs	r1, r2, #16
 8013250:	20ff      	movs	r0, #255	; 0xff
 8013252:	4001      	ands	r1, r0
 8013254:	000c      	movs	r4, r1
 8013256:	7b99      	ldrb	r1, [r3, #14]
 8013258:	2000      	movs	r0, #0
 801325a:	4001      	ands	r1, r0
 801325c:	1c08      	adds	r0, r1, #0
 801325e:	1c21      	adds	r1, r4, #0
 8013260:	4301      	orrs	r1, r0
 8013262:	7399      	strb	r1, [r3, #14]
 8013264:	0e10      	lsrs	r0, r2, #24
 8013266:	7bda      	ldrb	r2, [r3, #15]
 8013268:	2100      	movs	r1, #0
 801326a:	400a      	ands	r2, r1
 801326c:	1c11      	adds	r1, r2, #0
 801326e:	1c02      	adds	r2, r0, #0
 8013270:	430a      	orrs	r2, r1
 8013272:	73da      	strb	r2, [r3, #15]
        ip4_addr_copy(iphdr->dest, *ip4_current_src_addr());
 8013274:	4b5b      	ldr	r3, [pc, #364]	; (80133e4 <icmp_input+0x384>)
 8013276:	691a      	ldr	r2, [r3, #16]
 8013278:	68fb      	ldr	r3, [r7, #12]
 801327a:	21ff      	movs	r1, #255	; 0xff
 801327c:	4011      	ands	r1, r2
 801327e:	000c      	movs	r4, r1
 8013280:	7c19      	ldrb	r1, [r3, #16]
 8013282:	2000      	movs	r0, #0
 8013284:	4001      	ands	r1, r0
 8013286:	1c08      	adds	r0, r1, #0
 8013288:	1c21      	adds	r1, r4, #0
 801328a:	4301      	orrs	r1, r0
 801328c:	7419      	strb	r1, [r3, #16]
 801328e:	0a11      	lsrs	r1, r2, #8
 8013290:	20ff      	movs	r0, #255	; 0xff
 8013292:	4001      	ands	r1, r0
 8013294:	000c      	movs	r4, r1
 8013296:	7c59      	ldrb	r1, [r3, #17]
 8013298:	2000      	movs	r0, #0
 801329a:	4001      	ands	r1, r0
 801329c:	1c08      	adds	r0, r1, #0
 801329e:	1c21      	adds	r1, r4, #0
 80132a0:	4301      	orrs	r1, r0
 80132a2:	7459      	strb	r1, [r3, #17]
 80132a4:	0c11      	lsrs	r1, r2, #16
 80132a6:	20ff      	movs	r0, #255	; 0xff
 80132a8:	4001      	ands	r1, r0
 80132aa:	000c      	movs	r4, r1
 80132ac:	7c99      	ldrb	r1, [r3, #18]
 80132ae:	2000      	movs	r0, #0
 80132b0:	4001      	ands	r1, r0
 80132b2:	1c08      	adds	r0, r1, #0
 80132b4:	1c21      	adds	r1, r4, #0
 80132b6:	4301      	orrs	r1, r0
 80132b8:	7499      	strb	r1, [r3, #18]
 80132ba:	0e10      	lsrs	r0, r2, #24
 80132bc:	7cda      	ldrb	r2, [r3, #19]
 80132be:	2100      	movs	r1, #0
 80132c0:	400a      	ands	r2, r1
 80132c2:	1c11      	adds	r1, r2, #0
 80132c4:	1c02      	adds	r2, r0, #0
 80132c6:	430a      	orrs	r2, r1
 80132c8:	74da      	strb	r2, [r3, #19]
        ICMPH_TYPE_SET(iecho, ICMP_ER);
 80132ca:	693b      	ldr	r3, [r7, #16]
 80132cc:	2200      	movs	r2, #0
 80132ce:	701a      	strb	r2, [r3, #0]
#if CHECKSUM_GEN_ICMP
        IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_GEN_ICMP) {
          /* adjust the checksum */
          if (iecho->chksum > PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
 80132d0:	693b      	ldr	r3, [r7, #16]
 80132d2:	789a      	ldrb	r2, [r3, #2]
 80132d4:	78db      	ldrb	r3, [r3, #3]
 80132d6:	021b      	lsls	r3, r3, #8
 80132d8:	4313      	orrs	r3, r2
 80132da:	b29b      	uxth	r3, r3
 80132dc:	4a47      	ldr	r2, [pc, #284]	; (80133fc <icmp_input+0x39c>)
 80132de:	4293      	cmp	r3, r2
 80132e0:	d91c      	bls.n	801331c <icmp_input+0x2bc>
            iecho->chksum = (u16_t)(iecho->chksum + PP_HTONS((u16_t)(ICMP_ECHO << 8)) + 1);
 80132e2:	693b      	ldr	r3, [r7, #16]
 80132e4:	789a      	ldrb	r2, [r3, #2]
 80132e6:	78db      	ldrb	r3, [r3, #3]
 80132e8:	021b      	lsls	r3, r3, #8
 80132ea:	4313      	orrs	r3, r2
 80132ec:	b29b      	uxth	r3, r3
 80132ee:	3309      	adds	r3, #9
 80132f0:	b29a      	uxth	r2, r3
 80132f2:	693b      	ldr	r3, [r7, #16]
 80132f4:	21ff      	movs	r1, #255	; 0xff
 80132f6:	4011      	ands	r1, r2
 80132f8:	000c      	movs	r4, r1
 80132fa:	7899      	ldrb	r1, [r3, #2]
 80132fc:	2000      	movs	r0, #0
 80132fe:	4001      	ands	r1, r0
 8013300:	1c08      	adds	r0, r1, #0
 8013302:	1c21      	adds	r1, r4, #0
 8013304:	4301      	orrs	r1, r0
 8013306:	7099      	strb	r1, [r3, #2]
 8013308:	0a12      	lsrs	r2, r2, #8
 801330a:	b290      	uxth	r0, r2
 801330c:	78da      	ldrb	r2, [r3, #3]
 801330e:	2100      	movs	r1, #0
 8013310:	400a      	ands	r2, r1
 8013312:	1c11      	adds	r1, r2, #0
 8013314:	1c02      	adds	r2, r0, #0
 8013316:	430a      	orrs	r2, r1
 8013318:	70da      	strb	r2, [r3, #3]
 801331a:	e01b      	b.n	8013354 <icmp_input+0x2f4>
          } else {
            iecho->chksum = (u16_t)(iecho->chksum + PP_HTONS(ICMP_ECHO << 8));
 801331c:	693b      	ldr	r3, [r7, #16]
 801331e:	789a      	ldrb	r2, [r3, #2]
 8013320:	78db      	ldrb	r3, [r3, #3]
 8013322:	021b      	lsls	r3, r3, #8
 8013324:	4313      	orrs	r3, r2
 8013326:	b29b      	uxth	r3, r3
 8013328:	3308      	adds	r3, #8
 801332a:	b29a      	uxth	r2, r3
 801332c:	693b      	ldr	r3, [r7, #16]
 801332e:	21ff      	movs	r1, #255	; 0xff
 8013330:	4011      	ands	r1, r2
 8013332:	000c      	movs	r4, r1
 8013334:	7899      	ldrb	r1, [r3, #2]
 8013336:	2000      	movs	r0, #0
 8013338:	4001      	ands	r1, r0
 801333a:	1c08      	adds	r0, r1, #0
 801333c:	1c21      	adds	r1, r4, #0
 801333e:	4301      	orrs	r1, r0
 8013340:	7099      	strb	r1, [r3, #2]
 8013342:	0a12      	lsrs	r2, r2, #8
 8013344:	b290      	uxth	r0, r2
 8013346:	78da      	ldrb	r2, [r3, #3]
 8013348:	2100      	movs	r1, #0
 801334a:	400a      	ands	r2, r1
 801334c:	1c11      	adds	r1, r2, #0
 801334e:	1c02      	adds	r2, r0, #0
 8013350:	430a      	orrs	r2, r1
 8013352:	70da      	strb	r2, [r3, #3]
#else /* CHECKSUM_GEN_ICMP */
        iecho->chksum = 0;
#endif /* CHECKSUM_GEN_ICMP */

        /* Set the correct TTL and recalculate the header checksum. */
        IPH_TTL_SET(iphdr, ICMP_TTL);
 8013354:	68fb      	ldr	r3, [r7, #12]
 8013356:	22ff      	movs	r2, #255	; 0xff
 8013358:	721a      	strb	r2, [r3, #8]
        IPH_CHKSUM_SET(iphdr, 0);
 801335a:	68fb      	ldr	r3, [r7, #12]
 801335c:	7a9a      	ldrb	r2, [r3, #10]
 801335e:	2100      	movs	r1, #0
 8013360:	400a      	ands	r2, r1
 8013362:	729a      	strb	r2, [r3, #10]
 8013364:	7ada      	ldrb	r2, [r3, #11]
 8013366:	2100      	movs	r1, #0
 8013368:	400a      	ands	r2, r1
 801336a:	72da      	strb	r2, [r3, #11]
#if CHECKSUM_GEN_IP
        IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_GEN_IP) {
          IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, hlen));
 801336c:	2322      	movs	r3, #34	; 0x22
 801336e:	18fb      	adds	r3, r7, r3
 8013370:	881a      	ldrh	r2, [r3, #0]
 8013372:	68fb      	ldr	r3, [r7, #12]
 8013374:	0011      	movs	r1, r2
 8013376:	0018      	movs	r0, r3
 8013378:	f7f5 f982 	bl	8008680 <inet_chksum>
 801337c:	0003      	movs	r3, r0
 801337e:	001a      	movs	r2, r3
 8013380:	68fb      	ldr	r3, [r7, #12]
 8013382:	21ff      	movs	r1, #255	; 0xff
 8013384:	4011      	ands	r1, r2
 8013386:	000c      	movs	r4, r1
 8013388:	7a99      	ldrb	r1, [r3, #10]
 801338a:	2000      	movs	r0, #0
 801338c:	4001      	ands	r1, r0
 801338e:	1c08      	adds	r0, r1, #0
 8013390:	1c21      	adds	r1, r4, #0
 8013392:	4301      	orrs	r1, r0
 8013394:	7299      	strb	r1, [r3, #10]
 8013396:	0a12      	lsrs	r2, r2, #8
 8013398:	b290      	uxth	r0, r2
 801339a:	7ada      	ldrb	r2, [r3, #11]
 801339c:	2100      	movs	r1, #0
 801339e:	400a      	ands	r2, r1
 80133a0:	1c11      	adds	r1, r2, #0
 80133a2:	1c02      	adds	r2, r0, #0
 80133a4:	430a      	orrs	r2, r1
 80133a6:	72da      	strb	r2, [r3, #11]
        MIB2_STATS_INC(mib2.icmpoutmsgs);
        /* increase number of echo replies attempted to send */
        MIB2_STATS_INC(mib2.icmpoutechoreps);

        /* send an ICMP packet */
        ret = ip4_output_if(p, src, LWIP_IP_HDRINCL,
 80133a8:	230b      	movs	r3, #11
 80133aa:	18fc      	adds	r4, r7, r3
 80133ac:	69f9      	ldr	r1, [r7, #28]
 80133ae:	6878      	ldr	r0, [r7, #4]
 80133b0:	683b      	ldr	r3, [r7, #0]
 80133b2:	9302      	str	r3, [sp, #8]
 80133b4:	2301      	movs	r3, #1
 80133b6:	9301      	str	r3, [sp, #4]
 80133b8:	2300      	movs	r3, #0
 80133ba:	9300      	str	r3, [sp, #0]
 80133bc:	23ff      	movs	r3, #255	; 0xff
 80133be:	2200      	movs	r2, #0
 80133c0:	f000 fb06 	bl	80139d0 <ip4_output_if>
 80133c4:	0003      	movs	r3, r0
 80133c6:	7023      	strb	r3, [r4, #0]
                            ICMP_TTL, 0, IP_PROTO_ICMP, inp);
        if (ret != ERR_OK) {
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %s\n", lwip_strerr(ret)));
        }
      }
      break;
 80133c8:	e001      	b.n	80133ce <icmp_input+0x36e>
      break;
 80133ca:	46c0      	nop			; (mov r8, r8)
 80133cc:	e000      	b.n	80133d0 <icmp_input+0x370>
      break;
 80133ce:	46c0      	nop			; (mov r8, r8)
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n",
                               (s16_t)type, (s16_t)code));
      ICMP_STATS_INC(icmp.proterr);
      ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
 80133d0:	687b      	ldr	r3, [r7, #4]
 80133d2:	0018      	movs	r0, r3
 80133d4:	f7f6 fd72 	bl	8009ebc <pbuf_free>
  return;
 80133d8:	e024      	b.n	8013424 <icmp_input+0x3c4>
    goto lenerr;
 80133da:	46c0      	nop			; (mov r8, r8)
 80133dc:	e011      	b.n	8013402 <icmp_input+0x3a2>
    goto lenerr;
 80133de:	46c0      	nop			; (mov r8, r8)
 80133e0:	e00f      	b.n	8013402 <icmp_input+0x3a2>
 80133e2:	46c0      	nop			; (mov r8, r8)
 80133e4:	200018fc 	.word	0x200018fc
 80133e8:	20001910 	.word	0x20001910
 80133ec:	080217d4 	.word	0x080217d4
 80133f0:	08021800 	.word	0x08021800
 80133f4:	08021838 	.word	0x08021838
 80133f8:	08021864 	.word	0x08021864
 80133fc:	0000fff7 	.word	0x0000fff7
        goto lenerr;
 8013400:	46c0      	nop			; (mov r8, r8)
lenerr:
  pbuf_free(p);
 8013402:	687b      	ldr	r3, [r7, #4]
 8013404:	0018      	movs	r0, r3
 8013406:	f7f6 fd59 	bl	8009ebc <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  MIB2_STATS_INC(mib2.icmpinerrors);
  return;
 801340a:	e00b      	b.n	8013424 <icmp_input+0x3c4>
        goto icmperr;
 801340c:	46c0      	nop			; (mov r8, r8)
 801340e:	e004      	b.n	801341a <icmp_input+0x3ba>
        goto icmperr;
 8013410:	46c0      	nop			; (mov r8, r8)
 8013412:	e002      	b.n	801341a <icmp_input+0x3ba>
          goto icmperr;
 8013414:	46c0      	nop			; (mov r8, r8)
 8013416:	e000      	b.n	801341a <icmp_input+0x3ba>
          goto icmperr;
 8013418:	46c0      	nop			; (mov r8, r8)
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN || !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
icmperr:
  pbuf_free(p);
 801341a:	687b      	ldr	r3, [r7, #4]
 801341c:	0018      	movs	r0, r3
 801341e:	f7f6 fd4d 	bl	8009ebc <pbuf_free>
  ICMP_STATS_INC(icmp.err);
  MIB2_STATS_INC(mib2.icmpinerrors);
  return;
 8013422:	46c0      	nop			; (mov r8, r8)
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN || !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
}
 8013424:	46bd      	mov	sp, r7
 8013426:	b00b      	add	sp, #44	; 0x2c
 8013428:	bd90      	pop	{r4, r7, pc}
 801342a:	46c0      	nop			; (mov r8, r8)

0801342c <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
 801342c:	b580      	push	{r7, lr}
 801342e:	b082      	sub	sp, #8
 8013430:	af00      	add	r7, sp, #0
 8013432:	6078      	str	r0, [r7, #4]
 8013434:	000a      	movs	r2, r1
 8013436:	1cfb      	adds	r3, r7, #3
 8013438:	701a      	strb	r2, [r3, #0]
  MIB2_STATS_INC(mib2.icmpoutdestunreachs);
  icmp_send_response(p, ICMP_DUR, t);
 801343a:	1cfb      	adds	r3, r7, #3
 801343c:	781a      	ldrb	r2, [r3, #0]
 801343e:	687b      	ldr	r3, [r7, #4]
 8013440:	2103      	movs	r1, #3
 8013442:	0018      	movs	r0, r3
 8013444:	f000 f804 	bl	8013450 <icmp_send_response>
}
 8013448:	46c0      	nop			; (mov r8, r8)
 801344a:	46bd      	mov	sp, r7
 801344c:	b002      	add	sp, #8
 801344e:	bd80      	pop	{r7, pc}

08013450 <icmp_send_response>:
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
 8013450:	b5b0      	push	{r4, r5, r7, lr}
 8013452:	b08c      	sub	sp, #48	; 0x30
 8013454:	af04      	add	r7, sp, #16
 8013456:	6078      	str	r0, [r7, #4]
 8013458:	0008      	movs	r0, r1
 801345a:	0011      	movs	r1, r2
 801345c:	1cfb      	adds	r3, r7, #3
 801345e:	1c02      	adds	r2, r0, #0
 8013460:	701a      	strb	r2, [r3, #0]
 8013462:	1cbb      	adds	r3, r7, #2
 8013464:	1c0a      	adds	r2, r1, #0
 8013466:	701a      	strb	r2, [r3, #0]

  /* increase number of messages attempted to send */
  MIB2_STATS_INC(mib2.icmpoutmsgs);

  /* Keep IP header + up to 8 bytes */
  response_pkt_len = IP_HLEN + ICMP_DEST_UNREACH_DATASIZE;
 8013468:	211a      	movs	r1, #26
 801346a:	187b      	adds	r3, r7, r1
 801346c:	221c      	movs	r2, #28
 801346e:	801a      	strh	r2, [r3, #0]
  if (p->tot_len < response_pkt_len) {
 8013470:	687b      	ldr	r3, [r7, #4]
 8013472:	891b      	ldrh	r3, [r3, #8]
 8013474:	187a      	adds	r2, r7, r1
 8013476:	8812      	ldrh	r2, [r2, #0]
 8013478:	429a      	cmp	r2, r3
 801347a:	d903      	bls.n	8013484 <icmp_send_response+0x34>
    response_pkt_len = p->tot_len;
 801347c:	187b      	adds	r3, r7, r1
 801347e:	687a      	ldr	r2, [r7, #4]
 8013480:	8912      	ldrh	r2, [r2, #8]
 8013482:	801a      	strh	r2, [r3, #0]
  }

  /* ICMP header + part of original packet */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + response_pkt_len, PBUF_RAM);
 8013484:	241a      	movs	r4, #26
 8013486:	193b      	adds	r3, r7, r4
 8013488:	881b      	ldrh	r3, [r3, #0]
 801348a:	3308      	adds	r3, #8
 801348c:	b29b      	uxth	r3, r3
 801348e:	22a0      	movs	r2, #160	; 0xa0
 8013490:	0092      	lsls	r2, r2, #2
 8013492:	0019      	movs	r1, r3
 8013494:	2024      	movs	r0, #36	; 0x24
 8013496:	f7f6 f999 	bl	80097cc <pbuf_alloc>
 801349a:	0003      	movs	r3, r0
 801349c:	617b      	str	r3, [r7, #20]
  if (q == NULL) {
 801349e:	697b      	ldr	r3, [r7, #20]
 80134a0:	2b00      	cmp	r3, #0
 80134a2:	d100      	bne.n	80134a6 <icmp_send_response+0x56>
 80134a4:	e087      	b.n	80135b6 <icmp_send_response+0x166>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    MIB2_STATS_INC(mib2.icmpouterrors);
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
 80134a6:	697b      	ldr	r3, [r7, #20]
 80134a8:	895b      	ldrh	r3, [r3, #10]
 80134aa:	001a      	movs	r2, r3
 80134ac:	193b      	adds	r3, r7, r4
 80134ae:	881b      	ldrh	r3, [r3, #0]
 80134b0:	3308      	adds	r3, #8
 80134b2:	429a      	cmp	r2, r3
 80134b4:	d206      	bcs.n	80134c4 <icmp_send_response+0x74>
 80134b6:	4b42      	ldr	r3, [pc, #264]	; (80135c0 <icmp_send_response+0x170>)
 80134b8:	22b7      	movs	r2, #183	; 0xb7
 80134ba:	0052      	lsls	r2, r2, #1
 80134bc:	4941      	ldr	r1, [pc, #260]	; (80135c4 <icmp_send_response+0x174>)
 80134be:	4842      	ldr	r0, [pc, #264]	; (80135c8 <icmp_send_response+0x178>)
 80134c0:	f7ef fb82 	bl	8002bc8 <app_debug_rtt_raw>
              (q->len >= (sizeof(struct icmp_echo_hdr) + response_pkt_len)));

  iphdr = (struct ip_hdr *)p->payload;
 80134c4:	687b      	ldr	r3, [r7, #4]
 80134c6:	685b      	ldr	r3, [r3, #4]
 80134c8:	613b      	str	r3, [r7, #16]
  ip4_addr_debug_print_val(ICMP_DEBUG, iphdr->src);
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip4_addr_debug_print_val(ICMP_DEBUG, iphdr->dest);
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
 80134ca:	697b      	ldr	r3, [r7, #20]
 80134cc:	685b      	ldr	r3, [r3, #4]
 80134ce:	60fb      	str	r3, [r7, #12]
  icmphdr->type = type;
 80134d0:	68fb      	ldr	r3, [r7, #12]
 80134d2:	1cfa      	adds	r2, r7, #3
 80134d4:	7812      	ldrb	r2, [r2, #0]
 80134d6:	701a      	strb	r2, [r3, #0]
  icmphdr->code = code;
 80134d8:	68fb      	ldr	r3, [r7, #12]
 80134da:	1cba      	adds	r2, r7, #2
 80134dc:	7812      	ldrb	r2, [r2, #0]
 80134de:	705a      	strb	r2, [r3, #1]
  icmphdr->id = 0;
 80134e0:	68fb      	ldr	r3, [r7, #12]
 80134e2:	791a      	ldrb	r2, [r3, #4]
 80134e4:	2100      	movs	r1, #0
 80134e6:	400a      	ands	r2, r1
 80134e8:	711a      	strb	r2, [r3, #4]
 80134ea:	795a      	ldrb	r2, [r3, #5]
 80134ec:	2100      	movs	r1, #0
 80134ee:	400a      	ands	r2, r1
 80134f0:	715a      	strb	r2, [r3, #5]
  icmphdr->seqno = 0;
 80134f2:	68fb      	ldr	r3, [r7, #12]
 80134f4:	799a      	ldrb	r2, [r3, #6]
 80134f6:	2100      	movs	r1, #0
 80134f8:	400a      	ands	r2, r1
 80134fa:	719a      	strb	r2, [r3, #6]
 80134fc:	79da      	ldrb	r2, [r3, #7]
 80134fe:	2100      	movs	r1, #0
 8013500:	400a      	ands	r2, r1
 8013502:	71da      	strb	r2, [r3, #7]

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 8013504:	697b      	ldr	r3, [r7, #20]
 8013506:	685b      	ldr	r3, [r3, #4]
 8013508:	3308      	adds	r3, #8
 801350a:	0018      	movs	r0, r3
 801350c:	687b      	ldr	r3, [r7, #4]
 801350e:	6859      	ldr	r1, [r3, #4]
 8013510:	231a      	movs	r3, #26
 8013512:	18fb      	adds	r3, r7, r3
 8013514:	881b      	ldrh	r3, [r3, #0]
 8013516:	001a      	movs	r2, r3
 8013518:	f009 fcd8 	bl	801cecc <memcpy>
          response_pkt_len);

  ip4_addr_copy(iphdr_src, iphdr->src);
 801351c:	693b      	ldr	r3, [r7, #16]
 801351e:	7b1a      	ldrb	r2, [r3, #12]
 8013520:	7b59      	ldrb	r1, [r3, #13]
 8013522:	0209      	lsls	r1, r1, #8
 8013524:	430a      	orrs	r2, r1
 8013526:	7b99      	ldrb	r1, [r3, #14]
 8013528:	0409      	lsls	r1, r1, #16
 801352a:	430a      	orrs	r2, r1
 801352c:	7bdb      	ldrb	r3, [r3, #15]
 801352e:	061b      	lsls	r3, r3, #24
 8013530:	4313      	orrs	r3, r2
 8013532:	60bb      	str	r3, [r7, #8]
    ip4_addr_t iphdr_dst;
    ip4_addr_copy(iphdr_dst, iphdr->dest);
    netif = ip4_route_src(&iphdr_dst, &iphdr_src);
  }
#else
  netif = ip4_route(&iphdr_src);
 8013534:	2508      	movs	r5, #8
 8013536:	197b      	adds	r3, r7, r5
 8013538:	0018      	movs	r0, r3
 801353a:	f000 f847 	bl	80135cc <ip4_route>
 801353e:	0003      	movs	r3, r0
 8013540:	61fb      	str	r3, [r7, #28]
#endif
  if (netif != NULL) {
 8013542:	69fb      	ldr	r3, [r7, #28]
 8013544:	2b00      	cmp	r3, #0
 8013546:	d031      	beq.n	80135ac <icmp_send_response+0x15c>
    /* calculate checksum */
    icmphdr->chksum = 0;
 8013548:	68fb      	ldr	r3, [r7, #12]
 801354a:	789a      	ldrb	r2, [r3, #2]
 801354c:	2100      	movs	r1, #0
 801354e:	400a      	ands	r2, r1
 8013550:	709a      	strb	r2, [r3, #2]
 8013552:	78da      	ldrb	r2, [r3, #3]
 8013554:	2100      	movs	r1, #0
 8013556:	400a      	ands	r2, r1
 8013558:	70da      	strb	r2, [r3, #3]
#if CHECKSUM_GEN_ICMP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_ICMP) {
      icmphdr->chksum = inet_chksum(icmphdr, q->len);
 801355a:	697b      	ldr	r3, [r7, #20]
 801355c:	895a      	ldrh	r2, [r3, #10]
 801355e:	68fb      	ldr	r3, [r7, #12]
 8013560:	0011      	movs	r1, r2
 8013562:	0018      	movs	r0, r3
 8013564:	f7f5 f88c 	bl	8008680 <inet_chksum>
 8013568:	0003      	movs	r3, r0
 801356a:	001a      	movs	r2, r3
 801356c:	68fb      	ldr	r3, [r7, #12]
 801356e:	21ff      	movs	r1, #255	; 0xff
 8013570:	4011      	ands	r1, r2
 8013572:	000c      	movs	r4, r1
 8013574:	7899      	ldrb	r1, [r3, #2]
 8013576:	2000      	movs	r0, #0
 8013578:	4001      	ands	r1, r0
 801357a:	1c08      	adds	r0, r1, #0
 801357c:	1c21      	adds	r1, r4, #0
 801357e:	4301      	orrs	r1, r0
 8013580:	7099      	strb	r1, [r3, #2]
 8013582:	0a12      	lsrs	r2, r2, #8
 8013584:	b290      	uxth	r0, r2
 8013586:	78da      	ldrb	r2, [r3, #3]
 8013588:	2100      	movs	r1, #0
 801358a:	400a      	ands	r2, r1
 801358c:	1c11      	adds	r1, r2, #0
 801358e:	1c02      	adds	r2, r0, #0
 8013590:	430a      	orrs	r2, r1
 8013592:	70da      	strb	r2, [r3, #3]
    }
#endif
    ICMP_STATS_INC(icmp.xmit);
    ip4_output_if(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP, netif);
 8013594:	197a      	adds	r2, r7, r5
 8013596:	6978      	ldr	r0, [r7, #20]
 8013598:	69fb      	ldr	r3, [r7, #28]
 801359a:	9302      	str	r3, [sp, #8]
 801359c:	2301      	movs	r3, #1
 801359e:	9301      	str	r3, [sp, #4]
 80135a0:	2300      	movs	r3, #0
 80135a2:	9300      	str	r3, [sp, #0]
 80135a4:	23ff      	movs	r3, #255	; 0xff
 80135a6:	2100      	movs	r1, #0
 80135a8:	f000 fa12 	bl	80139d0 <ip4_output_if>
  }
  pbuf_free(q);
 80135ac:	697b      	ldr	r3, [r7, #20]
 80135ae:	0018      	movs	r0, r3
 80135b0:	f7f6 fc84 	bl	8009ebc <pbuf_free>
 80135b4:	e000      	b.n	80135b8 <icmp_send_response+0x168>
    return;
 80135b6:	46c0      	nop			; (mov r8, r8)
}
 80135b8:	46bd      	mov	sp, r7
 80135ba:	b008      	add	sp, #32
 80135bc:	bdb0      	pop	{r4, r5, r7, pc}
 80135be:	46c0      	nop			; (mov r8, r8)
 80135c0:	080217d4 	.word	0x080217d4
 80135c4:	08021898 	.word	0x08021898
 80135c8:	08021838 	.word	0x08021838

080135cc <ip4_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip4_route(const ip4_addr_t *dest)
{
 80135cc:	b580      	push	{r7, lr}
 80135ce:	b084      	sub	sp, #16
 80135d0:	af00      	add	r7, sp, #0
 80135d2:	6078      	str	r0, [r7, #4]

  /* bug #54569: in case LWIP_SINGLE_NETIF=1 and LWIP_DEBUGF() disabled, the following loop is optimized away */
  LWIP_UNUSED_ARG(dest);

  /* iterate through netifs */
  NETIF_FOREACH(netif) {
 80135d4:	4b33      	ldr	r3, [pc, #204]	; (80136a4 <ip4_route+0xd8>)
 80135d6:	681b      	ldr	r3, [r3, #0]
 80135d8:	60fb      	str	r3, [r7, #12]
 80135da:	e037      	b.n	801364c <ip4_route+0x80>
    /* is the netif up, does it have a link and a valid address? */
    if (netif_is_up(netif) && netif_is_link_up(netif) && !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 80135dc:	68fb      	ldr	r3, [r7, #12]
 80135de:	2231      	movs	r2, #49	; 0x31
 80135e0:	5c9b      	ldrb	r3, [r3, r2]
 80135e2:	1c1a      	adds	r2, r3, #0
 80135e4:	2301      	movs	r3, #1
 80135e6:	4013      	ands	r3, r2
 80135e8:	b2db      	uxtb	r3, r3
 80135ea:	2b00      	cmp	r3, #0
 80135ec:	d02b      	beq.n	8013646 <ip4_route+0x7a>
 80135ee:	68fb      	ldr	r3, [r7, #12]
 80135f0:	2231      	movs	r2, #49	; 0x31
 80135f2:	5c9b      	ldrb	r3, [r3, r2]
 80135f4:	089b      	lsrs	r3, r3, #2
 80135f6:	1c1a      	adds	r2, r3, #0
 80135f8:	2301      	movs	r3, #1
 80135fa:	4013      	ands	r3, r2
 80135fc:	b2db      	uxtb	r3, r3
 80135fe:	2b00      	cmp	r3, #0
 8013600:	d021      	beq.n	8013646 <ip4_route+0x7a>
 8013602:	68fb      	ldr	r3, [r7, #12]
 8013604:	3304      	adds	r3, #4
 8013606:	681b      	ldr	r3, [r3, #0]
 8013608:	2b00      	cmp	r3, #0
 801360a:	d01c      	beq.n	8013646 <ip4_route+0x7a>
      /* network mask matches? */
      if (ip4_addr_netcmp(dest, netif_ip4_addr(netif), netif_ip4_netmask(netif))) {
 801360c:	687b      	ldr	r3, [r7, #4]
 801360e:	681a      	ldr	r2, [r3, #0]
 8013610:	68fb      	ldr	r3, [r7, #12]
 8013612:	3304      	adds	r3, #4
 8013614:	681b      	ldr	r3, [r3, #0]
 8013616:	405a      	eors	r2, r3
 8013618:	68fb      	ldr	r3, [r7, #12]
 801361a:	3308      	adds	r3, #8
 801361c:	681b      	ldr	r3, [r3, #0]
 801361e:	4013      	ands	r3, r2
 8013620:	d101      	bne.n	8013626 <ip4_route+0x5a>
        /* return netif on which to forward IP packet */
        return netif;
 8013622:	68fb      	ldr	r3, [r7, #12]
 8013624:	e039      	b.n	801369a <ip4_route+0xce>
      }
      /* gateway matches on a non broadcast interface? (i.e. peer in a point to point interface) */
      if (((netif->flags & NETIF_FLAG_BROADCAST) == 0) && ip4_addr_cmp(dest, netif_ip4_gw(netif))) {
 8013626:	68fb      	ldr	r3, [r7, #12]
 8013628:	2231      	movs	r2, #49	; 0x31
 801362a:	5c9b      	ldrb	r3, [r3, r2]
 801362c:	001a      	movs	r2, r3
 801362e:	2302      	movs	r3, #2
 8013630:	4013      	ands	r3, r2
 8013632:	d108      	bne.n	8013646 <ip4_route+0x7a>
 8013634:	687b      	ldr	r3, [r7, #4]
 8013636:	681a      	ldr	r2, [r3, #0]
 8013638:	68fb      	ldr	r3, [r7, #12]
 801363a:	330c      	adds	r3, #12
 801363c:	681b      	ldr	r3, [r3, #0]
 801363e:	429a      	cmp	r2, r3
 8013640:	d101      	bne.n	8013646 <ip4_route+0x7a>
        /* return netif on which to forward IP packet */
        return netif;
 8013642:	68fb      	ldr	r3, [r7, #12]
 8013644:	e029      	b.n	801369a <ip4_route+0xce>
  NETIF_FOREACH(netif) {
 8013646:	68fb      	ldr	r3, [r7, #12]
 8013648:	681b      	ldr	r3, [r3, #0]
 801364a:	60fb      	str	r3, [r7, #12]
 801364c:	68fb      	ldr	r3, [r7, #12]
 801364e:	2b00      	cmp	r3, #0
 8013650:	d1c4      	bne.n	80135dc <ip4_route+0x10>
    return netif;
  }
#endif
#endif /* !LWIP_SINGLE_NETIF */

  if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
 8013652:	4b15      	ldr	r3, [pc, #84]	; (80136a8 <ip4_route+0xdc>)
 8013654:	681b      	ldr	r3, [r3, #0]
 8013656:	2b00      	cmp	r3, #0
 8013658:	d01b      	beq.n	8013692 <ip4_route+0xc6>
 801365a:	4b13      	ldr	r3, [pc, #76]	; (80136a8 <ip4_route+0xdc>)
 801365c:	681b      	ldr	r3, [r3, #0]
 801365e:	2231      	movs	r2, #49	; 0x31
 8013660:	5c9b      	ldrb	r3, [r3, r2]
 8013662:	001a      	movs	r2, r3
 8013664:	2301      	movs	r3, #1
 8013666:	4013      	ands	r3, r2
 8013668:	d013      	beq.n	8013692 <ip4_route+0xc6>
 801366a:	4b0f      	ldr	r3, [pc, #60]	; (80136a8 <ip4_route+0xdc>)
 801366c:	681b      	ldr	r3, [r3, #0]
 801366e:	2231      	movs	r2, #49	; 0x31
 8013670:	5c9b      	ldrb	r3, [r3, r2]
 8013672:	001a      	movs	r2, r3
 8013674:	2304      	movs	r3, #4
 8013676:	4013      	ands	r3, r2
 8013678:	d00b      	beq.n	8013692 <ip4_route+0xc6>
      ip4_addr_isany_val(*netif_ip4_addr(netif_default)) || ip4_addr_isloopback(dest)) {
 801367a:	4b0b      	ldr	r3, [pc, #44]	; (80136a8 <ip4_route+0xdc>)
 801367c:	681b      	ldr	r3, [r3, #0]
 801367e:	3304      	adds	r3, #4
 8013680:	681b      	ldr	r3, [r3, #0]
  if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
 8013682:	2b00      	cmp	r3, #0
 8013684:	d005      	beq.n	8013692 <ip4_route+0xc6>
      ip4_addr_isany_val(*netif_ip4_addr(netif_default)) || ip4_addr_isloopback(dest)) {
 8013686:	687b      	ldr	r3, [r7, #4]
 8013688:	681b      	ldr	r3, [r3, #0]
 801368a:	22ff      	movs	r2, #255	; 0xff
 801368c:	4013      	ands	r3, r2
 801368e:	2b7f      	cmp	r3, #127	; 0x7f
 8013690:	d101      	bne.n	8013696 <ip4_route+0xca>
       If this is not good enough for you, use LWIP_HOOK_IP4_ROUTE() */
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_route: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
                ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
    MIB2_STATS_INC(mib2.ipoutnoroutes);
    return NULL;
 8013692:	2300      	movs	r3, #0
 8013694:	e001      	b.n	801369a <ip4_route+0xce>
  }

  return netif_default;
 8013696:	4b04      	ldr	r3, [pc, #16]	; (80136a8 <ip4_route+0xdc>)
 8013698:	681b      	ldr	r3, [r3, #0]
}
 801369a:	0018      	movs	r0, r3
 801369c:	46bd      	mov	sp, r7
 801369e:	b004      	add	sp, #16
 80136a0:	bd80      	pop	{r7, pc}
 80136a2:	46c0      	nop			; (mov r8, r8)
 80136a4:	20002b2c 	.word	0x20002b2c
 80136a8:	20002b30 	.word	0x20002b30

080136ac <ip4_input_accept>:
#endif /* IP_FORWARD */

/** Return true if the current input packet should be accepted on this netif */
static int
ip4_input_accept(struct netif *netif)
{
 80136ac:	b580      	push	{r7, lr}
 80136ae:	b082      	sub	sp, #8
 80136b0:	af00      	add	r7, sp, #0
 80136b2:	6078      	str	r0, [r7, #4]
                         ip4_addr_get_u32(ip4_current_dest_addr()) & ip4_addr_get_u32(netif_ip4_netmask(netif)),
                         ip4_addr_get_u32(netif_ip4_addr(netif)) & ip4_addr_get_u32(netif_ip4_netmask(netif)),
                         ip4_addr_get_u32(ip4_current_dest_addr()) & ~ip4_addr_get_u32(netif_ip4_netmask(netif))));

  /* interface is up and configured? */
  if ((netif_is_up(netif)) && (!ip4_addr_isany_val(*netif_ip4_addr(netif)))) {
 80136b4:	687b      	ldr	r3, [r7, #4]
 80136b6:	2231      	movs	r2, #49	; 0x31
 80136b8:	5c9b      	ldrb	r3, [r3, r2]
 80136ba:	1c1a      	adds	r2, r3, #0
 80136bc:	2301      	movs	r3, #1
 80136be:	4013      	ands	r3, r2
 80136c0:	b2db      	uxtb	r3, r3
 80136c2:	2b00      	cmp	r3, #0
 80136c4:	d016      	beq.n	80136f4 <ip4_input_accept+0x48>
 80136c6:	687b      	ldr	r3, [r7, #4]
 80136c8:	3304      	adds	r3, #4
 80136ca:	681b      	ldr	r3, [r3, #0]
 80136cc:	2b00      	cmp	r3, #0
 80136ce:	d011      	beq.n	80136f4 <ip4_input_accept+0x48>
    /* unicast to this interface address? */
    if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
 80136d0:	4b0b      	ldr	r3, [pc, #44]	; (8013700 <ip4_input_accept+0x54>)
 80136d2:	695a      	ldr	r2, [r3, #20]
 80136d4:	687b      	ldr	r3, [r7, #4]
 80136d6:	3304      	adds	r3, #4
 80136d8:	681b      	ldr	r3, [r3, #0]
 80136da:	429a      	cmp	r2, r3
 80136dc:	d008      	beq.n	80136f0 <ip4_input_accept+0x44>
        /* or broadcast on this interface network address? */
        ip4_addr_isbroadcast(ip4_current_dest_addr(), netif)
 80136de:	4b08      	ldr	r3, [pc, #32]	; (8013700 <ip4_input_accept+0x54>)
 80136e0:	695b      	ldr	r3, [r3, #20]
 80136e2:	687a      	ldr	r2, [r7, #4]
 80136e4:	0011      	movs	r1, r2
 80136e6:	0018      	movs	r0, r3
 80136e8:	f000 fb98 	bl	8013e1c <ip4_addr_isbroadcast_u32>
 80136ec:	1e03      	subs	r3, r0, #0
    if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
 80136ee:	d001      	beq.n	80136f4 <ip4_input_accept+0x48>
#endif /* LWIP_NETIF_LOOPBACK && !LWIP_HAVE_LOOPIF */
       ) {
      LWIP_DEBUGF(IP_DEBUG, ("ip4_input: packet accepted on interface %c%c\n",
                             netif->name[0], netif->name[1]));
      /* accept on this netif */
      return 1;
 80136f0:	2301      	movs	r3, #1
 80136f2:	e000      	b.n	80136f6 <ip4_input_accept+0x4a>
      /* accept on this netif */
      return 1;
    }
#endif /* LWIP_AUTOIP */
  }
  return 0;
 80136f4:	2300      	movs	r3, #0
}
 80136f6:	0018      	movs	r0, r3
 80136f8:	46bd      	mov	sp, r7
 80136fa:	b002      	add	sp, #8
 80136fc:	bd80      	pop	{r7, pc}
 80136fe:	46c0      	nop			; (mov r8, r8)
 8013700:	200018fc 	.word	0x200018fc

08013704 <ip4_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip4_input(struct pbuf *p, struct netif *inp)
{
 8013704:	b5b0      	push	{r4, r5, r7, lr}
 8013706:	b086      	sub	sp, #24
 8013708:	af00      	add	r7, sp, #0
 801370a:	6078      	str	r0, [r7, #4]
 801370c:	6039      	str	r1, [r7, #0]

  IP_STATS_INC(ip.recv);
  MIB2_STATS_INC(mib2.ipinreceives);

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
 801370e:	687b      	ldr	r3, [r7, #4]
 8013710:	685b      	ldr	r3, [r3, #4]
 8013712:	613b      	str	r3, [r7, #16]
  if (IPH_V(iphdr) != 4) {
 8013714:	693b      	ldr	r3, [r7, #16]
 8013716:	781b      	ldrb	r3, [r3, #0]
 8013718:	091b      	lsrs	r3, r3, #4
 801371a:	b2db      	uxtb	r3, r3
 801371c:	2b04      	cmp	r3, #4
 801371e:	d005      	beq.n	801372c <ip4_input+0x28>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", (u16_t)IPH_V(iphdr)));
    ip4_debug_print(p);
    pbuf_free(p);
 8013720:	687b      	ldr	r3, [r7, #4]
 8013722:	0018      	movs	r0, r3
 8013724:	f7f6 fbca 	bl	8009ebc <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    MIB2_STATS_INC(mib2.ipinhdrerrors);
    return ERR_OK;
 8013728:	2300      	movs	r3, #0
 801372a:	e147      	b.n	80139bc <ip4_input+0x2b8>
    return ERR_OK;
  }
#endif

  /* obtain IP header length in bytes */
  iphdr_hlen = IPH_HL_BYTES(iphdr);
 801372c:	693b      	ldr	r3, [r7, #16]
 801372e:	781b      	ldrb	r3, [r3, #0]
 8013730:	220f      	movs	r2, #15
 8013732:	4013      	ands	r3, r2
 8013734:	b2db      	uxtb	r3, r3
 8013736:	009b      	lsls	r3, r3, #2
 8013738:	b2da      	uxtb	r2, r3
 801373a:	2316      	movs	r3, #22
 801373c:	18fb      	adds	r3, r7, r3
 801373e:	801a      	strh	r2, [r3, #0]
  /* obtain ip length in bytes */
  iphdr_len = lwip_ntohs(IPH_LEN(iphdr));
 8013740:	693b      	ldr	r3, [r7, #16]
 8013742:	789a      	ldrb	r2, [r3, #2]
 8013744:	78db      	ldrb	r3, [r3, #3]
 8013746:	021b      	lsls	r3, r3, #8
 8013748:	4313      	orrs	r3, r2
 801374a:	b29b      	uxth	r3, r3
 801374c:	2514      	movs	r5, #20
 801374e:	197c      	adds	r4, r7, r5
 8013750:	0018      	movs	r0, r3
 8013752:	f7f3 fbcf 	bl	8006ef4 <lwip_htons>
 8013756:	0003      	movs	r3, r0
 8013758:	8023      	strh	r3, [r4, #0]

  /* Trim pbuf. This is especially required for packets < 60 bytes. */
  if (iphdr_len < p->tot_len) {
 801375a:	687b      	ldr	r3, [r7, #4]
 801375c:	891b      	ldrh	r3, [r3, #8]
 801375e:	197a      	adds	r2, r7, r5
 8013760:	8812      	ldrh	r2, [r2, #0]
 8013762:	429a      	cmp	r2, r3
 8013764:	d206      	bcs.n	8013774 <ip4_input+0x70>
    pbuf_realloc(p, iphdr_len);
 8013766:	197b      	adds	r3, r7, r5
 8013768:	881a      	ldrh	r2, [r3, #0]
 801376a:	687b      	ldr	r3, [r7, #4]
 801376c:	0011      	movs	r1, r2
 801376e:	0018      	movs	r0, r3
 8013770:	f7f6 f9aa 	bl	8009ac8 <pbuf_realloc>
  }

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len) || (iphdr_hlen < IP_HLEN)) {
 8013774:	687b      	ldr	r3, [r7, #4]
 8013776:	895b      	ldrh	r3, [r3, #10]
 8013778:	2116      	movs	r1, #22
 801377a:	187a      	adds	r2, r7, r1
 801377c:	8812      	ldrh	r2, [r2, #0]
 801377e:	429a      	cmp	r2, r3
 8013780:	d80a      	bhi.n	8013798 <ip4_input+0x94>
 8013782:	687b      	ldr	r3, [r7, #4]
 8013784:	891b      	ldrh	r3, [r3, #8]
 8013786:	2214      	movs	r2, #20
 8013788:	18ba      	adds	r2, r7, r2
 801378a:	8812      	ldrh	r2, [r2, #0]
 801378c:	429a      	cmp	r2, r3
 801378e:	d803      	bhi.n	8013798 <ip4_input+0x94>
 8013790:	187b      	adds	r3, r7, r1
 8013792:	881b      	ldrh	r3, [r3, #0]
 8013794:	2b13      	cmp	r3, #19
 8013796:	d805      	bhi.n	80137a4 <ip4_input+0xa0>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                  ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
                   iphdr_len, p->tot_len));
    }
    /* free (drop) packet pbufs */
    pbuf_free(p);
 8013798:	687b      	ldr	r3, [r7, #4]
 801379a:	0018      	movs	r0, r3
 801379c:	f7f6 fb8e 	bl	8009ebc <pbuf_free>
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    MIB2_STATS_INC(mib2.ipindiscards);
    return ERR_OK;
 80137a0:	2300      	movs	r3, #0
 80137a2:	e10b      	b.n	80139bc <ip4_input+0x2b8>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_IP) {
    if (inet_chksum(iphdr, iphdr_hlen) != 0) {
 80137a4:	2316      	movs	r3, #22
 80137a6:	18fb      	adds	r3, r7, r3
 80137a8:	881a      	ldrh	r2, [r3, #0]
 80137aa:	693b      	ldr	r3, [r7, #16]
 80137ac:	0011      	movs	r1, r2
 80137ae:	0018      	movs	r0, r3
 80137b0:	f7f4 ff66 	bl	8008680 <inet_chksum>
 80137b4:	1e03      	subs	r3, r0, #0
 80137b6:	d005      	beq.n	80137c4 <ip4_input+0xc0>

      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                  ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
      ip4_debug_print(p);
      pbuf_free(p);
 80137b8:	687b      	ldr	r3, [r7, #4]
 80137ba:	0018      	movs	r0, r3
 80137bc:	f7f6 fb7e 	bl	8009ebc <pbuf_free>
      IP_STATS_INC(ip.chkerr);
      IP_STATS_INC(ip.drop);
      MIB2_STATS_INC(mib2.ipinhdrerrors);
      return ERR_OK;
 80137c0:	2300      	movs	r3, #0
 80137c2:	e0fb      	b.n	80139bc <ip4_input+0x2b8>
    }
  }
#endif

  /* copy IP addresses to aligned ip_addr_t */
  ip_addr_copy_from_ip4(ip_data.current_iphdr_dest, iphdr->dest);
 80137c4:	693b      	ldr	r3, [r7, #16]
 80137c6:	7c1a      	ldrb	r2, [r3, #16]
 80137c8:	7c59      	ldrb	r1, [r3, #17]
 80137ca:	0209      	lsls	r1, r1, #8
 80137cc:	430a      	orrs	r2, r1
 80137ce:	7c99      	ldrb	r1, [r3, #18]
 80137d0:	0409      	lsls	r1, r1, #16
 80137d2:	430a      	orrs	r2, r1
 80137d4:	7cdb      	ldrb	r3, [r3, #19]
 80137d6:	061b      	lsls	r3, r3, #24
 80137d8:	4313      	orrs	r3, r2
 80137da:	001a      	movs	r2, r3
 80137dc:	4b79      	ldr	r3, [pc, #484]	; (80139c4 <ip4_input+0x2c0>)
 80137de:	615a      	str	r2, [r3, #20]
  ip_addr_copy_from_ip4(ip_data.current_iphdr_src, iphdr->src);
 80137e0:	693b      	ldr	r3, [r7, #16]
 80137e2:	7b1a      	ldrb	r2, [r3, #12]
 80137e4:	7b59      	ldrb	r1, [r3, #13]
 80137e6:	0209      	lsls	r1, r1, #8
 80137e8:	430a      	orrs	r2, r1
 80137ea:	7b99      	ldrb	r1, [r3, #14]
 80137ec:	0409      	lsls	r1, r1, #16
 80137ee:	430a      	orrs	r2, r1
 80137f0:	7bdb      	ldrb	r3, [r3, #15]
 80137f2:	061b      	lsls	r3, r3, #24
 80137f4:	4313      	orrs	r3, r2
 80137f6:	001a      	movs	r2, r3
 80137f8:	4b72      	ldr	r3, [pc, #456]	; (80139c4 <ip4_input+0x2c0>)
 80137fa:	611a      	str	r2, [r3, #16]

  /* match packet against an interface, i.e. is this packet for us? */
  if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
 80137fc:	4b71      	ldr	r3, [pc, #452]	; (80139c4 <ip4_input+0x2c0>)
 80137fe:	695b      	ldr	r3, [r3, #20]
 8013800:	22f0      	movs	r2, #240	; 0xf0
 8013802:	4013      	ands	r3, r2
 8013804:	2be0      	cmp	r3, #224	; 0xe0
 8013806:	d113      	bne.n	8013830 <ip4_input+0x12c>
      netif = inp;
    } else {
      netif = NULL;
    }
#else /* LWIP_IGMP */
    if ((netif_is_up(inp)) && (!ip4_addr_isany_val(*netif_ip4_addr(inp)))) {
 8013808:	683b      	ldr	r3, [r7, #0]
 801380a:	2231      	movs	r2, #49	; 0x31
 801380c:	5c9b      	ldrb	r3, [r3, r2]
 801380e:	1c1a      	adds	r2, r3, #0
 8013810:	2301      	movs	r3, #1
 8013812:	4013      	ands	r3, r2
 8013814:	b2db      	uxtb	r3, r3
 8013816:	2b00      	cmp	r3, #0
 8013818:	d007      	beq.n	801382a <ip4_input+0x126>
 801381a:	683b      	ldr	r3, [r7, #0]
 801381c:	3304      	adds	r3, #4
 801381e:	681b      	ldr	r3, [r3, #0]
 8013820:	2b00      	cmp	r3, #0
 8013822:	d002      	beq.n	801382a <ip4_input+0x126>
      netif = inp;
 8013824:	683b      	ldr	r3, [r7, #0]
 8013826:	60fb      	str	r3, [r7, #12]
 8013828:	e02b      	b.n	8013882 <ip4_input+0x17e>
    } else {
      netif = NULL;
 801382a:	2300      	movs	r3, #0
 801382c:	60fb      	str	r3, [r7, #12]
 801382e:	e028      	b.n	8013882 <ip4_input+0x17e>
    }
#endif /* LWIP_IGMP */
  } else {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs. */
    if (ip4_input_accept(inp)) {
 8013830:	683b      	ldr	r3, [r7, #0]
 8013832:	0018      	movs	r0, r3
 8013834:	f7ff ff3a 	bl	80136ac <ip4_input_accept>
 8013838:	1e03      	subs	r3, r0, #0
 801383a:	d002      	beq.n	8013842 <ip4_input+0x13e>
      netif = inp;
 801383c:	683b      	ldr	r3, [r7, #0]
 801383e:	60fb      	str	r3, [r7, #12]
 8013840:	e01f      	b.n	8013882 <ip4_input+0x17e>
    } else {
      netif = NULL;
 8013842:	2300      	movs	r3, #0
 8013844:	60fb      	str	r3, [r7, #12]
#if !LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF
      /* Packets sent to the loopback address must not be accepted on an
       * interface that does not have the loopback address assigned to it,
       * unless a non-loopback interface is used for loopback traffic. */
      if (!ip4_addr_isloopback(ip4_current_dest_addr()))
 8013846:	4b5f      	ldr	r3, [pc, #380]	; (80139c4 <ip4_input+0x2c0>)
 8013848:	695b      	ldr	r3, [r3, #20]
 801384a:	22ff      	movs	r2, #255	; 0xff
 801384c:	4013      	ands	r3, r2
 801384e:	2b7f      	cmp	r3, #127	; 0x7f
 8013850:	d017      	beq.n	8013882 <ip4_input+0x17e>
#endif /* !LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF */
      {
#if !LWIP_SINGLE_NETIF
        NETIF_FOREACH(netif) {
 8013852:	4b5d      	ldr	r3, [pc, #372]	; (80139c8 <ip4_input+0x2c4>)
 8013854:	681b      	ldr	r3, [r3, #0]
 8013856:	60fb      	str	r3, [r7, #12]
 8013858:	e00e      	b.n	8013878 <ip4_input+0x174>
          if (netif == inp) {
 801385a:	68fa      	ldr	r2, [r7, #12]
 801385c:	683b      	ldr	r3, [r7, #0]
 801385e:	429a      	cmp	r2, r3
 8013860:	d006      	beq.n	8013870 <ip4_input+0x16c>
            /* we checked that before already */
            continue;
          }
          if (ip4_input_accept(netif)) {
 8013862:	68fb      	ldr	r3, [r7, #12]
 8013864:	0018      	movs	r0, r3
 8013866:	f7ff ff21 	bl	80136ac <ip4_input_accept>
 801386a:	1e03      	subs	r3, r0, #0
 801386c:	d108      	bne.n	8013880 <ip4_input+0x17c>
 801386e:	e000      	b.n	8013872 <ip4_input+0x16e>
            continue;
 8013870:	46c0      	nop			; (mov r8, r8)
        NETIF_FOREACH(netif) {
 8013872:	68fb      	ldr	r3, [r7, #12]
 8013874:	681b      	ldr	r3, [r3, #0]
 8013876:	60fb      	str	r3, [r7, #12]
 8013878:	68fb      	ldr	r3, [r7, #12]
 801387a:	2b00      	cmp	r3, #0
 801387c:	d1ed      	bne.n	801385a <ip4_input+0x156>
 801387e:	e000      	b.n	8013882 <ip4_input+0x17e>
            break;
 8013880:	46c0      	nop			; (mov r8, r8)
      && !ip4_addr_isany_val(*ip4_current_src_addr())
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
     )
#endif /* LWIP_IGMP || IP_ACCEPT_LINK_LAYER_ADDRESSING */
  {
    if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
 8013882:	4b50      	ldr	r3, [pc, #320]	; (80139c4 <ip4_input+0x2c0>)
 8013884:	691b      	ldr	r3, [r3, #16]
 8013886:	683a      	ldr	r2, [r7, #0]
 8013888:	0011      	movs	r1, r2
 801388a:	0018      	movs	r0, r3
 801388c:	f000 fac6 	bl	8013e1c <ip4_addr_isbroadcast_u32>
 8013890:	1e03      	subs	r3, r0, #0
 8013892:	d105      	bne.n	80138a0 <ip4_input+0x19c>
        (ip4_addr_ismulticast(ip4_current_src_addr()))) {
 8013894:	4b4b      	ldr	r3, [pc, #300]	; (80139c4 <ip4_input+0x2c0>)
 8013896:	691b      	ldr	r3, [r3, #16]
 8013898:	22f0      	movs	r2, #240	; 0xf0
 801389a:	4013      	ands	r3, r2
    if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
 801389c:	2be0      	cmp	r3, #224	; 0xe0
 801389e:	d105      	bne.n	80138ac <ip4_input+0x1a8>
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("ip4_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
 80138a0:	687b      	ldr	r3, [r7, #4]
 80138a2:	0018      	movs	r0, r3
 80138a4:	f7f6 fb0a 	bl	8009ebc <pbuf_free>
      IP_STATS_INC(ip.drop);
      MIB2_STATS_INC(mib2.ipinaddrerrors);
      MIB2_STATS_INC(mib2.ipindiscards);
      return ERR_OK;
 80138a8:	2300      	movs	r3, #0
 80138aa:	e087      	b.n	80139bc <ip4_input+0x2b8>
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
 80138ac:	68fb      	ldr	r3, [r7, #12]
 80138ae:	2b00      	cmp	r3, #0
 80138b0:	d105      	bne.n	80138be <ip4_input+0x1ba>
    {
      IP_STATS_INC(ip.drop);
      MIB2_STATS_INC(mib2.ipinaddrerrors);
      MIB2_STATS_INC(mib2.ipindiscards);
    }
    pbuf_free(p);
 80138b2:	687b      	ldr	r3, [r7, #4]
 80138b4:	0018      	movs	r0, r3
 80138b6:	f7f6 fb01 	bl	8009ebc <pbuf_free>
    return ERR_OK;
 80138ba:	2300      	movs	r3, #0
 80138bc:	e07e      	b.n	80139bc <ip4_input+0x2b8>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
 80138be:	693b      	ldr	r3, [r7, #16]
 80138c0:	799a      	ldrb	r2, [r3, #6]
 80138c2:	79db      	ldrb	r3, [r3, #7]
 80138c4:	021b      	lsls	r3, r3, #8
 80138c6:	4313      	orrs	r3, r2
 80138c8:	b29b      	uxth	r3, r3
 80138ca:	001a      	movs	r2, r3
 80138cc:	4b3f      	ldr	r3, [pc, #252]	; (80139cc <ip4_input+0x2c8>)
 80138ce:	4013      	ands	r3, r2
 80138d0:	d005      	beq.n	80138de <ip4_input+0x1da>
    if (p == NULL) {
      return ERR_OK;
    }
    iphdr = (const struct ip_hdr *)p->payload;
#else /* IP_REASSEMBLY == 0, no packet fragment reassembly code present */
    pbuf_free(p);
 80138d2:	687b      	ldr	r3, [r7, #4]
 80138d4:	0018      	movs	r0, r3
 80138d6:	f7f6 faf1 	bl	8009ebc <pbuf_free>
                lwip_ntohs(IPH_OFFSET(iphdr))));
    IP_STATS_INC(ip.opterr);
    IP_STATS_INC(ip.drop);
    /* unsupported protocol feature */
    MIB2_STATS_INC(mib2.ipinunknownprotos);
    return ERR_OK;
 80138da:	2300      	movs	r3, #0
 80138dc:	e06e      	b.n	80139bc <ip4_input+0x2b8>
  /* send to upper layers */
  LWIP_DEBUGF(IP_DEBUG, ("ip4_input: \n"));
  ip4_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip4_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

  ip_data.current_netif = netif;
 80138de:	4b39      	ldr	r3, [pc, #228]	; (80139c4 <ip4_input+0x2c0>)
 80138e0:	68fa      	ldr	r2, [r7, #12]
 80138e2:	601a      	str	r2, [r3, #0]
  ip_data.current_input_netif = inp;
 80138e4:	4b37      	ldr	r3, [pc, #220]	; (80139c4 <ip4_input+0x2c0>)
 80138e6:	683a      	ldr	r2, [r7, #0]
 80138e8:	605a      	str	r2, [r3, #4]
  ip_data.current_ip4_header = iphdr;
 80138ea:	4b36      	ldr	r3, [pc, #216]	; (80139c4 <ip4_input+0x2c0>)
 80138ec:	693a      	ldr	r2, [r7, #16]
 80138ee:	609a      	str	r2, [r3, #8]
  ip_data.current_ip_header_tot_len = IPH_HL_BYTES(iphdr);
 80138f0:	693b      	ldr	r3, [r7, #16]
 80138f2:	781b      	ldrb	r3, [r3, #0]
 80138f4:	220f      	movs	r2, #15
 80138f6:	4013      	ands	r3, r2
 80138f8:	b2db      	uxtb	r3, r3
 80138fa:	009b      	lsls	r3, r3, #2
 80138fc:	b2db      	uxtb	r3, r3
 80138fe:	b29a      	uxth	r2, r3
 8013900:	4b30      	ldr	r3, [pc, #192]	; (80139c4 <ip4_input+0x2c0>)
 8013902:	819a      	strh	r2, [r3, #12]
  /* raw input did not eat the packet? */
  raw_status = raw_input(p, inp);
  if (raw_status != RAW_INPUT_EATEN)
#endif /* LWIP_RAW */
  {
    pbuf_remove_header(p, iphdr_hlen); /* Move to payload, no check necessary. */
 8013904:	2316      	movs	r3, #22
 8013906:	18fb      	adds	r3, r7, r3
 8013908:	881a      	ldrh	r2, [r3, #0]
 801390a:	687b      	ldr	r3, [r7, #4]
 801390c:	0011      	movs	r1, r2
 801390e:	0018      	movs	r0, r3
 8013910:	f7f6 f9fc 	bl	8009d0c <pbuf_remove_header>

    switch (IPH_PROTO(iphdr)) {
 8013914:	693b      	ldr	r3, [r7, #16]
 8013916:	7a5b      	ldrb	r3, [r3, #9]
 8013918:	2b11      	cmp	r3, #17
 801391a:	d005      	beq.n	8013928 <ip4_input+0x224>
 801391c:	dc19      	bgt.n	8013952 <ip4_input+0x24e>
 801391e:	2b01      	cmp	r3, #1
 8013920:	d010      	beq.n	8013944 <ip4_input+0x240>
 8013922:	2b06      	cmp	r3, #6
 8013924:	d007      	beq.n	8013936 <ip4_input+0x232>
 8013926:	e014      	b.n	8013952 <ip4_input+0x24e>
      case IP_PROTO_UDP:
#if LWIP_UDPLITE
      case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
        MIB2_STATS_INC(mib2.ipindelivers);
        udp_input(p, inp);
 8013928:	683a      	ldr	r2, [r7, #0]
 801392a:	687b      	ldr	r3, [r7, #4]
 801392c:	0011      	movs	r1, r2
 801392e:	0018      	movs	r0, r3
 8013930:	f7fe fe80 	bl	8012634 <udp_input>
        break;
 8013934:	e02f      	b.n	8013996 <ip4_input+0x292>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case IP_PROTO_TCP:
        MIB2_STATS_INC(mib2.ipindelivers);
        tcp_input(p, inp);
 8013936:	683a      	ldr	r2, [r7, #0]
 8013938:	687b      	ldr	r3, [r7, #4]
 801393a:	0011      	movs	r1, r2
 801393c:	0018      	movs	r0, r3
 801393e:	f7f8 ffd5 	bl	800c8ec <tcp_input>
        break;
 8013942:	e028      	b.n	8013996 <ip4_input+0x292>
#endif /* LWIP_TCP */
#if LWIP_ICMP
      case IP_PROTO_ICMP:
        MIB2_STATS_INC(mib2.ipindelivers);
        icmp_input(p, inp);
 8013944:	683a      	ldr	r2, [r7, #0]
 8013946:	687b      	ldr	r3, [r7, #4]
 8013948:	0011      	movs	r1, r2
 801394a:	0018      	movs	r0, r3
 801394c:	f7ff fb88 	bl	8013060 <icmp_input>
        break;
 8013950:	e021      	b.n	8013996 <ip4_input+0x292>
        } else
#endif /* LWIP_RAW */
        {
#if LWIP_ICMP
          /* send ICMP destination protocol unreachable unless is was a broadcast */
          if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
 8013952:	4b1c      	ldr	r3, [pc, #112]	; (80139c4 <ip4_input+0x2c0>)
 8013954:	695b      	ldr	r3, [r3, #20]
 8013956:	68fa      	ldr	r2, [r7, #12]
 8013958:	0011      	movs	r1, r2
 801395a:	0018      	movs	r0, r3
 801395c:	f000 fa5e 	bl	8013e1c <ip4_addr_isbroadcast_u32>
 8013960:	1e03      	subs	r3, r0, #0
 8013962:	d113      	bne.n	801398c <ip4_input+0x288>
              !ip4_addr_ismulticast(ip4_current_dest_addr())) {
 8013964:	4b17      	ldr	r3, [pc, #92]	; (80139c4 <ip4_input+0x2c0>)
 8013966:	695b      	ldr	r3, [r3, #20]
 8013968:	22f0      	movs	r2, #240	; 0xf0
 801396a:	4013      	ands	r3, r2
          if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
 801396c:	2be0      	cmp	r3, #224	; 0xe0
 801396e:	d00d      	beq.n	801398c <ip4_input+0x288>
            pbuf_header_force(p, (s16_t)iphdr_hlen); /* Move to ip header, no check necessary. */
 8013970:	2316      	movs	r3, #22
 8013972:	18fb      	adds	r3, r7, r3
 8013974:	2200      	movs	r2, #0
 8013976:	5e9a      	ldrsh	r2, [r3, r2]
 8013978:	687b      	ldr	r3, [r7, #4]
 801397a:	0011      	movs	r1, r2
 801397c:	0018      	movs	r0, r3
 801397e:	f7f6 fa46 	bl	8009e0e <pbuf_header_force>
            icmp_dest_unreach(p, ICMP_DUR_PROTO);
 8013982:	687b      	ldr	r3, [r7, #4]
 8013984:	2102      	movs	r1, #2
 8013986:	0018      	movs	r0, r3
 8013988:	f7ff fd50 	bl	801342c <icmp_dest_unreach>

          IP_STATS_INC(ip.proterr);
          IP_STATS_INC(ip.drop);
          MIB2_STATS_INC(mib2.ipinunknownprotos);
        }
        pbuf_free(p);
 801398c:	687b      	ldr	r3, [r7, #4]
 801398e:	0018      	movs	r0, r3
 8013990:	f7f6 fa94 	bl	8009ebc <pbuf_free>
        break;
 8013994:	46c0      	nop			; (mov r8, r8)
    }
  }

  /* @todo: this is not really necessary... */
  ip_data.current_netif = NULL;
 8013996:	4b0b      	ldr	r3, [pc, #44]	; (80139c4 <ip4_input+0x2c0>)
 8013998:	2200      	movs	r2, #0
 801399a:	601a      	str	r2, [r3, #0]
  ip_data.current_input_netif = NULL;
 801399c:	4b09      	ldr	r3, [pc, #36]	; (80139c4 <ip4_input+0x2c0>)
 801399e:	2200      	movs	r2, #0
 80139a0:	605a      	str	r2, [r3, #4]
  ip_data.current_ip4_header = NULL;
 80139a2:	4b08      	ldr	r3, [pc, #32]	; (80139c4 <ip4_input+0x2c0>)
 80139a4:	2200      	movs	r2, #0
 80139a6:	609a      	str	r2, [r3, #8]
  ip_data.current_ip_header_tot_len = 0;
 80139a8:	4b06      	ldr	r3, [pc, #24]	; (80139c4 <ip4_input+0x2c0>)
 80139aa:	2200      	movs	r2, #0
 80139ac:	819a      	strh	r2, [r3, #12]
  ip4_addr_set_any(ip4_current_src_addr());
 80139ae:	4b05      	ldr	r3, [pc, #20]	; (80139c4 <ip4_input+0x2c0>)
 80139b0:	2200      	movs	r2, #0
 80139b2:	611a      	str	r2, [r3, #16]
  ip4_addr_set_any(ip4_current_dest_addr());
 80139b4:	4b03      	ldr	r3, [pc, #12]	; (80139c4 <ip4_input+0x2c0>)
 80139b6:	2200      	movs	r2, #0
 80139b8:	615a      	str	r2, [r3, #20]

  return ERR_OK;
 80139ba:	2300      	movs	r3, #0
}
 80139bc:	0018      	movs	r0, r3
 80139be:	46bd      	mov	sp, r7
 80139c0:	b006      	add	sp, #24
 80139c2:	bdb0      	pop	{r4, r5, r7, pc}
 80139c4:	200018fc 	.word	0x200018fc
 80139c8:	20002b2c 	.word	0x20002b2c
 80139cc:	0000ff3f 	.word	0x0000ff3f

080139d0 <ip4_output_if>:
 */
err_t
ip4_output_if(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
              u8_t ttl, u8_t tos,
              u8_t proto, struct netif *netif)
{
 80139d0:	b590      	push	{r4, r7, lr}
 80139d2:	b08b      	sub	sp, #44	; 0x2c
 80139d4:	af04      	add	r7, sp, #16
 80139d6:	60f8      	str	r0, [r7, #12]
 80139d8:	60b9      	str	r1, [r7, #8]
 80139da:	607a      	str	r2, [r7, #4]
 80139dc:	001a      	movs	r2, r3
 80139de:	1cfb      	adds	r3, r7, #3
 80139e0:	701a      	strb	r2, [r3, #0]
ip4_output_if_opt(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
                  u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
                  u16_t optlen)
{
#endif /* IP_OPTIONS_SEND */
  const ip4_addr_t *src_used = src;
 80139e2:	68bb      	ldr	r3, [r7, #8]
 80139e4:	617b      	str	r3, [r7, #20]
  if (dest != LWIP_IP_HDRINCL) {
 80139e6:	687b      	ldr	r3, [r7, #4]
 80139e8:	2b00      	cmp	r3, #0
 80139ea:	d009      	beq.n	8013a00 <ip4_output_if+0x30>
    if (ip4_addr_isany(src)) {
 80139ec:	68bb      	ldr	r3, [r7, #8]
 80139ee:	2b00      	cmp	r3, #0
 80139f0:	d003      	beq.n	80139fa <ip4_output_if+0x2a>
 80139f2:	68bb      	ldr	r3, [r7, #8]
 80139f4:	681b      	ldr	r3, [r3, #0]
 80139f6:	2b00      	cmp	r3, #0
 80139f8:	d102      	bne.n	8013a00 <ip4_output_if+0x30>
      src_used = netif_ip4_addr(netif);
 80139fa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80139fc:	3304      	adds	r3, #4
 80139fe:	617b      	str	r3, [r7, #20]

#if IP_OPTIONS_SEND
  return ip4_output_if_opt_src(p, src_used, dest, ttl, tos, proto, netif,
                               ip_options, optlen);
#else /* IP_OPTIONS_SEND */
  return ip4_output_if_src(p, src_used, dest, ttl, tos, proto, netif);
 8013a00:	1cfb      	adds	r3, r7, #3
 8013a02:	781c      	ldrb	r4, [r3, #0]
 8013a04:	687a      	ldr	r2, [r7, #4]
 8013a06:	6979      	ldr	r1, [r7, #20]
 8013a08:	68f8      	ldr	r0, [r7, #12]
 8013a0a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8013a0c:	9302      	str	r3, [sp, #8]
 8013a0e:	232c      	movs	r3, #44	; 0x2c
 8013a10:	18fb      	adds	r3, r7, r3
 8013a12:	781b      	ldrb	r3, [r3, #0]
 8013a14:	9301      	str	r3, [sp, #4]
 8013a16:	2328      	movs	r3, #40	; 0x28
 8013a18:	18fb      	adds	r3, r7, r3
 8013a1a:	781b      	ldrb	r3, [r3, #0]
 8013a1c:	9300      	str	r3, [sp, #0]
 8013a1e:	0023      	movs	r3, r4
 8013a20:	f000 f806 	bl	8013a30 <ip4_output_if_src>
 8013a24:	0003      	movs	r3, r0
#endif /* IP_OPTIONS_SEND */
}
 8013a26:	0018      	movs	r0, r3
 8013a28:	46bd      	mov	sp, r7
 8013a2a:	b007      	add	sp, #28
 8013a2c:	bd90      	pop	{r4, r7, pc}
	...

08013a30 <ip4_output_if_src>:
 */
err_t
ip4_output_if_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
                  u8_t ttl, u8_t tos,
                  u8_t proto, struct netif *netif)
{
 8013a30:	b590      	push	{r4, r7, lr}
 8013a32:	b089      	sub	sp, #36	; 0x24
 8013a34:	af00      	add	r7, sp, #0
 8013a36:	60f8      	str	r0, [r7, #12]
 8013a38:	60b9      	str	r1, [r7, #8]
 8013a3a:	607a      	str	r2, [r7, #4]
 8013a3c:	001a      	movs	r2, r3
 8013a3e:	1cfb      	adds	r3, r7, #3
 8013a40:	701a      	strb	r2, [r3, #0]
{
#endif /* IP_OPTIONS_SEND */
  struct ip_hdr *iphdr;
  ip4_addr_t dest_addr;
#if CHECKSUM_GEN_IP_INLINE
  u32_t chk_sum = 0;
 8013a42:	2300      	movs	r3, #0
 8013a44:	61fb      	str	r3, [r7, #28]
#endif /* CHECKSUM_GEN_IP_INLINE */

  LWIP_ASSERT_CORE_LOCKED();
  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
 8013a46:	68fb      	ldr	r3, [r7, #12]
 8013a48:	7b9b      	ldrb	r3, [r3, #14]
 8013a4a:	2b01      	cmp	r3, #1
 8013a4c:	d006      	beq.n	8013a5c <ip4_output_if_src+0x2c>
 8013a4e:	4bde      	ldr	r3, [pc, #888]	; (8013dc8 <ip4_output_if_src+0x398>)
 8013a50:	22d5      	movs	r2, #213	; 0xd5
 8013a52:	0092      	lsls	r2, r2, #2
 8013a54:	49dd      	ldr	r1, [pc, #884]	; (8013dcc <ip4_output_if_src+0x39c>)
 8013a56:	48de      	ldr	r0, [pc, #888]	; (8013dd0 <ip4_output_if_src+0x3a0>)
 8013a58:	f7ef f8b6 	bl	8002bc8 <app_debug_rtt_raw>

  MIB2_STATS_INC(mib2.ipoutrequests);

  /* Should the IP header be generated or is it already included in p? */
  if (dest != LWIP_IP_HDRINCL) {
 8013a5c:	687b      	ldr	r3, [r7, #4]
 8013a5e:	2b00      	cmp	r3, #0
 8013a60:	d100      	bne.n	8013a64 <ip4_output_if_src+0x34>
 8013a62:	e1aa      	b.n	8013dba <ip4_output_if_src+0x38a>
    u16_t ip_hlen = IP_HLEN;
 8013a64:	2316      	movs	r3, #22
 8013a66:	18fb      	adds	r3, r7, r3
 8013a68:	2214      	movs	r2, #20
 8013a6a:	801a      	strh	r2, [r3, #0]
      }
#endif /* CHECKSUM_GEN_IP_INLINE */
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_add_header(p, IP_HLEN)) {
 8013a6c:	68fb      	ldr	r3, [r7, #12]
 8013a6e:	2114      	movs	r1, #20
 8013a70:	0018      	movs	r0, r3
 8013a72:	f7f6 f93b 	bl	8009cec <pbuf_add_header>
 8013a76:	1e03      	subs	r3, r0, #0
 8013a78:	d002      	beq.n	8013a80 <ip4_output_if_src+0x50>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      MIB2_STATS_INC(mib2.ipoutdiscards);
      return ERR_BUF;
 8013a7a:	2302      	movs	r3, #2
 8013a7c:	425b      	negs	r3, r3
 8013a7e:	e1c8      	b.n	8013e12 <ip4_output_if_src+0x3e2>
    }

    iphdr = (struct ip_hdr *)p->payload;
 8013a80:	68fb      	ldr	r3, [r7, #12]
 8013a82:	685b      	ldr	r3, [r3, #4]
 8013a84:	61bb      	str	r3, [r7, #24]
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
 8013a86:	68fb      	ldr	r3, [r7, #12]
 8013a88:	895b      	ldrh	r3, [r3, #10]
 8013a8a:	2b13      	cmp	r3, #19
 8013a8c:	d806      	bhi.n	8013a9c <ip4_output_if_src+0x6c>
 8013a8e:	4bce      	ldr	r3, [pc, #824]	; (8013dc8 <ip4_output_if_src+0x398>)
 8013a90:	22e2      	movs	r2, #226	; 0xe2
 8013a92:	0092      	lsls	r2, r2, #2
 8013a94:	49cf      	ldr	r1, [pc, #828]	; (8013dd4 <ip4_output_if_src+0x3a4>)
 8013a96:	48ce      	ldr	r0, [pc, #824]	; (8013dd0 <ip4_output_if_src+0x3a0>)
 8013a98:	f7ef f896 	bl	8002bc8 <app_debug_rtt_raw>
                (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
 8013a9c:	69bb      	ldr	r3, [r7, #24]
 8013a9e:	1cfa      	adds	r2, r7, #3
 8013aa0:	7812      	ldrb	r2, [r2, #0]
 8013aa2:	721a      	strb	r2, [r3, #8]
    IPH_PROTO_SET(iphdr, proto);
 8013aa4:	69bb      	ldr	r3, [r7, #24]
 8013aa6:	2134      	movs	r1, #52	; 0x34
 8013aa8:	187a      	adds	r2, r7, r1
 8013aaa:	7812      	ldrb	r2, [r2, #0]
 8013aac:	725a      	strb	r2, [r3, #9]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += PP_NTOHS(proto | (ttl << 8));
 8013aae:	187b      	adds	r3, r7, r1
 8013ab0:	781a      	ldrb	r2, [r3, #0]
 8013ab2:	1cfb      	adds	r3, r7, #3
 8013ab4:	781b      	ldrb	r3, [r3, #0]
 8013ab6:	021b      	lsls	r3, r3, #8
 8013ab8:	4313      	orrs	r3, r2
 8013aba:	021b      	lsls	r3, r3, #8
 8013abc:	b21a      	sxth	r2, r3
 8013abe:	187b      	adds	r3, r7, r1
 8013ac0:	7819      	ldrb	r1, [r3, #0]
 8013ac2:	1cfb      	adds	r3, r7, #3
 8013ac4:	781b      	ldrb	r3, [r3, #0]
 8013ac6:	021b      	lsls	r3, r3, #8
 8013ac8:	430b      	orrs	r3, r1
 8013aca:	121b      	asrs	r3, r3, #8
 8013acc:	b21b      	sxth	r3, r3
 8013ace:	21ff      	movs	r1, #255	; 0xff
 8013ad0:	400b      	ands	r3, r1
 8013ad2:	b21b      	sxth	r3, r3
 8013ad4:	4313      	orrs	r3, r2
 8013ad6:	b21b      	sxth	r3, r3
 8013ad8:	b29b      	uxth	r3, r3
 8013ada:	001a      	movs	r2, r3
 8013adc:	69fb      	ldr	r3, [r7, #28]
 8013ade:	189b      	adds	r3, r3, r2
 8013ae0:	61fb      	str	r3, [r7, #28]
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip4_addr_copy(iphdr->dest, *dest);
 8013ae2:	687b      	ldr	r3, [r7, #4]
 8013ae4:	681a      	ldr	r2, [r3, #0]
 8013ae6:	69bb      	ldr	r3, [r7, #24]
 8013ae8:	21ff      	movs	r1, #255	; 0xff
 8013aea:	4011      	ands	r1, r2
 8013aec:	000c      	movs	r4, r1
 8013aee:	7c19      	ldrb	r1, [r3, #16]
 8013af0:	2000      	movs	r0, #0
 8013af2:	4001      	ands	r1, r0
 8013af4:	1c08      	adds	r0, r1, #0
 8013af6:	1c21      	adds	r1, r4, #0
 8013af8:	4301      	orrs	r1, r0
 8013afa:	7419      	strb	r1, [r3, #16]
 8013afc:	0a11      	lsrs	r1, r2, #8
 8013afe:	20ff      	movs	r0, #255	; 0xff
 8013b00:	4001      	ands	r1, r0
 8013b02:	000c      	movs	r4, r1
 8013b04:	7c59      	ldrb	r1, [r3, #17]
 8013b06:	2000      	movs	r0, #0
 8013b08:	4001      	ands	r1, r0
 8013b0a:	1c08      	adds	r0, r1, #0
 8013b0c:	1c21      	adds	r1, r4, #0
 8013b0e:	4301      	orrs	r1, r0
 8013b10:	7459      	strb	r1, [r3, #17]
 8013b12:	0c11      	lsrs	r1, r2, #16
 8013b14:	20ff      	movs	r0, #255	; 0xff
 8013b16:	4001      	ands	r1, r0
 8013b18:	000c      	movs	r4, r1
 8013b1a:	7c99      	ldrb	r1, [r3, #18]
 8013b1c:	2000      	movs	r0, #0
 8013b1e:	4001      	ands	r1, r0
 8013b20:	1c08      	adds	r0, r1, #0
 8013b22:	1c21      	adds	r1, r4, #0
 8013b24:	4301      	orrs	r1, r0
 8013b26:	7499      	strb	r1, [r3, #18]
 8013b28:	0e10      	lsrs	r0, r2, #24
 8013b2a:	7cda      	ldrb	r2, [r3, #19]
 8013b2c:	2100      	movs	r1, #0
 8013b2e:	400a      	ands	r2, r1
 8013b30:	1c11      	adds	r1, r2, #0
 8013b32:	1c02      	adds	r2, r0, #0
 8013b34:	430a      	orrs	r2, r1
 8013b36:	74da      	strb	r2, [r3, #19]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
 8013b38:	69bb      	ldr	r3, [r7, #24]
 8013b3a:	7c1a      	ldrb	r2, [r3, #16]
 8013b3c:	7c59      	ldrb	r1, [r3, #17]
 8013b3e:	0209      	lsls	r1, r1, #8
 8013b40:	430a      	orrs	r2, r1
 8013b42:	7c99      	ldrb	r1, [r3, #18]
 8013b44:	0409      	lsls	r1, r1, #16
 8013b46:	430a      	orrs	r2, r1
 8013b48:	7cdb      	ldrb	r3, [r3, #19]
 8013b4a:	061b      	lsls	r3, r3, #24
 8013b4c:	4313      	orrs	r3, r2
 8013b4e:	041b      	lsls	r3, r3, #16
 8013b50:	0c1b      	lsrs	r3, r3, #16
 8013b52:	69fa      	ldr	r2, [r7, #28]
 8013b54:	18d3      	adds	r3, r2, r3
 8013b56:	61fb      	str	r3, [r7, #28]
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
 8013b58:	69bb      	ldr	r3, [r7, #24]
 8013b5a:	7c1a      	ldrb	r2, [r3, #16]
 8013b5c:	7c59      	ldrb	r1, [r3, #17]
 8013b5e:	0209      	lsls	r1, r1, #8
 8013b60:	430a      	orrs	r2, r1
 8013b62:	7c99      	ldrb	r1, [r3, #18]
 8013b64:	0409      	lsls	r1, r1, #16
 8013b66:	430a      	orrs	r2, r1
 8013b68:	7cdb      	ldrb	r3, [r3, #19]
 8013b6a:	061b      	lsls	r3, r3, #24
 8013b6c:	4313      	orrs	r3, r2
 8013b6e:	0c1b      	lsrs	r3, r3, #16
 8013b70:	69fa      	ldr	r2, [r7, #28]
 8013b72:	18d3      	adds	r3, r2, r3
 8013b74:	61fb      	str	r3, [r7, #28]
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
 8013b76:	2316      	movs	r3, #22
 8013b78:	18fb      	adds	r3, r7, r3
 8013b7a:	881b      	ldrh	r3, [r3, #0]
 8013b7c:	089b      	lsrs	r3, r3, #2
 8013b7e:	b29b      	uxth	r3, r3
 8013b80:	b2db      	uxtb	r3, r3
 8013b82:	2240      	movs	r2, #64	; 0x40
 8013b84:	4313      	orrs	r3, r2
 8013b86:	b2da      	uxtb	r2, r3
 8013b88:	69bb      	ldr	r3, [r7, #24]
 8013b8a:	701a      	strb	r2, [r3, #0]
    IPH_TOS_SET(iphdr, tos);
 8013b8c:	69ba      	ldr	r2, [r7, #24]
 8013b8e:	2130      	movs	r1, #48	; 0x30
 8013b90:	187b      	adds	r3, r7, r1
 8013b92:	781b      	ldrb	r3, [r3, #0]
 8013b94:	7053      	strb	r3, [r2, #1]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += PP_NTOHS(tos | (iphdr->_v_hl << 8));
 8013b96:	187b      	adds	r3, r7, r1
 8013b98:	781a      	ldrb	r2, [r3, #0]
 8013b9a:	69bb      	ldr	r3, [r7, #24]
 8013b9c:	781b      	ldrb	r3, [r3, #0]
 8013b9e:	021b      	lsls	r3, r3, #8
 8013ba0:	4313      	orrs	r3, r2
 8013ba2:	021b      	lsls	r3, r3, #8
 8013ba4:	b21a      	sxth	r2, r3
 8013ba6:	187b      	adds	r3, r7, r1
 8013ba8:	7819      	ldrb	r1, [r3, #0]
 8013baa:	69bb      	ldr	r3, [r7, #24]
 8013bac:	781b      	ldrb	r3, [r3, #0]
 8013bae:	021b      	lsls	r3, r3, #8
 8013bb0:	430b      	orrs	r3, r1
 8013bb2:	121b      	asrs	r3, r3, #8
 8013bb4:	b21b      	sxth	r3, r3
 8013bb6:	21ff      	movs	r1, #255	; 0xff
 8013bb8:	400b      	ands	r3, r1
 8013bba:	b21b      	sxth	r3, r3
 8013bbc:	4313      	orrs	r3, r2
 8013bbe:	b21b      	sxth	r3, r3
 8013bc0:	b29b      	uxth	r3, r3
 8013bc2:	001a      	movs	r2, r3
 8013bc4:	69fb      	ldr	r3, [r7, #28]
 8013bc6:	189b      	adds	r3, r3, r2
 8013bc8:	61fb      	str	r3, [r7, #28]
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, lwip_htons(p->tot_len));
 8013bca:	68fb      	ldr	r3, [r7, #12]
 8013bcc:	891b      	ldrh	r3, [r3, #8]
 8013bce:	0018      	movs	r0, r3
 8013bd0:	f7f3 f990 	bl	8006ef4 <lwip_htons>
 8013bd4:	0003      	movs	r3, r0
 8013bd6:	001a      	movs	r2, r3
 8013bd8:	69bb      	ldr	r3, [r7, #24]
 8013bda:	21ff      	movs	r1, #255	; 0xff
 8013bdc:	4011      	ands	r1, r2
 8013bde:	000c      	movs	r4, r1
 8013be0:	7899      	ldrb	r1, [r3, #2]
 8013be2:	2000      	movs	r0, #0
 8013be4:	4001      	ands	r1, r0
 8013be6:	1c08      	adds	r0, r1, #0
 8013be8:	1c21      	adds	r1, r4, #0
 8013bea:	4301      	orrs	r1, r0
 8013bec:	7099      	strb	r1, [r3, #2]
 8013bee:	0a12      	lsrs	r2, r2, #8
 8013bf0:	b290      	uxth	r0, r2
 8013bf2:	78da      	ldrb	r2, [r3, #3]
 8013bf4:	2100      	movs	r1, #0
 8013bf6:	400a      	ands	r2, r1
 8013bf8:	1c11      	adds	r1, r2, #0
 8013bfa:	1c02      	adds	r2, r0, #0
 8013bfc:	430a      	orrs	r2, r1
 8013bfe:	70da      	strb	r2, [r3, #3]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
 8013c00:	69bb      	ldr	r3, [r7, #24]
 8013c02:	789a      	ldrb	r2, [r3, #2]
 8013c04:	78db      	ldrb	r3, [r3, #3]
 8013c06:	021b      	lsls	r3, r3, #8
 8013c08:	4313      	orrs	r3, r2
 8013c0a:	b29b      	uxth	r3, r3
 8013c0c:	001a      	movs	r2, r3
 8013c0e:	69fb      	ldr	r3, [r7, #28]
 8013c10:	189b      	adds	r3, r3, r2
 8013c12:	61fb      	str	r3, [r7, #28]
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
 8013c14:	69bb      	ldr	r3, [r7, #24]
 8013c16:	799a      	ldrb	r2, [r3, #6]
 8013c18:	2100      	movs	r1, #0
 8013c1a:	400a      	ands	r2, r1
 8013c1c:	719a      	strb	r2, [r3, #6]
 8013c1e:	79da      	ldrb	r2, [r3, #7]
 8013c20:	2100      	movs	r1, #0
 8013c22:	400a      	ands	r2, r1
 8013c24:	71da      	strb	r2, [r3, #7]
    IPH_ID_SET(iphdr, lwip_htons(ip_id));
 8013c26:	4b6c      	ldr	r3, [pc, #432]	; (8013dd8 <ip4_output_if_src+0x3a8>)
 8013c28:	881b      	ldrh	r3, [r3, #0]
 8013c2a:	0018      	movs	r0, r3
 8013c2c:	f7f3 f962 	bl	8006ef4 <lwip_htons>
 8013c30:	0003      	movs	r3, r0
 8013c32:	001a      	movs	r2, r3
 8013c34:	69bb      	ldr	r3, [r7, #24]
 8013c36:	21ff      	movs	r1, #255	; 0xff
 8013c38:	4011      	ands	r1, r2
 8013c3a:	000c      	movs	r4, r1
 8013c3c:	7919      	ldrb	r1, [r3, #4]
 8013c3e:	2000      	movs	r0, #0
 8013c40:	4001      	ands	r1, r0
 8013c42:	1c08      	adds	r0, r1, #0
 8013c44:	1c21      	adds	r1, r4, #0
 8013c46:	4301      	orrs	r1, r0
 8013c48:	7119      	strb	r1, [r3, #4]
 8013c4a:	0a12      	lsrs	r2, r2, #8
 8013c4c:	b290      	uxth	r0, r2
 8013c4e:	795a      	ldrb	r2, [r3, #5]
 8013c50:	2100      	movs	r1, #0
 8013c52:	400a      	ands	r2, r1
 8013c54:	1c11      	adds	r1, r2, #0
 8013c56:	1c02      	adds	r2, r0, #0
 8013c58:	430a      	orrs	r2, r1
 8013c5a:	715a      	strb	r2, [r3, #5]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
 8013c5c:	69bb      	ldr	r3, [r7, #24]
 8013c5e:	791a      	ldrb	r2, [r3, #4]
 8013c60:	795b      	ldrb	r3, [r3, #5]
 8013c62:	021b      	lsls	r3, r3, #8
 8013c64:	4313      	orrs	r3, r2
 8013c66:	b29b      	uxth	r3, r3
 8013c68:	001a      	movs	r2, r3
 8013c6a:	69fb      	ldr	r3, [r7, #28]
 8013c6c:	189b      	adds	r3, r3, r2
 8013c6e:	61fb      	str	r3, [r7, #28]
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
 8013c70:	4b59      	ldr	r3, [pc, #356]	; (8013dd8 <ip4_output_if_src+0x3a8>)
 8013c72:	881b      	ldrh	r3, [r3, #0]
 8013c74:	3301      	adds	r3, #1
 8013c76:	b29a      	uxth	r2, r3
 8013c78:	4b57      	ldr	r3, [pc, #348]	; (8013dd8 <ip4_output_if_src+0x3a8>)
 8013c7a:	801a      	strh	r2, [r3, #0]

    if (src == NULL) {
 8013c7c:	68bb      	ldr	r3, [r7, #8]
 8013c7e:	2b00      	cmp	r3, #0
 8013c80:	d12b      	bne.n	8013cda <ip4_output_if_src+0x2aa>
      ip4_addr_copy(iphdr->src, *IP4_ADDR_ANY4);
 8013c82:	4b56      	ldr	r3, [pc, #344]	; (8013ddc <ip4_output_if_src+0x3ac>)
 8013c84:	681a      	ldr	r2, [r3, #0]
 8013c86:	69bb      	ldr	r3, [r7, #24]
 8013c88:	21ff      	movs	r1, #255	; 0xff
 8013c8a:	4011      	ands	r1, r2
 8013c8c:	000c      	movs	r4, r1
 8013c8e:	7b19      	ldrb	r1, [r3, #12]
 8013c90:	2000      	movs	r0, #0
 8013c92:	4001      	ands	r1, r0
 8013c94:	1c08      	adds	r0, r1, #0
 8013c96:	1c21      	adds	r1, r4, #0
 8013c98:	4301      	orrs	r1, r0
 8013c9a:	7319      	strb	r1, [r3, #12]
 8013c9c:	0a11      	lsrs	r1, r2, #8
 8013c9e:	20ff      	movs	r0, #255	; 0xff
 8013ca0:	4001      	ands	r1, r0
 8013ca2:	000c      	movs	r4, r1
 8013ca4:	7b59      	ldrb	r1, [r3, #13]
 8013ca6:	2000      	movs	r0, #0
 8013ca8:	4001      	ands	r1, r0
 8013caa:	1c08      	adds	r0, r1, #0
 8013cac:	1c21      	adds	r1, r4, #0
 8013cae:	4301      	orrs	r1, r0
 8013cb0:	7359      	strb	r1, [r3, #13]
 8013cb2:	0c11      	lsrs	r1, r2, #16
 8013cb4:	20ff      	movs	r0, #255	; 0xff
 8013cb6:	4001      	ands	r1, r0
 8013cb8:	000c      	movs	r4, r1
 8013cba:	7b99      	ldrb	r1, [r3, #14]
 8013cbc:	2000      	movs	r0, #0
 8013cbe:	4001      	ands	r1, r0
 8013cc0:	1c08      	adds	r0, r1, #0
 8013cc2:	1c21      	adds	r1, r4, #0
 8013cc4:	4301      	orrs	r1, r0
 8013cc6:	7399      	strb	r1, [r3, #14]
 8013cc8:	0e10      	lsrs	r0, r2, #24
 8013cca:	7bda      	ldrb	r2, [r3, #15]
 8013ccc:	2100      	movs	r1, #0
 8013cce:	400a      	ands	r2, r1
 8013cd0:	1c11      	adds	r1, r2, #0
 8013cd2:	1c02      	adds	r2, r0, #0
 8013cd4:	430a      	orrs	r2, r1
 8013cd6:	73da      	strb	r2, [r3, #15]
 8013cd8:	e02a      	b.n	8013d30 <ip4_output_if_src+0x300>
    } else {
      /* src cannot be NULL here */
      ip4_addr_copy(iphdr->src, *src);
 8013cda:	68bb      	ldr	r3, [r7, #8]
 8013cdc:	681a      	ldr	r2, [r3, #0]
 8013cde:	69bb      	ldr	r3, [r7, #24]
 8013ce0:	21ff      	movs	r1, #255	; 0xff
 8013ce2:	4011      	ands	r1, r2
 8013ce4:	000c      	movs	r4, r1
 8013ce6:	7b19      	ldrb	r1, [r3, #12]
 8013ce8:	2000      	movs	r0, #0
 8013cea:	4001      	ands	r1, r0
 8013cec:	1c08      	adds	r0, r1, #0
 8013cee:	1c21      	adds	r1, r4, #0
 8013cf0:	4301      	orrs	r1, r0
 8013cf2:	7319      	strb	r1, [r3, #12]
 8013cf4:	0a11      	lsrs	r1, r2, #8
 8013cf6:	20ff      	movs	r0, #255	; 0xff
 8013cf8:	4001      	ands	r1, r0
 8013cfa:	000c      	movs	r4, r1
 8013cfc:	7b59      	ldrb	r1, [r3, #13]
 8013cfe:	2000      	movs	r0, #0
 8013d00:	4001      	ands	r1, r0
 8013d02:	1c08      	adds	r0, r1, #0
 8013d04:	1c21      	adds	r1, r4, #0
 8013d06:	4301      	orrs	r1, r0
 8013d08:	7359      	strb	r1, [r3, #13]
 8013d0a:	0c11      	lsrs	r1, r2, #16
 8013d0c:	20ff      	movs	r0, #255	; 0xff
 8013d0e:	4001      	ands	r1, r0
 8013d10:	000c      	movs	r4, r1
 8013d12:	7b99      	ldrb	r1, [r3, #14]
 8013d14:	2000      	movs	r0, #0
 8013d16:	4001      	ands	r1, r0
 8013d18:	1c08      	adds	r0, r1, #0
 8013d1a:	1c21      	adds	r1, r4, #0
 8013d1c:	4301      	orrs	r1, r0
 8013d1e:	7399      	strb	r1, [r3, #14]
 8013d20:	0e10      	lsrs	r0, r2, #24
 8013d22:	7bda      	ldrb	r2, [r3, #15]
 8013d24:	2100      	movs	r1, #0
 8013d26:	400a      	ands	r2, r1
 8013d28:	1c11      	adds	r1, r2, #0
 8013d2a:	1c02      	adds	r2, r0, #0
 8013d2c:	430a      	orrs	r2, r1
 8013d2e:	73da      	strb	r2, [r3, #15]
    }

#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
 8013d30:	69bb      	ldr	r3, [r7, #24]
 8013d32:	7b1a      	ldrb	r2, [r3, #12]
 8013d34:	7b59      	ldrb	r1, [r3, #13]
 8013d36:	0209      	lsls	r1, r1, #8
 8013d38:	430a      	orrs	r2, r1
 8013d3a:	7b99      	ldrb	r1, [r3, #14]
 8013d3c:	0409      	lsls	r1, r1, #16
 8013d3e:	430a      	orrs	r2, r1
 8013d40:	7bdb      	ldrb	r3, [r3, #15]
 8013d42:	061b      	lsls	r3, r3, #24
 8013d44:	4313      	orrs	r3, r2
 8013d46:	041b      	lsls	r3, r3, #16
 8013d48:	0c1b      	lsrs	r3, r3, #16
 8013d4a:	69fa      	ldr	r2, [r7, #28]
 8013d4c:	18d3      	adds	r3, r2, r3
 8013d4e:	61fb      	str	r3, [r7, #28]
    chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
 8013d50:	69bb      	ldr	r3, [r7, #24]
 8013d52:	7b1a      	ldrb	r2, [r3, #12]
 8013d54:	7b59      	ldrb	r1, [r3, #13]
 8013d56:	0209      	lsls	r1, r1, #8
 8013d58:	430a      	orrs	r2, r1
 8013d5a:	7b99      	ldrb	r1, [r3, #14]
 8013d5c:	0409      	lsls	r1, r1, #16
 8013d5e:	430a      	orrs	r2, r1
 8013d60:	7bdb      	ldrb	r3, [r3, #15]
 8013d62:	061b      	lsls	r3, r3, #24
 8013d64:	4313      	orrs	r3, r2
 8013d66:	0c1b      	lsrs	r3, r3, #16
 8013d68:	69fa      	ldr	r2, [r7, #28]
 8013d6a:	18d3      	adds	r3, r2, r3
 8013d6c:	61fb      	str	r3, [r7, #28]
    chk_sum = (chk_sum >> 16) + (chk_sum & 0xFFFF);
 8013d6e:	69fb      	ldr	r3, [r7, #28]
 8013d70:	0c1a      	lsrs	r2, r3, #16
 8013d72:	69fb      	ldr	r3, [r7, #28]
 8013d74:	041b      	lsls	r3, r3, #16
 8013d76:	0c1b      	lsrs	r3, r3, #16
 8013d78:	18d3      	adds	r3, r2, r3
 8013d7a:	61fb      	str	r3, [r7, #28]
    chk_sum = (chk_sum >> 16) + chk_sum;
 8013d7c:	69fb      	ldr	r3, [r7, #28]
 8013d7e:	0c1b      	lsrs	r3, r3, #16
 8013d80:	69fa      	ldr	r2, [r7, #28]
 8013d82:	18d3      	adds	r3, r2, r3
 8013d84:	61fb      	str	r3, [r7, #28]
    chk_sum = ~chk_sum;
 8013d86:	69fb      	ldr	r3, [r7, #28]
 8013d88:	43db      	mvns	r3, r3
 8013d8a:	61fb      	str	r3, [r7, #28]
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_IP) {
      iphdr->_chksum = (u16_t)chk_sum; /* network order */
 8013d8c:	69fb      	ldr	r3, [r7, #28]
 8013d8e:	b29a      	uxth	r2, r3
 8013d90:	69bb      	ldr	r3, [r7, #24]
 8013d92:	21ff      	movs	r1, #255	; 0xff
 8013d94:	4011      	ands	r1, r2
 8013d96:	000c      	movs	r4, r1
 8013d98:	7a99      	ldrb	r1, [r3, #10]
 8013d9a:	2000      	movs	r0, #0
 8013d9c:	4001      	ands	r1, r0
 8013d9e:	1c08      	adds	r0, r1, #0
 8013da0:	1c21      	adds	r1, r4, #0
 8013da2:	4301      	orrs	r1, r0
 8013da4:	7299      	strb	r1, [r3, #10]
 8013da6:	0a12      	lsrs	r2, r2, #8
 8013da8:	b290      	uxth	r0, r2
 8013daa:	7ada      	ldrb	r2, [r3, #11]
 8013dac:	2100      	movs	r1, #0
 8013dae:	400a      	ands	r2, r1
 8013db0:	1c11      	adds	r1, r2, #0
 8013db2:	1c02      	adds	r2, r0, #0
 8013db4:	430a      	orrs	r2, r1
 8013db6:	72da      	strb	r2, [r3, #11]
 8013db8:	e024      	b.n	8013e04 <ip4_output_if_src+0x3d4>
    }
#endif /* CHECKSUM_GEN_IP */
#endif /* CHECKSUM_GEN_IP_INLINE */
  } else {
    /* IP header already included in p */
    if (p->len < IP_HLEN) {
 8013dba:	68fb      	ldr	r3, [r7, #12]
 8013dbc:	895b      	ldrh	r3, [r3, #10]
 8013dbe:	2b13      	cmp	r3, #19
 8013dc0:	d80e      	bhi.n	8013de0 <ip4_output_if_src+0x3b0>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output: LWIP_IP_HDRINCL but pbuf is too short\n"));
      IP_STATS_INC(ip.err);
      MIB2_STATS_INC(mib2.ipoutdiscards);
      return ERR_BUF;
 8013dc2:	2302      	movs	r3, #2
 8013dc4:	425b      	negs	r3, r3
 8013dc6:	e024      	b.n	8013e12 <ip4_output_if_src+0x3e2>
 8013dc8:	080218c4 	.word	0x080218c4
 8013dcc:	080218f0 	.word	0x080218f0
 8013dd0:	080218fc 	.word	0x080218fc
 8013dd4:	08021928 	.word	0x08021928
 8013dd8:	200017d8 	.word	0x200017d8
 8013ddc:	08022888 	.word	0x08022888
    }
    iphdr = (struct ip_hdr *)p->payload;
 8013de0:	68fb      	ldr	r3, [r7, #12]
 8013de2:	685b      	ldr	r3, [r3, #4]
 8013de4:	61bb      	str	r3, [r7, #24]
    ip4_addr_copy(dest_addr, iphdr->dest);
 8013de6:	69bb      	ldr	r3, [r7, #24]
 8013de8:	7c1a      	ldrb	r2, [r3, #16]
 8013dea:	7c59      	ldrb	r1, [r3, #17]
 8013dec:	0209      	lsls	r1, r1, #8
 8013dee:	430a      	orrs	r2, r1
 8013df0:	7c99      	ldrb	r1, [r3, #18]
 8013df2:	0409      	lsls	r1, r1, #16
 8013df4:	430a      	orrs	r2, r1
 8013df6:	7cdb      	ldrb	r3, [r3, #19]
 8013df8:	061b      	lsls	r3, r3, #24
 8013dfa:	4313      	orrs	r3, r2
 8013dfc:	613b      	str	r3, [r7, #16]
    dest = &dest_addr;
 8013dfe:	2310      	movs	r3, #16
 8013e00:	18fb      	adds	r3, r7, r3
 8013e02:	607b      	str	r3, [r7, #4]
    return ip4_frag(p, netif, dest);
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("ip4_output_if: call netif->output()\n"));
  return netif->output(netif, p, dest);
 8013e04:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8013e06:	695b      	ldr	r3, [r3, #20]
 8013e08:	687a      	ldr	r2, [r7, #4]
 8013e0a:	68f9      	ldr	r1, [r7, #12]
 8013e0c:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8013e0e:	4798      	blx	r3
 8013e10:	0003      	movs	r3, r0
}
 8013e12:	0018      	movs	r0, r3
 8013e14:	46bd      	mov	sp, r7
 8013e16:	b009      	add	sp, #36	; 0x24
 8013e18:	bd90      	pop	{r4, r7, pc}
 8013e1a:	46c0      	nop			; (mov r8, r8)

08013e1c <ip4_addr_isbroadcast_u32>:
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t
ip4_addr_isbroadcast_u32(u32_t addr, const struct netif *netif)
{
 8013e1c:	b580      	push	{r7, lr}
 8013e1e:	b084      	sub	sp, #16
 8013e20:	af00      	add	r7, sp, #0
 8013e22:	6078      	str	r0, [r7, #4]
 8013e24:	6039      	str	r1, [r7, #0]
  ip4_addr_t ipaddr;
  ip4_addr_set_u32(&ipaddr, addr);
 8013e26:	687b      	ldr	r3, [r7, #4]
 8013e28:	60fb      	str	r3, [r7, #12]

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
 8013e2a:	687b      	ldr	r3, [r7, #4]
 8013e2c:	3301      	adds	r3, #1
 8013e2e:	d002      	beq.n	8013e36 <ip4_addr_isbroadcast_u32+0x1a>
 8013e30:	687b      	ldr	r3, [r7, #4]
 8013e32:	2b00      	cmp	r3, #0
 8013e34:	d101      	bne.n	8013e3a <ip4_addr_isbroadcast_u32+0x1e>
      (addr == IPADDR_ANY)) {
    return 1;
 8013e36:	2301      	movs	r3, #1
 8013e38:	e029      	b.n	8013e8e <ip4_addr_isbroadcast_u32+0x72>
    /* no broadcast support on this network interface? */
  } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
 8013e3a:	683b      	ldr	r3, [r7, #0]
 8013e3c:	2231      	movs	r2, #49	; 0x31
 8013e3e:	5c9b      	ldrb	r3, [r3, r2]
 8013e40:	001a      	movs	r2, r3
 8013e42:	2302      	movs	r3, #2
 8013e44:	4013      	ands	r3, r2
 8013e46:	d101      	bne.n	8013e4c <ip4_addr_isbroadcast_u32+0x30>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
 8013e48:	2300      	movs	r3, #0
 8013e4a:	e020      	b.n	8013e8e <ip4_addr_isbroadcast_u32+0x72>
    /* address matches network interface address exactly? => no broadcast */
  } else if (addr == ip4_addr_get_u32(netif_ip4_addr(netif))) {
 8013e4c:	683b      	ldr	r3, [r7, #0]
 8013e4e:	3304      	adds	r3, #4
 8013e50:	681b      	ldr	r3, [r3, #0]
 8013e52:	687a      	ldr	r2, [r7, #4]
 8013e54:	429a      	cmp	r2, r3
 8013e56:	d101      	bne.n	8013e5c <ip4_addr_isbroadcast_u32+0x40>
    return 0;
 8013e58:	2300      	movs	r3, #0
 8013e5a:	e018      	b.n	8013e8e <ip4_addr_isbroadcast_u32+0x72>
    /*  on the same (sub) network... */
  } else if (ip4_addr_netcmp(&ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif))
 8013e5c:	68fa      	ldr	r2, [r7, #12]
 8013e5e:	683b      	ldr	r3, [r7, #0]
 8013e60:	3304      	adds	r3, #4
 8013e62:	681b      	ldr	r3, [r3, #0]
 8013e64:	405a      	eors	r2, r3
 8013e66:	683b      	ldr	r3, [r7, #0]
 8013e68:	3308      	adds	r3, #8
 8013e6a:	681b      	ldr	r3, [r3, #0]
 8013e6c:	4013      	ands	r3, r2
 8013e6e:	d10d      	bne.n	8013e8c <ip4_addr_isbroadcast_u32+0x70>
             /* ...and host identifier bits are all ones? =>... */
             && ((addr & ~ip4_addr_get_u32(netif_ip4_netmask(netif))) ==
 8013e70:	683b      	ldr	r3, [r7, #0]
 8013e72:	3308      	adds	r3, #8
 8013e74:	681b      	ldr	r3, [r3, #0]
 8013e76:	43db      	mvns	r3, r3
 8013e78:	687a      	ldr	r2, [r7, #4]
 8013e7a:	401a      	ands	r2, r3
                 (IPADDR_BROADCAST & ~ip4_addr_get_u32(netif_ip4_netmask(netif))))) {
 8013e7c:	683b      	ldr	r3, [r7, #0]
 8013e7e:	3308      	adds	r3, #8
 8013e80:	681b      	ldr	r3, [r3, #0]
 8013e82:	43db      	mvns	r3, r3
             && ((addr & ~ip4_addr_get_u32(netif_ip4_netmask(netif))) ==
 8013e84:	429a      	cmp	r2, r3
 8013e86:	d101      	bne.n	8013e8c <ip4_addr_isbroadcast_u32+0x70>
    /* => network broadcast address */
    return 1;
 8013e88:	2301      	movs	r3, #1
 8013e8a:	e000      	b.n	8013e8e <ip4_addr_isbroadcast_u32+0x72>
  } else {
    return 0;
 8013e8c:	2300      	movs	r3, #0
  }
}
 8013e8e:	0018      	movs	r0, r3
 8013e90:	46bd      	mov	sp, r7
 8013e92:	b004      	add	sp, #16
 8013e94:	bd80      	pop	{r7, pc}
	...

08013e98 <ip4addr_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
ip4addr_aton(const char *cp, ip4_addr_t *addr)
{
 8013e98:	b580      	push	{r7, lr}
 8013e9a:	b08a      	sub	sp, #40	; 0x28
 8013e9c:	af00      	add	r7, sp, #0
 8013e9e:	6078      	str	r0, [r7, #4]
 8013ea0:	6039      	str	r1, [r7, #0]
  u32_t val;
  u8_t base;
  char c;
  u32_t parts[4];
  u32_t *pp = parts;
 8013ea2:	230c      	movs	r3, #12
 8013ea4:	18fb      	adds	r3, r7, r3
 8013ea6:	61fb      	str	r3, [r7, #28]

  c = *cp;
 8013ea8:	2322      	movs	r3, #34	; 0x22
 8013eaa:	18fb      	adds	r3, r7, r3
 8013eac:	687a      	ldr	r2, [r7, #4]
 8013eae:	7812      	ldrb	r2, [r2, #0]
 8013eb0:	701a      	strb	r2, [r3, #0]
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!lwip_isdigit(c)) {
 8013eb2:	2322      	movs	r3, #34	; 0x22
 8013eb4:	18fb      	adds	r3, r7, r3
 8013eb6:	781b      	ldrb	r3, [r3, #0]
 8013eb8:	1c5a      	adds	r2, r3, #1
 8013eba:	4b9d      	ldr	r3, [pc, #628]	; (8014130 <ip4addr_aton+0x298>)
 8013ebc:	18d3      	adds	r3, r2, r3
 8013ebe:	781b      	ldrb	r3, [r3, #0]
 8013ec0:	001a      	movs	r2, r3
 8013ec2:	2304      	movs	r3, #4
 8013ec4:	4013      	ands	r3, r2
 8013ec6:	d101      	bne.n	8013ecc <ip4addr_aton+0x34>
      return 0;
 8013ec8:	2300      	movs	r3, #0
 8013eca:	e12d      	b.n	8014128 <ip4addr_aton+0x290>
    }
    val = 0;
 8013ecc:	2300      	movs	r3, #0
 8013ece:	627b      	str	r3, [r7, #36]	; 0x24
    base = 10;
 8013ed0:	2323      	movs	r3, #35	; 0x23
 8013ed2:	18fb      	adds	r3, r7, r3
 8013ed4:	220a      	movs	r2, #10
 8013ed6:	701a      	strb	r2, [r3, #0]
    if (c == '0') {
 8013ed8:	2222      	movs	r2, #34	; 0x22
 8013eda:	18bb      	adds	r3, r7, r2
 8013edc:	781b      	ldrb	r3, [r3, #0]
 8013ede:	2b30      	cmp	r3, #48	; 0x30
 8013ee0:	d121      	bne.n	8013f26 <ip4addr_aton+0x8e>
      c = *++cp;
 8013ee2:	687b      	ldr	r3, [r7, #4]
 8013ee4:	3301      	adds	r3, #1
 8013ee6:	607b      	str	r3, [r7, #4]
 8013ee8:	0011      	movs	r1, r2
 8013eea:	18bb      	adds	r3, r7, r2
 8013eec:	687a      	ldr	r2, [r7, #4]
 8013eee:	7812      	ldrb	r2, [r2, #0]
 8013ef0:	701a      	strb	r2, [r3, #0]
      if (c == 'x' || c == 'X') {
 8013ef2:	000a      	movs	r2, r1
 8013ef4:	18bb      	adds	r3, r7, r2
 8013ef6:	781b      	ldrb	r3, [r3, #0]
 8013ef8:	2b78      	cmp	r3, #120	; 0x78
 8013efa:	d003      	beq.n	8013f04 <ip4addr_aton+0x6c>
 8013efc:	18bb      	adds	r3, r7, r2
 8013efe:	781b      	ldrb	r3, [r3, #0]
 8013f00:	2b58      	cmp	r3, #88	; 0x58
 8013f02:	d10c      	bne.n	8013f1e <ip4addr_aton+0x86>
        base = 16;
 8013f04:	2323      	movs	r3, #35	; 0x23
 8013f06:	18fb      	adds	r3, r7, r3
 8013f08:	2210      	movs	r2, #16
 8013f0a:	701a      	strb	r2, [r3, #0]
        c = *++cp;
 8013f0c:	687b      	ldr	r3, [r7, #4]
 8013f0e:	3301      	adds	r3, #1
 8013f10:	607b      	str	r3, [r7, #4]
 8013f12:	2322      	movs	r3, #34	; 0x22
 8013f14:	18fb      	adds	r3, r7, r3
 8013f16:	687a      	ldr	r2, [r7, #4]
 8013f18:	7812      	ldrb	r2, [r2, #0]
 8013f1a:	701a      	strb	r2, [r3, #0]
 8013f1c:	e003      	b.n	8013f26 <ip4addr_aton+0x8e>
      } else {
        base = 8;
 8013f1e:	2323      	movs	r3, #35	; 0x23
 8013f20:	18fb      	adds	r3, r7, r3
 8013f22:	2208      	movs	r2, #8
 8013f24:	701a      	strb	r2, [r3, #0]
      }
    }
    for (;;) {
      if (lwip_isdigit(c)) {
 8013f26:	2122      	movs	r1, #34	; 0x22
 8013f28:	187b      	adds	r3, r7, r1
 8013f2a:	781b      	ldrb	r3, [r3, #0]
 8013f2c:	1c5a      	adds	r2, r3, #1
 8013f2e:	4b80      	ldr	r3, [pc, #512]	; (8014130 <ip4addr_aton+0x298>)
 8013f30:	18d3      	adds	r3, r2, r3
 8013f32:	781b      	ldrb	r3, [r3, #0]
 8013f34:	001a      	movs	r2, r3
 8013f36:	2304      	movs	r3, #4
 8013f38:	4013      	ands	r3, r2
 8013f3a:	d01c      	beq.n	8013f76 <ip4addr_aton+0xde>
        if((base == 8) && ((u32_t)(c - '0') >= 8))
 8013f3c:	2323      	movs	r3, #35	; 0x23
 8013f3e:	18fb      	adds	r3, r7, r3
 8013f40:	781b      	ldrb	r3, [r3, #0]
 8013f42:	2b08      	cmp	r3, #8
 8013f44:	d104      	bne.n	8013f50 <ip4addr_aton+0xb8>
 8013f46:	187b      	adds	r3, r7, r1
 8013f48:	781b      	ldrb	r3, [r3, #0]
 8013f4a:	3b30      	subs	r3, #48	; 0x30
 8013f4c:	2b07      	cmp	r3, #7
 8013f4e:	d843      	bhi.n	8013fd8 <ip4addr_aton+0x140>
          break;
        val = (val * base) + (u32_t)(c - '0');
 8013f50:	2323      	movs	r3, #35	; 0x23
 8013f52:	18fb      	adds	r3, r7, r3
 8013f54:	781b      	ldrb	r3, [r3, #0]
 8013f56:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8013f58:	435a      	muls	r2, r3
 8013f5a:	2122      	movs	r1, #34	; 0x22
 8013f5c:	187b      	adds	r3, r7, r1
 8013f5e:	781b      	ldrb	r3, [r3, #0]
 8013f60:	18d3      	adds	r3, r2, r3
 8013f62:	3b30      	subs	r3, #48	; 0x30
 8013f64:	627b      	str	r3, [r7, #36]	; 0x24
        c = *++cp;
 8013f66:	687b      	ldr	r3, [r7, #4]
 8013f68:	3301      	adds	r3, #1
 8013f6a:	607b      	str	r3, [r7, #4]
 8013f6c:	187b      	adds	r3, r7, r1
 8013f6e:	687a      	ldr	r2, [r7, #4]
 8013f70:	7812      	ldrb	r2, [r2, #0]
 8013f72:	701a      	strb	r2, [r3, #0]
 8013f74:	e7d7      	b.n	8013f26 <ip4addr_aton+0x8e>
      } else if (base == 16 && lwip_isxdigit(c)) {
 8013f76:	2323      	movs	r3, #35	; 0x23
 8013f78:	18fb      	adds	r3, r7, r3
 8013f7a:	781b      	ldrb	r3, [r3, #0]
 8013f7c:	2b10      	cmp	r3, #16
 8013f7e:	d12c      	bne.n	8013fda <ip4addr_aton+0x142>
 8013f80:	2122      	movs	r1, #34	; 0x22
 8013f82:	187b      	adds	r3, r7, r1
 8013f84:	781b      	ldrb	r3, [r3, #0]
 8013f86:	1c5a      	adds	r2, r3, #1
 8013f88:	4b69      	ldr	r3, [pc, #420]	; (8014130 <ip4addr_aton+0x298>)
 8013f8a:	18d3      	adds	r3, r2, r3
 8013f8c:	781b      	ldrb	r3, [r3, #0]
 8013f8e:	001a      	movs	r2, r3
 8013f90:	2344      	movs	r3, #68	; 0x44
 8013f92:	4013      	ands	r3, r2
 8013f94:	d021      	beq.n	8013fda <ip4addr_aton+0x142>
        val = (val << 4) | (u32_t)(c + 10 - (lwip_islower(c) ? 'a' : 'A'));
 8013f96:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013f98:	011a      	lsls	r2, r3, #4
 8013f9a:	0008      	movs	r0, r1
 8013f9c:	187b      	adds	r3, r7, r1
 8013f9e:	781b      	ldrb	r3, [r3, #0]
 8013fa0:	330a      	adds	r3, #10
 8013fa2:	0019      	movs	r1, r3
 8013fa4:	183b      	adds	r3, r7, r0
 8013fa6:	781b      	ldrb	r3, [r3, #0]
 8013fa8:	1c58      	adds	r0, r3, #1
 8013faa:	4b61      	ldr	r3, [pc, #388]	; (8014130 <ip4addr_aton+0x298>)
 8013fac:	18c3      	adds	r3, r0, r3
 8013fae:	781b      	ldrb	r3, [r3, #0]
 8013fb0:	0018      	movs	r0, r3
 8013fb2:	2303      	movs	r3, #3
 8013fb4:	4003      	ands	r3, r0
 8013fb6:	2b02      	cmp	r3, #2
 8013fb8:	d101      	bne.n	8013fbe <ip4addr_aton+0x126>
 8013fba:	2361      	movs	r3, #97	; 0x61
 8013fbc:	e000      	b.n	8013fc0 <ip4addr_aton+0x128>
 8013fbe:	2341      	movs	r3, #65	; 0x41
 8013fc0:	1acb      	subs	r3, r1, r3
 8013fc2:	4313      	orrs	r3, r2
 8013fc4:	627b      	str	r3, [r7, #36]	; 0x24
        c = *++cp;
 8013fc6:	687b      	ldr	r3, [r7, #4]
 8013fc8:	3301      	adds	r3, #1
 8013fca:	607b      	str	r3, [r7, #4]
 8013fcc:	2322      	movs	r3, #34	; 0x22
 8013fce:	18fb      	adds	r3, r7, r3
 8013fd0:	687a      	ldr	r2, [r7, #4]
 8013fd2:	7812      	ldrb	r2, [r2, #0]
 8013fd4:	701a      	strb	r2, [r3, #0]
      if (lwip_isdigit(c)) {
 8013fd6:	e7a6      	b.n	8013f26 <ip4addr_aton+0x8e>
          break;
 8013fd8:	46c0      	nop			; (mov r8, r8)
      } else {
        break;
      }
    }
    if (c == '.') {
 8013fda:	2322      	movs	r3, #34	; 0x22
 8013fdc:	18fb      	adds	r3, r7, r3
 8013fde:	781b      	ldrb	r3, [r3, #0]
 8013fe0:	2b2e      	cmp	r3, #46	; 0x2e
 8013fe2:	d115      	bne.n	8014010 <ip4addr_aton+0x178>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3) {
 8013fe4:	230c      	movs	r3, #12
 8013fe6:	18fb      	adds	r3, r7, r3
 8013fe8:	330c      	adds	r3, #12
 8013fea:	69fa      	ldr	r2, [r7, #28]
 8013fec:	429a      	cmp	r2, r3
 8013fee:	d301      	bcc.n	8013ff4 <ip4addr_aton+0x15c>
        return 0;
 8013ff0:	2300      	movs	r3, #0
 8013ff2:	e099      	b.n	8014128 <ip4addr_aton+0x290>
      }
      *pp++ = val;
 8013ff4:	69fb      	ldr	r3, [r7, #28]
 8013ff6:	1d1a      	adds	r2, r3, #4
 8013ff8:	61fa      	str	r2, [r7, #28]
 8013ffa:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8013ffc:	601a      	str	r2, [r3, #0]
      c = *++cp;
 8013ffe:	687b      	ldr	r3, [r7, #4]
 8014000:	3301      	adds	r3, #1
 8014002:	607b      	str	r3, [r7, #4]
 8014004:	2322      	movs	r3, #34	; 0x22
 8014006:	18fb      	adds	r3, r7, r3
 8014008:	687a      	ldr	r2, [r7, #4]
 801400a:	7812      	ldrb	r2, [r2, #0]
 801400c:	701a      	strb	r2, [r3, #0]
    if (!lwip_isdigit(c)) {
 801400e:	e750      	b.n	8013eb2 <ip4addr_aton+0x1a>
    } else {
      break;
 8014010:	46c0      	nop			; (mov r8, r8)
    }
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && !lwip_isspace(c)) {
 8014012:	2222      	movs	r2, #34	; 0x22
 8014014:	18bb      	adds	r3, r7, r2
 8014016:	781b      	ldrb	r3, [r3, #0]
 8014018:	2b00      	cmp	r3, #0
 801401a:	d00b      	beq.n	8014034 <ip4addr_aton+0x19c>
 801401c:	18bb      	adds	r3, r7, r2
 801401e:	781b      	ldrb	r3, [r3, #0]
 8014020:	1c5a      	adds	r2, r3, #1
 8014022:	4b43      	ldr	r3, [pc, #268]	; (8014130 <ip4addr_aton+0x298>)
 8014024:	18d3      	adds	r3, r2, r3
 8014026:	781b      	ldrb	r3, [r3, #0]
 8014028:	001a      	movs	r2, r3
 801402a:	2308      	movs	r3, #8
 801402c:	4013      	ands	r3, r2
 801402e:	d101      	bne.n	8014034 <ip4addr_aton+0x19c>
    return 0;
 8014030:	2300      	movs	r3, #0
 8014032:	e079      	b.n	8014128 <ip4addr_aton+0x290>
  }
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  switch (pp - parts + 1) {
 8014034:	230c      	movs	r3, #12
 8014036:	18fb      	adds	r3, r7, r3
 8014038:	69fa      	ldr	r2, [r7, #28]
 801403a:	1ad3      	subs	r3, r2, r3
 801403c:	109b      	asrs	r3, r3, #2
 801403e:	3301      	adds	r3, #1
 8014040:	2b04      	cmp	r3, #4
 8014042:	d85e      	bhi.n	8014102 <ip4addr_aton+0x26a>
 8014044:	009a      	lsls	r2, r3, #2
 8014046:	4b3b      	ldr	r3, [pc, #236]	; (8014134 <ip4addr_aton+0x29c>)
 8014048:	18d3      	adds	r3, r2, r3
 801404a:	681b      	ldr	r3, [r3, #0]
 801404c:	469f      	mov	pc, r3

    case 0:
      return 0;       /* initial nondigit */
 801404e:	2300      	movs	r3, #0
 8014050:	e06a      	b.n	8014128 <ip4addr_aton+0x290>

    case 1:             /* a -- 32 bits */
      break;

    case 2:             /* a.b -- 8.24 bits */
      if (val > 0xffffffUL) {
 8014052:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8014054:	2380      	movs	r3, #128	; 0x80
 8014056:	045b      	lsls	r3, r3, #17
 8014058:	429a      	cmp	r2, r3
 801405a:	d301      	bcc.n	8014060 <ip4addr_aton+0x1c8>
        return 0;
 801405c:	2300      	movs	r3, #0
 801405e:	e063      	b.n	8014128 <ip4addr_aton+0x290>
      }
      if (parts[0] > 0xff) {
 8014060:	230c      	movs	r3, #12
 8014062:	18fb      	adds	r3, r7, r3
 8014064:	681b      	ldr	r3, [r3, #0]
 8014066:	2bff      	cmp	r3, #255	; 0xff
 8014068:	d901      	bls.n	801406e <ip4addr_aton+0x1d6>
        return 0;
 801406a:	2300      	movs	r3, #0
 801406c:	e05c      	b.n	8014128 <ip4addr_aton+0x290>
      }
      val |= parts[0] << 24;
 801406e:	230c      	movs	r3, #12
 8014070:	18fb      	adds	r3, r7, r3
 8014072:	681b      	ldr	r3, [r3, #0]
 8014074:	061b      	lsls	r3, r3, #24
 8014076:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8014078:	4313      	orrs	r3, r2
 801407a:	627b      	str	r3, [r7, #36]	; 0x24
      break;
 801407c:	e049      	b.n	8014112 <ip4addr_aton+0x27a>

    case 3:             /* a.b.c -- 8.8.16 bits */
      if (val > 0xffff) {
 801407e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8014080:	2380      	movs	r3, #128	; 0x80
 8014082:	025b      	lsls	r3, r3, #9
 8014084:	429a      	cmp	r2, r3
 8014086:	d301      	bcc.n	801408c <ip4addr_aton+0x1f4>
        return 0;
 8014088:	2300      	movs	r3, #0
 801408a:	e04d      	b.n	8014128 <ip4addr_aton+0x290>
      }
      if ((parts[0] > 0xff) || (parts[1] > 0xff)) {
 801408c:	220c      	movs	r2, #12
 801408e:	18bb      	adds	r3, r7, r2
 8014090:	681b      	ldr	r3, [r3, #0]
 8014092:	2bff      	cmp	r3, #255	; 0xff
 8014094:	d803      	bhi.n	801409e <ip4addr_aton+0x206>
 8014096:	18bb      	adds	r3, r7, r2
 8014098:	685b      	ldr	r3, [r3, #4]
 801409a:	2bff      	cmp	r3, #255	; 0xff
 801409c:	d901      	bls.n	80140a2 <ip4addr_aton+0x20a>
        return 0;
 801409e:	2300      	movs	r3, #0
 80140a0:	e042      	b.n	8014128 <ip4addr_aton+0x290>
      }
      val |= (parts[0] << 24) | (parts[1] << 16);
 80140a2:	210c      	movs	r1, #12
 80140a4:	187b      	adds	r3, r7, r1
 80140a6:	681b      	ldr	r3, [r3, #0]
 80140a8:	061a      	lsls	r2, r3, #24
 80140aa:	187b      	adds	r3, r7, r1
 80140ac:	685b      	ldr	r3, [r3, #4]
 80140ae:	041b      	lsls	r3, r3, #16
 80140b0:	4313      	orrs	r3, r2
 80140b2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80140b4:	4313      	orrs	r3, r2
 80140b6:	627b      	str	r3, [r7, #36]	; 0x24
      break;
 80140b8:	e02b      	b.n	8014112 <ip4addr_aton+0x27a>

    case 4:             /* a.b.c.d -- 8.8.8.8 bits */
      if (val > 0xff) {
 80140ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80140bc:	2bff      	cmp	r3, #255	; 0xff
 80140be:	d901      	bls.n	80140c4 <ip4addr_aton+0x22c>
        return 0;
 80140c0:	2300      	movs	r3, #0
 80140c2:	e031      	b.n	8014128 <ip4addr_aton+0x290>
      }
      if ((parts[0] > 0xff) || (parts[1] > 0xff) || (parts[2] > 0xff)) {
 80140c4:	220c      	movs	r2, #12
 80140c6:	18bb      	adds	r3, r7, r2
 80140c8:	681b      	ldr	r3, [r3, #0]
 80140ca:	2bff      	cmp	r3, #255	; 0xff
 80140cc:	d807      	bhi.n	80140de <ip4addr_aton+0x246>
 80140ce:	18bb      	adds	r3, r7, r2
 80140d0:	685b      	ldr	r3, [r3, #4]
 80140d2:	2bff      	cmp	r3, #255	; 0xff
 80140d4:	d803      	bhi.n	80140de <ip4addr_aton+0x246>
 80140d6:	18bb      	adds	r3, r7, r2
 80140d8:	689b      	ldr	r3, [r3, #8]
 80140da:	2bff      	cmp	r3, #255	; 0xff
 80140dc:	d901      	bls.n	80140e2 <ip4addr_aton+0x24a>
        return 0;
 80140de:	2300      	movs	r3, #0
 80140e0:	e022      	b.n	8014128 <ip4addr_aton+0x290>
      }
      val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
 80140e2:	210c      	movs	r1, #12
 80140e4:	187b      	adds	r3, r7, r1
 80140e6:	681b      	ldr	r3, [r3, #0]
 80140e8:	061a      	lsls	r2, r3, #24
 80140ea:	187b      	adds	r3, r7, r1
 80140ec:	685b      	ldr	r3, [r3, #4]
 80140ee:	041b      	lsls	r3, r3, #16
 80140f0:	431a      	orrs	r2, r3
 80140f2:	187b      	adds	r3, r7, r1
 80140f4:	689b      	ldr	r3, [r3, #8]
 80140f6:	021b      	lsls	r3, r3, #8
 80140f8:	4313      	orrs	r3, r2
 80140fa:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80140fc:	4313      	orrs	r3, r2
 80140fe:	627b      	str	r3, [r7, #36]	; 0x24
      break;
 8014100:	e007      	b.n	8014112 <ip4addr_aton+0x27a>
    default:
      LWIP_ASSERT("unhandled", 0);
 8014102:	4b0d      	ldr	r3, [pc, #52]	; (8014138 <ip4addr_aton+0x2a0>)
 8014104:	490d      	ldr	r1, [pc, #52]	; (801413c <ip4addr_aton+0x2a4>)
 8014106:	480e      	ldr	r0, [pc, #56]	; (8014140 <ip4addr_aton+0x2a8>)
 8014108:	22fb      	movs	r2, #251	; 0xfb
 801410a:	f7ee fd5d 	bl	8002bc8 <app_debug_rtt_raw>
      break;
 801410e:	e000      	b.n	8014112 <ip4addr_aton+0x27a>
      break;
 8014110:	46c0      	nop			; (mov r8, r8)
  }
  if (addr) {
 8014112:	683b      	ldr	r3, [r7, #0]
 8014114:	2b00      	cmp	r3, #0
 8014116:	d006      	beq.n	8014126 <ip4addr_aton+0x28e>
    ip4_addr_set_u32(addr, lwip_htonl(val));
 8014118:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801411a:	0018      	movs	r0, r3
 801411c:	f7f2 ff00 	bl	8006f20 <lwip_htonl>
 8014120:	0002      	movs	r2, r0
 8014122:	683b      	ldr	r3, [r7, #0]
 8014124:	601a      	str	r2, [r3, #0]
  }
  return 1;
 8014126:	2301      	movs	r3, #1
}
 8014128:	0018      	movs	r0, r3
 801412a:	46bd      	mov	sp, r7
 801412c:	b00a      	add	sp, #40	; 0x28
 801412e:	bd80      	pop	{r7, pc}
 8014130:	08022e64 	.word	0x08022e64
 8014134:	08022890 	.word	0x08022890
 8014138:	08021958 	.word	0x08021958
 801413c:	08021988 	.word	0x08021988
 8014140:	08021994 	.word	0x08021994

08014144 <ip4addr_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         representation of addr
 */
char *
ip4addr_ntoa(const ip4_addr_t *addr)
{
 8014144:	b580      	push	{r7, lr}
 8014146:	b082      	sub	sp, #8
 8014148:	af00      	add	r7, sp, #0
 801414a:	6078      	str	r0, [r7, #4]
  static char str[IP4ADDR_STRLEN_MAX];
  return ip4addr_ntoa_r(addr, str, IP4ADDR_STRLEN_MAX);
 801414c:	4905      	ldr	r1, [pc, #20]	; (8014164 <ip4addr_ntoa+0x20>)
 801414e:	687b      	ldr	r3, [r7, #4]
 8014150:	2210      	movs	r2, #16
 8014152:	0018      	movs	r0, r3
 8014154:	f000 f808 	bl	8014168 <ip4addr_ntoa_r>
 8014158:	0003      	movs	r3, r0
}
 801415a:	0018      	movs	r0, r3
 801415c:	46bd      	mov	sp, r7
 801415e:	b002      	add	sp, #8
 8014160:	bd80      	pop	{r7, pc}
 8014162:	46c0      	nop			; (mov r8, r8)
 8014164:	200017dc 	.word	0x200017dc

08014168 <ip4addr_ntoa_r>:
 * @return either pointer to buf which now holds the ASCII
 *         representation of addr or NULL if buf was too small
 */
char *
ip4addr_ntoa_r(const ip4_addr_t *addr, char *buf, int buflen)
{
 8014168:	b5b0      	push	{r4, r5, r7, lr}
 801416a:	b08c      	sub	sp, #48	; 0x30
 801416c:	af00      	add	r7, sp, #0
 801416e:	60f8      	str	r0, [r7, #12]
 8014170:	60b9      	str	r1, [r7, #8]
 8014172:	607a      	str	r2, [r7, #4]
  char *rp;
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;
  int len = 0;
 8014174:	2300      	movs	r3, #0
 8014176:	623b      	str	r3, [r7, #32]

  s_addr = ip4_addr_get_u32(addr);
 8014178:	68fb      	ldr	r3, [r7, #12]
 801417a:	681b      	ldr	r3, [r3, #0]
 801417c:	61bb      	str	r3, [r7, #24]

  rp = buf;
 801417e:	68bb      	ldr	r3, [r7, #8]
 8014180:	62fb      	str	r3, [r7, #44]	; 0x2c
  ap = (u8_t *)&s_addr;
 8014182:	2318      	movs	r3, #24
 8014184:	18fb      	adds	r3, r7, r3
 8014186:	62bb      	str	r3, [r7, #40]	; 0x28
  for (n = 0; n < 4; n++) {
 8014188:	2327      	movs	r3, #39	; 0x27
 801418a:	18fb      	adds	r3, r7, r3
 801418c:	2200      	movs	r2, #0
 801418e:	701a      	strb	r2, [r3, #0]
 8014190:	e05a      	b.n	8014248 <ip4addr_ntoa_r+0xe0>
    i = 0;
 8014192:	2326      	movs	r3, #38	; 0x26
 8014194:	18fb      	adds	r3, r7, r3
 8014196:	2200      	movs	r2, #0
 8014198:	701a      	strb	r2, [r3, #0]
    do {
      rem = *ap % (u8_t)10;
 801419a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801419c:	781b      	ldrb	r3, [r3, #0]
 801419e:	251f      	movs	r5, #31
 80141a0:	197c      	adds	r4, r7, r5
 80141a2:	210a      	movs	r1, #10
 80141a4:	0018      	movs	r0, r3
 80141a6:	f7ec f847 	bl	8000238 <__aeabi_uidivmod>
 80141aa:	000b      	movs	r3, r1
 80141ac:	7023      	strb	r3, [r4, #0]
      *ap /= (u8_t)10;
 80141ae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80141b0:	781b      	ldrb	r3, [r3, #0]
 80141b2:	210a      	movs	r1, #10
 80141b4:	0018      	movs	r0, r3
 80141b6:	f7eb ffb9 	bl	800012c <__udivsi3>
 80141ba:	0003      	movs	r3, r0
 80141bc:	b2da      	uxtb	r2, r3
 80141be:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80141c0:	701a      	strb	r2, [r3, #0]
      inv[i++] = (char)('0' + rem);
 80141c2:	2226      	movs	r2, #38	; 0x26
 80141c4:	18bb      	adds	r3, r7, r2
 80141c6:	781b      	ldrb	r3, [r3, #0]
 80141c8:	18ba      	adds	r2, r7, r2
 80141ca:	1c59      	adds	r1, r3, #1
 80141cc:	7011      	strb	r1, [r2, #0]
 80141ce:	001a      	movs	r2, r3
 80141d0:	197b      	adds	r3, r7, r5
 80141d2:	781b      	ldrb	r3, [r3, #0]
 80141d4:	3330      	adds	r3, #48	; 0x30
 80141d6:	b2d9      	uxtb	r1, r3
 80141d8:	2314      	movs	r3, #20
 80141da:	18fb      	adds	r3, r7, r3
 80141dc:	5499      	strb	r1, [r3, r2]
    } while (*ap);
 80141de:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80141e0:	781b      	ldrb	r3, [r3, #0]
 80141e2:	2b00      	cmp	r3, #0
 80141e4:	d1d9      	bne.n	801419a <ip4addr_ntoa_r+0x32>
    while (i--) {
 80141e6:	e011      	b.n	801420c <ip4addr_ntoa_r+0xa4>
      if (len++ >= buflen) {
 80141e8:	6a3b      	ldr	r3, [r7, #32]
 80141ea:	1c5a      	adds	r2, r3, #1
 80141ec:	623a      	str	r2, [r7, #32]
 80141ee:	687a      	ldr	r2, [r7, #4]
 80141f0:	429a      	cmp	r2, r3
 80141f2:	dc01      	bgt.n	80141f8 <ip4addr_ntoa_r+0x90>
        return NULL;
 80141f4:	2300      	movs	r3, #0
 80141f6:	e033      	b.n	8014260 <ip4addr_ntoa_r+0xf8>
      }
      *rp++ = inv[i];
 80141f8:	2326      	movs	r3, #38	; 0x26
 80141fa:	18fb      	adds	r3, r7, r3
 80141fc:	781a      	ldrb	r2, [r3, #0]
 80141fe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014200:	1c59      	adds	r1, r3, #1
 8014202:	62f9      	str	r1, [r7, #44]	; 0x2c
 8014204:	2114      	movs	r1, #20
 8014206:	1879      	adds	r1, r7, r1
 8014208:	5c8a      	ldrb	r2, [r1, r2]
 801420a:	701a      	strb	r2, [r3, #0]
    while (i--) {
 801420c:	2226      	movs	r2, #38	; 0x26
 801420e:	18bb      	adds	r3, r7, r2
 8014210:	781b      	ldrb	r3, [r3, #0]
 8014212:	18ba      	adds	r2, r7, r2
 8014214:	1e59      	subs	r1, r3, #1
 8014216:	7011      	strb	r1, [r2, #0]
 8014218:	2b00      	cmp	r3, #0
 801421a:	d1e5      	bne.n	80141e8 <ip4addr_ntoa_r+0x80>
    }
    if (len++ >= buflen) {
 801421c:	6a3b      	ldr	r3, [r7, #32]
 801421e:	1c5a      	adds	r2, r3, #1
 8014220:	623a      	str	r2, [r7, #32]
 8014222:	687a      	ldr	r2, [r7, #4]
 8014224:	429a      	cmp	r2, r3
 8014226:	dc01      	bgt.n	801422c <ip4addr_ntoa_r+0xc4>
      return NULL;
 8014228:	2300      	movs	r3, #0
 801422a:	e019      	b.n	8014260 <ip4addr_ntoa_r+0xf8>
    }
    *rp++ = '.';
 801422c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801422e:	1c5a      	adds	r2, r3, #1
 8014230:	62fa      	str	r2, [r7, #44]	; 0x2c
 8014232:	222e      	movs	r2, #46	; 0x2e
 8014234:	701a      	strb	r2, [r3, #0]
    ap++;
 8014236:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014238:	3301      	adds	r3, #1
 801423a:	62bb      	str	r3, [r7, #40]	; 0x28
  for (n = 0; n < 4; n++) {
 801423c:	2127      	movs	r1, #39	; 0x27
 801423e:	187b      	adds	r3, r7, r1
 8014240:	781a      	ldrb	r2, [r3, #0]
 8014242:	187b      	adds	r3, r7, r1
 8014244:	3201      	adds	r2, #1
 8014246:	701a      	strb	r2, [r3, #0]
 8014248:	2327      	movs	r3, #39	; 0x27
 801424a:	18fb      	adds	r3, r7, r3
 801424c:	781b      	ldrb	r3, [r3, #0]
 801424e:	2b03      	cmp	r3, #3
 8014250:	d99f      	bls.n	8014192 <ip4addr_ntoa_r+0x2a>
  }
  *--rp = 0;
 8014252:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014254:	3b01      	subs	r3, #1
 8014256:	62fb      	str	r3, [r7, #44]	; 0x2c
 8014258:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801425a:	2200      	movs	r2, #0
 801425c:	701a      	strb	r2, [r3, #0]
  return buf;
 801425e:	68bb      	ldr	r3, [r7, #8]
}
 8014260:	0018      	movs	r0, r3
 8014262:	46bd      	mov	sp, r7
 8014264:	b00c      	add	sp, #48	; 0x30
 8014266:	bdb0      	pop	{r4, r5, r7, pc}

08014268 <link_required>:
#endif

/*
 * An Open on LCP has requested a change from Dead to Establish phase.
 */
void link_required(ppp_pcb *pcb) {
 8014268:	b580      	push	{r7, lr}
 801426a:	b082      	sub	sp, #8
 801426c:	af00      	add	r7, sp, #0
 801426e:	6078      	str	r0, [r7, #4]
    LWIP_UNUSED_ARG(pcb);
}
 8014270:	46c0      	nop			; (mov r8, r8)
 8014272:	46bd      	mov	sp, r7
 8014274:	b002      	add	sp, #8
 8014276:	bd80      	pop	{r7, pc}

08014278 <link_terminated>:

/*
 * LCP has terminated the link; go to the Dead phase and take the
 * physical layer down.
 */
void link_terminated(ppp_pcb *pcb) {
 8014278:	b580      	push	{r7, lr}
 801427a:	b082      	sub	sp, #8
 801427c:	af00      	add	r7, sp, #0
 801427e:	6078      	str	r0, [r7, #4]
    if (pcb->phase == PPP_PHASE_DEAD
 8014280:	687b      	ldr	r3, [r7, #4]
 8014282:	2224      	movs	r2, #36	; 0x24
 8014284:	5c9b      	ldrb	r3, [r3, r2]
 8014286:	2b00      	cmp	r3, #0
 8014288:	d011      	beq.n	80142ae <link_terminated+0x36>
#ifdef HAVE_MULTILINK
    || pcb->phase == PPP_PHASE_MASTER
#endif /* HAVE_MULTILINK */
    )
	return;
    new_phase(pcb, PPP_PHASE_DISCONNECT);
 801428a:	687b      	ldr	r3, [r7, #4]
 801428c:	210c      	movs	r1, #12
 801428e:	0018      	movs	r0, r3
 8014290:	f006 f813 	bl	801a2ba <new_phase>
    }
    session_end(devnam);
#endif /* UNUSED */

    if (!doing_multilink) {
	ppp_notice("Connection terminated.");
 8014294:	4b08      	ldr	r3, [pc, #32]	; (80142b8 <link_terminated+0x40>)
 8014296:	0018      	movs	r0, r3
 8014298:	f007 fae1 	bl	801b85e <ppp_notice>
	print_link_stats();
#endif /* PPP_STATS_SUPPORT */
    } else
	ppp_notice("Link terminated.");

    lcp_lowerdown(pcb);
 801429c:	687b      	ldr	r3, [r7, #4]
 801429e:	0018      	movs	r0, r3
 80142a0:	f003 fcfc 	bl	8017c9c <lcp_lowerdown>

    ppp_link_terminated(pcb);
 80142a4:	687b      	ldr	r3, [r7, #4]
 80142a6:	0018      	movs	r0, r3
 80142a8:	f005 fff7 	bl	801a29a <ppp_link_terminated>
 80142ac:	e000      	b.n	80142b0 <link_terminated+0x38>
	return;
 80142ae:	46c0      	nop			; (mov r8, r8)
	else
	    mp_bundle_terminated();
    } else
	new_phase(pcb, PPP_PHASE_DEAD);
#endif
}
 80142b0:	46bd      	mov	sp, r7
 80142b2:	b002      	add	sp, #8
 80142b4:	bd80      	pop	{r7, pc}
 80142b6:	46c0      	nop			; (mov r8, r8)
 80142b8:	080219c0 	.word	0x080219c0

080142bc <link_down>:

/*
 * LCP has gone down; it will either die or try to re-establish.
 */
void link_down(ppp_pcb *pcb) {
 80142bc:	b580      	push	{r7, lr}
 80142be:	b082      	sub	sp, #8
 80142c0:	af00      	add	r7, sp, #0
 80142c2:	6078      	str	r0, [r7, #4]
#if PPP_NOTIFY
    notify(link_down_notifier, 0);
#endif /* PPP_NOTIFY */

    if (!doing_multilink) {
	upper_layers_down(pcb);
 80142c4:	687b      	ldr	r3, [r7, #4]
 80142c6:	0018      	movs	r0, r3
 80142c8:	f000 f80e 	bl	80142e8 <upper_layers_down>
	if (pcb->phase != PPP_PHASE_DEAD
 80142cc:	687b      	ldr	r3, [r7, #4]
 80142ce:	2224      	movs	r2, #36	; 0x24
 80142d0:	5c9b      	ldrb	r3, [r3, r2]
 80142d2:	2b00      	cmp	r3, #0
 80142d4:	d004      	beq.n	80142e0 <link_down+0x24>
#ifdef HAVE_MULTILINK
	&& pcb->phase != PPP_PHASE_MASTER
#endif /* HAVE_MULTILINK */
	)
	    new_phase(pcb, PPP_PHASE_ESTABLISH);
 80142d6:	687b      	ldr	r3, [r7, #4]
 80142d8:	2106      	movs	r1, #6
 80142da:	0018      	movs	r0, r3
 80142dc:	f005 ffed 	bl	801a2ba <new_phase>
    }
    /* XXX if doing_multilink, should do something to stop
       network-layer traffic on the link */
}
 80142e0:	46c0      	nop			; (mov r8, r8)
 80142e2:	46bd      	mov	sp, r7
 80142e4:	b002      	add	sp, #8
 80142e6:	bd80      	pop	{r7, pc}

080142e8 <upper_layers_down>:

void upper_layers_down(ppp_pcb *pcb) {
 80142e8:	b580      	push	{r7, lr}
 80142ea:	b084      	sub	sp, #16
 80142ec:	af00      	add	r7, sp, #0
 80142ee:	6078      	str	r0, [r7, #4]
    int i;
    const struct protent *protp;

    for (i = 0; (protp = protocols[i]) != NULL; ++i) {
 80142f0:	2300      	movs	r3, #0
 80142f2:	60fb      	str	r3, [r7, #12]
 80142f4:	e01f      	b.n	8014336 <upper_layers_down+0x4e>
        if (protp->protocol != PPP_LCP && protp->lowerdown != NULL)
 80142f6:	68bb      	ldr	r3, [r7, #8]
 80142f8:	881b      	ldrh	r3, [r3, #0]
 80142fa:	4a19      	ldr	r2, [pc, #100]	; (8014360 <upper_layers_down+0x78>)
 80142fc:	4293      	cmp	r3, r2
 80142fe:	d008      	beq.n	8014312 <upper_layers_down+0x2a>
 8014300:	68bb      	ldr	r3, [r7, #8]
 8014302:	695b      	ldr	r3, [r3, #20]
 8014304:	2b00      	cmp	r3, #0
 8014306:	d004      	beq.n	8014312 <upper_layers_down+0x2a>
	    (*protp->lowerdown)(pcb);
 8014308:	68bb      	ldr	r3, [r7, #8]
 801430a:	695b      	ldr	r3, [r3, #20]
 801430c:	687a      	ldr	r2, [r7, #4]
 801430e:	0010      	movs	r0, r2
 8014310:	4798      	blx	r3
        if (protp->protocol < 0xC000 && protp->close != NULL)
 8014312:	68bb      	ldr	r3, [r7, #8]
 8014314:	881b      	ldrh	r3, [r3, #0]
 8014316:	4a13      	ldr	r2, [pc, #76]	; (8014364 <upper_layers_down+0x7c>)
 8014318:	4293      	cmp	r3, r2
 801431a:	d809      	bhi.n	8014330 <upper_layers_down+0x48>
 801431c:	68bb      	ldr	r3, [r7, #8]
 801431e:	69db      	ldr	r3, [r3, #28]
 8014320:	2b00      	cmp	r3, #0
 8014322:	d005      	beq.n	8014330 <upper_layers_down+0x48>
	    (*protp->close)(pcb, "LCP down");
 8014324:	68bb      	ldr	r3, [r7, #8]
 8014326:	69db      	ldr	r3, [r3, #28]
 8014328:	490f      	ldr	r1, [pc, #60]	; (8014368 <upper_layers_down+0x80>)
 801432a:	687a      	ldr	r2, [r7, #4]
 801432c:	0010      	movs	r0, r2
 801432e:	4798      	blx	r3
    for (i = 0; (protp = protocols[i]) != NULL; ++i) {
 8014330:	68fb      	ldr	r3, [r7, #12]
 8014332:	3301      	adds	r3, #1
 8014334:	60fb      	str	r3, [r7, #12]
 8014336:	4b0d      	ldr	r3, [pc, #52]	; (801436c <upper_layers_down+0x84>)
 8014338:	68fa      	ldr	r2, [r7, #12]
 801433a:	0092      	lsls	r2, r2, #2
 801433c:	58d3      	ldr	r3, [r2, r3]
 801433e:	60bb      	str	r3, [r7, #8]
 8014340:	68bb      	ldr	r3, [r7, #8]
 8014342:	2b00      	cmp	r3, #0
 8014344:	d1d7      	bne.n	80142f6 <upper_layers_down+0xe>
    }
    pcb->num_np_open = 0;
 8014346:	687b      	ldr	r3, [r7, #4]
 8014348:	22d8      	movs	r2, #216	; 0xd8
 801434a:	2100      	movs	r1, #0
 801434c:	5499      	strb	r1, [r3, r2]
    pcb->num_np_up = 0;
 801434e:	687b      	ldr	r3, [r7, #4]
 8014350:	22d9      	movs	r2, #217	; 0xd9
 8014352:	2100      	movs	r1, #0
 8014354:	5499      	strb	r1, [r3, r2]
}
 8014356:	46c0      	nop			; (mov r8, r8)
 8014358:	46bd      	mov	sp, r7
 801435a:	b004      	add	sp, #16
 801435c:	bd80      	pop	{r7, pc}
 801435e:	46c0      	nop			; (mov r8, r8)
 8014360:	0000c021 	.word	0x0000c021
 8014364:	0000bfff 	.word	0x0000bfff
 8014368:	080219d8 	.word	0x080219d8
 801436c:	08022af4 	.word	0x08022af4

08014370 <link_established>:

/*
 * The link is established.
 * Proceed to the Dead, Authenticate or Network phase as appropriate.
 */
void link_established(ppp_pcb *pcb) {
 8014370:	b580      	push	{r7, lr}
 8014372:	b084      	sub	sp, #16
 8014374:	af00      	add	r7, sp, #0
 8014376:	6078      	str	r0, [r7, #4]

    /*
     * Tell higher-level protocols that LCP is up.
     */
    if (!doing_multilink) {
	for (i = 0; (protp = protocols[i]) != NULL; ++i)
 8014378:	2300      	movs	r3, #0
 801437a:	60fb      	str	r3, [r7, #12]
 801437c:	e010      	b.n	80143a0 <link_established+0x30>
	    if (protp->protocol != PPP_LCP
 801437e:	68bb      	ldr	r3, [r7, #8]
 8014380:	881b      	ldrh	r3, [r3, #0]
 8014382:	4a0f      	ldr	r2, [pc, #60]	; (80143c0 <link_established+0x50>)
 8014384:	4293      	cmp	r3, r2
 8014386:	d008      	beq.n	801439a <link_established+0x2a>
		&& protp->lowerup != NULL)
 8014388:	68bb      	ldr	r3, [r7, #8]
 801438a:	691b      	ldr	r3, [r3, #16]
 801438c:	2b00      	cmp	r3, #0
 801438e:	d004      	beq.n	801439a <link_established+0x2a>
		(*protp->lowerup)(pcb);
 8014390:	68bb      	ldr	r3, [r7, #8]
 8014392:	691b      	ldr	r3, [r3, #16]
 8014394:	687a      	ldr	r2, [r7, #4]
 8014396:	0010      	movs	r0, r2
 8014398:	4798      	blx	r3
	for (i = 0; (protp = protocols[i]) != NULL; ++i)
 801439a:	68fb      	ldr	r3, [r7, #12]
 801439c:	3301      	adds	r3, #1
 801439e:	60fb      	str	r3, [r7, #12]
 80143a0:	4b08      	ldr	r3, [pc, #32]	; (80143c4 <link_established+0x54>)
 80143a2:	68fa      	ldr	r2, [r7, #12]
 80143a4:	0092      	lsls	r2, r2, #2
 80143a6:	58d3      	ldr	r3, [r2, r3]
 80143a8:	60bb      	str	r3, [r7, #8]
 80143aa:	68bb      	ldr	r3, [r7, #8]
 80143ac:	2b00      	cmp	r3, #0
 80143ae:	d1e6      	bne.n	801437e <link_established+0xe>
    pcb->auth_pending = auth;
    pcb->auth_done = 0;

    if (!auth)
#endif /* PPP_AUTH_SUPPORT */
	network_phase(pcb);
 80143b0:	687b      	ldr	r3, [r7, #4]
 80143b2:	0018      	movs	r0, r3
 80143b4:	f000 f808 	bl	80143c8 <network_phase>
}
 80143b8:	46c0      	nop			; (mov r8, r8)
 80143ba:	46bd      	mov	sp, r7
 80143bc:	b004      	add	sp, #16
 80143be:	bd80      	pop	{r7, pc}
 80143c0:	0000c021 	.word	0x0000c021
 80143c4:	08022af4 	.word	0x08022af4

080143c8 <network_phase>:

/*
 * Proceed to the network phase.
 */
static void network_phase(ppp_pcb *pcb) {
 80143c8:	b580      	push	{r7, lr}
 80143ca:	b082      	sub	sp, #8
 80143cc:	af00      	add	r7, sp, #0
 80143ce:	6078      	str	r0, [r7, #4]
	options_from_list(extra_options, 1);
	free_wordlist(extra_options);
	extra_options = 0;
    }
#endif /* PPP_OPTIONS */
    start_networks(pcb);
 80143d0:	687b      	ldr	r3, [r7, #4]
 80143d2:	0018      	movs	r0, r3
 80143d4:	f000 f804 	bl	80143e0 <start_networks>
}
 80143d8:	46c0      	nop			; (mov r8, r8)
 80143da:	46bd      	mov	sp, r7
 80143dc:	b002      	add	sp, #8
 80143de:	bd80      	pop	{r7, pc}

080143e0 <start_networks>:

void start_networks(ppp_pcb *pcb) {
 80143e0:	b580      	push	{r7, lr}
 80143e2:	b082      	sub	sp, #8
 80143e4:	af00      	add	r7, sp, #0
 80143e6:	6078      	str	r0, [r7, #4]
#if CCP_SUPPORT || ECP_SUPPORT
    int i;
    const struct protent *protp;
#endif /* CCP_SUPPORT || ECP_SUPPORT */

    new_phase(pcb, PPP_PHASE_NETWORK);
 80143e8:	687b      	ldr	r3, [r7, #4]
 80143ea:	2109      	movs	r1, #9
 80143ec:	0018      	movs	r0, r3
 80143ee:	f005 ff64 	bl	801a2ba <new_phase>
#endif /* ECP_SUPPORT */
#if MPPE_SUPPORT
        && !pcb->ccp_gotoptions.mppe
#endif /* MPPE_SUPPORT */
        )
	continue_networks(pcb);
 80143f2:	687b      	ldr	r3, [r7, #4]
 80143f4:	0018      	movs	r0, r3
 80143f6:	f000 f805 	bl	8014404 <continue_networks>
}
 80143fa:	46c0      	nop			; (mov r8, r8)
 80143fc:	46bd      	mov	sp, r7
 80143fe:	b002      	add	sp, #8
 8014400:	bd80      	pop	{r7, pc}
	...

08014404 <continue_networks>:

void continue_networks(ppp_pcb *pcb) {
 8014404:	b580      	push	{r7, lr}
 8014406:	b084      	sub	sp, #16
 8014408:	af00      	add	r7, sp, #0
 801440a:	6078      	str	r0, [r7, #4]
    const struct protent *protp;

    /*
     * Start the "real" network protocols.
     */
    for (i = 0; (protp = protocols[i]) != NULL; ++i)
 801440c:	2300      	movs	r3, #0
 801440e:	60fb      	str	r3, [r7, #12]
 8014410:	e018      	b.n	8014444 <continue_networks+0x40>
	if (protp->protocol < 0xC000
 8014412:	68bb      	ldr	r3, [r7, #8]
 8014414:	881b      	ldrh	r3, [r3, #0]
 8014416:	4a17      	ldr	r2, [pc, #92]	; (8014474 <continue_networks+0x70>)
 8014418:	4293      	cmp	r3, r2
 801441a:	d810      	bhi.n	801443e <continue_networks+0x3a>
	    && protp->protocol != PPP_CCP
#endif /* CCP_SUPPORT */
#if ECP_SUPPORT
	    && protp->protocol != PPP_ECP
#endif /* ECP_SUPPORT */
	    && protp->open != NULL) {
 801441c:	68bb      	ldr	r3, [r7, #8]
 801441e:	699b      	ldr	r3, [r3, #24]
 8014420:	2b00      	cmp	r3, #0
 8014422:	d00c      	beq.n	801443e <continue_networks+0x3a>
	    (*protp->open)(pcb);
 8014424:	68bb      	ldr	r3, [r7, #8]
 8014426:	699b      	ldr	r3, [r3, #24]
 8014428:	687a      	ldr	r2, [r7, #4]
 801442a:	0010      	movs	r0, r2
 801442c:	4798      	blx	r3
	    ++pcb->num_np_open;
 801442e:	687b      	ldr	r3, [r7, #4]
 8014430:	22d8      	movs	r2, #216	; 0xd8
 8014432:	5c9b      	ldrb	r3, [r3, r2]
 8014434:	3301      	adds	r3, #1
 8014436:	b2d9      	uxtb	r1, r3
 8014438:	687b      	ldr	r3, [r7, #4]
 801443a:	22d8      	movs	r2, #216	; 0xd8
 801443c:	5499      	strb	r1, [r3, r2]
    for (i = 0; (protp = protocols[i]) != NULL; ++i)
 801443e:	68fb      	ldr	r3, [r7, #12]
 8014440:	3301      	adds	r3, #1
 8014442:	60fb      	str	r3, [r7, #12]
 8014444:	4b0c      	ldr	r3, [pc, #48]	; (8014478 <continue_networks+0x74>)
 8014446:	68fa      	ldr	r2, [r7, #12]
 8014448:	0092      	lsls	r2, r2, #2
 801444a:	58d3      	ldr	r3, [r2, r3]
 801444c:	60bb      	str	r3, [r7, #8]
 801444e:	68bb      	ldr	r3, [r7, #8]
 8014450:	2b00      	cmp	r3, #0
 8014452:	d1de      	bne.n	8014412 <continue_networks+0xe>
	}

    if (pcb->num_np_open == 0)
 8014454:	687b      	ldr	r3, [r7, #4]
 8014456:	22d8      	movs	r2, #216	; 0xd8
 8014458:	5c9b      	ldrb	r3, [r3, r2]
 801445a:	2b00      	cmp	r3, #0
 801445c:	d105      	bne.n	801446a <continue_networks+0x66>
	/* nothing to do */
	lcp_close(pcb, "No network protocols running");
 801445e:	4a07      	ldr	r2, [pc, #28]	; (801447c <continue_networks+0x78>)
 8014460:	687b      	ldr	r3, [r7, #4]
 8014462:	0011      	movs	r1, r2
 8014464:	0018      	movs	r0, r3
 8014466:	f003 fb75 	bl	8017b54 <lcp_close>
}
 801446a:	46c0      	nop			; (mov r8, r8)
 801446c:	46bd      	mov	sp, r7
 801446e:	b004      	add	sp, #16
 8014470:	bd80      	pop	{r7, pc}
 8014472:	46c0      	nop			; (mov r8, r8)
 8014474:	0000bfff 	.word	0x0000bfff
 8014478:	08022af4 	.word	0x08022af4
 801447c:	080219e4 	.word	0x080219e4

08014480 <np_up>:


/*
 * np_up - a network protocol has come up.
 */
void np_up(ppp_pcb *pcb, int proto) {
 8014480:	b580      	push	{r7, lr}
 8014482:	b082      	sub	sp, #8
 8014484:	af00      	add	r7, sp, #0
 8014486:	6078      	str	r0, [r7, #4]
 8014488:	6039      	str	r1, [r7, #0]
#if PPP_IDLETIMELIMIT
    int tlim;
#endif /* PPP_IDLETIMELIMIT */
    LWIP_UNUSED_ARG(proto);

    if (pcb->num_np_up == 0) {
 801448a:	687b      	ldr	r3, [r7, #4]
 801448c:	22d9      	movs	r2, #217	; 0xd9
 801448e:	5c9b      	ldrb	r3, [r3, r2]
 8014490:	2b00      	cmp	r3, #0
 8014492:	d104      	bne.n	801449e <np_up+0x1e>
	/*
	 * At this point we consider that the link has come up successfully.
	 */
	new_phase(pcb, PPP_PHASE_RUNNING);
 8014494:	687b      	ldr	r3, [r7, #4]
 8014496:	210a      	movs	r1, #10
 8014498:	0018      	movs	r0, r3
 801449a:	f005 ff0e 	bl	801a2ba <new_phase>
	 */
	if (updetach && !nodetach)
	    detach();
#endif /* Unused */
    }
    ++pcb->num_np_up;
 801449e:	687b      	ldr	r3, [r7, #4]
 80144a0:	22d9      	movs	r2, #217	; 0xd9
 80144a2:	5c9b      	ldrb	r3, [r3, r2]
 80144a4:	3301      	adds	r3, #1
 80144a6:	b2d9      	uxtb	r1, r3
 80144a8:	687b      	ldr	r3, [r7, #4]
 80144aa:	22d9      	movs	r2, #217	; 0xd9
 80144ac:	5499      	strb	r1, [r3, r2]
}
 80144ae:	46c0      	nop			; (mov r8, r8)
 80144b0:	46bd      	mov	sp, r7
 80144b2:	b002      	add	sp, #8
 80144b4:	bd80      	pop	{r7, pc}

080144b6 <np_down>:

/*
 * np_down - a network protocol has gone down.
 */
void np_down(ppp_pcb *pcb, int proto) {
 80144b6:	b580      	push	{r7, lr}
 80144b8:	b082      	sub	sp, #8
 80144ba:	af00      	add	r7, sp, #0
 80144bc:	6078      	str	r0, [r7, #4]
 80144be:	6039      	str	r1, [r7, #0]
    LWIP_UNUSED_ARG(proto);
    if (--pcb->num_np_up == 0) {
 80144c0:	687b      	ldr	r3, [r7, #4]
 80144c2:	22d9      	movs	r2, #217	; 0xd9
 80144c4:	5c9b      	ldrb	r3, [r3, r2]
 80144c6:	3b01      	subs	r3, #1
 80144c8:	b2d9      	uxtb	r1, r3
 80144ca:	687b      	ldr	r3, [r7, #4]
 80144cc:	22d9      	movs	r2, #217	; 0xd9
 80144ce:	5499      	strb	r1, [r3, r2]
 80144d0:	687b      	ldr	r3, [r7, #4]
 80144d2:	22d9      	movs	r2, #217	; 0xd9
 80144d4:	5c9b      	ldrb	r3, [r3, r2]
 80144d6:	2b00      	cmp	r3, #0
 80144d8:	d104      	bne.n	80144e4 <np_down+0x2e>
	UNTIMEOUT(connect_time_expired, NULL);
#endif /* PPP_MAXCONNECT */
#ifdef MAXOCTETS
	UNTIMEOUT(check_maxoctets, NULL);
#endif
	new_phase(pcb, PPP_PHASE_NETWORK);
 80144da:	687b      	ldr	r3, [r7, #4]
 80144dc:	2109      	movs	r1, #9
 80144de:	0018      	movs	r0, r3
 80144e0:	f005 feeb 	bl	801a2ba <new_phase>
    }
}
 80144e4:	46c0      	nop			; (mov r8, r8)
 80144e6:	46bd      	mov	sp, r7
 80144e8:	b002      	add	sp, #8
 80144ea:	bd80      	pop	{r7, pc}

080144ec <np_finished>:

/*
 * np_finished - a network protocol has finished using the link.
 */
void np_finished(ppp_pcb *pcb, int proto) {
 80144ec:	b580      	push	{r7, lr}
 80144ee:	b082      	sub	sp, #8
 80144f0:	af00      	add	r7, sp, #0
 80144f2:	6078      	str	r0, [r7, #4]
 80144f4:	6039      	str	r1, [r7, #0]
    LWIP_UNUSED_ARG(proto);
    if (--pcb->num_np_open <= 0) {
 80144f6:	687b      	ldr	r3, [r7, #4]
 80144f8:	22d8      	movs	r2, #216	; 0xd8
 80144fa:	5c9b      	ldrb	r3, [r3, r2]
 80144fc:	3b01      	subs	r3, #1
 80144fe:	b2d9      	uxtb	r1, r3
 8014500:	687b      	ldr	r3, [r7, #4]
 8014502:	22d8      	movs	r2, #216	; 0xd8
 8014504:	5499      	strb	r1, [r3, r2]
 8014506:	687b      	ldr	r3, [r7, #4]
 8014508:	22d8      	movs	r2, #216	; 0xd8
 801450a:	5c9b      	ldrb	r3, [r3, r2]
 801450c:	2b00      	cmp	r3, #0
 801450e:	d105      	bne.n	801451c <np_finished+0x30>
	/* no further use for the link: shut up shop. */
	lcp_close(pcb, "No network protocols running");
 8014510:	4a04      	ldr	r2, [pc, #16]	; (8014524 <np_finished+0x38>)
 8014512:	687b      	ldr	r3, [r7, #4]
 8014514:	0011      	movs	r1, r2
 8014516:	0018      	movs	r0, r3
 8014518:	f003 fb1c 	bl	8017b54 <lcp_close>
    }
}
 801451c:	46c0      	nop			; (mov r8, r8)
 801451e:	46bd      	mov	sp, r7
 8014520:	b002      	add	sp, #8
 8014522:	bd80      	pop	{r7, pc}
 8014524:	080219e4 	.word	0x080219e4

08014528 <fsm_init>:
/*
 * fsm_init - Initialize fsm.
 *
 * Initialize fsm state.
 */
void fsm_init(fsm *f) {
 8014528:	b580      	push	{r7, lr}
 801452a:	b084      	sub	sp, #16
 801452c:	af00      	add	r7, sp, #0
 801452e:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8014530:	687b      	ldr	r3, [r7, #4]
 8014532:	681b      	ldr	r3, [r3, #0]
 8014534:	60fb      	str	r3, [r7, #12]
    f->state = PPP_FSM_INITIAL;
 8014536:	687b      	ldr	r3, [r7, #4]
 8014538:	2200      	movs	r2, #0
 801453a:	741a      	strb	r2, [r3, #16]
    f->flags = 0;
 801453c:	687b      	ldr	r3, [r7, #4]
 801453e:	2200      	movs	r2, #0
 8014540:	745a      	strb	r2, [r3, #17]
    f->id = 0;				/* XXX Start with random id? */
 8014542:	687b      	ldr	r3, [r7, #4]
 8014544:	2200      	movs	r2, #0
 8014546:	749a      	strb	r2, [r3, #18]
    f->maxnakloops = pcb->settings.fsm_max_nak_loops;
 8014548:	68fb      	ldr	r3, [r7, #12]
 801454a:	79da      	ldrb	r2, [r3, #7]
 801454c:	687b      	ldr	r3, [r7, #4]
 801454e:	75da      	strb	r2, [r3, #23]
    f->term_reason_len = 0;
 8014550:	687b      	ldr	r3, [r7, #4]
 8014552:	2200      	movs	r2, #0
 8014554:	761a      	strb	r2, [r3, #24]
}
 8014556:	46c0      	nop			; (mov r8, r8)
 8014558:	46bd      	mov	sp, r7
 801455a:	b004      	add	sp, #16
 801455c:	bd80      	pop	{r7, pc}

0801455e <fsm_lowerup>:


/*
 * fsm_lowerup - The lower layer is up.
 */
void fsm_lowerup(fsm *f) {
 801455e:	b580      	push	{r7, lr}
 8014560:	b082      	sub	sp, #8
 8014562:	af00      	add	r7, sp, #0
 8014564:	6078      	str	r0, [r7, #4]
    switch( f->state ){
 8014566:	687b      	ldr	r3, [r7, #4]
 8014568:	7c1b      	ldrb	r3, [r3, #16]
 801456a:	2b00      	cmp	r3, #0
 801456c:	d002      	beq.n	8014574 <fsm_lowerup+0x16>
 801456e:	2b01      	cmp	r3, #1
 8014570:	d004      	beq.n	801457c <fsm_lowerup+0x1e>

    default:
	FSMDEBUG(("%s: Up event in state %d!", PROTO_NAME(f), f->state));
	/* no break */
    }
}
 8014572:	e016      	b.n	80145a2 <fsm_lowerup+0x44>
	f->state = PPP_FSM_CLOSED;
 8014574:	687b      	ldr	r3, [r7, #4]
 8014576:	2202      	movs	r2, #2
 8014578:	741a      	strb	r2, [r3, #16]
	break;
 801457a:	e012      	b.n	80145a2 <fsm_lowerup+0x44>
	if( f->flags & OPT_SILENT )
 801457c:	687b      	ldr	r3, [r7, #4]
 801457e:	7c5b      	ldrb	r3, [r3, #17]
 8014580:	001a      	movs	r2, r3
 8014582:	2304      	movs	r3, #4
 8014584:	4013      	ands	r3, r2
 8014586:	d003      	beq.n	8014590 <fsm_lowerup+0x32>
	    f->state = PPP_FSM_STOPPED;
 8014588:	687b      	ldr	r3, [r7, #4]
 801458a:	2203      	movs	r2, #3
 801458c:	741a      	strb	r2, [r3, #16]
	break;
 801458e:	e007      	b.n	80145a0 <fsm_lowerup+0x42>
	    fsm_sconfreq(f, 0);
 8014590:	687b      	ldr	r3, [r7, #4]
 8014592:	2100      	movs	r1, #0
 8014594:	0018      	movs	r0, r3
 8014596:	f000 fded 	bl	8015174 <fsm_sconfreq>
	    f->state = PPP_FSM_REQSENT;
 801459a:	687b      	ldr	r3, [r7, #4]
 801459c:	2206      	movs	r2, #6
 801459e:	741a      	strb	r2, [r3, #16]
	break;
 80145a0:	46c0      	nop			; (mov r8, r8)
}
 80145a2:	46c0      	nop			; (mov r8, r8)
 80145a4:	46bd      	mov	sp, r7
 80145a6:	b002      	add	sp, #8
 80145a8:	bd80      	pop	{r7, pc}
	...

080145ac <fsm_lowerdown>:
/*
 * fsm_lowerdown - The lower layer is down.
 *
 * Cancel all timeouts and inform upper layers.
 */
void fsm_lowerdown(fsm *f) {
 80145ac:	b580      	push	{r7, lr}
 80145ae:	b082      	sub	sp, #8
 80145b0:	af00      	add	r7, sp, #0
 80145b2:	6078      	str	r0, [r7, #4]
    switch( f->state ){
 80145b4:	687b      	ldr	r3, [r7, #4]
 80145b6:	7c1b      	ldrb	r3, [r3, #16]
 80145b8:	2b09      	cmp	r3, #9
 80145ba:	d83b      	bhi.n	8014634 <fsm_lowerdown+0x88>
 80145bc:	009a      	lsls	r2, r3, #2
 80145be:	4b1f      	ldr	r3, [pc, #124]	; (801463c <fsm_lowerdown+0x90>)
 80145c0:	18d3      	adds	r3, r2, r3
 80145c2:	681b      	ldr	r3, [r3, #0]
 80145c4:	469f      	mov	pc, r3
    case PPP_FSM_CLOSED:
	f->state = PPP_FSM_INITIAL;
 80145c6:	687b      	ldr	r3, [r7, #4]
 80145c8:	2200      	movs	r2, #0
 80145ca:	741a      	strb	r2, [r3, #16]
	break;
 80145cc:	e032      	b.n	8014634 <fsm_lowerdown+0x88>

    case PPP_FSM_STOPPED:
	f->state = PPP_FSM_STARTING;
 80145ce:	687b      	ldr	r3, [r7, #4]
 80145d0:	2201      	movs	r2, #1
 80145d2:	741a      	strb	r2, [r3, #16]
	if( f->callbacks->starting )
 80145d4:	687b      	ldr	r3, [r7, #4]
 80145d6:	685b      	ldr	r3, [r3, #4]
 80145d8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80145da:	2b00      	cmp	r3, #0
 80145dc:	d029      	beq.n	8014632 <fsm_lowerdown+0x86>
	    (*f->callbacks->starting)(f);
 80145de:	687b      	ldr	r3, [r7, #4]
 80145e0:	685b      	ldr	r3, [r3, #4]
 80145e2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80145e4:	687a      	ldr	r2, [r7, #4]
 80145e6:	0010      	movs	r0, r2
 80145e8:	4798      	blx	r3
	break;
 80145ea:	e022      	b.n	8014632 <fsm_lowerdown+0x86>

    case PPP_FSM_CLOSING:
	f->state = PPP_FSM_INITIAL;
 80145ec:	687b      	ldr	r3, [r7, #4]
 80145ee:	2200      	movs	r2, #0
 80145f0:	741a      	strb	r2, [r3, #16]
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 80145f2:	687a      	ldr	r2, [r7, #4]
 80145f4:	4b12      	ldr	r3, [pc, #72]	; (8014640 <fsm_lowerdown+0x94>)
 80145f6:	0011      	movs	r1, r2
 80145f8:	0018      	movs	r0, r3
 80145fa:	f7fd fefb 	bl	80123f4 <sys_untimeout>
	break;
 80145fe:	e019      	b.n	8014634 <fsm_lowerdown+0x88>

    case PPP_FSM_STOPPING:
    case PPP_FSM_REQSENT:
    case PPP_FSM_ACKRCVD:
    case PPP_FSM_ACKSENT:
	f->state = PPP_FSM_STARTING;
 8014600:	687b      	ldr	r3, [r7, #4]
 8014602:	2201      	movs	r2, #1
 8014604:	741a      	strb	r2, [r3, #16]
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 8014606:	687a      	ldr	r2, [r7, #4]
 8014608:	4b0d      	ldr	r3, [pc, #52]	; (8014640 <fsm_lowerdown+0x94>)
 801460a:	0011      	movs	r1, r2
 801460c:	0018      	movs	r0, r3
 801460e:	f7fd fef1 	bl	80123f4 <sys_untimeout>
	break;
 8014612:	e00f      	b.n	8014634 <fsm_lowerdown+0x88>

    case PPP_FSM_OPENED:
	if( f->callbacks->down )
 8014614:	687b      	ldr	r3, [r7, #4]
 8014616:	685b      	ldr	r3, [r3, #4]
 8014618:	6a1b      	ldr	r3, [r3, #32]
 801461a:	2b00      	cmp	r3, #0
 801461c:	d005      	beq.n	801462a <fsm_lowerdown+0x7e>
	    (*f->callbacks->down)(f);
 801461e:	687b      	ldr	r3, [r7, #4]
 8014620:	685b      	ldr	r3, [r3, #4]
 8014622:	6a1b      	ldr	r3, [r3, #32]
 8014624:	687a      	ldr	r2, [r7, #4]
 8014626:	0010      	movs	r0, r2
 8014628:	4798      	blx	r3
	f->state = PPP_FSM_STARTING;
 801462a:	687b      	ldr	r3, [r7, #4]
 801462c:	2201      	movs	r2, #1
 801462e:	741a      	strb	r2, [r3, #16]
	break;
 8014630:	e000      	b.n	8014634 <fsm_lowerdown+0x88>
	break;
 8014632:	46c0      	nop			; (mov r8, r8)

    default:
	FSMDEBUG(("%s: Down event in state %d!", PROTO_NAME(f), f->state));
	/* no break */
    }
}
 8014634:	46c0      	nop			; (mov r8, r8)
 8014636:	46bd      	mov	sp, r7
 8014638:	b002      	add	sp, #8
 801463a:	bd80      	pop	{r7, pc}
 801463c:	080228a4 	.word	0x080228a4
 8014640:	08014851 	.word	0x08014851

08014644 <fsm_open>:


/*
 * fsm_open - Link is allowed to come up.
 */
void fsm_open(fsm *f) {
 8014644:	b580      	push	{r7, lr}
 8014646:	b082      	sub	sp, #8
 8014648:	af00      	add	r7, sp, #0
 801464a:	6078      	str	r0, [r7, #4]
    switch( f->state ){
 801464c:	687b      	ldr	r3, [r7, #4]
 801464e:	7c1b      	ldrb	r3, [r3, #16]
 8014650:	2b09      	cmp	r3, #9
 8014652:	d838      	bhi.n	80146c6 <fsm_open+0x82>
 8014654:	009a      	lsls	r2, r3, #2
 8014656:	4b20      	ldr	r3, [pc, #128]	; (80146d8 <fsm_open+0x94>)
 8014658:	18d3      	adds	r3, r2, r3
 801465a:	681b      	ldr	r3, [r3, #0]
 801465c:	469f      	mov	pc, r3
    case PPP_FSM_INITIAL:
	f->state = PPP_FSM_STARTING;
 801465e:	687b      	ldr	r3, [r7, #4]
 8014660:	2201      	movs	r2, #1
 8014662:	741a      	strb	r2, [r3, #16]
	if( f->callbacks->starting )
 8014664:	687b      	ldr	r3, [r7, #4]
 8014666:	685b      	ldr	r3, [r3, #4]
 8014668:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801466a:	2b00      	cmp	r3, #0
 801466c:	d02d      	beq.n	80146ca <fsm_open+0x86>
	    (*f->callbacks->starting)(f);
 801466e:	687b      	ldr	r3, [r7, #4]
 8014670:	685b      	ldr	r3, [r3, #4]
 8014672:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8014674:	687a      	ldr	r2, [r7, #4]
 8014676:	0010      	movs	r0, r2
 8014678:	4798      	blx	r3
	break;
 801467a:	e026      	b.n	80146ca <fsm_open+0x86>

    case PPP_FSM_CLOSED:
	if( f->flags & OPT_SILENT )
 801467c:	687b      	ldr	r3, [r7, #4]
 801467e:	7c5b      	ldrb	r3, [r3, #17]
 8014680:	001a      	movs	r2, r3
 8014682:	2304      	movs	r3, #4
 8014684:	4013      	ands	r3, r2
 8014686:	d003      	beq.n	8014690 <fsm_open+0x4c>
	    f->state = PPP_FSM_STOPPED;
 8014688:	687b      	ldr	r3, [r7, #4]
 801468a:	2203      	movs	r2, #3
 801468c:	741a      	strb	r2, [r3, #16]
	else {
	    /* Send an initial configure-request */
	    fsm_sconfreq(f, 0);
	    f->state = PPP_FSM_REQSENT;
	}
	break;
 801468e:	e01f      	b.n	80146d0 <fsm_open+0x8c>
	    fsm_sconfreq(f, 0);
 8014690:	687b      	ldr	r3, [r7, #4]
 8014692:	2100      	movs	r1, #0
 8014694:	0018      	movs	r0, r3
 8014696:	f000 fd6d 	bl	8015174 <fsm_sconfreq>
	    f->state = PPP_FSM_REQSENT;
 801469a:	687b      	ldr	r3, [r7, #4]
 801469c:	2206      	movs	r2, #6
 801469e:	741a      	strb	r2, [r3, #16]
	break;
 80146a0:	e016      	b.n	80146d0 <fsm_open+0x8c>

    case PPP_FSM_CLOSING:
	f->state = PPP_FSM_STOPPING;
 80146a2:	687b      	ldr	r3, [r7, #4]
 80146a4:	2205      	movs	r2, #5
 80146a6:	741a      	strb	r2, [r3, #16]
	/* fall through */
	/* no break */
    case PPP_FSM_STOPPED:
    case PPP_FSM_OPENED:
	if( f->flags & OPT_RESTART ){
 80146a8:	687b      	ldr	r3, [r7, #4]
 80146aa:	7c5b      	ldrb	r3, [r3, #17]
 80146ac:	001a      	movs	r2, r3
 80146ae:	2302      	movs	r3, #2
 80146b0:	4013      	ands	r3, r2
 80146b2:	d00c      	beq.n	80146ce <fsm_open+0x8a>
	    fsm_lowerdown(f);
 80146b4:	687b      	ldr	r3, [r7, #4]
 80146b6:	0018      	movs	r0, r3
 80146b8:	f7ff ff78 	bl	80145ac <fsm_lowerdown>
	    fsm_lowerup(f);
 80146bc:	687b      	ldr	r3, [r7, #4]
 80146be:	0018      	movs	r0, r3
 80146c0:	f7ff ff4d 	bl	801455e <fsm_lowerup>
	}
	break;
 80146c4:	e003      	b.n	80146ce <fsm_open+0x8a>
    default:
	break;
 80146c6:	46c0      	nop			; (mov r8, r8)
 80146c8:	e002      	b.n	80146d0 <fsm_open+0x8c>
	break;
 80146ca:	46c0      	nop			; (mov r8, r8)
 80146cc:	e000      	b.n	80146d0 <fsm_open+0x8c>
	break;
 80146ce:	46c0      	nop			; (mov r8, r8)
    }
}
 80146d0:	46c0      	nop			; (mov r8, r8)
 80146d2:	46bd      	mov	sp, r7
 80146d4:	b002      	add	sp, #8
 80146d6:	bd80      	pop	{r7, pc}
 80146d8:	080228cc 	.word	0x080228cc

080146dc <terminate_layer>:
 * terminate_layer - Start process of shutting down the FSM
 *
 * Cancel any timeout running, notify upper layers we're done, and
 * send a terminate-request message as configured.
 */
static void terminate_layer(fsm *f, int nextstate) {
 80146dc:	b580      	push	{r7, lr}
 80146de:	b086      	sub	sp, #24
 80146e0:	af02      	add	r7, sp, #8
 80146e2:	6078      	str	r0, [r7, #4]
 80146e4:	6039      	str	r1, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 80146e6:	687b      	ldr	r3, [r7, #4]
 80146e8:	681b      	ldr	r3, [r3, #0]
 80146ea:	60fb      	str	r3, [r7, #12]

    if( f->state != PPP_FSM_OPENED )
 80146ec:	687b      	ldr	r3, [r7, #4]
 80146ee:	7c1b      	ldrb	r3, [r3, #16]
 80146f0:	2b09      	cmp	r3, #9
 80146f2:	d006      	beq.n	8014702 <terminate_layer+0x26>
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 80146f4:	687a      	ldr	r2, [r7, #4]
 80146f6:	4b33      	ldr	r3, [pc, #204]	; (80147c4 <terminate_layer+0xe8>)
 80146f8:	0011      	movs	r1, r2
 80146fa:	0018      	movs	r0, r3
 80146fc:	f7fd fe7a 	bl	80123f4 <sys_untimeout>
 8014700:	e00a      	b.n	8014718 <terminate_layer+0x3c>
    else if( f->callbacks->down )
 8014702:	687b      	ldr	r3, [r7, #4]
 8014704:	685b      	ldr	r3, [r3, #4]
 8014706:	6a1b      	ldr	r3, [r3, #32]
 8014708:	2b00      	cmp	r3, #0
 801470a:	d005      	beq.n	8014718 <terminate_layer+0x3c>
	(*f->callbacks->down)(f);	/* Inform upper layers we're down */
 801470c:	687b      	ldr	r3, [r7, #4]
 801470e:	685b      	ldr	r3, [r3, #4]
 8014710:	6a1b      	ldr	r3, [r3, #32]
 8014712:	687a      	ldr	r2, [r7, #4]
 8014714:	0010      	movs	r0, r2
 8014716:	4798      	blx	r3

    /* Init restart counter and send Terminate-Request */
    f->retransmits = pcb->settings.fsm_max_term_transmits;
 8014718:	68fb      	ldr	r3, [r7, #12]
 801471a:	799a      	ldrb	r2, [r3, #6]
 801471c:	687b      	ldr	r3, [r7, #4]
 801471e:	751a      	strb	r2, [r3, #20]
    fsm_sdata(f, TERMREQ, f->reqid = ++f->id,
 8014720:	687b      	ldr	r3, [r7, #4]
 8014722:	7c9b      	ldrb	r3, [r3, #18]
 8014724:	3301      	adds	r3, #1
 8014726:	b2da      	uxtb	r2, r3
 8014728:	687b      	ldr	r3, [r7, #4]
 801472a:	749a      	strb	r2, [r3, #18]
 801472c:	687b      	ldr	r3, [r7, #4]
 801472e:	7c9a      	ldrb	r2, [r3, #18]
 8014730:	687b      	ldr	r3, [r7, #4]
 8014732:	74da      	strb	r2, [r3, #19]
 8014734:	687b      	ldr	r3, [r7, #4]
 8014736:	7cda      	ldrb	r2, [r3, #19]
	      (const u_char *) f->term_reason, f->term_reason_len);
 8014738:	687b      	ldr	r3, [r7, #4]
 801473a:	6899      	ldr	r1, [r3, #8]
 801473c:	687b      	ldr	r3, [r7, #4]
 801473e:	7e1b      	ldrb	r3, [r3, #24]
    fsm_sdata(f, TERMREQ, f->reqid = ++f->id,
 8014740:	6878      	ldr	r0, [r7, #4]
 8014742:	9300      	str	r3, [sp, #0]
 8014744:	000b      	movs	r3, r1
 8014746:	2105      	movs	r1, #5
 8014748:	f000 fe0a 	bl	8015360 <fsm_sdata>

    if (f->retransmits == 0) {
 801474c:	687b      	ldr	r3, [r7, #4]
 801474e:	7d1b      	ldrb	r3, [r3, #20]
 8014750:	2b00      	cmp	r3, #0
 8014752:	d113      	bne.n	801477c <terminate_layer+0xa0>
	/*
	 * User asked for no terminate requests at all; just close it.
	 * We've already fired off one Terminate-Request just to be nice
	 * to the peer, but we're not going to wait for a reply.
	 */
	f->state = nextstate == PPP_FSM_CLOSING ? PPP_FSM_CLOSED : PPP_FSM_STOPPED;
 8014754:	683b      	ldr	r3, [r7, #0]
 8014756:	2b04      	cmp	r3, #4
 8014758:	d101      	bne.n	801475e <terminate_layer+0x82>
 801475a:	2202      	movs	r2, #2
 801475c:	e000      	b.n	8014760 <terminate_layer+0x84>
 801475e:	2203      	movs	r2, #3
 8014760:	687b      	ldr	r3, [r7, #4]
 8014762:	741a      	strb	r2, [r3, #16]
	if( f->callbacks->finished )
 8014764:	687b      	ldr	r3, [r7, #4]
 8014766:	685b      	ldr	r3, [r3, #4]
 8014768:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801476a:	2b00      	cmp	r3, #0
 801476c:	d026      	beq.n	80147bc <terminate_layer+0xe0>
	    (*f->callbacks->finished)(f);
 801476e:	687b      	ldr	r3, [r7, #4]
 8014770:	685b      	ldr	r3, [r3, #4]
 8014772:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014774:	687a      	ldr	r2, [r7, #4]
 8014776:	0010      	movs	r0, r2
 8014778:	4798      	blx	r3
	return;
 801477a:	e01f      	b.n	80147bc <terminate_layer+0xe0>
    }

    TIMEOUT(fsm_timeout, f, pcb->settings.fsm_timeout_time);
 801477c:	687a      	ldr	r2, [r7, #4]
 801477e:	4b11      	ldr	r3, [pc, #68]	; (80147c4 <terminate_layer+0xe8>)
 8014780:	0011      	movs	r1, r2
 8014782:	0018      	movs	r0, r3
 8014784:	f7fd fe36 	bl	80123f4 <sys_untimeout>
 8014788:	68fb      	ldr	r3, [r7, #12]
 801478a:	791b      	ldrb	r3, [r3, #4]
 801478c:	001a      	movs	r2, r3
 801478e:	0013      	movs	r3, r2
 8014790:	015b      	lsls	r3, r3, #5
 8014792:	1a9b      	subs	r3, r3, r2
 8014794:	009b      	lsls	r3, r3, #2
 8014796:	189b      	adds	r3, r3, r2
 8014798:	00db      	lsls	r3, r3, #3
 801479a:	0018      	movs	r0, r3
 801479c:	687a      	ldr	r2, [r7, #4]
 801479e:	4b09      	ldr	r3, [pc, #36]	; (80147c4 <terminate_layer+0xe8>)
 80147a0:	0019      	movs	r1, r3
 80147a2:	f7fd fdff 	bl	80123a4 <sys_timeout>
    --f->retransmits;
 80147a6:	687b      	ldr	r3, [r7, #4]
 80147a8:	7d1b      	ldrb	r3, [r3, #20]
 80147aa:	3b01      	subs	r3, #1
 80147ac:	b2da      	uxtb	r2, r3
 80147ae:	687b      	ldr	r3, [r7, #4]
 80147b0:	751a      	strb	r2, [r3, #20]

    f->state = nextstate;
 80147b2:	683b      	ldr	r3, [r7, #0]
 80147b4:	b2da      	uxtb	r2, r3
 80147b6:	687b      	ldr	r3, [r7, #4]
 80147b8:	741a      	strb	r2, [r3, #16]
 80147ba:	e000      	b.n	80147be <terminate_layer+0xe2>
	return;
 80147bc:	46c0      	nop			; (mov r8, r8)
}
 80147be:	46bd      	mov	sp, r7
 80147c0:	b004      	add	sp, #16
 80147c2:	bd80      	pop	{r7, pc}
 80147c4:	08014851 	.word	0x08014851

080147c8 <fsm_close>:
 * fsm_close - Start closing connection.
 *
 * Cancel timeouts and either initiate close or possibly go directly to
 * the PPP_FSM_CLOSED state.
 */
void fsm_close(fsm *f, const char *reason) {
 80147c8:	b580      	push	{r7, lr}
 80147ca:	b082      	sub	sp, #8
 80147cc:	af00      	add	r7, sp, #0
 80147ce:	6078      	str	r0, [r7, #4]
 80147d0:	6039      	str	r1, [r7, #0]
    f->term_reason = reason;
 80147d2:	687b      	ldr	r3, [r7, #4]
 80147d4:	683a      	ldr	r2, [r7, #0]
 80147d6:	609a      	str	r2, [r3, #8]
    f->term_reason_len = (reason == NULL? 0: (u8_t)LWIP_MIN(strlen(reason), 0xFF) );
 80147d8:	683b      	ldr	r3, [r7, #0]
 80147da:	2b00      	cmp	r3, #0
 80147dc:	d00f      	beq.n	80147fe <fsm_close+0x36>
 80147de:	683b      	ldr	r3, [r7, #0]
 80147e0:	0018      	movs	r0, r3
 80147e2:	f7eb fc91 	bl	8000108 <strlen>
 80147e6:	0003      	movs	r3, r0
 80147e8:	2bfe      	cmp	r3, #254	; 0xfe
 80147ea:	d806      	bhi.n	80147fa <fsm_close+0x32>
 80147ec:	683b      	ldr	r3, [r7, #0]
 80147ee:	0018      	movs	r0, r3
 80147f0:	f7eb fc8a 	bl	8000108 <strlen>
 80147f4:	0003      	movs	r3, r0
 80147f6:	b2db      	uxtb	r3, r3
 80147f8:	e002      	b.n	8014800 <fsm_close+0x38>
 80147fa:	23ff      	movs	r3, #255	; 0xff
 80147fc:	e000      	b.n	8014800 <fsm_close+0x38>
 80147fe:	2300      	movs	r3, #0
 8014800:	687a      	ldr	r2, [r7, #4]
 8014802:	7613      	strb	r3, [r2, #24]
    switch( f->state ){
 8014804:	687b      	ldr	r3, [r7, #4]
 8014806:	7c1b      	ldrb	r3, [r3, #16]
 8014808:	2b09      	cmp	r3, #9
 801480a:	dc1b      	bgt.n	8014844 <fsm_close+0x7c>
 801480c:	2b06      	cmp	r3, #6
 801480e:	da13      	bge.n	8014838 <fsm_close+0x70>
 8014810:	2b05      	cmp	r3, #5
 8014812:	d00d      	beq.n	8014830 <fsm_close+0x68>
 8014814:	dc16      	bgt.n	8014844 <fsm_close+0x7c>
 8014816:	2b01      	cmp	r3, #1
 8014818:	d002      	beq.n	8014820 <fsm_close+0x58>
 801481a:	2b03      	cmp	r3, #3
 801481c:	d004      	beq.n	8014828 <fsm_close+0x60>
    case PPP_FSM_ACKSENT:
    case PPP_FSM_OPENED:
	terminate_layer(f, PPP_FSM_CLOSING);
	break;
    default:
	break;
 801481e:	e011      	b.n	8014844 <fsm_close+0x7c>
	f->state = PPP_FSM_INITIAL;
 8014820:	687b      	ldr	r3, [r7, #4]
 8014822:	2200      	movs	r2, #0
 8014824:	741a      	strb	r2, [r3, #16]
	break;
 8014826:	e00e      	b.n	8014846 <fsm_close+0x7e>
	f->state = PPP_FSM_CLOSED;
 8014828:	687b      	ldr	r3, [r7, #4]
 801482a:	2202      	movs	r2, #2
 801482c:	741a      	strb	r2, [r3, #16]
	break;
 801482e:	e00a      	b.n	8014846 <fsm_close+0x7e>
	f->state = PPP_FSM_CLOSING;
 8014830:	687b      	ldr	r3, [r7, #4]
 8014832:	2204      	movs	r2, #4
 8014834:	741a      	strb	r2, [r3, #16]
	break;
 8014836:	e006      	b.n	8014846 <fsm_close+0x7e>
	terminate_layer(f, PPP_FSM_CLOSING);
 8014838:	687b      	ldr	r3, [r7, #4]
 801483a:	2104      	movs	r1, #4
 801483c:	0018      	movs	r0, r3
 801483e:	f7ff ff4d 	bl	80146dc <terminate_layer>
	break;
 8014842:	e000      	b.n	8014846 <fsm_close+0x7e>
	break;
 8014844:	46c0      	nop			; (mov r8, r8)
    }
}
 8014846:	46c0      	nop			; (mov r8, r8)
 8014848:	46bd      	mov	sp, r7
 801484a:	b002      	add	sp, #8
 801484c:	bd80      	pop	{r7, pc}
	...

08014850 <fsm_timeout>:


/*
 * fsm_timeout - Timeout expired.
 */
static void fsm_timeout(void *arg) {
 8014850:	b580      	push	{r7, lr}
 8014852:	b086      	sub	sp, #24
 8014854:	af02      	add	r7, sp, #8
 8014856:	6078      	str	r0, [r7, #4]
    fsm *f = (fsm *) arg;
 8014858:	687b      	ldr	r3, [r7, #4]
 801485a:	60fb      	str	r3, [r7, #12]
    ppp_pcb *pcb = f->pcb;
 801485c:	68fb      	ldr	r3, [r7, #12]
 801485e:	681b      	ldr	r3, [r3, #0]
 8014860:	60bb      	str	r3, [r7, #8]

    switch (f->state) {
 8014862:	68fb      	ldr	r3, [r7, #12]
 8014864:	7c1b      	ldrb	r3, [r3, #16]
 8014866:	2b05      	cmp	r3, #5
 8014868:	dc02      	bgt.n	8014870 <fsm_timeout+0x20>
 801486a:	2b04      	cmp	r3, #4
 801486c:	da05      	bge.n	801487a <fsm_timeout+0x2a>

    default:
	FSMDEBUG(("%s: Timeout event in state %d!", PROTO_NAME(f), f->state));
	/* no break */
    }
}
 801486e:	e08c      	b.n	801498a <fsm_timeout+0x13a>
 8014870:	3b06      	subs	r3, #6
    switch (f->state) {
 8014872:	2b02      	cmp	r3, #2
 8014874:	d900      	bls.n	8014878 <fsm_timeout+0x28>
 8014876:	e088      	b.n	801498a <fsm_timeout+0x13a>
 8014878:	e04b      	b.n	8014912 <fsm_timeout+0xc2>
	if( f->retransmits <= 0 ){
 801487a:	68fb      	ldr	r3, [r7, #12]
 801487c:	7d1b      	ldrb	r3, [r3, #20]
 801487e:	2b00      	cmp	r3, #0
 8014880:	d115      	bne.n	80148ae <fsm_timeout+0x5e>
	    f->state = (f->state == PPP_FSM_CLOSING)? PPP_FSM_CLOSED: PPP_FSM_STOPPED;
 8014882:	68fb      	ldr	r3, [r7, #12]
 8014884:	7c1b      	ldrb	r3, [r3, #16]
 8014886:	2b04      	cmp	r3, #4
 8014888:	d101      	bne.n	801488e <fsm_timeout+0x3e>
 801488a:	2202      	movs	r2, #2
 801488c:	e000      	b.n	8014890 <fsm_timeout+0x40>
 801488e:	2203      	movs	r2, #3
 8014890:	68fb      	ldr	r3, [r7, #12]
 8014892:	741a      	strb	r2, [r3, #16]
	    if( f->callbacks->finished )
 8014894:	68fb      	ldr	r3, [r7, #12]
 8014896:	685b      	ldr	r3, [r3, #4]
 8014898:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801489a:	2b00      	cmp	r3, #0
 801489c:	d100      	bne.n	80148a0 <fsm_timeout+0x50>
 801489e:	e071      	b.n	8014984 <fsm_timeout+0x134>
		(*f->callbacks->finished)(f);
 80148a0:	68fb      	ldr	r3, [r7, #12]
 80148a2:	685b      	ldr	r3, [r3, #4]
 80148a4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80148a6:	68fa      	ldr	r2, [r7, #12]
 80148a8:	0010      	movs	r0, r2
 80148aa:	4798      	blx	r3
	break;
 80148ac:	e06a      	b.n	8014984 <fsm_timeout+0x134>
	    fsm_sdata(f, TERMREQ, f->reqid = ++f->id,
 80148ae:	68fb      	ldr	r3, [r7, #12]
 80148b0:	7c9b      	ldrb	r3, [r3, #18]
 80148b2:	3301      	adds	r3, #1
 80148b4:	b2da      	uxtb	r2, r3
 80148b6:	68fb      	ldr	r3, [r7, #12]
 80148b8:	749a      	strb	r2, [r3, #18]
 80148ba:	68fb      	ldr	r3, [r7, #12]
 80148bc:	7c9a      	ldrb	r2, [r3, #18]
 80148be:	68fb      	ldr	r3, [r7, #12]
 80148c0:	74da      	strb	r2, [r3, #19]
 80148c2:	68fb      	ldr	r3, [r7, #12]
 80148c4:	7cda      	ldrb	r2, [r3, #19]
		      (const u_char *) f->term_reason, f->term_reason_len);
 80148c6:	68fb      	ldr	r3, [r7, #12]
 80148c8:	6899      	ldr	r1, [r3, #8]
 80148ca:	68fb      	ldr	r3, [r7, #12]
 80148cc:	7e1b      	ldrb	r3, [r3, #24]
	    fsm_sdata(f, TERMREQ, f->reqid = ++f->id,
 80148ce:	68f8      	ldr	r0, [r7, #12]
 80148d0:	9300      	str	r3, [sp, #0]
 80148d2:	000b      	movs	r3, r1
 80148d4:	2105      	movs	r1, #5
 80148d6:	f000 fd43 	bl	8015360 <fsm_sdata>
	    TIMEOUT(fsm_timeout, f, pcb->settings.fsm_timeout_time);
 80148da:	68fa      	ldr	r2, [r7, #12]
 80148dc:	4b2d      	ldr	r3, [pc, #180]	; (8014994 <fsm_timeout+0x144>)
 80148de:	0011      	movs	r1, r2
 80148e0:	0018      	movs	r0, r3
 80148e2:	f7fd fd87 	bl	80123f4 <sys_untimeout>
 80148e6:	68bb      	ldr	r3, [r7, #8]
 80148e8:	791b      	ldrb	r3, [r3, #4]
 80148ea:	001a      	movs	r2, r3
 80148ec:	0013      	movs	r3, r2
 80148ee:	015b      	lsls	r3, r3, #5
 80148f0:	1a9b      	subs	r3, r3, r2
 80148f2:	009b      	lsls	r3, r3, #2
 80148f4:	189b      	adds	r3, r3, r2
 80148f6:	00db      	lsls	r3, r3, #3
 80148f8:	0018      	movs	r0, r3
 80148fa:	68fa      	ldr	r2, [r7, #12]
 80148fc:	4b25      	ldr	r3, [pc, #148]	; (8014994 <fsm_timeout+0x144>)
 80148fe:	0019      	movs	r1, r3
 8014900:	f7fd fd50 	bl	80123a4 <sys_timeout>
	    --f->retransmits;
 8014904:	68fb      	ldr	r3, [r7, #12]
 8014906:	7d1b      	ldrb	r3, [r3, #20]
 8014908:	3b01      	subs	r3, #1
 801490a:	b2da      	uxtb	r2, r3
 801490c:	68fb      	ldr	r3, [r7, #12]
 801490e:	751a      	strb	r2, [r3, #20]
	break;
 8014910:	e038      	b.n	8014984 <fsm_timeout+0x134>
	if (f->retransmits <= 0) {
 8014912:	68fb      	ldr	r3, [r7, #12]
 8014914:	7d1b      	ldrb	r3, [r3, #20]
 8014916:	2b00      	cmp	r3, #0
 8014918:	d11c      	bne.n	8014954 <fsm_timeout+0x104>
	    ppp_warn("%s: timeout sending Config-Requests", PROTO_NAME(f));
 801491a:	68fb      	ldr	r3, [r7, #12]
 801491c:	685b      	ldr	r3, [r3, #4]
 801491e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8014920:	4b1d      	ldr	r3, [pc, #116]	; (8014998 <fsm_timeout+0x148>)
 8014922:	0011      	movs	r1, r2
 8014924:	0018      	movs	r0, r3
 8014926:	f006 ff86 	bl	801b836 <ppp_warn>
	    f->state = PPP_FSM_STOPPED;
 801492a:	68fb      	ldr	r3, [r7, #12]
 801492c:	2203      	movs	r2, #3
 801492e:	741a      	strb	r2, [r3, #16]
	    if( (f->flags & OPT_PASSIVE) == 0 && f->callbacks->finished )
 8014930:	68fb      	ldr	r3, [r7, #12]
 8014932:	7c5b      	ldrb	r3, [r3, #17]
 8014934:	001a      	movs	r2, r3
 8014936:	2301      	movs	r3, #1
 8014938:	4013      	ands	r3, r2
 801493a:	d125      	bne.n	8014988 <fsm_timeout+0x138>
 801493c:	68fb      	ldr	r3, [r7, #12]
 801493e:	685b      	ldr	r3, [r3, #4]
 8014940:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014942:	2b00      	cmp	r3, #0
 8014944:	d020      	beq.n	8014988 <fsm_timeout+0x138>
		(*f->callbacks->finished)(f);
 8014946:	68fb      	ldr	r3, [r7, #12]
 8014948:	685b      	ldr	r3, [r3, #4]
 801494a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801494c:	68fa      	ldr	r2, [r7, #12]
 801494e:	0010      	movs	r0, r2
 8014950:	4798      	blx	r3
	break;
 8014952:	e019      	b.n	8014988 <fsm_timeout+0x138>
	    if (f->callbacks->retransmit)
 8014954:	68fb      	ldr	r3, [r7, #12]
 8014956:	685b      	ldr	r3, [r3, #4]
 8014958:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801495a:	2b00      	cmp	r3, #0
 801495c:	d005      	beq.n	801496a <fsm_timeout+0x11a>
		(*f->callbacks->retransmit)(f);
 801495e:	68fb      	ldr	r3, [r7, #12]
 8014960:	685b      	ldr	r3, [r3, #4]
 8014962:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014964:	68fa      	ldr	r2, [r7, #12]
 8014966:	0010      	movs	r0, r2
 8014968:	4798      	blx	r3
	    fsm_sconfreq(f, 1);		/* Re-send Configure-Request */
 801496a:	68fb      	ldr	r3, [r7, #12]
 801496c:	2101      	movs	r1, #1
 801496e:	0018      	movs	r0, r3
 8014970:	f000 fc00 	bl	8015174 <fsm_sconfreq>
	    if( f->state == PPP_FSM_ACKRCVD )
 8014974:	68fb      	ldr	r3, [r7, #12]
 8014976:	7c1b      	ldrb	r3, [r3, #16]
 8014978:	2b07      	cmp	r3, #7
 801497a:	d105      	bne.n	8014988 <fsm_timeout+0x138>
		f->state = PPP_FSM_REQSENT;
 801497c:	68fb      	ldr	r3, [r7, #12]
 801497e:	2206      	movs	r2, #6
 8014980:	741a      	strb	r2, [r3, #16]
	break;
 8014982:	e001      	b.n	8014988 <fsm_timeout+0x138>
	break;
 8014984:	46c0      	nop			; (mov r8, r8)
 8014986:	e000      	b.n	801498a <fsm_timeout+0x13a>
	break;
 8014988:	46c0      	nop			; (mov r8, r8)
}
 801498a:	46c0      	nop			; (mov r8, r8)
 801498c:	46bd      	mov	sp, r7
 801498e:	b004      	add	sp, #16
 8014990:	bd80      	pop	{r7, pc}
 8014992:	46c0      	nop			; (mov r8, r8)
 8014994:	08014851 	.word	0x08014851
 8014998:	08021a04 	.word	0x08021a04

0801499c <fsm_input>:


/*
 * fsm_input - Input packet.
 */
void fsm_input(fsm *f, u_char *inpacket, int l) {
 801499c:	b5b0      	push	{r4, r5, r7, lr}
 801499e:	b08a      	sub	sp, #40	; 0x28
 80149a0:	af02      	add	r7, sp, #8
 80149a2:	60f8      	str	r0, [r7, #12]
 80149a4:	60b9      	str	r1, [r7, #8]
 80149a6:	607a      	str	r2, [r7, #4]

    /*
     * Parse header (code, id and length).
     * If packet too short, drop it.
     */
    inp = inpacket;
 80149a8:	68bb      	ldr	r3, [r7, #8]
 80149aa:	61fb      	str	r3, [r7, #28]
    if (l < HEADERLEN) {
 80149ac:	687b      	ldr	r3, [r7, #4]
 80149ae:	2b03      	cmp	r3, #3
 80149b0:	dc00      	bgt.n	80149b4 <fsm_input+0x18>
 80149b2:	e097      	b.n	8014ae4 <fsm_input+0x148>
	FSMDEBUG(("fsm_input(%x): Rcvd short header.", f->protocol));
	return;
    }
    GETCHAR(code, inp);
 80149b4:	69fb      	ldr	r3, [r7, #28]
 80149b6:	1c5a      	adds	r2, r3, #1
 80149b8:	61fa      	str	r2, [r7, #28]
 80149ba:	211b      	movs	r1, #27
 80149bc:	187a      	adds	r2, r7, r1
 80149be:	781b      	ldrb	r3, [r3, #0]
 80149c0:	7013      	strb	r3, [r2, #0]
    GETCHAR(id, inp);
 80149c2:	69fb      	ldr	r3, [r7, #28]
 80149c4:	1c5a      	adds	r2, r3, #1
 80149c6:	61fa      	str	r2, [r7, #28]
 80149c8:	221a      	movs	r2, #26
 80149ca:	18ba      	adds	r2, r7, r2
 80149cc:	781b      	ldrb	r3, [r3, #0]
 80149ce:	7013      	strb	r3, [r2, #0]
    GETSHORT(len, inp);
 80149d0:	69fb      	ldr	r3, [r7, #28]
 80149d2:	1c5a      	adds	r2, r3, #1
 80149d4:	61fa      	str	r2, [r7, #28]
 80149d6:	781b      	ldrb	r3, [r3, #0]
 80149d8:	021b      	lsls	r3, r3, #8
 80149da:	617b      	str	r3, [r7, #20]
 80149dc:	69fb      	ldr	r3, [r7, #28]
 80149de:	1c5a      	adds	r2, r3, #1
 80149e0:	61fa      	str	r2, [r7, #28]
 80149e2:	781b      	ldrb	r3, [r3, #0]
 80149e4:	001a      	movs	r2, r3
 80149e6:	697b      	ldr	r3, [r7, #20]
 80149e8:	4313      	orrs	r3, r2
 80149ea:	617b      	str	r3, [r7, #20]
    if (len < HEADERLEN) {
 80149ec:	697b      	ldr	r3, [r7, #20]
 80149ee:	2b03      	cmp	r3, #3
 80149f0:	dc00      	bgt.n	80149f4 <fsm_input+0x58>
 80149f2:	e079      	b.n	8014ae8 <fsm_input+0x14c>
	FSMDEBUG(("fsm_input(%x): Rcvd illegal length.", f->protocol));
	return;
    }
    if (len > l) {
 80149f4:	697a      	ldr	r2, [r7, #20]
 80149f6:	687b      	ldr	r3, [r7, #4]
 80149f8:	429a      	cmp	r2, r3
 80149fa:	dd00      	ble.n	80149fe <fsm_input+0x62>
 80149fc:	e076      	b.n	8014aec <fsm_input+0x150>
	FSMDEBUG(("fsm_input(%x): Rcvd short packet.", f->protocol));
	return;
    }
    len -= HEADERLEN;		/* subtract header length */
 80149fe:	697b      	ldr	r3, [r7, #20]
 8014a00:	3b04      	subs	r3, #4
 8014a02:	617b      	str	r3, [r7, #20]

    if( f->state == PPP_FSM_INITIAL || f->state == PPP_FSM_STARTING ){
 8014a04:	68fb      	ldr	r3, [r7, #12]
 8014a06:	7c1b      	ldrb	r3, [r3, #16]
 8014a08:	2b00      	cmp	r3, #0
 8014a0a:	d100      	bne.n	8014a0e <fsm_input+0x72>
 8014a0c:	e070      	b.n	8014af0 <fsm_input+0x154>
 8014a0e:	68fb      	ldr	r3, [r7, #12]
 8014a10:	7c1b      	ldrb	r3, [r3, #16]
 8014a12:	2b01      	cmp	r3, #1
 8014a14:	d06c      	beq.n	8014af0 <fsm_input+0x154>
    }

    /*
     * Action depends on code.
     */
    switch (code) {
 8014a16:	187b      	adds	r3, r7, r1
 8014a18:	781b      	ldrb	r3, [r3, #0]
 8014a1a:	2b07      	cmp	r3, #7
 8014a1c:	d83a      	bhi.n	8014a94 <fsm_input+0xf8>
 8014a1e:	009a      	lsls	r2, r3, #2
 8014a20:	4b36      	ldr	r3, [pc, #216]	; (8014afc <fsm_input+0x160>)
 8014a22:	18d3      	adds	r3, r2, r3
 8014a24:	681b      	ldr	r3, [r3, #0]
 8014a26:	469f      	mov	pc, r3
    case CONFREQ:
	fsm_rconfreq(f, id, inp, len);
 8014a28:	697c      	ldr	r4, [r7, #20]
 8014a2a:	69fa      	ldr	r2, [r7, #28]
 8014a2c:	231a      	movs	r3, #26
 8014a2e:	18fb      	adds	r3, r7, r3
 8014a30:	7819      	ldrb	r1, [r3, #0]
 8014a32:	68f8      	ldr	r0, [r7, #12]
 8014a34:	0023      	movs	r3, r4
 8014a36:	f000 f863 	bl	8014b00 <fsm_rconfreq>
	break;
 8014a3a:	e05c      	b.n	8014af6 <fsm_input+0x15a>
    
    case CONFACK:
	fsm_rconfack(f, id, inp, len);
 8014a3c:	231a      	movs	r3, #26
 8014a3e:	18fb      	adds	r3, r7, r3
 8014a40:	7819      	ldrb	r1, [r3, #0]
 8014a42:	697b      	ldr	r3, [r7, #20]
 8014a44:	69fa      	ldr	r2, [r7, #28]
 8014a46:	68f8      	ldr	r0, [r7, #12]
 8014a48:	f000 f904 	bl	8014c54 <fsm_rconfack>
	break;
 8014a4c:	e053      	b.n	8014af6 <fsm_input+0x15a>
    
    case CONFNAK:
    case CONFREJ:
	fsm_rconfnakrej(f, code, id, inp, len);
 8014a4e:	231b      	movs	r3, #27
 8014a50:	18fb      	adds	r3, r7, r3
 8014a52:	7819      	ldrb	r1, [r3, #0]
 8014a54:	231a      	movs	r3, #26
 8014a56:	18fb      	adds	r3, r7, r3
 8014a58:	781a      	ldrb	r2, [r3, #0]
 8014a5a:	69fc      	ldr	r4, [r7, #28]
 8014a5c:	68f8      	ldr	r0, [r7, #12]
 8014a5e:	697b      	ldr	r3, [r7, #20]
 8014a60:	9300      	str	r3, [sp, #0]
 8014a62:	0023      	movs	r3, r4
 8014a64:	f000 f996 	bl	8014d94 <fsm_rconfnakrej>
	break;
 8014a68:	e045      	b.n	8014af6 <fsm_input+0x15a>
    
    case TERMREQ:
	fsm_rtermreq(f, id, inp, len);
 8014a6a:	231a      	movs	r3, #26
 8014a6c:	18fb      	adds	r3, r7, r3
 8014a6e:	7819      	ldrb	r1, [r3, #0]
 8014a70:	697b      	ldr	r3, [r7, #20]
 8014a72:	69fa      	ldr	r2, [r7, #28]
 8014a74:	68f8      	ldr	r0, [r7, #12]
 8014a76:	f000 fa41 	bl	8014efc <fsm_rtermreq>
	break;
 8014a7a:	e03c      	b.n	8014af6 <fsm_input+0x15a>
    
    case TERMACK:
	fsm_rtermack(f);
 8014a7c:	68fb      	ldr	r3, [r7, #12]
 8014a7e:	0018      	movs	r0, r3
 8014a80:	f000 faa2 	bl	8014fc8 <fsm_rtermack>
	break;
 8014a84:	e037      	b.n	8014af6 <fsm_input+0x15a>
    
    case CODEREJ:
	fsm_rcoderej(f, inp, len);
 8014a86:	697a      	ldr	r2, [r7, #20]
 8014a88:	69f9      	ldr	r1, [r7, #28]
 8014a8a:	68fb      	ldr	r3, [r7, #12]
 8014a8c:	0018      	movs	r0, r3
 8014a8e:	f000 faf9 	bl	8015084 <fsm_rcoderej>
	break;
 8014a92:	e030      	b.n	8014af6 <fsm_input+0x15a>
    
    default:
	if( !f->callbacks->extcode
 8014a94:	68fb      	ldr	r3, [r7, #12]
 8014a96:	685b      	ldr	r3, [r3, #4]
 8014a98:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8014a9a:	2b00      	cmp	r3, #0
 8014a9c:	d010      	beq.n	8014ac0 <fsm_input+0x124>
	   || !(*f->callbacks->extcode)(f, code, id, inp, len) )
 8014a9e:	68fb      	ldr	r3, [r7, #12]
 8014aa0:	685b      	ldr	r3, [r3, #4]
 8014aa2:	6b5c      	ldr	r4, [r3, #52]	; 0x34
 8014aa4:	231b      	movs	r3, #27
 8014aa6:	18fb      	adds	r3, r7, r3
 8014aa8:	7819      	ldrb	r1, [r3, #0]
 8014aaa:	231a      	movs	r3, #26
 8014aac:	18fb      	adds	r3, r7, r3
 8014aae:	781a      	ldrb	r2, [r3, #0]
 8014ab0:	69fd      	ldr	r5, [r7, #28]
 8014ab2:	68f8      	ldr	r0, [r7, #12]
 8014ab4:	697b      	ldr	r3, [r7, #20]
 8014ab6:	9300      	str	r3, [sp, #0]
 8014ab8:	002b      	movs	r3, r5
 8014aba:	47a0      	blx	r4
 8014abc:	1e03      	subs	r3, r0, #0
 8014abe:	d119      	bne.n	8014af4 <fsm_input+0x158>
	    fsm_sdata(f, CODEREJ, ++f->id, inpacket, len + HEADERLEN);
 8014ac0:	68fb      	ldr	r3, [r7, #12]
 8014ac2:	7c9b      	ldrb	r3, [r3, #18]
 8014ac4:	3301      	adds	r3, #1
 8014ac6:	b2da      	uxtb	r2, r3
 8014ac8:	68fb      	ldr	r3, [r7, #12]
 8014aca:	749a      	strb	r2, [r3, #18]
 8014acc:	68fb      	ldr	r3, [r7, #12]
 8014ace:	7c9a      	ldrb	r2, [r3, #18]
 8014ad0:	697b      	ldr	r3, [r7, #20]
 8014ad2:	3304      	adds	r3, #4
 8014ad4:	68b9      	ldr	r1, [r7, #8]
 8014ad6:	68f8      	ldr	r0, [r7, #12]
 8014ad8:	9300      	str	r3, [sp, #0]
 8014ada:	000b      	movs	r3, r1
 8014adc:	2107      	movs	r1, #7
 8014ade:	f000 fc3f 	bl	8015360 <fsm_sdata>
	break;
 8014ae2:	e007      	b.n	8014af4 <fsm_input+0x158>
	return;
 8014ae4:	46c0      	nop			; (mov r8, r8)
 8014ae6:	e006      	b.n	8014af6 <fsm_input+0x15a>
	return;
 8014ae8:	46c0      	nop			; (mov r8, r8)
 8014aea:	e004      	b.n	8014af6 <fsm_input+0x15a>
	return;
 8014aec:	46c0      	nop			; (mov r8, r8)
 8014aee:	e002      	b.n	8014af6 <fsm_input+0x15a>
	return;
 8014af0:	46c0      	nop			; (mov r8, r8)
 8014af2:	e000      	b.n	8014af6 <fsm_input+0x15a>
	break;
 8014af4:	46c0      	nop			; (mov r8, r8)
    }
}
 8014af6:	46bd      	mov	sp, r7
 8014af8:	b008      	add	sp, #32
 8014afa:	bdb0      	pop	{r4, r5, r7, pc}
 8014afc:	080228f4 	.word	0x080228f4

08014b00 <fsm_rconfreq>:


/*
 * fsm_rconfreq - Receive Configure-Request.
 */
static void fsm_rconfreq(fsm *f, u_char id, u_char *inp, int len) {
 8014b00:	b590      	push	{r4, r7, lr}
 8014b02:	b089      	sub	sp, #36	; 0x24
 8014b04:	af02      	add	r7, sp, #8
 8014b06:	60f8      	str	r0, [r7, #12]
 8014b08:	607a      	str	r2, [r7, #4]
 8014b0a:	603b      	str	r3, [r7, #0]
 8014b0c:	230b      	movs	r3, #11
 8014b0e:	18fb      	adds	r3, r7, r3
 8014b10:	1c0a      	adds	r2, r1, #0
 8014b12:	701a      	strb	r2, [r3, #0]
    int code, reject_if_disagree;

    switch( f->state ){
 8014b14:	68fb      	ldr	r3, [r7, #12]
 8014b16:	7c1b      	ldrb	r3, [r3, #16]
 8014b18:	2b09      	cmp	r3, #9
 8014b1a:	d015      	beq.n	8014b48 <fsm_rconfreq+0x48>
 8014b1c:	dc31      	bgt.n	8014b82 <fsm_rconfreq+0x82>
 8014b1e:	2b05      	cmp	r3, #5
 8014b20:	dc2f      	bgt.n	8014b82 <fsm_rconfreq+0x82>
 8014b22:	2b04      	cmp	r3, #4
 8014b24:	db00      	blt.n	8014b28 <fsm_rconfreq+0x28>
 8014b26:	e08e      	b.n	8014c46 <fsm_rconfreq+0x146>
 8014b28:	2b02      	cmp	r3, #2
 8014b2a:	d002      	beq.n	8014b32 <fsm_rconfreq+0x32>
 8014b2c:	2b03      	cmp	r3, #3
 8014b2e:	d01f      	beq.n	8014b70 <fsm_rconfreq+0x70>
	/* Negotiation started by our peer */
	fsm_sconfreq(f, 0);		/* Send initial Configure-Request */
	f->state = PPP_FSM_REQSENT;
	break;
    default:
	break;
 8014b30:	e027      	b.n	8014b82 <fsm_rconfreq+0x82>
	fsm_sdata(f, TERMACK, id, NULL, 0);
 8014b32:	230b      	movs	r3, #11
 8014b34:	18fb      	adds	r3, r7, r3
 8014b36:	781a      	ldrb	r2, [r3, #0]
 8014b38:	68f8      	ldr	r0, [r7, #12]
 8014b3a:	2300      	movs	r3, #0
 8014b3c:	9300      	str	r3, [sp, #0]
 8014b3e:	2300      	movs	r3, #0
 8014b40:	2106      	movs	r1, #6
 8014b42:	f000 fc0d 	bl	8015360 <fsm_sdata>
	return;
 8014b46:	e07f      	b.n	8014c48 <fsm_rconfreq+0x148>
	if( f->callbacks->down )
 8014b48:	68fb      	ldr	r3, [r7, #12]
 8014b4a:	685b      	ldr	r3, [r3, #4]
 8014b4c:	6a1b      	ldr	r3, [r3, #32]
 8014b4e:	2b00      	cmp	r3, #0
 8014b50:	d005      	beq.n	8014b5e <fsm_rconfreq+0x5e>
	    (*f->callbacks->down)(f);	/* Inform upper layers */
 8014b52:	68fb      	ldr	r3, [r7, #12]
 8014b54:	685b      	ldr	r3, [r3, #4]
 8014b56:	6a1b      	ldr	r3, [r3, #32]
 8014b58:	68fa      	ldr	r2, [r7, #12]
 8014b5a:	0010      	movs	r0, r2
 8014b5c:	4798      	blx	r3
	fsm_sconfreq(f, 0);		/* Send initial Configure-Request */
 8014b5e:	68fb      	ldr	r3, [r7, #12]
 8014b60:	2100      	movs	r1, #0
 8014b62:	0018      	movs	r0, r3
 8014b64:	f000 fb06 	bl	8015174 <fsm_sconfreq>
	f->state = PPP_FSM_REQSENT;
 8014b68:	68fb      	ldr	r3, [r7, #12]
 8014b6a:	2206      	movs	r2, #6
 8014b6c:	741a      	strb	r2, [r3, #16]
	break;
 8014b6e:	e009      	b.n	8014b84 <fsm_rconfreq+0x84>
	fsm_sconfreq(f, 0);		/* Send initial Configure-Request */
 8014b70:	68fb      	ldr	r3, [r7, #12]
 8014b72:	2100      	movs	r1, #0
 8014b74:	0018      	movs	r0, r3
 8014b76:	f000 fafd 	bl	8015174 <fsm_sconfreq>
	f->state = PPP_FSM_REQSENT;
 8014b7a:	68fb      	ldr	r3, [r7, #12]
 8014b7c:	2206      	movs	r2, #6
 8014b7e:	741a      	strb	r2, [r3, #16]
	break;
 8014b80:	e000      	b.n	8014b84 <fsm_rconfreq+0x84>
	break;
 8014b82:	46c0      	nop			; (mov r8, r8)

    /*
     * Pass the requested configuration options
     * to protocol-specific code for checking.
     */
    if (f->callbacks->reqci){		/* Check CI */
 8014b84:	68fb      	ldr	r3, [r7, #12]
 8014b86:	685b      	ldr	r3, [r3, #4]
 8014b88:	699b      	ldr	r3, [r3, #24]
 8014b8a:	2b00      	cmp	r3, #0
 8014b8c:	d013      	beq.n	8014bb6 <fsm_rconfreq+0xb6>
	reject_if_disagree = (f->nakloops >= f->maxnakloops);
 8014b8e:	68fb      	ldr	r3, [r7, #12]
 8014b90:	7d59      	ldrb	r1, [r3, #21]
 8014b92:	68fb      	ldr	r3, [r7, #12]
 8014b94:	7dda      	ldrb	r2, [r3, #23]
 8014b96:	2300      	movs	r3, #0
 8014b98:	4291      	cmp	r1, r2
 8014b9a:	415b      	adcs	r3, r3
 8014b9c:	b2db      	uxtb	r3, r3
 8014b9e:	613b      	str	r3, [r7, #16]
	code = (*f->callbacks->reqci)(f, inp, &len, reject_if_disagree);
 8014ba0:	68fb      	ldr	r3, [r7, #12]
 8014ba2:	685b      	ldr	r3, [r3, #4]
 8014ba4:	699c      	ldr	r4, [r3, #24]
 8014ba6:	693b      	ldr	r3, [r7, #16]
 8014ba8:	003a      	movs	r2, r7
 8014baa:	6879      	ldr	r1, [r7, #4]
 8014bac:	68f8      	ldr	r0, [r7, #12]
 8014bae:	47a0      	blx	r4
 8014bb0:	0003      	movs	r3, r0
 8014bb2:	617b      	str	r3, [r7, #20]
 8014bb4:	e007      	b.n	8014bc6 <fsm_rconfreq+0xc6>
    } else if (len)
 8014bb6:	683b      	ldr	r3, [r7, #0]
 8014bb8:	2b00      	cmp	r3, #0
 8014bba:	d002      	beq.n	8014bc2 <fsm_rconfreq+0xc2>
	code = CONFREJ;			/* Reject all CI */
 8014bbc:	2304      	movs	r3, #4
 8014bbe:	617b      	str	r3, [r7, #20]
 8014bc0:	e001      	b.n	8014bc6 <fsm_rconfreq+0xc6>
    else
	code = CONFACK;
 8014bc2:	2302      	movs	r3, #2
 8014bc4:	617b      	str	r3, [r7, #20]

    /* send the Ack, Nak or Rej to the peer */
    fsm_sdata(f, code, id, inp, len);
 8014bc6:	697b      	ldr	r3, [r7, #20]
 8014bc8:	b2d9      	uxtb	r1, r3
 8014bca:	683b      	ldr	r3, [r7, #0]
 8014bcc:	687c      	ldr	r4, [r7, #4]
 8014bce:	220b      	movs	r2, #11
 8014bd0:	18ba      	adds	r2, r7, r2
 8014bd2:	7812      	ldrb	r2, [r2, #0]
 8014bd4:	68f8      	ldr	r0, [r7, #12]
 8014bd6:	9300      	str	r3, [sp, #0]
 8014bd8:	0023      	movs	r3, r4
 8014bda:	f000 fbc1 	bl	8015360 <fsm_sdata>

    if (code == CONFACK) {
 8014bde:	697b      	ldr	r3, [r7, #20]
 8014be0:	2b02      	cmp	r3, #2
 8014be2:	d11f      	bne.n	8014c24 <fsm_rconfreq+0x124>
	if (f->state == PPP_FSM_ACKRCVD) {
 8014be4:	68fb      	ldr	r3, [r7, #12]
 8014be6:	7c1b      	ldrb	r3, [r3, #16]
 8014be8:	2b07      	cmp	r3, #7
 8014bea:	d114      	bne.n	8014c16 <fsm_rconfreq+0x116>
	    UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 8014bec:	68fa      	ldr	r2, [r7, #12]
 8014bee:	4b18      	ldr	r3, [pc, #96]	; (8014c50 <fsm_rconfreq+0x150>)
 8014bf0:	0011      	movs	r1, r2
 8014bf2:	0018      	movs	r0, r3
 8014bf4:	f7fd fbfe 	bl	80123f4 <sys_untimeout>
	    f->state = PPP_FSM_OPENED;
 8014bf8:	68fb      	ldr	r3, [r7, #12]
 8014bfa:	2209      	movs	r2, #9
 8014bfc:	741a      	strb	r2, [r3, #16]
	    if (f->callbacks->up)
 8014bfe:	68fb      	ldr	r3, [r7, #12]
 8014c00:	685b      	ldr	r3, [r3, #4]
 8014c02:	69db      	ldr	r3, [r3, #28]
 8014c04:	2b00      	cmp	r3, #0
 8014c06:	d009      	beq.n	8014c1c <fsm_rconfreq+0x11c>
		(*f->callbacks->up)(f);	/* Inform upper layers */
 8014c08:	68fb      	ldr	r3, [r7, #12]
 8014c0a:	685b      	ldr	r3, [r3, #4]
 8014c0c:	69db      	ldr	r3, [r3, #28]
 8014c0e:	68fa      	ldr	r2, [r7, #12]
 8014c10:	0010      	movs	r0, r2
 8014c12:	4798      	blx	r3
 8014c14:	e002      	b.n	8014c1c <fsm_rconfreq+0x11c>
	} else
	    f->state = PPP_FSM_ACKSENT;
 8014c16:	68fb      	ldr	r3, [r7, #12]
 8014c18:	2208      	movs	r2, #8
 8014c1a:	741a      	strb	r2, [r3, #16]
	f->nakloops = 0;
 8014c1c:	68fb      	ldr	r3, [r7, #12]
 8014c1e:	2200      	movs	r2, #0
 8014c20:	755a      	strb	r2, [r3, #21]
 8014c22:	e011      	b.n	8014c48 <fsm_rconfreq+0x148>

    } else {
	/* we sent CONFACK or CONFREJ */
	if (f->state != PPP_FSM_ACKRCVD)
 8014c24:	68fb      	ldr	r3, [r7, #12]
 8014c26:	7c1b      	ldrb	r3, [r3, #16]
 8014c28:	2b07      	cmp	r3, #7
 8014c2a:	d002      	beq.n	8014c32 <fsm_rconfreq+0x132>
	    f->state = PPP_FSM_REQSENT;
 8014c2c:	68fb      	ldr	r3, [r7, #12]
 8014c2e:	2206      	movs	r2, #6
 8014c30:	741a      	strb	r2, [r3, #16]
	if( code == CONFNAK )
 8014c32:	697b      	ldr	r3, [r7, #20]
 8014c34:	2b03      	cmp	r3, #3
 8014c36:	d107      	bne.n	8014c48 <fsm_rconfreq+0x148>
	    ++f->nakloops;
 8014c38:	68fb      	ldr	r3, [r7, #12]
 8014c3a:	7d5b      	ldrb	r3, [r3, #21]
 8014c3c:	3301      	adds	r3, #1
 8014c3e:	b2da      	uxtb	r2, r3
 8014c40:	68fb      	ldr	r3, [r7, #12]
 8014c42:	755a      	strb	r2, [r3, #21]
 8014c44:	e000      	b.n	8014c48 <fsm_rconfreq+0x148>
	return;
 8014c46:	46c0      	nop			; (mov r8, r8)
    }
}
 8014c48:	46bd      	mov	sp, r7
 8014c4a:	b007      	add	sp, #28
 8014c4c:	bd90      	pop	{r4, r7, pc}
 8014c4e:	46c0      	nop			; (mov r8, r8)
 8014c50:	08014851 	.word	0x08014851

08014c54 <fsm_rconfack>:


/*
 * fsm_rconfack - Receive Configure-Ack.
 */
static void fsm_rconfack(fsm *f, int id, u_char *inp, int len) {
 8014c54:	b580      	push	{r7, lr}
 8014c56:	b088      	sub	sp, #32
 8014c58:	af02      	add	r7, sp, #8
 8014c5a:	60f8      	str	r0, [r7, #12]
 8014c5c:	60b9      	str	r1, [r7, #8]
 8014c5e:	607a      	str	r2, [r7, #4]
 8014c60:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 8014c62:	68fb      	ldr	r3, [r7, #12]
 8014c64:	681b      	ldr	r3, [r3, #0]
 8014c66:	617b      	str	r3, [r7, #20]

    if (id != f->reqid || f->seen_ack)		/* Expected id? */
 8014c68:	68fb      	ldr	r3, [r7, #12]
 8014c6a:	7cdb      	ldrb	r3, [r3, #19]
 8014c6c:	001a      	movs	r2, r3
 8014c6e:	68bb      	ldr	r3, [r7, #8]
 8014c70:	4293      	cmp	r3, r2
 8014c72:	d000      	beq.n	8014c76 <fsm_rconfack+0x22>
 8014c74:	e07f      	b.n	8014d76 <fsm_rconfack+0x122>
 8014c76:	68fb      	ldr	r3, [r7, #12]
 8014c78:	7b1b      	ldrb	r3, [r3, #12]
 8014c7a:	2b00      	cmp	r3, #0
 8014c7c:	d000      	beq.n	8014c80 <fsm_rconfack+0x2c>
 8014c7e:	e07a      	b.n	8014d76 <fsm_rconfack+0x122>
	return;					/* Nope, toss... */
    if( !(f->callbacks->ackci? (*f->callbacks->ackci)(f, inp, len):
 8014c80:	68fb      	ldr	r3, [r7, #12]
 8014c82:	685b      	ldr	r3, [r3, #4]
 8014c84:	68db      	ldr	r3, [r3, #12]
 8014c86:	2b00      	cmp	r3, #0
 8014c88:	d00b      	beq.n	8014ca2 <fsm_rconfack+0x4e>
 8014c8a:	68fb      	ldr	r3, [r7, #12]
 8014c8c:	685b      	ldr	r3, [r3, #4]
 8014c8e:	68db      	ldr	r3, [r3, #12]
 8014c90:	683a      	ldr	r2, [r7, #0]
 8014c92:	6879      	ldr	r1, [r7, #4]
 8014c94:	68f8      	ldr	r0, [r7, #12]
 8014c96:	4798      	blx	r3
 8014c98:	0003      	movs	r3, r0
 8014c9a:	425a      	negs	r2, r3
 8014c9c:	4153      	adcs	r3, r2
 8014c9e:	b2db      	uxtb	r3, r3
 8014ca0:	e003      	b.n	8014caa <fsm_rconfack+0x56>
 8014ca2:	683b      	ldr	r3, [r7, #0]
 8014ca4:	1e5a      	subs	r2, r3, #1
 8014ca6:	4193      	sbcs	r3, r2
 8014ca8:	b2db      	uxtb	r3, r3
 8014caa:	2b00      	cmp	r3, #0
 8014cac:	d006      	beq.n	8014cbc <fsm_rconfack+0x68>
	  (len == 0)) ){
	/* Ack is bad - ignore it */
	ppp_error("Received bad configure-ack: %P", inp, len);
 8014cae:	683a      	ldr	r2, [r7, #0]
 8014cb0:	6879      	ldr	r1, [r7, #4]
 8014cb2:	4b35      	ldr	r3, [pc, #212]	; (8014d88 <fsm_rconfack+0x134>)
 8014cb4:	0018      	movs	r0, r3
 8014cb6:	f006 fdaa 	bl	801b80e <ppp_error>
	return;
 8014cba:	e061      	b.n	8014d80 <fsm_rconfack+0x12c>
    }
    f->seen_ack = 1;
 8014cbc:	68fb      	ldr	r3, [r7, #12]
 8014cbe:	2201      	movs	r2, #1
 8014cc0:	731a      	strb	r2, [r3, #12]
    f->rnakloops = 0;
 8014cc2:	68fb      	ldr	r3, [r7, #12]
 8014cc4:	2200      	movs	r2, #0
 8014cc6:	759a      	strb	r2, [r3, #22]

    switch (f->state) {
 8014cc8:	68fb      	ldr	r3, [r7, #12]
 8014cca:	7c1b      	ldrb	r3, [r3, #16]
 8014ccc:	2b09      	cmp	r3, #9
 8014cce:	d854      	bhi.n	8014d7a <fsm_rconfack+0x126>
 8014cd0:	009a      	lsls	r2, r3, #2
 8014cd2:	4b2e      	ldr	r3, [pc, #184]	; (8014d8c <fsm_rconfack+0x138>)
 8014cd4:	18d3      	adds	r3, r2, r3
 8014cd6:	681b      	ldr	r3, [r3, #0]
 8014cd8:	469f      	mov	pc, r3
    case PPP_FSM_CLOSED:
    case PPP_FSM_STOPPED:
	fsm_sdata(f, TERMACK, id, NULL, 0);
 8014cda:	68bb      	ldr	r3, [r7, #8]
 8014cdc:	b2da      	uxtb	r2, r3
 8014cde:	68f8      	ldr	r0, [r7, #12]
 8014ce0:	2300      	movs	r3, #0
 8014ce2:	9300      	str	r3, [sp, #0]
 8014ce4:	2300      	movs	r3, #0
 8014ce6:	2106      	movs	r1, #6
 8014ce8:	f000 fb3a 	bl	8015360 <fsm_sdata>
	break;
 8014cec:	e048      	b.n	8014d80 <fsm_rconfack+0x12c>

    case PPP_FSM_REQSENT:
	f->state = PPP_FSM_ACKRCVD;
 8014cee:	68fb      	ldr	r3, [r7, #12]
 8014cf0:	2207      	movs	r2, #7
 8014cf2:	741a      	strb	r2, [r3, #16]
	f->retransmits = pcb->settings.fsm_max_conf_req_transmits;
 8014cf4:	697b      	ldr	r3, [r7, #20]
 8014cf6:	795a      	ldrb	r2, [r3, #5]
 8014cf8:	68fb      	ldr	r3, [r7, #12]
 8014cfa:	751a      	strb	r2, [r3, #20]
	break;
 8014cfc:	e040      	b.n	8014d80 <fsm_rconfack+0x12c>

    case PPP_FSM_ACKRCVD:
	/* Huh? an extra valid Ack? oh well... */
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 8014cfe:	68fa      	ldr	r2, [r7, #12]
 8014d00:	4b23      	ldr	r3, [pc, #140]	; (8014d90 <fsm_rconfack+0x13c>)
 8014d02:	0011      	movs	r1, r2
 8014d04:	0018      	movs	r0, r3
 8014d06:	f7fd fb75 	bl	80123f4 <sys_untimeout>
	fsm_sconfreq(f, 0);
 8014d0a:	68fb      	ldr	r3, [r7, #12]
 8014d0c:	2100      	movs	r1, #0
 8014d0e:	0018      	movs	r0, r3
 8014d10:	f000 fa30 	bl	8015174 <fsm_sconfreq>
	f->state = PPP_FSM_REQSENT;
 8014d14:	68fb      	ldr	r3, [r7, #12]
 8014d16:	2206      	movs	r2, #6
 8014d18:	741a      	strb	r2, [r3, #16]
	break;
 8014d1a:	e031      	b.n	8014d80 <fsm_rconfack+0x12c>

    case PPP_FSM_ACKSENT:
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 8014d1c:	68fa      	ldr	r2, [r7, #12]
 8014d1e:	4b1c      	ldr	r3, [pc, #112]	; (8014d90 <fsm_rconfack+0x13c>)
 8014d20:	0011      	movs	r1, r2
 8014d22:	0018      	movs	r0, r3
 8014d24:	f7fd fb66 	bl	80123f4 <sys_untimeout>
	f->state = PPP_FSM_OPENED;
 8014d28:	68fb      	ldr	r3, [r7, #12]
 8014d2a:	2209      	movs	r2, #9
 8014d2c:	741a      	strb	r2, [r3, #16]
	f->retransmits = pcb->settings.fsm_max_conf_req_transmits;
 8014d2e:	697b      	ldr	r3, [r7, #20]
 8014d30:	795a      	ldrb	r2, [r3, #5]
 8014d32:	68fb      	ldr	r3, [r7, #12]
 8014d34:	751a      	strb	r2, [r3, #20]
	if (f->callbacks->up)
 8014d36:	68fb      	ldr	r3, [r7, #12]
 8014d38:	685b      	ldr	r3, [r3, #4]
 8014d3a:	69db      	ldr	r3, [r3, #28]
 8014d3c:	2b00      	cmp	r3, #0
 8014d3e:	d01e      	beq.n	8014d7e <fsm_rconfack+0x12a>
	    (*f->callbacks->up)(f);	/* Inform upper layers */
 8014d40:	68fb      	ldr	r3, [r7, #12]
 8014d42:	685b      	ldr	r3, [r3, #4]
 8014d44:	69db      	ldr	r3, [r3, #28]
 8014d46:	68fa      	ldr	r2, [r7, #12]
 8014d48:	0010      	movs	r0, r2
 8014d4a:	4798      	blx	r3
	break;
 8014d4c:	e017      	b.n	8014d7e <fsm_rconfack+0x12a>

    case PPP_FSM_OPENED:
	/* Go down and restart negotiation */
	if (f->callbacks->down)
 8014d4e:	68fb      	ldr	r3, [r7, #12]
 8014d50:	685b      	ldr	r3, [r3, #4]
 8014d52:	6a1b      	ldr	r3, [r3, #32]
 8014d54:	2b00      	cmp	r3, #0
 8014d56:	d005      	beq.n	8014d64 <fsm_rconfack+0x110>
	    (*f->callbacks->down)(f);	/* Inform upper layers */
 8014d58:	68fb      	ldr	r3, [r7, #12]
 8014d5a:	685b      	ldr	r3, [r3, #4]
 8014d5c:	6a1b      	ldr	r3, [r3, #32]
 8014d5e:	68fa      	ldr	r2, [r7, #12]
 8014d60:	0010      	movs	r0, r2
 8014d62:	4798      	blx	r3
	fsm_sconfreq(f, 0);		/* Send initial Configure-Request */
 8014d64:	68fb      	ldr	r3, [r7, #12]
 8014d66:	2100      	movs	r1, #0
 8014d68:	0018      	movs	r0, r3
 8014d6a:	f000 fa03 	bl	8015174 <fsm_sconfreq>
	f->state = PPP_FSM_REQSENT;
 8014d6e:	68fb      	ldr	r3, [r7, #12]
 8014d70:	2206      	movs	r2, #6
 8014d72:	741a      	strb	r2, [r3, #16]
	break;
 8014d74:	e004      	b.n	8014d80 <fsm_rconfack+0x12c>
	return;					/* Nope, toss... */
 8014d76:	46c0      	nop			; (mov r8, r8)
 8014d78:	e002      	b.n	8014d80 <fsm_rconfack+0x12c>
    default:
	break;
 8014d7a:	46c0      	nop			; (mov r8, r8)
 8014d7c:	e000      	b.n	8014d80 <fsm_rconfack+0x12c>
	break;
 8014d7e:	46c0      	nop			; (mov r8, r8)
    }
}
 8014d80:	46bd      	mov	sp, r7
 8014d82:	b006      	add	sp, #24
 8014d84:	bd80      	pop	{r7, pc}
 8014d86:	46c0      	nop			; (mov r8, r8)
 8014d88:	08021a28 	.word	0x08021a28
 8014d8c:	08022914 	.word	0x08022914
 8014d90:	08014851 	.word	0x08014851

08014d94 <fsm_rconfnakrej>:


/*
 * fsm_rconfnakrej - Receive Configure-Nak or Configure-Reject.
 */
static void fsm_rconfnakrej(fsm *f, int code, int id, u_char *inp, int len) {
 8014d94:	b590      	push	{r4, r7, lr}
 8014d96:	b089      	sub	sp, #36	; 0x24
 8014d98:	af02      	add	r7, sp, #8
 8014d9a:	60f8      	str	r0, [r7, #12]
 8014d9c:	60b9      	str	r1, [r7, #8]
 8014d9e:	607a      	str	r2, [r7, #4]
 8014da0:	603b      	str	r3, [r7, #0]
    int ret;
    int treat_as_reject;

    if (id != f->reqid || f->seen_ack)	/* Expected id? */
 8014da2:	68fb      	ldr	r3, [r7, #12]
 8014da4:	7cdb      	ldrb	r3, [r3, #19]
 8014da6:	001a      	movs	r2, r3
 8014da8:	687b      	ldr	r3, [r7, #4]
 8014daa:	4293      	cmp	r3, r2
 8014dac:	d000      	beq.n	8014db0 <fsm_rconfnakrej+0x1c>
 8014dae:	e096      	b.n	8014ede <fsm_rconfnakrej+0x14a>
 8014db0:	68fb      	ldr	r3, [r7, #12]
 8014db2:	7b1b      	ldrb	r3, [r3, #12]
 8014db4:	2b00      	cmp	r3, #0
 8014db6:	d000      	beq.n	8014dba <fsm_rconfnakrej+0x26>
 8014db8:	e091      	b.n	8014ede <fsm_rconfnakrej+0x14a>
	return;				/* Nope, toss... */

    if (code == CONFNAK) {
 8014dba:	68bb      	ldr	r3, [r7, #8]
 8014dbc:	2b03      	cmp	r3, #3
 8014dbe:	d127      	bne.n	8014e10 <fsm_rconfnakrej+0x7c>
	++f->rnakloops;
 8014dc0:	68fb      	ldr	r3, [r7, #12]
 8014dc2:	7d9b      	ldrb	r3, [r3, #22]
 8014dc4:	3301      	adds	r3, #1
 8014dc6:	b2da      	uxtb	r2, r3
 8014dc8:	68fb      	ldr	r3, [r7, #12]
 8014dca:	759a      	strb	r2, [r3, #22]
	treat_as_reject = (f->rnakloops >= f->maxnakloops);
 8014dcc:	68fb      	ldr	r3, [r7, #12]
 8014dce:	7d99      	ldrb	r1, [r3, #22]
 8014dd0:	68fb      	ldr	r3, [r7, #12]
 8014dd2:	7dda      	ldrb	r2, [r3, #23]
 8014dd4:	2300      	movs	r3, #0
 8014dd6:	4291      	cmp	r1, r2
 8014dd8:	415b      	adcs	r3, r3
 8014dda:	b2db      	uxtb	r3, r3
 8014ddc:	613b      	str	r3, [r7, #16]
	if (f->callbacks->nakci == NULL
 8014dde:	68fb      	ldr	r3, [r7, #12]
 8014de0:	685b      	ldr	r3, [r3, #4]
 8014de2:	691b      	ldr	r3, [r3, #16]
 8014de4:	2b00      	cmp	r3, #0
 8014de6:	d00c      	beq.n	8014e02 <fsm_rconfnakrej+0x6e>
	    || !(ret = f->callbacks->nakci(f, inp, len, treat_as_reject))) {
 8014de8:	68fb      	ldr	r3, [r7, #12]
 8014dea:	685b      	ldr	r3, [r3, #4]
 8014dec:	691c      	ldr	r4, [r3, #16]
 8014dee:	693b      	ldr	r3, [r7, #16]
 8014df0:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8014df2:	6839      	ldr	r1, [r7, #0]
 8014df4:	68f8      	ldr	r0, [r7, #12]
 8014df6:	47a0      	blx	r4
 8014df8:	0003      	movs	r3, r0
 8014dfa:	617b      	str	r3, [r7, #20]
 8014dfc:	697b      	ldr	r3, [r7, #20]
 8014dfe:	2b00      	cmp	r3, #0
 8014e00:	d121      	bne.n	8014e46 <fsm_rconfnakrej+0xb2>
	    ppp_error("Received bad configure-nak: %P", inp, len);
 8014e02:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8014e04:	6839      	ldr	r1, [r7, #0]
 8014e06:	4b39      	ldr	r3, [pc, #228]	; (8014eec <fsm_rconfnakrej+0x158>)
 8014e08:	0018      	movs	r0, r3
 8014e0a:	f006 fd00 	bl	801b80e <ppp_error>
	    return;
 8014e0e:	e069      	b.n	8014ee4 <fsm_rconfnakrej+0x150>
	}
    } else {
	f->rnakloops = 0;
 8014e10:	68fb      	ldr	r3, [r7, #12]
 8014e12:	2200      	movs	r2, #0
 8014e14:	759a      	strb	r2, [r3, #22]
	if (f->callbacks->rejci == NULL
 8014e16:	68fb      	ldr	r3, [r7, #12]
 8014e18:	685b      	ldr	r3, [r3, #4]
 8014e1a:	695b      	ldr	r3, [r3, #20]
 8014e1c:	2b00      	cmp	r3, #0
 8014e1e:	d00b      	beq.n	8014e38 <fsm_rconfnakrej+0xa4>
	    || !(ret = f->callbacks->rejci(f, inp, len))) {
 8014e20:	68fb      	ldr	r3, [r7, #12]
 8014e22:	685b      	ldr	r3, [r3, #4]
 8014e24:	695b      	ldr	r3, [r3, #20]
 8014e26:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8014e28:	6839      	ldr	r1, [r7, #0]
 8014e2a:	68f8      	ldr	r0, [r7, #12]
 8014e2c:	4798      	blx	r3
 8014e2e:	0003      	movs	r3, r0
 8014e30:	617b      	str	r3, [r7, #20]
 8014e32:	697b      	ldr	r3, [r7, #20]
 8014e34:	2b00      	cmp	r3, #0
 8014e36:	d106      	bne.n	8014e46 <fsm_rconfnakrej+0xb2>
	    ppp_error("Received bad configure-rej: %P", inp, len);
 8014e38:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8014e3a:	6839      	ldr	r1, [r7, #0]
 8014e3c:	4b2c      	ldr	r3, [pc, #176]	; (8014ef0 <fsm_rconfnakrej+0x15c>)
 8014e3e:	0018      	movs	r0, r3
 8014e40:	f006 fce5 	bl	801b80e <ppp_error>
	    return;
 8014e44:	e04e      	b.n	8014ee4 <fsm_rconfnakrej+0x150>
	}
    }

    f->seen_ack = 1;
 8014e46:	68fb      	ldr	r3, [r7, #12]
 8014e48:	2201      	movs	r2, #1
 8014e4a:	731a      	strb	r2, [r3, #12]

    switch (f->state) {
 8014e4c:	68fb      	ldr	r3, [r7, #12]
 8014e4e:	7c1b      	ldrb	r3, [r3, #16]
 8014e50:	2b09      	cmp	r3, #9
 8014e52:	d846      	bhi.n	8014ee2 <fsm_rconfnakrej+0x14e>
 8014e54:	009a      	lsls	r2, r3, #2
 8014e56:	4b27      	ldr	r3, [pc, #156]	; (8014ef4 <fsm_rconfnakrej+0x160>)
 8014e58:	18d3      	adds	r3, r2, r3
 8014e5a:	681b      	ldr	r3, [r3, #0]
 8014e5c:	469f      	mov	pc, r3
    case PPP_FSM_CLOSED:
    case PPP_FSM_STOPPED:
	fsm_sdata(f, TERMACK, id, NULL, 0);
 8014e5e:	687b      	ldr	r3, [r7, #4]
 8014e60:	b2da      	uxtb	r2, r3
 8014e62:	68f8      	ldr	r0, [r7, #12]
 8014e64:	2300      	movs	r3, #0
 8014e66:	9300      	str	r3, [sp, #0]
 8014e68:	2300      	movs	r3, #0
 8014e6a:	2106      	movs	r1, #6
 8014e6c:	f000 fa78 	bl	8015360 <fsm_sdata>
	break;
 8014e70:	e038      	b.n	8014ee4 <fsm_rconfnakrej+0x150>

    case PPP_FSM_REQSENT:
    case PPP_FSM_ACKSENT:
	/* They didn't agree to what we wanted - try another request */
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 8014e72:	68fa      	ldr	r2, [r7, #12]
 8014e74:	4b20      	ldr	r3, [pc, #128]	; (8014ef8 <fsm_rconfnakrej+0x164>)
 8014e76:	0011      	movs	r1, r2
 8014e78:	0018      	movs	r0, r3
 8014e7a:	f7fd fabb 	bl	80123f4 <sys_untimeout>
	if (ret < 0)
 8014e7e:	697b      	ldr	r3, [r7, #20]
 8014e80:	2b00      	cmp	r3, #0
 8014e82:	da03      	bge.n	8014e8c <fsm_rconfnakrej+0xf8>
	    f->state = PPP_FSM_STOPPED;		/* kludge for stopping CCP */
 8014e84:	68fb      	ldr	r3, [r7, #12]
 8014e86:	2203      	movs	r2, #3
 8014e88:	741a      	strb	r2, [r3, #16]
	else
	    fsm_sconfreq(f, 0);		/* Send Configure-Request */
	break;
 8014e8a:	e02b      	b.n	8014ee4 <fsm_rconfnakrej+0x150>
	    fsm_sconfreq(f, 0);		/* Send Configure-Request */
 8014e8c:	68fb      	ldr	r3, [r7, #12]
 8014e8e:	2100      	movs	r1, #0
 8014e90:	0018      	movs	r0, r3
 8014e92:	f000 f96f 	bl	8015174 <fsm_sconfreq>
	break;
 8014e96:	e025      	b.n	8014ee4 <fsm_rconfnakrej+0x150>

    case PPP_FSM_ACKRCVD:
	/* Got a Nak/reject when we had already had an Ack?? oh well... */
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 8014e98:	68fa      	ldr	r2, [r7, #12]
 8014e9a:	4b17      	ldr	r3, [pc, #92]	; (8014ef8 <fsm_rconfnakrej+0x164>)
 8014e9c:	0011      	movs	r1, r2
 8014e9e:	0018      	movs	r0, r3
 8014ea0:	f7fd faa8 	bl	80123f4 <sys_untimeout>
	fsm_sconfreq(f, 0);
 8014ea4:	68fb      	ldr	r3, [r7, #12]
 8014ea6:	2100      	movs	r1, #0
 8014ea8:	0018      	movs	r0, r3
 8014eaa:	f000 f963 	bl	8015174 <fsm_sconfreq>
	f->state = PPP_FSM_REQSENT;
 8014eae:	68fb      	ldr	r3, [r7, #12]
 8014eb0:	2206      	movs	r2, #6
 8014eb2:	741a      	strb	r2, [r3, #16]
	break;
 8014eb4:	e016      	b.n	8014ee4 <fsm_rconfnakrej+0x150>

    case PPP_FSM_OPENED:
	/* Go down and restart negotiation */
	if (f->callbacks->down)
 8014eb6:	68fb      	ldr	r3, [r7, #12]
 8014eb8:	685b      	ldr	r3, [r3, #4]
 8014eba:	6a1b      	ldr	r3, [r3, #32]
 8014ebc:	2b00      	cmp	r3, #0
 8014ebe:	d005      	beq.n	8014ecc <fsm_rconfnakrej+0x138>
	    (*f->callbacks->down)(f);	/* Inform upper layers */
 8014ec0:	68fb      	ldr	r3, [r7, #12]
 8014ec2:	685b      	ldr	r3, [r3, #4]
 8014ec4:	6a1b      	ldr	r3, [r3, #32]
 8014ec6:	68fa      	ldr	r2, [r7, #12]
 8014ec8:	0010      	movs	r0, r2
 8014eca:	4798      	blx	r3
	fsm_sconfreq(f, 0);		/* Send initial Configure-Request */
 8014ecc:	68fb      	ldr	r3, [r7, #12]
 8014ece:	2100      	movs	r1, #0
 8014ed0:	0018      	movs	r0, r3
 8014ed2:	f000 f94f 	bl	8015174 <fsm_sconfreq>
	f->state = PPP_FSM_REQSENT;
 8014ed6:	68fb      	ldr	r3, [r7, #12]
 8014ed8:	2206      	movs	r2, #6
 8014eda:	741a      	strb	r2, [r3, #16]
	break;
 8014edc:	e002      	b.n	8014ee4 <fsm_rconfnakrej+0x150>
	return;				/* Nope, toss... */
 8014ede:	46c0      	nop			; (mov r8, r8)
 8014ee0:	e000      	b.n	8014ee4 <fsm_rconfnakrej+0x150>
    default:
	break;
 8014ee2:	46c0      	nop			; (mov r8, r8)
    }
}
 8014ee4:	46bd      	mov	sp, r7
 8014ee6:	b007      	add	sp, #28
 8014ee8:	bd90      	pop	{r4, r7, pc}
 8014eea:	46c0      	nop			; (mov r8, r8)
 8014eec:	08021a48 	.word	0x08021a48
 8014ef0:	08021a68 	.word	0x08021a68
 8014ef4:	0802293c 	.word	0x0802293c
 8014ef8:	08014851 	.word	0x08014851

08014efc <fsm_rtermreq>:


/*
 * fsm_rtermreq - Receive Terminate-Req.
 */
static void fsm_rtermreq(fsm *f, int id, u_char *p, int len) {
 8014efc:	b580      	push	{r7, lr}
 8014efe:	b088      	sub	sp, #32
 8014f00:	af02      	add	r7, sp, #8
 8014f02:	60f8      	str	r0, [r7, #12]
 8014f04:	60b9      	str	r1, [r7, #8]
 8014f06:	607a      	str	r2, [r7, #4]
 8014f08:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 8014f0a:	68fb      	ldr	r3, [r7, #12]
 8014f0c:	681b      	ldr	r3, [r3, #0]
 8014f0e:	617b      	str	r3, [r7, #20]

    switch (f->state) {
 8014f10:	68fb      	ldr	r3, [r7, #12]
 8014f12:	7c1b      	ldrb	r3, [r3, #16]
 8014f14:	2b08      	cmp	r3, #8
 8014f16:	dc02      	bgt.n	8014f1e <fsm_rtermreq+0x22>
 8014f18:	2b07      	cmp	r3, #7
 8014f1a:	da03      	bge.n	8014f24 <fsm_rtermreq+0x28>
	if (f->callbacks->down)
	    (*f->callbacks->down)(f);	/* Inform upper layers */
	TIMEOUT(fsm_timeout, f, pcb->settings.fsm_timeout_time);
	break;
    default:
	break;
 8014f1c:	e041      	b.n	8014fa2 <fsm_rtermreq+0xa6>
    switch (f->state) {
 8014f1e:	2b09      	cmp	r3, #9
 8014f20:	d004      	beq.n	8014f2c <fsm_rtermreq+0x30>
	break;
 8014f22:	e03e      	b.n	8014fa2 <fsm_rtermreq+0xa6>
	f->state = PPP_FSM_REQSENT;		/* Start over but keep trying */
 8014f24:	68fb      	ldr	r3, [r7, #12]
 8014f26:	2206      	movs	r2, #6
 8014f28:	741a      	strb	r2, [r3, #16]
	break;
 8014f2a:	e03a      	b.n	8014fa2 <fsm_rtermreq+0xa6>
	if (len > 0) {
 8014f2c:	683b      	ldr	r3, [r7, #0]
 8014f2e:	2b00      	cmp	r3, #0
 8014f30:	dd08      	ble.n	8014f44 <fsm_rtermreq+0x48>
	    ppp_info("%s terminated by peer (%0.*v)", PROTO_NAME(f), len, p);
 8014f32:	68fb      	ldr	r3, [r7, #12]
 8014f34:	685b      	ldr	r3, [r3, #4]
 8014f36:	6b99      	ldr	r1, [r3, #56]	; 0x38
 8014f38:	687b      	ldr	r3, [r7, #4]
 8014f3a:	683a      	ldr	r2, [r7, #0]
 8014f3c:	481f      	ldr	r0, [pc, #124]	; (8014fbc <fsm_rtermreq+0xc0>)
 8014f3e:	f006 fca2 	bl	801b886 <ppp_info>
 8014f42:	e007      	b.n	8014f54 <fsm_rtermreq+0x58>
	    ppp_info("%s terminated by peer", PROTO_NAME(f));
 8014f44:	68fb      	ldr	r3, [r7, #12]
 8014f46:	685b      	ldr	r3, [r3, #4]
 8014f48:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8014f4a:	4b1d      	ldr	r3, [pc, #116]	; (8014fc0 <fsm_rtermreq+0xc4>)
 8014f4c:	0011      	movs	r1, r2
 8014f4e:	0018      	movs	r0, r3
 8014f50:	f006 fc99 	bl	801b886 <ppp_info>
	f->retransmits = 0;
 8014f54:	68fb      	ldr	r3, [r7, #12]
 8014f56:	2200      	movs	r2, #0
 8014f58:	751a      	strb	r2, [r3, #20]
	f->state = PPP_FSM_STOPPING;
 8014f5a:	68fb      	ldr	r3, [r7, #12]
 8014f5c:	2205      	movs	r2, #5
 8014f5e:	741a      	strb	r2, [r3, #16]
	if (f->callbacks->down)
 8014f60:	68fb      	ldr	r3, [r7, #12]
 8014f62:	685b      	ldr	r3, [r3, #4]
 8014f64:	6a1b      	ldr	r3, [r3, #32]
 8014f66:	2b00      	cmp	r3, #0
 8014f68:	d005      	beq.n	8014f76 <fsm_rtermreq+0x7a>
	    (*f->callbacks->down)(f);	/* Inform upper layers */
 8014f6a:	68fb      	ldr	r3, [r7, #12]
 8014f6c:	685b      	ldr	r3, [r3, #4]
 8014f6e:	6a1b      	ldr	r3, [r3, #32]
 8014f70:	68fa      	ldr	r2, [r7, #12]
 8014f72:	0010      	movs	r0, r2
 8014f74:	4798      	blx	r3
	TIMEOUT(fsm_timeout, f, pcb->settings.fsm_timeout_time);
 8014f76:	68fa      	ldr	r2, [r7, #12]
 8014f78:	4b12      	ldr	r3, [pc, #72]	; (8014fc4 <fsm_rtermreq+0xc8>)
 8014f7a:	0011      	movs	r1, r2
 8014f7c:	0018      	movs	r0, r3
 8014f7e:	f7fd fa39 	bl	80123f4 <sys_untimeout>
 8014f82:	697b      	ldr	r3, [r7, #20]
 8014f84:	791b      	ldrb	r3, [r3, #4]
 8014f86:	001a      	movs	r2, r3
 8014f88:	0013      	movs	r3, r2
 8014f8a:	015b      	lsls	r3, r3, #5
 8014f8c:	1a9b      	subs	r3, r3, r2
 8014f8e:	009b      	lsls	r3, r3, #2
 8014f90:	189b      	adds	r3, r3, r2
 8014f92:	00db      	lsls	r3, r3, #3
 8014f94:	0018      	movs	r0, r3
 8014f96:	68fa      	ldr	r2, [r7, #12]
 8014f98:	4b0a      	ldr	r3, [pc, #40]	; (8014fc4 <fsm_rtermreq+0xc8>)
 8014f9a:	0019      	movs	r1, r3
 8014f9c:	f7fd fa02 	bl	80123a4 <sys_timeout>
	break;
 8014fa0:	46c0      	nop			; (mov r8, r8)
    }

    fsm_sdata(f, TERMACK, id, NULL, 0);
 8014fa2:	68bb      	ldr	r3, [r7, #8]
 8014fa4:	b2da      	uxtb	r2, r3
 8014fa6:	68f8      	ldr	r0, [r7, #12]
 8014fa8:	2300      	movs	r3, #0
 8014faa:	9300      	str	r3, [sp, #0]
 8014fac:	2300      	movs	r3, #0
 8014fae:	2106      	movs	r1, #6
 8014fb0:	f000 f9d6 	bl	8015360 <fsm_sdata>
}
 8014fb4:	46c0      	nop			; (mov r8, r8)
 8014fb6:	46bd      	mov	sp, r7
 8014fb8:	b006      	add	sp, #24
 8014fba:	bd80      	pop	{r7, pc}
 8014fbc:	08021a88 	.word	0x08021a88
 8014fc0:	08021aa8 	.word	0x08021aa8
 8014fc4:	08014851 	.word	0x08014851

08014fc8 <fsm_rtermack>:


/*
 * fsm_rtermack - Receive Terminate-Ack.
 */
static void fsm_rtermack(fsm *f) {
 8014fc8:	b580      	push	{r7, lr}
 8014fca:	b082      	sub	sp, #8
 8014fcc:	af00      	add	r7, sp, #0
 8014fce:	6078      	str	r0, [r7, #4]
    switch (f->state) {
 8014fd0:	687b      	ldr	r3, [r7, #4]
 8014fd2:	7c1b      	ldrb	r3, [r3, #16]
 8014fd4:	2b09      	cmp	r3, #9
 8014fd6:	d036      	beq.n	8015046 <fsm_rtermack+0x7e>
 8014fd8:	dc49      	bgt.n	801506e <fsm_rtermack+0xa6>
 8014fda:	2b07      	cmp	r3, #7
 8014fdc:	d02f      	beq.n	801503e <fsm_rtermack+0x76>
 8014fde:	dc46      	bgt.n	801506e <fsm_rtermack+0xa6>
 8014fe0:	2b04      	cmp	r3, #4
 8014fe2:	d002      	beq.n	8014fea <fsm_rtermack+0x22>
 8014fe4:	2b05      	cmp	r3, #5
 8014fe6:	d015      	beq.n	8015014 <fsm_rtermack+0x4c>
	    (*f->callbacks->down)(f);	/* Inform upper layers */
	fsm_sconfreq(f, 0);
	f->state = PPP_FSM_REQSENT;
	break;
    default:
	break;
 8014fe8:	e041      	b.n	801506e <fsm_rtermack+0xa6>
	UNTIMEOUT(fsm_timeout, f);
 8014fea:	687a      	ldr	r2, [r7, #4]
 8014fec:	4b24      	ldr	r3, [pc, #144]	; (8015080 <fsm_rtermack+0xb8>)
 8014fee:	0011      	movs	r1, r2
 8014ff0:	0018      	movs	r0, r3
 8014ff2:	f7fd f9ff 	bl	80123f4 <sys_untimeout>
	f->state = PPP_FSM_CLOSED;
 8014ff6:	687b      	ldr	r3, [r7, #4]
 8014ff8:	2202      	movs	r2, #2
 8014ffa:	741a      	strb	r2, [r3, #16]
	if( f->callbacks->finished )
 8014ffc:	687b      	ldr	r3, [r7, #4]
 8014ffe:	685b      	ldr	r3, [r3, #4]
 8015000:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8015002:	2b00      	cmp	r3, #0
 8015004:	d035      	beq.n	8015072 <fsm_rtermack+0xaa>
	    (*f->callbacks->finished)(f);
 8015006:	687b      	ldr	r3, [r7, #4]
 8015008:	685b      	ldr	r3, [r3, #4]
 801500a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801500c:	687a      	ldr	r2, [r7, #4]
 801500e:	0010      	movs	r0, r2
 8015010:	4798      	blx	r3
	break;
 8015012:	e02e      	b.n	8015072 <fsm_rtermack+0xaa>
	UNTIMEOUT(fsm_timeout, f);
 8015014:	687a      	ldr	r2, [r7, #4]
 8015016:	4b1a      	ldr	r3, [pc, #104]	; (8015080 <fsm_rtermack+0xb8>)
 8015018:	0011      	movs	r1, r2
 801501a:	0018      	movs	r0, r3
 801501c:	f7fd f9ea 	bl	80123f4 <sys_untimeout>
	f->state = PPP_FSM_STOPPED;
 8015020:	687b      	ldr	r3, [r7, #4]
 8015022:	2203      	movs	r2, #3
 8015024:	741a      	strb	r2, [r3, #16]
	if( f->callbacks->finished )
 8015026:	687b      	ldr	r3, [r7, #4]
 8015028:	685b      	ldr	r3, [r3, #4]
 801502a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801502c:	2b00      	cmp	r3, #0
 801502e:	d022      	beq.n	8015076 <fsm_rtermack+0xae>
	    (*f->callbacks->finished)(f);
 8015030:	687b      	ldr	r3, [r7, #4]
 8015032:	685b      	ldr	r3, [r3, #4]
 8015034:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8015036:	687a      	ldr	r2, [r7, #4]
 8015038:	0010      	movs	r0, r2
 801503a:	4798      	blx	r3
	break;
 801503c:	e01b      	b.n	8015076 <fsm_rtermack+0xae>
	f->state = PPP_FSM_REQSENT;
 801503e:	687b      	ldr	r3, [r7, #4]
 8015040:	2206      	movs	r2, #6
 8015042:	741a      	strb	r2, [r3, #16]
	break;
 8015044:	e018      	b.n	8015078 <fsm_rtermack+0xb0>
	if (f->callbacks->down)
 8015046:	687b      	ldr	r3, [r7, #4]
 8015048:	685b      	ldr	r3, [r3, #4]
 801504a:	6a1b      	ldr	r3, [r3, #32]
 801504c:	2b00      	cmp	r3, #0
 801504e:	d005      	beq.n	801505c <fsm_rtermack+0x94>
	    (*f->callbacks->down)(f);	/* Inform upper layers */
 8015050:	687b      	ldr	r3, [r7, #4]
 8015052:	685b      	ldr	r3, [r3, #4]
 8015054:	6a1b      	ldr	r3, [r3, #32]
 8015056:	687a      	ldr	r2, [r7, #4]
 8015058:	0010      	movs	r0, r2
 801505a:	4798      	blx	r3
	fsm_sconfreq(f, 0);
 801505c:	687b      	ldr	r3, [r7, #4]
 801505e:	2100      	movs	r1, #0
 8015060:	0018      	movs	r0, r3
 8015062:	f000 f887 	bl	8015174 <fsm_sconfreq>
	f->state = PPP_FSM_REQSENT;
 8015066:	687b      	ldr	r3, [r7, #4]
 8015068:	2206      	movs	r2, #6
 801506a:	741a      	strb	r2, [r3, #16]
	break;
 801506c:	e004      	b.n	8015078 <fsm_rtermack+0xb0>
	break;
 801506e:	46c0      	nop			; (mov r8, r8)
 8015070:	e002      	b.n	8015078 <fsm_rtermack+0xb0>
	break;
 8015072:	46c0      	nop			; (mov r8, r8)
 8015074:	e000      	b.n	8015078 <fsm_rtermack+0xb0>
	break;
 8015076:	46c0      	nop			; (mov r8, r8)
    }
}
 8015078:	46c0      	nop			; (mov r8, r8)
 801507a:	46bd      	mov	sp, r7
 801507c:	b002      	add	sp, #8
 801507e:	bd80      	pop	{r7, pc}
 8015080:	08014851 	.word	0x08014851

08015084 <fsm_rcoderej>:


/*
 * fsm_rcoderej - Receive an Code-Reject.
 */
static void fsm_rcoderej(fsm *f, u_char *inp, int len) {
 8015084:	b590      	push	{r4, r7, lr}
 8015086:	b087      	sub	sp, #28
 8015088:	af00      	add	r7, sp, #0
 801508a:	60f8      	str	r0, [r7, #12]
 801508c:	60b9      	str	r1, [r7, #8]
 801508e:	607a      	str	r2, [r7, #4]
    u_char code, id;

    if (len < HEADERLEN) {
 8015090:	687b      	ldr	r3, [r7, #4]
 8015092:	2b03      	cmp	r3, #3
 8015094:	dd1f      	ble.n	80150d6 <fsm_rcoderej+0x52>
	FSMDEBUG(("fsm_rcoderej: Rcvd short Code-Reject packet!"));
	return;
    }
    GETCHAR(code, inp);
 8015096:	68bb      	ldr	r3, [r7, #8]
 8015098:	1c5a      	adds	r2, r3, #1
 801509a:	60ba      	str	r2, [r7, #8]
 801509c:	2017      	movs	r0, #23
 801509e:	183a      	adds	r2, r7, r0
 80150a0:	781b      	ldrb	r3, [r3, #0]
 80150a2:	7013      	strb	r3, [r2, #0]
    GETCHAR(id, inp);
 80150a4:	68bb      	ldr	r3, [r7, #8]
 80150a6:	1c5a      	adds	r2, r3, #1
 80150a8:	60ba      	str	r2, [r7, #8]
 80150aa:	2416      	movs	r4, #22
 80150ac:	193a      	adds	r2, r7, r4
 80150ae:	781b      	ldrb	r3, [r3, #0]
 80150b0:	7013      	strb	r3, [r2, #0]
    ppp_warn("%s: Rcvd Code-Reject for code %d, id %d", PROTO_NAME(f), code, id);
 80150b2:	68fb      	ldr	r3, [r7, #12]
 80150b4:	685b      	ldr	r3, [r3, #4]
 80150b6:	6b99      	ldr	r1, [r3, #56]	; 0x38
 80150b8:	183b      	adds	r3, r7, r0
 80150ba:	781a      	ldrb	r2, [r3, #0]
 80150bc:	193b      	adds	r3, r7, r4
 80150be:	781b      	ldrb	r3, [r3, #0]
 80150c0:	4807      	ldr	r0, [pc, #28]	; (80150e0 <fsm_rcoderej+0x5c>)
 80150c2:	f006 fbb8 	bl	801b836 <ppp_warn>

    if( f->state == PPP_FSM_ACKRCVD )
 80150c6:	68fb      	ldr	r3, [r7, #12]
 80150c8:	7c1b      	ldrb	r3, [r3, #16]
 80150ca:	2b07      	cmp	r3, #7
 80150cc:	d104      	bne.n	80150d8 <fsm_rcoderej+0x54>
	f->state = PPP_FSM_REQSENT;
 80150ce:	68fb      	ldr	r3, [r7, #12]
 80150d0:	2206      	movs	r2, #6
 80150d2:	741a      	strb	r2, [r3, #16]
 80150d4:	e000      	b.n	80150d8 <fsm_rcoderej+0x54>
	return;
 80150d6:	46c0      	nop			; (mov r8, r8)
}
 80150d8:	46bd      	mov	sp, r7
 80150da:	b007      	add	sp, #28
 80150dc:	bd90      	pop	{r4, r7, pc}
 80150de:	46c0      	nop			; (mov r8, r8)
 80150e0:	08021ac0 	.word	0x08021ac0

080150e4 <fsm_protreject>:
/*
 * fsm_protreject - Peer doesn't speak this protocol.
 *
 * Treat this as a catastrophic error (RXJ-).
 */
void fsm_protreject(fsm *f) {
 80150e4:	b580      	push	{r7, lr}
 80150e6:	b082      	sub	sp, #8
 80150e8:	af00      	add	r7, sp, #0
 80150ea:	6078      	str	r0, [r7, #4]
    switch( f->state ){
 80150ec:	687b      	ldr	r3, [r7, #4]
 80150ee:	7c1b      	ldrb	r3, [r3, #16]
 80150f0:	2b09      	cmp	r3, #9
 80150f2:	d837      	bhi.n	8015164 <fsm_protreject+0x80>
 80150f4:	009a      	lsls	r2, r3, #2
 80150f6:	4b1d      	ldr	r3, [pc, #116]	; (801516c <fsm_protreject+0x88>)
 80150f8:	18d3      	adds	r3, r2, r3
 80150fa:	681b      	ldr	r3, [r3, #0]
 80150fc:	469f      	mov	pc, r3
    case PPP_FSM_CLOSING:
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 80150fe:	687a      	ldr	r2, [r7, #4]
 8015100:	4b1b      	ldr	r3, [pc, #108]	; (8015170 <fsm_protreject+0x8c>)
 8015102:	0011      	movs	r1, r2
 8015104:	0018      	movs	r0, r3
 8015106:	f7fd f975 	bl	80123f4 <sys_untimeout>
	/* fall through */
	/* no break */
    case PPP_FSM_CLOSED:
	f->state = PPP_FSM_CLOSED;
 801510a:	687b      	ldr	r3, [r7, #4]
 801510c:	2202      	movs	r2, #2
 801510e:	741a      	strb	r2, [r3, #16]
	if( f->callbacks->finished )
 8015110:	687b      	ldr	r3, [r7, #4]
 8015112:	685b      	ldr	r3, [r3, #4]
 8015114:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8015116:	2b00      	cmp	r3, #0
 8015118:	d021      	beq.n	801515e <fsm_protreject+0x7a>
	    (*f->callbacks->finished)(f);
 801511a:	687b      	ldr	r3, [r7, #4]
 801511c:	685b      	ldr	r3, [r3, #4]
 801511e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8015120:	687a      	ldr	r2, [r7, #4]
 8015122:	0010      	movs	r0, r2
 8015124:	4798      	blx	r3
	break;
 8015126:	e01a      	b.n	801515e <fsm_protreject+0x7a>

    case PPP_FSM_STOPPING:
    case PPP_FSM_REQSENT:
    case PPP_FSM_ACKRCVD:
    case PPP_FSM_ACKSENT:
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 8015128:	687a      	ldr	r2, [r7, #4]
 801512a:	4b11      	ldr	r3, [pc, #68]	; (8015170 <fsm_protreject+0x8c>)
 801512c:	0011      	movs	r1, r2
 801512e:	0018      	movs	r0, r3
 8015130:	f7fd f960 	bl	80123f4 <sys_untimeout>
	/* fall through */
	/* no break */
    case PPP_FSM_STOPPED:
	f->state = PPP_FSM_STOPPED;
 8015134:	687b      	ldr	r3, [r7, #4]
 8015136:	2203      	movs	r2, #3
 8015138:	741a      	strb	r2, [r3, #16]
	if( f->callbacks->finished )
 801513a:	687b      	ldr	r3, [r7, #4]
 801513c:	685b      	ldr	r3, [r3, #4]
 801513e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8015140:	2b00      	cmp	r3, #0
 8015142:	d00e      	beq.n	8015162 <fsm_protreject+0x7e>
	    (*f->callbacks->finished)(f);
 8015144:	687b      	ldr	r3, [r7, #4]
 8015146:	685b      	ldr	r3, [r3, #4]
 8015148:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801514a:	687a      	ldr	r2, [r7, #4]
 801514c:	0010      	movs	r0, r2
 801514e:	4798      	blx	r3
	break;
 8015150:	e007      	b.n	8015162 <fsm_protreject+0x7e>

    case PPP_FSM_OPENED:
	terminate_layer(f, PPP_FSM_STOPPING);
 8015152:	687b      	ldr	r3, [r7, #4]
 8015154:	2105      	movs	r1, #5
 8015156:	0018      	movs	r0, r3
 8015158:	f7ff fac0 	bl	80146dc <terminate_layer>
	break;
 801515c:	e002      	b.n	8015164 <fsm_protreject+0x80>
	break;
 801515e:	46c0      	nop			; (mov r8, r8)
 8015160:	e000      	b.n	8015164 <fsm_protreject+0x80>
	break;
 8015162:	46c0      	nop			; (mov r8, r8)
    default:
	FSMDEBUG(("%s: Protocol-reject event in state %d!",
		  PROTO_NAME(f), f->state));
	/* no break */
    }
}
 8015164:	46c0      	nop			; (mov r8, r8)
 8015166:	46bd      	mov	sp, r7
 8015168:	b002      	add	sp, #8
 801516a:	bd80      	pop	{r7, pc}
 801516c:	08022964 	.word	0x08022964
 8015170:	08014851 	.word	0x08014851

08015174 <fsm_sconfreq>:


/*
 * fsm_sconfreq - Send a Configure-Request.
 */
static void fsm_sconfreq(fsm *f, int retransmit) {
 8015174:	b580      	push	{r7, lr}
 8015176:	b086      	sub	sp, #24
 8015178:	af00      	add	r7, sp, #0
 801517a:	6078      	str	r0, [r7, #4]
 801517c:	6039      	str	r1, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 801517e:	687b      	ldr	r3, [r7, #4]
 8015180:	681b      	ldr	r3, [r3, #0]
 8015182:	617b      	str	r3, [r7, #20]
    struct pbuf *p;
    u_char *outp;
    int cilen;

    if( f->state != PPP_FSM_REQSENT && f->state != PPP_FSM_ACKRCVD && f->state != PPP_FSM_ACKSENT ){
 8015184:	687b      	ldr	r3, [r7, #4]
 8015186:	7c1b      	ldrb	r3, [r3, #16]
 8015188:	2b06      	cmp	r3, #6
 801518a:	d018      	beq.n	80151be <fsm_sconfreq+0x4a>
 801518c:	687b      	ldr	r3, [r7, #4]
 801518e:	7c1b      	ldrb	r3, [r3, #16]
 8015190:	2b07      	cmp	r3, #7
 8015192:	d014      	beq.n	80151be <fsm_sconfreq+0x4a>
 8015194:	687b      	ldr	r3, [r7, #4]
 8015196:	7c1b      	ldrb	r3, [r3, #16]
 8015198:	2b08      	cmp	r3, #8
 801519a:	d010      	beq.n	80151be <fsm_sconfreq+0x4a>
	/* Not currently negotiating - reset options */
	if( f->callbacks->resetci )
 801519c:	687b      	ldr	r3, [r7, #4]
 801519e:	685b      	ldr	r3, [r3, #4]
 80151a0:	681b      	ldr	r3, [r3, #0]
 80151a2:	2b00      	cmp	r3, #0
 80151a4:	d005      	beq.n	80151b2 <fsm_sconfreq+0x3e>
	    (*f->callbacks->resetci)(f);
 80151a6:	687b      	ldr	r3, [r7, #4]
 80151a8:	685b      	ldr	r3, [r3, #4]
 80151aa:	681b      	ldr	r3, [r3, #0]
 80151ac:	687a      	ldr	r2, [r7, #4]
 80151ae:	0010      	movs	r0, r2
 80151b0:	4798      	blx	r3
	f->nakloops = 0;
 80151b2:	687b      	ldr	r3, [r7, #4]
 80151b4:	2200      	movs	r2, #0
 80151b6:	755a      	strb	r2, [r3, #21]
	f->rnakloops = 0;
 80151b8:	687b      	ldr	r3, [r7, #4]
 80151ba:	2200      	movs	r2, #0
 80151bc:	759a      	strb	r2, [r3, #22]
    }

    if( !retransmit ){
 80151be:	683b      	ldr	r3, [r7, #0]
 80151c0:	2b00      	cmp	r3, #0
 80151c2:	d10d      	bne.n	80151e0 <fsm_sconfreq+0x6c>
	/* New request - reset retransmission counter, use new ID */
	f->retransmits = pcb->settings.fsm_max_conf_req_transmits;
 80151c4:	697b      	ldr	r3, [r7, #20]
 80151c6:	795a      	ldrb	r2, [r3, #5]
 80151c8:	687b      	ldr	r3, [r7, #4]
 80151ca:	751a      	strb	r2, [r3, #20]
	f->reqid = ++f->id;
 80151cc:	687b      	ldr	r3, [r7, #4]
 80151ce:	7c9b      	ldrb	r3, [r3, #18]
 80151d0:	3301      	adds	r3, #1
 80151d2:	b2da      	uxtb	r2, r3
 80151d4:	687b      	ldr	r3, [r7, #4]
 80151d6:	749a      	strb	r2, [r3, #18]
 80151d8:	687b      	ldr	r3, [r7, #4]
 80151da:	7c9a      	ldrb	r2, [r3, #18]
 80151dc:	687b      	ldr	r3, [r7, #4]
 80151de:	74da      	strb	r2, [r3, #19]
    }

    f->seen_ack = 0;
 80151e0:	687b      	ldr	r3, [r7, #4]
 80151e2:	2200      	movs	r2, #0
 80151e4:	731a      	strb	r2, [r3, #12]

    /*
     * Make up the request packet
     */
    if( f->callbacks->cilen && f->callbacks->addci ){
 80151e6:	687b      	ldr	r3, [r7, #4]
 80151e8:	685b      	ldr	r3, [r3, #4]
 80151ea:	685b      	ldr	r3, [r3, #4]
 80151ec:	2b00      	cmp	r3, #0
 80151ee:	d019      	beq.n	8015224 <fsm_sconfreq+0xb0>
 80151f0:	687b      	ldr	r3, [r7, #4]
 80151f2:	685b      	ldr	r3, [r3, #4]
 80151f4:	689b      	ldr	r3, [r3, #8]
 80151f6:	2b00      	cmp	r3, #0
 80151f8:	d014      	beq.n	8015224 <fsm_sconfreq+0xb0>
	cilen = (*f->callbacks->cilen)(f);
 80151fa:	687b      	ldr	r3, [r7, #4]
 80151fc:	685b      	ldr	r3, [r3, #4]
 80151fe:	685b      	ldr	r3, [r3, #4]
 8015200:	687a      	ldr	r2, [r7, #4]
 8015202:	0010      	movs	r0, r2
 8015204:	4798      	blx	r3
 8015206:	0003      	movs	r3, r0
 8015208:	60bb      	str	r3, [r7, #8]
	if( cilen > pcb->peer_mru - HEADERLEN )
 801520a:	697b      	ldr	r3, [r7, #20]
 801520c:	22d4      	movs	r2, #212	; 0xd4
 801520e:	5a9b      	ldrh	r3, [r3, r2]
 8015210:	1eda      	subs	r2, r3, #3
 8015212:	68bb      	ldr	r3, [r7, #8]
 8015214:	429a      	cmp	r2, r3
 8015216:	dc07      	bgt.n	8015228 <fsm_sconfreq+0xb4>
	    cilen = pcb->peer_mru - HEADERLEN;
 8015218:	697b      	ldr	r3, [r7, #20]
 801521a:	22d4      	movs	r2, #212	; 0xd4
 801521c:	5a9b      	ldrh	r3, [r3, r2]
 801521e:	3b04      	subs	r3, #4
 8015220:	60bb      	str	r3, [r7, #8]
	if( cilen > pcb->peer_mru - HEADERLEN )
 8015222:	e001      	b.n	8015228 <fsm_sconfreq+0xb4>
    } else
	cilen = 0;
 8015224:	2300      	movs	r3, #0
 8015226:	60bb      	str	r3, [r7, #8]

    p = pbuf_alloc(PBUF_RAW, (u16_t)(cilen + HEADERLEN + PPP_HDRLEN), PPP_CTRL_PBUF_TYPE);
 8015228:	68bb      	ldr	r3, [r7, #8]
 801522a:	b29b      	uxth	r3, r3
 801522c:	3308      	adds	r3, #8
 801522e:	b29b      	uxth	r3, r3
 8015230:	22c1      	movs	r2, #193	; 0xc1
 8015232:	0052      	lsls	r2, r2, #1
 8015234:	0019      	movs	r1, r3
 8015236:	2000      	movs	r0, #0
 8015238:	f7f4 fac8 	bl	80097cc <pbuf_alloc>
 801523c:	0003      	movs	r3, r0
 801523e:	613b      	str	r3, [r7, #16]
    if(NULL == p)
 8015240:	693b      	ldr	r3, [r7, #16]
 8015242:	2b00      	cmp	r3, #0
 8015244:	d100      	bne.n	8015248 <fsm_sconfreq+0xd4>
 8015246:	e07c      	b.n	8015342 <fsm_sconfreq+0x1ce>
        return;
    if(p->tot_len != p->len) {
 8015248:	693b      	ldr	r3, [r7, #16]
 801524a:	891a      	ldrh	r2, [r3, #8]
 801524c:	693b      	ldr	r3, [r7, #16]
 801524e:	895b      	ldrh	r3, [r3, #10]
 8015250:	429a      	cmp	r2, r3
 8015252:	d004      	beq.n	801525e <fsm_sconfreq+0xea>
        pbuf_free(p);
 8015254:	693b      	ldr	r3, [r7, #16]
 8015256:	0018      	movs	r0, r3
 8015258:	f7f4 fe30 	bl	8009ebc <pbuf_free>
        return;
 801525c:	e072      	b.n	8015344 <fsm_sconfreq+0x1d0>
    }

    /* send the request to our peer */
    outp = (u_char*)p->payload;
 801525e:	693b      	ldr	r3, [r7, #16]
 8015260:	685b      	ldr	r3, [r3, #4]
 8015262:	60fb      	str	r3, [r7, #12]
    MAKEHEADER(outp, f->protocol);
 8015264:	68fb      	ldr	r3, [r7, #12]
 8015266:	1c5a      	adds	r2, r3, #1
 8015268:	60fa      	str	r2, [r7, #12]
 801526a:	22ff      	movs	r2, #255	; 0xff
 801526c:	701a      	strb	r2, [r3, #0]
 801526e:	68fb      	ldr	r3, [r7, #12]
 8015270:	1c5a      	adds	r2, r3, #1
 8015272:	60fa      	str	r2, [r7, #12]
 8015274:	2203      	movs	r2, #3
 8015276:	701a      	strb	r2, [r3, #0]
 8015278:	687b      	ldr	r3, [r7, #4]
 801527a:	89db      	ldrh	r3, [r3, #14]
 801527c:	0a1b      	lsrs	r3, r3, #8
 801527e:	b299      	uxth	r1, r3
 8015280:	68fb      	ldr	r3, [r7, #12]
 8015282:	1c5a      	adds	r2, r3, #1
 8015284:	60fa      	str	r2, [r7, #12]
 8015286:	b2ca      	uxtb	r2, r1
 8015288:	701a      	strb	r2, [r3, #0]
 801528a:	687b      	ldr	r3, [r7, #4]
 801528c:	89d9      	ldrh	r1, [r3, #14]
 801528e:	68fb      	ldr	r3, [r7, #12]
 8015290:	1c5a      	adds	r2, r3, #1
 8015292:	60fa      	str	r2, [r7, #12]
 8015294:	b2ca      	uxtb	r2, r1
 8015296:	701a      	strb	r2, [r3, #0]
    PUTCHAR(CONFREQ, outp);
 8015298:	68fb      	ldr	r3, [r7, #12]
 801529a:	1c5a      	adds	r2, r3, #1
 801529c:	60fa      	str	r2, [r7, #12]
 801529e:	2201      	movs	r2, #1
 80152a0:	701a      	strb	r2, [r3, #0]
    PUTCHAR(f->reqid, outp);
 80152a2:	68fb      	ldr	r3, [r7, #12]
 80152a4:	1c5a      	adds	r2, r3, #1
 80152a6:	60fa      	str	r2, [r7, #12]
 80152a8:	687a      	ldr	r2, [r7, #4]
 80152aa:	7cd2      	ldrb	r2, [r2, #19]
 80152ac:	701a      	strb	r2, [r3, #0]
    PUTSHORT(cilen + HEADERLEN, outp);
 80152ae:	68bb      	ldr	r3, [r7, #8]
 80152b0:	3304      	adds	r3, #4
 80152b2:	1219      	asrs	r1, r3, #8
 80152b4:	68fb      	ldr	r3, [r7, #12]
 80152b6:	1c5a      	adds	r2, r3, #1
 80152b8:	60fa      	str	r2, [r7, #12]
 80152ba:	b2ca      	uxtb	r2, r1
 80152bc:	701a      	strb	r2, [r3, #0]
 80152be:	68bb      	ldr	r3, [r7, #8]
 80152c0:	b2da      	uxtb	r2, r3
 80152c2:	68fb      	ldr	r3, [r7, #12]
 80152c4:	1c59      	adds	r1, r3, #1
 80152c6:	60f9      	str	r1, [r7, #12]
 80152c8:	3204      	adds	r2, #4
 80152ca:	b2d2      	uxtb	r2, r2
 80152cc:	701a      	strb	r2, [r3, #0]
    if (cilen != 0) {
 80152ce:	68bb      	ldr	r3, [r7, #8]
 80152d0:	2b00      	cmp	r3, #0
 80152d2:	d014      	beq.n	80152fe <fsm_sconfreq+0x18a>
	(*f->callbacks->addci)(f, outp, &cilen);
 80152d4:	687b      	ldr	r3, [r7, #4]
 80152d6:	685b      	ldr	r3, [r3, #4]
 80152d8:	689b      	ldr	r3, [r3, #8]
 80152da:	2208      	movs	r2, #8
 80152dc:	18ba      	adds	r2, r7, r2
 80152de:	68f9      	ldr	r1, [r7, #12]
 80152e0:	6878      	ldr	r0, [r7, #4]
 80152e2:	4798      	blx	r3
	LWIP_ASSERT("cilen == p->len - HEADERLEN - PPP_HDRLEN", cilen == p->len - HEADERLEN - PPP_HDRLEN);
 80152e4:	693b      	ldr	r3, [r7, #16]
 80152e6:	895b      	ldrh	r3, [r3, #10]
 80152e8:	3b08      	subs	r3, #8
 80152ea:	001a      	movs	r2, r3
 80152ec:	68bb      	ldr	r3, [r7, #8]
 80152ee:	429a      	cmp	r2, r3
 80152f0:	d005      	beq.n	80152fe <fsm_sconfreq+0x18a>
 80152f2:	4b16      	ldr	r3, [pc, #88]	; (801534c <fsm_sconfreq+0x1d8>)
 80152f4:	4a16      	ldr	r2, [pc, #88]	; (8015350 <fsm_sconfreq+0x1dc>)
 80152f6:	4917      	ldr	r1, [pc, #92]	; (8015354 <fsm_sconfreq+0x1e0>)
 80152f8:	4817      	ldr	r0, [pc, #92]	; (8015358 <fsm_sconfreq+0x1e4>)
 80152fa:	f7ed fc65 	bl	8002bc8 <app_debug_rtt_raw>
    }

    ppp_write(pcb, p);
 80152fe:	693a      	ldr	r2, [r7, #16]
 8015300:	697b      	ldr	r3, [r7, #20]
 8015302:	0011      	movs	r1, r2
 8015304:	0018      	movs	r0, r3
 8015306:	f004 ffb5 	bl	801a274 <ppp_write>

    /* start the retransmit timer */
    --f->retransmits;
 801530a:	687b      	ldr	r3, [r7, #4]
 801530c:	7d1b      	ldrb	r3, [r3, #20]
 801530e:	3b01      	subs	r3, #1
 8015310:	b2da      	uxtb	r2, r3
 8015312:	687b      	ldr	r3, [r7, #4]
 8015314:	751a      	strb	r2, [r3, #20]
    TIMEOUT(fsm_timeout, f, pcb->settings.fsm_timeout_time);
 8015316:	687a      	ldr	r2, [r7, #4]
 8015318:	4b10      	ldr	r3, [pc, #64]	; (801535c <fsm_sconfreq+0x1e8>)
 801531a:	0011      	movs	r1, r2
 801531c:	0018      	movs	r0, r3
 801531e:	f7fd f869 	bl	80123f4 <sys_untimeout>
 8015322:	697b      	ldr	r3, [r7, #20]
 8015324:	791b      	ldrb	r3, [r3, #4]
 8015326:	001a      	movs	r2, r3
 8015328:	0013      	movs	r3, r2
 801532a:	015b      	lsls	r3, r3, #5
 801532c:	1a9b      	subs	r3, r3, r2
 801532e:	009b      	lsls	r3, r3, #2
 8015330:	189b      	adds	r3, r3, r2
 8015332:	00db      	lsls	r3, r3, #3
 8015334:	0018      	movs	r0, r3
 8015336:	687a      	ldr	r2, [r7, #4]
 8015338:	4b08      	ldr	r3, [pc, #32]	; (801535c <fsm_sconfreq+0x1e8>)
 801533a:	0019      	movs	r1, r3
 801533c:	f7fd f832 	bl	80123a4 <sys_timeout>
 8015340:	e000      	b.n	8015344 <fsm_sconfreq+0x1d0>
        return;
 8015342:	46c0      	nop			; (mov r8, r8)
}
 8015344:	46bd      	mov	sp, r7
 8015346:	b006      	add	sp, #24
 8015348:	bd80      	pop	{r7, pc}
 801534a:	46c0      	nop			; (mov r8, r8)
 801534c:	08021ae8 	.word	0x08021ae8
 8015350:	000002f2 	.word	0x000002f2
 8015354:	08021b14 	.word	0x08021b14
 8015358:	08021b40 	.word	0x08021b40
 801535c:	08014851 	.word	0x08014851

08015360 <fsm_sdata>:
/*
 * fsm_sdata - Send some data.
 *
 * Used for all packets sent to our peer by this module.
 */
void fsm_sdata(fsm *f, u_char code, u_char id, const u_char *data, int datalen) {
 8015360:	b580      	push	{r7, lr}
 8015362:	b088      	sub	sp, #32
 8015364:	af00      	add	r7, sp, #0
 8015366:	60f8      	str	r0, [r7, #12]
 8015368:	0008      	movs	r0, r1
 801536a:	0011      	movs	r1, r2
 801536c:	607b      	str	r3, [r7, #4]
 801536e:	230b      	movs	r3, #11
 8015370:	18fb      	adds	r3, r7, r3
 8015372:	1c02      	adds	r2, r0, #0
 8015374:	701a      	strb	r2, [r3, #0]
 8015376:	230a      	movs	r3, #10
 8015378:	18fb      	adds	r3, r7, r3
 801537a:	1c0a      	adds	r2, r1, #0
 801537c:	701a      	strb	r2, [r3, #0]
    ppp_pcb *pcb = f->pcb;
 801537e:	68fb      	ldr	r3, [r7, #12]
 8015380:	681b      	ldr	r3, [r3, #0]
 8015382:	61fb      	str	r3, [r7, #28]
    struct pbuf *p;
    u_char *outp;
    int outlen;

    /* Adjust length to be smaller than MTU */
    if (datalen > pcb->peer_mru - HEADERLEN)
 8015384:	69fb      	ldr	r3, [r7, #28]
 8015386:	22d4      	movs	r2, #212	; 0xd4
 8015388:	5a9b      	ldrh	r3, [r3, r2]
 801538a:	3b03      	subs	r3, #3
 801538c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801538e:	429a      	cmp	r2, r3
 8015390:	db04      	blt.n	801539c <fsm_sdata+0x3c>
	datalen = pcb->peer_mru - HEADERLEN;
 8015392:	69fb      	ldr	r3, [r7, #28]
 8015394:	22d4      	movs	r2, #212	; 0xd4
 8015396:	5a9b      	ldrh	r3, [r3, r2]
 8015398:	3b04      	subs	r3, #4
 801539a:	62bb      	str	r3, [r7, #40]	; 0x28
    outlen = datalen + HEADERLEN;
 801539c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801539e:	3304      	adds	r3, #4
 80153a0:	61bb      	str	r3, [r7, #24]

    p = pbuf_alloc(PBUF_RAW, (u16_t)(outlen + PPP_HDRLEN), PPP_CTRL_PBUF_TYPE);
 80153a2:	69bb      	ldr	r3, [r7, #24]
 80153a4:	b29b      	uxth	r3, r3
 80153a6:	3304      	adds	r3, #4
 80153a8:	b29b      	uxth	r3, r3
 80153aa:	22c1      	movs	r2, #193	; 0xc1
 80153ac:	0052      	lsls	r2, r2, #1
 80153ae:	0019      	movs	r1, r3
 80153b0:	2000      	movs	r0, #0
 80153b2:	f7f4 fa0b 	bl	80097cc <pbuf_alloc>
 80153b6:	0003      	movs	r3, r0
 80153b8:	617b      	str	r3, [r7, #20]
    if(NULL == p)
 80153ba:	697b      	ldr	r3, [r7, #20]
 80153bc:	2b00      	cmp	r3, #0
 80153be:	d053      	beq.n	8015468 <fsm_sdata+0x108>
        return;
    if(p->tot_len != p->len) {
 80153c0:	697b      	ldr	r3, [r7, #20]
 80153c2:	891a      	ldrh	r2, [r3, #8]
 80153c4:	697b      	ldr	r3, [r7, #20]
 80153c6:	895b      	ldrh	r3, [r3, #10]
 80153c8:	429a      	cmp	r2, r3
 80153ca:	d004      	beq.n	80153d6 <fsm_sdata+0x76>
        pbuf_free(p);
 80153cc:	697b      	ldr	r3, [r7, #20]
 80153ce:	0018      	movs	r0, r3
 80153d0:	f7f4 fd74 	bl	8009ebc <pbuf_free>
        return;
 80153d4:	e049      	b.n	801546a <fsm_sdata+0x10a>
    }

    outp = (u_char*)p->payload;
 80153d6:	697b      	ldr	r3, [r7, #20]
 80153d8:	685b      	ldr	r3, [r3, #4]
 80153da:	613b      	str	r3, [r7, #16]
    if (datalen) /* && data != outp + PPP_HDRLEN + HEADERLEN)  -- was only for fsm_sconfreq() */
 80153dc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80153de:	2b00      	cmp	r3, #0
 80153e0:	d006      	beq.n	80153f0 <fsm_sdata+0x90>
	MEMCPY(outp + PPP_HDRLEN + HEADERLEN, data, datalen);
 80153e2:	693b      	ldr	r3, [r7, #16]
 80153e4:	3308      	adds	r3, #8
 80153e6:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80153e8:	6879      	ldr	r1, [r7, #4]
 80153ea:	0018      	movs	r0, r3
 80153ec:	f007 fd6e 	bl	801cecc <memcpy>
    MAKEHEADER(outp, f->protocol);
 80153f0:	693b      	ldr	r3, [r7, #16]
 80153f2:	1c5a      	adds	r2, r3, #1
 80153f4:	613a      	str	r2, [r7, #16]
 80153f6:	22ff      	movs	r2, #255	; 0xff
 80153f8:	701a      	strb	r2, [r3, #0]
 80153fa:	693b      	ldr	r3, [r7, #16]
 80153fc:	1c5a      	adds	r2, r3, #1
 80153fe:	613a      	str	r2, [r7, #16]
 8015400:	2203      	movs	r2, #3
 8015402:	701a      	strb	r2, [r3, #0]
 8015404:	68fb      	ldr	r3, [r7, #12]
 8015406:	89db      	ldrh	r3, [r3, #14]
 8015408:	0a1b      	lsrs	r3, r3, #8
 801540a:	b299      	uxth	r1, r3
 801540c:	693b      	ldr	r3, [r7, #16]
 801540e:	1c5a      	adds	r2, r3, #1
 8015410:	613a      	str	r2, [r7, #16]
 8015412:	b2ca      	uxtb	r2, r1
 8015414:	701a      	strb	r2, [r3, #0]
 8015416:	68fb      	ldr	r3, [r7, #12]
 8015418:	89d9      	ldrh	r1, [r3, #14]
 801541a:	693b      	ldr	r3, [r7, #16]
 801541c:	1c5a      	adds	r2, r3, #1
 801541e:	613a      	str	r2, [r7, #16]
 8015420:	b2ca      	uxtb	r2, r1
 8015422:	701a      	strb	r2, [r3, #0]
    PUTCHAR(code, outp);
 8015424:	693b      	ldr	r3, [r7, #16]
 8015426:	1c5a      	adds	r2, r3, #1
 8015428:	613a      	str	r2, [r7, #16]
 801542a:	220b      	movs	r2, #11
 801542c:	18ba      	adds	r2, r7, r2
 801542e:	7812      	ldrb	r2, [r2, #0]
 8015430:	701a      	strb	r2, [r3, #0]
    PUTCHAR(id, outp);
 8015432:	693b      	ldr	r3, [r7, #16]
 8015434:	1c5a      	adds	r2, r3, #1
 8015436:	613a      	str	r2, [r7, #16]
 8015438:	220a      	movs	r2, #10
 801543a:	18ba      	adds	r2, r7, r2
 801543c:	7812      	ldrb	r2, [r2, #0]
 801543e:	701a      	strb	r2, [r3, #0]
    PUTSHORT(outlen, outp);
 8015440:	69bb      	ldr	r3, [r7, #24]
 8015442:	1219      	asrs	r1, r3, #8
 8015444:	693b      	ldr	r3, [r7, #16]
 8015446:	1c5a      	adds	r2, r3, #1
 8015448:	613a      	str	r2, [r7, #16]
 801544a:	b2ca      	uxtb	r2, r1
 801544c:	701a      	strb	r2, [r3, #0]
 801544e:	693b      	ldr	r3, [r7, #16]
 8015450:	1c5a      	adds	r2, r3, #1
 8015452:	613a      	str	r2, [r7, #16]
 8015454:	69ba      	ldr	r2, [r7, #24]
 8015456:	b2d2      	uxtb	r2, r2
 8015458:	701a      	strb	r2, [r3, #0]
    ppp_write(pcb, p);
 801545a:	697a      	ldr	r2, [r7, #20]
 801545c:	69fb      	ldr	r3, [r7, #28]
 801545e:	0011      	movs	r1, r2
 8015460:	0018      	movs	r0, r3
 8015462:	f004 ff07 	bl	801a274 <ppp_write>
 8015466:	e000      	b.n	801546a <fsm_sdata+0x10a>
        return;
 8015468:	46c0      	nop			; (mov r8, r8)
}
 801546a:	46bd      	mov	sp, r7
 801546c:	b008      	add	sp, #32
 801546e:	bd80      	pop	{r7, pc}

08015470 <ipcp_init>:
#endif /* PPP_OPTIONS */

/*
 * ipcp_init - Initialize IPCP.
 */
static void ipcp_init(ppp_pcb *pcb) {
 8015470:	b580      	push	{r7, lr}
 8015472:	b086      	sub	sp, #24
 8015474:	af00      	add	r7, sp, #0
 8015476:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->ipcp_fsm;
 8015478:	687b      	ldr	r3, [r7, #4]
 801547a:	4a34      	ldr	r2, [pc, #208]	; (801554c <ipcp_init+0xdc>)
 801547c:	4694      	mov	ip, r2
 801547e:	4463      	add	r3, ip
 8015480:	617b      	str	r3, [r7, #20]

    ipcp_options *wo = &pcb->ipcp_wantoptions;
 8015482:	687b      	ldr	r3, [r7, #4]
 8015484:	4a32      	ldr	r2, [pc, #200]	; (8015550 <ipcp_init+0xe0>)
 8015486:	4694      	mov	ip, r2
 8015488:	4463      	add	r3, ip
 801548a:	613b      	str	r3, [r7, #16]
    ipcp_options *ao = &pcb->ipcp_allowoptions;
 801548c:	687b      	ldr	r3, [r7, #4]
 801548e:	4a31      	ldr	r2, [pc, #196]	; (8015554 <ipcp_init+0xe4>)
 8015490:	4694      	mov	ip, r2
 8015492:	4463      	add	r3, ip
 8015494:	60fb      	str	r3, [r7, #12]

    f->pcb = pcb;
 8015496:	697b      	ldr	r3, [r7, #20]
 8015498:	687a      	ldr	r2, [r7, #4]
 801549a:	601a      	str	r2, [r3, #0]
    f->protocol = PPP_IPCP;
 801549c:	697b      	ldr	r3, [r7, #20]
 801549e:	4a2e      	ldr	r2, [pc, #184]	; (8015558 <ipcp_init+0xe8>)
 80154a0:	81da      	strh	r2, [r3, #14]
    f->callbacks = &ipcp_callbacks;
 80154a2:	697b      	ldr	r3, [r7, #20]
 80154a4:	4a2d      	ldr	r2, [pc, #180]	; (801555c <ipcp_init+0xec>)
 80154a6:	605a      	str	r2, [r3, #4]
    fsm_init(f);
 80154a8:	697b      	ldr	r3, [r7, #20]
 80154aa:	0018      	movs	r0, r3
 80154ac:	f7ff f83c 	bl	8014528 <fsm_init>
     * Some 3G modems use repeated IPCP NAKs as a way of stalling
     * until they can contact a server on the network, so we increase
     * the default number of NAKs we accept before we start treating
     * them as rejects.
     */
    f->maxnakloops = 100;
 80154b0:	697b      	ldr	r3, [r7, #20]
 80154b2:	2264      	movs	r2, #100	; 0x64
 80154b4:	75da      	strb	r2, [r3, #23]
#if 0 /* Not necessary, everything is cleared in ppp_new() */
    memset(wo, 0, sizeof(*wo));
    memset(ao, 0, sizeof(*ao));
#endif /* 0 */

    wo->neg_addr = wo->old_addrs = 1;
 80154b6:	693b      	ldr	r3, [r7, #16]
 80154b8:	781a      	ldrb	r2, [r3, #0]
 80154ba:	2102      	movs	r1, #2
 80154bc:	430a      	orrs	r2, r1
 80154be:	701a      	strb	r2, [r3, #0]
 80154c0:	693b      	ldr	r3, [r7, #16]
 80154c2:	781b      	ldrb	r3, [r3, #0]
 80154c4:	079b      	lsls	r3, r3, #30
 80154c6:	0fdb      	lsrs	r3, r3, #31
 80154c8:	b2da      	uxtb	r2, r3
 80154ca:	693b      	ldr	r3, [r7, #16]
 80154cc:	2101      	movs	r1, #1
 80154ce:	400a      	ands	r2, r1
 80154d0:	0010      	movs	r0, r2
 80154d2:	781a      	ldrb	r2, [r3, #0]
 80154d4:	2101      	movs	r1, #1
 80154d6:	438a      	bics	r2, r1
 80154d8:	1c11      	adds	r1, r2, #0
 80154da:	1c02      	adds	r2, r0, #0
 80154dc:	430a      	orrs	r2, r1
 80154de:	701a      	strb	r2, [r3, #0]
#if VJ_SUPPORT
    wo->neg_vj = 1;
 80154e0:	693b      	ldr	r3, [r7, #16]
 80154e2:	781a      	ldrb	r2, [r3, #0]
 80154e4:	2108      	movs	r1, #8
 80154e6:	430a      	orrs	r2, r1
 80154e8:	701a      	strb	r2, [r3, #0]
    wo->vj_protocol = IPCP_VJ_COMP;
 80154ea:	693b      	ldr	r3, [r7, #16]
 80154ec:	222d      	movs	r2, #45	; 0x2d
 80154ee:	829a      	strh	r2, [r3, #20]
    wo->maxslotindex = MAX_STATES - 1; /* really max index */
 80154f0:	693b      	ldr	r3, [r7, #16]
 80154f2:	220f      	movs	r2, #15
 80154f4:	759a      	strb	r2, [r3, #22]
    wo->cflag = 1;
 80154f6:	693b      	ldr	r3, [r7, #16]
 80154f8:	781a      	ldrb	r2, [r3, #0]
 80154fa:	2120      	movs	r1, #32
 80154fc:	430a      	orrs	r2, r1
 80154fe:	701a      	strb	r2, [r3, #0]
#if 0 /* UNUSED */
    /* wanting default route by default */
    wo->default_route = 1;
#endif /* UNUSED */

    ao->neg_addr = ao->old_addrs = 1;
 8015500:	68fb      	ldr	r3, [r7, #12]
 8015502:	781a      	ldrb	r2, [r3, #0]
 8015504:	2102      	movs	r1, #2
 8015506:	430a      	orrs	r2, r1
 8015508:	701a      	strb	r2, [r3, #0]
 801550a:	68fb      	ldr	r3, [r7, #12]
 801550c:	781b      	ldrb	r3, [r3, #0]
 801550e:	079b      	lsls	r3, r3, #30
 8015510:	0fdb      	lsrs	r3, r3, #31
 8015512:	b2da      	uxtb	r2, r3
 8015514:	68fb      	ldr	r3, [r7, #12]
 8015516:	2101      	movs	r1, #1
 8015518:	400a      	ands	r2, r1
 801551a:	0010      	movs	r0, r2
 801551c:	781a      	ldrb	r2, [r3, #0]
 801551e:	2101      	movs	r1, #1
 8015520:	438a      	bics	r2, r1
 8015522:	1c11      	adds	r1, r2, #0
 8015524:	1c02      	adds	r2, r0, #0
 8015526:	430a      	orrs	r2, r1
 8015528:	701a      	strb	r2, [r3, #0]
#if VJ_SUPPORT
    /* max slots and slot-id compression are currently hardwired in */
    /* ppp_if.c to 16 and 1, this needs to be changed (among other */
    /* things) gmc */

    ao->neg_vj = 1;
 801552a:	68fb      	ldr	r3, [r7, #12]
 801552c:	781a      	ldrb	r2, [r3, #0]
 801552e:	2108      	movs	r1, #8
 8015530:	430a      	orrs	r2, r1
 8015532:	701a      	strb	r2, [r3, #0]
    ao->maxslotindex = MAX_STATES - 1;
 8015534:	68fb      	ldr	r3, [r7, #12]
 8015536:	220f      	movs	r2, #15
 8015538:	759a      	strb	r2, [r3, #22]
    ao->cflag = 1;
 801553a:	68fb      	ldr	r3, [r7, #12]
 801553c:	781a      	ldrb	r2, [r3, #0]
 801553e:	2120      	movs	r1, #32
 8015540:	430a      	orrs	r2, r1
 8015542:	701a      	strb	r2, [r3, #0]
     * and defaultroute options.
     */
    ao->proxy_arp = 1;
    ao->default_route = 1;
#endif /* UNUSED */
}
 8015544:	46c0      	nop			; (mov r8, r8)
 8015546:	46bd      	mov	sp, r7
 8015548:	b006      	add	sp, #24
 801554a:	bd80      	pop	{r7, pc}
 801554c:	000011e8 	.word	0x000011e8
 8015550:	00001204 	.word	0x00001204
 8015554:	00001234 	.word	0x00001234
 8015558:	ffff8021 	.word	0xffff8021
 801555c:	0802298c 	.word	0x0802298c

08015560 <ipcp_open>:


/*
 * ipcp_open - IPCP is allowed to come up.
 */
static void ipcp_open(ppp_pcb *pcb) {
 8015560:	b580      	push	{r7, lr}
 8015562:	b084      	sub	sp, #16
 8015564:	af00      	add	r7, sp, #0
 8015566:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->ipcp_fsm;
 8015568:	687b      	ldr	r3, [r7, #4]
 801556a:	4a09      	ldr	r2, [pc, #36]	; (8015590 <ipcp_open+0x30>)
 801556c:	4694      	mov	ip, r2
 801556e:	4463      	add	r3, ip
 8015570:	60fb      	str	r3, [r7, #12]
    fsm_open(f);
 8015572:	68fb      	ldr	r3, [r7, #12]
 8015574:	0018      	movs	r0, r3
 8015576:	f7ff f865 	bl	8014644 <fsm_open>
    pcb->ipcp_is_open = 1;
 801557a:	687b      	ldr	r3, [r7, #4]
 801557c:	2226      	movs	r2, #38	; 0x26
 801557e:	5c99      	ldrb	r1, [r3, r2]
 8015580:	2002      	movs	r0, #2
 8015582:	4301      	orrs	r1, r0
 8015584:	5499      	strb	r1, [r3, r2]
}
 8015586:	46c0      	nop			; (mov r8, r8)
 8015588:	46bd      	mov	sp, r7
 801558a:	b004      	add	sp, #16
 801558c:	bd80      	pop	{r7, pc}
 801558e:	46c0      	nop			; (mov r8, r8)
 8015590:	000011e8 	.word	0x000011e8

08015594 <ipcp_close>:


/*
 * ipcp_close - Take IPCP down.
 */
static void ipcp_close(ppp_pcb *pcb, const char *reason) {
 8015594:	b580      	push	{r7, lr}
 8015596:	b084      	sub	sp, #16
 8015598:	af00      	add	r7, sp, #0
 801559a:	6078      	str	r0, [r7, #4]
 801559c:	6039      	str	r1, [r7, #0]
    fsm *f = &pcb->ipcp_fsm;
 801559e:	687b      	ldr	r3, [r7, #4]
 80155a0:	4a06      	ldr	r2, [pc, #24]	; (80155bc <ipcp_close+0x28>)
 80155a2:	4694      	mov	ip, r2
 80155a4:	4463      	add	r3, ip
 80155a6:	60fb      	str	r3, [r7, #12]
    fsm_close(f, reason);
 80155a8:	683a      	ldr	r2, [r7, #0]
 80155aa:	68fb      	ldr	r3, [r7, #12]
 80155ac:	0011      	movs	r1, r2
 80155ae:	0018      	movs	r0, r3
 80155b0:	f7ff f90a 	bl	80147c8 <fsm_close>
}
 80155b4:	46c0      	nop			; (mov r8, r8)
 80155b6:	46bd      	mov	sp, r7
 80155b8:	b004      	add	sp, #16
 80155ba:	bd80      	pop	{r7, pc}
 80155bc:	000011e8 	.word	0x000011e8

080155c0 <ipcp_lowerup>:


/*
 * ipcp_lowerup - The lower layer is up.
 */
static void ipcp_lowerup(ppp_pcb *pcb) {
 80155c0:	b580      	push	{r7, lr}
 80155c2:	b084      	sub	sp, #16
 80155c4:	af00      	add	r7, sp, #0
 80155c6:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->ipcp_fsm;
 80155c8:	687b      	ldr	r3, [r7, #4]
 80155ca:	4a06      	ldr	r2, [pc, #24]	; (80155e4 <ipcp_lowerup+0x24>)
 80155cc:	4694      	mov	ip, r2
 80155ce:	4463      	add	r3, ip
 80155d0:	60fb      	str	r3, [r7, #12]
    fsm_lowerup(f);
 80155d2:	68fb      	ldr	r3, [r7, #12]
 80155d4:	0018      	movs	r0, r3
 80155d6:	f7fe ffc2 	bl	801455e <fsm_lowerup>
}
 80155da:	46c0      	nop			; (mov r8, r8)
 80155dc:	46bd      	mov	sp, r7
 80155de:	b004      	add	sp, #16
 80155e0:	bd80      	pop	{r7, pc}
 80155e2:	46c0      	nop			; (mov r8, r8)
 80155e4:	000011e8 	.word	0x000011e8

080155e8 <ipcp_lowerdown>:


/*
 * ipcp_lowerdown - The lower layer is down.
 */
static void ipcp_lowerdown(ppp_pcb *pcb) {
 80155e8:	b580      	push	{r7, lr}
 80155ea:	b084      	sub	sp, #16
 80155ec:	af00      	add	r7, sp, #0
 80155ee:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->ipcp_fsm;
 80155f0:	687b      	ldr	r3, [r7, #4]
 80155f2:	4a06      	ldr	r2, [pc, #24]	; (801560c <ipcp_lowerdown+0x24>)
 80155f4:	4694      	mov	ip, r2
 80155f6:	4463      	add	r3, ip
 80155f8:	60fb      	str	r3, [r7, #12]
    fsm_lowerdown(f);
 80155fa:	68fb      	ldr	r3, [r7, #12]
 80155fc:	0018      	movs	r0, r3
 80155fe:	f7fe ffd5 	bl	80145ac <fsm_lowerdown>
}
 8015602:	46c0      	nop			; (mov r8, r8)
 8015604:	46bd      	mov	sp, r7
 8015606:	b004      	add	sp, #16
 8015608:	bd80      	pop	{r7, pc}
 801560a:	46c0      	nop			; (mov r8, r8)
 801560c:	000011e8 	.word	0x000011e8

08015610 <ipcp_input>:


/*
 * ipcp_input - Input IPCP packet.
 */
static void ipcp_input(ppp_pcb *pcb, u_char *p, int len) {
 8015610:	b580      	push	{r7, lr}
 8015612:	b086      	sub	sp, #24
 8015614:	af00      	add	r7, sp, #0
 8015616:	60f8      	str	r0, [r7, #12]
 8015618:	60b9      	str	r1, [r7, #8]
 801561a:	607a      	str	r2, [r7, #4]
    fsm *f = &pcb->ipcp_fsm;
 801561c:	68fb      	ldr	r3, [r7, #12]
 801561e:	4a07      	ldr	r2, [pc, #28]	; (801563c <ipcp_input+0x2c>)
 8015620:	4694      	mov	ip, r2
 8015622:	4463      	add	r3, ip
 8015624:	617b      	str	r3, [r7, #20]
    fsm_input(f, p, len);
 8015626:	687a      	ldr	r2, [r7, #4]
 8015628:	68b9      	ldr	r1, [r7, #8]
 801562a:	697b      	ldr	r3, [r7, #20]
 801562c:	0018      	movs	r0, r3
 801562e:	f7ff f9b5 	bl	801499c <fsm_input>
}
 8015632:	46c0      	nop			; (mov r8, r8)
 8015634:	46bd      	mov	sp, r7
 8015636:	b006      	add	sp, #24
 8015638:	bd80      	pop	{r7, pc}
 801563a:	46c0      	nop			; (mov r8, r8)
 801563c:	000011e8 	.word	0x000011e8

08015640 <ipcp_protrej>:
/*
 * ipcp_protrej - A Protocol-Reject was received for IPCP.
 *
 * Pretend the lower layer went down, so we shut up.
 */
static void ipcp_protrej(ppp_pcb *pcb) {
 8015640:	b580      	push	{r7, lr}
 8015642:	b084      	sub	sp, #16
 8015644:	af00      	add	r7, sp, #0
 8015646:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->ipcp_fsm;
 8015648:	687b      	ldr	r3, [r7, #4]
 801564a:	4a06      	ldr	r2, [pc, #24]	; (8015664 <ipcp_protrej+0x24>)
 801564c:	4694      	mov	ip, r2
 801564e:	4463      	add	r3, ip
 8015650:	60fb      	str	r3, [r7, #12]
    fsm_lowerdown(f);
 8015652:	68fb      	ldr	r3, [r7, #12]
 8015654:	0018      	movs	r0, r3
 8015656:	f7fe ffa9 	bl	80145ac <fsm_lowerdown>
}
 801565a:	46c0      	nop			; (mov r8, r8)
 801565c:	46bd      	mov	sp, r7
 801565e:	b004      	add	sp, #16
 8015660:	bd80      	pop	{r7, pc}
 8015662:	46c0      	nop			; (mov r8, r8)
 8015664:	000011e8 	.word	0x000011e8

08015668 <ipcp_resetci>:

/*
 * ipcp_resetci - Reset our CI.
 * Called by fsm_sconfreq, Send Configure Request.
 */
static void ipcp_resetci(fsm *f) {
 8015668:	b590      	push	{r4, r7, lr}
 801566a:	b087      	sub	sp, #28
 801566c:	af00      	add	r7, sp, #0
 801566e:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8015670:	687b      	ldr	r3, [r7, #4]
 8015672:	681b      	ldr	r3, [r3, #0]
 8015674:	617b      	str	r3, [r7, #20]
    ipcp_options *wo = &pcb->ipcp_wantoptions;
 8015676:	697b      	ldr	r3, [r7, #20]
 8015678:	4a46      	ldr	r2, [pc, #280]	; (8015794 <ipcp_resetci+0x12c>)
 801567a:	4694      	mov	ip, r2
 801567c:	4463      	add	r3, ip
 801567e:	613b      	str	r3, [r7, #16]
    ipcp_options *go = &pcb->ipcp_gotoptions;
 8015680:	697b      	ldr	r3, [r7, #20]
 8015682:	4a45      	ldr	r2, [pc, #276]	; (8015798 <ipcp_resetci+0x130>)
 8015684:	4694      	mov	ip, r2
 8015686:	4463      	add	r3, ip
 8015688:	60fb      	str	r3, [r7, #12]
    ipcp_options *ao = &pcb->ipcp_allowoptions;
 801568a:	697b      	ldr	r3, [r7, #20]
 801568c:	4a43      	ldr	r2, [pc, #268]	; (801579c <ipcp_resetci+0x134>)
 801568e:	4694      	mov	ip, r2
 8015690:	4463      	add	r3, ip
 8015692:	60bb      	str	r3, [r7, #8]

    wo->req_addr = (wo->neg_addr || wo->old_addrs) &&
 8015694:	693b      	ldr	r3, [r7, #16]
 8015696:	781b      	ldrb	r3, [r3, #0]
 8015698:	2201      	movs	r2, #1
 801569a:	4013      	ands	r3, r2
 801569c:	b2db      	uxtb	r3, r3
 801569e:	2b00      	cmp	r3, #0
 80156a0:	d106      	bne.n	80156b0 <ipcp_resetci+0x48>
 80156a2:	693b      	ldr	r3, [r7, #16]
 80156a4:	781b      	ldrb	r3, [r3, #0]
 80156a6:	2202      	movs	r2, #2
 80156a8:	4013      	ands	r3, r2
 80156aa:	b2db      	uxtb	r3, r3
 80156ac:	2b00      	cmp	r3, #0
 80156ae:	d00f      	beq.n	80156d0 <ipcp_resetci+0x68>
	(ao->neg_addr || ao->old_addrs);
 80156b0:	68bb      	ldr	r3, [r7, #8]
 80156b2:	781b      	ldrb	r3, [r3, #0]
 80156b4:	2201      	movs	r2, #1
 80156b6:	4013      	ands	r3, r2
 80156b8:	b2db      	uxtb	r3, r3
    wo->req_addr = (wo->neg_addr || wo->old_addrs) &&
 80156ba:	2b00      	cmp	r3, #0
 80156bc:	d106      	bne.n	80156cc <ipcp_resetci+0x64>
	(ao->neg_addr || ao->old_addrs);
 80156be:	68bb      	ldr	r3, [r7, #8]
 80156c0:	781b      	ldrb	r3, [r3, #0]
 80156c2:	2202      	movs	r2, #2
 80156c4:	4013      	ands	r3, r2
 80156c6:	b2db      	uxtb	r3, r3
 80156c8:	2b00      	cmp	r3, #0
 80156ca:	d001      	beq.n	80156d0 <ipcp_resetci+0x68>
    wo->req_addr = (wo->neg_addr || wo->old_addrs) &&
 80156cc:	2301      	movs	r3, #1
 80156ce:	e000      	b.n	80156d2 <ipcp_resetci+0x6a>
 80156d0:	2300      	movs	r3, #0
 80156d2:	1c1a      	adds	r2, r3, #0
 80156d4:	2301      	movs	r3, #1
 80156d6:	4013      	ands	r3, r2
 80156d8:	b2da      	uxtb	r2, r3
 80156da:	693b      	ldr	r3, [r7, #16]
 80156dc:	2101      	movs	r1, #1
 80156de:	400a      	ands	r2, r1
 80156e0:	0090      	lsls	r0, r2, #2
 80156e2:	781a      	ldrb	r2, [r3, #0]
 80156e4:	2104      	movs	r1, #4
 80156e6:	438a      	bics	r2, r1
 80156e8:	1c11      	adds	r1, r2, #0
 80156ea:	1c02      	adds	r2, r0, #0
 80156ec:	430a      	orrs	r2, r1
 80156ee:	701a      	strb	r2, [r3, #0]
    if (wo->ouraddr == 0)
 80156f0:	693b      	ldr	r3, [r7, #16]
 80156f2:	685b      	ldr	r3, [r3, #4]
 80156f4:	2b00      	cmp	r3, #0
 80156f6:	d104      	bne.n	8015702 <ipcp_resetci+0x9a>
	wo->accept_local = 1;
 80156f8:	693b      	ldr	r3, [r7, #16]
 80156fa:	781a      	ldrb	r2, [r3, #0]
 80156fc:	2140      	movs	r1, #64	; 0x40
 80156fe:	430a      	orrs	r2, r1
 8015700:	701a      	strb	r2, [r3, #0]
    if (wo->hisaddr == 0)
 8015702:	693b      	ldr	r3, [r7, #16]
 8015704:	689b      	ldr	r3, [r3, #8]
 8015706:	2b00      	cmp	r3, #0
 8015708:	d105      	bne.n	8015716 <ipcp_resetci+0xae>
	wo->accept_remote = 1;
 801570a:	693b      	ldr	r3, [r7, #16]
 801570c:	781a      	ldrb	r2, [r3, #0]
 801570e:	2180      	movs	r1, #128	; 0x80
 8015710:	4249      	negs	r1, r1
 8015712:	430a      	orrs	r2, r1
 8015714:	701a      	strb	r2, [r3, #0]
#if LWIP_DNS
    wo->req_dns1 = wo->req_dns2 = pcb->settings.usepeerdns;	/* Request DNS addresses from the peer */
 8015716:	697b      	ldr	r3, [r7, #20]
 8015718:	781b      	ldrb	r3, [r3, #0]
 801571a:	07db      	lsls	r3, r3, #31
 801571c:	0fdb      	lsrs	r3, r3, #31
 801571e:	b2da      	uxtb	r2, r3
 8015720:	693b      	ldr	r3, [r7, #16]
 8015722:	2101      	movs	r1, #1
 8015724:	400a      	ands	r2, r1
 8015726:	1890      	adds	r0, r2, r2
 8015728:	785a      	ldrb	r2, [r3, #1]
 801572a:	2102      	movs	r1, #2
 801572c:	438a      	bics	r2, r1
 801572e:	1c11      	adds	r1, r2, #0
 8015730:	1c02      	adds	r2, r0, #0
 8015732:	430a      	orrs	r2, r1
 8015734:	705a      	strb	r2, [r3, #1]
 8015736:	693b      	ldr	r3, [r7, #16]
 8015738:	785b      	ldrb	r3, [r3, #1]
 801573a:	079b      	lsls	r3, r3, #30
 801573c:	0fdb      	lsrs	r3, r3, #31
 801573e:	b2da      	uxtb	r2, r3
 8015740:	693b      	ldr	r3, [r7, #16]
 8015742:	2101      	movs	r1, #1
 8015744:	400a      	ands	r2, r1
 8015746:	0010      	movs	r0, r2
 8015748:	785a      	ldrb	r2, [r3, #1]
 801574a:	2101      	movs	r1, #1
 801574c:	438a      	bics	r2, r1
 801574e:	1c11      	adds	r1, r2, #0
 8015750:	1c02      	adds	r2, r0, #0
 8015752:	430a      	orrs	r2, r1
 8015754:	705a      	strb	r2, [r3, #1]
#endif /* LWIP_DNS */
    *go = *wo;
 8015756:	68fb      	ldr	r3, [r7, #12]
 8015758:	693a      	ldr	r2, [r7, #16]
 801575a:	ca13      	ldmia	r2!, {r0, r1, r4}
 801575c:	c313      	stmia	r3!, {r0, r1, r4}
 801575e:	ca13      	ldmia	r2!, {r0, r1, r4}
 8015760:	c313      	stmia	r3!, {r0, r1, r4}
    if (!pcb->ask_for_local)
 8015762:	697b      	ldr	r3, [r7, #20]
 8015764:	2226      	movs	r2, #38	; 0x26
 8015766:	5c9b      	ldrb	r3, [r3, r2]
 8015768:	2201      	movs	r2, #1
 801576a:	4013      	ands	r3, r2
 801576c:	b2db      	uxtb	r3, r3
 801576e:	2b00      	cmp	r3, #0
 8015770:	d102      	bne.n	8015778 <ipcp_resetci+0x110>
	go->ouraddr = 0;
 8015772:	68fb      	ldr	r3, [r7, #12]
 8015774:	2200      	movs	r2, #0
 8015776:	605a      	str	r2, [r3, #4]
	if (wo->hisaddr) {
	    wo->accept_remote = 0;
	}
    }
#endif /* UNUSED */
    BZERO(&pcb->ipcp_hisoptions, sizeof(ipcp_options));
 8015778:	697b      	ldr	r3, [r7, #20]
 801577a:	4a09      	ldr	r2, [pc, #36]	; (80157a0 <ipcp_resetci+0x138>)
 801577c:	4694      	mov	ip, r2
 801577e:	4463      	add	r3, ip
 8015780:	2218      	movs	r2, #24
 8015782:	2100      	movs	r1, #0
 8015784:	0018      	movs	r0, r3
 8015786:	f007 fbbd 	bl	801cf04 <memset>
}
 801578a:	46c0      	nop			; (mov r8, r8)
 801578c:	46bd      	mov	sp, r7
 801578e:	b007      	add	sp, #28
 8015790:	bd90      	pop	{r4, r7, pc}
 8015792:	46c0      	nop			; (mov r8, r8)
 8015794:	00001204 	.word	0x00001204
 8015798:	0000121c 	.word	0x0000121c
 801579c:	00001234 	.word	0x00001234
 80157a0:	0000124c 	.word	0x0000124c

080157a4 <ipcp_cilen>:

/*
 * ipcp_cilen - Return length of our CI.
 * Called by fsm_sconfreq, Send Configure Request.
 */
static int ipcp_cilen(fsm *f) {
 80157a4:	b580      	push	{r7, lr}
 80157a6:	b086      	sub	sp, #24
 80157a8:	af00      	add	r7, sp, #0
 80157aa:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 80157ac:	687b      	ldr	r3, [r7, #4]
 80157ae:	681b      	ldr	r3, [r3, #0]
 80157b0:	617b      	str	r3, [r7, #20]
    ipcp_options *go = &pcb->ipcp_gotoptions;
 80157b2:	697b      	ldr	r3, [r7, #20]
 80157b4:	4a54      	ldr	r2, [pc, #336]	; (8015908 <ipcp_cilen+0x164>)
 80157b6:	4694      	mov	ip, r2
 80157b8:	4463      	add	r3, ip
 80157ba:	613b      	str	r3, [r7, #16]
#if VJ_SUPPORT
    ipcp_options *wo = &pcb->ipcp_wantoptions;
 80157bc:	697b      	ldr	r3, [r7, #20]
 80157be:	4a53      	ldr	r2, [pc, #332]	; (801590c <ipcp_cilen+0x168>)
 80157c0:	4694      	mov	ip, r2
 80157c2:	4463      	add	r3, ip
 80157c4:	60fb      	str	r3, [r7, #12]
#endif /* VJ_SUPPORT */
    ipcp_options *ho = &pcb->ipcp_hisoptions;
 80157c6:	697b      	ldr	r3, [r7, #20]
 80157c8:	4a51      	ldr	r2, [pc, #324]	; (8015910 <ipcp_cilen+0x16c>)
 80157ca:	4694      	mov	ip, r2
 80157cc:	4463      	add	r3, ip
 80157ce:	60bb      	str	r3, [r7, #8]

    /*
     * First see if we want to change our options to the old
     * forms because we have received old forms from the peer.
     */
    if (go->neg_addr && go->old_addrs && !ho->neg_addr && ho->old_addrs)
 80157d0:	693b      	ldr	r3, [r7, #16]
 80157d2:	781b      	ldrb	r3, [r3, #0]
 80157d4:	2201      	movs	r2, #1
 80157d6:	4013      	ands	r3, r2
 80157d8:	b2db      	uxtb	r3, r3
 80157da:	2b00      	cmp	r3, #0
 80157dc:	d019      	beq.n	8015812 <ipcp_cilen+0x6e>
 80157de:	693b      	ldr	r3, [r7, #16]
 80157e0:	781b      	ldrb	r3, [r3, #0]
 80157e2:	2202      	movs	r2, #2
 80157e4:	4013      	ands	r3, r2
 80157e6:	b2db      	uxtb	r3, r3
 80157e8:	2b00      	cmp	r3, #0
 80157ea:	d012      	beq.n	8015812 <ipcp_cilen+0x6e>
 80157ec:	68bb      	ldr	r3, [r7, #8]
 80157ee:	781b      	ldrb	r3, [r3, #0]
 80157f0:	2201      	movs	r2, #1
 80157f2:	4013      	ands	r3, r2
 80157f4:	b2db      	uxtb	r3, r3
 80157f6:	2b00      	cmp	r3, #0
 80157f8:	d10b      	bne.n	8015812 <ipcp_cilen+0x6e>
 80157fa:	68bb      	ldr	r3, [r7, #8]
 80157fc:	781b      	ldrb	r3, [r3, #0]
 80157fe:	2202      	movs	r2, #2
 8015800:	4013      	ands	r3, r2
 8015802:	b2db      	uxtb	r3, r3
 8015804:	2b00      	cmp	r3, #0
 8015806:	d004      	beq.n	8015812 <ipcp_cilen+0x6e>
	go->neg_addr = 0;
 8015808:	693b      	ldr	r3, [r7, #16]
 801580a:	781a      	ldrb	r2, [r3, #0]
 801580c:	2101      	movs	r1, #1
 801580e:	438a      	bics	r2, r1
 8015810:	701a      	strb	r2, [r3, #0]

#if VJ_SUPPORT
    if (wo->neg_vj && !go->neg_vj && !go->old_vj) {
 8015812:	68fb      	ldr	r3, [r7, #12]
 8015814:	781b      	ldrb	r3, [r3, #0]
 8015816:	2208      	movs	r2, #8
 8015818:	4013      	ands	r3, r2
 801581a:	b2db      	uxtb	r3, r3
 801581c:	2b00      	cmp	r3, #0
 801581e:	d029      	beq.n	8015874 <ipcp_cilen+0xd0>
 8015820:	693b      	ldr	r3, [r7, #16]
 8015822:	781b      	ldrb	r3, [r3, #0]
 8015824:	2208      	movs	r2, #8
 8015826:	4013      	ands	r3, r2
 8015828:	b2db      	uxtb	r3, r3
 801582a:	2b00      	cmp	r3, #0
 801582c:	d122      	bne.n	8015874 <ipcp_cilen+0xd0>
 801582e:	693b      	ldr	r3, [r7, #16]
 8015830:	781b      	ldrb	r3, [r3, #0]
 8015832:	2210      	movs	r2, #16
 8015834:	4013      	ands	r3, r2
 8015836:	b2db      	uxtb	r3, r3
 8015838:	2b00      	cmp	r3, #0
 801583a:	d11b      	bne.n	8015874 <ipcp_cilen+0xd0>
	/* try an older style of VJ negotiation */
	/* use the old style only if the peer did */
	if (ho->neg_vj && ho->old_vj) {
 801583c:	68bb      	ldr	r3, [r7, #8]
 801583e:	781b      	ldrb	r3, [r3, #0]
 8015840:	2208      	movs	r2, #8
 8015842:	4013      	ands	r3, r2
 8015844:	b2db      	uxtb	r3, r3
 8015846:	2b00      	cmp	r3, #0
 8015848:	d014      	beq.n	8015874 <ipcp_cilen+0xd0>
 801584a:	68bb      	ldr	r3, [r7, #8]
 801584c:	781b      	ldrb	r3, [r3, #0]
 801584e:	2210      	movs	r2, #16
 8015850:	4013      	ands	r3, r2
 8015852:	b2db      	uxtb	r3, r3
 8015854:	2b00      	cmp	r3, #0
 8015856:	d00d      	beq.n	8015874 <ipcp_cilen+0xd0>
	    go->neg_vj = 1;
 8015858:	693b      	ldr	r3, [r7, #16]
 801585a:	781a      	ldrb	r2, [r3, #0]
 801585c:	2108      	movs	r1, #8
 801585e:	430a      	orrs	r2, r1
 8015860:	701a      	strb	r2, [r3, #0]
	    go->old_vj = 1;
 8015862:	693b      	ldr	r3, [r7, #16]
 8015864:	781a      	ldrb	r2, [r3, #0]
 8015866:	2110      	movs	r1, #16
 8015868:	430a      	orrs	r2, r1
 801586a:	701a      	strb	r2, [r3, #0]
	    go->vj_protocol = ho->vj_protocol;
 801586c:	68bb      	ldr	r3, [r7, #8]
 801586e:	8a9a      	ldrh	r2, [r3, #20]
 8015870:	693b      	ldr	r3, [r7, #16]
 8015872:	829a      	strh	r2, [r3, #20]
	}
    }
#endif /* VJ_SUPPORT */

    return (LENCIADDRS(!go->neg_addr && go->old_addrs) +
 8015874:	693b      	ldr	r3, [r7, #16]
 8015876:	781b      	ldrb	r3, [r3, #0]
 8015878:	2201      	movs	r2, #1
 801587a:	4013      	ands	r3, r2
 801587c:	b2db      	uxtb	r3, r3
 801587e:	2b00      	cmp	r3, #0
 8015880:	d108      	bne.n	8015894 <ipcp_cilen+0xf0>
 8015882:	693b      	ldr	r3, [r7, #16]
 8015884:	781b      	ldrb	r3, [r3, #0]
 8015886:	2202      	movs	r2, #2
 8015888:	4013      	ands	r3, r2
 801588a:	b2db      	uxtb	r3, r3
 801588c:	2b00      	cmp	r3, #0
 801588e:	d001      	beq.n	8015894 <ipcp_cilen+0xf0>
 8015890:	220a      	movs	r2, #10
 8015892:	e000      	b.n	8015896 <ipcp_cilen+0xf2>
 8015894:	2200      	movs	r2, #0
#if VJ_SUPPORT
	    LENCIVJ(go->neg_vj, go->old_vj) +
 8015896:	693b      	ldr	r3, [r7, #16]
 8015898:	781b      	ldrb	r3, [r3, #0]
 801589a:	2108      	movs	r1, #8
 801589c:	400b      	ands	r3, r1
 801589e:	b2db      	uxtb	r3, r3
 80158a0:	2b00      	cmp	r3, #0
 80158a2:	d00a      	beq.n	80158ba <ipcp_cilen+0x116>
 80158a4:	693b      	ldr	r3, [r7, #16]
 80158a6:	781b      	ldrb	r3, [r3, #0]
 80158a8:	2110      	movs	r1, #16
 80158aa:	400b      	ands	r3, r1
 80158ac:	b2db      	uxtb	r3, r3
 80158ae:	2b00      	cmp	r3, #0
 80158b0:	d001      	beq.n	80158b6 <ipcp_cilen+0x112>
 80158b2:	2304      	movs	r3, #4
 80158b4:	e002      	b.n	80158bc <ipcp_cilen+0x118>
 80158b6:	2306      	movs	r3, #6
 80158b8:	e000      	b.n	80158bc <ipcp_cilen+0x118>
 80158ba:	2300      	movs	r3, #0
    return (LENCIADDRS(!go->neg_addr && go->old_addrs) +
 80158bc:	18d2      	adds	r2, r2, r3
#endif /* VJ_SUPPORT */
	    LENCIADDR(go->neg_addr) +
 80158be:	693b      	ldr	r3, [r7, #16]
 80158c0:	781b      	ldrb	r3, [r3, #0]
 80158c2:	2101      	movs	r1, #1
 80158c4:	400b      	ands	r3, r1
 80158c6:	b2db      	uxtb	r3, r3
 80158c8:	2b00      	cmp	r3, #0
 80158ca:	d001      	beq.n	80158d0 <ipcp_cilen+0x12c>
 80158cc:	2306      	movs	r3, #6
 80158ce:	e000      	b.n	80158d2 <ipcp_cilen+0x12e>
 80158d0:	2300      	movs	r3, #0
	    LENCIVJ(go->neg_vj, go->old_vj) +
 80158d2:	189a      	adds	r2, r3, r2
#if LWIP_DNS
	    LENCIDNS(go->req_dns1) +
 80158d4:	693b      	ldr	r3, [r7, #16]
 80158d6:	785b      	ldrb	r3, [r3, #1]
 80158d8:	2101      	movs	r1, #1
 80158da:	400b      	ands	r3, r1
 80158dc:	b2db      	uxtb	r3, r3
 80158de:	2b00      	cmp	r3, #0
 80158e0:	d001      	beq.n	80158e6 <ipcp_cilen+0x142>
 80158e2:	2306      	movs	r3, #6
 80158e4:	e000      	b.n	80158e8 <ipcp_cilen+0x144>
 80158e6:	2300      	movs	r3, #0
	    LENCIADDR(go->neg_addr) +
 80158e8:	189a      	adds	r2, r3, r2
	    LENCIDNS(go->req_dns2) +
 80158ea:	693b      	ldr	r3, [r7, #16]
 80158ec:	785b      	ldrb	r3, [r3, #1]
 80158ee:	2102      	movs	r1, #2
 80158f0:	400b      	ands	r3, r1
 80158f2:	b2db      	uxtb	r3, r3
 80158f4:	2b00      	cmp	r3, #0
 80158f6:	d001      	beq.n	80158fc <ipcp_cilen+0x158>
 80158f8:	2306      	movs	r3, #6
 80158fa:	e000      	b.n	80158fe <ipcp_cilen+0x15a>
 80158fc:	2300      	movs	r3, #0
 80158fe:	189b      	adds	r3, r3, r2
#if 0 /* UNUSED - WINS */
	    LENCIWINS(go->winsaddr[0]) +
	    LENCIWINS(go->winsaddr[1]) +
#endif /* UNUSED - WINS */
	    0);
}
 8015900:	0018      	movs	r0, r3
 8015902:	46bd      	mov	sp, r7
 8015904:	b006      	add	sp, #24
 8015906:	bd80      	pop	{r7, pc}
 8015908:	0000121c 	.word	0x0000121c
 801590c:	00001204 	.word	0x00001204
 8015910:	0000124c 	.word	0x0000124c

08015914 <ipcp_addci>:

/*
 * ipcp_addci - Add our desired CIs to a packet.
 * Called by fsm_sconfreq, Send Configure Request.
 */
static void ipcp_addci(fsm *f, u_char *ucp, int *lenp) {
 8015914:	b580      	push	{r7, lr}
 8015916:	b08c      	sub	sp, #48	; 0x30
 8015918:	af00      	add	r7, sp, #0
 801591a:	60f8      	str	r0, [r7, #12]
 801591c:	60b9      	str	r1, [r7, #8]
 801591e:	607a      	str	r2, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8015920:	68fb      	ldr	r3, [r7, #12]
 8015922:	681b      	ldr	r3, [r3, #0]
 8015924:	62bb      	str	r3, [r7, #40]	; 0x28
    ipcp_options *go = &pcb->ipcp_gotoptions;
 8015926:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015928:	4ac3      	ldr	r2, [pc, #780]	; (8015c38 <ipcp_addci+0x324>)
 801592a:	4694      	mov	ip, r2
 801592c:	4463      	add	r3, ip
 801592e:	627b      	str	r3, [r7, #36]	; 0x24
    int len = *lenp;
 8015930:	687b      	ldr	r3, [r7, #4]
 8015932:	681b      	ldr	r3, [r3, #0]
 8015934:	62fb      	str	r3, [r7, #44]	; 0x2c
	} else \
	    addr = 0; \
    }
#endif /* UNUSED - WINS */

    ADDCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs, go->ouraddr,
 8015936:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015938:	781b      	ldrb	r3, [r3, #0]
 801593a:	2201      	movs	r2, #1
 801593c:	4013      	ands	r3, r2
 801593e:	b2db      	uxtb	r3, r3
 8015940:	2b00      	cmp	r3, #0
 8015942:	d160      	bne.n	8015a06 <ipcp_addci+0xf2>
 8015944:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015946:	781b      	ldrb	r3, [r3, #0]
 8015948:	2202      	movs	r2, #2
 801594a:	4013      	ands	r3, r2
 801594c:	b2db      	uxtb	r3, r3
 801594e:	2b00      	cmp	r3, #0
 8015950:	d059      	beq.n	8015a06 <ipcp_addci+0xf2>
 8015952:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015954:	2b09      	cmp	r3, #9
 8015956:	dd51      	ble.n	80159fc <ipcp_addci+0xe8>
 8015958:	68bb      	ldr	r3, [r7, #8]
 801595a:	1c5a      	adds	r2, r3, #1
 801595c:	60ba      	str	r2, [r7, #8]
 801595e:	2201      	movs	r2, #1
 8015960:	701a      	strb	r2, [r3, #0]
 8015962:	68bb      	ldr	r3, [r7, #8]
 8015964:	1c5a      	adds	r2, r3, #1
 8015966:	60ba      	str	r2, [r7, #8]
 8015968:	220a      	movs	r2, #10
 801596a:	701a      	strb	r2, [r3, #0]
 801596c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801596e:	685b      	ldr	r3, [r3, #4]
 8015970:	0018      	movs	r0, r3
 8015972:	f7f1 fad5 	bl	8006f20 <lwip_htonl>
 8015976:	0003      	movs	r3, r0
 8015978:	623b      	str	r3, [r7, #32]
 801597a:	6a3b      	ldr	r3, [r7, #32]
 801597c:	0e19      	lsrs	r1, r3, #24
 801597e:	68bb      	ldr	r3, [r7, #8]
 8015980:	1c5a      	adds	r2, r3, #1
 8015982:	60ba      	str	r2, [r7, #8]
 8015984:	b2ca      	uxtb	r2, r1
 8015986:	701a      	strb	r2, [r3, #0]
 8015988:	6a3b      	ldr	r3, [r7, #32]
 801598a:	0c19      	lsrs	r1, r3, #16
 801598c:	68bb      	ldr	r3, [r7, #8]
 801598e:	1c5a      	adds	r2, r3, #1
 8015990:	60ba      	str	r2, [r7, #8]
 8015992:	b2ca      	uxtb	r2, r1
 8015994:	701a      	strb	r2, [r3, #0]
 8015996:	6a3b      	ldr	r3, [r7, #32]
 8015998:	0a19      	lsrs	r1, r3, #8
 801599a:	68bb      	ldr	r3, [r7, #8]
 801599c:	1c5a      	adds	r2, r3, #1
 801599e:	60ba      	str	r2, [r7, #8]
 80159a0:	b2ca      	uxtb	r2, r1
 80159a2:	701a      	strb	r2, [r3, #0]
 80159a4:	68bb      	ldr	r3, [r7, #8]
 80159a6:	1c5a      	adds	r2, r3, #1
 80159a8:	60ba      	str	r2, [r7, #8]
 80159aa:	6a3a      	ldr	r2, [r7, #32]
 80159ac:	b2d2      	uxtb	r2, r2
 80159ae:	701a      	strb	r2, [r3, #0]
 80159b0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80159b2:	689b      	ldr	r3, [r3, #8]
 80159b4:	0018      	movs	r0, r3
 80159b6:	f7f1 fab3 	bl	8006f20 <lwip_htonl>
 80159ba:	0003      	movs	r3, r0
 80159bc:	623b      	str	r3, [r7, #32]
 80159be:	6a3b      	ldr	r3, [r7, #32]
 80159c0:	0e19      	lsrs	r1, r3, #24
 80159c2:	68bb      	ldr	r3, [r7, #8]
 80159c4:	1c5a      	adds	r2, r3, #1
 80159c6:	60ba      	str	r2, [r7, #8]
 80159c8:	b2ca      	uxtb	r2, r1
 80159ca:	701a      	strb	r2, [r3, #0]
 80159cc:	6a3b      	ldr	r3, [r7, #32]
 80159ce:	0c19      	lsrs	r1, r3, #16
 80159d0:	68bb      	ldr	r3, [r7, #8]
 80159d2:	1c5a      	adds	r2, r3, #1
 80159d4:	60ba      	str	r2, [r7, #8]
 80159d6:	b2ca      	uxtb	r2, r1
 80159d8:	701a      	strb	r2, [r3, #0]
 80159da:	6a3b      	ldr	r3, [r7, #32]
 80159dc:	0a19      	lsrs	r1, r3, #8
 80159de:	68bb      	ldr	r3, [r7, #8]
 80159e0:	1c5a      	adds	r2, r3, #1
 80159e2:	60ba      	str	r2, [r7, #8]
 80159e4:	b2ca      	uxtb	r2, r1
 80159e6:	701a      	strb	r2, [r3, #0]
 80159e8:	68bb      	ldr	r3, [r7, #8]
 80159ea:	1c5a      	adds	r2, r3, #1
 80159ec:	60ba      	str	r2, [r7, #8]
 80159ee:	6a3a      	ldr	r2, [r7, #32]
 80159f0:	b2d2      	uxtb	r2, r2
 80159f2:	701a      	strb	r2, [r3, #0]
 80159f4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80159f6:	3b0a      	subs	r3, #10
 80159f8:	62fb      	str	r3, [r7, #44]	; 0x2c
 80159fa:	e004      	b.n	8015a06 <ipcp_addci+0xf2>
 80159fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80159fe:	781a      	ldrb	r2, [r3, #0]
 8015a00:	2102      	movs	r1, #2
 8015a02:	438a      	bics	r2, r1
 8015a04:	701a      	strb	r2, [r3, #0]
	       go->hisaddr);

#if VJ_SUPPORT
    ADDCIVJ(CI_COMPRESSTYPE, go->neg_vj, go->vj_protocol, go->old_vj,
 8015a06:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015a08:	781b      	ldrb	r3, [r3, #0]
 8015a0a:	2208      	movs	r2, #8
 8015a0c:	4013      	ands	r3, r2
 8015a0e:	b2db      	uxtb	r3, r3
 8015a10:	2b00      	cmp	r3, #0
 8015a12:	d04a      	beq.n	8015aaa <ipcp_addci+0x196>
 8015a14:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015a16:	781b      	ldrb	r3, [r3, #0]
 8015a18:	2210      	movs	r2, #16
 8015a1a:	4013      	ands	r3, r2
 8015a1c:	b2db      	uxtb	r3, r3
 8015a1e:	2b00      	cmp	r3, #0
 8015a20:	d001      	beq.n	8015a26 <ipcp_addci+0x112>
 8015a22:	2304      	movs	r3, #4
 8015a24:	e000      	b.n	8015a28 <ipcp_addci+0x114>
 8015a26:	2306      	movs	r3, #6
 8015a28:	61fb      	str	r3, [r7, #28]
 8015a2a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8015a2c:	69fb      	ldr	r3, [r7, #28]
 8015a2e:	429a      	cmp	r2, r3
 8015a30:	db36      	blt.n	8015aa0 <ipcp_addci+0x18c>
 8015a32:	68bb      	ldr	r3, [r7, #8]
 8015a34:	1c5a      	adds	r2, r3, #1
 8015a36:	60ba      	str	r2, [r7, #8]
 8015a38:	2202      	movs	r2, #2
 8015a3a:	701a      	strb	r2, [r3, #0]
 8015a3c:	68bb      	ldr	r3, [r7, #8]
 8015a3e:	1c5a      	adds	r2, r3, #1
 8015a40:	60ba      	str	r2, [r7, #8]
 8015a42:	69fa      	ldr	r2, [r7, #28]
 8015a44:	b2d2      	uxtb	r2, r2
 8015a46:	701a      	strb	r2, [r3, #0]
 8015a48:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015a4a:	8a9b      	ldrh	r3, [r3, #20]
 8015a4c:	0a1b      	lsrs	r3, r3, #8
 8015a4e:	b299      	uxth	r1, r3
 8015a50:	68bb      	ldr	r3, [r7, #8]
 8015a52:	1c5a      	adds	r2, r3, #1
 8015a54:	60ba      	str	r2, [r7, #8]
 8015a56:	b2ca      	uxtb	r2, r1
 8015a58:	701a      	strb	r2, [r3, #0]
 8015a5a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015a5c:	8a99      	ldrh	r1, [r3, #20]
 8015a5e:	68bb      	ldr	r3, [r7, #8]
 8015a60:	1c5a      	adds	r2, r3, #1
 8015a62:	60ba      	str	r2, [r7, #8]
 8015a64:	b2ca      	uxtb	r2, r1
 8015a66:	701a      	strb	r2, [r3, #0]
 8015a68:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015a6a:	781b      	ldrb	r3, [r3, #0]
 8015a6c:	2210      	movs	r2, #16
 8015a6e:	4013      	ands	r3, r2
 8015a70:	b2db      	uxtb	r3, r3
 8015a72:	2b00      	cmp	r3, #0
 8015a74:	d10f      	bne.n	8015a96 <ipcp_addci+0x182>
 8015a76:	68bb      	ldr	r3, [r7, #8]
 8015a78:	1c5a      	adds	r2, r3, #1
 8015a7a:	60ba      	str	r2, [r7, #8]
 8015a7c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015a7e:	7d92      	ldrb	r2, [r2, #22]
 8015a80:	701a      	strb	r2, [r3, #0]
 8015a82:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015a84:	781b      	ldrb	r3, [r3, #0]
 8015a86:	069b      	lsls	r3, r3, #26
 8015a88:	0fdb      	lsrs	r3, r3, #31
 8015a8a:	b2d9      	uxtb	r1, r3
 8015a8c:	68bb      	ldr	r3, [r7, #8]
 8015a8e:	1c5a      	adds	r2, r3, #1
 8015a90:	60ba      	str	r2, [r7, #8]
 8015a92:	000a      	movs	r2, r1
 8015a94:	701a      	strb	r2, [r3, #0]
 8015a96:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8015a98:	69fb      	ldr	r3, [r7, #28]
 8015a9a:	1ad3      	subs	r3, r2, r3
 8015a9c:	62fb      	str	r3, [r7, #44]	; 0x2c
 8015a9e:	e004      	b.n	8015aaa <ipcp_addci+0x196>
 8015aa0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015aa2:	781a      	ldrb	r2, [r3, #0]
 8015aa4:	2108      	movs	r1, #8
 8015aa6:	438a      	bics	r2, r1
 8015aa8:	701a      	strb	r2, [r3, #0]
	    go->maxslotindex, go->cflag);
#endif /* VJ_SUPPORT */

    ADDCIADDR(CI_ADDR, go->neg_addr, go->ouraddr);
 8015aaa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015aac:	781b      	ldrb	r3, [r3, #0]
 8015aae:	2201      	movs	r2, #1
 8015ab0:	4013      	ands	r3, r2
 8015ab2:	b2db      	uxtb	r3, r3
 8015ab4:	2b00      	cmp	r3, #0
 8015ab6:	d037      	beq.n	8015b28 <ipcp_addci+0x214>
 8015ab8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015aba:	2b05      	cmp	r3, #5
 8015abc:	dd2f      	ble.n	8015b1e <ipcp_addci+0x20a>
 8015abe:	68bb      	ldr	r3, [r7, #8]
 8015ac0:	1c5a      	adds	r2, r3, #1
 8015ac2:	60ba      	str	r2, [r7, #8]
 8015ac4:	2203      	movs	r2, #3
 8015ac6:	701a      	strb	r2, [r3, #0]
 8015ac8:	68bb      	ldr	r3, [r7, #8]
 8015aca:	1c5a      	adds	r2, r3, #1
 8015acc:	60ba      	str	r2, [r7, #8]
 8015ace:	2206      	movs	r2, #6
 8015ad0:	701a      	strb	r2, [r3, #0]
 8015ad2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015ad4:	685b      	ldr	r3, [r3, #4]
 8015ad6:	0018      	movs	r0, r3
 8015ad8:	f7f1 fa22 	bl	8006f20 <lwip_htonl>
 8015adc:	0003      	movs	r3, r0
 8015ade:	61bb      	str	r3, [r7, #24]
 8015ae0:	69bb      	ldr	r3, [r7, #24]
 8015ae2:	0e19      	lsrs	r1, r3, #24
 8015ae4:	68bb      	ldr	r3, [r7, #8]
 8015ae6:	1c5a      	adds	r2, r3, #1
 8015ae8:	60ba      	str	r2, [r7, #8]
 8015aea:	b2ca      	uxtb	r2, r1
 8015aec:	701a      	strb	r2, [r3, #0]
 8015aee:	69bb      	ldr	r3, [r7, #24]
 8015af0:	0c19      	lsrs	r1, r3, #16
 8015af2:	68bb      	ldr	r3, [r7, #8]
 8015af4:	1c5a      	adds	r2, r3, #1
 8015af6:	60ba      	str	r2, [r7, #8]
 8015af8:	b2ca      	uxtb	r2, r1
 8015afa:	701a      	strb	r2, [r3, #0]
 8015afc:	69bb      	ldr	r3, [r7, #24]
 8015afe:	0a19      	lsrs	r1, r3, #8
 8015b00:	68bb      	ldr	r3, [r7, #8]
 8015b02:	1c5a      	adds	r2, r3, #1
 8015b04:	60ba      	str	r2, [r7, #8]
 8015b06:	b2ca      	uxtb	r2, r1
 8015b08:	701a      	strb	r2, [r3, #0]
 8015b0a:	68bb      	ldr	r3, [r7, #8]
 8015b0c:	1c5a      	adds	r2, r3, #1
 8015b0e:	60ba      	str	r2, [r7, #8]
 8015b10:	69ba      	ldr	r2, [r7, #24]
 8015b12:	b2d2      	uxtb	r2, r2
 8015b14:	701a      	strb	r2, [r3, #0]
 8015b16:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015b18:	3b06      	subs	r3, #6
 8015b1a:	62fb      	str	r3, [r7, #44]	; 0x2c
 8015b1c:	e004      	b.n	8015b28 <ipcp_addci+0x214>
 8015b1e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015b20:	781a      	ldrb	r2, [r3, #0]
 8015b22:	2101      	movs	r1, #1
 8015b24:	438a      	bics	r2, r1
 8015b26:	701a      	strb	r2, [r3, #0]

#if LWIP_DNS
    ADDCIDNS(CI_MS_DNS1, go->req_dns1, go->dnsaddr[0]);
 8015b28:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015b2a:	785b      	ldrb	r3, [r3, #1]
 8015b2c:	2201      	movs	r2, #1
 8015b2e:	4013      	ands	r3, r2
 8015b30:	b2db      	uxtb	r3, r3
 8015b32:	2b00      	cmp	r3, #0
 8015b34:	d037      	beq.n	8015ba6 <ipcp_addci+0x292>
 8015b36:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015b38:	2b05      	cmp	r3, #5
 8015b3a:	dd2f      	ble.n	8015b9c <ipcp_addci+0x288>
 8015b3c:	68bb      	ldr	r3, [r7, #8]
 8015b3e:	1c5a      	adds	r2, r3, #1
 8015b40:	60ba      	str	r2, [r7, #8]
 8015b42:	2281      	movs	r2, #129	; 0x81
 8015b44:	701a      	strb	r2, [r3, #0]
 8015b46:	68bb      	ldr	r3, [r7, #8]
 8015b48:	1c5a      	adds	r2, r3, #1
 8015b4a:	60ba      	str	r2, [r7, #8]
 8015b4c:	2206      	movs	r2, #6
 8015b4e:	701a      	strb	r2, [r3, #0]
 8015b50:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015b52:	68db      	ldr	r3, [r3, #12]
 8015b54:	0018      	movs	r0, r3
 8015b56:	f7f1 f9e3 	bl	8006f20 <lwip_htonl>
 8015b5a:	0003      	movs	r3, r0
 8015b5c:	617b      	str	r3, [r7, #20]
 8015b5e:	697b      	ldr	r3, [r7, #20]
 8015b60:	0e19      	lsrs	r1, r3, #24
 8015b62:	68bb      	ldr	r3, [r7, #8]
 8015b64:	1c5a      	adds	r2, r3, #1
 8015b66:	60ba      	str	r2, [r7, #8]
 8015b68:	b2ca      	uxtb	r2, r1
 8015b6a:	701a      	strb	r2, [r3, #0]
 8015b6c:	697b      	ldr	r3, [r7, #20]
 8015b6e:	0c19      	lsrs	r1, r3, #16
 8015b70:	68bb      	ldr	r3, [r7, #8]
 8015b72:	1c5a      	adds	r2, r3, #1
 8015b74:	60ba      	str	r2, [r7, #8]
 8015b76:	b2ca      	uxtb	r2, r1
 8015b78:	701a      	strb	r2, [r3, #0]
 8015b7a:	697b      	ldr	r3, [r7, #20]
 8015b7c:	0a19      	lsrs	r1, r3, #8
 8015b7e:	68bb      	ldr	r3, [r7, #8]
 8015b80:	1c5a      	adds	r2, r3, #1
 8015b82:	60ba      	str	r2, [r7, #8]
 8015b84:	b2ca      	uxtb	r2, r1
 8015b86:	701a      	strb	r2, [r3, #0]
 8015b88:	68bb      	ldr	r3, [r7, #8]
 8015b8a:	1c5a      	adds	r2, r3, #1
 8015b8c:	60ba      	str	r2, [r7, #8]
 8015b8e:	697a      	ldr	r2, [r7, #20]
 8015b90:	b2d2      	uxtb	r2, r2
 8015b92:	701a      	strb	r2, [r3, #0]
 8015b94:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015b96:	3b06      	subs	r3, #6
 8015b98:	62fb      	str	r3, [r7, #44]	; 0x2c
 8015b9a:	e004      	b.n	8015ba6 <ipcp_addci+0x292>
 8015b9c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015b9e:	785a      	ldrb	r2, [r3, #1]
 8015ba0:	2101      	movs	r1, #1
 8015ba2:	438a      	bics	r2, r1
 8015ba4:	705a      	strb	r2, [r3, #1]

    ADDCIDNS(CI_MS_DNS2, go->req_dns2, go->dnsaddr[1]);
 8015ba6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015ba8:	785b      	ldrb	r3, [r3, #1]
 8015baa:	2202      	movs	r2, #2
 8015bac:	4013      	ands	r3, r2
 8015bae:	b2db      	uxtb	r3, r3
 8015bb0:	2b00      	cmp	r3, #0
 8015bb2:	d037      	beq.n	8015c24 <ipcp_addci+0x310>
 8015bb4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015bb6:	2b05      	cmp	r3, #5
 8015bb8:	dd2f      	ble.n	8015c1a <ipcp_addci+0x306>
 8015bba:	68bb      	ldr	r3, [r7, #8]
 8015bbc:	1c5a      	adds	r2, r3, #1
 8015bbe:	60ba      	str	r2, [r7, #8]
 8015bc0:	2283      	movs	r2, #131	; 0x83
 8015bc2:	701a      	strb	r2, [r3, #0]
 8015bc4:	68bb      	ldr	r3, [r7, #8]
 8015bc6:	1c5a      	adds	r2, r3, #1
 8015bc8:	60ba      	str	r2, [r7, #8]
 8015bca:	2206      	movs	r2, #6
 8015bcc:	701a      	strb	r2, [r3, #0]
 8015bce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015bd0:	691b      	ldr	r3, [r3, #16]
 8015bd2:	0018      	movs	r0, r3
 8015bd4:	f7f1 f9a4 	bl	8006f20 <lwip_htonl>
 8015bd8:	0003      	movs	r3, r0
 8015bda:	613b      	str	r3, [r7, #16]
 8015bdc:	693b      	ldr	r3, [r7, #16]
 8015bde:	0e19      	lsrs	r1, r3, #24
 8015be0:	68bb      	ldr	r3, [r7, #8]
 8015be2:	1c5a      	adds	r2, r3, #1
 8015be4:	60ba      	str	r2, [r7, #8]
 8015be6:	b2ca      	uxtb	r2, r1
 8015be8:	701a      	strb	r2, [r3, #0]
 8015bea:	693b      	ldr	r3, [r7, #16]
 8015bec:	0c19      	lsrs	r1, r3, #16
 8015bee:	68bb      	ldr	r3, [r7, #8]
 8015bf0:	1c5a      	adds	r2, r3, #1
 8015bf2:	60ba      	str	r2, [r7, #8]
 8015bf4:	b2ca      	uxtb	r2, r1
 8015bf6:	701a      	strb	r2, [r3, #0]
 8015bf8:	693b      	ldr	r3, [r7, #16]
 8015bfa:	0a19      	lsrs	r1, r3, #8
 8015bfc:	68bb      	ldr	r3, [r7, #8]
 8015bfe:	1c5a      	adds	r2, r3, #1
 8015c00:	60ba      	str	r2, [r7, #8]
 8015c02:	b2ca      	uxtb	r2, r1
 8015c04:	701a      	strb	r2, [r3, #0]
 8015c06:	68bb      	ldr	r3, [r7, #8]
 8015c08:	1c5a      	adds	r2, r3, #1
 8015c0a:	60ba      	str	r2, [r7, #8]
 8015c0c:	693a      	ldr	r2, [r7, #16]
 8015c0e:	b2d2      	uxtb	r2, r2
 8015c10:	701a      	strb	r2, [r3, #0]
 8015c12:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015c14:	3b06      	subs	r3, #6
 8015c16:	62fb      	str	r3, [r7, #44]	; 0x2c
 8015c18:	e004      	b.n	8015c24 <ipcp_addci+0x310>
 8015c1a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015c1c:	785a      	ldrb	r2, [r3, #1]
 8015c1e:	2102      	movs	r1, #2
 8015c20:	438a      	bics	r2, r1
 8015c22:	705a      	strb	r2, [r3, #1]
    ADDCIWINS(CI_MS_WINS1, go->winsaddr[0]);

    ADDCIWINS(CI_MS_WINS2, go->winsaddr[1]);
#endif /* UNUSED - WINS */
    
    *lenp -= len;
 8015c24:	687b      	ldr	r3, [r7, #4]
 8015c26:	681a      	ldr	r2, [r3, #0]
 8015c28:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015c2a:	1ad2      	subs	r2, r2, r3
 8015c2c:	687b      	ldr	r3, [r7, #4]
 8015c2e:	601a      	str	r2, [r3, #0]
}
 8015c30:	46c0      	nop			; (mov r8, r8)
 8015c32:	46bd      	mov	sp, r7
 8015c34:	b00c      	add	sp, #48	; 0x30
 8015c36:	bd80      	pop	{r7, pc}
 8015c38:	0000121c 	.word	0x0000121c

08015c3c <ipcp_ackci>:
 *
 * Returns:
 *	0 - Ack was bad.
 *	1 - Ack was good.
 */
static int ipcp_ackci(fsm *f, u_char *p, int len) {
 8015c3c:	b580      	push	{r7, lr}
 8015c3e:	b08e      	sub	sp, #56	; 0x38
 8015c40:	af00      	add	r7, sp, #0
 8015c42:	60f8      	str	r0, [r7, #12]
 8015c44:	60b9      	str	r1, [r7, #8]
 8015c46:	607a      	str	r2, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8015c48:	68fb      	ldr	r3, [r7, #12]
 8015c4a:	681b      	ldr	r3, [r3, #0]
 8015c4c:	637b      	str	r3, [r7, #52]	; 0x34
    ipcp_options *go = &pcb->ipcp_gotoptions;
 8015c4e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8015c50:	4a51      	ldr	r2, [pc, #324]	; (8015d98 <ipcp_ackci+0x15c>)
 8015c52:	4694      	mov	ip, r2
 8015c54:	4463      	add	r3, ip
 8015c56:	633b      	str	r3, [r7, #48]	; 0x30
	if (addr != cilong) \
	    goto bad; \
    }
#endif /* UNUSED - WINS */

    ACKCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs, go->ouraddr,
 8015c58:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015c5a:	781b      	ldrb	r3, [r3, #0]
 8015c5c:	2201      	movs	r2, #1
 8015c5e:	4013      	ands	r3, r2
 8015c60:	b2db      	uxtb	r3, r3
 8015c62:	2b00      	cmp	r3, #0
 8015c64:	d000      	beq.n	8015c68 <ipcp_ackci+0x2c>
 8015c66:	e086      	b.n	8015d76 <ipcp_ackci+0x13a>
 8015c68:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015c6a:	781b      	ldrb	r3, [r3, #0]
 8015c6c:	2202      	movs	r2, #2
 8015c6e:	4013      	ands	r3, r2
 8015c70:	b2db      	uxtb	r3, r3
 8015c72:	2b00      	cmp	r3, #0
 8015c74:	d100      	bne.n	8015c78 <ipcp_ackci+0x3c>
 8015c76:	e07e      	b.n	8015d76 <ipcp_ackci+0x13a>
 8015c78:	687b      	ldr	r3, [r7, #4]
 8015c7a:	3b0a      	subs	r3, #10
 8015c7c:	607b      	str	r3, [r7, #4]
 8015c7e:	687b      	ldr	r3, [r7, #4]
 8015c80:	2b00      	cmp	r3, #0
 8015c82:	da00      	bge.n	8015c86 <ipcp_ackci+0x4a>
 8015c84:	e1f2      	b.n	801606c <ipcp_ackci+0x430>
 8015c86:	68bb      	ldr	r3, [r7, #8]
 8015c88:	1c5a      	adds	r2, r3, #1
 8015c8a:	60ba      	str	r2, [r7, #8]
 8015c8c:	781a      	ldrb	r2, [r3, #0]
 8015c8e:	212e      	movs	r1, #46	; 0x2e
 8015c90:	187b      	adds	r3, r7, r1
 8015c92:	801a      	strh	r2, [r3, #0]
 8015c94:	68bb      	ldr	r3, [r7, #8]
 8015c96:	1c5a      	adds	r2, r3, #1
 8015c98:	60ba      	str	r2, [r7, #8]
 8015c9a:	781a      	ldrb	r2, [r3, #0]
 8015c9c:	202c      	movs	r0, #44	; 0x2c
 8015c9e:	183b      	adds	r3, r7, r0
 8015ca0:	801a      	strh	r2, [r3, #0]
 8015ca2:	183b      	adds	r3, r7, r0
 8015ca4:	881b      	ldrh	r3, [r3, #0]
 8015ca6:	2b0a      	cmp	r3, #10
 8015ca8:	d000      	beq.n	8015cac <ipcp_ackci+0x70>
 8015caa:	e1e1      	b.n	8016070 <ipcp_ackci+0x434>
 8015cac:	187b      	adds	r3, r7, r1
 8015cae:	881b      	ldrh	r3, [r3, #0]
 8015cb0:	2b01      	cmp	r3, #1
 8015cb2:	d000      	beq.n	8015cb6 <ipcp_ackci+0x7a>
 8015cb4:	e1dc      	b.n	8016070 <ipcp_ackci+0x434>
 8015cb6:	68bb      	ldr	r3, [r7, #8]
 8015cb8:	1c5a      	adds	r2, r3, #1
 8015cba:	60ba      	str	r2, [r7, #8]
 8015cbc:	781b      	ldrb	r3, [r3, #0]
 8015cbe:	021b      	lsls	r3, r3, #8
 8015cc0:	62bb      	str	r3, [r7, #40]	; 0x28
 8015cc2:	68bb      	ldr	r3, [r7, #8]
 8015cc4:	1c5a      	adds	r2, r3, #1
 8015cc6:	60ba      	str	r2, [r7, #8]
 8015cc8:	781b      	ldrb	r3, [r3, #0]
 8015cca:	001a      	movs	r2, r3
 8015ccc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015cce:	4313      	orrs	r3, r2
 8015cd0:	62bb      	str	r3, [r7, #40]	; 0x28
 8015cd2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015cd4:	021b      	lsls	r3, r3, #8
 8015cd6:	62bb      	str	r3, [r7, #40]	; 0x28
 8015cd8:	68bb      	ldr	r3, [r7, #8]
 8015cda:	1c5a      	adds	r2, r3, #1
 8015cdc:	60ba      	str	r2, [r7, #8]
 8015cde:	781b      	ldrb	r3, [r3, #0]
 8015ce0:	001a      	movs	r2, r3
 8015ce2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015ce4:	4313      	orrs	r3, r2
 8015ce6:	62bb      	str	r3, [r7, #40]	; 0x28
 8015ce8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015cea:	021b      	lsls	r3, r3, #8
 8015cec:	62bb      	str	r3, [r7, #40]	; 0x28
 8015cee:	68bb      	ldr	r3, [r7, #8]
 8015cf0:	1c5a      	adds	r2, r3, #1
 8015cf2:	60ba      	str	r2, [r7, #8]
 8015cf4:	781b      	ldrb	r3, [r3, #0]
 8015cf6:	001a      	movs	r2, r3
 8015cf8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015cfa:	4313      	orrs	r3, r2
 8015cfc:	62bb      	str	r3, [r7, #40]	; 0x28
 8015cfe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015d00:	0018      	movs	r0, r3
 8015d02:	f7f1 f90d 	bl	8006f20 <lwip_htonl>
 8015d06:	0003      	movs	r3, r0
 8015d08:	627b      	str	r3, [r7, #36]	; 0x24
 8015d0a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015d0c:	685b      	ldr	r3, [r3, #4]
 8015d0e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015d10:	429a      	cmp	r2, r3
 8015d12:	d000      	beq.n	8015d16 <ipcp_ackci+0xda>
 8015d14:	e1ae      	b.n	8016074 <ipcp_ackci+0x438>
 8015d16:	68bb      	ldr	r3, [r7, #8]
 8015d18:	1c5a      	adds	r2, r3, #1
 8015d1a:	60ba      	str	r2, [r7, #8]
 8015d1c:	781b      	ldrb	r3, [r3, #0]
 8015d1e:	021b      	lsls	r3, r3, #8
 8015d20:	62bb      	str	r3, [r7, #40]	; 0x28
 8015d22:	68bb      	ldr	r3, [r7, #8]
 8015d24:	1c5a      	adds	r2, r3, #1
 8015d26:	60ba      	str	r2, [r7, #8]
 8015d28:	781b      	ldrb	r3, [r3, #0]
 8015d2a:	001a      	movs	r2, r3
 8015d2c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015d2e:	4313      	orrs	r3, r2
 8015d30:	62bb      	str	r3, [r7, #40]	; 0x28
 8015d32:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015d34:	021b      	lsls	r3, r3, #8
 8015d36:	62bb      	str	r3, [r7, #40]	; 0x28
 8015d38:	68bb      	ldr	r3, [r7, #8]
 8015d3a:	1c5a      	adds	r2, r3, #1
 8015d3c:	60ba      	str	r2, [r7, #8]
 8015d3e:	781b      	ldrb	r3, [r3, #0]
 8015d40:	001a      	movs	r2, r3
 8015d42:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015d44:	4313      	orrs	r3, r2
 8015d46:	62bb      	str	r3, [r7, #40]	; 0x28
 8015d48:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015d4a:	021b      	lsls	r3, r3, #8
 8015d4c:	62bb      	str	r3, [r7, #40]	; 0x28
 8015d4e:	68bb      	ldr	r3, [r7, #8]
 8015d50:	1c5a      	adds	r2, r3, #1
 8015d52:	60ba      	str	r2, [r7, #8]
 8015d54:	781b      	ldrb	r3, [r3, #0]
 8015d56:	001a      	movs	r2, r3
 8015d58:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015d5a:	4313      	orrs	r3, r2
 8015d5c:	62bb      	str	r3, [r7, #40]	; 0x28
 8015d5e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015d60:	0018      	movs	r0, r3
 8015d62:	f7f1 f8dd 	bl	8006f20 <lwip_htonl>
 8015d66:	0003      	movs	r3, r0
 8015d68:	627b      	str	r3, [r7, #36]	; 0x24
 8015d6a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015d6c:	689b      	ldr	r3, [r3, #8]
 8015d6e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015d70:	429a      	cmp	r2, r3
 8015d72:	d000      	beq.n	8015d76 <ipcp_ackci+0x13a>
 8015d74:	e180      	b.n	8016078 <ipcp_ackci+0x43c>
	       go->hisaddr);

#if VJ_SUPPORT
    ACKCIVJ(CI_COMPRESSTYPE, go->neg_vj, go->vj_protocol, go->old_vj,
 8015d76:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015d78:	781b      	ldrb	r3, [r3, #0]
 8015d7a:	2208      	movs	r2, #8
 8015d7c:	4013      	ands	r3, r2
 8015d7e:	b2db      	uxtb	r3, r3
 8015d80:	2b00      	cmp	r3, #0
 8015d82:	d100      	bne.n	8015d86 <ipcp_ackci+0x14a>
 8015d84:	e06e      	b.n	8015e64 <ipcp_ackci+0x228>
 8015d86:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015d88:	781b      	ldrb	r3, [r3, #0]
 8015d8a:	2210      	movs	r2, #16
 8015d8c:	4013      	ands	r3, r2
 8015d8e:	b2db      	uxtb	r3, r3
 8015d90:	2b00      	cmp	r3, #0
 8015d92:	d003      	beq.n	8015d9c <ipcp_ackci+0x160>
 8015d94:	2304      	movs	r3, #4
 8015d96:	e002      	b.n	8015d9e <ipcp_ackci+0x162>
 8015d98:	0000121c 	.word	0x0000121c
 8015d9c:	2306      	movs	r3, #6
 8015d9e:	623b      	str	r3, [r7, #32]
 8015da0:	687a      	ldr	r2, [r7, #4]
 8015da2:	6a3b      	ldr	r3, [r7, #32]
 8015da4:	1ad3      	subs	r3, r2, r3
 8015da6:	607b      	str	r3, [r7, #4]
 8015da8:	687b      	ldr	r3, [r7, #4]
 8015daa:	2b00      	cmp	r3, #0
 8015dac:	da00      	bge.n	8015db0 <ipcp_ackci+0x174>
 8015dae:	e165      	b.n	801607c <ipcp_ackci+0x440>
 8015db0:	68bb      	ldr	r3, [r7, #8]
 8015db2:	1c5a      	adds	r2, r3, #1
 8015db4:	60ba      	str	r2, [r7, #8]
 8015db6:	781a      	ldrb	r2, [r3, #0]
 8015db8:	212e      	movs	r1, #46	; 0x2e
 8015dba:	187b      	adds	r3, r7, r1
 8015dbc:	801a      	strh	r2, [r3, #0]
 8015dbe:	68bb      	ldr	r3, [r7, #8]
 8015dc0:	1c5a      	adds	r2, r3, #1
 8015dc2:	60ba      	str	r2, [r7, #8]
 8015dc4:	781a      	ldrb	r2, [r3, #0]
 8015dc6:	202c      	movs	r0, #44	; 0x2c
 8015dc8:	183b      	adds	r3, r7, r0
 8015dca:	801a      	strh	r2, [r3, #0]
 8015dcc:	183b      	adds	r3, r7, r0
 8015dce:	881b      	ldrh	r3, [r3, #0]
 8015dd0:	6a3a      	ldr	r2, [r7, #32]
 8015dd2:	429a      	cmp	r2, r3
 8015dd4:	d000      	beq.n	8015dd8 <ipcp_ackci+0x19c>
 8015dd6:	e153      	b.n	8016080 <ipcp_ackci+0x444>
 8015dd8:	187b      	adds	r3, r7, r1
 8015dda:	881b      	ldrh	r3, [r3, #0]
 8015ddc:	2b02      	cmp	r3, #2
 8015dde:	d000      	beq.n	8015de2 <ipcp_ackci+0x1a6>
 8015de0:	e14e      	b.n	8016080 <ipcp_ackci+0x444>
 8015de2:	68bb      	ldr	r3, [r7, #8]
 8015de4:	1c5a      	adds	r2, r3, #1
 8015de6:	60ba      	str	r2, [r7, #8]
 8015de8:	781b      	ldrb	r3, [r3, #0]
 8015dea:	b29a      	uxth	r2, r3
 8015dec:	201e      	movs	r0, #30
 8015dee:	183b      	adds	r3, r7, r0
 8015df0:	0212      	lsls	r2, r2, #8
 8015df2:	801a      	strh	r2, [r3, #0]
 8015df4:	68bb      	ldr	r3, [r7, #8]
 8015df6:	1c5a      	adds	r2, r3, #1
 8015df8:	60ba      	str	r2, [r7, #8]
 8015dfa:	781b      	ldrb	r3, [r3, #0]
 8015dfc:	b299      	uxth	r1, r3
 8015dfe:	183b      	adds	r3, r7, r0
 8015e00:	183a      	adds	r2, r7, r0
 8015e02:	8812      	ldrh	r2, [r2, #0]
 8015e04:	430a      	orrs	r2, r1
 8015e06:	801a      	strh	r2, [r3, #0]
 8015e08:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015e0a:	8a9b      	ldrh	r3, [r3, #20]
 8015e0c:	183a      	adds	r2, r7, r0
 8015e0e:	8812      	ldrh	r2, [r2, #0]
 8015e10:	429a      	cmp	r2, r3
 8015e12:	d000      	beq.n	8015e16 <ipcp_ackci+0x1da>
 8015e14:	e136      	b.n	8016084 <ipcp_ackci+0x448>
 8015e16:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015e18:	781b      	ldrb	r3, [r3, #0]
 8015e1a:	2210      	movs	r2, #16
 8015e1c:	4013      	ands	r3, r2
 8015e1e:	b2db      	uxtb	r3, r3
 8015e20:	2b00      	cmp	r3, #0
 8015e22:	d11f      	bne.n	8015e64 <ipcp_ackci+0x228>
 8015e24:	68bb      	ldr	r3, [r7, #8]
 8015e26:	1c5a      	adds	r2, r3, #1
 8015e28:	60ba      	str	r2, [r7, #8]
 8015e2a:	211d      	movs	r1, #29
 8015e2c:	187a      	adds	r2, r7, r1
 8015e2e:	781b      	ldrb	r3, [r3, #0]
 8015e30:	7013      	strb	r3, [r2, #0]
 8015e32:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015e34:	7d9b      	ldrb	r3, [r3, #22]
 8015e36:	187a      	adds	r2, r7, r1
 8015e38:	7812      	ldrb	r2, [r2, #0]
 8015e3a:	429a      	cmp	r2, r3
 8015e3c:	d000      	beq.n	8015e40 <ipcp_ackci+0x204>
 8015e3e:	e123      	b.n	8016088 <ipcp_ackci+0x44c>
 8015e40:	68bb      	ldr	r3, [r7, #8]
 8015e42:	1c5a      	adds	r2, r3, #1
 8015e44:	60ba      	str	r2, [r7, #8]
 8015e46:	211c      	movs	r1, #28
 8015e48:	187a      	adds	r2, r7, r1
 8015e4a:	781b      	ldrb	r3, [r3, #0]
 8015e4c:	7013      	strb	r3, [r2, #0]
 8015e4e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015e50:	781b      	ldrb	r3, [r3, #0]
 8015e52:	069b      	lsls	r3, r3, #26
 8015e54:	0fdb      	lsrs	r3, r3, #31
 8015e56:	b2db      	uxtb	r3, r3
 8015e58:	001a      	movs	r2, r3
 8015e5a:	187b      	adds	r3, r7, r1
 8015e5c:	781b      	ldrb	r3, [r3, #0]
 8015e5e:	4293      	cmp	r3, r2
 8015e60:	d000      	beq.n	8015e64 <ipcp_ackci+0x228>
 8015e62:	e113      	b.n	801608c <ipcp_ackci+0x450>
	    go->maxslotindex, go->cflag);
#endif /* VJ_SUPPORT */

    ACKCIADDR(CI_ADDR, go->neg_addr, go->ouraddr);
 8015e64:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015e66:	781b      	ldrb	r3, [r3, #0]
 8015e68:	2201      	movs	r2, #1
 8015e6a:	4013      	ands	r3, r2
 8015e6c:	b2db      	uxtb	r3, r3
 8015e6e:	2b00      	cmp	r3, #0
 8015e70:	d04e      	beq.n	8015f10 <ipcp_ackci+0x2d4>
 8015e72:	687b      	ldr	r3, [r7, #4]
 8015e74:	3b06      	subs	r3, #6
 8015e76:	607b      	str	r3, [r7, #4]
 8015e78:	687b      	ldr	r3, [r7, #4]
 8015e7a:	2b00      	cmp	r3, #0
 8015e7c:	da00      	bge.n	8015e80 <ipcp_ackci+0x244>
 8015e7e:	e107      	b.n	8016090 <ipcp_ackci+0x454>
 8015e80:	68bb      	ldr	r3, [r7, #8]
 8015e82:	1c5a      	adds	r2, r3, #1
 8015e84:	60ba      	str	r2, [r7, #8]
 8015e86:	781a      	ldrb	r2, [r3, #0]
 8015e88:	212e      	movs	r1, #46	; 0x2e
 8015e8a:	187b      	adds	r3, r7, r1
 8015e8c:	801a      	strh	r2, [r3, #0]
 8015e8e:	68bb      	ldr	r3, [r7, #8]
 8015e90:	1c5a      	adds	r2, r3, #1
 8015e92:	60ba      	str	r2, [r7, #8]
 8015e94:	781a      	ldrb	r2, [r3, #0]
 8015e96:	202c      	movs	r0, #44	; 0x2c
 8015e98:	183b      	adds	r3, r7, r0
 8015e9a:	801a      	strh	r2, [r3, #0]
 8015e9c:	183b      	adds	r3, r7, r0
 8015e9e:	881b      	ldrh	r3, [r3, #0]
 8015ea0:	2b06      	cmp	r3, #6
 8015ea2:	d000      	beq.n	8015ea6 <ipcp_ackci+0x26a>
 8015ea4:	e0f6      	b.n	8016094 <ipcp_ackci+0x458>
 8015ea6:	187b      	adds	r3, r7, r1
 8015ea8:	881b      	ldrh	r3, [r3, #0]
 8015eaa:	2b03      	cmp	r3, #3
 8015eac:	d000      	beq.n	8015eb0 <ipcp_ackci+0x274>
 8015eae:	e0f1      	b.n	8016094 <ipcp_ackci+0x458>
 8015eb0:	68bb      	ldr	r3, [r7, #8]
 8015eb2:	1c5a      	adds	r2, r3, #1
 8015eb4:	60ba      	str	r2, [r7, #8]
 8015eb6:	781b      	ldrb	r3, [r3, #0]
 8015eb8:	021b      	lsls	r3, r3, #8
 8015eba:	61bb      	str	r3, [r7, #24]
 8015ebc:	68bb      	ldr	r3, [r7, #8]
 8015ebe:	1c5a      	adds	r2, r3, #1
 8015ec0:	60ba      	str	r2, [r7, #8]
 8015ec2:	781b      	ldrb	r3, [r3, #0]
 8015ec4:	001a      	movs	r2, r3
 8015ec6:	69bb      	ldr	r3, [r7, #24]
 8015ec8:	4313      	orrs	r3, r2
 8015eca:	61bb      	str	r3, [r7, #24]
 8015ecc:	69bb      	ldr	r3, [r7, #24]
 8015ece:	021b      	lsls	r3, r3, #8
 8015ed0:	61bb      	str	r3, [r7, #24]
 8015ed2:	68bb      	ldr	r3, [r7, #8]
 8015ed4:	1c5a      	adds	r2, r3, #1
 8015ed6:	60ba      	str	r2, [r7, #8]
 8015ed8:	781b      	ldrb	r3, [r3, #0]
 8015eda:	001a      	movs	r2, r3
 8015edc:	69bb      	ldr	r3, [r7, #24]
 8015ede:	4313      	orrs	r3, r2
 8015ee0:	61bb      	str	r3, [r7, #24]
 8015ee2:	69bb      	ldr	r3, [r7, #24]
 8015ee4:	021b      	lsls	r3, r3, #8
 8015ee6:	61bb      	str	r3, [r7, #24]
 8015ee8:	68bb      	ldr	r3, [r7, #8]
 8015eea:	1c5a      	adds	r2, r3, #1
 8015eec:	60ba      	str	r2, [r7, #8]
 8015eee:	781b      	ldrb	r3, [r3, #0]
 8015ef0:	001a      	movs	r2, r3
 8015ef2:	69bb      	ldr	r3, [r7, #24]
 8015ef4:	4313      	orrs	r3, r2
 8015ef6:	61bb      	str	r3, [r7, #24]
 8015ef8:	69bb      	ldr	r3, [r7, #24]
 8015efa:	0018      	movs	r0, r3
 8015efc:	f7f1 f810 	bl	8006f20 <lwip_htonl>
 8015f00:	0003      	movs	r3, r0
 8015f02:	627b      	str	r3, [r7, #36]	; 0x24
 8015f04:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015f06:	685b      	ldr	r3, [r3, #4]
 8015f08:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015f0a:	429a      	cmp	r2, r3
 8015f0c:	d000      	beq.n	8015f10 <ipcp_ackci+0x2d4>
 8015f0e:	e0c3      	b.n	8016098 <ipcp_ackci+0x45c>

#if LWIP_DNS
    ACKCIDNS(CI_MS_DNS1, go->req_dns1, go->dnsaddr[0]);
 8015f10:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015f12:	785b      	ldrb	r3, [r3, #1]
 8015f14:	2201      	movs	r2, #1
 8015f16:	4013      	ands	r3, r2
 8015f18:	b2db      	uxtb	r3, r3
 8015f1a:	2b00      	cmp	r3, #0
 8015f1c:	d04e      	beq.n	8015fbc <ipcp_ackci+0x380>
 8015f1e:	687b      	ldr	r3, [r7, #4]
 8015f20:	3b06      	subs	r3, #6
 8015f22:	607b      	str	r3, [r7, #4]
 8015f24:	687b      	ldr	r3, [r7, #4]
 8015f26:	2b00      	cmp	r3, #0
 8015f28:	da00      	bge.n	8015f2c <ipcp_ackci+0x2f0>
 8015f2a:	e0b7      	b.n	801609c <ipcp_ackci+0x460>
 8015f2c:	68bb      	ldr	r3, [r7, #8]
 8015f2e:	1c5a      	adds	r2, r3, #1
 8015f30:	60ba      	str	r2, [r7, #8]
 8015f32:	781a      	ldrb	r2, [r3, #0]
 8015f34:	212e      	movs	r1, #46	; 0x2e
 8015f36:	187b      	adds	r3, r7, r1
 8015f38:	801a      	strh	r2, [r3, #0]
 8015f3a:	68bb      	ldr	r3, [r7, #8]
 8015f3c:	1c5a      	adds	r2, r3, #1
 8015f3e:	60ba      	str	r2, [r7, #8]
 8015f40:	781a      	ldrb	r2, [r3, #0]
 8015f42:	202c      	movs	r0, #44	; 0x2c
 8015f44:	183b      	adds	r3, r7, r0
 8015f46:	801a      	strh	r2, [r3, #0]
 8015f48:	183b      	adds	r3, r7, r0
 8015f4a:	881b      	ldrh	r3, [r3, #0]
 8015f4c:	2b06      	cmp	r3, #6
 8015f4e:	d000      	beq.n	8015f52 <ipcp_ackci+0x316>
 8015f50:	e0a6      	b.n	80160a0 <ipcp_ackci+0x464>
 8015f52:	187b      	adds	r3, r7, r1
 8015f54:	881b      	ldrh	r3, [r3, #0]
 8015f56:	2b81      	cmp	r3, #129	; 0x81
 8015f58:	d000      	beq.n	8015f5c <ipcp_ackci+0x320>
 8015f5a:	e0a1      	b.n	80160a0 <ipcp_ackci+0x464>
 8015f5c:	68bb      	ldr	r3, [r7, #8]
 8015f5e:	1c5a      	adds	r2, r3, #1
 8015f60:	60ba      	str	r2, [r7, #8]
 8015f62:	781b      	ldrb	r3, [r3, #0]
 8015f64:	021b      	lsls	r3, r3, #8
 8015f66:	617b      	str	r3, [r7, #20]
 8015f68:	68bb      	ldr	r3, [r7, #8]
 8015f6a:	1c5a      	adds	r2, r3, #1
 8015f6c:	60ba      	str	r2, [r7, #8]
 8015f6e:	781b      	ldrb	r3, [r3, #0]
 8015f70:	001a      	movs	r2, r3
 8015f72:	697b      	ldr	r3, [r7, #20]
 8015f74:	4313      	orrs	r3, r2
 8015f76:	617b      	str	r3, [r7, #20]
 8015f78:	697b      	ldr	r3, [r7, #20]
 8015f7a:	021b      	lsls	r3, r3, #8
 8015f7c:	617b      	str	r3, [r7, #20]
 8015f7e:	68bb      	ldr	r3, [r7, #8]
 8015f80:	1c5a      	adds	r2, r3, #1
 8015f82:	60ba      	str	r2, [r7, #8]
 8015f84:	781b      	ldrb	r3, [r3, #0]
 8015f86:	001a      	movs	r2, r3
 8015f88:	697b      	ldr	r3, [r7, #20]
 8015f8a:	4313      	orrs	r3, r2
 8015f8c:	617b      	str	r3, [r7, #20]
 8015f8e:	697b      	ldr	r3, [r7, #20]
 8015f90:	021b      	lsls	r3, r3, #8
 8015f92:	617b      	str	r3, [r7, #20]
 8015f94:	68bb      	ldr	r3, [r7, #8]
 8015f96:	1c5a      	adds	r2, r3, #1
 8015f98:	60ba      	str	r2, [r7, #8]
 8015f9a:	781b      	ldrb	r3, [r3, #0]
 8015f9c:	001a      	movs	r2, r3
 8015f9e:	697b      	ldr	r3, [r7, #20]
 8015fa0:	4313      	orrs	r3, r2
 8015fa2:	617b      	str	r3, [r7, #20]
 8015fa4:	697b      	ldr	r3, [r7, #20]
 8015fa6:	0018      	movs	r0, r3
 8015fa8:	f7f0 ffba 	bl	8006f20 <lwip_htonl>
 8015fac:	0003      	movs	r3, r0
 8015fae:	627b      	str	r3, [r7, #36]	; 0x24
 8015fb0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015fb2:	68db      	ldr	r3, [r3, #12]
 8015fb4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015fb6:	429a      	cmp	r2, r3
 8015fb8:	d000      	beq.n	8015fbc <ipcp_ackci+0x380>
 8015fba:	e073      	b.n	80160a4 <ipcp_ackci+0x468>

    ACKCIDNS(CI_MS_DNS2, go->req_dns2, go->dnsaddr[1]);
 8015fbc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015fbe:	785b      	ldrb	r3, [r3, #1]
 8015fc0:	2202      	movs	r2, #2
 8015fc2:	4013      	ands	r3, r2
 8015fc4:	b2db      	uxtb	r3, r3
 8015fc6:	2b00      	cmp	r3, #0
 8015fc8:	d04b      	beq.n	8016062 <ipcp_ackci+0x426>
 8015fca:	687b      	ldr	r3, [r7, #4]
 8015fcc:	3b06      	subs	r3, #6
 8015fce:	607b      	str	r3, [r7, #4]
 8015fd0:	687b      	ldr	r3, [r7, #4]
 8015fd2:	2b00      	cmp	r3, #0
 8015fd4:	da00      	bge.n	8015fd8 <ipcp_ackci+0x39c>
 8015fd6:	e067      	b.n	80160a8 <ipcp_ackci+0x46c>
 8015fd8:	68bb      	ldr	r3, [r7, #8]
 8015fda:	1c5a      	adds	r2, r3, #1
 8015fdc:	60ba      	str	r2, [r7, #8]
 8015fde:	781a      	ldrb	r2, [r3, #0]
 8015fe0:	212e      	movs	r1, #46	; 0x2e
 8015fe2:	187b      	adds	r3, r7, r1
 8015fe4:	801a      	strh	r2, [r3, #0]
 8015fe6:	68bb      	ldr	r3, [r7, #8]
 8015fe8:	1c5a      	adds	r2, r3, #1
 8015fea:	60ba      	str	r2, [r7, #8]
 8015fec:	781a      	ldrb	r2, [r3, #0]
 8015fee:	202c      	movs	r0, #44	; 0x2c
 8015ff0:	183b      	adds	r3, r7, r0
 8015ff2:	801a      	strh	r2, [r3, #0]
 8015ff4:	183b      	adds	r3, r7, r0
 8015ff6:	881b      	ldrh	r3, [r3, #0]
 8015ff8:	2b06      	cmp	r3, #6
 8015ffa:	d157      	bne.n	80160ac <ipcp_ackci+0x470>
 8015ffc:	187b      	adds	r3, r7, r1
 8015ffe:	881b      	ldrh	r3, [r3, #0]
 8016000:	2b83      	cmp	r3, #131	; 0x83
 8016002:	d153      	bne.n	80160ac <ipcp_ackci+0x470>
 8016004:	68bb      	ldr	r3, [r7, #8]
 8016006:	1c5a      	adds	r2, r3, #1
 8016008:	60ba      	str	r2, [r7, #8]
 801600a:	781b      	ldrb	r3, [r3, #0]
 801600c:	021b      	lsls	r3, r3, #8
 801600e:	613b      	str	r3, [r7, #16]
 8016010:	68bb      	ldr	r3, [r7, #8]
 8016012:	1c5a      	adds	r2, r3, #1
 8016014:	60ba      	str	r2, [r7, #8]
 8016016:	781b      	ldrb	r3, [r3, #0]
 8016018:	001a      	movs	r2, r3
 801601a:	693b      	ldr	r3, [r7, #16]
 801601c:	4313      	orrs	r3, r2
 801601e:	613b      	str	r3, [r7, #16]
 8016020:	693b      	ldr	r3, [r7, #16]
 8016022:	021b      	lsls	r3, r3, #8
 8016024:	613b      	str	r3, [r7, #16]
 8016026:	68bb      	ldr	r3, [r7, #8]
 8016028:	1c5a      	adds	r2, r3, #1
 801602a:	60ba      	str	r2, [r7, #8]
 801602c:	781b      	ldrb	r3, [r3, #0]
 801602e:	001a      	movs	r2, r3
 8016030:	693b      	ldr	r3, [r7, #16]
 8016032:	4313      	orrs	r3, r2
 8016034:	613b      	str	r3, [r7, #16]
 8016036:	693b      	ldr	r3, [r7, #16]
 8016038:	021b      	lsls	r3, r3, #8
 801603a:	613b      	str	r3, [r7, #16]
 801603c:	68bb      	ldr	r3, [r7, #8]
 801603e:	1c5a      	adds	r2, r3, #1
 8016040:	60ba      	str	r2, [r7, #8]
 8016042:	781b      	ldrb	r3, [r3, #0]
 8016044:	001a      	movs	r2, r3
 8016046:	693b      	ldr	r3, [r7, #16]
 8016048:	4313      	orrs	r3, r2
 801604a:	613b      	str	r3, [r7, #16]
 801604c:	693b      	ldr	r3, [r7, #16]
 801604e:	0018      	movs	r0, r3
 8016050:	f7f0 ff66 	bl	8006f20 <lwip_htonl>
 8016054:	0003      	movs	r3, r0
 8016056:	627b      	str	r3, [r7, #36]	; 0x24
 8016058:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801605a:	691b      	ldr	r3, [r3, #16]
 801605c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801605e:	429a      	cmp	r2, r3
 8016060:	d126      	bne.n	80160b0 <ipcp_ackci+0x474>
#endif /* UNUSED - WINS */

    /*
     * If there are any remaining CIs, then this packet is bad.
     */
    if (len != 0)
 8016062:	687b      	ldr	r3, [r7, #4]
 8016064:	2b00      	cmp	r3, #0
 8016066:	d125      	bne.n	80160b4 <ipcp_ackci+0x478>
	goto bad;
    return (1);
 8016068:	2301      	movs	r3, #1
 801606a:	e025      	b.n	80160b8 <ipcp_ackci+0x47c>
    ACKCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs, go->ouraddr,
 801606c:	46c0      	nop			; (mov r8, r8)
 801606e:	e022      	b.n	80160b6 <ipcp_ackci+0x47a>
 8016070:	46c0      	nop			; (mov r8, r8)
 8016072:	e020      	b.n	80160b6 <ipcp_ackci+0x47a>
 8016074:	46c0      	nop			; (mov r8, r8)
 8016076:	e01e      	b.n	80160b6 <ipcp_ackci+0x47a>
 8016078:	46c0      	nop			; (mov r8, r8)
 801607a:	e01c      	b.n	80160b6 <ipcp_ackci+0x47a>
    ACKCIVJ(CI_COMPRESSTYPE, go->neg_vj, go->vj_protocol, go->old_vj,
 801607c:	46c0      	nop			; (mov r8, r8)
 801607e:	e01a      	b.n	80160b6 <ipcp_ackci+0x47a>
 8016080:	46c0      	nop			; (mov r8, r8)
 8016082:	e018      	b.n	80160b6 <ipcp_ackci+0x47a>
 8016084:	46c0      	nop			; (mov r8, r8)
 8016086:	e016      	b.n	80160b6 <ipcp_ackci+0x47a>
 8016088:	46c0      	nop			; (mov r8, r8)
 801608a:	e014      	b.n	80160b6 <ipcp_ackci+0x47a>
 801608c:	46c0      	nop			; (mov r8, r8)
 801608e:	e012      	b.n	80160b6 <ipcp_ackci+0x47a>
    ACKCIADDR(CI_ADDR, go->neg_addr, go->ouraddr);
 8016090:	46c0      	nop			; (mov r8, r8)
 8016092:	e010      	b.n	80160b6 <ipcp_ackci+0x47a>
 8016094:	46c0      	nop			; (mov r8, r8)
 8016096:	e00e      	b.n	80160b6 <ipcp_ackci+0x47a>
 8016098:	46c0      	nop			; (mov r8, r8)
 801609a:	e00c      	b.n	80160b6 <ipcp_ackci+0x47a>
    ACKCIDNS(CI_MS_DNS1, go->req_dns1, go->dnsaddr[0]);
 801609c:	46c0      	nop			; (mov r8, r8)
 801609e:	e00a      	b.n	80160b6 <ipcp_ackci+0x47a>
 80160a0:	46c0      	nop			; (mov r8, r8)
 80160a2:	e008      	b.n	80160b6 <ipcp_ackci+0x47a>
 80160a4:	46c0      	nop			; (mov r8, r8)
 80160a6:	e006      	b.n	80160b6 <ipcp_ackci+0x47a>
    ACKCIDNS(CI_MS_DNS2, go->req_dns2, go->dnsaddr[1]);
 80160a8:	46c0      	nop			; (mov r8, r8)
 80160aa:	e004      	b.n	80160b6 <ipcp_ackci+0x47a>
 80160ac:	46c0      	nop			; (mov r8, r8)
 80160ae:	e002      	b.n	80160b6 <ipcp_ackci+0x47a>
 80160b0:	46c0      	nop			; (mov r8, r8)
 80160b2:	e000      	b.n	80160b6 <ipcp_ackci+0x47a>
	goto bad;
 80160b4:	46c0      	nop			; (mov r8, r8)

bad:
    IPCPDEBUG(("ipcp_ackci: received bad Ack!"));
    return (0);
 80160b6:	2300      	movs	r3, #0
}
 80160b8:	0018      	movs	r0, r3
 80160ba:	46bd      	mov	sp, r7
 80160bc:	b00e      	add	sp, #56	; 0x38
 80160be:	bd80      	pop	{r7, pc}

080160c0 <ipcp_nakci>:
 *
 * Returns:
 *	0 - Nak was bad.
 *	1 - Nak was good.
 */
static int ipcp_nakci(fsm *f, u_char *p, int len, int treat_as_reject) {
 80160c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80160c2:	b09b      	sub	sp, #108	; 0x6c
 80160c4:	af00      	add	r7, sp, #0
 80160c6:	60f8      	str	r0, [r7, #12]
 80160c8:	60b9      	str	r1, [r7, #8]
 80160ca:	607a      	str	r2, [r7, #4]
 80160cc:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 80160ce:	68fb      	ldr	r3, [r7, #12]
 80160d0:	681b      	ldr	r3, [r3, #0]
 80160d2:	667b      	str	r3, [r7, #100]	; 0x64
    ipcp_options *go = &pcb->ipcp_gotoptions;
 80160d4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80160d6:	4ae0      	ldr	r2, [pc, #896]	; (8016458 <ipcp_nakci+0x398>)
 80160d8:	4694      	mov	ip, r2
 80160da:	4463      	add	r3, ip
 80160dc:	663b      	str	r3, [r7, #96]	; 0x60
    u32_t cidnsaddr;
#endif /* LWIP_DNS */
    ipcp_options no;		/* options we've seen Naks for */
    ipcp_options try_;		/* options to request next time */

    BZERO(&no, sizeof(no));
 80160de:	2428      	movs	r4, #40	; 0x28
 80160e0:	193b      	adds	r3, r7, r4
 80160e2:	2218      	movs	r2, #24
 80160e4:	2100      	movs	r1, #0
 80160e6:	0018      	movs	r0, r3
 80160e8:	f006 ff0c 	bl	801cf04 <memset>
    try_ = *go;
 80160ec:	2510      	movs	r5, #16
 80160ee:	197b      	adds	r3, r7, r5
 80160f0:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 80160f2:	ca43      	ldmia	r2!, {r0, r1, r6}
 80160f4:	c343      	stmia	r3!, {r0, r1, r6}
 80160f6:	ca43      	ldmia	r2!, {r0, r1, r6}
 80160f8:	c343      	stmia	r3!, {r0, r1, r6}

    /*
     * Accept the peer's idea of {our,his} address, if different
     * from our idea, only if the accept_{local,remote} flag is set.
     */
    NAKCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs,
 80160fa:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80160fc:	781b      	ldrb	r3, [r3, #0]
 80160fe:	2201      	movs	r2, #1
 8016100:	4013      	ands	r3, r2
 8016102:	b2db      	uxtb	r3, r3
 8016104:	2b00      	cmp	r3, #0
 8016106:	d000      	beq.n	801610a <ipcp_nakci+0x4a>
 8016108:	e0a2      	b.n	8016250 <ipcp_nakci+0x190>
 801610a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801610c:	781b      	ldrb	r3, [r3, #0]
 801610e:	2202      	movs	r2, #2
 8016110:	4013      	ands	r3, r2
 8016112:	b2db      	uxtb	r3, r3
 8016114:	2b00      	cmp	r3, #0
 8016116:	d100      	bne.n	801611a <ipcp_nakci+0x5a>
 8016118:	e09a      	b.n	8016250 <ipcp_nakci+0x190>
 801611a:	215f      	movs	r1, #95	; 0x5f
 801611c:	187b      	adds	r3, r7, r1
 801611e:	68ba      	ldr	r2, [r7, #8]
 8016120:	7852      	ldrb	r2, [r2, #1]
 8016122:	701a      	strb	r2, [r3, #0]
 8016124:	187b      	adds	r3, r7, r1
 8016126:	781b      	ldrb	r3, [r3, #0]
 8016128:	2b0a      	cmp	r3, #10
 801612a:	d000      	beq.n	801612e <ipcp_nakci+0x6e>
 801612c:	e090      	b.n	8016250 <ipcp_nakci+0x190>
 801612e:	187b      	adds	r3, r7, r1
 8016130:	781b      	ldrb	r3, [r3, #0]
 8016132:	687a      	ldr	r2, [r7, #4]
 8016134:	429a      	cmp	r2, r3
 8016136:	da00      	bge.n	801613a <ipcp_nakci+0x7a>
 8016138:	e08a      	b.n	8016250 <ipcp_nakci+0x190>
 801613a:	68bb      	ldr	r3, [r7, #8]
 801613c:	781b      	ldrb	r3, [r3, #0]
 801613e:	2b01      	cmp	r3, #1
 8016140:	d000      	beq.n	8016144 <ipcp_nakci+0x84>
 8016142:	e085      	b.n	8016250 <ipcp_nakci+0x190>
 8016144:	187b      	adds	r3, r7, r1
 8016146:	781b      	ldrb	r3, [r3, #0]
 8016148:	687a      	ldr	r2, [r7, #4]
 801614a:	1ad3      	subs	r3, r2, r3
 801614c:	607b      	str	r3, [r7, #4]
 801614e:	68bb      	ldr	r3, [r7, #8]
 8016150:	3302      	adds	r3, #2
 8016152:	60bb      	str	r3, [r7, #8]
 8016154:	68bb      	ldr	r3, [r7, #8]
 8016156:	1c5a      	adds	r2, r3, #1
 8016158:	60ba      	str	r2, [r7, #8]
 801615a:	781b      	ldrb	r3, [r3, #0]
 801615c:	021b      	lsls	r3, r3, #8
 801615e:	65bb      	str	r3, [r7, #88]	; 0x58
 8016160:	68bb      	ldr	r3, [r7, #8]
 8016162:	1c5a      	adds	r2, r3, #1
 8016164:	60ba      	str	r2, [r7, #8]
 8016166:	781b      	ldrb	r3, [r3, #0]
 8016168:	001a      	movs	r2, r3
 801616a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801616c:	4313      	orrs	r3, r2
 801616e:	65bb      	str	r3, [r7, #88]	; 0x58
 8016170:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016172:	021b      	lsls	r3, r3, #8
 8016174:	65bb      	str	r3, [r7, #88]	; 0x58
 8016176:	68bb      	ldr	r3, [r7, #8]
 8016178:	1c5a      	adds	r2, r3, #1
 801617a:	60ba      	str	r2, [r7, #8]
 801617c:	781b      	ldrb	r3, [r3, #0]
 801617e:	001a      	movs	r2, r3
 8016180:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016182:	4313      	orrs	r3, r2
 8016184:	65bb      	str	r3, [r7, #88]	; 0x58
 8016186:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016188:	021b      	lsls	r3, r3, #8
 801618a:	65bb      	str	r3, [r7, #88]	; 0x58
 801618c:	68bb      	ldr	r3, [r7, #8]
 801618e:	1c5a      	adds	r2, r3, #1
 8016190:	60ba      	str	r2, [r7, #8]
 8016192:	781b      	ldrb	r3, [r3, #0]
 8016194:	001a      	movs	r2, r3
 8016196:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016198:	4313      	orrs	r3, r2
 801619a:	65bb      	str	r3, [r7, #88]	; 0x58
 801619c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801619e:	0018      	movs	r0, r3
 80161a0:	f7f0 febe 	bl	8006f20 <lwip_htonl>
 80161a4:	0003      	movs	r3, r0
 80161a6:	657b      	str	r3, [r7, #84]	; 0x54
 80161a8:	68bb      	ldr	r3, [r7, #8]
 80161aa:	1c5a      	adds	r2, r3, #1
 80161ac:	60ba      	str	r2, [r7, #8]
 80161ae:	781b      	ldrb	r3, [r3, #0]
 80161b0:	021b      	lsls	r3, r3, #8
 80161b2:	65bb      	str	r3, [r7, #88]	; 0x58
 80161b4:	68bb      	ldr	r3, [r7, #8]
 80161b6:	1c5a      	adds	r2, r3, #1
 80161b8:	60ba      	str	r2, [r7, #8]
 80161ba:	781b      	ldrb	r3, [r3, #0]
 80161bc:	001a      	movs	r2, r3
 80161be:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80161c0:	4313      	orrs	r3, r2
 80161c2:	65bb      	str	r3, [r7, #88]	; 0x58
 80161c4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80161c6:	021b      	lsls	r3, r3, #8
 80161c8:	65bb      	str	r3, [r7, #88]	; 0x58
 80161ca:	68bb      	ldr	r3, [r7, #8]
 80161cc:	1c5a      	adds	r2, r3, #1
 80161ce:	60ba      	str	r2, [r7, #8]
 80161d0:	781b      	ldrb	r3, [r3, #0]
 80161d2:	001a      	movs	r2, r3
 80161d4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80161d6:	4313      	orrs	r3, r2
 80161d8:	65bb      	str	r3, [r7, #88]	; 0x58
 80161da:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80161dc:	021b      	lsls	r3, r3, #8
 80161de:	65bb      	str	r3, [r7, #88]	; 0x58
 80161e0:	68bb      	ldr	r3, [r7, #8]
 80161e2:	1c5a      	adds	r2, r3, #1
 80161e4:	60ba      	str	r2, [r7, #8]
 80161e6:	781b      	ldrb	r3, [r3, #0]
 80161e8:	001a      	movs	r2, r3
 80161ea:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80161ec:	4313      	orrs	r3, r2
 80161ee:	65bb      	str	r3, [r7, #88]	; 0x58
 80161f0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80161f2:	0018      	movs	r0, r3
 80161f4:	f7f0 fe94 	bl	8006f20 <lwip_htonl>
 80161f8:	0003      	movs	r3, r0
 80161fa:	653b      	str	r3, [r7, #80]	; 0x50
 80161fc:	193b      	adds	r3, r7, r4
 80161fe:	781a      	ldrb	r2, [r3, #0]
 8016200:	2102      	movs	r1, #2
 8016202:	430a      	orrs	r2, r1
 8016204:	701a      	strb	r2, [r3, #0]
 8016206:	683b      	ldr	r3, [r7, #0]
 8016208:	2b00      	cmp	r3, #0
 801620a:	d005      	beq.n	8016218 <ipcp_nakci+0x158>
 801620c:	197b      	adds	r3, r7, r5
 801620e:	781a      	ldrb	r2, [r3, #0]
 8016210:	2102      	movs	r1, #2
 8016212:	438a      	bics	r2, r1
 8016214:	701a      	strb	r2, [r3, #0]
 8016216:	e01b      	b.n	8016250 <ipcp_nakci+0x190>
 8016218:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801621a:	781b      	ldrb	r3, [r3, #0]
 801621c:	2240      	movs	r2, #64	; 0x40
 801621e:	4013      	ands	r3, r2
 8016220:	b2db      	uxtb	r3, r3
 8016222:	2b00      	cmp	r3, #0
 8016224:	d006      	beq.n	8016234 <ipcp_nakci+0x174>
 8016226:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016228:	2b00      	cmp	r3, #0
 801622a:	d003      	beq.n	8016234 <ipcp_nakci+0x174>
 801622c:	2310      	movs	r3, #16
 801622e:	18fb      	adds	r3, r7, r3
 8016230:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8016232:	605a      	str	r2, [r3, #4]
 8016234:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016236:	781b      	ldrb	r3, [r3, #0]
 8016238:	227f      	movs	r2, #127	; 0x7f
 801623a:	4393      	bics	r3, r2
 801623c:	b2db      	uxtb	r3, r3
 801623e:	2b00      	cmp	r3, #0
 8016240:	d006      	beq.n	8016250 <ipcp_nakci+0x190>
 8016242:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016244:	2b00      	cmp	r3, #0
 8016246:	d003      	beq.n	8016250 <ipcp_nakci+0x190>
 8016248:	2310      	movs	r3, #16
 801624a:	18fb      	adds	r3, r7, r3
 801624c:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 801624e:	609a      	str	r2, [r3, #8]
     * Accept the peer's value of maxslotindex provided that it
     * is less than what we asked for.  Turn off slot-ID compression
     * if the peer wants.  Send old-style compress-type option if
     * the peer wants.
     */
    NAKCIVJ(CI_COMPRESSTYPE, neg_vj,
 8016250:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016252:	781b      	ldrb	r3, [r3, #0]
 8016254:	2208      	movs	r2, #8
 8016256:	4013      	ands	r3, r2
 8016258:	b2db      	uxtb	r3, r3
 801625a:	2b00      	cmp	r3, #0
 801625c:	d100      	bne.n	8016260 <ipcp_nakci+0x1a0>
 801625e:	e09b      	b.n	8016398 <ipcp_nakci+0x2d8>
 8016260:	215f      	movs	r1, #95	; 0x5f
 8016262:	187b      	adds	r3, r7, r1
 8016264:	68ba      	ldr	r2, [r7, #8]
 8016266:	7852      	ldrb	r2, [r2, #1]
 8016268:	701a      	strb	r2, [r3, #0]
 801626a:	000a      	movs	r2, r1
 801626c:	18bb      	adds	r3, r7, r2
 801626e:	781b      	ldrb	r3, [r3, #0]
 8016270:	2b04      	cmp	r3, #4
 8016272:	d004      	beq.n	801627e <ipcp_nakci+0x1be>
 8016274:	18bb      	adds	r3, r7, r2
 8016276:	781b      	ldrb	r3, [r3, #0]
 8016278:	2b06      	cmp	r3, #6
 801627a:	d000      	beq.n	801627e <ipcp_nakci+0x1be>
 801627c:	e08c      	b.n	8016398 <ipcp_nakci+0x2d8>
 801627e:	215f      	movs	r1, #95	; 0x5f
 8016280:	187b      	adds	r3, r7, r1
 8016282:	781b      	ldrb	r3, [r3, #0]
 8016284:	687a      	ldr	r2, [r7, #4]
 8016286:	429a      	cmp	r2, r3
 8016288:	da00      	bge.n	801628c <ipcp_nakci+0x1cc>
 801628a:	e085      	b.n	8016398 <ipcp_nakci+0x2d8>
 801628c:	68bb      	ldr	r3, [r7, #8]
 801628e:	781b      	ldrb	r3, [r3, #0]
 8016290:	2b02      	cmp	r3, #2
 8016292:	d000      	beq.n	8016296 <ipcp_nakci+0x1d6>
 8016294:	e080      	b.n	8016398 <ipcp_nakci+0x2d8>
 8016296:	187b      	adds	r3, r7, r1
 8016298:	781b      	ldrb	r3, [r3, #0]
 801629a:	687a      	ldr	r2, [r7, #4]
 801629c:	1ad3      	subs	r3, r2, r3
 801629e:	607b      	str	r3, [r7, #4]
 80162a0:	68bb      	ldr	r3, [r7, #8]
 80162a2:	3302      	adds	r3, #2
 80162a4:	60bb      	str	r3, [r7, #8]
 80162a6:	68bb      	ldr	r3, [r7, #8]
 80162a8:	1c5a      	adds	r2, r3, #1
 80162aa:	60ba      	str	r2, [r7, #8]
 80162ac:	781b      	ldrb	r3, [r3, #0]
 80162ae:	b29a      	uxth	r2, r3
 80162b0:	204e      	movs	r0, #78	; 0x4e
 80162b2:	183b      	adds	r3, r7, r0
 80162b4:	0212      	lsls	r2, r2, #8
 80162b6:	801a      	strh	r2, [r3, #0]
 80162b8:	68bb      	ldr	r3, [r7, #8]
 80162ba:	1c5a      	adds	r2, r3, #1
 80162bc:	60ba      	str	r2, [r7, #8]
 80162be:	781b      	ldrb	r3, [r3, #0]
 80162c0:	b299      	uxth	r1, r3
 80162c2:	183b      	adds	r3, r7, r0
 80162c4:	183a      	adds	r2, r7, r0
 80162c6:	8812      	ldrh	r2, [r2, #0]
 80162c8:	430a      	orrs	r2, r1
 80162ca:	801a      	strh	r2, [r3, #0]
 80162cc:	2328      	movs	r3, #40	; 0x28
 80162ce:	18fb      	adds	r3, r7, r3
 80162d0:	781a      	ldrb	r2, [r3, #0]
 80162d2:	2108      	movs	r1, #8
 80162d4:	430a      	orrs	r2, r1
 80162d6:	701a      	strb	r2, [r3, #0]
 80162d8:	683b      	ldr	r3, [r7, #0]
 80162da:	2b00      	cmp	r3, #0
 80162dc:	d006      	beq.n	80162ec <ipcp_nakci+0x22c>
 80162de:	2310      	movs	r3, #16
 80162e0:	18fb      	adds	r3, r7, r3
 80162e2:	781a      	ldrb	r2, [r3, #0]
 80162e4:	2108      	movs	r1, #8
 80162e6:	438a      	bics	r2, r1
 80162e8:	701a      	strb	r2, [r3, #0]
 80162ea:	e055      	b.n	8016398 <ipcp_nakci+0x2d8>
 80162ec:	235f      	movs	r3, #95	; 0x5f
 80162ee:	18fb      	adds	r3, r7, r3
 80162f0:	781b      	ldrb	r3, [r3, #0]
 80162f2:	2b06      	cmp	r3, #6
 80162f4:	d135      	bne.n	8016362 <ipcp_nakci+0x2a2>
 80162f6:	68bb      	ldr	r3, [r7, #8]
 80162f8:	1c5a      	adds	r2, r3, #1
 80162fa:	60ba      	str	r2, [r7, #8]
 80162fc:	204d      	movs	r0, #77	; 0x4d
 80162fe:	183a      	adds	r2, r7, r0
 8016300:	781b      	ldrb	r3, [r3, #0]
 8016302:	7013      	strb	r3, [r2, #0]
 8016304:	68bb      	ldr	r3, [r7, #8]
 8016306:	1c5a      	adds	r2, r3, #1
 8016308:	60ba      	str	r2, [r7, #8]
 801630a:	224c      	movs	r2, #76	; 0x4c
 801630c:	18ba      	adds	r2, r7, r2
 801630e:	781b      	ldrb	r3, [r3, #0]
 8016310:	7013      	strb	r3, [r2, #0]
 8016312:	234e      	movs	r3, #78	; 0x4e
 8016314:	18fb      	adds	r3, r7, r3
 8016316:	881b      	ldrh	r3, [r3, #0]
 8016318:	2b2d      	cmp	r3, #45	; 0x2d
 801631a:	d11b      	bne.n	8016354 <ipcp_nakci+0x294>
 801631c:	2410      	movs	r4, #16
 801631e:	193b      	adds	r3, r7, r4
 8016320:	781a      	ldrb	r2, [r3, #0]
 8016322:	2110      	movs	r1, #16
 8016324:	438a      	bics	r2, r1
 8016326:	701a      	strb	r2, [r3, #0]
 8016328:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801632a:	7d9b      	ldrb	r3, [r3, #22]
 801632c:	183a      	adds	r2, r7, r0
 801632e:	7812      	ldrb	r2, [r2, #0]
 8016330:	429a      	cmp	r2, r3
 8016332:	d203      	bcs.n	801633c <ipcp_nakci+0x27c>
 8016334:	193b      	adds	r3, r7, r4
 8016336:	183a      	adds	r2, r7, r0
 8016338:	7812      	ldrb	r2, [r2, #0]
 801633a:	759a      	strb	r2, [r3, #22]
 801633c:	234c      	movs	r3, #76	; 0x4c
 801633e:	18fb      	adds	r3, r7, r3
 8016340:	781b      	ldrb	r3, [r3, #0]
 8016342:	2b00      	cmp	r3, #0
 8016344:	d128      	bne.n	8016398 <ipcp_nakci+0x2d8>
 8016346:	2310      	movs	r3, #16
 8016348:	18fb      	adds	r3, r7, r3
 801634a:	781a      	ldrb	r2, [r3, #0]
 801634c:	2120      	movs	r1, #32
 801634e:	438a      	bics	r2, r1
 8016350:	701a      	strb	r2, [r3, #0]
 8016352:	e021      	b.n	8016398 <ipcp_nakci+0x2d8>
 8016354:	2310      	movs	r3, #16
 8016356:	18fb      	adds	r3, r7, r3
 8016358:	781a      	ldrb	r2, [r3, #0]
 801635a:	2108      	movs	r1, #8
 801635c:	438a      	bics	r2, r1
 801635e:	701a      	strb	r2, [r3, #0]
 8016360:	e01a      	b.n	8016398 <ipcp_nakci+0x2d8>
 8016362:	224e      	movs	r2, #78	; 0x4e
 8016364:	18bb      	adds	r3, r7, r2
 8016366:	881b      	ldrh	r3, [r3, #0]
 8016368:	2b2d      	cmp	r3, #45	; 0x2d
 801636a:	d003      	beq.n	8016374 <ipcp_nakci+0x2b4>
 801636c:	18bb      	adds	r3, r7, r2
 801636e:	881b      	ldrh	r3, [r3, #0]
 8016370:	2b37      	cmp	r3, #55	; 0x37
 8016372:	d10b      	bne.n	801638c <ipcp_nakci+0x2cc>
 8016374:	2010      	movs	r0, #16
 8016376:	183b      	adds	r3, r7, r0
 8016378:	781a      	ldrb	r2, [r3, #0]
 801637a:	2110      	movs	r1, #16
 801637c:	430a      	orrs	r2, r1
 801637e:	701a      	strb	r2, [r3, #0]
 8016380:	183b      	adds	r3, r7, r0
 8016382:	224e      	movs	r2, #78	; 0x4e
 8016384:	18ba      	adds	r2, r7, r2
 8016386:	8812      	ldrh	r2, [r2, #0]
 8016388:	829a      	strh	r2, [r3, #20]
 801638a:	e005      	b.n	8016398 <ipcp_nakci+0x2d8>
 801638c:	2310      	movs	r3, #16
 801638e:	18fb      	adds	r3, r7, r3
 8016390:	781a      	ldrb	r2, [r3, #0]
 8016392:	2108      	movs	r1, #8
 8016394:	438a      	bics	r2, r1
 8016396:	701a      	strb	r2, [r3, #0]
		}
	    }
	    );
#endif /* VJ_SUPPORT */

    NAKCIADDR(CI_ADDR, neg_addr,
 8016398:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801639a:	781b      	ldrb	r3, [r3, #0]
 801639c:	2201      	movs	r2, #1
 801639e:	4013      	ands	r3, r2
 80163a0:	b2db      	uxtb	r3, r3
 80163a2:	2b00      	cmp	r3, #0
 80163a4:	d068      	beq.n	8016478 <ipcp_nakci+0x3b8>
 80163a6:	215f      	movs	r1, #95	; 0x5f
 80163a8:	187b      	adds	r3, r7, r1
 80163aa:	68ba      	ldr	r2, [r7, #8]
 80163ac:	7852      	ldrb	r2, [r2, #1]
 80163ae:	701a      	strb	r2, [r3, #0]
 80163b0:	187b      	adds	r3, r7, r1
 80163b2:	781b      	ldrb	r3, [r3, #0]
 80163b4:	2b06      	cmp	r3, #6
 80163b6:	d15f      	bne.n	8016478 <ipcp_nakci+0x3b8>
 80163b8:	187b      	adds	r3, r7, r1
 80163ba:	781b      	ldrb	r3, [r3, #0]
 80163bc:	687a      	ldr	r2, [r7, #4]
 80163be:	429a      	cmp	r2, r3
 80163c0:	db5a      	blt.n	8016478 <ipcp_nakci+0x3b8>
 80163c2:	68bb      	ldr	r3, [r7, #8]
 80163c4:	781b      	ldrb	r3, [r3, #0]
 80163c6:	2b03      	cmp	r3, #3
 80163c8:	d156      	bne.n	8016478 <ipcp_nakci+0x3b8>
 80163ca:	187b      	adds	r3, r7, r1
 80163cc:	781b      	ldrb	r3, [r3, #0]
 80163ce:	687a      	ldr	r2, [r7, #4]
 80163d0:	1ad3      	subs	r3, r2, r3
 80163d2:	607b      	str	r3, [r7, #4]
 80163d4:	68bb      	ldr	r3, [r7, #8]
 80163d6:	3302      	adds	r3, #2
 80163d8:	60bb      	str	r3, [r7, #8]
 80163da:	68bb      	ldr	r3, [r7, #8]
 80163dc:	1c5a      	adds	r2, r3, #1
 80163de:	60ba      	str	r2, [r7, #8]
 80163e0:	781b      	ldrb	r3, [r3, #0]
 80163e2:	021b      	lsls	r3, r3, #8
 80163e4:	65bb      	str	r3, [r7, #88]	; 0x58
 80163e6:	68bb      	ldr	r3, [r7, #8]
 80163e8:	1c5a      	adds	r2, r3, #1
 80163ea:	60ba      	str	r2, [r7, #8]
 80163ec:	781b      	ldrb	r3, [r3, #0]
 80163ee:	001a      	movs	r2, r3
 80163f0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80163f2:	4313      	orrs	r3, r2
 80163f4:	65bb      	str	r3, [r7, #88]	; 0x58
 80163f6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80163f8:	021b      	lsls	r3, r3, #8
 80163fa:	65bb      	str	r3, [r7, #88]	; 0x58
 80163fc:	68bb      	ldr	r3, [r7, #8]
 80163fe:	1c5a      	adds	r2, r3, #1
 8016400:	60ba      	str	r2, [r7, #8]
 8016402:	781b      	ldrb	r3, [r3, #0]
 8016404:	001a      	movs	r2, r3
 8016406:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016408:	4313      	orrs	r3, r2
 801640a:	65bb      	str	r3, [r7, #88]	; 0x58
 801640c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801640e:	021b      	lsls	r3, r3, #8
 8016410:	65bb      	str	r3, [r7, #88]	; 0x58
 8016412:	68bb      	ldr	r3, [r7, #8]
 8016414:	1c5a      	adds	r2, r3, #1
 8016416:	60ba      	str	r2, [r7, #8]
 8016418:	781b      	ldrb	r3, [r3, #0]
 801641a:	001a      	movs	r2, r3
 801641c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801641e:	4313      	orrs	r3, r2
 8016420:	65bb      	str	r3, [r7, #88]	; 0x58
 8016422:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016424:	0018      	movs	r0, r3
 8016426:	f7f0 fd7b 	bl	8006f20 <lwip_htonl>
 801642a:	0003      	movs	r3, r0
 801642c:	657b      	str	r3, [r7, #84]	; 0x54
 801642e:	2328      	movs	r3, #40	; 0x28
 8016430:	18fb      	adds	r3, r7, r3
 8016432:	781a      	ldrb	r2, [r3, #0]
 8016434:	2101      	movs	r1, #1
 8016436:	430a      	orrs	r2, r1
 8016438:	701a      	strb	r2, [r3, #0]
 801643a:	683b      	ldr	r3, [r7, #0]
 801643c:	2b00      	cmp	r3, #0
 801643e:	d00d      	beq.n	801645c <ipcp_nakci+0x39c>
 8016440:	2010      	movs	r0, #16
 8016442:	183b      	adds	r3, r7, r0
 8016444:	781a      	ldrb	r2, [r3, #0]
 8016446:	2101      	movs	r1, #1
 8016448:	438a      	bics	r2, r1
 801644a:	701a      	strb	r2, [r3, #0]
 801644c:	183b      	adds	r3, r7, r0
 801644e:	781a      	ldrb	r2, [r3, #0]
 8016450:	2102      	movs	r1, #2
 8016452:	438a      	bics	r2, r1
 8016454:	701a      	strb	r2, [r3, #0]
 8016456:	e00f      	b.n	8016478 <ipcp_nakci+0x3b8>
 8016458:	0000121c 	.word	0x0000121c
 801645c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801645e:	781b      	ldrb	r3, [r3, #0]
 8016460:	2240      	movs	r2, #64	; 0x40
 8016462:	4013      	ands	r3, r2
 8016464:	b2db      	uxtb	r3, r3
 8016466:	2b00      	cmp	r3, #0
 8016468:	d006      	beq.n	8016478 <ipcp_nakci+0x3b8>
 801646a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801646c:	2b00      	cmp	r3, #0
 801646e:	d003      	beq.n	8016478 <ipcp_nakci+0x3b8>
 8016470:	2310      	movs	r3, #16
 8016472:	18fb      	adds	r3, r7, r3
 8016474:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8016476:	605a      	str	r2, [r3, #4]
		  try_.ouraddr = ciaddr1;
	      }
	      );

#if LWIP_DNS
    NAKCIDNS(CI_MS_DNS1, req_dns1,
 8016478:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801647a:	785b      	ldrb	r3, [r3, #1]
 801647c:	2201      	movs	r2, #1
 801647e:	4013      	ands	r3, r2
 8016480:	b2db      	uxtb	r3, r3
 8016482:	2b00      	cmp	r3, #0
 8016484:	d057      	beq.n	8016536 <ipcp_nakci+0x476>
 8016486:	215f      	movs	r1, #95	; 0x5f
 8016488:	187b      	adds	r3, r7, r1
 801648a:	68ba      	ldr	r2, [r7, #8]
 801648c:	7852      	ldrb	r2, [r2, #1]
 801648e:	701a      	strb	r2, [r3, #0]
 8016490:	187b      	adds	r3, r7, r1
 8016492:	781b      	ldrb	r3, [r3, #0]
 8016494:	2b06      	cmp	r3, #6
 8016496:	d14e      	bne.n	8016536 <ipcp_nakci+0x476>
 8016498:	187b      	adds	r3, r7, r1
 801649a:	781b      	ldrb	r3, [r3, #0]
 801649c:	687a      	ldr	r2, [r7, #4]
 801649e:	429a      	cmp	r2, r3
 80164a0:	db49      	blt.n	8016536 <ipcp_nakci+0x476>
 80164a2:	68bb      	ldr	r3, [r7, #8]
 80164a4:	781b      	ldrb	r3, [r3, #0]
 80164a6:	2b81      	cmp	r3, #129	; 0x81
 80164a8:	d145      	bne.n	8016536 <ipcp_nakci+0x476>
 80164aa:	187b      	adds	r3, r7, r1
 80164ac:	781b      	ldrb	r3, [r3, #0]
 80164ae:	687a      	ldr	r2, [r7, #4]
 80164b0:	1ad3      	subs	r3, r2, r3
 80164b2:	607b      	str	r3, [r7, #4]
 80164b4:	68bb      	ldr	r3, [r7, #8]
 80164b6:	3302      	adds	r3, #2
 80164b8:	60bb      	str	r3, [r7, #8]
 80164ba:	68bb      	ldr	r3, [r7, #8]
 80164bc:	1c5a      	adds	r2, r3, #1
 80164be:	60ba      	str	r2, [r7, #8]
 80164c0:	781b      	ldrb	r3, [r3, #0]
 80164c2:	021b      	lsls	r3, r3, #8
 80164c4:	65bb      	str	r3, [r7, #88]	; 0x58
 80164c6:	68bb      	ldr	r3, [r7, #8]
 80164c8:	1c5a      	adds	r2, r3, #1
 80164ca:	60ba      	str	r2, [r7, #8]
 80164cc:	781b      	ldrb	r3, [r3, #0]
 80164ce:	001a      	movs	r2, r3
 80164d0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80164d2:	4313      	orrs	r3, r2
 80164d4:	65bb      	str	r3, [r7, #88]	; 0x58
 80164d6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80164d8:	021b      	lsls	r3, r3, #8
 80164da:	65bb      	str	r3, [r7, #88]	; 0x58
 80164dc:	68bb      	ldr	r3, [r7, #8]
 80164de:	1c5a      	adds	r2, r3, #1
 80164e0:	60ba      	str	r2, [r7, #8]
 80164e2:	781b      	ldrb	r3, [r3, #0]
 80164e4:	001a      	movs	r2, r3
 80164e6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80164e8:	4313      	orrs	r3, r2
 80164ea:	65bb      	str	r3, [r7, #88]	; 0x58
 80164ec:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80164ee:	021b      	lsls	r3, r3, #8
 80164f0:	65bb      	str	r3, [r7, #88]	; 0x58
 80164f2:	68bb      	ldr	r3, [r7, #8]
 80164f4:	1c5a      	adds	r2, r3, #1
 80164f6:	60ba      	str	r2, [r7, #8]
 80164f8:	781b      	ldrb	r3, [r3, #0]
 80164fa:	001a      	movs	r2, r3
 80164fc:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80164fe:	4313      	orrs	r3, r2
 8016500:	65bb      	str	r3, [r7, #88]	; 0x58
 8016502:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016504:	0018      	movs	r0, r3
 8016506:	f7f0 fd0b 	bl	8006f20 <lwip_htonl>
 801650a:	0003      	movs	r3, r0
 801650c:	64bb      	str	r3, [r7, #72]	; 0x48
 801650e:	2328      	movs	r3, #40	; 0x28
 8016510:	18fb      	adds	r3, r7, r3
 8016512:	785a      	ldrb	r2, [r3, #1]
 8016514:	2101      	movs	r1, #1
 8016516:	430a      	orrs	r2, r1
 8016518:	705a      	strb	r2, [r3, #1]
 801651a:	683b      	ldr	r3, [r7, #0]
 801651c:	2b00      	cmp	r3, #0
 801651e:	d006      	beq.n	801652e <ipcp_nakci+0x46e>
 8016520:	2310      	movs	r3, #16
 8016522:	18fb      	adds	r3, r7, r3
 8016524:	785a      	ldrb	r2, [r3, #1]
 8016526:	2101      	movs	r1, #1
 8016528:	438a      	bics	r2, r1
 801652a:	705a      	strb	r2, [r3, #1]
 801652c:	e003      	b.n	8016536 <ipcp_nakci+0x476>
 801652e:	2310      	movs	r3, #16
 8016530:	18fb      	adds	r3, r7, r3
 8016532:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8016534:	60da      	str	r2, [r3, #12]
	     } else {
		 try_.dnsaddr[0] = cidnsaddr;
	     }
	     );

    NAKCIDNS(CI_MS_DNS2, req_dns2,
 8016536:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016538:	785b      	ldrb	r3, [r3, #1]
 801653a:	2202      	movs	r2, #2
 801653c:	4013      	ands	r3, r2
 801653e:	b2db      	uxtb	r3, r3
 8016540:	2b00      	cmp	r3, #0
 8016542:	d100      	bne.n	8016546 <ipcp_nakci+0x486>
 8016544:	e24f      	b.n	80169e6 <ipcp_nakci+0x926>
 8016546:	215f      	movs	r1, #95	; 0x5f
 8016548:	187b      	adds	r3, r7, r1
 801654a:	68ba      	ldr	r2, [r7, #8]
 801654c:	7852      	ldrb	r2, [r2, #1]
 801654e:	701a      	strb	r2, [r3, #0]
 8016550:	187b      	adds	r3, r7, r1
 8016552:	781b      	ldrb	r3, [r3, #0]
 8016554:	2b06      	cmp	r3, #6
 8016556:	d000      	beq.n	801655a <ipcp_nakci+0x49a>
 8016558:	e245      	b.n	80169e6 <ipcp_nakci+0x926>
 801655a:	187b      	adds	r3, r7, r1
 801655c:	781b      	ldrb	r3, [r3, #0]
 801655e:	687a      	ldr	r2, [r7, #4]
 8016560:	429a      	cmp	r2, r3
 8016562:	da00      	bge.n	8016566 <ipcp_nakci+0x4a6>
 8016564:	e23f      	b.n	80169e6 <ipcp_nakci+0x926>
 8016566:	68bb      	ldr	r3, [r7, #8]
 8016568:	781b      	ldrb	r3, [r3, #0]
 801656a:	2b83      	cmp	r3, #131	; 0x83
 801656c:	d000      	beq.n	8016570 <ipcp_nakci+0x4b0>
 801656e:	e23a      	b.n	80169e6 <ipcp_nakci+0x926>
 8016570:	187b      	adds	r3, r7, r1
 8016572:	781b      	ldrb	r3, [r3, #0]
 8016574:	687a      	ldr	r2, [r7, #4]
 8016576:	1ad3      	subs	r3, r2, r3
 8016578:	607b      	str	r3, [r7, #4]
 801657a:	68bb      	ldr	r3, [r7, #8]
 801657c:	3302      	adds	r3, #2
 801657e:	60bb      	str	r3, [r7, #8]
 8016580:	68bb      	ldr	r3, [r7, #8]
 8016582:	1c5a      	adds	r2, r3, #1
 8016584:	60ba      	str	r2, [r7, #8]
 8016586:	781b      	ldrb	r3, [r3, #0]
 8016588:	021b      	lsls	r3, r3, #8
 801658a:	65bb      	str	r3, [r7, #88]	; 0x58
 801658c:	68bb      	ldr	r3, [r7, #8]
 801658e:	1c5a      	adds	r2, r3, #1
 8016590:	60ba      	str	r2, [r7, #8]
 8016592:	781b      	ldrb	r3, [r3, #0]
 8016594:	001a      	movs	r2, r3
 8016596:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016598:	4313      	orrs	r3, r2
 801659a:	65bb      	str	r3, [r7, #88]	; 0x58
 801659c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801659e:	021b      	lsls	r3, r3, #8
 80165a0:	65bb      	str	r3, [r7, #88]	; 0x58
 80165a2:	68bb      	ldr	r3, [r7, #8]
 80165a4:	1c5a      	adds	r2, r3, #1
 80165a6:	60ba      	str	r2, [r7, #8]
 80165a8:	781b      	ldrb	r3, [r3, #0]
 80165aa:	001a      	movs	r2, r3
 80165ac:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80165ae:	4313      	orrs	r3, r2
 80165b0:	65bb      	str	r3, [r7, #88]	; 0x58
 80165b2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80165b4:	021b      	lsls	r3, r3, #8
 80165b6:	65bb      	str	r3, [r7, #88]	; 0x58
 80165b8:	68bb      	ldr	r3, [r7, #8]
 80165ba:	1c5a      	adds	r2, r3, #1
 80165bc:	60ba      	str	r2, [r7, #8]
 80165be:	781b      	ldrb	r3, [r3, #0]
 80165c0:	001a      	movs	r2, r3
 80165c2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80165c4:	4313      	orrs	r3, r2
 80165c6:	65bb      	str	r3, [r7, #88]	; 0x58
 80165c8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80165ca:	0018      	movs	r0, r3
 80165cc:	f7f0 fca8 	bl	8006f20 <lwip_htonl>
 80165d0:	0003      	movs	r3, r0
 80165d2:	64bb      	str	r3, [r7, #72]	; 0x48
 80165d4:	2328      	movs	r3, #40	; 0x28
 80165d6:	18fb      	adds	r3, r7, r3
 80165d8:	785a      	ldrb	r2, [r3, #1]
 80165da:	2102      	movs	r1, #2
 80165dc:	430a      	orrs	r2, r1
 80165de:	705a      	strb	r2, [r3, #1]
 80165e0:	683b      	ldr	r3, [r7, #0]
 80165e2:	2b00      	cmp	r3, #0
 80165e4:	d006      	beq.n	80165f4 <ipcp_nakci+0x534>
 80165e6:	2310      	movs	r3, #16
 80165e8:	18fb      	adds	r3, r7, r3
 80165ea:	785a      	ldrb	r2, [r3, #1]
 80165ec:	2102      	movs	r1, #2
 80165ee:	438a      	bics	r2, r1
 80165f0:	705a      	strb	r2, [r3, #1]
 80165f2:	e1f8      	b.n	80169e6 <ipcp_nakci+0x926>
 80165f4:	2310      	movs	r3, #16
 80165f6:	18fb      	adds	r3, r7, r3
 80165f8:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80165fa:	611a      	str	r2, [r3, #16]
     * If they want to negotiate about IP addresses, we comply.
     * If they want us to ask for compression, we refuse.
     * If they want us to ask for ms-dns, we do that, since some
     * peers get huffy if we don't.
     */
    while (len >= CILEN_VOID) {
 80165fc:	e1f3      	b.n	80169e6 <ipcp_nakci+0x926>
	GETCHAR(citype, p);
 80165fe:	68bb      	ldr	r3, [r7, #8]
 8016600:	1c5a      	adds	r2, r3, #1
 8016602:	60ba      	str	r2, [r7, #8]
 8016604:	2047      	movs	r0, #71	; 0x47
 8016606:	183a      	adds	r2, r7, r0
 8016608:	781b      	ldrb	r3, [r3, #0]
 801660a:	7013      	strb	r3, [r2, #0]
	GETCHAR(cilen, p);
 801660c:	68bb      	ldr	r3, [r7, #8]
 801660e:	1c5a      	adds	r2, r3, #1
 8016610:	60ba      	str	r2, [r7, #8]
 8016612:	215f      	movs	r1, #95	; 0x5f
 8016614:	187a      	adds	r2, r7, r1
 8016616:	781b      	ldrb	r3, [r3, #0]
 8016618:	7013      	strb	r3, [r2, #0]
	if ( cilen < CILEN_VOID || (len -= cilen) < 0 )
 801661a:	187b      	adds	r3, r7, r1
 801661c:	781b      	ldrb	r3, [r3, #0]
 801661e:	2b01      	cmp	r3, #1
 8016620:	d800      	bhi.n	8016624 <ipcp_nakci+0x564>
 8016622:	e1f1      	b.n	8016a08 <ipcp_nakci+0x948>
 8016624:	187b      	adds	r3, r7, r1
 8016626:	781b      	ldrb	r3, [r3, #0]
 8016628:	687a      	ldr	r2, [r7, #4]
 801662a:	1ad3      	subs	r3, r2, r3
 801662c:	607b      	str	r3, [r7, #4]
 801662e:	687b      	ldr	r3, [r7, #4]
 8016630:	2b00      	cmp	r3, #0
 8016632:	da00      	bge.n	8016636 <ipcp_nakci+0x576>
 8016634:	e1e8      	b.n	8016a08 <ipcp_nakci+0x948>
	    goto bad;
	next = p + cilen - 2;
 8016636:	187b      	adds	r3, r7, r1
 8016638:	781b      	ldrb	r3, [r3, #0]
 801663a:	3b02      	subs	r3, #2
 801663c:	68ba      	ldr	r2, [r7, #8]
 801663e:	18d3      	adds	r3, r2, r3
 8016640:	643b      	str	r3, [r7, #64]	; 0x40

	switch (citype) {
 8016642:	183b      	adds	r3, r7, r0
 8016644:	781b      	ldrb	r3, [r3, #0]
 8016646:	2b83      	cmp	r3, #131	; 0x83
 8016648:	d100      	bne.n	801664c <ipcp_nakci+0x58c>
 801664a:	e17e      	b.n	801694a <ipcp_nakci+0x88a>
 801664c:	dd00      	ble.n	8016650 <ipcp_nakci+0x590>
 801664e:	e1c7      	b.n	80169e0 <ipcp_nakci+0x920>
 8016650:	2b81      	cmp	r3, #129	; 0x81
 8016652:	d100      	bne.n	8016656 <ipcp_nakci+0x596>
 8016654:	e12b      	b.n	80168ae <ipcp_nakci+0x7ee>
 8016656:	dd00      	ble.n	801665a <ipcp_nakci+0x59a>
 8016658:	e1c2      	b.n	80169e0 <ipcp_nakci+0x920>
 801665a:	2b03      	cmp	r3, #3
 801665c:	d100      	bne.n	8016660 <ipcp_nakci+0x5a0>
 801665e:	e0c1      	b.n	80167e4 <ipcp_nakci+0x724>
 8016660:	dd00      	ble.n	8016664 <ipcp_nakci+0x5a4>
 8016662:	e1bd      	b.n	80169e0 <ipcp_nakci+0x920>
 8016664:	2b01      	cmp	r3, #1
 8016666:	d023      	beq.n	80166b0 <ipcp_nakci+0x5f0>
 8016668:	2b02      	cmp	r3, #2
 801666a:	d000      	beq.n	801666e <ipcp_nakci+0x5ae>
 801666c:	e1b8      	b.n	80169e0 <ipcp_nakci+0x920>
#if VJ_SUPPORT
	case CI_COMPRESSTYPE:
	    if (go->neg_vj || no.neg_vj ||
 801666e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016670:	781b      	ldrb	r3, [r3, #0]
 8016672:	2208      	movs	r2, #8
 8016674:	4013      	ands	r3, r2
 8016676:	b2db      	uxtb	r3, r3
 8016678:	2b00      	cmp	r3, #0
 801667a:	d000      	beq.n	801667e <ipcp_nakci+0x5be>
 801667c:	e1c6      	b.n	8016a0c <ipcp_nakci+0x94c>
 801667e:	2328      	movs	r3, #40	; 0x28
 8016680:	18fb      	adds	r3, r7, r3
 8016682:	781b      	ldrb	r3, [r3, #0]
 8016684:	2208      	movs	r2, #8
 8016686:	4013      	ands	r3, r2
 8016688:	b2db      	uxtb	r3, r3
 801668a:	2b00      	cmp	r3, #0
 801668c:	d000      	beq.n	8016690 <ipcp_nakci+0x5d0>
 801668e:	e1bd      	b.n	8016a0c <ipcp_nakci+0x94c>
 8016690:	187b      	adds	r3, r7, r1
 8016692:	781b      	ldrb	r3, [r3, #0]
 8016694:	2b06      	cmp	r3, #6
 8016696:	d004      	beq.n	80166a2 <ipcp_nakci+0x5e2>
		(cilen != CILEN_VJ && cilen != CILEN_COMPRESS))
 8016698:	187b      	adds	r3, r7, r1
 801669a:	781b      	ldrb	r3, [r3, #0]
 801669c:	2b04      	cmp	r3, #4
 801669e:	d000      	beq.n	80166a2 <ipcp_nakci+0x5e2>
 80166a0:	e1b4      	b.n	8016a0c <ipcp_nakci+0x94c>
		goto bad;
	    no.neg_vj = 1;
 80166a2:	2328      	movs	r3, #40	; 0x28
 80166a4:	18fb      	adds	r3, r7, r3
 80166a6:	781a      	ldrb	r2, [r3, #0]
 80166a8:	2108      	movs	r1, #8
 80166aa:	430a      	orrs	r2, r1
 80166ac:	701a      	strb	r2, [r3, #0]
	    break;
 80166ae:	e198      	b.n	80169e2 <ipcp_nakci+0x922>
#endif /* VJ_SUPPORT */
	case CI_ADDRS:
	    if ((!go->neg_addr && go->old_addrs) || no.old_addrs
 80166b0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80166b2:	781b      	ldrb	r3, [r3, #0]
 80166b4:	2201      	movs	r2, #1
 80166b6:	4013      	ands	r3, r2
 80166b8:	b2db      	uxtb	r3, r3
 80166ba:	2b00      	cmp	r3, #0
 80166bc:	d107      	bne.n	80166ce <ipcp_nakci+0x60e>
 80166be:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80166c0:	781b      	ldrb	r3, [r3, #0]
 80166c2:	2202      	movs	r2, #2
 80166c4:	4013      	ands	r3, r2
 80166c6:	b2db      	uxtb	r3, r3
 80166c8:	2b00      	cmp	r3, #0
 80166ca:	d000      	beq.n	80166ce <ipcp_nakci+0x60e>
 80166cc:	e1a0      	b.n	8016a10 <ipcp_nakci+0x950>
 80166ce:	2328      	movs	r3, #40	; 0x28
 80166d0:	18fb      	adds	r3, r7, r3
 80166d2:	781b      	ldrb	r3, [r3, #0]
 80166d4:	2202      	movs	r2, #2
 80166d6:	4013      	ands	r3, r2
 80166d8:	b2db      	uxtb	r3, r3
 80166da:	2b00      	cmp	r3, #0
 80166dc:	d000      	beq.n	80166e0 <ipcp_nakci+0x620>
 80166de:	e197      	b.n	8016a10 <ipcp_nakci+0x950>
		|| cilen != CILEN_ADDRS)
 80166e0:	235f      	movs	r3, #95	; 0x5f
 80166e2:	18fb      	adds	r3, r7, r3
 80166e4:	781b      	ldrb	r3, [r3, #0]
 80166e6:	2b0a      	cmp	r3, #10
 80166e8:	d000      	beq.n	80166ec <ipcp_nakci+0x62c>
 80166ea:	e191      	b.n	8016a10 <ipcp_nakci+0x950>
		goto bad;
	    try_.neg_addr = 0;
 80166ec:	2410      	movs	r4, #16
 80166ee:	193b      	adds	r3, r7, r4
 80166f0:	781a      	ldrb	r2, [r3, #0]
 80166f2:	2101      	movs	r1, #1
 80166f4:	438a      	bics	r2, r1
 80166f6:	701a      	strb	r2, [r3, #0]
	    GETLONG(l, p);
 80166f8:	68bb      	ldr	r3, [r7, #8]
 80166fa:	1c5a      	adds	r2, r3, #1
 80166fc:	60ba      	str	r2, [r7, #8]
 80166fe:	781b      	ldrb	r3, [r3, #0]
 8016700:	021b      	lsls	r3, r3, #8
 8016702:	65bb      	str	r3, [r7, #88]	; 0x58
 8016704:	68bb      	ldr	r3, [r7, #8]
 8016706:	1c5a      	adds	r2, r3, #1
 8016708:	60ba      	str	r2, [r7, #8]
 801670a:	781b      	ldrb	r3, [r3, #0]
 801670c:	001a      	movs	r2, r3
 801670e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016710:	4313      	orrs	r3, r2
 8016712:	65bb      	str	r3, [r7, #88]	; 0x58
 8016714:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016716:	021b      	lsls	r3, r3, #8
 8016718:	65bb      	str	r3, [r7, #88]	; 0x58
 801671a:	68bb      	ldr	r3, [r7, #8]
 801671c:	1c5a      	adds	r2, r3, #1
 801671e:	60ba      	str	r2, [r7, #8]
 8016720:	781b      	ldrb	r3, [r3, #0]
 8016722:	001a      	movs	r2, r3
 8016724:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016726:	4313      	orrs	r3, r2
 8016728:	65bb      	str	r3, [r7, #88]	; 0x58
 801672a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801672c:	021b      	lsls	r3, r3, #8
 801672e:	65bb      	str	r3, [r7, #88]	; 0x58
 8016730:	68bb      	ldr	r3, [r7, #8]
 8016732:	1c5a      	adds	r2, r3, #1
 8016734:	60ba      	str	r2, [r7, #8]
 8016736:	781b      	ldrb	r3, [r3, #0]
 8016738:	001a      	movs	r2, r3
 801673a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801673c:	4313      	orrs	r3, r2
 801673e:	65bb      	str	r3, [r7, #88]	; 0x58
	    ciaddr1 = lwip_htonl(l);
 8016740:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016742:	0018      	movs	r0, r3
 8016744:	f7f0 fbec 	bl	8006f20 <lwip_htonl>
 8016748:	0003      	movs	r3, r0
 801674a:	657b      	str	r3, [r7, #84]	; 0x54
	    if (ciaddr1 && go->accept_local)
 801674c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801674e:	2b00      	cmp	r3, #0
 8016750:	d009      	beq.n	8016766 <ipcp_nakci+0x6a6>
 8016752:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016754:	781b      	ldrb	r3, [r3, #0]
 8016756:	2240      	movs	r2, #64	; 0x40
 8016758:	4013      	ands	r3, r2
 801675a:	b2db      	uxtb	r3, r3
 801675c:	2b00      	cmp	r3, #0
 801675e:	d002      	beq.n	8016766 <ipcp_nakci+0x6a6>
		try_.ouraddr = ciaddr1;
 8016760:	193b      	adds	r3, r7, r4
 8016762:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8016764:	605a      	str	r2, [r3, #4]
	    GETLONG(l, p);
 8016766:	68bb      	ldr	r3, [r7, #8]
 8016768:	1c5a      	adds	r2, r3, #1
 801676a:	60ba      	str	r2, [r7, #8]
 801676c:	781b      	ldrb	r3, [r3, #0]
 801676e:	021b      	lsls	r3, r3, #8
 8016770:	65bb      	str	r3, [r7, #88]	; 0x58
 8016772:	68bb      	ldr	r3, [r7, #8]
 8016774:	1c5a      	adds	r2, r3, #1
 8016776:	60ba      	str	r2, [r7, #8]
 8016778:	781b      	ldrb	r3, [r3, #0]
 801677a:	001a      	movs	r2, r3
 801677c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801677e:	4313      	orrs	r3, r2
 8016780:	65bb      	str	r3, [r7, #88]	; 0x58
 8016782:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016784:	021b      	lsls	r3, r3, #8
 8016786:	65bb      	str	r3, [r7, #88]	; 0x58
 8016788:	68bb      	ldr	r3, [r7, #8]
 801678a:	1c5a      	adds	r2, r3, #1
 801678c:	60ba      	str	r2, [r7, #8]
 801678e:	781b      	ldrb	r3, [r3, #0]
 8016790:	001a      	movs	r2, r3
 8016792:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016794:	4313      	orrs	r3, r2
 8016796:	65bb      	str	r3, [r7, #88]	; 0x58
 8016798:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801679a:	021b      	lsls	r3, r3, #8
 801679c:	65bb      	str	r3, [r7, #88]	; 0x58
 801679e:	68bb      	ldr	r3, [r7, #8]
 80167a0:	1c5a      	adds	r2, r3, #1
 80167a2:	60ba      	str	r2, [r7, #8]
 80167a4:	781b      	ldrb	r3, [r3, #0]
 80167a6:	001a      	movs	r2, r3
 80167a8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80167aa:	4313      	orrs	r3, r2
 80167ac:	65bb      	str	r3, [r7, #88]	; 0x58
	    ciaddr2 = lwip_htonl(l);
 80167ae:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80167b0:	0018      	movs	r0, r3
 80167b2:	f7f0 fbb5 	bl	8006f20 <lwip_htonl>
 80167b6:	0003      	movs	r3, r0
 80167b8:	653b      	str	r3, [r7, #80]	; 0x50
	    if (ciaddr2 && go->accept_remote)
 80167ba:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80167bc:	2b00      	cmp	r3, #0
 80167be:	d00a      	beq.n	80167d6 <ipcp_nakci+0x716>
 80167c0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80167c2:	781b      	ldrb	r3, [r3, #0]
 80167c4:	227f      	movs	r2, #127	; 0x7f
 80167c6:	4393      	bics	r3, r2
 80167c8:	b2db      	uxtb	r3, r3
 80167ca:	2b00      	cmp	r3, #0
 80167cc:	d003      	beq.n	80167d6 <ipcp_nakci+0x716>
		try_.hisaddr = ciaddr2;
 80167ce:	2310      	movs	r3, #16
 80167d0:	18fb      	adds	r3, r7, r3
 80167d2:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80167d4:	609a      	str	r2, [r3, #8]
	    no.old_addrs = 1;
 80167d6:	2328      	movs	r3, #40	; 0x28
 80167d8:	18fb      	adds	r3, r7, r3
 80167da:	781a      	ldrb	r2, [r3, #0]
 80167dc:	2102      	movs	r1, #2
 80167de:	430a      	orrs	r2, r1
 80167e0:	701a      	strb	r2, [r3, #0]
	    break;
 80167e2:	e0fe      	b.n	80169e2 <ipcp_nakci+0x922>
	case CI_ADDR:
	    if (go->neg_addr || no.neg_addr || cilen != CILEN_ADDR)
 80167e4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80167e6:	781b      	ldrb	r3, [r3, #0]
 80167e8:	2201      	movs	r2, #1
 80167ea:	4013      	ands	r3, r2
 80167ec:	b2db      	uxtb	r3, r3
 80167ee:	2b00      	cmp	r3, #0
 80167f0:	d000      	beq.n	80167f4 <ipcp_nakci+0x734>
 80167f2:	e10f      	b.n	8016a14 <ipcp_nakci+0x954>
 80167f4:	2328      	movs	r3, #40	; 0x28
 80167f6:	18fb      	adds	r3, r7, r3
 80167f8:	781b      	ldrb	r3, [r3, #0]
 80167fa:	2201      	movs	r2, #1
 80167fc:	4013      	ands	r3, r2
 80167fe:	b2db      	uxtb	r3, r3
 8016800:	2b00      	cmp	r3, #0
 8016802:	d000      	beq.n	8016806 <ipcp_nakci+0x746>
 8016804:	e106      	b.n	8016a14 <ipcp_nakci+0x954>
 8016806:	235f      	movs	r3, #95	; 0x5f
 8016808:	18fb      	adds	r3, r7, r3
 801680a:	781b      	ldrb	r3, [r3, #0]
 801680c:	2b06      	cmp	r3, #6
 801680e:	d000      	beq.n	8016812 <ipcp_nakci+0x752>
 8016810:	e100      	b.n	8016a14 <ipcp_nakci+0x954>
		goto bad;
	    try_.old_addrs = 0;
 8016812:	2410      	movs	r4, #16
 8016814:	193b      	adds	r3, r7, r4
 8016816:	781a      	ldrb	r2, [r3, #0]
 8016818:	2102      	movs	r1, #2
 801681a:	438a      	bics	r2, r1
 801681c:	701a      	strb	r2, [r3, #0]
	    GETLONG(l, p);
 801681e:	68bb      	ldr	r3, [r7, #8]
 8016820:	1c5a      	adds	r2, r3, #1
 8016822:	60ba      	str	r2, [r7, #8]
 8016824:	781b      	ldrb	r3, [r3, #0]
 8016826:	021b      	lsls	r3, r3, #8
 8016828:	65bb      	str	r3, [r7, #88]	; 0x58
 801682a:	68bb      	ldr	r3, [r7, #8]
 801682c:	1c5a      	adds	r2, r3, #1
 801682e:	60ba      	str	r2, [r7, #8]
 8016830:	781b      	ldrb	r3, [r3, #0]
 8016832:	001a      	movs	r2, r3
 8016834:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016836:	4313      	orrs	r3, r2
 8016838:	65bb      	str	r3, [r7, #88]	; 0x58
 801683a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801683c:	021b      	lsls	r3, r3, #8
 801683e:	65bb      	str	r3, [r7, #88]	; 0x58
 8016840:	68bb      	ldr	r3, [r7, #8]
 8016842:	1c5a      	adds	r2, r3, #1
 8016844:	60ba      	str	r2, [r7, #8]
 8016846:	781b      	ldrb	r3, [r3, #0]
 8016848:	001a      	movs	r2, r3
 801684a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801684c:	4313      	orrs	r3, r2
 801684e:	65bb      	str	r3, [r7, #88]	; 0x58
 8016850:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016852:	021b      	lsls	r3, r3, #8
 8016854:	65bb      	str	r3, [r7, #88]	; 0x58
 8016856:	68bb      	ldr	r3, [r7, #8]
 8016858:	1c5a      	adds	r2, r3, #1
 801685a:	60ba      	str	r2, [r7, #8]
 801685c:	781b      	ldrb	r3, [r3, #0]
 801685e:	001a      	movs	r2, r3
 8016860:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016862:	4313      	orrs	r3, r2
 8016864:	65bb      	str	r3, [r7, #88]	; 0x58
	    ciaddr1 = lwip_htonl(l);
 8016866:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016868:	0018      	movs	r0, r3
 801686a:	f7f0 fb59 	bl	8006f20 <lwip_htonl>
 801686e:	0003      	movs	r3, r0
 8016870:	657b      	str	r3, [r7, #84]	; 0x54
	    if (ciaddr1 && go->accept_local)
 8016872:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016874:	2b00      	cmp	r3, #0
 8016876:	d009      	beq.n	801688c <ipcp_nakci+0x7cc>
 8016878:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801687a:	781b      	ldrb	r3, [r3, #0]
 801687c:	2240      	movs	r2, #64	; 0x40
 801687e:	4013      	ands	r3, r2
 8016880:	b2db      	uxtb	r3, r3
 8016882:	2b00      	cmp	r3, #0
 8016884:	d002      	beq.n	801688c <ipcp_nakci+0x7cc>
		try_.ouraddr = ciaddr1;
 8016886:	193b      	adds	r3, r7, r4
 8016888:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801688a:	605a      	str	r2, [r3, #4]
	    if (try_.ouraddr != 0)
 801688c:	2210      	movs	r2, #16
 801688e:	18bb      	adds	r3, r7, r2
 8016890:	685b      	ldr	r3, [r3, #4]
 8016892:	2b00      	cmp	r3, #0
 8016894:	d004      	beq.n	80168a0 <ipcp_nakci+0x7e0>
		try_.neg_addr = 1;
 8016896:	18bb      	adds	r3, r7, r2
 8016898:	781a      	ldrb	r2, [r3, #0]
 801689a:	2101      	movs	r1, #1
 801689c:	430a      	orrs	r2, r1
 801689e:	701a      	strb	r2, [r3, #0]
	    no.neg_addr = 1;
 80168a0:	2328      	movs	r3, #40	; 0x28
 80168a2:	18fb      	adds	r3, r7, r3
 80168a4:	781a      	ldrb	r2, [r3, #0]
 80168a6:	2101      	movs	r1, #1
 80168a8:	430a      	orrs	r2, r1
 80168aa:	701a      	strb	r2, [r3, #0]
	    break;
 80168ac:	e099      	b.n	80169e2 <ipcp_nakci+0x922>
#if LWIP_DNS
	case CI_MS_DNS1:
	    if (go->req_dns1 || no.req_dns1 || cilen != CILEN_ADDR)
 80168ae:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80168b0:	785b      	ldrb	r3, [r3, #1]
 80168b2:	2201      	movs	r2, #1
 80168b4:	4013      	ands	r3, r2
 80168b6:	b2db      	uxtb	r3, r3
 80168b8:	2b00      	cmp	r3, #0
 80168ba:	d000      	beq.n	80168be <ipcp_nakci+0x7fe>
 80168bc:	e0ac      	b.n	8016a18 <ipcp_nakci+0x958>
 80168be:	2428      	movs	r4, #40	; 0x28
 80168c0:	193b      	adds	r3, r7, r4
 80168c2:	785b      	ldrb	r3, [r3, #1]
 80168c4:	2201      	movs	r2, #1
 80168c6:	4013      	ands	r3, r2
 80168c8:	b2db      	uxtb	r3, r3
 80168ca:	2b00      	cmp	r3, #0
 80168cc:	d000      	beq.n	80168d0 <ipcp_nakci+0x810>
 80168ce:	e0a3      	b.n	8016a18 <ipcp_nakci+0x958>
 80168d0:	235f      	movs	r3, #95	; 0x5f
 80168d2:	18fb      	adds	r3, r7, r3
 80168d4:	781b      	ldrb	r3, [r3, #0]
 80168d6:	2b06      	cmp	r3, #6
 80168d8:	d000      	beq.n	80168dc <ipcp_nakci+0x81c>
 80168da:	e09d      	b.n	8016a18 <ipcp_nakci+0x958>
		goto bad;
	    GETLONG(l, p);
 80168dc:	68bb      	ldr	r3, [r7, #8]
 80168de:	1c5a      	adds	r2, r3, #1
 80168e0:	60ba      	str	r2, [r7, #8]
 80168e2:	781b      	ldrb	r3, [r3, #0]
 80168e4:	021b      	lsls	r3, r3, #8
 80168e6:	65bb      	str	r3, [r7, #88]	; 0x58
 80168e8:	68bb      	ldr	r3, [r7, #8]
 80168ea:	1c5a      	adds	r2, r3, #1
 80168ec:	60ba      	str	r2, [r7, #8]
 80168ee:	781b      	ldrb	r3, [r3, #0]
 80168f0:	001a      	movs	r2, r3
 80168f2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80168f4:	4313      	orrs	r3, r2
 80168f6:	65bb      	str	r3, [r7, #88]	; 0x58
 80168f8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80168fa:	021b      	lsls	r3, r3, #8
 80168fc:	65bb      	str	r3, [r7, #88]	; 0x58
 80168fe:	68bb      	ldr	r3, [r7, #8]
 8016900:	1c5a      	adds	r2, r3, #1
 8016902:	60ba      	str	r2, [r7, #8]
 8016904:	781b      	ldrb	r3, [r3, #0]
 8016906:	001a      	movs	r2, r3
 8016908:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801690a:	4313      	orrs	r3, r2
 801690c:	65bb      	str	r3, [r7, #88]	; 0x58
 801690e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016910:	021b      	lsls	r3, r3, #8
 8016912:	65bb      	str	r3, [r7, #88]	; 0x58
 8016914:	68bb      	ldr	r3, [r7, #8]
 8016916:	1c5a      	adds	r2, r3, #1
 8016918:	60ba      	str	r2, [r7, #8]
 801691a:	781b      	ldrb	r3, [r3, #0]
 801691c:	001a      	movs	r2, r3
 801691e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016920:	4313      	orrs	r3, r2
 8016922:	65bb      	str	r3, [r7, #88]	; 0x58
	    try_.dnsaddr[0] = lwip_htonl(l);
 8016924:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016926:	0018      	movs	r0, r3
 8016928:	f7f0 fafa 	bl	8006f20 <lwip_htonl>
 801692c:	0002      	movs	r2, r0
 801692e:	2110      	movs	r1, #16
 8016930:	187b      	adds	r3, r7, r1
 8016932:	60da      	str	r2, [r3, #12]
	    try_.req_dns1 = 1;
 8016934:	187b      	adds	r3, r7, r1
 8016936:	785a      	ldrb	r2, [r3, #1]
 8016938:	2101      	movs	r1, #1
 801693a:	430a      	orrs	r2, r1
 801693c:	705a      	strb	r2, [r3, #1]
	    no.req_dns1 = 1;
 801693e:	193b      	adds	r3, r7, r4
 8016940:	785a      	ldrb	r2, [r3, #1]
 8016942:	2101      	movs	r1, #1
 8016944:	430a      	orrs	r2, r1
 8016946:	705a      	strb	r2, [r3, #1]
	    break;
 8016948:	e04b      	b.n	80169e2 <ipcp_nakci+0x922>
	case CI_MS_DNS2:
	    if (go->req_dns2 || no.req_dns2 || cilen != CILEN_ADDR)
 801694a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801694c:	785b      	ldrb	r3, [r3, #1]
 801694e:	2202      	movs	r2, #2
 8016950:	4013      	ands	r3, r2
 8016952:	b2db      	uxtb	r3, r3
 8016954:	2b00      	cmp	r3, #0
 8016956:	d161      	bne.n	8016a1c <ipcp_nakci+0x95c>
 8016958:	2428      	movs	r4, #40	; 0x28
 801695a:	193b      	adds	r3, r7, r4
 801695c:	785b      	ldrb	r3, [r3, #1]
 801695e:	2202      	movs	r2, #2
 8016960:	4013      	ands	r3, r2
 8016962:	b2db      	uxtb	r3, r3
 8016964:	2b00      	cmp	r3, #0
 8016966:	d159      	bne.n	8016a1c <ipcp_nakci+0x95c>
 8016968:	235f      	movs	r3, #95	; 0x5f
 801696a:	18fb      	adds	r3, r7, r3
 801696c:	781b      	ldrb	r3, [r3, #0]
 801696e:	2b06      	cmp	r3, #6
 8016970:	d154      	bne.n	8016a1c <ipcp_nakci+0x95c>
		goto bad;
	    GETLONG(l, p);
 8016972:	68bb      	ldr	r3, [r7, #8]
 8016974:	1c5a      	adds	r2, r3, #1
 8016976:	60ba      	str	r2, [r7, #8]
 8016978:	781b      	ldrb	r3, [r3, #0]
 801697a:	021b      	lsls	r3, r3, #8
 801697c:	65bb      	str	r3, [r7, #88]	; 0x58
 801697e:	68bb      	ldr	r3, [r7, #8]
 8016980:	1c5a      	adds	r2, r3, #1
 8016982:	60ba      	str	r2, [r7, #8]
 8016984:	781b      	ldrb	r3, [r3, #0]
 8016986:	001a      	movs	r2, r3
 8016988:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801698a:	4313      	orrs	r3, r2
 801698c:	65bb      	str	r3, [r7, #88]	; 0x58
 801698e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016990:	021b      	lsls	r3, r3, #8
 8016992:	65bb      	str	r3, [r7, #88]	; 0x58
 8016994:	68bb      	ldr	r3, [r7, #8]
 8016996:	1c5a      	adds	r2, r3, #1
 8016998:	60ba      	str	r2, [r7, #8]
 801699a:	781b      	ldrb	r3, [r3, #0]
 801699c:	001a      	movs	r2, r3
 801699e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80169a0:	4313      	orrs	r3, r2
 80169a2:	65bb      	str	r3, [r7, #88]	; 0x58
 80169a4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80169a6:	021b      	lsls	r3, r3, #8
 80169a8:	65bb      	str	r3, [r7, #88]	; 0x58
 80169aa:	68bb      	ldr	r3, [r7, #8]
 80169ac:	1c5a      	adds	r2, r3, #1
 80169ae:	60ba      	str	r2, [r7, #8]
 80169b0:	781b      	ldrb	r3, [r3, #0]
 80169b2:	001a      	movs	r2, r3
 80169b4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80169b6:	4313      	orrs	r3, r2
 80169b8:	65bb      	str	r3, [r7, #88]	; 0x58
	    try_.dnsaddr[1] = lwip_htonl(l);
 80169ba:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80169bc:	0018      	movs	r0, r3
 80169be:	f7f0 faaf 	bl	8006f20 <lwip_htonl>
 80169c2:	0002      	movs	r2, r0
 80169c4:	2110      	movs	r1, #16
 80169c6:	187b      	adds	r3, r7, r1
 80169c8:	611a      	str	r2, [r3, #16]
	    try_.req_dns2 = 1;
 80169ca:	187b      	adds	r3, r7, r1
 80169cc:	785a      	ldrb	r2, [r3, #1]
 80169ce:	2102      	movs	r1, #2
 80169d0:	430a      	orrs	r2, r1
 80169d2:	705a      	strb	r2, [r3, #1]
	    no.req_dns2 = 1;
 80169d4:	193b      	adds	r3, r7, r4
 80169d6:	785a      	ldrb	r2, [r3, #1]
 80169d8:	2102      	movs	r1, #2
 80169da:	430a      	orrs	r2, r1
 80169dc:	705a      	strb	r2, [r3, #1]
	    break;
 80169de:	e000      	b.n	80169e2 <ipcp_nakci+0x922>
	    if (ciaddr1)
		try_.winsaddr[citype == CI_MS_WINS2] = ciaddr1;
	    break;
#endif /* UNUSED - WINS */
	default:
	    break;
 80169e0:	46c0      	nop			; (mov r8, r8)
	}
	p = next;
 80169e2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80169e4:	60bb      	str	r3, [r7, #8]
    while (len >= CILEN_VOID) {
 80169e6:	687b      	ldr	r3, [r7, #4]
 80169e8:	2b01      	cmp	r3, #1
 80169ea:	dd00      	ble.n	80169ee <ipcp_nakci+0x92e>
 80169ec:	e607      	b.n	80165fe <ipcp_nakci+0x53e>

    /*
     * OK, the Nak is good.  Now we can update state.
     * If there are any remaining options, we ignore them.
     */
    if (f->state != PPP_FSM_OPENED)
 80169ee:	68fb      	ldr	r3, [r7, #12]
 80169f0:	7c1b      	ldrb	r3, [r3, #16]
 80169f2:	2b09      	cmp	r3, #9
 80169f4:	d006      	beq.n	8016a04 <ipcp_nakci+0x944>
	*go = try_;
 80169f6:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80169f8:	2210      	movs	r2, #16
 80169fa:	18ba      	adds	r2, r7, r2
 80169fc:	ca13      	ldmia	r2!, {r0, r1, r4}
 80169fe:	c313      	stmia	r3!, {r0, r1, r4}
 8016a00:	ca13      	ldmia	r2!, {r0, r1, r4}
 8016a02:	c313      	stmia	r3!, {r0, r1, r4}

    return 1;
 8016a04:	2301      	movs	r3, #1
 8016a06:	e00b      	b.n	8016a20 <ipcp_nakci+0x960>
	    goto bad;
 8016a08:	46c0      	nop			; (mov r8, r8)
 8016a0a:	e008      	b.n	8016a1e <ipcp_nakci+0x95e>
		goto bad;
 8016a0c:	46c0      	nop			; (mov r8, r8)
 8016a0e:	e006      	b.n	8016a1e <ipcp_nakci+0x95e>
		goto bad;
 8016a10:	46c0      	nop			; (mov r8, r8)
 8016a12:	e004      	b.n	8016a1e <ipcp_nakci+0x95e>
		goto bad;
 8016a14:	46c0      	nop			; (mov r8, r8)
 8016a16:	e002      	b.n	8016a1e <ipcp_nakci+0x95e>
		goto bad;
 8016a18:	46c0      	nop			; (mov r8, r8)
 8016a1a:	e000      	b.n	8016a1e <ipcp_nakci+0x95e>
		goto bad;
 8016a1c:	46c0      	nop			; (mov r8, r8)

bad:
    IPCPDEBUG(("ipcp_nakci: received bad Nak!"));
    return 0;
 8016a1e:	2300      	movs	r3, #0
}
 8016a20:	0018      	movs	r0, r3
 8016a22:	46bd      	mov	sp, r7
 8016a24:	b01b      	add	sp, #108	; 0x6c
 8016a26:	bdf0      	pop	{r4, r5, r6, r7, pc}

08016a28 <ipcp_rejci>:

/*
 * ipcp_rejci - Reject some of our CIs.
 * Callback from fsm_rconfnakrej.
 */
static int ipcp_rejci(fsm *f, u_char *p, int len) {
 8016a28:	b5b0      	push	{r4, r5, r7, lr}
 8016a2a:	b094      	sub	sp, #80	; 0x50
 8016a2c:	af00      	add	r7, sp, #0
 8016a2e:	60f8      	str	r0, [r7, #12]
 8016a30:	60b9      	str	r1, [r7, #8]
 8016a32:	607a      	str	r2, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8016a34:	68fb      	ldr	r3, [r7, #12]
 8016a36:	681b      	ldr	r3, [r3, #0]
 8016a38:	64fb      	str	r3, [r7, #76]	; 0x4c
    ipcp_options *go = &pcb->ipcp_gotoptions;
 8016a3a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8016a3c:	4a57      	ldr	r2, [pc, #348]	; (8016b9c <ipcp_rejci+0x174>)
 8016a3e:	4694      	mov	ip, r2
 8016a40:	4463      	add	r3, ip
 8016a42:	64bb      	str	r3, [r7, #72]	; 0x48
    u_short cishort;
#endif /* VJ_SUPPORT */
    u32_t cilong;
    ipcp_options try_;		/* options to request next time */

    try_ = *go;
 8016a44:	2414      	movs	r4, #20
 8016a46:	193b      	adds	r3, r7, r4
 8016a48:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8016a4a:	ca23      	ldmia	r2!, {r0, r1, r5}
 8016a4c:	c323      	stmia	r3!, {r0, r1, r5}
 8016a4e:	ca23      	ldmia	r2!, {r0, r1, r5}
 8016a50:	c323      	stmia	r3!, {r0, r1, r5}
	    goto bad; \
	try_.winsaddr[opt == CI_MS_WINS2] = 0; \
    }
#endif /* UNUSED - WINS */

    REJCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs,
 8016a52:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016a54:	781b      	ldrb	r3, [r3, #0]
 8016a56:	2201      	movs	r2, #1
 8016a58:	4013      	ands	r3, r2
 8016a5a:	b2db      	uxtb	r3, r3
 8016a5c:	2b00      	cmp	r3, #0
 8016a5e:	d000      	beq.n	8016a62 <ipcp_rejci+0x3a>
 8016a60:	e086      	b.n	8016b70 <ipcp_rejci+0x148>
 8016a62:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016a64:	781b      	ldrb	r3, [r3, #0]
 8016a66:	2202      	movs	r2, #2
 8016a68:	4013      	ands	r3, r2
 8016a6a:	b2db      	uxtb	r3, r3
 8016a6c:	2b00      	cmp	r3, #0
 8016a6e:	d100      	bne.n	8016a72 <ipcp_rejci+0x4a>
 8016a70:	e07e      	b.n	8016b70 <ipcp_rejci+0x148>
 8016a72:	2147      	movs	r1, #71	; 0x47
 8016a74:	187b      	adds	r3, r7, r1
 8016a76:	68ba      	ldr	r2, [r7, #8]
 8016a78:	7852      	ldrb	r2, [r2, #1]
 8016a7a:	701a      	strb	r2, [r3, #0]
 8016a7c:	187b      	adds	r3, r7, r1
 8016a7e:	781b      	ldrb	r3, [r3, #0]
 8016a80:	2b0a      	cmp	r3, #10
 8016a82:	d175      	bne.n	8016b70 <ipcp_rejci+0x148>
 8016a84:	187b      	adds	r3, r7, r1
 8016a86:	781b      	ldrb	r3, [r3, #0]
 8016a88:	687a      	ldr	r2, [r7, #4]
 8016a8a:	429a      	cmp	r2, r3
 8016a8c:	db70      	blt.n	8016b70 <ipcp_rejci+0x148>
 8016a8e:	68bb      	ldr	r3, [r7, #8]
 8016a90:	781b      	ldrb	r3, [r3, #0]
 8016a92:	2b01      	cmp	r3, #1
 8016a94:	d16c      	bne.n	8016b70 <ipcp_rejci+0x148>
 8016a96:	187b      	adds	r3, r7, r1
 8016a98:	781b      	ldrb	r3, [r3, #0]
 8016a9a:	687a      	ldr	r2, [r7, #4]
 8016a9c:	1ad3      	subs	r3, r2, r3
 8016a9e:	607b      	str	r3, [r7, #4]
 8016aa0:	68bb      	ldr	r3, [r7, #8]
 8016aa2:	3302      	adds	r3, #2
 8016aa4:	60bb      	str	r3, [r7, #8]
 8016aa6:	68bb      	ldr	r3, [r7, #8]
 8016aa8:	1c5a      	adds	r2, r3, #1
 8016aaa:	60ba      	str	r2, [r7, #8]
 8016aac:	781b      	ldrb	r3, [r3, #0]
 8016aae:	021b      	lsls	r3, r3, #8
 8016ab0:	643b      	str	r3, [r7, #64]	; 0x40
 8016ab2:	68bb      	ldr	r3, [r7, #8]
 8016ab4:	1c5a      	adds	r2, r3, #1
 8016ab6:	60ba      	str	r2, [r7, #8]
 8016ab8:	781b      	ldrb	r3, [r3, #0]
 8016aba:	001a      	movs	r2, r3
 8016abc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016abe:	4313      	orrs	r3, r2
 8016ac0:	643b      	str	r3, [r7, #64]	; 0x40
 8016ac2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016ac4:	021b      	lsls	r3, r3, #8
 8016ac6:	643b      	str	r3, [r7, #64]	; 0x40
 8016ac8:	68bb      	ldr	r3, [r7, #8]
 8016aca:	1c5a      	adds	r2, r3, #1
 8016acc:	60ba      	str	r2, [r7, #8]
 8016ace:	781b      	ldrb	r3, [r3, #0]
 8016ad0:	001a      	movs	r2, r3
 8016ad2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016ad4:	4313      	orrs	r3, r2
 8016ad6:	643b      	str	r3, [r7, #64]	; 0x40
 8016ad8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016ada:	021b      	lsls	r3, r3, #8
 8016adc:	643b      	str	r3, [r7, #64]	; 0x40
 8016ade:	68bb      	ldr	r3, [r7, #8]
 8016ae0:	1c5a      	adds	r2, r3, #1
 8016ae2:	60ba      	str	r2, [r7, #8]
 8016ae4:	781b      	ldrb	r3, [r3, #0]
 8016ae6:	001a      	movs	r2, r3
 8016ae8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016aea:	4313      	orrs	r3, r2
 8016aec:	643b      	str	r3, [r7, #64]	; 0x40
 8016aee:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016af0:	0018      	movs	r0, r3
 8016af2:	f7f0 fa15 	bl	8006f20 <lwip_htonl>
 8016af6:	0003      	movs	r3, r0
 8016af8:	63fb      	str	r3, [r7, #60]	; 0x3c
 8016afa:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016afc:	685b      	ldr	r3, [r3, #4]
 8016afe:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8016b00:	429a      	cmp	r2, r3
 8016b02:	d000      	beq.n	8016b06 <ipcp_rejci+0xde>
 8016b04:	e1bf      	b.n	8016e86 <ipcp_rejci+0x45e>
 8016b06:	68bb      	ldr	r3, [r7, #8]
 8016b08:	1c5a      	adds	r2, r3, #1
 8016b0a:	60ba      	str	r2, [r7, #8]
 8016b0c:	781b      	ldrb	r3, [r3, #0]
 8016b0e:	021b      	lsls	r3, r3, #8
 8016b10:	643b      	str	r3, [r7, #64]	; 0x40
 8016b12:	68bb      	ldr	r3, [r7, #8]
 8016b14:	1c5a      	adds	r2, r3, #1
 8016b16:	60ba      	str	r2, [r7, #8]
 8016b18:	781b      	ldrb	r3, [r3, #0]
 8016b1a:	001a      	movs	r2, r3
 8016b1c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016b1e:	4313      	orrs	r3, r2
 8016b20:	643b      	str	r3, [r7, #64]	; 0x40
 8016b22:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016b24:	021b      	lsls	r3, r3, #8
 8016b26:	643b      	str	r3, [r7, #64]	; 0x40
 8016b28:	68bb      	ldr	r3, [r7, #8]
 8016b2a:	1c5a      	adds	r2, r3, #1
 8016b2c:	60ba      	str	r2, [r7, #8]
 8016b2e:	781b      	ldrb	r3, [r3, #0]
 8016b30:	001a      	movs	r2, r3
 8016b32:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016b34:	4313      	orrs	r3, r2
 8016b36:	643b      	str	r3, [r7, #64]	; 0x40
 8016b38:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016b3a:	021b      	lsls	r3, r3, #8
 8016b3c:	643b      	str	r3, [r7, #64]	; 0x40
 8016b3e:	68bb      	ldr	r3, [r7, #8]
 8016b40:	1c5a      	adds	r2, r3, #1
 8016b42:	60ba      	str	r2, [r7, #8]
 8016b44:	781b      	ldrb	r3, [r3, #0]
 8016b46:	001a      	movs	r2, r3
 8016b48:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016b4a:	4313      	orrs	r3, r2
 8016b4c:	643b      	str	r3, [r7, #64]	; 0x40
 8016b4e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016b50:	0018      	movs	r0, r3
 8016b52:	f7f0 f9e5 	bl	8006f20 <lwip_htonl>
 8016b56:	0003      	movs	r3, r0
 8016b58:	63fb      	str	r3, [r7, #60]	; 0x3c
 8016b5a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016b5c:	689b      	ldr	r3, [r3, #8]
 8016b5e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8016b60:	429a      	cmp	r2, r3
 8016b62:	d000      	beq.n	8016b66 <ipcp_rejci+0x13e>
 8016b64:	e191      	b.n	8016e8a <ipcp_rejci+0x462>
 8016b66:	193b      	adds	r3, r7, r4
 8016b68:	781a      	ldrb	r2, [r3, #0]
 8016b6a:	2102      	movs	r1, #2
 8016b6c:	438a      	bics	r2, r1
 8016b6e:	701a      	strb	r2, [r3, #0]
	       go->ouraddr, go->hisaddr);

#if VJ_SUPPORT
    REJCIVJ(CI_COMPRESSTYPE, neg_vj, go->vj_protocol, go->old_vj,
 8016b70:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016b72:	781b      	ldrb	r3, [r3, #0]
 8016b74:	2208      	movs	r2, #8
 8016b76:	4013      	ands	r3, r2
 8016b78:	b2db      	uxtb	r3, r3
 8016b7a:	2b00      	cmp	r3, #0
 8016b7c:	d100      	bne.n	8016b80 <ipcp_rejci+0x158>
 8016b7e:	e06e      	b.n	8016c5e <ipcp_rejci+0x236>
 8016b80:	68bb      	ldr	r3, [r7, #8]
 8016b82:	3301      	adds	r3, #1
 8016b84:	781b      	ldrb	r3, [r3, #0]
 8016b86:	0019      	movs	r1, r3
 8016b88:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016b8a:	781b      	ldrb	r3, [r3, #0]
 8016b8c:	2210      	movs	r2, #16
 8016b8e:	4013      	ands	r3, r2
 8016b90:	b2db      	uxtb	r3, r3
 8016b92:	2b00      	cmp	r3, #0
 8016b94:	d004      	beq.n	8016ba0 <ipcp_rejci+0x178>
 8016b96:	2304      	movs	r3, #4
 8016b98:	e003      	b.n	8016ba2 <ipcp_rejci+0x17a>
 8016b9a:	46c0      	nop			; (mov r8, r8)
 8016b9c:	0000121c 	.word	0x0000121c
 8016ba0:	2306      	movs	r3, #6
 8016ba2:	428b      	cmp	r3, r1
 8016ba4:	d15b      	bne.n	8016c5e <ipcp_rejci+0x236>
 8016ba6:	68bb      	ldr	r3, [r7, #8]
 8016ba8:	3301      	adds	r3, #1
 8016baa:	781b      	ldrb	r3, [r3, #0]
 8016bac:	001a      	movs	r2, r3
 8016bae:	687b      	ldr	r3, [r7, #4]
 8016bb0:	4293      	cmp	r3, r2
 8016bb2:	db54      	blt.n	8016c5e <ipcp_rejci+0x236>
 8016bb4:	68bb      	ldr	r3, [r7, #8]
 8016bb6:	781b      	ldrb	r3, [r3, #0]
 8016bb8:	2b02      	cmp	r3, #2
 8016bba:	d150      	bne.n	8016c5e <ipcp_rejci+0x236>
 8016bbc:	68bb      	ldr	r3, [r7, #8]
 8016bbe:	3301      	adds	r3, #1
 8016bc0:	781b      	ldrb	r3, [r3, #0]
 8016bc2:	001a      	movs	r2, r3
 8016bc4:	687b      	ldr	r3, [r7, #4]
 8016bc6:	1a9b      	subs	r3, r3, r2
 8016bc8:	607b      	str	r3, [r7, #4]
 8016bca:	68bb      	ldr	r3, [r7, #8]
 8016bcc:	3302      	adds	r3, #2
 8016bce:	60bb      	str	r3, [r7, #8]
 8016bd0:	68bb      	ldr	r3, [r7, #8]
 8016bd2:	1c5a      	adds	r2, r3, #1
 8016bd4:	60ba      	str	r2, [r7, #8]
 8016bd6:	781b      	ldrb	r3, [r3, #0]
 8016bd8:	b29a      	uxth	r2, r3
 8016bda:	203a      	movs	r0, #58	; 0x3a
 8016bdc:	183b      	adds	r3, r7, r0
 8016bde:	0212      	lsls	r2, r2, #8
 8016be0:	801a      	strh	r2, [r3, #0]
 8016be2:	68bb      	ldr	r3, [r7, #8]
 8016be4:	1c5a      	adds	r2, r3, #1
 8016be6:	60ba      	str	r2, [r7, #8]
 8016be8:	781b      	ldrb	r3, [r3, #0]
 8016bea:	b299      	uxth	r1, r3
 8016bec:	183b      	adds	r3, r7, r0
 8016bee:	183a      	adds	r2, r7, r0
 8016bf0:	8812      	ldrh	r2, [r2, #0]
 8016bf2:	430a      	orrs	r2, r1
 8016bf4:	801a      	strh	r2, [r3, #0]
 8016bf6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016bf8:	8a9b      	ldrh	r3, [r3, #20]
 8016bfa:	183a      	adds	r2, r7, r0
 8016bfc:	8812      	ldrh	r2, [r2, #0]
 8016bfe:	429a      	cmp	r2, r3
 8016c00:	d000      	beq.n	8016c04 <ipcp_rejci+0x1dc>
 8016c02:	e144      	b.n	8016e8e <ipcp_rejci+0x466>
 8016c04:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016c06:	781b      	ldrb	r3, [r3, #0]
 8016c08:	2210      	movs	r2, #16
 8016c0a:	4013      	ands	r3, r2
 8016c0c:	b2db      	uxtb	r3, r3
 8016c0e:	2b00      	cmp	r3, #0
 8016c10:	d11f      	bne.n	8016c52 <ipcp_rejci+0x22a>
 8016c12:	68bb      	ldr	r3, [r7, #8]
 8016c14:	1c5a      	adds	r2, r3, #1
 8016c16:	60ba      	str	r2, [r7, #8]
 8016c18:	2139      	movs	r1, #57	; 0x39
 8016c1a:	187a      	adds	r2, r7, r1
 8016c1c:	781b      	ldrb	r3, [r3, #0]
 8016c1e:	7013      	strb	r3, [r2, #0]
 8016c20:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016c22:	7d9b      	ldrb	r3, [r3, #22]
 8016c24:	187a      	adds	r2, r7, r1
 8016c26:	7812      	ldrb	r2, [r2, #0]
 8016c28:	429a      	cmp	r2, r3
 8016c2a:	d000      	beq.n	8016c2e <ipcp_rejci+0x206>
 8016c2c:	e131      	b.n	8016e92 <ipcp_rejci+0x46a>
 8016c2e:	68bb      	ldr	r3, [r7, #8]
 8016c30:	1c5a      	adds	r2, r3, #1
 8016c32:	60ba      	str	r2, [r7, #8]
 8016c34:	2138      	movs	r1, #56	; 0x38
 8016c36:	187a      	adds	r2, r7, r1
 8016c38:	781b      	ldrb	r3, [r3, #0]
 8016c3a:	7013      	strb	r3, [r2, #0]
 8016c3c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016c3e:	781b      	ldrb	r3, [r3, #0]
 8016c40:	069b      	lsls	r3, r3, #26
 8016c42:	0fdb      	lsrs	r3, r3, #31
 8016c44:	b2db      	uxtb	r3, r3
 8016c46:	001a      	movs	r2, r3
 8016c48:	187b      	adds	r3, r7, r1
 8016c4a:	781b      	ldrb	r3, [r3, #0]
 8016c4c:	4293      	cmp	r3, r2
 8016c4e:	d000      	beq.n	8016c52 <ipcp_rejci+0x22a>
 8016c50:	e121      	b.n	8016e96 <ipcp_rejci+0x46e>
 8016c52:	2314      	movs	r3, #20
 8016c54:	18fb      	adds	r3, r7, r3
 8016c56:	781a      	ldrb	r2, [r3, #0]
 8016c58:	2108      	movs	r1, #8
 8016c5a:	438a      	bics	r2, r1
 8016c5c:	701a      	strb	r2, [r3, #0]
	    go->maxslotindex, go->cflag);
#endif /* VJ_SUPPORT */

    REJCIADDR(CI_ADDR, neg_addr, go->ouraddr);
 8016c5e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016c60:	781b      	ldrb	r3, [r3, #0]
 8016c62:	2201      	movs	r2, #1
 8016c64:	4013      	ands	r3, r2
 8016c66:	b2db      	uxtb	r3, r3
 8016c68:	2b00      	cmp	r3, #0
 8016c6a:	d04f      	beq.n	8016d0c <ipcp_rejci+0x2e4>
 8016c6c:	2147      	movs	r1, #71	; 0x47
 8016c6e:	187b      	adds	r3, r7, r1
 8016c70:	68ba      	ldr	r2, [r7, #8]
 8016c72:	7852      	ldrb	r2, [r2, #1]
 8016c74:	701a      	strb	r2, [r3, #0]
 8016c76:	187b      	adds	r3, r7, r1
 8016c78:	781b      	ldrb	r3, [r3, #0]
 8016c7a:	2b06      	cmp	r3, #6
 8016c7c:	d146      	bne.n	8016d0c <ipcp_rejci+0x2e4>
 8016c7e:	187b      	adds	r3, r7, r1
 8016c80:	781b      	ldrb	r3, [r3, #0]
 8016c82:	687a      	ldr	r2, [r7, #4]
 8016c84:	429a      	cmp	r2, r3
 8016c86:	db41      	blt.n	8016d0c <ipcp_rejci+0x2e4>
 8016c88:	68bb      	ldr	r3, [r7, #8]
 8016c8a:	781b      	ldrb	r3, [r3, #0]
 8016c8c:	2b03      	cmp	r3, #3
 8016c8e:	d13d      	bne.n	8016d0c <ipcp_rejci+0x2e4>
 8016c90:	187b      	adds	r3, r7, r1
 8016c92:	781b      	ldrb	r3, [r3, #0]
 8016c94:	687a      	ldr	r2, [r7, #4]
 8016c96:	1ad3      	subs	r3, r2, r3
 8016c98:	607b      	str	r3, [r7, #4]
 8016c9a:	68bb      	ldr	r3, [r7, #8]
 8016c9c:	3302      	adds	r3, #2
 8016c9e:	60bb      	str	r3, [r7, #8]
 8016ca0:	68bb      	ldr	r3, [r7, #8]
 8016ca2:	1c5a      	adds	r2, r3, #1
 8016ca4:	60ba      	str	r2, [r7, #8]
 8016ca6:	781b      	ldrb	r3, [r3, #0]
 8016ca8:	021b      	lsls	r3, r3, #8
 8016caa:	637b      	str	r3, [r7, #52]	; 0x34
 8016cac:	68bb      	ldr	r3, [r7, #8]
 8016cae:	1c5a      	adds	r2, r3, #1
 8016cb0:	60ba      	str	r2, [r7, #8]
 8016cb2:	781b      	ldrb	r3, [r3, #0]
 8016cb4:	001a      	movs	r2, r3
 8016cb6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016cb8:	4313      	orrs	r3, r2
 8016cba:	637b      	str	r3, [r7, #52]	; 0x34
 8016cbc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016cbe:	021b      	lsls	r3, r3, #8
 8016cc0:	637b      	str	r3, [r7, #52]	; 0x34
 8016cc2:	68bb      	ldr	r3, [r7, #8]
 8016cc4:	1c5a      	adds	r2, r3, #1
 8016cc6:	60ba      	str	r2, [r7, #8]
 8016cc8:	781b      	ldrb	r3, [r3, #0]
 8016cca:	001a      	movs	r2, r3
 8016ccc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016cce:	4313      	orrs	r3, r2
 8016cd0:	637b      	str	r3, [r7, #52]	; 0x34
 8016cd2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016cd4:	021b      	lsls	r3, r3, #8
 8016cd6:	637b      	str	r3, [r7, #52]	; 0x34
 8016cd8:	68bb      	ldr	r3, [r7, #8]
 8016cda:	1c5a      	adds	r2, r3, #1
 8016cdc:	60ba      	str	r2, [r7, #8]
 8016cde:	781b      	ldrb	r3, [r3, #0]
 8016ce0:	001a      	movs	r2, r3
 8016ce2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016ce4:	4313      	orrs	r3, r2
 8016ce6:	637b      	str	r3, [r7, #52]	; 0x34
 8016ce8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016cea:	0018      	movs	r0, r3
 8016cec:	f7f0 f918 	bl	8006f20 <lwip_htonl>
 8016cf0:	0003      	movs	r3, r0
 8016cf2:	63fb      	str	r3, [r7, #60]	; 0x3c
 8016cf4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016cf6:	685b      	ldr	r3, [r3, #4]
 8016cf8:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8016cfa:	429a      	cmp	r2, r3
 8016cfc:	d000      	beq.n	8016d00 <ipcp_rejci+0x2d8>
 8016cfe:	e0cc      	b.n	8016e9a <ipcp_rejci+0x472>
 8016d00:	2314      	movs	r3, #20
 8016d02:	18fb      	adds	r3, r7, r3
 8016d04:	781a      	ldrb	r2, [r3, #0]
 8016d06:	2101      	movs	r1, #1
 8016d08:	438a      	bics	r2, r1
 8016d0a:	701a      	strb	r2, [r3, #0]

#if LWIP_DNS
    REJCIDNS(CI_MS_DNS1, req_dns1, go->dnsaddr[0]);
 8016d0c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016d0e:	785b      	ldrb	r3, [r3, #1]
 8016d10:	2201      	movs	r2, #1
 8016d12:	4013      	ands	r3, r2
 8016d14:	b2db      	uxtb	r3, r3
 8016d16:	2b00      	cmp	r3, #0
 8016d18:	d04f      	beq.n	8016dba <ipcp_rejci+0x392>
 8016d1a:	2147      	movs	r1, #71	; 0x47
 8016d1c:	187b      	adds	r3, r7, r1
 8016d1e:	68ba      	ldr	r2, [r7, #8]
 8016d20:	7852      	ldrb	r2, [r2, #1]
 8016d22:	701a      	strb	r2, [r3, #0]
 8016d24:	187b      	adds	r3, r7, r1
 8016d26:	781b      	ldrb	r3, [r3, #0]
 8016d28:	2b06      	cmp	r3, #6
 8016d2a:	d146      	bne.n	8016dba <ipcp_rejci+0x392>
 8016d2c:	187b      	adds	r3, r7, r1
 8016d2e:	781b      	ldrb	r3, [r3, #0]
 8016d30:	687a      	ldr	r2, [r7, #4]
 8016d32:	429a      	cmp	r2, r3
 8016d34:	db41      	blt.n	8016dba <ipcp_rejci+0x392>
 8016d36:	68bb      	ldr	r3, [r7, #8]
 8016d38:	781b      	ldrb	r3, [r3, #0]
 8016d3a:	2b81      	cmp	r3, #129	; 0x81
 8016d3c:	d13d      	bne.n	8016dba <ipcp_rejci+0x392>
 8016d3e:	187b      	adds	r3, r7, r1
 8016d40:	781b      	ldrb	r3, [r3, #0]
 8016d42:	687a      	ldr	r2, [r7, #4]
 8016d44:	1ad3      	subs	r3, r2, r3
 8016d46:	607b      	str	r3, [r7, #4]
 8016d48:	68bb      	ldr	r3, [r7, #8]
 8016d4a:	3302      	adds	r3, #2
 8016d4c:	60bb      	str	r3, [r7, #8]
 8016d4e:	68bb      	ldr	r3, [r7, #8]
 8016d50:	1c5a      	adds	r2, r3, #1
 8016d52:	60ba      	str	r2, [r7, #8]
 8016d54:	781b      	ldrb	r3, [r3, #0]
 8016d56:	021b      	lsls	r3, r3, #8
 8016d58:	633b      	str	r3, [r7, #48]	; 0x30
 8016d5a:	68bb      	ldr	r3, [r7, #8]
 8016d5c:	1c5a      	adds	r2, r3, #1
 8016d5e:	60ba      	str	r2, [r7, #8]
 8016d60:	781b      	ldrb	r3, [r3, #0]
 8016d62:	001a      	movs	r2, r3
 8016d64:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016d66:	4313      	orrs	r3, r2
 8016d68:	633b      	str	r3, [r7, #48]	; 0x30
 8016d6a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016d6c:	021b      	lsls	r3, r3, #8
 8016d6e:	633b      	str	r3, [r7, #48]	; 0x30
 8016d70:	68bb      	ldr	r3, [r7, #8]
 8016d72:	1c5a      	adds	r2, r3, #1
 8016d74:	60ba      	str	r2, [r7, #8]
 8016d76:	781b      	ldrb	r3, [r3, #0]
 8016d78:	001a      	movs	r2, r3
 8016d7a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016d7c:	4313      	orrs	r3, r2
 8016d7e:	633b      	str	r3, [r7, #48]	; 0x30
 8016d80:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016d82:	021b      	lsls	r3, r3, #8
 8016d84:	633b      	str	r3, [r7, #48]	; 0x30
 8016d86:	68bb      	ldr	r3, [r7, #8]
 8016d88:	1c5a      	adds	r2, r3, #1
 8016d8a:	60ba      	str	r2, [r7, #8]
 8016d8c:	781b      	ldrb	r3, [r3, #0]
 8016d8e:	001a      	movs	r2, r3
 8016d90:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016d92:	4313      	orrs	r3, r2
 8016d94:	633b      	str	r3, [r7, #48]	; 0x30
 8016d96:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016d98:	0018      	movs	r0, r3
 8016d9a:	f7f0 f8c1 	bl	8006f20 <lwip_htonl>
 8016d9e:	0003      	movs	r3, r0
 8016da0:	63fb      	str	r3, [r7, #60]	; 0x3c
 8016da2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016da4:	68db      	ldr	r3, [r3, #12]
 8016da6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8016da8:	429a      	cmp	r2, r3
 8016daa:	d000      	beq.n	8016dae <ipcp_rejci+0x386>
 8016dac:	e077      	b.n	8016e9e <ipcp_rejci+0x476>
 8016dae:	2314      	movs	r3, #20
 8016db0:	18fb      	adds	r3, r7, r3
 8016db2:	785a      	ldrb	r2, [r3, #1]
 8016db4:	2101      	movs	r1, #1
 8016db6:	438a      	bics	r2, r1
 8016db8:	705a      	strb	r2, [r3, #1]

    REJCIDNS(CI_MS_DNS2, req_dns2, go->dnsaddr[1]);
 8016dba:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016dbc:	785b      	ldrb	r3, [r3, #1]
 8016dbe:	2202      	movs	r2, #2
 8016dc0:	4013      	ands	r3, r2
 8016dc2:	b2db      	uxtb	r3, r3
 8016dc4:	2b00      	cmp	r3, #0
 8016dc6:	d04e      	beq.n	8016e66 <ipcp_rejci+0x43e>
 8016dc8:	2147      	movs	r1, #71	; 0x47
 8016dca:	187b      	adds	r3, r7, r1
 8016dcc:	68ba      	ldr	r2, [r7, #8]
 8016dce:	7852      	ldrb	r2, [r2, #1]
 8016dd0:	701a      	strb	r2, [r3, #0]
 8016dd2:	187b      	adds	r3, r7, r1
 8016dd4:	781b      	ldrb	r3, [r3, #0]
 8016dd6:	2b06      	cmp	r3, #6
 8016dd8:	d145      	bne.n	8016e66 <ipcp_rejci+0x43e>
 8016dda:	187b      	adds	r3, r7, r1
 8016ddc:	781b      	ldrb	r3, [r3, #0]
 8016dde:	687a      	ldr	r2, [r7, #4]
 8016de0:	429a      	cmp	r2, r3
 8016de2:	db40      	blt.n	8016e66 <ipcp_rejci+0x43e>
 8016de4:	68bb      	ldr	r3, [r7, #8]
 8016de6:	781b      	ldrb	r3, [r3, #0]
 8016de8:	2b83      	cmp	r3, #131	; 0x83
 8016dea:	d13c      	bne.n	8016e66 <ipcp_rejci+0x43e>
 8016dec:	187b      	adds	r3, r7, r1
 8016dee:	781b      	ldrb	r3, [r3, #0]
 8016df0:	687a      	ldr	r2, [r7, #4]
 8016df2:	1ad3      	subs	r3, r2, r3
 8016df4:	607b      	str	r3, [r7, #4]
 8016df6:	68bb      	ldr	r3, [r7, #8]
 8016df8:	3302      	adds	r3, #2
 8016dfa:	60bb      	str	r3, [r7, #8]
 8016dfc:	68bb      	ldr	r3, [r7, #8]
 8016dfe:	1c5a      	adds	r2, r3, #1
 8016e00:	60ba      	str	r2, [r7, #8]
 8016e02:	781b      	ldrb	r3, [r3, #0]
 8016e04:	021b      	lsls	r3, r3, #8
 8016e06:	62fb      	str	r3, [r7, #44]	; 0x2c
 8016e08:	68bb      	ldr	r3, [r7, #8]
 8016e0a:	1c5a      	adds	r2, r3, #1
 8016e0c:	60ba      	str	r2, [r7, #8]
 8016e0e:	781b      	ldrb	r3, [r3, #0]
 8016e10:	001a      	movs	r2, r3
 8016e12:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016e14:	4313      	orrs	r3, r2
 8016e16:	62fb      	str	r3, [r7, #44]	; 0x2c
 8016e18:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016e1a:	021b      	lsls	r3, r3, #8
 8016e1c:	62fb      	str	r3, [r7, #44]	; 0x2c
 8016e1e:	68bb      	ldr	r3, [r7, #8]
 8016e20:	1c5a      	adds	r2, r3, #1
 8016e22:	60ba      	str	r2, [r7, #8]
 8016e24:	781b      	ldrb	r3, [r3, #0]
 8016e26:	001a      	movs	r2, r3
 8016e28:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016e2a:	4313      	orrs	r3, r2
 8016e2c:	62fb      	str	r3, [r7, #44]	; 0x2c
 8016e2e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016e30:	021b      	lsls	r3, r3, #8
 8016e32:	62fb      	str	r3, [r7, #44]	; 0x2c
 8016e34:	68bb      	ldr	r3, [r7, #8]
 8016e36:	1c5a      	adds	r2, r3, #1
 8016e38:	60ba      	str	r2, [r7, #8]
 8016e3a:	781b      	ldrb	r3, [r3, #0]
 8016e3c:	001a      	movs	r2, r3
 8016e3e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016e40:	4313      	orrs	r3, r2
 8016e42:	62fb      	str	r3, [r7, #44]	; 0x2c
 8016e44:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016e46:	0018      	movs	r0, r3
 8016e48:	f7f0 f86a 	bl	8006f20 <lwip_htonl>
 8016e4c:	0003      	movs	r3, r0
 8016e4e:	63fb      	str	r3, [r7, #60]	; 0x3c
 8016e50:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016e52:	691b      	ldr	r3, [r3, #16]
 8016e54:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8016e56:	429a      	cmp	r2, r3
 8016e58:	d123      	bne.n	8016ea2 <ipcp_rejci+0x47a>
 8016e5a:	2314      	movs	r3, #20
 8016e5c:	18fb      	adds	r3, r7, r3
 8016e5e:	785a      	ldrb	r2, [r3, #1]
 8016e60:	2102      	movs	r1, #2
 8016e62:	438a      	bics	r2, r1
 8016e64:	705a      	strb	r2, [r3, #1]
#endif /* UNUSED - WINS */

    /*
     * If there are any remaining CIs, then this packet is bad.
     */
    if (len != 0)
 8016e66:	687b      	ldr	r3, [r7, #4]
 8016e68:	2b00      	cmp	r3, #0
 8016e6a:	d11c      	bne.n	8016ea6 <ipcp_rejci+0x47e>
	goto bad;
    /*
     * Now we can update state.
     */
    if (f->state != PPP_FSM_OPENED)
 8016e6c:	68fb      	ldr	r3, [r7, #12]
 8016e6e:	7c1b      	ldrb	r3, [r3, #16]
 8016e70:	2b09      	cmp	r3, #9
 8016e72:	d006      	beq.n	8016e82 <ipcp_rejci+0x45a>
	*go = try_;
 8016e74:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016e76:	2214      	movs	r2, #20
 8016e78:	18ba      	adds	r2, r7, r2
 8016e7a:	ca13      	ldmia	r2!, {r0, r1, r4}
 8016e7c:	c313      	stmia	r3!, {r0, r1, r4}
 8016e7e:	ca13      	ldmia	r2!, {r0, r1, r4}
 8016e80:	c313      	stmia	r3!, {r0, r1, r4}
    return 1;
 8016e82:	2301      	movs	r3, #1
 8016e84:	e011      	b.n	8016eaa <ipcp_rejci+0x482>
    REJCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs,
 8016e86:	46c0      	nop			; (mov r8, r8)
 8016e88:	e00e      	b.n	8016ea8 <ipcp_rejci+0x480>
 8016e8a:	46c0      	nop			; (mov r8, r8)
 8016e8c:	e00c      	b.n	8016ea8 <ipcp_rejci+0x480>
    REJCIVJ(CI_COMPRESSTYPE, neg_vj, go->vj_protocol, go->old_vj,
 8016e8e:	46c0      	nop			; (mov r8, r8)
 8016e90:	e00a      	b.n	8016ea8 <ipcp_rejci+0x480>
 8016e92:	46c0      	nop			; (mov r8, r8)
 8016e94:	e008      	b.n	8016ea8 <ipcp_rejci+0x480>
 8016e96:	46c0      	nop			; (mov r8, r8)
 8016e98:	e006      	b.n	8016ea8 <ipcp_rejci+0x480>
    REJCIADDR(CI_ADDR, neg_addr, go->ouraddr);
 8016e9a:	46c0      	nop			; (mov r8, r8)
 8016e9c:	e004      	b.n	8016ea8 <ipcp_rejci+0x480>
    REJCIDNS(CI_MS_DNS1, req_dns1, go->dnsaddr[0]);
 8016e9e:	46c0      	nop			; (mov r8, r8)
 8016ea0:	e002      	b.n	8016ea8 <ipcp_rejci+0x480>
    REJCIDNS(CI_MS_DNS2, req_dns2, go->dnsaddr[1]);
 8016ea2:	46c0      	nop			; (mov r8, r8)
 8016ea4:	e000      	b.n	8016ea8 <ipcp_rejci+0x480>
	goto bad;
 8016ea6:	46c0      	nop			; (mov r8, r8)

bad:
    IPCPDEBUG(("ipcp_rejci: received bad Reject!"));
    return 0;
 8016ea8:	2300      	movs	r3, #0
}
 8016eaa:	0018      	movs	r0, r3
 8016eac:	46bd      	mov	sp, r7
 8016eae:	b014      	add	sp, #80	; 0x50
 8016eb0:	bdb0      	pop	{r4, r5, r7, pc}
 8016eb2:	46c0      	nop			; (mov r8, r8)

08016eb4 <ipcp_reqci>:
 * CONFNAK; returns CONFREJ if it can't return CONFACK.
 *
 * inp = Requested CIs
 * len = Length of requested CIs
 */
static int ipcp_reqci(fsm *f, u_char *inp, int *len, int reject_if_disagree) {
 8016eb4:	b580      	push	{r7, lr}
 8016eb6:	b096      	sub	sp, #88	; 0x58
 8016eb8:	af00      	add	r7, sp, #0
 8016eba:	60f8      	str	r0, [r7, #12]
 8016ebc:	60b9      	str	r1, [r7, #8]
 8016ebe:	607a      	str	r2, [r7, #4]
 8016ec0:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 8016ec2:	68fb      	ldr	r3, [r7, #12]
 8016ec4:	681b      	ldr	r3, [r3, #0]
 8016ec6:	63bb      	str	r3, [r7, #56]	; 0x38
    ipcp_options *wo = &pcb->ipcp_wantoptions;
 8016ec8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016eca:	4abe      	ldr	r2, [pc, #760]	; (80171c4 <ipcp_reqci+0x310>)
 8016ecc:	4694      	mov	ip, r2
 8016ece:	4463      	add	r3, ip
 8016ed0:	637b      	str	r3, [r7, #52]	; 0x34
    ipcp_options *ho = &pcb->ipcp_hisoptions;
 8016ed2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016ed4:	4abc      	ldr	r2, [pc, #752]	; (80171c8 <ipcp_reqci+0x314>)
 8016ed6:	4694      	mov	ip, r2
 8016ed8:	4463      	add	r3, ip
 8016eda:	633b      	str	r3, [r7, #48]	; 0x30
    ipcp_options *ao = &pcb->ipcp_allowoptions;
 8016edc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016ede:	4abb      	ldr	r2, [pc, #748]	; (80171cc <ipcp_reqci+0x318>)
 8016ee0:	4694      	mov	ip, r2
 8016ee2:	4463      	add	r3, ip
 8016ee4:	62fb      	str	r3, [r7, #44]	; 0x2c
    u_short cilen, citype;	/* Parsed len, type */
#if VJ_SUPPORT
    u_short cishort;		/* Parsed short value */
#endif /* VJ_SUPPORT */
    u32_t tl, ciaddr1, ciaddr2;/* Parsed address values */
    int rc = CONFACK;		/* Final packet return code */
 8016ee6:	2302      	movs	r3, #2
 8016ee8:	64fb      	str	r3, [r7, #76]	; 0x4c
    int orc;			/* Individual option return code */
    u_char *p;			/* Pointer to next char to parse */
    u_char *ucp = inp;		/* Pointer to current output char */
 8016eea:	68bb      	ldr	r3, [r7, #8]
 8016eec:	643b      	str	r3, [r7, #64]	; 0x40
    int l = *len;		/* Length left */
 8016eee:	687b      	ldr	r3, [r7, #4]
 8016ef0:	681b      	ldr	r3, [r3, #0]
 8016ef2:	63fb      	str	r3, [r7, #60]	; 0x3c
#endif /* LWIP_DNS */

    /*
     * Reset all his options.
     */
    BZERO(ho, sizeof(*ho));
 8016ef4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016ef6:	2218      	movs	r2, #24
 8016ef8:	2100      	movs	r1, #0
 8016efa:	0018      	movs	r0, r3
 8016efc:	f006 f802 	bl	801cf04 <memset>
    
    /*
     * Process all his options.
     */
    next = inp;
 8016f00:	68bb      	ldr	r3, [r7, #8]
 8016f02:	657b      	str	r3, [r7, #84]	; 0x54
    while (l) {
 8016f04:	e33d      	b.n	8017582 <ipcp_reqci+0x6ce>
	orc = CONFACK;			/* Assume success */
 8016f06:	2302      	movs	r3, #2
 8016f08:	64bb      	str	r3, [r7, #72]	; 0x48
	cip = p = next;			/* Remember begining of CI */
 8016f0a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016f0c:	647b      	str	r3, [r7, #68]	; 0x44
 8016f0e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016f10:	627b      	str	r3, [r7, #36]	; 0x24
	if (l < 2 ||			/* Not enough data for CI header or */
 8016f12:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016f14:	2b01      	cmp	r3, #1
 8016f16:	dd0b      	ble.n	8016f30 <ipcp_reqci+0x7c>
	    p[1] < 2 ||			/*  CI length too small or */
 8016f18:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016f1a:	3301      	adds	r3, #1
 8016f1c:	781b      	ldrb	r3, [r3, #0]
	if (l < 2 ||			/* Not enough data for CI header or */
 8016f1e:	2b01      	cmp	r3, #1
 8016f20:	d906      	bls.n	8016f30 <ipcp_reqci+0x7c>
	    p[1] > l) {			/*  CI length too big? */
 8016f22:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016f24:	3301      	adds	r3, #1
 8016f26:	781b      	ldrb	r3, [r3, #0]
 8016f28:	001a      	movs	r2, r3
	    p[1] < 2 ||			/*  CI length too small or */
 8016f2a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016f2c:	4293      	cmp	r3, r2
 8016f2e:	da08      	bge.n	8016f42 <ipcp_reqci+0x8e>
	    IPCPDEBUG(("ipcp_reqci: bad CI length!"));
	    orc = CONFREJ;		/* Reject bad CI */
 8016f30:	2304      	movs	r3, #4
 8016f32:	64bb      	str	r3, [r7, #72]	; 0x48
	    cilen = l;			/* Reject till end of packet */
 8016f34:	2352      	movs	r3, #82	; 0x52
 8016f36:	18fb      	adds	r3, r7, r3
 8016f38:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8016f3a:	801a      	strh	r2, [r3, #0]
	    l = 0;			/* Don't loop again */
 8016f3c:	2300      	movs	r3, #0
 8016f3e:	63fb      	str	r3, [r7, #60]	; 0x3c
	    goto endswitch;
 8016f40:	e2e8      	b.n	8017514 <ipcp_reqci+0x660>
	}
	GETCHAR(citype, p);		/* Parse CI type */
 8016f42:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016f44:	1c5a      	adds	r2, r3, #1
 8016f46:	647a      	str	r2, [r7, #68]	; 0x44
 8016f48:	781a      	ldrb	r2, [r3, #0]
 8016f4a:	2022      	movs	r0, #34	; 0x22
 8016f4c:	183b      	adds	r3, r7, r0
 8016f4e:	801a      	strh	r2, [r3, #0]
	GETCHAR(cilen, p);		/* Parse CI length */
 8016f50:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016f52:	1c5a      	adds	r2, r3, #1
 8016f54:	647a      	str	r2, [r7, #68]	; 0x44
 8016f56:	781a      	ldrb	r2, [r3, #0]
 8016f58:	2152      	movs	r1, #82	; 0x52
 8016f5a:	187b      	adds	r3, r7, r1
 8016f5c:	801a      	strh	r2, [r3, #0]
	l -= cilen;			/* Adjust remaining length */
 8016f5e:	187b      	adds	r3, r7, r1
 8016f60:	881b      	ldrh	r3, [r3, #0]
 8016f62:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8016f64:	1ad3      	subs	r3, r2, r3
 8016f66:	63fb      	str	r3, [r7, #60]	; 0x3c
	next += cilen;			/* Step to next CI */
 8016f68:	187b      	adds	r3, r7, r1
 8016f6a:	881b      	ldrh	r3, [r3, #0]
 8016f6c:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8016f6e:	18d3      	adds	r3, r2, r3
 8016f70:	657b      	str	r3, [r7, #84]	; 0x54

	switch (citype) {		/* Check CI type */
 8016f72:	183b      	adds	r3, r7, r0
 8016f74:	881b      	ldrh	r3, [r3, #0]
 8016f76:	2b83      	cmp	r3, #131	; 0x83
 8016f78:	d100      	bne.n	8016f7c <ipcp_reqci+0xc8>
 8016f7a:	e1a5      	b.n	80172c8 <ipcp_reqci+0x414>
 8016f7c:	dd00      	ble.n	8016f80 <ipcp_reqci+0xcc>
 8016f7e:	e2c5      	b.n	801750c <ipcp_reqci+0x658>
 8016f80:	2b81      	cmp	r3, #129	; 0x81
 8016f82:	d100      	bne.n	8016f86 <ipcp_reqci+0xd2>
 8016f84:	e1a0      	b.n	80172c8 <ipcp_reqci+0x414>
 8016f86:	dd00      	ble.n	8016f8a <ipcp_reqci+0xd6>
 8016f88:	e2c0      	b.n	801750c <ipcp_reqci+0x658>
 8016f8a:	2b03      	cmp	r3, #3
 8016f8c:	d100      	bne.n	8016f90 <ipcp_reqci+0xdc>
 8016f8e:	e103      	b.n	8017198 <ipcp_reqci+0x2e4>
 8016f90:	dd00      	ble.n	8016f94 <ipcp_reqci+0xe0>
 8016f92:	e2bb      	b.n	801750c <ipcp_reqci+0x658>
 8016f94:	2b01      	cmp	r3, #1
 8016f96:	d003      	beq.n	8016fa0 <ipcp_reqci+0xec>
 8016f98:	2b02      	cmp	r3, #2
 8016f9a:	d100      	bne.n	8016f9e <ipcp_reqci+0xea>
 8016f9c:	e20d      	b.n	80173ba <ipcp_reqci+0x506>
 8016f9e:	e2b5      	b.n	801750c <ipcp_reqci+0x658>
	case CI_ADDRS:
	    if (!ao->old_addrs || ho->neg_addr ||
 8016fa0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016fa2:	781b      	ldrb	r3, [r3, #0]
 8016fa4:	2202      	movs	r2, #2
 8016fa6:	4013      	ands	r3, r2
 8016fa8:	b2db      	uxtb	r3, r3
 8016faa:	2b00      	cmp	r3, #0
 8016fac:	d00b      	beq.n	8016fc6 <ipcp_reqci+0x112>
 8016fae:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016fb0:	781b      	ldrb	r3, [r3, #0]
 8016fb2:	2201      	movs	r2, #1
 8016fb4:	4013      	ands	r3, r2
 8016fb6:	b2db      	uxtb	r3, r3
 8016fb8:	2b00      	cmp	r3, #0
 8016fba:	d104      	bne.n	8016fc6 <ipcp_reqci+0x112>
 8016fbc:	2352      	movs	r3, #82	; 0x52
 8016fbe:	18fb      	adds	r3, r7, r3
 8016fc0:	881b      	ldrh	r3, [r3, #0]
 8016fc2:	2b0a      	cmp	r3, #10
 8016fc4:	d002      	beq.n	8016fcc <ipcp_reqci+0x118>
		cilen != CILEN_ADDRS) {	/* Check CI length */
		orc = CONFREJ;		/* Reject CI */
 8016fc6:	2304      	movs	r3, #4
 8016fc8:	64bb      	str	r3, [r7, #72]	; 0x48
		break;
 8016fca:	e2a3      	b.n	8017514 <ipcp_reqci+0x660>
	     * If he has no address, or if we both have his address but
	     * disagree about it, then NAK it with our idea.
	     * In particular, if we don't know his address, but he does,
	     * then accept it.
	     */
	    GETLONG(tl, p);		/* Parse source address (his) */
 8016fcc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016fce:	1c5a      	adds	r2, r3, #1
 8016fd0:	647a      	str	r2, [r7, #68]	; 0x44
 8016fd2:	781b      	ldrb	r3, [r3, #0]
 8016fd4:	021b      	lsls	r3, r3, #8
 8016fd6:	62bb      	str	r3, [r7, #40]	; 0x28
 8016fd8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016fda:	1c5a      	adds	r2, r3, #1
 8016fdc:	647a      	str	r2, [r7, #68]	; 0x44
 8016fde:	781b      	ldrb	r3, [r3, #0]
 8016fe0:	001a      	movs	r2, r3
 8016fe2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016fe4:	4313      	orrs	r3, r2
 8016fe6:	62bb      	str	r3, [r7, #40]	; 0x28
 8016fe8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016fea:	021b      	lsls	r3, r3, #8
 8016fec:	62bb      	str	r3, [r7, #40]	; 0x28
 8016fee:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016ff0:	1c5a      	adds	r2, r3, #1
 8016ff2:	647a      	str	r2, [r7, #68]	; 0x44
 8016ff4:	781b      	ldrb	r3, [r3, #0]
 8016ff6:	001a      	movs	r2, r3
 8016ff8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016ffa:	4313      	orrs	r3, r2
 8016ffc:	62bb      	str	r3, [r7, #40]	; 0x28
 8016ffe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017000:	021b      	lsls	r3, r3, #8
 8017002:	62bb      	str	r3, [r7, #40]	; 0x28
 8017004:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017006:	1c5a      	adds	r2, r3, #1
 8017008:	647a      	str	r2, [r7, #68]	; 0x44
 801700a:	781b      	ldrb	r3, [r3, #0]
 801700c:	001a      	movs	r2, r3
 801700e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017010:	4313      	orrs	r3, r2
 8017012:	62bb      	str	r3, [r7, #40]	; 0x28
	    ciaddr1 = lwip_htonl(tl);
 8017014:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017016:	0018      	movs	r0, r3
 8017018:	f7ef ff82 	bl	8006f20 <lwip_htonl>
 801701c:	0003      	movs	r3, r0
 801701e:	61bb      	str	r3, [r7, #24]
	    if (ciaddr1 != wo->hisaddr
 8017020:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017022:	689b      	ldr	r3, [r3, #8]
 8017024:	69ba      	ldr	r2, [r7, #24]
 8017026:	429a      	cmp	r2, r3
 8017028:	d034      	beq.n	8017094 <ipcp_reqci+0x1e0>
		&& (ciaddr1 == 0 || !wo->accept_remote)) {
 801702a:	69bb      	ldr	r3, [r7, #24]
 801702c:	2b00      	cmp	r3, #0
 801702e:	d006      	beq.n	801703e <ipcp_reqci+0x18a>
 8017030:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017032:	781b      	ldrb	r3, [r3, #0]
 8017034:	227f      	movs	r2, #127	; 0x7f
 8017036:	4393      	bics	r3, r2
 8017038:	b2db      	uxtb	r3, r3
 801703a:	2b00      	cmp	r3, #0
 801703c:	d12a      	bne.n	8017094 <ipcp_reqci+0x1e0>
		orc = CONFNAK;
 801703e:	2303      	movs	r3, #3
 8017040:	64bb      	str	r3, [r7, #72]	; 0x48
		if (!reject_if_disagree) {
 8017042:	683b      	ldr	r3, [r7, #0]
 8017044:	2b00      	cmp	r3, #0
 8017046:	d134      	bne.n	80170b2 <ipcp_reqci+0x1fe>
		    DECPTR(sizeof(u32_t), p);
 8017048:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801704a:	3b04      	subs	r3, #4
 801704c:	647b      	str	r3, [r7, #68]	; 0x44
		    tl = lwip_ntohl(wo->hisaddr);
 801704e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017050:	689b      	ldr	r3, [r3, #8]
 8017052:	0018      	movs	r0, r3
 8017054:	f7ef ff64 	bl	8006f20 <lwip_htonl>
 8017058:	0003      	movs	r3, r0
 801705a:	62bb      	str	r3, [r7, #40]	; 0x28
		    PUTLONG(tl, p);
 801705c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801705e:	0e19      	lsrs	r1, r3, #24
 8017060:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017062:	1c5a      	adds	r2, r3, #1
 8017064:	647a      	str	r2, [r7, #68]	; 0x44
 8017066:	b2ca      	uxtb	r2, r1
 8017068:	701a      	strb	r2, [r3, #0]
 801706a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801706c:	0c19      	lsrs	r1, r3, #16
 801706e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017070:	1c5a      	adds	r2, r3, #1
 8017072:	647a      	str	r2, [r7, #68]	; 0x44
 8017074:	b2ca      	uxtb	r2, r1
 8017076:	701a      	strb	r2, [r3, #0]
 8017078:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801707a:	0a19      	lsrs	r1, r3, #8
 801707c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801707e:	1c5a      	adds	r2, r3, #1
 8017080:	647a      	str	r2, [r7, #68]	; 0x44
 8017082:	b2ca      	uxtb	r2, r1
 8017084:	701a      	strb	r2, [r3, #0]
 8017086:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017088:	1c5a      	adds	r2, r3, #1
 801708a:	647a      	str	r2, [r7, #68]	; 0x44
 801708c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801708e:	b2d2      	uxtb	r2, r2
 8017090:	701a      	strb	r2, [r3, #0]
		if (!reject_if_disagree) {
 8017092:	e00e      	b.n	80170b2 <ipcp_reqci+0x1fe>
		}
	    } else if (ciaddr1 == 0 && wo->hisaddr == 0) {
 8017094:	69bb      	ldr	r3, [r7, #24]
 8017096:	2b00      	cmp	r3, #0
 8017098:	d10b      	bne.n	80170b2 <ipcp_reqci+0x1fe>
 801709a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801709c:	689b      	ldr	r3, [r3, #8]
 801709e:	2b00      	cmp	r3, #0
 80170a0:	d107      	bne.n	80170b2 <ipcp_reqci+0x1fe>
		/*
		 * If neither we nor he knows his address, reject the option.
		 */
		orc = CONFREJ;
 80170a2:	2304      	movs	r3, #4
 80170a4:	64bb      	str	r3, [r7, #72]	; 0x48
		wo->req_addr = 0;	/* don't NAK with 0.0.0.0 later */
 80170a6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80170a8:	781a      	ldrb	r2, [r3, #0]
 80170aa:	2104      	movs	r1, #4
 80170ac:	438a      	bics	r2, r1
 80170ae:	701a      	strb	r2, [r3, #0]
		break;
 80170b0:	e230      	b.n	8017514 <ipcp_reqci+0x660>

	    /*
	     * If he doesn't know our address, or if we both have our address
	     * but disagree about it, then NAK it with our idea.
	     */
	    GETLONG(tl, p);		/* Parse desination address (ours) */
 80170b2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80170b4:	1c5a      	adds	r2, r3, #1
 80170b6:	647a      	str	r2, [r7, #68]	; 0x44
 80170b8:	781b      	ldrb	r3, [r3, #0]
 80170ba:	021b      	lsls	r3, r3, #8
 80170bc:	62bb      	str	r3, [r7, #40]	; 0x28
 80170be:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80170c0:	1c5a      	adds	r2, r3, #1
 80170c2:	647a      	str	r2, [r7, #68]	; 0x44
 80170c4:	781b      	ldrb	r3, [r3, #0]
 80170c6:	001a      	movs	r2, r3
 80170c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80170ca:	4313      	orrs	r3, r2
 80170cc:	62bb      	str	r3, [r7, #40]	; 0x28
 80170ce:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80170d0:	021b      	lsls	r3, r3, #8
 80170d2:	62bb      	str	r3, [r7, #40]	; 0x28
 80170d4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80170d6:	1c5a      	adds	r2, r3, #1
 80170d8:	647a      	str	r2, [r7, #68]	; 0x44
 80170da:	781b      	ldrb	r3, [r3, #0]
 80170dc:	001a      	movs	r2, r3
 80170de:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80170e0:	4313      	orrs	r3, r2
 80170e2:	62bb      	str	r3, [r7, #40]	; 0x28
 80170e4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80170e6:	021b      	lsls	r3, r3, #8
 80170e8:	62bb      	str	r3, [r7, #40]	; 0x28
 80170ea:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80170ec:	1c5a      	adds	r2, r3, #1
 80170ee:	647a      	str	r2, [r7, #68]	; 0x44
 80170f0:	781b      	ldrb	r3, [r3, #0]
 80170f2:	001a      	movs	r2, r3
 80170f4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80170f6:	4313      	orrs	r3, r2
 80170f8:	62bb      	str	r3, [r7, #40]	; 0x28
	    ciaddr2 = lwip_htonl(tl);
 80170fa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80170fc:	0018      	movs	r0, r3
 80170fe:	f7ef ff0f 	bl	8006f20 <lwip_htonl>
 8017102:	0003      	movs	r3, r0
 8017104:	613b      	str	r3, [r7, #16]
	    if (ciaddr2 != wo->ouraddr) {
 8017106:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017108:	685b      	ldr	r3, [r3, #4]
 801710a:	693a      	ldr	r2, [r7, #16]
 801710c:	429a      	cmp	r2, r3
 801710e:	d037      	beq.n	8017180 <ipcp_reqci+0x2cc>
		if (ciaddr2 == 0 || !wo->accept_local) {
 8017110:	693b      	ldr	r3, [r7, #16]
 8017112:	2b00      	cmp	r3, #0
 8017114:	d006      	beq.n	8017124 <ipcp_reqci+0x270>
 8017116:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017118:	781b      	ldrb	r3, [r3, #0]
 801711a:	2240      	movs	r2, #64	; 0x40
 801711c:	4013      	ands	r3, r2
 801711e:	b2db      	uxtb	r3, r3
 8017120:	2b00      	cmp	r3, #0
 8017122:	d12a      	bne.n	801717a <ipcp_reqci+0x2c6>
		    orc = CONFNAK;
 8017124:	2303      	movs	r3, #3
 8017126:	64bb      	str	r3, [r7, #72]	; 0x48
		    if (!reject_if_disagree) {
 8017128:	683b      	ldr	r3, [r7, #0]
 801712a:	2b00      	cmp	r3, #0
 801712c:	d128      	bne.n	8017180 <ipcp_reqci+0x2cc>
			DECPTR(sizeof(u32_t), p);
 801712e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017130:	3b04      	subs	r3, #4
 8017132:	647b      	str	r3, [r7, #68]	; 0x44
			tl = lwip_ntohl(wo->ouraddr);
 8017134:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017136:	685b      	ldr	r3, [r3, #4]
 8017138:	0018      	movs	r0, r3
 801713a:	f7ef fef1 	bl	8006f20 <lwip_htonl>
 801713e:	0003      	movs	r3, r0
 8017140:	62bb      	str	r3, [r7, #40]	; 0x28
			PUTLONG(tl, p);
 8017142:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017144:	0e19      	lsrs	r1, r3, #24
 8017146:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017148:	1c5a      	adds	r2, r3, #1
 801714a:	647a      	str	r2, [r7, #68]	; 0x44
 801714c:	b2ca      	uxtb	r2, r1
 801714e:	701a      	strb	r2, [r3, #0]
 8017150:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017152:	0c19      	lsrs	r1, r3, #16
 8017154:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017156:	1c5a      	adds	r2, r3, #1
 8017158:	647a      	str	r2, [r7, #68]	; 0x44
 801715a:	b2ca      	uxtb	r2, r1
 801715c:	701a      	strb	r2, [r3, #0]
 801715e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017160:	0a19      	lsrs	r1, r3, #8
 8017162:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017164:	1c5a      	adds	r2, r3, #1
 8017166:	647a      	str	r2, [r7, #68]	; 0x44
 8017168:	b2ca      	uxtb	r2, r1
 801716a:	701a      	strb	r2, [r3, #0]
 801716c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801716e:	1c5a      	adds	r2, r3, #1
 8017170:	647a      	str	r2, [r7, #68]	; 0x44
 8017172:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8017174:	b2d2      	uxtb	r2, r2
 8017176:	701a      	strb	r2, [r3, #0]
		    if (!reject_if_disagree) {
 8017178:	e002      	b.n	8017180 <ipcp_reqci+0x2cc>
		    }
		} else {
		    wo->ouraddr = ciaddr2;	/* accept peer's idea */
 801717a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801717c:	693a      	ldr	r2, [r7, #16]
 801717e:	605a      	str	r2, [r3, #4]
		}
	    }

	    ho->old_addrs = 1;
 8017180:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017182:	781a      	ldrb	r2, [r3, #0]
 8017184:	2102      	movs	r1, #2
 8017186:	430a      	orrs	r2, r1
 8017188:	701a      	strb	r2, [r3, #0]
	    ho->hisaddr = ciaddr1;
 801718a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801718c:	69ba      	ldr	r2, [r7, #24]
 801718e:	609a      	str	r2, [r3, #8]
	    ho->ouraddr = ciaddr2;
 8017190:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017192:	693a      	ldr	r2, [r7, #16]
 8017194:	605a      	str	r2, [r3, #4]
	    break;
 8017196:	e1bd      	b.n	8017514 <ipcp_reqci+0x660>

	case CI_ADDR:
	    if (!ao->neg_addr || ho->old_addrs ||
 8017198:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801719a:	781b      	ldrb	r3, [r3, #0]
 801719c:	2201      	movs	r2, #1
 801719e:	4013      	ands	r3, r2
 80171a0:	b2db      	uxtb	r3, r3
 80171a2:	2b00      	cmp	r3, #0
 80171a4:	d00b      	beq.n	80171be <ipcp_reqci+0x30a>
 80171a6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80171a8:	781b      	ldrb	r3, [r3, #0]
 80171aa:	2202      	movs	r2, #2
 80171ac:	4013      	ands	r3, r2
 80171ae:	b2db      	uxtb	r3, r3
 80171b0:	2b00      	cmp	r3, #0
 80171b2:	d104      	bne.n	80171be <ipcp_reqci+0x30a>
 80171b4:	2352      	movs	r3, #82	; 0x52
 80171b6:	18fb      	adds	r3, r7, r3
 80171b8:	881b      	ldrh	r3, [r3, #0]
 80171ba:	2b06      	cmp	r3, #6
 80171bc:	d008      	beq.n	80171d0 <ipcp_reqci+0x31c>
		cilen != CILEN_ADDR) {	/* Check CI length */
		orc = CONFREJ;		/* Reject CI */
 80171be:	2304      	movs	r3, #4
 80171c0:	64bb      	str	r3, [r7, #72]	; 0x48
		break;
 80171c2:	e1a7      	b.n	8017514 <ipcp_reqci+0x660>
 80171c4:	00001204 	.word	0x00001204
 80171c8:	0000124c 	.word	0x0000124c
 80171cc:	00001234 	.word	0x00001234
	     * If he has no address, or if we both have his address but
	     * disagree about it, then NAK it with our idea.
	     * In particular, if we don't know his address, but he does,
	     * then accept it.
	     */
	    GETLONG(tl, p);	/* Parse source address (his) */
 80171d0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80171d2:	1c5a      	adds	r2, r3, #1
 80171d4:	647a      	str	r2, [r7, #68]	; 0x44
 80171d6:	781b      	ldrb	r3, [r3, #0]
 80171d8:	021b      	lsls	r3, r3, #8
 80171da:	62bb      	str	r3, [r7, #40]	; 0x28
 80171dc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80171de:	1c5a      	adds	r2, r3, #1
 80171e0:	647a      	str	r2, [r7, #68]	; 0x44
 80171e2:	781b      	ldrb	r3, [r3, #0]
 80171e4:	001a      	movs	r2, r3
 80171e6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80171e8:	4313      	orrs	r3, r2
 80171ea:	62bb      	str	r3, [r7, #40]	; 0x28
 80171ec:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80171ee:	021b      	lsls	r3, r3, #8
 80171f0:	62bb      	str	r3, [r7, #40]	; 0x28
 80171f2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80171f4:	1c5a      	adds	r2, r3, #1
 80171f6:	647a      	str	r2, [r7, #68]	; 0x44
 80171f8:	781b      	ldrb	r3, [r3, #0]
 80171fa:	001a      	movs	r2, r3
 80171fc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80171fe:	4313      	orrs	r3, r2
 8017200:	62bb      	str	r3, [r7, #40]	; 0x28
 8017202:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017204:	021b      	lsls	r3, r3, #8
 8017206:	62bb      	str	r3, [r7, #40]	; 0x28
 8017208:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801720a:	1c5a      	adds	r2, r3, #1
 801720c:	647a      	str	r2, [r7, #68]	; 0x44
 801720e:	781b      	ldrb	r3, [r3, #0]
 8017210:	001a      	movs	r2, r3
 8017212:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017214:	4313      	orrs	r3, r2
 8017216:	62bb      	str	r3, [r7, #40]	; 0x28
	    ciaddr1 = lwip_htonl(tl);
 8017218:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801721a:	0018      	movs	r0, r3
 801721c:	f7ef fe80 	bl	8006f20 <lwip_htonl>
 8017220:	0003      	movs	r3, r0
 8017222:	61bb      	str	r3, [r7, #24]
	    if (ciaddr1 != wo->hisaddr
 8017224:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017226:	689b      	ldr	r3, [r3, #8]
 8017228:	69ba      	ldr	r2, [r7, #24]
 801722a:	429a      	cmp	r2, r3
 801722c:	d034      	beq.n	8017298 <ipcp_reqci+0x3e4>
		&& (ciaddr1 == 0 || !wo->accept_remote)) {
 801722e:	69bb      	ldr	r3, [r7, #24]
 8017230:	2b00      	cmp	r3, #0
 8017232:	d006      	beq.n	8017242 <ipcp_reqci+0x38e>
 8017234:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017236:	781b      	ldrb	r3, [r3, #0]
 8017238:	227f      	movs	r2, #127	; 0x7f
 801723a:	4393      	bics	r3, r2
 801723c:	b2db      	uxtb	r3, r3
 801723e:	2b00      	cmp	r3, #0
 8017240:	d12a      	bne.n	8017298 <ipcp_reqci+0x3e4>
		orc = CONFNAK;
 8017242:	2303      	movs	r3, #3
 8017244:	64bb      	str	r3, [r7, #72]	; 0x48
		if (!reject_if_disagree) {
 8017246:	683b      	ldr	r3, [r7, #0]
 8017248:	2b00      	cmp	r3, #0
 801724a:	d134      	bne.n	80172b6 <ipcp_reqci+0x402>
		    DECPTR(sizeof(u32_t), p);
 801724c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801724e:	3b04      	subs	r3, #4
 8017250:	647b      	str	r3, [r7, #68]	; 0x44
		    tl = lwip_ntohl(wo->hisaddr);
 8017252:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017254:	689b      	ldr	r3, [r3, #8]
 8017256:	0018      	movs	r0, r3
 8017258:	f7ef fe62 	bl	8006f20 <lwip_htonl>
 801725c:	0003      	movs	r3, r0
 801725e:	62bb      	str	r3, [r7, #40]	; 0x28
		    PUTLONG(tl, p);
 8017260:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017262:	0e19      	lsrs	r1, r3, #24
 8017264:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017266:	1c5a      	adds	r2, r3, #1
 8017268:	647a      	str	r2, [r7, #68]	; 0x44
 801726a:	b2ca      	uxtb	r2, r1
 801726c:	701a      	strb	r2, [r3, #0]
 801726e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017270:	0c19      	lsrs	r1, r3, #16
 8017272:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017274:	1c5a      	adds	r2, r3, #1
 8017276:	647a      	str	r2, [r7, #68]	; 0x44
 8017278:	b2ca      	uxtb	r2, r1
 801727a:	701a      	strb	r2, [r3, #0]
 801727c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801727e:	0a19      	lsrs	r1, r3, #8
 8017280:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017282:	1c5a      	adds	r2, r3, #1
 8017284:	647a      	str	r2, [r7, #68]	; 0x44
 8017286:	b2ca      	uxtb	r2, r1
 8017288:	701a      	strb	r2, [r3, #0]
 801728a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801728c:	1c5a      	adds	r2, r3, #1
 801728e:	647a      	str	r2, [r7, #68]	; 0x44
 8017290:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8017292:	b2d2      	uxtb	r2, r2
 8017294:	701a      	strb	r2, [r3, #0]
		if (!reject_if_disagree) {
 8017296:	e00e      	b.n	80172b6 <ipcp_reqci+0x402>
		}
	    } else if (ciaddr1 == 0 && wo->hisaddr == 0) {
 8017298:	69bb      	ldr	r3, [r7, #24]
 801729a:	2b00      	cmp	r3, #0
 801729c:	d10b      	bne.n	80172b6 <ipcp_reqci+0x402>
 801729e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80172a0:	689b      	ldr	r3, [r3, #8]
 80172a2:	2b00      	cmp	r3, #0
 80172a4:	d107      	bne.n	80172b6 <ipcp_reqci+0x402>
		/*
		 * Don't ACK an address of 0.0.0.0 - reject it instead.
		 */
		orc = CONFREJ;
 80172a6:	2304      	movs	r3, #4
 80172a8:	64bb      	str	r3, [r7, #72]	; 0x48
		wo->req_addr = 0;	/* don't NAK with 0.0.0.0 later */
 80172aa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80172ac:	781a      	ldrb	r2, [r3, #0]
 80172ae:	2104      	movs	r1, #4
 80172b0:	438a      	bics	r2, r1
 80172b2:	701a      	strb	r2, [r3, #0]
		break;
 80172b4:	e12e      	b.n	8017514 <ipcp_reqci+0x660>
	    }
	
	    ho->neg_addr = 1;
 80172b6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80172b8:	781a      	ldrb	r2, [r3, #0]
 80172ba:	2101      	movs	r1, #1
 80172bc:	430a      	orrs	r2, r1
 80172be:	701a      	strb	r2, [r3, #0]
	    ho->hisaddr = ciaddr1;
 80172c0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80172c2:	69ba      	ldr	r2, [r7, #24]
 80172c4:	609a      	str	r2, [r3, #8]
	    break;
 80172c6:	e125      	b.n	8017514 <ipcp_reqci+0x660>

#if LWIP_DNS
	case CI_MS_DNS1:
	case CI_MS_DNS2:
	    /* Microsoft primary or secondary DNS request */
	    d = citype == CI_MS_DNS2;
 80172c8:	2322      	movs	r3, #34	; 0x22
 80172ca:	18fb      	adds	r3, r7, r3
 80172cc:	881b      	ldrh	r3, [r3, #0]
 80172ce:	3b83      	subs	r3, #131	; 0x83
 80172d0:	425a      	negs	r2, r3
 80172d2:	4153      	adcs	r3, r2
 80172d4:	b2db      	uxtb	r3, r3
 80172d6:	61fb      	str	r3, [r7, #28]

	    /* If we do not have a DNS address then we cannot send it */
	    if (ao->dnsaddr[d] == 0 ||
 80172d8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80172da:	69fb      	ldr	r3, [r7, #28]
 80172dc:	3302      	adds	r3, #2
 80172de:	009b      	lsls	r3, r3, #2
 80172e0:	18d3      	adds	r3, r2, r3
 80172e2:	3304      	adds	r3, #4
 80172e4:	681b      	ldr	r3, [r3, #0]
 80172e6:	2b00      	cmp	r3, #0
 80172e8:	d004      	beq.n	80172f4 <ipcp_reqci+0x440>
 80172ea:	2352      	movs	r3, #82	; 0x52
 80172ec:	18fb      	adds	r3, r7, r3
 80172ee:	881b      	ldrh	r3, [r3, #0]
 80172f0:	2b06      	cmp	r3, #6
 80172f2:	d002      	beq.n	80172fa <ipcp_reqci+0x446>
		cilen != CILEN_ADDR) {	/* Check CI length */
		orc = CONFREJ;		/* Reject CI */
 80172f4:	2304      	movs	r3, #4
 80172f6:	64bb      	str	r3, [r7, #72]	; 0x48
		break;
 80172f8:	e10c      	b.n	8017514 <ipcp_reqci+0x660>
	    }
	    GETLONG(tl, p);
 80172fa:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80172fc:	1c5a      	adds	r2, r3, #1
 80172fe:	647a      	str	r2, [r7, #68]	; 0x44
 8017300:	781b      	ldrb	r3, [r3, #0]
 8017302:	021b      	lsls	r3, r3, #8
 8017304:	62bb      	str	r3, [r7, #40]	; 0x28
 8017306:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017308:	1c5a      	adds	r2, r3, #1
 801730a:	647a      	str	r2, [r7, #68]	; 0x44
 801730c:	781b      	ldrb	r3, [r3, #0]
 801730e:	001a      	movs	r2, r3
 8017310:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017312:	4313      	orrs	r3, r2
 8017314:	62bb      	str	r3, [r7, #40]	; 0x28
 8017316:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017318:	021b      	lsls	r3, r3, #8
 801731a:	62bb      	str	r3, [r7, #40]	; 0x28
 801731c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801731e:	1c5a      	adds	r2, r3, #1
 8017320:	647a      	str	r2, [r7, #68]	; 0x44
 8017322:	781b      	ldrb	r3, [r3, #0]
 8017324:	001a      	movs	r2, r3
 8017326:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017328:	4313      	orrs	r3, r2
 801732a:	62bb      	str	r3, [r7, #40]	; 0x28
 801732c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801732e:	021b      	lsls	r3, r3, #8
 8017330:	62bb      	str	r3, [r7, #40]	; 0x28
 8017332:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017334:	1c5a      	adds	r2, r3, #1
 8017336:	647a      	str	r2, [r7, #68]	; 0x44
 8017338:	781b      	ldrb	r3, [r3, #0]
 801733a:	001a      	movs	r2, r3
 801733c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801733e:	4313      	orrs	r3, r2
 8017340:	62bb      	str	r3, [r7, #40]	; 0x28
	    if (lwip_htonl(tl) != ao->dnsaddr[d]) {
 8017342:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017344:	0018      	movs	r0, r3
 8017346:	f7ef fdeb 	bl	8006f20 <lwip_htonl>
 801734a:	0001      	movs	r1, r0
 801734c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801734e:	69fb      	ldr	r3, [r7, #28]
 8017350:	3302      	adds	r3, #2
 8017352:	009b      	lsls	r3, r3, #2
 8017354:	18d3      	adds	r3, r2, r3
 8017356:	3304      	adds	r3, #4
 8017358:	681b      	ldr	r3, [r3, #0]
 801735a:	4299      	cmp	r1, r3
 801735c:	d100      	bne.n	8017360 <ipcp_reqci+0x4ac>
 801735e:	e0d8      	b.n	8017512 <ipcp_reqci+0x65e>
                DECPTR(sizeof(u32_t), p);
 8017360:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017362:	3b04      	subs	r3, #4
 8017364:	647b      	str	r3, [r7, #68]	; 0x44
		tl = lwip_ntohl(ao->dnsaddr[d]);
 8017366:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8017368:	69fb      	ldr	r3, [r7, #28]
 801736a:	3302      	adds	r3, #2
 801736c:	009b      	lsls	r3, r3, #2
 801736e:	18d3      	adds	r3, r2, r3
 8017370:	3304      	adds	r3, #4
 8017372:	681b      	ldr	r3, [r3, #0]
 8017374:	0018      	movs	r0, r3
 8017376:	f7ef fdd3 	bl	8006f20 <lwip_htonl>
 801737a:	0003      	movs	r3, r0
 801737c:	62bb      	str	r3, [r7, #40]	; 0x28
		PUTLONG(tl, p);
 801737e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017380:	0e19      	lsrs	r1, r3, #24
 8017382:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017384:	1c5a      	adds	r2, r3, #1
 8017386:	647a      	str	r2, [r7, #68]	; 0x44
 8017388:	b2ca      	uxtb	r2, r1
 801738a:	701a      	strb	r2, [r3, #0]
 801738c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801738e:	0c19      	lsrs	r1, r3, #16
 8017390:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017392:	1c5a      	adds	r2, r3, #1
 8017394:	647a      	str	r2, [r7, #68]	; 0x44
 8017396:	b2ca      	uxtb	r2, r1
 8017398:	701a      	strb	r2, [r3, #0]
 801739a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801739c:	0a19      	lsrs	r1, r3, #8
 801739e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80173a0:	1c5a      	adds	r2, r3, #1
 80173a2:	647a      	str	r2, [r7, #68]	; 0x44
 80173a4:	b2ca      	uxtb	r2, r1
 80173a6:	701a      	strb	r2, [r3, #0]
 80173a8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80173aa:	1c5a      	adds	r2, r3, #1
 80173ac:	647a      	str	r2, [r7, #68]	; 0x44
 80173ae:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80173b0:	b2d2      	uxtb	r2, r2
 80173b2:	701a      	strb	r2, [r3, #0]
		orc = CONFNAK;
 80173b4:	2303      	movs	r3, #3
 80173b6:	64bb      	str	r3, [r7, #72]	; 0x48
            }
            break;
 80173b8:	e0ab      	b.n	8017512 <ipcp_reqci+0x65e>
            break;
#endif /* UNUSED - WINS */

#if VJ_SUPPORT
	case CI_COMPRESSTYPE:
	    if (!ao->neg_vj ||
 80173ba:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80173bc:	781b      	ldrb	r3, [r3, #0]
 80173be:	2208      	movs	r2, #8
 80173c0:	4013      	ands	r3, r2
 80173c2:	b2db      	uxtb	r3, r3
 80173c4:	2b00      	cmp	r3, #0
 80173c6:	d008      	beq.n	80173da <ipcp_reqci+0x526>
 80173c8:	2252      	movs	r2, #82	; 0x52
 80173ca:	18bb      	adds	r3, r7, r2
 80173cc:	881b      	ldrh	r3, [r3, #0]
 80173ce:	2b06      	cmp	r3, #6
 80173d0:	d006      	beq.n	80173e0 <ipcp_reqci+0x52c>
		(cilen != CILEN_VJ && cilen != CILEN_COMPRESS)) {
 80173d2:	18bb      	adds	r3, r7, r2
 80173d4:	881b      	ldrh	r3, [r3, #0]
 80173d6:	2b04      	cmp	r3, #4
 80173d8:	d002      	beq.n	80173e0 <ipcp_reqci+0x52c>
		orc = CONFREJ;
 80173da:	2304      	movs	r3, #4
 80173dc:	64bb      	str	r3, [r7, #72]	; 0x48
		break;
 80173de:	e099      	b.n	8017514 <ipcp_reqci+0x660>
	    }
	    GETSHORT(cishort, p);
 80173e0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80173e2:	1c5a      	adds	r2, r3, #1
 80173e4:	647a      	str	r2, [r7, #68]	; 0x44
 80173e6:	781b      	ldrb	r3, [r3, #0]
 80173e8:	b29a      	uxth	r2, r3
 80173ea:	2016      	movs	r0, #22
 80173ec:	183b      	adds	r3, r7, r0
 80173ee:	0212      	lsls	r2, r2, #8
 80173f0:	801a      	strh	r2, [r3, #0]
 80173f2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80173f4:	1c5a      	adds	r2, r3, #1
 80173f6:	647a      	str	r2, [r7, #68]	; 0x44
 80173f8:	781b      	ldrb	r3, [r3, #0]
 80173fa:	b299      	uxth	r1, r3
 80173fc:	183b      	adds	r3, r7, r0
 80173fe:	183a      	adds	r2, r7, r0
 8017400:	8812      	ldrh	r2, [r2, #0]
 8017402:	430a      	orrs	r2, r1
 8017404:	801a      	strh	r2, [r3, #0]

	    if (!(cishort == IPCP_VJ_COMP ||
 8017406:	183b      	adds	r3, r7, r0
 8017408:	881b      	ldrh	r3, [r3, #0]
 801740a:	2b2d      	cmp	r3, #45	; 0x2d
 801740c:	d00b      	beq.n	8017426 <ipcp_reqci+0x572>
 801740e:	183b      	adds	r3, r7, r0
 8017410:	881b      	ldrh	r3, [r3, #0]
 8017412:	2b37      	cmp	r3, #55	; 0x37
 8017414:	d104      	bne.n	8017420 <ipcp_reqci+0x56c>
		  (cishort == IPCP_VJ_COMP_OLD && cilen == CILEN_COMPRESS))) {
 8017416:	2352      	movs	r3, #82	; 0x52
 8017418:	18fb      	adds	r3, r7, r3
 801741a:	881b      	ldrh	r3, [r3, #0]
 801741c:	2b04      	cmp	r3, #4
 801741e:	d002      	beq.n	8017426 <ipcp_reqci+0x572>
		orc = CONFREJ;
 8017420:	2304      	movs	r3, #4
 8017422:	64bb      	str	r3, [r7, #72]	; 0x48
		break;
 8017424:	e076      	b.n	8017514 <ipcp_reqci+0x660>
	    }

	    ho->neg_vj = 1;
 8017426:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017428:	781a      	ldrb	r2, [r3, #0]
 801742a:	2108      	movs	r1, #8
 801742c:	430a      	orrs	r2, r1
 801742e:	701a      	strb	r2, [r3, #0]
	    ho->vj_protocol = cishort;
 8017430:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017432:	2216      	movs	r2, #22
 8017434:	18ba      	adds	r2, r7, r2
 8017436:	8812      	ldrh	r2, [r2, #0]
 8017438:	829a      	strh	r2, [r3, #20]
	    if (cilen == CILEN_VJ) {
 801743a:	2352      	movs	r3, #82	; 0x52
 801743c:	18fb      	adds	r3, r7, r3
 801743e:	881b      	ldrh	r3, [r3, #0]
 8017440:	2b06      	cmp	r3, #6
 8017442:	d155      	bne.n	80174f0 <ipcp_reqci+0x63c>
		GETCHAR(maxslotindex, p);
 8017444:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017446:	1c5a      	adds	r2, r3, #1
 8017448:	647a      	str	r2, [r7, #68]	; 0x44
 801744a:	2115      	movs	r1, #21
 801744c:	187a      	adds	r2, r7, r1
 801744e:	781b      	ldrb	r3, [r3, #0]
 8017450:	7013      	strb	r3, [r2, #0]
		if (maxslotindex > ao->maxslotindex) { 
 8017452:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017454:	7d9b      	ldrb	r3, [r3, #22]
 8017456:	187a      	adds	r2, r7, r1
 8017458:	7812      	ldrb	r2, [r2, #0]
 801745a:	429a      	cmp	r2, r3
 801745c:	d90d      	bls.n	801747a <ipcp_reqci+0x5c6>
		    orc = CONFNAK;
 801745e:	2303      	movs	r3, #3
 8017460:	64bb      	str	r3, [r7, #72]	; 0x48
		    if (!reject_if_disagree){
 8017462:	683b      	ldr	r3, [r7, #0]
 8017464:	2b00      	cmp	r3, #0
 8017466:	d108      	bne.n	801747a <ipcp_reqci+0x5c6>
			DECPTR(1, p);
 8017468:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801746a:	3b01      	subs	r3, #1
 801746c:	647b      	str	r3, [r7, #68]	; 0x44
			PUTCHAR(ao->maxslotindex, p);
 801746e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017470:	1c5a      	adds	r2, r3, #1
 8017472:	647a      	str	r2, [r7, #68]	; 0x44
 8017474:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8017476:	7d92      	ldrb	r2, [r2, #22]
 8017478:	701a      	strb	r2, [r3, #0]
		    }
		}
		GETCHAR(cflag, p);
 801747a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801747c:	1c5a      	adds	r2, r3, #1
 801747e:	647a      	str	r2, [r7, #68]	; 0x44
 8017480:	2114      	movs	r1, #20
 8017482:	187a      	adds	r2, r7, r1
 8017484:	781b      	ldrb	r3, [r3, #0]
 8017486:	7013      	strb	r3, [r2, #0]
		if (cflag && !ao->cflag) {
 8017488:	187b      	adds	r3, r7, r1
 801748a:	781b      	ldrb	r3, [r3, #0]
 801748c:	2b00      	cmp	r3, #0
 801748e:	d018      	beq.n	80174c2 <ipcp_reqci+0x60e>
 8017490:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017492:	781b      	ldrb	r3, [r3, #0]
 8017494:	2220      	movs	r2, #32
 8017496:	4013      	ands	r3, r2
 8017498:	b2db      	uxtb	r3, r3
 801749a:	2b00      	cmp	r3, #0
 801749c:	d111      	bne.n	80174c2 <ipcp_reqci+0x60e>
		    orc = CONFNAK;
 801749e:	2303      	movs	r3, #3
 80174a0:	64bb      	str	r3, [r7, #72]	; 0x48
		    if (!reject_if_disagree){
 80174a2:	683b      	ldr	r3, [r7, #0]
 80174a4:	2b00      	cmp	r3, #0
 80174a6:	d10c      	bne.n	80174c2 <ipcp_reqci+0x60e>
			DECPTR(1, p);
 80174a8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80174aa:	3b01      	subs	r3, #1
 80174ac:	647b      	str	r3, [r7, #68]	; 0x44
			PUTCHAR(wo->cflag, p);
 80174ae:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80174b0:	781b      	ldrb	r3, [r3, #0]
 80174b2:	069b      	lsls	r3, r3, #26
 80174b4:	0fdb      	lsrs	r3, r3, #31
 80174b6:	b2d9      	uxtb	r1, r3
 80174b8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80174ba:	1c5a      	adds	r2, r3, #1
 80174bc:	647a      	str	r2, [r7, #68]	; 0x44
 80174be:	000a      	movs	r2, r1
 80174c0:	701a      	strb	r2, [r3, #0]
		    }
		}
		ho->maxslotindex = maxslotindex;
 80174c2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80174c4:	2215      	movs	r2, #21
 80174c6:	18ba      	adds	r2, r7, r2
 80174c8:	7812      	ldrb	r2, [r2, #0]
 80174ca:	759a      	strb	r2, [r3, #22]
		ho->cflag = cflag;
 80174cc:	2314      	movs	r3, #20
 80174ce:	18fb      	adds	r3, r7, r3
 80174d0:	781b      	ldrb	r3, [r3, #0]
 80174d2:	2201      	movs	r2, #1
 80174d4:	4013      	ands	r3, r2
 80174d6:	b2da      	uxtb	r2, r3
 80174d8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80174da:	2101      	movs	r1, #1
 80174dc:	400a      	ands	r2, r1
 80174de:	0150      	lsls	r0, r2, #5
 80174e0:	781a      	ldrb	r2, [r3, #0]
 80174e2:	2120      	movs	r1, #32
 80174e4:	438a      	bics	r2, r1
 80174e6:	1c11      	adds	r1, r2, #0
 80174e8:	1c02      	adds	r2, r0, #0
 80174ea:	430a      	orrs	r2, r1
 80174ec:	701a      	strb	r2, [r3, #0]
	    } else {
		ho->old_vj = 1;
		ho->maxslotindex = MAX_STATES - 1;
		ho->cflag = 1;
	    }
	    break;
 80174ee:	e011      	b.n	8017514 <ipcp_reqci+0x660>
		ho->old_vj = 1;
 80174f0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80174f2:	781a      	ldrb	r2, [r3, #0]
 80174f4:	2110      	movs	r1, #16
 80174f6:	430a      	orrs	r2, r1
 80174f8:	701a      	strb	r2, [r3, #0]
		ho->maxslotindex = MAX_STATES - 1;
 80174fa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80174fc:	220f      	movs	r2, #15
 80174fe:	759a      	strb	r2, [r3, #22]
		ho->cflag = 1;
 8017500:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017502:	781a      	ldrb	r2, [r3, #0]
 8017504:	2120      	movs	r1, #32
 8017506:	430a      	orrs	r2, r1
 8017508:	701a      	strb	r2, [r3, #0]
	    break;
 801750a:	e003      	b.n	8017514 <ipcp_reqci+0x660>
#endif /* VJ_SUPPORT */

	default:
	    orc = CONFREJ;
 801750c:	2304      	movs	r3, #4
 801750e:	64bb      	str	r3, [r7, #72]	; 0x48
	    break;
 8017510:	e000      	b.n	8017514 <ipcp_reqci+0x660>
            break;
 8017512:	46c0      	nop			; (mov r8, r8)
	}
endswitch:
	if (orc == CONFACK &&		/* Good CI */
 8017514:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8017516:	2b02      	cmp	r3, #2
 8017518:	d103      	bne.n	8017522 <ipcp_reqci+0x66e>
 801751a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801751c:	2b02      	cmp	r3, #2
 801751e:	d000      	beq.n	8017522 <ipcp_reqci+0x66e>
	    rc != CONFACK)		/*  but prior CI wasnt? */
	    continue;			/* Don't send this one */
 8017520:	e02f      	b.n	8017582 <ipcp_reqci+0x6ce>

	if (orc == CONFNAK) {		/* Nak this CI? */
 8017522:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8017524:	2b03      	cmp	r3, #3
 8017526:	d110      	bne.n	801754a <ipcp_reqci+0x696>
	    if (reject_if_disagree)	/* Getting fed up with sending NAKs? */
 8017528:	683b      	ldr	r3, [r7, #0]
 801752a:	2b00      	cmp	r3, #0
 801752c:	d002      	beq.n	8017534 <ipcp_reqci+0x680>
		orc = CONFREJ;		/* Get tough if so */
 801752e:	2304      	movs	r3, #4
 8017530:	64bb      	str	r3, [r7, #72]	; 0x48
 8017532:	e00a      	b.n	801754a <ipcp_reqci+0x696>
	    else {
		if (rc == CONFREJ)	/* Rejecting prior CI? */
 8017534:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8017536:	2b04      	cmp	r3, #4
 8017538:	d100      	bne.n	801753c <ipcp_reqci+0x688>
		    continue;		/* Don't send this one */
 801753a:	e022      	b.n	8017582 <ipcp_reqci+0x6ce>
		if (rc == CONFACK) {	/* Ack'd all prior CIs? */
 801753c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801753e:	2b02      	cmp	r3, #2
 8017540:	d103      	bne.n	801754a <ipcp_reqci+0x696>
		    rc = CONFNAK;	/* Not anymore... */
 8017542:	2303      	movs	r3, #3
 8017544:	64fb      	str	r3, [r7, #76]	; 0x4c
		    ucp = inp;		/* Backup */
 8017546:	68bb      	ldr	r3, [r7, #8]
 8017548:	643b      	str	r3, [r7, #64]	; 0x40
		}
	    }
	}

	if (orc == CONFREJ &&		/* Reject this CI */
 801754a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801754c:	2b04      	cmp	r3, #4
 801754e:	d106      	bne.n	801755e <ipcp_reqci+0x6aa>
 8017550:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8017552:	2b04      	cmp	r3, #4
 8017554:	d003      	beq.n	801755e <ipcp_reqci+0x6aa>
	    rc != CONFREJ) {		/*  but no prior ones? */
	    rc = CONFREJ;
 8017556:	2304      	movs	r3, #4
 8017558:	64fb      	str	r3, [r7, #76]	; 0x4c
	    ucp = inp;			/* Backup */
 801755a:	68bb      	ldr	r3, [r7, #8]
 801755c:	643b      	str	r3, [r7, #64]	; 0x40
	}

	/* Need to move CI? */
	if (ucp != cip)
 801755e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8017560:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017562:	429a      	cmp	r2, r3
 8017564:	d007      	beq.n	8017576 <ipcp_reqci+0x6c2>
	    MEMCPY(ucp, cip, cilen);	/* Move it */
 8017566:	2352      	movs	r3, #82	; 0x52
 8017568:	18fb      	adds	r3, r7, r3
 801756a:	881a      	ldrh	r2, [r3, #0]
 801756c:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801756e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8017570:	0018      	movs	r0, r3
 8017572:	f005 fcab 	bl	801cecc <memcpy>

	/* Update output pointer */
	INCPTR(cilen, ucp);
 8017576:	2352      	movs	r3, #82	; 0x52
 8017578:	18fb      	adds	r3, r7, r3
 801757a:	881b      	ldrh	r3, [r3, #0]
 801757c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801757e:	18d3      	adds	r3, r2, r3
 8017580:	643b      	str	r3, [r7, #64]	; 0x40
    while (l) {
 8017582:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8017584:	2b00      	cmp	r3, #0
 8017586:	d000      	beq.n	801758a <ipcp_reqci+0x6d6>
 8017588:	e4bd      	b.n	8016f06 <ipcp_reqci+0x52>
     * their address, and they didn't send their address, then we
     * send a NAK with a CI_ADDR option appended.  We assume the
     * input buffer is long enough that we can append the extra
     * option safely.
     */
    if (rc != CONFREJ && !ho->neg_addr && !ho->old_addrs &&
 801758a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801758c:	2b04      	cmp	r3, #4
 801758e:	d056      	beq.n	801763e <ipcp_reqci+0x78a>
 8017590:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017592:	781b      	ldrb	r3, [r3, #0]
 8017594:	2201      	movs	r2, #1
 8017596:	4013      	ands	r3, r2
 8017598:	b2db      	uxtb	r3, r3
 801759a:	2b00      	cmp	r3, #0
 801759c:	d14f      	bne.n	801763e <ipcp_reqci+0x78a>
 801759e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80175a0:	781b      	ldrb	r3, [r3, #0]
 80175a2:	2202      	movs	r2, #2
 80175a4:	4013      	ands	r3, r2
 80175a6:	b2db      	uxtb	r3, r3
 80175a8:	2b00      	cmp	r3, #0
 80175aa:	d148      	bne.n	801763e <ipcp_reqci+0x78a>
 80175ac:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80175ae:	781b      	ldrb	r3, [r3, #0]
 80175b0:	2204      	movs	r2, #4
 80175b2:	4013      	ands	r3, r2
 80175b4:	b2db      	uxtb	r3, r3
 80175b6:	2b00      	cmp	r3, #0
 80175b8:	d041      	beq.n	801763e <ipcp_reqci+0x78a>
	wo->req_addr && !reject_if_disagree && !pcb->settings.noremoteip) {
 80175ba:	683b      	ldr	r3, [r7, #0]
 80175bc:	2b00      	cmp	r3, #0
 80175be:	d13e      	bne.n	801763e <ipcp_reqci+0x78a>
 80175c0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80175c2:	781b      	ldrb	r3, [r3, #0]
 80175c4:	2204      	movs	r2, #4
 80175c6:	4013      	ands	r3, r2
 80175c8:	b2db      	uxtb	r3, r3
 80175ca:	2b00      	cmp	r3, #0
 80175cc:	d137      	bne.n	801763e <ipcp_reqci+0x78a>
	if (rc == CONFACK) {
 80175ce:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80175d0:	2b02      	cmp	r3, #2
 80175d2:	d108      	bne.n	80175e6 <ipcp_reqci+0x732>
	    rc = CONFNAK;
 80175d4:	2303      	movs	r3, #3
 80175d6:	64fb      	str	r3, [r7, #76]	; 0x4c
	    ucp = inp;			/* reset pointer */
 80175d8:	68bb      	ldr	r3, [r7, #8]
 80175da:	643b      	str	r3, [r7, #64]	; 0x40
	    wo->req_addr = 0;		/* don't ask again */
 80175dc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80175de:	781a      	ldrb	r2, [r3, #0]
 80175e0:	2104      	movs	r1, #4
 80175e2:	438a      	bics	r2, r1
 80175e4:	701a      	strb	r2, [r3, #0]
	}
	PUTCHAR(CI_ADDR, ucp);
 80175e6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80175e8:	1c5a      	adds	r2, r3, #1
 80175ea:	643a      	str	r2, [r7, #64]	; 0x40
 80175ec:	2203      	movs	r2, #3
 80175ee:	701a      	strb	r2, [r3, #0]
	PUTCHAR(CILEN_ADDR, ucp);
 80175f0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80175f2:	1c5a      	adds	r2, r3, #1
 80175f4:	643a      	str	r2, [r7, #64]	; 0x40
 80175f6:	2206      	movs	r2, #6
 80175f8:	701a      	strb	r2, [r3, #0]
	tl = lwip_ntohl(wo->hisaddr);
 80175fa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80175fc:	689b      	ldr	r3, [r3, #8]
 80175fe:	0018      	movs	r0, r3
 8017600:	f7ef fc8e 	bl	8006f20 <lwip_htonl>
 8017604:	0003      	movs	r3, r0
 8017606:	62bb      	str	r3, [r7, #40]	; 0x28
	PUTLONG(tl, ucp);
 8017608:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801760a:	0e19      	lsrs	r1, r3, #24
 801760c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801760e:	1c5a      	adds	r2, r3, #1
 8017610:	643a      	str	r2, [r7, #64]	; 0x40
 8017612:	b2ca      	uxtb	r2, r1
 8017614:	701a      	strb	r2, [r3, #0]
 8017616:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017618:	0c19      	lsrs	r1, r3, #16
 801761a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801761c:	1c5a      	adds	r2, r3, #1
 801761e:	643a      	str	r2, [r7, #64]	; 0x40
 8017620:	b2ca      	uxtb	r2, r1
 8017622:	701a      	strb	r2, [r3, #0]
 8017624:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017626:	0a19      	lsrs	r1, r3, #8
 8017628:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801762a:	1c5a      	adds	r2, r3, #1
 801762c:	643a      	str	r2, [r7, #64]	; 0x40
 801762e:	b2ca      	uxtb	r2, r1
 8017630:	701a      	strb	r2, [r3, #0]
 8017632:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8017634:	1c5a      	adds	r2, r3, #1
 8017636:	643a      	str	r2, [r7, #64]	; 0x40
 8017638:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801763a:	b2d2      	uxtb	r2, r2
 801763c:	701a      	strb	r2, [r3, #0]
    }

    *len = ucp - inp;			/* Compute output length */
 801763e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8017640:	68bb      	ldr	r3, [r7, #8]
 8017642:	1ad2      	subs	r2, r2, r3
 8017644:	687b      	ldr	r3, [r7, #4]
 8017646:	601a      	str	r2, [r3, #0]
    IPCPDEBUG(("ipcp: returning Configure-%s", CODENAME(rc)));
    return (rc);			/* Return final code */
 8017648:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
}
 801764a:	0018      	movs	r0, r3
 801764c:	46bd      	mov	sp, r7
 801764e:	b016      	add	sp, #88	; 0x58
 8017650:	bd80      	pop	{r7, pc}
 8017652:	46c0      	nop			; (mov r8, r8)

08017654 <ipcp_up>:
/*
 * ipcp_up - IPCP has come UP.
 *
 * Configure the IP network interface appropriately and bring it up.
 */
static void ipcp_up(fsm *f) {
 8017654:	b580      	push	{r7, lr}
 8017656:	b088      	sub	sp, #32
 8017658:	af00      	add	r7, sp, #0
 801765a:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 801765c:	687b      	ldr	r3, [r7, #4]
 801765e:	681b      	ldr	r3, [r3, #0]
 8017660:	61fb      	str	r3, [r7, #28]
    u32_t mask;
    ipcp_options *ho = &pcb->ipcp_hisoptions;
 8017662:	69fb      	ldr	r3, [r7, #28]
 8017664:	4a9e      	ldr	r2, [pc, #632]	; (80178e0 <ipcp_up+0x28c>)
 8017666:	4694      	mov	ip, r2
 8017668:	4463      	add	r3, ip
 801766a:	61bb      	str	r3, [r7, #24]
    ipcp_options *go = &pcb->ipcp_gotoptions;
 801766c:	69fb      	ldr	r3, [r7, #28]
 801766e:	4a9d      	ldr	r2, [pc, #628]	; (80178e4 <ipcp_up+0x290>)
 8017670:	4694      	mov	ip, r2
 8017672:	4463      	add	r3, ip
 8017674:	617b      	str	r3, [r7, #20]
    ipcp_options *wo = &pcb->ipcp_wantoptions;
 8017676:	69fb      	ldr	r3, [r7, #28]
 8017678:	4a9b      	ldr	r2, [pc, #620]	; (80178e8 <ipcp_up+0x294>)
 801767a:	4694      	mov	ip, r2
 801767c:	4463      	add	r3, ip
 801767e:	613b      	str	r3, [r7, #16]
    IPCPDEBUG(("ipcp: up"));

    /*
     * We must have a non-zero IP address for both ends of the link.
     */
    if (!ho->neg_addr && !ho->old_addrs)
 8017680:	69bb      	ldr	r3, [r7, #24]
 8017682:	781b      	ldrb	r3, [r3, #0]
 8017684:	2201      	movs	r2, #1
 8017686:	4013      	ands	r3, r2
 8017688:	b2db      	uxtb	r3, r3
 801768a:	2b00      	cmp	r3, #0
 801768c:	d10a      	bne.n	80176a4 <ipcp_up+0x50>
 801768e:	69bb      	ldr	r3, [r7, #24]
 8017690:	781b      	ldrb	r3, [r3, #0]
 8017692:	2202      	movs	r2, #2
 8017694:	4013      	ands	r3, r2
 8017696:	b2db      	uxtb	r3, r3
 8017698:	2b00      	cmp	r3, #0
 801769a:	d103      	bne.n	80176a4 <ipcp_up+0x50>
	ho->hisaddr = wo->hisaddr;
 801769c:	693b      	ldr	r3, [r7, #16]
 801769e:	689a      	ldr	r2, [r3, #8]
 80176a0:	69bb      	ldr	r3, [r7, #24]
 80176a2:	609a      	str	r2, [r3, #8]

    if (!(go->neg_addr || go->old_addrs) && (wo->neg_addr || wo->old_addrs)
 80176a4:	697b      	ldr	r3, [r7, #20]
 80176a6:	781b      	ldrb	r3, [r3, #0]
 80176a8:	2201      	movs	r2, #1
 80176aa:	4013      	ands	r3, r2
 80176ac:	b2db      	uxtb	r3, r3
 80176ae:	2b00      	cmp	r3, #0
 80176b0:	d124      	bne.n	80176fc <ipcp_up+0xa8>
 80176b2:	697b      	ldr	r3, [r7, #20]
 80176b4:	781b      	ldrb	r3, [r3, #0]
 80176b6:	2202      	movs	r2, #2
 80176b8:	4013      	ands	r3, r2
 80176ba:	b2db      	uxtb	r3, r3
 80176bc:	2b00      	cmp	r3, #0
 80176be:	d11d      	bne.n	80176fc <ipcp_up+0xa8>
 80176c0:	693b      	ldr	r3, [r7, #16]
 80176c2:	781b      	ldrb	r3, [r3, #0]
 80176c4:	2201      	movs	r2, #1
 80176c6:	4013      	ands	r3, r2
 80176c8:	b2db      	uxtb	r3, r3
 80176ca:	2b00      	cmp	r3, #0
 80176cc:	d106      	bne.n	80176dc <ipcp_up+0x88>
 80176ce:	693b      	ldr	r3, [r7, #16]
 80176d0:	781b      	ldrb	r3, [r3, #0]
 80176d2:	2202      	movs	r2, #2
 80176d4:	4013      	ands	r3, r2
 80176d6:	b2db      	uxtb	r3, r3
 80176d8:	2b00      	cmp	r3, #0
 80176da:	d00f      	beq.n	80176fc <ipcp_up+0xa8>
	&& wo->ouraddr != 0) {
 80176dc:	693b      	ldr	r3, [r7, #16]
 80176de:	685b      	ldr	r3, [r3, #4]
 80176e0:	2b00      	cmp	r3, #0
 80176e2:	d00b      	beq.n	80176fc <ipcp_up+0xa8>
	ppp_error("Peer refused to agree to our IP address");
 80176e4:	4b81      	ldr	r3, [pc, #516]	; (80178ec <ipcp_up+0x298>)
 80176e6:	0018      	movs	r0, r3
 80176e8:	f004 f891 	bl	801b80e <ppp_error>
	ipcp_close(f->pcb, "Refused our IP address");
 80176ec:	687b      	ldr	r3, [r7, #4]
 80176ee:	681b      	ldr	r3, [r3, #0]
 80176f0:	4a7f      	ldr	r2, [pc, #508]	; (80178f0 <ipcp_up+0x29c>)
 80176f2:	0011      	movs	r1, r2
 80176f4:	0018      	movs	r0, r3
 80176f6:	f7fd ff4d 	bl	8015594 <ipcp_close>
	return;
 80176fa:	e0ed      	b.n	80178d8 <ipcp_up+0x284>
    }
    if (go->ouraddr == 0) {
 80176fc:	697b      	ldr	r3, [r7, #20]
 80176fe:	685b      	ldr	r3, [r3, #4]
 8017700:	2b00      	cmp	r3, #0
 8017702:	d10b      	bne.n	801771c <ipcp_up+0xc8>
	ppp_error("Could not determine local IP address");
 8017704:	4b7b      	ldr	r3, [pc, #492]	; (80178f4 <ipcp_up+0x2a0>)
 8017706:	0018      	movs	r0, r3
 8017708:	f004 f881 	bl	801b80e <ppp_error>
	ipcp_close(f->pcb, "Could not determine local IP address");
 801770c:	687b      	ldr	r3, [r7, #4]
 801770e:	681b      	ldr	r3, [r3, #0]
 8017710:	4a78      	ldr	r2, [pc, #480]	; (80178f4 <ipcp_up+0x2a0>)
 8017712:	0011      	movs	r1, r2
 8017714:	0018      	movs	r0, r3
 8017716:	f7fd ff3d 	bl	8015594 <ipcp_close>
	return;
 801771a:	e0dd      	b.n	80178d8 <ipcp_up+0x284>
    }
    if (ho->hisaddr == 0 && !pcb->settings.noremoteip) {
 801771c:	69bb      	ldr	r3, [r7, #24]
 801771e:	689b      	ldr	r3, [r3, #8]
 8017720:	2b00      	cmp	r3, #0
 8017722:	d114      	bne.n	801774e <ipcp_up+0xfa>
 8017724:	69fb      	ldr	r3, [r7, #28]
 8017726:	781b      	ldrb	r3, [r3, #0]
 8017728:	2204      	movs	r2, #4
 801772a:	4013      	ands	r3, r2
 801772c:	b2db      	uxtb	r3, r3
 801772e:	2b00      	cmp	r3, #0
 8017730:	d10d      	bne.n	801774e <ipcp_up+0xfa>
	ho->hisaddr = lwip_htonl(0x0a404040);
 8017732:	4b71      	ldr	r3, [pc, #452]	; (80178f8 <ipcp_up+0x2a4>)
 8017734:	0018      	movs	r0, r3
 8017736:	f7ef fbf3 	bl	8006f20 <lwip_htonl>
 801773a:	0002      	movs	r2, r0
 801773c:	69bb      	ldr	r3, [r7, #24]
 801773e:	609a      	str	r2, [r3, #8]
	ppp_warn("Could not determine remote IP address: defaulting to %I",
 8017740:	69bb      	ldr	r3, [r7, #24]
 8017742:	689a      	ldr	r2, [r3, #8]
 8017744:	4b6d      	ldr	r3, [pc, #436]	; (80178fc <ipcp_up+0x2a8>)
 8017746:	0011      	movs	r1, r2
 8017748:	0018      	movs	r0, r3
 801774a:	f004 f874 	bl	801b836 <ppp_warn>
    if (ho->hisaddr != 0)
	script_setenv("IPREMOTE", ip_ntoa(ho->hisaddr), 1);
#endif /* UNUSED */

#if LWIP_DNS
    if (!go->req_dns1)
 801774e:	697b      	ldr	r3, [r7, #20]
 8017750:	785b      	ldrb	r3, [r3, #1]
 8017752:	2201      	movs	r2, #1
 8017754:	4013      	ands	r3, r2
 8017756:	b2db      	uxtb	r3, r3
 8017758:	2b00      	cmp	r3, #0
 801775a:	d102      	bne.n	8017762 <ipcp_up+0x10e>
	    go->dnsaddr[0] = 0;
 801775c:	697b      	ldr	r3, [r7, #20]
 801775e:	2200      	movs	r2, #0
 8017760:	60da      	str	r2, [r3, #12]
    if (!go->req_dns2)
 8017762:	697b      	ldr	r3, [r7, #20]
 8017764:	785b      	ldrb	r3, [r3, #1]
 8017766:	2202      	movs	r2, #2
 8017768:	4013      	ands	r3, r2
 801776a:	b2db      	uxtb	r3, r3
 801776c:	2b00      	cmp	r3, #0
 801776e:	d102      	bne.n	8017776 <ipcp_up+0x122>
	    go->dnsaddr[1] = 0;
 8017770:	697b      	ldr	r3, [r7, #20]
 8017772:	2200      	movs	r2, #0
 8017774:	611a      	str	r2, [r3, #16]
    if (go->dnsaddr[0])
	script_setenv("DNS1", ip_ntoa(go->dnsaddr[0]), 0);
    if (go->dnsaddr[1])
	script_setenv("DNS2", ip_ntoa(go->dnsaddr[1]), 0);
#endif /* UNUSED */
    if (pcb->settings.usepeerdns && (go->dnsaddr[0] || go->dnsaddr[1])) {
 8017776:	69fb      	ldr	r3, [r7, #28]
 8017778:	781b      	ldrb	r3, [r3, #0]
 801777a:	2201      	movs	r2, #1
 801777c:	4013      	ands	r3, r2
 801777e:	b2db      	uxtb	r3, r3
 8017780:	2b00      	cmp	r3, #0
 8017782:	d00f      	beq.n	80177a4 <ipcp_up+0x150>
 8017784:	697b      	ldr	r3, [r7, #20]
 8017786:	68db      	ldr	r3, [r3, #12]
 8017788:	2b00      	cmp	r3, #0
 801778a:	d103      	bne.n	8017794 <ipcp_up+0x140>
 801778c:	697b      	ldr	r3, [r7, #20]
 801778e:	691b      	ldr	r3, [r3, #16]
 8017790:	2b00      	cmp	r3, #0
 8017792:	d007      	beq.n	80177a4 <ipcp_up+0x150>
	sdns(pcb, go->dnsaddr[0], go->dnsaddr[1]);
 8017794:	697b      	ldr	r3, [r7, #20]
 8017796:	68d9      	ldr	r1, [r3, #12]
 8017798:	697b      	ldr	r3, [r7, #20]
 801779a:	691a      	ldr	r2, [r3, #16]
 801779c:	69fb      	ldr	r3, [r7, #28]
 801779e:	0018      	movs	r0, r3
 80177a0:	f002 fe12 	bl	801a3c8 <sdns>
#endif /* LWIP_DNS */

    /*
     * Check that the peer is allowed to use the IP address it wants.
     */
    if (ho->hisaddr != 0) {
 80177a4:	69bb      	ldr	r3, [r7, #24]
 80177a6:	689b      	ldr	r3, [r3, #8]
 80177a8:	2b00      	cmp	r3, #0
 80177aa:	d026      	beq.n	80177fa <ipcp_up+0x1a6>
	u32_t addr = lwip_ntohl(ho->hisaddr);
 80177ac:	69bb      	ldr	r3, [r7, #24]
 80177ae:	689b      	ldr	r3, [r3, #8]
 80177b0:	0018      	movs	r0, r3
 80177b2:	f7ef fbb5 	bl	8006f20 <lwip_htonl>
 80177b6:	0003      	movs	r3, r0
 80177b8:	60fb      	str	r3, [r7, #12]
	if ((addr >> IP_CLASSA_NSHIFT) == IP_LOOPBACKNET
 80177ba:	68fb      	ldr	r3, [r7, #12]
 80177bc:	0e1b      	lsrs	r3, r3, #24
 80177be:	2b7f      	cmp	r3, #127	; 0x7f
 80177c0:	d00d      	beq.n	80177de <ipcp_up+0x18a>
	    || IP_MULTICAST(addr) || IP_BADCLASS(addr)
 80177c2:	68fb      	ldr	r3, [r7, #12]
 80177c4:	0f1b      	lsrs	r3, r3, #28
 80177c6:	071a      	lsls	r2, r3, #28
 80177c8:	23e0      	movs	r3, #224	; 0xe0
 80177ca:	061b      	lsls	r3, r3, #24
 80177cc:	429a      	cmp	r2, r3
 80177ce:	d006      	beq.n	80177de <ipcp_up+0x18a>
 80177d0:	68fb      	ldr	r3, [r7, #12]
 80177d2:	0f1b      	lsrs	r3, r3, #28
 80177d4:	071a      	lsls	r2, r3, #28
 80177d6:	23f0      	movs	r3, #240	; 0xf0
 80177d8:	061b      	lsls	r3, r3, #24
 80177da:	429a      	cmp	r2, r3
 80177dc:	d10d      	bne.n	80177fa <ipcp_up+0x1a6>
	     */
#if PPP_SERVER && PPP_AUTH_SUPPORT
	    || (pcb->settings.auth_required && wo->hisaddr != ho->hisaddr)
#endif /* PPP_SERVER && PPP_AUTH_SUPPORT */
	    ) {
		ppp_error("Peer is not authorized to use remote address %I", ho->hisaddr);
 80177de:	69bb      	ldr	r3, [r7, #24]
 80177e0:	689a      	ldr	r2, [r3, #8]
 80177e2:	4b47      	ldr	r3, [pc, #284]	; (8017900 <ipcp_up+0x2ac>)
 80177e4:	0011      	movs	r1, r2
 80177e6:	0018      	movs	r0, r3
 80177e8:	f004 f811 	bl	801b80e <ppp_error>
		ipcp_close(pcb, "Unauthorized remote IP address");
 80177ec:	4a45      	ldr	r2, [pc, #276]	; (8017904 <ipcp_up+0x2b0>)
 80177ee:	69fb      	ldr	r3, [r7, #28]
 80177f0:	0011      	movs	r1, r2
 80177f2:	0018      	movs	r0, r3
 80177f4:	f7fd fece 	bl	8015594 <ipcp_close>
		return;
 80177f8:	e06e      	b.n	80178d8 <ipcp_up+0x284>
    }
#endif /* Unused */

#if VJ_SUPPORT
    /* set tcp compression */
    sifvjcomp(pcb, ho->neg_vj, ho->cflag, ho->maxslotindex);
 80177fa:	69bb      	ldr	r3, [r7, #24]
 80177fc:	781b      	ldrb	r3, [r3, #0]
 80177fe:	071b      	lsls	r3, r3, #28
 8017800:	0fdb      	lsrs	r3, r3, #31
 8017802:	b2db      	uxtb	r3, r3
 8017804:	0019      	movs	r1, r3
 8017806:	69bb      	ldr	r3, [r7, #24]
 8017808:	781b      	ldrb	r3, [r3, #0]
 801780a:	069b      	lsls	r3, r3, #26
 801780c:	0fdb      	lsrs	r3, r3, #31
 801780e:	b2db      	uxtb	r3, r3
 8017810:	001a      	movs	r2, r3
 8017812:	69bb      	ldr	r3, [r7, #24]
 8017814:	7d9b      	ldrb	r3, [r3, #22]
 8017816:	69f8      	ldr	r0, [r7, #28]
 8017818:	f002 fe20 	bl	801a45c <sifvjcomp>
#endif /* DEMAND_SUPPORT */
    {
	/*
	 * Set IP addresses and (if specified) netmask.
	 */
	mask = get_mask(go->ouraddr);
 801781c:	697b      	ldr	r3, [r7, #20]
 801781e:	685b      	ldr	r3, [r3, #4]
 8017820:	0018      	movs	r0, r3
 8017822:	f002 fe79 	bl	801a518 <get_mask>
 8017826:	0003      	movs	r3, r0
 8017828:	60bb      	str	r3, [r7, #8]

#if !(defined(SVR4) && (defined(SNI) || defined(__USLC__)))
	if (!sifaddr(pcb, go->ouraddr, ho->hisaddr, mask)) {
 801782a:	697b      	ldr	r3, [r7, #20]
 801782c:	6859      	ldr	r1, [r3, #4]
 801782e:	69bb      	ldr	r3, [r7, #24]
 8017830:	689a      	ldr	r2, [r3, #8]
 8017832:	68bb      	ldr	r3, [r7, #8]
 8017834:	69f8      	ldr	r0, [r7, #28]
 8017836:	f002 fd95 	bl	801a364 <sifaddr>
 801783a:	1e03      	subs	r3, r0, #0
 801783c:	d107      	bne.n	801784e <ipcp_up+0x1fa>
#if PPP_DEBUG
	    ppp_warn("Interface configuration failed");
#endif /* PPP_DEBUG */
	    ipcp_close(f->pcb, "Interface configuration failed");
 801783e:	687b      	ldr	r3, [r7, #4]
 8017840:	681b      	ldr	r3, [r3, #0]
 8017842:	4a31      	ldr	r2, [pc, #196]	; (8017908 <ipcp_up+0x2b4>)
 8017844:	0011      	movs	r1, r2
 8017846:	0018      	movs	r0, r3
 8017848:	f7fd fea4 	bl	8015594 <ipcp_close>
	    return;
 801784c:	e044      	b.n	80178d8 <ipcp_up+0x284>
	}
#endif

	/* bring the interface up for IP */
	if (!sifup(pcb)) {
 801784e:	69fb      	ldr	r3, [r7, #28]
 8017850:	0018      	movs	r0, r3
 8017852:	f002 fe2a 	bl	801a4aa <sifup>
 8017856:	1e03      	subs	r3, r0, #0
 8017858:	d107      	bne.n	801786a <ipcp_up+0x216>
#if PPP_DEBUG
	    ppp_warn("Interface failed to come up");
#endif /* PPP_DEBUG */
	    ipcp_close(f->pcb, "Interface configuration failed");
 801785a:	687b      	ldr	r3, [r7, #4]
 801785c:	681b      	ldr	r3, [r3, #0]
 801785e:	4a2a      	ldr	r2, [pc, #168]	; (8017908 <ipcp_up+0x2b4>)
 8017860:	0011      	movs	r1, r2
 8017862:	0018      	movs	r0, r3
 8017864:	f7fd fe96 	bl	8015594 <ipcp_close>
	    return;
 8017868:	e036      	b.n	80178d8 <ipcp_up+0x284>
	if (ho->hisaddr != 0 && wo->proxy_arp)
	    if (sifproxyarp(pcb, ho->hisaddr))
		pcb->proxy_arp_set = 1;
#endif /* UNUSED - PROXY ARP */

	wo->ouraddr = go->ouraddr;
 801786a:	697b      	ldr	r3, [r7, #20]
 801786c:	685a      	ldr	r2, [r3, #4]
 801786e:	693b      	ldr	r3, [r7, #16]
 8017870:	605a      	str	r2, [r3, #4]

	ppp_notice("local  IP address %I", go->ouraddr);
 8017872:	697b      	ldr	r3, [r7, #20]
 8017874:	685a      	ldr	r2, [r3, #4]
 8017876:	4b25      	ldr	r3, [pc, #148]	; (801790c <ipcp_up+0x2b8>)
 8017878:	0011      	movs	r1, r2
 801787a:	0018      	movs	r0, r3
 801787c:	f003 ffef 	bl	801b85e <ppp_notice>
	if (ho->hisaddr != 0)
 8017880:	69bb      	ldr	r3, [r7, #24]
 8017882:	689b      	ldr	r3, [r3, #8]
 8017884:	2b00      	cmp	r3, #0
 8017886:	d006      	beq.n	8017896 <ipcp_up+0x242>
	    ppp_notice("remote IP address %I", ho->hisaddr);
 8017888:	69bb      	ldr	r3, [r7, #24]
 801788a:	689a      	ldr	r2, [r3, #8]
 801788c:	4b20      	ldr	r3, [pc, #128]	; (8017910 <ipcp_up+0x2bc>)
 801788e:	0011      	movs	r1, r2
 8017890:	0018      	movs	r0, r3
 8017892:	f003 ffe4 	bl	801b85e <ppp_notice>
#if LWIP_DNS
	if (go->dnsaddr[0])
 8017896:	697b      	ldr	r3, [r7, #20]
 8017898:	68db      	ldr	r3, [r3, #12]
 801789a:	2b00      	cmp	r3, #0
 801789c:	d006      	beq.n	80178ac <ipcp_up+0x258>
	    ppp_notice("primary   DNS address %I", go->dnsaddr[0]);
 801789e:	697b      	ldr	r3, [r7, #20]
 80178a0:	68da      	ldr	r2, [r3, #12]
 80178a2:	4b1c      	ldr	r3, [pc, #112]	; (8017914 <ipcp_up+0x2c0>)
 80178a4:	0011      	movs	r1, r2
 80178a6:	0018      	movs	r0, r3
 80178a8:	f003 ffd9 	bl	801b85e <ppp_notice>
	if (go->dnsaddr[1])
 80178ac:	697b      	ldr	r3, [r7, #20]
 80178ae:	691b      	ldr	r3, [r3, #16]
 80178b0:	2b00      	cmp	r3, #0
 80178b2:	d006      	beq.n	80178c2 <ipcp_up+0x26e>
	    ppp_notice("secondary DNS address %I", go->dnsaddr[1]);
 80178b4:	697b      	ldr	r3, [r7, #20]
 80178b6:	691a      	ldr	r2, [r3, #16]
 80178b8:	4b17      	ldr	r3, [pc, #92]	; (8017918 <ipcp_up+0x2c4>)
 80178ba:	0011      	movs	r1, r2
 80178bc:	0018      	movs	r0, r3
 80178be:	f003 ffce 	bl	801b85e <ppp_notice>

#if PPP_STATS_SUPPORT
    reset_link_stats(f->unit);
#endif /* PPP_STATS_SUPPORT */

    np_up(pcb, PPP_IP);
 80178c2:	69fb      	ldr	r3, [r7, #28]
 80178c4:	2121      	movs	r1, #33	; 0x21
 80178c6:	0018      	movs	r0, r3
 80178c8:	f7fc fdda 	bl	8014480 <np_up>
    pcb->ipcp_is_up = 1;
 80178cc:	69fb      	ldr	r3, [r7, #28]
 80178ce:	2226      	movs	r2, #38	; 0x26
 80178d0:	5c99      	ldrb	r1, [r3, r2]
 80178d2:	2004      	movs	r0, #4
 80178d4:	4301      	orrs	r1, r0
 80178d6:	5499      	strb	r1, [r3, r2]
#endif /* PPP_NOTIFY */
#if 0 /* UNUSED */
    if (ip_up_hook)
	ip_up_hook();
#endif /* UNUSED */
}
 80178d8:	46bd      	mov	sp, r7
 80178da:	b008      	add	sp, #32
 80178dc:	bd80      	pop	{r7, pc}
 80178de:	46c0      	nop			; (mov r8, r8)
 80178e0:	0000124c 	.word	0x0000124c
 80178e4:	0000121c 	.word	0x0000121c
 80178e8:	00001204 	.word	0x00001204
 80178ec:	08021b74 	.word	0x08021b74
 80178f0:	08021b9c 	.word	0x08021b9c
 80178f4:	08021bb4 	.word	0x08021bb4
 80178f8:	0a404040 	.word	0x0a404040
 80178fc:	08021bdc 	.word	0x08021bdc
 8017900:	08021c14 	.word	0x08021c14
 8017904:	08021c44 	.word	0x08021c44
 8017908:	08021c64 	.word	0x08021c64
 801790c:	08021c84 	.word	0x08021c84
 8017910:	08021c9c 	.word	0x08021c9c
 8017914:	08021cb4 	.word	0x08021cb4
 8017918:	08021cd0 	.word	0x08021cd0

0801791c <ipcp_down>:
 * ipcp_down - IPCP has gone DOWN.
 *
 * Take the IP network interface down, clear its addresses
 * and delete routes through it.
 */
static void ipcp_down(fsm *f) {
 801791c:	b580      	push	{r7, lr}
 801791e:	b086      	sub	sp, #24
 8017920:	af00      	add	r7, sp, #0
 8017922:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8017924:	687b      	ldr	r3, [r7, #4]
 8017926:	681b      	ldr	r3, [r3, #0]
 8017928:	617b      	str	r3, [r7, #20]
    ipcp_options *ho = &pcb->ipcp_hisoptions;
 801792a:	697b      	ldr	r3, [r7, #20]
 801792c:	4a1c      	ldr	r2, [pc, #112]	; (80179a0 <ipcp_down+0x84>)
 801792e:	4694      	mov	ip, r2
 8017930:	4463      	add	r3, ip
 8017932:	613b      	str	r3, [r7, #16]
    ipcp_options *go = &pcb->ipcp_gotoptions;
 8017934:	697b      	ldr	r3, [r7, #20]
 8017936:	4a1b      	ldr	r2, [pc, #108]	; (80179a4 <ipcp_down+0x88>)
 8017938:	4694      	mov	ip, r2
 801793a:	4463      	add	r3, ip
 801793c:	60fb      	str	r3, [r7, #12]
#endif /* PPP_NOTIFY */
#if 0 /* UNUSED */
    if (ip_down_hook)
	ip_down_hook();
#endif /* UNUSED */
    if (pcb->ipcp_is_up) {
 801793e:	697b      	ldr	r3, [r7, #20]
 8017940:	2226      	movs	r2, #38	; 0x26
 8017942:	5c9b      	ldrb	r3, [r3, r2]
 8017944:	2204      	movs	r2, #4
 8017946:	4013      	ands	r3, r2
 8017948:	b2db      	uxtb	r3, r3
 801794a:	2b00      	cmp	r3, #0
 801794c:	d00a      	beq.n	8017964 <ipcp_down+0x48>
	pcb->ipcp_is_up = 0;
 801794e:	697b      	ldr	r3, [r7, #20]
 8017950:	2226      	movs	r2, #38	; 0x26
 8017952:	5c99      	ldrb	r1, [r3, r2]
 8017954:	2004      	movs	r0, #4
 8017956:	4381      	bics	r1, r0
 8017958:	5499      	strb	r1, [r3, r2]
	np_down(pcb, PPP_IP);
 801795a:	697b      	ldr	r3, [r7, #20]
 801795c:	2121      	movs	r1, #33	; 0x21
 801795e:	0018      	movs	r0, r3
 8017960:	f7fc fda9 	bl	80144b6 <np_down>
    }
#if VJ_SUPPORT
    sifvjcomp(pcb, 0, 0, 0);
 8017964:	6978      	ldr	r0, [r7, #20]
 8017966:	2300      	movs	r3, #0
 8017968:	2200      	movs	r2, #0
 801796a:	2100      	movs	r1, #0
 801796c:	f002 fd76 	bl	801a45c <sifvjcomp>
#endif /* DEMAND_SUPPORT */
    {
#if DEMAND_SUPPORT
	sifnpmode(pcb, PPP_IP, NPMODE_DROP);
#endif /* DEMAND_SUPPORT */
	sifdown(pcb);
 8017970:	697b      	ldr	r3, [r7, #20]
 8017972:	0018      	movs	r0, r3
 8017974:	f002 fdbc 	bl	801a4f0 <sifdown>
	ipcp_clear_addrs(pcb, go->ouraddr,
 8017978:	68fb      	ldr	r3, [r7, #12]
 801797a:	6859      	ldr	r1, [r3, #4]
 801797c:	693b      	ldr	r3, [r7, #16]
 801797e:	689a      	ldr	r2, [r3, #8]
 8017980:	6978      	ldr	r0, [r7, #20]
 8017982:	2300      	movs	r3, #0
 8017984:	f000 f810 	bl	80179a8 <ipcp_clear_addrs>
			 ho->hisaddr, 0);
#if LWIP_DNS
	cdns(pcb, go->dnsaddr[0], go->dnsaddr[1]);
 8017988:	68fb      	ldr	r3, [r7, #12]
 801798a:	68d9      	ldr	r1, [r3, #12]
 801798c:	68fb      	ldr	r3, [r7, #12]
 801798e:	691a      	ldr	r2, [r3, #16]
 8017990:	697b      	ldr	r3, [r7, #20]
 8017992:	0018      	movs	r0, r3
 8017994:	f002 fd32 	bl	801a3fc <cdns>
#endif /* LWIP_DNS */
    }
}
 8017998:	46c0      	nop			; (mov r8, r8)
 801799a:	46bd      	mov	sp, r7
 801799c:	b006      	add	sp, #24
 801799e:	bd80      	pop	{r7, pc}
 80179a0:	0000124c 	.word	0x0000124c
 80179a4:	0000121c 	.word	0x0000121c

080179a8 <ipcp_clear_addrs>:

/*
 * ipcp_clear_addrs() - clear the interface addresses, routes,
 * proxy arp entries, etc.
 */
static void ipcp_clear_addrs(ppp_pcb *pcb, u32_t ouraddr, u32_t hisaddr, u8_t replacedefaultroute) {
 80179a8:	b580      	push	{r7, lr}
 80179aa:	b084      	sub	sp, #16
 80179ac:	af00      	add	r7, sp, #0
 80179ae:	60f8      	str	r0, [r7, #12]
 80179b0:	60b9      	str	r1, [r7, #8]
 80179b2:	607a      	str	r2, [r7, #4]
 80179b4:	001a      	movs	r2, r3
 80179b6:	1cfb      	adds	r3, r7, #3
 80179b8:	701a      	strb	r2, [r3, #0]
    if (!replacedefaultroute && pcb->default_route_set) {
	cifdefaultroute(pcb, ouraddr, hisaddr);
	pcb->default_route_set = 0;
    }
#endif /* UNUSED */
    cifaddr(pcb, ouraddr, hisaddr);
 80179ba:	687a      	ldr	r2, [r7, #4]
 80179bc:	68b9      	ldr	r1, [r7, #8]
 80179be:	68fb      	ldr	r3, [r7, #12]
 80179c0:	0018      	movs	r0, r3
 80179c2:	f002 fceb 	bl	801a39c <cifaddr>
}
 80179c6:	46c0      	nop			; (mov r8, r8)
 80179c8:	46bd      	mov	sp, r7
 80179ca:	b004      	add	sp, #16
 80179cc:	bd80      	pop	{r7, pc}

080179ce <ipcp_finished>:


/*
 * ipcp_finished - possibly shut down the lower layers.
 */
static void ipcp_finished(fsm *f) {
 80179ce:	b580      	push	{r7, lr}
 80179d0:	b084      	sub	sp, #16
 80179d2:	af00      	add	r7, sp, #0
 80179d4:	6078      	str	r0, [r7, #4]
	ppp_pcb *pcb = f->pcb;
 80179d6:	687b      	ldr	r3, [r7, #4]
 80179d8:	681b      	ldr	r3, [r3, #0]
 80179da:	60fb      	str	r3, [r7, #12]
	if (pcb->ipcp_is_open) {
 80179dc:	68fb      	ldr	r3, [r7, #12]
 80179de:	2226      	movs	r2, #38	; 0x26
 80179e0:	5c9b      	ldrb	r3, [r3, r2]
 80179e2:	2202      	movs	r2, #2
 80179e4:	4013      	ands	r3, r2
 80179e6:	b2db      	uxtb	r3, r3
 80179e8:	2b00      	cmp	r3, #0
 80179ea:	d00a      	beq.n	8017a02 <ipcp_finished+0x34>
		pcb->ipcp_is_open = 0;
 80179ec:	68fb      	ldr	r3, [r7, #12]
 80179ee:	2226      	movs	r2, #38	; 0x26
 80179f0:	5c99      	ldrb	r1, [r3, r2]
 80179f2:	2002      	movs	r0, #2
 80179f4:	4381      	bics	r1, r0
 80179f6:	5499      	strb	r1, [r3, r2]
		np_finished(pcb, PPP_IP);
 80179f8:	68fb      	ldr	r3, [r7, #12]
 80179fa:	2121      	movs	r1, #33	; 0x21
 80179fc:	0018      	movs	r0, r3
 80179fe:	f7fc fd75 	bl	80144ec <np_finished>
	}
}
 8017a02:	46c0      	nop			; (mov r8, r8)
 8017a04:	46bd      	mov	sp, r7
 8017a06:	b004      	add	sp, #16
 8017a08:	bd80      	pop	{r7, pc}
	...

08017a0c <lcp_init>:
#endif /* HAVE_MULTILINK */

/*
 * lcp_init - Initialize LCP.
 */
static void lcp_init(ppp_pcb *pcb) {
 8017a0c:	b580      	push	{r7, lr}
 8017a0e:	b086      	sub	sp, #24
 8017a10:	af00      	add	r7, sp, #0
 8017a12:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->lcp_fsm;
 8017a14:	687b      	ldr	r3, [r7, #4]
 8017a16:	3328      	adds	r3, #40	; 0x28
 8017a18:	617b      	str	r3, [r7, #20]
    lcp_options *wo = &pcb->lcp_wantoptions;
 8017a1a:	687b      	ldr	r3, [r7, #4]
 8017a1c:	3344      	adds	r3, #68	; 0x44
 8017a1e:	613b      	str	r3, [r7, #16]
    lcp_options *ao = &pcb->lcp_allowoptions;
 8017a20:	687b      	ldr	r3, [r7, #4]
 8017a22:	338c      	adds	r3, #140	; 0x8c
 8017a24:	60fb      	str	r3, [r7, #12]

    f->pcb = pcb;
 8017a26:	697b      	ldr	r3, [r7, #20]
 8017a28:	687a      	ldr	r2, [r7, #4]
 8017a2a:	601a      	str	r2, [r3, #0]
    f->protocol = PPP_LCP;
 8017a2c:	697b      	ldr	r3, [r7, #20]
 8017a2e:	4a2b      	ldr	r2, [pc, #172]	; (8017adc <lcp_init+0xd0>)
 8017a30:	81da      	strh	r2, [r3, #14]
    f->callbacks = &lcp_callbacks;
 8017a32:	697b      	ldr	r3, [r7, #20]
 8017a34:	4a2a      	ldr	r2, [pc, #168]	; (8017ae0 <lcp_init+0xd4>)
 8017a36:	605a      	str	r2, [r3, #4]

    fsm_init(f);
 8017a38:	697b      	ldr	r3, [r7, #20]
 8017a3a:	0018      	movs	r0, r3
 8017a3c:	f7fc fd74 	bl	8014528 <fsm_init>

    BZERO(wo, sizeof(*wo));
 8017a40:	693b      	ldr	r3, [r7, #16]
 8017a42:	2224      	movs	r2, #36	; 0x24
 8017a44:	2100      	movs	r1, #0
 8017a46:	0018      	movs	r0, r3
 8017a48:	f005 fa5c 	bl	801cf04 <memset>
    wo->neg_mru = 1;
 8017a4c:	693b      	ldr	r3, [r7, #16]
 8017a4e:	781a      	ldrb	r2, [r3, #0]
 8017a50:	2104      	movs	r1, #4
 8017a52:	430a      	orrs	r2, r1
 8017a54:	701a      	strb	r2, [r3, #0]
    wo->mru = PPP_DEFMRU;
 8017a56:	693b      	ldr	r3, [r7, #16]
 8017a58:	4a22      	ldr	r2, [pc, #136]	; (8017ae4 <lcp_init+0xd8>)
 8017a5a:	805a      	strh	r2, [r3, #2]
    wo->neg_asyncmap = 1;
 8017a5c:	693b      	ldr	r3, [r7, #16]
 8017a5e:	781a      	ldrb	r2, [r3, #0]
 8017a60:	2108      	movs	r1, #8
 8017a62:	430a      	orrs	r2, r1
 8017a64:	701a      	strb	r2, [r3, #0]
    wo->neg_magicnumber = 1;
 8017a66:	693b      	ldr	r3, [r7, #16]
 8017a68:	781a      	ldrb	r2, [r3, #0]
 8017a6a:	2110      	movs	r1, #16
 8017a6c:	430a      	orrs	r2, r1
 8017a6e:	701a      	strb	r2, [r3, #0]
    wo->neg_pcompression = 1;
 8017a70:	693b      	ldr	r3, [r7, #16]
 8017a72:	781a      	ldrb	r2, [r3, #0]
 8017a74:	2120      	movs	r1, #32
 8017a76:	430a      	orrs	r2, r1
 8017a78:	701a      	strb	r2, [r3, #0]
    wo->neg_accompression = 1;
 8017a7a:	693b      	ldr	r3, [r7, #16]
 8017a7c:	781a      	ldrb	r2, [r3, #0]
 8017a7e:	2140      	movs	r1, #64	; 0x40
 8017a80:	430a      	orrs	r2, r1
 8017a82:	701a      	strb	r2, [r3, #0]

    BZERO(ao, sizeof(*ao));
 8017a84:	68fb      	ldr	r3, [r7, #12]
 8017a86:	2224      	movs	r2, #36	; 0x24
 8017a88:	2100      	movs	r1, #0
 8017a8a:	0018      	movs	r0, r3
 8017a8c:	f005 fa3a 	bl	801cf04 <memset>
    ao->neg_mru = 1;
 8017a90:	68fb      	ldr	r3, [r7, #12]
 8017a92:	781a      	ldrb	r2, [r3, #0]
 8017a94:	2104      	movs	r1, #4
 8017a96:	430a      	orrs	r2, r1
 8017a98:	701a      	strb	r2, [r3, #0]
    ao->mru = PPP_MAXMRU;
 8017a9a:	68fb      	ldr	r3, [r7, #12]
 8017a9c:	4a11      	ldr	r2, [pc, #68]	; (8017ae4 <lcp_init+0xd8>)
 8017a9e:	805a      	strh	r2, [r3, #2]
    ao->neg_asyncmap = 1;
 8017aa0:	68fb      	ldr	r3, [r7, #12]
 8017aa2:	781a      	ldrb	r2, [r3, #0]
 8017aa4:	2108      	movs	r1, #8
 8017aa6:	430a      	orrs	r2, r1
 8017aa8:	701a      	strb	r2, [r3, #0]
    ao->neg_upap = 1;
#endif /* PAP_SUPPORT */
#if EAP_SUPPORT
    ao->neg_eap = 1;
#endif /* EAP_SUPPORT */
    ao->neg_magicnumber = 1;
 8017aaa:	68fb      	ldr	r3, [r7, #12]
 8017aac:	781a      	ldrb	r2, [r3, #0]
 8017aae:	2110      	movs	r1, #16
 8017ab0:	430a      	orrs	r2, r1
 8017ab2:	701a      	strb	r2, [r3, #0]
    ao->neg_pcompression = 1;
 8017ab4:	68fb      	ldr	r3, [r7, #12]
 8017ab6:	781a      	ldrb	r2, [r3, #0]
 8017ab8:	2120      	movs	r1, #32
 8017aba:	430a      	orrs	r2, r1
 8017abc:	701a      	strb	r2, [r3, #0]
    ao->neg_accompression = 1;
 8017abe:	68fb      	ldr	r3, [r7, #12]
 8017ac0:	781a      	ldrb	r2, [r3, #0]
 8017ac2:	2140      	movs	r1, #64	; 0x40
 8017ac4:	430a      	orrs	r2, r1
 8017ac6:	701a      	strb	r2, [r3, #0]
    ao->neg_endpoint = 1;
 8017ac8:	68fb      	ldr	r3, [r7, #12]
 8017aca:	785a      	ldrb	r2, [r3, #1]
 8017acc:	2102      	movs	r1, #2
 8017ace:	430a      	orrs	r2, r1
 8017ad0:	705a      	strb	r2, [r3, #1]
}
 8017ad2:	46c0      	nop			; (mov r8, r8)
 8017ad4:	46bd      	mov	sp, r7
 8017ad6:	b006      	add	sp, #24
 8017ad8:	bd80      	pop	{r7, pc}
 8017ada:	46c0      	nop			; (mov r8, r8)
 8017adc:	ffffc021 	.word	0xffffc021
 8017ae0:	080229e8 	.word	0x080229e8
 8017ae4:	000005dc 	.word	0x000005dc

08017ae8 <lcp_open>:


/*
 * lcp_open - LCP is allowed to come up.
 */
void lcp_open(ppp_pcb *pcb) {
 8017ae8:	b580      	push	{r7, lr}
 8017aea:	b084      	sub	sp, #16
 8017aec:	af00      	add	r7, sp, #0
 8017aee:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->lcp_fsm;
 8017af0:	687b      	ldr	r3, [r7, #4]
 8017af2:	3328      	adds	r3, #40	; 0x28
 8017af4:	60fb      	str	r3, [r7, #12]
    lcp_options *wo = &pcb->lcp_wantoptions;
 8017af6:	687b      	ldr	r3, [r7, #4]
 8017af8:	3344      	adds	r3, #68	; 0x44
 8017afa:	60bb      	str	r3, [r7, #8]

    f->flags &= ~(OPT_PASSIVE | OPT_SILENT);
 8017afc:	68fb      	ldr	r3, [r7, #12]
 8017afe:	7c5b      	ldrb	r3, [r3, #17]
 8017b00:	2205      	movs	r2, #5
 8017b02:	4393      	bics	r3, r2
 8017b04:	b2da      	uxtb	r2, r3
 8017b06:	68fb      	ldr	r3, [r7, #12]
 8017b08:	745a      	strb	r2, [r3, #17]
    if (wo->passive)
 8017b0a:	68bb      	ldr	r3, [r7, #8]
 8017b0c:	781b      	ldrb	r3, [r3, #0]
 8017b0e:	2201      	movs	r2, #1
 8017b10:	4013      	ands	r3, r2
 8017b12:	b2db      	uxtb	r3, r3
 8017b14:	2b00      	cmp	r3, #0
 8017b16:	d006      	beq.n	8017b26 <lcp_open+0x3e>
	f->flags |= OPT_PASSIVE;
 8017b18:	68fb      	ldr	r3, [r7, #12]
 8017b1a:	7c5b      	ldrb	r3, [r3, #17]
 8017b1c:	2201      	movs	r2, #1
 8017b1e:	4313      	orrs	r3, r2
 8017b20:	b2da      	uxtb	r2, r3
 8017b22:	68fb      	ldr	r3, [r7, #12]
 8017b24:	745a      	strb	r2, [r3, #17]
    if (wo->silent)
 8017b26:	68bb      	ldr	r3, [r7, #8]
 8017b28:	781b      	ldrb	r3, [r3, #0]
 8017b2a:	2202      	movs	r2, #2
 8017b2c:	4013      	ands	r3, r2
 8017b2e:	b2db      	uxtb	r3, r3
 8017b30:	2b00      	cmp	r3, #0
 8017b32:	d006      	beq.n	8017b42 <lcp_open+0x5a>
	f->flags |= OPT_SILENT;
 8017b34:	68fb      	ldr	r3, [r7, #12]
 8017b36:	7c5b      	ldrb	r3, [r3, #17]
 8017b38:	2204      	movs	r2, #4
 8017b3a:	4313      	orrs	r3, r2
 8017b3c:	b2da      	uxtb	r2, r3
 8017b3e:	68fb      	ldr	r3, [r7, #12]
 8017b40:	745a      	strb	r2, [r3, #17]
    fsm_open(f);
 8017b42:	68fb      	ldr	r3, [r7, #12]
 8017b44:	0018      	movs	r0, r3
 8017b46:	f7fc fd7d 	bl	8014644 <fsm_open>
}
 8017b4a:	46c0      	nop			; (mov r8, r8)
 8017b4c:	46bd      	mov	sp, r7
 8017b4e:	b004      	add	sp, #16
 8017b50:	bd80      	pop	{r7, pc}
	...

08017b54 <lcp_close>:


/*
 * lcp_close - Take LCP down.
 */
void lcp_close(ppp_pcb *pcb, const char *reason) {
 8017b54:	b580      	push	{r7, lr}
 8017b56:	b084      	sub	sp, #16
 8017b58:	af00      	add	r7, sp, #0
 8017b5a:	6078      	str	r0, [r7, #4]
 8017b5c:	6039      	str	r1, [r7, #0]
    fsm *f = &pcb->lcp_fsm;
 8017b5e:	687b      	ldr	r3, [r7, #4]
 8017b60:	3328      	adds	r3, #40	; 0x28
 8017b62:	60fb      	str	r3, [r7, #12]
    int oldstate;

    if (pcb->phase != PPP_PHASE_DEAD
 8017b64:	687b      	ldr	r3, [r7, #4]
 8017b66:	2224      	movs	r2, #36	; 0x24
 8017b68:	5c9b      	ldrb	r3, [r3, r2]
 8017b6a:	2b00      	cmp	r3, #0
 8017b6c:	d004      	beq.n	8017b78 <lcp_close+0x24>
#ifdef HAVE_MULTILINK
    && pcb->phase != PPP_PHASE_MASTER
#endif /* HAVE_MULTILINK */
    )
	new_phase(pcb, PPP_PHASE_TERMINATE);
 8017b6e:	687b      	ldr	r3, [r7, #4]
 8017b70:	210b      	movs	r1, #11
 8017b72:	0018      	movs	r0, r3
 8017b74:	f002 fba1 	bl	801a2ba <new_phase>

    if (f->flags & DELAYED_UP) {
 8017b78:	68fb      	ldr	r3, [r7, #12]
 8017b7a:	7c5b      	ldrb	r3, [r3, #17]
 8017b7c:	b25b      	sxtb	r3, r3
 8017b7e:	2b00      	cmp	r3, #0
 8017b80:	da08      	bge.n	8017b94 <lcp_close+0x40>
	UNTIMEOUT(lcp_delayed_up, f);
 8017b82:	68fa      	ldr	r2, [r7, #12]
 8017b84:	4b14      	ldr	r3, [pc, #80]	; (8017bd8 <lcp_close+0x84>)
 8017b86:	0011      	movs	r1, r2
 8017b88:	0018      	movs	r0, r3
 8017b8a:	f7fa fc33 	bl	80123f4 <sys_untimeout>
	f->state = PPP_FSM_STOPPED;
 8017b8e:	68fb      	ldr	r3, [r7, #12]
 8017b90:	2203      	movs	r2, #3
 8017b92:	741a      	strb	r2, [r3, #16]
    }
    oldstate = f->state;
 8017b94:	68fb      	ldr	r3, [r7, #12]
 8017b96:	7c1b      	ldrb	r3, [r3, #16]
 8017b98:	60bb      	str	r3, [r7, #8]

    fsm_close(f, reason);
 8017b9a:	683a      	ldr	r2, [r7, #0]
 8017b9c:	68fb      	ldr	r3, [r7, #12]
 8017b9e:	0011      	movs	r1, r2
 8017ba0:	0018      	movs	r0, r3
 8017ba2:	f7fc fe11 	bl	80147c8 <fsm_close>
    if (oldstate == PPP_FSM_STOPPED && (f->flags & (OPT_PASSIVE|OPT_SILENT|DELAYED_UP))) {
 8017ba6:	68bb      	ldr	r3, [r7, #8]
 8017ba8:	2b03      	cmp	r3, #3
 8017baa:	d110      	bne.n	8017bce <lcp_close+0x7a>
 8017bac:	68fb      	ldr	r3, [r7, #12]
 8017bae:	7c5b      	ldrb	r3, [r3, #17]
 8017bb0:	001a      	movs	r2, r3
 8017bb2:	2385      	movs	r3, #133	; 0x85
 8017bb4:	4013      	ands	r3, r2
 8017bb6:	d00a      	beq.n	8017bce <lcp_close+0x7a>
	 * but it does mean that the program terminates if you do a
	 * lcp_close() when a connection hasn't been established
	 * because we are in passive/silent mode or because we have
	 * delayed the fsm_lowerup() call and it hasn't happened yet.
	 */
	f->flags &= ~DELAYED_UP;
 8017bb8:	68fb      	ldr	r3, [r7, #12]
 8017bba:	7c5b      	ldrb	r3, [r3, #17]
 8017bbc:	227f      	movs	r2, #127	; 0x7f
 8017bbe:	4013      	ands	r3, r2
 8017bc0:	b2da      	uxtb	r2, r3
 8017bc2:	68fb      	ldr	r3, [r7, #12]
 8017bc4:	745a      	strb	r2, [r3, #17]
	lcp_finished(f);
 8017bc6:	68fb      	ldr	r3, [r7, #12]
 8017bc8:	0018      	movs	r0, r3
 8017bca:	f001 fe64 	bl	8019896 <lcp_finished>
    }
}
 8017bce:	46c0      	nop			; (mov r8, r8)
 8017bd0:	46bd      	mov	sp, r7
 8017bd2:	b004      	add	sp, #16
 8017bd4:	bd80      	pop	{r7, pc}
 8017bd6:	46c0      	nop			; (mov r8, r8)
 8017bd8:	08017ce5 	.word	0x08017ce5

08017bdc <lcp_lowerup>:


/*
 * lcp_lowerup - The lower layer is up.
 */
void lcp_lowerup(ppp_pcb *pcb) {
 8017bdc:	b590      	push	{r4, r7, lr}
 8017bde:	b087      	sub	sp, #28
 8017be0:	af02      	add	r7, sp, #8
 8017be2:	6078      	str	r0, [r7, #4]
    lcp_options *wo = &pcb->lcp_wantoptions;
 8017be4:	687b      	ldr	r3, [r7, #4]
 8017be6:	3344      	adds	r3, #68	; 0x44
 8017be8:	60fb      	str	r3, [r7, #12]
    fsm *f = &pcb->lcp_fsm;
 8017bea:	687b      	ldr	r3, [r7, #4]
 8017bec:	3328      	adds	r3, #40	; 0x28
 8017bee:	60bb      	str	r3, [r7, #8]
    /*
     * Don't use A/C or protocol compression on transmission,
     * but accept A/C and protocol compressed packets
     * if we are going to ask for A/C and protocol compression.
     */
    if (ppp_send_config(pcb, PPP_MRU, 0xffffffff, 0, 0) < 0
 8017bf0:	2301      	movs	r3, #1
 8017bf2:	425a      	negs	r2, r3
 8017bf4:	4927      	ldr	r1, [pc, #156]	; (8017c94 <lcp_lowerup+0xb8>)
 8017bf6:	6878      	ldr	r0, [r7, #4]
 8017bf8:	2300      	movs	r3, #0
 8017bfa:	9300      	str	r3, [sp, #0]
 8017bfc:	2300      	movs	r3, #0
 8017bfe:	f002 fb77 	bl	801a2f0 <ppp_send_config>
 8017c02:	1e03      	subs	r3, r0, #0
 8017c04:	db41      	blt.n	8017c8a <lcp_lowerup+0xae>
	|| ppp_recv_config(pcb, PPP_MRU, (pcb->settings.lax_recv? 0: 0xffffffff),
 8017c06:	687b      	ldr	r3, [r7, #4]
 8017c08:	781b      	ldrb	r3, [r3, #0]
 8017c0a:	2208      	movs	r2, #8
 8017c0c:	4013      	ands	r3, r2
 8017c0e:	b2db      	uxtb	r3, r3
 8017c10:	2b00      	cmp	r3, #0
 8017c12:	d001      	beq.n	8017c18 <lcp_lowerup+0x3c>
 8017c14:	2200      	movs	r2, #0
 8017c16:	e001      	b.n	8017c1c <lcp_lowerup+0x40>
 8017c18:	2301      	movs	r3, #1
 8017c1a:	425a      	negs	r2, r3
			   wo->neg_pcompression, wo->neg_accompression) < 0)
 8017c1c:	68fb      	ldr	r3, [r7, #12]
 8017c1e:	781b      	ldrb	r3, [r3, #0]
 8017c20:	069b      	lsls	r3, r3, #26
 8017c22:	0fdb      	lsrs	r3, r3, #31
 8017c24:	b2db      	uxtb	r3, r3
	|| ppp_recv_config(pcb, PPP_MRU, (pcb->settings.lax_recv? 0: 0xffffffff),
 8017c26:	001c      	movs	r4, r3
			   wo->neg_pcompression, wo->neg_accompression) < 0)
 8017c28:	68fb      	ldr	r3, [r7, #12]
 8017c2a:	781b      	ldrb	r3, [r3, #0]
 8017c2c:	065b      	lsls	r3, r3, #25
 8017c2e:	0fdb      	lsrs	r3, r3, #31
 8017c30:	b2db      	uxtb	r3, r3
	|| ppp_recv_config(pcb, PPP_MRU, (pcb->settings.lax_recv? 0: 0xffffffff),
 8017c32:	4918      	ldr	r1, [pc, #96]	; (8017c94 <lcp_lowerup+0xb8>)
 8017c34:	6878      	ldr	r0, [r7, #4]
 8017c36:	9300      	str	r3, [sp, #0]
 8017c38:	0023      	movs	r3, r4
 8017c3a:	f002 fb76 	bl	801a32a <ppp_recv_config>
 8017c3e:	1e03      	subs	r3, r0, #0
 8017c40:	db23      	blt.n	8017c8a <lcp_lowerup+0xae>
	    return;
    pcb->peer_mru = PPP_MRU;
 8017c42:	687b      	ldr	r3, [r7, #4]
 8017c44:	22d4      	movs	r2, #212	; 0xd4
 8017c46:	4913      	ldr	r1, [pc, #76]	; (8017c94 <lcp_lowerup+0xb8>)
 8017c48:	5299      	strh	r1, [r3, r2]

    if (pcb->settings.listen_time != 0) {
 8017c4a:	687b      	ldr	r3, [r7, #4]
 8017c4c:	885b      	ldrh	r3, [r3, #2]
 8017c4e:	2b00      	cmp	r3, #0
 8017c50:	d016      	beq.n	8017c80 <lcp_lowerup+0xa4>
	f->flags |= DELAYED_UP;
 8017c52:	68bb      	ldr	r3, [r7, #8]
 8017c54:	7c5b      	ldrb	r3, [r3, #17]
 8017c56:	2280      	movs	r2, #128	; 0x80
 8017c58:	4252      	negs	r2, r2
 8017c5a:	4313      	orrs	r3, r2
 8017c5c:	b2da      	uxtb	r2, r3
 8017c5e:	68bb      	ldr	r3, [r7, #8]
 8017c60:	745a      	strb	r2, [r3, #17]
	TIMEOUTMS(lcp_delayed_up, f, pcb->settings.listen_time);
 8017c62:	68ba      	ldr	r2, [r7, #8]
 8017c64:	4b0c      	ldr	r3, [pc, #48]	; (8017c98 <lcp_lowerup+0xbc>)
 8017c66:	0011      	movs	r1, r2
 8017c68:	0018      	movs	r0, r3
 8017c6a:	f7fa fbc3 	bl	80123f4 <sys_untimeout>
 8017c6e:	687b      	ldr	r3, [r7, #4]
 8017c70:	885b      	ldrh	r3, [r3, #2]
 8017c72:	0018      	movs	r0, r3
 8017c74:	68ba      	ldr	r2, [r7, #8]
 8017c76:	4b08      	ldr	r3, [pc, #32]	; (8017c98 <lcp_lowerup+0xbc>)
 8017c78:	0019      	movs	r1, r3
 8017c7a:	f7fa fb93 	bl	80123a4 <sys_timeout>
 8017c7e:	e005      	b.n	8017c8c <lcp_lowerup+0xb0>
    } else
	fsm_lowerup(f);
 8017c80:	68bb      	ldr	r3, [r7, #8]
 8017c82:	0018      	movs	r0, r3
 8017c84:	f7fc fc6b 	bl	801455e <fsm_lowerup>
 8017c88:	e000      	b.n	8017c8c <lcp_lowerup+0xb0>
	    return;
 8017c8a:	46c0      	nop			; (mov r8, r8)
}
 8017c8c:	46bd      	mov	sp, r7
 8017c8e:	b005      	add	sp, #20
 8017c90:	bd90      	pop	{r4, r7, pc}
 8017c92:	46c0      	nop			; (mov r8, r8)
 8017c94:	000005dc 	.word	0x000005dc
 8017c98:	08017ce5 	.word	0x08017ce5

08017c9c <lcp_lowerdown>:


/*
 * lcp_lowerdown - The lower layer is down.
 */
void lcp_lowerdown(ppp_pcb *pcb) {
 8017c9c:	b580      	push	{r7, lr}
 8017c9e:	b084      	sub	sp, #16
 8017ca0:	af00      	add	r7, sp, #0
 8017ca2:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->lcp_fsm;
 8017ca4:	687b      	ldr	r3, [r7, #4]
 8017ca6:	3328      	adds	r3, #40	; 0x28
 8017ca8:	60fb      	str	r3, [r7, #12]

    if (f->flags & DELAYED_UP) {
 8017caa:	68fb      	ldr	r3, [r7, #12]
 8017cac:	7c5b      	ldrb	r3, [r3, #17]
 8017cae:	b25b      	sxtb	r3, r3
 8017cb0:	2b00      	cmp	r3, #0
 8017cb2:	da0d      	bge.n	8017cd0 <lcp_lowerdown+0x34>
	f->flags &= ~DELAYED_UP;
 8017cb4:	68fb      	ldr	r3, [r7, #12]
 8017cb6:	7c5b      	ldrb	r3, [r3, #17]
 8017cb8:	227f      	movs	r2, #127	; 0x7f
 8017cba:	4013      	ands	r3, r2
 8017cbc:	b2da      	uxtb	r2, r3
 8017cbe:	68fb      	ldr	r3, [r7, #12]
 8017cc0:	745a      	strb	r2, [r3, #17]
	UNTIMEOUT(lcp_delayed_up, f);
 8017cc2:	68fa      	ldr	r2, [r7, #12]
 8017cc4:	4b06      	ldr	r3, [pc, #24]	; (8017ce0 <lcp_lowerdown+0x44>)
 8017cc6:	0011      	movs	r1, r2
 8017cc8:	0018      	movs	r0, r3
 8017cca:	f7fa fb93 	bl	80123f4 <sys_untimeout>
    } else
	fsm_lowerdown(f);
}
 8017cce:	e003      	b.n	8017cd8 <lcp_lowerdown+0x3c>
	fsm_lowerdown(f);
 8017cd0:	68fb      	ldr	r3, [r7, #12]
 8017cd2:	0018      	movs	r0, r3
 8017cd4:	f7fc fc6a 	bl	80145ac <fsm_lowerdown>
}
 8017cd8:	46c0      	nop			; (mov r8, r8)
 8017cda:	46bd      	mov	sp, r7
 8017cdc:	b004      	add	sp, #16
 8017cde:	bd80      	pop	{r7, pc}
 8017ce0:	08017ce5 	.word	0x08017ce5

08017ce4 <lcp_delayed_up>:


/*
 * lcp_delayed_up - Bring the lower layer up now.
 */
static void lcp_delayed_up(void *arg) {
 8017ce4:	b580      	push	{r7, lr}
 8017ce6:	b084      	sub	sp, #16
 8017ce8:	af00      	add	r7, sp, #0
 8017cea:	6078      	str	r0, [r7, #4]
    fsm *f = (fsm*)arg;
 8017cec:	687b      	ldr	r3, [r7, #4]
 8017cee:	60fb      	str	r3, [r7, #12]

    if (f->flags & DELAYED_UP) {
 8017cf0:	68fb      	ldr	r3, [r7, #12]
 8017cf2:	7c5b      	ldrb	r3, [r3, #17]
 8017cf4:	b25b      	sxtb	r3, r3
 8017cf6:	2b00      	cmp	r3, #0
 8017cf8:	da0a      	bge.n	8017d10 <lcp_delayed_up+0x2c>
	f->flags &= ~DELAYED_UP;
 8017cfa:	68fb      	ldr	r3, [r7, #12]
 8017cfc:	7c5b      	ldrb	r3, [r3, #17]
 8017cfe:	227f      	movs	r2, #127	; 0x7f
 8017d00:	4013      	ands	r3, r2
 8017d02:	b2da      	uxtb	r2, r3
 8017d04:	68fb      	ldr	r3, [r7, #12]
 8017d06:	745a      	strb	r2, [r3, #17]
	fsm_lowerup(f);
 8017d08:	68fb      	ldr	r3, [r7, #12]
 8017d0a:	0018      	movs	r0, r3
 8017d0c:	f7fc fc27 	bl	801455e <fsm_lowerup>
    }
}
 8017d10:	46c0      	nop			; (mov r8, r8)
 8017d12:	46bd      	mov	sp, r7
 8017d14:	b004      	add	sp, #16
 8017d16:	bd80      	pop	{r7, pc}

08017d18 <lcp_input>:


/*
 * lcp_input - Input LCP packet.
 */
static void lcp_input(ppp_pcb *pcb, u_char *p, int len) {
 8017d18:	b580      	push	{r7, lr}
 8017d1a:	b086      	sub	sp, #24
 8017d1c:	af00      	add	r7, sp, #0
 8017d1e:	60f8      	str	r0, [r7, #12]
 8017d20:	60b9      	str	r1, [r7, #8]
 8017d22:	607a      	str	r2, [r7, #4]
    fsm *f = &pcb->lcp_fsm;
 8017d24:	68fb      	ldr	r3, [r7, #12]
 8017d26:	3328      	adds	r3, #40	; 0x28
 8017d28:	617b      	str	r3, [r7, #20]

    if (f->flags & DELAYED_UP) {
 8017d2a:	697b      	ldr	r3, [r7, #20]
 8017d2c:	7c5b      	ldrb	r3, [r3, #17]
 8017d2e:	b25b      	sxtb	r3, r3
 8017d30:	2b00      	cmp	r3, #0
 8017d32:	da10      	bge.n	8017d56 <lcp_input+0x3e>
	f->flags &= ~DELAYED_UP;
 8017d34:	697b      	ldr	r3, [r7, #20]
 8017d36:	7c5b      	ldrb	r3, [r3, #17]
 8017d38:	227f      	movs	r2, #127	; 0x7f
 8017d3a:	4013      	ands	r3, r2
 8017d3c:	b2da      	uxtb	r2, r3
 8017d3e:	697b      	ldr	r3, [r7, #20]
 8017d40:	745a      	strb	r2, [r3, #17]
	UNTIMEOUT(lcp_delayed_up, f);
 8017d42:	697a      	ldr	r2, [r7, #20]
 8017d44:	4b09      	ldr	r3, [pc, #36]	; (8017d6c <lcp_input+0x54>)
 8017d46:	0011      	movs	r1, r2
 8017d48:	0018      	movs	r0, r3
 8017d4a:	f7fa fb53 	bl	80123f4 <sys_untimeout>
	fsm_lowerup(f);
 8017d4e:	697b      	ldr	r3, [r7, #20]
 8017d50:	0018      	movs	r0, r3
 8017d52:	f7fc fc04 	bl	801455e <fsm_lowerup>
    }
    fsm_input(f, p, len);
 8017d56:	687a      	ldr	r2, [r7, #4]
 8017d58:	68b9      	ldr	r1, [r7, #8]
 8017d5a:	697b      	ldr	r3, [r7, #20]
 8017d5c:	0018      	movs	r0, r3
 8017d5e:	f7fc fe1d 	bl	801499c <fsm_input>
}
 8017d62:	46c0      	nop			; (mov r8, r8)
 8017d64:	46bd      	mov	sp, r7
 8017d66:	b006      	add	sp, #24
 8017d68:	bd80      	pop	{r7, pc}
 8017d6a:	46c0      	nop			; (mov r8, r8)
 8017d6c:	08017ce5 	.word	0x08017ce5

08017d70 <lcp_extcode>:

/*
 * lcp_extcode - Handle a LCP-specific code.
 */
static int lcp_extcode(fsm *f, int code, int id, u_char *inp, int len) {
 8017d70:	b580      	push	{r7, lr}
 8017d72:	b08a      	sub	sp, #40	; 0x28
 8017d74:	af02      	add	r7, sp, #8
 8017d76:	60f8      	str	r0, [r7, #12]
 8017d78:	60b9      	str	r1, [r7, #8]
 8017d7a:	607a      	str	r2, [r7, #4]
 8017d7c:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 8017d7e:	68fb      	ldr	r3, [r7, #12]
 8017d80:	681b      	ldr	r3, [r3, #0]
 8017d82:	61fb      	str	r3, [r7, #28]
    lcp_options *go = &pcb->lcp_gotoptions;
 8017d84:	69fb      	ldr	r3, [r7, #28]
 8017d86:	3368      	adds	r3, #104	; 0x68
 8017d88:	61bb      	str	r3, [r7, #24]
    u_char *magp;

    switch( code ){
 8017d8a:	68bb      	ldr	r3, [r7, #8]
 8017d8c:	2b0d      	cmp	r3, #13
 8017d8e:	dc4d      	bgt.n	8017e2c <lcp_extcode+0xbc>
 8017d90:	68bb      	ldr	r3, [r7, #8]
 8017d92:	2b0b      	cmp	r3, #11
 8017d94:	da4c      	bge.n	8017e30 <lcp_extcode+0xc0>
 8017d96:	68bb      	ldr	r3, [r7, #8]
 8017d98:	2b0a      	cmp	r3, #10
 8017d9a:	d040      	beq.n	8017e1e <lcp_extcode+0xae>
 8017d9c:	68bb      	ldr	r3, [r7, #8]
 8017d9e:	2b0a      	cmp	r3, #10
 8017da0:	dc44      	bgt.n	8017e2c <lcp_extcode+0xbc>
 8017da2:	68bb      	ldr	r3, [r7, #8]
 8017da4:	2b08      	cmp	r3, #8
 8017da6:	d003      	beq.n	8017db0 <lcp_extcode+0x40>
 8017da8:	68bb      	ldr	r3, [r7, #8]
 8017daa:	2b09      	cmp	r3, #9
 8017dac:	d007      	beq.n	8017dbe <lcp_extcode+0x4e>
 8017dae:	e03d      	b.n	8017e2c <lcp_extcode+0xbc>
    case PROTREJ:
	lcp_rprotrej(f, inp, len);
 8017db0:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8017db2:	6839      	ldr	r1, [r7, #0]
 8017db4:	68fb      	ldr	r3, [r7, #12]
 8017db6:	0018      	movs	r0, r3
 8017db8:	f000 f842 	bl	8017e40 <lcp_rprotrej>
	break;
 8017dbc:	e03b      	b.n	8017e36 <lcp_extcode+0xc6>
    
    case ECHOREQ:
	if (f->state != PPP_FSM_OPENED)
 8017dbe:	68fb      	ldr	r3, [r7, #12]
 8017dc0:	7c1b      	ldrb	r3, [r3, #16]
 8017dc2:	2b09      	cmp	r3, #9
 8017dc4:	d136      	bne.n	8017e34 <lcp_extcode+0xc4>
	    break;
	magp = inp;
 8017dc6:	683b      	ldr	r3, [r7, #0]
 8017dc8:	617b      	str	r3, [r7, #20]
	PUTLONG(go->magicnumber, magp);
 8017dca:	69bb      	ldr	r3, [r7, #24]
 8017dcc:	689b      	ldr	r3, [r3, #8]
 8017dce:	0e19      	lsrs	r1, r3, #24
 8017dd0:	697b      	ldr	r3, [r7, #20]
 8017dd2:	1c5a      	adds	r2, r3, #1
 8017dd4:	617a      	str	r2, [r7, #20]
 8017dd6:	b2ca      	uxtb	r2, r1
 8017dd8:	701a      	strb	r2, [r3, #0]
 8017dda:	69bb      	ldr	r3, [r7, #24]
 8017ddc:	689b      	ldr	r3, [r3, #8]
 8017dde:	0c19      	lsrs	r1, r3, #16
 8017de0:	697b      	ldr	r3, [r7, #20]
 8017de2:	1c5a      	adds	r2, r3, #1
 8017de4:	617a      	str	r2, [r7, #20]
 8017de6:	b2ca      	uxtb	r2, r1
 8017de8:	701a      	strb	r2, [r3, #0]
 8017dea:	69bb      	ldr	r3, [r7, #24]
 8017dec:	689b      	ldr	r3, [r3, #8]
 8017dee:	0a19      	lsrs	r1, r3, #8
 8017df0:	697b      	ldr	r3, [r7, #20]
 8017df2:	1c5a      	adds	r2, r3, #1
 8017df4:	617a      	str	r2, [r7, #20]
 8017df6:	b2ca      	uxtb	r2, r1
 8017df8:	701a      	strb	r2, [r3, #0]
 8017dfa:	69bb      	ldr	r3, [r7, #24]
 8017dfc:	6899      	ldr	r1, [r3, #8]
 8017dfe:	697b      	ldr	r3, [r7, #20]
 8017e00:	1c5a      	adds	r2, r3, #1
 8017e02:	617a      	str	r2, [r7, #20]
 8017e04:	b2ca      	uxtb	r2, r1
 8017e06:	701a      	strb	r2, [r3, #0]
	fsm_sdata(f, ECHOREP, id, inp, len);
 8017e08:	687b      	ldr	r3, [r7, #4]
 8017e0a:	b2da      	uxtb	r2, r3
 8017e0c:	6839      	ldr	r1, [r7, #0]
 8017e0e:	68f8      	ldr	r0, [r7, #12]
 8017e10:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017e12:	9300      	str	r3, [sp, #0]
 8017e14:	000b      	movs	r3, r1
 8017e16:	210a      	movs	r1, #10
 8017e18:	f7fd faa2 	bl	8015360 <fsm_sdata>
	break;
 8017e1c:	e00b      	b.n	8017e36 <lcp_extcode+0xc6>
    
    case ECHOREP:
	lcp_received_echo_reply(f, id, inp, len);
 8017e1e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017e20:	683a      	ldr	r2, [r7, #0]
 8017e22:	6879      	ldr	r1, [r7, #4]
 8017e24:	68f8      	ldr	r0, [r7, #12]
 8017e26:	f001 fdd1 	bl	80199cc <lcp_received_echo_reply>
	break;
 8017e2a:	e004      	b.n	8017e36 <lcp_extcode+0xc6>
    case IDENTIF:
    case TIMEREM:
	break;

    default:
	return 0;
 8017e2c:	2300      	movs	r3, #0
 8017e2e:	e003      	b.n	8017e38 <lcp_extcode+0xc8>
	break;
 8017e30:	46c0      	nop			; (mov r8, r8)
 8017e32:	e000      	b.n	8017e36 <lcp_extcode+0xc6>
	    break;
 8017e34:	46c0      	nop			; (mov r8, r8)
    }
    return 1;
 8017e36:	2301      	movs	r3, #1
}
 8017e38:	0018      	movs	r0, r3
 8017e3a:	46bd      	mov	sp, r7
 8017e3c:	b008      	add	sp, #32
 8017e3e:	bd80      	pop	{r7, pc}

08017e40 <lcp_rprotrej>:
/*
 * lcp_rprotrej - Receive an Protocol-Reject.
 *
 * Figure out which protocol is rejected and inform it.
 */
static void lcp_rprotrej(fsm *f, u_char *inp, int len) {
 8017e40:	b580      	push	{r7, lr}
 8017e42:	b088      	sub	sp, #32
 8017e44:	af00      	add	r7, sp, #0
 8017e46:	60f8      	str	r0, [r7, #12]
 8017e48:	60b9      	str	r1, [r7, #8]
 8017e4a:	607a      	str	r2, [r7, #4]
    u_short prot;
#if PPP_PROTOCOLNAME
    const char *pname;
#endif /* PPP_PROTOCOLNAME */

    if (len < 2) {
 8017e4c:	687b      	ldr	r3, [r7, #4]
 8017e4e:	2b01      	cmp	r3, #1
 8017e50:	dd42      	ble.n	8017ed8 <lcp_rprotrej+0x98>
	LCPDEBUG(("lcp_rprotrej: Rcvd short Protocol-Reject packet!"));
	return;
    }

    GETSHORT(prot, inp);
 8017e52:	68bb      	ldr	r3, [r7, #8]
 8017e54:	1c5a      	adds	r2, r3, #1
 8017e56:	60ba      	str	r2, [r7, #8]
 8017e58:	781b      	ldrb	r3, [r3, #0]
 8017e5a:	b29a      	uxth	r2, r3
 8017e5c:	201a      	movs	r0, #26
 8017e5e:	183b      	adds	r3, r7, r0
 8017e60:	0212      	lsls	r2, r2, #8
 8017e62:	801a      	strh	r2, [r3, #0]
 8017e64:	68bb      	ldr	r3, [r7, #8]
 8017e66:	1c5a      	adds	r2, r3, #1
 8017e68:	60ba      	str	r2, [r7, #8]
 8017e6a:	781b      	ldrb	r3, [r3, #0]
 8017e6c:	b299      	uxth	r1, r3
 8017e6e:	183b      	adds	r3, r7, r0
 8017e70:	183a      	adds	r2, r7, r0
 8017e72:	8812      	ldrh	r2, [r2, #0]
 8017e74:	430a      	orrs	r2, r1
 8017e76:	801a      	strh	r2, [r3, #0]

    /*
     * Protocol-Reject packets received in any state other than the LCP
     * OPENED state SHOULD be silently discarded.
     */
    if( f->state != PPP_FSM_OPENED ){
 8017e78:	68fb      	ldr	r3, [r7, #12]
 8017e7a:	7c1b      	ldrb	r3, [r3, #16]
 8017e7c:	2b09      	cmp	r3, #9
 8017e7e:	d12d      	bne.n	8017edc <lcp_rprotrej+0x9c>
#endif /* PPP_PROTOCOLNAME */

    /*
     * Upcall the proper Protocol-Reject routine.
     */
    for (i = 0; (protp = protocols[i]) != NULL; ++i)
 8017e80:	2300      	movs	r3, #0
 8017e82:	61fb      	str	r3, [r7, #28]
 8017e84:	e017      	b.n	8017eb6 <lcp_rprotrej+0x76>
	if (protp->protocol == prot) {
 8017e86:	697b      	ldr	r3, [r7, #20]
 8017e88:	881b      	ldrh	r3, [r3, #0]
 8017e8a:	211a      	movs	r1, #26
 8017e8c:	187a      	adds	r2, r7, r1
 8017e8e:	8812      	ldrh	r2, [r2, #0]
 8017e90:	429a      	cmp	r2, r3
 8017e92:	d10d      	bne.n	8017eb0 <lcp_rprotrej+0x70>
	    if (pname != NULL)
		ppp_dbglog("Protocol-Reject for '%s' (0x%x) received", pname,
		       prot);
	    else
#endif /* PPP_PROTOCOLNAME */
		ppp_dbglog("Protocol-Reject for 0x%x received", prot);
 8017e94:	187b      	adds	r3, r7, r1
 8017e96:	881a      	ldrh	r2, [r3, #0]
 8017e98:	4b12      	ldr	r3, [pc, #72]	; (8017ee4 <lcp_rprotrej+0xa4>)
 8017e9a:	0011      	movs	r1, r2
 8017e9c:	0018      	movs	r0, r3
 8017e9e:	f003 fd06 	bl	801b8ae <ppp_dbglog>
	    (*protp->protrej)(f->pcb);
 8017ea2:	697b      	ldr	r3, [r7, #20]
 8017ea4:	68da      	ldr	r2, [r3, #12]
 8017ea6:	68fb      	ldr	r3, [r7, #12]
 8017ea8:	681b      	ldr	r3, [r3, #0]
 8017eaa:	0018      	movs	r0, r3
 8017eac:	4790      	blx	r2
	    return;
 8017eae:	e016      	b.n	8017ede <lcp_rprotrej+0x9e>
    for (i = 0; (protp = protocols[i]) != NULL; ++i)
 8017eb0:	69fb      	ldr	r3, [r7, #28]
 8017eb2:	3301      	adds	r3, #1
 8017eb4:	61fb      	str	r3, [r7, #28]
 8017eb6:	4b0c      	ldr	r3, [pc, #48]	; (8017ee8 <lcp_rprotrej+0xa8>)
 8017eb8:	69fa      	ldr	r2, [r7, #28]
 8017eba:	0092      	lsls	r2, r2, #2
 8017ebc:	58d3      	ldr	r3, [r2, r3]
 8017ebe:	617b      	str	r3, [r7, #20]
 8017ec0:	697b      	ldr	r3, [r7, #20]
 8017ec2:	2b00      	cmp	r3, #0
 8017ec4:	d1df      	bne.n	8017e86 <lcp_rprotrej+0x46>
    if (pname != NULL)
	ppp_warn("Protocol-Reject for unsupported protocol '%s' (0x%x)", pname,
	     prot);
    else
#endif /* #if PPP_PROTOCOLNAME */
	ppp_warn("Protocol-Reject for unsupported protocol 0x%x", prot);
 8017ec6:	231a      	movs	r3, #26
 8017ec8:	18fb      	adds	r3, r7, r3
 8017eca:	881a      	ldrh	r2, [r3, #0]
 8017ecc:	4b07      	ldr	r3, [pc, #28]	; (8017eec <lcp_rprotrej+0xac>)
 8017ece:	0011      	movs	r1, r2
 8017ed0:	0018      	movs	r0, r3
 8017ed2:	f003 fcb0 	bl	801b836 <ppp_warn>
 8017ed6:	e002      	b.n	8017ede <lcp_rprotrej+0x9e>
	return;
 8017ed8:	46c0      	nop			; (mov r8, r8)
 8017eda:	e000      	b.n	8017ede <lcp_rprotrej+0x9e>
	return;
 8017edc:	46c0      	nop			; (mov r8, r8)
}
 8017ede:	46bd      	mov	sp, r7
 8017ee0:	b008      	add	sp, #32
 8017ee2:	bd80      	pop	{r7, pc}
 8017ee4:	08021cf0 	.word	0x08021cf0
 8017ee8:	08022af4 	.word	0x08022af4
 8017eec:	08021d14 	.word	0x08021d14

08017ef0 <lcp_protrej>:

/*
 * lcp_protrej - A Protocol-Reject was received.
 */
/*ARGSUSED*/
static void lcp_protrej(ppp_pcb *pcb) {
 8017ef0:	b580      	push	{r7, lr}
 8017ef2:	b082      	sub	sp, #8
 8017ef4:	af00      	add	r7, sp, #0
 8017ef6:	6078      	str	r0, [r7, #4]
    /*
     * Can't reject LCP!
     */
    ppp_error("Received Protocol-Reject for LCP!");
 8017ef8:	4b06      	ldr	r3, [pc, #24]	; (8017f14 <lcp_protrej+0x24>)
 8017efa:	0018      	movs	r0, r3
 8017efc:	f003 fc87 	bl	801b80e <ppp_error>
    fsm_protreject(&pcb->lcp_fsm);
 8017f00:	687b      	ldr	r3, [r7, #4]
 8017f02:	3328      	adds	r3, #40	; 0x28
 8017f04:	0018      	movs	r0, r3
 8017f06:	f7fd f8ed 	bl	80150e4 <fsm_protreject>
}
 8017f0a:	46c0      	nop			; (mov r8, r8)
 8017f0c:	46bd      	mov	sp, r7
 8017f0e:	b002      	add	sp, #8
 8017f10:	bd80      	pop	{r7, pc}
 8017f12:	46c0      	nop			; (mov r8, r8)
 8017f14:	08021d44 	.word	0x08021d44

08017f18 <lcp_sprotrej>:


/*
 * lcp_sprotrej - Send a Protocol-Reject for some protocol.
 */
void lcp_sprotrej(ppp_pcb *pcb, u_char *p, int len) {
 8017f18:	b580      	push	{r7, lr}
 8017f1a:	b088      	sub	sp, #32
 8017f1c:	af02      	add	r7, sp, #8
 8017f1e:	60f8      	str	r0, [r7, #12]
 8017f20:	60b9      	str	r1, [r7, #8]
 8017f22:	607a      	str	r2, [r7, #4]
    fsm *f = &pcb->lcp_fsm;
 8017f24:	68fb      	ldr	r3, [r7, #12]
 8017f26:	3328      	adds	r3, #40	; 0x28
 8017f28:	617b      	str	r3, [r7, #20]
#if 0
    p += 2;
    len -= 2;
#endif

    fsm_sdata(f, PROTREJ, ++f->id,
 8017f2a:	697b      	ldr	r3, [r7, #20]
 8017f2c:	7c9b      	ldrb	r3, [r3, #18]
 8017f2e:	3301      	adds	r3, #1
 8017f30:	b2da      	uxtb	r2, r3
 8017f32:	697b      	ldr	r3, [r7, #20]
 8017f34:	749a      	strb	r2, [r3, #18]
 8017f36:	697b      	ldr	r3, [r7, #20]
 8017f38:	7c9a      	ldrb	r2, [r3, #18]
 8017f3a:	68b9      	ldr	r1, [r7, #8]
 8017f3c:	6978      	ldr	r0, [r7, #20]
 8017f3e:	687b      	ldr	r3, [r7, #4]
 8017f40:	9300      	str	r3, [sp, #0]
 8017f42:	000b      	movs	r3, r1
 8017f44:	2108      	movs	r1, #8
 8017f46:	f7fd fa0b 	bl	8015360 <fsm_sdata>
	      p, len);
}
 8017f4a:	46c0      	nop			; (mov r8, r8)
 8017f4c:	46bd      	mov	sp, r7
 8017f4e:	b006      	add	sp, #24
 8017f50:	bd80      	pop	{r7, pc}
	...

08017f54 <lcp_resetci>:


/*
 * lcp_resetci - Reset our CI.
 */
static void lcp_resetci(fsm *f) {
 8017f54:	b590      	push	{r4, r7, lr}
 8017f56:	b087      	sub	sp, #28
 8017f58:	af00      	add	r7, sp, #0
 8017f5a:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8017f5c:	687b      	ldr	r3, [r7, #4]
 8017f5e:	681b      	ldr	r3, [r3, #0]
 8017f60:	617b      	str	r3, [r7, #20]
    lcp_options *wo = &pcb->lcp_wantoptions;
 8017f62:	697b      	ldr	r3, [r7, #20]
 8017f64:	3344      	adds	r3, #68	; 0x44
 8017f66:	613b      	str	r3, [r7, #16]
    lcp_options *go = &pcb->lcp_gotoptions;
 8017f68:	697b      	ldr	r3, [r7, #20]
 8017f6a:	3368      	adds	r3, #104	; 0x68
 8017f6c:	60fb      	str	r3, [r7, #12]
    lcp_options *ao = &pcb->lcp_allowoptions;
 8017f6e:	697b      	ldr	r3, [r7, #20]
 8017f70:	338c      	adds	r3, #140	; 0x8c
 8017f72:	60bb      	str	r3, [r7, #8]
#endif /* EAP_SUPPORT */
    PPPDEBUG(LOG_DEBUG, ("\n"));

#endif /* PPP_AUTH_SUPPORT */

    wo->magicnumber = magic();
 8017f74:	f001 fe36 	bl	8019be4 <magic>
 8017f78:	0002      	movs	r2, r0
 8017f7a:	693b      	ldr	r3, [r7, #16]
 8017f7c:	609a      	str	r2, [r3, #8]
    wo->numloops = 0;
 8017f7e:	693b      	ldr	r3, [r7, #16]
 8017f80:	2200      	movs	r2, #0
 8017f82:	731a      	strb	r2, [r3, #12]
    *go = *wo;
 8017f84:	68fb      	ldr	r3, [r7, #12]
 8017f86:	693a      	ldr	r2, [r7, #16]
 8017f88:	ca13      	ldmia	r2!, {r0, r1, r4}
 8017f8a:	c313      	stmia	r3!, {r0, r1, r4}
 8017f8c:	ca13      	ldmia	r2!, {r0, r1, r4}
 8017f8e:	c313      	stmia	r3!, {r0, r1, r4}
 8017f90:	ca13      	ldmia	r2!, {r0, r1, r4}
 8017f92:	c313      	stmia	r3!, {r0, r1, r4}
#ifdef HAVE_MULTILINK
    if (!multilink) {
	go->neg_mrru = 0;
#endif /* HAVE_MULTILINK */
	go->neg_ssnhf = 0;
 8017f94:	68fb      	ldr	r3, [r7, #12]
 8017f96:	785a      	ldrb	r2, [r3, #1]
 8017f98:	2101      	movs	r1, #1
 8017f9a:	438a      	bics	r2, r1
 8017f9c:	705a      	strb	r2, [r3, #1]
	go->neg_endpoint = 0;
 8017f9e:	68fb      	ldr	r3, [r7, #12]
 8017fa0:	785a      	ldrb	r2, [r3, #1]
 8017fa2:	2102      	movs	r1, #2
 8017fa4:	438a      	bics	r2, r1
 8017fa6:	705a      	strb	r2, [r3, #1]
#ifdef HAVE_MULTILINK
    }
#endif /* HAVE_MULTILINK */
    if (pcb->settings.noendpoint)
 8017fa8:	697b      	ldr	r3, [r7, #20]
 8017faa:	781b      	ldrb	r3, [r3, #0]
 8017fac:	2210      	movs	r2, #16
 8017fae:	4013      	ands	r3, r2
 8017fb0:	b2db      	uxtb	r3, r3
 8017fb2:	2b00      	cmp	r3, #0
 8017fb4:	d004      	beq.n	8017fc0 <lcp_resetci+0x6c>
	ao->neg_endpoint = 0;
 8017fb6:	68bb      	ldr	r3, [r7, #8]
 8017fb8:	785a      	ldrb	r2, [r3, #1]
 8017fba:	2102      	movs	r1, #2
 8017fbc:	438a      	bics	r2, r1
 8017fbe:	705a      	strb	r2, [r3, #1]
    pcb->peer_mru = PPP_MRU;
 8017fc0:	697b      	ldr	r3, [r7, #20]
 8017fc2:	22d4      	movs	r2, #212	; 0xd4
 8017fc4:	4902      	ldr	r1, [pc, #8]	; (8017fd0 <lcp_resetci+0x7c>)
 8017fc6:	5299      	strh	r1, [r3, r2]
#if 0 /* UNUSED */
    auth_reset(pcb);
#endif /* UNUSED */
}
 8017fc8:	46c0      	nop			; (mov r8, r8)
 8017fca:	46bd      	mov	sp, r7
 8017fcc:	b007      	add	sp, #28
 8017fce:	bd90      	pop	{r4, r7, pc}
 8017fd0:	000005dc 	.word	0x000005dc

08017fd4 <lcp_cilen>:


/*
 * lcp_cilen - Return length of our CI.
 */
static int lcp_cilen(fsm *f) {
 8017fd4:	b580      	push	{r7, lr}
 8017fd6:	b084      	sub	sp, #16
 8017fd8:	af00      	add	r7, sp, #0
 8017fda:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8017fdc:	687b      	ldr	r3, [r7, #4]
 8017fde:	681b      	ldr	r3, [r3, #0]
 8017fe0:	60fb      	str	r3, [r7, #12]
    lcp_options *go = &pcb->lcp_gotoptions;
 8017fe2:	68fb      	ldr	r3, [r7, #12]
 8017fe4:	3368      	adds	r3, #104	; 0x68
 8017fe6:	60bb      	str	r3, [r7, #8]
    /*
     * NB: we only ask for one of CHAP, UPAP, or EAP, even if we will
     * accept more than one.  We prefer EAP first, then CHAP, then
     * PAP.
     */
    return (LENCISHORT(go->neg_mru && go->mru != PPP_DEFMRU) +
 8017fe8:	68bb      	ldr	r3, [r7, #8]
 8017fea:	781b      	ldrb	r3, [r3, #0]
 8017fec:	2204      	movs	r2, #4
 8017fee:	4013      	ands	r3, r2
 8017ff0:	b2db      	uxtb	r3, r3
 8017ff2:	2b00      	cmp	r3, #0
 8017ff4:	d006      	beq.n	8018004 <lcp_cilen+0x30>
 8017ff6:	68bb      	ldr	r3, [r7, #8]
 8017ff8:	885b      	ldrh	r3, [r3, #2]
 8017ffa:	4a29      	ldr	r2, [pc, #164]	; (80180a0 <lcp_cilen+0xcc>)
 8017ffc:	4293      	cmp	r3, r2
 8017ffe:	d001      	beq.n	8018004 <lcp_cilen+0x30>
 8018000:	2204      	movs	r2, #4
 8018002:	e000      	b.n	8018006 <lcp_cilen+0x32>
 8018004:	2200      	movs	r2, #0
	    LENCILONG(go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF) +
 8018006:	68bb      	ldr	r3, [r7, #8]
 8018008:	781b      	ldrb	r3, [r3, #0]
 801800a:	2108      	movs	r1, #8
 801800c:	400b      	ands	r3, r1
 801800e:	b2db      	uxtb	r3, r3
 8018010:	2b00      	cmp	r3, #0
 8018012:	d005      	beq.n	8018020 <lcp_cilen+0x4c>
 8018014:	68bb      	ldr	r3, [r7, #8]
 8018016:	685b      	ldr	r3, [r3, #4]
 8018018:	3301      	adds	r3, #1
 801801a:	d001      	beq.n	8018020 <lcp_cilen+0x4c>
 801801c:	2306      	movs	r3, #6
 801801e:	e000      	b.n	8018022 <lcp_cilen+0x4e>
 8018020:	2300      	movs	r3, #0
    return (LENCISHORT(go->neg_mru && go->mru != PPP_DEFMRU) +
 8018022:	18d2      	adds	r2, r2, r3
#endif /* !EAP_SUPPORT && !CHAP_SUPPORT */
#endif /* PAP_SUPPORT */
#if LQR_SUPPORT
	    LENCILQR(go->neg_lqr) +
#endif /* LQR_SUPPORT */
	    LENCICBCP(go->neg_cbcp) +
 8018024:	68bb      	ldr	r3, [r7, #8]
 8018026:	781b      	ldrb	r3, [r3, #0]
 8018028:	217f      	movs	r1, #127	; 0x7f
 801802a:	438b      	bics	r3, r1
 801802c:	b2db      	uxtb	r3, r3
 801802e:	2b00      	cmp	r3, #0
 8018030:	d001      	beq.n	8018036 <lcp_cilen+0x62>
 8018032:	2303      	movs	r3, #3
 8018034:	e000      	b.n	8018038 <lcp_cilen+0x64>
 8018036:	2300      	movs	r3, #0
	    LENCILONG(go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF) +
 8018038:	189a      	adds	r2, r3, r2
	    LENCILONG(go->neg_magicnumber) +
 801803a:	68bb      	ldr	r3, [r7, #8]
 801803c:	781b      	ldrb	r3, [r3, #0]
 801803e:	2110      	movs	r1, #16
 8018040:	400b      	ands	r3, r1
 8018042:	b2db      	uxtb	r3, r3
 8018044:	2b00      	cmp	r3, #0
 8018046:	d001      	beq.n	801804c <lcp_cilen+0x78>
 8018048:	2306      	movs	r3, #6
 801804a:	e000      	b.n	801804e <lcp_cilen+0x7a>
 801804c:	2300      	movs	r3, #0
	    LENCICBCP(go->neg_cbcp) +
 801804e:	189a      	adds	r2, r3, r2
	    LENCIVOID(go->neg_pcompression) +
 8018050:	68bb      	ldr	r3, [r7, #8]
 8018052:	781b      	ldrb	r3, [r3, #0]
 8018054:	091b      	lsrs	r3, r3, #4
 8018056:	b2db      	uxtb	r3, r3
 8018058:	0019      	movs	r1, r3
 801805a:	2302      	movs	r3, #2
 801805c:	400b      	ands	r3, r1
	    LENCILONG(go->neg_magicnumber) +
 801805e:	18d2      	adds	r2, r2, r3
	    LENCIVOID(go->neg_accompression) +
 8018060:	68bb      	ldr	r3, [r7, #8]
 8018062:	781b      	ldrb	r3, [r3, #0]
 8018064:	095b      	lsrs	r3, r3, #5
 8018066:	b2db      	uxtb	r3, r3
 8018068:	0019      	movs	r1, r3
 801806a:	2302      	movs	r3, #2
 801806c:	400b      	ands	r3, r1
	    LENCIVOID(go->neg_pcompression) +
 801806e:	18d2      	adds	r2, r2, r3
#ifdef HAVE_MULTILINK
	    LENCISHORT(go->neg_mrru) +
#endif /* HAVE_MULTILINK */
	    LENCIVOID(go->neg_ssnhf) +
 8018070:	68bb      	ldr	r3, [r7, #8]
 8018072:	785b      	ldrb	r3, [r3, #1]
 8018074:	005b      	lsls	r3, r3, #1
 8018076:	2102      	movs	r1, #2
 8018078:	400b      	ands	r3, r1
	    LENCIVOID(go->neg_accompression) +
 801807a:	18d2      	adds	r2, r2, r3
	    (go->neg_endpoint? CILEN_CHAR + go->endpoint.length: 0));
 801807c:	68bb      	ldr	r3, [r7, #8]
 801807e:	785b      	ldrb	r3, [r3, #1]
 8018080:	2102      	movs	r1, #2
 8018082:	400b      	ands	r3, r1
 8018084:	b2db      	uxtb	r3, r3
 8018086:	2b00      	cmp	r3, #0
 8018088:	d003      	beq.n	8018092 <lcp_cilen+0xbe>
 801808a:	68bb      	ldr	r3, [r7, #8]
 801808c:	7b9b      	ldrb	r3, [r3, #14]
 801808e:	3303      	adds	r3, #3
 8018090:	e000      	b.n	8018094 <lcp_cilen+0xc0>
 8018092:	2300      	movs	r3, #0
	    LENCIVOID(go->neg_ssnhf) +
 8018094:	189b      	adds	r3, r3, r2
}
 8018096:	0018      	movs	r0, r3
 8018098:	46bd      	mov	sp, r7
 801809a:	b004      	add	sp, #16
 801809c:	bd80      	pop	{r7, pc}
 801809e:	46c0      	nop			; (mov r8, r8)
 80180a0:	000005dc 	.word	0x000005dc

080180a4 <lcp_addci>:


/*
 * lcp_addci - Add our desired CIs to a packet.
 */
static void lcp_addci(fsm *f, u_char *ucp, int *lenp) {
 80180a4:	b580      	push	{r7, lr}
 80180a6:	b088      	sub	sp, #32
 80180a8:	af00      	add	r7, sp, #0
 80180aa:	60f8      	str	r0, [r7, #12]
 80180ac:	60b9      	str	r1, [r7, #8]
 80180ae:	607a      	str	r2, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 80180b0:	68fb      	ldr	r3, [r7, #12]
 80180b2:	681b      	ldr	r3, [r3, #0]
 80180b4:	61bb      	str	r3, [r7, #24]
    lcp_options *go = &pcb->lcp_gotoptions;
 80180b6:	69bb      	ldr	r3, [r7, #24]
 80180b8:	3368      	adds	r3, #104	; 0x68
 80180ba:	617b      	str	r3, [r7, #20]
    u_char *start_ucp = ucp;
 80180bc:	68bb      	ldr	r3, [r7, #8]
 80180be:	613b      	str	r3, [r7, #16]
	PUTCHAR(class, ucp); \
	for (i = 0; i < len; ++i) \
	    PUTCHAR(val[i], ucp); \
    }

    ADDCISHORT(CI_MRU, go->neg_mru && go->mru != PPP_DEFMRU, go->mru);
 80180c0:	697b      	ldr	r3, [r7, #20]
 80180c2:	781b      	ldrb	r3, [r3, #0]
 80180c4:	2204      	movs	r2, #4
 80180c6:	4013      	ands	r3, r2
 80180c8:	b2db      	uxtb	r3, r3
 80180ca:	2b00      	cmp	r3, #0
 80180cc:	d01e      	beq.n	801810c <lcp_addci+0x68>
 80180ce:	697b      	ldr	r3, [r7, #20]
 80180d0:	885b      	ldrh	r3, [r3, #2]
 80180d2:	4a84      	ldr	r2, [pc, #528]	; (80182e4 <lcp_addci+0x240>)
 80180d4:	4293      	cmp	r3, r2
 80180d6:	d019      	beq.n	801810c <lcp_addci+0x68>
 80180d8:	68bb      	ldr	r3, [r7, #8]
 80180da:	1c5a      	adds	r2, r3, #1
 80180dc:	60ba      	str	r2, [r7, #8]
 80180de:	2201      	movs	r2, #1
 80180e0:	701a      	strb	r2, [r3, #0]
 80180e2:	68bb      	ldr	r3, [r7, #8]
 80180e4:	1c5a      	adds	r2, r3, #1
 80180e6:	60ba      	str	r2, [r7, #8]
 80180e8:	2204      	movs	r2, #4
 80180ea:	701a      	strb	r2, [r3, #0]
 80180ec:	697b      	ldr	r3, [r7, #20]
 80180ee:	885b      	ldrh	r3, [r3, #2]
 80180f0:	0a1b      	lsrs	r3, r3, #8
 80180f2:	b299      	uxth	r1, r3
 80180f4:	68bb      	ldr	r3, [r7, #8]
 80180f6:	1c5a      	adds	r2, r3, #1
 80180f8:	60ba      	str	r2, [r7, #8]
 80180fa:	b2ca      	uxtb	r2, r1
 80180fc:	701a      	strb	r2, [r3, #0]
 80180fe:	697b      	ldr	r3, [r7, #20]
 8018100:	8859      	ldrh	r1, [r3, #2]
 8018102:	68bb      	ldr	r3, [r7, #8]
 8018104:	1c5a      	adds	r2, r3, #1
 8018106:	60ba      	str	r2, [r7, #8]
 8018108:	b2ca      	uxtb	r2, r1
 801810a:	701a      	strb	r2, [r3, #0]
    ADDCILONG(CI_ASYNCMAP, go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF,
 801810c:	697b      	ldr	r3, [r7, #20]
 801810e:	781b      	ldrb	r3, [r3, #0]
 8018110:	2208      	movs	r2, #8
 8018112:	4013      	ands	r3, r2
 8018114:	b2db      	uxtb	r3, r3
 8018116:	2b00      	cmp	r3, #0
 8018118:	d02c      	beq.n	8018174 <lcp_addci+0xd0>
 801811a:	697b      	ldr	r3, [r7, #20]
 801811c:	685b      	ldr	r3, [r3, #4]
 801811e:	3301      	adds	r3, #1
 8018120:	d028      	beq.n	8018174 <lcp_addci+0xd0>
 8018122:	68bb      	ldr	r3, [r7, #8]
 8018124:	1c5a      	adds	r2, r3, #1
 8018126:	60ba      	str	r2, [r7, #8]
 8018128:	2202      	movs	r2, #2
 801812a:	701a      	strb	r2, [r3, #0]
 801812c:	68bb      	ldr	r3, [r7, #8]
 801812e:	1c5a      	adds	r2, r3, #1
 8018130:	60ba      	str	r2, [r7, #8]
 8018132:	2206      	movs	r2, #6
 8018134:	701a      	strb	r2, [r3, #0]
 8018136:	697b      	ldr	r3, [r7, #20]
 8018138:	685b      	ldr	r3, [r3, #4]
 801813a:	0e19      	lsrs	r1, r3, #24
 801813c:	68bb      	ldr	r3, [r7, #8]
 801813e:	1c5a      	adds	r2, r3, #1
 8018140:	60ba      	str	r2, [r7, #8]
 8018142:	b2ca      	uxtb	r2, r1
 8018144:	701a      	strb	r2, [r3, #0]
 8018146:	697b      	ldr	r3, [r7, #20]
 8018148:	685b      	ldr	r3, [r3, #4]
 801814a:	0c19      	lsrs	r1, r3, #16
 801814c:	68bb      	ldr	r3, [r7, #8]
 801814e:	1c5a      	adds	r2, r3, #1
 8018150:	60ba      	str	r2, [r7, #8]
 8018152:	b2ca      	uxtb	r2, r1
 8018154:	701a      	strb	r2, [r3, #0]
 8018156:	697b      	ldr	r3, [r7, #20]
 8018158:	685b      	ldr	r3, [r3, #4]
 801815a:	0a19      	lsrs	r1, r3, #8
 801815c:	68bb      	ldr	r3, [r7, #8]
 801815e:	1c5a      	adds	r2, r3, #1
 8018160:	60ba      	str	r2, [r7, #8]
 8018162:	b2ca      	uxtb	r2, r1
 8018164:	701a      	strb	r2, [r3, #0]
 8018166:	697b      	ldr	r3, [r7, #20]
 8018168:	6859      	ldr	r1, [r3, #4]
 801816a:	68bb      	ldr	r3, [r7, #8]
 801816c:	1c5a      	adds	r2, r3, #1
 801816e:	60ba      	str	r2, [r7, #8]
 8018170:	b2ca      	uxtb	r2, r1
 8018172:	701a      	strb	r2, [r3, #0]
#endif /* !EAP_SUPPORT && !CHAP_SUPPORT */
#endif /* PAP_SUPPORT */
#if LQR_SUPPORT
    ADDCILQR(CI_QUALITY, go->neg_lqr, go->lqr_period);
#endif /* LQR_SUPPORT */
    ADDCICHAR(CI_CALLBACK, go->neg_cbcp, CBCP_OPT);
 8018174:	697b      	ldr	r3, [r7, #20]
 8018176:	781b      	ldrb	r3, [r3, #0]
 8018178:	227f      	movs	r2, #127	; 0x7f
 801817a:	4393      	bics	r3, r2
 801817c:	b2db      	uxtb	r3, r3
 801817e:	2b00      	cmp	r3, #0
 8018180:	d00e      	beq.n	80181a0 <lcp_addci+0xfc>
 8018182:	68bb      	ldr	r3, [r7, #8]
 8018184:	1c5a      	adds	r2, r3, #1
 8018186:	60ba      	str	r2, [r7, #8]
 8018188:	220d      	movs	r2, #13
 801818a:	701a      	strb	r2, [r3, #0]
 801818c:	68bb      	ldr	r3, [r7, #8]
 801818e:	1c5a      	adds	r2, r3, #1
 8018190:	60ba      	str	r2, [r7, #8]
 8018192:	2203      	movs	r2, #3
 8018194:	701a      	strb	r2, [r3, #0]
 8018196:	68bb      	ldr	r3, [r7, #8]
 8018198:	1c5a      	adds	r2, r3, #1
 801819a:	60ba      	str	r2, [r7, #8]
 801819c:	2206      	movs	r2, #6
 801819e:	701a      	strb	r2, [r3, #0]
    ADDCILONG(CI_MAGICNUMBER, go->neg_magicnumber, go->magicnumber);
 80181a0:	697b      	ldr	r3, [r7, #20]
 80181a2:	781b      	ldrb	r3, [r3, #0]
 80181a4:	2210      	movs	r2, #16
 80181a6:	4013      	ands	r3, r2
 80181a8:	b2db      	uxtb	r3, r3
 80181aa:	2b00      	cmp	r3, #0
 80181ac:	d028      	beq.n	8018200 <lcp_addci+0x15c>
 80181ae:	68bb      	ldr	r3, [r7, #8]
 80181b0:	1c5a      	adds	r2, r3, #1
 80181b2:	60ba      	str	r2, [r7, #8]
 80181b4:	2205      	movs	r2, #5
 80181b6:	701a      	strb	r2, [r3, #0]
 80181b8:	68bb      	ldr	r3, [r7, #8]
 80181ba:	1c5a      	adds	r2, r3, #1
 80181bc:	60ba      	str	r2, [r7, #8]
 80181be:	2206      	movs	r2, #6
 80181c0:	701a      	strb	r2, [r3, #0]
 80181c2:	697b      	ldr	r3, [r7, #20]
 80181c4:	689b      	ldr	r3, [r3, #8]
 80181c6:	0e19      	lsrs	r1, r3, #24
 80181c8:	68bb      	ldr	r3, [r7, #8]
 80181ca:	1c5a      	adds	r2, r3, #1
 80181cc:	60ba      	str	r2, [r7, #8]
 80181ce:	b2ca      	uxtb	r2, r1
 80181d0:	701a      	strb	r2, [r3, #0]
 80181d2:	697b      	ldr	r3, [r7, #20]
 80181d4:	689b      	ldr	r3, [r3, #8]
 80181d6:	0c19      	lsrs	r1, r3, #16
 80181d8:	68bb      	ldr	r3, [r7, #8]
 80181da:	1c5a      	adds	r2, r3, #1
 80181dc:	60ba      	str	r2, [r7, #8]
 80181de:	b2ca      	uxtb	r2, r1
 80181e0:	701a      	strb	r2, [r3, #0]
 80181e2:	697b      	ldr	r3, [r7, #20]
 80181e4:	689b      	ldr	r3, [r3, #8]
 80181e6:	0a19      	lsrs	r1, r3, #8
 80181e8:	68bb      	ldr	r3, [r7, #8]
 80181ea:	1c5a      	adds	r2, r3, #1
 80181ec:	60ba      	str	r2, [r7, #8]
 80181ee:	b2ca      	uxtb	r2, r1
 80181f0:	701a      	strb	r2, [r3, #0]
 80181f2:	697b      	ldr	r3, [r7, #20]
 80181f4:	6899      	ldr	r1, [r3, #8]
 80181f6:	68bb      	ldr	r3, [r7, #8]
 80181f8:	1c5a      	adds	r2, r3, #1
 80181fa:	60ba      	str	r2, [r7, #8]
 80181fc:	b2ca      	uxtb	r2, r1
 80181fe:	701a      	strb	r2, [r3, #0]
    ADDCIVOID(CI_PCOMPRESSION, go->neg_pcompression);
 8018200:	697b      	ldr	r3, [r7, #20]
 8018202:	781b      	ldrb	r3, [r3, #0]
 8018204:	2220      	movs	r2, #32
 8018206:	4013      	ands	r3, r2
 8018208:	b2db      	uxtb	r3, r3
 801820a:	2b00      	cmp	r3, #0
 801820c:	d009      	beq.n	8018222 <lcp_addci+0x17e>
 801820e:	68bb      	ldr	r3, [r7, #8]
 8018210:	1c5a      	adds	r2, r3, #1
 8018212:	60ba      	str	r2, [r7, #8]
 8018214:	2207      	movs	r2, #7
 8018216:	701a      	strb	r2, [r3, #0]
 8018218:	68bb      	ldr	r3, [r7, #8]
 801821a:	1c5a      	adds	r2, r3, #1
 801821c:	60ba      	str	r2, [r7, #8]
 801821e:	2202      	movs	r2, #2
 8018220:	701a      	strb	r2, [r3, #0]
    ADDCIVOID(CI_ACCOMPRESSION, go->neg_accompression);
 8018222:	697b      	ldr	r3, [r7, #20]
 8018224:	781b      	ldrb	r3, [r3, #0]
 8018226:	2240      	movs	r2, #64	; 0x40
 8018228:	4013      	ands	r3, r2
 801822a:	b2db      	uxtb	r3, r3
 801822c:	2b00      	cmp	r3, #0
 801822e:	d009      	beq.n	8018244 <lcp_addci+0x1a0>
 8018230:	68bb      	ldr	r3, [r7, #8]
 8018232:	1c5a      	adds	r2, r3, #1
 8018234:	60ba      	str	r2, [r7, #8]
 8018236:	2208      	movs	r2, #8
 8018238:	701a      	strb	r2, [r3, #0]
 801823a:	68bb      	ldr	r3, [r7, #8]
 801823c:	1c5a      	adds	r2, r3, #1
 801823e:	60ba      	str	r2, [r7, #8]
 8018240:	2202      	movs	r2, #2
 8018242:	701a      	strb	r2, [r3, #0]
#ifdef HAVE_MULTILINK
    ADDCISHORT(CI_MRRU, go->neg_mrru, go->mrru);
#endif
    ADDCIVOID(CI_SSNHF, go->neg_ssnhf);
 8018244:	697b      	ldr	r3, [r7, #20]
 8018246:	785b      	ldrb	r3, [r3, #1]
 8018248:	2201      	movs	r2, #1
 801824a:	4013      	ands	r3, r2
 801824c:	b2db      	uxtb	r3, r3
 801824e:	2b00      	cmp	r3, #0
 8018250:	d009      	beq.n	8018266 <lcp_addci+0x1c2>
 8018252:	68bb      	ldr	r3, [r7, #8]
 8018254:	1c5a      	adds	r2, r3, #1
 8018256:	60ba      	str	r2, [r7, #8]
 8018258:	2212      	movs	r2, #18
 801825a:	701a      	strb	r2, [r3, #0]
 801825c:	68bb      	ldr	r3, [r7, #8]
 801825e:	1c5a      	adds	r2, r3, #1
 8018260:	60ba      	str	r2, [r7, #8]
 8018262:	2202      	movs	r2, #2
 8018264:	701a      	strb	r2, [r3, #0]
    ADDCIENDP(CI_EPDISC, go->neg_endpoint, go->endpoint.class_,
 8018266:	697b      	ldr	r3, [r7, #20]
 8018268:	785b      	ldrb	r3, [r3, #1]
 801826a:	2202      	movs	r2, #2
 801826c:	4013      	ands	r3, r2
 801826e:	b2db      	uxtb	r3, r3
 8018270:	2b00      	cmp	r3, #0
 8018272:	d027      	beq.n	80182c4 <lcp_addci+0x220>
 8018274:	68bb      	ldr	r3, [r7, #8]
 8018276:	1c5a      	adds	r2, r3, #1
 8018278:	60ba      	str	r2, [r7, #8]
 801827a:	2213      	movs	r2, #19
 801827c:	701a      	strb	r2, [r3, #0]
 801827e:	697b      	ldr	r3, [r7, #20]
 8018280:	7b9a      	ldrb	r2, [r3, #14]
 8018282:	68bb      	ldr	r3, [r7, #8]
 8018284:	1c59      	adds	r1, r3, #1
 8018286:	60b9      	str	r1, [r7, #8]
 8018288:	3203      	adds	r2, #3
 801828a:	b2d2      	uxtb	r2, r2
 801828c:	701a      	strb	r2, [r3, #0]
 801828e:	68bb      	ldr	r3, [r7, #8]
 8018290:	1c5a      	adds	r2, r3, #1
 8018292:	60ba      	str	r2, [r7, #8]
 8018294:	697a      	ldr	r2, [r7, #20]
 8018296:	7b52      	ldrb	r2, [r2, #13]
 8018298:	701a      	strb	r2, [r3, #0]
 801829a:	2300      	movs	r3, #0
 801829c:	61fb      	str	r3, [r7, #28]
 801829e:	e00b      	b.n	80182b8 <lcp_addci+0x214>
 80182a0:	68bb      	ldr	r3, [r7, #8]
 80182a2:	1c5a      	adds	r2, r3, #1
 80182a4:	60ba      	str	r2, [r7, #8]
 80182a6:	6979      	ldr	r1, [r7, #20]
 80182a8:	69fa      	ldr	r2, [r7, #28]
 80182aa:	188a      	adds	r2, r1, r2
 80182ac:	320f      	adds	r2, #15
 80182ae:	7812      	ldrb	r2, [r2, #0]
 80182b0:	701a      	strb	r2, [r3, #0]
 80182b2:	69fb      	ldr	r3, [r7, #28]
 80182b4:	3301      	adds	r3, #1
 80182b6:	61fb      	str	r3, [r7, #28]
 80182b8:	697b      	ldr	r3, [r7, #20]
 80182ba:	7b9b      	ldrb	r3, [r3, #14]
 80182bc:	001a      	movs	r2, r3
 80182be:	69fb      	ldr	r3, [r7, #28]
 80182c0:	4293      	cmp	r3, r2
 80182c2:	dbed      	blt.n	80182a0 <lcp_addci+0x1fc>
	      go->endpoint.value, go->endpoint.length);

    if (ucp - start_ucp != *lenp) {
 80182c4:	68ba      	ldr	r2, [r7, #8]
 80182c6:	693b      	ldr	r3, [r7, #16]
 80182c8:	1ad2      	subs	r2, r2, r3
 80182ca:	687b      	ldr	r3, [r7, #4]
 80182cc:	681b      	ldr	r3, [r3, #0]
 80182ce:	429a      	cmp	r2, r3
 80182d0:	d003      	beq.n	80182da <lcp_addci+0x236>
	/* this should never happen, because peer_mtu should be 1500 */
	ppp_error("Bug in lcp_addci: wrong length");
 80182d2:	4b05      	ldr	r3, [pc, #20]	; (80182e8 <lcp_addci+0x244>)
 80182d4:	0018      	movs	r0, r3
 80182d6:	f003 fa9a 	bl	801b80e <ppp_error>
    }
}
 80182da:	46c0      	nop			; (mov r8, r8)
 80182dc:	46bd      	mov	sp, r7
 80182de:	b008      	add	sp, #32
 80182e0:	bd80      	pop	{r7, pc}
 80182e2:	46c0      	nop			; (mov r8, r8)
 80182e4:	000005dc 	.word	0x000005dc
 80182e8:	08021d68 	.word	0x08021d68

080182ec <lcp_ackci>:
 *
 * Returns:
 *	0 - Ack was bad.
 *	1 - Ack was good.
 */
static int lcp_ackci(fsm *f, u_char *p, int len) {
 80182ec:	b580      	push	{r7, lr}
 80182ee:	b08a      	sub	sp, #40	; 0x28
 80182f0:	af00      	add	r7, sp, #0
 80182f2:	60f8      	str	r0, [r7, #12]
 80182f4:	60b9      	str	r1, [r7, #8]
 80182f6:	607a      	str	r2, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 80182f8:	68fb      	ldr	r3, [r7, #12]
 80182fa:	681b      	ldr	r3, [r3, #0]
 80182fc:	623b      	str	r3, [r7, #32]
    lcp_options *go = &pcb->lcp_gotoptions;
 80182fe:	6a3b      	ldr	r3, [r7, #32]
 8018300:	3368      	adds	r3, #104	; 0x68
 8018302:	61fb      	str	r3, [r7, #28]
	    if (cichar != val[i]) \
		goto bad; \
	} \
    }

    ACKCISHORT(CI_MRU, go->neg_mru && go->mru != PPP_DEFMRU, go->mru);
 8018304:	69fb      	ldr	r3, [r7, #28]
 8018306:	781b      	ldrb	r3, [r3, #0]
 8018308:	2204      	movs	r2, #4
 801830a:	4013      	ands	r3, r2
 801830c:	b2db      	uxtb	r3, r3
 801830e:	2b00      	cmp	r3, #0
 8018310:	d03d      	beq.n	801838e <lcp_ackci+0xa2>
 8018312:	69fb      	ldr	r3, [r7, #28]
 8018314:	885b      	ldrh	r3, [r3, #2]
 8018316:	4adf      	ldr	r2, [pc, #892]	; (8018694 <lcp_ackci+0x3a8>)
 8018318:	4293      	cmp	r3, r2
 801831a:	d038      	beq.n	801838e <lcp_ackci+0xa2>
 801831c:	687b      	ldr	r3, [r7, #4]
 801831e:	3b04      	subs	r3, #4
 8018320:	607b      	str	r3, [r7, #4]
 8018322:	687b      	ldr	r3, [r7, #4]
 8018324:	2b00      	cmp	r3, #0
 8018326:	da00      	bge.n	801832a <lcp_ackci+0x3e>
 8018328:	e1d4      	b.n	80186d4 <lcp_ackci+0x3e8>
 801832a:	68bb      	ldr	r3, [r7, #8]
 801832c:	1c5a      	adds	r2, r3, #1
 801832e:	60ba      	str	r2, [r7, #8]
 8018330:	211b      	movs	r1, #27
 8018332:	187a      	adds	r2, r7, r1
 8018334:	781b      	ldrb	r3, [r3, #0]
 8018336:	7013      	strb	r3, [r2, #0]
 8018338:	68bb      	ldr	r3, [r7, #8]
 801833a:	1c5a      	adds	r2, r3, #1
 801833c:	60ba      	str	r2, [r7, #8]
 801833e:	201a      	movs	r0, #26
 8018340:	183a      	adds	r2, r7, r0
 8018342:	781b      	ldrb	r3, [r3, #0]
 8018344:	7013      	strb	r3, [r2, #0]
 8018346:	183b      	adds	r3, r7, r0
 8018348:	781b      	ldrb	r3, [r3, #0]
 801834a:	2b04      	cmp	r3, #4
 801834c:	d000      	beq.n	8018350 <lcp_ackci+0x64>
 801834e:	e1c3      	b.n	80186d8 <lcp_ackci+0x3ec>
 8018350:	187b      	adds	r3, r7, r1
 8018352:	781b      	ldrb	r3, [r3, #0]
 8018354:	2b01      	cmp	r3, #1
 8018356:	d000      	beq.n	801835a <lcp_ackci+0x6e>
 8018358:	e1be      	b.n	80186d8 <lcp_ackci+0x3ec>
 801835a:	68bb      	ldr	r3, [r7, #8]
 801835c:	1c5a      	adds	r2, r3, #1
 801835e:	60ba      	str	r2, [r7, #8]
 8018360:	781b      	ldrb	r3, [r3, #0]
 8018362:	b29a      	uxth	r2, r3
 8018364:	2018      	movs	r0, #24
 8018366:	183b      	adds	r3, r7, r0
 8018368:	0212      	lsls	r2, r2, #8
 801836a:	801a      	strh	r2, [r3, #0]
 801836c:	68bb      	ldr	r3, [r7, #8]
 801836e:	1c5a      	adds	r2, r3, #1
 8018370:	60ba      	str	r2, [r7, #8]
 8018372:	781b      	ldrb	r3, [r3, #0]
 8018374:	b299      	uxth	r1, r3
 8018376:	183b      	adds	r3, r7, r0
 8018378:	183a      	adds	r2, r7, r0
 801837a:	8812      	ldrh	r2, [r2, #0]
 801837c:	430a      	orrs	r2, r1
 801837e:	801a      	strh	r2, [r3, #0]
 8018380:	69fb      	ldr	r3, [r7, #28]
 8018382:	885b      	ldrh	r3, [r3, #2]
 8018384:	183a      	adds	r2, r7, r0
 8018386:	8812      	ldrh	r2, [r2, #0]
 8018388:	429a      	cmp	r2, r3
 801838a:	d000      	beq.n	801838e <lcp_ackci+0xa2>
 801838c:	e1a6      	b.n	80186dc <lcp_ackci+0x3f0>
    ACKCILONG(CI_ASYNCMAP, go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF,
 801838e:	69fb      	ldr	r3, [r7, #28]
 8018390:	781b      	ldrb	r3, [r3, #0]
 8018392:	2208      	movs	r2, #8
 8018394:	4013      	ands	r3, r2
 8018396:	b2db      	uxtb	r3, r3
 8018398:	2b00      	cmp	r3, #0
 801839a:	d04c      	beq.n	8018436 <lcp_ackci+0x14a>
 801839c:	69fb      	ldr	r3, [r7, #28]
 801839e:	685b      	ldr	r3, [r3, #4]
 80183a0:	3301      	adds	r3, #1
 80183a2:	d048      	beq.n	8018436 <lcp_ackci+0x14a>
 80183a4:	687b      	ldr	r3, [r7, #4]
 80183a6:	3b06      	subs	r3, #6
 80183a8:	607b      	str	r3, [r7, #4]
 80183aa:	687b      	ldr	r3, [r7, #4]
 80183ac:	2b00      	cmp	r3, #0
 80183ae:	da00      	bge.n	80183b2 <lcp_ackci+0xc6>
 80183b0:	e196      	b.n	80186e0 <lcp_ackci+0x3f4>
 80183b2:	68bb      	ldr	r3, [r7, #8]
 80183b4:	1c5a      	adds	r2, r3, #1
 80183b6:	60ba      	str	r2, [r7, #8]
 80183b8:	211b      	movs	r1, #27
 80183ba:	187a      	adds	r2, r7, r1
 80183bc:	781b      	ldrb	r3, [r3, #0]
 80183be:	7013      	strb	r3, [r2, #0]
 80183c0:	68bb      	ldr	r3, [r7, #8]
 80183c2:	1c5a      	adds	r2, r3, #1
 80183c4:	60ba      	str	r2, [r7, #8]
 80183c6:	201a      	movs	r0, #26
 80183c8:	183a      	adds	r2, r7, r0
 80183ca:	781b      	ldrb	r3, [r3, #0]
 80183cc:	7013      	strb	r3, [r2, #0]
 80183ce:	183b      	adds	r3, r7, r0
 80183d0:	781b      	ldrb	r3, [r3, #0]
 80183d2:	2b06      	cmp	r3, #6
 80183d4:	d000      	beq.n	80183d8 <lcp_ackci+0xec>
 80183d6:	e185      	b.n	80186e4 <lcp_ackci+0x3f8>
 80183d8:	187b      	adds	r3, r7, r1
 80183da:	781b      	ldrb	r3, [r3, #0]
 80183dc:	2b02      	cmp	r3, #2
 80183de:	d000      	beq.n	80183e2 <lcp_ackci+0xf6>
 80183e0:	e180      	b.n	80186e4 <lcp_ackci+0x3f8>
 80183e2:	68bb      	ldr	r3, [r7, #8]
 80183e4:	1c5a      	adds	r2, r3, #1
 80183e6:	60ba      	str	r2, [r7, #8]
 80183e8:	781b      	ldrb	r3, [r3, #0]
 80183ea:	021b      	lsls	r3, r3, #8
 80183ec:	617b      	str	r3, [r7, #20]
 80183ee:	68bb      	ldr	r3, [r7, #8]
 80183f0:	1c5a      	adds	r2, r3, #1
 80183f2:	60ba      	str	r2, [r7, #8]
 80183f4:	781b      	ldrb	r3, [r3, #0]
 80183f6:	001a      	movs	r2, r3
 80183f8:	697b      	ldr	r3, [r7, #20]
 80183fa:	4313      	orrs	r3, r2
 80183fc:	617b      	str	r3, [r7, #20]
 80183fe:	697b      	ldr	r3, [r7, #20]
 8018400:	021b      	lsls	r3, r3, #8
 8018402:	617b      	str	r3, [r7, #20]
 8018404:	68bb      	ldr	r3, [r7, #8]
 8018406:	1c5a      	adds	r2, r3, #1
 8018408:	60ba      	str	r2, [r7, #8]
 801840a:	781b      	ldrb	r3, [r3, #0]
 801840c:	001a      	movs	r2, r3
 801840e:	697b      	ldr	r3, [r7, #20]
 8018410:	4313      	orrs	r3, r2
 8018412:	617b      	str	r3, [r7, #20]
 8018414:	697b      	ldr	r3, [r7, #20]
 8018416:	021b      	lsls	r3, r3, #8
 8018418:	617b      	str	r3, [r7, #20]
 801841a:	68bb      	ldr	r3, [r7, #8]
 801841c:	1c5a      	adds	r2, r3, #1
 801841e:	60ba      	str	r2, [r7, #8]
 8018420:	781b      	ldrb	r3, [r3, #0]
 8018422:	001a      	movs	r2, r3
 8018424:	697b      	ldr	r3, [r7, #20]
 8018426:	4313      	orrs	r3, r2
 8018428:	617b      	str	r3, [r7, #20]
 801842a:	69fb      	ldr	r3, [r7, #28]
 801842c:	685b      	ldr	r3, [r3, #4]
 801842e:	697a      	ldr	r2, [r7, #20]
 8018430:	429a      	cmp	r2, r3
 8018432:	d000      	beq.n	8018436 <lcp_ackci+0x14a>
 8018434:	e158      	b.n	80186e8 <lcp_ackci+0x3fc>
#endif /* !EAP_SUPPORT && !CHAP_SUPPORT */
#endif /* PAP_SUPPORT */
#if LQR_SUPPORT
    ACKCILQR(CI_QUALITY, go->neg_lqr, go->lqr_period);
#endif /* LQR_SUPPORT */
    ACKCICHAR(CI_CALLBACK, go->neg_cbcp, CBCP_OPT);
 8018436:	69fb      	ldr	r3, [r7, #28]
 8018438:	781b      	ldrb	r3, [r3, #0]
 801843a:	227f      	movs	r2, #127	; 0x7f
 801843c:	4393      	bics	r3, r2
 801843e:	b2db      	uxtb	r3, r3
 8018440:	2b00      	cmp	r3, #0
 8018442:	d02a      	beq.n	801849a <lcp_ackci+0x1ae>
 8018444:	687b      	ldr	r3, [r7, #4]
 8018446:	3b03      	subs	r3, #3
 8018448:	607b      	str	r3, [r7, #4]
 801844a:	687b      	ldr	r3, [r7, #4]
 801844c:	2b00      	cmp	r3, #0
 801844e:	da00      	bge.n	8018452 <lcp_ackci+0x166>
 8018450:	e14c      	b.n	80186ec <lcp_ackci+0x400>
 8018452:	68bb      	ldr	r3, [r7, #8]
 8018454:	1c5a      	adds	r2, r3, #1
 8018456:	60ba      	str	r2, [r7, #8]
 8018458:	211b      	movs	r1, #27
 801845a:	187a      	adds	r2, r7, r1
 801845c:	781b      	ldrb	r3, [r3, #0]
 801845e:	7013      	strb	r3, [r2, #0]
 8018460:	68bb      	ldr	r3, [r7, #8]
 8018462:	1c5a      	adds	r2, r3, #1
 8018464:	60ba      	str	r2, [r7, #8]
 8018466:	201a      	movs	r0, #26
 8018468:	183a      	adds	r2, r7, r0
 801846a:	781b      	ldrb	r3, [r3, #0]
 801846c:	7013      	strb	r3, [r2, #0]
 801846e:	183b      	adds	r3, r7, r0
 8018470:	781b      	ldrb	r3, [r3, #0]
 8018472:	2b03      	cmp	r3, #3
 8018474:	d000      	beq.n	8018478 <lcp_ackci+0x18c>
 8018476:	e13b      	b.n	80186f0 <lcp_ackci+0x404>
 8018478:	187b      	adds	r3, r7, r1
 801847a:	781b      	ldrb	r3, [r3, #0]
 801847c:	2b0d      	cmp	r3, #13
 801847e:	d000      	beq.n	8018482 <lcp_ackci+0x196>
 8018480:	e136      	b.n	80186f0 <lcp_ackci+0x404>
 8018482:	68bb      	ldr	r3, [r7, #8]
 8018484:	1c5a      	adds	r2, r3, #1
 8018486:	60ba      	str	r2, [r7, #8]
 8018488:	2113      	movs	r1, #19
 801848a:	187a      	adds	r2, r7, r1
 801848c:	781b      	ldrb	r3, [r3, #0]
 801848e:	7013      	strb	r3, [r2, #0]
 8018490:	187b      	adds	r3, r7, r1
 8018492:	781b      	ldrb	r3, [r3, #0]
 8018494:	2b06      	cmp	r3, #6
 8018496:	d000      	beq.n	801849a <lcp_ackci+0x1ae>
 8018498:	e12c      	b.n	80186f4 <lcp_ackci+0x408>
    ACKCILONG(CI_MAGICNUMBER, go->neg_magicnumber, go->magicnumber);
 801849a:	69fb      	ldr	r3, [r7, #28]
 801849c:	781b      	ldrb	r3, [r3, #0]
 801849e:	2210      	movs	r2, #16
 80184a0:	4013      	ands	r3, r2
 80184a2:	b2db      	uxtb	r3, r3
 80184a4:	2b00      	cmp	r3, #0
 80184a6:	d048      	beq.n	801853a <lcp_ackci+0x24e>
 80184a8:	687b      	ldr	r3, [r7, #4]
 80184aa:	3b06      	subs	r3, #6
 80184ac:	607b      	str	r3, [r7, #4]
 80184ae:	687b      	ldr	r3, [r7, #4]
 80184b0:	2b00      	cmp	r3, #0
 80184b2:	da00      	bge.n	80184b6 <lcp_ackci+0x1ca>
 80184b4:	e120      	b.n	80186f8 <lcp_ackci+0x40c>
 80184b6:	68bb      	ldr	r3, [r7, #8]
 80184b8:	1c5a      	adds	r2, r3, #1
 80184ba:	60ba      	str	r2, [r7, #8]
 80184bc:	211b      	movs	r1, #27
 80184be:	187a      	adds	r2, r7, r1
 80184c0:	781b      	ldrb	r3, [r3, #0]
 80184c2:	7013      	strb	r3, [r2, #0]
 80184c4:	68bb      	ldr	r3, [r7, #8]
 80184c6:	1c5a      	adds	r2, r3, #1
 80184c8:	60ba      	str	r2, [r7, #8]
 80184ca:	201a      	movs	r0, #26
 80184cc:	183a      	adds	r2, r7, r0
 80184ce:	781b      	ldrb	r3, [r3, #0]
 80184d0:	7013      	strb	r3, [r2, #0]
 80184d2:	183b      	adds	r3, r7, r0
 80184d4:	781b      	ldrb	r3, [r3, #0]
 80184d6:	2b06      	cmp	r3, #6
 80184d8:	d000      	beq.n	80184dc <lcp_ackci+0x1f0>
 80184da:	e10f      	b.n	80186fc <lcp_ackci+0x410>
 80184dc:	187b      	adds	r3, r7, r1
 80184de:	781b      	ldrb	r3, [r3, #0]
 80184e0:	2b05      	cmp	r3, #5
 80184e2:	d000      	beq.n	80184e6 <lcp_ackci+0x1fa>
 80184e4:	e10a      	b.n	80186fc <lcp_ackci+0x410>
 80184e6:	68bb      	ldr	r3, [r7, #8]
 80184e8:	1c5a      	adds	r2, r3, #1
 80184ea:	60ba      	str	r2, [r7, #8]
 80184ec:	781b      	ldrb	r3, [r3, #0]
 80184ee:	021b      	lsls	r3, r3, #8
 80184f0:	617b      	str	r3, [r7, #20]
 80184f2:	68bb      	ldr	r3, [r7, #8]
 80184f4:	1c5a      	adds	r2, r3, #1
 80184f6:	60ba      	str	r2, [r7, #8]
 80184f8:	781b      	ldrb	r3, [r3, #0]
 80184fa:	001a      	movs	r2, r3
 80184fc:	697b      	ldr	r3, [r7, #20]
 80184fe:	4313      	orrs	r3, r2
 8018500:	617b      	str	r3, [r7, #20]
 8018502:	697b      	ldr	r3, [r7, #20]
 8018504:	021b      	lsls	r3, r3, #8
 8018506:	617b      	str	r3, [r7, #20]
 8018508:	68bb      	ldr	r3, [r7, #8]
 801850a:	1c5a      	adds	r2, r3, #1
 801850c:	60ba      	str	r2, [r7, #8]
 801850e:	781b      	ldrb	r3, [r3, #0]
 8018510:	001a      	movs	r2, r3
 8018512:	697b      	ldr	r3, [r7, #20]
 8018514:	4313      	orrs	r3, r2
 8018516:	617b      	str	r3, [r7, #20]
 8018518:	697b      	ldr	r3, [r7, #20]
 801851a:	021b      	lsls	r3, r3, #8
 801851c:	617b      	str	r3, [r7, #20]
 801851e:	68bb      	ldr	r3, [r7, #8]
 8018520:	1c5a      	adds	r2, r3, #1
 8018522:	60ba      	str	r2, [r7, #8]
 8018524:	781b      	ldrb	r3, [r3, #0]
 8018526:	001a      	movs	r2, r3
 8018528:	697b      	ldr	r3, [r7, #20]
 801852a:	4313      	orrs	r3, r2
 801852c:	617b      	str	r3, [r7, #20]
 801852e:	69fb      	ldr	r3, [r7, #28]
 8018530:	689b      	ldr	r3, [r3, #8]
 8018532:	697a      	ldr	r2, [r7, #20]
 8018534:	429a      	cmp	r2, r3
 8018536:	d000      	beq.n	801853a <lcp_ackci+0x24e>
 8018538:	e0e2      	b.n	8018700 <lcp_ackci+0x414>
    ACKCIVOID(CI_PCOMPRESSION, go->neg_pcompression);
 801853a:	69fb      	ldr	r3, [r7, #28]
 801853c:	781b      	ldrb	r3, [r3, #0]
 801853e:	2220      	movs	r2, #32
 8018540:	4013      	ands	r3, r2
 8018542:	b2db      	uxtb	r3, r3
 8018544:	2b00      	cmp	r3, #0
 8018546:	d01e      	beq.n	8018586 <lcp_ackci+0x29a>
 8018548:	687b      	ldr	r3, [r7, #4]
 801854a:	3b02      	subs	r3, #2
 801854c:	607b      	str	r3, [r7, #4]
 801854e:	687b      	ldr	r3, [r7, #4]
 8018550:	2b00      	cmp	r3, #0
 8018552:	da00      	bge.n	8018556 <lcp_ackci+0x26a>
 8018554:	e0d6      	b.n	8018704 <lcp_ackci+0x418>
 8018556:	68bb      	ldr	r3, [r7, #8]
 8018558:	1c5a      	adds	r2, r3, #1
 801855a:	60ba      	str	r2, [r7, #8]
 801855c:	211b      	movs	r1, #27
 801855e:	187a      	adds	r2, r7, r1
 8018560:	781b      	ldrb	r3, [r3, #0]
 8018562:	7013      	strb	r3, [r2, #0]
 8018564:	68bb      	ldr	r3, [r7, #8]
 8018566:	1c5a      	adds	r2, r3, #1
 8018568:	60ba      	str	r2, [r7, #8]
 801856a:	201a      	movs	r0, #26
 801856c:	183a      	adds	r2, r7, r0
 801856e:	781b      	ldrb	r3, [r3, #0]
 8018570:	7013      	strb	r3, [r2, #0]
 8018572:	183b      	adds	r3, r7, r0
 8018574:	781b      	ldrb	r3, [r3, #0]
 8018576:	2b02      	cmp	r3, #2
 8018578:	d000      	beq.n	801857c <lcp_ackci+0x290>
 801857a:	e0c5      	b.n	8018708 <lcp_ackci+0x41c>
 801857c:	187b      	adds	r3, r7, r1
 801857e:	781b      	ldrb	r3, [r3, #0]
 8018580:	2b07      	cmp	r3, #7
 8018582:	d000      	beq.n	8018586 <lcp_ackci+0x29a>
 8018584:	e0c0      	b.n	8018708 <lcp_ackci+0x41c>
    ACKCIVOID(CI_ACCOMPRESSION, go->neg_accompression);
 8018586:	69fb      	ldr	r3, [r7, #28]
 8018588:	781b      	ldrb	r3, [r3, #0]
 801858a:	2240      	movs	r2, #64	; 0x40
 801858c:	4013      	ands	r3, r2
 801858e:	b2db      	uxtb	r3, r3
 8018590:	2b00      	cmp	r3, #0
 8018592:	d01e      	beq.n	80185d2 <lcp_ackci+0x2e6>
 8018594:	687b      	ldr	r3, [r7, #4]
 8018596:	3b02      	subs	r3, #2
 8018598:	607b      	str	r3, [r7, #4]
 801859a:	687b      	ldr	r3, [r7, #4]
 801859c:	2b00      	cmp	r3, #0
 801859e:	da00      	bge.n	80185a2 <lcp_ackci+0x2b6>
 80185a0:	e0b4      	b.n	801870c <lcp_ackci+0x420>
 80185a2:	68bb      	ldr	r3, [r7, #8]
 80185a4:	1c5a      	adds	r2, r3, #1
 80185a6:	60ba      	str	r2, [r7, #8]
 80185a8:	211b      	movs	r1, #27
 80185aa:	187a      	adds	r2, r7, r1
 80185ac:	781b      	ldrb	r3, [r3, #0]
 80185ae:	7013      	strb	r3, [r2, #0]
 80185b0:	68bb      	ldr	r3, [r7, #8]
 80185b2:	1c5a      	adds	r2, r3, #1
 80185b4:	60ba      	str	r2, [r7, #8]
 80185b6:	201a      	movs	r0, #26
 80185b8:	183a      	adds	r2, r7, r0
 80185ba:	781b      	ldrb	r3, [r3, #0]
 80185bc:	7013      	strb	r3, [r2, #0]
 80185be:	183b      	adds	r3, r7, r0
 80185c0:	781b      	ldrb	r3, [r3, #0]
 80185c2:	2b02      	cmp	r3, #2
 80185c4:	d000      	beq.n	80185c8 <lcp_ackci+0x2dc>
 80185c6:	e0a3      	b.n	8018710 <lcp_ackci+0x424>
 80185c8:	187b      	adds	r3, r7, r1
 80185ca:	781b      	ldrb	r3, [r3, #0]
 80185cc:	2b08      	cmp	r3, #8
 80185ce:	d000      	beq.n	80185d2 <lcp_ackci+0x2e6>
 80185d0:	e09e      	b.n	8018710 <lcp_ackci+0x424>
#ifdef HAVE_MULTILINK
    ACKCISHORT(CI_MRRU, go->neg_mrru, go->mrru);
#endif /* HAVE_MULTILINK */
    ACKCIVOID(CI_SSNHF, go->neg_ssnhf);
 80185d2:	69fb      	ldr	r3, [r7, #28]
 80185d4:	785b      	ldrb	r3, [r3, #1]
 80185d6:	2201      	movs	r2, #1
 80185d8:	4013      	ands	r3, r2
 80185da:	b2db      	uxtb	r3, r3
 80185dc:	2b00      	cmp	r3, #0
 80185de:	d01e      	beq.n	801861e <lcp_ackci+0x332>
 80185e0:	687b      	ldr	r3, [r7, #4]
 80185e2:	3b02      	subs	r3, #2
 80185e4:	607b      	str	r3, [r7, #4]
 80185e6:	687b      	ldr	r3, [r7, #4]
 80185e8:	2b00      	cmp	r3, #0
 80185ea:	da00      	bge.n	80185ee <lcp_ackci+0x302>
 80185ec:	e092      	b.n	8018714 <lcp_ackci+0x428>
 80185ee:	68bb      	ldr	r3, [r7, #8]
 80185f0:	1c5a      	adds	r2, r3, #1
 80185f2:	60ba      	str	r2, [r7, #8]
 80185f4:	211b      	movs	r1, #27
 80185f6:	187a      	adds	r2, r7, r1
 80185f8:	781b      	ldrb	r3, [r3, #0]
 80185fa:	7013      	strb	r3, [r2, #0]
 80185fc:	68bb      	ldr	r3, [r7, #8]
 80185fe:	1c5a      	adds	r2, r3, #1
 8018600:	60ba      	str	r2, [r7, #8]
 8018602:	201a      	movs	r0, #26
 8018604:	183a      	adds	r2, r7, r0
 8018606:	781b      	ldrb	r3, [r3, #0]
 8018608:	7013      	strb	r3, [r2, #0]
 801860a:	183b      	adds	r3, r7, r0
 801860c:	781b      	ldrb	r3, [r3, #0]
 801860e:	2b02      	cmp	r3, #2
 8018610:	d000      	beq.n	8018614 <lcp_ackci+0x328>
 8018612:	e081      	b.n	8018718 <lcp_ackci+0x42c>
 8018614:	187b      	adds	r3, r7, r1
 8018616:	781b      	ldrb	r3, [r3, #0]
 8018618:	2b12      	cmp	r3, #18
 801861a:	d000      	beq.n	801861e <lcp_ackci+0x332>
 801861c:	e07c      	b.n	8018718 <lcp_ackci+0x42c>
    ACKCIENDP(CI_EPDISC, go->neg_endpoint, go->endpoint.class_,
 801861e:	69fb      	ldr	r3, [r7, #28]
 8018620:	785b      	ldrb	r3, [r3, #1]
 8018622:	2202      	movs	r2, #2
 8018624:	4013      	ands	r3, r2
 8018626:	b2db      	uxtb	r3, r3
 8018628:	2b00      	cmp	r3, #0
 801862a:	d04e      	beq.n	80186ca <lcp_ackci+0x3de>
 801862c:	69fb      	ldr	r3, [r7, #28]
 801862e:	7b9b      	ldrb	r3, [r3, #14]
 8018630:	3303      	adds	r3, #3
 8018632:	687a      	ldr	r2, [r7, #4]
 8018634:	1ad3      	subs	r3, r2, r3
 8018636:	607b      	str	r3, [r7, #4]
 8018638:	687b      	ldr	r3, [r7, #4]
 801863a:	2b00      	cmp	r3, #0
 801863c:	da00      	bge.n	8018640 <lcp_ackci+0x354>
 801863e:	e06d      	b.n	801871c <lcp_ackci+0x430>
 8018640:	68bb      	ldr	r3, [r7, #8]
 8018642:	1c5a      	adds	r2, r3, #1
 8018644:	60ba      	str	r2, [r7, #8]
 8018646:	211b      	movs	r1, #27
 8018648:	187a      	adds	r2, r7, r1
 801864a:	781b      	ldrb	r3, [r3, #0]
 801864c:	7013      	strb	r3, [r2, #0]
 801864e:	68bb      	ldr	r3, [r7, #8]
 8018650:	1c5a      	adds	r2, r3, #1
 8018652:	60ba      	str	r2, [r7, #8]
 8018654:	201a      	movs	r0, #26
 8018656:	183a      	adds	r2, r7, r0
 8018658:	781b      	ldrb	r3, [r3, #0]
 801865a:	7013      	strb	r3, [r2, #0]
 801865c:	183b      	adds	r3, r7, r0
 801865e:	781a      	ldrb	r2, [r3, #0]
 8018660:	69fb      	ldr	r3, [r7, #28]
 8018662:	7b9b      	ldrb	r3, [r3, #14]
 8018664:	3303      	adds	r3, #3
 8018666:	429a      	cmp	r2, r3
 8018668:	d15a      	bne.n	8018720 <lcp_ackci+0x434>
 801866a:	187b      	adds	r3, r7, r1
 801866c:	781b      	ldrb	r3, [r3, #0]
 801866e:	2b13      	cmp	r3, #19
 8018670:	d156      	bne.n	8018720 <lcp_ackci+0x434>
 8018672:	68bb      	ldr	r3, [r7, #8]
 8018674:	1c5a      	adds	r2, r3, #1
 8018676:	60ba      	str	r2, [r7, #8]
 8018678:	2113      	movs	r1, #19
 801867a:	187a      	adds	r2, r7, r1
 801867c:	781b      	ldrb	r3, [r3, #0]
 801867e:	7013      	strb	r3, [r2, #0]
 8018680:	69fb      	ldr	r3, [r7, #28]
 8018682:	7b5b      	ldrb	r3, [r3, #13]
 8018684:	187a      	adds	r2, r7, r1
 8018686:	7812      	ldrb	r2, [r2, #0]
 8018688:	429a      	cmp	r2, r3
 801868a:	d14b      	bne.n	8018724 <lcp_ackci+0x438>
 801868c:	2300      	movs	r3, #0
 801868e:	627b      	str	r3, [r7, #36]	; 0x24
 8018690:	e015      	b.n	80186be <lcp_ackci+0x3d2>
 8018692:	46c0      	nop			; (mov r8, r8)
 8018694:	000005dc 	.word	0x000005dc
 8018698:	68bb      	ldr	r3, [r7, #8]
 801869a:	1c5a      	adds	r2, r3, #1
 801869c:	60ba      	str	r2, [r7, #8]
 801869e:	2113      	movs	r1, #19
 80186a0:	187a      	adds	r2, r7, r1
 80186a2:	781b      	ldrb	r3, [r3, #0]
 80186a4:	7013      	strb	r3, [r2, #0]
 80186a6:	69fa      	ldr	r2, [r7, #28]
 80186a8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80186aa:	18d3      	adds	r3, r2, r3
 80186ac:	330f      	adds	r3, #15
 80186ae:	781b      	ldrb	r3, [r3, #0]
 80186b0:	187a      	adds	r2, r7, r1
 80186b2:	7812      	ldrb	r2, [r2, #0]
 80186b4:	429a      	cmp	r2, r3
 80186b6:	d137      	bne.n	8018728 <lcp_ackci+0x43c>
 80186b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80186ba:	3301      	adds	r3, #1
 80186bc:	627b      	str	r3, [r7, #36]	; 0x24
 80186be:	69fb      	ldr	r3, [r7, #28]
 80186c0:	7b9b      	ldrb	r3, [r3, #14]
 80186c2:	001a      	movs	r2, r3
 80186c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80186c6:	4293      	cmp	r3, r2
 80186c8:	dbe6      	blt.n	8018698 <lcp_ackci+0x3ac>
	      go->endpoint.value, go->endpoint.length);

    /*
     * If there are any remaining CIs, then this packet is bad.
     */
    if (len != 0)
 80186ca:	687b      	ldr	r3, [r7, #4]
 80186cc:	2b00      	cmp	r3, #0
 80186ce:	d12d      	bne.n	801872c <lcp_ackci+0x440>
	goto bad;
    return (1);
 80186d0:	2301      	movs	r3, #1
 80186d2:	e02d      	b.n	8018730 <lcp_ackci+0x444>
    ACKCISHORT(CI_MRU, go->neg_mru && go->mru != PPP_DEFMRU, go->mru);
 80186d4:	46c0      	nop			; (mov r8, r8)
 80186d6:	e02a      	b.n	801872e <lcp_ackci+0x442>
 80186d8:	46c0      	nop			; (mov r8, r8)
 80186da:	e028      	b.n	801872e <lcp_ackci+0x442>
 80186dc:	46c0      	nop			; (mov r8, r8)
 80186de:	e026      	b.n	801872e <lcp_ackci+0x442>
    ACKCILONG(CI_ASYNCMAP, go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF,
 80186e0:	46c0      	nop			; (mov r8, r8)
 80186e2:	e024      	b.n	801872e <lcp_ackci+0x442>
 80186e4:	46c0      	nop			; (mov r8, r8)
 80186e6:	e022      	b.n	801872e <lcp_ackci+0x442>
 80186e8:	46c0      	nop			; (mov r8, r8)
 80186ea:	e020      	b.n	801872e <lcp_ackci+0x442>
    ACKCICHAR(CI_CALLBACK, go->neg_cbcp, CBCP_OPT);
 80186ec:	46c0      	nop			; (mov r8, r8)
 80186ee:	e01e      	b.n	801872e <lcp_ackci+0x442>
 80186f0:	46c0      	nop			; (mov r8, r8)
 80186f2:	e01c      	b.n	801872e <lcp_ackci+0x442>
 80186f4:	46c0      	nop			; (mov r8, r8)
 80186f6:	e01a      	b.n	801872e <lcp_ackci+0x442>
    ACKCILONG(CI_MAGICNUMBER, go->neg_magicnumber, go->magicnumber);
 80186f8:	46c0      	nop			; (mov r8, r8)
 80186fa:	e018      	b.n	801872e <lcp_ackci+0x442>
 80186fc:	46c0      	nop			; (mov r8, r8)
 80186fe:	e016      	b.n	801872e <lcp_ackci+0x442>
 8018700:	46c0      	nop			; (mov r8, r8)
 8018702:	e014      	b.n	801872e <lcp_ackci+0x442>
    ACKCIVOID(CI_PCOMPRESSION, go->neg_pcompression);
 8018704:	46c0      	nop			; (mov r8, r8)
 8018706:	e012      	b.n	801872e <lcp_ackci+0x442>
 8018708:	46c0      	nop			; (mov r8, r8)
 801870a:	e010      	b.n	801872e <lcp_ackci+0x442>
    ACKCIVOID(CI_ACCOMPRESSION, go->neg_accompression);
 801870c:	46c0      	nop			; (mov r8, r8)
 801870e:	e00e      	b.n	801872e <lcp_ackci+0x442>
 8018710:	46c0      	nop			; (mov r8, r8)
 8018712:	e00c      	b.n	801872e <lcp_ackci+0x442>
    ACKCIVOID(CI_SSNHF, go->neg_ssnhf);
 8018714:	46c0      	nop			; (mov r8, r8)
 8018716:	e00a      	b.n	801872e <lcp_ackci+0x442>
 8018718:	46c0      	nop			; (mov r8, r8)
 801871a:	e008      	b.n	801872e <lcp_ackci+0x442>
    ACKCIENDP(CI_EPDISC, go->neg_endpoint, go->endpoint.class_,
 801871c:	46c0      	nop			; (mov r8, r8)
 801871e:	e006      	b.n	801872e <lcp_ackci+0x442>
 8018720:	46c0      	nop			; (mov r8, r8)
 8018722:	e004      	b.n	801872e <lcp_ackci+0x442>
 8018724:	46c0      	nop			; (mov r8, r8)
 8018726:	e002      	b.n	801872e <lcp_ackci+0x442>
 8018728:	46c0      	nop			; (mov r8, r8)
 801872a:	e000      	b.n	801872e <lcp_ackci+0x442>
	goto bad;
 801872c:	46c0      	nop			; (mov r8, r8)
bad:
    LCPDEBUG(("lcp_acki: received bad Ack!"));
    return (0);
 801872e:	2300      	movs	r3, #0
}
 8018730:	0018      	movs	r0, r3
 8018732:	46bd      	mov	sp, r7
 8018734:	b00a      	add	sp, #40	; 0x28
 8018736:	bd80      	pop	{r7, pc}

08018738 <lcp_nakci>:
 *
 * Returns:
 *	0 - Nak was bad.
 *	1 - Nak was good.
 */
static int lcp_nakci(fsm *f, u_char *p, int len, int treat_as_reject) {
 8018738:	b5b0      	push	{r4, r5, r7, lr}
 801873a:	b0a0      	sub	sp, #128	; 0x80
 801873c:	af00      	add	r7, sp, #0
 801873e:	60f8      	str	r0, [r7, #12]
 8018740:	60b9      	str	r1, [r7, #8]
 8018742:	607a      	str	r2, [r7, #4]
 8018744:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 8018746:	68fb      	ldr	r3, [r7, #12]
 8018748:	681b      	ldr	r3, [r3, #0]
 801874a:	67bb      	str	r3, [r7, #120]	; 0x78
    lcp_options *go = &pcb->lcp_gotoptions;
 801874c:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 801874e:	3368      	adds	r3, #104	; 0x68
 8018750:	677b      	str	r3, [r7, #116]	; 0x74
    lcp_options *wo = &pcb->lcp_wantoptions;
 8018752:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8018754:	3344      	adds	r3, #68	; 0x44
 8018756:	673b      	str	r3, [r7, #112]	; 0x70
    u_char citype, cichar, *next;
    u_short cishort;
    u32_t cilong;
    lcp_options no;		/* options we've seen Naks for */
    lcp_options try_;		/* options to request next time */
    int looped_back = 0;
 8018758:	2300      	movs	r3, #0
 801875a:	67fb      	str	r3, [r7, #124]	; 0x7c
    int cilen;

    BZERO(&no, sizeof(no));
 801875c:	2438      	movs	r4, #56	; 0x38
 801875e:	193b      	adds	r3, r7, r4
 8018760:	2224      	movs	r2, #36	; 0x24
 8018762:	2100      	movs	r1, #0
 8018764:	0018      	movs	r0, r3
 8018766:	f004 fbcd 	bl	801cf04 <memset>
    try_ = *go;
 801876a:	2314      	movs	r3, #20
 801876c:	18fb      	adds	r3, r7, r3
 801876e:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8018770:	ca23      	ldmia	r2!, {r0, r1, r5}
 8018772:	c323      	stmia	r3!, {r0, r1, r5}
 8018774:	ca23      	ldmia	r2!, {r0, r1, r5}
 8018776:	c323      	stmia	r3!, {r0, r1, r5}
 8018778:	ca23      	ldmia	r2!, {r0, r1, r5}
 801877a:	c323      	stmia	r3!, {r0, r1, r5}
     * we want.  Therefore, accept any MRU less than what we asked for,
     * but then ignore the new value when setting the MRU in the kernel.
     * If they send us a bigger MRU than what we asked, accept it, up to
     * the limit of the default MRU we'd get if we didn't negotiate.
     */
    if (go->neg_mru && go->mru != PPP_DEFMRU) {
 801877c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801877e:	781b      	ldrb	r3, [r3, #0]
 8018780:	2204      	movs	r2, #4
 8018782:	4013      	ands	r3, r2
 8018784:	b2db      	uxtb	r3, r3
 8018786:	2b00      	cmp	r3, #0
 8018788:	d04a      	beq.n	8018820 <lcp_nakci+0xe8>
 801878a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801878c:	885b      	ldrh	r3, [r3, #2]
 801878e:	4a20      	ldr	r2, [pc, #128]	; (8018810 <lcp_nakci+0xd8>)
 8018790:	4293      	cmp	r3, r2
 8018792:	d045      	beq.n	8018820 <lcp_nakci+0xe8>
	NAKCISHORT(CI_MRU, neg_mru,
 8018794:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018796:	781b      	ldrb	r3, [r3, #0]
 8018798:	2204      	movs	r2, #4
 801879a:	4013      	ands	r3, r2
 801879c:	b2db      	uxtb	r3, r3
 801879e:	2b00      	cmp	r3, #0
 80187a0:	d03e      	beq.n	8018820 <lcp_nakci+0xe8>
 80187a2:	687b      	ldr	r3, [r7, #4]
 80187a4:	2b03      	cmp	r3, #3
 80187a6:	dd3b      	ble.n	8018820 <lcp_nakci+0xe8>
 80187a8:	68bb      	ldr	r3, [r7, #8]
 80187aa:	3301      	adds	r3, #1
 80187ac:	781b      	ldrb	r3, [r3, #0]
 80187ae:	2b04      	cmp	r3, #4
 80187b0:	d136      	bne.n	8018820 <lcp_nakci+0xe8>
 80187b2:	68bb      	ldr	r3, [r7, #8]
 80187b4:	781b      	ldrb	r3, [r3, #0]
 80187b6:	2b01      	cmp	r3, #1
 80187b8:	d132      	bne.n	8018820 <lcp_nakci+0xe8>
 80187ba:	687b      	ldr	r3, [r7, #4]
 80187bc:	3b04      	subs	r3, #4
 80187be:	607b      	str	r3, [r7, #4]
 80187c0:	68bb      	ldr	r3, [r7, #8]
 80187c2:	3302      	adds	r3, #2
 80187c4:	60bb      	str	r3, [r7, #8]
 80187c6:	68bb      	ldr	r3, [r7, #8]
 80187c8:	1c5a      	adds	r2, r3, #1
 80187ca:	60ba      	str	r2, [r7, #8]
 80187cc:	781b      	ldrb	r3, [r3, #0]
 80187ce:	b29a      	uxth	r2, r3
 80187d0:	206e      	movs	r0, #110	; 0x6e
 80187d2:	183b      	adds	r3, r7, r0
 80187d4:	0212      	lsls	r2, r2, #8
 80187d6:	801a      	strh	r2, [r3, #0]
 80187d8:	68bb      	ldr	r3, [r7, #8]
 80187da:	1c5a      	adds	r2, r3, #1
 80187dc:	60ba      	str	r2, [r7, #8]
 80187de:	781b      	ldrb	r3, [r3, #0]
 80187e0:	b299      	uxth	r1, r3
 80187e2:	183b      	adds	r3, r7, r0
 80187e4:	183a      	adds	r2, r7, r0
 80187e6:	8812      	ldrh	r2, [r2, #0]
 80187e8:	430a      	orrs	r2, r1
 80187ea:	801a      	strh	r2, [r3, #0]
 80187ec:	193b      	adds	r3, r7, r4
 80187ee:	781a      	ldrb	r2, [r3, #0]
 80187f0:	2104      	movs	r1, #4
 80187f2:	430a      	orrs	r2, r1
 80187f4:	701a      	strb	r2, [r3, #0]
 80187f6:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80187f8:	885b      	ldrh	r3, [r3, #2]
 80187fa:	183a      	adds	r2, r7, r0
 80187fc:	8812      	ldrh	r2, [r2, #0]
 80187fe:	429a      	cmp	r2, r3
 8018800:	d908      	bls.n	8018814 <lcp_nakci+0xdc>
 8018802:	183b      	adds	r3, r7, r0
 8018804:	881b      	ldrh	r3, [r3, #0]
 8018806:	4a02      	ldr	r2, [pc, #8]	; (8018810 <lcp_nakci+0xd8>)
 8018808:	4293      	cmp	r3, r2
 801880a:	d809      	bhi.n	8018820 <lcp_nakci+0xe8>
 801880c:	e002      	b.n	8018814 <lcp_nakci+0xdc>
 801880e:	46c0      	nop			; (mov r8, r8)
 8018810:	000005dc 	.word	0x000005dc
 8018814:	2314      	movs	r3, #20
 8018816:	18fb      	adds	r3, r7, r3
 8018818:	226e      	movs	r2, #110	; 0x6e
 801881a:	18ba      	adds	r2, r7, r2
 801881c:	8812      	ldrh	r2, [r2, #0]
 801881e:	805a      	strh	r2, [r3, #2]
    }

    /*
     * Add any characters they want to our (receive-side) asyncmap.
     */
    if (go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF) {
 8018820:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018822:	781b      	ldrb	r3, [r3, #0]
 8018824:	2208      	movs	r2, #8
 8018826:	4013      	ands	r3, r2
 8018828:	b2db      	uxtb	r3, r3
 801882a:	2b00      	cmp	r3, #0
 801882c:	d04d      	beq.n	80188ca <lcp_nakci+0x192>
 801882e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018830:	685b      	ldr	r3, [r3, #4]
 8018832:	3301      	adds	r3, #1
 8018834:	d049      	beq.n	80188ca <lcp_nakci+0x192>
	NAKCILONG(CI_ASYNCMAP, neg_asyncmap,
 8018836:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018838:	781b      	ldrb	r3, [r3, #0]
 801883a:	2208      	movs	r2, #8
 801883c:	4013      	ands	r3, r2
 801883e:	b2db      	uxtb	r3, r3
 8018840:	2b00      	cmp	r3, #0
 8018842:	d042      	beq.n	80188ca <lcp_nakci+0x192>
 8018844:	687b      	ldr	r3, [r7, #4]
 8018846:	2b05      	cmp	r3, #5
 8018848:	dd3f      	ble.n	80188ca <lcp_nakci+0x192>
 801884a:	68bb      	ldr	r3, [r7, #8]
 801884c:	3301      	adds	r3, #1
 801884e:	781b      	ldrb	r3, [r3, #0]
 8018850:	2b06      	cmp	r3, #6
 8018852:	d13a      	bne.n	80188ca <lcp_nakci+0x192>
 8018854:	68bb      	ldr	r3, [r7, #8]
 8018856:	781b      	ldrb	r3, [r3, #0]
 8018858:	2b02      	cmp	r3, #2
 801885a:	d136      	bne.n	80188ca <lcp_nakci+0x192>
 801885c:	687b      	ldr	r3, [r7, #4]
 801885e:	3b06      	subs	r3, #6
 8018860:	607b      	str	r3, [r7, #4]
 8018862:	68bb      	ldr	r3, [r7, #8]
 8018864:	3302      	adds	r3, #2
 8018866:	60bb      	str	r3, [r7, #8]
 8018868:	68bb      	ldr	r3, [r7, #8]
 801886a:	1c5a      	adds	r2, r3, #1
 801886c:	60ba      	str	r2, [r7, #8]
 801886e:	781b      	ldrb	r3, [r3, #0]
 8018870:	021b      	lsls	r3, r3, #8
 8018872:	66bb      	str	r3, [r7, #104]	; 0x68
 8018874:	68bb      	ldr	r3, [r7, #8]
 8018876:	1c5a      	adds	r2, r3, #1
 8018878:	60ba      	str	r2, [r7, #8]
 801887a:	781b      	ldrb	r3, [r3, #0]
 801887c:	001a      	movs	r2, r3
 801887e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018880:	4313      	orrs	r3, r2
 8018882:	66bb      	str	r3, [r7, #104]	; 0x68
 8018884:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018886:	021b      	lsls	r3, r3, #8
 8018888:	66bb      	str	r3, [r7, #104]	; 0x68
 801888a:	68bb      	ldr	r3, [r7, #8]
 801888c:	1c5a      	adds	r2, r3, #1
 801888e:	60ba      	str	r2, [r7, #8]
 8018890:	781b      	ldrb	r3, [r3, #0]
 8018892:	001a      	movs	r2, r3
 8018894:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018896:	4313      	orrs	r3, r2
 8018898:	66bb      	str	r3, [r7, #104]	; 0x68
 801889a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801889c:	021b      	lsls	r3, r3, #8
 801889e:	66bb      	str	r3, [r7, #104]	; 0x68
 80188a0:	68bb      	ldr	r3, [r7, #8]
 80188a2:	1c5a      	adds	r2, r3, #1
 80188a4:	60ba      	str	r2, [r7, #8]
 80188a6:	781b      	ldrb	r3, [r3, #0]
 80188a8:	001a      	movs	r2, r3
 80188aa:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80188ac:	4313      	orrs	r3, r2
 80188ae:	66bb      	str	r3, [r7, #104]	; 0x68
 80188b0:	2338      	movs	r3, #56	; 0x38
 80188b2:	18fb      	adds	r3, r7, r3
 80188b4:	781a      	ldrb	r2, [r3, #0]
 80188b6:	2108      	movs	r1, #8
 80188b8:	430a      	orrs	r2, r1
 80188ba:	701a      	strb	r2, [r3, #0]
 80188bc:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80188be:	685a      	ldr	r2, [r3, #4]
 80188c0:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80188c2:	431a      	orrs	r2, r3
 80188c4:	2314      	movs	r3, #20
 80188c6:	18fb      	adds	r3, r7, r3
 80188c8:	605a      	str	r2, [r3, #4]
#endif /* LQR_SUPPORT */

    /*
     * Only implementing CBCP...not the rest of the callback options
     */
    NAKCICHAR(CI_CALLBACK, neg_cbcp,
 80188ca:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80188cc:	781b      	ldrb	r3, [r3, #0]
 80188ce:	227f      	movs	r2, #127	; 0x7f
 80188d0:	4393      	bics	r3, r2
 80188d2:	b2db      	uxtb	r3, r3
 80188d4:	2b00      	cmp	r3, #0
 80188d6:	d025      	beq.n	8018924 <lcp_nakci+0x1ec>
 80188d8:	687b      	ldr	r3, [r7, #4]
 80188da:	2b02      	cmp	r3, #2
 80188dc:	dd22      	ble.n	8018924 <lcp_nakci+0x1ec>
 80188de:	68bb      	ldr	r3, [r7, #8]
 80188e0:	3301      	adds	r3, #1
 80188e2:	781b      	ldrb	r3, [r3, #0]
 80188e4:	2b03      	cmp	r3, #3
 80188e6:	d11d      	bne.n	8018924 <lcp_nakci+0x1ec>
 80188e8:	68bb      	ldr	r3, [r7, #8]
 80188ea:	781b      	ldrb	r3, [r3, #0]
 80188ec:	2b0d      	cmp	r3, #13
 80188ee:	d119      	bne.n	8018924 <lcp_nakci+0x1ec>
 80188f0:	687b      	ldr	r3, [r7, #4]
 80188f2:	3b03      	subs	r3, #3
 80188f4:	607b      	str	r3, [r7, #4]
 80188f6:	68bb      	ldr	r3, [r7, #8]
 80188f8:	3302      	adds	r3, #2
 80188fa:	60bb      	str	r3, [r7, #8]
 80188fc:	68bb      	ldr	r3, [r7, #8]
 80188fe:	1c5a      	adds	r2, r3, #1
 8018900:	60ba      	str	r2, [r7, #8]
 8018902:	2267      	movs	r2, #103	; 0x67
 8018904:	18ba      	adds	r2, r7, r2
 8018906:	781b      	ldrb	r3, [r3, #0]
 8018908:	7013      	strb	r3, [r2, #0]
 801890a:	2338      	movs	r3, #56	; 0x38
 801890c:	18fb      	adds	r3, r7, r3
 801890e:	781a      	ldrb	r2, [r3, #0]
 8018910:	2180      	movs	r1, #128	; 0x80
 8018912:	4249      	negs	r1, r1
 8018914:	430a      	orrs	r2, r1
 8018916:	701a      	strb	r2, [r3, #0]
 8018918:	2314      	movs	r3, #20
 801891a:	18fb      	adds	r3, r7, r3
 801891c:	781a      	ldrb	r2, [r3, #0]
 801891e:	217f      	movs	r1, #127	; 0x7f
 8018920:	400a      	ands	r2, r1
 8018922:	701a      	strb	r2, [r3, #0]
              );

    /*
     * Check for a looped-back line.
     */
    NAKCILONG(CI_MAGICNUMBER, neg_magicnumber,
 8018924:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018926:	781b      	ldrb	r3, [r3, #0]
 8018928:	2210      	movs	r2, #16
 801892a:	4013      	ands	r3, r2
 801892c:	b2db      	uxtb	r3, r3
 801892e:	2b00      	cmp	r3, #0
 8018930:	d043      	beq.n	80189ba <lcp_nakci+0x282>
 8018932:	687b      	ldr	r3, [r7, #4]
 8018934:	2b05      	cmp	r3, #5
 8018936:	dd40      	ble.n	80189ba <lcp_nakci+0x282>
 8018938:	68bb      	ldr	r3, [r7, #8]
 801893a:	3301      	adds	r3, #1
 801893c:	781b      	ldrb	r3, [r3, #0]
 801893e:	2b06      	cmp	r3, #6
 8018940:	d13b      	bne.n	80189ba <lcp_nakci+0x282>
 8018942:	68bb      	ldr	r3, [r7, #8]
 8018944:	781b      	ldrb	r3, [r3, #0]
 8018946:	2b05      	cmp	r3, #5
 8018948:	d137      	bne.n	80189ba <lcp_nakci+0x282>
 801894a:	687b      	ldr	r3, [r7, #4]
 801894c:	3b06      	subs	r3, #6
 801894e:	607b      	str	r3, [r7, #4]
 8018950:	68bb      	ldr	r3, [r7, #8]
 8018952:	3302      	adds	r3, #2
 8018954:	60bb      	str	r3, [r7, #8]
 8018956:	68bb      	ldr	r3, [r7, #8]
 8018958:	1c5a      	adds	r2, r3, #1
 801895a:	60ba      	str	r2, [r7, #8]
 801895c:	781b      	ldrb	r3, [r3, #0]
 801895e:	021b      	lsls	r3, r3, #8
 8018960:	66bb      	str	r3, [r7, #104]	; 0x68
 8018962:	68bb      	ldr	r3, [r7, #8]
 8018964:	1c5a      	adds	r2, r3, #1
 8018966:	60ba      	str	r2, [r7, #8]
 8018968:	781b      	ldrb	r3, [r3, #0]
 801896a:	001a      	movs	r2, r3
 801896c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801896e:	4313      	orrs	r3, r2
 8018970:	66bb      	str	r3, [r7, #104]	; 0x68
 8018972:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018974:	021b      	lsls	r3, r3, #8
 8018976:	66bb      	str	r3, [r7, #104]	; 0x68
 8018978:	68bb      	ldr	r3, [r7, #8]
 801897a:	1c5a      	adds	r2, r3, #1
 801897c:	60ba      	str	r2, [r7, #8]
 801897e:	781b      	ldrb	r3, [r3, #0]
 8018980:	001a      	movs	r2, r3
 8018982:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018984:	4313      	orrs	r3, r2
 8018986:	66bb      	str	r3, [r7, #104]	; 0x68
 8018988:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801898a:	021b      	lsls	r3, r3, #8
 801898c:	66bb      	str	r3, [r7, #104]	; 0x68
 801898e:	68bb      	ldr	r3, [r7, #8]
 8018990:	1c5a      	adds	r2, r3, #1
 8018992:	60ba      	str	r2, [r7, #8]
 8018994:	781b      	ldrb	r3, [r3, #0]
 8018996:	001a      	movs	r2, r3
 8018998:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801899a:	4313      	orrs	r3, r2
 801899c:	66bb      	str	r3, [r7, #104]	; 0x68
 801899e:	2338      	movs	r3, #56	; 0x38
 80189a0:	18fb      	adds	r3, r7, r3
 80189a2:	781a      	ldrb	r2, [r3, #0]
 80189a4:	2110      	movs	r1, #16
 80189a6:	430a      	orrs	r2, r1
 80189a8:	701a      	strb	r2, [r3, #0]
 80189aa:	f001 f91b 	bl	8019be4 <magic>
 80189ae:	0002      	movs	r2, r0
 80189b0:	2314      	movs	r3, #20
 80189b2:	18fb      	adds	r3, r7, r3
 80189b4:	609a      	str	r2, [r3, #8]
 80189b6:	2301      	movs	r3, #1
 80189b8:	67fb      	str	r3, [r7, #124]	; 0x7c
    /*
     * Peer shouldn't send Nak for protocol compression or
     * address/control compression requests; they should send
     * a Reject instead.  If they send a Nak, treat it as a Reject.
     */
    NAKCIVOID(CI_PCOMPRESSION, neg_pcompression);
 80189ba:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80189bc:	781b      	ldrb	r3, [r3, #0]
 80189be:	2220      	movs	r2, #32
 80189c0:	4013      	ands	r3, r2
 80189c2:	b2db      	uxtb	r3, r3
 80189c4:	2b00      	cmp	r3, #0
 80189c6:	d01d      	beq.n	8018a04 <lcp_nakci+0x2cc>
 80189c8:	687b      	ldr	r3, [r7, #4]
 80189ca:	2b01      	cmp	r3, #1
 80189cc:	dd1a      	ble.n	8018a04 <lcp_nakci+0x2cc>
 80189ce:	68bb      	ldr	r3, [r7, #8]
 80189d0:	3301      	adds	r3, #1
 80189d2:	781b      	ldrb	r3, [r3, #0]
 80189d4:	2b02      	cmp	r3, #2
 80189d6:	d115      	bne.n	8018a04 <lcp_nakci+0x2cc>
 80189d8:	68bb      	ldr	r3, [r7, #8]
 80189da:	781b      	ldrb	r3, [r3, #0]
 80189dc:	2b07      	cmp	r3, #7
 80189de:	d111      	bne.n	8018a04 <lcp_nakci+0x2cc>
 80189e0:	687b      	ldr	r3, [r7, #4]
 80189e2:	3b02      	subs	r3, #2
 80189e4:	607b      	str	r3, [r7, #4]
 80189e6:	68bb      	ldr	r3, [r7, #8]
 80189e8:	3302      	adds	r3, #2
 80189ea:	60bb      	str	r3, [r7, #8]
 80189ec:	2338      	movs	r3, #56	; 0x38
 80189ee:	18fb      	adds	r3, r7, r3
 80189f0:	781a      	ldrb	r2, [r3, #0]
 80189f2:	2120      	movs	r1, #32
 80189f4:	430a      	orrs	r2, r1
 80189f6:	701a      	strb	r2, [r3, #0]
 80189f8:	2314      	movs	r3, #20
 80189fa:	18fb      	adds	r3, r7, r3
 80189fc:	781a      	ldrb	r2, [r3, #0]
 80189fe:	2120      	movs	r1, #32
 8018a00:	438a      	bics	r2, r1
 8018a02:	701a      	strb	r2, [r3, #0]
    NAKCIVOID(CI_ACCOMPRESSION, neg_accompression);
 8018a04:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018a06:	781b      	ldrb	r3, [r3, #0]
 8018a08:	2240      	movs	r2, #64	; 0x40
 8018a0a:	4013      	ands	r3, r2
 8018a0c:	b2db      	uxtb	r3, r3
 8018a0e:	2b00      	cmp	r3, #0
 8018a10:	d01d      	beq.n	8018a4e <lcp_nakci+0x316>
 8018a12:	687b      	ldr	r3, [r7, #4]
 8018a14:	2b01      	cmp	r3, #1
 8018a16:	dd1a      	ble.n	8018a4e <lcp_nakci+0x316>
 8018a18:	68bb      	ldr	r3, [r7, #8]
 8018a1a:	3301      	adds	r3, #1
 8018a1c:	781b      	ldrb	r3, [r3, #0]
 8018a1e:	2b02      	cmp	r3, #2
 8018a20:	d115      	bne.n	8018a4e <lcp_nakci+0x316>
 8018a22:	68bb      	ldr	r3, [r7, #8]
 8018a24:	781b      	ldrb	r3, [r3, #0]
 8018a26:	2b08      	cmp	r3, #8
 8018a28:	d111      	bne.n	8018a4e <lcp_nakci+0x316>
 8018a2a:	687b      	ldr	r3, [r7, #4]
 8018a2c:	3b02      	subs	r3, #2
 8018a2e:	607b      	str	r3, [r7, #4]
 8018a30:	68bb      	ldr	r3, [r7, #8]
 8018a32:	3302      	adds	r3, #2
 8018a34:	60bb      	str	r3, [r7, #8]
 8018a36:	2338      	movs	r3, #56	; 0x38
 8018a38:	18fb      	adds	r3, r7, r3
 8018a3a:	781a      	ldrb	r2, [r3, #0]
 8018a3c:	2140      	movs	r1, #64	; 0x40
 8018a3e:	430a      	orrs	r2, r1
 8018a40:	701a      	strb	r2, [r3, #0]
 8018a42:	2314      	movs	r3, #20
 8018a44:	18fb      	adds	r3, r7, r3
 8018a46:	781a      	ldrb	r2, [r3, #0]
 8018a48:	2140      	movs	r1, #64	; 0x40
 8018a4a:	438a      	bics	r2, r1
 8018a4c:	701a      	strb	r2, [r3, #0]

    /*
     * Nak for short sequence numbers shouldn't be sent, treat it
     * like a reject.
     */
    NAKCIVOID(CI_SSNHF, neg_ssnhf);
 8018a4e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018a50:	785b      	ldrb	r3, [r3, #1]
 8018a52:	2201      	movs	r2, #1
 8018a54:	4013      	ands	r3, r2
 8018a56:	b2db      	uxtb	r3, r3
 8018a58:	2b00      	cmp	r3, #0
 8018a5a:	d01d      	beq.n	8018a98 <lcp_nakci+0x360>
 8018a5c:	687b      	ldr	r3, [r7, #4]
 8018a5e:	2b01      	cmp	r3, #1
 8018a60:	dd1a      	ble.n	8018a98 <lcp_nakci+0x360>
 8018a62:	68bb      	ldr	r3, [r7, #8]
 8018a64:	3301      	adds	r3, #1
 8018a66:	781b      	ldrb	r3, [r3, #0]
 8018a68:	2b02      	cmp	r3, #2
 8018a6a:	d115      	bne.n	8018a98 <lcp_nakci+0x360>
 8018a6c:	68bb      	ldr	r3, [r7, #8]
 8018a6e:	781b      	ldrb	r3, [r3, #0]
 8018a70:	2b12      	cmp	r3, #18
 8018a72:	d111      	bne.n	8018a98 <lcp_nakci+0x360>
 8018a74:	687b      	ldr	r3, [r7, #4]
 8018a76:	3b02      	subs	r3, #2
 8018a78:	607b      	str	r3, [r7, #4]
 8018a7a:	68bb      	ldr	r3, [r7, #8]
 8018a7c:	3302      	adds	r3, #2
 8018a7e:	60bb      	str	r3, [r7, #8]
 8018a80:	2338      	movs	r3, #56	; 0x38
 8018a82:	18fb      	adds	r3, r7, r3
 8018a84:	785a      	ldrb	r2, [r3, #1]
 8018a86:	2101      	movs	r1, #1
 8018a88:	430a      	orrs	r2, r1
 8018a8a:	705a      	strb	r2, [r3, #1]
 8018a8c:	2314      	movs	r3, #20
 8018a8e:	18fb      	adds	r3, r7, r3
 8018a90:	785a      	ldrb	r2, [r3, #1]
 8018a92:	2101      	movs	r1, #1
 8018a94:	438a      	bics	r2, r1
 8018a96:	705a      	strb	r2, [r3, #1]

    /*
     * Nak of the endpoint discriminator option is not permitted,
     * treat it like a reject.
     */
    NAKCIENDP(CI_EPDISC, neg_endpoint);
 8018a98:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018a9a:	785b      	ldrb	r3, [r3, #1]
 8018a9c:	2202      	movs	r2, #2
 8018a9e:	4013      	ands	r3, r2
 8018aa0:	b2db      	uxtb	r3, r3
 8018aa2:	2b00      	cmp	r3, #0
 8018aa4:	d100      	bne.n	8018aa8 <lcp_nakci+0x370>
 8018aa6:	e12b      	b.n	8018d00 <lcp_nakci+0x5c8>
 8018aa8:	687b      	ldr	r3, [r7, #4]
 8018aaa:	2b02      	cmp	r3, #2
 8018aac:	dc00      	bgt.n	8018ab0 <lcp_nakci+0x378>
 8018aae:	e127      	b.n	8018d00 <lcp_nakci+0x5c8>
 8018ab0:	68bb      	ldr	r3, [r7, #8]
 8018ab2:	781b      	ldrb	r3, [r3, #0]
 8018ab4:	2b13      	cmp	r3, #19
 8018ab6:	d000      	beq.n	8018aba <lcp_nakci+0x382>
 8018ab8:	e122      	b.n	8018d00 <lcp_nakci+0x5c8>
 8018aba:	68bb      	ldr	r3, [r7, #8]
 8018abc:	3301      	adds	r3, #1
 8018abe:	781b      	ldrb	r3, [r3, #0]
 8018ac0:	2b02      	cmp	r3, #2
 8018ac2:	d800      	bhi.n	8018ac6 <lcp_nakci+0x38e>
 8018ac4:	e11c      	b.n	8018d00 <lcp_nakci+0x5c8>
 8018ac6:	68bb      	ldr	r3, [r7, #8]
 8018ac8:	3301      	adds	r3, #1
 8018aca:	781b      	ldrb	r3, [r3, #0]
 8018acc:	001a      	movs	r2, r3
 8018ace:	687b      	ldr	r3, [r7, #4]
 8018ad0:	4293      	cmp	r3, r2
 8018ad2:	da00      	bge.n	8018ad6 <lcp_nakci+0x39e>
 8018ad4:	e114      	b.n	8018d00 <lcp_nakci+0x5c8>
 8018ad6:	68bb      	ldr	r3, [r7, #8]
 8018ad8:	3301      	adds	r3, #1
 8018ada:	781b      	ldrb	r3, [r3, #0]
 8018adc:	001a      	movs	r2, r3
 8018ade:	687b      	ldr	r3, [r7, #4]
 8018ae0:	1a9b      	subs	r3, r3, r2
 8018ae2:	607b      	str	r3, [r7, #4]
 8018ae4:	68bb      	ldr	r3, [r7, #8]
 8018ae6:	3301      	adds	r3, #1
 8018ae8:	781b      	ldrb	r3, [r3, #0]
 8018aea:	001a      	movs	r2, r3
 8018aec:	68bb      	ldr	r3, [r7, #8]
 8018aee:	189b      	adds	r3, r3, r2
 8018af0:	60bb      	str	r3, [r7, #8]
 8018af2:	2338      	movs	r3, #56	; 0x38
 8018af4:	18fb      	adds	r3, r7, r3
 8018af6:	785a      	ldrb	r2, [r3, #1]
 8018af8:	2102      	movs	r1, #2
 8018afa:	430a      	orrs	r2, r1
 8018afc:	705a      	strb	r2, [r3, #1]
 8018afe:	2314      	movs	r3, #20
 8018b00:	18fb      	adds	r3, r7, r3
 8018b02:	785a      	ldrb	r2, [r3, #1]
 8018b04:	2102      	movs	r1, #2
 8018b06:	438a      	bics	r2, r1
 8018b08:	705a      	strb	r2, [r3, #1]
     * For the quality protocol, the Nak means `ask me to send you quality
     * reports', but if we didn't ask for them, we don't want them.
     * An option we don't recognize represents the peer asking to
     * negotiate some option we don't support, so ignore it.
     */
    while (len >= CILEN_VOID) {
 8018b0a:	e0f9      	b.n	8018d00 <lcp_nakci+0x5c8>
	GETCHAR(citype, p);
 8018b0c:	68bb      	ldr	r3, [r7, #8]
 8018b0e:	1c5a      	adds	r2, r3, #1
 8018b10:	60ba      	str	r2, [r7, #8]
 8018b12:	2166      	movs	r1, #102	; 0x66
 8018b14:	187a      	adds	r2, r7, r1
 8018b16:	781b      	ldrb	r3, [r3, #0]
 8018b18:	7013      	strb	r3, [r2, #0]
	GETCHAR(cilen, p);
 8018b1a:	68bb      	ldr	r3, [r7, #8]
 8018b1c:	1c5a      	adds	r2, r3, #1
 8018b1e:	60ba      	str	r2, [r7, #8]
 8018b20:	781b      	ldrb	r3, [r3, #0]
 8018b22:	663b      	str	r3, [r7, #96]	; 0x60
	if (cilen < CILEN_VOID || (len -= cilen) < 0)
 8018b24:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8018b26:	2b01      	cmp	r3, #1
 8018b28:	dc00      	bgt.n	8018b2c <lcp_nakci+0x3f4>
 8018b2a:	e120      	b.n	8018d6e <lcp_nakci+0x636>
 8018b2c:	687a      	ldr	r2, [r7, #4]
 8018b2e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8018b30:	1ad3      	subs	r3, r2, r3
 8018b32:	607b      	str	r3, [r7, #4]
 8018b34:	687b      	ldr	r3, [r7, #4]
 8018b36:	2b00      	cmp	r3, #0
 8018b38:	da00      	bge.n	8018b3c <lcp_nakci+0x404>
 8018b3a:	e118      	b.n	8018d6e <lcp_nakci+0x636>
	    goto bad;
	next = p + cilen - 2;
 8018b3c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8018b3e:	3b02      	subs	r3, #2
 8018b40:	68ba      	ldr	r2, [r7, #8]
 8018b42:	18d3      	adds	r3, r2, r3
 8018b44:	65fb      	str	r3, [r7, #92]	; 0x5c

	switch (citype) {
 8018b46:	187b      	adds	r3, r7, r1
 8018b48:	781b      	ldrb	r3, [r3, #0]
 8018b4a:	2b13      	cmp	r3, #19
 8018b4c:	d900      	bls.n	8018b50 <lcp_nakci+0x418>
 8018b4e:	e0ca      	b.n	8018ce6 <lcp_nakci+0x5ae>
 8018b50:	009a      	lsls	r2, r3, #2
 8018b52:	4b91      	ldr	r3, [pc, #580]	; (8018d98 <lcp_nakci+0x660>)
 8018b54:	18d3      	adds	r3, r2, r3
 8018b56:	681b      	ldr	r3, [r3, #0]
 8018b58:	469f      	mov	pc, r3
	case CI_MRU:
	    if ((go->neg_mru && go->mru != PPP_DEFMRU)
 8018b5a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018b5c:	781b      	ldrb	r3, [r3, #0]
 8018b5e:	2204      	movs	r2, #4
 8018b60:	4013      	ands	r3, r2
 8018b62:	b2db      	uxtb	r3, r3
 8018b64:	2b00      	cmp	r3, #0
 8018b66:	d005      	beq.n	8018b74 <lcp_nakci+0x43c>
 8018b68:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018b6a:	885b      	ldrh	r3, [r3, #2]
 8018b6c:	4a8b      	ldr	r2, [pc, #556]	; (8018d9c <lcp_nakci+0x664>)
 8018b6e:	4293      	cmp	r3, r2
 8018b70:	d000      	beq.n	8018b74 <lcp_nakci+0x43c>
 8018b72:	e0fe      	b.n	8018d72 <lcp_nakci+0x63a>
		|| no.neg_mru || cilen != CILEN_SHORT)
 8018b74:	2338      	movs	r3, #56	; 0x38
 8018b76:	18fb      	adds	r3, r7, r3
 8018b78:	781b      	ldrb	r3, [r3, #0]
 8018b7a:	2204      	movs	r2, #4
 8018b7c:	4013      	ands	r3, r2
 8018b7e:	b2db      	uxtb	r3, r3
 8018b80:	2b00      	cmp	r3, #0
 8018b82:	d000      	beq.n	8018b86 <lcp_nakci+0x44e>
 8018b84:	e0f5      	b.n	8018d72 <lcp_nakci+0x63a>
 8018b86:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8018b88:	2b04      	cmp	r3, #4
 8018b8a:	d000      	beq.n	8018b8e <lcp_nakci+0x456>
 8018b8c:	e0f1      	b.n	8018d72 <lcp_nakci+0x63a>
		goto bad;
	    GETSHORT(cishort, p);
 8018b8e:	68bb      	ldr	r3, [r7, #8]
 8018b90:	1c5a      	adds	r2, r3, #1
 8018b92:	60ba      	str	r2, [r7, #8]
 8018b94:	781b      	ldrb	r3, [r3, #0]
 8018b96:	b29a      	uxth	r2, r3
 8018b98:	206e      	movs	r0, #110	; 0x6e
 8018b9a:	183b      	adds	r3, r7, r0
 8018b9c:	0212      	lsls	r2, r2, #8
 8018b9e:	801a      	strh	r2, [r3, #0]
 8018ba0:	68bb      	ldr	r3, [r7, #8]
 8018ba2:	1c5a      	adds	r2, r3, #1
 8018ba4:	60ba      	str	r2, [r7, #8]
 8018ba6:	781b      	ldrb	r3, [r3, #0]
 8018ba8:	b299      	uxth	r1, r3
 8018baa:	183b      	adds	r3, r7, r0
 8018bac:	183a      	adds	r2, r7, r0
 8018bae:	8812      	ldrh	r2, [r2, #0]
 8018bb0:	430a      	orrs	r2, r1
 8018bb2:	801a      	strh	r2, [r3, #0]
	    if (cishort < PPP_DEFMRU) {
 8018bb4:	183b      	adds	r3, r7, r0
 8018bb6:	881b      	ldrh	r3, [r3, #0]
 8018bb8:	4a79      	ldr	r2, [pc, #484]	; (8018da0 <lcp_nakci+0x668>)
 8018bba:	4293      	cmp	r3, r2
 8018bbc:	d900      	bls.n	8018bc0 <lcp_nakci+0x488>
 8018bbe:	e094      	b.n	8018cea <lcp_nakci+0x5b2>
		try_.neg_mru = 1;
 8018bc0:	2414      	movs	r4, #20
 8018bc2:	193b      	adds	r3, r7, r4
 8018bc4:	781a      	ldrb	r2, [r3, #0]
 8018bc6:	2104      	movs	r1, #4
 8018bc8:	430a      	orrs	r2, r1
 8018bca:	701a      	strb	r2, [r3, #0]
		try_.mru = cishort;
 8018bcc:	193b      	adds	r3, r7, r4
 8018bce:	183a      	adds	r2, r7, r0
 8018bd0:	8812      	ldrh	r2, [r2, #0]
 8018bd2:	805a      	strh	r2, [r3, #2]
	    }
	    break;
 8018bd4:	e089      	b.n	8018cea <lcp_nakci+0x5b2>
	case CI_ASYNCMAP:
	    if ((go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF)
 8018bd6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018bd8:	781b      	ldrb	r3, [r3, #0]
 8018bda:	2208      	movs	r2, #8
 8018bdc:	4013      	ands	r3, r2
 8018bde:	b2db      	uxtb	r3, r3
 8018be0:	2b00      	cmp	r3, #0
 8018be2:	d004      	beq.n	8018bee <lcp_nakci+0x4b6>
 8018be4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018be6:	685b      	ldr	r3, [r3, #4]
 8018be8:	3301      	adds	r3, #1
 8018bea:	d000      	beq.n	8018bee <lcp_nakci+0x4b6>
 8018bec:	e0c3      	b.n	8018d76 <lcp_nakci+0x63e>
		|| no.neg_asyncmap || cilen != CILEN_LONG)
 8018bee:	2338      	movs	r3, #56	; 0x38
 8018bf0:	18fb      	adds	r3, r7, r3
 8018bf2:	781b      	ldrb	r3, [r3, #0]
 8018bf4:	2208      	movs	r2, #8
 8018bf6:	4013      	ands	r3, r2
 8018bf8:	b2db      	uxtb	r3, r3
 8018bfa:	2b00      	cmp	r3, #0
 8018bfc:	d000      	beq.n	8018c00 <lcp_nakci+0x4c8>
 8018bfe:	e0ba      	b.n	8018d76 <lcp_nakci+0x63e>
 8018c00:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8018c02:	2b06      	cmp	r3, #6
 8018c04:	d100      	bne.n	8018c08 <lcp_nakci+0x4d0>
 8018c06:	e072      	b.n	8018cee <lcp_nakci+0x5b6>
		goto bad;
 8018c08:	e0b5      	b.n	8018d76 <lcp_nakci+0x63e>
#endif /* EAP_SUPPORT */
		)
		goto bad;
	    break;
	case CI_MAGICNUMBER:
	    if (go->neg_magicnumber || no.neg_magicnumber ||
 8018c0a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018c0c:	781b      	ldrb	r3, [r3, #0]
 8018c0e:	2210      	movs	r2, #16
 8018c10:	4013      	ands	r3, r2
 8018c12:	b2db      	uxtb	r3, r3
 8018c14:	2b00      	cmp	r3, #0
 8018c16:	d000      	beq.n	8018c1a <lcp_nakci+0x4e2>
 8018c18:	e0af      	b.n	8018d7a <lcp_nakci+0x642>
 8018c1a:	2338      	movs	r3, #56	; 0x38
 8018c1c:	18fb      	adds	r3, r7, r3
 8018c1e:	781b      	ldrb	r3, [r3, #0]
 8018c20:	2210      	movs	r2, #16
 8018c22:	4013      	ands	r3, r2
 8018c24:	b2db      	uxtb	r3, r3
 8018c26:	2b00      	cmp	r3, #0
 8018c28:	d000      	beq.n	8018c2c <lcp_nakci+0x4f4>
 8018c2a:	e0a6      	b.n	8018d7a <lcp_nakci+0x642>
 8018c2c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8018c2e:	2b06      	cmp	r3, #6
 8018c30:	d05f      	beq.n	8018cf2 <lcp_nakci+0x5ba>
		cilen != CILEN_LONG)
		goto bad;
 8018c32:	e0a2      	b.n	8018d7a <lcp_nakci+0x642>
	    break;
	case CI_PCOMPRESSION:
	    if (go->neg_pcompression || no.neg_pcompression
 8018c34:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018c36:	781b      	ldrb	r3, [r3, #0]
 8018c38:	2220      	movs	r2, #32
 8018c3a:	4013      	ands	r3, r2
 8018c3c:	b2db      	uxtb	r3, r3
 8018c3e:	2b00      	cmp	r3, #0
 8018c40:	d000      	beq.n	8018c44 <lcp_nakci+0x50c>
 8018c42:	e09c      	b.n	8018d7e <lcp_nakci+0x646>
 8018c44:	2338      	movs	r3, #56	; 0x38
 8018c46:	18fb      	adds	r3, r7, r3
 8018c48:	781b      	ldrb	r3, [r3, #0]
 8018c4a:	2220      	movs	r2, #32
 8018c4c:	4013      	ands	r3, r2
 8018c4e:	b2db      	uxtb	r3, r3
 8018c50:	2b00      	cmp	r3, #0
 8018c52:	d000      	beq.n	8018c56 <lcp_nakci+0x51e>
 8018c54:	e093      	b.n	8018d7e <lcp_nakci+0x646>
		|| cilen != CILEN_VOID)
 8018c56:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8018c58:	2b02      	cmp	r3, #2
 8018c5a:	d04c      	beq.n	8018cf6 <lcp_nakci+0x5be>
		goto bad;
 8018c5c:	e08f      	b.n	8018d7e <lcp_nakci+0x646>
	    break;
	case CI_ACCOMPRESSION:
	    if (go->neg_accompression || no.neg_accompression
 8018c5e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018c60:	781b      	ldrb	r3, [r3, #0]
 8018c62:	2240      	movs	r2, #64	; 0x40
 8018c64:	4013      	ands	r3, r2
 8018c66:	b2db      	uxtb	r3, r3
 8018c68:	2b00      	cmp	r3, #0
 8018c6a:	d000      	beq.n	8018c6e <lcp_nakci+0x536>
 8018c6c:	e089      	b.n	8018d82 <lcp_nakci+0x64a>
 8018c6e:	2338      	movs	r3, #56	; 0x38
 8018c70:	18fb      	adds	r3, r7, r3
 8018c72:	781b      	ldrb	r3, [r3, #0]
 8018c74:	2240      	movs	r2, #64	; 0x40
 8018c76:	4013      	ands	r3, r2
 8018c78:	b2db      	uxtb	r3, r3
 8018c7a:	2b00      	cmp	r3, #0
 8018c7c:	d000      	beq.n	8018c80 <lcp_nakci+0x548>
 8018c7e:	e080      	b.n	8018d82 <lcp_nakci+0x64a>
		|| cilen != CILEN_VOID)
 8018c80:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8018c82:	2b02      	cmp	r3, #2
 8018c84:	d039      	beq.n	8018cfa <lcp_nakci+0x5c2>
		goto bad;
 8018c86:	e07c      	b.n	8018d82 <lcp_nakci+0x64a>
	    if (go->neg_mrru || no.neg_mrru || cilen != CILEN_SHORT)
		goto bad;
	    break;
#endif /* HAVE_MULTILINK */
	case CI_SSNHF:
	    if (go->neg_ssnhf || no.neg_ssnhf || cilen != CILEN_VOID)
 8018c88:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018c8a:	785b      	ldrb	r3, [r3, #1]
 8018c8c:	2201      	movs	r2, #1
 8018c8e:	4013      	ands	r3, r2
 8018c90:	b2db      	uxtb	r3, r3
 8018c92:	2b00      	cmp	r3, #0
 8018c94:	d000      	beq.n	8018c98 <lcp_nakci+0x560>
 8018c96:	e076      	b.n	8018d86 <lcp_nakci+0x64e>
 8018c98:	2338      	movs	r3, #56	; 0x38
 8018c9a:	18fb      	adds	r3, r7, r3
 8018c9c:	785b      	ldrb	r3, [r3, #1]
 8018c9e:	2201      	movs	r2, #1
 8018ca0:	4013      	ands	r3, r2
 8018ca2:	b2db      	uxtb	r3, r3
 8018ca4:	2b00      	cmp	r3, #0
 8018ca6:	d000      	beq.n	8018caa <lcp_nakci+0x572>
 8018ca8:	e06d      	b.n	8018d86 <lcp_nakci+0x64e>
 8018caa:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8018cac:	2b02      	cmp	r3, #2
 8018cae:	d000      	beq.n	8018cb2 <lcp_nakci+0x57a>
 8018cb0:	e069      	b.n	8018d86 <lcp_nakci+0x64e>
		goto bad;
	    try_.neg_ssnhf = 1;
 8018cb2:	2314      	movs	r3, #20
 8018cb4:	18fb      	adds	r3, r7, r3
 8018cb6:	785a      	ldrb	r2, [r3, #1]
 8018cb8:	2101      	movs	r1, #1
 8018cba:	430a      	orrs	r2, r1
 8018cbc:	705a      	strb	r2, [r3, #1]
	    break;
 8018cbe:	e01d      	b.n	8018cfc <lcp_nakci+0x5c4>
	case CI_EPDISC:
	    if (go->neg_endpoint || no.neg_endpoint || cilen < CILEN_CHAR)
 8018cc0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018cc2:	785b      	ldrb	r3, [r3, #1]
 8018cc4:	2202      	movs	r2, #2
 8018cc6:	4013      	ands	r3, r2
 8018cc8:	b2db      	uxtb	r3, r3
 8018cca:	2b00      	cmp	r3, #0
 8018ccc:	d15d      	bne.n	8018d8a <lcp_nakci+0x652>
 8018cce:	2338      	movs	r3, #56	; 0x38
 8018cd0:	18fb      	adds	r3, r7, r3
 8018cd2:	785b      	ldrb	r3, [r3, #1]
 8018cd4:	2202      	movs	r2, #2
 8018cd6:	4013      	ands	r3, r2
 8018cd8:	b2db      	uxtb	r3, r3
 8018cda:	2b00      	cmp	r3, #0
 8018cdc:	d155      	bne.n	8018d8a <lcp_nakci+0x652>
 8018cde:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8018ce0:	2b02      	cmp	r3, #2
 8018ce2:	dd52      	ble.n	8018d8a <lcp_nakci+0x652>
		goto bad;
	    break;
 8018ce4:	e00a      	b.n	8018cfc <lcp_nakci+0x5c4>
	default:
	    break;
 8018ce6:	46c0      	nop			; (mov r8, r8)
 8018ce8:	e008      	b.n	8018cfc <lcp_nakci+0x5c4>
	    break;
 8018cea:	46c0      	nop			; (mov r8, r8)
 8018cec:	e006      	b.n	8018cfc <lcp_nakci+0x5c4>
	    break;
 8018cee:	46c0      	nop			; (mov r8, r8)
 8018cf0:	e004      	b.n	8018cfc <lcp_nakci+0x5c4>
	    break;
 8018cf2:	46c0      	nop			; (mov r8, r8)
 8018cf4:	e002      	b.n	8018cfc <lcp_nakci+0x5c4>
	    break;
 8018cf6:	46c0      	nop			; (mov r8, r8)
 8018cf8:	e000      	b.n	8018cfc <lcp_nakci+0x5c4>
	    break;
 8018cfa:	46c0      	nop			; (mov r8, r8)
	}
	p = next;
 8018cfc:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8018cfe:	60bb      	str	r3, [r7, #8]
    while (len >= CILEN_VOID) {
 8018d00:	687b      	ldr	r3, [r7, #4]
 8018d02:	2b01      	cmp	r3, #1
 8018d04:	dd00      	ble.n	8018d08 <lcp_nakci+0x5d0>
 8018d06:	e701      	b.n	8018b0c <lcp_nakci+0x3d4>

    /*
     * OK, the Nak is good.  Now we can update state.
     * If there are any options left we ignore them.
     */
    if (f->state != PPP_FSM_OPENED) {
 8018d08:	68fb      	ldr	r3, [r7, #12]
 8018d0a:	7c1b      	ldrb	r3, [r3, #16]
 8018d0c:	2b09      	cmp	r3, #9
 8018d0e:	d02c      	beq.n	8018d6a <lcp_nakci+0x632>
	if (looped_back) {
 8018d10:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8018d12:	2b00      	cmp	r3, #0
 8018d14:	d01c      	beq.n	8018d50 <lcp_nakci+0x618>
	    if (++try_.numloops >= pcb->settings.lcp_loopbackfail) {
 8018d16:	2114      	movs	r1, #20
 8018d18:	187b      	adds	r3, r7, r1
 8018d1a:	7b1b      	ldrb	r3, [r3, #12]
 8018d1c:	3301      	adds	r3, #1
 8018d1e:	b2da      	uxtb	r2, r3
 8018d20:	187b      	adds	r3, r7, r1
 8018d22:	731a      	strb	r2, [r3, #12]
 8018d24:	187b      	adds	r3, r7, r1
 8018d26:	7b1a      	ldrb	r2, [r3, #12]
 8018d28:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8018d2a:	7a1b      	ldrb	r3, [r3, #8]
 8018d2c:	429a      	cmp	r2, r3
 8018d2e:	d313      	bcc.n	8018d58 <lcp_nakci+0x620>
		ppp_notice("Serial line is looped back.");
 8018d30:	4b1c      	ldr	r3, [pc, #112]	; (8018da4 <lcp_nakci+0x66c>)
 8018d32:	0018      	movs	r0, r3
 8018d34:	f002 fd93 	bl	801b85e <ppp_notice>
		pcb->err_code = PPPERR_LOOPBACK;
 8018d38:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8018d3a:	2225      	movs	r2, #37	; 0x25
 8018d3c:	210c      	movs	r1, #12
 8018d3e:	5499      	strb	r1, [r3, r2]
		lcp_close(f->pcb, "Loopback detected");
 8018d40:	68fb      	ldr	r3, [r7, #12]
 8018d42:	681b      	ldr	r3, [r3, #0]
 8018d44:	4a18      	ldr	r2, [pc, #96]	; (8018da8 <lcp_nakci+0x670>)
 8018d46:	0011      	movs	r1, r2
 8018d48:	0018      	movs	r0, r3
 8018d4a:	f7fe ff03 	bl	8017b54 <lcp_close>
 8018d4e:	e003      	b.n	8018d58 <lcp_nakci+0x620>
	    }
	} else
	    try_.numloops = 0;
 8018d50:	2314      	movs	r3, #20
 8018d52:	18fb      	adds	r3, r7, r3
 8018d54:	2200      	movs	r2, #0
 8018d56:	731a      	strb	r2, [r3, #12]
	*go = try_;
 8018d58:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018d5a:	2214      	movs	r2, #20
 8018d5c:	18ba      	adds	r2, r7, r2
 8018d5e:	ca13      	ldmia	r2!, {r0, r1, r4}
 8018d60:	c313      	stmia	r3!, {r0, r1, r4}
 8018d62:	ca13      	ldmia	r2!, {r0, r1, r4}
 8018d64:	c313      	stmia	r3!, {r0, r1, r4}
 8018d66:	ca13      	ldmia	r2!, {r0, r1, r4}
 8018d68:	c313      	stmia	r3!, {r0, r1, r4}
    }

    return 1;
 8018d6a:	2301      	movs	r3, #1
 8018d6c:	e00f      	b.n	8018d8e <lcp_nakci+0x656>
	    goto bad;
 8018d6e:	46c0      	nop			; (mov r8, r8)
 8018d70:	e00c      	b.n	8018d8c <lcp_nakci+0x654>
		goto bad;
 8018d72:	46c0      	nop			; (mov r8, r8)
 8018d74:	e00a      	b.n	8018d8c <lcp_nakci+0x654>
		goto bad;
 8018d76:	46c0      	nop			; (mov r8, r8)
 8018d78:	e008      	b.n	8018d8c <lcp_nakci+0x654>
		goto bad;
 8018d7a:	46c0      	nop			; (mov r8, r8)
 8018d7c:	e006      	b.n	8018d8c <lcp_nakci+0x654>
		goto bad;
 8018d7e:	46c0      	nop			; (mov r8, r8)
 8018d80:	e004      	b.n	8018d8c <lcp_nakci+0x654>
		goto bad;
 8018d82:	46c0      	nop			; (mov r8, r8)
 8018d84:	e002      	b.n	8018d8c <lcp_nakci+0x654>
		goto bad;
 8018d86:	46c0      	nop			; (mov r8, r8)
 8018d88:	e000      	b.n	8018d8c <lcp_nakci+0x654>
		goto bad;
 8018d8a:	46c0      	nop			; (mov r8, r8)

bad:
    LCPDEBUG(("lcp_nakci: received bad Nak!"));
    return 0;
 8018d8c:	2300      	movs	r3, #0
}
 8018d8e:	0018      	movs	r0, r3
 8018d90:	46bd      	mov	sp, r7
 8018d92:	b020      	add	sp, #128	; 0x80
 8018d94:	bdb0      	pop	{r4, r5, r7, pc}
 8018d96:	46c0      	nop			; (mov r8, r8)
 8018d98:	08022a44 	.word	0x08022a44
 8018d9c:	000005dc 	.word	0x000005dc
 8018da0:	000005db 	.word	0x000005db
 8018da4:	08021d88 	.word	0x08021d88
 8018da8:	08021da4 	.word	0x08021da4

08018dac <lcp_rejci>:
 *
 * Returns:
 *	0 - Reject was bad.
 *	1 - Reject was good.
 */
static int lcp_rejci(fsm *f, u_char *p, int len) {
 8018dac:	b5b0      	push	{r4, r5, r7, lr}
 8018dae:	b094      	sub	sp, #80	; 0x50
 8018db0:	af00      	add	r7, sp, #0
 8018db2:	60f8      	str	r0, [r7, #12]
 8018db4:	60b9      	str	r1, [r7, #8]
 8018db6:	607a      	str	r2, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8018db8:	68fb      	ldr	r3, [r7, #12]
 8018dba:	681b      	ldr	r3, [r3, #0]
 8018dbc:	64bb      	str	r3, [r7, #72]	; 0x48
    lcp_options *go = &pcb->lcp_gotoptions;
 8018dbe:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8018dc0:	3368      	adds	r3, #104	; 0x68
 8018dc2:	647b      	str	r3, [r7, #68]	; 0x44
    u_char cichar;
    u_short cishort;
    u32_t cilong;
    lcp_options try_;		/* options to request next time */

    try_ = *go;
 8018dc4:	2414      	movs	r4, #20
 8018dc6:	193b      	adds	r3, r7, r4
 8018dc8:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8018dca:	ca23      	ldmia	r2!, {r0, r1, r5}
 8018dcc:	c323      	stmia	r3!, {r0, r1, r5}
 8018dce:	ca23      	ldmia	r2!, {r0, r1, r5}
 8018dd0:	c323      	stmia	r3!, {r0, r1, r5}
 8018dd2:	ca23      	ldmia	r2!, {r0, r1, r5}
 8018dd4:	c323      	stmia	r3!, {r0, r1, r5}
		goto bad; \
	} \
	try_.neg = 0; \
    }

    REJCISHORT(CI_MRU, neg_mru, go->mru);
 8018dd6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018dd8:	781b      	ldrb	r3, [r3, #0]
 8018dda:	2204      	movs	r2, #4
 8018ddc:	4013      	ands	r3, r2
 8018dde:	b2db      	uxtb	r3, r3
 8018de0:	2b00      	cmp	r3, #0
 8018de2:	d030      	beq.n	8018e46 <lcp_rejci+0x9a>
 8018de4:	687b      	ldr	r3, [r7, #4]
 8018de6:	2b03      	cmp	r3, #3
 8018de8:	dd2d      	ble.n	8018e46 <lcp_rejci+0x9a>
 8018dea:	68bb      	ldr	r3, [r7, #8]
 8018dec:	3301      	adds	r3, #1
 8018dee:	781b      	ldrb	r3, [r3, #0]
 8018df0:	2b04      	cmp	r3, #4
 8018df2:	d128      	bne.n	8018e46 <lcp_rejci+0x9a>
 8018df4:	68bb      	ldr	r3, [r7, #8]
 8018df6:	781b      	ldrb	r3, [r3, #0]
 8018df8:	2b01      	cmp	r3, #1
 8018dfa:	d124      	bne.n	8018e46 <lcp_rejci+0x9a>
 8018dfc:	687b      	ldr	r3, [r7, #4]
 8018dfe:	3b04      	subs	r3, #4
 8018e00:	607b      	str	r3, [r7, #4]
 8018e02:	68bb      	ldr	r3, [r7, #8]
 8018e04:	3302      	adds	r3, #2
 8018e06:	60bb      	str	r3, [r7, #8]
 8018e08:	68bb      	ldr	r3, [r7, #8]
 8018e0a:	1c5a      	adds	r2, r3, #1
 8018e0c:	60ba      	str	r2, [r7, #8]
 8018e0e:	781b      	ldrb	r3, [r3, #0]
 8018e10:	b29a      	uxth	r2, r3
 8018e12:	2042      	movs	r0, #66	; 0x42
 8018e14:	183b      	adds	r3, r7, r0
 8018e16:	0212      	lsls	r2, r2, #8
 8018e18:	801a      	strh	r2, [r3, #0]
 8018e1a:	68bb      	ldr	r3, [r7, #8]
 8018e1c:	1c5a      	adds	r2, r3, #1
 8018e1e:	60ba      	str	r2, [r7, #8]
 8018e20:	781b      	ldrb	r3, [r3, #0]
 8018e22:	b299      	uxth	r1, r3
 8018e24:	183b      	adds	r3, r7, r0
 8018e26:	183a      	adds	r2, r7, r0
 8018e28:	8812      	ldrh	r2, [r2, #0]
 8018e2a:	430a      	orrs	r2, r1
 8018e2c:	801a      	strh	r2, [r3, #0]
 8018e2e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018e30:	885b      	ldrh	r3, [r3, #2]
 8018e32:	183a      	adds	r2, r7, r0
 8018e34:	8812      	ldrh	r2, [r2, #0]
 8018e36:	429a      	cmp	r2, r3
 8018e38:	d000      	beq.n	8018e3c <lcp_rejci+0x90>
 8018e3a:	e182      	b.n	8019142 <lcp_rejci+0x396>
 8018e3c:	193b      	adds	r3, r7, r4
 8018e3e:	781a      	ldrb	r2, [r3, #0]
 8018e40:	2104      	movs	r1, #4
 8018e42:	438a      	bics	r2, r1
 8018e44:	701a      	strb	r2, [r3, #0]
    REJCILONG(CI_ASYNCMAP, neg_asyncmap, go->asyncmap);
 8018e46:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018e48:	781b      	ldrb	r3, [r3, #0]
 8018e4a:	2208      	movs	r2, #8
 8018e4c:	4013      	ands	r3, r2
 8018e4e:	b2db      	uxtb	r3, r3
 8018e50:	2b00      	cmp	r3, #0
 8018e52:	d041      	beq.n	8018ed8 <lcp_rejci+0x12c>
 8018e54:	687b      	ldr	r3, [r7, #4]
 8018e56:	2b05      	cmp	r3, #5
 8018e58:	dd3e      	ble.n	8018ed8 <lcp_rejci+0x12c>
 8018e5a:	68bb      	ldr	r3, [r7, #8]
 8018e5c:	3301      	adds	r3, #1
 8018e5e:	781b      	ldrb	r3, [r3, #0]
 8018e60:	2b06      	cmp	r3, #6
 8018e62:	d139      	bne.n	8018ed8 <lcp_rejci+0x12c>
 8018e64:	68bb      	ldr	r3, [r7, #8]
 8018e66:	781b      	ldrb	r3, [r3, #0]
 8018e68:	2b02      	cmp	r3, #2
 8018e6a:	d135      	bne.n	8018ed8 <lcp_rejci+0x12c>
 8018e6c:	687b      	ldr	r3, [r7, #4]
 8018e6e:	3b06      	subs	r3, #6
 8018e70:	607b      	str	r3, [r7, #4]
 8018e72:	68bb      	ldr	r3, [r7, #8]
 8018e74:	3302      	adds	r3, #2
 8018e76:	60bb      	str	r3, [r7, #8]
 8018e78:	68bb      	ldr	r3, [r7, #8]
 8018e7a:	1c5a      	adds	r2, r3, #1
 8018e7c:	60ba      	str	r2, [r7, #8]
 8018e7e:	781b      	ldrb	r3, [r3, #0]
 8018e80:	021b      	lsls	r3, r3, #8
 8018e82:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018e84:	68bb      	ldr	r3, [r7, #8]
 8018e86:	1c5a      	adds	r2, r3, #1
 8018e88:	60ba      	str	r2, [r7, #8]
 8018e8a:	781b      	ldrb	r3, [r3, #0]
 8018e8c:	001a      	movs	r2, r3
 8018e8e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018e90:	4313      	orrs	r3, r2
 8018e92:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018e94:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018e96:	021b      	lsls	r3, r3, #8
 8018e98:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018e9a:	68bb      	ldr	r3, [r7, #8]
 8018e9c:	1c5a      	adds	r2, r3, #1
 8018e9e:	60ba      	str	r2, [r7, #8]
 8018ea0:	781b      	ldrb	r3, [r3, #0]
 8018ea2:	001a      	movs	r2, r3
 8018ea4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018ea6:	4313      	orrs	r3, r2
 8018ea8:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018eaa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018eac:	021b      	lsls	r3, r3, #8
 8018eae:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018eb0:	68bb      	ldr	r3, [r7, #8]
 8018eb2:	1c5a      	adds	r2, r3, #1
 8018eb4:	60ba      	str	r2, [r7, #8]
 8018eb6:	781b      	ldrb	r3, [r3, #0]
 8018eb8:	001a      	movs	r2, r3
 8018eba:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018ebc:	4313      	orrs	r3, r2
 8018ebe:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018ec0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018ec2:	685b      	ldr	r3, [r3, #4]
 8018ec4:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8018ec6:	429a      	cmp	r2, r3
 8018ec8:	d000      	beq.n	8018ecc <lcp_rejci+0x120>
 8018eca:	e13c      	b.n	8019146 <lcp_rejci+0x39a>
 8018ecc:	2314      	movs	r3, #20
 8018ece:	18fb      	adds	r3, r7, r3
 8018ed0:	781a      	ldrb	r2, [r3, #0]
 8018ed2:	2108      	movs	r1, #8
 8018ed4:	438a      	bics	r2, r1
 8018ed6:	701a      	strb	r2, [r3, #0]
    }
#endif /* EAP_SUPPORT */
#if LQR_SUPPORT
    REJCILQR(CI_QUALITY, neg_lqr, go->lqr_period);
#endif /* LQR_SUPPORT */
    REJCICBCP(CI_CALLBACK, neg_cbcp, CBCP_OPT);
 8018ed8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018eda:	781b      	ldrb	r3, [r3, #0]
 8018edc:	227f      	movs	r2, #127	; 0x7f
 8018ede:	4393      	bics	r3, r2
 8018ee0:	b2db      	uxtb	r3, r3
 8018ee2:	2b00      	cmp	r3, #0
 8018ee4:	d023      	beq.n	8018f2e <lcp_rejci+0x182>
 8018ee6:	687b      	ldr	r3, [r7, #4]
 8018ee8:	2b02      	cmp	r3, #2
 8018eea:	dd20      	ble.n	8018f2e <lcp_rejci+0x182>
 8018eec:	68bb      	ldr	r3, [r7, #8]
 8018eee:	3301      	adds	r3, #1
 8018ef0:	781b      	ldrb	r3, [r3, #0]
 8018ef2:	2b03      	cmp	r3, #3
 8018ef4:	d11b      	bne.n	8018f2e <lcp_rejci+0x182>
 8018ef6:	68bb      	ldr	r3, [r7, #8]
 8018ef8:	781b      	ldrb	r3, [r3, #0]
 8018efa:	2b0d      	cmp	r3, #13
 8018efc:	d117      	bne.n	8018f2e <lcp_rejci+0x182>
 8018efe:	687b      	ldr	r3, [r7, #4]
 8018f00:	3b03      	subs	r3, #3
 8018f02:	607b      	str	r3, [r7, #4]
 8018f04:	68bb      	ldr	r3, [r7, #8]
 8018f06:	3302      	adds	r3, #2
 8018f08:	60bb      	str	r3, [r7, #8]
 8018f0a:	68bb      	ldr	r3, [r7, #8]
 8018f0c:	1c5a      	adds	r2, r3, #1
 8018f0e:	60ba      	str	r2, [r7, #8]
 8018f10:	213b      	movs	r1, #59	; 0x3b
 8018f12:	187a      	adds	r2, r7, r1
 8018f14:	781b      	ldrb	r3, [r3, #0]
 8018f16:	7013      	strb	r3, [r2, #0]
 8018f18:	187b      	adds	r3, r7, r1
 8018f1a:	781b      	ldrb	r3, [r3, #0]
 8018f1c:	2b06      	cmp	r3, #6
 8018f1e:	d000      	beq.n	8018f22 <lcp_rejci+0x176>
 8018f20:	e113      	b.n	801914a <lcp_rejci+0x39e>
 8018f22:	2314      	movs	r3, #20
 8018f24:	18fb      	adds	r3, r7, r3
 8018f26:	781a      	ldrb	r2, [r3, #0]
 8018f28:	217f      	movs	r1, #127	; 0x7f
 8018f2a:	400a      	ands	r2, r1
 8018f2c:	701a      	strb	r2, [r3, #0]
    REJCILONG(CI_MAGICNUMBER, neg_magicnumber, go->magicnumber);
 8018f2e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018f30:	781b      	ldrb	r3, [r3, #0]
 8018f32:	2210      	movs	r2, #16
 8018f34:	4013      	ands	r3, r2
 8018f36:	b2db      	uxtb	r3, r3
 8018f38:	2b00      	cmp	r3, #0
 8018f3a:	d041      	beq.n	8018fc0 <lcp_rejci+0x214>
 8018f3c:	687b      	ldr	r3, [r7, #4]
 8018f3e:	2b05      	cmp	r3, #5
 8018f40:	dd3e      	ble.n	8018fc0 <lcp_rejci+0x214>
 8018f42:	68bb      	ldr	r3, [r7, #8]
 8018f44:	3301      	adds	r3, #1
 8018f46:	781b      	ldrb	r3, [r3, #0]
 8018f48:	2b06      	cmp	r3, #6
 8018f4a:	d139      	bne.n	8018fc0 <lcp_rejci+0x214>
 8018f4c:	68bb      	ldr	r3, [r7, #8]
 8018f4e:	781b      	ldrb	r3, [r3, #0]
 8018f50:	2b05      	cmp	r3, #5
 8018f52:	d135      	bne.n	8018fc0 <lcp_rejci+0x214>
 8018f54:	687b      	ldr	r3, [r7, #4]
 8018f56:	3b06      	subs	r3, #6
 8018f58:	607b      	str	r3, [r7, #4]
 8018f5a:	68bb      	ldr	r3, [r7, #8]
 8018f5c:	3302      	adds	r3, #2
 8018f5e:	60bb      	str	r3, [r7, #8]
 8018f60:	68bb      	ldr	r3, [r7, #8]
 8018f62:	1c5a      	adds	r2, r3, #1
 8018f64:	60ba      	str	r2, [r7, #8]
 8018f66:	781b      	ldrb	r3, [r3, #0]
 8018f68:	021b      	lsls	r3, r3, #8
 8018f6a:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018f6c:	68bb      	ldr	r3, [r7, #8]
 8018f6e:	1c5a      	adds	r2, r3, #1
 8018f70:	60ba      	str	r2, [r7, #8]
 8018f72:	781b      	ldrb	r3, [r3, #0]
 8018f74:	001a      	movs	r2, r3
 8018f76:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018f78:	4313      	orrs	r3, r2
 8018f7a:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018f7c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018f7e:	021b      	lsls	r3, r3, #8
 8018f80:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018f82:	68bb      	ldr	r3, [r7, #8]
 8018f84:	1c5a      	adds	r2, r3, #1
 8018f86:	60ba      	str	r2, [r7, #8]
 8018f88:	781b      	ldrb	r3, [r3, #0]
 8018f8a:	001a      	movs	r2, r3
 8018f8c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018f8e:	4313      	orrs	r3, r2
 8018f90:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018f92:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018f94:	021b      	lsls	r3, r3, #8
 8018f96:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018f98:	68bb      	ldr	r3, [r7, #8]
 8018f9a:	1c5a      	adds	r2, r3, #1
 8018f9c:	60ba      	str	r2, [r7, #8]
 8018f9e:	781b      	ldrb	r3, [r3, #0]
 8018fa0:	001a      	movs	r2, r3
 8018fa2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018fa4:	4313      	orrs	r3, r2
 8018fa6:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018fa8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018faa:	689b      	ldr	r3, [r3, #8]
 8018fac:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8018fae:	429a      	cmp	r2, r3
 8018fb0:	d000      	beq.n	8018fb4 <lcp_rejci+0x208>
 8018fb2:	e0cc      	b.n	801914e <lcp_rejci+0x3a2>
 8018fb4:	2314      	movs	r3, #20
 8018fb6:	18fb      	adds	r3, r7, r3
 8018fb8:	781a      	ldrb	r2, [r3, #0]
 8018fba:	2110      	movs	r1, #16
 8018fbc:	438a      	bics	r2, r1
 8018fbe:	701a      	strb	r2, [r3, #0]
    REJCIVOID(CI_PCOMPRESSION, neg_pcompression);
 8018fc0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018fc2:	781b      	ldrb	r3, [r3, #0]
 8018fc4:	2220      	movs	r2, #32
 8018fc6:	4013      	ands	r3, r2
 8018fc8:	b2db      	uxtb	r3, r3
 8018fca:	2b00      	cmp	r3, #0
 8018fcc:	d017      	beq.n	8018ffe <lcp_rejci+0x252>
 8018fce:	687b      	ldr	r3, [r7, #4]
 8018fd0:	2b01      	cmp	r3, #1
 8018fd2:	dd14      	ble.n	8018ffe <lcp_rejci+0x252>
 8018fd4:	68bb      	ldr	r3, [r7, #8]
 8018fd6:	3301      	adds	r3, #1
 8018fd8:	781b      	ldrb	r3, [r3, #0]
 8018fda:	2b02      	cmp	r3, #2
 8018fdc:	d10f      	bne.n	8018ffe <lcp_rejci+0x252>
 8018fde:	68bb      	ldr	r3, [r7, #8]
 8018fe0:	781b      	ldrb	r3, [r3, #0]
 8018fe2:	2b07      	cmp	r3, #7
 8018fe4:	d10b      	bne.n	8018ffe <lcp_rejci+0x252>
 8018fe6:	687b      	ldr	r3, [r7, #4]
 8018fe8:	3b02      	subs	r3, #2
 8018fea:	607b      	str	r3, [r7, #4]
 8018fec:	68bb      	ldr	r3, [r7, #8]
 8018fee:	3302      	adds	r3, #2
 8018ff0:	60bb      	str	r3, [r7, #8]
 8018ff2:	2314      	movs	r3, #20
 8018ff4:	18fb      	adds	r3, r7, r3
 8018ff6:	781a      	ldrb	r2, [r3, #0]
 8018ff8:	2120      	movs	r1, #32
 8018ffa:	438a      	bics	r2, r1
 8018ffc:	701a      	strb	r2, [r3, #0]
    REJCIVOID(CI_ACCOMPRESSION, neg_accompression);
 8018ffe:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8019000:	781b      	ldrb	r3, [r3, #0]
 8019002:	2240      	movs	r2, #64	; 0x40
 8019004:	4013      	ands	r3, r2
 8019006:	b2db      	uxtb	r3, r3
 8019008:	2b00      	cmp	r3, #0
 801900a:	d017      	beq.n	801903c <lcp_rejci+0x290>
 801900c:	687b      	ldr	r3, [r7, #4]
 801900e:	2b01      	cmp	r3, #1
 8019010:	dd14      	ble.n	801903c <lcp_rejci+0x290>
 8019012:	68bb      	ldr	r3, [r7, #8]
 8019014:	3301      	adds	r3, #1
 8019016:	781b      	ldrb	r3, [r3, #0]
 8019018:	2b02      	cmp	r3, #2
 801901a:	d10f      	bne.n	801903c <lcp_rejci+0x290>
 801901c:	68bb      	ldr	r3, [r7, #8]
 801901e:	781b      	ldrb	r3, [r3, #0]
 8019020:	2b08      	cmp	r3, #8
 8019022:	d10b      	bne.n	801903c <lcp_rejci+0x290>
 8019024:	687b      	ldr	r3, [r7, #4]
 8019026:	3b02      	subs	r3, #2
 8019028:	607b      	str	r3, [r7, #4]
 801902a:	68bb      	ldr	r3, [r7, #8]
 801902c:	3302      	adds	r3, #2
 801902e:	60bb      	str	r3, [r7, #8]
 8019030:	2314      	movs	r3, #20
 8019032:	18fb      	adds	r3, r7, r3
 8019034:	781a      	ldrb	r2, [r3, #0]
 8019036:	2140      	movs	r1, #64	; 0x40
 8019038:	438a      	bics	r2, r1
 801903a:	701a      	strb	r2, [r3, #0]
#ifdef HAVE_MULTILINK
    REJCISHORT(CI_MRRU, neg_mrru, go->mrru);
#endif /* HAVE_MULTILINK */
    REJCIVOID(CI_SSNHF, neg_ssnhf);
 801903c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801903e:	785b      	ldrb	r3, [r3, #1]
 8019040:	2201      	movs	r2, #1
 8019042:	4013      	ands	r3, r2
 8019044:	b2db      	uxtb	r3, r3
 8019046:	2b00      	cmp	r3, #0
 8019048:	d017      	beq.n	801907a <lcp_rejci+0x2ce>
 801904a:	687b      	ldr	r3, [r7, #4]
 801904c:	2b01      	cmp	r3, #1
 801904e:	dd14      	ble.n	801907a <lcp_rejci+0x2ce>
 8019050:	68bb      	ldr	r3, [r7, #8]
 8019052:	3301      	adds	r3, #1
 8019054:	781b      	ldrb	r3, [r3, #0]
 8019056:	2b02      	cmp	r3, #2
 8019058:	d10f      	bne.n	801907a <lcp_rejci+0x2ce>
 801905a:	68bb      	ldr	r3, [r7, #8]
 801905c:	781b      	ldrb	r3, [r3, #0]
 801905e:	2b12      	cmp	r3, #18
 8019060:	d10b      	bne.n	801907a <lcp_rejci+0x2ce>
 8019062:	687b      	ldr	r3, [r7, #4]
 8019064:	3b02      	subs	r3, #2
 8019066:	607b      	str	r3, [r7, #4]
 8019068:	68bb      	ldr	r3, [r7, #8]
 801906a:	3302      	adds	r3, #2
 801906c:	60bb      	str	r3, [r7, #8]
 801906e:	2314      	movs	r3, #20
 8019070:	18fb      	adds	r3, r7, r3
 8019072:	785a      	ldrb	r2, [r3, #1]
 8019074:	2101      	movs	r1, #1
 8019076:	438a      	bics	r2, r1
 8019078:	705a      	strb	r2, [r3, #1]
    REJCIENDP(CI_EPDISC, neg_endpoint, go->endpoint.class_,
 801907a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801907c:	785b      	ldrb	r3, [r3, #1]
 801907e:	2202      	movs	r2, #2
 8019080:	4013      	ands	r3, r2
 8019082:	b2db      	uxtb	r3, r3
 8019084:	2b00      	cmp	r3, #0
 8019086:	d04a      	beq.n	801911e <lcp_rejci+0x372>
 8019088:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801908a:	7b9b      	ldrb	r3, [r3, #14]
 801908c:	3302      	adds	r3, #2
 801908e:	687a      	ldr	r2, [r7, #4]
 8019090:	429a      	cmp	r2, r3
 8019092:	dd44      	ble.n	801911e <lcp_rejci+0x372>
 8019094:	68bb      	ldr	r3, [r7, #8]
 8019096:	781b      	ldrb	r3, [r3, #0]
 8019098:	2b13      	cmp	r3, #19
 801909a:	d140      	bne.n	801911e <lcp_rejci+0x372>
 801909c:	68bb      	ldr	r3, [r7, #8]
 801909e:	3301      	adds	r3, #1
 80190a0:	781b      	ldrb	r3, [r3, #0]
 80190a2:	001a      	movs	r2, r3
 80190a4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80190a6:	7b9b      	ldrb	r3, [r3, #14]
 80190a8:	3303      	adds	r3, #3
 80190aa:	429a      	cmp	r2, r3
 80190ac:	d137      	bne.n	801911e <lcp_rejci+0x372>
 80190ae:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80190b0:	7b9b      	ldrb	r3, [r3, #14]
 80190b2:	3303      	adds	r3, #3
 80190b4:	687a      	ldr	r2, [r7, #4]
 80190b6:	1ad3      	subs	r3, r2, r3
 80190b8:	607b      	str	r3, [r7, #4]
 80190ba:	68bb      	ldr	r3, [r7, #8]
 80190bc:	3302      	adds	r3, #2
 80190be:	60bb      	str	r3, [r7, #8]
 80190c0:	68bb      	ldr	r3, [r7, #8]
 80190c2:	1c5a      	adds	r2, r3, #1
 80190c4:	60ba      	str	r2, [r7, #8]
 80190c6:	213b      	movs	r1, #59	; 0x3b
 80190c8:	187a      	adds	r2, r7, r1
 80190ca:	781b      	ldrb	r3, [r3, #0]
 80190cc:	7013      	strb	r3, [r2, #0]
 80190ce:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80190d0:	7b5b      	ldrb	r3, [r3, #13]
 80190d2:	187a      	adds	r2, r7, r1
 80190d4:	7812      	ldrb	r2, [r2, #0]
 80190d6:	429a      	cmp	r2, r3
 80190d8:	d13b      	bne.n	8019152 <lcp_rejci+0x3a6>
 80190da:	2300      	movs	r3, #0
 80190dc:	64fb      	str	r3, [r7, #76]	; 0x4c
 80190de:	e012      	b.n	8019106 <lcp_rejci+0x35a>
 80190e0:	68bb      	ldr	r3, [r7, #8]
 80190e2:	1c5a      	adds	r2, r3, #1
 80190e4:	60ba      	str	r2, [r7, #8]
 80190e6:	213b      	movs	r1, #59	; 0x3b
 80190e8:	187a      	adds	r2, r7, r1
 80190ea:	781b      	ldrb	r3, [r3, #0]
 80190ec:	7013      	strb	r3, [r2, #0]
 80190ee:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80190f0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80190f2:	18d3      	adds	r3, r2, r3
 80190f4:	330f      	adds	r3, #15
 80190f6:	781b      	ldrb	r3, [r3, #0]
 80190f8:	187a      	adds	r2, r7, r1
 80190fa:	7812      	ldrb	r2, [r2, #0]
 80190fc:	429a      	cmp	r2, r3
 80190fe:	d12a      	bne.n	8019156 <lcp_rejci+0x3aa>
 8019100:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8019102:	3301      	adds	r3, #1
 8019104:	64fb      	str	r3, [r7, #76]	; 0x4c
 8019106:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8019108:	7b9b      	ldrb	r3, [r3, #14]
 801910a:	001a      	movs	r2, r3
 801910c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801910e:	4293      	cmp	r3, r2
 8019110:	dbe6      	blt.n	80190e0 <lcp_rejci+0x334>
 8019112:	2314      	movs	r3, #20
 8019114:	18fb      	adds	r3, r7, r3
 8019116:	785a      	ldrb	r2, [r3, #1]
 8019118:	2102      	movs	r1, #2
 801911a:	438a      	bics	r2, r1
 801911c:	705a      	strb	r2, [r3, #1]
	      go->endpoint.value, go->endpoint.length);

    /*
     * If there are any remaining CIs, then this packet is bad.
     */
    if (len != 0)
 801911e:	687b      	ldr	r3, [r7, #4]
 8019120:	2b00      	cmp	r3, #0
 8019122:	d11a      	bne.n	801915a <lcp_rejci+0x3ae>
	goto bad;
    /*
     * Now we can update state.
     */
    if (f->state != PPP_FSM_OPENED)
 8019124:	68fb      	ldr	r3, [r7, #12]
 8019126:	7c1b      	ldrb	r3, [r3, #16]
 8019128:	2b09      	cmp	r3, #9
 801912a:	d008      	beq.n	801913e <lcp_rejci+0x392>
	*go = try_;
 801912c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801912e:	2214      	movs	r2, #20
 8019130:	18ba      	adds	r2, r7, r2
 8019132:	ca13      	ldmia	r2!, {r0, r1, r4}
 8019134:	c313      	stmia	r3!, {r0, r1, r4}
 8019136:	ca13      	ldmia	r2!, {r0, r1, r4}
 8019138:	c313      	stmia	r3!, {r0, r1, r4}
 801913a:	ca13      	ldmia	r2!, {r0, r1, r4}
 801913c:	c313      	stmia	r3!, {r0, r1, r4}
    return 1;
 801913e:	2301      	movs	r3, #1
 8019140:	e00d      	b.n	801915e <lcp_rejci+0x3b2>
    REJCISHORT(CI_MRU, neg_mru, go->mru);
 8019142:	46c0      	nop			; (mov r8, r8)
 8019144:	e00a      	b.n	801915c <lcp_rejci+0x3b0>
    REJCILONG(CI_ASYNCMAP, neg_asyncmap, go->asyncmap);
 8019146:	46c0      	nop			; (mov r8, r8)
 8019148:	e008      	b.n	801915c <lcp_rejci+0x3b0>
    REJCICBCP(CI_CALLBACK, neg_cbcp, CBCP_OPT);
 801914a:	46c0      	nop			; (mov r8, r8)
 801914c:	e006      	b.n	801915c <lcp_rejci+0x3b0>
    REJCILONG(CI_MAGICNUMBER, neg_magicnumber, go->magicnumber);
 801914e:	46c0      	nop			; (mov r8, r8)
 8019150:	e004      	b.n	801915c <lcp_rejci+0x3b0>
    REJCIENDP(CI_EPDISC, neg_endpoint, go->endpoint.class_,
 8019152:	46c0      	nop			; (mov r8, r8)
 8019154:	e002      	b.n	801915c <lcp_rejci+0x3b0>
 8019156:	46c0      	nop			; (mov r8, r8)
 8019158:	e000      	b.n	801915c <lcp_rejci+0x3b0>
	goto bad;
 801915a:	46c0      	nop			; (mov r8, r8)

bad:
    LCPDEBUG(("lcp_rejci: received bad Reject!"));
    return 0;
 801915c:	2300      	movs	r3, #0
}
 801915e:	0018      	movs	r0, r3
 8019160:	46bd      	mov	sp, r7
 8019162:	b014      	add	sp, #80	; 0x50
 8019164:	bdb0      	pop	{r4, r5, r7, pc}
	...

08019168 <lcp_reqci>:
 * CONFNAK; returns CONFREJ if it can't return CONFACK.
 *
 * inp = Requested CIs
 * lenp = Length of requested CIs
 */
static int lcp_reqci(fsm *f, u_char *inp, int *lenp, int reject_if_disagree) {
 8019168:	b580      	push	{r7, lr}
 801916a:	b096      	sub	sp, #88	; 0x58
 801916c:	af00      	add	r7, sp, #0
 801916e:	60f8      	str	r0, [r7, #12]
 8019170:	60b9      	str	r1, [r7, #8]
 8019172:	607a      	str	r2, [r7, #4]
 8019174:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 8019176:	68fb      	ldr	r3, [r7, #12]
 8019178:	681b      	ldr	r3, [r3, #0]
 801917a:	637b      	str	r3, [r7, #52]	; 0x34
    lcp_options *go = &pcb->lcp_gotoptions;
 801917c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801917e:	3368      	adds	r3, #104	; 0x68
 8019180:	633b      	str	r3, [r7, #48]	; 0x30
    lcp_options *ho = &pcb->lcp_hisoptions;
 8019182:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8019184:	33b0      	adds	r3, #176	; 0xb0
 8019186:	62fb      	str	r3, [r7, #44]	; 0x2c
    lcp_options *ao = &pcb->lcp_allowoptions;
 8019188:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801918a:	338c      	adds	r3, #140	; 0x8c
 801918c:	62bb      	str	r3, [r7, #40]	; 0x28
    u_char *cip, *next;		/* Pointer to current and next CIs */
    int cilen, citype, cichar;	/* Parsed len, type, char value */
    u_short cishort;		/* Parsed short value */
    u32_t cilong;		/* Parse long value */
    int rc = CONFACK;		/* Final packet return code */
 801918e:	2302      	movs	r3, #2
 8019190:	64bb      	str	r3, [r7, #72]	; 0x48
    int orc;			/* Individual option return code */
    u_char *p;			/* Pointer to next char to parse */
    u_char *rejp;		/* Pointer to next char in reject frame */
    struct pbuf *nakp;          /* Nak buffer */
    u_char *nakoutp;		/* Pointer to next char in Nak frame */
    int l = *lenp;		/* Length left */
 8019192:	687b      	ldr	r3, [r7, #4]
 8019194:	681b      	ldr	r3, [r3, #0]
 8019196:	63bb      	str	r3, [r7, #56]	; 0x38

    /*
     * Reset all his options.
     */
    BZERO(ho, sizeof(*ho));
 8019198:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801919a:	2224      	movs	r2, #36	; 0x24
 801919c:	2100      	movs	r1, #0
 801919e:	0018      	movs	r0, r3
 80191a0:	f003 feb0 	bl	801cf04 <memset>

    /*
     * Process all his options.
     */
    next = inp;
 80191a4:	68bb      	ldr	r3, [r7, #8]
 80191a6:	657b      	str	r3, [r7, #84]	; 0x54
    nakp = pbuf_alloc(PBUF_RAW, (u16_t)(PPP_CTRL_PBUF_MAX_SIZE), PPP_CTRL_PBUF_TYPE);
 80191a8:	23c1      	movs	r3, #193	; 0xc1
 80191aa:	005a      	lsls	r2, r3, #1
 80191ac:	2394      	movs	r3, #148	; 0x94
 80191ae:	009b      	lsls	r3, r3, #2
 80191b0:	0019      	movs	r1, r3
 80191b2:	2000      	movs	r0, #0
 80191b4:	f7f0 fb0a 	bl	80097cc <pbuf_alloc>
 80191b8:	0003      	movs	r3, r0
 80191ba:	627b      	str	r3, [r7, #36]	; 0x24
    if(NULL == nakp)
 80191bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80191be:	2b00      	cmp	r3, #0
 80191c0:	d101      	bne.n	80191c6 <lcp_reqci+0x5e>
        return 0;
 80191c2:	2300      	movs	r3, #0
 80191c4:	e258      	b.n	8019678 <lcp_reqci+0x510>
    if(nakp->tot_len != nakp->len) {
 80191c6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80191c8:	891a      	ldrh	r2, [r3, #8]
 80191ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80191cc:	895b      	ldrh	r3, [r3, #10]
 80191ce:	429a      	cmp	r2, r3
 80191d0:	d005      	beq.n	80191de <lcp_reqci+0x76>
        pbuf_free(nakp);
 80191d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80191d4:	0018      	movs	r0, r3
 80191d6:	f7f0 fe71 	bl	8009ebc <pbuf_free>
        return 0;
 80191da:	2300      	movs	r3, #0
 80191dc:	e24c      	b.n	8019678 <lcp_reqci+0x510>
    }

    nakoutp = (u_char*)nakp->payload;
 80191de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80191e0:	685b      	ldr	r3, [r3, #4]
 80191e2:	63fb      	str	r3, [r7, #60]	; 0x3c
    rejp = inp;
 80191e4:	68bb      	ldr	r3, [r7, #8]
 80191e6:	643b      	str	r3, [r7, #64]	; 0x40
    while (l) {
 80191e8:	e213      	b.n	8019612 <lcp_reqci+0x4aa>
	orc = CONFACK;			/* Assume success */
 80191ea:	2302      	movs	r3, #2
 80191ec:	647b      	str	r3, [r7, #68]	; 0x44
	cip = p = next;			/* Remember begining of CI */
 80191ee:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80191f0:	623b      	str	r3, [r7, #32]
 80191f2:	6a3b      	ldr	r3, [r7, #32]
 80191f4:	61fb      	str	r3, [r7, #28]
	if (l < 2 ||			/* Not enough data for CI header or */
 80191f6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80191f8:	2b01      	cmp	r3, #1
 80191fa:	dd0b      	ble.n	8019214 <lcp_reqci+0xac>
	    p[1] < 2 ||			/*  CI length too small or */
 80191fc:	6a3b      	ldr	r3, [r7, #32]
 80191fe:	3301      	adds	r3, #1
 8019200:	781b      	ldrb	r3, [r3, #0]
	if (l < 2 ||			/* Not enough data for CI header or */
 8019202:	2b01      	cmp	r3, #1
 8019204:	d906      	bls.n	8019214 <lcp_reqci+0xac>
	    p[1] > l) {			/*  CI length too big? */
 8019206:	6a3b      	ldr	r3, [r7, #32]
 8019208:	3301      	adds	r3, #1
 801920a:	781b      	ldrb	r3, [r3, #0]
 801920c:	001a      	movs	r2, r3
	    p[1] < 2 ||			/*  CI length too small or */
 801920e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8019210:	4293      	cmp	r3, r2
 8019212:	da08      	bge.n	8019226 <lcp_reqci+0xbe>
	    LCPDEBUG(("lcp_reqci: bad CI length!"));
	    orc = CONFREJ;		/* Reject bad CI */
 8019214:	2304      	movs	r3, #4
 8019216:	647b      	str	r3, [r7, #68]	; 0x44
	    cilen = l;			/* Reject till end of packet */
 8019218:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801921a:	653b      	str	r3, [r7, #80]	; 0x50
	    l = 0;			/* Don't loop again */
 801921c:	2300      	movs	r3, #0
 801921e:	63bb      	str	r3, [r7, #56]	; 0x38
	    citype = 0;
 8019220:	2300      	movs	r3, #0
 8019222:	64fb      	str	r3, [r7, #76]	; 0x4c
	    goto endswitch;
 8019224:	e1c4      	b.n	80195b0 <lcp_reqci+0x448>
	}
	GETCHAR(citype, p);		/* Parse CI type */
 8019226:	6a3b      	ldr	r3, [r7, #32]
 8019228:	1c5a      	adds	r2, r3, #1
 801922a:	623a      	str	r2, [r7, #32]
 801922c:	781b      	ldrb	r3, [r3, #0]
 801922e:	64fb      	str	r3, [r7, #76]	; 0x4c
	GETCHAR(cilen, p);		/* Parse CI length */
 8019230:	6a3b      	ldr	r3, [r7, #32]
 8019232:	1c5a      	adds	r2, r3, #1
 8019234:	623a      	str	r2, [r7, #32]
 8019236:	781b      	ldrb	r3, [r3, #0]
 8019238:	653b      	str	r3, [r7, #80]	; 0x50
	l -= cilen;			/* Adjust remaining length */
 801923a:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801923c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801923e:	1ad3      	subs	r3, r2, r3
 8019240:	63bb      	str	r3, [r7, #56]	; 0x38
	next += cilen;			/* Step to next CI */
 8019242:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019244:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8019246:	18d3      	adds	r3, r2, r3
 8019248:	657b      	str	r3, [r7, #84]	; 0x54
 801924a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801924c:	2b13      	cmp	r3, #19
 801924e:	d900      	bls.n	8019252 <lcp_reqci+0xea>
 8019250:	e1ab      	b.n	80195aa <lcp_reqci+0x442>
 8019252:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8019254:	009a      	lsls	r2, r3, #2
 8019256:	4bda      	ldr	r3, [pc, #872]	; (80195c0 <lcp_reqci+0x458>)
 8019258:	18d3      	adds	r3, r2, r3
 801925a:	681b      	ldr	r3, [r3, #0]
 801925c:	469f      	mov	pc, r3

	switch (citype) {		/* Check CI type */
	case CI_MRU:
	    if (!ao->neg_mru ||		/* Allow option? */
 801925e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019260:	781b      	ldrb	r3, [r3, #0]
 8019262:	2204      	movs	r2, #4
 8019264:	4013      	ands	r3, r2
 8019266:	b2db      	uxtb	r3, r3
 8019268:	2b00      	cmp	r3, #0
 801926a:	d002      	beq.n	8019272 <lcp_reqci+0x10a>
 801926c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801926e:	2b04      	cmp	r3, #4
 8019270:	d002      	beq.n	8019278 <lcp_reqci+0x110>
		cilen != CILEN_SHORT) {	/* Check CI length */
		orc = CONFREJ;		/* Reject CI */
 8019272:	2304      	movs	r3, #4
 8019274:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 8019276:	e19b      	b.n	80195b0 <lcp_reqci+0x448>
	    }
	    GETSHORT(cishort, p);	/* Parse MRU */
 8019278:	6a3b      	ldr	r3, [r7, #32]
 801927a:	1c5a      	adds	r2, r3, #1
 801927c:	623a      	str	r2, [r7, #32]
 801927e:	781b      	ldrb	r3, [r3, #0]
 8019280:	b29a      	uxth	r2, r3
 8019282:	2012      	movs	r0, #18
 8019284:	183b      	adds	r3, r7, r0
 8019286:	0212      	lsls	r2, r2, #8
 8019288:	801a      	strh	r2, [r3, #0]
 801928a:	6a3b      	ldr	r3, [r7, #32]
 801928c:	1c5a      	adds	r2, r3, #1
 801928e:	623a      	str	r2, [r7, #32]
 8019290:	781b      	ldrb	r3, [r3, #0]
 8019292:	b299      	uxth	r1, r3
 8019294:	183b      	adds	r3, r7, r0
 8019296:	183a      	adds	r2, r7, r0
 8019298:	8812      	ldrh	r2, [r2, #0]
 801929a:	430a      	orrs	r2, r1
 801929c:	801a      	strh	r2, [r3, #0]
	    /*
	     * He must be able to receive at least our minimum.
	     * No need to check a maximum.  If he sends a large number,
	     * we'll just ignore it.
	     */
	    if (cishort < PPP_MINMRU) {
 801929e:	183b      	adds	r3, r7, r0
 80192a0:	881b      	ldrh	r3, [r3, #0]
 80192a2:	2b7f      	cmp	r3, #127	; 0x7f
 80192a4:	d816      	bhi.n	80192d4 <lcp_reqci+0x16c>
		orc = CONFNAK;		/* Nak CI */
 80192a6:	2303      	movs	r3, #3
 80192a8:	647b      	str	r3, [r7, #68]	; 0x44
		PUTCHAR(CI_MRU, nakoutp);
 80192aa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80192ac:	1c5a      	adds	r2, r3, #1
 80192ae:	63fa      	str	r2, [r7, #60]	; 0x3c
 80192b0:	2201      	movs	r2, #1
 80192b2:	701a      	strb	r2, [r3, #0]
		PUTCHAR(CILEN_SHORT, nakoutp);
 80192b4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80192b6:	1c5a      	adds	r2, r3, #1
 80192b8:	63fa      	str	r2, [r7, #60]	; 0x3c
 80192ba:	2204      	movs	r2, #4
 80192bc:	701a      	strb	r2, [r3, #0]
		PUTSHORT(PPP_MINMRU, nakoutp);	/* Give him a hint */
 80192be:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80192c0:	1c5a      	adds	r2, r3, #1
 80192c2:	63fa      	str	r2, [r7, #60]	; 0x3c
 80192c4:	2200      	movs	r2, #0
 80192c6:	701a      	strb	r2, [r3, #0]
 80192c8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80192ca:	1c5a      	adds	r2, r3, #1
 80192cc:	63fa      	str	r2, [r7, #60]	; 0x3c
 80192ce:	2280      	movs	r2, #128	; 0x80
 80192d0:	701a      	strb	r2, [r3, #0]
		break;
 80192d2:	e16d      	b.n	80195b0 <lcp_reqci+0x448>
	    }
	    ho->neg_mru = 1;		/* Remember he sent MRU */
 80192d4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80192d6:	781a      	ldrb	r2, [r3, #0]
 80192d8:	2104      	movs	r1, #4
 80192da:	430a      	orrs	r2, r1
 80192dc:	701a      	strb	r2, [r3, #0]
	    ho->mru = cishort;		/* And remember value */
 80192de:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80192e0:	2212      	movs	r2, #18
 80192e2:	18ba      	adds	r2, r7, r2
 80192e4:	8812      	ldrh	r2, [r2, #0]
 80192e6:	805a      	strh	r2, [r3, #2]
	    break;
 80192e8:	e162      	b.n	80195b0 <lcp_reqci+0x448>

	case CI_ASYNCMAP:
	    if (!ao->neg_asyncmap ||
 80192ea:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80192ec:	781b      	ldrb	r3, [r3, #0]
 80192ee:	2208      	movs	r2, #8
 80192f0:	4013      	ands	r3, r2
 80192f2:	b2db      	uxtb	r3, r3
 80192f4:	2b00      	cmp	r3, #0
 80192f6:	d002      	beq.n	80192fe <lcp_reqci+0x196>
 80192f8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80192fa:	2b06      	cmp	r3, #6
 80192fc:	d002      	beq.n	8019304 <lcp_reqci+0x19c>
		cilen != CILEN_LONG) {
		orc = CONFREJ;
 80192fe:	2304      	movs	r3, #4
 8019300:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 8019302:	e155      	b.n	80195b0 <lcp_reqci+0x448>
	    }
	    GETLONG(cilong, p);
 8019304:	6a3b      	ldr	r3, [r7, #32]
 8019306:	1c5a      	adds	r2, r3, #1
 8019308:	623a      	str	r2, [r7, #32]
 801930a:	781b      	ldrb	r3, [r3, #0]
 801930c:	021b      	lsls	r3, r3, #8
 801930e:	617b      	str	r3, [r7, #20]
 8019310:	6a3b      	ldr	r3, [r7, #32]
 8019312:	1c5a      	adds	r2, r3, #1
 8019314:	623a      	str	r2, [r7, #32]
 8019316:	781b      	ldrb	r3, [r3, #0]
 8019318:	001a      	movs	r2, r3
 801931a:	697b      	ldr	r3, [r7, #20]
 801931c:	4313      	orrs	r3, r2
 801931e:	617b      	str	r3, [r7, #20]
 8019320:	697b      	ldr	r3, [r7, #20]
 8019322:	021b      	lsls	r3, r3, #8
 8019324:	617b      	str	r3, [r7, #20]
 8019326:	6a3b      	ldr	r3, [r7, #32]
 8019328:	1c5a      	adds	r2, r3, #1
 801932a:	623a      	str	r2, [r7, #32]
 801932c:	781b      	ldrb	r3, [r3, #0]
 801932e:	001a      	movs	r2, r3
 8019330:	697b      	ldr	r3, [r7, #20]
 8019332:	4313      	orrs	r3, r2
 8019334:	617b      	str	r3, [r7, #20]
 8019336:	697b      	ldr	r3, [r7, #20]
 8019338:	021b      	lsls	r3, r3, #8
 801933a:	617b      	str	r3, [r7, #20]
 801933c:	6a3b      	ldr	r3, [r7, #32]
 801933e:	1c5a      	adds	r2, r3, #1
 8019340:	623a      	str	r2, [r7, #32]
 8019342:	781b      	ldrb	r3, [r3, #0]
 8019344:	001a      	movs	r2, r3
 8019346:	697b      	ldr	r3, [r7, #20]
 8019348:	4313      	orrs	r3, r2
 801934a:	617b      	str	r3, [r7, #20]

	    /*
	     * Asyncmap must have set at least the bits
	     * which are set in lcp_allowoptions[unit].asyncmap.
	     */
	    if ((ao->asyncmap & ~cilong) != 0) {
 801934c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801934e:	685b      	ldr	r3, [r3, #4]
 8019350:	697a      	ldr	r2, [r7, #20]
 8019352:	43d2      	mvns	r2, r2
 8019354:	4013      	ands	r3, r2
 8019356:	d035      	beq.n	80193c4 <lcp_reqci+0x25c>
		orc = CONFNAK;
 8019358:	2303      	movs	r3, #3
 801935a:	647b      	str	r3, [r7, #68]	; 0x44
		PUTCHAR(CI_ASYNCMAP, nakoutp);
 801935c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801935e:	1c5a      	adds	r2, r3, #1
 8019360:	63fa      	str	r2, [r7, #60]	; 0x3c
 8019362:	2202      	movs	r2, #2
 8019364:	701a      	strb	r2, [r3, #0]
		PUTCHAR(CILEN_LONG, nakoutp);
 8019366:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8019368:	1c5a      	adds	r2, r3, #1
 801936a:	63fa      	str	r2, [r7, #60]	; 0x3c
 801936c:	2206      	movs	r2, #6
 801936e:	701a      	strb	r2, [r3, #0]
		PUTLONG(ao->asyncmap | cilong, nakoutp);
 8019370:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019372:	685a      	ldr	r2, [r3, #4]
 8019374:	697b      	ldr	r3, [r7, #20]
 8019376:	4313      	orrs	r3, r2
 8019378:	0e19      	lsrs	r1, r3, #24
 801937a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801937c:	1c5a      	adds	r2, r3, #1
 801937e:	63fa      	str	r2, [r7, #60]	; 0x3c
 8019380:	b2ca      	uxtb	r2, r1
 8019382:	701a      	strb	r2, [r3, #0]
 8019384:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019386:	685a      	ldr	r2, [r3, #4]
 8019388:	697b      	ldr	r3, [r7, #20]
 801938a:	4313      	orrs	r3, r2
 801938c:	0c19      	lsrs	r1, r3, #16
 801938e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8019390:	1c5a      	adds	r2, r3, #1
 8019392:	63fa      	str	r2, [r7, #60]	; 0x3c
 8019394:	b2ca      	uxtb	r2, r1
 8019396:	701a      	strb	r2, [r3, #0]
 8019398:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801939a:	685a      	ldr	r2, [r3, #4]
 801939c:	697b      	ldr	r3, [r7, #20]
 801939e:	4313      	orrs	r3, r2
 80193a0:	0a19      	lsrs	r1, r3, #8
 80193a2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80193a4:	1c5a      	adds	r2, r3, #1
 80193a6:	63fa      	str	r2, [r7, #60]	; 0x3c
 80193a8:	b2ca      	uxtb	r2, r1
 80193aa:	701a      	strb	r2, [r3, #0]
 80193ac:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80193ae:	685b      	ldr	r3, [r3, #4]
 80193b0:	b2d9      	uxtb	r1, r3
 80193b2:	697b      	ldr	r3, [r7, #20]
 80193b4:	b2da      	uxtb	r2, r3
 80193b6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80193b8:	1c58      	adds	r0, r3, #1
 80193ba:	63f8      	str	r0, [r7, #60]	; 0x3c
 80193bc:	430a      	orrs	r2, r1
 80193be:	b2d2      	uxtb	r2, r2
 80193c0:	701a      	strb	r2, [r3, #0]
		break;
 80193c2:	e0f5      	b.n	80195b0 <lcp_reqci+0x448>
	    }
	    ho->neg_asyncmap = 1;
 80193c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80193c6:	781a      	ldrb	r2, [r3, #0]
 80193c8:	2108      	movs	r1, #8
 80193ca:	430a      	orrs	r2, r1
 80193cc:	701a      	strb	r2, [r3, #0]
	    ho->asyncmap = cilong;
 80193ce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80193d0:	697a      	ldr	r2, [r7, #20]
 80193d2:	605a      	str	r2, [r3, #4]
	    break;
 80193d4:	e0ec      	b.n	80195b0 <lcp_reqci+0x448>
#endif /* EAP_SUPPORT */
		)) {
		/*
		 * Reject the option if we're not willing to authenticate.
		 */
		ppp_dbglog("No auth is possible");
 80193d6:	4b7b      	ldr	r3, [pc, #492]	; (80195c4 <lcp_reqci+0x45c>)
 80193d8:	0018      	movs	r0, r3
 80193da:	f002 fa68 	bl	801b8ae <ppp_dbglog>
		orc = CONFREJ;
 80193de:	2304      	movs	r3, #4
 80193e0:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 80193e2:	e0e5      	b.n	80195b0 <lcp_reqci+0x448>
	    }
	    break;
#endif /* LQR_SUPPORT */

	case CI_MAGICNUMBER:
	    if (!(ao->neg_magicnumber || go->neg_magicnumber) ||
 80193e4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80193e6:	781b      	ldrb	r3, [r3, #0]
 80193e8:	2210      	movs	r2, #16
 80193ea:	4013      	ands	r3, r2
 80193ec:	b2db      	uxtb	r3, r3
 80193ee:	2b00      	cmp	r3, #0
 80193f0:	d106      	bne.n	8019400 <lcp_reqci+0x298>
 80193f2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80193f4:	781b      	ldrb	r3, [r3, #0]
 80193f6:	2210      	movs	r2, #16
 80193f8:	4013      	ands	r3, r2
 80193fa:	b2db      	uxtb	r3, r3
 80193fc:	2b00      	cmp	r3, #0
 80193fe:	d002      	beq.n	8019406 <lcp_reqci+0x29e>
 8019400:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019402:	2b06      	cmp	r3, #6
 8019404:	d002      	beq.n	801940c <lcp_reqci+0x2a4>
		cilen != CILEN_LONG) {
		orc = CONFREJ;
 8019406:	2304      	movs	r3, #4
 8019408:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 801940a:	e0d1      	b.n	80195b0 <lcp_reqci+0x448>
	    }
	    GETLONG(cilong, p);
 801940c:	6a3b      	ldr	r3, [r7, #32]
 801940e:	1c5a      	adds	r2, r3, #1
 8019410:	623a      	str	r2, [r7, #32]
 8019412:	781b      	ldrb	r3, [r3, #0]
 8019414:	021b      	lsls	r3, r3, #8
 8019416:	617b      	str	r3, [r7, #20]
 8019418:	6a3b      	ldr	r3, [r7, #32]
 801941a:	1c5a      	adds	r2, r3, #1
 801941c:	623a      	str	r2, [r7, #32]
 801941e:	781b      	ldrb	r3, [r3, #0]
 8019420:	001a      	movs	r2, r3
 8019422:	697b      	ldr	r3, [r7, #20]
 8019424:	4313      	orrs	r3, r2
 8019426:	617b      	str	r3, [r7, #20]
 8019428:	697b      	ldr	r3, [r7, #20]
 801942a:	021b      	lsls	r3, r3, #8
 801942c:	617b      	str	r3, [r7, #20]
 801942e:	6a3b      	ldr	r3, [r7, #32]
 8019430:	1c5a      	adds	r2, r3, #1
 8019432:	623a      	str	r2, [r7, #32]
 8019434:	781b      	ldrb	r3, [r3, #0]
 8019436:	001a      	movs	r2, r3
 8019438:	697b      	ldr	r3, [r7, #20]
 801943a:	4313      	orrs	r3, r2
 801943c:	617b      	str	r3, [r7, #20]
 801943e:	697b      	ldr	r3, [r7, #20]
 8019440:	021b      	lsls	r3, r3, #8
 8019442:	617b      	str	r3, [r7, #20]
 8019444:	6a3b      	ldr	r3, [r7, #32]
 8019446:	1c5a      	adds	r2, r3, #1
 8019448:	623a      	str	r2, [r7, #32]
 801944a:	781b      	ldrb	r3, [r3, #0]
 801944c:	001a      	movs	r2, r3
 801944e:	697b      	ldr	r3, [r7, #20]
 8019450:	4313      	orrs	r3, r2
 8019452:	617b      	str	r3, [r7, #20]

	    /*
	     * He must have a different magic number.
	     */
	    if (go->neg_magicnumber &&
 8019454:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019456:	781b      	ldrb	r3, [r3, #0]
 8019458:	2210      	movs	r2, #16
 801945a:	4013      	ands	r3, r2
 801945c:	b2db      	uxtb	r3, r3
 801945e:	2b00      	cmp	r3, #0
 8019460:	d030      	beq.n	80194c4 <lcp_reqci+0x35c>
		cilong == go->magicnumber) {
 8019462:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019464:	689b      	ldr	r3, [r3, #8]
	    if (go->neg_magicnumber &&
 8019466:	697a      	ldr	r2, [r7, #20]
 8019468:	429a      	cmp	r2, r3
 801946a:	d12b      	bne.n	80194c4 <lcp_reqci+0x35c>
		cilong = magic();	/* Don't put magic() inside macro! */
 801946c:	f000 fbba 	bl	8019be4 <magic>
 8019470:	0003      	movs	r3, r0
 8019472:	617b      	str	r3, [r7, #20]
		orc = CONFNAK;
 8019474:	2303      	movs	r3, #3
 8019476:	647b      	str	r3, [r7, #68]	; 0x44
		PUTCHAR(CI_MAGICNUMBER, nakoutp);
 8019478:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801947a:	1c5a      	adds	r2, r3, #1
 801947c:	63fa      	str	r2, [r7, #60]	; 0x3c
 801947e:	2205      	movs	r2, #5
 8019480:	701a      	strb	r2, [r3, #0]
		PUTCHAR(CILEN_LONG, nakoutp);
 8019482:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8019484:	1c5a      	adds	r2, r3, #1
 8019486:	63fa      	str	r2, [r7, #60]	; 0x3c
 8019488:	2206      	movs	r2, #6
 801948a:	701a      	strb	r2, [r3, #0]
		PUTLONG(cilong, nakoutp);
 801948c:	697b      	ldr	r3, [r7, #20]
 801948e:	0e19      	lsrs	r1, r3, #24
 8019490:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8019492:	1c5a      	adds	r2, r3, #1
 8019494:	63fa      	str	r2, [r7, #60]	; 0x3c
 8019496:	b2ca      	uxtb	r2, r1
 8019498:	701a      	strb	r2, [r3, #0]
 801949a:	697b      	ldr	r3, [r7, #20]
 801949c:	0c19      	lsrs	r1, r3, #16
 801949e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80194a0:	1c5a      	adds	r2, r3, #1
 80194a2:	63fa      	str	r2, [r7, #60]	; 0x3c
 80194a4:	b2ca      	uxtb	r2, r1
 80194a6:	701a      	strb	r2, [r3, #0]
 80194a8:	697b      	ldr	r3, [r7, #20]
 80194aa:	0a19      	lsrs	r1, r3, #8
 80194ac:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80194ae:	1c5a      	adds	r2, r3, #1
 80194b0:	63fa      	str	r2, [r7, #60]	; 0x3c
 80194b2:	b2ca      	uxtb	r2, r1
 80194b4:	701a      	strb	r2, [r3, #0]
 80194b6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80194b8:	1c5a      	adds	r2, r3, #1
 80194ba:	63fa      	str	r2, [r7, #60]	; 0x3c
 80194bc:	697a      	ldr	r2, [r7, #20]
 80194be:	b2d2      	uxtb	r2, r2
 80194c0:	701a      	strb	r2, [r3, #0]
		break;
 80194c2:	e075      	b.n	80195b0 <lcp_reqci+0x448>
	    }
	    ho->neg_magicnumber = 1;
 80194c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80194c6:	781a      	ldrb	r2, [r3, #0]
 80194c8:	2110      	movs	r1, #16
 80194ca:	430a      	orrs	r2, r1
 80194cc:	701a      	strb	r2, [r3, #0]
	    ho->magicnumber = cilong;
 80194ce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80194d0:	697a      	ldr	r2, [r7, #20]
 80194d2:	609a      	str	r2, [r3, #8]
	    break;
 80194d4:	e06c      	b.n	80195b0 <lcp_reqci+0x448>


	case CI_PCOMPRESSION:
	    if (!ao->neg_pcompression ||
 80194d6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80194d8:	781b      	ldrb	r3, [r3, #0]
 80194da:	2220      	movs	r2, #32
 80194dc:	4013      	ands	r3, r2
 80194de:	b2db      	uxtb	r3, r3
 80194e0:	2b00      	cmp	r3, #0
 80194e2:	d002      	beq.n	80194ea <lcp_reqci+0x382>
 80194e4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80194e6:	2b02      	cmp	r3, #2
 80194e8:	d002      	beq.n	80194f0 <lcp_reqci+0x388>
		cilen != CILEN_VOID) {
		orc = CONFREJ;
 80194ea:	2304      	movs	r3, #4
 80194ec:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 80194ee:	e05f      	b.n	80195b0 <lcp_reqci+0x448>
	    }
	    ho->neg_pcompression = 1;
 80194f0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80194f2:	781a      	ldrb	r2, [r3, #0]
 80194f4:	2120      	movs	r1, #32
 80194f6:	430a      	orrs	r2, r1
 80194f8:	701a      	strb	r2, [r3, #0]
	    break;
 80194fa:	e059      	b.n	80195b0 <lcp_reqci+0x448>

	case CI_ACCOMPRESSION:
	    if (!ao->neg_accompression ||
 80194fc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80194fe:	781b      	ldrb	r3, [r3, #0]
 8019500:	2240      	movs	r2, #64	; 0x40
 8019502:	4013      	ands	r3, r2
 8019504:	b2db      	uxtb	r3, r3
 8019506:	2b00      	cmp	r3, #0
 8019508:	d002      	beq.n	8019510 <lcp_reqci+0x3a8>
 801950a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801950c:	2b02      	cmp	r3, #2
 801950e:	d002      	beq.n	8019516 <lcp_reqci+0x3ae>
		cilen != CILEN_VOID) {
		orc = CONFREJ;
 8019510:	2304      	movs	r3, #4
 8019512:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 8019514:	e04c      	b.n	80195b0 <lcp_reqci+0x448>
	    }
	    ho->neg_accompression = 1;
 8019516:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019518:	781a      	ldrb	r2, [r3, #0]
 801951a:	2140      	movs	r1, #64	; 0x40
 801951c:	430a      	orrs	r2, r1
 801951e:	701a      	strb	r2, [r3, #0]
	    break;
 8019520:	e046      	b.n	80195b0 <lcp_reqci+0x448>
	    ho->mrru = cishort;
	    break;
#endif /* HAVE_MULTILINK */

	case CI_SSNHF:
	    if (!ao->neg_ssnhf
 8019522:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019524:	785b      	ldrb	r3, [r3, #1]
 8019526:	2201      	movs	r2, #1
 8019528:	4013      	ands	r3, r2
 801952a:	b2db      	uxtb	r3, r3
 801952c:	2b00      	cmp	r3, #0
 801952e:	d002      	beq.n	8019536 <lcp_reqci+0x3ce>
#ifdef HAVE_MULTILINK
		|| !multilink
#endif /* HAVE_MULTILINK */
		|| cilen != CILEN_VOID) {
 8019530:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019532:	2b02      	cmp	r3, #2
 8019534:	d002      	beq.n	801953c <lcp_reqci+0x3d4>
		orc = CONFREJ;
 8019536:	2304      	movs	r3, #4
 8019538:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 801953a:	e039      	b.n	80195b0 <lcp_reqci+0x448>
	    }
	    ho->neg_ssnhf = 1;
 801953c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801953e:	785a      	ldrb	r2, [r3, #1]
 8019540:	2101      	movs	r1, #1
 8019542:	430a      	orrs	r2, r1
 8019544:	705a      	strb	r2, [r3, #1]
	    break;
 8019546:	e033      	b.n	80195b0 <lcp_reqci+0x448>

	case CI_EPDISC:
	    if (!ao->neg_endpoint ||
 8019548:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801954a:	785b      	ldrb	r3, [r3, #1]
 801954c:	2202      	movs	r2, #2
 801954e:	4013      	ands	r3, r2
 8019550:	b2db      	uxtb	r3, r3
 8019552:	2b00      	cmp	r3, #0
 8019554:	d005      	beq.n	8019562 <lcp_reqci+0x3fa>
 8019556:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019558:	2b02      	cmp	r3, #2
 801955a:	dd02      	ble.n	8019562 <lcp_reqci+0x3fa>
		cilen < CILEN_CHAR ||
 801955c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801955e:	2b17      	cmp	r3, #23
 8019560:	dd02      	ble.n	8019568 <lcp_reqci+0x400>
		cilen > CILEN_CHAR + MAX_ENDP_LEN) {
		orc = CONFREJ;
 8019562:	2304      	movs	r3, #4
 8019564:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 8019566:	e023      	b.n	80195b0 <lcp_reqci+0x448>
	    }
	    GETCHAR(cichar, p);
 8019568:	6a3b      	ldr	r3, [r7, #32]
 801956a:	1c5a      	adds	r2, r3, #1
 801956c:	623a      	str	r2, [r7, #32]
 801956e:	781b      	ldrb	r3, [r3, #0]
 8019570:	61bb      	str	r3, [r7, #24]
	    cilen -= CILEN_CHAR;
 8019572:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019574:	3b03      	subs	r3, #3
 8019576:	653b      	str	r3, [r7, #80]	; 0x50
	    ho->neg_endpoint = 1;
 8019578:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801957a:	785a      	ldrb	r2, [r3, #1]
 801957c:	2102      	movs	r1, #2
 801957e:	430a      	orrs	r2, r1
 8019580:	705a      	strb	r2, [r3, #1]
	    ho->endpoint.class_ = cichar;
 8019582:	69bb      	ldr	r3, [r7, #24]
 8019584:	b2da      	uxtb	r2, r3
 8019586:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019588:	735a      	strb	r2, [r3, #13]
	    ho->endpoint.length = cilen;
 801958a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801958c:	b2da      	uxtb	r2, r3
 801958e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019590:	739a      	strb	r2, [r3, #14]
	    MEMCPY(ho->endpoint.value, p, cilen);
 8019592:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019594:	330f      	adds	r3, #15
 8019596:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8019598:	6a39      	ldr	r1, [r7, #32]
 801959a:	0018      	movs	r0, r3
 801959c:	f003 fc96 	bl	801cecc <memcpy>
	    INCPTR(cilen, p);
 80195a0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80195a2:	6a3a      	ldr	r2, [r7, #32]
 80195a4:	18d3      	adds	r3, r2, r3
 80195a6:	623b      	str	r3, [r7, #32]
	    break;
 80195a8:	e002      	b.n	80195b0 <lcp_reqci+0x448>

	default:
	    LCPDEBUG(("lcp_reqci: rcvd unknown option %d", citype));
	    orc = CONFREJ;
 80195aa:	2304      	movs	r3, #4
 80195ac:	647b      	str	r3, [r7, #68]	; 0x44
	    break;
 80195ae:	46c0      	nop			; (mov r8, r8)
	}

endswitch:
	if (orc == CONFACK &&		/* Good CI */
 80195b0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80195b2:	2b02      	cmp	r3, #2
 80195b4:	d108      	bne.n	80195c8 <lcp_reqci+0x460>
 80195b6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80195b8:	2b02      	cmp	r3, #2
 80195ba:	d005      	beq.n	80195c8 <lcp_reqci+0x460>
	    rc != CONFACK)		/*  but prior CI wasnt? */
	    continue;			/* Don't send this one */
 80195bc:	e029      	b.n	8019612 <lcp_reqci+0x4aa>
 80195be:	46c0      	nop			; (mov r8, r8)
 80195c0:	08022a94 	.word	0x08022a94
 80195c4:	08021db8 	.word	0x08021db8

	if (orc == CONFNAK) {		/* Nak this CI? */
 80195c8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80195ca:	2b03      	cmp	r3, #3
 80195cc:	d10e      	bne.n	80195ec <lcp_reqci+0x484>
	    if (reject_if_disagree	/* Getting fed up with sending NAKs? */
 80195ce:	683b      	ldr	r3, [r7, #0]
 80195d0:	2b00      	cmp	r3, #0
 80195d2:	d005      	beq.n	80195e0 <lcp_reqci+0x478>
		&& citype != CI_MAGICNUMBER) {
 80195d4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80195d6:	2b05      	cmp	r3, #5
 80195d8:	d002      	beq.n	80195e0 <lcp_reqci+0x478>
		orc = CONFREJ;		/* Get tough if so */
 80195da:	2304      	movs	r3, #4
 80195dc:	647b      	str	r3, [r7, #68]	; 0x44
 80195de:	e005      	b.n	80195ec <lcp_reqci+0x484>
	    } else {
		if (rc == CONFREJ)	/* Rejecting prior CI? */
 80195e0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80195e2:	2b04      	cmp	r3, #4
 80195e4:	d100      	bne.n	80195e8 <lcp_reqci+0x480>
		    continue;		/* Don't send this one */
 80195e6:	e014      	b.n	8019612 <lcp_reqci+0x4aa>
		rc = CONFNAK;
 80195e8:	2303      	movs	r3, #3
 80195ea:	64bb      	str	r3, [r7, #72]	; 0x48
	    }
	}
	if (orc == CONFREJ) {		/* Reject this CI */
 80195ec:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80195ee:	2b04      	cmp	r3, #4
 80195f0:	d10f      	bne.n	8019612 <lcp_reqci+0x4aa>
	    rc = CONFREJ;
 80195f2:	2304      	movs	r3, #4
 80195f4:	64bb      	str	r3, [r7, #72]	; 0x48
	    if (cip != rejp)		/* Need to move rejected CI? */
 80195f6:	69fa      	ldr	r2, [r7, #28]
 80195f8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80195fa:	429a      	cmp	r2, r3
 80195fc:	d005      	beq.n	801960a <lcp_reqci+0x4a2>
		MEMCPY(rejp, cip, cilen); /* Move it */
 80195fe:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8019600:	69f9      	ldr	r1, [r7, #28]
 8019602:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8019604:	0018      	movs	r0, r3
 8019606:	f003 fc61 	bl	801cecc <memcpy>
	    INCPTR(cilen, rejp);	/* Update output pointer */
 801960a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801960c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801960e:	18d3      	adds	r3, r2, r3
 8019610:	643b      	str	r3, [r7, #64]	; 0x40
    while (l) {
 8019612:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8019614:	2b00      	cmp	r3, #0
 8019616:	d000      	beq.n	801961a <lcp_reqci+0x4b2>
 8019618:	e5e7      	b.n	80191ea <lcp_reqci+0x82>
     * code would go here.  The extra NAKs would go at *nakoutp.
     * At present there are no cases where we want to ask the
     * peer to negotiate an option.
     */

    switch (rc) {
 801961a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801961c:	2b04      	cmp	r3, #4
 801961e:	d01f      	beq.n	8019660 <lcp_reqci+0x4f8>
 8019620:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8019622:	2b04      	cmp	r3, #4
 8019624:	dc22      	bgt.n	801966c <lcp_reqci+0x504>
 8019626:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8019628:	2b02      	cmp	r3, #2
 801962a:	d003      	beq.n	8019634 <lcp_reqci+0x4cc>
 801962c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801962e:	2b03      	cmp	r3, #3
 8019630:	d006      	beq.n	8019640 <lcp_reqci+0x4d8>
	break;
    case CONFREJ:
	*lenp = rejp - inp;
	break;
    default:
	break;
 8019632:	e01b      	b.n	801966c <lcp_reqci+0x504>
	*lenp = next - inp;
 8019634:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8019636:	68bb      	ldr	r3, [r7, #8]
 8019638:	1ad2      	subs	r2, r2, r3
 801963a:	687b      	ldr	r3, [r7, #4]
 801963c:	601a      	str	r2, [r3, #0]
	break;
 801963e:	e016      	b.n	801966e <lcp_reqci+0x506>
	*lenp = nakoutp - (u_char*)nakp->payload;
 8019640:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019642:	685b      	ldr	r3, [r3, #4]
 8019644:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8019646:	1ad2      	subs	r2, r2, r3
 8019648:	687b      	ldr	r3, [r7, #4]
 801964a:	601a      	str	r2, [r3, #0]
	MEMCPY(inp, nakp->payload, *lenp);
 801964c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801964e:	6859      	ldr	r1, [r3, #4]
 8019650:	687b      	ldr	r3, [r7, #4]
 8019652:	681b      	ldr	r3, [r3, #0]
 8019654:	001a      	movs	r2, r3
 8019656:	68bb      	ldr	r3, [r7, #8]
 8019658:	0018      	movs	r0, r3
 801965a:	f003 fc37 	bl	801cecc <memcpy>
	break;
 801965e:	e006      	b.n	801966e <lcp_reqci+0x506>
	*lenp = rejp - inp;
 8019660:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8019662:	68bb      	ldr	r3, [r7, #8]
 8019664:	1ad2      	subs	r2, r2, r3
 8019666:	687b      	ldr	r3, [r7, #4]
 8019668:	601a      	str	r2, [r3, #0]
	break;
 801966a:	e000      	b.n	801966e <lcp_reqci+0x506>
	break;
 801966c:	46c0      	nop			; (mov r8, r8)
    }

    pbuf_free(nakp);
 801966e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019670:	0018      	movs	r0, r3
 8019672:	f7f0 fc23 	bl	8009ebc <pbuf_free>
    LCPDEBUG(("lcp_reqci: returning CONF%s.", CODENAME(rc)));
    return (rc);			/* Return final code */
 8019676:	6cbb      	ldr	r3, [r7, #72]	; 0x48
}
 8019678:	0018      	movs	r0, r3
 801967a:	46bd      	mov	sp, r7
 801967c:	b016      	add	sp, #88	; 0x58
 801967e:	bd80      	pop	{r7, pc}

08019680 <lcp_up>:


/*
 * lcp_up - LCP has come UP.
 */
static void lcp_up(fsm *f) {
 8019680:	b590      	push	{r4, r7, lr}
 8019682:	b08d      	sub	sp, #52	; 0x34
 8019684:	af02      	add	r7, sp, #8
 8019686:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8019688:	687b      	ldr	r3, [r7, #4]
 801968a:	681b      	ldr	r3, [r3, #0]
 801968c:	627b      	str	r3, [r7, #36]	; 0x24
    lcp_options *wo = &pcb->lcp_wantoptions;
 801968e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019690:	3344      	adds	r3, #68	; 0x44
 8019692:	623b      	str	r3, [r7, #32]
    lcp_options *ho = &pcb->lcp_hisoptions;
 8019694:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019696:	33b0      	adds	r3, #176	; 0xb0
 8019698:	61fb      	str	r3, [r7, #28]
    lcp_options *go = &pcb->lcp_gotoptions;
 801969a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801969c:	3368      	adds	r3, #104	; 0x68
 801969e:	61bb      	str	r3, [r7, #24]
    lcp_options *ao = &pcb->lcp_allowoptions;
 80196a0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80196a2:	338c      	adds	r3, #140	; 0x8c
 80196a4:	617b      	str	r3, [r7, #20]
    int mtu, mru;

    if (!go->neg_magicnumber)
 80196a6:	69bb      	ldr	r3, [r7, #24]
 80196a8:	781b      	ldrb	r3, [r3, #0]
 80196aa:	2210      	movs	r2, #16
 80196ac:	4013      	ands	r3, r2
 80196ae:	b2db      	uxtb	r3, r3
 80196b0:	2b00      	cmp	r3, #0
 80196b2:	d102      	bne.n	80196ba <lcp_up+0x3a>
	go->magicnumber = 0;
 80196b4:	69bb      	ldr	r3, [r7, #24]
 80196b6:	2200      	movs	r2, #0
 80196b8:	609a      	str	r2, [r3, #8]
    if (!ho->neg_magicnumber)
 80196ba:	69fb      	ldr	r3, [r7, #28]
 80196bc:	781b      	ldrb	r3, [r3, #0]
 80196be:	2210      	movs	r2, #16
 80196c0:	4013      	ands	r3, r2
 80196c2:	b2db      	uxtb	r3, r3
 80196c4:	2b00      	cmp	r3, #0
 80196c6:	d102      	bne.n	80196ce <lcp_up+0x4e>
	ho->magicnumber = 0;
 80196c8:	69fb      	ldr	r3, [r7, #28]
 80196ca:	2200      	movs	r2, #0
 80196cc:	609a      	str	r2, [r3, #8]
     * the value we got in the negotiation.
     * Note on the MTU: the link MTU can be the MRU the peer wanted,
     * the interface MTU is set to the lowest of that, the
     * MTU we want to use, and our link MRU.
     */
    mtu = ho->neg_mru? ho->mru: PPP_MRU;
 80196ce:	69fb      	ldr	r3, [r7, #28]
 80196d0:	781b      	ldrb	r3, [r3, #0]
 80196d2:	2204      	movs	r2, #4
 80196d4:	4013      	ands	r3, r2
 80196d6:	b2db      	uxtb	r3, r3
 80196d8:	2b00      	cmp	r3, #0
 80196da:	d002      	beq.n	80196e2 <lcp_up+0x62>
 80196dc:	69fb      	ldr	r3, [r7, #28]
 80196de:	885b      	ldrh	r3, [r3, #2]
 80196e0:	e000      	b.n	80196e4 <lcp_up+0x64>
 80196e2:	4b42      	ldr	r3, [pc, #264]	; (80197ec <lcp_up+0x16c>)
 80196e4:	613b      	str	r3, [r7, #16]
    mru = go->neg_mru? LWIP_MAX(wo->mru, go->mru): PPP_MRU;
 80196e6:	69bb      	ldr	r3, [r7, #24]
 80196e8:	781b      	ldrb	r3, [r3, #0]
 80196ea:	2204      	movs	r2, #4
 80196ec:	4013      	ands	r3, r2
 80196ee:	b2db      	uxtb	r3, r3
 80196f0:	2b00      	cmp	r3, #0
 80196f2:	d00c      	beq.n	801970e <lcp_up+0x8e>
 80196f4:	69bb      	ldr	r3, [r7, #24]
 80196f6:	885a      	ldrh	r2, [r3, #2]
 80196f8:	6a3b      	ldr	r3, [r7, #32]
 80196fa:	885b      	ldrh	r3, [r3, #2]
 80196fc:	1c18      	adds	r0, r3, #0
 80196fe:	1c11      	adds	r1, r2, #0
 8019700:	b28a      	uxth	r2, r1
 8019702:	b283      	uxth	r3, r0
 8019704:	429a      	cmp	r2, r3
 8019706:	d200      	bcs.n	801970a <lcp_up+0x8a>
 8019708:	1c01      	adds	r1, r0, #0
 801970a:	b28b      	uxth	r3, r1
 801970c:	e000      	b.n	8019710 <lcp_up+0x90>
 801970e:	4b37      	ldr	r3, [pc, #220]	; (80197ec <lcp_up+0x16c>)
 8019710:	60fb      	str	r3, [r7, #12]
#ifdef HAVE_MULTILINK
    if (!(multilink && go->neg_mrru && ho->neg_mrru))
#endif /* HAVE_MULTILINK */
	netif_set_mtu(pcb, LWIP_MIN(LWIP_MIN(mtu, mru), ao->mru));
 8019712:	697b      	ldr	r3, [r7, #20]
 8019714:	885b      	ldrh	r3, [r3, #2]
 8019716:	0019      	movs	r1, r3
 8019718:	693a      	ldr	r2, [r7, #16]
 801971a:	68fb      	ldr	r3, [r7, #12]
 801971c:	4293      	cmp	r3, r2
 801971e:	dd00      	ble.n	8019722 <lcp_up+0xa2>
 8019720:	0013      	movs	r3, r2
 8019722:	000a      	movs	r2, r1
 8019724:	429a      	cmp	r2, r3
 8019726:	dd00      	ble.n	801972a <lcp_up+0xaa>
 8019728:	001a      	movs	r2, r3
 801972a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801972c:	0011      	movs	r1, r2
 801972e:	0018      	movs	r0, r3
 8019730:	f000 fefc 	bl	801a52c <netif_set_mtu>
    ppp_send_config(pcb, mtu,
		    (ho->neg_asyncmap? ho->asyncmap: 0xffffffff),
 8019734:	69fb      	ldr	r3, [r7, #28]
 8019736:	781b      	ldrb	r3, [r3, #0]
 8019738:	2208      	movs	r2, #8
 801973a:	4013      	ands	r3, r2
 801973c:	b2db      	uxtb	r3, r3
    ppp_send_config(pcb, mtu,
 801973e:	2b00      	cmp	r3, #0
 8019740:	d002      	beq.n	8019748 <lcp_up+0xc8>
 8019742:	69fb      	ldr	r3, [r7, #28]
 8019744:	685a      	ldr	r2, [r3, #4]
 8019746:	e001      	b.n	801974c <lcp_up+0xcc>
 8019748:	2301      	movs	r3, #1
 801974a:	425a      	negs	r2, r3
		    ho->neg_pcompression, ho->neg_accompression);
 801974c:	69fb      	ldr	r3, [r7, #28]
 801974e:	781b      	ldrb	r3, [r3, #0]
 8019750:	069b      	lsls	r3, r3, #26
 8019752:	0fdb      	lsrs	r3, r3, #31
 8019754:	b2db      	uxtb	r3, r3
    ppp_send_config(pcb, mtu,
 8019756:	001c      	movs	r4, r3
		    ho->neg_pcompression, ho->neg_accompression);
 8019758:	69fb      	ldr	r3, [r7, #28]
 801975a:	781b      	ldrb	r3, [r3, #0]
 801975c:	065b      	lsls	r3, r3, #25
 801975e:	0fdb      	lsrs	r3, r3, #31
 8019760:	b2db      	uxtb	r3, r3
    ppp_send_config(pcb, mtu,
 8019762:	6939      	ldr	r1, [r7, #16]
 8019764:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8019766:	9300      	str	r3, [sp, #0]
 8019768:	0023      	movs	r3, r4
 801976a:	f000 fdc1 	bl	801a2f0 <ppp_send_config>
    ppp_recv_config(pcb, mru,
		    (pcb->settings.lax_recv? 0: go->neg_asyncmap? go->asyncmap: 0xffffffff),
 801976e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019770:	781b      	ldrb	r3, [r3, #0]
 8019772:	2208      	movs	r2, #8
 8019774:	4013      	ands	r3, r2
 8019776:	b2db      	uxtb	r3, r3
    ppp_recv_config(pcb, mru,
 8019778:	2b00      	cmp	r3, #0
 801977a:	d10c      	bne.n	8019796 <lcp_up+0x116>
		    (pcb->settings.lax_recv? 0: go->neg_asyncmap? go->asyncmap: 0xffffffff),
 801977c:	69bb      	ldr	r3, [r7, #24]
 801977e:	781b      	ldrb	r3, [r3, #0]
 8019780:	2208      	movs	r2, #8
 8019782:	4013      	ands	r3, r2
 8019784:	b2db      	uxtb	r3, r3
 8019786:	2b00      	cmp	r3, #0
 8019788:	d002      	beq.n	8019790 <lcp_up+0x110>
 801978a:	69bb      	ldr	r3, [r7, #24]
 801978c:	685a      	ldr	r2, [r3, #4]
 801978e:	e003      	b.n	8019798 <lcp_up+0x118>
 8019790:	2301      	movs	r3, #1
 8019792:	425a      	negs	r2, r3
 8019794:	e000      	b.n	8019798 <lcp_up+0x118>
    ppp_recv_config(pcb, mru,
 8019796:	2200      	movs	r2, #0
		    go->neg_pcompression, go->neg_accompression);
 8019798:	69bb      	ldr	r3, [r7, #24]
 801979a:	781b      	ldrb	r3, [r3, #0]
 801979c:	069b      	lsls	r3, r3, #26
 801979e:	0fdb      	lsrs	r3, r3, #31
 80197a0:	b2db      	uxtb	r3, r3
    ppp_recv_config(pcb, mru,
 80197a2:	001c      	movs	r4, r3
		    go->neg_pcompression, go->neg_accompression);
 80197a4:	69bb      	ldr	r3, [r7, #24]
 80197a6:	781b      	ldrb	r3, [r3, #0]
 80197a8:	065b      	lsls	r3, r3, #25
 80197aa:	0fdb      	lsrs	r3, r3, #31
 80197ac:	b2db      	uxtb	r3, r3
    ppp_recv_config(pcb, mru,
 80197ae:	68f9      	ldr	r1, [r7, #12]
 80197b0:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80197b2:	9300      	str	r3, [sp, #0]
 80197b4:	0023      	movs	r3, r4
 80197b6:	f000 fdb8 	bl	801a32a <ppp_recv_config>

    if (ho->neg_mru)
 80197ba:	69fb      	ldr	r3, [r7, #28]
 80197bc:	781b      	ldrb	r3, [r3, #0]
 80197be:	2204      	movs	r2, #4
 80197c0:	4013      	ands	r3, r2
 80197c2:	b2db      	uxtb	r3, r3
 80197c4:	2b00      	cmp	r3, #0
 80197c6:	d004      	beq.n	80197d2 <lcp_up+0x152>
	pcb->peer_mru = ho->mru;
 80197c8:	69fb      	ldr	r3, [r7, #28]
 80197ca:	8859      	ldrh	r1, [r3, #2]
 80197cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80197ce:	22d4      	movs	r2, #212	; 0xd4
 80197d0:	5299      	strh	r1, [r3, r2]

    lcp_echo_lowerup(f->pcb);  /* Enable echo messages */
 80197d2:	687b      	ldr	r3, [r7, #4]
 80197d4:	681b      	ldr	r3, [r3, #0]
 80197d6:	0018      	movs	r0, r3
 80197d8:	f000 f9b0 	bl	8019b3c <lcp_echo_lowerup>

    link_established(pcb);
 80197dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80197de:	0018      	movs	r0, r3
 80197e0:	f7fa fdc6 	bl	8014370 <link_established>
}
 80197e4:	46c0      	nop			; (mov r8, r8)
 80197e6:	46bd      	mov	sp, r7
 80197e8:	b00b      	add	sp, #44	; 0x2c
 80197ea:	bd90      	pop	{r4, r7, pc}
 80197ec:	000005dc 	.word	0x000005dc

080197f0 <lcp_down>:
/*
 * lcp_down - LCP has gone DOWN.
 *
 * Alert other protocols.
 */
static void lcp_down(fsm *f) {
 80197f0:	b590      	push	{r4, r7, lr}
 80197f2:	b087      	sub	sp, #28
 80197f4:	af02      	add	r7, sp, #8
 80197f6:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 80197f8:	687b      	ldr	r3, [r7, #4]
 80197fa:	681b      	ldr	r3, [r3, #0]
 80197fc:	60fb      	str	r3, [r7, #12]
    lcp_options *go = &pcb->lcp_gotoptions;
 80197fe:	68fb      	ldr	r3, [r7, #12]
 8019800:	3368      	adds	r3, #104	; 0x68
 8019802:	60bb      	str	r3, [r7, #8]

    lcp_echo_lowerdown(f->pcb);
 8019804:	687b      	ldr	r3, [r7, #4]
 8019806:	681b      	ldr	r3, [r3, #0]
 8019808:	0018      	movs	r0, r3
 801980a:	f000 f9b9 	bl	8019b80 <lcp_echo_lowerdown>

    link_down(pcb);
 801980e:	68fb      	ldr	r3, [r7, #12]
 8019810:	0018      	movs	r0, r3
 8019812:	f7fa fd53 	bl	80142bc <link_down>

    ppp_send_config(pcb, PPP_MRU, 0xffffffff, 0, 0);
 8019816:	2301      	movs	r3, #1
 8019818:	425a      	negs	r2, r3
 801981a:	4916      	ldr	r1, [pc, #88]	; (8019874 <lcp_down+0x84>)
 801981c:	68f8      	ldr	r0, [r7, #12]
 801981e:	2300      	movs	r3, #0
 8019820:	9300      	str	r3, [sp, #0]
 8019822:	2300      	movs	r3, #0
 8019824:	f000 fd64 	bl	801a2f0 <ppp_send_config>
    ppp_recv_config(pcb, PPP_MRU,
		    (go->neg_asyncmap? go->asyncmap: 0xffffffff),
 8019828:	68bb      	ldr	r3, [r7, #8]
 801982a:	781b      	ldrb	r3, [r3, #0]
 801982c:	2208      	movs	r2, #8
 801982e:	4013      	ands	r3, r2
 8019830:	b2db      	uxtb	r3, r3
    ppp_recv_config(pcb, PPP_MRU,
 8019832:	2b00      	cmp	r3, #0
 8019834:	d002      	beq.n	801983c <lcp_down+0x4c>
 8019836:	68bb      	ldr	r3, [r7, #8]
 8019838:	685a      	ldr	r2, [r3, #4]
 801983a:	e001      	b.n	8019840 <lcp_down+0x50>
 801983c:	2301      	movs	r3, #1
 801983e:	425a      	negs	r2, r3
		    go->neg_pcompression, go->neg_accompression);
 8019840:	68bb      	ldr	r3, [r7, #8]
 8019842:	781b      	ldrb	r3, [r3, #0]
 8019844:	069b      	lsls	r3, r3, #26
 8019846:	0fdb      	lsrs	r3, r3, #31
 8019848:	b2db      	uxtb	r3, r3
    ppp_recv_config(pcb, PPP_MRU,
 801984a:	001c      	movs	r4, r3
		    go->neg_pcompression, go->neg_accompression);
 801984c:	68bb      	ldr	r3, [r7, #8]
 801984e:	781b      	ldrb	r3, [r3, #0]
 8019850:	065b      	lsls	r3, r3, #25
 8019852:	0fdb      	lsrs	r3, r3, #31
 8019854:	b2db      	uxtb	r3, r3
    ppp_recv_config(pcb, PPP_MRU,
 8019856:	4907      	ldr	r1, [pc, #28]	; (8019874 <lcp_down+0x84>)
 8019858:	68f8      	ldr	r0, [r7, #12]
 801985a:	9300      	str	r3, [sp, #0]
 801985c:	0023      	movs	r3, r4
 801985e:	f000 fd64 	bl	801a32a <ppp_recv_config>
    pcb->peer_mru = PPP_MRU;
 8019862:	68fb      	ldr	r3, [r7, #12]
 8019864:	22d4      	movs	r2, #212	; 0xd4
 8019866:	4903      	ldr	r1, [pc, #12]	; (8019874 <lcp_down+0x84>)
 8019868:	5299      	strh	r1, [r3, r2]
}
 801986a:	46c0      	nop			; (mov r8, r8)
 801986c:	46bd      	mov	sp, r7
 801986e:	b005      	add	sp, #20
 8019870:	bd90      	pop	{r4, r7, pc}
 8019872:	46c0      	nop			; (mov r8, r8)
 8019874:	000005dc 	.word	0x000005dc

08019878 <lcp_starting>:


/*
 * lcp_starting - LCP needs the lower layer up.
 */
static void lcp_starting(fsm *f) {
 8019878:	b580      	push	{r7, lr}
 801987a:	b084      	sub	sp, #16
 801987c:	af00      	add	r7, sp, #0
 801987e:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8019880:	687b      	ldr	r3, [r7, #4]
 8019882:	681b      	ldr	r3, [r3, #0]
 8019884:	60fb      	str	r3, [r7, #12]
    link_required(pcb);
 8019886:	68fb      	ldr	r3, [r7, #12]
 8019888:	0018      	movs	r0, r3
 801988a:	f7fa fced 	bl	8014268 <link_required>
}
 801988e:	46c0      	nop			; (mov r8, r8)
 8019890:	46bd      	mov	sp, r7
 8019892:	b004      	add	sp, #16
 8019894:	bd80      	pop	{r7, pc}

08019896 <lcp_finished>:


/*
 * lcp_finished - LCP has finished with the lower layer.
 */
static void lcp_finished(fsm *f) {
 8019896:	b580      	push	{r7, lr}
 8019898:	b084      	sub	sp, #16
 801989a:	af00      	add	r7, sp, #0
 801989c:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 801989e:	687b      	ldr	r3, [r7, #4]
 80198a0:	681b      	ldr	r3, [r3, #0]
 80198a2:	60fb      	str	r3, [r7, #12]
    link_terminated(pcb);
 80198a4:	68fb      	ldr	r3, [r7, #12]
 80198a6:	0018      	movs	r0, r3
 80198a8:	f7fa fce6 	bl	8014278 <link_terminated>
}
 80198ac:	46c0      	nop			; (mov r8, r8)
 80198ae:	46bd      	mov	sp, r7
 80198b0:	b004      	add	sp, #16
 80198b2:	bd80      	pop	{r7, pc}

080198b4 <LcpLinkFailure>:

/*
 * Time to shut down the link because there is nothing out there.
 */

static void LcpLinkFailure(fsm *f) {
 80198b4:	b580      	push	{r7, lr}
 80198b6:	b084      	sub	sp, #16
 80198b8:	af00      	add	r7, sp, #0
 80198ba:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 80198bc:	687b      	ldr	r3, [r7, #4]
 80198be:	681b      	ldr	r3, [r3, #0]
 80198c0:	60fb      	str	r3, [r7, #12]
    if (f->state == PPP_FSM_OPENED) {
 80198c2:	687b      	ldr	r3, [r7, #4]
 80198c4:	7c1b      	ldrb	r3, [r3, #16]
 80198c6:	2b09      	cmp	r3, #9
 80198c8:	d116      	bne.n	80198f8 <LcpLinkFailure+0x44>
	ppp_info("No response to %d echo-requests", pcb->lcp_echos_pending);
 80198ca:	68fb      	ldr	r3, [r7, #12]
 80198cc:	22d6      	movs	r2, #214	; 0xd6
 80198ce:	5c9b      	ldrb	r3, [r3, r2]
 80198d0:	001a      	movs	r2, r3
 80198d2:	4b0b      	ldr	r3, [pc, #44]	; (8019900 <LcpLinkFailure+0x4c>)
 80198d4:	0011      	movs	r1, r2
 80198d6:	0018      	movs	r0, r3
 80198d8:	f001 ffd5 	bl	801b886 <ppp_info>
        ppp_notice("Serial link appears to be disconnected.");
 80198dc:	4b09      	ldr	r3, [pc, #36]	; (8019904 <LcpLinkFailure+0x50>)
 80198de:	0018      	movs	r0, r3
 80198e0:	f001 ffbd 	bl	801b85e <ppp_notice>
	pcb->err_code = PPPERR_PEERDEAD;
 80198e4:	68fb      	ldr	r3, [r7, #12]
 80198e6:	2225      	movs	r2, #37	; 0x25
 80198e8:	2109      	movs	r1, #9
 80198ea:	5499      	strb	r1, [r3, r2]
	lcp_close(pcb, "Peer not responding");
 80198ec:	4a06      	ldr	r2, [pc, #24]	; (8019908 <LcpLinkFailure+0x54>)
 80198ee:	68fb      	ldr	r3, [r7, #12]
 80198f0:	0011      	movs	r1, r2
 80198f2:	0018      	movs	r0, r3
 80198f4:	f7fe f92e 	bl	8017b54 <lcp_close>
    }
}
 80198f8:	46c0      	nop			; (mov r8, r8)
 80198fa:	46bd      	mov	sp, r7
 80198fc:	b004      	add	sp, #16
 80198fe:	bd80      	pop	{r7, pc}
 8019900:	08021dcc 	.word	0x08021dcc
 8019904:	08021dec 	.word	0x08021dec
 8019908:	08021e14 	.word	0x08021e14

0801990c <LcpEchoCheck>:

/*
 * Timer expired for the LCP echo requests from this process.
 */

static void LcpEchoCheck(fsm *f) {
 801990c:	b580      	push	{r7, lr}
 801990e:	b084      	sub	sp, #16
 8019910:	af00      	add	r7, sp, #0
 8019912:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8019914:	687b      	ldr	r3, [r7, #4]
 8019916:	681b      	ldr	r3, [r3, #0]
 8019918:	60fb      	str	r3, [r7, #12]

    LcpSendEchoRequest (f);
 801991a:	687b      	ldr	r3, [r7, #4]
 801991c:	0018      	movs	r0, r3
 801991e:	f000 f8ad 	bl	8019a7c <LcpSendEchoRequest>
    if (f->state != PPP_FSM_OPENED)
 8019922:	687b      	ldr	r3, [r7, #4]
 8019924:	7c1b      	ldrb	r3, [r3, #16]
 8019926:	2b09      	cmp	r3, #9
 8019928:	d127      	bne.n	801997a <LcpEchoCheck+0x6e>
	return;

    /*
     * Start the timer for the next interval.
     */
    if (pcb->lcp_echo_timer_running)
 801992a:	68fb      	ldr	r3, [r7, #12]
 801992c:	2226      	movs	r2, #38	; 0x26
 801992e:	5c9b      	ldrb	r3, [r3, r2]
 8019930:	2210      	movs	r2, #16
 8019932:	4013      	ands	r3, r2
 8019934:	b2db      	uxtb	r3, r3
 8019936:	2b00      	cmp	r3, #0
 8019938:	d003      	beq.n	8019942 <LcpEchoCheck+0x36>
	ppp_warn("assertion lcp_echo_timer_running==0 failed");
 801993a:	4b12      	ldr	r3, [pc, #72]	; (8019984 <LcpEchoCheck+0x78>)
 801993c:	0018      	movs	r0, r3
 801993e:	f001 ff7a 	bl	801b836 <ppp_warn>
    TIMEOUT (LcpEchoTimeout, f, pcb->settings.lcp_echo_interval);
 8019942:	687a      	ldr	r2, [r7, #4]
 8019944:	4b10      	ldr	r3, [pc, #64]	; (8019988 <LcpEchoCheck+0x7c>)
 8019946:	0011      	movs	r1, r2
 8019948:	0018      	movs	r0, r3
 801994a:	f7f8 fd53 	bl	80123f4 <sys_untimeout>
 801994e:	68fb      	ldr	r3, [r7, #12]
 8019950:	7a5b      	ldrb	r3, [r3, #9]
 8019952:	001a      	movs	r2, r3
 8019954:	0013      	movs	r3, r2
 8019956:	015b      	lsls	r3, r3, #5
 8019958:	1a9b      	subs	r3, r3, r2
 801995a:	009b      	lsls	r3, r3, #2
 801995c:	189b      	adds	r3, r3, r2
 801995e:	00db      	lsls	r3, r3, #3
 8019960:	0018      	movs	r0, r3
 8019962:	687a      	ldr	r2, [r7, #4]
 8019964:	4b08      	ldr	r3, [pc, #32]	; (8019988 <LcpEchoCheck+0x7c>)
 8019966:	0019      	movs	r1, r3
 8019968:	f7f8 fd1c 	bl	80123a4 <sys_timeout>
    pcb->lcp_echo_timer_running = 1;
 801996c:	68fb      	ldr	r3, [r7, #12]
 801996e:	2226      	movs	r2, #38	; 0x26
 8019970:	5c99      	ldrb	r1, [r3, r2]
 8019972:	2010      	movs	r0, #16
 8019974:	4301      	orrs	r1, r0
 8019976:	5499      	strb	r1, [r3, r2]
 8019978:	e000      	b.n	801997c <LcpEchoCheck+0x70>
	return;
 801997a:	46c0      	nop			; (mov r8, r8)
}
 801997c:	46bd      	mov	sp, r7
 801997e:	b004      	add	sp, #16
 8019980:	bd80      	pop	{r7, pc}
 8019982:	46c0      	nop			; (mov r8, r8)
 8019984:	08021e28 	.word	0x08021e28
 8019988:	0801998d 	.word	0x0801998d

0801998c <LcpEchoTimeout>:

/*
 * LcpEchoTimeout - Timer expired on the LCP echo
 */

static void LcpEchoTimeout(void *arg) {
 801998c:	b580      	push	{r7, lr}
 801998e:	b084      	sub	sp, #16
 8019990:	af00      	add	r7, sp, #0
 8019992:	6078      	str	r0, [r7, #4]
    fsm *f = (fsm*)arg;
 8019994:	687b      	ldr	r3, [r7, #4]
 8019996:	60fb      	str	r3, [r7, #12]
    ppp_pcb *pcb = f->pcb;
 8019998:	68fb      	ldr	r3, [r7, #12]
 801999a:	681b      	ldr	r3, [r3, #0]
 801999c:	60bb      	str	r3, [r7, #8]
    if (pcb->lcp_echo_timer_running != 0) {
 801999e:	68bb      	ldr	r3, [r7, #8]
 80199a0:	2226      	movs	r2, #38	; 0x26
 80199a2:	5c9b      	ldrb	r3, [r3, r2]
 80199a4:	2210      	movs	r2, #16
 80199a6:	4013      	ands	r3, r2
 80199a8:	b2db      	uxtb	r3, r3
 80199aa:	2b00      	cmp	r3, #0
 80199ac:	d009      	beq.n	80199c2 <LcpEchoTimeout+0x36>
        pcb->lcp_echo_timer_running = 0;
 80199ae:	68bb      	ldr	r3, [r7, #8]
 80199b0:	2226      	movs	r2, #38	; 0x26
 80199b2:	5c99      	ldrb	r1, [r3, r2]
 80199b4:	2010      	movs	r0, #16
 80199b6:	4381      	bics	r1, r0
 80199b8:	5499      	strb	r1, [r3, r2]
        LcpEchoCheck ((fsm *) arg);
 80199ba:	687b      	ldr	r3, [r7, #4]
 80199bc:	0018      	movs	r0, r3
 80199be:	f7ff ffa5 	bl	801990c <LcpEchoCheck>
    }
}
 80199c2:	46c0      	nop			; (mov r8, r8)
 80199c4:	46bd      	mov	sp, r7
 80199c6:	b004      	add	sp, #16
 80199c8:	bd80      	pop	{r7, pc}
	...

080199cc <lcp_received_echo_reply>:

/*
 * LcpEchoReply - LCP has received a reply to the echo
 */

static void lcp_received_echo_reply(fsm *f, int id, u_char *inp, int len) {
 80199cc:	b580      	push	{r7, lr}
 80199ce:	b088      	sub	sp, #32
 80199d0:	af00      	add	r7, sp, #0
 80199d2:	60f8      	str	r0, [r7, #12]
 80199d4:	60b9      	str	r1, [r7, #8]
 80199d6:	607a      	str	r2, [r7, #4]
 80199d8:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 80199da:	68fb      	ldr	r3, [r7, #12]
 80199dc:	681b      	ldr	r3, [r3, #0]
 80199de:	61fb      	str	r3, [r7, #28]
    lcp_options *go = &pcb->lcp_gotoptions;
 80199e0:	69fb      	ldr	r3, [r7, #28]
 80199e2:	3368      	adds	r3, #104	; 0x68
 80199e4:	61bb      	str	r3, [r7, #24]
    u32_t magic_val;
    LWIP_UNUSED_ARG(id);

    /* Check the magic number - don't count replies from ourselves. */
    if (len < 4) {
 80199e6:	683b      	ldr	r3, [r7, #0]
 80199e8:	2b03      	cmp	r3, #3
 80199ea:	dc06      	bgt.n	80199fa <lcp_received_echo_reply+0x2e>
	ppp_dbglog("lcp: received short Echo-Reply, length %d", len);
 80199ec:	683a      	ldr	r2, [r7, #0]
 80199ee:	4b21      	ldr	r3, [pc, #132]	; (8019a74 <lcp_received_echo_reply+0xa8>)
 80199f0:	0011      	movs	r1, r2
 80199f2:	0018      	movs	r0, r3
 80199f4:	f001 ff5b 	bl	801b8ae <ppp_dbglog>
	return;
 80199f8:	e038      	b.n	8019a6c <lcp_received_echo_reply+0xa0>
    }
    GETLONG(magic_val, inp);
 80199fa:	687b      	ldr	r3, [r7, #4]
 80199fc:	1c5a      	adds	r2, r3, #1
 80199fe:	607a      	str	r2, [r7, #4]
 8019a00:	781b      	ldrb	r3, [r3, #0]
 8019a02:	021b      	lsls	r3, r3, #8
 8019a04:	617b      	str	r3, [r7, #20]
 8019a06:	687b      	ldr	r3, [r7, #4]
 8019a08:	1c5a      	adds	r2, r3, #1
 8019a0a:	607a      	str	r2, [r7, #4]
 8019a0c:	781b      	ldrb	r3, [r3, #0]
 8019a0e:	001a      	movs	r2, r3
 8019a10:	697b      	ldr	r3, [r7, #20]
 8019a12:	4313      	orrs	r3, r2
 8019a14:	617b      	str	r3, [r7, #20]
 8019a16:	697b      	ldr	r3, [r7, #20]
 8019a18:	021b      	lsls	r3, r3, #8
 8019a1a:	617b      	str	r3, [r7, #20]
 8019a1c:	687b      	ldr	r3, [r7, #4]
 8019a1e:	1c5a      	adds	r2, r3, #1
 8019a20:	607a      	str	r2, [r7, #4]
 8019a22:	781b      	ldrb	r3, [r3, #0]
 8019a24:	001a      	movs	r2, r3
 8019a26:	697b      	ldr	r3, [r7, #20]
 8019a28:	4313      	orrs	r3, r2
 8019a2a:	617b      	str	r3, [r7, #20]
 8019a2c:	697b      	ldr	r3, [r7, #20]
 8019a2e:	021b      	lsls	r3, r3, #8
 8019a30:	617b      	str	r3, [r7, #20]
 8019a32:	687b      	ldr	r3, [r7, #4]
 8019a34:	1c5a      	adds	r2, r3, #1
 8019a36:	607a      	str	r2, [r7, #4]
 8019a38:	781b      	ldrb	r3, [r3, #0]
 8019a3a:	001a      	movs	r2, r3
 8019a3c:	697b      	ldr	r3, [r7, #20]
 8019a3e:	4313      	orrs	r3, r2
 8019a40:	617b      	str	r3, [r7, #20]
    if (go->neg_magicnumber
 8019a42:	69bb      	ldr	r3, [r7, #24]
 8019a44:	781b      	ldrb	r3, [r3, #0]
 8019a46:	2210      	movs	r2, #16
 8019a48:	4013      	ands	r3, r2
 8019a4a:	b2db      	uxtb	r3, r3
 8019a4c:	2b00      	cmp	r3, #0
 8019a4e:	d009      	beq.n	8019a64 <lcp_received_echo_reply+0x98>
	&& magic_val == go->magicnumber) {
 8019a50:	69bb      	ldr	r3, [r7, #24]
 8019a52:	689b      	ldr	r3, [r3, #8]
 8019a54:	697a      	ldr	r2, [r7, #20]
 8019a56:	429a      	cmp	r2, r3
 8019a58:	d104      	bne.n	8019a64 <lcp_received_echo_reply+0x98>
	ppp_warn("appear to have received our own echo-reply!");
 8019a5a:	4b07      	ldr	r3, [pc, #28]	; (8019a78 <lcp_received_echo_reply+0xac>)
 8019a5c:	0018      	movs	r0, r3
 8019a5e:	f001 feea 	bl	801b836 <ppp_warn>
	return;
 8019a62:	e003      	b.n	8019a6c <lcp_received_echo_reply+0xa0>
    }

    /* Reset the number of outstanding echo frames */
    pcb->lcp_echos_pending = 0;
 8019a64:	69fb      	ldr	r3, [r7, #28]
 8019a66:	22d6      	movs	r2, #214	; 0xd6
 8019a68:	2100      	movs	r1, #0
 8019a6a:	5499      	strb	r1, [r3, r2]
}
 8019a6c:	46bd      	mov	sp, r7
 8019a6e:	b008      	add	sp, #32
 8019a70:	bd80      	pop	{r7, pc}
 8019a72:	46c0      	nop			; (mov r8, r8)
 8019a74:	08021e54 	.word	0x08021e54
 8019a78:	08021e80 	.word	0x08021e80

08019a7c <LcpSendEchoRequest>:

/*
 * LcpSendEchoRequest - Send an echo request frame to the peer
 */

static void LcpSendEchoRequest(fsm *f) {
 8019a7c:	b590      	push	{r4, r7, lr}
 8019a7e:	b08b      	sub	sp, #44	; 0x2c
 8019a80:	af02      	add	r7, sp, #8
 8019a82:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8019a84:	687b      	ldr	r3, [r7, #4]
 8019a86:	681b      	ldr	r3, [r3, #0]
 8019a88:	61fb      	str	r3, [r7, #28]
    lcp_options *go = &pcb->lcp_gotoptions;
 8019a8a:	69fb      	ldr	r3, [r7, #28]
 8019a8c:	3368      	adds	r3, #104	; 0x68
 8019a8e:	61bb      	str	r3, [r7, #24]
    u_char pkt[4], *pktp;

    /*
     * Detect the failure of the peer at this point.
     */
    if (pcb->settings.lcp_echo_fails != 0) {
 8019a90:	69fb      	ldr	r3, [r7, #28]
 8019a92:	7a9b      	ldrb	r3, [r3, #10]
 8019a94:	2b00      	cmp	r3, #0
 8019a96:	d00e      	beq.n	8019ab6 <LcpSendEchoRequest+0x3a>
        if (pcb->lcp_echos_pending >= pcb->settings.lcp_echo_fails) {
 8019a98:	69fb      	ldr	r3, [r7, #28]
 8019a9a:	22d6      	movs	r2, #214	; 0xd6
 8019a9c:	5c9a      	ldrb	r2, [r3, r2]
 8019a9e:	69fb      	ldr	r3, [r7, #28]
 8019aa0:	7a9b      	ldrb	r3, [r3, #10]
 8019aa2:	429a      	cmp	r2, r3
 8019aa4:	d307      	bcc.n	8019ab6 <LcpSendEchoRequest+0x3a>
            LcpLinkFailure(f);
 8019aa6:	687b      	ldr	r3, [r7, #4]
 8019aa8:	0018      	movs	r0, r3
 8019aaa:	f7ff ff03 	bl	80198b4 <LcpLinkFailure>
            pcb->lcp_echos_pending = 0;
 8019aae:	69fb      	ldr	r3, [r7, #28]
 8019ab0:	22d6      	movs	r2, #214	; 0xd6
 8019ab2:	2100      	movs	r1, #0
 8019ab4:	5499      	strb	r1, [r3, r2]
#endif

    /*
     * Make and send the echo request frame.
     */
    if (f->state == PPP_FSM_OPENED) {
 8019ab6:	687b      	ldr	r3, [r7, #4]
 8019ab8:	7c1b      	ldrb	r3, [r3, #16]
 8019aba:	2b09      	cmp	r3, #9
 8019abc:	d13a      	bne.n	8019b34 <LcpSendEchoRequest+0xb8>
        lcp_magic = go->magicnumber;
 8019abe:	69bb      	ldr	r3, [r7, #24]
 8019ac0:	689b      	ldr	r3, [r3, #8]
 8019ac2:	617b      	str	r3, [r7, #20]
	pktp = pkt;
 8019ac4:	240c      	movs	r4, #12
 8019ac6:	193b      	adds	r3, r7, r4
 8019ac8:	613b      	str	r3, [r7, #16]
	PUTLONG(lcp_magic, pktp);
 8019aca:	697b      	ldr	r3, [r7, #20]
 8019acc:	0e19      	lsrs	r1, r3, #24
 8019ace:	693b      	ldr	r3, [r7, #16]
 8019ad0:	1c5a      	adds	r2, r3, #1
 8019ad2:	613a      	str	r2, [r7, #16]
 8019ad4:	b2ca      	uxtb	r2, r1
 8019ad6:	701a      	strb	r2, [r3, #0]
 8019ad8:	697b      	ldr	r3, [r7, #20]
 8019ada:	0c19      	lsrs	r1, r3, #16
 8019adc:	693b      	ldr	r3, [r7, #16]
 8019ade:	1c5a      	adds	r2, r3, #1
 8019ae0:	613a      	str	r2, [r7, #16]
 8019ae2:	b2ca      	uxtb	r2, r1
 8019ae4:	701a      	strb	r2, [r3, #0]
 8019ae6:	697b      	ldr	r3, [r7, #20]
 8019ae8:	0a19      	lsrs	r1, r3, #8
 8019aea:	693b      	ldr	r3, [r7, #16]
 8019aec:	1c5a      	adds	r2, r3, #1
 8019aee:	613a      	str	r2, [r7, #16]
 8019af0:	b2ca      	uxtb	r2, r1
 8019af2:	701a      	strb	r2, [r3, #0]
 8019af4:	693b      	ldr	r3, [r7, #16]
 8019af6:	1c5a      	adds	r2, r3, #1
 8019af8:	613a      	str	r2, [r7, #16]
 8019afa:	697a      	ldr	r2, [r7, #20]
 8019afc:	b2d2      	uxtb	r2, r2
 8019afe:	701a      	strb	r2, [r3, #0]
        fsm_sdata(f, ECHOREQ, pcb->lcp_echo_number++, pkt, pktp - pkt);
 8019b00:	69fb      	ldr	r3, [r7, #28]
 8019b02:	22d7      	movs	r2, #215	; 0xd7
 8019b04:	5c9a      	ldrb	r2, [r3, r2]
 8019b06:	1c53      	adds	r3, r2, #1
 8019b08:	b2d8      	uxtb	r0, r3
 8019b0a:	69fb      	ldr	r3, [r7, #28]
 8019b0c:	21d7      	movs	r1, #215	; 0xd7
 8019b0e:	5458      	strb	r0, [r3, r1]
 8019b10:	193b      	adds	r3, r7, r4
 8019b12:	6939      	ldr	r1, [r7, #16]
 8019b14:	1acb      	subs	r3, r1, r3
 8019b16:	1939      	adds	r1, r7, r4
 8019b18:	6878      	ldr	r0, [r7, #4]
 8019b1a:	9300      	str	r3, [sp, #0]
 8019b1c:	000b      	movs	r3, r1
 8019b1e:	2109      	movs	r1, #9
 8019b20:	f7fb fc1e 	bl	8015360 <fsm_sdata>
	++pcb->lcp_echos_pending;
 8019b24:	69fb      	ldr	r3, [r7, #28]
 8019b26:	22d6      	movs	r2, #214	; 0xd6
 8019b28:	5c9b      	ldrb	r3, [r3, r2]
 8019b2a:	3301      	adds	r3, #1
 8019b2c:	b2d9      	uxtb	r1, r3
 8019b2e:	69fb      	ldr	r3, [r7, #28]
 8019b30:	22d6      	movs	r2, #214	; 0xd6
 8019b32:	5499      	strb	r1, [r3, r2]
    }
}
 8019b34:	46c0      	nop			; (mov r8, r8)
 8019b36:	46bd      	mov	sp, r7
 8019b38:	b009      	add	sp, #36	; 0x24
 8019b3a:	bd90      	pop	{r4, r7, pc}

08019b3c <lcp_echo_lowerup>:

/*
 * lcp_echo_lowerup - Start the timer for the LCP frame
 */

static void lcp_echo_lowerup(ppp_pcb *pcb) {
 8019b3c:	b580      	push	{r7, lr}
 8019b3e:	b084      	sub	sp, #16
 8019b40:	af00      	add	r7, sp, #0
 8019b42:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->lcp_fsm;
 8019b44:	687b      	ldr	r3, [r7, #4]
 8019b46:	3328      	adds	r3, #40	; 0x28
 8019b48:	60fb      	str	r3, [r7, #12]

    /* Clear the parameters for generating echo frames */
    pcb->lcp_echos_pending      = 0;
 8019b4a:	687b      	ldr	r3, [r7, #4]
 8019b4c:	22d6      	movs	r2, #214	; 0xd6
 8019b4e:	2100      	movs	r1, #0
 8019b50:	5499      	strb	r1, [r3, r2]
    pcb->lcp_echo_number        = 0;
 8019b52:	687b      	ldr	r3, [r7, #4]
 8019b54:	22d7      	movs	r2, #215	; 0xd7
 8019b56:	2100      	movs	r1, #0
 8019b58:	5499      	strb	r1, [r3, r2]
    pcb->lcp_echo_timer_running = 0;
 8019b5a:	687b      	ldr	r3, [r7, #4]
 8019b5c:	2226      	movs	r2, #38	; 0x26
 8019b5e:	5c99      	ldrb	r1, [r3, r2]
 8019b60:	2010      	movs	r0, #16
 8019b62:	4381      	bics	r1, r0
 8019b64:	5499      	strb	r1, [r3, r2]
  
    /* If a timeout interval is specified then start the timer */
    if (pcb->settings.lcp_echo_interval != 0)
 8019b66:	687b      	ldr	r3, [r7, #4]
 8019b68:	7a5b      	ldrb	r3, [r3, #9]
 8019b6a:	2b00      	cmp	r3, #0
 8019b6c:	d003      	beq.n	8019b76 <lcp_echo_lowerup+0x3a>
        LcpEchoCheck (f);
 8019b6e:	68fb      	ldr	r3, [r7, #12]
 8019b70:	0018      	movs	r0, r3
 8019b72:	f7ff fecb 	bl	801990c <LcpEchoCheck>
}
 8019b76:	46c0      	nop			; (mov r8, r8)
 8019b78:	46bd      	mov	sp, r7
 8019b7a:	b004      	add	sp, #16
 8019b7c:	bd80      	pop	{r7, pc}
	...

08019b80 <lcp_echo_lowerdown>:

/*
 * lcp_echo_lowerdown - Stop the timer for the LCP frame
 */

static void lcp_echo_lowerdown(ppp_pcb *pcb) {
 8019b80:	b580      	push	{r7, lr}
 8019b82:	b084      	sub	sp, #16
 8019b84:	af00      	add	r7, sp, #0
 8019b86:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->lcp_fsm;
 8019b88:	687b      	ldr	r3, [r7, #4]
 8019b8a:	3328      	adds	r3, #40	; 0x28
 8019b8c:	60fb      	str	r3, [r7, #12]

    if (pcb->lcp_echo_timer_running != 0) {
 8019b8e:	687b      	ldr	r3, [r7, #4]
 8019b90:	2226      	movs	r2, #38	; 0x26
 8019b92:	5c9b      	ldrb	r3, [r3, r2]
 8019b94:	2210      	movs	r2, #16
 8019b96:	4013      	ands	r3, r2
 8019b98:	b2db      	uxtb	r3, r3
 8019b9a:	2b00      	cmp	r3, #0
 8019b9c:	d00b      	beq.n	8019bb6 <lcp_echo_lowerdown+0x36>
        UNTIMEOUT (LcpEchoTimeout, f);
 8019b9e:	68fa      	ldr	r2, [r7, #12]
 8019ba0:	4b07      	ldr	r3, [pc, #28]	; (8019bc0 <lcp_echo_lowerdown+0x40>)
 8019ba2:	0011      	movs	r1, r2
 8019ba4:	0018      	movs	r0, r3
 8019ba6:	f7f8 fc25 	bl	80123f4 <sys_untimeout>
        pcb->lcp_echo_timer_running = 0;
 8019baa:	687b      	ldr	r3, [r7, #4]
 8019bac:	2226      	movs	r2, #38	; 0x26
 8019bae:	5c99      	ldrb	r1, [r3, r2]
 8019bb0:	2010      	movs	r0, #16
 8019bb2:	4381      	bics	r1, r0
 8019bb4:	5499      	strb	r1, [r3, r2]
    }
}
 8019bb6:	46c0      	nop			; (mov r8, r8)
 8019bb8:	46bd      	mov	sp, r7
 8019bba:	b004      	add	sp, #16
 8019bbc:	bd80      	pop	{r7, pc}
 8019bbe:	46c0      	nop			; (mov r8, r8)
 8019bc0:	0801998d 	.word	0x0801998d

08019bc4 <magic_randomize>:
 * this function is called at *truely random* times by the polling
 * and network functions.  Here we only get 16 bits of new random
 * value but we use the previous value to randomize the other 16
 * bits.
 */
void magic_randomize(void) {
 8019bc4:	b580      	push	{r7, lr}
 8019bc6:	af00      	add	r7, sp, #0
    magic_randomized = !0;
    magic_init();
    /* The initialization function also updates the seed. */
  } else {
#endif /* LWIP_RAND */
    magic_randomseed += sys_jiffies();
 8019bc8:	f003 f936 	bl	801ce38 <sys_jiffies>
 8019bcc:	0002      	movs	r2, r0
 8019bce:	4b04      	ldr	r3, [pc, #16]	; (8019be0 <magic_randomize+0x1c>)
 8019bd0:	681b      	ldr	r3, [r3, #0]
 8019bd2:	18d2      	adds	r2, r2, r3
 8019bd4:	4b02      	ldr	r3, [pc, #8]	; (8019be0 <magic_randomize+0x1c>)
 8019bd6:	601a      	str	r2, [r3, #0]
#ifndef LWIP_RAND
  }
#endif /* LWIP_RAND */
}
 8019bd8:	46c0      	nop			; (mov r8, r8)
 8019bda:	46bd      	mov	sp, r7
 8019bdc:	bd80      	pop	{r7, pc}
 8019bde:	46c0      	nop			; (mov r8, r8)
 8019be0:	200017ec 	.word	0x200017ec

08019be4 <magic>:
 * seed which is randomized by truely random events.
 * Thus the numbers will be truely random unless there have been no
 * operator or network events in which case it will be pseudo random
 * seeded by the real time clock.
 */
u32_t magic(void) {
 8019be4:	b580      	push	{r7, lr}
 8019be6:	af00      	add	r7, sp, #0
#ifdef LWIP_RAND
  return LWIP_RAND() + magic_randomseed;
 8019be8:	f003 f90c 	bl	801ce04 <sys_rand>
 8019bec:	0002      	movs	r2, r0
 8019bee:	4b03      	ldr	r3, [pc, #12]	; (8019bfc <magic+0x18>)
 8019bf0:	681b      	ldr	r3, [r3, #0]
 8019bf2:	18d3      	adds	r3, r2, r3
#else /* LWIP_RAND */
  return ((u32_t)rand() << 16) + (u32_t)rand() + magic_randomseed;
#endif /* LWIP_RAND */
}
 8019bf4:	0018      	movs	r0, r3
 8019bf6:	46bd      	mov	sp, r7
 8019bf8:	bd80      	pop	{r7, pc}
 8019bfa:	46c0      	nop			; (mov r8, r8)
 8019bfc:	200017ec 	.word	0x200017ec

08019c00 <ppp_set_notify_phase_callback>:
  pcb->settings.refuse_mppe_128 = !!(flags & PPP_MPPE_REFUSE_128);
}
#endif /* MPPE_SUPPORT */

#if PPP_NOTIFY_PHASE
void ppp_set_notify_phase_callback(ppp_pcb *pcb, ppp_notify_phase_cb_fn notify_phase_cb) {
 8019c00:	b580      	push	{r7, lr}
 8019c02:	b082      	sub	sp, #8
 8019c04:	af00      	add	r7, sp, #0
 8019c06:	6078      	str	r0, [r7, #4]
 8019c08:	6039      	str	r1, [r7, #0]
  pcb->notify_phase_cb = notify_phase_cb;
 8019c0a:	687b      	ldr	r3, [r7, #4]
 8019c0c:	683a      	ldr	r2, [r7, #0]
 8019c0e:	619a      	str	r2, [r3, #24]
  notify_phase_cb(pcb, pcb->phase, pcb->ctx_cb);
 8019c10:	687b      	ldr	r3, [r7, #4]
 8019c12:	2224      	movs	r2, #36	; 0x24
 8019c14:	5c99      	ldrb	r1, [r3, r2]
 8019c16:	687b      	ldr	r3, [r7, #4]
 8019c18:	69da      	ldr	r2, [r3, #28]
 8019c1a:	6878      	ldr	r0, [r7, #4]
 8019c1c:	683b      	ldr	r3, [r7, #0]
 8019c1e:	4798      	blx	r3
}
 8019c20:	46c0      	nop			; (mov r8, r8)
 8019c22:	46bd      	mov	sp, r7
 8019c24:	b002      	add	sp, #8
 8019c26:	bd80      	pop	{r7, pc}

08019c28 <ppp_connect>:
 * the connection.
 *
 * If this port connects to a modem, the modem connection must be
 * established before calling this.
 */
err_t ppp_connect(ppp_pcb *pcb, u16_t holdoff) {
 8019c28:	b580      	push	{r7, lr}
 8019c2a:	b082      	sub	sp, #8
 8019c2c:	af00      	add	r7, sp, #0
 8019c2e:	6078      	str	r0, [r7, #4]
 8019c30:	000a      	movs	r2, r1
 8019c32:	1cbb      	adds	r3, r7, #2
 8019c34:	801a      	strh	r2, [r3, #0]
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb->phase != PPP_PHASE_DEAD) {
 8019c36:	687b      	ldr	r3, [r7, #4]
 8019c38:	2224      	movs	r2, #36	; 0x24
 8019c3a:	5c9b      	ldrb	r3, [r3, r2]
 8019c3c:	2b00      	cmp	r3, #0
 8019c3e:	d002      	beq.n	8019c46 <ppp_connect+0x1e>
    return ERR_ALREADY;
 8019c40:	2309      	movs	r3, #9
 8019c42:	425b      	negs	r3, r3
 8019c44:	e01f      	b.n	8019c86 <ppp_connect+0x5e>
  }

  PPPDEBUG(LOG_DEBUG, ("ppp_connect[%d]: holdoff=%d\n", pcb->netif->num, holdoff));

  magic_randomize();
 8019c46:	f7ff ffbd 	bl	8019bc4 <magic_randomize>

  if (holdoff == 0) {
 8019c4a:	1cbb      	adds	r3, r7, #2
 8019c4c:	881b      	ldrh	r3, [r3, #0]
 8019c4e:	2b00      	cmp	r3, #0
 8019c50:	d105      	bne.n	8019c5e <ppp_connect+0x36>
    ppp_do_connect(pcb);
 8019c52:	687b      	ldr	r3, [r7, #4]
 8019c54:	0018      	movs	r0, r3
 8019c56:	f000 f8b1 	bl	8019dbc <ppp_do_connect>
    return ERR_OK;
 8019c5a:	2300      	movs	r3, #0
 8019c5c:	e013      	b.n	8019c86 <ppp_connect+0x5e>
  }

  new_phase(pcb, PPP_PHASE_HOLDOFF);
 8019c5e:	687b      	ldr	r3, [r7, #4]
 8019c60:	2102      	movs	r1, #2
 8019c62:	0018      	movs	r0, r3
 8019c64:	f000 fb29 	bl	801a2ba <new_phase>
  sys_timeout((u32_t)(holdoff*1000), ppp_do_connect, pcb);
 8019c68:	1cbb      	adds	r3, r7, #2
 8019c6a:	881a      	ldrh	r2, [r3, #0]
 8019c6c:	0013      	movs	r3, r2
 8019c6e:	015b      	lsls	r3, r3, #5
 8019c70:	1a9b      	subs	r3, r3, r2
 8019c72:	009b      	lsls	r3, r3, #2
 8019c74:	189b      	adds	r3, r3, r2
 8019c76:	00db      	lsls	r3, r3, #3
 8019c78:	0018      	movs	r0, r3
 8019c7a:	687a      	ldr	r2, [r7, #4]
 8019c7c:	4b04      	ldr	r3, [pc, #16]	; (8019c90 <ppp_connect+0x68>)
 8019c7e:	0019      	movs	r1, r3
 8019c80:	f7f8 fb90 	bl	80123a4 <sys_timeout>
  return ERR_OK;
 8019c84:	2300      	movs	r3, #0
}
 8019c86:	0018      	movs	r0, r3
 8019c88:	46bd      	mov	sp, r7
 8019c8a:	b002      	add	sp, #8
 8019c8c:	bd80      	pop	{r7, pc}
 8019c8e:	46c0      	nop			; (mov r8, r8)
 8019c90:	08019dbd 	.word	0x08019dbd

08019c94 <ppp_close>:
 *
 * Return 0 on success, an error code on failure.
 */
err_t
ppp_close(ppp_pcb *pcb, u8_t nocarrier)
{
 8019c94:	b590      	push	{r4, r7, lr}
 8019c96:	b083      	sub	sp, #12
 8019c98:	af00      	add	r7, sp, #0
 8019c9a:	6078      	str	r0, [r7, #4]
 8019c9c:	000a      	movs	r2, r1
 8019c9e:	1cfb      	adds	r3, r7, #3
 8019ca0:	701a      	strb	r2, [r3, #0]
  LWIP_ASSERT_CORE_LOCKED();

  pcb->err_code = PPPERR_USER;
 8019ca2:	687b      	ldr	r3, [r7, #4]
 8019ca4:	2225      	movs	r2, #37	; 0x25
 8019ca6:	2105      	movs	r1, #5
 8019ca8:	5499      	strb	r1, [r3, r2]

  /* holdoff phase, cancel the reconnection */
  if (pcb->phase == PPP_PHASE_HOLDOFF) {
 8019caa:	687b      	ldr	r3, [r7, #4]
 8019cac:	2224      	movs	r2, #36	; 0x24
 8019cae:	5c9b      	ldrb	r3, [r3, r2]
 8019cb0:	2b02      	cmp	r3, #2
 8019cb2:	d10a      	bne.n	8019cca <ppp_close+0x36>
    sys_untimeout(ppp_do_connect, pcb);
 8019cb4:	687a      	ldr	r2, [r7, #4]
 8019cb6:	4b29      	ldr	r3, [pc, #164]	; (8019d5c <ppp_close+0xc8>)
 8019cb8:	0011      	movs	r1, r2
 8019cba:	0018      	movs	r0, r3
 8019cbc:	f7f8 fb9a 	bl	80123f4 <sys_untimeout>
    new_phase(pcb, PPP_PHASE_DEAD);
 8019cc0:	687b      	ldr	r3, [r7, #4]
 8019cc2:	2100      	movs	r1, #0
 8019cc4:	0018      	movs	r0, r3
 8019cc6:	f000 faf8 	bl	801a2ba <new_phase>
  }

  /* dead phase, nothing to do, call the status callback to be consistent */
  if (pcb->phase == PPP_PHASE_DEAD) {
 8019cca:	687b      	ldr	r3, [r7, #4]
 8019ccc:	2224      	movs	r2, #36	; 0x24
 8019cce:	5c9b      	ldrb	r3, [r3, r2]
 8019cd0:	2b00      	cmp	r3, #0
 8019cd2:	d10c      	bne.n	8019cee <ppp_close+0x5a>
    pcb->link_status_cb(pcb, pcb->err_code, pcb->ctx_cb);
 8019cd4:	687b      	ldr	r3, [r7, #4]
 8019cd6:	695c      	ldr	r4, [r3, #20]
 8019cd8:	687b      	ldr	r3, [r7, #4]
 8019cda:	2225      	movs	r2, #37	; 0x25
 8019cdc:	5c9b      	ldrb	r3, [r3, r2]
 8019cde:	0019      	movs	r1, r3
 8019ce0:	687b      	ldr	r3, [r7, #4]
 8019ce2:	69da      	ldr	r2, [r3, #28]
 8019ce4:	687b      	ldr	r3, [r7, #4]
 8019ce6:	0018      	movs	r0, r3
 8019ce8:	47a0      	blx	r4
    return ERR_OK;
 8019cea:	2300      	movs	r3, #0
 8019cec:	e031      	b.n	8019d52 <ppp_close+0xbe>
  }

  /* Already terminating, nothing to do */
  if (pcb->phase >= PPP_PHASE_TERMINATE) {
 8019cee:	687b      	ldr	r3, [r7, #4]
 8019cf0:	2224      	movs	r2, #36	; 0x24
 8019cf2:	5c9b      	ldrb	r3, [r3, r2]
 8019cf4:	2b0a      	cmp	r3, #10
 8019cf6:	d902      	bls.n	8019cfe <ppp_close+0x6a>
    return ERR_INPROGRESS;
 8019cf8:	2305      	movs	r3, #5
 8019cfa:	425b      	negs	r3, r3
 8019cfc:	e029      	b.n	8019d52 <ppp_close+0xbe>
  }

  /* LCP not open, close link protocol */
  if (pcb->phase < PPP_PHASE_ESTABLISH) {
 8019cfe:	687b      	ldr	r3, [r7, #4]
 8019d00:	2224      	movs	r2, #36	; 0x24
 8019d02:	5c9b      	ldrb	r3, [r3, r2]
 8019d04:	2b05      	cmp	r3, #5
 8019d06:	d80a      	bhi.n	8019d1e <ppp_close+0x8a>
    new_phase(pcb, PPP_PHASE_DISCONNECT);
 8019d08:	687b      	ldr	r3, [r7, #4]
 8019d0a:	210c      	movs	r1, #12
 8019d0c:	0018      	movs	r0, r3
 8019d0e:	f000 fad4 	bl	801a2ba <new_phase>
    ppp_link_terminated(pcb);
 8019d12:	687b      	ldr	r3, [r7, #4]
 8019d14:	0018      	movs	r0, r3
 8019d16:	f000 fac0 	bl	801a29a <ppp_link_terminated>
    return ERR_OK;
 8019d1a:	2300      	movs	r3, #0
 8019d1c:	e019      	b.n	8019d52 <ppp_close+0xbe>
   * to prevent changing the PPP phase FSM in transition phases.
   *
   * Always using nocarrier = 0 is still recommended, this is going to
   * take a little longer time, but is a safer choice from FSM point of view.
   */
  if (nocarrier && pcb->phase == PPP_PHASE_RUNNING) {
 8019d1e:	1cfb      	adds	r3, r7, #3
 8019d20:	781b      	ldrb	r3, [r3, #0]
 8019d22:	2b00      	cmp	r3, #0
 8019d24:	d00e      	beq.n	8019d44 <ppp_close+0xb0>
 8019d26:	687b      	ldr	r3, [r7, #4]
 8019d28:	2224      	movs	r2, #36	; 0x24
 8019d2a:	5c9b      	ldrb	r3, [r3, r2]
 8019d2c:	2b0a      	cmp	r3, #10
 8019d2e:	d109      	bne.n	8019d44 <ppp_close+0xb0>
    PPPDEBUG(LOG_DEBUG, ("ppp_close[%d]: carrier lost -> lcp_lowerdown\n", pcb->netif->num));
    lcp_lowerdown(pcb);
 8019d30:	687b      	ldr	r3, [r7, #4]
 8019d32:	0018      	movs	r0, r3
 8019d34:	f7fd ffb2 	bl	8017c9c <lcp_lowerdown>
    /* forced link termination, this will force link protocol to disconnect. */
    link_terminated(pcb);
 8019d38:	687b      	ldr	r3, [r7, #4]
 8019d3a:	0018      	movs	r0, r3
 8019d3c:	f7fa fa9c 	bl	8014278 <link_terminated>
    return ERR_OK;
 8019d40:	2300      	movs	r3, #0
 8019d42:	e006      	b.n	8019d52 <ppp_close+0xbe>
  }

  /* Disconnect */
  PPPDEBUG(LOG_DEBUG, ("ppp_close[%d]: kill_link -> lcp_close\n", pcb->netif->num));
  /* LCP soft close request. */
  lcp_close(pcb, "User request");
 8019d44:	4a06      	ldr	r2, [pc, #24]	; (8019d60 <ppp_close+0xcc>)
 8019d46:	687b      	ldr	r3, [r7, #4]
 8019d48:	0011      	movs	r1, r2
 8019d4a:	0018      	movs	r0, r3
 8019d4c:	f7fd ff02 	bl	8017b54 <lcp_close>
  return ERR_OK;
 8019d50:	2300      	movs	r3, #0
}
 8019d52:	0018      	movs	r0, r3
 8019d54:	46bd      	mov	sp, r7
 8019d56:	b003      	add	sp, #12
 8019d58:	bd90      	pop	{r4, r7, pc}
 8019d5a:	46c0      	nop			; (mov r8, r8)
 8019d5c:	08019dbd 	.word	0x08019dbd
 8019d60:	08021eb4 	.word	0x08021eb4

08019d64 <ppp_free>:
 * You must use ppp_close() before if you wish to terminate
 * an established PPP session.
 *
 * Return 0 on success, an error code on failure.
 */
err_t ppp_free(ppp_pcb *pcb) {
 8019d64:	b5b0      	push	{r4, r5, r7, lr}
 8019d66:	b084      	sub	sp, #16
 8019d68:	af00      	add	r7, sp, #0
 8019d6a:	6078      	str	r0, [r7, #4]
  err_t err;
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb->phase != PPP_PHASE_DEAD) {
 8019d6c:	687b      	ldr	r3, [r7, #4]
 8019d6e:	2224      	movs	r2, #36	; 0x24
 8019d70:	5c9b      	ldrb	r3, [r3, r2]
 8019d72:	2b00      	cmp	r3, #0
 8019d74:	d002      	beq.n	8019d7c <ppp_free+0x18>
    return ERR_CONN;
 8019d76:	230b      	movs	r3, #11
 8019d78:	425b      	negs	r3, r3
 8019d7a:	e019      	b.n	8019db0 <ppp_free+0x4c>
  }

  PPPDEBUG(LOG_DEBUG, ("ppp_free[%d]\n", pcb->netif->num));

  netif_remove(pcb->netif);
 8019d7c:	687b      	ldr	r3, [r7, #4]
 8019d7e:	6a1b      	ldr	r3, [r3, #32]
 8019d80:	0018      	movs	r0, r3
 8019d82:	f7ef fb8f 	bl	80094a4 <netif_remove>

  err = pcb->link_cb->free(pcb, pcb->link_ctx_cb);
 8019d86:	687b      	ldr	r3, [r7, #4]
 8019d88:	68db      	ldr	r3, [r3, #12]
 8019d8a:	689a      	ldr	r2, [r3, #8]
 8019d8c:	687b      	ldr	r3, [r7, #4]
 8019d8e:	6919      	ldr	r1, [r3, #16]
 8019d90:	250f      	movs	r5, #15
 8019d92:	197c      	adds	r4, r7, r5
 8019d94:	687b      	ldr	r3, [r7, #4]
 8019d96:	0018      	movs	r0, r3
 8019d98:	4790      	blx	r2
 8019d9a:	0003      	movs	r3, r0
 8019d9c:	7023      	strb	r3, [r4, #0]

  LWIP_MEMPOOL_FREE(PPP_PCB, pcb);
 8019d9e:	687a      	ldr	r2, [r7, #4]
 8019da0:	4b05      	ldr	r3, [pc, #20]	; (8019db8 <ppp_free+0x54>)
 8019da2:	0011      	movs	r1, r2
 8019da4:	0018      	movs	r0, r3
 8019da6:	f7ef f973 	bl	8009090 <memp_free_pool>
  return err;
 8019daa:	197b      	adds	r3, r7, r5
 8019dac:	781b      	ldrb	r3, [r3, #0]
 8019dae:	b25b      	sxtb	r3, r3
}
 8019db0:	0018      	movs	r0, r3
 8019db2:	46bd      	mov	sp, r7
 8019db4:	b004      	add	sp, #16
 8019db6:	bdb0      	pop	{r4, r5, r7, pc}
 8019db8:	08022ae4 	.word	0x08022ae4

08019dbc <ppp_do_connect>:

/**********************************/
/*** LOCAL FUNCTION DEFINITIONS ***/
/**********************************/

static void ppp_do_connect(void *arg) {
 8019dbc:	b580      	push	{r7, lr}
 8019dbe:	b084      	sub	sp, #16
 8019dc0:	af00      	add	r7, sp, #0
 8019dc2:	6078      	str	r0, [r7, #4]
  ppp_pcb *pcb = (ppp_pcb*)arg;
 8019dc4:	687b      	ldr	r3, [r7, #4]
 8019dc6:	60fb      	str	r3, [r7, #12]

  LWIP_ASSERT("pcb->phase == PPP_PHASE_DEAD || pcb->phase == PPP_PHASE_HOLDOFF", pcb->phase == PPP_PHASE_DEAD || pcb->phase == PPP_PHASE_HOLDOFF);
 8019dc8:	68fb      	ldr	r3, [r7, #12]
 8019dca:	2224      	movs	r2, #36	; 0x24
 8019dcc:	5c9b      	ldrb	r3, [r3, r2]
 8019dce:	2b00      	cmp	r3, #0
 8019dd0:	d00b      	beq.n	8019dea <ppp_do_connect+0x2e>
 8019dd2:	68fb      	ldr	r3, [r7, #12]
 8019dd4:	2224      	movs	r2, #36	; 0x24
 8019dd6:	5c9b      	ldrb	r3, [r3, r2]
 8019dd8:	2b02      	cmp	r3, #2
 8019dda:	d006      	beq.n	8019dea <ppp_do_connect+0x2e>
 8019ddc:	4b0b      	ldr	r3, [pc, #44]	; (8019e0c <ppp_do_connect+0x50>)
 8019dde:	22ce      	movs	r2, #206	; 0xce
 8019de0:	32ff      	adds	r2, #255	; 0xff
 8019de2:	490b      	ldr	r1, [pc, #44]	; (8019e10 <ppp_do_connect+0x54>)
 8019de4:	480b      	ldr	r0, [pc, #44]	; (8019e14 <ppp_do_connect+0x58>)
 8019de6:	f7e8 feef 	bl	8002bc8 <app_debug_rtt_raw>

  new_phase(pcb, PPP_PHASE_INITIALIZE);
 8019dea:	68fb      	ldr	r3, [r7, #12]
 8019dec:	2103      	movs	r1, #3
 8019dee:	0018      	movs	r0, r3
 8019df0:	f000 fa63 	bl	801a2ba <new_phase>
  pcb->link_cb->connect(pcb, pcb->link_ctx_cb);
 8019df4:	68fb      	ldr	r3, [r7, #12]
 8019df6:	68db      	ldr	r3, [r3, #12]
 8019df8:	681a      	ldr	r2, [r3, #0]
 8019dfa:	68fb      	ldr	r3, [r7, #12]
 8019dfc:	6919      	ldr	r1, [r3, #16]
 8019dfe:	68fb      	ldr	r3, [r7, #12]
 8019e00:	0018      	movs	r0, r3
 8019e02:	4790      	blx	r2
}
 8019e04:	46c0      	nop			; (mov r8, r8)
 8019e06:	46bd      	mov	sp, r7
 8019e08:	b004      	add	sp, #16
 8019e0a:	bd80      	pop	{r7, pc}
 8019e0c:	08021ec4 	.word	0x08021ec4
 8019e10:	08021ef0 	.word	0x08021ef0
 8019e14:	08021f30 	.word	0x08021f30

08019e18 <ppp_netif_init_cb>:

/*
 * ppp_netif_init_cb - netif init callback
 */
static err_t ppp_netif_init_cb(struct netif *netif) {
 8019e18:	b580      	push	{r7, lr}
 8019e1a:	b082      	sub	sp, #8
 8019e1c:	af00      	add	r7, sp, #0
 8019e1e:	6078      	str	r0, [r7, #4]
  netif->name[0] = 'p';
 8019e20:	687b      	ldr	r3, [r7, #4]
 8019e22:	2232      	movs	r2, #50	; 0x32
 8019e24:	2170      	movs	r1, #112	; 0x70
 8019e26:	5499      	strb	r1, [r3, r2]
  netif->name[1] = 'p';
 8019e28:	687b      	ldr	r3, [r7, #4]
 8019e2a:	2233      	movs	r2, #51	; 0x33
 8019e2c:	2170      	movs	r1, #112	; 0x70
 8019e2e:	5499      	strb	r1, [r3, r2]
#if PPP_IPV4_SUPPORT
  netif->output = ppp_netif_output_ip4;
 8019e30:	687b      	ldr	r3, [r7, #4]
 8019e32:	4a05      	ldr	r2, [pc, #20]	; (8019e48 <ppp_netif_init_cb+0x30>)
 8019e34:	615a      	str	r2, [r3, #20]
#endif /* PPP_IPV4_SUPPORT */
#if PPP_IPV6_SUPPORT
  netif->output_ip6 = ppp_netif_output_ip6;
#endif /* PPP_IPV6_SUPPORT */
  netif->flags = NETIF_FLAG_UP;
 8019e36:	687b      	ldr	r3, [r7, #4]
 8019e38:	2231      	movs	r2, #49	; 0x31
 8019e3a:	2101      	movs	r1, #1
 8019e3c:	5499      	strb	r1, [r3, r2]
#if LWIP_NETIF_HOSTNAME
  /* @todo: Initialize interface hostname */
  /* netif_set_hostname(netif, "lwip"); */
#endif /* LWIP_NETIF_HOSTNAME */
  return ERR_OK;
 8019e3e:	2300      	movs	r3, #0
}
 8019e40:	0018      	movs	r0, r3
 8019e42:	46bd      	mov	sp, r7
 8019e44:	b002      	add	sp, #8
 8019e46:	bd80      	pop	{r7, pc}
 8019e48:	08019e4d 	.word	0x08019e4d

08019e4c <ppp_netif_output_ip4>:

#if PPP_IPV4_SUPPORT
/*
 * Send an IPv4 packet on the given connection.
 */
static err_t ppp_netif_output_ip4(struct netif *netif, struct pbuf *pb, const ip4_addr_t *ipaddr) {
 8019e4c:	b580      	push	{r7, lr}
 8019e4e:	b084      	sub	sp, #16
 8019e50:	af00      	add	r7, sp, #0
 8019e52:	60f8      	str	r0, [r7, #12]
 8019e54:	60b9      	str	r1, [r7, #8]
 8019e56:	607a      	str	r2, [r7, #4]
  LWIP_UNUSED_ARG(ipaddr);
  return ppp_netif_output(netif, pb, PPP_IP);
 8019e58:	68b9      	ldr	r1, [r7, #8]
 8019e5a:	68fb      	ldr	r3, [r7, #12]
 8019e5c:	2221      	movs	r2, #33	; 0x21
 8019e5e:	0018      	movs	r0, r3
 8019e60:	f000 f805 	bl	8019e6e <ppp_netif_output>
 8019e64:	0003      	movs	r3, r0
}
 8019e66:	0018      	movs	r0, r3
 8019e68:	46bd      	mov	sp, r7
 8019e6a:	b004      	add	sp, #16
 8019e6c:	bd80      	pop	{r7, pc}

08019e6e <ppp_netif_output>:
  LWIP_UNUSED_ARG(ipaddr);
  return ppp_netif_output(netif, pb, PPP_IPV6);
}
#endif /* PPP_IPV6_SUPPORT */

static err_t ppp_netif_output(struct netif *netif, struct pbuf *pb, u16_t protocol) {
 8019e6e:	b5b0      	push	{r4, r5, r7, lr}
 8019e70:	b088      	sub	sp, #32
 8019e72:	af00      	add	r7, sp, #0
 8019e74:	60f8      	str	r0, [r7, #12]
 8019e76:	60b9      	str	r1, [r7, #8]
 8019e78:	1dbb      	adds	r3, r7, #6
 8019e7a:	801a      	strh	r2, [r3, #0]
  ppp_pcb *pcb = (ppp_pcb*)netif->state;
 8019e7c:	68fb      	ldr	r3, [r7, #12]
 8019e7e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8019e80:	617b      	str	r3, [r7, #20]
  err_t err;
  struct pbuf *fpb = NULL;
 8019e82:	2300      	movs	r3, #0
 8019e84:	61bb      	str	r3, [r7, #24]

  /* Check that the link is up. */
  if (0
 8019e86:	1dbb      	adds	r3, r7, #6
 8019e88:	881b      	ldrh	r3, [r3, #0]
 8019e8a:	2b21      	cmp	r3, #33	; 0x21
 8019e8c:	d107      	bne.n	8019e9e <ppp_netif_output+0x30>
#if PPP_IPV4_SUPPORT
      || (protocol == PPP_IP && !pcb->if4_up)
 8019e8e:	697b      	ldr	r3, [r7, #20]
 8019e90:	2226      	movs	r2, #38	; 0x26
 8019e92:	5c9b      	ldrb	r3, [r3, r2]
 8019e94:	2208      	movs	r2, #8
 8019e96:	4013      	ands	r3, r2
 8019e98:	b2db      	uxtb	r3, r3
 8019e9a:	2b00      	cmp	r3, #0
 8019e9c:	d03d      	beq.n	8019f1a <ppp_netif_output+0xac>
#if VJ_SUPPORT
  /*
   * Attempt Van Jacobson header compression if VJ is configured and
   * this is an IP packet.
   */
  if (protocol == PPP_IP && pcb->vj_enabled) {
 8019e9e:	1dbb      	adds	r3, r7, #6
 8019ea0:	881b      	ldrh	r3, [r3, #0]
 8019ea2:	2b21      	cmp	r3, #33	; 0x21
 8019ea4:	d127      	bne.n	8019ef6 <ppp_netif_output+0x88>
 8019ea6:	697b      	ldr	r3, [r7, #20]
 8019ea8:	2226      	movs	r2, #38	; 0x26
 8019eaa:	5c9b      	ldrb	r3, [r3, r2]
 8019eac:	2220      	movs	r2, #32
 8019eae:	4013      	ands	r3, r2
 8019eb0:	b2db      	uxtb	r3, r3
 8019eb2:	2b00      	cmp	r3, #0
 8019eb4:	d01f      	beq.n	8019ef6 <ppp_netif_output+0x88>
    switch (vj_compress_tcp(&pcb->vj_comp, &pb)) {
 8019eb6:	697b      	ldr	r3, [r7, #20]
 8019eb8:	33dc      	adds	r3, #220	; 0xdc
 8019eba:	2208      	movs	r2, #8
 8019ebc:	18ba      	adds	r2, r7, r2
 8019ebe:	0011      	movs	r1, r2
 8019ec0:	0018      	movs	r0, r3
 8019ec2:	f001 fd5f 	bl	801b984 <vj_compress_tcp>
 8019ec6:	0003      	movs	r3, r0
 8019ec8:	2b80      	cmp	r3, #128	; 0x80
 8019eca:	d005      	beq.n	8019ed8 <ppp_netif_output+0x6a>
 8019ecc:	dc10      	bgt.n	8019ef0 <ppp_netif_output+0x82>
 8019ece:	2b40      	cmp	r3, #64	; 0x40
 8019ed0:	d013      	beq.n	8019efa <ppp_netif_output+0x8c>
 8019ed2:	2b70      	cmp	r3, #112	; 0x70
 8019ed4:	d006      	beq.n	8019ee4 <ppp_netif_output+0x76>
 8019ed6:	e00b      	b.n	8019ef0 <ppp_netif_output+0x82>
           protocol = PPP_IP; */
        break;
      case TYPE_COMPRESSED_TCP:
        /* vj_compress_tcp() returns a new allocated pbuf, indicate we should free
         * our duplicated pbuf later */
        fpb = pb;
 8019ed8:	68bb      	ldr	r3, [r7, #8]
 8019eda:	61bb      	str	r3, [r7, #24]
        protocol = PPP_VJC_COMP;
 8019edc:	1dbb      	adds	r3, r7, #6
 8019ede:	222d      	movs	r2, #45	; 0x2d
 8019ee0:	801a      	strh	r2, [r3, #0]
        break;
 8019ee2:	e00b      	b.n	8019efc <ppp_netif_output+0x8e>
      case TYPE_UNCOMPRESSED_TCP:
        /* vj_compress_tcp() returns a new allocated pbuf, indicate we should free
         * our duplicated pbuf later */
        fpb = pb;
 8019ee4:	68bb      	ldr	r3, [r7, #8]
 8019ee6:	61bb      	str	r3, [r7, #24]
        protocol = PPP_VJC_UNCOMP;
 8019ee8:	1dbb      	adds	r3, r7, #6
 8019eea:	222f      	movs	r2, #47	; 0x2f
 8019eec:	801a      	strh	r2, [r3, #0]
        break;
 8019eee:	e005      	b.n	8019efc <ppp_netif_output+0x8e>
      default:
        PPPDEBUG(LOG_WARNING, ("ppp_netif_output[%d]: bad IP packet\n", pcb->netif->num));
        LINK_STATS_INC(link.proterr);
        LINK_STATS_INC(link.drop);
        MIB2_STATS_NETIF_INC(pcb->netif, ifoutdiscards);
        return ERR_VAL;
 8019ef0:	2306      	movs	r3, #6
 8019ef2:	425b      	negs	r3, r3
 8019ef4:	e021      	b.n	8019f3a <ppp_netif_output+0xcc>
    }
  }
 8019ef6:	46c0      	nop			; (mov r8, r8)
 8019ef8:	e000      	b.n	8019efc <ppp_netif_output+0x8e>
        break;
 8019efa:	46c0      	nop			; (mov r8, r8)
    PPPDEBUG(LOG_ERR, ("ppp_netif_output[%d]: bad CCP transmit method\n", pcb->netif->num));
    goto err_rte_drop; /* Cannot really happen, we only negotiate what we are able to do */
  }
#endif /* CCP_SUPPORT */

  err = pcb->link_cb->netif_output(pcb, pcb->link_ctx_cb, pb, protocol);
 8019efc:	697b      	ldr	r3, [r7, #20]
 8019efe:	68db      	ldr	r3, [r3, #12]
 8019f00:	691d      	ldr	r5, [r3, #16]
 8019f02:	697b      	ldr	r3, [r7, #20]
 8019f04:	6919      	ldr	r1, [r3, #16]
 8019f06:	68ba      	ldr	r2, [r7, #8]
 8019f08:	231f      	movs	r3, #31
 8019f0a:	18fc      	adds	r4, r7, r3
 8019f0c:	1dbb      	adds	r3, r7, #6
 8019f0e:	881b      	ldrh	r3, [r3, #0]
 8019f10:	6978      	ldr	r0, [r7, #20]
 8019f12:	47a8      	blx	r5
 8019f14:	0003      	movs	r3, r0
 8019f16:	7023      	strb	r3, [r4, #0]
  goto err;
 8019f18:	e004      	b.n	8019f24 <ppp_netif_output+0xb6>
    goto err_rte_drop;
 8019f1a:	46c0      	nop			; (mov r8, r8)

err_rte_drop:
  err = ERR_RTE;
 8019f1c:	231f      	movs	r3, #31
 8019f1e:	18fb      	adds	r3, r7, r3
 8019f20:	22fc      	movs	r2, #252	; 0xfc
 8019f22:	701a      	strb	r2, [r3, #0]
  LINK_STATS_INC(link.rterr);
  LINK_STATS_INC(link.drop);
  MIB2_STATS_NETIF_INC(netif, ifoutdiscards);
err:
  if (fpb) {
 8019f24:	69bb      	ldr	r3, [r7, #24]
 8019f26:	2b00      	cmp	r3, #0
 8019f28:	d003      	beq.n	8019f32 <ppp_netif_output+0xc4>
    pbuf_free(fpb);
 8019f2a:	69bb      	ldr	r3, [r7, #24]
 8019f2c:	0018      	movs	r0, r3
 8019f2e:	f7ef ffc5 	bl	8009ebc <pbuf_free>
  }
  return err;
 8019f32:	231f      	movs	r3, #31
 8019f34:	18fb      	adds	r3, r7, r3
 8019f36:	781b      	ldrb	r3, [r3, #0]
 8019f38:	b25b      	sxtb	r3, r3
}
 8019f3a:	0018      	movs	r0, r3
 8019f3c:	46bd      	mov	sp, r7
 8019f3e:	b008      	add	sp, #32
 8019f40:	bdb0      	pop	{r4, r5, r7, pc}
	...

08019f44 <ppp_new>:
 * attempt to negotiate the LCP session.
 *
 * Return a new PPP connection control block pointer
 * on success or a null pointer on failure.
 */
ppp_pcb *ppp_new(struct netif *pppif, const struct link_callbacks *callbacks, void *link_ctx_cb, ppp_link_status_cb_fn link_status_cb, void *ctx_cb) {
 8019f44:	b590      	push	{r4, r7, lr}
 8019f46:	b08d      	sub	sp, #52	; 0x34
 8019f48:	af04      	add	r7, sp, #16
 8019f4a:	60f8      	str	r0, [r7, #12]
 8019f4c:	60b9      	str	r1, [r7, #8]
 8019f4e:	607a      	str	r2, [r7, #4]
 8019f50:	603b      	str	r3, [r7, #0]
  const struct protent *protp;
  int i;

  /* PPP is single-threaded: without a callback,
   * there is no way to know when the link is up. */
  if (link_status_cb == NULL) {
 8019f52:	683b      	ldr	r3, [r7, #0]
 8019f54:	2b00      	cmp	r3, #0
 8019f56:	d101      	bne.n	8019f5c <ppp_new+0x18>
    return NULL;
 8019f58:	2300      	movs	r3, #0
 8019f5a:	e065      	b.n	801a028 <ppp_new+0xe4>
  }

  pcb = (ppp_pcb*)LWIP_MEMPOOL_ALLOC(PPP_PCB);
 8019f5c:	4b34      	ldr	r3, [pc, #208]	; (801a030 <ppp_new+0xec>)
 8019f5e:	0018      	movs	r0, r3
 8019f60:	f7ef f82a 	bl	8008fb8 <memp_malloc_pool>
 8019f64:	0003      	movs	r3, r0
 8019f66:	61bb      	str	r3, [r7, #24]
  if (pcb == NULL) {
 8019f68:	69bb      	ldr	r3, [r7, #24]
 8019f6a:	2b00      	cmp	r3, #0
 8019f6c:	d101      	bne.n	8019f72 <ppp_new+0x2e>
    return NULL;
 8019f6e:	2300      	movs	r3, #0
 8019f70:	e05a      	b.n	801a028 <ppp_new+0xe4>
  }

  memset(pcb, 0, sizeof(ppp_pcb));
 8019f72:	4a30      	ldr	r2, [pc, #192]	; (801a034 <ppp_new+0xf0>)
 8019f74:	69bb      	ldr	r3, [r7, #24]
 8019f76:	2100      	movs	r1, #0
 8019f78:	0018      	movs	r0, r3
 8019f7a:	f002 ffc3 	bl	801cf04 <memset>
  pcb->settings.eap_timeout_time = EAP_DEFTIMEOUT;
  pcb->settings.eap_max_transmits = EAP_DEFTRANSMITS;
#endif /* PPP_SERVER */
#endif /* EAP_SUPPORT */

  pcb->settings.lcp_loopbackfail = LCP_DEFLOOPBACKFAIL;
 8019f7e:	69bb      	ldr	r3, [r7, #24]
 8019f80:	220a      	movs	r2, #10
 8019f82:	721a      	strb	r2, [r3, #8]
  pcb->settings.lcp_echo_interval = LCP_ECHOINTERVAL;
 8019f84:	69bb      	ldr	r3, [r7, #24]
 8019f86:	2200      	movs	r2, #0
 8019f88:	725a      	strb	r2, [r3, #9]
  pcb->settings.lcp_echo_fails = LCP_MAXECHOFAILS;
 8019f8a:	69bb      	ldr	r3, [r7, #24]
 8019f8c:	2203      	movs	r2, #3
 8019f8e:	729a      	strb	r2, [r3, #10]

  pcb->settings.fsm_timeout_time = FSM_DEFTIMEOUT;
 8019f90:	69bb      	ldr	r3, [r7, #24]
 8019f92:	2206      	movs	r2, #6
 8019f94:	711a      	strb	r2, [r3, #4]
  pcb->settings.fsm_max_conf_req_transmits = FSM_DEFMAXCONFREQS;
 8019f96:	69bb      	ldr	r3, [r7, #24]
 8019f98:	220a      	movs	r2, #10
 8019f9a:	715a      	strb	r2, [r3, #5]
  pcb->settings.fsm_max_term_transmits = FSM_DEFMAXTERMREQS;
 8019f9c:	69bb      	ldr	r3, [r7, #24]
 8019f9e:	2202      	movs	r2, #2
 8019fa0:	719a      	strb	r2, [r3, #6]
  pcb->settings.fsm_max_nak_loops = FSM_DEFMAXNAKLOOPS;
 8019fa2:	69bb      	ldr	r3, [r7, #24]
 8019fa4:	2205      	movs	r2, #5
 8019fa6:	71da      	strb	r2, [r3, #7]

  pcb->netif = pppif;
 8019fa8:	69bb      	ldr	r3, [r7, #24]
 8019faa:	68fa      	ldr	r2, [r7, #12]
 8019fac:	621a      	str	r2, [r3, #32]
  MIB2_INIT_NETIF(pppif, snmp_ifType_ppp, 0);
  if (!netif_add(pcb->netif,
 8019fae:	69bb      	ldr	r3, [r7, #24]
 8019fb0:	6a18      	ldr	r0, [r3, #32]
 8019fb2:	4c21      	ldr	r4, [pc, #132]	; (801a038 <ppp_new+0xf4>)
 8019fb4:	4a21      	ldr	r2, [pc, #132]	; (801a03c <ppp_new+0xf8>)
 8019fb6:	4920      	ldr	r1, [pc, #128]	; (801a038 <ppp_new+0xf4>)
 8019fb8:	2300      	movs	r3, #0
 8019fba:	9302      	str	r3, [sp, #8]
 8019fbc:	4b20      	ldr	r3, [pc, #128]	; (801a040 <ppp_new+0xfc>)
 8019fbe:	9301      	str	r3, [sp, #4]
 8019fc0:	69bb      	ldr	r3, [r7, #24]
 8019fc2:	9300      	str	r3, [sp, #0]
 8019fc4:	0023      	movs	r3, r4
 8019fc6:	f7ef f8af 	bl	8009128 <netif_add>
 8019fca:	1e03      	subs	r3, r0, #0
 8019fcc:	d107      	bne.n	8019fde <ppp_new+0x9a>
#if LWIP_IPV4
                 IP4_ADDR_ANY4, IP4_ADDR_BROADCAST, IP4_ADDR_ANY4,
#endif /* LWIP_IPV4 */
                 (void *)pcb, ppp_netif_init_cb, NULL)) {
    LWIP_MEMPOOL_FREE(PPP_PCB, pcb);
 8019fce:	69ba      	ldr	r2, [r7, #24]
 8019fd0:	4b17      	ldr	r3, [pc, #92]	; (801a030 <ppp_new+0xec>)
 8019fd2:	0011      	movs	r1, r2
 8019fd4:	0018      	movs	r0, r3
 8019fd6:	f7ef f85b 	bl	8009090 <memp_free_pool>
    PPPDEBUG(LOG_ERR, ("ppp_new: netif_add failed\n"));
    return NULL;
 8019fda:	2300      	movs	r3, #0
 8019fdc:	e024      	b.n	801a028 <ppp_new+0xe4>
  }

  pcb->link_cb = callbacks;
 8019fde:	69bb      	ldr	r3, [r7, #24]
 8019fe0:	68ba      	ldr	r2, [r7, #8]
 8019fe2:	60da      	str	r2, [r3, #12]
  pcb->link_ctx_cb = link_ctx_cb;
 8019fe4:	69bb      	ldr	r3, [r7, #24]
 8019fe6:	687a      	ldr	r2, [r7, #4]
 8019fe8:	611a      	str	r2, [r3, #16]
  pcb->link_status_cb = link_status_cb;
 8019fea:	69bb      	ldr	r3, [r7, #24]
 8019fec:	683a      	ldr	r2, [r7, #0]
 8019fee:	615a      	str	r2, [r3, #20]
  pcb->ctx_cb = ctx_cb;
 8019ff0:	69bb      	ldr	r3, [r7, #24]
 8019ff2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8019ff4:	61da      	str	r2, [r3, #28]

  /*
   * Initialize each protocol.
   */
  for (i = 0; (protp = protocols[i]) != NULL; ++i) {
 8019ff6:	2300      	movs	r3, #0
 8019ff8:	61fb      	str	r3, [r7, #28]
 8019ffa:	e007      	b.n	801a00c <ppp_new+0xc8>
      (*protp->init)(pcb);
 8019ffc:	697b      	ldr	r3, [r7, #20]
 8019ffe:	685b      	ldr	r3, [r3, #4]
 801a000:	69ba      	ldr	r2, [r7, #24]
 801a002:	0010      	movs	r0, r2
 801a004:	4798      	blx	r3
  for (i = 0; (protp = protocols[i]) != NULL; ++i) {
 801a006:	69fb      	ldr	r3, [r7, #28]
 801a008:	3301      	adds	r3, #1
 801a00a:	61fb      	str	r3, [r7, #28]
 801a00c:	4b0d      	ldr	r3, [pc, #52]	; (801a044 <ppp_new+0x100>)
 801a00e:	69fa      	ldr	r2, [r7, #28]
 801a010:	0092      	lsls	r2, r2, #2
 801a012:	58d3      	ldr	r3, [r2, r3]
 801a014:	617b      	str	r3, [r7, #20]
 801a016:	697b      	ldr	r3, [r7, #20]
 801a018:	2b00      	cmp	r3, #0
 801a01a:	d1ef      	bne.n	8019ffc <ppp_new+0xb8>
  }

  new_phase(pcb, PPP_PHASE_DEAD);
 801a01c:	69bb      	ldr	r3, [r7, #24]
 801a01e:	2100      	movs	r1, #0
 801a020:	0018      	movs	r0, r3
 801a022:	f000 f94a 	bl	801a2ba <new_phase>
  return pcb;
 801a026:	69bb      	ldr	r3, [r7, #24]
}
 801a028:	0018      	movs	r0, r3
 801a02a:	46bd      	mov	sp, r7
 801a02c:	b009      	add	sp, #36	; 0x24
 801a02e:	bd90      	pop	{r4, r7, pc}
 801a030:	08022ae4 	.word	0x08022ae4
 801a034:	00001264 	.word	0x00001264
 801a038:	08022888 	.word	0x08022888
 801a03c:	0802288c 	.word	0x0802288c
 801a040:	08019e19 	.word	0x08019e19
 801a044:	08022af4 	.word	0x08022af4

0801a048 <ppp_start>:

/** Initiate LCP open request */
void ppp_start(ppp_pcb *pcb) {
 801a048:	b580      	push	{r7, lr}
 801a04a:	b082      	sub	sp, #8
 801a04c:	af00      	add	r7, sp, #0
 801a04e:	6078      	str	r0, [r7, #4]
  pcb->mppe_keys_set = 0;
  memset(&pcb->mppe_comp, 0, sizeof(pcb->mppe_comp));
  memset(&pcb->mppe_decomp, 0, sizeof(pcb->mppe_decomp));
#endif /* MPPE_SUPPORT */
#if VJ_SUPPORT
  vj_compress_init(&pcb->vj_comp);
 801a050:	687b      	ldr	r3, [r7, #4]
 801a052:	33dc      	adds	r3, #220	; 0xdc
 801a054:	0018      	movs	r0, r3
 801a056:	f001 fc3e 	bl	801b8d6 <vj_compress_init>
#endif /* VJ_SUPPORT */

  /* Start protocol */
  new_phase(pcb, PPP_PHASE_ESTABLISH);
 801a05a:	687b      	ldr	r3, [r7, #4]
 801a05c:	2106      	movs	r1, #6
 801a05e:	0018      	movs	r0, r3
 801a060:	f000 f92b 	bl	801a2ba <new_phase>
  lcp_open(pcb);
 801a064:	687b      	ldr	r3, [r7, #4]
 801a066:	0018      	movs	r0, r3
 801a068:	f7fd fd3e 	bl	8017ae8 <lcp_open>
  lcp_lowerup(pcb);
 801a06c:	687b      	ldr	r3, [r7, #4]
 801a06e:	0018      	movs	r0, r3
 801a070:	f7fd fdb4 	bl	8017bdc <lcp_lowerup>
  PPPDEBUG(LOG_DEBUG, ("ppp_start[%d]: finished\n", pcb->netif->num));
}
 801a074:	46c0      	nop			; (mov r8, r8)
 801a076:	46bd      	mov	sp, r7
 801a078:	b002      	add	sp, #8
 801a07a:	bd80      	pop	{r7, pc}

0801a07c <ppp_link_end>:
  pcb->err_code = PPPERR_OPEN;
  pcb->link_status_cb(pcb, pcb->err_code, pcb->ctx_cb);
}

/** Called when link is normally down (i.e. it was asked to end) */
void ppp_link_end(ppp_pcb *pcb) {
 801a07c:	b590      	push	{r4, r7, lr}
 801a07e:	b083      	sub	sp, #12
 801a080:	af00      	add	r7, sp, #0
 801a082:	6078      	str	r0, [r7, #4]
  PPPDEBUG(LOG_DEBUG, ("ppp_link_end[%d]\n", pcb->netif->num));
  new_phase(pcb, PPP_PHASE_DEAD);
 801a084:	687b      	ldr	r3, [r7, #4]
 801a086:	2100      	movs	r1, #0
 801a088:	0018      	movs	r0, r3
 801a08a:	f000 f916 	bl	801a2ba <new_phase>
  if (pcb->err_code == PPPERR_NONE) {
 801a08e:	687b      	ldr	r3, [r7, #4]
 801a090:	2225      	movs	r2, #37	; 0x25
 801a092:	5c9b      	ldrb	r3, [r3, r2]
 801a094:	2b00      	cmp	r3, #0
 801a096:	d103      	bne.n	801a0a0 <ppp_link_end+0x24>
    pcb->err_code = PPPERR_CONNECT;
 801a098:	687b      	ldr	r3, [r7, #4]
 801a09a:	2225      	movs	r2, #37	; 0x25
 801a09c:	2106      	movs	r1, #6
 801a09e:	5499      	strb	r1, [r3, r2]
  }
  pcb->link_status_cb(pcb, pcb->err_code, pcb->ctx_cb);
 801a0a0:	687b      	ldr	r3, [r7, #4]
 801a0a2:	695c      	ldr	r4, [r3, #20]
 801a0a4:	687b      	ldr	r3, [r7, #4]
 801a0a6:	2225      	movs	r2, #37	; 0x25
 801a0a8:	5c9b      	ldrb	r3, [r3, r2]
 801a0aa:	0019      	movs	r1, r3
 801a0ac:	687b      	ldr	r3, [r7, #4]
 801a0ae:	69da      	ldr	r2, [r3, #28]
 801a0b0:	687b      	ldr	r3, [r7, #4]
 801a0b2:	0018      	movs	r0, r3
 801a0b4:	47a0      	blx	r4
}
 801a0b6:	46c0      	nop			; (mov r8, r8)
 801a0b8:	46bd      	mov	sp, r7
 801a0ba:	b003      	add	sp, #12
 801a0bc:	bd90      	pop	{r4, r7, pc}
	...

0801a0c0 <ppp_input>:

/*
 * Pass the processed input packet to the appropriate handler.
 * This function and all handlers run in the context of the tcpip_thread
 */
void ppp_input(ppp_pcb *pcb, struct pbuf *pb) {
 801a0c0:	b590      	push	{r4, r7, lr}
 801a0c2:	b087      	sub	sp, #28
 801a0c4:	af00      	add	r7, sp, #0
 801a0c6:	6078      	str	r0, [r7, #4]
 801a0c8:	6039      	str	r1, [r7, #0]
  u16_t protocol;
#if PPP_DEBUG && PPP_PROTOCOLNAME
    const char *pname;
#endif /* PPP_DEBUG && PPP_PROTOCOLNAME */

  magic_randomize();
 801a0ca:	f7ff fd7b 	bl	8019bc4 <magic_randomize>

  if (pb->len < 2) {
 801a0ce:	683b      	ldr	r3, [r7, #0]
 801a0d0:	895b      	ldrh	r3, [r3, #10]
 801a0d2:	2b01      	cmp	r3, #1
 801a0d4:	d800      	bhi.n	801a0d8 <ppp_input+0x18>
 801a0d6:	e0b6      	b.n	801a246 <ppp_input+0x186>
    PPPDEBUG(LOG_ERR, ("ppp_input[%d]: packet too short\n", pcb->netif->num));
    goto drop;
  }
  protocol = (((u8_t *)pb->payload)[0] << 8) | ((u8_t*)pb->payload)[1];
 801a0d8:	683b      	ldr	r3, [r7, #0]
 801a0da:	685b      	ldr	r3, [r3, #4]
 801a0dc:	781b      	ldrb	r3, [r3, #0]
 801a0de:	021b      	lsls	r3, r3, #8
 801a0e0:	b21a      	sxth	r2, r3
 801a0e2:	683b      	ldr	r3, [r7, #0]
 801a0e4:	685b      	ldr	r3, [r3, #4]
 801a0e6:	3301      	adds	r3, #1
 801a0e8:	781b      	ldrb	r3, [r3, #0]
 801a0ea:	b21b      	sxth	r3, r3
 801a0ec:	4313      	orrs	r3, r2
 801a0ee:	b21a      	sxth	r2, r3
 801a0f0:	2412      	movs	r4, #18
 801a0f2:	193b      	adds	r3, r7, r4
 801a0f4:	801a      	strh	r2, [r3, #0]

#if PRINTPKT_SUPPORT
  ppp_dump_packet(pcb, "rcvd", (unsigned char *)pb->payload, pb->len);
#endif /* PRINTPKT_SUPPORT */

  pbuf_remove_header(pb, sizeof(protocol));
 801a0f6:	683b      	ldr	r3, [r7, #0]
 801a0f8:	2102      	movs	r1, #2
 801a0fa:	0018      	movs	r0, r3
 801a0fc:	f7ef fe06 	bl	8009d0c <pbuf_remove_header>
  MIB2_STATS_NETIF_ADD(pcb->netif, ifinoctets, pb->tot_len);

  /*
   * Toss all non-LCP packets unless LCP is OPEN.
   */
  if (protocol != PPP_LCP && pcb->lcp_fsm.state != PPP_FSM_OPENED) {
 801a100:	193b      	adds	r3, r7, r4
 801a102:	881b      	ldrh	r3, [r3, #0]
 801a104:	4a57      	ldr	r2, [pc, #348]	; (801a264 <ppp_input+0x1a4>)
 801a106:	4293      	cmp	r3, r2
 801a108:	d009      	beq.n	801a11e <ppp_input+0x5e>
 801a10a:	687b      	ldr	r3, [r7, #4]
 801a10c:	2238      	movs	r2, #56	; 0x38
 801a10e:	5c9b      	ldrb	r3, [r3, r2]
 801a110:	2b09      	cmp	r3, #9
 801a112:	d004      	beq.n	801a11e <ppp_input+0x5e>
    ppp_dbglog("Discarded non-LCP packet when LCP not open");
 801a114:	4b54      	ldr	r3, [pc, #336]	; (801a268 <ppp_input+0x1a8>)
 801a116:	0018      	movs	r0, r3
 801a118:	f001 fbc9 	bl	801b8ae <ppp_dbglog>
    goto drop;
 801a11c:	e09a      	b.n	801a254 <ppp_input+0x194>

  /*
   * Until we get past the authentication phase, toss all packets
   * except LCP, LQR and authentication packets.
   */
  if (pcb->phase <= PPP_PHASE_AUTHENTICATE
 801a11e:	687b      	ldr	r3, [r7, #4]
 801a120:	2224      	movs	r2, #36	; 0x24
 801a122:	5c9b      	ldrb	r3, [r3, r2]
 801a124:	2b07      	cmp	r3, #7
 801a126:	d810      	bhi.n	801a14a <ppp_input+0x8a>
   && !(protocol == PPP_LCP
 801a128:	2112      	movs	r1, #18
 801a12a:	187b      	adds	r3, r7, r1
 801a12c:	881b      	ldrh	r3, [r3, #0]
 801a12e:	4a4d      	ldr	r2, [pc, #308]	; (801a264 <ppp_input+0x1a4>)
 801a130:	4293      	cmp	r3, r2
 801a132:	d00a      	beq.n	801a14a <ppp_input+0x8a>
#endif /* CHAP_SUPPORT */
#if EAP_SUPPORT
   || protocol == PPP_EAP
#endif /* EAP_SUPPORT */
   )) {
    ppp_dbglog("discarding proto 0x%x in phase %d", protocol, pcb->phase);
 801a134:	187b      	adds	r3, r7, r1
 801a136:	8819      	ldrh	r1, [r3, #0]
 801a138:	687b      	ldr	r3, [r7, #4]
 801a13a:	2224      	movs	r2, #36	; 0x24
 801a13c:	5c9b      	ldrb	r3, [r3, r2]
 801a13e:	001a      	movs	r2, r3
 801a140:	4b4a      	ldr	r3, [pc, #296]	; (801a26c <ppp_input+0x1ac>)
 801a142:	0018      	movs	r0, r3
 801a144:	f001 fbb3 	bl	801b8ae <ppp_dbglog>
    goto drop;
 801a148:	e084      	b.n	801a254 <ppp_input+0x194>
      pbuf_remove_header(pb, 2);
    }
  }
#endif /* CCP_SUPPORT */

  switch(protocol) {
 801a14a:	2312      	movs	r3, #18
 801a14c:	18fb      	adds	r3, r7, r3
 801a14e:	881b      	ldrh	r3, [r3, #0]
 801a150:	2b2f      	cmp	r3, #47	; 0x2f
 801a152:	d027      	beq.n	801a1a4 <ppp_input+0xe4>
 801a154:	dc3f      	bgt.n	801a1d6 <ppp_input+0x116>
 801a156:	2b21      	cmp	r3, #33	; 0x21
 801a158:	d002      	beq.n	801a160 <ppp_input+0xa0>
 801a15a:	2b2d      	cmp	r3, #45	; 0x2d
 801a15c:	d008      	beq.n	801a170 <ppp_input+0xb0>
 801a15e:	e03a      	b.n	801a1d6 <ppp_input+0x116>

#if PPP_IPV4_SUPPORT
    case PPP_IP:            /* Internet Protocol */
      PPPDEBUG(LOG_INFO, ("ppp_input[%d]: ip in pbuf len=%d\n", pcb->netif->num, pb->tot_len));
      ip4_input(pb, pcb->netif);
 801a160:	683a      	ldr	r2, [r7, #0]
 801a162:	687b      	ldr	r3, [r7, #4]
 801a164:	6a1b      	ldr	r3, [r3, #32]
 801a166:	0019      	movs	r1, r3
 801a168:	0010      	movs	r0, r2
 801a16a:	f7f9 facb 	bl	8013704 <ip4_input>
      return;
 801a16e:	e075      	b.n	801a25c <ppp_input+0x19c>
      /*
       * Clip off the VJ header and prepend the rebuilt TCP/IP header and
       * pass the result to IP.
       */
      PPPDEBUG(LOG_INFO, ("ppp_input[%d]: vj_comp in pbuf len=%d\n", pcb->netif->num, pb->tot_len));
      if (pcb->vj_enabled && vj_uncompress_tcp(&pb, &pcb->vj_comp) >= 0) {
 801a170:	687b      	ldr	r3, [r7, #4]
 801a172:	2226      	movs	r2, #38	; 0x26
 801a174:	5c9b      	ldrb	r3, [r3, r2]
 801a176:	2220      	movs	r2, #32
 801a178:	4013      	ands	r3, r2
 801a17a:	b2db      	uxtb	r3, r3
 801a17c:	2b00      	cmp	r3, #0
 801a17e:	d064      	beq.n	801a24a <ppp_input+0x18a>
 801a180:	687b      	ldr	r3, [r7, #4]
 801a182:	33dc      	adds	r3, #220	; 0xdc
 801a184:	001a      	movs	r2, r3
 801a186:	003b      	movs	r3, r7
 801a188:	0011      	movs	r1, r2
 801a18a:	0018      	movs	r0, r3
 801a18c:	f002 f8fe 	bl	801c38c <vj_uncompress_tcp>
 801a190:	1e03      	subs	r3, r0, #0
 801a192:	db5a      	blt.n	801a24a <ppp_input+0x18a>
        ip4_input(pb, pcb->netif);
 801a194:	683a      	ldr	r2, [r7, #0]
 801a196:	687b      	ldr	r3, [r7, #4]
 801a198:	6a1b      	ldr	r3, [r3, #32]
 801a19a:	0019      	movs	r1, r3
 801a19c:	0010      	movs	r0, r2
 801a19e:	f7f9 fab1 	bl	8013704 <ip4_input>
        return;
 801a1a2:	e05b      	b.n	801a25c <ppp_input+0x19c>
      /*
       * Process the TCP/IP header for VJ header compression and then pass
       * the packet to IP.
       */
      PPPDEBUG(LOG_INFO, ("ppp_input[%d]: vj_un in pbuf len=%d\n", pcb->netif->num, pb->tot_len));
      if (pcb->vj_enabled && vj_uncompress_uncomp(pb, &pcb->vj_comp) >= 0) {
 801a1a4:	687b      	ldr	r3, [r7, #4]
 801a1a6:	2226      	movs	r2, #38	; 0x26
 801a1a8:	5c9b      	ldrb	r3, [r3, r2]
 801a1aa:	2220      	movs	r2, #32
 801a1ac:	4013      	ands	r3, r2
 801a1ae:	b2db      	uxtb	r3, r3
 801a1b0:	2b00      	cmp	r3, #0
 801a1b2:	d04c      	beq.n	801a24e <ppp_input+0x18e>
 801a1b4:	683a      	ldr	r2, [r7, #0]
 801a1b6:	687b      	ldr	r3, [r7, #4]
 801a1b8:	33dc      	adds	r3, #220	; 0xdc
 801a1ba:	0019      	movs	r1, r3
 801a1bc:	0010      	movs	r0, r2
 801a1be:	f002 f877 	bl	801c2b0 <vj_uncompress_uncomp>
 801a1c2:	1e03      	subs	r3, r0, #0
 801a1c4:	db43      	blt.n	801a24e <ppp_input+0x18e>
        ip4_input(pb, pcb->netif);
 801a1c6:	683a      	ldr	r2, [r7, #0]
 801a1c8:	687b      	ldr	r3, [r7, #4]
 801a1ca:	6a1b      	ldr	r3, [r3, #32]
 801a1cc:	0019      	movs	r1, r3
 801a1ce:	0010      	movs	r0, r2
 801a1d0:	f7f9 fa98 	bl	8013704 <ip4_input>
        return;
 801a1d4:	e042      	b.n	801a25c <ppp_input+0x19c>
      const struct protent *protp;

      /*
       * Upcall the proper protocol input routine.
       */
      for (i = 0; (protp = protocols[i]) != NULL; ++i) {
 801a1d6:	2300      	movs	r3, #0
 801a1d8:	617b      	str	r3, [r7, #20]
 801a1da:	e01b      	b.n	801a214 <ppp_input+0x154>
        if (protp->protocol == protocol) {
 801a1dc:	68fb      	ldr	r3, [r7, #12]
 801a1de:	881b      	ldrh	r3, [r3, #0]
 801a1e0:	2212      	movs	r2, #18
 801a1e2:	18ba      	adds	r2, r7, r2
 801a1e4:	8812      	ldrh	r2, [r2, #0]
 801a1e6:	429a      	cmp	r2, r3
 801a1e8:	d111      	bne.n	801a20e <ppp_input+0x14e>
          pb = pbuf_coalesce(pb, PBUF_RAW);
 801a1ea:	683b      	ldr	r3, [r7, #0]
 801a1ec:	2100      	movs	r1, #0
 801a1ee:	0018      	movs	r0, r3
 801a1f0:	f7f0 fb1c 	bl	800a82c <pbuf_coalesce>
 801a1f4:	0003      	movs	r3, r0
 801a1f6:	603b      	str	r3, [r7, #0]
          (*protp->input)(pcb, (u8_t*)pb->payload, pb->len);
 801a1f8:	68fb      	ldr	r3, [r7, #12]
 801a1fa:	689c      	ldr	r4, [r3, #8]
 801a1fc:	683b      	ldr	r3, [r7, #0]
 801a1fe:	6859      	ldr	r1, [r3, #4]
 801a200:	683b      	ldr	r3, [r7, #0]
 801a202:	895b      	ldrh	r3, [r3, #10]
 801a204:	001a      	movs	r2, r3
 801a206:	687b      	ldr	r3, [r7, #4]
 801a208:	0018      	movs	r0, r3
 801a20a:	47a0      	blx	r4
          goto out;
 801a20c:	e022      	b.n	801a254 <ppp_input+0x194>
      for (i = 0; (protp = protocols[i]) != NULL; ++i) {
 801a20e:	697b      	ldr	r3, [r7, #20]
 801a210:	3301      	adds	r3, #1
 801a212:	617b      	str	r3, [r7, #20]
 801a214:	4b16      	ldr	r3, [pc, #88]	; (801a270 <ppp_input+0x1b0>)
 801a216:	697a      	ldr	r2, [r7, #20]
 801a218:	0092      	lsls	r2, r2, #2
 801a21a:	58d3      	ldr	r3, [r2, r3]
 801a21c:	60fb      	str	r3, [r7, #12]
 801a21e:	68fb      	ldr	r3, [r7, #12]
 801a220:	2b00      	cmp	r3, #0
 801a222:	d1db      	bne.n	801a1dc <ppp_input+0x11c>
        ppp_warn("Unsupported protocol '%s' (0x%x) received", pname, protocol);
      } else
#endif /* PPP_PROTOCOLNAME */
        ppp_warn("Unsupported protocol 0x%x received", protocol);
#endif /* PPP_DEBUG */
        if (pbuf_add_header(pb, sizeof(protocol))) {
 801a224:	683b      	ldr	r3, [r7, #0]
 801a226:	2102      	movs	r1, #2
 801a228:	0018      	movs	r0, r3
 801a22a:	f7ef fd5f 	bl	8009cec <pbuf_add_header>
 801a22e:	1e03      	subs	r3, r0, #0
 801a230:	d10f      	bne.n	801a252 <ppp_input+0x192>
          PPPDEBUG(LOG_WARNING, ("ppp_input[%d]: Dropping (pbuf_add_header failed)\n", pcb->netif->num));
          goto drop;
        }
        lcp_sprotrej(pcb, (u8_t*)pb->payload, pb->len);
 801a232:	683b      	ldr	r3, [r7, #0]
 801a234:	6859      	ldr	r1, [r3, #4]
 801a236:	683b      	ldr	r3, [r7, #0]
 801a238:	895b      	ldrh	r3, [r3, #10]
 801a23a:	001a      	movs	r2, r3
 801a23c:	687b      	ldr	r3, [r7, #4]
 801a23e:	0018      	movs	r0, r3
 801a240:	f7fd fe6a 	bl	8017f18 <lcp_sprotrej>
      }
      break;
 801a244:	e006      	b.n	801a254 <ppp_input+0x194>
    goto drop;
 801a246:	46c0      	nop			; (mov r8, r8)
 801a248:	e004      	b.n	801a254 <ppp_input+0x194>
      break;
 801a24a:	46c0      	nop			; (mov r8, r8)
 801a24c:	e002      	b.n	801a254 <ppp_input+0x194>
      break;
 801a24e:	46c0      	nop			; (mov r8, r8)
 801a250:	e000      	b.n	801a254 <ppp_input+0x194>
          goto drop;
 801a252:	46c0      	nop			; (mov r8, r8)
drop:
  LINK_STATS_INC(link.drop);
  MIB2_STATS_NETIF_INC(pcb->netif, ifindiscards);

out:
  pbuf_free(pb);
 801a254:	683b      	ldr	r3, [r7, #0]
 801a256:	0018      	movs	r0, r3
 801a258:	f7ef fe30 	bl	8009ebc <pbuf_free>
}
 801a25c:	46bd      	mov	sp, r7
 801a25e:	b007      	add	sp, #28
 801a260:	bd90      	pop	{r4, r7, pc}
 801a262:	46c0      	nop			; (mov r8, r8)
 801a264:	0000c021 	.word	0x0000c021
 801a268:	08021f5c 	.word	0x08021f5c
 801a26c:	08021f88 	.word	0x08021f88
 801a270:	08022af4 	.word	0x08022af4

0801a274 <ppp_write>:
 *
 * IPv4 and IPv6 packets from lwIP are sent, respectively,
 * with ppp_netif_output_ip4() and ppp_netif_output_ip6()
 * functions (which are callbacks of the netif PPP interface).
 */
err_t ppp_write(ppp_pcb *pcb, struct pbuf *p) {
 801a274:	b590      	push	{r4, r7, lr}
 801a276:	b083      	sub	sp, #12
 801a278:	af00      	add	r7, sp, #0
 801a27a:	6078      	str	r0, [r7, #4]
 801a27c:	6039      	str	r1, [r7, #0]
#if PRINTPKT_SUPPORT
  ppp_dump_packet(pcb, "sent", (unsigned char *)p->payload+2, p->len-2);
#endif /* PRINTPKT_SUPPORT */
  return pcb->link_cb->write(pcb, pcb->link_ctx_cb, p);
 801a27e:	687b      	ldr	r3, [r7, #4]
 801a280:	68db      	ldr	r3, [r3, #12]
 801a282:	68dc      	ldr	r4, [r3, #12]
 801a284:	687b      	ldr	r3, [r7, #4]
 801a286:	6919      	ldr	r1, [r3, #16]
 801a288:	683a      	ldr	r2, [r7, #0]
 801a28a:	687b      	ldr	r3, [r7, #4]
 801a28c:	0018      	movs	r0, r3
 801a28e:	47a0      	blx	r4
 801a290:	0003      	movs	r3, r0
}
 801a292:	0018      	movs	r0, r3
 801a294:	46bd      	mov	sp, r7
 801a296:	b003      	add	sp, #12
 801a298:	bd90      	pop	{r4, r7, pc}

0801a29a <ppp_link_terminated>:

void ppp_link_terminated(ppp_pcb *pcb) {
 801a29a:	b580      	push	{r7, lr}
 801a29c:	b082      	sub	sp, #8
 801a29e:	af00      	add	r7, sp, #0
 801a2a0:	6078      	str	r0, [r7, #4]
  PPPDEBUG(LOG_DEBUG, ("ppp_link_terminated[%d]\n", pcb->netif->num));
  pcb->link_cb->disconnect(pcb, pcb->link_ctx_cb);
 801a2a2:	687b      	ldr	r3, [r7, #4]
 801a2a4:	68db      	ldr	r3, [r3, #12]
 801a2a6:	685a      	ldr	r2, [r3, #4]
 801a2a8:	687b      	ldr	r3, [r7, #4]
 801a2aa:	6919      	ldr	r1, [r3, #16]
 801a2ac:	687b      	ldr	r3, [r7, #4]
 801a2ae:	0018      	movs	r0, r3
 801a2b0:	4790      	blx	r2
  PPPDEBUG(LOG_DEBUG, ("ppp_link_terminated[%d]: finished.\n", pcb->netif->num));
}
 801a2b2:	46c0      	nop			; (mov r8, r8)
 801a2b4:	46bd      	mov	sp, r7
 801a2b6:	b002      	add	sp, #8
 801a2b8:	bd80      	pop	{r7, pc}

0801a2ba <new_phase>:
 */

/*
 * new_phase - signal the start of a new phase of pppd's operation.
 */
void new_phase(ppp_pcb *pcb, int p) {
 801a2ba:	b590      	push	{r4, r7, lr}
 801a2bc:	b083      	sub	sp, #12
 801a2be:	af00      	add	r7, sp, #0
 801a2c0:	6078      	str	r0, [r7, #4]
 801a2c2:	6039      	str	r1, [r7, #0]
  pcb->phase = p;
 801a2c4:	683b      	ldr	r3, [r7, #0]
 801a2c6:	b2d9      	uxtb	r1, r3
 801a2c8:	687b      	ldr	r3, [r7, #4]
 801a2ca:	2224      	movs	r2, #36	; 0x24
 801a2cc:	5499      	strb	r1, [r3, r2]
  PPPDEBUG(LOG_DEBUG, ("ppp phase changed[%d]: phase=%d\n", pcb->netif->num, pcb->phase));
#if PPP_NOTIFY_PHASE
  if (pcb->notify_phase_cb != NULL) {
 801a2ce:	687b      	ldr	r3, [r7, #4]
 801a2d0:	699b      	ldr	r3, [r3, #24]
 801a2d2:	2b00      	cmp	r3, #0
 801a2d4:	d008      	beq.n	801a2e8 <new_phase+0x2e>
    pcb->notify_phase_cb(pcb, p, pcb->ctx_cb);
 801a2d6:	687b      	ldr	r3, [r7, #4]
 801a2d8:	699c      	ldr	r4, [r3, #24]
 801a2da:	683b      	ldr	r3, [r7, #0]
 801a2dc:	b2d9      	uxtb	r1, r3
 801a2de:	687b      	ldr	r3, [r7, #4]
 801a2e0:	69da      	ldr	r2, [r3, #28]
 801a2e2:	687b      	ldr	r3, [r7, #4]
 801a2e4:	0018      	movs	r0, r3
 801a2e6:	47a0      	blx	r4
  }
#endif /* PPP_NOTIFY_PHASE */
}
 801a2e8:	46c0      	nop			; (mov r8, r8)
 801a2ea:	46bd      	mov	sp, r7
 801a2ec:	b003      	add	sp, #12
 801a2ee:	bd90      	pop	{r4, r7, pc}

0801a2f0 <ppp_send_config>:

/*
 * ppp_send_config - configure the transmit-side characteristics of
 * the ppp interface.
 */
int ppp_send_config(ppp_pcb *pcb, int mtu, u32_t accm, int pcomp, int accomp) {
 801a2f0:	b5b0      	push	{r4, r5, r7, lr}
 801a2f2:	b086      	sub	sp, #24
 801a2f4:	af02      	add	r7, sp, #8
 801a2f6:	60f8      	str	r0, [r7, #12]
 801a2f8:	60b9      	str	r1, [r7, #8]
 801a2fa:	607a      	str	r2, [r7, #4]
 801a2fc:	603b      	str	r3, [r7, #0]
  LWIP_UNUSED_ARG(mtu);
  /* pcb->mtu = mtu; -- set correctly with netif_set_mtu */

  if (pcb->link_cb->send_config) {
 801a2fe:	68fb      	ldr	r3, [r7, #12]
 801a300:	68db      	ldr	r3, [r3, #12]
 801a302:	695b      	ldr	r3, [r3, #20]
 801a304:	2b00      	cmp	r3, #0
 801a306:	d00b      	beq.n	801a320 <ppp_send_config+0x30>
    pcb->link_cb->send_config(pcb, pcb->link_ctx_cb, accm, pcomp, accomp);
 801a308:	68fb      	ldr	r3, [r7, #12]
 801a30a:	68db      	ldr	r3, [r3, #12]
 801a30c:	695c      	ldr	r4, [r3, #20]
 801a30e:	68fb      	ldr	r3, [r7, #12]
 801a310:	6919      	ldr	r1, [r3, #16]
 801a312:	683d      	ldr	r5, [r7, #0]
 801a314:	687a      	ldr	r2, [r7, #4]
 801a316:	68f8      	ldr	r0, [r7, #12]
 801a318:	6a3b      	ldr	r3, [r7, #32]
 801a31a:	9300      	str	r3, [sp, #0]
 801a31c:	002b      	movs	r3, r5
 801a31e:	47a0      	blx	r4
  }

  PPPDEBUG(LOG_INFO, ("ppp_send_config[%d]\n", pcb->netif->num) );
  return 0;
 801a320:	2300      	movs	r3, #0
}
 801a322:	0018      	movs	r0, r3
 801a324:	46bd      	mov	sp, r7
 801a326:	b004      	add	sp, #16
 801a328:	bdb0      	pop	{r4, r5, r7, pc}

0801a32a <ppp_recv_config>:

/*
 * ppp_recv_config - configure the receive-side characteristics of
 * the ppp interface.
 */
int ppp_recv_config(ppp_pcb *pcb, int mru, u32_t accm, int pcomp, int accomp) {
 801a32a:	b5b0      	push	{r4, r5, r7, lr}
 801a32c:	b086      	sub	sp, #24
 801a32e:	af02      	add	r7, sp, #8
 801a330:	60f8      	str	r0, [r7, #12]
 801a332:	60b9      	str	r1, [r7, #8]
 801a334:	607a      	str	r2, [r7, #4]
 801a336:	603b      	str	r3, [r7, #0]
  LWIP_UNUSED_ARG(mru);

  if (pcb->link_cb->recv_config) {
 801a338:	68fb      	ldr	r3, [r7, #12]
 801a33a:	68db      	ldr	r3, [r3, #12]
 801a33c:	699b      	ldr	r3, [r3, #24]
 801a33e:	2b00      	cmp	r3, #0
 801a340:	d00b      	beq.n	801a35a <ppp_recv_config+0x30>
    pcb->link_cb->recv_config(pcb, pcb->link_ctx_cb, accm, pcomp, accomp);
 801a342:	68fb      	ldr	r3, [r7, #12]
 801a344:	68db      	ldr	r3, [r3, #12]
 801a346:	699c      	ldr	r4, [r3, #24]
 801a348:	68fb      	ldr	r3, [r7, #12]
 801a34a:	6919      	ldr	r1, [r3, #16]
 801a34c:	683d      	ldr	r5, [r7, #0]
 801a34e:	687a      	ldr	r2, [r7, #4]
 801a350:	68f8      	ldr	r0, [r7, #12]
 801a352:	6a3b      	ldr	r3, [r7, #32]
 801a354:	9300      	str	r3, [sp, #0]
 801a356:	002b      	movs	r3, r5
 801a358:	47a0      	blx	r4
  }

  PPPDEBUG(LOG_INFO, ("ppp_recv_config[%d]\n", pcb->netif->num));
  return 0;
 801a35a:	2300      	movs	r3, #0
}
 801a35c:	0018      	movs	r0, r3
 801a35e:	46bd      	mov	sp, r7
 801a360:	b004      	add	sp, #16
 801a362:	bdb0      	pop	{r4, r5, r7, pc}

0801a364 <sifaddr>:

#if PPP_IPV4_SUPPORT
/*
 * sifaddr - Config the interface IP addresses and netmask.
 */
int sifaddr(ppp_pcb *pcb, u32_t our_adr, u32_t his_adr, u32_t netmask) {
 801a364:	b580      	push	{r7, lr}
 801a366:	b088      	sub	sp, #32
 801a368:	af00      	add	r7, sp, #0
 801a36a:	60f8      	str	r0, [r7, #12]
 801a36c:	60b9      	str	r1, [r7, #8]
 801a36e:	607a      	str	r2, [r7, #4]
 801a370:	603b      	str	r3, [r7, #0]
  ip4_addr_t ip, nm, gw;

  ip4_addr_set_u32(&ip, our_adr);
 801a372:	68bb      	ldr	r3, [r7, #8]
 801a374:	61fb      	str	r3, [r7, #28]
  ip4_addr_set_u32(&nm, netmask);
 801a376:	683b      	ldr	r3, [r7, #0]
 801a378:	61bb      	str	r3, [r7, #24]
  ip4_addr_set_u32(&gw, his_adr);
 801a37a:	687b      	ldr	r3, [r7, #4]
 801a37c:	617b      	str	r3, [r7, #20]
  netif_set_addr(pcb->netif, &ip, &nm, &gw);
 801a37e:	68fb      	ldr	r3, [r7, #12]
 801a380:	6a18      	ldr	r0, [r3, #32]
 801a382:	2314      	movs	r3, #20
 801a384:	18fb      	adds	r3, r7, r3
 801a386:	2218      	movs	r2, #24
 801a388:	18ba      	adds	r2, r7, r2
 801a38a:	211c      	movs	r1, #28
 801a38c:	1879      	adds	r1, r7, r1
 801a38e:	f7ef f83d 	bl	800940c <netif_set_addr>
  return 1;
 801a392:	2301      	movs	r3, #1
}
 801a394:	0018      	movs	r0, r3
 801a396:	46bd      	mov	sp, r7
 801a398:	b008      	add	sp, #32
 801a39a:	bd80      	pop	{r7, pc}

0801a39c <cifaddr>:
/********************************************************************
 *
 * cifaddr - Clear the interface IP addresses, and delete routes
 * through the interface if possible.
 */
int cifaddr(ppp_pcb *pcb, u32_t our_adr, u32_t his_adr) {
 801a39c:	b580      	push	{r7, lr}
 801a39e:	b084      	sub	sp, #16
 801a3a0:	af00      	add	r7, sp, #0
 801a3a2:	60f8      	str	r0, [r7, #12]
 801a3a4:	60b9      	str	r1, [r7, #8]
 801a3a6:	607a      	str	r2, [r7, #4]
  LWIP_UNUSED_ARG(our_adr);
  LWIP_UNUSED_ARG(his_adr);

  netif_set_addr(pcb->netif, IP4_ADDR_ANY4, IP4_ADDR_BROADCAST, IP4_ADDR_ANY4);
 801a3a8:	68fb      	ldr	r3, [r7, #12]
 801a3aa:	6a18      	ldr	r0, [r3, #32]
 801a3ac:	4b04      	ldr	r3, [pc, #16]	; (801a3c0 <cifaddr+0x24>)
 801a3ae:	4a05      	ldr	r2, [pc, #20]	; (801a3c4 <cifaddr+0x28>)
 801a3b0:	4903      	ldr	r1, [pc, #12]	; (801a3c0 <cifaddr+0x24>)
 801a3b2:	f7ef f82b 	bl	800940c <netif_set_addr>
  return 1;
 801a3b6:	2301      	movs	r3, #1
}
 801a3b8:	0018      	movs	r0, r3
 801a3ba:	46bd      	mov	sp, r7
 801a3bc:	b004      	add	sp, #16
 801a3be:	bd80      	pop	{r7, pc}
 801a3c0:	08022888 	.word	0x08022888
 801a3c4:	0802288c 	.word	0x0802288c

0801a3c8 <sdns>:

#if LWIP_DNS
/*
 * sdns - Config the DNS servers
 */
int sdns(ppp_pcb *pcb, u32_t ns1, u32_t ns2) {
 801a3c8:	b590      	push	{r4, r7, lr}
 801a3ca:	b087      	sub	sp, #28
 801a3cc:	af00      	add	r7, sp, #0
 801a3ce:	60f8      	str	r0, [r7, #12]
 801a3d0:	60b9      	str	r1, [r7, #8]
 801a3d2:	607a      	str	r2, [r7, #4]
  ip_addr_t ns;
  LWIP_UNUSED_ARG(pcb);

  ip_addr_set_ip4_u32_val(ns, ns1);
 801a3d4:	68bb      	ldr	r3, [r7, #8]
 801a3d6:	617b      	str	r3, [r7, #20]
  dns_setserver(0, &ns);
 801a3d8:	2414      	movs	r4, #20
 801a3da:	193b      	adds	r3, r7, r4
 801a3dc:	0019      	movs	r1, r3
 801a3de:	2000      	movs	r0, #0
 801a3e0:	f7ec fe08 	bl	8006ff4 <dns_setserver>
  ip_addr_set_ip4_u32_val(ns, ns2);
 801a3e4:	687b      	ldr	r3, [r7, #4]
 801a3e6:	617b      	str	r3, [r7, #20]
  dns_setserver(1, &ns);
 801a3e8:	193b      	adds	r3, r7, r4
 801a3ea:	0019      	movs	r1, r3
 801a3ec:	2001      	movs	r0, #1
 801a3ee:	f7ec fe01 	bl	8006ff4 <dns_setserver>
  return 1;
 801a3f2:	2301      	movs	r3, #1
}
 801a3f4:	0018      	movs	r0, r3
 801a3f6:	46bd      	mov	sp, r7
 801a3f8:	b007      	add	sp, #28
 801a3fa:	bd90      	pop	{r4, r7, pc}

0801a3fc <cdns>:

/********************************************************************
 *
 * cdns - Clear the DNS servers
 */
int cdns(ppp_pcb *pcb, u32_t ns1, u32_t ns2) {
 801a3fc:	b580      	push	{r7, lr}
 801a3fe:	b086      	sub	sp, #24
 801a400:	af00      	add	r7, sp, #0
 801a402:	60f8      	str	r0, [r7, #12]
 801a404:	60b9      	str	r1, [r7, #8]
 801a406:	607a      	str	r2, [r7, #4]
  const ip_addr_t *nsa;
  ip_addr_t nsb;
  LWIP_UNUSED_ARG(pcb);

  nsa = dns_getserver(0);
 801a408:	2000      	movs	r0, #0
 801a40a:	f7ec fe19 	bl	8007040 <dns_getserver>
 801a40e:	0003      	movs	r3, r0
 801a410:	617b      	str	r3, [r7, #20]
  ip_addr_set_ip4_u32_val(nsb, ns1);
 801a412:	68bb      	ldr	r3, [r7, #8]
 801a414:	613b      	str	r3, [r7, #16]
  if (ip_addr_cmp(nsa, &nsb)) {
 801a416:	697b      	ldr	r3, [r7, #20]
 801a418:	681a      	ldr	r2, [r3, #0]
 801a41a:	693b      	ldr	r3, [r7, #16]
 801a41c:	429a      	cmp	r2, r3
 801a41e:	d104      	bne.n	801a42a <cdns+0x2e>
    dns_setserver(0, IP_ADDR_ANY);
 801a420:	4b0d      	ldr	r3, [pc, #52]	; (801a458 <cdns+0x5c>)
 801a422:	0019      	movs	r1, r3
 801a424:	2000      	movs	r0, #0
 801a426:	f7ec fde5 	bl	8006ff4 <dns_setserver>
  }
  nsa = dns_getserver(1);
 801a42a:	2001      	movs	r0, #1
 801a42c:	f7ec fe08 	bl	8007040 <dns_getserver>
 801a430:	0003      	movs	r3, r0
 801a432:	617b      	str	r3, [r7, #20]
  ip_addr_set_ip4_u32_val(nsb, ns2);
 801a434:	687b      	ldr	r3, [r7, #4]
 801a436:	613b      	str	r3, [r7, #16]
  if (ip_addr_cmp(nsa, &nsb)) {
 801a438:	697b      	ldr	r3, [r7, #20]
 801a43a:	681a      	ldr	r2, [r3, #0]
 801a43c:	693b      	ldr	r3, [r7, #16]
 801a43e:	429a      	cmp	r2, r3
 801a440:	d104      	bne.n	801a44c <cdns+0x50>
    dns_setserver(1, IP_ADDR_ANY);
 801a442:	4b05      	ldr	r3, [pc, #20]	; (801a458 <cdns+0x5c>)
 801a444:	0019      	movs	r1, r3
 801a446:	2001      	movs	r0, #1
 801a448:	f7ec fdd4 	bl	8006ff4 <dns_setserver>
  }
  return 1;
 801a44c:	2301      	movs	r3, #1
}
 801a44e:	0018      	movs	r0, r3
 801a450:	46bd      	mov	sp, r7
 801a452:	b006      	add	sp, #24
 801a454:	bd80      	pop	{r7, pc}
 801a456:	46c0      	nop			; (mov r8, r8)
 801a458:	08022888 	.word	0x08022888

0801a45c <sifvjcomp>:
#if VJ_SUPPORT
/********************************************************************
 *
 * sifvjcomp - config tcp header compression
 */
int sifvjcomp(ppp_pcb *pcb, int vjcomp, int cidcomp, int maxcid) {
 801a45c:	b590      	push	{r4, r7, lr}
 801a45e:	b085      	sub	sp, #20
 801a460:	af00      	add	r7, sp, #0
 801a462:	60f8      	str	r0, [r7, #12]
 801a464:	60b9      	str	r1, [r7, #8]
 801a466:	607a      	str	r2, [r7, #4]
 801a468:	603b      	str	r3, [r7, #0]
  pcb->vj_enabled = vjcomp;
 801a46a:	68bb      	ldr	r3, [r7, #8]
 801a46c:	1c1a      	adds	r2, r3, #0
 801a46e:	2301      	movs	r3, #1
 801a470:	4013      	ands	r3, r2
 801a472:	b2d9      	uxtb	r1, r3
 801a474:	68fb      	ldr	r3, [r7, #12]
 801a476:	2226      	movs	r2, #38	; 0x26
 801a478:	2001      	movs	r0, #1
 801a47a:	4001      	ands	r1, r0
 801a47c:	014c      	lsls	r4, r1, #5
 801a47e:	5c99      	ldrb	r1, [r3, r2]
 801a480:	2020      	movs	r0, #32
 801a482:	4381      	bics	r1, r0
 801a484:	1c08      	adds	r0, r1, #0
 801a486:	1c21      	adds	r1, r4, #0
 801a488:	4301      	orrs	r1, r0
 801a48a:	5499      	strb	r1, [r3, r2]
  pcb->vj_comp.compressSlot = cidcomp;
 801a48c:	687b      	ldr	r3, [r7, #4]
 801a48e:	b2d9      	uxtb	r1, r3
 801a490:	68fb      	ldr	r3, [r7, #12]
 801a492:	22e5      	movs	r2, #229	; 0xe5
 801a494:	5499      	strb	r1, [r3, r2]
  pcb->vj_comp.maxSlotIndex = maxcid;
 801a496:	683b      	ldr	r3, [r7, #0]
 801a498:	b2d9      	uxtb	r1, r3
 801a49a:	68fb      	ldr	r3, [r7, #12]
 801a49c:	22e4      	movs	r2, #228	; 0xe4
 801a49e:	5499      	strb	r1, [r3, r2]
  PPPDEBUG(LOG_INFO, ("sifvjcomp[%d]: VJ compress enable=%d slot=%d max slot=%d\n",
            pcb->netif->num, vjcomp, cidcomp, maxcid));
  return 0;
 801a4a0:	2300      	movs	r3, #0
}
 801a4a2:	0018      	movs	r0, r3
 801a4a4:	46bd      	mov	sp, r7
 801a4a6:	b005      	add	sp, #20
 801a4a8:	bd90      	pop	{r4, r7, pc}

0801a4aa <sifup>:
#endif /* VJ_SUPPORT */

/*
 * sifup - Config the interface up and enable IP packets to pass.
 */
int sifup(ppp_pcb *pcb) {
 801a4aa:	b590      	push	{r4, r7, lr}
 801a4ac:	b083      	sub	sp, #12
 801a4ae:	af00      	add	r7, sp, #0
 801a4b0:	6078      	str	r0, [r7, #4]
  pcb->if4_up = 1;
 801a4b2:	687b      	ldr	r3, [r7, #4]
 801a4b4:	2226      	movs	r2, #38	; 0x26
 801a4b6:	5c99      	ldrb	r1, [r3, r2]
 801a4b8:	2008      	movs	r0, #8
 801a4ba:	4301      	orrs	r1, r0
 801a4bc:	5499      	strb	r1, [r3, r2]
  pcb->err_code = PPPERR_NONE;
 801a4be:	687b      	ldr	r3, [r7, #4]
 801a4c0:	2225      	movs	r2, #37	; 0x25
 801a4c2:	2100      	movs	r1, #0
 801a4c4:	5499      	strb	r1, [r3, r2]
  netif_set_link_up(pcb->netif);
 801a4c6:	687b      	ldr	r3, [r7, #4]
 801a4c8:	6a1b      	ldr	r3, [r3, #32]
 801a4ca:	0018      	movs	r0, r3
 801a4cc:	f7ef f89a 	bl	8009604 <netif_set_link_up>

  PPPDEBUG(LOG_DEBUG, ("sifup[%d]: err_code=%d\n", pcb->netif->num, pcb->err_code));
  pcb->link_status_cb(pcb, pcb->err_code, pcb->ctx_cb);
 801a4d0:	687b      	ldr	r3, [r7, #4]
 801a4d2:	695c      	ldr	r4, [r3, #20]
 801a4d4:	687b      	ldr	r3, [r7, #4]
 801a4d6:	2225      	movs	r2, #37	; 0x25
 801a4d8:	5c9b      	ldrb	r3, [r3, r2]
 801a4da:	0019      	movs	r1, r3
 801a4dc:	687b      	ldr	r3, [r7, #4]
 801a4de:	69da      	ldr	r2, [r3, #28]
 801a4e0:	687b      	ldr	r3, [r7, #4]
 801a4e2:	0018      	movs	r0, r3
 801a4e4:	47a0      	blx	r4
  return 1;
 801a4e6:	2301      	movs	r3, #1
}
 801a4e8:	0018      	movs	r0, r3
 801a4ea:	46bd      	mov	sp, r7
 801a4ec:	b003      	add	sp, #12
 801a4ee:	bd90      	pop	{r4, r7, pc}

0801a4f0 <sifdown>:
/********************************************************************
 *
 * sifdown - Disable the indicated protocol and config the interface
 *           down if there are no remaining protocols.
 */
int sifdown(ppp_pcb *pcb) {
 801a4f0:	b580      	push	{r7, lr}
 801a4f2:	b082      	sub	sp, #8
 801a4f4:	af00      	add	r7, sp, #0
 801a4f6:	6078      	str	r0, [r7, #4]

  pcb->if4_up = 0;
 801a4f8:	687b      	ldr	r3, [r7, #4]
 801a4fa:	2226      	movs	r2, #38	; 0x26
 801a4fc:	5c99      	ldrb	r1, [r3, r2]
 801a4fe:	2008      	movs	r0, #8
 801a500:	4381      	bics	r1, r0
 801a502:	5499      	strb	r1, [r3, r2]
   /* set the interface down if IPv6 is down as well */
   && !pcb->if6_up
#endif /* PPP_IPV6_SUPPORT */
  ) {
    /* make sure the netif link callback is called */
    netif_set_link_down(pcb->netif);
 801a504:	687b      	ldr	r3, [r7, #4]
 801a506:	6a1b      	ldr	r3, [r3, #32]
 801a508:	0018      	movs	r0, r3
 801a50a:	f7ef f8ab 	bl	8009664 <netif_set_link_down>
  }
  PPPDEBUG(LOG_DEBUG, ("sifdown[%d]: err_code=%d\n", pcb->netif->num, pcb->err_code));
  return 1;
 801a50e:	2301      	movs	r3, #1
}
 801a510:	0018      	movs	r0, r3
 801a512:	46bd      	mov	sp, r7
 801a514:	b002      	add	sp, #8
 801a516:	bd80      	pop	{r7, pc}

0801a518 <get_mask>:
 * Here we scan through the system's list of interfaces, looking for
 * any non-point-to-point interfaces which might appear to be on the same
 * network as `addr'.  If we find any, we OR in their netmask to the
 * user-specified netmask.
 */
u32_t get_mask(u32_t addr) {
 801a518:	b580      	push	{r7, lr}
 801a51a:	b082      	sub	sp, #8
 801a51c:	af00      	add	r7, sp, #0
 801a51e:	6078      	str	r0, [r7, #4]
   */
  /* return mask; */
  return mask;
#endif /* 0 */
  LWIP_UNUSED_ARG(addr);
  return IPADDR_BROADCAST;
 801a520:	2301      	movs	r3, #1
 801a522:	425b      	negs	r3, r3
}
 801a524:	0018      	movs	r0, r3
 801a526:	46bd      	mov	sp, r7
 801a528:	b002      	add	sp, #8
 801a52a:	bd80      	pop	{r7, pc}

0801a52c <netif_set_mtu>:
#endif /* DEMAND_SUPPORT */

/*
 * netif_set_mtu - set the MTU on the PPP network interface.
 */
void netif_set_mtu(ppp_pcb *pcb, int mtu) {
 801a52c:	b580      	push	{r7, lr}
 801a52e:	b082      	sub	sp, #8
 801a530:	af00      	add	r7, sp, #0
 801a532:	6078      	str	r0, [r7, #4]
 801a534:	6039      	str	r1, [r7, #0]

  pcb->netif->mtu = mtu;
 801a536:	687b      	ldr	r3, [r7, #4]
 801a538:	6a1b      	ldr	r3, [r3, #32]
 801a53a:	683a      	ldr	r2, [r7, #0]
 801a53c:	b292      	uxth	r2, r2
 801a53e:	851a      	strh	r2, [r3, #40]	; 0x28
  PPPDEBUG(LOG_INFO, ("netif_set_mtu[%d]: mtu=%d\n", pcb->netif->num, mtu));
}
 801a540:	46c0      	nop			; (mov r8, r8)
 801a542:	46bd      	mov	sp, r7
 801a544:	b002      	add	sp, #8
 801a546:	bd80      	pop	{r7, pc}

0801a548 <pppos_create>:
 *
 * Return 0 on success, an error code on failure.
 */
ppp_pcb *pppos_create(struct netif *pppif, pppos_output_cb_fn output_cb,
       ppp_link_status_cb_fn link_status_cb, void *ctx_cb)
{
 801a548:	b590      	push	{r4, r7, lr}
 801a54a:	b089      	sub	sp, #36	; 0x24
 801a54c:	af02      	add	r7, sp, #8
 801a54e:	60f8      	str	r0, [r7, #12]
 801a550:	60b9      	str	r1, [r7, #8]
 801a552:	607a      	str	r2, [r7, #4]
 801a554:	603b      	str	r3, [r7, #0]
  pppos_pcb *pppos;
  ppp_pcb *ppp;
  LWIP_ASSERT_CORE_LOCKED();

  pppos = (pppos_pcb *)LWIP_MEMPOOL_ALLOC(PPPOS_PCB);
 801a556:	4b19      	ldr	r3, [pc, #100]	; (801a5bc <pppos_create+0x74>)
 801a558:	0018      	movs	r0, r3
 801a55a:	f7ee fd2d 	bl	8008fb8 <memp_malloc_pool>
 801a55e:	0003      	movs	r3, r0
 801a560:	617b      	str	r3, [r7, #20]
  if (pppos == NULL) {
 801a562:	697b      	ldr	r3, [r7, #20]
 801a564:	2b00      	cmp	r3, #0
 801a566:	d101      	bne.n	801a56c <pppos_create+0x24>
    return NULL;
 801a568:	2300      	movs	r3, #0
 801a56a:	e022      	b.n	801a5b2 <pppos_create+0x6a>
  }

  ppp = ppp_new(pppif, &pppos_callbacks, pppos, link_status_cb, ctx_cb);
 801a56c:	687c      	ldr	r4, [r7, #4]
 801a56e:	697a      	ldr	r2, [r7, #20]
 801a570:	4913      	ldr	r1, [pc, #76]	; (801a5c0 <pppos_create+0x78>)
 801a572:	68f8      	ldr	r0, [r7, #12]
 801a574:	683b      	ldr	r3, [r7, #0]
 801a576:	9300      	str	r3, [sp, #0]
 801a578:	0023      	movs	r3, r4
 801a57a:	f7ff fce3 	bl	8019f44 <ppp_new>
 801a57e:	0003      	movs	r3, r0
 801a580:	613b      	str	r3, [r7, #16]
  if (ppp == NULL) {
 801a582:	693b      	ldr	r3, [r7, #16]
 801a584:	2b00      	cmp	r3, #0
 801a586:	d107      	bne.n	801a598 <pppos_create+0x50>
    LWIP_MEMPOOL_FREE(PPPOS_PCB, pppos);
 801a588:	697a      	ldr	r2, [r7, #20]
 801a58a:	4b0c      	ldr	r3, [pc, #48]	; (801a5bc <pppos_create+0x74>)
 801a58c:	0011      	movs	r1, r2
 801a58e:	0018      	movs	r0, r3
 801a590:	f7ee fd7e 	bl	8009090 <memp_free_pool>
    return NULL;
 801a594:	2300      	movs	r3, #0
 801a596:	e00c      	b.n	801a5b2 <pppos_create+0x6a>
  }

  memset(pppos, 0, sizeof(pppos_pcb));
 801a598:	697b      	ldr	r3, [r7, #20]
 801a59a:	2260      	movs	r2, #96	; 0x60
 801a59c:	2100      	movs	r1, #0
 801a59e:	0018      	movs	r0, r3
 801a5a0:	f002 fcb0 	bl	801cf04 <memset>
  pppos->ppp = ppp;
 801a5a4:	697b      	ldr	r3, [r7, #20]
 801a5a6:	693a      	ldr	r2, [r7, #16]
 801a5a8:	601a      	str	r2, [r3, #0]
  pppos->output_cb = output_cb;
 801a5aa:	697b      	ldr	r3, [r7, #20]
 801a5ac:	68ba      	ldr	r2, [r7, #8]
 801a5ae:	605a      	str	r2, [r3, #4]
  return ppp;
 801a5b0:	693b      	ldr	r3, [r7, #16]
}
 801a5b2:	0018      	movs	r0, r3
 801a5b4:	46bd      	mov	sp, r7
 801a5b6:	b007      	add	sp, #28
 801a5b8:	bd90      	pop	{r4, r7, pc}
 801a5ba:	46c0      	nop			; (mov r8, r8)
 801a5bc:	08022b00 	.word	0x08022b00
 801a5c0:	08022b10 	.word	0x08022b10

0801a5c4 <pppos_write>:

/* Called by PPP core */
static err_t
pppos_write(ppp_pcb *ppp, void *ctx, struct pbuf *p)
{
 801a5c4:	b5f0      	push	{r4, r5, r6, r7, lr}
 801a5c6:	b08d      	sub	sp, #52	; 0x34
 801a5c8:	af02      	add	r7, sp, #8
 801a5ca:	60f8      	str	r0, [r7, #12]
 801a5cc:	60b9      	str	r1, [r7, #8]
 801a5ce:	607a      	str	r2, [r7, #4]
  pppos_pcb *pppos = (pppos_pcb *)ctx;
 801a5d0:	68bb      	ldr	r3, [r7, #8]
 801a5d2:	61fb      	str	r3, [r7, #28]
  LWIP_UNUSED_ARG(ppp);

  /* Grab an output buffer. Using PBUF_POOL here for tx is ok since the pbuf
     gets freed by 'pppos_output_last' before this function returns and thus
     cannot starve rx. */
  nb = pbuf_alloc(PBUF_RAW, 0, PBUF_POOL);
 801a5d4:	23c1      	movs	r3, #193	; 0xc1
 801a5d6:	005b      	lsls	r3, r3, #1
 801a5d8:	001a      	movs	r2, r3
 801a5da:	2100      	movs	r1, #0
 801a5dc:	2000      	movs	r0, #0
 801a5de:	f7ef f8f5 	bl	80097cc <pbuf_alloc>
 801a5e2:	0003      	movs	r3, r0
 801a5e4:	61bb      	str	r3, [r7, #24]
  if (nb == NULL) {
 801a5e6:	69bb      	ldr	r3, [r7, #24]
 801a5e8:	2b00      	cmp	r3, #0
 801a5ea:	d106      	bne.n	801a5fa <pppos_write+0x36>
    PPPDEBUG(LOG_WARNING, ("pppos_write[%d]: alloc fail\n", ppp->netif->num));
    LINK_STATS_INC(link.memerr);
    LINK_STATS_INC(link.drop);
    MIB2_STATS_NETIF_INC(ppp->netif, ifoutdiscards);
    pbuf_free(p);
 801a5ec:	687b      	ldr	r3, [r7, #4]
 801a5ee:	0018      	movs	r0, r3
 801a5f0:	f7ef fc64 	bl	8009ebc <pbuf_free>
    return ERR_MEM;
 801a5f4:	2301      	movs	r3, #1
 801a5f6:	425b      	negs	r3, r3
 801a5f8:	e05f      	b.n	801a6ba <pppos_write+0xf6>
  }

  /* Set nb->tot_len to actual payload length */
  nb->tot_len = p->len;
 801a5fa:	687b      	ldr	r3, [r7, #4]
 801a5fc:	895a      	ldrh	r2, [r3, #10]
 801a5fe:	69bb      	ldr	r3, [r7, #24]
 801a600:	811a      	strh	r2, [r3, #8]

  /* If the link has been idle, we'll send a fresh flag character to
   * flush any noise. */
  err = ERR_OK;
 801a602:	2421      	movs	r4, #33	; 0x21
 801a604:	193b      	adds	r3, r7, r4
 801a606:	2200      	movs	r2, #0
 801a608:	701a      	strb	r2, [r3, #0]
  if ((sys_now() - pppos->last_xmit) >= PPP_MAXIDLEFLAG) {
 801a60a:	f002 fc0d 	bl	801ce28 <sys_now>
 801a60e:	0002      	movs	r2, r0
 801a610:	69fb      	ldr	r3, [r7, #28]
 801a612:	689b      	ldr	r3, [r3, #8]
 801a614:	1ad3      	subs	r3, r2, r3
 801a616:	2b63      	cmp	r3, #99	; 0x63
 801a618:	d90f      	bls.n	801a63a <pppos_write+0x76>
    err = pppos_output_append(pppos, err,  nb, PPP_FLAG, 0, NULL);
 801a61a:	0023      	movs	r3, r4
 801a61c:	18fc      	adds	r4, r7, r3
 801a61e:	69ba      	ldr	r2, [r7, #24]
 801a620:	18fb      	adds	r3, r7, r3
 801a622:	2100      	movs	r1, #0
 801a624:	5659      	ldrsb	r1, [r3, r1]
 801a626:	69f8      	ldr	r0, [r7, #28]
 801a628:	2300      	movs	r3, #0
 801a62a:	9301      	str	r3, [sp, #4]
 801a62c:	2300      	movs	r3, #0
 801a62e:	9300      	str	r3, [sp, #0]
 801a630:	237e      	movs	r3, #126	; 0x7e
 801a632:	f000 fbe3 	bl	801adfc <pppos_output_append>
 801a636:	0003      	movs	r3, r0
 801a638:	7023      	strb	r3, [r4, #0]
  }

  /* Load output buffer. */
  fcs_out = PPP_INITFCS;
 801a63a:	2316      	movs	r3, #22
 801a63c:	18fb      	adds	r3, r7, r3
 801a63e:	2201      	movs	r2, #1
 801a640:	4252      	negs	r2, r2
 801a642:	801a      	strh	r2, [r3, #0]
  s = (u8_t*)p->payload;
 801a644:	687b      	ldr	r3, [r7, #4]
 801a646:	685b      	ldr	r3, [r3, #4]
 801a648:	627b      	str	r3, [r7, #36]	; 0x24
  n = p->len;
 801a64a:	2322      	movs	r3, #34	; 0x22
 801a64c:	18fb      	adds	r3, r7, r3
 801a64e:	687a      	ldr	r2, [r7, #4]
 801a650:	8952      	ldrh	r2, [r2, #10]
 801a652:	801a      	strh	r2, [r3, #0]
  while (n-- > 0) {
 801a654:	e014      	b.n	801a680 <pppos_write+0xbc>
    err = pppos_output_append(pppos, err,  nb, *s++, 1, &fcs_out);
 801a656:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a658:	1c5a      	adds	r2, r3, #1
 801a65a:	627a      	str	r2, [r7, #36]	; 0x24
 801a65c:	781d      	ldrb	r5, [r3, #0]
 801a65e:	2321      	movs	r3, #33	; 0x21
 801a660:	18fc      	adds	r4, r7, r3
 801a662:	69ba      	ldr	r2, [r7, #24]
 801a664:	18fb      	adds	r3, r7, r3
 801a666:	2100      	movs	r1, #0
 801a668:	5659      	ldrsb	r1, [r3, r1]
 801a66a:	69f8      	ldr	r0, [r7, #28]
 801a66c:	2316      	movs	r3, #22
 801a66e:	18fb      	adds	r3, r7, r3
 801a670:	9301      	str	r3, [sp, #4]
 801a672:	2301      	movs	r3, #1
 801a674:	9300      	str	r3, [sp, #0]
 801a676:	002b      	movs	r3, r5
 801a678:	f000 fbc0 	bl	801adfc <pppos_output_append>
 801a67c:	0003      	movs	r3, r0
 801a67e:	7023      	strb	r3, [r4, #0]
  while (n-- > 0) {
 801a680:	2222      	movs	r2, #34	; 0x22
 801a682:	18bb      	adds	r3, r7, r2
 801a684:	881b      	ldrh	r3, [r3, #0]
 801a686:	18ba      	adds	r2, r7, r2
 801a688:	1e59      	subs	r1, r3, #1
 801a68a:	8011      	strh	r1, [r2, #0]
 801a68c:	2b00      	cmp	r3, #0
 801a68e:	d1e2      	bne.n	801a656 <pppos_write+0x92>
  }

  err = pppos_output_last(pppos, err, nb, &fcs_out);
 801a690:	2621      	movs	r6, #33	; 0x21
 801a692:	19bc      	adds	r4, r7, r6
 801a694:	2316      	movs	r3, #22
 801a696:	18fd      	adds	r5, r7, r3
 801a698:	69ba      	ldr	r2, [r7, #24]
 801a69a:	19bb      	adds	r3, r7, r6
 801a69c:	2100      	movs	r1, #0
 801a69e:	5659      	ldrsb	r1, [r3, r1]
 801a6a0:	69f8      	ldr	r0, [r7, #28]
 801a6a2:	002b      	movs	r3, r5
 801a6a4:	f000 fc44 	bl	801af30 <pppos_output_last>
 801a6a8:	0003      	movs	r3, r0
 801a6aa:	7023      	strb	r3, [r4, #0]
  if (err == ERR_OK) {
    PPPDEBUG(LOG_INFO, ("pppos_write[%d]: len=%d\n", ppp->netif->num, p->len));
  } else {
    PPPDEBUG(LOG_WARNING, ("pppos_write[%d]: output failed len=%d\n", ppp->netif->num, p->len));
  }
  pbuf_free(p);
 801a6ac:	687b      	ldr	r3, [r7, #4]
 801a6ae:	0018      	movs	r0, r3
 801a6b0:	f7ef fc04 	bl	8009ebc <pbuf_free>
  return err;
 801a6b4:	19bb      	adds	r3, r7, r6
 801a6b6:	781b      	ldrb	r3, [r3, #0]
 801a6b8:	b25b      	sxtb	r3, r3
}
 801a6ba:	0018      	movs	r0, r3
 801a6bc:	46bd      	mov	sp, r7
 801a6be:	b00b      	add	sp, #44	; 0x2c
 801a6c0:	bdf0      	pop	{r4, r5, r6, r7, pc}

0801a6c2 <pppos_netif_output>:

/* Called by PPP core */
static err_t
pppos_netif_output(ppp_pcb *ppp, void *ctx, struct pbuf *pb, u16_t protocol)
{
 801a6c2:	b5f0      	push	{r4, r5, r6, r7, lr}
 801a6c4:	b08d      	sub	sp, #52	; 0x34
 801a6c6:	af02      	add	r7, sp, #8
 801a6c8:	60f8      	str	r0, [r7, #12]
 801a6ca:	60b9      	str	r1, [r7, #8]
 801a6cc:	607a      	str	r2, [r7, #4]
 801a6ce:	001a      	movs	r2, r3
 801a6d0:	1cbb      	adds	r3, r7, #2
 801a6d2:	801a      	strh	r2, [r3, #0]
  pppos_pcb *pppos = (pppos_pcb *)ctx;
 801a6d4:	68bb      	ldr	r3, [r7, #8]
 801a6d6:	61bb      	str	r3, [r7, #24]
  LWIP_UNUSED_ARG(ppp);

  /* Grab an output buffer. Using PBUF_POOL here for tx is ok since the pbuf
     gets freed by 'pppos_output_last' before this function returns and thus
     cannot starve rx. */
  nb = pbuf_alloc(PBUF_RAW, 0, PBUF_POOL);
 801a6d8:	23c1      	movs	r3, #193	; 0xc1
 801a6da:	005b      	lsls	r3, r3, #1
 801a6dc:	001a      	movs	r2, r3
 801a6de:	2100      	movs	r1, #0
 801a6e0:	2000      	movs	r0, #0
 801a6e2:	f7ef f873 	bl	80097cc <pbuf_alloc>
 801a6e6:	0003      	movs	r3, r0
 801a6e8:	617b      	str	r3, [r7, #20]
  if (nb == NULL) {
 801a6ea:	697b      	ldr	r3, [r7, #20]
 801a6ec:	2b00      	cmp	r3, #0
 801a6ee:	d102      	bne.n	801a6f6 <pppos_netif_output+0x34>
    PPPDEBUG(LOG_WARNING, ("pppos_netif_output[%d]: alloc fail\n", ppp->netif->num));
    LINK_STATS_INC(link.memerr);
    LINK_STATS_INC(link.drop);
    MIB2_STATS_NETIF_INC(ppp->netif, ifoutdiscards);
    return ERR_MEM;
 801a6f0:	2301      	movs	r3, #1
 801a6f2:	425b      	negs	r3, r3
 801a6f4:	e0c1      	b.n	801a87a <pppos_netif_output+0x1b8>
  }

  /* Set nb->tot_len to actual payload length */
  nb->tot_len = pb->tot_len;
 801a6f6:	687b      	ldr	r3, [r7, #4]
 801a6f8:	891a      	ldrh	r2, [r3, #8]
 801a6fa:	697b      	ldr	r3, [r7, #20]
 801a6fc:	811a      	strh	r2, [r3, #8]

  /* If the link has been idle, we'll send a fresh flag character to
   * flush any noise. */
  err = ERR_OK;
 801a6fe:	2423      	movs	r4, #35	; 0x23
 801a700:	193b      	adds	r3, r7, r4
 801a702:	2200      	movs	r2, #0
 801a704:	701a      	strb	r2, [r3, #0]
  if ((sys_now() - pppos->last_xmit) >= PPP_MAXIDLEFLAG) {
 801a706:	f002 fb8f 	bl	801ce28 <sys_now>
 801a70a:	0002      	movs	r2, r0
 801a70c:	69bb      	ldr	r3, [r7, #24]
 801a70e:	689b      	ldr	r3, [r3, #8]
 801a710:	1ad3      	subs	r3, r2, r3
 801a712:	2b63      	cmp	r3, #99	; 0x63
 801a714:	d90f      	bls.n	801a736 <pppos_netif_output+0x74>
    err = pppos_output_append(pppos, err,  nb, PPP_FLAG, 0, NULL);
 801a716:	0023      	movs	r3, r4
 801a718:	18fc      	adds	r4, r7, r3
 801a71a:	697a      	ldr	r2, [r7, #20]
 801a71c:	18fb      	adds	r3, r7, r3
 801a71e:	2100      	movs	r1, #0
 801a720:	5659      	ldrsb	r1, [r3, r1]
 801a722:	69b8      	ldr	r0, [r7, #24]
 801a724:	2300      	movs	r3, #0
 801a726:	9301      	str	r3, [sp, #4]
 801a728:	2300      	movs	r3, #0
 801a72a:	9300      	str	r3, [sp, #0]
 801a72c:	237e      	movs	r3, #126	; 0x7e
 801a72e:	f000 fb65 	bl	801adfc <pppos_output_append>
 801a732:	0003      	movs	r3, r0
 801a734:	7023      	strb	r3, [r4, #0]
  }

  fcs_out = PPP_INITFCS;
 801a736:	2612      	movs	r6, #18
 801a738:	19bb      	adds	r3, r7, r6
 801a73a:	2201      	movs	r2, #1
 801a73c:	4252      	negs	r2, r2
 801a73e:	801a      	strh	r2, [r3, #0]
  if (!pppos->accomp) {
 801a740:	69bb      	ldr	r3, [r7, #24]
 801a742:	222c      	movs	r2, #44	; 0x2c
 801a744:	5c9b      	ldrb	r3, [r3, r2]
 801a746:	2204      	movs	r2, #4
 801a748:	4013      	ands	r3, r2
 801a74a:	b2db      	uxtb	r3, r3
 801a74c:	2b00      	cmp	r3, #0
 801a74e:	d11e      	bne.n	801a78e <pppos_netif_output+0xcc>
    err = pppos_output_append(pppos, err,  nb, PPP_ALLSTATIONS, 1, &fcs_out);
 801a750:	2523      	movs	r5, #35	; 0x23
 801a752:	197c      	adds	r4, r7, r5
 801a754:	697a      	ldr	r2, [r7, #20]
 801a756:	197b      	adds	r3, r7, r5
 801a758:	2100      	movs	r1, #0
 801a75a:	5659      	ldrsb	r1, [r3, r1]
 801a75c:	69b8      	ldr	r0, [r7, #24]
 801a75e:	19bb      	adds	r3, r7, r6
 801a760:	9301      	str	r3, [sp, #4]
 801a762:	2301      	movs	r3, #1
 801a764:	9300      	str	r3, [sp, #0]
 801a766:	23ff      	movs	r3, #255	; 0xff
 801a768:	f000 fb48 	bl	801adfc <pppos_output_append>
 801a76c:	0003      	movs	r3, r0
 801a76e:	7023      	strb	r3, [r4, #0]
    err = pppos_output_append(pppos, err,  nb, PPP_UI, 1, &fcs_out);
 801a770:	197c      	adds	r4, r7, r5
 801a772:	697a      	ldr	r2, [r7, #20]
 801a774:	197b      	adds	r3, r7, r5
 801a776:	2100      	movs	r1, #0
 801a778:	5659      	ldrsb	r1, [r3, r1]
 801a77a:	69b8      	ldr	r0, [r7, #24]
 801a77c:	19bb      	adds	r3, r7, r6
 801a77e:	9301      	str	r3, [sp, #4]
 801a780:	2301      	movs	r3, #1
 801a782:	9300      	str	r3, [sp, #0]
 801a784:	2303      	movs	r3, #3
 801a786:	f000 fb39 	bl	801adfc <pppos_output_append>
 801a78a:	0003      	movs	r3, r0
 801a78c:	7023      	strb	r3, [r4, #0]
  }
  if (!pppos->pcomp || protocol > 0xFF) {
 801a78e:	69bb      	ldr	r3, [r7, #24]
 801a790:	222c      	movs	r2, #44	; 0x2c
 801a792:	5c9b      	ldrb	r3, [r3, r2]
 801a794:	2202      	movs	r2, #2
 801a796:	4013      	ands	r3, r2
 801a798:	b2db      	uxtb	r3, r3
 801a79a:	2b00      	cmp	r3, #0
 801a79c:	d003      	beq.n	801a7a6 <pppos_netif_output+0xe4>
 801a79e:	1cbb      	adds	r3, r7, #2
 801a7a0:	881b      	ldrh	r3, [r3, #0]
 801a7a2:	2bff      	cmp	r3, #255	; 0xff
 801a7a4:	d915      	bls.n	801a7d2 <pppos_netif_output+0x110>
    err = pppos_output_append(pppos, err,  nb, (protocol >> 8) & 0xFF, 1, &fcs_out);
 801a7a6:	1cbb      	adds	r3, r7, #2
 801a7a8:	881b      	ldrh	r3, [r3, #0]
 801a7aa:	0a1b      	lsrs	r3, r3, #8
 801a7ac:	b29b      	uxth	r3, r3
 801a7ae:	b2dd      	uxtb	r5, r3
 801a7b0:	2323      	movs	r3, #35	; 0x23
 801a7b2:	18fc      	adds	r4, r7, r3
 801a7b4:	697a      	ldr	r2, [r7, #20]
 801a7b6:	18fb      	adds	r3, r7, r3
 801a7b8:	2100      	movs	r1, #0
 801a7ba:	5659      	ldrsb	r1, [r3, r1]
 801a7bc:	69b8      	ldr	r0, [r7, #24]
 801a7be:	2312      	movs	r3, #18
 801a7c0:	18fb      	adds	r3, r7, r3
 801a7c2:	9301      	str	r3, [sp, #4]
 801a7c4:	2301      	movs	r3, #1
 801a7c6:	9300      	str	r3, [sp, #0]
 801a7c8:	002b      	movs	r3, r5
 801a7ca:	f000 fb17 	bl	801adfc <pppos_output_append>
 801a7ce:	0003      	movs	r3, r0
 801a7d0:	7023      	strb	r3, [r4, #0]
  }
  err = pppos_output_append(pppos, err,  nb, protocol & 0xFF, 1, &fcs_out);
 801a7d2:	1cbb      	adds	r3, r7, #2
 801a7d4:	881b      	ldrh	r3, [r3, #0]
 801a7d6:	b2dd      	uxtb	r5, r3
 801a7d8:	2323      	movs	r3, #35	; 0x23
 801a7da:	18fc      	adds	r4, r7, r3
 801a7dc:	697a      	ldr	r2, [r7, #20]
 801a7de:	18fb      	adds	r3, r7, r3
 801a7e0:	2100      	movs	r1, #0
 801a7e2:	5659      	ldrsb	r1, [r3, r1]
 801a7e4:	69b8      	ldr	r0, [r7, #24]
 801a7e6:	2312      	movs	r3, #18
 801a7e8:	18fb      	adds	r3, r7, r3
 801a7ea:	9301      	str	r3, [sp, #4]
 801a7ec:	2301      	movs	r3, #1
 801a7ee:	9300      	str	r3, [sp, #0]
 801a7f0:	002b      	movs	r3, r5
 801a7f2:	f000 fb03 	bl	801adfc <pppos_output_append>
 801a7f6:	0003      	movs	r3, r0
 801a7f8:	7023      	strb	r3, [r4, #0]

  /* Load packet. */
  for(p = pb; p; p = p->next) {
 801a7fa:	687b      	ldr	r3, [r7, #4]
 801a7fc:	627b      	str	r3, [r7, #36]	; 0x24
 801a7fe:	e028      	b.n	801a852 <pppos_netif_output+0x190>
    u16_t n = p->len;
 801a800:	2320      	movs	r3, #32
 801a802:	18fb      	adds	r3, r7, r3
 801a804:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801a806:	8952      	ldrh	r2, [r2, #10]
 801a808:	801a      	strh	r2, [r3, #0]
    u8_t *s = (u8_t*)p->payload;
 801a80a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a80c:	685b      	ldr	r3, [r3, #4]
 801a80e:	61fb      	str	r3, [r7, #28]

    while (n-- > 0) {
 801a810:	e014      	b.n	801a83c <pppos_netif_output+0x17a>
      err = pppos_output_append(pppos, err,  nb, *s++, 1, &fcs_out);
 801a812:	69fb      	ldr	r3, [r7, #28]
 801a814:	1c5a      	adds	r2, r3, #1
 801a816:	61fa      	str	r2, [r7, #28]
 801a818:	781d      	ldrb	r5, [r3, #0]
 801a81a:	2323      	movs	r3, #35	; 0x23
 801a81c:	18fc      	adds	r4, r7, r3
 801a81e:	697a      	ldr	r2, [r7, #20]
 801a820:	18fb      	adds	r3, r7, r3
 801a822:	2100      	movs	r1, #0
 801a824:	5659      	ldrsb	r1, [r3, r1]
 801a826:	69b8      	ldr	r0, [r7, #24]
 801a828:	2312      	movs	r3, #18
 801a82a:	18fb      	adds	r3, r7, r3
 801a82c:	9301      	str	r3, [sp, #4]
 801a82e:	2301      	movs	r3, #1
 801a830:	9300      	str	r3, [sp, #0]
 801a832:	002b      	movs	r3, r5
 801a834:	f000 fae2 	bl	801adfc <pppos_output_append>
 801a838:	0003      	movs	r3, r0
 801a83a:	7023      	strb	r3, [r4, #0]
    while (n-- > 0) {
 801a83c:	2220      	movs	r2, #32
 801a83e:	18bb      	adds	r3, r7, r2
 801a840:	881b      	ldrh	r3, [r3, #0]
 801a842:	18ba      	adds	r2, r7, r2
 801a844:	1e59      	subs	r1, r3, #1
 801a846:	8011      	strh	r1, [r2, #0]
 801a848:	2b00      	cmp	r3, #0
 801a84a:	d1e2      	bne.n	801a812 <pppos_netif_output+0x150>
  for(p = pb; p; p = p->next) {
 801a84c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a84e:	681b      	ldr	r3, [r3, #0]
 801a850:	627b      	str	r3, [r7, #36]	; 0x24
 801a852:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a854:	2b00      	cmp	r3, #0
 801a856:	d1d3      	bne.n	801a800 <pppos_netif_output+0x13e>
    }
  }

  err = pppos_output_last(pppos, err, nb, &fcs_out);
 801a858:	2623      	movs	r6, #35	; 0x23
 801a85a:	19bc      	adds	r4, r7, r6
 801a85c:	2312      	movs	r3, #18
 801a85e:	18fd      	adds	r5, r7, r3
 801a860:	697a      	ldr	r2, [r7, #20]
 801a862:	19bb      	adds	r3, r7, r6
 801a864:	2100      	movs	r1, #0
 801a866:	5659      	ldrsb	r1, [r3, r1]
 801a868:	69b8      	ldr	r0, [r7, #24]
 801a86a:	002b      	movs	r3, r5
 801a86c:	f000 fb60 	bl	801af30 <pppos_output_last>
 801a870:	0003      	movs	r3, r0
 801a872:	7023      	strb	r3, [r4, #0]
  if (err == ERR_OK) {
    PPPDEBUG(LOG_INFO, ("pppos_netif_output[%d]: proto=0x%"X16_F", len = %d\n", ppp->netif->num, protocol, pb->tot_len));
  } else {
    PPPDEBUG(LOG_WARNING, ("pppos_netif_output[%d]: output failed proto=0x%"X16_F", len = %d\n", ppp->netif->num, protocol, pb->tot_len));
  }
  return err;
 801a874:	19bb      	adds	r3, r7, r6
 801a876:	781b      	ldrb	r3, [r3, #0]
 801a878:	b25b      	sxtb	r3, r3
}
 801a87a:	0018      	movs	r0, r3
 801a87c:	46bd      	mov	sp, r7
 801a87e:	b00b      	add	sp, #44	; 0x2c
 801a880:	bdf0      	pop	{r4, r5, r6, r7, pc}

0801a882 <pppos_connect>:

static void
pppos_connect(ppp_pcb *ppp, void *ctx)
{
 801a882:	b580      	push	{r7, lr}
 801a884:	b084      	sub	sp, #16
 801a886:	af00      	add	r7, sp, #0
 801a888:	6078      	str	r0, [r7, #4]
 801a88a:	6039      	str	r1, [r7, #0]
  pppos_pcb *pppos = (pppos_pcb *)ctx;
 801a88c:	683b      	ldr	r3, [r7, #0]
 801a88e:	60fb      	str	r3, [r7, #12]
  /* input pbuf left over from last session? */
  pppos_input_free_current_packet(pppos);
#endif /* PPP_INPROC_IRQ_SAFE */

  /* reset PPPoS control block to its initial state */
  memset(&pppos->last_xmit, 0, sizeof(pppos_pcb) - offsetof(pppos_pcb, last_xmit));
 801a890:	68fb      	ldr	r3, [r7, #12]
 801a892:	3308      	adds	r3, #8
 801a894:	2258      	movs	r2, #88	; 0x58
 801a896:	2100      	movs	r1, #0
 801a898:	0018      	movs	r0, r3
 801a89a:	f002 fb33 	bl	801cf04 <memset>

  /*
   * Default the in and out accm so that escape and flag characters
   * are always escaped.
   */
  pppos->in_accm[15] = 0x60; /* no need to protect since RX is not running */
 801a89e:	68fb      	ldr	r3, [r7, #12]
 801a8a0:	223c      	movs	r2, #60	; 0x3c
 801a8a2:	2160      	movs	r1, #96	; 0x60
 801a8a4:	5499      	strb	r1, [r3, r2]
  pppos->out_accm[15] = 0x60;
 801a8a6:	68fb      	ldr	r3, [r7, #12]
 801a8a8:	2260      	movs	r2, #96	; 0x60
 801a8aa:	76da      	strb	r2, [r3, #27]
  PPPOS_PROTECT(lev);
  pppos->open = 1;
 801a8ac:	68fb      	ldr	r3, [r7, #12]
 801a8ae:	222c      	movs	r2, #44	; 0x2c
 801a8b0:	5c99      	ldrb	r1, [r3, r2]
 801a8b2:	2001      	movs	r0, #1
 801a8b4:	4301      	orrs	r1, r0
 801a8b6:	5499      	strb	r1, [r3, r2]

  /*
   * Start the connection and handle incoming events (packet or timeout).
   */
  PPPDEBUG(LOG_INFO, ("pppos_connect: unit %d: connecting\n", ppp->netif->num));
  ppp_start(ppp); /* notify upper layers */
 801a8b8:	687b      	ldr	r3, [r7, #4]
 801a8ba:	0018      	movs	r0, r3
 801a8bc:	f7ff fbc4 	bl	801a048 <ppp_start>
}
 801a8c0:	46c0      	nop			; (mov r8, r8)
 801a8c2:	46bd      	mov	sp, r7
 801a8c4:	b004      	add	sp, #16
 801a8c6:	bd80      	pop	{r7, pc}

0801a8c8 <pppos_disconnect>:
}
#endif /* PPP_SERVER */

static void
pppos_disconnect(ppp_pcb *ppp, void *ctx)
{
 801a8c8:	b580      	push	{r7, lr}
 801a8ca:	b084      	sub	sp, #16
 801a8cc:	af00      	add	r7, sp, #0
 801a8ce:	6078      	str	r0, [r7, #4]
 801a8d0:	6039      	str	r1, [r7, #0]
  pppos_pcb *pppos = (pppos_pcb *)ctx;
 801a8d2:	683b      	ldr	r3, [r7, #0]
 801a8d4:	60fb      	str	r3, [r7, #12]
  PPPOS_DECL_PROTECT(lev);

  PPPOS_PROTECT(lev);
  pppos->open = 0;
 801a8d6:	68fb      	ldr	r3, [r7, #12]
 801a8d8:	222c      	movs	r2, #44	; 0x2c
 801a8da:	5c99      	ldrb	r1, [r3, r2]
 801a8dc:	2001      	movs	r0, #1
 801a8de:	4381      	bics	r1, r0
 801a8e0:	5499      	strb	r1, [r3, r2]
   * pppos_input_free_current_packet() here because
   * rx IRQ might still call pppos_input().
   */
#if !PPP_INPROC_IRQ_SAFE
  /* input pbuf left ? */
  pppos_input_free_current_packet(pppos);
 801a8e2:	68fb      	ldr	r3, [r7, #12]
 801a8e4:	0018      	movs	r0, r3
 801a8e6:	f000 fa50 	bl	801ad8a <pppos_input_free_current_packet>
#endif /* !PPP_INPROC_IRQ_SAFE */

  ppp_link_end(ppp); /* notify upper layers */
 801a8ea:	687b      	ldr	r3, [r7, #4]
 801a8ec:	0018      	movs	r0, r3
 801a8ee:	f7ff fbc5 	bl	801a07c <ppp_link_end>
}
 801a8f2:	46c0      	nop			; (mov r8, r8)
 801a8f4:	46bd      	mov	sp, r7
 801a8f6:	b004      	add	sp, #16
 801a8f8:	bd80      	pop	{r7, pc}
	...

0801a8fc <pppos_destroy>:

static err_t
pppos_destroy(ppp_pcb *ppp, void *ctx)
{
 801a8fc:	b580      	push	{r7, lr}
 801a8fe:	b084      	sub	sp, #16
 801a900:	af00      	add	r7, sp, #0
 801a902:	6078      	str	r0, [r7, #4]
 801a904:	6039      	str	r1, [r7, #0]
  pppos_pcb *pppos = (pppos_pcb *)ctx;
 801a906:	683b      	ldr	r3, [r7, #0]
 801a908:	60fb      	str	r3, [r7, #12]
#if PPP_INPROC_IRQ_SAFE
  /* input pbuf left ? */
  pppos_input_free_current_packet(pppos);
#endif /* PPP_INPROC_IRQ_SAFE */

  LWIP_MEMPOOL_FREE(PPPOS_PCB, pppos);
 801a90a:	68fa      	ldr	r2, [r7, #12]
 801a90c:	4b04      	ldr	r3, [pc, #16]	; (801a920 <pppos_destroy+0x24>)
 801a90e:	0011      	movs	r1, r2
 801a910:	0018      	movs	r0, r3
 801a912:	f7ee fbbd 	bl	8009090 <memp_free_pool>
  return ERR_OK;
 801a916:	2300      	movs	r3, #0
}
 801a918:	0018      	movs	r0, r3
 801a91a:	46bd      	mov	sp, r7
 801a91c:	b004      	add	sp, #16
 801a91e:	bd80      	pop	{r7, pc}
 801a920:	08022b00 	.word	0x08022b00

0801a924 <pppos_input>:
 * @param s received data
 * @param l length of received data
 */
void
pppos_input(ppp_pcb *ppp, u8_t *s, int l)
{
 801a924:	b580      	push	{r7, lr}
 801a926:	b08a      	sub	sp, #40	; 0x28
 801a928:	af00      	add	r7, sp, #0
 801a92a:	60f8      	str	r0, [r7, #12]
 801a92c:	60b9      	str	r1, [r7, #8]
 801a92e:	607a      	str	r2, [r7, #4]
  pppos_pcb *pppos = (pppos_pcb *)ppp->link_ctx_cb;
 801a930:	68fb      	ldr	r3, [r7, #12]
 801a932:	691b      	ldr	r3, [r3, #16]
 801a934:	623b      	str	r3, [r7, #32]
#if !PPP_INPROC_IRQ_SAFE
  LWIP_ASSERT_CORE_LOCKED();
#endif

  PPPDEBUG(LOG_DEBUG, ("pppos_input[%d]: got %d bytes\n", ppp->netif->num, l));
  while (l-- > 0) {
 801a936:	e1ae      	b.n	801ac96 <pppos_input+0x372>
    cur_char = *s++;
 801a938:	68bb      	ldr	r3, [r7, #8]
 801a93a:	1c5a      	adds	r2, r3, #1
 801a93c:	60ba      	str	r2, [r7, #8]
 801a93e:	2027      	movs	r0, #39	; 0x27
 801a940:	183a      	adds	r2, r7, r0
 801a942:	781b      	ldrb	r3, [r3, #0]
 801a944:	7013      	strb	r3, [r2, #0]
    /* ppp_input can disconnect the interface, we need to abort to prevent a memory
     * leak if there are remaining bytes because pppos_connect and pppos_listen
     * functions expect input buffer to be free. Furthermore there are no real
     * reason to continue reading bytes if we are disconnected.
     */
    if (!pppos->open) {
 801a946:	6a3b      	ldr	r3, [r7, #32]
 801a948:	222c      	movs	r2, #44	; 0x2c
 801a94a:	5c9b      	ldrb	r3, [r3, r2]
 801a94c:	2201      	movs	r2, #1
 801a94e:	4013      	ands	r3, r2
 801a950:	b2db      	uxtb	r3, r3
 801a952:	2b00      	cmp	r3, #0
 801a954:	d100      	bne.n	801a958 <pppos_input+0x34>
 801a956:	e1a5      	b.n	801aca4 <pppos_input+0x380>
      PPPOS_UNPROTECT(lev);
      return;
    }
    escaped = ESCAPE_P(pppos->in_accm, cur_char);
 801a958:	183b      	adds	r3, r7, r0
 801a95a:	781b      	ldrb	r3, [r3, #0]
 801a95c:	08db      	lsrs	r3, r3, #3
 801a95e:	b2db      	uxtb	r3, r3
 801a960:	0019      	movs	r1, r3
 801a962:	6a3b      	ldr	r3, [r7, #32]
 801a964:	222d      	movs	r2, #45	; 0x2d
 801a966:	185b      	adds	r3, r3, r1
 801a968:	189b      	adds	r3, r3, r2
 801a96a:	781b      	ldrb	r3, [r3, #0]
 801a96c:	b25b      	sxtb	r3, r3
 801a96e:	183a      	adds	r2, r7, r0
 801a970:	7812      	ldrb	r2, [r2, #0]
 801a972:	2107      	movs	r1, #7
 801a974:	400a      	ands	r2, r1
 801a976:	2101      	movs	r1, #1
 801a978:	4091      	lsls	r1, r2
 801a97a:	000a      	movs	r2, r1
 801a97c:	b252      	sxtb	r2, r2
 801a97e:	4013      	ands	r3, r2
 801a980:	b25a      	sxtb	r2, r3
 801a982:	211f      	movs	r1, #31
 801a984:	187b      	adds	r3, r7, r1
 801a986:	701a      	strb	r2, [r3, #0]
    PPPOS_UNPROTECT(lev);
    /* Handle special characters. */
    if (escaped) {
 801a988:	187b      	adds	r3, r7, r1
 801a98a:	781b      	ldrb	r3, [r3, #0]
 801a98c:	2b00      	cmp	r3, #0
 801a98e:	d100      	bne.n	801a992 <pppos_input+0x6e>
 801a990:	e086      	b.n	801aaa0 <pppos_input+0x17c>
      /* Check for escape sequences. */
      /* XXX Note that this does not handle an escaped 0x5d character which
       * would appear as an escape character.  Since this is an ASCII ']'
       * and there is no reason that I know of to escape it, I won't complicate
       * the code to handle this case. GLL */
      if (cur_char == PPP_ESCAPE) {
 801a992:	183b      	adds	r3, r7, r0
 801a994:	781b      	ldrb	r3, [r3, #0]
 801a996:	2b7d      	cmp	r3, #125	; 0x7d
 801a998:	d104      	bne.n	801a9a4 <pppos_input+0x80>
        pppos->in_escaped = 1;
 801a99a:	6a3b      	ldr	r3, [r7, #32]
 801a99c:	225d      	movs	r2, #93	; 0x5d
 801a99e:	2101      	movs	r1, #1
 801a9a0:	5499      	strb	r1, [r3, r2]
 801a9a2:	e178      	b.n	801ac96 <pppos_input+0x372>
      /* Check for the flag character. */
      } else if (cur_char == PPP_FLAG) {
 801a9a4:	2327      	movs	r3, #39	; 0x27
 801a9a6:	18fb      	adds	r3, r7, r3
 801a9a8:	781b      	ldrb	r3, [r3, #0]
 801a9aa:	2b7e      	cmp	r3, #126	; 0x7e
 801a9ac:	d000      	beq.n	801a9b0 <pppos_input+0x8c>
 801a9ae:	e172      	b.n	801ac96 <pppos_input+0x372>
        /* If this is just an extra flag character, ignore it. */
        if (pppos->in_state <= PDADDRESS) {
 801a9b0:	6a3b      	ldr	r3, [r7, #32]
 801a9b2:	225c      	movs	r2, #92	; 0x5c
 801a9b4:	5c9b      	ldrb	r3, [r3, r2]
 801a9b6:	2b02      	cmp	r3, #2
 801a9b8:	d964      	bls.n	801aa84 <pppos_input+0x160>
          /* ignore it */;
        /* If we haven't received the packet header, drop what has come in. */
        } else if (pppos->in_state < PDDATA) {
 801a9ba:	6a3b      	ldr	r3, [r7, #32]
 801a9bc:	225c      	movs	r2, #92	; 0x5c
 801a9be:	5c9b      	ldrb	r3, [r3, r2]
 801a9c0:	2b05      	cmp	r3, #5
 801a9c2:	d804      	bhi.n	801a9ce <pppos_input+0xaa>
          PPPDEBUG(LOG_WARNING,
                   ("pppos_input[%d]: Dropping incomplete packet %d\n",
                    ppp->netif->num, pppos->in_state));
          LINK_STATS_INC(link.lenerr);
          pppos_input_drop(pppos);
 801a9c4:	6a3b      	ldr	r3, [r7, #32]
 801a9c6:	0018      	movs	r0, r3
 801a9c8:	f000 fa05 	bl	801add6 <pppos_input_drop>
 801a9cc:	e05a      	b.n	801aa84 <pppos_input+0x160>
        /* If the fcs is invalid, drop the packet. */
        } else if (pppos->in_fcs != PPP_GOODFCS) {
 801a9ce:	6a3b      	ldr	r3, [r7, #32]
 801a9d0:	225a      	movs	r2, #90	; 0x5a
 801a9d2:	5a9b      	ldrh	r3, [r3, r2]
 801a9d4:	4ab5      	ldr	r2, [pc, #724]	; (801acac <pppos_input+0x388>)
 801a9d6:	4293      	cmp	r3, r2
 801a9d8:	d004      	beq.n	801a9e4 <pppos_input+0xc0>
          PPPDEBUG(LOG_INFO,
                   ("pppos_input[%d]: Dropping bad fcs 0x%"X16_F" proto=0x%"X16_F"\n",
                    ppp->netif->num, pppos->in_fcs, pppos->in_protocol));
          /* Note: If you get lots of these, check for UART frame errors or try different baud rate */
          LINK_STATS_INC(link.chkerr);
          pppos_input_drop(pppos);
 801a9da:	6a3b      	ldr	r3, [r7, #32]
 801a9dc:	0018      	movs	r0, r3
 801a9de:	f000 f9fa 	bl	801add6 <pppos_input_drop>
 801a9e2:	e04f      	b.n	801aa84 <pppos_input+0x160>
        /* Otherwise it's a good packet so pass it on. */
        } else {
          struct pbuf *inp;
          /* Trim off the checksum. */
          if(pppos->in_tail->len > 2) {
 801a9e4:	6a3b      	ldr	r3, [r7, #32]
 801a9e6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a9e8:	895b      	ldrh	r3, [r3, #10]
 801a9ea:	2b02      	cmp	r3, #2
 801a9ec:	d91c      	bls.n	801aa28 <pppos_input+0x104>
            pppos->in_tail->len -= 2;
 801a9ee:	6a3b      	ldr	r3, [r7, #32]
 801a9f0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a9f2:	895a      	ldrh	r2, [r3, #10]
 801a9f4:	6a3b      	ldr	r3, [r7, #32]
 801a9f6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a9f8:	3a02      	subs	r2, #2
 801a9fa:	b292      	uxth	r2, r2
 801a9fc:	815a      	strh	r2, [r3, #10]

            pppos->in_tail->tot_len = pppos->in_tail->len;
 801a9fe:	6a3b      	ldr	r3, [r7, #32]
 801aa00:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801aa02:	6a3b      	ldr	r3, [r7, #32]
 801aa04:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801aa06:	8952      	ldrh	r2, [r2, #10]
 801aa08:	811a      	strh	r2, [r3, #8]
            if (pppos->in_tail != pppos->in_head) {
 801aa0a:	6a3b      	ldr	r3, [r7, #32]
 801aa0c:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801aa0e:	6a3b      	ldr	r3, [r7, #32]
 801aa10:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801aa12:	429a      	cmp	r2, r3
 801aa14:	d027      	beq.n	801aa66 <pppos_input+0x142>
              pbuf_cat(pppos->in_head, pppos->in_tail);
 801aa16:	6a3b      	ldr	r3, [r7, #32]
 801aa18:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 801aa1a:	6a3b      	ldr	r3, [r7, #32]
 801aa1c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801aa1e:	0019      	movs	r1, r3
 801aa20:	0010      	movs	r0, r2
 801aa22:	f7ef fb2b 	bl	800a07c <pbuf_cat>
 801aa26:	e01e      	b.n	801aa66 <pppos_input+0x142>
            }
          } else {
            pppos->in_tail->tot_len = pppos->in_tail->len;
 801aa28:	6a3b      	ldr	r3, [r7, #32]
 801aa2a:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801aa2c:	6a3b      	ldr	r3, [r7, #32]
 801aa2e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801aa30:	8952      	ldrh	r2, [r2, #10]
 801aa32:	811a      	strh	r2, [r3, #8]
            if (pppos->in_tail != pppos->in_head) {
 801aa34:	6a3b      	ldr	r3, [r7, #32]
 801aa36:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801aa38:	6a3b      	ldr	r3, [r7, #32]
 801aa3a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801aa3c:	429a      	cmp	r2, r3
 801aa3e:	d007      	beq.n	801aa50 <pppos_input+0x12c>
              pbuf_cat(pppos->in_head, pppos->in_tail);
 801aa40:	6a3b      	ldr	r3, [r7, #32]
 801aa42:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 801aa44:	6a3b      	ldr	r3, [r7, #32]
 801aa46:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801aa48:	0019      	movs	r1, r3
 801aa4a:	0010      	movs	r0, r2
 801aa4c:	f7ef fb16 	bl	800a07c <pbuf_cat>
            }

            pbuf_realloc(pppos->in_head, pppos->in_head->tot_len - 2);
 801aa50:	6a3b      	ldr	r3, [r7, #32]
 801aa52:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 801aa54:	6a3b      	ldr	r3, [r7, #32]
 801aa56:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801aa58:	891b      	ldrh	r3, [r3, #8]
 801aa5a:	3b02      	subs	r3, #2
 801aa5c:	b29b      	uxth	r3, r3
 801aa5e:	0019      	movs	r1, r3
 801aa60:	0010      	movs	r0, r2
 801aa62:	f7ef f831 	bl	8009ac8 <pbuf_realloc>
          }

          /* Dispatch the packet thereby consuming it. */
          inp = pppos->in_head;
 801aa66:	6a3b      	ldr	r3, [r7, #32]
 801aa68:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801aa6a:	613b      	str	r3, [r7, #16]
          /* Packet consumed, release our references. */
          pppos->in_head = NULL;
 801aa6c:	6a3b      	ldr	r3, [r7, #32]
 801aa6e:	2200      	movs	r2, #0
 801aa70:	651a      	str	r2, [r3, #80]	; 0x50
          pppos->in_tail = NULL;
 801aa72:	6a3b      	ldr	r3, [r7, #32]
 801aa74:	2200      	movs	r2, #0
 801aa76:	655a      	str	r2, [r3, #84]	; 0x54
            pbuf_free(inp);
            LINK_STATS_INC(link.drop);
            MIB2_STATS_NETIF_INC(ppp->netif, ifindiscards);
          }
#else /* PPP_INPROC_IRQ_SAFE */
          ppp_input(ppp, inp);
 801aa78:	693a      	ldr	r2, [r7, #16]
 801aa7a:	68fb      	ldr	r3, [r7, #12]
 801aa7c:	0011      	movs	r1, r2
 801aa7e:	0018      	movs	r0, r3
 801aa80:	f7ff fb1e 	bl	801a0c0 <ppp_input>
#endif /* PPP_INPROC_IRQ_SAFE */
        }

        /* Prepare for a new packet. */
        pppos->in_fcs = PPP_INITFCS;
 801aa84:	6a3b      	ldr	r3, [r7, #32]
 801aa86:	225a      	movs	r2, #90	; 0x5a
 801aa88:	2101      	movs	r1, #1
 801aa8a:	4249      	negs	r1, r1
 801aa8c:	5299      	strh	r1, [r3, r2]
        pppos->in_state = PDADDRESS;
 801aa8e:	6a3b      	ldr	r3, [r7, #32]
 801aa90:	225c      	movs	r2, #92	; 0x5c
 801aa92:	2102      	movs	r1, #2
 801aa94:	5499      	strb	r1, [r3, r2]
        pppos->in_escaped = 0;
 801aa96:	6a3b      	ldr	r3, [r7, #32]
 801aa98:	225d      	movs	r2, #93	; 0x5d
 801aa9a:	2100      	movs	r1, #0
 801aa9c:	5499      	strb	r1, [r3, r2]
 801aa9e:	e0fa      	b.n	801ac96 <pppos_input+0x372>
                 ("pppos_input[%d]: Dropping ACCM char <%d>\n", ppp->netif->num, cur_char));
      }
    /* Process other characters. */
    } else {
      /* Unencode escaped characters. */
      if (pppos->in_escaped) {
 801aaa0:	6a3b      	ldr	r3, [r7, #32]
 801aaa2:	225d      	movs	r2, #93	; 0x5d
 801aaa4:	5c9b      	ldrb	r3, [r3, r2]
 801aaa6:	2b00      	cmp	r3, #0
 801aaa8:	d00a      	beq.n	801aac0 <pppos_input+0x19c>
        pppos->in_escaped = 0;
 801aaaa:	6a3b      	ldr	r3, [r7, #32]
 801aaac:	225d      	movs	r2, #93	; 0x5d
 801aaae:	2100      	movs	r1, #0
 801aab0:	5499      	strb	r1, [r3, r2]
        cur_char ^= PPP_TRANS;
 801aab2:	2227      	movs	r2, #39	; 0x27
 801aab4:	18bb      	adds	r3, r7, r2
 801aab6:	18ba      	adds	r2, r7, r2
 801aab8:	7812      	ldrb	r2, [r2, #0]
 801aaba:	2120      	movs	r1, #32
 801aabc:	404a      	eors	r2, r1
 801aabe:	701a      	strb	r2, [r3, #0]
      }

      /* Process character relative to current state. */
      switch(pppos->in_state) {
 801aac0:	6a3b      	ldr	r3, [r7, #32]
 801aac2:	225c      	movs	r2, #92	; 0x5c
 801aac4:	5c9b      	ldrb	r3, [r3, r2]
 801aac6:	2b06      	cmp	r3, #6
 801aac8:	d900      	bls.n	801aacc <pppos_input+0x1a8>
 801aaca:	e0ca      	b.n	801ac62 <pppos_input+0x33e>
 801aacc:	009a      	lsls	r2, r3, #2
 801aace:	4b78      	ldr	r3, [pc, #480]	; (801acb0 <pppos_input+0x38c>)
 801aad0:	18d3      	adds	r3, r2, r3
 801aad2:	681b      	ldr	r3, [r3, #0]
 801aad4:	469f      	mov	pc, r3
        case PDIDLE:                    /* Idle state - waiting. */
          /* Drop the character if it's not 0xff
           * we would have processed a flag character above. */
          if (cur_char != PPP_ALLSTATIONS) {
 801aad6:	2327      	movs	r3, #39	; 0x27
 801aad8:	18fb      	adds	r3, r7, r3
 801aada:	781b      	ldrb	r3, [r3, #0]
 801aadc:	2bff      	cmp	r3, #255	; 0xff
 801aade:	d000      	beq.n	801aae2 <pppos_input+0x1be>
 801aae0:	e0c1      	b.n	801ac66 <pppos_input+0x342>
          /* no break */
          /* Fall through */

        case PDSTART:                   /* Process start flag. */
          /* Prepare for a new packet. */
          pppos->in_fcs = PPP_INITFCS;
 801aae2:	6a3b      	ldr	r3, [r7, #32]
 801aae4:	225a      	movs	r2, #90	; 0x5a
 801aae6:	2101      	movs	r1, #1
 801aae8:	4249      	negs	r1, r1
 801aaea:	5299      	strh	r1, [r3, r2]
          /* no break */
          /* Fall through */

        case PDADDRESS:                 /* Process address field. */
          if (cur_char == PPP_ALLSTATIONS) {
 801aaec:	2327      	movs	r3, #39	; 0x27
 801aaee:	18fb      	adds	r3, r7, r3
 801aaf0:	781b      	ldrb	r3, [r3, #0]
 801aaf2:	2bff      	cmp	r3, #255	; 0xff
 801aaf4:	d104      	bne.n	801ab00 <pppos_input+0x1dc>
            pppos->in_state = PDCONTROL;
 801aaf6:	6a3b      	ldr	r3, [r7, #32]
 801aaf8:	225c      	movs	r2, #92	; 0x5c
 801aafa:	2103      	movs	r1, #3
 801aafc:	5499      	strb	r1, [r3, r2]
            break;
 801aafe:	e0b3      	b.n	801ac68 <pppos_input+0x344>
          /* Else assume compressed address and control fields so
           * fall through to get the protocol... */
          /* Fall through */
        case PDCONTROL:                 /* Process control field. */
          /* If we don't get a valid control code, restart. */
          if (cur_char == PPP_UI) {
 801ab00:	2327      	movs	r3, #39	; 0x27
 801ab02:	18fb      	adds	r3, r7, r3
 801ab04:	781b      	ldrb	r3, [r3, #0]
 801ab06:	2b03      	cmp	r3, #3
 801ab08:	d104      	bne.n	801ab14 <pppos_input+0x1f0>
            pppos->in_state = PDPROTOCOL1;
 801ab0a:	6a3b      	ldr	r3, [r7, #32]
 801ab0c:	225c      	movs	r2, #92	; 0x5c
 801ab0e:	2104      	movs	r1, #4
 801ab10:	5499      	strb	r1, [r3, r2]
            break;
 801ab12:	e0a9      	b.n	801ac68 <pppos_input+0x344>
          /* Fall through */

      case PDPROTOCOL1:               /* Process protocol field 1. */
          /* If the lower bit is set, this is the end of the protocol
           * field. */
          if (cur_char & 1) {
 801ab14:	2127      	movs	r1, #39	; 0x27
 801ab16:	187b      	adds	r3, r7, r1
 801ab18:	781b      	ldrb	r3, [r3, #0]
 801ab1a:	2201      	movs	r2, #1
 801ab1c:	4013      	ands	r3, r2
 801ab1e:	d00a      	beq.n	801ab36 <pppos_input+0x212>
            pppos->in_protocol = cur_char;
 801ab20:	187b      	adds	r3, r7, r1
 801ab22:	781b      	ldrb	r3, [r3, #0]
 801ab24:	b299      	uxth	r1, r3
 801ab26:	6a3b      	ldr	r3, [r7, #32]
 801ab28:	2258      	movs	r2, #88	; 0x58
 801ab2a:	5299      	strh	r1, [r3, r2]
            pppos->in_state = PDDATA;
 801ab2c:	6a3b      	ldr	r3, [r7, #32]
 801ab2e:	225c      	movs	r2, #92	; 0x5c
 801ab30:	2106      	movs	r1, #6
 801ab32:	5499      	strb	r1, [r3, r2]
          } else {
            pppos->in_protocol = (u16_t)cur_char << 8;
            pppos->in_state = PDPROTOCOL2;
          }
          break;
 801ab34:	e098      	b.n	801ac68 <pppos_input+0x344>
            pppos->in_protocol = (u16_t)cur_char << 8;
 801ab36:	2327      	movs	r3, #39	; 0x27
 801ab38:	18fb      	adds	r3, r7, r3
 801ab3a:	781b      	ldrb	r3, [r3, #0]
 801ab3c:	b29b      	uxth	r3, r3
 801ab3e:	021b      	lsls	r3, r3, #8
 801ab40:	b299      	uxth	r1, r3
 801ab42:	6a3b      	ldr	r3, [r7, #32]
 801ab44:	2258      	movs	r2, #88	; 0x58
 801ab46:	5299      	strh	r1, [r3, r2]
            pppos->in_state = PDPROTOCOL2;
 801ab48:	6a3b      	ldr	r3, [r7, #32]
 801ab4a:	225c      	movs	r2, #92	; 0x5c
 801ab4c:	2105      	movs	r1, #5
 801ab4e:	5499      	strb	r1, [r3, r2]
          break;
 801ab50:	e08a      	b.n	801ac68 <pppos_input+0x344>
        case PDPROTOCOL2:               /* Process protocol field 2. */
          pppos->in_protocol |= cur_char;
 801ab52:	6a3b      	ldr	r3, [r7, #32]
 801ab54:	2258      	movs	r2, #88	; 0x58
 801ab56:	5a9a      	ldrh	r2, [r3, r2]
 801ab58:	2327      	movs	r3, #39	; 0x27
 801ab5a:	18fb      	adds	r3, r7, r3
 801ab5c:	781b      	ldrb	r3, [r3, #0]
 801ab5e:	b29b      	uxth	r3, r3
 801ab60:	4313      	orrs	r3, r2
 801ab62:	b299      	uxth	r1, r3
 801ab64:	6a3b      	ldr	r3, [r7, #32]
 801ab66:	2258      	movs	r2, #88	; 0x58
 801ab68:	5299      	strh	r1, [r3, r2]
          pppos->in_state = PDDATA;
 801ab6a:	6a3b      	ldr	r3, [r7, #32]
 801ab6c:	225c      	movs	r2, #92	; 0x5c
 801ab6e:	2106      	movs	r1, #6
 801ab70:	5499      	strb	r1, [r3, r2]
          break;
 801ab72:	e079      	b.n	801ac68 <pppos_input+0x344>
        case PDDATA:                    /* Process data byte. */
          /* Make space to receive processed data. */
          if (pppos->in_tail == NULL || pppos->in_tail->len == PBUF_POOL_BUFSIZE) {
 801ab74:	6a3b      	ldr	r3, [r7, #32]
 801ab76:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801ab78:	2b00      	cmp	r3, #0
 801ab7a:	d006      	beq.n	801ab8a <pppos_input+0x266>
 801ab7c:	6a3b      	ldr	r3, [r7, #32]
 801ab7e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801ab80:	895a      	ldrh	r2, [r3, #10]
 801ab82:	2394      	movs	r3, #148	; 0x94
 801ab84:	009b      	lsls	r3, r3, #2
 801ab86:	429a      	cmp	r2, r3
 801ab88:	d15b      	bne.n	801ac42 <pppos_input+0x31e>
            u16_t pbuf_alloc_len;
            if (pppos->in_tail != NULL) {
 801ab8a:	6a3b      	ldr	r3, [r7, #32]
 801ab8c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801ab8e:	2b00      	cmp	r3, #0
 801ab90:	d016      	beq.n	801abc0 <pppos_input+0x29c>
              pppos->in_tail->tot_len = pppos->in_tail->len;
 801ab92:	6a3b      	ldr	r3, [r7, #32]
 801ab94:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801ab96:	6a3b      	ldr	r3, [r7, #32]
 801ab98:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801ab9a:	8952      	ldrh	r2, [r2, #10]
 801ab9c:	811a      	strh	r2, [r3, #8]
              if (pppos->in_tail != pppos->in_head) {
 801ab9e:	6a3b      	ldr	r3, [r7, #32]
 801aba0:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801aba2:	6a3b      	ldr	r3, [r7, #32]
 801aba4:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801aba6:	429a      	cmp	r2, r3
 801aba8:	d00a      	beq.n	801abc0 <pppos_input+0x29c>
                pbuf_cat(pppos->in_head, pppos->in_tail);
 801abaa:	6a3b      	ldr	r3, [r7, #32]
 801abac:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 801abae:	6a3b      	ldr	r3, [r7, #32]
 801abb0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801abb2:	0019      	movs	r1, r3
 801abb4:	0010      	movs	r0, r2
 801abb6:	f7ef fa61 	bl	800a07c <pbuf_cat>
                /* give up the in_tail reference now */
                pppos->in_tail = NULL;
 801abba:	6a3b      	ldr	r3, [r7, #32]
 801abbc:	2200      	movs	r2, #0
 801abbe:	655a      	str	r2, [r3, #84]	; 0x54
              }
            }
            /* If we haven't started a packet, we need a packet header. */
            pbuf_alloc_len = 0;
 801abc0:	211c      	movs	r1, #28
 801abc2:	187b      	adds	r3, r7, r1
 801abc4:	2200      	movs	r2, #0
 801abc6:	801a      	strh	r2, [r3, #0]
             */
            if (pppos->in_head == NULL) {
              pbuf_alloc_len = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN;
            }
#endif /* IP_FORWARD || LWIP_IPV6_FORWARD */
            next_pbuf = pbuf_alloc(PBUF_RAW, pbuf_alloc_len, PBUF_POOL);
 801abc8:	23c1      	movs	r3, #193	; 0xc1
 801abca:	005a      	lsls	r2, r3, #1
 801abcc:	187b      	adds	r3, r7, r1
 801abce:	881b      	ldrh	r3, [r3, #0]
 801abd0:	0019      	movs	r1, r3
 801abd2:	2000      	movs	r0, #0
 801abd4:	f7ee fdfa 	bl	80097cc <pbuf_alloc>
 801abd8:	0003      	movs	r3, r0
 801abda:	61bb      	str	r3, [r7, #24]
            if (next_pbuf == NULL) {
 801abdc:	69bb      	ldr	r3, [r7, #24]
 801abde:	2b00      	cmp	r3, #0
 801abe0:	d108      	bne.n	801abf4 <pppos_input+0x2d0>
              /* No free buffers.  Drop the input packet and let the
               * higher layers deal with it.  Continue processing
               * the received pbuf chain in case a new packet starts. */
              PPPDEBUG(LOG_ERR, ("pppos_input[%d]: NO FREE PBUFS!\n", ppp->netif->num));
              LINK_STATS_INC(link.memerr);
              pppos_input_drop(pppos);
 801abe2:	6a3b      	ldr	r3, [r7, #32]
 801abe4:	0018      	movs	r0, r3
 801abe6:	f000 f8f6 	bl	801add6 <pppos_input_drop>
              pppos->in_state = PDSTART;  /* Wait for flag sequence. */
 801abea:	6a3b      	ldr	r3, [r7, #32]
 801abec:	225c      	movs	r2, #92	; 0x5c
 801abee:	2101      	movs	r1, #1
 801abf0:	5499      	strb	r1, [r3, r2]
              break;
 801abf2:	e039      	b.n	801ac68 <pppos_input+0x344>
            }
            if (pppos->in_head == NULL) {
 801abf4:	6a3b      	ldr	r3, [r7, #32]
 801abf6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801abf8:	2b00      	cmp	r3, #0
 801abfa:	d11f      	bne.n	801ac3c <pppos_input+0x318>
              u8_t *payload = ((u8_t*)next_pbuf->payload) + pbuf_alloc_len;
 801abfc:	69bb      	ldr	r3, [r7, #24]
 801abfe:	685a      	ldr	r2, [r3, #4]
 801ac00:	231c      	movs	r3, #28
 801ac02:	18fb      	adds	r3, r7, r3
 801ac04:	881b      	ldrh	r3, [r3, #0]
 801ac06:	18d3      	adds	r3, r2, r3
 801ac08:	617b      	str	r3, [r7, #20]
#if PPP_INPROC_IRQ_SAFE
              ((struct pppos_input_header*)payload)->ppp = ppp;
              payload += sizeof(struct pppos_input_header);
              next_pbuf->len += sizeof(struct pppos_input_header);
#endif /* PPP_INPROC_IRQ_SAFE */
              next_pbuf->len += sizeof(pppos->in_protocol);
 801ac0a:	69bb      	ldr	r3, [r7, #24]
 801ac0c:	895b      	ldrh	r3, [r3, #10]
 801ac0e:	3302      	adds	r3, #2
 801ac10:	b29a      	uxth	r2, r3
 801ac12:	69bb      	ldr	r3, [r7, #24]
 801ac14:	815a      	strh	r2, [r3, #10]
              *(payload++) = pppos->in_protocol >> 8;
 801ac16:	6a3b      	ldr	r3, [r7, #32]
 801ac18:	2258      	movs	r2, #88	; 0x58
 801ac1a:	5a9b      	ldrh	r3, [r3, r2]
 801ac1c:	0a1b      	lsrs	r3, r3, #8
 801ac1e:	b299      	uxth	r1, r3
 801ac20:	697b      	ldr	r3, [r7, #20]
 801ac22:	1c5a      	adds	r2, r3, #1
 801ac24:	617a      	str	r2, [r7, #20]
 801ac26:	b2ca      	uxtb	r2, r1
 801ac28:	701a      	strb	r2, [r3, #0]
              *(payload) = pppos->in_protocol & 0xFF;
 801ac2a:	6a3b      	ldr	r3, [r7, #32]
 801ac2c:	2258      	movs	r2, #88	; 0x58
 801ac2e:	5a9b      	ldrh	r3, [r3, r2]
 801ac30:	b2da      	uxtb	r2, r3
 801ac32:	697b      	ldr	r3, [r7, #20]
 801ac34:	701a      	strb	r2, [r3, #0]
              pppos->in_head = next_pbuf;
 801ac36:	6a3b      	ldr	r3, [r7, #32]
 801ac38:	69ba      	ldr	r2, [r7, #24]
 801ac3a:	651a      	str	r2, [r3, #80]	; 0x50
            }
            pppos->in_tail = next_pbuf;
 801ac3c:	6a3b      	ldr	r3, [r7, #32]
 801ac3e:	69ba      	ldr	r2, [r7, #24]
 801ac40:	655a      	str	r2, [r3, #84]	; 0x54
          }
          /* Load character into buffer. */
          ((u8_t*)pppos->in_tail->payload)[pppos->in_tail->len++] = cur_char;
 801ac42:	6a3b      	ldr	r3, [r7, #32]
 801ac44:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801ac46:	6859      	ldr	r1, [r3, #4]
 801ac48:	6a3b      	ldr	r3, [r7, #32]
 801ac4a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801ac4c:	895a      	ldrh	r2, [r3, #10]
 801ac4e:	1c50      	adds	r0, r2, #1
 801ac50:	b280      	uxth	r0, r0
 801ac52:	8158      	strh	r0, [r3, #10]
 801ac54:	0013      	movs	r3, r2
 801ac56:	18cb      	adds	r3, r1, r3
 801ac58:	2227      	movs	r2, #39	; 0x27
 801ac5a:	18ba      	adds	r2, r7, r2
 801ac5c:	7812      	ldrb	r2, [r2, #0]
 801ac5e:	701a      	strb	r2, [r3, #0]
          break;
 801ac60:	e002      	b.n	801ac68 <pppos_input+0x344>
        default:
          break;
 801ac62:	46c0      	nop			; (mov r8, r8)
 801ac64:	e000      	b.n	801ac68 <pppos_input+0x344>
            break;
 801ac66:	46c0      	nop			; (mov r8, r8)
      }

      /* update the frame check sequence number. */
      pppos->in_fcs = PPP_FCS(pppos->in_fcs, cur_char);
 801ac68:	6a3b      	ldr	r3, [r7, #32]
 801ac6a:	225a      	movs	r2, #90	; 0x5a
 801ac6c:	5a9b      	ldrh	r3, [r3, r2]
 801ac6e:	0a1b      	lsrs	r3, r3, #8
 801ac70:	b29a      	uxth	r2, r3
 801ac72:	6a3b      	ldr	r3, [r7, #32]
 801ac74:	215a      	movs	r1, #90	; 0x5a
 801ac76:	5a5b      	ldrh	r3, [r3, r1]
 801ac78:	0019      	movs	r1, r3
 801ac7a:	2327      	movs	r3, #39	; 0x27
 801ac7c:	18fb      	adds	r3, r7, r3
 801ac7e:	781b      	ldrb	r3, [r3, #0]
 801ac80:	404b      	eors	r3, r1
 801ac82:	21ff      	movs	r1, #255	; 0xff
 801ac84:	4019      	ands	r1, r3
 801ac86:	4b0b      	ldr	r3, [pc, #44]	; (801acb4 <pppos_input+0x390>)
 801ac88:	0049      	lsls	r1, r1, #1
 801ac8a:	5acb      	ldrh	r3, [r1, r3]
 801ac8c:	4053      	eors	r3, r2
 801ac8e:	b299      	uxth	r1, r3
 801ac90:	6a3b      	ldr	r3, [r7, #32]
 801ac92:	225a      	movs	r2, #90	; 0x5a
 801ac94:	5299      	strh	r1, [r3, r2]
  while (l-- > 0) {
 801ac96:	687b      	ldr	r3, [r7, #4]
 801ac98:	1e5a      	subs	r2, r3, #1
 801ac9a:	607a      	str	r2, [r7, #4]
 801ac9c:	2b00      	cmp	r3, #0
 801ac9e:	dd00      	ble.n	801aca2 <pppos_input+0x37e>
 801aca0:	e64a      	b.n	801a938 <pppos_input+0x14>
 801aca2:	e000      	b.n	801aca6 <pppos_input+0x382>
      return;
 801aca4:	46c0      	nop			; (mov r8, r8)
    }
  } /* while (l-- > 0), all bytes processed */
}
 801aca6:	46bd      	mov	sp, r7
 801aca8:	b00a      	add	sp, #40	; 0x28
 801acaa:	bd80      	pop	{r7, pc}
 801acac:	0000f0b8 	.word	0x0000f0b8
 801acb0:	08022d2c 	.word	0x08022d2c
 801acb4:	08022b2c 	.word	0x08022b2c

0801acb8 <pppos_send_config>:
}
#endif /* PPP_INPROC_IRQ_SAFE */

static void
pppos_send_config(ppp_pcb *ppp, void *ctx, u32_t accm, int pcomp, int accomp)
{
 801acb8:	b590      	push	{r4, r7, lr}
 801acba:	b087      	sub	sp, #28
 801acbc:	af00      	add	r7, sp, #0
 801acbe:	60f8      	str	r0, [r7, #12]
 801acc0:	60b9      	str	r1, [r7, #8]
 801acc2:	607a      	str	r2, [r7, #4]
 801acc4:	603b      	str	r3, [r7, #0]
  int i;
  pppos_pcb *pppos = (pppos_pcb *)ctx;
 801acc6:	68bb      	ldr	r3, [r7, #8]
 801acc8:	613b      	str	r3, [r7, #16]
  LWIP_UNUSED_ARG(ppp);

  pppos->pcomp = pcomp;
 801acca:	683b      	ldr	r3, [r7, #0]
 801accc:	1c1a      	adds	r2, r3, #0
 801acce:	2301      	movs	r3, #1
 801acd0:	4013      	ands	r3, r2
 801acd2:	b2d9      	uxtb	r1, r3
 801acd4:	693b      	ldr	r3, [r7, #16]
 801acd6:	222c      	movs	r2, #44	; 0x2c
 801acd8:	2001      	movs	r0, #1
 801acda:	4001      	ands	r1, r0
 801acdc:	184c      	adds	r4, r1, r1
 801acde:	5c99      	ldrb	r1, [r3, r2]
 801ace0:	2002      	movs	r0, #2
 801ace2:	4381      	bics	r1, r0
 801ace4:	1c08      	adds	r0, r1, #0
 801ace6:	1c21      	adds	r1, r4, #0
 801ace8:	4301      	orrs	r1, r0
 801acea:	5499      	strb	r1, [r3, r2]
  pppos->accomp = accomp;
 801acec:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801acee:	1c1a      	adds	r2, r3, #0
 801acf0:	2301      	movs	r3, #1
 801acf2:	4013      	ands	r3, r2
 801acf4:	b2d9      	uxtb	r1, r3
 801acf6:	693b      	ldr	r3, [r7, #16]
 801acf8:	222c      	movs	r2, #44	; 0x2c
 801acfa:	2001      	movs	r0, #1
 801acfc:	4001      	ands	r1, r0
 801acfe:	008c      	lsls	r4, r1, #2
 801ad00:	5c99      	ldrb	r1, [r3, r2]
 801ad02:	2004      	movs	r0, #4
 801ad04:	4381      	bics	r1, r0
 801ad06:	1c08      	adds	r0, r1, #0
 801ad08:	1c21      	adds	r1, r4, #0
 801ad0a:	4301      	orrs	r1, r0
 801ad0c:	5499      	strb	r1, [r3, r2]

  /* Load the ACCM bits for the 32 control codes. */
  for (i = 0; i < 32/8; i++) {
 801ad0e:	2300      	movs	r3, #0
 801ad10:	617b      	str	r3, [r7, #20]
 801ad12:	e00e      	b.n	801ad32 <pppos_send_config+0x7a>
    pppos->out_accm[i] = (u8_t)((accm >> (8 * i)) & 0xFF);
 801ad14:	697b      	ldr	r3, [r7, #20]
 801ad16:	00db      	lsls	r3, r3, #3
 801ad18:	687a      	ldr	r2, [r7, #4]
 801ad1a:	40da      	lsrs	r2, r3
 801ad1c:	0013      	movs	r3, r2
 801ad1e:	b2d9      	uxtb	r1, r3
 801ad20:	693a      	ldr	r2, [r7, #16]
 801ad22:	697b      	ldr	r3, [r7, #20]
 801ad24:	18d3      	adds	r3, r2, r3
 801ad26:	330c      	adds	r3, #12
 801ad28:	1c0a      	adds	r2, r1, #0
 801ad2a:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < 32/8; i++) {
 801ad2c:	697b      	ldr	r3, [r7, #20]
 801ad2e:	3301      	adds	r3, #1
 801ad30:	617b      	str	r3, [r7, #20]
 801ad32:	697b      	ldr	r3, [r7, #20]
 801ad34:	2b03      	cmp	r3, #3
 801ad36:	dded      	ble.n	801ad14 <pppos_send_config+0x5c>
  }

  PPPDEBUG(LOG_INFO, ("pppos_send_config[%d]: out_accm=%X %X %X %X\n",
            pppos->ppp->netif->num,
            pppos->out_accm[0], pppos->out_accm[1], pppos->out_accm[2], pppos->out_accm[3]));
}
 801ad38:	46c0      	nop			; (mov r8, r8)
 801ad3a:	46c0      	nop			; (mov r8, r8)
 801ad3c:	46bd      	mov	sp, r7
 801ad3e:	b007      	add	sp, #28
 801ad40:	bd90      	pop	{r4, r7, pc}

0801ad42 <pppos_recv_config>:

static void
pppos_recv_config(ppp_pcb *ppp, void *ctx, u32_t accm, int pcomp, int accomp)
{
 801ad42:	b580      	push	{r7, lr}
 801ad44:	b086      	sub	sp, #24
 801ad46:	af00      	add	r7, sp, #0
 801ad48:	60f8      	str	r0, [r7, #12]
 801ad4a:	60b9      	str	r1, [r7, #8]
 801ad4c:	607a      	str	r2, [r7, #4]
 801ad4e:	603b      	str	r3, [r7, #0]
  int i;
  pppos_pcb *pppos = (pppos_pcb *)ctx;
 801ad50:	68bb      	ldr	r3, [r7, #8]
 801ad52:	613b      	str	r3, [r7, #16]
  LWIP_UNUSED_ARG(pcomp);
  LWIP_UNUSED_ARG(accomp);

  /* Load the ACCM bits for the 32 control codes. */
  PPPOS_PROTECT(lev);
  for (i = 0; i < 32 / 8; i++) {
 801ad54:	2300      	movs	r3, #0
 801ad56:	617b      	str	r3, [r7, #20]
 801ad58:	e00f      	b.n	801ad7a <pppos_recv_config+0x38>
    pppos->in_accm[i] = (u8_t)(accm >> (i * 8));
 801ad5a:	697b      	ldr	r3, [r7, #20]
 801ad5c:	00db      	lsls	r3, r3, #3
 801ad5e:	687a      	ldr	r2, [r7, #4]
 801ad60:	40da      	lsrs	r2, r3
 801ad62:	0013      	movs	r3, r2
 801ad64:	b2d8      	uxtb	r0, r3
 801ad66:	693a      	ldr	r2, [r7, #16]
 801ad68:	212d      	movs	r1, #45	; 0x2d
 801ad6a:	697b      	ldr	r3, [r7, #20]
 801ad6c:	18d3      	adds	r3, r2, r3
 801ad6e:	185b      	adds	r3, r3, r1
 801ad70:	1c02      	adds	r2, r0, #0
 801ad72:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < 32 / 8; i++) {
 801ad74:	697b      	ldr	r3, [r7, #20]
 801ad76:	3301      	adds	r3, #1
 801ad78:	617b      	str	r3, [r7, #20]
 801ad7a:	697b      	ldr	r3, [r7, #20]
 801ad7c:	2b03      	cmp	r3, #3
 801ad7e:	ddec      	ble.n	801ad5a <pppos_recv_config+0x18>
  PPPOS_UNPROTECT(lev);

  PPPDEBUG(LOG_INFO, ("pppos_recv_config[%d]: in_accm=%X %X %X %X\n",
            pppos->ppp->netif->num,
            pppos->in_accm[0], pppos->in_accm[1], pppos->in_accm[2], pppos->in_accm[3]));
}
 801ad80:	46c0      	nop			; (mov r8, r8)
 801ad82:	46c0      	nop			; (mov r8, r8)
 801ad84:	46bd      	mov	sp, r7
 801ad86:	b006      	add	sp, #24
 801ad88:	bd80      	pop	{r7, pc}

0801ad8a <pppos_input_free_current_packet>:
/*
 * Drop the input packet.
 */
static void
pppos_input_free_current_packet(pppos_pcb *pppos)
{
 801ad8a:	b580      	push	{r7, lr}
 801ad8c:	b082      	sub	sp, #8
 801ad8e:	af00      	add	r7, sp, #0
 801ad90:	6078      	str	r0, [r7, #4]
  if (pppos->in_head != NULL) {
 801ad92:	687b      	ldr	r3, [r7, #4]
 801ad94:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801ad96:	2b00      	cmp	r3, #0
 801ad98:	d016      	beq.n	801adc8 <pppos_input_free_current_packet+0x3e>
    if (pppos->in_tail && (pppos->in_tail != pppos->in_head)) {
 801ad9a:	687b      	ldr	r3, [r7, #4]
 801ad9c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801ad9e:	2b00      	cmp	r3, #0
 801ada0:	d00a      	beq.n	801adb8 <pppos_input_free_current_packet+0x2e>
 801ada2:	687b      	ldr	r3, [r7, #4]
 801ada4:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801ada6:	687b      	ldr	r3, [r7, #4]
 801ada8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801adaa:	429a      	cmp	r2, r3
 801adac:	d004      	beq.n	801adb8 <pppos_input_free_current_packet+0x2e>
      pbuf_free(pppos->in_tail);
 801adae:	687b      	ldr	r3, [r7, #4]
 801adb0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801adb2:	0018      	movs	r0, r3
 801adb4:	f7ef f882 	bl	8009ebc <pbuf_free>
    }
    pbuf_free(pppos->in_head);
 801adb8:	687b      	ldr	r3, [r7, #4]
 801adba:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801adbc:	0018      	movs	r0, r3
 801adbe:	f7ef f87d 	bl	8009ebc <pbuf_free>
    pppos->in_head = NULL;
 801adc2:	687b      	ldr	r3, [r7, #4]
 801adc4:	2200      	movs	r2, #0
 801adc6:	651a      	str	r2, [r3, #80]	; 0x50
  }
  pppos->in_tail = NULL;
 801adc8:	687b      	ldr	r3, [r7, #4]
 801adca:	2200      	movs	r2, #0
 801adcc:	655a      	str	r2, [r3, #84]	; 0x54
}
 801adce:	46c0      	nop			; (mov r8, r8)
 801add0:	46bd      	mov	sp, r7
 801add2:	b002      	add	sp, #8
 801add4:	bd80      	pop	{r7, pc}

0801add6 <pppos_input_drop>:
/*
 * Drop the input packet and increase error counters.
 */
static void
pppos_input_drop(pppos_pcb *pppos)
{
 801add6:	b580      	push	{r7, lr}
 801add8:	b082      	sub	sp, #8
 801adda:	af00      	add	r7, sp, #0
 801addc:	6078      	str	r0, [r7, #4]
#if 0
    PPPDEBUG(LOG_INFO, ("pppos_input_drop: %d:%.*H\n", pppos->in_head->len, min(60, pppos->in_head->len * 2), pppos->in_head->payload));
#endif
    PPPDEBUG(LOG_INFO, ("pppos_input_drop: pbuf len=%d, addr %p\n", pppos->in_head->len, (void*)pppos->in_head));
  }
  pppos_input_free_current_packet(pppos);
 801adde:	687b      	ldr	r3, [r7, #4]
 801ade0:	0018      	movs	r0, r3
 801ade2:	f7ff ffd2 	bl	801ad8a <pppos_input_free_current_packet>
#if VJ_SUPPORT
  vj_uncompress_err(&pppos->ppp->vj_comp);
 801ade6:	687b      	ldr	r3, [r7, #4]
 801ade8:	681b      	ldr	r3, [r3, #0]
 801adea:	33dc      	adds	r3, #220	; 0xdc
 801adec:	0018      	movs	r0, r3
 801adee:	f001 fa4f 	bl	801c290 <vj_uncompress_err>
#endif /* VJ_SUPPORT */

  LINK_STATS_INC(link.drop);
  MIB2_STATS_NETIF_INC(pppos->ppp->netif, ifindiscards);
}
 801adf2:	46c0      	nop			; (mov r8, r8)
 801adf4:	46bd      	mov	sp, r7
 801adf6:	b002      	add	sp, #8
 801adf8:	bd80      	pop	{r7, pc}
	...

0801adfc <pppos_output_append>:
 * If pbuf is full, send the pbuf and reuse it.
 * Return the current pbuf.
 */
static err_t
pppos_output_append(pppos_pcb *pppos, err_t err, struct pbuf *nb, u8_t c, u8_t accm, u16_t *fcs)
{
 801adfc:	b590      	push	{r4, r7, lr}
 801adfe:	b087      	sub	sp, #28
 801ae00:	af00      	add	r7, sp, #0
 801ae02:	60f8      	str	r0, [r7, #12]
 801ae04:	0008      	movs	r0, r1
 801ae06:	607a      	str	r2, [r7, #4]
 801ae08:	0019      	movs	r1, r3
 801ae0a:	240b      	movs	r4, #11
 801ae0c:	193b      	adds	r3, r7, r4
 801ae0e:	1c02      	adds	r2, r0, #0
 801ae10:	701a      	strb	r2, [r3, #0]
 801ae12:	230a      	movs	r3, #10
 801ae14:	18fb      	adds	r3, r7, r3
 801ae16:	1c0a      	adds	r2, r1, #0
 801ae18:	701a      	strb	r2, [r3, #0]
  if (err != ERR_OK) {
 801ae1a:	193b      	adds	r3, r7, r4
 801ae1c:	781b      	ldrb	r3, [r3, #0]
 801ae1e:	b25b      	sxtb	r3, r3
 801ae20:	2b00      	cmp	r3, #0
 801ae22:	d003      	beq.n	801ae2c <pppos_output_append+0x30>
    return err;
 801ae24:	193b      	adds	r3, r7, r4
 801ae26:	781b      	ldrb	r3, [r3, #0]
 801ae28:	b25b      	sxtb	r3, r3
 801ae2a:	e07a      	b.n	801af22 <pppos_output_append+0x126>
  }

  /* Make sure there is room for the character and an escape code.
   * Sure we don't quite fill the buffer if the character doesn't
   * get escaped but is one character worth complicating this? */
  if ((PBUF_POOL_BUFSIZE - nb->len) < 2) {
 801ae2c:	687b      	ldr	r3, [r7, #4]
 801ae2e:	895b      	ldrh	r3, [r3, #10]
 801ae30:	001a      	movs	r2, r3
 801ae32:	2394      	movs	r3, #148	; 0x94
 801ae34:	009b      	lsls	r3, r3, #2
 801ae36:	1a9b      	subs	r3, r3, r2
 801ae38:	2b01      	cmp	r3, #1
 801ae3a:	d81a      	bhi.n	801ae72 <pppos_output_append+0x76>
    u32_t l = pppos->output_cb(pppos->ppp, (u8_t*)nb->payload, nb->len, pppos->ppp->ctx_cb);
 801ae3c:	68fb      	ldr	r3, [r7, #12]
 801ae3e:	685c      	ldr	r4, [r3, #4]
 801ae40:	68fb      	ldr	r3, [r7, #12]
 801ae42:	6818      	ldr	r0, [r3, #0]
 801ae44:	687b      	ldr	r3, [r7, #4]
 801ae46:	6859      	ldr	r1, [r3, #4]
 801ae48:	687b      	ldr	r3, [r7, #4]
 801ae4a:	895b      	ldrh	r3, [r3, #10]
 801ae4c:	001a      	movs	r2, r3
 801ae4e:	68fb      	ldr	r3, [r7, #12]
 801ae50:	681b      	ldr	r3, [r3, #0]
 801ae52:	69db      	ldr	r3, [r3, #28]
 801ae54:	47a0      	blx	r4
 801ae56:	0003      	movs	r3, r0
 801ae58:	617b      	str	r3, [r7, #20]
    if (l != nb->len) {
 801ae5a:	687b      	ldr	r3, [r7, #4]
 801ae5c:	895b      	ldrh	r3, [r3, #10]
 801ae5e:	001a      	movs	r2, r3
 801ae60:	697b      	ldr	r3, [r7, #20]
 801ae62:	4293      	cmp	r3, r2
 801ae64:	d002      	beq.n	801ae6c <pppos_output_append+0x70>
      return ERR_IF;
 801ae66:	230c      	movs	r3, #12
 801ae68:	425b      	negs	r3, r3
 801ae6a:	e05a      	b.n	801af22 <pppos_output_append+0x126>
    }
    nb->len = 0;
 801ae6c:	687b      	ldr	r3, [r7, #4]
 801ae6e:	2200      	movs	r2, #0
 801ae70:	815a      	strh	r2, [r3, #10]
  }

  /* Update FCS before checking for special characters. */
  if (fcs) {
 801ae72:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801ae74:	2b00      	cmp	r3, #0
 801ae76:	d013      	beq.n	801aea0 <pppos_output_append+0xa4>
    *fcs = PPP_FCS(*fcs, c);
 801ae78:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801ae7a:	881b      	ldrh	r3, [r3, #0]
 801ae7c:	0a1b      	lsrs	r3, r3, #8
 801ae7e:	b29a      	uxth	r2, r3
 801ae80:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801ae82:	881b      	ldrh	r3, [r3, #0]
 801ae84:	0019      	movs	r1, r3
 801ae86:	230a      	movs	r3, #10
 801ae88:	18fb      	adds	r3, r7, r3
 801ae8a:	781b      	ldrb	r3, [r3, #0]
 801ae8c:	404b      	eors	r3, r1
 801ae8e:	21ff      	movs	r1, #255	; 0xff
 801ae90:	4019      	ands	r1, r3
 801ae92:	4b26      	ldr	r3, [pc, #152]	; (801af2c <pppos_output_append+0x130>)
 801ae94:	0049      	lsls	r1, r1, #1
 801ae96:	5acb      	ldrh	r3, [r1, r3]
 801ae98:	4053      	eors	r3, r2
 801ae9a:	b29a      	uxth	r2, r3
 801ae9c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801ae9e:	801a      	strh	r2, [r3, #0]
  }

  /* Copy to output buffer escaping special characters. */
  if (accm && ESCAPE_P(pppos->out_accm, c)) {
 801aea0:	2328      	movs	r3, #40	; 0x28
 801aea2:	18fb      	adds	r3, r7, r3
 801aea4:	781b      	ldrb	r3, [r3, #0]
 801aea6:	2b00      	cmp	r3, #0
 801aea8:	d02d      	beq.n	801af06 <pppos_output_append+0x10a>
 801aeaa:	240a      	movs	r4, #10
 801aeac:	193b      	adds	r3, r7, r4
 801aeae:	781b      	ldrb	r3, [r3, #0]
 801aeb0:	08db      	lsrs	r3, r3, #3
 801aeb2:	b2db      	uxtb	r3, r3
 801aeb4:	001a      	movs	r2, r3
 801aeb6:	68fb      	ldr	r3, [r7, #12]
 801aeb8:	189b      	adds	r3, r3, r2
 801aeba:	7b1b      	ldrb	r3, [r3, #12]
 801aebc:	0019      	movs	r1, r3
 801aebe:	193b      	adds	r3, r7, r4
 801aec0:	781b      	ldrb	r3, [r3, #0]
 801aec2:	2207      	movs	r2, #7
 801aec4:	4013      	ands	r3, r2
 801aec6:	4119      	asrs	r1, r3
 801aec8:	000b      	movs	r3, r1
 801aeca:	2201      	movs	r2, #1
 801aecc:	4013      	ands	r3, r2
 801aece:	d01a      	beq.n	801af06 <pppos_output_append+0x10a>
    *((u8_t*)nb->payload + nb->len++) = PPP_ESCAPE;
 801aed0:	687b      	ldr	r3, [r7, #4]
 801aed2:	685a      	ldr	r2, [r3, #4]
 801aed4:	687b      	ldr	r3, [r7, #4]
 801aed6:	895b      	ldrh	r3, [r3, #10]
 801aed8:	1c59      	adds	r1, r3, #1
 801aeda:	b288      	uxth	r0, r1
 801aedc:	6879      	ldr	r1, [r7, #4]
 801aede:	8148      	strh	r0, [r1, #10]
 801aee0:	18d3      	adds	r3, r2, r3
 801aee2:	227d      	movs	r2, #125	; 0x7d
 801aee4:	701a      	strb	r2, [r3, #0]
    *((u8_t*)nb->payload + nb->len++) = c ^ PPP_TRANS;
 801aee6:	687b      	ldr	r3, [r7, #4]
 801aee8:	685a      	ldr	r2, [r3, #4]
 801aeea:	687b      	ldr	r3, [r7, #4]
 801aeec:	895b      	ldrh	r3, [r3, #10]
 801aeee:	1c59      	adds	r1, r3, #1
 801aef0:	b288      	uxth	r0, r1
 801aef2:	6879      	ldr	r1, [r7, #4]
 801aef4:	8148      	strh	r0, [r1, #10]
 801aef6:	18d3      	adds	r3, r2, r3
 801aef8:	193a      	adds	r2, r7, r4
 801aefa:	7812      	ldrb	r2, [r2, #0]
 801aefc:	2120      	movs	r1, #32
 801aefe:	404a      	eors	r2, r1
 801af00:	b2d2      	uxtb	r2, r2
 801af02:	701a      	strb	r2, [r3, #0]
 801af04:	e00c      	b.n	801af20 <pppos_output_append+0x124>
  } else {
    *((u8_t*)nb->payload + nb->len++) = c;
 801af06:	687b      	ldr	r3, [r7, #4]
 801af08:	685a      	ldr	r2, [r3, #4]
 801af0a:	687b      	ldr	r3, [r7, #4]
 801af0c:	895b      	ldrh	r3, [r3, #10]
 801af0e:	1c59      	adds	r1, r3, #1
 801af10:	b288      	uxth	r0, r1
 801af12:	6879      	ldr	r1, [r7, #4]
 801af14:	8148      	strh	r0, [r1, #10]
 801af16:	18d3      	adds	r3, r2, r3
 801af18:	220a      	movs	r2, #10
 801af1a:	18ba      	adds	r2, r7, r2
 801af1c:	7812      	ldrb	r2, [r2, #0]
 801af1e:	701a      	strb	r2, [r3, #0]
  }

  return ERR_OK;
 801af20:	2300      	movs	r3, #0
}
 801af22:	0018      	movs	r0, r3
 801af24:	46bd      	mov	sp, r7
 801af26:	b007      	add	sp, #28
 801af28:	bd90      	pop	{r4, r7, pc}
 801af2a:	46c0      	nop			; (mov r8, r8)
 801af2c:	08022b2c 	.word	0x08022b2c

0801af30 <pppos_output_last>:

static err_t
pppos_output_last(pppos_pcb *pppos, err_t err, struct pbuf *nb, u16_t *fcs)
{
 801af30:	b5f0      	push	{r4, r5, r6, r7, lr}
 801af32:	b089      	sub	sp, #36	; 0x24
 801af34:	af02      	add	r7, sp, #8
 801af36:	60f8      	str	r0, [r7, #12]
 801af38:	607a      	str	r2, [r7, #4]
 801af3a:	603b      	str	r3, [r7, #0]
 801af3c:	260b      	movs	r6, #11
 801af3e:	19bb      	adds	r3, r7, r6
 801af40:	1c0a      	adds	r2, r1, #0
 801af42:	701a      	strb	r2, [r3, #0]
  ppp_pcb *ppp = pppos->ppp;
 801af44:	68fb      	ldr	r3, [r7, #12]
 801af46:	681b      	ldr	r3, [r3, #0]
 801af48:	617b      	str	r3, [r7, #20]

  /* Add FCS and trailing flag. */
  err = pppos_output_append(pppos, err,  nb, ~(*fcs) & 0xFF, 1, NULL);
 801af4a:	683b      	ldr	r3, [r7, #0]
 801af4c:	881b      	ldrh	r3, [r3, #0]
 801af4e:	b2db      	uxtb	r3, r3
 801af50:	43db      	mvns	r3, r3
 801af52:	b2dd      	uxtb	r5, r3
 801af54:	19bc      	adds	r4, r7, r6
 801af56:	687a      	ldr	r2, [r7, #4]
 801af58:	19bb      	adds	r3, r7, r6
 801af5a:	2100      	movs	r1, #0
 801af5c:	5659      	ldrsb	r1, [r3, r1]
 801af5e:	68f8      	ldr	r0, [r7, #12]
 801af60:	2300      	movs	r3, #0
 801af62:	9301      	str	r3, [sp, #4]
 801af64:	2301      	movs	r3, #1
 801af66:	9300      	str	r3, [sp, #0]
 801af68:	002b      	movs	r3, r5
 801af6a:	f7ff ff47 	bl	801adfc <pppos_output_append>
 801af6e:	0003      	movs	r3, r0
 801af70:	7023      	strb	r3, [r4, #0]
  err = pppos_output_append(pppos, err,  nb, (~(*fcs) >> 8) & 0xFF, 1, NULL);
 801af72:	683b      	ldr	r3, [r7, #0]
 801af74:	881b      	ldrh	r3, [r3, #0]
 801af76:	43db      	mvns	r3, r3
 801af78:	121b      	asrs	r3, r3, #8
 801af7a:	b2dd      	uxtb	r5, r3
 801af7c:	19bc      	adds	r4, r7, r6
 801af7e:	687a      	ldr	r2, [r7, #4]
 801af80:	19bb      	adds	r3, r7, r6
 801af82:	2100      	movs	r1, #0
 801af84:	5659      	ldrsb	r1, [r3, r1]
 801af86:	68f8      	ldr	r0, [r7, #12]
 801af88:	2300      	movs	r3, #0
 801af8a:	9301      	str	r3, [sp, #4]
 801af8c:	2301      	movs	r3, #1
 801af8e:	9300      	str	r3, [sp, #0]
 801af90:	002b      	movs	r3, r5
 801af92:	f7ff ff33 	bl	801adfc <pppos_output_append>
 801af96:	0003      	movs	r3, r0
 801af98:	7023      	strb	r3, [r4, #0]
  err = pppos_output_append(pppos, err,  nb, PPP_FLAG, 0, NULL);
 801af9a:	0035      	movs	r5, r6
 801af9c:	197c      	adds	r4, r7, r5
 801af9e:	687a      	ldr	r2, [r7, #4]
 801afa0:	197b      	adds	r3, r7, r5
 801afa2:	2100      	movs	r1, #0
 801afa4:	5659      	ldrsb	r1, [r3, r1]
 801afa6:	68f8      	ldr	r0, [r7, #12]
 801afa8:	2300      	movs	r3, #0
 801afaa:	9301      	str	r3, [sp, #4]
 801afac:	2300      	movs	r3, #0
 801afae:	9300      	str	r3, [sp, #0]
 801afb0:	237e      	movs	r3, #126	; 0x7e
 801afb2:	f7ff ff23 	bl	801adfc <pppos_output_append>
 801afb6:	0003      	movs	r3, r0
 801afb8:	7023      	strb	r3, [r4, #0]

  if (err != ERR_OK) {
 801afba:	197b      	adds	r3, r7, r5
 801afbc:	781b      	ldrb	r3, [r3, #0]
 801afbe:	b25b      	sxtb	r3, r3
 801afc0:	2b00      	cmp	r3, #0
 801afc2:	d125      	bne.n	801b010 <pppos_output_last+0xe0>
    goto failed;
  }

  /* Send remaining buffer if not empty */
  if (nb->len > 0) {
 801afc4:	687b      	ldr	r3, [r7, #4]
 801afc6:	895b      	ldrh	r3, [r3, #10]
 801afc8:	2b00      	cmp	r3, #0
 801afca:	d016      	beq.n	801affa <pppos_output_last+0xca>
    u32_t l = pppos->output_cb(ppp, (u8_t*)nb->payload, nb->len, ppp->ctx_cb);
 801afcc:	68fb      	ldr	r3, [r7, #12]
 801afce:	685c      	ldr	r4, [r3, #4]
 801afd0:	687b      	ldr	r3, [r7, #4]
 801afd2:	6859      	ldr	r1, [r3, #4]
 801afd4:	687b      	ldr	r3, [r7, #4]
 801afd6:	895b      	ldrh	r3, [r3, #10]
 801afd8:	001a      	movs	r2, r3
 801afda:	697b      	ldr	r3, [r7, #20]
 801afdc:	69db      	ldr	r3, [r3, #28]
 801afde:	6978      	ldr	r0, [r7, #20]
 801afe0:	47a0      	blx	r4
 801afe2:	0003      	movs	r3, r0
 801afe4:	613b      	str	r3, [r7, #16]
    if (l != nb->len) {
 801afe6:	687b      	ldr	r3, [r7, #4]
 801afe8:	895b      	ldrh	r3, [r3, #10]
 801afea:	001a      	movs	r2, r3
 801afec:	693b      	ldr	r3, [r7, #16]
 801afee:	4293      	cmp	r3, r2
 801aff0:	d003      	beq.n	801affa <pppos_output_last+0xca>
      err = ERR_IF;
 801aff2:	197b      	adds	r3, r7, r5
 801aff4:	22f4      	movs	r2, #244	; 0xf4
 801aff6:	701a      	strb	r2, [r3, #0]
      goto failed;
 801aff8:	e00b      	b.n	801b012 <pppos_output_last+0xe2>
    }
  }

  pppos->last_xmit = sys_now();
 801affa:	f001 ff15 	bl	801ce28 <sys_now>
 801affe:	0002      	movs	r2, r0
 801b000:	68fb      	ldr	r3, [r7, #12]
 801b002:	609a      	str	r2, [r3, #8]
  MIB2_STATS_NETIF_ADD(ppp->netif, ifoutoctets, nb->tot_len);
  MIB2_STATS_NETIF_INC(ppp->netif, ifoutucastpkts);
  LINK_STATS_INC(link.xmit);
  pbuf_free(nb);
 801b004:	687b      	ldr	r3, [r7, #4]
 801b006:	0018      	movs	r0, r3
 801b008:	f7ee ff58 	bl	8009ebc <pbuf_free>
  return ERR_OK;
 801b00c:	2300      	movs	r3, #0
 801b00e:	e00b      	b.n	801b028 <pppos_output_last+0xf8>
    goto failed;
 801b010:	46c0      	nop			; (mov r8, r8)

failed:
  pppos->last_xmit = 0; /* prepend PPP_FLAG to next packet */
 801b012:	68fb      	ldr	r3, [r7, #12]
 801b014:	2200      	movs	r2, #0
 801b016:	609a      	str	r2, [r3, #8]
  LINK_STATS_INC(link.err);
  LINK_STATS_INC(link.drop);
  MIB2_STATS_NETIF_INC(ppp->netif, ifoutdiscards);
  pbuf_free(nb);
 801b018:	687b      	ldr	r3, [r7, #4]
 801b01a:	0018      	movs	r0, r3
 801b01c:	f7ee ff4e 	bl	8009ebc <pbuf_free>
  return err;
 801b020:	230b      	movs	r3, #11
 801b022:	18fb      	adds	r3, r7, r3
 801b024:	781b      	ldrb	r3, [r3, #0]
 801b026:	b25b      	sxtb	r3, r3
}
 801b028:	0018      	movs	r0, r3
 801b02a:	46bd      	mov	sp, r7
 801b02c:	b007      	add	sp, #28
 801b02e:	bdf0      	pop	{r4, r5, r6, r7, pc}

0801b030 <ppp_slprintf>:
 * %m (error message), %v (visible string),
 * %q (quoted string), %t (current time) and %I (IP address) formats.
 * Doesn't do floating-point formats.
 * Returns the number of chars put into buf.
 */
int ppp_slprintf(char *buf, int buflen, const char *fmt, ...) {
 801b030:	b40c      	push	{r2, r3}
 801b032:	b580      	push	{r7, lr}
 801b034:	b084      	sub	sp, #16
 801b036:	af00      	add	r7, sp, #0
 801b038:	6078      	str	r0, [r7, #4]
 801b03a:	6039      	str	r1, [r7, #0]
    va_list args;
    int n;

    va_start(args, fmt);
 801b03c:	231c      	movs	r3, #28
 801b03e:	18fb      	adds	r3, r7, r3
 801b040:	60bb      	str	r3, [r7, #8]
    n = ppp_vslprintf(buf, buflen, fmt, args);
 801b042:	68bb      	ldr	r3, [r7, #8]
 801b044:	69ba      	ldr	r2, [r7, #24]
 801b046:	6839      	ldr	r1, [r7, #0]
 801b048:	6878      	ldr	r0, [r7, #4]
 801b04a:	f000 f80b 	bl	801b064 <ppp_vslprintf>
 801b04e:	0003      	movs	r3, r0
 801b050:	60fb      	str	r3, [r7, #12]
    va_end(args);
    return n;
 801b052:	68fb      	ldr	r3, [r7, #12]
}
 801b054:	0018      	movs	r0, r3
 801b056:	46bd      	mov	sp, r7
 801b058:	b004      	add	sp, #16
 801b05a:	bc80      	pop	{r7}
 801b05c:	bc08      	pop	{r3}
 801b05e:	b002      	add	sp, #8
 801b060:	4718      	bx	r3
	...

0801b064 <ppp_vslprintf>:
/*
 * ppp_vslprintf - like ppp_slprintf, takes a va_list instead of a list of args.
 */
#define OUTCHAR(c)	(buflen > 0? (--buflen, *buf++ = (c)): 0)

int ppp_vslprintf(char *buf, int buflen, const char *fmt, va_list args) {
 801b064:	b5f0      	push	{r4, r5, r6, r7, lr}
 801b066:	b0a1      	sub	sp, #132	; 0x84
 801b068:	af04      	add	r7, sp, #16
 801b06a:	60f8      	str	r0, [r7, #12]
 801b06c:	60b9      	str	r1, [r7, #8]
 801b06e:	607a      	str	r2, [r7, #4]
 801b070:	603b      	str	r3, [r7, #0]
    int c, i, n;
    int width, prec, fillch;
    int base, len, neg, quoted;
    unsigned long val = 0;
 801b072:	2300      	movs	r3, #0
 801b074:	64fb      	str	r3, [r7, #76]	; 0x4c
    static char hexchars[] = "0123456789abcdef";
#if PRINTPKT_SUPPORT
    struct buffer_info bufinfo;
#endif /* PRINTPKT_SUPPORT */

    buf0 = buf;
 801b076:	68fb      	ldr	r3, [r7, #12]
 801b078:	63fb      	str	r3, [r7, #60]	; 0x3c
    --buflen;
 801b07a:	68bb      	ldr	r3, [r7, #8]
 801b07c:	3b01      	subs	r3, #1
 801b07e:	60bb      	str	r3, [r7, #8]
    while (buflen > 0) {
 801b080:	f000 fb8b 	bl	801b79a <ppp_vslprintf+0x736>
	for (f = fmt; *f != '%' && *f != 0; ++f)
 801b084:	687b      	ldr	r3, [r7, #4]
 801b086:	64bb      	str	r3, [r7, #72]	; 0x48
 801b088:	e002      	b.n	801b090 <ppp_vslprintf+0x2c>
 801b08a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801b08c:	3301      	adds	r3, #1
 801b08e:	64bb      	str	r3, [r7, #72]	; 0x48
 801b090:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801b092:	781b      	ldrb	r3, [r3, #0]
 801b094:	2b25      	cmp	r3, #37	; 0x25
 801b096:	d003      	beq.n	801b0a0 <ppp_vslprintf+0x3c>
 801b098:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801b09a:	781b      	ldrb	r3, [r3, #0]
 801b09c:	2b00      	cmp	r3, #0
 801b09e:	d1f4      	bne.n	801b08a <ppp_vslprintf+0x26>
	    ;
	if (f > fmt) {
 801b0a0:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801b0a2:	687b      	ldr	r3, [r7, #4]
 801b0a4:	429a      	cmp	r2, r3
 801b0a6:	d919      	bls.n	801b0dc <ppp_vslprintf+0x78>
	    len = f - fmt;
 801b0a8:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801b0aa:	687b      	ldr	r3, [r7, #4]
 801b0ac:	1ad3      	subs	r3, r2, r3
 801b0ae:	657b      	str	r3, [r7, #84]	; 0x54
	    if (len > buflen)
 801b0b0:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801b0b2:	68bb      	ldr	r3, [r7, #8]
 801b0b4:	429a      	cmp	r2, r3
 801b0b6:	dd01      	ble.n	801b0bc <ppp_vslprintf+0x58>
		len = buflen;
 801b0b8:	68bb      	ldr	r3, [r7, #8]
 801b0ba:	657b      	str	r3, [r7, #84]	; 0x54
	    memcpy(buf, fmt, len);
 801b0bc:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801b0be:	6879      	ldr	r1, [r7, #4]
 801b0c0:	68fb      	ldr	r3, [r7, #12]
 801b0c2:	0018      	movs	r0, r3
 801b0c4:	f001 ff02 	bl	801cecc <memcpy>
	    buf += len;
 801b0c8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801b0ca:	68fa      	ldr	r2, [r7, #12]
 801b0cc:	18d3      	adds	r3, r2, r3
 801b0ce:	60fb      	str	r3, [r7, #12]
	    buflen -= len;
 801b0d0:	68ba      	ldr	r2, [r7, #8]
 801b0d2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801b0d4:	1ad3      	subs	r3, r2, r3
 801b0d6:	60bb      	str	r3, [r7, #8]
	    fmt = f;
 801b0d8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801b0da:	607b      	str	r3, [r7, #4]
	}
	if (*fmt == 0)
 801b0dc:	687b      	ldr	r3, [r7, #4]
 801b0de:	781b      	ldrb	r3, [r3, #0]
 801b0e0:	2b00      	cmp	r3, #0
 801b0e2:	d101      	bne.n	801b0e8 <ppp_vslprintf+0x84>
 801b0e4:	f000 fb5e 	bl	801b7a4 <ppp_vslprintf+0x740>
	    break;
	c = *++fmt;
 801b0e8:	687b      	ldr	r3, [r7, #4]
 801b0ea:	3301      	adds	r3, #1
 801b0ec:	607b      	str	r3, [r7, #4]
 801b0ee:	687b      	ldr	r3, [r7, #4]
 801b0f0:	781b      	ldrb	r3, [r3, #0]
 801b0f2:	66fb      	str	r3, [r7, #108]	; 0x6c
	width = 0;
 801b0f4:	2300      	movs	r3, #0
 801b0f6:	667b      	str	r3, [r7, #100]	; 0x64
	prec = -1;
 801b0f8:	2301      	movs	r3, #1
 801b0fa:	425b      	negs	r3, r3
 801b0fc:	663b      	str	r3, [r7, #96]	; 0x60
	fillch = ' ';
 801b0fe:	2320      	movs	r3, #32
 801b100:	65fb      	str	r3, [r7, #92]	; 0x5c
	if (c == '0') {
 801b102:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b104:	2b30      	cmp	r3, #48	; 0x30
 801b106:	d107      	bne.n	801b118 <ppp_vslprintf+0xb4>
	    fillch = '0';
 801b108:	2330      	movs	r3, #48	; 0x30
 801b10a:	65fb      	str	r3, [r7, #92]	; 0x5c
	    c = *++fmt;
 801b10c:	687b      	ldr	r3, [r7, #4]
 801b10e:	3301      	adds	r3, #1
 801b110:	607b      	str	r3, [r7, #4]
 801b112:	687b      	ldr	r3, [r7, #4]
 801b114:	781b      	ldrb	r3, [r3, #0]
 801b116:	66fb      	str	r3, [r7, #108]	; 0x6c
	}
	if (c == '*') {
 801b118:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b11a:	2b2a      	cmp	r3, #42	; 0x2a
 801b11c:	d11b      	bne.n	801b156 <ppp_vslprintf+0xf2>
	    width = va_arg(args, int);
 801b11e:	683b      	ldr	r3, [r7, #0]
 801b120:	1d1a      	adds	r2, r3, #4
 801b122:	603a      	str	r2, [r7, #0]
 801b124:	681b      	ldr	r3, [r3, #0]
 801b126:	667b      	str	r3, [r7, #100]	; 0x64
	    c = *++fmt;
 801b128:	687b      	ldr	r3, [r7, #4]
 801b12a:	3301      	adds	r3, #1
 801b12c:	607b      	str	r3, [r7, #4]
 801b12e:	687b      	ldr	r3, [r7, #4]
 801b130:	781b      	ldrb	r3, [r3, #0]
 801b132:	66fb      	str	r3, [r7, #108]	; 0x6c
 801b134:	e019      	b.n	801b16a <ppp_vslprintf+0x106>
	} else {
	    while (lwip_isdigit(c)) {
		width = width * 10 + c - '0';
 801b136:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 801b138:	0013      	movs	r3, r2
 801b13a:	009b      	lsls	r3, r3, #2
 801b13c:	189b      	adds	r3, r3, r2
 801b13e:	005b      	lsls	r3, r3, #1
 801b140:	001a      	movs	r2, r3
 801b142:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b144:	18d3      	adds	r3, r2, r3
 801b146:	3b30      	subs	r3, #48	; 0x30
 801b148:	667b      	str	r3, [r7, #100]	; 0x64
		c = *++fmt;
 801b14a:	687b      	ldr	r3, [r7, #4]
 801b14c:	3301      	adds	r3, #1
 801b14e:	607b      	str	r3, [r7, #4]
 801b150:	687b      	ldr	r3, [r7, #4]
 801b152:	781b      	ldrb	r3, [r3, #0]
 801b154:	66fb      	str	r3, [r7, #108]	; 0x6c
	    while (lwip_isdigit(c)) {
 801b156:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b158:	b2db      	uxtb	r3, r3
 801b15a:	1c5a      	adds	r2, r3, #1
 801b15c:	4bcf      	ldr	r3, [pc, #828]	; (801b49c <ppp_vslprintf+0x438>)
 801b15e:	18d3      	adds	r3, r2, r3
 801b160:	781b      	ldrb	r3, [r3, #0]
 801b162:	001a      	movs	r2, r3
 801b164:	2304      	movs	r3, #4
 801b166:	4013      	ands	r3, r2
 801b168:	d1e5      	bne.n	801b136 <ppp_vslprintf+0xd2>
	    }
	}
	if (c == '.') {
 801b16a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b16c:	2b2e      	cmp	r3, #46	; 0x2e
 801b16e:	d131      	bne.n	801b1d4 <ppp_vslprintf+0x170>
	    c = *++fmt;
 801b170:	687b      	ldr	r3, [r7, #4]
 801b172:	3301      	adds	r3, #1
 801b174:	607b      	str	r3, [r7, #4]
 801b176:	687b      	ldr	r3, [r7, #4]
 801b178:	781b      	ldrb	r3, [r3, #0]
 801b17a:	66fb      	str	r3, [r7, #108]	; 0x6c
	    if (c == '*') {
 801b17c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b17e:	2b2a      	cmp	r3, #42	; 0x2a
 801b180:	d10b      	bne.n	801b19a <ppp_vslprintf+0x136>
		prec = va_arg(args, int);
 801b182:	683b      	ldr	r3, [r7, #0]
 801b184:	1d1a      	adds	r2, r3, #4
 801b186:	603a      	str	r2, [r7, #0]
 801b188:	681b      	ldr	r3, [r3, #0]
 801b18a:	663b      	str	r3, [r7, #96]	; 0x60
		c = *++fmt;
 801b18c:	687b      	ldr	r3, [r7, #4]
 801b18e:	3301      	adds	r3, #1
 801b190:	607b      	str	r3, [r7, #4]
 801b192:	687b      	ldr	r3, [r7, #4]
 801b194:	781b      	ldrb	r3, [r3, #0]
 801b196:	66fb      	str	r3, [r7, #108]	; 0x6c
 801b198:	e01c      	b.n	801b1d4 <ppp_vslprintf+0x170>
	    } else {
		prec = 0;
 801b19a:	2300      	movs	r3, #0
 801b19c:	663b      	str	r3, [r7, #96]	; 0x60
		while (lwip_isdigit(c)) {
 801b19e:	e00f      	b.n	801b1c0 <ppp_vslprintf+0x15c>
		    prec = prec * 10 + c - '0';
 801b1a0:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 801b1a2:	0013      	movs	r3, r2
 801b1a4:	009b      	lsls	r3, r3, #2
 801b1a6:	189b      	adds	r3, r3, r2
 801b1a8:	005b      	lsls	r3, r3, #1
 801b1aa:	001a      	movs	r2, r3
 801b1ac:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b1ae:	18d3      	adds	r3, r2, r3
 801b1b0:	3b30      	subs	r3, #48	; 0x30
 801b1b2:	663b      	str	r3, [r7, #96]	; 0x60
		    c = *++fmt;
 801b1b4:	687b      	ldr	r3, [r7, #4]
 801b1b6:	3301      	adds	r3, #1
 801b1b8:	607b      	str	r3, [r7, #4]
 801b1ba:	687b      	ldr	r3, [r7, #4]
 801b1bc:	781b      	ldrb	r3, [r3, #0]
 801b1be:	66fb      	str	r3, [r7, #108]	; 0x6c
		while (lwip_isdigit(c)) {
 801b1c0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b1c2:	b2db      	uxtb	r3, r3
 801b1c4:	1c5a      	adds	r2, r3, #1
 801b1c6:	4bb5      	ldr	r3, [pc, #724]	; (801b49c <ppp_vslprintf+0x438>)
 801b1c8:	18d3      	adds	r3, r2, r3
 801b1ca:	781b      	ldrb	r3, [r3, #0]
 801b1cc:	001a      	movs	r2, r3
 801b1ce:	2304      	movs	r3, #4
 801b1d0:	4013      	ands	r3, r2
 801b1d2:	d1e5      	bne.n	801b1a0 <ppp_vslprintf+0x13c>
		}
	    }
	}
	str = 0;
 801b1d4:	2300      	movs	r3, #0
 801b1d6:	647b      	str	r3, [r7, #68]	; 0x44
	base = 0;
 801b1d8:	2300      	movs	r3, #0
 801b1da:	65bb      	str	r3, [r7, #88]	; 0x58
	neg = 0;
 801b1dc:	2300      	movs	r3, #0
 801b1de:	653b      	str	r3, [r7, #80]	; 0x50
	++fmt;
 801b1e0:	687b      	ldr	r3, [r7, #4]
 801b1e2:	3301      	adds	r3, #1
 801b1e4:	607b      	str	r3, [r7, #4]
 801b1e6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b1e8:	3b42      	subs	r3, #66	; 0x42
 801b1ea:	2b36      	cmp	r3, #54	; 0x36
 801b1ec:	d900      	bls.n	801b1f0 <ppp_vslprintf+0x18c>
 801b1ee:	e229      	b.n	801b644 <ppp_vslprintf+0x5e0>
 801b1f0:	009a      	lsls	r2, r3, #2
 801b1f2:	4bab      	ldr	r3, [pc, #684]	; (801b4a0 <ppp_vslprintf+0x43c>)
 801b1f4:	18d3      	adds	r3, r2, r3
 801b1f6:	681b      	ldr	r3, [r3, #0]
 801b1f8:	469f      	mov	pc, r3
	switch (c) {
	case 'l':
	    c = *fmt++;
 801b1fa:	687b      	ldr	r3, [r7, #4]
 801b1fc:	1c5a      	adds	r2, r3, #1
 801b1fe:	607a      	str	r2, [r7, #4]
 801b200:	781b      	ldrb	r3, [r3, #0]
 801b202:	66fb      	str	r3, [r7, #108]	; 0x6c
 801b204:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b206:	2b64      	cmp	r3, #100	; 0x64
 801b208:	d003      	beq.n	801b212 <ppp_vslprintf+0x1ae>
 801b20a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b20c:	2b75      	cmp	r3, #117	; 0x75
 801b20e:	d010      	beq.n	801b232 <ppp_vslprintf+0x1ce>
 801b210:	e017      	b.n	801b242 <ppp_vslprintf+0x1de>
	    switch (c) {
	    case 'd':
		val = va_arg(args, long);
 801b212:	683b      	ldr	r3, [r7, #0]
 801b214:	1d1a      	adds	r2, r3, #4
 801b216:	603a      	str	r2, [r7, #0]
 801b218:	681b      	ldr	r3, [r3, #0]
 801b21a:	64fb      	str	r3, [r7, #76]	; 0x4c
		if ((long)val < 0) {
 801b21c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b21e:	2b00      	cmp	r3, #0
 801b220:	da04      	bge.n	801b22c <ppp_vslprintf+0x1c8>
		    neg = 1;
 801b222:	2301      	movs	r3, #1
 801b224:	653b      	str	r3, [r7, #80]	; 0x50
		    val = (unsigned long)-(long)val;
 801b226:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b228:	425b      	negs	r3, r3
 801b22a:	64fb      	str	r3, [r7, #76]	; 0x4c
		}
		base = 10;
 801b22c:	230a      	movs	r3, #10
 801b22e:	65bb      	str	r3, [r7, #88]	; 0x58
		break;
 801b230:	e021      	b.n	801b276 <ppp_vslprintf+0x212>
	    case 'u':
		val = va_arg(args, unsigned long);
 801b232:	683b      	ldr	r3, [r7, #0]
 801b234:	1d1a      	adds	r2, r3, #4
 801b236:	603a      	str	r2, [r7, #0]
 801b238:	681b      	ldr	r3, [r3, #0]
 801b23a:	64fb      	str	r3, [r7, #76]	; 0x4c
		base = 10;
 801b23c:	230a      	movs	r3, #10
 801b23e:	65bb      	str	r3, [r7, #88]	; 0x58
		break;
 801b240:	e019      	b.n	801b276 <ppp_vslprintf+0x212>
	    default:
		OUTCHAR('%');
 801b242:	68bb      	ldr	r3, [r7, #8]
 801b244:	2b00      	cmp	r3, #0
 801b246:	dd07      	ble.n	801b258 <ppp_vslprintf+0x1f4>
 801b248:	68bb      	ldr	r3, [r7, #8]
 801b24a:	3b01      	subs	r3, #1
 801b24c:	60bb      	str	r3, [r7, #8]
 801b24e:	68fb      	ldr	r3, [r7, #12]
 801b250:	1c5a      	adds	r2, r3, #1
 801b252:	60fa      	str	r2, [r7, #12]
 801b254:	2225      	movs	r2, #37	; 0x25
 801b256:	701a      	strb	r2, [r3, #0]
		OUTCHAR('l');
 801b258:	68bb      	ldr	r3, [r7, #8]
 801b25a:	2b00      	cmp	r3, #0
 801b25c:	dd07      	ble.n	801b26e <ppp_vslprintf+0x20a>
 801b25e:	68bb      	ldr	r3, [r7, #8]
 801b260:	3b01      	subs	r3, #1
 801b262:	60bb      	str	r3, [r7, #8]
 801b264:	68fb      	ldr	r3, [r7, #12]
 801b266:	1c5a      	adds	r2, r3, #1
 801b268:	60fa      	str	r2, [r7, #12]
 801b26a:	226c      	movs	r2, #108	; 0x6c
 801b26c:	701a      	strb	r2, [r3, #0]
		--fmt;		/* so %lz outputs %lz etc. */
 801b26e:	687b      	ldr	r3, [r7, #4]
 801b270:	3b01      	subs	r3, #1
 801b272:	607b      	str	r3, [r7, #4]
		continue;
 801b274:	e291      	b.n	801b79a <ppp_vslprintf+0x736>
	    }
	    break;
 801b276:	e1f4      	b.n	801b662 <ppp_vslprintf+0x5fe>
	case 'd':
	    i = va_arg(args, int);
 801b278:	683b      	ldr	r3, [r7, #0]
 801b27a:	1d1a      	adds	r2, r3, #4
 801b27c:	603a      	str	r2, [r7, #0]
 801b27e:	681b      	ldr	r3, [r3, #0]
 801b280:	637b      	str	r3, [r7, #52]	; 0x34
	    if (i < 0) {
 801b282:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b284:	2b00      	cmp	r3, #0
 801b286:	da05      	bge.n	801b294 <ppp_vslprintf+0x230>
		neg = 1;
 801b288:	2301      	movs	r3, #1
 801b28a:	653b      	str	r3, [r7, #80]	; 0x50
		val = -i;
 801b28c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b28e:	425b      	negs	r3, r3
 801b290:	64fb      	str	r3, [r7, #76]	; 0x4c
 801b292:	e001      	b.n	801b298 <ppp_vslprintf+0x234>
	    } else
		val = i;
 801b294:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b296:	64fb      	str	r3, [r7, #76]	; 0x4c
	    base = 10;
 801b298:	230a      	movs	r3, #10
 801b29a:	65bb      	str	r3, [r7, #88]	; 0x58
	    break;
 801b29c:	e1e1      	b.n	801b662 <ppp_vslprintf+0x5fe>
	case 'u':
	    val = va_arg(args, unsigned int);
 801b29e:	683b      	ldr	r3, [r7, #0]
 801b2a0:	1d1a      	adds	r2, r3, #4
 801b2a2:	603a      	str	r2, [r7, #0]
 801b2a4:	681b      	ldr	r3, [r3, #0]
 801b2a6:	64fb      	str	r3, [r7, #76]	; 0x4c
	    base = 10;
 801b2a8:	230a      	movs	r3, #10
 801b2aa:	65bb      	str	r3, [r7, #88]	; 0x58
	    break;
 801b2ac:	e1d9      	b.n	801b662 <ppp_vslprintf+0x5fe>
	case 'o':
	    val = va_arg(args, unsigned int);
 801b2ae:	683b      	ldr	r3, [r7, #0]
 801b2b0:	1d1a      	adds	r2, r3, #4
 801b2b2:	603a      	str	r2, [r7, #0]
 801b2b4:	681b      	ldr	r3, [r3, #0]
 801b2b6:	64fb      	str	r3, [r7, #76]	; 0x4c
	    base = 8;
 801b2b8:	2308      	movs	r3, #8
 801b2ba:	65bb      	str	r3, [r7, #88]	; 0x58
	    break;
 801b2bc:	e1d1      	b.n	801b662 <ppp_vslprintf+0x5fe>
	case 'x':
	case 'X':
	    val = va_arg(args, unsigned int);
 801b2be:	683b      	ldr	r3, [r7, #0]
 801b2c0:	1d1a      	adds	r2, r3, #4
 801b2c2:	603a      	str	r2, [r7, #0]
 801b2c4:	681b      	ldr	r3, [r3, #0]
 801b2c6:	64fb      	str	r3, [r7, #76]	; 0x4c
	    base = 16;
 801b2c8:	2310      	movs	r3, #16
 801b2ca:	65bb      	str	r3, [r7, #88]	; 0x58
	    break;
 801b2cc:	e1c9      	b.n	801b662 <ppp_vslprintf+0x5fe>
	    base = 16;
	    neg = 2;
	    break;
#endif /* unused (and wrong on LLP64 systems) */
	case 's':
	    str = va_arg(args, char *);
 801b2ce:	683b      	ldr	r3, [r7, #0]
 801b2d0:	1d1a      	adds	r2, r3, #4
 801b2d2:	603a      	str	r2, [r7, #0]
 801b2d4:	681b      	ldr	r3, [r3, #0]
 801b2d6:	647b      	str	r3, [r7, #68]	; 0x44
	    break;
 801b2d8:	e1c3      	b.n	801b662 <ppp_vslprintf+0x5fe>
	case 'c':
	    num[0] = va_arg(args, int);
 801b2da:	683b      	ldr	r3, [r7, #0]
 801b2dc:	1d1a      	adds	r2, r3, #4
 801b2de:	603a      	str	r2, [r7, #0]
 801b2e0:	681b      	ldr	r3, [r3, #0]
 801b2e2:	b2da      	uxtb	r2, r3
 801b2e4:	2110      	movs	r1, #16
 801b2e6:	187b      	adds	r3, r7, r1
 801b2e8:	701a      	strb	r2, [r3, #0]
	    num[1] = 0;
 801b2ea:	187b      	adds	r3, r7, r1
 801b2ec:	2200      	movs	r2, #0
 801b2ee:	705a      	strb	r2, [r3, #1]
	    str = num;
 801b2f0:	187b      	adds	r3, r7, r1
 801b2f2:	647b      	str	r3, [r7, #68]	; 0x44
	    break;
 801b2f4:	e1b5      	b.n	801b662 <ppp_vslprintf+0x5fe>
	case 'm':
	    str = strerror(errno);
	    break;
#endif /* do we always have strerror() in embedded ? */
	case 'I':
	    ip = va_arg(args, u32_t);
 801b2f6:	683b      	ldr	r3, [r7, #0]
 801b2f8:	1d1a      	adds	r2, r3, #4
 801b2fa:	603a      	str	r2, [r7, #0]
 801b2fc:	681b      	ldr	r3, [r3, #0]
 801b2fe:	633b      	str	r3, [r7, #48]	; 0x30
	    ip = lwip_ntohl(ip);
 801b300:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b302:	0018      	movs	r0, r3
 801b304:	f7eb fe0c 	bl	8006f20 <lwip_htonl>
 801b308:	0003      	movs	r3, r0
 801b30a:	633b      	str	r3, [r7, #48]	; 0x30
	    ppp_slprintf(num, sizeof(num), "%d.%d.%d.%d", (ip >> 24) & 0xff,
 801b30c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b30e:	0e1d      	lsrs	r5, r3, #24
		     (ip >> 16) & 0xff, (ip >> 8) & 0xff, ip & 0xff);
 801b310:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b312:	0c1b      	lsrs	r3, r3, #16
	    ppp_slprintf(num, sizeof(num), "%d.%d.%d.%d", (ip >> 24) & 0xff,
 801b314:	22ff      	movs	r2, #255	; 0xff
 801b316:	4013      	ands	r3, r2
		     (ip >> 16) & 0xff, (ip >> 8) & 0xff, ip & 0xff);
 801b318:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801b31a:	0a12      	lsrs	r2, r2, #8
	    ppp_slprintf(num, sizeof(num), "%d.%d.%d.%d", (ip >> 24) & 0xff,
 801b31c:	21ff      	movs	r1, #255	; 0xff
 801b31e:	400a      	ands	r2, r1
 801b320:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801b322:	20ff      	movs	r0, #255	; 0xff
 801b324:	4001      	ands	r1, r0
 801b326:	4c5f      	ldr	r4, [pc, #380]	; (801b4a4 <ppp_vslprintf+0x440>)
 801b328:	2610      	movs	r6, #16
 801b32a:	19b8      	adds	r0, r7, r6
 801b32c:	9102      	str	r1, [sp, #8]
 801b32e:	9201      	str	r2, [sp, #4]
 801b330:	9300      	str	r3, [sp, #0]
 801b332:	002b      	movs	r3, r5
 801b334:	0022      	movs	r2, r4
 801b336:	2120      	movs	r1, #32
 801b338:	f7ff fe7a 	bl	801b030 <ppp_slprintf>
	    str = num;
 801b33c:	19bb      	adds	r3, r7, r6
 801b33e:	647b      	str	r3, [r7, #68]	; 0x44
	    break;
 801b340:	e18f      	b.n	801b662 <ppp_vslprintf+0x5fe>
	    str[15] = 0;	/* chop off year and newline */
	    break;
#endif /* need port */
	case 'v':		/* "visible" string */
	case 'q':		/* quoted string */
	    quoted = c == 'q';
 801b342:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b344:	3b71      	subs	r3, #113	; 0x71
 801b346:	425a      	negs	r2, r3
 801b348:	4153      	adcs	r3, r2
 801b34a:	b2db      	uxtb	r3, r3
 801b34c:	63bb      	str	r3, [r7, #56]	; 0x38
	    p = va_arg(args, unsigned char *);
 801b34e:	683b      	ldr	r3, [r7, #0]
 801b350:	1d1a      	adds	r2, r3, #4
 801b352:	603a      	str	r2, [r7, #0]
 801b354:	681b      	ldr	r3, [r3, #0]
 801b356:	643b      	str	r3, [r7, #64]	; 0x40
	    if (p == NULL)
 801b358:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b35a:	2b00      	cmp	r3, #0
 801b35c:	d101      	bne.n	801b362 <ppp_vslprintf+0x2fe>
		p = (const unsigned char *)"<NULL>";
 801b35e:	4b52      	ldr	r3, [pc, #328]	; (801b4a8 <ppp_vslprintf+0x444>)
 801b360:	643b      	str	r3, [r7, #64]	; 0x40
	    if (fillch == '0' && prec >= 0) {
 801b362:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801b364:	2b30      	cmp	r3, #48	; 0x30
 801b366:	d105      	bne.n	801b374 <ppp_vslprintf+0x310>
 801b368:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801b36a:	2b00      	cmp	r3, #0
 801b36c:	db02      	blt.n	801b374 <ppp_vslprintf+0x310>
		n = prec;
 801b36e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801b370:	66bb      	str	r3, [r7, #104]	; 0x68
 801b372:	e010      	b.n	801b396 <ppp_vslprintf+0x332>
	    } else {
		n = strlen((const char *)p);
 801b374:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b376:	0018      	movs	r0, r3
 801b378:	f7e4 fec6 	bl	8000108 <strlen>
 801b37c:	0003      	movs	r3, r0
 801b37e:	66bb      	str	r3, [r7, #104]	; 0x68
		if (prec >= 0 && n > prec)
 801b380:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801b382:	2b00      	cmp	r3, #0
 801b384:	da00      	bge.n	801b388 <ppp_vslprintf+0x324>
 801b386:	e113      	b.n	801b5b0 <ppp_vslprintf+0x54c>
 801b388:	6eba      	ldr	r2, [r7, #104]	; 0x68
 801b38a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801b38c:	429a      	cmp	r2, r3
 801b38e:	dc00      	bgt.n	801b392 <ppp_vslprintf+0x32e>
 801b390:	e10e      	b.n	801b5b0 <ppp_vslprintf+0x54c>
		    n = prec;
 801b392:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801b394:	66bb      	str	r3, [r7, #104]	; 0x68
	    }
	    while (n > 0 && buflen > 0) {
 801b396:	e10b      	b.n	801b5b0 <ppp_vslprintf+0x54c>
		c = *p++;
 801b398:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b39a:	1c5a      	adds	r2, r3, #1
 801b39c:	643a      	str	r2, [r7, #64]	; 0x40
 801b39e:	781b      	ldrb	r3, [r3, #0]
 801b3a0:	66fb      	str	r3, [r7, #108]	; 0x6c
		--n;
 801b3a2:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801b3a4:	3b01      	subs	r3, #1
 801b3a6:	66bb      	str	r3, [r7, #104]	; 0x68
		if (!quoted && c >= 0x80) {
 801b3a8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b3aa:	2b00      	cmp	r3, #0
 801b3ac:	d11b      	bne.n	801b3e6 <ppp_vslprintf+0x382>
 801b3ae:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b3b0:	2b7f      	cmp	r3, #127	; 0x7f
 801b3b2:	dd18      	ble.n	801b3e6 <ppp_vslprintf+0x382>
		    OUTCHAR('M');
 801b3b4:	68bb      	ldr	r3, [r7, #8]
 801b3b6:	2b00      	cmp	r3, #0
 801b3b8:	dd07      	ble.n	801b3ca <ppp_vslprintf+0x366>
 801b3ba:	68bb      	ldr	r3, [r7, #8]
 801b3bc:	3b01      	subs	r3, #1
 801b3be:	60bb      	str	r3, [r7, #8]
 801b3c0:	68fb      	ldr	r3, [r7, #12]
 801b3c2:	1c5a      	adds	r2, r3, #1
 801b3c4:	60fa      	str	r2, [r7, #12]
 801b3c6:	224d      	movs	r2, #77	; 0x4d
 801b3c8:	701a      	strb	r2, [r3, #0]
		    OUTCHAR('-');
 801b3ca:	68bb      	ldr	r3, [r7, #8]
 801b3cc:	2b00      	cmp	r3, #0
 801b3ce:	dd07      	ble.n	801b3e0 <ppp_vslprintf+0x37c>
 801b3d0:	68bb      	ldr	r3, [r7, #8]
 801b3d2:	3b01      	subs	r3, #1
 801b3d4:	60bb      	str	r3, [r7, #8]
 801b3d6:	68fb      	ldr	r3, [r7, #12]
 801b3d8:	1c5a      	adds	r2, r3, #1
 801b3da:	60fa      	str	r2, [r7, #12]
 801b3dc:	222d      	movs	r2, #45	; 0x2d
 801b3de:	701a      	strb	r2, [r3, #0]
		    c -= 0x80;
 801b3e0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b3e2:	3b80      	subs	r3, #128	; 0x80
 801b3e4:	66fb      	str	r3, [r7, #108]	; 0x6c
		}
		if (quoted && (c == '"' || c == '\\'))
 801b3e6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b3e8:	2b00      	cmp	r3, #0
 801b3ea:	d010      	beq.n	801b40e <ppp_vslprintf+0x3aa>
 801b3ec:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b3ee:	2b22      	cmp	r3, #34	; 0x22
 801b3f0:	d002      	beq.n	801b3f8 <ppp_vslprintf+0x394>
 801b3f2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b3f4:	2b5c      	cmp	r3, #92	; 0x5c
 801b3f6:	d10a      	bne.n	801b40e <ppp_vslprintf+0x3aa>
		    OUTCHAR('\\');
 801b3f8:	68bb      	ldr	r3, [r7, #8]
 801b3fa:	2b00      	cmp	r3, #0
 801b3fc:	dd07      	ble.n	801b40e <ppp_vslprintf+0x3aa>
 801b3fe:	68bb      	ldr	r3, [r7, #8]
 801b400:	3b01      	subs	r3, #1
 801b402:	60bb      	str	r3, [r7, #8]
 801b404:	68fb      	ldr	r3, [r7, #12]
 801b406:	1c5a      	adds	r2, r3, #1
 801b408:	60fa      	str	r2, [r7, #12]
 801b40a:	225c      	movs	r2, #92	; 0x5c
 801b40c:	701a      	strb	r2, [r3, #0]
		if (c < 0x20 || (0x7f <= c && c < 0xa0)) {
 801b40e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b410:	2b1f      	cmp	r3, #31
 801b412:	dd07      	ble.n	801b424 <ppp_vslprintf+0x3c0>
 801b414:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b416:	2b7e      	cmp	r3, #126	; 0x7e
 801b418:	dc00      	bgt.n	801b41c <ppp_vslprintf+0x3b8>
 801b41a:	e0bd      	b.n	801b598 <ppp_vslprintf+0x534>
 801b41c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b41e:	2b9f      	cmp	r3, #159	; 0x9f
 801b420:	dd00      	ble.n	801b424 <ppp_vslprintf+0x3c0>
 801b422:	e0b9      	b.n	801b598 <ppp_vslprintf+0x534>
		    if (quoted) {
 801b424:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b426:	2b00      	cmp	r3, #0
 801b428:	d100      	bne.n	801b42c <ppp_vslprintf+0x3c8>
 801b42a:	e081      	b.n	801b530 <ppp_vslprintf+0x4cc>
			OUTCHAR('\\');
 801b42c:	68bb      	ldr	r3, [r7, #8]
 801b42e:	2b00      	cmp	r3, #0
 801b430:	dd07      	ble.n	801b442 <ppp_vslprintf+0x3de>
 801b432:	68bb      	ldr	r3, [r7, #8]
 801b434:	3b01      	subs	r3, #1
 801b436:	60bb      	str	r3, [r7, #8]
 801b438:	68fb      	ldr	r3, [r7, #12]
 801b43a:	1c5a      	adds	r2, r3, #1
 801b43c:	60fa      	str	r2, [r7, #12]
 801b43e:	225c      	movs	r2, #92	; 0x5c
 801b440:	701a      	strb	r2, [r3, #0]
 801b442:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b444:	2b0c      	cmp	r3, #12
 801b446:	d03e      	beq.n	801b4c6 <ppp_vslprintf+0x462>
 801b448:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b44a:	2b0c      	cmp	r3, #12
 801b44c:	dc47      	bgt.n	801b4de <ppp_vslprintf+0x47a>
 801b44e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b450:	2b0a      	cmp	r3, #10
 801b452:	d015      	beq.n	801b480 <ppp_vslprintf+0x41c>
 801b454:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b456:	2b0a      	cmp	r3, #10
 801b458:	dc41      	bgt.n	801b4de <ppp_vslprintf+0x47a>
 801b45a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b45c:	2b08      	cmp	r3, #8
 801b45e:	d025      	beq.n	801b4ac <ppp_vslprintf+0x448>
 801b460:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b462:	2b09      	cmp	r3, #9
 801b464:	d13b      	bne.n	801b4de <ppp_vslprintf+0x47a>
			switch (c) {
			case '\t':	OUTCHAR('t');	break;
 801b466:	68bb      	ldr	r3, [r7, #8]
 801b468:	2b00      	cmp	r3, #0
 801b46a:	dc00      	bgt.n	801b46e <ppp_vslprintf+0x40a>
 801b46c:	e08c      	b.n	801b588 <ppp_vslprintf+0x524>
 801b46e:	68bb      	ldr	r3, [r7, #8]
 801b470:	3b01      	subs	r3, #1
 801b472:	60bb      	str	r3, [r7, #8]
 801b474:	68fb      	ldr	r3, [r7, #12]
 801b476:	1c5a      	adds	r2, r3, #1
 801b478:	60fa      	str	r2, [r7, #12]
 801b47a:	2274      	movs	r2, #116	; 0x74
 801b47c:	701a      	strb	r2, [r3, #0]
 801b47e:	e083      	b.n	801b588 <ppp_vslprintf+0x524>
			case '\n':	OUTCHAR('n');	break;
 801b480:	68bb      	ldr	r3, [r7, #8]
 801b482:	2b00      	cmp	r3, #0
 801b484:	dc00      	bgt.n	801b488 <ppp_vslprintf+0x424>
 801b486:	e081      	b.n	801b58c <ppp_vslprintf+0x528>
 801b488:	68bb      	ldr	r3, [r7, #8]
 801b48a:	3b01      	subs	r3, #1
 801b48c:	60bb      	str	r3, [r7, #8]
 801b48e:	68fb      	ldr	r3, [r7, #12]
 801b490:	1c5a      	adds	r2, r3, #1
 801b492:	60fa      	str	r2, [r7, #12]
 801b494:	226e      	movs	r2, #110	; 0x6e
 801b496:	701a      	strb	r2, [r3, #0]
 801b498:	e078      	b.n	801b58c <ppp_vslprintf+0x528>
 801b49a:	46c0      	nop			; (mov r8, r8)
 801b49c:	08022e64 	.word	0x08022e64
 801b4a0:	08022d48 	.word	0x08022d48
 801b4a4:	08021fb8 	.word	0x08021fb8
 801b4a8:	08021fc4 	.word	0x08021fc4
			case '\b':	OUTCHAR('b');	break;
 801b4ac:	68bb      	ldr	r3, [r7, #8]
 801b4ae:	2b00      	cmp	r3, #0
 801b4b0:	dc00      	bgt.n	801b4b4 <ppp_vslprintf+0x450>
 801b4b2:	e06d      	b.n	801b590 <ppp_vslprintf+0x52c>
 801b4b4:	68bb      	ldr	r3, [r7, #8]
 801b4b6:	3b01      	subs	r3, #1
 801b4b8:	60bb      	str	r3, [r7, #8]
 801b4ba:	68fb      	ldr	r3, [r7, #12]
 801b4bc:	1c5a      	adds	r2, r3, #1
 801b4be:	60fa      	str	r2, [r7, #12]
 801b4c0:	2262      	movs	r2, #98	; 0x62
 801b4c2:	701a      	strb	r2, [r3, #0]
 801b4c4:	e064      	b.n	801b590 <ppp_vslprintf+0x52c>
			case '\f':	OUTCHAR('f');	break;
 801b4c6:	68bb      	ldr	r3, [r7, #8]
 801b4c8:	2b00      	cmp	r3, #0
 801b4ca:	dd63      	ble.n	801b594 <ppp_vslprintf+0x530>
 801b4cc:	68bb      	ldr	r3, [r7, #8]
 801b4ce:	3b01      	subs	r3, #1
 801b4d0:	60bb      	str	r3, [r7, #8]
 801b4d2:	68fb      	ldr	r3, [r7, #12]
 801b4d4:	1c5a      	adds	r2, r3, #1
 801b4d6:	60fa      	str	r2, [r7, #12]
 801b4d8:	2266      	movs	r2, #102	; 0x66
 801b4da:	701a      	strb	r2, [r3, #0]
 801b4dc:	e05a      	b.n	801b594 <ppp_vslprintf+0x530>
			default:
			    OUTCHAR('x');
 801b4de:	68bb      	ldr	r3, [r7, #8]
 801b4e0:	2b00      	cmp	r3, #0
 801b4e2:	dd07      	ble.n	801b4f4 <ppp_vslprintf+0x490>
 801b4e4:	68bb      	ldr	r3, [r7, #8]
 801b4e6:	3b01      	subs	r3, #1
 801b4e8:	60bb      	str	r3, [r7, #8]
 801b4ea:	68fb      	ldr	r3, [r7, #12]
 801b4ec:	1c5a      	adds	r2, r3, #1
 801b4ee:	60fa      	str	r2, [r7, #12]
 801b4f0:	2278      	movs	r2, #120	; 0x78
 801b4f2:	701a      	strb	r2, [r3, #0]
			    OUTCHAR(hexchars[c >> 4]);
 801b4f4:	68bb      	ldr	r3, [r7, #8]
 801b4f6:	2b00      	cmp	r3, #0
 801b4f8:	dd0a      	ble.n	801b510 <ppp_vslprintf+0x4ac>
 801b4fa:	68bb      	ldr	r3, [r7, #8]
 801b4fc:	3b01      	subs	r3, #1
 801b4fe:	60bb      	str	r3, [r7, #8]
 801b500:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b502:	111a      	asrs	r2, r3, #4
 801b504:	68fb      	ldr	r3, [r7, #12]
 801b506:	1c59      	adds	r1, r3, #1
 801b508:	60f9      	str	r1, [r7, #12]
 801b50a:	49ac      	ldr	r1, [pc, #688]	; (801b7bc <ppp_vslprintf+0x758>)
 801b50c:	5c8a      	ldrb	r2, [r1, r2]
 801b50e:	701a      	strb	r2, [r3, #0]
			    OUTCHAR(hexchars[c & 0xf]);
 801b510:	68bb      	ldr	r3, [r7, #8]
 801b512:	2b00      	cmp	r3, #0
 801b514:	dd4c      	ble.n	801b5b0 <ppp_vslprintf+0x54c>
 801b516:	68bb      	ldr	r3, [r7, #8]
 801b518:	3b01      	subs	r3, #1
 801b51a:	60bb      	str	r3, [r7, #8]
 801b51c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b51e:	220f      	movs	r2, #15
 801b520:	401a      	ands	r2, r3
 801b522:	68fb      	ldr	r3, [r7, #12]
 801b524:	1c59      	adds	r1, r3, #1
 801b526:	60f9      	str	r1, [r7, #12]
 801b528:	49a4      	ldr	r1, [pc, #656]	; (801b7bc <ppp_vslprintf+0x758>)
 801b52a:	5c8a      	ldrb	r2, [r1, r2]
 801b52c:	701a      	strb	r2, [r3, #0]
 801b52e:	e03f      	b.n	801b5b0 <ppp_vslprintf+0x54c>
			}
		    } else {
			if (c == '\t')
 801b530:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b532:	2b09      	cmp	r3, #9
 801b534:	d10c      	bne.n	801b550 <ppp_vslprintf+0x4ec>
			    OUTCHAR(c);
 801b536:	68bb      	ldr	r3, [r7, #8]
 801b538:	2b00      	cmp	r3, #0
 801b53a:	dd39      	ble.n	801b5b0 <ppp_vslprintf+0x54c>
 801b53c:	68bb      	ldr	r3, [r7, #8]
 801b53e:	3b01      	subs	r3, #1
 801b540:	60bb      	str	r3, [r7, #8]
 801b542:	68fb      	ldr	r3, [r7, #12]
 801b544:	1c5a      	adds	r2, r3, #1
 801b546:	60fa      	str	r2, [r7, #12]
 801b548:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801b54a:	b2d2      	uxtb	r2, r2
 801b54c:	701a      	strb	r2, [r3, #0]
 801b54e:	e02f      	b.n	801b5b0 <ppp_vslprintf+0x54c>
			else {
			    OUTCHAR('^');
 801b550:	68bb      	ldr	r3, [r7, #8]
 801b552:	2b00      	cmp	r3, #0
 801b554:	dd07      	ble.n	801b566 <ppp_vslprintf+0x502>
 801b556:	68bb      	ldr	r3, [r7, #8]
 801b558:	3b01      	subs	r3, #1
 801b55a:	60bb      	str	r3, [r7, #8]
 801b55c:	68fb      	ldr	r3, [r7, #12]
 801b55e:	1c5a      	adds	r2, r3, #1
 801b560:	60fa      	str	r2, [r7, #12]
 801b562:	225e      	movs	r2, #94	; 0x5e
 801b564:	701a      	strb	r2, [r3, #0]
			    OUTCHAR(c ^ 0x40);
 801b566:	68bb      	ldr	r3, [r7, #8]
 801b568:	2b00      	cmp	r3, #0
 801b56a:	dd21      	ble.n	801b5b0 <ppp_vslprintf+0x54c>
 801b56c:	68bb      	ldr	r3, [r7, #8]
 801b56e:	3b01      	subs	r3, #1
 801b570:	60bb      	str	r3, [r7, #8]
 801b572:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b574:	b25b      	sxtb	r3, r3
 801b576:	2240      	movs	r2, #64	; 0x40
 801b578:	4053      	eors	r3, r2
 801b57a:	b259      	sxtb	r1, r3
 801b57c:	68fb      	ldr	r3, [r7, #12]
 801b57e:	1c5a      	adds	r2, r3, #1
 801b580:	60fa      	str	r2, [r7, #12]
 801b582:	b2ca      	uxtb	r2, r1
 801b584:	701a      	strb	r2, [r3, #0]
 801b586:	e013      	b.n	801b5b0 <ppp_vslprintf+0x54c>
			case '\t':	OUTCHAR('t');	break;
 801b588:	46c0      	nop			; (mov r8, r8)
 801b58a:	e011      	b.n	801b5b0 <ppp_vslprintf+0x54c>
			case '\n':	OUTCHAR('n');	break;
 801b58c:	46c0      	nop			; (mov r8, r8)
 801b58e:	e00f      	b.n	801b5b0 <ppp_vslprintf+0x54c>
			case '\b':	OUTCHAR('b');	break;
 801b590:	46c0      	nop			; (mov r8, r8)
 801b592:	e00d      	b.n	801b5b0 <ppp_vslprintf+0x54c>
			case '\f':	OUTCHAR('f');	break;
 801b594:	46c0      	nop			; (mov r8, r8)
		    if (quoted) {
 801b596:	e00b      	b.n	801b5b0 <ppp_vslprintf+0x54c>
			}
		    }
		} else
		    OUTCHAR(c);
 801b598:	68bb      	ldr	r3, [r7, #8]
 801b59a:	2b00      	cmp	r3, #0
 801b59c:	dd08      	ble.n	801b5b0 <ppp_vslprintf+0x54c>
 801b59e:	68bb      	ldr	r3, [r7, #8]
 801b5a0:	3b01      	subs	r3, #1
 801b5a2:	60bb      	str	r3, [r7, #8]
 801b5a4:	68fb      	ldr	r3, [r7, #12]
 801b5a6:	1c5a      	adds	r2, r3, #1
 801b5a8:	60fa      	str	r2, [r7, #12]
 801b5aa:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801b5ac:	b2d2      	uxtb	r2, r2
 801b5ae:	701a      	strb	r2, [r3, #0]
	    while (n > 0 && buflen > 0) {
 801b5b0:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801b5b2:	2b00      	cmp	r3, #0
 801b5b4:	dc00      	bgt.n	801b5b8 <ppp_vslprintf+0x554>
 801b5b6:	e0f0      	b.n	801b79a <ppp_vslprintf+0x736>
 801b5b8:	68bb      	ldr	r3, [r7, #8]
 801b5ba:	2b00      	cmp	r3, #0
 801b5bc:	dd00      	ble.n	801b5c0 <ppp_vslprintf+0x55c>
 801b5be:	e6eb      	b.n	801b398 <ppp_vslprintf+0x334>
	    }
	    continue;
 801b5c0:	e0eb      	b.n	801b79a <ppp_vslprintf+0x736>
	    buf = bufinfo.ptr;
	    buflen = bufinfo.len - 1;
	    continue;
#endif /* PRINTPKT_SUPPORT */
	case 'B':
	    p = va_arg(args, unsigned char *);
 801b5c2:	683b      	ldr	r3, [r7, #0]
 801b5c4:	1d1a      	adds	r2, r3, #4
 801b5c6:	603a      	str	r2, [r7, #0]
 801b5c8:	681b      	ldr	r3, [r3, #0]
 801b5ca:	643b      	str	r3, [r7, #64]	; 0x40
	    for (n = prec; n > 0; --n) {
 801b5cc:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801b5ce:	66bb      	str	r3, [r7, #104]	; 0x68
 801b5d0:	e034      	b.n	801b63c <ppp_vslprintf+0x5d8>
		c = *p++;
 801b5d2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b5d4:	1c5a      	adds	r2, r3, #1
 801b5d6:	643a      	str	r2, [r7, #64]	; 0x40
 801b5d8:	781b      	ldrb	r3, [r3, #0]
 801b5da:	66fb      	str	r3, [r7, #108]	; 0x6c
		if (fillch == ' ')
 801b5dc:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801b5de:	2b20      	cmp	r3, #32
 801b5e0:	d10a      	bne.n	801b5f8 <ppp_vslprintf+0x594>
		    OUTCHAR(' ');
 801b5e2:	68bb      	ldr	r3, [r7, #8]
 801b5e4:	2b00      	cmp	r3, #0
 801b5e6:	dd07      	ble.n	801b5f8 <ppp_vslprintf+0x594>
 801b5e8:	68bb      	ldr	r3, [r7, #8]
 801b5ea:	3b01      	subs	r3, #1
 801b5ec:	60bb      	str	r3, [r7, #8]
 801b5ee:	68fb      	ldr	r3, [r7, #12]
 801b5f0:	1c5a      	adds	r2, r3, #1
 801b5f2:	60fa      	str	r2, [r7, #12]
 801b5f4:	2220      	movs	r2, #32
 801b5f6:	701a      	strb	r2, [r3, #0]
		OUTCHAR(hexchars[(c >> 4) & 0xf]);
 801b5f8:	68bb      	ldr	r3, [r7, #8]
 801b5fa:	2b00      	cmp	r3, #0
 801b5fc:	dd0c      	ble.n	801b618 <ppp_vslprintf+0x5b4>
 801b5fe:	68bb      	ldr	r3, [r7, #8]
 801b600:	3b01      	subs	r3, #1
 801b602:	60bb      	str	r3, [r7, #8]
 801b604:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b606:	111b      	asrs	r3, r3, #4
 801b608:	220f      	movs	r2, #15
 801b60a:	401a      	ands	r2, r3
 801b60c:	68fb      	ldr	r3, [r7, #12]
 801b60e:	1c59      	adds	r1, r3, #1
 801b610:	60f9      	str	r1, [r7, #12]
 801b612:	496a      	ldr	r1, [pc, #424]	; (801b7bc <ppp_vslprintf+0x758>)
 801b614:	5c8a      	ldrb	r2, [r1, r2]
 801b616:	701a      	strb	r2, [r3, #0]
		OUTCHAR(hexchars[c & 0xf]);
 801b618:	68bb      	ldr	r3, [r7, #8]
 801b61a:	2b00      	cmp	r3, #0
 801b61c:	dd0b      	ble.n	801b636 <ppp_vslprintf+0x5d2>
 801b61e:	68bb      	ldr	r3, [r7, #8]
 801b620:	3b01      	subs	r3, #1
 801b622:	60bb      	str	r3, [r7, #8]
 801b624:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b626:	220f      	movs	r2, #15
 801b628:	401a      	ands	r2, r3
 801b62a:	68fb      	ldr	r3, [r7, #12]
 801b62c:	1c59      	adds	r1, r3, #1
 801b62e:	60f9      	str	r1, [r7, #12]
 801b630:	4962      	ldr	r1, [pc, #392]	; (801b7bc <ppp_vslprintf+0x758>)
 801b632:	5c8a      	ldrb	r2, [r1, r2]
 801b634:	701a      	strb	r2, [r3, #0]
	    for (n = prec; n > 0; --n) {
 801b636:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801b638:	3b01      	subs	r3, #1
 801b63a:	66bb      	str	r3, [r7, #104]	; 0x68
 801b63c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801b63e:	2b00      	cmp	r3, #0
 801b640:	dcc7      	bgt.n	801b5d2 <ppp_vslprintf+0x56e>
	    }
	    continue;
 801b642:	e0aa      	b.n	801b79a <ppp_vslprintf+0x736>
	default:
	    *buf++ = '%';
 801b644:	68fb      	ldr	r3, [r7, #12]
 801b646:	1c5a      	adds	r2, r3, #1
 801b648:	60fa      	str	r2, [r7, #12]
 801b64a:	2225      	movs	r2, #37	; 0x25
 801b64c:	701a      	strb	r2, [r3, #0]
	    if (c != '%')
 801b64e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b650:	2b25      	cmp	r3, #37	; 0x25
 801b652:	d002      	beq.n	801b65a <ppp_vslprintf+0x5f6>
		--fmt;		/* so %z outputs %z etc. */
 801b654:	687b      	ldr	r3, [r7, #4]
 801b656:	3b01      	subs	r3, #1
 801b658:	607b      	str	r3, [r7, #4]
	    --buflen;
 801b65a:	68bb      	ldr	r3, [r7, #8]
 801b65c:	3b01      	subs	r3, #1
 801b65e:	60bb      	str	r3, [r7, #8]
	    continue;
 801b660:	e09b      	b.n	801b79a <ppp_vslprintf+0x736>
	}
	if (base != 0) {
 801b662:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801b664:	2b00      	cmp	r3, #0
 801b666:	d054      	beq.n	801b712 <ppp_vslprintf+0x6ae>
	    str = num + sizeof(num);
 801b668:	2310      	movs	r3, #16
 801b66a:	18fb      	adds	r3, r7, r3
 801b66c:	3320      	adds	r3, #32
 801b66e:	647b      	str	r3, [r7, #68]	; 0x44
	    *--str = 0;
 801b670:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b672:	3b01      	subs	r3, #1
 801b674:	647b      	str	r3, [r7, #68]	; 0x44
 801b676:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b678:	2200      	movs	r2, #0
 801b67a:	701a      	strb	r2, [r3, #0]
	    while (str > num + neg) {
 801b67c:	e01e      	b.n	801b6bc <ppp_vslprintf+0x658>
		*--str = hexchars[val % base];
 801b67e:	6dba      	ldr	r2, [r7, #88]	; 0x58
 801b680:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b682:	0011      	movs	r1, r2
 801b684:	0018      	movs	r0, r3
 801b686:	f7e4 fdd7 	bl	8000238 <__aeabi_uidivmod>
 801b68a:	000b      	movs	r3, r1
 801b68c:	001a      	movs	r2, r3
 801b68e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b690:	3b01      	subs	r3, #1
 801b692:	647b      	str	r3, [r7, #68]	; 0x44
 801b694:	4b49      	ldr	r3, [pc, #292]	; (801b7bc <ppp_vslprintf+0x758>)
 801b696:	5c9a      	ldrb	r2, [r3, r2]
 801b698:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b69a:	701a      	strb	r2, [r3, #0]
		val = val / base;
 801b69c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801b69e:	0019      	movs	r1, r3
 801b6a0:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 801b6a2:	f7e4 fd43 	bl	800012c <__udivsi3>
 801b6a6:	0003      	movs	r3, r0
 801b6a8:	64fb      	str	r3, [r7, #76]	; 0x4c
		if (--prec <= 0 && val == 0)
 801b6aa:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801b6ac:	3b01      	subs	r3, #1
 801b6ae:	663b      	str	r3, [r7, #96]	; 0x60
 801b6b0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801b6b2:	2b00      	cmp	r3, #0
 801b6b4:	dc02      	bgt.n	801b6bc <ppp_vslprintf+0x658>
 801b6b6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b6b8:	2b00      	cmp	r3, #0
 801b6ba:	d007      	beq.n	801b6cc <ppp_vslprintf+0x668>
	    while (str > num + neg) {
 801b6bc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801b6be:	2210      	movs	r2, #16
 801b6c0:	18ba      	adds	r2, r7, r2
 801b6c2:	18d3      	adds	r3, r2, r3
 801b6c4:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801b6c6:	429a      	cmp	r2, r3
 801b6c8:	d8d9      	bhi.n	801b67e <ppp_vslprintf+0x61a>
 801b6ca:	e000      	b.n	801b6ce <ppp_vslprintf+0x66a>
		    break;
 801b6cc:	46c0      	nop			; (mov r8, r8)
	    }
	    switch (neg) {
 801b6ce:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801b6d0:	2b01      	cmp	r3, #1
 801b6d2:	d003      	beq.n	801b6dc <ppp_vslprintf+0x678>
 801b6d4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801b6d6:	2b02      	cmp	r3, #2
 801b6d8:	d007      	beq.n	801b6ea <ppp_vslprintf+0x686>
	    case 2:
		*--str = 'x';
		*--str = '0';
		break;
	    default:
		break;
 801b6da:	e013      	b.n	801b704 <ppp_vslprintf+0x6a0>
		*--str = '-';
 801b6dc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b6de:	3b01      	subs	r3, #1
 801b6e0:	647b      	str	r3, [r7, #68]	; 0x44
 801b6e2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b6e4:	222d      	movs	r2, #45	; 0x2d
 801b6e6:	701a      	strb	r2, [r3, #0]
		break;
 801b6e8:	e00c      	b.n	801b704 <ppp_vslprintf+0x6a0>
		*--str = 'x';
 801b6ea:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b6ec:	3b01      	subs	r3, #1
 801b6ee:	647b      	str	r3, [r7, #68]	; 0x44
 801b6f0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b6f2:	2278      	movs	r2, #120	; 0x78
 801b6f4:	701a      	strb	r2, [r3, #0]
		*--str = '0';
 801b6f6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b6f8:	3b01      	subs	r3, #1
 801b6fa:	647b      	str	r3, [r7, #68]	; 0x44
 801b6fc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b6fe:	2230      	movs	r2, #48	; 0x30
 801b700:	701a      	strb	r2, [r3, #0]
		break;
 801b702:	46c0      	nop			; (mov r8, r8)
	    }
	    len = num + sizeof(num) - 1 - str;
 801b704:	2310      	movs	r3, #16
 801b706:	18fb      	adds	r3, r7, r3
 801b708:	331f      	adds	r3, #31
 801b70a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801b70c:	1a9b      	subs	r3, r3, r2
 801b70e:	657b      	str	r3, [r7, #84]	; 0x54
 801b710:	e00e      	b.n	801b730 <ppp_vslprintf+0x6cc>
	} else {
	    len = strlen(str);
 801b712:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b714:	0018      	movs	r0, r3
 801b716:	f7e4 fcf7 	bl	8000108 <strlen>
 801b71a:	0003      	movs	r3, r0
 801b71c:	657b      	str	r3, [r7, #84]	; 0x54
	    if (prec >= 0 && len > prec)
 801b71e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801b720:	2b00      	cmp	r3, #0
 801b722:	db05      	blt.n	801b730 <ppp_vslprintf+0x6cc>
 801b724:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801b726:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801b728:	429a      	cmp	r2, r3
 801b72a:	dd01      	ble.n	801b730 <ppp_vslprintf+0x6cc>
		len = prec;
 801b72c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801b72e:	657b      	str	r3, [r7, #84]	; 0x54
	}
	if (width > 0) {
 801b730:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801b732:	2b00      	cmp	r3, #0
 801b734:	dd1d      	ble.n	801b772 <ppp_vslprintf+0x70e>
	    if (width > buflen)
 801b736:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 801b738:	68bb      	ldr	r3, [r7, #8]
 801b73a:	429a      	cmp	r2, r3
 801b73c:	dd01      	ble.n	801b742 <ppp_vslprintf+0x6de>
		width = buflen;
 801b73e:	68bb      	ldr	r3, [r7, #8]
 801b740:	667b      	str	r3, [r7, #100]	; 0x64
	    if ((n = width - len) > 0) {
 801b742:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 801b744:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801b746:	1ad3      	subs	r3, r2, r3
 801b748:	66bb      	str	r3, [r7, #104]	; 0x68
 801b74a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801b74c:	2b00      	cmp	r3, #0
 801b74e:	dd10      	ble.n	801b772 <ppp_vslprintf+0x70e>
		buflen -= n;
 801b750:	68ba      	ldr	r2, [r7, #8]
 801b752:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801b754:	1ad3      	subs	r3, r2, r3
 801b756:	60bb      	str	r3, [r7, #8]
		for (; n > 0; --n)
 801b758:	e008      	b.n	801b76c <ppp_vslprintf+0x708>
		    *buf++ = fillch;
 801b75a:	68fb      	ldr	r3, [r7, #12]
 801b75c:	1c5a      	adds	r2, r3, #1
 801b75e:	60fa      	str	r2, [r7, #12]
 801b760:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 801b762:	b2d2      	uxtb	r2, r2
 801b764:	701a      	strb	r2, [r3, #0]
		for (; n > 0; --n)
 801b766:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801b768:	3b01      	subs	r3, #1
 801b76a:	66bb      	str	r3, [r7, #104]	; 0x68
 801b76c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801b76e:	2b00      	cmp	r3, #0
 801b770:	dcf3      	bgt.n	801b75a <ppp_vslprintf+0x6f6>
	    }
	}
	if (len > buflen)
 801b772:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801b774:	68bb      	ldr	r3, [r7, #8]
 801b776:	429a      	cmp	r2, r3
 801b778:	dd01      	ble.n	801b77e <ppp_vslprintf+0x71a>
	    len = buflen;
 801b77a:	68bb      	ldr	r3, [r7, #8]
 801b77c:	657b      	str	r3, [r7, #84]	; 0x54
	memcpy(buf, str, len);
 801b77e:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801b780:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801b782:	68fb      	ldr	r3, [r7, #12]
 801b784:	0018      	movs	r0, r3
 801b786:	f001 fba1 	bl	801cecc <memcpy>
	buf += len;
 801b78a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801b78c:	68fa      	ldr	r2, [r7, #12]
 801b78e:	18d3      	adds	r3, r2, r3
 801b790:	60fb      	str	r3, [r7, #12]
	buflen -= len;
 801b792:	68ba      	ldr	r2, [r7, #8]
 801b794:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801b796:	1ad3      	subs	r3, r2, r3
 801b798:	60bb      	str	r3, [r7, #8]
    while (buflen > 0) {
 801b79a:	68bb      	ldr	r3, [r7, #8]
 801b79c:	2b00      	cmp	r3, #0
 801b79e:	dd00      	ble.n	801b7a2 <ppp_vslprintf+0x73e>
 801b7a0:	e470      	b.n	801b084 <ppp_vslprintf+0x20>
 801b7a2:	e000      	b.n	801b7a6 <ppp_vslprintf+0x742>
	    break;
 801b7a4:	46c0      	nop			; (mov r8, r8)
    }
    *buf = 0;
 801b7a6:	68fb      	ldr	r3, [r7, #12]
 801b7a8:	2200      	movs	r2, #0
 801b7aa:	701a      	strb	r2, [r3, #0]
    return buf - buf0;
 801b7ac:	68fa      	ldr	r2, [r7, #12]
 801b7ae:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801b7b0:	1ad3      	subs	r3, r2, r3
}
 801b7b2:	0018      	movs	r0, r3
 801b7b4:	46bd      	mov	sp, r7
 801b7b6:	b01d      	add	sp, #116	; 0x74
 801b7b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801b7ba:	46c0      	nop			; (mov r8, r8)
 801b7bc:	20000024 	.word	0x20000024

0801b7c0 <ppp_logit>:
}

/*
 * ppp_logit - does the hard work for fatal et al.
 */
static void ppp_logit(int level, const char *fmt, va_list args) {
 801b7c0:	b590      	push	{r4, r7, lr}
 801b7c2:	4c0c      	ldr	r4, [pc, #48]	; (801b7f4 <ppp_logit+0x34>)
 801b7c4:	44a5      	add	sp, r4
 801b7c6:	af00      	add	r7, sp, #0
 801b7c8:	60f8      	str	r0, [r7, #12]
 801b7ca:	60b9      	str	r1, [r7, #8]
 801b7cc:	607a      	str	r2, [r7, #4]
    char buf[1024];

    ppp_vslprintf(buf, sizeof(buf), fmt, args);
 801b7ce:	687b      	ldr	r3, [r7, #4]
 801b7d0:	68ba      	ldr	r2, [r7, #8]
 801b7d2:	2180      	movs	r1, #128	; 0x80
 801b7d4:	00c9      	lsls	r1, r1, #3
 801b7d6:	2410      	movs	r4, #16
 801b7d8:	1938      	adds	r0, r7, r4
 801b7da:	f7ff fc43 	bl	801b064 <ppp_vslprintf>
    ppp_log_write(level, buf);
 801b7de:	193a      	adds	r2, r7, r4
 801b7e0:	68fb      	ldr	r3, [r7, #12]
 801b7e2:	0011      	movs	r1, r2
 801b7e4:	0018      	movs	r0, r3
 801b7e6:	f000 f809 	bl	801b7fc <ppp_log_write>
}
 801b7ea:	46c0      	nop			; (mov r8, r8)
 801b7ec:	46bd      	mov	sp, r7
 801b7ee:	4b02      	ldr	r3, [pc, #8]	; (801b7f8 <ppp_logit+0x38>)
 801b7f0:	449d      	add	sp, r3
 801b7f2:	bd90      	pop	{r4, r7, pc}
 801b7f4:	fffffbec 	.word	0xfffffbec
 801b7f8:	00000414 	.word	0x00000414

0801b7fc <ppp_log_write>:

static void ppp_log_write(int level, char *buf) {
 801b7fc:	b580      	push	{r7, lr}
 801b7fe:	b082      	sub	sp, #8
 801b800:	af00      	add	r7, sp, #0
 801b802:	6078      	str	r0, [r7, #4]
 801b804:	6039      	str	r1, [r7, #0]
	if (write(log_to_fd, buf, n) != n
	    || write(log_to_fd, "\n", 1) != 1)
	    log_to_fd = -1;
    }
#endif
}
 801b806:	46c0      	nop			; (mov r8, r8)
 801b808:	46bd      	mov	sp, r7
 801b80a:	b002      	add	sp, #8
 801b80c:	bd80      	pop	{r7, pc}

0801b80e <ppp_error>:
}

/*
 * ppp_error - log an error message.
 */
void ppp_error(const char *fmt, ...) {
 801b80e:	b40f      	push	{r0, r1, r2, r3}
 801b810:	b580      	push	{r7, lr}
 801b812:	b082      	sub	sp, #8
 801b814:	af00      	add	r7, sp, #0
    va_list pvar;

    va_start(pvar, fmt);
 801b816:	2314      	movs	r3, #20
 801b818:	18fb      	adds	r3, r7, r3
 801b81a:	607b      	str	r3, [r7, #4]
    ppp_logit(LOG_ERR, fmt, pvar);
 801b81c:	687a      	ldr	r2, [r7, #4]
 801b81e:	693b      	ldr	r3, [r7, #16]
 801b820:	0019      	movs	r1, r3
 801b822:	2003      	movs	r0, #3
 801b824:	f7ff ffcc 	bl	801b7c0 <ppp_logit>
    va_end(pvar);
#if 0 /* UNUSED */
    ++error_count;
#endif /* UNUSED */
}
 801b828:	46c0      	nop			; (mov r8, r8)
 801b82a:	46bd      	mov	sp, r7
 801b82c:	b002      	add	sp, #8
 801b82e:	bc80      	pop	{r7}
 801b830:	bc08      	pop	{r3}
 801b832:	b004      	add	sp, #16
 801b834:	4718      	bx	r3

0801b836 <ppp_warn>:

/*
 * ppp_warn - log a warning message.
 */
void ppp_warn(const char *fmt, ...) {
 801b836:	b40f      	push	{r0, r1, r2, r3}
 801b838:	b580      	push	{r7, lr}
 801b83a:	b082      	sub	sp, #8
 801b83c:	af00      	add	r7, sp, #0
    va_list pvar;

    va_start(pvar, fmt);
 801b83e:	2314      	movs	r3, #20
 801b840:	18fb      	adds	r3, r7, r3
 801b842:	607b      	str	r3, [r7, #4]
    ppp_logit(LOG_WARNING, fmt, pvar);
 801b844:	687a      	ldr	r2, [r7, #4]
 801b846:	693b      	ldr	r3, [r7, #16]
 801b848:	0019      	movs	r1, r3
 801b84a:	2001      	movs	r0, #1
 801b84c:	f7ff ffb8 	bl	801b7c0 <ppp_logit>
    va_end(pvar);
}
 801b850:	46c0      	nop			; (mov r8, r8)
 801b852:	46bd      	mov	sp, r7
 801b854:	b002      	add	sp, #8
 801b856:	bc80      	pop	{r7}
 801b858:	bc08      	pop	{r3}
 801b85a:	b004      	add	sp, #16
 801b85c:	4718      	bx	r3

0801b85e <ppp_notice>:

/*
 * ppp_notice - log a notice-level message.
 */
void ppp_notice(const char *fmt, ...) {
 801b85e:	b40f      	push	{r0, r1, r2, r3}
 801b860:	b580      	push	{r7, lr}
 801b862:	b082      	sub	sp, #8
 801b864:	af00      	add	r7, sp, #0
    va_list pvar;

    va_start(pvar, fmt);
 801b866:	2314      	movs	r3, #20
 801b868:	18fb      	adds	r3, r7, r3
 801b86a:	607b      	str	r3, [r7, #4]
    ppp_logit(LOG_NOTICE, fmt, pvar);
 801b86c:	687a      	ldr	r2, [r7, #4]
 801b86e:	693b      	ldr	r3, [r7, #16]
 801b870:	0019      	movs	r1, r3
 801b872:	2001      	movs	r0, #1
 801b874:	f7ff ffa4 	bl	801b7c0 <ppp_logit>
    va_end(pvar);
}
 801b878:	46c0      	nop			; (mov r8, r8)
 801b87a:	46bd      	mov	sp, r7
 801b87c:	b002      	add	sp, #8
 801b87e:	bc80      	pop	{r7}
 801b880:	bc08      	pop	{r3}
 801b882:	b004      	add	sp, #16
 801b884:	4718      	bx	r3

0801b886 <ppp_info>:

/*
 * ppp_info - log an informational message.
 */
void ppp_info(const char *fmt, ...) {
 801b886:	b40f      	push	{r0, r1, r2, r3}
 801b888:	b580      	push	{r7, lr}
 801b88a:	b082      	sub	sp, #8
 801b88c:	af00      	add	r7, sp, #0
    va_list pvar;

    va_start(pvar, fmt);
 801b88e:	2314      	movs	r3, #20
 801b890:	18fb      	adds	r3, r7, r3
 801b892:	607b      	str	r3, [r7, #4]
    ppp_logit(LOG_INFO, fmt, pvar);
 801b894:	687a      	ldr	r2, [r7, #4]
 801b896:	693b      	ldr	r3, [r7, #16]
 801b898:	0019      	movs	r1, r3
 801b89a:	2000      	movs	r0, #0
 801b89c:	f7ff ff90 	bl	801b7c0 <ppp_logit>
    va_end(pvar);
}
 801b8a0:	46c0      	nop			; (mov r8, r8)
 801b8a2:	46bd      	mov	sp, r7
 801b8a4:	b002      	add	sp, #8
 801b8a6:	bc80      	pop	{r7}
 801b8a8:	bc08      	pop	{r3}
 801b8aa:	b004      	add	sp, #16
 801b8ac:	4718      	bx	r3

0801b8ae <ppp_dbglog>:

/*
 * ppp_dbglog - log a debug message.
 */
void ppp_dbglog(const char *fmt, ...) {
 801b8ae:	b40f      	push	{r0, r1, r2, r3}
 801b8b0:	b580      	push	{r7, lr}
 801b8b2:	b082      	sub	sp, #8
 801b8b4:	af00      	add	r7, sp, #0
    va_list pvar;

    va_start(pvar, fmt);
 801b8b6:	2314      	movs	r3, #20
 801b8b8:	18fb      	adds	r3, r7, r3
 801b8ba:	607b      	str	r3, [r7, #4]
    ppp_logit(LOG_DEBUG, fmt, pvar);
 801b8bc:	687a      	ldr	r2, [r7, #4]
 801b8be:	693b      	ldr	r3, [r7, #16]
 801b8c0:	0019      	movs	r1, r3
 801b8c2:	2000      	movs	r0, #0
 801b8c4:	f7ff ff7c 	bl	801b7c0 <ppp_logit>
    va_end(pvar);
}
 801b8c8:	46c0      	nop			; (mov r8, r8)
 801b8ca:	46bd      	mov	sp, r7
 801b8cc:	b002      	add	sp, #8
 801b8ce:	bc80      	pop	{r7}
 801b8d0:	bc08      	pop	{r3}
 801b8d2:	b004      	add	sp, #16
 801b8d4:	4718      	bx	r3

0801b8d6 <vj_compress_init>:
#define INCR(counter)
#endif

void
vj_compress_init(struct vjcompress *comp)
{
 801b8d6:	b580      	push	{r7, lr}
 801b8d8:	b084      	sub	sp, #16
 801b8da:	af00      	add	r7, sp, #0
 801b8dc:	6078      	str	r0, [r7, #4]
  u8_t i;
  struct cstate *tstate = comp->tstate;
 801b8de:	687b      	ldr	r3, [r7, #4]
 801b8e0:	330c      	adds	r3, #12
 801b8e2:	60bb      	str	r3, [r7, #8]

#if MAX_SLOTS == 0
  memset((char *)comp, 0, sizeof(*comp));
#endif
  comp->maxSlotIndex = MAX_SLOTS - 1;
 801b8e4:	687b      	ldr	r3, [r7, #4]
 801b8e6:	220f      	movs	r2, #15
 801b8e8:	721a      	strb	r2, [r3, #8]
  comp->compressSlot = 0;    /* Disable slot ID compression by default. */
 801b8ea:	687b      	ldr	r3, [r7, #4]
 801b8ec:	2200      	movs	r2, #0
 801b8ee:	725a      	strb	r2, [r3, #9]
  for (i = MAX_SLOTS - 1; i > 0; --i) {
 801b8f0:	230f      	movs	r3, #15
 801b8f2:	18fb      	adds	r3, r7, r3
 801b8f4:	220f      	movs	r2, #15
 801b8f6:	701a      	strb	r2, [r3, #0]
 801b8f8:	e025      	b.n	801b946 <vj_compress_init+0x70>
    tstate[i].cs_id = i;
 801b8fa:	200f      	movs	r0, #15
 801b8fc:	183b      	adds	r3, r7, r0
 801b8fe:	781a      	ldrb	r2, [r3, #0]
 801b900:	0013      	movs	r3, r2
 801b902:	011b      	lsls	r3, r3, #4
 801b904:	189b      	adds	r3, r3, r2
 801b906:	00db      	lsls	r3, r3, #3
 801b908:	001a      	movs	r2, r3
 801b90a:	68bb      	ldr	r3, [r7, #8]
 801b90c:	189b      	adds	r3, r3, r2
 801b90e:	183a      	adds	r2, r7, r0
 801b910:	7812      	ldrb	r2, [r2, #0]
 801b912:	719a      	strb	r2, [r3, #6]
    tstate[i].cs_next = &tstate[i - 1];
 801b914:	183b      	adds	r3, r7, r0
 801b916:	781a      	ldrb	r2, [r3, #0]
 801b918:	0013      	movs	r3, r2
 801b91a:	011b      	lsls	r3, r3, #4
 801b91c:	189b      	adds	r3, r3, r2
 801b91e:	00db      	lsls	r3, r3, #3
 801b920:	3b88      	subs	r3, #136	; 0x88
 801b922:	0019      	movs	r1, r3
 801b924:	183b      	adds	r3, r7, r0
 801b926:	781a      	ldrb	r2, [r3, #0]
 801b928:	0013      	movs	r3, r2
 801b92a:	011b      	lsls	r3, r3, #4
 801b92c:	189b      	adds	r3, r3, r2
 801b92e:	00db      	lsls	r3, r3, #3
 801b930:	001a      	movs	r2, r3
 801b932:	68bb      	ldr	r3, [r7, #8]
 801b934:	189b      	adds	r3, r3, r2
 801b936:	68ba      	ldr	r2, [r7, #8]
 801b938:	1852      	adds	r2, r2, r1
 801b93a:	601a      	str	r2, [r3, #0]
  for (i = MAX_SLOTS - 1; i > 0; --i) {
 801b93c:	183b      	adds	r3, r7, r0
 801b93e:	183a      	adds	r2, r7, r0
 801b940:	7812      	ldrb	r2, [r2, #0]
 801b942:	3a01      	subs	r2, #1
 801b944:	701a      	strb	r2, [r3, #0]
 801b946:	230f      	movs	r3, #15
 801b948:	18fb      	adds	r3, r7, r3
 801b94a:	781b      	ldrb	r3, [r3, #0]
 801b94c:	2b00      	cmp	r3, #0
 801b94e:	d1d4      	bne.n	801b8fa <vj_compress_init+0x24>
  }
  tstate[0].cs_next = &tstate[MAX_SLOTS - 1];
 801b950:	68bb      	ldr	r3, [r7, #8]
 801b952:	22ff      	movs	r2, #255	; 0xff
 801b954:	00d2      	lsls	r2, r2, #3
 801b956:	189a      	adds	r2, r3, r2
 801b958:	68bb      	ldr	r3, [r7, #8]
 801b95a:	601a      	str	r2, [r3, #0]
  tstate[0].cs_id = 0;
 801b95c:	68bb      	ldr	r3, [r7, #8]
 801b95e:	2200      	movs	r2, #0
 801b960:	719a      	strb	r2, [r3, #6]
  comp->last_cs = &tstate[0];
 801b962:	687b      	ldr	r3, [r7, #4]
 801b964:	68ba      	ldr	r2, [r7, #8]
 801b966:	601a      	str	r2, [r3, #0]
  comp->last_recv = 255;
 801b968:	687b      	ldr	r3, [r7, #4]
 801b96a:	22ff      	movs	r2, #255	; 0xff
 801b96c:	711a      	strb	r2, [r3, #4]
  comp->last_xmit = 255;
 801b96e:	687b      	ldr	r3, [r7, #4]
 801b970:	22ff      	movs	r2, #255	; 0xff
 801b972:	715a      	strb	r2, [r3, #5]
  comp->flags = VJF_TOSS;
 801b974:	687b      	ldr	r3, [r7, #4]
 801b976:	2201      	movs	r2, #1
 801b978:	80da      	strh	r2, [r3, #6]
}
 801b97a:	46c0      	nop			; (mov r8, r8)
 801b97c:	46bd      	mov	sp, r7
 801b97e:	b004      	add	sp, #16
 801b980:	bd80      	pop	{r7, pc}
	...

0801b984 <vj_compress_tcp>:
 * Return the VJ type code indicating whether or not the packet was
 * compressed.
 */
u8_t
vj_compress_tcp(struct vjcompress *comp, struct pbuf **pb)
{
 801b984:	b5b0      	push	{r4, r5, r7, lr}
 801b986:	b094      	sub	sp, #80	; 0x50
 801b988:	af00      	add	r7, sp, #0
 801b98a:	6078      	str	r0, [r7, #4]
 801b98c:	6039      	str	r1, [r7, #0]
  struct pbuf *np = *pb;
 801b98e:	683b      	ldr	r3, [r7, #0]
 801b990:	681b      	ldr	r3, [r3, #0]
 801b992:	63fb      	str	r3, [r7, #60]	; 0x3c
  struct ip_hdr *ip = (struct ip_hdr *)np->payload;
 801b994:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801b996:	685b      	ldr	r3, [r3, #4]
 801b998:	63bb      	str	r3, [r7, #56]	; 0x38
  struct cstate *cs = comp->last_cs->cs_next;
 801b99a:	687b      	ldr	r3, [r7, #4]
 801b99c:	681b      	ldr	r3, [r3, #0]
 801b99e:	681b      	ldr	r3, [r3, #0]
 801b9a0:	64fb      	str	r3, [r7, #76]	; 0x4c
  u16_t ilen = IPH_HL(ip);
 801b9a2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b9a4:	781b      	ldrb	r3, [r3, #0]
 801b9a6:	b29a      	uxth	r2, r3
 801b9a8:	2336      	movs	r3, #54	; 0x36
 801b9aa:	18fb      	adds	r3, r7, r3
 801b9ac:	210f      	movs	r1, #15
 801b9ae:	400a      	ands	r2, r1
 801b9b0:	801a      	strh	r2, [r3, #0]
  u16_t hlen;
  struct tcp_hdr *oth;
  struct tcp_hdr *th;
  u16_t deltaS, deltaA = 0;
 801b9b2:	2348      	movs	r3, #72	; 0x48
 801b9b4:	18fb      	adds	r3, r7, r3
 801b9b6:	2200      	movs	r2, #0
 801b9b8:	801a      	strh	r2, [r3, #0]
  u32_t deltaL;
  u32_t changes = 0;
 801b9ba:	2300      	movs	r3, #0
 801b9bc:	647b      	str	r3, [r7, #68]	; 0x44
  u8_t new_seq[16];
  u8_t *cp = new_seq;
 801b9be:	230c      	movs	r3, #12
 801b9c0:	18fb      	adds	r3, r7, r3
 801b9c2:	643b      	str	r3, [r7, #64]	; 0x40

  /*
   * Check that the packet is IP proto TCP.
   */
  if (IPH_PROTO(ip) != IP_PROTO_TCP) {
 801b9c4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b9c6:	7a5b      	ldrb	r3, [r3, #9]
 801b9c8:	2b06      	cmp	r3, #6
 801b9ca:	d002      	beq.n	801b9d2 <vj_compress_tcp+0x4e>
    return (TYPE_IP);
 801b9cc:	2340      	movs	r3, #64	; 0x40
 801b9ce:	f000 fc53 	bl	801c278 <vj_compress_tcp+0x8f4>
  /*
   * Bail if this is an IP fragment or if the TCP packet isn't
   * `compressible' (i.e., ACK isn't set or some other control bit is
   * set).
   */
  if ((IPH_OFFSET(ip) & PP_HTONS(0x3fff)) || np->tot_len < 40) {
 801b9d2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b9d4:	799a      	ldrb	r2, [r3, #6]
 801b9d6:	79db      	ldrb	r3, [r3, #7]
 801b9d8:	021b      	lsls	r3, r3, #8
 801b9da:	4313      	orrs	r3, r2
 801b9dc:	b29b      	uxth	r3, r3
 801b9de:	001a      	movs	r2, r3
 801b9e0:	4b7c      	ldr	r3, [pc, #496]	; (801bbd4 <vj_compress_tcp+0x250>)
 801b9e2:	4013      	ands	r3, r2
 801b9e4:	d103      	bne.n	801b9ee <vj_compress_tcp+0x6a>
 801b9e6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801b9e8:	891b      	ldrh	r3, [r3, #8]
 801b9ea:	2b27      	cmp	r3, #39	; 0x27
 801b9ec:	d802      	bhi.n	801b9f4 <vj_compress_tcp+0x70>
    return (TYPE_IP);
 801b9ee:	2340      	movs	r3, #64	; 0x40
 801b9f0:	f000 fc42 	bl	801c278 <vj_compress_tcp+0x8f4>
  }
  th = (struct tcp_hdr *)&((struct vj_u32_t*)ip)[ilen];
 801b9f4:	2336      	movs	r3, #54	; 0x36
 801b9f6:	18fb      	adds	r3, r7, r3
 801b9f8:	881b      	ldrh	r3, [r3, #0]
 801b9fa:	009b      	lsls	r3, r3, #2
 801b9fc:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801b9fe:	18d3      	adds	r3, r2, r3
 801ba00:	633b      	str	r3, [r7, #48]	; 0x30
  if ((TCPH_FLAGS(th) & (TCP_SYN|TCP_FIN|TCP_RST|TCP_ACK)) != TCP_ACK) {
 801ba02:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ba04:	7b1a      	ldrb	r2, [r3, #12]
 801ba06:	7b5b      	ldrb	r3, [r3, #13]
 801ba08:	021b      	lsls	r3, r3, #8
 801ba0a:	4313      	orrs	r3, r2
 801ba0c:	b29b      	uxth	r3, r3
 801ba0e:	0018      	movs	r0, r3
 801ba10:	f7eb fa70 	bl	8006ef4 <lwip_htons>
 801ba14:	0003      	movs	r3, r0
 801ba16:	b2db      	uxtb	r3, r3
 801ba18:	001a      	movs	r2, r3
 801ba1a:	2317      	movs	r3, #23
 801ba1c:	4013      	ands	r3, r2
 801ba1e:	2b10      	cmp	r3, #16
 801ba20:	d002      	beq.n	801ba28 <vj_compress_tcp+0xa4>
    return (TYPE_IP);
 801ba22:	2340      	movs	r3, #64	; 0x40
 801ba24:	f000 fc28 	bl	801c278 <vj_compress_tcp+0x8f4>
  }

  /* Check that the TCP/IP headers are contained in the first buffer. */
  hlen = ilen + TCPH_HDRLEN(th);
 801ba28:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ba2a:	7b1a      	ldrb	r2, [r3, #12]
 801ba2c:	7b5b      	ldrb	r3, [r3, #13]
 801ba2e:	021b      	lsls	r3, r3, #8
 801ba30:	4313      	orrs	r3, r2
 801ba32:	b29b      	uxth	r3, r3
 801ba34:	0018      	movs	r0, r3
 801ba36:	f7eb fa5d 	bl	8006ef4 <lwip_htons>
 801ba3a:	0003      	movs	r3, r0
 801ba3c:	0b1b      	lsrs	r3, r3, #12
 801ba3e:	b299      	uxth	r1, r3
 801ba40:	202e      	movs	r0, #46	; 0x2e
 801ba42:	183b      	adds	r3, r7, r0
 801ba44:	2236      	movs	r2, #54	; 0x36
 801ba46:	18ba      	adds	r2, r7, r2
 801ba48:	8812      	ldrh	r2, [r2, #0]
 801ba4a:	188a      	adds	r2, r1, r2
 801ba4c:	801a      	strh	r2, [r3, #0]
  hlen <<= 2;
 801ba4e:	0001      	movs	r1, r0
 801ba50:	187b      	adds	r3, r7, r1
 801ba52:	187a      	adds	r2, r7, r1
 801ba54:	8812      	ldrh	r2, [r2, #0]
 801ba56:	0092      	lsls	r2, r2, #2
 801ba58:	801a      	strh	r2, [r3, #0]
  if (np->len < hlen) {
 801ba5a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801ba5c:	895b      	ldrh	r3, [r3, #10]
 801ba5e:	187a      	adds	r2, r7, r1
 801ba60:	8812      	ldrh	r2, [r2, #0]
 801ba62:	429a      	cmp	r2, r3
 801ba64:	d902      	bls.n	801ba6c <vj_compress_tcp+0xe8>
    PPPDEBUG(LOG_INFO, ("vj_compress_tcp: header len %d spans buffers\n", hlen));
    return (TYPE_IP);
 801ba66:	2340      	movs	r3, #64	; 0x40
 801ba68:	f000 fc06 	bl	801c278 <vj_compress_tcp+0x8f4>
  }

  /* TCP stack requires that we don't change the packet payload, therefore we copy
   * the whole packet before compression. */
  np = pbuf_clone(PBUF_RAW, PBUF_RAM, *pb);
 801ba6c:	683b      	ldr	r3, [r7, #0]
 801ba6e:	681a      	ldr	r2, [r3, #0]
 801ba70:	23a0      	movs	r3, #160	; 0xa0
 801ba72:	009b      	lsls	r3, r3, #2
 801ba74:	0019      	movs	r1, r3
 801ba76:	2000      	movs	r0, #0
 801ba78:	f7ee fefe 	bl	800a878 <pbuf_clone>
 801ba7c:	0003      	movs	r3, r0
 801ba7e:	63fb      	str	r3, [r7, #60]	; 0x3c
  if (!np) {
 801ba80:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801ba82:	2b00      	cmp	r3, #0
 801ba84:	d102      	bne.n	801ba8c <vj_compress_tcp+0x108>
    return (TYPE_IP);
 801ba86:	2340      	movs	r3, #64	; 0x40
 801ba88:	f000 fbf6 	bl	801c278 <vj_compress_tcp+0x8f4>
  }

  *pb = np;
 801ba8c:	683b      	ldr	r3, [r7, #0]
 801ba8e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801ba90:	601a      	str	r2, [r3, #0]
  ip = (struct ip_hdr *)np->payload;
 801ba92:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801ba94:	685b      	ldr	r3, [r3, #4]
 801ba96:	63bb      	str	r3, [r7, #56]	; 0x38
   * to locate (or create) the connection state.  Special case the
   * most recently used connection since it's most likely to be used
   * again & we don't have to do any reordering if it's used.
   */
  INCR(vjs_packets);
  if (!ip4_addr_cmp(&ip->src, &cs->cs_ip.src)
 801ba98:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801ba9a:	7b1a      	ldrb	r2, [r3, #12]
 801ba9c:	7b59      	ldrb	r1, [r3, #13]
 801ba9e:	0209      	lsls	r1, r1, #8
 801baa0:	430a      	orrs	r2, r1
 801baa2:	7b99      	ldrb	r1, [r3, #14]
 801baa4:	0409      	lsls	r1, r1, #16
 801baa6:	430a      	orrs	r2, r1
 801baa8:	7bdb      	ldrb	r3, [r3, #15]
 801baaa:	061b      	lsls	r3, r3, #24
 801baac:	4313      	orrs	r3, r2
 801baae:	001a      	movs	r2, r3
 801bab0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bab2:	695b      	ldr	r3, [r3, #20]
 801bab4:	429a      	cmp	r2, r3
 801bab6:	d131      	bne.n	801bb1c <vj_compress_tcp+0x198>
      || !ip4_addr_cmp(&ip->dest, &cs->cs_ip.dest)
 801bab8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801baba:	7c1a      	ldrb	r2, [r3, #16]
 801babc:	7c59      	ldrb	r1, [r3, #17]
 801babe:	0209      	lsls	r1, r1, #8
 801bac0:	430a      	orrs	r2, r1
 801bac2:	7c99      	ldrb	r1, [r3, #18]
 801bac4:	0409      	lsls	r1, r1, #16
 801bac6:	430a      	orrs	r2, r1
 801bac8:	7cdb      	ldrb	r3, [r3, #19]
 801baca:	061b      	lsls	r3, r3, #24
 801bacc:	4313      	orrs	r3, r2
 801bace:	001a      	movs	r2, r3
 801bad0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bad2:	699b      	ldr	r3, [r3, #24]
 801bad4:	429a      	cmp	r2, r3
 801bad6:	d121      	bne.n	801bb1c <vj_compress_tcp+0x198>
      || (*(struct vj_u32_t*)th).v != (((struct vj_u32_t*)&cs->cs_ip)[IPH_HL(&cs->cs_ip)]).v) {
 801bad8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801bada:	781a      	ldrb	r2, [r3, #0]
 801badc:	7859      	ldrb	r1, [r3, #1]
 801bade:	0209      	lsls	r1, r1, #8
 801bae0:	430a      	orrs	r2, r1
 801bae2:	7899      	ldrb	r1, [r3, #2]
 801bae4:	0409      	lsls	r1, r1, #16
 801bae6:	430a      	orrs	r2, r1
 801bae8:	78db      	ldrb	r3, [r3, #3]
 801baea:	061b      	lsls	r3, r3, #24
 801baec:	4313      	orrs	r3, r2
 801baee:	0018      	movs	r0, r3
 801baf0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801baf2:	3308      	adds	r3, #8
 801baf4:	001a      	movs	r2, r3
 801baf6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801baf8:	7a1b      	ldrb	r3, [r3, #8]
 801bafa:	0019      	movs	r1, r3
 801bafc:	230f      	movs	r3, #15
 801bafe:	400b      	ands	r3, r1
 801bb00:	009b      	lsls	r3, r3, #2
 801bb02:	18d3      	adds	r3, r2, r3
 801bb04:	781a      	ldrb	r2, [r3, #0]
 801bb06:	7859      	ldrb	r1, [r3, #1]
 801bb08:	0209      	lsls	r1, r1, #8
 801bb0a:	430a      	orrs	r2, r1
 801bb0c:	7899      	ldrb	r1, [r3, #2]
 801bb0e:	0409      	lsls	r1, r1, #16
 801bb10:	430a      	orrs	r2, r1
 801bb12:	78db      	ldrb	r3, [r3, #3]
 801bb14:	061b      	lsls	r3, r3, #24
 801bb16:	4313      	orrs	r3, r2
 801bb18:	4298      	cmp	r0, r3
 801bb1a:	d068      	beq.n	801bbee <vj_compress_tcp+0x26a>
     * we want is almost always near the front, we locate
     * states via linear search.  If we don't find a state
     * for the datagram, the oldest state is (re-)used.
     */
    struct cstate *lcs;
    struct cstate *lastcs = comp->last_cs;
 801bb1c:	687b      	ldr	r3, [r7, #4]
 801bb1e:	681b      	ldr	r3, [r3, #0]
 801bb20:	62bb      	str	r3, [r7, #40]	; 0x28

    do {
      lcs = cs; cs = cs->cs_next;
 801bb22:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bb24:	627b      	str	r3, [r7, #36]	; 0x24
 801bb26:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bb28:	681b      	ldr	r3, [r3, #0]
 801bb2a:	64fb      	str	r3, [r7, #76]	; 0x4c
      INCR(vjs_searches);
      if (ip4_addr_cmp(&ip->src, &cs->cs_ip.src)
 801bb2c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801bb2e:	7b1a      	ldrb	r2, [r3, #12]
 801bb30:	7b59      	ldrb	r1, [r3, #13]
 801bb32:	0209      	lsls	r1, r1, #8
 801bb34:	430a      	orrs	r2, r1
 801bb36:	7b99      	ldrb	r1, [r3, #14]
 801bb38:	0409      	lsls	r1, r1, #16
 801bb3a:	430a      	orrs	r2, r1
 801bb3c:	7bdb      	ldrb	r3, [r3, #15]
 801bb3e:	061b      	lsls	r3, r3, #24
 801bb40:	4313      	orrs	r3, r2
 801bb42:	001a      	movs	r2, r3
 801bb44:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bb46:	695b      	ldr	r3, [r3, #20]
 801bb48:	429a      	cmp	r2, r3
 801bb4a:	d131      	bne.n	801bbb0 <vj_compress_tcp+0x22c>
          && ip4_addr_cmp(&ip->dest, &cs->cs_ip.dest)
 801bb4c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801bb4e:	7c1a      	ldrb	r2, [r3, #16]
 801bb50:	7c59      	ldrb	r1, [r3, #17]
 801bb52:	0209      	lsls	r1, r1, #8
 801bb54:	430a      	orrs	r2, r1
 801bb56:	7c99      	ldrb	r1, [r3, #18]
 801bb58:	0409      	lsls	r1, r1, #16
 801bb5a:	430a      	orrs	r2, r1
 801bb5c:	7cdb      	ldrb	r3, [r3, #19]
 801bb5e:	061b      	lsls	r3, r3, #24
 801bb60:	4313      	orrs	r3, r2
 801bb62:	001a      	movs	r2, r3
 801bb64:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bb66:	699b      	ldr	r3, [r3, #24]
 801bb68:	429a      	cmp	r2, r3
 801bb6a:	d121      	bne.n	801bbb0 <vj_compress_tcp+0x22c>
          && (*(struct vj_u32_t*)th).v == (((struct vj_u32_t*)&cs->cs_ip)[IPH_HL(&cs->cs_ip)]).v) {
 801bb6c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801bb6e:	781a      	ldrb	r2, [r3, #0]
 801bb70:	7859      	ldrb	r1, [r3, #1]
 801bb72:	0209      	lsls	r1, r1, #8
 801bb74:	430a      	orrs	r2, r1
 801bb76:	7899      	ldrb	r1, [r3, #2]
 801bb78:	0409      	lsls	r1, r1, #16
 801bb7a:	430a      	orrs	r2, r1
 801bb7c:	78db      	ldrb	r3, [r3, #3]
 801bb7e:	061b      	lsls	r3, r3, #24
 801bb80:	4313      	orrs	r3, r2
 801bb82:	0018      	movs	r0, r3
 801bb84:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bb86:	3308      	adds	r3, #8
 801bb88:	001a      	movs	r2, r3
 801bb8a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bb8c:	7a1b      	ldrb	r3, [r3, #8]
 801bb8e:	0019      	movs	r1, r3
 801bb90:	230f      	movs	r3, #15
 801bb92:	400b      	ands	r3, r1
 801bb94:	009b      	lsls	r3, r3, #2
 801bb96:	18d3      	adds	r3, r2, r3
 801bb98:	781a      	ldrb	r2, [r3, #0]
 801bb9a:	7859      	ldrb	r1, [r3, #1]
 801bb9c:	0209      	lsls	r1, r1, #8
 801bb9e:	430a      	orrs	r2, r1
 801bba0:	7899      	ldrb	r1, [r3, #2]
 801bba2:	0409      	lsls	r1, r1, #16
 801bba4:	430a      	orrs	r2, r1
 801bba6:	78db      	ldrb	r3, [r3, #3]
 801bba8:	061b      	lsls	r3, r3, #24
 801bbaa:	4313      	orrs	r3, r2
 801bbac:	4298      	cmp	r0, r3
 801bbae:	d007      	beq.n	801bbc0 <vj_compress_tcp+0x23c>
        goto found;
      }
    } while (cs != lastcs);
 801bbb0:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801bbb2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801bbb4:	429a      	cmp	r2, r3
 801bbb6:	d1b4      	bne.n	801bb22 <vj_compress_tcp+0x19e>
     * Note that since the state list is circular, the oldest
     * state points to the newest and we only need to set
     * last_cs to update the lru linkage.
     */
    INCR(vjs_misses);
    comp->last_cs = lcs;
 801bbb8:	687b      	ldr	r3, [r7, #4]
 801bbba:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801bbbc:	601a      	str	r2, [r3, #0]
    goto uncompressed;
 801bbbe:	e348      	b.n	801c252 <vj_compress_tcp+0x8ce>
        goto found;
 801bbc0:	46c0      	nop			; (mov r8, r8)

    found:
    /*
     * Found it -- move to the front on the connection list.
     */
    if (cs == lastcs) {
 801bbc2:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801bbc4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801bbc6:	429a      	cmp	r2, r3
 801bbc8:	d106      	bne.n	801bbd8 <vj_compress_tcp+0x254>
      comp->last_cs = lcs;
 801bbca:	687b      	ldr	r3, [r7, #4]
 801bbcc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801bbce:	601a      	str	r2, [r3, #0]
 801bbd0:	e00d      	b.n	801bbee <vj_compress_tcp+0x26a>
 801bbd2:	46c0      	nop			; (mov r8, r8)
 801bbd4:	0000ff3f 	.word	0x0000ff3f
    } else {
      lcs->cs_next = cs->cs_next;
 801bbd8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bbda:	681a      	ldr	r2, [r3, #0]
 801bbdc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801bbde:	601a      	str	r2, [r3, #0]
      cs->cs_next = lastcs->cs_next;
 801bbe0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801bbe2:	681a      	ldr	r2, [r3, #0]
 801bbe4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bbe6:	601a      	str	r2, [r3, #0]
      lastcs->cs_next = cs;
 801bbe8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801bbea:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801bbec:	601a      	str	r2, [r3, #0]
    }
  }

  oth = (struct tcp_hdr *)&((struct vj_u32_t*)&cs->cs_ip)[ilen];
 801bbee:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bbf0:	3308      	adds	r3, #8
 801bbf2:	001a      	movs	r2, r3
 801bbf4:	2136      	movs	r1, #54	; 0x36
 801bbf6:	187b      	adds	r3, r7, r1
 801bbf8:	881b      	ldrh	r3, [r3, #0]
 801bbfa:	009b      	lsls	r3, r3, #2
 801bbfc:	18d3      	adds	r3, r2, r3
 801bbfe:	623b      	str	r3, [r7, #32]
  deltaS = ilen;
 801bc00:	254a      	movs	r5, #74	; 0x4a
 801bc02:	197b      	adds	r3, r7, r5
 801bc04:	187a      	adds	r2, r7, r1
 801bc06:	8812      	ldrh	r2, [r2, #0]
 801bc08:	801a      	strh	r2, [r3, #0]
   * header length.  The 5th line checks IP options, if any.  The 6th
   * line checks TCP options, if any.  If any of these things are
   * different between the previous & current datagram, we send the
   * current datagram `uncompressed'.
   */
  if ((((struct vj_u16_t*)ip)[0]).v != (((struct vj_u16_t*)&cs->cs_ip)[0]).v
 801bc0a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801bc0c:	781a      	ldrb	r2, [r3, #0]
 801bc0e:	785b      	ldrb	r3, [r3, #1]
 801bc10:	021b      	lsls	r3, r3, #8
 801bc12:	4313      	orrs	r3, r2
 801bc14:	b29a      	uxth	r2, r3
 801bc16:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bc18:	3308      	adds	r3, #8
 801bc1a:	7819      	ldrb	r1, [r3, #0]
 801bc1c:	785b      	ldrb	r3, [r3, #1]
 801bc1e:	021b      	lsls	r3, r3, #8
 801bc20:	430b      	orrs	r3, r1
 801bc22:	b29b      	uxth	r3, r3
 801bc24:	429a      	cmp	r2, r3
 801bc26:	d000      	beq.n	801bc2a <vj_compress_tcp+0x2a6>
 801bc28:	e30a      	b.n	801c240 <vj_compress_tcp+0x8bc>
      || (((struct vj_u16_t*)ip)[3]).v != (((struct vj_u16_t*)&cs->cs_ip)[3]).v
 801bc2a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801bc2c:	3306      	adds	r3, #6
 801bc2e:	781a      	ldrb	r2, [r3, #0]
 801bc30:	785b      	ldrb	r3, [r3, #1]
 801bc32:	021b      	lsls	r3, r3, #8
 801bc34:	4313      	orrs	r3, r2
 801bc36:	b29a      	uxth	r2, r3
 801bc38:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bc3a:	3308      	adds	r3, #8
 801bc3c:	3306      	adds	r3, #6
 801bc3e:	7819      	ldrb	r1, [r3, #0]
 801bc40:	785b      	ldrb	r3, [r3, #1]
 801bc42:	021b      	lsls	r3, r3, #8
 801bc44:	430b      	orrs	r3, r1
 801bc46:	b29b      	uxth	r3, r3
 801bc48:	429a      	cmp	r2, r3
 801bc4a:	d000      	beq.n	801bc4e <vj_compress_tcp+0x2ca>
 801bc4c:	e2f8      	b.n	801c240 <vj_compress_tcp+0x8bc>
      || (((struct vj_u16_t*)ip)[4]).v != (((struct vj_u16_t*)&cs->cs_ip)[4]).v
 801bc4e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801bc50:	3308      	adds	r3, #8
 801bc52:	781a      	ldrb	r2, [r3, #0]
 801bc54:	785b      	ldrb	r3, [r3, #1]
 801bc56:	021b      	lsls	r3, r3, #8
 801bc58:	4313      	orrs	r3, r2
 801bc5a:	b29a      	uxth	r2, r3
 801bc5c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bc5e:	3308      	adds	r3, #8
 801bc60:	3308      	adds	r3, #8
 801bc62:	7819      	ldrb	r1, [r3, #0]
 801bc64:	785b      	ldrb	r3, [r3, #1]
 801bc66:	021b      	lsls	r3, r3, #8
 801bc68:	430b      	orrs	r3, r1
 801bc6a:	b29b      	uxth	r3, r3
 801bc6c:	429a      	cmp	r2, r3
 801bc6e:	d000      	beq.n	801bc72 <vj_compress_tcp+0x2ee>
 801bc70:	e2e6      	b.n	801c240 <vj_compress_tcp+0x8bc>
      || TCPH_HDRLEN(th) != TCPH_HDRLEN(oth)
 801bc72:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801bc74:	7b1a      	ldrb	r2, [r3, #12]
 801bc76:	7b5b      	ldrb	r3, [r3, #13]
 801bc78:	021b      	lsls	r3, r3, #8
 801bc7a:	4313      	orrs	r3, r2
 801bc7c:	b29b      	uxth	r3, r3
 801bc7e:	0018      	movs	r0, r3
 801bc80:	f7eb f938 	bl	8006ef4 <lwip_htons>
 801bc84:	0003      	movs	r3, r0
 801bc86:	0b1b      	lsrs	r3, r3, #12
 801bc88:	b29c      	uxth	r4, r3
 801bc8a:	6a3b      	ldr	r3, [r7, #32]
 801bc8c:	7b1a      	ldrb	r2, [r3, #12]
 801bc8e:	7b5b      	ldrb	r3, [r3, #13]
 801bc90:	021b      	lsls	r3, r3, #8
 801bc92:	4313      	orrs	r3, r2
 801bc94:	b29b      	uxth	r3, r3
 801bc96:	0018      	movs	r0, r3
 801bc98:	f7eb f92c 	bl	8006ef4 <lwip_htons>
 801bc9c:	0003      	movs	r3, r0
 801bc9e:	0b1b      	lsrs	r3, r3, #12
 801bca0:	b29b      	uxth	r3, r3
 801bca2:	429c      	cmp	r4, r3
 801bca4:	d000      	beq.n	801bca8 <vj_compress_tcp+0x324>
 801bca6:	e2cb      	b.n	801c240 <vj_compress_tcp+0x8bc>
      || (deltaS > 5 && BCMP(ip + 1, &cs->cs_ip + 1, (deltaS - 5) << 2))
 801bca8:	197b      	adds	r3, r7, r5
 801bcaa:	881b      	ldrh	r3, [r3, #0]
 801bcac:	2b05      	cmp	r3, #5
 801bcae:	d910      	bls.n	801bcd2 <vj_compress_tcp+0x34e>
 801bcb0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801bcb2:	3314      	adds	r3, #20
 801bcb4:	0018      	movs	r0, r3
 801bcb6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bcb8:	3308      	adds	r3, #8
 801bcba:	3314      	adds	r3, #20
 801bcbc:	0019      	movs	r1, r3
 801bcbe:	197b      	adds	r3, r7, r5
 801bcc0:	881b      	ldrh	r3, [r3, #0]
 801bcc2:	3b05      	subs	r3, #5
 801bcc4:	009b      	lsls	r3, r3, #2
 801bcc6:	001a      	movs	r2, r3
 801bcc8:	f001 f8f2 	bl	801ceb0 <memcmp>
 801bccc:	1e03      	subs	r3, r0, #0
 801bcce:	d000      	beq.n	801bcd2 <vj_compress_tcp+0x34e>
 801bcd0:	e2b6      	b.n	801c240 <vj_compress_tcp+0x8bc>
      || (TCPH_HDRLEN(th) > 5 && BCMP(th + 1, oth + 1, (TCPH_HDRLEN(th) - 5) << 2))) {
 801bcd2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801bcd4:	7b1a      	ldrb	r2, [r3, #12]
 801bcd6:	7b5b      	ldrb	r3, [r3, #13]
 801bcd8:	021b      	lsls	r3, r3, #8
 801bcda:	4313      	orrs	r3, r2
 801bcdc:	b29b      	uxth	r3, r3
 801bcde:	0018      	movs	r0, r3
 801bce0:	f7eb f908 	bl	8006ef4 <lwip_htons>
 801bce4:	0003      	movs	r3, r0
 801bce6:	0b1b      	lsrs	r3, r3, #12
 801bce8:	b29b      	uxth	r3, r3
 801bcea:	2b05      	cmp	r3, #5
 801bcec:	d91b      	bls.n	801bd26 <vj_compress_tcp+0x3a2>
 801bcee:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801bcf0:	3314      	adds	r3, #20
 801bcf2:	001c      	movs	r4, r3
 801bcf4:	6a3b      	ldr	r3, [r7, #32]
 801bcf6:	3314      	adds	r3, #20
 801bcf8:	001d      	movs	r5, r3
 801bcfa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801bcfc:	7b1a      	ldrb	r2, [r3, #12]
 801bcfe:	7b5b      	ldrb	r3, [r3, #13]
 801bd00:	021b      	lsls	r3, r3, #8
 801bd02:	4313      	orrs	r3, r2
 801bd04:	b29b      	uxth	r3, r3
 801bd06:	0018      	movs	r0, r3
 801bd08:	f7eb f8f4 	bl	8006ef4 <lwip_htons>
 801bd0c:	0003      	movs	r3, r0
 801bd0e:	0b1b      	lsrs	r3, r3, #12
 801bd10:	b29b      	uxth	r3, r3
 801bd12:	3b05      	subs	r3, #5
 801bd14:	009b      	lsls	r3, r3, #2
 801bd16:	001a      	movs	r2, r3
 801bd18:	0029      	movs	r1, r5
 801bd1a:	0020      	movs	r0, r4
 801bd1c:	f001 f8c8 	bl	801ceb0 <memcmp>
 801bd20:	1e03      	subs	r3, r0, #0
 801bd22:	d000      	beq.n	801bd26 <vj_compress_tcp+0x3a2>
 801bd24:	e28c      	b.n	801c240 <vj_compress_tcp+0x8bc>
   * Figure out which of the changing fields changed.  The
   * receiver expects changes in the order: urgent, window,
   * ack, seq (the order minimizes the number of temporaries
   * needed in this section of code).
   */
  if (TCPH_FLAGS(th) & TCP_URG) {
 801bd26:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801bd28:	7b1a      	ldrb	r2, [r3, #12]
 801bd2a:	7b5b      	ldrb	r3, [r3, #13]
 801bd2c:	021b      	lsls	r3, r3, #8
 801bd2e:	4313      	orrs	r3, r2
 801bd30:	b29b      	uxth	r3, r3
 801bd32:	0018      	movs	r0, r3
 801bd34:	f7eb f8de 	bl	8006ef4 <lwip_htons>
 801bd38:	0003      	movs	r3, r0
 801bd3a:	b2db      	uxtb	r3, r3
 801bd3c:	001a      	movs	r2, r3
 801bd3e:	2320      	movs	r3, #32
 801bd40:	4013      	ands	r3, r2
 801bd42:	d038      	beq.n	801bdb6 <vj_compress_tcp+0x432>
    deltaS = lwip_ntohs(th->urgp);
 801bd44:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801bd46:	7c9a      	ldrb	r2, [r3, #18]
 801bd48:	7cdb      	ldrb	r3, [r3, #19]
 801bd4a:	021b      	lsls	r3, r3, #8
 801bd4c:	4313      	orrs	r3, r2
 801bd4e:	b29b      	uxth	r3, r3
 801bd50:	254a      	movs	r5, #74	; 0x4a
 801bd52:	197c      	adds	r4, r7, r5
 801bd54:	0018      	movs	r0, r3
 801bd56:	f7eb f8cd 	bl	8006ef4 <lwip_htons>
 801bd5a:	0003      	movs	r3, r0
 801bd5c:	8023      	strh	r3, [r4, #0]
    ENCODEZ(deltaS);
 801bd5e:	197b      	adds	r3, r7, r5
 801bd60:	881b      	ldrh	r3, [r3, #0]
 801bd62:	2bff      	cmp	r3, #255	; 0xff
 801bd64:	d803      	bhi.n	801bd6e <vj_compress_tcp+0x3ea>
 801bd66:	197b      	adds	r3, r7, r5
 801bd68:	881b      	ldrh	r3, [r3, #0]
 801bd6a:	2b00      	cmp	r3, #0
 801bd6c:	d116      	bne.n	801bd9c <vj_compress_tcp+0x418>
 801bd6e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bd70:	1c5a      	adds	r2, r3, #1
 801bd72:	643a      	str	r2, [r7, #64]	; 0x40
 801bd74:	2200      	movs	r2, #0
 801bd76:	701a      	strb	r2, [r3, #0]
 801bd78:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bd7a:	3301      	adds	r3, #1
 801bd7c:	214a      	movs	r1, #74	; 0x4a
 801bd7e:	187a      	adds	r2, r7, r1
 801bd80:	8812      	ldrh	r2, [r2, #0]
 801bd82:	b2d2      	uxtb	r2, r2
 801bd84:	701a      	strb	r2, [r3, #0]
 801bd86:	187b      	adds	r3, r7, r1
 801bd88:	881b      	ldrh	r3, [r3, #0]
 801bd8a:	0a1b      	lsrs	r3, r3, #8
 801bd8c:	b29b      	uxth	r3, r3
 801bd8e:	b2da      	uxtb	r2, r3
 801bd90:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bd92:	701a      	strb	r2, [r3, #0]
 801bd94:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bd96:	3302      	adds	r3, #2
 801bd98:	643b      	str	r3, [r7, #64]	; 0x40
 801bd9a:	e007      	b.n	801bdac <vj_compress_tcp+0x428>
 801bd9c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bd9e:	1c5a      	adds	r2, r3, #1
 801bda0:	643a      	str	r2, [r7, #64]	; 0x40
 801bda2:	224a      	movs	r2, #74	; 0x4a
 801bda4:	18ba      	adds	r2, r7, r2
 801bda6:	8812      	ldrh	r2, [r2, #0]
 801bda8:	b2d2      	uxtb	r2, r2
 801bdaa:	701a      	strb	r2, [r3, #0]
    changes |= NEW_U;
 801bdac:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801bdae:	2201      	movs	r2, #1
 801bdb0:	4313      	orrs	r3, r2
 801bdb2:	647b      	str	r3, [r7, #68]	; 0x44
 801bdb4:	e00e      	b.n	801bdd4 <vj_compress_tcp+0x450>
  } else if (th->urgp != oth->urgp) {
 801bdb6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801bdb8:	7c9a      	ldrb	r2, [r3, #18]
 801bdba:	7cdb      	ldrb	r3, [r3, #19]
 801bdbc:	021b      	lsls	r3, r3, #8
 801bdbe:	4313      	orrs	r3, r2
 801bdc0:	b29a      	uxth	r2, r3
 801bdc2:	6a3b      	ldr	r3, [r7, #32]
 801bdc4:	7c99      	ldrb	r1, [r3, #18]
 801bdc6:	7cdb      	ldrb	r3, [r3, #19]
 801bdc8:	021b      	lsls	r3, r3, #8
 801bdca:	430b      	orrs	r3, r1
 801bdcc:	b29b      	uxth	r3, r3
 801bdce:	429a      	cmp	r2, r3
 801bdd0:	d000      	beq.n	801bdd4 <vj_compress_tcp+0x450>
 801bdd2:	e237      	b.n	801c244 <vj_compress_tcp+0x8c0>
     * doesn't prohibit the change so we have to deal
     * with it. */
    goto uncompressed;
  }

  if ((deltaS = (u16_t)(lwip_ntohs(th->wnd) - lwip_ntohs(oth->wnd))) != 0) {
 801bdd4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801bdd6:	7b9a      	ldrb	r2, [r3, #14]
 801bdd8:	7bdb      	ldrb	r3, [r3, #15]
 801bdda:	021b      	lsls	r3, r3, #8
 801bddc:	4313      	orrs	r3, r2
 801bdde:	b29b      	uxth	r3, r3
 801bde0:	0018      	movs	r0, r3
 801bde2:	f7eb f887 	bl	8006ef4 <lwip_htons>
 801bde6:	0003      	movs	r3, r0
 801bde8:	001c      	movs	r4, r3
 801bdea:	6a3b      	ldr	r3, [r7, #32]
 801bdec:	7b9a      	ldrb	r2, [r3, #14]
 801bdee:	7bdb      	ldrb	r3, [r3, #15]
 801bdf0:	021b      	lsls	r3, r3, #8
 801bdf2:	4313      	orrs	r3, r2
 801bdf4:	b29b      	uxth	r3, r3
 801bdf6:	0018      	movs	r0, r3
 801bdf8:	f7eb f87c 	bl	8006ef4 <lwip_htons>
 801bdfc:	0003      	movs	r3, r0
 801bdfe:	001a      	movs	r2, r3
 801be00:	214a      	movs	r1, #74	; 0x4a
 801be02:	187b      	adds	r3, r7, r1
 801be04:	1aa2      	subs	r2, r4, r2
 801be06:	801a      	strh	r2, [r3, #0]
 801be08:	187b      	adds	r3, r7, r1
 801be0a:	881b      	ldrh	r3, [r3, #0]
 801be0c:	2b00      	cmp	r3, #0
 801be0e:	d025      	beq.n	801be5c <vj_compress_tcp+0x4d8>
    ENCODE(deltaS);
 801be10:	187b      	adds	r3, r7, r1
 801be12:	881b      	ldrh	r3, [r3, #0]
 801be14:	2bff      	cmp	r3, #255	; 0xff
 801be16:	d915      	bls.n	801be44 <vj_compress_tcp+0x4c0>
 801be18:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801be1a:	1c5a      	adds	r2, r3, #1
 801be1c:	643a      	str	r2, [r7, #64]	; 0x40
 801be1e:	2200      	movs	r2, #0
 801be20:	701a      	strb	r2, [r3, #0]
 801be22:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801be24:	3301      	adds	r3, #1
 801be26:	187a      	adds	r2, r7, r1
 801be28:	8812      	ldrh	r2, [r2, #0]
 801be2a:	b2d2      	uxtb	r2, r2
 801be2c:	701a      	strb	r2, [r3, #0]
 801be2e:	187b      	adds	r3, r7, r1
 801be30:	881b      	ldrh	r3, [r3, #0]
 801be32:	0a1b      	lsrs	r3, r3, #8
 801be34:	b29b      	uxth	r3, r3
 801be36:	b2da      	uxtb	r2, r3
 801be38:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801be3a:	701a      	strb	r2, [r3, #0]
 801be3c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801be3e:	3302      	adds	r3, #2
 801be40:	643b      	str	r3, [r7, #64]	; 0x40
 801be42:	e007      	b.n	801be54 <vj_compress_tcp+0x4d0>
 801be44:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801be46:	1c5a      	adds	r2, r3, #1
 801be48:	643a      	str	r2, [r7, #64]	; 0x40
 801be4a:	224a      	movs	r2, #74	; 0x4a
 801be4c:	18ba      	adds	r2, r7, r2
 801be4e:	8812      	ldrh	r2, [r2, #0]
 801be50:	b2d2      	uxtb	r2, r2
 801be52:	701a      	strb	r2, [r3, #0]
    changes |= NEW_W;
 801be54:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801be56:	2202      	movs	r2, #2
 801be58:	4313      	orrs	r3, r2
 801be5a:	647b      	str	r3, [r7, #68]	; 0x44
  }

  if ((deltaL = lwip_ntohl(th->ackno) - lwip_ntohl(oth->ackno)) != 0) {
 801be5c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801be5e:	7a1a      	ldrb	r2, [r3, #8]
 801be60:	7a59      	ldrb	r1, [r3, #9]
 801be62:	0209      	lsls	r1, r1, #8
 801be64:	430a      	orrs	r2, r1
 801be66:	7a99      	ldrb	r1, [r3, #10]
 801be68:	0409      	lsls	r1, r1, #16
 801be6a:	430a      	orrs	r2, r1
 801be6c:	7adb      	ldrb	r3, [r3, #11]
 801be6e:	061b      	lsls	r3, r3, #24
 801be70:	4313      	orrs	r3, r2
 801be72:	0018      	movs	r0, r3
 801be74:	f7eb f854 	bl	8006f20 <lwip_htonl>
 801be78:	0004      	movs	r4, r0
 801be7a:	6a3b      	ldr	r3, [r7, #32]
 801be7c:	7a1a      	ldrb	r2, [r3, #8]
 801be7e:	7a59      	ldrb	r1, [r3, #9]
 801be80:	0209      	lsls	r1, r1, #8
 801be82:	430a      	orrs	r2, r1
 801be84:	7a99      	ldrb	r1, [r3, #10]
 801be86:	0409      	lsls	r1, r1, #16
 801be88:	430a      	orrs	r2, r1
 801be8a:	7adb      	ldrb	r3, [r3, #11]
 801be8c:	061b      	lsls	r3, r3, #24
 801be8e:	4313      	orrs	r3, r2
 801be90:	0018      	movs	r0, r3
 801be92:	f7eb f845 	bl	8006f20 <lwip_htonl>
 801be96:	0003      	movs	r3, r0
 801be98:	1ae3      	subs	r3, r4, r3
 801be9a:	61fb      	str	r3, [r7, #28]
 801be9c:	69fb      	ldr	r3, [r7, #28]
 801be9e:	2b00      	cmp	r3, #0
 801bea0:	d02f      	beq.n	801bf02 <vj_compress_tcp+0x57e>
    if (deltaL > 0xffff) {
 801bea2:	69fa      	ldr	r2, [r7, #28]
 801bea4:	2380      	movs	r3, #128	; 0x80
 801bea6:	025b      	lsls	r3, r3, #9
 801bea8:	429a      	cmp	r2, r3
 801beaa:	d300      	bcc.n	801beae <vj_compress_tcp+0x52a>
 801beac:	e1cc      	b.n	801c248 <vj_compress_tcp+0x8c4>
      goto uncompressed;
    }
    deltaA = (u16_t)deltaL;
 801beae:	2148      	movs	r1, #72	; 0x48
 801beb0:	187b      	adds	r3, r7, r1
 801beb2:	69fa      	ldr	r2, [r7, #28]
 801beb4:	801a      	strh	r2, [r3, #0]
    ENCODE(deltaA);
 801beb6:	187b      	adds	r3, r7, r1
 801beb8:	881b      	ldrh	r3, [r3, #0]
 801beba:	2bff      	cmp	r3, #255	; 0xff
 801bebc:	d915      	bls.n	801beea <vj_compress_tcp+0x566>
 801bebe:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bec0:	1c5a      	adds	r2, r3, #1
 801bec2:	643a      	str	r2, [r7, #64]	; 0x40
 801bec4:	2200      	movs	r2, #0
 801bec6:	701a      	strb	r2, [r3, #0]
 801bec8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801beca:	3301      	adds	r3, #1
 801becc:	187a      	adds	r2, r7, r1
 801bece:	8812      	ldrh	r2, [r2, #0]
 801bed0:	b2d2      	uxtb	r2, r2
 801bed2:	701a      	strb	r2, [r3, #0]
 801bed4:	187b      	adds	r3, r7, r1
 801bed6:	881b      	ldrh	r3, [r3, #0]
 801bed8:	0a1b      	lsrs	r3, r3, #8
 801beda:	b29b      	uxth	r3, r3
 801bedc:	b2da      	uxtb	r2, r3
 801bede:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bee0:	701a      	strb	r2, [r3, #0]
 801bee2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bee4:	3302      	adds	r3, #2
 801bee6:	643b      	str	r3, [r7, #64]	; 0x40
 801bee8:	e007      	b.n	801befa <vj_compress_tcp+0x576>
 801beea:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801beec:	1c5a      	adds	r2, r3, #1
 801beee:	643a      	str	r2, [r7, #64]	; 0x40
 801bef0:	2248      	movs	r2, #72	; 0x48
 801bef2:	18ba      	adds	r2, r7, r2
 801bef4:	8812      	ldrh	r2, [r2, #0]
 801bef6:	b2d2      	uxtb	r2, r2
 801bef8:	701a      	strb	r2, [r3, #0]
    changes |= NEW_A;
 801befa:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801befc:	2204      	movs	r2, #4
 801befe:	4313      	orrs	r3, r2
 801bf00:	647b      	str	r3, [r7, #68]	; 0x44
  }

  if ((deltaL = lwip_ntohl(th->seqno) - lwip_ntohl(oth->seqno)) != 0) {
 801bf02:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801bf04:	791a      	ldrb	r2, [r3, #4]
 801bf06:	7959      	ldrb	r1, [r3, #5]
 801bf08:	0209      	lsls	r1, r1, #8
 801bf0a:	430a      	orrs	r2, r1
 801bf0c:	7999      	ldrb	r1, [r3, #6]
 801bf0e:	0409      	lsls	r1, r1, #16
 801bf10:	430a      	orrs	r2, r1
 801bf12:	79db      	ldrb	r3, [r3, #7]
 801bf14:	061b      	lsls	r3, r3, #24
 801bf16:	4313      	orrs	r3, r2
 801bf18:	0018      	movs	r0, r3
 801bf1a:	f7eb f801 	bl	8006f20 <lwip_htonl>
 801bf1e:	0004      	movs	r4, r0
 801bf20:	6a3b      	ldr	r3, [r7, #32]
 801bf22:	791a      	ldrb	r2, [r3, #4]
 801bf24:	7959      	ldrb	r1, [r3, #5]
 801bf26:	0209      	lsls	r1, r1, #8
 801bf28:	430a      	orrs	r2, r1
 801bf2a:	7999      	ldrb	r1, [r3, #6]
 801bf2c:	0409      	lsls	r1, r1, #16
 801bf2e:	430a      	orrs	r2, r1
 801bf30:	79db      	ldrb	r3, [r3, #7]
 801bf32:	061b      	lsls	r3, r3, #24
 801bf34:	4313      	orrs	r3, r2
 801bf36:	0018      	movs	r0, r3
 801bf38:	f7ea fff2 	bl	8006f20 <lwip_htonl>
 801bf3c:	0003      	movs	r3, r0
 801bf3e:	1ae3      	subs	r3, r4, r3
 801bf40:	61fb      	str	r3, [r7, #28]
 801bf42:	69fb      	ldr	r3, [r7, #28]
 801bf44:	2b00      	cmp	r3, #0
 801bf46:	d02f      	beq.n	801bfa8 <vj_compress_tcp+0x624>
    if (deltaL > 0xffff) {
 801bf48:	69fa      	ldr	r2, [r7, #28]
 801bf4a:	2380      	movs	r3, #128	; 0x80
 801bf4c:	025b      	lsls	r3, r3, #9
 801bf4e:	429a      	cmp	r2, r3
 801bf50:	d300      	bcc.n	801bf54 <vj_compress_tcp+0x5d0>
 801bf52:	e17b      	b.n	801c24c <vj_compress_tcp+0x8c8>
      goto uncompressed;
    }
    deltaS = (u16_t)deltaL;
 801bf54:	214a      	movs	r1, #74	; 0x4a
 801bf56:	187b      	adds	r3, r7, r1
 801bf58:	69fa      	ldr	r2, [r7, #28]
 801bf5a:	801a      	strh	r2, [r3, #0]
    ENCODE(deltaS);
 801bf5c:	187b      	adds	r3, r7, r1
 801bf5e:	881b      	ldrh	r3, [r3, #0]
 801bf60:	2bff      	cmp	r3, #255	; 0xff
 801bf62:	d915      	bls.n	801bf90 <vj_compress_tcp+0x60c>
 801bf64:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bf66:	1c5a      	adds	r2, r3, #1
 801bf68:	643a      	str	r2, [r7, #64]	; 0x40
 801bf6a:	2200      	movs	r2, #0
 801bf6c:	701a      	strb	r2, [r3, #0]
 801bf6e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bf70:	3301      	adds	r3, #1
 801bf72:	187a      	adds	r2, r7, r1
 801bf74:	8812      	ldrh	r2, [r2, #0]
 801bf76:	b2d2      	uxtb	r2, r2
 801bf78:	701a      	strb	r2, [r3, #0]
 801bf7a:	187b      	adds	r3, r7, r1
 801bf7c:	881b      	ldrh	r3, [r3, #0]
 801bf7e:	0a1b      	lsrs	r3, r3, #8
 801bf80:	b29b      	uxth	r3, r3
 801bf82:	b2da      	uxtb	r2, r3
 801bf84:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bf86:	701a      	strb	r2, [r3, #0]
 801bf88:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bf8a:	3302      	adds	r3, #2
 801bf8c:	643b      	str	r3, [r7, #64]	; 0x40
 801bf8e:	e007      	b.n	801bfa0 <vj_compress_tcp+0x61c>
 801bf90:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bf92:	1c5a      	adds	r2, r3, #1
 801bf94:	643a      	str	r2, [r7, #64]	; 0x40
 801bf96:	224a      	movs	r2, #74	; 0x4a
 801bf98:	18ba      	adds	r2, r7, r2
 801bf9a:	8812      	ldrh	r2, [r2, #0]
 801bf9c:	b2d2      	uxtb	r2, r2
 801bf9e:	701a      	strb	r2, [r3, #0]
    changes |= NEW_S;
 801bfa0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801bfa2:	2208      	movs	r2, #8
 801bfa4:	4313      	orrs	r3, r2
 801bfa6:	647b      	str	r3, [r7, #68]	; 0x44
 801bfa8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801bfaa:	2b0f      	cmp	r3, #15
 801bfac:	d851      	bhi.n	801c052 <vj_compress_tcp+0x6ce>
 801bfae:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801bfb0:	009a      	lsls	r2, r3, #2
 801bfb2:	4bb3      	ldr	r3, [pc, #716]	; (801c280 <vj_compress_tcp+0x8fc>)
 801bfb4:	18d3      	adds	r3, r2, r3
 801bfb6:	681b      	ldr	r3, [r3, #0]
 801bfb8:	469f      	mov	pc, r3
     * an ack (normal on an interactive connection) and we send
     * it compressed.  Otherwise it's probably a retransmit,
     * retransmitted ack or window probe.  Send it uncompressed
     * in case the other side missed the compressed version.
     */
    if (IPH_LEN(ip) != IPH_LEN(&cs->cs_ip) &&
 801bfba:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801bfbc:	789a      	ldrb	r2, [r3, #2]
 801bfbe:	78db      	ldrb	r3, [r3, #3]
 801bfc0:	021b      	lsls	r3, r3, #8
 801bfc2:	4313      	orrs	r3, r2
 801bfc4:	b29a      	uxth	r2, r3
 801bfc6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bfc8:	895b      	ldrh	r3, [r3, #10]
 801bfca:	429a      	cmp	r2, r3
 801bfcc:	d100      	bne.n	801bfd0 <vj_compress_tcp+0x64c>
 801bfce:	e13f      	b.n	801c250 <vj_compress_tcp+0x8cc>
      lwip_ntohs(IPH_LEN(&cs->cs_ip)) == hlen) {
 801bfd0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bfd2:	895b      	ldrh	r3, [r3, #10]
 801bfd4:	0018      	movs	r0, r3
 801bfd6:	f7ea ff8d 	bl	8006ef4 <lwip_htons>
 801bfda:	0003      	movs	r3, r0
 801bfdc:	001a      	movs	r2, r3
    if (IPH_LEN(ip) != IPH_LEN(&cs->cs_ip) &&
 801bfde:	232e      	movs	r3, #46	; 0x2e
 801bfe0:	18fb      	adds	r3, r7, r3
 801bfe2:	881b      	ldrh	r3, [r3, #0]
 801bfe4:	4293      	cmp	r3, r2
 801bfe6:	d000      	beq.n	801bfea <vj_compress_tcp+0x666>
 801bfe8:	e132      	b.n	801c250 <vj_compress_tcp+0x8cc>
      break;
 801bfea:	e037      	b.n	801c05c <vj_compress_tcp+0x6d8>
     * send packet uncompressed.
     */
    goto uncompressed;

  case NEW_S|NEW_A:
    if (deltaS == deltaA && deltaS == lwip_ntohs(IPH_LEN(&cs->cs_ip)) - hlen) {
 801bfec:	214a      	movs	r1, #74	; 0x4a
 801bfee:	187a      	adds	r2, r7, r1
 801bff0:	2348      	movs	r3, #72	; 0x48
 801bff2:	18fb      	adds	r3, r7, r3
 801bff4:	8812      	ldrh	r2, [r2, #0]
 801bff6:	881b      	ldrh	r3, [r3, #0]
 801bff8:	429a      	cmp	r2, r3
 801bffa:	d12c      	bne.n	801c056 <vj_compress_tcp+0x6d2>
 801bffc:	187b      	adds	r3, r7, r1
 801bffe:	881c      	ldrh	r4, [r3, #0]
 801c000:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c002:	895b      	ldrh	r3, [r3, #10]
 801c004:	0018      	movs	r0, r3
 801c006:	f7ea ff75 	bl	8006ef4 <lwip_htons>
 801c00a:	0003      	movs	r3, r0
 801c00c:	001a      	movs	r2, r3
 801c00e:	232e      	movs	r3, #46	; 0x2e
 801c010:	18fb      	adds	r3, r7, r3
 801c012:	881b      	ldrh	r3, [r3, #0]
 801c014:	1ad3      	subs	r3, r2, r3
 801c016:	429c      	cmp	r4, r3
 801c018:	d11d      	bne.n	801c056 <vj_compress_tcp+0x6d2>
      /* special case for echoed terminal traffic */
      changes = SPECIAL_I;
 801c01a:	230b      	movs	r3, #11
 801c01c:	647b      	str	r3, [r7, #68]	; 0x44
      cp = new_seq;
 801c01e:	230c      	movs	r3, #12
 801c020:	18fb      	adds	r3, r7, r3
 801c022:	643b      	str	r3, [r7, #64]	; 0x40
    }
    break;
 801c024:	e017      	b.n	801c056 <vj_compress_tcp+0x6d2>

  case NEW_S:
    if (deltaS == lwip_ntohs(IPH_LEN(&cs->cs_ip)) - hlen) {
 801c026:	234a      	movs	r3, #74	; 0x4a
 801c028:	18fb      	adds	r3, r7, r3
 801c02a:	881c      	ldrh	r4, [r3, #0]
 801c02c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c02e:	895b      	ldrh	r3, [r3, #10]
 801c030:	0018      	movs	r0, r3
 801c032:	f7ea ff5f 	bl	8006ef4 <lwip_htons>
 801c036:	0003      	movs	r3, r0
 801c038:	001a      	movs	r2, r3
 801c03a:	232e      	movs	r3, #46	; 0x2e
 801c03c:	18fb      	adds	r3, r7, r3
 801c03e:	881b      	ldrh	r3, [r3, #0]
 801c040:	1ad3      	subs	r3, r2, r3
 801c042:	429c      	cmp	r4, r3
 801c044:	d109      	bne.n	801c05a <vj_compress_tcp+0x6d6>
      /* special case for data xfer */
      changes = SPECIAL_D;
 801c046:	230f      	movs	r3, #15
 801c048:	647b      	str	r3, [r7, #68]	; 0x44
      cp = new_seq;
 801c04a:	230c      	movs	r3, #12
 801c04c:	18fb      	adds	r3, r7, r3
 801c04e:	643b      	str	r3, [r7, #64]	; 0x40
    }
    break;
 801c050:	e003      	b.n	801c05a <vj_compress_tcp+0x6d6>
  default:
     break;
 801c052:	46c0      	nop			; (mov r8, r8)
 801c054:	e002      	b.n	801c05c <vj_compress_tcp+0x6d8>
    break;
 801c056:	46c0      	nop			; (mov r8, r8)
 801c058:	e000      	b.n	801c05c <vj_compress_tcp+0x6d8>
    break;
 801c05a:	46c0      	nop			; (mov r8, r8)
  }

  deltaS = (u16_t)(lwip_ntohs(IPH_ID(ip)) - lwip_ntohs(IPH_ID(&cs->cs_ip)));
 801c05c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c05e:	791a      	ldrb	r2, [r3, #4]
 801c060:	795b      	ldrb	r3, [r3, #5]
 801c062:	021b      	lsls	r3, r3, #8
 801c064:	4313      	orrs	r3, r2
 801c066:	b29b      	uxth	r3, r3
 801c068:	0018      	movs	r0, r3
 801c06a:	f7ea ff43 	bl	8006ef4 <lwip_htons>
 801c06e:	0003      	movs	r3, r0
 801c070:	001c      	movs	r4, r3
 801c072:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c074:	899b      	ldrh	r3, [r3, #12]
 801c076:	0018      	movs	r0, r3
 801c078:	f7ea ff3c 	bl	8006ef4 <lwip_htons>
 801c07c:	0003      	movs	r3, r0
 801c07e:	001a      	movs	r2, r3
 801c080:	214a      	movs	r1, #74	; 0x4a
 801c082:	187b      	adds	r3, r7, r1
 801c084:	1aa2      	subs	r2, r4, r2
 801c086:	801a      	strh	r2, [r3, #0]
  if (deltaS != 1) {
 801c088:	187b      	adds	r3, r7, r1
 801c08a:	881b      	ldrh	r3, [r3, #0]
 801c08c:	2b01      	cmp	r3, #1
 801c08e:	d02a      	beq.n	801c0e6 <vj_compress_tcp+0x762>
    ENCODEZ(deltaS);
 801c090:	187b      	adds	r3, r7, r1
 801c092:	881b      	ldrh	r3, [r3, #0]
 801c094:	2bff      	cmp	r3, #255	; 0xff
 801c096:	d803      	bhi.n	801c0a0 <vj_compress_tcp+0x71c>
 801c098:	187b      	adds	r3, r7, r1
 801c09a:	881b      	ldrh	r3, [r3, #0]
 801c09c:	2b00      	cmp	r3, #0
 801c09e:	d116      	bne.n	801c0ce <vj_compress_tcp+0x74a>
 801c0a0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c0a2:	1c5a      	adds	r2, r3, #1
 801c0a4:	643a      	str	r2, [r7, #64]	; 0x40
 801c0a6:	2200      	movs	r2, #0
 801c0a8:	701a      	strb	r2, [r3, #0]
 801c0aa:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c0ac:	3301      	adds	r3, #1
 801c0ae:	214a      	movs	r1, #74	; 0x4a
 801c0b0:	187a      	adds	r2, r7, r1
 801c0b2:	8812      	ldrh	r2, [r2, #0]
 801c0b4:	b2d2      	uxtb	r2, r2
 801c0b6:	701a      	strb	r2, [r3, #0]
 801c0b8:	187b      	adds	r3, r7, r1
 801c0ba:	881b      	ldrh	r3, [r3, #0]
 801c0bc:	0a1b      	lsrs	r3, r3, #8
 801c0be:	b29b      	uxth	r3, r3
 801c0c0:	b2da      	uxtb	r2, r3
 801c0c2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c0c4:	701a      	strb	r2, [r3, #0]
 801c0c6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c0c8:	3302      	adds	r3, #2
 801c0ca:	643b      	str	r3, [r7, #64]	; 0x40
 801c0cc:	e007      	b.n	801c0de <vj_compress_tcp+0x75a>
 801c0ce:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c0d0:	1c5a      	adds	r2, r3, #1
 801c0d2:	643a      	str	r2, [r7, #64]	; 0x40
 801c0d4:	224a      	movs	r2, #74	; 0x4a
 801c0d6:	18ba      	adds	r2, r7, r2
 801c0d8:	8812      	ldrh	r2, [r2, #0]
 801c0da:	b2d2      	uxtb	r2, r2
 801c0dc:	701a      	strb	r2, [r3, #0]
    changes |= NEW_I;
 801c0de:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c0e0:	2220      	movs	r2, #32
 801c0e2:	4313      	orrs	r3, r2
 801c0e4:	647b      	str	r3, [r7, #68]	; 0x44
  }
  if (TCPH_FLAGS(th) & TCP_PSH) {
 801c0e6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c0e8:	7b1a      	ldrb	r2, [r3, #12]
 801c0ea:	7b5b      	ldrb	r3, [r3, #13]
 801c0ec:	021b      	lsls	r3, r3, #8
 801c0ee:	4313      	orrs	r3, r2
 801c0f0:	b29b      	uxth	r3, r3
 801c0f2:	0018      	movs	r0, r3
 801c0f4:	f7ea fefe 	bl	8006ef4 <lwip_htons>
 801c0f8:	0003      	movs	r3, r0
 801c0fa:	b2db      	uxtb	r3, r3
 801c0fc:	001a      	movs	r2, r3
 801c0fe:	2308      	movs	r3, #8
 801c100:	4013      	ands	r3, r2
 801c102:	d003      	beq.n	801c10c <vj_compress_tcp+0x788>
    changes |= TCP_PUSH_BIT;
 801c104:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c106:	2210      	movs	r2, #16
 801c108:	4313      	orrs	r3, r2
 801c10a:	647b      	str	r3, [r7, #68]	; 0x44
  }
  /*
   * Grab the cksum before we overwrite it below.  Then update our
   * state with this packet's header.
   */
  deltaA = lwip_ntohs(th->chksum);
 801c10c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c10e:	7c1a      	ldrb	r2, [r3, #16]
 801c110:	7c5b      	ldrb	r3, [r3, #17]
 801c112:	021b      	lsls	r3, r3, #8
 801c114:	4313      	orrs	r3, r2
 801c116:	b29b      	uxth	r3, r3
 801c118:	2248      	movs	r2, #72	; 0x48
 801c11a:	18bc      	adds	r4, r7, r2
 801c11c:	0018      	movs	r0, r3
 801c11e:	f7ea fee9 	bl	8006ef4 <lwip_htons>
 801c122:	0003      	movs	r3, r0
 801c124:	8023      	strh	r3, [r4, #0]
  MEMCPY(&cs->cs_ip, ip, hlen);
 801c126:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c128:	3308      	adds	r3, #8
 801c12a:	0018      	movs	r0, r3
 801c12c:	232e      	movs	r3, #46	; 0x2e
 801c12e:	18fb      	adds	r3, r7, r3
 801c130:	881a      	ldrh	r2, [r3, #0]
 801c132:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c134:	0019      	movs	r1, r3
 801c136:	f000 fec9 	bl	801cecc <memcpy>
   * mask, one for the connection id and two for the tcp checksum.
   * So, (cp - new_seq) + 4 bytes of header are needed.  hlen is how
   * many bytes of the original packet to toss so subtract the two to
   * get the new packet size.
   */
  deltaS = (u16_t)(cp - new_seq);
 801c13a:	230c      	movs	r3, #12
 801c13c:	18fb      	adds	r3, r7, r3
 801c13e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801c140:	1ad2      	subs	r2, r2, r3
 801c142:	234a      	movs	r3, #74	; 0x4a
 801c144:	18fb      	adds	r3, r7, r3
 801c146:	801a      	strh	r2, [r3, #0]
  if (!comp->compressSlot || comp->last_xmit != cs->cs_id) {
 801c148:	687b      	ldr	r3, [r7, #4]
 801c14a:	7a5b      	ldrb	r3, [r3, #9]
 801c14c:	2b00      	cmp	r3, #0
 801c14e:	d005      	beq.n	801c15c <vj_compress_tcp+0x7d8>
 801c150:	687b      	ldr	r3, [r7, #4]
 801c152:	795a      	ldrb	r2, [r3, #5]
 801c154:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c156:	799b      	ldrb	r3, [r3, #6]
 801c158:	429a      	cmp	r2, r3
 801c15a:	d031      	beq.n	801c1c0 <vj_compress_tcp+0x83c>
    comp->last_xmit = cs->cs_id;
 801c15c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c15e:	799a      	ldrb	r2, [r3, #6]
 801c160:	687b      	ldr	r3, [r7, #4]
 801c162:	715a      	strb	r2, [r3, #5]
    hlen -= deltaS + 4;
 801c164:	212e      	movs	r1, #46	; 0x2e
 801c166:	187a      	adds	r2, r7, r1
 801c168:	234a      	movs	r3, #74	; 0x4a
 801c16a:	18fb      	adds	r3, r7, r3
 801c16c:	8812      	ldrh	r2, [r2, #0]
 801c16e:	881b      	ldrh	r3, [r3, #0]
 801c170:	1ad3      	subs	r3, r2, r3
 801c172:	b29a      	uxth	r2, r3
 801c174:	187b      	adds	r3, r7, r1
 801c176:	3a04      	subs	r2, #4
 801c178:	801a      	strh	r2, [r3, #0]
    if (pbuf_remove_header(np, hlen)){
 801c17a:	187b      	adds	r3, r7, r1
 801c17c:	881a      	ldrh	r2, [r3, #0]
 801c17e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c180:	0011      	movs	r1, r2
 801c182:	0018      	movs	r0, r3
 801c184:	f7ed fdc2 	bl	8009d0c <pbuf_remove_header>
 801c188:	1e03      	subs	r3, r0, #0
 801c18a:	d006      	beq.n	801c19a <vj_compress_tcp+0x816>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_remove_header failed\n", 0);
 801c18c:	4b3d      	ldr	r3, [pc, #244]	; (801c284 <vj_compress_tcp+0x900>)
 801c18e:	22ce      	movs	r2, #206	; 0xce
 801c190:	0052      	lsls	r2, r2, #1
 801c192:	493d      	ldr	r1, [pc, #244]	; (801c288 <vj_compress_tcp+0x904>)
 801c194:	483d      	ldr	r0, [pc, #244]	; (801c28c <vj_compress_tcp+0x908>)
 801c196:	f7e6 fd17 	bl	8002bc8 <app_debug_rtt_raw>
    }
    cp = (u8_t*)np->payload;
 801c19a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c19c:	685b      	ldr	r3, [r3, #4]
 801c19e:	643b      	str	r3, [r7, #64]	; 0x40
    *cp++ = (u8_t)(changes | NEW_C);
 801c1a0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c1a2:	b2da      	uxtb	r2, r3
 801c1a4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c1a6:	1c59      	adds	r1, r3, #1
 801c1a8:	6439      	str	r1, [r7, #64]	; 0x40
 801c1aa:	2140      	movs	r1, #64	; 0x40
 801c1ac:	430a      	orrs	r2, r1
 801c1ae:	b2d2      	uxtb	r2, r2
 801c1b0:	701a      	strb	r2, [r3, #0]
    *cp++ = cs->cs_id;
 801c1b2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c1b4:	1c5a      	adds	r2, r3, #1
 801c1b6:	643a      	str	r2, [r7, #64]	; 0x40
 801c1b8:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801c1ba:	7992      	ldrb	r2, [r2, #6]
 801c1bc:	701a      	strb	r2, [r3, #0]
 801c1be:	e023      	b.n	801c208 <vj_compress_tcp+0x884>
  } else {
    hlen -= deltaS + 3;
 801c1c0:	212e      	movs	r1, #46	; 0x2e
 801c1c2:	187a      	adds	r2, r7, r1
 801c1c4:	234a      	movs	r3, #74	; 0x4a
 801c1c6:	18fb      	adds	r3, r7, r3
 801c1c8:	8812      	ldrh	r2, [r2, #0]
 801c1ca:	881b      	ldrh	r3, [r3, #0]
 801c1cc:	1ad3      	subs	r3, r2, r3
 801c1ce:	b29a      	uxth	r2, r3
 801c1d0:	187b      	adds	r3, r7, r1
 801c1d2:	3a03      	subs	r2, #3
 801c1d4:	801a      	strh	r2, [r3, #0]
    if (pbuf_remove_header(np, hlen)) {
 801c1d6:	187b      	adds	r3, r7, r1
 801c1d8:	881a      	ldrh	r2, [r3, #0]
 801c1da:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c1dc:	0011      	movs	r1, r2
 801c1de:	0018      	movs	r0, r3
 801c1e0:	f7ed fd94 	bl	8009d0c <pbuf_remove_header>
 801c1e4:	1e03      	subs	r3, r0, #0
 801c1e6:	d006      	beq.n	801c1f6 <vj_compress_tcp+0x872>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_remove_header failed\n", 0);
 801c1e8:	4b26      	ldr	r3, [pc, #152]	; (801c284 <vj_compress_tcp+0x900>)
 801c1ea:	22a6      	movs	r2, #166	; 0xa6
 801c1ec:	32ff      	adds	r2, #255	; 0xff
 801c1ee:	4926      	ldr	r1, [pc, #152]	; (801c288 <vj_compress_tcp+0x904>)
 801c1f0:	4826      	ldr	r0, [pc, #152]	; (801c28c <vj_compress_tcp+0x908>)
 801c1f2:	f7e6 fce9 	bl	8002bc8 <app_debug_rtt_raw>
    }
    cp = (u8_t*)np->payload;
 801c1f6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c1f8:	685b      	ldr	r3, [r3, #4]
 801c1fa:	643b      	str	r3, [r7, #64]	; 0x40
    *cp++ = (u8_t)changes;
 801c1fc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c1fe:	1c5a      	adds	r2, r3, #1
 801c200:	643a      	str	r2, [r7, #64]	; 0x40
 801c202:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801c204:	b2d2      	uxtb	r2, r2
 801c206:	701a      	strb	r2, [r3, #0]
  }
  *cp++ = (u8_t)(deltaA >> 8);
 801c208:	2048      	movs	r0, #72	; 0x48
 801c20a:	183b      	adds	r3, r7, r0
 801c20c:	881b      	ldrh	r3, [r3, #0]
 801c20e:	0a1b      	lsrs	r3, r3, #8
 801c210:	b299      	uxth	r1, r3
 801c212:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c214:	1c5a      	adds	r2, r3, #1
 801c216:	643a      	str	r2, [r7, #64]	; 0x40
 801c218:	b2ca      	uxtb	r2, r1
 801c21a:	701a      	strb	r2, [r3, #0]
  *cp++ = (u8_t)deltaA;
 801c21c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c21e:	1c5a      	adds	r2, r3, #1
 801c220:	643a      	str	r2, [r7, #64]	; 0x40
 801c222:	183a      	adds	r2, r7, r0
 801c224:	8812      	ldrh	r2, [r2, #0]
 801c226:	b2d2      	uxtb	r2, r2
 801c228:	701a      	strb	r2, [r3, #0]
  MEMCPY(cp, new_seq, deltaS);
 801c22a:	234a      	movs	r3, #74	; 0x4a
 801c22c:	18fb      	adds	r3, r7, r3
 801c22e:	881a      	ldrh	r2, [r3, #0]
 801c230:	230c      	movs	r3, #12
 801c232:	18f9      	adds	r1, r7, r3
 801c234:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c236:	0018      	movs	r0, r3
 801c238:	f000 fe48 	bl	801cecc <memcpy>
  INCR(vjs_compressed);
  return (TYPE_COMPRESSED_TCP);
 801c23c:	2380      	movs	r3, #128	; 0x80
 801c23e:	e01b      	b.n	801c278 <vj_compress_tcp+0x8f4>
    goto uncompressed;
 801c240:	46c0      	nop			; (mov r8, r8)
 801c242:	e006      	b.n	801c252 <vj_compress_tcp+0x8ce>
    goto uncompressed;
 801c244:	46c0      	nop			; (mov r8, r8)
 801c246:	e004      	b.n	801c252 <vj_compress_tcp+0x8ce>
      goto uncompressed;
 801c248:	46c0      	nop			; (mov r8, r8)
 801c24a:	e002      	b.n	801c252 <vj_compress_tcp+0x8ce>
      goto uncompressed;
 801c24c:	46c0      	nop			; (mov r8, r8)
 801c24e:	e000      	b.n	801c252 <vj_compress_tcp+0x8ce>
    goto uncompressed;
 801c250:	46c0      	nop			; (mov r8, r8)
   * Update connection state cs & send uncompressed packet (that is,
   * a regular ip/tcp packet but with the 'conversation id' we hope
   * to use on future compressed packets in the protocol field).
   */
uncompressed:
  MEMCPY(&cs->cs_ip, ip, hlen);
 801c252:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c254:	3308      	adds	r3, #8
 801c256:	0018      	movs	r0, r3
 801c258:	232e      	movs	r3, #46	; 0x2e
 801c25a:	18fb      	adds	r3, r7, r3
 801c25c:	881a      	ldrh	r2, [r3, #0]
 801c25e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c260:	0019      	movs	r1, r3
 801c262:	f000 fe33 	bl	801cecc <memcpy>
  IPH_PROTO_SET(ip, cs->cs_id);
 801c266:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c268:	799a      	ldrb	r2, [r3, #6]
 801c26a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c26c:	725a      	strb	r2, [r3, #9]
  comp->last_xmit = cs->cs_id;
 801c26e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c270:	799a      	ldrb	r2, [r3, #6]
 801c272:	687b      	ldr	r3, [r7, #4]
 801c274:	715a      	strb	r2, [r3, #5]
  return (TYPE_UNCOMPRESSED_TCP);
 801c276:	2370      	movs	r3, #112	; 0x70
}
 801c278:	0018      	movs	r0, r3
 801c27a:	46bd      	mov	sp, r7
 801c27c:	b014      	add	sp, #80	; 0x50
 801c27e:	bdb0      	pop	{r4, r5, r7, pc}
 801c280:	08022e24 	.word	0x08022e24
 801c284:	08022050 	.word	0x08022050
 801c288:	0802207c 	.word	0x0802207c
 801c28c:	08022098 	.word	0x08022098

0801c290 <vj_uncompress_err>:
/*
 * Called when we may have missed a packet.
 */
void
vj_uncompress_err(struct vjcompress *comp)
{
 801c290:	b580      	push	{r7, lr}
 801c292:	b082      	sub	sp, #8
 801c294:	af00      	add	r7, sp, #0
 801c296:	6078      	str	r0, [r7, #4]
  comp->flags |= VJF_TOSS;
 801c298:	687b      	ldr	r3, [r7, #4]
 801c29a:	88db      	ldrh	r3, [r3, #6]
 801c29c:	2201      	movs	r2, #1
 801c29e:	4313      	orrs	r3, r2
 801c2a0:	b29a      	uxth	r2, r3
 801c2a2:	687b      	ldr	r3, [r7, #4]
 801c2a4:	80da      	strh	r2, [r3, #6]
  INCR(vjs_errorin);
}
 801c2a6:	46c0      	nop			; (mov r8, r8)
 801c2a8:	46bd      	mov	sp, r7
 801c2aa:	b002      	add	sp, #8
 801c2ac:	bd80      	pop	{r7, pc}
	...

0801c2b0 <vj_uncompress_uncomp>:
 * "Uncompress" a packet of type TYPE_UNCOMPRESSED_TCP.
 * Return 0 on success, -1 on failure.
 */
int
vj_uncompress_uncomp(struct pbuf *nb, struct vjcompress *comp)
{
 801c2b0:	b580      	push	{r7, lr}
 801c2b2:	b086      	sub	sp, #24
 801c2b4:	af00      	add	r7, sp, #0
 801c2b6:	6078      	str	r0, [r7, #4]
 801c2b8:	6039      	str	r1, [r7, #0]
  u32_t hlen;
  struct cstate *cs;
  struct ip_hdr *ip;

  ip = (struct ip_hdr *)nb->payload;
 801c2ba:	687b      	ldr	r3, [r7, #4]
 801c2bc:	685b      	ldr	r3, [r3, #4]
 801c2be:	617b      	str	r3, [r7, #20]
  hlen = IPH_HL(ip) << 2;
 801c2c0:	697b      	ldr	r3, [r7, #20]
 801c2c2:	781b      	ldrb	r3, [r3, #0]
 801c2c4:	009b      	lsls	r3, r3, #2
 801c2c6:	001a      	movs	r2, r3
 801c2c8:	233c      	movs	r3, #60	; 0x3c
 801c2ca:	4013      	ands	r3, r2
 801c2cc:	613b      	str	r3, [r7, #16]
  if (IPH_PROTO(ip) >= MAX_SLOTS
 801c2ce:	697b      	ldr	r3, [r7, #20]
 801c2d0:	7a5b      	ldrb	r3, [r3, #9]
 801c2d2:	2b0f      	cmp	r3, #15
 801c2d4:	d823      	bhi.n	801c31e <vj_uncompress_uncomp+0x6e>
      || hlen + sizeof(struct tcp_hdr) > nb->len
 801c2d6:	693b      	ldr	r3, [r7, #16]
 801c2d8:	3314      	adds	r3, #20
 801c2da:	687a      	ldr	r2, [r7, #4]
 801c2dc:	8952      	ldrh	r2, [r2, #10]
 801c2de:	4293      	cmp	r3, r2
 801c2e0:	d81d      	bhi.n	801c31e <vj_uncompress_uncomp+0x6e>
      || (hlen += TCPH_HDRLEN_BYTES((struct tcp_hdr *)&((char *)ip)[hlen]))
 801c2e2:	697a      	ldr	r2, [r7, #20]
 801c2e4:	693b      	ldr	r3, [r7, #16]
 801c2e6:	18d3      	adds	r3, r2, r3
 801c2e8:	7b1a      	ldrb	r2, [r3, #12]
 801c2ea:	7b5b      	ldrb	r3, [r3, #13]
 801c2ec:	021b      	lsls	r3, r3, #8
 801c2ee:	4313      	orrs	r3, r2
 801c2f0:	b29b      	uxth	r3, r3
 801c2f2:	0018      	movs	r0, r3
 801c2f4:	f7ea fdfe 	bl	8006ef4 <lwip_htons>
 801c2f8:	0003      	movs	r3, r0
 801c2fa:	0b1b      	lsrs	r3, r3, #12
 801c2fc:	b29b      	uxth	r3, r3
 801c2fe:	b2db      	uxtb	r3, r3
 801c300:	009b      	lsls	r3, r3, #2
 801c302:	b2db      	uxtb	r3, r3
 801c304:	001a      	movs	r2, r3
 801c306:	693b      	ldr	r3, [r7, #16]
 801c308:	189b      	adds	r3, r3, r2
 801c30a:	613b      	str	r3, [r7, #16]
          > nb->len
 801c30c:	687b      	ldr	r3, [r7, #4]
 801c30e:	895b      	ldrh	r3, [r3, #10]
 801c310:	001a      	movs	r2, r3
      || (hlen += TCPH_HDRLEN_BYTES((struct tcp_hdr *)&((char *)ip)[hlen]))
 801c312:	693b      	ldr	r3, [r7, #16]
 801c314:	4293      	cmp	r3, r2
 801c316:	d802      	bhi.n	801c31e <vj_uncompress_uncomp+0x6e>
      || hlen > MAX_HDR) {
 801c318:	693b      	ldr	r3, [r7, #16]
 801c31a:	2b80      	cmp	r3, #128	; 0x80
 801c31c:	d906      	bls.n	801c32c <vj_uncompress_uncomp+0x7c>
    PPPDEBUG(LOG_INFO, ("vj_uncompress_uncomp: bad cid=%d, hlen=%d buflen=%d\n",
      IPH_PROTO(ip), hlen, nb->len));
    vj_uncompress_err(comp);
 801c31e:	683b      	ldr	r3, [r7, #0]
 801c320:	0018      	movs	r0, r3
 801c322:	f7ff ffb5 	bl	801c290 <vj_uncompress_err>
    return -1;
 801c326:	2301      	movs	r3, #1
 801c328:	425b      	negs	r3, r3
 801c32a:	e029      	b.n	801c380 <vj_uncompress_uncomp+0xd0>
  }
  cs = &comp->rstate[comp->last_recv = IPH_PROTO(ip)];
 801c32c:	697b      	ldr	r3, [r7, #20]
 801c32e:	7a5a      	ldrb	r2, [r3, #9]
 801c330:	683b      	ldr	r3, [r7, #0]
 801c332:	711a      	strb	r2, [r3, #4]
 801c334:	683b      	ldr	r3, [r7, #0]
 801c336:	791b      	ldrb	r3, [r3, #4]
 801c338:	001a      	movs	r2, r3
 801c33a:	0013      	movs	r3, r2
 801c33c:	011b      	lsls	r3, r3, #4
 801c33e:	189b      	adds	r3, r3, r2
 801c340:	00db      	lsls	r3, r3, #3
 801c342:	4a11      	ldr	r2, [pc, #68]	; (801c388 <vj_uncompress_uncomp+0xd8>)
 801c344:	4694      	mov	ip, r2
 801c346:	4463      	add	r3, ip
 801c348:	683a      	ldr	r2, [r7, #0]
 801c34a:	18d3      	adds	r3, r2, r3
 801c34c:	3304      	adds	r3, #4
 801c34e:	60fb      	str	r3, [r7, #12]
  comp->flags &=~ VJF_TOSS;
 801c350:	683b      	ldr	r3, [r7, #0]
 801c352:	88db      	ldrh	r3, [r3, #6]
 801c354:	2201      	movs	r2, #1
 801c356:	4393      	bics	r3, r2
 801c358:	b29a      	uxth	r2, r3
 801c35a:	683b      	ldr	r3, [r7, #0]
 801c35c:	80da      	strh	r2, [r3, #6]
  IPH_PROTO_SET(ip, IP_PROTO_TCP);
 801c35e:	697b      	ldr	r3, [r7, #20]
 801c360:	2206      	movs	r2, #6
 801c362:	725a      	strb	r2, [r3, #9]
  /* copy from/to bigger buffers checked above instead of cs->cs_ip and ip
     just to help static code analysis to see this is correct ;-) */
  MEMCPY(&cs->cs_hdr, nb->payload, hlen);
 801c364:	68fb      	ldr	r3, [r7, #12]
 801c366:	3308      	adds	r3, #8
 801c368:	0018      	movs	r0, r3
 801c36a:	687b      	ldr	r3, [r7, #4]
 801c36c:	685b      	ldr	r3, [r3, #4]
 801c36e:	693a      	ldr	r2, [r7, #16]
 801c370:	0019      	movs	r1, r3
 801c372:	f000 fdab 	bl	801cecc <memcpy>
  cs->cs_hlen = (u16_t)hlen;
 801c376:	693b      	ldr	r3, [r7, #16]
 801c378:	b29a      	uxth	r2, r3
 801c37a:	68fb      	ldr	r3, [r7, #12]
 801c37c:	809a      	strh	r2, [r3, #4]
  INCR(vjs_uncompressedin);
  return 0;
 801c37e:	2300      	movs	r3, #0
}
 801c380:	0018      	movs	r0, r3
 801c382:	46bd      	mov	sp, r7
 801c384:	b006      	add	sp, #24
 801c386:	bd80      	pop	{r7, pc}
 801c388:	00000888 	.word	0x00000888

0801c38c <vj_uncompress_tcp>:
 * This procedure replaces the compressed header with the uncompressed
 * header and returns the length of the VJ header.
 */
int
vj_uncompress_tcp(struct pbuf **nb, struct vjcompress *comp)
{
 801c38c:	b590      	push	{r4, r7, lr}
 801c38e:	b095      	sub	sp, #84	; 0x54
 801c390:	af00      	add	r7, sp, #0
 801c392:	6078      	str	r0, [r7, #4]
 801c394:	6039      	str	r1, [r7, #0]
  u8_t *cp;
  struct tcp_hdr *th;
  struct cstate *cs;
  struct vj_u16_t *bp;
  struct pbuf *n0 = *nb;
 801c396:	687b      	ldr	r3, [r7, #4]
 801c398:	681b      	ldr	r3, [r3, #0]
 801c39a:	647b      	str	r3, [r7, #68]	; 0x44
  u32_t tmp;
  u32_t vjlen, hlen, changes;

  INCR(vjs_compressedin);
  cp = (u8_t*)n0->payload;
 801c39c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c39e:	685b      	ldr	r3, [r3, #4]
 801c3a0:	64fb      	str	r3, [r7, #76]	; 0x4c
  changes = *cp++;
 801c3a2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c3a4:	1c5a      	adds	r2, r3, #1
 801c3a6:	64fa      	str	r2, [r7, #76]	; 0x4c
 801c3a8:	781b      	ldrb	r3, [r3, #0]
 801c3aa:	63bb      	str	r3, [r7, #56]	; 0x38
  if (changes & NEW_C) {
 801c3ac:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c3ae:	2240      	movs	r2, #64	; 0x40
 801c3b0:	4013      	ands	r3, r2
 801c3b2:	d013      	beq.n	801c3dc <vj_uncompress_tcp+0x50>
    /*
     * Make sure the state index is in range, then grab the state.
     * If we have a good state index, clear the 'discard' flag.
     */
    if (*cp >= MAX_SLOTS) {
 801c3b4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c3b6:	781b      	ldrb	r3, [r3, #0]
 801c3b8:	2b0f      	cmp	r3, #15
 801c3ba:	d901      	bls.n	801c3c0 <vj_uncompress_tcp+0x34>
 801c3bc:	f000 fd00 	bl	801cdc0 <vj_uncompress_tcp+0xa34>
      PPPDEBUG(LOG_INFO, ("vj_uncompress_tcp: bad cid=%d\n", *cp));
      goto bad;
    }

    comp->flags &=~ VJF_TOSS;
 801c3c0:	683b      	ldr	r3, [r7, #0]
 801c3c2:	88db      	ldrh	r3, [r3, #6]
 801c3c4:	2201      	movs	r2, #1
 801c3c6:	4393      	bics	r3, r2
 801c3c8:	b29a      	uxth	r2, r3
 801c3ca:	683b      	ldr	r3, [r7, #0]
 801c3cc:	80da      	strh	r2, [r3, #6]
    comp->last_recv = *cp++;
 801c3ce:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c3d0:	1c5a      	adds	r2, r3, #1
 801c3d2:	64fa      	str	r2, [r7, #76]	; 0x4c
 801c3d4:	781a      	ldrb	r2, [r3, #0]
 801c3d6:	683b      	ldr	r3, [r7, #0]
 801c3d8:	711a      	strb	r2, [r3, #4]
 801c3da:	e009      	b.n	801c3f0 <vj_uncompress_tcp+0x64>
    /*
     * this packet has an implicit state index.  If we've
     * had a line error since the last time we got an
     * explicit state index, we have to toss the packet.
     */
    if (comp->flags & VJF_TOSS) {
 801c3dc:	683b      	ldr	r3, [r7, #0]
 801c3de:	88db      	ldrh	r3, [r3, #6]
 801c3e0:	001a      	movs	r2, r3
 801c3e2:	2301      	movs	r3, #1
 801c3e4:	4013      	ands	r3, r2
 801c3e6:	d003      	beq.n	801c3f0 <vj_uncompress_tcp+0x64>
      PPPDEBUG(LOG_INFO, ("vj_uncompress_tcp: tossing\n"));
      INCR(vjs_tossed);
      return (-1);
 801c3e8:	2301      	movs	r3, #1
 801c3ea:	425b      	negs	r3, r3
 801c3ec:	f000 fcf5 	bl	801cdda <vj_uncompress_tcp+0xa4e>
    }
  }
  cs = &comp->rstate[comp->last_recv];
 801c3f0:	683b      	ldr	r3, [r7, #0]
 801c3f2:	791b      	ldrb	r3, [r3, #4]
 801c3f4:	001a      	movs	r2, r3
 801c3f6:	0013      	movs	r3, r2
 801c3f8:	011b      	lsls	r3, r3, #4
 801c3fa:	189b      	adds	r3, r3, r2
 801c3fc:	00db      	lsls	r3, r3, #3
 801c3fe:	4ae9      	ldr	r2, [pc, #932]	; (801c7a4 <vj_uncompress_tcp+0x418>)
 801c400:	4694      	mov	ip, r2
 801c402:	4463      	add	r3, ip
 801c404:	683a      	ldr	r2, [r7, #0]
 801c406:	18d3      	adds	r3, r2, r3
 801c408:	3304      	adds	r3, #4
 801c40a:	637b      	str	r3, [r7, #52]	; 0x34
  hlen = IPH_HL(&cs->cs_ip) << 2;
 801c40c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c40e:	7a1b      	ldrb	r3, [r3, #8]
 801c410:	009b      	lsls	r3, r3, #2
 801c412:	001a      	movs	r2, r3
 801c414:	233c      	movs	r3, #60	; 0x3c
 801c416:	4013      	ands	r3, r2
 801c418:	63fb      	str	r3, [r7, #60]	; 0x3c
  th = (struct tcp_hdr *)&((u8_t*)&cs->cs_ip)[hlen];
 801c41a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c41c:	3308      	adds	r3, #8
 801c41e:	001a      	movs	r2, r3
 801c420:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c422:	18d3      	adds	r3, r2, r3
 801c424:	633b      	str	r3, [r7, #48]	; 0x30
  th->chksum = lwip_htons((*cp << 8) | cp[1]);
 801c426:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c428:	781b      	ldrb	r3, [r3, #0]
 801c42a:	021b      	lsls	r3, r3, #8
 801c42c:	b21a      	sxth	r2, r3
 801c42e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c430:	3301      	adds	r3, #1
 801c432:	781b      	ldrb	r3, [r3, #0]
 801c434:	b21b      	sxth	r3, r3
 801c436:	4313      	orrs	r3, r2
 801c438:	b21b      	sxth	r3, r3
 801c43a:	b29b      	uxth	r3, r3
 801c43c:	0018      	movs	r0, r3
 801c43e:	f7ea fd59 	bl	8006ef4 <lwip_htons>
 801c442:	0003      	movs	r3, r0
 801c444:	001a      	movs	r2, r3
 801c446:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c448:	21ff      	movs	r1, #255	; 0xff
 801c44a:	4011      	ands	r1, r2
 801c44c:	000c      	movs	r4, r1
 801c44e:	7c19      	ldrb	r1, [r3, #16]
 801c450:	2000      	movs	r0, #0
 801c452:	4001      	ands	r1, r0
 801c454:	1c08      	adds	r0, r1, #0
 801c456:	1c21      	adds	r1, r4, #0
 801c458:	4301      	orrs	r1, r0
 801c45a:	7419      	strb	r1, [r3, #16]
 801c45c:	0a12      	lsrs	r2, r2, #8
 801c45e:	b290      	uxth	r0, r2
 801c460:	7c5a      	ldrb	r2, [r3, #17]
 801c462:	2100      	movs	r1, #0
 801c464:	400a      	ands	r2, r1
 801c466:	1c11      	adds	r1, r2, #0
 801c468:	1c02      	adds	r2, r0, #0
 801c46a:	430a      	orrs	r2, r1
 801c46c:	745a      	strb	r2, [r3, #17]
  cp += 2;
 801c46e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c470:	3302      	adds	r3, #2
 801c472:	64fb      	str	r3, [r7, #76]	; 0x4c
  if (changes & TCP_PUSH_BIT) {
 801c474:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c476:	2210      	movs	r2, #16
 801c478:	4013      	ands	r3, r2
 801c47a:	d020      	beq.n	801c4be <vj_uncompress_tcp+0x132>
    TCPH_SET_FLAG(th, TCP_PSH);
 801c47c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c47e:	7b1a      	ldrb	r2, [r3, #12]
 801c480:	7b5b      	ldrb	r3, [r3, #13]
 801c482:	021b      	lsls	r3, r3, #8
 801c484:	4313      	orrs	r3, r2
 801c486:	b29c      	uxth	r4, r3
 801c488:	2008      	movs	r0, #8
 801c48a:	f7ea fd33 	bl	8006ef4 <lwip_htons>
 801c48e:	0003      	movs	r3, r0
 801c490:	4323      	orrs	r3, r4
 801c492:	b29a      	uxth	r2, r3
 801c494:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c496:	21ff      	movs	r1, #255	; 0xff
 801c498:	4011      	ands	r1, r2
 801c49a:	000c      	movs	r4, r1
 801c49c:	7b19      	ldrb	r1, [r3, #12]
 801c49e:	2000      	movs	r0, #0
 801c4a0:	4001      	ands	r1, r0
 801c4a2:	1c08      	adds	r0, r1, #0
 801c4a4:	1c21      	adds	r1, r4, #0
 801c4a6:	4301      	orrs	r1, r0
 801c4a8:	7319      	strb	r1, [r3, #12]
 801c4aa:	0a12      	lsrs	r2, r2, #8
 801c4ac:	b290      	uxth	r0, r2
 801c4ae:	7b5a      	ldrb	r2, [r3, #13]
 801c4b0:	2100      	movs	r1, #0
 801c4b2:	400a      	ands	r2, r1
 801c4b4:	1c11      	adds	r1, r2, #0
 801c4b6:	1c02      	adds	r2, r0, #0
 801c4b8:	430a      	orrs	r2, r1
 801c4ba:	735a      	strb	r2, [r3, #13]
 801c4bc:	e024      	b.n	801c508 <vj_uncompress_tcp+0x17c>
  } else {
    TCPH_UNSET_FLAG(th, TCP_PSH);
 801c4be:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c4c0:	7b1a      	ldrb	r2, [r3, #12]
 801c4c2:	7b5b      	ldrb	r3, [r3, #13]
 801c4c4:	021b      	lsls	r3, r3, #8
 801c4c6:	4313      	orrs	r3, r2
 801c4c8:	b29b      	uxth	r3, r3
 801c4ca:	b21c      	sxth	r4, r3
 801c4cc:	2008      	movs	r0, #8
 801c4ce:	f7ea fd11 	bl	8006ef4 <lwip_htons>
 801c4d2:	0003      	movs	r3, r0
 801c4d4:	b21b      	sxth	r3, r3
 801c4d6:	43db      	mvns	r3, r3
 801c4d8:	b21b      	sxth	r3, r3
 801c4da:	4023      	ands	r3, r4
 801c4dc:	b21b      	sxth	r3, r3
 801c4de:	b29a      	uxth	r2, r3
 801c4e0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c4e2:	21ff      	movs	r1, #255	; 0xff
 801c4e4:	4011      	ands	r1, r2
 801c4e6:	000c      	movs	r4, r1
 801c4e8:	7b19      	ldrb	r1, [r3, #12]
 801c4ea:	2000      	movs	r0, #0
 801c4ec:	4001      	ands	r1, r0
 801c4ee:	1c08      	adds	r0, r1, #0
 801c4f0:	1c21      	adds	r1, r4, #0
 801c4f2:	4301      	orrs	r1, r0
 801c4f4:	7319      	strb	r1, [r3, #12]
 801c4f6:	0a12      	lsrs	r2, r2, #8
 801c4f8:	b290      	uxth	r0, r2
 801c4fa:	7b5a      	ldrb	r2, [r3, #13]
 801c4fc:	2100      	movs	r1, #0
 801c4fe:	400a      	ands	r2, r1
 801c500:	1c11      	adds	r1, r2, #0
 801c502:	1c02      	adds	r2, r0, #0
 801c504:	430a      	orrs	r2, r1
 801c506:	735a      	strb	r2, [r3, #13]
  }

  switch (changes & SPECIALS_MASK) {
 801c508:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c50a:	220f      	movs	r2, #15
 801c50c:	4013      	ands	r3, r2
 801c50e:	2b0b      	cmp	r3, #11
 801c510:	d003      	beq.n	801c51a <vj_uncompress_tcp+0x18e>
 801c512:	2b0f      	cmp	r3, #15
 801c514:	d100      	bne.n	801c518 <vj_uncompress_tcp+0x18c>
 801c516:	e08c      	b.n	801c632 <vj_uncompress_tcp+0x2a6>
 801c518:	e0d4      	b.n	801c6c4 <vj_uncompress_tcp+0x338>
  case SPECIAL_I:
    {
      u32_t i = lwip_ntohs(IPH_LEN(&cs->cs_ip)) - cs->cs_hlen;
 801c51a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c51c:	895b      	ldrh	r3, [r3, #10]
 801c51e:	0018      	movs	r0, r3
 801c520:	f7ea fce8 	bl	8006ef4 <lwip_htons>
 801c524:	0003      	movs	r3, r0
 801c526:	001a      	movs	r2, r3
 801c528:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c52a:	889b      	ldrh	r3, [r3, #4]
 801c52c:	1ad3      	subs	r3, r2, r3
 801c52e:	62fb      	str	r3, [r7, #44]	; 0x2c
      /* some compilers can't nest inline assembler.. */
      tmp = lwip_ntohl(th->ackno) + i;
 801c530:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c532:	7a1a      	ldrb	r2, [r3, #8]
 801c534:	7a59      	ldrb	r1, [r3, #9]
 801c536:	0209      	lsls	r1, r1, #8
 801c538:	430a      	orrs	r2, r1
 801c53a:	7a99      	ldrb	r1, [r3, #10]
 801c53c:	0409      	lsls	r1, r1, #16
 801c53e:	430a      	orrs	r2, r1
 801c540:	7adb      	ldrb	r3, [r3, #11]
 801c542:	061b      	lsls	r3, r3, #24
 801c544:	4313      	orrs	r3, r2
 801c546:	0018      	movs	r0, r3
 801c548:	f7ea fcea 	bl	8006f20 <lwip_htonl>
 801c54c:	0002      	movs	r2, r0
 801c54e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801c550:	189b      	adds	r3, r3, r2
 801c552:	643b      	str	r3, [r7, #64]	; 0x40
      th->ackno = lwip_htonl(tmp);
 801c554:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c556:	0018      	movs	r0, r3
 801c558:	f7ea fce2 	bl	8006f20 <lwip_htonl>
 801c55c:	0002      	movs	r2, r0
 801c55e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c560:	21ff      	movs	r1, #255	; 0xff
 801c562:	4011      	ands	r1, r2
 801c564:	000c      	movs	r4, r1
 801c566:	7a19      	ldrb	r1, [r3, #8]
 801c568:	2000      	movs	r0, #0
 801c56a:	4001      	ands	r1, r0
 801c56c:	1c08      	adds	r0, r1, #0
 801c56e:	1c21      	adds	r1, r4, #0
 801c570:	4301      	orrs	r1, r0
 801c572:	7219      	strb	r1, [r3, #8]
 801c574:	0a11      	lsrs	r1, r2, #8
 801c576:	20ff      	movs	r0, #255	; 0xff
 801c578:	4001      	ands	r1, r0
 801c57a:	000c      	movs	r4, r1
 801c57c:	7a59      	ldrb	r1, [r3, #9]
 801c57e:	2000      	movs	r0, #0
 801c580:	4001      	ands	r1, r0
 801c582:	1c08      	adds	r0, r1, #0
 801c584:	1c21      	adds	r1, r4, #0
 801c586:	4301      	orrs	r1, r0
 801c588:	7259      	strb	r1, [r3, #9]
 801c58a:	0c11      	lsrs	r1, r2, #16
 801c58c:	20ff      	movs	r0, #255	; 0xff
 801c58e:	4001      	ands	r1, r0
 801c590:	000c      	movs	r4, r1
 801c592:	7a99      	ldrb	r1, [r3, #10]
 801c594:	2000      	movs	r0, #0
 801c596:	4001      	ands	r1, r0
 801c598:	1c08      	adds	r0, r1, #0
 801c59a:	1c21      	adds	r1, r4, #0
 801c59c:	4301      	orrs	r1, r0
 801c59e:	7299      	strb	r1, [r3, #10]
 801c5a0:	0e10      	lsrs	r0, r2, #24
 801c5a2:	7ada      	ldrb	r2, [r3, #11]
 801c5a4:	2100      	movs	r1, #0
 801c5a6:	400a      	ands	r2, r1
 801c5a8:	1c11      	adds	r1, r2, #0
 801c5aa:	1c02      	adds	r2, r0, #0
 801c5ac:	430a      	orrs	r2, r1
 801c5ae:	72da      	strb	r2, [r3, #11]
      tmp = lwip_ntohl(th->seqno) + i;
 801c5b0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c5b2:	791a      	ldrb	r2, [r3, #4]
 801c5b4:	7959      	ldrb	r1, [r3, #5]
 801c5b6:	0209      	lsls	r1, r1, #8
 801c5b8:	430a      	orrs	r2, r1
 801c5ba:	7999      	ldrb	r1, [r3, #6]
 801c5bc:	0409      	lsls	r1, r1, #16
 801c5be:	430a      	orrs	r2, r1
 801c5c0:	79db      	ldrb	r3, [r3, #7]
 801c5c2:	061b      	lsls	r3, r3, #24
 801c5c4:	4313      	orrs	r3, r2
 801c5c6:	0018      	movs	r0, r3
 801c5c8:	f7ea fcaa 	bl	8006f20 <lwip_htonl>
 801c5cc:	0002      	movs	r2, r0
 801c5ce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801c5d0:	189b      	adds	r3, r3, r2
 801c5d2:	643b      	str	r3, [r7, #64]	; 0x40
      th->seqno = lwip_htonl(tmp);
 801c5d4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c5d6:	0018      	movs	r0, r3
 801c5d8:	f7ea fca2 	bl	8006f20 <lwip_htonl>
 801c5dc:	0002      	movs	r2, r0
 801c5de:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c5e0:	21ff      	movs	r1, #255	; 0xff
 801c5e2:	4011      	ands	r1, r2
 801c5e4:	000c      	movs	r4, r1
 801c5e6:	7919      	ldrb	r1, [r3, #4]
 801c5e8:	2000      	movs	r0, #0
 801c5ea:	4001      	ands	r1, r0
 801c5ec:	1c08      	adds	r0, r1, #0
 801c5ee:	1c21      	adds	r1, r4, #0
 801c5f0:	4301      	orrs	r1, r0
 801c5f2:	7119      	strb	r1, [r3, #4]
 801c5f4:	0a11      	lsrs	r1, r2, #8
 801c5f6:	20ff      	movs	r0, #255	; 0xff
 801c5f8:	4001      	ands	r1, r0
 801c5fa:	000c      	movs	r4, r1
 801c5fc:	7959      	ldrb	r1, [r3, #5]
 801c5fe:	2000      	movs	r0, #0
 801c600:	4001      	ands	r1, r0
 801c602:	1c08      	adds	r0, r1, #0
 801c604:	1c21      	adds	r1, r4, #0
 801c606:	4301      	orrs	r1, r0
 801c608:	7159      	strb	r1, [r3, #5]
 801c60a:	0c11      	lsrs	r1, r2, #16
 801c60c:	20ff      	movs	r0, #255	; 0xff
 801c60e:	4001      	ands	r1, r0
 801c610:	000c      	movs	r4, r1
 801c612:	7999      	ldrb	r1, [r3, #6]
 801c614:	2000      	movs	r0, #0
 801c616:	4001      	ands	r1, r0
 801c618:	1c08      	adds	r0, r1, #0
 801c61a:	1c21      	adds	r1, r4, #0
 801c61c:	4301      	orrs	r1, r0
 801c61e:	7199      	strb	r1, [r3, #6]
 801c620:	0e10      	lsrs	r0, r2, #24
 801c622:	79da      	ldrb	r2, [r3, #7]
 801c624:	2100      	movs	r1, #0
 801c626:	400a      	ands	r2, r1
 801c628:	1c11      	adds	r1, r2, #0
 801c62a:	1c02      	adds	r2, r0, #0
 801c62c:	430a      	orrs	r2, r1
 801c62e:	71da      	strb	r2, [r3, #7]
    }
    break;
 801c630:	e27f      	b.n	801cb32 <vj_uncompress_tcp+0x7a6>

  case SPECIAL_D:
    /* some compilers can't nest inline assembler.. */
    tmp = lwip_ntohl(th->seqno) + lwip_ntohs(IPH_LEN(&cs->cs_ip)) - cs->cs_hlen;
 801c632:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c634:	791a      	ldrb	r2, [r3, #4]
 801c636:	7959      	ldrb	r1, [r3, #5]
 801c638:	0209      	lsls	r1, r1, #8
 801c63a:	430a      	orrs	r2, r1
 801c63c:	7999      	ldrb	r1, [r3, #6]
 801c63e:	0409      	lsls	r1, r1, #16
 801c640:	430a      	orrs	r2, r1
 801c642:	79db      	ldrb	r3, [r3, #7]
 801c644:	061b      	lsls	r3, r3, #24
 801c646:	4313      	orrs	r3, r2
 801c648:	0018      	movs	r0, r3
 801c64a:	f7ea fc69 	bl	8006f20 <lwip_htonl>
 801c64e:	0004      	movs	r4, r0
 801c650:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c652:	895b      	ldrh	r3, [r3, #10]
 801c654:	0018      	movs	r0, r3
 801c656:	f7ea fc4d 	bl	8006ef4 <lwip_htons>
 801c65a:	0003      	movs	r3, r0
 801c65c:	18e3      	adds	r3, r4, r3
 801c65e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801c660:	8892      	ldrh	r2, [r2, #4]
 801c662:	1a9b      	subs	r3, r3, r2
 801c664:	643b      	str	r3, [r7, #64]	; 0x40
    th->seqno = lwip_htonl(tmp);
 801c666:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c668:	0018      	movs	r0, r3
 801c66a:	f7ea fc59 	bl	8006f20 <lwip_htonl>
 801c66e:	0002      	movs	r2, r0
 801c670:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c672:	21ff      	movs	r1, #255	; 0xff
 801c674:	4011      	ands	r1, r2
 801c676:	000c      	movs	r4, r1
 801c678:	7919      	ldrb	r1, [r3, #4]
 801c67a:	2000      	movs	r0, #0
 801c67c:	4001      	ands	r1, r0
 801c67e:	1c08      	adds	r0, r1, #0
 801c680:	1c21      	adds	r1, r4, #0
 801c682:	4301      	orrs	r1, r0
 801c684:	7119      	strb	r1, [r3, #4]
 801c686:	0a11      	lsrs	r1, r2, #8
 801c688:	20ff      	movs	r0, #255	; 0xff
 801c68a:	4001      	ands	r1, r0
 801c68c:	000c      	movs	r4, r1
 801c68e:	7959      	ldrb	r1, [r3, #5]
 801c690:	2000      	movs	r0, #0
 801c692:	4001      	ands	r1, r0
 801c694:	1c08      	adds	r0, r1, #0
 801c696:	1c21      	adds	r1, r4, #0
 801c698:	4301      	orrs	r1, r0
 801c69a:	7159      	strb	r1, [r3, #5]
 801c69c:	0c11      	lsrs	r1, r2, #16
 801c69e:	20ff      	movs	r0, #255	; 0xff
 801c6a0:	4001      	ands	r1, r0
 801c6a2:	000c      	movs	r4, r1
 801c6a4:	7999      	ldrb	r1, [r3, #6]
 801c6a6:	2000      	movs	r0, #0
 801c6a8:	4001      	ands	r1, r0
 801c6aa:	1c08      	adds	r0, r1, #0
 801c6ac:	1c21      	adds	r1, r4, #0
 801c6ae:	4301      	orrs	r1, r0
 801c6b0:	7199      	strb	r1, [r3, #6]
 801c6b2:	0e10      	lsrs	r0, r2, #24
 801c6b4:	79da      	ldrb	r2, [r3, #7]
 801c6b6:	2100      	movs	r1, #0
 801c6b8:	400a      	ands	r2, r1
 801c6ba:	1c11      	adds	r1, r2, #0
 801c6bc:	1c02      	adds	r2, r0, #0
 801c6be:	430a      	orrs	r2, r1
 801c6c0:	71da      	strb	r2, [r3, #7]
    break;
 801c6c2:	e236      	b.n	801cb32 <vj_uncompress_tcp+0x7a6>

  default:
    if (changes & NEW_U) {
 801c6c4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c6c6:	2201      	movs	r2, #1
 801c6c8:	4013      	ands	r3, r2
 801c6ca:	d06d      	beq.n	801c7a8 <vj_uncompress_tcp+0x41c>
      TCPH_SET_FLAG(th, TCP_URG);
 801c6cc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c6ce:	7b1a      	ldrb	r2, [r3, #12]
 801c6d0:	7b5b      	ldrb	r3, [r3, #13]
 801c6d2:	021b      	lsls	r3, r3, #8
 801c6d4:	4313      	orrs	r3, r2
 801c6d6:	b29c      	uxth	r4, r3
 801c6d8:	2020      	movs	r0, #32
 801c6da:	f7ea fc0b 	bl	8006ef4 <lwip_htons>
 801c6de:	0003      	movs	r3, r0
 801c6e0:	4323      	orrs	r3, r4
 801c6e2:	b29a      	uxth	r2, r3
 801c6e4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c6e6:	21ff      	movs	r1, #255	; 0xff
 801c6e8:	4011      	ands	r1, r2
 801c6ea:	000c      	movs	r4, r1
 801c6ec:	7b19      	ldrb	r1, [r3, #12]
 801c6ee:	2000      	movs	r0, #0
 801c6f0:	4001      	ands	r1, r0
 801c6f2:	1c08      	adds	r0, r1, #0
 801c6f4:	1c21      	adds	r1, r4, #0
 801c6f6:	4301      	orrs	r1, r0
 801c6f8:	7319      	strb	r1, [r3, #12]
 801c6fa:	0a12      	lsrs	r2, r2, #8
 801c6fc:	b290      	uxth	r0, r2
 801c6fe:	7b5a      	ldrb	r2, [r3, #13]
 801c700:	2100      	movs	r1, #0
 801c702:	400a      	ands	r2, r1
 801c704:	1c11      	adds	r1, r2, #0
 801c706:	1c02      	adds	r2, r0, #0
 801c708:	430a      	orrs	r2, r1
 801c70a:	735a      	strb	r2, [r3, #13]
      DECODEU(th->urgp);
 801c70c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c70e:	781b      	ldrb	r3, [r3, #0]
 801c710:	2b00      	cmp	r3, #0
 801c712:	d128      	bne.n	801c766 <vj_uncompress_tcp+0x3da>
 801c714:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c716:	3301      	adds	r3, #1
 801c718:	781b      	ldrb	r3, [r3, #0]
 801c71a:	021b      	lsls	r3, r3, #8
 801c71c:	b21a      	sxth	r2, r3
 801c71e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c720:	3302      	adds	r3, #2
 801c722:	781b      	ldrb	r3, [r3, #0]
 801c724:	b21b      	sxth	r3, r3
 801c726:	4313      	orrs	r3, r2
 801c728:	b21b      	sxth	r3, r3
 801c72a:	b29b      	uxth	r3, r3
 801c72c:	0018      	movs	r0, r3
 801c72e:	f7ea fbe1 	bl	8006ef4 <lwip_htons>
 801c732:	0003      	movs	r3, r0
 801c734:	001a      	movs	r2, r3
 801c736:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c738:	21ff      	movs	r1, #255	; 0xff
 801c73a:	4011      	ands	r1, r2
 801c73c:	000c      	movs	r4, r1
 801c73e:	7c99      	ldrb	r1, [r3, #18]
 801c740:	2000      	movs	r0, #0
 801c742:	4001      	ands	r1, r0
 801c744:	1c08      	adds	r0, r1, #0
 801c746:	1c21      	adds	r1, r4, #0
 801c748:	4301      	orrs	r1, r0
 801c74a:	7499      	strb	r1, [r3, #18]
 801c74c:	0a12      	lsrs	r2, r2, #8
 801c74e:	b290      	uxth	r0, r2
 801c750:	7cda      	ldrb	r2, [r3, #19]
 801c752:	2100      	movs	r1, #0
 801c754:	400a      	ands	r2, r1
 801c756:	1c11      	adds	r1, r2, #0
 801c758:	1c02      	adds	r2, r0, #0
 801c75a:	430a      	orrs	r2, r1
 801c75c:	74da      	strb	r2, [r3, #19]
 801c75e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c760:	3303      	adds	r3, #3
 801c762:	64fb      	str	r3, [r7, #76]	; 0x4c
 801c764:	e045      	b.n	801c7f2 <vj_uncompress_tcp+0x466>
 801c766:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c768:	1c5a      	adds	r2, r3, #1
 801c76a:	64fa      	str	r2, [r7, #76]	; 0x4c
 801c76c:	781b      	ldrb	r3, [r3, #0]
 801c76e:	b29b      	uxth	r3, r3
 801c770:	0018      	movs	r0, r3
 801c772:	f7ea fbbf 	bl	8006ef4 <lwip_htons>
 801c776:	0003      	movs	r3, r0
 801c778:	001a      	movs	r2, r3
 801c77a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c77c:	21ff      	movs	r1, #255	; 0xff
 801c77e:	4011      	ands	r1, r2
 801c780:	000c      	movs	r4, r1
 801c782:	7c99      	ldrb	r1, [r3, #18]
 801c784:	2000      	movs	r0, #0
 801c786:	4001      	ands	r1, r0
 801c788:	1c08      	adds	r0, r1, #0
 801c78a:	1c21      	adds	r1, r4, #0
 801c78c:	4301      	orrs	r1, r0
 801c78e:	7499      	strb	r1, [r3, #18]
 801c790:	0a12      	lsrs	r2, r2, #8
 801c792:	b290      	uxth	r0, r2
 801c794:	7cda      	ldrb	r2, [r3, #19]
 801c796:	2100      	movs	r1, #0
 801c798:	400a      	ands	r2, r1
 801c79a:	1c11      	adds	r1, r2, #0
 801c79c:	1c02      	adds	r2, r0, #0
 801c79e:	430a      	orrs	r2, r1
 801c7a0:	74da      	strb	r2, [r3, #19]
 801c7a2:	e026      	b.n	801c7f2 <vj_uncompress_tcp+0x466>
 801c7a4:	00000888 	.word	0x00000888
    } else {
      TCPH_UNSET_FLAG(th, TCP_URG);
 801c7a8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c7aa:	7b1a      	ldrb	r2, [r3, #12]
 801c7ac:	7b5b      	ldrb	r3, [r3, #13]
 801c7ae:	021b      	lsls	r3, r3, #8
 801c7b0:	4313      	orrs	r3, r2
 801c7b2:	b29b      	uxth	r3, r3
 801c7b4:	b21c      	sxth	r4, r3
 801c7b6:	2020      	movs	r0, #32
 801c7b8:	f7ea fb9c 	bl	8006ef4 <lwip_htons>
 801c7bc:	0003      	movs	r3, r0
 801c7be:	b21b      	sxth	r3, r3
 801c7c0:	43db      	mvns	r3, r3
 801c7c2:	b21b      	sxth	r3, r3
 801c7c4:	4023      	ands	r3, r4
 801c7c6:	b21b      	sxth	r3, r3
 801c7c8:	b29a      	uxth	r2, r3
 801c7ca:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c7cc:	21ff      	movs	r1, #255	; 0xff
 801c7ce:	4011      	ands	r1, r2
 801c7d0:	000c      	movs	r4, r1
 801c7d2:	7b19      	ldrb	r1, [r3, #12]
 801c7d4:	2000      	movs	r0, #0
 801c7d6:	4001      	ands	r1, r0
 801c7d8:	1c08      	adds	r0, r1, #0
 801c7da:	1c21      	adds	r1, r4, #0
 801c7dc:	4301      	orrs	r1, r0
 801c7de:	7319      	strb	r1, [r3, #12]
 801c7e0:	0a12      	lsrs	r2, r2, #8
 801c7e2:	b290      	uxth	r0, r2
 801c7e4:	7b5a      	ldrb	r2, [r3, #13]
 801c7e6:	2100      	movs	r1, #0
 801c7e8:	400a      	ands	r2, r1
 801c7ea:	1c11      	adds	r1, r2, #0
 801c7ec:	1c02      	adds	r2, r0, #0
 801c7ee:	430a      	orrs	r2, r1
 801c7f0:	735a      	strb	r2, [r3, #13]
    }
    if (changes & NEW_W) {
 801c7f2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c7f4:	2202      	movs	r2, #2
 801c7f6:	4013      	ands	r3, r2
 801c7f8:	d06c      	beq.n	801c8d4 <vj_uncompress_tcp+0x548>
      DECODES(th->wnd);
 801c7fa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c7fc:	781b      	ldrb	r3, [r3, #0]
 801c7fe:	2b00      	cmp	r3, #0
 801c800:	d139      	bne.n	801c876 <vj_uncompress_tcp+0x4ea>
 801c802:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c804:	7b9a      	ldrb	r2, [r3, #14]
 801c806:	7bdb      	ldrb	r3, [r3, #15]
 801c808:	021b      	lsls	r3, r3, #8
 801c80a:	4313      	orrs	r3, r2
 801c80c:	b29b      	uxth	r3, r3
 801c80e:	0018      	movs	r0, r3
 801c810:	f7ea fb70 	bl	8006ef4 <lwip_htons>
 801c814:	0003      	movs	r3, r0
 801c816:	0019      	movs	r1, r3
 801c818:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c81a:	3301      	adds	r3, #1
 801c81c:	781b      	ldrb	r3, [r3, #0]
 801c81e:	021b      	lsls	r3, r3, #8
 801c820:	b21a      	sxth	r2, r3
 801c822:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c824:	3302      	adds	r3, #2
 801c826:	781b      	ldrb	r3, [r3, #0]
 801c828:	b21b      	sxth	r3, r3
 801c82a:	4313      	orrs	r3, r2
 801c82c:	b21b      	sxth	r3, r3
 801c82e:	b29a      	uxth	r2, r3
 801c830:	2028      	movs	r0, #40	; 0x28
 801c832:	183b      	adds	r3, r7, r0
 801c834:	188a      	adds	r2, r1, r2
 801c836:	801a      	strh	r2, [r3, #0]
 801c838:	183b      	adds	r3, r7, r0
 801c83a:	881b      	ldrh	r3, [r3, #0]
 801c83c:	0018      	movs	r0, r3
 801c83e:	f7ea fb59 	bl	8006ef4 <lwip_htons>
 801c842:	0003      	movs	r3, r0
 801c844:	001a      	movs	r2, r3
 801c846:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c848:	21ff      	movs	r1, #255	; 0xff
 801c84a:	4011      	ands	r1, r2
 801c84c:	000c      	movs	r4, r1
 801c84e:	7b99      	ldrb	r1, [r3, #14]
 801c850:	2000      	movs	r0, #0
 801c852:	4001      	ands	r1, r0
 801c854:	1c08      	adds	r0, r1, #0
 801c856:	1c21      	adds	r1, r4, #0
 801c858:	4301      	orrs	r1, r0
 801c85a:	7399      	strb	r1, [r3, #14]
 801c85c:	0a12      	lsrs	r2, r2, #8
 801c85e:	b290      	uxth	r0, r2
 801c860:	7bda      	ldrb	r2, [r3, #15]
 801c862:	2100      	movs	r1, #0
 801c864:	400a      	ands	r2, r1
 801c866:	1c11      	adds	r1, r2, #0
 801c868:	1c02      	adds	r2, r0, #0
 801c86a:	430a      	orrs	r2, r1
 801c86c:	73da      	strb	r2, [r3, #15]
 801c86e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c870:	3303      	adds	r3, #3
 801c872:	64fb      	str	r3, [r7, #76]	; 0x4c
 801c874:	e02e      	b.n	801c8d4 <vj_uncompress_tcp+0x548>
 801c876:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c878:	7b9a      	ldrb	r2, [r3, #14]
 801c87a:	7bdb      	ldrb	r3, [r3, #15]
 801c87c:	021b      	lsls	r3, r3, #8
 801c87e:	4313      	orrs	r3, r2
 801c880:	b29b      	uxth	r3, r3
 801c882:	0018      	movs	r0, r3
 801c884:	f7ea fb36 	bl	8006ef4 <lwip_htons>
 801c888:	0003      	movs	r3, r0
 801c88a:	0019      	movs	r1, r3
 801c88c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c88e:	1c5a      	adds	r2, r3, #1
 801c890:	64fa      	str	r2, [r7, #76]	; 0x4c
 801c892:	781b      	ldrb	r3, [r3, #0]
 801c894:	b29a      	uxth	r2, r3
 801c896:	202a      	movs	r0, #42	; 0x2a
 801c898:	183b      	adds	r3, r7, r0
 801c89a:	188a      	adds	r2, r1, r2
 801c89c:	801a      	strh	r2, [r3, #0]
 801c89e:	183b      	adds	r3, r7, r0
 801c8a0:	881b      	ldrh	r3, [r3, #0]
 801c8a2:	0018      	movs	r0, r3
 801c8a4:	f7ea fb26 	bl	8006ef4 <lwip_htons>
 801c8a8:	0003      	movs	r3, r0
 801c8aa:	001a      	movs	r2, r3
 801c8ac:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c8ae:	21ff      	movs	r1, #255	; 0xff
 801c8b0:	4011      	ands	r1, r2
 801c8b2:	000c      	movs	r4, r1
 801c8b4:	7b99      	ldrb	r1, [r3, #14]
 801c8b6:	2000      	movs	r0, #0
 801c8b8:	4001      	ands	r1, r0
 801c8ba:	1c08      	adds	r0, r1, #0
 801c8bc:	1c21      	adds	r1, r4, #0
 801c8be:	4301      	orrs	r1, r0
 801c8c0:	7399      	strb	r1, [r3, #14]
 801c8c2:	0a12      	lsrs	r2, r2, #8
 801c8c4:	b290      	uxth	r0, r2
 801c8c6:	7bda      	ldrb	r2, [r3, #15]
 801c8c8:	2100      	movs	r1, #0
 801c8ca:	400a      	ands	r2, r1
 801c8cc:	1c11      	adds	r1, r2, #0
 801c8ce:	1c02      	adds	r2, r0, #0
 801c8d0:	430a      	orrs	r2, r1
 801c8d2:	73da      	strb	r2, [r3, #15]
    }
    if (changes & NEW_A) {
 801c8d4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c8d6:	2204      	movs	r2, #4
 801c8d8:	4013      	ands	r3, r2
 801c8da:	d100      	bne.n	801c8de <vj_uncompress_tcp+0x552>
 801c8dc:	e091      	b.n	801ca02 <vj_uncompress_tcp+0x676>
      DECODEL(th->ackno);
 801c8de:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c8e0:	781b      	ldrb	r3, [r3, #0]
 801c8e2:	2b00      	cmp	r3, #0
 801c8e4:	d14a      	bne.n	801c97c <vj_uncompress_tcp+0x5f0>
 801c8e6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c8e8:	7a1a      	ldrb	r2, [r3, #8]
 801c8ea:	7a59      	ldrb	r1, [r3, #9]
 801c8ec:	0209      	lsls	r1, r1, #8
 801c8ee:	430a      	orrs	r2, r1
 801c8f0:	7a99      	ldrb	r1, [r3, #10]
 801c8f2:	0409      	lsls	r1, r1, #16
 801c8f4:	430a      	orrs	r2, r1
 801c8f6:	7adb      	ldrb	r3, [r3, #11]
 801c8f8:	061b      	lsls	r3, r3, #24
 801c8fa:	4313      	orrs	r3, r2
 801c8fc:	0018      	movs	r0, r3
 801c8fe:	f7ea fb0f 	bl	8006f20 <lwip_htonl>
 801c902:	0001      	movs	r1, r0
 801c904:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c906:	3301      	adds	r3, #1
 801c908:	781b      	ldrb	r3, [r3, #0]
 801c90a:	021b      	lsls	r3, r3, #8
 801c90c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801c90e:	3202      	adds	r2, #2
 801c910:	7812      	ldrb	r2, [r2, #0]
 801c912:	4313      	orrs	r3, r2
 801c914:	18cb      	adds	r3, r1, r3
 801c916:	623b      	str	r3, [r7, #32]
 801c918:	6a3b      	ldr	r3, [r7, #32]
 801c91a:	0018      	movs	r0, r3
 801c91c:	f7ea fb00 	bl	8006f20 <lwip_htonl>
 801c920:	0002      	movs	r2, r0
 801c922:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c924:	21ff      	movs	r1, #255	; 0xff
 801c926:	4011      	ands	r1, r2
 801c928:	000c      	movs	r4, r1
 801c92a:	7a19      	ldrb	r1, [r3, #8]
 801c92c:	2000      	movs	r0, #0
 801c92e:	4001      	ands	r1, r0
 801c930:	1c08      	adds	r0, r1, #0
 801c932:	1c21      	adds	r1, r4, #0
 801c934:	4301      	orrs	r1, r0
 801c936:	7219      	strb	r1, [r3, #8]
 801c938:	0a11      	lsrs	r1, r2, #8
 801c93a:	20ff      	movs	r0, #255	; 0xff
 801c93c:	4001      	ands	r1, r0
 801c93e:	000c      	movs	r4, r1
 801c940:	7a59      	ldrb	r1, [r3, #9]
 801c942:	2000      	movs	r0, #0
 801c944:	4001      	ands	r1, r0
 801c946:	1c08      	adds	r0, r1, #0
 801c948:	1c21      	adds	r1, r4, #0
 801c94a:	4301      	orrs	r1, r0
 801c94c:	7259      	strb	r1, [r3, #9]
 801c94e:	0c11      	lsrs	r1, r2, #16
 801c950:	20ff      	movs	r0, #255	; 0xff
 801c952:	4001      	ands	r1, r0
 801c954:	000c      	movs	r4, r1
 801c956:	7a99      	ldrb	r1, [r3, #10]
 801c958:	2000      	movs	r0, #0
 801c95a:	4001      	ands	r1, r0
 801c95c:	1c08      	adds	r0, r1, #0
 801c95e:	1c21      	adds	r1, r4, #0
 801c960:	4301      	orrs	r1, r0
 801c962:	7299      	strb	r1, [r3, #10]
 801c964:	0e10      	lsrs	r0, r2, #24
 801c966:	7ada      	ldrb	r2, [r3, #11]
 801c968:	2100      	movs	r1, #0
 801c96a:	400a      	ands	r2, r1
 801c96c:	1c11      	adds	r1, r2, #0
 801c96e:	1c02      	adds	r2, r0, #0
 801c970:	430a      	orrs	r2, r1
 801c972:	72da      	strb	r2, [r3, #11]
 801c974:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c976:	3303      	adds	r3, #3
 801c978:	64fb      	str	r3, [r7, #76]	; 0x4c
 801c97a:	e042      	b.n	801ca02 <vj_uncompress_tcp+0x676>
 801c97c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c97e:	7a1a      	ldrb	r2, [r3, #8]
 801c980:	7a59      	ldrb	r1, [r3, #9]
 801c982:	0209      	lsls	r1, r1, #8
 801c984:	430a      	orrs	r2, r1
 801c986:	7a99      	ldrb	r1, [r3, #10]
 801c988:	0409      	lsls	r1, r1, #16
 801c98a:	430a      	orrs	r2, r1
 801c98c:	7adb      	ldrb	r3, [r3, #11]
 801c98e:	061b      	lsls	r3, r3, #24
 801c990:	4313      	orrs	r3, r2
 801c992:	0018      	movs	r0, r3
 801c994:	f7ea fac4 	bl	8006f20 <lwip_htonl>
 801c998:	0001      	movs	r1, r0
 801c99a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c99c:	1c5a      	adds	r2, r3, #1
 801c99e:	64fa      	str	r2, [r7, #76]	; 0x4c
 801c9a0:	781b      	ldrb	r3, [r3, #0]
 801c9a2:	18cb      	adds	r3, r1, r3
 801c9a4:	627b      	str	r3, [r7, #36]	; 0x24
 801c9a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c9a8:	0018      	movs	r0, r3
 801c9aa:	f7ea fab9 	bl	8006f20 <lwip_htonl>
 801c9ae:	0002      	movs	r2, r0
 801c9b0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c9b2:	21ff      	movs	r1, #255	; 0xff
 801c9b4:	4011      	ands	r1, r2
 801c9b6:	000c      	movs	r4, r1
 801c9b8:	7a19      	ldrb	r1, [r3, #8]
 801c9ba:	2000      	movs	r0, #0
 801c9bc:	4001      	ands	r1, r0
 801c9be:	1c08      	adds	r0, r1, #0
 801c9c0:	1c21      	adds	r1, r4, #0
 801c9c2:	4301      	orrs	r1, r0
 801c9c4:	7219      	strb	r1, [r3, #8]
 801c9c6:	0a11      	lsrs	r1, r2, #8
 801c9c8:	20ff      	movs	r0, #255	; 0xff
 801c9ca:	4001      	ands	r1, r0
 801c9cc:	000c      	movs	r4, r1
 801c9ce:	7a59      	ldrb	r1, [r3, #9]
 801c9d0:	2000      	movs	r0, #0
 801c9d2:	4001      	ands	r1, r0
 801c9d4:	1c08      	adds	r0, r1, #0
 801c9d6:	1c21      	adds	r1, r4, #0
 801c9d8:	4301      	orrs	r1, r0
 801c9da:	7259      	strb	r1, [r3, #9]
 801c9dc:	0c11      	lsrs	r1, r2, #16
 801c9de:	20ff      	movs	r0, #255	; 0xff
 801c9e0:	4001      	ands	r1, r0
 801c9e2:	000c      	movs	r4, r1
 801c9e4:	7a99      	ldrb	r1, [r3, #10]
 801c9e6:	2000      	movs	r0, #0
 801c9e8:	4001      	ands	r1, r0
 801c9ea:	1c08      	adds	r0, r1, #0
 801c9ec:	1c21      	adds	r1, r4, #0
 801c9ee:	4301      	orrs	r1, r0
 801c9f0:	7299      	strb	r1, [r3, #10]
 801c9f2:	0e10      	lsrs	r0, r2, #24
 801c9f4:	7ada      	ldrb	r2, [r3, #11]
 801c9f6:	2100      	movs	r1, #0
 801c9f8:	400a      	ands	r2, r1
 801c9fa:	1c11      	adds	r1, r2, #0
 801c9fc:	1c02      	adds	r2, r0, #0
 801c9fe:	430a      	orrs	r2, r1
 801ca00:	72da      	strb	r2, [r3, #11]
    }
    if (changes & NEW_S) {
 801ca02:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801ca04:	2208      	movs	r2, #8
 801ca06:	4013      	ands	r3, r2
 801ca08:	d100      	bne.n	801ca0c <vj_uncompress_tcp+0x680>
 801ca0a:	e091      	b.n	801cb30 <vj_uncompress_tcp+0x7a4>

    	DECODEL(th->seqno);
 801ca0c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801ca0e:	781b      	ldrb	r3, [r3, #0]
 801ca10:	2b00      	cmp	r3, #0
 801ca12:	d14a      	bne.n	801caaa <vj_uncompress_tcp+0x71e>
 801ca14:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ca16:	791a      	ldrb	r2, [r3, #4]
 801ca18:	7959      	ldrb	r1, [r3, #5]
 801ca1a:	0209      	lsls	r1, r1, #8
 801ca1c:	430a      	orrs	r2, r1
 801ca1e:	7999      	ldrb	r1, [r3, #6]
 801ca20:	0409      	lsls	r1, r1, #16
 801ca22:	430a      	orrs	r2, r1
 801ca24:	79db      	ldrb	r3, [r3, #7]
 801ca26:	061b      	lsls	r3, r3, #24
 801ca28:	4313      	orrs	r3, r2
 801ca2a:	0018      	movs	r0, r3
 801ca2c:	f7ea fa78 	bl	8006f20 <lwip_htonl>
 801ca30:	0001      	movs	r1, r0
 801ca32:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801ca34:	3301      	adds	r3, #1
 801ca36:	781b      	ldrb	r3, [r3, #0]
 801ca38:	021b      	lsls	r3, r3, #8
 801ca3a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801ca3c:	3202      	adds	r2, #2
 801ca3e:	7812      	ldrb	r2, [r2, #0]
 801ca40:	4313      	orrs	r3, r2
 801ca42:	18cb      	adds	r3, r1, r3
 801ca44:	61bb      	str	r3, [r7, #24]
 801ca46:	69bb      	ldr	r3, [r7, #24]
 801ca48:	0018      	movs	r0, r3
 801ca4a:	f7ea fa69 	bl	8006f20 <lwip_htonl>
 801ca4e:	0002      	movs	r2, r0
 801ca50:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ca52:	21ff      	movs	r1, #255	; 0xff
 801ca54:	4011      	ands	r1, r2
 801ca56:	000c      	movs	r4, r1
 801ca58:	7919      	ldrb	r1, [r3, #4]
 801ca5a:	2000      	movs	r0, #0
 801ca5c:	4001      	ands	r1, r0
 801ca5e:	1c08      	adds	r0, r1, #0
 801ca60:	1c21      	adds	r1, r4, #0
 801ca62:	4301      	orrs	r1, r0
 801ca64:	7119      	strb	r1, [r3, #4]
 801ca66:	0a11      	lsrs	r1, r2, #8
 801ca68:	20ff      	movs	r0, #255	; 0xff
 801ca6a:	4001      	ands	r1, r0
 801ca6c:	000c      	movs	r4, r1
 801ca6e:	7959      	ldrb	r1, [r3, #5]
 801ca70:	2000      	movs	r0, #0
 801ca72:	4001      	ands	r1, r0
 801ca74:	1c08      	adds	r0, r1, #0
 801ca76:	1c21      	adds	r1, r4, #0
 801ca78:	4301      	orrs	r1, r0
 801ca7a:	7159      	strb	r1, [r3, #5]
 801ca7c:	0c11      	lsrs	r1, r2, #16
 801ca7e:	20ff      	movs	r0, #255	; 0xff
 801ca80:	4001      	ands	r1, r0
 801ca82:	000c      	movs	r4, r1
 801ca84:	7999      	ldrb	r1, [r3, #6]
 801ca86:	2000      	movs	r0, #0
 801ca88:	4001      	ands	r1, r0
 801ca8a:	1c08      	adds	r0, r1, #0
 801ca8c:	1c21      	adds	r1, r4, #0
 801ca8e:	4301      	orrs	r1, r0
 801ca90:	7199      	strb	r1, [r3, #6]
 801ca92:	0e10      	lsrs	r0, r2, #24
 801ca94:	79da      	ldrb	r2, [r3, #7]
 801ca96:	2100      	movs	r1, #0
 801ca98:	400a      	ands	r2, r1
 801ca9a:	1c11      	adds	r1, r2, #0
 801ca9c:	1c02      	adds	r2, r0, #0
 801ca9e:	430a      	orrs	r2, r1
 801caa0:	71da      	strb	r2, [r3, #7]
 801caa2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801caa4:	3303      	adds	r3, #3
 801caa6:	64fb      	str	r3, [r7, #76]	; 0x4c
    }
    break;
 801caa8:	e042      	b.n	801cb30 <vj_uncompress_tcp+0x7a4>
    	DECODEL(th->seqno);
 801caaa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801caac:	791a      	ldrb	r2, [r3, #4]
 801caae:	7959      	ldrb	r1, [r3, #5]
 801cab0:	0209      	lsls	r1, r1, #8
 801cab2:	430a      	orrs	r2, r1
 801cab4:	7999      	ldrb	r1, [r3, #6]
 801cab6:	0409      	lsls	r1, r1, #16
 801cab8:	430a      	orrs	r2, r1
 801caba:	79db      	ldrb	r3, [r3, #7]
 801cabc:	061b      	lsls	r3, r3, #24
 801cabe:	4313      	orrs	r3, r2
 801cac0:	0018      	movs	r0, r3
 801cac2:	f7ea fa2d 	bl	8006f20 <lwip_htonl>
 801cac6:	0001      	movs	r1, r0
 801cac8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801caca:	1c5a      	adds	r2, r3, #1
 801cacc:	64fa      	str	r2, [r7, #76]	; 0x4c
 801cace:	781b      	ldrb	r3, [r3, #0]
 801cad0:	18cb      	adds	r3, r1, r3
 801cad2:	61fb      	str	r3, [r7, #28]
 801cad4:	69fb      	ldr	r3, [r7, #28]
 801cad6:	0018      	movs	r0, r3
 801cad8:	f7ea fa22 	bl	8006f20 <lwip_htonl>
 801cadc:	0002      	movs	r2, r0
 801cade:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cae0:	21ff      	movs	r1, #255	; 0xff
 801cae2:	4011      	ands	r1, r2
 801cae4:	000c      	movs	r4, r1
 801cae6:	7919      	ldrb	r1, [r3, #4]
 801cae8:	2000      	movs	r0, #0
 801caea:	4001      	ands	r1, r0
 801caec:	1c08      	adds	r0, r1, #0
 801caee:	1c21      	adds	r1, r4, #0
 801caf0:	4301      	orrs	r1, r0
 801caf2:	7119      	strb	r1, [r3, #4]
 801caf4:	0a11      	lsrs	r1, r2, #8
 801caf6:	20ff      	movs	r0, #255	; 0xff
 801caf8:	4001      	ands	r1, r0
 801cafa:	000c      	movs	r4, r1
 801cafc:	7959      	ldrb	r1, [r3, #5]
 801cafe:	2000      	movs	r0, #0
 801cb00:	4001      	ands	r1, r0
 801cb02:	1c08      	adds	r0, r1, #0
 801cb04:	1c21      	adds	r1, r4, #0
 801cb06:	4301      	orrs	r1, r0
 801cb08:	7159      	strb	r1, [r3, #5]
 801cb0a:	0c11      	lsrs	r1, r2, #16
 801cb0c:	20ff      	movs	r0, #255	; 0xff
 801cb0e:	4001      	ands	r1, r0
 801cb10:	000c      	movs	r4, r1
 801cb12:	7999      	ldrb	r1, [r3, #6]
 801cb14:	2000      	movs	r0, #0
 801cb16:	4001      	ands	r1, r0
 801cb18:	1c08      	adds	r0, r1, #0
 801cb1a:	1c21      	adds	r1, r4, #0
 801cb1c:	4301      	orrs	r1, r0
 801cb1e:	7199      	strb	r1, [r3, #6]
 801cb20:	0e10      	lsrs	r0, r2, #24
 801cb22:	79da      	ldrb	r2, [r3, #7]
 801cb24:	2100      	movs	r1, #0
 801cb26:	400a      	ands	r2, r1
 801cb28:	1c11      	adds	r1, r2, #0
 801cb2a:	1c02      	adds	r2, r0, #0
 801cb2c:	430a      	orrs	r2, r1
 801cb2e:	71da      	strb	r2, [r3, #7]
    break;
 801cb30:	46c0      	nop			; (mov r8, r8)
  }
  if (changes & NEW_I) {
 801cb32:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801cb34:	2220      	movs	r2, #32
 801cb36:	4013      	ands	r3, r2
 801cb38:	d041      	beq.n	801cbbe <vj_uncompress_tcp+0x832>
    DECODES(cs->cs_ip._id);
 801cb3a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801cb3c:	781b      	ldrb	r3, [r3, #0]
 801cb3e:	2b00      	cmp	r3, #0
 801cb40:	d123      	bne.n	801cb8a <vj_uncompress_tcp+0x7fe>
 801cb42:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cb44:	899b      	ldrh	r3, [r3, #12]
 801cb46:	0018      	movs	r0, r3
 801cb48:	f7ea f9d4 	bl	8006ef4 <lwip_htons>
 801cb4c:	0003      	movs	r3, r0
 801cb4e:	0019      	movs	r1, r3
 801cb50:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801cb52:	3301      	adds	r3, #1
 801cb54:	781b      	ldrb	r3, [r3, #0]
 801cb56:	021b      	lsls	r3, r3, #8
 801cb58:	b21a      	sxth	r2, r3
 801cb5a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801cb5c:	3302      	adds	r3, #2
 801cb5e:	781b      	ldrb	r3, [r3, #0]
 801cb60:	b21b      	sxth	r3, r3
 801cb62:	4313      	orrs	r3, r2
 801cb64:	b21b      	sxth	r3, r3
 801cb66:	b29a      	uxth	r2, r3
 801cb68:	2014      	movs	r0, #20
 801cb6a:	183b      	adds	r3, r7, r0
 801cb6c:	188a      	adds	r2, r1, r2
 801cb6e:	801a      	strh	r2, [r3, #0]
 801cb70:	183b      	adds	r3, r7, r0
 801cb72:	881b      	ldrh	r3, [r3, #0]
 801cb74:	0018      	movs	r0, r3
 801cb76:	f7ea f9bd 	bl	8006ef4 <lwip_htons>
 801cb7a:	0003      	movs	r3, r0
 801cb7c:	001a      	movs	r2, r3
 801cb7e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cb80:	819a      	strh	r2, [r3, #12]
 801cb82:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801cb84:	3303      	adds	r3, #3
 801cb86:	64fb      	str	r3, [r7, #76]	; 0x4c
 801cb88:	e02c      	b.n	801cbe4 <vj_uncompress_tcp+0x858>
 801cb8a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cb8c:	899b      	ldrh	r3, [r3, #12]
 801cb8e:	0018      	movs	r0, r3
 801cb90:	f7ea f9b0 	bl	8006ef4 <lwip_htons>
 801cb94:	0003      	movs	r3, r0
 801cb96:	0019      	movs	r1, r3
 801cb98:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801cb9a:	1c5a      	adds	r2, r3, #1
 801cb9c:	64fa      	str	r2, [r7, #76]	; 0x4c
 801cb9e:	781b      	ldrb	r3, [r3, #0]
 801cba0:	b29a      	uxth	r2, r3
 801cba2:	2016      	movs	r0, #22
 801cba4:	183b      	adds	r3, r7, r0
 801cba6:	188a      	adds	r2, r1, r2
 801cba8:	801a      	strh	r2, [r3, #0]
 801cbaa:	183b      	adds	r3, r7, r0
 801cbac:	881b      	ldrh	r3, [r3, #0]
 801cbae:	0018      	movs	r0, r3
 801cbb0:	f7ea f9a0 	bl	8006ef4 <lwip_htons>
 801cbb4:	0003      	movs	r3, r0
 801cbb6:	001a      	movs	r2, r3
 801cbb8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cbba:	819a      	strh	r2, [r3, #12]
 801cbbc:	e012      	b.n	801cbe4 <vj_uncompress_tcp+0x858>
  } else {
    IPH_ID_SET(&cs->cs_ip, lwip_ntohs(IPH_ID(&cs->cs_ip)) + 1);
 801cbbe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cbc0:	899b      	ldrh	r3, [r3, #12]
 801cbc2:	0018      	movs	r0, r3
 801cbc4:	f7ea f996 	bl	8006ef4 <lwip_htons>
 801cbc8:	0003      	movs	r3, r0
 801cbca:	3301      	adds	r3, #1
 801cbcc:	b29a      	uxth	r2, r3
 801cbce:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cbd0:	819a      	strh	r2, [r3, #12]
    IPH_ID_SET(&cs->cs_ip, lwip_htons(IPH_ID(&cs->cs_ip)));
 801cbd2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cbd4:	899b      	ldrh	r3, [r3, #12]
 801cbd6:	0018      	movs	r0, r3
 801cbd8:	f7ea f98c 	bl	8006ef4 <lwip_htons>
 801cbdc:	0003      	movs	r3, r0
 801cbde:	001a      	movs	r2, r3
 801cbe0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cbe2:	819a      	strh	r2, [r3, #12]
  /*
   * At this point, cp points to the first byte of data in the
   * packet.  Fill in the IP total length and update the IP
   * header checksum.
   */
  vjlen = (u16_t)(cp - (u8_t*)n0->payload);
 801cbe4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801cbe6:	685b      	ldr	r3, [r3, #4]
 801cbe8:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801cbea:	1ad3      	subs	r3, r2, r3
 801cbec:	b29b      	uxth	r3, r3
 801cbee:	613b      	str	r3, [r7, #16]
  if (n0->len < vjlen) {
 801cbf0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801cbf2:	895b      	ldrh	r3, [r3, #10]
 801cbf4:	001a      	movs	r2, r3
 801cbf6:	693b      	ldr	r3, [r7, #16]
 801cbf8:	4293      	cmp	r3, r2
 801cbfa:	d900      	bls.n	801cbfe <vj_uncompress_tcp+0x872>
 801cbfc:	e0e2      	b.n	801cdc4 <vj_uncompress_tcp+0xa38>
          n0->len, vjlen));
    goto bad;
  }

#if BYTE_ORDER == LITTLE_ENDIAN
  tmp = n0->tot_len - vjlen + cs->cs_hlen;
 801cbfe:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801cc00:	891b      	ldrh	r3, [r3, #8]
 801cc02:	001a      	movs	r2, r3
 801cc04:	693b      	ldr	r3, [r7, #16]
 801cc06:	1ad3      	subs	r3, r2, r3
 801cc08:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801cc0a:	8892      	ldrh	r2, [r2, #4]
 801cc0c:	189b      	adds	r3, r3, r2
 801cc0e:	643b      	str	r3, [r7, #64]	; 0x40
  IPH_LEN_SET(&cs->cs_ip, lwip_htons((u16_t)tmp));
 801cc10:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801cc12:	b29b      	uxth	r3, r3
 801cc14:	0018      	movs	r0, r3
 801cc16:	f7ea f96d 	bl	8006ef4 <lwip_htons>
 801cc1a:	0003      	movs	r3, r0
 801cc1c:	001a      	movs	r2, r3
 801cc1e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cc20:	815a      	strh	r2, [r3, #10]
#else
  IPH_LEN_SET(&cs->cs_ip, lwip_htons(n0->tot_len - vjlen + cs->cs_hlen));
#endif

  /* recompute the ip header checksum */
  bp = (struct vj_u16_t*) &cs->cs_ip;
 801cc22:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cc24:	3308      	adds	r3, #8
 801cc26:	64bb      	str	r3, [r7, #72]	; 0x48
  IPH_CHKSUM_SET(&cs->cs_ip, 0);
 801cc28:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cc2a:	2200      	movs	r2, #0
 801cc2c:	825a      	strh	r2, [r3, #18]
  for (tmp = 0; hlen > 0; hlen -= 2) {
 801cc2e:	2300      	movs	r3, #0
 801cc30:	643b      	str	r3, [r7, #64]	; 0x40
 801cc32:	e00e      	b.n	801cc52 <vj_uncompress_tcp+0x8c6>
    tmp += (*bp++).v;
 801cc34:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801cc36:	1c9a      	adds	r2, r3, #2
 801cc38:	64ba      	str	r2, [r7, #72]	; 0x48
 801cc3a:	781a      	ldrb	r2, [r3, #0]
 801cc3c:	785b      	ldrb	r3, [r3, #1]
 801cc3e:	021b      	lsls	r3, r3, #8
 801cc40:	4313      	orrs	r3, r2
 801cc42:	b29b      	uxth	r3, r3
 801cc44:	001a      	movs	r2, r3
 801cc46:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801cc48:	189b      	adds	r3, r3, r2
 801cc4a:	643b      	str	r3, [r7, #64]	; 0x40
  for (tmp = 0; hlen > 0; hlen -= 2) {
 801cc4c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801cc4e:	3b02      	subs	r3, #2
 801cc50:	63fb      	str	r3, [r7, #60]	; 0x3c
 801cc52:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801cc54:	2b00      	cmp	r3, #0
 801cc56:	d1ed      	bne.n	801cc34 <vj_uncompress_tcp+0x8a8>
  }
  tmp = (tmp & 0xffff) + (tmp >> 16);
 801cc58:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801cc5a:	041b      	lsls	r3, r3, #16
 801cc5c:	0c1a      	lsrs	r2, r3, #16
 801cc5e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801cc60:	0c1b      	lsrs	r3, r3, #16
 801cc62:	18d3      	adds	r3, r2, r3
 801cc64:	643b      	str	r3, [r7, #64]	; 0x40
  tmp = (tmp & 0xffff) + (tmp >> 16);
 801cc66:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801cc68:	041b      	lsls	r3, r3, #16
 801cc6a:	0c1a      	lsrs	r2, r3, #16
 801cc6c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801cc6e:	0c1b      	lsrs	r3, r3, #16
 801cc70:	18d3      	adds	r3, r2, r3
 801cc72:	643b      	str	r3, [r7, #64]	; 0x40
  IPH_CHKSUM_SET(&cs->cs_ip,  (u16_t)(~tmp));
 801cc74:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801cc76:	b29b      	uxth	r3, r3
 801cc78:	43db      	mvns	r3, r3
 801cc7a:	b29a      	uxth	r2, r3
 801cc7c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cc7e:	825a      	strh	r2, [r3, #18]

  /* Remove the compressed header and prepend the uncompressed header. */
  if (pbuf_remove_header(n0, vjlen)) {
 801cc80:	693a      	ldr	r2, [r7, #16]
 801cc82:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801cc84:	0011      	movs	r1, r2
 801cc86:	0018      	movs	r0, r3
 801cc88:	f7ed f840 	bl	8009d0c <pbuf_remove_header>
 801cc8c:	1e03      	subs	r3, r0, #0
 801cc8e:	d006      	beq.n	801cc9e <vj_uncompress_tcp+0x912>
    /* Can we cope with this failing?  Just assert for now */
    LWIP_ASSERT("pbuf_remove_header failed\n", 0);
 801cc90:	4b54      	ldr	r3, [pc, #336]	; (801cde4 <vj_uncompress_tcp+0xa58>)
 801cc92:	4a55      	ldr	r2, [pc, #340]	; (801cde8 <vj_uncompress_tcp+0xa5c>)
 801cc94:	4955      	ldr	r1, [pc, #340]	; (801cdec <vj_uncompress_tcp+0xa60>)
 801cc96:	4856      	ldr	r0, [pc, #344]	; (801cdf0 <vj_uncompress_tcp+0xa64>)
 801cc98:	f7e5 ff96 	bl	8002bc8 <app_debug_rtt_raw>
    goto bad;
 801cc9c:	e097      	b.n	801cdce <vj_uncompress_tcp+0xa42>
  }

  if(LWIP_MEM_ALIGN(n0->payload) != n0->payload) {
 801cc9e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801cca0:	685b      	ldr	r3, [r3, #4]
 801cca2:	3303      	adds	r3, #3
 801cca4:	2203      	movs	r2, #3
 801cca6:	4393      	bics	r3, r2
 801cca8:	001a      	movs	r2, r3
 801ccaa:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801ccac:	685b      	ldr	r3, [r3, #4]
 801ccae:	429a      	cmp	r2, r3
 801ccb0:	d040      	beq.n	801cd34 <vj_uncompress_tcp+0x9a8>
     * the packet is being allocated with enough header space to be
     * forwarded (to Ethernet for example).
     */
    np = pbuf_alloc(PBUF_LINK, n0->len + cs->cs_hlen, PBUF_POOL);
#else /* IP_FORWARD */
    np = pbuf_alloc(PBUF_RAW, n0->len + cs->cs_hlen, PBUF_POOL);
 801ccb2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801ccb4:	895a      	ldrh	r2, [r3, #10]
 801ccb6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801ccb8:	889b      	ldrh	r3, [r3, #4]
 801ccba:	18d3      	adds	r3, r2, r3
 801ccbc:	b29b      	uxth	r3, r3
 801ccbe:	22c1      	movs	r2, #193	; 0xc1
 801ccc0:	0052      	lsls	r2, r2, #1
 801ccc2:	0019      	movs	r1, r3
 801ccc4:	2000      	movs	r0, #0
 801ccc6:	f7ec fd81 	bl	80097cc <pbuf_alloc>
 801ccca:	0003      	movs	r3, r0
 801cccc:	60fb      	str	r3, [r7, #12]
#endif /* IP_FORWARD */
    if(!np) {
 801ccce:	68fb      	ldr	r3, [r7, #12]
 801ccd0:	2b00      	cmp	r3, #0
 801ccd2:	d100      	bne.n	801ccd6 <vj_uncompress_tcp+0x94a>
 801ccd4:	e078      	b.n	801cdc8 <vj_uncompress_tcp+0xa3c>
      PPPDEBUG(LOG_WARNING, ("vj_uncompress_tcp: realign failed\n"));
      goto bad;
    }

    if (pbuf_remove_header(np, cs->cs_hlen)) {
 801ccd6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801ccd8:	889b      	ldrh	r3, [r3, #4]
 801ccda:	001a      	movs	r2, r3
 801ccdc:	68fb      	ldr	r3, [r7, #12]
 801ccde:	0011      	movs	r1, r2
 801cce0:	0018      	movs	r0, r3
 801cce2:	f7ed f813 	bl	8009d0c <pbuf_remove_header>
 801cce6:	1e03      	subs	r3, r0, #0
 801cce8:	d007      	beq.n	801ccfa <vj_uncompress_tcp+0x96e>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_remove_header failed\n", 0);
 801ccea:	4b3e      	ldr	r3, [pc, #248]	; (801cde4 <vj_uncompress_tcp+0xa58>)
 801ccec:	22a2      	movs	r2, #162	; 0xa2
 801ccee:	0092      	lsls	r2, r2, #2
 801ccf0:	493e      	ldr	r1, [pc, #248]	; (801cdec <vj_uncompress_tcp+0xa60>)
 801ccf2:	483f      	ldr	r0, [pc, #252]	; (801cdf0 <vj_uncompress_tcp+0xa64>)
 801ccf4:	f7e5 ff68 	bl	8002bc8 <app_debug_rtt_raw>
      goto bad;
 801ccf8:	e069      	b.n	801cdce <vj_uncompress_tcp+0xa42>
    }

    pbuf_take(np, n0->payload, n0->len);
 801ccfa:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801ccfc:	6859      	ldr	r1, [r3, #4]
 801ccfe:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801cd00:	895a      	ldrh	r2, [r3, #10]
 801cd02:	68fb      	ldr	r3, [r7, #12]
 801cd04:	0018      	movs	r0, r3
 801cd06:	f7ed fc79 	bl	800a5fc <pbuf_take>

    if(n0->next) {
 801cd0a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801cd0c:	681b      	ldr	r3, [r3, #0]
 801cd0e:	2b00      	cmp	r3, #0
 801cd10:	d00a      	beq.n	801cd28 <vj_uncompress_tcp+0x99c>
      pbuf_chain(np, n0->next);
 801cd12:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801cd14:	681a      	ldr	r2, [r3, #0]
 801cd16:	68fb      	ldr	r3, [r7, #12]
 801cd18:	0011      	movs	r1, r2
 801cd1a:	0018      	movs	r0, r3
 801cd1c:	f7ed fa02 	bl	800a124 <pbuf_chain>
      pbuf_dechain(n0);
 801cd20:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801cd22:	0018      	movs	r0, r3
 801cd24:	f7ed fa12 	bl	800a14c <pbuf_dechain>
    }
    pbuf_free(n0);
 801cd28:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801cd2a:	0018      	movs	r0, r3
 801cd2c:	f7ed f8c6 	bl	8009ebc <pbuf_free>
    n0 = np;
 801cd30:	68fb      	ldr	r3, [r7, #12]
 801cd32:	647b      	str	r3, [r7, #68]	; 0x44
  }

  if (pbuf_add_header(n0, cs->cs_hlen)) {
 801cd34:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cd36:	889b      	ldrh	r3, [r3, #4]
 801cd38:	001a      	movs	r2, r3
 801cd3a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801cd3c:	0011      	movs	r1, r2
 801cd3e:	0018      	movs	r0, r3
 801cd40:	f7ec ffd4 	bl	8009cec <pbuf_add_header>
 801cd44:	1e03      	subs	r3, r0, #0
 801cd46:	d020      	beq.n	801cd8a <vj_uncompress_tcp+0x9fe>
    struct pbuf *np;

    LWIP_ASSERT("vj_uncompress_tcp: cs->cs_hlen <= PBUF_POOL_BUFSIZE", cs->cs_hlen <= PBUF_POOL_BUFSIZE);
 801cd48:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cd4a:	889a      	ldrh	r2, [r3, #4]
 801cd4c:	2394      	movs	r3, #148	; 0x94
 801cd4e:	009b      	lsls	r3, r3, #2
 801cd50:	429a      	cmp	r2, r3
 801cd52:	d905      	bls.n	801cd60 <vj_uncompress_tcp+0x9d4>
 801cd54:	4b23      	ldr	r3, [pc, #140]	; (801cde4 <vj_uncompress_tcp+0xa58>)
 801cd56:	4a27      	ldr	r2, [pc, #156]	; (801cdf4 <vj_uncompress_tcp+0xa68>)
 801cd58:	4927      	ldr	r1, [pc, #156]	; (801cdf8 <vj_uncompress_tcp+0xa6c>)
 801cd5a:	4825      	ldr	r0, [pc, #148]	; (801cdf0 <vj_uncompress_tcp+0xa64>)
 801cd5c:	f7e5 ff34 	bl	8002bc8 <app_debug_rtt_raw>
    np = pbuf_alloc(PBUF_RAW, cs->cs_hlen, PBUF_POOL);
 801cd60:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cd62:	889b      	ldrh	r3, [r3, #4]
 801cd64:	22c1      	movs	r2, #193	; 0xc1
 801cd66:	0052      	lsls	r2, r2, #1
 801cd68:	0019      	movs	r1, r3
 801cd6a:	2000      	movs	r0, #0
 801cd6c:	f7ec fd2e 	bl	80097cc <pbuf_alloc>
 801cd70:	0003      	movs	r3, r0
 801cd72:	60bb      	str	r3, [r7, #8]
    if(!np) {
 801cd74:	68bb      	ldr	r3, [r7, #8]
 801cd76:	2b00      	cmp	r3, #0
 801cd78:	d028      	beq.n	801cdcc <vj_uncompress_tcp+0xa40>
      PPPDEBUG(LOG_WARNING, ("vj_uncompress_tcp: prepend failed\n"));
      goto bad;
    }
    pbuf_cat(np, n0);
 801cd7a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801cd7c:	68bb      	ldr	r3, [r7, #8]
 801cd7e:	0011      	movs	r1, r2
 801cd80:	0018      	movs	r0, r3
 801cd82:	f7ed f97b 	bl	800a07c <pbuf_cat>
    n0 = np;
 801cd86:	68bb      	ldr	r3, [r7, #8]
 801cd88:	647b      	str	r3, [r7, #68]	; 0x44
  }
  LWIP_ASSERT("n0->len >= cs->cs_hlen", n0->len >= cs->cs_hlen);
 801cd8a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801cd8c:	895a      	ldrh	r2, [r3, #10]
 801cd8e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cd90:	889b      	ldrh	r3, [r3, #4]
 801cd92:	429a      	cmp	r2, r3
 801cd94:	d205      	bcs.n	801cda2 <vj_uncompress_tcp+0xa16>
 801cd96:	4b13      	ldr	r3, [pc, #76]	; (801cde4 <vj_uncompress_tcp+0xa58>)
 801cd98:	4a18      	ldr	r2, [pc, #96]	; (801cdfc <vj_uncompress_tcp+0xa70>)
 801cd9a:	4919      	ldr	r1, [pc, #100]	; (801ce00 <vj_uncompress_tcp+0xa74>)
 801cd9c:	4814      	ldr	r0, [pc, #80]	; (801cdf0 <vj_uncompress_tcp+0xa64>)
 801cd9e:	f7e5 ff13 	bl	8002bc8 <app_debug_rtt_raw>
  MEMCPY(n0->payload, &cs->cs_ip, cs->cs_hlen);
 801cda2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801cda4:	6858      	ldr	r0, [r3, #4]
 801cda6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cda8:	3308      	adds	r3, #8
 801cdaa:	0019      	movs	r1, r3
 801cdac:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cdae:	889b      	ldrh	r3, [r3, #4]
 801cdb0:	001a      	movs	r2, r3
 801cdb2:	f000 f88b 	bl	801cecc <memcpy>

  *nb = n0;
 801cdb6:	687b      	ldr	r3, [r7, #4]
 801cdb8:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801cdba:	601a      	str	r2, [r3, #0]

  return vjlen;
 801cdbc:	693b      	ldr	r3, [r7, #16]
 801cdbe:	e00c      	b.n	801cdda <vj_uncompress_tcp+0xa4e>
      goto bad;
 801cdc0:	46c0      	nop			; (mov r8, r8)
 801cdc2:	e004      	b.n	801cdce <vj_uncompress_tcp+0xa42>
    goto bad;
 801cdc4:	46c0      	nop			; (mov r8, r8)
 801cdc6:	e002      	b.n	801cdce <vj_uncompress_tcp+0xa42>
      goto bad;
 801cdc8:	46c0      	nop			; (mov r8, r8)
 801cdca:	e000      	b.n	801cdce <vj_uncompress_tcp+0xa42>
      goto bad;
 801cdcc:	46c0      	nop			; (mov r8, r8)

bad:
  vj_uncompress_err(comp);
 801cdce:	683b      	ldr	r3, [r7, #0]
 801cdd0:	0018      	movs	r0, r3
 801cdd2:	f7ff fa5d 	bl	801c290 <vj_uncompress_err>
  return (-1);
 801cdd6:	2301      	movs	r3, #1
 801cdd8:	425b      	negs	r3, r3
}
 801cdda:	0018      	movs	r0, r3
 801cddc:	46bd      	mov	sp, r7
 801cdde:	b015      	add	sp, #84	; 0x54
 801cde0:	bd90      	pop	{r4, r7, pc}
 801cde2:	46c0      	nop			; (mov r8, r8)
 801cde4:	08022050 	.word	0x08022050
 801cde8:	00000271 	.word	0x00000271
 801cdec:	0802207c 	.word	0x0802207c
 801cdf0:	08022098 	.word	0x08022098
 801cdf4:	00000299 	.word	0x00000299
 801cdf8:	080220c4 	.word	0x080220c4
 801cdfc:	000002a2 	.word	0x000002a2
 801ce00:	080220f8 	.word	0x080220f8

0801ce04 <sys_rand>:
 */



extern uint32_t sys_rand()
{
 801ce04:	b580      	push	{r7, lr}
 801ce06:	af00      	add	r7, sp, #0
    return SysTick->VAL;
 801ce08:	4b02      	ldr	r3, [pc, #8]	; (801ce14 <sys_rand+0x10>)
 801ce0a:	689b      	ldr	r3, [r3, #8]
}
 801ce0c:	0018      	movs	r0, r3
 801ce0e:	46bd      	mov	sp, r7
 801ce10:	bd80      	pop	{r7, pc}
 801ce12:	46c0      	nop			; (mov r8, r8)
 801ce14:	e000e010 	.word	0xe000e010

0801ce18 <sys_get_tick_ms>:

extern uint32_t sys_get_tick_ms()
{
 801ce18:	b580      	push	{r7, lr}
 801ce1a:	af00      	add	r7, sp, #0
    return HAL_GetTick();
 801ce1c:	f7e6 f84a 	bl	8002eb4 <HAL_GetTick>
 801ce20:	0003      	movs	r3, r0
}
 801ce22:	0018      	movs	r0, r3
 801ce24:	46bd      	mov	sp, r7
 801ce26:	bd80      	pop	{r7, pc}

0801ce28 <sys_now>:



uint32_t sys_now(void)
{
 801ce28:	b580      	push	{r7, lr}
 801ce2a:	af00      	add	r7, sp, #0
    return sys_get_tick_ms();
 801ce2c:	f7ff fff4 	bl	801ce18 <sys_get_tick_ms>
 801ce30:	0003      	movs	r3, r0
}
 801ce32:	0018      	movs	r0, r3
 801ce34:	46bd      	mov	sp, r7
 801ce36:	bd80      	pop	{r7, pc}

0801ce38 <sys_jiffies>:

/**
 * @brief Override LWIP weak function
 */
uint32_t sys_jiffies(void)
{
 801ce38:	b580      	push	{r7, lr}
 801ce3a:	af00      	add	r7, sp, #0
    return sys_get_tick_ms();
 801ce3c:	f7ff ffec 	bl	801ce18 <sys_get_tick_ms>
 801ce40:	0003      	movs	r3, r0
}
 801ce42:	0018      	movs	r0, r3
 801ce44:	46bd      	mov	sp, r7
 801ce46:	bd80      	pop	{r7, pc}

0801ce48 <atoi>:
 801ce48:	b510      	push	{r4, lr}
 801ce4a:	220a      	movs	r2, #10
 801ce4c:	2100      	movs	r1, #0
 801ce4e:	f000 fa07 	bl	801d260 <strtol>
 801ce52:	bd10      	pop	{r4, pc}

0801ce54 <__libc_init_array>:
 801ce54:	b570      	push	{r4, r5, r6, lr}
 801ce56:	2600      	movs	r6, #0
 801ce58:	4d0c      	ldr	r5, [pc, #48]	; (801ce8c <__libc_init_array+0x38>)
 801ce5a:	4c0d      	ldr	r4, [pc, #52]	; (801ce90 <__libc_init_array+0x3c>)
 801ce5c:	1b64      	subs	r4, r4, r5
 801ce5e:	10a4      	asrs	r4, r4, #2
 801ce60:	42a6      	cmp	r6, r4
 801ce62:	d109      	bne.n	801ce78 <__libc_init_array+0x24>
 801ce64:	2600      	movs	r6, #0
 801ce66:	f000 fd75 	bl	801d954 <_init>
 801ce6a:	4d0a      	ldr	r5, [pc, #40]	; (801ce94 <__libc_init_array+0x40>)
 801ce6c:	4c0a      	ldr	r4, [pc, #40]	; (801ce98 <__libc_init_array+0x44>)
 801ce6e:	1b64      	subs	r4, r4, r5
 801ce70:	10a4      	asrs	r4, r4, #2
 801ce72:	42a6      	cmp	r6, r4
 801ce74:	d105      	bne.n	801ce82 <__libc_init_array+0x2e>
 801ce76:	bd70      	pop	{r4, r5, r6, pc}
 801ce78:	00b3      	lsls	r3, r6, #2
 801ce7a:	58eb      	ldr	r3, [r5, r3]
 801ce7c:	4798      	blx	r3
 801ce7e:	3601      	adds	r6, #1
 801ce80:	e7ee      	b.n	801ce60 <__libc_init_array+0xc>
 801ce82:	00b3      	lsls	r3, r6, #2
 801ce84:	58eb      	ldr	r3, [r5, r3]
 801ce86:	4798      	blx	r3
 801ce88:	3601      	adds	r6, #1
 801ce8a:	e7f2      	b.n	801ce72 <__libc_init_array+0x1e>
 801ce8c:	08023000 	.word	0x08023000
 801ce90:	08023000 	.word	0x08023000
 801ce94:	08023000 	.word	0x08023000
 801ce98:	08023004 	.word	0x08023004

0801ce9c <malloc>:
 801ce9c:	b510      	push	{r4, lr}
 801ce9e:	4b03      	ldr	r3, [pc, #12]	; (801ceac <malloc+0x10>)
 801cea0:	0001      	movs	r1, r0
 801cea2:	6818      	ldr	r0, [r3, #0]
 801cea4:	f000 f880 	bl	801cfa8 <_malloc_r>
 801cea8:	bd10      	pop	{r4, pc}
 801ceaa:	46c0      	nop			; (mov r8, r8)
 801ceac:	20000038 	.word	0x20000038

0801ceb0 <memcmp>:
 801ceb0:	b530      	push	{r4, r5, lr}
 801ceb2:	2400      	movs	r4, #0
 801ceb4:	3901      	subs	r1, #1
 801ceb6:	42a2      	cmp	r2, r4
 801ceb8:	d101      	bne.n	801cebe <memcmp+0xe>
 801ceba:	2000      	movs	r0, #0
 801cebc:	e005      	b.n	801ceca <memcmp+0x1a>
 801cebe:	5d03      	ldrb	r3, [r0, r4]
 801cec0:	3401      	adds	r4, #1
 801cec2:	5d0d      	ldrb	r5, [r1, r4]
 801cec4:	42ab      	cmp	r3, r5
 801cec6:	d0f6      	beq.n	801ceb6 <memcmp+0x6>
 801cec8:	1b58      	subs	r0, r3, r5
 801ceca:	bd30      	pop	{r4, r5, pc}

0801cecc <memcpy>:
 801cecc:	2300      	movs	r3, #0
 801cece:	b510      	push	{r4, lr}
 801ced0:	429a      	cmp	r2, r3
 801ced2:	d100      	bne.n	801ced6 <memcpy+0xa>
 801ced4:	bd10      	pop	{r4, pc}
 801ced6:	5ccc      	ldrb	r4, [r1, r3]
 801ced8:	54c4      	strb	r4, [r0, r3]
 801ceda:	3301      	adds	r3, #1
 801cedc:	e7f8      	b.n	801ced0 <memcpy+0x4>

0801cede <memmove>:
 801cede:	b510      	push	{r4, lr}
 801cee0:	4288      	cmp	r0, r1
 801cee2:	d902      	bls.n	801ceea <memmove+0xc>
 801cee4:	188b      	adds	r3, r1, r2
 801cee6:	4298      	cmp	r0, r3
 801cee8:	d303      	bcc.n	801cef2 <memmove+0x14>
 801ceea:	2300      	movs	r3, #0
 801ceec:	e007      	b.n	801cefe <memmove+0x20>
 801ceee:	5c8b      	ldrb	r3, [r1, r2]
 801cef0:	5483      	strb	r3, [r0, r2]
 801cef2:	3a01      	subs	r2, #1
 801cef4:	d2fb      	bcs.n	801ceee <memmove+0x10>
 801cef6:	bd10      	pop	{r4, pc}
 801cef8:	5ccc      	ldrb	r4, [r1, r3]
 801cefa:	54c4      	strb	r4, [r0, r3]
 801cefc:	3301      	adds	r3, #1
 801cefe:	429a      	cmp	r2, r3
 801cf00:	d1fa      	bne.n	801cef8 <memmove+0x1a>
 801cf02:	e7f8      	b.n	801cef6 <memmove+0x18>

0801cf04 <memset>:
 801cf04:	0003      	movs	r3, r0
 801cf06:	1882      	adds	r2, r0, r2
 801cf08:	4293      	cmp	r3, r2
 801cf0a:	d100      	bne.n	801cf0e <memset+0xa>
 801cf0c:	4770      	bx	lr
 801cf0e:	7019      	strb	r1, [r3, #0]
 801cf10:	3301      	adds	r3, #1
 801cf12:	e7f9      	b.n	801cf08 <memset+0x4>

0801cf14 <_free_r>:
 801cf14:	b570      	push	{r4, r5, r6, lr}
 801cf16:	0005      	movs	r5, r0
 801cf18:	2900      	cmp	r1, #0
 801cf1a:	d010      	beq.n	801cf3e <_free_r+0x2a>
 801cf1c:	1f0c      	subs	r4, r1, #4
 801cf1e:	6823      	ldr	r3, [r4, #0]
 801cf20:	2b00      	cmp	r3, #0
 801cf22:	da00      	bge.n	801cf26 <_free_r+0x12>
 801cf24:	18e4      	adds	r4, r4, r3
 801cf26:	0028      	movs	r0, r5
 801cf28:	f000 f9e6 	bl	801d2f8 <__malloc_lock>
 801cf2c:	4a1d      	ldr	r2, [pc, #116]	; (801cfa4 <_free_r+0x90>)
 801cf2e:	6813      	ldr	r3, [r2, #0]
 801cf30:	2b00      	cmp	r3, #0
 801cf32:	d105      	bne.n	801cf40 <_free_r+0x2c>
 801cf34:	6063      	str	r3, [r4, #4]
 801cf36:	6014      	str	r4, [r2, #0]
 801cf38:	0028      	movs	r0, r5
 801cf3a:	f000 f9e5 	bl	801d308 <__malloc_unlock>
 801cf3e:	bd70      	pop	{r4, r5, r6, pc}
 801cf40:	42a3      	cmp	r3, r4
 801cf42:	d908      	bls.n	801cf56 <_free_r+0x42>
 801cf44:	6821      	ldr	r1, [r4, #0]
 801cf46:	1860      	adds	r0, r4, r1
 801cf48:	4283      	cmp	r3, r0
 801cf4a:	d1f3      	bne.n	801cf34 <_free_r+0x20>
 801cf4c:	6818      	ldr	r0, [r3, #0]
 801cf4e:	685b      	ldr	r3, [r3, #4]
 801cf50:	1841      	adds	r1, r0, r1
 801cf52:	6021      	str	r1, [r4, #0]
 801cf54:	e7ee      	b.n	801cf34 <_free_r+0x20>
 801cf56:	001a      	movs	r2, r3
 801cf58:	685b      	ldr	r3, [r3, #4]
 801cf5a:	2b00      	cmp	r3, #0
 801cf5c:	d001      	beq.n	801cf62 <_free_r+0x4e>
 801cf5e:	42a3      	cmp	r3, r4
 801cf60:	d9f9      	bls.n	801cf56 <_free_r+0x42>
 801cf62:	6811      	ldr	r1, [r2, #0]
 801cf64:	1850      	adds	r0, r2, r1
 801cf66:	42a0      	cmp	r0, r4
 801cf68:	d10b      	bne.n	801cf82 <_free_r+0x6e>
 801cf6a:	6820      	ldr	r0, [r4, #0]
 801cf6c:	1809      	adds	r1, r1, r0
 801cf6e:	1850      	adds	r0, r2, r1
 801cf70:	6011      	str	r1, [r2, #0]
 801cf72:	4283      	cmp	r3, r0
 801cf74:	d1e0      	bne.n	801cf38 <_free_r+0x24>
 801cf76:	6818      	ldr	r0, [r3, #0]
 801cf78:	685b      	ldr	r3, [r3, #4]
 801cf7a:	1841      	adds	r1, r0, r1
 801cf7c:	6011      	str	r1, [r2, #0]
 801cf7e:	6053      	str	r3, [r2, #4]
 801cf80:	e7da      	b.n	801cf38 <_free_r+0x24>
 801cf82:	42a0      	cmp	r0, r4
 801cf84:	d902      	bls.n	801cf8c <_free_r+0x78>
 801cf86:	230c      	movs	r3, #12
 801cf88:	602b      	str	r3, [r5, #0]
 801cf8a:	e7d5      	b.n	801cf38 <_free_r+0x24>
 801cf8c:	6821      	ldr	r1, [r4, #0]
 801cf8e:	1860      	adds	r0, r4, r1
 801cf90:	4283      	cmp	r3, r0
 801cf92:	d103      	bne.n	801cf9c <_free_r+0x88>
 801cf94:	6818      	ldr	r0, [r3, #0]
 801cf96:	685b      	ldr	r3, [r3, #4]
 801cf98:	1841      	adds	r1, r0, r1
 801cf9a:	6021      	str	r1, [r4, #0]
 801cf9c:	6063      	str	r3, [r4, #4]
 801cf9e:	6054      	str	r4, [r2, #4]
 801cfa0:	e7ca      	b.n	801cf38 <_free_r+0x24>
 801cfa2:	46c0      	nop			; (mov r8, r8)
 801cfa4:	200017f8 	.word	0x200017f8

0801cfa8 <_malloc_r>:
 801cfa8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801cfaa:	2303      	movs	r3, #3
 801cfac:	1ccd      	adds	r5, r1, #3
 801cfae:	439d      	bics	r5, r3
 801cfb0:	3508      	adds	r5, #8
 801cfb2:	0006      	movs	r6, r0
 801cfb4:	2d0c      	cmp	r5, #12
 801cfb6:	d21f      	bcs.n	801cff8 <_malloc_r+0x50>
 801cfb8:	250c      	movs	r5, #12
 801cfba:	42a9      	cmp	r1, r5
 801cfbc:	d81e      	bhi.n	801cffc <_malloc_r+0x54>
 801cfbe:	0030      	movs	r0, r6
 801cfc0:	f000 f99a 	bl	801d2f8 <__malloc_lock>
 801cfc4:	4925      	ldr	r1, [pc, #148]	; (801d05c <_malloc_r+0xb4>)
 801cfc6:	680a      	ldr	r2, [r1, #0]
 801cfc8:	0014      	movs	r4, r2
 801cfca:	2c00      	cmp	r4, #0
 801cfcc:	d11a      	bne.n	801d004 <_malloc_r+0x5c>
 801cfce:	4f24      	ldr	r7, [pc, #144]	; (801d060 <_malloc_r+0xb8>)
 801cfd0:	683b      	ldr	r3, [r7, #0]
 801cfd2:	2b00      	cmp	r3, #0
 801cfd4:	d104      	bne.n	801cfe0 <_malloc_r+0x38>
 801cfd6:	0021      	movs	r1, r4
 801cfd8:	0030      	movs	r0, r6
 801cfda:	f000 f843 	bl	801d064 <_sbrk_r>
 801cfde:	6038      	str	r0, [r7, #0]
 801cfe0:	0029      	movs	r1, r5
 801cfe2:	0030      	movs	r0, r6
 801cfe4:	f000 f83e 	bl	801d064 <_sbrk_r>
 801cfe8:	1c43      	adds	r3, r0, #1
 801cfea:	d12b      	bne.n	801d044 <_malloc_r+0x9c>
 801cfec:	230c      	movs	r3, #12
 801cfee:	0030      	movs	r0, r6
 801cff0:	6033      	str	r3, [r6, #0]
 801cff2:	f000 f989 	bl	801d308 <__malloc_unlock>
 801cff6:	e003      	b.n	801d000 <_malloc_r+0x58>
 801cff8:	2d00      	cmp	r5, #0
 801cffa:	dade      	bge.n	801cfba <_malloc_r+0x12>
 801cffc:	230c      	movs	r3, #12
 801cffe:	6033      	str	r3, [r6, #0]
 801d000:	2000      	movs	r0, #0
 801d002:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801d004:	6823      	ldr	r3, [r4, #0]
 801d006:	1b5b      	subs	r3, r3, r5
 801d008:	d419      	bmi.n	801d03e <_malloc_r+0x96>
 801d00a:	2b0b      	cmp	r3, #11
 801d00c:	d903      	bls.n	801d016 <_malloc_r+0x6e>
 801d00e:	6023      	str	r3, [r4, #0]
 801d010:	18e4      	adds	r4, r4, r3
 801d012:	6025      	str	r5, [r4, #0]
 801d014:	e003      	b.n	801d01e <_malloc_r+0x76>
 801d016:	6863      	ldr	r3, [r4, #4]
 801d018:	42a2      	cmp	r2, r4
 801d01a:	d10e      	bne.n	801d03a <_malloc_r+0x92>
 801d01c:	600b      	str	r3, [r1, #0]
 801d01e:	0030      	movs	r0, r6
 801d020:	f000 f972 	bl	801d308 <__malloc_unlock>
 801d024:	0020      	movs	r0, r4
 801d026:	2207      	movs	r2, #7
 801d028:	300b      	adds	r0, #11
 801d02a:	1d23      	adds	r3, r4, #4
 801d02c:	4390      	bics	r0, r2
 801d02e:	1ac2      	subs	r2, r0, r3
 801d030:	4298      	cmp	r0, r3
 801d032:	d0e6      	beq.n	801d002 <_malloc_r+0x5a>
 801d034:	1a1b      	subs	r3, r3, r0
 801d036:	50a3      	str	r3, [r4, r2]
 801d038:	e7e3      	b.n	801d002 <_malloc_r+0x5a>
 801d03a:	6053      	str	r3, [r2, #4]
 801d03c:	e7ef      	b.n	801d01e <_malloc_r+0x76>
 801d03e:	0022      	movs	r2, r4
 801d040:	6864      	ldr	r4, [r4, #4]
 801d042:	e7c2      	b.n	801cfca <_malloc_r+0x22>
 801d044:	2303      	movs	r3, #3
 801d046:	1cc4      	adds	r4, r0, #3
 801d048:	439c      	bics	r4, r3
 801d04a:	42a0      	cmp	r0, r4
 801d04c:	d0e1      	beq.n	801d012 <_malloc_r+0x6a>
 801d04e:	1a21      	subs	r1, r4, r0
 801d050:	0030      	movs	r0, r6
 801d052:	f000 f807 	bl	801d064 <_sbrk_r>
 801d056:	1c43      	adds	r3, r0, #1
 801d058:	d1db      	bne.n	801d012 <_malloc_r+0x6a>
 801d05a:	e7c7      	b.n	801cfec <_malloc_r+0x44>
 801d05c:	200017f8 	.word	0x200017f8
 801d060:	200017fc 	.word	0x200017fc

0801d064 <_sbrk_r>:
 801d064:	2300      	movs	r3, #0
 801d066:	b570      	push	{r4, r5, r6, lr}
 801d068:	4d06      	ldr	r5, [pc, #24]	; (801d084 <_sbrk_r+0x20>)
 801d06a:	0004      	movs	r4, r0
 801d06c:	0008      	movs	r0, r1
 801d06e:	602b      	str	r3, [r5, #0]
 801d070:	f7e3 fbda 	bl	8000828 <_sbrk>
 801d074:	1c43      	adds	r3, r0, #1
 801d076:	d103      	bne.n	801d080 <_sbrk_r+0x1c>
 801d078:	682b      	ldr	r3, [r5, #0]
 801d07a:	2b00      	cmp	r3, #0
 801d07c:	d000      	beq.n	801d080 <_sbrk_r+0x1c>
 801d07e:	6023      	str	r3, [r4, #0]
 801d080:	bd70      	pop	{r4, r5, r6, pc}
 801d082:	46c0      	nop			; (mov r8, r8)
 801d084:	20003e24 	.word	0x20003e24

0801d088 <sniprintf>:
 801d088:	b40c      	push	{r2, r3}
 801d08a:	b530      	push	{r4, r5, lr}
 801d08c:	4b17      	ldr	r3, [pc, #92]	; (801d0ec <sniprintf+0x64>)
 801d08e:	000c      	movs	r4, r1
 801d090:	681d      	ldr	r5, [r3, #0]
 801d092:	b09d      	sub	sp, #116	; 0x74
 801d094:	2900      	cmp	r1, #0
 801d096:	da08      	bge.n	801d0aa <sniprintf+0x22>
 801d098:	238b      	movs	r3, #139	; 0x8b
 801d09a:	2001      	movs	r0, #1
 801d09c:	602b      	str	r3, [r5, #0]
 801d09e:	4240      	negs	r0, r0
 801d0a0:	b01d      	add	sp, #116	; 0x74
 801d0a2:	bc30      	pop	{r4, r5}
 801d0a4:	bc08      	pop	{r3}
 801d0a6:	b002      	add	sp, #8
 801d0a8:	4718      	bx	r3
 801d0aa:	2382      	movs	r3, #130	; 0x82
 801d0ac:	466a      	mov	r2, sp
 801d0ae:	009b      	lsls	r3, r3, #2
 801d0b0:	8293      	strh	r3, [r2, #20]
 801d0b2:	2300      	movs	r3, #0
 801d0b4:	9002      	str	r0, [sp, #8]
 801d0b6:	9006      	str	r0, [sp, #24]
 801d0b8:	4299      	cmp	r1, r3
 801d0ba:	d000      	beq.n	801d0be <sniprintf+0x36>
 801d0bc:	1e4b      	subs	r3, r1, #1
 801d0be:	9304      	str	r3, [sp, #16]
 801d0c0:	9307      	str	r3, [sp, #28]
 801d0c2:	2301      	movs	r3, #1
 801d0c4:	466a      	mov	r2, sp
 801d0c6:	425b      	negs	r3, r3
 801d0c8:	82d3      	strh	r3, [r2, #22]
 801d0ca:	0028      	movs	r0, r5
 801d0cc:	ab21      	add	r3, sp, #132	; 0x84
 801d0ce:	9a20      	ldr	r2, [sp, #128]	; 0x80
 801d0d0:	a902      	add	r1, sp, #8
 801d0d2:	9301      	str	r3, [sp, #4]
 801d0d4:	f000 f982 	bl	801d3dc <_svfiprintf_r>
 801d0d8:	1c43      	adds	r3, r0, #1
 801d0da:	da01      	bge.n	801d0e0 <sniprintf+0x58>
 801d0dc:	238b      	movs	r3, #139	; 0x8b
 801d0de:	602b      	str	r3, [r5, #0]
 801d0e0:	2c00      	cmp	r4, #0
 801d0e2:	d0dd      	beq.n	801d0a0 <sniprintf+0x18>
 801d0e4:	2300      	movs	r3, #0
 801d0e6:	9a02      	ldr	r2, [sp, #8]
 801d0e8:	7013      	strb	r3, [r2, #0]
 801d0ea:	e7d9      	b.n	801d0a0 <sniprintf+0x18>
 801d0ec:	20000038 	.word	0x20000038

0801d0f0 <strncpy>:
 801d0f0:	0003      	movs	r3, r0
 801d0f2:	b530      	push	{r4, r5, lr}
 801d0f4:	001d      	movs	r5, r3
 801d0f6:	2a00      	cmp	r2, #0
 801d0f8:	d006      	beq.n	801d108 <strncpy+0x18>
 801d0fa:	780c      	ldrb	r4, [r1, #0]
 801d0fc:	3a01      	subs	r2, #1
 801d0fe:	3301      	adds	r3, #1
 801d100:	702c      	strb	r4, [r5, #0]
 801d102:	3101      	adds	r1, #1
 801d104:	2c00      	cmp	r4, #0
 801d106:	d1f5      	bne.n	801d0f4 <strncpy+0x4>
 801d108:	2100      	movs	r1, #0
 801d10a:	189a      	adds	r2, r3, r2
 801d10c:	4293      	cmp	r3, r2
 801d10e:	d100      	bne.n	801d112 <strncpy+0x22>
 801d110:	bd30      	pop	{r4, r5, pc}
 801d112:	7019      	strb	r1, [r3, #0]
 801d114:	3301      	adds	r3, #1
 801d116:	e7f9      	b.n	801d10c <strncpy+0x1c>

0801d118 <strstr>:
 801d118:	780a      	ldrb	r2, [r1, #0]
 801d11a:	b530      	push	{r4, r5, lr}
 801d11c:	2a00      	cmp	r2, #0
 801d11e:	d10c      	bne.n	801d13a <strstr+0x22>
 801d120:	bd30      	pop	{r4, r5, pc}
 801d122:	429a      	cmp	r2, r3
 801d124:	d108      	bne.n	801d138 <strstr+0x20>
 801d126:	2301      	movs	r3, #1
 801d128:	5ccc      	ldrb	r4, [r1, r3]
 801d12a:	2c00      	cmp	r4, #0
 801d12c:	d0f8      	beq.n	801d120 <strstr+0x8>
 801d12e:	5cc5      	ldrb	r5, [r0, r3]
 801d130:	42a5      	cmp	r5, r4
 801d132:	d101      	bne.n	801d138 <strstr+0x20>
 801d134:	3301      	adds	r3, #1
 801d136:	e7f7      	b.n	801d128 <strstr+0x10>
 801d138:	3001      	adds	r0, #1
 801d13a:	7803      	ldrb	r3, [r0, #0]
 801d13c:	2b00      	cmp	r3, #0
 801d13e:	d1f0      	bne.n	801d122 <strstr+0xa>
 801d140:	0018      	movs	r0, r3
 801d142:	e7ed      	b.n	801d120 <strstr+0x8>

0801d144 <_strtol_l.isra.0>:
 801d144:	b5f0      	push	{r4, r5, r6, r7, lr}
 801d146:	b087      	sub	sp, #28
 801d148:	001e      	movs	r6, r3
 801d14a:	9005      	str	r0, [sp, #20]
 801d14c:	9101      	str	r1, [sp, #4]
 801d14e:	9202      	str	r2, [sp, #8]
 801d150:	2b01      	cmp	r3, #1
 801d152:	d045      	beq.n	801d1e0 <_strtol_l.isra.0+0x9c>
 801d154:	0008      	movs	r0, r1
 801d156:	2b24      	cmp	r3, #36	; 0x24
 801d158:	d842      	bhi.n	801d1e0 <_strtol_l.isra.0+0x9c>
 801d15a:	4b3f      	ldr	r3, [pc, #252]	; (801d258 <_strtol_l.isra.0+0x114>)
 801d15c:	2208      	movs	r2, #8
 801d15e:	469c      	mov	ip, r3
 801d160:	0003      	movs	r3, r0
 801d162:	4661      	mov	r1, ip
 801d164:	781c      	ldrb	r4, [r3, #0]
 801d166:	1c45      	adds	r5, r0, #1
 801d168:	5d09      	ldrb	r1, [r1, r4]
 801d16a:	0028      	movs	r0, r5
 801d16c:	000f      	movs	r7, r1
 801d16e:	4017      	ands	r7, r2
 801d170:	4211      	tst	r1, r2
 801d172:	d1f5      	bne.n	801d160 <_strtol_l.isra.0+0x1c>
 801d174:	2c2d      	cmp	r4, #45	; 0x2d
 801d176:	d13a      	bne.n	801d1ee <_strtol_l.isra.0+0xaa>
 801d178:	2701      	movs	r7, #1
 801d17a:	782c      	ldrb	r4, [r5, #0]
 801d17c:	1c9d      	adds	r5, r3, #2
 801d17e:	2e00      	cmp	r6, #0
 801d180:	d065      	beq.n	801d24e <_strtol_l.isra.0+0x10a>
 801d182:	2e10      	cmp	r6, #16
 801d184:	d109      	bne.n	801d19a <_strtol_l.isra.0+0x56>
 801d186:	2c30      	cmp	r4, #48	; 0x30
 801d188:	d107      	bne.n	801d19a <_strtol_l.isra.0+0x56>
 801d18a:	2220      	movs	r2, #32
 801d18c:	782b      	ldrb	r3, [r5, #0]
 801d18e:	4393      	bics	r3, r2
 801d190:	2b58      	cmp	r3, #88	; 0x58
 801d192:	d157      	bne.n	801d244 <_strtol_l.isra.0+0x100>
 801d194:	2610      	movs	r6, #16
 801d196:	786c      	ldrb	r4, [r5, #1]
 801d198:	3502      	adds	r5, #2
 801d19a:	4b30      	ldr	r3, [pc, #192]	; (801d25c <_strtol_l.isra.0+0x118>)
 801d19c:	0031      	movs	r1, r6
 801d19e:	18fb      	adds	r3, r7, r3
 801d1a0:	0018      	movs	r0, r3
 801d1a2:	9303      	str	r3, [sp, #12]
 801d1a4:	f7e3 f848 	bl	8000238 <__aeabi_uidivmod>
 801d1a8:	2300      	movs	r3, #0
 801d1aa:	2201      	movs	r2, #1
 801d1ac:	4684      	mov	ip, r0
 801d1ae:	0018      	movs	r0, r3
 801d1b0:	9104      	str	r1, [sp, #16]
 801d1b2:	4252      	negs	r2, r2
 801d1b4:	0021      	movs	r1, r4
 801d1b6:	3930      	subs	r1, #48	; 0x30
 801d1b8:	2909      	cmp	r1, #9
 801d1ba:	d81d      	bhi.n	801d1f8 <_strtol_l.isra.0+0xb4>
 801d1bc:	000c      	movs	r4, r1
 801d1be:	42a6      	cmp	r6, r4
 801d1c0:	dd28      	ble.n	801d214 <_strtol_l.isra.0+0xd0>
 801d1c2:	2b00      	cmp	r3, #0
 801d1c4:	db24      	blt.n	801d210 <_strtol_l.isra.0+0xcc>
 801d1c6:	0013      	movs	r3, r2
 801d1c8:	4584      	cmp	ip, r0
 801d1ca:	d306      	bcc.n	801d1da <_strtol_l.isra.0+0x96>
 801d1cc:	d102      	bne.n	801d1d4 <_strtol_l.isra.0+0x90>
 801d1ce:	9904      	ldr	r1, [sp, #16]
 801d1d0:	42a1      	cmp	r1, r4
 801d1d2:	db02      	blt.n	801d1da <_strtol_l.isra.0+0x96>
 801d1d4:	2301      	movs	r3, #1
 801d1d6:	4370      	muls	r0, r6
 801d1d8:	1820      	adds	r0, r4, r0
 801d1da:	782c      	ldrb	r4, [r5, #0]
 801d1dc:	3501      	adds	r5, #1
 801d1de:	e7e9      	b.n	801d1b4 <_strtol_l.isra.0+0x70>
 801d1e0:	f000 f882 	bl	801d2e8 <__errno>
 801d1e4:	2316      	movs	r3, #22
 801d1e6:	6003      	str	r3, [r0, #0]
 801d1e8:	2000      	movs	r0, #0
 801d1ea:	b007      	add	sp, #28
 801d1ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801d1ee:	2c2b      	cmp	r4, #43	; 0x2b
 801d1f0:	d1c5      	bne.n	801d17e <_strtol_l.isra.0+0x3a>
 801d1f2:	782c      	ldrb	r4, [r5, #0]
 801d1f4:	1c9d      	adds	r5, r3, #2
 801d1f6:	e7c2      	b.n	801d17e <_strtol_l.isra.0+0x3a>
 801d1f8:	0021      	movs	r1, r4
 801d1fa:	3941      	subs	r1, #65	; 0x41
 801d1fc:	2919      	cmp	r1, #25
 801d1fe:	d801      	bhi.n	801d204 <_strtol_l.isra.0+0xc0>
 801d200:	3c37      	subs	r4, #55	; 0x37
 801d202:	e7dc      	b.n	801d1be <_strtol_l.isra.0+0x7a>
 801d204:	0021      	movs	r1, r4
 801d206:	3961      	subs	r1, #97	; 0x61
 801d208:	2919      	cmp	r1, #25
 801d20a:	d803      	bhi.n	801d214 <_strtol_l.isra.0+0xd0>
 801d20c:	3c57      	subs	r4, #87	; 0x57
 801d20e:	e7d6      	b.n	801d1be <_strtol_l.isra.0+0x7a>
 801d210:	0013      	movs	r3, r2
 801d212:	e7e2      	b.n	801d1da <_strtol_l.isra.0+0x96>
 801d214:	2b00      	cmp	r3, #0
 801d216:	da09      	bge.n	801d22c <_strtol_l.isra.0+0xe8>
 801d218:	2322      	movs	r3, #34	; 0x22
 801d21a:	9a05      	ldr	r2, [sp, #20]
 801d21c:	9803      	ldr	r0, [sp, #12]
 801d21e:	6013      	str	r3, [r2, #0]
 801d220:	9b02      	ldr	r3, [sp, #8]
 801d222:	2b00      	cmp	r3, #0
 801d224:	d0e1      	beq.n	801d1ea <_strtol_l.isra.0+0xa6>
 801d226:	1e6b      	subs	r3, r5, #1
 801d228:	9301      	str	r3, [sp, #4]
 801d22a:	e007      	b.n	801d23c <_strtol_l.isra.0+0xf8>
 801d22c:	2f00      	cmp	r7, #0
 801d22e:	d000      	beq.n	801d232 <_strtol_l.isra.0+0xee>
 801d230:	4240      	negs	r0, r0
 801d232:	9a02      	ldr	r2, [sp, #8]
 801d234:	2a00      	cmp	r2, #0
 801d236:	d0d8      	beq.n	801d1ea <_strtol_l.isra.0+0xa6>
 801d238:	2b00      	cmp	r3, #0
 801d23a:	d1f4      	bne.n	801d226 <_strtol_l.isra.0+0xe2>
 801d23c:	9b02      	ldr	r3, [sp, #8]
 801d23e:	9a01      	ldr	r2, [sp, #4]
 801d240:	601a      	str	r2, [r3, #0]
 801d242:	e7d2      	b.n	801d1ea <_strtol_l.isra.0+0xa6>
 801d244:	2430      	movs	r4, #48	; 0x30
 801d246:	2e00      	cmp	r6, #0
 801d248:	d1a7      	bne.n	801d19a <_strtol_l.isra.0+0x56>
 801d24a:	3608      	adds	r6, #8
 801d24c:	e7a5      	b.n	801d19a <_strtol_l.isra.0+0x56>
 801d24e:	2c30      	cmp	r4, #48	; 0x30
 801d250:	d09b      	beq.n	801d18a <_strtol_l.isra.0+0x46>
 801d252:	260a      	movs	r6, #10
 801d254:	e7a1      	b.n	801d19a <_strtol_l.isra.0+0x56>
 801d256:	46c0      	nop			; (mov r8, r8)
 801d258:	08022e65 	.word	0x08022e65
 801d25c:	7fffffff 	.word	0x7fffffff

0801d260 <strtol>:
 801d260:	b510      	push	{r4, lr}
 801d262:	0013      	movs	r3, r2
 801d264:	000a      	movs	r2, r1
 801d266:	0001      	movs	r1, r0
 801d268:	4802      	ldr	r0, [pc, #8]	; (801d274 <strtol+0x14>)
 801d26a:	6800      	ldr	r0, [r0, #0]
 801d26c:	f7ff ff6a 	bl	801d144 <_strtol_l.isra.0>
 801d270:	bd10      	pop	{r4, pc}
 801d272:	46c0      	nop			; (mov r8, r8)
 801d274:	20000038 	.word	0x20000038

0801d278 <_vsniprintf_r>:
 801d278:	b530      	push	{r4, r5, lr}
 801d27a:	0014      	movs	r4, r2
 801d27c:	0005      	movs	r5, r0
 801d27e:	001a      	movs	r2, r3
 801d280:	b09b      	sub	sp, #108	; 0x6c
 801d282:	2c00      	cmp	r4, #0
 801d284:	da05      	bge.n	801d292 <_vsniprintf_r+0x1a>
 801d286:	238b      	movs	r3, #139	; 0x8b
 801d288:	6003      	str	r3, [r0, #0]
 801d28a:	2001      	movs	r0, #1
 801d28c:	4240      	negs	r0, r0
 801d28e:	b01b      	add	sp, #108	; 0x6c
 801d290:	bd30      	pop	{r4, r5, pc}
 801d292:	2382      	movs	r3, #130	; 0x82
 801d294:	4668      	mov	r0, sp
 801d296:	009b      	lsls	r3, r3, #2
 801d298:	8183      	strh	r3, [r0, #12]
 801d29a:	2300      	movs	r3, #0
 801d29c:	9100      	str	r1, [sp, #0]
 801d29e:	9104      	str	r1, [sp, #16]
 801d2a0:	429c      	cmp	r4, r3
 801d2a2:	d000      	beq.n	801d2a6 <_vsniprintf_r+0x2e>
 801d2a4:	1e63      	subs	r3, r4, #1
 801d2a6:	9302      	str	r3, [sp, #8]
 801d2a8:	9305      	str	r3, [sp, #20]
 801d2aa:	2301      	movs	r3, #1
 801d2ac:	4669      	mov	r1, sp
 801d2ae:	425b      	negs	r3, r3
 801d2b0:	81cb      	strh	r3, [r1, #14]
 801d2b2:	0028      	movs	r0, r5
 801d2b4:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 801d2b6:	f000 f891 	bl	801d3dc <_svfiprintf_r>
 801d2ba:	1c43      	adds	r3, r0, #1
 801d2bc:	da01      	bge.n	801d2c2 <_vsniprintf_r+0x4a>
 801d2be:	238b      	movs	r3, #139	; 0x8b
 801d2c0:	602b      	str	r3, [r5, #0]
 801d2c2:	2c00      	cmp	r4, #0
 801d2c4:	d0e3      	beq.n	801d28e <_vsniprintf_r+0x16>
 801d2c6:	2300      	movs	r3, #0
 801d2c8:	9a00      	ldr	r2, [sp, #0]
 801d2ca:	7013      	strb	r3, [r2, #0]
 801d2cc:	e7df      	b.n	801d28e <_vsniprintf_r+0x16>
	...

0801d2d0 <vsniprintf>:
 801d2d0:	b507      	push	{r0, r1, r2, lr}
 801d2d2:	9300      	str	r3, [sp, #0]
 801d2d4:	0013      	movs	r3, r2
 801d2d6:	000a      	movs	r2, r1
 801d2d8:	0001      	movs	r1, r0
 801d2da:	4802      	ldr	r0, [pc, #8]	; (801d2e4 <vsniprintf+0x14>)
 801d2dc:	6800      	ldr	r0, [r0, #0]
 801d2de:	f7ff ffcb 	bl	801d278 <_vsniprintf_r>
 801d2e2:	bd0e      	pop	{r1, r2, r3, pc}
 801d2e4:	20000038 	.word	0x20000038

0801d2e8 <__errno>:
 801d2e8:	4b01      	ldr	r3, [pc, #4]	; (801d2f0 <__errno+0x8>)
 801d2ea:	6818      	ldr	r0, [r3, #0]
 801d2ec:	4770      	bx	lr
 801d2ee:	46c0      	nop			; (mov r8, r8)
 801d2f0:	20000038 	.word	0x20000038

0801d2f4 <__retarget_lock_acquire_recursive>:
 801d2f4:	4770      	bx	lr

0801d2f6 <__retarget_lock_release_recursive>:
 801d2f6:	4770      	bx	lr

0801d2f8 <__malloc_lock>:
 801d2f8:	b510      	push	{r4, lr}
 801d2fa:	4802      	ldr	r0, [pc, #8]	; (801d304 <__malloc_lock+0xc>)
 801d2fc:	f7ff fffa 	bl	801d2f4 <__retarget_lock_acquire_recursive>
 801d300:	bd10      	pop	{r4, pc}
 801d302:	46c0      	nop			; (mov r8, r8)
 801d304:	20003e2c 	.word	0x20003e2c

0801d308 <__malloc_unlock>:
 801d308:	b510      	push	{r4, lr}
 801d30a:	4802      	ldr	r0, [pc, #8]	; (801d314 <__malloc_unlock+0xc>)
 801d30c:	f7ff fff3 	bl	801d2f6 <__retarget_lock_release_recursive>
 801d310:	bd10      	pop	{r4, pc}
 801d312:	46c0      	nop			; (mov r8, r8)
 801d314:	20003e2c 	.word	0x20003e2c

0801d318 <__ssputs_r>:
 801d318:	b5f0      	push	{r4, r5, r6, r7, lr}
 801d31a:	688e      	ldr	r6, [r1, #8]
 801d31c:	b085      	sub	sp, #20
 801d31e:	0007      	movs	r7, r0
 801d320:	000c      	movs	r4, r1
 801d322:	9203      	str	r2, [sp, #12]
 801d324:	9301      	str	r3, [sp, #4]
 801d326:	429e      	cmp	r6, r3
 801d328:	d83c      	bhi.n	801d3a4 <__ssputs_r+0x8c>
 801d32a:	2390      	movs	r3, #144	; 0x90
 801d32c:	898a      	ldrh	r2, [r1, #12]
 801d32e:	00db      	lsls	r3, r3, #3
 801d330:	421a      	tst	r2, r3
 801d332:	d034      	beq.n	801d39e <__ssputs_r+0x86>
 801d334:	2503      	movs	r5, #3
 801d336:	6909      	ldr	r1, [r1, #16]
 801d338:	6823      	ldr	r3, [r4, #0]
 801d33a:	1a5b      	subs	r3, r3, r1
 801d33c:	9302      	str	r3, [sp, #8]
 801d33e:	6963      	ldr	r3, [r4, #20]
 801d340:	9802      	ldr	r0, [sp, #8]
 801d342:	435d      	muls	r5, r3
 801d344:	0feb      	lsrs	r3, r5, #31
 801d346:	195d      	adds	r5, r3, r5
 801d348:	9b01      	ldr	r3, [sp, #4]
 801d34a:	106d      	asrs	r5, r5, #1
 801d34c:	3301      	adds	r3, #1
 801d34e:	181b      	adds	r3, r3, r0
 801d350:	42ab      	cmp	r3, r5
 801d352:	d900      	bls.n	801d356 <__ssputs_r+0x3e>
 801d354:	001d      	movs	r5, r3
 801d356:	0553      	lsls	r3, r2, #21
 801d358:	d532      	bpl.n	801d3c0 <__ssputs_r+0xa8>
 801d35a:	0029      	movs	r1, r5
 801d35c:	0038      	movs	r0, r7
 801d35e:	f7ff fe23 	bl	801cfa8 <_malloc_r>
 801d362:	1e06      	subs	r6, r0, #0
 801d364:	d109      	bne.n	801d37a <__ssputs_r+0x62>
 801d366:	230c      	movs	r3, #12
 801d368:	603b      	str	r3, [r7, #0]
 801d36a:	2340      	movs	r3, #64	; 0x40
 801d36c:	2001      	movs	r0, #1
 801d36e:	89a2      	ldrh	r2, [r4, #12]
 801d370:	4240      	negs	r0, r0
 801d372:	4313      	orrs	r3, r2
 801d374:	81a3      	strh	r3, [r4, #12]
 801d376:	b005      	add	sp, #20
 801d378:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801d37a:	9a02      	ldr	r2, [sp, #8]
 801d37c:	6921      	ldr	r1, [r4, #16]
 801d37e:	f7ff fda5 	bl	801cecc <memcpy>
 801d382:	89a3      	ldrh	r3, [r4, #12]
 801d384:	4a14      	ldr	r2, [pc, #80]	; (801d3d8 <__ssputs_r+0xc0>)
 801d386:	401a      	ands	r2, r3
 801d388:	2380      	movs	r3, #128	; 0x80
 801d38a:	4313      	orrs	r3, r2
 801d38c:	81a3      	strh	r3, [r4, #12]
 801d38e:	9b02      	ldr	r3, [sp, #8]
 801d390:	6126      	str	r6, [r4, #16]
 801d392:	18f6      	adds	r6, r6, r3
 801d394:	6026      	str	r6, [r4, #0]
 801d396:	6165      	str	r5, [r4, #20]
 801d398:	9e01      	ldr	r6, [sp, #4]
 801d39a:	1aed      	subs	r5, r5, r3
 801d39c:	60a5      	str	r5, [r4, #8]
 801d39e:	9b01      	ldr	r3, [sp, #4]
 801d3a0:	429e      	cmp	r6, r3
 801d3a2:	d900      	bls.n	801d3a6 <__ssputs_r+0x8e>
 801d3a4:	9e01      	ldr	r6, [sp, #4]
 801d3a6:	0032      	movs	r2, r6
 801d3a8:	9903      	ldr	r1, [sp, #12]
 801d3aa:	6820      	ldr	r0, [r4, #0]
 801d3ac:	f7ff fd97 	bl	801cede <memmove>
 801d3b0:	68a3      	ldr	r3, [r4, #8]
 801d3b2:	2000      	movs	r0, #0
 801d3b4:	1b9b      	subs	r3, r3, r6
 801d3b6:	60a3      	str	r3, [r4, #8]
 801d3b8:	6823      	ldr	r3, [r4, #0]
 801d3ba:	199e      	adds	r6, r3, r6
 801d3bc:	6026      	str	r6, [r4, #0]
 801d3be:	e7da      	b.n	801d376 <__ssputs_r+0x5e>
 801d3c0:	002a      	movs	r2, r5
 801d3c2:	0038      	movs	r0, r7
 801d3c4:	f000 fa97 	bl	801d8f6 <_realloc_r>
 801d3c8:	1e06      	subs	r6, r0, #0
 801d3ca:	d1e0      	bne.n	801d38e <__ssputs_r+0x76>
 801d3cc:	0038      	movs	r0, r7
 801d3ce:	6921      	ldr	r1, [r4, #16]
 801d3d0:	f7ff fda0 	bl	801cf14 <_free_r>
 801d3d4:	e7c7      	b.n	801d366 <__ssputs_r+0x4e>
 801d3d6:	46c0      	nop			; (mov r8, r8)
 801d3d8:	fffffb7f 	.word	0xfffffb7f

0801d3dc <_svfiprintf_r>:
 801d3dc:	b5f0      	push	{r4, r5, r6, r7, lr}
 801d3de:	b0a1      	sub	sp, #132	; 0x84
 801d3e0:	9003      	str	r0, [sp, #12]
 801d3e2:	001d      	movs	r5, r3
 801d3e4:	898b      	ldrh	r3, [r1, #12]
 801d3e6:	000f      	movs	r7, r1
 801d3e8:	0016      	movs	r6, r2
 801d3ea:	061b      	lsls	r3, r3, #24
 801d3ec:	d511      	bpl.n	801d412 <_svfiprintf_r+0x36>
 801d3ee:	690b      	ldr	r3, [r1, #16]
 801d3f0:	2b00      	cmp	r3, #0
 801d3f2:	d10e      	bne.n	801d412 <_svfiprintf_r+0x36>
 801d3f4:	2140      	movs	r1, #64	; 0x40
 801d3f6:	f7ff fdd7 	bl	801cfa8 <_malloc_r>
 801d3fa:	6038      	str	r0, [r7, #0]
 801d3fc:	6138      	str	r0, [r7, #16]
 801d3fe:	2800      	cmp	r0, #0
 801d400:	d105      	bne.n	801d40e <_svfiprintf_r+0x32>
 801d402:	230c      	movs	r3, #12
 801d404:	9a03      	ldr	r2, [sp, #12]
 801d406:	3801      	subs	r0, #1
 801d408:	6013      	str	r3, [r2, #0]
 801d40a:	b021      	add	sp, #132	; 0x84
 801d40c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801d40e:	2340      	movs	r3, #64	; 0x40
 801d410:	617b      	str	r3, [r7, #20]
 801d412:	2300      	movs	r3, #0
 801d414:	ac08      	add	r4, sp, #32
 801d416:	6163      	str	r3, [r4, #20]
 801d418:	3320      	adds	r3, #32
 801d41a:	7663      	strb	r3, [r4, #25]
 801d41c:	3310      	adds	r3, #16
 801d41e:	76a3      	strb	r3, [r4, #26]
 801d420:	9507      	str	r5, [sp, #28]
 801d422:	0035      	movs	r5, r6
 801d424:	782b      	ldrb	r3, [r5, #0]
 801d426:	2b00      	cmp	r3, #0
 801d428:	d001      	beq.n	801d42e <_svfiprintf_r+0x52>
 801d42a:	2b25      	cmp	r3, #37	; 0x25
 801d42c:	d147      	bne.n	801d4be <_svfiprintf_r+0xe2>
 801d42e:	1bab      	subs	r3, r5, r6
 801d430:	9305      	str	r3, [sp, #20]
 801d432:	42b5      	cmp	r5, r6
 801d434:	d00c      	beq.n	801d450 <_svfiprintf_r+0x74>
 801d436:	0032      	movs	r2, r6
 801d438:	0039      	movs	r1, r7
 801d43a:	9803      	ldr	r0, [sp, #12]
 801d43c:	f7ff ff6c 	bl	801d318 <__ssputs_r>
 801d440:	1c43      	adds	r3, r0, #1
 801d442:	d100      	bne.n	801d446 <_svfiprintf_r+0x6a>
 801d444:	e0ae      	b.n	801d5a4 <_svfiprintf_r+0x1c8>
 801d446:	6962      	ldr	r2, [r4, #20]
 801d448:	9b05      	ldr	r3, [sp, #20]
 801d44a:	4694      	mov	ip, r2
 801d44c:	4463      	add	r3, ip
 801d44e:	6163      	str	r3, [r4, #20]
 801d450:	782b      	ldrb	r3, [r5, #0]
 801d452:	2b00      	cmp	r3, #0
 801d454:	d100      	bne.n	801d458 <_svfiprintf_r+0x7c>
 801d456:	e0a5      	b.n	801d5a4 <_svfiprintf_r+0x1c8>
 801d458:	2201      	movs	r2, #1
 801d45a:	2300      	movs	r3, #0
 801d45c:	4252      	negs	r2, r2
 801d45e:	6062      	str	r2, [r4, #4]
 801d460:	a904      	add	r1, sp, #16
 801d462:	3254      	adds	r2, #84	; 0x54
 801d464:	1852      	adds	r2, r2, r1
 801d466:	1c6e      	adds	r6, r5, #1
 801d468:	6023      	str	r3, [r4, #0]
 801d46a:	60e3      	str	r3, [r4, #12]
 801d46c:	60a3      	str	r3, [r4, #8]
 801d46e:	7013      	strb	r3, [r2, #0]
 801d470:	65a3      	str	r3, [r4, #88]	; 0x58
 801d472:	2205      	movs	r2, #5
 801d474:	7831      	ldrb	r1, [r6, #0]
 801d476:	4854      	ldr	r0, [pc, #336]	; (801d5c8 <_svfiprintf_r+0x1ec>)
 801d478:	f000 fa32 	bl	801d8e0 <memchr>
 801d47c:	1c75      	adds	r5, r6, #1
 801d47e:	2800      	cmp	r0, #0
 801d480:	d11f      	bne.n	801d4c2 <_svfiprintf_r+0xe6>
 801d482:	6822      	ldr	r2, [r4, #0]
 801d484:	06d3      	lsls	r3, r2, #27
 801d486:	d504      	bpl.n	801d492 <_svfiprintf_r+0xb6>
 801d488:	2353      	movs	r3, #83	; 0x53
 801d48a:	a904      	add	r1, sp, #16
 801d48c:	185b      	adds	r3, r3, r1
 801d48e:	2120      	movs	r1, #32
 801d490:	7019      	strb	r1, [r3, #0]
 801d492:	0713      	lsls	r3, r2, #28
 801d494:	d504      	bpl.n	801d4a0 <_svfiprintf_r+0xc4>
 801d496:	2353      	movs	r3, #83	; 0x53
 801d498:	a904      	add	r1, sp, #16
 801d49a:	185b      	adds	r3, r3, r1
 801d49c:	212b      	movs	r1, #43	; 0x2b
 801d49e:	7019      	strb	r1, [r3, #0]
 801d4a0:	7833      	ldrb	r3, [r6, #0]
 801d4a2:	2b2a      	cmp	r3, #42	; 0x2a
 801d4a4:	d016      	beq.n	801d4d4 <_svfiprintf_r+0xf8>
 801d4a6:	0035      	movs	r5, r6
 801d4a8:	2100      	movs	r1, #0
 801d4aa:	200a      	movs	r0, #10
 801d4ac:	68e3      	ldr	r3, [r4, #12]
 801d4ae:	782a      	ldrb	r2, [r5, #0]
 801d4b0:	1c6e      	adds	r6, r5, #1
 801d4b2:	3a30      	subs	r2, #48	; 0x30
 801d4b4:	2a09      	cmp	r2, #9
 801d4b6:	d94e      	bls.n	801d556 <_svfiprintf_r+0x17a>
 801d4b8:	2900      	cmp	r1, #0
 801d4ba:	d111      	bne.n	801d4e0 <_svfiprintf_r+0x104>
 801d4bc:	e017      	b.n	801d4ee <_svfiprintf_r+0x112>
 801d4be:	3501      	adds	r5, #1
 801d4c0:	e7b0      	b.n	801d424 <_svfiprintf_r+0x48>
 801d4c2:	4b41      	ldr	r3, [pc, #260]	; (801d5c8 <_svfiprintf_r+0x1ec>)
 801d4c4:	6822      	ldr	r2, [r4, #0]
 801d4c6:	1ac0      	subs	r0, r0, r3
 801d4c8:	2301      	movs	r3, #1
 801d4ca:	4083      	lsls	r3, r0
 801d4cc:	4313      	orrs	r3, r2
 801d4ce:	002e      	movs	r6, r5
 801d4d0:	6023      	str	r3, [r4, #0]
 801d4d2:	e7ce      	b.n	801d472 <_svfiprintf_r+0x96>
 801d4d4:	9b07      	ldr	r3, [sp, #28]
 801d4d6:	1d19      	adds	r1, r3, #4
 801d4d8:	681b      	ldr	r3, [r3, #0]
 801d4da:	9107      	str	r1, [sp, #28]
 801d4dc:	2b00      	cmp	r3, #0
 801d4de:	db01      	blt.n	801d4e4 <_svfiprintf_r+0x108>
 801d4e0:	930b      	str	r3, [sp, #44]	; 0x2c
 801d4e2:	e004      	b.n	801d4ee <_svfiprintf_r+0x112>
 801d4e4:	425b      	negs	r3, r3
 801d4e6:	60e3      	str	r3, [r4, #12]
 801d4e8:	2302      	movs	r3, #2
 801d4ea:	4313      	orrs	r3, r2
 801d4ec:	6023      	str	r3, [r4, #0]
 801d4ee:	782b      	ldrb	r3, [r5, #0]
 801d4f0:	2b2e      	cmp	r3, #46	; 0x2e
 801d4f2:	d10a      	bne.n	801d50a <_svfiprintf_r+0x12e>
 801d4f4:	786b      	ldrb	r3, [r5, #1]
 801d4f6:	2b2a      	cmp	r3, #42	; 0x2a
 801d4f8:	d135      	bne.n	801d566 <_svfiprintf_r+0x18a>
 801d4fa:	9b07      	ldr	r3, [sp, #28]
 801d4fc:	3502      	adds	r5, #2
 801d4fe:	1d1a      	adds	r2, r3, #4
 801d500:	681b      	ldr	r3, [r3, #0]
 801d502:	9207      	str	r2, [sp, #28]
 801d504:	2b00      	cmp	r3, #0
 801d506:	db2b      	blt.n	801d560 <_svfiprintf_r+0x184>
 801d508:	9309      	str	r3, [sp, #36]	; 0x24
 801d50a:	4e30      	ldr	r6, [pc, #192]	; (801d5cc <_svfiprintf_r+0x1f0>)
 801d50c:	2203      	movs	r2, #3
 801d50e:	0030      	movs	r0, r6
 801d510:	7829      	ldrb	r1, [r5, #0]
 801d512:	f000 f9e5 	bl	801d8e0 <memchr>
 801d516:	2800      	cmp	r0, #0
 801d518:	d006      	beq.n	801d528 <_svfiprintf_r+0x14c>
 801d51a:	2340      	movs	r3, #64	; 0x40
 801d51c:	1b80      	subs	r0, r0, r6
 801d51e:	4083      	lsls	r3, r0
 801d520:	6822      	ldr	r2, [r4, #0]
 801d522:	3501      	adds	r5, #1
 801d524:	4313      	orrs	r3, r2
 801d526:	6023      	str	r3, [r4, #0]
 801d528:	7829      	ldrb	r1, [r5, #0]
 801d52a:	2206      	movs	r2, #6
 801d52c:	4828      	ldr	r0, [pc, #160]	; (801d5d0 <_svfiprintf_r+0x1f4>)
 801d52e:	1c6e      	adds	r6, r5, #1
 801d530:	7621      	strb	r1, [r4, #24]
 801d532:	f000 f9d5 	bl	801d8e0 <memchr>
 801d536:	2800      	cmp	r0, #0
 801d538:	d03c      	beq.n	801d5b4 <_svfiprintf_r+0x1d8>
 801d53a:	4b26      	ldr	r3, [pc, #152]	; (801d5d4 <_svfiprintf_r+0x1f8>)
 801d53c:	2b00      	cmp	r3, #0
 801d53e:	d125      	bne.n	801d58c <_svfiprintf_r+0x1b0>
 801d540:	2207      	movs	r2, #7
 801d542:	9b07      	ldr	r3, [sp, #28]
 801d544:	3307      	adds	r3, #7
 801d546:	4393      	bics	r3, r2
 801d548:	3308      	adds	r3, #8
 801d54a:	9307      	str	r3, [sp, #28]
 801d54c:	6963      	ldr	r3, [r4, #20]
 801d54e:	9a04      	ldr	r2, [sp, #16]
 801d550:	189b      	adds	r3, r3, r2
 801d552:	6163      	str	r3, [r4, #20]
 801d554:	e765      	b.n	801d422 <_svfiprintf_r+0x46>
 801d556:	4343      	muls	r3, r0
 801d558:	0035      	movs	r5, r6
 801d55a:	2101      	movs	r1, #1
 801d55c:	189b      	adds	r3, r3, r2
 801d55e:	e7a6      	b.n	801d4ae <_svfiprintf_r+0xd2>
 801d560:	2301      	movs	r3, #1
 801d562:	425b      	negs	r3, r3
 801d564:	e7d0      	b.n	801d508 <_svfiprintf_r+0x12c>
 801d566:	2300      	movs	r3, #0
 801d568:	200a      	movs	r0, #10
 801d56a:	001a      	movs	r2, r3
 801d56c:	3501      	adds	r5, #1
 801d56e:	6063      	str	r3, [r4, #4]
 801d570:	7829      	ldrb	r1, [r5, #0]
 801d572:	1c6e      	adds	r6, r5, #1
 801d574:	3930      	subs	r1, #48	; 0x30
 801d576:	2909      	cmp	r1, #9
 801d578:	d903      	bls.n	801d582 <_svfiprintf_r+0x1a6>
 801d57a:	2b00      	cmp	r3, #0
 801d57c:	d0c5      	beq.n	801d50a <_svfiprintf_r+0x12e>
 801d57e:	9209      	str	r2, [sp, #36]	; 0x24
 801d580:	e7c3      	b.n	801d50a <_svfiprintf_r+0x12e>
 801d582:	4342      	muls	r2, r0
 801d584:	0035      	movs	r5, r6
 801d586:	2301      	movs	r3, #1
 801d588:	1852      	adds	r2, r2, r1
 801d58a:	e7f1      	b.n	801d570 <_svfiprintf_r+0x194>
 801d58c:	ab07      	add	r3, sp, #28
 801d58e:	9300      	str	r3, [sp, #0]
 801d590:	003a      	movs	r2, r7
 801d592:	0021      	movs	r1, r4
 801d594:	4b10      	ldr	r3, [pc, #64]	; (801d5d8 <_svfiprintf_r+0x1fc>)
 801d596:	9803      	ldr	r0, [sp, #12]
 801d598:	e000      	b.n	801d59c <_svfiprintf_r+0x1c0>
 801d59a:	bf00      	nop
 801d59c:	9004      	str	r0, [sp, #16]
 801d59e:	9b04      	ldr	r3, [sp, #16]
 801d5a0:	3301      	adds	r3, #1
 801d5a2:	d1d3      	bne.n	801d54c <_svfiprintf_r+0x170>
 801d5a4:	89bb      	ldrh	r3, [r7, #12]
 801d5a6:	980d      	ldr	r0, [sp, #52]	; 0x34
 801d5a8:	065b      	lsls	r3, r3, #25
 801d5aa:	d400      	bmi.n	801d5ae <_svfiprintf_r+0x1d2>
 801d5ac:	e72d      	b.n	801d40a <_svfiprintf_r+0x2e>
 801d5ae:	2001      	movs	r0, #1
 801d5b0:	4240      	negs	r0, r0
 801d5b2:	e72a      	b.n	801d40a <_svfiprintf_r+0x2e>
 801d5b4:	ab07      	add	r3, sp, #28
 801d5b6:	9300      	str	r3, [sp, #0]
 801d5b8:	003a      	movs	r2, r7
 801d5ba:	0021      	movs	r1, r4
 801d5bc:	4b06      	ldr	r3, [pc, #24]	; (801d5d8 <_svfiprintf_r+0x1fc>)
 801d5be:	9803      	ldr	r0, [sp, #12]
 801d5c0:	f000 f87c 	bl	801d6bc <_printf_i>
 801d5c4:	e7ea      	b.n	801d59c <_svfiprintf_r+0x1c0>
 801d5c6:	46c0      	nop			; (mov r8, r8)
 801d5c8:	08022f65 	.word	0x08022f65
 801d5cc:	08022f6b 	.word	0x08022f6b
 801d5d0:	08022f6f 	.word	0x08022f6f
 801d5d4:	00000000 	.word	0x00000000
 801d5d8:	0801d319 	.word	0x0801d319

0801d5dc <_printf_common>:
 801d5dc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 801d5de:	0015      	movs	r5, r2
 801d5e0:	9301      	str	r3, [sp, #4]
 801d5e2:	688a      	ldr	r2, [r1, #8]
 801d5e4:	690b      	ldr	r3, [r1, #16]
 801d5e6:	000c      	movs	r4, r1
 801d5e8:	9000      	str	r0, [sp, #0]
 801d5ea:	4293      	cmp	r3, r2
 801d5ec:	da00      	bge.n	801d5f0 <_printf_common+0x14>
 801d5ee:	0013      	movs	r3, r2
 801d5f0:	0022      	movs	r2, r4
 801d5f2:	602b      	str	r3, [r5, #0]
 801d5f4:	3243      	adds	r2, #67	; 0x43
 801d5f6:	7812      	ldrb	r2, [r2, #0]
 801d5f8:	2a00      	cmp	r2, #0
 801d5fa:	d001      	beq.n	801d600 <_printf_common+0x24>
 801d5fc:	3301      	adds	r3, #1
 801d5fe:	602b      	str	r3, [r5, #0]
 801d600:	6823      	ldr	r3, [r4, #0]
 801d602:	069b      	lsls	r3, r3, #26
 801d604:	d502      	bpl.n	801d60c <_printf_common+0x30>
 801d606:	682b      	ldr	r3, [r5, #0]
 801d608:	3302      	adds	r3, #2
 801d60a:	602b      	str	r3, [r5, #0]
 801d60c:	6822      	ldr	r2, [r4, #0]
 801d60e:	2306      	movs	r3, #6
 801d610:	0017      	movs	r7, r2
 801d612:	401f      	ands	r7, r3
 801d614:	421a      	tst	r2, r3
 801d616:	d027      	beq.n	801d668 <_printf_common+0x8c>
 801d618:	0023      	movs	r3, r4
 801d61a:	3343      	adds	r3, #67	; 0x43
 801d61c:	781b      	ldrb	r3, [r3, #0]
 801d61e:	1e5a      	subs	r2, r3, #1
 801d620:	4193      	sbcs	r3, r2
 801d622:	6822      	ldr	r2, [r4, #0]
 801d624:	0692      	lsls	r2, r2, #26
 801d626:	d430      	bmi.n	801d68a <_printf_common+0xae>
 801d628:	0022      	movs	r2, r4
 801d62a:	9901      	ldr	r1, [sp, #4]
 801d62c:	9800      	ldr	r0, [sp, #0]
 801d62e:	9e08      	ldr	r6, [sp, #32]
 801d630:	3243      	adds	r2, #67	; 0x43
 801d632:	47b0      	blx	r6
 801d634:	1c43      	adds	r3, r0, #1
 801d636:	d025      	beq.n	801d684 <_printf_common+0xa8>
 801d638:	2306      	movs	r3, #6
 801d63a:	6820      	ldr	r0, [r4, #0]
 801d63c:	682a      	ldr	r2, [r5, #0]
 801d63e:	68e1      	ldr	r1, [r4, #12]
 801d640:	2500      	movs	r5, #0
 801d642:	4003      	ands	r3, r0
 801d644:	2b04      	cmp	r3, #4
 801d646:	d103      	bne.n	801d650 <_printf_common+0x74>
 801d648:	1a8d      	subs	r5, r1, r2
 801d64a:	43eb      	mvns	r3, r5
 801d64c:	17db      	asrs	r3, r3, #31
 801d64e:	401d      	ands	r5, r3
 801d650:	68a3      	ldr	r3, [r4, #8]
 801d652:	6922      	ldr	r2, [r4, #16]
 801d654:	4293      	cmp	r3, r2
 801d656:	dd01      	ble.n	801d65c <_printf_common+0x80>
 801d658:	1a9b      	subs	r3, r3, r2
 801d65a:	18ed      	adds	r5, r5, r3
 801d65c:	2700      	movs	r7, #0
 801d65e:	42bd      	cmp	r5, r7
 801d660:	d120      	bne.n	801d6a4 <_printf_common+0xc8>
 801d662:	2000      	movs	r0, #0
 801d664:	e010      	b.n	801d688 <_printf_common+0xac>
 801d666:	3701      	adds	r7, #1
 801d668:	68e3      	ldr	r3, [r4, #12]
 801d66a:	682a      	ldr	r2, [r5, #0]
 801d66c:	1a9b      	subs	r3, r3, r2
 801d66e:	42bb      	cmp	r3, r7
 801d670:	ddd2      	ble.n	801d618 <_printf_common+0x3c>
 801d672:	0022      	movs	r2, r4
 801d674:	2301      	movs	r3, #1
 801d676:	9901      	ldr	r1, [sp, #4]
 801d678:	9800      	ldr	r0, [sp, #0]
 801d67a:	9e08      	ldr	r6, [sp, #32]
 801d67c:	3219      	adds	r2, #25
 801d67e:	47b0      	blx	r6
 801d680:	1c43      	adds	r3, r0, #1
 801d682:	d1f0      	bne.n	801d666 <_printf_common+0x8a>
 801d684:	2001      	movs	r0, #1
 801d686:	4240      	negs	r0, r0
 801d688:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 801d68a:	2030      	movs	r0, #48	; 0x30
 801d68c:	18e1      	adds	r1, r4, r3
 801d68e:	3143      	adds	r1, #67	; 0x43
 801d690:	7008      	strb	r0, [r1, #0]
 801d692:	0021      	movs	r1, r4
 801d694:	1c5a      	adds	r2, r3, #1
 801d696:	3145      	adds	r1, #69	; 0x45
 801d698:	7809      	ldrb	r1, [r1, #0]
 801d69a:	18a2      	adds	r2, r4, r2
 801d69c:	3243      	adds	r2, #67	; 0x43
 801d69e:	3302      	adds	r3, #2
 801d6a0:	7011      	strb	r1, [r2, #0]
 801d6a2:	e7c1      	b.n	801d628 <_printf_common+0x4c>
 801d6a4:	0022      	movs	r2, r4
 801d6a6:	2301      	movs	r3, #1
 801d6a8:	9901      	ldr	r1, [sp, #4]
 801d6aa:	9800      	ldr	r0, [sp, #0]
 801d6ac:	9e08      	ldr	r6, [sp, #32]
 801d6ae:	321a      	adds	r2, #26
 801d6b0:	47b0      	blx	r6
 801d6b2:	1c43      	adds	r3, r0, #1
 801d6b4:	d0e6      	beq.n	801d684 <_printf_common+0xa8>
 801d6b6:	3701      	adds	r7, #1
 801d6b8:	e7d1      	b.n	801d65e <_printf_common+0x82>
	...

0801d6bc <_printf_i>:
 801d6bc:	b5f0      	push	{r4, r5, r6, r7, lr}
 801d6be:	b08b      	sub	sp, #44	; 0x2c
 801d6c0:	9206      	str	r2, [sp, #24]
 801d6c2:	000a      	movs	r2, r1
 801d6c4:	3243      	adds	r2, #67	; 0x43
 801d6c6:	9307      	str	r3, [sp, #28]
 801d6c8:	9005      	str	r0, [sp, #20]
 801d6ca:	9204      	str	r2, [sp, #16]
 801d6cc:	7e0a      	ldrb	r2, [r1, #24]
 801d6ce:	000c      	movs	r4, r1
 801d6d0:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801d6d2:	2a78      	cmp	r2, #120	; 0x78
 801d6d4:	d806      	bhi.n	801d6e4 <_printf_i+0x28>
 801d6d6:	2a62      	cmp	r2, #98	; 0x62
 801d6d8:	d808      	bhi.n	801d6ec <_printf_i+0x30>
 801d6da:	2a00      	cmp	r2, #0
 801d6dc:	d100      	bne.n	801d6e0 <_printf_i+0x24>
 801d6de:	e0c0      	b.n	801d862 <_printf_i+0x1a6>
 801d6e0:	2a58      	cmp	r2, #88	; 0x58
 801d6e2:	d052      	beq.n	801d78a <_printf_i+0xce>
 801d6e4:	0026      	movs	r6, r4
 801d6e6:	3642      	adds	r6, #66	; 0x42
 801d6e8:	7032      	strb	r2, [r6, #0]
 801d6ea:	e022      	b.n	801d732 <_printf_i+0x76>
 801d6ec:	0010      	movs	r0, r2
 801d6ee:	3863      	subs	r0, #99	; 0x63
 801d6f0:	2815      	cmp	r0, #21
 801d6f2:	d8f7      	bhi.n	801d6e4 <_printf_i+0x28>
 801d6f4:	f7e2 fd10 	bl	8000118 <__gnu_thumb1_case_shi>
 801d6f8:	001f0016 	.word	0x001f0016
 801d6fc:	fff6fff6 	.word	0xfff6fff6
 801d700:	fff6fff6 	.word	0xfff6fff6
 801d704:	fff6001f 	.word	0xfff6001f
 801d708:	fff6fff6 	.word	0xfff6fff6
 801d70c:	00a8fff6 	.word	0x00a8fff6
 801d710:	009a0036 	.word	0x009a0036
 801d714:	fff6fff6 	.word	0xfff6fff6
 801d718:	fff600b9 	.word	0xfff600b9
 801d71c:	fff60036 	.word	0xfff60036
 801d720:	009efff6 	.word	0x009efff6
 801d724:	0026      	movs	r6, r4
 801d726:	681a      	ldr	r2, [r3, #0]
 801d728:	3642      	adds	r6, #66	; 0x42
 801d72a:	1d11      	adds	r1, r2, #4
 801d72c:	6019      	str	r1, [r3, #0]
 801d72e:	6813      	ldr	r3, [r2, #0]
 801d730:	7033      	strb	r3, [r6, #0]
 801d732:	2301      	movs	r3, #1
 801d734:	e0a7      	b.n	801d886 <_printf_i+0x1ca>
 801d736:	6808      	ldr	r0, [r1, #0]
 801d738:	6819      	ldr	r1, [r3, #0]
 801d73a:	1d0a      	adds	r2, r1, #4
 801d73c:	0605      	lsls	r5, r0, #24
 801d73e:	d50b      	bpl.n	801d758 <_printf_i+0x9c>
 801d740:	680d      	ldr	r5, [r1, #0]
 801d742:	601a      	str	r2, [r3, #0]
 801d744:	2d00      	cmp	r5, #0
 801d746:	da03      	bge.n	801d750 <_printf_i+0x94>
 801d748:	232d      	movs	r3, #45	; 0x2d
 801d74a:	9a04      	ldr	r2, [sp, #16]
 801d74c:	426d      	negs	r5, r5
 801d74e:	7013      	strb	r3, [r2, #0]
 801d750:	4b61      	ldr	r3, [pc, #388]	; (801d8d8 <_printf_i+0x21c>)
 801d752:	270a      	movs	r7, #10
 801d754:	9303      	str	r3, [sp, #12]
 801d756:	e032      	b.n	801d7be <_printf_i+0x102>
 801d758:	680d      	ldr	r5, [r1, #0]
 801d75a:	601a      	str	r2, [r3, #0]
 801d75c:	0641      	lsls	r1, r0, #25
 801d75e:	d5f1      	bpl.n	801d744 <_printf_i+0x88>
 801d760:	b22d      	sxth	r5, r5
 801d762:	e7ef      	b.n	801d744 <_printf_i+0x88>
 801d764:	680d      	ldr	r5, [r1, #0]
 801d766:	6819      	ldr	r1, [r3, #0]
 801d768:	1d08      	adds	r0, r1, #4
 801d76a:	6018      	str	r0, [r3, #0]
 801d76c:	062e      	lsls	r6, r5, #24
 801d76e:	d501      	bpl.n	801d774 <_printf_i+0xb8>
 801d770:	680d      	ldr	r5, [r1, #0]
 801d772:	e003      	b.n	801d77c <_printf_i+0xc0>
 801d774:	066d      	lsls	r5, r5, #25
 801d776:	d5fb      	bpl.n	801d770 <_printf_i+0xb4>
 801d778:	680d      	ldr	r5, [r1, #0]
 801d77a:	b2ad      	uxth	r5, r5
 801d77c:	4b56      	ldr	r3, [pc, #344]	; (801d8d8 <_printf_i+0x21c>)
 801d77e:	270a      	movs	r7, #10
 801d780:	9303      	str	r3, [sp, #12]
 801d782:	2a6f      	cmp	r2, #111	; 0x6f
 801d784:	d117      	bne.n	801d7b6 <_printf_i+0xfa>
 801d786:	2708      	movs	r7, #8
 801d788:	e015      	b.n	801d7b6 <_printf_i+0xfa>
 801d78a:	3145      	adds	r1, #69	; 0x45
 801d78c:	700a      	strb	r2, [r1, #0]
 801d78e:	4a52      	ldr	r2, [pc, #328]	; (801d8d8 <_printf_i+0x21c>)
 801d790:	9203      	str	r2, [sp, #12]
 801d792:	681a      	ldr	r2, [r3, #0]
 801d794:	6821      	ldr	r1, [r4, #0]
 801d796:	ca20      	ldmia	r2!, {r5}
 801d798:	601a      	str	r2, [r3, #0]
 801d79a:	0608      	lsls	r0, r1, #24
 801d79c:	d550      	bpl.n	801d840 <_printf_i+0x184>
 801d79e:	07cb      	lsls	r3, r1, #31
 801d7a0:	d502      	bpl.n	801d7a8 <_printf_i+0xec>
 801d7a2:	2320      	movs	r3, #32
 801d7a4:	4319      	orrs	r1, r3
 801d7a6:	6021      	str	r1, [r4, #0]
 801d7a8:	2710      	movs	r7, #16
 801d7aa:	2d00      	cmp	r5, #0
 801d7ac:	d103      	bne.n	801d7b6 <_printf_i+0xfa>
 801d7ae:	2320      	movs	r3, #32
 801d7b0:	6822      	ldr	r2, [r4, #0]
 801d7b2:	439a      	bics	r2, r3
 801d7b4:	6022      	str	r2, [r4, #0]
 801d7b6:	0023      	movs	r3, r4
 801d7b8:	2200      	movs	r2, #0
 801d7ba:	3343      	adds	r3, #67	; 0x43
 801d7bc:	701a      	strb	r2, [r3, #0]
 801d7be:	6863      	ldr	r3, [r4, #4]
 801d7c0:	60a3      	str	r3, [r4, #8]
 801d7c2:	2b00      	cmp	r3, #0
 801d7c4:	db03      	blt.n	801d7ce <_printf_i+0x112>
 801d7c6:	2204      	movs	r2, #4
 801d7c8:	6821      	ldr	r1, [r4, #0]
 801d7ca:	4391      	bics	r1, r2
 801d7cc:	6021      	str	r1, [r4, #0]
 801d7ce:	2d00      	cmp	r5, #0
 801d7d0:	d102      	bne.n	801d7d8 <_printf_i+0x11c>
 801d7d2:	9e04      	ldr	r6, [sp, #16]
 801d7d4:	2b00      	cmp	r3, #0
 801d7d6:	d00c      	beq.n	801d7f2 <_printf_i+0x136>
 801d7d8:	9e04      	ldr	r6, [sp, #16]
 801d7da:	0028      	movs	r0, r5
 801d7dc:	0039      	movs	r1, r7
 801d7de:	f7e2 fd2b 	bl	8000238 <__aeabi_uidivmod>
 801d7e2:	9b03      	ldr	r3, [sp, #12]
 801d7e4:	3e01      	subs	r6, #1
 801d7e6:	5c5b      	ldrb	r3, [r3, r1]
 801d7e8:	7033      	strb	r3, [r6, #0]
 801d7ea:	002b      	movs	r3, r5
 801d7ec:	0005      	movs	r5, r0
 801d7ee:	429f      	cmp	r7, r3
 801d7f0:	d9f3      	bls.n	801d7da <_printf_i+0x11e>
 801d7f2:	2f08      	cmp	r7, #8
 801d7f4:	d109      	bne.n	801d80a <_printf_i+0x14e>
 801d7f6:	6823      	ldr	r3, [r4, #0]
 801d7f8:	07db      	lsls	r3, r3, #31
 801d7fa:	d506      	bpl.n	801d80a <_printf_i+0x14e>
 801d7fc:	6863      	ldr	r3, [r4, #4]
 801d7fe:	6922      	ldr	r2, [r4, #16]
 801d800:	4293      	cmp	r3, r2
 801d802:	dc02      	bgt.n	801d80a <_printf_i+0x14e>
 801d804:	2330      	movs	r3, #48	; 0x30
 801d806:	3e01      	subs	r6, #1
 801d808:	7033      	strb	r3, [r6, #0]
 801d80a:	9b04      	ldr	r3, [sp, #16]
 801d80c:	1b9b      	subs	r3, r3, r6
 801d80e:	6123      	str	r3, [r4, #16]
 801d810:	9b07      	ldr	r3, [sp, #28]
 801d812:	0021      	movs	r1, r4
 801d814:	9300      	str	r3, [sp, #0]
 801d816:	9805      	ldr	r0, [sp, #20]
 801d818:	9b06      	ldr	r3, [sp, #24]
 801d81a:	aa09      	add	r2, sp, #36	; 0x24
 801d81c:	f7ff fede 	bl	801d5dc <_printf_common>
 801d820:	1c43      	adds	r3, r0, #1
 801d822:	d135      	bne.n	801d890 <_printf_i+0x1d4>
 801d824:	2001      	movs	r0, #1
 801d826:	4240      	negs	r0, r0
 801d828:	b00b      	add	sp, #44	; 0x2c
 801d82a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801d82c:	2220      	movs	r2, #32
 801d82e:	6809      	ldr	r1, [r1, #0]
 801d830:	430a      	orrs	r2, r1
 801d832:	6022      	str	r2, [r4, #0]
 801d834:	0022      	movs	r2, r4
 801d836:	2178      	movs	r1, #120	; 0x78
 801d838:	3245      	adds	r2, #69	; 0x45
 801d83a:	7011      	strb	r1, [r2, #0]
 801d83c:	4a27      	ldr	r2, [pc, #156]	; (801d8dc <_printf_i+0x220>)
 801d83e:	e7a7      	b.n	801d790 <_printf_i+0xd4>
 801d840:	0648      	lsls	r0, r1, #25
 801d842:	d5ac      	bpl.n	801d79e <_printf_i+0xe2>
 801d844:	b2ad      	uxth	r5, r5
 801d846:	e7aa      	b.n	801d79e <_printf_i+0xe2>
 801d848:	681a      	ldr	r2, [r3, #0]
 801d84a:	680d      	ldr	r5, [r1, #0]
 801d84c:	1d10      	adds	r0, r2, #4
 801d84e:	6949      	ldr	r1, [r1, #20]
 801d850:	6018      	str	r0, [r3, #0]
 801d852:	6813      	ldr	r3, [r2, #0]
 801d854:	062e      	lsls	r6, r5, #24
 801d856:	d501      	bpl.n	801d85c <_printf_i+0x1a0>
 801d858:	6019      	str	r1, [r3, #0]
 801d85a:	e002      	b.n	801d862 <_printf_i+0x1a6>
 801d85c:	066d      	lsls	r5, r5, #25
 801d85e:	d5fb      	bpl.n	801d858 <_printf_i+0x19c>
 801d860:	8019      	strh	r1, [r3, #0]
 801d862:	2300      	movs	r3, #0
 801d864:	9e04      	ldr	r6, [sp, #16]
 801d866:	6123      	str	r3, [r4, #16]
 801d868:	e7d2      	b.n	801d810 <_printf_i+0x154>
 801d86a:	681a      	ldr	r2, [r3, #0]
 801d86c:	1d11      	adds	r1, r2, #4
 801d86e:	6019      	str	r1, [r3, #0]
 801d870:	6816      	ldr	r6, [r2, #0]
 801d872:	2100      	movs	r1, #0
 801d874:	0030      	movs	r0, r6
 801d876:	6862      	ldr	r2, [r4, #4]
 801d878:	f000 f832 	bl	801d8e0 <memchr>
 801d87c:	2800      	cmp	r0, #0
 801d87e:	d001      	beq.n	801d884 <_printf_i+0x1c8>
 801d880:	1b80      	subs	r0, r0, r6
 801d882:	6060      	str	r0, [r4, #4]
 801d884:	6863      	ldr	r3, [r4, #4]
 801d886:	6123      	str	r3, [r4, #16]
 801d888:	2300      	movs	r3, #0
 801d88a:	9a04      	ldr	r2, [sp, #16]
 801d88c:	7013      	strb	r3, [r2, #0]
 801d88e:	e7bf      	b.n	801d810 <_printf_i+0x154>
 801d890:	6923      	ldr	r3, [r4, #16]
 801d892:	0032      	movs	r2, r6
 801d894:	9906      	ldr	r1, [sp, #24]
 801d896:	9805      	ldr	r0, [sp, #20]
 801d898:	9d07      	ldr	r5, [sp, #28]
 801d89a:	47a8      	blx	r5
 801d89c:	1c43      	adds	r3, r0, #1
 801d89e:	d0c1      	beq.n	801d824 <_printf_i+0x168>
 801d8a0:	6823      	ldr	r3, [r4, #0]
 801d8a2:	079b      	lsls	r3, r3, #30
 801d8a4:	d415      	bmi.n	801d8d2 <_printf_i+0x216>
 801d8a6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801d8a8:	68e0      	ldr	r0, [r4, #12]
 801d8aa:	4298      	cmp	r0, r3
 801d8ac:	dabc      	bge.n	801d828 <_printf_i+0x16c>
 801d8ae:	0018      	movs	r0, r3
 801d8b0:	e7ba      	b.n	801d828 <_printf_i+0x16c>
 801d8b2:	0022      	movs	r2, r4
 801d8b4:	2301      	movs	r3, #1
 801d8b6:	9906      	ldr	r1, [sp, #24]
 801d8b8:	9805      	ldr	r0, [sp, #20]
 801d8ba:	9e07      	ldr	r6, [sp, #28]
 801d8bc:	3219      	adds	r2, #25
 801d8be:	47b0      	blx	r6
 801d8c0:	1c43      	adds	r3, r0, #1
 801d8c2:	d0af      	beq.n	801d824 <_printf_i+0x168>
 801d8c4:	3501      	adds	r5, #1
 801d8c6:	68e3      	ldr	r3, [r4, #12]
 801d8c8:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801d8ca:	1a9b      	subs	r3, r3, r2
 801d8cc:	42ab      	cmp	r3, r5
 801d8ce:	dcf0      	bgt.n	801d8b2 <_printf_i+0x1f6>
 801d8d0:	e7e9      	b.n	801d8a6 <_printf_i+0x1ea>
 801d8d2:	2500      	movs	r5, #0
 801d8d4:	e7f7      	b.n	801d8c6 <_printf_i+0x20a>
 801d8d6:	46c0      	nop			; (mov r8, r8)
 801d8d8:	08022f76 	.word	0x08022f76
 801d8dc:	08022f87 	.word	0x08022f87

0801d8e0 <memchr>:
 801d8e0:	b2c9      	uxtb	r1, r1
 801d8e2:	1882      	adds	r2, r0, r2
 801d8e4:	4290      	cmp	r0, r2
 801d8e6:	d101      	bne.n	801d8ec <memchr+0xc>
 801d8e8:	2000      	movs	r0, #0
 801d8ea:	4770      	bx	lr
 801d8ec:	7803      	ldrb	r3, [r0, #0]
 801d8ee:	428b      	cmp	r3, r1
 801d8f0:	d0fb      	beq.n	801d8ea <memchr+0xa>
 801d8f2:	3001      	adds	r0, #1
 801d8f4:	e7f6      	b.n	801d8e4 <memchr+0x4>

0801d8f6 <_realloc_r>:
 801d8f6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801d8f8:	0007      	movs	r7, r0
 801d8fa:	000d      	movs	r5, r1
 801d8fc:	0016      	movs	r6, r2
 801d8fe:	2900      	cmp	r1, #0
 801d900:	d105      	bne.n	801d90e <_realloc_r+0x18>
 801d902:	0011      	movs	r1, r2
 801d904:	f7ff fb50 	bl	801cfa8 <_malloc_r>
 801d908:	0004      	movs	r4, r0
 801d90a:	0020      	movs	r0, r4
 801d90c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801d90e:	2a00      	cmp	r2, #0
 801d910:	d103      	bne.n	801d91a <_realloc_r+0x24>
 801d912:	f7ff faff 	bl	801cf14 <_free_r>
 801d916:	0034      	movs	r4, r6
 801d918:	e7f7      	b.n	801d90a <_realloc_r+0x14>
 801d91a:	f000 f812 	bl	801d942 <_malloc_usable_size_r>
 801d91e:	002c      	movs	r4, r5
 801d920:	42b0      	cmp	r0, r6
 801d922:	d2f2      	bcs.n	801d90a <_realloc_r+0x14>
 801d924:	0031      	movs	r1, r6
 801d926:	0038      	movs	r0, r7
 801d928:	f7ff fb3e 	bl	801cfa8 <_malloc_r>
 801d92c:	1e04      	subs	r4, r0, #0
 801d92e:	d0ec      	beq.n	801d90a <_realloc_r+0x14>
 801d930:	0029      	movs	r1, r5
 801d932:	0032      	movs	r2, r6
 801d934:	f7ff faca 	bl	801cecc <memcpy>
 801d938:	0029      	movs	r1, r5
 801d93a:	0038      	movs	r0, r7
 801d93c:	f7ff faea 	bl	801cf14 <_free_r>
 801d940:	e7e3      	b.n	801d90a <_realloc_r+0x14>

0801d942 <_malloc_usable_size_r>:
 801d942:	1f0b      	subs	r3, r1, #4
 801d944:	681b      	ldr	r3, [r3, #0]
 801d946:	1f18      	subs	r0, r3, #4
 801d948:	2b00      	cmp	r3, #0
 801d94a:	da01      	bge.n	801d950 <_malloc_usable_size_r+0xe>
 801d94c:	580b      	ldr	r3, [r1, r0]
 801d94e:	18c0      	adds	r0, r0, r3
 801d950:	4770      	bx	lr
	...

0801d954 <_init>:
 801d954:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801d956:	46c0      	nop			; (mov r8, r8)
 801d958:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801d95a:	bc08      	pop	{r3}
 801d95c:	469e      	mov	lr, r3
 801d95e:	4770      	bx	lr

0801d960 <_fini>:
 801d960:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801d962:	46c0      	nop			; (mov r8, r8)
 801d964:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801d966:	bc08      	pop	{r3}
 801d968:	469e      	mov	lr, r3
 801d96a:	4770      	bx	lr

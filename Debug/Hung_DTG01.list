
Hung_DTG01.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000c0  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0001e83c  080000c0  080000c0  000100c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00005920  0801e8fc  0801e8fc  0002e8fc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0802421c  0802421c  000400a4  2**0
                  CONTENTS
  4 .ARM          00000008  0802421c  0802421c  0003421c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  08024224  08024224  000400a4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08024224  08024224  00034224  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08024228  08024228  00034228  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         000000a4  20000000  0802422c  00040000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          000039e0  200000a4  080242d0  000400a4  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  20003a84  080242d0  00043a84  2**0
                  ALLOC
 11 .ARM.attributes 00000028  00000000  00000000  000400a4  2**0
                  CONTENTS, READONLY
 12 .debug_info   0005488c  00000000  00000000  000400cc  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 00008db4  00000000  00000000  00094958  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00001c20  00000000  00000000  0009d710  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_ranges 00001cb0  00000000  00000000  0009f330  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  000226d9  00000000  00000000  000a0fe0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   000332fd  00000000  00000000  000c36b9  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    00089ca1  00000000  00000000  000f69b6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000053  00000000  00000000  00180657  2**0
                  CONTENTS, READONLY
 20 .debug_frame  000066c8  00000000  00000000  001806ac  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080000c0 <__do_global_dtors_aux>:
 80000c0:	b510      	push	{r4, lr}
 80000c2:	4c06      	ldr	r4, [pc, #24]	; (80000dc <__do_global_dtors_aux+0x1c>)
 80000c4:	7823      	ldrb	r3, [r4, #0]
 80000c6:	2b00      	cmp	r3, #0
 80000c8:	d107      	bne.n	80000da <__do_global_dtors_aux+0x1a>
 80000ca:	4b05      	ldr	r3, [pc, #20]	; (80000e0 <__do_global_dtors_aux+0x20>)
 80000cc:	2b00      	cmp	r3, #0
 80000ce:	d002      	beq.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d0:	4804      	ldr	r0, [pc, #16]	; (80000e4 <__do_global_dtors_aux+0x24>)
 80000d2:	e000      	b.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d4:	bf00      	nop
 80000d6:	2301      	movs	r3, #1
 80000d8:	7023      	strb	r3, [r4, #0]
 80000da:	bd10      	pop	{r4, pc}
 80000dc:	200000a4 	.word	0x200000a4
 80000e0:	00000000 	.word	0x00000000
 80000e4:	0801e8e4 	.word	0x0801e8e4

080000e8 <frame_dummy>:
 80000e8:	4b04      	ldr	r3, [pc, #16]	; (80000fc <frame_dummy+0x14>)
 80000ea:	b510      	push	{r4, lr}
 80000ec:	2b00      	cmp	r3, #0
 80000ee:	d003      	beq.n	80000f8 <frame_dummy+0x10>
 80000f0:	4903      	ldr	r1, [pc, #12]	; (8000100 <frame_dummy+0x18>)
 80000f2:	4804      	ldr	r0, [pc, #16]	; (8000104 <frame_dummy+0x1c>)
 80000f4:	e000      	b.n	80000f8 <frame_dummy+0x10>
 80000f6:	bf00      	nop
 80000f8:	bd10      	pop	{r4, pc}
 80000fa:	46c0      	nop			; (mov r8, r8)
 80000fc:	00000000 	.word	0x00000000
 8000100:	200000a8 	.word	0x200000a8
 8000104:	0801e8e4 	.word	0x0801e8e4

08000108 <strcmp>:
 8000108:	7802      	ldrb	r2, [r0, #0]
 800010a:	780b      	ldrb	r3, [r1, #0]
 800010c:	2a00      	cmp	r2, #0
 800010e:	d003      	beq.n	8000118 <strcmp+0x10>
 8000110:	3001      	adds	r0, #1
 8000112:	3101      	adds	r1, #1
 8000114:	429a      	cmp	r2, r3
 8000116:	d0f7      	beq.n	8000108 <strcmp>
 8000118:	1ad0      	subs	r0, r2, r3
 800011a:	4770      	bx	lr

0800011c <strlen>:
 800011c:	2300      	movs	r3, #0
 800011e:	5cc2      	ldrb	r2, [r0, r3]
 8000120:	3301      	adds	r3, #1
 8000122:	2a00      	cmp	r2, #0
 8000124:	d1fb      	bne.n	800011e <strlen+0x2>
 8000126:	1e58      	subs	r0, r3, #1
 8000128:	4770      	bx	lr
	...

0800012c <__gnu_thumb1_case_shi>:
 800012c:	b403      	push	{r0, r1}
 800012e:	4671      	mov	r1, lr
 8000130:	0849      	lsrs	r1, r1, #1
 8000132:	0040      	lsls	r0, r0, #1
 8000134:	0049      	lsls	r1, r1, #1
 8000136:	5e09      	ldrsh	r1, [r1, r0]
 8000138:	0049      	lsls	r1, r1, #1
 800013a:	448e      	add	lr, r1
 800013c:	bc03      	pop	{r0, r1}
 800013e:	4770      	bx	lr

08000140 <__udivsi3>:
 8000140:	2200      	movs	r2, #0
 8000142:	0843      	lsrs	r3, r0, #1
 8000144:	428b      	cmp	r3, r1
 8000146:	d374      	bcc.n	8000232 <__udivsi3+0xf2>
 8000148:	0903      	lsrs	r3, r0, #4
 800014a:	428b      	cmp	r3, r1
 800014c:	d35f      	bcc.n	800020e <__udivsi3+0xce>
 800014e:	0a03      	lsrs	r3, r0, #8
 8000150:	428b      	cmp	r3, r1
 8000152:	d344      	bcc.n	80001de <__udivsi3+0x9e>
 8000154:	0b03      	lsrs	r3, r0, #12
 8000156:	428b      	cmp	r3, r1
 8000158:	d328      	bcc.n	80001ac <__udivsi3+0x6c>
 800015a:	0c03      	lsrs	r3, r0, #16
 800015c:	428b      	cmp	r3, r1
 800015e:	d30d      	bcc.n	800017c <__udivsi3+0x3c>
 8000160:	22ff      	movs	r2, #255	; 0xff
 8000162:	0209      	lsls	r1, r1, #8
 8000164:	ba12      	rev	r2, r2
 8000166:	0c03      	lsrs	r3, r0, #16
 8000168:	428b      	cmp	r3, r1
 800016a:	d302      	bcc.n	8000172 <__udivsi3+0x32>
 800016c:	1212      	asrs	r2, r2, #8
 800016e:	0209      	lsls	r1, r1, #8
 8000170:	d065      	beq.n	800023e <__udivsi3+0xfe>
 8000172:	0b03      	lsrs	r3, r0, #12
 8000174:	428b      	cmp	r3, r1
 8000176:	d319      	bcc.n	80001ac <__udivsi3+0x6c>
 8000178:	e000      	b.n	800017c <__udivsi3+0x3c>
 800017a:	0a09      	lsrs	r1, r1, #8
 800017c:	0bc3      	lsrs	r3, r0, #15
 800017e:	428b      	cmp	r3, r1
 8000180:	d301      	bcc.n	8000186 <__udivsi3+0x46>
 8000182:	03cb      	lsls	r3, r1, #15
 8000184:	1ac0      	subs	r0, r0, r3
 8000186:	4152      	adcs	r2, r2
 8000188:	0b83      	lsrs	r3, r0, #14
 800018a:	428b      	cmp	r3, r1
 800018c:	d301      	bcc.n	8000192 <__udivsi3+0x52>
 800018e:	038b      	lsls	r3, r1, #14
 8000190:	1ac0      	subs	r0, r0, r3
 8000192:	4152      	adcs	r2, r2
 8000194:	0b43      	lsrs	r3, r0, #13
 8000196:	428b      	cmp	r3, r1
 8000198:	d301      	bcc.n	800019e <__udivsi3+0x5e>
 800019a:	034b      	lsls	r3, r1, #13
 800019c:	1ac0      	subs	r0, r0, r3
 800019e:	4152      	adcs	r2, r2
 80001a0:	0b03      	lsrs	r3, r0, #12
 80001a2:	428b      	cmp	r3, r1
 80001a4:	d301      	bcc.n	80001aa <__udivsi3+0x6a>
 80001a6:	030b      	lsls	r3, r1, #12
 80001a8:	1ac0      	subs	r0, r0, r3
 80001aa:	4152      	adcs	r2, r2
 80001ac:	0ac3      	lsrs	r3, r0, #11
 80001ae:	428b      	cmp	r3, r1
 80001b0:	d301      	bcc.n	80001b6 <__udivsi3+0x76>
 80001b2:	02cb      	lsls	r3, r1, #11
 80001b4:	1ac0      	subs	r0, r0, r3
 80001b6:	4152      	adcs	r2, r2
 80001b8:	0a83      	lsrs	r3, r0, #10
 80001ba:	428b      	cmp	r3, r1
 80001bc:	d301      	bcc.n	80001c2 <__udivsi3+0x82>
 80001be:	028b      	lsls	r3, r1, #10
 80001c0:	1ac0      	subs	r0, r0, r3
 80001c2:	4152      	adcs	r2, r2
 80001c4:	0a43      	lsrs	r3, r0, #9
 80001c6:	428b      	cmp	r3, r1
 80001c8:	d301      	bcc.n	80001ce <__udivsi3+0x8e>
 80001ca:	024b      	lsls	r3, r1, #9
 80001cc:	1ac0      	subs	r0, r0, r3
 80001ce:	4152      	adcs	r2, r2
 80001d0:	0a03      	lsrs	r3, r0, #8
 80001d2:	428b      	cmp	r3, r1
 80001d4:	d301      	bcc.n	80001da <__udivsi3+0x9a>
 80001d6:	020b      	lsls	r3, r1, #8
 80001d8:	1ac0      	subs	r0, r0, r3
 80001da:	4152      	adcs	r2, r2
 80001dc:	d2cd      	bcs.n	800017a <__udivsi3+0x3a>
 80001de:	09c3      	lsrs	r3, r0, #7
 80001e0:	428b      	cmp	r3, r1
 80001e2:	d301      	bcc.n	80001e8 <__udivsi3+0xa8>
 80001e4:	01cb      	lsls	r3, r1, #7
 80001e6:	1ac0      	subs	r0, r0, r3
 80001e8:	4152      	adcs	r2, r2
 80001ea:	0983      	lsrs	r3, r0, #6
 80001ec:	428b      	cmp	r3, r1
 80001ee:	d301      	bcc.n	80001f4 <__udivsi3+0xb4>
 80001f0:	018b      	lsls	r3, r1, #6
 80001f2:	1ac0      	subs	r0, r0, r3
 80001f4:	4152      	adcs	r2, r2
 80001f6:	0943      	lsrs	r3, r0, #5
 80001f8:	428b      	cmp	r3, r1
 80001fa:	d301      	bcc.n	8000200 <__udivsi3+0xc0>
 80001fc:	014b      	lsls	r3, r1, #5
 80001fe:	1ac0      	subs	r0, r0, r3
 8000200:	4152      	adcs	r2, r2
 8000202:	0903      	lsrs	r3, r0, #4
 8000204:	428b      	cmp	r3, r1
 8000206:	d301      	bcc.n	800020c <__udivsi3+0xcc>
 8000208:	010b      	lsls	r3, r1, #4
 800020a:	1ac0      	subs	r0, r0, r3
 800020c:	4152      	adcs	r2, r2
 800020e:	08c3      	lsrs	r3, r0, #3
 8000210:	428b      	cmp	r3, r1
 8000212:	d301      	bcc.n	8000218 <__udivsi3+0xd8>
 8000214:	00cb      	lsls	r3, r1, #3
 8000216:	1ac0      	subs	r0, r0, r3
 8000218:	4152      	adcs	r2, r2
 800021a:	0883      	lsrs	r3, r0, #2
 800021c:	428b      	cmp	r3, r1
 800021e:	d301      	bcc.n	8000224 <__udivsi3+0xe4>
 8000220:	008b      	lsls	r3, r1, #2
 8000222:	1ac0      	subs	r0, r0, r3
 8000224:	4152      	adcs	r2, r2
 8000226:	0843      	lsrs	r3, r0, #1
 8000228:	428b      	cmp	r3, r1
 800022a:	d301      	bcc.n	8000230 <__udivsi3+0xf0>
 800022c:	004b      	lsls	r3, r1, #1
 800022e:	1ac0      	subs	r0, r0, r3
 8000230:	4152      	adcs	r2, r2
 8000232:	1a41      	subs	r1, r0, r1
 8000234:	d200      	bcs.n	8000238 <__udivsi3+0xf8>
 8000236:	4601      	mov	r1, r0
 8000238:	4152      	adcs	r2, r2
 800023a:	4610      	mov	r0, r2
 800023c:	4770      	bx	lr
 800023e:	e7ff      	b.n	8000240 <__udivsi3+0x100>
 8000240:	b501      	push	{r0, lr}
 8000242:	2000      	movs	r0, #0
 8000244:	f000 f806 	bl	8000254 <__aeabi_idiv0>
 8000248:	bd02      	pop	{r1, pc}
 800024a:	46c0      	nop			; (mov r8, r8)

0800024c <__aeabi_uidivmod>:
 800024c:	2900      	cmp	r1, #0
 800024e:	d0f7      	beq.n	8000240 <__udivsi3+0x100>
 8000250:	e776      	b.n	8000140 <__udivsi3>
 8000252:	4770      	bx	lr

08000254 <__aeabi_idiv0>:
 8000254:	4770      	bx	lr
 8000256:	46c0      	nop			; (mov r8, r8)

08000258 <__aeabi_uldivmod>:
 8000258:	2b00      	cmp	r3, #0
 800025a:	d111      	bne.n	8000280 <__aeabi_uldivmod+0x28>
 800025c:	2a00      	cmp	r2, #0
 800025e:	d10f      	bne.n	8000280 <__aeabi_uldivmod+0x28>
 8000260:	2900      	cmp	r1, #0
 8000262:	d100      	bne.n	8000266 <__aeabi_uldivmod+0xe>
 8000264:	2800      	cmp	r0, #0
 8000266:	d002      	beq.n	800026e <__aeabi_uldivmod+0x16>
 8000268:	2100      	movs	r1, #0
 800026a:	43c9      	mvns	r1, r1
 800026c:	1c08      	adds	r0, r1, #0
 800026e:	b407      	push	{r0, r1, r2}
 8000270:	4802      	ldr	r0, [pc, #8]	; (800027c <__aeabi_uldivmod+0x24>)
 8000272:	a102      	add	r1, pc, #8	; (adr r1, 800027c <__aeabi_uldivmod+0x24>)
 8000274:	1840      	adds	r0, r0, r1
 8000276:	9002      	str	r0, [sp, #8]
 8000278:	bd03      	pop	{r0, r1, pc}
 800027a:	46c0      	nop			; (mov r8, r8)
 800027c:	ffffffd9 	.word	0xffffffd9
 8000280:	b403      	push	{r0, r1}
 8000282:	4668      	mov	r0, sp
 8000284:	b501      	push	{r0, lr}
 8000286:	9802      	ldr	r0, [sp, #8]
 8000288:	f000 f82e 	bl	80002e8 <__udivmoddi4>
 800028c:	9b01      	ldr	r3, [sp, #4]
 800028e:	469e      	mov	lr, r3
 8000290:	b002      	add	sp, #8
 8000292:	bc0c      	pop	{r2, r3}
 8000294:	4770      	bx	lr
 8000296:	46c0      	nop			; (mov r8, r8)

08000298 <__aeabi_lmul>:
 8000298:	b5f0      	push	{r4, r5, r6, r7, lr}
 800029a:	0415      	lsls	r5, r2, #16
 800029c:	0c2d      	lsrs	r5, r5, #16
 800029e:	000f      	movs	r7, r1
 80002a0:	0001      	movs	r1, r0
 80002a2:	002e      	movs	r6, r5
 80002a4:	46c6      	mov	lr, r8
 80002a6:	4684      	mov	ip, r0
 80002a8:	0400      	lsls	r0, r0, #16
 80002aa:	0c14      	lsrs	r4, r2, #16
 80002ac:	0c00      	lsrs	r0, r0, #16
 80002ae:	0c09      	lsrs	r1, r1, #16
 80002b0:	4346      	muls	r6, r0
 80002b2:	434d      	muls	r5, r1
 80002b4:	4360      	muls	r0, r4
 80002b6:	4361      	muls	r1, r4
 80002b8:	1940      	adds	r0, r0, r5
 80002ba:	0c34      	lsrs	r4, r6, #16
 80002bc:	1824      	adds	r4, r4, r0
 80002be:	b500      	push	{lr}
 80002c0:	42a5      	cmp	r5, r4
 80002c2:	d903      	bls.n	80002cc <__aeabi_lmul+0x34>
 80002c4:	2080      	movs	r0, #128	; 0x80
 80002c6:	0240      	lsls	r0, r0, #9
 80002c8:	4680      	mov	r8, r0
 80002ca:	4441      	add	r1, r8
 80002cc:	0c25      	lsrs	r5, r4, #16
 80002ce:	186d      	adds	r5, r5, r1
 80002d0:	4661      	mov	r1, ip
 80002d2:	4359      	muls	r1, r3
 80002d4:	437a      	muls	r2, r7
 80002d6:	0430      	lsls	r0, r6, #16
 80002d8:	1949      	adds	r1, r1, r5
 80002da:	0424      	lsls	r4, r4, #16
 80002dc:	0c00      	lsrs	r0, r0, #16
 80002de:	1820      	adds	r0, r4, r0
 80002e0:	1889      	adds	r1, r1, r2
 80002e2:	bc80      	pop	{r7}
 80002e4:	46b8      	mov	r8, r7
 80002e6:	bdf0      	pop	{r4, r5, r6, r7, pc}

080002e8 <__udivmoddi4>:
 80002e8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80002ea:	4657      	mov	r7, sl
 80002ec:	464e      	mov	r6, r9
 80002ee:	4645      	mov	r5, r8
 80002f0:	46de      	mov	lr, fp
 80002f2:	b5e0      	push	{r5, r6, r7, lr}
 80002f4:	0004      	movs	r4, r0
 80002f6:	000d      	movs	r5, r1
 80002f8:	4692      	mov	sl, r2
 80002fa:	4699      	mov	r9, r3
 80002fc:	b083      	sub	sp, #12
 80002fe:	428b      	cmp	r3, r1
 8000300:	d830      	bhi.n	8000364 <__udivmoddi4+0x7c>
 8000302:	d02d      	beq.n	8000360 <__udivmoddi4+0x78>
 8000304:	4649      	mov	r1, r9
 8000306:	4650      	mov	r0, sl
 8000308:	f000 f8ba 	bl	8000480 <__clzdi2>
 800030c:	0029      	movs	r1, r5
 800030e:	0006      	movs	r6, r0
 8000310:	0020      	movs	r0, r4
 8000312:	f000 f8b5 	bl	8000480 <__clzdi2>
 8000316:	1a33      	subs	r3, r6, r0
 8000318:	4698      	mov	r8, r3
 800031a:	3b20      	subs	r3, #32
 800031c:	469b      	mov	fp, r3
 800031e:	d433      	bmi.n	8000388 <__udivmoddi4+0xa0>
 8000320:	465a      	mov	r2, fp
 8000322:	4653      	mov	r3, sl
 8000324:	4093      	lsls	r3, r2
 8000326:	4642      	mov	r2, r8
 8000328:	001f      	movs	r7, r3
 800032a:	4653      	mov	r3, sl
 800032c:	4093      	lsls	r3, r2
 800032e:	001e      	movs	r6, r3
 8000330:	42af      	cmp	r7, r5
 8000332:	d83a      	bhi.n	80003aa <__udivmoddi4+0xc2>
 8000334:	42af      	cmp	r7, r5
 8000336:	d100      	bne.n	800033a <__udivmoddi4+0x52>
 8000338:	e078      	b.n	800042c <__udivmoddi4+0x144>
 800033a:	465b      	mov	r3, fp
 800033c:	1ba4      	subs	r4, r4, r6
 800033e:	41bd      	sbcs	r5, r7
 8000340:	2b00      	cmp	r3, #0
 8000342:	da00      	bge.n	8000346 <__udivmoddi4+0x5e>
 8000344:	e075      	b.n	8000432 <__udivmoddi4+0x14a>
 8000346:	2200      	movs	r2, #0
 8000348:	2300      	movs	r3, #0
 800034a:	9200      	str	r2, [sp, #0]
 800034c:	9301      	str	r3, [sp, #4]
 800034e:	2301      	movs	r3, #1
 8000350:	465a      	mov	r2, fp
 8000352:	4093      	lsls	r3, r2
 8000354:	9301      	str	r3, [sp, #4]
 8000356:	2301      	movs	r3, #1
 8000358:	4642      	mov	r2, r8
 800035a:	4093      	lsls	r3, r2
 800035c:	9300      	str	r3, [sp, #0]
 800035e:	e028      	b.n	80003b2 <__udivmoddi4+0xca>
 8000360:	4282      	cmp	r2, r0
 8000362:	d9cf      	bls.n	8000304 <__udivmoddi4+0x1c>
 8000364:	2200      	movs	r2, #0
 8000366:	2300      	movs	r3, #0
 8000368:	9200      	str	r2, [sp, #0]
 800036a:	9301      	str	r3, [sp, #4]
 800036c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800036e:	2b00      	cmp	r3, #0
 8000370:	d001      	beq.n	8000376 <__udivmoddi4+0x8e>
 8000372:	601c      	str	r4, [r3, #0]
 8000374:	605d      	str	r5, [r3, #4]
 8000376:	9800      	ldr	r0, [sp, #0]
 8000378:	9901      	ldr	r1, [sp, #4]
 800037a:	b003      	add	sp, #12
 800037c:	bcf0      	pop	{r4, r5, r6, r7}
 800037e:	46bb      	mov	fp, r7
 8000380:	46b2      	mov	sl, r6
 8000382:	46a9      	mov	r9, r5
 8000384:	46a0      	mov	r8, r4
 8000386:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000388:	4642      	mov	r2, r8
 800038a:	2320      	movs	r3, #32
 800038c:	1a9b      	subs	r3, r3, r2
 800038e:	4652      	mov	r2, sl
 8000390:	40da      	lsrs	r2, r3
 8000392:	4641      	mov	r1, r8
 8000394:	0013      	movs	r3, r2
 8000396:	464a      	mov	r2, r9
 8000398:	408a      	lsls	r2, r1
 800039a:	0017      	movs	r7, r2
 800039c:	4642      	mov	r2, r8
 800039e:	431f      	orrs	r7, r3
 80003a0:	4653      	mov	r3, sl
 80003a2:	4093      	lsls	r3, r2
 80003a4:	001e      	movs	r6, r3
 80003a6:	42af      	cmp	r7, r5
 80003a8:	d9c4      	bls.n	8000334 <__udivmoddi4+0x4c>
 80003aa:	2200      	movs	r2, #0
 80003ac:	2300      	movs	r3, #0
 80003ae:	9200      	str	r2, [sp, #0]
 80003b0:	9301      	str	r3, [sp, #4]
 80003b2:	4643      	mov	r3, r8
 80003b4:	2b00      	cmp	r3, #0
 80003b6:	d0d9      	beq.n	800036c <__udivmoddi4+0x84>
 80003b8:	07fb      	lsls	r3, r7, #31
 80003ba:	0872      	lsrs	r2, r6, #1
 80003bc:	431a      	orrs	r2, r3
 80003be:	4646      	mov	r6, r8
 80003c0:	087b      	lsrs	r3, r7, #1
 80003c2:	e00e      	b.n	80003e2 <__udivmoddi4+0xfa>
 80003c4:	42ab      	cmp	r3, r5
 80003c6:	d101      	bne.n	80003cc <__udivmoddi4+0xe4>
 80003c8:	42a2      	cmp	r2, r4
 80003ca:	d80c      	bhi.n	80003e6 <__udivmoddi4+0xfe>
 80003cc:	1aa4      	subs	r4, r4, r2
 80003ce:	419d      	sbcs	r5, r3
 80003d0:	2001      	movs	r0, #1
 80003d2:	1924      	adds	r4, r4, r4
 80003d4:	416d      	adcs	r5, r5
 80003d6:	2100      	movs	r1, #0
 80003d8:	3e01      	subs	r6, #1
 80003da:	1824      	adds	r4, r4, r0
 80003dc:	414d      	adcs	r5, r1
 80003de:	2e00      	cmp	r6, #0
 80003e0:	d006      	beq.n	80003f0 <__udivmoddi4+0x108>
 80003e2:	42ab      	cmp	r3, r5
 80003e4:	d9ee      	bls.n	80003c4 <__udivmoddi4+0xdc>
 80003e6:	3e01      	subs	r6, #1
 80003e8:	1924      	adds	r4, r4, r4
 80003ea:	416d      	adcs	r5, r5
 80003ec:	2e00      	cmp	r6, #0
 80003ee:	d1f8      	bne.n	80003e2 <__udivmoddi4+0xfa>
 80003f0:	9800      	ldr	r0, [sp, #0]
 80003f2:	9901      	ldr	r1, [sp, #4]
 80003f4:	465b      	mov	r3, fp
 80003f6:	1900      	adds	r0, r0, r4
 80003f8:	4169      	adcs	r1, r5
 80003fa:	2b00      	cmp	r3, #0
 80003fc:	db24      	blt.n	8000448 <__udivmoddi4+0x160>
 80003fe:	002b      	movs	r3, r5
 8000400:	465a      	mov	r2, fp
 8000402:	4644      	mov	r4, r8
 8000404:	40d3      	lsrs	r3, r2
 8000406:	002a      	movs	r2, r5
 8000408:	40e2      	lsrs	r2, r4
 800040a:	001c      	movs	r4, r3
 800040c:	465b      	mov	r3, fp
 800040e:	0015      	movs	r5, r2
 8000410:	2b00      	cmp	r3, #0
 8000412:	db2a      	blt.n	800046a <__udivmoddi4+0x182>
 8000414:	0026      	movs	r6, r4
 8000416:	409e      	lsls	r6, r3
 8000418:	0033      	movs	r3, r6
 800041a:	0026      	movs	r6, r4
 800041c:	4647      	mov	r7, r8
 800041e:	40be      	lsls	r6, r7
 8000420:	0032      	movs	r2, r6
 8000422:	1a80      	subs	r0, r0, r2
 8000424:	4199      	sbcs	r1, r3
 8000426:	9000      	str	r0, [sp, #0]
 8000428:	9101      	str	r1, [sp, #4]
 800042a:	e79f      	b.n	800036c <__udivmoddi4+0x84>
 800042c:	42a3      	cmp	r3, r4
 800042e:	d8bc      	bhi.n	80003aa <__udivmoddi4+0xc2>
 8000430:	e783      	b.n	800033a <__udivmoddi4+0x52>
 8000432:	4642      	mov	r2, r8
 8000434:	2320      	movs	r3, #32
 8000436:	2100      	movs	r1, #0
 8000438:	1a9b      	subs	r3, r3, r2
 800043a:	2200      	movs	r2, #0
 800043c:	9100      	str	r1, [sp, #0]
 800043e:	9201      	str	r2, [sp, #4]
 8000440:	2201      	movs	r2, #1
 8000442:	40da      	lsrs	r2, r3
 8000444:	9201      	str	r2, [sp, #4]
 8000446:	e786      	b.n	8000356 <__udivmoddi4+0x6e>
 8000448:	4642      	mov	r2, r8
 800044a:	2320      	movs	r3, #32
 800044c:	1a9b      	subs	r3, r3, r2
 800044e:	002a      	movs	r2, r5
 8000450:	4646      	mov	r6, r8
 8000452:	409a      	lsls	r2, r3
 8000454:	0023      	movs	r3, r4
 8000456:	40f3      	lsrs	r3, r6
 8000458:	4644      	mov	r4, r8
 800045a:	4313      	orrs	r3, r2
 800045c:	002a      	movs	r2, r5
 800045e:	40e2      	lsrs	r2, r4
 8000460:	001c      	movs	r4, r3
 8000462:	465b      	mov	r3, fp
 8000464:	0015      	movs	r5, r2
 8000466:	2b00      	cmp	r3, #0
 8000468:	dad4      	bge.n	8000414 <__udivmoddi4+0x12c>
 800046a:	4642      	mov	r2, r8
 800046c:	002f      	movs	r7, r5
 800046e:	2320      	movs	r3, #32
 8000470:	0026      	movs	r6, r4
 8000472:	4097      	lsls	r7, r2
 8000474:	1a9b      	subs	r3, r3, r2
 8000476:	40de      	lsrs	r6, r3
 8000478:	003b      	movs	r3, r7
 800047a:	4333      	orrs	r3, r6
 800047c:	e7cd      	b.n	800041a <__udivmoddi4+0x132>
 800047e:	46c0      	nop			; (mov r8, r8)

08000480 <__clzdi2>:
 8000480:	b510      	push	{r4, lr}
 8000482:	2900      	cmp	r1, #0
 8000484:	d103      	bne.n	800048e <__clzdi2+0xe>
 8000486:	f000 f807 	bl	8000498 <__clzsi2>
 800048a:	3020      	adds	r0, #32
 800048c:	e002      	b.n	8000494 <__clzdi2+0x14>
 800048e:	1c08      	adds	r0, r1, #0
 8000490:	f000 f802 	bl	8000498 <__clzsi2>
 8000494:	bd10      	pop	{r4, pc}
 8000496:	46c0      	nop			; (mov r8, r8)

08000498 <__clzsi2>:
 8000498:	211c      	movs	r1, #28
 800049a:	2301      	movs	r3, #1
 800049c:	041b      	lsls	r3, r3, #16
 800049e:	4298      	cmp	r0, r3
 80004a0:	d301      	bcc.n	80004a6 <__clzsi2+0xe>
 80004a2:	0c00      	lsrs	r0, r0, #16
 80004a4:	3910      	subs	r1, #16
 80004a6:	0a1b      	lsrs	r3, r3, #8
 80004a8:	4298      	cmp	r0, r3
 80004aa:	d301      	bcc.n	80004b0 <__clzsi2+0x18>
 80004ac:	0a00      	lsrs	r0, r0, #8
 80004ae:	3908      	subs	r1, #8
 80004b0:	091b      	lsrs	r3, r3, #4
 80004b2:	4298      	cmp	r0, r3
 80004b4:	d301      	bcc.n	80004ba <__clzsi2+0x22>
 80004b6:	0900      	lsrs	r0, r0, #4
 80004b8:	3904      	subs	r1, #4
 80004ba:	a202      	add	r2, pc, #8	; (adr r2, 80004c4 <__clzsi2+0x2c>)
 80004bc:	5c10      	ldrb	r0, [r2, r0]
 80004be:	1840      	adds	r0, r0, r1
 80004c0:	4770      	bx	lr
 80004c2:	46c0      	nop			; (mov r8, r8)
 80004c4:	02020304 	.word	0x02020304
 80004c8:	01010101 	.word	0x01010101
	...

080004d4 <HAL_UART_RxCpltCallback>:
	"test-mqtt-stm32-ec200",
	"inQSolHhWx8lX0xj",
};

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
 80004d4:	b580      	push	{r7, lr}
 80004d6:	b082      	sub	sp, #8
 80004d8:	af00      	add	r7, sp, #0
 80004da:	6078      	str	r0, [r7, #4]
//	m_rx_buff.data[m_rx_buff.index] = data ;
//	m_rx_buff.index++;

	RingBuffer_Push(&Rx_Buffer, data);
 80004dc:	4b08      	ldr	r3, [pc, #32]	; (8000500 <HAL_UART_RxCpltCallback+0x2c>)
 80004de:	781a      	ldrb	r2, [r3, #0]
 80004e0:	4b08      	ldr	r3, [pc, #32]	; (8000504 <HAL_UART_RxCpltCallback+0x30>)
 80004e2:	0011      	movs	r1, r2
 80004e4:	0018      	movs	r0, r3
 80004e6:	f001 fec9 	bl	800227c <RingBuffer_Push>
	HAL_UART_Receive_IT(&huart1, &data, 1);
 80004ea:	4905      	ldr	r1, [pc, #20]	; (8000500 <HAL_UART_RxCpltCallback+0x2c>)
 80004ec:	4b06      	ldr	r3, [pc, #24]	; (8000508 <HAL_UART_RxCpltCallback+0x34>)
 80004ee:	2201      	movs	r2, #1
 80004f0:	0018      	movs	r0, r3
 80004f2:	f003 faf3 	bl	8003adc <HAL_UART_Receive_IT>
}
 80004f6:	46c0      	nop			; (mov r8, r8)
 80004f8:	46bd      	mov	sp, r7
 80004fa:	b002      	add	sp, #8
 80004fc:	bd80      	pop	{r7, pc}
 80004fe:	46c0      	nop			; (mov r8, r8)
 8000500:	200000c0 	.word	0x200000c0
 8000504:	200010d4 	.word	0x200010d4
 8000508:	2000103c 	.word	0x2000103c

0800050c <App_Main>:
static void dns_initialize(void);

void App_Main ()
{
 800050c:	b580      	push	{r7, lr}
 800050e:	af00      	add	r7, sp, #0
	// Note: Sá»­a NOPULL -> PULLUP:  GPIO_InitStruct.Pull = GPIO_PULLUP; de tranh loi nhan NULL truoc khi Power on EC200
	HAL_UART_Receive_IT(&huart1, &data, 1);
 8000510:	490e      	ldr	r1, [pc, #56]	; (800054c <App_Main+0x40>)
 8000512:	4b0f      	ldr	r3, [pc, #60]	; (8000550 <App_Main+0x44>)
 8000514:	2201      	movs	r2, #1
 8000516:	0018      	movs	r0, r3
 8000518:	f003 fae0 	bl	8003adc <HAL_UART_Receive_IT>

 	dns_initialize();
 800051c:	f000 f820 	bl	8000560 <dns_initialize>
	lwip_init();
 8000520:	f008 fbd5 	bl	8008cce <lwip_init>
	MQTT_Client_Init(&cfg);
 8000524:	4b0b      	ldr	r3, [pc, #44]	; (8000554 <App_Main+0x48>)
 8000526:	0018      	movs	r0, r3
 8000528:	f01d f818 	bl	801d55c <MQTT_Client_Init>
	DEBUG_INFO("Application started\r\n");
 800052c:	f01d fce2 	bl	801def4 <sys_get_tick_ms>
 8000530:	0001      	movs	r1, r0
 8000532:	4a09      	ldr	r2, [pc, #36]	; (8000558 <App_Main+0x4c>)
 8000534:	4b09      	ldr	r3, [pc, #36]	; (800055c <App_Main+0x50>)
 8000536:	0018      	movs	r0, r3
 8000538:	f001 fe54 	bl	80021e4 <app_debug_rtt_raw>
	GMS_Hardware_Init();
 800053c:	f000 ff74 	bl	8001428 <GMS_Hardware_Init>
	//UART_SendData(USART1, bf_send, sizeof(bf_send));
	while(1)
	{
		GSM_mnr_task();
 8000540:	f000 ff66 	bl	8001410 <GSM_mnr_task>
		MQTT_Client_Polling_Task(NULL);
 8000544:	2000      	movs	r0, #0
 8000546:	f01d fb3d 	bl	801dbc4 <MQTT_Client_Polling_Task>
		GSM_mnr_task();
 800054a:	e7f9      	b.n	8000540 <App_Main+0x34>
 800054c:	200000c0 	.word	0x200000c0
 8000550:	2000103c 	.word	0x2000103c
 8000554:	20000000 	.word	0x20000000
 8000558:	0801e95c 	.word	0x0801e95c
 800055c:	0801e960 	.word	0x0801e960

08000560 <dns_initialize>:
	}
}

static void dns_initialize(void)
{
 8000560:	b580      	push	{r7, lr}
 8000562:	b082      	sub	sp, #8
 8000564:	af00      	add	r7, sp, #0
    ip_addr_t dns_server_0 = IPADDR4_INIT_BYTES(8, 8, 8, 8);
 8000566:	4b0a      	ldr	r3, [pc, #40]	; (8000590 <dns_initialize+0x30>)
 8000568:	607b      	str	r3, [r7, #4]
    ip_addr_t dns_server_1 = IPADDR4_INIT_BYTES(1, 1, 1, 1);
 800056a:	4b0a      	ldr	r3, [pc, #40]	; (8000594 <dns_initialize+0x34>)
 800056c:	603b      	str	r3, [r7, #0]
    dns_setserver(0, &dns_server_0);
 800056e:	1d3b      	adds	r3, r7, #4
 8000570:	0019      	movs	r1, r3
 8000572:	2000      	movs	r0, #0
 8000574:	f006 ffc4 	bl	8007500 <dns_setserver>
    dns_setserver(1, &dns_server_1);
 8000578:	003b      	movs	r3, r7
 800057a:	0019      	movs	r1, r3
 800057c:	2001      	movs	r0, #1
 800057e:	f006 ffbf 	bl	8007500 <dns_setserver>
    dns_init();
 8000582:	f006 ffb7 	bl	80074f4 <dns_init>
}
 8000586:	46c0      	nop			; (mov r8, r8)
 8000588:	46bd      	mov	sp, r7
 800058a:	b002      	add	sp, #8
 800058c:	bd80      	pop	{r7, pc}
 800058e:	46c0      	nop			; (mov r8, r8)
 8000590:	08080808 	.word	0x08080808
 8000594:	01010101 	.word	0x01010101

08000598 <MX_GPIO_Init>:
        * Output
        * EVENT_OUT
        * EXTI
*/
void MX_GPIO_Init(void)
{
 8000598:	b590      	push	{r4, r7, lr}
 800059a:	b08b      	sub	sp, #44	; 0x2c
 800059c:	af00      	add	r7, sp, #0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800059e:	2414      	movs	r4, #20
 80005a0:	193b      	adds	r3, r7, r4
 80005a2:	0018      	movs	r0, r3
 80005a4:	2314      	movs	r3, #20
 80005a6:	001a      	movs	r2, r3
 80005a8:	2100      	movs	r1, #0
 80005aa:	f01d fd13 	bl	801dfd4 <memset>

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
 80005ae:	4b42      	ldr	r3, [pc, #264]	; (80006b8 <MX_GPIO_Init+0x120>)
 80005b0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80005b2:	4b41      	ldr	r3, [pc, #260]	; (80006b8 <MX_GPIO_Init+0x120>)
 80005b4:	2180      	movs	r1, #128	; 0x80
 80005b6:	430a      	orrs	r2, r1
 80005b8:	62da      	str	r2, [r3, #44]	; 0x2c
 80005ba:	4b3f      	ldr	r3, [pc, #252]	; (80006b8 <MX_GPIO_Init+0x120>)
 80005bc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80005be:	2280      	movs	r2, #128	; 0x80
 80005c0:	4013      	ands	r3, r2
 80005c2:	613b      	str	r3, [r7, #16]
 80005c4:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 80005c6:	4b3c      	ldr	r3, [pc, #240]	; (80006b8 <MX_GPIO_Init+0x120>)
 80005c8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80005ca:	4b3b      	ldr	r3, [pc, #236]	; (80006b8 <MX_GPIO_Init+0x120>)
 80005cc:	2104      	movs	r1, #4
 80005ce:	430a      	orrs	r2, r1
 80005d0:	62da      	str	r2, [r3, #44]	; 0x2c
 80005d2:	4b39      	ldr	r3, [pc, #228]	; (80006b8 <MX_GPIO_Init+0x120>)
 80005d4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80005d6:	2204      	movs	r2, #4
 80005d8:	4013      	ands	r3, r2
 80005da:	60fb      	str	r3, [r7, #12]
 80005dc:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80005de:	4b36      	ldr	r3, [pc, #216]	; (80006b8 <MX_GPIO_Init+0x120>)
 80005e0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80005e2:	4b35      	ldr	r3, [pc, #212]	; (80006b8 <MX_GPIO_Init+0x120>)
 80005e4:	2101      	movs	r1, #1
 80005e6:	430a      	orrs	r2, r1
 80005e8:	62da      	str	r2, [r3, #44]	; 0x2c
 80005ea:	4b33      	ldr	r3, [pc, #204]	; (80006b8 <MX_GPIO_Init+0x120>)
 80005ec:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80005ee:	2201      	movs	r2, #1
 80005f0:	4013      	ands	r3, r2
 80005f2:	60bb      	str	r3, [r7, #8]
 80005f4:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 80005f6:	4b30      	ldr	r3, [pc, #192]	; (80006b8 <MX_GPIO_Init+0x120>)
 80005f8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80005fa:	4b2f      	ldr	r3, [pc, #188]	; (80006b8 <MX_GPIO_Init+0x120>)
 80005fc:	2102      	movs	r1, #2
 80005fe:	430a      	orrs	r2, r1
 8000600:	62da      	str	r2, [r3, #44]	; 0x2c
 8000602:	4b2d      	ldr	r3, [pc, #180]	; (80006b8 <MX_GPIO_Init+0x120>)
 8000604:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000606:	2202      	movs	r2, #2
 8000608:	4013      	ands	r3, r2
 800060a:	607b      	str	r3, [r7, #4]
 800060c:	687b      	ldr	r3, [r7, #4]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOC, CHARGE_EN_Pin|EN_GSM_Pin, GPIO_PIN_RESET);
 800060e:	4b2b      	ldr	r3, [pc, #172]	; (80006bc <MX_GPIO_Init+0x124>)
 8000610:	2200      	movs	r2, #0
 8000612:	2150      	movs	r1, #80	; 0x50
 8000614:	0018      	movs	r0, r3
 8000616:	f002 fa61 	bl	8002adc <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, GSM_PWKEY_Pin|GSM_EN_Pin, GPIO_PIN_RESET);
 800061a:	2381      	movs	r3, #129	; 0x81
 800061c:	0219      	lsls	r1, r3, #8
 800061e:	23a0      	movs	r3, #160	; 0xa0
 8000620:	05db      	lsls	r3, r3, #23
 8000622:	2200      	movs	r2, #0
 8000624:	0018      	movs	r0, r3
 8000626:	f002 fa59 	bl	8002adc <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GSM_RESET_GPIO_Port, GSM_RESET_Pin, GPIO_PIN_RESET);
 800062a:	2380      	movs	r3, #128	; 0x80
 800062c:	009b      	lsls	r3, r3, #2
 800062e:	4824      	ldr	r0, [pc, #144]	; (80006c0 <MX_GPIO_Init+0x128>)
 8000630:	2200      	movs	r2, #0
 8000632:	0019      	movs	r1, r3
 8000634:	f002 fa52 	bl	8002adc <HAL_GPIO_WritePin>

  /*Configure GPIO pins : PCPin PCPin */
  GPIO_InitStruct.Pin = CHARGE_EN_Pin|EN_GSM_Pin;
 8000638:	193b      	adds	r3, r7, r4
 800063a:	2250      	movs	r2, #80	; 0x50
 800063c:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800063e:	193b      	adds	r3, r7, r4
 8000640:	2201      	movs	r2, #1
 8000642:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000644:	193b      	adds	r3, r7, r4
 8000646:	2200      	movs	r2, #0
 8000648:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800064a:	193b      	adds	r3, r7, r4
 800064c:	2200      	movs	r2, #0
 800064e:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000650:	193b      	adds	r3, r7, r4
 8000652:	4a1a      	ldr	r2, [pc, #104]	; (80006bc <MX_GPIO_Init+0x124>)
 8000654:	0019      	movs	r1, r3
 8000656:	0010      	movs	r0, r2
 8000658:	f002 f8c2 	bl	80027e0 <HAL_GPIO_Init>

  /*Configure GPIO pins : PAPin PAPin */
  GPIO_InitStruct.Pin = GSM_PWKEY_Pin|GSM_EN_Pin;
 800065c:	0021      	movs	r1, r4
 800065e:	187b      	adds	r3, r7, r1
 8000660:	2281      	movs	r2, #129	; 0x81
 8000662:	0212      	lsls	r2, r2, #8
 8000664:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000666:	000c      	movs	r4, r1
 8000668:	193b      	adds	r3, r7, r4
 800066a:	2201      	movs	r2, #1
 800066c:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800066e:	193b      	adds	r3, r7, r4
 8000670:	2200      	movs	r2, #0
 8000672:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000674:	193b      	adds	r3, r7, r4
 8000676:	2200      	movs	r2, #0
 8000678:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800067a:	193a      	adds	r2, r7, r4
 800067c:	23a0      	movs	r3, #160	; 0xa0
 800067e:	05db      	lsls	r3, r3, #23
 8000680:	0011      	movs	r1, r2
 8000682:	0018      	movs	r0, r3
 8000684:	f002 f8ac 	bl	80027e0 <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = GSM_RESET_Pin;
 8000688:	0021      	movs	r1, r4
 800068a:	187b      	adds	r3, r7, r1
 800068c:	2280      	movs	r2, #128	; 0x80
 800068e:	0092      	lsls	r2, r2, #2
 8000690:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000692:	187b      	adds	r3, r7, r1
 8000694:	2201      	movs	r2, #1
 8000696:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000698:	187b      	adds	r3, r7, r1
 800069a:	2200      	movs	r2, #0
 800069c:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800069e:	187b      	adds	r3, r7, r1
 80006a0:	2200      	movs	r2, #0
 80006a2:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(GSM_RESET_GPIO_Port, &GPIO_InitStruct);
 80006a4:	187b      	adds	r3, r7, r1
 80006a6:	4a06      	ldr	r2, [pc, #24]	; (80006c0 <MX_GPIO_Init+0x128>)
 80006a8:	0019      	movs	r1, r3
 80006aa:	0010      	movs	r0, r2
 80006ac:	f002 f898 	bl	80027e0 <HAL_GPIO_Init>

}
 80006b0:	46c0      	nop			; (mov r8, r8)
 80006b2:	46bd      	mov	sp, r7
 80006b4:	b00b      	add	sp, #44	; 0x2c
 80006b6:	bd90      	pop	{r4, r7, pc}
 80006b8:	40021000 	.word	0x40021000
 80006bc:	50000800 	.word	0x50000800
 80006c0:	50000400 	.word	0x50000400

080006c4 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 80006c4:	b580      	push	{r7, lr}
 80006c6:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 80006c8:	f001 fe90 	bl	80023ec <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 80006cc:	f000 f808 	bl	80006e0 <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 80006d0:	f7ff ff62 	bl	8000598 <MX_GPIO_Init>
  MX_USART1_UART_Init();
 80006d4:	f000 f8f0 	bl	80008b8 <MX_USART1_UART_Init>
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
	  App_Main();
 80006d8:	f7ff ff18 	bl	800050c <App_Main>
 80006dc:	e7fc      	b.n	80006d8 <main+0x14>
	...

080006e0 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 80006e0:	b590      	push	{r4, r7, lr}
 80006e2:	b09b      	sub	sp, #108	; 0x6c
 80006e4:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 80006e6:	2434      	movs	r4, #52	; 0x34
 80006e8:	193b      	adds	r3, r7, r4
 80006ea:	0018      	movs	r0, r3
 80006ec:	2334      	movs	r3, #52	; 0x34
 80006ee:	001a      	movs	r2, r3
 80006f0:	2100      	movs	r1, #0
 80006f2:	f01d fc6f 	bl	801dfd4 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 80006f6:	2320      	movs	r3, #32
 80006f8:	18fb      	adds	r3, r7, r3
 80006fa:	0018      	movs	r0, r3
 80006fc:	2314      	movs	r3, #20
 80006fe:	001a      	movs	r2, r3
 8000700:	2100      	movs	r1, #0
 8000702:	f01d fc67 	bl	801dfd4 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8000706:	003b      	movs	r3, r7
 8000708:	0018      	movs	r0, r3
 800070a:	2320      	movs	r3, #32
 800070c:	001a      	movs	r2, r3
 800070e:	2100      	movs	r1, #0
 8000710:	f01d fc60 	bl	801dfd4 <memset>

  /** Configure the main internal regulator output voltage
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8000714:	4b29      	ldr	r3, [pc, #164]	; (80007bc <SystemClock_Config+0xdc>)
 8000716:	681b      	ldr	r3, [r3, #0]
 8000718:	4a29      	ldr	r2, [pc, #164]	; (80007c0 <SystemClock_Config+0xe0>)
 800071a:	401a      	ands	r2, r3
 800071c:	4b27      	ldr	r3, [pc, #156]	; (80007bc <SystemClock_Config+0xdc>)
 800071e:	2180      	movs	r1, #128	; 0x80
 8000720:	0109      	lsls	r1, r1, #4
 8000722:	430a      	orrs	r2, r1
 8000724:	601a      	str	r2, [r3, #0]
  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 8000726:	0021      	movs	r1, r4
 8000728:	187b      	adds	r3, r7, r1
 800072a:	2202      	movs	r2, #2
 800072c:	601a      	str	r2, [r3, #0]
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 800072e:	187b      	adds	r3, r7, r1
 8000730:	2201      	movs	r2, #1
 8000732:	60da      	str	r2, [r3, #12]
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 8000734:	187b      	adds	r3, r7, r1
 8000736:	2210      	movs	r2, #16
 8000738:	611a      	str	r2, [r3, #16]
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800073a:	187b      	adds	r3, r7, r1
 800073c:	2202      	movs	r2, #2
 800073e:	625a      	str	r2, [r3, #36]	; 0x24
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
 8000740:	187b      	adds	r3, r7, r1
 8000742:	2200      	movs	r2, #0
 8000744:	629a      	str	r2, [r3, #40]	; 0x28
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLLMUL_4;
 8000746:	187b      	adds	r3, r7, r1
 8000748:	2280      	movs	r2, #128	; 0x80
 800074a:	02d2      	lsls	r2, r2, #11
 800074c:	62da      	str	r2, [r3, #44]	; 0x2c
  RCC_OscInitStruct.PLL.PLLDIV = RCC_PLLDIV_2;
 800074e:	187b      	adds	r3, r7, r1
 8000750:	2280      	movs	r2, #128	; 0x80
 8000752:	03d2      	lsls	r2, r2, #15
 8000754:	631a      	str	r2, [r3, #48]	; 0x30
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000756:	187b      	adds	r3, r7, r1
 8000758:	0018      	movs	r0, r3
 800075a:	f002 f9dd 	bl	8002b18 <HAL_RCC_OscConfig>
 800075e:	1e03      	subs	r3, r0, #0
 8000760:	d001      	beq.n	8000766 <SystemClock_Config+0x86>
  {
    Error_Handler();
 8000762:	f000 f82f 	bl	80007c4 <Error_Handler>
  }
  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8000766:	2120      	movs	r1, #32
 8000768:	187b      	adds	r3, r7, r1
 800076a:	220f      	movs	r2, #15
 800076c:	601a      	str	r2, [r3, #0]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800076e:	187b      	adds	r3, r7, r1
 8000770:	2203      	movs	r2, #3
 8000772:	605a      	str	r2, [r3, #4]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8000774:	187b      	adds	r3, r7, r1
 8000776:	2200      	movs	r2, #0
 8000778:	609a      	str	r2, [r3, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 800077a:	187b      	adds	r3, r7, r1
 800077c:	2200      	movs	r2, #0
 800077e:	60da      	str	r2, [r3, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8000780:	187b      	adds	r3, r7, r1
 8000782:	2200      	movs	r2, #0
 8000784:	611a      	str	r2, [r3, #16]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 8000786:	187b      	adds	r3, r7, r1
 8000788:	2101      	movs	r1, #1
 800078a:	0018      	movs	r0, r3
 800078c:	f002 fd40 	bl	8003210 <HAL_RCC_ClockConfig>
 8000790:	1e03      	subs	r3, r0, #0
 8000792:	d001      	beq.n	8000798 <SystemClock_Config+0xb8>
  {
    Error_Handler();
 8000794:	f000 f816 	bl	80007c4 <Error_Handler>
  }
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1;
 8000798:	003b      	movs	r3, r7
 800079a:	2201      	movs	r2, #1
 800079c:	601a      	str	r2, [r3, #0]
  PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
 800079e:	003b      	movs	r3, r7
 80007a0:	2200      	movs	r2, #0
 80007a2:	609a      	str	r2, [r3, #8]
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 80007a4:	003b      	movs	r3, r7
 80007a6:	0018      	movs	r0, r3
 80007a8:	f002 ff56 	bl	8003658 <HAL_RCCEx_PeriphCLKConfig>
 80007ac:	1e03      	subs	r3, r0, #0
 80007ae:	d001      	beq.n	80007b4 <SystemClock_Config+0xd4>
  {
    Error_Handler();
 80007b0:	f000 f808 	bl	80007c4 <Error_Handler>
  }
}
 80007b4:	46c0      	nop			; (mov r8, r8)
 80007b6:	46bd      	mov	sp, r7
 80007b8:	b01b      	add	sp, #108	; 0x6c
 80007ba:	bd90      	pop	{r4, r7, pc}
 80007bc:	40007000 	.word	0x40007000
 80007c0:	ffffe7ff 	.word	0xffffe7ff

080007c4 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 80007c4:	b580      	push	{r7, lr}
 80007c6:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80007c8:	b672      	cpsid	i
}
 80007ca:	46c0      	nop			; (mov r8, r8)
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 80007cc:	e7fe      	b.n	80007cc <Error_Handler+0x8>
	...

080007d0 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80007d0:	b580      	push	{r7, lr}
 80007d2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80007d4:	4b07      	ldr	r3, [pc, #28]	; (80007f4 <HAL_MspInit+0x24>)
 80007d6:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80007d8:	4b06      	ldr	r3, [pc, #24]	; (80007f4 <HAL_MspInit+0x24>)
 80007da:	2101      	movs	r1, #1
 80007dc:	430a      	orrs	r2, r1
 80007de:	635a      	str	r2, [r3, #52]	; 0x34
  __HAL_RCC_PWR_CLK_ENABLE();
 80007e0:	4b04      	ldr	r3, [pc, #16]	; (80007f4 <HAL_MspInit+0x24>)
 80007e2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80007e4:	4b03      	ldr	r3, [pc, #12]	; (80007f4 <HAL_MspInit+0x24>)
 80007e6:	2180      	movs	r1, #128	; 0x80
 80007e8:	0549      	lsls	r1, r1, #21
 80007ea:	430a      	orrs	r2, r1
 80007ec:	639a      	str	r2, [r3, #56]	; 0x38
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80007ee:	46c0      	nop			; (mov r8, r8)
 80007f0:	46bd      	mov	sp, r7
 80007f2:	bd80      	pop	{r7, pc}
 80007f4:	40021000 	.word	0x40021000

080007f8 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable Interrupt.
  */
void NMI_Handler(void)
{
 80007f8:	b580      	push	{r7, lr}
 80007fa:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 80007fc:	e7fe      	b.n	80007fc <NMI_Handler+0x4>

080007fe <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 80007fe:	b580      	push	{r7, lr}
 8000800:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8000802:	e7fe      	b.n	8000802 <HardFault_Handler+0x4>

08000804 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 8000804:	b580      	push	{r7, lr}
 8000806:	af00      	add	r7, sp, #0

  /* USER CODE END SVC_IRQn 0 */
  /* USER CODE BEGIN SVC_IRQn 1 */

  /* USER CODE END SVC_IRQn 1 */
}
 8000808:	46c0      	nop			; (mov r8, r8)
 800080a:	46bd      	mov	sp, r7
 800080c:	bd80      	pop	{r7, pc}

0800080e <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 800080e:	b580      	push	{r7, lr}
 8000810:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 8000812:	46c0      	nop			; (mov r8, r8)
 8000814:	46bd      	mov	sp, r7
 8000816:	bd80      	pop	{r7, pc}

08000818 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8000818:	b580      	push	{r7, lr}
 800081a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 800081c:	f001 fe3a 	bl	8002494 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8000820:	46c0      	nop			; (mov r8, r8)
 8000822:	46bd      	mov	sp, r7
 8000824:	bd80      	pop	{r7, pc}
	...

08000828 <USART1_IRQHandler>:

/**
  * @brief This function handles USART1 global interrupt / USART1 wake-up interrupt through EXTI line 25.
  */
void USART1_IRQHandler(void)
{
 8000828:	b580      	push	{r7, lr}
 800082a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN USART1_IRQn 0 */
	/* Check RXNE flag value in ISR register */

  /* USER CODE END USART1_IRQn 0 */
  HAL_UART_IRQHandler(&huart1);
 800082c:	4b03      	ldr	r3, [pc, #12]	; (800083c <USART1_IRQHandler+0x14>)
 800082e:	0018      	movs	r0, r3
 8000830:	f003 f9bc 	bl	8003bac <HAL_UART_IRQHandler>
  /* USER CODE BEGIN USART1_IRQn 1 */

  /* USER CODE END USART1_IRQn 1 */
}
 8000834:	46c0      	nop			; (mov r8, r8)
 8000836:	46bd      	mov	sp, r7
 8000838:	bd80      	pop	{r7, pc}
 800083a:	46c0      	nop			; (mov r8, r8)
 800083c:	2000103c 	.word	0x2000103c

08000840 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 8000840:	b580      	push	{r7, lr}
 8000842:	b086      	sub	sp, #24
 8000844:	af00      	add	r7, sp, #0
 8000846:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8000848:	4a13      	ldr	r2, [pc, #76]	; (8000898 <_sbrk+0x58>)
 800084a:	4b14      	ldr	r3, [pc, #80]	; (800089c <_sbrk+0x5c>)
 800084c:	1ad3      	subs	r3, r2, r3
 800084e:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 8000850:	697b      	ldr	r3, [r7, #20]
 8000852:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8000854:	4b12      	ldr	r3, [pc, #72]	; (80008a0 <_sbrk+0x60>)
 8000856:	681b      	ldr	r3, [r3, #0]
 8000858:	2b00      	cmp	r3, #0
 800085a:	d102      	bne.n	8000862 <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 800085c:	4b10      	ldr	r3, [pc, #64]	; (80008a0 <_sbrk+0x60>)
 800085e:	4a11      	ldr	r2, [pc, #68]	; (80008a4 <_sbrk+0x64>)
 8000860:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 8000862:	4b0f      	ldr	r3, [pc, #60]	; (80008a0 <_sbrk+0x60>)
 8000864:	681a      	ldr	r2, [r3, #0]
 8000866:	687b      	ldr	r3, [r7, #4]
 8000868:	18d3      	adds	r3, r2, r3
 800086a:	693a      	ldr	r2, [r7, #16]
 800086c:	429a      	cmp	r2, r3
 800086e:	d205      	bcs.n	800087c <_sbrk+0x3c>
  {
    errno = ENOMEM;
 8000870:	4b0d      	ldr	r3, [pc, #52]	; (80008a8 <_sbrk+0x68>)
 8000872:	220c      	movs	r2, #12
 8000874:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 8000876:	2301      	movs	r3, #1
 8000878:	425b      	negs	r3, r3
 800087a:	e009      	b.n	8000890 <_sbrk+0x50>
  }

  prev_heap_end = __sbrk_heap_end;
 800087c:	4b08      	ldr	r3, [pc, #32]	; (80008a0 <_sbrk+0x60>)
 800087e:	681b      	ldr	r3, [r3, #0]
 8000880:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 8000882:	4b07      	ldr	r3, [pc, #28]	; (80008a0 <_sbrk+0x60>)
 8000884:	681a      	ldr	r2, [r3, #0]
 8000886:	687b      	ldr	r3, [r7, #4]
 8000888:	18d2      	adds	r2, r2, r3
 800088a:	4b05      	ldr	r3, [pc, #20]	; (80008a0 <_sbrk+0x60>)
 800088c:	601a      	str	r2, [r3, #0]

  return (void *)prev_heap_end;
 800088e:	68fb      	ldr	r3, [r7, #12]
}
 8000890:	0018      	movs	r0, r3
 8000892:	46bd      	mov	sp, r7
 8000894:	b006      	add	sp, #24
 8000896:	bd80      	pop	{r7, pc}
 8000898:	20005000 	.word	0x20005000
 800089c:	00000400 	.word	0x00000400
 80008a0:	200000c4 	.word	0x200000c4
 80008a4:	20003a88 	.word	0x20003a88
 80008a8:	20003a74 	.word	0x20003a74

080008ac <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 80008ac:	b580      	push	{r7, lr}
 80008ae:	af00      	add	r7, sp, #0
  /* Configure the Vector Table location add offset address ------------------*/
#if defined (USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 80008b0:	46c0      	nop			; (mov r8, r8)
 80008b2:	46bd      	mov	sp, r7
 80008b4:	bd80      	pop	{r7, pc}
	...

080008b8 <MX_USART1_UART_Init>:
UART_HandleTypeDef huart1;

/* USART1 init function */

void MX_USART1_UART_Init(void)
{
 80008b8:	b580      	push	{r7, lr}
 80008ba:	af00      	add	r7, sp, #0
  /* USER CODE END USART1_Init 0 */

  /* USER CODE BEGIN USART1_Init 1 */

  /* USER CODE END USART1_Init 1 */
  huart1.Instance = USART1;
 80008bc:	4b14      	ldr	r3, [pc, #80]	; (8000910 <MX_USART1_UART_Init+0x58>)
 80008be:	4a15      	ldr	r2, [pc, #84]	; (8000914 <MX_USART1_UART_Init+0x5c>)
 80008c0:	601a      	str	r2, [r3, #0]
  huart1.Init.BaudRate = 115200;
 80008c2:	4b13      	ldr	r3, [pc, #76]	; (8000910 <MX_USART1_UART_Init+0x58>)
 80008c4:	22e1      	movs	r2, #225	; 0xe1
 80008c6:	0252      	lsls	r2, r2, #9
 80008c8:	605a      	str	r2, [r3, #4]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 80008ca:	4b11      	ldr	r3, [pc, #68]	; (8000910 <MX_USART1_UART_Init+0x58>)
 80008cc:	2200      	movs	r2, #0
 80008ce:	609a      	str	r2, [r3, #8]
  huart1.Init.StopBits = UART_STOPBITS_1;
 80008d0:	4b0f      	ldr	r3, [pc, #60]	; (8000910 <MX_USART1_UART_Init+0x58>)
 80008d2:	2200      	movs	r2, #0
 80008d4:	60da      	str	r2, [r3, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
 80008d6:	4b0e      	ldr	r3, [pc, #56]	; (8000910 <MX_USART1_UART_Init+0x58>)
 80008d8:	2200      	movs	r2, #0
 80008da:	611a      	str	r2, [r3, #16]
  huart1.Init.Mode = UART_MODE_TX_RX;
 80008dc:	4b0c      	ldr	r3, [pc, #48]	; (8000910 <MX_USART1_UART_Init+0x58>)
 80008de:	220c      	movs	r2, #12
 80008e0:	615a      	str	r2, [r3, #20]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 80008e2:	4b0b      	ldr	r3, [pc, #44]	; (8000910 <MX_USART1_UART_Init+0x58>)
 80008e4:	2200      	movs	r2, #0
 80008e6:	619a      	str	r2, [r3, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 80008e8:	4b09      	ldr	r3, [pc, #36]	; (8000910 <MX_USART1_UART_Init+0x58>)
 80008ea:	2200      	movs	r2, #0
 80008ec:	61da      	str	r2, [r3, #28]
  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 80008ee:	4b08      	ldr	r3, [pc, #32]	; (8000910 <MX_USART1_UART_Init+0x58>)
 80008f0:	2200      	movs	r2, #0
 80008f2:	621a      	str	r2, [r3, #32]
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 80008f4:	4b06      	ldr	r3, [pc, #24]	; (8000910 <MX_USART1_UART_Init+0x58>)
 80008f6:	2200      	movs	r2, #0
 80008f8:	625a      	str	r2, [r3, #36]	; 0x24
  if (HAL_UART_Init(&huart1) != HAL_OK)
 80008fa:	4b05      	ldr	r3, [pc, #20]	; (8000910 <MX_USART1_UART_Init+0x58>)
 80008fc:	0018      	movs	r0, r3
 80008fe:	f002 fff1 	bl	80038e4 <HAL_UART_Init>
 8000902:	1e03      	subs	r3, r0, #0
 8000904:	d001      	beq.n	800090a <MX_USART1_UART_Init+0x52>
  {
    Error_Handler();
 8000906:	f7ff ff5d 	bl	80007c4 <Error_Handler>
  }
  /* USER CODE BEGIN USART1_Init 2 */

  /* USER CODE END USART1_Init 2 */

}
 800090a:	46c0      	nop			; (mov r8, r8)
 800090c:	46bd      	mov	sp, r7
 800090e:	bd80      	pop	{r7, pc}
 8000910:	2000103c 	.word	0x2000103c
 8000914:	40013800 	.word	0x40013800

08000918 <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 8000918:	b590      	push	{r4, r7, lr}
 800091a:	b089      	sub	sp, #36	; 0x24
 800091c:	af00      	add	r7, sp, #0
 800091e:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000920:	240c      	movs	r4, #12
 8000922:	193b      	adds	r3, r7, r4
 8000924:	0018      	movs	r0, r3
 8000926:	2314      	movs	r3, #20
 8000928:	001a      	movs	r2, r3
 800092a:	2100      	movs	r1, #0
 800092c:	f01d fb52 	bl	801dfd4 <memset>
  if(uartHandle->Instance==USART1)
 8000930:	687b      	ldr	r3, [r7, #4]
 8000932:	681b      	ldr	r3, [r3, #0]
 8000934:	4a1c      	ldr	r2, [pc, #112]	; (80009a8 <HAL_UART_MspInit+0x90>)
 8000936:	4293      	cmp	r3, r2
 8000938:	d132      	bne.n	80009a0 <HAL_UART_MspInit+0x88>
  {
  /* USER CODE BEGIN USART1_MspInit 0 */

  /* USER CODE END USART1_MspInit 0 */
    /* USART1 clock enable */
    __HAL_RCC_USART1_CLK_ENABLE();
 800093a:	4b1c      	ldr	r3, [pc, #112]	; (80009ac <HAL_UART_MspInit+0x94>)
 800093c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800093e:	4b1b      	ldr	r3, [pc, #108]	; (80009ac <HAL_UART_MspInit+0x94>)
 8000940:	2180      	movs	r1, #128	; 0x80
 8000942:	01c9      	lsls	r1, r1, #7
 8000944:	430a      	orrs	r2, r1
 8000946:	635a      	str	r2, [r3, #52]	; 0x34

    __HAL_RCC_GPIOA_CLK_ENABLE();
 8000948:	4b18      	ldr	r3, [pc, #96]	; (80009ac <HAL_UART_MspInit+0x94>)
 800094a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800094c:	4b17      	ldr	r3, [pc, #92]	; (80009ac <HAL_UART_MspInit+0x94>)
 800094e:	2101      	movs	r1, #1
 8000950:	430a      	orrs	r2, r1
 8000952:	62da      	str	r2, [r3, #44]	; 0x2c
 8000954:	4b15      	ldr	r3, [pc, #84]	; (80009ac <HAL_UART_MspInit+0x94>)
 8000956:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000958:	2201      	movs	r2, #1
 800095a:	4013      	ands	r3, r2
 800095c:	60bb      	str	r3, [r7, #8]
 800095e:	68bb      	ldr	r3, [r7, #8]
    /**USART1 GPIO Configuration
    PA9     ------> USART1_TX
    PA10     ------> USART1_RX
    */
    GPIO_InitStruct.Pin = MCU_TX0_Pin|MCU_RX0_Pin;
 8000960:	193b      	adds	r3, r7, r4
 8000962:	22c0      	movs	r2, #192	; 0xc0
 8000964:	00d2      	lsls	r2, r2, #3
 8000966:	601a      	str	r2, [r3, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000968:	0021      	movs	r1, r4
 800096a:	187b      	adds	r3, r7, r1
 800096c:	2202      	movs	r2, #2
 800096e:	605a      	str	r2, [r3, #4]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000970:	187b      	adds	r3, r7, r1
 8000972:	2200      	movs	r2, #0
 8000974:	609a      	str	r2, [r3, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000976:	187b      	adds	r3, r7, r1
 8000978:	2203      	movs	r2, #3
 800097a:	60da      	str	r2, [r3, #12]
    GPIO_InitStruct.Alternate = GPIO_AF4_USART1;
 800097c:	187b      	adds	r3, r7, r1
 800097e:	2204      	movs	r2, #4
 8000980:	611a      	str	r2, [r3, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000982:	187a      	adds	r2, r7, r1
 8000984:	23a0      	movs	r3, #160	; 0xa0
 8000986:	05db      	lsls	r3, r3, #23
 8000988:	0011      	movs	r1, r2
 800098a:	0018      	movs	r0, r3
 800098c:	f001 ff28 	bl	80027e0 <HAL_GPIO_Init>

    /* USART1 interrupt Init */
    HAL_NVIC_SetPriority(USART1_IRQn, 1, 0);
 8000990:	2200      	movs	r2, #0
 8000992:	2101      	movs	r1, #1
 8000994:	201b      	movs	r0, #27
 8000996:	f001 fe69 	bl	800266c <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART1_IRQn);
 800099a:	201b      	movs	r0, #27
 800099c:	f001 fe7b 	bl	8002696 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USART1_MspInit 1 */

  /* USER CODE END USART1_MspInit 1 */
  }
}
 80009a0:	46c0      	nop			; (mov r8, r8)
 80009a2:	46bd      	mov	sp, r7
 80009a4:	b009      	add	sp, #36	; 0x24
 80009a6:	bd90      	pop	{r4, r7, pc}
 80009a8:	40013800 	.word	0x40013800
 80009ac:	40021000 	.word	0x40021000

080009b0 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
   ldr   r0, =_estack
 80009b0:	480d      	ldr	r0, [pc, #52]	; (80009e8 <LoopForever+0x2>)
   mov   sp, r0          /* set stack pointer */
 80009b2:	4685      	mov	sp, r0

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 80009b4:	480d      	ldr	r0, [pc, #52]	; (80009ec <LoopForever+0x6>)
  ldr r1, =_edata
 80009b6:	490e      	ldr	r1, [pc, #56]	; (80009f0 <LoopForever+0xa>)
  ldr r2, =_sidata
 80009b8:	4a0e      	ldr	r2, [pc, #56]	; (80009f4 <LoopForever+0xe>)
  movs r3, #0
 80009ba:	2300      	movs	r3, #0
  b LoopCopyDataInit
 80009bc:	e002      	b.n	80009c4 <LoopCopyDataInit>

080009be <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 80009be:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 80009c0:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 80009c2:	3304      	adds	r3, #4

080009c4 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 80009c4:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 80009c6:	428c      	cmp	r4, r1
  bcc CopyDataInit
 80009c8:	d3f9      	bcc.n	80009be <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 80009ca:	4a0b      	ldr	r2, [pc, #44]	; (80009f8 <LoopForever+0x12>)
  ldr r4, =_ebss
 80009cc:	4c0b      	ldr	r4, [pc, #44]	; (80009fc <LoopForever+0x16>)
  movs r3, #0
 80009ce:	2300      	movs	r3, #0
  b LoopFillZerobss
 80009d0:	e001      	b.n	80009d6 <LoopFillZerobss>

080009d2 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 80009d2:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 80009d4:	3204      	adds	r2, #4

080009d6 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 80009d6:	42a2      	cmp	r2, r4
  bcc FillZerobss
 80009d8:	d3fb      	bcc.n	80009d2 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit
 80009da:	f7ff ff67 	bl	80008ac <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 80009de:	f01d faa1 	bl	801df24 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 80009e2:	f7ff fe6f 	bl	80006c4 <main>

080009e6 <LoopForever>:

LoopForever:
    b LoopForever
 80009e6:	e7fe      	b.n	80009e6 <LoopForever>
   ldr   r0, =_estack
 80009e8:	20005000 	.word	0x20005000
  ldr r0, =_sdata
 80009ec:	20000000 	.word	0x20000000
  ldr r1, =_edata
 80009f0:	200000a4 	.word	0x200000a4
  ldr r2, =_sidata
 80009f4:	0802422c 	.word	0x0802422c
  ldr r2, =_sbss
 80009f8:	200000a4 	.word	0x200000a4
  ldr r4, =_ebss
 80009fc:	20003a84 	.word	0x20003a84

08000a00 <ADC1_COMP_IRQHandler>:
 * @retval : None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8000a00:	e7fe      	b.n	8000a00 <ADC1_COMP_IRQHandler>
	...

08000a04 <__NVIC_SystemReset>:
/**
  \brief   System Reset
  \details Initiates a system reset request to reset the MCU.
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
 8000a04:	b580      	push	{r7, lr}
 8000a06:	af00      	add	r7, sp, #0
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8000a08:	f3bf 8f4f 	dsb	sy
}
 8000a0c:	46c0      	nop			; (mov r8, r8)
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8000a0e:	4b04      	ldr	r3, [pc, #16]	; (8000a20 <__NVIC_SystemReset+0x1c>)
 8000a10:	4a04      	ldr	r2, [pc, #16]	; (8000a24 <__NVIC_SystemReset+0x20>)
 8000a12:	60da      	str	r2, [r3, #12]
  __ASM volatile ("dsb 0xF":::"memory");
 8000a14:	f3bf 8f4f 	dsb	sy
}
 8000a18:	46c0      	nop			; (mov r8, r8)
                 SCB_AIRCR_SYSRESETREQ_Msk);
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 8000a1a:	46c0      	nop			; (mov r8, r8)
 8000a1c:	e7fd      	b.n	8000a1a <__NVIC_SystemReset+0x16>
 8000a1e:	46c0      	nop			; (mov r8, r8)
 8000a20:	e000ed00 	.word	0xe000ed00
 8000a24:	05fa0004 	.word	0x05fa0004

08000a28 <GSM_Config_Module>:
    {"ATD*99***1#\r\n", "CONNECT", "", "", "", 1000, 10, open_ppp_stack}, // Open ppp stack
    
};

void GSM_Config_Module (GSM_Response_Event_TypDef event, void *Resp_Buffer)
{
 8000a28:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000a2a:	b089      	sub	sp, #36	; 0x24
 8000a2c:	af04      	add	r7, sp, #16
 8000a2e:	0002      	movs	r2, r0
 8000a30:	6039      	str	r1, [r7, #0]
 8000a32:	1dfb      	adds	r3, r7, #7
 8000a34:	701a      	strb	r2, [r3, #0]
    uint8_t TableIndex = GSM_Manager.step;
 8000a36:	210f      	movs	r1, #15
 8000a38:	187b      	adds	r3, r7, r1
 8000a3a:	4a36      	ldr	r2, [pc, #216]	; (8000b14 <GSM_Config_Module+0xec>)
 8000a3c:	7852      	ldrb	r2, [r2, #1]
 8000a3e:	701a      	strb	r2, [r3, #0]
    uint8_t TableSize = sizeof(atc_table_config_module)/sizeof(atc_table_config_module[0]);
 8000a40:	200e      	movs	r0, #14
 8000a42:	183b      	adds	r3, r7, r0
 8000a44:	2219      	movs	r2, #25
 8000a46:	701a      	strb	r2, [r3, #0]
    if(TableIndex > TableSize)
 8000a48:	187a      	adds	r2, r7, r1
 8000a4a:	183b      	adds	r3, r7, r0
 8000a4c:	7812      	ldrb	r2, [r2, #0]
 8000a4e:	781b      	ldrb	r3, [r3, #0]
 8000a50:	429a      	cmp	r2, r3
 8000a52:	d85b      	bhi.n	8000b0c <GSM_Config_Module+0xe4>
    {
        return;
    }
    DEBUG_PrintResult_ATC(atc_table_config_module[TableIndex-1].cmd, (event == GSM_EVENT_OK)?"[OK]":"[FAIL]");
 8000a54:	187b      	adds	r3, r7, r1
 8000a56:	781b      	ldrb	r3, [r3, #0]
 8000a58:	1e5a      	subs	r2, r3, #1
 8000a5a:	4b2f      	ldr	r3, [pc, #188]	; (8000b18 <GSM_Config_Module+0xf0>)
 8000a5c:	0152      	lsls	r2, r2, #5
 8000a5e:	58d2      	ldr	r2, [r2, r3]
 8000a60:	1dfb      	adds	r3, r7, #7
 8000a62:	781b      	ldrb	r3, [r3, #0]
 8000a64:	2b00      	cmp	r3, #0
 8000a66:	d101      	bne.n	8000a6c <GSM_Config_Module+0x44>
 8000a68:	4b2c      	ldr	r3, [pc, #176]	; (8000b1c <GSM_Config_Module+0xf4>)
 8000a6a:	e000      	b.n	8000a6e <GSM_Config_Module+0x46>
 8000a6c:	4b2c      	ldr	r3, [pc, #176]	; (8000b20 <GSM_Config_Module+0xf8>)
 8000a6e:	0019      	movs	r1, r3
 8000a70:	0010      	movs	r0, r2
 8000a72:	f001 f9e7 	bl	8001e44 <DEBUG_PrintResult_ATC>
    if(event == GSM_EVENT_OK)
 8000a76:	1dfb      	adds	r3, r7, #7
 8000a78:	781b      	ldrb	r3, [r3, #0]
 8000a7a:	2b00      	cmp	r3, #0
 8000a7c:	d13e      	bne.n	8000afc <GSM_Config_Module+0xd4>
    {
        if(TableIndex < TableSize)
 8000a7e:	210f      	movs	r1, #15
 8000a80:	187a      	adds	r2, r7, r1
 8000a82:	230e      	movs	r3, #14
 8000a84:	18fb      	adds	r3, r7, r3
 8000a86:	7812      	ldrb	r2, [r2, #0]
 8000a88:	781b      	ldrb	r3, [r3, #0]
 8000a8a:	429a      	cmp	r2, r3
 8000a8c:	d215      	bcs.n	8000aba <GSM_Config_Module+0x92>
        {
        	//HAL_Delay(2000);
            GSM_SendCommand_AT(atc_table_config_module[TableIndex]);
 8000a8e:	187b      	adds	r3, r7, r1
 8000a90:	781b      	ldrb	r3, [r3, #0]
 8000a92:	4c21      	ldr	r4, [pc, #132]	; (8000b18 <GSM_Config_Module+0xf0>)
 8000a94:	015b      	lsls	r3, r3, #5
 8000a96:	2110      	movs	r1, #16
 8000a98:	18e2      	adds	r2, r4, r3
 8000a9a:	1851      	adds	r1, r2, r1
 8000a9c:	466a      	mov	r2, sp
 8000a9e:	c961      	ldmia	r1!, {r0, r5, r6}
 8000aa0:	c261      	stmia	r2!, {r0, r5, r6}
 8000aa2:	6809      	ldr	r1, [r1, #0]
 8000aa4:	6011      	str	r1, [r2, #0]
 8000aa6:	5918      	ldr	r0, [r3, r4]
 8000aa8:	18e2      	adds	r2, r4, r3
 8000aaa:	6851      	ldr	r1, [r2, #4]
 8000aac:	18e2      	adds	r2, r4, r3
 8000aae:	6892      	ldr	r2, [r2, #8]
 8000ab0:	18e3      	adds	r3, r4, r3
 8000ab2:	68db      	ldr	r3, [r3, #12]
 8000ab4:	f000 ff4a 	bl	800194c <GSM_SendCommand_AT>
 8000ab8:	e019      	b.n	8000aee <GSM_Config_Module+0xc6>
        }
        else
        {
            // Da Config Module xong
            GSM_Manager.step = 0;
 8000aba:	4b16      	ldr	r3, [pc, #88]	; (8000b14 <GSM_Config_Module+0xec>)
 8000abc:	2200      	movs	r2, #0
 8000abe:	705a      	strb	r2, [r3, #1]
            DEBUG_INFO("Config module DONE.\r\n");
 8000ac0:	f01d fa18 	bl	801def4 <sys_get_tick_ms>
 8000ac4:	0001      	movs	r1, r0
 8000ac6:	4a17      	ldr	r2, [pc, #92]	; (8000b24 <GSM_Config_Module+0xfc>)
 8000ac8:	4b17      	ldr	r3, [pc, #92]	; (8000b28 <GSM_Config_Module+0x100>)
 8000aca:	0018      	movs	r0, r3
 8000acc:	f001 fb8a 	bl	80021e4 <app_debug_rtt_raw>
            GSM_SendCommand_AT(atc_table_open_ppp_stack[0]);
 8000ad0:	4b16      	ldr	r3, [pc, #88]	; (8000b2c <GSM_Config_Module+0x104>)
 8000ad2:	466a      	mov	r2, sp
 8000ad4:	0011      	movs	r1, r2
 8000ad6:	001a      	movs	r2, r3
 8000ad8:	3210      	adds	r2, #16
 8000ada:	ca31      	ldmia	r2!, {r0, r4, r5}
 8000adc:	c131      	stmia	r1!, {r0, r4, r5}
 8000ade:	6812      	ldr	r2, [r2, #0]
 8000ae0:	600a      	str	r2, [r1, #0]
 8000ae2:	6818      	ldr	r0, [r3, #0]
 8000ae4:	6859      	ldr	r1, [r3, #4]
 8000ae6:	689a      	ldr	r2, [r3, #8]
 8000ae8:	68db      	ldr	r3, [r3, #12]
 8000aea:	f000 ff2f 	bl	800194c <GSM_SendCommand_AT>
        }
        GSM_Manager.step++;
 8000aee:	4b09      	ldr	r3, [pc, #36]	; (8000b14 <GSM_Config_Module+0xec>)
 8000af0:	785b      	ldrb	r3, [r3, #1]
 8000af2:	3301      	adds	r3, #1
 8000af4:	b2da      	uxtb	r2, r3
 8000af6:	4b07      	ldr	r3, [pc, #28]	; (8000b14 <GSM_Config_Module+0xec>)
 8000af8:	705a      	strb	r2, [r3, #1]
 8000afa:	e008      	b.n	8000b0e <GSM_Config_Module+0xe6>
    }
    else if(event == GSM_EVENT_TIMEOUT)
 8000afc:	1dfb      	adds	r3, r7, #7
 8000afe:	781b      	ldrb	r3, [r3, #0]
 8000b00:	2b01      	cmp	r3, #1
 8000b02:	d104      	bne.n	8000b0e <GSM_Config_Module+0xe6>
    {
        GSM_Manager_ChangeState(GSM_STATE_RESET);
 8000b04:	2001      	movs	r0, #1
 8000b06:	f000 fbe5 	bl	80012d4 <GSM_Manager_ChangeState>
 8000b0a:	e000      	b.n	8000b0e <GSM_Config_Module+0xe6>
        return;
 8000b0c:	46c0      	nop			; (mov r8, r8)
    }
}
 8000b0e:	46bd      	mov	sp, r7
 8000b10:	b005      	add	sp, #20
 8000b12:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000b14:	200010c0 	.word	0x200010c0
 8000b18:	08023530 	.word	0x08023530
 8000b1c:	0801eb14 	.word	0x0801eb14
 8000b20:	0801eb1c 	.word	0x0801eb1c
 8000b24:	0801e9c4 	.word	0x0801e9c4
 8000b28:	0801eb24 	.word	0x0801eb24
 8000b2c:	08023850 	.word	0x08023850

08000b30 <open_ppp_stack>:
void open_ppp_stack(GSM_Response_Event_TypDef event, void *Resp_Buffer)
{
 8000b30:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000b32:	b089      	sub	sp, #36	; 0x24
 8000b34:	af04      	add	r7, sp, #16
 8000b36:	0002      	movs	r2, r0
 8000b38:	6039      	str	r1, [r7, #0]
 8000b3a:	1dfb      	adds	r3, r7, #7
 8000b3c:	701a      	strb	r2, [r3, #0]
    DEBUG_INFO("Open PPP stack step %d\r\n", GSM_Manager.step);
 8000b3e:	f01d f9d9 	bl	801def4 <sys_get_tick_ms>
 8000b42:	0001      	movs	r1, r0
 8000b44:	4b41      	ldr	r3, [pc, #260]	; (8000c4c <open_ppp_stack+0x11c>)
 8000b46:	785b      	ldrb	r3, [r3, #1]
 8000b48:	4a41      	ldr	r2, [pc, #260]	; (8000c50 <open_ppp_stack+0x120>)
 8000b4a:	4842      	ldr	r0, [pc, #264]	; (8000c54 <open_ppp_stack+0x124>)
 8000b4c:	f001 fb4a 	bl	80021e4 <app_debug_rtt_raw>
    uint8_t TableIndex = GSM_Manager.step;
 8000b50:	210f      	movs	r1, #15
 8000b52:	187b      	adds	r3, r7, r1
 8000b54:	4a3d      	ldr	r2, [pc, #244]	; (8000c4c <open_ppp_stack+0x11c>)
 8000b56:	7852      	ldrb	r2, [r2, #1]
 8000b58:	701a      	strb	r2, [r3, #0]
    uint8_t TableSize = sizeof(atc_table_open_ppp_stack)/sizeof(atc_table_open_ppp_stack[0]);
 8000b5a:	200e      	movs	r0, #14
 8000b5c:	183b      	adds	r3, r7, r0
 8000b5e:	2204      	movs	r2, #4
 8000b60:	701a      	strb	r2, [r3, #0]
    if(TableIndex > TableSize)
 8000b62:	187a      	adds	r2, r7, r1
 8000b64:	183b      	adds	r3, r7, r0
 8000b66:	7812      	ldrb	r2, [r2, #0]
 8000b68:	781b      	ldrb	r3, [r3, #0]
 8000b6a:	429a      	cmp	r2, r3
 8000b6c:	d869      	bhi.n	8000c42 <open_ppp_stack+0x112>
    {
        return;
    }
    DEBUG_PrintResult_ATC(atc_table_open_ppp_stack[TableIndex-1].cmd, (event == GSM_EVENT_OK)?"[OK]":"[FAIL]");
 8000b6e:	187b      	adds	r3, r7, r1
 8000b70:	781b      	ldrb	r3, [r3, #0]
 8000b72:	1e5a      	subs	r2, r3, #1
 8000b74:	4b38      	ldr	r3, [pc, #224]	; (8000c58 <open_ppp_stack+0x128>)
 8000b76:	0152      	lsls	r2, r2, #5
 8000b78:	58d2      	ldr	r2, [r2, r3]
 8000b7a:	1dfb      	adds	r3, r7, #7
 8000b7c:	781b      	ldrb	r3, [r3, #0]
 8000b7e:	2b00      	cmp	r3, #0
 8000b80:	d101      	bne.n	8000b86 <open_ppp_stack+0x56>
 8000b82:	4b36      	ldr	r3, [pc, #216]	; (8000c5c <open_ppp_stack+0x12c>)
 8000b84:	e000      	b.n	8000b88 <open_ppp_stack+0x58>
 8000b86:	4b36      	ldr	r3, [pc, #216]	; (8000c60 <open_ppp_stack+0x130>)
 8000b88:	0019      	movs	r1, r3
 8000b8a:	0010      	movs	r0, r2
 8000b8c:	f001 f95a 	bl	8001e44 <DEBUG_PrintResult_ATC>
    if(event == GSM_EVENT_OK)
 8000b90:	1dfb      	adds	r3, r7, #7
 8000b92:	781b      	ldrb	r3, [r3, #0]
 8000b94:	2b00      	cmp	r3, #0
 8000b96:	d155      	bne.n	8000c44 <open_ppp_stack+0x114>
    {
        if(TableIndex < TableSize)
 8000b98:	210f      	movs	r1, #15
 8000b9a:	187a      	adds	r2, r7, r1
 8000b9c:	230e      	movs	r3, #14
 8000b9e:	18fb      	adds	r3, r7, r3
 8000ba0:	7812      	ldrb	r2, [r2, #0]
 8000ba2:	781b      	ldrb	r3, [r3, #0]
 8000ba4:	429a      	cmp	r2, r3
 8000ba6:	d215      	bcs.n	8000bd4 <open_ppp_stack+0xa4>
        {
            GSM_SendCommand_AT(atc_table_open_ppp_stack[TableIndex]);
 8000ba8:	187b      	adds	r3, r7, r1
 8000baa:	781b      	ldrb	r3, [r3, #0]
 8000bac:	4c2a      	ldr	r4, [pc, #168]	; (8000c58 <open_ppp_stack+0x128>)
 8000bae:	015b      	lsls	r3, r3, #5
 8000bb0:	2110      	movs	r1, #16
 8000bb2:	18e2      	adds	r2, r4, r3
 8000bb4:	1851      	adds	r1, r2, r1
 8000bb6:	466a      	mov	r2, sp
 8000bb8:	c961      	ldmia	r1!, {r0, r5, r6}
 8000bba:	c261      	stmia	r2!, {r0, r5, r6}
 8000bbc:	6809      	ldr	r1, [r1, #0]
 8000bbe:	6011      	str	r1, [r2, #0]
 8000bc0:	5918      	ldr	r0, [r3, r4]
 8000bc2:	18e2      	adds	r2, r4, r3
 8000bc4:	6851      	ldr	r1, [r2, #4]
 8000bc6:	18e2      	adds	r2, r4, r3
 8000bc8:	6892      	ldr	r2, [r2, #8]
 8000bca:	18e3      	adds	r3, r4, r3
 8000bcc:	68db      	ldr	r3, [r3, #12]
 8000bce:	f000 febd 	bl	800194c <GSM_SendCommand_AT>
 8000bd2:	e02f      	b.n	8000c34 <open_ppp_stack+0x104>
        }
        else
        {
            GSM_Manager.mode = GSM_INTERNET_MODE_PPP_STACK;
 8000bd4:	4b1d      	ldr	r3, [pc, #116]	; (8000c4c <open_ppp_stack+0x11c>)
 8000bd6:	2201      	movs	r2, #1
 8000bd8:	709a      	strb	r2, [r3, #2]
            // Da CONNECT PPP thanh cong
            GSM_Manager_ChangeState(GSM_STATE_OK);
 8000bda:	2002      	movs	r0, #2
 8000bdc:	f000 fb7a 	bl	80012d4 <GSM_Manager_ChangeState>

            //Create PPP connection
            m_ppp_control_block = pppos_create(&m_ppp_netif, ppp_output_callback, ppp_link_status_cb, NULL);
 8000be0:	4a20      	ldr	r2, [pc, #128]	; (8000c64 <open_ppp_stack+0x134>)
 8000be2:	4921      	ldr	r1, [pc, #132]	; (8000c68 <open_ppp_stack+0x138>)
 8000be4:	4821      	ldr	r0, [pc, #132]	; (8000c6c <open_ppp_stack+0x13c>)
 8000be6:	2300      	movs	r3, #0
 8000be8:	f01a f848 	bl	801ac7c <pppos_create>
 8000bec:	0002      	movs	r2, r0
 8000bee:	4b20      	ldr	r3, [pc, #128]	; (8000c70 <open_ppp_stack+0x140>)
 8000bf0:	601a      	str	r2, [r3, #0]
            if (m_ppp_control_block == NULL)
 8000bf2:	4b1f      	ldr	r3, [pc, #124]	; (8000c70 <open_ppp_stack+0x140>)
 8000bf4:	681b      	ldr	r3, [r3, #0]
 8000bf6:	2b00      	cmp	r3, #0
 8000bf8:	d109      	bne.n	8000c0e <open_ppp_stack+0xde>
            {
                DEBUG_ERROR("Create PPP interface ERR!\r\n");
 8000bfa:	f01d f97b 	bl	801def4 <sys_get_tick_ms>
 8000bfe:	0001      	movs	r1, r0
 8000c00:	4a13      	ldr	r2, [pc, #76]	; (8000c50 <open_ppp_stack+0x120>)
 8000c02:	4b1c      	ldr	r3, [pc, #112]	; (8000c74 <open_ppp_stack+0x144>)
 8000c04:	0018      	movs	r0, r3
 8000c06:	f001 faed 	bl	80021e4 <app_debug_rtt_raw>
                //assert(0);
                // TODO handle memory error
                NVIC_SystemReset();
 8000c0a:	f7ff fefb 	bl	8000a04 <__NVIC_SystemReset>
            }

            /* Set this interface as default route */
            ppp_set_default(m_ppp_control_block);
 8000c0e:	4b18      	ldr	r3, [pc, #96]	; (8000c70 <open_ppp_stack+0x140>)
 8000c10:	681b      	ldr	r3, [r3, #0]
 8000c12:	6a1b      	ldr	r3, [r3, #32]
 8000c14:	0018      	movs	r0, r3
 8000c16:	f008 ffe5 	bl	8009be4 <netif_set_default>
            //ppp_set_auth(m_ppp_control_block, PPPAUTHTYPE_CHAP, "", "");
            ppp_set_notify_phase_callback(m_ppp_control_block, ppp_notify_phase_cb);
 8000c1a:	4b15      	ldr	r3, [pc, #84]	; (8000c70 <open_ppp_stack+0x140>)
 8000c1c:	681b      	ldr	r3, [r3, #0]
 8000c1e:	4a16      	ldr	r2, [pc, #88]	; (8000c78 <open_ppp_stack+0x148>)
 8000c20:	0011      	movs	r1, r2
 8000c22:	0018      	movs	r0, r3
 8000c24:	f019 fb72 	bl	801a30c <ppp_set_notify_phase_callback>
            ppp_connect(m_ppp_control_block, 0);
 8000c28:	4b11      	ldr	r3, [pc, #68]	; (8000c70 <open_ppp_stack+0x140>)
 8000c2a:	681b      	ldr	r3, [r3, #0]
 8000c2c:	2100      	movs	r1, #0
 8000c2e:	0018      	movs	r0, r3
 8000c30:	f019 fb80 	bl	801a334 <ppp_connect>
        }
        GSM_Manager.step++;
 8000c34:	4b05      	ldr	r3, [pc, #20]	; (8000c4c <open_ppp_stack+0x11c>)
 8000c36:	785b      	ldrb	r3, [r3, #1]
 8000c38:	3301      	adds	r3, #1
 8000c3a:	b2da      	uxtb	r2, r3
 8000c3c:	4b03      	ldr	r3, [pc, #12]	; (8000c4c <open_ppp_stack+0x11c>)
 8000c3e:	705a      	strb	r2, [r3, #1]
 8000c40:	e000      	b.n	8000c44 <open_ppp_stack+0x114>
        return;
 8000c42:	46c0      	nop			; (mov r8, r8)
    }
    else
    {
        // Handle ERROR
    }
}
 8000c44:	46bd      	mov	sp, r7
 8000c46:	b005      	add	sp, #20
 8000c48:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000c4a:	46c0      	nop			; (mov r8, r8)
 8000c4c:	200010c0 	.word	0x200010c0
 8000c50:	0801e9c4 	.word	0x0801e9c4
 8000c54:	0801eb54 	.word	0x0801eb54
 8000c58:	08023850 	.word	0x08023850
 8000c5c:	0801eb14 	.word	0x0801eb14
 8000c60:	0801eb1c 	.word	0x0801eb1c
 8000c64:	08000f85 	.word	0x08000f85
 8000c68:	08000ead 	.word	0x08000ead
 8000c6c:	200000e0 	.word	0x200000e0
 8000c70:	2000011c 	.word	0x2000011c
 8000c74:	0801eb88 	.word	0x0801eb88
 8000c78:	08000d89 	.word	0x08000d89

08000c7c <GSM_GET_IMEI_Buffer>:
void GSM_GET_IMEI_Buffer(GSM_Response_Event_TypDef event, void *Resp_Buffer)
{
 8000c7c:	b580      	push	{r7, lr}
 8000c7e:	b082      	sub	sp, #8
 8000c80:	af00      	add	r7, sp, #0
 8000c82:	0002      	movs	r2, r0
 8000c84:	6039      	str	r1, [r7, #0]
 8000c86:	1dfb      	adds	r3, r7, #7
 8000c88:	701a      	strb	r2, [r3, #0]
    if(event != GSM_EVENT_OK)
 8000c8a:	1dfb      	adds	r3, r7, #7
 8000c8c:	781b      	ldrb	r3, [r3, #0]
 8000c8e:	2b00      	cmp	r3, #0
 8000c90:	d007      	beq.n	8000ca2 <GSM_GET_IMEI_Buffer+0x26>
    {
        GSM_Config_Module(event, &Resp_Buffer);
 8000c92:	003a      	movs	r2, r7
 8000c94:	1dfb      	adds	r3, r7, #7
 8000c96:	781b      	ldrb	r3, [r3, #0]
 8000c98:	0011      	movs	r1, r2
 8000c9a:	0018      	movs	r0, r3
 8000c9c:	f7ff fec4 	bl	8000a28 <GSM_Config_Module>
 8000ca0:	e02e      	b.n	8000d00 <GSM_GET_IMEI_Buffer+0x84>
    }
    else
    {
        if(strlen((char*)GSM_IMEI_Buffer) < 14)
 8000ca2:	4b19      	ldr	r3, [pc, #100]	; (8000d08 <GSM_GET_IMEI_Buffer+0x8c>)
 8000ca4:	0018      	movs	r0, r3
 8000ca6:	f7ff fa39 	bl	800011c <strlen>
 8000caa:	0003      	movs	r3, r0
 8000cac:	2b0d      	cmp	r3, #13
 8000cae:	d820      	bhi.n	8000cf2 <GSM_GET_IMEI_Buffer+0x76>
        {
            GSM_Utilities_Get_IMEI(Resp_Buffer, GSM_IMEI_Buffer, 16);
 8000cb0:	683b      	ldr	r3, [r7, #0]
 8000cb2:	4915      	ldr	r1, [pc, #84]	; (8000d08 <GSM_GET_IMEI_Buffer+0x8c>)
 8000cb4:	2210      	movs	r2, #16
 8000cb6:	0018      	movs	r0, r3
 8000cb8:	f001 f808 	bl	8001ccc <GSM_Utilities_Get_IMEI>
            if(strlen((char*)GSM_IMEI_Buffer) < 15)
 8000cbc:	4b12      	ldr	r3, [pc, #72]	; (8000d08 <GSM_GET_IMEI_Buffer+0x8c>)
 8000cbe:	0018      	movs	r0, r3
 8000cc0:	f7ff fa2c 	bl	800011c <strlen>
 8000cc4:	0003      	movs	r3, r0
 8000cc6:	2b0e      	cmp	r3, #14
 8000cc8:	d80b      	bhi.n	8000ce2 <GSM_GET_IMEI_Buffer+0x66>
            {
                DEBUG_WARN("IMEI's invalid!\r\n");
 8000cca:	f01d f913 	bl	801def4 <sys_get_tick_ms>
 8000cce:	0001      	movs	r1, r0
 8000cd0:	4a0e      	ldr	r2, [pc, #56]	; (8000d0c <GSM_GET_IMEI_Buffer+0x90>)
 8000cd2:	4b0f      	ldr	r3, [pc, #60]	; (8000d10 <GSM_GET_IMEI_Buffer+0x94>)
 8000cd4:	0018      	movs	r0, r3
 8000cd6:	f001 fa85 	bl	80021e4 <app_debug_rtt_raw>
                GSM_Manager_ChangeState(GSM_STATE_RESET); // Cant get GSM imei, maybe gsm module error =>> Restart module
 8000cda:	2001      	movs	r0, #1
 8000cdc:	f000 fafa 	bl	80012d4 <GSM_Manager_ChangeState>
                return;
 8000ce0:	e00e      	b.n	8000d00 <GSM_GET_IMEI_Buffer+0x84>
            }
            else
            {
                DEBUG_INFO("GSM IMEI: %s\r\n", GSM_IMEI_Buffer);
 8000ce2:	f01d f907 	bl	801def4 <sys_get_tick_ms>
 8000ce6:	0001      	movs	r1, r0
 8000ce8:	4b07      	ldr	r3, [pc, #28]	; (8000d08 <GSM_GET_IMEI_Buffer+0x8c>)
 8000cea:	4a08      	ldr	r2, [pc, #32]	; (8000d0c <GSM_GET_IMEI_Buffer+0x90>)
 8000cec:	4809      	ldr	r0, [pc, #36]	; (8000d14 <GSM_GET_IMEI_Buffer+0x98>)
 8000cee:	f001 fa79 	bl	80021e4 <app_debug_rtt_raw>
            }
        }
        GSM_Config_Module(event, &Resp_Buffer);
 8000cf2:	003a      	movs	r2, r7
 8000cf4:	1dfb      	adds	r3, r7, #7
 8000cf6:	781b      	ldrb	r3, [r3, #0]
 8000cf8:	0011      	movs	r1, r2
 8000cfa:	0018      	movs	r0, r3
 8000cfc:	f7ff fe94 	bl	8000a28 <GSM_Config_Module>
    }
}
 8000d00:	46bd      	mov	sp, r7
 8000d02:	b002      	add	sp, #8
 8000d04:	bd80      	pop	{r7, pc}
 8000d06:	46c0      	nop			; (mov r8, r8)
 8000d08:	200000c8 	.word	0x200000c8
 8000d0c:	0801e9c4 	.word	0x0801e9c4
 8000d10:	0801ebc0 	.word	0x0801ebc0
 8000d14:	0801ebec 	.word	0x0801ebec

08000d18 <GSM_GET_Signal_Strength>:
void GSM_GET_Signal_Strength(GSM_Response_Event_TypDef event, void *Resp_Buffer)
{
 8000d18:	b580      	push	{r7, lr}
 8000d1a:	b082      	sub	sp, #8
 8000d1c:	af00      	add	r7, sp, #0
 8000d1e:	0002      	movs	r2, r0
 8000d20:	6039      	str	r1, [r7, #0]
 8000d22:	1dfb      	adds	r3, r7, #7
 8000d24:	701a      	strb	r2, [r3, #0]
    
    if(event != GSM_EVENT_OK)
 8000d26:	1dfb      	adds	r3, r7, #7
 8000d28:	781b      	ldrb	r3, [r3, #0]
 8000d2a:	2b00      	cmp	r3, #0
 8000d2c:	d007      	beq.n	8000d3e <GSM_GET_Signal_Strength+0x26>
    {
        GSM_Config_Module(event, &Resp_Buffer);
 8000d2e:	003a      	movs	r2, r7
 8000d30:	1dfb      	adds	r3, r7, #7
 8000d32:	781b      	ldrb	r3, [r3, #0]
 8000d34:	0011      	movs	r1, r2
 8000d36:	0018      	movs	r0, r3
 8000d38:	f7ff fe76 	bl	8000a28 <GSM_Config_Module>
            gsm_utilities_get_signal_strength_from_buffer(Resp_Buffer, &GSM_Signal_Strength);
            DEBUG_INFO("GSM Signal strength: %d\r\n", GSM_Signal_Strength);
        }
        GSM_Config_Module(event, &Resp_Buffer);
    }
}
 8000d3c:	e019      	b.n	8000d72 <GSM_GET_Signal_Strength+0x5a>
        if(GSM_Signal_Strength == 0)
 8000d3e:	4b0f      	ldr	r3, [pc, #60]	; (8000d7c <GSM_GET_Signal_Strength+0x64>)
 8000d40:	881b      	ldrh	r3, [r3, #0]
 8000d42:	2b00      	cmp	r3, #0
 8000d44:	d10e      	bne.n	8000d64 <GSM_GET_Signal_Strength+0x4c>
            gsm_utilities_get_signal_strength_from_buffer(Resp_Buffer, &GSM_Signal_Strength);
 8000d46:	683b      	ldr	r3, [r7, #0]
 8000d48:	4a0c      	ldr	r2, [pc, #48]	; (8000d7c <GSM_GET_Signal_Strength+0x64>)
 8000d4a:	0011      	movs	r1, r2
 8000d4c:	0018      	movs	r0, r3
 8000d4e:	f001 f801 	bl	8001d54 <gsm_utilities_get_signal_strength_from_buffer>
            DEBUG_INFO("GSM Signal strength: %d\r\n", GSM_Signal_Strength);
 8000d52:	f01d f8cf 	bl	801def4 <sys_get_tick_ms>
 8000d56:	0001      	movs	r1, r0
 8000d58:	4b08      	ldr	r3, [pc, #32]	; (8000d7c <GSM_GET_Signal_Strength+0x64>)
 8000d5a:	881b      	ldrh	r3, [r3, #0]
 8000d5c:	4a08      	ldr	r2, [pc, #32]	; (8000d80 <GSM_GET_Signal_Strength+0x68>)
 8000d5e:	4809      	ldr	r0, [pc, #36]	; (8000d84 <GSM_GET_Signal_Strength+0x6c>)
 8000d60:	f001 fa40 	bl	80021e4 <app_debug_rtt_raw>
        GSM_Config_Module(event, &Resp_Buffer);
 8000d64:	003a      	movs	r2, r7
 8000d66:	1dfb      	adds	r3, r7, #7
 8000d68:	781b      	ldrb	r3, [r3, #0]
 8000d6a:	0011      	movs	r1, r2
 8000d6c:	0018      	movs	r0, r3
 8000d6e:	f7ff fe5b 	bl	8000a28 <GSM_Config_Module>
}
 8000d72:	46c0      	nop			; (mov r8, r8)
 8000d74:	46bd      	mov	sp, r7
 8000d76:	b002      	add	sp, #8
 8000d78:	bd80      	pop	{r7, pc}
 8000d7a:	46c0      	nop			; (mov r8, r8)
 8000d7c:	200000dc 	.word	0x200000dc
 8000d80:	0801e9c4 	.word	0x0801e9c4
 8000d84:	0801ec14 	.word	0x0801ec14

08000d88 <ppp_notify_phase_cb>:
static void ppp_notify_phase_cb(ppp_pcb *pcb, u8_t phase, void *ctx)
{
 8000d88:	b580      	push	{r7, lr}
 8000d8a:	b084      	sub	sp, #16
 8000d8c:	af00      	add	r7, sp, #0
 8000d8e:	60f8      	str	r0, [r7, #12]
 8000d90:	607a      	str	r2, [r7, #4]
 8000d92:	200b      	movs	r0, #11
 8000d94:	183b      	adds	r3, r7, r0
 8000d96:	1c0a      	adds	r2, r1, #0
 8000d98:	701a      	strb	r2, [r3, #0]
    switch (phase)
 8000d9a:	183b      	adds	r3, r7, r0
 8000d9c:	781b      	ldrb	r3, [r3, #0]
 8000d9e:	2b0c      	cmp	r3, #12
 8000da0:	d85b      	bhi.n	8000e5a <ppp_notify_phase_cb+0xd2>
 8000da2:	009a      	lsls	r2, r3, #2
 8000da4:	4b34      	ldr	r3, [pc, #208]	; (8000e78 <ppp_notify_phase_cb+0xf0>)
 8000da6:	18d3      	adds	r3, r2, r3
 8000da8:	681b      	ldr	r3, [r3, #0]
 8000daa:	469f      	mov	pc, r3
    {
    /* Session is down (either permanently or briefly) */
    case PPP_PHASE_DEAD:
        DEBUG_INFO("PPP_PHASE_DEAD\r\n");
 8000dac:	f01d f8a2 	bl	801def4 <sys_get_tick_ms>
 8000db0:	0001      	movs	r1, r0
 8000db2:	4a32      	ldr	r2, [pc, #200]	; (8000e7c <ppp_notify_phase_cb+0xf4>)
 8000db4:	4b32      	ldr	r3, [pc, #200]	; (8000e80 <ppp_notify_phase_cb+0xf8>)
 8000db6:	0018      	movs	r0, r3
 8000db8:	f001 fa14 	bl	80021e4 <app_debug_rtt_raw>
        GSM_Manager.ppp_phase = PPP_PHASE_DEAD;
 8000dbc:	4b31      	ldr	r3, [pc, #196]	; (8000e84 <ppp_notify_phase_cb+0xfc>)
 8000dbe:	2200      	movs	r2, #0
 8000dc0:	70da      	strb	r2, [r3, #3]
        break;
 8000dc2:	e055      	b.n	8000e70 <ppp_notify_phase_cb+0xe8>

    /* We are between two sessions */
    case PPP_PHASE_HOLDOFF:
        DEBUG_INFO("PPP_PHASE_HOLDOFF\r\n");
 8000dc4:	f01d f896 	bl	801def4 <sys_get_tick_ms>
 8000dc8:	0001      	movs	r1, r0
 8000dca:	4a2c      	ldr	r2, [pc, #176]	; (8000e7c <ppp_notify_phase_cb+0xf4>)
 8000dcc:	4b2e      	ldr	r3, [pc, #184]	; (8000e88 <ppp_notify_phase_cb+0x100>)
 8000dce:	0018      	movs	r0, r3
 8000dd0:	f001 fa08 	bl	80021e4 <app_debug_rtt_raw>
        GSM_Manager.ppp_phase = PPP_PHASE_HOLDOFF;
 8000dd4:	4b2b      	ldr	r3, [pc, #172]	; (8000e84 <ppp_notify_phase_cb+0xfc>)
 8000dd6:	2202      	movs	r2, #2
 8000dd8:	70da      	strb	r2, [r3, #3]
        break;
 8000dda:	e049      	b.n	8000e70 <ppp_notify_phase_cb+0xe8>

    /* Session just started */
    case PPP_PHASE_INITIALIZE:
        DEBUG_INFO("PPP_PHASE_INITIALIZE\r\n");
 8000ddc:	f01d f88a 	bl	801def4 <sys_get_tick_ms>
 8000de0:	0001      	movs	r1, r0
 8000de2:	4a26      	ldr	r2, [pc, #152]	; (8000e7c <ppp_notify_phase_cb+0xf4>)
 8000de4:	4b29      	ldr	r3, [pc, #164]	; (8000e8c <ppp_notify_phase_cb+0x104>)
 8000de6:	0018      	movs	r0, r3
 8000de8:	f001 f9fc 	bl	80021e4 <app_debug_rtt_raw>
        GSM_Manager.ppp_phase = PPP_PHASE_INITIALIZE;
 8000dec:	4b25      	ldr	r3, [pc, #148]	; (8000e84 <ppp_notify_phase_cb+0xfc>)
 8000dee:	2203      	movs	r2, #3
 8000df0:	70da      	strb	r2, [r3, #3]
        break;
 8000df2:	e03d      	b.n	8000e70 <ppp_notify_phase_cb+0xe8>

    case PPP_PHASE_NETWORK:
        DEBUG_INFO("PPP_PHASE_NETWORK\r\n");
 8000df4:	f01d f87e 	bl	801def4 <sys_get_tick_ms>
 8000df8:	0001      	movs	r1, r0
 8000dfa:	4a20      	ldr	r2, [pc, #128]	; (8000e7c <ppp_notify_phase_cb+0xf4>)
 8000dfc:	4b24      	ldr	r3, [pc, #144]	; (8000e90 <ppp_notify_phase_cb+0x108>)
 8000dfe:	0018      	movs	r0, r3
 8000e00:	f001 f9f0 	bl	80021e4 <app_debug_rtt_raw>
        break;
 8000e04:	e034      	b.n	8000e70 <ppp_notify_phase_cb+0xe8>

    case PPP_PHASE_ESTABLISH:
        DEBUG_INFO("PPP_PHASE_ESTABLISH\r\n");
 8000e06:	f01d f875 	bl	801def4 <sys_get_tick_ms>
 8000e0a:	0001      	movs	r1, r0
 8000e0c:	4a1b      	ldr	r2, [pc, #108]	; (8000e7c <ppp_notify_phase_cb+0xf4>)
 8000e0e:	4b21      	ldr	r3, [pc, #132]	; (8000e94 <ppp_notify_phase_cb+0x10c>)
 8000e10:	0018      	movs	r0, r3
 8000e12:	f001 f9e7 	bl	80021e4 <app_debug_rtt_raw>
        break;
 8000e16:	e02b      	b.n	8000e70 <ppp_notify_phase_cb+0xe8>

    /* Session is running */
    case PPP_PHASE_RUNNING:
        DEBUG_INFO("PPP_PHASE_RUNNING\r\n");
 8000e18:	f01d f86c 	bl	801def4 <sys_get_tick_ms>
 8000e1c:	0001      	movs	r1, r0
 8000e1e:	4a17      	ldr	r2, [pc, #92]	; (8000e7c <ppp_notify_phase_cb+0xf4>)
 8000e20:	4b1d      	ldr	r3, [pc, #116]	; (8000e98 <ppp_notify_phase_cb+0x110>)
 8000e22:	0018      	movs	r0, r3
 8000e24:	f001 f9de 	bl	80021e4 <app_debug_rtt_raw>
        GSM_Manager.ppp_phase = PPP_PHASE_RUNNING;
 8000e28:	4b16      	ldr	r3, [pc, #88]	; (8000e84 <ppp_notify_phase_cb+0xfc>)
 8000e2a:	220a      	movs	r2, #10
 8000e2c:	70da      	strb	r2, [r3, #3]
        m_ppp_connected = true;
 8000e2e:	4b1b      	ldr	r3, [pc, #108]	; (8000e9c <ppp_notify_phase_cb+0x114>)
 8000e30:	2201      	movs	r2, #1
 8000e32:	701a      	strb	r2, [r3, #0]
        break;
 8000e34:	e01c      	b.n	8000e70 <ppp_notify_phase_cb+0xe8>

    case PPP_PHASE_TERMINATE:
        DEBUG_INFO("PPP_PHASE_TERMINATE\r\n");
 8000e36:	f01d f85d 	bl	801def4 <sys_get_tick_ms>
 8000e3a:	0001      	movs	r1, r0
 8000e3c:	4a0f      	ldr	r2, [pc, #60]	; (8000e7c <ppp_notify_phase_cb+0xf4>)
 8000e3e:	4b18      	ldr	r3, [pc, #96]	; (8000ea0 <ppp_notify_phase_cb+0x118>)
 8000e40:	0018      	movs	r0, r3
 8000e42:	f001 f9cf 	bl	80021e4 <app_debug_rtt_raw>
        break;
 8000e46:	e013      	b.n	8000e70 <ppp_notify_phase_cb+0xe8>

    case PPP_PHASE_DISCONNECT:
        DEBUG_INFO("PPP_PHASE_DISCONNECT\r\n");
 8000e48:	f01d f854 	bl	801def4 <sys_get_tick_ms>
 8000e4c:	0001      	movs	r1, r0
 8000e4e:	4a0b      	ldr	r2, [pc, #44]	; (8000e7c <ppp_notify_phase_cb+0xf4>)
 8000e50:	4b14      	ldr	r3, [pc, #80]	; (8000ea4 <ppp_notify_phase_cb+0x11c>)
 8000e52:	0018      	movs	r0, r3
 8000e54:	f001 f9c6 	bl	80021e4 <app_debug_rtt_raw>
        break;
 8000e58:	e00a      	b.n	8000e70 <ppp_notify_phase_cb+0xe8>

    default:
        DEBUG_INFO("Unknown PPP phase %d\r\n", phase);
 8000e5a:	f01d f84b 	bl	801def4 <sys_get_tick_ms>
 8000e5e:	0001      	movs	r1, r0
 8000e60:	230b      	movs	r3, #11
 8000e62:	18fb      	adds	r3, r7, r3
 8000e64:	781b      	ldrb	r3, [r3, #0]
 8000e66:	4a05      	ldr	r2, [pc, #20]	; (8000e7c <ppp_notify_phase_cb+0xf4>)
 8000e68:	480f      	ldr	r0, [pc, #60]	; (8000ea8 <ppp_notify_phase_cb+0x120>)
 8000e6a:	f001 f9bb 	bl	80021e4 <app_debug_rtt_raw>
        break;
 8000e6e:	46c0      	nop			; (mov r8, r8)
    }
}
 8000e70:	46c0      	nop			; (mov r8, r8)
 8000e72:	46bd      	mov	sp, r7
 8000e74:	b004      	add	sp, #16
 8000e76:	bd80      	pop	{r7, pc}
 8000e78:	080238d0 	.word	0x080238d0
 8000e7c:	0801e9c4 	.word	0x0801e9c4
 8000e80:	0801ec48 	.word	0x0801ec48
 8000e84:	200010c0 	.word	0x200010c0
 8000e88:	0801ec74 	.word	0x0801ec74
 8000e8c:	0801eca4 	.word	0x0801eca4
 8000e90:	0801ecd4 	.word	0x0801ecd4
 8000e94:	0801ed04 	.word	0x0801ed04
 8000e98:	0801ed34 	.word	0x0801ed34
 8000e9c:	20000120 	.word	0x20000120
 8000ea0:	0801ed64 	.word	0x0801ed64
 8000ea4:	0801ed94 	.word	0x0801ed94
 8000ea8:	0801edc4 	.word	0x0801edc4

08000eac <ppp_output_callback>:
static uint32_t ppp_output_callback(ppp_pcb *pcb, u8_t *data, u32_t len, void *ctx)
{
 8000eac:	b580      	push	{r7, lr}
 8000eae:	b084      	sub	sp, #16
 8000eb0:	af00      	add	r7, sp, #0
 8000eb2:	60f8      	str	r0, [r7, #12]
 8000eb4:	60b9      	str	r1, [r7, #8]
 8000eb6:	607a      	str	r2, [r7, #4]
 8000eb8:	603b      	str	r3, [r7, #0]
    GSM_UART_TX( data, len, 1000);
 8000eba:	687b      	ldr	r3, [r7, #4]
 8000ebc:	b29a      	uxth	r2, r3
 8000ebe:	23fa      	movs	r3, #250	; 0xfa
 8000ec0:	009b      	lsls	r3, r3, #2
 8000ec2:	68b9      	ldr	r1, [r7, #8]
 8000ec4:	4803      	ldr	r0, [pc, #12]	; (8000ed4 <ppp_output_callback+0x28>)
 8000ec6:	f002 fd61 	bl	800398c <HAL_UART_Transmit>
    return len;
 8000eca:	687b      	ldr	r3, [r7, #4]
}
 8000ecc:	0018      	movs	r0, r3
 8000ece:	46bd      	mov	sp, r7
 8000ed0:	b004      	add	sp, #16
 8000ed2:	bd80      	pop	{r7, pc}
 8000ed4:	2000103c 	.word	0x2000103c

08000ed8 <gsm_data_layer_get_ppp_control_block>:
void *gsm_data_layer_get_ppp_control_block(void)
{
 8000ed8:	b580      	push	{r7, lr}
 8000eda:	af00      	add	r7, sp, #0
    return m_ppp_control_block;
 8000edc:	4b02      	ldr	r3, [pc, #8]	; (8000ee8 <gsm_data_layer_get_ppp_control_block+0x10>)
 8000ede:	681b      	ldr	r3, [r3, #0]
}
 8000ee0:	0018      	movs	r0, r3
 8000ee2:	46bd      	mov	sp, r7
 8000ee4:	bd80      	pop	{r7, pc}
 8000ee6:	46c0      	nop			; (mov r8, r8)
 8000ee8:	2000011c 	.word	0x2000011c

08000eec <initialize_stnp>:
static void initialize_stnp(void)
{
 8000eec:	b580      	push	{r7, lr}
 8000eee:	af00      	add	r7, sp, #0
    static bool sntp_start = false;
    if (sntp_start == false)
 8000ef0:	4b0f      	ldr	r3, [pc, #60]	; (8000f30 <initialize_stnp+0x44>)
 8000ef2:	781b      	ldrb	r3, [r3, #0]
 8000ef4:	2201      	movs	r2, #1
 8000ef6:	4053      	eors	r3, r2
 8000ef8:	b2db      	uxtb	r3, r3
 8000efa:	2b00      	cmp	r3, #0
 8000efc:	d014      	beq.n	8000f28 <initialize_stnp+0x3c>
    {
        sntp_start = true;
 8000efe:	4b0c      	ldr	r3, [pc, #48]	; (8000f30 <initialize_stnp+0x44>)
 8000f00:	2201      	movs	r2, #1
 8000f02:	701a      	strb	r2, [r3, #0]
        DEBUG_INFO("Initialize stnp\r\n");
 8000f04:	f01c fff6 	bl	801def4 <sys_get_tick_ms>
 8000f08:	0001      	movs	r1, r0
 8000f0a:	4a0a      	ldr	r2, [pc, #40]	; (8000f34 <initialize_stnp+0x48>)
 8000f0c:	4b0a      	ldr	r3, [pc, #40]	; (8000f38 <initialize_stnp+0x4c>)
 8000f0e:	0018      	movs	r0, r3
 8000f10:	f001 f968 	bl	80021e4 <app_debug_rtt_raw>
        sntp_setoperatingmode(SNTP_OPMODE_POLL);
 8000f14:	2000      	movs	r0, #0
 8000f16:	f006 fa27 	bl	8007368 <sntp_setoperatingmode>
        sntp_setservername(0, "pool.ntp.org");
 8000f1a:	4b08      	ldr	r3, [pc, #32]	; (8000f3c <initialize_stnp+0x50>)
 8000f1c:	0019      	movs	r1, r3
 8000f1e:	2000      	movs	r0, #0
 8000f20:	f006 fa54 	bl	80073cc <sntp_setservername>
        sntp_init();
 8000f24:	f006 f9ba 	bl	800729c <sntp_init>
    }
}
 8000f28:	46c0      	nop			; (mov r8, r8)
 8000f2a:	46bd      	mov	sp, r7
 8000f2c:	bd80      	pop	{r7, pc}
 8000f2e:	46c0      	nop			; (mov r8, r8)
 8000f30:	20000121 	.word	0x20000121
 8000f34:	0801e9c4 	.word	0x0801e9c4
 8000f38:	0801edf4 	.word	0x0801edf4
 8000f3c:	0801ee20 	.word	0x0801ee20

08000f40 <lwip_sntp_recv_callback>:

void lwip_sntp_recv_callback(uint32_t time)
{
 8000f40:	b580      	push	{r7, lr}
 8000f42:	b082      	sub	sp, #8
 8000f44:	af00      	add	r7, sp, #0
 8000f46:	6078      	str	r0, [r7, #4]
    if (time == 0)
 8000f48:	687b      	ldr	r3, [r7, #4]
 8000f4a:	2b00      	cmp	r3, #0
 8000f4c:	d108      	bne.n	8000f60 <lwip_sntp_recv_callback+0x20>
    {
        DEBUG_WARN("NTP: Error, server not responding or bad response\r\n");
 8000f4e:	f01c ffd1 	bl	801def4 <sys_get_tick_ms>
 8000f52:	0001      	movs	r1, r0
 8000f54:	4a08      	ldr	r2, [pc, #32]	; (8000f78 <lwip_sntp_recv_callback+0x38>)
 8000f56:	4b09      	ldr	r3, [pc, #36]	; (8000f7c <lwip_sntp_recv_callback+0x3c>)
 8000f58:	0018      	movs	r0, r3
 8000f5a:	f001 f943 	bl	80021e4 <app_debug_rtt_raw>
    }
    else
    {
        DEBUG_INFO("NTP: %u seconds elapsed since 1.1.1970\r\n", time);
    }
}
 8000f5e:	e007      	b.n	8000f70 <lwip_sntp_recv_callback+0x30>
        DEBUG_INFO("NTP: %u seconds elapsed since 1.1.1970\r\n", time);
 8000f60:	f01c ffc8 	bl	801def4 <sys_get_tick_ms>
 8000f64:	0001      	movs	r1, r0
 8000f66:	687b      	ldr	r3, [r7, #4]
 8000f68:	4a03      	ldr	r2, [pc, #12]	; (8000f78 <lwip_sntp_recv_callback+0x38>)
 8000f6a:	4805      	ldr	r0, [pc, #20]	; (8000f80 <lwip_sntp_recv_callback+0x40>)
 8000f6c:	f001 f93a 	bl	80021e4 <app_debug_rtt_raw>
}
 8000f70:	46c0      	nop			; (mov r8, r8)
 8000f72:	46bd      	mov	sp, r7
 8000f74:	b002      	add	sp, #8
 8000f76:	bd80      	pop	{r7, pc}
 8000f78:	0801e9c4 	.word	0x0801e9c4
 8000f7c:	0801ee30 	.word	0x0801ee30
 8000f80:	0801ee80 	.word	0x0801ee80

08000f84 <ppp_link_status_cb>:
 * ===================
 *
 * PPP status callback is called on PPP status change (up, down, ...) from lwIP core thread
 */
static void ppp_link_status_cb(ppp_pcb *pcb, int err_code, void *ctx)
{
 8000f84:	b590      	push	{r4, r7, lr}
 8000f86:	b087      	sub	sp, #28
 8000f88:	af00      	add	r7, sp, #0
 8000f8a:	60f8      	str	r0, [r7, #12]
 8000f8c:	60b9      	str	r1, [r7, #8]
 8000f8e:	607a      	str	r2, [r7, #4]
    struct netif *pppif = ppp_netif(pcb);
 8000f90:	68fb      	ldr	r3, [r7, #12]
 8000f92:	6a1b      	ldr	r3, [r3, #32]
 8000f94:	617b      	str	r3, [r7, #20]
 8000f96:	68bb      	ldr	r3, [r7, #8]
 8000f98:	2b0c      	cmp	r3, #12
 8000f9a:	d900      	bls.n	8000f9e <ppp_link_status_cb+0x1a>
 8000f9c:	e0df      	b.n	800115e <ppp_link_status_cb+0x1da>
 8000f9e:	68bb      	ldr	r3, [r7, #8]
 8000fa0:	009a      	lsls	r2, r3, #2
 8000fa2:	4b7c      	ldr	r3, [pc, #496]	; (8001194 <ppp_link_status_cb+0x210>)
 8000fa4:	18d3      	adds	r3, r2, r3
 8000fa6:	681b      	ldr	r3, [r3, #0]
 8000fa8:	469f      	mov	pc, r3
    {
#if LWIP_DNS
        const ip_addr_t *ns;
#endif /* LWIP_DNS */

        DEBUG_INFO("PPP Connected\r\n");
 8000faa:	f01c ffa3 	bl	801def4 <sys_get_tick_ms>
 8000fae:	0001      	movs	r1, r0
 8000fb0:	4a79      	ldr	r2, [pc, #484]	; (8001198 <ppp_link_status_cb+0x214>)
 8000fb2:	4b7a      	ldr	r3, [pc, #488]	; (800119c <ppp_link_status_cb+0x218>)
 8000fb4:	0018      	movs	r0, r3
 8000fb6:	f001 f915 	bl	80021e4 <app_debug_rtt_raw>

#if PPP_IPV4_SUPPORT

        DEBUG_INFO("\tour_ipaddr    = %s\r\n", ipaddr_ntoa(&pppif->ip_addr));
 8000fba:	f01c ff9b 	bl	801def4 <sys_get_tick_ms>
 8000fbe:	0004      	movs	r4, r0
 8000fc0:	697b      	ldr	r3, [r7, #20]
 8000fc2:	3304      	adds	r3, #4
 8000fc4:	0018      	movs	r0, r3
 8000fc6:	f013 fc33 	bl	8014830 <ip4addr_ntoa>
 8000fca:	0003      	movs	r3, r0
 8000fcc:	4a72      	ldr	r2, [pc, #456]	; (8001198 <ppp_link_status_cb+0x214>)
 8000fce:	4874      	ldr	r0, [pc, #464]	; (80011a0 <ppp_link_status_cb+0x21c>)
 8000fd0:	0021      	movs	r1, r4
 8000fd2:	f001 f907 	bl	80021e4 <app_debug_rtt_raw>
        DEBUG_INFO("\this_ipaddr    = %s\r\n", ipaddr_ntoa(&pppif->gw));
 8000fd6:	f01c ff8d 	bl	801def4 <sys_get_tick_ms>
 8000fda:	0004      	movs	r4, r0
 8000fdc:	697b      	ldr	r3, [r7, #20]
 8000fde:	330c      	adds	r3, #12
 8000fe0:	0018      	movs	r0, r3
 8000fe2:	f013 fc25 	bl	8014830 <ip4addr_ntoa>
 8000fe6:	0003      	movs	r3, r0
 8000fe8:	4a6b      	ldr	r2, [pc, #428]	; (8001198 <ppp_link_status_cb+0x214>)
 8000fea:	486e      	ldr	r0, [pc, #440]	; (80011a4 <ppp_link_status_cb+0x220>)
 8000fec:	0021      	movs	r1, r4
 8000fee:	f001 f8f9 	bl	80021e4 <app_debug_rtt_raw>
        DEBUG_INFO("\tnetmask       = %s\r\n", ipaddr_ntoa(&pppif->netmask));
 8000ff2:	f01c ff7f 	bl	801def4 <sys_get_tick_ms>
 8000ff6:	0004      	movs	r4, r0
 8000ff8:	697b      	ldr	r3, [r7, #20]
 8000ffa:	3308      	adds	r3, #8
 8000ffc:	0018      	movs	r0, r3
 8000ffe:	f013 fc17 	bl	8014830 <ip4addr_ntoa>
 8001002:	0003      	movs	r3, r0
 8001004:	4a64      	ldr	r2, [pc, #400]	; (8001198 <ppp_link_status_cb+0x214>)
 8001006:	4868      	ldr	r0, [pc, #416]	; (80011a8 <ppp_link_status_cb+0x224>)
 8001008:	0021      	movs	r1, r4
 800100a:	f001 f8eb 	bl	80021e4 <app_debug_rtt_raw>
        HAL_Delay(1);
 800100e:	2001      	movs	r0, #1
 8001010:	f001 fa5c 	bl	80024cc <HAL_Delay>

#if LWIP_DNS
        ns = dns_getserver(0);
 8001014:	2000      	movs	r0, #0
 8001016:	f006 fa99 	bl	800754c <dns_getserver>
 800101a:	0003      	movs	r3, r0
 800101c:	613b      	str	r3, [r7, #16]
        DEBUG_INFO("\tdns1          = %s\r\n", ipaddr_ntoa(ns));
 800101e:	f01c ff69 	bl	801def4 <sys_get_tick_ms>
 8001022:	0004      	movs	r4, r0
 8001024:	693b      	ldr	r3, [r7, #16]
 8001026:	0018      	movs	r0, r3
 8001028:	f013 fc02 	bl	8014830 <ip4addr_ntoa>
 800102c:	0003      	movs	r3, r0
 800102e:	4a5a      	ldr	r2, [pc, #360]	; (8001198 <ppp_link_status_cb+0x214>)
 8001030:	485e      	ldr	r0, [pc, #376]	; (80011ac <ppp_link_status_cb+0x228>)
 8001032:	0021      	movs	r1, r4
 8001034:	f001 f8d6 	bl	80021e4 <app_debug_rtt_raw>
        ns = dns_getserver(1);
 8001038:	2001      	movs	r0, #1
 800103a:	f006 fa87 	bl	800754c <dns_getserver>
 800103e:	0003      	movs	r3, r0
 8001040:	613b      	str	r3, [r7, #16]
        DEBUG_INFO("\tdns2          = %s\r\n", ipaddr_ntoa(ns));
 8001042:	f01c ff57 	bl	801def4 <sys_get_tick_ms>
 8001046:	0004      	movs	r4, r0
 8001048:	693b      	ldr	r3, [r7, #16]
 800104a:	0018      	movs	r0, r3
 800104c:	f013 fbf0 	bl	8014830 <ip4addr_ntoa>
 8001050:	0003      	movs	r3, r0
 8001052:	4a51      	ldr	r2, [pc, #324]	; (8001198 <ppp_link_status_cb+0x214>)
 8001054:	4856      	ldr	r0, [pc, #344]	; (80011b0 <ppp_link_status_cb+0x22c>)
 8001056:	0021      	movs	r1, r4
 8001058:	f001 f8c4 	bl	80021e4 <app_debug_rtt_raw>
        HAL_Delay(1);
 800105c:	2001      	movs	r0, #1
 800105e:	f001 fa35 	bl	80024cc <HAL_Delay>
#endif /* PPP_IPV4_SUPPORT */

#if PPP_IPV6_SUPPORT
        DEBUG_INFO("\r   our6_ipaddr = %s\n", ip6addr_ntoa(netif_ip6_addr(pppif, 0)));
#endif /* PPP_IPV6_SUPPORT */
        break;
 8001062:	e085      	b.n	8001170 <ppp_link_status_cb+0x1ec>
    }

    case PPPERR_PARAM:
    {
        DEBUG_INFO("status_cb: Invalid parameter\r\n");
 8001064:	f01c ff46 	bl	801def4 <sys_get_tick_ms>
 8001068:	0001      	movs	r1, r0
 800106a:	4a4b      	ldr	r2, [pc, #300]	; (8001198 <ppp_link_status_cb+0x214>)
 800106c:	4b51      	ldr	r3, [pc, #324]	; (80011b4 <ppp_link_status_cb+0x230>)
 800106e:	0018      	movs	r0, r3
 8001070:	f001 f8b8 	bl	80021e4 <app_debug_rtt_raw>
        break;
 8001074:	e07c      	b.n	8001170 <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_OPEN:
    {
        DEBUG_INFO("status_cb: Unable to open PPP session\r\n");
 8001076:	f01c ff3d 	bl	801def4 <sys_get_tick_ms>
 800107a:	0001      	movs	r1, r0
 800107c:	4a46      	ldr	r2, [pc, #280]	; (8001198 <ppp_link_status_cb+0x214>)
 800107e:	4b4e      	ldr	r3, [pc, #312]	; (80011b8 <ppp_link_status_cb+0x234>)
 8001080:	0018      	movs	r0, r3
 8001082:	f001 f8af 	bl	80021e4 <app_debug_rtt_raw>
        break;
 8001086:	e073      	b.n	8001170 <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_DEVICE:
    {
        DEBUG_INFO("status_cb: Invalid I/O device for PPP\r\n");
 8001088:	f01c ff34 	bl	801def4 <sys_get_tick_ms>
 800108c:	0001      	movs	r1, r0
 800108e:	4a42      	ldr	r2, [pc, #264]	; (8001198 <ppp_link_status_cb+0x214>)
 8001090:	4b4a      	ldr	r3, [pc, #296]	; (80011bc <ppp_link_status_cb+0x238>)
 8001092:	0018      	movs	r0, r3
 8001094:	f001 f8a6 	bl	80021e4 <app_debug_rtt_raw>
        break;
 8001098:	e06a      	b.n	8001170 <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_ALLOC:
    {
        DEBUG_INFO("status_cb: Unable to allocate resources\r\n");
 800109a:	f01c ff2b 	bl	801def4 <sys_get_tick_ms>
 800109e:	0001      	movs	r1, r0
 80010a0:	4a3d      	ldr	r2, [pc, #244]	; (8001198 <ppp_link_status_cb+0x214>)
 80010a2:	4b47      	ldr	r3, [pc, #284]	; (80011c0 <ppp_link_status_cb+0x23c>)
 80010a4:	0018      	movs	r0, r3
 80010a6:	f001 f89d 	bl	80021e4 <app_debug_rtt_raw>
        break;
 80010aa:	e061      	b.n	8001170 <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_USER: /* 5 */
    {
        /* ppp_close() was previously called, reconnect */
        DEBUG_INFO("status_cb: ppp is closed by user OK! Try to re-open...\r\n");
 80010ac:	f01c ff22 	bl	801def4 <sys_get_tick_ms>
 80010b0:	0001      	movs	r1, r0
 80010b2:	4a39      	ldr	r2, [pc, #228]	; (8001198 <ppp_link_status_cb+0x214>)
 80010b4:	4b43      	ldr	r3, [pc, #268]	; (80011c4 <ppp_link_status_cb+0x240>)
 80010b6:	0018      	movs	r0, r3
 80010b8:	f001 f894 	bl	80021e4 <app_debug_rtt_raw>
        /* ppp_free(); -- can be called here */
        ppp_free(m_ppp_control_block);
 80010bc:	4b42      	ldr	r3, [pc, #264]	; (80011c8 <ppp_link_status_cb+0x244>)
 80010be:	681b      	ldr	r3, [r3, #0]
 80010c0:	0018      	movs	r0, r3
 80010c2:	f019 f9d5 	bl	801a470 <ppp_free>
        GSM_Manager_ChangeState(GSM_STATE_REOPEN_PPP);
 80010c6:	2003      	movs	r0, #3
 80010c8:	f000 f904 	bl	80012d4 <GSM_Manager_ChangeState>
        break;
 80010cc:	e050      	b.n	8001170 <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_CONNECT: /* 6 */
    {
        DEBUG_INFO("status_cb: Connection lost\r\n");
 80010ce:	f01c ff11 	bl	801def4 <sys_get_tick_ms>
 80010d2:	0001      	movs	r1, r0
 80010d4:	4a30      	ldr	r2, [pc, #192]	; (8001198 <ppp_link_status_cb+0x214>)
 80010d6:	4b3d      	ldr	r3, [pc, #244]	; (80011cc <ppp_link_status_cb+0x248>)
 80010d8:	0018      	movs	r0, r3
 80010da:	f001 f883 	bl	80021e4 <app_debug_rtt_raw>
        m_ppp_connected = false;
 80010de:	4b3c      	ldr	r3, [pc, #240]	; (80011d0 <ppp_link_status_cb+0x24c>)
 80010e0:	2200      	movs	r2, #0
 80010e2:	701a      	strb	r2, [r3, #0]
        ppp_close(m_ppp_control_block, 1);
 80010e4:	4b38      	ldr	r3, [pc, #224]	; (80011c8 <ppp_link_status_cb+0x244>)
 80010e6:	681b      	ldr	r3, [r3, #0]
 80010e8:	2101      	movs	r1, #1
 80010ea:	0018      	movs	r0, r3
 80010ec:	f019 f958 	bl	801a3a0 <ppp_close>
        break;
 80010f0:	e03e      	b.n	8001170 <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_AUTHFAIL:
    {
        DEBUG_INFO("status_cb: Failed authentication challenge\r\n");
 80010f2:	f01c feff 	bl	801def4 <sys_get_tick_ms>
 80010f6:	0001      	movs	r1, r0
 80010f8:	4a27      	ldr	r2, [pc, #156]	; (8001198 <ppp_link_status_cb+0x214>)
 80010fa:	4b36      	ldr	r3, [pc, #216]	; (80011d4 <ppp_link_status_cb+0x250>)
 80010fc:	0018      	movs	r0, r3
 80010fe:	f001 f871 	bl	80021e4 <app_debug_rtt_raw>
        break;
 8001102:	e035      	b.n	8001170 <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_PROTOCOL:
    {
        DEBUG_INFO("status_cb: Failed to meet protocol\n");
 8001104:	f01c fef6 	bl	801def4 <sys_get_tick_ms>
 8001108:	0001      	movs	r1, r0
 800110a:	4a23      	ldr	r2, [pc, #140]	; (8001198 <ppp_link_status_cb+0x214>)
 800110c:	4b32      	ldr	r3, [pc, #200]	; (80011d8 <ppp_link_status_cb+0x254>)
 800110e:	0018      	movs	r0, r3
 8001110:	f001 f868 	bl	80021e4 <app_debug_rtt_raw>
        break;
 8001114:	e02c      	b.n	8001170 <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_PEERDEAD:
    {
        DEBUG_INFO("status_cb: Connection timeout\r\n");
 8001116:	f01c feed 	bl	801def4 <sys_get_tick_ms>
 800111a:	0001      	movs	r1, r0
 800111c:	4a1e      	ldr	r2, [pc, #120]	; (8001198 <ppp_link_status_cb+0x214>)
 800111e:	4b2f      	ldr	r3, [pc, #188]	; (80011dc <ppp_link_status_cb+0x258>)
 8001120:	0018      	movs	r0, r3
 8001122:	f001 f85f 	bl	80021e4 <app_debug_rtt_raw>
        break;
 8001126:	e023      	b.n	8001170 <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_IDLETIMEOUT:
    {
        DEBUG_INFO("status_cb: Idle Timeout\r\n");
 8001128:	f01c fee4 	bl	801def4 <sys_get_tick_ms>
 800112c:	0001      	movs	r1, r0
 800112e:	4a1a      	ldr	r2, [pc, #104]	; (8001198 <ppp_link_status_cb+0x214>)
 8001130:	4b2b      	ldr	r3, [pc, #172]	; (80011e0 <ppp_link_status_cb+0x25c>)
 8001132:	0018      	movs	r0, r3
 8001134:	f001 f856 	bl	80021e4 <app_debug_rtt_raw>
        break;
 8001138:	e01a      	b.n	8001170 <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_CONNECTTIME:
    {
        DEBUG_INFO("status_cb: Max connect time reached\r\n");
 800113a:	f01c fedb 	bl	801def4 <sys_get_tick_ms>
 800113e:	0001      	movs	r1, r0
 8001140:	4a15      	ldr	r2, [pc, #84]	; (8001198 <ppp_link_status_cb+0x214>)
 8001142:	4b28      	ldr	r3, [pc, #160]	; (80011e4 <ppp_link_status_cb+0x260>)
 8001144:	0018      	movs	r0, r3
 8001146:	f001 f84d 	bl	80021e4 <app_debug_rtt_raw>
        break;
 800114a:	e011      	b.n	8001170 <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_LOOPBACK:
    {
        DEBUG_INFO("status_cb: Loopback detected\r\n");
 800114c:	f01c fed2 	bl	801def4 <sys_get_tick_ms>
 8001150:	0001      	movs	r1, r0
 8001152:	4a11      	ldr	r2, [pc, #68]	; (8001198 <ppp_link_status_cb+0x214>)
 8001154:	4b24      	ldr	r3, [pc, #144]	; (80011e8 <ppp_link_status_cb+0x264>)
 8001156:	0018      	movs	r0, r3
 8001158:	f001 f844 	bl	80021e4 <app_debug_rtt_raw>
        break;
 800115c:	e008      	b.n	8001170 <ppp_link_status_cb+0x1ec>
    }
    default:
    {
        DEBUG_INFO("status_cb: Unknown error code %d\r\n", err_code);
 800115e:	f01c fec9 	bl	801def4 <sys_get_tick_ms>
 8001162:	0001      	movs	r1, r0
 8001164:	68bb      	ldr	r3, [r7, #8]
 8001166:	4a0c      	ldr	r2, [pc, #48]	; (8001198 <ppp_link_status_cb+0x214>)
 8001168:	4820      	ldr	r0, [pc, #128]	; (80011ec <ppp_link_status_cb+0x268>)
 800116a:	f001 f83b 	bl	80021e4 <app_debug_rtt_raw>
        break;
 800116e:	46c0      	nop			; (mov r8, r8)
    /*
	* This should be in the switch case, this is put outside of the switch
	* case for example readability.
	*/

    if (err_code == PPPERR_NONE)
 8001170:	68bb      	ldr	r3, [r7, #8]
 8001172:	2b00      	cmp	r3, #0
 8001174:	d10a      	bne.n	800118c <ppp_link_status_cb+0x208>
    {
        DEBUG_INFO("PPP is opened OK\r\n");
 8001176:	f01c febd 	bl	801def4 <sys_get_tick_ms>
 800117a:	0001      	movs	r1, r0
 800117c:	4a06      	ldr	r2, [pc, #24]	; (8001198 <ppp_link_status_cb+0x214>)
 800117e:	4b1c      	ldr	r3, [pc, #112]	; (80011f0 <ppp_link_status_cb+0x26c>)
 8001180:	0018      	movs	r0, r3
 8001182:	f001 f82f 	bl	80021e4 <app_debug_rtt_raw>
        initialize_stnp();
 8001186:	f7ff feb1 	bl	8000eec <initialize_stnp>
        return;
 800118a:	46c0      	nop			; (mov r8, r8)
   * Try to reconnect in 30 seconds, if you need a modem chatscript you have
   * to do a much better signaling here ;-)
   */
    //  ppp_connect(pcb, 30);
    /* OR ppp_listen(pcb); */
}
 800118c:	46bd      	mov	sp, r7
 800118e:	b007      	add	sp, #28
 8001190:	bd90      	pop	{r4, r7, pc}
 8001192:	46c0      	nop			; (mov r8, r8)
 8001194:	08023904 	.word	0x08023904
 8001198:	0801e9c4 	.word	0x0801e9c4
 800119c:	0801eec4 	.word	0x0801eec4
 80011a0:	0801eef0 	.word	0x0801eef0
 80011a4:	0801ef20 	.word	0x0801ef20
 80011a8:	0801ef50 	.word	0x0801ef50
 80011ac:	0801ef80 	.word	0x0801ef80
 80011b0:	0801efb0 	.word	0x0801efb0
 80011b4:	0801efe0 	.word	0x0801efe0
 80011b8:	0801f018 	.word	0x0801f018
 80011bc:	0801f05c 	.word	0x0801f05c
 80011c0:	0801f0a0 	.word	0x0801f0a0
 80011c4:	0801f0e4 	.word	0x0801f0e4
 80011c8:	2000011c 	.word	0x2000011c
 80011cc:	0801f138 	.word	0x0801f138
 80011d0:	20000120 	.word	0x20000120
 80011d4:	0801f170 	.word	0x0801f170
 80011d8:	0801f1b8 	.word	0x0801f1b8
 80011dc:	0801f1f8 	.word	0x0801f1f8
 80011e0:	0801f234 	.word	0x0801f234
 80011e4:	0801f268 	.word	0x0801f268
 80011e8:	0801f2a8 	.word	0x0801f2a8
 80011ec:	0801f2e0 	.word	0x0801f2e0
 80011f0:	0801f31c 	.word	0x0801f31c

080011f4 <Polling_GSM_StateMachine>:
void Polling_GSM_StateMachine (void)
{
 80011f4:	b5b0      	push	{r4, r5, r7, lr}
 80011f6:	b086      	sub	sp, #24
 80011f8:	af04      	add	r7, sp, #16
    static uint32_t last_tick = 0;
    uint32_t current_tick = sys_get_tick_ms();
 80011fa:	f01c fe7b 	bl	801def4 <sys_get_tick_ms>
 80011fe:	0003      	movs	r3, r0
 8001200:	607b      	str	r3, [r7, #4]
    if(current_tick - last_tick >= (uint32_t)1000)
 8001202:	4b23      	ldr	r3, [pc, #140]	; (8001290 <Polling_GSM_StateMachine+0x9c>)
 8001204:	681b      	ldr	r3, [r3, #0]
 8001206:	687a      	ldr	r2, [r7, #4]
 8001208:	1ad2      	subs	r2, r2, r3
 800120a:	23fa      	movs	r3, #250	; 0xfa
 800120c:	009b      	lsls	r3, r3, #2
 800120e:	429a      	cmp	r2, r3
 8001210:	d332      	bcc.n	8001278 <Polling_GSM_StateMachine+0x84>
    {
        last_tick = current_tick;
 8001212:	4b1f      	ldr	r3, [pc, #124]	; (8001290 <Polling_GSM_StateMachine+0x9c>)
 8001214:	687a      	ldr	r2, [r7, #4]
 8001216:	601a      	str	r2, [r3, #0]
        switch (GSM_Manager.state)
 8001218:	4b1e      	ldr	r3, [pc, #120]	; (8001294 <Polling_GSM_StateMachine+0xa0>)
 800121a:	781b      	ldrb	r3, [r3, #0]
 800121c:	2b03      	cmp	r3, #3
 800121e:	d02d      	beq.n	800127c <Polling_GSM_StateMachine+0x88>
 8001220:	dc20      	bgt.n	8001264 <Polling_GSM_StateMachine+0x70>
 8001222:	2b02      	cmp	r3, #2
 8001224:	d02c      	beq.n	8001280 <Polling_GSM_StateMachine+0x8c>
 8001226:	dc1d      	bgt.n	8001264 <Polling_GSM_StateMachine+0x70>
 8001228:	2b00      	cmp	r3, #0
 800122a:	d004      	beq.n	8001236 <Polling_GSM_StateMachine+0x42>
 800122c:	2b01      	cmp	r3, #1
 800122e:	d119      	bne.n	8001264 <Polling_GSM_StateMachine+0x70>
        {
            case GSM_STATE_RESET:
                GSM_Turn_on_Power();
 8001230:	f000 fad0 	bl	80017d4 <GSM_Turn_on_Power>
                break;
 8001234:	e027      	b.n	8001286 <Polling_GSM_StateMachine+0x92>
            case GSM_STATE_POWER_ON:
                if(GSM_Manager.step == 0)
 8001236:	4b17      	ldr	r3, [pc, #92]	; (8001294 <Polling_GSM_StateMachine+0xa0>)
 8001238:	785b      	ldrb	r3, [r3, #1]
 800123a:	2b00      	cmp	r3, #0
 800123c:	d122      	bne.n	8001284 <Polling_GSM_StateMachine+0x90>
                {
                    GSM_Manager.step = 1;
 800123e:	4b15      	ldr	r3, [pc, #84]	; (8001294 <Polling_GSM_StateMachine+0xa0>)
 8001240:	2201      	movs	r2, #1
 8001242:	705a      	strb	r2, [r3, #1]
                    GSM_SendCommand_AT(atc_table_config_module[0]);
 8001244:	4b14      	ldr	r3, [pc, #80]	; (8001298 <Polling_GSM_StateMachine+0xa4>)
 8001246:	466a      	mov	r2, sp
 8001248:	0011      	movs	r1, r2
 800124a:	001a      	movs	r2, r3
 800124c:	3210      	adds	r2, #16
 800124e:	ca31      	ldmia	r2!, {r0, r4, r5}
 8001250:	c131      	stmia	r1!, {r0, r4, r5}
 8001252:	6812      	ldr	r2, [r2, #0]
 8001254:	600a      	str	r2, [r1, #0]
 8001256:	6818      	ldr	r0, [r3, #0]
 8001258:	6859      	ldr	r1, [r3, #4]
 800125a:	689a      	ldr	r2, [r3, #8]
 800125c:	68db      	ldr	r3, [r3, #12]
 800125e:	f000 fb75 	bl	800194c <GSM_SendCommand_AT>
                }
                break;
 8001262:	e00f      	b.n	8001284 <Polling_GSM_StateMachine+0x90>
                break;
            case GSM_STATE_REOPEN_PPP:

            	break;
            default:
                DEBUG_WARN("Unhandled state %d.\r\n", GSM_Manager.state);
 8001264:	f01c fe46 	bl	801def4 <sys_get_tick_ms>
 8001268:	0001      	movs	r1, r0
 800126a:	4b0a      	ldr	r3, [pc, #40]	; (8001294 <Polling_GSM_StateMachine+0xa0>)
 800126c:	781b      	ldrb	r3, [r3, #0]
 800126e:	4a0b      	ldr	r2, [pc, #44]	; (800129c <Polling_GSM_StateMachine+0xa8>)
 8001270:	480b      	ldr	r0, [pc, #44]	; (80012a0 <Polling_GSM_StateMachine+0xac>)
 8001272:	f000 ffb7 	bl	80021e4 <app_debug_rtt_raw>
                break;
 8001276:	e006      	b.n	8001286 <Polling_GSM_StateMachine+0x92>
        }
    }
 8001278:	46c0      	nop			; (mov r8, r8)
 800127a:	e004      	b.n	8001286 <Polling_GSM_StateMachine+0x92>
            	break;
 800127c:	46c0      	nop			; (mov r8, r8)
 800127e:	e002      	b.n	8001286 <Polling_GSM_StateMachine+0x92>
                break;
 8001280:	46c0      	nop			; (mov r8, r8)
 8001282:	e000      	b.n	8001286 <Polling_GSM_StateMachine+0x92>
                break;
 8001284:	46c0      	nop			; (mov r8, r8)
}
 8001286:	46c0      	nop			; (mov r8, r8)
 8001288:	46bd      	mov	sp, r7
 800128a:	b002      	add	sp, #8
 800128c:	bdb0      	pop	{r4, r5, r7, pc}
 800128e:	46c0      	nop			; (mov r8, r8)
 8001290:	20000124 	.word	0x20000124
 8001294:	200010c0 	.word	0x200010c0
 8001298:	08023530 	.word	0x08023530
 800129c:	0801e9c4 	.word	0x0801e9c4
 80012a0:	0801f348 	.word	0x0801f348

080012a4 <gsm_is_in_ppp_mode>:
bool gsm_is_in_ppp_mode(void)
{
 80012a4:	b580      	push	{r7, lr}
 80012a6:	af00      	add	r7, sp, #0
    return GSM_Manager.mode == GSM_INTERNET_MODE_PPP_STACK? true : false;
 80012a8:	4b04      	ldr	r3, [pc, #16]	; (80012bc <gsm_is_in_ppp_mode+0x18>)
 80012aa:	789b      	ldrb	r3, [r3, #2]
 80012ac:	3b01      	subs	r3, #1
 80012ae:	425a      	negs	r2, r3
 80012b0:	4153      	adcs	r3, r2
 80012b2:	b2db      	uxtb	r3, r3
}
 80012b4:	0018      	movs	r0, r3
 80012b6:	46bd      	mov	sp, r7
 80012b8:	bd80      	pop	{r7, pc}
 80012ba:	46c0      	nop			; (mov r8, r8)
 80012bc:	200010c0 	.word	0x200010c0

080012c0 <gsm_data_layer_is_ppp_connected>:
bool gsm_data_layer_is_ppp_connected(void)
{
 80012c0:	b580      	push	{r7, lr}
 80012c2:	af00      	add	r7, sp, #0
    return m_ppp_connected;
 80012c4:	4b02      	ldr	r3, [pc, #8]	; (80012d0 <gsm_data_layer_is_ppp_connected+0x10>)
 80012c6:	781b      	ldrb	r3, [r3, #0]
}
 80012c8:	0018      	movs	r0, r3
 80012ca:	46bd      	mov	sp, r7
 80012cc:	bd80      	pop	{r7, pc}
 80012ce:	46c0      	nop			; (mov r8, r8)
 80012d0:	20000120 	.word	0x20000120

080012d4 <GSM_Manager_ChangeState>:


void GSM_Manager_ChangeState(Gsm_State_TypDef state)
{
 80012d4:	b5b0      	push	{r4, r5, r7, lr}
 80012d6:	b086      	sub	sp, #24
 80012d8:	af04      	add	r7, sp, #16
 80012da:	0002      	movs	r2, r0
 80012dc:	1dfb      	adds	r3, r7, #7
 80012de:	701a      	strb	r2, [r3, #0]
    GSM_Manager.state = state;
 80012e0:	4b38      	ldr	r3, [pc, #224]	; (80013c4 <GSM_Manager_ChangeState+0xf0>)
 80012e2:	1dfa      	adds	r2, r7, #7
 80012e4:	7812      	ldrb	r2, [r2, #0]
 80012e6:	701a      	strb	r2, [r3, #0]
    GSM_Manager.step = 0;
 80012e8:	4b36      	ldr	r3, [pc, #216]	; (80013c4 <GSM_Manager_ChangeState+0xf0>)
 80012ea:	2200      	movs	r2, #0
 80012ec:	705a      	strb	r2, [r3, #1]
    DEBUG_INFO("Change GSM State to: ");
 80012ee:	f01c fe01 	bl	801def4 <sys_get_tick_ms>
 80012f2:	0001      	movs	r1, r0
 80012f4:	4a34      	ldr	r2, [pc, #208]	; (80013c8 <GSM_Manager_ChangeState+0xf4>)
 80012f6:	4b35      	ldr	r3, [pc, #212]	; (80013cc <GSM_Manager_ChangeState+0xf8>)
 80012f8:	0018      	movs	r0, r3
 80012fa:	f000 ff73 	bl	80021e4 <app_debug_rtt_raw>
    switch (state)
 80012fe:	1dfb      	adds	r3, r7, #7
 8001300:	781b      	ldrb	r3, [r3, #0]
 8001302:	2b03      	cmp	r3, #3
 8001304:	d033      	beq.n	800136e <GSM_Manager_ChangeState+0x9a>
 8001306:	dc55      	bgt.n	80013b4 <GSM_Manager_ChangeState+0xe0>
 8001308:	2b02      	cmp	r3, #2
 800130a:	d005      	beq.n	8001318 <GSM_Manager_ChangeState+0x44>
 800130c:	dc52      	bgt.n	80013b4 <GSM_Manager_ChangeState+0xe0>
 800130e:	2b00      	cmp	r3, #0
 8001310:	d026      	beq.n	8001360 <GSM_Manager_ChangeState+0x8c>
 8001312:	2b01      	cmp	r3, #1
 8001314:	d005      	beq.n	8001322 <GSM_Manager_ChangeState+0x4e>
            GSM_HwLayer_Reset_Rx_Buffer(); // Reset USART RX buffer
            GSM_SendCommand_AT(atc_table_open_ppp_stack[0]);
        }
        break;
    default:
        break;
 8001316:	e04d      	b.n	80013b4 <GSM_Manager_ChangeState+0xe0>
        DEBUG_RAW("OK\r\n");
 8001318:	4b2d      	ldr	r3, [pc, #180]	; (80013d0 <GSM_Manager_ChangeState+0xfc>)
 800131a:	0018      	movs	r0, r3
 800131c:	f000 ff62 	bl	80021e4 <app_debug_rtt_raw>
        break;
 8001320:	e04b      	b.n	80013ba <GSM_Manager_ChangeState+0xe6>
    	DEBUG_RAW("RESET\r\n");
 8001322:	4b2c      	ldr	r3, [pc, #176]	; (80013d4 <GSM_Manager_ChangeState+0x100>)
 8001324:	0018      	movs	r0, r3
 8001326:	f000 ff5d 	bl	80021e4 <app_debug_rtt_raw>
        GSM_HwLayer_Reset_Rx_Buffer(); // Reset USART RX buffer
 800132a:	f000 fbfb 	bl	8001b24 <GSM_HwLayer_Reset_Rx_Buffer>
        GSM_Manager_ChangeInternetMode(GSM_INTERNET_MODE_AT_STACK);
 800132e:	2000      	movs	r0, #0
 8001330:	f000 f85e 	bl	80013f0 <GSM_Manager_ChangeInternetMode>
        HAL_GPIO_WritePin(EN_GSM_GPIO_Port,EN_GSM_Pin,0);    // Set GSM power en level to 0 = power off device
 8001334:	4b28      	ldr	r3, [pc, #160]	; (80013d8 <GSM_Manager_ChangeState+0x104>)
 8001336:	2200      	movs	r2, #0
 8001338:	2140      	movs	r1, #64	; 0x40
 800133a:	0018      	movs	r0, r3
 800133c:	f001 fbce 	bl	8002adc <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GSM_RESET_GPIO_Port,GSM_RESET_Pin,1);  // Set GSM Reset pin to high
 8001340:	2380      	movs	r3, #128	; 0x80
 8001342:	009b      	lsls	r3, r3, #2
 8001344:	4825      	ldr	r0, [pc, #148]	; (80013dc <GSM_Manager_ChangeState+0x108>)
 8001346:	2201      	movs	r2, #1
 8001348:	0019      	movs	r1, r3
 800134a:	f001 fbc7 	bl	8002adc <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GSM_PWKEY_GPIO_Port,GSM_PWKEY_Pin,0);  // Reset GSM power key pin
 800134e:	2380      	movs	r3, #128	; 0x80
 8001350:	0059      	lsls	r1, r3, #1
 8001352:	23a0      	movs	r3, #160	; 0xa0
 8001354:	05db      	lsls	r3, r3, #23
 8001356:	2200      	movs	r2, #0
 8001358:	0018      	movs	r0, r3
 800135a:	f001 fbbf 	bl	8002adc <HAL_GPIO_WritePin>
        break;
 800135e:	e02c      	b.n	80013ba <GSM_Manager_ChangeState+0xe6>
    	DEBUG_RAW("POWER ON\r\n");
 8001360:	4b1f      	ldr	r3, [pc, #124]	; (80013e0 <GSM_Manager_ChangeState+0x10c>)
 8001362:	0018      	movs	r0, r3
 8001364:	f000 ff3e 	bl	80021e4 <app_debug_rtt_raw>
        GSM_HwLayer_Reset_Rx_Buffer(); // Reset USART RX buffer
 8001368:	f000 fbdc 	bl	8001b24 <GSM_HwLayer_Reset_Rx_Buffer>
        break;
 800136c:	e025      	b.n	80013ba <GSM_Manager_ChangeState+0xe6>
    	DEBUG_RAW("REOPEN PPP\r\n");
 800136e:	4b1d      	ldr	r3, [pc, #116]	; (80013e4 <GSM_Manager_ChangeState+0x110>)
 8001370:	0018      	movs	r0, r3
 8001372:	f000 ff37 	bl	80021e4 <app_debug_rtt_raw>
        if (GSM_Manager.step == 0)
 8001376:	4b13      	ldr	r3, [pc, #76]	; (80013c4 <GSM_Manager_ChangeState+0xf0>)
 8001378:	785b      	ldrb	r3, [r3, #1]
 800137a:	2b00      	cmp	r3, #0
 800137c:	d11c      	bne.n	80013b8 <GSM_Manager_ChangeState+0xe4>
            GSM_Manager.step = 1;
 800137e:	4b11      	ldr	r3, [pc, #68]	; (80013c4 <GSM_Manager_ChangeState+0xf0>)
 8001380:	2201      	movs	r2, #1
 8001382:	705a      	strb	r2, [r3, #1]
            m_ppp_connected = false;
 8001384:	4b18      	ldr	r3, [pc, #96]	; (80013e8 <GSM_Manager_ChangeState+0x114>)
 8001386:	2200      	movs	r2, #0
 8001388:	701a      	strb	r2, [r3, #0]
            GSM_Manager_ChangeInternetMode(GSM_INTERNET_MODE_AT_STACK);
 800138a:	2000      	movs	r0, #0
 800138c:	f000 f830 	bl	80013f0 <GSM_Manager_ChangeInternetMode>
            GSM_HwLayer_Reset_Rx_Buffer(); // Reset USART RX buffer
 8001390:	f000 fbc8 	bl	8001b24 <GSM_HwLayer_Reset_Rx_Buffer>
            GSM_SendCommand_AT(atc_table_open_ppp_stack[0]);
 8001394:	4b15      	ldr	r3, [pc, #84]	; (80013ec <GSM_Manager_ChangeState+0x118>)
 8001396:	466a      	mov	r2, sp
 8001398:	0011      	movs	r1, r2
 800139a:	001a      	movs	r2, r3
 800139c:	3210      	adds	r2, #16
 800139e:	ca31      	ldmia	r2!, {r0, r4, r5}
 80013a0:	c131      	stmia	r1!, {r0, r4, r5}
 80013a2:	6812      	ldr	r2, [r2, #0]
 80013a4:	600a      	str	r2, [r1, #0]
 80013a6:	6818      	ldr	r0, [r3, #0]
 80013a8:	6859      	ldr	r1, [r3, #4]
 80013aa:	689a      	ldr	r2, [r3, #8]
 80013ac:	68db      	ldr	r3, [r3, #12]
 80013ae:	f000 facd 	bl	800194c <GSM_SendCommand_AT>
        break;
 80013b2:	e001      	b.n	80013b8 <GSM_Manager_ChangeState+0xe4>
        break;
 80013b4:	46c0      	nop			; (mov r8, r8)
 80013b6:	e000      	b.n	80013ba <GSM_Manager_ChangeState+0xe6>
        break;
 80013b8:	46c0      	nop			; (mov r8, r8)
    }
}
 80013ba:	46c0      	nop			; (mov r8, r8)
 80013bc:	46bd      	mov	sp, r7
 80013be:	b002      	add	sp, #8
 80013c0:	bdb0      	pop	{r4, r5, r7, pc}
 80013c2:	46c0      	nop			; (mov r8, r8)
 80013c4:	200010c0 	.word	0x200010c0
 80013c8:	0801e9c4 	.word	0x0801e9c4
 80013cc:	0801f378 	.word	0x0801f378
 80013d0:	0801e9b4 	.word	0x0801e9b4
 80013d4:	0801f3a8 	.word	0x0801f3a8
 80013d8:	50000800 	.word	0x50000800
 80013dc:	50000400 	.word	0x50000400
 80013e0:	0801f3b0 	.word	0x0801f3b0
 80013e4:	0801f3bc 	.word	0x0801f3bc
 80013e8:	20000120 	.word	0x20000120
 80013ec:	08023850 	.word	0x08023850

080013f0 <GSM_Manager_ChangeInternetMode>:
void GSM_Manager_ChangeInternetMode(gsm_internet_mode_t mode)
{
 80013f0:	b580      	push	{r7, lr}
 80013f2:	b082      	sub	sp, #8
 80013f4:	af00      	add	r7, sp, #0
 80013f6:	0002      	movs	r2, r0
 80013f8:	1dfb      	adds	r3, r7, #7
 80013fa:	701a      	strb	r2, [r3, #0]
    GSM_Manager.mode = mode;
 80013fc:	4b03      	ldr	r3, [pc, #12]	; (800140c <GSM_Manager_ChangeInternetMode+0x1c>)
 80013fe:	1dfa      	adds	r2, r7, #7
 8001400:	7812      	ldrb	r2, [r2, #0]
 8001402:	709a      	strb	r2, [r3, #2]
}
 8001404:	46c0      	nop			; (mov r8, r8)
 8001406:	46bd      	mov	sp, r7
 8001408:	b002      	add	sp, #8
 800140a:	bd80      	pop	{r7, pc}
 800140c:	200010c0 	.word	0x200010c0

08001410 <GSM_mnr_task>:
void GSM_mnr_task(void)
{
 8001410:	b580      	push	{r7, lr}
 8001412:	af00      	add	r7, sp, #0
    GSM_Hardware_Layer_Run();
 8001414:	f000 f832 	bl	800147c <GSM_Hardware_Layer_Run>
    Polling_GSM_StateMachine();
 8001418:	f7ff feec 	bl	80011f4 <Polling_GSM_StateMachine>
    GSM_Hardware_pppos_Polling();
 800141c:	f000 fb2a 	bl	8001a74 <GSM_Hardware_pppos_Polling>
}
 8001420:	46c0      	nop			; (mov r8, r8)
 8001422:	46bd      	mov	sp, r7
 8001424:	bd80      	pop	{r7, pc}
	...

08001428 <GMS_Hardware_Init>:
static GSM_Hardware_atc_TypDef m_gsm_atc;
// Buffer for ppp
static GSM_Modem_Buffer_TypDef m_gsm_modem_buffer;

void GMS_Hardware_Init(void)
{
 8001428:	b580      	push	{r7, lr}
 800142a:	af00      	add	r7, sp, #0
	// Turn off power GSM
	HAL_GPIO_WritePin(EN_GSM_GPIO_Port,EN_GSM_Pin,0);
 800142c:	4b10      	ldr	r3, [pc, #64]	; (8001470 <GMS_Hardware_Init+0x48>)
 800142e:	2200      	movs	r2, #0
 8001430:	2140      	movs	r1, #64	; 0x40
 8001432:	0018      	movs	r0, r3
 8001434:	f001 fb52 	bl	8002adc <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GSM_RESET_GPIO_Port,GSM_RESET_Pin,1);
 8001438:	2380      	movs	r3, #128	; 0x80
 800143a:	009b      	lsls	r3, r3, #2
 800143c:	480d      	ldr	r0, [pc, #52]	; (8001474 <GMS_Hardware_Init+0x4c>)
 800143e:	2201      	movs	r2, #1
 8001440:	0019      	movs	r1, r3
 8001442:	f001 fb4b 	bl	8002adc <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GSM_PWKEY_GPIO_Port,GSM_PWKEY_Pin,0);
 8001446:	2380      	movs	r3, #128	; 0x80
 8001448:	0059      	lsls	r1, r3, #1
 800144a:	23a0      	movs	r3, #160	; 0xa0
 800144c:	05db      	lsls	r3, r3, #23
 800144e:	2200      	movs	r2, #0
 8001450:	0018      	movs	r0, r3
 8001452:	f001 fb43 	bl	8002adc <HAL_GPIO_WritePin>
	//Init SEGGER RTT Debug
	SEGGER_RTT_Init();
 8001456:	f000 febd 	bl	80021d4 <SEGGER_RTT_Init>
	// Cap phat bo nho cho RxRingBuffer
	RingBuffer_Init(&Rx_Buffer, 100);
 800145a:	4b07      	ldr	r3, [pc, #28]	; (8001478 <GMS_Hardware_Init+0x50>)
 800145c:	2164      	movs	r1, #100	; 0x64
 800145e:	0018      	movs	r0, r3
 8001460:	f000 fef2 	bl	8002248 <RingBuffer_Init>
	// Set default GMS State to GMS_STATE_RESET
	GSM_Manager_ChangeState(GSM_STATE_RESET);
 8001464:	2001      	movs	r0, #1
 8001466:	f7ff ff35 	bl	80012d4 <GSM_Manager_ChangeState>
}
 800146a:	46c0      	nop			; (mov r8, r8)
 800146c:	46bd      	mov	sp, r7
 800146e:	bd80      	pop	{r7, pc}
 8001470:	50000800 	.word	0x50000800
 8001474:	50000400 	.word	0x50000400
 8001478:	200010d4 	.word	0x200010d4

0800147c <GSM_Hardware_Layer_Run>:
void GSM_Hardware_Layer_Run(void)
{
 800147c:	b590      	push	{r4, r7, lr}
 800147e:	b097      	sub	sp, #92	; 0x5c
 8001480:	af02      	add	r7, sp, #8
	static uint32_t LastTick = 0;
	uint32_t Current_Tick = sys_get_tick_ms();
 8001482:	f01c fd37 	bl	801def4 <sys_get_tick_ms>
 8001486:	0003      	movs	r3, r0
 8001488:	64bb      	str	r3, [r7, #72]	; 0x48

	if(Current_Tick - LastTick < (uint32_t)5)
 800148a:	4bc4      	ldr	r3, [pc, #784]	; (800179c <GSM_Hardware_Layer_Run+0x320>)
 800148c:	681b      	ldr	r3, [r3, #0]
 800148e:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8001490:	1ad3      	subs	r3, r2, r3
 8001492:	2b04      	cmp	r3, #4
 8001494:	d800      	bhi.n	8001498 <GSM_Hardware_Layer_Run+0x1c>
 8001496:	e17d      	b.n	8001794 <GSM_Hardware_Layer_Run+0x318>
	{
		return;
	}
	uint32_t diff = sys_get_tick_ms() - m_gsm_atc.atc.Last_time_send_atc_ms;
 8001498:	f01c fd2c 	bl	801def4 <sys_get_tick_ms>
 800149c:	0002      	movs	r2, r0
 800149e:	4bc0      	ldr	r3, [pc, #768]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 80014a0:	699b      	ldr	r3, [r3, #24]
 80014a2:	1ad3      	subs	r3, r2, r3
 80014a4:	647b      	str	r3, [r7, #68]	; 0x44
	if(m_gsm_atc.atc.Timeout_atc_ms && diff >= m_gsm_atc.atc.Timeout_atc_ms)
 80014a6:	4bbe      	ldr	r3, [pc, #760]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 80014a8:	695b      	ldr	r3, [r3, #20]
 80014aa:	2b00      	cmp	r3, #0
 80014ac:	d100      	bne.n	80014b0 <GSM_Hardware_Layer_Run+0x34>
 80014ae:	e07d      	b.n	80015ac <GSM_Hardware_Layer_Run+0x130>
 80014b0:	4bbb      	ldr	r3, [pc, #748]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 80014b2:	695b      	ldr	r3, [r3, #20]
 80014b4:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80014b6:	429a      	cmp	r2, r3
 80014b8:	d378      	bcc.n	80015ac <GSM_Hardware_Layer_Run+0x130>
	{
		if(--m_gsm_atc.atc.Retry_Count_atc <= 0)
 80014ba:	4bb9      	ldr	r3, [pc, #740]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 80014bc:	7f1b      	ldrb	r3, [r3, #28]
 80014be:	3b01      	subs	r3, #1
 80014c0:	b2da      	uxtb	r2, r3
 80014c2:	4bb7      	ldr	r3, [pc, #732]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 80014c4:	771a      	strb	r2, [r3, #28]
 80014c6:	4bb6      	ldr	r3, [pc, #728]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 80014c8:	7f1b      	ldrb	r3, [r3, #28]
 80014ca:	2b00      	cmp	r3, #0
 80014cc:	d11c      	bne.n	8001508 <GSM_Hardware_Layer_Run+0x8c>
		{
			m_gsm_atc.atc.Timeout_atc_ms = 0;
 80014ce:	4bb4      	ldr	r3, [pc, #720]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 80014d0:	2200      	movs	r2, #0
 80014d2:	615a      	str	r2, [r3, #20]
			if(m_gsm_atc.atc.Send_at_Callback != NULL)
 80014d4:	4ab2      	ldr	r2, [pc, #712]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 80014d6:	2390      	movs	r3, #144	; 0x90
 80014d8:	005b      	lsls	r3, r3, #1
 80014da:	58d3      	ldr	r3, [r2, r3]
 80014dc:	2b00      	cmp	r3, #0
 80014de:	d006      	beq.n	80014ee <GSM_Hardware_Layer_Run+0x72>
			{
				m_gsm_atc.atc.Send_at_Callback(GSM_EVENT_TIMEOUT,NULL);
 80014e0:	4aaf      	ldr	r2, [pc, #700]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 80014e2:	2390      	movs	r3, #144	; 0x90
 80014e4:	005b      	lsls	r3, r3, #1
 80014e6:	58d3      	ldr	r3, [r2, r3]
 80014e8:	2100      	movs	r1, #0
 80014ea:	2001      	movs	r0, #1
 80014ec:	4798      	blx	r3
			}
			memset(&m_gsm_atc.atc.Recv_Buffer.u8Buffer, 0, sizeof(m_gsm_atc.atc.Recv_Buffer.u8Buffer));
 80014ee:	2380      	movs	r3, #128	; 0x80
 80014f0:	005a      	lsls	r2, r3, #1
 80014f2:	4bac      	ldr	r3, [pc, #688]	; (80017a4 <GSM_Hardware_Layer_Run+0x328>)
 80014f4:	2100      	movs	r1, #0
 80014f6:	0018      	movs	r0, r3
 80014f8:	f01c fd6c 	bl	801dfd4 <memset>
			m_gsm_atc.atc.Recv_Buffer.index = 0;
 80014fc:	4aa8      	ldr	r2, [pc, #672]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 80014fe:	238f      	movs	r3, #143	; 0x8f
 8001500:	005b      	lsls	r3, r3, #1
 8001502:	2100      	movs	r1, #0
 8001504:	52d1      	strh	r1, [r2, r3]
 8001506:	e051      	b.n	80015ac <GSM_Hardware_Layer_Run+0x130>
		}
		else
		{
			char sub_cmd[64] = "";
 8001508:	1d3b      	adds	r3, r7, #4
 800150a:	2200      	movs	r2, #0
 800150c:	601a      	str	r2, [r3, #0]
 800150e:	3304      	adds	r3, #4
 8001510:	223c      	movs	r2, #60	; 0x3c
 8001512:	2100      	movs	r1, #0
 8001514:	0018      	movs	r0, r3
 8001516:	f01c fd5d 	bl	801dfd4 <memset>
			strncpy(sub_cmd, m_gsm_atc.atc.cmd + 0, strlen(m_gsm_atc.atc.cmd) - 2);
 800151a:	4ba1      	ldr	r3, [pc, #644]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 800151c:	681c      	ldr	r4, [r3, #0]
 800151e:	4ba0      	ldr	r3, [pc, #640]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 8001520:	681b      	ldr	r3, [r3, #0]
 8001522:	0018      	movs	r0, r3
 8001524:	f7fe fdfa 	bl	800011c <strlen>
 8001528:	0003      	movs	r3, r0
 800152a:	1e9a      	subs	r2, r3, #2
 800152c:	1d3b      	adds	r3, r7, #4
 800152e:	0021      	movs	r1, r4
 8001530:	0018      	movs	r0, r3
 8001532:	f01c fe45 	bl	801e1c0 <strncpy>
			DEBUG_WARN("Retry send [%s] %d.\r\n", sub_cmd, m_gsm_atc.atc.Retry_Count_atc);
 8001536:	f01c fcdd 	bl	801def4 <sys_get_tick_ms>
 800153a:	0001      	movs	r1, r0
 800153c:	4b98      	ldr	r3, [pc, #608]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 800153e:	7f1b      	ldrb	r3, [r3, #28]
 8001540:	001c      	movs	r4, r3
 8001542:	1d3b      	adds	r3, r7, #4
 8001544:	4a98      	ldr	r2, [pc, #608]	; (80017a8 <GSM_Hardware_Layer_Run+0x32c>)
 8001546:	4899      	ldr	r0, [pc, #612]	; (80017ac <GSM_Hardware_Layer_Run+0x330>)
 8001548:	9400      	str	r4, [sp, #0]
 800154a:	f000 fe4b 	bl	80021e4 <app_debug_rtt_raw>
			DEBUG_RAW("index = %d\r\n",m_gsm_atc.atc.Recv_Buffer.index);
 800154e:	4a94      	ldr	r2, [pc, #592]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 8001550:	238f      	movs	r3, #143	; 0x8f
 8001552:	005b      	lsls	r3, r3, #1
 8001554:	5ad3      	ldrh	r3, [r2, r3]
 8001556:	001a      	movs	r2, r3
 8001558:	4b95      	ldr	r3, [pc, #596]	; (80017b0 <GSM_Hardware_Layer_Run+0x334>)
 800155a:	0011      	movs	r1, r2
 800155c:	0018      	movs	r0, r3
 800155e:	f000 fe41 	bl	80021e4 <app_debug_rtt_raw>
			DEBUG_RAW("%s\r\n", (char*)m_gsm_atc.atc.Recv_Buffer.u8Buffer);
 8001562:	4a90      	ldr	r2, [pc, #576]	; (80017a4 <GSM_Hardware_Layer_Run+0x328>)
 8001564:	4b93      	ldr	r3, [pc, #588]	; (80017b4 <GSM_Hardware_Layer_Run+0x338>)
 8001566:	0011      	movs	r1, r2
 8001568:	0018      	movs	r0, r3
 800156a:	f000 fe3b 	bl	80021e4 <app_debug_rtt_raw>
			m_gsm_atc.atc.Last_time_send_atc_ms = sys_get_tick_ms();
 800156e:	f01c fcc1 	bl	801def4 <sys_get_tick_ms>
 8001572:	0002      	movs	r2, r0
 8001574:	4b8a      	ldr	r3, [pc, #552]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 8001576:	619a      	str	r2, [r3, #24]
			memset(&m_gsm_atc.atc.Recv_Buffer.u8Buffer, 0, sizeof(m_gsm_atc.atc.Recv_Buffer.u8Buffer));
 8001578:	2380      	movs	r3, #128	; 0x80
 800157a:	005a      	lsls	r2, r3, #1
 800157c:	4b89      	ldr	r3, [pc, #548]	; (80017a4 <GSM_Hardware_Layer_Run+0x328>)
 800157e:	2100      	movs	r1, #0
 8001580:	0018      	movs	r0, r3
 8001582:	f01c fd27 	bl	801dfd4 <memset>
			m_gsm_atc.atc.Recv_Buffer.index = 0;
 8001586:	4a86      	ldr	r2, [pc, #536]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 8001588:	238f      	movs	r3, #143	; 0x8f
 800158a:	005b      	lsls	r3, r3, #1
 800158c:	2100      	movs	r1, #0
 800158e:	52d1      	strh	r1, [r2, r3]
			GSM_UART_TX((uint8_t*) m_gsm_atc.atc.cmd, strlen(m_gsm_atc.atc.cmd), 200);
 8001590:	4b83      	ldr	r3, [pc, #524]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 8001592:	681c      	ldr	r4, [r3, #0]
 8001594:	4b82      	ldr	r3, [pc, #520]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 8001596:	681b      	ldr	r3, [r3, #0]
 8001598:	0018      	movs	r0, r3
 800159a:	f7fe fdbf 	bl	800011c <strlen>
 800159e:	0003      	movs	r3, r0
 80015a0:	b29a      	uxth	r2, r3
 80015a2:	4885      	ldr	r0, [pc, #532]	; (80017b8 <GSM_Hardware_Layer_Run+0x33c>)
 80015a4:	23c8      	movs	r3, #200	; 0xc8
 80015a6:	0021      	movs	r1, r4
 80015a8:	f002 f9f0 	bl	800398c <HAL_UART_Transmit>
		}
	}
	if(strlen(m_gsm_atc.atc.expect_resp) && strstr((char*)m_gsm_atc.atc.Recv_Buffer.u8Buffer, m_gsm_atc.atc.expect_resp))
 80015ac:	4b7c      	ldr	r3, [pc, #496]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 80015ae:	685b      	ldr	r3, [r3, #4]
 80015b0:	781b      	ldrb	r3, [r3, #0]
 80015b2:	2b00      	cmp	r3, #0
 80015b4:	d06f      	beq.n	8001696 <GSM_Hardware_Layer_Run+0x21a>
 80015b6:	4b7a      	ldr	r3, [pc, #488]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 80015b8:	685a      	ldr	r2, [r3, #4]
 80015ba:	4b7a      	ldr	r3, [pc, #488]	; (80017a4 <GSM_Hardware_Layer_Run+0x328>)
 80015bc:	0011      	movs	r1, r2
 80015be:	0018      	movs	r0, r3
 80015c0:	f01c fe12 	bl	801e1e8 <strstr>
 80015c4:	1e03      	subs	r3, r0, #0
 80015c6:	d066      	beq.n	8001696 <GSM_Hardware_Layer_Run+0x21a>
	{
		bool do_callback = true;
 80015c8:	244f      	movs	r4, #79	; 0x4f
 80015ca:	193b      	adds	r3, r7, r4
 80015cc:	2201      	movs	r2, #1
 80015ce:	701a      	strb	r2, [r3, #0]
		if(m_gsm_atc.atc.expected_response_at_the_end && strlen(m_gsm_atc.atc.expected_response_at_the_end))
 80015d0:	4b73      	ldr	r3, [pc, #460]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 80015d2:	689b      	ldr	r3, [r3, #8]
 80015d4:	2b00      	cmp	r3, #0
 80015d6:	d03d      	beq.n	8001654 <GSM_Hardware_Layer_Run+0x1d8>
 80015d8:	4b71      	ldr	r3, [pc, #452]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 80015da:	689b      	ldr	r3, [r3, #8]
 80015dc:	781b      	ldrb	r3, [r3, #0]
 80015de:	2b00      	cmp	r3, #0
 80015e0:	d038      	beq.n	8001654 <GSM_Hardware_Layer_Run+0x1d8>
		{
			Expect_len_compare = strlen(m_gsm_atc.atc.expected_response_at_the_end);
 80015e2:	4b6f      	ldr	r3, [pc, #444]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 80015e4:	689b      	ldr	r3, [r3, #8]
 80015e6:	0018      	movs	r0, r3
 80015e8:	f7fe fd98 	bl	800011c <strlen>
 80015ec:	0002      	movs	r2, r0
 80015ee:	4b73      	ldr	r3, [pc, #460]	; (80017bc <GSM_Hardware_Layer_Run+0x340>)
 80015f0:	601a      	str	r2, [r3, #0]
			Current_Response_len = strlen((char*)m_gsm_atc.atc.Recv_Buffer.u8Buffer);
 80015f2:	4b6c      	ldr	r3, [pc, #432]	; (80017a4 <GSM_Hardware_Layer_Run+0x328>)
 80015f4:	0018      	movs	r0, r3
 80015f6:	f7fe fd91 	bl	800011c <strlen>
 80015fa:	0002      	movs	r2, r0
 80015fc:	4b70      	ldr	r3, [pc, #448]	; (80017c0 <GSM_Hardware_Layer_Run+0x344>)
 80015fe:	601a      	str	r2, [r3, #0]
			if(Expect_len_compare < Current_Response_len)
 8001600:	4b6e      	ldr	r3, [pc, #440]	; (80017bc <GSM_Hardware_Layer_Run+0x340>)
 8001602:	681a      	ldr	r2, [r3, #0]
 8001604:	4b6e      	ldr	r3, [pc, #440]	; (80017c0 <GSM_Hardware_Layer_Run+0x344>)
 8001606:	681b      	ldr	r3, [r3, #0]
 8001608:	429a      	cmp	r2, r3
 800160a:	d21f      	bcs.n	800164c <GSM_Hardware_Layer_Run+0x1d0>
			{
				p_compare_end_str = &m_gsm_atc.atc.Recv_Buffer.u8Buffer[Current_Response_len - Expect_len_compare];
 800160c:	4b6c      	ldr	r3, [pc, #432]	; (80017c0 <GSM_Hardware_Layer_Run+0x344>)
 800160e:	681a      	ldr	r2, [r3, #0]
 8001610:	4b6a      	ldr	r3, [pc, #424]	; (80017bc <GSM_Hardware_Layer_Run+0x340>)
 8001612:	681b      	ldr	r3, [r3, #0]
 8001614:	1ad3      	subs	r3, r2, r3
 8001616:	3318      	adds	r3, #24
 8001618:	001a      	movs	r2, r3
 800161a:	4b61      	ldr	r3, [pc, #388]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 800161c:	18d3      	adds	r3, r2, r3
 800161e:	1d9a      	adds	r2, r3, #6
 8001620:	4b68      	ldr	r3, [pc, #416]	; (80017c4 <GSM_Hardware_Layer_Run+0x348>)
 8001622:	601a      	str	r2, [r3, #0]
				if(memcmp(p_compare_end_str,m_gsm_atc.atc.expected_response_at_the_end,Expect_len_compare) == 0)
 8001624:	4b67      	ldr	r3, [pc, #412]	; (80017c4 <GSM_Hardware_Layer_Run+0x348>)
 8001626:	6818      	ldr	r0, [r3, #0]
 8001628:	4b5d      	ldr	r3, [pc, #372]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 800162a:	6899      	ldr	r1, [r3, #8]
 800162c:	4b63      	ldr	r3, [pc, #396]	; (80017bc <GSM_Hardware_Layer_Run+0x340>)
 800162e:	681b      	ldr	r3, [r3, #0]
 8001630:	001a      	movs	r2, r3
 8001632:	f01c fca5 	bl	801df80 <memcmp>
 8001636:	1e03      	subs	r3, r0, #0
 8001638:	d103      	bne.n	8001642 <GSM_Hardware_Layer_Run+0x1c6>
				{
					// Compare thÃ nh cÃ´ng ÄuÃ´i Response
					do_callback = true;
 800163a:	193b      	adds	r3, r7, r4
 800163c:	2201      	movs	r2, #1
 800163e:	701a      	strb	r2, [r3, #0]
 8001640:	e008      	b.n	8001654 <GSM_Hardware_Layer_Run+0x1d8>
				}
				else
				{
					do_callback = false;
 8001642:	234f      	movs	r3, #79	; 0x4f
 8001644:	18fb      	adds	r3, r7, r3
 8001646:	2200      	movs	r2, #0
 8001648:	701a      	strb	r2, [r3, #0]
 800164a:	e003      	b.n	8001654 <GSM_Hardware_Layer_Run+0x1d8>
				}
			}
			else
			{
				do_callback = false;
 800164c:	234f      	movs	r3, #79	; 0x4f
 800164e:	18fb      	adds	r3, r7, r3
 8001650:	2200      	movs	r2, #0
 8001652:	701a      	strb	r2, [r3, #0]
			}
		}
		if(do_callback == true)
 8001654:	234f      	movs	r3, #79	; 0x4f
 8001656:	18fb      	adds	r3, r7, r3
 8001658:	781b      	ldrb	r3, [r3, #0]
 800165a:	2b00      	cmp	r3, #0
 800165c:	d100      	bne.n	8001660 <GSM_Hardware_Layer_Run+0x1e4>
 800165e:	e092      	b.n	8001786 <GSM_Hardware_Layer_Run+0x30a>
		{
			m_gsm_atc.atc.Timeout_atc_ms = 0;
 8001660:	4b4f      	ldr	r3, [pc, #316]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 8001662:	2200      	movs	r2, #0
 8001664:	615a      	str	r2, [r3, #20]
			m_gsm_atc.atc.Retry_Count_atc = 0;
 8001666:	4b4e      	ldr	r3, [pc, #312]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 8001668:	2200      	movs	r2, #0
 800166a:	771a      	strb	r2, [r3, #28]
			m_gsm_atc.atc.Send_at_Callback(GSM_EVENT_OK,m_gsm_atc.atc.Recv_Buffer.u8Buffer);
 800166c:	4a4c      	ldr	r2, [pc, #304]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 800166e:	2390      	movs	r3, #144	; 0x90
 8001670:	005b      	lsls	r3, r3, #1
 8001672:	58d3      	ldr	r3, [r2, r3]
 8001674:	4a4b      	ldr	r2, [pc, #300]	; (80017a4 <GSM_Hardware_Layer_Run+0x328>)
 8001676:	0011      	movs	r1, r2
 8001678:	2000      	movs	r0, #0
 800167a:	4798      	blx	r3
			memset(&m_gsm_atc.atc.Recv_Buffer.u8Buffer, 0, sizeof(m_gsm_atc.atc.Recv_Buffer.u8Buffer));
 800167c:	2380      	movs	r3, #128	; 0x80
 800167e:	005a      	lsls	r2, r3, #1
 8001680:	4b48      	ldr	r3, [pc, #288]	; (80017a4 <GSM_Hardware_Layer_Run+0x328>)
 8001682:	2100      	movs	r1, #0
 8001684:	0018      	movs	r0, r3
 8001686:	f01c fca5 	bl	801dfd4 <memset>
			m_gsm_atc.atc.Recv_Buffer.index = 0;
 800168a:	4a45      	ldr	r2, [pc, #276]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 800168c:	238f      	movs	r3, #143	; 0x8f
 800168e:	005b      	lsls	r3, r3, #1
 8001690:	2100      	movs	r1, #0
 8001692:	52d1      	strh	r1, [r2, r3]
	{
 8001694:	e077      	b.n	8001786 <GSM_Hardware_Layer_Run+0x30a>
		}

	}
	else if(strlen(m_gsm_atc.atc.expect_error) && strstr((char*)m_gsm_atc.atc.Recv_Buffer.u8Buffer, m_gsm_atc.atc.expect_error))
 8001696:	4b42      	ldr	r3, [pc, #264]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 8001698:	68db      	ldr	r3, [r3, #12]
 800169a:	781b      	ldrb	r3, [r3, #0]
 800169c:	2b00      	cmp	r3, #0
 800169e:	d100      	bne.n	80016a2 <GSM_Hardware_Layer_Run+0x226>
 80016a0:	e072      	b.n	8001788 <GSM_Hardware_Layer_Run+0x30c>
 80016a2:	4b3f      	ldr	r3, [pc, #252]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 80016a4:	68da      	ldr	r2, [r3, #12]
 80016a6:	4b3f      	ldr	r3, [pc, #252]	; (80017a4 <GSM_Hardware_Layer_Run+0x328>)
 80016a8:	0011      	movs	r1, r2
 80016aa:	0018      	movs	r0, r3
 80016ac:	f01c fd9c 	bl	801e1e8 <strstr>
 80016b0:	1e03      	subs	r3, r0, #0
 80016b2:	d069      	beq.n	8001788 <GSM_Hardware_Layer_Run+0x30c>
	{
		bool do_callback = true;
 80016b4:	244e      	movs	r4, #78	; 0x4e
 80016b6:	193b      	adds	r3, r7, r4
 80016b8:	2201      	movs	r2, #1
 80016ba:	701a      	strb	r2, [r3, #0]
		if(m_gsm_atc.atc.expect_error_at_the_end && strlen(m_gsm_atc.atc.expect_error_at_the_end))
 80016bc:	4b38      	ldr	r3, [pc, #224]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 80016be:	691b      	ldr	r3, [r3, #16]
 80016c0:	2b00      	cmp	r3, #0
 80016c2:	d03d      	beq.n	8001740 <GSM_Hardware_Layer_Run+0x2c4>
 80016c4:	4b36      	ldr	r3, [pc, #216]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 80016c6:	691b      	ldr	r3, [r3, #16]
 80016c8:	781b      	ldrb	r3, [r3, #0]
 80016ca:	2b00      	cmp	r3, #0
 80016cc:	d038      	beq.n	8001740 <GSM_Hardware_Layer_Run+0x2c4>
		{
			Expect_len_compare_error_handle = strlen(m_gsm_atc.atc.expect_error_at_the_end);
 80016ce:	4b34      	ldr	r3, [pc, #208]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 80016d0:	691b      	ldr	r3, [r3, #16]
 80016d2:	0018      	movs	r0, r3
 80016d4:	f7fe fd22 	bl	800011c <strlen>
 80016d8:	0002      	movs	r2, r0
 80016da:	4b3b      	ldr	r3, [pc, #236]	; (80017c8 <GSM_Hardware_Layer_Run+0x34c>)
 80016dc:	601a      	str	r2, [r3, #0]
			Current_Response_len_error_handle = strlen((char*)m_gsm_atc.atc.Recv_Buffer.u8Buffer);
 80016de:	4b31      	ldr	r3, [pc, #196]	; (80017a4 <GSM_Hardware_Layer_Run+0x328>)
 80016e0:	0018      	movs	r0, r3
 80016e2:	f7fe fd1b 	bl	800011c <strlen>
 80016e6:	0002      	movs	r2, r0
 80016e8:	4b38      	ldr	r3, [pc, #224]	; (80017cc <GSM_Hardware_Layer_Run+0x350>)
 80016ea:	601a      	str	r2, [r3, #0]
			if(Expect_len_compare_error_handle < Current_Response_len_error_handle)
 80016ec:	4b36      	ldr	r3, [pc, #216]	; (80017c8 <GSM_Hardware_Layer_Run+0x34c>)
 80016ee:	681a      	ldr	r2, [r3, #0]
 80016f0:	4b36      	ldr	r3, [pc, #216]	; (80017cc <GSM_Hardware_Layer_Run+0x350>)
 80016f2:	681b      	ldr	r3, [r3, #0]
 80016f4:	429a      	cmp	r2, r3
 80016f6:	d21f      	bcs.n	8001738 <GSM_Hardware_Layer_Run+0x2bc>
			{
				p_compare_end_str_error_handle = &m_gsm_atc.atc.Recv_Buffer.u8Buffer[Current_Response_len_error_handle - Expect_len_compare_error_handle];
 80016f8:	4b34      	ldr	r3, [pc, #208]	; (80017cc <GSM_Hardware_Layer_Run+0x350>)
 80016fa:	681a      	ldr	r2, [r3, #0]
 80016fc:	4b32      	ldr	r3, [pc, #200]	; (80017c8 <GSM_Hardware_Layer_Run+0x34c>)
 80016fe:	681b      	ldr	r3, [r3, #0]
 8001700:	1ad3      	subs	r3, r2, r3
 8001702:	3318      	adds	r3, #24
 8001704:	001a      	movs	r2, r3
 8001706:	4b26      	ldr	r3, [pc, #152]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 8001708:	18d3      	adds	r3, r2, r3
 800170a:	1d9a      	adds	r2, r3, #6
 800170c:	4b30      	ldr	r3, [pc, #192]	; (80017d0 <GSM_Hardware_Layer_Run+0x354>)
 800170e:	601a      	str	r2, [r3, #0]
				if(memcmp(p_compare_end_str_error_handle,m_gsm_atc.atc.expect_error_at_the_end,Expect_len_compare_error_handle))
 8001710:	4b2f      	ldr	r3, [pc, #188]	; (80017d0 <GSM_Hardware_Layer_Run+0x354>)
 8001712:	6818      	ldr	r0, [r3, #0]
 8001714:	4b22      	ldr	r3, [pc, #136]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 8001716:	6919      	ldr	r1, [r3, #16]
 8001718:	4b2b      	ldr	r3, [pc, #172]	; (80017c8 <GSM_Hardware_Layer_Run+0x34c>)
 800171a:	681b      	ldr	r3, [r3, #0]
 800171c:	001a      	movs	r2, r3
 800171e:	f01c fc2f 	bl	801df80 <memcmp>
 8001722:	1e03      	subs	r3, r0, #0
 8001724:	d003      	beq.n	800172e <GSM_Hardware_Layer_Run+0x2b2>
				{
					// Compare thÃ nh cÃ´ng ÄuÃ´i Response (trÆ°á»ng há»£p Response Error)
					do_callback = true;
 8001726:	193b      	adds	r3, r7, r4
 8001728:	2201      	movs	r2, #1
 800172a:	701a      	strb	r2, [r3, #0]
 800172c:	e008      	b.n	8001740 <GSM_Hardware_Layer_Run+0x2c4>
				}
				else
				{
					do_callback = false;
 800172e:	234e      	movs	r3, #78	; 0x4e
 8001730:	18fb      	adds	r3, r7, r3
 8001732:	2200      	movs	r2, #0
 8001734:	701a      	strb	r2, [r3, #0]
 8001736:	e003      	b.n	8001740 <GSM_Hardware_Layer_Run+0x2c4>
				}
			}
			else
			{
				do_callback = false;
 8001738:	234e      	movs	r3, #78	; 0x4e
 800173a:	18fb      	adds	r3, r7, r3
 800173c:	2200      	movs	r2, #0
 800173e:	701a      	strb	r2, [r3, #0]
			}
		}
		if(do_callback == true)
 8001740:	234e      	movs	r3, #78	; 0x4e
 8001742:	18fb      	adds	r3, r7, r3
 8001744:	781b      	ldrb	r3, [r3, #0]
 8001746:	2b00      	cmp	r3, #0
 8001748:	d01e      	beq.n	8001788 <GSM_Hardware_Layer_Run+0x30c>
		{
			m_gsm_atc.atc.Last_time_send_atc_ms = 0;
 800174a:	4b15      	ldr	r3, [pc, #84]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 800174c:	2200      	movs	r2, #0
 800174e:	619a      	str	r2, [r3, #24]
			m_gsm_atc.atc.Timeout_atc_ms = 0;
 8001750:	4b13      	ldr	r3, [pc, #76]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 8001752:	2200      	movs	r2, #0
 8001754:	615a      	str	r2, [r3, #20]
			m_gsm_atc.atc.Retry_Count_atc = 0;
 8001756:	4b12      	ldr	r3, [pc, #72]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 8001758:	2200      	movs	r2, #0
 800175a:	771a      	strb	r2, [r3, #28]
			m_gsm_atc.atc.Send_at_Callback(GSM_EVENT_ERROR,m_gsm_atc.atc.Recv_Buffer.u8Buffer);
 800175c:	4a10      	ldr	r2, [pc, #64]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 800175e:	2390      	movs	r3, #144	; 0x90
 8001760:	005b      	lsls	r3, r3, #1
 8001762:	58d3      	ldr	r3, [r2, r3]
 8001764:	4a0f      	ldr	r2, [pc, #60]	; (80017a4 <GSM_Hardware_Layer_Run+0x328>)
 8001766:	0011      	movs	r1, r2
 8001768:	2002      	movs	r0, #2
 800176a:	4798      	blx	r3
			memset(&m_gsm_atc.atc.Recv_Buffer.u8Buffer, 0, sizeof(m_gsm_atc.atc.Recv_Buffer.u8Buffer));
 800176c:	2380      	movs	r3, #128	; 0x80
 800176e:	005a      	lsls	r2, r3, #1
 8001770:	4b0c      	ldr	r3, [pc, #48]	; (80017a4 <GSM_Hardware_Layer_Run+0x328>)
 8001772:	2100      	movs	r1, #0
 8001774:	0018      	movs	r0, r3
 8001776:	f01c fc2d 	bl	801dfd4 <memset>
			m_gsm_atc.atc.Recv_Buffer.index = 0;
 800177a:	4a09      	ldr	r2, [pc, #36]	; (80017a0 <GSM_Hardware_Layer_Run+0x324>)
 800177c:	238f      	movs	r3, #143	; 0x8f
 800177e:	005b      	lsls	r3, r3, #1
 8001780:	2100      	movs	r1, #0
 8001782:	52d1      	strh	r1, [r2, r3]
 8001784:	e000      	b.n	8001788 <GSM_Hardware_Layer_Run+0x30c>
	{
 8001786:	46c0      	nop			; (mov r8, r8)
		}
	}
	LastTick = sys_get_tick_ms();
 8001788:	f01c fbb4 	bl	801def4 <sys_get_tick_ms>
 800178c:	0002      	movs	r2, r0
 800178e:	4b03      	ldr	r3, [pc, #12]	; (800179c <GSM_Hardware_Layer_Run+0x320>)
 8001790:	601a      	str	r2, [r3, #0]
 8001792:	e000      	b.n	8001796 <GSM_Hardware_Layer_Run+0x31a>
		return;
 8001794:	46c0      	nop			; (mov r8, r8)
}
 8001796:	46bd      	mov	sp, r7
 8001798:	b015      	add	sp, #84	; 0x54
 800179a:	bd90      	pop	{r4, r7, pc}
 800179c:	20000850 	.word	0x20000850
 80017a0:	20000128 	.word	0x20000128
 80017a4:	20000146 	.word	0x20000146
 80017a8:	0801f3cc 	.word	0x0801f3cc
 80017ac:	0801f3d0 	.word	0x0801f3d0
 80017b0:	0801f400 	.word	0x0801f400
 80017b4:	0801f410 	.word	0x0801f410
 80017b8:	2000103c 	.word	0x2000103c
 80017bc:	200010c8 	.word	0x200010c8
 80017c0:	200010cc 	.word	0x200010cc
 80017c4:	200010e8 	.word	0x200010e8
 80017c8:	200010c4 	.word	0x200010c4
 80017cc:	200010e4 	.word	0x200010e4
 80017d0:	200010d0 	.word	0x200010d0

080017d4 <GSM_Turn_on_Power>:
void GSM_Turn_on_Power(void)
{
 80017d4:	b580      	push	{r7, lr}
 80017d6:	af00      	add	r7, sp, #0
	static uint8_t step;
	DEBUG_INFO("GSM Hard reset step %d.\r\n", step);
 80017d8:	f01c fb8c 	bl	801def4 <sys_get_tick_ms>
 80017dc:	0001      	movs	r1, r0
 80017de:	4b52      	ldr	r3, [pc, #328]	; (8001928 <GSM_Turn_on_Power+0x154>)
 80017e0:	781b      	ldrb	r3, [r3, #0]
 80017e2:	4a52      	ldr	r2, [pc, #328]	; (800192c <GSM_Turn_on_Power+0x158>)
 80017e4:	4852      	ldr	r0, [pc, #328]	; (8001930 <GSM_Turn_on_Power+0x15c>)
 80017e6:	f000 fcfd 	bl	80021e4 <app_debug_rtt_raw>
	switch (step)
 80017ea:	4b4f      	ldr	r3, [pc, #316]	; (8001928 <GSM_Turn_on_Power+0x154>)
 80017ec:	781b      	ldrb	r3, [r3, #0]
 80017ee:	2b07      	cmp	r3, #7
 80017f0:	d900      	bls.n	80017f4 <GSM_Turn_on_Power+0x20>
 80017f2:	e094      	b.n	800191e <GSM_Turn_on_Power+0x14a>
 80017f4:	009a      	lsls	r2, r3, #2
 80017f6:	4b4f      	ldr	r3, [pc, #316]	; (8001934 <GSM_Turn_on_Power+0x160>)
 80017f8:	18d3      	adds	r3, r2, r3
 80017fa:	681b      	ldr	r3, [r3, #0]
 80017fc:	469f      	mov	pc, r3
	{
		case 0:
			HAL_GPIO_WritePin(EN_GSM_GPIO_Port,EN_GSM_Pin,0);
 80017fe:	4b4e      	ldr	r3, [pc, #312]	; (8001938 <GSM_Turn_on_Power+0x164>)
 8001800:	2200      	movs	r2, #0
 8001802:	2140      	movs	r1, #64	; 0x40
 8001804:	0018      	movs	r0, r3
 8001806:	f001 f969 	bl	8002adc <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(GSM_RESET_GPIO_Port,GSM_RESET_Pin,1);
 800180a:	2380      	movs	r3, #128	; 0x80
 800180c:	009b      	lsls	r3, r3, #2
 800180e:	484b      	ldr	r0, [pc, #300]	; (800193c <GSM_Turn_on_Power+0x168>)
 8001810:	2201      	movs	r2, #1
 8001812:	0019      	movs	r1, r3
 8001814:	f001 f962 	bl	8002adc <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(GSM_PWKEY_GPIO_Port,GSM_PWKEY_Pin,0);
 8001818:	2380      	movs	r3, #128	; 0x80
 800181a:	0059      	lsls	r1, r3, #1
 800181c:	23a0      	movs	r3, #160	; 0xa0
 800181e:	05db      	lsls	r3, r3, #23
 8001820:	2200      	movs	r2, #0
 8001822:	0018      	movs	r0, r3
 8001824:	f001 f95a 	bl	8002adc <HAL_GPIO_WritePin>
			step++;
 8001828:	4b3f      	ldr	r3, [pc, #252]	; (8001928 <GSM_Turn_on_Power+0x154>)
 800182a:	781b      	ldrb	r3, [r3, #0]
 800182c:	3301      	adds	r3, #1
 800182e:	b2da      	uxtb	r2, r3
 8001830:	4b3d      	ldr	r3, [pc, #244]	; (8001928 <GSM_Turn_on_Power+0x154>)
 8001832:	701a      	strb	r2, [r3, #0]
			break;
 8001834:	e074      	b.n	8001920 <GSM_Turn_on_Power+0x14c>
		case 1:
			HAL_GPIO_WritePin(GSM_RESET_GPIO_Port,GSM_RESET_Pin,0);
 8001836:	2380      	movs	r3, #128	; 0x80
 8001838:	009b      	lsls	r3, r3, #2
 800183a:	4840      	ldr	r0, [pc, #256]	; (800193c <GSM_Turn_on_Power+0x168>)
 800183c:	2200      	movs	r2, #0
 800183e:	0019      	movs	r1, r3
 8001840:	f001 f94c 	bl	8002adc <HAL_GPIO_WritePin>
			DEBUG_INFO("GSM power on.\r\n");
 8001844:	f01c fb56 	bl	801def4 <sys_get_tick_ms>
 8001848:	0001      	movs	r1, r0
 800184a:	4a38      	ldr	r2, [pc, #224]	; (800192c <GSM_Turn_on_Power+0x158>)
 800184c:	4b3c      	ldr	r3, [pc, #240]	; (8001940 <GSM_Turn_on_Power+0x16c>)
 800184e:	0018      	movs	r0, r3
 8001850:	f000 fcc8 	bl	80021e4 <app_debug_rtt_raw>
			HAL_GPIO_WritePin(EN_GSM_GPIO_Port,EN_GSM_Pin,1);
 8001854:	4b38      	ldr	r3, [pc, #224]	; (8001938 <GSM_Turn_on_Power+0x164>)
 8001856:	2201      	movs	r2, #1
 8001858:	2140      	movs	r1, #64	; 0x40
 800185a:	0018      	movs	r0, r3
 800185c:	f001 f93e 	bl	8002adc <HAL_GPIO_WritePin>
			// Enable nguon 5V
			HAL_GPIO_WritePin(CHARGE_EN_GPIO_Port,CHARGE_EN_Pin,1);
 8001860:	4b35      	ldr	r3, [pc, #212]	; (8001938 <GSM_Turn_on_Power+0x164>)
 8001862:	2201      	movs	r2, #1
 8001864:	2110      	movs	r1, #16
 8001866:	0018      	movs	r0, r3
 8001868:	f001 f938 	bl	8002adc <HAL_GPIO_WritePin>
			// Enable nguon 4.2V
			HAL_GPIO_WritePin(GSM_EN_GPIO_Port,GSM_EN_Pin,1);
 800186c:	2380      	movs	r3, #128	; 0x80
 800186e:	0219      	lsls	r1, r3, #8
 8001870:	23a0      	movs	r3, #160	; 0xa0
 8001872:	05db      	lsls	r3, r3, #23
 8001874:	2201      	movs	r2, #1
 8001876:	0018      	movs	r0, r3
 8001878:	f001 f930 	bl	8002adc <HAL_GPIO_WritePin>
			step++;
 800187c:	4b2a      	ldr	r3, [pc, #168]	; (8001928 <GSM_Turn_on_Power+0x154>)
 800187e:	781b      	ldrb	r3, [r3, #0]
 8001880:	3301      	adds	r3, #1
 8001882:	b2da      	uxtb	r2, r3
 8001884:	4b28      	ldr	r3, [pc, #160]	; (8001928 <GSM_Turn_on_Power+0x154>)
 8001886:	701a      	strb	r2, [r3, #0]
			break;
 8001888:	e04a      	b.n	8001920 <GSM_Turn_on_Power+0x14c>
		case 2:
			step++;
 800188a:	4b27      	ldr	r3, [pc, #156]	; (8001928 <GSM_Turn_on_Power+0x154>)
 800188c:	781b      	ldrb	r3, [r3, #0]
 800188e:	3301      	adds	r3, #1
 8001890:	b2da      	uxtb	r2, r3
 8001892:	4b25      	ldr	r3, [pc, #148]	; (8001928 <GSM_Turn_on_Power+0x154>)
 8001894:	701a      	strb	r2, [r3, #0]
			break;
 8001896:	e043      	b.n	8001920 <GSM_Turn_on_Power+0x14c>
		case 3: 
			/* Generate pulse from (1-0-1) |_| to Power On module */
			DEBUG_INFO("Pulse power key.\r\n");
 8001898:	f01c fb2c 	bl	801def4 <sys_get_tick_ms>
 800189c:	0001      	movs	r1, r0
 800189e:	4a23      	ldr	r2, [pc, #140]	; (800192c <GSM_Turn_on_Power+0x158>)
 80018a0:	4b28      	ldr	r3, [pc, #160]	; (8001944 <GSM_Turn_on_Power+0x170>)
 80018a2:	0018      	movs	r0, r3
 80018a4:	f000 fc9e 	bl	80021e4 <app_debug_rtt_raw>
			HAL_GPIO_WritePin(GSM_PWKEY_GPIO_Port,GSM_PWKEY_Pin,1);
 80018a8:	2380      	movs	r3, #128	; 0x80
 80018aa:	0059      	lsls	r1, r3, #1
 80018ac:	23a0      	movs	r3, #160	; 0xa0
 80018ae:	05db      	lsls	r3, r3, #23
 80018b0:	2201      	movs	r2, #1
 80018b2:	0018      	movs	r0, r3
 80018b4:	f001 f912 	bl	8002adc <HAL_GPIO_WritePin>
			step++;
 80018b8:	4b1b      	ldr	r3, [pc, #108]	; (8001928 <GSM_Turn_on_Power+0x154>)
 80018ba:	781b      	ldrb	r3, [r3, #0]
 80018bc:	3301      	adds	r3, #1
 80018be:	b2da      	uxtb	r2, r3
 80018c0:	4b19      	ldr	r3, [pc, #100]	; (8001928 <GSM_Turn_on_Power+0x154>)
 80018c2:	701a      	strb	r2, [r3, #0]
			break;
 80018c4:	e02c      	b.n	8001920 <GSM_Turn_on_Power+0x14c>
		case 4:
			HAL_GPIO_WritePin(GSM_PWKEY_GPIO_Port,GSM_PWKEY_Pin,0);
 80018c6:	2380      	movs	r3, #128	; 0x80
 80018c8:	0059      	lsls	r1, r3, #1
 80018ca:	23a0      	movs	r3, #160	; 0xa0
 80018cc:	05db      	lsls	r3, r3, #23
 80018ce:	2200      	movs	r2, #0
 80018d0:	0018      	movs	r0, r3
 80018d2:	f001 f903 	bl	8002adc <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(GSM_RESET_GPIO_Port,GSM_RESET_Pin,0);
 80018d6:	2380      	movs	r3, #128	; 0x80
 80018d8:	009b      	lsls	r3, r3, #2
 80018da:	4818      	ldr	r0, [pc, #96]	; (800193c <GSM_Turn_on_Power+0x168>)
 80018dc:	2200      	movs	r2, #0
 80018de:	0019      	movs	r1, r3
 80018e0:	f001 f8fc 	bl	8002adc <HAL_GPIO_WritePin>
			step++;
 80018e4:	4b10      	ldr	r3, [pc, #64]	; (8001928 <GSM_Turn_on_Power+0x154>)
 80018e6:	781b      	ldrb	r3, [r3, #0]
 80018e8:	3301      	adds	r3, #1
 80018ea:	b2da      	uxtb	r2, r3
 80018ec:	4b0e      	ldr	r3, [pc, #56]	; (8001928 <GSM_Turn_on_Power+0x154>)
 80018ee:	701a      	strb	r2, [r3, #0]
			break;
 80018f0:	e016      	b.n	8001920 <GSM_Turn_on_Power+0x14c>
		case 5:
		case 6:
			step++;
 80018f2:	4b0d      	ldr	r3, [pc, #52]	; (8001928 <GSM_Turn_on_Power+0x154>)
 80018f4:	781b      	ldrb	r3, [r3, #0]
 80018f6:	3301      	adds	r3, #1
 80018f8:	b2da      	uxtb	r2, r3
 80018fa:	4b0b      	ldr	r3, [pc, #44]	; (8001928 <GSM_Turn_on_Power+0x154>)
 80018fc:	701a      	strb	r2, [r3, #0]
			break;
 80018fe:	e00f      	b.n	8001920 <GSM_Turn_on_Power+0x14c>
		case 7:
			step = 0;
 8001900:	4b09      	ldr	r3, [pc, #36]	; (8001928 <GSM_Turn_on_Power+0x154>)
 8001902:	2200      	movs	r2, #0
 8001904:	701a      	strb	r2, [r3, #0]
			DEBUG_INFO("GSM Hard reset DONE.\r\n");
 8001906:	f01c faf5 	bl	801def4 <sys_get_tick_ms>
 800190a:	0001      	movs	r1, r0
 800190c:	4a07      	ldr	r2, [pc, #28]	; (800192c <GSM_Turn_on_Power+0x158>)
 800190e:	4b0e      	ldr	r3, [pc, #56]	; (8001948 <GSM_Turn_on_Power+0x174>)
 8001910:	0018      	movs	r0, r3
 8001912:	f000 fc67 	bl	80021e4 <app_debug_rtt_raw>
			GSM_Manager_ChangeState(GSM_STATE_POWER_ON); // GSM turn on Power Finish-> active GSM by AT Cmd
 8001916:	2000      	movs	r0, #0
 8001918:	f7ff fcdc 	bl	80012d4 <GSM_Manager_ChangeState>
			break;
 800191c:	e000      	b.n	8001920 <GSM_Turn_on_Power+0x14c>
		default:
		break;
 800191e:	46c0      	nop			; (mov r8, r8)
	}
}
 8001920:	46c0      	nop			; (mov r8, r8)
 8001922:	46bd      	mov	sp, r7
 8001924:	bd80      	pop	{r7, pc}
 8001926:	46c0      	nop			; (mov r8, r8)
 8001928:	20000854 	.word	0x20000854
 800192c:	0801f3cc 	.word	0x0801f3cc
 8001930:	0801f418 	.word	0x0801f418
 8001934:	08023938 	.word	0x08023938
 8001938:	50000800 	.word	0x50000800
 800193c:	50000400 	.word	0x50000400
 8001940:	0801f44c 	.word	0x0801f44c
 8001944:	0801f478 	.word	0x0801f478
 8001948:	0801f4a4 	.word	0x0801f4a4

0800194c <GSM_SendCommand_AT>:
void GSM_SendCommand_AT (GSM_ATCommand_Table_TypDef AT_Cmd)
{
 800194c:	b084      	sub	sp, #16
 800194e:	b5b0      	push	{r4, r5, r7, lr}
 8001950:	af00      	add	r7, sp, #0
 8001952:	2510      	movs	r5, #16
 8001954:	197c      	adds	r4, r7, r5
 8001956:	6020      	str	r0, [r4, #0]
 8001958:	6061      	str	r1, [r4, #4]
 800195a:	60a2      	str	r2, [r4, #8]
 800195c:	60e3      	str	r3, [r4, #12]
	if(AT_Cmd.Timeout_atc_ms == 0 || AT_Cmd.Send_at_Callback == NULL)
 800195e:	002a      	movs	r2, r5
 8001960:	18bb      	adds	r3, r7, r2
 8001962:	695b      	ldr	r3, [r3, #20]
 8001964:	2b00      	cmp	r3, #0
 8001966:	d003      	beq.n	8001970 <GSM_SendCommand_AT+0x24>
 8001968:	18bb      	adds	r3, r7, r2
 800196a:	69db      	ldr	r3, [r3, #28]
 800196c:	2b00      	cmp	r3, #0
 800196e:	d11b      	bne.n	80019a8 <GSM_SendCommand_AT+0x5c>
	{
		memset(&m_gsm_atc.atc.Recv_Buffer.u8Buffer, 0, sizeof(m_gsm_atc.atc.Recv_Buffer.u8Buffer));
 8001970:	2380      	movs	r3, #128	; 0x80
 8001972:	005a      	lsls	r2, r3, #1
 8001974:	4b33      	ldr	r3, [pc, #204]	; (8001a44 <GSM_SendCommand_AT+0xf8>)
 8001976:	2100      	movs	r1, #0
 8001978:	0018      	movs	r0, r3
 800197a:	f01c fb2b 	bl	801dfd4 <memset>
		m_gsm_atc.atc.Recv_Buffer.index = 0;
 800197e:	4a32      	ldr	r2, [pc, #200]	; (8001a48 <GSM_SendCommand_AT+0xfc>)
 8001980:	238f      	movs	r3, #143	; 0x8f
 8001982:	005b      	lsls	r3, r3, #1
 8001984:	2100      	movs	r1, #0
 8001986:	52d1      	strh	r1, [r2, r3]
		//HAL_UART_Transmit(&huart1, (uint8_t *)AT_Cmd.cmd, strlen(AT_Cmd.cmd), 200);
		GSM_UART_TX((uint8_t *)AT_Cmd.cmd, strlen(AT_Cmd.cmd), 200);
 8001988:	2210      	movs	r2, #16
 800198a:	18bb      	adds	r3, r7, r2
 800198c:	681c      	ldr	r4, [r3, #0]
 800198e:	18bb      	adds	r3, r7, r2
 8001990:	681b      	ldr	r3, [r3, #0]
 8001992:	0018      	movs	r0, r3
 8001994:	f7fe fbc2 	bl	800011c <strlen>
 8001998:	0003      	movs	r3, r0
 800199a:	b29a      	uxth	r2, r3
 800199c:	482b      	ldr	r0, [pc, #172]	; (8001a4c <GSM_SendCommand_AT+0x100>)
 800199e:	23c8      	movs	r3, #200	; 0xc8
 80019a0:	0021      	movs	r1, r4
 80019a2:	f001 fff3 	bl	800398c <HAL_UART_Transmit>
		return;
 80019a6:	e047      	b.n	8001a38 <GSM_SendCommand_AT+0xec>
	}
	if(strlen(AT_Cmd.cmd) < 64)
 80019a8:	2410      	movs	r4, #16
 80019aa:	193b      	adds	r3, r7, r4
 80019ac:	681b      	ldr	r3, [r3, #0]
 80019ae:	0018      	movs	r0, r3
 80019b0:	f7fe fbb4 	bl	800011c <strlen>
	{

	}
	m_gsm_atc.atc.cmd = AT_Cmd.cmd;
 80019b4:	193b      	adds	r3, r7, r4
 80019b6:	681a      	ldr	r2, [r3, #0]
 80019b8:	4b23      	ldr	r3, [pc, #140]	; (8001a48 <GSM_SendCommand_AT+0xfc>)
 80019ba:	601a      	str	r2, [r3, #0]
	m_gsm_atc.atc.expect_resp = AT_Cmd.expect_resp;
 80019bc:	193b      	adds	r3, r7, r4
 80019be:	685a      	ldr	r2, [r3, #4]
 80019c0:	4b21      	ldr	r3, [pc, #132]	; (8001a48 <GSM_SendCommand_AT+0xfc>)
 80019c2:	605a      	str	r2, [r3, #4]
	m_gsm_atc.atc.expected_response_at_the_end = AT_Cmd.expected_response_at_the_end;
 80019c4:	193b      	adds	r3, r7, r4
 80019c6:	689a      	ldr	r2, [r3, #8]
 80019c8:	4b1f      	ldr	r3, [pc, #124]	; (8001a48 <GSM_SendCommand_AT+0xfc>)
 80019ca:	609a      	str	r2, [r3, #8]
	m_gsm_atc.atc.expect_error = AT_Cmd.expect_error;
 80019cc:	193b      	adds	r3, r7, r4
 80019ce:	68da      	ldr	r2, [r3, #12]
 80019d0:	4b1d      	ldr	r3, [pc, #116]	; (8001a48 <GSM_SendCommand_AT+0xfc>)
 80019d2:	60da      	str	r2, [r3, #12]
	m_gsm_atc.atc.expect_error_at_the_end = AT_Cmd.expect_error_at_the_end;
 80019d4:	193b      	adds	r3, r7, r4
 80019d6:	691a      	ldr	r2, [r3, #16]
 80019d8:	4b1b      	ldr	r3, [pc, #108]	; (8001a48 <GSM_SendCommand_AT+0xfc>)
 80019da:	611a      	str	r2, [r3, #16]
	m_gsm_atc.atc.Timeout_atc_ms = AT_Cmd.Timeout_atc_ms;
 80019dc:	193b      	adds	r3, r7, r4
 80019de:	695a      	ldr	r2, [r3, #20]
 80019e0:	4b19      	ldr	r3, [pc, #100]	; (8001a48 <GSM_SendCommand_AT+0xfc>)
 80019e2:	615a      	str	r2, [r3, #20]
	m_gsm_atc.atc.Last_time_send_atc_ms = sys_get_tick_ms();
 80019e4:	f01c fa86 	bl	801def4 <sys_get_tick_ms>
 80019e8:	0002      	movs	r2, r0
 80019ea:	4b17      	ldr	r3, [pc, #92]	; (8001a48 <GSM_SendCommand_AT+0xfc>)
 80019ec:	619a      	str	r2, [r3, #24]
	m_gsm_atc.atc.Retry_Count_atc = AT_Cmd.Retry_Count_atc;
 80019ee:	193b      	adds	r3, r7, r4
 80019f0:	7e1a      	ldrb	r2, [r3, #24]
 80019f2:	4b15      	ldr	r3, [pc, #84]	; (8001a48 <GSM_SendCommand_AT+0xfc>)
 80019f4:	771a      	strb	r2, [r3, #28]
	m_gsm_atc.atc.Send_at_Callback = AT_Cmd.Send_at_Callback;
 80019f6:	193b      	adds	r3, r7, r4
 80019f8:	69d9      	ldr	r1, [r3, #28]
 80019fa:	4a13      	ldr	r2, [pc, #76]	; (8001a48 <GSM_SendCommand_AT+0xfc>)
 80019fc:	2390      	movs	r3, #144	; 0x90
 80019fe:	005b      	lsls	r3, r3, #1
 8001a00:	50d1      	str	r1, [r2, r3]

	memset(&m_gsm_atc.atc.Recv_Buffer.u8Buffer, 0, sizeof(m_gsm_atc.atc.Recv_Buffer.u8Buffer));
 8001a02:	2380      	movs	r3, #128	; 0x80
 8001a04:	005a      	lsls	r2, r3, #1
 8001a06:	4b0f      	ldr	r3, [pc, #60]	; (8001a44 <GSM_SendCommand_AT+0xf8>)
 8001a08:	2100      	movs	r1, #0
 8001a0a:	0018      	movs	r0, r3
 8001a0c:	f01c fae2 	bl	801dfd4 <memset>
	m_gsm_atc.atc.Recv_Buffer.index = 0;
 8001a10:	4a0d      	ldr	r2, [pc, #52]	; (8001a48 <GSM_SendCommand_AT+0xfc>)
 8001a12:	238f      	movs	r3, #143	; 0x8f
 8001a14:	005b      	lsls	r3, r3, #1
 8001a16:	2100      	movs	r1, #0
 8001a18:	52d1      	strh	r1, [r2, r3]
	//HAL_UART_Transmit(&huart1, (uint8_t *)AT_Cmd.cmd, strlen(AT_Cmd.cmd), 200);
	GSM_UART_TX((uint8_t *)AT_Cmd.cmd, strlen(AT_Cmd.cmd), 200);
 8001a1a:	0022      	movs	r2, r4
 8001a1c:	18bb      	adds	r3, r7, r2
 8001a1e:	681c      	ldr	r4, [r3, #0]
 8001a20:	18bb      	adds	r3, r7, r2
 8001a22:	681b      	ldr	r3, [r3, #0]
 8001a24:	0018      	movs	r0, r3
 8001a26:	f7fe fb79 	bl	800011c <strlen>
 8001a2a:	0003      	movs	r3, r0
 8001a2c:	b29a      	uxth	r2, r3
 8001a2e:	4807      	ldr	r0, [pc, #28]	; (8001a4c <GSM_SendCommand_AT+0x100>)
 8001a30:	23c8      	movs	r3, #200	; 0xc8
 8001a32:	0021      	movs	r1, r4
 8001a34:	f001 ffaa 	bl	800398c <HAL_UART_Transmit>

}
 8001a38:	46bd      	mov	sp, r7
 8001a3a:	bcb0      	pop	{r4, r5, r7}
 8001a3c:	bc08      	pop	{r3}
 8001a3e:	b004      	add	sp, #16
 8001a40:	4718      	bx	r3
 8001a42:	46c0      	nop			; (mov r8, r8)
 8001a44:	20000146 	.word	0x20000146
 8001a48:	20000128 	.word	0x20000128
 8001a4c:	2000103c 	.word	0x2000103c

08001a50 <sio_read>:
uint32_t sio_read(sio_fd_t fd, u8_t *data, u32_t len)
{
 8001a50:	b580      	push	{r7, lr}
 8001a52:	b084      	sub	sp, #16
 8001a54:	af00      	add	r7, sp, #0
 8001a56:	60f8      	str	r0, [r7, #12]
 8001a58:	60b9      	str	r1, [r7, #8]
 8001a5a:	607a      	str	r2, [r7, #4]
    return GSM_Hardware_layer_Copy_ppp_Buffer(data, len);
 8001a5c:	687a      	ldr	r2, [r7, #4]
 8001a5e:	68bb      	ldr	r3, [r7, #8]
 8001a60:	0011      	movs	r1, r2
 8001a62:	0018      	movs	r0, r3
 8001a64:	f000 f8f8 	bl	8001c58 <GSM_Hardware_layer_Copy_ppp_Buffer>
 8001a68:	0003      	movs	r3, r0
}
 8001a6a:	0018      	movs	r0, r3
 8001a6c:	46bd      	mov	sp, r7
 8001a6e:	b004      	add	sp, #16
 8001a70:	bd80      	pop	{r7, pc}
	...

08001a74 <GSM_Hardware_pppos_Polling>:
static uint8_t m_ppp_rx_buffer[512];
void GSM_Hardware_pppos_Polling(void)
{
 8001a74:	b590      	push	{r4, r7, lr}
 8001a76:	4c26      	ldr	r4, [pc, #152]	; (8001b10 <GSM_Hardware_pppos_Polling+0x9c>)
 8001a78:	44a5      	add	sp, r4
 8001a7a:	af00      	add	r7, sp, #0
    uint32_t sio_size;
    sys_check_timeouts();
 8001a7c:	f011 f854 	bl	8012b28 <sys_check_timeouts>
	uint8_t buffer[512] = {0};
 8001a80:	4b24      	ldr	r3, [pc, #144]	; (8001b14 <GSM_Hardware_pppos_Polling+0xa0>)
 8001a82:	2282      	movs	r2, #130	; 0x82
 8001a84:	0092      	lsls	r2, r2, #2
 8001a86:	4694      	mov	ip, r2
 8001a88:	44bc      	add	ip, r7
 8001a8a:	4463      	add	r3, ip
 8001a8c:	2200      	movs	r2, #0
 8001a8e:	601a      	str	r2, [r3, #0]
 8001a90:	3304      	adds	r3, #4
 8001a92:	22fe      	movs	r2, #254	; 0xfe
 8001a94:	0052      	lsls	r2, r2, #1
 8001a96:	2100      	movs	r1, #0
 8001a98:	0018      	movs	r0, r3
 8001a9a:	f01c fa9b 	bl	801dfd4 <memset>
	uint16_t dataLength = 0;
 8001a9e:	4b1e      	ldr	r3, [pc, #120]	; (8001b18 <GSM_Hardware_pppos_Polling+0xa4>)
 8001aa0:	2282      	movs	r2, #130	; 0x82
 8001aa2:	0092      	lsls	r2, r2, #2
 8001aa4:	4694      	mov	ip, r2
 8001aa6:	44bc      	add	ip, r7
 8001aa8:	4463      	add	r3, ip
 8001aaa:	2200      	movs	r2, #0
 8001aac:	801a      	strh	r2, [r3, #0]

	RingBuffer_GetBuffer(buffer, &dataLength, &Rx_Buffer);
 8001aae:	4a1b      	ldr	r2, [pc, #108]	; (8001b1c <GSM_Hardware_pppos_Polling+0xa8>)
 8001ab0:	1cb9      	adds	r1, r7, #2
 8001ab2:	1d3b      	adds	r3, r7, #4
 8001ab4:	0018      	movs	r0, r3
 8001ab6:	f000 fc4c 	bl	8002352 <RingBuffer_GetBuffer>
	GSM_HwLayer_Fill_Rx_Buffer(buffer, dataLength);
 8001aba:	4b17      	ldr	r3, [pc, #92]	; (8001b18 <GSM_Hardware_pppos_Polling+0xa4>)
 8001abc:	2282      	movs	r2, #130	; 0x82
 8001abe:	0092      	lsls	r2, r2, #2
 8001ac0:	4694      	mov	ip, r2
 8001ac2:	44bc      	add	ip, r7
 8001ac4:	4463      	add	r3, ip
 8001ac6:	881b      	ldrh	r3, [r3, #0]
 8001ac8:	001a      	movs	r2, r3
 8001aca:	1d3b      	adds	r3, r7, #4
 8001acc:	0011      	movs	r1, r2
 8001ace:	0018      	movs	r0, r3
 8001ad0:	f000 f84a 	bl	8001b68 <GSM_HwLayer_Fill_Rx_Buffer>

    sio_size = sio_read(0, m_ppp_rx_buffer, 512);
 8001ad4:	2380      	movs	r3, #128	; 0x80
 8001ad6:	009a      	lsls	r2, r3, #2
 8001ad8:	4b11      	ldr	r3, [pc, #68]	; (8001b20 <GSM_Hardware_pppos_Polling+0xac>)
 8001ada:	0019      	movs	r1, r3
 8001adc:	2000      	movs	r0, #0
 8001ade:	f7ff ffb7 	bl	8001a50 <sio_read>
 8001ae2:	0003      	movs	r3, r0
 8001ae4:	2481      	movs	r4, #129	; 0x81
 8001ae6:	00a4      	lsls	r4, r4, #2
 8001ae8:	193a      	adds	r2, r7, r4
 8001aea:	6013      	str	r3, [r2, #0]
	if(sio_size > 0)
 8001aec:	193b      	adds	r3, r7, r4
 8001aee:	681b      	ldr	r3, [r3, #0]
 8001af0:	2b00      	cmp	r3, #0
 8001af2:	d007      	beq.n	8001b04 <GSM_Hardware_pppos_Polling+0x90>
	{
		// Bypass data into ppp stack
		pppos_input(gsm_data_layer_get_ppp_control_block(), m_ppp_rx_buffer, sio_size);
 8001af4:	f7ff f9f0 	bl	8000ed8 <gsm_data_layer_get_ppp_control_block>
 8001af8:	193b      	adds	r3, r7, r4
 8001afa:	681a      	ldr	r2, [r3, #0]
 8001afc:	4b08      	ldr	r3, [pc, #32]	; (8001b20 <GSM_Hardware_pppos_Polling+0xac>)
 8001afe:	0019      	movs	r1, r3
 8001b00:	f019 faaa 	bl	801b058 <pppos_input>
	}

}
 8001b04:	46c0      	nop			; (mov r8, r8)
 8001b06:	46bd      	mov	sp, r7
 8001b08:	2383      	movs	r3, #131	; 0x83
 8001b0a:	009b      	lsls	r3, r3, #2
 8001b0c:	449d      	add	sp, r3
 8001b0e:	bd90      	pop	{r4, r7, pc}
 8001b10:	fffffdf4 	.word	0xfffffdf4
 8001b14:	fffffdfc 	.word	0xfffffdfc
 8001b18:	fffffdfa 	.word	0xfffffdfa
 8001b1c:	200010d4 	.word	0x200010d4
 8001b20:	20000650 	.word	0x20000650

08001b24 <GSM_HwLayer_Reset_Rx_Buffer>:
void GSM_HwLayer_Reset_Rx_Buffer(void)
{
 8001b24:	b580      	push	{r7, lr}
 8001b26:	af00      	add	r7, sp, #0
	memset(&m_gsm_atc.atc.Recv_Buffer.u8Buffer, 0, sizeof(m_gsm_atc.atc.Recv_Buffer.u8Buffer));
 8001b28:	2380      	movs	r3, #128	; 0x80
 8001b2a:	005a      	lsls	r2, r3, #1
 8001b2c:	4b0a      	ldr	r3, [pc, #40]	; (8001b58 <GSM_HwLayer_Reset_Rx_Buffer+0x34>)
 8001b2e:	2100      	movs	r1, #0
 8001b30:	0018      	movs	r0, r3
 8001b32:	f01c fa4f 	bl	801dfd4 <memset>
	m_gsm_atc.atc.Recv_Buffer.index = 0;
 8001b36:	4a09      	ldr	r2, [pc, #36]	; (8001b5c <GSM_HwLayer_Reset_Rx_Buffer+0x38>)
 8001b38:	238f      	movs	r3, #143	; 0x8f
 8001b3a:	005b      	lsls	r3, r3, #1
 8001b3c:	2100      	movs	r1, #0
 8001b3e:	52d1      	strh	r1, [r2, r3]
	memset(&m_gsm_modem_buffer, 0, sizeof(m_gsm_modem_buffer));
 8001b40:	4a07      	ldr	r2, [pc, #28]	; (8001b60 <GSM_HwLayer_Reset_Rx_Buffer+0x3c>)
 8001b42:	4b08      	ldr	r3, [pc, #32]	; (8001b64 <GSM_HwLayer_Reset_Rx_Buffer+0x40>)
 8001b44:	2100      	movs	r1, #0
 8001b46:	0018      	movs	r0, r3
 8001b48:	f01c fa44 	bl	801dfd4 <memset>
	m_gsm_atc.atc.Retry_Count_atc = 0;
 8001b4c:	4b03      	ldr	r3, [pc, #12]	; (8001b5c <GSM_HwLayer_Reset_Rx_Buffer+0x38>)
 8001b4e:	2200      	movs	r2, #0
 8001b50:	771a      	strb	r2, [r3, #28]
}
 8001b52:	46c0      	nop			; (mov r8, r8)
 8001b54:	46bd      	mov	sp, r7
 8001b56:	bd80      	pop	{r7, pc}
 8001b58:	20000146 	.word	0x20000146
 8001b5c:	20000128 	.word	0x20000128
 8001b60:	00000404 	.word	0x00000404
 8001b64:	2000024c 	.word	0x2000024c

08001b68 <GSM_HwLayer_Fill_Rx_Buffer>:
void GSM_HwLayer_Fill_Rx_Buffer(uint8_t* data, uint32_t length)
{
 8001b68:	b580      	push	{r7, lr}
 8001b6a:	b084      	sub	sp, #16
 8001b6c:	af00      	add	r7, sp, #0
 8001b6e:	6078      	str	r0, [r7, #4]
 8001b70:	6039      	str	r1, [r7, #0]
	if(length)
 8001b72:	683b      	ldr	r3, [r7, #0]
 8001b74:	2b00      	cmp	r3, #0
 8001b76:	d063      	beq.n	8001c40 <GSM_HwLayer_Fill_Rx_Buffer+0xd8>
	{
		// Device do not enter AT mode =>> bypass data into PPP stack
		if(gsm_is_in_ppp_mode())
 8001b78:	f7ff fb94 	bl	80012a4 <gsm_is_in_ppp_mode>
 8001b7c:	1e03      	subs	r3, r0, #0
 8001b7e:	d028      	beq.n	8001bd2 <GSM_HwLayer_Fill_Rx_Buffer+0x6a>
		{
			for(int CountByte = 0; CountByte < length; CountByte ++)
 8001b80:	2300      	movs	r3, #0
 8001b82:	60fb      	str	r3, [r7, #12]
 8001b84:	e010      	b.n	8001ba8 <GSM_HwLayer_Fill_Rx_Buffer+0x40>
			{
				m_gsm_modem_buffer.u8Buffer[m_gsm_modem_buffer.idx_in++] = data[CountByte];
 8001b86:	68fb      	ldr	r3, [r7, #12]
 8001b88:	687a      	ldr	r2, [r7, #4]
 8001b8a:	18d2      	adds	r2, r2, r3
 8001b8c:	4b2e      	ldr	r3, [pc, #184]	; (8001c48 <GSM_HwLayer_Fill_Rx_Buffer+0xe0>)
 8001b8e:	881b      	ldrh	r3, [r3, #0]
 8001b90:	1c59      	adds	r1, r3, #1
 8001b92:	b288      	uxth	r0, r1
 8001b94:	492c      	ldr	r1, [pc, #176]	; (8001c48 <GSM_HwLayer_Fill_Rx_Buffer+0xe0>)
 8001b96:	8008      	strh	r0, [r1, #0]
 8001b98:	0019      	movs	r1, r3
 8001b9a:	7812      	ldrb	r2, [r2, #0]
 8001b9c:	4b2a      	ldr	r3, [pc, #168]	; (8001c48 <GSM_HwLayer_Fill_Rx_Buffer+0xe0>)
 8001b9e:	185b      	adds	r3, r3, r1
 8001ba0:	711a      	strb	r2, [r3, #4]
			for(int CountByte = 0; CountByte < length; CountByte ++)
 8001ba2:	68fb      	ldr	r3, [r7, #12]
 8001ba4:	3301      	adds	r3, #1
 8001ba6:	60fb      	str	r3, [r7, #12]
 8001ba8:	68fb      	ldr	r3, [r7, #12]
 8001baa:	683a      	ldr	r2, [r7, #0]
 8001bac:	429a      	cmp	r2, r3
 8001bae:	d8ea      	bhi.n	8001b86 <GSM_HwLayer_Fill_Rx_Buffer+0x1e>
			}
			if(m_gsm_modem_buffer.idx_in >= GSM_PPP_MODEM_BUFFER_SIZE)
 8001bb0:	4b25      	ldr	r3, [pc, #148]	; (8001c48 <GSM_HwLayer_Fill_Rx_Buffer+0xe0>)
 8001bb2:	881a      	ldrh	r2, [r3, #0]
 8001bb4:	2380      	movs	r3, #128	; 0x80
 8001bb6:	00db      	lsls	r3, r3, #3
 8001bb8:	429a      	cmp	r2, r3
 8001bba:	d302      	bcc.n	8001bc2 <GSM_HwLayer_Fill_Rx_Buffer+0x5a>
			{
				m_gsm_modem_buffer.idx_in = 0;
 8001bbc:	4b22      	ldr	r3, [pc, #136]	; (8001c48 <GSM_HwLayer_Fill_Rx_Buffer+0xe0>)
 8001bbe:	2200      	movs	r2, #0
 8001bc0:	801a      	strh	r2, [r3, #0]
			}
			m_gsm_modem_buffer.u8Buffer[m_gsm_modem_buffer.idx_in] = 0;
 8001bc2:	4b21      	ldr	r3, [pc, #132]	; (8001c48 <GSM_HwLayer_Fill_Rx_Buffer+0xe0>)
 8001bc4:	881b      	ldrh	r3, [r3, #0]
 8001bc6:	001a      	movs	r2, r3
 8001bc8:	4b1f      	ldr	r3, [pc, #124]	; (8001c48 <GSM_HwLayer_Fill_Rx_Buffer+0xe0>)
 8001bca:	189b      	adds	r3, r3, r2
 8001bcc:	2200      	movs	r2, #0
 8001bce:	711a      	strb	r2, [r3, #4]
 8001bd0:	e036      	b.n	8001c40 <GSM_HwLayer_Fill_Rx_Buffer+0xd8>
		}
		else
		{
			for(int CountByte = 0; CountByte < length; CountByte ++)
 8001bd2:	2300      	movs	r3, #0
 8001bd4:	60bb      	str	r3, [r7, #8]
 8001bd6:	e02f      	b.n	8001c38 <GSM_HwLayer_Fill_Rx_Buffer+0xd0>
			{
				m_gsm_atc.atc.Recv_Buffer.u8Buffer[m_gsm_atc.atc.Recv_Buffer.index] = data[CountByte];
 8001bd8:	68bb      	ldr	r3, [r7, #8]
 8001bda:	687a      	ldr	r2, [r7, #4]
 8001bdc:	18d3      	adds	r3, r2, r3
 8001bde:	491b      	ldr	r1, [pc, #108]	; (8001c4c <GSM_HwLayer_Fill_Rx_Buffer+0xe4>)
 8001be0:	228f      	movs	r2, #143	; 0x8f
 8001be2:	0052      	lsls	r2, r2, #1
 8001be4:	5a8a      	ldrh	r2, [r1, r2]
 8001be6:	0011      	movs	r1, r2
 8001be8:	781a      	ldrb	r2, [r3, #0]
 8001bea:	4b18      	ldr	r3, [pc, #96]	; (8001c4c <GSM_HwLayer_Fill_Rx_Buffer+0xe4>)
 8001bec:	185b      	adds	r3, r3, r1
 8001bee:	779a      	strb	r2, [r3, #30]
				m_gsm_atc.atc.Recv_Buffer.index ++;
 8001bf0:	4a16      	ldr	r2, [pc, #88]	; (8001c4c <GSM_HwLayer_Fill_Rx_Buffer+0xe4>)
 8001bf2:	238f      	movs	r3, #143	; 0x8f
 8001bf4:	005b      	lsls	r3, r3, #1
 8001bf6:	5ad3      	ldrh	r3, [r2, r3]
 8001bf8:	3301      	adds	r3, #1
 8001bfa:	b299      	uxth	r1, r3
 8001bfc:	4a13      	ldr	r2, [pc, #76]	; (8001c4c <GSM_HwLayer_Fill_Rx_Buffer+0xe4>)
 8001bfe:	238f      	movs	r3, #143	; 0x8f
 8001c00:	005b      	lsls	r3, r3, #1
 8001c02:	52d1      	strh	r1, [r2, r3]
				if(m_gsm_atc.atc.Recv_Buffer.index >= GSM_ATC_BUFFER_SIZE)
 8001c04:	4a11      	ldr	r2, [pc, #68]	; (8001c4c <GSM_HwLayer_Fill_Rx_Buffer+0xe4>)
 8001c06:	238f      	movs	r3, #143	; 0x8f
 8001c08:	005b      	lsls	r3, r3, #1
 8001c0a:	5ad3      	ldrh	r3, [r2, r3]
 8001c0c:	2bff      	cmp	r3, #255	; 0xff
 8001c0e:	d910      	bls.n	8001c32 <GSM_HwLayer_Fill_Rx_Buffer+0xca>
				{
					DEBUG_ERROR("GSM ATC RX Buffer out of range!\r\n");
 8001c10:	f01c f970 	bl	801def4 <sys_get_tick_ms>
 8001c14:	0001      	movs	r1, r0
 8001c16:	4a0e      	ldr	r2, [pc, #56]	; (8001c50 <GSM_HwLayer_Fill_Rx_Buffer+0xe8>)
 8001c18:	4b0e      	ldr	r3, [pc, #56]	; (8001c54 <GSM_HwLayer_Fill_Rx_Buffer+0xec>)
 8001c1a:	0018      	movs	r0, r3
 8001c1c:	f000 fae2 	bl	80021e4 <app_debug_rtt_raw>
                    m_gsm_atc.atc.Recv_Buffer.index = 0;
 8001c20:	4a0a      	ldr	r2, [pc, #40]	; (8001c4c <GSM_HwLayer_Fill_Rx_Buffer+0xe4>)
 8001c22:	238f      	movs	r3, #143	; 0x8f
 8001c24:	005b      	lsls	r3, r3, #1
 8001c26:	2100      	movs	r1, #0
 8001c28:	52d1      	strh	r1, [r2, r3]
                    m_gsm_atc.atc.Recv_Buffer.u8Buffer[0] = 0;
 8001c2a:	4b08      	ldr	r3, [pc, #32]	; (8001c4c <GSM_HwLayer_Fill_Rx_Buffer+0xe4>)
 8001c2c:	2200      	movs	r2, #0
 8001c2e:	779a      	strb	r2, [r3, #30]
                    return;
 8001c30:	e006      	b.n	8001c40 <GSM_HwLayer_Fill_Rx_Buffer+0xd8>
			for(int CountByte = 0; CountByte < length; CountByte ++)
 8001c32:	68bb      	ldr	r3, [r7, #8]
 8001c34:	3301      	adds	r3, #1
 8001c36:	60bb      	str	r3, [r7, #8]
 8001c38:	68bb      	ldr	r3, [r7, #8]
 8001c3a:	683a      	ldr	r2, [r7, #0]
 8001c3c:	429a      	cmp	r2, r3
 8001c3e:	d8cb      	bhi.n	8001bd8 <GSM_HwLayer_Fill_Rx_Buffer+0x70>
				}
			}
		}
	}
}
 8001c40:	46bd      	mov	sp, r7
 8001c42:	b004      	add	sp, #16
 8001c44:	bd80      	pop	{r7, pc}
 8001c46:	46c0      	nop			; (mov r8, r8)
 8001c48:	2000024c 	.word	0x2000024c
 8001c4c:	20000128 	.word	0x20000128
 8001c50:	0801f3cc 	.word	0x0801f3cc
 8001c54:	0801f4d4 	.word	0x0801f4d4

08001c58 <GSM_Hardware_layer_Copy_ppp_Buffer>:
uint32_t GSM_Hardware_layer_Copy_ppp_Buffer(uint8_t* data, uint32_t length)
{
 8001c58:	b580      	push	{r7, lr}
 8001c5a:	b084      	sub	sp, #16
 8001c5c:	af00      	add	r7, sp, #0
 8001c5e:	6078      	str	r0, [r7, #4]
 8001c60:	6039      	str	r1, [r7, #0]
	int CountByte = 0;
 8001c62:	2300      	movs	r3, #0
 8001c64:	60fb      	str	r3, [r7, #12]
	for(CountByte = 0; CountByte < length; CountByte++)
 8001c66:	2300      	movs	r3, #0
 8001c68:	60fb      	str	r3, [r7, #12]
 8001c6a:	e023      	b.n	8001cb4 <GSM_Hardware_layer_Copy_ppp_Buffer+0x5c>
	{
		if(m_gsm_modem_buffer.idx_out == m_gsm_modem_buffer.idx_in)
 8001c6c:	4b16      	ldr	r3, [pc, #88]	; (8001cc8 <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001c6e:	885a      	ldrh	r2, [r3, #2]
 8001c70:	4b15      	ldr	r3, [pc, #84]	; (8001cc8 <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001c72:	881b      	ldrh	r3, [r3, #0]
 8001c74:	429a      	cmp	r2, r3
 8001c76:	d101      	bne.n	8001c7c <GSM_Hardware_layer_Copy_ppp_Buffer+0x24>
		{
			return CountByte; // Da quet het Buffer Modem
 8001c78:	68fb      	ldr	r3, [r7, #12]
 8001c7a:	e020      	b.n	8001cbe <GSM_Hardware_layer_Copy_ppp_Buffer+0x66>
		}
		data[CountByte] = m_gsm_modem_buffer.u8Buffer[m_gsm_modem_buffer.idx_out];
 8001c7c:	4b12      	ldr	r3, [pc, #72]	; (8001cc8 <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001c7e:	885b      	ldrh	r3, [r3, #2]
 8001c80:	0019      	movs	r1, r3
 8001c82:	68fb      	ldr	r3, [r7, #12]
 8001c84:	687a      	ldr	r2, [r7, #4]
 8001c86:	18d3      	adds	r3, r2, r3
 8001c88:	4a0f      	ldr	r2, [pc, #60]	; (8001cc8 <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001c8a:	1852      	adds	r2, r2, r1
 8001c8c:	7912      	ldrb	r2, [r2, #4]
 8001c8e:	701a      	strb	r2, [r3, #0]
		m_gsm_modem_buffer.idx_out ++;
 8001c90:	4b0d      	ldr	r3, [pc, #52]	; (8001cc8 <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001c92:	885b      	ldrh	r3, [r3, #2]
 8001c94:	3301      	adds	r3, #1
 8001c96:	b29a      	uxth	r2, r3
 8001c98:	4b0b      	ldr	r3, [pc, #44]	; (8001cc8 <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001c9a:	805a      	strh	r2, [r3, #2]
		if(m_gsm_modem_buffer.idx_out >= GSM_PPP_MODEM_BUFFER_SIZE)
 8001c9c:	4b0a      	ldr	r3, [pc, #40]	; (8001cc8 <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001c9e:	885a      	ldrh	r2, [r3, #2]
 8001ca0:	2380      	movs	r3, #128	; 0x80
 8001ca2:	00db      	lsls	r3, r3, #3
 8001ca4:	429a      	cmp	r2, r3
 8001ca6:	d302      	bcc.n	8001cae <GSM_Hardware_layer_Copy_ppp_Buffer+0x56>
		{
			m_gsm_modem_buffer.idx_out = 0;
 8001ca8:	4b07      	ldr	r3, [pc, #28]	; (8001cc8 <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001caa:	2200      	movs	r2, #0
 8001cac:	805a      	strh	r2, [r3, #2]
	for(CountByte = 0; CountByte < length; CountByte++)
 8001cae:	68fb      	ldr	r3, [r7, #12]
 8001cb0:	3301      	adds	r3, #1
 8001cb2:	60fb      	str	r3, [r7, #12]
 8001cb4:	68fb      	ldr	r3, [r7, #12]
 8001cb6:	683a      	ldr	r2, [r7, #0]
 8001cb8:	429a      	cmp	r2, r3
 8001cba:	d8d7      	bhi.n	8001c6c <GSM_Hardware_layer_Copy_ppp_Buffer+0x14>
		}
	}
	return CountByte;
 8001cbc:	68fb      	ldr	r3, [r7, #12]
}
 8001cbe:	0018      	movs	r0, r3
 8001cc0:	46bd      	mov	sp, r7
 8001cc2:	b004      	add	sp, #16
 8001cc4:	bd80      	pop	{r7, pc}
 8001cc6:	46c0      	nop			; (mov r8, r8)
 8001cc8:	2000024c 	.word	0x2000024c

08001ccc <GSM_Utilities_Get_IMEI>:
#include "gsm_utilities.h"

void GSM_Utilities_Get_IMEI(uint8_t *recv_Buffer, uint8_t* IMEI_Buffer, uint8_t Max_IMEI_Length)
{
 8001ccc:	b580      	push	{r7, lr}
 8001cce:	b086      	sub	sp, #24
 8001cd0:	af00      	add	r7, sp, #0
 8001cd2:	60f8      	str	r0, [r7, #12]
 8001cd4:	60b9      	str	r1, [r7, #8]
 8001cd6:	1dfb      	adds	r3, r7, #7
 8001cd8:	701a      	strb	r2, [r3, #0]
    int IMEI_Index = 0;
 8001cda:	2300      	movs	r3, #0
 8001cdc:	617b      	str	r3, [r7, #20]
    for(int CountByte = 0; CountByte < strlen((char*)recv_Buffer); CountByte++)
 8001cde:	2300      	movs	r3, #0
 8001ce0:	613b      	str	r3, [r7, #16]
 8001ce2:	e025      	b.n	8001d30 <GSM_Utilities_Get_IMEI+0x64>
    {
        if((recv_Buffer[CountByte] >= '0') && (recv_Buffer[CountByte] <= '9'))
 8001ce4:	693b      	ldr	r3, [r7, #16]
 8001ce6:	68fa      	ldr	r2, [r7, #12]
 8001ce8:	18d3      	adds	r3, r2, r3
 8001cea:	781b      	ldrb	r3, [r3, #0]
 8001cec:	2b2f      	cmp	r3, #47	; 0x2f
 8001cee:	d91c      	bls.n	8001d2a <GSM_Utilities_Get_IMEI+0x5e>
 8001cf0:	693b      	ldr	r3, [r7, #16]
 8001cf2:	68fa      	ldr	r2, [r7, #12]
 8001cf4:	18d3      	adds	r3, r2, r3
 8001cf6:	781b      	ldrb	r3, [r3, #0]
 8001cf8:	2b39      	cmp	r3, #57	; 0x39
 8001cfa:	d816      	bhi.n	8001d2a <GSM_Utilities_Get_IMEI+0x5e>
        {
            if(IMEI_Index < Max_IMEI_Length)
 8001cfc:	1dfb      	adds	r3, r7, #7
 8001cfe:	781b      	ldrb	r3, [r3, #0]
 8001d00:	697a      	ldr	r2, [r7, #20]
 8001d02:	429a      	cmp	r2, r3
 8001d04:	da0b      	bge.n	8001d1e <GSM_Utilities_Get_IMEI+0x52>
            {
                IMEI_Buffer[IMEI_Index++] = recv_Buffer[CountByte];
 8001d06:	693b      	ldr	r3, [r7, #16]
 8001d08:	68fa      	ldr	r2, [r7, #12]
 8001d0a:	18d2      	adds	r2, r2, r3
 8001d0c:	697b      	ldr	r3, [r7, #20]
 8001d0e:	1c59      	adds	r1, r3, #1
 8001d10:	6179      	str	r1, [r7, #20]
 8001d12:	0019      	movs	r1, r3
 8001d14:	68bb      	ldr	r3, [r7, #8]
 8001d16:	185b      	adds	r3, r3, r1
 8001d18:	7812      	ldrb	r2, [r2, #0]
 8001d1a:	701a      	strb	r2, [r3, #0]
 8001d1c:	e005      	b.n	8001d2a <GSM_Utilities_Get_IMEI+0x5e>
            }
            else
            {
                IMEI_Buffer[IMEI_Index] = 0;
 8001d1e:	697b      	ldr	r3, [r7, #20]
 8001d20:	68ba      	ldr	r2, [r7, #8]
 8001d22:	18d3      	adds	r3, r2, r3
 8001d24:	2200      	movs	r2, #0
 8001d26:	701a      	strb	r2, [r3, #0]
                break;
 8001d28:	e00a      	b.n	8001d40 <GSM_Utilities_Get_IMEI+0x74>
    for(int CountByte = 0; CountByte < strlen((char*)recv_Buffer); CountByte++)
 8001d2a:	693b      	ldr	r3, [r7, #16]
 8001d2c:	3301      	adds	r3, #1
 8001d2e:	613b      	str	r3, [r7, #16]
 8001d30:	68fb      	ldr	r3, [r7, #12]
 8001d32:	0018      	movs	r0, r3
 8001d34:	f7fe f9f2 	bl	800011c <strlen>
 8001d38:	0002      	movs	r2, r0
 8001d3a:	693b      	ldr	r3, [r7, #16]
 8001d3c:	429a      	cmp	r2, r3
 8001d3e:	d8d1      	bhi.n	8001ce4 <GSM_Utilities_Get_IMEI+0x18>
            }
        }
    }
    IMEI_Buffer[IMEI_Index] = 0;
 8001d40:	697b      	ldr	r3, [r7, #20]
 8001d42:	68ba      	ldr	r2, [r7, #8]
 8001d44:	18d3      	adds	r3, r2, r3
 8001d46:	2200      	movs	r2, #0
 8001d48:	701a      	strb	r2, [r3, #0]
}
 8001d4a:	46c0      	nop			; (mov r8, r8)
 8001d4c:	46bd      	mov	sp, r7
 8001d4e:	b006      	add	sp, #24
 8001d50:	bd80      	pop	{r7, pc}
	...

08001d54 <gsm_utilities_get_signal_strength_from_buffer>:
bool gsm_utilities_get_signal_strength_from_buffer(uint8_t *buffer, uint16_t *csq)
{
 8001d54:	b580      	push	{r7, lr}
 8001d56:	b084      	sub	sp, #16
 8001d58:	af00      	add	r7, sp, #0
 8001d5a:	6078      	str	r0, [r7, #4]
 8001d5c:	6039      	str	r1, [r7, #0]
    char *tmp_buff = strstr((char *)buffer, "+CSQ:");
 8001d5e:	4a0d      	ldr	r2, [pc, #52]	; (8001d94 <gsm_utilities_get_signal_strength_from_buffer+0x40>)
 8001d60:	687b      	ldr	r3, [r7, #4]
 8001d62:	0011      	movs	r1, r2
 8001d64:	0018      	movs	r0, r3
 8001d66:	f01c fa3f 	bl	801e1e8 <strstr>
 8001d6a:	0003      	movs	r3, r0
 8001d6c:	60fb      	str	r3, [r7, #12]

    if (tmp_buff == NULL)
 8001d6e:	68fb      	ldr	r3, [r7, #12]
 8001d70:	2b00      	cmp	r3, #0
 8001d72:	d101      	bne.n	8001d78 <gsm_utilities_get_signal_strength_from_buffer+0x24>
    {
        return false;
 8001d74:	2300      	movs	r3, #0
 8001d76:	e009      	b.n	8001d8c <gsm_utilities_get_signal_strength_from_buffer+0x38>
    }

    *csq = gsm_utilities_get_number_from_string((uint16_t)6, tmp_buff);
 8001d78:	68fb      	ldr	r3, [r7, #12]
 8001d7a:	0019      	movs	r1, r3
 8001d7c:	2006      	movs	r0, #6
 8001d7e:	f000 f80b 	bl	8001d98 <gsm_utilities_get_number_from_string>
 8001d82:	0003      	movs	r3, r0
 8001d84:	001a      	movs	r2, r3
 8001d86:	683b      	ldr	r3, [r7, #0]
 8001d88:	801a      	strh	r2, [r3, #0]
    return true;
 8001d8a:	2301      	movs	r3, #1
}
 8001d8c:	0018      	movs	r0, r3
 8001d8e:	46bd      	mov	sp, r7
 8001d90:	b004      	add	sp, #16
 8001d92:	bd80      	pop	{r7, pc}
 8001d94:	0801f510 	.word	0x0801f510

08001d98 <gsm_utilities_get_number_from_string>:
 * 	Ham doc mot so trong chuoi bat dau tu dia chi nao do.
 *	Buffer = abc124mff thi gsm_utilities_get_number_from_string(3,Buffer) = 123
 *
 */
uint16_t gsm_utilities_get_number_from_string(uint16_t begin_index, char *buffer)
{
 8001d98:	b590      	push	{r4, r7, lr}
 8001d9a:	b085      	sub	sp, #20
 8001d9c:	af00      	add	r7, sp, #0
 8001d9e:	0002      	movs	r2, r0
 8001da0:	6039      	str	r1, [r7, #0]
 8001da2:	1dbb      	adds	r3, r7, #6
 8001da4:	801a      	strh	r2, [r3, #0]
    // assert(buffer);

	uint16_t value = 0;
 8001da6:	230e      	movs	r3, #14
 8001da8:	18fb      	adds	r3, r7, r3
 8001daa:	2200      	movs	r2, #0
 8001dac:	801a      	strh	r2, [r3, #0]
    uint16_t tmp = begin_index;
 8001dae:	230c      	movs	r3, #12
 8001db0:	18fb      	adds	r3, r7, r3
 8001db2:	1dba      	adds	r2, r7, #6
 8001db4:	8812      	ldrh	r2, [r2, #0]
 8001db6:	801a      	strh	r2, [r3, #0]
    uint32_t len = strlen(buffer);
 8001db8:	683b      	ldr	r3, [r7, #0]
 8001dba:	0018      	movs	r0, r3
 8001dbc:	f7fe f9ae 	bl	800011c <strlen>
 8001dc0:	0003      	movs	r3, r0
 8001dc2:	60bb      	str	r3, [r7, #8]
    while (buffer[tmp] && tmp < len)
 8001dc4:	e029      	b.n	8001e1a <gsm_utilities_get_number_from_string+0x82>
    {
        if (buffer[tmp] >= '0' && buffer[tmp] <= '9')
 8001dc6:	200c      	movs	r0, #12
 8001dc8:	183b      	adds	r3, r7, r0
 8001dca:	881b      	ldrh	r3, [r3, #0]
 8001dcc:	683a      	ldr	r2, [r7, #0]
 8001dce:	18d3      	adds	r3, r2, r3
 8001dd0:	781b      	ldrb	r3, [r3, #0]
 8001dd2:	2b2f      	cmp	r3, #47	; 0x2f
 8001dd4:	d92e      	bls.n	8001e34 <gsm_utilities_get_number_from_string+0x9c>
 8001dd6:	183b      	adds	r3, r7, r0
 8001dd8:	881b      	ldrh	r3, [r3, #0]
 8001dda:	683a      	ldr	r2, [r7, #0]
 8001ddc:	18d3      	adds	r3, r2, r3
 8001dde:	781b      	ldrb	r3, [r3, #0]
 8001de0:	2b39      	cmp	r3, #57	; 0x39
 8001de2:	d827      	bhi.n	8001e34 <gsm_utilities_get_number_from_string+0x9c>
        {
            value *= 10;
 8001de4:	240e      	movs	r4, #14
 8001de6:	193a      	adds	r2, r7, r4
 8001de8:	193b      	adds	r3, r7, r4
 8001dea:	881b      	ldrh	r3, [r3, #0]
 8001dec:	1c19      	adds	r1, r3, #0
 8001dee:	0089      	lsls	r1, r1, #2
 8001df0:	18cb      	adds	r3, r1, r3
 8001df2:	18db      	adds	r3, r3, r3
 8001df4:	8013      	strh	r3, [r2, #0]
            value += buffer[tmp] - 48;
 8001df6:	183b      	adds	r3, r7, r0
 8001df8:	881b      	ldrh	r3, [r3, #0]
 8001dfa:	683a      	ldr	r2, [r7, #0]
 8001dfc:	18d3      	adds	r3, r2, r3
 8001dfe:	781b      	ldrb	r3, [r3, #0]
 8001e00:	b29a      	uxth	r2, r3
 8001e02:	193b      	adds	r3, r7, r4
 8001e04:	881b      	ldrh	r3, [r3, #0]
 8001e06:	18d3      	adds	r3, r2, r3
 8001e08:	b29a      	uxth	r2, r3
 8001e0a:	193b      	adds	r3, r7, r4
 8001e0c:	3a30      	subs	r2, #48	; 0x30
 8001e0e:	801a      	strh	r2, [r3, #0]
        }
        else
        {
            break;
        }
        tmp++;
 8001e10:	183b      	adds	r3, r7, r0
 8001e12:	881a      	ldrh	r2, [r3, #0]
 8001e14:	183b      	adds	r3, r7, r0
 8001e16:	3201      	adds	r2, #1
 8001e18:	801a      	strh	r2, [r3, #0]
    while (buffer[tmp] && tmp < len)
 8001e1a:	210c      	movs	r1, #12
 8001e1c:	187b      	adds	r3, r7, r1
 8001e1e:	881b      	ldrh	r3, [r3, #0]
 8001e20:	683a      	ldr	r2, [r7, #0]
 8001e22:	18d3      	adds	r3, r2, r3
 8001e24:	781b      	ldrb	r3, [r3, #0]
 8001e26:	2b00      	cmp	r3, #0
 8001e28:	d004      	beq.n	8001e34 <gsm_utilities_get_number_from_string+0x9c>
 8001e2a:	187b      	adds	r3, r7, r1
 8001e2c:	881b      	ldrh	r3, [r3, #0]
 8001e2e:	68ba      	ldr	r2, [r7, #8]
 8001e30:	429a      	cmp	r2, r3
 8001e32:	d8c8      	bhi.n	8001dc6 <gsm_utilities_get_number_from_string+0x2e>
    }

    return value;
 8001e34:	230e      	movs	r3, #14
 8001e36:	18fb      	adds	r3, r7, r3
 8001e38:	881b      	ldrh	r3, [r3, #0]
}
 8001e3a:	0018      	movs	r0, r3
 8001e3c:	46bd      	mov	sp, r7
 8001e3e:	b005      	add	sp, #20
 8001e40:	bd90      	pop	{r4, r7, pc}
	...

08001e44 <DEBUG_PrintResult_ATC>:
void DEBUG_PrintResult_ATC(char* cmd, char* result)
{
 8001e44:	b5b0      	push	{r4, r5, r7, lr}
 8001e46:	b094      	sub	sp, #80	; 0x50
 8001e48:	af02      	add	r7, sp, #8
 8001e4a:	6078      	str	r0, [r7, #4]
 8001e4c:	6039      	str	r1, [r7, #0]
    // In ket qua: "AT cmd: OK/FAIL " trong debug
    char sub_cmd[64] = "";
 8001e4e:	2408      	movs	r4, #8
 8001e50:	193b      	adds	r3, r7, r4
 8001e52:	2200      	movs	r2, #0
 8001e54:	601a      	str	r2, [r3, #0]
 8001e56:	3304      	adds	r3, #4
 8001e58:	223c      	movs	r2, #60	; 0x3c
 8001e5a:	2100      	movs	r1, #0
 8001e5c:	0018      	movs	r0, r3
 8001e5e:	f01c f8b9 	bl	801dfd4 <memset>
    strncpy(sub_cmd, cmd + 0, strlen(cmd) - 2);
 8001e62:	687b      	ldr	r3, [r7, #4]
 8001e64:	0018      	movs	r0, r3
 8001e66:	f7fe f959 	bl	800011c <strlen>
 8001e6a:	0003      	movs	r3, r0
 8001e6c:	1e9a      	subs	r2, r3, #2
 8001e6e:	6879      	ldr	r1, [r7, #4]
 8001e70:	0025      	movs	r5, r4
 8001e72:	193b      	adds	r3, r7, r4
 8001e74:	0018      	movs	r0, r3
 8001e76:	f01c f9a3 	bl	801e1c0 <strncpy>
    DEBUG_INFO("%s : %s\r\n", sub_cmd, result);
 8001e7a:	f01c f83b 	bl	801def4 <sys_get_tick_ms>
 8001e7e:	0004      	movs	r4, r0
 8001e80:	1979      	adds	r1, r7, r5
 8001e82:	4a06      	ldr	r2, [pc, #24]	; (8001e9c <DEBUG_PrintResult_ATC+0x58>)
 8001e84:	4806      	ldr	r0, [pc, #24]	; (8001ea0 <DEBUG_PrintResult_ATC+0x5c>)
 8001e86:	683b      	ldr	r3, [r7, #0]
 8001e88:	9300      	str	r3, [sp, #0]
 8001e8a:	000b      	movs	r3, r1
 8001e8c:	0021      	movs	r1, r4
 8001e8e:	f000 f9a9 	bl	80021e4 <app_debug_rtt_raw>
}
 8001e92:	46c0      	nop			; (mov r8, r8)
 8001e94:	46bd      	mov	sp, r7
 8001e96:	b012      	add	sp, #72	; 0x48
 8001e98:	bdb0      	pop	{r4, r5, r7, pc}
 8001e9a:	46c0      	nop			; (mov r8, r8)
 8001e9c:	0801f518 	.word	0x0801f518
 8001ea0:	0801f51c 	.word	0x0801f51c

08001ea4 <_DoInit>:
                      _DoInit();                                                                     \
                    }                                                                                \
                  } while (0);                                                                       \
                }

static void _DoInit(void) {
 8001ea4:	b580      	push	{r7, lr}
 8001ea6:	b082      	sub	sp, #8
 8001ea8:	af00      	add	r7, sp, #0
  volatile SEGGER_RTT_CB* p;   // Volatile to make sure that compiler cannot change the order of accesses to the control block
  //
  // Initialize control block
  //
  p                     = (volatile SEGGER_RTT_CB*)((char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access control block uncached so that nothing in the cache ever becomes dirty and all changes are visible in HW directly
 8001eaa:	4b22      	ldr	r3, [pc, #136]	; (8001f34 <_DoInit+0x90>)
 8001eac:	607b      	str	r3, [r7, #4]
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
 8001eae:	687b      	ldr	r3, [r7, #4]
 8001eb0:	2201      	movs	r2, #1
 8001eb2:	611a      	str	r2, [r3, #16]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
 8001eb4:	687b      	ldr	r3, [r7, #4]
 8001eb6:	2201      	movs	r2, #1
 8001eb8:	615a      	str	r2, [r3, #20]
  //
  // Initialize up buffer 0
  //
  p->aUp[0].sName         = "Terminal";
 8001eba:	687b      	ldr	r3, [r7, #4]
 8001ebc:	4a1e      	ldr	r2, [pc, #120]	; (8001f38 <_DoInit+0x94>)
 8001ebe:	619a      	str	r2, [r3, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
 8001ec0:	687b      	ldr	r3, [r7, #4]
 8001ec2:	4a1e      	ldr	r2, [pc, #120]	; (8001f3c <_DoInit+0x98>)
 8001ec4:	61da      	str	r2, [r3, #28]
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
 8001ec6:	687b      	ldr	r3, [r7, #4]
 8001ec8:	2280      	movs	r2, #128	; 0x80
 8001eca:	0052      	lsls	r2, r2, #1
 8001ecc:	621a      	str	r2, [r3, #32]
  p->aUp[0].RdOff         = 0u;
 8001ece:	687b      	ldr	r3, [r7, #4]
 8001ed0:	2200      	movs	r2, #0
 8001ed2:	629a      	str	r2, [r3, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
 8001ed4:	687b      	ldr	r3, [r7, #4]
 8001ed6:	2200      	movs	r2, #0
 8001ed8:	625a      	str	r2, [r3, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
 8001eda:	687b      	ldr	r3, [r7, #4]
 8001edc:	2200      	movs	r2, #0
 8001ede:	62da      	str	r2, [r3, #44]	; 0x2c
  //
  // Initialize down buffer 0
  //
  p->aDown[0].sName         = "Terminal";
 8001ee0:	687b      	ldr	r3, [r7, #4]
 8001ee2:	4a15      	ldr	r2, [pc, #84]	; (8001f38 <_DoInit+0x94>)
 8001ee4:	631a      	str	r2, [r3, #48]	; 0x30
  p->aDown[0].pBuffer       = _acDownBuffer;
 8001ee6:	687b      	ldr	r3, [r7, #4]
 8001ee8:	4a15      	ldr	r2, [pc, #84]	; (8001f40 <_DoInit+0x9c>)
 8001eea:	635a      	str	r2, [r3, #52]	; 0x34
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
 8001eec:	687b      	ldr	r3, [r7, #4]
 8001eee:	2240      	movs	r2, #64	; 0x40
 8001ef0:	639a      	str	r2, [r3, #56]	; 0x38
  p->aDown[0].RdOff         = 0u;
 8001ef2:	687b      	ldr	r3, [r7, #4]
 8001ef4:	2200      	movs	r2, #0
 8001ef6:	641a      	str	r2, [r3, #64]	; 0x40
  p->aDown[0].WrOff         = 0u;
 8001ef8:	687b      	ldr	r3, [r7, #4]
 8001efa:	2200      	movs	r2, #0
 8001efc:	63da      	str	r2, [r3, #60]	; 0x3c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
 8001efe:	687b      	ldr	r3, [r7, #4]
 8001f00:	2200      	movs	r2, #0
 8001f02:	645a      	str	r2, [r3, #68]	; 0x44
  //
  // Finish initialization of the control block.
  // Copy Id string in three steps to make sure "SEGGER RTT" is not found
  // in initializer memory (usually flash) by J-Link
  //
  STRCPY((char*)&p->acID[7], "RTT");
 8001f04:	687b      	ldr	r3, [r7, #4]
 8001f06:	1dda      	adds	r2, r3, #7
 8001f08:	4b0e      	ldr	r3, [pc, #56]	; (8001f44 <_DoInit+0xa0>)
 8001f0a:	0010      	movs	r0, r2
 8001f0c:	0019      	movs	r1, r3
 8001f0e:	2304      	movs	r3, #4
 8001f10:	001a      	movs	r2, r3
 8001f12:	f01c f843 	bl	801df9c <memcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
  STRCPY((char*)&p->acID[0], "SEGGER");
 8001f16:	687a      	ldr	r2, [r7, #4]
 8001f18:	4b0b      	ldr	r3, [pc, #44]	; (8001f48 <_DoInit+0xa4>)
 8001f1a:	0010      	movs	r0, r2
 8001f1c:	0019      	movs	r1, r3
 8001f1e:	2307      	movs	r3, #7
 8001f20:	001a      	movs	r2, r3
 8001f22:	f01c f83b 	bl	801df9c <memcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
  p->acID[6] = ' ';
 8001f26:	687b      	ldr	r3, [r7, #4]
 8001f28:	2220      	movs	r2, #32
 8001f2a:	719a      	strb	r2, [r3, #6]
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
}
 8001f2c:	46c0      	nop			; (mov r8, r8)
 8001f2e:	46bd      	mov	sp, r7
 8001f30:	b002      	add	sp, #8
 8001f32:	bd80      	pop	{r7, pc}
 8001f34:	200010ec 	.word	0x200010ec
 8001f38:	0801f540 	.word	0x0801f540
 8001f3c:	20000858 	.word	0x20000858
 8001f40:	20000958 	.word	0x20000958
 8001f44:	0801f54c 	.word	0x0801f54c
 8001f48:	0801f550 	.word	0x0801f550

08001f4c <_WriteBlocking>:
*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
*
*  Return value
*    >= 0 - Number of bytes written into buffer.
*/
static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
 8001f4c:	b580      	push	{r7, lr}
 8001f4e:	b08a      	sub	sp, #40	; 0x28
 8001f50:	af00      	add	r7, sp, #0
 8001f52:	60f8      	str	r0, [r7, #12]
 8001f54:	60b9      	str	r1, [r7, #8]
 8001f56:	607a      	str	r2, [r7, #4]
  unsigned WrOff;
  volatile char* pDst;
  //
  // Write data to buffer and handle wrap-around if necessary
  //
  NumBytesWritten = 0u;
 8001f58:	2300      	movs	r3, #0
 8001f5a:	623b      	str	r3, [r7, #32]
  WrOff = pRing->WrOff;
 8001f5c:	68fb      	ldr	r3, [r7, #12]
 8001f5e:	68db      	ldr	r3, [r3, #12]
 8001f60:	61fb      	str	r3, [r7, #28]
  do {
    RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
 8001f62:	68fb      	ldr	r3, [r7, #12]
 8001f64:	691b      	ldr	r3, [r3, #16]
 8001f66:	61bb      	str	r3, [r7, #24]
    if (RdOff > WrOff) {
 8001f68:	69ba      	ldr	r2, [r7, #24]
 8001f6a:	69fb      	ldr	r3, [r7, #28]
 8001f6c:	429a      	cmp	r2, r3
 8001f6e:	d905      	bls.n	8001f7c <_WriteBlocking+0x30>
      NumBytesToWrite = RdOff - WrOff - 1u;
 8001f70:	69ba      	ldr	r2, [r7, #24]
 8001f72:	69fb      	ldr	r3, [r7, #28]
 8001f74:	1ad3      	subs	r3, r2, r3
 8001f76:	3b01      	subs	r3, #1
 8001f78:	627b      	str	r3, [r7, #36]	; 0x24
 8001f7a:	e007      	b.n	8001f8c <_WriteBlocking+0x40>
    } else {
      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
 8001f7c:	68fb      	ldr	r3, [r7, #12]
 8001f7e:	689a      	ldr	r2, [r3, #8]
 8001f80:	69b9      	ldr	r1, [r7, #24]
 8001f82:	69fb      	ldr	r3, [r7, #28]
 8001f84:	1acb      	subs	r3, r1, r3
 8001f86:	18d3      	adds	r3, r2, r3
 8001f88:	3b01      	subs	r3, #1
 8001f8a:	627b      	str	r3, [r7, #36]	; 0x24
    }
    NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
 8001f8c:	68fb      	ldr	r3, [r7, #12]
 8001f8e:	689a      	ldr	r2, [r3, #8]
 8001f90:	69fb      	ldr	r3, [r7, #28]
 8001f92:	1ad2      	subs	r2, r2, r3
 8001f94:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001f96:	4293      	cmp	r3, r2
 8001f98:	d900      	bls.n	8001f9c <_WriteBlocking+0x50>
 8001f9a:	0013      	movs	r3, r2
 8001f9c:	627b      	str	r3, [r7, #36]	; 0x24
    NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
 8001f9e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8001fa0:	687b      	ldr	r3, [r7, #4]
 8001fa2:	4293      	cmp	r3, r2
 8001fa4:	d900      	bls.n	8001fa8 <_WriteBlocking+0x5c>
 8001fa6:	0013      	movs	r3, r2
 8001fa8:	627b      	str	r3, [r7, #36]	; 0x24
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
 8001faa:	68fb      	ldr	r3, [r7, #12]
 8001fac:	685a      	ldr	r2, [r3, #4]
 8001fae:	69fb      	ldr	r3, [r7, #28]
 8001fb0:	18d3      	adds	r3, r2, r3
 8001fb2:	617b      	str	r3, [r7, #20]
    WrOff           += NumBytesToWrite;
    while (NumBytesToWrite--) {
      *pDst++ = *pBuffer++;
    };
#else
    SEGGER_RTT_MEMCPY((void*)pDst, pBuffer, NumBytesToWrite);
 8001fb4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8001fb6:	68b9      	ldr	r1, [r7, #8]
 8001fb8:	697b      	ldr	r3, [r7, #20]
 8001fba:	0018      	movs	r0, r3
 8001fbc:	f01b ffee 	bl	801df9c <memcpy>
    NumBytesWritten += NumBytesToWrite;
 8001fc0:	6a3a      	ldr	r2, [r7, #32]
 8001fc2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001fc4:	18d3      	adds	r3, r2, r3
 8001fc6:	623b      	str	r3, [r7, #32]
    pBuffer         += NumBytesToWrite;
 8001fc8:	68ba      	ldr	r2, [r7, #8]
 8001fca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001fcc:	18d3      	adds	r3, r2, r3
 8001fce:	60bb      	str	r3, [r7, #8]
    NumBytes        -= NumBytesToWrite;
 8001fd0:	687a      	ldr	r2, [r7, #4]
 8001fd2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001fd4:	1ad3      	subs	r3, r2, r3
 8001fd6:	607b      	str	r3, [r7, #4]
    WrOff           += NumBytesToWrite;
 8001fd8:	69fa      	ldr	r2, [r7, #28]
 8001fda:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001fdc:	18d3      	adds	r3, r2, r3
 8001fde:	61fb      	str	r3, [r7, #28]
#endif
    if (WrOff == pRing->SizeOfBuffer) {
 8001fe0:	68fb      	ldr	r3, [r7, #12]
 8001fe2:	689b      	ldr	r3, [r3, #8]
 8001fe4:	69fa      	ldr	r2, [r7, #28]
 8001fe6:	429a      	cmp	r2, r3
 8001fe8:	d101      	bne.n	8001fee <_WriteBlocking+0xa2>
      WrOff = 0u;
 8001fea:	2300      	movs	r3, #0
 8001fec:	61fb      	str	r3, [r7, #28]
    }
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    pRing->WrOff = WrOff;
 8001fee:	68fb      	ldr	r3, [r7, #12]
 8001ff0:	69fa      	ldr	r2, [r7, #28]
 8001ff2:	60da      	str	r2, [r3, #12]
  } while (NumBytes);
 8001ff4:	687b      	ldr	r3, [r7, #4]
 8001ff6:	2b00      	cmp	r3, #0
 8001ff8:	d1b3      	bne.n	8001f62 <_WriteBlocking+0x16>
  return NumBytesWritten;
 8001ffa:	6a3b      	ldr	r3, [r7, #32]
}
 8001ffc:	0018      	movs	r0, r3
 8001ffe:	46bd      	mov	sp, r7
 8002000:	b00a      	add	sp, #40	; 0x28
 8002002:	bd80      	pop	{r7, pc}

08002004 <_WriteNoCheck>:
*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
*
*  Notes
*    (1) If there might not be enough space in the "Up"-buffer, call _WriteBlocking
*/
static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
 8002004:	b580      	push	{r7, lr}
 8002006:	b088      	sub	sp, #32
 8002008:	af00      	add	r7, sp, #0
 800200a:	60f8      	str	r0, [r7, #12]
 800200c:	60b9      	str	r1, [r7, #8]
 800200e:	607a      	str	r2, [r7, #4]
  unsigned NumBytesAtOnce;
  unsigned WrOff;
  unsigned Rem;
  volatile char* pDst;

  WrOff = pRing->WrOff;
 8002010:	68fb      	ldr	r3, [r7, #12]
 8002012:	68db      	ldr	r3, [r3, #12]
 8002014:	61fb      	str	r3, [r7, #28]
  Rem = pRing->SizeOfBuffer - WrOff;
 8002016:	68fb      	ldr	r3, [r7, #12]
 8002018:	689a      	ldr	r2, [r3, #8]
 800201a:	69fb      	ldr	r3, [r7, #28]
 800201c:	1ad3      	subs	r3, r2, r3
 800201e:	61bb      	str	r3, [r7, #24]
  if (Rem > NumBytes) {
 8002020:	69ba      	ldr	r2, [r7, #24]
 8002022:	687b      	ldr	r3, [r7, #4]
 8002024:	429a      	cmp	r2, r3
 8002026:	d910      	bls.n	800204a <_WriteNoCheck+0x46>
    //
    // All data fits before wrap around
    //
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
 8002028:	68fb      	ldr	r3, [r7, #12]
 800202a:	685a      	ldr	r2, [r3, #4]
 800202c:	69fb      	ldr	r3, [r7, #28]
 800202e:	18d3      	adds	r3, r2, r3
 8002030:	613b      	str	r3, [r7, #16]
      *pDst++ = *pData++;
    };
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    pRing->WrOff = WrOff;
#else
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytes);
 8002032:	687a      	ldr	r2, [r7, #4]
 8002034:	68b9      	ldr	r1, [r7, #8]
 8002036:	693b      	ldr	r3, [r7, #16]
 8002038:	0018      	movs	r0, r3
 800203a:	f01b ffaf 	bl	801df9c <memcpy>
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    pRing->WrOff = WrOff + NumBytes;
 800203e:	69fa      	ldr	r2, [r7, #28]
 8002040:	687b      	ldr	r3, [r7, #4]
 8002042:	18d2      	adds	r2, r2, r3
 8002044:	68fb      	ldr	r3, [r7, #12]
 8002046:	60da      	str	r2, [r3, #12]
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    pRing->WrOff = NumBytesAtOnce;
#endif
  }
}
 8002048:	e01e      	b.n	8002088 <_WriteNoCheck+0x84>
    NumBytesAtOnce = Rem;
 800204a:	69bb      	ldr	r3, [r7, #24]
 800204c:	617b      	str	r3, [r7, #20]
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
 800204e:	68fb      	ldr	r3, [r7, #12]
 8002050:	685a      	ldr	r2, [r3, #4]
 8002052:	69fb      	ldr	r3, [r7, #28]
 8002054:	18d3      	adds	r3, r2, r3
 8002056:	613b      	str	r3, [r7, #16]
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytesAtOnce);
 8002058:	697a      	ldr	r2, [r7, #20]
 800205a:	68b9      	ldr	r1, [r7, #8]
 800205c:	693b      	ldr	r3, [r7, #16]
 800205e:	0018      	movs	r0, r3
 8002060:	f01b ff9c 	bl	801df9c <memcpy>
    NumBytesAtOnce = NumBytes - Rem;
 8002064:	687a      	ldr	r2, [r7, #4]
 8002066:	69bb      	ldr	r3, [r7, #24]
 8002068:	1ad3      	subs	r3, r2, r3
 800206a:	617b      	str	r3, [r7, #20]
    pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
 800206c:	68fb      	ldr	r3, [r7, #12]
 800206e:	685b      	ldr	r3, [r3, #4]
 8002070:	613b      	str	r3, [r7, #16]
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
 8002072:	68ba      	ldr	r2, [r7, #8]
 8002074:	69bb      	ldr	r3, [r7, #24]
 8002076:	18d1      	adds	r1, r2, r3
 8002078:	697a      	ldr	r2, [r7, #20]
 800207a:	693b      	ldr	r3, [r7, #16]
 800207c:	0018      	movs	r0, r3
 800207e:	f01b ff8d 	bl	801df9c <memcpy>
    pRing->WrOff = NumBytesAtOnce;
 8002082:	68fb      	ldr	r3, [r7, #12]
 8002084:	697a      	ldr	r2, [r7, #20]
 8002086:	60da      	str	r2, [r3, #12]
}
 8002088:	46c0      	nop			; (mov r8, r8)
 800208a:	46bd      	mov	sp, r7
 800208c:	b008      	add	sp, #32
 800208e:	bd80      	pop	{r7, pc}

08002090 <_GetAvailWriteSpace>:
*    pRing        Ring buffer to check.
*
*  Return value
*    Number of bytes that are free in the buffer.
*/
static unsigned _GetAvailWriteSpace(SEGGER_RTT_BUFFER_UP* pRing) {
 8002090:	b580      	push	{r7, lr}
 8002092:	b086      	sub	sp, #24
 8002094:	af00      	add	r7, sp, #0
 8002096:	6078      	str	r0, [r7, #4]
  unsigned r;
  //
  // Avoid warnings regarding volatile access order.  It's not a problem
  // in this case, but dampen compiler enthusiasm.
  //
  RdOff = pRing->RdOff;
 8002098:	687b      	ldr	r3, [r7, #4]
 800209a:	691b      	ldr	r3, [r3, #16]
 800209c:	613b      	str	r3, [r7, #16]
  WrOff = pRing->WrOff;
 800209e:	687b      	ldr	r3, [r7, #4]
 80020a0:	68db      	ldr	r3, [r3, #12]
 80020a2:	60fb      	str	r3, [r7, #12]
  if (RdOff <= WrOff) {
 80020a4:	693a      	ldr	r2, [r7, #16]
 80020a6:	68fb      	ldr	r3, [r7, #12]
 80020a8:	429a      	cmp	r2, r3
 80020aa:	d808      	bhi.n	80020be <_GetAvailWriteSpace+0x2e>
    r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
 80020ac:	687b      	ldr	r3, [r7, #4]
 80020ae:	689a      	ldr	r2, [r3, #8]
 80020b0:	68fb      	ldr	r3, [r7, #12]
 80020b2:	1ad2      	subs	r2, r2, r3
 80020b4:	693b      	ldr	r3, [r7, #16]
 80020b6:	18d3      	adds	r3, r2, r3
 80020b8:	3b01      	subs	r3, #1
 80020ba:	617b      	str	r3, [r7, #20]
 80020bc:	e004      	b.n	80020c8 <_GetAvailWriteSpace+0x38>
  } else {
    r = RdOff - WrOff - 1u;
 80020be:	693a      	ldr	r2, [r7, #16]
 80020c0:	68fb      	ldr	r3, [r7, #12]
 80020c2:	1ad3      	subs	r3, r2, r3
 80020c4:	3b01      	subs	r3, #1
 80020c6:	617b      	str	r3, [r7, #20]
  }
  return r;
 80020c8:	697b      	ldr	r3, [r7, #20]
}
 80020ca:	0018      	movs	r0, r3
 80020cc:	46bd      	mov	sp, r7
 80020ce:	b006      	add	sp, #24
 80020d0:	bd80      	pop	{r7, pc}
	...

080020d4 <SEGGER_RTT_WriteNoLock>:
*    (1) Data is stored according to buffer flags.
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
 80020d4:	b580      	push	{r7, lr}
 80020d6:	b088      	sub	sp, #32
 80020d8:	af00      	add	r7, sp, #0
 80020da:	60f8      	str	r0, [r7, #12]
 80020dc:	60b9      	str	r1, [r7, #8]
 80020de:	607a      	str	r2, [r7, #4]
  const char*           pData;
  SEGGER_RTT_BUFFER_UP* pRing;
  //
  // Get "to-host" ring buffer.
  //
  pData = (const char *)pBuffer;
 80020e0:	68bb      	ldr	r3, [r7, #8]
 80020e2:	61bb      	str	r3, [r7, #24]
  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
 80020e4:	68fb      	ldr	r3, [r7, #12]
 80020e6:	1c5a      	adds	r2, r3, #1
 80020e8:	0013      	movs	r3, r2
 80020ea:	005b      	lsls	r3, r3, #1
 80020ec:	189b      	adds	r3, r3, r2
 80020ee:	00db      	lsls	r3, r3, #3
 80020f0:	4a23      	ldr	r2, [pc, #140]	; (8002180 <SEGGER_RTT_WriteNoLock+0xac>)
 80020f2:	189b      	adds	r3, r3, r2
 80020f4:	617b      	str	r3, [r7, #20]
  //
  // How we output depends upon the mode...
  //
  switch (pRing->Flags) {
 80020f6:	697b      	ldr	r3, [r7, #20]
 80020f8:	695b      	ldr	r3, [r3, #20]
 80020fa:	2b02      	cmp	r3, #2
 80020fc:	d02e      	beq.n	800215c <SEGGER_RTT_WriteNoLock+0x88>
 80020fe:	d836      	bhi.n	800216e <SEGGER_RTT_WriteNoLock+0x9a>
 8002100:	2b00      	cmp	r3, #0
 8002102:	d002      	beq.n	800210a <SEGGER_RTT_WriteNoLock+0x36>
 8002104:	2b01      	cmp	r3, #1
 8002106:	d016      	beq.n	8002136 <SEGGER_RTT_WriteNoLock+0x62>
 8002108:	e031      	b.n	800216e <SEGGER_RTT_WriteNoLock+0x9a>
  case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
    //
    // If we are in skip mode and there is no space for the whole
    // of this output, don't bother.
    //
    Avail = _GetAvailWriteSpace(pRing);
 800210a:	697b      	ldr	r3, [r7, #20]
 800210c:	0018      	movs	r0, r3
 800210e:	f7ff ffbf 	bl	8002090 <_GetAvailWriteSpace>
 8002112:	0003      	movs	r3, r0
 8002114:	613b      	str	r3, [r7, #16]
    if (Avail < NumBytes) {
 8002116:	693a      	ldr	r2, [r7, #16]
 8002118:	687b      	ldr	r3, [r7, #4]
 800211a:	429a      	cmp	r2, r3
 800211c:	d202      	bcs.n	8002124 <SEGGER_RTT_WriteNoLock+0x50>
      Status = 0u;
 800211e:	2300      	movs	r3, #0
 8002120:	61fb      	str	r3, [r7, #28]
    } else {
      Status = NumBytes;
      _WriteNoCheck(pRing, pData, NumBytes);
    }
    break;
 8002122:	e027      	b.n	8002174 <SEGGER_RTT_WriteNoLock+0xa0>
      Status = NumBytes;
 8002124:	687b      	ldr	r3, [r7, #4]
 8002126:	61fb      	str	r3, [r7, #28]
      _WriteNoCheck(pRing, pData, NumBytes);
 8002128:	687a      	ldr	r2, [r7, #4]
 800212a:	69b9      	ldr	r1, [r7, #24]
 800212c:	697b      	ldr	r3, [r7, #20]
 800212e:	0018      	movs	r0, r3
 8002130:	f7ff ff68 	bl	8002004 <_WriteNoCheck>
    break;
 8002134:	e01e      	b.n	8002174 <SEGGER_RTT_WriteNoLock+0xa0>
  case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
    //
    // If we are in trim mode, trim to what we can output without blocking.
    //
    Avail = _GetAvailWriteSpace(pRing);
 8002136:	697b      	ldr	r3, [r7, #20]
 8002138:	0018      	movs	r0, r3
 800213a:	f7ff ffa9 	bl	8002090 <_GetAvailWriteSpace>
 800213e:	0003      	movs	r3, r0
 8002140:	613b      	str	r3, [r7, #16]
    Status = Avail < NumBytes ? Avail : NumBytes;
 8002142:	693a      	ldr	r2, [r7, #16]
 8002144:	687b      	ldr	r3, [r7, #4]
 8002146:	4293      	cmp	r3, r2
 8002148:	d900      	bls.n	800214c <SEGGER_RTT_WriteNoLock+0x78>
 800214a:	0013      	movs	r3, r2
 800214c:	61fb      	str	r3, [r7, #28]
    _WriteNoCheck(pRing, pData, Status);
 800214e:	69fa      	ldr	r2, [r7, #28]
 8002150:	69b9      	ldr	r1, [r7, #24]
 8002152:	697b      	ldr	r3, [r7, #20]
 8002154:	0018      	movs	r0, r3
 8002156:	f7ff ff55 	bl	8002004 <_WriteNoCheck>
    break;
 800215a:	e00b      	b.n	8002174 <SEGGER_RTT_WriteNoLock+0xa0>
  case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
    //
    // If we are in blocking mode, output everything.
    //
    Status = _WriteBlocking(pRing, pData, NumBytes);
 800215c:	687a      	ldr	r2, [r7, #4]
 800215e:	69b9      	ldr	r1, [r7, #24]
 8002160:	697b      	ldr	r3, [r7, #20]
 8002162:	0018      	movs	r0, r3
 8002164:	f7ff fef2 	bl	8001f4c <_WriteBlocking>
 8002168:	0003      	movs	r3, r0
 800216a:	61fb      	str	r3, [r7, #28]
    break;
 800216c:	e002      	b.n	8002174 <SEGGER_RTT_WriteNoLock+0xa0>
  default:
    Status = 0u;
 800216e:	2300      	movs	r3, #0
 8002170:	61fb      	str	r3, [r7, #28]
    break;
 8002172:	46c0      	nop			; (mov r8, r8)
  }
  //
  // Finish up.
  //
  return Status;
 8002174:	69fb      	ldr	r3, [r7, #28]
}
 8002176:	0018      	movs	r0, r3
 8002178:	46bd      	mov	sp, r7
 800217a:	b008      	add	sp, #32
 800217c:	bd80      	pop	{r7, pc}
 800217e:	46c0      	nop			; (mov r8, r8)
 8002180:	200010ec 	.word	0x200010ec

08002184 <SEGGER_RTT_Write>:
*    Number of bytes which have been stored in the "Up"-buffer.
*
*  Notes
*    (1) Data is stored according to buffer flags.
*/
unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
 8002184:	b580      	push	{r7, lr}
 8002186:	b088      	sub	sp, #32
 8002188:	af00      	add	r7, sp, #0
 800218a:	60f8      	str	r0, [r7, #12]
 800218c:	60b9      	str	r1, [r7, #8]
 800218e:	607a      	str	r2, [r7, #4]
  unsigned Status;

  INIT();
 8002190:	4b0f      	ldr	r3, [pc, #60]	; (80021d0 <SEGGER_RTT_Write+0x4c>)
 8002192:	61fb      	str	r3, [r7, #28]
 8002194:	69fb      	ldr	r3, [r7, #28]
 8002196:	781b      	ldrb	r3, [r3, #0]
 8002198:	b2db      	uxtb	r3, r3
 800219a:	2b00      	cmp	r3, #0
 800219c:	d101      	bne.n	80021a2 <SEGGER_RTT_Write+0x1e>
 800219e:	f7ff fe81 	bl	8001ea4 <_DoInit>
  SEGGER_RTT_LOCK();
 80021a2:	f3ef 8310 	mrs	r3, PRIMASK
 80021a6:	2101      	movs	r1, #1
 80021a8:	f381 8810 	msr	PRIMASK, r1
 80021ac:	61bb      	str	r3, [r7, #24]
  Status = SEGGER_RTT_WriteNoLock(BufferIndex, pBuffer, NumBytes);  // Call the non-locking write function
 80021ae:	687a      	ldr	r2, [r7, #4]
 80021b0:	68b9      	ldr	r1, [r7, #8]
 80021b2:	68fb      	ldr	r3, [r7, #12]
 80021b4:	0018      	movs	r0, r3
 80021b6:	f7ff ff8d 	bl	80020d4 <SEGGER_RTT_WriteNoLock>
 80021ba:	0003      	movs	r3, r0
 80021bc:	617b      	str	r3, [r7, #20]
  SEGGER_RTT_UNLOCK();
 80021be:	69bb      	ldr	r3, [r7, #24]
 80021c0:	f383 8810 	msr	PRIMASK, r3
  return Status;
 80021c4:	697b      	ldr	r3, [r7, #20]
}
 80021c6:	0018      	movs	r0, r3
 80021c8:	46bd      	mov	sp, r7
 80021ca:	b008      	add	sp, #32
 80021cc:	bd80      	pop	{r7, pc}
 80021ce:	46c0      	nop			; (mov r8, r8)
 80021d0:	200010ec 	.word	0x200010ec

080021d4 <SEGGER_RTT_Init>:
*  Function description
*    Initializes the RTT Control Block.
*    Should be used in RAM targets, at start of the application.
*
*/
void SEGGER_RTT_Init (void) {
 80021d4:	b580      	push	{r7, lr}
 80021d6:	af00      	add	r7, sp, #0
  _DoInit();
 80021d8:	f7ff fe64 	bl	8001ea4 <_DoInit>
}
 80021dc:	46c0      	nop			; (mov r8, r8)
 80021de:	46bd      	mov	sp, r7
 80021e0:	bd80      	pop	{r7, pc}
	...

080021e4 <app_debug_rtt_raw>:
    
    return n;
}

int32_t app_debug_rtt_raw(const char *fmt,...)
{
 80021e4:	b40f      	push	{r0, r1, r2, r3}
 80021e6:	b580      	push	{r7, lr}
 80021e8:	b084      	sub	sp, #16
 80021ea:	af00      	add	r7, sp, #0
    int32_t     n;

    char *p = &m_debug_buffer[0];
 80021ec:	4b15      	ldr	r3, [pc, #84]	; (8002244 <app_debug_rtt_raw+0x60>)
 80021ee:	60fb      	str	r3, [r7, #12]
    int32_t size = SEGGER_RTT_PRINTF_BUFFER_SIZE;
 80021f0:	2380      	movs	r3, #128	; 0x80
 80021f2:	60bb      	str	r3, [r7, #8]
    va_list args;

    va_start (args, fmt);
 80021f4:	231c      	movs	r3, #28
 80021f6:	18fb      	adds	r3, r7, r3
 80021f8:	603b      	str	r3, [r7, #0]
    n = vsnprintf(p, size, fmt, args);
 80021fa:	68b9      	ldr	r1, [r7, #8]
 80021fc:	683b      	ldr	r3, [r7, #0]
 80021fe:	69ba      	ldr	r2, [r7, #24]
 8002200:	68f8      	ldr	r0, [r7, #12]
 8002202:	f01c f833 	bl	801e26c <vsniprintf>
 8002206:	0003      	movs	r3, r0
 8002208:	607b      	str	r3, [r7, #4]
    if (n > (int)size) 
 800220a:	687a      	ldr	r2, [r7, #4]
 800220c:	68bb      	ldr	r3, [r7, #8]
 800220e:	429a      	cmp	r2, r3
 8002210:	dd06      	ble.n	8002220 <app_debug_rtt_raw+0x3c>
    {
        SEGGER_RTT_Write(0, m_debug_buffer, size);
 8002212:	68ba      	ldr	r2, [r7, #8]
 8002214:	4b0b      	ldr	r3, [pc, #44]	; (8002244 <app_debug_rtt_raw+0x60>)
 8002216:	0019      	movs	r1, r3
 8002218:	2000      	movs	r0, #0
 800221a:	f7ff ffb3 	bl	8002184 <SEGGER_RTT_Write>
 800221e:	e008      	b.n	8002232 <app_debug_rtt_raw+0x4e>
    } 
    else if (n > 0) 
 8002220:	687b      	ldr	r3, [r7, #4]
 8002222:	2b00      	cmp	r3, #0
 8002224:	dd05      	ble.n	8002232 <app_debug_rtt_raw+0x4e>
    {
        SEGGER_RTT_Write(0, m_debug_buffer, n);
 8002226:	687a      	ldr	r2, [r7, #4]
 8002228:	4b06      	ldr	r3, [pc, #24]	; (8002244 <app_debug_rtt_raw+0x60>)
 800222a:	0019      	movs	r1, r3
 800222c:	2000      	movs	r0, #0
 800222e:	f7ff ffa9 	bl	8002184 <SEGGER_RTT_Write>
    }
    va_end(args);
    
    return n;
 8002232:	687b      	ldr	r3, [r7, #4]
}
 8002234:	0018      	movs	r0, r3
 8002236:	46bd      	mov	sp, r7
 8002238:	b004      	add	sp, #16
 800223a:	bc80      	pop	{r7}
 800223c:	bc08      	pop	{r3}
 800223e:	b004      	add	sp, #16
 8002240:	4718      	bx	r3
 8002242:	46c0      	nop			; (mov r8, r8)
 8002244:	20000998 	.word	0x20000998

08002248 <RingBuffer_Init>:
#include "ringbuffer.h"


void RingBuffer_Init(RingBuffer_Types* ringbuffer, int BufferSize)
{
 8002248:	b580      	push	{r7, lr}
 800224a:	b082      	sub	sp, #8
 800224c:	af00      	add	r7, sp, #0
 800224e:	6078      	str	r0, [r7, #4]
 8002250:	6039      	str	r1, [r7, #0]
    ringbuffer->BufferSize = BufferSize;
 8002252:	687b      	ldr	r3, [r7, #4]
 8002254:	683a      	ldr	r2, [r7, #0]
 8002256:	601a      	str	r2, [r3, #0]
    ringbuffer->Head = 0;
 8002258:	687b      	ldr	r3, [r7, #4]
 800225a:	2200      	movs	r2, #0
 800225c:	605a      	str	r2, [r3, #4]
    ringbuffer->Tail = 0;
 800225e:	687b      	ldr	r3, [r7, #4]
 8002260:	2200      	movs	r2, #0
 8002262:	609a      	str	r2, [r3, #8]
    ringbuffer->u8Buffer = (uint8_t*)malloc(BufferSize*sizeof(uint8_t));
 8002264:	683b      	ldr	r3, [r7, #0]
 8002266:	0018      	movs	r0, r3
 8002268:	f01b fe80 	bl	801df6c <malloc>
 800226c:	0003      	movs	r3, r0
 800226e:	001a      	movs	r2, r3
 8002270:	687b      	ldr	r3, [r7, #4]
 8002272:	60da      	str	r2, [r3, #12]
}
 8002274:	46c0      	nop			; (mov r8, r8)
 8002276:	46bd      	mov	sp, r7
 8002278:	b002      	add	sp, #8
 800227a:	bd80      	pop	{r7, pc}

0800227c <RingBuffer_Push>:

// Day 1 Byte vÃ o RingBuffer
uint8_t RingBuffer_Push(RingBuffer_Types* ringbuffer, uint8_t BytePush)
{
 800227c:	b580      	push	{r7, lr}
 800227e:	b082      	sub	sp, #8
 8002280:	af00      	add	r7, sp, #0
 8002282:	6078      	str	r0, [r7, #4]
 8002284:	000a      	movs	r2, r1
 8002286:	1cfb      	adds	r3, r7, #3
 8002288:	701a      	strb	r2, [r3, #0]
    if((ringbuffer->Head - ringbuffer->Tail == (ringbuffer->BufferSize - 1))
 800228a:	687b      	ldr	r3, [r7, #4]
 800228c:	685a      	ldr	r2, [r3, #4]
 800228e:	687b      	ldr	r3, [r7, #4]
 8002290:	689b      	ldr	r3, [r3, #8]
 8002292:	1ad2      	subs	r2, r2, r3
 8002294:	687b      	ldr	r3, [r7, #4]
 8002296:	681b      	ldr	r3, [r3, #0]
 8002298:	3b01      	subs	r3, #1
 800229a:	429a      	cmp	r2, r3
 800229c:	d009      	beq.n	80022b2 <RingBuffer_Push+0x36>
       || (ringbuffer->Tail - ringbuffer->Head == (ringbuffer->BufferSize - 1)))
 800229e:	687b      	ldr	r3, [r7, #4]
 80022a0:	689a      	ldr	r2, [r3, #8]
 80022a2:	687b      	ldr	r3, [r7, #4]
 80022a4:	685b      	ldr	r3, [r3, #4]
 80022a6:	1ad2      	subs	r2, r2, r3
 80022a8:	687b      	ldr	r3, [r7, #4]
 80022aa:	681b      	ldr	r3, [r3, #0]
 80022ac:	3b01      	subs	r3, #1
 80022ae:	429a      	cmp	r2, r3
 80022b0:	d101      	bne.n	80022b6 <RingBuffer_Push+0x3a>
       {
        return E_NOT_OK; // return E_NOT_OK khi bo nho Full
 80022b2:	2300      	movs	r3, #0
 80022b4:	e018      	b.n	80022e8 <RingBuffer_Push+0x6c>
       }
    ringbuffer->u8Buffer[ringbuffer->Head] = BytePush;
 80022b6:	687b      	ldr	r3, [r7, #4]
 80022b8:	68da      	ldr	r2, [r3, #12]
 80022ba:	687b      	ldr	r3, [r7, #4]
 80022bc:	685b      	ldr	r3, [r3, #4]
 80022be:	18d3      	adds	r3, r2, r3
 80022c0:	1cfa      	adds	r2, r7, #3
 80022c2:	7812      	ldrb	r2, [r2, #0]
 80022c4:	701a      	strb	r2, [r3, #0]
    if(ringbuffer->Head == (ringbuffer->BufferSize - 1))
 80022c6:	687b      	ldr	r3, [r7, #4]
 80022c8:	685a      	ldr	r2, [r3, #4]
 80022ca:	687b      	ldr	r3, [r7, #4]
 80022cc:	681b      	ldr	r3, [r3, #0]
 80022ce:	3b01      	subs	r3, #1
 80022d0:	429a      	cmp	r2, r3
 80022d2:	d103      	bne.n	80022dc <RingBuffer_Push+0x60>
    {
        ringbuffer->Head = 0;
 80022d4:	687b      	ldr	r3, [r7, #4]
 80022d6:	2200      	movs	r2, #0
 80022d8:	605a      	str	r2, [r3, #4]
 80022da:	e004      	b.n	80022e6 <RingBuffer_Push+0x6a>
    }
    else
    {
        ringbuffer->Head += 1;
 80022dc:	687b      	ldr	r3, [r7, #4]
 80022de:	685b      	ldr	r3, [r3, #4]
 80022e0:	1c5a      	adds	r2, r3, #1
 80022e2:	687b      	ldr	r3, [r7, #4]
 80022e4:	605a      	str	r2, [r3, #4]
    }
    return E_OK;
 80022e6:	2301      	movs	r3, #1
}
 80022e8:	0018      	movs	r0, r3
 80022ea:	46bd      	mov	sp, r7
 80022ec:	b002      	add	sp, #8
 80022ee:	bd80      	pop	{r7, pc}

080022f0 <RingBuffer_Pop>:

// Doc 1 byte tÆ° RingBuffer
uint8_t RingBuffer_Pop(RingBuffer_Types* ringbuffer)
{
 80022f0:	b580      	push	{r7, lr}
 80022f2:	b084      	sub	sp, #16
 80022f4:	af00      	add	r7, sp, #0
 80022f6:	6078      	str	r0, [r7, #4]
    uint8_t BytePush = 0;
 80022f8:	210f      	movs	r1, #15
 80022fa:	187b      	adds	r3, r7, r1
 80022fc:	2200      	movs	r2, #0
 80022fe:	701a      	strb	r2, [r3, #0]
    if(ringbuffer->Head == ringbuffer->Tail)
 8002300:	687b      	ldr	r3, [r7, #4]
 8002302:	685a      	ldr	r2, [r3, #4]
 8002304:	687b      	ldr	r3, [r7, #4]
 8002306:	689b      	ldr	r3, [r3, #8]
 8002308:	429a      	cmp	r2, r3
 800230a:	d102      	bne.n	8002312 <RingBuffer_Pop+0x22>
    {
        return BytePush; // Return Null khi bo nho Empty
 800230c:	187b      	adds	r3, r7, r1
 800230e:	781b      	ldrb	r3, [r3, #0]
 8002310:	e01b      	b.n	800234a <RingBuffer_Pop+0x5a>
    }
    BytePush = ringbuffer->u8Buffer[ringbuffer->Tail];
 8002312:	687b      	ldr	r3, [r7, #4]
 8002314:	68da      	ldr	r2, [r3, #12]
 8002316:	687b      	ldr	r3, [r7, #4]
 8002318:	689b      	ldr	r3, [r3, #8]
 800231a:	18d2      	adds	r2, r2, r3
 800231c:	230f      	movs	r3, #15
 800231e:	18fb      	adds	r3, r7, r3
 8002320:	7812      	ldrb	r2, [r2, #0]
 8002322:	701a      	strb	r2, [r3, #0]
    if(ringbuffer->Tail == (ringbuffer->BufferSize - 1))
 8002324:	687b      	ldr	r3, [r7, #4]
 8002326:	689a      	ldr	r2, [r3, #8]
 8002328:	687b      	ldr	r3, [r7, #4]
 800232a:	681b      	ldr	r3, [r3, #0]
 800232c:	3b01      	subs	r3, #1
 800232e:	429a      	cmp	r2, r3
 8002330:	d103      	bne.n	800233a <RingBuffer_Pop+0x4a>
    {
        ringbuffer->Tail = 0;
 8002332:	687b      	ldr	r3, [r7, #4]
 8002334:	2200      	movs	r2, #0
 8002336:	609a      	str	r2, [r3, #8]
 8002338:	e004      	b.n	8002344 <RingBuffer_Pop+0x54>
    }
    else
    {
        ringbuffer->Tail += 1;
 800233a:	687b      	ldr	r3, [r7, #4]
 800233c:	689b      	ldr	r3, [r3, #8]
 800233e:	1c5a      	adds	r2, r3, #1
 8002340:	687b      	ldr	r3, [r7, #4]
 8002342:	609a      	str	r2, [r3, #8]
    }
    return BytePush;
 8002344:	230f      	movs	r3, #15
 8002346:	18fb      	adds	r3, r7, r3
 8002348:	781b      	ldrb	r3, [r3, #0]
}
 800234a:	0018      	movs	r0, r3
 800234c:	46bd      	mov	sp, r7
 800234e:	b004      	add	sp, #16
 8002350:	bd80      	pop	{r7, pc}

08002352 <RingBuffer_GetBuffer>:
// Doc toan bo du lieu trong RingBuffer gÃ¡n vÃ o return Buffer
void RingBuffer_GetBuffer(uint8_t* retBuffer, uint16_t* dataLength, RingBuffer_Types* ringbuffer)
{
 8002352:	b590      	push	{r4, r7, lr}
 8002354:	b087      	sub	sp, #28
 8002356:	af00      	add	r7, sp, #0
 8002358:	60f8      	str	r0, [r7, #12]
 800235a:	60b9      	str	r1, [r7, #8]
 800235c:	607a      	str	r2, [r7, #4]
    int Num_Elements = RingBuffer_GetNumberElements(ringbuffer);
 800235e:	687b      	ldr	r3, [r7, #4]
 8002360:	0018      	movs	r0, r3
 8002362:	f000 f821 	bl	80023a8 <RingBuffer_GetNumberElements>
 8002366:	0003      	movs	r3, r0
 8002368:	613b      	str	r3, [r7, #16]
    if(Num_Elements == 0)
 800236a:	693b      	ldr	r3, [r7, #16]
 800236c:	2b00      	cmp	r3, #0
 800236e:	d017      	beq.n	80023a0 <RingBuffer_GetBuffer+0x4e>
    {
    	return;
    }
    for(int CountByte = 0; CountByte < Num_Elements; CountByte ++)
 8002370:	2300      	movs	r3, #0
 8002372:	617b      	str	r3, [r7, #20]
 8002374:	e00b      	b.n	800238e <RingBuffer_GetBuffer+0x3c>
    {
        retBuffer[CountByte] = RingBuffer_Pop(ringbuffer);
 8002376:	697b      	ldr	r3, [r7, #20]
 8002378:	68fa      	ldr	r2, [r7, #12]
 800237a:	18d4      	adds	r4, r2, r3
 800237c:	687b      	ldr	r3, [r7, #4]
 800237e:	0018      	movs	r0, r3
 8002380:	f7ff ffb6 	bl	80022f0 <RingBuffer_Pop>
 8002384:	0003      	movs	r3, r0
 8002386:	7023      	strb	r3, [r4, #0]
    for(int CountByte = 0; CountByte < Num_Elements; CountByte ++)
 8002388:	697b      	ldr	r3, [r7, #20]
 800238a:	3301      	adds	r3, #1
 800238c:	617b      	str	r3, [r7, #20]
 800238e:	697a      	ldr	r2, [r7, #20]
 8002390:	693b      	ldr	r3, [r7, #16]
 8002392:	429a      	cmp	r2, r3
 8002394:	dbef      	blt.n	8002376 <RingBuffer_GetBuffer+0x24>
    }
    *dataLength = Num_Elements;
 8002396:	693b      	ldr	r3, [r7, #16]
 8002398:	b29a      	uxth	r2, r3
 800239a:	68bb      	ldr	r3, [r7, #8]
 800239c:	801a      	strh	r2, [r3, #0]
 800239e:	e000      	b.n	80023a2 <RingBuffer_GetBuffer+0x50>
    	return;
 80023a0:	46c0      	nop			; (mov r8, r8)
}
 80023a2:	46bd      	mov	sp, r7
 80023a4:	b007      	add	sp, #28
 80023a6:	bd90      	pop	{r4, r7, pc}

080023a8 <RingBuffer_GetNumberElements>:

// Lay tong so byte du lieu trong RingBuffer
int RingBuffer_GetNumberElements(RingBuffer_Types* ringbuffer)
{
 80023a8:	b580      	push	{r7, lr}
 80023aa:	b084      	sub	sp, #16
 80023ac:	af00      	add	r7, sp, #0
 80023ae:	6078      	str	r0, [r7, #4]
    int Num_Element = 0;
 80023b0:	2300      	movs	r3, #0
 80023b2:	60fb      	str	r3, [r7, #12]
    if (ringbuffer->Head >= ringbuffer->Tail)
 80023b4:	687b      	ldr	r3, [r7, #4]
 80023b6:	685a      	ldr	r2, [r3, #4]
 80023b8:	687b      	ldr	r3, [r7, #4]
 80023ba:	689b      	ldr	r3, [r3, #8]
 80023bc:	429a      	cmp	r2, r3
 80023be:	db06      	blt.n	80023ce <RingBuffer_GetNumberElements+0x26>
    {
        Num_Element = ringbuffer->Head - ringbuffer->Tail;
 80023c0:	687b      	ldr	r3, [r7, #4]
 80023c2:	685a      	ldr	r2, [r3, #4]
 80023c4:	687b      	ldr	r3, [r7, #4]
 80023c6:	689b      	ldr	r3, [r3, #8]
 80023c8:	1ad3      	subs	r3, r2, r3
 80023ca:	60fb      	str	r3, [r7, #12]
 80023cc:	e008      	b.n	80023e0 <RingBuffer_GetNumberElements+0x38>
    }
    else
    {
        Num_Element = ringbuffer->BufferSize - ringbuffer->Tail + ringbuffer->Head;
 80023ce:	687b      	ldr	r3, [r7, #4]
 80023d0:	681a      	ldr	r2, [r3, #0]
 80023d2:	687b      	ldr	r3, [r7, #4]
 80023d4:	689b      	ldr	r3, [r3, #8]
 80023d6:	1ad2      	subs	r2, r2, r3
 80023d8:	687b      	ldr	r3, [r7, #4]
 80023da:	685b      	ldr	r3, [r3, #4]
 80023dc:	18d3      	adds	r3, r2, r3
 80023de:	60fb      	str	r3, [r7, #12]
    }
    return Num_Element;
 80023e0:	68fb      	ldr	r3, [r7, #12]
}
 80023e2:	0018      	movs	r0, r3
 80023e4:	46bd      	mov	sp, r7
 80023e6:	b004      	add	sp, #16
 80023e8:	bd80      	pop	{r7, pc}
	...

080023ec <HAL_Init>:
  *        In the default implementation,Systick is used as source of time base.
  *        the tick variable is incremented each 1ms in its ISR.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 80023ec:	b580      	push	{r7, lr}
 80023ee:	b082      	sub	sp, #8
 80023f0:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
 80023f2:	1dfb      	adds	r3, r7, #7
 80023f4:	2200      	movs	r2, #0
 80023f6:	701a      	strb	r2, [r3, #0]
#if (BUFFER_CACHE_DISABLE != 0)
  __HAL_FLASH_BUFFER_CACHE_DISABLE();
#endif /* BUFFER_CACHE_DISABLE */

#if (PREREAD_ENABLE != 0)
  __HAL_FLASH_PREREAD_BUFFER_ENABLE();
 80023f8:	4b0b      	ldr	r3, [pc, #44]	; (8002428 <HAL_Init+0x3c>)
 80023fa:	681a      	ldr	r2, [r3, #0]
 80023fc:	4b0a      	ldr	r3, [pc, #40]	; (8002428 <HAL_Init+0x3c>)
 80023fe:	2140      	movs	r1, #64	; 0x40
 8002400:	430a      	orrs	r2, r1
 8002402:	601a      	str	r2, [r3, #0]
#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif /* PREFETCH_ENABLE */

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8002404:	2003      	movs	r0, #3
 8002406:	f000 f811 	bl	800242c <HAL_InitTick>
 800240a:	1e03      	subs	r3, r0, #0
 800240c:	d003      	beq.n	8002416 <HAL_Init+0x2a>
  {
    status = HAL_ERROR;
 800240e:	1dfb      	adds	r3, r7, #7
 8002410:	2201      	movs	r2, #1
 8002412:	701a      	strb	r2, [r3, #0]
 8002414:	e001      	b.n	800241a <HAL_Init+0x2e>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
 8002416:	f7fe f9db 	bl	80007d0 <HAL_MspInit>
  }

  /* Return function status */
  return status;
 800241a:	1dfb      	adds	r3, r7, #7
 800241c:	781b      	ldrb	r3, [r3, #0]
}
 800241e:	0018      	movs	r0, r3
 8002420:	46bd      	mov	sp, r7
 8002422:	b002      	add	sp, #8
 8002424:	bd80      	pop	{r7, pc}
 8002426:	46c0      	nop			; (mov r8, r8)
 8002428:	40022000 	.word	0x40022000

0800242c <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800242c:	b590      	push	{r4, r7, lr}
 800242e:	b083      	sub	sp, #12
 8002430:	af00      	add	r7, sp, #0
 8002432:	6078      	str	r0, [r7, #4]
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8002434:	4b14      	ldr	r3, [pc, #80]	; (8002488 <HAL_InitTick+0x5c>)
 8002436:	681c      	ldr	r4, [r3, #0]
 8002438:	4b14      	ldr	r3, [pc, #80]	; (800248c <HAL_InitTick+0x60>)
 800243a:	781b      	ldrb	r3, [r3, #0]
 800243c:	0019      	movs	r1, r3
 800243e:	23fa      	movs	r3, #250	; 0xfa
 8002440:	0098      	lsls	r0, r3, #2
 8002442:	f7fd fe7d 	bl	8000140 <__udivsi3>
 8002446:	0003      	movs	r3, r0
 8002448:	0019      	movs	r1, r3
 800244a:	0020      	movs	r0, r4
 800244c:	f7fd fe78 	bl	8000140 <__udivsi3>
 8002450:	0003      	movs	r3, r0
 8002452:	0018      	movs	r0, r3
 8002454:	f000 f92f 	bl	80026b6 <HAL_SYSTICK_Config>
 8002458:	1e03      	subs	r3, r0, #0
 800245a:	d001      	beq.n	8002460 <HAL_InitTick+0x34>
  {
    return HAL_ERROR;
 800245c:	2301      	movs	r3, #1
 800245e:	e00f      	b.n	8002480 <HAL_InitTick+0x54>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8002460:	687b      	ldr	r3, [r7, #4]
 8002462:	2b03      	cmp	r3, #3
 8002464:	d80b      	bhi.n	800247e <HAL_InitTick+0x52>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8002466:	6879      	ldr	r1, [r7, #4]
 8002468:	2301      	movs	r3, #1
 800246a:	425b      	negs	r3, r3
 800246c:	2200      	movs	r2, #0
 800246e:	0018      	movs	r0, r3
 8002470:	f000 f8fc 	bl	800266c <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 8002474:	4b06      	ldr	r3, [pc, #24]	; (8002490 <HAL_InitTick+0x64>)
 8002476:	687a      	ldr	r2, [r7, #4]
 8002478:	601a      	str	r2, [r3, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
 800247a:	2300      	movs	r3, #0
 800247c:	e000      	b.n	8002480 <HAL_InitTick+0x54>
    return HAL_ERROR;
 800247e:	2301      	movs	r3, #1
}
 8002480:	0018      	movs	r0, r3
 8002482:	46bd      	mov	sp, r7
 8002484:	b003      	add	sp, #12
 8002486:	bd90      	pop	{r4, r7, pc}
 8002488:	20000018 	.word	0x20000018
 800248c:	20000020 	.word	0x20000020
 8002490:	2000001c 	.word	0x2000001c

08002494 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8002494:	b580      	push	{r7, lr}
 8002496:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 8002498:	4b05      	ldr	r3, [pc, #20]	; (80024b0 <HAL_IncTick+0x1c>)
 800249a:	781b      	ldrb	r3, [r3, #0]
 800249c:	001a      	movs	r2, r3
 800249e:	4b05      	ldr	r3, [pc, #20]	; (80024b4 <HAL_IncTick+0x20>)
 80024a0:	681b      	ldr	r3, [r3, #0]
 80024a2:	18d2      	adds	r2, r2, r3
 80024a4:	4b03      	ldr	r3, [pc, #12]	; (80024b4 <HAL_IncTick+0x20>)
 80024a6:	601a      	str	r2, [r3, #0]
}
 80024a8:	46c0      	nop			; (mov r8, r8)
 80024aa:	46bd      	mov	sp, r7
 80024ac:	bd80      	pop	{r7, pc}
 80024ae:	46c0      	nop			; (mov r8, r8)
 80024b0:	20000020 	.word	0x20000020
 80024b4:	20001134 	.word	0x20001134

080024b8 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 80024b8:	b580      	push	{r7, lr}
 80024ba:	af00      	add	r7, sp, #0
  return uwTick;
 80024bc:	4b02      	ldr	r3, [pc, #8]	; (80024c8 <HAL_GetTick+0x10>)
 80024be:	681b      	ldr	r3, [r3, #0]
}
 80024c0:	0018      	movs	r0, r3
 80024c2:	46bd      	mov	sp, r7
 80024c4:	bd80      	pop	{r7, pc}
 80024c6:	46c0      	nop			; (mov r8, r8)
 80024c8:	20001134 	.word	0x20001134

080024cc <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 80024cc:	b580      	push	{r7, lr}
 80024ce:	b084      	sub	sp, #16
 80024d0:	af00      	add	r7, sp, #0
 80024d2:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 80024d4:	f7ff fff0 	bl	80024b8 <HAL_GetTick>
 80024d8:	0003      	movs	r3, r0
 80024da:	60bb      	str	r3, [r7, #8]
  uint32_t wait = Delay;
 80024dc:	687b      	ldr	r3, [r7, #4]
 80024de:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 80024e0:	68fb      	ldr	r3, [r7, #12]
 80024e2:	3301      	adds	r3, #1
 80024e4:	d005      	beq.n	80024f2 <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
 80024e6:	4b0a      	ldr	r3, [pc, #40]	; (8002510 <HAL_Delay+0x44>)
 80024e8:	781b      	ldrb	r3, [r3, #0]
 80024ea:	001a      	movs	r2, r3
 80024ec:	68fb      	ldr	r3, [r7, #12]
 80024ee:	189b      	adds	r3, r3, r2
 80024f0:	60fb      	str	r3, [r7, #12]
  }

  while((HAL_GetTick() - tickstart) < wait)
 80024f2:	46c0      	nop			; (mov r8, r8)
 80024f4:	f7ff ffe0 	bl	80024b8 <HAL_GetTick>
 80024f8:	0002      	movs	r2, r0
 80024fa:	68bb      	ldr	r3, [r7, #8]
 80024fc:	1ad3      	subs	r3, r2, r3
 80024fe:	68fa      	ldr	r2, [r7, #12]
 8002500:	429a      	cmp	r2, r3
 8002502:	d8f7      	bhi.n	80024f4 <HAL_Delay+0x28>
  {
  }
}
 8002504:	46c0      	nop			; (mov r8, r8)
 8002506:	46c0      	nop			; (mov r8, r8)
 8002508:	46bd      	mov	sp, r7
 800250a:	b004      	add	sp, #16
 800250c:	bd80      	pop	{r7, pc}
 800250e:	46c0      	nop			; (mov r8, r8)
 8002510:	20000020 	.word	0x20000020

08002514 <__NVIC_EnableIRQ>:
{
 8002514:	b580      	push	{r7, lr}
 8002516:	b082      	sub	sp, #8
 8002518:	af00      	add	r7, sp, #0
 800251a:	0002      	movs	r2, r0
 800251c:	1dfb      	adds	r3, r7, #7
 800251e:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
 8002520:	1dfb      	adds	r3, r7, #7
 8002522:	781b      	ldrb	r3, [r3, #0]
 8002524:	2b7f      	cmp	r3, #127	; 0x7f
 8002526:	d809      	bhi.n	800253c <__NVIC_EnableIRQ+0x28>
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8002528:	1dfb      	adds	r3, r7, #7
 800252a:	781b      	ldrb	r3, [r3, #0]
 800252c:	001a      	movs	r2, r3
 800252e:	231f      	movs	r3, #31
 8002530:	401a      	ands	r2, r3
 8002532:	4b04      	ldr	r3, [pc, #16]	; (8002544 <__NVIC_EnableIRQ+0x30>)
 8002534:	2101      	movs	r1, #1
 8002536:	4091      	lsls	r1, r2
 8002538:	000a      	movs	r2, r1
 800253a:	601a      	str	r2, [r3, #0]
}
 800253c:	46c0      	nop			; (mov r8, r8)
 800253e:	46bd      	mov	sp, r7
 8002540:	b002      	add	sp, #8
 8002542:	bd80      	pop	{r7, pc}
 8002544:	e000e100 	.word	0xe000e100

08002548 <__NVIC_SetPriority>:
{
 8002548:	b590      	push	{r4, r7, lr}
 800254a:	b083      	sub	sp, #12
 800254c:	af00      	add	r7, sp, #0
 800254e:	0002      	movs	r2, r0
 8002550:	6039      	str	r1, [r7, #0]
 8002552:	1dfb      	adds	r3, r7, #7
 8002554:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
 8002556:	1dfb      	adds	r3, r7, #7
 8002558:	781b      	ldrb	r3, [r3, #0]
 800255a:	2b7f      	cmp	r3, #127	; 0x7f
 800255c:	d828      	bhi.n	80025b0 <__NVIC_SetPriority+0x68>
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800255e:	4a2f      	ldr	r2, [pc, #188]	; (800261c <__NVIC_SetPriority+0xd4>)
 8002560:	1dfb      	adds	r3, r7, #7
 8002562:	781b      	ldrb	r3, [r3, #0]
 8002564:	b25b      	sxtb	r3, r3
 8002566:	089b      	lsrs	r3, r3, #2
 8002568:	33c0      	adds	r3, #192	; 0xc0
 800256a:	009b      	lsls	r3, r3, #2
 800256c:	589b      	ldr	r3, [r3, r2]
 800256e:	1dfa      	adds	r2, r7, #7
 8002570:	7812      	ldrb	r2, [r2, #0]
 8002572:	0011      	movs	r1, r2
 8002574:	2203      	movs	r2, #3
 8002576:	400a      	ands	r2, r1
 8002578:	00d2      	lsls	r2, r2, #3
 800257a:	21ff      	movs	r1, #255	; 0xff
 800257c:	4091      	lsls	r1, r2
 800257e:	000a      	movs	r2, r1
 8002580:	43d2      	mvns	r2, r2
 8002582:	401a      	ands	r2, r3
 8002584:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 8002586:	683b      	ldr	r3, [r7, #0]
 8002588:	019b      	lsls	r3, r3, #6
 800258a:	22ff      	movs	r2, #255	; 0xff
 800258c:	401a      	ands	r2, r3
 800258e:	1dfb      	adds	r3, r7, #7
 8002590:	781b      	ldrb	r3, [r3, #0]
 8002592:	0018      	movs	r0, r3
 8002594:	2303      	movs	r3, #3
 8002596:	4003      	ands	r3, r0
 8002598:	00db      	lsls	r3, r3, #3
 800259a:	409a      	lsls	r2, r3
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800259c:	481f      	ldr	r0, [pc, #124]	; (800261c <__NVIC_SetPriority+0xd4>)
 800259e:	1dfb      	adds	r3, r7, #7
 80025a0:	781b      	ldrb	r3, [r3, #0]
 80025a2:	b25b      	sxtb	r3, r3
 80025a4:	089b      	lsrs	r3, r3, #2
 80025a6:	430a      	orrs	r2, r1
 80025a8:	33c0      	adds	r3, #192	; 0xc0
 80025aa:	009b      	lsls	r3, r3, #2
 80025ac:	501a      	str	r2, [r3, r0]
}
 80025ae:	e031      	b.n	8002614 <__NVIC_SetPriority+0xcc>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80025b0:	4a1b      	ldr	r2, [pc, #108]	; (8002620 <__NVIC_SetPriority+0xd8>)
 80025b2:	1dfb      	adds	r3, r7, #7
 80025b4:	781b      	ldrb	r3, [r3, #0]
 80025b6:	0019      	movs	r1, r3
 80025b8:	230f      	movs	r3, #15
 80025ba:	400b      	ands	r3, r1
 80025bc:	3b08      	subs	r3, #8
 80025be:	089b      	lsrs	r3, r3, #2
 80025c0:	3306      	adds	r3, #6
 80025c2:	009b      	lsls	r3, r3, #2
 80025c4:	18d3      	adds	r3, r2, r3
 80025c6:	3304      	adds	r3, #4
 80025c8:	681b      	ldr	r3, [r3, #0]
 80025ca:	1dfa      	adds	r2, r7, #7
 80025cc:	7812      	ldrb	r2, [r2, #0]
 80025ce:	0011      	movs	r1, r2
 80025d0:	2203      	movs	r2, #3
 80025d2:	400a      	ands	r2, r1
 80025d4:	00d2      	lsls	r2, r2, #3
 80025d6:	21ff      	movs	r1, #255	; 0xff
 80025d8:	4091      	lsls	r1, r2
 80025da:	000a      	movs	r2, r1
 80025dc:	43d2      	mvns	r2, r2
 80025de:	401a      	ands	r2, r3
 80025e0:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 80025e2:	683b      	ldr	r3, [r7, #0]
 80025e4:	019b      	lsls	r3, r3, #6
 80025e6:	22ff      	movs	r2, #255	; 0xff
 80025e8:	401a      	ands	r2, r3
 80025ea:	1dfb      	adds	r3, r7, #7
 80025ec:	781b      	ldrb	r3, [r3, #0]
 80025ee:	0018      	movs	r0, r3
 80025f0:	2303      	movs	r3, #3
 80025f2:	4003      	ands	r3, r0
 80025f4:	00db      	lsls	r3, r3, #3
 80025f6:	409a      	lsls	r2, r3
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80025f8:	4809      	ldr	r0, [pc, #36]	; (8002620 <__NVIC_SetPriority+0xd8>)
 80025fa:	1dfb      	adds	r3, r7, #7
 80025fc:	781b      	ldrb	r3, [r3, #0]
 80025fe:	001c      	movs	r4, r3
 8002600:	230f      	movs	r3, #15
 8002602:	4023      	ands	r3, r4
 8002604:	3b08      	subs	r3, #8
 8002606:	089b      	lsrs	r3, r3, #2
 8002608:	430a      	orrs	r2, r1
 800260a:	3306      	adds	r3, #6
 800260c:	009b      	lsls	r3, r3, #2
 800260e:	18c3      	adds	r3, r0, r3
 8002610:	3304      	adds	r3, #4
 8002612:	601a      	str	r2, [r3, #0]
}
 8002614:	46c0      	nop			; (mov r8, r8)
 8002616:	46bd      	mov	sp, r7
 8002618:	b003      	add	sp, #12
 800261a:	bd90      	pop	{r4, r7, pc}
 800261c:	e000e100 	.word	0xe000e100
 8002620:	e000ed00 	.word	0xe000ed00

08002624 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 8002624:	b580      	push	{r7, lr}
 8002626:	b082      	sub	sp, #8
 8002628:	af00      	add	r7, sp, #0
 800262a:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 800262c:	687b      	ldr	r3, [r7, #4]
 800262e:	1e5a      	subs	r2, r3, #1
 8002630:	2380      	movs	r3, #128	; 0x80
 8002632:	045b      	lsls	r3, r3, #17
 8002634:	429a      	cmp	r2, r3
 8002636:	d301      	bcc.n	800263c <SysTick_Config+0x18>
  {
    return (1UL);                                                   /* Reload value impossible */
 8002638:	2301      	movs	r3, #1
 800263a:	e010      	b.n	800265e <SysTick_Config+0x3a>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800263c:	4b0a      	ldr	r3, [pc, #40]	; (8002668 <SysTick_Config+0x44>)
 800263e:	687a      	ldr	r2, [r7, #4]
 8002640:	3a01      	subs	r2, #1
 8002642:	605a      	str	r2, [r3, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 8002644:	2301      	movs	r3, #1
 8002646:	425b      	negs	r3, r3
 8002648:	2103      	movs	r1, #3
 800264a:	0018      	movs	r0, r3
 800264c:	f7ff ff7c 	bl	8002548 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8002650:	4b05      	ldr	r3, [pc, #20]	; (8002668 <SysTick_Config+0x44>)
 8002652:	2200      	movs	r2, #0
 8002654:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8002656:	4b04      	ldr	r3, [pc, #16]	; (8002668 <SysTick_Config+0x44>)
 8002658:	2207      	movs	r2, #7
 800265a:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 800265c:	2300      	movs	r3, #0
}
 800265e:	0018      	movs	r0, r3
 8002660:	46bd      	mov	sp, r7
 8002662:	b002      	add	sp, #8
 8002664:	bd80      	pop	{r7, pc}
 8002666:	46c0      	nop			; (mov r8, r8)
 8002668:	e000e010 	.word	0xe000e010

0800266c <HAL_NVIC_SetPriority>:
  *         with stm32l0xx devices, this parameter is a dummy value and it is ignored, because 
  *         no subpriority supported in Cortex M0+ based products.   
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 800266c:	b580      	push	{r7, lr}
 800266e:	b084      	sub	sp, #16
 8002670:	af00      	add	r7, sp, #0
 8002672:	60b9      	str	r1, [r7, #8]
 8002674:	607a      	str	r2, [r7, #4]
 8002676:	210f      	movs	r1, #15
 8002678:	187b      	adds	r3, r7, r1
 800267a:	1c02      	adds	r2, r0, #0
 800267c:	701a      	strb	r2, [r3, #0]
    /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn,PreemptPriority);
 800267e:	68ba      	ldr	r2, [r7, #8]
 8002680:	187b      	adds	r3, r7, r1
 8002682:	781b      	ldrb	r3, [r3, #0]
 8002684:	b25b      	sxtb	r3, r3
 8002686:	0011      	movs	r1, r2
 8002688:	0018      	movs	r0, r3
 800268a:	f7ff ff5d 	bl	8002548 <__NVIC_SetPriority>
}
 800268e:	46c0      	nop			; (mov r8, r8)
 8002690:	46bd      	mov	sp, r7
 8002692:	b004      	add	sp, #16
 8002694:	bd80      	pop	{r7, pc}

08002696 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of  IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to stm32l0xx.h file)  
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8002696:	b580      	push	{r7, lr}
 8002698:	b082      	sub	sp, #8
 800269a:	af00      	add	r7, sp, #0
 800269c:	0002      	movs	r2, r0
 800269e:	1dfb      	adds	r3, r7, #7
 80026a0:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 80026a2:	1dfb      	adds	r3, r7, #7
 80026a4:	781b      	ldrb	r3, [r3, #0]
 80026a6:	b25b      	sxtb	r3, r3
 80026a8:	0018      	movs	r0, r3
 80026aa:	f7ff ff33 	bl	8002514 <__NVIC_EnableIRQ>
}
 80026ae:	46c0      	nop			; (mov r8, r8)
 80026b0:	46bd      	mov	sp, r7
 80026b2:	b002      	add	sp, #8
 80026b4:	bd80      	pop	{r7, pc}

080026b6 <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 80026b6:	b580      	push	{r7, lr}
 80026b8:	b082      	sub	sp, #8
 80026ba:	af00      	add	r7, sp, #0
 80026bc:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 80026be:	687b      	ldr	r3, [r7, #4]
 80026c0:	0018      	movs	r0, r3
 80026c2:	f7ff ffaf 	bl	8002624 <SysTick_Config>
 80026c6:	0003      	movs	r3, r0
}
 80026c8:	0018      	movs	r0, r3
 80026ca:	46bd      	mov	sp, r7
 80026cc:	b002      	add	sp, #8
 80026ce:	bd80      	pop	{r7, pc}

080026d0 <HAL_DMA_Abort>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
    * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
{
 80026d0:	b580      	push	{r7, lr}
 80026d2:	b084      	sub	sp, #16
 80026d4:	af00      	add	r7, sp, #0
 80026d6:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 80026d8:	230f      	movs	r3, #15
 80026da:	18fb      	adds	r3, r7, r3
 80026dc:	2200      	movs	r2, #0
 80026de:	701a      	strb	r2, [r3, #0]

  /* Check the DMA peripheral state */
  if(hdma->State != HAL_DMA_STATE_BUSY)
 80026e0:	687b      	ldr	r3, [r7, #4]
 80026e2:	2225      	movs	r2, #37	; 0x25
 80026e4:	5c9b      	ldrb	r3, [r3, r2]
 80026e6:	b2db      	uxtb	r3, r3
 80026e8:	2b02      	cmp	r3, #2
 80026ea:	d008      	beq.n	80026fe <HAL_DMA_Abort+0x2e>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 80026ec:	687b      	ldr	r3, [r7, #4]
 80026ee:	2204      	movs	r2, #4
 80026f0:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 80026f2:	687b      	ldr	r3, [r7, #4]
 80026f4:	2224      	movs	r2, #36	; 0x24
 80026f6:	2100      	movs	r1, #0
 80026f8:	5499      	strb	r1, [r3, r2]

    return HAL_ERROR;
 80026fa:	2301      	movs	r3, #1
 80026fc:	e024      	b.n	8002748 <HAL_DMA_Abort+0x78>
  }
  else
  {
    /* Disable DMA IT */
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 80026fe:	687b      	ldr	r3, [r7, #4]
 8002700:	681b      	ldr	r3, [r3, #0]
 8002702:	681a      	ldr	r2, [r3, #0]
 8002704:	687b      	ldr	r3, [r7, #4]
 8002706:	681b      	ldr	r3, [r3, #0]
 8002708:	210e      	movs	r1, #14
 800270a:	438a      	bics	r2, r1
 800270c:	601a      	str	r2, [r3, #0]

    /* Disable the channel */
    __HAL_DMA_DISABLE(hdma);
 800270e:	687b      	ldr	r3, [r7, #4]
 8002710:	681b      	ldr	r3, [r3, #0]
 8002712:	681a      	ldr	r2, [r3, #0]
 8002714:	687b      	ldr	r3, [r7, #4]
 8002716:	681b      	ldr	r3, [r3, #0]
 8002718:	2101      	movs	r1, #1
 800271a:	438a      	bics	r2, r1
 800271c:	601a      	str	r2, [r3, #0]

    /* Clear all flags */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
 800271e:	687b      	ldr	r3, [r7, #4]
 8002720:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002722:	221c      	movs	r2, #28
 8002724:	401a      	ands	r2, r3
 8002726:	687b      	ldr	r3, [r7, #4]
 8002728:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800272a:	2101      	movs	r1, #1
 800272c:	4091      	lsls	r1, r2
 800272e:	000a      	movs	r2, r1
 8002730:	605a      	str	r2, [r3, #4]

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
 8002732:	687b      	ldr	r3, [r7, #4]
 8002734:	2225      	movs	r2, #37	; 0x25
 8002736:	2101      	movs	r1, #1
 8002738:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 800273a:	687b      	ldr	r3, [r7, #4]
 800273c:	2224      	movs	r2, #36	; 0x24
 800273e:	2100      	movs	r1, #0
 8002740:	5499      	strb	r1, [r3, r2]

    return status;
 8002742:	230f      	movs	r3, #15
 8002744:	18fb      	adds	r3, r7, r3
 8002746:	781b      	ldrb	r3, [r3, #0]
  }
}
 8002748:	0018      	movs	r0, r3
 800274a:	46bd      	mov	sp, r7
 800274c:	b004      	add	sp, #16
 800274e:	bd80      	pop	{r7, pc}

08002750 <HAL_DMA_Abort_IT>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
 8002750:	b580      	push	{r7, lr}
 8002752:	b084      	sub	sp, #16
 8002754:	af00      	add	r7, sp, #0
 8002756:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8002758:	210f      	movs	r1, #15
 800275a:	187b      	adds	r3, r7, r1
 800275c:	2200      	movs	r2, #0
 800275e:	701a      	strb	r2, [r3, #0]

  if(HAL_DMA_STATE_BUSY != hdma->State)
 8002760:	687b      	ldr	r3, [r7, #4]
 8002762:	2225      	movs	r2, #37	; 0x25
 8002764:	5c9b      	ldrb	r3, [r3, r2]
 8002766:	b2db      	uxtb	r3, r3
 8002768:	2b02      	cmp	r3, #2
 800276a:	d006      	beq.n	800277a <HAL_DMA_Abort_IT+0x2a>
  {
    /* no transfer ongoing */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 800276c:	687b      	ldr	r3, [r7, #4]
 800276e:	2204      	movs	r2, #4
 8002770:	63da      	str	r2, [r3, #60]	; 0x3c

    status = HAL_ERROR;
 8002772:	187b      	adds	r3, r7, r1
 8002774:	2201      	movs	r2, #1
 8002776:	701a      	strb	r2, [r3, #0]
 8002778:	e02a      	b.n	80027d0 <HAL_DMA_Abort_IT+0x80>
  }
  else
  {
    /* Disable DMA IT */
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 800277a:	687b      	ldr	r3, [r7, #4]
 800277c:	681b      	ldr	r3, [r3, #0]
 800277e:	681a      	ldr	r2, [r3, #0]
 8002780:	687b      	ldr	r3, [r7, #4]
 8002782:	681b      	ldr	r3, [r3, #0]
 8002784:	210e      	movs	r1, #14
 8002786:	438a      	bics	r2, r1
 8002788:	601a      	str	r2, [r3, #0]

    /* Disable the channel */
    __HAL_DMA_DISABLE(hdma);
 800278a:	687b      	ldr	r3, [r7, #4]
 800278c:	681b      	ldr	r3, [r3, #0]
 800278e:	681a      	ldr	r2, [r3, #0]
 8002790:	687b      	ldr	r3, [r7, #4]
 8002792:	681b      	ldr	r3, [r3, #0]
 8002794:	2101      	movs	r1, #1
 8002796:	438a      	bics	r2, r1
 8002798:	601a      	str	r2, [r3, #0]

    /* Clear all flags */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
 800279a:	687b      	ldr	r3, [r7, #4]
 800279c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800279e:	221c      	movs	r2, #28
 80027a0:	401a      	ands	r2, r3
 80027a2:	687b      	ldr	r3, [r7, #4]
 80027a4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80027a6:	2101      	movs	r1, #1
 80027a8:	4091      	lsls	r1, r2
 80027aa:	000a      	movs	r2, r1
 80027ac:	605a      	str	r2, [r3, #4]

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
 80027ae:	687b      	ldr	r3, [r7, #4]
 80027b0:	2225      	movs	r2, #37	; 0x25
 80027b2:	2101      	movs	r1, #1
 80027b4:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 80027b6:	687b      	ldr	r3, [r7, #4]
 80027b8:	2224      	movs	r2, #36	; 0x24
 80027ba:	2100      	movs	r1, #0
 80027bc:	5499      	strb	r1, [r3, r2]

    /* Call User Abort callback */
    if(hdma->XferAbortCallback != NULL)
 80027be:	687b      	ldr	r3, [r7, #4]
 80027c0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80027c2:	2b00      	cmp	r3, #0
 80027c4:	d004      	beq.n	80027d0 <HAL_DMA_Abort_IT+0x80>
    {
      hdma->XferAbortCallback(hdma);
 80027c6:	687b      	ldr	r3, [r7, #4]
 80027c8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80027ca:	687a      	ldr	r2, [r7, #4]
 80027cc:	0010      	movs	r0, r2
 80027ce:	4798      	blx	r3
    }
  }
  return status;
 80027d0:	230f      	movs	r3, #15
 80027d2:	18fb      	adds	r3, r7, r3
 80027d4:	781b      	ldrb	r3, [r3, #0]
}
 80027d6:	0018      	movs	r0, r3
 80027d8:	46bd      	mov	sp, r7
 80027da:	b004      	add	sp, #16
 80027dc:	bd80      	pop	{r7, pc}
	...

080027e0 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *                    the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 80027e0:	b580      	push	{r7, lr}
 80027e2:	b086      	sub	sp, #24
 80027e4:	af00      	add	r7, sp, #0
 80027e6:	6078      	str	r0, [r7, #4]
 80027e8:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
 80027ea:	2300      	movs	r3, #0
 80027ec:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00U;
 80027ee:	2300      	movs	r3, #0
 80027f0:	60fb      	str	r3, [r7, #12]
  uint32_t temp = 0x00U;
 80027f2:	2300      	movs	r3, #0
 80027f4:	613b      	str	r3, [r7, #16]
  /* Check the parameters */
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx, (GPIO_Init->Pin)));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0)
 80027f6:	e155      	b.n	8002aa4 <HAL_GPIO_Init+0x2c4>
  {
    /* Get the IO position */
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 80027f8:	683b      	ldr	r3, [r7, #0]
 80027fa:	681b      	ldr	r3, [r3, #0]
 80027fc:	2101      	movs	r1, #1
 80027fe:	697a      	ldr	r2, [r7, #20]
 8002800:	4091      	lsls	r1, r2
 8002802:	000a      	movs	r2, r1
 8002804:	4013      	ands	r3, r2
 8002806:	60fb      	str	r3, [r7, #12]

    if (iocurrent)
 8002808:	68fb      	ldr	r3, [r7, #12]
 800280a:	2b00      	cmp	r3, #0
 800280c:	d100      	bne.n	8002810 <HAL_GPIO_Init+0x30>
 800280e:	e146      	b.n	8002a9e <HAL_GPIO_Init+0x2be>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) ||
 8002810:	683b      	ldr	r3, [r7, #0]
 8002812:	685b      	ldr	r3, [r3, #4]
 8002814:	2203      	movs	r2, #3
 8002816:	4013      	ands	r3, r2
 8002818:	2b01      	cmp	r3, #1
 800281a:	d005      	beq.n	8002828 <HAL_GPIO_Init+0x48>
          ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 800281c:	683b      	ldr	r3, [r7, #0]
 800281e:	685b      	ldr	r3, [r3, #4]
 8002820:	2203      	movs	r2, #3
 8002822:	4013      	ands	r3, r2
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) ||
 8002824:	2b02      	cmp	r3, #2
 8002826:	d130      	bne.n	800288a <HAL_GPIO_Init+0xaa>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 8002828:	687b      	ldr	r3, [r7, #4]
 800282a:	689b      	ldr	r3, [r3, #8]
 800282c:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDER_OSPEED0 << (position * 2U));
 800282e:	697b      	ldr	r3, [r7, #20]
 8002830:	005b      	lsls	r3, r3, #1
 8002832:	2203      	movs	r2, #3
 8002834:	409a      	lsls	r2, r3
 8002836:	0013      	movs	r3, r2
 8002838:	43da      	mvns	r2, r3
 800283a:	693b      	ldr	r3, [r7, #16]
 800283c:	4013      	ands	r3, r2
 800283e:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * 2U));
 8002840:	683b      	ldr	r3, [r7, #0]
 8002842:	68da      	ldr	r2, [r3, #12]
 8002844:	697b      	ldr	r3, [r7, #20]
 8002846:	005b      	lsls	r3, r3, #1
 8002848:	409a      	lsls	r2, r3
 800284a:	0013      	movs	r3, r2
 800284c:	693a      	ldr	r2, [r7, #16]
 800284e:	4313      	orrs	r3, r2
 8002850:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
 8002852:	687b      	ldr	r3, [r7, #4]
 8002854:	693a      	ldr	r2, [r7, #16]
 8002856:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8002858:	687b      	ldr	r3, [r7, #4]
 800285a:	685b      	ldr	r3, [r3, #4]
 800285c:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 800285e:	2201      	movs	r2, #1
 8002860:	697b      	ldr	r3, [r7, #20]
 8002862:	409a      	lsls	r2, r3
 8002864:	0013      	movs	r3, r2
 8002866:	43da      	mvns	r2, r3
 8002868:	693b      	ldr	r3, [r7, #16]
 800286a:	4013      	ands	r3, r2
 800286c:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 800286e:	683b      	ldr	r3, [r7, #0]
 8002870:	685b      	ldr	r3, [r3, #4]
 8002872:	091b      	lsrs	r3, r3, #4
 8002874:	2201      	movs	r2, #1
 8002876:	401a      	ands	r2, r3
 8002878:	697b      	ldr	r3, [r7, #20]
 800287a:	409a      	lsls	r2, r3
 800287c:	0013      	movs	r3, r2
 800287e:	693a      	ldr	r2, [r7, #16]
 8002880:	4313      	orrs	r3, r2
 8002882:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
 8002884:	687b      	ldr	r3, [r7, #4]
 8002886:	693a      	ldr	r2, [r7, #16]
 8002888:	605a      	str	r2, [r3, #4]
      }

      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 800288a:	683b      	ldr	r3, [r7, #0]
 800288c:	685b      	ldr	r3, [r3, #4]
 800288e:	2203      	movs	r2, #3
 8002890:	4013      	ands	r3, r2
 8002892:	2b03      	cmp	r3, #3
 8002894:	d017      	beq.n	80028c6 <HAL_GPIO_Init+0xe6>
      {
        /* Check the Pull parameter */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
 8002896:	687b      	ldr	r3, [r7, #4]
 8002898:	68db      	ldr	r3, [r3, #12]
 800289a:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 800289c:	697b      	ldr	r3, [r7, #20]
 800289e:	005b      	lsls	r3, r3, #1
 80028a0:	2203      	movs	r2, #3
 80028a2:	409a      	lsls	r2, r3
 80028a4:	0013      	movs	r3, r2
 80028a6:	43da      	mvns	r2, r3
 80028a8:	693b      	ldr	r3, [r7, #16]
 80028aa:	4013      	ands	r3, r2
 80028ac:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 80028ae:	683b      	ldr	r3, [r7, #0]
 80028b0:	689a      	ldr	r2, [r3, #8]
 80028b2:	697b      	ldr	r3, [r7, #20]
 80028b4:	005b      	lsls	r3, r3, #1
 80028b6:	409a      	lsls	r2, r3
 80028b8:	0013      	movs	r3, r2
 80028ba:	693a      	ldr	r2, [r7, #16]
 80028bc:	4313      	orrs	r3, r2
 80028be:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
 80028c0:	687b      	ldr	r3, [r7, #4]
 80028c2:	693a      	ldr	r2, [r7, #16]
 80028c4:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 80028c6:	683b      	ldr	r3, [r7, #0]
 80028c8:	685b      	ldr	r3, [r3, #4]
 80028ca:	2203      	movs	r2, #3
 80028cc:	4013      	ands	r3, r2
 80028ce:	2b02      	cmp	r3, #2
 80028d0:	d123      	bne.n	800291a <HAL_GPIO_Init+0x13a>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 80028d2:	697b      	ldr	r3, [r7, #20]
 80028d4:	08da      	lsrs	r2, r3, #3
 80028d6:	687b      	ldr	r3, [r7, #4]
 80028d8:	3208      	adds	r2, #8
 80028da:	0092      	lsls	r2, r2, #2
 80028dc:	58d3      	ldr	r3, [r2, r3]
 80028de:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFUL << ((uint32_t)(position & 0x07UL) * 4U));
 80028e0:	697b      	ldr	r3, [r7, #20]
 80028e2:	2207      	movs	r2, #7
 80028e4:	4013      	ands	r3, r2
 80028e6:	009b      	lsls	r3, r3, #2
 80028e8:	220f      	movs	r2, #15
 80028ea:	409a      	lsls	r2, r3
 80028ec:	0013      	movs	r3, r2
 80028ee:	43da      	mvns	r2, r3
 80028f0:	693b      	ldr	r3, [r7, #16]
 80028f2:	4013      	ands	r3, r2
 80028f4:	613b      	str	r3, [r7, #16]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U));
 80028f6:	683b      	ldr	r3, [r7, #0]
 80028f8:	691a      	ldr	r2, [r3, #16]
 80028fa:	697b      	ldr	r3, [r7, #20]
 80028fc:	2107      	movs	r1, #7
 80028fe:	400b      	ands	r3, r1
 8002900:	009b      	lsls	r3, r3, #2
 8002902:	409a      	lsls	r2, r3
 8002904:	0013      	movs	r3, r2
 8002906:	693a      	ldr	r2, [r7, #16]
 8002908:	4313      	orrs	r3, r2
 800290a:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3U] = temp;
 800290c:	697b      	ldr	r3, [r7, #20]
 800290e:	08da      	lsrs	r2, r3, #3
 8002910:	687b      	ldr	r3, [r7, #4]
 8002912:	3208      	adds	r2, #8
 8002914:	0092      	lsls	r2, r2, #2
 8002916:	6939      	ldr	r1, [r7, #16]
 8002918:	50d1      	str	r1, [r2, r3]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 800291a:	687b      	ldr	r3, [r7, #4]
 800291c:	681b      	ldr	r3, [r3, #0]
 800291e:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 8002920:	697b      	ldr	r3, [r7, #20]
 8002922:	005b      	lsls	r3, r3, #1
 8002924:	2203      	movs	r2, #3
 8002926:	409a      	lsls	r2, r3
 8002928:	0013      	movs	r3, r2
 800292a:	43da      	mvns	r2, r3
 800292c:	693b      	ldr	r3, [r7, #16]
 800292e:	4013      	ands	r3, r2
 8002930:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8002932:	683b      	ldr	r3, [r7, #0]
 8002934:	685b      	ldr	r3, [r3, #4]
 8002936:	2203      	movs	r2, #3
 8002938:	401a      	ands	r2, r3
 800293a:	697b      	ldr	r3, [r7, #20]
 800293c:	005b      	lsls	r3, r3, #1
 800293e:	409a      	lsls	r2, r3
 8002940:	0013      	movs	r3, r2
 8002942:	693a      	ldr	r2, [r7, #16]
 8002944:	4313      	orrs	r3, r2
 8002946:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
 8002948:	687b      	ldr	r3, [r7, #4]
 800294a:	693a      	ldr	r2, [r7, #16]
 800294c:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 800294e:	683b      	ldr	r3, [r7, #0]
 8002950:	685a      	ldr	r2, [r3, #4]
 8002952:	23c0      	movs	r3, #192	; 0xc0
 8002954:	029b      	lsls	r3, r3, #10
 8002956:	4013      	ands	r3, r2
 8002958:	d100      	bne.n	800295c <HAL_GPIO_Init+0x17c>
 800295a:	e0a0      	b.n	8002a9e <HAL_GPIO_Init+0x2be>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800295c:	4b57      	ldr	r3, [pc, #348]	; (8002abc <HAL_GPIO_Init+0x2dc>)
 800295e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002960:	4b56      	ldr	r3, [pc, #344]	; (8002abc <HAL_GPIO_Init+0x2dc>)
 8002962:	2101      	movs	r1, #1
 8002964:	430a      	orrs	r2, r1
 8002966:	635a      	str	r2, [r3, #52]	; 0x34

        temp = SYSCFG->EXTICR[position >> 2U];
 8002968:	4a55      	ldr	r2, [pc, #340]	; (8002ac0 <HAL_GPIO_Init+0x2e0>)
 800296a:	697b      	ldr	r3, [r7, #20]
 800296c:	089b      	lsrs	r3, r3, #2
 800296e:	3302      	adds	r3, #2
 8002970:	009b      	lsls	r3, r3, #2
 8002972:	589b      	ldr	r3, [r3, r2]
 8002974:	613b      	str	r3, [r7, #16]
        CLEAR_BIT(temp, (0x0FUL) << (4U * (position & 0x03U)));
 8002976:	697b      	ldr	r3, [r7, #20]
 8002978:	2203      	movs	r2, #3
 800297a:	4013      	ands	r3, r2
 800297c:	009b      	lsls	r3, r3, #2
 800297e:	220f      	movs	r2, #15
 8002980:	409a      	lsls	r2, r3
 8002982:	0013      	movs	r3, r2
 8002984:	43da      	mvns	r2, r3
 8002986:	693b      	ldr	r3, [r7, #16]
 8002988:	4013      	ands	r3, r2
 800298a:	613b      	str	r3, [r7, #16]
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03U)));
 800298c:	687a      	ldr	r2, [r7, #4]
 800298e:	23a0      	movs	r3, #160	; 0xa0
 8002990:	05db      	lsls	r3, r3, #23
 8002992:	429a      	cmp	r2, r3
 8002994:	d01f      	beq.n	80029d6 <HAL_GPIO_Init+0x1f6>
 8002996:	687b      	ldr	r3, [r7, #4]
 8002998:	4a4a      	ldr	r2, [pc, #296]	; (8002ac4 <HAL_GPIO_Init+0x2e4>)
 800299a:	4293      	cmp	r3, r2
 800299c:	d019      	beq.n	80029d2 <HAL_GPIO_Init+0x1f2>
 800299e:	687b      	ldr	r3, [r7, #4]
 80029a0:	4a49      	ldr	r2, [pc, #292]	; (8002ac8 <HAL_GPIO_Init+0x2e8>)
 80029a2:	4293      	cmp	r3, r2
 80029a4:	d013      	beq.n	80029ce <HAL_GPIO_Init+0x1ee>
 80029a6:	687b      	ldr	r3, [r7, #4]
 80029a8:	4a48      	ldr	r2, [pc, #288]	; (8002acc <HAL_GPIO_Init+0x2ec>)
 80029aa:	4293      	cmp	r3, r2
 80029ac:	d00d      	beq.n	80029ca <HAL_GPIO_Init+0x1ea>
 80029ae:	687b      	ldr	r3, [r7, #4]
 80029b0:	4a47      	ldr	r2, [pc, #284]	; (8002ad0 <HAL_GPIO_Init+0x2f0>)
 80029b2:	4293      	cmp	r3, r2
 80029b4:	d007      	beq.n	80029c6 <HAL_GPIO_Init+0x1e6>
 80029b6:	687b      	ldr	r3, [r7, #4]
 80029b8:	4a46      	ldr	r2, [pc, #280]	; (8002ad4 <HAL_GPIO_Init+0x2f4>)
 80029ba:	4293      	cmp	r3, r2
 80029bc:	d101      	bne.n	80029c2 <HAL_GPIO_Init+0x1e2>
 80029be:	2305      	movs	r3, #5
 80029c0:	e00a      	b.n	80029d8 <HAL_GPIO_Init+0x1f8>
 80029c2:	2306      	movs	r3, #6
 80029c4:	e008      	b.n	80029d8 <HAL_GPIO_Init+0x1f8>
 80029c6:	2304      	movs	r3, #4
 80029c8:	e006      	b.n	80029d8 <HAL_GPIO_Init+0x1f8>
 80029ca:	2303      	movs	r3, #3
 80029cc:	e004      	b.n	80029d8 <HAL_GPIO_Init+0x1f8>
 80029ce:	2302      	movs	r3, #2
 80029d0:	e002      	b.n	80029d8 <HAL_GPIO_Init+0x1f8>
 80029d2:	2301      	movs	r3, #1
 80029d4:	e000      	b.n	80029d8 <HAL_GPIO_Init+0x1f8>
 80029d6:	2300      	movs	r3, #0
 80029d8:	697a      	ldr	r2, [r7, #20]
 80029da:	2103      	movs	r1, #3
 80029dc:	400a      	ands	r2, r1
 80029de:	0092      	lsls	r2, r2, #2
 80029e0:	4093      	lsls	r3, r2
 80029e2:	693a      	ldr	r2, [r7, #16]
 80029e4:	4313      	orrs	r3, r2
 80029e6:	613b      	str	r3, [r7, #16]
        SYSCFG->EXTICR[position >> 2U] = temp;
 80029e8:	4935      	ldr	r1, [pc, #212]	; (8002ac0 <HAL_GPIO_Init+0x2e0>)
 80029ea:	697b      	ldr	r3, [r7, #20]
 80029ec:	089b      	lsrs	r3, r3, #2
 80029ee:	3302      	adds	r3, #2
 80029f0:	009b      	lsls	r3, r3, #2
 80029f2:	693a      	ldr	r2, [r7, #16]
 80029f4:	505a      	str	r2, [r3, r1]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 80029f6:	4b38      	ldr	r3, [pc, #224]	; (8002ad8 <HAL_GPIO_Init+0x2f8>)
 80029f8:	681b      	ldr	r3, [r3, #0]
 80029fa:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 80029fc:	68fb      	ldr	r3, [r7, #12]
 80029fe:	43da      	mvns	r2, r3
 8002a00:	693b      	ldr	r3, [r7, #16]
 8002a02:	4013      	ands	r3, r2
 8002a04:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 8002a06:	683b      	ldr	r3, [r7, #0]
 8002a08:	685a      	ldr	r2, [r3, #4]
 8002a0a:	2380      	movs	r3, #128	; 0x80
 8002a0c:	025b      	lsls	r3, r3, #9
 8002a0e:	4013      	ands	r3, r2
 8002a10:	d003      	beq.n	8002a1a <HAL_GPIO_Init+0x23a>
        {
          temp |= iocurrent;
 8002a12:	693a      	ldr	r2, [r7, #16]
 8002a14:	68fb      	ldr	r3, [r7, #12]
 8002a16:	4313      	orrs	r3, r2
 8002a18:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR = temp;
 8002a1a:	4b2f      	ldr	r3, [pc, #188]	; (8002ad8 <HAL_GPIO_Init+0x2f8>)
 8002a1c:	693a      	ldr	r2, [r7, #16]
 8002a1e:	601a      	str	r2, [r3, #0]

        temp = EXTI->EMR;
 8002a20:	4b2d      	ldr	r3, [pc, #180]	; (8002ad8 <HAL_GPIO_Init+0x2f8>)
 8002a22:	685b      	ldr	r3, [r3, #4]
 8002a24:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 8002a26:	68fb      	ldr	r3, [r7, #12]
 8002a28:	43da      	mvns	r2, r3
 8002a2a:	693b      	ldr	r3, [r7, #16]
 8002a2c:	4013      	ands	r3, r2
 8002a2e:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 8002a30:	683b      	ldr	r3, [r7, #0]
 8002a32:	685a      	ldr	r2, [r3, #4]
 8002a34:	2380      	movs	r3, #128	; 0x80
 8002a36:	029b      	lsls	r3, r3, #10
 8002a38:	4013      	ands	r3, r2
 8002a3a:	d003      	beq.n	8002a44 <HAL_GPIO_Init+0x264>
        {
          temp |= iocurrent;
 8002a3c:	693a      	ldr	r2, [r7, #16]
 8002a3e:	68fb      	ldr	r3, [r7, #12]
 8002a40:	4313      	orrs	r3, r2
 8002a42:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR = temp;
 8002a44:	4b24      	ldr	r3, [pc, #144]	; (8002ad8 <HAL_GPIO_Init+0x2f8>)
 8002a46:	693a      	ldr	r2, [r7, #16]
 8002a48:	605a      	str	r2, [r3, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8002a4a:	4b23      	ldr	r3, [pc, #140]	; (8002ad8 <HAL_GPIO_Init+0x2f8>)
 8002a4c:	689b      	ldr	r3, [r3, #8]
 8002a4e:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 8002a50:	68fb      	ldr	r3, [r7, #12]
 8002a52:	43da      	mvns	r2, r3
 8002a54:	693b      	ldr	r3, [r7, #16]
 8002a56:	4013      	ands	r3, r2
 8002a58:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 8002a5a:	683b      	ldr	r3, [r7, #0]
 8002a5c:	685a      	ldr	r2, [r3, #4]
 8002a5e:	2380      	movs	r3, #128	; 0x80
 8002a60:	035b      	lsls	r3, r3, #13
 8002a62:	4013      	ands	r3, r2
 8002a64:	d003      	beq.n	8002a6e <HAL_GPIO_Init+0x28e>
        {
          temp |= iocurrent;
 8002a66:	693a      	ldr	r2, [r7, #16]
 8002a68:	68fb      	ldr	r3, [r7, #12]
 8002a6a:	4313      	orrs	r3, r2
 8002a6c:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR = temp;
 8002a6e:	4b1a      	ldr	r3, [pc, #104]	; (8002ad8 <HAL_GPIO_Init+0x2f8>)
 8002a70:	693a      	ldr	r2, [r7, #16]
 8002a72:	609a      	str	r2, [r3, #8]

        temp = EXTI->FTSR;
 8002a74:	4b18      	ldr	r3, [pc, #96]	; (8002ad8 <HAL_GPIO_Init+0x2f8>)
 8002a76:	68db      	ldr	r3, [r3, #12]
 8002a78:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 8002a7a:	68fb      	ldr	r3, [r7, #12]
 8002a7c:	43da      	mvns	r2, r3
 8002a7e:	693b      	ldr	r3, [r7, #16]
 8002a80:	4013      	ands	r3, r2
 8002a82:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 8002a84:	683b      	ldr	r3, [r7, #0]
 8002a86:	685a      	ldr	r2, [r3, #4]
 8002a88:	2380      	movs	r3, #128	; 0x80
 8002a8a:	039b      	lsls	r3, r3, #14
 8002a8c:	4013      	ands	r3, r2
 8002a8e:	d003      	beq.n	8002a98 <HAL_GPIO_Init+0x2b8>
        {
          temp |= iocurrent;
 8002a90:	693a      	ldr	r2, [r7, #16]
 8002a92:	68fb      	ldr	r3, [r7, #12]
 8002a94:	4313      	orrs	r3, r2
 8002a96:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR = temp;
 8002a98:	4b0f      	ldr	r3, [pc, #60]	; (8002ad8 <HAL_GPIO_Init+0x2f8>)
 8002a9a:	693a      	ldr	r2, [r7, #16]
 8002a9c:	60da      	str	r2, [r3, #12]
      }
    }
    position++;
 8002a9e:	697b      	ldr	r3, [r7, #20]
 8002aa0:	3301      	adds	r3, #1
 8002aa2:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0)
 8002aa4:	683b      	ldr	r3, [r7, #0]
 8002aa6:	681a      	ldr	r2, [r3, #0]
 8002aa8:	697b      	ldr	r3, [r7, #20]
 8002aaa:	40da      	lsrs	r2, r3
 8002aac:	1e13      	subs	r3, r2, #0
 8002aae:	d000      	beq.n	8002ab2 <HAL_GPIO_Init+0x2d2>
 8002ab0:	e6a2      	b.n	80027f8 <HAL_GPIO_Init+0x18>
  }
}
 8002ab2:	46c0      	nop			; (mov r8, r8)
 8002ab4:	46c0      	nop			; (mov r8, r8)
 8002ab6:	46bd      	mov	sp, r7
 8002ab8:	b006      	add	sp, #24
 8002aba:	bd80      	pop	{r7, pc}
 8002abc:	40021000 	.word	0x40021000
 8002ac0:	40010000 	.word	0x40010000
 8002ac4:	50000400 	.word	0x50000400
 8002ac8:	50000800 	.word	0x50000800
 8002acc:	50000c00 	.word	0x50000c00
 8002ad0:	50001000 	.word	0x50001000
 8002ad4:	50001c00 	.word	0x50001c00
 8002ad8:	40010400 	.word	0x40010400

08002adc <HAL_GPIO_WritePin>:
  *                        GPIO_PIN_RESET: to clear the port pin
  *                        GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 8002adc:	b580      	push	{r7, lr}
 8002ade:	b082      	sub	sp, #8
 8002ae0:	af00      	add	r7, sp, #0
 8002ae2:	6078      	str	r0, [r7, #4]
 8002ae4:	0008      	movs	r0, r1
 8002ae6:	0011      	movs	r1, r2
 8002ae8:	1cbb      	adds	r3, r7, #2
 8002aea:	1c02      	adds	r2, r0, #0
 8002aec:	801a      	strh	r2, [r3, #0]
 8002aee:	1c7b      	adds	r3, r7, #1
 8002af0:	1c0a      	adds	r2, r1, #0
 8002af2:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx, GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 8002af4:	1c7b      	adds	r3, r7, #1
 8002af6:	781b      	ldrb	r3, [r3, #0]
 8002af8:	2b00      	cmp	r3, #0
 8002afa:	d004      	beq.n	8002b06 <HAL_GPIO_WritePin+0x2a>
  {
    GPIOx->BSRR = GPIO_Pin;
 8002afc:	1cbb      	adds	r3, r7, #2
 8002afe:	881a      	ldrh	r2, [r3, #0]
 8002b00:	687b      	ldr	r3, [r7, #4]
 8002b02:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = GPIO_Pin ;
  }
}
 8002b04:	e003      	b.n	8002b0e <HAL_GPIO_WritePin+0x32>
    GPIOx->BRR = GPIO_Pin ;
 8002b06:	1cbb      	adds	r3, r7, #2
 8002b08:	881a      	ldrh	r2, [r3, #0]
 8002b0a:	687b      	ldr	r3, [r7, #4]
 8002b0c:	629a      	str	r2, [r3, #40]	; 0x28
}
 8002b0e:	46c0      	nop			; (mov r8, r8)
 8002b10:	46bd      	mov	sp, r7
 8002b12:	b002      	add	sp, #8
 8002b14:	bd80      	pop	{r7, pc}
	...

08002b18 <HAL_RCC_OscConfig>:
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8002b18:	b5b0      	push	{r4, r5, r7, lr}
 8002b1a:	b08a      	sub	sp, #40	; 0x28
 8002b1c:	af00      	add	r7, sp, #0
 8002b1e:	6078      	str	r0, [r7, #4]
  uint32_t hsi_state;
  HAL_StatusTypeDef status;
  uint32_t sysclk_source, pll_config;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 8002b20:	687b      	ldr	r3, [r7, #4]
 8002b22:	2b00      	cmp	r3, #0
 8002b24:	d102      	bne.n	8002b2c <HAL_RCC_OscConfig+0x14>
  {
    return HAL_ERROR;
 8002b26:	2301      	movs	r3, #1
 8002b28:	f000 fb6c 	bl	8003204 <HAL_RCC_OscConfig+0x6ec>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8002b2c:	4bc8      	ldr	r3, [pc, #800]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002b2e:	68db      	ldr	r3, [r3, #12]
 8002b30:	220c      	movs	r2, #12
 8002b32:	4013      	ands	r3, r2
 8002b34:	61fb      	str	r3, [r7, #28]
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 8002b36:	4bc6      	ldr	r3, [pc, #792]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002b38:	68da      	ldr	r2, [r3, #12]
 8002b3a:	2380      	movs	r3, #128	; 0x80
 8002b3c:	025b      	lsls	r3, r3, #9
 8002b3e:	4013      	ands	r3, r2
 8002b40:	61bb      	str	r3, [r7, #24]

  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8002b42:	687b      	ldr	r3, [r7, #4]
 8002b44:	681b      	ldr	r3, [r3, #0]
 8002b46:	2201      	movs	r2, #1
 8002b48:	4013      	ands	r3, r2
 8002b4a:	d100      	bne.n	8002b4e <HAL_RCC_OscConfig+0x36>
 8002b4c:	e07d      	b.n	8002c4a <HAL_RCC_OscConfig+0x132>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 8002b4e:	69fb      	ldr	r3, [r7, #28]
 8002b50:	2b08      	cmp	r3, #8
 8002b52:	d007      	beq.n	8002b64 <HAL_RCC_OscConfig+0x4c>
       || ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSE)))
 8002b54:	69fb      	ldr	r3, [r7, #28]
 8002b56:	2b0c      	cmp	r3, #12
 8002b58:	d112      	bne.n	8002b80 <HAL_RCC_OscConfig+0x68>
 8002b5a:	69ba      	ldr	r2, [r7, #24]
 8002b5c:	2380      	movs	r3, #128	; 0x80
 8002b5e:	025b      	lsls	r3, r3, #9
 8002b60:	429a      	cmp	r2, r3
 8002b62:	d10d      	bne.n	8002b80 <HAL_RCC_OscConfig+0x68>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8002b64:	4bba      	ldr	r3, [pc, #744]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002b66:	681a      	ldr	r2, [r3, #0]
 8002b68:	2380      	movs	r3, #128	; 0x80
 8002b6a:	029b      	lsls	r3, r3, #10
 8002b6c:	4013      	ands	r3, r2
 8002b6e:	d100      	bne.n	8002b72 <HAL_RCC_OscConfig+0x5a>
 8002b70:	e06a      	b.n	8002c48 <HAL_RCC_OscConfig+0x130>
 8002b72:	687b      	ldr	r3, [r7, #4]
 8002b74:	685b      	ldr	r3, [r3, #4]
 8002b76:	2b00      	cmp	r3, #0
 8002b78:	d166      	bne.n	8002c48 <HAL_RCC_OscConfig+0x130>
      {
        return HAL_ERROR;
 8002b7a:	2301      	movs	r3, #1
 8002b7c:	f000 fb42 	bl	8003204 <HAL_RCC_OscConfig+0x6ec>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002b80:	687b      	ldr	r3, [r7, #4]
 8002b82:	685a      	ldr	r2, [r3, #4]
 8002b84:	2380      	movs	r3, #128	; 0x80
 8002b86:	025b      	lsls	r3, r3, #9
 8002b88:	429a      	cmp	r2, r3
 8002b8a:	d107      	bne.n	8002b9c <HAL_RCC_OscConfig+0x84>
 8002b8c:	4bb0      	ldr	r3, [pc, #704]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002b8e:	681a      	ldr	r2, [r3, #0]
 8002b90:	4baf      	ldr	r3, [pc, #700]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002b92:	2180      	movs	r1, #128	; 0x80
 8002b94:	0249      	lsls	r1, r1, #9
 8002b96:	430a      	orrs	r2, r1
 8002b98:	601a      	str	r2, [r3, #0]
 8002b9a:	e027      	b.n	8002bec <HAL_RCC_OscConfig+0xd4>
 8002b9c:	687b      	ldr	r3, [r7, #4]
 8002b9e:	685a      	ldr	r2, [r3, #4]
 8002ba0:	23a0      	movs	r3, #160	; 0xa0
 8002ba2:	02db      	lsls	r3, r3, #11
 8002ba4:	429a      	cmp	r2, r3
 8002ba6:	d10e      	bne.n	8002bc6 <HAL_RCC_OscConfig+0xae>
 8002ba8:	4ba9      	ldr	r3, [pc, #676]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002baa:	681a      	ldr	r2, [r3, #0]
 8002bac:	4ba8      	ldr	r3, [pc, #672]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002bae:	2180      	movs	r1, #128	; 0x80
 8002bb0:	02c9      	lsls	r1, r1, #11
 8002bb2:	430a      	orrs	r2, r1
 8002bb4:	601a      	str	r2, [r3, #0]
 8002bb6:	4ba6      	ldr	r3, [pc, #664]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002bb8:	681a      	ldr	r2, [r3, #0]
 8002bba:	4ba5      	ldr	r3, [pc, #660]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002bbc:	2180      	movs	r1, #128	; 0x80
 8002bbe:	0249      	lsls	r1, r1, #9
 8002bc0:	430a      	orrs	r2, r1
 8002bc2:	601a      	str	r2, [r3, #0]
 8002bc4:	e012      	b.n	8002bec <HAL_RCC_OscConfig+0xd4>
 8002bc6:	4ba2      	ldr	r3, [pc, #648]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002bc8:	681a      	ldr	r2, [r3, #0]
 8002bca:	4ba1      	ldr	r3, [pc, #644]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002bcc:	49a1      	ldr	r1, [pc, #644]	; (8002e54 <HAL_RCC_OscConfig+0x33c>)
 8002bce:	400a      	ands	r2, r1
 8002bd0:	601a      	str	r2, [r3, #0]
 8002bd2:	4b9f      	ldr	r3, [pc, #636]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002bd4:	681a      	ldr	r2, [r3, #0]
 8002bd6:	2380      	movs	r3, #128	; 0x80
 8002bd8:	025b      	lsls	r3, r3, #9
 8002bda:	4013      	ands	r3, r2
 8002bdc:	60fb      	str	r3, [r7, #12]
 8002bde:	68fb      	ldr	r3, [r7, #12]
 8002be0:	4b9b      	ldr	r3, [pc, #620]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002be2:	681a      	ldr	r2, [r3, #0]
 8002be4:	4b9a      	ldr	r3, [pc, #616]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002be6:	499c      	ldr	r1, [pc, #624]	; (8002e58 <HAL_RCC_OscConfig+0x340>)
 8002be8:	400a      	ands	r2, r1
 8002bea:	601a      	str	r2, [r3, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8002bec:	687b      	ldr	r3, [r7, #4]
 8002bee:	685b      	ldr	r3, [r3, #4]
 8002bf0:	2b00      	cmp	r3, #0
 8002bf2:	d014      	beq.n	8002c1e <HAL_RCC_OscConfig+0x106>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8002bf4:	f7ff fc60 	bl	80024b8 <HAL_GetTick>
 8002bf8:	0003      	movs	r3, r0
 8002bfa:	617b      	str	r3, [r7, #20]

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 8002bfc:	e008      	b.n	8002c10 <HAL_RCC_OscConfig+0xf8>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8002bfe:	f7ff fc5b 	bl	80024b8 <HAL_GetTick>
 8002c02:	0002      	movs	r2, r0
 8002c04:	697b      	ldr	r3, [r7, #20]
 8002c06:	1ad3      	subs	r3, r2, r3
 8002c08:	2b64      	cmp	r3, #100	; 0x64
 8002c0a:	d901      	bls.n	8002c10 <HAL_RCC_OscConfig+0xf8>
          {
            return HAL_TIMEOUT;
 8002c0c:	2303      	movs	r3, #3
 8002c0e:	e2f9      	b.n	8003204 <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 8002c10:	4b8f      	ldr	r3, [pc, #572]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002c12:	681a      	ldr	r2, [r3, #0]
 8002c14:	2380      	movs	r3, #128	; 0x80
 8002c16:	029b      	lsls	r3, r3, #10
 8002c18:	4013      	ands	r3, r2
 8002c1a:	d0f0      	beq.n	8002bfe <HAL_RCC_OscConfig+0xe6>
 8002c1c:	e015      	b.n	8002c4a <HAL_RCC_OscConfig+0x132>
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8002c1e:	f7ff fc4b 	bl	80024b8 <HAL_GetTick>
 8002c22:	0003      	movs	r3, r0
 8002c24:	617b      	str	r3, [r7, #20]

        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 8002c26:	e008      	b.n	8002c3a <HAL_RCC_OscConfig+0x122>
        {
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8002c28:	f7ff fc46 	bl	80024b8 <HAL_GetTick>
 8002c2c:	0002      	movs	r2, r0
 8002c2e:	697b      	ldr	r3, [r7, #20]
 8002c30:	1ad3      	subs	r3, r2, r3
 8002c32:	2b64      	cmp	r3, #100	; 0x64
 8002c34:	d901      	bls.n	8002c3a <HAL_RCC_OscConfig+0x122>
          {
            return HAL_TIMEOUT;
 8002c36:	2303      	movs	r3, #3
 8002c38:	e2e4      	b.n	8003204 <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 8002c3a:	4b85      	ldr	r3, [pc, #532]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002c3c:	681a      	ldr	r2, [r3, #0]
 8002c3e:	2380      	movs	r3, #128	; 0x80
 8002c40:	029b      	lsls	r3, r3, #10
 8002c42:	4013      	ands	r3, r2
 8002c44:	d1f0      	bne.n	8002c28 <HAL_RCC_OscConfig+0x110>
 8002c46:	e000      	b.n	8002c4a <HAL_RCC_OscConfig+0x132>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8002c48:	46c0      	nop			; (mov r8, r8)
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8002c4a:	687b      	ldr	r3, [r7, #4]
 8002c4c:	681b      	ldr	r3, [r3, #0]
 8002c4e:	2202      	movs	r2, #2
 8002c50:	4013      	ands	r3, r2
 8002c52:	d100      	bne.n	8002c56 <HAL_RCC_OscConfig+0x13e>
 8002c54:	e099      	b.n	8002d8a <HAL_RCC_OscConfig+0x272>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    hsi_state = RCC_OscInitStruct->HSIState;
 8002c56:	687b      	ldr	r3, [r7, #4]
 8002c58:	68db      	ldr	r3, [r3, #12]
 8002c5a:	627b      	str	r3, [r7, #36]	; 0x24

#if defined(RCC_CR_HSIOUTEN)
    if((hsi_state & RCC_HSI_OUTEN) != 0U)
 8002c5c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002c5e:	2220      	movs	r2, #32
 8002c60:	4013      	ands	r3, r2
 8002c62:	d009      	beq.n	8002c78 <HAL_RCC_OscConfig+0x160>
    {
      /* HSI Output enable for timer requested */
      SET_BIT(RCC->CR, RCC_CR_HSIOUTEN);
 8002c64:	4b7a      	ldr	r3, [pc, #488]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002c66:	681a      	ldr	r2, [r3, #0]
 8002c68:	4b79      	ldr	r3, [pc, #484]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002c6a:	2120      	movs	r1, #32
 8002c6c:	430a      	orrs	r2, r1
 8002c6e:	601a      	str	r2, [r3, #0]

      hsi_state &= ~RCC_CR_HSIOUTEN;
 8002c70:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002c72:	2220      	movs	r2, #32
 8002c74:	4393      	bics	r3, r2
 8002c76:	627b      	str	r3, [r7, #36]	; 0x24
    }
#endif

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
 8002c78:	69fb      	ldr	r3, [r7, #28]
 8002c7a:	2b04      	cmp	r3, #4
 8002c7c:	d005      	beq.n	8002c8a <HAL_RCC_OscConfig+0x172>
       || ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSI)))
 8002c7e:	69fb      	ldr	r3, [r7, #28]
 8002c80:	2b0c      	cmp	r3, #12
 8002c82:	d13e      	bne.n	8002d02 <HAL_RCC_OscConfig+0x1ea>
 8002c84:	69bb      	ldr	r3, [r7, #24]
 8002c86:	2b00      	cmp	r3, #0
 8002c88:	d13b      	bne.n	8002d02 <HAL_RCC_OscConfig+0x1ea>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (hsi_state == RCC_HSI_OFF))
 8002c8a:	4b71      	ldr	r3, [pc, #452]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002c8c:	681b      	ldr	r3, [r3, #0]
 8002c8e:	2204      	movs	r2, #4
 8002c90:	4013      	ands	r3, r2
 8002c92:	d004      	beq.n	8002c9e <HAL_RCC_OscConfig+0x186>
 8002c94:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002c96:	2b00      	cmp	r3, #0
 8002c98:	d101      	bne.n	8002c9e <HAL_RCC_OscConfig+0x186>
      {
        return HAL_ERROR;
 8002c9a:	2301      	movs	r3, #1
 8002c9c:	e2b2      	b.n	8003204 <HAL_RCC_OscConfig+0x6ec>
      }
      /* Otherwise, just the calibration and HSI or HSIdiv4 are allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8002c9e:	4b6c      	ldr	r3, [pc, #432]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002ca0:	685b      	ldr	r3, [r3, #4]
 8002ca2:	4a6e      	ldr	r2, [pc, #440]	; (8002e5c <HAL_RCC_OscConfig+0x344>)
 8002ca4:	4013      	ands	r3, r2
 8002ca6:	0019      	movs	r1, r3
 8002ca8:	687b      	ldr	r3, [r7, #4]
 8002caa:	691b      	ldr	r3, [r3, #16]
 8002cac:	021a      	lsls	r2, r3, #8
 8002cae:	4b68      	ldr	r3, [pc, #416]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002cb0:	430a      	orrs	r2, r1
 8002cb2:	605a      	str	r2, [r3, #4]

        /* Enable the Internal High Speed oscillator (HSI or HSIdiv4) */
        __HAL_RCC_HSI_CONFIG(hsi_state);
 8002cb4:	4b66      	ldr	r3, [pc, #408]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002cb6:	681b      	ldr	r3, [r3, #0]
 8002cb8:	2209      	movs	r2, #9
 8002cba:	4393      	bics	r3, r2
 8002cbc:	0019      	movs	r1, r3
 8002cbe:	4b64      	ldr	r3, [pc, #400]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002cc0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8002cc2:	430a      	orrs	r2, r1
 8002cc4:	601a      	str	r2, [r3, #0]
      }

      /* Update the SystemCoreClock global variable */
      SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 8002cc6:	f000 fbeb 	bl	80034a0 <HAL_RCC_GetSysClockFreq>
 8002cca:	0001      	movs	r1, r0
 8002ccc:	4b60      	ldr	r3, [pc, #384]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002cce:	68db      	ldr	r3, [r3, #12]
 8002cd0:	091b      	lsrs	r3, r3, #4
 8002cd2:	220f      	movs	r2, #15
 8002cd4:	4013      	ands	r3, r2
 8002cd6:	4a62      	ldr	r2, [pc, #392]	; (8002e60 <HAL_RCC_OscConfig+0x348>)
 8002cd8:	5cd3      	ldrb	r3, [r2, r3]
 8002cda:	000a      	movs	r2, r1
 8002cdc:	40da      	lsrs	r2, r3
 8002cde:	4b61      	ldr	r3, [pc, #388]	; (8002e64 <HAL_RCC_OscConfig+0x34c>)
 8002ce0:	601a      	str	r2, [r3, #0]

      /* Configure the source of time base considering new system clocks settings*/
      status = HAL_InitTick (uwTickPrio);
 8002ce2:	4b61      	ldr	r3, [pc, #388]	; (8002e68 <HAL_RCC_OscConfig+0x350>)
 8002ce4:	681b      	ldr	r3, [r3, #0]
 8002ce6:	2513      	movs	r5, #19
 8002ce8:	197c      	adds	r4, r7, r5
 8002cea:	0018      	movs	r0, r3
 8002cec:	f7ff fb9e 	bl	800242c <HAL_InitTick>
 8002cf0:	0003      	movs	r3, r0
 8002cf2:	7023      	strb	r3, [r4, #0]
      if(status != HAL_OK)
 8002cf4:	197b      	adds	r3, r7, r5
 8002cf6:	781b      	ldrb	r3, [r3, #0]
 8002cf8:	2b00      	cmp	r3, #0
 8002cfa:	d046      	beq.n	8002d8a <HAL_RCC_OscConfig+0x272>
      {
        return status;
 8002cfc:	197b      	adds	r3, r7, r5
 8002cfe:	781b      	ldrb	r3, [r3, #0]
 8002d00:	e280      	b.n	8003204 <HAL_RCC_OscConfig+0x6ec>
      }
    }
    else
    {
      /* Check the HSI State */
      if(hsi_state != RCC_HSI_OFF)
 8002d02:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002d04:	2b00      	cmp	r3, #0
 8002d06:	d027      	beq.n	8002d58 <HAL_RCC_OscConfig+0x240>
      {
        /* Enable the Internal High Speed oscillator (HSI or HSIdiv4) */
        __HAL_RCC_HSI_CONFIG(hsi_state);
 8002d08:	4b51      	ldr	r3, [pc, #324]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002d0a:	681b      	ldr	r3, [r3, #0]
 8002d0c:	2209      	movs	r2, #9
 8002d0e:	4393      	bics	r3, r2
 8002d10:	0019      	movs	r1, r3
 8002d12:	4b4f      	ldr	r3, [pc, #316]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002d14:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8002d16:	430a      	orrs	r2, r1
 8002d18:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8002d1a:	f7ff fbcd 	bl	80024b8 <HAL_GetTick>
 8002d1e:	0003      	movs	r3, r0
 8002d20:	617b      	str	r3, [r7, #20]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8002d22:	e008      	b.n	8002d36 <HAL_RCC_OscConfig+0x21e>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8002d24:	f7ff fbc8 	bl	80024b8 <HAL_GetTick>
 8002d28:	0002      	movs	r2, r0
 8002d2a:	697b      	ldr	r3, [r7, #20]
 8002d2c:	1ad3      	subs	r3, r2, r3
 8002d2e:	2b02      	cmp	r3, #2
 8002d30:	d901      	bls.n	8002d36 <HAL_RCC_OscConfig+0x21e>
          {
            return HAL_TIMEOUT;
 8002d32:	2303      	movs	r3, #3
 8002d34:	e266      	b.n	8003204 <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8002d36:	4b46      	ldr	r3, [pc, #280]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002d38:	681b      	ldr	r3, [r3, #0]
 8002d3a:	2204      	movs	r2, #4
 8002d3c:	4013      	ands	r3, r2
 8002d3e:	d0f1      	beq.n	8002d24 <HAL_RCC_OscConfig+0x20c>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8002d40:	4b43      	ldr	r3, [pc, #268]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002d42:	685b      	ldr	r3, [r3, #4]
 8002d44:	4a45      	ldr	r2, [pc, #276]	; (8002e5c <HAL_RCC_OscConfig+0x344>)
 8002d46:	4013      	ands	r3, r2
 8002d48:	0019      	movs	r1, r3
 8002d4a:	687b      	ldr	r3, [r7, #4]
 8002d4c:	691b      	ldr	r3, [r3, #16]
 8002d4e:	021a      	lsls	r2, r3, #8
 8002d50:	4b3f      	ldr	r3, [pc, #252]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002d52:	430a      	orrs	r2, r1
 8002d54:	605a      	str	r2, [r3, #4]
 8002d56:	e018      	b.n	8002d8a <HAL_RCC_OscConfig+0x272>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8002d58:	4b3d      	ldr	r3, [pc, #244]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002d5a:	681a      	ldr	r2, [r3, #0]
 8002d5c:	4b3c      	ldr	r3, [pc, #240]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002d5e:	2101      	movs	r1, #1
 8002d60:	438a      	bics	r2, r1
 8002d62:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8002d64:	f7ff fba8 	bl	80024b8 <HAL_GetTick>
 8002d68:	0003      	movs	r3, r0
 8002d6a:	617b      	str	r3, [r7, #20]

        /* Wait till HSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 8002d6c:	e008      	b.n	8002d80 <HAL_RCC_OscConfig+0x268>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8002d6e:	f7ff fba3 	bl	80024b8 <HAL_GetTick>
 8002d72:	0002      	movs	r2, r0
 8002d74:	697b      	ldr	r3, [r7, #20]
 8002d76:	1ad3      	subs	r3, r2, r3
 8002d78:	2b02      	cmp	r3, #2
 8002d7a:	d901      	bls.n	8002d80 <HAL_RCC_OscConfig+0x268>
          {
            return HAL_TIMEOUT;
 8002d7c:	2303      	movs	r3, #3
 8002d7e:	e241      	b.n	8003204 <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 8002d80:	4b33      	ldr	r3, [pc, #204]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002d82:	681b      	ldr	r3, [r3, #0]
 8002d84:	2204      	movs	r2, #4
 8002d86:	4013      	ands	r3, r2
 8002d88:	d1f1      	bne.n	8002d6e <HAL_RCC_OscConfig+0x256>
        }
      }
    }
  }
  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8002d8a:	687b      	ldr	r3, [r7, #4]
 8002d8c:	681b      	ldr	r3, [r3, #0]
 8002d8e:	2210      	movs	r2, #16
 8002d90:	4013      	ands	r3, r2
 8002d92:	d100      	bne.n	8002d96 <HAL_RCC_OscConfig+0x27e>
 8002d94:	e0a1      	b.n	8002eda <HAL_RCC_OscConfig+0x3c2>
  {
    /* When the MSI is used as system clock it will not be disabled */
    if(sysclk_source == RCC_CFGR_SWS_MSI)
 8002d96:	69fb      	ldr	r3, [r7, #28]
 8002d98:	2b00      	cmp	r3, #0
 8002d9a:	d140      	bne.n	8002e1e <HAL_RCC_OscConfig+0x306>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 8002d9c:	4b2c      	ldr	r3, [pc, #176]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002d9e:	681a      	ldr	r2, [r3, #0]
 8002da0:	2380      	movs	r3, #128	; 0x80
 8002da2:	009b      	lsls	r3, r3, #2
 8002da4:	4013      	ands	r3, r2
 8002da6:	d005      	beq.n	8002db4 <HAL_RCC_OscConfig+0x29c>
 8002da8:	687b      	ldr	r3, [r7, #4]
 8002daa:	699b      	ldr	r3, [r3, #24]
 8002dac:	2b00      	cmp	r3, #0
 8002dae:	d101      	bne.n	8002db4 <HAL_RCC_OscConfig+0x29c>
      {
        return HAL_ERROR;
 8002db0:	2301      	movs	r3, #1
 8002db2:	e227      	b.n	8003204 <HAL_RCC_OscConfig+0x6ec>
        /* Check MSICalibrationValue and MSIClockRange input parameters */
        assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
        assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

        /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8002db4:	4b26      	ldr	r3, [pc, #152]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002db6:	685b      	ldr	r3, [r3, #4]
 8002db8:	4a2c      	ldr	r2, [pc, #176]	; (8002e6c <HAL_RCC_OscConfig+0x354>)
 8002dba:	4013      	ands	r3, r2
 8002dbc:	0019      	movs	r1, r3
 8002dbe:	687b      	ldr	r3, [r7, #4]
 8002dc0:	6a1a      	ldr	r2, [r3, #32]
 8002dc2:	4b23      	ldr	r3, [pc, #140]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002dc4:	430a      	orrs	r2, r1
 8002dc6:	605a      	str	r2, [r3, #4]
        /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8002dc8:	4b21      	ldr	r3, [pc, #132]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002dca:	685b      	ldr	r3, [r3, #4]
 8002dcc:	021b      	lsls	r3, r3, #8
 8002dce:	0a19      	lsrs	r1, r3, #8
 8002dd0:	687b      	ldr	r3, [r7, #4]
 8002dd2:	69db      	ldr	r3, [r3, #28]
 8002dd4:	061a      	lsls	r2, r3, #24
 8002dd6:	4b1e      	ldr	r3, [pc, #120]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002dd8:	430a      	orrs	r2, r1
 8002dda:	605a      	str	r2, [r3, #4]


        /* Update the SystemCoreClock global variable */
        SystemCoreClock =  (32768U * (1UL << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_Pos) + 1U)))
 8002ddc:	687b      	ldr	r3, [r7, #4]
 8002dde:	6a1b      	ldr	r3, [r3, #32]
 8002de0:	0b5b      	lsrs	r3, r3, #13
 8002de2:	3301      	adds	r3, #1
 8002de4:	2280      	movs	r2, #128	; 0x80
 8002de6:	0212      	lsls	r2, r2, #8
 8002de8:	409a      	lsls	r2, r3
                           >> AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos)];
 8002dea:	4b19      	ldr	r3, [pc, #100]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002dec:	68db      	ldr	r3, [r3, #12]
 8002dee:	091b      	lsrs	r3, r3, #4
 8002df0:	210f      	movs	r1, #15
 8002df2:	400b      	ands	r3, r1
 8002df4:	491a      	ldr	r1, [pc, #104]	; (8002e60 <HAL_RCC_OscConfig+0x348>)
 8002df6:	5ccb      	ldrb	r3, [r1, r3]
 8002df8:	40da      	lsrs	r2, r3
        SystemCoreClock =  (32768U * (1UL << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_Pos) + 1U)))
 8002dfa:	4b1a      	ldr	r3, [pc, #104]	; (8002e64 <HAL_RCC_OscConfig+0x34c>)
 8002dfc:	601a      	str	r2, [r3, #0]

        /* Configure the source of time base considering new system clocks settings*/
        status = HAL_InitTick (uwTickPrio);
 8002dfe:	4b1a      	ldr	r3, [pc, #104]	; (8002e68 <HAL_RCC_OscConfig+0x350>)
 8002e00:	681b      	ldr	r3, [r3, #0]
 8002e02:	2513      	movs	r5, #19
 8002e04:	197c      	adds	r4, r7, r5
 8002e06:	0018      	movs	r0, r3
 8002e08:	f7ff fb10 	bl	800242c <HAL_InitTick>
 8002e0c:	0003      	movs	r3, r0
 8002e0e:	7023      	strb	r3, [r4, #0]
        if(status != HAL_OK)
 8002e10:	197b      	adds	r3, r7, r5
 8002e12:	781b      	ldrb	r3, [r3, #0]
 8002e14:	2b00      	cmp	r3, #0
 8002e16:	d060      	beq.n	8002eda <HAL_RCC_OscConfig+0x3c2>
        {
          return status;
 8002e18:	197b      	adds	r3, r7, r5
 8002e1a:	781b      	ldrb	r3, [r3, #0]
 8002e1c:	e1f2      	b.n	8003204 <HAL_RCC_OscConfig+0x6ec>
    {
      /* Check MSI State */
      assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));

      /* Check the MSI State */
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 8002e1e:	687b      	ldr	r3, [r7, #4]
 8002e20:	699b      	ldr	r3, [r3, #24]
 8002e22:	2b00      	cmp	r3, #0
 8002e24:	d03f      	beq.n	8002ea6 <HAL_RCC_OscConfig+0x38e>
      {
        /* Enable the Multi Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
 8002e26:	4b0a      	ldr	r3, [pc, #40]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002e28:	681a      	ldr	r2, [r3, #0]
 8002e2a:	4b09      	ldr	r3, [pc, #36]	; (8002e50 <HAL_RCC_OscConfig+0x338>)
 8002e2c:	2180      	movs	r1, #128	; 0x80
 8002e2e:	0049      	lsls	r1, r1, #1
 8002e30:	430a      	orrs	r2, r1
 8002e32:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8002e34:	f7ff fb40 	bl	80024b8 <HAL_GetTick>
 8002e38:	0003      	movs	r3, r0
 8002e3a:	617b      	str	r3, [r7, #20]

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == 0U)
 8002e3c:	e018      	b.n	8002e70 <HAL_RCC_OscConfig+0x358>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8002e3e:	f7ff fb3b 	bl	80024b8 <HAL_GetTick>
 8002e42:	0002      	movs	r2, r0
 8002e44:	697b      	ldr	r3, [r7, #20]
 8002e46:	1ad3      	subs	r3, r2, r3
 8002e48:	2b02      	cmp	r3, #2
 8002e4a:	d911      	bls.n	8002e70 <HAL_RCC_OscConfig+0x358>
          {
            return HAL_TIMEOUT;
 8002e4c:	2303      	movs	r3, #3
 8002e4e:	e1d9      	b.n	8003204 <HAL_RCC_OscConfig+0x6ec>
 8002e50:	40021000 	.word	0x40021000
 8002e54:	fffeffff 	.word	0xfffeffff
 8002e58:	fffbffff 	.word	0xfffbffff
 8002e5c:	ffffe0ff 	.word	0xffffe0ff
 8002e60:	0802350c 	.word	0x0802350c
 8002e64:	20000018 	.word	0x20000018
 8002e68:	2000001c 	.word	0x2000001c
 8002e6c:	ffff1fff 	.word	0xffff1fff
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == 0U)
 8002e70:	4bc9      	ldr	r3, [pc, #804]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8002e72:	681a      	ldr	r2, [r3, #0]
 8002e74:	2380      	movs	r3, #128	; 0x80
 8002e76:	009b      	lsls	r3, r3, #2
 8002e78:	4013      	ands	r3, r2
 8002e7a:	d0e0      	beq.n	8002e3e <HAL_RCC_OscConfig+0x326>
        /* Check MSICalibrationValue and MSIClockRange input parameters */
        assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
        assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

        /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8002e7c:	4bc6      	ldr	r3, [pc, #792]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8002e7e:	685b      	ldr	r3, [r3, #4]
 8002e80:	4ac6      	ldr	r2, [pc, #792]	; (800319c <HAL_RCC_OscConfig+0x684>)
 8002e82:	4013      	ands	r3, r2
 8002e84:	0019      	movs	r1, r3
 8002e86:	687b      	ldr	r3, [r7, #4]
 8002e88:	6a1a      	ldr	r2, [r3, #32]
 8002e8a:	4bc3      	ldr	r3, [pc, #780]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8002e8c:	430a      	orrs	r2, r1
 8002e8e:	605a      	str	r2, [r3, #4]
         /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8002e90:	4bc1      	ldr	r3, [pc, #772]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8002e92:	685b      	ldr	r3, [r3, #4]
 8002e94:	021b      	lsls	r3, r3, #8
 8002e96:	0a19      	lsrs	r1, r3, #8
 8002e98:	687b      	ldr	r3, [r7, #4]
 8002e9a:	69db      	ldr	r3, [r3, #28]
 8002e9c:	061a      	lsls	r2, r3, #24
 8002e9e:	4bbe      	ldr	r3, [pc, #760]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8002ea0:	430a      	orrs	r2, r1
 8002ea2:	605a      	str	r2, [r3, #4]
 8002ea4:	e019      	b.n	8002eda <HAL_RCC_OscConfig+0x3c2>
      }
      else
      {
        /* Disable the Multi Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
 8002ea6:	4bbc      	ldr	r3, [pc, #752]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8002ea8:	681a      	ldr	r2, [r3, #0]
 8002eaa:	4bbb      	ldr	r3, [pc, #748]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8002eac:	49bc      	ldr	r1, [pc, #752]	; (80031a0 <HAL_RCC_OscConfig+0x688>)
 8002eae:	400a      	ands	r2, r1
 8002eb0:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8002eb2:	f7ff fb01 	bl	80024b8 <HAL_GetTick>
 8002eb6:	0003      	movs	r3, r0
 8002eb8:	617b      	str	r3, [r7, #20]

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != 0U)
 8002eba:	e008      	b.n	8002ece <HAL_RCC_OscConfig+0x3b6>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8002ebc:	f7ff fafc 	bl	80024b8 <HAL_GetTick>
 8002ec0:	0002      	movs	r2, r0
 8002ec2:	697b      	ldr	r3, [r7, #20]
 8002ec4:	1ad3      	subs	r3, r2, r3
 8002ec6:	2b02      	cmp	r3, #2
 8002ec8:	d901      	bls.n	8002ece <HAL_RCC_OscConfig+0x3b6>
          {
            return HAL_TIMEOUT;
 8002eca:	2303      	movs	r3, #3
 8002ecc:	e19a      	b.n	8003204 <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != 0U)
 8002ece:	4bb2      	ldr	r3, [pc, #712]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8002ed0:	681a      	ldr	r2, [r3, #0]
 8002ed2:	2380      	movs	r3, #128	; 0x80
 8002ed4:	009b      	lsls	r3, r3, #2
 8002ed6:	4013      	ands	r3, r2
 8002ed8:	d1f0      	bne.n	8002ebc <HAL_RCC_OscConfig+0x3a4>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8002eda:	687b      	ldr	r3, [r7, #4]
 8002edc:	681b      	ldr	r3, [r3, #0]
 8002ede:	2208      	movs	r2, #8
 8002ee0:	4013      	ands	r3, r2
 8002ee2:	d036      	beq.n	8002f52 <HAL_RCC_OscConfig+0x43a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8002ee4:	687b      	ldr	r3, [r7, #4]
 8002ee6:	695b      	ldr	r3, [r3, #20]
 8002ee8:	2b00      	cmp	r3, #0
 8002eea:	d019      	beq.n	8002f20 <HAL_RCC_OscConfig+0x408>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8002eec:	4baa      	ldr	r3, [pc, #680]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8002eee:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8002ef0:	4ba9      	ldr	r3, [pc, #676]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8002ef2:	2101      	movs	r1, #1
 8002ef4:	430a      	orrs	r2, r1
 8002ef6:	651a      	str	r2, [r3, #80]	; 0x50

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8002ef8:	f7ff fade 	bl	80024b8 <HAL_GetTick>
 8002efc:	0003      	movs	r3, r0
 8002efe:	617b      	str	r3, [r7, #20]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 8002f00:	e008      	b.n	8002f14 <HAL_RCC_OscConfig+0x3fc>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8002f02:	f7ff fad9 	bl	80024b8 <HAL_GetTick>
 8002f06:	0002      	movs	r2, r0
 8002f08:	697b      	ldr	r3, [r7, #20]
 8002f0a:	1ad3      	subs	r3, r2, r3
 8002f0c:	2b02      	cmp	r3, #2
 8002f0e:	d901      	bls.n	8002f14 <HAL_RCC_OscConfig+0x3fc>
        {
          return HAL_TIMEOUT;
 8002f10:	2303      	movs	r3, #3
 8002f12:	e177      	b.n	8003204 <HAL_RCC_OscConfig+0x6ec>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 8002f14:	4ba0      	ldr	r3, [pc, #640]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8002f16:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8002f18:	2202      	movs	r2, #2
 8002f1a:	4013      	ands	r3, r2
 8002f1c:	d0f1      	beq.n	8002f02 <HAL_RCC_OscConfig+0x3ea>
 8002f1e:	e018      	b.n	8002f52 <HAL_RCC_OscConfig+0x43a>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8002f20:	4b9d      	ldr	r3, [pc, #628]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8002f22:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8002f24:	4b9c      	ldr	r3, [pc, #624]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8002f26:	2101      	movs	r1, #1
 8002f28:	438a      	bics	r2, r1
 8002f2a:	651a      	str	r2, [r3, #80]	; 0x50

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8002f2c:	f7ff fac4 	bl	80024b8 <HAL_GetTick>
 8002f30:	0003      	movs	r3, r0
 8002f32:	617b      	str	r3, [r7, #20]

      /* Wait till LSI is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 8002f34:	e008      	b.n	8002f48 <HAL_RCC_OscConfig+0x430>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8002f36:	f7ff fabf 	bl	80024b8 <HAL_GetTick>
 8002f3a:	0002      	movs	r2, r0
 8002f3c:	697b      	ldr	r3, [r7, #20]
 8002f3e:	1ad3      	subs	r3, r2, r3
 8002f40:	2b02      	cmp	r3, #2
 8002f42:	d901      	bls.n	8002f48 <HAL_RCC_OscConfig+0x430>
        {
          return HAL_TIMEOUT;
 8002f44:	2303      	movs	r3, #3
 8002f46:	e15d      	b.n	8003204 <HAL_RCC_OscConfig+0x6ec>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 8002f48:	4b93      	ldr	r3, [pc, #588]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8002f4a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8002f4c:	2202      	movs	r2, #2
 8002f4e:	4013      	ands	r3, r2
 8002f50:	d1f1      	bne.n	8002f36 <HAL_RCC_OscConfig+0x41e>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8002f52:	687b      	ldr	r3, [r7, #4]
 8002f54:	681b      	ldr	r3, [r3, #0]
 8002f56:	2204      	movs	r2, #4
 8002f58:	4013      	ands	r3, r2
 8002f5a:	d100      	bne.n	8002f5e <HAL_RCC_OscConfig+0x446>
 8002f5c:	e0ae      	b.n	80030bc <HAL_RCC_OscConfig+0x5a4>
  {
    FlagStatus       pwrclkchanged = RESET;
 8002f5e:	2023      	movs	r0, #35	; 0x23
 8002f60:	183b      	adds	r3, r7, r0
 8002f62:	2200      	movs	r2, #0
 8002f64:	701a      	strb	r2, [r3, #0]
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8002f66:	4b8c      	ldr	r3, [pc, #560]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8002f68:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002f6a:	2380      	movs	r3, #128	; 0x80
 8002f6c:	055b      	lsls	r3, r3, #21
 8002f6e:	4013      	ands	r3, r2
 8002f70:	d109      	bne.n	8002f86 <HAL_RCC_OscConfig+0x46e>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8002f72:	4b89      	ldr	r3, [pc, #548]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8002f74:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002f76:	4b88      	ldr	r3, [pc, #544]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8002f78:	2180      	movs	r1, #128	; 0x80
 8002f7a:	0549      	lsls	r1, r1, #21
 8002f7c:	430a      	orrs	r2, r1
 8002f7e:	639a      	str	r2, [r3, #56]	; 0x38
      pwrclkchanged = SET;
 8002f80:	183b      	adds	r3, r7, r0
 8002f82:	2201      	movs	r2, #1
 8002f84:	701a      	strb	r2, [r3, #0]
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8002f86:	4b87      	ldr	r3, [pc, #540]	; (80031a4 <HAL_RCC_OscConfig+0x68c>)
 8002f88:	681a      	ldr	r2, [r3, #0]
 8002f8a:	2380      	movs	r3, #128	; 0x80
 8002f8c:	005b      	lsls	r3, r3, #1
 8002f8e:	4013      	ands	r3, r2
 8002f90:	d11a      	bne.n	8002fc8 <HAL_RCC_OscConfig+0x4b0>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8002f92:	4b84      	ldr	r3, [pc, #528]	; (80031a4 <HAL_RCC_OscConfig+0x68c>)
 8002f94:	681a      	ldr	r2, [r3, #0]
 8002f96:	4b83      	ldr	r3, [pc, #524]	; (80031a4 <HAL_RCC_OscConfig+0x68c>)
 8002f98:	2180      	movs	r1, #128	; 0x80
 8002f9a:	0049      	lsls	r1, r1, #1
 8002f9c:	430a      	orrs	r2, r1
 8002f9e:	601a      	str	r2, [r3, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8002fa0:	f7ff fa8a 	bl	80024b8 <HAL_GetTick>
 8002fa4:	0003      	movs	r3, r0
 8002fa6:	617b      	str	r3, [r7, #20]

      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8002fa8:	e008      	b.n	8002fbc <HAL_RCC_OscConfig+0x4a4>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8002faa:	f7ff fa85 	bl	80024b8 <HAL_GetTick>
 8002fae:	0002      	movs	r2, r0
 8002fb0:	697b      	ldr	r3, [r7, #20]
 8002fb2:	1ad3      	subs	r3, r2, r3
 8002fb4:	2b64      	cmp	r3, #100	; 0x64
 8002fb6:	d901      	bls.n	8002fbc <HAL_RCC_OscConfig+0x4a4>
        {
          return HAL_TIMEOUT;
 8002fb8:	2303      	movs	r3, #3
 8002fba:	e123      	b.n	8003204 <HAL_RCC_OscConfig+0x6ec>
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8002fbc:	4b79      	ldr	r3, [pc, #484]	; (80031a4 <HAL_RCC_OscConfig+0x68c>)
 8002fbe:	681a      	ldr	r2, [r3, #0]
 8002fc0:	2380      	movs	r3, #128	; 0x80
 8002fc2:	005b      	lsls	r3, r3, #1
 8002fc4:	4013      	ands	r3, r2
 8002fc6:	d0f0      	beq.n	8002faa <HAL_RCC_OscConfig+0x492>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8002fc8:	687b      	ldr	r3, [r7, #4]
 8002fca:	689a      	ldr	r2, [r3, #8]
 8002fcc:	2380      	movs	r3, #128	; 0x80
 8002fce:	005b      	lsls	r3, r3, #1
 8002fd0:	429a      	cmp	r2, r3
 8002fd2:	d107      	bne.n	8002fe4 <HAL_RCC_OscConfig+0x4cc>
 8002fd4:	4b70      	ldr	r3, [pc, #448]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8002fd6:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8002fd8:	4b6f      	ldr	r3, [pc, #444]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8002fda:	2180      	movs	r1, #128	; 0x80
 8002fdc:	0049      	lsls	r1, r1, #1
 8002fde:	430a      	orrs	r2, r1
 8002fe0:	651a      	str	r2, [r3, #80]	; 0x50
 8002fe2:	e031      	b.n	8003048 <HAL_RCC_OscConfig+0x530>
 8002fe4:	687b      	ldr	r3, [r7, #4]
 8002fe6:	689b      	ldr	r3, [r3, #8]
 8002fe8:	2b00      	cmp	r3, #0
 8002fea:	d10c      	bne.n	8003006 <HAL_RCC_OscConfig+0x4ee>
 8002fec:	4b6a      	ldr	r3, [pc, #424]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8002fee:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8002ff0:	4b69      	ldr	r3, [pc, #420]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8002ff2:	496b      	ldr	r1, [pc, #428]	; (80031a0 <HAL_RCC_OscConfig+0x688>)
 8002ff4:	400a      	ands	r2, r1
 8002ff6:	651a      	str	r2, [r3, #80]	; 0x50
 8002ff8:	4b67      	ldr	r3, [pc, #412]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8002ffa:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8002ffc:	4b66      	ldr	r3, [pc, #408]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8002ffe:	496a      	ldr	r1, [pc, #424]	; (80031a8 <HAL_RCC_OscConfig+0x690>)
 8003000:	400a      	ands	r2, r1
 8003002:	651a      	str	r2, [r3, #80]	; 0x50
 8003004:	e020      	b.n	8003048 <HAL_RCC_OscConfig+0x530>
 8003006:	687b      	ldr	r3, [r7, #4]
 8003008:	689a      	ldr	r2, [r3, #8]
 800300a:	23a0      	movs	r3, #160	; 0xa0
 800300c:	00db      	lsls	r3, r3, #3
 800300e:	429a      	cmp	r2, r3
 8003010:	d10e      	bne.n	8003030 <HAL_RCC_OscConfig+0x518>
 8003012:	4b61      	ldr	r3, [pc, #388]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8003014:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003016:	4b60      	ldr	r3, [pc, #384]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8003018:	2180      	movs	r1, #128	; 0x80
 800301a:	00c9      	lsls	r1, r1, #3
 800301c:	430a      	orrs	r2, r1
 800301e:	651a      	str	r2, [r3, #80]	; 0x50
 8003020:	4b5d      	ldr	r3, [pc, #372]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8003022:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003024:	4b5c      	ldr	r3, [pc, #368]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8003026:	2180      	movs	r1, #128	; 0x80
 8003028:	0049      	lsls	r1, r1, #1
 800302a:	430a      	orrs	r2, r1
 800302c:	651a      	str	r2, [r3, #80]	; 0x50
 800302e:	e00b      	b.n	8003048 <HAL_RCC_OscConfig+0x530>
 8003030:	4b59      	ldr	r3, [pc, #356]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8003032:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003034:	4b58      	ldr	r3, [pc, #352]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8003036:	495a      	ldr	r1, [pc, #360]	; (80031a0 <HAL_RCC_OscConfig+0x688>)
 8003038:	400a      	ands	r2, r1
 800303a:	651a      	str	r2, [r3, #80]	; 0x50
 800303c:	4b56      	ldr	r3, [pc, #344]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 800303e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003040:	4b55      	ldr	r3, [pc, #340]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8003042:	4959      	ldr	r1, [pc, #356]	; (80031a8 <HAL_RCC_OscConfig+0x690>)
 8003044:	400a      	ands	r2, r1
 8003046:	651a      	str	r2, [r3, #80]	; 0x50

    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8003048:	687b      	ldr	r3, [r7, #4]
 800304a:	689b      	ldr	r3, [r3, #8]
 800304c:	2b00      	cmp	r3, #0
 800304e:	d015      	beq.n	800307c <HAL_RCC_OscConfig+0x564>
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8003050:	f7ff fa32 	bl	80024b8 <HAL_GetTick>
 8003054:	0003      	movs	r3, r0
 8003056:	617b      	str	r3, [r7, #20]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8003058:	e009      	b.n	800306e <HAL_RCC_OscConfig+0x556>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800305a:	f7ff fa2d 	bl	80024b8 <HAL_GetTick>
 800305e:	0002      	movs	r2, r0
 8003060:	697b      	ldr	r3, [r7, #20]
 8003062:	1ad3      	subs	r3, r2, r3
 8003064:	4a51      	ldr	r2, [pc, #324]	; (80031ac <HAL_RCC_OscConfig+0x694>)
 8003066:	4293      	cmp	r3, r2
 8003068:	d901      	bls.n	800306e <HAL_RCC_OscConfig+0x556>
        {
          return HAL_TIMEOUT;
 800306a:	2303      	movs	r3, #3
 800306c:	e0ca      	b.n	8003204 <HAL_RCC_OscConfig+0x6ec>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800306e:	4b4a      	ldr	r3, [pc, #296]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8003070:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003072:	2380      	movs	r3, #128	; 0x80
 8003074:	009b      	lsls	r3, r3, #2
 8003076:	4013      	ands	r3, r2
 8003078:	d0ef      	beq.n	800305a <HAL_RCC_OscConfig+0x542>
 800307a:	e014      	b.n	80030a6 <HAL_RCC_OscConfig+0x58e>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800307c:	f7ff fa1c 	bl	80024b8 <HAL_GetTick>
 8003080:	0003      	movs	r3, r0
 8003082:	617b      	str	r3, [r7, #20]

      /* Wait till LSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 8003084:	e009      	b.n	800309a <HAL_RCC_OscConfig+0x582>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8003086:	f7ff fa17 	bl	80024b8 <HAL_GetTick>
 800308a:	0002      	movs	r2, r0
 800308c:	697b      	ldr	r3, [r7, #20]
 800308e:	1ad3      	subs	r3, r2, r3
 8003090:	4a46      	ldr	r2, [pc, #280]	; (80031ac <HAL_RCC_OscConfig+0x694>)
 8003092:	4293      	cmp	r3, r2
 8003094:	d901      	bls.n	800309a <HAL_RCC_OscConfig+0x582>
        {
          return HAL_TIMEOUT;
 8003096:	2303      	movs	r3, #3
 8003098:	e0b4      	b.n	8003204 <HAL_RCC_OscConfig+0x6ec>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 800309a:	4b3f      	ldr	r3, [pc, #252]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 800309c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800309e:	2380      	movs	r3, #128	; 0x80
 80030a0:	009b      	lsls	r3, r3, #2
 80030a2:	4013      	ands	r3, r2
 80030a4:	d1ef      	bne.n	8003086 <HAL_RCC_OscConfig+0x56e>
        }
      }
    }

    /* Require to disable power clock if necessary */
    if(pwrclkchanged == SET)
 80030a6:	2323      	movs	r3, #35	; 0x23
 80030a8:	18fb      	adds	r3, r7, r3
 80030aa:	781b      	ldrb	r3, [r3, #0]
 80030ac:	2b01      	cmp	r3, #1
 80030ae:	d105      	bne.n	80030bc <HAL_RCC_OscConfig+0x5a4>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 80030b0:	4b39      	ldr	r3, [pc, #228]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 80030b2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80030b4:	4b38      	ldr	r3, [pc, #224]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 80030b6:	493e      	ldr	r1, [pc, #248]	; (80031b0 <HAL_RCC_OscConfig+0x698>)
 80030b8:	400a      	ands	r2, r1
 80030ba:	639a      	str	r2, [r3, #56]	; 0x38
#endif /* RCC_HSI48_SUPPORT */

  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80030bc:	687b      	ldr	r3, [r7, #4]
 80030be:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80030c0:	2b00      	cmp	r3, #0
 80030c2:	d100      	bne.n	80030c6 <HAL_RCC_OscConfig+0x5ae>
 80030c4:	e09d      	b.n	8003202 <HAL_RCC_OscConfig+0x6ea>
  {
    /* Check if the PLL is used as system clock or not */
    if(sysclk_source != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80030c6:	69fb      	ldr	r3, [r7, #28]
 80030c8:	2b0c      	cmp	r3, #12
 80030ca:	d100      	bne.n	80030ce <HAL_RCC_OscConfig+0x5b6>
 80030cc:	e076      	b.n	80031bc <HAL_RCC_OscConfig+0x6a4>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80030ce:	687b      	ldr	r3, [r7, #4]
 80030d0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80030d2:	2b02      	cmp	r3, #2
 80030d4:	d145      	bne.n	8003162 <HAL_RCC_OscConfig+0x64a>
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
        assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
        assert_param(IS_RCC_PLL_DIV(RCC_OscInitStruct->PLL.PLLDIV));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80030d6:	4b30      	ldr	r3, [pc, #192]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 80030d8:	681a      	ldr	r2, [r3, #0]
 80030da:	4b2f      	ldr	r3, [pc, #188]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 80030dc:	4935      	ldr	r1, [pc, #212]	; (80031b4 <HAL_RCC_OscConfig+0x69c>)
 80030de:	400a      	ands	r2, r1
 80030e0:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80030e2:	f7ff f9e9 	bl	80024b8 <HAL_GetTick>
 80030e6:	0003      	movs	r3, r0
 80030e8:	617b      	str	r3, [r7, #20]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 80030ea:	e008      	b.n	80030fe <HAL_RCC_OscConfig+0x5e6>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80030ec:	f7ff f9e4 	bl	80024b8 <HAL_GetTick>
 80030f0:	0002      	movs	r2, r0
 80030f2:	697b      	ldr	r3, [r7, #20]
 80030f4:	1ad3      	subs	r3, r2, r3
 80030f6:	2b02      	cmp	r3, #2
 80030f8:	d901      	bls.n	80030fe <HAL_RCC_OscConfig+0x5e6>
          {
            return HAL_TIMEOUT;
 80030fa:	2303      	movs	r3, #3
 80030fc:	e082      	b.n	8003204 <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 80030fe:	4b26      	ldr	r3, [pc, #152]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8003100:	681a      	ldr	r2, [r3, #0]
 8003102:	2380      	movs	r3, #128	; 0x80
 8003104:	049b      	lsls	r3, r3, #18
 8003106:	4013      	ands	r3, r2
 8003108:	d1f0      	bne.n	80030ec <HAL_RCC_OscConfig+0x5d4>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800310a:	4b23      	ldr	r3, [pc, #140]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 800310c:	68db      	ldr	r3, [r3, #12]
 800310e:	4a2a      	ldr	r2, [pc, #168]	; (80031b8 <HAL_RCC_OscConfig+0x6a0>)
 8003110:	4013      	ands	r3, r2
 8003112:	0019      	movs	r1, r3
 8003114:	687b      	ldr	r3, [r7, #4]
 8003116:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8003118:	687b      	ldr	r3, [r7, #4]
 800311a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800311c:	431a      	orrs	r2, r3
 800311e:	687b      	ldr	r3, [r7, #4]
 8003120:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8003122:	431a      	orrs	r2, r3
 8003124:	4b1c      	ldr	r3, [pc, #112]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8003126:	430a      	orrs	r2, r1
 8003128:	60da      	str	r2, [r3, #12]
                             RCC_OscInitStruct->PLL.PLLMUL,
                             RCC_OscInitStruct->PLL.PLLDIV);
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 800312a:	4b1b      	ldr	r3, [pc, #108]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 800312c:	681a      	ldr	r2, [r3, #0]
 800312e:	4b1a      	ldr	r3, [pc, #104]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8003130:	2180      	movs	r1, #128	; 0x80
 8003132:	0449      	lsls	r1, r1, #17
 8003134:	430a      	orrs	r2, r1
 8003136:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8003138:	f7ff f9be 	bl	80024b8 <HAL_GetTick>
 800313c:	0003      	movs	r3, r0
 800313e:	617b      	str	r3, [r7, #20]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == 0U)
 8003140:	e008      	b.n	8003154 <HAL_RCC_OscConfig+0x63c>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8003142:	f7ff f9b9 	bl	80024b8 <HAL_GetTick>
 8003146:	0002      	movs	r2, r0
 8003148:	697b      	ldr	r3, [r7, #20]
 800314a:	1ad3      	subs	r3, r2, r3
 800314c:	2b02      	cmp	r3, #2
 800314e:	d901      	bls.n	8003154 <HAL_RCC_OscConfig+0x63c>
          {
            return HAL_TIMEOUT;
 8003150:	2303      	movs	r3, #3
 8003152:	e057      	b.n	8003204 <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == 0U)
 8003154:	4b10      	ldr	r3, [pc, #64]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8003156:	681a      	ldr	r2, [r3, #0]
 8003158:	2380      	movs	r3, #128	; 0x80
 800315a:	049b      	lsls	r3, r3, #18
 800315c:	4013      	ands	r3, r2
 800315e:	d0f0      	beq.n	8003142 <HAL_RCC_OscConfig+0x62a>
 8003160:	e04f      	b.n	8003202 <HAL_RCC_OscConfig+0x6ea>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8003162:	4b0d      	ldr	r3, [pc, #52]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8003164:	681a      	ldr	r2, [r3, #0]
 8003166:	4b0c      	ldr	r3, [pc, #48]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 8003168:	4912      	ldr	r1, [pc, #72]	; (80031b4 <HAL_RCC_OscConfig+0x69c>)
 800316a:	400a      	ands	r2, r1
 800316c:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800316e:	f7ff f9a3 	bl	80024b8 <HAL_GetTick>
 8003172:	0003      	movs	r3, r0
 8003174:	617b      	str	r3, [r7, #20]

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 8003176:	e008      	b.n	800318a <HAL_RCC_OscConfig+0x672>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8003178:	f7ff f99e 	bl	80024b8 <HAL_GetTick>
 800317c:	0002      	movs	r2, r0
 800317e:	697b      	ldr	r3, [r7, #20]
 8003180:	1ad3      	subs	r3, r2, r3
 8003182:	2b02      	cmp	r3, #2
 8003184:	d901      	bls.n	800318a <HAL_RCC_OscConfig+0x672>
          {
            return HAL_TIMEOUT;
 8003186:	2303      	movs	r3, #3
 8003188:	e03c      	b.n	8003204 <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 800318a:	4b03      	ldr	r3, [pc, #12]	; (8003198 <HAL_RCC_OscConfig+0x680>)
 800318c:	681a      	ldr	r2, [r3, #0]
 800318e:	2380      	movs	r3, #128	; 0x80
 8003190:	049b      	lsls	r3, r3, #18
 8003192:	4013      	ands	r3, r2
 8003194:	d1f0      	bne.n	8003178 <HAL_RCC_OscConfig+0x660>
 8003196:	e034      	b.n	8003202 <HAL_RCC_OscConfig+0x6ea>
 8003198:	40021000 	.word	0x40021000
 800319c:	ffff1fff 	.word	0xffff1fff
 80031a0:	fffffeff 	.word	0xfffffeff
 80031a4:	40007000 	.word	0x40007000
 80031a8:	fffffbff 	.word	0xfffffbff
 80031ac:	00001388 	.word	0x00001388
 80031b0:	efffffff 	.word	0xefffffff
 80031b4:	feffffff 	.word	0xfeffffff
 80031b8:	ff02ffff 	.word	0xff02ffff
      }
    }
    else
    {
      /* Check if there is a request to disable the PLL used as System clock source */
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 80031bc:	687b      	ldr	r3, [r7, #4]
 80031be:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80031c0:	2b01      	cmp	r3, #1
 80031c2:	d101      	bne.n	80031c8 <HAL_RCC_OscConfig+0x6b0>
      {
        return HAL_ERROR;
 80031c4:	2301      	movs	r3, #1
 80031c6:	e01d      	b.n	8003204 <HAL_RCC_OscConfig+0x6ec>
      }
      else
      {
        /* Do not return HAL_ERROR if request repeats the current configuration */
        pll_config = RCC->CFGR;
 80031c8:	4b10      	ldr	r3, [pc, #64]	; (800320c <HAL_RCC_OscConfig+0x6f4>)
 80031ca:	68db      	ldr	r3, [r3, #12]
 80031cc:	61bb      	str	r3, [r7, #24]
        if((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 80031ce:	69ba      	ldr	r2, [r7, #24]
 80031d0:	2380      	movs	r3, #128	; 0x80
 80031d2:	025b      	lsls	r3, r3, #9
 80031d4:	401a      	ands	r2, r3
 80031d6:	687b      	ldr	r3, [r7, #4]
 80031d8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80031da:	429a      	cmp	r2, r3
 80031dc:	d10f      	bne.n	80031fe <HAL_RCC_OscConfig+0x6e6>
           (READ_BIT(pll_config, RCC_CFGR_PLLMUL) != RCC_OscInitStruct->PLL.PLLMUL) ||
 80031de:	69ba      	ldr	r2, [r7, #24]
 80031e0:	23f0      	movs	r3, #240	; 0xf0
 80031e2:	039b      	lsls	r3, r3, #14
 80031e4:	401a      	ands	r2, r3
 80031e6:	687b      	ldr	r3, [r7, #4]
 80031e8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
        if((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 80031ea:	429a      	cmp	r2, r3
 80031ec:	d107      	bne.n	80031fe <HAL_RCC_OscConfig+0x6e6>
           (READ_BIT(pll_config, RCC_CFGR_PLLDIV) != RCC_OscInitStruct->PLL.PLLDIV))
 80031ee:	69ba      	ldr	r2, [r7, #24]
 80031f0:	23c0      	movs	r3, #192	; 0xc0
 80031f2:	041b      	lsls	r3, r3, #16
 80031f4:	401a      	ands	r2, r3
 80031f6:	687b      	ldr	r3, [r7, #4]
 80031f8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
           (READ_BIT(pll_config, RCC_CFGR_PLLMUL) != RCC_OscInitStruct->PLL.PLLMUL) ||
 80031fa:	429a      	cmp	r2, r3
 80031fc:	d001      	beq.n	8003202 <HAL_RCC_OscConfig+0x6ea>
        {
          return HAL_ERROR;
 80031fe:	2301      	movs	r3, #1
 8003200:	e000      	b.n	8003204 <HAL_RCC_OscConfig+0x6ec>
        }
      }
    }
  }
  return HAL_OK;
 8003202:	2300      	movs	r3, #0
}
 8003204:	0018      	movs	r0, r3
 8003206:	46bd      	mov	sp, r7
 8003208:	b00a      	add	sp, #40	; 0x28
 800320a:	bdb0      	pop	{r4, r5, r7, pc}
 800320c:	40021000 	.word	0x40021000

08003210 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8003210:	b5b0      	push	{r4, r5, r7, lr}
 8003212:	b084      	sub	sp, #16
 8003214:	af00      	add	r7, sp, #0
 8003216:	6078      	str	r0, [r7, #4]
 8003218:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  HAL_StatusTypeDef status;

  /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
 800321a:	687b      	ldr	r3, [r7, #4]
 800321c:	2b00      	cmp	r3, #0
 800321e:	d101      	bne.n	8003224 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 8003220:	2301      	movs	r3, #1
 8003222:	e128      	b.n	8003476 <HAL_RCC_ClockConfig+0x266>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
  must be correctly programmed according to the frequency of the CPU clock
  (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8003224:	4b96      	ldr	r3, [pc, #600]	; (8003480 <HAL_RCC_ClockConfig+0x270>)
 8003226:	681b      	ldr	r3, [r3, #0]
 8003228:	2201      	movs	r2, #1
 800322a:	4013      	ands	r3, r2
 800322c:	683a      	ldr	r2, [r7, #0]
 800322e:	429a      	cmp	r2, r3
 8003230:	d91e      	bls.n	8003270 <HAL_RCC_ClockConfig+0x60>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8003232:	4b93      	ldr	r3, [pc, #588]	; (8003480 <HAL_RCC_ClockConfig+0x270>)
 8003234:	681b      	ldr	r3, [r3, #0]
 8003236:	2201      	movs	r2, #1
 8003238:	4393      	bics	r3, r2
 800323a:	0019      	movs	r1, r3
 800323c:	4b90      	ldr	r3, [pc, #576]	; (8003480 <HAL_RCC_ClockConfig+0x270>)
 800323e:	683a      	ldr	r2, [r7, #0]
 8003240:	430a      	orrs	r2, r1
 8003242:	601a      	str	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by polling the FLASH_ACR register */
    tickstart = HAL_GetTick();
 8003244:	f7ff f938 	bl	80024b8 <HAL_GetTick>
 8003248:	0003      	movs	r3, r0
 800324a:	60fb      	str	r3, [r7, #12]

    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 800324c:	e009      	b.n	8003262 <HAL_RCC_ClockConfig+0x52>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800324e:	f7ff f933 	bl	80024b8 <HAL_GetTick>
 8003252:	0002      	movs	r2, r0
 8003254:	68fb      	ldr	r3, [r7, #12]
 8003256:	1ad3      	subs	r3, r2, r3
 8003258:	4a8a      	ldr	r2, [pc, #552]	; (8003484 <HAL_RCC_ClockConfig+0x274>)
 800325a:	4293      	cmp	r3, r2
 800325c:	d901      	bls.n	8003262 <HAL_RCC_ClockConfig+0x52>
      {
        return HAL_TIMEOUT;
 800325e:	2303      	movs	r3, #3
 8003260:	e109      	b.n	8003476 <HAL_RCC_ClockConfig+0x266>
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 8003262:	4b87      	ldr	r3, [pc, #540]	; (8003480 <HAL_RCC_ClockConfig+0x270>)
 8003264:	681b      	ldr	r3, [r3, #0]
 8003266:	2201      	movs	r2, #1
 8003268:	4013      	ands	r3, r2
 800326a:	683a      	ldr	r2, [r7, #0]
 800326c:	429a      	cmp	r2, r3
 800326e:	d1ee      	bne.n	800324e <HAL_RCC_ClockConfig+0x3e>
      }
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8003270:	687b      	ldr	r3, [r7, #4]
 8003272:	681b      	ldr	r3, [r3, #0]
 8003274:	2202      	movs	r2, #2
 8003276:	4013      	ands	r3, r2
 8003278:	d009      	beq.n	800328e <HAL_RCC_ClockConfig+0x7e>
  {
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800327a:	4b83      	ldr	r3, [pc, #524]	; (8003488 <HAL_RCC_ClockConfig+0x278>)
 800327c:	68db      	ldr	r3, [r3, #12]
 800327e:	22f0      	movs	r2, #240	; 0xf0
 8003280:	4393      	bics	r3, r2
 8003282:	0019      	movs	r1, r3
 8003284:	687b      	ldr	r3, [r7, #4]
 8003286:	689a      	ldr	r2, [r3, #8]
 8003288:	4b7f      	ldr	r3, [pc, #508]	; (8003488 <HAL_RCC_ClockConfig+0x278>)
 800328a:	430a      	orrs	r2, r1
 800328c:	60da      	str	r2, [r3, #12]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800328e:	687b      	ldr	r3, [r7, #4]
 8003290:	681b      	ldr	r3, [r3, #0]
 8003292:	2201      	movs	r2, #1
 8003294:	4013      	ands	r3, r2
 8003296:	d100      	bne.n	800329a <HAL_RCC_ClockConfig+0x8a>
 8003298:	e089      	b.n	80033ae <HAL_RCC_ClockConfig+0x19e>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800329a:	687b      	ldr	r3, [r7, #4]
 800329c:	685b      	ldr	r3, [r3, #4]
 800329e:	2b02      	cmp	r3, #2
 80032a0:	d107      	bne.n	80032b2 <HAL_RCC_ClockConfig+0xa2>
    {
      /* Check the HSE ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 80032a2:	4b79      	ldr	r3, [pc, #484]	; (8003488 <HAL_RCC_ClockConfig+0x278>)
 80032a4:	681a      	ldr	r2, [r3, #0]
 80032a6:	2380      	movs	r3, #128	; 0x80
 80032a8:	029b      	lsls	r3, r3, #10
 80032aa:	4013      	ands	r3, r2
 80032ac:	d120      	bne.n	80032f0 <HAL_RCC_ClockConfig+0xe0>
      {
        return HAL_ERROR;
 80032ae:	2301      	movs	r3, #1
 80032b0:	e0e1      	b.n	8003476 <HAL_RCC_ClockConfig+0x266>
      }
    }
    /* PLL is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80032b2:	687b      	ldr	r3, [r7, #4]
 80032b4:	685b      	ldr	r3, [r3, #4]
 80032b6:	2b03      	cmp	r3, #3
 80032b8:	d107      	bne.n	80032ca <HAL_RCC_ClockConfig+0xba>
    {
      /* Check the PLL ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 80032ba:	4b73      	ldr	r3, [pc, #460]	; (8003488 <HAL_RCC_ClockConfig+0x278>)
 80032bc:	681a      	ldr	r2, [r3, #0]
 80032be:	2380      	movs	r3, #128	; 0x80
 80032c0:	049b      	lsls	r3, r3, #18
 80032c2:	4013      	ands	r3, r2
 80032c4:	d114      	bne.n	80032f0 <HAL_RCC_ClockConfig+0xe0>
      {
        return HAL_ERROR;
 80032c6:	2301      	movs	r3, #1
 80032c8:	e0d5      	b.n	8003476 <HAL_RCC_ClockConfig+0x266>
      }
    }
    /* HSI is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
 80032ca:	687b      	ldr	r3, [r7, #4]
 80032cc:	685b      	ldr	r3, [r3, #4]
 80032ce:	2b01      	cmp	r3, #1
 80032d0:	d106      	bne.n	80032e0 <HAL_RCC_ClockConfig+0xd0>
    {
      /* Check the HSI ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 80032d2:	4b6d      	ldr	r3, [pc, #436]	; (8003488 <HAL_RCC_ClockConfig+0x278>)
 80032d4:	681b      	ldr	r3, [r3, #0]
 80032d6:	2204      	movs	r2, #4
 80032d8:	4013      	ands	r3, r2
 80032da:	d109      	bne.n	80032f0 <HAL_RCC_ClockConfig+0xe0>
      {
        return HAL_ERROR;
 80032dc:	2301      	movs	r3, #1
 80032de:	e0ca      	b.n	8003476 <HAL_RCC_ClockConfig+0x266>
    }
    /* MSI is selected as System Clock Source */
    else
    {
      /* Check the MSI ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == 0U)
 80032e0:	4b69      	ldr	r3, [pc, #420]	; (8003488 <HAL_RCC_ClockConfig+0x278>)
 80032e2:	681a      	ldr	r2, [r3, #0]
 80032e4:	2380      	movs	r3, #128	; 0x80
 80032e6:	009b      	lsls	r3, r3, #2
 80032e8:	4013      	ands	r3, r2
 80032ea:	d101      	bne.n	80032f0 <HAL_RCC_ClockConfig+0xe0>
      {
        return HAL_ERROR;
 80032ec:	2301      	movs	r3, #1
 80032ee:	e0c2      	b.n	8003476 <HAL_RCC_ClockConfig+0x266>
      }
    }
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80032f0:	4b65      	ldr	r3, [pc, #404]	; (8003488 <HAL_RCC_ClockConfig+0x278>)
 80032f2:	68db      	ldr	r3, [r3, #12]
 80032f4:	2203      	movs	r2, #3
 80032f6:	4393      	bics	r3, r2
 80032f8:	0019      	movs	r1, r3
 80032fa:	687b      	ldr	r3, [r7, #4]
 80032fc:	685a      	ldr	r2, [r3, #4]
 80032fe:	4b62      	ldr	r3, [pc, #392]	; (8003488 <HAL_RCC_ClockConfig+0x278>)
 8003300:	430a      	orrs	r2, r1
 8003302:	60da      	str	r2, [r3, #12]

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 8003304:	f7ff f8d8 	bl	80024b8 <HAL_GetTick>
 8003308:	0003      	movs	r3, r0
 800330a:	60fb      	str	r3, [r7, #12]

    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800330c:	687b      	ldr	r3, [r7, #4]
 800330e:	685b      	ldr	r3, [r3, #4]
 8003310:	2b02      	cmp	r3, #2
 8003312:	d111      	bne.n	8003338 <HAL_RCC_ClockConfig+0x128>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8003314:	e009      	b.n	800332a <HAL_RCC_ClockConfig+0x11a>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8003316:	f7ff f8cf 	bl	80024b8 <HAL_GetTick>
 800331a:	0002      	movs	r2, r0
 800331c:	68fb      	ldr	r3, [r7, #12]
 800331e:	1ad3      	subs	r3, r2, r3
 8003320:	4a58      	ldr	r2, [pc, #352]	; (8003484 <HAL_RCC_ClockConfig+0x274>)
 8003322:	4293      	cmp	r3, r2
 8003324:	d901      	bls.n	800332a <HAL_RCC_ClockConfig+0x11a>
        {
          return HAL_TIMEOUT;
 8003326:	2303      	movs	r3, #3
 8003328:	e0a5      	b.n	8003476 <HAL_RCC_ClockConfig+0x266>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 800332a:	4b57      	ldr	r3, [pc, #348]	; (8003488 <HAL_RCC_ClockConfig+0x278>)
 800332c:	68db      	ldr	r3, [r3, #12]
 800332e:	220c      	movs	r2, #12
 8003330:	4013      	ands	r3, r2
 8003332:	2b08      	cmp	r3, #8
 8003334:	d1ef      	bne.n	8003316 <HAL_RCC_ClockConfig+0x106>
 8003336:	e03a      	b.n	80033ae <HAL_RCC_ClockConfig+0x19e>
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8003338:	687b      	ldr	r3, [r7, #4]
 800333a:	685b      	ldr	r3, [r3, #4]
 800333c:	2b03      	cmp	r3, #3
 800333e:	d111      	bne.n	8003364 <HAL_RCC_ClockConfig+0x154>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8003340:	e009      	b.n	8003356 <HAL_RCC_ClockConfig+0x146>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8003342:	f7ff f8b9 	bl	80024b8 <HAL_GetTick>
 8003346:	0002      	movs	r2, r0
 8003348:	68fb      	ldr	r3, [r7, #12]
 800334a:	1ad3      	subs	r3, r2, r3
 800334c:	4a4d      	ldr	r2, [pc, #308]	; (8003484 <HAL_RCC_ClockConfig+0x274>)
 800334e:	4293      	cmp	r3, r2
 8003350:	d901      	bls.n	8003356 <HAL_RCC_ClockConfig+0x146>
        {
          return HAL_TIMEOUT;
 8003352:	2303      	movs	r3, #3
 8003354:	e08f      	b.n	8003476 <HAL_RCC_ClockConfig+0x266>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8003356:	4b4c      	ldr	r3, [pc, #304]	; (8003488 <HAL_RCC_ClockConfig+0x278>)
 8003358:	68db      	ldr	r3, [r3, #12]
 800335a:	220c      	movs	r2, #12
 800335c:	4013      	ands	r3, r2
 800335e:	2b0c      	cmp	r3, #12
 8003360:	d1ef      	bne.n	8003342 <HAL_RCC_ClockConfig+0x132>
 8003362:	e024      	b.n	80033ae <HAL_RCC_ClockConfig+0x19e>
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
 8003364:	687b      	ldr	r3, [r7, #4]
 8003366:	685b      	ldr	r3, [r3, #4]
 8003368:	2b01      	cmp	r3, #1
 800336a:	d11b      	bne.n	80033a4 <HAL_RCC_ClockConfig+0x194>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 800336c:	e009      	b.n	8003382 <HAL_RCC_ClockConfig+0x172>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800336e:	f7ff f8a3 	bl	80024b8 <HAL_GetTick>
 8003372:	0002      	movs	r2, r0
 8003374:	68fb      	ldr	r3, [r7, #12]
 8003376:	1ad3      	subs	r3, r2, r3
 8003378:	4a42      	ldr	r2, [pc, #264]	; (8003484 <HAL_RCC_ClockConfig+0x274>)
 800337a:	4293      	cmp	r3, r2
 800337c:	d901      	bls.n	8003382 <HAL_RCC_ClockConfig+0x172>
        {
          return HAL_TIMEOUT;
 800337e:	2303      	movs	r3, #3
 8003380:	e079      	b.n	8003476 <HAL_RCC_ClockConfig+0x266>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 8003382:	4b41      	ldr	r3, [pc, #260]	; (8003488 <HAL_RCC_ClockConfig+0x278>)
 8003384:	68db      	ldr	r3, [r3, #12]
 8003386:	220c      	movs	r2, #12
 8003388:	4013      	ands	r3, r2
 800338a:	2b04      	cmp	r3, #4
 800338c:	d1ef      	bne.n	800336e <HAL_RCC_ClockConfig+0x15e>
 800338e:	e00e      	b.n	80033ae <HAL_RCC_ClockConfig+0x19e>
    }
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8003390:	f7ff f892 	bl	80024b8 <HAL_GetTick>
 8003394:	0002      	movs	r2, r0
 8003396:	68fb      	ldr	r3, [r7, #12]
 8003398:	1ad3      	subs	r3, r2, r3
 800339a:	4a3a      	ldr	r2, [pc, #232]	; (8003484 <HAL_RCC_ClockConfig+0x274>)
 800339c:	4293      	cmp	r3, r2
 800339e:	d901      	bls.n	80033a4 <HAL_RCC_ClockConfig+0x194>
        {
          return HAL_TIMEOUT;
 80033a0:	2303      	movs	r3, #3
 80033a2:	e068      	b.n	8003476 <HAL_RCC_ClockConfig+0x266>
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
 80033a4:	4b38      	ldr	r3, [pc, #224]	; (8003488 <HAL_RCC_ClockConfig+0x278>)
 80033a6:	68db      	ldr	r3, [r3, #12]
 80033a8:	220c      	movs	r2, #12
 80033aa:	4013      	ands	r3, r2
 80033ac:	d1f0      	bne.n	8003390 <HAL_RCC_ClockConfig+0x180>
        }
      }
    }
  }
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 80033ae:	4b34      	ldr	r3, [pc, #208]	; (8003480 <HAL_RCC_ClockConfig+0x270>)
 80033b0:	681b      	ldr	r3, [r3, #0]
 80033b2:	2201      	movs	r2, #1
 80033b4:	4013      	ands	r3, r2
 80033b6:	683a      	ldr	r2, [r7, #0]
 80033b8:	429a      	cmp	r2, r3
 80033ba:	d21e      	bcs.n	80033fa <HAL_RCC_ClockConfig+0x1ea>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80033bc:	4b30      	ldr	r3, [pc, #192]	; (8003480 <HAL_RCC_ClockConfig+0x270>)
 80033be:	681b      	ldr	r3, [r3, #0]
 80033c0:	2201      	movs	r2, #1
 80033c2:	4393      	bics	r3, r2
 80033c4:	0019      	movs	r1, r3
 80033c6:	4b2e      	ldr	r3, [pc, #184]	; (8003480 <HAL_RCC_ClockConfig+0x270>)
 80033c8:	683a      	ldr	r2, [r7, #0]
 80033ca:	430a      	orrs	r2, r1
 80033cc:	601a      	str	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by polling the FLASH_ACR register */
    tickstart = HAL_GetTick();
 80033ce:	f7ff f873 	bl	80024b8 <HAL_GetTick>
 80033d2:	0003      	movs	r3, r0
 80033d4:	60fb      	str	r3, [r7, #12]

    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 80033d6:	e009      	b.n	80033ec <HAL_RCC_ClockConfig+0x1dc>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80033d8:	f7ff f86e 	bl	80024b8 <HAL_GetTick>
 80033dc:	0002      	movs	r2, r0
 80033de:	68fb      	ldr	r3, [r7, #12]
 80033e0:	1ad3      	subs	r3, r2, r3
 80033e2:	4a28      	ldr	r2, [pc, #160]	; (8003484 <HAL_RCC_ClockConfig+0x274>)
 80033e4:	4293      	cmp	r3, r2
 80033e6:	d901      	bls.n	80033ec <HAL_RCC_ClockConfig+0x1dc>
      {
        return HAL_TIMEOUT;
 80033e8:	2303      	movs	r3, #3
 80033ea:	e044      	b.n	8003476 <HAL_RCC_ClockConfig+0x266>
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 80033ec:	4b24      	ldr	r3, [pc, #144]	; (8003480 <HAL_RCC_ClockConfig+0x270>)
 80033ee:	681b      	ldr	r3, [r3, #0]
 80033f0:	2201      	movs	r2, #1
 80033f2:	4013      	ands	r3, r2
 80033f4:	683a      	ldr	r2, [r7, #0]
 80033f6:	429a      	cmp	r2, r3
 80033f8:	d1ee      	bne.n	80033d8 <HAL_RCC_ClockConfig+0x1c8>
      }
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80033fa:	687b      	ldr	r3, [r7, #4]
 80033fc:	681b      	ldr	r3, [r3, #0]
 80033fe:	2204      	movs	r2, #4
 8003400:	4013      	ands	r3, r2
 8003402:	d009      	beq.n	8003418 <HAL_RCC_ClockConfig+0x208>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8003404:	4b20      	ldr	r3, [pc, #128]	; (8003488 <HAL_RCC_ClockConfig+0x278>)
 8003406:	68db      	ldr	r3, [r3, #12]
 8003408:	4a20      	ldr	r2, [pc, #128]	; (800348c <HAL_RCC_ClockConfig+0x27c>)
 800340a:	4013      	ands	r3, r2
 800340c:	0019      	movs	r1, r3
 800340e:	687b      	ldr	r3, [r7, #4]
 8003410:	68da      	ldr	r2, [r3, #12]
 8003412:	4b1d      	ldr	r3, [pc, #116]	; (8003488 <HAL_RCC_ClockConfig+0x278>)
 8003414:	430a      	orrs	r2, r1
 8003416:	60da      	str	r2, [r3, #12]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8003418:	687b      	ldr	r3, [r7, #4]
 800341a:	681b      	ldr	r3, [r3, #0]
 800341c:	2208      	movs	r2, #8
 800341e:	4013      	ands	r3, r2
 8003420:	d00a      	beq.n	8003438 <HAL_RCC_ClockConfig+0x228>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8003422:	4b19      	ldr	r3, [pc, #100]	; (8003488 <HAL_RCC_ClockConfig+0x278>)
 8003424:	68db      	ldr	r3, [r3, #12]
 8003426:	4a1a      	ldr	r2, [pc, #104]	; (8003490 <HAL_RCC_ClockConfig+0x280>)
 8003428:	4013      	ands	r3, r2
 800342a:	0019      	movs	r1, r3
 800342c:	687b      	ldr	r3, [r7, #4]
 800342e:	691b      	ldr	r3, [r3, #16]
 8003430:	00da      	lsls	r2, r3, #3
 8003432:	4b15      	ldr	r3, [pc, #84]	; (8003488 <HAL_RCC_ClockConfig+0x278>)
 8003434:	430a      	orrs	r2, r1
 8003436:	60da      	str	r2, [r3, #12]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 8003438:	f000 f832 	bl	80034a0 <HAL_RCC_GetSysClockFreq>
 800343c:	0001      	movs	r1, r0
 800343e:	4b12      	ldr	r3, [pc, #72]	; (8003488 <HAL_RCC_ClockConfig+0x278>)
 8003440:	68db      	ldr	r3, [r3, #12]
 8003442:	091b      	lsrs	r3, r3, #4
 8003444:	220f      	movs	r2, #15
 8003446:	4013      	ands	r3, r2
 8003448:	4a12      	ldr	r2, [pc, #72]	; (8003494 <HAL_RCC_ClockConfig+0x284>)
 800344a:	5cd3      	ldrb	r3, [r2, r3]
 800344c:	000a      	movs	r2, r1
 800344e:	40da      	lsrs	r2, r3
 8003450:	4b11      	ldr	r3, [pc, #68]	; (8003498 <HAL_RCC_ClockConfig+0x288>)
 8003452:	601a      	str	r2, [r3, #0]

  /* Configure the source of time base considering new system clocks settings*/
  status = HAL_InitTick(uwTickPrio);
 8003454:	4b11      	ldr	r3, [pc, #68]	; (800349c <HAL_RCC_ClockConfig+0x28c>)
 8003456:	681b      	ldr	r3, [r3, #0]
 8003458:	250b      	movs	r5, #11
 800345a:	197c      	adds	r4, r7, r5
 800345c:	0018      	movs	r0, r3
 800345e:	f7fe ffe5 	bl	800242c <HAL_InitTick>
 8003462:	0003      	movs	r3, r0
 8003464:	7023      	strb	r3, [r4, #0]
  if(status != HAL_OK)
 8003466:	197b      	adds	r3, r7, r5
 8003468:	781b      	ldrb	r3, [r3, #0]
 800346a:	2b00      	cmp	r3, #0
 800346c:	d002      	beq.n	8003474 <HAL_RCC_ClockConfig+0x264>
  {
    return status;
 800346e:	197b      	adds	r3, r7, r5
 8003470:	781b      	ldrb	r3, [r3, #0]
 8003472:	e000      	b.n	8003476 <HAL_RCC_ClockConfig+0x266>
  }

  return HAL_OK;
 8003474:	2300      	movs	r3, #0
}
 8003476:	0018      	movs	r0, r3
 8003478:	46bd      	mov	sp, r7
 800347a:	b004      	add	sp, #16
 800347c:	bdb0      	pop	{r4, r5, r7, pc}
 800347e:	46c0      	nop			; (mov r8, r8)
 8003480:	40022000 	.word	0x40022000
 8003484:	00001388 	.word	0x00001388
 8003488:	40021000 	.word	0x40021000
 800348c:	fffff8ff 	.word	0xfffff8ff
 8003490:	ffffc7ff 	.word	0xffffc7ff
 8003494:	0802350c 	.word	0x0802350c
 8003498:	20000018 	.word	0x20000018
 800349c:	2000001c 	.word	0x2000001c

080034a0 <HAL_RCC_GetSysClockFreq>:
  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 80034a0:	b5b0      	push	{r4, r5, r7, lr}
 80034a2:	b08e      	sub	sp, #56	; 0x38
 80034a4:	af00      	add	r7, sp, #0
  uint32_t tmpreg, pllm, plld, pllvco, msiclkrange;    /* no init needed */
  uint32_t sysclockfreq;

  tmpreg = RCC->CFGR;
 80034a6:	4b4c      	ldr	r3, [pc, #304]	; (80035d8 <HAL_RCC_GetSysClockFreq+0x138>)
 80034a8:	68db      	ldr	r3, [r3, #12]
 80034aa:	62fb      	str	r3, [r7, #44]	; 0x2c

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
 80034ac:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80034ae:	230c      	movs	r3, #12
 80034b0:	4013      	ands	r3, r2
 80034b2:	2b0c      	cmp	r3, #12
 80034b4:	d014      	beq.n	80034e0 <HAL_RCC_GetSysClockFreq+0x40>
 80034b6:	d900      	bls.n	80034ba <HAL_RCC_GetSysClockFreq+0x1a>
 80034b8:	e07b      	b.n	80035b2 <HAL_RCC_GetSysClockFreq+0x112>
 80034ba:	2b04      	cmp	r3, #4
 80034bc:	d002      	beq.n	80034c4 <HAL_RCC_GetSysClockFreq+0x24>
 80034be:	2b08      	cmp	r3, #8
 80034c0:	d00b      	beq.n	80034da <HAL_RCC_GetSysClockFreq+0x3a>
 80034c2:	e076      	b.n	80035b2 <HAL_RCC_GetSysClockFreq+0x112>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    {
      if ((RCC->CR & RCC_CR_HSIDIVF) != 0U)
 80034c4:	4b44      	ldr	r3, [pc, #272]	; (80035d8 <HAL_RCC_GetSysClockFreq+0x138>)
 80034c6:	681b      	ldr	r3, [r3, #0]
 80034c8:	2210      	movs	r2, #16
 80034ca:	4013      	ands	r3, r2
 80034cc:	d002      	beq.n	80034d4 <HAL_RCC_GetSysClockFreq+0x34>
      {
        sysclockfreq =  (HSI_VALUE >> 2);
 80034ce:	4b43      	ldr	r3, [pc, #268]	; (80035dc <HAL_RCC_GetSysClockFreq+0x13c>)
 80034d0:	633b      	str	r3, [r7, #48]	; 0x30
      }
      else
      {
        sysclockfreq =  HSI_VALUE;
      }
      break;
 80034d2:	e07c      	b.n	80035ce <HAL_RCC_GetSysClockFreq+0x12e>
        sysclockfreq =  HSI_VALUE;
 80034d4:	4b42      	ldr	r3, [pc, #264]	; (80035e0 <HAL_RCC_GetSysClockFreq+0x140>)
 80034d6:	633b      	str	r3, [r7, #48]	; 0x30
      break;
 80034d8:	e079      	b.n	80035ce <HAL_RCC_GetSysClockFreq+0x12e>
    }
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
    {
      sysclockfreq = HSE_VALUE;
 80034da:	4b42      	ldr	r3, [pc, #264]	; (80035e4 <HAL_RCC_GetSysClockFreq+0x144>)
 80034dc:	633b      	str	r3, [r7, #48]	; 0x30
      break;
 80034de:	e076      	b.n	80035ce <HAL_RCC_GetSysClockFreq+0x12e>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
    {
      pllm = PLLMulTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_Pos];
 80034e0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80034e2:	0c9a      	lsrs	r2, r3, #18
 80034e4:	230f      	movs	r3, #15
 80034e6:	401a      	ands	r2, r3
 80034e8:	4b3f      	ldr	r3, [pc, #252]	; (80035e8 <HAL_RCC_GetSysClockFreq+0x148>)
 80034ea:	5c9b      	ldrb	r3, [r3, r2]
 80034ec:	62bb      	str	r3, [r7, #40]	; 0x28
      plld = ((uint32_t)(tmpreg & RCC_CFGR_PLLDIV) >> RCC_CFGR_PLLDIV_Pos) + 1U;
 80034ee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80034f0:	0d9a      	lsrs	r2, r3, #22
 80034f2:	2303      	movs	r3, #3
 80034f4:	4013      	ands	r3, r2
 80034f6:	3301      	adds	r3, #1
 80034f8:	627b      	str	r3, [r7, #36]	; 0x24
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 80034fa:	4b37      	ldr	r3, [pc, #220]	; (80035d8 <HAL_RCC_GetSysClockFreq+0x138>)
 80034fc:	68da      	ldr	r2, [r3, #12]
 80034fe:	2380      	movs	r3, #128	; 0x80
 8003500:	025b      	lsls	r3, r3, #9
 8003502:	4013      	ands	r3, r2
 8003504:	d01a      	beq.n	800353c <HAL_RCC_GetSysClockFreq+0x9c>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t)(((uint64_t)HSE_VALUE * (uint64_t)pllm) / (uint64_t)plld);
 8003506:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003508:	61bb      	str	r3, [r7, #24]
 800350a:	2300      	movs	r3, #0
 800350c:	61fb      	str	r3, [r7, #28]
 800350e:	4a35      	ldr	r2, [pc, #212]	; (80035e4 <HAL_RCC_GetSysClockFreq+0x144>)
 8003510:	2300      	movs	r3, #0
 8003512:	69b8      	ldr	r0, [r7, #24]
 8003514:	69f9      	ldr	r1, [r7, #28]
 8003516:	f7fc febf 	bl	8000298 <__aeabi_lmul>
 800351a:	0002      	movs	r2, r0
 800351c:	000b      	movs	r3, r1
 800351e:	0010      	movs	r0, r2
 8003520:	0019      	movs	r1, r3
 8003522:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003524:	613b      	str	r3, [r7, #16]
 8003526:	2300      	movs	r3, #0
 8003528:	617b      	str	r3, [r7, #20]
 800352a:	693a      	ldr	r2, [r7, #16]
 800352c:	697b      	ldr	r3, [r7, #20]
 800352e:	f7fc fe93 	bl	8000258 <__aeabi_uldivmod>
 8003532:	0002      	movs	r2, r0
 8003534:	000b      	movs	r3, r1
 8003536:	0013      	movs	r3, r2
 8003538:	637b      	str	r3, [r7, #52]	; 0x34
 800353a:	e037      	b.n	80035ac <HAL_RCC_GetSysClockFreq+0x10c>
      }
      else
      {
        if ((RCC->CR & RCC_CR_HSIDIVF) != 0U)
 800353c:	4b26      	ldr	r3, [pc, #152]	; (80035d8 <HAL_RCC_GetSysClockFreq+0x138>)
 800353e:	681b      	ldr	r3, [r3, #0]
 8003540:	2210      	movs	r2, #16
 8003542:	4013      	ands	r3, r2
 8003544:	d01a      	beq.n	800357c <HAL_RCC_GetSysClockFreq+0xdc>
        {
          pllvco = (uint32_t)((((uint64_t)(HSI_VALUE >> 2)) * (uint64_t)pllm) / (uint64_t)plld);
 8003546:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003548:	60bb      	str	r3, [r7, #8]
 800354a:	2300      	movs	r3, #0
 800354c:	60fb      	str	r3, [r7, #12]
 800354e:	4a23      	ldr	r2, [pc, #140]	; (80035dc <HAL_RCC_GetSysClockFreq+0x13c>)
 8003550:	2300      	movs	r3, #0
 8003552:	68b8      	ldr	r0, [r7, #8]
 8003554:	68f9      	ldr	r1, [r7, #12]
 8003556:	f7fc fe9f 	bl	8000298 <__aeabi_lmul>
 800355a:	0002      	movs	r2, r0
 800355c:	000b      	movs	r3, r1
 800355e:	0010      	movs	r0, r2
 8003560:	0019      	movs	r1, r3
 8003562:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003564:	603b      	str	r3, [r7, #0]
 8003566:	2300      	movs	r3, #0
 8003568:	607b      	str	r3, [r7, #4]
 800356a:	683a      	ldr	r2, [r7, #0]
 800356c:	687b      	ldr	r3, [r7, #4]
 800356e:	f7fc fe73 	bl	8000258 <__aeabi_uldivmod>
 8003572:	0002      	movs	r2, r0
 8003574:	000b      	movs	r3, r1
 8003576:	0013      	movs	r3, r2
 8003578:	637b      	str	r3, [r7, #52]	; 0x34
 800357a:	e017      	b.n	80035ac <HAL_RCC_GetSysClockFreq+0x10c>
        }
        else
        {
         pllvco = (uint32_t)(((uint64_t)HSI_VALUE * (uint64_t)pllm) / (uint64_t)plld);
 800357c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800357e:	0018      	movs	r0, r3
 8003580:	2300      	movs	r3, #0
 8003582:	0019      	movs	r1, r3
 8003584:	4a16      	ldr	r2, [pc, #88]	; (80035e0 <HAL_RCC_GetSysClockFreq+0x140>)
 8003586:	2300      	movs	r3, #0
 8003588:	f7fc fe86 	bl	8000298 <__aeabi_lmul>
 800358c:	0002      	movs	r2, r0
 800358e:	000b      	movs	r3, r1
 8003590:	0010      	movs	r0, r2
 8003592:	0019      	movs	r1, r3
 8003594:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003596:	001c      	movs	r4, r3
 8003598:	2300      	movs	r3, #0
 800359a:	001d      	movs	r5, r3
 800359c:	0022      	movs	r2, r4
 800359e:	002b      	movs	r3, r5
 80035a0:	f7fc fe5a 	bl	8000258 <__aeabi_uldivmod>
 80035a4:	0002      	movs	r2, r0
 80035a6:	000b      	movs	r3, r1
 80035a8:	0013      	movs	r3, r2
 80035aa:	637b      	str	r3, [r7, #52]	; 0x34
        }
      }
      sysclockfreq = pllvco;
 80035ac:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80035ae:	633b      	str	r3, [r7, #48]	; 0x30
      break;
 80035b0:	e00d      	b.n	80035ce <HAL_RCC_GetSysClockFreq+0x12e>
    }
    case RCC_SYSCLKSOURCE_STATUS_MSI:  /* MSI used as system clock source */
    default: /* MSI used as system clock */
    {
      msiclkrange = (RCC->ICSCR & RCC_ICSCR_MSIRANGE ) >> RCC_ICSCR_MSIRANGE_Pos;
 80035b2:	4b09      	ldr	r3, [pc, #36]	; (80035d8 <HAL_RCC_GetSysClockFreq+0x138>)
 80035b4:	685b      	ldr	r3, [r3, #4]
 80035b6:	0b5b      	lsrs	r3, r3, #13
 80035b8:	2207      	movs	r2, #7
 80035ba:	4013      	ands	r3, r2
 80035bc:	623b      	str	r3, [r7, #32]
      sysclockfreq = (32768U * (1UL << (msiclkrange + 1U)));
 80035be:	6a3b      	ldr	r3, [r7, #32]
 80035c0:	3301      	adds	r3, #1
 80035c2:	2280      	movs	r2, #128	; 0x80
 80035c4:	0212      	lsls	r2, r2, #8
 80035c6:	409a      	lsls	r2, r3
 80035c8:	0013      	movs	r3, r2
 80035ca:	633b      	str	r3, [r7, #48]	; 0x30
      break;
 80035cc:	46c0      	nop			; (mov r8, r8)
    }
  }
  return sysclockfreq;
 80035ce:	6b3b      	ldr	r3, [r7, #48]	; 0x30
}
 80035d0:	0018      	movs	r0, r3
 80035d2:	46bd      	mov	sp, r7
 80035d4:	b00e      	add	sp, #56	; 0x38
 80035d6:	bdb0      	pop	{r4, r5, r7, pc}
 80035d8:	40021000 	.word	0x40021000
 80035dc:	003d0900 	.word	0x003d0900
 80035e0:	00f42400 	.word	0x00f42400
 80035e4:	007a1200 	.word	0x007a1200
 80035e8:	08023524 	.word	0x08023524

080035ec <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 80035ec:	b580      	push	{r7, lr}
 80035ee:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 80035f0:	4b02      	ldr	r3, [pc, #8]	; (80035fc <HAL_RCC_GetHCLKFreq+0x10>)
 80035f2:	681b      	ldr	r3, [r3, #0]
}
 80035f4:	0018      	movs	r0, r3
 80035f6:	46bd      	mov	sp, r7
 80035f8:	bd80      	pop	{r7, pc}
 80035fa:	46c0      	nop			; (mov r8, r8)
 80035fc:	20000018 	.word	0x20000018

08003600 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 8003600:	b580      	push	{r7, lr}
 8003602:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 8003604:	f7ff fff2 	bl	80035ec <HAL_RCC_GetHCLKFreq>
 8003608:	0001      	movs	r1, r0
 800360a:	4b06      	ldr	r3, [pc, #24]	; (8003624 <HAL_RCC_GetPCLK1Freq+0x24>)
 800360c:	68db      	ldr	r3, [r3, #12]
 800360e:	0a1b      	lsrs	r3, r3, #8
 8003610:	2207      	movs	r2, #7
 8003612:	4013      	ands	r3, r2
 8003614:	4a04      	ldr	r2, [pc, #16]	; (8003628 <HAL_RCC_GetPCLK1Freq+0x28>)
 8003616:	5cd3      	ldrb	r3, [r2, r3]
 8003618:	40d9      	lsrs	r1, r3
 800361a:	000b      	movs	r3, r1
}
 800361c:	0018      	movs	r0, r3
 800361e:	46bd      	mov	sp, r7
 8003620:	bd80      	pop	{r7, pc}
 8003622:	46c0      	nop			; (mov r8, r8)
 8003624:	40021000 	.word	0x40021000
 8003628:	0802351c 	.word	0x0802351c

0800362c <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 800362c:	b580      	push	{r7, lr}
 800362e:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 8003630:	f7ff ffdc 	bl	80035ec <HAL_RCC_GetHCLKFreq>
 8003634:	0001      	movs	r1, r0
 8003636:	4b06      	ldr	r3, [pc, #24]	; (8003650 <HAL_RCC_GetPCLK2Freq+0x24>)
 8003638:	68db      	ldr	r3, [r3, #12]
 800363a:	0adb      	lsrs	r3, r3, #11
 800363c:	2207      	movs	r2, #7
 800363e:	4013      	ands	r3, r2
 8003640:	4a04      	ldr	r2, [pc, #16]	; (8003654 <HAL_RCC_GetPCLK2Freq+0x28>)
 8003642:	5cd3      	ldrb	r3, [r2, r3]
 8003644:	40d9      	lsrs	r1, r3
 8003646:	000b      	movs	r3, r1
}
 8003648:	0018      	movs	r0, r3
 800364a:	46bd      	mov	sp, r7
 800364c:	bd80      	pop	{r7, pc}
 800364e:	46c0      	nop			; (mov r8, r8)
 8003650:	40021000 	.word	0x40021000
 8003654:	0802351c 	.word	0x0802351c

08003658 <HAL_RCCEx_PeriphCLKConfig>:
  * @retval HAL status
  * @note   If HAL_ERROR returned, first switch-OFF HSE clock oscillator with @ref HAL_RCC_OscConfig()
  *         to possibly update HSE divider.
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8003658:	b580      	push	{r7, lr}
 800365a:	b086      	sub	sp, #24
 800365c:	af00      	add	r7, sp, #0
 800365e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  uint32_t temp_reg;
  FlagStatus       pwrclkchanged = RESET;
 8003660:	2017      	movs	r0, #23
 8003662:	183b      	adds	r3, r7, r0
 8003664:	2200      	movs	r2, #0
 8003666:	701a      	strb	r2, [r3, #0]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*------------------------------- RTC/LCD Configuration ------------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8003668:	687b      	ldr	r3, [r7, #4]
 800366a:	681b      	ldr	r3, [r3, #0]
 800366c:	2220      	movs	r2, #32
 800366e:	4013      	ands	r3, r2
 8003670:	d100      	bne.n	8003674 <HAL_RCCEx_PeriphCLKConfig+0x1c>
 8003672:	e0c2      	b.n	80037fa <HAL_RCCEx_PeriphCLKConfig+0x1a2>
#endif /* LCD */

    /* As soon as function is called to change RTC clock source, activation of the
       power domain is done. */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8003674:	4b91      	ldr	r3, [pc, #580]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003676:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8003678:	2380      	movs	r3, #128	; 0x80
 800367a:	055b      	lsls	r3, r3, #21
 800367c:	4013      	ands	r3, r2
 800367e:	d109      	bne.n	8003694 <HAL_RCCEx_PeriphCLKConfig+0x3c>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8003680:	4b8e      	ldr	r3, [pc, #568]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003682:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8003684:	4b8d      	ldr	r3, [pc, #564]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003686:	2180      	movs	r1, #128	; 0x80
 8003688:	0549      	lsls	r1, r1, #21
 800368a:	430a      	orrs	r2, r1
 800368c:	639a      	str	r2, [r3, #56]	; 0x38
      pwrclkchanged = SET;
 800368e:	183b      	adds	r3, r7, r0
 8003690:	2201      	movs	r2, #1
 8003692:	701a      	strb	r2, [r3, #0]
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8003694:	4b8a      	ldr	r3, [pc, #552]	; (80038c0 <HAL_RCCEx_PeriphCLKConfig+0x268>)
 8003696:	681a      	ldr	r2, [r3, #0]
 8003698:	2380      	movs	r3, #128	; 0x80
 800369a:	005b      	lsls	r3, r3, #1
 800369c:	4013      	ands	r3, r2
 800369e:	d11a      	bne.n	80036d6 <HAL_RCCEx_PeriphCLKConfig+0x7e>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 80036a0:	4b87      	ldr	r3, [pc, #540]	; (80038c0 <HAL_RCCEx_PeriphCLKConfig+0x268>)
 80036a2:	681a      	ldr	r2, [r3, #0]
 80036a4:	4b86      	ldr	r3, [pc, #536]	; (80038c0 <HAL_RCCEx_PeriphCLKConfig+0x268>)
 80036a6:	2180      	movs	r1, #128	; 0x80
 80036a8:	0049      	lsls	r1, r1, #1
 80036aa:	430a      	orrs	r2, r1
 80036ac:	601a      	str	r2, [r3, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 80036ae:	f7fe ff03 	bl	80024b8 <HAL_GetTick>
 80036b2:	0003      	movs	r3, r0
 80036b4:	613b      	str	r3, [r7, #16]

      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80036b6:	e008      	b.n	80036ca <HAL_RCCEx_PeriphCLKConfig+0x72>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80036b8:	f7fe fefe 	bl	80024b8 <HAL_GetTick>
 80036bc:	0002      	movs	r2, r0
 80036be:	693b      	ldr	r3, [r7, #16]
 80036c0:	1ad3      	subs	r3, r2, r3
 80036c2:	2b64      	cmp	r3, #100	; 0x64
 80036c4:	d901      	bls.n	80036ca <HAL_RCCEx_PeriphCLKConfig+0x72>
        {
          return HAL_TIMEOUT;
 80036c6:	2303      	movs	r3, #3
 80036c8:	e0f3      	b.n	80038b2 <HAL_RCCEx_PeriphCLKConfig+0x25a>
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80036ca:	4b7d      	ldr	r3, [pc, #500]	; (80038c0 <HAL_RCCEx_PeriphCLKConfig+0x268>)
 80036cc:	681a      	ldr	r2, [r3, #0]
 80036ce:	2380      	movs	r3, #128	; 0x80
 80036d0:	005b      	lsls	r3, r3, #1
 80036d2:	4013      	ands	r3, r2
 80036d4:	d0f0      	beq.n	80036b8 <HAL_RCCEx_PeriphCLKConfig+0x60>
        }
      }
    }

    /* Check if user wants to change HSE RTC prescaler whereas HSE is enabled */
    temp_reg = (RCC->CR & RCC_CR_RTCPRE);
 80036d6:	4b79      	ldr	r3, [pc, #484]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 80036d8:	681a      	ldr	r2, [r3, #0]
 80036da:	23c0      	movs	r3, #192	; 0xc0
 80036dc:	039b      	lsls	r3, r3, #14
 80036de:	4013      	ands	r3, r2
 80036e0:	60fb      	str	r3, [r7, #12]
    if ((temp_reg != (PeriphClkInit->RTCClockSelection & RCC_CR_RTCPRE))
 80036e2:	687b      	ldr	r3, [r7, #4]
 80036e4:	685a      	ldr	r2, [r3, #4]
 80036e6:	23c0      	movs	r3, #192	; 0xc0
 80036e8:	039b      	lsls	r3, r3, #14
 80036ea:	4013      	ands	r3, r2
 80036ec:	68fa      	ldr	r2, [r7, #12]
 80036ee:	429a      	cmp	r2, r3
 80036f0:	d013      	beq.n	800371a <HAL_RCCEx_PeriphCLKConfig+0xc2>
#if defined (LCD)
     || (temp_reg != (PeriphClkInit->LCDClockSelection & RCC_CR_RTCPRE))
#endif /* LCD */
       )
    { /* Check HSE State */
      if ((PeriphClkInit->RTCClockSelection & RCC_CSR_RTCSEL) == RCC_CSR_RTCSEL_HSE)
 80036f2:	687b      	ldr	r3, [r7, #4]
 80036f4:	685a      	ldr	r2, [r3, #4]
 80036f6:	23c0      	movs	r3, #192	; 0xc0
 80036f8:	029b      	lsls	r3, r3, #10
 80036fa:	401a      	ands	r2, r3
 80036fc:	23c0      	movs	r3, #192	; 0xc0
 80036fe:	029b      	lsls	r3, r3, #10
 8003700:	429a      	cmp	r2, r3
 8003702:	d10a      	bne.n	800371a <HAL_RCCEx_PeriphCLKConfig+0xc2>
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
 8003704:	4b6d      	ldr	r3, [pc, #436]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003706:	681a      	ldr	r2, [r3, #0]
 8003708:	2380      	movs	r3, #128	; 0x80
 800370a:	029b      	lsls	r3, r3, #10
 800370c:	401a      	ands	r2, r3
 800370e:	2380      	movs	r3, #128	; 0x80
 8003710:	029b      	lsls	r3, r3, #10
 8003712:	429a      	cmp	r2, r3
 8003714:	d101      	bne.n	800371a <HAL_RCCEx_PeriphCLKConfig+0xc2>
        {
          /* To update HSE divider, first switch-OFF HSE clock oscillator*/
          return HAL_ERROR;
 8003716:	2301      	movs	r3, #1
 8003718:	e0cb      	b.n	80038b2 <HAL_RCCEx_PeriphCLKConfig+0x25a>
        }
      }
    }

    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */
    temp_reg = (RCC->CSR & RCC_CSR_RTCSEL);
 800371a:	4b68      	ldr	r3, [pc, #416]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800371c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800371e:	23c0      	movs	r3, #192	; 0xc0
 8003720:	029b      	lsls	r3, r3, #10
 8003722:	4013      	ands	r3, r2
 8003724:	60fb      	str	r3, [r7, #12]

    if((temp_reg != 0x00000000U) && (((temp_reg != (PeriphClkInit->RTCClockSelection & RCC_CSR_RTCSEL)) \
 8003726:	68fb      	ldr	r3, [r7, #12]
 8003728:	2b00      	cmp	r3, #0
 800372a:	d03b      	beq.n	80037a4 <HAL_RCCEx_PeriphCLKConfig+0x14c>
 800372c:	687b      	ldr	r3, [r7, #4]
 800372e:	685a      	ldr	r2, [r3, #4]
 8003730:	23c0      	movs	r3, #192	; 0xc0
 8003732:	029b      	lsls	r3, r3, #10
 8003734:	4013      	ands	r3, r2
 8003736:	68fa      	ldr	r2, [r7, #12]
 8003738:	429a      	cmp	r2, r3
 800373a:	d033      	beq.n	80037a4 <HAL_RCCEx_PeriphCLKConfig+0x14c>
      && (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
 800373c:	687b      	ldr	r3, [r7, #4]
 800373e:	681b      	ldr	r3, [r3, #0]
 8003740:	2220      	movs	r2, #32
 8003742:	4013      	ands	r3, r2
 8003744:	d02e      	beq.n	80037a4 <HAL_RCCEx_PeriphCLKConfig+0x14c>
       && (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LCD) == RCC_PERIPHCLK_LCD))
#endif /* LCD */
     ))
    {
      /* Store the content of CSR register before the reset of Backup Domain */
      temp_reg = (RCC->CSR & ~(RCC_CSR_RTCSEL));
 8003746:	4b5d      	ldr	r3, [pc, #372]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003748:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800374a:	4a5e      	ldr	r2, [pc, #376]	; (80038c4 <HAL_RCCEx_PeriphCLKConfig+0x26c>)
 800374c:	4013      	ands	r3, r2
 800374e:	60fb      	str	r3, [r7, #12]

      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 8003750:	4b5a      	ldr	r3, [pc, #360]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003752:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003754:	4b59      	ldr	r3, [pc, #356]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003756:	2180      	movs	r1, #128	; 0x80
 8003758:	0309      	lsls	r1, r1, #12
 800375a:	430a      	orrs	r2, r1
 800375c:	651a      	str	r2, [r3, #80]	; 0x50
      __HAL_RCC_BACKUPRESET_RELEASE();
 800375e:	4b57      	ldr	r3, [pc, #348]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003760:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003762:	4b56      	ldr	r3, [pc, #344]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003764:	4958      	ldr	r1, [pc, #352]	; (80038c8 <HAL_RCCEx_PeriphCLKConfig+0x270>)
 8003766:	400a      	ands	r2, r1
 8003768:	651a      	str	r2, [r3, #80]	; 0x50

      /* Restore the Content of CSR register */
      RCC->CSR = temp_reg;
 800376a:	4b54      	ldr	r3, [pc, #336]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800376c:	68fa      	ldr	r2, [r7, #12]
 800376e:	651a      	str	r2, [r3, #80]	; 0x50

       /* Wait for LSERDY if LSE was enabled */
      if (HAL_IS_BIT_SET(temp_reg, RCC_CSR_LSEON))
 8003770:	68fa      	ldr	r2, [r7, #12]
 8003772:	2380      	movs	r3, #128	; 0x80
 8003774:	005b      	lsls	r3, r3, #1
 8003776:	4013      	ands	r3, r2
 8003778:	d014      	beq.n	80037a4 <HAL_RCCEx_PeriphCLKConfig+0x14c>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800377a:	f7fe fe9d 	bl	80024b8 <HAL_GetTick>
 800377e:	0003      	movs	r3, r0
 8003780:	613b      	str	r3, [r7, #16]

        /* Wait till LSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8003782:	e009      	b.n	8003798 <HAL_RCCEx_PeriphCLKConfig+0x140>
        {
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8003784:	f7fe fe98 	bl	80024b8 <HAL_GetTick>
 8003788:	0002      	movs	r2, r0
 800378a:	693b      	ldr	r3, [r7, #16]
 800378c:	1ad3      	subs	r3, r2, r3
 800378e:	4a4f      	ldr	r2, [pc, #316]	; (80038cc <HAL_RCCEx_PeriphCLKConfig+0x274>)
 8003790:	4293      	cmp	r3, r2
 8003792:	d901      	bls.n	8003798 <HAL_RCCEx_PeriphCLKConfig+0x140>
          {
            return HAL_TIMEOUT;
 8003794:	2303      	movs	r3, #3
 8003796:	e08c      	b.n	80038b2 <HAL_RCCEx_PeriphCLKConfig+0x25a>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8003798:	4b48      	ldr	r3, [pc, #288]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800379a:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800379c:	2380      	movs	r3, #128	; 0x80
 800379e:	009b      	lsls	r3, r3, #2
 80037a0:	4013      	ands	r3, r2
 80037a2:	d0ef      	beq.n	8003784 <HAL_RCCEx_PeriphCLKConfig+0x12c>
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 80037a4:	687b      	ldr	r3, [r7, #4]
 80037a6:	685a      	ldr	r2, [r3, #4]
 80037a8:	23c0      	movs	r3, #192	; 0xc0
 80037aa:	029b      	lsls	r3, r3, #10
 80037ac:	401a      	ands	r2, r3
 80037ae:	23c0      	movs	r3, #192	; 0xc0
 80037b0:	029b      	lsls	r3, r3, #10
 80037b2:	429a      	cmp	r2, r3
 80037b4:	d10c      	bne.n	80037d0 <HAL_RCCEx_PeriphCLKConfig+0x178>
 80037b6:	4b41      	ldr	r3, [pc, #260]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 80037b8:	681b      	ldr	r3, [r3, #0]
 80037ba:	4a45      	ldr	r2, [pc, #276]	; (80038d0 <HAL_RCCEx_PeriphCLKConfig+0x278>)
 80037bc:	4013      	ands	r3, r2
 80037be:	0019      	movs	r1, r3
 80037c0:	687b      	ldr	r3, [r7, #4]
 80037c2:	685a      	ldr	r2, [r3, #4]
 80037c4:	23c0      	movs	r3, #192	; 0xc0
 80037c6:	039b      	lsls	r3, r3, #14
 80037c8:	401a      	ands	r2, r3
 80037ca:	4b3c      	ldr	r3, [pc, #240]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 80037cc:	430a      	orrs	r2, r1
 80037ce:	601a      	str	r2, [r3, #0]
 80037d0:	4b3a      	ldr	r3, [pc, #232]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 80037d2:	6d19      	ldr	r1, [r3, #80]	; 0x50
 80037d4:	687b      	ldr	r3, [r7, #4]
 80037d6:	685a      	ldr	r2, [r3, #4]
 80037d8:	23c0      	movs	r3, #192	; 0xc0
 80037da:	029b      	lsls	r3, r3, #10
 80037dc:	401a      	ands	r2, r3
 80037de:	4b37      	ldr	r3, [pc, #220]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 80037e0:	430a      	orrs	r2, r1
 80037e2:	651a      	str	r2, [r3, #80]	; 0x50

    /* Require to disable power clock if necessary */
    if(pwrclkchanged == SET)
 80037e4:	2317      	movs	r3, #23
 80037e6:	18fb      	adds	r3, r7, r3
 80037e8:	781b      	ldrb	r3, [r3, #0]
 80037ea:	2b01      	cmp	r3, #1
 80037ec:	d105      	bne.n	80037fa <HAL_RCCEx_PeriphCLKConfig+0x1a2>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 80037ee:	4b33      	ldr	r3, [pc, #204]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 80037f0:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80037f2:	4b32      	ldr	r3, [pc, #200]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 80037f4:	4937      	ldr	r1, [pc, #220]	; (80038d4 <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 80037f6:	400a      	ands	r2, r1
 80037f8:	639a      	str	r2, [r3, #56]	; 0x38
    }
  }

#if defined (RCC_CCIPR_USART1SEL)
  /*------------------------------- USART1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 80037fa:	687b      	ldr	r3, [r7, #4]
 80037fc:	681b      	ldr	r3, [r3, #0]
 80037fe:	2201      	movs	r2, #1
 8003800:	4013      	ands	r3, r2
 8003802:	d009      	beq.n	8003818 <HAL_RCCEx_PeriphCLKConfig+0x1c0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8003804:	4b2d      	ldr	r3, [pc, #180]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003806:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8003808:	2203      	movs	r2, #3
 800380a:	4393      	bics	r3, r2
 800380c:	0019      	movs	r1, r3
 800380e:	687b      	ldr	r3, [r7, #4]
 8003810:	689a      	ldr	r2, [r3, #8]
 8003812:	4b2a      	ldr	r3, [pc, #168]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003814:	430a      	orrs	r2, r1
 8003816:	64da      	str	r2, [r3, #76]	; 0x4c
  }
#endif /* RCC_CCIPR_USART1SEL */

  /*----------------------------- USART2 Configuration --------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8003818:	687b      	ldr	r3, [r7, #4]
 800381a:	681b      	ldr	r3, [r3, #0]
 800381c:	2202      	movs	r2, #2
 800381e:	4013      	ands	r3, r2
 8003820:	d009      	beq.n	8003836 <HAL_RCCEx_PeriphCLKConfig+0x1de>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8003822:	4b26      	ldr	r3, [pc, #152]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003824:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8003826:	220c      	movs	r2, #12
 8003828:	4393      	bics	r3, r2
 800382a:	0019      	movs	r1, r3
 800382c:	687b      	ldr	r3, [r7, #4]
 800382e:	68da      	ldr	r2, [r3, #12]
 8003830:	4b22      	ldr	r3, [pc, #136]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003832:	430a      	orrs	r2, r1
 8003834:	64da      	str	r2, [r3, #76]	; 0x4c
  }

  /*------------------------------ LPUART1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8003836:	687b      	ldr	r3, [r7, #4]
 8003838:	681b      	ldr	r3, [r3, #0]
 800383a:	2204      	movs	r2, #4
 800383c:	4013      	ands	r3, r2
 800383e:	d009      	beq.n	8003854 <HAL_RCCEx_PeriphCLKConfig+0x1fc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 8003840:	4b1e      	ldr	r3, [pc, #120]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003842:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8003844:	4a24      	ldr	r2, [pc, #144]	; (80038d8 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 8003846:	4013      	ands	r3, r2
 8003848:	0019      	movs	r1, r3
 800384a:	687b      	ldr	r3, [r7, #4]
 800384c:	691a      	ldr	r2, [r3, #16]
 800384e:	4b1b      	ldr	r3, [pc, #108]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003850:	430a      	orrs	r2, r1
 8003852:	64da      	str	r2, [r3, #76]	; 0x4c
  }

  /*------------------------------ I2C1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8003854:	687b      	ldr	r3, [r7, #4]
 8003856:	681b      	ldr	r3, [r3, #0]
 8003858:	2208      	movs	r2, #8
 800385a:	4013      	ands	r3, r2
 800385c:	d009      	beq.n	8003872 <HAL_RCCEx_PeriphCLKConfig+0x21a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 800385e:	4b17      	ldr	r3, [pc, #92]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003860:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8003862:	4a1e      	ldr	r2, [pc, #120]	; (80038dc <HAL_RCCEx_PeriphCLKConfig+0x284>)
 8003864:	4013      	ands	r3, r2
 8003866:	0019      	movs	r1, r3
 8003868:	687b      	ldr	r3, [r7, #4]
 800386a:	695a      	ldr	r2, [r3, #20]
 800386c:	4b13      	ldr	r3, [pc, #76]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800386e:	430a      	orrs	r2, r1
 8003870:	64da      	str	r2, [r3, #76]	; 0x4c
  }

#if defined (RCC_CCIPR_I2C3SEL)
    /*------------------------------ I2C3 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8003872:	687b      	ldr	r3, [r7, #4]
 8003874:	681a      	ldr	r2, [r3, #0]
 8003876:	2380      	movs	r3, #128	; 0x80
 8003878:	005b      	lsls	r3, r3, #1
 800387a:	4013      	ands	r3, r2
 800387c:	d009      	beq.n	8003892 <HAL_RCCEx_PeriphCLKConfig+0x23a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 800387e:	4b0f      	ldr	r3, [pc, #60]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003880:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8003882:	4a10      	ldr	r2, [pc, #64]	; (80038c4 <HAL_RCCEx_PeriphCLKConfig+0x26c>)
 8003884:	4013      	ands	r3, r2
 8003886:	0019      	movs	r1, r3
 8003888:	687b      	ldr	r3, [r7, #4]
 800388a:	699a      	ldr	r2, [r3, #24]
 800388c:	4b0b      	ldr	r3, [pc, #44]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800388e:	430a      	orrs	r2, r1
 8003890:	64da      	str	r2, [r3, #76]	; 0x4c
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
  }
#endif /* USB */

  /*---------------------------- LPTIM1 configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 8003892:	687b      	ldr	r3, [r7, #4]
 8003894:	681b      	ldr	r3, [r3, #0]
 8003896:	2280      	movs	r2, #128	; 0x80
 8003898:	4013      	ands	r3, r2
 800389a:	d009      	beq.n	80038b0 <HAL_RCCEx_PeriphCLKConfig+0x258>
  {
    assert_param(IS_RCC_LPTIMCLK(PeriphClkInit->LptimClockSelection));
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->LptimClockSelection);
 800389c:	4b07      	ldr	r3, [pc, #28]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800389e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80038a0:	4a0f      	ldr	r2, [pc, #60]	; (80038e0 <HAL_RCCEx_PeriphCLKConfig+0x288>)
 80038a2:	4013      	ands	r3, r2
 80038a4:	0019      	movs	r1, r3
 80038a6:	687b      	ldr	r3, [r7, #4]
 80038a8:	69da      	ldr	r2, [r3, #28]
 80038aa:	4b04      	ldr	r3, [pc, #16]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x264>)
 80038ac:	430a      	orrs	r2, r1
 80038ae:	64da      	str	r2, [r3, #76]	; 0x4c
  }

  return HAL_OK;
 80038b0:	2300      	movs	r3, #0
}
 80038b2:	0018      	movs	r0, r3
 80038b4:	46bd      	mov	sp, r7
 80038b6:	b006      	add	sp, #24
 80038b8:	bd80      	pop	{r7, pc}
 80038ba:	46c0      	nop			; (mov r8, r8)
 80038bc:	40021000 	.word	0x40021000
 80038c0:	40007000 	.word	0x40007000
 80038c4:	fffcffff 	.word	0xfffcffff
 80038c8:	fff7ffff 	.word	0xfff7ffff
 80038cc:	00001388 	.word	0x00001388
 80038d0:	ffcfffff 	.word	0xffcfffff
 80038d4:	efffffff 	.word	0xefffffff
 80038d8:	fffff3ff 	.word	0xfffff3ff
 80038dc:	ffffcfff 	.word	0xffffcfff
 80038e0:	fff3ffff 	.word	0xfff3ffff

080038e4 <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 80038e4:	b580      	push	{r7, lr}
 80038e6:	b082      	sub	sp, #8
 80038e8:	af00      	add	r7, sp, #0
 80038ea:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
 80038ec:	687b      	ldr	r3, [r7, #4]
 80038ee:	2b00      	cmp	r3, #0
 80038f0:	d101      	bne.n	80038f6 <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 80038f2:	2301      	movs	r3, #1
 80038f4:	e044      	b.n	8003980 <HAL_UART_Init+0x9c>
  {
    /* Check the parameters */
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
  }

  if (huart->gState == HAL_UART_STATE_RESET)
 80038f6:	687b      	ldr	r3, [r7, #4]
 80038f8:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80038fa:	2b00      	cmp	r3, #0
 80038fc:	d107      	bne.n	800390e <HAL_UART_Init+0x2a>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 80038fe:	687b      	ldr	r3, [r7, #4]
 8003900:	2274      	movs	r2, #116	; 0x74
 8003902:	2100      	movs	r1, #0
 8003904:	5499      	strb	r1, [r3, r2]

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 8003906:	687b      	ldr	r3, [r7, #4]
 8003908:	0018      	movs	r0, r3
 800390a:	f7fd f805 	bl	8000918 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
 800390e:	687b      	ldr	r3, [r7, #4]
 8003910:	2224      	movs	r2, #36	; 0x24
 8003912:	679a      	str	r2, [r3, #120]	; 0x78

  __HAL_UART_DISABLE(huart);
 8003914:	687b      	ldr	r3, [r7, #4]
 8003916:	681b      	ldr	r3, [r3, #0]
 8003918:	681a      	ldr	r2, [r3, #0]
 800391a:	687b      	ldr	r3, [r7, #4]
 800391c:	681b      	ldr	r3, [r3, #0]
 800391e:	2101      	movs	r1, #1
 8003920:	438a      	bics	r2, r1
 8003922:	601a      	str	r2, [r3, #0]

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
 8003924:	687b      	ldr	r3, [r7, #4]
 8003926:	0018      	movs	r0, r3
 8003928:	f000 fc36 	bl	8004198 <UART_SetConfig>
 800392c:	0003      	movs	r3, r0
 800392e:	2b01      	cmp	r3, #1
 8003930:	d101      	bne.n	8003936 <HAL_UART_Init+0x52>
  {
    return HAL_ERROR;
 8003932:	2301      	movs	r3, #1
 8003934:	e024      	b.n	8003980 <HAL_UART_Init+0x9c>
  }

  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 8003936:	687b      	ldr	r3, [r7, #4]
 8003938:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800393a:	2b00      	cmp	r3, #0
 800393c:	d003      	beq.n	8003946 <HAL_UART_Init+0x62>
  {
    UART_AdvFeatureConfig(huart);
 800393e:	687b      	ldr	r3, [r7, #4]
 8003940:	0018      	movs	r0, r3
 8003942:	f000 fee7 	bl	8004714 <UART_AdvFeatureConfig>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8003946:	687b      	ldr	r3, [r7, #4]
 8003948:	681b      	ldr	r3, [r3, #0]
 800394a:	685a      	ldr	r2, [r3, #4]
 800394c:	687b      	ldr	r3, [r7, #4]
 800394e:	681b      	ldr	r3, [r3, #0]
 8003950:	490d      	ldr	r1, [pc, #52]	; (8003988 <HAL_UART_Init+0xa4>)
 8003952:	400a      	ands	r2, r1
 8003954:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8003956:	687b      	ldr	r3, [r7, #4]
 8003958:	681b      	ldr	r3, [r3, #0]
 800395a:	689a      	ldr	r2, [r3, #8]
 800395c:	687b      	ldr	r3, [r7, #4]
 800395e:	681b      	ldr	r3, [r3, #0]
 8003960:	212a      	movs	r1, #42	; 0x2a
 8003962:	438a      	bics	r2, r1
 8003964:	609a      	str	r2, [r3, #8]

  __HAL_UART_ENABLE(huart);
 8003966:	687b      	ldr	r3, [r7, #4]
 8003968:	681b      	ldr	r3, [r3, #0]
 800396a:	681a      	ldr	r2, [r3, #0]
 800396c:	687b      	ldr	r3, [r7, #4]
 800396e:	681b      	ldr	r3, [r3, #0]
 8003970:	2101      	movs	r1, #1
 8003972:	430a      	orrs	r2, r1
 8003974:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
 8003976:	687b      	ldr	r3, [r7, #4]
 8003978:	0018      	movs	r0, r3
 800397a:	f000 ff7f 	bl	800487c <UART_CheckIdleState>
 800397e:	0003      	movs	r3, r0
}
 8003980:	0018      	movs	r0, r3
 8003982:	46bd      	mov	sp, r7
 8003984:	b002      	add	sp, #8
 8003986:	bd80      	pop	{r7, pc}
 8003988:	ffffb7ff 	.word	0xffffb7ff

0800398c <HAL_UART_Transmit>:
  * @param Size    Amount of data elements (u8 or u16) to be sent.
  * @param Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 800398c:	b580      	push	{r7, lr}
 800398e:	b08a      	sub	sp, #40	; 0x28
 8003990:	af02      	add	r7, sp, #8
 8003992:	60f8      	str	r0, [r7, #12]
 8003994:	60b9      	str	r1, [r7, #8]
 8003996:	603b      	str	r3, [r7, #0]
 8003998:	1dbb      	adds	r3, r7, #6
 800399a:	801a      	strh	r2, [r3, #0]
  uint8_t  *pdata8bits;
  uint16_t *pdata16bits;
  uint32_t tickstart;

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 800399c:	68fb      	ldr	r3, [r7, #12]
 800399e:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80039a0:	2b20      	cmp	r3, #32
 80039a2:	d000      	beq.n	80039a6 <HAL_UART_Transmit+0x1a>
 80039a4:	e095      	b.n	8003ad2 <HAL_UART_Transmit+0x146>
  {
    if ((pData == NULL) || (Size == 0U))
 80039a6:	68bb      	ldr	r3, [r7, #8]
 80039a8:	2b00      	cmp	r3, #0
 80039aa:	d003      	beq.n	80039b4 <HAL_UART_Transmit+0x28>
 80039ac:	1dbb      	adds	r3, r7, #6
 80039ae:	881b      	ldrh	r3, [r3, #0]
 80039b0:	2b00      	cmp	r3, #0
 80039b2:	d101      	bne.n	80039b8 <HAL_UART_Transmit+0x2c>
    {
      return  HAL_ERROR;
 80039b4:	2301      	movs	r3, #1
 80039b6:	e08d      	b.n	8003ad4 <HAL_UART_Transmit+0x148>
    }

    /* In case of 9bits/No Parity transfer, pData buffer provided as input parameter
       should be aligned on a u16 frontier, as data to be filled into TDR will be
       handled through a u16 cast. */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80039b8:	68fb      	ldr	r3, [r7, #12]
 80039ba:	689a      	ldr	r2, [r3, #8]
 80039bc:	2380      	movs	r3, #128	; 0x80
 80039be:	015b      	lsls	r3, r3, #5
 80039c0:	429a      	cmp	r2, r3
 80039c2:	d109      	bne.n	80039d8 <HAL_UART_Transmit+0x4c>
 80039c4:	68fb      	ldr	r3, [r7, #12]
 80039c6:	691b      	ldr	r3, [r3, #16]
 80039c8:	2b00      	cmp	r3, #0
 80039ca:	d105      	bne.n	80039d8 <HAL_UART_Transmit+0x4c>
    {
      if ((((uint32_t)pData) & 1U) != 0U)
 80039cc:	68bb      	ldr	r3, [r7, #8]
 80039ce:	2201      	movs	r2, #1
 80039d0:	4013      	ands	r3, r2
 80039d2:	d001      	beq.n	80039d8 <HAL_UART_Transmit+0x4c>
      {
        return  HAL_ERROR;
 80039d4:	2301      	movs	r3, #1
 80039d6:	e07d      	b.n	8003ad4 <HAL_UART_Transmit+0x148>
      }
    }

    __HAL_LOCK(huart);
 80039d8:	68fb      	ldr	r3, [r7, #12]
 80039da:	2274      	movs	r2, #116	; 0x74
 80039dc:	5c9b      	ldrb	r3, [r3, r2]
 80039de:	2b01      	cmp	r3, #1
 80039e0:	d101      	bne.n	80039e6 <HAL_UART_Transmit+0x5a>
 80039e2:	2302      	movs	r3, #2
 80039e4:	e076      	b.n	8003ad4 <HAL_UART_Transmit+0x148>
 80039e6:	68fb      	ldr	r3, [r7, #12]
 80039e8:	2274      	movs	r2, #116	; 0x74
 80039ea:	2101      	movs	r1, #1
 80039ec:	5499      	strb	r1, [r3, r2]

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 80039ee:	68fb      	ldr	r3, [r7, #12]
 80039f0:	2280      	movs	r2, #128	; 0x80
 80039f2:	2100      	movs	r1, #0
 80039f4:	5099      	str	r1, [r3, r2]
    huart->gState = HAL_UART_STATE_BUSY_TX;
 80039f6:	68fb      	ldr	r3, [r7, #12]
 80039f8:	2221      	movs	r2, #33	; 0x21
 80039fa:	679a      	str	r2, [r3, #120]	; 0x78

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
 80039fc:	f7fe fd5c 	bl	80024b8 <HAL_GetTick>
 8003a00:	0003      	movs	r3, r0
 8003a02:	617b      	str	r3, [r7, #20]

    huart->TxXferSize  = Size;
 8003a04:	68fb      	ldr	r3, [r7, #12]
 8003a06:	1dba      	adds	r2, r7, #6
 8003a08:	2150      	movs	r1, #80	; 0x50
 8003a0a:	8812      	ldrh	r2, [r2, #0]
 8003a0c:	525a      	strh	r2, [r3, r1]
    huart->TxXferCount = Size;
 8003a0e:	68fb      	ldr	r3, [r7, #12]
 8003a10:	1dba      	adds	r2, r7, #6
 8003a12:	2152      	movs	r1, #82	; 0x52
 8003a14:	8812      	ldrh	r2, [r2, #0]
 8003a16:	525a      	strh	r2, [r3, r1]

    /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8003a18:	68fb      	ldr	r3, [r7, #12]
 8003a1a:	689a      	ldr	r2, [r3, #8]
 8003a1c:	2380      	movs	r3, #128	; 0x80
 8003a1e:	015b      	lsls	r3, r3, #5
 8003a20:	429a      	cmp	r2, r3
 8003a22:	d108      	bne.n	8003a36 <HAL_UART_Transmit+0xaa>
 8003a24:	68fb      	ldr	r3, [r7, #12]
 8003a26:	691b      	ldr	r3, [r3, #16]
 8003a28:	2b00      	cmp	r3, #0
 8003a2a:	d104      	bne.n	8003a36 <HAL_UART_Transmit+0xaa>
    {
      pdata8bits  = NULL;
 8003a2c:	2300      	movs	r3, #0
 8003a2e:	61fb      	str	r3, [r7, #28]
      pdata16bits = (uint16_t *) pData;
 8003a30:	68bb      	ldr	r3, [r7, #8]
 8003a32:	61bb      	str	r3, [r7, #24]
 8003a34:	e003      	b.n	8003a3e <HAL_UART_Transmit+0xb2>
    }
    else
    {
      pdata8bits  = pData;
 8003a36:	68bb      	ldr	r3, [r7, #8]
 8003a38:	61fb      	str	r3, [r7, #28]
      pdata16bits = NULL;
 8003a3a:	2300      	movs	r3, #0
 8003a3c:	61bb      	str	r3, [r7, #24]
    }

    __HAL_UNLOCK(huart);
 8003a3e:	68fb      	ldr	r3, [r7, #12]
 8003a40:	2274      	movs	r2, #116	; 0x74
 8003a42:	2100      	movs	r1, #0
 8003a44:	5499      	strb	r1, [r3, r2]

    while (huart->TxXferCount > 0U)
 8003a46:	e02c      	b.n	8003aa2 <HAL_UART_Transmit+0x116>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 8003a48:	697a      	ldr	r2, [r7, #20]
 8003a4a:	68f8      	ldr	r0, [r7, #12]
 8003a4c:	683b      	ldr	r3, [r7, #0]
 8003a4e:	9300      	str	r3, [sp, #0]
 8003a50:	0013      	movs	r3, r2
 8003a52:	2200      	movs	r2, #0
 8003a54:	2180      	movs	r1, #128	; 0x80
 8003a56:	f000 ff59 	bl	800490c <UART_WaitOnFlagUntilTimeout>
 8003a5a:	1e03      	subs	r3, r0, #0
 8003a5c:	d001      	beq.n	8003a62 <HAL_UART_Transmit+0xd6>
      {
        return HAL_TIMEOUT;
 8003a5e:	2303      	movs	r3, #3
 8003a60:	e038      	b.n	8003ad4 <HAL_UART_Transmit+0x148>
      }
      if (pdata8bits == NULL)
 8003a62:	69fb      	ldr	r3, [r7, #28]
 8003a64:	2b00      	cmp	r3, #0
 8003a66:	d10b      	bne.n	8003a80 <HAL_UART_Transmit+0xf4>
      {
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 8003a68:	69bb      	ldr	r3, [r7, #24]
 8003a6a:	881b      	ldrh	r3, [r3, #0]
 8003a6c:	001a      	movs	r2, r3
 8003a6e:	68fb      	ldr	r3, [r7, #12]
 8003a70:	681b      	ldr	r3, [r3, #0]
 8003a72:	05d2      	lsls	r2, r2, #23
 8003a74:	0dd2      	lsrs	r2, r2, #23
 8003a76:	629a      	str	r2, [r3, #40]	; 0x28
        pdata16bits++;
 8003a78:	69bb      	ldr	r3, [r7, #24]
 8003a7a:	3302      	adds	r3, #2
 8003a7c:	61bb      	str	r3, [r7, #24]
 8003a7e:	e007      	b.n	8003a90 <HAL_UART_Transmit+0x104>
      }
      else
      {
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 8003a80:	69fb      	ldr	r3, [r7, #28]
 8003a82:	781a      	ldrb	r2, [r3, #0]
 8003a84:	68fb      	ldr	r3, [r7, #12]
 8003a86:	681b      	ldr	r3, [r3, #0]
 8003a88:	629a      	str	r2, [r3, #40]	; 0x28
        pdata8bits++;
 8003a8a:	69fb      	ldr	r3, [r7, #28]
 8003a8c:	3301      	adds	r3, #1
 8003a8e:	61fb      	str	r3, [r7, #28]
      }
      huart->TxXferCount--;
 8003a90:	68fb      	ldr	r3, [r7, #12]
 8003a92:	2252      	movs	r2, #82	; 0x52
 8003a94:	5a9b      	ldrh	r3, [r3, r2]
 8003a96:	b29b      	uxth	r3, r3
 8003a98:	3b01      	subs	r3, #1
 8003a9a:	b299      	uxth	r1, r3
 8003a9c:	68fb      	ldr	r3, [r7, #12]
 8003a9e:	2252      	movs	r2, #82	; 0x52
 8003aa0:	5299      	strh	r1, [r3, r2]
    while (huart->TxXferCount > 0U)
 8003aa2:	68fb      	ldr	r3, [r7, #12]
 8003aa4:	2252      	movs	r2, #82	; 0x52
 8003aa6:	5a9b      	ldrh	r3, [r3, r2]
 8003aa8:	b29b      	uxth	r3, r3
 8003aaa:	2b00      	cmp	r3, #0
 8003aac:	d1cc      	bne.n	8003a48 <HAL_UART_Transmit+0xbc>
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 8003aae:	697a      	ldr	r2, [r7, #20]
 8003ab0:	68f8      	ldr	r0, [r7, #12]
 8003ab2:	683b      	ldr	r3, [r7, #0]
 8003ab4:	9300      	str	r3, [sp, #0]
 8003ab6:	0013      	movs	r3, r2
 8003ab8:	2200      	movs	r2, #0
 8003aba:	2140      	movs	r1, #64	; 0x40
 8003abc:	f000 ff26 	bl	800490c <UART_WaitOnFlagUntilTimeout>
 8003ac0:	1e03      	subs	r3, r0, #0
 8003ac2:	d001      	beq.n	8003ac8 <HAL_UART_Transmit+0x13c>
    {
      return HAL_TIMEOUT;
 8003ac4:	2303      	movs	r3, #3
 8003ac6:	e005      	b.n	8003ad4 <HAL_UART_Transmit+0x148>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
 8003ac8:	68fb      	ldr	r3, [r7, #12]
 8003aca:	2220      	movs	r2, #32
 8003acc:	679a      	str	r2, [r3, #120]	; 0x78

    return HAL_OK;
 8003ace:	2300      	movs	r3, #0
 8003ad0:	e000      	b.n	8003ad4 <HAL_UART_Transmit+0x148>
  }
  else
  {
    return HAL_BUSY;
 8003ad2:	2302      	movs	r3, #2
  }
}
 8003ad4:	0018      	movs	r0, r3
 8003ad6:	46bd      	mov	sp, r7
 8003ad8:	b008      	add	sp, #32
 8003ada:	bd80      	pop	{r7, pc}

08003adc <HAL_UART_Receive_IT>:
  * @param pData Pointer to data buffer (u8 or u16 data elements).
  * @param Size  Amount of data elements (u8 or u16) to be received.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 8003adc:	b580      	push	{r7, lr}
 8003ade:	b088      	sub	sp, #32
 8003ae0:	af00      	add	r7, sp, #0
 8003ae2:	60f8      	str	r0, [r7, #12]
 8003ae4:	60b9      	str	r1, [r7, #8]
 8003ae6:	1dbb      	adds	r3, r7, #6
 8003ae8:	801a      	strh	r2, [r3, #0]
  /* Check that a Rx process is not already ongoing */
  if (huart->RxState == HAL_UART_STATE_READY)
 8003aea:	68fb      	ldr	r3, [r7, #12]
 8003aec:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8003aee:	2b20      	cmp	r3, #32
 8003af0:	d155      	bne.n	8003b9e <HAL_UART_Receive_IT+0xc2>
  {
    if ((pData == NULL) || (Size == 0U))
 8003af2:	68bb      	ldr	r3, [r7, #8]
 8003af4:	2b00      	cmp	r3, #0
 8003af6:	d003      	beq.n	8003b00 <HAL_UART_Receive_IT+0x24>
 8003af8:	1dbb      	adds	r3, r7, #6
 8003afa:	881b      	ldrh	r3, [r3, #0]
 8003afc:	2b00      	cmp	r3, #0
 8003afe:	d101      	bne.n	8003b04 <HAL_UART_Receive_IT+0x28>
    {
      return HAL_ERROR;
 8003b00:	2301      	movs	r3, #1
 8003b02:	e04d      	b.n	8003ba0 <HAL_UART_Receive_IT+0xc4>
    }

    /* In case of 9bits/No Parity transfer, pData buffer provided as input parameter
       should be aligned on a u16 frontier, as data to be received from RDR will be
       handled through a u16 cast. */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8003b04:	68fb      	ldr	r3, [r7, #12]
 8003b06:	689a      	ldr	r2, [r3, #8]
 8003b08:	2380      	movs	r3, #128	; 0x80
 8003b0a:	015b      	lsls	r3, r3, #5
 8003b0c:	429a      	cmp	r2, r3
 8003b0e:	d109      	bne.n	8003b24 <HAL_UART_Receive_IT+0x48>
 8003b10:	68fb      	ldr	r3, [r7, #12]
 8003b12:	691b      	ldr	r3, [r3, #16]
 8003b14:	2b00      	cmp	r3, #0
 8003b16:	d105      	bne.n	8003b24 <HAL_UART_Receive_IT+0x48>
    {
      if ((((uint32_t)pData) & 1U) != 0U)
 8003b18:	68bb      	ldr	r3, [r7, #8]
 8003b1a:	2201      	movs	r2, #1
 8003b1c:	4013      	ands	r3, r2
 8003b1e:	d001      	beq.n	8003b24 <HAL_UART_Receive_IT+0x48>
      {
        return  HAL_ERROR;
 8003b20:	2301      	movs	r3, #1
 8003b22:	e03d      	b.n	8003ba0 <HAL_UART_Receive_IT+0xc4>
      }
    }

    __HAL_LOCK(huart);
 8003b24:	68fb      	ldr	r3, [r7, #12]
 8003b26:	2274      	movs	r2, #116	; 0x74
 8003b28:	5c9b      	ldrb	r3, [r3, r2]
 8003b2a:	2b01      	cmp	r3, #1
 8003b2c:	d101      	bne.n	8003b32 <HAL_UART_Receive_IT+0x56>
 8003b2e:	2302      	movs	r3, #2
 8003b30:	e036      	b.n	8003ba0 <HAL_UART_Receive_IT+0xc4>
 8003b32:	68fb      	ldr	r3, [r7, #12]
 8003b34:	2274      	movs	r2, #116	; 0x74
 8003b36:	2101      	movs	r1, #1
 8003b38:	5499      	strb	r1, [r3, r2]

    /* Set Reception type to Standard reception */
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8003b3a:	68fb      	ldr	r3, [r7, #12]
 8003b3c:	2200      	movs	r2, #0
 8003b3e:	661a      	str	r2, [r3, #96]	; 0x60

    if (!(IS_LPUART_INSTANCE(huart->Instance)))
 8003b40:	68fb      	ldr	r3, [r7, #12]
 8003b42:	681b      	ldr	r3, [r3, #0]
 8003b44:	4a18      	ldr	r2, [pc, #96]	; (8003ba8 <HAL_UART_Receive_IT+0xcc>)
 8003b46:	4293      	cmp	r3, r2
 8003b48:	d020      	beq.n	8003b8c <HAL_UART_Receive_IT+0xb0>
    {
      /* Check that USART RTOEN bit is set */
      if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 8003b4a:	68fb      	ldr	r3, [r7, #12]
 8003b4c:	681b      	ldr	r3, [r3, #0]
 8003b4e:	685a      	ldr	r2, [r3, #4]
 8003b50:	2380      	movs	r3, #128	; 0x80
 8003b52:	041b      	lsls	r3, r3, #16
 8003b54:	4013      	ands	r3, r2
 8003b56:	d019      	beq.n	8003b8c <HAL_UART_Receive_IT+0xb0>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8003b58:	f3ef 8310 	mrs	r3, PRIMASK
 8003b5c:	613b      	str	r3, [r7, #16]
  return(result);
 8003b5e:	693b      	ldr	r3, [r7, #16]
      {
        /* Enable the UART Receiver Timeout Interrupt */
        ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 8003b60:	61fb      	str	r3, [r7, #28]
 8003b62:	2301      	movs	r3, #1
 8003b64:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8003b66:	697b      	ldr	r3, [r7, #20]
 8003b68:	f383 8810 	msr	PRIMASK, r3
}
 8003b6c:	46c0      	nop			; (mov r8, r8)
 8003b6e:	68fb      	ldr	r3, [r7, #12]
 8003b70:	681b      	ldr	r3, [r3, #0]
 8003b72:	681a      	ldr	r2, [r3, #0]
 8003b74:	68fb      	ldr	r3, [r7, #12]
 8003b76:	681b      	ldr	r3, [r3, #0]
 8003b78:	2180      	movs	r1, #128	; 0x80
 8003b7a:	04c9      	lsls	r1, r1, #19
 8003b7c:	430a      	orrs	r2, r1
 8003b7e:	601a      	str	r2, [r3, #0]
 8003b80:	69fb      	ldr	r3, [r7, #28]
 8003b82:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8003b84:	69bb      	ldr	r3, [r7, #24]
 8003b86:	f383 8810 	msr	PRIMASK, r3
}
 8003b8a:	46c0      	nop			; (mov r8, r8)
      }
    }

    return (UART_Start_Receive_IT(huart, pData, Size));
 8003b8c:	1dbb      	adds	r3, r7, #6
 8003b8e:	881a      	ldrh	r2, [r3, #0]
 8003b90:	68b9      	ldr	r1, [r7, #8]
 8003b92:	68fb      	ldr	r3, [r7, #12]
 8003b94:	0018      	movs	r0, r3
 8003b96:	f000 ff7d 	bl	8004a94 <UART_Start_Receive_IT>
 8003b9a:	0003      	movs	r3, r0
 8003b9c:	e000      	b.n	8003ba0 <HAL_UART_Receive_IT+0xc4>
  }
  else
  {
    return HAL_BUSY;
 8003b9e:	2302      	movs	r3, #2
  }
}
 8003ba0:	0018      	movs	r0, r3
 8003ba2:	46bd      	mov	sp, r7
 8003ba4:	b008      	add	sp, #32
 8003ba6:	bd80      	pop	{r7, pc}
 8003ba8:	40004800 	.word	0x40004800

08003bac <HAL_UART_IRQHandler>:
  * @brief Handle UART interrupt request.
  * @param huart UART handle.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
 8003bac:	b590      	push	{r4, r7, lr}
 8003bae:	b0ab      	sub	sp, #172	; 0xac
 8003bb0:	af00      	add	r7, sp, #0
 8003bb2:	6078      	str	r0, [r7, #4]
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 8003bb4:	687b      	ldr	r3, [r7, #4]
 8003bb6:	681b      	ldr	r3, [r3, #0]
 8003bb8:	69db      	ldr	r3, [r3, #28]
 8003bba:	22a4      	movs	r2, #164	; 0xa4
 8003bbc:	18b9      	adds	r1, r7, r2
 8003bbe:	600b      	str	r3, [r1, #0]
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 8003bc0:	687b      	ldr	r3, [r7, #4]
 8003bc2:	681b      	ldr	r3, [r3, #0]
 8003bc4:	681b      	ldr	r3, [r3, #0]
 8003bc6:	20a0      	movs	r0, #160	; 0xa0
 8003bc8:	1839      	adds	r1, r7, r0
 8003bca:	600b      	str	r3, [r1, #0]
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 8003bcc:	687b      	ldr	r3, [r7, #4]
 8003bce:	681b      	ldr	r3, [r3, #0]
 8003bd0:	689b      	ldr	r3, [r3, #8]
 8003bd2:	219c      	movs	r1, #156	; 0x9c
 8003bd4:	1879      	adds	r1, r7, r1
 8003bd6:	600b      	str	r3, [r1, #0]

  uint32_t errorflags;
  uint32_t errorcode;

  /* If no error occurs */
  errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE | USART_ISR_RTOF));
 8003bd8:	0011      	movs	r1, r2
 8003bda:	18bb      	adds	r3, r7, r2
 8003bdc:	681b      	ldr	r3, [r3, #0]
 8003bde:	4a99      	ldr	r2, [pc, #612]	; (8003e44 <HAL_UART_IRQHandler+0x298>)
 8003be0:	4013      	ands	r3, r2
 8003be2:	2298      	movs	r2, #152	; 0x98
 8003be4:	18bc      	adds	r4, r7, r2
 8003be6:	6023      	str	r3, [r4, #0]
  if (errorflags == 0U)
 8003be8:	18bb      	adds	r3, r7, r2
 8003bea:	681b      	ldr	r3, [r3, #0]
 8003bec:	2b00      	cmp	r3, #0
 8003bee:	d114      	bne.n	8003c1a <HAL_UART_IRQHandler+0x6e>
  {
    /* UART in mode Receiver ---------------------------------------------------*/
    if (((isrflags & USART_ISR_RXNE) != 0U)
 8003bf0:	187b      	adds	r3, r7, r1
 8003bf2:	681b      	ldr	r3, [r3, #0]
 8003bf4:	2220      	movs	r2, #32
 8003bf6:	4013      	ands	r3, r2
 8003bf8:	d00f      	beq.n	8003c1a <HAL_UART_IRQHandler+0x6e>
        && ((cr1its & USART_CR1_RXNEIE) != 0U))
 8003bfa:	183b      	adds	r3, r7, r0
 8003bfc:	681b      	ldr	r3, [r3, #0]
 8003bfe:	2220      	movs	r2, #32
 8003c00:	4013      	ands	r3, r2
 8003c02:	d00a      	beq.n	8003c1a <HAL_UART_IRQHandler+0x6e>
    {
      if (huart->RxISR != NULL)
 8003c04:	687b      	ldr	r3, [r7, #4]
 8003c06:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8003c08:	2b00      	cmp	r3, #0
 8003c0a:	d100      	bne.n	8003c0e <HAL_UART_IRQHandler+0x62>
 8003c0c:	e298      	b.n	8004140 <HAL_UART_IRQHandler+0x594>
      {
        huart->RxISR(huart);
 8003c0e:	687b      	ldr	r3, [r7, #4]
 8003c10:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8003c12:	687a      	ldr	r2, [r7, #4]
 8003c14:	0010      	movs	r0, r2
 8003c16:	4798      	blx	r3
      }
      return;
 8003c18:	e292      	b.n	8004140 <HAL_UART_IRQHandler+0x594>
    }
  }

  /* If some errors occur */
  if ((errorflags != 0U)
 8003c1a:	2398      	movs	r3, #152	; 0x98
 8003c1c:	18fb      	adds	r3, r7, r3
 8003c1e:	681b      	ldr	r3, [r3, #0]
 8003c20:	2b00      	cmp	r3, #0
 8003c22:	d100      	bne.n	8003c26 <HAL_UART_IRQHandler+0x7a>
 8003c24:	e114      	b.n	8003e50 <HAL_UART_IRQHandler+0x2a4>
      && (((cr3its & USART_CR3_EIE) != 0U)
 8003c26:	239c      	movs	r3, #156	; 0x9c
 8003c28:	18fb      	adds	r3, r7, r3
 8003c2a:	681b      	ldr	r3, [r3, #0]
 8003c2c:	2201      	movs	r2, #1
 8003c2e:	4013      	ands	r3, r2
 8003c30:	d106      	bne.n	8003c40 <HAL_UART_IRQHandler+0x94>
          || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U)))
 8003c32:	23a0      	movs	r3, #160	; 0xa0
 8003c34:	18fb      	adds	r3, r7, r3
 8003c36:	681b      	ldr	r3, [r3, #0]
 8003c38:	4a83      	ldr	r2, [pc, #524]	; (8003e48 <HAL_UART_IRQHandler+0x29c>)
 8003c3a:	4013      	ands	r3, r2
 8003c3c:	d100      	bne.n	8003c40 <HAL_UART_IRQHandler+0x94>
 8003c3e:	e107      	b.n	8003e50 <HAL_UART_IRQHandler+0x2a4>
  {
    /* UART parity error interrupt occurred -------------------------------------*/
    if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 8003c40:	23a4      	movs	r3, #164	; 0xa4
 8003c42:	18fb      	adds	r3, r7, r3
 8003c44:	681b      	ldr	r3, [r3, #0]
 8003c46:	2201      	movs	r2, #1
 8003c48:	4013      	ands	r3, r2
 8003c4a:	d012      	beq.n	8003c72 <HAL_UART_IRQHandler+0xc6>
 8003c4c:	23a0      	movs	r3, #160	; 0xa0
 8003c4e:	18fb      	adds	r3, r7, r3
 8003c50:	681a      	ldr	r2, [r3, #0]
 8003c52:	2380      	movs	r3, #128	; 0x80
 8003c54:	005b      	lsls	r3, r3, #1
 8003c56:	4013      	ands	r3, r2
 8003c58:	d00b      	beq.n	8003c72 <HAL_UART_IRQHandler+0xc6>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 8003c5a:	687b      	ldr	r3, [r7, #4]
 8003c5c:	681b      	ldr	r3, [r3, #0]
 8003c5e:	2201      	movs	r2, #1
 8003c60:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_PE;
 8003c62:	687b      	ldr	r3, [r7, #4]
 8003c64:	2280      	movs	r2, #128	; 0x80
 8003c66:	589b      	ldr	r3, [r3, r2]
 8003c68:	2201      	movs	r2, #1
 8003c6a:	431a      	orrs	r2, r3
 8003c6c:	687b      	ldr	r3, [r7, #4]
 8003c6e:	2180      	movs	r1, #128	; 0x80
 8003c70:	505a      	str	r2, [r3, r1]
    }

    /* UART frame error interrupt occurred --------------------------------------*/
    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8003c72:	23a4      	movs	r3, #164	; 0xa4
 8003c74:	18fb      	adds	r3, r7, r3
 8003c76:	681b      	ldr	r3, [r3, #0]
 8003c78:	2202      	movs	r2, #2
 8003c7a:	4013      	ands	r3, r2
 8003c7c:	d011      	beq.n	8003ca2 <HAL_UART_IRQHandler+0xf6>
 8003c7e:	239c      	movs	r3, #156	; 0x9c
 8003c80:	18fb      	adds	r3, r7, r3
 8003c82:	681b      	ldr	r3, [r3, #0]
 8003c84:	2201      	movs	r2, #1
 8003c86:	4013      	ands	r3, r2
 8003c88:	d00b      	beq.n	8003ca2 <HAL_UART_IRQHandler+0xf6>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 8003c8a:	687b      	ldr	r3, [r7, #4]
 8003c8c:	681b      	ldr	r3, [r3, #0]
 8003c8e:	2202      	movs	r2, #2
 8003c90:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_FE;
 8003c92:	687b      	ldr	r3, [r7, #4]
 8003c94:	2280      	movs	r2, #128	; 0x80
 8003c96:	589b      	ldr	r3, [r3, r2]
 8003c98:	2204      	movs	r2, #4
 8003c9a:	431a      	orrs	r2, r3
 8003c9c:	687b      	ldr	r3, [r7, #4]
 8003c9e:	2180      	movs	r1, #128	; 0x80
 8003ca0:	505a      	str	r2, [r3, r1]
    }

    /* UART noise error interrupt occurred --------------------------------------*/
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8003ca2:	23a4      	movs	r3, #164	; 0xa4
 8003ca4:	18fb      	adds	r3, r7, r3
 8003ca6:	681b      	ldr	r3, [r3, #0]
 8003ca8:	2204      	movs	r2, #4
 8003caa:	4013      	ands	r3, r2
 8003cac:	d011      	beq.n	8003cd2 <HAL_UART_IRQHandler+0x126>
 8003cae:	239c      	movs	r3, #156	; 0x9c
 8003cb0:	18fb      	adds	r3, r7, r3
 8003cb2:	681b      	ldr	r3, [r3, #0]
 8003cb4:	2201      	movs	r2, #1
 8003cb6:	4013      	ands	r3, r2
 8003cb8:	d00b      	beq.n	8003cd2 <HAL_UART_IRQHandler+0x126>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 8003cba:	687b      	ldr	r3, [r7, #4]
 8003cbc:	681b      	ldr	r3, [r3, #0]
 8003cbe:	2204      	movs	r2, #4
 8003cc0:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_NE;
 8003cc2:	687b      	ldr	r3, [r7, #4]
 8003cc4:	2280      	movs	r2, #128	; 0x80
 8003cc6:	589b      	ldr	r3, [r3, r2]
 8003cc8:	2202      	movs	r2, #2
 8003cca:	431a      	orrs	r2, r3
 8003ccc:	687b      	ldr	r3, [r7, #4]
 8003cce:	2180      	movs	r1, #128	; 0x80
 8003cd0:	505a      	str	r2, [r3, r1]
    }

    /* UART Over-Run interrupt occurred -----------------------------------------*/
    if (((isrflags & USART_ISR_ORE) != 0U)
 8003cd2:	23a4      	movs	r3, #164	; 0xa4
 8003cd4:	18fb      	adds	r3, r7, r3
 8003cd6:	681b      	ldr	r3, [r3, #0]
 8003cd8:	2208      	movs	r2, #8
 8003cda:	4013      	ands	r3, r2
 8003cdc:	d017      	beq.n	8003d0e <HAL_UART_IRQHandler+0x162>
        && (((cr1its & USART_CR1_RXNEIE) != 0U) ||
 8003cde:	23a0      	movs	r3, #160	; 0xa0
 8003ce0:	18fb      	adds	r3, r7, r3
 8003ce2:	681b      	ldr	r3, [r3, #0]
 8003ce4:	2220      	movs	r2, #32
 8003ce6:	4013      	ands	r3, r2
 8003ce8:	d105      	bne.n	8003cf6 <HAL_UART_IRQHandler+0x14a>
            ((cr3its & USART_CR3_EIE) != 0U)))
 8003cea:	239c      	movs	r3, #156	; 0x9c
 8003cec:	18fb      	adds	r3, r7, r3
 8003cee:	681b      	ldr	r3, [r3, #0]
 8003cf0:	2201      	movs	r2, #1
 8003cf2:	4013      	ands	r3, r2
        && (((cr1its & USART_CR1_RXNEIE) != 0U) ||
 8003cf4:	d00b      	beq.n	8003d0e <HAL_UART_IRQHandler+0x162>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 8003cf6:	687b      	ldr	r3, [r7, #4]
 8003cf8:	681b      	ldr	r3, [r3, #0]
 8003cfa:	2208      	movs	r2, #8
 8003cfc:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 8003cfe:	687b      	ldr	r3, [r7, #4]
 8003d00:	2280      	movs	r2, #128	; 0x80
 8003d02:	589b      	ldr	r3, [r3, r2]
 8003d04:	2208      	movs	r2, #8
 8003d06:	431a      	orrs	r2, r3
 8003d08:	687b      	ldr	r3, [r7, #4]
 8003d0a:	2180      	movs	r1, #128	; 0x80
 8003d0c:	505a      	str	r2, [r3, r1]
    }

    /* UART Receiver Timeout interrupt occurred ---------------------------------*/
    if (((isrflags & USART_ISR_RTOF) != 0U) && ((cr1its & USART_CR1_RTOIE) != 0U))
 8003d0e:	23a4      	movs	r3, #164	; 0xa4
 8003d10:	18fb      	adds	r3, r7, r3
 8003d12:	681a      	ldr	r2, [r3, #0]
 8003d14:	2380      	movs	r3, #128	; 0x80
 8003d16:	011b      	lsls	r3, r3, #4
 8003d18:	4013      	ands	r3, r2
 8003d1a:	d013      	beq.n	8003d44 <HAL_UART_IRQHandler+0x198>
 8003d1c:	23a0      	movs	r3, #160	; 0xa0
 8003d1e:	18fb      	adds	r3, r7, r3
 8003d20:	681a      	ldr	r2, [r3, #0]
 8003d22:	2380      	movs	r3, #128	; 0x80
 8003d24:	04db      	lsls	r3, r3, #19
 8003d26:	4013      	ands	r3, r2
 8003d28:	d00c      	beq.n	8003d44 <HAL_UART_IRQHandler+0x198>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 8003d2a:	687b      	ldr	r3, [r7, #4]
 8003d2c:	681b      	ldr	r3, [r3, #0]
 8003d2e:	2280      	movs	r2, #128	; 0x80
 8003d30:	0112      	lsls	r2, r2, #4
 8003d32:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_RTO;
 8003d34:	687b      	ldr	r3, [r7, #4]
 8003d36:	2280      	movs	r2, #128	; 0x80
 8003d38:	589b      	ldr	r3, [r3, r2]
 8003d3a:	2220      	movs	r2, #32
 8003d3c:	431a      	orrs	r2, r3
 8003d3e:	687b      	ldr	r3, [r7, #4]
 8003d40:	2180      	movs	r1, #128	; 0x80
 8003d42:	505a      	str	r2, [r3, r1]
    }

    /* Call UART Error Call back function if need be ----------------------------*/
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 8003d44:	687b      	ldr	r3, [r7, #4]
 8003d46:	2280      	movs	r2, #128	; 0x80
 8003d48:	589b      	ldr	r3, [r3, r2]
 8003d4a:	2b00      	cmp	r3, #0
 8003d4c:	d100      	bne.n	8003d50 <HAL_UART_IRQHandler+0x1a4>
 8003d4e:	e1f9      	b.n	8004144 <HAL_UART_IRQHandler+0x598>
    {
      /* UART in mode Receiver --------------------------------------------------*/
      if (((isrflags & USART_ISR_RXNE) != 0U)
 8003d50:	23a4      	movs	r3, #164	; 0xa4
 8003d52:	18fb      	adds	r3, r7, r3
 8003d54:	681b      	ldr	r3, [r3, #0]
 8003d56:	2220      	movs	r2, #32
 8003d58:	4013      	ands	r3, r2
 8003d5a:	d00e      	beq.n	8003d7a <HAL_UART_IRQHandler+0x1ce>
          && ((cr1its & USART_CR1_RXNEIE) != 0U))
 8003d5c:	23a0      	movs	r3, #160	; 0xa0
 8003d5e:	18fb      	adds	r3, r7, r3
 8003d60:	681b      	ldr	r3, [r3, #0]
 8003d62:	2220      	movs	r2, #32
 8003d64:	4013      	ands	r3, r2
 8003d66:	d008      	beq.n	8003d7a <HAL_UART_IRQHandler+0x1ce>
      {
        if (huart->RxISR != NULL)
 8003d68:	687b      	ldr	r3, [r7, #4]
 8003d6a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8003d6c:	2b00      	cmp	r3, #0
 8003d6e:	d004      	beq.n	8003d7a <HAL_UART_IRQHandler+0x1ce>
        {
          huart->RxISR(huart);
 8003d70:	687b      	ldr	r3, [r7, #4]
 8003d72:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8003d74:	687a      	ldr	r2, [r7, #4]
 8003d76:	0010      	movs	r0, r2
 8003d78:	4798      	blx	r3
      /* If Error is to be considered as blocking :
          - Receiver Timeout error in Reception
          - Overrun error in Reception
          - any error occurs in DMA mode reception
      */
      errorcode = huart->ErrorCode;
 8003d7a:	687b      	ldr	r3, [r7, #4]
 8003d7c:	2280      	movs	r2, #128	; 0x80
 8003d7e:	589b      	ldr	r3, [r3, r2]
 8003d80:	2194      	movs	r1, #148	; 0x94
 8003d82:	187a      	adds	r2, r7, r1
 8003d84:	6013      	str	r3, [r2, #0]
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8003d86:	687b      	ldr	r3, [r7, #4]
 8003d88:	681b      	ldr	r3, [r3, #0]
 8003d8a:	689b      	ldr	r3, [r3, #8]
 8003d8c:	2240      	movs	r2, #64	; 0x40
 8003d8e:	4013      	ands	r3, r2
 8003d90:	2b40      	cmp	r3, #64	; 0x40
 8003d92:	d004      	beq.n	8003d9e <HAL_UART_IRQHandler+0x1f2>
          ((errorcode & (HAL_UART_ERROR_RTO | HAL_UART_ERROR_ORE)) != 0U))
 8003d94:	187b      	adds	r3, r7, r1
 8003d96:	681b      	ldr	r3, [r3, #0]
 8003d98:	2228      	movs	r2, #40	; 0x28
 8003d9a:	4013      	ands	r3, r2
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8003d9c:	d047      	beq.n	8003e2e <HAL_UART_IRQHandler+0x282>
      {
        /* Blocking error : transfer is aborted
           Set the UART state ready to be able to start again the process,
           Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
        UART_EndRxTransfer(huart);
 8003d9e:	687b      	ldr	r3, [r7, #4]
 8003da0:	0018      	movs	r0, r3
 8003da2:	f000 ff27 	bl	8004bf4 <UART_EndRxTransfer>

        /* Disable the UART DMA Rx request if enabled */
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8003da6:	687b      	ldr	r3, [r7, #4]
 8003da8:	681b      	ldr	r3, [r3, #0]
 8003daa:	689b      	ldr	r3, [r3, #8]
 8003dac:	2240      	movs	r2, #64	; 0x40
 8003dae:	4013      	ands	r3, r2
 8003db0:	2b40      	cmp	r3, #64	; 0x40
 8003db2:	d137      	bne.n	8003e24 <HAL_UART_IRQHandler+0x278>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8003db4:	f3ef 8310 	mrs	r3, PRIMASK
 8003db8:	663b      	str	r3, [r7, #96]	; 0x60
  return(result);
 8003dba:	6e3b      	ldr	r3, [r7, #96]	; 0x60
        {
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8003dbc:	2090      	movs	r0, #144	; 0x90
 8003dbe:	183a      	adds	r2, r7, r0
 8003dc0:	6013      	str	r3, [r2, #0]
 8003dc2:	2301      	movs	r3, #1
 8003dc4:	667b      	str	r3, [r7, #100]	; 0x64
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8003dc6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8003dc8:	f383 8810 	msr	PRIMASK, r3
}
 8003dcc:	46c0      	nop			; (mov r8, r8)
 8003dce:	687b      	ldr	r3, [r7, #4]
 8003dd0:	681b      	ldr	r3, [r3, #0]
 8003dd2:	689a      	ldr	r2, [r3, #8]
 8003dd4:	687b      	ldr	r3, [r7, #4]
 8003dd6:	681b      	ldr	r3, [r3, #0]
 8003dd8:	2140      	movs	r1, #64	; 0x40
 8003dda:	438a      	bics	r2, r1
 8003ddc:	609a      	str	r2, [r3, #8]
 8003dde:	183b      	adds	r3, r7, r0
 8003de0:	681b      	ldr	r3, [r3, #0]
 8003de2:	66bb      	str	r3, [r7, #104]	; 0x68
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8003de4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8003de6:	f383 8810 	msr	PRIMASK, r3
}
 8003dea:	46c0      	nop			; (mov r8, r8)

          /* Abort the UART DMA Rx channel */
          if (huart->hdmarx != NULL)
 8003dec:	687b      	ldr	r3, [r7, #4]
 8003dee:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003df0:	2b00      	cmp	r3, #0
 8003df2:	d012      	beq.n	8003e1a <HAL_UART_IRQHandler+0x26e>
          {
            /* Set the UART DMA Abort callback :
               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 8003df4:	687b      	ldr	r3, [r7, #4]
 8003df6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003df8:	4a14      	ldr	r2, [pc, #80]	; (8003e4c <HAL_UART_IRQHandler+0x2a0>)
 8003dfa:	639a      	str	r2, [r3, #56]	; 0x38

            /* Abort DMA RX */
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 8003dfc:	687b      	ldr	r3, [r7, #4]
 8003dfe:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003e00:	0018      	movs	r0, r3
 8003e02:	f7fe fca5 	bl	8002750 <HAL_DMA_Abort_IT>
 8003e06:	1e03      	subs	r3, r0, #0
 8003e08:	d01a      	beq.n	8003e40 <HAL_UART_IRQHandler+0x294>
            {
              /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8003e0a:	687b      	ldr	r3, [r7, #4]
 8003e0c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003e0e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8003e10:	687b      	ldr	r3, [r7, #4]
 8003e12:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003e14:	0018      	movs	r0, r3
 8003e16:	4790      	blx	r2
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8003e18:	e012      	b.n	8003e40 <HAL_UART_IRQHandler+0x294>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
            /*Call registered error callback*/
            huart->ErrorCallback(huart);
#else
            /*Call legacy weak error callback*/
            HAL_UART_ErrorCallback(huart);
 8003e1a:	687b      	ldr	r3, [r7, #4]
 8003e1c:	0018      	movs	r0, r3
 8003e1e:	f000 f9a7 	bl	8004170 <HAL_UART_ErrorCallback>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8003e22:	e00d      	b.n	8003e40 <HAL_UART_IRQHandler+0x294>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
          /*Call registered error callback*/
          huart->ErrorCallback(huart);
#else
          /*Call legacy weak error callback*/
          HAL_UART_ErrorCallback(huart);
 8003e24:	687b      	ldr	r3, [r7, #4]
 8003e26:	0018      	movs	r0, r3
 8003e28:	f000 f9a2 	bl	8004170 <HAL_UART_ErrorCallback>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8003e2c:	e008      	b.n	8003e40 <HAL_UART_IRQHandler+0x294>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered error callback*/
        huart->ErrorCallback(huart);
#else
        /*Call legacy weak error callback*/
        HAL_UART_ErrorCallback(huart);
 8003e2e:	687b      	ldr	r3, [r7, #4]
 8003e30:	0018      	movs	r0, r3
 8003e32:	f000 f99d 	bl	8004170 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003e36:	687b      	ldr	r3, [r7, #4]
 8003e38:	2280      	movs	r2, #128	; 0x80
 8003e3a:	2100      	movs	r1, #0
 8003e3c:	5099      	str	r1, [r3, r2]
      }
    }
    return;
 8003e3e:	e181      	b.n	8004144 <HAL_UART_IRQHandler+0x598>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8003e40:	46c0      	nop			; (mov r8, r8)
    return;
 8003e42:	e17f      	b.n	8004144 <HAL_UART_IRQHandler+0x598>
 8003e44:	0000080f 	.word	0x0000080f
 8003e48:	04000120 	.word	0x04000120
 8003e4c:	08004cb9 	.word	0x08004cb9

  } /* End if some error occurs */

  /* Check current reception Mode :
     If Reception till IDLE event has been selected : */
  if ((huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8003e50:	687b      	ldr	r3, [r7, #4]
 8003e52:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8003e54:	2b01      	cmp	r3, #1
 8003e56:	d000      	beq.n	8003e5a <HAL_UART_IRQHandler+0x2ae>
 8003e58:	e133      	b.n	80040c2 <HAL_UART_IRQHandler+0x516>
      && ((isrflags & USART_ISR_IDLE) != 0U)
 8003e5a:	23a4      	movs	r3, #164	; 0xa4
 8003e5c:	18fb      	adds	r3, r7, r3
 8003e5e:	681b      	ldr	r3, [r3, #0]
 8003e60:	2210      	movs	r2, #16
 8003e62:	4013      	ands	r3, r2
 8003e64:	d100      	bne.n	8003e68 <HAL_UART_IRQHandler+0x2bc>
 8003e66:	e12c      	b.n	80040c2 <HAL_UART_IRQHandler+0x516>
      && ((cr1its & USART_ISR_IDLE) != 0U))
 8003e68:	23a0      	movs	r3, #160	; 0xa0
 8003e6a:	18fb      	adds	r3, r7, r3
 8003e6c:	681b      	ldr	r3, [r3, #0]
 8003e6e:	2210      	movs	r2, #16
 8003e70:	4013      	ands	r3, r2
 8003e72:	d100      	bne.n	8003e76 <HAL_UART_IRQHandler+0x2ca>
 8003e74:	e125      	b.n	80040c2 <HAL_UART_IRQHandler+0x516>
  {
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8003e76:	687b      	ldr	r3, [r7, #4]
 8003e78:	681b      	ldr	r3, [r3, #0]
 8003e7a:	2210      	movs	r2, #16
 8003e7c:	621a      	str	r2, [r3, #32]

    /* Check if DMA mode is enabled in UART */
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8003e7e:	687b      	ldr	r3, [r7, #4]
 8003e80:	681b      	ldr	r3, [r3, #0]
 8003e82:	689b      	ldr	r3, [r3, #8]
 8003e84:	2240      	movs	r2, #64	; 0x40
 8003e86:	4013      	ands	r3, r2
 8003e88:	2b40      	cmp	r3, #64	; 0x40
 8003e8a:	d000      	beq.n	8003e8e <HAL_UART_IRQHandler+0x2e2>
 8003e8c:	e09d      	b.n	8003fca <HAL_UART_IRQHandler+0x41e>
    {
      /* DMA mode enabled */
      /* Check received length : If all expected data are received, do nothing,
         (DMA cplt callback will be called).
         Otherwise, if at least one data has already been received, IDLE event is to be notified to user */
      uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);
 8003e8e:	687b      	ldr	r3, [r7, #4]
 8003e90:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003e92:	681b      	ldr	r3, [r3, #0]
 8003e94:	685a      	ldr	r2, [r3, #4]
 8003e96:	217e      	movs	r1, #126	; 0x7e
 8003e98:	187b      	adds	r3, r7, r1
 8003e9a:	801a      	strh	r2, [r3, #0]
      if ((nb_remaining_rx_data > 0U)
 8003e9c:	187b      	adds	r3, r7, r1
 8003e9e:	881b      	ldrh	r3, [r3, #0]
 8003ea0:	2b00      	cmp	r3, #0
 8003ea2:	d100      	bne.n	8003ea6 <HAL_UART_IRQHandler+0x2fa>
 8003ea4:	e150      	b.n	8004148 <HAL_UART_IRQHandler+0x59c>
          && (nb_remaining_rx_data < huart->RxXferSize))
 8003ea6:	687b      	ldr	r3, [r7, #4]
 8003ea8:	2258      	movs	r2, #88	; 0x58
 8003eaa:	5a9b      	ldrh	r3, [r3, r2]
 8003eac:	187a      	adds	r2, r7, r1
 8003eae:	8812      	ldrh	r2, [r2, #0]
 8003eb0:	429a      	cmp	r2, r3
 8003eb2:	d300      	bcc.n	8003eb6 <HAL_UART_IRQHandler+0x30a>
 8003eb4:	e148      	b.n	8004148 <HAL_UART_IRQHandler+0x59c>
      {
        /* Reception is not complete */
        huart->RxXferCount = nb_remaining_rx_data;
 8003eb6:	687b      	ldr	r3, [r7, #4]
 8003eb8:	187a      	adds	r2, r7, r1
 8003eba:	215a      	movs	r1, #90	; 0x5a
 8003ebc:	8812      	ldrh	r2, [r2, #0]
 8003ebe:	525a      	strh	r2, [r3, r1]

        /* In Normal mode, end DMA xfer and HAL UART Rx process*/
        if (HAL_IS_BIT_CLR(huart->hdmarx->Instance->CCR, DMA_CCR_CIRC))
 8003ec0:	687b      	ldr	r3, [r7, #4]
 8003ec2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003ec4:	681b      	ldr	r3, [r3, #0]
 8003ec6:	681b      	ldr	r3, [r3, #0]
 8003ec8:	2220      	movs	r2, #32
 8003eca:	4013      	ands	r3, r2
 8003ecc:	d16e      	bne.n	8003fac <HAL_UART_IRQHandler+0x400>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8003ece:	f3ef 8310 	mrs	r3, PRIMASK
 8003ed2:	633b      	str	r3, [r7, #48]	; 0x30
  return(result);
 8003ed4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
        {
          /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8003ed6:	67bb      	str	r3, [r7, #120]	; 0x78
 8003ed8:	2301      	movs	r3, #1
 8003eda:	637b      	str	r3, [r7, #52]	; 0x34
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8003edc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003ede:	f383 8810 	msr	PRIMASK, r3
}
 8003ee2:	46c0      	nop			; (mov r8, r8)
 8003ee4:	687b      	ldr	r3, [r7, #4]
 8003ee6:	681b      	ldr	r3, [r3, #0]
 8003ee8:	681a      	ldr	r2, [r3, #0]
 8003eea:	687b      	ldr	r3, [r7, #4]
 8003eec:	681b      	ldr	r3, [r3, #0]
 8003eee:	499a      	ldr	r1, [pc, #616]	; (8004158 <HAL_UART_IRQHandler+0x5ac>)
 8003ef0:	400a      	ands	r2, r1
 8003ef2:	601a      	str	r2, [r3, #0]
 8003ef4:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8003ef6:	63bb      	str	r3, [r7, #56]	; 0x38
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8003ef8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8003efa:	f383 8810 	msr	PRIMASK, r3
}
 8003efe:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8003f00:	f3ef 8310 	mrs	r3, PRIMASK
 8003f04:	63fb      	str	r3, [r7, #60]	; 0x3c
  return(result);
 8003f06:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8003f08:	677b      	str	r3, [r7, #116]	; 0x74
 8003f0a:	2301      	movs	r3, #1
 8003f0c:	643b      	str	r3, [r7, #64]	; 0x40
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8003f0e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8003f10:	f383 8810 	msr	PRIMASK, r3
}
 8003f14:	46c0      	nop			; (mov r8, r8)
 8003f16:	687b      	ldr	r3, [r7, #4]
 8003f18:	681b      	ldr	r3, [r3, #0]
 8003f1a:	689a      	ldr	r2, [r3, #8]
 8003f1c:	687b      	ldr	r3, [r7, #4]
 8003f1e:	681b      	ldr	r3, [r3, #0]
 8003f20:	2101      	movs	r1, #1
 8003f22:	438a      	bics	r2, r1
 8003f24:	609a      	str	r2, [r3, #8]
 8003f26:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8003f28:	647b      	str	r3, [r7, #68]	; 0x44
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8003f2a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8003f2c:	f383 8810 	msr	PRIMASK, r3
}
 8003f30:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8003f32:	f3ef 8310 	mrs	r3, PRIMASK
 8003f36:	64bb      	str	r3, [r7, #72]	; 0x48
  return(result);
 8003f38:	6cbb      	ldr	r3, [r7, #72]	; 0x48

          /* Disable the DMA transfer for the receiver request by resetting the DMAR bit
             in the UART CR3 register */
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8003f3a:	673b      	str	r3, [r7, #112]	; 0x70
 8003f3c:	2301      	movs	r3, #1
 8003f3e:	64fb      	str	r3, [r7, #76]	; 0x4c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8003f40:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8003f42:	f383 8810 	msr	PRIMASK, r3
}
 8003f46:	46c0      	nop			; (mov r8, r8)
 8003f48:	687b      	ldr	r3, [r7, #4]
 8003f4a:	681b      	ldr	r3, [r3, #0]
 8003f4c:	689a      	ldr	r2, [r3, #8]
 8003f4e:	687b      	ldr	r3, [r7, #4]
 8003f50:	681b      	ldr	r3, [r3, #0]
 8003f52:	2140      	movs	r1, #64	; 0x40
 8003f54:	438a      	bics	r2, r1
 8003f56:	609a      	str	r2, [r3, #8]
 8003f58:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8003f5a:	653b      	str	r3, [r7, #80]	; 0x50
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8003f5c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8003f5e:	f383 8810 	msr	PRIMASK, r3
}
 8003f62:	46c0      	nop			; (mov r8, r8)

          /* At end of Rx process, restore huart->RxState to Ready */
          huart->RxState = HAL_UART_STATE_READY;
 8003f64:	687b      	ldr	r3, [r7, #4]
 8003f66:	2220      	movs	r2, #32
 8003f68:	67da      	str	r2, [r3, #124]	; 0x7c
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8003f6a:	687b      	ldr	r3, [r7, #4]
 8003f6c:	2200      	movs	r2, #0
 8003f6e:	661a      	str	r2, [r3, #96]	; 0x60
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8003f70:	f3ef 8310 	mrs	r3, PRIMASK
 8003f74:	657b      	str	r3, [r7, #84]	; 0x54
  return(result);
 8003f76:	6d7b      	ldr	r3, [r7, #84]	; 0x54

          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8003f78:	66fb      	str	r3, [r7, #108]	; 0x6c
 8003f7a:	2301      	movs	r3, #1
 8003f7c:	65bb      	str	r3, [r7, #88]	; 0x58
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8003f7e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8003f80:	f383 8810 	msr	PRIMASK, r3
}
 8003f84:	46c0      	nop			; (mov r8, r8)
 8003f86:	687b      	ldr	r3, [r7, #4]
 8003f88:	681b      	ldr	r3, [r3, #0]
 8003f8a:	681a      	ldr	r2, [r3, #0]
 8003f8c:	687b      	ldr	r3, [r7, #4]
 8003f8e:	681b      	ldr	r3, [r3, #0]
 8003f90:	2110      	movs	r1, #16
 8003f92:	438a      	bics	r2, r1
 8003f94:	601a      	str	r2, [r3, #0]
 8003f96:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8003f98:	65fb      	str	r3, [r7, #92]	; 0x5c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8003f9a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8003f9c:	f383 8810 	msr	PRIMASK, r3
}
 8003fa0:	46c0      	nop			; (mov r8, r8)

          /* Last bytes received, so no need as the abort is immediate */
          (void)HAL_DMA_Abort(huart->hdmarx);
 8003fa2:	687b      	ldr	r3, [r7, #4]
 8003fa4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003fa6:	0018      	movs	r0, r3
 8003fa8:	f7fe fb92 	bl	80026d0 <HAL_DMA_Abort>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
 8003fac:	687b      	ldr	r3, [r7, #4]
 8003fae:	2258      	movs	r2, #88	; 0x58
 8003fb0:	5a9a      	ldrh	r2, [r3, r2]
 8003fb2:	687b      	ldr	r3, [r7, #4]
 8003fb4:	215a      	movs	r1, #90	; 0x5a
 8003fb6:	5a5b      	ldrh	r3, [r3, r1]
 8003fb8:	b29b      	uxth	r3, r3
 8003fba:	1ad3      	subs	r3, r2, r3
 8003fbc:	b29a      	uxth	r2, r3
 8003fbe:	687b      	ldr	r3, [r7, #4]
 8003fc0:	0011      	movs	r1, r2
 8003fc2:	0018      	movs	r0, r3
 8003fc4:	f000 f8dc 	bl	8004180 <HAL_UARTEx_RxEventCallback>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
      }
      return;
 8003fc8:	e0be      	b.n	8004148 <HAL_UART_IRQHandler+0x59c>
    else
    {
      /* DMA mode not enabled */
      /* Check received length : If all expected data are received, do nothing.
         Otherwise, if at least one data has already been received, IDLE event is to be notified to user */
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 8003fca:	687b      	ldr	r3, [r7, #4]
 8003fcc:	2258      	movs	r2, #88	; 0x58
 8003fce:	5a99      	ldrh	r1, [r3, r2]
 8003fd0:	687b      	ldr	r3, [r7, #4]
 8003fd2:	225a      	movs	r2, #90	; 0x5a
 8003fd4:	5a9b      	ldrh	r3, [r3, r2]
 8003fd6:	b29a      	uxth	r2, r3
 8003fd8:	208e      	movs	r0, #142	; 0x8e
 8003fda:	183b      	adds	r3, r7, r0
 8003fdc:	1a8a      	subs	r2, r1, r2
 8003fde:	801a      	strh	r2, [r3, #0]
      if ((huart->RxXferCount > 0U)
 8003fe0:	687b      	ldr	r3, [r7, #4]
 8003fe2:	225a      	movs	r2, #90	; 0x5a
 8003fe4:	5a9b      	ldrh	r3, [r3, r2]
 8003fe6:	b29b      	uxth	r3, r3
 8003fe8:	2b00      	cmp	r3, #0
 8003fea:	d100      	bne.n	8003fee <HAL_UART_IRQHandler+0x442>
 8003fec:	e0ae      	b.n	800414c <HAL_UART_IRQHandler+0x5a0>
          && (nb_rx_data > 0U))
 8003fee:	183b      	adds	r3, r7, r0
 8003ff0:	881b      	ldrh	r3, [r3, #0]
 8003ff2:	2b00      	cmp	r3, #0
 8003ff4:	d100      	bne.n	8003ff8 <HAL_UART_IRQHandler+0x44c>
 8003ff6:	e0a9      	b.n	800414c <HAL_UART_IRQHandler+0x5a0>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8003ff8:	f3ef 8310 	mrs	r3, PRIMASK
 8003ffc:	60fb      	str	r3, [r7, #12]
  return(result);
 8003ffe:	68fb      	ldr	r3, [r7, #12]
      {
        /* Disable the UART Parity Error Interrupt and RXNE interrupts */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8004000:	2488      	movs	r4, #136	; 0x88
 8004002:	193a      	adds	r2, r7, r4
 8004004:	6013      	str	r3, [r2, #0]
 8004006:	2301      	movs	r3, #1
 8004008:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800400a:	693b      	ldr	r3, [r7, #16]
 800400c:	f383 8810 	msr	PRIMASK, r3
}
 8004010:	46c0      	nop			; (mov r8, r8)
 8004012:	687b      	ldr	r3, [r7, #4]
 8004014:	681b      	ldr	r3, [r3, #0]
 8004016:	681a      	ldr	r2, [r3, #0]
 8004018:	687b      	ldr	r3, [r7, #4]
 800401a:	681b      	ldr	r3, [r3, #0]
 800401c:	494f      	ldr	r1, [pc, #316]	; (800415c <HAL_UART_IRQHandler+0x5b0>)
 800401e:	400a      	ands	r2, r1
 8004020:	601a      	str	r2, [r3, #0]
 8004022:	193b      	adds	r3, r7, r4
 8004024:	681b      	ldr	r3, [r3, #0]
 8004026:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004028:	697b      	ldr	r3, [r7, #20]
 800402a:	f383 8810 	msr	PRIMASK, r3
}
 800402e:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004030:	f3ef 8310 	mrs	r3, PRIMASK
 8004034:	61bb      	str	r3, [r7, #24]
  return(result);
 8004036:	69bb      	ldr	r3, [r7, #24]

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8004038:	2484      	movs	r4, #132	; 0x84
 800403a:	193a      	adds	r2, r7, r4
 800403c:	6013      	str	r3, [r2, #0]
 800403e:	2301      	movs	r3, #1
 8004040:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004042:	69fb      	ldr	r3, [r7, #28]
 8004044:	f383 8810 	msr	PRIMASK, r3
}
 8004048:	46c0      	nop			; (mov r8, r8)
 800404a:	687b      	ldr	r3, [r7, #4]
 800404c:	681b      	ldr	r3, [r3, #0]
 800404e:	689a      	ldr	r2, [r3, #8]
 8004050:	687b      	ldr	r3, [r7, #4]
 8004052:	681b      	ldr	r3, [r3, #0]
 8004054:	2101      	movs	r1, #1
 8004056:	438a      	bics	r2, r1
 8004058:	609a      	str	r2, [r3, #8]
 800405a:	193b      	adds	r3, r7, r4
 800405c:	681b      	ldr	r3, [r3, #0]
 800405e:	623b      	str	r3, [r7, #32]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004060:	6a3b      	ldr	r3, [r7, #32]
 8004062:	f383 8810 	msr	PRIMASK, r3
}
 8004066:	46c0      	nop			; (mov r8, r8)

        /* Rx process is completed, restore huart->RxState to Ready */
        huart->RxState = HAL_UART_STATE_READY;
 8004068:	687b      	ldr	r3, [r7, #4]
 800406a:	2220      	movs	r2, #32
 800406c:	67da      	str	r2, [r3, #124]	; 0x7c
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800406e:	687b      	ldr	r3, [r7, #4]
 8004070:	2200      	movs	r2, #0
 8004072:	661a      	str	r2, [r3, #96]	; 0x60

        /* Clear RxISR function pointer */
        huart->RxISR = NULL;
 8004074:	687b      	ldr	r3, [r7, #4]
 8004076:	2200      	movs	r2, #0
 8004078:	665a      	str	r2, [r3, #100]	; 0x64
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800407a:	f3ef 8310 	mrs	r3, PRIMASK
 800407e:	627b      	str	r3, [r7, #36]	; 0x24
  return(result);
 8004080:	6a7b      	ldr	r3, [r7, #36]	; 0x24

        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8004082:	2480      	movs	r4, #128	; 0x80
 8004084:	193a      	adds	r2, r7, r4
 8004086:	6013      	str	r3, [r2, #0]
 8004088:	2301      	movs	r3, #1
 800408a:	62bb      	str	r3, [r7, #40]	; 0x28
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800408c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800408e:	f383 8810 	msr	PRIMASK, r3
}
 8004092:	46c0      	nop			; (mov r8, r8)
 8004094:	687b      	ldr	r3, [r7, #4]
 8004096:	681b      	ldr	r3, [r3, #0]
 8004098:	681a      	ldr	r2, [r3, #0]
 800409a:	687b      	ldr	r3, [r7, #4]
 800409c:	681b      	ldr	r3, [r3, #0]
 800409e:	2110      	movs	r1, #16
 80040a0:	438a      	bics	r2, r1
 80040a2:	601a      	str	r2, [r3, #0]
 80040a4:	193b      	adds	r3, r7, r4
 80040a6:	681b      	ldr	r3, [r3, #0]
 80040a8:	62fb      	str	r3, [r7, #44]	; 0x2c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80040aa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80040ac:	f383 8810 	msr	PRIMASK, r3
}
 80040b0:	46c0      	nop			; (mov r8, r8)
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx complete callback*/
        huart->RxEventCallback(huart, nb_rx_data);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, nb_rx_data);
 80040b2:	183b      	adds	r3, r7, r0
 80040b4:	881a      	ldrh	r2, [r3, #0]
 80040b6:	687b      	ldr	r3, [r7, #4]
 80040b8:	0011      	movs	r1, r2
 80040ba:	0018      	movs	r0, r3
 80040bc:	f000 f860 	bl	8004180 <HAL_UARTEx_RxEventCallback>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
      }
      return;
 80040c0:	e044      	b.n	800414c <HAL_UART_IRQHandler+0x5a0>
    }
  }

  /* UART wakeup from Stop mode interrupt occurred ---------------------------*/
  if (((isrflags & USART_ISR_WUF) != 0U) && ((cr3its & USART_CR3_WUFIE) != 0U))
 80040c2:	23a4      	movs	r3, #164	; 0xa4
 80040c4:	18fb      	adds	r3, r7, r3
 80040c6:	681a      	ldr	r2, [r3, #0]
 80040c8:	2380      	movs	r3, #128	; 0x80
 80040ca:	035b      	lsls	r3, r3, #13
 80040cc:	4013      	ands	r3, r2
 80040ce:	d010      	beq.n	80040f2 <HAL_UART_IRQHandler+0x546>
 80040d0:	239c      	movs	r3, #156	; 0x9c
 80040d2:	18fb      	adds	r3, r7, r3
 80040d4:	681a      	ldr	r2, [r3, #0]
 80040d6:	2380      	movs	r3, #128	; 0x80
 80040d8:	03db      	lsls	r3, r3, #15
 80040da:	4013      	ands	r3, r2
 80040dc:	d009      	beq.n	80040f2 <HAL_UART_IRQHandler+0x546>
  {
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
 80040de:	687b      	ldr	r3, [r7, #4]
 80040e0:	681b      	ldr	r3, [r3, #0]
 80040e2:	2280      	movs	r2, #128	; 0x80
 80040e4:	0352      	lsls	r2, r2, #13
 80040e6:	621a      	str	r2, [r3, #32]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    /* Call registered Wakeup Callback */
    huart->WakeupCallback(huart);
#else
    /* Call legacy weak Wakeup Callback */
    HAL_UARTEx_WakeupCallback(huart);
 80040e8:	687b      	ldr	r3, [r7, #4]
 80040ea:	0018      	movs	r0, r3
 80040ec:	f000 ff8e 	bl	800500c <HAL_UARTEx_WakeupCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
    return;
 80040f0:	e02f      	b.n	8004152 <HAL_UART_IRQHandler+0x5a6>
  }

  /* UART in mode Transmitter ------------------------------------------------*/
  if (((isrflags & USART_ISR_TXE) != 0U)
 80040f2:	23a4      	movs	r3, #164	; 0xa4
 80040f4:	18fb      	adds	r3, r7, r3
 80040f6:	681b      	ldr	r3, [r3, #0]
 80040f8:	2280      	movs	r2, #128	; 0x80
 80040fa:	4013      	ands	r3, r2
 80040fc:	d00f      	beq.n	800411e <HAL_UART_IRQHandler+0x572>
      && ((cr1its & USART_CR1_TXEIE) != 0U))
 80040fe:	23a0      	movs	r3, #160	; 0xa0
 8004100:	18fb      	adds	r3, r7, r3
 8004102:	681b      	ldr	r3, [r3, #0]
 8004104:	2280      	movs	r2, #128	; 0x80
 8004106:	4013      	ands	r3, r2
 8004108:	d009      	beq.n	800411e <HAL_UART_IRQHandler+0x572>
  {
    if (huart->TxISR != NULL)
 800410a:	687b      	ldr	r3, [r7, #4]
 800410c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800410e:	2b00      	cmp	r3, #0
 8004110:	d01e      	beq.n	8004150 <HAL_UART_IRQHandler+0x5a4>
    {
      huart->TxISR(huart);
 8004112:	687b      	ldr	r3, [r7, #4]
 8004114:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8004116:	687a      	ldr	r2, [r7, #4]
 8004118:	0010      	movs	r0, r2
 800411a:	4798      	blx	r3
    }
    return;
 800411c:	e018      	b.n	8004150 <HAL_UART_IRQHandler+0x5a4>
  }

  /* UART in mode Transmitter (transmission end) -----------------------------*/
  if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
 800411e:	23a4      	movs	r3, #164	; 0xa4
 8004120:	18fb      	adds	r3, r7, r3
 8004122:	681b      	ldr	r3, [r3, #0]
 8004124:	2240      	movs	r2, #64	; 0x40
 8004126:	4013      	ands	r3, r2
 8004128:	d013      	beq.n	8004152 <HAL_UART_IRQHandler+0x5a6>
 800412a:	23a0      	movs	r3, #160	; 0xa0
 800412c:	18fb      	adds	r3, r7, r3
 800412e:	681b      	ldr	r3, [r3, #0]
 8004130:	2240      	movs	r2, #64	; 0x40
 8004132:	4013      	ands	r3, r2
 8004134:	d00d      	beq.n	8004152 <HAL_UART_IRQHandler+0x5a6>
  {
    UART_EndTransmit_IT(huart);
 8004136:	687b      	ldr	r3, [r7, #4]
 8004138:	0018      	movs	r0, r3
 800413a:	f000 fdd4 	bl	8004ce6 <UART_EndTransmit_IT>
    return;
 800413e:	e008      	b.n	8004152 <HAL_UART_IRQHandler+0x5a6>
      return;
 8004140:	46c0      	nop			; (mov r8, r8)
 8004142:	e006      	b.n	8004152 <HAL_UART_IRQHandler+0x5a6>
    return;
 8004144:	46c0      	nop			; (mov r8, r8)
 8004146:	e004      	b.n	8004152 <HAL_UART_IRQHandler+0x5a6>
      return;
 8004148:	46c0      	nop			; (mov r8, r8)
 800414a:	e002      	b.n	8004152 <HAL_UART_IRQHandler+0x5a6>
      return;
 800414c:	46c0      	nop			; (mov r8, r8)
 800414e:	e000      	b.n	8004152 <HAL_UART_IRQHandler+0x5a6>
    return;
 8004150:	46c0      	nop			; (mov r8, r8)
  }

}
 8004152:	46bd      	mov	sp, r7
 8004154:	b02b      	add	sp, #172	; 0xac
 8004156:	bd90      	pop	{r4, r7, pc}
 8004158:	fffffeff 	.word	0xfffffeff
 800415c:	fffffedf 	.word	0xfffffedf

08004160 <HAL_UART_TxCpltCallback>:
  * @brief Tx Transfer completed callback.
  * @param huart UART handle.
  * @retval None
  */
__weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
 8004160:	b580      	push	{r7, lr}
 8004162:	b082      	sub	sp, #8
 8004164:	af00      	add	r7, sp, #0
 8004166:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_TxCpltCallback can be implemented in the user file.
   */
}
 8004168:	46c0      	nop			; (mov r8, r8)
 800416a:	46bd      	mov	sp, r7
 800416c:	b002      	add	sp, #8
 800416e:	bd80      	pop	{r7, pc}

08004170 <HAL_UART_ErrorCallback>:
  * @brief  UART error callback.
  * @param  huart UART handle.
  * @retval None
  */
__weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
 8004170:	b580      	push	{r7, lr}
 8004172:	b082      	sub	sp, #8
 8004174:	af00      	add	r7, sp, #0
 8004176:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_ErrorCallback can be implemented in the user file.
   */
}
 8004178:	46c0      	nop			; (mov r8, r8)
 800417a:	46bd      	mov	sp, r7
 800417c:	b002      	add	sp, #8
 800417e:	bd80      	pop	{r7, pc}

08004180 <HAL_UARTEx_RxEventCallback>:
  * @param  Size  Number of data available in application reception buffer (indicates a position in
  *               reception buffer until which, data are available)
  * @retval None
  */
__weak void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
{
 8004180:	b580      	push	{r7, lr}
 8004182:	b082      	sub	sp, #8
 8004184:	af00      	add	r7, sp, #0
 8004186:	6078      	str	r0, [r7, #4]
 8004188:	000a      	movs	r2, r1
 800418a:	1cbb      	adds	r3, r7, #2
 800418c:	801a      	strh	r2, [r3, #0]
  UNUSED(Size);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_RxEventCallback can be implemented in the user file.
   */
}
 800418e:	46c0      	nop			; (mov r8, r8)
 8004190:	46bd      	mov	sp, r7
 8004192:	b002      	add	sp, #8
 8004194:	bd80      	pop	{r7, pc}
	...

08004198 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 8004198:	b5b0      	push	{r4, r5, r7, lr}
 800419a:	b08e      	sub	sp, #56	; 0x38
 800419c:	af00      	add	r7, sp, #0
 800419e:	61f8      	str	r0, [r7, #28]
  uint32_t tmpreg;
  uint16_t brrtemp;
  UART_ClockSourceTypeDef clocksource;
  uint32_t usartdiv;
  HAL_StatusTypeDef ret               = HAL_OK;
 80041a0:	231a      	movs	r3, #26
 80041a2:	2218      	movs	r2, #24
 80041a4:	4694      	mov	ip, r2
 80041a6:	44bc      	add	ip, r7
 80041a8:	4463      	add	r3, ip
 80041aa:	2200      	movs	r2, #0
 80041ac:	701a      	strb	r2, [r3, #0]
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80041ae:	69fb      	ldr	r3, [r7, #28]
 80041b0:	689a      	ldr	r2, [r3, #8]
 80041b2:	69fb      	ldr	r3, [r7, #28]
 80041b4:	691b      	ldr	r3, [r3, #16]
 80041b6:	431a      	orrs	r2, r3
 80041b8:	69fb      	ldr	r3, [r7, #28]
 80041ba:	695b      	ldr	r3, [r3, #20]
 80041bc:	431a      	orrs	r2, r3
 80041be:	69fb      	ldr	r3, [r7, #28]
 80041c0:	69db      	ldr	r3, [r3, #28]
 80041c2:	4313      	orrs	r3, r2
 80041c4:	637b      	str	r3, [r7, #52]	; 0x34
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80041c6:	69fb      	ldr	r3, [r7, #28]
 80041c8:	681b      	ldr	r3, [r3, #0]
 80041ca:	681b      	ldr	r3, [r3, #0]
 80041cc:	4ab0      	ldr	r2, [pc, #704]	; (8004490 <UART_SetConfig+0x2f8>)
 80041ce:	4013      	ands	r3, r2
 80041d0:	0019      	movs	r1, r3
 80041d2:	69fb      	ldr	r3, [r7, #28]
 80041d4:	681b      	ldr	r3, [r3, #0]
 80041d6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80041d8:	430a      	orrs	r2, r1
 80041da:	601a      	str	r2, [r3, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80041dc:	69fb      	ldr	r3, [r7, #28]
 80041de:	681b      	ldr	r3, [r3, #0]
 80041e0:	685b      	ldr	r3, [r3, #4]
 80041e2:	4aac      	ldr	r2, [pc, #688]	; (8004494 <UART_SetConfig+0x2fc>)
 80041e4:	4013      	ands	r3, r2
 80041e6:	0019      	movs	r1, r3
 80041e8:	69fb      	ldr	r3, [r7, #28]
 80041ea:	68da      	ldr	r2, [r3, #12]
 80041ec:	69fb      	ldr	r3, [r7, #28]
 80041ee:	681b      	ldr	r3, [r3, #0]
 80041f0:	430a      	orrs	r2, r1
 80041f2:	605a      	str	r2, [r3, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 80041f4:	69fb      	ldr	r3, [r7, #28]
 80041f6:	699b      	ldr	r3, [r3, #24]
 80041f8:	637b      	str	r3, [r7, #52]	; 0x34

  if (!(UART_INSTANCE_LOWPOWER(huart)))
 80041fa:	69fb      	ldr	r3, [r7, #28]
 80041fc:	681b      	ldr	r3, [r3, #0]
 80041fe:	4aa6      	ldr	r2, [pc, #664]	; (8004498 <UART_SetConfig+0x300>)
 8004200:	4293      	cmp	r3, r2
 8004202:	d004      	beq.n	800420e <UART_SetConfig+0x76>
  {
    tmpreg |= huart->Init.OneBitSampling;
 8004204:	69fb      	ldr	r3, [r7, #28]
 8004206:	6a1b      	ldr	r3, [r3, #32]
 8004208:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800420a:	4313      	orrs	r3, r2
 800420c:	637b      	str	r3, [r7, #52]	; 0x34
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 800420e:	69fb      	ldr	r3, [r7, #28]
 8004210:	681b      	ldr	r3, [r3, #0]
 8004212:	689b      	ldr	r3, [r3, #8]
 8004214:	4aa1      	ldr	r2, [pc, #644]	; (800449c <UART_SetConfig+0x304>)
 8004216:	4013      	ands	r3, r2
 8004218:	0019      	movs	r1, r3
 800421a:	69fb      	ldr	r3, [r7, #28]
 800421c:	681b      	ldr	r3, [r3, #0]
 800421e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8004220:	430a      	orrs	r2, r1
 8004222:	609a      	str	r2, [r3, #8]


  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 8004224:	69fb      	ldr	r3, [r7, #28]
 8004226:	681b      	ldr	r3, [r3, #0]
 8004228:	4a9d      	ldr	r2, [pc, #628]	; (80044a0 <UART_SetConfig+0x308>)
 800422a:	4293      	cmp	r3, r2
 800422c:	d136      	bne.n	800429c <UART_SetConfig+0x104>
 800422e:	4b9d      	ldr	r3, [pc, #628]	; (80044a4 <UART_SetConfig+0x30c>)
 8004230:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8004232:	2203      	movs	r2, #3
 8004234:	4013      	ands	r3, r2
 8004236:	2b03      	cmp	r3, #3
 8004238:	d020      	beq.n	800427c <UART_SetConfig+0xe4>
 800423a:	d827      	bhi.n	800428c <UART_SetConfig+0xf4>
 800423c:	2b02      	cmp	r3, #2
 800423e:	d00d      	beq.n	800425c <UART_SetConfig+0xc4>
 8004240:	d824      	bhi.n	800428c <UART_SetConfig+0xf4>
 8004242:	2b00      	cmp	r3, #0
 8004244:	d002      	beq.n	800424c <UART_SetConfig+0xb4>
 8004246:	2b01      	cmp	r3, #1
 8004248:	d010      	beq.n	800426c <UART_SetConfig+0xd4>
 800424a:	e01f      	b.n	800428c <UART_SetConfig+0xf4>
 800424c:	231b      	movs	r3, #27
 800424e:	2218      	movs	r2, #24
 8004250:	4694      	mov	ip, r2
 8004252:	44bc      	add	ip, r7
 8004254:	4463      	add	r3, ip
 8004256:	2201      	movs	r2, #1
 8004258:	701a      	strb	r2, [r3, #0]
 800425a:	e0c5      	b.n	80043e8 <UART_SetConfig+0x250>
 800425c:	231b      	movs	r3, #27
 800425e:	2218      	movs	r2, #24
 8004260:	4694      	mov	ip, r2
 8004262:	44bc      	add	ip, r7
 8004264:	4463      	add	r3, ip
 8004266:	2202      	movs	r2, #2
 8004268:	701a      	strb	r2, [r3, #0]
 800426a:	e0bd      	b.n	80043e8 <UART_SetConfig+0x250>
 800426c:	231b      	movs	r3, #27
 800426e:	2218      	movs	r2, #24
 8004270:	4694      	mov	ip, r2
 8004272:	44bc      	add	ip, r7
 8004274:	4463      	add	r3, ip
 8004276:	2204      	movs	r2, #4
 8004278:	701a      	strb	r2, [r3, #0]
 800427a:	e0b5      	b.n	80043e8 <UART_SetConfig+0x250>
 800427c:	231b      	movs	r3, #27
 800427e:	2218      	movs	r2, #24
 8004280:	4694      	mov	ip, r2
 8004282:	44bc      	add	ip, r7
 8004284:	4463      	add	r3, ip
 8004286:	2208      	movs	r2, #8
 8004288:	701a      	strb	r2, [r3, #0]
 800428a:	e0ad      	b.n	80043e8 <UART_SetConfig+0x250>
 800428c:	231b      	movs	r3, #27
 800428e:	2218      	movs	r2, #24
 8004290:	4694      	mov	ip, r2
 8004292:	44bc      	add	ip, r7
 8004294:	4463      	add	r3, ip
 8004296:	2210      	movs	r2, #16
 8004298:	701a      	strb	r2, [r3, #0]
 800429a:	e0a5      	b.n	80043e8 <UART_SetConfig+0x250>
 800429c:	69fb      	ldr	r3, [r7, #28]
 800429e:	681b      	ldr	r3, [r3, #0]
 80042a0:	4a81      	ldr	r2, [pc, #516]	; (80044a8 <UART_SetConfig+0x310>)
 80042a2:	4293      	cmp	r3, r2
 80042a4:	d136      	bne.n	8004314 <UART_SetConfig+0x17c>
 80042a6:	4b7f      	ldr	r3, [pc, #508]	; (80044a4 <UART_SetConfig+0x30c>)
 80042a8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80042aa:	220c      	movs	r2, #12
 80042ac:	4013      	ands	r3, r2
 80042ae:	2b0c      	cmp	r3, #12
 80042b0:	d020      	beq.n	80042f4 <UART_SetConfig+0x15c>
 80042b2:	d827      	bhi.n	8004304 <UART_SetConfig+0x16c>
 80042b4:	2b08      	cmp	r3, #8
 80042b6:	d00d      	beq.n	80042d4 <UART_SetConfig+0x13c>
 80042b8:	d824      	bhi.n	8004304 <UART_SetConfig+0x16c>
 80042ba:	2b00      	cmp	r3, #0
 80042bc:	d002      	beq.n	80042c4 <UART_SetConfig+0x12c>
 80042be:	2b04      	cmp	r3, #4
 80042c0:	d010      	beq.n	80042e4 <UART_SetConfig+0x14c>
 80042c2:	e01f      	b.n	8004304 <UART_SetConfig+0x16c>
 80042c4:	231b      	movs	r3, #27
 80042c6:	2218      	movs	r2, #24
 80042c8:	4694      	mov	ip, r2
 80042ca:	44bc      	add	ip, r7
 80042cc:	4463      	add	r3, ip
 80042ce:	2200      	movs	r2, #0
 80042d0:	701a      	strb	r2, [r3, #0]
 80042d2:	e089      	b.n	80043e8 <UART_SetConfig+0x250>
 80042d4:	231b      	movs	r3, #27
 80042d6:	2218      	movs	r2, #24
 80042d8:	4694      	mov	ip, r2
 80042da:	44bc      	add	ip, r7
 80042dc:	4463      	add	r3, ip
 80042de:	2202      	movs	r2, #2
 80042e0:	701a      	strb	r2, [r3, #0]
 80042e2:	e081      	b.n	80043e8 <UART_SetConfig+0x250>
 80042e4:	231b      	movs	r3, #27
 80042e6:	2218      	movs	r2, #24
 80042e8:	4694      	mov	ip, r2
 80042ea:	44bc      	add	ip, r7
 80042ec:	4463      	add	r3, ip
 80042ee:	2204      	movs	r2, #4
 80042f0:	701a      	strb	r2, [r3, #0]
 80042f2:	e079      	b.n	80043e8 <UART_SetConfig+0x250>
 80042f4:	231b      	movs	r3, #27
 80042f6:	2218      	movs	r2, #24
 80042f8:	4694      	mov	ip, r2
 80042fa:	44bc      	add	ip, r7
 80042fc:	4463      	add	r3, ip
 80042fe:	2208      	movs	r2, #8
 8004300:	701a      	strb	r2, [r3, #0]
 8004302:	e071      	b.n	80043e8 <UART_SetConfig+0x250>
 8004304:	231b      	movs	r3, #27
 8004306:	2218      	movs	r2, #24
 8004308:	4694      	mov	ip, r2
 800430a:	44bc      	add	ip, r7
 800430c:	4463      	add	r3, ip
 800430e:	2210      	movs	r2, #16
 8004310:	701a      	strb	r2, [r3, #0]
 8004312:	e069      	b.n	80043e8 <UART_SetConfig+0x250>
 8004314:	69fb      	ldr	r3, [r7, #28]
 8004316:	681b      	ldr	r3, [r3, #0]
 8004318:	4a64      	ldr	r2, [pc, #400]	; (80044ac <UART_SetConfig+0x314>)
 800431a:	4293      	cmp	r3, r2
 800431c:	d107      	bne.n	800432e <UART_SetConfig+0x196>
 800431e:	231b      	movs	r3, #27
 8004320:	2218      	movs	r2, #24
 8004322:	4694      	mov	ip, r2
 8004324:	44bc      	add	ip, r7
 8004326:	4463      	add	r3, ip
 8004328:	2200      	movs	r2, #0
 800432a:	701a      	strb	r2, [r3, #0]
 800432c:	e05c      	b.n	80043e8 <UART_SetConfig+0x250>
 800432e:	69fb      	ldr	r3, [r7, #28]
 8004330:	681b      	ldr	r3, [r3, #0]
 8004332:	4a5f      	ldr	r2, [pc, #380]	; (80044b0 <UART_SetConfig+0x318>)
 8004334:	4293      	cmp	r3, r2
 8004336:	d107      	bne.n	8004348 <UART_SetConfig+0x1b0>
 8004338:	231b      	movs	r3, #27
 800433a:	2218      	movs	r2, #24
 800433c:	4694      	mov	ip, r2
 800433e:	44bc      	add	ip, r7
 8004340:	4463      	add	r3, ip
 8004342:	2200      	movs	r2, #0
 8004344:	701a      	strb	r2, [r3, #0]
 8004346:	e04f      	b.n	80043e8 <UART_SetConfig+0x250>
 8004348:	69fb      	ldr	r3, [r7, #28]
 800434a:	681b      	ldr	r3, [r3, #0]
 800434c:	4a52      	ldr	r2, [pc, #328]	; (8004498 <UART_SetConfig+0x300>)
 800434e:	4293      	cmp	r3, r2
 8004350:	d143      	bne.n	80043da <UART_SetConfig+0x242>
 8004352:	4b54      	ldr	r3, [pc, #336]	; (80044a4 <UART_SetConfig+0x30c>)
 8004354:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8004356:	23c0      	movs	r3, #192	; 0xc0
 8004358:	011b      	lsls	r3, r3, #4
 800435a:	4013      	ands	r3, r2
 800435c:	22c0      	movs	r2, #192	; 0xc0
 800435e:	0112      	lsls	r2, r2, #4
 8004360:	4293      	cmp	r3, r2
 8004362:	d02a      	beq.n	80043ba <UART_SetConfig+0x222>
 8004364:	22c0      	movs	r2, #192	; 0xc0
 8004366:	0112      	lsls	r2, r2, #4
 8004368:	4293      	cmp	r3, r2
 800436a:	d82e      	bhi.n	80043ca <UART_SetConfig+0x232>
 800436c:	2280      	movs	r2, #128	; 0x80
 800436e:	0112      	lsls	r2, r2, #4
 8004370:	4293      	cmp	r3, r2
 8004372:	d012      	beq.n	800439a <UART_SetConfig+0x202>
 8004374:	2280      	movs	r2, #128	; 0x80
 8004376:	0112      	lsls	r2, r2, #4
 8004378:	4293      	cmp	r3, r2
 800437a:	d826      	bhi.n	80043ca <UART_SetConfig+0x232>
 800437c:	2b00      	cmp	r3, #0
 800437e:	d004      	beq.n	800438a <UART_SetConfig+0x1f2>
 8004380:	2280      	movs	r2, #128	; 0x80
 8004382:	00d2      	lsls	r2, r2, #3
 8004384:	4293      	cmp	r3, r2
 8004386:	d010      	beq.n	80043aa <UART_SetConfig+0x212>
 8004388:	e01f      	b.n	80043ca <UART_SetConfig+0x232>
 800438a:	231b      	movs	r3, #27
 800438c:	2218      	movs	r2, #24
 800438e:	4694      	mov	ip, r2
 8004390:	44bc      	add	ip, r7
 8004392:	4463      	add	r3, ip
 8004394:	2200      	movs	r2, #0
 8004396:	701a      	strb	r2, [r3, #0]
 8004398:	e026      	b.n	80043e8 <UART_SetConfig+0x250>
 800439a:	231b      	movs	r3, #27
 800439c:	2218      	movs	r2, #24
 800439e:	4694      	mov	ip, r2
 80043a0:	44bc      	add	ip, r7
 80043a2:	4463      	add	r3, ip
 80043a4:	2202      	movs	r2, #2
 80043a6:	701a      	strb	r2, [r3, #0]
 80043a8:	e01e      	b.n	80043e8 <UART_SetConfig+0x250>
 80043aa:	231b      	movs	r3, #27
 80043ac:	2218      	movs	r2, #24
 80043ae:	4694      	mov	ip, r2
 80043b0:	44bc      	add	ip, r7
 80043b2:	4463      	add	r3, ip
 80043b4:	2204      	movs	r2, #4
 80043b6:	701a      	strb	r2, [r3, #0]
 80043b8:	e016      	b.n	80043e8 <UART_SetConfig+0x250>
 80043ba:	231b      	movs	r3, #27
 80043bc:	2218      	movs	r2, #24
 80043be:	4694      	mov	ip, r2
 80043c0:	44bc      	add	ip, r7
 80043c2:	4463      	add	r3, ip
 80043c4:	2208      	movs	r2, #8
 80043c6:	701a      	strb	r2, [r3, #0]
 80043c8:	e00e      	b.n	80043e8 <UART_SetConfig+0x250>
 80043ca:	231b      	movs	r3, #27
 80043cc:	2218      	movs	r2, #24
 80043ce:	4694      	mov	ip, r2
 80043d0:	44bc      	add	ip, r7
 80043d2:	4463      	add	r3, ip
 80043d4:	2210      	movs	r2, #16
 80043d6:	701a      	strb	r2, [r3, #0]
 80043d8:	e006      	b.n	80043e8 <UART_SetConfig+0x250>
 80043da:	231b      	movs	r3, #27
 80043dc:	2218      	movs	r2, #24
 80043de:	4694      	mov	ip, r2
 80043e0:	44bc      	add	ip, r7
 80043e2:	4463      	add	r3, ip
 80043e4:	2210      	movs	r2, #16
 80043e6:	701a      	strb	r2, [r3, #0]

  /* Check LPUART instance */
  if (UART_INSTANCE_LOWPOWER(huart))
 80043e8:	69fb      	ldr	r3, [r7, #28]
 80043ea:	681b      	ldr	r3, [r3, #0]
 80043ec:	4a2a      	ldr	r2, [pc, #168]	; (8004498 <UART_SetConfig+0x300>)
 80043ee:	4293      	cmp	r3, r2
 80043f0:	d000      	beq.n	80043f4 <UART_SetConfig+0x25c>
 80043f2:	e09e      	b.n	8004532 <UART_SetConfig+0x39a>
  {
    /* Retrieve frequency clock */
    switch (clocksource)
 80043f4:	231b      	movs	r3, #27
 80043f6:	2218      	movs	r2, #24
 80043f8:	4694      	mov	ip, r2
 80043fa:	44bc      	add	ip, r7
 80043fc:	4463      	add	r3, ip
 80043fe:	781b      	ldrb	r3, [r3, #0]
 8004400:	2b08      	cmp	r3, #8
 8004402:	d01d      	beq.n	8004440 <UART_SetConfig+0x2a8>
 8004404:	dc20      	bgt.n	8004448 <UART_SetConfig+0x2b0>
 8004406:	2b04      	cmp	r3, #4
 8004408:	d015      	beq.n	8004436 <UART_SetConfig+0x29e>
 800440a:	dc1d      	bgt.n	8004448 <UART_SetConfig+0x2b0>
 800440c:	2b00      	cmp	r3, #0
 800440e:	d002      	beq.n	8004416 <UART_SetConfig+0x27e>
 8004410:	2b02      	cmp	r3, #2
 8004412:	d005      	beq.n	8004420 <UART_SetConfig+0x288>
 8004414:	e018      	b.n	8004448 <UART_SetConfig+0x2b0>
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 8004416:	f7ff f8f3 	bl	8003600 <HAL_RCC_GetPCLK1Freq>
 800441a:	0003      	movs	r3, r0
 800441c:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800441e:	e01d      	b.n	800445c <UART_SetConfig+0x2c4>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8004420:	4b20      	ldr	r3, [pc, #128]	; (80044a4 <UART_SetConfig+0x30c>)
 8004422:	681b      	ldr	r3, [r3, #0]
 8004424:	2210      	movs	r2, #16
 8004426:	4013      	ands	r3, r2
 8004428:	d002      	beq.n	8004430 <UART_SetConfig+0x298>
        {
          pclk = (uint32_t)(HSI_VALUE >> 2U);
 800442a:	4b22      	ldr	r3, [pc, #136]	; (80044b4 <UART_SetConfig+0x31c>)
 800442c:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
 800442e:	e015      	b.n	800445c <UART_SetConfig+0x2c4>
          pclk = (uint32_t) HSI_VALUE;
 8004430:	4b21      	ldr	r3, [pc, #132]	; (80044b8 <UART_SetConfig+0x320>)
 8004432:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004434:	e012      	b.n	800445c <UART_SetConfig+0x2c4>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
 8004436:	f7ff f833 	bl	80034a0 <HAL_RCC_GetSysClockFreq>
 800443a:	0003      	movs	r3, r0
 800443c:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800443e:	e00d      	b.n	800445c <UART_SetConfig+0x2c4>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 8004440:	2380      	movs	r3, #128	; 0x80
 8004442:	021b      	lsls	r3, r3, #8
 8004444:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004446:	e009      	b.n	800445c <UART_SetConfig+0x2c4>
      default:
        pclk = 0U;
 8004448:	2300      	movs	r3, #0
 800444a:	62fb      	str	r3, [r7, #44]	; 0x2c
        ret = HAL_ERROR;
 800444c:	231a      	movs	r3, #26
 800444e:	2218      	movs	r2, #24
 8004450:	4694      	mov	ip, r2
 8004452:	44bc      	add	ip, r7
 8004454:	4463      	add	r3, ip
 8004456:	2201      	movs	r2, #1
 8004458:	701a      	strb	r2, [r3, #0]
        break;
 800445a:	46c0      	nop			; (mov r8, r8)
    }

    /* If proper clock source reported */
    if (pclk != 0U)
 800445c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800445e:	2b00      	cmp	r3, #0
 8004460:	d100      	bne.n	8004464 <UART_SetConfig+0x2cc>
 8004462:	e13c      	b.n	80046de <UART_SetConfig+0x546>
    {
      /* No Prescaler applicable */
      /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ((pclk < (3U * huart->Init.BaudRate)) ||
 8004464:	69fb      	ldr	r3, [r7, #28]
 8004466:	685a      	ldr	r2, [r3, #4]
 8004468:	0013      	movs	r3, r2
 800446a:	005b      	lsls	r3, r3, #1
 800446c:	189b      	adds	r3, r3, r2
 800446e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004470:	429a      	cmp	r2, r3
 8004472:	d305      	bcc.n	8004480 <UART_SetConfig+0x2e8>
          (pclk > (4096U * huart->Init.BaudRate)))
 8004474:	69fb      	ldr	r3, [r7, #28]
 8004476:	685b      	ldr	r3, [r3, #4]
 8004478:	031b      	lsls	r3, r3, #12
      if ((pclk < (3U * huart->Init.BaudRate)) ||
 800447a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800447c:	429a      	cmp	r2, r3
 800447e:	d91d      	bls.n	80044bc <UART_SetConfig+0x324>
      {
        ret = HAL_ERROR;
 8004480:	231a      	movs	r3, #26
 8004482:	2218      	movs	r2, #24
 8004484:	4694      	mov	ip, r2
 8004486:	44bc      	add	ip, r7
 8004488:	4463      	add	r3, ip
 800448a:	2201      	movs	r2, #1
 800448c:	701a      	strb	r2, [r3, #0]
 800448e:	e126      	b.n	80046de <UART_SetConfig+0x546>
 8004490:	efff69f3 	.word	0xefff69f3
 8004494:	ffffcfff 	.word	0xffffcfff
 8004498:	40004800 	.word	0x40004800
 800449c:	fffff4ff 	.word	0xfffff4ff
 80044a0:	40013800 	.word	0x40013800
 80044a4:	40021000 	.word	0x40021000
 80044a8:	40004400 	.word	0x40004400
 80044ac:	40004c00 	.word	0x40004c00
 80044b0:	40005000 	.word	0x40005000
 80044b4:	003d0900 	.word	0x003d0900
 80044b8:	00f42400 	.word	0x00f42400
      }
      else
      {
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate));
 80044bc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80044be:	613b      	str	r3, [r7, #16]
 80044c0:	2300      	movs	r3, #0
 80044c2:	617b      	str	r3, [r7, #20]
 80044c4:	6939      	ldr	r1, [r7, #16]
 80044c6:	697a      	ldr	r2, [r7, #20]
 80044c8:	000b      	movs	r3, r1
 80044ca:	0e1b      	lsrs	r3, r3, #24
 80044cc:	0010      	movs	r0, r2
 80044ce:	0205      	lsls	r5, r0, #8
 80044d0:	431d      	orrs	r5, r3
 80044d2:	000b      	movs	r3, r1
 80044d4:	021c      	lsls	r4, r3, #8
 80044d6:	69fb      	ldr	r3, [r7, #28]
 80044d8:	685b      	ldr	r3, [r3, #4]
 80044da:	085b      	lsrs	r3, r3, #1
 80044dc:	60bb      	str	r3, [r7, #8]
 80044de:	2300      	movs	r3, #0
 80044e0:	60fb      	str	r3, [r7, #12]
 80044e2:	68b8      	ldr	r0, [r7, #8]
 80044e4:	68f9      	ldr	r1, [r7, #12]
 80044e6:	1900      	adds	r0, r0, r4
 80044e8:	4169      	adcs	r1, r5
 80044ea:	69fb      	ldr	r3, [r7, #28]
 80044ec:	685b      	ldr	r3, [r3, #4]
 80044ee:	603b      	str	r3, [r7, #0]
 80044f0:	2300      	movs	r3, #0
 80044f2:	607b      	str	r3, [r7, #4]
 80044f4:	683a      	ldr	r2, [r7, #0]
 80044f6:	687b      	ldr	r3, [r7, #4]
 80044f8:	f7fb feae 	bl	8000258 <__aeabi_uldivmod>
 80044fc:	0002      	movs	r2, r0
 80044fe:	000b      	movs	r3, r1
 8004500:	0013      	movs	r3, r2
 8004502:	62bb      	str	r3, [r7, #40]	; 0x28
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 8004504:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8004506:	23c0      	movs	r3, #192	; 0xc0
 8004508:	009b      	lsls	r3, r3, #2
 800450a:	429a      	cmp	r2, r3
 800450c:	d309      	bcc.n	8004522 <UART_SetConfig+0x38a>
 800450e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8004510:	2380      	movs	r3, #128	; 0x80
 8004512:	035b      	lsls	r3, r3, #13
 8004514:	429a      	cmp	r2, r3
 8004516:	d204      	bcs.n	8004522 <UART_SetConfig+0x38a>
        {
          huart->Instance->BRR = usartdiv;
 8004518:	69fb      	ldr	r3, [r7, #28]
 800451a:	681b      	ldr	r3, [r3, #0]
 800451c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800451e:	60da      	str	r2, [r3, #12]
 8004520:	e0dd      	b.n	80046de <UART_SetConfig+0x546>
        }
        else
        {
          ret = HAL_ERROR;
 8004522:	231a      	movs	r3, #26
 8004524:	2218      	movs	r2, #24
 8004526:	4694      	mov	ip, r2
 8004528:	44bc      	add	ip, r7
 800452a:	4463      	add	r3, ip
 800452c:	2201      	movs	r2, #1
 800452e:	701a      	strb	r2, [r3, #0]
 8004530:	e0d5      	b.n	80046de <UART_SetConfig+0x546>
        }
      } /* if ( (pclk < (3 * huart->Init.BaudRate) ) || (pclk > (4096 * huart->Init.BaudRate) )) */
    } /* if (pclk != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8004532:	69fb      	ldr	r3, [r7, #28]
 8004534:	69da      	ldr	r2, [r3, #28]
 8004536:	2380      	movs	r3, #128	; 0x80
 8004538:	021b      	lsls	r3, r3, #8
 800453a:	429a      	cmp	r2, r3
 800453c:	d000      	beq.n	8004540 <UART_SetConfig+0x3a8>
 800453e:	e074      	b.n	800462a <UART_SetConfig+0x492>
  {
    switch (clocksource)
 8004540:	231b      	movs	r3, #27
 8004542:	2218      	movs	r2, #24
 8004544:	4694      	mov	ip, r2
 8004546:	44bc      	add	ip, r7
 8004548:	4463      	add	r3, ip
 800454a:	781b      	ldrb	r3, [r3, #0]
 800454c:	2b08      	cmp	r3, #8
 800454e:	d822      	bhi.n	8004596 <UART_SetConfig+0x3fe>
 8004550:	009a      	lsls	r2, r3, #2
 8004552:	4b6b      	ldr	r3, [pc, #428]	; (8004700 <UART_SetConfig+0x568>)
 8004554:	18d3      	adds	r3, r2, r3
 8004556:	681b      	ldr	r3, [r3, #0]
 8004558:	469f      	mov	pc, r3
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 800455a:	f7ff f851 	bl	8003600 <HAL_RCC_GetPCLK1Freq>
 800455e:	0003      	movs	r3, r0
 8004560:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004562:	e022      	b.n	80045aa <UART_SetConfig+0x412>
      case UART_CLOCKSOURCE_PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
 8004564:	f7ff f862 	bl	800362c <HAL_RCC_GetPCLK2Freq>
 8004568:	0003      	movs	r3, r0
 800456a:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800456c:	e01d      	b.n	80045aa <UART_SetConfig+0x412>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800456e:	4b65      	ldr	r3, [pc, #404]	; (8004704 <UART_SetConfig+0x56c>)
 8004570:	681b      	ldr	r3, [r3, #0]
 8004572:	2210      	movs	r2, #16
 8004574:	4013      	ands	r3, r2
 8004576:	d002      	beq.n	800457e <UART_SetConfig+0x3e6>
        {
          pclk = (uint32_t)(HSI_VALUE >> 2U);
 8004578:	4b63      	ldr	r3, [pc, #396]	; (8004708 <UART_SetConfig+0x570>)
 800457a:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
 800457c:	e015      	b.n	80045aa <UART_SetConfig+0x412>
          pclk = (uint32_t) HSI_VALUE;
 800457e:	4b63      	ldr	r3, [pc, #396]	; (800470c <UART_SetConfig+0x574>)
 8004580:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004582:	e012      	b.n	80045aa <UART_SetConfig+0x412>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
 8004584:	f7fe ff8c 	bl	80034a0 <HAL_RCC_GetSysClockFreq>
 8004588:	0003      	movs	r3, r0
 800458a:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800458c:	e00d      	b.n	80045aa <UART_SetConfig+0x412>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 800458e:	2380      	movs	r3, #128	; 0x80
 8004590:	021b      	lsls	r3, r3, #8
 8004592:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004594:	e009      	b.n	80045aa <UART_SetConfig+0x412>
      default:
        pclk = 0U;
 8004596:	2300      	movs	r3, #0
 8004598:	62fb      	str	r3, [r7, #44]	; 0x2c
        ret = HAL_ERROR;
 800459a:	231a      	movs	r3, #26
 800459c:	2218      	movs	r2, #24
 800459e:	4694      	mov	ip, r2
 80045a0:	44bc      	add	ip, r7
 80045a2:	4463      	add	r3, ip
 80045a4:	2201      	movs	r2, #1
 80045a6:	701a      	strb	r2, [r3, #0]
        break;
 80045a8:	46c0      	nop			; (mov r8, r8)
    }

    /* USARTDIV must be greater than or equal to 0d16 */
    if (pclk != 0U)
 80045aa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80045ac:	2b00      	cmp	r3, #0
 80045ae:	d100      	bne.n	80045b2 <UART_SetConfig+0x41a>
 80045b0:	e095      	b.n	80046de <UART_SetConfig+0x546>
    {
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate));
 80045b2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80045b4:	005a      	lsls	r2, r3, #1
 80045b6:	69fb      	ldr	r3, [r7, #28]
 80045b8:	685b      	ldr	r3, [r3, #4]
 80045ba:	085b      	lsrs	r3, r3, #1
 80045bc:	18d2      	adds	r2, r2, r3
 80045be:	69fb      	ldr	r3, [r7, #28]
 80045c0:	685b      	ldr	r3, [r3, #4]
 80045c2:	0019      	movs	r1, r3
 80045c4:	0010      	movs	r0, r2
 80045c6:	f7fb fdbb 	bl	8000140 <__udivsi3>
 80045ca:	0003      	movs	r3, r0
 80045cc:	b29b      	uxth	r3, r3
 80045ce:	62bb      	str	r3, [r7, #40]	; 0x28
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 80045d0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80045d2:	2b0f      	cmp	r3, #15
 80045d4:	d921      	bls.n	800461a <UART_SetConfig+0x482>
 80045d6:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80045d8:	2380      	movs	r3, #128	; 0x80
 80045da:	025b      	lsls	r3, r3, #9
 80045dc:	429a      	cmp	r2, r3
 80045de:	d21c      	bcs.n	800461a <UART_SetConfig+0x482>
      {
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 80045e0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80045e2:	b29a      	uxth	r2, r3
 80045e4:	200e      	movs	r0, #14
 80045e6:	2418      	movs	r4, #24
 80045e8:	193b      	adds	r3, r7, r4
 80045ea:	181b      	adds	r3, r3, r0
 80045ec:	210f      	movs	r1, #15
 80045ee:	438a      	bics	r2, r1
 80045f0:	801a      	strh	r2, [r3, #0]
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 80045f2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80045f4:	085b      	lsrs	r3, r3, #1
 80045f6:	b29b      	uxth	r3, r3
 80045f8:	2207      	movs	r2, #7
 80045fa:	4013      	ands	r3, r2
 80045fc:	b299      	uxth	r1, r3
 80045fe:	193b      	adds	r3, r7, r4
 8004600:	181b      	adds	r3, r3, r0
 8004602:	193a      	adds	r2, r7, r4
 8004604:	1812      	adds	r2, r2, r0
 8004606:	8812      	ldrh	r2, [r2, #0]
 8004608:	430a      	orrs	r2, r1
 800460a:	801a      	strh	r2, [r3, #0]
        huart->Instance->BRR = brrtemp;
 800460c:	69fb      	ldr	r3, [r7, #28]
 800460e:	681b      	ldr	r3, [r3, #0]
 8004610:	193a      	adds	r2, r7, r4
 8004612:	1812      	adds	r2, r2, r0
 8004614:	8812      	ldrh	r2, [r2, #0]
 8004616:	60da      	str	r2, [r3, #12]
 8004618:	e061      	b.n	80046de <UART_SetConfig+0x546>
      }
      else
      {
        ret = HAL_ERROR;
 800461a:	231a      	movs	r3, #26
 800461c:	2218      	movs	r2, #24
 800461e:	4694      	mov	ip, r2
 8004620:	44bc      	add	ip, r7
 8004622:	4463      	add	r3, ip
 8004624:	2201      	movs	r2, #1
 8004626:	701a      	strb	r2, [r3, #0]
 8004628:	e059      	b.n	80046de <UART_SetConfig+0x546>
      }
    }
  }
  else
  {
    switch (clocksource)
 800462a:	231b      	movs	r3, #27
 800462c:	2218      	movs	r2, #24
 800462e:	4694      	mov	ip, r2
 8004630:	44bc      	add	ip, r7
 8004632:	4463      	add	r3, ip
 8004634:	781b      	ldrb	r3, [r3, #0]
 8004636:	2b08      	cmp	r3, #8
 8004638:	d822      	bhi.n	8004680 <UART_SetConfig+0x4e8>
 800463a:	009a      	lsls	r2, r3, #2
 800463c:	4b34      	ldr	r3, [pc, #208]	; (8004710 <UART_SetConfig+0x578>)
 800463e:	18d3      	adds	r3, r2, r3
 8004640:	681b      	ldr	r3, [r3, #0]
 8004642:	469f      	mov	pc, r3
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 8004644:	f7fe ffdc 	bl	8003600 <HAL_RCC_GetPCLK1Freq>
 8004648:	0003      	movs	r3, r0
 800464a:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800464c:	e022      	b.n	8004694 <UART_SetConfig+0x4fc>
      case UART_CLOCKSOURCE_PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
 800464e:	f7fe ffed 	bl	800362c <HAL_RCC_GetPCLK2Freq>
 8004652:	0003      	movs	r3, r0
 8004654:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004656:	e01d      	b.n	8004694 <UART_SetConfig+0x4fc>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8004658:	4b2a      	ldr	r3, [pc, #168]	; (8004704 <UART_SetConfig+0x56c>)
 800465a:	681b      	ldr	r3, [r3, #0]
 800465c:	2210      	movs	r2, #16
 800465e:	4013      	ands	r3, r2
 8004660:	d002      	beq.n	8004668 <UART_SetConfig+0x4d0>
        {
          pclk = (uint32_t)(HSI_VALUE >> 2U);
 8004662:	4b29      	ldr	r3, [pc, #164]	; (8004708 <UART_SetConfig+0x570>)
 8004664:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
 8004666:	e015      	b.n	8004694 <UART_SetConfig+0x4fc>
          pclk = (uint32_t) HSI_VALUE;
 8004668:	4b28      	ldr	r3, [pc, #160]	; (800470c <UART_SetConfig+0x574>)
 800466a:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800466c:	e012      	b.n	8004694 <UART_SetConfig+0x4fc>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
 800466e:	f7fe ff17 	bl	80034a0 <HAL_RCC_GetSysClockFreq>
 8004672:	0003      	movs	r3, r0
 8004674:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004676:	e00d      	b.n	8004694 <UART_SetConfig+0x4fc>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 8004678:	2380      	movs	r3, #128	; 0x80
 800467a:	021b      	lsls	r3, r3, #8
 800467c:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800467e:	e009      	b.n	8004694 <UART_SetConfig+0x4fc>
      default:
        pclk = 0U;
 8004680:	2300      	movs	r3, #0
 8004682:	62fb      	str	r3, [r7, #44]	; 0x2c
        ret = HAL_ERROR;
 8004684:	231a      	movs	r3, #26
 8004686:	2218      	movs	r2, #24
 8004688:	4694      	mov	ip, r2
 800468a:	44bc      	add	ip, r7
 800468c:	4463      	add	r3, ip
 800468e:	2201      	movs	r2, #1
 8004690:	701a      	strb	r2, [r3, #0]
        break;
 8004692:	46c0      	nop			; (mov r8, r8)
    }

    if (pclk != 0U)
 8004694:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004696:	2b00      	cmp	r3, #0
 8004698:	d021      	beq.n	80046de <UART_SetConfig+0x546>
    {
      /* USARTDIV must be greater than or equal to 0d16 */
      usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate));
 800469a:	69fb      	ldr	r3, [r7, #28]
 800469c:	685b      	ldr	r3, [r3, #4]
 800469e:	085a      	lsrs	r2, r3, #1
 80046a0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80046a2:	18d2      	adds	r2, r2, r3
 80046a4:	69fb      	ldr	r3, [r7, #28]
 80046a6:	685b      	ldr	r3, [r3, #4]
 80046a8:	0019      	movs	r1, r3
 80046aa:	0010      	movs	r0, r2
 80046ac:	f7fb fd48 	bl	8000140 <__udivsi3>
 80046b0:	0003      	movs	r3, r0
 80046b2:	b29b      	uxth	r3, r3
 80046b4:	62bb      	str	r3, [r7, #40]	; 0x28
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 80046b6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80046b8:	2b0f      	cmp	r3, #15
 80046ba:	d909      	bls.n	80046d0 <UART_SetConfig+0x538>
 80046bc:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80046be:	2380      	movs	r3, #128	; 0x80
 80046c0:	025b      	lsls	r3, r3, #9
 80046c2:	429a      	cmp	r2, r3
 80046c4:	d204      	bcs.n	80046d0 <UART_SetConfig+0x538>
      {
        huart->Instance->BRR = usartdiv;
 80046c6:	69fb      	ldr	r3, [r7, #28]
 80046c8:	681b      	ldr	r3, [r3, #0]
 80046ca:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80046cc:	60da      	str	r2, [r3, #12]
 80046ce:	e006      	b.n	80046de <UART_SetConfig+0x546>
      }
      else
      {
        ret = HAL_ERROR;
 80046d0:	231a      	movs	r3, #26
 80046d2:	2218      	movs	r2, #24
 80046d4:	4694      	mov	ip, r2
 80046d6:	44bc      	add	ip, r7
 80046d8:	4463      	add	r3, ip
 80046da:	2201      	movs	r2, #1
 80046dc:	701a      	strb	r2, [r3, #0]
    }
  }


  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 80046de:	69fb      	ldr	r3, [r7, #28]
 80046e0:	2200      	movs	r2, #0
 80046e2:	665a      	str	r2, [r3, #100]	; 0x64
  huart->TxISR = NULL;
 80046e4:	69fb      	ldr	r3, [r7, #28]
 80046e6:	2200      	movs	r2, #0
 80046e8:	669a      	str	r2, [r3, #104]	; 0x68

  return ret;
 80046ea:	231a      	movs	r3, #26
 80046ec:	2218      	movs	r2, #24
 80046ee:	4694      	mov	ip, r2
 80046f0:	44bc      	add	ip, r7
 80046f2:	4463      	add	r3, ip
 80046f4:	781b      	ldrb	r3, [r3, #0]
}
 80046f6:	0018      	movs	r0, r3
 80046f8:	46bd      	mov	sp, r7
 80046fa:	b00e      	add	sp, #56	; 0x38
 80046fc:	bdb0      	pop	{r4, r5, r7, pc}
 80046fe:	46c0      	nop			; (mov r8, r8)
 8004700:	08023958 	.word	0x08023958
 8004704:	40021000 	.word	0x40021000
 8004708:	003d0900 	.word	0x003d0900
 800470c:	00f42400 	.word	0x00f42400
 8004710:	0802397c 	.word	0x0802397c

08004714 <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
 8004714:	b580      	push	{r7, lr}
 8004716:	b082      	sub	sp, #8
 8004718:	af00      	add	r7, sp, #0
 800471a:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 800471c:	687b      	ldr	r3, [r7, #4]
 800471e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004720:	2201      	movs	r2, #1
 8004722:	4013      	ands	r3, r2
 8004724:	d00b      	beq.n	800473e <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 8004726:	687b      	ldr	r3, [r7, #4]
 8004728:	681b      	ldr	r3, [r3, #0]
 800472a:	685b      	ldr	r3, [r3, #4]
 800472c:	4a4a      	ldr	r2, [pc, #296]	; (8004858 <UART_AdvFeatureConfig+0x144>)
 800472e:	4013      	ands	r3, r2
 8004730:	0019      	movs	r1, r3
 8004732:	687b      	ldr	r3, [r7, #4]
 8004734:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8004736:	687b      	ldr	r3, [r7, #4]
 8004738:	681b      	ldr	r3, [r3, #0]
 800473a:	430a      	orrs	r2, r1
 800473c:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 800473e:	687b      	ldr	r3, [r7, #4]
 8004740:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004742:	2202      	movs	r2, #2
 8004744:	4013      	ands	r3, r2
 8004746:	d00b      	beq.n	8004760 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 8004748:	687b      	ldr	r3, [r7, #4]
 800474a:	681b      	ldr	r3, [r3, #0]
 800474c:	685b      	ldr	r3, [r3, #4]
 800474e:	4a43      	ldr	r2, [pc, #268]	; (800485c <UART_AdvFeatureConfig+0x148>)
 8004750:	4013      	ands	r3, r2
 8004752:	0019      	movs	r1, r3
 8004754:	687b      	ldr	r3, [r7, #4]
 8004756:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8004758:	687b      	ldr	r3, [r7, #4]
 800475a:	681b      	ldr	r3, [r3, #0]
 800475c:	430a      	orrs	r2, r1
 800475e:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 8004760:	687b      	ldr	r3, [r7, #4]
 8004762:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004764:	2204      	movs	r2, #4
 8004766:	4013      	ands	r3, r2
 8004768:	d00b      	beq.n	8004782 <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 800476a:	687b      	ldr	r3, [r7, #4]
 800476c:	681b      	ldr	r3, [r3, #0]
 800476e:	685b      	ldr	r3, [r3, #4]
 8004770:	4a3b      	ldr	r2, [pc, #236]	; (8004860 <UART_AdvFeatureConfig+0x14c>)
 8004772:	4013      	ands	r3, r2
 8004774:	0019      	movs	r1, r3
 8004776:	687b      	ldr	r3, [r7, #4]
 8004778:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800477a:	687b      	ldr	r3, [r7, #4]
 800477c:	681b      	ldr	r3, [r3, #0]
 800477e:	430a      	orrs	r2, r1
 8004780:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 8004782:	687b      	ldr	r3, [r7, #4]
 8004784:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004786:	2208      	movs	r2, #8
 8004788:	4013      	ands	r3, r2
 800478a:	d00b      	beq.n	80047a4 <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 800478c:	687b      	ldr	r3, [r7, #4]
 800478e:	681b      	ldr	r3, [r3, #0]
 8004790:	685b      	ldr	r3, [r3, #4]
 8004792:	4a34      	ldr	r2, [pc, #208]	; (8004864 <UART_AdvFeatureConfig+0x150>)
 8004794:	4013      	ands	r3, r2
 8004796:	0019      	movs	r1, r3
 8004798:	687b      	ldr	r3, [r7, #4]
 800479a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800479c:	687b      	ldr	r3, [r7, #4]
 800479e:	681b      	ldr	r3, [r3, #0]
 80047a0:	430a      	orrs	r2, r1
 80047a2:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 80047a4:	687b      	ldr	r3, [r7, #4]
 80047a6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80047a8:	2210      	movs	r2, #16
 80047aa:	4013      	ands	r3, r2
 80047ac:	d00b      	beq.n	80047c6 <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 80047ae:	687b      	ldr	r3, [r7, #4]
 80047b0:	681b      	ldr	r3, [r3, #0]
 80047b2:	689b      	ldr	r3, [r3, #8]
 80047b4:	4a2c      	ldr	r2, [pc, #176]	; (8004868 <UART_AdvFeatureConfig+0x154>)
 80047b6:	4013      	ands	r3, r2
 80047b8:	0019      	movs	r1, r3
 80047ba:	687b      	ldr	r3, [r7, #4]
 80047bc:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80047be:	687b      	ldr	r3, [r7, #4]
 80047c0:	681b      	ldr	r3, [r3, #0]
 80047c2:	430a      	orrs	r2, r1
 80047c4:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 80047c6:	687b      	ldr	r3, [r7, #4]
 80047c8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80047ca:	2220      	movs	r2, #32
 80047cc:	4013      	ands	r3, r2
 80047ce:	d00b      	beq.n	80047e8 <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 80047d0:	687b      	ldr	r3, [r7, #4]
 80047d2:	681b      	ldr	r3, [r3, #0]
 80047d4:	689b      	ldr	r3, [r3, #8]
 80047d6:	4a25      	ldr	r2, [pc, #148]	; (800486c <UART_AdvFeatureConfig+0x158>)
 80047d8:	4013      	ands	r3, r2
 80047da:	0019      	movs	r1, r3
 80047dc:	687b      	ldr	r3, [r7, #4]
 80047de:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 80047e0:	687b      	ldr	r3, [r7, #4]
 80047e2:	681b      	ldr	r3, [r3, #0]
 80047e4:	430a      	orrs	r2, r1
 80047e6:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 80047e8:	687b      	ldr	r3, [r7, #4]
 80047ea:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80047ec:	2240      	movs	r2, #64	; 0x40
 80047ee:	4013      	ands	r3, r2
 80047f0:	d01d      	beq.n	800482e <UART_AdvFeatureConfig+0x11a>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 80047f2:	687b      	ldr	r3, [r7, #4]
 80047f4:	681b      	ldr	r3, [r3, #0]
 80047f6:	685b      	ldr	r3, [r3, #4]
 80047f8:	4a1d      	ldr	r2, [pc, #116]	; (8004870 <UART_AdvFeatureConfig+0x15c>)
 80047fa:	4013      	ands	r3, r2
 80047fc:	0019      	movs	r1, r3
 80047fe:	687b      	ldr	r3, [r7, #4]
 8004800:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8004802:	687b      	ldr	r3, [r7, #4]
 8004804:	681b      	ldr	r3, [r3, #0]
 8004806:	430a      	orrs	r2, r1
 8004808:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800480a:	687b      	ldr	r3, [r7, #4]
 800480c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800480e:	2380      	movs	r3, #128	; 0x80
 8004810:	035b      	lsls	r3, r3, #13
 8004812:	429a      	cmp	r2, r3
 8004814:	d10b      	bne.n	800482e <UART_AdvFeatureConfig+0x11a>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 8004816:	687b      	ldr	r3, [r7, #4]
 8004818:	681b      	ldr	r3, [r3, #0]
 800481a:	685b      	ldr	r3, [r3, #4]
 800481c:	4a15      	ldr	r2, [pc, #84]	; (8004874 <UART_AdvFeatureConfig+0x160>)
 800481e:	4013      	ands	r3, r2
 8004820:	0019      	movs	r1, r3
 8004822:	687b      	ldr	r3, [r7, #4]
 8004824:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8004826:	687b      	ldr	r3, [r7, #4]
 8004828:	681b      	ldr	r3, [r3, #0]
 800482a:	430a      	orrs	r2, r1
 800482c:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 800482e:	687b      	ldr	r3, [r7, #4]
 8004830:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004832:	2280      	movs	r2, #128	; 0x80
 8004834:	4013      	ands	r3, r2
 8004836:	d00b      	beq.n	8004850 <UART_AdvFeatureConfig+0x13c>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8004838:	687b      	ldr	r3, [r7, #4]
 800483a:	681b      	ldr	r3, [r3, #0]
 800483c:	685b      	ldr	r3, [r3, #4]
 800483e:	4a0e      	ldr	r2, [pc, #56]	; (8004878 <UART_AdvFeatureConfig+0x164>)
 8004840:	4013      	ands	r3, r2
 8004842:	0019      	movs	r1, r3
 8004844:	687b      	ldr	r3, [r7, #4]
 8004846:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8004848:	687b      	ldr	r3, [r7, #4]
 800484a:	681b      	ldr	r3, [r3, #0]
 800484c:	430a      	orrs	r2, r1
 800484e:	605a      	str	r2, [r3, #4]
  }
}
 8004850:	46c0      	nop			; (mov r8, r8)
 8004852:	46bd      	mov	sp, r7
 8004854:	b002      	add	sp, #8
 8004856:	bd80      	pop	{r7, pc}
 8004858:	fffdffff 	.word	0xfffdffff
 800485c:	fffeffff 	.word	0xfffeffff
 8004860:	fffbffff 	.word	0xfffbffff
 8004864:	ffff7fff 	.word	0xffff7fff
 8004868:	ffffefff 	.word	0xffffefff
 800486c:	ffffdfff 	.word	0xffffdfff
 8004870:	ffefffff 	.word	0xffefffff
 8004874:	ff9fffff 	.word	0xff9fffff
 8004878:	fff7ffff 	.word	0xfff7ffff

0800487c <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 800487c:	b580      	push	{r7, lr}
 800487e:	b086      	sub	sp, #24
 8004880:	af02      	add	r7, sp, #8
 8004882:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8004884:	687b      	ldr	r3, [r7, #4]
 8004886:	2280      	movs	r2, #128	; 0x80
 8004888:	2100      	movs	r1, #0
 800488a:	5099      	str	r1, [r3, r2]

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
 800488c:	f7fd fe14 	bl	80024b8 <HAL_GetTick>
 8004890:	0003      	movs	r3, r0
 8004892:	60fb      	str	r3, [r7, #12]

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8004894:	687b      	ldr	r3, [r7, #4]
 8004896:	681b      	ldr	r3, [r3, #0]
 8004898:	681b      	ldr	r3, [r3, #0]
 800489a:	2208      	movs	r2, #8
 800489c:	4013      	ands	r3, r2
 800489e:	2b08      	cmp	r3, #8
 80048a0:	d10c      	bne.n	80048bc <UART_CheckIdleState+0x40>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 80048a2:	68fb      	ldr	r3, [r7, #12]
 80048a4:	2280      	movs	r2, #128	; 0x80
 80048a6:	0391      	lsls	r1, r2, #14
 80048a8:	6878      	ldr	r0, [r7, #4]
 80048aa:	4a17      	ldr	r2, [pc, #92]	; (8004908 <UART_CheckIdleState+0x8c>)
 80048ac:	9200      	str	r2, [sp, #0]
 80048ae:	2200      	movs	r2, #0
 80048b0:	f000 f82c 	bl	800490c <UART_WaitOnFlagUntilTimeout>
 80048b4:	1e03      	subs	r3, r0, #0
 80048b6:	d001      	beq.n	80048bc <UART_CheckIdleState+0x40>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 80048b8:	2303      	movs	r3, #3
 80048ba:	e021      	b.n	8004900 <UART_CheckIdleState+0x84>
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 80048bc:	687b      	ldr	r3, [r7, #4]
 80048be:	681b      	ldr	r3, [r3, #0]
 80048c0:	681b      	ldr	r3, [r3, #0]
 80048c2:	2204      	movs	r2, #4
 80048c4:	4013      	ands	r3, r2
 80048c6:	2b04      	cmp	r3, #4
 80048c8:	d10c      	bne.n	80048e4 <UART_CheckIdleState+0x68>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 80048ca:	68fb      	ldr	r3, [r7, #12]
 80048cc:	2280      	movs	r2, #128	; 0x80
 80048ce:	03d1      	lsls	r1, r2, #15
 80048d0:	6878      	ldr	r0, [r7, #4]
 80048d2:	4a0d      	ldr	r2, [pc, #52]	; (8004908 <UART_CheckIdleState+0x8c>)
 80048d4:	9200      	str	r2, [sp, #0]
 80048d6:	2200      	movs	r2, #0
 80048d8:	f000 f818 	bl	800490c <UART_WaitOnFlagUntilTimeout>
 80048dc:	1e03      	subs	r3, r0, #0
 80048de:	d001      	beq.n	80048e4 <UART_CheckIdleState+0x68>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 80048e0:	2303      	movs	r3, #3
 80048e2:	e00d      	b.n	8004900 <UART_CheckIdleState+0x84>
    }
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
 80048e4:	687b      	ldr	r3, [r7, #4]
 80048e6:	2220      	movs	r2, #32
 80048e8:	679a      	str	r2, [r3, #120]	; 0x78
  huart->RxState = HAL_UART_STATE_READY;
 80048ea:	687b      	ldr	r3, [r7, #4]
 80048ec:	2220      	movs	r2, #32
 80048ee:	67da      	str	r2, [r3, #124]	; 0x7c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80048f0:	687b      	ldr	r3, [r7, #4]
 80048f2:	2200      	movs	r2, #0
 80048f4:	661a      	str	r2, [r3, #96]	; 0x60

  __HAL_UNLOCK(huart);
 80048f6:	687b      	ldr	r3, [r7, #4]
 80048f8:	2274      	movs	r2, #116	; 0x74
 80048fa:	2100      	movs	r1, #0
 80048fc:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 80048fe:	2300      	movs	r3, #0
}
 8004900:	0018      	movs	r0, r3
 8004902:	46bd      	mov	sp, r7
 8004904:	b004      	add	sp, #16
 8004906:	bd80      	pop	{r7, pc}
 8004908:	01ffffff 	.word	0x01ffffff

0800490c <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
 800490c:	b580      	push	{r7, lr}
 800490e:	b094      	sub	sp, #80	; 0x50
 8004910:	af00      	add	r7, sp, #0
 8004912:	60f8      	str	r0, [r7, #12]
 8004914:	60b9      	str	r1, [r7, #8]
 8004916:	603b      	str	r3, [r7, #0]
 8004918:	1dfb      	adds	r3, r7, #7
 800491a:	701a      	strb	r2, [r3, #0]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800491c:	e0a3      	b.n	8004a66 <UART_WaitOnFlagUntilTimeout+0x15a>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800491e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8004920:	3301      	adds	r3, #1
 8004922:	d100      	bne.n	8004926 <UART_WaitOnFlagUntilTimeout+0x1a>
 8004924:	e09f      	b.n	8004a66 <UART_WaitOnFlagUntilTimeout+0x15a>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8004926:	f7fd fdc7 	bl	80024b8 <HAL_GetTick>
 800492a:	0002      	movs	r2, r0
 800492c:	683b      	ldr	r3, [r7, #0]
 800492e:	1ad3      	subs	r3, r2, r3
 8004930:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8004932:	429a      	cmp	r2, r3
 8004934:	d302      	bcc.n	800493c <UART_WaitOnFlagUntilTimeout+0x30>
 8004936:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8004938:	2b00      	cmp	r3, #0
 800493a:	d13d      	bne.n	80049b8 <UART_WaitOnFlagUntilTimeout+0xac>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800493c:	f3ef 8310 	mrs	r3, PRIMASK
 8004940:	62bb      	str	r3, [r7, #40]	; 0x28
  return(result);
 8004942:	6abb      	ldr	r3, [r7, #40]	; 0x28
      {
        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error)
           interrupts for the interrupt process */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 8004944:	647b      	str	r3, [r7, #68]	; 0x44
 8004946:	2301      	movs	r3, #1
 8004948:	62fb      	str	r3, [r7, #44]	; 0x2c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800494a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800494c:	f383 8810 	msr	PRIMASK, r3
}
 8004950:	46c0      	nop			; (mov r8, r8)
 8004952:	68fb      	ldr	r3, [r7, #12]
 8004954:	681b      	ldr	r3, [r3, #0]
 8004956:	681a      	ldr	r2, [r3, #0]
 8004958:	68fb      	ldr	r3, [r7, #12]
 800495a:	681b      	ldr	r3, [r3, #0]
 800495c:	494c      	ldr	r1, [pc, #304]	; (8004a90 <UART_WaitOnFlagUntilTimeout+0x184>)
 800495e:	400a      	ands	r2, r1
 8004960:	601a      	str	r2, [r3, #0]
 8004962:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8004964:	633b      	str	r3, [r7, #48]	; 0x30
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004966:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004968:	f383 8810 	msr	PRIMASK, r3
}
 800496c:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800496e:	f3ef 8310 	mrs	r3, PRIMASK
 8004972:	637b      	str	r3, [r7, #52]	; 0x34
  return(result);
 8004974:	6b7b      	ldr	r3, [r7, #52]	; 0x34
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8004976:	643b      	str	r3, [r7, #64]	; 0x40
 8004978:	2301      	movs	r3, #1
 800497a:	63bb      	str	r3, [r7, #56]	; 0x38
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800497c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800497e:	f383 8810 	msr	PRIMASK, r3
}
 8004982:	46c0      	nop			; (mov r8, r8)
 8004984:	68fb      	ldr	r3, [r7, #12]
 8004986:	681b      	ldr	r3, [r3, #0]
 8004988:	689a      	ldr	r2, [r3, #8]
 800498a:	68fb      	ldr	r3, [r7, #12]
 800498c:	681b      	ldr	r3, [r3, #0]
 800498e:	2101      	movs	r1, #1
 8004990:	438a      	bics	r2, r1
 8004992:	609a      	str	r2, [r3, #8]
 8004994:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8004996:	63fb      	str	r3, [r7, #60]	; 0x3c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004998:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800499a:	f383 8810 	msr	PRIMASK, r3
}
 800499e:	46c0      	nop			; (mov r8, r8)

        huart->gState = HAL_UART_STATE_READY;
 80049a0:	68fb      	ldr	r3, [r7, #12]
 80049a2:	2220      	movs	r2, #32
 80049a4:	679a      	str	r2, [r3, #120]	; 0x78
        huart->RxState = HAL_UART_STATE_READY;
 80049a6:	68fb      	ldr	r3, [r7, #12]
 80049a8:	2220      	movs	r2, #32
 80049aa:	67da      	str	r2, [r3, #124]	; 0x7c

        __HAL_UNLOCK(huart);
 80049ac:	68fb      	ldr	r3, [r7, #12]
 80049ae:	2274      	movs	r2, #116	; 0x74
 80049b0:	2100      	movs	r1, #0
 80049b2:	5499      	strb	r1, [r3, r2]

        return HAL_TIMEOUT;
 80049b4:	2303      	movs	r3, #3
 80049b6:	e067      	b.n	8004a88 <UART_WaitOnFlagUntilTimeout+0x17c>
      }

      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 80049b8:	68fb      	ldr	r3, [r7, #12]
 80049ba:	681b      	ldr	r3, [r3, #0]
 80049bc:	681b      	ldr	r3, [r3, #0]
 80049be:	2204      	movs	r2, #4
 80049c0:	4013      	ands	r3, r2
 80049c2:	d050      	beq.n	8004a66 <UART_WaitOnFlagUntilTimeout+0x15a>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 80049c4:	68fb      	ldr	r3, [r7, #12]
 80049c6:	681b      	ldr	r3, [r3, #0]
 80049c8:	69da      	ldr	r2, [r3, #28]
 80049ca:	2380      	movs	r3, #128	; 0x80
 80049cc:	011b      	lsls	r3, r3, #4
 80049ce:	401a      	ands	r2, r3
 80049d0:	2380      	movs	r3, #128	; 0x80
 80049d2:	011b      	lsls	r3, r3, #4
 80049d4:	429a      	cmp	r2, r3
 80049d6:	d146      	bne.n	8004a66 <UART_WaitOnFlagUntilTimeout+0x15a>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 80049d8:	68fb      	ldr	r3, [r7, #12]
 80049da:	681b      	ldr	r3, [r3, #0]
 80049dc:	2280      	movs	r2, #128	; 0x80
 80049de:	0112      	lsls	r2, r2, #4
 80049e0:	621a      	str	r2, [r3, #32]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80049e2:	f3ef 8310 	mrs	r3, PRIMASK
 80049e6:	613b      	str	r3, [r7, #16]
  return(result);
 80049e8:	693b      	ldr	r3, [r7, #16]

          /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error)
             interrupts for the interrupt process */
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 80049ea:	64fb      	str	r3, [r7, #76]	; 0x4c
 80049ec:	2301      	movs	r3, #1
 80049ee:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80049f0:	697b      	ldr	r3, [r7, #20]
 80049f2:	f383 8810 	msr	PRIMASK, r3
}
 80049f6:	46c0      	nop			; (mov r8, r8)
 80049f8:	68fb      	ldr	r3, [r7, #12]
 80049fa:	681b      	ldr	r3, [r3, #0]
 80049fc:	681a      	ldr	r2, [r3, #0]
 80049fe:	68fb      	ldr	r3, [r7, #12]
 8004a00:	681b      	ldr	r3, [r3, #0]
 8004a02:	4923      	ldr	r1, [pc, #140]	; (8004a90 <UART_WaitOnFlagUntilTimeout+0x184>)
 8004a04:	400a      	ands	r2, r1
 8004a06:	601a      	str	r2, [r3, #0]
 8004a08:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8004a0a:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004a0c:	69bb      	ldr	r3, [r7, #24]
 8004a0e:	f383 8810 	msr	PRIMASK, r3
}
 8004a12:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004a14:	f3ef 8310 	mrs	r3, PRIMASK
 8004a18:	61fb      	str	r3, [r7, #28]
  return(result);
 8004a1a:	69fb      	ldr	r3, [r7, #28]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8004a1c:	64bb      	str	r3, [r7, #72]	; 0x48
 8004a1e:	2301      	movs	r3, #1
 8004a20:	623b      	str	r3, [r7, #32]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004a22:	6a3b      	ldr	r3, [r7, #32]
 8004a24:	f383 8810 	msr	PRIMASK, r3
}
 8004a28:	46c0      	nop			; (mov r8, r8)
 8004a2a:	68fb      	ldr	r3, [r7, #12]
 8004a2c:	681b      	ldr	r3, [r3, #0]
 8004a2e:	689a      	ldr	r2, [r3, #8]
 8004a30:	68fb      	ldr	r3, [r7, #12]
 8004a32:	681b      	ldr	r3, [r3, #0]
 8004a34:	2101      	movs	r1, #1
 8004a36:	438a      	bics	r2, r1
 8004a38:	609a      	str	r2, [r3, #8]
 8004a3a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8004a3c:	627b      	str	r3, [r7, #36]	; 0x24
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004a3e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004a40:	f383 8810 	msr	PRIMASK, r3
}
 8004a44:	46c0      	nop			; (mov r8, r8)

          huart->gState = HAL_UART_STATE_READY;
 8004a46:	68fb      	ldr	r3, [r7, #12]
 8004a48:	2220      	movs	r2, #32
 8004a4a:	679a      	str	r2, [r3, #120]	; 0x78
          huart->RxState = HAL_UART_STATE_READY;
 8004a4c:	68fb      	ldr	r3, [r7, #12]
 8004a4e:	2220      	movs	r2, #32
 8004a50:	67da      	str	r2, [r3, #124]	; 0x7c
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 8004a52:	68fb      	ldr	r3, [r7, #12]
 8004a54:	2280      	movs	r2, #128	; 0x80
 8004a56:	2120      	movs	r1, #32
 8004a58:	5099      	str	r1, [r3, r2]

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 8004a5a:	68fb      	ldr	r3, [r7, #12]
 8004a5c:	2274      	movs	r2, #116	; 0x74
 8004a5e:	2100      	movs	r1, #0
 8004a60:	5499      	strb	r1, [r3, r2]

          return HAL_TIMEOUT;
 8004a62:	2303      	movs	r3, #3
 8004a64:	e010      	b.n	8004a88 <UART_WaitOnFlagUntilTimeout+0x17c>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8004a66:	68fb      	ldr	r3, [r7, #12]
 8004a68:	681b      	ldr	r3, [r3, #0]
 8004a6a:	69db      	ldr	r3, [r3, #28]
 8004a6c:	68ba      	ldr	r2, [r7, #8]
 8004a6e:	4013      	ands	r3, r2
 8004a70:	68ba      	ldr	r2, [r7, #8]
 8004a72:	1ad3      	subs	r3, r2, r3
 8004a74:	425a      	negs	r2, r3
 8004a76:	4153      	adcs	r3, r2
 8004a78:	b2db      	uxtb	r3, r3
 8004a7a:	001a      	movs	r2, r3
 8004a7c:	1dfb      	adds	r3, r7, #7
 8004a7e:	781b      	ldrb	r3, [r3, #0]
 8004a80:	429a      	cmp	r2, r3
 8004a82:	d100      	bne.n	8004a86 <UART_WaitOnFlagUntilTimeout+0x17a>
 8004a84:	e74b      	b.n	800491e <UART_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
 8004a86:	2300      	movs	r3, #0
}
 8004a88:	0018      	movs	r0, r3
 8004a8a:	46bd      	mov	sp, r7
 8004a8c:	b014      	add	sp, #80	; 0x50
 8004a8e:	bd80      	pop	{r7, pc}
 8004a90:	fffffe5f 	.word	0xfffffe5f

08004a94 <UART_Start_Receive_IT>:
  * @param  pData Pointer to data buffer (u8 or u16 data elements).
  * @param  Size  Amount of data elements (u8 or u16) to be received.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_Start_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 8004a94:	b580      	push	{r7, lr}
 8004a96:	b08c      	sub	sp, #48	; 0x30
 8004a98:	af00      	add	r7, sp, #0
 8004a9a:	60f8      	str	r0, [r7, #12]
 8004a9c:	60b9      	str	r1, [r7, #8]
 8004a9e:	1dbb      	adds	r3, r7, #6
 8004aa0:	801a      	strh	r2, [r3, #0]
  huart->pRxBuffPtr  = pData;
 8004aa2:	68fb      	ldr	r3, [r7, #12]
 8004aa4:	68ba      	ldr	r2, [r7, #8]
 8004aa6:	655a      	str	r2, [r3, #84]	; 0x54
  huart->RxXferSize  = Size;
 8004aa8:	68fb      	ldr	r3, [r7, #12]
 8004aaa:	1dba      	adds	r2, r7, #6
 8004aac:	2158      	movs	r1, #88	; 0x58
 8004aae:	8812      	ldrh	r2, [r2, #0]
 8004ab0:	525a      	strh	r2, [r3, r1]
  huart->RxXferCount = Size;
 8004ab2:	68fb      	ldr	r3, [r7, #12]
 8004ab4:	1dba      	adds	r2, r7, #6
 8004ab6:	215a      	movs	r1, #90	; 0x5a
 8004ab8:	8812      	ldrh	r2, [r2, #0]
 8004aba:	525a      	strh	r2, [r3, r1]
  huart->RxISR       = NULL;
 8004abc:	68fb      	ldr	r3, [r7, #12]
 8004abe:	2200      	movs	r2, #0
 8004ac0:	665a      	str	r2, [r3, #100]	; 0x64

  /* Computation of UART mask to apply to RDR register */
  UART_MASK_COMPUTATION(huart);
 8004ac2:	68fb      	ldr	r3, [r7, #12]
 8004ac4:	689a      	ldr	r2, [r3, #8]
 8004ac6:	2380      	movs	r3, #128	; 0x80
 8004ac8:	015b      	lsls	r3, r3, #5
 8004aca:	429a      	cmp	r2, r3
 8004acc:	d10d      	bne.n	8004aea <UART_Start_Receive_IT+0x56>
 8004ace:	68fb      	ldr	r3, [r7, #12]
 8004ad0:	691b      	ldr	r3, [r3, #16]
 8004ad2:	2b00      	cmp	r3, #0
 8004ad4:	d104      	bne.n	8004ae0 <UART_Start_Receive_IT+0x4c>
 8004ad6:	68fb      	ldr	r3, [r7, #12]
 8004ad8:	225c      	movs	r2, #92	; 0x5c
 8004ada:	4943      	ldr	r1, [pc, #268]	; (8004be8 <UART_Start_Receive_IT+0x154>)
 8004adc:	5299      	strh	r1, [r3, r2]
 8004ade:	e02e      	b.n	8004b3e <UART_Start_Receive_IT+0xaa>
 8004ae0:	68fb      	ldr	r3, [r7, #12]
 8004ae2:	225c      	movs	r2, #92	; 0x5c
 8004ae4:	21ff      	movs	r1, #255	; 0xff
 8004ae6:	5299      	strh	r1, [r3, r2]
 8004ae8:	e029      	b.n	8004b3e <UART_Start_Receive_IT+0xaa>
 8004aea:	68fb      	ldr	r3, [r7, #12]
 8004aec:	689b      	ldr	r3, [r3, #8]
 8004aee:	2b00      	cmp	r3, #0
 8004af0:	d10d      	bne.n	8004b0e <UART_Start_Receive_IT+0x7a>
 8004af2:	68fb      	ldr	r3, [r7, #12]
 8004af4:	691b      	ldr	r3, [r3, #16]
 8004af6:	2b00      	cmp	r3, #0
 8004af8:	d104      	bne.n	8004b04 <UART_Start_Receive_IT+0x70>
 8004afa:	68fb      	ldr	r3, [r7, #12]
 8004afc:	225c      	movs	r2, #92	; 0x5c
 8004afe:	21ff      	movs	r1, #255	; 0xff
 8004b00:	5299      	strh	r1, [r3, r2]
 8004b02:	e01c      	b.n	8004b3e <UART_Start_Receive_IT+0xaa>
 8004b04:	68fb      	ldr	r3, [r7, #12]
 8004b06:	225c      	movs	r2, #92	; 0x5c
 8004b08:	217f      	movs	r1, #127	; 0x7f
 8004b0a:	5299      	strh	r1, [r3, r2]
 8004b0c:	e017      	b.n	8004b3e <UART_Start_Receive_IT+0xaa>
 8004b0e:	68fb      	ldr	r3, [r7, #12]
 8004b10:	689a      	ldr	r2, [r3, #8]
 8004b12:	2380      	movs	r3, #128	; 0x80
 8004b14:	055b      	lsls	r3, r3, #21
 8004b16:	429a      	cmp	r2, r3
 8004b18:	d10d      	bne.n	8004b36 <UART_Start_Receive_IT+0xa2>
 8004b1a:	68fb      	ldr	r3, [r7, #12]
 8004b1c:	691b      	ldr	r3, [r3, #16]
 8004b1e:	2b00      	cmp	r3, #0
 8004b20:	d104      	bne.n	8004b2c <UART_Start_Receive_IT+0x98>
 8004b22:	68fb      	ldr	r3, [r7, #12]
 8004b24:	225c      	movs	r2, #92	; 0x5c
 8004b26:	217f      	movs	r1, #127	; 0x7f
 8004b28:	5299      	strh	r1, [r3, r2]
 8004b2a:	e008      	b.n	8004b3e <UART_Start_Receive_IT+0xaa>
 8004b2c:	68fb      	ldr	r3, [r7, #12]
 8004b2e:	225c      	movs	r2, #92	; 0x5c
 8004b30:	213f      	movs	r1, #63	; 0x3f
 8004b32:	5299      	strh	r1, [r3, r2]
 8004b34:	e003      	b.n	8004b3e <UART_Start_Receive_IT+0xaa>
 8004b36:	68fb      	ldr	r3, [r7, #12]
 8004b38:	225c      	movs	r2, #92	; 0x5c
 8004b3a:	2100      	movs	r1, #0
 8004b3c:	5299      	strh	r1, [r3, r2]

  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8004b3e:	68fb      	ldr	r3, [r7, #12]
 8004b40:	2280      	movs	r2, #128	; 0x80
 8004b42:	2100      	movs	r1, #0
 8004b44:	5099      	str	r1, [r3, r2]
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 8004b46:	68fb      	ldr	r3, [r7, #12]
 8004b48:	2222      	movs	r2, #34	; 0x22
 8004b4a:	67da      	str	r2, [r3, #124]	; 0x7c
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004b4c:	f3ef 8310 	mrs	r3, PRIMASK
 8004b50:	61fb      	str	r3, [r7, #28]
  return(result);
 8004b52:	69fb      	ldr	r3, [r7, #28]

  /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8004b54:	62fb      	str	r3, [r7, #44]	; 0x2c
 8004b56:	2301      	movs	r3, #1
 8004b58:	623b      	str	r3, [r7, #32]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004b5a:	6a3b      	ldr	r3, [r7, #32]
 8004b5c:	f383 8810 	msr	PRIMASK, r3
}
 8004b60:	46c0      	nop			; (mov r8, r8)
 8004b62:	68fb      	ldr	r3, [r7, #12]
 8004b64:	681b      	ldr	r3, [r3, #0]
 8004b66:	689a      	ldr	r2, [r3, #8]
 8004b68:	68fb      	ldr	r3, [r7, #12]
 8004b6a:	681b      	ldr	r3, [r3, #0]
 8004b6c:	2101      	movs	r1, #1
 8004b6e:	430a      	orrs	r2, r1
 8004b70:	609a      	str	r2, [r3, #8]
 8004b72:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004b74:	627b      	str	r3, [r7, #36]	; 0x24
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004b76:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004b78:	f383 8810 	msr	PRIMASK, r3
}
 8004b7c:	46c0      	nop			; (mov r8, r8)

  /* Set the Rx ISR function pointer according to the data word length */
  if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8004b7e:	68fb      	ldr	r3, [r7, #12]
 8004b80:	689a      	ldr	r2, [r3, #8]
 8004b82:	2380      	movs	r3, #128	; 0x80
 8004b84:	015b      	lsls	r3, r3, #5
 8004b86:	429a      	cmp	r2, r3
 8004b88:	d107      	bne.n	8004b9a <UART_Start_Receive_IT+0x106>
 8004b8a:	68fb      	ldr	r3, [r7, #12]
 8004b8c:	691b      	ldr	r3, [r3, #16]
 8004b8e:	2b00      	cmp	r3, #0
 8004b90:	d103      	bne.n	8004b9a <UART_Start_Receive_IT+0x106>
  {
    huart->RxISR = UART_RxISR_16BIT;
 8004b92:	68fb      	ldr	r3, [r7, #12]
 8004b94:	4a15      	ldr	r2, [pc, #84]	; (8004bec <UART_Start_Receive_IT+0x158>)
 8004b96:	665a      	str	r2, [r3, #100]	; 0x64
 8004b98:	e002      	b.n	8004ba0 <UART_Start_Receive_IT+0x10c>
  }
  else
  {
    huart->RxISR = UART_RxISR_8BIT;
 8004b9a:	68fb      	ldr	r3, [r7, #12]
 8004b9c:	4a14      	ldr	r2, [pc, #80]	; (8004bf0 <UART_Start_Receive_IT+0x15c>)
 8004b9e:	665a      	str	r2, [r3, #100]	; 0x64
  }

  __HAL_UNLOCK(huart);
 8004ba0:	68fb      	ldr	r3, [r7, #12]
 8004ba2:	2274      	movs	r2, #116	; 0x74
 8004ba4:	2100      	movs	r1, #0
 8004ba6:	5499      	strb	r1, [r3, r2]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004ba8:	f3ef 8310 	mrs	r3, PRIMASK
 8004bac:	613b      	str	r3, [r7, #16]
  return(result);
 8004bae:	693b      	ldr	r3, [r7, #16]

  /* Enable the UART Parity Error interrupt and Data Register Not Empty interrupt */
  ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
 8004bb0:	62bb      	str	r3, [r7, #40]	; 0x28
 8004bb2:	2301      	movs	r3, #1
 8004bb4:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004bb6:	697b      	ldr	r3, [r7, #20]
 8004bb8:	f383 8810 	msr	PRIMASK, r3
}
 8004bbc:	46c0      	nop			; (mov r8, r8)
 8004bbe:	68fb      	ldr	r3, [r7, #12]
 8004bc0:	681b      	ldr	r3, [r3, #0]
 8004bc2:	681a      	ldr	r2, [r3, #0]
 8004bc4:	68fb      	ldr	r3, [r7, #12]
 8004bc6:	681b      	ldr	r3, [r3, #0]
 8004bc8:	2190      	movs	r1, #144	; 0x90
 8004bca:	0049      	lsls	r1, r1, #1
 8004bcc:	430a      	orrs	r2, r1
 8004bce:	601a      	str	r2, [r3, #0]
 8004bd0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004bd2:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004bd4:	69bb      	ldr	r3, [r7, #24]
 8004bd6:	f383 8810 	msr	PRIMASK, r3
}
 8004bda:	46c0      	nop			; (mov r8, r8)
  return HAL_OK;
 8004bdc:	2300      	movs	r3, #0
}
 8004bde:	0018      	movs	r0, r3
 8004be0:	46bd      	mov	sp, r7
 8004be2:	b00c      	add	sp, #48	; 0x30
 8004be4:	bd80      	pop	{r7, pc}
 8004be6:	46c0      	nop			; (mov r8, r8)
 8004be8:	000001ff 	.word	0x000001ff
 8004bec:	08004ea5 	.word	0x08004ea5
 8004bf0:	08004d3d 	.word	0x08004d3d

08004bf4 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 8004bf4:	b580      	push	{r7, lr}
 8004bf6:	b08e      	sub	sp, #56	; 0x38
 8004bf8:	af00      	add	r7, sp, #0
 8004bfa:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004bfc:	f3ef 8310 	mrs	r3, PRIMASK
 8004c00:	617b      	str	r3, [r7, #20]
  return(result);
 8004c02:	697b      	ldr	r3, [r7, #20]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8004c04:	637b      	str	r3, [r7, #52]	; 0x34
 8004c06:	2301      	movs	r3, #1
 8004c08:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004c0a:	69bb      	ldr	r3, [r7, #24]
 8004c0c:	f383 8810 	msr	PRIMASK, r3
}
 8004c10:	46c0      	nop			; (mov r8, r8)
 8004c12:	687b      	ldr	r3, [r7, #4]
 8004c14:	681b      	ldr	r3, [r3, #0]
 8004c16:	681a      	ldr	r2, [r3, #0]
 8004c18:	687b      	ldr	r3, [r7, #4]
 8004c1a:	681b      	ldr	r3, [r3, #0]
 8004c1c:	4925      	ldr	r1, [pc, #148]	; (8004cb4 <UART_EndRxTransfer+0xc0>)
 8004c1e:	400a      	ands	r2, r1
 8004c20:	601a      	str	r2, [r3, #0]
 8004c22:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004c24:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004c26:	69fb      	ldr	r3, [r7, #28]
 8004c28:	f383 8810 	msr	PRIMASK, r3
}
 8004c2c:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004c2e:	f3ef 8310 	mrs	r3, PRIMASK
 8004c32:	623b      	str	r3, [r7, #32]
  return(result);
 8004c34:	6a3b      	ldr	r3, [r7, #32]
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8004c36:	633b      	str	r3, [r7, #48]	; 0x30
 8004c38:	2301      	movs	r3, #1
 8004c3a:	627b      	str	r3, [r7, #36]	; 0x24
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004c3c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004c3e:	f383 8810 	msr	PRIMASK, r3
}
 8004c42:	46c0      	nop			; (mov r8, r8)
 8004c44:	687b      	ldr	r3, [r7, #4]
 8004c46:	681b      	ldr	r3, [r3, #0]
 8004c48:	689a      	ldr	r2, [r3, #8]
 8004c4a:	687b      	ldr	r3, [r7, #4]
 8004c4c:	681b      	ldr	r3, [r3, #0]
 8004c4e:	2101      	movs	r1, #1
 8004c50:	438a      	bics	r2, r1
 8004c52:	609a      	str	r2, [r3, #8]
 8004c54:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004c56:	62bb      	str	r3, [r7, #40]	; 0x28
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004c58:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004c5a:	f383 8810 	msr	PRIMASK, r3
}
 8004c5e:	46c0      	nop			; (mov r8, r8)

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8004c60:	687b      	ldr	r3, [r7, #4]
 8004c62:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8004c64:	2b01      	cmp	r3, #1
 8004c66:	d118      	bne.n	8004c9a <UART_EndRxTransfer+0xa6>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004c68:	f3ef 8310 	mrs	r3, PRIMASK
 8004c6c:	60bb      	str	r3, [r7, #8]
  return(result);
 8004c6e:	68bb      	ldr	r3, [r7, #8]
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8004c70:	62fb      	str	r3, [r7, #44]	; 0x2c
 8004c72:	2301      	movs	r3, #1
 8004c74:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004c76:	68fb      	ldr	r3, [r7, #12]
 8004c78:	f383 8810 	msr	PRIMASK, r3
}
 8004c7c:	46c0      	nop			; (mov r8, r8)
 8004c7e:	687b      	ldr	r3, [r7, #4]
 8004c80:	681b      	ldr	r3, [r3, #0]
 8004c82:	681a      	ldr	r2, [r3, #0]
 8004c84:	687b      	ldr	r3, [r7, #4]
 8004c86:	681b      	ldr	r3, [r3, #0]
 8004c88:	2110      	movs	r1, #16
 8004c8a:	438a      	bics	r2, r1
 8004c8c:	601a      	str	r2, [r3, #0]
 8004c8e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004c90:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004c92:	693b      	ldr	r3, [r7, #16]
 8004c94:	f383 8810 	msr	PRIMASK, r3
}
 8004c98:	46c0      	nop			; (mov r8, r8)
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 8004c9a:	687b      	ldr	r3, [r7, #4]
 8004c9c:	2220      	movs	r2, #32
 8004c9e:	67da      	str	r2, [r3, #124]	; 0x7c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8004ca0:	687b      	ldr	r3, [r7, #4]
 8004ca2:	2200      	movs	r2, #0
 8004ca4:	661a      	str	r2, [r3, #96]	; 0x60

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 8004ca6:	687b      	ldr	r3, [r7, #4]
 8004ca8:	2200      	movs	r2, #0
 8004caa:	665a      	str	r2, [r3, #100]	; 0x64
}
 8004cac:	46c0      	nop			; (mov r8, r8)
 8004cae:	46bd      	mov	sp, r7
 8004cb0:	b00e      	add	sp, #56	; 0x38
 8004cb2:	bd80      	pop	{r7, pc}
 8004cb4:	fffffedf 	.word	0xfffffedf

08004cb8 <UART_DMAAbortOnError>:
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 8004cb8:	b580      	push	{r7, lr}
 8004cba:	b084      	sub	sp, #16
 8004cbc:	af00      	add	r7, sp, #0
 8004cbe:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 8004cc0:	687b      	ldr	r3, [r7, #4]
 8004cc2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004cc4:	60fb      	str	r3, [r7, #12]
  huart->RxXferCount = 0U;
 8004cc6:	68fb      	ldr	r3, [r7, #12]
 8004cc8:	225a      	movs	r2, #90	; 0x5a
 8004cca:	2100      	movs	r1, #0
 8004ccc:	5299      	strh	r1, [r3, r2]
  huart->TxXferCount = 0U;
 8004cce:	68fb      	ldr	r3, [r7, #12]
 8004cd0:	2252      	movs	r2, #82	; 0x52
 8004cd2:	2100      	movs	r1, #0
 8004cd4:	5299      	strh	r1, [r3, r2]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 8004cd6:	68fb      	ldr	r3, [r7, #12]
 8004cd8:	0018      	movs	r0, r3
 8004cda:	f7ff fa49 	bl	8004170 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 8004cde:	46c0      	nop			; (mov r8, r8)
 8004ce0:	46bd      	mov	sp, r7
 8004ce2:	b004      	add	sp, #16
 8004ce4:	bd80      	pop	{r7, pc}

08004ce6 <UART_EndTransmit_IT>:
  * @param  huart pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
 8004ce6:	b580      	push	{r7, lr}
 8004ce8:	b086      	sub	sp, #24
 8004cea:	af00      	add	r7, sp, #0
 8004cec:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004cee:	f3ef 8310 	mrs	r3, PRIMASK
 8004cf2:	60bb      	str	r3, [r7, #8]
  return(result);
 8004cf4:	68bb      	ldr	r3, [r7, #8]
  /* Disable the UART Transmit Complete Interrupt */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8004cf6:	617b      	str	r3, [r7, #20]
 8004cf8:	2301      	movs	r3, #1
 8004cfa:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004cfc:	68fb      	ldr	r3, [r7, #12]
 8004cfe:	f383 8810 	msr	PRIMASK, r3
}
 8004d02:	46c0      	nop			; (mov r8, r8)
 8004d04:	687b      	ldr	r3, [r7, #4]
 8004d06:	681b      	ldr	r3, [r3, #0]
 8004d08:	681a      	ldr	r2, [r3, #0]
 8004d0a:	687b      	ldr	r3, [r7, #4]
 8004d0c:	681b      	ldr	r3, [r3, #0]
 8004d0e:	2140      	movs	r1, #64	; 0x40
 8004d10:	438a      	bics	r2, r1
 8004d12:	601a      	str	r2, [r3, #0]
 8004d14:	697b      	ldr	r3, [r7, #20]
 8004d16:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004d18:	693b      	ldr	r3, [r7, #16]
 8004d1a:	f383 8810 	msr	PRIMASK, r3
}
 8004d1e:	46c0      	nop			; (mov r8, r8)

  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 8004d20:	687b      	ldr	r3, [r7, #4]
 8004d22:	2220      	movs	r2, #32
 8004d24:	679a      	str	r2, [r3, #120]	; 0x78

  /* Cleat TxISR function pointer */
  huart->TxISR = NULL;
 8004d26:	687b      	ldr	r3, [r7, #4]
 8004d28:	2200      	movs	r2, #0
 8004d2a:	669a      	str	r2, [r3, #104]	; 0x68
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx complete callback*/
  huart->TxCpltCallback(huart);
#else
  /*Call legacy weak Tx complete callback*/
  HAL_UART_TxCpltCallback(huart);
 8004d2c:	687b      	ldr	r3, [r7, #4]
 8004d2e:	0018      	movs	r0, r3
 8004d30:	f7ff fa16 	bl	8004160 <HAL_UART_TxCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 8004d34:	46c0      	nop			; (mov r8, r8)
 8004d36:	46bd      	mov	sp, r7
 8004d38:	b006      	add	sp, #24
 8004d3a:	bd80      	pop	{r7, pc}

08004d3c <UART_RxISR_8BIT>:
  * @brief RX interrupt handler for 7 or 8 bits data word length .
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_8BIT(UART_HandleTypeDef *huart)
{
 8004d3c:	b580      	push	{r7, lr}
 8004d3e:	b090      	sub	sp, #64	; 0x40
 8004d40:	af00      	add	r7, sp, #0
 8004d42:	6078      	str	r0, [r7, #4]
  uint16_t uhMask = huart->Mask;
 8004d44:	203e      	movs	r0, #62	; 0x3e
 8004d46:	183b      	adds	r3, r7, r0
 8004d48:	687a      	ldr	r2, [r7, #4]
 8004d4a:	215c      	movs	r1, #92	; 0x5c
 8004d4c:	5a52      	ldrh	r2, [r2, r1]
 8004d4e:	801a      	strh	r2, [r3, #0]
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8004d50:	687b      	ldr	r3, [r7, #4]
 8004d52:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8004d54:	2b22      	cmp	r3, #34	; 0x22
 8004d56:	d000      	beq.n	8004d5a <UART_RxISR_8BIT+0x1e>
 8004d58:	e095      	b.n	8004e86 <UART_RxISR_8BIT+0x14a>
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8004d5a:	687b      	ldr	r3, [r7, #4]
 8004d5c:	681b      	ldr	r3, [r3, #0]
 8004d5e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004d60:	213c      	movs	r1, #60	; 0x3c
 8004d62:	187b      	adds	r3, r7, r1
 8004d64:	801a      	strh	r2, [r3, #0]
    *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 8004d66:	187b      	adds	r3, r7, r1
 8004d68:	881b      	ldrh	r3, [r3, #0]
 8004d6a:	b2da      	uxtb	r2, r3
 8004d6c:	183b      	adds	r3, r7, r0
 8004d6e:	881b      	ldrh	r3, [r3, #0]
 8004d70:	b2d9      	uxtb	r1, r3
 8004d72:	687b      	ldr	r3, [r7, #4]
 8004d74:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004d76:	400a      	ands	r2, r1
 8004d78:	b2d2      	uxtb	r2, r2
 8004d7a:	701a      	strb	r2, [r3, #0]
    huart->pRxBuffPtr++;
 8004d7c:	687b      	ldr	r3, [r7, #4]
 8004d7e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004d80:	1c5a      	adds	r2, r3, #1
 8004d82:	687b      	ldr	r3, [r7, #4]
 8004d84:	655a      	str	r2, [r3, #84]	; 0x54
    huart->RxXferCount--;
 8004d86:	687b      	ldr	r3, [r7, #4]
 8004d88:	225a      	movs	r2, #90	; 0x5a
 8004d8a:	5a9b      	ldrh	r3, [r3, r2]
 8004d8c:	b29b      	uxth	r3, r3
 8004d8e:	3b01      	subs	r3, #1
 8004d90:	b299      	uxth	r1, r3
 8004d92:	687b      	ldr	r3, [r7, #4]
 8004d94:	225a      	movs	r2, #90	; 0x5a
 8004d96:	5299      	strh	r1, [r3, r2]

    if (huart->RxXferCount == 0U)
 8004d98:	687b      	ldr	r3, [r7, #4]
 8004d9a:	225a      	movs	r2, #90	; 0x5a
 8004d9c:	5a9b      	ldrh	r3, [r3, r2]
 8004d9e:	b29b      	uxth	r3, r3
 8004da0:	2b00      	cmp	r3, #0
 8004da2:	d178      	bne.n	8004e96 <UART_RxISR_8BIT+0x15a>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004da4:	f3ef 8310 	mrs	r3, PRIMASK
 8004da8:	61bb      	str	r3, [r7, #24]
  return(result);
 8004daa:	69bb      	ldr	r3, [r7, #24]
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupts */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8004dac:	63bb      	str	r3, [r7, #56]	; 0x38
 8004dae:	2301      	movs	r3, #1
 8004db0:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004db2:	69fb      	ldr	r3, [r7, #28]
 8004db4:	f383 8810 	msr	PRIMASK, r3
}
 8004db8:	46c0      	nop			; (mov r8, r8)
 8004dba:	687b      	ldr	r3, [r7, #4]
 8004dbc:	681b      	ldr	r3, [r3, #0]
 8004dbe:	681a      	ldr	r2, [r3, #0]
 8004dc0:	687b      	ldr	r3, [r7, #4]
 8004dc2:	681b      	ldr	r3, [r3, #0]
 8004dc4:	4936      	ldr	r1, [pc, #216]	; (8004ea0 <UART_RxISR_8BIT+0x164>)
 8004dc6:	400a      	ands	r2, r1
 8004dc8:	601a      	str	r2, [r3, #0]
 8004dca:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004dcc:	623b      	str	r3, [r7, #32]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004dce:	6a3b      	ldr	r3, [r7, #32]
 8004dd0:	f383 8810 	msr	PRIMASK, r3
}
 8004dd4:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004dd6:	f3ef 8310 	mrs	r3, PRIMASK
 8004dda:	627b      	str	r3, [r7, #36]	; 0x24
  return(result);
 8004ddc:	6a7b      	ldr	r3, [r7, #36]	; 0x24

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8004dde:	637b      	str	r3, [r7, #52]	; 0x34
 8004de0:	2301      	movs	r3, #1
 8004de2:	62bb      	str	r3, [r7, #40]	; 0x28
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004de4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004de6:	f383 8810 	msr	PRIMASK, r3
}
 8004dea:	46c0      	nop			; (mov r8, r8)
 8004dec:	687b      	ldr	r3, [r7, #4]
 8004dee:	681b      	ldr	r3, [r3, #0]
 8004df0:	689a      	ldr	r2, [r3, #8]
 8004df2:	687b      	ldr	r3, [r7, #4]
 8004df4:	681b      	ldr	r3, [r3, #0]
 8004df6:	2101      	movs	r1, #1
 8004df8:	438a      	bics	r2, r1
 8004dfa:	609a      	str	r2, [r3, #8]
 8004dfc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004dfe:	62fb      	str	r3, [r7, #44]	; 0x2c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004e00:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004e02:	f383 8810 	msr	PRIMASK, r3
}
 8004e06:	46c0      	nop			; (mov r8, r8)

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 8004e08:	687b      	ldr	r3, [r7, #4]
 8004e0a:	2220      	movs	r2, #32
 8004e0c:	67da      	str	r2, [r3, #124]	; 0x7c

      /* Clear RxISR function pointer */
      huart->RxISR = NULL;
 8004e0e:	687b      	ldr	r3, [r7, #4]
 8004e10:	2200      	movs	r2, #0
 8004e12:	665a      	str	r2, [r3, #100]	; 0x64

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8004e14:	687b      	ldr	r3, [r7, #4]
 8004e16:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8004e18:	2b01      	cmp	r3, #1
 8004e1a:	d12f      	bne.n	8004e7c <UART_RxISR_8BIT+0x140>
      {
        /* Set reception type to Standard */
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8004e1c:	687b      	ldr	r3, [r7, #4]
 8004e1e:	2200      	movs	r2, #0
 8004e20:	661a      	str	r2, [r3, #96]	; 0x60
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004e22:	f3ef 8310 	mrs	r3, PRIMASK
 8004e26:	60fb      	str	r3, [r7, #12]
  return(result);
 8004e28:	68fb      	ldr	r3, [r7, #12]

        /* Disable IDLE interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8004e2a:	633b      	str	r3, [r7, #48]	; 0x30
 8004e2c:	2301      	movs	r3, #1
 8004e2e:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004e30:	693b      	ldr	r3, [r7, #16]
 8004e32:	f383 8810 	msr	PRIMASK, r3
}
 8004e36:	46c0      	nop			; (mov r8, r8)
 8004e38:	687b      	ldr	r3, [r7, #4]
 8004e3a:	681b      	ldr	r3, [r3, #0]
 8004e3c:	681a      	ldr	r2, [r3, #0]
 8004e3e:	687b      	ldr	r3, [r7, #4]
 8004e40:	681b      	ldr	r3, [r3, #0]
 8004e42:	2110      	movs	r1, #16
 8004e44:	438a      	bics	r2, r1
 8004e46:	601a      	str	r2, [r3, #0]
 8004e48:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004e4a:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004e4c:	697b      	ldr	r3, [r7, #20]
 8004e4e:	f383 8810 	msr	PRIMASK, r3
}
 8004e52:	46c0      	nop			; (mov r8, r8)

        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 8004e54:	687b      	ldr	r3, [r7, #4]
 8004e56:	681b      	ldr	r3, [r3, #0]
 8004e58:	69db      	ldr	r3, [r3, #28]
 8004e5a:	2210      	movs	r2, #16
 8004e5c:	4013      	ands	r3, r2
 8004e5e:	2b10      	cmp	r3, #16
 8004e60:	d103      	bne.n	8004e6a <UART_RxISR_8BIT+0x12e>
        {
          /* Clear IDLE Flag */
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8004e62:	687b      	ldr	r3, [r7, #4]
 8004e64:	681b      	ldr	r3, [r3, #0]
 8004e66:	2210      	movs	r2, #16
 8004e68:	621a      	str	r2, [r3, #32]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, huart->RxXferSize);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8004e6a:	687b      	ldr	r3, [r7, #4]
 8004e6c:	2258      	movs	r2, #88	; 0x58
 8004e6e:	5a9a      	ldrh	r2, [r3, r2]
 8004e70:	687b      	ldr	r3, [r7, #4]
 8004e72:	0011      	movs	r1, r2
 8004e74:	0018      	movs	r0, r3
 8004e76:	f7ff f983 	bl	8004180 <HAL_UARTEx_RxEventCallback>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 8004e7a:	e00c      	b.n	8004e96 <UART_RxISR_8BIT+0x15a>
        HAL_UART_RxCpltCallback(huart);
 8004e7c:	687b      	ldr	r3, [r7, #4]
 8004e7e:	0018      	movs	r0, r3
 8004e80:	f7fb fb28 	bl	80004d4 <HAL_UART_RxCpltCallback>
}
 8004e84:	e007      	b.n	8004e96 <UART_RxISR_8BIT+0x15a>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8004e86:	687b      	ldr	r3, [r7, #4]
 8004e88:	681b      	ldr	r3, [r3, #0]
 8004e8a:	699a      	ldr	r2, [r3, #24]
 8004e8c:	687b      	ldr	r3, [r7, #4]
 8004e8e:	681b      	ldr	r3, [r3, #0]
 8004e90:	2108      	movs	r1, #8
 8004e92:	430a      	orrs	r2, r1
 8004e94:	619a      	str	r2, [r3, #24]
}
 8004e96:	46c0      	nop			; (mov r8, r8)
 8004e98:	46bd      	mov	sp, r7
 8004e9a:	b010      	add	sp, #64	; 0x40
 8004e9c:	bd80      	pop	{r7, pc}
 8004e9e:	46c0      	nop			; (mov r8, r8)
 8004ea0:	fffffedf 	.word	0xfffffedf

08004ea4 <UART_RxISR_16BIT>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_16BIT(UART_HandleTypeDef *huart)
{
 8004ea4:	b580      	push	{r7, lr}
 8004ea6:	b090      	sub	sp, #64	; 0x40
 8004ea8:	af00      	add	r7, sp, #0
 8004eaa:	6078      	str	r0, [r7, #4]
  uint16_t *tmp;
  uint16_t uhMask = huart->Mask;
 8004eac:	203e      	movs	r0, #62	; 0x3e
 8004eae:	183b      	adds	r3, r7, r0
 8004eb0:	687a      	ldr	r2, [r7, #4]
 8004eb2:	215c      	movs	r1, #92	; 0x5c
 8004eb4:	5a52      	ldrh	r2, [r2, r1]
 8004eb6:	801a      	strh	r2, [r3, #0]
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8004eb8:	687b      	ldr	r3, [r7, #4]
 8004eba:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8004ebc:	2b22      	cmp	r3, #34	; 0x22
 8004ebe:	d000      	beq.n	8004ec2 <UART_RxISR_16BIT+0x1e>
 8004ec0:	e095      	b.n	8004fee <UART_RxISR_16BIT+0x14a>
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8004ec2:	687b      	ldr	r3, [r7, #4]
 8004ec4:	681b      	ldr	r3, [r3, #0]
 8004ec6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004ec8:	213c      	movs	r1, #60	; 0x3c
 8004eca:	187b      	adds	r3, r7, r1
 8004ecc:	801a      	strh	r2, [r3, #0]
    tmp = (uint16_t *) huart->pRxBuffPtr ;
 8004ece:	687b      	ldr	r3, [r7, #4]
 8004ed0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004ed2:	63bb      	str	r3, [r7, #56]	; 0x38
    *tmp = (uint16_t)(uhdata & uhMask);
 8004ed4:	187b      	adds	r3, r7, r1
 8004ed6:	183a      	adds	r2, r7, r0
 8004ed8:	881b      	ldrh	r3, [r3, #0]
 8004eda:	8812      	ldrh	r2, [r2, #0]
 8004edc:	4013      	ands	r3, r2
 8004ede:	b29a      	uxth	r2, r3
 8004ee0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004ee2:	801a      	strh	r2, [r3, #0]
    huart->pRxBuffPtr += 2U;
 8004ee4:	687b      	ldr	r3, [r7, #4]
 8004ee6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004ee8:	1c9a      	adds	r2, r3, #2
 8004eea:	687b      	ldr	r3, [r7, #4]
 8004eec:	655a      	str	r2, [r3, #84]	; 0x54
    huart->RxXferCount--;
 8004eee:	687b      	ldr	r3, [r7, #4]
 8004ef0:	225a      	movs	r2, #90	; 0x5a
 8004ef2:	5a9b      	ldrh	r3, [r3, r2]
 8004ef4:	b29b      	uxth	r3, r3
 8004ef6:	3b01      	subs	r3, #1
 8004ef8:	b299      	uxth	r1, r3
 8004efa:	687b      	ldr	r3, [r7, #4]
 8004efc:	225a      	movs	r2, #90	; 0x5a
 8004efe:	5299      	strh	r1, [r3, r2]

    if (huart->RxXferCount == 0U)
 8004f00:	687b      	ldr	r3, [r7, #4]
 8004f02:	225a      	movs	r2, #90	; 0x5a
 8004f04:	5a9b      	ldrh	r3, [r3, r2]
 8004f06:	b29b      	uxth	r3, r3
 8004f08:	2b00      	cmp	r3, #0
 8004f0a:	d178      	bne.n	8004ffe <UART_RxISR_16BIT+0x15a>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004f0c:	f3ef 8310 	mrs	r3, PRIMASK
 8004f10:	617b      	str	r3, [r7, #20]
  return(result);
 8004f12:	697b      	ldr	r3, [r7, #20]
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8004f14:	637b      	str	r3, [r7, #52]	; 0x34
 8004f16:	2301      	movs	r3, #1
 8004f18:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004f1a:	69bb      	ldr	r3, [r7, #24]
 8004f1c:	f383 8810 	msr	PRIMASK, r3
}
 8004f20:	46c0      	nop			; (mov r8, r8)
 8004f22:	687b      	ldr	r3, [r7, #4]
 8004f24:	681b      	ldr	r3, [r3, #0]
 8004f26:	681a      	ldr	r2, [r3, #0]
 8004f28:	687b      	ldr	r3, [r7, #4]
 8004f2a:	681b      	ldr	r3, [r3, #0]
 8004f2c:	4936      	ldr	r1, [pc, #216]	; (8005008 <UART_RxISR_16BIT+0x164>)
 8004f2e:	400a      	ands	r2, r1
 8004f30:	601a      	str	r2, [r3, #0]
 8004f32:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004f34:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004f36:	69fb      	ldr	r3, [r7, #28]
 8004f38:	f383 8810 	msr	PRIMASK, r3
}
 8004f3c:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004f3e:	f3ef 8310 	mrs	r3, PRIMASK
 8004f42:	623b      	str	r3, [r7, #32]
  return(result);
 8004f44:	6a3b      	ldr	r3, [r7, #32]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8004f46:	633b      	str	r3, [r7, #48]	; 0x30
 8004f48:	2301      	movs	r3, #1
 8004f4a:	627b      	str	r3, [r7, #36]	; 0x24
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004f4c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004f4e:	f383 8810 	msr	PRIMASK, r3
}
 8004f52:	46c0      	nop			; (mov r8, r8)
 8004f54:	687b      	ldr	r3, [r7, #4]
 8004f56:	681b      	ldr	r3, [r3, #0]
 8004f58:	689a      	ldr	r2, [r3, #8]
 8004f5a:	687b      	ldr	r3, [r7, #4]
 8004f5c:	681b      	ldr	r3, [r3, #0]
 8004f5e:	2101      	movs	r1, #1
 8004f60:	438a      	bics	r2, r1
 8004f62:	609a      	str	r2, [r3, #8]
 8004f64:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004f66:	62bb      	str	r3, [r7, #40]	; 0x28
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004f68:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004f6a:	f383 8810 	msr	PRIMASK, r3
}
 8004f6e:	46c0      	nop			; (mov r8, r8)

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 8004f70:	687b      	ldr	r3, [r7, #4]
 8004f72:	2220      	movs	r2, #32
 8004f74:	67da      	str	r2, [r3, #124]	; 0x7c

      /* Clear RxISR function pointer */
      huart->RxISR = NULL;
 8004f76:	687b      	ldr	r3, [r7, #4]
 8004f78:	2200      	movs	r2, #0
 8004f7a:	665a      	str	r2, [r3, #100]	; 0x64

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8004f7c:	687b      	ldr	r3, [r7, #4]
 8004f7e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8004f80:	2b01      	cmp	r3, #1
 8004f82:	d12f      	bne.n	8004fe4 <UART_RxISR_16BIT+0x140>
      {
        /* Set reception type to Standard */
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8004f84:	687b      	ldr	r3, [r7, #4]
 8004f86:	2200      	movs	r2, #0
 8004f88:	661a      	str	r2, [r3, #96]	; 0x60
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004f8a:	f3ef 8310 	mrs	r3, PRIMASK
 8004f8e:	60bb      	str	r3, [r7, #8]
  return(result);
 8004f90:	68bb      	ldr	r3, [r7, #8]

        /* Disable IDLE interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8004f92:	62fb      	str	r3, [r7, #44]	; 0x2c
 8004f94:	2301      	movs	r3, #1
 8004f96:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004f98:	68fb      	ldr	r3, [r7, #12]
 8004f9a:	f383 8810 	msr	PRIMASK, r3
}
 8004f9e:	46c0      	nop			; (mov r8, r8)
 8004fa0:	687b      	ldr	r3, [r7, #4]
 8004fa2:	681b      	ldr	r3, [r3, #0]
 8004fa4:	681a      	ldr	r2, [r3, #0]
 8004fa6:	687b      	ldr	r3, [r7, #4]
 8004fa8:	681b      	ldr	r3, [r3, #0]
 8004faa:	2110      	movs	r1, #16
 8004fac:	438a      	bics	r2, r1
 8004fae:	601a      	str	r2, [r3, #0]
 8004fb0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004fb2:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004fb4:	693b      	ldr	r3, [r7, #16]
 8004fb6:	f383 8810 	msr	PRIMASK, r3
}
 8004fba:	46c0      	nop			; (mov r8, r8)

        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 8004fbc:	687b      	ldr	r3, [r7, #4]
 8004fbe:	681b      	ldr	r3, [r3, #0]
 8004fc0:	69db      	ldr	r3, [r3, #28]
 8004fc2:	2210      	movs	r2, #16
 8004fc4:	4013      	ands	r3, r2
 8004fc6:	2b10      	cmp	r3, #16
 8004fc8:	d103      	bne.n	8004fd2 <UART_RxISR_16BIT+0x12e>
        {
          /* Clear IDLE Flag */
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8004fca:	687b      	ldr	r3, [r7, #4]
 8004fcc:	681b      	ldr	r3, [r3, #0]
 8004fce:	2210      	movs	r2, #16
 8004fd0:	621a      	str	r2, [r3, #32]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, huart->RxXferSize);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8004fd2:	687b      	ldr	r3, [r7, #4]
 8004fd4:	2258      	movs	r2, #88	; 0x58
 8004fd6:	5a9a      	ldrh	r2, [r3, r2]
 8004fd8:	687b      	ldr	r3, [r7, #4]
 8004fda:	0011      	movs	r1, r2
 8004fdc:	0018      	movs	r0, r3
 8004fde:	f7ff f8cf 	bl	8004180 <HAL_UARTEx_RxEventCallback>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 8004fe2:	e00c      	b.n	8004ffe <UART_RxISR_16BIT+0x15a>
        HAL_UART_RxCpltCallback(huart);
 8004fe4:	687b      	ldr	r3, [r7, #4]
 8004fe6:	0018      	movs	r0, r3
 8004fe8:	f7fb fa74 	bl	80004d4 <HAL_UART_RxCpltCallback>
}
 8004fec:	e007      	b.n	8004ffe <UART_RxISR_16BIT+0x15a>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8004fee:	687b      	ldr	r3, [r7, #4]
 8004ff0:	681b      	ldr	r3, [r3, #0]
 8004ff2:	699a      	ldr	r2, [r3, #24]
 8004ff4:	687b      	ldr	r3, [r7, #4]
 8004ff6:	681b      	ldr	r3, [r3, #0]
 8004ff8:	2108      	movs	r1, #8
 8004ffa:	430a      	orrs	r2, r1
 8004ffc:	619a      	str	r2, [r3, #24]
}
 8004ffe:	46c0      	nop			; (mov r8, r8)
 8005000:	46bd      	mov	sp, r7
 8005002:	b010      	add	sp, #64	; 0x40
 8005004:	bd80      	pop	{r7, pc}
 8005006:	46c0      	nop			; (mov r8, r8)
 8005008:	fffffedf 	.word	0xfffffedf

0800500c <HAL_UARTEx_WakeupCallback>:
  * @brief UART wakeup from Stop mode callback.
  * @param huart UART handle.
  * @retval None
  */
__weak void HAL_UARTEx_WakeupCallback(UART_HandleTypeDef *huart)
{
 800500c:	b580      	push	{r7, lr}
 800500e:	b082      	sub	sp, #8
 8005010:	af00      	add	r7, sp, #0
 8005012:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_WakeupCallback can be implemented in the user file.
   */
}
 8005014:	46c0      	nop			; (mov r8, r8)
 8005016:	46bd      	mov	sp, r7
 8005018:	b002      	add	sp, #8
 800501a:	bd80      	pop	{r7, pc}

0800501c <msg_generate_packet_id>:
 * @param client MQTT client
 * @return New packet identifier, range 1 to 65535
 */
static u16_t
msg_generate_packet_id(mqtt_client_t *client)
{
 800501c:	b580      	push	{r7, lr}
 800501e:	b082      	sub	sp, #8
 8005020:	af00      	add	r7, sp, #0
 8005022:	6078      	str	r0, [r7, #4]
  client->pkt_id_seq++;
 8005024:	687b      	ldr	r3, [r7, #4]
 8005026:	88db      	ldrh	r3, [r3, #6]
 8005028:	3301      	adds	r3, #1
 800502a:	b29a      	uxth	r2, r3
 800502c:	687b      	ldr	r3, [r7, #4]
 800502e:	80da      	strh	r2, [r3, #6]
  if (client->pkt_id_seq == 0) {
 8005030:	687b      	ldr	r3, [r7, #4]
 8005032:	88db      	ldrh	r3, [r3, #6]
 8005034:	2b00      	cmp	r3, #0
 8005036:	d105      	bne.n	8005044 <msg_generate_packet_id+0x28>
    client->pkt_id_seq++;
 8005038:	687b      	ldr	r3, [r7, #4]
 800503a:	88db      	ldrh	r3, [r3, #6]
 800503c:	3301      	adds	r3, #1
 800503e:	b29a      	uxth	r2, r3
 8005040:	687b      	ldr	r3, [r7, #4]
 8005042:	80da      	strh	r2, [r3, #6]
  }
  return client->pkt_id_seq;
 8005044:	687b      	ldr	r3, [r7, #4]
 8005046:	88db      	ldrh	r3, [r3, #6]
}
 8005048:	0018      	movs	r0, r3
 800504a:	46bd      	mov	sp, r7
 800504c:	b002      	add	sp, #8
 800504e:	bd80      	pop	{r7, pc}

08005050 <mqtt_ringbuf_put>:
/* Output ring buffer */

/** Add single item to ring buffer */
static void
mqtt_ringbuf_put(struct mqtt_ringbuf_t *rb, u8_t item)
{
 8005050:	b580      	push	{r7, lr}
 8005052:	b082      	sub	sp, #8
 8005054:	af00      	add	r7, sp, #0
 8005056:	6078      	str	r0, [r7, #4]
 8005058:	000a      	movs	r2, r1
 800505a:	1cfb      	adds	r3, r7, #3
 800505c:	701a      	strb	r2, [r3, #0]
  rb->buf[rb->put] = item;
 800505e:	687b      	ldr	r3, [r7, #4]
 8005060:	881b      	ldrh	r3, [r3, #0]
 8005062:	001a      	movs	r2, r3
 8005064:	687b      	ldr	r3, [r7, #4]
 8005066:	189b      	adds	r3, r3, r2
 8005068:	1cfa      	adds	r2, r7, #3
 800506a:	7812      	ldrb	r2, [r2, #0]
 800506c:	711a      	strb	r2, [r3, #4]
  rb->put++;
 800506e:	687b      	ldr	r3, [r7, #4]
 8005070:	881b      	ldrh	r3, [r3, #0]
 8005072:	3301      	adds	r3, #1
 8005074:	b29a      	uxth	r2, r3
 8005076:	687b      	ldr	r3, [r7, #4]
 8005078:	801a      	strh	r2, [r3, #0]
  if (rb->put >= MQTT_OUTPUT_RINGBUF_SIZE) {
 800507a:	687b      	ldr	r3, [r7, #4]
 800507c:	881b      	ldrh	r3, [r3, #0]
 800507e:	2bff      	cmp	r3, #255	; 0xff
 8005080:	d902      	bls.n	8005088 <mqtt_ringbuf_put+0x38>
    rb->put = 0;
 8005082:	687b      	ldr	r3, [r7, #4]
 8005084:	2200      	movs	r2, #0
 8005086:	801a      	strh	r2, [r3, #0]
  }
}
 8005088:	46c0      	nop			; (mov r8, r8)
 800508a:	46bd      	mov	sp, r7
 800508c:	b002      	add	sp, #8
 800508e:	bd80      	pop	{r7, pc}

08005090 <mqtt_ringbuf_get_ptr>:

/** Return pointer to ring buffer get position */
static u8_t *
mqtt_ringbuf_get_ptr(struct mqtt_ringbuf_t *rb)
{
 8005090:	b580      	push	{r7, lr}
 8005092:	b082      	sub	sp, #8
 8005094:	af00      	add	r7, sp, #0
 8005096:	6078      	str	r0, [r7, #4]
  return &rb->buf[rb->get];
 8005098:	687b      	ldr	r3, [r7, #4]
 800509a:	885b      	ldrh	r3, [r3, #2]
 800509c:	001a      	movs	r2, r3
 800509e:	687b      	ldr	r3, [r7, #4]
 80050a0:	189b      	adds	r3, r3, r2
 80050a2:	3304      	adds	r3, #4
}
 80050a4:	0018      	movs	r0, r3
 80050a6:	46bd      	mov	sp, r7
 80050a8:	b002      	add	sp, #8
 80050aa:	bd80      	pop	{r7, pc}

080050ac <mqtt_ringbuf_advance_get_idx>:

static void
mqtt_ringbuf_advance_get_idx(struct mqtt_ringbuf_t *rb, u16_t len)
{
 80050ac:	b580      	push	{r7, lr}
 80050ae:	b082      	sub	sp, #8
 80050b0:	af00      	add	r7, sp, #0
 80050b2:	6078      	str	r0, [r7, #4]
 80050b4:	000a      	movs	r2, r1
 80050b6:	1cbb      	adds	r3, r7, #2
 80050b8:	801a      	strh	r2, [r3, #0]
  LWIP_ASSERT("mqtt_ringbuf_advance_get_idx: len < MQTT_OUTPUT_RINGBUF_SIZE", len < MQTT_OUTPUT_RINGBUF_SIZE);
 80050ba:	1cbb      	adds	r3, r7, #2
 80050bc:	881b      	ldrh	r3, [r3, #0]
 80050be:	2bff      	cmp	r3, #255	; 0xff
 80050c0:	d905      	bls.n	80050ce <mqtt_ringbuf_advance_get_idx+0x22>
 80050c2:	4b0e      	ldr	r3, [pc, #56]	; (80050fc <mqtt_ringbuf_advance_get_idx+0x50>)
 80050c4:	490e      	ldr	r1, [pc, #56]	; (8005100 <mqtt_ringbuf_advance_get_idx+0x54>)
 80050c6:	480f      	ldr	r0, [pc, #60]	; (8005104 <mqtt_ringbuf_advance_get_idx+0x58>)
 80050c8:	22cb      	movs	r2, #203	; 0xcb
 80050ca:	f7fd f88b 	bl	80021e4 <app_debug_rtt_raw>

  rb->get += len;
 80050ce:	687b      	ldr	r3, [r7, #4]
 80050d0:	885a      	ldrh	r2, [r3, #2]
 80050d2:	1cbb      	adds	r3, r7, #2
 80050d4:	881b      	ldrh	r3, [r3, #0]
 80050d6:	18d3      	adds	r3, r2, r3
 80050d8:	b29a      	uxth	r2, r3
 80050da:	687b      	ldr	r3, [r7, #4]
 80050dc:	805a      	strh	r2, [r3, #2]
  if (rb->get >= MQTT_OUTPUT_RINGBUF_SIZE) {
 80050de:	687b      	ldr	r3, [r7, #4]
 80050e0:	885b      	ldrh	r3, [r3, #2]
 80050e2:	2bff      	cmp	r3, #255	; 0xff
 80050e4:	d906      	bls.n	80050f4 <mqtt_ringbuf_advance_get_idx+0x48>
    rb->get = rb->get - MQTT_OUTPUT_RINGBUF_SIZE;
 80050e6:	687b      	ldr	r3, [r7, #4]
 80050e8:	885b      	ldrh	r3, [r3, #2]
 80050ea:	3b01      	subs	r3, #1
 80050ec:	3bff      	subs	r3, #255	; 0xff
 80050ee:	b29a      	uxth	r2, r3
 80050f0:	687b      	ldr	r3, [r7, #4]
 80050f2:	805a      	strh	r2, [r3, #2]
  }
}
 80050f4:	46c0      	nop			; (mov r8, r8)
 80050f6:	46bd      	mov	sp, r7
 80050f8:	b002      	add	sp, #8
 80050fa:	bd80      	pop	{r7, pc}
 80050fc:	0801f5e8 	.word	0x0801f5e8
 8005100:	0801f614 	.word	0x0801f614
 8005104:	0801f654 	.word	0x0801f654

08005108 <mqtt_ringbuf_len>:

/** Return number of bytes in ring buffer */
static u16_t
mqtt_ringbuf_len(struct mqtt_ringbuf_t *rb)
{
 8005108:	b580      	push	{r7, lr}
 800510a:	b084      	sub	sp, #16
 800510c:	af00      	add	r7, sp, #0
 800510e:	6078      	str	r0, [r7, #4]
  u32_t len = rb->put - rb->get;
 8005110:	687b      	ldr	r3, [r7, #4]
 8005112:	881b      	ldrh	r3, [r3, #0]
 8005114:	001a      	movs	r2, r3
 8005116:	687b      	ldr	r3, [r7, #4]
 8005118:	885b      	ldrh	r3, [r3, #2]
 800511a:	1ad3      	subs	r3, r2, r3
 800511c:	60fb      	str	r3, [r7, #12]
  if (len > 0xFFFF) {
 800511e:	68fa      	ldr	r2, [r7, #12]
 8005120:	2380      	movs	r3, #128	; 0x80
 8005122:	025b      	lsls	r3, r3, #9
 8005124:	429a      	cmp	r2, r3
 8005126:	d303      	bcc.n	8005130 <mqtt_ringbuf_len+0x28>
    len += MQTT_OUTPUT_RINGBUF_SIZE;
 8005128:	68fb      	ldr	r3, [r7, #12]
 800512a:	3301      	adds	r3, #1
 800512c:	33ff      	adds	r3, #255	; 0xff
 800512e:	60fb      	str	r3, [r7, #12]
  }
  return (u16_t)len;
 8005130:	68fb      	ldr	r3, [r7, #12]
 8005132:	b29b      	uxth	r3, r3
}
 8005134:	0018      	movs	r0, r3
 8005136:	46bd      	mov	sp, r7
 8005138:	b004      	add	sp, #16
 800513a:	bd80      	pop	{r7, pc}

0800513c <mqtt_output_send>:
 * @param rb Output ring buffer
 * @param tpcb TCP connection handle
 */
static void
mqtt_output_send(struct mqtt_ringbuf_t *rb, struct altcp_pcb *tpcb)
{
 800513c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800513e:	b085      	sub	sp, #20
 8005140:	af00      	add	r7, sp, #0
 8005142:	6078      	str	r0, [r7, #4]
 8005144:	6039      	str	r1, [r7, #0]
  err_t err;
  u8_t wrap = 0;
 8005146:	230c      	movs	r3, #12
 8005148:	18fb      	adds	r3, r7, r3
 800514a:	2200      	movs	r2, #0
 800514c:	701a      	strb	r2, [r3, #0]
  u16_t ringbuf_lin_len = mqtt_ringbuf_linear_read_length(rb);
 800514e:	687b      	ldr	r3, [r7, #4]
 8005150:	0018      	movs	r0, r3
 8005152:	f7ff ffd9 	bl	8005108 <mqtt_ringbuf_len>
 8005156:	0003      	movs	r3, r0
 8005158:	001a      	movs	r2, r3
 800515a:	687b      	ldr	r3, [r7, #4]
 800515c:	885b      	ldrh	r3, [r3, #2]
 800515e:	0019      	movs	r1, r3
 8005160:	2380      	movs	r3, #128	; 0x80
 8005162:	005b      	lsls	r3, r3, #1
 8005164:	1a5b      	subs	r3, r3, r1
 8005166:	429a      	cmp	r2, r3
 8005168:	da06      	bge.n	8005178 <mqtt_output_send+0x3c>
 800516a:	687b      	ldr	r3, [r7, #4]
 800516c:	0018      	movs	r0, r3
 800516e:	f7ff ffcb 	bl	8005108 <mqtt_ringbuf_len>
 8005172:	0003      	movs	r3, r0
 8005174:	001a      	movs	r2, r3
 8005176:	e005      	b.n	8005184 <mqtt_output_send+0x48>
 8005178:	687b      	ldr	r3, [r7, #4]
 800517a:	885b      	ldrh	r3, [r3, #2]
 800517c:	2280      	movs	r2, #128	; 0x80
 800517e:	0052      	lsls	r2, r2, #1
 8005180:	1ad3      	subs	r3, r2, r3
 8005182:	b29a      	uxth	r2, r3
 8005184:	230a      	movs	r3, #10
 8005186:	18fb      	adds	r3, r7, r3
 8005188:	801a      	strh	r2, [r3, #0]
  u16_t send_len = altcp_sndbuf(tpcb);
 800518a:	230e      	movs	r3, #14
 800518c:	18fb      	adds	r3, r7, r3
 800518e:	683a      	ldr	r2, [r7, #0]
 8005190:	2168      	movs	r1, #104	; 0x68
 8005192:	5a52      	ldrh	r2, [r2, r1]
 8005194:	801a      	strh	r2, [r3, #0]
  LWIP_ASSERT("mqtt_output_send: tpcb != NULL", tpcb != NULL);
 8005196:	683b      	ldr	r3, [r7, #0]
 8005198:	2b00      	cmp	r3, #0
 800519a:	d105      	bne.n	80051a8 <mqtt_output_send+0x6c>
 800519c:	4b5c      	ldr	r3, [pc, #368]	; (8005310 <mqtt_output_send+0x1d4>)
 800519e:	495d      	ldr	r1, [pc, #372]	; (8005314 <mqtt_output_send+0x1d8>)
 80051a0:	485d      	ldr	r0, [pc, #372]	; (8005318 <mqtt_output_send+0x1dc>)
 80051a2:	22f0      	movs	r2, #240	; 0xf0
 80051a4:	f7fd f81e 	bl	80021e4 <app_debug_rtt_raw>

  if (send_len == 0 || ringbuf_lin_len == 0) {
 80051a8:	210e      	movs	r1, #14
 80051aa:	187b      	adds	r3, r7, r1
 80051ac:	881b      	ldrh	r3, [r3, #0]
 80051ae:	2b00      	cmp	r3, #0
 80051b0:	d100      	bne.n	80051b4 <mqtt_output_send+0x78>
 80051b2:	e0a9      	b.n	8005308 <mqtt_output_send+0x1cc>
 80051b4:	240a      	movs	r4, #10
 80051b6:	193b      	adds	r3, r7, r4
 80051b8:	881b      	ldrh	r3, [r3, #0]
 80051ba:	2b00      	cmp	r3, #0
 80051bc:	d100      	bne.n	80051c0 <mqtt_output_send+0x84>
 80051be:	e0a3      	b.n	8005308 <mqtt_output_send+0x1cc>
  }

  LWIP_DEBUGF(MQTT_DEBUG_TRACE, ("mqtt_output_send: tcp_sndbuf: %d bytes, ringbuf_linear_available: %d, get %d, put %d\n",
                                 send_len, ringbuf_lin_len, rb->get, rb->put));

  if (send_len > ringbuf_lin_len) {
 80051c0:	187a      	adds	r2, r7, r1
 80051c2:	193b      	adds	r3, r7, r4
 80051c4:	8812      	ldrh	r2, [r2, #0]
 80051c6:	881b      	ldrh	r3, [r3, #0]
 80051c8:	429a      	cmp	r2, r3
 80051ca:	d912      	bls.n	80051f2 <mqtt_output_send+0xb6>
    /* Space in TCP output buffer is larger than available in ring buffer linear portion */
    send_len = ringbuf_lin_len;
 80051cc:	187b      	adds	r3, r7, r1
 80051ce:	193a      	adds	r2, r7, r4
 80051d0:	8812      	ldrh	r2, [r2, #0]
 80051d2:	801a      	strh	r2, [r3, #0]
    /* Wrap around if more data in ring buffer after linear portion */
    wrap = (mqtt_ringbuf_len(rb) > ringbuf_lin_len);
 80051d4:	687b      	ldr	r3, [r7, #4]
 80051d6:	0018      	movs	r0, r3
 80051d8:	f7ff ff96 	bl	8005108 <mqtt_ringbuf_len>
 80051dc:	0003      	movs	r3, r0
 80051de:	001a      	movs	r2, r3
 80051e0:	193b      	adds	r3, r7, r4
 80051e2:	881b      	ldrh	r3, [r3, #0]
 80051e4:	4293      	cmp	r3, r2
 80051e6:	419b      	sbcs	r3, r3
 80051e8:	425b      	negs	r3, r3
 80051ea:	b2da      	uxtb	r2, r3
 80051ec:	230c      	movs	r3, #12
 80051ee:	18fb      	adds	r3, r7, r3
 80051f0:	701a      	strb	r2, [r3, #0]
  }
  err = altcp_write(tpcb, mqtt_ringbuf_get_ptr(rb), send_len, TCP_WRITE_FLAG_COPY | (wrap ? TCP_WRITE_FLAG_MORE : 0));
 80051f2:	687b      	ldr	r3, [r7, #4]
 80051f4:	0018      	movs	r0, r3
 80051f6:	f7ff ff4b 	bl	8005090 <mqtt_ringbuf_get_ptr>
 80051fa:	0001      	movs	r1, r0
 80051fc:	230c      	movs	r3, #12
 80051fe:	18fb      	adds	r3, r7, r3
 8005200:	781b      	ldrb	r3, [r3, #0]
 8005202:	2b00      	cmp	r3, #0
 8005204:	d001      	beq.n	800520a <mqtt_output_send+0xce>
 8005206:	2303      	movs	r3, #3
 8005208:	e000      	b.n	800520c <mqtt_output_send+0xd0>
 800520a:	2301      	movs	r3, #1
 800520c:	250d      	movs	r5, #13
 800520e:	197c      	adds	r4, r7, r5
 8005210:	260e      	movs	r6, #14
 8005212:	19ba      	adds	r2, r7, r6
 8005214:	8812      	ldrh	r2, [r2, #0]
 8005216:	6838      	ldr	r0, [r7, #0]
 8005218:	f00a ffb0 	bl	801017c <tcp_write>
 800521c:	0003      	movs	r3, r0
 800521e:	7023      	strb	r3, [r4, #0]
  if ((err == ERR_OK) && wrap) {
 8005220:	197b      	adds	r3, r7, r5
 8005222:	781b      	ldrb	r3, [r3, #0]
 8005224:	b25b      	sxtb	r3, r3
 8005226:	2b00      	cmp	r3, #0
 8005228:	d15b      	bne.n	80052e2 <mqtt_output_send+0x1a6>
 800522a:	230c      	movs	r3, #12
 800522c:	18fb      	adds	r3, r7, r3
 800522e:	781b      	ldrb	r3, [r3, #0]
 8005230:	2b00      	cmp	r3, #0
 8005232:	d056      	beq.n	80052e2 <mqtt_output_send+0x1a6>
    mqtt_ringbuf_advance_get_idx(rb, send_len);
 8005234:	19bb      	adds	r3, r7, r6
 8005236:	881a      	ldrh	r2, [r3, #0]
 8005238:	687b      	ldr	r3, [r7, #4]
 800523a:	0011      	movs	r1, r2
 800523c:	0018      	movs	r0, r3
 800523e:	f7ff ff35 	bl	80050ac <mqtt_ringbuf_advance_get_idx>
    /* Use the lesser one of ring buffer linear length and TCP send buffer size */
    send_len = LWIP_MIN(altcp_sndbuf(tpcb), mqtt_ringbuf_linear_read_length(rb));
 8005242:	683b      	ldr	r3, [r7, #0]
 8005244:	2268      	movs	r2, #104	; 0x68
 8005246:	5a9b      	ldrh	r3, [r3, r2]
 8005248:	001c      	movs	r4, r3
 800524a:	687b      	ldr	r3, [r7, #4]
 800524c:	0018      	movs	r0, r3
 800524e:	f7ff ff5b 	bl	8005108 <mqtt_ringbuf_len>
 8005252:	0003      	movs	r3, r0
 8005254:	001a      	movs	r2, r3
 8005256:	687b      	ldr	r3, [r7, #4]
 8005258:	885b      	ldrh	r3, [r3, #2]
 800525a:	0019      	movs	r1, r3
 800525c:	2380      	movs	r3, #128	; 0x80
 800525e:	005b      	lsls	r3, r3, #1
 8005260:	1a5b      	subs	r3, r3, r1
 8005262:	429a      	cmp	r2, r3
 8005264:	da05      	bge.n	8005272 <mqtt_output_send+0x136>
 8005266:	687b      	ldr	r3, [r7, #4]
 8005268:	0018      	movs	r0, r3
 800526a:	f7ff ff4d 	bl	8005108 <mqtt_ringbuf_len>
 800526e:	0003      	movs	r3, r0
 8005270:	e005      	b.n	800527e <mqtt_output_send+0x142>
 8005272:	687b      	ldr	r3, [r7, #4]
 8005274:	885b      	ldrh	r3, [r3, #2]
 8005276:	001a      	movs	r2, r3
 8005278:	2380      	movs	r3, #128	; 0x80
 800527a:	005b      	lsls	r3, r3, #1
 800527c:	1a9b      	subs	r3, r3, r2
 800527e:	42a3      	cmp	r3, r4
 8005280:	dd03      	ble.n	800528a <mqtt_output_send+0x14e>
 8005282:	683b      	ldr	r3, [r7, #0]
 8005284:	2268      	movs	r2, #104	; 0x68
 8005286:	5a9b      	ldrh	r3, [r3, r2]
 8005288:	e019      	b.n	80052be <mqtt_output_send+0x182>
 800528a:	687b      	ldr	r3, [r7, #4]
 800528c:	0018      	movs	r0, r3
 800528e:	f7ff ff3b 	bl	8005108 <mqtt_ringbuf_len>
 8005292:	0003      	movs	r3, r0
 8005294:	001a      	movs	r2, r3
 8005296:	687b      	ldr	r3, [r7, #4]
 8005298:	885b      	ldrh	r3, [r3, #2]
 800529a:	0019      	movs	r1, r3
 800529c:	2380      	movs	r3, #128	; 0x80
 800529e:	005b      	lsls	r3, r3, #1
 80052a0:	1a5b      	subs	r3, r3, r1
 80052a2:	429a      	cmp	r2, r3
 80052a4:	da05      	bge.n	80052b2 <mqtt_output_send+0x176>
 80052a6:	687b      	ldr	r3, [r7, #4]
 80052a8:	0018      	movs	r0, r3
 80052aa:	f7ff ff2d 	bl	8005108 <mqtt_ringbuf_len>
 80052ae:	0003      	movs	r3, r0
 80052b0:	e005      	b.n	80052be <mqtt_output_send+0x182>
 80052b2:	687b      	ldr	r3, [r7, #4]
 80052b4:	885b      	ldrh	r3, [r3, #2]
 80052b6:	2280      	movs	r2, #128	; 0x80
 80052b8:	0052      	lsls	r2, r2, #1
 80052ba:	1ad3      	subs	r3, r2, r3
 80052bc:	b29b      	uxth	r3, r3
 80052be:	250e      	movs	r5, #14
 80052c0:	197a      	adds	r2, r7, r5
 80052c2:	8013      	strh	r3, [r2, #0]
    err = altcp_write(tpcb, mqtt_ringbuf_get_ptr(rb), send_len, TCP_WRITE_FLAG_COPY);
 80052c4:	687b      	ldr	r3, [r7, #4]
 80052c6:	0018      	movs	r0, r3
 80052c8:	f7ff fee2 	bl	8005090 <mqtt_ringbuf_get_ptr>
 80052cc:	0001      	movs	r1, r0
 80052ce:	230d      	movs	r3, #13
 80052d0:	18fc      	adds	r4, r7, r3
 80052d2:	197b      	adds	r3, r7, r5
 80052d4:	881a      	ldrh	r2, [r3, #0]
 80052d6:	6838      	ldr	r0, [r7, #0]
 80052d8:	2301      	movs	r3, #1
 80052da:	f00a ff4f 	bl	801017c <tcp_write>
 80052de:	0003      	movs	r3, r0
 80052e0:	7023      	strb	r3, [r4, #0]
  }

  if (err == ERR_OK) {
 80052e2:	230d      	movs	r3, #13
 80052e4:	18fb      	adds	r3, r7, r3
 80052e6:	781b      	ldrb	r3, [r3, #0]
 80052e8:	b25b      	sxtb	r3, r3
 80052ea:	2b00      	cmp	r3, #0
 80052ec:	d10d      	bne.n	800530a <mqtt_output_send+0x1ce>
    mqtt_ringbuf_advance_get_idx(rb, send_len);
 80052ee:	230e      	movs	r3, #14
 80052f0:	18fb      	adds	r3, r7, r3
 80052f2:	881a      	ldrh	r2, [r3, #0]
 80052f4:	687b      	ldr	r3, [r7, #4]
 80052f6:	0011      	movs	r1, r2
 80052f8:	0018      	movs	r0, r3
 80052fa:	f7ff fed7 	bl	80050ac <mqtt_ringbuf_advance_get_idx>
    /* Flush */
    altcp_output(tpcb);
 80052fe:	683b      	ldr	r3, [r7, #0]
 8005300:	0018      	movs	r0, r3
 8005302:	f00c f843 	bl	801138c <tcp_output>
 8005306:	e000      	b.n	800530a <mqtt_output_send+0x1ce>
    return;
 8005308:	46c0      	nop			; (mov r8, r8)
  } else {
    LWIP_DEBUGF(MQTT_DEBUG_WARN, ("mqtt_output_send: Send failed with err %d (\"%s\")\n", err, lwip_strerr(err)));
  }
}
 800530a:	46bd      	mov	sp, r7
 800530c:	b005      	add	sp, #20
 800530e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005310:	0801f5e8 	.word	0x0801f5e8
 8005314:	0801f680 	.word	0x0801f680
 8005318:	0801f654 	.word	0x0801f654

0800531c <mqtt_create_request>:
 * @param arg Parameter following callback
 * @return Request or NULL if failed to create
 */
static struct mqtt_request_t *
mqtt_create_request(struct mqtt_request_t *r_objs, size_t r_objs_len, u16_t pkt_id, mqtt_request_cb_t cb, void *arg)
{
 800531c:	b580      	push	{r7, lr}
 800531e:	b086      	sub	sp, #24
 8005320:	af00      	add	r7, sp, #0
 8005322:	60f8      	str	r0, [r7, #12]
 8005324:	60b9      	str	r1, [r7, #8]
 8005326:	603b      	str	r3, [r7, #0]
 8005328:	1dbb      	adds	r3, r7, #6
 800532a:	801a      	strh	r2, [r3, #0]
  struct mqtt_request_t *r = NULL;
 800532c:	2300      	movs	r3, #0
 800532e:	617b      	str	r3, [r7, #20]
  u8_t n;
  LWIP_ASSERT("mqtt_create_request: r_objs != NULL", r_objs != NULL);
 8005330:	68fb      	ldr	r3, [r7, #12]
 8005332:	2b00      	cmp	r3, #0
 8005334:	d106      	bne.n	8005344 <mqtt_create_request+0x28>
 8005336:	4b1f      	ldr	r3, [pc, #124]	; (80053b4 <mqtt_create_request+0x98>)
 8005338:	2224      	movs	r2, #36	; 0x24
 800533a:	32ff      	adds	r2, #255	; 0xff
 800533c:	491e      	ldr	r1, [pc, #120]	; (80053b8 <mqtt_create_request+0x9c>)
 800533e:	481f      	ldr	r0, [pc, #124]	; (80053bc <mqtt_create_request+0xa0>)
 8005340:	f7fc ff50 	bl	80021e4 <app_debug_rtt_raw>
  for (n = 0; n < r_objs_len; n++) {
 8005344:	2313      	movs	r3, #19
 8005346:	18fb      	adds	r3, r7, r3
 8005348:	2200      	movs	r2, #0
 800534a:	701a      	strb	r2, [r3, #0]
 800534c:	e027      	b.n	800539e <mqtt_create_request+0x82>
    /* Item point to itself if not in use */
    if (r_objs[n].next == &r_objs[n]) {
 800534e:	2013      	movs	r0, #19
 8005350:	183b      	adds	r3, r7, r0
 8005352:	781b      	ldrb	r3, [r3, #0]
 8005354:	011b      	lsls	r3, r3, #4
 8005356:	68fa      	ldr	r2, [r7, #12]
 8005358:	18d3      	adds	r3, r2, r3
 800535a:	681a      	ldr	r2, [r3, #0]
 800535c:	183b      	adds	r3, r7, r0
 800535e:	781b      	ldrb	r3, [r3, #0]
 8005360:	011b      	lsls	r3, r3, #4
 8005362:	68f9      	ldr	r1, [r7, #12]
 8005364:	18cb      	adds	r3, r1, r3
 8005366:	429a      	cmp	r2, r3
 8005368:	d113      	bne.n	8005392 <mqtt_create_request+0x76>
      r = &r_objs[n];
 800536a:	183b      	adds	r3, r7, r0
 800536c:	781b      	ldrb	r3, [r3, #0]
 800536e:	011b      	lsls	r3, r3, #4
 8005370:	68fa      	ldr	r2, [r7, #12]
 8005372:	18d3      	adds	r3, r2, r3
 8005374:	617b      	str	r3, [r7, #20]
      r->next = NULL;
 8005376:	697b      	ldr	r3, [r7, #20]
 8005378:	2200      	movs	r2, #0
 800537a:	601a      	str	r2, [r3, #0]
      r->cb = cb;
 800537c:	697b      	ldr	r3, [r7, #20]
 800537e:	683a      	ldr	r2, [r7, #0]
 8005380:	605a      	str	r2, [r3, #4]
      r->arg = arg;
 8005382:	697b      	ldr	r3, [r7, #20]
 8005384:	6a3a      	ldr	r2, [r7, #32]
 8005386:	609a      	str	r2, [r3, #8]
      r->pkt_id = pkt_id;
 8005388:	697b      	ldr	r3, [r7, #20]
 800538a:	1dba      	adds	r2, r7, #6
 800538c:	8812      	ldrh	r2, [r2, #0]
 800538e:	819a      	strh	r2, [r3, #12]
      break;
 8005390:	e00b      	b.n	80053aa <mqtt_create_request+0x8e>
  for (n = 0; n < r_objs_len; n++) {
 8005392:	2113      	movs	r1, #19
 8005394:	187b      	adds	r3, r7, r1
 8005396:	781a      	ldrb	r2, [r3, #0]
 8005398:	187b      	adds	r3, r7, r1
 800539a:	3201      	adds	r2, #1
 800539c:	701a      	strb	r2, [r3, #0]
 800539e:	2313      	movs	r3, #19
 80053a0:	18fb      	adds	r3, r7, r3
 80053a2:	781b      	ldrb	r3, [r3, #0]
 80053a4:	68ba      	ldr	r2, [r7, #8]
 80053a6:	429a      	cmp	r2, r3
 80053a8:	d8d1      	bhi.n	800534e <mqtt_create_request+0x32>
    }
  }
  return r;
 80053aa:	697b      	ldr	r3, [r7, #20]
}
 80053ac:	0018      	movs	r0, r3
 80053ae:	46bd      	mov	sp, r7
 80053b0:	b006      	add	sp, #24
 80053b2:	bd80      	pop	{r7, pc}
 80053b4:	0801f5e8 	.word	0x0801f5e8
 80053b8:	0801f6a0 	.word	0x0801f6a0
 80053bc:	0801f654 	.word	0x0801f654

080053c0 <mqtt_append_request>:
 * @param tail Pointer to request queue tail pointer
 * @param r Request to append
 */
static void
mqtt_append_request(struct mqtt_request_t **tail, struct mqtt_request_t *r)
{
 80053c0:	b580      	push	{r7, lr}
 80053c2:	b086      	sub	sp, #24
 80053c4:	af00      	add	r7, sp, #0
 80053c6:	6078      	str	r0, [r7, #4]
 80053c8:	6039      	str	r1, [r7, #0]
  struct mqtt_request_t *head = NULL;
 80053ca:	2300      	movs	r3, #0
 80053cc:	617b      	str	r3, [r7, #20]
  s16_t time_before = 0;
 80053ce:	2312      	movs	r3, #18
 80053d0:	18fb      	adds	r3, r7, r3
 80053d2:	2200      	movs	r2, #0
 80053d4:	801a      	strh	r2, [r3, #0]
  struct mqtt_request_t *iter;

  LWIP_ASSERT("mqtt_append_request: tail != NULL", tail != NULL);
 80053d6:	687b      	ldr	r3, [r7, #4]
 80053d8:	2b00      	cmp	r3, #0
 80053da:	d106      	bne.n	80053ea <mqtt_append_request+0x2a>
 80053dc:	4b1f      	ldr	r3, [pc, #124]	; (800545c <mqtt_append_request+0x9c>)
 80053de:	2240      	movs	r2, #64	; 0x40
 80053e0:	32ff      	adds	r2, #255	; 0xff
 80053e2:	491f      	ldr	r1, [pc, #124]	; (8005460 <mqtt_append_request+0xa0>)
 80053e4:	481f      	ldr	r0, [pc, #124]	; (8005464 <mqtt_append_request+0xa4>)
 80053e6:	f7fc fefd 	bl	80021e4 <app_debug_rtt_raw>

  /* Iterate trough queue to find head, and count total timeout time */
  for (iter = *tail; iter != NULL; iter = iter->next) {
 80053ea:	687b      	ldr	r3, [r7, #4]
 80053ec:	681b      	ldr	r3, [r3, #0]
 80053ee:	60fb      	str	r3, [r7, #12]
 80053f0:	e00d      	b.n	800540e <mqtt_append_request+0x4e>
    time_before += iter->timeout_diff;
 80053f2:	68fb      	ldr	r3, [r7, #12]
 80053f4:	89da      	ldrh	r2, [r3, #14]
 80053f6:	2112      	movs	r1, #18
 80053f8:	187b      	adds	r3, r7, r1
 80053fa:	881b      	ldrh	r3, [r3, #0]
 80053fc:	18d3      	adds	r3, r2, r3
 80053fe:	b29a      	uxth	r2, r3
 8005400:	187b      	adds	r3, r7, r1
 8005402:	801a      	strh	r2, [r3, #0]
    head = iter;
 8005404:	68fb      	ldr	r3, [r7, #12]
 8005406:	617b      	str	r3, [r7, #20]
  for (iter = *tail; iter != NULL; iter = iter->next) {
 8005408:	68fb      	ldr	r3, [r7, #12]
 800540a:	681b      	ldr	r3, [r3, #0]
 800540c:	60fb      	str	r3, [r7, #12]
 800540e:	68fb      	ldr	r3, [r7, #12]
 8005410:	2b00      	cmp	r3, #0
 8005412:	d1ee      	bne.n	80053f2 <mqtt_append_request+0x32>
  }

  LWIP_ASSERT("mqtt_append_request: time_before <= MQTT_REQ_TIMEOUT", time_before <= MQTT_REQ_TIMEOUT);
 8005414:	2312      	movs	r3, #18
 8005416:	18fb      	adds	r3, r7, r3
 8005418:	2200      	movs	r2, #0
 800541a:	5e9b      	ldrsh	r3, [r3, r2]
 800541c:	2b1e      	cmp	r3, #30
 800541e:	dd06      	ble.n	800542e <mqtt_append_request+0x6e>
 8005420:	4b0e      	ldr	r3, [pc, #56]	; (800545c <mqtt_append_request+0x9c>)
 8005422:	2248      	movs	r2, #72	; 0x48
 8005424:	32ff      	adds	r2, #255	; 0xff
 8005426:	4910      	ldr	r1, [pc, #64]	; (8005468 <mqtt_append_request+0xa8>)
 8005428:	480e      	ldr	r0, [pc, #56]	; (8005464 <mqtt_append_request+0xa4>)
 800542a:	f7fc fedb 	bl	80021e4 <app_debug_rtt_raw>
  r->timeout_diff = MQTT_REQ_TIMEOUT - time_before;
 800542e:	2312      	movs	r3, #18
 8005430:	18fb      	adds	r3, r7, r3
 8005432:	881b      	ldrh	r3, [r3, #0]
 8005434:	221e      	movs	r2, #30
 8005436:	1ad3      	subs	r3, r2, r3
 8005438:	b29a      	uxth	r2, r3
 800543a:	683b      	ldr	r3, [r7, #0]
 800543c:	81da      	strh	r2, [r3, #14]
  if (head == NULL) {
 800543e:	697b      	ldr	r3, [r7, #20]
 8005440:	2b00      	cmp	r3, #0
 8005442:	d103      	bne.n	800544c <mqtt_append_request+0x8c>
    *tail = r;
 8005444:	687b      	ldr	r3, [r7, #4]
 8005446:	683a      	ldr	r2, [r7, #0]
 8005448:	601a      	str	r2, [r3, #0]
  } else {
    head->next = r;
  }
}
 800544a:	e002      	b.n	8005452 <mqtt_append_request+0x92>
    head->next = r;
 800544c:	697b      	ldr	r3, [r7, #20]
 800544e:	683a      	ldr	r2, [r7, #0]
 8005450:	601a      	str	r2, [r3, #0]
}
 8005452:	46c0      	nop			; (mov r8, r8)
 8005454:	46bd      	mov	sp, r7
 8005456:	b006      	add	sp, #24
 8005458:	bd80      	pop	{r7, pc}
 800545a:	46c0      	nop			; (mov r8, r8)
 800545c:	0801f5e8 	.word	0x0801f5e8
 8005460:	0801f6c4 	.word	0x0801f6c4
 8005464:	0801f654 	.word	0x0801f654
 8005468:	0801f6e8 	.word	0x0801f6e8

0800546c <mqtt_delete_request>:
 * Delete request item
 * @param r Request item to delete
 */
static void
mqtt_delete_request(struct mqtt_request_t *r)
{
 800546c:	b580      	push	{r7, lr}
 800546e:	b082      	sub	sp, #8
 8005470:	af00      	add	r7, sp, #0
 8005472:	6078      	str	r0, [r7, #4]
  if (r != NULL) {
 8005474:	687b      	ldr	r3, [r7, #4]
 8005476:	2b00      	cmp	r3, #0
 8005478:	d002      	beq.n	8005480 <mqtt_delete_request+0x14>
    r->next = r;
 800547a:	687b      	ldr	r3, [r7, #4]
 800547c:	687a      	ldr	r2, [r7, #4]
 800547e:	601a      	str	r2, [r3, #0]
  }
}
 8005480:	46c0      	nop			; (mov r8, r8)
 8005482:	46bd      	mov	sp, r7
 8005484:	b002      	add	sp, #8
 8005486:	bd80      	pop	{r7, pc}

08005488 <mqtt_take_request>:
 * @param pkt_id Packet identifier of request to take
 * @return Request item if found, NULL if not
 */
static struct mqtt_request_t *
mqtt_take_request(struct mqtt_request_t **tail, u16_t pkt_id)
{
 8005488:	b580      	push	{r7, lr}
 800548a:	b084      	sub	sp, #16
 800548c:	af00      	add	r7, sp, #0
 800548e:	6078      	str	r0, [r7, #4]
 8005490:	000a      	movs	r2, r1
 8005492:	1cbb      	adds	r3, r7, #2
 8005494:	801a      	strh	r2, [r3, #0]
  struct mqtt_request_t *iter = NULL, *prev = NULL;
 8005496:	2300      	movs	r3, #0
 8005498:	60fb      	str	r3, [r7, #12]
 800549a:	2300      	movs	r3, #0
 800549c:	60bb      	str	r3, [r7, #8]
  LWIP_ASSERT("mqtt_take_request: tail != NULL", tail != NULL);
 800549e:	687b      	ldr	r3, [r7, #4]
 80054a0:	2b00      	cmp	r3, #0
 80054a2:	d106      	bne.n	80054b2 <mqtt_take_request+0x2a>
 80054a4:	4b1f      	ldr	r3, [pc, #124]	; (8005524 <mqtt_take_request+0x9c>)
 80054a6:	2268      	movs	r2, #104	; 0x68
 80054a8:	32ff      	adds	r2, #255	; 0xff
 80054aa:	491f      	ldr	r1, [pc, #124]	; (8005528 <mqtt_take_request+0xa0>)
 80054ac:	481f      	ldr	r0, [pc, #124]	; (800552c <mqtt_take_request+0xa4>)
 80054ae:	f7fc fe99 	bl	80021e4 <app_debug_rtt_raw>
  /* Search all request for pkt_id */
  for (iter = *tail; iter != NULL; iter = iter->next) {
 80054b2:	687b      	ldr	r3, [r7, #4]
 80054b4:	681b      	ldr	r3, [r3, #0]
 80054b6:	60fb      	str	r3, [r7, #12]
 80054b8:	e00a      	b.n	80054d0 <mqtt_take_request+0x48>
    if (iter->pkt_id == pkt_id) {
 80054ba:	68fb      	ldr	r3, [r7, #12]
 80054bc:	899b      	ldrh	r3, [r3, #12]
 80054be:	1cba      	adds	r2, r7, #2
 80054c0:	8812      	ldrh	r2, [r2, #0]
 80054c2:	429a      	cmp	r2, r3
 80054c4:	d008      	beq.n	80054d8 <mqtt_take_request+0x50>
      break;
    }
    prev = iter;
 80054c6:	68fb      	ldr	r3, [r7, #12]
 80054c8:	60bb      	str	r3, [r7, #8]
  for (iter = *tail; iter != NULL; iter = iter->next) {
 80054ca:	68fb      	ldr	r3, [r7, #12]
 80054cc:	681b      	ldr	r3, [r3, #0]
 80054ce:	60fb      	str	r3, [r7, #12]
 80054d0:	68fb      	ldr	r3, [r7, #12]
 80054d2:	2b00      	cmp	r3, #0
 80054d4:	d1f1      	bne.n	80054ba <mqtt_take_request+0x32>
 80054d6:	e000      	b.n	80054da <mqtt_take_request+0x52>
      break;
 80054d8:	46c0      	nop			; (mov r8, r8)
  }

  /* If request was found */
  if (iter != NULL) {
 80054da:	68fb      	ldr	r3, [r7, #12]
 80054dc:	2b00      	cmp	r3, #0
 80054de:	d01c      	beq.n	800551a <mqtt_take_request+0x92>
    /* unchain */
    if (prev == NULL) {
 80054e0:	68bb      	ldr	r3, [r7, #8]
 80054e2:	2b00      	cmp	r3, #0
 80054e4:	d104      	bne.n	80054f0 <mqtt_take_request+0x68>
      *tail = iter->next;
 80054e6:	68fb      	ldr	r3, [r7, #12]
 80054e8:	681a      	ldr	r2, [r3, #0]
 80054ea:	687b      	ldr	r3, [r7, #4]
 80054ec:	601a      	str	r2, [r3, #0]
 80054ee:	e003      	b.n	80054f8 <mqtt_take_request+0x70>
    } else {
      prev->next = iter->next;
 80054f0:	68fb      	ldr	r3, [r7, #12]
 80054f2:	681a      	ldr	r2, [r3, #0]
 80054f4:	68bb      	ldr	r3, [r7, #8]
 80054f6:	601a      	str	r2, [r3, #0]
    }
    /* If exists, add remaining timeout time for the request to next */
    if (iter->next != NULL) {
 80054f8:	68fb      	ldr	r3, [r7, #12]
 80054fa:	681b      	ldr	r3, [r3, #0]
 80054fc:	2b00      	cmp	r3, #0
 80054fe:	d009      	beq.n	8005514 <mqtt_take_request+0x8c>
      iter->next->timeout_diff += iter->timeout_diff;
 8005500:	68fb      	ldr	r3, [r7, #12]
 8005502:	681b      	ldr	r3, [r3, #0]
 8005504:	89d9      	ldrh	r1, [r3, #14]
 8005506:	68fb      	ldr	r3, [r7, #12]
 8005508:	89da      	ldrh	r2, [r3, #14]
 800550a:	68fb      	ldr	r3, [r7, #12]
 800550c:	681b      	ldr	r3, [r3, #0]
 800550e:	188a      	adds	r2, r1, r2
 8005510:	b292      	uxth	r2, r2
 8005512:	81da      	strh	r2, [r3, #14]
    }
    iter->next = NULL;
 8005514:	68fb      	ldr	r3, [r7, #12]
 8005516:	2200      	movs	r2, #0
 8005518:	601a      	str	r2, [r3, #0]
  }
  return iter;
 800551a:	68fb      	ldr	r3, [r7, #12]
}
 800551c:	0018      	movs	r0, r3
 800551e:	46bd      	mov	sp, r7
 8005520:	b004      	add	sp, #16
 8005522:	bd80      	pop	{r7, pc}
 8005524:	0801f5e8 	.word	0x0801f5e8
 8005528:	0801f720 	.word	0x0801f720
 800552c:	0801f654 	.word	0x0801f654

08005530 <mqtt_request_time_elapsed>:
 * @param tail Pointer to request queue tail pointer
 * @param t Time since last call in seconds
 */
static void
mqtt_request_time_elapsed(struct mqtt_request_t **tail, u8_t t)
{
 8005530:	b580      	push	{r7, lr}
 8005532:	b084      	sub	sp, #16
 8005534:	af00      	add	r7, sp, #0
 8005536:	6078      	str	r0, [r7, #4]
 8005538:	000a      	movs	r2, r1
 800553a:	1cfb      	adds	r3, r7, #3
 800553c:	701a      	strb	r2, [r3, #0]
  struct mqtt_request_t *r;
  LWIP_ASSERT("mqtt_request_time_elapsed: tail != NULL", tail != NULL);
 800553e:	687b      	ldr	r3, [r7, #4]
 8005540:	2b00      	cmp	r3, #0
 8005542:	d106      	bne.n	8005552 <mqtt_request_time_elapsed+0x22>
 8005544:	4b24      	ldr	r3, [pc, #144]	; (80055d8 <mqtt_request_time_elapsed+0xa8>)
 8005546:	22c5      	movs	r2, #197	; 0xc5
 8005548:	0052      	lsls	r2, r2, #1
 800554a:	4924      	ldr	r1, [pc, #144]	; (80055dc <mqtt_request_time_elapsed+0xac>)
 800554c:	4824      	ldr	r0, [pc, #144]	; (80055e0 <mqtt_request_time_elapsed+0xb0>)
 800554e:	f7fc fe49 	bl	80021e4 <app_debug_rtt_raw>
  r = *tail;
 8005552:	687b      	ldr	r3, [r7, #4]
 8005554:	681b      	ldr	r3, [r3, #0]
 8005556:	60fb      	str	r3, [r7, #12]
  while (t > 0 && r != NULL) {
 8005558:	e032      	b.n	80055c0 <mqtt_request_time_elapsed+0x90>
    if (t >= r->timeout_diff) {
 800555a:	1cfb      	adds	r3, r7, #3
 800555c:	781b      	ldrb	r3, [r3, #0]
 800555e:	b29a      	uxth	r2, r3
 8005560:	68fb      	ldr	r3, [r7, #12]
 8005562:	89db      	ldrh	r3, [r3, #14]
 8005564:	429a      	cmp	r2, r3
 8005566:	d31f      	bcc.n	80055a8 <mqtt_request_time_elapsed+0x78>
      t -= (u8_t)r->timeout_diff;
 8005568:	68fb      	ldr	r3, [r7, #12]
 800556a:	89db      	ldrh	r3, [r3, #14]
 800556c:	b2da      	uxtb	r2, r3
 800556e:	1cfb      	adds	r3, r7, #3
 8005570:	1cf9      	adds	r1, r7, #3
 8005572:	7809      	ldrb	r1, [r1, #0]
 8005574:	1a8a      	subs	r2, r1, r2
 8005576:	701a      	strb	r2, [r3, #0]
      /* Unchain */
      *tail = r->next;
 8005578:	68fb      	ldr	r3, [r7, #12]
 800557a:	681a      	ldr	r2, [r3, #0]
 800557c:	687b      	ldr	r3, [r7, #4]
 800557e:	601a      	str	r2, [r3, #0]
      /* Notify upper layer about timeout */
      if (r->cb != NULL) {
 8005580:	68fb      	ldr	r3, [r7, #12]
 8005582:	685b      	ldr	r3, [r3, #4]
 8005584:	2b00      	cmp	r3, #0
 8005586:	d007      	beq.n	8005598 <mqtt_request_time_elapsed+0x68>
        r->cb(r->arg, ERR_TIMEOUT);
 8005588:	68fb      	ldr	r3, [r7, #12]
 800558a:	685a      	ldr	r2, [r3, #4]
 800558c:	68fb      	ldr	r3, [r7, #12]
 800558e:	689b      	ldr	r3, [r3, #8]
 8005590:	2103      	movs	r1, #3
 8005592:	4249      	negs	r1, r1
 8005594:	0018      	movs	r0, r3
 8005596:	4790      	blx	r2
      }
      mqtt_delete_request(r);
 8005598:	68fb      	ldr	r3, [r7, #12]
 800559a:	0018      	movs	r0, r3
 800559c:	f7ff ff66 	bl	800546c <mqtt_delete_request>
      /* Tail might be be modified in callback, so re-read it in every iteration */
      r = *(struct mqtt_request_t *const volatile *)tail;
 80055a0:	687b      	ldr	r3, [r7, #4]
 80055a2:	681b      	ldr	r3, [r3, #0]
 80055a4:	60fb      	str	r3, [r7, #12]
 80055a6:	e00b      	b.n	80055c0 <mqtt_request_time_elapsed+0x90>
    } else {
      r->timeout_diff -= t;
 80055a8:	68fb      	ldr	r3, [r7, #12]
 80055aa:	89da      	ldrh	r2, [r3, #14]
 80055ac:	1cfb      	adds	r3, r7, #3
 80055ae:	781b      	ldrb	r3, [r3, #0]
 80055b0:	b29b      	uxth	r3, r3
 80055b2:	1ad3      	subs	r3, r2, r3
 80055b4:	b29a      	uxth	r2, r3
 80055b6:	68fb      	ldr	r3, [r7, #12]
 80055b8:	81da      	strh	r2, [r3, #14]
      t = 0;
 80055ba:	1cfb      	adds	r3, r7, #3
 80055bc:	2200      	movs	r2, #0
 80055be:	701a      	strb	r2, [r3, #0]
  while (t > 0 && r != NULL) {
 80055c0:	1cfb      	adds	r3, r7, #3
 80055c2:	781b      	ldrb	r3, [r3, #0]
 80055c4:	2b00      	cmp	r3, #0
 80055c6:	d002      	beq.n	80055ce <mqtt_request_time_elapsed+0x9e>
 80055c8:	68fb      	ldr	r3, [r7, #12]
 80055ca:	2b00      	cmp	r3, #0
 80055cc:	d1c5      	bne.n	800555a <mqtt_request_time_elapsed+0x2a>
    }
  }
}
 80055ce:	46c0      	nop			; (mov r8, r8)
 80055d0:	46bd      	mov	sp, r7
 80055d2:	b004      	add	sp, #16
 80055d4:	bd80      	pop	{r7, pc}
 80055d6:	46c0      	nop			; (mov r8, r8)
 80055d8:	0801f5e8 	.word	0x0801f5e8
 80055dc:	0801f740 	.word	0x0801f740
 80055e0:	0801f654 	.word	0x0801f654

080055e4 <mqtt_clear_requests>:
 * Free all request items
 * @param tail Pointer to request queue tail pointer
 */
static void
mqtt_clear_requests(struct mqtt_request_t **tail)
{
 80055e4:	b580      	push	{r7, lr}
 80055e6:	b084      	sub	sp, #16
 80055e8:	af00      	add	r7, sp, #0
 80055ea:	6078      	str	r0, [r7, #4]
  struct mqtt_request_t *iter, *next;
  LWIP_ASSERT("mqtt_clear_requests: tail != NULL", tail != NULL);
 80055ec:	687b      	ldr	r3, [r7, #4]
 80055ee:	2b00      	cmp	r3, #0
 80055f0:	d106      	bne.n	8005600 <mqtt_clear_requests+0x1c>
 80055f2:	4b0f      	ldr	r3, [pc, #60]	; (8005630 <mqtt_clear_requests+0x4c>)
 80055f4:	22a8      	movs	r2, #168	; 0xa8
 80055f6:	32ff      	adds	r2, #255	; 0xff
 80055f8:	490e      	ldr	r1, [pc, #56]	; (8005634 <mqtt_clear_requests+0x50>)
 80055fa:	480f      	ldr	r0, [pc, #60]	; (8005638 <mqtt_clear_requests+0x54>)
 80055fc:	f7fc fdf2 	bl	80021e4 <app_debug_rtt_raw>
  for (iter = *tail; iter != NULL; iter = next) {
 8005600:	687b      	ldr	r3, [r7, #4]
 8005602:	681b      	ldr	r3, [r3, #0]
 8005604:	60fb      	str	r3, [r7, #12]
 8005606:	e008      	b.n	800561a <mqtt_clear_requests+0x36>
    next = iter->next;
 8005608:	68fb      	ldr	r3, [r7, #12]
 800560a:	681b      	ldr	r3, [r3, #0]
 800560c:	60bb      	str	r3, [r7, #8]
    mqtt_delete_request(iter);
 800560e:	68fb      	ldr	r3, [r7, #12]
 8005610:	0018      	movs	r0, r3
 8005612:	f7ff ff2b 	bl	800546c <mqtt_delete_request>
  for (iter = *tail; iter != NULL; iter = next) {
 8005616:	68bb      	ldr	r3, [r7, #8]
 8005618:	60fb      	str	r3, [r7, #12]
 800561a:	68fb      	ldr	r3, [r7, #12]
 800561c:	2b00      	cmp	r3, #0
 800561e:	d1f3      	bne.n	8005608 <mqtt_clear_requests+0x24>
  }
  *tail = NULL;
 8005620:	687b      	ldr	r3, [r7, #4]
 8005622:	2200      	movs	r2, #0
 8005624:	601a      	str	r2, [r3, #0]
}
 8005626:	46c0      	nop			; (mov r8, r8)
 8005628:	46bd      	mov	sp, r7
 800562a:	b004      	add	sp, #16
 800562c:	bd80      	pop	{r7, pc}
 800562e:	46c0      	nop			; (mov r8, r8)
 8005630:	0801f5e8 	.word	0x0801f5e8
 8005634:	0801f768 	.word	0x0801f768
 8005638:	0801f654 	.word	0x0801f654

0800563c <mqtt_init_requests>:
 * @param r_objs Pointer to request objects
 * @param r_objs_len Number of array entries
 */
static void
mqtt_init_requests(struct mqtt_request_t *r_objs, size_t r_objs_len)
{
 800563c:	b580      	push	{r7, lr}
 800563e:	b084      	sub	sp, #16
 8005640:	af00      	add	r7, sp, #0
 8005642:	6078      	str	r0, [r7, #4]
 8005644:	6039      	str	r1, [r7, #0]
  u8_t n;
  LWIP_ASSERT("mqtt_init_requests: r_objs != NULL", r_objs != NULL);
 8005646:	687b      	ldr	r3, [r7, #4]
 8005648:	2b00      	cmp	r3, #0
 800564a:	d106      	bne.n	800565a <mqtt_init_requests+0x1e>
 800564c:	4b13      	ldr	r3, [pc, #76]	; (800569c <mqtt_init_requests+0x60>)
 800564e:	22b8      	movs	r2, #184	; 0xb8
 8005650:	32ff      	adds	r2, #255	; 0xff
 8005652:	4913      	ldr	r1, [pc, #76]	; (80056a0 <mqtt_init_requests+0x64>)
 8005654:	4813      	ldr	r0, [pc, #76]	; (80056a4 <mqtt_init_requests+0x68>)
 8005656:	f7fc fdc5 	bl	80021e4 <app_debug_rtt_raw>
  for (n = 0; n < r_objs_len; n++) {
 800565a:	230f      	movs	r3, #15
 800565c:	18fb      	adds	r3, r7, r3
 800565e:	2200      	movs	r2, #0
 8005660:	701a      	strb	r2, [r3, #0]
 8005662:	e010      	b.n	8005686 <mqtt_init_requests+0x4a>
    /* Item pointing to itself indicates unused */
    r_objs[n].next = &r_objs[n];
 8005664:	200f      	movs	r0, #15
 8005666:	183b      	adds	r3, r7, r0
 8005668:	781b      	ldrb	r3, [r3, #0]
 800566a:	011a      	lsls	r2, r3, #4
 800566c:	183b      	adds	r3, r7, r0
 800566e:	781b      	ldrb	r3, [r3, #0]
 8005670:	011b      	lsls	r3, r3, #4
 8005672:	6879      	ldr	r1, [r7, #4]
 8005674:	18cb      	adds	r3, r1, r3
 8005676:	6879      	ldr	r1, [r7, #4]
 8005678:	188a      	adds	r2, r1, r2
 800567a:	601a      	str	r2, [r3, #0]
  for (n = 0; n < r_objs_len; n++) {
 800567c:	183b      	adds	r3, r7, r0
 800567e:	781a      	ldrb	r2, [r3, #0]
 8005680:	183b      	adds	r3, r7, r0
 8005682:	3201      	adds	r2, #1
 8005684:	701a      	strb	r2, [r3, #0]
 8005686:	230f      	movs	r3, #15
 8005688:	18fb      	adds	r3, r7, r3
 800568a:	781b      	ldrb	r3, [r3, #0]
 800568c:	683a      	ldr	r2, [r7, #0]
 800568e:	429a      	cmp	r2, r3
 8005690:	d8e8      	bhi.n	8005664 <mqtt_init_requests+0x28>
  }
}
 8005692:	46c0      	nop			; (mov r8, r8)
 8005694:	46c0      	nop			; (mov r8, r8)
 8005696:	46bd      	mov	sp, r7
 8005698:	b004      	add	sp, #16
 800569a:	bd80      	pop	{r7, pc}
 800569c:	0801f5e8 	.word	0x0801f5e8
 80056a0:	0801f78c 	.word	0x0801f78c
 80056a4:	0801f654 	.word	0x0801f654

080056a8 <mqtt_output_append_u8>:
/* Output message build helpers */


static void
mqtt_output_append_u8(struct mqtt_ringbuf_t *rb, u8_t value)
{
 80056a8:	b580      	push	{r7, lr}
 80056aa:	b082      	sub	sp, #8
 80056ac:	af00      	add	r7, sp, #0
 80056ae:	6078      	str	r0, [r7, #4]
 80056b0:	000a      	movs	r2, r1
 80056b2:	1cfb      	adds	r3, r7, #3
 80056b4:	701a      	strb	r2, [r3, #0]
  mqtt_ringbuf_put(rb, value);
 80056b6:	1cfb      	adds	r3, r7, #3
 80056b8:	781a      	ldrb	r2, [r3, #0]
 80056ba:	687b      	ldr	r3, [r7, #4]
 80056bc:	0011      	movs	r1, r2
 80056be:	0018      	movs	r0, r3
 80056c0:	f7ff fcc6 	bl	8005050 <mqtt_ringbuf_put>
}
 80056c4:	46c0      	nop			; (mov r8, r8)
 80056c6:	46bd      	mov	sp, r7
 80056c8:	b002      	add	sp, #8
 80056ca:	bd80      	pop	{r7, pc}

080056cc <mqtt_output_append_u16>:

static
void mqtt_output_append_u16(struct mqtt_ringbuf_t *rb, u16_t value)
{
 80056cc:	b580      	push	{r7, lr}
 80056ce:	b082      	sub	sp, #8
 80056d0:	af00      	add	r7, sp, #0
 80056d2:	6078      	str	r0, [r7, #4]
 80056d4:	000a      	movs	r2, r1
 80056d6:	1cbb      	adds	r3, r7, #2
 80056d8:	801a      	strh	r2, [r3, #0]
  mqtt_ringbuf_put(rb, value >> 8);
 80056da:	1cbb      	adds	r3, r7, #2
 80056dc:	881b      	ldrh	r3, [r3, #0]
 80056de:	0a1b      	lsrs	r3, r3, #8
 80056e0:	b29b      	uxth	r3, r3
 80056e2:	b2da      	uxtb	r2, r3
 80056e4:	687b      	ldr	r3, [r7, #4]
 80056e6:	0011      	movs	r1, r2
 80056e8:	0018      	movs	r0, r3
 80056ea:	f7ff fcb1 	bl	8005050 <mqtt_ringbuf_put>
  mqtt_ringbuf_put(rb, value & 0xff);
 80056ee:	1cbb      	adds	r3, r7, #2
 80056f0:	881b      	ldrh	r3, [r3, #0]
 80056f2:	b2da      	uxtb	r2, r3
 80056f4:	687b      	ldr	r3, [r7, #4]
 80056f6:	0011      	movs	r1, r2
 80056f8:	0018      	movs	r0, r3
 80056fa:	f7ff fca9 	bl	8005050 <mqtt_ringbuf_put>
}
 80056fe:	46c0      	nop			; (mov r8, r8)
 8005700:	46bd      	mov	sp, r7
 8005702:	b002      	add	sp, #8
 8005704:	bd80      	pop	{r7, pc}

08005706 <mqtt_output_append_buf>:

static void
mqtt_output_append_buf(struct mqtt_ringbuf_t *rb, const void *data, u16_t length)
{
 8005706:	b590      	push	{r4, r7, lr}
 8005708:	b087      	sub	sp, #28
 800570a:	af00      	add	r7, sp, #0
 800570c:	60f8      	str	r0, [r7, #12]
 800570e:	60b9      	str	r1, [r7, #8]
 8005710:	1dbb      	adds	r3, r7, #6
 8005712:	801a      	strh	r2, [r3, #0]
  u16_t n;
  for (n = 0; n < length; n++) {
 8005714:	2316      	movs	r3, #22
 8005716:	18fb      	adds	r3, r7, r3
 8005718:	2200      	movs	r2, #0
 800571a:	801a      	strh	r2, [r3, #0]
 800571c:	e00f      	b.n	800573e <mqtt_output_append_buf+0x38>
    mqtt_ringbuf_put(rb, ((const u8_t *)data)[n]);
 800571e:	2416      	movs	r4, #22
 8005720:	193b      	adds	r3, r7, r4
 8005722:	881b      	ldrh	r3, [r3, #0]
 8005724:	68ba      	ldr	r2, [r7, #8]
 8005726:	18d3      	adds	r3, r2, r3
 8005728:	781a      	ldrb	r2, [r3, #0]
 800572a:	68fb      	ldr	r3, [r7, #12]
 800572c:	0011      	movs	r1, r2
 800572e:	0018      	movs	r0, r3
 8005730:	f7ff fc8e 	bl	8005050 <mqtt_ringbuf_put>
  for (n = 0; n < length; n++) {
 8005734:	193b      	adds	r3, r7, r4
 8005736:	881a      	ldrh	r2, [r3, #0]
 8005738:	193b      	adds	r3, r7, r4
 800573a:	3201      	adds	r2, #1
 800573c:	801a      	strh	r2, [r3, #0]
 800573e:	2316      	movs	r3, #22
 8005740:	18fa      	adds	r2, r7, r3
 8005742:	1dbb      	adds	r3, r7, #6
 8005744:	8812      	ldrh	r2, [r2, #0]
 8005746:	881b      	ldrh	r3, [r3, #0]
 8005748:	429a      	cmp	r2, r3
 800574a:	d3e8      	bcc.n	800571e <mqtt_output_append_buf+0x18>
  }
}
 800574c:	46c0      	nop			; (mov r8, r8)
 800574e:	46c0      	nop			; (mov r8, r8)
 8005750:	46bd      	mov	sp, r7
 8005752:	b007      	add	sp, #28
 8005754:	bd90      	pop	{r4, r7, pc}

08005756 <mqtt_output_append_string>:

static void
mqtt_output_append_string(struct mqtt_ringbuf_t *rb, const char *str, u16_t length)
{
 8005756:	b590      	push	{r4, r7, lr}
 8005758:	b087      	sub	sp, #28
 800575a:	af00      	add	r7, sp, #0
 800575c:	60f8      	str	r0, [r7, #12]
 800575e:	60b9      	str	r1, [r7, #8]
 8005760:	1dbb      	adds	r3, r7, #6
 8005762:	801a      	strh	r2, [r3, #0]
  u16_t n;
  mqtt_ringbuf_put(rb, length >> 8);
 8005764:	1dbb      	adds	r3, r7, #6
 8005766:	881b      	ldrh	r3, [r3, #0]
 8005768:	0a1b      	lsrs	r3, r3, #8
 800576a:	b29b      	uxth	r3, r3
 800576c:	b2da      	uxtb	r2, r3
 800576e:	68fb      	ldr	r3, [r7, #12]
 8005770:	0011      	movs	r1, r2
 8005772:	0018      	movs	r0, r3
 8005774:	f7ff fc6c 	bl	8005050 <mqtt_ringbuf_put>
  mqtt_ringbuf_put(rb, length & 0xff);
 8005778:	1dbb      	adds	r3, r7, #6
 800577a:	881b      	ldrh	r3, [r3, #0]
 800577c:	b2da      	uxtb	r2, r3
 800577e:	68fb      	ldr	r3, [r7, #12]
 8005780:	0011      	movs	r1, r2
 8005782:	0018      	movs	r0, r3
 8005784:	f7ff fc64 	bl	8005050 <mqtt_ringbuf_put>
  for (n = 0; n < length; n++) {
 8005788:	2316      	movs	r3, #22
 800578a:	18fb      	adds	r3, r7, r3
 800578c:	2200      	movs	r2, #0
 800578e:	801a      	strh	r2, [r3, #0]
 8005790:	e00f      	b.n	80057b2 <mqtt_output_append_string+0x5c>
    mqtt_ringbuf_put(rb, str[n]);
 8005792:	2416      	movs	r4, #22
 8005794:	193b      	adds	r3, r7, r4
 8005796:	881b      	ldrh	r3, [r3, #0]
 8005798:	68ba      	ldr	r2, [r7, #8]
 800579a:	18d3      	adds	r3, r2, r3
 800579c:	781a      	ldrb	r2, [r3, #0]
 800579e:	68fb      	ldr	r3, [r7, #12]
 80057a0:	0011      	movs	r1, r2
 80057a2:	0018      	movs	r0, r3
 80057a4:	f7ff fc54 	bl	8005050 <mqtt_ringbuf_put>
  for (n = 0; n < length; n++) {
 80057a8:	193b      	adds	r3, r7, r4
 80057aa:	881a      	ldrh	r2, [r3, #0]
 80057ac:	193b      	adds	r3, r7, r4
 80057ae:	3201      	adds	r2, #1
 80057b0:	801a      	strh	r2, [r3, #0]
 80057b2:	2316      	movs	r3, #22
 80057b4:	18fa      	adds	r2, r7, r3
 80057b6:	1dbb      	adds	r3, r7, #6
 80057b8:	8812      	ldrh	r2, [r2, #0]
 80057ba:	881b      	ldrh	r3, [r3, #0]
 80057bc:	429a      	cmp	r2, r3
 80057be:	d3e8      	bcc.n	8005792 <mqtt_output_append_string+0x3c>
  }
}
 80057c0:	46c0      	nop			; (mov r8, r8)
 80057c2:	46c0      	nop			; (mov r8, r8)
 80057c4:	46bd      	mov	sp, r7
 80057c6:	b007      	add	sp, #28
 80057c8:	bd90      	pop	{r4, r7, pc}

080057ca <mqtt_output_append_fixed_header>:
 */

static void
mqtt_output_append_fixed_header(struct mqtt_ringbuf_t *rb, u8_t msg_type, u8_t fdup,
                                u8_t fqos, u8_t fretain, u16_t r_length)
{
 80057ca:	b590      	push	{r4, r7, lr}
 80057cc:	b083      	sub	sp, #12
 80057ce:	af00      	add	r7, sp, #0
 80057d0:	6078      	str	r0, [r7, #4]
 80057d2:	000c      	movs	r4, r1
 80057d4:	0010      	movs	r0, r2
 80057d6:	0019      	movs	r1, r3
 80057d8:	1cfb      	adds	r3, r7, #3
 80057da:	1c22      	adds	r2, r4, #0
 80057dc:	701a      	strb	r2, [r3, #0]
 80057de:	1cbb      	adds	r3, r7, #2
 80057e0:	1c02      	adds	r2, r0, #0
 80057e2:	701a      	strb	r2, [r3, #0]
 80057e4:	1c7b      	adds	r3, r7, #1
 80057e6:	1c0a      	adds	r2, r1, #0
 80057e8:	701a      	strb	r2, [r3, #0]
  /* Start with control byte */
  mqtt_output_append_u8(rb, (((msg_type & 0x0f) << 4) | ((fdup & 1) << 3) | ((fqos & 3) << 1) | (fretain & 1)));
 80057ea:	1cfb      	adds	r3, r7, #3
 80057ec:	781b      	ldrb	r3, [r3, #0]
 80057ee:	011b      	lsls	r3, r3, #4
 80057f0:	b25a      	sxtb	r2, r3
 80057f2:	1cbb      	adds	r3, r7, #2
 80057f4:	781b      	ldrb	r3, [r3, #0]
 80057f6:	00db      	lsls	r3, r3, #3
 80057f8:	b25b      	sxtb	r3, r3
 80057fa:	2108      	movs	r1, #8
 80057fc:	400b      	ands	r3, r1
 80057fe:	b25b      	sxtb	r3, r3
 8005800:	4313      	orrs	r3, r2
 8005802:	b25a      	sxtb	r2, r3
 8005804:	1c7b      	adds	r3, r7, #1
 8005806:	781b      	ldrb	r3, [r3, #0]
 8005808:	005b      	lsls	r3, r3, #1
 800580a:	b25b      	sxtb	r3, r3
 800580c:	2106      	movs	r1, #6
 800580e:	400b      	ands	r3, r1
 8005810:	b25b      	sxtb	r3, r3
 8005812:	4313      	orrs	r3, r2
 8005814:	b25a      	sxtb	r2, r3
 8005816:	2318      	movs	r3, #24
 8005818:	18fb      	adds	r3, r7, r3
 800581a:	781b      	ldrb	r3, [r3, #0]
 800581c:	b25b      	sxtb	r3, r3
 800581e:	2101      	movs	r1, #1
 8005820:	400b      	ands	r3, r1
 8005822:	b25b      	sxtb	r3, r3
 8005824:	4313      	orrs	r3, r2
 8005826:	b25b      	sxtb	r3, r3
 8005828:	b2da      	uxtb	r2, r3
 800582a:	687b      	ldr	r3, [r7, #4]
 800582c:	0011      	movs	r1, r2
 800582e:	0018      	movs	r0, r3
 8005830:	f7ff ff3a 	bl	80056a8 <mqtt_output_append_u8>
  /* Encode remaining length field */
  do {
    mqtt_output_append_u8(rb, (r_length & 0x7f) | (r_length >= 128 ? 0x80 : 0));
 8005834:	211c      	movs	r1, #28
 8005836:	187b      	adds	r3, r7, r1
 8005838:	881b      	ldrh	r3, [r3, #0]
 800583a:	b25b      	sxtb	r3, r3
 800583c:	227f      	movs	r2, #127	; 0x7f
 800583e:	4013      	ands	r3, r2
 8005840:	b25a      	sxtb	r2, r3
 8005842:	187b      	adds	r3, r7, r1
 8005844:	881b      	ldrh	r3, [r3, #0]
 8005846:	2b7f      	cmp	r3, #127	; 0x7f
 8005848:	d902      	bls.n	8005850 <mqtt_output_append_fixed_header+0x86>
 800584a:	2380      	movs	r3, #128	; 0x80
 800584c:	425b      	negs	r3, r3
 800584e:	e000      	b.n	8005852 <mqtt_output_append_fixed_header+0x88>
 8005850:	2300      	movs	r3, #0
 8005852:	4313      	orrs	r3, r2
 8005854:	b25b      	sxtb	r3, r3
 8005856:	b2da      	uxtb	r2, r3
 8005858:	687b      	ldr	r3, [r7, #4]
 800585a:	0011      	movs	r1, r2
 800585c:	0018      	movs	r0, r3
 800585e:	f7ff ff23 	bl	80056a8 <mqtt_output_append_u8>
    r_length >>= 7;
 8005862:	211c      	movs	r1, #28
 8005864:	187b      	adds	r3, r7, r1
 8005866:	187a      	adds	r2, r7, r1
 8005868:	8812      	ldrh	r2, [r2, #0]
 800586a:	09d2      	lsrs	r2, r2, #7
 800586c:	801a      	strh	r2, [r3, #0]
  } while (r_length > 0);
 800586e:	187b      	adds	r3, r7, r1
 8005870:	881b      	ldrh	r3, [r3, #0]
 8005872:	2b00      	cmp	r3, #0
 8005874:	d1de      	bne.n	8005834 <mqtt_output_append_fixed_header+0x6a>
}
 8005876:	46c0      	nop			; (mov r8, r8)
 8005878:	46c0      	nop			; (mov r8, r8)
 800587a:	46bd      	mov	sp, r7
 800587c:	b003      	add	sp, #12
 800587e:	bd90      	pop	{r4, r7, pc}

08005880 <mqtt_output_check_space>:
 * @param r_length Remaining length after fixed header
 * @return 1 if message will fit, 0 if not enough buffer space
 */
static u8_t
mqtt_output_check_space(struct mqtt_ringbuf_t *rb, u16_t r_length)
{
 8005880:	b590      	push	{r4, r7, lr}
 8005882:	b085      	sub	sp, #20
 8005884:	af00      	add	r7, sp, #0
 8005886:	6078      	str	r0, [r7, #4]
 8005888:	000a      	movs	r2, r1
 800588a:	1cbb      	adds	r3, r7, #2
 800588c:	801a      	strh	r2, [r3, #0]
  /* Start with length of type byte + remaining length */
  u16_t total_len = 1 + r_length;
 800588e:	230e      	movs	r3, #14
 8005890:	18fb      	adds	r3, r7, r3
 8005892:	1cba      	adds	r2, r7, #2
 8005894:	8812      	ldrh	r2, [r2, #0]
 8005896:	3201      	adds	r2, #1
 8005898:	801a      	strh	r2, [r3, #0]

  LWIP_ASSERT("mqtt_output_check_space: rb != NULL", rb != NULL);
 800589a:	687b      	ldr	r3, [r7, #4]
 800589c:	2b00      	cmp	r3, #0
 800589e:	d105      	bne.n	80058ac <mqtt_output_check_space+0x2c>
 80058a0:	4b14      	ldr	r3, [pc, #80]	; (80058f4 <mqtt_output_check_space+0x74>)
 80058a2:	4a15      	ldr	r2, [pc, #84]	; (80058f8 <mqtt_output_check_space+0x78>)
 80058a4:	4915      	ldr	r1, [pc, #84]	; (80058fc <mqtt_output_check_space+0x7c>)
 80058a6:	4816      	ldr	r0, [pc, #88]	; (8005900 <mqtt_output_check_space+0x80>)
 80058a8:	f7fc fc9c 	bl	80021e4 <app_debug_rtt_raw>

  /* Calculate number of required bytes to contain the remaining bytes field and add to total*/
  do {
    total_len++;
 80058ac:	210e      	movs	r1, #14
 80058ae:	187b      	adds	r3, r7, r1
 80058b0:	881a      	ldrh	r2, [r3, #0]
 80058b2:	187b      	adds	r3, r7, r1
 80058b4:	3201      	adds	r2, #1
 80058b6:	801a      	strh	r2, [r3, #0]
    r_length >>= 7;
 80058b8:	1cbb      	adds	r3, r7, #2
 80058ba:	1cba      	adds	r2, r7, #2
 80058bc:	8812      	ldrh	r2, [r2, #0]
 80058be:	09d2      	lsrs	r2, r2, #7
 80058c0:	801a      	strh	r2, [r3, #0]
  } while (r_length > 0);
 80058c2:	1cbb      	adds	r3, r7, #2
 80058c4:	881b      	ldrh	r3, [r3, #0]
 80058c6:	2b00      	cmp	r3, #0
 80058c8:	d1f0      	bne.n	80058ac <mqtt_output_check_space+0x2c>

  return (total_len <= mqtt_ringbuf_free(rb));
 80058ca:	187b      	adds	r3, r7, r1
 80058cc:	881c      	ldrh	r4, [r3, #0]
 80058ce:	687b      	ldr	r3, [r7, #4]
 80058d0:	0018      	movs	r0, r3
 80058d2:	f7ff fc19 	bl	8005108 <mqtt_ringbuf_len>
 80058d6:	0003      	movs	r3, r0
 80058d8:	001a      	movs	r2, r3
 80058da:	2380      	movs	r3, #128	; 0x80
 80058dc:	005b      	lsls	r3, r3, #1
 80058de:	1a9b      	subs	r3, r3, r2
 80058e0:	0fe1      	lsrs	r1, r4, #31
 80058e2:	17da      	asrs	r2, r3, #31
 80058e4:	42a3      	cmp	r3, r4
 80058e6:	4151      	adcs	r1, r2
 80058e8:	000b      	movs	r3, r1
 80058ea:	b2db      	uxtb	r3, r3
}
 80058ec:	0018      	movs	r0, r3
 80058ee:	46bd      	mov	sp, r7
 80058f0:	b005      	add	sp, #20
 80058f2:	bd90      	pop	{r4, r7, pc}
 80058f4:	0801f5e8 	.word	0x0801f5e8
 80058f8:	00000207 	.word	0x00000207
 80058fc:	0801f7b0 	.word	0x0801f7b0
 8005900:	0801f654 	.word	0x0801f654

08005904 <mqtt_close>:
 * @param client MQTT client
 * @param reason Reason for disconnection
 */
static void
mqtt_close(mqtt_client_t *client, mqtt_connection_status_t reason)
{
 8005904:	b5b0      	push	{r4, r5, r7, lr}
 8005906:	b084      	sub	sp, #16
 8005908:	af00      	add	r7, sp, #0
 800590a:	6078      	str	r0, [r7, #4]
 800590c:	000a      	movs	r2, r1
 800590e:	1cbb      	adds	r3, r7, #2
 8005910:	801a      	strh	r2, [r3, #0]
  LWIP_ASSERT("mqtt_close: client != NULL", client != NULL);
 8005912:	687b      	ldr	r3, [r7, #4]
 8005914:	2b00      	cmp	r3, #0
 8005916:	d105      	bne.n	8005924 <mqtt_close+0x20>
 8005918:	4b2a      	ldr	r3, [pc, #168]	; (80059c4 <mqtt_close+0xc0>)
 800591a:	4a2b      	ldr	r2, [pc, #172]	; (80059c8 <mqtt_close+0xc4>)
 800591c:	492b      	ldr	r1, [pc, #172]	; (80059cc <mqtt_close+0xc8>)
 800591e:	482c      	ldr	r0, [pc, #176]	; (80059d0 <mqtt_close+0xcc>)
 8005920:	f7fc fc60 	bl	80021e4 <app_debug_rtt_raw>

  /* Bring down TCP connection if not already done */
  if (client->conn != NULL) {
 8005924:	687b      	ldr	r3, [r7, #4]
 8005926:	68db      	ldr	r3, [r3, #12]
 8005928:	2b00      	cmp	r3, #0
 800592a:	d027      	beq.n	800597c <mqtt_close+0x78>
    err_t res;
    altcp_recv(client->conn, NULL);
 800592c:	687b      	ldr	r3, [r7, #4]
 800592e:	68db      	ldr	r3, [r3, #12]
 8005930:	2100      	movs	r1, #0
 8005932:	0018      	movs	r0, r3
 8005934:	f007 f868 	bl	800ca08 <tcp_recv>
    altcp_err(client->conn,  NULL);
 8005938:	687b      	ldr	r3, [r7, #4]
 800593a:	68db      	ldr	r3, [r3, #12]
 800593c:	2100      	movs	r1, #0
 800593e:	0018      	movs	r0, r3
 8005940:	f007 f8a6 	bl	800ca90 <tcp_err>
    altcp_sent(client->conn, NULL);
 8005944:	687b      	ldr	r3, [r7, #4]
 8005946:	68db      	ldr	r3, [r3, #12]
 8005948:	2100      	movs	r1, #0
 800594a:	0018      	movs	r0, r3
 800594c:	f007 f87e 	bl	800ca4c <tcp_sent>
    res = altcp_close(client->conn);
 8005950:	687b      	ldr	r3, [r7, #4]
 8005952:	68db      	ldr	r3, [r3, #12]
 8005954:	250f      	movs	r5, #15
 8005956:	197c      	adds	r4, r7, r5
 8005958:	0018      	movs	r0, r3
 800595a:	f005 fd83 	bl	800b464 <tcp_close>
 800595e:	0003      	movs	r3, r0
 8005960:	7023      	strb	r3, [r4, #0]
    if (res != ERR_OK) {
 8005962:	197b      	adds	r3, r7, r5
 8005964:	781b      	ldrb	r3, [r3, #0]
 8005966:	b25b      	sxtb	r3, r3
 8005968:	2b00      	cmp	r3, #0
 800596a:	d004      	beq.n	8005976 <mqtt_close+0x72>
      altcp_abort(client->conn);
 800596c:	687b      	ldr	r3, [r7, #4]
 800596e:	68db      	ldr	r3, [r3, #12]
 8005970:	0018      	movs	r0, r3
 8005972:	f005 fe67 	bl	800b644 <tcp_abort>
      LWIP_DEBUGF(MQTT_DEBUG_TRACE, ("mqtt_close: Close err=%s\n", lwip_strerr(res)));
    }
    client->conn = NULL;
 8005976:	687b      	ldr	r3, [r7, #4]
 8005978:	2200      	movs	r2, #0
 800597a:	60da      	str	r2, [r3, #12]
  }

  /* Remove all pending requests */
  mqtt_clear_requests(&client->pend_req_queue);
 800597c:	687b      	ldr	r3, [r7, #4]
 800597e:	3318      	adds	r3, #24
 8005980:	0018      	movs	r0, r3
 8005982:	f7ff fe2f 	bl	80055e4 <mqtt_clear_requests>
  /* Stop cyclic timer */
  sys_untimeout(mqtt_cyclic_timer, client);
 8005986:	687a      	ldr	r2, [r7, #4]
 8005988:	4b12      	ldr	r3, [pc, #72]	; (80059d4 <mqtt_close+0xd0>)
 800598a:	0011      	movs	r1, r2
 800598c:	0018      	movs	r0, r3
 800598e:	f00d f891 	bl	8012ab4 <sys_untimeout>

  /* Notify upper layer of disconnection if changed state */
  if (client->conn_state != TCP_DISCONNECTED) {
 8005992:	687b      	ldr	r3, [r7, #4]
 8005994:	7a9b      	ldrb	r3, [r3, #10]
 8005996:	2b00      	cmp	r3, #0
 8005998:	d00f      	beq.n	80059ba <mqtt_close+0xb6>

    client->conn_state = TCP_DISCONNECTED;
 800599a:	687b      	ldr	r3, [r7, #4]
 800599c:	2200      	movs	r2, #0
 800599e:	729a      	strb	r2, [r3, #10]
    if (client->connect_cb != NULL) {
 80059a0:	687b      	ldr	r3, [r7, #4]
 80059a2:	695b      	ldr	r3, [r3, #20]
 80059a4:	2b00      	cmp	r3, #0
 80059a6:	d008      	beq.n	80059ba <mqtt_close+0xb6>
      client->connect_cb(client, client->connect_arg, reason);
 80059a8:	687b      	ldr	r3, [r7, #4]
 80059aa:	695c      	ldr	r4, [r3, #20]
 80059ac:	687b      	ldr	r3, [r7, #4]
 80059ae:	6919      	ldr	r1, [r3, #16]
 80059b0:	1cbb      	adds	r3, r7, #2
 80059b2:	881a      	ldrh	r2, [r3, #0]
 80059b4:	687b      	ldr	r3, [r7, #4]
 80059b6:	0018      	movs	r0, r3
 80059b8:	47a0      	blx	r4
    }
  }
}
 80059ba:	46c0      	nop			; (mov r8, r8)
 80059bc:	46bd      	mov	sp, r7
 80059be:	b004      	add	sp, #16
 80059c0:	bdb0      	pop	{r4, r5, r7, pc}
 80059c2:	46c0      	nop			; (mov r8, r8)
 80059c4:	0801f5e8 	.word	0x0801f5e8
 80059c8:	0000021b 	.word	0x0000021b
 80059cc:	0801f7d4 	.word	0x0801f7d4
 80059d0:	0801f654 	.word	0x0801f654
 80059d4:	080059d9 	.word	0x080059d9

080059d8 <mqtt_cyclic_timer>:
 * Interval timer, called every MQTT_CYCLIC_TIMER_INTERVAL seconds in MQTT_CONNECTING and MQTT_CONNECTED states
 * @param arg MQTT client
 */
static void
mqtt_cyclic_timer(void *arg)
{
 80059d8:	b580      	push	{r7, lr}
 80059da:	b086      	sub	sp, #24
 80059dc:	af02      	add	r7, sp, #8
 80059de:	6078      	str	r0, [r7, #4]
  u8_t restart_timer = 1;
 80059e0:	230f      	movs	r3, #15
 80059e2:	18fb      	adds	r3, r7, r3
 80059e4:	2201      	movs	r2, #1
 80059e6:	701a      	strb	r2, [r3, #0]
  mqtt_client_t *client = (mqtt_client_t *)arg;
 80059e8:	687b      	ldr	r3, [r7, #4]
 80059ea:	60bb      	str	r3, [r7, #8]
  LWIP_ASSERT("mqtt_cyclic_timer: client != NULL", client != NULL);
 80059ec:	68bb      	ldr	r3, [r7, #8]
 80059ee:	2b00      	cmp	r3, #0
 80059f0:	d106      	bne.n	8005a00 <mqtt_cyclic_timer+0x28>
 80059f2:	4b49      	ldr	r3, [pc, #292]	; (8005b18 <mqtt_cyclic_timer+0x140>)
 80059f4:	2291      	movs	r2, #145	; 0x91
 80059f6:	0092      	lsls	r2, r2, #2
 80059f8:	4948      	ldr	r1, [pc, #288]	; (8005b1c <mqtt_cyclic_timer+0x144>)
 80059fa:	4849      	ldr	r0, [pc, #292]	; (8005b20 <mqtt_cyclic_timer+0x148>)
 80059fc:	f7fc fbf2 	bl	80021e4 <app_debug_rtt_raw>

  if (client->conn_state == MQTT_CONNECTING) {
 8005a00:	68bb      	ldr	r3, [r7, #8]
 8005a02:	7a9b      	ldrb	r3, [r3, #10]
 8005a04:	2b02      	cmp	r3, #2
 8005a06:	d11a      	bne.n	8005a3e <mqtt_cyclic_timer+0x66>
    client->cyclic_tick++;
 8005a08:	68bb      	ldr	r3, [r7, #8]
 8005a0a:	881b      	ldrh	r3, [r3, #0]
 8005a0c:	3301      	adds	r3, #1
 8005a0e:	b29a      	uxth	r2, r3
 8005a10:	68bb      	ldr	r3, [r7, #8]
 8005a12:	801a      	strh	r2, [r3, #0]
    if ((client->cyclic_tick * MQTT_CYCLIC_TIMER_INTERVAL) >= MQTT_CONNECT_TIMOUT) {
 8005a14:	68bb      	ldr	r3, [r7, #8]
 8005a16:	881b      	ldrh	r3, [r3, #0]
 8005a18:	001a      	movs	r2, r3
 8005a1a:	0013      	movs	r3, r2
 8005a1c:	009b      	lsls	r3, r3, #2
 8005a1e:	189b      	adds	r3, r3, r2
 8005a20:	2b63      	cmp	r3, #99	; 0x63
 8005a22:	dd69      	ble.n	8005af8 <mqtt_cyclic_timer+0x120>
      LWIP_DEBUGF(MQTT_DEBUG_TRACE, ("mqtt_cyclic_timer: CONNECT attempt to server timed out\n"));
      /* Disconnect TCP */
      mqtt_close(client, MQTT_CONNECT_TIMEOUT);
 8005a24:	2302      	movs	r3, #2
 8005a26:	33ff      	adds	r3, #255	; 0xff
 8005a28:	001a      	movs	r2, r3
 8005a2a:	68bb      	ldr	r3, [r7, #8]
 8005a2c:	0011      	movs	r1, r2
 8005a2e:	0018      	movs	r0, r3
 8005a30:	f7ff ff68 	bl	8005904 <mqtt_close>
      restart_timer = 0;
 8005a34:	230f      	movs	r3, #15
 8005a36:	18fb      	adds	r3, r7, r3
 8005a38:	2200      	movs	r2, #0
 8005a3a:	701a      	strb	r2, [r3, #0]
 8005a3c:	e05c      	b.n	8005af8 <mqtt_cyclic_timer+0x120>
    }
  } else if (client->conn_state == MQTT_CONNECTED) {
 8005a3e:	68bb      	ldr	r3, [r7, #8]
 8005a40:	7a9b      	ldrb	r3, [r3, #10]
 8005a42:	2b03      	cmp	r3, #3
 8005a44:	d154      	bne.n	8005af0 <mqtt_cyclic_timer+0x118>
    /* Handle timeout for pending requests */
    mqtt_request_time_elapsed(&client->pend_req_queue, MQTT_CYCLIC_TIMER_INTERVAL);
 8005a46:	68bb      	ldr	r3, [r7, #8]
 8005a48:	3318      	adds	r3, #24
 8005a4a:	2105      	movs	r1, #5
 8005a4c:	0018      	movs	r0, r3
 8005a4e:	f7ff fd6f 	bl	8005530 <mqtt_request_time_elapsed>

    /* keep_alive > 0 means keep alive functionality shall be used */
    if (client->keep_alive > 0) {
 8005a52:	68bb      	ldr	r3, [r7, #8]
 8005a54:	885b      	ldrh	r3, [r3, #2]
 8005a56:	2b00      	cmp	r3, #0
 8005a58:	d04e      	beq.n	8005af8 <mqtt_cyclic_timer+0x120>

      client->server_watchdog++;
 8005a5a:	68bb      	ldr	r3, [r7, #8]
 8005a5c:	889b      	ldrh	r3, [r3, #4]
 8005a5e:	3301      	adds	r3, #1
 8005a60:	b29a      	uxth	r2, r3
 8005a62:	68bb      	ldr	r3, [r7, #8]
 8005a64:	809a      	strh	r2, [r3, #4]
      /* If reception from server has been idle for 1.5*keep_alive time, server is considered unresponsive */
      if ((client->server_watchdog * MQTT_CYCLIC_TIMER_INTERVAL) > (client->keep_alive + client->keep_alive / 2)) {
 8005a66:	68bb      	ldr	r3, [r7, #8]
 8005a68:	889b      	ldrh	r3, [r3, #4]
 8005a6a:	001a      	movs	r2, r3
 8005a6c:	0013      	movs	r3, r2
 8005a6e:	009b      	lsls	r3, r3, #2
 8005a70:	189a      	adds	r2, r3, r2
 8005a72:	68bb      	ldr	r3, [r7, #8]
 8005a74:	885b      	ldrh	r3, [r3, #2]
 8005a76:	0019      	movs	r1, r3
 8005a78:	68bb      	ldr	r3, [r7, #8]
 8005a7a:	885b      	ldrh	r3, [r3, #2]
 8005a7c:	085b      	lsrs	r3, r3, #1
 8005a7e:	b29b      	uxth	r3, r3
 8005a80:	18cb      	adds	r3, r1, r3
 8005a82:	429a      	cmp	r2, r3
 8005a84:	dd0b      	ble.n	8005a9e <mqtt_cyclic_timer+0xc6>
        LWIP_DEBUGF(MQTT_DEBUG_WARN, ("mqtt_cyclic_timer: Server incoming keep-alive timeout\n"));
        mqtt_close(client, MQTT_CONNECT_TIMEOUT);
 8005a86:	2302      	movs	r3, #2
 8005a88:	33ff      	adds	r3, #255	; 0xff
 8005a8a:	001a      	movs	r2, r3
 8005a8c:	68bb      	ldr	r3, [r7, #8]
 8005a8e:	0011      	movs	r1, r2
 8005a90:	0018      	movs	r0, r3
 8005a92:	f7ff ff37 	bl	8005904 <mqtt_close>
        restart_timer = 0;
 8005a96:	230f      	movs	r3, #15
 8005a98:	18fb      	adds	r3, r7, r3
 8005a9a:	2200      	movs	r2, #0
 8005a9c:	701a      	strb	r2, [r3, #0]
      }

      /* If time for a keep alive message to be sent, transmission has been idle for keep_alive time */
      if ((client->cyclic_tick * MQTT_CYCLIC_TIMER_INTERVAL) >= client->keep_alive) {
 8005a9e:	68bb      	ldr	r3, [r7, #8]
 8005aa0:	881b      	ldrh	r3, [r3, #0]
 8005aa2:	001a      	movs	r2, r3
 8005aa4:	0013      	movs	r3, r2
 8005aa6:	009b      	lsls	r3, r3, #2
 8005aa8:	189b      	adds	r3, r3, r2
 8005aaa:	68ba      	ldr	r2, [r7, #8]
 8005aac:	8852      	ldrh	r2, [r2, #2]
 8005aae:	4293      	cmp	r3, r2
 8005ab0:	db17      	blt.n	8005ae2 <mqtt_cyclic_timer+0x10a>
        LWIP_DEBUGF(MQTT_DEBUG_TRACE, ("mqtt_cyclic_timer: Sending keep-alive message to server\n"));
        if (mqtt_output_check_space(&client->output, 0) != 0) {
 8005ab2:	68bb      	ldr	r3, [r7, #8]
 8005ab4:	33ec      	adds	r3, #236	; 0xec
 8005ab6:	2100      	movs	r1, #0
 8005ab8:	0018      	movs	r0, r3
 8005aba:	f7ff fee1 	bl	8005880 <mqtt_output_check_space>
 8005abe:	1e03      	subs	r3, r0, #0
 8005ac0:	d01a      	beq.n	8005af8 <mqtt_cyclic_timer+0x120>
          mqtt_output_append_fixed_header(&client->output, MQTT_MSG_TYPE_PINGREQ, 0, 0, 0, 0);
 8005ac2:	68bb      	ldr	r3, [r7, #8]
 8005ac4:	33ec      	adds	r3, #236	; 0xec
 8005ac6:	0018      	movs	r0, r3
 8005ac8:	2300      	movs	r3, #0
 8005aca:	9301      	str	r3, [sp, #4]
 8005acc:	2300      	movs	r3, #0
 8005ace:	9300      	str	r3, [sp, #0]
 8005ad0:	2300      	movs	r3, #0
 8005ad2:	2200      	movs	r2, #0
 8005ad4:	210c      	movs	r1, #12
 8005ad6:	f7ff fe78 	bl	80057ca <mqtt_output_append_fixed_header>
          client->cyclic_tick = 0;
 8005ada:	68bb      	ldr	r3, [r7, #8]
 8005adc:	2200      	movs	r2, #0
 8005ade:	801a      	strh	r2, [r3, #0]
 8005ae0:	e00a      	b.n	8005af8 <mqtt_cyclic_timer+0x120>
        }
      } else {
        client->cyclic_tick++;
 8005ae2:	68bb      	ldr	r3, [r7, #8]
 8005ae4:	881b      	ldrh	r3, [r3, #0]
 8005ae6:	3301      	adds	r3, #1
 8005ae8:	b29a      	uxth	r2, r3
 8005aea:	68bb      	ldr	r3, [r7, #8]
 8005aec:	801a      	strh	r2, [r3, #0]
 8005aee:	e003      	b.n	8005af8 <mqtt_cyclic_timer+0x120>
      }
    }
  } else {
    LWIP_DEBUGF(MQTT_DEBUG_WARN, ("mqtt_cyclic_timer: Timer should not be running in state %d\n", client->conn_state));
    restart_timer = 0;
 8005af0:	230f      	movs	r3, #15
 8005af2:	18fb      	adds	r3, r7, r3
 8005af4:	2200      	movs	r2, #0
 8005af6:	701a      	strb	r2, [r3, #0]
  }
  if (restart_timer) {
 8005af8:	230f      	movs	r3, #15
 8005afa:	18fb      	adds	r3, r7, r3
 8005afc:	781b      	ldrb	r3, [r3, #0]
 8005afe:	2b00      	cmp	r3, #0
 8005b00:	d005      	beq.n	8005b0e <mqtt_cyclic_timer+0x136>
    sys_timeout(MQTT_CYCLIC_TIMER_INTERVAL * 1000, mqtt_cyclic_timer, arg);
 8005b02:	687a      	ldr	r2, [r7, #4]
 8005b04:	4b07      	ldr	r3, [pc, #28]	; (8005b24 <mqtt_cyclic_timer+0x14c>)
 8005b06:	4808      	ldr	r0, [pc, #32]	; (8005b28 <mqtt_cyclic_timer+0x150>)
 8005b08:	0019      	movs	r1, r3
 8005b0a:	f00c ffab 	bl	8012a64 <sys_timeout>
  }
}
 8005b0e:	46c0      	nop			; (mov r8, r8)
 8005b10:	46bd      	mov	sp, r7
 8005b12:	b004      	add	sp, #16
 8005b14:	bd80      	pop	{r7, pc}
 8005b16:	46c0      	nop			; (mov r8, r8)
 8005b18:	0801f5e8 	.word	0x0801f5e8
 8005b1c:	0801f7f0 	.word	0x0801f7f0
 8005b20:	0801f654 	.word	0x0801f654
 8005b24:	080059d9 	.word	0x080059d9
 8005b28:	00001388 	.word	0x00001388

08005b2c <pub_ack_rec_rel_response>:
 * @param qos QoS value
 * @return ERR_OK if successful, ERR_MEM if out of memory
 */
static err_t
pub_ack_rec_rel_response(mqtt_client_t *client, u8_t msg, u16_t pkt_id, u8_t qos)
{
 8005b2c:	b590      	push	{r4, r7, lr}
 8005b2e:	b087      	sub	sp, #28
 8005b30:	af02      	add	r7, sp, #8
 8005b32:	6078      	str	r0, [r7, #4]
 8005b34:	000c      	movs	r4, r1
 8005b36:	0010      	movs	r0, r2
 8005b38:	0019      	movs	r1, r3
 8005b3a:	1cfb      	adds	r3, r7, #3
 8005b3c:	1c22      	adds	r2, r4, #0
 8005b3e:	701a      	strb	r2, [r3, #0]
 8005b40:	003b      	movs	r3, r7
 8005b42:	1c02      	adds	r2, r0, #0
 8005b44:	801a      	strh	r2, [r3, #0]
 8005b46:	1cbb      	adds	r3, r7, #2
 8005b48:	1c0a      	adds	r2, r1, #0
 8005b4a:	701a      	strb	r2, [r3, #0]
  err_t err = ERR_OK;
 8005b4c:	230f      	movs	r3, #15
 8005b4e:	18fb      	adds	r3, r7, r3
 8005b50:	2200      	movs	r2, #0
 8005b52:	701a      	strb	r2, [r3, #0]
  if (mqtt_output_check_space(&client->output, 2)) {
 8005b54:	687b      	ldr	r3, [r7, #4]
 8005b56:	33ec      	adds	r3, #236	; 0xec
 8005b58:	2102      	movs	r1, #2
 8005b5a:	0018      	movs	r0, r3
 8005b5c:	f7ff fe90 	bl	8005880 <mqtt_output_check_space>
 8005b60:	1e03      	subs	r3, r0, #0
 8005b62:	d021      	beq.n	8005ba8 <pub_ack_rec_rel_response+0x7c>
    mqtt_output_append_fixed_header(&client->output, msg, 0, qos, 0, 2);
 8005b64:	687b      	ldr	r3, [r7, #4]
 8005b66:	33ec      	adds	r3, #236	; 0xec
 8005b68:	0018      	movs	r0, r3
 8005b6a:	1cbb      	adds	r3, r7, #2
 8005b6c:	781a      	ldrb	r2, [r3, #0]
 8005b6e:	1cfb      	adds	r3, r7, #3
 8005b70:	7819      	ldrb	r1, [r3, #0]
 8005b72:	2302      	movs	r3, #2
 8005b74:	9301      	str	r3, [sp, #4]
 8005b76:	2300      	movs	r3, #0
 8005b78:	9300      	str	r3, [sp, #0]
 8005b7a:	0013      	movs	r3, r2
 8005b7c:	2200      	movs	r2, #0
 8005b7e:	f7ff fe24 	bl	80057ca <mqtt_output_append_fixed_header>
    mqtt_output_append_u16(&client->output, pkt_id);
 8005b82:	687b      	ldr	r3, [r7, #4]
 8005b84:	33ec      	adds	r3, #236	; 0xec
 8005b86:	001a      	movs	r2, r3
 8005b88:	003b      	movs	r3, r7
 8005b8a:	881b      	ldrh	r3, [r3, #0]
 8005b8c:	0019      	movs	r1, r3
 8005b8e:	0010      	movs	r0, r2
 8005b90:	f7ff fd9c 	bl	80056cc <mqtt_output_append_u16>
    mqtt_output_send(&client->output, client->conn);
 8005b94:	687b      	ldr	r3, [r7, #4]
 8005b96:	33ec      	adds	r3, #236	; 0xec
 8005b98:	001a      	movs	r2, r3
 8005b9a:	687b      	ldr	r3, [r7, #4]
 8005b9c:	68db      	ldr	r3, [r3, #12]
 8005b9e:	0019      	movs	r1, r3
 8005ba0:	0010      	movs	r0, r2
 8005ba2:	f7ff facb 	bl	800513c <mqtt_output_send>
 8005ba6:	e003      	b.n	8005bb0 <pub_ack_rec_rel_response+0x84>
  } else {
    LWIP_DEBUGF(MQTT_DEBUG_TRACE, ("pub_ack_rec_rel_response: OOM creating response: %s with pkt_id: %d\n",
                                   mqtt_msg_type_to_str(msg), pkt_id));
    err = ERR_MEM;
 8005ba8:	230f      	movs	r3, #15
 8005baa:	18fb      	adds	r3, r7, r3
 8005bac:	22ff      	movs	r2, #255	; 0xff
 8005bae:	701a      	strb	r2, [r3, #0]
  }
  return err;
 8005bb0:	230f      	movs	r3, #15
 8005bb2:	18fb      	adds	r3, r7, r3
 8005bb4:	781b      	ldrb	r3, [r3, #0]
 8005bb6:	b25b      	sxtb	r3, r3
}
 8005bb8:	0018      	movs	r0, r3
 8005bba:	46bd      	mov	sp, r7
 8005bbc:	b005      	add	sp, #20
 8005bbe:	bd90      	pop	{r4, r7, pc}

08005bc0 <mqtt_incomming_suback>:
 * @param r Matching request
 * @param result Result code from server
 */
static void
mqtt_incomming_suback(struct mqtt_request_t *r, u8_t result)
{
 8005bc0:	b580      	push	{r7, lr}
 8005bc2:	b082      	sub	sp, #8
 8005bc4:	af00      	add	r7, sp, #0
 8005bc6:	6078      	str	r0, [r7, #4]
 8005bc8:	000a      	movs	r2, r1
 8005bca:	1cfb      	adds	r3, r7, #3
 8005bcc:	701a      	strb	r2, [r3, #0]
  if (r->cb != NULL) {
 8005bce:	687b      	ldr	r3, [r7, #4]
 8005bd0:	685b      	ldr	r3, [r3, #4]
 8005bd2:	2b00      	cmp	r3, #0
 8005bd4:	d00d      	beq.n	8005bf2 <mqtt_incomming_suback+0x32>
    r->cb(r->arg, result < 3 ? ERR_OK : ERR_ABRT);
 8005bd6:	687b      	ldr	r3, [r7, #4]
 8005bd8:	685a      	ldr	r2, [r3, #4]
 8005bda:	687b      	ldr	r3, [r7, #4]
 8005bdc:	6898      	ldr	r0, [r3, #8]
 8005bde:	1cfb      	adds	r3, r7, #3
 8005be0:	781b      	ldrb	r3, [r3, #0]
 8005be2:	2b02      	cmp	r3, #2
 8005be4:	d801      	bhi.n	8005bea <mqtt_incomming_suback+0x2a>
 8005be6:	2300      	movs	r3, #0
 8005be8:	e001      	b.n	8005bee <mqtt_incomming_suback+0x2e>
 8005bea:	230d      	movs	r3, #13
 8005bec:	425b      	negs	r3, r3
 8005bee:	0019      	movs	r1, r3
 8005bf0:	4790      	blx	r2
  }
}
 8005bf2:	46c0      	nop			; (mov r8, r8)
 8005bf4:	46bd      	mov	sp, r7
 8005bf6:	b002      	add	sp, #8
 8005bf8:	bd80      	pop	{r7, pc}
	...

08005bfc <mqtt_message_received>:
 * @param length length received part
 * @param remaining_length Remaining length of complete message
 */
static mqtt_connection_status_t
mqtt_message_received(mqtt_client_t *client, u8_t fixed_hdr_len, u16_t length, u32_t remaining_length)
{
 8005bfc:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005bfe:	b08f      	sub	sp, #60	; 0x3c
 8005c00:	af00      	add	r7, sp, #0
 8005c02:	60f8      	str	r0, [r7, #12]
 8005c04:	0008      	movs	r0, r1
 8005c06:	0011      	movs	r1, r2
 8005c08:	607b      	str	r3, [r7, #4]
 8005c0a:	240b      	movs	r4, #11
 8005c0c:	193b      	adds	r3, r7, r4
 8005c0e:	1c02      	adds	r2, r0, #0
 8005c10:	701a      	strb	r2, [r3, #0]
 8005c12:	2308      	movs	r3, #8
 8005c14:	18fb      	adds	r3, r7, r3
 8005c16:	1c0a      	adds	r2, r1, #0
 8005c18:	801a      	strh	r2, [r3, #0]
  mqtt_connection_status_t res = MQTT_CONNECT_ACCEPTED;
 8005c1a:	2330      	movs	r3, #48	; 0x30
 8005c1c:	18fb      	adds	r3, r7, r3
 8005c1e:	2200      	movs	r2, #0
 8005c20:	801a      	strh	r2, [r3, #0]

  u8_t *var_hdr_payload = client->rx_buffer + fixed_hdr_len;
 8005c22:	68fb      	ldr	r3, [r7, #12]
 8005c24:	336c      	adds	r3, #108	; 0x6c
 8005c26:	001a      	movs	r2, r3
 8005c28:	0021      	movs	r1, r4
 8005c2a:	187b      	adds	r3, r7, r1
 8005c2c:	781b      	ldrb	r3, [r3, #0]
 8005c2e:	18d3      	adds	r3, r2, r3
 8005c30:	62fb      	str	r3, [r7, #44]	; 0x2c
  size_t var_hdr_payload_bufsize = sizeof(client->rx_buffer) - fixed_hdr_len;
 8005c32:	187b      	adds	r3, r7, r1
 8005c34:	781b      	ldrb	r3, [r3, #0]
 8005c36:	2280      	movs	r2, #128	; 0x80
 8005c38:	1ad3      	subs	r3, r2, r3
 8005c3a:	62bb      	str	r3, [r7, #40]	; 0x28

  /* Control packet type */
  u8_t pkt_type = MQTT_CTL_PACKET_TYPE(client->rx_buffer[0]);
 8005c3c:	68fb      	ldr	r3, [r7, #12]
 8005c3e:	226c      	movs	r2, #108	; 0x6c
 8005c40:	5c9a      	ldrb	r2, [r3, r2]
 8005c42:	2327      	movs	r3, #39	; 0x27
 8005c44:	18fb      	adds	r3, r7, r3
 8005c46:	0912      	lsrs	r2, r2, #4
 8005c48:	701a      	strb	r2, [r3, #0]
  u16_t pkt_id = 0;
 8005c4a:	2324      	movs	r3, #36	; 0x24
 8005c4c:	18fb      	adds	r3, r7, r3
 8005c4e:	2200      	movs	r2, #0
 8005c50:	801a      	strh	r2, [r3, #0]

  LWIP_ASSERT("fixed_hdr_len <= client->msg_idx", fixed_hdr_len <= client->msg_idx);
 8005c52:	187b      	adds	r3, r7, r1
 8005c54:	781a      	ldrb	r2, [r3, #0]
 8005c56:	68fb      	ldr	r3, [r7, #12]
 8005c58:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8005c5a:	429a      	cmp	r2, r3
 8005c5c:	d905      	bls.n	8005c6a <mqtt_message_received+0x6e>
 8005c5e:	4bc9      	ldr	r3, [pc, #804]	; (8005f84 <mqtt_message_received+0x388>)
 8005c60:	4ac9      	ldr	r2, [pc, #804]	; (8005f88 <mqtt_message_received+0x38c>)
 8005c62:	49ca      	ldr	r1, [pc, #808]	; (8005f8c <mqtt_message_received+0x390>)
 8005c64:	48ca      	ldr	r0, [pc, #808]	; (8005f90 <mqtt_message_received+0x394>)
 8005c66:	f7fc fabd 	bl	80021e4 <app_debug_rtt_raw>
  LWIP_ERROR("buffer length mismatch", fixed_hdr_len + length <= MQTT_VAR_HEADER_BUFFER_LEN,
 8005c6a:	230b      	movs	r3, #11
 8005c6c:	18fb      	adds	r3, r7, r3
 8005c6e:	781a      	ldrb	r2, [r3, #0]
 8005c70:	2308      	movs	r3, #8
 8005c72:	18fb      	adds	r3, r7, r3
 8005c74:	881b      	ldrh	r3, [r3, #0]
 8005c76:	18d3      	adds	r3, r2, r3
 8005c78:	2b80      	cmp	r3, #128	; 0x80
 8005c7a:	dd06      	ble.n	8005c8a <mqtt_message_received+0x8e>
 8005c7c:	4bc5      	ldr	r3, [pc, #788]	; (8005f94 <mqtt_message_received+0x398>)
 8005c7e:	0018      	movs	r0, r3
 8005c80:	f7fc fab0 	bl	80021e4 <app_debug_rtt_raw>
 8005c84:	2380      	movs	r3, #128	; 0x80
 8005c86:	005b      	lsls	r3, r3, #1
 8005c88:	e1e0      	b.n	800604c <mqtt_message_received+0x450>
             return MQTT_CONNECT_DISCONNECTED);

  if (pkt_type == MQTT_MSG_TYPE_CONNACK) {
 8005c8a:	2327      	movs	r3, #39	; 0x27
 8005c8c:	18fb      	adds	r3, r7, r3
 8005c8e:	781b      	ldrb	r3, [r3, #0]
 8005c90:	2b02      	cmp	r3, #2
 8005c92:	d12a      	bne.n	8005cea <mqtt_message_received+0xee>
    if (client->conn_state == MQTT_CONNECTING) {
 8005c94:	68fb      	ldr	r3, [r7, #12]
 8005c96:	7a9b      	ldrb	r3, [r3, #10]
 8005c98:	2b02      	cmp	r3, #2
 8005c9a:	d000      	beq.n	8005c9e <mqtt_message_received+0xa2>
 8005c9c:	e1bf      	b.n	800601e <mqtt_message_received+0x422>
      if (length < 2) {
 8005c9e:	2308      	movs	r3, #8
 8005ca0:	18fb      	adds	r3, r7, r3
 8005ca2:	881b      	ldrh	r3, [r3, #0]
 8005ca4:	2b01      	cmp	r3, #1
 8005ca6:	d800      	bhi.n	8005caa <mqtt_message_received+0xae>
 8005ca8:	e1bd      	b.n	8006026 <mqtt_message_received+0x42a>
        LWIP_DEBUGF(MQTT_DEBUG_WARN,( "mqtt_message_received: Received short CONNACK message\n"));
        goto out_disconnect;
      }
      /* Get result code from CONNACK */
      res = (mqtt_connection_status_t)var_hdr_payload[1];
 8005caa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005cac:	3301      	adds	r3, #1
 8005cae:	781a      	ldrb	r2, [r3, #0]
 8005cb0:	2030      	movs	r0, #48	; 0x30
 8005cb2:	183b      	adds	r3, r7, r0
 8005cb4:	801a      	strh	r2, [r3, #0]
      LWIP_DEBUGF(MQTT_DEBUG_TRACE, ("mqtt_message_received: Connect response code %d\n", res));
      if (res == MQTT_CONNECT_ACCEPTED) {
 8005cb6:	183b      	adds	r3, r7, r0
 8005cb8:	881b      	ldrh	r3, [r3, #0]
 8005cba:	2b00      	cmp	r3, #0
 8005cbc:	d000      	beq.n	8005cc0 <mqtt_message_received+0xc4>
 8005cbe:	e1ae      	b.n	800601e <mqtt_message_received+0x422>
        /* Reset cyclic_tick when changing to connected state */
        client->cyclic_tick = 0;
 8005cc0:	68fb      	ldr	r3, [r7, #12]
 8005cc2:	2200      	movs	r2, #0
 8005cc4:	801a      	strh	r2, [r3, #0]
        client->conn_state = MQTT_CONNECTED;
 8005cc6:	68fb      	ldr	r3, [r7, #12]
 8005cc8:	2203      	movs	r2, #3
 8005cca:	729a      	strb	r2, [r3, #10]
        /* Notify upper layer */
        if (client->connect_cb != 0) {
 8005ccc:	68fb      	ldr	r3, [r7, #12]
 8005cce:	695b      	ldr	r3, [r3, #20]
 8005cd0:	2b00      	cmp	r3, #0
 8005cd2:	d100      	bne.n	8005cd6 <mqtt_message_received+0xda>
 8005cd4:	e1a3      	b.n	800601e <mqtt_message_received+0x422>
          client->connect_cb(client, client->connect_arg, res);
 8005cd6:	68fb      	ldr	r3, [r7, #12]
 8005cd8:	695c      	ldr	r4, [r3, #20]
 8005cda:	68fb      	ldr	r3, [r7, #12]
 8005cdc:	6919      	ldr	r1, [r3, #16]
 8005cde:	183b      	adds	r3, r7, r0
 8005ce0:	881a      	ldrh	r2, [r3, #0]
 8005ce2:	68fb      	ldr	r3, [r7, #12]
 8005ce4:	0018      	movs	r0, r3
 8005ce6:	47a0      	blx	r4
 8005ce8:	e199      	b.n	800601e <mqtt_message_received+0x422>
        }
      }
    } else {
      LWIP_DEBUGF(MQTT_DEBUG_WARN, ("mqtt_message_received: Received CONNACK in connected state\n"));
    }
  } else if (pkt_type == MQTT_MSG_TYPE_PINGRESP) {
 8005cea:	2227      	movs	r2, #39	; 0x27
 8005cec:	18bb      	adds	r3, r7, r2
 8005cee:	781b      	ldrb	r3, [r3, #0]
 8005cf0:	2b0d      	cmp	r3, #13
 8005cf2:	d100      	bne.n	8005cf6 <mqtt_message_received+0xfa>
 8005cf4:	e193      	b.n	800601e <mqtt_message_received+0x422>
    LWIP_DEBUGF(MQTT_DEBUG_TRACE, ( "mqtt_message_received: Received PINGRESP from server\n"));

  } else if (pkt_type == MQTT_MSG_TYPE_PUBLISH) {
 8005cf6:	18bb      	adds	r3, r7, r2
 8005cf8:	781b      	ldrb	r3, [r3, #0]
 8005cfa:	2b03      	cmp	r3, #3
 8005cfc:	d000      	beq.n	8005d00 <mqtt_message_received+0x104>
 8005cfe:	e111      	b.n	8005f24 <mqtt_message_received+0x328>
    u16_t payload_offset = 0;
 8005d00:	2334      	movs	r3, #52	; 0x34
 8005d02:	18fb      	adds	r3, r7, r3
 8005d04:	2200      	movs	r2, #0
 8005d06:	801a      	strh	r2, [r3, #0]
    u16_t payload_length = length;
 8005d08:	2332      	movs	r3, #50	; 0x32
 8005d0a:	18fb      	adds	r3, r7, r3
 8005d0c:	2208      	movs	r2, #8
 8005d0e:	18ba      	adds	r2, r7, r2
 8005d10:	8812      	ldrh	r2, [r2, #0]
 8005d12:	801a      	strh	r2, [r3, #0]
    u8_t qos = MQTT_CTL_PACKET_QOS(client->rx_buffer[0]);
 8005d14:	68fb      	ldr	r3, [r7, #12]
 8005d16:	226c      	movs	r2, #108	; 0x6c
 8005d18:	5c9b      	ldrb	r3, [r3, r2]
 8005d1a:	105b      	asrs	r3, r3, #1
 8005d1c:	b2da      	uxtb	r2, r3
 8005d1e:	201f      	movs	r0, #31
 8005d20:	183b      	adds	r3, r7, r0
 8005d22:	2103      	movs	r1, #3
 8005d24:	400a      	ands	r2, r1
 8005d26:	701a      	strb	r2, [r3, #0]

    if (client->msg_idx <= MQTT_VAR_HEADER_BUFFER_LEN) {
 8005d28:	68fb      	ldr	r3, [r7, #12]
 8005d2a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8005d2c:	2b80      	cmp	r3, #128	; 0x80
 8005d2e:	d900      	bls.n	8005d32 <mqtt_message_received+0x136>
 8005d30:	e0b0      	b.n	8005e94 <mqtt_message_received+0x298>
      /* Should have topic and pkt id*/
      u8_t *topic;
      u16_t after_topic;
      u8_t bkp;
      u16_t topic_len;
      u16_t qos_len = (qos ? 2U : 0U);
 8005d32:	183b      	adds	r3, r7, r0
 8005d34:	781b      	ldrb	r3, [r3, #0]
 8005d36:	2b00      	cmp	r3, #0
 8005d38:	d001      	beq.n	8005d3e <mqtt_message_received+0x142>
 8005d3a:	2202      	movs	r2, #2
 8005d3c:	e000      	b.n	8005d40 <mqtt_message_received+0x144>
 8005d3e:	2200      	movs	r2, #0
 8005d40:	241c      	movs	r4, #28
 8005d42:	193b      	adds	r3, r7, r4
 8005d44:	801a      	strh	r2, [r3, #0]
      if (length < 2 + qos_len) {
 8005d46:	193b      	adds	r3, r7, r4
 8005d48:	881b      	ldrh	r3, [r3, #0]
 8005d4a:	1c5a      	adds	r2, r3, #1
 8005d4c:	2508      	movs	r5, #8
 8005d4e:	197b      	adds	r3, r7, r5
 8005d50:	881b      	ldrh	r3, [r3, #0]
 8005d52:	429a      	cmp	r2, r3
 8005d54:	db00      	blt.n	8005d58 <mqtt_message_received+0x15c>
 8005d56:	e168      	b.n	800602a <mqtt_message_received+0x42e>
        LWIP_DEBUGF(MQTT_DEBUG_WARN,( "mqtt_message_received: Received short PUBLISH packet\n"));
        goto out_disconnect;
      }
      topic_len = var_hdr_payload[0];
 8005d58:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005d5a:	781a      	ldrb	r2, [r3, #0]
 8005d5c:	201a      	movs	r0, #26
 8005d5e:	183b      	adds	r3, r7, r0
 8005d60:	801a      	strh	r2, [r3, #0]
      topic_len = (topic_len << 8) + (u16_t)(var_hdr_payload[1]);
 8005d62:	183b      	adds	r3, r7, r0
 8005d64:	881b      	ldrh	r3, [r3, #0]
 8005d66:	021b      	lsls	r3, r3, #8
 8005d68:	b299      	uxth	r1, r3
 8005d6a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005d6c:	3301      	adds	r3, #1
 8005d6e:	781b      	ldrb	r3, [r3, #0]
 8005d70:	b29a      	uxth	r2, r3
 8005d72:	183b      	adds	r3, r7, r0
 8005d74:	188a      	adds	r2, r1, r2
 8005d76:	801a      	strh	r2, [r3, #0]
      if ((topic_len > length - (2 + qos_len)) ||
 8005d78:	183b      	adds	r3, r7, r0
 8005d7a:	881a      	ldrh	r2, [r3, #0]
 8005d7c:	197b      	adds	r3, r7, r5
 8005d7e:	8819      	ldrh	r1, [r3, #0]
 8005d80:	193b      	adds	r3, r7, r4
 8005d82:	881b      	ldrh	r3, [r3, #0]
 8005d84:	3302      	adds	r3, #2
 8005d86:	1acb      	subs	r3, r1, r3
 8005d88:	429a      	cmp	r2, r3
 8005d8a:	dd00      	ble.n	8005d8e <mqtt_message_received+0x192>
 8005d8c:	e14f      	b.n	800602e <mqtt_message_received+0x432>
          (topic_len > var_hdr_payload_bufsize - (2 + qos_len))) {
 8005d8e:	183b      	adds	r3, r7, r0
 8005d90:	881a      	ldrh	r2, [r3, #0]
 8005d92:	193b      	adds	r3, r7, r4
 8005d94:	881b      	ldrh	r3, [r3, #0]
 8005d96:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8005d98:	1acb      	subs	r3, r1, r3
 8005d9a:	3b02      	subs	r3, #2
      if ((topic_len > length - (2 + qos_len)) ||
 8005d9c:	429a      	cmp	r2, r3
 8005d9e:	d900      	bls.n	8005da2 <mqtt_message_received+0x1a6>
 8005da0:	e145      	b.n	800602e <mqtt_message_received+0x432>
        LWIP_DEBUGF(MQTT_DEBUG_WARN,( "mqtt_message_received: Received short PUBLISH packet (topic)\n"));
        goto out_disconnect;
      }

      topic = var_hdr_payload + 2;
 8005da2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005da4:	3302      	adds	r3, #2
 8005da6:	617b      	str	r3, [r7, #20]
      after_topic = 2 + topic_len;
 8005da8:	2136      	movs	r1, #54	; 0x36
 8005daa:	187b      	adds	r3, r7, r1
 8005dac:	183a      	adds	r2, r7, r0
 8005dae:	8812      	ldrh	r2, [r2, #0]
 8005db0:	3202      	adds	r2, #2
 8005db2:	801a      	strh	r2, [r3, #0]
      /* Check buffer length, add one byte even for QoS 0 so that zero termination will fit */
      if ((after_topic + (qos ? 2U : 1U)) > var_hdr_payload_bufsize) {
 8005db4:	187b      	adds	r3, r7, r1
 8005db6:	881a      	ldrh	r2, [r3, #0]
 8005db8:	231f      	movs	r3, #31
 8005dba:	18fb      	adds	r3, r7, r3
 8005dbc:	781b      	ldrb	r3, [r3, #0]
 8005dbe:	2b00      	cmp	r3, #0
 8005dc0:	d001      	beq.n	8005dc6 <mqtt_message_received+0x1ca>
 8005dc2:	2302      	movs	r3, #2
 8005dc4:	e000      	b.n	8005dc8 <mqtt_message_received+0x1cc>
 8005dc6:	2301      	movs	r3, #1
 8005dc8:	189b      	adds	r3, r3, r2
 8005dca:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8005dcc:	429a      	cmp	r2, r3
 8005dce:	d200      	bcs.n	8005dd2 <mqtt_message_received+0x1d6>
 8005dd0:	e12f      	b.n	8006032 <mqtt_message_received+0x436>
        LWIP_DEBUGF(MQTT_DEBUG_WARN, ("mqtt_message_received: Receive buffer can not fit topic + pkt_id\n"));
        goto out_disconnect;
      }

      /* id for QoS 1 and 2 */
      if (qos > 0) {
 8005dd2:	231f      	movs	r3, #31
 8005dd4:	18fb      	adds	r3, r7, r3
 8005dd6:	781b      	ldrb	r3, [r3, #0]
 8005dd8:	2b00      	cmp	r3, #0
 8005dda:	d022      	beq.n	8005e22 <mqtt_message_received+0x226>
        if (length < after_topic + 2U) {
 8005ddc:	2308      	movs	r3, #8
 8005dde:	18fb      	adds	r3, r7, r3
 8005de0:	881a      	ldrh	r2, [r3, #0]
 8005de2:	2036      	movs	r0, #54	; 0x36
 8005de4:	183b      	adds	r3, r7, r0
 8005de6:	881b      	ldrh	r3, [r3, #0]
 8005de8:	3302      	adds	r3, #2
 8005dea:	429a      	cmp	r2, r3
 8005dec:	d200      	bcs.n	8005df0 <mqtt_message_received+0x1f4>
 8005dee:	e122      	b.n	8006036 <mqtt_message_received+0x43a>
          LWIP_DEBUGF(MQTT_DEBUG_WARN,( "mqtt_message_received: Received short PUBLISH packet (after_topic)\n"));
          goto out_disconnect;
        }
        client->inpub_pkt_id = ((u16_t)var_hdr_payload[after_topic] << 8) + (u16_t)var_hdr_payload[after_topic + 1];
 8005df0:	183b      	adds	r3, r7, r0
 8005df2:	881b      	ldrh	r3, [r3, #0]
 8005df4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8005df6:	18d3      	adds	r3, r2, r3
 8005df8:	781b      	ldrb	r3, [r3, #0]
 8005dfa:	b29b      	uxth	r3, r3
 8005dfc:	021b      	lsls	r3, r3, #8
 8005dfe:	b29a      	uxth	r2, r3
 8005e00:	183b      	adds	r3, r7, r0
 8005e02:	881b      	ldrh	r3, [r3, #0]
 8005e04:	3301      	adds	r3, #1
 8005e06:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8005e08:	18cb      	adds	r3, r1, r3
 8005e0a:	781b      	ldrb	r3, [r3, #0]
 8005e0c:	b29b      	uxth	r3, r3
 8005e0e:	18d3      	adds	r3, r2, r3
 8005e10:	b29a      	uxth	r2, r3
 8005e12:	68fb      	ldr	r3, [r7, #12]
 8005e14:	811a      	strh	r2, [r3, #8]
        after_topic += 2;
 8005e16:	183b      	adds	r3, r7, r0
 8005e18:	183a      	adds	r2, r7, r0
 8005e1a:	8812      	ldrh	r2, [r2, #0]
 8005e1c:	3202      	adds	r2, #2
 8005e1e:	801a      	strh	r2, [r3, #0]
 8005e20:	e002      	b.n	8005e28 <mqtt_message_received+0x22c>
      } else {
        client->inpub_pkt_id = 0;
 8005e22:	68fb      	ldr	r3, [r7, #12]
 8005e24:	2200      	movs	r2, #0
 8005e26:	811a      	strh	r2, [r3, #8]
      }
      /* Take backup of byte after topic */
      bkp = topic[topic_len];
 8005e28:	211a      	movs	r1, #26
 8005e2a:	187b      	adds	r3, r7, r1
 8005e2c:	881b      	ldrh	r3, [r3, #0]
 8005e2e:	697a      	ldr	r2, [r7, #20]
 8005e30:	18d2      	adds	r2, r2, r3
 8005e32:	2313      	movs	r3, #19
 8005e34:	18fb      	adds	r3, r7, r3
 8005e36:	7812      	ldrb	r2, [r2, #0]
 8005e38:	701a      	strb	r2, [r3, #0]
      /* Zero terminate string */
      topic[topic_len] = 0;
 8005e3a:	187b      	adds	r3, r7, r1
 8005e3c:	881b      	ldrh	r3, [r3, #0]
 8005e3e:	697a      	ldr	r2, [r7, #20]
 8005e40:	18d3      	adds	r3, r2, r3
 8005e42:	2200      	movs	r2, #0
 8005e44:	701a      	strb	r2, [r3, #0]
      /* Payload data remaining in receive buffer */
      payload_length = length - after_topic;
 8005e46:	2532      	movs	r5, #50	; 0x32
 8005e48:	197b      	adds	r3, r7, r5
 8005e4a:	2208      	movs	r2, #8
 8005e4c:	18b9      	adds	r1, r7, r2
 8005e4e:	2036      	movs	r0, #54	; 0x36
 8005e50:	183a      	adds	r2, r7, r0
 8005e52:	8809      	ldrh	r1, [r1, #0]
 8005e54:	8812      	ldrh	r2, [r2, #0]
 8005e56:	1a8a      	subs	r2, r1, r2
 8005e58:	801a      	strh	r2, [r3, #0]
      payload_offset = after_topic;
 8005e5a:	2334      	movs	r3, #52	; 0x34
 8005e5c:	18fb      	adds	r3, r7, r3
 8005e5e:	183a      	adds	r2, r7, r0
 8005e60:	8812      	ldrh	r2, [r2, #0]
 8005e62:	801a      	strh	r2, [r3, #0]

      LWIP_DEBUGF(MQTT_DEBUG_TRACE, ("mqtt_incomming_publish: Received message with QoS %d at topic: %s, payload length %"U32_F"\n",
                                     qos, topic, remaining_length + payload_length));
      if (client->pub_cb != NULL) {
 8005e64:	68fb      	ldr	r3, [r7, #12]
 8005e66:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8005e68:	2b00      	cmp	r3, #0
 8005e6a:	d00a      	beq.n	8005e82 <mqtt_message_received+0x286>
        client->pub_cb(client->inpub_arg, (const char *)topic, remaining_length + payload_length);
 8005e6c:	68fb      	ldr	r3, [r7, #12]
 8005e6e:	6e5c      	ldr	r4, [r3, #100]	; 0x64
 8005e70:	68fb      	ldr	r3, [r7, #12]
 8005e72:	6dd8      	ldr	r0, [r3, #92]	; 0x5c
 8005e74:	197b      	adds	r3, r7, r5
 8005e76:	881a      	ldrh	r2, [r3, #0]
 8005e78:	687b      	ldr	r3, [r7, #4]
 8005e7a:	18d2      	adds	r2, r2, r3
 8005e7c:	697b      	ldr	r3, [r7, #20]
 8005e7e:	0019      	movs	r1, r3
 8005e80:	47a0      	blx	r4
      }
      /* Restore byte after topic */
      topic[topic_len] = bkp;
 8005e82:	231a      	movs	r3, #26
 8005e84:	18fb      	adds	r3, r7, r3
 8005e86:	881b      	ldrh	r3, [r3, #0]
 8005e88:	697a      	ldr	r2, [r7, #20]
 8005e8a:	18d3      	adds	r3, r2, r3
 8005e8c:	2213      	movs	r2, #19
 8005e8e:	18ba      	adds	r2, r7, r2
 8005e90:	7812      	ldrb	r2, [r2, #0]
 8005e92:	701a      	strb	r2, [r3, #0]
    }
    if (payload_length > 0 || remaining_length == 0) {
 8005e94:	2332      	movs	r3, #50	; 0x32
 8005e96:	18fb      	adds	r3, r7, r3
 8005e98:	881b      	ldrh	r3, [r3, #0]
 8005e9a:	2b00      	cmp	r3, #0
 8005e9c:	d103      	bne.n	8005ea6 <mqtt_message_received+0x2aa>
 8005e9e:	687b      	ldr	r3, [r7, #4]
 8005ea0:	2b00      	cmp	r3, #0
 8005ea2:	d000      	beq.n	8005ea6 <mqtt_message_received+0x2aa>
 8005ea4:	e0bb      	b.n	800601e <mqtt_message_received+0x422>
      if (length < (size_t)(payload_offset + payload_length)) {
 8005ea6:	2308      	movs	r3, #8
 8005ea8:	18fb      	adds	r3, r7, r3
 8005eaa:	881b      	ldrh	r3, [r3, #0]
 8005eac:	2534      	movs	r5, #52	; 0x34
 8005eae:	197a      	adds	r2, r7, r5
 8005eb0:	8811      	ldrh	r1, [r2, #0]
 8005eb2:	2632      	movs	r6, #50	; 0x32
 8005eb4:	19ba      	adds	r2, r7, r6
 8005eb6:	8812      	ldrh	r2, [r2, #0]
 8005eb8:	188a      	adds	r2, r1, r2
 8005eba:	4293      	cmp	r3, r2
 8005ebc:	d200      	bcs.n	8005ec0 <mqtt_message_received+0x2c4>
 8005ebe:	e0bc      	b.n	800603a <mqtt_message_received+0x43e>
        LWIP_DEBUGF(MQTT_DEBUG_WARN,( "mqtt_message_received: Received short packet (payload)\n"));
        goto out_disconnect;
      }
      if (client->data_cb != NULL) {
 8005ec0:	68fb      	ldr	r3, [r7, #12]
 8005ec2:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8005ec4:	2b00      	cmp	r3, #0
 8005ec6:	d010      	beq.n	8005eea <mqtt_message_received+0x2ee>
        client->data_cb(client->inpub_arg, var_hdr_payload + payload_offset, payload_length, remaining_length == 0 ? MQTT_DATA_FLAG_LAST : 0);
 8005ec8:	68fb      	ldr	r3, [r7, #12]
 8005eca:	6e1c      	ldr	r4, [r3, #96]	; 0x60
 8005ecc:	68fb      	ldr	r3, [r7, #12]
 8005ece:	6dd8      	ldr	r0, [r3, #92]	; 0x5c
 8005ed0:	197b      	adds	r3, r7, r5
 8005ed2:	881b      	ldrh	r3, [r3, #0]
 8005ed4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8005ed6:	18d1      	adds	r1, r2, r3
 8005ed8:	687b      	ldr	r3, [r7, #4]
 8005eda:	425a      	negs	r2, r3
 8005edc:	4153      	adcs	r3, r2
 8005ede:	b2db      	uxtb	r3, r3
 8005ee0:	001d      	movs	r5, r3
 8005ee2:	19bb      	adds	r3, r7, r6
 8005ee4:	881a      	ldrh	r2, [r3, #0]
 8005ee6:	002b      	movs	r3, r5
 8005ee8:	47a0      	blx	r4
      }
      /* Reply if QoS > 0 */
      if (remaining_length == 0 && qos > 0) {
 8005eea:	687b      	ldr	r3, [r7, #4]
 8005eec:	2b00      	cmp	r3, #0
 8005eee:	d000      	beq.n	8005ef2 <mqtt_message_received+0x2f6>
 8005ef0:	e095      	b.n	800601e <mqtt_message_received+0x422>
 8005ef2:	221f      	movs	r2, #31
 8005ef4:	18bb      	adds	r3, r7, r2
 8005ef6:	781b      	ldrb	r3, [r3, #0]
 8005ef8:	2b00      	cmp	r3, #0
 8005efa:	d100      	bne.n	8005efe <mqtt_message_received+0x302>
 8005efc:	e08f      	b.n	800601e <mqtt_message_received+0x422>
        /* Send PUBACK for QoS 1 or PUBREC for QoS 2 */
        u8_t resp_msg = (qos == 1) ? MQTT_MSG_TYPE_PUBACK : MQTT_MSG_TYPE_PUBREC;
 8005efe:	18bb      	adds	r3, r7, r2
 8005f00:	781b      	ldrb	r3, [r3, #0]
 8005f02:	2b01      	cmp	r3, #1
 8005f04:	d101      	bne.n	8005f0a <mqtt_message_received+0x30e>
 8005f06:	2204      	movs	r2, #4
 8005f08:	e000      	b.n	8005f0c <mqtt_message_received+0x310>
 8005f0a:	2205      	movs	r2, #5
 8005f0c:	2112      	movs	r1, #18
 8005f0e:	187b      	adds	r3, r7, r1
 8005f10:	701a      	strb	r2, [r3, #0]
        LWIP_DEBUGF(MQTT_DEBUG_TRACE, ("mqtt_incomming_publish: Sending publish response: %s with pkt_id: %d\n",
                                       mqtt_msg_type_to_str(resp_msg), client->inpub_pkt_id));
        pub_ack_rec_rel_response(client, resp_msg, client->inpub_pkt_id, 0);
 8005f12:	68fb      	ldr	r3, [r7, #12]
 8005f14:	891a      	ldrh	r2, [r3, #8]
 8005f16:	187b      	adds	r3, r7, r1
 8005f18:	7819      	ldrb	r1, [r3, #0]
 8005f1a:	68f8      	ldr	r0, [r7, #12]
 8005f1c:	2300      	movs	r3, #0
 8005f1e:	f7ff fe05 	bl	8005b2c <pub_ack_rec_rel_response>
 8005f22:	e07c      	b.n	800601e <mqtt_message_received+0x422>
      }
    }
  } else {
    /* Get packet identifier */
    pkt_id = (u16_t)var_hdr_payload[0] << 8;
 8005f24:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005f26:	781b      	ldrb	r3, [r3, #0]
 8005f28:	b29a      	uxth	r2, r3
 8005f2a:	2024      	movs	r0, #36	; 0x24
 8005f2c:	183b      	adds	r3, r7, r0
 8005f2e:	0212      	lsls	r2, r2, #8
 8005f30:	801a      	strh	r2, [r3, #0]
    pkt_id |= (u16_t)var_hdr_payload[1];
 8005f32:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005f34:	3301      	adds	r3, #1
 8005f36:	781b      	ldrb	r3, [r3, #0]
 8005f38:	b299      	uxth	r1, r3
 8005f3a:	183b      	adds	r3, r7, r0
 8005f3c:	183a      	adds	r2, r7, r0
 8005f3e:	8812      	ldrh	r2, [r2, #0]
 8005f40:	430a      	orrs	r2, r1
 8005f42:	801a      	strh	r2, [r3, #0]
    if (pkt_id == 0) {
 8005f44:	183b      	adds	r3, r7, r0
 8005f46:	881b      	ldrh	r3, [r3, #0]
 8005f48:	2b00      	cmp	r3, #0
 8005f4a:	d100      	bne.n	8005f4e <mqtt_message_received+0x352>
 8005f4c:	e077      	b.n	800603e <mqtt_message_received+0x442>
      LWIP_DEBUGF(MQTT_DEBUG_WARN, ("mqtt_message_received: Got message with illegal packet identifier: 0\n"));
      goto out_disconnect;
    }
    if (pkt_type == MQTT_MSG_TYPE_PUBREC) {
 8005f4e:	2327      	movs	r3, #39	; 0x27
 8005f50:	18fb      	adds	r3, r7, r3
 8005f52:	781b      	ldrb	r3, [r3, #0]
 8005f54:	2b05      	cmp	r3, #5
 8005f56:	d107      	bne.n	8005f68 <mqtt_message_received+0x36c>
      LWIP_DEBUGF(MQTT_DEBUG_TRACE, ("mqtt_message_received: PUBREC, sending PUBREL with pkt_id: %d\n", pkt_id));
      pub_ack_rec_rel_response(client, MQTT_MSG_TYPE_PUBREL, pkt_id, 1);
 8005f58:	183b      	adds	r3, r7, r0
 8005f5a:	881a      	ldrh	r2, [r3, #0]
 8005f5c:	68f8      	ldr	r0, [r7, #12]
 8005f5e:	2301      	movs	r3, #1
 8005f60:	2106      	movs	r1, #6
 8005f62:	f7ff fde3 	bl	8005b2c <pub_ack_rec_rel_response>
 8005f66:	e05a      	b.n	800601e <mqtt_message_received+0x422>

    } else if (pkt_type == MQTT_MSG_TYPE_PUBREL) {
 8005f68:	2327      	movs	r3, #39	; 0x27
 8005f6a:	18fb      	adds	r3, r7, r3
 8005f6c:	781b      	ldrb	r3, [r3, #0]
 8005f6e:	2b06      	cmp	r3, #6
 8005f70:	d112      	bne.n	8005f98 <mqtt_message_received+0x39c>
      LWIP_DEBUGF(MQTT_DEBUG_TRACE, ("mqtt_message_received: PUBREL, sending PUBCOMP response with pkt_id: %d\n", pkt_id));
      pub_ack_rec_rel_response(client, MQTT_MSG_TYPE_PUBCOMP, pkt_id, 0);
 8005f72:	2324      	movs	r3, #36	; 0x24
 8005f74:	18fb      	adds	r3, r7, r3
 8005f76:	881a      	ldrh	r2, [r3, #0]
 8005f78:	68f8      	ldr	r0, [r7, #12]
 8005f7a:	2300      	movs	r3, #0
 8005f7c:	2107      	movs	r1, #7
 8005f7e:	f7ff fdd5 	bl	8005b2c <pub_ack_rec_rel_response>
 8005f82:	e04c      	b.n	800601e <mqtt_message_received+0x422>
 8005f84:	0801f5e8 	.word	0x0801f5e8
 8005f88:	000002ab 	.word	0x000002ab
 8005f8c:	0801f814 	.word	0x0801f814
 8005f90:	0801f654 	.word	0x0801f654
 8005f94:	0801f838 	.word	0x0801f838

    } else if (pkt_type == MQTT_MSG_TYPE_SUBACK || pkt_type == MQTT_MSG_TYPE_UNSUBACK ||
 8005f98:	2227      	movs	r2, #39	; 0x27
 8005f9a:	18bb      	adds	r3, r7, r2
 8005f9c:	781b      	ldrb	r3, [r3, #0]
 8005f9e:	2b09      	cmp	r3, #9
 8005fa0:	d00b      	beq.n	8005fba <mqtt_message_received+0x3be>
 8005fa2:	18bb      	adds	r3, r7, r2
 8005fa4:	781b      	ldrb	r3, [r3, #0]
 8005fa6:	2b0b      	cmp	r3, #11
 8005fa8:	d007      	beq.n	8005fba <mqtt_message_received+0x3be>
 8005faa:	18bb      	adds	r3, r7, r2
 8005fac:	781b      	ldrb	r3, [r3, #0]
 8005fae:	2b07      	cmp	r3, #7
 8005fb0:	d003      	beq.n	8005fba <mqtt_message_received+0x3be>
               pkt_type == MQTT_MSG_TYPE_PUBCOMP || pkt_type == MQTT_MSG_TYPE_PUBACK) {
 8005fb2:	18bb      	adds	r3, r7, r2
 8005fb4:	781b      	ldrb	r3, [r3, #0]
 8005fb6:	2b04      	cmp	r3, #4
 8005fb8:	d143      	bne.n	8006042 <mqtt_message_received+0x446>
      struct mqtt_request_t *r = mqtt_take_request(&client->pend_req_queue, pkt_id);
 8005fba:	68fb      	ldr	r3, [r7, #12]
 8005fbc:	3318      	adds	r3, #24
 8005fbe:	001a      	movs	r2, r3
 8005fc0:	2324      	movs	r3, #36	; 0x24
 8005fc2:	18fb      	adds	r3, r7, r3
 8005fc4:	881b      	ldrh	r3, [r3, #0]
 8005fc6:	0019      	movs	r1, r3
 8005fc8:	0010      	movs	r0, r2
 8005fca:	f7ff fa5d 	bl	8005488 <mqtt_take_request>
 8005fce:	0003      	movs	r3, r0
 8005fd0:	623b      	str	r3, [r7, #32]
      if (r != NULL) {
 8005fd2:	6a3b      	ldr	r3, [r7, #32]
 8005fd4:	2b00      	cmp	r3, #0
 8005fd6:	d021      	beq.n	800601c <mqtt_message_received+0x420>
        LWIP_DEBUGF(MQTT_DEBUG_TRACE, ("mqtt_message_received: %s response with id %d\n", mqtt_msg_type_to_str(pkt_type), pkt_id));
        if (pkt_type == MQTT_MSG_TYPE_SUBACK) {
 8005fd8:	2327      	movs	r3, #39	; 0x27
 8005fda:	18fb      	adds	r3, r7, r3
 8005fdc:	781b      	ldrb	r3, [r3, #0]
 8005fde:	2b09      	cmp	r3, #9
 8005fe0:	d10d      	bne.n	8005ffe <mqtt_message_received+0x402>
          if (length < 3) {
 8005fe2:	2308      	movs	r3, #8
 8005fe4:	18fb      	adds	r3, r7, r3
 8005fe6:	881b      	ldrh	r3, [r3, #0]
 8005fe8:	2b02      	cmp	r3, #2
 8005fea:	d92c      	bls.n	8006046 <mqtt_message_received+0x44a>
            LWIP_DEBUGF(MQTT_DEBUG_WARN, ("mqtt_message_received: To small SUBACK packet\n"));
            goto out_disconnect;
          } else {
            mqtt_incomming_suback(r, var_hdr_payload[2]);
 8005fec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005fee:	3302      	adds	r3, #2
 8005ff0:	781a      	ldrb	r2, [r3, #0]
 8005ff2:	6a3b      	ldr	r3, [r7, #32]
 8005ff4:	0011      	movs	r1, r2
 8005ff6:	0018      	movs	r0, r3
 8005ff8:	f7ff fde2 	bl	8005bc0 <mqtt_incomming_suback>
 8005ffc:	e00a      	b.n	8006014 <mqtt_message_received+0x418>
          }
        } else if (r->cb != NULL) {
 8005ffe:	6a3b      	ldr	r3, [r7, #32]
 8006000:	685b      	ldr	r3, [r3, #4]
 8006002:	2b00      	cmp	r3, #0
 8006004:	d006      	beq.n	8006014 <mqtt_message_received+0x418>
          r->cb(r->arg, ERR_OK);
 8006006:	6a3b      	ldr	r3, [r7, #32]
 8006008:	685a      	ldr	r2, [r3, #4]
 800600a:	6a3b      	ldr	r3, [r7, #32]
 800600c:	689b      	ldr	r3, [r3, #8]
 800600e:	2100      	movs	r1, #0
 8006010:	0018      	movs	r0, r3
 8006012:	4790      	blx	r2
        }
        mqtt_delete_request(r);
 8006014:	6a3b      	ldr	r3, [r7, #32]
 8006016:	0018      	movs	r0, r3
 8006018:	f7ff fa28 	bl	800546c <mqtt_delete_request>
               pkt_type == MQTT_MSG_TYPE_PUBCOMP || pkt_type == MQTT_MSG_TYPE_PUBACK) {
 800601c:	46c0      	nop			; (mov r8, r8)
    } else {
      LWIP_DEBUGF(MQTT_DEBUG_WARN, ( "mqtt_message_received: Received unknown message type: %d\n", pkt_type));
      goto out_disconnect;
    }
  }
  return res;
 800601e:	2330      	movs	r3, #48	; 0x30
 8006020:	18fb      	adds	r3, r7, r3
 8006022:	881b      	ldrh	r3, [r3, #0]
 8006024:	e012      	b.n	800604c <mqtt_message_received+0x450>
        goto out_disconnect;
 8006026:	46c0      	nop			; (mov r8, r8)
 8006028:	e00e      	b.n	8006048 <mqtt_message_received+0x44c>
        goto out_disconnect;
 800602a:	46c0      	nop			; (mov r8, r8)
 800602c:	e00c      	b.n	8006048 <mqtt_message_received+0x44c>
        goto out_disconnect;
 800602e:	46c0      	nop			; (mov r8, r8)
 8006030:	e00a      	b.n	8006048 <mqtt_message_received+0x44c>
        goto out_disconnect;
 8006032:	46c0      	nop			; (mov r8, r8)
 8006034:	e008      	b.n	8006048 <mqtt_message_received+0x44c>
          goto out_disconnect;
 8006036:	46c0      	nop			; (mov r8, r8)
 8006038:	e006      	b.n	8006048 <mqtt_message_received+0x44c>
        goto out_disconnect;
 800603a:	46c0      	nop			; (mov r8, r8)
 800603c:	e004      	b.n	8006048 <mqtt_message_received+0x44c>
      goto out_disconnect;
 800603e:	46c0      	nop			; (mov r8, r8)
 8006040:	e002      	b.n	8006048 <mqtt_message_received+0x44c>
      goto out_disconnect;
 8006042:	46c0      	nop			; (mov r8, r8)
 8006044:	e000      	b.n	8006048 <mqtt_message_received+0x44c>
            goto out_disconnect;
 8006046:	46c0      	nop			; (mov r8, r8)
out_disconnect:
  return MQTT_CONNECT_DISCONNECTED;
 8006048:	2380      	movs	r3, #128	; 0x80
 800604a:	005b      	lsls	r3, r3, #1
}
 800604c:	0018      	movs	r0, r3
 800604e:	46bd      	mov	sp, r7
 8006050:	b00f      	add	sp, #60	; 0x3c
 8006052:	bdf0      	pop	{r4, r5, r6, r7, pc}

08006054 <mqtt_parse_incoming>:
 * @param p PBUF chain of received data
 * @return Connection status
 */
static mqtt_connection_status_t
mqtt_parse_incoming(mqtt_client_t *client, struct pbuf *p)
{
 8006054:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006056:	b087      	sub	sp, #28
 8006058:	af00      	add	r7, sp, #0
 800605a:	6078      	str	r0, [r7, #4]
 800605c:	6039      	str	r1, [r7, #0]
  u16_t in_offset = 0;
 800605e:	2316      	movs	r3, #22
 8006060:	18fb      	adds	r3, r7, r3
 8006062:	2200      	movs	r2, #0
 8006064:	801a      	strh	r2, [r3, #0]
  u32_t msg_rem_len = 0;
 8006066:	2300      	movs	r3, #0
 8006068:	613b      	str	r3, [r7, #16]
  u8_t fixed_hdr_len = 0;
 800606a:	230f      	movs	r3, #15
 800606c:	18fb      	adds	r3, r7, r3
 800606e:	2200      	movs	r2, #0
 8006070:	701a      	strb	r2, [r3, #0]
  u8_t b = 0;
 8006072:	230e      	movs	r3, #14
 8006074:	18fb      	adds	r3, r7, r3
 8006076:	2200      	movs	r2, #0
 8006078:	701a      	strb	r2, [r3, #0]

  while (p->tot_len > in_offset) {
 800607a:	e103      	b.n	8006284 <mqtt_parse_incoming+0x230>
    /* We ALWAYS parse the header here first. Even if the header was not
       included in this segment, we re-parse it here by buffering it in
       client->rx_buffer. client->msg_idx keeps track of this. */
    if ((fixed_hdr_len < 2) || ((b & 0x80) != 0)) {
 800607c:	230f      	movs	r3, #15
 800607e:	18fb      	adds	r3, r7, r3
 8006080:	781b      	ldrb	r3, [r3, #0]
 8006082:	2b01      	cmp	r3, #1
 8006084:	d905      	bls.n	8006092 <mqtt_parse_incoming+0x3e>
 8006086:	230e      	movs	r3, #14
 8006088:	18fb      	adds	r3, r7, r3
 800608a:	781b      	ldrb	r3, [r3, #0]
 800608c:	b25b      	sxtb	r3, r3
 800608e:	2b00      	cmp	r3, #0
 8006090:	da6a      	bge.n	8006168 <mqtt_parse_incoming+0x114>

      if (fixed_hdr_len < client->msg_idx) {
 8006092:	210f      	movs	r1, #15
 8006094:	187b      	adds	r3, r7, r1
 8006096:	781a      	ldrb	r2, [r3, #0]
 8006098:	687b      	ldr	r3, [r7, #4]
 800609a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800609c:	429a      	cmp	r2, r3
 800609e:	d20a      	bcs.n	80060b6 <mqtt_parse_incoming+0x62>
        /* parse header from old pbuf (buffered in client->rx_buffer) */
        b = client->rx_buffer[fixed_hdr_len];
 80060a0:	187b      	adds	r3, r7, r1
 80060a2:	781a      	ldrb	r2, [r3, #0]
 80060a4:	230e      	movs	r3, #14
 80060a6:	18fb      	adds	r3, r7, r3
 80060a8:	6879      	ldr	r1, [r7, #4]
 80060aa:	206c      	movs	r0, #108	; 0x6c
 80060ac:	188a      	adds	r2, r1, r2
 80060ae:	1812      	adds	r2, r2, r0
 80060b0:	7812      	ldrb	r2, [r2, #0]
 80060b2:	701a      	strb	r2, [r3, #0]
 80060b4:	e01a      	b.n	80060ec <mqtt_parse_incoming+0x98>
      } else {
        /* parse header from this pbuf and save it in client->rx_buffer in case
           it comes in segmented */
        b = pbuf_get_at(p, in_offset++);
 80060b6:	2216      	movs	r2, #22
 80060b8:	18bb      	adds	r3, r7, r2
 80060ba:	881b      	ldrh	r3, [r3, #0]
 80060bc:	18ba      	adds	r2, r7, r2
 80060be:	1c59      	adds	r1, r3, #1
 80060c0:	8011      	strh	r1, [r2, #0]
 80060c2:	250e      	movs	r5, #14
 80060c4:	197c      	adds	r4, r7, r5
 80060c6:	683a      	ldr	r2, [r7, #0]
 80060c8:	0019      	movs	r1, r3
 80060ca:	0010      	movs	r0, r2
 80060cc:	f004 ff20 	bl	800af10 <pbuf_get_at>
 80060d0:	0003      	movs	r3, r0
 80060d2:	7023      	strb	r3, [r4, #0]
        client->rx_buffer[client->msg_idx++] = b;
 80060d4:	687b      	ldr	r3, [r7, #4]
 80060d6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80060d8:	1c59      	adds	r1, r3, #1
 80060da:	687a      	ldr	r2, [r7, #4]
 80060dc:	6691      	str	r1, [r2, #104]	; 0x68
 80060de:	687a      	ldr	r2, [r7, #4]
 80060e0:	216c      	movs	r1, #108	; 0x6c
 80060e2:	18d3      	adds	r3, r2, r3
 80060e4:	185b      	adds	r3, r3, r1
 80060e6:	197a      	adds	r2, r7, r5
 80060e8:	7812      	ldrb	r2, [r2, #0]
 80060ea:	701a      	strb	r2, [r3, #0]
      }
      fixed_hdr_len++;
 80060ec:	200f      	movs	r0, #15
 80060ee:	183b      	adds	r3, r7, r0
 80060f0:	781a      	ldrb	r2, [r3, #0]
 80060f2:	183b      	adds	r3, r7, r0
 80060f4:	3201      	adds	r2, #1
 80060f6:	701a      	strb	r2, [r3, #0]

      if (fixed_hdr_len >= 2) {
 80060f8:	183b      	adds	r3, r7, r0
 80060fa:	781b      	ldrb	r3, [r3, #0]
 80060fc:	2b01      	cmp	r3, #1
 80060fe:	d800      	bhi.n	8006102 <mqtt_parse_incoming+0xae>
 8006100:	e0c0      	b.n	8006284 <mqtt_parse_incoming+0x230>
        /* fixed header contains at least 2 bytes but can contain more, depending on
           'remaining length'. All bytes but the last of this have 0x80 set to
           indicate more bytes are coming. */
        msg_rem_len |= (u32_t)(b & 0x7f) << ((fixed_hdr_len - 2) * 7);
 8006102:	240e      	movs	r4, #14
 8006104:	193b      	adds	r3, r7, r4
 8006106:	781b      	ldrb	r3, [r3, #0]
 8006108:	227f      	movs	r2, #127	; 0x7f
 800610a:	4013      	ands	r3, r2
 800610c:	0019      	movs	r1, r3
 800610e:	183b      	adds	r3, r7, r0
 8006110:	781b      	ldrb	r3, [r3, #0]
 8006112:	1e9a      	subs	r2, r3, #2
 8006114:	0013      	movs	r3, r2
 8006116:	00db      	lsls	r3, r3, #3
 8006118:	1a9b      	subs	r3, r3, r2
 800611a:	4099      	lsls	r1, r3
 800611c:	000b      	movs	r3, r1
 800611e:	693a      	ldr	r2, [r7, #16]
 8006120:	4313      	orrs	r3, r2
 8006122:	613b      	str	r3, [r7, #16]
        if ((b & 0x80) == 0) {
 8006124:	193b      	adds	r3, r7, r4
 8006126:	781b      	ldrb	r3, [r3, #0]
 8006128:	b25b      	sxtb	r3, r3
 800612a:	2b00      	cmp	r3, #0
 800612c:	da00      	bge.n	8006130 <mqtt_parse_incoming+0xdc>
 800612e:	e0a9      	b.n	8006284 <mqtt_parse_incoming+0x230>
          /* fixed header is done */
          LWIP_DEBUGF(MQTT_DEBUG_TRACE, ("mqtt_parse_incoming: Remaining length after fixed header: %"U32_F"\n", msg_rem_len));
          if (msg_rem_len == 0) {
 8006130:	693b      	ldr	r3, [r7, #16]
 8006132:	2b00      	cmp	r3, #0
 8006134:	d10e      	bne.n	8006154 <mqtt_parse_incoming+0x100>
            /* Complete message with no extra headers of payload received */
            mqtt_message_received(client, fixed_hdr_len, 0, 0);
 8006136:	0004      	movs	r4, r0
 8006138:	183b      	adds	r3, r7, r0
 800613a:	7819      	ldrb	r1, [r3, #0]
 800613c:	6878      	ldr	r0, [r7, #4]
 800613e:	2300      	movs	r3, #0
 8006140:	2200      	movs	r2, #0
 8006142:	f7ff fd5b 	bl	8005bfc <mqtt_message_received>
            client->msg_idx = 0;
 8006146:	687b      	ldr	r3, [r7, #4]
 8006148:	2200      	movs	r2, #0
 800614a:	669a      	str	r2, [r3, #104]	; 0x68
            fixed_hdr_len = 0;
 800614c:	193b      	adds	r3, r7, r4
 800614e:	2200      	movs	r2, #0
 8006150:	701a      	strb	r2, [r3, #0]
 8006152:	e097      	b.n	8006284 <mqtt_parse_incoming+0x230>
          } else {
            /* Bytes remaining in message (changes remaining length if this is
               not the first segment of this message) */
            msg_rem_len = (msg_rem_len + fixed_hdr_len) - client->msg_idx;
 8006154:	230f      	movs	r3, #15
 8006156:	18fb      	adds	r3, r7, r3
 8006158:	781a      	ldrb	r2, [r3, #0]
 800615a:	693b      	ldr	r3, [r7, #16]
 800615c:	18d2      	adds	r2, r2, r3
 800615e:	687b      	ldr	r3, [r7, #4]
 8006160:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8006162:	1ad3      	subs	r3, r2, r3
 8006164:	613b      	str	r3, [r7, #16]
      if (fixed_hdr_len >= 2) {
 8006166:	e08d      	b.n	8006284 <mqtt_parse_incoming+0x230>
    } else {
      /* Fixed header has been parsed, parse variable header */
      u16_t cpy_len, buffer_space;

      /* Allow to copy the lesser one of available length in input data or bytes remaining in message */
      cpy_len = (u16_t)LWIP_MIN((u16_t)(p->tot_len - in_offset), msg_rem_len);
 8006168:	683b      	ldr	r3, [r7, #0]
 800616a:	891a      	ldrh	r2, [r3, #8]
 800616c:	2116      	movs	r1, #22
 800616e:	187b      	adds	r3, r7, r1
 8006170:	881b      	ldrh	r3, [r3, #0]
 8006172:	1ad3      	subs	r3, r2, r3
 8006174:	b29b      	uxth	r3, r3
 8006176:	001a      	movs	r2, r3
 8006178:	693b      	ldr	r3, [r7, #16]
 800617a:	4293      	cmp	r3, r2
 800617c:	d906      	bls.n	800618c <mqtt_parse_incoming+0x138>
 800617e:	683b      	ldr	r3, [r7, #0]
 8006180:	891a      	ldrh	r2, [r3, #8]
 8006182:	187b      	adds	r3, r7, r1
 8006184:	881b      	ldrh	r3, [r3, #0]
 8006186:	1ad3      	subs	r3, r2, r3
 8006188:	b29b      	uxth	r3, r3
 800618a:	e001      	b.n	8006190 <mqtt_parse_incoming+0x13c>
 800618c:	693b      	ldr	r3, [r7, #16]
 800618e:	b29b      	uxth	r3, r3
 8006190:	200c      	movs	r0, #12
 8006192:	183a      	adds	r2, r7, r0
 8006194:	8013      	strh	r3, [r2, #0]

      /* Limit to available space in buffer */
      buffer_space = MQTT_VAR_HEADER_BUFFER_LEN - fixed_hdr_len;
 8006196:	230f      	movs	r3, #15
 8006198:	18fb      	adds	r3, r7, r3
 800619a:	781b      	ldrb	r3, [r3, #0]
 800619c:	b29a      	uxth	r2, r3
 800619e:	240a      	movs	r4, #10
 80061a0:	193b      	adds	r3, r7, r4
 80061a2:	2180      	movs	r1, #128	; 0x80
 80061a4:	1a8a      	subs	r2, r1, r2
 80061a6:	801a      	strh	r2, [r3, #0]
      if (cpy_len > buffer_space) {
 80061a8:	183a      	adds	r2, r7, r0
 80061aa:	0021      	movs	r1, r4
 80061ac:	187b      	adds	r3, r7, r1
 80061ae:	8812      	ldrh	r2, [r2, #0]
 80061b0:	881b      	ldrh	r3, [r3, #0]
 80061b2:	429a      	cmp	r2, r3
 80061b4:	d903      	bls.n	80061be <mqtt_parse_incoming+0x16a>
        cpy_len = buffer_space;
 80061b6:	183b      	adds	r3, r7, r0
 80061b8:	187a      	adds	r2, r7, r1
 80061ba:	8812      	ldrh	r2, [r2, #0]
 80061bc:	801a      	strh	r2, [r3, #0]
      }
      pbuf_copy_partial(p, client->rx_buffer + fixed_hdr_len, cpy_len, in_offset);
 80061be:	687b      	ldr	r3, [r7, #4]
 80061c0:	336c      	adds	r3, #108	; 0x6c
 80061c2:	001a      	movs	r2, r3
 80061c4:	260f      	movs	r6, #15
 80061c6:	19bb      	adds	r3, r7, r6
 80061c8:	781b      	ldrb	r3, [r3, #0]
 80061ca:	18d1      	adds	r1, r2, r3
 80061cc:	2216      	movs	r2, #22
 80061ce:	18bb      	adds	r3, r7, r2
 80061d0:	881c      	ldrh	r4, [r3, #0]
 80061d2:	250c      	movs	r5, #12
 80061d4:	197b      	adds	r3, r7, r5
 80061d6:	881a      	ldrh	r2, [r3, #0]
 80061d8:	6838      	ldr	r0, [r7, #0]
 80061da:	0023      	movs	r3, r4
 80061dc:	f004 fc48 	bl	800aa70 <pbuf_copy_partial>

      /* Advance get and put indexes  */
      client->msg_idx += cpy_len;
 80061e0:	687b      	ldr	r3, [r7, #4]
 80061e2:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 80061e4:	0028      	movs	r0, r5
 80061e6:	183b      	adds	r3, r7, r0
 80061e8:	881b      	ldrh	r3, [r3, #0]
 80061ea:	18d2      	adds	r2, r2, r3
 80061ec:	687b      	ldr	r3, [r7, #4]
 80061ee:	669a      	str	r2, [r3, #104]	; 0x68
      in_offset += cpy_len;
 80061f0:	2216      	movs	r2, #22
 80061f2:	18bb      	adds	r3, r7, r2
 80061f4:	18b9      	adds	r1, r7, r2
 80061f6:	183a      	adds	r2, r7, r0
 80061f8:	8809      	ldrh	r1, [r1, #0]
 80061fa:	8812      	ldrh	r2, [r2, #0]
 80061fc:	188a      	adds	r2, r1, r2
 80061fe:	801a      	strh	r2, [r3, #0]
      msg_rem_len -= cpy_len;
 8006200:	0001      	movs	r1, r0
 8006202:	183b      	adds	r3, r7, r0
 8006204:	881b      	ldrh	r3, [r3, #0]
 8006206:	693a      	ldr	r2, [r7, #16]
 8006208:	1ad3      	subs	r3, r2, r3
 800620a:	613b      	str	r3, [r7, #16]

      LWIP_DEBUGF(MQTT_DEBUG_TRACE, ("mqtt_parse_incoming: msg_idx: %"U32_F", cpy_len: %"U16_F", remaining %"U32_F"\n", client->msg_idx, cpy_len, msg_rem_len));
      if ((msg_rem_len == 0) || (cpy_len == buffer_space)) {
 800620c:	693b      	ldr	r3, [r7, #16]
 800620e:	2b00      	cmp	r3, #0
 8006210:	d00f      	beq.n	8006232 <mqtt_parse_incoming+0x1de>
 8006212:	19bb      	adds	r3, r7, r6
 8006214:	19ba      	adds	r2, r7, r6
 8006216:	7812      	ldrb	r2, [r2, #0]
 8006218:	701a      	strb	r2, [r3, #0]
 800621a:	220e      	movs	r2, #14
 800621c:	18bb      	adds	r3, r7, r2
 800621e:	18ba      	adds	r2, r7, r2
 8006220:	7812      	ldrb	r2, [r2, #0]
 8006222:	701a      	strb	r2, [r3, #0]
 8006224:	187a      	adds	r2, r7, r1
 8006226:	230a      	movs	r3, #10
 8006228:	18fb      	adds	r3, r7, r3
 800622a:	8812      	ldrh	r2, [r2, #0]
 800622c:	881b      	ldrh	r3, [r3, #0]
 800622e:	429a      	cmp	r2, r3
 8006230:	d128      	bne.n	8006284 <mqtt_parse_incoming+0x230>
        /* Whole message received or buffer is full */
        mqtt_connection_status_t res = mqtt_message_received(client, fixed_hdr_len, cpy_len, msg_rem_len);
 8006232:	2608      	movs	r6, #8
 8006234:	19bc      	adds	r4, r7, r6
 8006236:	693d      	ldr	r5, [r7, #16]
 8006238:	230c      	movs	r3, #12
 800623a:	18fb      	adds	r3, r7, r3
 800623c:	881a      	ldrh	r2, [r3, #0]
 800623e:	230f      	movs	r3, #15
 8006240:	18fb      	adds	r3, r7, r3
 8006242:	7819      	ldrb	r1, [r3, #0]
 8006244:	6878      	ldr	r0, [r7, #4]
 8006246:	002b      	movs	r3, r5
 8006248:	f7ff fcd8 	bl	8005bfc <mqtt_message_received>
 800624c:	0003      	movs	r3, r0
 800624e:	8023      	strh	r3, [r4, #0]
        if (res != MQTT_CONNECT_ACCEPTED) {
 8006250:	19bb      	adds	r3, r7, r6
 8006252:	881b      	ldrh	r3, [r3, #0]
 8006254:	2b00      	cmp	r3, #0
 8006256:	d002      	beq.n	800625e <mqtt_parse_incoming+0x20a>
          return res;
 8006258:	19bb      	adds	r3, r7, r6
 800625a:	881b      	ldrh	r3, [r3, #0]
 800625c:	e01b      	b.n	8006296 <mqtt_parse_incoming+0x242>
 800625e:	210f      	movs	r1, #15
 8006260:	187b      	adds	r3, r7, r1
 8006262:	187a      	adds	r2, r7, r1
 8006264:	7812      	ldrb	r2, [r2, #0]
 8006266:	701a      	strb	r2, [r3, #0]
 8006268:	220e      	movs	r2, #14
 800626a:	18bb      	adds	r3, r7, r2
 800626c:	18ba      	adds	r2, r7, r2
 800626e:	7812      	ldrb	r2, [r2, #0]
 8006270:	701a      	strb	r2, [r3, #0]
        }
        if (msg_rem_len == 0) {
 8006272:	693b      	ldr	r3, [r7, #16]
 8006274:	2b00      	cmp	r3, #0
 8006276:	d105      	bne.n	8006284 <mqtt_parse_incoming+0x230>
          /* Reset parser state */
          client->msg_idx = 0;
 8006278:	687b      	ldr	r3, [r7, #4]
 800627a:	2200      	movs	r2, #0
 800627c:	669a      	str	r2, [r3, #104]	; 0x68
          /* msg_tot_len = 0; */
          fixed_hdr_len = 0;
 800627e:	187b      	adds	r3, r7, r1
 8006280:	2200      	movs	r2, #0
 8006282:	701a      	strb	r2, [r3, #0]
  while (p->tot_len > in_offset) {
 8006284:	683b      	ldr	r3, [r7, #0]
 8006286:	891b      	ldrh	r3, [r3, #8]
 8006288:	2216      	movs	r2, #22
 800628a:	18ba      	adds	r2, r7, r2
 800628c:	8812      	ldrh	r2, [r2, #0]
 800628e:	429a      	cmp	r2, r3
 8006290:	d200      	bcs.n	8006294 <mqtt_parse_incoming+0x240>
 8006292:	e6f3      	b.n	800607c <mqtt_parse_incoming+0x28>
        }
      }
    }
  }
  return MQTT_CONNECT_ACCEPTED;
 8006294:	2300      	movs	r3, #0
}
 8006296:	0018      	movs	r0, r3
 8006298:	46bd      	mov	sp, r7
 800629a:	b007      	add	sp, #28
 800629c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

080062a0 <mqtt_tcp_recv_cb>:
 * @param err Passed as return value if not ERR_OK
 * @return ERR_OK or err passed into callback
 */
static err_t
mqtt_tcp_recv_cb(void *arg, struct altcp_pcb *pcb, struct pbuf *p, err_t err)
{
 80062a0:	b5b0      	push	{r4, r5, r7, lr}
 80062a2:	b086      	sub	sp, #24
 80062a4:	af00      	add	r7, sp, #0
 80062a6:	60f8      	str	r0, [r7, #12]
 80062a8:	60b9      	str	r1, [r7, #8]
 80062aa:	607a      	str	r2, [r7, #4]
 80062ac:	001a      	movs	r2, r3
 80062ae:	1cfb      	adds	r3, r7, #3
 80062b0:	701a      	strb	r2, [r3, #0]
  mqtt_client_t *client = (mqtt_client_t *)arg;
 80062b2:	68fb      	ldr	r3, [r7, #12]
 80062b4:	617b      	str	r3, [r7, #20]
  LWIP_ASSERT("mqtt_tcp_recv_cb: client != NULL", client != NULL);
 80062b6:	697b      	ldr	r3, [r7, #20]
 80062b8:	2b00      	cmp	r3, #0
 80062ba:	d105      	bne.n	80062c8 <mqtt_tcp_recv_cb+0x28>
 80062bc:	4b2a      	ldr	r3, [pc, #168]	; (8006368 <mqtt_tcp_recv_cb+0xc8>)
 80062be:	4a2b      	ldr	r2, [pc, #172]	; (800636c <mqtt_tcp_recv_cb+0xcc>)
 80062c0:	492b      	ldr	r1, [pc, #172]	; (8006370 <mqtt_tcp_recv_cb+0xd0>)
 80062c2:	482c      	ldr	r0, [pc, #176]	; (8006374 <mqtt_tcp_recv_cb+0xd4>)
 80062c4:	f7fb ff8e 	bl	80021e4 <app_debug_rtt_raw>
  LWIP_ASSERT("mqtt_tcp_recv_cb: client->conn == pcb", client->conn == pcb);
 80062c8:	697b      	ldr	r3, [r7, #20]
 80062ca:	68db      	ldr	r3, [r3, #12]
 80062cc:	68ba      	ldr	r2, [r7, #8]
 80062ce:	429a      	cmp	r2, r3
 80062d0:	d005      	beq.n	80062de <mqtt_tcp_recv_cb+0x3e>
 80062d2:	4b25      	ldr	r3, [pc, #148]	; (8006368 <mqtt_tcp_recv_cb+0xc8>)
 80062d4:	4a28      	ldr	r2, [pc, #160]	; (8006378 <mqtt_tcp_recv_cb+0xd8>)
 80062d6:	4929      	ldr	r1, [pc, #164]	; (800637c <mqtt_tcp_recv_cb+0xdc>)
 80062d8:	4826      	ldr	r0, [pc, #152]	; (8006374 <mqtt_tcp_recv_cb+0xd4>)
 80062da:	f7fb ff83 	bl	80021e4 <app_debug_rtt_raw>

  if (p == NULL) {
 80062de:	687b      	ldr	r3, [r7, #4]
 80062e0:	2b00      	cmp	r3, #0
 80062e2:	d107      	bne.n	80062f4 <mqtt_tcp_recv_cb+0x54>
    LWIP_DEBUGF(MQTT_DEBUG_TRACE, ("mqtt_tcp_recv_cb: Recv pbuf=NULL, remote has closed connection\n"));
    mqtt_close(client, MQTT_CONNECT_DISCONNECTED);
 80062e4:	2380      	movs	r3, #128	; 0x80
 80062e6:	005a      	lsls	r2, r3, #1
 80062e8:	697b      	ldr	r3, [r7, #20]
 80062ea:	0011      	movs	r1, r2
 80062ec:	0018      	movs	r0, r3
 80062ee:	f7ff fb09 	bl	8005904 <mqtt_close>
 80062f2:	e033      	b.n	800635c <mqtt_tcp_recv_cb+0xbc>
  } else {
    mqtt_connection_status_t res;
    if (err != ERR_OK) {
 80062f4:	1cfb      	adds	r3, r7, #3
 80062f6:	781b      	ldrb	r3, [r3, #0]
 80062f8:	b25b      	sxtb	r3, r3
 80062fa:	2b00      	cmp	r3, #0
 80062fc:	d007      	beq.n	800630e <mqtt_tcp_recv_cb+0x6e>
      LWIP_DEBUGF(MQTT_DEBUG_WARN, ("mqtt_tcp_recv_cb: Recv err=%d\n", err));
      pbuf_free(p);
 80062fe:	687b      	ldr	r3, [r7, #4]
 8006300:	0018      	movs	r0, r3
 8006302:	f004 f8eb 	bl	800a4dc <pbuf_free>
      return err;
 8006306:	1cfb      	adds	r3, r7, #3
 8006308:	781b      	ldrb	r3, [r3, #0]
 800630a:	b25b      	sxtb	r3, r3
 800630c:	e027      	b.n	800635e <mqtt_tcp_recv_cb+0xbe>
    }

    /* Tell remote that data has been received */
    altcp_recved(pcb, p->tot_len);
 800630e:	687b      	ldr	r3, [r7, #4]
 8006310:	891a      	ldrh	r2, [r3, #8]
 8006312:	68bb      	ldr	r3, [r7, #8]
 8006314:	0011      	movs	r1, r2
 8006316:	0018      	movs	r0, r3
 8006318:	f005 faaa 	bl	800b870 <tcp_recved>
    res = mqtt_parse_incoming(client, p);
 800631c:	2512      	movs	r5, #18
 800631e:	197c      	adds	r4, r7, r5
 8006320:	687a      	ldr	r2, [r7, #4]
 8006322:	697b      	ldr	r3, [r7, #20]
 8006324:	0011      	movs	r1, r2
 8006326:	0018      	movs	r0, r3
 8006328:	f7ff fe94 	bl	8006054 <mqtt_parse_incoming>
 800632c:	0003      	movs	r3, r0
 800632e:	8023      	strh	r3, [r4, #0]
    pbuf_free(p);
 8006330:	687b      	ldr	r3, [r7, #4]
 8006332:	0018      	movs	r0, r3
 8006334:	f004 f8d2 	bl	800a4dc <pbuf_free>

    if (res != MQTT_CONNECT_ACCEPTED) {
 8006338:	197b      	adds	r3, r7, r5
 800633a:	881b      	ldrh	r3, [r3, #0]
 800633c:	2b00      	cmp	r3, #0
 800633e:	d006      	beq.n	800634e <mqtt_tcp_recv_cb+0xae>
      mqtt_close(client, res);
 8006340:	197b      	adds	r3, r7, r5
 8006342:	881a      	ldrh	r2, [r3, #0]
 8006344:	697b      	ldr	r3, [r7, #20]
 8006346:	0011      	movs	r1, r2
 8006348:	0018      	movs	r0, r3
 800634a:	f7ff fadb 	bl	8005904 <mqtt_close>
    }
    /* If keep alive functionality is used */
    if (client->keep_alive != 0) {
 800634e:	697b      	ldr	r3, [r7, #20]
 8006350:	885b      	ldrh	r3, [r3, #2]
 8006352:	2b00      	cmp	r3, #0
 8006354:	d002      	beq.n	800635c <mqtt_tcp_recv_cb+0xbc>
      /* Reset server alive watchdog */
      client->server_watchdog = 0;
 8006356:	697b      	ldr	r3, [r7, #20]
 8006358:	2200      	movs	r2, #0
 800635a:	809a      	strh	r2, [r3, #4]
    }

  }
  return ERR_OK;
 800635c:	2300      	movs	r3, #0
}
 800635e:	0018      	movs	r0, r3
 8006360:	46bd      	mov	sp, r7
 8006362:	b006      	add	sp, #24
 8006364:	bdb0      	pop	{r4, r5, r7, pc}
 8006366:	46c0      	nop			; (mov r8, r8)
 8006368:	0801f5e8 	.word	0x0801f5e8
 800636c:	000003a6 	.word	0x000003a6
 8006370:	0801f850 	.word	0x0801f850
 8006374:	0801f654 	.word	0x0801f654
 8006378:	000003a7 	.word	0x000003a7
 800637c:	0801f874 	.word	0x0801f874

08006380 <mqtt_tcp_sent_cb>:
 * @param len Number of bytes sent
 * @return ERR_OK
 */
static err_t
mqtt_tcp_sent_cb(void *arg, struct altcp_pcb *tpcb, u16_t len)
{
 8006380:	b580      	push	{r7, lr}
 8006382:	b086      	sub	sp, #24
 8006384:	af00      	add	r7, sp, #0
 8006386:	60f8      	str	r0, [r7, #12]
 8006388:	60b9      	str	r1, [r7, #8]
 800638a:	1dbb      	adds	r3, r7, #6
 800638c:	801a      	strh	r2, [r3, #0]
  mqtt_client_t *client = (mqtt_client_t *)arg;
 800638e:	68fb      	ldr	r3, [r7, #12]
 8006390:	617b      	str	r3, [r7, #20]

  LWIP_UNUSED_ARG(tpcb);
  LWIP_UNUSED_ARG(len);

  if (client->conn_state == MQTT_CONNECTED) {
 8006392:	697b      	ldr	r3, [r7, #20]
 8006394:	7a9b      	ldrb	r3, [r3, #10]
 8006396:	2b03      	cmp	r3, #3
 8006398:	d129      	bne.n	80063ee <mqtt_tcp_sent_cb+0x6e>
    struct mqtt_request_t *r;

    /* Reset keep-alive send timer and server watchdog */
    client->cyclic_tick = 0;
 800639a:	697b      	ldr	r3, [r7, #20]
 800639c:	2200      	movs	r2, #0
 800639e:	801a      	strh	r2, [r3, #0]
    client->server_watchdog = 0;
 80063a0:	697b      	ldr	r3, [r7, #20]
 80063a2:	2200      	movs	r2, #0
 80063a4:	809a      	strh	r2, [r3, #4]
    /* QoS 0 publish has no response from server, so call its callbacks here */
    while ((r = mqtt_take_request(&client->pend_req_queue, 0)) != NULL) {
 80063a6:	e00e      	b.n	80063c6 <mqtt_tcp_sent_cb+0x46>
      LWIP_DEBUGF(MQTT_DEBUG_TRACE, ("mqtt_tcp_sent_cb: Calling QoS 0 publish complete callback\n"));
      if (r->cb != NULL) {
 80063a8:	693b      	ldr	r3, [r7, #16]
 80063aa:	685b      	ldr	r3, [r3, #4]
 80063ac:	2b00      	cmp	r3, #0
 80063ae:	d006      	beq.n	80063be <mqtt_tcp_sent_cb+0x3e>
        r->cb(r->arg, ERR_OK);
 80063b0:	693b      	ldr	r3, [r7, #16]
 80063b2:	685a      	ldr	r2, [r3, #4]
 80063b4:	693b      	ldr	r3, [r7, #16]
 80063b6:	689b      	ldr	r3, [r3, #8]
 80063b8:	2100      	movs	r1, #0
 80063ba:	0018      	movs	r0, r3
 80063bc:	4790      	blx	r2
      }
      mqtt_delete_request(r);
 80063be:	693b      	ldr	r3, [r7, #16]
 80063c0:	0018      	movs	r0, r3
 80063c2:	f7ff f853 	bl	800546c <mqtt_delete_request>
    while ((r = mqtt_take_request(&client->pend_req_queue, 0)) != NULL) {
 80063c6:	697b      	ldr	r3, [r7, #20]
 80063c8:	3318      	adds	r3, #24
 80063ca:	2100      	movs	r1, #0
 80063cc:	0018      	movs	r0, r3
 80063ce:	f7ff f85b 	bl	8005488 <mqtt_take_request>
 80063d2:	0003      	movs	r3, r0
 80063d4:	613b      	str	r3, [r7, #16]
 80063d6:	693b      	ldr	r3, [r7, #16]
 80063d8:	2b00      	cmp	r3, #0
 80063da:	d1e5      	bne.n	80063a8 <mqtt_tcp_sent_cb+0x28>
    }
    /* Try send any remaining buffers from output queue */
    mqtt_output_send(&client->output, client->conn);
 80063dc:	697b      	ldr	r3, [r7, #20]
 80063de:	33ec      	adds	r3, #236	; 0xec
 80063e0:	001a      	movs	r2, r3
 80063e2:	697b      	ldr	r3, [r7, #20]
 80063e4:	68db      	ldr	r3, [r3, #12]
 80063e6:	0019      	movs	r1, r3
 80063e8:	0010      	movs	r0, r2
 80063ea:	f7fe fea7 	bl	800513c <mqtt_output_send>
  }
  return ERR_OK;
 80063ee:	2300      	movs	r3, #0
}
 80063f0:	0018      	movs	r0, r3
 80063f2:	46bd      	mov	sp, r7
 80063f4:	b006      	add	sp, #24
 80063f6:	bd80      	pop	{r7, pc}

080063f8 <mqtt_tcp_err_cb>:
 * @param arg MQTT client
 * @param err Error encountered
 */
static void
mqtt_tcp_err_cb(void *arg, err_t err)
{
 80063f8:	b580      	push	{r7, lr}
 80063fa:	b084      	sub	sp, #16
 80063fc:	af00      	add	r7, sp, #0
 80063fe:	6078      	str	r0, [r7, #4]
 8006400:	000a      	movs	r2, r1
 8006402:	1cfb      	adds	r3, r7, #3
 8006404:	701a      	strb	r2, [r3, #0]
  mqtt_client_t *client = (mqtt_client_t *)arg;
 8006406:	687b      	ldr	r3, [r7, #4]
 8006408:	60fb      	str	r3, [r7, #12]
  LWIP_UNUSED_ARG(err); /* only used for debug output */
  LWIP_DEBUGF(MQTT_DEBUG_TRACE, ("mqtt_tcp_err_cb: TCP error callback: error %d, arg: %p\n", err, arg));
  LWIP_ASSERT("mqtt_tcp_err_cb: client != NULL", client != NULL);
 800640a:	68fb      	ldr	r3, [r7, #12]
 800640c:	2b00      	cmp	r3, #0
 800640e:	d105      	bne.n	800641c <mqtt_tcp_err_cb+0x24>
 8006410:	4b09      	ldr	r3, [pc, #36]	; (8006438 <mqtt_tcp_err_cb+0x40>)
 8006412:	4a0a      	ldr	r2, [pc, #40]	; (800643c <mqtt_tcp_err_cb+0x44>)
 8006414:	490a      	ldr	r1, [pc, #40]	; (8006440 <mqtt_tcp_err_cb+0x48>)
 8006416:	480b      	ldr	r0, [pc, #44]	; (8006444 <mqtt_tcp_err_cb+0x4c>)
 8006418:	f7fb fee4 	bl	80021e4 <app_debug_rtt_raw>
  /* Set conn to null before calling close as pcb is already deallocated*/
  client->conn = 0;
 800641c:	68fb      	ldr	r3, [r7, #12]
 800641e:	2200      	movs	r2, #0
 8006420:	60da      	str	r2, [r3, #12]
  mqtt_close(client, MQTT_CONNECT_DISCONNECTED);
 8006422:	2380      	movs	r3, #128	; 0x80
 8006424:	005a      	lsls	r2, r3, #1
 8006426:	68fb      	ldr	r3, [r7, #12]
 8006428:	0011      	movs	r1, r2
 800642a:	0018      	movs	r0, r3
 800642c:	f7ff fa6a 	bl	8005904 <mqtt_close>
}
 8006430:	46c0      	nop			; (mov r8, r8)
 8006432:	46bd      	mov	sp, r7
 8006434:	b004      	add	sp, #16
 8006436:	bd80      	pop	{r7, pc}
 8006438:	0801f5e8 	.word	0x0801f5e8
 800643c:	000003f5 	.word	0x000003f5
 8006440:	0801f89c 	.word	0x0801f89c
 8006444:	0801f654 	.word	0x0801f654

08006448 <mqtt_tcp_poll_cb>:
 * @param tpcb TCP connection handle
 * @return err ERR_OK
 */
static err_t
mqtt_tcp_poll_cb(void *arg, struct altcp_pcb *tpcb)
{
 8006448:	b580      	push	{r7, lr}
 800644a:	b084      	sub	sp, #16
 800644c:	af00      	add	r7, sp, #0
 800644e:	6078      	str	r0, [r7, #4]
 8006450:	6039      	str	r1, [r7, #0]
  mqtt_client_t *client = (mqtt_client_t *)arg;
 8006452:	687b      	ldr	r3, [r7, #4]
 8006454:	60fb      	str	r3, [r7, #12]
  if (client->conn_state == MQTT_CONNECTED) {
 8006456:	68fb      	ldr	r3, [r7, #12]
 8006458:	7a9b      	ldrb	r3, [r3, #10]
 800645a:	2b03      	cmp	r3, #3
 800645c:	d106      	bne.n	800646c <mqtt_tcp_poll_cb+0x24>
    /* Try send any remaining buffers from output queue */
    mqtt_output_send(&client->output, tpcb);
 800645e:	68fb      	ldr	r3, [r7, #12]
 8006460:	33ec      	adds	r3, #236	; 0xec
 8006462:	683a      	ldr	r2, [r7, #0]
 8006464:	0011      	movs	r1, r2
 8006466:	0018      	movs	r0, r3
 8006468:	f7fe fe68 	bl	800513c <mqtt_output_send>
  }
  return ERR_OK;
 800646c:	2300      	movs	r3, #0
}
 800646e:	0018      	movs	r0, r3
 8006470:	46bd      	mov	sp, r7
 8006472:	b004      	add	sp, #16
 8006474:	bd80      	pop	{r7, pc}
	...

08006478 <mqtt_tcp_connect_cb>:
 * @param err Always ERR_OK, mqtt_tcp_err_cb is called in case of error
 * @return ERR_OK
 */
static err_t
mqtt_tcp_connect_cb(void *arg, struct altcp_pcb *tpcb, err_t err)
{
 8006478:	b580      	push	{r7, lr}
 800647a:	b086      	sub	sp, #24
 800647c:	af00      	add	r7, sp, #0
 800647e:	60f8      	str	r0, [r7, #12]
 8006480:	60b9      	str	r1, [r7, #8]
 8006482:	1dfb      	adds	r3, r7, #7
 8006484:	701a      	strb	r2, [r3, #0]
  mqtt_client_t *client = (mqtt_client_t *)arg;
 8006486:	68fb      	ldr	r3, [r7, #12]
 8006488:	617b      	str	r3, [r7, #20]

  if (err != ERR_OK) {
 800648a:	1dfb      	adds	r3, r7, #7
 800648c:	781b      	ldrb	r3, [r3, #0]
 800648e:	b25b      	sxtb	r3, r3
 8006490:	2b00      	cmp	r3, #0
 8006492:	d003      	beq.n	800649c <mqtt_tcp_connect_cb+0x24>
    LWIP_DEBUGF(MQTT_DEBUG_WARN, ("mqtt_tcp_connect_cb: TCP connect error %d\n", err));
    return err;
 8006494:	1dfb      	adds	r3, r7, #7
 8006496:	781b      	ldrb	r3, [r3, #0]
 8006498:	b25b      	sxtb	r3, r3
 800649a:	e02a      	b.n	80064f2 <mqtt_tcp_connect_cb+0x7a>
  }

  /* Initiate receiver state */
  client->msg_idx = 0;
 800649c:	697b      	ldr	r3, [r7, #20]
 800649e:	2200      	movs	r2, #0
 80064a0:	669a      	str	r2, [r3, #104]	; 0x68

  /* Setup TCP callbacks */
  altcp_recv(tpcb, mqtt_tcp_recv_cb);
 80064a2:	4a16      	ldr	r2, [pc, #88]	; (80064fc <mqtt_tcp_connect_cb+0x84>)
 80064a4:	68bb      	ldr	r3, [r7, #8]
 80064a6:	0011      	movs	r1, r2
 80064a8:	0018      	movs	r0, r3
 80064aa:	f006 faad 	bl	800ca08 <tcp_recv>
  altcp_sent(tpcb, mqtt_tcp_sent_cb);
 80064ae:	4a14      	ldr	r2, [pc, #80]	; (8006500 <mqtt_tcp_connect_cb+0x88>)
 80064b0:	68bb      	ldr	r3, [r7, #8]
 80064b2:	0011      	movs	r1, r2
 80064b4:	0018      	movs	r0, r3
 80064b6:	f006 fac9 	bl	800ca4c <tcp_sent>
  altcp_poll(tpcb, mqtt_tcp_poll_cb, 2);
 80064ba:	4912      	ldr	r1, [pc, #72]	; (8006504 <mqtt_tcp_connect_cb+0x8c>)
 80064bc:	68bb      	ldr	r3, [r7, #8]
 80064be:	2202      	movs	r2, #2
 80064c0:	0018      	movs	r0, r3
 80064c2:	f006 fb07 	bl	800cad4 <tcp_poll>

  LWIP_DEBUGF(MQTT_DEBUG_TRACE, ("mqtt_tcp_connect_cb: TCP connection established to server\n"));
  /* Enter MQTT connect state */
  client->conn_state = MQTT_CONNECTING;
 80064c6:	697b      	ldr	r3, [r7, #20]
 80064c8:	2202      	movs	r2, #2
 80064ca:	729a      	strb	r2, [r3, #10]

  /* Start cyclic timer */
  sys_timeout(MQTT_CYCLIC_TIMER_INTERVAL * 1000, mqtt_cyclic_timer, client);
 80064cc:	697a      	ldr	r2, [r7, #20]
 80064ce:	4b0e      	ldr	r3, [pc, #56]	; (8006508 <mqtt_tcp_connect_cb+0x90>)
 80064d0:	480e      	ldr	r0, [pc, #56]	; (800650c <mqtt_tcp_connect_cb+0x94>)
 80064d2:	0019      	movs	r1, r3
 80064d4:	f00c fac6 	bl	8012a64 <sys_timeout>
  client->cyclic_tick = 0;
 80064d8:	697b      	ldr	r3, [r7, #20]
 80064da:	2200      	movs	r2, #0
 80064dc:	801a      	strh	r2, [r3, #0]

  /* Start transmission from output queue, connect message is the first one out*/
  mqtt_output_send(&client->output, client->conn);
 80064de:	697b      	ldr	r3, [r7, #20]
 80064e0:	33ec      	adds	r3, #236	; 0xec
 80064e2:	001a      	movs	r2, r3
 80064e4:	697b      	ldr	r3, [r7, #20]
 80064e6:	68db      	ldr	r3, [r3, #12]
 80064e8:	0019      	movs	r1, r3
 80064ea:	0010      	movs	r0, r2
 80064ec:	f7fe fe26 	bl	800513c <mqtt_output_send>

  return ERR_OK;
 80064f0:	2300      	movs	r3, #0
}
 80064f2:	0018      	movs	r0, r3
 80064f4:	46bd      	mov	sp, r7
 80064f6:	b006      	add	sp, #24
 80064f8:	bd80      	pop	{r7, pc}
 80064fa:	46c0      	nop			; (mov r8, r8)
 80064fc:	080062a1 	.word	0x080062a1
 8006500:	08006381 	.word	0x08006381
 8006504:	08006449 	.word	0x08006449
 8006508:	080059d9 	.word	0x080059d9
 800650c:	00001388 	.word	0x00001388

08006510 <mqtt_publish>:
 *         ERR_MEM if short on memory
 */
err_t
mqtt_publish(mqtt_client_t *client, const char *topic, const void *payload, u16_t payload_length, u8_t qos, u8_t retain,
             mqtt_request_cb_t cb, void *arg)
{
 8006510:	b590      	push	{r4, r7, lr}
 8006512:	b08d      	sub	sp, #52	; 0x34
 8006514:	af02      	add	r7, sp, #8
 8006516:	60f8      	str	r0, [r7, #12]
 8006518:	60b9      	str	r1, [r7, #8]
 800651a:	607a      	str	r2, [r7, #4]
 800651c:	001a      	movs	r2, r3
 800651e:	1cbb      	adds	r3, r7, #2
 8006520:	801a      	strh	r2, [r3, #0]
  size_t total_len;
  u16_t topic_len;
  u16_t remaining_length;

  LWIP_ASSERT_CORE_LOCKED();
  LWIP_ASSERT("mqtt_publish: client != NULL", client);
 8006522:	68fb      	ldr	r3, [r7, #12]
 8006524:	2b00      	cmp	r3, #0
 8006526:	d105      	bne.n	8006534 <mqtt_publish+0x24>
 8006528:	4b69      	ldr	r3, [pc, #420]	; (80066d0 <mqtt_publish+0x1c0>)
 800652a:	4a6a      	ldr	r2, [pc, #424]	; (80066d4 <mqtt_publish+0x1c4>)
 800652c:	496a      	ldr	r1, [pc, #424]	; (80066d8 <mqtt_publish+0x1c8>)
 800652e:	486b      	ldr	r0, [pc, #428]	; (80066dc <mqtt_publish+0x1cc>)
 8006530:	f7fb fe58 	bl	80021e4 <app_debug_rtt_raw>
  LWIP_ASSERT("mqtt_publish: topic != NULL", topic);
 8006534:	68bb      	ldr	r3, [r7, #8]
 8006536:	2b00      	cmp	r3, #0
 8006538:	d105      	bne.n	8006546 <mqtt_publish+0x36>
 800653a:	4b65      	ldr	r3, [pc, #404]	; (80066d0 <mqtt_publish+0x1c0>)
 800653c:	4a68      	ldr	r2, [pc, #416]	; (80066e0 <mqtt_publish+0x1d0>)
 800653e:	4969      	ldr	r1, [pc, #420]	; (80066e4 <mqtt_publish+0x1d4>)
 8006540:	4866      	ldr	r0, [pc, #408]	; (80066dc <mqtt_publish+0x1cc>)
 8006542:	f7fb fe4f 	bl	80021e4 <app_debug_rtt_raw>
  LWIP_ERROR("mqtt_publish: TCP disconnected", (client->conn_state != TCP_DISCONNECTED), return ERR_CONN);
 8006546:	68fb      	ldr	r3, [r7, #12]
 8006548:	7a9b      	ldrb	r3, [r3, #10]
 800654a:	2b00      	cmp	r3, #0
 800654c:	d106      	bne.n	800655c <mqtt_publish+0x4c>
 800654e:	4b66      	ldr	r3, [pc, #408]	; (80066e8 <mqtt_publish+0x1d8>)
 8006550:	0018      	movs	r0, r3
 8006552:	f7fb fe47 	bl	80021e4 <app_debug_rtt_raw>
 8006556:	230b      	movs	r3, #11
 8006558:	425b      	negs	r3, r3
 800655a:	e0b4      	b.n	80066c6 <mqtt_publish+0x1b6>

  topic_strlen = strlen(topic);
 800655c:	68bb      	ldr	r3, [r7, #8]
 800655e:	0018      	movs	r0, r3
 8006560:	f7f9 fddc 	bl	800011c <strlen>
 8006564:	0003      	movs	r3, r0
 8006566:	61fb      	str	r3, [r7, #28]
  LWIP_ERROR("mqtt_publish: topic length overflow", (topic_strlen <= (0xFFFF - 2)), return ERR_ARG);
 8006568:	69fb      	ldr	r3, [r7, #28]
 800656a:	4a60      	ldr	r2, [pc, #384]	; (80066ec <mqtt_publish+0x1dc>)
 800656c:	4293      	cmp	r3, r2
 800656e:	d906      	bls.n	800657e <mqtt_publish+0x6e>
 8006570:	4b5f      	ldr	r3, [pc, #380]	; (80066f0 <mqtt_publish+0x1e0>)
 8006572:	0018      	movs	r0, r3
 8006574:	f7fb fe36 	bl	80021e4 <app_debug_rtt_raw>
 8006578:	2310      	movs	r3, #16
 800657a:	425b      	negs	r3, r3
 800657c:	e0a3      	b.n	80066c6 <mqtt_publish+0x1b6>
  topic_len = (u16_t)topic_strlen;
 800657e:	211a      	movs	r1, #26
 8006580:	187b      	adds	r3, r7, r1
 8006582:	69fa      	ldr	r2, [r7, #28]
 8006584:	801a      	strh	r2, [r3, #0]
  total_len = 2 + topic_len + payload_length;
 8006586:	187b      	adds	r3, r7, r1
 8006588:	881b      	ldrh	r3, [r3, #0]
 800658a:	1c9a      	adds	r2, r3, #2
 800658c:	1cbb      	adds	r3, r7, #2
 800658e:	881b      	ldrh	r3, [r3, #0]
 8006590:	18d3      	adds	r3, r2, r3
 8006592:	623b      	str	r3, [r7, #32]

  if (qos > 0) {
 8006594:	2338      	movs	r3, #56	; 0x38
 8006596:	18fb      	adds	r3, r7, r3
 8006598:	781b      	ldrb	r3, [r3, #0]
 800659a:	2b00      	cmp	r3, #0
 800659c:	d00b      	beq.n	80065b6 <mqtt_publish+0xa6>
    total_len += 2;
 800659e:	6a3b      	ldr	r3, [r7, #32]
 80065a0:	3302      	adds	r3, #2
 80065a2:	623b      	str	r3, [r7, #32]
    /* Generate pkt_id id for QoS1 and 2 */
    pkt_id = msg_generate_packet_id(client);
 80065a4:	2326      	movs	r3, #38	; 0x26
 80065a6:	18fc      	adds	r4, r7, r3
 80065a8:	68fb      	ldr	r3, [r7, #12]
 80065aa:	0018      	movs	r0, r3
 80065ac:	f7fe fd36 	bl	800501c <msg_generate_packet_id>
 80065b0:	0003      	movs	r3, r0
 80065b2:	8023      	strh	r3, [r4, #0]
 80065b4:	e003      	b.n	80065be <mqtt_publish+0xae>
  } else {
    /* Use reserved value pkt_id 0 for QoS 0 in request handle */
    pkt_id = 0;
 80065b6:	2326      	movs	r3, #38	; 0x26
 80065b8:	18fb      	adds	r3, r7, r3
 80065ba:	2200      	movs	r2, #0
 80065bc:	801a      	strh	r2, [r3, #0]
  }
  LWIP_ERROR("mqtt_publish: total length overflow", (total_len <= 0xFFFF), return ERR_ARG);
 80065be:	6a3a      	ldr	r2, [r7, #32]
 80065c0:	2380      	movs	r3, #128	; 0x80
 80065c2:	025b      	lsls	r3, r3, #9
 80065c4:	429a      	cmp	r2, r3
 80065c6:	d306      	bcc.n	80065d6 <mqtt_publish+0xc6>
 80065c8:	4b4a      	ldr	r3, [pc, #296]	; (80066f4 <mqtt_publish+0x1e4>)
 80065ca:	0018      	movs	r0, r3
 80065cc:	f7fb fe0a 	bl	80021e4 <app_debug_rtt_raw>
 80065d0:	2310      	movs	r3, #16
 80065d2:	425b      	negs	r3, r3
 80065d4:	e077      	b.n	80066c6 <mqtt_publish+0x1b6>
  remaining_length = (u16_t)total_len;
 80065d6:	2318      	movs	r3, #24
 80065d8:	18fb      	adds	r3, r7, r3
 80065da:	6a3a      	ldr	r2, [r7, #32]
 80065dc:	801a      	strh	r2, [r3, #0]

  LWIP_DEBUGF(MQTT_DEBUG_TRACE, ("mqtt_publish: Publish with payload length %d to topic \"%s\"\n", payload_length, topic));

  r = mqtt_create_request(client->req_list, LWIP_ARRAYSIZE(client->req_list), pkt_id, cb, arg);
 80065de:	68fb      	ldr	r3, [r7, #12]
 80065e0:	331c      	adds	r3, #28
 80065e2:	0018      	movs	r0, r3
 80065e4:	6c39      	ldr	r1, [r7, #64]	; 0x40
 80065e6:	2326      	movs	r3, #38	; 0x26
 80065e8:	18fb      	adds	r3, r7, r3
 80065ea:	881a      	ldrh	r2, [r3, #0]
 80065ec:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80065ee:	9300      	str	r3, [sp, #0]
 80065f0:	000b      	movs	r3, r1
 80065f2:	2104      	movs	r1, #4
 80065f4:	f7fe fe92 	bl	800531c <mqtt_create_request>
 80065f8:	0003      	movs	r3, r0
 80065fa:	617b      	str	r3, [r7, #20]
  if (r == NULL) {
 80065fc:	697b      	ldr	r3, [r7, #20]
 80065fe:	2b00      	cmp	r3, #0
 8006600:	d102      	bne.n	8006608 <mqtt_publish+0xf8>
    return ERR_MEM;
 8006602:	2301      	movs	r3, #1
 8006604:	425b      	negs	r3, r3
 8006606:	e05e      	b.n	80066c6 <mqtt_publish+0x1b6>
  }

  if (mqtt_output_check_space(&client->output, remaining_length) == 0) {
 8006608:	68fb      	ldr	r3, [r7, #12]
 800660a:	33ec      	adds	r3, #236	; 0xec
 800660c:	001a      	movs	r2, r3
 800660e:	2318      	movs	r3, #24
 8006610:	18fb      	adds	r3, r7, r3
 8006612:	881b      	ldrh	r3, [r3, #0]
 8006614:	0019      	movs	r1, r3
 8006616:	0010      	movs	r0, r2
 8006618:	f7ff f932 	bl	8005880 <mqtt_output_check_space>
 800661c:	1e03      	subs	r3, r0, #0
 800661e:	d106      	bne.n	800662e <mqtt_publish+0x11e>
    mqtt_delete_request(r);
 8006620:	697b      	ldr	r3, [r7, #20]
 8006622:	0018      	movs	r0, r3
 8006624:	f7fe ff22 	bl	800546c <mqtt_delete_request>
    return ERR_MEM;
 8006628:	2301      	movs	r3, #1
 800662a:	425b      	negs	r3, r3
 800662c:	e04b      	b.n	80066c6 <mqtt_publish+0x1b6>
  }
  /* Append fixed header */
  mqtt_output_append_fixed_header(&client->output, MQTT_MSG_TYPE_PUBLISH, 0, qos, retain, remaining_length);
 800662e:	68fb      	ldr	r3, [r7, #12]
 8006630:	33ec      	adds	r3, #236	; 0xec
 8006632:	0018      	movs	r0, r3
 8006634:	2438      	movs	r4, #56	; 0x38
 8006636:	193b      	adds	r3, r7, r4
 8006638:	781a      	ldrb	r2, [r3, #0]
 800663a:	2318      	movs	r3, #24
 800663c:	18fb      	adds	r3, r7, r3
 800663e:	881b      	ldrh	r3, [r3, #0]
 8006640:	9301      	str	r3, [sp, #4]
 8006642:	233c      	movs	r3, #60	; 0x3c
 8006644:	18fb      	adds	r3, r7, r3
 8006646:	781b      	ldrb	r3, [r3, #0]
 8006648:	9300      	str	r3, [sp, #0]
 800664a:	0013      	movs	r3, r2
 800664c:	2200      	movs	r2, #0
 800664e:	2103      	movs	r1, #3
 8006650:	f7ff f8bb 	bl	80057ca <mqtt_output_append_fixed_header>

  /* Append Topic */
  mqtt_output_append_string(&client->output, topic, topic_len);
 8006654:	68fb      	ldr	r3, [r7, #12]
 8006656:	33ec      	adds	r3, #236	; 0xec
 8006658:	0018      	movs	r0, r3
 800665a:	231a      	movs	r3, #26
 800665c:	18fb      	adds	r3, r7, r3
 800665e:	881a      	ldrh	r2, [r3, #0]
 8006660:	68bb      	ldr	r3, [r7, #8]
 8006662:	0019      	movs	r1, r3
 8006664:	f7ff f877 	bl	8005756 <mqtt_output_append_string>

  /* Append packet if for QoS 1 and 2*/
  if (qos > 0) {
 8006668:	193b      	adds	r3, r7, r4
 800666a:	781b      	ldrb	r3, [r3, #0]
 800666c:	2b00      	cmp	r3, #0
 800666e:	d009      	beq.n	8006684 <mqtt_publish+0x174>
    mqtt_output_append_u16(&client->output, pkt_id);
 8006670:	68fb      	ldr	r3, [r7, #12]
 8006672:	33ec      	adds	r3, #236	; 0xec
 8006674:	001a      	movs	r2, r3
 8006676:	2326      	movs	r3, #38	; 0x26
 8006678:	18fb      	adds	r3, r7, r3
 800667a:	881b      	ldrh	r3, [r3, #0]
 800667c:	0019      	movs	r1, r3
 800667e:	0010      	movs	r0, r2
 8006680:	f7ff f824 	bl	80056cc <mqtt_output_append_u16>
  }

  /* Append optional publish payload */
  if ((payload != NULL) && (payload_length > 0)) {
 8006684:	687b      	ldr	r3, [r7, #4]
 8006686:	2b00      	cmp	r3, #0
 8006688:	d00c      	beq.n	80066a4 <mqtt_publish+0x194>
 800668a:	1cbb      	adds	r3, r7, #2
 800668c:	881b      	ldrh	r3, [r3, #0]
 800668e:	2b00      	cmp	r3, #0
 8006690:	d008      	beq.n	80066a4 <mqtt_publish+0x194>
    mqtt_output_append_buf(&client->output, payload, payload_length);
 8006692:	68fb      	ldr	r3, [r7, #12]
 8006694:	33ec      	adds	r3, #236	; 0xec
 8006696:	0018      	movs	r0, r3
 8006698:	1cbb      	adds	r3, r7, #2
 800669a:	881a      	ldrh	r2, [r3, #0]
 800669c:	687b      	ldr	r3, [r7, #4]
 800669e:	0019      	movs	r1, r3
 80066a0:	f7ff f831 	bl	8005706 <mqtt_output_append_buf>
  }

  mqtt_append_request(&client->pend_req_queue, r);
 80066a4:	68fb      	ldr	r3, [r7, #12]
 80066a6:	3318      	adds	r3, #24
 80066a8:	697a      	ldr	r2, [r7, #20]
 80066aa:	0011      	movs	r1, r2
 80066ac:	0018      	movs	r0, r3
 80066ae:	f7fe fe87 	bl	80053c0 <mqtt_append_request>
  mqtt_output_send(&client->output, client->conn);
 80066b2:	68fb      	ldr	r3, [r7, #12]
 80066b4:	33ec      	adds	r3, #236	; 0xec
 80066b6:	001a      	movs	r2, r3
 80066b8:	68fb      	ldr	r3, [r7, #12]
 80066ba:	68db      	ldr	r3, [r3, #12]
 80066bc:	0019      	movs	r1, r3
 80066be:	0010      	movs	r0, r2
 80066c0:	f7fe fd3c 	bl	800513c <mqtt_output_send>
  return ERR_OK;
 80066c4:	2300      	movs	r3, #0
}
 80066c6:	0018      	movs	r0, r3
 80066c8:	46bd      	mov	sp, r7
 80066ca:	b00b      	add	sp, #44	; 0x2c
 80066cc:	bd90      	pop	{r4, r7, pc}
 80066ce:	46c0      	nop			; (mov r8, r8)
 80066d0:	0801f5e8 	.word	0x0801f5e8
 80066d4:	00000453 	.word	0x00000453
 80066d8:	0801f8bc 	.word	0x0801f8bc
 80066dc:	0801f654 	.word	0x0801f654
 80066e0:	00000454 	.word	0x00000454
 80066e4:	0801f8dc 	.word	0x0801f8dc
 80066e8:	0801f8f8 	.word	0x0801f8f8
 80066ec:	0000fffd 	.word	0x0000fffd
 80066f0:	0801f918 	.word	0x0801f918
 80066f4:	0801f93c 	.word	0x0801f93c

080066f8 <mqtt_sub_unsub>:
 * @param sub 1 for subscribe, 0 for unsubscribe
 * @return ERR_OK if successful, @see err_t enum for other results
 */
err_t
mqtt_sub_unsub(mqtt_client_t *client, const char *topic, u8_t qos, mqtt_request_cb_t cb, void *arg, u8_t sub)
{
 80066f8:	b5b0      	push	{r4, r5, r7, lr}
 80066fa:	b08c      	sub	sp, #48	; 0x30
 80066fc:	af02      	add	r7, sp, #8
 80066fe:	60f8      	str	r0, [r7, #12]
 8006700:	60b9      	str	r1, [r7, #8]
 8006702:	603b      	str	r3, [r7, #0]
 8006704:	1dfb      	adds	r3, r7, #7
 8006706:	701a      	strb	r2, [r3, #0]
  u16_t remaining_length;
  u16_t pkt_id;
  struct mqtt_request_t *r;

  LWIP_ASSERT_CORE_LOCKED();
  LWIP_ASSERT("mqtt_sub_unsub: client != NULL", client);
 8006708:	68fb      	ldr	r3, [r7, #12]
 800670a:	2b00      	cmp	r3, #0
 800670c:	d105      	bne.n	800671a <mqtt_sub_unsub+0x22>
 800670e:	4b67      	ldr	r3, [pc, #412]	; (80068ac <mqtt_sub_unsub+0x1b4>)
 8006710:	4a67      	ldr	r2, [pc, #412]	; (80068b0 <mqtt_sub_unsub+0x1b8>)
 8006712:	4968      	ldr	r1, [pc, #416]	; (80068b4 <mqtt_sub_unsub+0x1bc>)
 8006714:	4868      	ldr	r0, [pc, #416]	; (80068b8 <mqtt_sub_unsub+0x1c0>)
 8006716:	f7fb fd65 	bl	80021e4 <app_debug_rtt_raw>
  LWIP_ASSERT("mqtt_sub_unsub: topic != NULL", topic);
 800671a:	68bb      	ldr	r3, [r7, #8]
 800671c:	2b00      	cmp	r3, #0
 800671e:	d105      	bne.n	800672c <mqtt_sub_unsub+0x34>
 8006720:	4b62      	ldr	r3, [pc, #392]	; (80068ac <mqtt_sub_unsub+0x1b4>)
 8006722:	4a66      	ldr	r2, [pc, #408]	; (80068bc <mqtt_sub_unsub+0x1c4>)
 8006724:	4966      	ldr	r1, [pc, #408]	; (80068c0 <mqtt_sub_unsub+0x1c8>)
 8006726:	4864      	ldr	r0, [pc, #400]	; (80068b8 <mqtt_sub_unsub+0x1c0>)
 8006728:	f7fb fd5c 	bl	80021e4 <app_debug_rtt_raw>

  topic_strlen = strlen(topic);
 800672c:	68bb      	ldr	r3, [r7, #8]
 800672e:	0018      	movs	r0, r3
 8006730:	f7f9 fcf4 	bl	800011c <strlen>
 8006734:	0003      	movs	r3, r0
 8006736:	627b      	str	r3, [r7, #36]	; 0x24
  LWIP_ERROR("mqtt_sub_unsub: topic length overflow", (topic_strlen <= (0xFFFF - 2)), return ERR_ARG);
 8006738:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800673a:	4a62      	ldr	r2, [pc, #392]	; (80068c4 <mqtt_sub_unsub+0x1cc>)
 800673c:	4293      	cmp	r3, r2
 800673e:	d906      	bls.n	800674e <mqtt_sub_unsub+0x56>
 8006740:	4b61      	ldr	r3, [pc, #388]	; (80068c8 <mqtt_sub_unsub+0x1d0>)
 8006742:	0018      	movs	r0, r3
 8006744:	f7fb fd4e 	bl	80021e4 <app_debug_rtt_raw>
 8006748:	2310      	movs	r3, #16
 800674a:	425b      	negs	r3, r3
 800674c:	e0aa      	b.n	80068a4 <mqtt_sub_unsub+0x1ac>
  topic_len = (u16_t)topic_strlen;
 800674e:	2122      	movs	r1, #34	; 0x22
 8006750:	187b      	adds	r3, r7, r1
 8006752:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8006754:	801a      	strh	r2, [r3, #0]
  /* Topic string, pkt_id, qos for subscribe */
  total_len =  topic_len + 2 + 2 + (sub != 0);
 8006756:	187b      	adds	r3, r7, r1
 8006758:	881b      	ldrh	r3, [r3, #0]
 800675a:	3304      	adds	r3, #4
 800675c:	223c      	movs	r2, #60	; 0x3c
 800675e:	18ba      	adds	r2, r7, r2
 8006760:	7812      	ldrb	r2, [r2, #0]
 8006762:	1e51      	subs	r1, r2, #1
 8006764:	418a      	sbcs	r2, r1
 8006766:	b2d2      	uxtb	r2, r2
 8006768:	189b      	adds	r3, r3, r2
 800676a:	61fb      	str	r3, [r7, #28]
  LWIP_ERROR("mqtt_sub_unsub: total length overflow", (total_len <= 0xFFFF), return ERR_ARG);
 800676c:	69fa      	ldr	r2, [r7, #28]
 800676e:	2380      	movs	r3, #128	; 0x80
 8006770:	025b      	lsls	r3, r3, #9
 8006772:	429a      	cmp	r2, r3
 8006774:	d306      	bcc.n	8006784 <mqtt_sub_unsub+0x8c>
 8006776:	4b55      	ldr	r3, [pc, #340]	; (80068cc <mqtt_sub_unsub+0x1d4>)
 8006778:	0018      	movs	r0, r3
 800677a:	f7fb fd33 	bl	80021e4 <app_debug_rtt_raw>
 800677e:	2310      	movs	r3, #16
 8006780:	425b      	negs	r3, r3
 8006782:	e08f      	b.n	80068a4 <mqtt_sub_unsub+0x1ac>
  remaining_length = (u16_t)total_len;
 8006784:	231a      	movs	r3, #26
 8006786:	18fb      	adds	r3, r7, r3
 8006788:	69fa      	ldr	r2, [r7, #28]
 800678a:	801a      	strh	r2, [r3, #0]

  LWIP_ASSERT("mqtt_sub_unsub: qos < 3", qos < 3);
 800678c:	1dfb      	adds	r3, r7, #7
 800678e:	781b      	ldrb	r3, [r3, #0]
 8006790:	2b02      	cmp	r3, #2
 8006792:	d905      	bls.n	80067a0 <mqtt_sub_unsub+0xa8>
 8006794:	4b45      	ldr	r3, [pc, #276]	; (80068ac <mqtt_sub_unsub+0x1b4>)
 8006796:	4a4e      	ldr	r2, [pc, #312]	; (80068d0 <mqtt_sub_unsub+0x1d8>)
 8006798:	494e      	ldr	r1, [pc, #312]	; (80068d4 <mqtt_sub_unsub+0x1dc>)
 800679a:	4847      	ldr	r0, [pc, #284]	; (80068b8 <mqtt_sub_unsub+0x1c0>)
 800679c:	f7fb fd22 	bl	80021e4 <app_debug_rtt_raw>
  if (client->conn_state == TCP_DISCONNECTED) {
 80067a0:	68fb      	ldr	r3, [r7, #12]
 80067a2:	7a9b      	ldrb	r3, [r3, #10]
 80067a4:	2b00      	cmp	r3, #0
 80067a6:	d102      	bne.n	80067ae <mqtt_sub_unsub+0xb6>
    LWIP_DEBUGF(MQTT_DEBUG_WARN, ("mqtt_sub_unsub: Can not (un)subscribe in disconnected state\n"));
    return ERR_CONN;
 80067a8:	230b      	movs	r3, #11
 80067aa:	425b      	negs	r3, r3
 80067ac:	e07a      	b.n	80068a4 <mqtt_sub_unsub+0x1ac>
  }

  pkt_id = msg_generate_packet_id(client);
 80067ae:	2518      	movs	r5, #24
 80067b0:	197c      	adds	r4, r7, r5
 80067b2:	68fb      	ldr	r3, [r7, #12]
 80067b4:	0018      	movs	r0, r3
 80067b6:	f7fe fc31 	bl	800501c <msg_generate_packet_id>
 80067ba:	0003      	movs	r3, r0
 80067bc:	8023      	strh	r3, [r4, #0]
  r = mqtt_create_request(client->req_list, LWIP_ARRAYSIZE(client->req_list), pkt_id, cb, arg);
 80067be:	68fb      	ldr	r3, [r7, #12]
 80067c0:	331c      	adds	r3, #28
 80067c2:	0018      	movs	r0, r3
 80067c4:	6839      	ldr	r1, [r7, #0]
 80067c6:	197b      	adds	r3, r7, r5
 80067c8:	881a      	ldrh	r2, [r3, #0]
 80067ca:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80067cc:	9300      	str	r3, [sp, #0]
 80067ce:	000b      	movs	r3, r1
 80067d0:	2104      	movs	r1, #4
 80067d2:	f7fe fda3 	bl	800531c <mqtt_create_request>
 80067d6:	0003      	movs	r3, r0
 80067d8:	617b      	str	r3, [r7, #20]
  if (r == NULL) {
 80067da:	697b      	ldr	r3, [r7, #20]
 80067dc:	2b00      	cmp	r3, #0
 80067de:	d102      	bne.n	80067e6 <mqtt_sub_unsub+0xee>
    return ERR_MEM;
 80067e0:	2301      	movs	r3, #1
 80067e2:	425b      	negs	r3, r3
 80067e4:	e05e      	b.n	80068a4 <mqtt_sub_unsub+0x1ac>
  }

  if (mqtt_output_check_space(&client->output, remaining_length) == 0) {
 80067e6:	68fb      	ldr	r3, [r7, #12]
 80067e8:	33ec      	adds	r3, #236	; 0xec
 80067ea:	001a      	movs	r2, r3
 80067ec:	231a      	movs	r3, #26
 80067ee:	18fb      	adds	r3, r7, r3
 80067f0:	881b      	ldrh	r3, [r3, #0]
 80067f2:	0019      	movs	r1, r3
 80067f4:	0010      	movs	r0, r2
 80067f6:	f7ff f843 	bl	8005880 <mqtt_output_check_space>
 80067fa:	1e03      	subs	r3, r0, #0
 80067fc:	d106      	bne.n	800680c <mqtt_sub_unsub+0x114>
    mqtt_delete_request(r);
 80067fe:	697b      	ldr	r3, [r7, #20]
 8006800:	0018      	movs	r0, r3
 8006802:	f7fe fe33 	bl	800546c <mqtt_delete_request>
    return ERR_MEM;
 8006806:	2301      	movs	r3, #1
 8006808:	425b      	negs	r3, r3
 800680a:	e04b      	b.n	80068a4 <mqtt_sub_unsub+0x1ac>
  }

  LWIP_DEBUGF(MQTT_DEBUG_TRACE, ("mqtt_sub_unsub: Client (un)subscribe to topic \"%s\", id: %d\n", topic, pkt_id));

  mqtt_output_append_fixed_header(&client->output, sub ? MQTT_MSG_TYPE_SUBSCRIBE : MQTT_MSG_TYPE_UNSUBSCRIBE, 0, 1, 0, remaining_length);
 800680c:	68fb      	ldr	r3, [r7, #12]
 800680e:	33ec      	adds	r3, #236	; 0xec
 8006810:	0018      	movs	r0, r3
 8006812:	233c      	movs	r3, #60	; 0x3c
 8006814:	18fb      	adds	r3, r7, r3
 8006816:	781b      	ldrb	r3, [r3, #0]
 8006818:	2b00      	cmp	r3, #0
 800681a:	d001      	beq.n	8006820 <mqtt_sub_unsub+0x128>
 800681c:	2108      	movs	r1, #8
 800681e:	e000      	b.n	8006822 <mqtt_sub_unsub+0x12a>
 8006820:	210a      	movs	r1, #10
 8006822:	231a      	movs	r3, #26
 8006824:	18fb      	adds	r3, r7, r3
 8006826:	881b      	ldrh	r3, [r3, #0]
 8006828:	9301      	str	r3, [sp, #4]
 800682a:	2300      	movs	r3, #0
 800682c:	9300      	str	r3, [sp, #0]
 800682e:	2301      	movs	r3, #1
 8006830:	2200      	movs	r2, #0
 8006832:	f7fe ffca 	bl	80057ca <mqtt_output_append_fixed_header>
  /* Packet id */
  mqtt_output_append_u16(&client->output, pkt_id);
 8006836:	68fb      	ldr	r3, [r7, #12]
 8006838:	33ec      	adds	r3, #236	; 0xec
 800683a:	001a      	movs	r2, r3
 800683c:	2318      	movs	r3, #24
 800683e:	18fb      	adds	r3, r7, r3
 8006840:	881b      	ldrh	r3, [r3, #0]
 8006842:	0019      	movs	r1, r3
 8006844:	0010      	movs	r0, r2
 8006846:	f7fe ff41 	bl	80056cc <mqtt_output_append_u16>
  /* Topic */
  mqtt_output_append_string(&client->output, topic, topic_len);
 800684a:	68fb      	ldr	r3, [r7, #12]
 800684c:	33ec      	adds	r3, #236	; 0xec
 800684e:	0018      	movs	r0, r3
 8006850:	2322      	movs	r3, #34	; 0x22
 8006852:	18fb      	adds	r3, r7, r3
 8006854:	881a      	ldrh	r2, [r3, #0]
 8006856:	68bb      	ldr	r3, [r7, #8]
 8006858:	0019      	movs	r1, r3
 800685a:	f7fe ff7c 	bl	8005756 <mqtt_output_append_string>
  /* QoS */
  if (sub != 0) {
 800685e:	233c      	movs	r3, #60	; 0x3c
 8006860:	18fb      	adds	r3, r7, r3
 8006862:	781b      	ldrb	r3, [r3, #0]
 8006864:	2b00      	cmp	r3, #0
 8006866:	d00c      	beq.n	8006882 <mqtt_sub_unsub+0x18a>
    mqtt_output_append_u8(&client->output, LWIP_MIN(qos, 2));
 8006868:	68fb      	ldr	r3, [r7, #12]
 800686a:	33ec      	adds	r3, #236	; 0xec
 800686c:	0018      	movs	r0, r3
 800686e:	1dfb      	adds	r3, r7, #7
 8006870:	781b      	ldrb	r3, [r3, #0]
 8006872:	b2da      	uxtb	r2, r3
 8006874:	2a02      	cmp	r2, #2
 8006876:	d900      	bls.n	800687a <mqtt_sub_unsub+0x182>
 8006878:	2302      	movs	r3, #2
 800687a:	b2db      	uxtb	r3, r3
 800687c:	0019      	movs	r1, r3
 800687e:	f7fe ff13 	bl	80056a8 <mqtt_output_append_u8>
  }

  mqtt_append_request(&client->pend_req_queue, r);
 8006882:	68fb      	ldr	r3, [r7, #12]
 8006884:	3318      	adds	r3, #24
 8006886:	697a      	ldr	r2, [r7, #20]
 8006888:	0011      	movs	r1, r2
 800688a:	0018      	movs	r0, r3
 800688c:	f7fe fd98 	bl	80053c0 <mqtt_append_request>
  mqtt_output_send(&client->output, client->conn);
 8006890:	68fb      	ldr	r3, [r7, #12]
 8006892:	33ec      	adds	r3, #236	; 0xec
 8006894:	001a      	movs	r2, r3
 8006896:	68fb      	ldr	r3, [r7, #12]
 8006898:	68db      	ldr	r3, [r3, #12]
 800689a:	0019      	movs	r1, r3
 800689c:	0010      	movs	r0, r2
 800689e:	f7fe fc4d 	bl	800513c <mqtt_output_send>
  return ERR_OK;
 80068a2:	2300      	movs	r3, #0
}
 80068a4:	0018      	movs	r0, r3
 80068a6:	46bd      	mov	sp, r7
 80068a8:	b00a      	add	sp, #40	; 0x28
 80068aa:	bdb0      	pop	{r4, r5, r7, pc}
 80068ac:	0801f5e8 	.word	0x0801f5e8
 80068b0:	0000049e 	.word	0x0000049e
 80068b4:	0801f960 	.word	0x0801f960
 80068b8:	0801f654 	.word	0x0801f654
 80068bc:	0000049f 	.word	0x0000049f
 80068c0:	0801f980 	.word	0x0801f980
 80068c4:	0000fffd 	.word	0x0000fffd
 80068c8:	0801f9a0 	.word	0x0801f9a0
 80068cc:	0801f9c8 	.word	0x0801f9c8
 80068d0:	000004a9 	.word	0x000004a9
 80068d4:	0801f9f0 	.word	0x0801f9f0

080068d8 <mqtt_set_inpub_callback>:
 * @param arg User supplied argument to both callbacks
 */
void
mqtt_set_inpub_callback(mqtt_client_t *client, mqtt_incoming_publish_cb_t pub_cb,
                        mqtt_incoming_data_cb_t data_cb, void *arg)
{
 80068d8:	b580      	push	{r7, lr}
 80068da:	b084      	sub	sp, #16
 80068dc:	af00      	add	r7, sp, #0
 80068de:	60f8      	str	r0, [r7, #12]
 80068e0:	60b9      	str	r1, [r7, #8]
 80068e2:	607a      	str	r2, [r7, #4]
 80068e4:	603b      	str	r3, [r7, #0]
  LWIP_ASSERT_CORE_LOCKED();
  LWIP_ASSERT("mqtt_set_inpub_callback: client != NULL", client != NULL);
 80068e6:	68fb      	ldr	r3, [r7, #12]
 80068e8:	2b00      	cmp	r3, #0
 80068ea:	d105      	bne.n	80068f8 <mqtt_set_inpub_callback+0x20>
 80068ec:	4b09      	ldr	r3, [pc, #36]	; (8006914 <mqtt_set_inpub_callback+0x3c>)
 80068ee:	4a0a      	ldr	r2, [pc, #40]	; (8006918 <mqtt_set_inpub_callback+0x40>)
 80068f0:	490a      	ldr	r1, [pc, #40]	; (800691c <mqtt_set_inpub_callback+0x44>)
 80068f2:	480b      	ldr	r0, [pc, #44]	; (8006920 <mqtt_set_inpub_callback+0x48>)
 80068f4:	f7fb fc76 	bl	80021e4 <app_debug_rtt_raw>
  client->data_cb = data_cb;
 80068f8:	68fb      	ldr	r3, [r7, #12]
 80068fa:	687a      	ldr	r2, [r7, #4]
 80068fc:	661a      	str	r2, [r3, #96]	; 0x60
  client->pub_cb = pub_cb;
 80068fe:	68fb      	ldr	r3, [r7, #12]
 8006900:	68ba      	ldr	r2, [r7, #8]
 8006902:	665a      	str	r2, [r3, #100]	; 0x64
  client->inpub_arg = arg;
 8006904:	68fb      	ldr	r3, [r7, #12]
 8006906:	683a      	ldr	r2, [r7, #0]
 8006908:	65da      	str	r2, [r3, #92]	; 0x5c
}
 800690a:	46c0      	nop			; (mov r8, r8)
 800690c:	46bd      	mov	sp, r7
 800690e:	b004      	add	sp, #16
 8006910:	bd80      	pop	{r7, pc}
 8006912:	46c0      	nop			; (mov r8, r8)
 8006914:	0801f5e8 	.word	0x0801f5e8
 8006918:	000004d9 	.word	0x000004d9
 800691c:	0801fa08 	.word	0x0801fa08
 8006920:	0801f654 	.word	0x0801f654

08006924 <mqtt_client_connect>:
 * @return ERR_OK if successful, @see err_t enum for other results
 */
err_t
mqtt_client_connect(mqtt_client_t *client, const ip_addr_t *ip_addr, u16_t port, mqtt_connection_cb_t cb, void *arg,
                    const struct mqtt_connect_client_info_t *client_info)
{
 8006924:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006926:	b08d      	sub	sp, #52	; 0x34
 8006928:	af02      	add	r7, sp, #8
 800692a:	60f8      	str	r0, [r7, #12]
 800692c:	60b9      	str	r1, [r7, #8]
 800692e:	603b      	str	r3, [r7, #0]
 8006930:	1dbb      	adds	r3, r7, #6
 8006932:	801a      	strh	r2, [r3, #0]
  err_t err;
  size_t len;
  u16_t client_id_length;
  /* Length is the sum of 2+"MQTT", protocol level, flags and keep alive */
  u16_t remaining_length = 2 + 4 + 1 + 1 + 2;
 8006934:	2326      	movs	r3, #38	; 0x26
 8006936:	18fb      	adds	r3, r7, r3
 8006938:	220a      	movs	r2, #10
 800693a:	801a      	strh	r2, [r3, #0]
  u8_t flags = 0, will_topic_len = 0, will_msg_len = 0;
 800693c:	2324      	movs	r3, #36	; 0x24
 800693e:	18fb      	adds	r3, r7, r3
 8006940:	2200      	movs	r2, #0
 8006942:	701a      	strb	r2, [r3, #0]
 8006944:	2323      	movs	r3, #35	; 0x23
 8006946:	18fb      	adds	r3, r7, r3
 8006948:	2200      	movs	r2, #0
 800694a:	701a      	strb	r2, [r3, #0]
 800694c:	2322      	movs	r3, #34	; 0x22
 800694e:	18fb      	adds	r3, r7, r3
 8006950:	2200      	movs	r2, #0
 8006952:	701a      	strb	r2, [r3, #0]
  u16_t client_user_len = 0, client_pass_len = 0;
 8006954:	2320      	movs	r3, #32
 8006956:	18fb      	adds	r3, r7, r3
 8006958:	2200      	movs	r2, #0
 800695a:	801a      	strh	r2, [r3, #0]
 800695c:	231e      	movs	r3, #30
 800695e:	18fb      	adds	r3, r7, r3
 8006960:	2200      	movs	r2, #0
 8006962:	801a      	strh	r2, [r3, #0]

  LWIP_ASSERT_CORE_LOCKED();
  LWIP_ASSERT("mqtt_client_connect: client != NULL", client != NULL);
 8006964:	68fb      	ldr	r3, [r7, #12]
 8006966:	2b00      	cmp	r3, #0
 8006968:	d105      	bne.n	8006976 <mqtt_client_connect+0x52>
 800696a:	4bca      	ldr	r3, [pc, #808]	; (8006c94 <mqtt_client_connect+0x370>)
 800696c:	4aca      	ldr	r2, [pc, #808]	; (8006c98 <mqtt_client_connect+0x374>)
 800696e:	49cb      	ldr	r1, [pc, #812]	; (8006c9c <mqtt_client_connect+0x378>)
 8006970:	48cb      	ldr	r0, [pc, #812]	; (8006ca0 <mqtt_client_connect+0x37c>)
 8006972:	f7fb fc37 	bl	80021e4 <app_debug_rtt_raw>
  LWIP_ASSERT("mqtt_client_connect: ip_addr != NULL", ip_addr != NULL);
 8006976:	68bb      	ldr	r3, [r7, #8]
 8006978:	2b00      	cmp	r3, #0
 800697a:	d105      	bne.n	8006988 <mqtt_client_connect+0x64>
 800697c:	4bc5      	ldr	r3, [pc, #788]	; (8006c94 <mqtt_client_connect+0x370>)
 800697e:	4ac9      	ldr	r2, [pc, #804]	; (8006ca4 <mqtt_client_connect+0x380>)
 8006980:	49c9      	ldr	r1, [pc, #804]	; (8006ca8 <mqtt_client_connect+0x384>)
 8006982:	48c7      	ldr	r0, [pc, #796]	; (8006ca0 <mqtt_client_connect+0x37c>)
 8006984:	f7fb fc2e 	bl	80021e4 <app_debug_rtt_raw>
  LWIP_ASSERT("mqtt_client_connect: client_info != NULL", client_info != NULL);
 8006988:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800698a:	2b00      	cmp	r3, #0
 800698c:	d106      	bne.n	800699c <mqtt_client_connect+0x78>
 800698e:	4bc1      	ldr	r3, [pc, #772]	; (8006c94 <mqtt_client_connect+0x370>)
 8006990:	22a2      	movs	r2, #162	; 0xa2
 8006992:	00d2      	lsls	r2, r2, #3
 8006994:	49c5      	ldr	r1, [pc, #788]	; (8006cac <mqtt_client_connect+0x388>)
 8006996:	48c2      	ldr	r0, [pc, #776]	; (8006ca0 <mqtt_client_connect+0x37c>)
 8006998:	f7fb fc24 	bl	80021e4 <app_debug_rtt_raw>
  LWIP_ASSERT("mqtt_client_connect: client_info->client_id != NULL", client_info->client_id != NULL);
 800699c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800699e:	681b      	ldr	r3, [r3, #0]
 80069a0:	2b00      	cmp	r3, #0
 80069a2:	d105      	bne.n	80069b0 <mqtt_client_connect+0x8c>
 80069a4:	4bbb      	ldr	r3, [pc, #748]	; (8006c94 <mqtt_client_connect+0x370>)
 80069a6:	4ac2      	ldr	r2, [pc, #776]	; (8006cb0 <mqtt_client_connect+0x38c>)
 80069a8:	49c2      	ldr	r1, [pc, #776]	; (8006cb4 <mqtt_client_connect+0x390>)
 80069aa:	48bd      	ldr	r0, [pc, #756]	; (8006ca0 <mqtt_client_connect+0x37c>)
 80069ac:	f7fb fc1a 	bl	80021e4 <app_debug_rtt_raw>

  if (client->conn_state != TCP_DISCONNECTED) {
 80069b0:	68fb      	ldr	r3, [r7, #12]
 80069b2:	7a9b      	ldrb	r3, [r3, #10]
 80069b4:	2b00      	cmp	r3, #0
 80069b6:	d002      	beq.n	80069be <mqtt_client_connect+0x9a>
    LWIP_DEBUGF(MQTT_DEBUG_WARN, ("mqtt_client_connect: Already connected\n"));
    return ERR_ISCONN;
 80069b8:	230a      	movs	r3, #10
 80069ba:	425b      	negs	r3, r3
 80069bc:	e24b      	b.n	8006e56 <mqtt_client_connect+0x532>
  }

  /* Wipe clean */
  memset(client, 0, sizeof(mqtt_client_t));
 80069be:	23f8      	movs	r3, #248	; 0xf8
 80069c0:	005a      	lsls	r2, r3, #1
 80069c2:	68fb      	ldr	r3, [r7, #12]
 80069c4:	2100      	movs	r1, #0
 80069c6:	0018      	movs	r0, r3
 80069c8:	f017 fb04 	bl	801dfd4 <memset>
  client->connect_arg = arg;
 80069cc:	68fb      	ldr	r3, [r7, #12]
 80069ce:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80069d0:	611a      	str	r2, [r3, #16]
  client->connect_cb = cb;
 80069d2:	68fb      	ldr	r3, [r7, #12]
 80069d4:	683a      	ldr	r2, [r7, #0]
 80069d6:	615a      	str	r2, [r3, #20]
  client->keep_alive = client_info->keep_alive;
 80069d8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80069da:	899a      	ldrh	r2, [r3, #12]
 80069dc:	68fb      	ldr	r3, [r7, #12]
 80069de:	805a      	strh	r2, [r3, #2]
  mqtt_init_requests(client->req_list, LWIP_ARRAYSIZE(client->req_list));
 80069e0:	68fb      	ldr	r3, [r7, #12]
 80069e2:	331c      	adds	r3, #28
 80069e4:	2104      	movs	r1, #4
 80069e6:	0018      	movs	r0, r3
 80069e8:	f7fe fe28 	bl	800563c <mqtt_init_requests>

  /* Build connect message */
  if (client_info->will_topic != NULL && client_info->will_msg != NULL) {
 80069ec:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80069ee:	691b      	ldr	r3, [r3, #16]
 80069f0:	2b00      	cmp	r3, #0
 80069f2:	d100      	bne.n	80069f6 <mqtt_client_connect+0xd2>
 80069f4:	e073      	b.n	8006ade <mqtt_client_connect+0x1ba>
 80069f6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80069f8:	695b      	ldr	r3, [r3, #20]
 80069fa:	2b00      	cmp	r3, #0
 80069fc:	d06f      	beq.n	8006ade <mqtt_client_connect+0x1ba>
    flags |= MQTT_CONNECT_FLAG_WILL;
 80069fe:	2024      	movs	r0, #36	; 0x24
 8006a00:	183b      	adds	r3, r7, r0
 8006a02:	183a      	adds	r2, r7, r0
 8006a04:	7812      	ldrb	r2, [r2, #0]
 8006a06:	2104      	movs	r1, #4
 8006a08:	430a      	orrs	r2, r1
 8006a0a:	701a      	strb	r2, [r3, #0]
    flags |= (client_info->will_qos & 3) << 3;
 8006a0c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006a0e:	7e1b      	ldrb	r3, [r3, #24]
 8006a10:	00db      	lsls	r3, r3, #3
 8006a12:	b25b      	sxtb	r3, r3
 8006a14:	2218      	movs	r2, #24
 8006a16:	4013      	ands	r3, r2
 8006a18:	b25a      	sxtb	r2, r3
 8006a1a:	183b      	adds	r3, r7, r0
 8006a1c:	781b      	ldrb	r3, [r3, #0]
 8006a1e:	b25b      	sxtb	r3, r3
 8006a20:	4313      	orrs	r3, r2
 8006a22:	b25a      	sxtb	r2, r3
 8006a24:	183b      	adds	r3, r7, r0
 8006a26:	701a      	strb	r2, [r3, #0]
    if (client_info->will_retain) {
 8006a28:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006a2a:	7e5b      	ldrb	r3, [r3, #25]
 8006a2c:	2b00      	cmp	r3, #0
 8006a2e:	d005      	beq.n	8006a3c <mqtt_client_connect+0x118>
      flags |= MQTT_CONNECT_FLAG_WILL_RETAIN;
 8006a30:	183b      	adds	r3, r7, r0
 8006a32:	183a      	adds	r2, r7, r0
 8006a34:	7812      	ldrb	r2, [r2, #0]
 8006a36:	2120      	movs	r1, #32
 8006a38:	430a      	orrs	r2, r1
 8006a3a:	701a      	strb	r2, [r3, #0]
    }
    len = strlen(client_info->will_topic);
 8006a3c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006a3e:	691b      	ldr	r3, [r3, #16]
 8006a40:	0018      	movs	r0, r3
 8006a42:	f7f9 fb6b 	bl	800011c <strlen>
 8006a46:	0003      	movs	r3, r0
 8006a48:	61bb      	str	r3, [r7, #24]
    LWIP_ERROR("mqtt_client_connect: client_info->will_topic length overflow", len <= 0xFF, return ERR_VAL);
 8006a4a:	69bb      	ldr	r3, [r7, #24]
 8006a4c:	2bff      	cmp	r3, #255	; 0xff
 8006a4e:	d906      	bls.n	8006a5e <mqtt_client_connect+0x13a>
 8006a50:	4b99      	ldr	r3, [pc, #612]	; (8006cb8 <mqtt_client_connect+0x394>)
 8006a52:	0018      	movs	r0, r3
 8006a54:	f7fb fbc6 	bl	80021e4 <app_debug_rtt_raw>
 8006a58:	2306      	movs	r3, #6
 8006a5a:	425b      	negs	r3, r3
 8006a5c:	e1fb      	b.n	8006e56 <mqtt_client_connect+0x532>
    LWIP_ERROR("mqtt_client_connect: client_info->will_topic length must be > 0", len > 0, return ERR_VAL);
 8006a5e:	69bb      	ldr	r3, [r7, #24]
 8006a60:	2b00      	cmp	r3, #0
 8006a62:	d106      	bne.n	8006a72 <mqtt_client_connect+0x14e>
 8006a64:	4b95      	ldr	r3, [pc, #596]	; (8006cbc <mqtt_client_connect+0x398>)
 8006a66:	0018      	movs	r0, r3
 8006a68:	f7fb fbbc 	bl	80021e4 <app_debug_rtt_raw>
 8006a6c:	2306      	movs	r3, #6
 8006a6e:	425b      	negs	r3, r3
 8006a70:	e1f1      	b.n	8006e56 <mqtt_client_connect+0x532>
    will_topic_len = (u8_t)len;
 8006a72:	2323      	movs	r3, #35	; 0x23
 8006a74:	18fb      	adds	r3, r7, r3
 8006a76:	69ba      	ldr	r2, [r7, #24]
 8006a78:	701a      	strb	r2, [r3, #0]
    len = strlen(client_info->will_msg);
 8006a7a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006a7c:	695b      	ldr	r3, [r3, #20]
 8006a7e:	0018      	movs	r0, r3
 8006a80:	f7f9 fb4c 	bl	800011c <strlen>
 8006a84:	0003      	movs	r3, r0
 8006a86:	61bb      	str	r3, [r7, #24]
    LWIP_ERROR("mqtt_client_connect: client_info->will_msg length overflow", len <= 0xFF, return ERR_VAL);
 8006a88:	69bb      	ldr	r3, [r7, #24]
 8006a8a:	2bff      	cmp	r3, #255	; 0xff
 8006a8c:	d906      	bls.n	8006a9c <mqtt_client_connect+0x178>
 8006a8e:	4b8c      	ldr	r3, [pc, #560]	; (8006cc0 <mqtt_client_connect+0x39c>)
 8006a90:	0018      	movs	r0, r3
 8006a92:	f7fb fba7 	bl	80021e4 <app_debug_rtt_raw>
 8006a96:	2306      	movs	r3, #6
 8006a98:	425b      	negs	r3, r3
 8006a9a:	e1dc      	b.n	8006e56 <mqtt_client_connect+0x532>
    will_msg_len = (u8_t)len;
 8006a9c:	2122      	movs	r1, #34	; 0x22
 8006a9e:	187b      	adds	r3, r7, r1
 8006aa0:	69ba      	ldr	r2, [r7, #24]
 8006aa2:	701a      	strb	r2, [r3, #0]
    len = remaining_length + 2 + will_topic_len + 2 + will_msg_len;
 8006aa4:	2326      	movs	r3, #38	; 0x26
 8006aa6:	18fb      	adds	r3, r7, r3
 8006aa8:	881b      	ldrh	r3, [r3, #0]
 8006aaa:	1c9a      	adds	r2, r3, #2
 8006aac:	2323      	movs	r3, #35	; 0x23
 8006aae:	18fb      	adds	r3, r7, r3
 8006ab0:	781b      	ldrb	r3, [r3, #0]
 8006ab2:	18d3      	adds	r3, r2, r3
 8006ab4:	1c9a      	adds	r2, r3, #2
 8006ab6:	187b      	adds	r3, r7, r1
 8006ab8:	781b      	ldrb	r3, [r3, #0]
 8006aba:	18d3      	adds	r3, r2, r3
 8006abc:	61bb      	str	r3, [r7, #24]
    LWIP_ERROR("mqtt_client_connect: remaining_length overflow", len <= 0xFFFF, return ERR_VAL);
 8006abe:	69ba      	ldr	r2, [r7, #24]
 8006ac0:	2380      	movs	r3, #128	; 0x80
 8006ac2:	025b      	lsls	r3, r3, #9
 8006ac4:	429a      	cmp	r2, r3
 8006ac6:	d306      	bcc.n	8006ad6 <mqtt_client_connect+0x1b2>
 8006ac8:	4b7e      	ldr	r3, [pc, #504]	; (8006cc4 <mqtt_client_connect+0x3a0>)
 8006aca:	0018      	movs	r0, r3
 8006acc:	f7fb fb8a 	bl	80021e4 <app_debug_rtt_raw>
 8006ad0:	2306      	movs	r3, #6
 8006ad2:	425b      	negs	r3, r3
 8006ad4:	e1bf      	b.n	8006e56 <mqtt_client_connect+0x532>
    remaining_length = (u16_t)len;
 8006ad6:	2326      	movs	r3, #38	; 0x26
 8006ad8:	18fb      	adds	r3, r7, r3
 8006ada:	69ba      	ldr	r2, [r7, #24]
 8006adc:	801a      	strh	r2, [r3, #0]
  }
  if (client_info->client_user != NULL) {
 8006ade:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006ae0:	685b      	ldr	r3, [r3, #4]
 8006ae2:	2b00      	cmp	r3, #0
 8006ae4:	d040      	beq.n	8006b68 <mqtt_client_connect+0x244>
    flags |= MQTT_CONNECT_FLAG_USERNAME;
 8006ae6:	2224      	movs	r2, #36	; 0x24
 8006ae8:	18bb      	adds	r3, r7, r2
 8006aea:	18ba      	adds	r2, r7, r2
 8006aec:	7812      	ldrb	r2, [r2, #0]
 8006aee:	2180      	movs	r1, #128	; 0x80
 8006af0:	4249      	negs	r1, r1
 8006af2:	430a      	orrs	r2, r1
 8006af4:	701a      	strb	r2, [r3, #0]
    len = strlen(client_info->client_user);
 8006af6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006af8:	685b      	ldr	r3, [r3, #4]
 8006afa:	0018      	movs	r0, r3
 8006afc:	f7f9 fb0e 	bl	800011c <strlen>
 8006b00:	0003      	movs	r3, r0
 8006b02:	61bb      	str	r3, [r7, #24]
    LWIP_ERROR("mqtt_client_connect: client_info->client_user length overflow", len <= 0xFFFF, return ERR_VAL);
 8006b04:	69ba      	ldr	r2, [r7, #24]
 8006b06:	2380      	movs	r3, #128	; 0x80
 8006b08:	025b      	lsls	r3, r3, #9
 8006b0a:	429a      	cmp	r2, r3
 8006b0c:	d306      	bcc.n	8006b1c <mqtt_client_connect+0x1f8>
 8006b0e:	4b6e      	ldr	r3, [pc, #440]	; (8006cc8 <mqtt_client_connect+0x3a4>)
 8006b10:	0018      	movs	r0, r3
 8006b12:	f7fb fb67 	bl	80021e4 <app_debug_rtt_raw>
 8006b16:	2306      	movs	r3, #6
 8006b18:	425b      	negs	r3, r3
 8006b1a:	e19c      	b.n	8006e56 <mqtt_client_connect+0x532>
    LWIP_ERROR("mqtt_client_connect: client_info->client_user length must be > 0", len > 0, return ERR_VAL);
 8006b1c:	69bb      	ldr	r3, [r7, #24]
 8006b1e:	2b00      	cmp	r3, #0
 8006b20:	d106      	bne.n	8006b30 <mqtt_client_connect+0x20c>
 8006b22:	4b6a      	ldr	r3, [pc, #424]	; (8006ccc <mqtt_client_connect+0x3a8>)
 8006b24:	0018      	movs	r0, r3
 8006b26:	f7fb fb5d 	bl	80021e4 <app_debug_rtt_raw>
 8006b2a:	2306      	movs	r3, #6
 8006b2c:	425b      	negs	r3, r3
 8006b2e:	e192      	b.n	8006e56 <mqtt_client_connect+0x532>
    client_user_len = (u16_t)len;
 8006b30:	2120      	movs	r1, #32
 8006b32:	187b      	adds	r3, r7, r1
 8006b34:	69ba      	ldr	r2, [r7, #24]
 8006b36:	801a      	strh	r2, [r3, #0]
    len = remaining_length + 2 + client_user_len;
 8006b38:	2326      	movs	r3, #38	; 0x26
 8006b3a:	18fb      	adds	r3, r7, r3
 8006b3c:	881b      	ldrh	r3, [r3, #0]
 8006b3e:	1c9a      	adds	r2, r3, #2
 8006b40:	187b      	adds	r3, r7, r1
 8006b42:	881b      	ldrh	r3, [r3, #0]
 8006b44:	18d3      	adds	r3, r2, r3
 8006b46:	61bb      	str	r3, [r7, #24]
    LWIP_ERROR("mqtt_client_connect: remaining_length overflow", len <= 0xFFFF, return ERR_VAL);
 8006b48:	69ba      	ldr	r2, [r7, #24]
 8006b4a:	2380      	movs	r3, #128	; 0x80
 8006b4c:	025b      	lsls	r3, r3, #9
 8006b4e:	429a      	cmp	r2, r3
 8006b50:	d306      	bcc.n	8006b60 <mqtt_client_connect+0x23c>
 8006b52:	4b5c      	ldr	r3, [pc, #368]	; (8006cc4 <mqtt_client_connect+0x3a0>)
 8006b54:	0018      	movs	r0, r3
 8006b56:	f7fb fb45 	bl	80021e4 <app_debug_rtt_raw>
 8006b5a:	2306      	movs	r3, #6
 8006b5c:	425b      	negs	r3, r3
 8006b5e:	e17a      	b.n	8006e56 <mqtt_client_connect+0x532>
    remaining_length = (u16_t)len;
 8006b60:	2326      	movs	r3, #38	; 0x26
 8006b62:	18fb      	adds	r3, r7, r3
 8006b64:	69ba      	ldr	r2, [r7, #24]
 8006b66:	801a      	strh	r2, [r3, #0]
  }
  if (client_info->client_pass != NULL) {
 8006b68:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006b6a:	689b      	ldr	r3, [r3, #8]
 8006b6c:	2b00      	cmp	r3, #0
 8006b6e:	d03f      	beq.n	8006bf0 <mqtt_client_connect+0x2cc>
    flags |= MQTT_CONNECT_FLAG_PASSWORD;
 8006b70:	2224      	movs	r2, #36	; 0x24
 8006b72:	18bb      	adds	r3, r7, r2
 8006b74:	18ba      	adds	r2, r7, r2
 8006b76:	7812      	ldrb	r2, [r2, #0]
 8006b78:	2140      	movs	r1, #64	; 0x40
 8006b7a:	430a      	orrs	r2, r1
 8006b7c:	701a      	strb	r2, [r3, #0]
    len = strlen(client_info->client_pass);
 8006b7e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006b80:	689b      	ldr	r3, [r3, #8]
 8006b82:	0018      	movs	r0, r3
 8006b84:	f7f9 faca 	bl	800011c <strlen>
 8006b88:	0003      	movs	r3, r0
 8006b8a:	61bb      	str	r3, [r7, #24]
    LWIP_ERROR("mqtt_client_connect: client_info->client_pass length overflow", len <= 0xFFFF, return ERR_VAL);
 8006b8c:	69ba      	ldr	r2, [r7, #24]
 8006b8e:	2380      	movs	r3, #128	; 0x80
 8006b90:	025b      	lsls	r3, r3, #9
 8006b92:	429a      	cmp	r2, r3
 8006b94:	d306      	bcc.n	8006ba4 <mqtt_client_connect+0x280>
 8006b96:	4b4e      	ldr	r3, [pc, #312]	; (8006cd0 <mqtt_client_connect+0x3ac>)
 8006b98:	0018      	movs	r0, r3
 8006b9a:	f7fb fb23 	bl	80021e4 <app_debug_rtt_raw>
 8006b9e:	2306      	movs	r3, #6
 8006ba0:	425b      	negs	r3, r3
 8006ba2:	e158      	b.n	8006e56 <mqtt_client_connect+0x532>
    LWIP_ERROR("mqtt_client_connect: client_info->client_pass length must be > 0", len > 0, return ERR_VAL);
 8006ba4:	69bb      	ldr	r3, [r7, #24]
 8006ba6:	2b00      	cmp	r3, #0
 8006ba8:	d106      	bne.n	8006bb8 <mqtt_client_connect+0x294>
 8006baa:	4b4a      	ldr	r3, [pc, #296]	; (8006cd4 <mqtt_client_connect+0x3b0>)
 8006bac:	0018      	movs	r0, r3
 8006bae:	f7fb fb19 	bl	80021e4 <app_debug_rtt_raw>
 8006bb2:	2306      	movs	r3, #6
 8006bb4:	425b      	negs	r3, r3
 8006bb6:	e14e      	b.n	8006e56 <mqtt_client_connect+0x532>
    client_pass_len = (u16_t)len;
 8006bb8:	211e      	movs	r1, #30
 8006bba:	187b      	adds	r3, r7, r1
 8006bbc:	69ba      	ldr	r2, [r7, #24]
 8006bbe:	801a      	strh	r2, [r3, #0]
    len = remaining_length + 2 + client_pass_len;
 8006bc0:	2326      	movs	r3, #38	; 0x26
 8006bc2:	18fb      	adds	r3, r7, r3
 8006bc4:	881b      	ldrh	r3, [r3, #0]
 8006bc6:	1c9a      	adds	r2, r3, #2
 8006bc8:	187b      	adds	r3, r7, r1
 8006bca:	881b      	ldrh	r3, [r3, #0]
 8006bcc:	18d3      	adds	r3, r2, r3
 8006bce:	61bb      	str	r3, [r7, #24]
    LWIP_ERROR("mqtt_client_connect: remaining_length overflow", len <= 0xFFFF, return ERR_VAL);
 8006bd0:	69ba      	ldr	r2, [r7, #24]
 8006bd2:	2380      	movs	r3, #128	; 0x80
 8006bd4:	025b      	lsls	r3, r3, #9
 8006bd6:	429a      	cmp	r2, r3
 8006bd8:	d306      	bcc.n	8006be8 <mqtt_client_connect+0x2c4>
 8006bda:	4b3a      	ldr	r3, [pc, #232]	; (8006cc4 <mqtt_client_connect+0x3a0>)
 8006bdc:	0018      	movs	r0, r3
 8006bde:	f7fb fb01 	bl	80021e4 <app_debug_rtt_raw>
 8006be2:	2306      	movs	r3, #6
 8006be4:	425b      	negs	r3, r3
 8006be6:	e136      	b.n	8006e56 <mqtt_client_connect+0x532>
    remaining_length = (u16_t)len;
 8006be8:	2326      	movs	r3, #38	; 0x26
 8006bea:	18fb      	adds	r3, r7, r3
 8006bec:	69ba      	ldr	r2, [r7, #24]
 8006bee:	801a      	strh	r2, [r3, #0]
  }

  /* Don't complicate things, always connect using clean session */
  flags |= MQTT_CONNECT_FLAG_CLEAN_SESSION;
 8006bf0:	2224      	movs	r2, #36	; 0x24
 8006bf2:	18bb      	adds	r3, r7, r2
 8006bf4:	18ba      	adds	r2, r7, r2
 8006bf6:	7812      	ldrb	r2, [r2, #0]
 8006bf8:	2102      	movs	r1, #2
 8006bfa:	430a      	orrs	r2, r1
 8006bfc:	701a      	strb	r2, [r3, #0]

  len = strlen(client_info->client_id);
 8006bfe:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006c00:	681b      	ldr	r3, [r3, #0]
 8006c02:	0018      	movs	r0, r3
 8006c04:	f7f9 fa8a 	bl	800011c <strlen>
 8006c08:	0003      	movs	r3, r0
 8006c0a:	61bb      	str	r3, [r7, #24]
  LWIP_ERROR("mqtt_client_connect: client_info->client_id length overflow", len <= 0xFFFF, return ERR_VAL);
 8006c0c:	69ba      	ldr	r2, [r7, #24]
 8006c0e:	2380      	movs	r3, #128	; 0x80
 8006c10:	025b      	lsls	r3, r3, #9
 8006c12:	429a      	cmp	r2, r3
 8006c14:	d306      	bcc.n	8006c24 <mqtt_client_connect+0x300>
 8006c16:	4b30      	ldr	r3, [pc, #192]	; (8006cd8 <mqtt_client_connect+0x3b4>)
 8006c18:	0018      	movs	r0, r3
 8006c1a:	f7fb fae3 	bl	80021e4 <app_debug_rtt_raw>
 8006c1e:	2306      	movs	r3, #6
 8006c20:	425b      	negs	r3, r3
 8006c22:	e118      	b.n	8006e56 <mqtt_client_connect+0x532>
  client_id_length = (u16_t)len;
 8006c24:	2116      	movs	r1, #22
 8006c26:	187b      	adds	r3, r7, r1
 8006c28:	69ba      	ldr	r2, [r7, #24]
 8006c2a:	801a      	strh	r2, [r3, #0]
  len = remaining_length + 2 + client_id_length;
 8006c2c:	2326      	movs	r3, #38	; 0x26
 8006c2e:	18fb      	adds	r3, r7, r3
 8006c30:	881b      	ldrh	r3, [r3, #0]
 8006c32:	1c9a      	adds	r2, r3, #2
 8006c34:	187b      	adds	r3, r7, r1
 8006c36:	881b      	ldrh	r3, [r3, #0]
 8006c38:	18d3      	adds	r3, r2, r3
 8006c3a:	61bb      	str	r3, [r7, #24]
  LWIP_ERROR("mqtt_client_connect: remaining_length overflow", len <= 0xFFFF, return ERR_VAL);
 8006c3c:	69ba      	ldr	r2, [r7, #24]
 8006c3e:	2380      	movs	r3, #128	; 0x80
 8006c40:	025b      	lsls	r3, r3, #9
 8006c42:	429a      	cmp	r2, r3
 8006c44:	d306      	bcc.n	8006c54 <mqtt_client_connect+0x330>
 8006c46:	4b1f      	ldr	r3, [pc, #124]	; (8006cc4 <mqtt_client_connect+0x3a0>)
 8006c48:	0018      	movs	r0, r3
 8006c4a:	f7fb facb 	bl	80021e4 <app_debug_rtt_raw>
 8006c4e:	2306      	movs	r3, #6
 8006c50:	425b      	negs	r3, r3
 8006c52:	e100      	b.n	8006e56 <mqtt_client_connect+0x532>
  remaining_length = (u16_t)len;
 8006c54:	2126      	movs	r1, #38	; 0x26
 8006c56:	187b      	adds	r3, r7, r1
 8006c58:	69ba      	ldr	r2, [r7, #24]
 8006c5a:	801a      	strh	r2, [r3, #0]

  if (mqtt_output_check_space(&client->output, remaining_length) == 0) {
 8006c5c:	68fb      	ldr	r3, [r7, #12]
 8006c5e:	33ec      	adds	r3, #236	; 0xec
 8006c60:	001a      	movs	r2, r3
 8006c62:	187b      	adds	r3, r7, r1
 8006c64:	881b      	ldrh	r3, [r3, #0]
 8006c66:	0019      	movs	r1, r3
 8006c68:	0010      	movs	r0, r2
 8006c6a:	f7fe fe09 	bl	8005880 <mqtt_output_check_space>
 8006c6e:	1e03      	subs	r3, r0, #0
 8006c70:	d102      	bne.n	8006c78 <mqtt_client_connect+0x354>
    return ERR_MEM;
 8006c72:	2301      	movs	r3, #1
 8006c74:	425b      	negs	r3, r3
 8006c76:	e0ee      	b.n	8006e56 <mqtt_client_connect+0x532>
  if (client_info->tls_config) {
    client->conn = altcp_tls_new(client_info->tls_config, IP_GET_TYPE(ip_addr));
  } else
#endif
  {
    client->conn = altcp_tcp_new_ip_type(IP_GET_TYPE(ip_addr));
 8006c78:	2000      	movs	r0, #0
 8006c7a:	f005 fea5 	bl	800c9c8 <tcp_new_ip_type>
 8006c7e:	0002      	movs	r2, r0
 8006c80:	68fb      	ldr	r3, [r7, #12]
 8006c82:	60da      	str	r2, [r3, #12]
  }
  if (client->conn == NULL) {
 8006c84:	68fb      	ldr	r3, [r7, #12]
 8006c86:	68db      	ldr	r3, [r3, #12]
 8006c88:	2b00      	cmp	r3, #0
 8006c8a:	d127      	bne.n	8006cdc <mqtt_client_connect+0x3b8>
    return ERR_MEM;
 8006c8c:	2301      	movs	r3, #1
 8006c8e:	425b      	negs	r3, r3
 8006c90:	e0e1      	b.n	8006e56 <mqtt_client_connect+0x532>
 8006c92:	46c0      	nop			; (mov r8, r8)
 8006c94:	0801f5e8 	.word	0x0801f5e8
 8006c98:	0000050e 	.word	0x0000050e
 8006c9c:	0801fa30 	.word	0x0801fa30
 8006ca0:	0801f654 	.word	0x0801f654
 8006ca4:	0000050f 	.word	0x0000050f
 8006ca8:	0801fa54 	.word	0x0801fa54
 8006cac:	0801fa7c 	.word	0x0801fa7c
 8006cb0:	00000511 	.word	0x00000511
 8006cb4:	0801faa8 	.word	0x0801faa8
 8006cb8:	0801fadc 	.word	0x0801fadc
 8006cbc:	0801fb1c 	.word	0x0801fb1c
 8006cc0:	0801fb5c 	.word	0x0801fb5c
 8006cc4:	0801fb98 	.word	0x0801fb98
 8006cc8:	0801fbc8 	.word	0x0801fbc8
 8006ccc:	0801fc08 	.word	0x0801fc08
 8006cd0:	0801fc4c 	.word	0x0801fc4c
 8006cd4:	0801fc8c 	.word	0x0801fc8c
 8006cd8:	0801fcd0 	.word	0x0801fcd0
  }

  /* Set arg pointer for callbacks */
  altcp_arg(client->conn, client);
 8006cdc:	68fb      	ldr	r3, [r7, #12]
 8006cde:	68db      	ldr	r3, [r3, #12]
 8006ce0:	68fa      	ldr	r2, [r7, #12]
 8006ce2:	0011      	movs	r1, r2
 8006ce4:	0018      	movs	r0, r3
 8006ce6:	f005 fe7f 	bl	800c9e8 <tcp_arg>
  /* Any local address, pick random local port number */
  err = altcp_bind(client->conn, IP_ADDR_ANY, 0);
 8006cea:	68fb      	ldr	r3, [r7, #12]
 8006cec:	68db      	ldr	r3, [r3, #12]
 8006cee:	2625      	movs	r6, #37	; 0x25
 8006cf0:	19bc      	adds	r4, r7, r6
 8006cf2:	495b      	ldr	r1, [pc, #364]	; (8006e60 <mqtt_client_connect+0x53c>)
 8006cf4:	2200      	movs	r2, #0
 8006cf6:	0018      	movs	r0, r3
 8006cf8:	f004 fcb2 	bl	800b660 <tcp_bind>
 8006cfc:	0003      	movs	r3, r0
 8006cfe:	7023      	strb	r3, [r4, #0]
  if (err != ERR_OK) {
 8006d00:	19bb      	adds	r3, r7, r6
 8006d02:	781b      	ldrb	r3, [r3, #0]
 8006d04:	b25b      	sxtb	r3, r3
 8006d06:	2b00      	cmp	r3, #0
 8006d08:	d000      	beq.n	8006d0c <mqtt_client_connect+0x3e8>
 8006d0a:	e095      	b.n	8006e38 <mqtt_client_connect+0x514>
    goto tcp_fail;
  }
  LWIP_DEBUGF(MQTT_DEBUG_TRACE, ("mqtt_client_connect: Connecting to host: %s at port:%"U16_F"\n", ipaddr_ntoa(ip_addr), port));

  /* Connect to server */
  err = altcp_connect(client->conn, ip_addr, port, mqtt_tcp_connect_cb);
 8006d0c:	68fb      	ldr	r3, [r7, #12]
 8006d0e:	68d8      	ldr	r0, [r3, #12]
 8006d10:	19bc      	adds	r4, r7, r6
 8006d12:	4d54      	ldr	r5, [pc, #336]	; (8006e64 <mqtt_client_connect+0x540>)
 8006d14:	1dbb      	adds	r3, r7, #6
 8006d16:	881a      	ldrh	r2, [r3, #0]
 8006d18:	68b9      	ldr	r1, [r7, #8]
 8006d1a:	002b      	movs	r3, r5
 8006d1c:	f004 fe54 	bl	800b9c8 <tcp_connect>
 8006d20:	0003      	movs	r3, r0
 8006d22:	7023      	strb	r3, [r4, #0]
  if (err != ERR_OK) {
 8006d24:	19bb      	adds	r3, r7, r6
 8006d26:	781b      	ldrb	r3, [r3, #0]
 8006d28:	b25b      	sxtb	r3, r3
 8006d2a:	2b00      	cmp	r3, #0
 8006d2c:	d000      	beq.n	8006d30 <mqtt_client_connect+0x40c>
 8006d2e:	e085      	b.n	8006e3c <mqtt_client_connect+0x518>
    LWIP_DEBUGF(MQTT_DEBUG_TRACE, ("mqtt_client_connect: Error connecting to remote ip/port, %d\n", err));
    goto tcp_fail;
  }
  /* Set error callback */
  altcp_err(client->conn, mqtt_tcp_err_cb);
 8006d30:	68fb      	ldr	r3, [r7, #12]
 8006d32:	68db      	ldr	r3, [r3, #12]
 8006d34:	4a4c      	ldr	r2, [pc, #304]	; (8006e68 <mqtt_client_connect+0x544>)
 8006d36:	0011      	movs	r1, r2
 8006d38:	0018      	movs	r0, r3
 8006d3a:	f005 fea9 	bl	800ca90 <tcp_err>
  client->conn_state = TCP_CONNECTING;
 8006d3e:	68fb      	ldr	r3, [r7, #12]
 8006d40:	2201      	movs	r2, #1
 8006d42:	729a      	strb	r2, [r3, #10]

  /* Append fixed header */
  mqtt_output_append_fixed_header(&client->output, MQTT_MSG_TYPE_CONNECT, 0, 0, 0, remaining_length);
 8006d44:	68fb      	ldr	r3, [r7, #12]
 8006d46:	33ec      	adds	r3, #236	; 0xec
 8006d48:	0018      	movs	r0, r3
 8006d4a:	2326      	movs	r3, #38	; 0x26
 8006d4c:	18fb      	adds	r3, r7, r3
 8006d4e:	881b      	ldrh	r3, [r3, #0]
 8006d50:	9301      	str	r3, [sp, #4]
 8006d52:	2300      	movs	r3, #0
 8006d54:	9300      	str	r3, [sp, #0]
 8006d56:	2300      	movs	r3, #0
 8006d58:	2200      	movs	r2, #0
 8006d5a:	2101      	movs	r1, #1
 8006d5c:	f7fe fd35 	bl	80057ca <mqtt_output_append_fixed_header>
  /* Append Protocol string */
  mqtt_output_append_string(&client->output, "MQTT", 4);
 8006d60:	68fb      	ldr	r3, [r7, #12]
 8006d62:	33ec      	adds	r3, #236	; 0xec
 8006d64:	4941      	ldr	r1, [pc, #260]	; (8006e6c <mqtt_client_connect+0x548>)
 8006d66:	2204      	movs	r2, #4
 8006d68:	0018      	movs	r0, r3
 8006d6a:	f7fe fcf4 	bl	8005756 <mqtt_output_append_string>
  /* Append Protocol level */
  mqtt_output_append_u8(&client->output, 4);
 8006d6e:	68fb      	ldr	r3, [r7, #12]
 8006d70:	33ec      	adds	r3, #236	; 0xec
 8006d72:	2104      	movs	r1, #4
 8006d74:	0018      	movs	r0, r3
 8006d76:	f7fe fc97 	bl	80056a8 <mqtt_output_append_u8>
  /* Append connect flags */
  mqtt_output_append_u8(&client->output, flags);
 8006d7a:	68fb      	ldr	r3, [r7, #12]
 8006d7c:	33ec      	adds	r3, #236	; 0xec
 8006d7e:	001a      	movs	r2, r3
 8006d80:	2424      	movs	r4, #36	; 0x24
 8006d82:	193b      	adds	r3, r7, r4
 8006d84:	781b      	ldrb	r3, [r3, #0]
 8006d86:	0019      	movs	r1, r3
 8006d88:	0010      	movs	r0, r2
 8006d8a:	f7fe fc8d 	bl	80056a8 <mqtt_output_append_u8>
  /* Append keep-alive */
  mqtt_output_append_u16(&client->output, client_info->keep_alive);
 8006d8e:	68fb      	ldr	r3, [r7, #12]
 8006d90:	33ec      	adds	r3, #236	; 0xec
 8006d92:	001a      	movs	r2, r3
 8006d94:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006d96:	899b      	ldrh	r3, [r3, #12]
 8006d98:	0019      	movs	r1, r3
 8006d9a:	0010      	movs	r0, r2
 8006d9c:	f7fe fc96 	bl	80056cc <mqtt_output_append_u16>
  /* Append client id */
  mqtt_output_append_string(&client->output, client_info->client_id, client_id_length);
 8006da0:	68fb      	ldr	r3, [r7, #12]
 8006da2:	33ec      	adds	r3, #236	; 0xec
 8006da4:	0018      	movs	r0, r3
 8006da6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006da8:	6819      	ldr	r1, [r3, #0]
 8006daa:	2316      	movs	r3, #22
 8006dac:	18fb      	adds	r3, r7, r3
 8006dae:	881b      	ldrh	r3, [r3, #0]
 8006db0:	001a      	movs	r2, r3
 8006db2:	f7fe fcd0 	bl	8005756 <mqtt_output_append_string>
  /* Append will message if used */
  if ((flags & MQTT_CONNECT_FLAG_WILL) != 0) {
 8006db6:	193b      	adds	r3, r7, r4
 8006db8:	781b      	ldrb	r3, [r3, #0]
 8006dba:	2204      	movs	r2, #4
 8006dbc:	4013      	ands	r3, r2
 8006dbe:	d017      	beq.n	8006df0 <mqtt_client_connect+0x4cc>
    mqtt_output_append_string(&client->output, client_info->will_topic, will_topic_len);
 8006dc0:	68fb      	ldr	r3, [r7, #12]
 8006dc2:	33ec      	adds	r3, #236	; 0xec
 8006dc4:	0018      	movs	r0, r3
 8006dc6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006dc8:	6919      	ldr	r1, [r3, #16]
 8006dca:	2323      	movs	r3, #35	; 0x23
 8006dcc:	18fb      	adds	r3, r7, r3
 8006dce:	781b      	ldrb	r3, [r3, #0]
 8006dd0:	b29b      	uxth	r3, r3
 8006dd2:	001a      	movs	r2, r3
 8006dd4:	f7fe fcbf 	bl	8005756 <mqtt_output_append_string>
    mqtt_output_append_string(&client->output, client_info->will_msg, will_msg_len);
 8006dd8:	68fb      	ldr	r3, [r7, #12]
 8006dda:	33ec      	adds	r3, #236	; 0xec
 8006ddc:	0018      	movs	r0, r3
 8006dde:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006de0:	6959      	ldr	r1, [r3, #20]
 8006de2:	2322      	movs	r3, #34	; 0x22
 8006de4:	18fb      	adds	r3, r7, r3
 8006de6:	781b      	ldrb	r3, [r3, #0]
 8006de8:	b29b      	uxth	r3, r3
 8006dea:	001a      	movs	r2, r3
 8006dec:	f7fe fcb3 	bl	8005756 <mqtt_output_append_string>
  }
  /* Append user name if given */
  if ((flags & MQTT_CONNECT_FLAG_USERNAME) != 0) {
 8006df0:	2324      	movs	r3, #36	; 0x24
 8006df2:	18fb      	adds	r3, r7, r3
 8006df4:	781b      	ldrb	r3, [r3, #0]
 8006df6:	b25b      	sxtb	r3, r3
 8006df8:	2b00      	cmp	r3, #0
 8006dfa:	da0a      	bge.n	8006e12 <mqtt_client_connect+0x4ee>
    mqtt_output_append_string(&client->output, client_info->client_user, client_user_len);
 8006dfc:	68fb      	ldr	r3, [r7, #12]
 8006dfe:	33ec      	adds	r3, #236	; 0xec
 8006e00:	0018      	movs	r0, r3
 8006e02:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006e04:	6859      	ldr	r1, [r3, #4]
 8006e06:	2320      	movs	r3, #32
 8006e08:	18fb      	adds	r3, r7, r3
 8006e0a:	881b      	ldrh	r3, [r3, #0]
 8006e0c:	001a      	movs	r2, r3
 8006e0e:	f7fe fca2 	bl	8005756 <mqtt_output_append_string>
  }
  /* Append password if given */
  if ((flags & MQTT_CONNECT_FLAG_PASSWORD) != 0) {
 8006e12:	2324      	movs	r3, #36	; 0x24
 8006e14:	18fb      	adds	r3, r7, r3
 8006e16:	781b      	ldrb	r3, [r3, #0]
 8006e18:	2240      	movs	r2, #64	; 0x40
 8006e1a:	4013      	ands	r3, r2
 8006e1c:	d00a      	beq.n	8006e34 <mqtt_client_connect+0x510>
    mqtt_output_append_string(&client->output, client_info->client_pass, client_pass_len);
 8006e1e:	68fb      	ldr	r3, [r7, #12]
 8006e20:	33ec      	adds	r3, #236	; 0xec
 8006e22:	0018      	movs	r0, r3
 8006e24:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006e26:	6899      	ldr	r1, [r3, #8]
 8006e28:	231e      	movs	r3, #30
 8006e2a:	18fb      	adds	r3, r7, r3
 8006e2c:	881b      	ldrh	r3, [r3, #0]
 8006e2e:	001a      	movs	r2, r3
 8006e30:	f7fe fc91 	bl	8005756 <mqtt_output_append_string>
  }
  return ERR_OK;
 8006e34:	2300      	movs	r3, #0
 8006e36:	e00e      	b.n	8006e56 <mqtt_client_connect+0x532>
    goto tcp_fail;
 8006e38:	46c0      	nop			; (mov r8, r8)
 8006e3a:	e000      	b.n	8006e3e <mqtt_client_connect+0x51a>
    goto tcp_fail;
 8006e3c:	46c0      	nop			; (mov r8, r8)

tcp_fail:
  altcp_abort(client->conn);
 8006e3e:	68fb      	ldr	r3, [r7, #12]
 8006e40:	68db      	ldr	r3, [r3, #12]
 8006e42:	0018      	movs	r0, r3
 8006e44:	f004 fbfe 	bl	800b644 <tcp_abort>
  client->conn = NULL;
 8006e48:	68fb      	ldr	r3, [r7, #12]
 8006e4a:	2200      	movs	r2, #0
 8006e4c:	60da      	str	r2, [r3, #12]
  return err;
 8006e4e:	2325      	movs	r3, #37	; 0x25
 8006e50:	18fb      	adds	r3, r7, r3
 8006e52:	781b      	ldrb	r3, [r3, #0]
 8006e54:	b25b      	sxtb	r3, r3
}
 8006e56:	0018      	movs	r0, r3
 8006e58:	46bd      	mov	sp, r7
 8006e5a:	b00b      	add	sp, #44	; 0x2c
 8006e5c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006e5e:	46c0      	nop			; (mov r8, r8)
 8006e60:	08023a8c 	.word	0x08023a8c
 8006e64:	08006479 	.word	0x08006479
 8006e68:	080063f9 	.word	0x080063f9
 8006e6c:	0801fd0c 	.word	0x0801fd0c

08006e70 <mqtt_disconnect>:
 * Disconnect from MQTT server
 * @param client MQTT client
 */
void
mqtt_disconnect(mqtt_client_t *client)
{
 8006e70:	b580      	push	{r7, lr}
 8006e72:	b082      	sub	sp, #8
 8006e74:	af00      	add	r7, sp, #0
 8006e76:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT_CORE_LOCKED();
  LWIP_ASSERT("mqtt_disconnect: client != NULL", client);
 8006e78:	687b      	ldr	r3, [r7, #4]
 8006e7a:	2b00      	cmp	r3, #0
 8006e7c:	d105      	bne.n	8006e8a <mqtt_disconnect+0x1a>
 8006e7e:	4b0b      	ldr	r3, [pc, #44]	; (8006eac <mqtt_disconnect+0x3c>)
 8006e80:	4a0b      	ldr	r2, [pc, #44]	; (8006eb0 <mqtt_disconnect+0x40>)
 8006e82:	490c      	ldr	r1, [pc, #48]	; (8006eb4 <mqtt_disconnect+0x44>)
 8006e84:	480c      	ldr	r0, [pc, #48]	; (8006eb8 <mqtt_disconnect+0x48>)
 8006e86:	f7fb f9ad 	bl	80021e4 <app_debug_rtt_raw>
  /* If connection in not already closed */
  if (client->conn_state != TCP_DISCONNECTED) {
 8006e8a:	687b      	ldr	r3, [r7, #4]
 8006e8c:	7a9b      	ldrb	r3, [r3, #10]
 8006e8e:	2b00      	cmp	r3, #0
 8006e90:	d007      	beq.n	8006ea2 <mqtt_disconnect+0x32>
    /* Set conn_state before calling mqtt_close to prevent callback from being called */
    client->conn_state = TCP_DISCONNECTED;
 8006e92:	687b      	ldr	r3, [r7, #4]
 8006e94:	2200      	movs	r2, #0
 8006e96:	729a      	strb	r2, [r3, #10]
    mqtt_close(client, (mqtt_connection_status_t)0);
 8006e98:	687b      	ldr	r3, [r7, #4]
 8006e9a:	2100      	movs	r1, #0
 8006e9c:	0018      	movs	r0, r3
 8006e9e:	f7fe fd31 	bl	8005904 <mqtt_close>
  }
}
 8006ea2:	46c0      	nop			; (mov r8, r8)
 8006ea4:	46bd      	mov	sp, r7
 8006ea6:	b002      	add	sp, #8
 8006ea8:	bd80      	pop	{r7, pc}
 8006eaa:	46c0      	nop			; (mov r8, r8)
 8006eac:	0801f5e8 	.word	0x0801f5e8
 8006eb0:	0000059f 	.word	0x0000059f
 8006eb4:	0801fd14 	.word	0x0801fd14
 8006eb8:	0801f654 	.word	0x0801f654

08006ebc <mqtt_client_is_connected>:
 * @param client MQTT client
 * @return 1 if connected to server, 0 otherwise
 */
u8_t
mqtt_client_is_connected(mqtt_client_t *client)
{
 8006ebc:	b580      	push	{r7, lr}
 8006ebe:	b082      	sub	sp, #8
 8006ec0:	af00      	add	r7, sp, #0
 8006ec2:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT_CORE_LOCKED();
  LWIP_ASSERT("mqtt_client_is_connected: client != NULL", client);
 8006ec4:	687b      	ldr	r3, [r7, #4]
 8006ec6:	2b00      	cmp	r3, #0
 8006ec8:	d105      	bne.n	8006ed6 <mqtt_client_is_connected+0x1a>
 8006eca:	4b08      	ldr	r3, [pc, #32]	; (8006eec <mqtt_client_is_connected+0x30>)
 8006ecc:	4a08      	ldr	r2, [pc, #32]	; (8006ef0 <mqtt_client_is_connected+0x34>)
 8006ece:	4909      	ldr	r1, [pc, #36]	; (8006ef4 <mqtt_client_is_connected+0x38>)
 8006ed0:	4809      	ldr	r0, [pc, #36]	; (8006ef8 <mqtt_client_is_connected+0x3c>)
 8006ed2:	f7fb f987 	bl	80021e4 <app_debug_rtt_raw>
  return client->conn_state == MQTT_CONNECTED;
 8006ed6:	687b      	ldr	r3, [r7, #4]
 8006ed8:	7a9b      	ldrb	r3, [r3, #10]
 8006eda:	3b03      	subs	r3, #3
 8006edc:	425a      	negs	r2, r3
 8006ede:	4153      	adcs	r3, r2
 8006ee0:	b2db      	uxtb	r3, r3
}
 8006ee2:	0018      	movs	r0, r3
 8006ee4:	46bd      	mov	sp, r7
 8006ee6:	b002      	add	sp, #8
 8006ee8:	bd80      	pop	{r7, pc}
 8006eea:	46c0      	nop			; (mov r8, r8)
 8006eec:	0801f5e8 	.word	0x0801f5e8
 8006ef0:	000005b2 	.word	0x000005b2
 8006ef4:	0801fd34 	.word	0x0801fd34
 8006ef8:	0801f654 	.word	0x0801f654

08006efc <sntp_process>:
/**
 * SNTP processing of received timestamp
 */
static void
sntp_process(const struct sntp_timestamps *timestamps)
{
 8006efc:	b580      	push	{r7, lr}
 8006efe:	b084      	sub	sp, #16
 8006f00:	af00      	add	r7, sp, #0
 8006f02:	6078      	str	r0, [r7, #4]
  s32_t sec;
  u32_t frac;

  sec  = (s32_t)lwip_ntohl(timestamps->xmit.sec);
 8006f04:	687b      	ldr	r3, [r7, #4]
 8006f06:	681b      	ldr	r3, [r3, #0]
 8006f08:	0018      	movs	r0, r3
 8006f0a:	f000 fa8f 	bl	800742c <lwip_htonl>
 8006f0e:	0003      	movs	r3, r0
 8006f10:	60fb      	str	r3, [r7, #12]
  frac = lwip_ntohl(timestamps->xmit.frac);
 8006f12:	687b      	ldr	r3, [r7, #4]
 8006f14:	685b      	ldr	r3, [r3, #4]
 8006f16:	0018      	movs	r0, r3
 8006f18:	f000 fa88 	bl	800742c <lwip_htonl>
 8006f1c:	0003      	movs	r3, r0
 8006f1e:	60bb      	str	r3, [r7, #8]
      frac = (u32_t)((u64_t)t4);
    }
  }
#endif /* SNTP_COMP_ROUNDTRIP */

  SNTP_SET_SYSTEM_TIME_NTP(sec, frac);
 8006f20:	68fb      	ldr	r3, [r7, #12]
 8006f22:	4a05      	ldr	r2, [pc, #20]	; (8006f38 <sntp_process+0x3c>)
 8006f24:	4694      	mov	ip, r2
 8006f26:	4463      	add	r3, ip
 8006f28:	0018      	movs	r0, r3
 8006f2a:	f7fa f809 	bl	8000f40 <lwip_sntp_recv_callback>
  LWIP_UNUSED_ARG(frac); /* might be unused if only seconds are set */
  LWIP_DEBUGF(SNTP_DEBUG_TRACE, ("sntp_process: %s, %" U32_F " us\n",
                                 sntp_format_time(sec), SNTP_FRAC_TO_US(frac)));
}
 8006f2e:	46c0      	nop			; (mov r8, r8)
 8006f30:	46bd      	mov	sp, r7
 8006f32:	b004      	add	sp, #16
 8006f34:	bd80      	pop	{r7, pc}
 8006f36:	46c0      	nop			; (mov r8, r8)
 8006f38:	7c558180 	.word	0x7c558180

08006f3c <sntp_initialize_request>:
/**
 * Initialize request struct to be sent to server.
 */
static void
sntp_initialize_request(struct sntp_msg *req)
{
 8006f3c:	b580      	push	{r7, lr}
 8006f3e:	b082      	sub	sp, #8
 8006f40:	af00      	add	r7, sp, #0
 8006f42:	6078      	str	r0, [r7, #4]
  memset(req, 0, SNTP_MSG_LEN);
 8006f44:	687b      	ldr	r3, [r7, #4]
 8006f46:	2230      	movs	r2, #48	; 0x30
 8006f48:	2100      	movs	r1, #0
 8006f4a:	0018      	movs	r0, r3
 8006f4c:	f017 f842 	bl	801dfd4 <memset>
  req->li_vn_mode = SNTP_LI_NO_WARNING | SNTP_VERSION | SNTP_MODE_CLIENT;
 8006f50:	687b      	ldr	r3, [r7, #4]
 8006f52:	2223      	movs	r2, #35	; 0x23
 8006f54:	701a      	strb	r2, [r3, #0]
# endif
    req->transmit_timestamp[0] = sec;
    req->transmit_timestamp[1] = frac;
  }
#endif /* SNTP_CHECK_RESPONSE >= 2 || SNTP_COMP_ROUNDTRIP */
}
 8006f56:	46c0      	nop			; (mov r8, r8)
 8006f58:	46bd      	mov	sp, r7
 8006f5a:	b002      	add	sp, #8
 8006f5c:	bd80      	pop	{r7, pc}
	...

08006f60 <sntp_retry>:
 *
 * @param arg is unused (only necessary to conform to sys_timeout)
 */
static void
sntp_retry(void *arg)
{
 8006f60:	b580      	push	{r7, lr}
 8006f62:	b084      	sub	sp, #16
 8006f64:	af00      	add	r7, sp, #0
 8006f66:	6078      	str	r0, [r7, #4]

  LWIP_DEBUGF(SNTP_DEBUG_STATE, ("sntp_retry: Next request will be sent in %"U32_F" ms\n",
                                 sntp_retry_timeout));

  /* set up a timer to send a retry and increase the retry delay */
  sys_untimeout(sntp_request, NULL);
 8006f68:	4b12      	ldr	r3, [pc, #72]	; (8006fb4 <sntp_retry+0x54>)
 8006f6a:	2100      	movs	r1, #0
 8006f6c:	0018      	movs	r0, r3
 8006f6e:	f00b fda1 	bl	8012ab4 <sys_untimeout>
  sys_timeout(sntp_retry_timeout, sntp_request, NULL);
 8006f72:	4b11      	ldr	r3, [pc, #68]	; (8006fb8 <sntp_retry+0x58>)
 8006f74:	681b      	ldr	r3, [r3, #0]
 8006f76:	490f      	ldr	r1, [pc, #60]	; (8006fb4 <sntp_retry+0x54>)
 8006f78:	2200      	movs	r2, #0
 8006f7a:	0018      	movs	r0, r3
 8006f7c:	f00b fd72 	bl	8012a64 <sys_timeout>

#if SNTP_RETRY_TIMEOUT_EXP
  {
    u32_t new_retry_timeout;
    /* increase the timeout for next retry */
    new_retry_timeout = sntp_retry_timeout << 1;
 8006f80:	4b0d      	ldr	r3, [pc, #52]	; (8006fb8 <sntp_retry+0x58>)
 8006f82:	681b      	ldr	r3, [r3, #0]
 8006f84:	005b      	lsls	r3, r3, #1
 8006f86:	60fb      	str	r3, [r7, #12]
    /* limit to maximum timeout and prevent overflow */
    if ((new_retry_timeout <= SNTP_RETRY_TIMEOUT_MAX) &&
 8006f88:	68fb      	ldr	r3, [r7, #12]
 8006f8a:	4a0c      	ldr	r2, [pc, #48]	; (8006fbc <sntp_retry+0x5c>)
 8006f8c:	4293      	cmp	r3, r2
 8006f8e:	d808      	bhi.n	8006fa2 <sntp_retry+0x42>
        (new_retry_timeout > sntp_retry_timeout)) {
 8006f90:	4b09      	ldr	r3, [pc, #36]	; (8006fb8 <sntp_retry+0x58>)
 8006f92:	681b      	ldr	r3, [r3, #0]
    if ((new_retry_timeout <= SNTP_RETRY_TIMEOUT_MAX) &&
 8006f94:	68fa      	ldr	r2, [r7, #12]
 8006f96:	429a      	cmp	r2, r3
 8006f98:	d903      	bls.n	8006fa2 <sntp_retry+0x42>
      sntp_retry_timeout = new_retry_timeout;
 8006f9a:	4b07      	ldr	r3, [pc, #28]	; (8006fb8 <sntp_retry+0x58>)
 8006f9c:	68fa      	ldr	r2, [r7, #12]
 8006f9e:	601a      	str	r2, [r3, #0]
 8006fa0:	e003      	b.n	8006faa <sntp_retry+0x4a>
    } else {
      sntp_retry_timeout = SNTP_RETRY_TIMEOUT_MAX;
 8006fa2:	4b05      	ldr	r3, [pc, #20]	; (8006fb8 <sntp_retry+0x58>)
 8006fa4:	4a05      	ldr	r2, [pc, #20]	; (8006fbc <sntp_retry+0x5c>)
 8006fa6:	601a      	str	r2, [r3, #0]
    }
  }
#endif /* SNTP_RETRY_TIMEOUT_EXP */
}
 8006fa8:	46c0      	nop			; (mov r8, r8)
 8006faa:	46c0      	nop			; (mov r8, r8)
 8006fac:	46bd      	mov	sp, r7
 8006fae:	b004      	add	sp, #16
 8006fb0:	bd80      	pop	{r7, pc}
 8006fb2:	46c0      	nop			; (mov r8, r8)
 8006fb4:	080071f1 	.word	0x080071f1
 8006fb8:	20000a2c 	.word	0x20000a2c
 8006fbc:	000249f0 	.word	0x000249f0

08006fc0 <sntp_recv>:
#endif /* SNTP_SUPPORT_MULTIPLE_SERVERS */

/** UDP recv callback for the sntp pcb */
static void
sntp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr, u16_t port)
{
 8006fc0:	b5b0      	push	{r4, r5, r7, lr}
 8006fc2:	b088      	sub	sp, #32
 8006fc4:	af00      	add	r7, sp, #0
 8006fc6:	60f8      	str	r0, [r7, #12]
 8006fc8:	60b9      	str	r1, [r7, #8]
 8006fca:	607a      	str	r2, [r7, #4]
 8006fcc:	603b      	str	r3, [r7, #0]
  err_t err;

  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);

  err = ERR_ARG;
 8006fce:	231f      	movs	r3, #31
 8006fd0:	18fb      	adds	r3, r7, r3
 8006fd2:	22f0      	movs	r2, #240	; 0xf0
 8006fd4:	701a      	strb	r2, [r3, #0]
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
#endif /* SNTP_CHECK_RESPONSE >= 1 */
  {
    /* process the response */
    if (p->tot_len == SNTP_MSG_LEN) {
 8006fd6:	687b      	ldr	r3, [r7, #4]
 8006fd8:	891b      	ldrh	r3, [r3, #8]
 8006fda:	2b30      	cmp	r3, #48	; 0x30
 8006fdc:	d13e      	bne.n	800705c <sntp_recv+0x9c>
      mode = pbuf_get_at(p, SNTP_OFFSET_LI_VN_MODE) & SNTP_MODE_MASK;
 8006fde:	687b      	ldr	r3, [r7, #4]
 8006fe0:	2100      	movs	r1, #0
 8006fe2:	0018      	movs	r0, r3
 8006fe4:	f003 ff94 	bl	800af10 <pbuf_get_at>
 8006fe8:	0003      	movs	r3, r0
 8006fea:	0019      	movs	r1, r3
 8006fec:	201e      	movs	r0, #30
 8006fee:	183b      	adds	r3, r7, r0
 8006ff0:	2207      	movs	r2, #7
 8006ff2:	400a      	ands	r2, r1
 8006ff4:	701a      	strb	r2, [r3, #0]
      /* if this is a SNTP response... */
      if (((sntp_opmode == SNTP_OPMODE_POLL)       && (mode == SNTP_MODE_SERVER)) ||
 8006ff6:	4b3a      	ldr	r3, [pc, #232]	; (80070e0 <sntp_recv+0x120>)
 8006ff8:	781b      	ldrb	r3, [r3, #0]
 8006ffa:	2b00      	cmp	r3, #0
 8006ffc:	d103      	bne.n	8007006 <sntp_recv+0x46>
 8006ffe:	183b      	adds	r3, r7, r0
 8007000:	781b      	ldrb	r3, [r3, #0]
 8007002:	2b04      	cmp	r3, #4
 8007004:	d008      	beq.n	8007018 <sntp_recv+0x58>
          ((sntp_opmode == SNTP_OPMODE_LISTENONLY) && (mode == SNTP_MODE_BROADCAST))) {
 8007006:	4b36      	ldr	r3, [pc, #216]	; (80070e0 <sntp_recv+0x120>)
 8007008:	781b      	ldrb	r3, [r3, #0]
      if (((sntp_opmode == SNTP_OPMODE_POLL)       && (mode == SNTP_MODE_SERVER)) ||
 800700a:	2b01      	cmp	r3, #1
 800700c:	d122      	bne.n	8007054 <sntp_recv+0x94>
          ((sntp_opmode == SNTP_OPMODE_LISTENONLY) && (mode == SNTP_MODE_BROADCAST))) {
 800700e:	231e      	movs	r3, #30
 8007010:	18fb      	adds	r3, r7, r3
 8007012:	781b      	ldrb	r3, [r3, #0]
 8007014:	2b05      	cmp	r3, #5
 8007016:	d11d      	bne.n	8007054 <sntp_recv+0x94>
        stratum = pbuf_get_at(p, SNTP_OFFSET_STRATUM);
 8007018:	251d      	movs	r5, #29
 800701a:	197c      	adds	r4, r7, r5
 800701c:	687b      	ldr	r3, [r7, #4]
 800701e:	2101      	movs	r1, #1
 8007020:	0018      	movs	r0, r3
 8007022:	f003 ff75 	bl	800af10 <pbuf_get_at>
 8007026:	0003      	movs	r3, r0
 8007028:	7023      	strb	r3, [r4, #0]

        if (stratum == SNTP_STRATUM_KOD) {
 800702a:	197b      	adds	r3, r7, r5
 800702c:	781b      	ldrb	r3, [r3, #0]
 800702e:	2b00      	cmp	r3, #0
 8007030:	d104      	bne.n	800703c <sntp_recv+0x7c>
          /* Kiss-of-death packet. Use another server or increase UPDATE_DELAY. */
          err = SNTP_ERR_KOD;
 8007032:	231f      	movs	r3, #31
 8007034:	18fb      	adds	r3, r7, r3
 8007036:	2201      	movs	r2, #1
 8007038:	701a      	strb	r2, [r3, #0]
        if (stratum == SNTP_STRATUM_KOD) {
 800703a:	e00f      	b.n	800705c <sntp_recv+0x9c>
          LWIP_DEBUGF(SNTP_DEBUG_STATE, ("sntp_recv: Received Kiss-of-Death\n"));
        } else {
          pbuf_copy_partial(p, &timestamps, sizeof(timestamps), SNTP_OFFSET_TIMESTAMPS);
 800703c:	2310      	movs	r3, #16
 800703e:	18f9      	adds	r1, r7, r3
 8007040:	6878      	ldr	r0, [r7, #4]
 8007042:	2328      	movs	r3, #40	; 0x28
 8007044:	2208      	movs	r2, #8
 8007046:	f003 fd13 	bl	800aa70 <pbuf_copy_partial>
          } else
#endif /* SNTP_CHECK_RESPONSE >= 2 */
            /* @todo: add code for SNTP_CHECK_RESPONSE >= 3 and >= 4 here */
          {
            /* correct answer */
            err = ERR_OK;
 800704a:	231f      	movs	r3, #31
 800704c:	18fb      	adds	r3, r7, r3
 800704e:	2200      	movs	r2, #0
 8007050:	701a      	strb	r2, [r3, #0]
        if (stratum == SNTP_STRATUM_KOD) {
 8007052:	e003      	b.n	800705c <sntp_recv+0x9c>
          }
        }
      } else {
        LWIP_DEBUGF(SNTP_DEBUG_WARN, ("sntp_recv: Invalid mode in response: %"U16_F"\n", (u16_t)mode));
        /* wait for correct response */
        err = ERR_TIMEOUT;
 8007054:	231f      	movs	r3, #31
 8007056:	18fb      	adds	r3, r7, r3
 8007058:	22fd      	movs	r2, #253	; 0xfd
 800705a:	701a      	strb	r2, [r3, #0]
    /* packet from wrong remote address or port, wait for correct response */
    err = ERR_TIMEOUT;
  }
#endif /* SNTP_CHECK_RESPONSE >= 1 */

  pbuf_free(p);
 800705c:	687b      	ldr	r3, [r7, #4]
 800705e:	0018      	movs	r0, r3
 8007060:	f003 fa3c 	bl	800a4dc <pbuf_free>

  if (err == ERR_OK) {
 8007064:	231f      	movs	r3, #31
 8007066:	18fb      	adds	r3, r7, r3
 8007068:	781b      	ldrb	r3, [r3, #0]
 800706a:	b25b      	sxtb	r3, r3
 800706c:	2b00      	cmp	r3, #0
 800706e:	d125      	bne.n	80070bc <sntp_recv+0xfc>
    /* correct packet received: process it it */
    sntp_process(&timestamps);
 8007070:	2310      	movs	r3, #16
 8007072:	18fb      	adds	r3, r7, r3
 8007074:	0018      	movs	r0, r3
 8007076:	f7ff ff41 	bl	8006efc <sntp_process>

#if SNTP_MONITOR_SERVER_REACHABILITY
    /* indicate that server responded */
    sntp_servers[sntp_current_server].reachability |= 1;
 800707a:	4b1a      	ldr	r3, [pc, #104]	; (80070e4 <sntp_recv+0x124>)
 800707c:	7a1b      	ldrb	r3, [r3, #8]
 800707e:	2201      	movs	r2, #1
 8007080:	4313      	orrs	r3, r2
 8007082:	b2da      	uxtb	r2, r3
 8007084:	4b17      	ldr	r3, [pc, #92]	; (80070e4 <sntp_recv+0x124>)
 8007086:	721a      	strb	r2, [r3, #8]
#endif /* SNTP_MONITOR_SERVER_REACHABILITY */
    /* Set up timeout for next request (only if poll response was received)*/
    if (sntp_opmode == SNTP_OPMODE_POLL) {
 8007088:	4b15      	ldr	r3, [pc, #84]	; (80070e0 <sntp_recv+0x120>)
 800708a:	781b      	ldrb	r3, [r3, #0]
 800708c:	2b00      	cmp	r3, #0
 800708e:	d122      	bne.n	80070d6 <sntp_recv+0x116>
      u32_t sntp_update_delay;
      sys_untimeout(sntp_try_next_server, NULL);
 8007090:	4b15      	ldr	r3, [pc, #84]	; (80070e8 <sntp_recv+0x128>)
 8007092:	2100      	movs	r1, #0
 8007094:	0018      	movs	r0, r3
 8007096:	f00b fd0d 	bl	8012ab4 <sys_untimeout>
      sys_untimeout(sntp_request, NULL);
 800709a:	4b14      	ldr	r3, [pc, #80]	; (80070ec <sntp_recv+0x12c>)
 800709c:	2100      	movs	r1, #0
 800709e:	0018      	movs	r0, r3
 80070a0:	f00b fd08 	bl	8012ab4 <sys_untimeout>

      /* Correct response, reset retry timeout */
      SNTP_RESET_RETRY_TIMEOUT();
 80070a4:	4b12      	ldr	r3, [pc, #72]	; (80070f0 <sntp_recv+0x130>)
 80070a6:	4a13      	ldr	r2, [pc, #76]	; (80070f4 <sntp_recv+0x134>)
 80070a8:	601a      	str	r2, [r3, #0]

      sntp_update_delay = (u32_t)SNTP_UPDATE_DELAY;
 80070aa:	4b13      	ldr	r3, [pc, #76]	; (80070f8 <sntp_recv+0x138>)
 80070ac:	61bb      	str	r3, [r7, #24]
      sys_timeout(sntp_update_delay, sntp_request, NULL);
 80070ae:	490f      	ldr	r1, [pc, #60]	; (80070ec <sntp_recv+0x12c>)
 80070b0:	69bb      	ldr	r3, [r7, #24]
 80070b2:	2200      	movs	r2, #0
 80070b4:	0018      	movs	r0, r3
 80070b6:	f00b fcd5 	bl	8012a64 <sys_timeout>
      sntp_try_next_server(NULL);
    }
  } else {
    /* ignore any broken packet, poll mode: retry after timeout to avoid flooding */
  }
}
 80070ba:	e00c      	b.n	80070d6 <sntp_recv+0x116>
  } else if (err == SNTP_ERR_KOD) {
 80070bc:	231f      	movs	r3, #31
 80070be:	18fb      	adds	r3, r7, r3
 80070c0:	781b      	ldrb	r3, [r3, #0]
 80070c2:	b25b      	sxtb	r3, r3
 80070c4:	2b01      	cmp	r3, #1
 80070c6:	d106      	bne.n	80070d6 <sntp_recv+0x116>
    if (sntp_opmode == SNTP_OPMODE_POLL) {
 80070c8:	4b05      	ldr	r3, [pc, #20]	; (80070e0 <sntp_recv+0x120>)
 80070ca:	781b      	ldrb	r3, [r3, #0]
 80070cc:	2b00      	cmp	r3, #0
 80070ce:	d102      	bne.n	80070d6 <sntp_recv+0x116>
      sntp_try_next_server(NULL);
 80070d0:	2000      	movs	r0, #0
 80070d2:	f7ff ff45 	bl	8006f60 <sntp_retry>
}
 80070d6:	46c0      	nop			; (mov r8, r8)
 80070d8:	46bd      	mov	sp, r7
 80070da:	b008      	add	sp, #32
 80070dc:	bdb0      	pop	{r4, r5, r7, pc}
 80070de:	46c0      	nop			; (mov r8, r8)
 80070e0:	20000a18 	.word	0x20000a18
 80070e4:	20000a20 	.word	0x20000a20
 80070e8:	08006f61 	.word	0x08006f61
 80070ec:	080071f1 	.word	0x080071f1
 80070f0:	20000a2c 	.word	0x20000a2c
 80070f4:	00003a98 	.word	0x00003a98
 80070f8:	0036ee80 	.word	0x0036ee80

080070fc <sntp_send_request>:
 *
 * @param server_addr resolved IP address of the SNTP server
 */
static void
sntp_send_request(const ip_addr_t *server_addr)
{
 80070fc:	b580      	push	{r7, lr}
 80070fe:	b084      	sub	sp, #16
 8007100:	af00      	add	r7, sp, #0
 8007102:	6078      	str	r0, [r7, #4]
  struct pbuf *p;

  LWIP_ASSERT("server_addr != NULL", server_addr != NULL);
 8007104:	687b      	ldr	r3, [r7, #4]
 8007106:	2b00      	cmp	r3, #0
 8007108:	d105      	bne.n	8007116 <sntp_send_request+0x1a>
 800710a:	4b22      	ldr	r3, [pc, #136]	; (8007194 <sntp_send_request+0x98>)
 800710c:	4a22      	ldr	r2, [pc, #136]	; (8007198 <sntp_send_request+0x9c>)
 800710e:	4923      	ldr	r1, [pc, #140]	; (800719c <sntp_send_request+0xa0>)
 8007110:	4823      	ldr	r0, [pc, #140]	; (80071a0 <sntp_send_request+0xa4>)
 8007112:	f7fb f867 	bl	80021e4 <app_debug_rtt_raw>

  p = pbuf_alloc(PBUF_TRANSPORT, SNTP_MSG_LEN, PBUF_RAM);
 8007116:	23a0      	movs	r3, #160	; 0xa0
 8007118:	009b      	lsls	r3, r3, #2
 800711a:	001a      	movs	r2, r3
 800711c:	2130      	movs	r1, #48	; 0x30
 800711e:	2038      	movs	r0, #56	; 0x38
 8007120:	f002 fea6 	bl	8009e70 <pbuf_alloc>
 8007124:	0003      	movs	r3, r0
 8007126:	60fb      	str	r3, [r7, #12]
  if (p != NULL) {
 8007128:	68fb      	ldr	r3, [r7, #12]
 800712a:	2b00      	cmp	r3, #0
 800712c:	d023      	beq.n	8007176 <sntp_send_request+0x7a>
    struct sntp_msg *sntpmsg = (struct sntp_msg *)p->payload;
 800712e:	68fb      	ldr	r3, [r7, #12]
 8007130:	685b      	ldr	r3, [r3, #4]
 8007132:	60bb      	str	r3, [r7, #8]
    LWIP_DEBUGF(SNTP_DEBUG_STATE, ("sntp_send_request: Sending request to server\n"));
    /* initialize request message */
    sntp_initialize_request(sntpmsg);
 8007134:	68bb      	ldr	r3, [r7, #8]
 8007136:	0018      	movs	r0, r3
 8007138:	f7ff ff00 	bl	8006f3c <sntp_initialize_request>
    /* send request */
    udp_sendto(sntp_pcb, p, server_addr, SNTP_PORT);
 800713c:	4b19      	ldr	r3, [pc, #100]	; (80071a4 <sntp_send_request+0xa8>)
 800713e:	6818      	ldr	r0, [r3, #0]
 8007140:	687a      	ldr	r2, [r7, #4]
 8007142:	68f9      	ldr	r1, [r7, #12]
 8007144:	237b      	movs	r3, #123	; 0x7b
 8007146:	f00b ff4d 	bl	8012fe4 <udp_sendto>
    /* free the pbuf after sending it */
    pbuf_free(p);
 800714a:	68fb      	ldr	r3, [r7, #12]
 800714c:	0018      	movs	r0, r3
 800714e:	f003 f9c5 	bl	800a4dc <pbuf_free>
#if SNTP_MONITOR_SERVER_REACHABILITY
    /* indicate new packet has been sent */
    sntp_servers[sntp_current_server].reachability <<= 1;
 8007152:	4b15      	ldr	r3, [pc, #84]	; (80071a8 <sntp_send_request+0xac>)
 8007154:	7a1b      	ldrb	r3, [r3, #8]
 8007156:	18db      	adds	r3, r3, r3
 8007158:	b2da      	uxtb	r2, r3
 800715a:	4b13      	ldr	r3, [pc, #76]	; (80071a8 <sntp_send_request+0xac>)
 800715c:	721a      	strb	r2, [r3, #8]
#endif /* SNTP_MONITOR_SERVER_REACHABILITY */
    /* set up receive timeout: try next server or retry on timeout */
    sys_untimeout(sntp_try_next_server, NULL);
 800715e:	4b13      	ldr	r3, [pc, #76]	; (80071ac <sntp_send_request+0xb0>)
 8007160:	2100      	movs	r1, #0
 8007162:	0018      	movs	r0, r3
 8007164:	f00b fca6 	bl	8012ab4 <sys_untimeout>
    sys_timeout((u32_t)SNTP_RECV_TIMEOUT, sntp_try_next_server, NULL);
 8007168:	4b10      	ldr	r3, [pc, #64]	; (80071ac <sntp_send_request+0xb0>)
 800716a:	4811      	ldr	r0, [pc, #68]	; (80071b0 <sntp_send_request+0xb4>)
 800716c:	2200      	movs	r2, #0
 800716e:	0019      	movs	r1, r3
 8007170:	f00b fc78 	bl	8012a64 <sys_timeout>
                                     (u32_t)SNTP_RETRY_TIMEOUT));
    /* out of memory: set up a timer to send a retry */
    sys_untimeout(sntp_request, NULL);
    sys_timeout((u32_t)SNTP_RETRY_TIMEOUT, sntp_request, NULL);
  }
}
 8007174:	e00a      	b.n	800718c <sntp_send_request+0x90>
    sys_untimeout(sntp_request, NULL);
 8007176:	4b0f      	ldr	r3, [pc, #60]	; (80071b4 <sntp_send_request+0xb8>)
 8007178:	2100      	movs	r1, #0
 800717a:	0018      	movs	r0, r3
 800717c:	f00b fc9a 	bl	8012ab4 <sys_untimeout>
    sys_timeout((u32_t)SNTP_RETRY_TIMEOUT, sntp_request, NULL);
 8007180:	4b0c      	ldr	r3, [pc, #48]	; (80071b4 <sntp_send_request+0xb8>)
 8007182:	480b      	ldr	r0, [pc, #44]	; (80071b0 <sntp_send_request+0xb4>)
 8007184:	2200      	movs	r2, #0
 8007186:	0019      	movs	r1, r3
 8007188:	f00b fc6c 	bl	8012a64 <sys_timeout>
}
 800718c:	46c0      	nop			; (mov r8, r8)
 800718e:	46bd      	mov	sp, r7
 8007190:	b004      	add	sp, #16
 8007192:	bd80      	pop	{r7, pc}
 8007194:	0801fd60 	.word	0x0801fd60
 8007198:	00000223 	.word	0x00000223
 800719c:	0801fd8c 	.word	0x0801fd8c
 80071a0:	0801fda0 	.word	0x0801fda0
 80071a4:	20000a1c 	.word	0x20000a1c
 80071a8:	20000a20 	.word	0x20000a20
 80071ac:	08006f61 	.word	0x08006f61
 80071b0:	00003a98 	.word	0x00003a98
 80071b4:	080071f1 	.word	0x080071f1

080071b8 <sntp_dns_found>:
/**
 * DNS found callback when using DNS names as server address.
 */
static void
sntp_dns_found(const char *hostname, const ip_addr_t *ipaddr, void *arg)
{
 80071b8:	b580      	push	{r7, lr}
 80071ba:	b084      	sub	sp, #16
 80071bc:	af00      	add	r7, sp, #0
 80071be:	60f8      	str	r0, [r7, #12]
 80071c0:	60b9      	str	r1, [r7, #8]
 80071c2:	607a      	str	r2, [r7, #4]
  LWIP_UNUSED_ARG(hostname);
  LWIP_UNUSED_ARG(arg);

  if (ipaddr != NULL) {
 80071c4:	68bb      	ldr	r3, [r7, #8]
 80071c6:	2b00      	cmp	r3, #0
 80071c8:	d008      	beq.n	80071dc <sntp_dns_found+0x24>
    /* Address resolved, send request */
    LWIP_DEBUGF(SNTP_DEBUG_STATE, ("sntp_dns_found: Server address resolved, sending request\n"));
    sntp_servers[sntp_current_server].addr = *ipaddr;
 80071ca:	4b08      	ldr	r3, [pc, #32]	; (80071ec <sntp_dns_found+0x34>)
 80071cc:	68ba      	ldr	r2, [r7, #8]
 80071ce:	6812      	ldr	r2, [r2, #0]
 80071d0:	605a      	str	r2, [r3, #4]
    sntp_send_request(ipaddr);
 80071d2:	68bb      	ldr	r3, [r7, #8]
 80071d4:	0018      	movs	r0, r3
 80071d6:	f7ff ff91 	bl	80070fc <sntp_send_request>
  } else {
    /* DNS resolving failed -> try another server */
    LWIP_DEBUGF(SNTP_DEBUG_WARN_STATE, ("sntp_dns_found: Failed to resolve server address resolved, trying next server\n"));
    sntp_try_next_server(NULL);
  }
}
 80071da:	e002      	b.n	80071e2 <sntp_dns_found+0x2a>
    sntp_try_next_server(NULL);
 80071dc:	2000      	movs	r0, #0
 80071de:	f7ff febf 	bl	8006f60 <sntp_retry>
}
 80071e2:	46c0      	nop			; (mov r8, r8)
 80071e4:	46bd      	mov	sp, r7
 80071e6:	b004      	add	sp, #16
 80071e8:	bd80      	pop	{r7, pc}
 80071ea:	46c0      	nop			; (mov r8, r8)
 80071ec:	20000a20 	.word	0x20000a20

080071f0 <sntp_request>:
 *
 * @param arg is unused (only necessary to conform to sys_timeout)
 */
static void
sntp_request(void *arg)
{
 80071f0:	b5b0      	push	{r4, r5, r7, lr}
 80071f2:	b084      	sub	sp, #16
 80071f4:	af00      	add	r7, sp, #0
 80071f6:	6078      	str	r0, [r7, #4]

  LWIP_UNUSED_ARG(arg);

  /* initialize SNTP server address */
#if SNTP_SERVER_DNS
  if (sntp_servers[sntp_current_server].name) {
 80071f8:	4b24      	ldr	r3, [pc, #144]	; (800728c <sntp_request+0x9c>)
 80071fa:	681b      	ldr	r3, [r3, #0]
 80071fc:	2b00      	cmp	r3, #0
 80071fe:	d01c      	beq.n	800723a <sntp_request+0x4a>
    /* always resolve the name and rely on dns-internal caching & timeout */
    ip_addr_set_zero(&sntp_servers[sntp_current_server].addr);
 8007200:	4b22      	ldr	r3, [pc, #136]	; (800728c <sntp_request+0x9c>)
 8007202:	2200      	movs	r2, #0
 8007204:	605a      	str	r2, [r3, #4]
    err = dns_gethostbyname(sntp_servers[sntp_current_server].name, &sntp_server_address,
 8007206:	4b21      	ldr	r3, [pc, #132]	; (800728c <sntp_request+0x9c>)
 8007208:	6818      	ldr	r0, [r3, #0]
 800720a:	250f      	movs	r5, #15
 800720c:	197c      	adds	r4, r7, r5
 800720e:	4a20      	ldr	r2, [pc, #128]	; (8007290 <sntp_request+0xa0>)
 8007210:	2308      	movs	r3, #8
 8007212:	18f9      	adds	r1, r7, r3
 8007214:	2300      	movs	r3, #0
 8007216:	f001 fa1b 	bl	8008650 <dns_gethostbyname>
 800721a:	0003      	movs	r3, r0
 800721c:	7023      	strb	r3, [r4, #0]
                            sntp_dns_found, NULL);
    if (err == ERR_INPROGRESS) {
 800721e:	197b      	adds	r3, r7, r5
 8007220:	781b      	ldrb	r3, [r3, #0]
 8007222:	b25b      	sxtb	r3, r3
 8007224:	3305      	adds	r3, #5
 8007226:	d02d      	beq.n	8007284 <sntp_request+0x94>
      /* DNS request sent, wait for sntp_dns_found being called */
      LWIP_DEBUGF(SNTP_DEBUG_STATE, ("sntp_request: Waiting for server address to be resolved.\n"));
      return;
    } else if (err == ERR_OK) {
 8007228:	197b      	adds	r3, r7, r5
 800722a:	781b      	ldrb	r3, [r3, #0]
 800722c:	b25b      	sxtb	r3, r3
 800722e:	2b00      	cmp	r3, #0
 8007230:	d110      	bne.n	8007254 <sntp_request+0x64>
      sntp_servers[sntp_current_server].addr = sntp_server_address;
 8007232:	4b16      	ldr	r3, [pc, #88]	; (800728c <sntp_request+0x9c>)
 8007234:	68ba      	ldr	r2, [r7, #8]
 8007236:	605a      	str	r2, [r3, #4]
 8007238:	e00c      	b.n	8007254 <sntp_request+0x64>
    }
  } else
#endif /* SNTP_SERVER_DNS */
  {
    sntp_server_address = sntp_servers[sntp_current_server].addr;
 800723a:	4b14      	ldr	r3, [pc, #80]	; (800728c <sntp_request+0x9c>)
 800723c:	685b      	ldr	r3, [r3, #4]
 800723e:	60bb      	str	r3, [r7, #8]
    err = (ip_addr_isany_val(sntp_server_address)) ? ERR_ARG : ERR_OK;
 8007240:	68bb      	ldr	r3, [r7, #8]
 8007242:	2b00      	cmp	r3, #0
 8007244:	d102      	bne.n	800724c <sntp_request+0x5c>
 8007246:	2310      	movs	r3, #16
 8007248:	425a      	negs	r2, r3
 800724a:	e000      	b.n	800724e <sntp_request+0x5e>
 800724c:	2200      	movs	r2, #0
 800724e:	230f      	movs	r3, #15
 8007250:	18fb      	adds	r3, r7, r3
 8007252:	701a      	strb	r2, [r3, #0]
  }

  if (err == ERR_OK) {
 8007254:	230f      	movs	r3, #15
 8007256:	18fb      	adds	r3, r7, r3
 8007258:	781b      	ldrb	r3, [r3, #0]
 800725a:	b25b      	sxtb	r3, r3
 800725c:	2b00      	cmp	r3, #0
 800725e:	d105      	bne.n	800726c <sntp_request+0x7c>
    LWIP_DEBUGF(SNTP_DEBUG_TRACE, ("sntp_request: current server address is %s\n",
                                   ipaddr_ntoa(&sntp_server_address)));
    sntp_send_request(&sntp_server_address);
 8007260:	2308      	movs	r3, #8
 8007262:	18fb      	adds	r3, r7, r3
 8007264:	0018      	movs	r0, r3
 8007266:	f7ff ff49 	bl	80070fc <sntp_send_request>
 800726a:	e00c      	b.n	8007286 <sntp_request+0x96>
  } else {
    /* address conversion failed, try another server */
    LWIP_DEBUGF(SNTP_DEBUG_WARN_STATE, ("sntp_request: Invalid server address, trying next server.\n"));
    sys_untimeout(sntp_try_next_server, NULL);
 800726c:	4b09      	ldr	r3, [pc, #36]	; (8007294 <sntp_request+0xa4>)
 800726e:	2100      	movs	r1, #0
 8007270:	0018      	movs	r0, r3
 8007272:	f00b fc1f 	bl	8012ab4 <sys_untimeout>
    sys_timeout((u32_t)SNTP_RETRY_TIMEOUT, sntp_try_next_server, NULL);
 8007276:	4b07      	ldr	r3, [pc, #28]	; (8007294 <sntp_request+0xa4>)
 8007278:	4807      	ldr	r0, [pc, #28]	; (8007298 <sntp_request+0xa8>)
 800727a:	2200      	movs	r2, #0
 800727c:	0019      	movs	r1, r3
 800727e:	f00b fbf1 	bl	8012a64 <sys_timeout>
 8007282:	e000      	b.n	8007286 <sntp_request+0x96>
      return;
 8007284:	46c0      	nop			; (mov r8, r8)
  }
}
 8007286:	46bd      	mov	sp, r7
 8007288:	b004      	add	sp, #16
 800728a:	bdb0      	pop	{r4, r5, r7, pc}
 800728c:	20000a20 	.word	0x20000a20
 8007290:	080071b9 	.word	0x080071b9
 8007294:	08006f61 	.word	0x08006f61
 8007298:	00003a98 	.word	0x00003a98

0800729c <sntp_init>:
 * Initialize this module.
 * Send out request instantly or after SNTP_STARTUP_DELAY(_FUNC).
 */
void
sntp_init(void)
{
 800729c:	b580      	push	{r7, lr}
 800729e:	af00      	add	r7, sp, #0
#else
#error SNTP_SERVER_ADDRESS string not supported SNTP_SERVER_DNS==0
#endif
#endif /* SNTP_SERVER_ADDRESS */

  if (sntp_pcb == NULL) {
 80072a0:	4b25      	ldr	r3, [pc, #148]	; (8007338 <sntp_init+0x9c>)
 80072a2:	681b      	ldr	r3, [r3, #0]
 80072a4:	2b00      	cmp	r3, #0
 80072a6:	d144      	bne.n	8007332 <sntp_init+0x96>
    sntp_pcb = udp_new_ip_type(IPADDR_TYPE_ANY);
 80072a8:	202e      	movs	r0, #46	; 0x2e
 80072aa:	f00c fa12 	bl	80136d2 <udp_new_ip_type>
 80072ae:	0002      	movs	r2, r0
 80072b0:	4b21      	ldr	r3, [pc, #132]	; (8007338 <sntp_init+0x9c>)
 80072b2:	601a      	str	r2, [r3, #0]
    LWIP_ASSERT("Failed to allocate udp pcb for sntp client", sntp_pcb != NULL);
 80072b4:	4b20      	ldr	r3, [pc, #128]	; (8007338 <sntp_init+0x9c>)
 80072b6:	681b      	ldr	r3, [r3, #0]
 80072b8:	2b00      	cmp	r3, #0
 80072ba:	d105      	bne.n	80072c8 <sntp_init+0x2c>
 80072bc:	4b1f      	ldr	r3, [pc, #124]	; (800733c <sntp_init+0xa0>)
 80072be:	4a20      	ldr	r2, [pc, #128]	; (8007340 <sntp_init+0xa4>)
 80072c0:	4920      	ldr	r1, [pc, #128]	; (8007344 <sntp_init+0xa8>)
 80072c2:	4821      	ldr	r0, [pc, #132]	; (8007348 <sntp_init+0xac>)
 80072c4:	f7fa ff8e 	bl	80021e4 <app_debug_rtt_raw>
    if (sntp_pcb != NULL) {
 80072c8:	4b1b      	ldr	r3, [pc, #108]	; (8007338 <sntp_init+0x9c>)
 80072ca:	681b      	ldr	r3, [r3, #0]
 80072cc:	2b00      	cmp	r3, #0
 80072ce:	d030      	beq.n	8007332 <sntp_init+0x96>
      udp_recv(sntp_pcb, sntp_recv, NULL);
 80072d0:	4b19      	ldr	r3, [pc, #100]	; (8007338 <sntp_init+0x9c>)
 80072d2:	681b      	ldr	r3, [r3, #0]
 80072d4:	491d      	ldr	r1, [pc, #116]	; (800734c <sntp_init+0xb0>)
 80072d6:	2200      	movs	r2, #0
 80072d8:	0018      	movs	r0, r3
 80072da:	f00c f98b 	bl	80135f4 <udp_recv>

      if (sntp_opmode == SNTP_OPMODE_POLL) {
 80072de:	4b1c      	ldr	r3, [pc, #112]	; (8007350 <sntp_init+0xb4>)
 80072e0:	781b      	ldrb	r3, [r3, #0]
 80072e2:	2b00      	cmp	r3, #0
 80072e4:	d111      	bne.n	800730a <sntp_init+0x6e>
        SNTP_RESET_RETRY_TIMEOUT();
 80072e6:	4b1b      	ldr	r3, [pc, #108]	; (8007354 <sntp_init+0xb8>)
 80072e8:	4a1b      	ldr	r2, [pc, #108]	; (8007358 <sntp_init+0xbc>)
 80072ea:	601a      	str	r2, [r3, #0]
#if SNTP_STARTUP_DELAY
        sys_timeout((u32_t)SNTP_STARTUP_DELAY_FUNC, sntp_request, NULL);
 80072ec:	f016 fdf8 	bl	801dee0 <sys_rand>
 80072f0:	0003      	movs	r3, r0
 80072f2:	491a      	ldr	r1, [pc, #104]	; (800735c <sntp_init+0xc0>)
 80072f4:	0018      	movs	r0, r3
 80072f6:	f7f8 ffa9 	bl	800024c <__aeabi_uidivmod>
 80072fa:	000b      	movs	r3, r1
 80072fc:	0018      	movs	r0, r3
 80072fe:	4b18      	ldr	r3, [pc, #96]	; (8007360 <sntp_init+0xc4>)
 8007300:	2200      	movs	r2, #0
 8007302:	0019      	movs	r1, r3
 8007304:	f00b fbae 	bl	8012a64 <sys_timeout>
        ip_set_option(sntp_pcb, SOF_BROADCAST);
        udp_bind(sntp_pcb, IP_ANY_TYPE, SNTP_PORT);
      }
    }
  }
}
 8007308:	e013      	b.n	8007332 <sntp_init+0x96>
      } else if (sntp_opmode == SNTP_OPMODE_LISTENONLY) {
 800730a:	4b11      	ldr	r3, [pc, #68]	; (8007350 <sntp_init+0xb4>)
 800730c:	781b      	ldrb	r3, [r3, #0]
 800730e:	2b01      	cmp	r3, #1
 8007310:	d10f      	bne.n	8007332 <sntp_init+0x96>
        ip_set_option(sntp_pcb, SOF_BROADCAST);
 8007312:	4b09      	ldr	r3, [pc, #36]	; (8007338 <sntp_init+0x9c>)
 8007314:	681b      	ldr	r3, [r3, #0]
 8007316:	7a5a      	ldrb	r2, [r3, #9]
 8007318:	4b07      	ldr	r3, [pc, #28]	; (8007338 <sntp_init+0x9c>)
 800731a:	681b      	ldr	r3, [r3, #0]
 800731c:	2120      	movs	r1, #32
 800731e:	430a      	orrs	r2, r1
 8007320:	b2d2      	uxtb	r2, r2
 8007322:	725a      	strb	r2, [r3, #9]
        udp_bind(sntp_pcb, IP_ANY_TYPE, SNTP_PORT);
 8007324:	4b04      	ldr	r3, [pc, #16]	; (8007338 <sntp_init+0x9c>)
 8007326:	681b      	ldr	r3, [r3, #0]
 8007328:	490e      	ldr	r1, [pc, #56]	; (8007364 <sntp_init+0xc8>)
 800732a:	227b      	movs	r2, #123	; 0x7b
 800732c:	0018      	movs	r0, r3
 800732e:	f00c f8c9 	bl	80134c4 <udp_bind>
}
 8007332:	46c0      	nop			; (mov r8, r8)
 8007334:	46bd      	mov	sp, r7
 8007336:	bd80      	pop	{r7, pc}
 8007338:	20000a1c 	.word	0x20000a1c
 800733c:	0801fd60 	.word	0x0801fd60
 8007340:	0000029d 	.word	0x0000029d
 8007344:	0801fdcc 	.word	0x0801fdcc
 8007348:	0801fda0 	.word	0x0801fda0
 800734c:	08006fc1 	.word	0x08006fc1
 8007350:	20000a18 	.word	0x20000a18
 8007354:	20000a2c 	.word	0x20000a2c
 8007358:	00003a98 	.word	0x00003a98
 800735c:	00001388 	.word	0x00001388
 8007360:	080071f1 	.word	0x080071f1
 8007364:	08023a8c 	.word	0x08023a8c

08007368 <sntp_setoperatingmode>:
 * Sets the operating mode.
 * @param operating_mode one of the available operating modes
 */
void
sntp_setoperatingmode(u8_t operating_mode)
{
 8007368:	b580      	push	{r7, lr}
 800736a:	b082      	sub	sp, #8
 800736c:	af00      	add	r7, sp, #0
 800736e:	0002      	movs	r2, r0
 8007370:	1dfb      	adds	r3, r7, #7
 8007372:	701a      	strb	r2, [r3, #0]
  LWIP_ASSERT_CORE_LOCKED();
  LWIP_ASSERT("Invalid operating mode", operating_mode <= SNTP_OPMODE_LISTENONLY);
 8007374:	1dfb      	adds	r3, r7, #7
 8007376:	781b      	ldrb	r3, [r3, #0]
 8007378:	2b01      	cmp	r3, #1
 800737a:	d906      	bls.n	800738a <sntp_setoperatingmode+0x22>
 800737c:	4b0c      	ldr	r3, [pc, #48]	; (80073b0 <sntp_setoperatingmode+0x48>)
 800737e:	22b6      	movs	r2, #182	; 0xb6
 8007380:	0092      	lsls	r2, r2, #2
 8007382:	490c      	ldr	r1, [pc, #48]	; (80073b4 <sntp_setoperatingmode+0x4c>)
 8007384:	480c      	ldr	r0, [pc, #48]	; (80073b8 <sntp_setoperatingmode+0x50>)
 8007386:	f7fa ff2d 	bl	80021e4 <app_debug_rtt_raw>
  LWIP_ASSERT("Operating mode must not be set while SNTP client is running", sntp_pcb == NULL);
 800738a:	4b0c      	ldr	r3, [pc, #48]	; (80073bc <sntp_setoperatingmode+0x54>)
 800738c:	681b      	ldr	r3, [r3, #0]
 800738e:	2b00      	cmp	r3, #0
 8007390:	d005      	beq.n	800739e <sntp_setoperatingmode+0x36>
 8007392:	4b07      	ldr	r3, [pc, #28]	; (80073b0 <sntp_setoperatingmode+0x48>)
 8007394:	4a0a      	ldr	r2, [pc, #40]	; (80073c0 <sntp_setoperatingmode+0x58>)
 8007396:	490b      	ldr	r1, [pc, #44]	; (80073c4 <sntp_setoperatingmode+0x5c>)
 8007398:	4807      	ldr	r0, [pc, #28]	; (80073b8 <sntp_setoperatingmode+0x50>)
 800739a:	f7fa ff23 	bl	80021e4 <app_debug_rtt_raw>
  sntp_opmode = operating_mode;
 800739e:	4b0a      	ldr	r3, [pc, #40]	; (80073c8 <sntp_setoperatingmode+0x60>)
 80073a0:	1dfa      	adds	r2, r7, #7
 80073a2:	7812      	ldrb	r2, [r2, #0]
 80073a4:	701a      	strb	r2, [r3, #0]
}
 80073a6:	46c0      	nop			; (mov r8, r8)
 80073a8:	46bd      	mov	sp, r7
 80073aa:	b002      	add	sp, #8
 80073ac:	bd80      	pop	{r7, pc}
 80073ae:	46c0      	nop			; (mov r8, r8)
 80073b0:	0801fd60 	.word	0x0801fd60
 80073b4:	0801fdf8 	.word	0x0801fdf8
 80073b8:	0801fda0 	.word	0x0801fda0
 80073bc:	20000a1c 	.word	0x20000a1c
 80073c0:	000002d9 	.word	0x000002d9
 80073c4:	0801fe10 	.word	0x0801fe10
 80073c8:	20000a18 	.word	0x20000a18

080073cc <sntp_setservername>:
 * @param idx the index of the NTP server to set must be < SNTP_MAX_SERVERS
 * @param server DNS name of the NTP server to set, to be resolved at contact time
 */
void
sntp_setservername(u8_t idx, const char *server)
{
 80073cc:	b580      	push	{r7, lr}
 80073ce:	b082      	sub	sp, #8
 80073d0:	af00      	add	r7, sp, #0
 80073d2:	0002      	movs	r2, r0
 80073d4:	6039      	str	r1, [r7, #0]
 80073d6:	1dfb      	adds	r3, r7, #7
 80073d8:	701a      	strb	r2, [r3, #0]
  LWIP_ASSERT_CORE_LOCKED();
  if (idx < SNTP_MAX_SERVERS) {
 80073da:	1dfb      	adds	r3, r7, #7
 80073dc:	781b      	ldrb	r3, [r3, #0]
 80073de:	2b00      	cmp	r3, #0
 80073e0:	d108      	bne.n	80073f4 <sntp_setservername+0x28>
    sntp_servers[idx].name = server;
 80073e2:	1dfb      	adds	r3, r7, #7
 80073e4:	781a      	ldrb	r2, [r3, #0]
 80073e6:	4905      	ldr	r1, [pc, #20]	; (80073fc <sntp_setservername+0x30>)
 80073e8:	0013      	movs	r3, r2
 80073ea:	005b      	lsls	r3, r3, #1
 80073ec:	189b      	adds	r3, r3, r2
 80073ee:	009b      	lsls	r3, r3, #2
 80073f0:	683a      	ldr	r2, [r7, #0]
 80073f2:	505a      	str	r2, [r3, r1]
  }
}
 80073f4:	46c0      	nop			; (mov r8, r8)
 80073f6:	46bd      	mov	sp, r7
 80073f8:	b002      	add	sp, #8
 80073fa:	bd80      	pop	{r7, pc}
 80073fc:	20000a20 	.word	0x20000a20

08007400 <lwip_htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
lwip_htons(u16_t n)
{
 8007400:	b580      	push	{r7, lr}
 8007402:	b082      	sub	sp, #8
 8007404:	af00      	add	r7, sp, #0
 8007406:	0002      	movs	r2, r0
 8007408:	1dbb      	adds	r3, r7, #6
 800740a:	801a      	strh	r2, [r3, #0]
  return PP_HTONS(n);
 800740c:	1dbb      	adds	r3, r7, #6
 800740e:	881b      	ldrh	r3, [r3, #0]
 8007410:	021b      	lsls	r3, r3, #8
 8007412:	b21a      	sxth	r2, r3
 8007414:	1dbb      	adds	r3, r7, #6
 8007416:	881b      	ldrh	r3, [r3, #0]
 8007418:	0a1b      	lsrs	r3, r3, #8
 800741a:	b29b      	uxth	r3, r3
 800741c:	b21b      	sxth	r3, r3
 800741e:	4313      	orrs	r3, r2
 8007420:	b21b      	sxth	r3, r3
 8007422:	b29b      	uxth	r3, r3
}
 8007424:	0018      	movs	r0, r3
 8007426:	46bd      	mov	sp, r7
 8007428:	b002      	add	sp, #8
 800742a:	bd80      	pop	{r7, pc}

0800742c <lwip_htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
lwip_htonl(u32_t n)
{
 800742c:	b580      	push	{r7, lr}
 800742e:	b082      	sub	sp, #8
 8007430:	af00      	add	r7, sp, #0
 8007432:	6078      	str	r0, [r7, #4]
  return PP_HTONL(n);
 8007434:	687b      	ldr	r3, [r7, #4]
 8007436:	061a      	lsls	r2, r3, #24
 8007438:	687b      	ldr	r3, [r7, #4]
 800743a:	0219      	lsls	r1, r3, #8
 800743c:	23ff      	movs	r3, #255	; 0xff
 800743e:	041b      	lsls	r3, r3, #16
 8007440:	400b      	ands	r3, r1
 8007442:	431a      	orrs	r2, r3
 8007444:	687b      	ldr	r3, [r7, #4]
 8007446:	0a19      	lsrs	r1, r3, #8
 8007448:	23ff      	movs	r3, #255	; 0xff
 800744a:	021b      	lsls	r3, r3, #8
 800744c:	400b      	ands	r3, r1
 800744e:	431a      	orrs	r2, r3
 8007450:	687b      	ldr	r3, [r7, #4]
 8007452:	0e1b      	lsrs	r3, r3, #24
 8007454:	4313      	orrs	r3, r2
}
 8007456:	0018      	movs	r0, r3
 8007458:	46bd      	mov	sp, r7
 800745a:	b002      	add	sp, #8
 800745c:	bd80      	pop	{r7, pc}

0800745e <lwip_strnicmp>:
 * lwIP default implementation for strnicmp() non-standard function.
 * This can be \#defined to strnicmp() depending on your platform port.
 */
int
lwip_strnicmp(const char *str1, const char *str2, size_t len)
{
 800745e:	b5b0      	push	{r4, r5, r7, lr}
 8007460:	b086      	sub	sp, #24
 8007462:	af00      	add	r7, sp, #0
 8007464:	60f8      	str	r0, [r7, #12]
 8007466:	60b9      	str	r1, [r7, #8]
 8007468:	607a      	str	r2, [r7, #4]
  char c1, c2;

  do {
    c1 = *str1++;
 800746a:	68fb      	ldr	r3, [r7, #12]
 800746c:	1c5a      	adds	r2, r3, #1
 800746e:	60fa      	str	r2, [r7, #12]
 8007470:	2117      	movs	r1, #23
 8007472:	187a      	adds	r2, r7, r1
 8007474:	781b      	ldrb	r3, [r3, #0]
 8007476:	7013      	strb	r3, [r2, #0]
    c2 = *str2++;
 8007478:	68bb      	ldr	r3, [r7, #8]
 800747a:	1c5a      	adds	r2, r3, #1
 800747c:	60ba      	str	r2, [r7, #8]
 800747e:	2416      	movs	r4, #22
 8007480:	193a      	adds	r2, r7, r4
 8007482:	781b      	ldrb	r3, [r3, #0]
 8007484:	7013      	strb	r3, [r2, #0]
    if (c1 != c2) {
 8007486:	187a      	adds	r2, r7, r1
 8007488:	193b      	adds	r3, r7, r4
 800748a:	7812      	ldrb	r2, [r2, #0]
 800748c:	781b      	ldrb	r3, [r3, #0]
 800748e:	429a      	cmp	r2, r3
 8007490:	d020      	beq.n	80074d4 <lwip_strnicmp+0x76>
      char c1_upc = c1 | 0x20;
 8007492:	2015      	movs	r0, #21
 8007494:	183b      	adds	r3, r7, r0
 8007496:	187a      	adds	r2, r7, r1
 8007498:	7812      	ldrb	r2, [r2, #0]
 800749a:	2120      	movs	r1, #32
 800749c:	430a      	orrs	r2, r1
 800749e:	701a      	strb	r2, [r3, #0]
      if ((c1_upc >= 'a') && (c1_upc <= 'z')) {
 80074a0:	183b      	adds	r3, r7, r0
 80074a2:	781b      	ldrb	r3, [r3, #0]
 80074a4:	2b60      	cmp	r3, #96	; 0x60
 80074a6:	d912      	bls.n	80074ce <lwip_strnicmp+0x70>
 80074a8:	183b      	adds	r3, r7, r0
 80074aa:	781b      	ldrb	r3, [r3, #0]
 80074ac:	2b7a      	cmp	r3, #122	; 0x7a
 80074ae:	d80e      	bhi.n	80074ce <lwip_strnicmp+0x70>
        /* characters are not equal an one is in the alphabet range:
        downcase both chars and check again */
        char c2_upc = c2 | 0x20;
 80074b0:	2514      	movs	r5, #20
 80074b2:	197b      	adds	r3, r7, r5
 80074b4:	193a      	adds	r2, r7, r4
 80074b6:	7812      	ldrb	r2, [r2, #0]
 80074b8:	2120      	movs	r1, #32
 80074ba:	430a      	orrs	r2, r1
 80074bc:	701a      	strb	r2, [r3, #0]
        if (c1_upc != c2_upc) {
 80074be:	183a      	adds	r2, r7, r0
 80074c0:	197b      	adds	r3, r7, r5
 80074c2:	7812      	ldrb	r2, [r2, #0]
 80074c4:	781b      	ldrb	r3, [r3, #0]
 80074c6:	429a      	cmp	r2, r3
 80074c8:	d003      	beq.n	80074d2 <lwip_strnicmp+0x74>
          /* still not equal */
          /* don't care for < or > */
          return 1;
 80074ca:	2301      	movs	r3, #1
 80074cc:	e00e      	b.n	80074ec <lwip_strnicmp+0x8e>
        }
      } else {
        /* characters are not equal but none is in the alphabet range */
        return 1;
 80074ce:	2301      	movs	r3, #1
 80074d0:	e00c      	b.n	80074ec <lwip_strnicmp+0x8e>
      if ((c1_upc >= 'a') && (c1_upc <= 'z')) {
 80074d2:	46c0      	nop			; (mov r8, r8)
      }
    }
    len--;
 80074d4:	687b      	ldr	r3, [r7, #4]
 80074d6:	3b01      	subs	r3, #1
 80074d8:	607b      	str	r3, [r7, #4]
  } while ((len != 0) && (c1 != 0));
 80074da:	687b      	ldr	r3, [r7, #4]
 80074dc:	2b00      	cmp	r3, #0
 80074de:	d004      	beq.n	80074ea <lwip_strnicmp+0x8c>
 80074e0:	2317      	movs	r3, #23
 80074e2:	18fb      	adds	r3, r7, r3
 80074e4:	781b      	ldrb	r3, [r3, #0]
 80074e6:	2b00      	cmp	r3, #0
 80074e8:	d1bf      	bne.n	800746a <lwip_strnicmp+0xc>
  return 0;
 80074ea:	2300      	movs	r3, #0
}
 80074ec:	0018      	movs	r0, r3
 80074ee:	46bd      	mov	sp, r7
 80074f0:	b006      	add	sp, #24
 80074f2:	bdb0      	pop	{r4, r5, r7, pc}

080074f4 <dns_init>:
 * Initialize the resolver: set up the UDP pcb and configure the default server
 * (if DNS_SERVER_ADDRESS is set).
 */
void
dns_init(void)
{
 80074f4:	b580      	push	{r7, lr}
 80074f6:	af00      	add	r7, sp, #0
#endif

#if DNS_LOCAL_HOSTLIST
  dns_init_local();
#endif
}
 80074f8:	46c0      	nop			; (mov r8, r8)
 80074fa:	46bd      	mov	sp, r7
 80074fc:	bd80      	pop	{r7, pc}
	...

08007500 <dns_setserver>:
 * @param numdns the index of the DNS server to set must be < DNS_MAX_SERVERS
 * @param dnsserver IP address of the DNS server to set
 */
void
dns_setserver(u8_t numdns, const ip_addr_t *dnsserver)
{
 8007500:	b580      	push	{r7, lr}
 8007502:	b082      	sub	sp, #8
 8007504:	af00      	add	r7, sp, #0
 8007506:	0002      	movs	r2, r0
 8007508:	6039      	str	r1, [r7, #0]
 800750a:	1dfb      	adds	r3, r7, #7
 800750c:	701a      	strb	r2, [r3, #0]
  if (numdns < DNS_MAX_SERVERS) {
 800750e:	1dfb      	adds	r3, r7, #7
 8007510:	781b      	ldrb	r3, [r3, #0]
 8007512:	2b01      	cmp	r3, #1
 8007514:	d811      	bhi.n	800753a <dns_setserver+0x3a>
    if (dnsserver != NULL) {
 8007516:	683b      	ldr	r3, [r7, #0]
 8007518:	2b00      	cmp	r3, #0
 800751a:	d007      	beq.n	800752c <dns_setserver+0x2c>
      dns_servers[numdns] = (*dnsserver);
 800751c:	1dfb      	adds	r3, r7, #7
 800751e:	781b      	ldrb	r3, [r3, #0]
 8007520:	4a08      	ldr	r2, [pc, #32]	; (8007544 <dns_setserver+0x44>)
 8007522:	0099      	lsls	r1, r3, #2
 8007524:	683b      	ldr	r3, [r7, #0]
 8007526:	681b      	ldr	r3, [r3, #0]
 8007528:	508b      	str	r3, [r1, r2]
    } else {
      dns_servers[numdns] = *IP_ADDR_ANY;
    }
  }
}
 800752a:	e006      	b.n	800753a <dns_setserver+0x3a>
      dns_servers[numdns] = *IP_ADDR_ANY;
 800752c:	1dfb      	adds	r3, r7, #7
 800752e:	781b      	ldrb	r3, [r3, #0]
 8007530:	4a04      	ldr	r2, [pc, #16]	; (8007544 <dns_setserver+0x44>)
 8007532:	0099      	lsls	r1, r3, #2
 8007534:	4b04      	ldr	r3, [pc, #16]	; (8007548 <dns_setserver+0x48>)
 8007536:	681b      	ldr	r3, [r3, #0]
 8007538:	508b      	str	r3, [r1, r2]
}
 800753a:	46c0      	nop			; (mov r8, r8)
 800753c:	46bd      	mov	sp, r7
 800753e:	b002      	add	sp, #8
 8007540:	bd80      	pop	{r7, pc}
 8007542:	46c0      	nop			; (mov r8, r8)
 8007544:	20000c14 	.word	0x20000c14
 8007548:	08023a8c 	.word	0x08023a8c

0800754c <dns_getserver>:
 * @return IP address of the indexed DNS server or "ip_addr_any" if the DNS
 *         server has not been configured.
 */
const ip_addr_t *
dns_getserver(u8_t numdns)
{
 800754c:	b580      	push	{r7, lr}
 800754e:	b082      	sub	sp, #8
 8007550:	af00      	add	r7, sp, #0
 8007552:	0002      	movs	r2, r0
 8007554:	1dfb      	adds	r3, r7, #7
 8007556:	701a      	strb	r2, [r3, #0]
  if (numdns < DNS_MAX_SERVERS) {
 8007558:	1dfb      	adds	r3, r7, #7
 800755a:	781b      	ldrb	r3, [r3, #0]
 800755c:	2b01      	cmp	r3, #1
 800755e:	d805      	bhi.n	800756c <dns_getserver+0x20>
    return &dns_servers[numdns];
 8007560:	1dfb      	adds	r3, r7, #7
 8007562:	781b      	ldrb	r3, [r3, #0]
 8007564:	009a      	lsls	r2, r3, #2
 8007566:	4b04      	ldr	r3, [pc, #16]	; (8007578 <dns_getserver+0x2c>)
 8007568:	18d3      	adds	r3, r2, r3
 800756a:	e000      	b.n	800756e <dns_getserver+0x22>
  } else {
    return IP_ADDR_ANY;
 800756c:	4b03      	ldr	r3, [pc, #12]	; (800757c <dns_getserver+0x30>)
  }
}
 800756e:	0018      	movs	r0, r3
 8007570:	46bd      	mov	sp, r7
 8007572:	b002      	add	sp, #8
 8007574:	bd80      	pop	{r7, pc}
 8007576:	46c0      	nop			; (mov r8, r8)
 8007578:	20000c14 	.word	0x20000c14
 800757c:	08023a8c 	.word	0x08023a8c

08007580 <dns_tmr>:
 * The DNS resolver client timer - handle retries and timeouts and should
 * be called every DNS_TMR_INTERVAL milliseconds (every second by default).
 */
void
dns_tmr(void)
{
 8007580:	b580      	push	{r7, lr}
 8007582:	af00      	add	r7, sp, #0
  LWIP_DEBUGF(DNS_DEBUG, ("dns_tmr: dns_check_entries\n"));
  dns_check_entries();
 8007584:	f000 fd16 	bl	8007fb4 <dns_check_entries>
}
 8007588:	46c0      	nop			; (mov r8, r8)
 800758a:	46bd      	mov	sp, r7
 800758c:	bd80      	pop	{r7, pc}
	...

08007590 <dns_lookup>:
 *         was not found in the cached dns_table.
 * @return ERR_OK if found, ERR_ARG if not found
 */
static err_t
dns_lookup(const char *name, ip_addr_t *addr LWIP_DNS_ADDRTYPE_ARG(u8_t dns_addrtype))
{
 8007590:	b590      	push	{r4, r7, lr}
 8007592:	b085      	sub	sp, #20
 8007594:	af00      	add	r7, sp, #0
 8007596:	6078      	str	r0, [r7, #4]
 8007598:	6039      	str	r1, [r7, #0]
    return ERR_OK;
  }
#endif /* DNS_LOOKUP_LOCAL_EXTERN */

  /* Walk through name list, return entry if found. If not, return NULL. */
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 800759a:	230f      	movs	r3, #15
 800759c:	18fb      	adds	r3, r7, r3
 800759e:	2200      	movs	r2, #0
 80075a0:	701a      	strb	r2, [r3, #0]
 80075a2:	e034      	b.n	800760e <dns_lookup+0x7e>
    if ((dns_table[i].state == DNS_STATE_DONE) &&
 80075a4:	240f      	movs	r4, #15
 80075a6:	193b      	adds	r3, r7, r4
 80075a8:	781a      	ldrb	r2, [r3, #0]
 80075aa:	491e      	ldr	r1, [pc, #120]	; (8007624 <dns_lookup+0x94>)
 80075ac:	0013      	movs	r3, r2
 80075ae:	00db      	lsls	r3, r3, #3
 80075b0:	189b      	adds	r3, r3, r2
 80075b2:	011b      	lsls	r3, r3, #4
 80075b4:	18cb      	adds	r3, r1, r3
 80075b6:	330a      	adds	r3, #10
 80075b8:	781b      	ldrb	r3, [r3, #0]
 80075ba:	2b03      	cmp	r3, #3
 80075bc:	d121      	bne.n	8007602 <dns_lookup+0x72>
        (lwip_strnicmp(name, dns_table[i].name, sizeof(dns_table[i].name)) == 0) &&
 80075be:	193b      	adds	r3, r7, r4
 80075c0:	781a      	ldrb	r2, [r3, #0]
 80075c2:	0013      	movs	r3, r2
 80075c4:	00db      	lsls	r3, r3, #3
 80075c6:	189b      	adds	r3, r3, r2
 80075c8:	011b      	lsls	r3, r3, #4
 80075ca:	3310      	adds	r3, #16
 80075cc:	001a      	movs	r2, r3
 80075ce:	4b15      	ldr	r3, [pc, #84]	; (8007624 <dns_lookup+0x94>)
 80075d0:	18d1      	adds	r1, r2, r3
 80075d2:	687b      	ldr	r3, [r7, #4]
 80075d4:	2280      	movs	r2, #128	; 0x80
 80075d6:	0018      	movs	r0, r3
 80075d8:	f7ff ff41 	bl	800745e <lwip_strnicmp>
 80075dc:	1e03      	subs	r3, r0, #0
    if ((dns_table[i].state == DNS_STATE_DONE) &&
 80075de:	d110      	bne.n	8007602 <dns_lookup+0x72>
        LWIP_DNS_ADDRTYPE_MATCH_IP(dns_addrtype, dns_table[i].ipaddr)) {
      LWIP_DEBUGF(DNS_DEBUG, ("dns_lookup: \"%s\": found = ", name));
      ip_addr_debug_print_val(DNS_DEBUG, dns_table[i].ipaddr);
      LWIP_DEBUGF(DNS_DEBUG, ("\n"));
      if (addr) {
 80075e0:	683b      	ldr	r3, [r7, #0]
 80075e2:	2b00      	cmp	r3, #0
 80075e4:	d00b      	beq.n	80075fe <dns_lookup+0x6e>
        ip_addr_copy(*addr, dns_table[i].ipaddr);
 80075e6:	193b      	adds	r3, r7, r4
 80075e8:	781a      	ldrb	r2, [r3, #0]
 80075ea:	490e      	ldr	r1, [pc, #56]	; (8007624 <dns_lookup+0x94>)
 80075ec:	0013      	movs	r3, r2
 80075ee:	00db      	lsls	r3, r3, #3
 80075f0:	189b      	adds	r3, r3, r2
 80075f2:	011b      	lsls	r3, r3, #4
 80075f4:	18cb      	adds	r3, r1, r3
 80075f6:	3304      	adds	r3, #4
 80075f8:	681a      	ldr	r2, [r3, #0]
 80075fa:	683b      	ldr	r3, [r7, #0]
 80075fc:	601a      	str	r2, [r3, #0]
      }
      return ERR_OK;
 80075fe:	2300      	movs	r3, #0
 8007600:	e00c      	b.n	800761c <dns_lookup+0x8c>
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 8007602:	220f      	movs	r2, #15
 8007604:	18bb      	adds	r3, r7, r2
 8007606:	18ba      	adds	r2, r7, r2
 8007608:	7812      	ldrb	r2, [r2, #0]
 800760a:	3201      	adds	r2, #1
 800760c:	701a      	strb	r2, [r3, #0]
 800760e:	230f      	movs	r3, #15
 8007610:	18fb      	adds	r3, r7, r3
 8007612:	781b      	ldrb	r3, [r3, #0]
 8007614:	2b02      	cmp	r3, #2
 8007616:	d9c5      	bls.n	80075a4 <dns_lookup+0x14>
    }
  }

  return ERR_ARG;
 8007618:	2310      	movs	r3, #16
 800761a:	425b      	negs	r3, r3
}
 800761c:	0018      	movs	r0, r3
 800761e:	46bd      	mov	sp, r7
 8007620:	b005      	add	sp, #20
 8007622:	bd90      	pop	{r4, r7, pc}
 8007624:	20000a40 	.word	0x20000a40

08007628 <dns_compare_name>:
 * @param start_offset offset into p where the name starts
 * @return 0xFFFF: names differ, other: names equal -> offset behind name
 */
static u16_t
dns_compare_name(const char *query, struct pbuf *p, u16_t start_offset)
{
 8007628:	b590      	push	{r4, r7, lr}
 800762a:	b089      	sub	sp, #36	; 0x24
 800762c:	af00      	add	r7, sp, #0
 800762e:	60f8      	str	r0, [r7, #12]
 8007630:	60b9      	str	r1, [r7, #8]
 8007632:	1dbb      	adds	r3, r7, #6
 8007634:	801a      	strh	r2, [r3, #0]
  int n;
  u16_t response_offset = start_offset;
 8007636:	231a      	movs	r3, #26
 8007638:	18fb      	adds	r3, r7, r3
 800763a:	1dba      	adds	r2, r7, #6
 800763c:	8812      	ldrh	r2, [r2, #0]
 800763e:	801a      	strh	r2, [r3, #0]

  do {
    n = pbuf_try_get_at(p, response_offset);
 8007640:	241a      	movs	r4, #26
 8007642:	193b      	adds	r3, r7, r4
 8007644:	881a      	ldrh	r2, [r3, #0]
 8007646:	68bb      	ldr	r3, [r7, #8]
 8007648:	0011      	movs	r1, r2
 800764a:	0018      	movs	r0, r3
 800764c:	f003 fc7b 	bl	800af46 <pbuf_try_get_at>
 8007650:	0003      	movs	r3, r0
 8007652:	61fb      	str	r3, [r7, #28]
    if ((n < 0) || (response_offset == 0xFFFF)) {
 8007654:	69fb      	ldr	r3, [r7, #28]
 8007656:	2b00      	cmp	r3, #0
 8007658:	db04      	blt.n	8007664 <dns_compare_name+0x3c>
 800765a:	193b      	adds	r3, r7, r4
 800765c:	881b      	ldrh	r3, [r3, #0]
 800765e:	4a48      	ldr	r2, [pc, #288]	; (8007780 <dns_compare_name+0x158>)
 8007660:	4293      	cmp	r3, r2
 8007662:	d101      	bne.n	8007668 <dns_compare_name+0x40>
      /* error or overflow */
      return 0xFFFF;
 8007664:	4b46      	ldr	r3, [pc, #280]	; (8007780 <dns_compare_name+0x158>)
 8007666:	e087      	b.n	8007778 <dns_compare_name+0x150>
    }
    response_offset++;
 8007668:	211a      	movs	r1, #26
 800766a:	187b      	adds	r3, r7, r1
 800766c:	881a      	ldrh	r2, [r3, #0]
 800766e:	187b      	adds	r3, r7, r1
 8007670:	3201      	adds	r2, #1
 8007672:	801a      	strh	r2, [r3, #0]
    /** @see RFC 1035 - 4.1.4. Message compression */
    if ((n & 0xc0) == 0xc0) {
 8007674:	69fb      	ldr	r3, [r7, #28]
 8007676:	22c0      	movs	r2, #192	; 0xc0
 8007678:	4013      	ands	r3, r2
 800767a:	2bc0      	cmp	r3, #192	; 0xc0
 800767c:	d156      	bne.n	800772c <dns_compare_name+0x104>
      /* Compressed name: cannot be equal since we don't send them */
      return 0xFFFF;
 800767e:	4b40      	ldr	r3, [pc, #256]	; (8007780 <dns_compare_name+0x158>)
 8007680:	e07a      	b.n	8007778 <dns_compare_name+0x150>
    } else {
      /* Not compressed name */
      while (n > 0) {
        int c = pbuf_try_get_at(p, response_offset);
 8007682:	231a      	movs	r3, #26
 8007684:	18fb      	adds	r3, r7, r3
 8007686:	881a      	ldrh	r2, [r3, #0]
 8007688:	68bb      	ldr	r3, [r7, #8]
 800768a:	0011      	movs	r1, r2
 800768c:	0018      	movs	r0, r3
 800768e:	f003 fc5a 	bl	800af46 <pbuf_try_get_at>
 8007692:	0003      	movs	r3, r0
 8007694:	617b      	str	r3, [r7, #20]
        if (c < 0) {
 8007696:	697b      	ldr	r3, [r7, #20]
 8007698:	2b00      	cmp	r3, #0
 800769a:	da01      	bge.n	80076a0 <dns_compare_name+0x78>
          return 0xFFFF;
 800769c:	4b38      	ldr	r3, [pc, #224]	; (8007780 <dns_compare_name+0x158>)
 800769e:	e06b      	b.n	8007778 <dns_compare_name+0x150>
        }
        if (lwip_tolower((*query)) != lwip_tolower((u8_t)c)) {
 80076a0:	2113      	movs	r1, #19
 80076a2:	187b      	adds	r3, r7, r1
 80076a4:	68fa      	ldr	r2, [r7, #12]
 80076a6:	7812      	ldrb	r2, [r2, #0]
 80076a8:	701a      	strb	r2, [r3, #0]
 80076aa:	187b      	adds	r3, r7, r1
 80076ac:	781b      	ldrb	r3, [r3, #0]
 80076ae:	1c5a      	adds	r2, r3, #1
 80076b0:	4b34      	ldr	r3, [pc, #208]	; (8007784 <dns_compare_name+0x15c>)
 80076b2:	18d3      	adds	r3, r2, r3
 80076b4:	781b      	ldrb	r3, [r3, #0]
 80076b6:	001a      	movs	r2, r3
 80076b8:	2303      	movs	r3, #3
 80076ba:	4013      	ands	r3, r2
 80076bc:	2b01      	cmp	r3, #1
 80076be:	d104      	bne.n	80076ca <dns_compare_name+0xa2>
 80076c0:	187b      	adds	r3, r7, r1
 80076c2:	781b      	ldrb	r3, [r3, #0]
 80076c4:	3320      	adds	r3, #32
 80076c6:	001a      	movs	r2, r3
 80076c8:	e002      	b.n	80076d0 <dns_compare_name+0xa8>
 80076ca:	2313      	movs	r3, #19
 80076cc:	18fb      	adds	r3, r7, r3
 80076ce:	781a      	ldrb	r2, [r3, #0]
 80076d0:	2012      	movs	r0, #18
 80076d2:	183b      	adds	r3, r7, r0
 80076d4:	6979      	ldr	r1, [r7, #20]
 80076d6:	7019      	strb	r1, [r3, #0]
 80076d8:	183b      	adds	r3, r7, r0
 80076da:	781b      	ldrb	r3, [r3, #0]
 80076dc:	1c59      	adds	r1, r3, #1
 80076de:	4b29      	ldr	r3, [pc, #164]	; (8007784 <dns_compare_name+0x15c>)
 80076e0:	18cb      	adds	r3, r1, r3
 80076e2:	781b      	ldrb	r3, [r3, #0]
 80076e4:	0019      	movs	r1, r3
 80076e6:	2303      	movs	r3, #3
 80076e8:	400b      	ands	r3, r1
 80076ea:	2b01      	cmp	r3, #1
 80076ec:	d103      	bne.n	80076f6 <dns_compare_name+0xce>
 80076ee:	183b      	adds	r3, r7, r0
 80076f0:	781b      	ldrb	r3, [r3, #0]
 80076f2:	3320      	adds	r3, #32
 80076f4:	e002      	b.n	80076fc <dns_compare_name+0xd4>
 80076f6:	2312      	movs	r3, #18
 80076f8:	18fb      	adds	r3, r7, r3
 80076fa:	781b      	ldrb	r3, [r3, #0]
 80076fc:	429a      	cmp	r2, r3
 80076fe:	d001      	beq.n	8007704 <dns_compare_name+0xdc>
          return 0xFFFF;
 8007700:	4b1f      	ldr	r3, [pc, #124]	; (8007780 <dns_compare_name+0x158>)
 8007702:	e039      	b.n	8007778 <dns_compare_name+0x150>
        }
        if (response_offset == 0xFFFF) {
 8007704:	231a      	movs	r3, #26
 8007706:	18fb      	adds	r3, r7, r3
 8007708:	881b      	ldrh	r3, [r3, #0]
 800770a:	4a1d      	ldr	r2, [pc, #116]	; (8007780 <dns_compare_name+0x158>)
 800770c:	4293      	cmp	r3, r2
 800770e:	d101      	bne.n	8007714 <dns_compare_name+0xec>
          /* would overflow */
          return 0xFFFF;
 8007710:	4b1b      	ldr	r3, [pc, #108]	; (8007780 <dns_compare_name+0x158>)
 8007712:	e031      	b.n	8007778 <dns_compare_name+0x150>
        }
        response_offset++;
 8007714:	211a      	movs	r1, #26
 8007716:	187b      	adds	r3, r7, r1
 8007718:	881a      	ldrh	r2, [r3, #0]
 800771a:	187b      	adds	r3, r7, r1
 800771c:	3201      	adds	r2, #1
 800771e:	801a      	strh	r2, [r3, #0]
        ++query;
 8007720:	68fb      	ldr	r3, [r7, #12]
 8007722:	3301      	adds	r3, #1
 8007724:	60fb      	str	r3, [r7, #12]
        --n;
 8007726:	69fb      	ldr	r3, [r7, #28]
 8007728:	3b01      	subs	r3, #1
 800772a:	61fb      	str	r3, [r7, #28]
      while (n > 0) {
 800772c:	69fb      	ldr	r3, [r7, #28]
 800772e:	2b00      	cmp	r3, #0
 8007730:	dca7      	bgt.n	8007682 <dns_compare_name+0x5a>
      }
      ++query;
 8007732:	68fb      	ldr	r3, [r7, #12]
 8007734:	3301      	adds	r3, #1
 8007736:	60fb      	str	r3, [r7, #12]
    }
    n = pbuf_try_get_at(p, response_offset);
 8007738:	231a      	movs	r3, #26
 800773a:	18fb      	adds	r3, r7, r3
 800773c:	881a      	ldrh	r2, [r3, #0]
 800773e:	68bb      	ldr	r3, [r7, #8]
 8007740:	0011      	movs	r1, r2
 8007742:	0018      	movs	r0, r3
 8007744:	f003 fbff 	bl	800af46 <pbuf_try_get_at>
 8007748:	0003      	movs	r3, r0
 800774a:	61fb      	str	r3, [r7, #28]
    if (n < 0) {
 800774c:	69fb      	ldr	r3, [r7, #28]
 800774e:	2b00      	cmp	r3, #0
 8007750:	da01      	bge.n	8007756 <dns_compare_name+0x12e>
      return 0xFFFF;
 8007752:	4b0b      	ldr	r3, [pc, #44]	; (8007780 <dns_compare_name+0x158>)
 8007754:	e010      	b.n	8007778 <dns_compare_name+0x150>
    }
  } while (n != 0);
 8007756:	69fb      	ldr	r3, [r7, #28]
 8007758:	2b00      	cmp	r3, #0
 800775a:	d000      	beq.n	800775e <dns_compare_name+0x136>
 800775c:	e770      	b.n	8007640 <dns_compare_name+0x18>

  if (response_offset == 0xFFFF) {
 800775e:	231a      	movs	r3, #26
 8007760:	18fb      	adds	r3, r7, r3
 8007762:	881b      	ldrh	r3, [r3, #0]
 8007764:	4a06      	ldr	r2, [pc, #24]	; (8007780 <dns_compare_name+0x158>)
 8007766:	4293      	cmp	r3, r2
 8007768:	d101      	bne.n	800776e <dns_compare_name+0x146>
    /* would overflow */
    return 0xFFFF;
 800776a:	4b05      	ldr	r3, [pc, #20]	; (8007780 <dns_compare_name+0x158>)
 800776c:	e004      	b.n	8007778 <dns_compare_name+0x150>
  }
  return (u16_t)(response_offset + 1);
 800776e:	231a      	movs	r3, #26
 8007770:	18fb      	adds	r3, r7, r3
 8007772:	881b      	ldrh	r3, [r3, #0]
 8007774:	3301      	adds	r3, #1
 8007776:	b29b      	uxth	r3, r3
}
 8007778:	0018      	movs	r0, r3
 800777a:	46bd      	mov	sp, r7
 800777c:	b009      	add	sp, #36	; 0x24
 800777e:	bd90      	pop	{r4, r7, pc}
 8007780:	0000ffff 	.word	0x0000ffff
 8007784:	08024088 	.word	0x08024088

08007788 <dns_skip_name>:
 * @param query_idx start index into p pointing to encoded DNS name in the DNS server response
 * @return index to end of the name
 */
static u16_t
dns_skip_name(struct pbuf *p, u16_t query_idx)
{
 8007788:	b590      	push	{r4, r7, lr}
 800778a:	b085      	sub	sp, #20
 800778c:	af00      	add	r7, sp, #0
 800778e:	6078      	str	r0, [r7, #4]
 8007790:	000a      	movs	r2, r1
 8007792:	1cbb      	adds	r3, r7, #2
 8007794:	801a      	strh	r2, [r3, #0]
  int n;
  u16_t offset = query_idx;
 8007796:	230e      	movs	r3, #14
 8007798:	18fb      	adds	r3, r7, r3
 800779a:	1cba      	adds	r2, r7, #2
 800779c:	8812      	ldrh	r2, [r2, #0]
 800779e:	801a      	strh	r2, [r3, #0]

  do {
    n = pbuf_try_get_at(p, offset++);
 80077a0:	240e      	movs	r4, #14
 80077a2:	193b      	adds	r3, r7, r4
 80077a4:	881b      	ldrh	r3, [r3, #0]
 80077a6:	193a      	adds	r2, r7, r4
 80077a8:	1c59      	adds	r1, r3, #1
 80077aa:	8011      	strh	r1, [r2, #0]
 80077ac:	687a      	ldr	r2, [r7, #4]
 80077ae:	0019      	movs	r1, r3
 80077b0:	0010      	movs	r0, r2
 80077b2:	f003 fbc8 	bl	800af46 <pbuf_try_get_at>
 80077b6:	0003      	movs	r3, r0
 80077b8:	60bb      	str	r3, [r7, #8]
    if ((n < 0) || (offset == 0)) {
 80077ba:	68bb      	ldr	r3, [r7, #8]
 80077bc:	2b00      	cmp	r3, #0
 80077be:	db03      	blt.n	80077c8 <dns_skip_name+0x40>
 80077c0:	193b      	adds	r3, r7, r4
 80077c2:	881b      	ldrh	r3, [r3, #0]
 80077c4:	2b00      	cmp	r3, #0
 80077c6:	d101      	bne.n	80077cc <dns_skip_name+0x44>
      return 0xFFFF;
 80077c8:	4b1e      	ldr	r3, [pc, #120]	; (8007844 <dns_skip_name+0xbc>)
 80077ca:	e037      	b.n	800783c <dns_skip_name+0xb4>
    }
    /** @see RFC 1035 - 4.1.4. Message compression */
    if ((n & 0xc0) == 0xc0) {
 80077cc:	68bb      	ldr	r3, [r7, #8]
 80077ce:	22c0      	movs	r2, #192	; 0xc0
 80077d0:	4013      	ands	r3, r2
 80077d2:	2bc0      	cmp	r3, #192	; 0xc0
 80077d4:	d024      	beq.n	8007820 <dns_skip_name+0x98>
      /* Compressed name: since we only want to skip it (not check it), stop here */
      break;
    } else {
      /* Not compressed name */
      if (offset + n >= p->tot_len) {
 80077d6:	230e      	movs	r3, #14
 80077d8:	18fb      	adds	r3, r7, r3
 80077da:	881a      	ldrh	r2, [r3, #0]
 80077dc:	68bb      	ldr	r3, [r7, #8]
 80077de:	18d3      	adds	r3, r2, r3
 80077e0:	687a      	ldr	r2, [r7, #4]
 80077e2:	8912      	ldrh	r2, [r2, #8]
 80077e4:	4293      	cmp	r3, r2
 80077e6:	db01      	blt.n	80077ec <dns_skip_name+0x64>
        return 0xFFFF;
 80077e8:	4b16      	ldr	r3, [pc, #88]	; (8007844 <dns_skip_name+0xbc>)
 80077ea:	e027      	b.n	800783c <dns_skip_name+0xb4>
      }
      offset = (u16_t)(offset + n);
 80077ec:	68bb      	ldr	r3, [r7, #8]
 80077ee:	b299      	uxth	r1, r3
 80077f0:	200e      	movs	r0, #14
 80077f2:	183b      	adds	r3, r7, r0
 80077f4:	183a      	adds	r2, r7, r0
 80077f6:	8812      	ldrh	r2, [r2, #0]
 80077f8:	188a      	adds	r2, r1, r2
 80077fa:	801a      	strh	r2, [r3, #0]
    }
    n = pbuf_try_get_at(p, offset);
 80077fc:	183b      	adds	r3, r7, r0
 80077fe:	881a      	ldrh	r2, [r3, #0]
 8007800:	687b      	ldr	r3, [r7, #4]
 8007802:	0011      	movs	r1, r2
 8007804:	0018      	movs	r0, r3
 8007806:	f003 fb9e 	bl	800af46 <pbuf_try_get_at>
 800780a:	0003      	movs	r3, r0
 800780c:	60bb      	str	r3, [r7, #8]
    if (n < 0) {
 800780e:	68bb      	ldr	r3, [r7, #8]
 8007810:	2b00      	cmp	r3, #0
 8007812:	da01      	bge.n	8007818 <dns_skip_name+0x90>
      return 0xFFFF;
 8007814:	4b0b      	ldr	r3, [pc, #44]	; (8007844 <dns_skip_name+0xbc>)
 8007816:	e011      	b.n	800783c <dns_skip_name+0xb4>
    }
  } while (n != 0);
 8007818:	68bb      	ldr	r3, [r7, #8]
 800781a:	2b00      	cmp	r3, #0
 800781c:	d1c0      	bne.n	80077a0 <dns_skip_name+0x18>
 800781e:	e000      	b.n	8007822 <dns_skip_name+0x9a>
      break;
 8007820:	46c0      	nop			; (mov r8, r8)

  if (offset == 0xFFFF) {
 8007822:	230e      	movs	r3, #14
 8007824:	18fb      	adds	r3, r7, r3
 8007826:	881b      	ldrh	r3, [r3, #0]
 8007828:	4a06      	ldr	r2, [pc, #24]	; (8007844 <dns_skip_name+0xbc>)
 800782a:	4293      	cmp	r3, r2
 800782c:	d101      	bne.n	8007832 <dns_skip_name+0xaa>
    return 0xFFFF;
 800782e:	4b05      	ldr	r3, [pc, #20]	; (8007844 <dns_skip_name+0xbc>)
 8007830:	e004      	b.n	800783c <dns_skip_name+0xb4>
  }
  return (u16_t)(offset + 1);
 8007832:	230e      	movs	r3, #14
 8007834:	18fb      	adds	r3, r7, r3
 8007836:	881b      	ldrh	r3, [r3, #0]
 8007838:	3301      	adds	r3, #1
 800783a:	b29b      	uxth	r3, r3
}
 800783c:	0018      	movs	r0, r3
 800783e:	46bd      	mov	sp, r7
 8007840:	b005      	add	sp, #20
 8007842:	bd90      	pop	{r4, r7, pc}
 8007844:	0000ffff 	.word	0x0000ffff

08007848 <dns_send>:
 * @param idx the DNS table entry index for which to send a request
 * @return ERR_OK if packet is sent; an err_t indicating the problem otherwise
 */
static err_t
dns_send(u8_t idx)
{
 8007848:	b5f0      	push	{r4, r5, r6, r7, lr}
 800784a:	b091      	sub	sp, #68	; 0x44
 800784c:	af00      	add	r7, sp, #0
 800784e:	0002      	movs	r2, r0
 8007850:	1dfb      	adds	r3, r7, #7
 8007852:	701a      	strb	r2, [r3, #0]
  struct pbuf *p;
  u16_t query_idx, copy_len;
  const char *hostname, *hostname_part;
  u8_t n;
  u8_t pcb_idx;
  struct dns_table_entry *entry = &dns_table[idx];
 8007854:	1dfb      	adds	r3, r7, #7
 8007856:	781a      	ldrb	r2, [r3, #0]
 8007858:	0013      	movs	r3, r2
 800785a:	00db      	lsls	r3, r3, #3
 800785c:	189b      	adds	r3, r3, r2
 800785e:	011b      	lsls	r3, r3, #4
 8007860:	4a7e      	ldr	r2, [pc, #504]	; (8007a5c <dns_send+0x214>)
 8007862:	189b      	adds	r3, r3, r2
 8007864:	633b      	str	r3, [r7, #48]	; 0x30

  LWIP_DEBUGF(DNS_DEBUG, ("dns_send: dns_servers[%"U16_F"] \"%s\": request\n",
                          (u16_t)(entry->server_idx), entry->name));
  LWIP_ASSERT("dns server out of array", entry->server_idx < DNS_MAX_SERVERS);
 8007866:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007868:	7adb      	ldrb	r3, [r3, #11]
 800786a:	2b01      	cmp	r3, #1
 800786c:	d905      	bls.n	800787a <dns_send+0x32>
 800786e:	4b7c      	ldr	r3, [pc, #496]	; (8007a60 <dns_send+0x218>)
 8007870:	4a7c      	ldr	r2, [pc, #496]	; (8007a64 <dns_send+0x21c>)
 8007872:	497d      	ldr	r1, [pc, #500]	; (8007a68 <dns_send+0x220>)
 8007874:	487d      	ldr	r0, [pc, #500]	; (8007a6c <dns_send+0x224>)
 8007876:	f7fa fcb5 	bl	80021e4 <app_debug_rtt_raw>
  if (ip_addr_isany_val(dns_servers[entry->server_idx])
 800787a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800787c:	7adb      	ldrb	r3, [r3, #11]
 800787e:	001a      	movs	r2, r3
 8007880:	4b7b      	ldr	r3, [pc, #492]	; (8007a70 <dns_send+0x228>)
 8007882:	0092      	lsls	r2, r2, #2
 8007884:	58d3      	ldr	r3, [r2, r3]
 8007886:	2b00      	cmp	r3, #0
 8007888:	d10a      	bne.n	80078a0 <dns_send+0x58>
      && !entry->is_mdns
#endif
     ) {
    /* DNS server not valid anymore, e.g. PPP netif has been shut down */
    /* call specified callback function if provided */
    dns_call_found(idx, NULL);
 800788a:	1dfb      	adds	r3, r7, #7
 800788c:	781b      	ldrb	r3, [r3, #0]
 800788e:	2100      	movs	r1, #0
 8007890:	0018      	movs	r0, r3
 8007892:	f000 f9a3 	bl	8007bdc <dns_call_found>
    /* flush this entry */
    entry->state = DNS_STATE_UNUSED;
 8007896:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007898:	2200      	movs	r2, #0
 800789a:	729a      	strb	r2, [r3, #10]
    return ERR_OK;
 800789c:	2300      	movs	r3, #0
 800789e:	e0d8      	b.n	8007a52 <dns_send+0x20a>
  }

  /* if here, we have either a new query or a retry on a previous query to process */
  p = pbuf_alloc(PBUF_TRANSPORT, (u16_t)(SIZEOF_DNS_HDR + strlen(entry->name) + 2 +
 80078a0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80078a2:	3310      	adds	r3, #16
 80078a4:	0018      	movs	r0, r3
 80078a6:	f7f8 fc39 	bl	800011c <strlen>
 80078aa:	0003      	movs	r3, r0
 80078ac:	b29b      	uxth	r3, r3
 80078ae:	3312      	adds	r3, #18
 80078b0:	b29b      	uxth	r3, r3
 80078b2:	22a0      	movs	r2, #160	; 0xa0
 80078b4:	0092      	lsls	r2, r2, #2
 80078b6:	0019      	movs	r1, r3
 80078b8:	2038      	movs	r0, #56	; 0x38
 80078ba:	f002 fad9 	bl	8009e70 <pbuf_alloc>
 80078be:	0003      	movs	r3, r0
 80078c0:	62fb      	str	r3, [r7, #44]	; 0x2c
                                         SIZEOF_DNS_QUERY), PBUF_RAM);
  if (p != NULL) {
 80078c2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80078c4:	2b00      	cmp	r3, #0
 80078c6:	d100      	bne.n	80078ca <dns_send+0x82>
 80078c8:	e0b3      	b.n	8007a32 <dns_send+0x1ea>
    const ip_addr_t *dst;
    u16_t dst_port;
    /* fill dns header */
    memset(&hdr, 0, SIZEOF_DNS_HDR);
 80078ca:	2410      	movs	r4, #16
 80078cc:	193b      	adds	r3, r7, r4
 80078ce:	220c      	movs	r2, #12
 80078d0:	2100      	movs	r1, #0
 80078d2:	0018      	movs	r0, r3
 80078d4:	f016 fb7e 	bl	801dfd4 <memset>
    hdr.id = lwip_htons(entry->txid);
 80078d8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80078da:	891b      	ldrh	r3, [r3, #8]
 80078dc:	0018      	movs	r0, r3
 80078de:	f7ff fd8f 	bl	8007400 <lwip_htons>
 80078e2:	0003      	movs	r3, r0
 80078e4:	001a      	movs	r2, r3
 80078e6:	193b      	adds	r3, r7, r4
 80078e8:	801a      	strh	r2, [r3, #0]
    hdr.flags1 = DNS_FLAG1_RD;
 80078ea:	193b      	adds	r3, r7, r4
 80078ec:	2201      	movs	r2, #1
 80078ee:	709a      	strb	r2, [r3, #2]
    hdr.numquestions = PP_HTONS(1);
 80078f0:	193b      	adds	r3, r7, r4
 80078f2:	2280      	movs	r2, #128	; 0x80
 80078f4:	0052      	lsls	r2, r2, #1
 80078f6:	809a      	strh	r2, [r3, #4]
    pbuf_take(p, &hdr, SIZEOF_DNS_HDR);
 80078f8:	1939      	adds	r1, r7, r4
 80078fa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80078fc:	220c      	movs	r2, #12
 80078fe:	0018      	movs	r0, r3
 8007900:	f003 f98c 	bl	800ac1c <pbuf_take>
    hostname = entry->name;
 8007904:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007906:	3310      	adds	r3, #16
 8007908:	63bb      	str	r3, [r7, #56]	; 0x38
    --hostname;
 800790a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800790c:	3b01      	subs	r3, #1
 800790e:	63bb      	str	r3, [r7, #56]	; 0x38

    /* convert hostname into suitable query format. */
    query_idx = SIZEOF_DNS_HDR;
 8007910:	233c      	movs	r3, #60	; 0x3c
 8007912:	18fb      	adds	r3, r7, r3
 8007914:	220c      	movs	r2, #12
 8007916:	801a      	strh	r2, [r3, #0]
    do {
      ++hostname;
 8007918:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800791a:	3301      	adds	r3, #1
 800791c:	63bb      	str	r3, [r7, #56]	; 0x38
      hostname_part = hostname;
 800791e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007920:	62bb      	str	r3, [r7, #40]	; 0x28
      for (n = 0; *hostname != '.' && *hostname != 0; ++hostname) {
 8007922:	2337      	movs	r3, #55	; 0x37
 8007924:	18fb      	adds	r3, r7, r3
 8007926:	2200      	movs	r2, #0
 8007928:	701a      	strb	r2, [r3, #0]
 800792a:	e008      	b.n	800793e <dns_send+0xf6>
        ++n;
 800792c:	2237      	movs	r2, #55	; 0x37
 800792e:	18bb      	adds	r3, r7, r2
 8007930:	18ba      	adds	r2, r7, r2
 8007932:	7812      	ldrb	r2, [r2, #0]
 8007934:	3201      	adds	r2, #1
 8007936:	701a      	strb	r2, [r3, #0]
      for (n = 0; *hostname != '.' && *hostname != 0; ++hostname) {
 8007938:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800793a:	3301      	adds	r3, #1
 800793c:	63bb      	str	r3, [r7, #56]	; 0x38
 800793e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007940:	781b      	ldrb	r3, [r3, #0]
 8007942:	2b2e      	cmp	r3, #46	; 0x2e
 8007944:	d003      	beq.n	800794e <dns_send+0x106>
 8007946:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007948:	781b      	ldrb	r3, [r3, #0]
 800794a:	2b00      	cmp	r3, #0
 800794c:	d1ee      	bne.n	800792c <dns_send+0xe4>
      }
      copy_len = (u16_t)(hostname - hostname_part);
 800794e:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8007950:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007952:	1ad2      	subs	r2, r2, r3
 8007954:	2326      	movs	r3, #38	; 0x26
 8007956:	18fb      	adds	r3, r7, r3
 8007958:	801a      	strh	r2, [r3, #0]
      if (query_idx + n + 1 > 0xFFFF) {
 800795a:	253c      	movs	r5, #60	; 0x3c
 800795c:	197b      	adds	r3, r7, r5
 800795e:	881a      	ldrh	r2, [r3, #0]
 8007960:	2637      	movs	r6, #55	; 0x37
 8007962:	19bb      	adds	r3, r7, r6
 8007964:	781b      	ldrb	r3, [r3, #0]
 8007966:	18d3      	adds	r3, r2, r3
 8007968:	4a42      	ldr	r2, [pc, #264]	; (8007a74 <dns_send+0x22c>)
 800796a:	4293      	cmp	r3, r2
 800796c:	dc6a      	bgt.n	8007a44 <dns_send+0x1fc>
        /* u16_t overflow */
        goto overflow_return;
      }
      pbuf_put_at(p, query_idx, n);
 800796e:	19bb      	adds	r3, r7, r6
 8007970:	781a      	ldrb	r2, [r3, #0]
 8007972:	197b      	adds	r3, r7, r5
 8007974:	8819      	ldrh	r1, [r3, #0]
 8007976:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007978:	0018      	movs	r0, r3
 800797a:	f003 fb0b 	bl	800af94 <pbuf_put_at>
      pbuf_take_at(p, hostname_part, copy_len, (u16_t)(query_idx + 1));
 800797e:	197b      	adds	r3, r7, r5
 8007980:	881b      	ldrh	r3, [r3, #0]
 8007982:	3301      	adds	r3, #1
 8007984:	b29c      	uxth	r4, r3
 8007986:	2326      	movs	r3, #38	; 0x26
 8007988:	18fb      	adds	r3, r7, r3
 800798a:	881a      	ldrh	r2, [r3, #0]
 800798c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800798e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8007990:	0023      	movs	r3, r4
 8007992:	f003 f9d3 	bl	800ad3c <pbuf_take_at>
      query_idx = (u16_t)(query_idx + n + 1);
 8007996:	19bb      	adds	r3, r7, r6
 8007998:	781b      	ldrb	r3, [r3, #0]
 800799a:	b29a      	uxth	r2, r3
 800799c:	197b      	adds	r3, r7, r5
 800799e:	881b      	ldrh	r3, [r3, #0]
 80079a0:	18d3      	adds	r3, r2, r3
 80079a2:	b29a      	uxth	r2, r3
 80079a4:	197b      	adds	r3, r7, r5
 80079a6:	3201      	adds	r2, #1
 80079a8:	801a      	strh	r2, [r3, #0]
    } while (*hostname != 0);
 80079aa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80079ac:	781b      	ldrb	r3, [r3, #0]
 80079ae:	2b00      	cmp	r3, #0
 80079b0:	d1b2      	bne.n	8007918 <dns_send+0xd0>
    pbuf_put_at(p, query_idx, 0);
 80079b2:	197b      	adds	r3, r7, r5
 80079b4:	8819      	ldrh	r1, [r3, #0]
 80079b6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80079b8:	2200      	movs	r2, #0
 80079ba:	0018      	movs	r0, r3
 80079bc:	f003 faea 	bl	800af94 <pbuf_put_at>
    query_idx++;
 80079c0:	0029      	movs	r1, r5
 80079c2:	187b      	adds	r3, r7, r1
 80079c4:	881a      	ldrh	r2, [r3, #0]
 80079c6:	187b      	adds	r3, r7, r1
 80079c8:	3201      	adds	r2, #1
 80079ca:	801a      	strh	r2, [r3, #0]

    /* fill dns query */
    if (LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype)) {
      qry.type = PP_HTONS(DNS_RRTYPE_AAAA);
    } else {
      qry.type = PP_HTONS(DNS_RRTYPE_A);
 80079cc:	200c      	movs	r0, #12
 80079ce:	183b      	adds	r3, r7, r0
 80079d0:	2280      	movs	r2, #128	; 0x80
 80079d2:	0052      	lsls	r2, r2, #1
 80079d4:	801a      	strh	r2, [r3, #0]
    }
    qry.cls = PP_HTONS(DNS_RRCLASS_IN);
 80079d6:	183b      	adds	r3, r7, r0
 80079d8:	2280      	movs	r2, #128	; 0x80
 80079da:	0052      	lsls	r2, r2, #1
 80079dc:	805a      	strh	r2, [r3, #2]
    pbuf_take_at(p, &qry, SIZEOF_DNS_QUERY, query_idx);
 80079de:	187b      	adds	r3, r7, r1
 80079e0:	881b      	ldrh	r3, [r3, #0]
 80079e2:	1839      	adds	r1, r7, r0
 80079e4:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80079e6:	2204      	movs	r2, #4
 80079e8:	f003 f9a8 	bl	800ad3c <pbuf_take_at>

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) != 0)
    pcb_idx = entry->pcb_idx;
 80079ec:	2125      	movs	r1, #37	; 0x25
 80079ee:	187b      	adds	r3, r7, r1
 80079f0:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80079f2:	7bd2      	ldrb	r2, [r2, #15]
 80079f4:	701a      	strb	r2, [r3, #0]
      }
#endif
    } else
#endif /* LWIP_DNS_SUPPORT_MDNS_QUERIES */
    {
      dst_port = DNS_SERVER_PORT;
 80079f6:	2522      	movs	r5, #34	; 0x22
 80079f8:	197b      	adds	r3, r7, r5
 80079fa:	2235      	movs	r2, #53	; 0x35
 80079fc:	801a      	strh	r2, [r3, #0]
      dst = &dns_servers[entry->server_idx];
 80079fe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007a00:	7adb      	ldrb	r3, [r3, #11]
 8007a02:	009a      	lsls	r2, r3, #2
 8007a04:	4b1a      	ldr	r3, [pc, #104]	; (8007a70 <dns_send+0x228>)
 8007a06:	18d3      	adds	r3, r2, r3
 8007a08:	61fb      	str	r3, [r7, #28]
    }
    err = udp_sendto(dns_pcbs[pcb_idx], p, dst, dst_port);
 8007a0a:	187b      	adds	r3, r7, r1
 8007a0c:	781a      	ldrb	r2, [r3, #0]
 8007a0e:	4b1a      	ldr	r3, [pc, #104]	; (8007a78 <dns_send+0x230>)
 8007a10:	0092      	lsls	r2, r2, #2
 8007a12:	58d0      	ldr	r0, [r2, r3]
 8007a14:	233f      	movs	r3, #63	; 0x3f
 8007a16:	18fc      	adds	r4, r7, r3
 8007a18:	197b      	adds	r3, r7, r5
 8007a1a:	881b      	ldrh	r3, [r3, #0]
 8007a1c:	69fa      	ldr	r2, [r7, #28]
 8007a1e:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8007a20:	f00b fae0 	bl	8012fe4 <udp_sendto>
 8007a24:	0003      	movs	r3, r0
 8007a26:	7023      	strb	r3, [r4, #0]

    /* free pbuf */
    pbuf_free(p);
 8007a28:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007a2a:	0018      	movs	r0, r3
 8007a2c:	f002 fd56 	bl	800a4dc <pbuf_free>
 8007a30:	e003      	b.n	8007a3a <dns_send+0x1f2>
  } else {
    err = ERR_MEM;
 8007a32:	233f      	movs	r3, #63	; 0x3f
 8007a34:	18fb      	adds	r3, r7, r3
 8007a36:	22ff      	movs	r2, #255	; 0xff
 8007a38:	701a      	strb	r2, [r3, #0]
  }

  return err;
 8007a3a:	233f      	movs	r3, #63	; 0x3f
 8007a3c:	18fb      	adds	r3, r7, r3
 8007a3e:	781b      	ldrb	r3, [r3, #0]
 8007a40:	b25b      	sxtb	r3, r3
 8007a42:	e006      	b.n	8007a52 <dns_send+0x20a>
        goto overflow_return;
 8007a44:	46c0      	nop			; (mov r8, r8)
overflow_return:
  pbuf_free(p);
 8007a46:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007a48:	0018      	movs	r0, r3
 8007a4a:	f002 fd47 	bl	800a4dc <pbuf_free>
  return ERR_VAL;
 8007a4e:	2306      	movs	r3, #6
 8007a50:	425b      	negs	r3, r3
}
 8007a52:	0018      	movs	r0, r3
 8007a54:	46bd      	mov	sp, r7
 8007a56:	b011      	add	sp, #68	; 0x44
 8007a58:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007a5a:	46c0      	nop			; (mov r8, r8)
 8007a5c:	20000a40 	.word	0x20000a40
 8007a60:	0801fe4c 	.word	0x0801fe4c
 8007a64:	000002fa 	.word	0x000002fa
 8007a68:	0801fe74 	.word	0x0801fe74
 8007a6c:	0801fe8c 	.word	0x0801fe8c
 8007a70:	20000c14 	.word	0x20000c14
 8007a74:	0000fffe 	.word	0x0000fffe
 8007a78:	20000a30 	.word	0x20000a30

08007a7c <dns_alloc_random_port>:

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) != 0)
static struct udp_pcb *
dns_alloc_random_port(void)
{
 8007a7c:	b590      	push	{r4, r7, lr}
 8007a7e:	b085      	sub	sp, #20
 8007a80:	af00      	add	r7, sp, #0
  err_t err;
  struct udp_pcb *pcb;

  pcb = udp_new_ip_type(IPADDR_TYPE_ANY);
 8007a82:	202e      	movs	r0, #46	; 0x2e
 8007a84:	f00b fe25 	bl	80136d2 <udp_new_ip_type>
 8007a88:	0003      	movs	r3, r0
 8007a8a:	60bb      	str	r3, [r7, #8]
  if (pcb == NULL) {
 8007a8c:	68bb      	ldr	r3, [r7, #8]
 8007a8e:	2b00      	cmp	r3, #0
 8007a90:	d101      	bne.n	8007a96 <dns_alloc_random_port+0x1a>
    /* out of memory, have to reuse an existing pcb */
    return NULL;
 8007a92:	2300      	movs	r3, #0
 8007a94:	e032      	b.n	8007afc <dns_alloc_random_port+0x80>
  }
  do {
    u16_t port = (u16_t)DNS_RAND_TXID();
 8007a96:	f016 fa23 	bl	801dee0 <sys_rand>
 8007a9a:	0002      	movs	r2, r0
 8007a9c:	1dbb      	adds	r3, r7, #6
 8007a9e:	801a      	strh	r2, [r3, #0]
    if (DNS_PORT_ALLOWED(port)) {
 8007aa0:	1dbb      	adds	r3, r7, #6
 8007aa2:	881a      	ldrh	r2, [r3, #0]
 8007aa4:	2380      	movs	r3, #128	; 0x80
 8007aa6:	00db      	lsls	r3, r3, #3
 8007aa8:	429a      	cmp	r2, r3
 8007aaa:	d30b      	bcc.n	8007ac4 <dns_alloc_random_port+0x48>
      err = udp_bind(pcb, IP_ANY_TYPE, port);
 8007aac:	230f      	movs	r3, #15
 8007aae:	18fc      	adds	r4, r7, r3
 8007ab0:	1dbb      	adds	r3, r7, #6
 8007ab2:	881a      	ldrh	r2, [r3, #0]
 8007ab4:	4913      	ldr	r1, [pc, #76]	; (8007b04 <dns_alloc_random_port+0x88>)
 8007ab6:	68bb      	ldr	r3, [r7, #8]
 8007ab8:	0018      	movs	r0, r3
 8007aba:	f00b fd03 	bl	80134c4 <udp_bind>
 8007abe:	0003      	movs	r3, r0
 8007ac0:	7023      	strb	r3, [r4, #0]
 8007ac2:	e003      	b.n	8007acc <dns_alloc_random_port+0x50>
    } else {
      /* this port is not allowed, try again */
      err = ERR_USE;
 8007ac4:	230f      	movs	r3, #15
 8007ac6:	18fb      	adds	r3, r7, r3
 8007ac8:	22f8      	movs	r2, #248	; 0xf8
 8007aca:	701a      	strb	r2, [r3, #0]
    }
  } while (err == ERR_USE);
 8007acc:	220f      	movs	r2, #15
 8007ace:	18bb      	adds	r3, r7, r2
 8007ad0:	781b      	ldrb	r3, [r3, #0]
 8007ad2:	b25b      	sxtb	r3, r3
 8007ad4:	3308      	adds	r3, #8
 8007ad6:	d0de      	beq.n	8007a96 <dns_alloc_random_port+0x1a>
  if (err != ERR_OK) {
 8007ad8:	18bb      	adds	r3, r7, r2
 8007ada:	781b      	ldrb	r3, [r3, #0]
 8007adc:	b25b      	sxtb	r3, r3
 8007ade:	2b00      	cmp	r3, #0
 8007ae0:	d005      	beq.n	8007aee <dns_alloc_random_port+0x72>
    udp_remove(pcb);
 8007ae2:	68bb      	ldr	r3, [r7, #8]
 8007ae4:	0018      	movs	r0, r3
 8007ae6:	f00b fd9f 	bl	8013628 <udp_remove>
    return NULL;
 8007aea:	2300      	movs	r3, #0
 8007aec:	e006      	b.n	8007afc <dns_alloc_random_port+0x80>
  }
  udp_recv(pcb, dns_recv, NULL);
 8007aee:	4906      	ldr	r1, [pc, #24]	; (8007b08 <dns_alloc_random_port+0x8c>)
 8007af0:	68bb      	ldr	r3, [r7, #8]
 8007af2:	2200      	movs	r2, #0
 8007af4:	0018      	movs	r0, r3
 8007af6:	f00b fd7d 	bl	80135f4 <udp_recv>
  return pcb;
 8007afa:	68bb      	ldr	r3, [r7, #8]
}
 8007afc:	0018      	movs	r0, r3
 8007afe:	46bd      	mov	sp, r7
 8007b00:	b005      	add	sp, #20
 8007b02:	bd90      	pop	{r4, r7, pc}
 8007b04:	08023a8c 	.word	0x08023a8c
 8007b08:	0800805d 	.word	0x0800805d

08007b0c <dns_alloc_pcb>:
 *
 * @return an index into dns_pcbs
 */
static u8_t
dns_alloc_pcb(void)
{
 8007b0c:	b590      	push	{r4, r7, lr}
 8007b0e:	b083      	sub	sp, #12
 8007b10:	af00      	add	r7, sp, #0
  u8_t i;
  u8_t idx;

  for (i = 0; i < DNS_MAX_SOURCE_PORTS; i++) {
 8007b12:	1dfb      	adds	r3, r7, #7
 8007b14:	2200      	movs	r2, #0
 8007b16:	701a      	strb	r2, [r3, #0]
 8007b18:	e00b      	b.n	8007b32 <dns_alloc_pcb+0x26>
    if (dns_pcbs[i] == NULL) {
 8007b1a:	1dfb      	adds	r3, r7, #7
 8007b1c:	781a      	ldrb	r2, [r3, #0]
 8007b1e:	4b2d      	ldr	r3, [pc, #180]	; (8007bd4 <dns_alloc_pcb+0xc8>)
 8007b20:	0092      	lsls	r2, r2, #2
 8007b22:	58d3      	ldr	r3, [r2, r3]
 8007b24:	2b00      	cmp	r3, #0
 8007b26:	d009      	beq.n	8007b3c <dns_alloc_pcb+0x30>
  for (i = 0; i < DNS_MAX_SOURCE_PORTS; i++) {
 8007b28:	1dfb      	adds	r3, r7, #7
 8007b2a:	781a      	ldrb	r2, [r3, #0]
 8007b2c:	1dfb      	adds	r3, r7, #7
 8007b2e:	3201      	adds	r2, #1
 8007b30:	701a      	strb	r2, [r3, #0]
 8007b32:	1dfb      	adds	r3, r7, #7
 8007b34:	781b      	ldrb	r3, [r3, #0]
 8007b36:	2b02      	cmp	r3, #2
 8007b38:	d9ef      	bls.n	8007b1a <dns_alloc_pcb+0xe>
 8007b3a:	e000      	b.n	8007b3e <dns_alloc_pcb+0x32>
      break;
 8007b3c:	46c0      	nop			; (mov r8, r8)
    }
  }
  if (i < DNS_MAX_SOURCE_PORTS) {
 8007b3e:	1dfb      	adds	r3, r7, #7
 8007b40:	781b      	ldrb	r3, [r3, #0]
 8007b42:	2b02      	cmp	r3, #2
 8007b44:	d815      	bhi.n	8007b72 <dns_alloc_pcb+0x66>
    dns_pcbs[i] = dns_alloc_random_port();
 8007b46:	1dfb      	adds	r3, r7, #7
 8007b48:	781c      	ldrb	r4, [r3, #0]
 8007b4a:	f7ff ff97 	bl	8007a7c <dns_alloc_random_port>
 8007b4e:	0001      	movs	r1, r0
 8007b50:	4b20      	ldr	r3, [pc, #128]	; (8007bd4 <dns_alloc_pcb+0xc8>)
 8007b52:	00a2      	lsls	r2, r4, #2
 8007b54:	50d1      	str	r1, [r2, r3]
    if (dns_pcbs[i] != NULL) {
 8007b56:	1dfb      	adds	r3, r7, #7
 8007b58:	781a      	ldrb	r2, [r3, #0]
 8007b5a:	4b1e      	ldr	r3, [pc, #120]	; (8007bd4 <dns_alloc_pcb+0xc8>)
 8007b5c:	0092      	lsls	r2, r2, #2
 8007b5e:	58d3      	ldr	r3, [r2, r3]
 8007b60:	2b00      	cmp	r3, #0
 8007b62:	d006      	beq.n	8007b72 <dns_alloc_pcb+0x66>
      /* succeeded */
      dns_last_pcb_idx = i;
 8007b64:	4b1c      	ldr	r3, [pc, #112]	; (8007bd8 <dns_alloc_pcb+0xcc>)
 8007b66:	1dfa      	adds	r2, r7, #7
 8007b68:	7812      	ldrb	r2, [r2, #0]
 8007b6a:	701a      	strb	r2, [r3, #0]
      return i;
 8007b6c:	1dfb      	adds	r3, r7, #7
 8007b6e:	781b      	ldrb	r3, [r3, #0]
 8007b70:	e02c      	b.n	8007bcc <dns_alloc_pcb+0xc0>
    }
  }
  /* if we come here, creating a new UDP pcb failed, so we have to use
     an already existing one (so overflow is no issue) */
  for (i = 0, idx = (u8_t)(dns_last_pcb_idx + 1); i < DNS_MAX_SOURCE_PORTS; i++, idx++) {
 8007b72:	1dfb      	adds	r3, r7, #7
 8007b74:	2200      	movs	r2, #0
 8007b76:	701a      	strb	r2, [r3, #0]
 8007b78:	4b17      	ldr	r3, [pc, #92]	; (8007bd8 <dns_alloc_pcb+0xcc>)
 8007b7a:	781a      	ldrb	r2, [r3, #0]
 8007b7c:	1dbb      	adds	r3, r7, #6
 8007b7e:	3201      	adds	r2, #1
 8007b80:	701a      	strb	r2, [r3, #0]
 8007b82:	e01e      	b.n	8007bc2 <dns_alloc_pcb+0xb6>
    if (idx >= DNS_MAX_SOURCE_PORTS) {
 8007b84:	1dbb      	adds	r3, r7, #6
 8007b86:	781b      	ldrb	r3, [r3, #0]
 8007b88:	2b02      	cmp	r3, #2
 8007b8a:	d902      	bls.n	8007b92 <dns_alloc_pcb+0x86>
      idx = 0;
 8007b8c:	1dbb      	adds	r3, r7, #6
 8007b8e:	2200      	movs	r2, #0
 8007b90:	701a      	strb	r2, [r3, #0]
    }
    if (dns_pcbs[idx] != NULL) {
 8007b92:	1dbb      	adds	r3, r7, #6
 8007b94:	781a      	ldrb	r2, [r3, #0]
 8007b96:	4b0f      	ldr	r3, [pc, #60]	; (8007bd4 <dns_alloc_pcb+0xc8>)
 8007b98:	0092      	lsls	r2, r2, #2
 8007b9a:	58d3      	ldr	r3, [r2, r3]
 8007b9c:	2b00      	cmp	r3, #0
 8007b9e:	d006      	beq.n	8007bae <dns_alloc_pcb+0xa2>
      dns_last_pcb_idx = idx;
 8007ba0:	4b0d      	ldr	r3, [pc, #52]	; (8007bd8 <dns_alloc_pcb+0xcc>)
 8007ba2:	1dba      	adds	r2, r7, #6
 8007ba4:	7812      	ldrb	r2, [r2, #0]
 8007ba6:	701a      	strb	r2, [r3, #0]
      return idx;
 8007ba8:	1dbb      	adds	r3, r7, #6
 8007baa:	781b      	ldrb	r3, [r3, #0]
 8007bac:	e00e      	b.n	8007bcc <dns_alloc_pcb+0xc0>
  for (i = 0, idx = (u8_t)(dns_last_pcb_idx + 1); i < DNS_MAX_SOURCE_PORTS; i++, idx++) {
 8007bae:	1dfb      	adds	r3, r7, #7
 8007bb0:	781a      	ldrb	r2, [r3, #0]
 8007bb2:	1dfb      	adds	r3, r7, #7
 8007bb4:	3201      	adds	r2, #1
 8007bb6:	701a      	strb	r2, [r3, #0]
 8007bb8:	1dbb      	adds	r3, r7, #6
 8007bba:	781a      	ldrb	r2, [r3, #0]
 8007bbc:	1dbb      	adds	r3, r7, #6
 8007bbe:	3201      	adds	r2, #1
 8007bc0:	701a      	strb	r2, [r3, #0]
 8007bc2:	1dfb      	adds	r3, r7, #7
 8007bc4:	781b      	ldrb	r3, [r3, #0]
 8007bc6:	2b02      	cmp	r3, #2
 8007bc8:	d9dc      	bls.n	8007b84 <dns_alloc_pcb+0x78>
    }
  }
  return DNS_MAX_SOURCE_PORTS;
 8007bca:	2303      	movs	r3, #3
}
 8007bcc:	0018      	movs	r0, r3
 8007bce:	46bd      	mov	sp, r7
 8007bd0:	b003      	add	sp, #12
 8007bd2:	bd90      	pop	{r4, r7, pc}
 8007bd4:	20000a30 	.word	0x20000a30
 8007bd8:	20000a3c 	.word	0x20000a3c

08007bdc <dns_call_found>:
 * @param idx dns table index of the entry that is resolved or removed
 * @param addr IP address for the hostname (or NULL on error or memory shortage)
 */
static void
dns_call_found(u8_t idx, ip_addr_t *addr)
{
 8007bdc:	b5b0      	push	{r4, r5, r7, lr}
 8007bde:	b084      	sub	sp, #16
 8007be0:	af00      	add	r7, sp, #0
 8007be2:	0002      	movs	r2, r0
 8007be4:	6039      	str	r1, [r7, #0]
 8007be6:	1dfb      	adds	r3, r7, #7
 8007be8:	701a      	strb	r2, [r3, #0]
    }
  }
#endif /* LWIP_IPV4 && LWIP_IPV6 */

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING) != 0)
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
 8007bea:	230f      	movs	r3, #15
 8007bec:	18fb      	adds	r3, r7, r3
 8007bee:	2200      	movs	r2, #0
 8007bf0:	701a      	strb	r2, [r3, #0]
 8007bf2:	e046      	b.n	8007c82 <dns_call_found+0xa6>
    if (dns_requests[i].found && (dns_requests[i].dns_table_idx == idx)) {
 8007bf4:	250f      	movs	r5, #15
 8007bf6:	197b      	adds	r3, r7, r5
 8007bf8:	781a      	ldrb	r2, [r3, #0]
 8007bfa:	4964      	ldr	r1, [pc, #400]	; (8007d8c <dns_call_found+0x1b0>)
 8007bfc:	0013      	movs	r3, r2
 8007bfe:	005b      	lsls	r3, r3, #1
 8007c00:	189b      	adds	r3, r3, r2
 8007c02:	009b      	lsls	r3, r3, #2
 8007c04:	585b      	ldr	r3, [r3, r1]
 8007c06:	2b00      	cmp	r3, #0
 8007c08:	d035      	beq.n	8007c76 <dns_call_found+0x9a>
 8007c0a:	197b      	adds	r3, r7, r5
 8007c0c:	781a      	ldrb	r2, [r3, #0]
 8007c0e:	495f      	ldr	r1, [pc, #380]	; (8007d8c <dns_call_found+0x1b0>)
 8007c10:	0013      	movs	r3, r2
 8007c12:	005b      	lsls	r3, r3, #1
 8007c14:	189b      	adds	r3, r3, r2
 8007c16:	009b      	lsls	r3, r3, #2
 8007c18:	18cb      	adds	r3, r1, r3
 8007c1a:	3308      	adds	r3, #8
 8007c1c:	781b      	ldrb	r3, [r3, #0]
 8007c1e:	1dfa      	adds	r2, r7, #7
 8007c20:	7812      	ldrb	r2, [r2, #0]
 8007c22:	429a      	cmp	r2, r3
 8007c24:	d127      	bne.n	8007c76 <dns_call_found+0x9a>
      (*dns_requests[i].found)(dns_table[idx].name, addr, dns_requests[i].arg);
 8007c26:	197b      	adds	r3, r7, r5
 8007c28:	781a      	ldrb	r2, [r3, #0]
 8007c2a:	4958      	ldr	r1, [pc, #352]	; (8007d8c <dns_call_found+0x1b0>)
 8007c2c:	0013      	movs	r3, r2
 8007c2e:	005b      	lsls	r3, r3, #1
 8007c30:	189b      	adds	r3, r3, r2
 8007c32:	009b      	lsls	r3, r3, #2
 8007c34:	585c      	ldr	r4, [r3, r1]
 8007c36:	1dfb      	adds	r3, r7, #7
 8007c38:	781a      	ldrb	r2, [r3, #0]
 8007c3a:	0013      	movs	r3, r2
 8007c3c:	00db      	lsls	r3, r3, #3
 8007c3e:	189b      	adds	r3, r3, r2
 8007c40:	011b      	lsls	r3, r3, #4
 8007c42:	3310      	adds	r3, #16
 8007c44:	001a      	movs	r2, r3
 8007c46:	4b52      	ldr	r3, [pc, #328]	; (8007d90 <dns_call_found+0x1b4>)
 8007c48:	18d0      	adds	r0, r2, r3
 8007c4a:	197b      	adds	r3, r7, r5
 8007c4c:	781a      	ldrb	r2, [r3, #0]
 8007c4e:	494f      	ldr	r1, [pc, #316]	; (8007d8c <dns_call_found+0x1b0>)
 8007c50:	0013      	movs	r3, r2
 8007c52:	005b      	lsls	r3, r3, #1
 8007c54:	189b      	adds	r3, r3, r2
 8007c56:	009b      	lsls	r3, r3, #2
 8007c58:	18cb      	adds	r3, r1, r3
 8007c5a:	3304      	adds	r3, #4
 8007c5c:	681a      	ldr	r2, [r3, #0]
 8007c5e:	683b      	ldr	r3, [r7, #0]
 8007c60:	0019      	movs	r1, r3
 8007c62:	47a0      	blx	r4
      /* flush this entry */
      dns_requests[i].found = NULL;
 8007c64:	197b      	adds	r3, r7, r5
 8007c66:	781a      	ldrb	r2, [r3, #0]
 8007c68:	4948      	ldr	r1, [pc, #288]	; (8007d8c <dns_call_found+0x1b0>)
 8007c6a:	0013      	movs	r3, r2
 8007c6c:	005b      	lsls	r3, r3, #1
 8007c6e:	189b      	adds	r3, r3, r2
 8007c70:	009b      	lsls	r3, r3, #2
 8007c72:	2200      	movs	r2, #0
 8007c74:	505a      	str	r2, [r3, r1]
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
 8007c76:	210f      	movs	r1, #15
 8007c78:	187b      	adds	r3, r7, r1
 8007c7a:	781a      	ldrb	r2, [r3, #0]
 8007c7c:	187b      	adds	r3, r7, r1
 8007c7e:	3201      	adds	r2, #1
 8007c80:	701a      	strb	r2, [r3, #0]
 8007c82:	220f      	movs	r2, #15
 8007c84:	18bb      	adds	r3, r7, r2
 8007c86:	781b      	ldrb	r3, [r3, #0]
 8007c88:	2b02      	cmp	r3, #2
 8007c8a:	d9b3      	bls.n	8007bf4 <dns_call_found+0x18>
  }
  dns_requests[idx].found = NULL;
#endif
#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) != 0)
  /* close the pcb used unless other request are using it */
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
 8007c8c:	18bb      	adds	r3, r7, r2
 8007c8e:	2200      	movs	r2, #0
 8007c90:	701a      	strb	r2, [r3, #0]
 8007c92:	e03b      	b.n	8007d0c <dns_call_found+0x130>
    if (i == idx) {
 8007c94:	200f      	movs	r0, #15
 8007c96:	183a      	adds	r2, r7, r0
 8007c98:	1dfb      	adds	r3, r7, #7
 8007c9a:	7812      	ldrb	r2, [r2, #0]
 8007c9c:	781b      	ldrb	r3, [r3, #0]
 8007c9e:	429a      	cmp	r2, r3
 8007ca0:	d02d      	beq.n	8007cfe <dns_call_found+0x122>
      continue; /* only check other requests */
    }
    if (dns_table[i].state == DNS_STATE_ASKING) {
 8007ca2:	183b      	adds	r3, r7, r0
 8007ca4:	781a      	ldrb	r2, [r3, #0]
 8007ca6:	493a      	ldr	r1, [pc, #232]	; (8007d90 <dns_call_found+0x1b4>)
 8007ca8:	0013      	movs	r3, r2
 8007caa:	00db      	lsls	r3, r3, #3
 8007cac:	189b      	adds	r3, r3, r2
 8007cae:	011b      	lsls	r3, r3, #4
 8007cb0:	18cb      	adds	r3, r1, r3
 8007cb2:	330a      	adds	r3, #10
 8007cb4:	781b      	ldrb	r3, [r3, #0]
 8007cb6:	2b02      	cmp	r3, #2
 8007cb8:	d122      	bne.n	8007d00 <dns_call_found+0x124>
      if (dns_table[i].pcb_idx == dns_table[idx].pcb_idx) {
 8007cba:	183b      	adds	r3, r7, r0
 8007cbc:	781a      	ldrb	r2, [r3, #0]
 8007cbe:	4934      	ldr	r1, [pc, #208]	; (8007d90 <dns_call_found+0x1b4>)
 8007cc0:	0013      	movs	r3, r2
 8007cc2:	00db      	lsls	r3, r3, #3
 8007cc4:	189b      	adds	r3, r3, r2
 8007cc6:	011b      	lsls	r3, r3, #4
 8007cc8:	18cb      	adds	r3, r1, r3
 8007cca:	330f      	adds	r3, #15
 8007ccc:	7819      	ldrb	r1, [r3, #0]
 8007cce:	1dfb      	adds	r3, r7, #7
 8007cd0:	781a      	ldrb	r2, [r3, #0]
 8007cd2:	482f      	ldr	r0, [pc, #188]	; (8007d90 <dns_call_found+0x1b4>)
 8007cd4:	0013      	movs	r3, r2
 8007cd6:	00db      	lsls	r3, r3, #3
 8007cd8:	189b      	adds	r3, r3, r2
 8007cda:	011b      	lsls	r3, r3, #4
 8007cdc:	18c3      	adds	r3, r0, r3
 8007cde:	330f      	adds	r3, #15
 8007ce0:	781b      	ldrb	r3, [r3, #0]
 8007ce2:	4299      	cmp	r1, r3
 8007ce4:	d10c      	bne.n	8007d00 <dns_call_found+0x124>
        /* another request is still using the same pcb */
        dns_table[idx].pcb_idx = DNS_MAX_SOURCE_PORTS;
 8007ce6:	1dfb      	adds	r3, r7, #7
 8007ce8:	781a      	ldrb	r2, [r3, #0]
 8007cea:	4929      	ldr	r1, [pc, #164]	; (8007d90 <dns_call_found+0x1b4>)
 8007cec:	0013      	movs	r3, r2
 8007cee:	00db      	lsls	r3, r3, #3
 8007cf0:	189b      	adds	r3, r3, r2
 8007cf2:	011b      	lsls	r3, r3, #4
 8007cf4:	18cb      	adds	r3, r1, r3
 8007cf6:	330f      	adds	r3, #15
 8007cf8:	2203      	movs	r2, #3
 8007cfa:	701a      	strb	r2, [r3, #0]
        break;
 8007cfc:	e00b      	b.n	8007d16 <dns_call_found+0x13a>
      continue; /* only check other requests */
 8007cfe:	46c0      	nop			; (mov r8, r8)
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
 8007d00:	210f      	movs	r1, #15
 8007d02:	187b      	adds	r3, r7, r1
 8007d04:	781a      	ldrb	r2, [r3, #0]
 8007d06:	187b      	adds	r3, r7, r1
 8007d08:	3201      	adds	r2, #1
 8007d0a:	701a      	strb	r2, [r3, #0]
 8007d0c:	230f      	movs	r3, #15
 8007d0e:	18fb      	adds	r3, r7, r3
 8007d10:	781b      	ldrb	r3, [r3, #0]
 8007d12:	2b02      	cmp	r3, #2
 8007d14:	d9be      	bls.n	8007c94 <dns_call_found+0xb8>
      }
    }
  }
  if (dns_table[idx].pcb_idx < DNS_MAX_SOURCE_PORTS) {
 8007d16:	1dfb      	adds	r3, r7, #7
 8007d18:	781a      	ldrb	r2, [r3, #0]
 8007d1a:	491d      	ldr	r1, [pc, #116]	; (8007d90 <dns_call_found+0x1b4>)
 8007d1c:	0013      	movs	r3, r2
 8007d1e:	00db      	lsls	r3, r3, #3
 8007d20:	189b      	adds	r3, r3, r2
 8007d22:	011b      	lsls	r3, r3, #4
 8007d24:	18cb      	adds	r3, r1, r3
 8007d26:	330f      	adds	r3, #15
 8007d28:	781b      	ldrb	r3, [r3, #0]
 8007d2a:	2b02      	cmp	r3, #2
 8007d2c:	d82a      	bhi.n	8007d84 <dns_call_found+0x1a8>
    /* if we come here, the pcb is not used any more and can be removed */
    udp_remove(dns_pcbs[dns_table[idx].pcb_idx]);
 8007d2e:	1dfb      	adds	r3, r7, #7
 8007d30:	781a      	ldrb	r2, [r3, #0]
 8007d32:	4917      	ldr	r1, [pc, #92]	; (8007d90 <dns_call_found+0x1b4>)
 8007d34:	0013      	movs	r3, r2
 8007d36:	00db      	lsls	r3, r3, #3
 8007d38:	189b      	adds	r3, r3, r2
 8007d3a:	011b      	lsls	r3, r3, #4
 8007d3c:	18cb      	adds	r3, r1, r3
 8007d3e:	330f      	adds	r3, #15
 8007d40:	781b      	ldrb	r3, [r3, #0]
 8007d42:	001a      	movs	r2, r3
 8007d44:	4b13      	ldr	r3, [pc, #76]	; (8007d94 <dns_call_found+0x1b8>)
 8007d46:	0092      	lsls	r2, r2, #2
 8007d48:	58d3      	ldr	r3, [r2, r3]
 8007d4a:	0018      	movs	r0, r3
 8007d4c:	f00b fc6c 	bl	8013628 <udp_remove>
    dns_pcbs[dns_table[idx].pcb_idx] = NULL;
 8007d50:	1dfb      	adds	r3, r7, #7
 8007d52:	781a      	ldrb	r2, [r3, #0]
 8007d54:	490e      	ldr	r1, [pc, #56]	; (8007d90 <dns_call_found+0x1b4>)
 8007d56:	0013      	movs	r3, r2
 8007d58:	00db      	lsls	r3, r3, #3
 8007d5a:	189b      	adds	r3, r3, r2
 8007d5c:	011b      	lsls	r3, r3, #4
 8007d5e:	18cb      	adds	r3, r1, r3
 8007d60:	330f      	adds	r3, #15
 8007d62:	781b      	ldrb	r3, [r3, #0]
 8007d64:	001a      	movs	r2, r3
 8007d66:	4b0b      	ldr	r3, [pc, #44]	; (8007d94 <dns_call_found+0x1b8>)
 8007d68:	0092      	lsls	r2, r2, #2
 8007d6a:	2100      	movs	r1, #0
 8007d6c:	50d1      	str	r1, [r2, r3]
    dns_table[idx].pcb_idx = DNS_MAX_SOURCE_PORTS;
 8007d6e:	1dfb      	adds	r3, r7, #7
 8007d70:	781a      	ldrb	r2, [r3, #0]
 8007d72:	4907      	ldr	r1, [pc, #28]	; (8007d90 <dns_call_found+0x1b4>)
 8007d74:	0013      	movs	r3, r2
 8007d76:	00db      	lsls	r3, r3, #3
 8007d78:	189b      	adds	r3, r3, r2
 8007d7a:	011b      	lsls	r3, r3, #4
 8007d7c:	18cb      	adds	r3, r1, r3
 8007d7e:	330f      	adds	r3, #15
 8007d80:	2203      	movs	r2, #3
 8007d82:	701a      	strb	r2, [r3, #0]
  }
#endif
}
 8007d84:	46c0      	nop			; (mov r8, r8)
 8007d86:	46bd      	mov	sp, r7
 8007d88:	b004      	add	sp, #16
 8007d8a:	bdb0      	pop	{r4, r5, r7, pc}
 8007d8c:	20000bf0 	.word	0x20000bf0
 8007d90:	20000a40 	.word	0x20000a40
 8007d94:	20000a30 	.word	0x20000a30

08007d98 <dns_create_txid>:

/* Create a query transmission ID that is unique for all outstanding queries */
static u16_t
dns_create_txid(void)
{
 8007d98:	b580      	push	{r7, lr}
 8007d9a:	b082      	sub	sp, #8
 8007d9c:	af00      	add	r7, sp, #0
  u16_t txid;
  u8_t i;

again:
  txid = (u16_t)DNS_RAND_TXID();
 8007d9e:	f016 f89f 	bl	801dee0 <sys_rand>
 8007da2:	0002      	movs	r2, r0
 8007da4:	1d3b      	adds	r3, r7, #4
 8007da6:	801a      	strh	r2, [r3, #0]

  /* check whether the ID is unique */
  for (i = 0; i < DNS_TABLE_SIZE; i++) {
 8007da8:	1dfb      	adds	r3, r7, #7
 8007daa:	2200      	movs	r2, #0
 8007dac:	701a      	strb	r2, [r3, #0]
 8007dae:	e01f      	b.n	8007df0 <dns_create_txid+0x58>
    if ((dns_table[i].state == DNS_STATE_ASKING) &&
 8007db0:	1dfb      	adds	r3, r7, #7
 8007db2:	781a      	ldrb	r2, [r3, #0]
 8007db4:	4913      	ldr	r1, [pc, #76]	; (8007e04 <dns_create_txid+0x6c>)
 8007db6:	0013      	movs	r3, r2
 8007db8:	00db      	lsls	r3, r3, #3
 8007dba:	189b      	adds	r3, r3, r2
 8007dbc:	011b      	lsls	r3, r3, #4
 8007dbe:	18cb      	adds	r3, r1, r3
 8007dc0:	330a      	adds	r3, #10
 8007dc2:	781b      	ldrb	r3, [r3, #0]
 8007dc4:	2b02      	cmp	r3, #2
 8007dc6:	d10e      	bne.n	8007de6 <dns_create_txid+0x4e>
        (dns_table[i].txid == txid)) {
 8007dc8:	1dfb      	adds	r3, r7, #7
 8007dca:	781a      	ldrb	r2, [r3, #0]
 8007dcc:	490d      	ldr	r1, [pc, #52]	; (8007e04 <dns_create_txid+0x6c>)
 8007dce:	0013      	movs	r3, r2
 8007dd0:	00db      	lsls	r3, r3, #3
 8007dd2:	189b      	adds	r3, r3, r2
 8007dd4:	011b      	lsls	r3, r3, #4
 8007dd6:	18cb      	adds	r3, r1, r3
 8007dd8:	3308      	adds	r3, #8
 8007dda:	881b      	ldrh	r3, [r3, #0]
    if ((dns_table[i].state == DNS_STATE_ASKING) &&
 8007ddc:	1d3a      	adds	r2, r7, #4
 8007dde:	8812      	ldrh	r2, [r2, #0]
 8007de0:	429a      	cmp	r2, r3
 8007de2:	d100      	bne.n	8007de6 <dns_create_txid+0x4e>
      /* ID already used by another pending query */
      goto again;
 8007de4:	e7db      	b.n	8007d9e <dns_create_txid+0x6>
  for (i = 0; i < DNS_TABLE_SIZE; i++) {
 8007de6:	1dfb      	adds	r3, r7, #7
 8007de8:	781a      	ldrb	r2, [r3, #0]
 8007dea:	1dfb      	adds	r3, r7, #7
 8007dec:	3201      	adds	r2, #1
 8007dee:	701a      	strb	r2, [r3, #0]
 8007df0:	1dfb      	adds	r3, r7, #7
 8007df2:	781b      	ldrb	r3, [r3, #0]
 8007df4:	2b02      	cmp	r3, #2
 8007df6:	d9db      	bls.n	8007db0 <dns_create_txid+0x18>
    }
  }

  return txid;
 8007df8:	1d3b      	adds	r3, r7, #4
 8007dfa:	881b      	ldrh	r3, [r3, #0]
}
 8007dfc:	0018      	movs	r0, r3
 8007dfe:	46bd      	mov	sp, r7
 8007e00:	b002      	add	sp, #8
 8007e02:	bd80      	pop	{r7, pc}
 8007e04:	20000a40 	.word	0x20000a40

08007e08 <dns_backupserver_available>:
/**
 * Check whether there are other backup DNS servers available to try
 */
static u8_t
dns_backupserver_available(struct dns_table_entry *pentry)
{
 8007e08:	b580      	push	{r7, lr}
 8007e0a:	b084      	sub	sp, #16
 8007e0c:	af00      	add	r7, sp, #0
 8007e0e:	6078      	str	r0, [r7, #4]
  u8_t ret = 0;
 8007e10:	210f      	movs	r1, #15
 8007e12:	187b      	adds	r3, r7, r1
 8007e14:	2200      	movs	r2, #0
 8007e16:	701a      	strb	r2, [r3, #0]

  if (pentry) {
 8007e18:	687b      	ldr	r3, [r7, #4]
 8007e1a:	2b00      	cmp	r3, #0
 8007e1c:	d00e      	beq.n	8007e3c <dns_backupserver_available+0x34>
    if ((pentry->server_idx + 1 < DNS_MAX_SERVERS) && !ip_addr_isany_val(dns_servers[pentry->server_idx + 1])) {
 8007e1e:	687b      	ldr	r3, [r7, #4]
 8007e20:	7adb      	ldrb	r3, [r3, #11]
 8007e22:	2b00      	cmp	r3, #0
 8007e24:	d10a      	bne.n	8007e3c <dns_backupserver_available+0x34>
 8007e26:	687b      	ldr	r3, [r7, #4]
 8007e28:	7adb      	ldrb	r3, [r3, #11]
 8007e2a:	1c5a      	adds	r2, r3, #1
 8007e2c:	4b07      	ldr	r3, [pc, #28]	; (8007e4c <dns_backupserver_available+0x44>)
 8007e2e:	0092      	lsls	r2, r2, #2
 8007e30:	58d3      	ldr	r3, [r2, r3]
 8007e32:	2b00      	cmp	r3, #0
 8007e34:	d002      	beq.n	8007e3c <dns_backupserver_available+0x34>
      ret = 1;
 8007e36:	187b      	adds	r3, r7, r1
 8007e38:	2201      	movs	r2, #1
 8007e3a:	701a      	strb	r2, [r3, #0]
    }
  }

  return ret;
 8007e3c:	230f      	movs	r3, #15
 8007e3e:	18fb      	adds	r3, r7, r3
 8007e40:	781b      	ldrb	r3, [r3, #0]
}
 8007e42:	0018      	movs	r0, r3
 8007e44:	46bd      	mov	sp, r7
 8007e46:	b004      	add	sp, #16
 8007e48:	bd80      	pop	{r7, pc}
 8007e4a:	46c0      	nop			; (mov r8, r8)
 8007e4c:	20000c14 	.word	0x20000c14

08007e50 <dns_check_entry>:
 *
 * @param i index of the dns_table entry to check
 */
static void
dns_check_entry(u8_t i)
{
 8007e50:	b590      	push	{r4, r7, lr}
 8007e52:	b085      	sub	sp, #20
 8007e54:	af00      	add	r7, sp, #0
 8007e56:	0002      	movs	r2, r0
 8007e58:	1dfb      	adds	r3, r7, #7
 8007e5a:	701a      	strb	r2, [r3, #0]
  err_t err;
  struct dns_table_entry *entry = &dns_table[i];
 8007e5c:	1dfb      	adds	r3, r7, #7
 8007e5e:	781a      	ldrb	r2, [r3, #0]
 8007e60:	0013      	movs	r3, r2
 8007e62:	00db      	lsls	r3, r3, #3
 8007e64:	189b      	adds	r3, r3, r2
 8007e66:	011b      	lsls	r3, r3, #4
 8007e68:	4a4b      	ldr	r2, [pc, #300]	; (8007f98 <dns_check_entry+0x148>)
 8007e6a:	189b      	adds	r3, r3, r2
 8007e6c:	60fb      	str	r3, [r7, #12]

  LWIP_ASSERT("array index out of bounds", i < DNS_TABLE_SIZE);
 8007e6e:	1dfb      	adds	r3, r7, #7
 8007e70:	781b      	ldrb	r3, [r3, #0]
 8007e72:	2b02      	cmp	r3, #2
 8007e74:	d905      	bls.n	8007e82 <dns_check_entry+0x32>
 8007e76:	4b49      	ldr	r3, [pc, #292]	; (8007f9c <dns_check_entry+0x14c>)
 8007e78:	4a49      	ldr	r2, [pc, #292]	; (8007fa0 <dns_check_entry+0x150>)
 8007e7a:	494a      	ldr	r1, [pc, #296]	; (8007fa4 <dns_check_entry+0x154>)
 8007e7c:	484a      	ldr	r0, [pc, #296]	; (8007fa8 <dns_check_entry+0x158>)
 8007e7e:	f7fa f9b1 	bl	80021e4 <app_debug_rtt_raw>

  switch (entry->state) {
 8007e82:	68fb      	ldr	r3, [r7, #12]
 8007e84:	7a9b      	ldrb	r3, [r3, #10]
 8007e86:	2b03      	cmp	r3, #3
 8007e88:	d065      	beq.n	8007f56 <dns_check_entry+0x106>
 8007e8a:	dd00      	ble.n	8007e8e <dns_check_entry+0x3e>
 8007e8c:	e074      	b.n	8007f78 <dns_check_entry+0x128>
 8007e8e:	2b02      	cmp	r3, #2
 8007e90:	d022      	beq.n	8007ed8 <dns_check_entry+0x88>
 8007e92:	dd00      	ble.n	8007e96 <dns_check_entry+0x46>
 8007e94:	e070      	b.n	8007f78 <dns_check_entry+0x128>
 8007e96:	2b00      	cmp	r3, #0
 8007e98:	d100      	bne.n	8007e9c <dns_check_entry+0x4c>
 8007e9a:	e074      	b.n	8007f86 <dns_check_entry+0x136>
 8007e9c:	2b01      	cmp	r3, #1
 8007e9e:	d16b      	bne.n	8007f78 <dns_check_entry+0x128>
    case DNS_STATE_NEW:
      /* initialize new entry */
      entry->txid = dns_create_txid();
 8007ea0:	f7ff ff7a 	bl	8007d98 <dns_create_txid>
 8007ea4:	0003      	movs	r3, r0
 8007ea6:	001a      	movs	r2, r3
 8007ea8:	68fb      	ldr	r3, [r7, #12]
 8007eaa:	811a      	strh	r2, [r3, #8]
      entry->state = DNS_STATE_ASKING;
 8007eac:	68fb      	ldr	r3, [r7, #12]
 8007eae:	2202      	movs	r2, #2
 8007eb0:	729a      	strb	r2, [r3, #10]
      entry->server_idx = 0;
 8007eb2:	68fb      	ldr	r3, [r7, #12]
 8007eb4:	2200      	movs	r2, #0
 8007eb6:	72da      	strb	r2, [r3, #11]
      entry->tmr = 1;
 8007eb8:	68fb      	ldr	r3, [r7, #12]
 8007eba:	2201      	movs	r2, #1
 8007ebc:	731a      	strb	r2, [r3, #12]
      entry->retries = 0;
 8007ebe:	68fb      	ldr	r3, [r7, #12]
 8007ec0:	2200      	movs	r2, #0
 8007ec2:	735a      	strb	r2, [r3, #13]

      /* send DNS packet for this entry */
      err = dns_send(i);
 8007ec4:	230b      	movs	r3, #11
 8007ec6:	18fc      	adds	r4, r7, r3
 8007ec8:	1dfb      	adds	r3, r7, #7
 8007eca:	781b      	ldrb	r3, [r3, #0]
 8007ecc:	0018      	movs	r0, r3
 8007ece:	f7ff fcbb 	bl	8007848 <dns_send>
 8007ed2:	0003      	movs	r3, r0
 8007ed4:	7023      	strb	r3, [r4, #0]
      if (err != ERR_OK) {
        LWIP_DEBUGF(DNS_DEBUG | LWIP_DBG_LEVEL_WARNING,
                    ("dns_send returned error: %s\n", lwip_strerr(err)));
      }
      break;
 8007ed6:	e05b      	b.n	8007f90 <dns_check_entry+0x140>
    case DNS_STATE_ASKING:
      if (--entry->tmr == 0) {
 8007ed8:	68fb      	ldr	r3, [r7, #12]
 8007eda:	7b1b      	ldrb	r3, [r3, #12]
 8007edc:	3b01      	subs	r3, #1
 8007ede:	b2da      	uxtb	r2, r3
 8007ee0:	68fb      	ldr	r3, [r7, #12]
 8007ee2:	731a      	strb	r2, [r3, #12]
 8007ee4:	68fb      	ldr	r3, [r7, #12]
 8007ee6:	7b1b      	ldrb	r3, [r3, #12]
 8007ee8:	2b00      	cmp	r3, #0
 8007eea:	d14e      	bne.n	8007f8a <dns_check_entry+0x13a>
        if (++entry->retries == DNS_MAX_RETRIES) {
 8007eec:	68fb      	ldr	r3, [r7, #12]
 8007eee:	7b5b      	ldrb	r3, [r3, #13]
 8007ef0:	3301      	adds	r3, #1
 8007ef2:	b2da      	uxtb	r2, r3
 8007ef4:	68fb      	ldr	r3, [r7, #12]
 8007ef6:	735a      	strb	r2, [r3, #13]
 8007ef8:	68fb      	ldr	r3, [r7, #12]
 8007efa:	7b5b      	ldrb	r3, [r3, #13]
 8007efc:	2b04      	cmp	r3, #4
 8007efe:	d11c      	bne.n	8007f3a <dns_check_entry+0xea>
          if (dns_backupserver_available(entry)
 8007f00:	68fb      	ldr	r3, [r7, #12]
 8007f02:	0018      	movs	r0, r3
 8007f04:	f7ff ff80 	bl	8007e08 <dns_backupserver_available>
 8007f08:	1e03      	subs	r3, r0, #0
 8007f0a:	d00c      	beq.n	8007f26 <dns_check_entry+0xd6>
#if LWIP_DNS_SUPPORT_MDNS_QUERIES
              && !entry->is_mdns
#endif /* LWIP_DNS_SUPPORT_MDNS_QUERIES */
             ) {
            /* change of server */
            entry->server_idx++;
 8007f0c:	68fb      	ldr	r3, [r7, #12]
 8007f0e:	7adb      	ldrb	r3, [r3, #11]
 8007f10:	3301      	adds	r3, #1
 8007f12:	b2da      	uxtb	r2, r3
 8007f14:	68fb      	ldr	r3, [r7, #12]
 8007f16:	72da      	strb	r2, [r3, #11]
            entry->tmr = 1;
 8007f18:	68fb      	ldr	r3, [r7, #12]
 8007f1a:	2201      	movs	r2, #1
 8007f1c:	731a      	strb	r2, [r3, #12]
            entry->retries = 0;
 8007f1e:	68fb      	ldr	r3, [r7, #12]
 8007f20:	2200      	movs	r2, #0
 8007f22:	735a      	strb	r2, [r3, #13]
 8007f24:	e00d      	b.n	8007f42 <dns_check_entry+0xf2>
          } else {
            LWIP_DEBUGF(DNS_DEBUG, ("dns_check_entry: \"%s\": timeout\n", entry->name));
            /* call specified callback function if provided */
            dns_call_found(i, NULL);
 8007f26:	1dfb      	adds	r3, r7, #7
 8007f28:	781b      	ldrb	r3, [r3, #0]
 8007f2a:	2100      	movs	r1, #0
 8007f2c:	0018      	movs	r0, r3
 8007f2e:	f7ff fe55 	bl	8007bdc <dns_call_found>
            /* flush this entry */
            entry->state = DNS_STATE_UNUSED;
 8007f32:	68fb      	ldr	r3, [r7, #12]
 8007f34:	2200      	movs	r2, #0
 8007f36:	729a      	strb	r2, [r3, #10]
            break;
 8007f38:	e02a      	b.n	8007f90 <dns_check_entry+0x140>
          }
        } else {
          /* wait longer for the next retry */
          entry->tmr = entry->retries;
 8007f3a:	68fb      	ldr	r3, [r7, #12]
 8007f3c:	7b5a      	ldrb	r2, [r3, #13]
 8007f3e:	68fb      	ldr	r3, [r7, #12]
 8007f40:	731a      	strb	r2, [r3, #12]
        }

        /* send DNS packet for this entry */
        err = dns_send(i);
 8007f42:	230b      	movs	r3, #11
 8007f44:	18fc      	adds	r4, r7, r3
 8007f46:	1dfb      	adds	r3, r7, #7
 8007f48:	781b      	ldrb	r3, [r3, #0]
 8007f4a:	0018      	movs	r0, r3
 8007f4c:	f7ff fc7c 	bl	8007848 <dns_send>
 8007f50:	0003      	movs	r3, r0
 8007f52:	7023      	strb	r3, [r4, #0]
        if (err != ERR_OK) {
          LWIP_DEBUGF(DNS_DEBUG | LWIP_DBG_LEVEL_WARNING,
                      ("dns_send returned error: %s\n", lwip_strerr(err)));
        }
      }
      break;
 8007f54:	e019      	b.n	8007f8a <dns_check_entry+0x13a>
    case DNS_STATE_DONE:
      /* if the time to live is nul */
      if ((entry->ttl == 0) || (--entry->ttl == 0)) {
 8007f56:	68fb      	ldr	r3, [r7, #12]
 8007f58:	681b      	ldr	r3, [r3, #0]
 8007f5a:	2b00      	cmp	r3, #0
 8007f5c:	d008      	beq.n	8007f70 <dns_check_entry+0x120>
 8007f5e:	68fb      	ldr	r3, [r7, #12]
 8007f60:	681b      	ldr	r3, [r3, #0]
 8007f62:	1e5a      	subs	r2, r3, #1
 8007f64:	68fb      	ldr	r3, [r7, #12]
 8007f66:	601a      	str	r2, [r3, #0]
 8007f68:	68fb      	ldr	r3, [r7, #12]
 8007f6a:	681b      	ldr	r3, [r3, #0]
 8007f6c:	2b00      	cmp	r3, #0
 8007f6e:	d10e      	bne.n	8007f8e <dns_check_entry+0x13e>
        LWIP_DEBUGF(DNS_DEBUG, ("dns_check_entry: \"%s\": flush\n", entry->name));
        /* flush this entry, there cannot be any related pending entries in this state */
        entry->state = DNS_STATE_UNUSED;
 8007f70:	68fb      	ldr	r3, [r7, #12]
 8007f72:	2200      	movs	r2, #0
 8007f74:	729a      	strb	r2, [r3, #10]
      }
      break;
 8007f76:	e00a      	b.n	8007f8e <dns_check_entry+0x13e>
    case DNS_STATE_UNUSED:
      /* nothing to do */
      break;
    default:
      LWIP_ASSERT("unknown dns_table entry state:", 0);
 8007f78:	4b08      	ldr	r3, [pc, #32]	; (8007f9c <dns_check_entry+0x14c>)
 8007f7a:	4a0c      	ldr	r2, [pc, #48]	; (8007fac <dns_check_entry+0x15c>)
 8007f7c:	490c      	ldr	r1, [pc, #48]	; (8007fb0 <dns_check_entry+0x160>)
 8007f7e:	480a      	ldr	r0, [pc, #40]	; (8007fa8 <dns_check_entry+0x158>)
 8007f80:	f7fa f930 	bl	80021e4 <app_debug_rtt_raw>
      break;
 8007f84:	e004      	b.n	8007f90 <dns_check_entry+0x140>
      break;
 8007f86:	46c0      	nop			; (mov r8, r8)
 8007f88:	e002      	b.n	8007f90 <dns_check_entry+0x140>
      break;
 8007f8a:	46c0      	nop			; (mov r8, r8)
 8007f8c:	e000      	b.n	8007f90 <dns_check_entry+0x140>
      break;
 8007f8e:	46c0      	nop			; (mov r8, r8)
  }
}
 8007f90:	46c0      	nop			; (mov r8, r8)
 8007f92:	46bd      	mov	sp, r7
 8007f94:	b005      	add	sp, #20
 8007f96:	bd90      	pop	{r4, r7, pc}
 8007f98:	20000a40 	.word	0x20000a40
 8007f9c:	0801fe4c 	.word	0x0801fe4c
 8007fa0:	0000041c 	.word	0x0000041c
 8007fa4:	0801feb8 	.word	0x0801feb8
 8007fa8:	0801fe8c 	.word	0x0801fe8c
 8007fac:	0000045b 	.word	0x0000045b
 8007fb0:	0801fed4 	.word	0x0801fed4

08007fb4 <dns_check_entries>:
/**
 * Call dns_check_entry for each entry in dns_table - check all entries.
 */
static void
dns_check_entries(void)
{
 8007fb4:	b580      	push	{r7, lr}
 8007fb6:	b082      	sub	sp, #8
 8007fb8:	af00      	add	r7, sp, #0
  u8_t i;

  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 8007fba:	1dfb      	adds	r3, r7, #7
 8007fbc:	2200      	movs	r2, #0
 8007fbe:	701a      	strb	r2, [r3, #0]
 8007fc0:	e009      	b.n	8007fd6 <dns_check_entries+0x22>
    dns_check_entry(i);
 8007fc2:	1dfb      	adds	r3, r7, #7
 8007fc4:	781b      	ldrb	r3, [r3, #0]
 8007fc6:	0018      	movs	r0, r3
 8007fc8:	f7ff ff42 	bl	8007e50 <dns_check_entry>
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 8007fcc:	1dfb      	adds	r3, r7, #7
 8007fce:	1dfa      	adds	r2, r7, #7
 8007fd0:	7812      	ldrb	r2, [r2, #0]
 8007fd2:	3201      	adds	r2, #1
 8007fd4:	701a      	strb	r2, [r3, #0]
 8007fd6:	1dfb      	adds	r3, r7, #7
 8007fd8:	781b      	ldrb	r3, [r3, #0]
 8007fda:	2b02      	cmp	r3, #2
 8007fdc:	d9f1      	bls.n	8007fc2 <dns_check_entries+0xe>
  }
}
 8007fde:	46c0      	nop			; (mov r8, r8)
 8007fe0:	46c0      	nop			; (mov r8, r8)
 8007fe2:	46bd      	mov	sp, r7
 8007fe4:	b002      	add	sp, #8
 8007fe6:	bd80      	pop	{r7, pc}

08007fe8 <dns_correct_response>:
/**
 * Save TTL and call dns_call_found for correct response.
 */
static void
dns_correct_response(u8_t idx, u32_t ttl)
{
 8007fe8:	b580      	push	{r7, lr}
 8007fea:	b084      	sub	sp, #16
 8007fec:	af00      	add	r7, sp, #0
 8007fee:	0002      	movs	r2, r0
 8007ff0:	6039      	str	r1, [r7, #0]
 8007ff2:	1dfb      	adds	r3, r7, #7
 8007ff4:	701a      	strb	r2, [r3, #0]
  struct dns_table_entry *entry = &dns_table[idx];
 8007ff6:	1dfb      	adds	r3, r7, #7
 8007ff8:	781a      	ldrb	r2, [r3, #0]
 8007ffa:	0013      	movs	r3, r2
 8007ffc:	00db      	lsls	r3, r3, #3
 8007ffe:	189b      	adds	r3, r3, r2
 8008000:	011b      	lsls	r3, r3, #4
 8008002:	4a14      	ldr	r2, [pc, #80]	; (8008054 <dns_correct_response+0x6c>)
 8008004:	189b      	adds	r3, r3, r2
 8008006:	60fb      	str	r3, [r7, #12]

  entry->state = DNS_STATE_DONE;
 8008008:	68fb      	ldr	r3, [r7, #12]
 800800a:	2203      	movs	r2, #3
 800800c:	729a      	strb	r2, [r3, #10]
  LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response = ", entry->name));
  ip_addr_debug_print_val(DNS_DEBUG, entry->ipaddr);
  LWIP_DEBUGF(DNS_DEBUG, ("\n"));

  /* read the answer resource record's TTL, and maximize it if needed */
  entry->ttl = ttl;
 800800e:	68fb      	ldr	r3, [r7, #12]
 8008010:	683a      	ldr	r2, [r7, #0]
 8008012:	601a      	str	r2, [r3, #0]
  if (entry->ttl > DNS_MAX_TTL) {
 8008014:	68fb      	ldr	r3, [r7, #12]
 8008016:	681b      	ldr	r3, [r3, #0]
 8008018:	4a0f      	ldr	r2, [pc, #60]	; (8008058 <dns_correct_response+0x70>)
 800801a:	4293      	cmp	r3, r2
 800801c:	d902      	bls.n	8008024 <dns_correct_response+0x3c>
    entry->ttl = DNS_MAX_TTL;
 800801e:	68fb      	ldr	r3, [r7, #12]
 8008020:	4a0d      	ldr	r2, [pc, #52]	; (8008058 <dns_correct_response+0x70>)
 8008022:	601a      	str	r2, [r3, #0]
  }
  dns_call_found(idx, &entry->ipaddr);
 8008024:	68fb      	ldr	r3, [r7, #12]
 8008026:	1d1a      	adds	r2, r3, #4
 8008028:	1dfb      	adds	r3, r7, #7
 800802a:	781b      	ldrb	r3, [r3, #0]
 800802c:	0011      	movs	r1, r2
 800802e:	0018      	movs	r0, r3
 8008030:	f7ff fdd4 	bl	8007bdc <dns_call_found>

  if (entry->ttl == 0) {
 8008034:	68fb      	ldr	r3, [r7, #12]
 8008036:	681b      	ldr	r3, [r3, #0]
 8008038:	2b00      	cmp	r3, #0
 800803a:	d106      	bne.n	800804a <dns_correct_response+0x62>
    /* RFC 883, page 29: "Zero values are
       interpreted to mean that the RR can only be used for the
       transaction in progress, and should not be cached."
       -> flush this entry now */
    /* entry reused during callback? */
    if (entry->state == DNS_STATE_DONE) {
 800803c:	68fb      	ldr	r3, [r7, #12]
 800803e:	7a9b      	ldrb	r3, [r3, #10]
 8008040:	2b03      	cmp	r3, #3
 8008042:	d102      	bne.n	800804a <dns_correct_response+0x62>
      entry->state = DNS_STATE_UNUSED;
 8008044:	68fb      	ldr	r3, [r7, #12]
 8008046:	2200      	movs	r2, #0
 8008048:	729a      	strb	r2, [r3, #10]
    }
  }
}
 800804a:	46c0      	nop			; (mov r8, r8)
 800804c:	46bd      	mov	sp, r7
 800804e:	b004      	add	sp, #16
 8008050:	bd80      	pop	{r7, pc}
 8008052:	46c0      	nop			; (mov r8, r8)
 8008054:	20000a40 	.word	0x20000a40
 8008058:	00093a80 	.word	0x00093a80

0800805c <dns_recv>:
/**
 * Receive input function for DNS response packets arriving for the dns UDP pcb.
 */
static void
dns_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr, u16_t port)
{
 800805c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800805e:	b091      	sub	sp, #68	; 0x44
 8008060:	af00      	add	r7, sp, #0
 8008062:	60f8      	str	r0, [r7, #12]
 8008064:	60b9      	str	r1, [r7, #8]
 8008066:	607a      	str	r2, [r7, #4]
 8008068:	603b      	str	r3, [r7, #0]
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(port);

  /* is the dns message big enough ? */
  if (p->tot_len < (SIZEOF_DNS_HDR + SIZEOF_DNS_QUERY)) {
 800806a:	687b      	ldr	r3, [r7, #4]
 800806c:	891b      	ldrh	r3, [r3, #8]
 800806e:	2b0f      	cmp	r3, #15
 8008070:	d800      	bhi.n	8008074 <dns_recv+0x18>
 8008072:	e162      	b.n	800833a <dns_recv+0x2de>
    /* free pbuf and return */
    goto ignore_packet;
  }

  /* copy dns payload inside static buffer for processing */
  if (pbuf_copy_partial(p, &hdr, SIZEOF_DNS_HDR, 0) == SIZEOF_DNS_HDR) {
 8008074:	2424      	movs	r4, #36	; 0x24
 8008076:	1939      	adds	r1, r7, r4
 8008078:	6878      	ldr	r0, [r7, #4]
 800807a:	2300      	movs	r3, #0
 800807c:	220c      	movs	r2, #12
 800807e:	f002 fcf7 	bl	800aa70 <pbuf_copy_partial>
 8008082:	0003      	movs	r3, r0
 8008084:	2b0c      	cmp	r3, #12
 8008086:	d000      	beq.n	800808a <dns_recv+0x2e>
 8008088:	e159      	b.n	800833e <dns_recv+0x2e2>
    /* Match the ID in the DNS header with the name table. */
    txid = lwip_htons(hdr.id);
 800808a:	193b      	adds	r3, r7, r4
 800808c:	881b      	ldrh	r3, [r3, #0]
 800808e:	2238      	movs	r2, #56	; 0x38
 8008090:	18bc      	adds	r4, r7, r2
 8008092:	0018      	movs	r0, r3
 8008094:	f7ff f9b4 	bl	8007400 <lwip_htons>
 8008098:	0003      	movs	r3, r0
 800809a:	8023      	strh	r3, [r4, #0]
    for (i = 0; i < DNS_TABLE_SIZE; i++) {
 800809c:	233b      	movs	r3, #59	; 0x3b
 800809e:	18fb      	adds	r3, r7, r3
 80080a0:	2200      	movs	r2, #0
 80080a2:	701a      	strb	r2, [r3, #0]
 80080a4:	e142      	b.n	800832c <dns_recv+0x2d0>
      struct dns_table_entry *entry = &dns_table[i];
 80080a6:	233b      	movs	r3, #59	; 0x3b
 80080a8:	18fb      	adds	r3, r7, r3
 80080aa:	781a      	ldrb	r2, [r3, #0]
 80080ac:	0013      	movs	r3, r2
 80080ae:	00db      	lsls	r3, r3, #3
 80080b0:	189b      	adds	r3, r3, r2
 80080b2:	011b      	lsls	r3, r3, #4
 80080b4:	4ab2      	ldr	r2, [pc, #712]	; (8008380 <dns_recv+0x324>)
 80080b6:	189b      	adds	r3, r3, r2
 80080b8:	637b      	str	r3, [r7, #52]	; 0x34
      if ((entry->state == DNS_STATE_ASKING) &&
 80080ba:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80080bc:	7a9b      	ldrb	r3, [r3, #10]
 80080be:	2b02      	cmp	r3, #2
 80080c0:	d000      	beq.n	80080c4 <dns_recv+0x68>
 80080c2:	e12d      	b.n	8008320 <dns_recv+0x2c4>
          (entry->txid == txid)) {
 80080c4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80080c6:	891b      	ldrh	r3, [r3, #8]
      if ((entry->state == DNS_STATE_ASKING) &&
 80080c8:	2238      	movs	r2, #56	; 0x38
 80080ca:	18ba      	adds	r2, r7, r2
 80080cc:	8812      	ldrh	r2, [r2, #0]
 80080ce:	429a      	cmp	r2, r3
 80080d0:	d000      	beq.n	80080d4 <dns_recv+0x78>
 80080d2:	e125      	b.n	8008320 <dns_recv+0x2c4>

        /* We only care about the question(s) and the answers. The authrr
           and the extrarr are simply discarded. */
        nquestions = lwip_htons(hdr.numquestions);
 80080d4:	2624      	movs	r6, #36	; 0x24
 80080d6:	19bb      	adds	r3, r7, r6
 80080d8:	889b      	ldrh	r3, [r3, #4]
 80080da:	2532      	movs	r5, #50	; 0x32
 80080dc:	197c      	adds	r4, r7, r5
 80080de:	0018      	movs	r0, r3
 80080e0:	f7ff f98e 	bl	8007400 <lwip_htons>
 80080e4:	0003      	movs	r3, r0
 80080e6:	8023      	strh	r3, [r4, #0]
        nanswers   = lwip_htons(hdr.numanswers);
 80080e8:	19bb      	adds	r3, r7, r6
 80080ea:	88db      	ldrh	r3, [r3, #6]
 80080ec:	223e      	movs	r2, #62	; 0x3e
 80080ee:	18bc      	adds	r4, r7, r2
 80080f0:	0018      	movs	r0, r3
 80080f2:	f7ff f985 	bl	8007400 <lwip_htons>
 80080f6:	0003      	movs	r3, r0
 80080f8:	8023      	strh	r3, [r4, #0]

        /* Check for correct response. */
        if ((hdr.flags1 & DNS_FLAG1_RESPONSE) == 0) {
 80080fa:	19bb      	adds	r3, r7, r6
 80080fc:	789b      	ldrb	r3, [r3, #2]
 80080fe:	b25b      	sxtb	r3, r3
 8008100:	2b00      	cmp	r3, #0
 8008102:	db00      	blt.n	8008106 <dns_recv+0xaa>
 8008104:	e11d      	b.n	8008342 <dns_recv+0x2e6>
          LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": not a response\n", entry->name));
          goto ignore_packet; /* ignore this packet */
        }
        if (nquestions != 1) {
 8008106:	197b      	adds	r3, r7, r5
 8008108:	881b      	ldrh	r3, [r3, #0]
 800810a:	2b01      	cmp	r3, #1
 800810c:	d000      	beq.n	8008110 <dns_recv+0xb4>
 800810e:	e11a      	b.n	8008346 <dns_recv+0x2ea>
        if (!entry->is_mdns)
#endif /* LWIP_DNS_SUPPORT_MDNS_QUERIES */
        {
          /* Check whether response comes from the same network address to which the
             question was sent. (RFC 5452) */
          if (!ip_addr_cmp(addr, &dns_servers[entry->server_idx])) {
 8008110:	683b      	ldr	r3, [r7, #0]
 8008112:	681a      	ldr	r2, [r3, #0]
 8008114:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008116:	7adb      	ldrb	r3, [r3, #11]
 8008118:	0019      	movs	r1, r3
 800811a:	4b9a      	ldr	r3, [pc, #616]	; (8008384 <dns_recv+0x328>)
 800811c:	0089      	lsls	r1, r1, #2
 800811e:	58cb      	ldr	r3, [r1, r3]
 8008120:	429a      	cmp	r2, r3
 8008122:	d000      	beq.n	8008126 <dns_recv+0xca>
 8008124:	e111      	b.n	800834a <dns_recv+0x2ee>
          }
        }

        /* Check if the name in the "question" part match with the name in the entry and
           skip it if equal. */
        res_idx = dns_compare_name(entry->name, p, SIZEOF_DNS_HDR);
 8008126:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008128:	3310      	adds	r3, #16
 800812a:	253c      	movs	r5, #60	; 0x3c
 800812c:	197c      	adds	r4, r7, r5
 800812e:	6879      	ldr	r1, [r7, #4]
 8008130:	220c      	movs	r2, #12
 8008132:	0018      	movs	r0, r3
 8008134:	f7ff fa78 	bl	8007628 <dns_compare_name>
 8008138:	0003      	movs	r3, r0
 800813a:	8023      	strh	r3, [r4, #0]
        if (res_idx == 0xFFFF) {
 800813c:	002c      	movs	r4, r5
 800813e:	193b      	adds	r3, r7, r4
 8008140:	881b      	ldrh	r3, [r3, #0]
 8008142:	4a91      	ldr	r2, [pc, #580]	; (8008388 <dns_recv+0x32c>)
 8008144:	4293      	cmp	r3, r2
 8008146:	d100      	bne.n	800814a <dns_recv+0xee>
 8008148:	e101      	b.n	800834e <dns_recv+0x2f2>
          LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response not match to query\n", entry->name));
          goto ignore_packet; /* ignore this packet */
        }

        /* check if "question" part matches the request */
        if (pbuf_copy_partial(p, &qry, SIZEOF_DNS_QUERY, res_idx) != SIZEOF_DNS_QUERY) {
 800814a:	193b      	adds	r3, r7, r4
 800814c:	881b      	ldrh	r3, [r3, #0]
 800814e:	2514      	movs	r5, #20
 8008150:	1979      	adds	r1, r7, r5
 8008152:	6878      	ldr	r0, [r7, #4]
 8008154:	2204      	movs	r2, #4
 8008156:	f002 fc8b 	bl	800aa70 <pbuf_copy_partial>
 800815a:	0003      	movs	r3, r0
 800815c:	2b04      	cmp	r3, #4
 800815e:	d000      	beq.n	8008162 <dns_recv+0x106>
 8008160:	e0f7      	b.n	8008352 <dns_recv+0x2f6>
          goto ignore_packet; /* ignore this packet */
        }
        if ((qry.cls != PP_HTONS(DNS_RRCLASS_IN)) ||
 8008162:	197b      	adds	r3, r7, r5
 8008164:	885a      	ldrh	r2, [r3, #2]
 8008166:	2380      	movs	r3, #128	; 0x80
 8008168:	005b      	lsls	r3, r3, #1
 800816a:	429a      	cmp	r2, r3
 800816c:	d000      	beq.n	8008170 <dns_recv+0x114>
 800816e:	e0f2      	b.n	8008356 <dns_recv+0x2fa>
            (LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype) && (qry.type != PP_HTONS(DNS_RRTYPE_AAAA))) ||
            (!LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype) && (qry.type != PP_HTONS(DNS_RRTYPE_A)))) {
 8008170:	197b      	adds	r3, r7, r5
 8008172:	881a      	ldrh	r2, [r3, #0]
            (LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype) && (qry.type != PP_HTONS(DNS_RRTYPE_AAAA))) ||
 8008174:	2380      	movs	r3, #128	; 0x80
 8008176:	005b      	lsls	r3, r3, #1
 8008178:	429a      	cmp	r2, r3
 800817a:	d000      	beq.n	800817e <dns_recv+0x122>
 800817c:	e0eb      	b.n	8008356 <dns_recv+0x2fa>
          LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response not match to query\n", entry->name));
          goto ignore_packet; /* ignore this packet */
        }
        /* skip the rest of the "question" part */
        if (res_idx + SIZEOF_DNS_QUERY > 0xFFFF) {
 800817e:	193b      	adds	r3, r7, r4
 8008180:	881b      	ldrh	r3, [r3, #0]
 8008182:	4a82      	ldr	r2, [pc, #520]	; (800838c <dns_recv+0x330>)
 8008184:	4293      	cmp	r3, r2
 8008186:	d900      	bls.n	800818a <dns_recv+0x12e>
 8008188:	e0e7      	b.n	800835a <dns_recv+0x2fe>
          goto ignore_packet;
        }
        res_idx = (u16_t)(res_idx + SIZEOF_DNS_QUERY);
 800818a:	193b      	adds	r3, r7, r4
 800818c:	193a      	adds	r2, r7, r4
 800818e:	8812      	ldrh	r2, [r2, #0]
 8008190:	3204      	adds	r2, #4
 8008192:	801a      	strh	r2, [r3, #0]

        /* Check for error. If so, call callback to inform. */
        if (hdr.flags2 & DNS_FLAG2_ERR_MASK) {
 8008194:	19bb      	adds	r3, r7, r6
 8008196:	78db      	ldrb	r3, [r3, #3]
 8008198:	001a      	movs	r2, r3
 800819a:	230f      	movs	r3, #15
 800819c:	4013      	ands	r3, r2
 800819e:	d100      	bne.n	80081a2 <dns_recv+0x146>
 80081a0:	e09a      	b.n	80082d8 <dns_recv+0x27c>
          LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": error in flags\n", entry->name));

          /* if there is another backup DNS server to try
           * then don't stop the DNS request
           */
          if (dns_backupserver_available(entry)) {
 80081a2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80081a4:	0018      	movs	r0, r3
 80081a6:	f7ff fe2f 	bl	8007e08 <dns_backupserver_available>
 80081aa:	1e03      	subs	r3, r0, #0
 80081ac:	d100      	bne.n	80081b0 <dns_recv+0x154>
 80081ae:	e0a0      	b.n	80082f2 <dns_recv+0x296>
            /* avoid retrying the same server */
            entry->retries = DNS_MAX_RETRIES-1;
 80081b0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80081b2:	2203      	movs	r2, #3
 80081b4:	735a      	strb	r2, [r3, #13]
            entry->tmr     = 1;
 80081b6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80081b8:	2201      	movs	r2, #1
 80081ba:	731a      	strb	r2, [r3, #12]

            /* contact next available server for this entry */
            dns_check_entry(i);
 80081bc:	233b      	movs	r3, #59	; 0x3b
 80081be:	18fb      	adds	r3, r7, r3
 80081c0:	781b      	ldrb	r3, [r3, #0]
 80081c2:	0018      	movs	r0, r3
 80081c4:	f7ff fe44 	bl	8007e50 <dns_check_entry>

            goto ignore_packet;
 80081c8:	e0d2      	b.n	8008370 <dns_recv+0x314>
          }
        } else {
          while ((nanswers > 0) && (res_idx < p->tot_len)) {
            /* skip answer resource record's host name */
            res_idx = dns_skip_name(p, res_idx);
 80081ca:	253c      	movs	r5, #60	; 0x3c
 80081cc:	197c      	adds	r4, r7, r5
 80081ce:	197b      	adds	r3, r7, r5
 80081d0:	881a      	ldrh	r2, [r3, #0]
 80081d2:	687b      	ldr	r3, [r7, #4]
 80081d4:	0011      	movs	r1, r2
 80081d6:	0018      	movs	r0, r3
 80081d8:	f7ff fad6 	bl	8007788 <dns_skip_name>
 80081dc:	0003      	movs	r3, r0
 80081de:	8023      	strh	r3, [r4, #0]
            if (res_idx == 0xFFFF) {
 80081e0:	002c      	movs	r4, r5
 80081e2:	193b      	adds	r3, r7, r4
 80081e4:	881b      	ldrh	r3, [r3, #0]
 80081e6:	4a68      	ldr	r2, [pc, #416]	; (8008388 <dns_recv+0x32c>)
 80081e8:	4293      	cmp	r3, r2
 80081ea:	d100      	bne.n	80081ee <dns_recv+0x192>
 80081ec:	e0b7      	b.n	800835e <dns_recv+0x302>
              goto ignore_packet; /* ignore this packet */
            }

            /* Check for IP address type and Internet class. Others are discarded. */
            if (pbuf_copy_partial(p, &ans, SIZEOF_DNS_ANSWER, res_idx) != SIZEOF_DNS_ANSWER) {
 80081ee:	193b      	adds	r3, r7, r4
 80081f0:	881b      	ldrh	r3, [r3, #0]
 80081f2:	2518      	movs	r5, #24
 80081f4:	1979      	adds	r1, r7, r5
 80081f6:	6878      	ldr	r0, [r7, #4]
 80081f8:	220a      	movs	r2, #10
 80081fa:	f002 fc39 	bl	800aa70 <pbuf_copy_partial>
 80081fe:	0003      	movs	r3, r0
 8008200:	2b0a      	cmp	r3, #10
 8008202:	d000      	beq.n	8008206 <dns_recv+0x1aa>
 8008204:	e0ad      	b.n	8008362 <dns_recv+0x306>
              goto ignore_packet; /* ignore this packet */
            }
            if (res_idx + SIZEOF_DNS_ANSWER > 0xFFFF) {
 8008206:	193b      	adds	r3, r7, r4
 8008208:	881b      	ldrh	r3, [r3, #0]
 800820a:	4a61      	ldr	r2, [pc, #388]	; (8008390 <dns_recv+0x334>)
 800820c:	4293      	cmp	r3, r2
 800820e:	d900      	bls.n	8008212 <dns_recv+0x1b6>
 8008210:	e0a9      	b.n	8008366 <dns_recv+0x30a>
              goto ignore_packet;
            }
            res_idx = (u16_t)(res_idx + SIZEOF_DNS_ANSWER);
 8008212:	193b      	adds	r3, r7, r4
 8008214:	0021      	movs	r1, r4
 8008216:	193a      	adds	r2, r7, r4
 8008218:	8812      	ldrh	r2, [r2, #0]
 800821a:	320a      	adds	r2, #10
 800821c:	801a      	strh	r2, [r3, #0]

            if (ans.cls == PP_HTONS(DNS_RRCLASS_IN)) {
 800821e:	002c      	movs	r4, r5
 8008220:	193b      	adds	r3, r7, r4
 8008222:	885a      	ldrh	r2, [r3, #2]
 8008224:	2380      	movs	r3, #128	; 0x80
 8008226:	005b      	lsls	r3, r3, #1
 8008228:	429a      	cmp	r2, r3
 800822a:	d134      	bne.n	8008296 <dns_recv+0x23a>
#if LWIP_IPV4
              if ((ans.type == PP_HTONS(DNS_RRTYPE_A)) && (ans.len == PP_HTONS(sizeof(ip4_addr_t)))) {
 800822c:	193b      	adds	r3, r7, r4
 800822e:	881a      	ldrh	r2, [r3, #0]
 8008230:	2380      	movs	r3, #128	; 0x80
 8008232:	005b      	lsls	r3, r3, #1
 8008234:	429a      	cmp	r2, r3
 8008236:	d12e      	bne.n	8008296 <dns_recv+0x23a>
 8008238:	193b      	adds	r3, r7, r4
 800823a:	891a      	ldrh	r2, [r3, #8]
 800823c:	2380      	movs	r3, #128	; 0x80
 800823e:	00db      	lsls	r3, r3, #3
 8008240:	429a      	cmp	r2, r3
 8008242:	d128      	bne.n	8008296 <dns_recv+0x23a>
                if (!LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype))
#endif /* LWIP_IPV4 && LWIP_IPV6 */
                {
                  ip4_addr_t ip4addr;
                  /* read the IP address after answer resource record's header */
                  if (pbuf_copy_partial(p, &ip4addr, sizeof(ip4_addr_t), res_idx) != sizeof(ip4_addr_t)) {
 8008244:	187b      	adds	r3, r7, r1
 8008246:	881b      	ldrh	r3, [r3, #0]
 8008248:	2210      	movs	r2, #16
 800824a:	18b9      	adds	r1, r7, r2
 800824c:	6878      	ldr	r0, [r7, #4]
 800824e:	2204      	movs	r2, #4
 8008250:	f002 fc0e 	bl	800aa70 <pbuf_copy_partial>
 8008254:	0003      	movs	r3, r0
 8008256:	2b04      	cmp	r3, #4
 8008258:	d000      	beq.n	800825c <dns_recv+0x200>
 800825a:	e086      	b.n	800836a <dns_recv+0x30e>
                    goto ignore_packet; /* ignore this packet */
                  }
                  ip_addr_copy_from_ip4(dns_table[i].ipaddr, ip4addr);
 800825c:	253b      	movs	r5, #59	; 0x3b
 800825e:	197b      	adds	r3, r7, r5
 8008260:	781a      	ldrb	r2, [r3, #0]
 8008262:	6939      	ldr	r1, [r7, #16]
 8008264:	4846      	ldr	r0, [pc, #280]	; (8008380 <dns_recv+0x324>)
 8008266:	0013      	movs	r3, r2
 8008268:	00db      	lsls	r3, r3, #3
 800826a:	189b      	adds	r3, r3, r2
 800826c:	011b      	lsls	r3, r3, #4
 800826e:	18c3      	adds	r3, r0, r3
 8008270:	3304      	adds	r3, #4
 8008272:	6019      	str	r1, [r3, #0]
                  pbuf_free(p);
 8008274:	687b      	ldr	r3, [r7, #4]
 8008276:	0018      	movs	r0, r3
 8008278:	f002 f930 	bl	800a4dc <pbuf_free>
                  /* handle correct response */
                  dns_correct_response(i, lwip_ntohl(ans.ttl));
 800827c:	193b      	adds	r3, r7, r4
 800827e:	685b      	ldr	r3, [r3, #4]
 8008280:	0018      	movs	r0, r3
 8008282:	f7ff f8d3 	bl	800742c <lwip_htonl>
 8008286:	0002      	movs	r2, r0
 8008288:	197b      	adds	r3, r7, r5
 800828a:	781b      	ldrb	r3, [r3, #0]
 800828c:	0011      	movs	r1, r2
 800828e:	0018      	movs	r0, r3
 8008290:	f7ff feaa 	bl	8007fe8 <dns_correct_response>
 8008294:	e071      	b.n	800837a <dns_recv+0x31e>
                }
              }
#endif /* LWIP_IPV6 */
            }
            /* skip this answer */
            if ((int)(res_idx + lwip_htons(ans.len)) > 0xFFFF) {
 8008296:	253c      	movs	r5, #60	; 0x3c
 8008298:	197b      	adds	r3, r7, r5
 800829a:	881c      	ldrh	r4, [r3, #0]
 800829c:	2618      	movs	r6, #24
 800829e:	19bb      	adds	r3, r7, r6
 80082a0:	891b      	ldrh	r3, [r3, #8]
 80082a2:	0018      	movs	r0, r3
 80082a4:	f7ff f8ac 	bl	8007400 <lwip_htons>
 80082a8:	0003      	movs	r3, r0
 80082aa:	18e2      	adds	r2, r4, r3
 80082ac:	2380      	movs	r3, #128	; 0x80
 80082ae:	025b      	lsls	r3, r3, #9
 80082b0:	429a      	cmp	r2, r3
 80082b2:	da5c      	bge.n	800836e <dns_recv+0x312>
              goto ignore_packet; /* ignore this packet */
            }
            res_idx = (u16_t)(res_idx + lwip_htons(ans.len));
 80082b4:	19bb      	adds	r3, r7, r6
 80082b6:	891b      	ldrh	r3, [r3, #8]
 80082b8:	0018      	movs	r0, r3
 80082ba:	f7ff f8a1 	bl	8007400 <lwip_htons>
 80082be:	0003      	movs	r3, r0
 80082c0:	0019      	movs	r1, r3
 80082c2:	197b      	adds	r3, r7, r5
 80082c4:	197a      	adds	r2, r7, r5
 80082c6:	8812      	ldrh	r2, [r2, #0]
 80082c8:	188a      	adds	r2, r1, r2
 80082ca:	801a      	strh	r2, [r3, #0]
            --nanswers;
 80082cc:	223e      	movs	r2, #62	; 0x3e
 80082ce:	18bb      	adds	r3, r7, r2
 80082d0:	18ba      	adds	r2, r7, r2
 80082d2:	8812      	ldrh	r2, [r2, #0]
 80082d4:	3a01      	subs	r2, #1
 80082d6:	801a      	strh	r2, [r3, #0]
          while ((nanswers > 0) && (res_idx < p->tot_len)) {
 80082d8:	233e      	movs	r3, #62	; 0x3e
 80082da:	18fb      	adds	r3, r7, r3
 80082dc:	881b      	ldrh	r3, [r3, #0]
 80082de:	2b00      	cmp	r3, #0
 80082e0:	d007      	beq.n	80082f2 <dns_recv+0x296>
 80082e2:	687b      	ldr	r3, [r7, #4]
 80082e4:	891b      	ldrh	r3, [r3, #8]
 80082e6:	223c      	movs	r2, #60	; 0x3c
 80082e8:	18ba      	adds	r2, r7, r2
 80082ea:	8812      	ldrh	r2, [r2, #0]
 80082ec:	429a      	cmp	r2, r3
 80082ee:	d200      	bcs.n	80082f2 <dns_recv+0x296>
 80082f0:	e76b      	b.n	80081ca <dns_recv+0x16e>
          }
#endif /* LWIP_IPV4 && LWIP_IPV6 */
          LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": error in response\n", entry->name));
        }
        /* call callback to indicate error, clean up memory and return */
        pbuf_free(p);
 80082f2:	687b      	ldr	r3, [r7, #4]
 80082f4:	0018      	movs	r0, r3
 80082f6:	f002 f8f1 	bl	800a4dc <pbuf_free>
        dns_call_found(i, NULL);
 80082fa:	243b      	movs	r4, #59	; 0x3b
 80082fc:	193b      	adds	r3, r7, r4
 80082fe:	781b      	ldrb	r3, [r3, #0]
 8008300:	2100      	movs	r1, #0
 8008302:	0018      	movs	r0, r3
 8008304:	f7ff fc6a 	bl	8007bdc <dns_call_found>
        dns_table[i].state = DNS_STATE_UNUSED;
 8008308:	193b      	adds	r3, r7, r4
 800830a:	781a      	ldrb	r2, [r3, #0]
 800830c:	491c      	ldr	r1, [pc, #112]	; (8008380 <dns_recv+0x324>)
 800830e:	0013      	movs	r3, r2
 8008310:	00db      	lsls	r3, r3, #3
 8008312:	189b      	adds	r3, r3, r2
 8008314:	011b      	lsls	r3, r3, #4
 8008316:	18cb      	adds	r3, r1, r3
 8008318:	330a      	adds	r3, #10
 800831a:	2200      	movs	r2, #0
 800831c:	701a      	strb	r2, [r3, #0]
        return;
 800831e:	e02c      	b.n	800837a <dns_recv+0x31e>
    for (i = 0; i < DNS_TABLE_SIZE; i++) {
 8008320:	213b      	movs	r1, #59	; 0x3b
 8008322:	187b      	adds	r3, r7, r1
 8008324:	781a      	ldrb	r2, [r3, #0]
 8008326:	187b      	adds	r3, r7, r1
 8008328:	3201      	adds	r2, #1
 800832a:	701a      	strb	r2, [r3, #0]
 800832c:	233b      	movs	r3, #59	; 0x3b
 800832e:	18fb      	adds	r3, r7, r3
 8008330:	781b      	ldrb	r3, [r3, #0]
 8008332:	2b02      	cmp	r3, #2
 8008334:	d800      	bhi.n	8008338 <dns_recv+0x2dc>
 8008336:	e6b6      	b.n	80080a6 <dns_recv+0x4a>
      }
    }
  }

ignore_packet:
 8008338:	e001      	b.n	800833e <dns_recv+0x2e2>
    goto ignore_packet;
 800833a:	46c0      	nop			; (mov r8, r8)
 800833c:	e018      	b.n	8008370 <dns_recv+0x314>
ignore_packet:
 800833e:	46c0      	nop			; (mov r8, r8)
 8008340:	e016      	b.n	8008370 <dns_recv+0x314>
          goto ignore_packet; /* ignore this packet */
 8008342:	46c0      	nop			; (mov r8, r8)
 8008344:	e014      	b.n	8008370 <dns_recv+0x314>
          goto ignore_packet; /* ignore this packet */
 8008346:	46c0      	nop			; (mov r8, r8)
 8008348:	e012      	b.n	8008370 <dns_recv+0x314>
            goto ignore_packet; /* ignore this packet */
 800834a:	46c0      	nop			; (mov r8, r8)
 800834c:	e010      	b.n	8008370 <dns_recv+0x314>
          goto ignore_packet; /* ignore this packet */
 800834e:	46c0      	nop			; (mov r8, r8)
 8008350:	e00e      	b.n	8008370 <dns_recv+0x314>
          goto ignore_packet; /* ignore this packet */
 8008352:	46c0      	nop			; (mov r8, r8)
 8008354:	e00c      	b.n	8008370 <dns_recv+0x314>
          goto ignore_packet; /* ignore this packet */
 8008356:	46c0      	nop			; (mov r8, r8)
 8008358:	e00a      	b.n	8008370 <dns_recv+0x314>
          goto ignore_packet;
 800835a:	46c0      	nop			; (mov r8, r8)
 800835c:	e008      	b.n	8008370 <dns_recv+0x314>
              goto ignore_packet; /* ignore this packet */
 800835e:	46c0      	nop			; (mov r8, r8)
 8008360:	e006      	b.n	8008370 <dns_recv+0x314>
              goto ignore_packet; /* ignore this packet */
 8008362:	46c0      	nop			; (mov r8, r8)
 8008364:	e004      	b.n	8008370 <dns_recv+0x314>
              goto ignore_packet;
 8008366:	46c0      	nop			; (mov r8, r8)
 8008368:	e002      	b.n	8008370 <dns_recv+0x314>
                    goto ignore_packet; /* ignore this packet */
 800836a:	46c0      	nop			; (mov r8, r8)
 800836c:	e000      	b.n	8008370 <dns_recv+0x314>
              goto ignore_packet; /* ignore this packet */
 800836e:	46c0      	nop			; (mov r8, r8)
  /* deallocate memory and return */
  pbuf_free(p);
 8008370:	687b      	ldr	r3, [r7, #4]
 8008372:	0018      	movs	r0, r3
 8008374:	f002 f8b2 	bl	800a4dc <pbuf_free>
  return;
 8008378:	46c0      	nop			; (mov r8, r8)
}
 800837a:	46bd      	mov	sp, r7
 800837c:	b011      	add	sp, #68	; 0x44
 800837e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008380:	20000a40 	.word	0x20000a40
 8008384:	20000c14 	.word	0x20000c14
 8008388:	0000ffff 	.word	0x0000ffff
 800838c:	0000fffb 	.word	0x0000fffb
 8008390:	0000fff5 	.word	0x0000fff5

08008394 <dns_enqueue>:
 * @return err_t return code.
 */
static err_t
dns_enqueue(const char *name, size_t hostnamelen, dns_found_callback found,
            void *callback_arg LWIP_DNS_ADDRTYPE_ARG(u8_t dns_addrtype) LWIP_DNS_ISMDNS_ARG(u8_t is_mdns))
{
 8008394:	b590      	push	{r4, r7, lr}
 8008396:	b08b      	sub	sp, #44	; 0x2c
 8008398:	af00      	add	r7, sp, #0
 800839a:	60f8      	str	r0, [r7, #12]
 800839c:	60b9      	str	r1, [r7, #8]
 800839e:	607a      	str	r2, [r7, #4]
 80083a0:	603b      	str	r3, [r7, #0]
  u8_t i;
  u8_t lseq, lseqi;
  struct dns_table_entry *entry = NULL;
 80083a2:	2300      	movs	r3, #0
 80083a4:	623b      	str	r3, [r7, #32]
  struct dns_req_entry *req;

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING) != 0)
  u8_t r;
  /* check for duplicate entries */
  for (i = 0; i < DNS_TABLE_SIZE; i++) {
 80083a6:	2327      	movs	r3, #39	; 0x27
 80083a8:	18fb      	adds	r3, r7, r3
 80083aa:	2200      	movs	r2, #0
 80083ac:	701a      	strb	r2, [r3, #0]
 80083ae:	e062      	b.n	8008476 <dns_enqueue+0xe2>
    if ((dns_table[i].state == DNS_STATE_ASKING) &&
 80083b0:	2027      	movs	r0, #39	; 0x27
 80083b2:	183b      	adds	r3, r7, r0
 80083b4:	781a      	ldrb	r2, [r3, #0]
 80083b6:	49a3      	ldr	r1, [pc, #652]	; (8008644 <dns_enqueue+0x2b0>)
 80083b8:	0013      	movs	r3, r2
 80083ba:	00db      	lsls	r3, r3, #3
 80083bc:	189b      	adds	r3, r3, r2
 80083be:	011b      	lsls	r3, r3, #4
 80083c0:	18cb      	adds	r3, r1, r3
 80083c2:	330a      	adds	r3, #10
 80083c4:	781b      	ldrb	r3, [r3, #0]
 80083c6:	2b02      	cmp	r3, #2
 80083c8:	d14f      	bne.n	800846a <dns_enqueue+0xd6>
        (lwip_strnicmp(name, dns_table[i].name, sizeof(dns_table[i].name)) == 0)) {
 80083ca:	183b      	adds	r3, r7, r0
 80083cc:	781a      	ldrb	r2, [r3, #0]
 80083ce:	0013      	movs	r3, r2
 80083d0:	00db      	lsls	r3, r3, #3
 80083d2:	189b      	adds	r3, r3, r2
 80083d4:	011b      	lsls	r3, r3, #4
 80083d6:	3310      	adds	r3, #16
 80083d8:	001a      	movs	r2, r3
 80083da:	4b9a      	ldr	r3, [pc, #616]	; (8008644 <dns_enqueue+0x2b0>)
 80083dc:	18d1      	adds	r1, r2, r3
 80083de:	68fb      	ldr	r3, [r7, #12]
 80083e0:	2280      	movs	r2, #128	; 0x80
 80083e2:	0018      	movs	r0, r3
 80083e4:	f7ff f83b 	bl	800745e <lwip_strnicmp>
 80083e8:	1e03      	subs	r3, r0, #0
    if ((dns_table[i].state == DNS_STATE_ASKING) &&
 80083ea:	d13e      	bne.n	800846a <dns_enqueue+0xd6>
           for the same host should not be that common */
        continue;
      }
#endif /* LWIP_IPV4 && LWIP_IPV6 */
      /* this is a duplicate entry, find a free request entry */
      for (r = 0; r < DNS_MAX_REQUESTS; r++) {
 80083ec:	231b      	movs	r3, #27
 80083ee:	18fb      	adds	r3, r7, r3
 80083f0:	2200      	movs	r2, #0
 80083f2:	701a      	strb	r2, [r3, #0]
 80083f4:	e034      	b.n	8008460 <dns_enqueue+0xcc>
        if (dns_requests[r].found == 0) {
 80083f6:	201b      	movs	r0, #27
 80083f8:	183b      	adds	r3, r7, r0
 80083fa:	781a      	ldrb	r2, [r3, #0]
 80083fc:	4992      	ldr	r1, [pc, #584]	; (8008648 <dns_enqueue+0x2b4>)
 80083fe:	0013      	movs	r3, r2
 8008400:	005b      	lsls	r3, r3, #1
 8008402:	189b      	adds	r3, r3, r2
 8008404:	009b      	lsls	r3, r3, #2
 8008406:	585b      	ldr	r3, [r3, r1]
 8008408:	2b00      	cmp	r3, #0
 800840a:	d123      	bne.n	8008454 <dns_enqueue+0xc0>
          dns_requests[r].found = found;
 800840c:	183b      	adds	r3, r7, r0
 800840e:	781a      	ldrb	r2, [r3, #0]
 8008410:	498d      	ldr	r1, [pc, #564]	; (8008648 <dns_enqueue+0x2b4>)
 8008412:	0013      	movs	r3, r2
 8008414:	005b      	lsls	r3, r3, #1
 8008416:	189b      	adds	r3, r3, r2
 8008418:	009b      	lsls	r3, r3, #2
 800841a:	687a      	ldr	r2, [r7, #4]
 800841c:	505a      	str	r2, [r3, r1]
          dns_requests[r].arg = callback_arg;
 800841e:	183b      	adds	r3, r7, r0
 8008420:	781a      	ldrb	r2, [r3, #0]
 8008422:	4989      	ldr	r1, [pc, #548]	; (8008648 <dns_enqueue+0x2b4>)
 8008424:	0013      	movs	r3, r2
 8008426:	005b      	lsls	r3, r3, #1
 8008428:	189b      	adds	r3, r3, r2
 800842a:	009b      	lsls	r3, r3, #2
 800842c:	18cb      	adds	r3, r1, r3
 800842e:	3304      	adds	r3, #4
 8008430:	683a      	ldr	r2, [r7, #0]
 8008432:	601a      	str	r2, [r3, #0]
          dns_requests[r].dns_table_idx = i;
 8008434:	183b      	adds	r3, r7, r0
 8008436:	781a      	ldrb	r2, [r3, #0]
 8008438:	4983      	ldr	r1, [pc, #524]	; (8008648 <dns_enqueue+0x2b4>)
 800843a:	0013      	movs	r3, r2
 800843c:	005b      	lsls	r3, r3, #1
 800843e:	189b      	adds	r3, r3, r2
 8008440:	009b      	lsls	r3, r3, #2
 8008442:	18cb      	adds	r3, r1, r3
 8008444:	3308      	adds	r3, #8
 8008446:	2227      	movs	r2, #39	; 0x27
 8008448:	18ba      	adds	r2, r7, r2
 800844a:	7812      	ldrb	r2, [r2, #0]
 800844c:	701a      	strb	r2, [r3, #0]
          LWIP_DNS_SET_ADDRTYPE(dns_requests[r].reqaddrtype, dns_addrtype);
          LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": duplicate request\n", name));
          return ERR_INPROGRESS;
 800844e:	2305      	movs	r3, #5
 8008450:	425b      	negs	r3, r3
 8008452:	e0f3      	b.n	800863c <dns_enqueue+0x2a8>
      for (r = 0; r < DNS_MAX_REQUESTS; r++) {
 8008454:	211b      	movs	r1, #27
 8008456:	187b      	adds	r3, r7, r1
 8008458:	781a      	ldrb	r2, [r3, #0]
 800845a:	187b      	adds	r3, r7, r1
 800845c:	3201      	adds	r2, #1
 800845e:	701a      	strb	r2, [r3, #0]
 8008460:	231b      	movs	r3, #27
 8008462:	18fb      	adds	r3, r7, r3
 8008464:	781b      	ldrb	r3, [r3, #0]
 8008466:	2b02      	cmp	r3, #2
 8008468:	d9c5      	bls.n	80083f6 <dns_enqueue+0x62>
  for (i = 0; i < DNS_TABLE_SIZE; i++) {
 800846a:	2127      	movs	r1, #39	; 0x27
 800846c:	187b      	adds	r3, r7, r1
 800846e:	781a      	ldrb	r2, [r3, #0]
 8008470:	187b      	adds	r3, r7, r1
 8008472:	3201      	adds	r2, #1
 8008474:	701a      	strb	r2, [r3, #0]
 8008476:	2127      	movs	r1, #39	; 0x27
 8008478:	187b      	adds	r3, r7, r1
 800847a:	781b      	ldrb	r3, [r3, #0]
 800847c:	2b02      	cmp	r3, #2
 800847e:	d997      	bls.n	80083b0 <dns_enqueue+0x1c>
  }
  /* no duplicate entries found */
#endif

  /* search an unused entry, or the oldest one */
  lseq = 0;
 8008480:	2326      	movs	r3, #38	; 0x26
 8008482:	18fb      	adds	r3, r7, r3
 8008484:	2200      	movs	r2, #0
 8008486:	701a      	strb	r2, [r3, #0]
  lseqi = DNS_TABLE_SIZE;
 8008488:	2325      	movs	r3, #37	; 0x25
 800848a:	18fb      	adds	r3, r7, r3
 800848c:	2203      	movs	r2, #3
 800848e:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 8008490:	187b      	adds	r3, r7, r1
 8008492:	2200      	movs	r2, #0
 8008494:	701a      	strb	r2, [r3, #0]
 8008496:	e030      	b.n	80084fa <dns_enqueue+0x166>
    entry = &dns_table[i];
 8008498:	2427      	movs	r4, #39	; 0x27
 800849a:	193b      	adds	r3, r7, r4
 800849c:	781a      	ldrb	r2, [r3, #0]
 800849e:	0013      	movs	r3, r2
 80084a0:	00db      	lsls	r3, r3, #3
 80084a2:	189b      	adds	r3, r3, r2
 80084a4:	011b      	lsls	r3, r3, #4
 80084a6:	4a67      	ldr	r2, [pc, #412]	; (8008644 <dns_enqueue+0x2b0>)
 80084a8:	189b      	adds	r3, r3, r2
 80084aa:	623b      	str	r3, [r7, #32]
    /* is it an unused entry ? */
    if (entry->state == DNS_STATE_UNUSED) {
 80084ac:	6a3b      	ldr	r3, [r7, #32]
 80084ae:	7a9b      	ldrb	r3, [r3, #10]
 80084b0:	2b00      	cmp	r3, #0
 80084b2:	d028      	beq.n	8008506 <dns_enqueue+0x172>
      break;
    }
    /* check if this is the oldest completed entry */
    if (entry->state == DNS_STATE_DONE) {
 80084b4:	6a3b      	ldr	r3, [r7, #32]
 80084b6:	7a9b      	ldrb	r3, [r3, #10]
 80084b8:	2b03      	cmp	r3, #3
 80084ba:	d118      	bne.n	80084ee <dns_enqueue+0x15a>
      u8_t age = (u8_t)(dns_seqno - entry->seqno);
 80084bc:	4b63      	ldr	r3, [pc, #396]	; (800864c <dns_enqueue+0x2b8>)
 80084be:	7819      	ldrb	r1, [r3, #0]
 80084c0:	6a3b      	ldr	r3, [r7, #32]
 80084c2:	7b9a      	ldrb	r2, [r3, #14]
 80084c4:	201a      	movs	r0, #26
 80084c6:	183b      	adds	r3, r7, r0
 80084c8:	1a8a      	subs	r2, r1, r2
 80084ca:	701a      	strb	r2, [r3, #0]
      if (age > lseq) {
 80084cc:	0001      	movs	r1, r0
 80084ce:	187a      	adds	r2, r7, r1
 80084d0:	2026      	movs	r0, #38	; 0x26
 80084d2:	183b      	adds	r3, r7, r0
 80084d4:	7812      	ldrb	r2, [r2, #0]
 80084d6:	781b      	ldrb	r3, [r3, #0]
 80084d8:	429a      	cmp	r2, r3
 80084da:	d908      	bls.n	80084ee <dns_enqueue+0x15a>
        lseq = age;
 80084dc:	183b      	adds	r3, r7, r0
 80084de:	187a      	adds	r2, r7, r1
 80084e0:	7812      	ldrb	r2, [r2, #0]
 80084e2:	701a      	strb	r2, [r3, #0]
        lseqi = i;
 80084e4:	2325      	movs	r3, #37	; 0x25
 80084e6:	18fb      	adds	r3, r7, r3
 80084e8:	193a      	adds	r2, r7, r4
 80084ea:	7812      	ldrb	r2, [r2, #0]
 80084ec:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 80084ee:	2227      	movs	r2, #39	; 0x27
 80084f0:	18bb      	adds	r3, r7, r2
 80084f2:	18ba      	adds	r2, r7, r2
 80084f4:	7812      	ldrb	r2, [r2, #0]
 80084f6:	3201      	adds	r2, #1
 80084f8:	701a      	strb	r2, [r3, #0]
 80084fa:	2327      	movs	r3, #39	; 0x27
 80084fc:	18fb      	adds	r3, r7, r3
 80084fe:	781b      	ldrb	r3, [r3, #0]
 8008500:	2b02      	cmp	r3, #2
 8008502:	d9c9      	bls.n	8008498 <dns_enqueue+0x104>
 8008504:	e000      	b.n	8008508 <dns_enqueue+0x174>
      break;
 8008506:	46c0      	nop			; (mov r8, r8)
      }
    }
  }

  /* if we don't have found an unused entry, use the oldest completed one */
  if (i == DNS_TABLE_SIZE) {
 8008508:	2327      	movs	r3, #39	; 0x27
 800850a:	18fb      	adds	r3, r7, r3
 800850c:	781b      	ldrb	r3, [r3, #0]
 800850e:	2b03      	cmp	r3, #3
 8008510:	d122      	bne.n	8008558 <dns_enqueue+0x1c4>
    if ((lseqi >= DNS_TABLE_SIZE) || (dns_table[lseqi].state != DNS_STATE_DONE)) {
 8008512:	2225      	movs	r2, #37	; 0x25
 8008514:	18bb      	adds	r3, r7, r2
 8008516:	781b      	ldrb	r3, [r3, #0]
 8008518:	2b02      	cmp	r3, #2
 800851a:	d80b      	bhi.n	8008534 <dns_enqueue+0x1a0>
 800851c:	18bb      	adds	r3, r7, r2
 800851e:	781a      	ldrb	r2, [r3, #0]
 8008520:	4948      	ldr	r1, [pc, #288]	; (8008644 <dns_enqueue+0x2b0>)
 8008522:	0013      	movs	r3, r2
 8008524:	00db      	lsls	r3, r3, #3
 8008526:	189b      	adds	r3, r3, r2
 8008528:	011b      	lsls	r3, r3, #4
 800852a:	18cb      	adds	r3, r1, r3
 800852c:	330a      	adds	r3, #10
 800852e:	781b      	ldrb	r3, [r3, #0]
 8008530:	2b03      	cmp	r3, #3
 8008532:	d002      	beq.n	800853a <dns_enqueue+0x1a6>
      /* no entry can be used now, table is full */
      LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": DNS entries table is full\n", name));
      return ERR_MEM;
 8008534:	2301      	movs	r3, #1
 8008536:	425b      	negs	r3, r3
 8008538:	e080      	b.n	800863c <dns_enqueue+0x2a8>
    } else {
      /* use the oldest completed one */
      i = lseqi;
 800853a:	2127      	movs	r1, #39	; 0x27
 800853c:	187b      	adds	r3, r7, r1
 800853e:	2225      	movs	r2, #37	; 0x25
 8008540:	18ba      	adds	r2, r7, r2
 8008542:	7812      	ldrb	r2, [r2, #0]
 8008544:	701a      	strb	r2, [r3, #0]
      entry = &dns_table[i];
 8008546:	187b      	adds	r3, r7, r1
 8008548:	781a      	ldrb	r2, [r3, #0]
 800854a:	0013      	movs	r3, r2
 800854c:	00db      	lsls	r3, r3, #3
 800854e:	189b      	adds	r3, r3, r2
 8008550:	011b      	lsls	r3, r3, #4
 8008552:	4a3c      	ldr	r2, [pc, #240]	; (8008644 <dns_enqueue+0x2b0>)
 8008554:	189b      	adds	r3, r3, r2
 8008556:	623b      	str	r3, [r7, #32]
    }
  }

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING) != 0)
  /* find a free request entry */
  req = NULL;
 8008558:	2300      	movs	r3, #0
 800855a:	61fb      	str	r3, [r7, #28]
  for (r = 0; r < DNS_MAX_REQUESTS; r++) {
 800855c:	231b      	movs	r3, #27
 800855e:	18fb      	adds	r3, r7, r3
 8008560:	2200      	movs	r2, #0
 8008562:	701a      	strb	r2, [r3, #0]
 8008564:	e01a      	b.n	800859c <dns_enqueue+0x208>
    if (dns_requests[r].found == NULL) {
 8008566:	201b      	movs	r0, #27
 8008568:	183b      	adds	r3, r7, r0
 800856a:	781a      	ldrb	r2, [r3, #0]
 800856c:	4936      	ldr	r1, [pc, #216]	; (8008648 <dns_enqueue+0x2b4>)
 800856e:	0013      	movs	r3, r2
 8008570:	005b      	lsls	r3, r3, #1
 8008572:	189b      	adds	r3, r3, r2
 8008574:	009b      	lsls	r3, r3, #2
 8008576:	585b      	ldr	r3, [r3, r1]
 8008578:	2b00      	cmp	r3, #0
 800857a:	d109      	bne.n	8008590 <dns_enqueue+0x1fc>
      req = &dns_requests[r];
 800857c:	183b      	adds	r3, r7, r0
 800857e:	781a      	ldrb	r2, [r3, #0]
 8008580:	0013      	movs	r3, r2
 8008582:	005b      	lsls	r3, r3, #1
 8008584:	189b      	adds	r3, r3, r2
 8008586:	009b      	lsls	r3, r3, #2
 8008588:	4a2f      	ldr	r2, [pc, #188]	; (8008648 <dns_enqueue+0x2b4>)
 800858a:	189b      	adds	r3, r3, r2
 800858c:	61fb      	str	r3, [r7, #28]
      break;
 800858e:	e00a      	b.n	80085a6 <dns_enqueue+0x212>
  for (r = 0; r < DNS_MAX_REQUESTS; r++) {
 8008590:	211b      	movs	r1, #27
 8008592:	187b      	adds	r3, r7, r1
 8008594:	781a      	ldrb	r2, [r3, #0]
 8008596:	187b      	adds	r3, r7, r1
 8008598:	3201      	adds	r2, #1
 800859a:	701a      	strb	r2, [r3, #0]
 800859c:	231b      	movs	r3, #27
 800859e:	18fb      	adds	r3, r7, r3
 80085a0:	781b      	ldrb	r3, [r3, #0]
 80085a2:	2b02      	cmp	r3, #2
 80085a4:	d9df      	bls.n	8008566 <dns_enqueue+0x1d2>
    }
  }
  if (req == NULL) {
 80085a6:	69fb      	ldr	r3, [r7, #28]
 80085a8:	2b00      	cmp	r3, #0
 80085aa:	d102      	bne.n	80085b2 <dns_enqueue+0x21e>
    /* no request entry can be used now, table is full */
    LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": DNS request entries table is full\n", name));
    return ERR_MEM;
 80085ac:	2301      	movs	r3, #1
 80085ae:	425b      	negs	r3, r3
 80085b0:	e044      	b.n	800863c <dns_enqueue+0x2a8>
  }
  req->dns_table_idx = i;
 80085b2:	69fb      	ldr	r3, [r7, #28]
 80085b4:	2227      	movs	r2, #39	; 0x27
 80085b6:	18ba      	adds	r2, r7, r2
 80085b8:	7812      	ldrb	r2, [r2, #0]
 80085ba:	721a      	strb	r2, [r3, #8]

  /* use this entry */
  LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": use DNS entry %"U16_F"\n", name, (u16_t)(i)));

  /* fill the entry */
  entry->state = DNS_STATE_NEW;
 80085bc:	6a3b      	ldr	r3, [r7, #32]
 80085be:	2201      	movs	r2, #1
 80085c0:	729a      	strb	r2, [r3, #10]
  entry->seqno = dns_seqno;
 80085c2:	4b22      	ldr	r3, [pc, #136]	; (800864c <dns_enqueue+0x2b8>)
 80085c4:	781a      	ldrb	r2, [r3, #0]
 80085c6:	6a3b      	ldr	r3, [r7, #32]
 80085c8:	739a      	strb	r2, [r3, #14]
  LWIP_DNS_SET_ADDRTYPE(entry->reqaddrtype, dns_addrtype);
  LWIP_DNS_SET_ADDRTYPE(req->reqaddrtype, dns_addrtype);
  req->found = found;
 80085ca:	69fb      	ldr	r3, [r7, #28]
 80085cc:	687a      	ldr	r2, [r7, #4]
 80085ce:	601a      	str	r2, [r3, #0]
  req->arg   = callback_arg;
 80085d0:	69fb      	ldr	r3, [r7, #28]
 80085d2:	683a      	ldr	r2, [r7, #0]
 80085d4:	605a      	str	r2, [r3, #4]
  namelen = LWIP_MIN(hostnamelen, DNS_MAX_NAME_LENGTH - 1);
 80085d6:	68bb      	ldr	r3, [r7, #8]
 80085d8:	2b7f      	cmp	r3, #127	; 0x7f
 80085da:	d900      	bls.n	80085de <dns_enqueue+0x24a>
 80085dc:	237f      	movs	r3, #127	; 0x7f
 80085de:	617b      	str	r3, [r7, #20]
  MEMCPY(entry->name, name, namelen);
 80085e0:	6a3b      	ldr	r3, [r7, #32]
 80085e2:	3310      	adds	r3, #16
 80085e4:	697a      	ldr	r2, [r7, #20]
 80085e6:	68f9      	ldr	r1, [r7, #12]
 80085e8:	0018      	movs	r0, r3
 80085ea:	f015 fcd7 	bl	801df9c <memcpy>
  entry->name[namelen] = 0;
 80085ee:	6a3a      	ldr	r2, [r7, #32]
 80085f0:	697b      	ldr	r3, [r7, #20]
 80085f2:	18d3      	adds	r3, r2, r3
 80085f4:	3310      	adds	r3, #16
 80085f6:	2200      	movs	r2, #0
 80085f8:	701a      	strb	r2, [r3, #0]

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) != 0)
  entry->pcb_idx = dns_alloc_pcb();
 80085fa:	f7ff fa87 	bl	8007b0c <dns_alloc_pcb>
 80085fe:	0003      	movs	r3, r0
 8008600:	001a      	movs	r2, r3
 8008602:	6a3b      	ldr	r3, [r7, #32]
 8008604:	73da      	strb	r2, [r3, #15]
  if (entry->pcb_idx >= DNS_MAX_SOURCE_PORTS) {
 8008606:	6a3b      	ldr	r3, [r7, #32]
 8008608:	7bdb      	ldrb	r3, [r3, #15]
 800860a:	2b02      	cmp	r3, #2
 800860c:	d908      	bls.n	8008620 <dns_enqueue+0x28c>
    /* failed to get a UDP pcb */
    LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": failed to allocate a pcb\n", name));
    entry->state = DNS_STATE_UNUSED;
 800860e:	6a3b      	ldr	r3, [r7, #32]
 8008610:	2200      	movs	r2, #0
 8008612:	729a      	strb	r2, [r3, #10]
    req->found = NULL;
 8008614:	69fb      	ldr	r3, [r7, #28]
 8008616:	2200      	movs	r2, #0
 8008618:	601a      	str	r2, [r3, #0]
    return ERR_MEM;
 800861a:	2301      	movs	r3, #1
 800861c:	425b      	negs	r3, r3
 800861e:	e00d      	b.n	800863c <dns_enqueue+0x2a8>

#if LWIP_DNS_SUPPORT_MDNS_QUERIES
  entry->is_mdns = is_mdns;
#endif

  dns_seqno++;
 8008620:	4b0a      	ldr	r3, [pc, #40]	; (800864c <dns_enqueue+0x2b8>)
 8008622:	781b      	ldrb	r3, [r3, #0]
 8008624:	3301      	adds	r3, #1
 8008626:	b2da      	uxtb	r2, r3
 8008628:	4b08      	ldr	r3, [pc, #32]	; (800864c <dns_enqueue+0x2b8>)
 800862a:	701a      	strb	r2, [r3, #0]

  /* force to send query without waiting timer */
  dns_check_entry(i);
 800862c:	2327      	movs	r3, #39	; 0x27
 800862e:	18fb      	adds	r3, r7, r3
 8008630:	781b      	ldrb	r3, [r3, #0]
 8008632:	0018      	movs	r0, r3
 8008634:	f7ff fc0c 	bl	8007e50 <dns_check_entry>

  /* dns query is enqueued */
  return ERR_INPROGRESS;
 8008638:	2305      	movs	r3, #5
 800863a:	425b      	negs	r3, r3
}
 800863c:	0018      	movs	r0, r3
 800863e:	46bd      	mov	sp, r7
 8008640:	b00b      	add	sp, #44	; 0x2c
 8008642:	bd90      	pop	{r4, r7, pc}
 8008644:	20000a40 	.word	0x20000a40
 8008648:	20000bf0 	.word	0x20000bf0
 800864c:	20000a3d 	.word	0x20000a3d

08008650 <dns_gethostbyname>:
 * @return a err_t return code.
 */
err_t
dns_gethostbyname(const char *hostname, ip_addr_t *addr, dns_found_callback found,
                  void *callback_arg)
{
 8008650:	b590      	push	{r4, r7, lr}
 8008652:	b087      	sub	sp, #28
 8008654:	af02      	add	r7, sp, #8
 8008656:	60f8      	str	r0, [r7, #12]
 8008658:	60b9      	str	r1, [r7, #8]
 800865a:	607a      	str	r2, [r7, #4]
 800865c:	603b      	str	r3, [r7, #0]
  return dns_gethostbyname_addrtype(hostname, addr, found, callback_arg, LWIP_DNS_ADDRTYPE_DEFAULT);
 800865e:	683b      	ldr	r3, [r7, #0]
 8008660:	687a      	ldr	r2, [r7, #4]
 8008662:	68b9      	ldr	r1, [r7, #8]
 8008664:	68f8      	ldr	r0, [r7, #12]
 8008666:	2400      	movs	r4, #0
 8008668:	9400      	str	r4, [sp, #0]
 800866a:	f000 f805 	bl	8008678 <dns_gethostbyname_addrtype>
 800866e:	0003      	movs	r3, r0
}
 8008670:	0018      	movs	r0, r3
 8008672:	46bd      	mov	sp, r7
 8008674:	b005      	add	sp, #20
 8008676:	bd90      	pop	{r4, r7, pc}

08008678 <dns_gethostbyname_addrtype>:
 *                     - LWIP_DNS_ADDRTYPE_IPV6: try to resolve IPv6 only
 */
err_t
dns_gethostbyname_addrtype(const char *hostname, ip_addr_t *addr, dns_found_callback found,
                           void *callback_arg, u8_t dns_addrtype)
{
 8008678:	b580      	push	{r7, lr}
 800867a:	b086      	sub	sp, #24
 800867c:	af00      	add	r7, sp, #0
 800867e:	60f8      	str	r0, [r7, #12]
 8008680:	60b9      	str	r1, [r7, #8]
 8008682:	607a      	str	r2, [r7, #4]
 8008684:	603b      	str	r3, [r7, #0]
#if LWIP_DNS_SUPPORT_MDNS_QUERIES
  u8_t is_mdns;
#endif
  /* not initialized or no valid server yet, or invalid addr pointer
   * or invalid hostname or invalid hostname length */
  if ((addr == NULL) ||
 8008686:	68bb      	ldr	r3, [r7, #8]
 8008688:	2b00      	cmp	r3, #0
 800868a:	d006      	beq.n	800869a <dns_gethostbyname_addrtype+0x22>
 800868c:	68fb      	ldr	r3, [r7, #12]
 800868e:	2b00      	cmp	r3, #0
 8008690:	d003      	beq.n	800869a <dns_gethostbyname_addrtype+0x22>
      (!hostname) || (!hostname[0])) {
 8008692:	68fb      	ldr	r3, [r7, #12]
 8008694:	781b      	ldrb	r3, [r3, #0]
 8008696:	2b00      	cmp	r3, #0
 8008698:	d102      	bne.n	80086a0 <dns_gethostbyname_addrtype+0x28>
    return ERR_ARG;
 800869a:	2310      	movs	r3, #16
 800869c:	425b      	negs	r3, r3
 800869e:	e02d      	b.n	80086fc <dns_gethostbyname_addrtype+0x84>
#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) == 0)
  if (dns_pcbs[0] == NULL) {
    return ERR_ARG;
  }
#endif
  hostnamelen = strlen(hostname);
 80086a0:	68fb      	ldr	r3, [r7, #12]
 80086a2:	0018      	movs	r0, r3
 80086a4:	f7f7 fd3a 	bl	800011c <strlen>
 80086a8:	0003      	movs	r3, r0
 80086aa:	617b      	str	r3, [r7, #20]
  if (hostnamelen >= DNS_MAX_NAME_LENGTH) {
 80086ac:	697b      	ldr	r3, [r7, #20]
 80086ae:	2b7f      	cmp	r3, #127	; 0x7f
 80086b0:	d902      	bls.n	80086b8 <dns_gethostbyname_addrtype+0x40>
    LWIP_DEBUGF(DNS_DEBUG, ("dns_gethostbyname: name too long to resolve"));
    return ERR_ARG;
 80086b2:	2310      	movs	r3, #16
 80086b4:	425b      	negs	r3, r3
 80086b6:	e021      	b.n	80086fc <dns_gethostbyname_addrtype+0x84>
    return ERR_OK;
  }
#endif /* LWIP_HAVE_LOOPIF */

  /* host name already in octet notation? set ip addr and return ERR_OK */
  if (ipaddr_aton(hostname, addr)) {
 80086b8:	68ba      	ldr	r2, [r7, #8]
 80086ba:	68fb      	ldr	r3, [r7, #12]
 80086bc:	0011      	movs	r1, r2
 80086be:	0018      	movs	r0, r3
 80086c0:	f00b ff60 	bl	8014584 <ip4addr_aton>
 80086c4:	1e03      	subs	r3, r0, #0
 80086c6:	d001      	beq.n	80086cc <dns_gethostbyname_addrtype+0x54>
#if LWIP_IPV4 && LWIP_IPV6
    if ((IP_IS_V6(addr) && (dns_addrtype != LWIP_DNS_ADDRTYPE_IPV4)) ||
        (IP_IS_V4(addr) && (dns_addrtype != LWIP_DNS_ADDRTYPE_IPV6)))
#endif /* LWIP_IPV4 && LWIP_IPV6 */
    {
      return ERR_OK;
 80086c8:	2300      	movs	r3, #0
 80086ca:	e017      	b.n	80086fc <dns_gethostbyname_addrtype+0x84>
    }
  }
  /* already have this address cached? */
  if (dns_lookup(hostname, addr LWIP_DNS_ADDRTYPE_ARG(dns_addrtype)) == ERR_OK) {
 80086cc:	68ba      	ldr	r2, [r7, #8]
 80086ce:	68fb      	ldr	r3, [r7, #12]
 80086d0:	0011      	movs	r1, r2
 80086d2:	0018      	movs	r0, r3
 80086d4:	f7fe ff5c 	bl	8007590 <dns_lookup>
 80086d8:	1e03      	subs	r3, r0, #0
 80086da:	d101      	bne.n	80086e0 <dns_gethostbyname_addrtype+0x68>
    return ERR_OK;
 80086dc:	2300      	movs	r3, #0
 80086de:	e00d      	b.n	80086fc <dns_gethostbyname_addrtype+0x84>

  if (!is_mdns)
#endif /* LWIP_DNS_SUPPORT_MDNS_QUERIES */
  {
    /* prevent calling found callback if no server is set, return error instead */
    if (ip_addr_isany_val(dns_servers[0])) {
 80086e0:	4b08      	ldr	r3, [pc, #32]	; (8008704 <dns_gethostbyname_addrtype+0x8c>)
 80086e2:	681b      	ldr	r3, [r3, #0]
 80086e4:	2b00      	cmp	r3, #0
 80086e6:	d102      	bne.n	80086ee <dns_gethostbyname_addrtype+0x76>
      return ERR_VAL;
 80086e8:	2306      	movs	r3, #6
 80086ea:	425b      	negs	r3, r3
 80086ec:	e006      	b.n	80086fc <dns_gethostbyname_addrtype+0x84>
    }
  }

  /* queue query with specified callback */
  return dns_enqueue(hostname, hostnamelen, found, callback_arg LWIP_DNS_ADDRTYPE_ARG(dns_addrtype)
 80086ee:	683b      	ldr	r3, [r7, #0]
 80086f0:	687a      	ldr	r2, [r7, #4]
 80086f2:	6979      	ldr	r1, [r7, #20]
 80086f4:	68f8      	ldr	r0, [r7, #12]
 80086f6:	f7ff fe4d 	bl	8008394 <dns_enqueue>
 80086fa:	0003      	movs	r3, r0
                     LWIP_DNS_ISMDNS_ARG(is_mdns));
}
 80086fc:	0018      	movs	r0, r3
 80086fe:	46bd      	mov	sp, r7
 8008700:	b006      	add	sp, #24
 8008702:	bd80      	pop	{r7, pc}
 8008704:	20000c14 	.word	0x20000c14

08008708 <lwip_standard_chksum>:
 * @param len length of data to be summed
 * @return host order (!) lwip checksum (non-inverted Internet sum)
 */
u16_t
lwip_standard_chksum(const void *dataptr, int len)
{
 8008708:	b580      	push	{r7, lr}
 800870a:	b088      	sub	sp, #32
 800870c:	af00      	add	r7, sp, #0
 800870e:	6078      	str	r0, [r7, #4]
 8008710:	6039      	str	r1, [r7, #0]
  const u8_t *pb = (const u8_t *)dataptr;
 8008712:	687b      	ldr	r3, [r7, #4]
 8008714:	61fb      	str	r3, [r7, #28]
  const u16_t *ps;
  u16_t t = 0;
 8008716:	210e      	movs	r1, #14
 8008718:	187b      	adds	r3, r7, r1
 800871a:	2200      	movs	r2, #0
 800871c:	801a      	strh	r2, [r3, #0]
  u32_t sum = 0;
 800871e:	2300      	movs	r3, #0
 8008720:	617b      	str	r3, [r7, #20]
  int odd = ((mem_ptr_t)pb & 1);
 8008722:	69fb      	ldr	r3, [r7, #28]
 8008724:	2201      	movs	r2, #1
 8008726:	4013      	ands	r3, r2
 8008728:	613b      	str	r3, [r7, #16]

  /* Get aligned to u16_t */
  if (odd && len > 0) {
 800872a:	693b      	ldr	r3, [r7, #16]
 800872c:	2b00      	cmp	r3, #0
 800872e:	d00c      	beq.n	800874a <lwip_standard_chksum+0x42>
 8008730:	683b      	ldr	r3, [r7, #0]
 8008732:	2b00      	cmp	r3, #0
 8008734:	dd09      	ble.n	800874a <lwip_standard_chksum+0x42>
    ((u8_t *)&t)[1] = *pb++;
 8008736:	69fa      	ldr	r2, [r7, #28]
 8008738:	1c53      	adds	r3, r2, #1
 800873a:	61fb      	str	r3, [r7, #28]
 800873c:	187b      	adds	r3, r7, r1
 800873e:	3301      	adds	r3, #1
 8008740:	7812      	ldrb	r2, [r2, #0]
 8008742:	701a      	strb	r2, [r3, #0]
    len--;
 8008744:	683b      	ldr	r3, [r7, #0]
 8008746:	3b01      	subs	r3, #1
 8008748:	603b      	str	r3, [r7, #0]
  }

  /* Add the bulk of the data */
  ps = (const u16_t *)(const void *)pb;
 800874a:	69fb      	ldr	r3, [r7, #28]
 800874c:	61bb      	str	r3, [r7, #24]
  while (len > 1) {
 800874e:	e00a      	b.n	8008766 <lwip_standard_chksum+0x5e>
    sum += *ps++;
 8008750:	69bb      	ldr	r3, [r7, #24]
 8008752:	1c9a      	adds	r2, r3, #2
 8008754:	61ba      	str	r2, [r7, #24]
 8008756:	881b      	ldrh	r3, [r3, #0]
 8008758:	001a      	movs	r2, r3
 800875a:	697b      	ldr	r3, [r7, #20]
 800875c:	189b      	adds	r3, r3, r2
 800875e:	617b      	str	r3, [r7, #20]
    len -= 2;
 8008760:	683b      	ldr	r3, [r7, #0]
 8008762:	3b02      	subs	r3, #2
 8008764:	603b      	str	r3, [r7, #0]
  while (len > 1) {
 8008766:	683b      	ldr	r3, [r7, #0]
 8008768:	2b01      	cmp	r3, #1
 800876a:	dcf1      	bgt.n	8008750 <lwip_standard_chksum+0x48>
  }

  /* Consume left-over byte, if any */
  if (len > 0) {
 800876c:	683b      	ldr	r3, [r7, #0]
 800876e:	2b00      	cmp	r3, #0
 8008770:	dd04      	ble.n	800877c <lwip_standard_chksum+0x74>
    ((u8_t *)&t)[0] = *(const u8_t *)ps;
 8008772:	230e      	movs	r3, #14
 8008774:	18fb      	adds	r3, r7, r3
 8008776:	69ba      	ldr	r2, [r7, #24]
 8008778:	7812      	ldrb	r2, [r2, #0]
 800877a:	701a      	strb	r2, [r3, #0]
  }

  /* Add end bytes */
  sum += t;
 800877c:	230e      	movs	r3, #14
 800877e:	18fb      	adds	r3, r7, r3
 8008780:	881b      	ldrh	r3, [r3, #0]
 8008782:	001a      	movs	r2, r3
 8008784:	697b      	ldr	r3, [r7, #20]
 8008786:	189b      	adds	r3, r3, r2
 8008788:	617b      	str	r3, [r7, #20]

  /* Fold 32-bit sum to 16 bits
     calling this twice is probably faster than if statements... */
  sum = FOLD_U32T(sum);
 800878a:	697b      	ldr	r3, [r7, #20]
 800878c:	0c1a      	lsrs	r2, r3, #16
 800878e:	697b      	ldr	r3, [r7, #20]
 8008790:	041b      	lsls	r3, r3, #16
 8008792:	0c1b      	lsrs	r3, r3, #16
 8008794:	18d3      	adds	r3, r2, r3
 8008796:	617b      	str	r3, [r7, #20]
  sum = FOLD_U32T(sum);
 8008798:	697b      	ldr	r3, [r7, #20]
 800879a:	0c1a      	lsrs	r2, r3, #16
 800879c:	697b      	ldr	r3, [r7, #20]
 800879e:	041b      	lsls	r3, r3, #16
 80087a0:	0c1b      	lsrs	r3, r3, #16
 80087a2:	18d3      	adds	r3, r2, r3
 80087a4:	617b      	str	r3, [r7, #20]

  /* Swap if alignment was odd */
  if (odd) {
 80087a6:	693b      	ldr	r3, [r7, #16]
 80087a8:	2b00      	cmp	r3, #0
 80087aa:	d009      	beq.n	80087c0 <lwip_standard_chksum+0xb8>
    sum = SWAP_BYTES_IN_WORD(sum);
 80087ac:	697b      	ldr	r3, [r7, #20]
 80087ae:	021b      	lsls	r3, r3, #8
 80087b0:	041b      	lsls	r3, r3, #16
 80087b2:	0c1a      	lsrs	r2, r3, #16
 80087b4:	697b      	ldr	r3, [r7, #20]
 80087b6:	0a1b      	lsrs	r3, r3, #8
 80087b8:	21ff      	movs	r1, #255	; 0xff
 80087ba:	400b      	ands	r3, r1
 80087bc:	4313      	orrs	r3, r2
 80087be:	617b      	str	r3, [r7, #20]
  }

  return (u16_t)sum;
 80087c0:	697b      	ldr	r3, [r7, #20]
 80087c2:	b29b      	uxth	r3, r3
}
 80087c4:	0018      	movs	r0, r3
 80087c6:	46bd      	mov	sp, r7
 80087c8:	b008      	add	sp, #32
 80087ca:	bd80      	pop	{r7, pc}

080087cc <inet_cksum_pseudo_base>:
#endif

/** Parts of the pseudo checksum which are common to IPv4 and IPv6 */
static u16_t
inet_cksum_pseudo_base(struct pbuf *p, u8_t proto, u16_t proto_len, u32_t acc)
{
 80087cc:	b580      	push	{r7, lr}
 80087ce:	b086      	sub	sp, #24
 80087d0:	af00      	add	r7, sp, #0
 80087d2:	60f8      	str	r0, [r7, #12]
 80087d4:	0008      	movs	r0, r1
 80087d6:	0011      	movs	r1, r2
 80087d8:	607b      	str	r3, [r7, #4]
 80087da:	230b      	movs	r3, #11
 80087dc:	18fb      	adds	r3, r7, r3
 80087de:	1c02      	adds	r2, r0, #0
 80087e0:	701a      	strb	r2, [r3, #0]
 80087e2:	2308      	movs	r3, #8
 80087e4:	18fb      	adds	r3, r7, r3
 80087e6:	1c0a      	adds	r2, r1, #0
 80087e8:	801a      	strh	r2, [r3, #0]
  struct pbuf *q;
  int swapped = 0;
 80087ea:	2300      	movs	r3, #0
 80087ec:	613b      	str	r3, [r7, #16]

  /* iterate through all pbuf in chain */
  for (q = p; q != NULL; q = q->next) {
 80087ee:	68fb      	ldr	r3, [r7, #12]
 80087f0:	617b      	str	r3, [r7, #20]
 80087f2:	e02c      	b.n	800884e <inet_cksum_pseudo_base+0x82>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
                             (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
 80087f4:	697b      	ldr	r3, [r7, #20]
 80087f6:	685a      	ldr	r2, [r3, #4]
 80087f8:	697b      	ldr	r3, [r7, #20]
 80087fa:	895b      	ldrh	r3, [r3, #10]
 80087fc:	0019      	movs	r1, r3
 80087fe:	0010      	movs	r0, r2
 8008800:	f7ff ff82 	bl	8008708 <lwip_standard_chksum>
 8008804:	0003      	movs	r3, r0
 8008806:	001a      	movs	r2, r3
 8008808:	687b      	ldr	r3, [r7, #4]
 800880a:	189b      	adds	r3, r3, r2
 800880c:	607b      	str	r3, [r7, #4]
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
 800880e:	687b      	ldr	r3, [r7, #4]
 8008810:	0c1a      	lsrs	r2, r3, #16
 8008812:	687b      	ldr	r3, [r7, #4]
 8008814:	041b      	lsls	r3, r3, #16
 8008816:	0c1b      	lsrs	r3, r3, #16
 8008818:	18d3      	adds	r3, r2, r3
 800881a:	607b      	str	r3, [r7, #4]
    if (q->len % 2 != 0) {
 800881c:	697b      	ldr	r3, [r7, #20]
 800881e:	895b      	ldrh	r3, [r3, #10]
 8008820:	2201      	movs	r2, #1
 8008822:	4013      	ands	r3, r2
 8008824:	b29b      	uxth	r3, r3
 8008826:	2b00      	cmp	r3, #0
 8008828:	d00e      	beq.n	8008848 <inet_cksum_pseudo_base+0x7c>
      swapped = !swapped;
 800882a:	693b      	ldr	r3, [r7, #16]
 800882c:	425a      	negs	r2, r3
 800882e:	4153      	adcs	r3, r2
 8008830:	b2db      	uxtb	r3, r3
 8008832:	613b      	str	r3, [r7, #16]
      acc = SWAP_BYTES_IN_WORD(acc);
 8008834:	687b      	ldr	r3, [r7, #4]
 8008836:	021b      	lsls	r3, r3, #8
 8008838:	041b      	lsls	r3, r3, #16
 800883a:	0c1a      	lsrs	r2, r3, #16
 800883c:	687b      	ldr	r3, [r7, #4]
 800883e:	0a1b      	lsrs	r3, r3, #8
 8008840:	21ff      	movs	r1, #255	; 0xff
 8008842:	400b      	ands	r3, r1
 8008844:	4313      	orrs	r3, r2
 8008846:	607b      	str	r3, [r7, #4]
  for (q = p; q != NULL; q = q->next) {
 8008848:	697b      	ldr	r3, [r7, #20]
 800884a:	681b      	ldr	r3, [r3, #0]
 800884c:	617b      	str	r3, [r7, #20]
 800884e:	697b      	ldr	r3, [r7, #20]
 8008850:	2b00      	cmp	r3, #0
 8008852:	d1cf      	bne.n	80087f4 <inet_cksum_pseudo_base+0x28>
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
 8008854:	693b      	ldr	r3, [r7, #16]
 8008856:	2b00      	cmp	r3, #0
 8008858:	d009      	beq.n	800886e <inet_cksum_pseudo_base+0xa2>
    acc = SWAP_BYTES_IN_WORD(acc);
 800885a:	687b      	ldr	r3, [r7, #4]
 800885c:	021b      	lsls	r3, r3, #8
 800885e:	041b      	lsls	r3, r3, #16
 8008860:	0c1a      	lsrs	r2, r3, #16
 8008862:	687b      	ldr	r3, [r7, #4]
 8008864:	0a1b      	lsrs	r3, r3, #8
 8008866:	21ff      	movs	r1, #255	; 0xff
 8008868:	400b      	ands	r3, r1
 800886a:	4313      	orrs	r3, r2
 800886c:	607b      	str	r3, [r7, #4]
  }

  acc += (u32_t)lwip_htons((u16_t)proto);
 800886e:	230b      	movs	r3, #11
 8008870:	18fb      	adds	r3, r7, r3
 8008872:	781b      	ldrb	r3, [r3, #0]
 8008874:	b29b      	uxth	r3, r3
 8008876:	0018      	movs	r0, r3
 8008878:	f7fe fdc2 	bl	8007400 <lwip_htons>
 800887c:	0003      	movs	r3, r0
 800887e:	001a      	movs	r2, r3
 8008880:	687b      	ldr	r3, [r7, #4]
 8008882:	189b      	adds	r3, r3, r2
 8008884:	607b      	str	r3, [r7, #4]
  acc += (u32_t)lwip_htons(proto_len);
 8008886:	2308      	movs	r3, #8
 8008888:	18fb      	adds	r3, r7, r3
 800888a:	881b      	ldrh	r3, [r3, #0]
 800888c:	0018      	movs	r0, r3
 800888e:	f7fe fdb7 	bl	8007400 <lwip_htons>
 8008892:	0003      	movs	r3, r0
 8008894:	001a      	movs	r2, r3
 8008896:	687b      	ldr	r3, [r7, #4]
 8008898:	189b      	adds	r3, r3, r2
 800889a:	607b      	str	r3, [r7, #4]

  /* Fold 32-bit sum to 16 bits
     calling this twice is probably faster than if statements... */
  acc = FOLD_U32T(acc);
 800889c:	687b      	ldr	r3, [r7, #4]
 800889e:	0c1a      	lsrs	r2, r3, #16
 80088a0:	687b      	ldr	r3, [r7, #4]
 80088a2:	041b      	lsls	r3, r3, #16
 80088a4:	0c1b      	lsrs	r3, r3, #16
 80088a6:	18d3      	adds	r3, r2, r3
 80088a8:	607b      	str	r3, [r7, #4]
  acc = FOLD_U32T(acc);
 80088aa:	687b      	ldr	r3, [r7, #4]
 80088ac:	0c1a      	lsrs	r2, r3, #16
 80088ae:	687b      	ldr	r3, [r7, #4]
 80088b0:	041b      	lsls	r3, r3, #16
 80088b2:	0c1b      	lsrs	r3, r3, #16
 80088b4:	18d3      	adds	r3, r2, r3
 80088b6:	607b      	str	r3, [r7, #4]
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
 80088b8:	687b      	ldr	r3, [r7, #4]
 80088ba:	b29b      	uxth	r3, r3
 80088bc:	43db      	mvns	r3, r3
 80088be:	b29b      	uxth	r3, r3
}
 80088c0:	0018      	movs	r0, r3
 80088c2:	46bd      	mov	sp, r7
 80088c4:	b006      	add	sp, #24
 80088c6:	bd80      	pop	{r7, pc}

080088c8 <inet_chksum_pseudo>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pseudo(struct pbuf *p, u8_t proto, u16_t proto_len,
                   const ip4_addr_t *src, const ip4_addr_t *dest)
{
 80088c8:	b5b0      	push	{r4, r5, r7, lr}
 80088ca:	b086      	sub	sp, #24
 80088cc:	af00      	add	r7, sp, #0
 80088ce:	60f8      	str	r0, [r7, #12]
 80088d0:	0008      	movs	r0, r1
 80088d2:	0011      	movs	r1, r2
 80088d4:	607b      	str	r3, [r7, #4]
 80088d6:	250b      	movs	r5, #11
 80088d8:	197b      	adds	r3, r7, r5
 80088da:	1c02      	adds	r2, r0, #0
 80088dc:	701a      	strb	r2, [r3, #0]
 80088de:	2008      	movs	r0, #8
 80088e0:	183b      	adds	r3, r7, r0
 80088e2:	1c0a      	adds	r2, r1, #0
 80088e4:	801a      	strh	r2, [r3, #0]
  u32_t acc;
  u32_t addr;

  addr = ip4_addr_get_u32(src);
 80088e6:	687b      	ldr	r3, [r7, #4]
 80088e8:	681b      	ldr	r3, [r3, #0]
 80088ea:	617b      	str	r3, [r7, #20]
  acc = (addr & 0xffffUL);
 80088ec:	697b      	ldr	r3, [r7, #20]
 80088ee:	041b      	lsls	r3, r3, #16
 80088f0:	0c1b      	lsrs	r3, r3, #16
 80088f2:	613b      	str	r3, [r7, #16]
  acc = (u32_t)(acc + ((addr >> 16) & 0xffffUL));
 80088f4:	697b      	ldr	r3, [r7, #20]
 80088f6:	0c1b      	lsrs	r3, r3, #16
 80088f8:	693a      	ldr	r2, [r7, #16]
 80088fa:	18d3      	adds	r3, r2, r3
 80088fc:	613b      	str	r3, [r7, #16]
  addr = ip4_addr_get_u32(dest);
 80088fe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008900:	681b      	ldr	r3, [r3, #0]
 8008902:	617b      	str	r3, [r7, #20]
  acc = (u32_t)(acc + (addr & 0xffffUL));
 8008904:	697b      	ldr	r3, [r7, #20]
 8008906:	041b      	lsls	r3, r3, #16
 8008908:	0c1b      	lsrs	r3, r3, #16
 800890a:	693a      	ldr	r2, [r7, #16]
 800890c:	18d3      	adds	r3, r2, r3
 800890e:	613b      	str	r3, [r7, #16]
  acc = (u32_t)(acc + ((addr >> 16) & 0xffffUL));
 8008910:	697b      	ldr	r3, [r7, #20]
 8008912:	0c1b      	lsrs	r3, r3, #16
 8008914:	693a      	ldr	r2, [r7, #16]
 8008916:	18d3      	adds	r3, r2, r3
 8008918:	613b      	str	r3, [r7, #16]
  /* fold down to 16 bits */
  acc = FOLD_U32T(acc);
 800891a:	693b      	ldr	r3, [r7, #16]
 800891c:	0c1a      	lsrs	r2, r3, #16
 800891e:	693b      	ldr	r3, [r7, #16]
 8008920:	041b      	lsls	r3, r3, #16
 8008922:	0c1b      	lsrs	r3, r3, #16
 8008924:	18d3      	adds	r3, r2, r3
 8008926:	613b      	str	r3, [r7, #16]
  acc = FOLD_U32T(acc);
 8008928:	693b      	ldr	r3, [r7, #16]
 800892a:	0c1a      	lsrs	r2, r3, #16
 800892c:	693b      	ldr	r3, [r7, #16]
 800892e:	041b      	lsls	r3, r3, #16
 8008930:	0c1b      	lsrs	r3, r3, #16
 8008932:	18d3      	adds	r3, r2, r3
 8008934:	613b      	str	r3, [r7, #16]

  return inet_cksum_pseudo_base(p, proto, proto_len, acc);
 8008936:	693c      	ldr	r4, [r7, #16]
 8008938:	183b      	adds	r3, r7, r0
 800893a:	881a      	ldrh	r2, [r3, #0]
 800893c:	197b      	adds	r3, r7, r5
 800893e:	7819      	ldrb	r1, [r3, #0]
 8008940:	68f8      	ldr	r0, [r7, #12]
 8008942:	0023      	movs	r3, r4
 8008944:	f7ff ff42 	bl	80087cc <inet_cksum_pseudo_base>
 8008948:	0003      	movs	r3, r0
}
 800894a:	0018      	movs	r0, r3
 800894c:	46bd      	mov	sp, r7
 800894e:	b006      	add	sp, #24
 8008950:	bdb0      	pop	{r4, r5, r7, pc}

08008952 <ip_chksum_pseudo>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
ip_chksum_pseudo(struct pbuf *p, u8_t proto, u16_t proto_len,
                 const ip_addr_t *src, const ip_addr_t *dest)
{
 8008952:	b5b0      	push	{r4, r5, r7, lr}
 8008954:	b086      	sub	sp, #24
 8008956:	af02      	add	r7, sp, #8
 8008958:	60f8      	str	r0, [r7, #12]
 800895a:	0008      	movs	r0, r1
 800895c:	0011      	movs	r1, r2
 800895e:	607b      	str	r3, [r7, #4]
 8008960:	250b      	movs	r5, #11
 8008962:	197b      	adds	r3, r7, r5
 8008964:	1c02      	adds	r2, r0, #0
 8008966:	701a      	strb	r2, [r3, #0]
 8008968:	2008      	movs	r0, #8
 800896a:	183b      	adds	r3, r7, r0
 800896c:	1c0a      	adds	r2, r1, #0
 800896e:	801a      	strh	r2, [r3, #0]
#if LWIP_IPV4 && LWIP_IPV6
  else
#endif /* LWIP_IPV4 && LWIP_IPV6 */
#if LWIP_IPV4
  {
    return inet_chksum_pseudo(p, proto, proto_len, ip_2_ip4(src), ip_2_ip4(dest));
 8008970:	687c      	ldr	r4, [r7, #4]
 8008972:	183b      	adds	r3, r7, r0
 8008974:	881a      	ldrh	r2, [r3, #0]
 8008976:	197b      	adds	r3, r7, r5
 8008978:	7819      	ldrb	r1, [r3, #0]
 800897a:	68f8      	ldr	r0, [r7, #12]
 800897c:	6a3b      	ldr	r3, [r7, #32]
 800897e:	9300      	str	r3, [sp, #0]
 8008980:	0023      	movs	r3, r4
 8008982:	f7ff ffa1 	bl	80088c8 <inet_chksum_pseudo>
 8008986:	0003      	movs	r3, r0
  }
#endif /* LWIP_IPV4 */
}
 8008988:	0018      	movs	r0, r3
 800898a:	46bd      	mov	sp, r7
 800898c:	b004      	add	sp, #16
 800898e:	bdb0      	pop	{r4, r5, r7, pc}

08008990 <inet_cksum_pseudo_partial_base>:

/** Parts of the pseudo checksum which are common to IPv4 and IPv6 */
static u16_t
inet_cksum_pseudo_partial_base(struct pbuf *p, u8_t proto, u16_t proto_len,
                               u16_t chksum_len, u32_t acc)
{
 8008990:	b590      	push	{r4, r7, lr}
 8008992:	b089      	sub	sp, #36	; 0x24
 8008994:	af00      	add	r7, sp, #0
 8008996:	60f8      	str	r0, [r7, #12]
 8008998:	000c      	movs	r4, r1
 800899a:	0010      	movs	r0, r2
 800899c:	0019      	movs	r1, r3
 800899e:	230b      	movs	r3, #11
 80089a0:	18fb      	adds	r3, r7, r3
 80089a2:	1c22      	adds	r2, r4, #0
 80089a4:	701a      	strb	r2, [r3, #0]
 80089a6:	2308      	movs	r3, #8
 80089a8:	18fb      	adds	r3, r7, r3
 80089aa:	1c02      	adds	r2, r0, #0
 80089ac:	801a      	strh	r2, [r3, #0]
 80089ae:	1dbb      	adds	r3, r7, #6
 80089b0:	1c0a      	adds	r2, r1, #0
 80089b2:	801a      	strh	r2, [r3, #0]
  struct pbuf *q;
  int swapped = 0;
 80089b4:	2300      	movs	r3, #0
 80089b6:	61bb      	str	r3, [r7, #24]
  u16_t chklen;

  /* iterate through all pbuf in chain */
  for (q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
 80089b8:	68fb      	ldr	r3, [r7, #12]
 80089ba:	61fb      	str	r3, [r7, #28]
 80089bc:	e04f      	b.n	8008a5e <inet_cksum_pseudo_partial_base+0xce>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
                             (void *)q, (void *)q->next));
    chklen = q->len;
 80089be:	2116      	movs	r1, #22
 80089c0:	187b      	adds	r3, r7, r1
 80089c2:	69fa      	ldr	r2, [r7, #28]
 80089c4:	8952      	ldrh	r2, [r2, #10]
 80089c6:	801a      	strh	r2, [r3, #0]
    if (chklen > chksum_len) {
 80089c8:	187a      	adds	r2, r7, r1
 80089ca:	1dbb      	adds	r3, r7, #6
 80089cc:	8812      	ldrh	r2, [r2, #0]
 80089ce:	881b      	ldrh	r3, [r3, #0]
 80089d0:	429a      	cmp	r2, r3
 80089d2:	d903      	bls.n	80089dc <inet_cksum_pseudo_partial_base+0x4c>
      chklen = chksum_len;
 80089d4:	187b      	adds	r3, r7, r1
 80089d6:	1dba      	adds	r2, r7, #6
 80089d8:	8812      	ldrh	r2, [r2, #0]
 80089da:	801a      	strh	r2, [r3, #0]
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
 80089dc:	69fb      	ldr	r3, [r7, #28]
 80089de:	685a      	ldr	r2, [r3, #4]
 80089e0:	2416      	movs	r4, #22
 80089e2:	193b      	adds	r3, r7, r4
 80089e4:	881b      	ldrh	r3, [r3, #0]
 80089e6:	0019      	movs	r1, r3
 80089e8:	0010      	movs	r0, r2
 80089ea:	f7ff fe8d 	bl	8008708 <lwip_standard_chksum>
 80089ee:	0003      	movs	r3, r0
 80089f0:	001a      	movs	r2, r3
 80089f2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80089f4:	189b      	adds	r3, r3, r2
 80089f6:	633b      	str	r3, [r7, #48]	; 0x30
    chksum_len = (u16_t)(chksum_len - chklen);
 80089f8:	1dbb      	adds	r3, r7, #6
 80089fa:	1db9      	adds	r1, r7, #6
 80089fc:	193a      	adds	r2, r7, r4
 80089fe:	8809      	ldrh	r1, [r1, #0]
 8008a00:	8812      	ldrh	r2, [r2, #0]
 8008a02:	1a8a      	subs	r2, r1, r2
 8008a04:	801a      	strh	r2, [r3, #0]
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
 8008a06:	1dbb      	adds	r3, r7, #6
 8008a08:	881b      	ldrh	r3, [r3, #0]
 8008a0a:	4a35      	ldr	r2, [pc, #212]	; (8008ae0 <inet_cksum_pseudo_partial_base+0x150>)
 8008a0c:	4293      	cmp	r3, r2
 8008a0e:	d906      	bls.n	8008a1e <inet_cksum_pseudo_partial_base+0x8e>
 8008a10:	4b34      	ldr	r3, [pc, #208]	; (8008ae4 <inet_cksum_pseudo_partial_base+0x154>)
 8008a12:	22d0      	movs	r2, #208	; 0xd0
 8008a14:	0052      	lsls	r2, r2, #1
 8008a16:	4934      	ldr	r1, [pc, #208]	; (8008ae8 <inet_cksum_pseudo_partial_base+0x158>)
 8008a18:	4834      	ldr	r0, [pc, #208]	; (8008aec <inet_cksum_pseudo_partial_base+0x15c>)
 8008a1a:	f7f9 fbe3 	bl	80021e4 <app_debug_rtt_raw>
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
 8008a1e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008a20:	0c1a      	lsrs	r2, r3, #16
 8008a22:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008a24:	041b      	lsls	r3, r3, #16
 8008a26:	0c1b      	lsrs	r3, r3, #16
 8008a28:	18d3      	adds	r3, r2, r3
 8008a2a:	633b      	str	r3, [r7, #48]	; 0x30
    if (q->len % 2 != 0) {
 8008a2c:	69fb      	ldr	r3, [r7, #28]
 8008a2e:	895b      	ldrh	r3, [r3, #10]
 8008a30:	2201      	movs	r2, #1
 8008a32:	4013      	ands	r3, r2
 8008a34:	b29b      	uxth	r3, r3
 8008a36:	2b00      	cmp	r3, #0
 8008a38:	d00e      	beq.n	8008a58 <inet_cksum_pseudo_partial_base+0xc8>
      swapped = !swapped;
 8008a3a:	69bb      	ldr	r3, [r7, #24]
 8008a3c:	425a      	negs	r2, r3
 8008a3e:	4153      	adcs	r3, r2
 8008a40:	b2db      	uxtb	r3, r3
 8008a42:	61bb      	str	r3, [r7, #24]
      acc = SWAP_BYTES_IN_WORD(acc);
 8008a44:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008a46:	021b      	lsls	r3, r3, #8
 8008a48:	041b      	lsls	r3, r3, #16
 8008a4a:	0c1a      	lsrs	r2, r3, #16
 8008a4c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008a4e:	0a1b      	lsrs	r3, r3, #8
 8008a50:	21ff      	movs	r1, #255	; 0xff
 8008a52:	400b      	ands	r3, r1
 8008a54:	4313      	orrs	r3, r2
 8008a56:	633b      	str	r3, [r7, #48]	; 0x30
  for (q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
 8008a58:	69fb      	ldr	r3, [r7, #28]
 8008a5a:	681b      	ldr	r3, [r3, #0]
 8008a5c:	61fb      	str	r3, [r7, #28]
 8008a5e:	69fb      	ldr	r3, [r7, #28]
 8008a60:	2b00      	cmp	r3, #0
 8008a62:	d003      	beq.n	8008a6c <inet_cksum_pseudo_partial_base+0xdc>
 8008a64:	1dbb      	adds	r3, r7, #6
 8008a66:	881b      	ldrh	r3, [r3, #0]
 8008a68:	2b00      	cmp	r3, #0
 8008a6a:	d1a8      	bne.n	80089be <inet_cksum_pseudo_partial_base+0x2e>
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
 8008a6c:	69bb      	ldr	r3, [r7, #24]
 8008a6e:	2b00      	cmp	r3, #0
 8008a70:	d009      	beq.n	8008a86 <inet_cksum_pseudo_partial_base+0xf6>
    acc = SWAP_BYTES_IN_WORD(acc);
 8008a72:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008a74:	021b      	lsls	r3, r3, #8
 8008a76:	041b      	lsls	r3, r3, #16
 8008a78:	0c1a      	lsrs	r2, r3, #16
 8008a7a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008a7c:	0a1b      	lsrs	r3, r3, #8
 8008a7e:	21ff      	movs	r1, #255	; 0xff
 8008a80:	400b      	ands	r3, r1
 8008a82:	4313      	orrs	r3, r2
 8008a84:	633b      	str	r3, [r7, #48]	; 0x30
  }

  acc += (u32_t)lwip_htons((u16_t)proto);
 8008a86:	230b      	movs	r3, #11
 8008a88:	18fb      	adds	r3, r7, r3
 8008a8a:	781b      	ldrb	r3, [r3, #0]
 8008a8c:	b29b      	uxth	r3, r3
 8008a8e:	0018      	movs	r0, r3
 8008a90:	f7fe fcb6 	bl	8007400 <lwip_htons>
 8008a94:	0003      	movs	r3, r0
 8008a96:	001a      	movs	r2, r3
 8008a98:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008a9a:	189b      	adds	r3, r3, r2
 8008a9c:	633b      	str	r3, [r7, #48]	; 0x30
  acc += (u32_t)lwip_htons(proto_len);
 8008a9e:	2308      	movs	r3, #8
 8008aa0:	18fb      	adds	r3, r7, r3
 8008aa2:	881b      	ldrh	r3, [r3, #0]
 8008aa4:	0018      	movs	r0, r3
 8008aa6:	f7fe fcab 	bl	8007400 <lwip_htons>
 8008aaa:	0003      	movs	r3, r0
 8008aac:	001a      	movs	r2, r3
 8008aae:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008ab0:	189b      	adds	r3, r3, r2
 8008ab2:	633b      	str	r3, [r7, #48]	; 0x30

  /* Fold 32-bit sum to 16 bits
     calling this twice is probably faster than if statements... */
  acc = FOLD_U32T(acc);
 8008ab4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008ab6:	0c1a      	lsrs	r2, r3, #16
 8008ab8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008aba:	041b      	lsls	r3, r3, #16
 8008abc:	0c1b      	lsrs	r3, r3, #16
 8008abe:	18d3      	adds	r3, r2, r3
 8008ac0:	633b      	str	r3, [r7, #48]	; 0x30
  acc = FOLD_U32T(acc);
 8008ac2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008ac4:	0c1a      	lsrs	r2, r3, #16
 8008ac6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008ac8:	041b      	lsls	r3, r3, #16
 8008aca:	0c1b      	lsrs	r3, r3, #16
 8008acc:	18d3      	adds	r3, r2, r3
 8008ace:	633b      	str	r3, [r7, #48]	; 0x30
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
 8008ad0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008ad2:	b29b      	uxth	r3, r3
 8008ad4:	43db      	mvns	r3, r3
 8008ad6:	b29b      	uxth	r3, r3
}
 8008ad8:	0018      	movs	r0, r3
 8008ada:	46bd      	mov	sp, r7
 8008adc:	b009      	add	sp, #36	; 0x24
 8008ade:	bd90      	pop	{r4, r7, pc}
 8008ae0:	00007ffe 	.word	0x00007ffe
 8008ae4:	0801fef4 	.word	0x0801fef4
 8008ae8:	0801ff24 	.word	0x0801ff24
 8008aec:	0801ff30 	.word	0x0801ff30

08008af0 <inet_chksum_pseudo_partial>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p, u8_t proto, u16_t proto_len,
                           u16_t chksum_len, const ip4_addr_t *src, const ip4_addr_t *dest)
{
 8008af0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008af2:	b089      	sub	sp, #36	; 0x24
 8008af4:	af02      	add	r7, sp, #8
 8008af6:	60f8      	str	r0, [r7, #12]
 8008af8:	000c      	movs	r4, r1
 8008afa:	0010      	movs	r0, r2
 8008afc:	0019      	movs	r1, r3
 8008afe:	250b      	movs	r5, #11
 8008b00:	197b      	adds	r3, r7, r5
 8008b02:	1c22      	adds	r2, r4, #0
 8008b04:	701a      	strb	r2, [r3, #0]
 8008b06:	2608      	movs	r6, #8
 8008b08:	19bb      	adds	r3, r7, r6
 8008b0a:	1c02      	adds	r2, r0, #0
 8008b0c:	801a      	strh	r2, [r3, #0]
 8008b0e:	1dbb      	adds	r3, r7, #6
 8008b10:	1c0a      	adds	r2, r1, #0
 8008b12:	801a      	strh	r2, [r3, #0]
  u32_t acc;
  u32_t addr;

  addr = ip4_addr_get_u32(src);
 8008b14:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008b16:	681b      	ldr	r3, [r3, #0]
 8008b18:	617b      	str	r3, [r7, #20]
  acc = (addr & 0xffffUL);
 8008b1a:	697b      	ldr	r3, [r7, #20]
 8008b1c:	041b      	lsls	r3, r3, #16
 8008b1e:	0c1b      	lsrs	r3, r3, #16
 8008b20:	613b      	str	r3, [r7, #16]
  acc = (u32_t)(acc + ((addr >> 16) & 0xffffUL));
 8008b22:	697b      	ldr	r3, [r7, #20]
 8008b24:	0c1b      	lsrs	r3, r3, #16
 8008b26:	693a      	ldr	r2, [r7, #16]
 8008b28:	18d3      	adds	r3, r2, r3
 8008b2a:	613b      	str	r3, [r7, #16]
  addr = ip4_addr_get_u32(dest);
 8008b2c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008b2e:	681b      	ldr	r3, [r3, #0]
 8008b30:	617b      	str	r3, [r7, #20]
  acc = (u32_t)(acc + (addr & 0xffffUL));
 8008b32:	697b      	ldr	r3, [r7, #20]
 8008b34:	041b      	lsls	r3, r3, #16
 8008b36:	0c1b      	lsrs	r3, r3, #16
 8008b38:	693a      	ldr	r2, [r7, #16]
 8008b3a:	18d3      	adds	r3, r2, r3
 8008b3c:	613b      	str	r3, [r7, #16]
  acc = (u32_t)(acc + ((addr >> 16) & 0xffffUL));
 8008b3e:	697b      	ldr	r3, [r7, #20]
 8008b40:	0c1b      	lsrs	r3, r3, #16
 8008b42:	693a      	ldr	r2, [r7, #16]
 8008b44:	18d3      	adds	r3, r2, r3
 8008b46:	613b      	str	r3, [r7, #16]
  /* fold down to 16 bits */
  acc = FOLD_U32T(acc);
 8008b48:	693b      	ldr	r3, [r7, #16]
 8008b4a:	0c1a      	lsrs	r2, r3, #16
 8008b4c:	693b      	ldr	r3, [r7, #16]
 8008b4e:	041b      	lsls	r3, r3, #16
 8008b50:	0c1b      	lsrs	r3, r3, #16
 8008b52:	18d3      	adds	r3, r2, r3
 8008b54:	613b      	str	r3, [r7, #16]
  acc = FOLD_U32T(acc);
 8008b56:	693b      	ldr	r3, [r7, #16]
 8008b58:	0c1a      	lsrs	r2, r3, #16
 8008b5a:	693b      	ldr	r3, [r7, #16]
 8008b5c:	041b      	lsls	r3, r3, #16
 8008b5e:	0c1b      	lsrs	r3, r3, #16
 8008b60:	18d3      	adds	r3, r2, r3
 8008b62:	613b      	str	r3, [r7, #16]

  return inet_cksum_pseudo_partial_base(p, proto, proto_len, chksum_len, acc);
 8008b64:	1dbb      	adds	r3, r7, #6
 8008b66:	881c      	ldrh	r4, [r3, #0]
 8008b68:	19bb      	adds	r3, r7, r6
 8008b6a:	881a      	ldrh	r2, [r3, #0]
 8008b6c:	197b      	adds	r3, r7, r5
 8008b6e:	7819      	ldrb	r1, [r3, #0]
 8008b70:	68f8      	ldr	r0, [r7, #12]
 8008b72:	693b      	ldr	r3, [r7, #16]
 8008b74:	9300      	str	r3, [sp, #0]
 8008b76:	0023      	movs	r3, r4
 8008b78:	f7ff ff0a 	bl	8008990 <inet_cksum_pseudo_partial_base>
 8008b7c:	0003      	movs	r3, r0
}
 8008b7e:	0018      	movs	r0, r3
 8008b80:	46bd      	mov	sp, r7
 8008b82:	b007      	add	sp, #28
 8008b84:	bdf0      	pop	{r4, r5, r6, r7, pc}

08008b86 <ip_chksum_pseudo_partial>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
ip_chksum_pseudo_partial(struct pbuf *p, u8_t proto, u16_t proto_len,
                         u16_t chksum_len, const ip_addr_t *src, const ip_addr_t *dest)
{
 8008b86:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008b88:	b087      	sub	sp, #28
 8008b8a:	af02      	add	r7, sp, #8
 8008b8c:	60f8      	str	r0, [r7, #12]
 8008b8e:	000c      	movs	r4, r1
 8008b90:	0010      	movs	r0, r2
 8008b92:	0019      	movs	r1, r3
 8008b94:	250b      	movs	r5, #11
 8008b96:	197b      	adds	r3, r7, r5
 8008b98:	1c22      	adds	r2, r4, #0
 8008b9a:	701a      	strb	r2, [r3, #0]
 8008b9c:	2608      	movs	r6, #8
 8008b9e:	19bb      	adds	r3, r7, r6
 8008ba0:	1c02      	adds	r2, r0, #0
 8008ba2:	801a      	strh	r2, [r3, #0]
 8008ba4:	1dbb      	adds	r3, r7, #6
 8008ba6:	1c0a      	adds	r2, r1, #0
 8008ba8:	801a      	strh	r2, [r3, #0]
#if LWIP_IPV4 && LWIP_IPV6
  else
#endif /* LWIP_IPV4 && LWIP_IPV6 */
#if LWIP_IPV4
  {
    return inet_chksum_pseudo_partial(p, proto, proto_len, chksum_len, ip_2_ip4(src), ip_2_ip4(dest));
 8008baa:	1dbb      	adds	r3, r7, #6
 8008bac:	881c      	ldrh	r4, [r3, #0]
 8008bae:	19bb      	adds	r3, r7, r6
 8008bb0:	881a      	ldrh	r2, [r3, #0]
 8008bb2:	197b      	adds	r3, r7, r5
 8008bb4:	7819      	ldrb	r1, [r3, #0]
 8008bb6:	68f8      	ldr	r0, [r7, #12]
 8008bb8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8008bba:	9301      	str	r3, [sp, #4]
 8008bbc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008bbe:	9300      	str	r3, [sp, #0]
 8008bc0:	0023      	movs	r3, r4
 8008bc2:	f7ff ff95 	bl	8008af0 <inet_chksum_pseudo_partial>
 8008bc6:	0003      	movs	r3, r0
  }
#endif /* LWIP_IPV4 */
}
 8008bc8:	0018      	movs	r0, r3
 8008bca:	46bd      	mov	sp, r7
 8008bcc:	b005      	add	sp, #20
 8008bce:	bdf0      	pop	{r4, r5, r6, r7, pc}

08008bd0 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(const void *dataptr, u16_t len)
{
 8008bd0:	b580      	push	{r7, lr}
 8008bd2:	b082      	sub	sp, #8
 8008bd4:	af00      	add	r7, sp, #0
 8008bd6:	6078      	str	r0, [r7, #4]
 8008bd8:	000a      	movs	r2, r1
 8008bda:	1cbb      	adds	r3, r7, #2
 8008bdc:	801a      	strh	r2, [r3, #0]
  return (u16_t)~(unsigned int)LWIP_CHKSUM(dataptr, len);
 8008bde:	1cbb      	adds	r3, r7, #2
 8008be0:	881a      	ldrh	r2, [r3, #0]
 8008be2:	687b      	ldr	r3, [r7, #4]
 8008be4:	0011      	movs	r1, r2
 8008be6:	0018      	movs	r0, r3
 8008be8:	f7ff fd8e 	bl	8008708 <lwip_standard_chksum>
 8008bec:	0003      	movs	r3, r0
 8008bee:	43db      	mvns	r3, r3
 8008bf0:	b29b      	uxth	r3, r3
}
 8008bf2:	0018      	movs	r0, r3
 8008bf4:	46bd      	mov	sp, r7
 8008bf6:	b002      	add	sp, #8
 8008bf8:	bd80      	pop	{r7, pc}

08008bfa <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
 8008bfa:	b580      	push	{r7, lr}
 8008bfc:	b086      	sub	sp, #24
 8008bfe:	af00      	add	r7, sp, #0
 8008c00:	6078      	str	r0, [r7, #4]
  u32_t acc;
  struct pbuf *q;
  int swapped = 0;
 8008c02:	2300      	movs	r3, #0
 8008c04:	60fb      	str	r3, [r7, #12]

  acc = 0;
 8008c06:	2300      	movs	r3, #0
 8008c08:	617b      	str	r3, [r7, #20]
  for (q = p; q != NULL; q = q->next) {
 8008c0a:	687b      	ldr	r3, [r7, #4]
 8008c0c:	613b      	str	r3, [r7, #16]
 8008c0e:	e02c      	b.n	8008c6a <inet_chksum_pbuf+0x70>
    acc += LWIP_CHKSUM(q->payload, q->len);
 8008c10:	693b      	ldr	r3, [r7, #16]
 8008c12:	685a      	ldr	r2, [r3, #4]
 8008c14:	693b      	ldr	r3, [r7, #16]
 8008c16:	895b      	ldrh	r3, [r3, #10]
 8008c18:	0019      	movs	r1, r3
 8008c1a:	0010      	movs	r0, r2
 8008c1c:	f7ff fd74 	bl	8008708 <lwip_standard_chksum>
 8008c20:	0003      	movs	r3, r0
 8008c22:	001a      	movs	r2, r3
 8008c24:	697b      	ldr	r3, [r7, #20]
 8008c26:	189b      	adds	r3, r3, r2
 8008c28:	617b      	str	r3, [r7, #20]
    acc = FOLD_U32T(acc);
 8008c2a:	697b      	ldr	r3, [r7, #20]
 8008c2c:	0c1a      	lsrs	r2, r3, #16
 8008c2e:	697b      	ldr	r3, [r7, #20]
 8008c30:	041b      	lsls	r3, r3, #16
 8008c32:	0c1b      	lsrs	r3, r3, #16
 8008c34:	18d3      	adds	r3, r2, r3
 8008c36:	617b      	str	r3, [r7, #20]
    if (q->len % 2 != 0) {
 8008c38:	693b      	ldr	r3, [r7, #16]
 8008c3a:	895b      	ldrh	r3, [r3, #10]
 8008c3c:	2201      	movs	r2, #1
 8008c3e:	4013      	ands	r3, r2
 8008c40:	b29b      	uxth	r3, r3
 8008c42:	2b00      	cmp	r3, #0
 8008c44:	d00e      	beq.n	8008c64 <inet_chksum_pbuf+0x6a>
      swapped = !swapped;
 8008c46:	68fb      	ldr	r3, [r7, #12]
 8008c48:	425a      	negs	r2, r3
 8008c4a:	4153      	adcs	r3, r2
 8008c4c:	b2db      	uxtb	r3, r3
 8008c4e:	60fb      	str	r3, [r7, #12]
      acc = SWAP_BYTES_IN_WORD(acc);
 8008c50:	697b      	ldr	r3, [r7, #20]
 8008c52:	021b      	lsls	r3, r3, #8
 8008c54:	041b      	lsls	r3, r3, #16
 8008c56:	0c1a      	lsrs	r2, r3, #16
 8008c58:	697b      	ldr	r3, [r7, #20]
 8008c5a:	0a1b      	lsrs	r3, r3, #8
 8008c5c:	21ff      	movs	r1, #255	; 0xff
 8008c5e:	400b      	ands	r3, r1
 8008c60:	4313      	orrs	r3, r2
 8008c62:	617b      	str	r3, [r7, #20]
  for (q = p; q != NULL; q = q->next) {
 8008c64:	693b      	ldr	r3, [r7, #16]
 8008c66:	681b      	ldr	r3, [r3, #0]
 8008c68:	613b      	str	r3, [r7, #16]
 8008c6a:	693b      	ldr	r3, [r7, #16]
 8008c6c:	2b00      	cmp	r3, #0
 8008c6e:	d1cf      	bne.n	8008c10 <inet_chksum_pbuf+0x16>
    }
  }

  if (swapped) {
 8008c70:	68fb      	ldr	r3, [r7, #12]
 8008c72:	2b00      	cmp	r3, #0
 8008c74:	d009      	beq.n	8008c8a <inet_chksum_pbuf+0x90>
    acc = SWAP_BYTES_IN_WORD(acc);
 8008c76:	697b      	ldr	r3, [r7, #20]
 8008c78:	021b      	lsls	r3, r3, #8
 8008c7a:	041b      	lsls	r3, r3, #16
 8008c7c:	0c1a      	lsrs	r2, r3, #16
 8008c7e:	697b      	ldr	r3, [r7, #20]
 8008c80:	0a1b      	lsrs	r3, r3, #8
 8008c82:	21ff      	movs	r1, #255	; 0xff
 8008c84:	400b      	ands	r3, r1
 8008c86:	4313      	orrs	r3, r2
 8008c88:	617b      	str	r3, [r7, #20]
  }
  return (u16_t)~(acc & 0xffffUL);
 8008c8a:	697b      	ldr	r3, [r7, #20]
 8008c8c:	b29b      	uxth	r3, r3
 8008c8e:	43db      	mvns	r3, r3
 8008c90:	b29b      	uxth	r3, r3
}
 8008c92:	0018      	movs	r0, r3
 8008c94:	46bd      	mov	sp, r7
 8008c96:	b006      	add	sp, #24
 8008c98:	bd80      	pop	{r7, pc}

08008c9a <lwip_chksum_copy>:
 * For architectures with big caches, data might still be in cache when
 * generating the checksum after copying.
 */
u16_t
lwip_chksum_copy(void *dst, const void *src, u16_t len)
{
 8008c9a:	b580      	push	{r7, lr}
 8008c9c:	b084      	sub	sp, #16
 8008c9e:	af00      	add	r7, sp, #0
 8008ca0:	60f8      	str	r0, [r7, #12]
 8008ca2:	60b9      	str	r1, [r7, #8]
 8008ca4:	1dbb      	adds	r3, r7, #6
 8008ca6:	801a      	strh	r2, [r3, #0]
  MEMCPY(dst, src, len);
 8008ca8:	1dbb      	adds	r3, r7, #6
 8008caa:	881a      	ldrh	r2, [r3, #0]
 8008cac:	68b9      	ldr	r1, [r7, #8]
 8008cae:	68fb      	ldr	r3, [r7, #12]
 8008cb0:	0018      	movs	r0, r3
 8008cb2:	f015 f973 	bl	801df9c <memcpy>
  return LWIP_CHKSUM(dst, len);
 8008cb6:	1dbb      	adds	r3, r7, #6
 8008cb8:	881a      	ldrh	r2, [r3, #0]
 8008cba:	68fb      	ldr	r3, [r7, #12]
 8008cbc:	0011      	movs	r1, r2
 8008cbe:	0018      	movs	r0, r3
 8008cc0:	f7ff fd22 	bl	8008708 <lwip_standard_chksum>
 8008cc4:	0003      	movs	r3, r0
}
 8008cc6:	0018      	movs	r0, r3
 8008cc8:	46bd      	mov	sp, r7
 8008cca:	b004      	add	sp, #16
 8008ccc:	bd80      	pop	{r7, pc}

08008cce <lwip_init>:
 * Initialize all modules.
 * Use this in NO_SYS mode. Use tcpip_init() otherwise.
 */
void
lwip_init(void)
{
 8008cce:	b580      	push	{r7, lr}
 8008cd0:	b082      	sub	sp, #8
 8008cd2:	af00      	add	r7, sp, #0
#ifndef LWIP_SKIP_CONST_CHECK
  int a = 0;
 8008cd4:	2300      	movs	r3, #0
 8008cd6:	607b      	str	r3, [r7, #4]
  /* Modules initialization */
  stats_init();
#if !NO_SYS
  sys_init();
#endif /* !NO_SYS */
  mem_init();
 8008cd8:	f000 f8de 	bl	8008e98 <mem_init>
  memp_init();
 8008cdc:	f000 fc70 	bl	80095c0 <memp_init>
  pbuf_init();
  netif_init();
 8008ce0:	f000 fd6e 	bl	80097c0 <netif_init>
#endif /* LWIP_IPV4 */
#if LWIP_RAW
  raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
  udp_init();
 8008ce4:	f009 ff66 	bl	8012bb4 <udp_init>
#endif /* LWIP_UDP */
#if LWIP_TCP
  tcp_init();
 8008ce8:	f002 f980 	bl	800afec <tcp_init>
#endif /* LWIP_TCP */
#if LWIP_IGMP
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
 8008cec:	f7fe fc02 	bl	80074f4 <dns_init>
#endif /* LWIP_DNS */
#if PPP_SUPPORT
  ppp_init();
 8008cf0:	f011 fcae 	bl	801a650 <ppp_init>
#endif

#if LWIP_TIMERS
  sys_timeouts_init();
 8008cf4:	f009 fe94 	bl	8012a20 <sys_timeouts_init>
#endif /* LWIP_TIMERS */
}
 8008cf8:	46c0      	nop			; (mov r8, r8)
 8008cfa:	46bd      	mov	sp, r7
 8008cfc:	b002      	add	sp, #8
 8008cfe:	bd80      	pop	{r7, pc}

08008d00 <ptr_to_mem>:
#define mem_overflow_check_element(mem)
#endif /* MEM_OVERFLOW_CHECK */

static struct mem *
ptr_to_mem(mem_size_t ptr)
{
 8008d00:	b580      	push	{r7, lr}
 8008d02:	b082      	sub	sp, #8
 8008d04:	af00      	add	r7, sp, #0
 8008d06:	0002      	movs	r2, r0
 8008d08:	1dbb      	adds	r3, r7, #6
 8008d0a:	801a      	strh	r2, [r3, #0]
  return (struct mem *)(void *)&ram[ptr];
 8008d0c:	4b04      	ldr	r3, [pc, #16]	; (8008d20 <ptr_to_mem+0x20>)
 8008d0e:	681a      	ldr	r2, [r3, #0]
 8008d10:	1dbb      	adds	r3, r7, #6
 8008d12:	881b      	ldrh	r3, [r3, #0]
 8008d14:	18d3      	adds	r3, r2, r3
}
 8008d16:	0018      	movs	r0, r3
 8008d18:	46bd      	mov	sp, r7
 8008d1a:	b002      	add	sp, #8
 8008d1c:	bd80      	pop	{r7, pc}
 8008d1e:	46c0      	nop			; (mov r8, r8)
 8008d20:	20000c1c 	.word	0x20000c1c

08008d24 <mem_to_ptr>:

static mem_size_t
mem_to_ptr(void *mem)
{
 8008d24:	b580      	push	{r7, lr}
 8008d26:	b082      	sub	sp, #8
 8008d28:	af00      	add	r7, sp, #0
 8008d2a:	6078      	str	r0, [r7, #4]
  return (mem_size_t)((u8_t *)mem - ram);
 8008d2c:	4b04      	ldr	r3, [pc, #16]	; (8008d40 <mem_to_ptr+0x1c>)
 8008d2e:	681b      	ldr	r3, [r3, #0]
 8008d30:	687a      	ldr	r2, [r7, #4]
 8008d32:	1ad3      	subs	r3, r2, r3
 8008d34:	b29b      	uxth	r3, r3
}
 8008d36:	0018      	movs	r0, r3
 8008d38:	46bd      	mov	sp, r7
 8008d3a:	b002      	add	sp, #8
 8008d3c:	bd80      	pop	{r7, pc}
 8008d3e:	46c0      	nop			; (mov r8, r8)
 8008d40:	20000c1c 	.word	0x20000c1c

08008d44 <plug_holes>:
 * This assumes access to the heap is protected by the calling function
 * already.
 */
static void
plug_holes(struct mem *mem)
{
 8008d44:	b590      	push	{r4, r7, lr}
 8008d46:	b085      	sub	sp, #20
 8008d48:	af00      	add	r7, sp, #0
 8008d4a:	6078      	str	r0, [r7, #4]
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
 8008d4c:	4b49      	ldr	r3, [pc, #292]	; (8008e74 <plug_holes+0x130>)
 8008d4e:	681b      	ldr	r3, [r3, #0]
 8008d50:	687a      	ldr	r2, [r7, #4]
 8008d52:	429a      	cmp	r2, r3
 8008d54:	d206      	bcs.n	8008d64 <plug_holes+0x20>
 8008d56:	4b48      	ldr	r3, [pc, #288]	; (8008e78 <plug_holes+0x134>)
 8008d58:	22e0      	movs	r2, #224	; 0xe0
 8008d5a:	32ff      	adds	r2, #255	; 0xff
 8008d5c:	4947      	ldr	r1, [pc, #284]	; (8008e7c <plug_holes+0x138>)
 8008d5e:	4848      	ldr	r0, [pc, #288]	; (8008e80 <plug_holes+0x13c>)
 8008d60:	f7f9 fa40 	bl	80021e4 <app_debug_rtt_raw>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
 8008d64:	4b47      	ldr	r3, [pc, #284]	; (8008e84 <plug_holes+0x140>)
 8008d66:	681b      	ldr	r3, [r3, #0]
 8008d68:	687a      	ldr	r2, [r7, #4]
 8008d6a:	429a      	cmp	r2, r3
 8008d6c:	d306      	bcc.n	8008d7c <plug_holes+0x38>
 8008d6e:	4b42      	ldr	r3, [pc, #264]	; (8008e78 <plug_holes+0x134>)
 8008d70:	22f0      	movs	r2, #240	; 0xf0
 8008d72:	0052      	lsls	r2, r2, #1
 8008d74:	4944      	ldr	r1, [pc, #272]	; (8008e88 <plug_holes+0x144>)
 8008d76:	4842      	ldr	r0, [pc, #264]	; (8008e80 <plug_holes+0x13c>)
 8008d78:	f7f9 fa34 	bl	80021e4 <app_debug_rtt_raw>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
 8008d7c:	687b      	ldr	r3, [r7, #4]
 8008d7e:	791b      	ldrb	r3, [r3, #4]
 8008d80:	2b00      	cmp	r3, #0
 8008d82:	d006      	beq.n	8008d92 <plug_holes+0x4e>
 8008d84:	4b3c      	ldr	r3, [pc, #240]	; (8008e78 <plug_holes+0x134>)
 8008d86:	22e2      	movs	r2, #226	; 0xe2
 8008d88:	32ff      	adds	r2, #255	; 0xff
 8008d8a:	4940      	ldr	r1, [pc, #256]	; (8008e8c <plug_holes+0x148>)
 8008d8c:	483c      	ldr	r0, [pc, #240]	; (8008e80 <plug_holes+0x13c>)
 8008d8e:	f7f9 fa29 	bl	80021e4 <app_debug_rtt_raw>

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
 8008d92:	687b      	ldr	r3, [r7, #4]
 8008d94:	881a      	ldrh	r2, [r3, #0]
 8008d96:	2380      	movs	r3, #128	; 0x80
 8008d98:	00db      	lsls	r3, r3, #3
 8008d9a:	429a      	cmp	r2, r3
 8008d9c:	d906      	bls.n	8008dac <plug_holes+0x68>
 8008d9e:	4b36      	ldr	r3, [pc, #216]	; (8008e78 <plug_holes+0x134>)
 8008da0:	22f2      	movs	r2, #242	; 0xf2
 8008da2:	0052      	lsls	r2, r2, #1
 8008da4:	493a      	ldr	r1, [pc, #232]	; (8008e90 <plug_holes+0x14c>)
 8008da6:	4836      	ldr	r0, [pc, #216]	; (8008e80 <plug_holes+0x13c>)
 8008da8:	f7f9 fa1c 	bl	80021e4 <app_debug_rtt_raw>

  nmem = ptr_to_mem(mem->next);
 8008dac:	687b      	ldr	r3, [r7, #4]
 8008dae:	881b      	ldrh	r3, [r3, #0]
 8008db0:	0018      	movs	r0, r3
 8008db2:	f7ff ffa5 	bl	8008d00 <ptr_to_mem>
 8008db6:	0003      	movs	r3, r0
 8008db8:	60fb      	str	r3, [r7, #12]
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
 8008dba:	687a      	ldr	r2, [r7, #4]
 8008dbc:	68fb      	ldr	r3, [r7, #12]
 8008dbe:	429a      	cmp	r2, r3
 8008dc0:	d026      	beq.n	8008e10 <plug_holes+0xcc>
 8008dc2:	68fb      	ldr	r3, [r7, #12]
 8008dc4:	791b      	ldrb	r3, [r3, #4]
 8008dc6:	2b00      	cmp	r3, #0
 8008dc8:	d122      	bne.n	8008e10 <plug_holes+0xcc>
 8008dca:	4b2e      	ldr	r3, [pc, #184]	; (8008e84 <plug_holes+0x140>)
 8008dcc:	681b      	ldr	r3, [r3, #0]
 8008dce:	68fa      	ldr	r2, [r7, #12]
 8008dd0:	429a      	cmp	r2, r3
 8008dd2:	d01d      	beq.n	8008e10 <plug_holes+0xcc>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
 8008dd4:	4b2f      	ldr	r3, [pc, #188]	; (8008e94 <plug_holes+0x150>)
 8008dd6:	681b      	ldr	r3, [r3, #0]
 8008dd8:	68fa      	ldr	r2, [r7, #12]
 8008dda:	429a      	cmp	r2, r3
 8008ddc:	d102      	bne.n	8008de4 <plug_holes+0xa0>
      lfree = mem;
 8008dde:	4b2d      	ldr	r3, [pc, #180]	; (8008e94 <plug_holes+0x150>)
 8008de0:	687a      	ldr	r2, [r7, #4]
 8008de2:	601a      	str	r2, [r3, #0]
    }
    mem->next = nmem->next;
 8008de4:	68fb      	ldr	r3, [r7, #12]
 8008de6:	881a      	ldrh	r2, [r3, #0]
 8008de8:	687b      	ldr	r3, [r7, #4]
 8008dea:	801a      	strh	r2, [r3, #0]
    if (nmem->next != MEM_SIZE_ALIGNED) {
 8008dec:	68fb      	ldr	r3, [r7, #12]
 8008dee:	881a      	ldrh	r2, [r3, #0]
 8008df0:	2380      	movs	r3, #128	; 0x80
 8008df2:	00db      	lsls	r3, r3, #3
 8008df4:	429a      	cmp	r2, r3
 8008df6:	d00b      	beq.n	8008e10 <plug_holes+0xcc>
      ptr_to_mem(nmem->next)->prev = mem_to_ptr(mem);
 8008df8:	68fb      	ldr	r3, [r7, #12]
 8008dfa:	881b      	ldrh	r3, [r3, #0]
 8008dfc:	0018      	movs	r0, r3
 8008dfe:	f7ff ff7f 	bl	8008d00 <ptr_to_mem>
 8008e02:	0004      	movs	r4, r0
 8008e04:	687b      	ldr	r3, [r7, #4]
 8008e06:	0018      	movs	r0, r3
 8008e08:	f7ff ff8c 	bl	8008d24 <mem_to_ptr>
 8008e0c:	0003      	movs	r3, r0
 8008e0e:	8063      	strh	r3, [r4, #2]
    }
  }

  /* plug hole backward */
  pmem = ptr_to_mem(mem->prev);
 8008e10:	687b      	ldr	r3, [r7, #4]
 8008e12:	885b      	ldrh	r3, [r3, #2]
 8008e14:	0018      	movs	r0, r3
 8008e16:	f7ff ff73 	bl	8008d00 <ptr_to_mem>
 8008e1a:	0003      	movs	r3, r0
 8008e1c:	60bb      	str	r3, [r7, #8]
  if (pmem != mem && pmem->used == 0) {
 8008e1e:	68ba      	ldr	r2, [r7, #8]
 8008e20:	687b      	ldr	r3, [r7, #4]
 8008e22:	429a      	cmp	r2, r3
 8008e24:	d021      	beq.n	8008e6a <plug_holes+0x126>
 8008e26:	68bb      	ldr	r3, [r7, #8]
 8008e28:	791b      	ldrb	r3, [r3, #4]
 8008e2a:	2b00      	cmp	r3, #0
 8008e2c:	d11d      	bne.n	8008e6a <plug_holes+0x126>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
 8008e2e:	4b19      	ldr	r3, [pc, #100]	; (8008e94 <plug_holes+0x150>)
 8008e30:	681b      	ldr	r3, [r3, #0]
 8008e32:	687a      	ldr	r2, [r7, #4]
 8008e34:	429a      	cmp	r2, r3
 8008e36:	d102      	bne.n	8008e3e <plug_holes+0xfa>
      lfree = pmem;
 8008e38:	4b16      	ldr	r3, [pc, #88]	; (8008e94 <plug_holes+0x150>)
 8008e3a:	68ba      	ldr	r2, [r7, #8]
 8008e3c:	601a      	str	r2, [r3, #0]
    }
    pmem->next = mem->next;
 8008e3e:	687b      	ldr	r3, [r7, #4]
 8008e40:	881a      	ldrh	r2, [r3, #0]
 8008e42:	68bb      	ldr	r3, [r7, #8]
 8008e44:	801a      	strh	r2, [r3, #0]
    if (mem->next != MEM_SIZE_ALIGNED) {
 8008e46:	687b      	ldr	r3, [r7, #4]
 8008e48:	881a      	ldrh	r2, [r3, #0]
 8008e4a:	2380      	movs	r3, #128	; 0x80
 8008e4c:	00db      	lsls	r3, r3, #3
 8008e4e:	429a      	cmp	r2, r3
 8008e50:	d00b      	beq.n	8008e6a <plug_holes+0x126>
      ptr_to_mem(mem->next)->prev = mem_to_ptr(pmem);
 8008e52:	687b      	ldr	r3, [r7, #4]
 8008e54:	881b      	ldrh	r3, [r3, #0]
 8008e56:	0018      	movs	r0, r3
 8008e58:	f7ff ff52 	bl	8008d00 <ptr_to_mem>
 8008e5c:	0004      	movs	r4, r0
 8008e5e:	68bb      	ldr	r3, [r7, #8]
 8008e60:	0018      	movs	r0, r3
 8008e62:	f7ff ff5f 	bl	8008d24 <mem_to_ptr>
 8008e66:	0003      	movs	r3, r0
 8008e68:	8063      	strh	r3, [r4, #2]
    }
  }
}
 8008e6a:	46c0      	nop			; (mov r8, r8)
 8008e6c:	46bd      	mov	sp, r7
 8008e6e:	b005      	add	sp, #20
 8008e70:	bd90      	pop	{r4, r7, pc}
 8008e72:	46c0      	nop			; (mov r8, r8)
 8008e74:	20000c1c 	.word	0x20000c1c
 8008e78:	0801ff5c 	.word	0x0801ff5c
 8008e7c:	0801ff84 	.word	0x0801ff84
 8008e80:	0801ff9c 	.word	0x0801ff9c
 8008e84:	20000c20 	.word	0x20000c20
 8008e88:	0801ffc8 	.word	0x0801ffc8
 8008e8c:	0801ffe4 	.word	0x0801ffe4
 8008e90:	08020000 	.word	0x08020000
 8008e94:	20000c24 	.word	0x20000c24

08008e98 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
 8008e98:	b580      	push	{r7, lr}
 8008e9a:	b082      	sub	sp, #8
 8008e9c:	af00      	add	r7, sp, #0

  LWIP_ASSERT("Sanity check alignment",
              (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT - 1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
 8008e9e:	4b19      	ldr	r3, [pc, #100]	; (8008f04 <mem_init+0x6c>)
 8008ea0:	3303      	adds	r3, #3
 8008ea2:	2203      	movs	r2, #3
 8008ea4:	4393      	bics	r3, r2
 8008ea6:	001a      	movs	r2, r3
 8008ea8:	4b17      	ldr	r3, [pc, #92]	; (8008f08 <mem_init+0x70>)
 8008eaa:	601a      	str	r2, [r3, #0]
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
 8008eac:	4b16      	ldr	r3, [pc, #88]	; (8008f08 <mem_init+0x70>)
 8008eae:	681b      	ldr	r3, [r3, #0]
 8008eb0:	607b      	str	r3, [r7, #4]
  mem->next = MEM_SIZE_ALIGNED;
 8008eb2:	687b      	ldr	r3, [r7, #4]
 8008eb4:	2280      	movs	r2, #128	; 0x80
 8008eb6:	00d2      	lsls	r2, r2, #3
 8008eb8:	801a      	strh	r2, [r3, #0]
  mem->prev = 0;
 8008eba:	687b      	ldr	r3, [r7, #4]
 8008ebc:	2200      	movs	r2, #0
 8008ebe:	805a      	strh	r2, [r3, #2]
  mem->used = 0;
 8008ec0:	687b      	ldr	r3, [r7, #4]
 8008ec2:	2200      	movs	r2, #0
 8008ec4:	711a      	strb	r2, [r3, #4]
  /* initialize the end of the heap */
  ram_end = ptr_to_mem(MEM_SIZE_ALIGNED);
 8008ec6:	2380      	movs	r3, #128	; 0x80
 8008ec8:	00db      	lsls	r3, r3, #3
 8008eca:	0018      	movs	r0, r3
 8008ecc:	f7ff ff18 	bl	8008d00 <ptr_to_mem>
 8008ed0:	0002      	movs	r2, r0
 8008ed2:	4b0e      	ldr	r3, [pc, #56]	; (8008f0c <mem_init+0x74>)
 8008ed4:	601a      	str	r2, [r3, #0]
  ram_end->used = 1;
 8008ed6:	4b0d      	ldr	r3, [pc, #52]	; (8008f0c <mem_init+0x74>)
 8008ed8:	681b      	ldr	r3, [r3, #0]
 8008eda:	2201      	movs	r2, #1
 8008edc:	711a      	strb	r2, [r3, #4]
  ram_end->next = MEM_SIZE_ALIGNED;
 8008ede:	4b0b      	ldr	r3, [pc, #44]	; (8008f0c <mem_init+0x74>)
 8008ee0:	681b      	ldr	r3, [r3, #0]
 8008ee2:	2280      	movs	r2, #128	; 0x80
 8008ee4:	00d2      	lsls	r2, r2, #3
 8008ee6:	801a      	strh	r2, [r3, #0]
  ram_end->prev = MEM_SIZE_ALIGNED;
 8008ee8:	4b08      	ldr	r3, [pc, #32]	; (8008f0c <mem_init+0x74>)
 8008eea:	681b      	ldr	r3, [r3, #0]
 8008eec:	2280      	movs	r2, #128	; 0x80
 8008eee:	00d2      	lsls	r2, r2, #3
 8008ef0:	805a      	strh	r2, [r3, #2]
  MEM_SANITY();

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;
 8008ef2:	4b05      	ldr	r3, [pc, #20]	; (8008f08 <mem_init+0x70>)
 8008ef4:	681a      	ldr	r2, [r3, #0]
 8008ef6:	4b06      	ldr	r3, [pc, #24]	; (8008f10 <mem_init+0x78>)
 8008ef8:	601a      	str	r2, [r3, #0]
  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);

  if (sys_mutex_new(&mem_mutex) != ERR_OK) {
    LWIP_ASSERT("failed to create mem_mutex", 0);
  }
}
 8008efa:	46c0      	nop			; (mov r8, r8)
 8008efc:	46bd      	mov	sp, r7
 8008efe:	b002      	add	sp, #8
 8008f00:	bd80      	pop	{r7, pc}
 8008f02:	46c0      	nop			; (mov r8, r8)
 8008f04:	20001150 	.word	0x20001150
 8008f08:	20000c1c 	.word	0x20000c1c
 8008f0c:	20000c20 	.word	0x20000c20
 8008f10:	20000c24 	.word	0x20000c24

08008f14 <mem_link_valid>:
/* Check if a struct mem is correctly linked.
 * If not, double-free is a possible reason.
 */
static int
mem_link_valid(struct mem *mem)
{
 8008f14:	b5b0      	push	{r4, r5, r7, lr}
 8008f16:	b086      	sub	sp, #24
 8008f18:	af00      	add	r7, sp, #0
 8008f1a:	6078      	str	r0, [r7, #4]
  struct mem *nmem, *pmem;
  mem_size_t rmem_idx;
  rmem_idx = mem_to_ptr(mem);
 8008f1c:	2516      	movs	r5, #22
 8008f1e:	197c      	adds	r4, r7, r5
 8008f20:	687b      	ldr	r3, [r7, #4]
 8008f22:	0018      	movs	r0, r3
 8008f24:	f7ff fefe 	bl	8008d24 <mem_to_ptr>
 8008f28:	0003      	movs	r3, r0
 8008f2a:	8023      	strh	r3, [r4, #0]
  nmem = ptr_to_mem(mem->next);
 8008f2c:	687b      	ldr	r3, [r7, #4]
 8008f2e:	881b      	ldrh	r3, [r3, #0]
 8008f30:	0018      	movs	r0, r3
 8008f32:	f7ff fee5 	bl	8008d00 <ptr_to_mem>
 8008f36:	0003      	movs	r3, r0
 8008f38:	613b      	str	r3, [r7, #16]
  pmem = ptr_to_mem(mem->prev);
 8008f3a:	687b      	ldr	r3, [r7, #4]
 8008f3c:	885b      	ldrh	r3, [r3, #2]
 8008f3e:	0018      	movs	r0, r3
 8008f40:	f7ff fede 	bl	8008d00 <ptr_to_mem>
 8008f44:	0003      	movs	r3, r0
 8008f46:	60fb      	str	r3, [r7, #12]
  if ((mem->next > MEM_SIZE_ALIGNED) || (mem->prev > MEM_SIZE_ALIGNED) ||
 8008f48:	687b      	ldr	r3, [r7, #4]
 8008f4a:	881a      	ldrh	r2, [r3, #0]
 8008f4c:	2380      	movs	r3, #128	; 0x80
 8008f4e:	00db      	lsls	r3, r3, #3
 8008f50:	429a      	cmp	r2, r3
 8008f52:	d81d      	bhi.n	8008f90 <mem_link_valid+0x7c>
 8008f54:	687b      	ldr	r3, [r7, #4]
 8008f56:	885a      	ldrh	r2, [r3, #2]
 8008f58:	2380      	movs	r3, #128	; 0x80
 8008f5a:	00db      	lsls	r3, r3, #3
 8008f5c:	429a      	cmp	r2, r3
 8008f5e:	d817      	bhi.n	8008f90 <mem_link_valid+0x7c>
      ((mem->prev != rmem_idx) && (pmem->next != rmem_idx)) ||
 8008f60:	687b      	ldr	r3, [r7, #4]
 8008f62:	885b      	ldrh	r3, [r3, #2]
  if ((mem->next > MEM_SIZE_ALIGNED) || (mem->prev > MEM_SIZE_ALIGNED) ||
 8008f64:	197a      	adds	r2, r7, r5
 8008f66:	8812      	ldrh	r2, [r2, #0]
 8008f68:	429a      	cmp	r2, r3
 8008f6a:	d005      	beq.n	8008f78 <mem_link_valid+0x64>
      ((mem->prev != rmem_idx) && (pmem->next != rmem_idx)) ||
 8008f6c:	68fb      	ldr	r3, [r7, #12]
 8008f6e:	881b      	ldrh	r3, [r3, #0]
 8008f70:	197a      	adds	r2, r7, r5
 8008f72:	8812      	ldrh	r2, [r2, #0]
 8008f74:	429a      	cmp	r2, r3
 8008f76:	d10b      	bne.n	8008f90 <mem_link_valid+0x7c>
      ((nmem != ram_end) && (nmem->prev != rmem_idx))) {
 8008f78:	4b09      	ldr	r3, [pc, #36]	; (8008fa0 <mem_link_valid+0x8c>)
 8008f7a:	681b      	ldr	r3, [r3, #0]
      ((mem->prev != rmem_idx) && (pmem->next != rmem_idx)) ||
 8008f7c:	693a      	ldr	r2, [r7, #16]
 8008f7e:	429a      	cmp	r2, r3
 8008f80:	d008      	beq.n	8008f94 <mem_link_valid+0x80>
      ((nmem != ram_end) && (nmem->prev != rmem_idx))) {
 8008f82:	693b      	ldr	r3, [r7, #16]
 8008f84:	885b      	ldrh	r3, [r3, #2]
 8008f86:	2216      	movs	r2, #22
 8008f88:	18ba      	adds	r2, r7, r2
 8008f8a:	8812      	ldrh	r2, [r2, #0]
 8008f8c:	429a      	cmp	r2, r3
 8008f8e:	d001      	beq.n	8008f94 <mem_link_valid+0x80>
    return 0;
 8008f90:	2300      	movs	r3, #0
 8008f92:	e000      	b.n	8008f96 <mem_link_valid+0x82>
  }
  return 1;
 8008f94:	2301      	movs	r3, #1
}
 8008f96:	0018      	movs	r0, r3
 8008f98:	46bd      	mov	sp, r7
 8008f9a:	b006      	add	sp, #24
 8008f9c:	bdb0      	pop	{r4, r5, r7, pc}
 8008f9e:	46c0      	nop			; (mov r8, r8)
 8008fa0:	20000c20 	.word	0x20000c20

08008fa4 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
 8008fa4:	b580      	push	{r7, lr}
 8008fa6:	b084      	sub	sp, #16
 8008fa8:	af00      	add	r7, sp, #0
 8008faa:	6078      	str	r0, [r7, #4]
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
 8008fac:	687b      	ldr	r3, [r7, #4]
 8008fae:	2b00      	cmp	r3, #0
 8008fb0:	d049      	beq.n	8009046 <mem_free+0xa2>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  if ((((mem_ptr_t)rmem) & (MEM_ALIGNMENT - 1)) != 0) {
 8008fb2:	687b      	ldr	r3, [r7, #4]
 8008fb4:	2203      	movs	r2, #3
 8008fb6:	4013      	ands	r3, r2
 8008fb8:	d006      	beq.n	8008fc8 <mem_free+0x24>
    LWIP_MEM_ILLEGAL_FREE("mem_free: sanity check alignment");
 8008fba:	4b25      	ldr	r3, [pc, #148]	; (8009050 <mem_free+0xac>)
 8008fbc:	4a25      	ldr	r2, [pc, #148]	; (8009054 <mem_free+0xb0>)
 8008fbe:	4926      	ldr	r1, [pc, #152]	; (8009058 <mem_free+0xb4>)
 8008fc0:	4826      	ldr	r0, [pc, #152]	; (800905c <mem_free+0xb8>)
 8008fc2:	f7f9 f90f 	bl	80021e4 <app_debug_rtt_raw>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: sanity check alignment\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
    return;
 8008fc6:	e03f      	b.n	8009048 <mem_free+0xa4>
  }

  /* Get the corresponding struct mem: */
  /* cast through void* to get rid of alignment warnings */
  mem = (struct mem *)(void *)((u8_t *)rmem - (SIZEOF_STRUCT_MEM + MEM_SANITY_OFFSET));
 8008fc8:	687b      	ldr	r3, [r7, #4]
 8008fca:	3b08      	subs	r3, #8
 8008fcc:	60fb      	str	r3, [r7, #12]

  if ((u8_t *)mem < ram || (u8_t *)rmem + MIN_SIZE_ALIGNED > (u8_t *)ram_end) {
 8008fce:	4b24      	ldr	r3, [pc, #144]	; (8009060 <mem_free+0xbc>)
 8008fd0:	681b      	ldr	r3, [r3, #0]
 8008fd2:	68fa      	ldr	r2, [r7, #12]
 8008fd4:	429a      	cmp	r2, r3
 8008fd6:	d306      	bcc.n	8008fe6 <mem_free+0x42>
 8008fd8:	687b      	ldr	r3, [r7, #4]
 8008fda:	330c      	adds	r3, #12
 8008fdc:	001a      	movs	r2, r3
 8008fde:	4b21      	ldr	r3, [pc, #132]	; (8009064 <mem_free+0xc0>)
 8008fe0:	681b      	ldr	r3, [r3, #0]
 8008fe2:	429a      	cmp	r2, r3
 8008fe4:	d906      	bls.n	8008ff4 <mem_free+0x50>
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory");
 8008fe6:	4b1a      	ldr	r3, [pc, #104]	; (8009050 <mem_free+0xac>)
 8008fe8:	4a1f      	ldr	r2, [pc, #124]	; (8009068 <mem_free+0xc4>)
 8008fea:	4920      	ldr	r1, [pc, #128]	; (800906c <mem_free+0xc8>)
 8008fec:	481b      	ldr	r0, [pc, #108]	; (800905c <mem_free+0xb8>)
 8008fee:	f7f9 f8f9 	bl	80021e4 <app_debug_rtt_raw>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
    return;
 8008ff2:	e029      	b.n	8009048 <mem_free+0xa4>
  mem_overflow_check_element(mem);
#endif
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* mem has to be in a used state */
  if (!mem->used) {
 8008ff4:	68fb      	ldr	r3, [r7, #12]
 8008ff6:	791b      	ldrb	r3, [r3, #4]
 8008ff8:	2b00      	cmp	r3, #0
 8008ffa:	d107      	bne.n	800900c <mem_free+0x68>
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory: double free");
 8008ffc:	4b14      	ldr	r3, [pc, #80]	; (8009050 <mem_free+0xac>)
 8008ffe:	22a3      	movs	r2, #163	; 0xa3
 8009000:	0092      	lsls	r2, r2, #2
 8009002:	491b      	ldr	r1, [pc, #108]	; (8009070 <mem_free+0xcc>)
 8009004:	4815      	ldr	r0, [pc, #84]	; (800905c <mem_free+0xb8>)
 8009006:	f7f9 f8ed 	bl	80021e4 <app_debug_rtt_raw>
    LWIP_MEM_FREE_UNPROTECT();
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory: double free?\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
    return;
 800900a:	e01d      	b.n	8009048 <mem_free+0xa4>
  }

  if (!mem_link_valid(mem)) {
 800900c:	68fb      	ldr	r3, [r7, #12]
 800900e:	0018      	movs	r0, r3
 8009010:	f7ff ff80 	bl	8008f14 <mem_link_valid>
 8009014:	1e03      	subs	r3, r0, #0
 8009016:	d106      	bne.n	8009026 <mem_free+0x82>
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory: non-linked: double free");
 8009018:	4b0d      	ldr	r3, [pc, #52]	; (8009050 <mem_free+0xac>)
 800901a:	4a16      	ldr	r2, [pc, #88]	; (8009074 <mem_free+0xd0>)
 800901c:	4916      	ldr	r1, [pc, #88]	; (8009078 <mem_free+0xd4>)
 800901e:	480f      	ldr	r0, [pc, #60]	; (800905c <mem_free+0xb8>)
 8009020:	f7f9 f8e0 	bl	80021e4 <app_debug_rtt_raw>
    LWIP_MEM_FREE_UNPROTECT();
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory: non-linked: double free?\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
    return;
 8009024:	e010      	b.n	8009048 <mem_free+0xa4>
  }

  /* mem is now unused. */
  mem->used = 0;
 8009026:	68fb      	ldr	r3, [r7, #12]
 8009028:	2200      	movs	r2, #0
 800902a:	711a      	strb	r2, [r3, #4]

  if (mem < lfree) {
 800902c:	4b13      	ldr	r3, [pc, #76]	; (800907c <mem_free+0xd8>)
 800902e:	681b      	ldr	r3, [r3, #0]
 8009030:	68fa      	ldr	r2, [r7, #12]
 8009032:	429a      	cmp	r2, r3
 8009034:	d202      	bcs.n	800903c <mem_free+0x98>
    /* the newly freed struct is now the lowest */
    lfree = mem;
 8009036:	4b11      	ldr	r3, [pc, #68]	; (800907c <mem_free+0xd8>)
 8009038:	68fa      	ldr	r2, [r7, #12]
 800903a:	601a      	str	r2, [r3, #0]
  }

  MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));

  /* finally, see if prev or next are free also */
  plug_holes(mem);
 800903c:	68fb      	ldr	r3, [r7, #12]
 800903e:	0018      	movs	r0, r3
 8009040:	f7ff fe80 	bl	8008d44 <plug_holes>
 8009044:	e000      	b.n	8009048 <mem_free+0xa4>
    return;
 8009046:	46c0      	nop			; (mov r8, r8)
  MEM_SANITY();
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
 8009048:	46bd      	mov	sp, r7
 800904a:	b004      	add	sp, #16
 800904c:	bd80      	pop	{r7, pc}
 800904e:	46c0      	nop			; (mov r8, r8)
 8009050:	0801ff5c 	.word	0x0801ff5c
 8009054:	00000273 	.word	0x00000273
 8009058:	0802002c 	.word	0x0802002c
 800905c:	0801ff9c 	.word	0x0801ff9c
 8009060:	20000c1c 	.word	0x20000c1c
 8009064:	20000c20 	.word	0x20000c20
 8009068:	0000027f 	.word	0x0000027f
 800906c:	08020050 	.word	0x08020050
 8009070:	0802006c 	.word	0x0802006c
 8009074:	00000295 	.word	0x00000295
 8009078:	08020094 	.word	0x08020094
 800907c:	20000c24 	.word	0x20000c24

08009080 <mem_trim>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_trim(void *rmem, mem_size_t new_size)
{
 8009080:	b5b0      	push	{r4, r5, r7, lr}
 8009082:	b088      	sub	sp, #32
 8009084:	af00      	add	r7, sp, #0
 8009086:	6078      	str	r0, [r7, #4]
 8009088:	000a      	movs	r2, r1
 800908a:	1cbb      	adds	r3, r7, #2
 800908c:	801a      	strh	r2, [r3, #0]
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = (mem_size_t)LWIP_MEM_ALIGN_SIZE(new_size);
 800908e:	1cbb      	adds	r3, r7, #2
 8009090:	881b      	ldrh	r3, [r3, #0]
 8009092:	3303      	adds	r3, #3
 8009094:	b29a      	uxth	r2, r3
 8009096:	201e      	movs	r0, #30
 8009098:	183b      	adds	r3, r7, r0
 800909a:	2103      	movs	r1, #3
 800909c:	438a      	bics	r2, r1
 800909e:	801a      	strh	r2, [r3, #0]
  if (newsize < MIN_SIZE_ALIGNED) {
 80090a0:	183b      	adds	r3, r7, r0
 80090a2:	881b      	ldrh	r3, [r3, #0]
 80090a4:	2b0b      	cmp	r3, #11
 80090a6:	d802      	bhi.n	80090ae <mem_trim+0x2e>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
 80090a8:	183b      	adds	r3, r7, r0
 80090aa:	220c      	movs	r2, #12
 80090ac:	801a      	strh	r2, [r3, #0]
  }
#if MEM_OVERFLOW_CHECK
  newsize += MEM_SANITY_REGION_BEFORE_ALIGNED + MEM_SANITY_REGION_AFTER_ALIGNED;
#endif
  if ((newsize > MEM_SIZE_ALIGNED) || (newsize < new_size)) {
 80090ae:	211e      	movs	r1, #30
 80090b0:	187b      	adds	r3, r7, r1
 80090b2:	881a      	ldrh	r2, [r3, #0]
 80090b4:	2380      	movs	r3, #128	; 0x80
 80090b6:	00db      	lsls	r3, r3, #3
 80090b8:	429a      	cmp	r2, r3
 80090ba:	d805      	bhi.n	80090c8 <mem_trim+0x48>
 80090bc:	187a      	adds	r2, r7, r1
 80090be:	1cbb      	adds	r3, r7, #2
 80090c0:	8812      	ldrh	r2, [r2, #0]
 80090c2:	881b      	ldrh	r3, [r3, #0]
 80090c4:	429a      	cmp	r2, r3
 80090c6:	d201      	bcs.n	80090cc <mem_trim+0x4c>
    return NULL;
 80090c8:	2300      	movs	r3, #0
 80090ca:	e102      	b.n	80092d2 <mem_trim+0x252>
  }

  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 80090cc:	4b83      	ldr	r3, [pc, #524]	; (80092dc <mem_trim+0x25c>)
 80090ce:	681b      	ldr	r3, [r3, #0]
 80090d0:	687a      	ldr	r2, [r7, #4]
 80090d2:	429a      	cmp	r2, r3
 80090d4:	d304      	bcc.n	80090e0 <mem_trim+0x60>
 80090d6:	4b82      	ldr	r3, [pc, #520]	; (80092e0 <mem_trim+0x260>)
 80090d8:	681b      	ldr	r3, [r3, #0]
 80090da:	687a      	ldr	r2, [r7, #4]
 80090dc:	429a      	cmp	r2, r3
 80090de:	d305      	bcc.n	80090ec <mem_trim+0x6c>
 80090e0:	4b80      	ldr	r3, [pc, #512]	; (80092e4 <mem_trim+0x264>)
 80090e2:	4a81      	ldr	r2, [pc, #516]	; (80092e8 <mem_trim+0x268>)
 80090e4:	4981      	ldr	r1, [pc, #516]	; (80092ec <mem_trim+0x26c>)
 80090e6:	4882      	ldr	r0, [pc, #520]	; (80092f0 <mem_trim+0x270>)
 80090e8:	f7f9 f87c 	bl	80021e4 <app_debug_rtt_raw>
              (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 80090ec:	4b7b      	ldr	r3, [pc, #492]	; (80092dc <mem_trim+0x25c>)
 80090ee:	681b      	ldr	r3, [r3, #0]
 80090f0:	687a      	ldr	r2, [r7, #4]
 80090f2:	429a      	cmp	r2, r3
 80090f4:	d304      	bcc.n	8009100 <mem_trim+0x80>
 80090f6:	4b7a      	ldr	r3, [pc, #488]	; (80092e0 <mem_trim+0x260>)
 80090f8:	681b      	ldr	r3, [r3, #0]
 80090fa:	687a      	ldr	r2, [r7, #4]
 80090fc:	429a      	cmp	r2, r3
 80090fe:	d301      	bcc.n	8009104 <mem_trim+0x84>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_trim: illegal memory\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
    return rmem;
 8009100:	687b      	ldr	r3, [r7, #4]
 8009102:	e0e6      	b.n	80092d2 <mem_trim+0x252>
  }
  /* Get the corresponding struct mem ... */
  /* cast through void* to get rid of alignment warnings */
  mem = (struct mem *)(void *)((u8_t *)rmem - (SIZEOF_STRUCT_MEM + MEM_SANITY_OFFSET));
 8009104:	687b      	ldr	r3, [r7, #4]
 8009106:	3b08      	subs	r3, #8
 8009108:	61bb      	str	r3, [r7, #24]
#if MEM_OVERFLOW_CHECK
  mem_overflow_check_element(mem);
#endif
  /* ... and its offset pointer */
  ptr = mem_to_ptr(mem);
 800910a:	2516      	movs	r5, #22
 800910c:	197c      	adds	r4, r7, r5
 800910e:	69bb      	ldr	r3, [r7, #24]
 8009110:	0018      	movs	r0, r3
 8009112:	f7ff fe07 	bl	8008d24 <mem_to_ptr>
 8009116:	0003      	movs	r3, r0
 8009118:	8023      	strh	r3, [r4, #0]

  size = (mem_size_t)((mem_size_t)(mem->next - ptr) - (SIZEOF_STRUCT_MEM + MEM_SANITY_OVERHEAD));
 800911a:	69bb      	ldr	r3, [r7, #24]
 800911c:	881a      	ldrh	r2, [r3, #0]
 800911e:	197b      	adds	r3, r7, r5
 8009120:	881b      	ldrh	r3, [r3, #0]
 8009122:	1ad3      	subs	r3, r2, r3
 8009124:	b29a      	uxth	r2, r3
 8009126:	2114      	movs	r1, #20
 8009128:	187b      	adds	r3, r7, r1
 800912a:	3a08      	subs	r2, #8
 800912c:	801a      	strh	r2, [r3, #0]
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
 800912e:	231e      	movs	r3, #30
 8009130:	18fa      	adds	r2, r7, r3
 8009132:	187b      	adds	r3, r7, r1
 8009134:	8812      	ldrh	r2, [r2, #0]
 8009136:	881b      	ldrh	r3, [r3, #0]
 8009138:	429a      	cmp	r2, r3
 800913a:	d906      	bls.n	800914a <mem_trim+0xca>
 800913c:	4b69      	ldr	r3, [pc, #420]	; (80092e4 <mem_trim+0x264>)
 800913e:	22b9      	movs	r2, #185	; 0xb9
 8009140:	0092      	lsls	r2, r2, #2
 8009142:	496c      	ldr	r1, [pc, #432]	; (80092f4 <mem_trim+0x274>)
 8009144:	486a      	ldr	r0, [pc, #424]	; (80092f0 <mem_trim+0x270>)
 8009146:	f7f9 f84d 	bl	80021e4 <app_debug_rtt_raw>
  if (newsize > size) {
 800914a:	231e      	movs	r3, #30
 800914c:	18fa      	adds	r2, r7, r3
 800914e:	2314      	movs	r3, #20
 8009150:	18fb      	adds	r3, r7, r3
 8009152:	8812      	ldrh	r2, [r2, #0]
 8009154:	881b      	ldrh	r3, [r3, #0]
 8009156:	429a      	cmp	r2, r3
 8009158:	d901      	bls.n	800915e <mem_trim+0xde>
    /* not supported */
    return NULL;
 800915a:	2300      	movs	r3, #0
 800915c:	e0b9      	b.n	80092d2 <mem_trim+0x252>
  }
  if (newsize == size) {
 800915e:	231e      	movs	r3, #30
 8009160:	18fa      	adds	r2, r7, r3
 8009162:	2314      	movs	r3, #20
 8009164:	18fb      	adds	r3, r7, r3
 8009166:	8812      	ldrh	r2, [r2, #0]
 8009168:	881b      	ldrh	r3, [r3, #0]
 800916a:	429a      	cmp	r2, r3
 800916c:	d101      	bne.n	8009172 <mem_trim+0xf2>
    /* No change in size, simply return */
    return rmem;
 800916e:	687b      	ldr	r3, [r7, #4]
 8009170:	e0af      	b.n	80092d2 <mem_trim+0x252>
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();

  mem2 = ptr_to_mem(mem->next);
 8009172:	69bb      	ldr	r3, [r7, #24]
 8009174:	881b      	ldrh	r3, [r3, #0]
 8009176:	0018      	movs	r0, r3
 8009178:	f7ff fdc2 	bl	8008d00 <ptr_to_mem>
 800917c:	0003      	movs	r3, r0
 800917e:	613b      	str	r3, [r7, #16]
  if (mem2->used == 0) {
 8009180:	693b      	ldr	r3, [r7, #16]
 8009182:	791b      	ldrb	r3, [r3, #4]
 8009184:	2b00      	cmp	r3, #0
 8009186:	d152      	bne.n	800922e <mem_trim+0x1ae>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    LWIP_ASSERT("invalid next ptr", mem->next != MEM_SIZE_ALIGNED);
 8009188:	69bb      	ldr	r3, [r7, #24]
 800918a:	881a      	ldrh	r2, [r3, #0]
 800918c:	2380      	movs	r3, #128	; 0x80
 800918e:	00db      	lsls	r3, r3, #3
 8009190:	429a      	cmp	r2, r3
 8009192:	d105      	bne.n	80091a0 <mem_trim+0x120>
 8009194:	4b53      	ldr	r3, [pc, #332]	; (80092e4 <mem_trim+0x264>)
 8009196:	4a58      	ldr	r2, [pc, #352]	; (80092f8 <mem_trim+0x278>)
 8009198:	4958      	ldr	r1, [pc, #352]	; (80092fc <mem_trim+0x27c>)
 800919a:	4855      	ldr	r0, [pc, #340]	; (80092f0 <mem_trim+0x270>)
 800919c:	f7f9 f822 	bl	80021e4 <app_debug_rtt_raw>
    /* remember the old next pointer */
    next = mem2->next;
 80091a0:	230c      	movs	r3, #12
 80091a2:	18fb      	adds	r3, r7, r3
 80091a4:	693a      	ldr	r2, [r7, #16]
 80091a6:	8812      	ldrh	r2, [r2, #0]
 80091a8:	801a      	strh	r2, [r3, #0]
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + newsize);
 80091aa:	2316      	movs	r3, #22
 80091ac:	18fa      	adds	r2, r7, r3
 80091ae:	231e      	movs	r3, #30
 80091b0:	18fb      	adds	r3, r7, r3
 80091b2:	8812      	ldrh	r2, [r2, #0]
 80091b4:	881b      	ldrh	r3, [r3, #0]
 80091b6:	18d3      	adds	r3, r2, r3
 80091b8:	b29a      	uxth	r2, r3
 80091ba:	210e      	movs	r1, #14
 80091bc:	187b      	adds	r3, r7, r1
 80091be:	3208      	adds	r2, #8
 80091c0:	801a      	strh	r2, [r3, #0]
    if (lfree == mem2) {
 80091c2:	4b4f      	ldr	r3, [pc, #316]	; (8009300 <mem_trim+0x280>)
 80091c4:	681b      	ldr	r3, [r3, #0]
 80091c6:	693a      	ldr	r2, [r7, #16]
 80091c8:	429a      	cmp	r2, r3
 80091ca:	d107      	bne.n	80091dc <mem_trim+0x15c>
      lfree = ptr_to_mem(ptr2);
 80091cc:	187b      	adds	r3, r7, r1
 80091ce:	881b      	ldrh	r3, [r3, #0]
 80091d0:	0018      	movs	r0, r3
 80091d2:	f7ff fd95 	bl	8008d00 <ptr_to_mem>
 80091d6:	0002      	movs	r2, r0
 80091d8:	4b49      	ldr	r3, [pc, #292]	; (8009300 <mem_trim+0x280>)
 80091da:	601a      	str	r2, [r3, #0]
    }
    mem2 = ptr_to_mem(ptr2);
 80091dc:	240e      	movs	r4, #14
 80091de:	193b      	adds	r3, r7, r4
 80091e0:	881b      	ldrh	r3, [r3, #0]
 80091e2:	0018      	movs	r0, r3
 80091e4:	f7ff fd8c 	bl	8008d00 <ptr_to_mem>
 80091e8:	0003      	movs	r3, r0
 80091ea:	613b      	str	r3, [r7, #16]
    mem2->used = 0;
 80091ec:	693b      	ldr	r3, [r7, #16]
 80091ee:	2200      	movs	r2, #0
 80091f0:	711a      	strb	r2, [r3, #4]
    /* restore the next pointer */
    mem2->next = next;
 80091f2:	693b      	ldr	r3, [r7, #16]
 80091f4:	220c      	movs	r2, #12
 80091f6:	18ba      	adds	r2, r7, r2
 80091f8:	8812      	ldrh	r2, [r2, #0]
 80091fa:	801a      	strh	r2, [r3, #0]
    /* link it back to mem */
    mem2->prev = ptr;
 80091fc:	693b      	ldr	r3, [r7, #16]
 80091fe:	2216      	movs	r2, #22
 8009200:	18ba      	adds	r2, r7, r2
 8009202:	8812      	ldrh	r2, [r2, #0]
 8009204:	805a      	strh	r2, [r3, #2]
    /* link mem to it */
    mem->next = ptr2;
 8009206:	69bb      	ldr	r3, [r7, #24]
 8009208:	193a      	adds	r2, r7, r4
 800920a:	8812      	ldrh	r2, [r2, #0]
 800920c:	801a      	strh	r2, [r3, #0]
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
 800920e:	693b      	ldr	r3, [r7, #16]
 8009210:	881a      	ldrh	r2, [r3, #0]
 8009212:	2380      	movs	r3, #128	; 0x80
 8009214:	00db      	lsls	r3, r3, #3
 8009216:	429a      	cmp	r2, r3
 8009218:	d05a      	beq.n	80092d0 <mem_trim+0x250>
      ptr_to_mem(mem2->next)->prev = ptr2;
 800921a:	693b      	ldr	r3, [r7, #16]
 800921c:	881b      	ldrh	r3, [r3, #0]
 800921e:	0018      	movs	r0, r3
 8009220:	f7ff fd6e 	bl	8008d00 <ptr_to_mem>
 8009224:	0002      	movs	r2, r0
 8009226:	193b      	adds	r3, r7, r4
 8009228:	881b      	ldrh	r3, [r3, #0]
 800922a:	8053      	strh	r3, [r2, #2]
 800922c:	e050      	b.n	80092d0 <mem_trim+0x250>
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
 800922e:	211e      	movs	r1, #30
 8009230:	187b      	adds	r3, r7, r1
 8009232:	881b      	ldrh	r3, [r3, #0]
 8009234:	3314      	adds	r3, #20
 8009236:	001a      	movs	r2, r3
 8009238:	2314      	movs	r3, #20
 800923a:	18fb      	adds	r3, r7, r3
 800923c:	881b      	ldrh	r3, [r3, #0]
 800923e:	429a      	cmp	r2, r3
 8009240:	d846      	bhi.n	80092d0 <mem_trim+0x250>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + newsize);
 8009242:	2316      	movs	r3, #22
 8009244:	18fa      	adds	r2, r7, r3
 8009246:	187b      	adds	r3, r7, r1
 8009248:	8812      	ldrh	r2, [r2, #0]
 800924a:	881b      	ldrh	r3, [r3, #0]
 800924c:	18d3      	adds	r3, r2, r3
 800924e:	b29a      	uxth	r2, r3
 8009250:	230e      	movs	r3, #14
 8009252:	18fb      	adds	r3, r7, r3
 8009254:	3208      	adds	r2, #8
 8009256:	801a      	strh	r2, [r3, #0]
    LWIP_ASSERT("invalid next ptr", mem->next != MEM_SIZE_ALIGNED);
 8009258:	69bb      	ldr	r3, [r7, #24]
 800925a:	881a      	ldrh	r2, [r3, #0]
 800925c:	2380      	movs	r3, #128	; 0x80
 800925e:	00db      	lsls	r3, r3, #3
 8009260:	429a      	cmp	r2, r3
 8009262:	d105      	bne.n	8009270 <mem_trim+0x1f0>
 8009264:	4b1f      	ldr	r3, [pc, #124]	; (80092e4 <mem_trim+0x264>)
 8009266:	4a27      	ldr	r2, [pc, #156]	; (8009304 <mem_trim+0x284>)
 8009268:	4924      	ldr	r1, [pc, #144]	; (80092fc <mem_trim+0x27c>)
 800926a:	4821      	ldr	r0, [pc, #132]	; (80092f0 <mem_trim+0x270>)
 800926c:	f7f8 ffba 	bl	80021e4 <app_debug_rtt_raw>
    mem2 = ptr_to_mem(ptr2);
 8009270:	230e      	movs	r3, #14
 8009272:	18fb      	adds	r3, r7, r3
 8009274:	881b      	ldrh	r3, [r3, #0]
 8009276:	0018      	movs	r0, r3
 8009278:	f7ff fd42 	bl	8008d00 <ptr_to_mem>
 800927c:	0003      	movs	r3, r0
 800927e:	613b      	str	r3, [r7, #16]
    if (mem2 < lfree) {
 8009280:	4b1f      	ldr	r3, [pc, #124]	; (8009300 <mem_trim+0x280>)
 8009282:	681b      	ldr	r3, [r3, #0]
 8009284:	693a      	ldr	r2, [r7, #16]
 8009286:	429a      	cmp	r2, r3
 8009288:	d202      	bcs.n	8009290 <mem_trim+0x210>
      lfree = mem2;
 800928a:	4b1d      	ldr	r3, [pc, #116]	; (8009300 <mem_trim+0x280>)
 800928c:	693a      	ldr	r2, [r7, #16]
 800928e:	601a      	str	r2, [r3, #0]
    }
    mem2->used = 0;
 8009290:	693b      	ldr	r3, [r7, #16]
 8009292:	2200      	movs	r2, #0
 8009294:	711a      	strb	r2, [r3, #4]
    mem2->next = mem->next;
 8009296:	69bb      	ldr	r3, [r7, #24]
 8009298:	881a      	ldrh	r2, [r3, #0]
 800929a:	693b      	ldr	r3, [r7, #16]
 800929c:	801a      	strh	r2, [r3, #0]
    mem2->prev = ptr;
 800929e:	693b      	ldr	r3, [r7, #16]
 80092a0:	2216      	movs	r2, #22
 80092a2:	18ba      	adds	r2, r7, r2
 80092a4:	8812      	ldrh	r2, [r2, #0]
 80092a6:	805a      	strh	r2, [r3, #2]
    mem->next = ptr2;
 80092a8:	69bb      	ldr	r3, [r7, #24]
 80092aa:	240e      	movs	r4, #14
 80092ac:	193a      	adds	r2, r7, r4
 80092ae:	8812      	ldrh	r2, [r2, #0]
 80092b0:	801a      	strh	r2, [r3, #0]
    if (mem2->next != MEM_SIZE_ALIGNED) {
 80092b2:	693b      	ldr	r3, [r7, #16]
 80092b4:	881a      	ldrh	r2, [r3, #0]
 80092b6:	2380      	movs	r3, #128	; 0x80
 80092b8:	00db      	lsls	r3, r3, #3
 80092ba:	429a      	cmp	r2, r3
 80092bc:	d008      	beq.n	80092d0 <mem_trim+0x250>
      ptr_to_mem(mem2->next)->prev = ptr2;
 80092be:	693b      	ldr	r3, [r7, #16]
 80092c0:	881b      	ldrh	r3, [r3, #0]
 80092c2:	0018      	movs	r0, r3
 80092c4:	f7ff fd1c 	bl	8008d00 <ptr_to_mem>
 80092c8:	0002      	movs	r2, r0
 80092ca:	193b      	adds	r3, r7, r4
 80092cc:	881b      	ldrh	r3, [r3, #0]
 80092ce:	8053      	strh	r3, [r2, #2]
  MEM_SANITY();
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
 80092d0:	687b      	ldr	r3, [r7, #4]
}
 80092d2:	0018      	movs	r0, r3
 80092d4:	46bd      	mov	sp, r7
 80092d6:	b008      	add	sp, #32
 80092d8:	bdb0      	pop	{r4, r5, r7, pc}
 80092da:	46c0      	nop			; (mov r8, r8)
 80092dc:	20000c1c 	.word	0x20000c1c
 80092e0:	20000c20 	.word	0x20000c20
 80092e4:	0801ff5c 	.word	0x0801ff5c
 80092e8:	000002d1 	.word	0x000002d1
 80092ec:	080200c8 	.word	0x080200c8
 80092f0:	0801ff9c 	.word	0x0801ff9c
 80092f4:	080200e0 	.word	0x080200e0
 80092f8:	000002f5 	.word	0x000002f5
 80092fc:	08020100 	.word	0x08020100
 8009300:	20000c24 	.word	0x20000c24
 8009304:	00000316 	.word	0x00000316

08009308 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size_in)
{
 8009308:	b590      	push	{r4, r7, lr}
 800930a:	b089      	sub	sp, #36	; 0x24
 800930c:	af00      	add	r7, sp, #0
 800930e:	0002      	movs	r2, r0
 8009310:	1dbb      	adds	r3, r7, #6
 8009312:	801a      	strh	r2, [r3, #0]
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size_in == 0) {
 8009314:	1dbb      	adds	r3, r7, #6
 8009316:	881b      	ldrh	r3, [r3, #0]
 8009318:	2b00      	cmp	r3, #0
 800931a:	d101      	bne.n	8009320 <mem_malloc+0x18>
    return NULL;
 800931c:	2300      	movs	r3, #0
 800931e:	e101      	b.n	8009524 <mem_malloc+0x21c>
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = (mem_size_t)LWIP_MEM_ALIGN_SIZE(size_in);
 8009320:	1dbb      	adds	r3, r7, #6
 8009322:	881b      	ldrh	r3, [r3, #0]
 8009324:	3303      	adds	r3, #3
 8009326:	b29a      	uxth	r2, r3
 8009328:	201c      	movs	r0, #28
 800932a:	183b      	adds	r3, r7, r0
 800932c:	2103      	movs	r1, #3
 800932e:	438a      	bics	r2, r1
 8009330:	801a      	strh	r2, [r3, #0]
  if (size < MIN_SIZE_ALIGNED) {
 8009332:	183b      	adds	r3, r7, r0
 8009334:	881b      	ldrh	r3, [r3, #0]
 8009336:	2b0b      	cmp	r3, #11
 8009338:	d802      	bhi.n	8009340 <mem_malloc+0x38>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
 800933a:	183b      	adds	r3, r7, r0
 800933c:	220c      	movs	r2, #12
 800933e:	801a      	strh	r2, [r3, #0]
  }
#if MEM_OVERFLOW_CHECK
  size += MEM_SANITY_REGION_BEFORE_ALIGNED + MEM_SANITY_REGION_AFTER_ALIGNED;
#endif
  if ((size > MEM_SIZE_ALIGNED) || (size < size_in)) {
 8009340:	211c      	movs	r1, #28
 8009342:	187b      	adds	r3, r7, r1
 8009344:	881a      	ldrh	r2, [r3, #0]
 8009346:	2380      	movs	r3, #128	; 0x80
 8009348:	00db      	lsls	r3, r3, #3
 800934a:	429a      	cmp	r2, r3
 800934c:	d805      	bhi.n	800935a <mem_malloc+0x52>
 800934e:	187a      	adds	r2, r7, r1
 8009350:	1dbb      	adds	r3, r7, #6
 8009352:	8812      	ldrh	r2, [r2, #0]
 8009354:	881b      	ldrh	r3, [r3, #0]
 8009356:	429a      	cmp	r2, r3
 8009358:	d201      	bcs.n	800935e <mem_malloc+0x56>
    return NULL;
 800935a:	2300      	movs	r3, #0
 800935c:	e0e2      	b.n	8009524 <mem_malloc+0x21c>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = mem_to_ptr(lfree); ptr < MEM_SIZE_ALIGNED - size;
 800935e:	4b73      	ldr	r3, [pc, #460]	; (800952c <mem_malloc+0x224>)
 8009360:	681b      	ldr	r3, [r3, #0]
 8009362:	221e      	movs	r2, #30
 8009364:	18bc      	adds	r4, r7, r2
 8009366:	0018      	movs	r0, r3
 8009368:	f7ff fcdc 	bl	8008d24 <mem_to_ptr>
 800936c:	0003      	movs	r3, r0
 800936e:	8023      	strh	r3, [r4, #0]
 8009370:	e0cb      	b.n	800950a <mem_malloc+0x202>
         ptr = ptr_to_mem(ptr)->next) {
      mem = ptr_to_mem(ptr);
 8009372:	241e      	movs	r4, #30
 8009374:	193b      	adds	r3, r7, r4
 8009376:	881b      	ldrh	r3, [r3, #0]
 8009378:	0018      	movs	r0, r3
 800937a:	f7ff fcc1 	bl	8008d00 <ptr_to_mem>
 800937e:	0003      	movs	r3, r0
 8009380:	617b      	str	r3, [r7, #20]
        local_mem_free_count = 1;
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
 8009382:	697b      	ldr	r3, [r7, #20]
 8009384:	791b      	ldrb	r3, [r3, #4]
 8009386:	2b00      	cmp	r3, #0
 8009388:	d000      	beq.n	800938c <mem_malloc+0x84>
 800938a:	e0b4      	b.n	80094f6 <mem_malloc+0x1ee>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 800938c:	697b      	ldr	r3, [r7, #20]
 800938e:	881b      	ldrh	r3, [r3, #0]
 8009390:	001a      	movs	r2, r3
 8009392:	0021      	movs	r1, r4
 8009394:	187b      	adds	r3, r7, r1
 8009396:	881b      	ldrh	r3, [r3, #0]
 8009398:	1ad3      	subs	r3, r2, r3
 800939a:	3b08      	subs	r3, #8
 800939c:	001a      	movs	r2, r3
 800939e:	201c      	movs	r0, #28
 80093a0:	183b      	adds	r3, r7, r0
 80093a2:	881b      	ldrh	r3, [r3, #0]
      if ((!mem->used) &&
 80093a4:	429a      	cmp	r2, r3
 80093a6:	d200      	bcs.n	80093aa <mem_malloc+0xa2>
 80093a8:	e0a5      	b.n	80094f6 <mem_malloc+0x1ee>
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
 80093aa:	697b      	ldr	r3, [r7, #20]
 80093ac:	881b      	ldrh	r3, [r3, #0]
 80093ae:	001a      	movs	r2, r3
 80093b0:	187b      	adds	r3, r7, r1
 80093b2:	881b      	ldrh	r3, [r3, #0]
 80093b4:	1ad3      	subs	r3, r2, r3
 80093b6:	3b08      	subs	r3, #8
 80093b8:	001a      	movs	r2, r3
 80093ba:	183b      	adds	r3, r7, r0
 80093bc:	881b      	ldrh	r3, [r3, #0]
 80093be:	3314      	adds	r3, #20
 80093c0:	429a      	cmp	r2, r3
 80093c2:	d340      	bcc.n	8009446 <mem_malloc+0x13e>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + size);
 80093c4:	187a      	adds	r2, r7, r1
 80093c6:	183b      	adds	r3, r7, r0
 80093c8:	8812      	ldrh	r2, [r2, #0]
 80093ca:	881b      	ldrh	r3, [r3, #0]
 80093cc:	18d3      	adds	r3, r2, r3
 80093ce:	b29a      	uxth	r2, r3
 80093d0:	2112      	movs	r1, #18
 80093d2:	187b      	adds	r3, r7, r1
 80093d4:	3208      	adds	r2, #8
 80093d6:	801a      	strh	r2, [r3, #0]
          LWIP_ASSERT("invalid next ptr",ptr2 != MEM_SIZE_ALIGNED);
 80093d8:	187b      	adds	r3, r7, r1
 80093da:	881a      	ldrh	r2, [r3, #0]
 80093dc:	2380      	movs	r3, #128	; 0x80
 80093de:	00db      	lsls	r3, r3, #3
 80093e0:	429a      	cmp	r2, r3
 80093e2:	d105      	bne.n	80093f0 <mem_malloc+0xe8>
 80093e4:	4b52      	ldr	r3, [pc, #328]	; (8009530 <mem_malloc+0x228>)
 80093e6:	4a53      	ldr	r2, [pc, #332]	; (8009534 <mem_malloc+0x22c>)
 80093e8:	4953      	ldr	r1, [pc, #332]	; (8009538 <mem_malloc+0x230>)
 80093ea:	4854      	ldr	r0, [pc, #336]	; (800953c <mem_malloc+0x234>)
 80093ec:	f7f8 fefa 	bl	80021e4 <app_debug_rtt_raw>
          /* create mem2 struct */
          mem2 = ptr_to_mem(ptr2);
 80093f0:	2412      	movs	r4, #18
 80093f2:	193b      	adds	r3, r7, r4
 80093f4:	881b      	ldrh	r3, [r3, #0]
 80093f6:	0018      	movs	r0, r3
 80093f8:	f7ff fc82 	bl	8008d00 <ptr_to_mem>
 80093fc:	0003      	movs	r3, r0
 80093fe:	60fb      	str	r3, [r7, #12]
          mem2->used = 0;
 8009400:	68fb      	ldr	r3, [r7, #12]
 8009402:	2200      	movs	r2, #0
 8009404:	711a      	strb	r2, [r3, #4]
          mem2->next = mem->next;
 8009406:	697b      	ldr	r3, [r7, #20]
 8009408:	881a      	ldrh	r2, [r3, #0]
 800940a:	68fb      	ldr	r3, [r7, #12]
 800940c:	801a      	strh	r2, [r3, #0]
          mem2->prev = ptr;
 800940e:	68fb      	ldr	r3, [r7, #12]
 8009410:	221e      	movs	r2, #30
 8009412:	18ba      	adds	r2, r7, r2
 8009414:	8812      	ldrh	r2, [r2, #0]
 8009416:	805a      	strh	r2, [r3, #2]
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
 8009418:	697b      	ldr	r3, [r7, #20]
 800941a:	193a      	adds	r2, r7, r4
 800941c:	8812      	ldrh	r2, [r2, #0]
 800941e:	801a      	strh	r2, [r3, #0]
          mem->used = 1;
 8009420:	697b      	ldr	r3, [r7, #20]
 8009422:	2201      	movs	r2, #1
 8009424:	711a      	strb	r2, [r3, #4]

          if (mem2->next != MEM_SIZE_ALIGNED) {
 8009426:	68fb      	ldr	r3, [r7, #12]
 8009428:	881a      	ldrh	r2, [r3, #0]
 800942a:	2380      	movs	r3, #128	; 0x80
 800942c:	00db      	lsls	r3, r3, #3
 800942e:	429a      	cmp	r2, r3
 8009430:	d00c      	beq.n	800944c <mem_malloc+0x144>
            ptr_to_mem(mem2->next)->prev = ptr2;
 8009432:	68fb      	ldr	r3, [r7, #12]
 8009434:	881b      	ldrh	r3, [r3, #0]
 8009436:	0018      	movs	r0, r3
 8009438:	f7ff fc62 	bl	8008d00 <ptr_to_mem>
 800943c:	0002      	movs	r2, r0
 800943e:	193b      	adds	r3, r7, r4
 8009440:	881b      	ldrh	r3, [r3, #0]
 8009442:	8053      	strh	r3, [r2, #2]
 8009444:	e002      	b.n	800944c <mem_malloc+0x144>
           * take care of this).
           * -> near fit or exact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
 8009446:	697b      	ldr	r3, [r7, #20]
 8009448:	2201      	movs	r2, #1
 800944a:	711a      	strb	r2, [r3, #4]
          MEM_STATS_INC_USED(used, mem->next - mem_to_ptr(mem));
        }
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
 800944c:	4b37      	ldr	r3, [pc, #220]	; (800952c <mem_malloc+0x224>)
 800944e:	681b      	ldr	r3, [r3, #0]
 8009450:	697a      	ldr	r2, [r7, #20]
 8009452:	429a      	cmp	r2, r3
 8009454:	d127      	bne.n	80094a6 <mem_malloc+0x19e>
          struct mem *cur = lfree;
 8009456:	4b35      	ldr	r3, [pc, #212]	; (800952c <mem_malloc+0x224>)
 8009458:	681b      	ldr	r3, [r3, #0]
 800945a:	61bb      	str	r3, [r7, #24]
          /* Find next free block after mem and update lowest free pointer */
          while (cur->used && cur != ram_end) {
 800945c:	e006      	b.n	800946c <mem_malloc+0x164>
              /* If mem_free or mem_trim have run, we have to restart since they
                 could have altered our current struct mem or lfree. */
              goto mem_malloc_adjust_lfree;
            }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
            cur = ptr_to_mem(cur->next);
 800945e:	69bb      	ldr	r3, [r7, #24]
 8009460:	881b      	ldrh	r3, [r3, #0]
 8009462:	0018      	movs	r0, r3
 8009464:	f7ff fc4c 	bl	8008d00 <ptr_to_mem>
 8009468:	0003      	movs	r3, r0
 800946a:	61bb      	str	r3, [r7, #24]
          while (cur->used && cur != ram_end) {
 800946c:	69bb      	ldr	r3, [r7, #24]
 800946e:	791b      	ldrb	r3, [r3, #4]
 8009470:	2b00      	cmp	r3, #0
 8009472:	d004      	beq.n	800947e <mem_malloc+0x176>
 8009474:	4b32      	ldr	r3, [pc, #200]	; (8009540 <mem_malloc+0x238>)
 8009476:	681b      	ldr	r3, [r3, #0]
 8009478:	69ba      	ldr	r2, [r7, #24]
 800947a:	429a      	cmp	r2, r3
 800947c:	d1ef      	bne.n	800945e <mem_malloc+0x156>
          }
          lfree = cur;
 800947e:	4b2b      	ldr	r3, [pc, #172]	; (800952c <mem_malloc+0x224>)
 8009480:	69ba      	ldr	r2, [r7, #24]
 8009482:	601a      	str	r2, [r3, #0]
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
 8009484:	4b29      	ldr	r3, [pc, #164]	; (800952c <mem_malloc+0x224>)
 8009486:	681a      	ldr	r2, [r3, #0]
 8009488:	4b2d      	ldr	r3, [pc, #180]	; (8009540 <mem_malloc+0x238>)
 800948a:	681b      	ldr	r3, [r3, #0]
 800948c:	429a      	cmp	r2, r3
 800948e:	d00a      	beq.n	80094a6 <mem_malloc+0x19e>
 8009490:	4b26      	ldr	r3, [pc, #152]	; (800952c <mem_malloc+0x224>)
 8009492:	681b      	ldr	r3, [r3, #0]
 8009494:	791b      	ldrb	r3, [r3, #4]
 8009496:	2b00      	cmp	r3, #0
 8009498:	d005      	beq.n	80094a6 <mem_malloc+0x19e>
 800949a:	4b25      	ldr	r3, [pc, #148]	; (8009530 <mem_malloc+0x228>)
 800949c:	4a29      	ldr	r2, [pc, #164]	; (8009544 <mem_malloc+0x23c>)
 800949e:	492a      	ldr	r1, [pc, #168]	; (8009548 <mem_malloc+0x240>)
 80094a0:	4826      	ldr	r0, [pc, #152]	; (800953c <mem_malloc+0x234>)
 80094a2:	f7f8 fe9f 	bl	80021e4 <app_debug_rtt_raw>
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_mutex_unlock(&mem_mutex);
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
 80094a6:	231c      	movs	r3, #28
 80094a8:	18fb      	adds	r3, r7, r3
 80094aa:	881a      	ldrh	r2, [r3, #0]
 80094ac:	697b      	ldr	r3, [r7, #20]
 80094ae:	18d3      	adds	r3, r2, r3
 80094b0:	3308      	adds	r3, #8
 80094b2:	001a      	movs	r2, r3
 80094b4:	4b22      	ldr	r3, [pc, #136]	; (8009540 <mem_malloc+0x238>)
 80094b6:	681b      	ldr	r3, [r3, #0]
 80094b8:	429a      	cmp	r2, r3
 80094ba:	d905      	bls.n	80094c8 <mem_malloc+0x1c0>
 80094bc:	4b1c      	ldr	r3, [pc, #112]	; (8009530 <mem_malloc+0x228>)
 80094be:	4a23      	ldr	r2, [pc, #140]	; (800954c <mem_malloc+0x244>)
 80094c0:	4923      	ldr	r1, [pc, #140]	; (8009550 <mem_malloc+0x248>)
 80094c2:	481e      	ldr	r0, [pc, #120]	; (800953c <mem_malloc+0x234>)
 80094c4:	f7f8 fe8e 	bl	80021e4 <app_debug_rtt_raw>
                    (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
 80094c8:	697b      	ldr	r3, [r7, #20]
 80094ca:	2203      	movs	r2, #3
 80094cc:	4013      	ands	r3, r2
 80094ce:	d005      	beq.n	80094dc <mem_malloc+0x1d4>
 80094d0:	4b17      	ldr	r3, [pc, #92]	; (8009530 <mem_malloc+0x228>)
 80094d2:	4a20      	ldr	r2, [pc, #128]	; (8009554 <mem_malloc+0x24c>)
 80094d4:	4920      	ldr	r1, [pc, #128]	; (8009558 <mem_malloc+0x250>)
 80094d6:	4819      	ldr	r0, [pc, #100]	; (800953c <mem_malloc+0x234>)
 80094d8:	f7f8 fe84 	bl	80021e4 <app_debug_rtt_raw>
                    ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
 80094dc:	697b      	ldr	r3, [r7, #20]
 80094de:	2203      	movs	r2, #3
 80094e0:	4013      	ands	r3, r2
 80094e2:	d005      	beq.n	80094f0 <mem_malloc+0x1e8>
 80094e4:	4b12      	ldr	r3, [pc, #72]	; (8009530 <mem_malloc+0x228>)
 80094e6:	4a1d      	ldr	r2, [pc, #116]	; (800955c <mem_malloc+0x254>)
 80094e8:	491d      	ldr	r1, [pc, #116]	; (8009560 <mem_malloc+0x258>)
 80094ea:	4814      	ldr	r0, [pc, #80]	; (800953c <mem_malloc+0x234>)
 80094ec:	f7f8 fe7a 	bl	80021e4 <app_debug_rtt_raw>

#if MEM_OVERFLOW_CHECK
        mem_overflow_init_element(mem, size_in);
#endif
        MEM_SANITY();
        return (u8_t *)mem + SIZEOF_STRUCT_MEM + MEM_SANITY_OFFSET;
 80094f0:	697b      	ldr	r3, [r7, #20]
 80094f2:	3308      	adds	r3, #8
 80094f4:	e016      	b.n	8009524 <mem_malloc+0x21c>
         ptr = ptr_to_mem(ptr)->next) {
 80094f6:	241e      	movs	r4, #30
 80094f8:	193b      	adds	r3, r7, r4
 80094fa:	881b      	ldrh	r3, [r3, #0]
 80094fc:	0018      	movs	r0, r3
 80094fe:	f7ff fbff 	bl	8008d00 <ptr_to_mem>
 8009502:	0002      	movs	r2, r0
 8009504:	193b      	adds	r3, r7, r4
 8009506:	8812      	ldrh	r2, [r2, #0]
 8009508:	801a      	strh	r2, [r3, #0]
    for (ptr = mem_to_ptr(lfree); ptr < MEM_SIZE_ALIGNED - size;
 800950a:	231e      	movs	r3, #30
 800950c:	18fb      	adds	r3, r7, r3
 800950e:	881a      	ldrh	r2, [r3, #0]
 8009510:	231c      	movs	r3, #28
 8009512:	18fb      	adds	r3, r7, r3
 8009514:	881b      	ldrh	r3, [r3, #0]
 8009516:	2180      	movs	r1, #128	; 0x80
 8009518:	00c9      	lsls	r1, r1, #3
 800951a:	1acb      	subs	r3, r1, r3
 800951c:	429a      	cmp	r2, r3
 800951e:	d200      	bcs.n	8009522 <mem_malloc+0x21a>
 8009520:	e727      	b.n	8009372 <mem_malloc+0x6a>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  return NULL;
 8009522:	2300      	movs	r3, #0
}
 8009524:	0018      	movs	r0, r3
 8009526:	46bd      	mov	sp, r7
 8009528:	b009      	add	sp, #36	; 0x24
 800952a:	bd90      	pop	{r4, r7, pc}
 800952c:	20000c24 	.word	0x20000c24
 8009530:	0801ff5c 	.word	0x0801ff5c
 8009534:	00000387 	.word	0x00000387
 8009538:	08020100 	.word	0x08020100
 800953c:	0801ff9c 	.word	0x0801ff9c
 8009540:	20000c20 	.word	0x20000c20
 8009544:	000003b5 	.word	0x000003b5
 8009548:	08020114 	.word	0x08020114
 800954c:	000003b9 	.word	0x000003b9
 8009550:	08020130 	.word	0x08020130
 8009554:	000003bb 	.word	0x000003bb
 8009558:	08020160 	.word	0x08020160
 800955c:	000003bd 	.word	0x000003bd
 8009560:	08020190 	.word	0x08020190

08009564 <memp_init_pool>:
 *
 * @param desc pool to initialize
 */
void
memp_init_pool(const struct memp_desc *desc)
{
 8009564:	b580      	push	{r7, lr}
 8009566:	b084      	sub	sp, #16
 8009568:	af00      	add	r7, sp, #0
 800956a:	6078      	str	r0, [r7, #4]
  LWIP_UNUSED_ARG(desc);
#else
  int i;
  struct memp *memp;

  *desc->tab = NULL;
 800956c:	687b      	ldr	r3, [r7, #4]
 800956e:	68db      	ldr	r3, [r3, #12]
 8009570:	2200      	movs	r2, #0
 8009572:	601a      	str	r2, [r3, #0]
  memp = (struct memp *)LWIP_MEM_ALIGN(desc->base);
 8009574:	687b      	ldr	r3, [r7, #4]
 8009576:	689b      	ldr	r3, [r3, #8]
 8009578:	3303      	adds	r3, #3
 800957a:	2203      	movs	r2, #3
 800957c:	4393      	bics	r3, r2
 800957e:	60bb      	str	r3, [r7, #8]
                                       + MEM_SANITY_REGION_AFTER_ALIGNED
#endif
                                      ));
#endif
  /* create a linked list of memp elements */
  for (i = 0; i < desc->num; ++i) {
 8009580:	2300      	movs	r3, #0
 8009582:	60fb      	str	r3, [r7, #12]
 8009584:	e011      	b.n	80095aa <memp_init_pool+0x46>
    memp->next = *desc->tab;
 8009586:	687b      	ldr	r3, [r7, #4]
 8009588:	68db      	ldr	r3, [r3, #12]
 800958a:	681a      	ldr	r2, [r3, #0]
 800958c:	68bb      	ldr	r3, [r7, #8]
 800958e:	601a      	str	r2, [r3, #0]
    *desc->tab = memp;
 8009590:	687b      	ldr	r3, [r7, #4]
 8009592:	68db      	ldr	r3, [r3, #12]
 8009594:	68ba      	ldr	r2, [r7, #8]
 8009596:	601a      	str	r2, [r3, #0]
#if MEMP_OVERFLOW_CHECK
    memp_overflow_init_element(memp, desc);
#endif /* MEMP_OVERFLOW_CHECK */
    /* cast through void* to get rid of alignment warnings */
    memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + desc->size
 8009598:	687b      	ldr	r3, [r7, #4]
 800959a:	889b      	ldrh	r3, [r3, #4]
 800959c:	001a      	movs	r2, r3
 800959e:	68bb      	ldr	r3, [r7, #8]
 80095a0:	189b      	adds	r3, r3, r2
 80095a2:	60bb      	str	r3, [r7, #8]
  for (i = 0; i < desc->num; ++i) {
 80095a4:	68fb      	ldr	r3, [r7, #12]
 80095a6:	3301      	adds	r3, #1
 80095a8:	60fb      	str	r3, [r7, #12]
 80095aa:	687b      	ldr	r3, [r7, #4]
 80095ac:	88db      	ldrh	r3, [r3, #6]
 80095ae:	001a      	movs	r2, r3
 80095b0:	68fb      	ldr	r3, [r7, #12]
 80095b2:	4293      	cmp	r3, r2
 80095b4:	dbe7      	blt.n	8009586 <memp_init_pool+0x22>
#endif /* !MEMP_MEM_MALLOC */

#if MEMP_STATS && (defined(LWIP_DEBUG) || LWIP_STATS_DISPLAY)
  desc->stats->name  = desc->desc;
#endif /* MEMP_STATS && (defined(LWIP_DEBUG) || LWIP_STATS_DISPLAY) */
}
 80095b6:	46c0      	nop			; (mov r8, r8)
 80095b8:	46c0      	nop			; (mov r8, r8)
 80095ba:	46bd      	mov	sp, r7
 80095bc:	b004      	add	sp, #16
 80095be:	bd80      	pop	{r7, pc}

080095c0 <memp_init>:
 *
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
 80095c0:	b580      	push	{r7, lr}
 80095c2:	b082      	sub	sp, #8
 80095c4:	af00      	add	r7, sp, #0
  u16_t i;

  /* for every pool: */
  for (i = 0; i < LWIP_ARRAYSIZE(memp_pools); i++) {
 80095c6:	1dbb      	adds	r3, r7, #6
 80095c8:	2200      	movs	r2, #0
 80095ca:	801a      	strh	r2, [r3, #0]
 80095cc:	e00c      	b.n	80095e8 <memp_init+0x28>
    memp_init_pool(memp_pools[i]);
 80095ce:	1dbb      	adds	r3, r7, #6
 80095d0:	881a      	ldrh	r2, [r3, #0]
 80095d2:	4b0a      	ldr	r3, [pc, #40]	; (80095fc <memp_init+0x3c>)
 80095d4:	0092      	lsls	r2, r2, #2
 80095d6:	58d3      	ldr	r3, [r2, r3]
 80095d8:	0018      	movs	r0, r3
 80095da:	f7ff ffc3 	bl	8009564 <memp_init_pool>
  for (i = 0; i < LWIP_ARRAYSIZE(memp_pools); i++) {
 80095de:	1dbb      	adds	r3, r7, #6
 80095e0:	881a      	ldrh	r2, [r3, #0]
 80095e2:	1dbb      	adds	r3, r7, #6
 80095e4:	3201      	adds	r2, #1
 80095e6:	801a      	strh	r2, [r3, #0]
 80095e8:	1dbb      	adds	r3, r7, #6
 80095ea:	881b      	ldrh	r3, [r3, #0]
 80095ec:	2b06      	cmp	r3, #6
 80095ee:	d9ee      	bls.n	80095ce <memp_init+0xe>

#if MEMP_OVERFLOW_CHECK >= 2
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
}
 80095f0:	46c0      	nop			; (mov r8, r8)
 80095f2:	46c0      	nop			; (mov r8, r8)
 80095f4:	46bd      	mov	sp, r7
 80095f6:	b002      	add	sp, #8
 80095f8:	bd80      	pop	{r7, pc}
 80095fa:	46c0      	nop			; (mov r8, r8)
 80095fc:	08023a10 	.word	0x08023a10

08009600 <do_memp_malloc_pool>:
#if !MEMP_OVERFLOW_CHECK
do_memp_malloc_pool(const struct memp_desc *desc)
#else
do_memp_malloc_pool_fn(const struct memp_desc *desc, const char *file, const int line)
#endif
{
 8009600:	b580      	push	{r7, lr}
 8009602:	b084      	sub	sp, #16
 8009604:	af00      	add	r7, sp, #0
 8009606:	6078      	str	r0, [r7, #4]
  memp = (struct memp *)mem_malloc(MEMP_SIZE + MEMP_ALIGN_SIZE(desc->size));
  SYS_ARCH_PROTECT(old_level);
#else /* MEMP_MEM_MALLOC */
  SYS_ARCH_PROTECT(old_level);

  memp = *desc->tab;
 8009608:	687b      	ldr	r3, [r7, #4]
 800960a:	68db      	ldr	r3, [r3, #12]
 800960c:	681b      	ldr	r3, [r3, #0]
 800960e:	60fb      	str	r3, [r7, #12]
#endif /* MEMP_MEM_MALLOC */

  if (memp != NULL) {
 8009610:	68fb      	ldr	r3, [r7, #12]
 8009612:	2b00      	cmp	r3, #0
 8009614:	d011      	beq.n	800963a <do_memp_malloc_pool+0x3a>
#if !MEMP_MEM_MALLOC
#if MEMP_OVERFLOW_CHECK == 1
    memp_overflow_check_element(memp, desc);
#endif /* MEMP_OVERFLOW_CHECK */

    *desc->tab = memp->next;
 8009616:	687b      	ldr	r3, [r7, #4]
 8009618:	68db      	ldr	r3, [r3, #12]
 800961a:	68fa      	ldr	r2, [r7, #12]
 800961c:	6812      	ldr	r2, [r2, #0]
 800961e:	601a      	str	r2, [r3, #0]
    memp->line = line;
#if MEMP_MEM_MALLOC
    memp_overflow_init_element(memp, desc);
#endif /* MEMP_MEM_MALLOC */
#endif /* MEMP_OVERFLOW_CHECK */
    LWIP_ASSERT("memp_malloc: memp properly aligned",
 8009620:	68fb      	ldr	r3, [r7, #12]
 8009622:	2203      	movs	r2, #3
 8009624:	4013      	ands	r3, r2
 8009626:	d006      	beq.n	8009636 <do_memp_malloc_pool+0x36>
 8009628:	4b06      	ldr	r3, [pc, #24]	; (8009644 <do_memp_malloc_pool+0x44>)
 800962a:	228c      	movs	r2, #140	; 0x8c
 800962c:	0052      	lsls	r2, r2, #1
 800962e:	4906      	ldr	r1, [pc, #24]	; (8009648 <do_memp_malloc_pool+0x48>)
 8009630:	4806      	ldr	r0, [pc, #24]	; (800964c <do_memp_malloc_pool+0x4c>)
 8009632:	f7f8 fdd7 	bl	80021e4 <app_debug_rtt_raw>
      desc->stats->max = desc->stats->used;
    }
#endif
    SYS_ARCH_UNPROTECT(old_level);
    /* cast through u8_t* to get rid of alignment warnings */
    return ((u8_t *)memp + MEMP_SIZE);
 8009636:	68fb      	ldr	r3, [r7, #12]
 8009638:	e000      	b.n	800963c <do_memp_malloc_pool+0x3c>
#endif
    SYS_ARCH_UNPROTECT(old_level);
    LWIP_DEBUGF(MEMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("memp_malloc: out of memory in pool %s\n", desc->desc));
  }

  return NULL;
 800963a:	2300      	movs	r3, #0
}
 800963c:	0018      	movs	r0, r3
 800963e:	46bd      	mov	sp, r7
 8009640:	b004      	add	sp, #16
 8009642:	bd80      	pop	{r7, pc}
 8009644:	08020204 	.word	0x08020204
 8009648:	0802022c 	.word	0x0802022c
 800964c:	08020250 	.word	0x08020250

08009650 <memp_malloc_pool>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc_pool(const struct memp_desc *desc)
#else
memp_malloc_pool_fn(const struct memp_desc *desc, const char *file, const int line)
#endif
{
 8009650:	b580      	push	{r7, lr}
 8009652:	b082      	sub	sp, #8
 8009654:	af00      	add	r7, sp, #0
 8009656:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("invalid pool desc", desc != NULL);
 8009658:	687b      	ldr	r3, [r7, #4]
 800965a:	2b00      	cmp	r3, #0
 800965c:	d106      	bne.n	800966c <memp_malloc_pool+0x1c>
 800965e:	4b0a      	ldr	r3, [pc, #40]	; (8009688 <memp_malloc_pool+0x38>)
 8009660:	229e      	movs	r2, #158	; 0x9e
 8009662:	0052      	lsls	r2, r2, #1
 8009664:	4909      	ldr	r1, [pc, #36]	; (800968c <memp_malloc_pool+0x3c>)
 8009666:	480a      	ldr	r0, [pc, #40]	; (8009690 <memp_malloc_pool+0x40>)
 8009668:	f7f8 fdbc 	bl	80021e4 <app_debug_rtt_raw>
  if (desc == NULL) {
 800966c:	687b      	ldr	r3, [r7, #4]
 800966e:	2b00      	cmp	r3, #0
 8009670:	d101      	bne.n	8009676 <memp_malloc_pool+0x26>
    return NULL;
 8009672:	2300      	movs	r3, #0
 8009674:	e004      	b.n	8009680 <memp_malloc_pool+0x30>
  }

#if !MEMP_OVERFLOW_CHECK
  return do_memp_malloc_pool(desc);
 8009676:	687b      	ldr	r3, [r7, #4]
 8009678:	0018      	movs	r0, r3
 800967a:	f7ff ffc1 	bl	8009600 <do_memp_malloc_pool>
 800967e:	0003      	movs	r3, r0
#else
  return do_memp_malloc_pool_fn(desc, file, line);
#endif
}
 8009680:	0018      	movs	r0, r3
 8009682:	46bd      	mov	sp, r7
 8009684:	b002      	add	sp, #8
 8009686:	bd80      	pop	{r7, pc}
 8009688:	08020204 	.word	0x08020204
 800968c:	0802027c 	.word	0x0802027c
 8009690:	08020250 	.word	0x08020250

08009694 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char *file, const int line)
#endif
{
 8009694:	b580      	push	{r7, lr}
 8009696:	b084      	sub	sp, #16
 8009698:	af00      	add	r7, sp, #0
 800969a:	0002      	movs	r2, r0
 800969c:	1dfb      	adds	r3, r7, #7
 800969e:	701a      	strb	r2, [r3, #0]
  void *memp;
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 80096a0:	1dfb      	adds	r3, r7, #7
 80096a2:	781b      	ldrb	r3, [r3, #0]
 80096a4:	2b06      	cmp	r3, #6
 80096a6:	d905      	bls.n	80096b4 <memp_malloc+0x20>
 80096a8:	4b0a      	ldr	r3, [pc, #40]	; (80096d4 <memp_malloc+0x40>)
 80096aa:	0018      	movs	r0, r3
 80096ac:	f7f8 fd9a 	bl	80021e4 <app_debug_rtt_raw>
 80096b0:	2300      	movs	r3, #0
 80096b2:	e00a      	b.n	80096ca <memp_malloc+0x36>
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

#if !MEMP_OVERFLOW_CHECK
  memp = do_memp_malloc_pool(memp_pools[type]);
 80096b4:	1dfb      	adds	r3, r7, #7
 80096b6:	781a      	ldrb	r2, [r3, #0]
 80096b8:	4b07      	ldr	r3, [pc, #28]	; (80096d8 <memp_malloc+0x44>)
 80096ba:	0092      	lsls	r2, r2, #2
 80096bc:	58d3      	ldr	r3, [r2, r3]
 80096be:	0018      	movs	r0, r3
 80096c0:	f7ff ff9e 	bl	8009600 <do_memp_malloc_pool>
 80096c4:	0003      	movs	r3, r0
 80096c6:	60fb      	str	r3, [r7, #12]
#else
  memp = do_memp_malloc_pool_fn(memp_pools[type], file, line);
#endif

  return memp;
 80096c8:	68fb      	ldr	r3, [r7, #12]
}
 80096ca:	0018      	movs	r0, r3
 80096cc:	46bd      	mov	sp, r7
 80096ce:	b004      	add	sp, #16
 80096d0:	bd80      	pop	{r7, pc}
 80096d2:	46c0      	nop			; (mov r8, r8)
 80096d4:	08020290 	.word	0x08020290
 80096d8:	08023a10 	.word	0x08023a10

080096dc <do_memp_free_pool>:

static void
do_memp_free_pool(const struct memp_desc *desc, void *mem)
{
 80096dc:	b580      	push	{r7, lr}
 80096de:	b084      	sub	sp, #16
 80096e0:	af00      	add	r7, sp, #0
 80096e2:	6078      	str	r0, [r7, #4]
 80096e4:	6039      	str	r1, [r7, #0]
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  LWIP_ASSERT("memp_free: mem properly aligned",
 80096e6:	683b      	ldr	r3, [r7, #0]
 80096e8:	2203      	movs	r2, #3
 80096ea:	4013      	ands	r3, r2
 80096ec:	d006      	beq.n	80096fc <do_memp_free_pool+0x20>
 80096ee:	4b0b      	ldr	r3, [pc, #44]	; (800971c <do_memp_free_pool+0x40>)
 80096f0:	22b6      	movs	r2, #182	; 0xb6
 80096f2:	0052      	lsls	r2, r2, #1
 80096f4:	490a      	ldr	r1, [pc, #40]	; (8009720 <do_memp_free_pool+0x44>)
 80096f6:	480b      	ldr	r0, [pc, #44]	; (8009724 <do_memp_free_pool+0x48>)
 80096f8:	f7f8 fd74 	bl	80021e4 <app_debug_rtt_raw>
              ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  /* cast through void* to get rid of alignment warnings */
  memp = (struct memp *)(void *)((u8_t *)mem - MEMP_SIZE);
 80096fc:	683b      	ldr	r3, [r7, #0]
 80096fe:	60fb      	str	r3, [r7, #12]
#if MEMP_MEM_MALLOC
  LWIP_UNUSED_ARG(desc);
  SYS_ARCH_UNPROTECT(old_level);
  mem_free(memp);
#else /* MEMP_MEM_MALLOC */
  memp->next = *desc->tab;
 8009700:	687b      	ldr	r3, [r7, #4]
 8009702:	68db      	ldr	r3, [r3, #12]
 8009704:	681a      	ldr	r2, [r3, #0]
 8009706:	68fb      	ldr	r3, [r7, #12]
 8009708:	601a      	str	r2, [r3, #0]
  *desc->tab = memp;
 800970a:	687b      	ldr	r3, [r7, #4]
 800970c:	68db      	ldr	r3, [r3, #12]
 800970e:	68fa      	ldr	r2, [r7, #12]
 8009710:	601a      	str	r2, [r3, #0]
  LWIP_ASSERT("memp sanity", memp_sanity(desc));
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
#endif /* !MEMP_MEM_MALLOC */
}
 8009712:	46c0      	nop			; (mov r8, r8)
 8009714:	46bd      	mov	sp, r7
 8009716:	b004      	add	sp, #16
 8009718:	bd80      	pop	{r7, pc}
 800971a:	46c0      	nop			; (mov r8, r8)
 800971c:	08020204 	.word	0x08020204
 8009720:	080202b0 	.word	0x080202b0
 8009724:	08020250 	.word	0x08020250

08009728 <memp_free_pool>:
 * @param desc the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free_pool(const struct memp_desc *desc, void *mem)
{
 8009728:	b580      	push	{r7, lr}
 800972a:	b082      	sub	sp, #8
 800972c:	af00      	add	r7, sp, #0
 800972e:	6078      	str	r0, [r7, #4]
 8009730:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT("invalid pool desc", desc != NULL);
 8009732:	687b      	ldr	r3, [r7, #4]
 8009734:	2b00      	cmp	r3, #0
 8009736:	d106      	bne.n	8009746 <memp_free_pool+0x1e>
 8009738:	4b0b      	ldr	r3, [pc, #44]	; (8009768 <memp_free_pool+0x40>)
 800973a:	2296      	movs	r2, #150	; 0x96
 800973c:	32ff      	adds	r2, #255	; 0xff
 800973e:	490b      	ldr	r1, [pc, #44]	; (800976c <memp_free_pool+0x44>)
 8009740:	480b      	ldr	r0, [pc, #44]	; (8009770 <memp_free_pool+0x48>)
 8009742:	f7f8 fd4f 	bl	80021e4 <app_debug_rtt_raw>
  if ((desc == NULL) || (mem == NULL)) {
 8009746:	687b      	ldr	r3, [r7, #4]
 8009748:	2b00      	cmp	r3, #0
 800974a:	d009      	beq.n	8009760 <memp_free_pool+0x38>
 800974c:	683b      	ldr	r3, [r7, #0]
 800974e:	2b00      	cmp	r3, #0
 8009750:	d006      	beq.n	8009760 <memp_free_pool+0x38>
    return;
  }

  do_memp_free_pool(desc, mem);
 8009752:	683a      	ldr	r2, [r7, #0]
 8009754:	687b      	ldr	r3, [r7, #4]
 8009756:	0011      	movs	r1, r2
 8009758:	0018      	movs	r0, r3
 800975a:	f7ff ffbf 	bl	80096dc <do_memp_free_pool>
 800975e:	e000      	b.n	8009762 <memp_free_pool+0x3a>
    return;
 8009760:	46c0      	nop			; (mov r8, r8)
}
 8009762:	46bd      	mov	sp, r7
 8009764:	b002      	add	sp, #8
 8009766:	bd80      	pop	{r7, pc}
 8009768:	08020204 	.word	0x08020204
 800976c:	0802027c 	.word	0x0802027c
 8009770:	08020250 	.word	0x08020250

08009774 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
 8009774:	b580      	push	{r7, lr}
 8009776:	b082      	sub	sp, #8
 8009778:	af00      	add	r7, sp, #0
 800977a:	0002      	movs	r2, r0
 800977c:	6039      	str	r1, [r7, #0]
 800977e:	1dfb      	adds	r3, r7, #7
 8009780:	701a      	strb	r2, [r3, #0]
#ifdef LWIP_HOOK_MEMP_AVAILABLE
  struct memp *old_first;
#endif

  LWIP_ERROR("memp_free: type < MEMP_MAX", (type < MEMP_MAX), return;);
 8009782:	1dfb      	adds	r3, r7, #7
 8009784:	781b      	ldrb	r3, [r3, #0]
 8009786:	2b06      	cmp	r3, #6
 8009788:	d904      	bls.n	8009794 <memp_free+0x20>
 800978a:	4b0b      	ldr	r3, [pc, #44]	; (80097b8 <memp_free+0x44>)
 800978c:	0018      	movs	r0, r3
 800978e:	f7f8 fd29 	bl	80021e4 <app_debug_rtt_raw>
 8009792:	e00e      	b.n	80097b2 <memp_free+0x3e>

  if (mem == NULL) {
 8009794:	683b      	ldr	r3, [r7, #0]
 8009796:	2b00      	cmp	r3, #0
 8009798:	d00a      	beq.n	80097b0 <memp_free+0x3c>

#ifdef LWIP_HOOK_MEMP_AVAILABLE
  old_first = *memp_pools[type]->tab;
#endif

  do_memp_free_pool(memp_pools[type], mem);
 800979a:	1dfb      	adds	r3, r7, #7
 800979c:	781a      	ldrb	r2, [r3, #0]
 800979e:	4b07      	ldr	r3, [pc, #28]	; (80097bc <memp_free+0x48>)
 80097a0:	0092      	lsls	r2, r2, #2
 80097a2:	58d3      	ldr	r3, [r2, r3]
 80097a4:	683a      	ldr	r2, [r7, #0]
 80097a6:	0011      	movs	r1, r2
 80097a8:	0018      	movs	r0, r3
 80097aa:	f7ff ff97 	bl	80096dc <do_memp_free_pool>
 80097ae:	e000      	b.n	80097b2 <memp_free+0x3e>
    return;
 80097b0:	46c0      	nop			; (mov r8, r8)
#ifdef LWIP_HOOK_MEMP_AVAILABLE
  if (old_first == NULL) {
    LWIP_HOOK_MEMP_AVAILABLE(type);
  }
#endif
}
 80097b2:	46bd      	mov	sp, r7
 80097b4:	b002      	add	sp, #8
 80097b6:	bd80      	pop	{r7, pc}
 80097b8:	080202d0 	.word	0x080202d0
 80097bc:	08023a10 	.word	0x08023a10

080097c0 <netif_init>:
}
#endif /* LWIP_HAVE_LOOPIF */

void
netif_init(void)
{
 80097c0:	b580      	push	{r7, lr}
 80097c2:	af00      	add	r7, sp, #0

  netif_set_link_up(&loop_netif);
  netif_set_up(&loop_netif);

#endif /* LWIP_HAVE_LOOPIF */
}
 80097c4:	46c0      	nop			; (mov r8, r8)
 80097c6:	46bd      	mov	sp, r7
 80097c8:	bd80      	pop	{r7, pc}
	...

080097cc <netif_add>:
netif_add(struct netif *netif,
#if LWIP_IPV4
          const ip4_addr_t *ipaddr, const ip4_addr_t *netmask, const ip4_addr_t *gw,
#endif /* LWIP_IPV4 */
          void *state, netif_init_fn init, netif_input_fn input)
{
 80097cc:	b580      	push	{r7, lr}
 80097ce:	b086      	sub	sp, #24
 80097d0:	af00      	add	r7, sp, #0
 80097d2:	60f8      	str	r0, [r7, #12]
 80097d4:	60b9      	str	r1, [r7, #8]
 80097d6:	607a      	str	r2, [r7, #4]
 80097d8:	603b      	str	r3, [r7, #0]
    LWIP_ASSERT("single netif already set", 0);
    return NULL;
  }
#endif

  LWIP_ERROR("netif_add: invalid netif", netif != NULL, return NULL);
 80097da:	68fb      	ldr	r3, [r7, #12]
 80097dc:	2b00      	cmp	r3, #0
 80097de:	d105      	bne.n	80097ec <netif_add+0x20>
 80097e0:	4b57      	ldr	r3, [pc, #348]	; (8009940 <netif_add+0x174>)
 80097e2:	0018      	movs	r0, r3
 80097e4:	f7f8 fcfe 	bl	80021e4 <app_debug_rtt_raw>
 80097e8:	2300      	movs	r3, #0
 80097ea:	e0a5      	b.n	8009938 <netif_add+0x16c>
  LWIP_ERROR("netif_add: No init function given", init != NULL, return NULL);
 80097ec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80097ee:	2b00      	cmp	r3, #0
 80097f0:	d105      	bne.n	80097fe <netif_add+0x32>
 80097f2:	4b54      	ldr	r3, [pc, #336]	; (8009944 <netif_add+0x178>)
 80097f4:	0018      	movs	r0, r3
 80097f6:	f7f8 fcf5 	bl	80021e4 <app_debug_rtt_raw>
 80097fa:	2300      	movs	r3, #0
 80097fc:	e09c      	b.n	8009938 <netif_add+0x16c>

#if LWIP_IPV4
  if (ipaddr == NULL) {
 80097fe:	68bb      	ldr	r3, [r7, #8]
 8009800:	2b00      	cmp	r3, #0
 8009802:	d101      	bne.n	8009808 <netif_add+0x3c>
    ipaddr = ip_2_ip4(IP4_ADDR_ANY);
 8009804:	4b50      	ldr	r3, [pc, #320]	; (8009948 <netif_add+0x17c>)
 8009806:	60bb      	str	r3, [r7, #8]
  }
  if (netmask == NULL) {
 8009808:	687b      	ldr	r3, [r7, #4]
 800980a:	2b00      	cmp	r3, #0
 800980c:	d101      	bne.n	8009812 <netif_add+0x46>
    netmask = ip_2_ip4(IP4_ADDR_ANY);
 800980e:	4b4e      	ldr	r3, [pc, #312]	; (8009948 <netif_add+0x17c>)
 8009810:	607b      	str	r3, [r7, #4]
  }
  if (gw == NULL) {
 8009812:	683b      	ldr	r3, [r7, #0]
 8009814:	2b00      	cmp	r3, #0
 8009816:	d101      	bne.n	800981c <netif_add+0x50>
    gw = ip_2_ip4(IP4_ADDR_ANY);
 8009818:	4b4b      	ldr	r3, [pc, #300]	; (8009948 <netif_add+0x17c>)
 800981a:	603b      	str	r3, [r7, #0]
  }

  /* reset new interface configuration state */
  ip_addr_set_zero_ip4(&netif->ip_addr);
 800981c:	68fb      	ldr	r3, [r7, #12]
 800981e:	2200      	movs	r2, #0
 8009820:	605a      	str	r2, [r3, #4]
  ip_addr_set_zero_ip4(&netif->netmask);
 8009822:	68fb      	ldr	r3, [r7, #12]
 8009824:	2200      	movs	r2, #0
 8009826:	609a      	str	r2, [r3, #8]
  ip_addr_set_zero_ip4(&netif->gw);
 8009828:	68fb      	ldr	r3, [r7, #12]
 800982a:	2200      	movs	r2, #0
 800982c:	60da      	str	r2, [r3, #12]
  netif->output = netif_null_output_ip4;
 800982e:	68fb      	ldr	r3, [r7, #12]
 8009830:	4a46      	ldr	r2, [pc, #280]	; (800994c <netif_add+0x180>)
 8009832:	615a      	str	r2, [r3, #20]
#endif /* LWIP_IPV6_ADDRESS_LIFETIMES */
  }
  netif->output_ip6 = netif_null_output_ip6;
#endif /* LWIP_IPV6 */
  NETIF_SET_CHECKSUM_CTRL(netif, NETIF_CHECKSUM_ENABLE_ALL);
  netif->mtu = 0;
 8009834:	68fb      	ldr	r3, [r7, #12]
 8009836:	2200      	movs	r2, #0
 8009838:	851a      	strh	r2, [r3, #40]	; 0x28
  netif->flags = 0;
 800983a:	68fb      	ldr	r3, [r7, #12]
 800983c:	2231      	movs	r2, #49	; 0x31
 800983e:	2100      	movs	r1, #0
 8009840:	5499      	strb	r1, [r3, r2]
  netif->ip6_autoconfig_enabled = 0;
#endif /* LWIP_IPV6_AUTOCONFIG */
  nd6_restart_netif(netif);
#endif /* LWIP_IPV6 */
#if LWIP_NETIF_STATUS_CALLBACK
  netif->status_callback = NULL;
 8009842:	68fb      	ldr	r3, [r7, #12]
 8009844:	2200      	movs	r2, #0
 8009846:	61da      	str	r2, [r3, #28]
#endif /* LWIP_NETIF_STATUS_CALLBACK */
#if LWIP_NETIF_LINK_CALLBACK
  netif->link_callback = NULL;
 8009848:	68fb      	ldr	r3, [r7, #12]
 800984a:	2200      	movs	r2, #0
 800984c:	621a      	str	r2, [r3, #32]
#if LWIP_IPV6 && LWIP_IPV6_MLD
  netif->mld_mac_filter = NULL;
#endif /* LWIP_IPV6 && LWIP_IPV6_MLD */

  /* remember netif specific state information data */
  netif->state = state;
 800984e:	68fb      	ldr	r3, [r7, #12]
 8009850:	6a3a      	ldr	r2, [r7, #32]
 8009852:	625a      	str	r2, [r3, #36]	; 0x24
  netif->num = netif_num;
 8009854:	4b3e      	ldr	r3, [pc, #248]	; (8009950 <netif_add+0x184>)
 8009856:	7819      	ldrb	r1, [r3, #0]
 8009858:	68fb      	ldr	r3, [r7, #12]
 800985a:	2234      	movs	r2, #52	; 0x34
 800985c:	5499      	strb	r1, [r3, r2]
  netif->input = input;
 800985e:	68fb      	ldr	r3, [r7, #12]
 8009860:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8009862:	611a      	str	r2, [r3, #16]

  NETIF_RESET_HINTS(netif);
 8009864:	68fb      	ldr	r3, [r7, #12]
 8009866:	2200      	movs	r2, #0
 8009868:	639a      	str	r2, [r3, #56]	; 0x38
  netif->reschedule_poll = 0;
#endif /* LWIP_NETIF_LOOPBACK_MULTITHREADING */
#endif /* ENABLE_LOOPBACK */

#if LWIP_IPV4
  netif_set_addr(netif, ipaddr, netmask, gw);
 800986a:	683b      	ldr	r3, [r7, #0]
 800986c:	687a      	ldr	r2, [r7, #4]
 800986e:	68b9      	ldr	r1, [r7, #8]
 8009870:	68f8      	ldr	r0, [r7, #12]
 8009872:	f000 f91d 	bl	8009ab0 <netif_set_addr>
#endif /* LWIP_IPV4 */

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
 8009876:	68fa      	ldr	r2, [r7, #12]
 8009878:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800987a:	0010      	movs	r0, r2
 800987c:	4798      	blx	r3
 800987e:	1e03      	subs	r3, r0, #0
 8009880:	d001      	beq.n	8009886 <netif_add+0xba>
    return NULL;
 8009882:	2300      	movs	r3, #0
 8009884:	e058      	b.n	8009938 <netif_add+0x16c>
     */
  {
    struct netif *netif2;
    int num_netifs;
    do {
      if (netif->num == 255) {
 8009886:	68fb      	ldr	r3, [r7, #12]
 8009888:	2234      	movs	r2, #52	; 0x34
 800988a:	5c9b      	ldrb	r3, [r3, r2]
 800988c:	2bff      	cmp	r3, #255	; 0xff
 800988e:	d103      	bne.n	8009898 <netif_add+0xcc>
        netif->num = 0;
 8009890:	68fb      	ldr	r3, [r7, #12]
 8009892:	2234      	movs	r2, #52	; 0x34
 8009894:	2100      	movs	r1, #0
 8009896:	5499      	strb	r1, [r3, r2]
      }
      num_netifs = 0;
 8009898:	2300      	movs	r3, #0
 800989a:	613b      	str	r3, [r7, #16]
      for (netif2 = netif_list; netif2 != NULL; netif2 = netif2->next) {
 800989c:	4b2d      	ldr	r3, [pc, #180]	; (8009954 <netif_add+0x188>)
 800989e:	681b      	ldr	r3, [r3, #0]
 80098a0:	617b      	str	r3, [r7, #20]
 80098a2:	e02b      	b.n	80098fc <netif_add+0x130>
        LWIP_ASSERT("netif already added", netif2 != netif);
 80098a4:	697a      	ldr	r2, [r7, #20]
 80098a6:	68fb      	ldr	r3, [r7, #12]
 80098a8:	429a      	cmp	r2, r3
 80098aa:	d106      	bne.n	80098ba <netif_add+0xee>
 80098ac:	4b2a      	ldr	r3, [pc, #168]	; (8009958 <netif_add+0x18c>)
 80098ae:	22c7      	movs	r2, #199	; 0xc7
 80098b0:	0052      	lsls	r2, r2, #1
 80098b2:	492a      	ldr	r1, [pc, #168]	; (800995c <netif_add+0x190>)
 80098b4:	482a      	ldr	r0, [pc, #168]	; (8009960 <netif_add+0x194>)
 80098b6:	f7f8 fc95 	bl	80021e4 <app_debug_rtt_raw>
        num_netifs++;
 80098ba:	693b      	ldr	r3, [r7, #16]
 80098bc:	3301      	adds	r3, #1
 80098be:	613b      	str	r3, [r7, #16]
        LWIP_ASSERT("too many netifs, max. supported number is 255", num_netifs <= 255);
 80098c0:	693b      	ldr	r3, [r7, #16]
 80098c2:	2bff      	cmp	r3, #255	; 0xff
 80098c4:	dd06      	ble.n	80098d4 <netif_add+0x108>
 80098c6:	4b24      	ldr	r3, [pc, #144]	; (8009958 <netif_add+0x18c>)
 80098c8:	22c8      	movs	r2, #200	; 0xc8
 80098ca:	0052      	lsls	r2, r2, #1
 80098cc:	4925      	ldr	r1, [pc, #148]	; (8009964 <netif_add+0x198>)
 80098ce:	4824      	ldr	r0, [pc, #144]	; (8009960 <netif_add+0x194>)
 80098d0:	f7f8 fc88 	bl	80021e4 <app_debug_rtt_raw>
        if (netif2->num == netif->num) {
 80098d4:	697b      	ldr	r3, [r7, #20]
 80098d6:	2234      	movs	r2, #52	; 0x34
 80098d8:	5c9a      	ldrb	r2, [r3, r2]
 80098da:	68fb      	ldr	r3, [r7, #12]
 80098dc:	2134      	movs	r1, #52	; 0x34
 80098de:	5c5b      	ldrb	r3, [r3, r1]
 80098e0:	429a      	cmp	r2, r3
 80098e2:	d108      	bne.n	80098f6 <netif_add+0x12a>
          netif->num++;
 80098e4:	68fb      	ldr	r3, [r7, #12]
 80098e6:	2234      	movs	r2, #52	; 0x34
 80098e8:	5c9b      	ldrb	r3, [r3, r2]
 80098ea:	3301      	adds	r3, #1
 80098ec:	b2d9      	uxtb	r1, r3
 80098ee:	68fb      	ldr	r3, [r7, #12]
 80098f0:	2234      	movs	r2, #52	; 0x34
 80098f2:	5499      	strb	r1, [r3, r2]
          break;
 80098f4:	e005      	b.n	8009902 <netif_add+0x136>
      for (netif2 = netif_list; netif2 != NULL; netif2 = netif2->next) {
 80098f6:	697b      	ldr	r3, [r7, #20]
 80098f8:	681b      	ldr	r3, [r3, #0]
 80098fa:	617b      	str	r3, [r7, #20]
 80098fc:	697b      	ldr	r3, [r7, #20]
 80098fe:	2b00      	cmp	r3, #0
 8009900:	d1d0      	bne.n	80098a4 <netif_add+0xd8>
        }
      }
    } while (netif2 != NULL);
 8009902:	697b      	ldr	r3, [r7, #20]
 8009904:	2b00      	cmp	r3, #0
 8009906:	d1be      	bne.n	8009886 <netif_add+0xba>
  }
  if (netif->num == 254) {
 8009908:	68fb      	ldr	r3, [r7, #12]
 800990a:	2234      	movs	r2, #52	; 0x34
 800990c:	5c9b      	ldrb	r3, [r3, r2]
 800990e:	2bfe      	cmp	r3, #254	; 0xfe
 8009910:	d103      	bne.n	800991a <netif_add+0x14e>
    netif_num = 0;
 8009912:	4b0f      	ldr	r3, [pc, #60]	; (8009950 <netif_add+0x184>)
 8009914:	2200      	movs	r2, #0
 8009916:	701a      	strb	r2, [r3, #0]
 8009918:	e006      	b.n	8009928 <netif_add+0x15c>
  } else {
    netif_num = (u8_t)(netif->num + 1);
 800991a:	68fb      	ldr	r3, [r7, #12]
 800991c:	2234      	movs	r2, #52	; 0x34
 800991e:	5c9b      	ldrb	r3, [r3, r2]
 8009920:	3301      	adds	r3, #1
 8009922:	b2da      	uxtb	r2, r3
 8009924:	4b0a      	ldr	r3, [pc, #40]	; (8009950 <netif_add+0x184>)
 8009926:	701a      	strb	r2, [r3, #0]
  }

  /* add this netif to the list */
  netif->next = netif_list;
 8009928:	4b0a      	ldr	r3, [pc, #40]	; (8009954 <netif_add+0x188>)
 800992a:	681a      	ldr	r2, [r3, #0]
 800992c:	68fb      	ldr	r3, [r7, #12]
 800992e:	601a      	str	r2, [r3, #0]
  netif_list = netif;
 8009930:	4b08      	ldr	r3, [pc, #32]	; (8009954 <netif_add+0x188>)
 8009932:	68fa      	ldr	r2, [r7, #12]
 8009934:	601a      	str	r2, [r3, #0]
#endif /* LWIP_IPV4 */
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));

  netif_invoke_ext_callback(netif, LWIP_NSC_NETIF_ADDED, NULL);

  return netif;
 8009936:	68fb      	ldr	r3, [r7, #12]
}
 8009938:	0018      	movs	r0, r3
 800993a:	46bd      	mov	sp, r7
 800993c:	b006      	add	sp, #24
 800993e:	bd80      	pop	{r7, pc}
 8009940:	08020378 	.word	0x08020378
 8009944:	08020394 	.word	0x08020394
 8009948:	08023a8c 	.word	0x08023a8c
 800994c:	08009d5d 	.word	0x08009d5d
 8009950:	20000c44 	.word	0x20000c44
 8009954:	2000277c 	.word	0x2000277c
 8009958:	080202ec 	.word	0x080202ec
 800995c:	080203b8 	.word	0x080203b8
 8009960:	08020330 	.word	0x08020330
 8009964:	080203cc 	.word	0x080203cc

08009968 <netif_do_ip_addr_changed>:

static void
netif_do_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_addr)
{
 8009968:	b580      	push	{r7, lr}
 800996a:	b082      	sub	sp, #8
 800996c:	af00      	add	r7, sp, #0
 800996e:	6078      	str	r0, [r7, #4]
 8009970:	6039      	str	r1, [r7, #0]
#if LWIP_TCP
  tcp_netif_ip_addr_changed(old_addr, new_addr);
 8009972:	683a      	ldr	r2, [r7, #0]
 8009974:	687b      	ldr	r3, [r7, #4]
 8009976:	0011      	movs	r1, r2
 8009978:	0018      	movs	r0, r3
 800997a:	f003 fa6b 	bl	800ce54 <tcp_netif_ip_addr_changed>
#endif /* LWIP_TCP */
#if LWIP_UDP
  udp_netif_ip_addr_changed(old_addr, new_addr);
 800997e:	683a      	ldr	r2, [r7, #0]
 8009980:	687b      	ldr	r3, [r7, #4]
 8009982:	0011      	movs	r1, r2
 8009984:	0018      	movs	r0, r3
 8009986:	f009 feb3 	bl	80136f0 <udp_netif_ip_addr_changed>
#endif /* LWIP_UDP */
#if LWIP_RAW
  raw_netif_ip_addr_changed(old_addr, new_addr);
#endif /* LWIP_RAW */
}
 800998a:	46c0      	nop			; (mov r8, r8)
 800998c:	46bd      	mov	sp, r7
 800998e:	b002      	add	sp, #8
 8009990:	bd80      	pop	{r7, pc}
	...

08009994 <netif_do_set_ipaddr>:

#if LWIP_IPV4
static int
netif_do_set_ipaddr(struct netif *netif, const ip4_addr_t *ipaddr, ip_addr_t *old_addr)
{
 8009994:	b580      	push	{r7, lr}
 8009996:	b086      	sub	sp, #24
 8009998:	af00      	add	r7, sp, #0
 800999a:	60f8      	str	r0, [r7, #12]
 800999c:	60b9      	str	r1, [r7, #8]
 800999e:	607a      	str	r2, [r7, #4]
  LWIP_ASSERT("invalid pointer", ipaddr != NULL);
 80099a0:	68bb      	ldr	r3, [r7, #8]
 80099a2:	2b00      	cmp	r3, #0
 80099a4:	d106      	bne.n	80099b4 <netif_do_set_ipaddr+0x20>
 80099a6:	4b22      	ldr	r3, [pc, #136]	; (8009a30 <netif_do_set_ipaddr+0x9c>)
 80099a8:	22e7      	movs	r2, #231	; 0xe7
 80099aa:	0052      	lsls	r2, r2, #1
 80099ac:	4921      	ldr	r1, [pc, #132]	; (8009a34 <netif_do_set_ipaddr+0xa0>)
 80099ae:	4822      	ldr	r0, [pc, #136]	; (8009a38 <netif_do_set_ipaddr+0xa4>)
 80099b0:	f7f8 fc18 	bl	80021e4 <app_debug_rtt_raw>
  LWIP_ASSERT("invalid pointer", old_addr != NULL);
 80099b4:	687b      	ldr	r3, [r7, #4]
 80099b6:	2b00      	cmp	r3, #0
 80099b8:	d106      	bne.n	80099c8 <netif_do_set_ipaddr+0x34>
 80099ba:	4b1d      	ldr	r3, [pc, #116]	; (8009a30 <netif_do_set_ipaddr+0x9c>)
 80099bc:	22d0      	movs	r2, #208	; 0xd0
 80099be:	32ff      	adds	r2, #255	; 0xff
 80099c0:	491c      	ldr	r1, [pc, #112]	; (8009a34 <netif_do_set_ipaddr+0xa0>)
 80099c2:	481d      	ldr	r0, [pc, #116]	; (8009a38 <netif_do_set_ipaddr+0xa4>)
 80099c4:	f7f8 fc0e 	bl	80021e4 <app_debug_rtt_raw>

  /* address is actually being changed? */
  if (ip4_addr_cmp(ipaddr, netif_ip4_addr(netif)) == 0) {
 80099c8:	68bb      	ldr	r3, [r7, #8]
 80099ca:	681a      	ldr	r2, [r3, #0]
 80099cc:	68fb      	ldr	r3, [r7, #12]
 80099ce:	3304      	adds	r3, #4
 80099d0:	681b      	ldr	r3, [r3, #0]
 80099d2:	429a      	cmp	r2, r3
 80099d4:	d027      	beq.n	8009a26 <netif_do_set_ipaddr+0x92>
    ip_addr_t new_addr;
    *ip_2_ip4(&new_addr) = *ipaddr;
 80099d6:	68bb      	ldr	r3, [r7, #8]
 80099d8:	681b      	ldr	r3, [r3, #0]
 80099da:	617b      	str	r3, [r7, #20]
    IP_SET_TYPE_VAL(new_addr, IPADDR_TYPE_V4);

    ip_addr_copy(*old_addr, *netif_ip_addr4(netif));
 80099dc:	68fb      	ldr	r3, [r7, #12]
 80099de:	3304      	adds	r3, #4
 80099e0:	681a      	ldr	r2, [r3, #0]
 80099e2:	687b      	ldr	r3, [r7, #4]
 80099e4:	601a      	str	r2, [r3, #0]

    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    netif_do_ip_addr_changed(old_addr, &new_addr);
 80099e6:	2314      	movs	r3, #20
 80099e8:	18fa      	adds	r2, r7, r3
 80099ea:	687b      	ldr	r3, [r7, #4]
 80099ec:	0011      	movs	r1, r2
 80099ee:	0018      	movs	r0, r3
 80099f0:	f7ff ffba 	bl	8009968 <netif_do_ip_addr_changed>

    mib2_remove_ip4(netif);
    mib2_remove_route_ip4(0, netif);
    /* set new IP address to netif */
    ip4_addr_set(ip_2_ip4(&netif->ip_addr), ipaddr);
 80099f4:	68bb      	ldr	r3, [r7, #8]
 80099f6:	2b00      	cmp	r3, #0
 80099f8:	d002      	beq.n	8009a00 <netif_do_set_ipaddr+0x6c>
 80099fa:	68bb      	ldr	r3, [r7, #8]
 80099fc:	681a      	ldr	r2, [r3, #0]
 80099fe:	e000      	b.n	8009a02 <netif_do_set_ipaddr+0x6e>
 8009a00:	2200      	movs	r2, #0
 8009a02:	68fb      	ldr	r3, [r7, #12]
 8009a04:	605a      	str	r2, [r3, #4]
    IP_SET_TYPE_VAL(netif->ip_addr, IPADDR_TYPE_V4);
    mib2_add_ip4(netif);
    mib2_add_route_ip4(0, netif);

    netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4);
 8009a06:	68fb      	ldr	r3, [r7, #12]
 8009a08:	2101      	movs	r1, #1
 8009a0a:	0018      	movs	r0, r3
 8009a0c:	f000 f8f8 	bl	8009c00 <netif_issue_reports>

    NETIF_STATUS_CALLBACK(netif);
 8009a10:	68fb      	ldr	r3, [r7, #12]
 8009a12:	69db      	ldr	r3, [r3, #28]
 8009a14:	2b00      	cmp	r3, #0
 8009a16:	d004      	beq.n	8009a22 <netif_do_set_ipaddr+0x8e>
 8009a18:	68fb      	ldr	r3, [r7, #12]
 8009a1a:	69db      	ldr	r3, [r3, #28]
 8009a1c:	68fa      	ldr	r2, [r7, #12]
 8009a1e:	0010      	movs	r0, r2
 8009a20:	4798      	blx	r3
    return 1; /* address changed */
 8009a22:	2301      	movs	r3, #1
 8009a24:	e000      	b.n	8009a28 <netif_do_set_ipaddr+0x94>
  }
  return 0; /* address unchanged */
 8009a26:	2300      	movs	r3, #0
}
 8009a28:	0018      	movs	r0, r3
 8009a2a:	46bd      	mov	sp, r7
 8009a2c:	b006      	add	sp, #24
 8009a2e:	bd80      	pop	{r7, pc}
 8009a30:	080202ec 	.word	0x080202ec
 8009a34:	080203fc 	.word	0x080203fc
 8009a38:	08020330 	.word	0x08020330

08009a3c <netif_do_set_netmask>:
  }
}

static int
netif_do_set_netmask(struct netif *netif, const ip4_addr_t *netmask, ip_addr_t *old_nm)
{
 8009a3c:	b580      	push	{r7, lr}
 8009a3e:	b084      	sub	sp, #16
 8009a40:	af00      	add	r7, sp, #0
 8009a42:	60f8      	str	r0, [r7, #12]
 8009a44:	60b9      	str	r1, [r7, #8]
 8009a46:	607a      	str	r2, [r7, #4]
  /* address is actually being changed? */
  if (ip4_addr_cmp(netmask, netif_ip4_netmask(netif)) == 0) {
 8009a48:	68bb      	ldr	r3, [r7, #8]
 8009a4a:	681a      	ldr	r2, [r3, #0]
 8009a4c:	68fb      	ldr	r3, [r7, #12]
 8009a4e:	3308      	adds	r3, #8
 8009a50:	681b      	ldr	r3, [r3, #0]
 8009a52:	429a      	cmp	r2, r3
 8009a54:	d00a      	beq.n	8009a6c <netif_do_set_netmask+0x30>
#else
    LWIP_UNUSED_ARG(old_nm);
#endif
    mib2_remove_route_ip4(0, netif);
    /* set new netmask to netif */
    ip4_addr_set(ip_2_ip4(&netif->netmask), netmask);
 8009a56:	68bb      	ldr	r3, [r7, #8]
 8009a58:	2b00      	cmp	r3, #0
 8009a5a:	d002      	beq.n	8009a62 <netif_do_set_netmask+0x26>
 8009a5c:	68bb      	ldr	r3, [r7, #8]
 8009a5e:	681a      	ldr	r2, [r3, #0]
 8009a60:	e000      	b.n	8009a64 <netif_do_set_netmask+0x28>
 8009a62:	2200      	movs	r2, #0
 8009a64:	68fb      	ldr	r3, [r7, #12]
 8009a66:	609a      	str	r2, [r3, #8]
                netif->name[0], netif->name[1],
                ip4_addr1_16(netif_ip4_netmask(netif)),
                ip4_addr2_16(netif_ip4_netmask(netif)),
                ip4_addr3_16(netif_ip4_netmask(netif)),
                ip4_addr4_16(netif_ip4_netmask(netif))));
    return 1; /* netmask changed */
 8009a68:	2301      	movs	r3, #1
 8009a6a:	e000      	b.n	8009a6e <netif_do_set_netmask+0x32>
  }
  return 0; /* netmask unchanged */
 8009a6c:	2300      	movs	r3, #0
}
 8009a6e:	0018      	movs	r0, r3
 8009a70:	46bd      	mov	sp, r7
 8009a72:	b004      	add	sp, #16
 8009a74:	bd80      	pop	{r7, pc}

08009a76 <netif_do_set_gw>:
  }
}

static int
netif_do_set_gw(struct netif *netif, const ip4_addr_t *gw, ip_addr_t *old_gw)
{
 8009a76:	b580      	push	{r7, lr}
 8009a78:	b084      	sub	sp, #16
 8009a7a:	af00      	add	r7, sp, #0
 8009a7c:	60f8      	str	r0, [r7, #12]
 8009a7e:	60b9      	str	r1, [r7, #8]
 8009a80:	607a      	str	r2, [r7, #4]
  /* address is actually being changed? */
  if (ip4_addr_cmp(gw, netif_ip4_gw(netif)) == 0) {
 8009a82:	68bb      	ldr	r3, [r7, #8]
 8009a84:	681a      	ldr	r2, [r3, #0]
 8009a86:	68fb      	ldr	r3, [r7, #12]
 8009a88:	330c      	adds	r3, #12
 8009a8a:	681b      	ldr	r3, [r3, #0]
 8009a8c:	429a      	cmp	r2, r3
 8009a8e:	d00a      	beq.n	8009aa6 <netif_do_set_gw+0x30>
    ip_addr_copy(*old_gw, *netif_ip_gw4(netif));
#else
    LWIP_UNUSED_ARG(old_gw);
#endif

    ip4_addr_set(ip_2_ip4(&netif->gw), gw);
 8009a90:	68bb      	ldr	r3, [r7, #8]
 8009a92:	2b00      	cmp	r3, #0
 8009a94:	d002      	beq.n	8009a9c <netif_do_set_gw+0x26>
 8009a96:	68bb      	ldr	r3, [r7, #8]
 8009a98:	681a      	ldr	r2, [r3, #0]
 8009a9a:	e000      	b.n	8009a9e <netif_do_set_gw+0x28>
 8009a9c:	2200      	movs	r2, #0
 8009a9e:	68fb      	ldr	r3, [r7, #12]
 8009aa0:	60da      	str	r2, [r3, #12]
                netif->name[0], netif->name[1],
                ip4_addr1_16(netif_ip4_gw(netif)),
                ip4_addr2_16(netif_ip4_gw(netif)),
                ip4_addr3_16(netif_ip4_gw(netif)),
                ip4_addr4_16(netif_ip4_gw(netif))));
    return 1; /* gateway changed */
 8009aa2:	2301      	movs	r3, #1
 8009aa4:	e000      	b.n	8009aa8 <netif_do_set_gw+0x32>
  }
  return 0; /* gateway unchanged */
 8009aa6:	2300      	movs	r3, #0
}
 8009aa8:	0018      	movs	r0, r3
 8009aaa:	46bd      	mov	sp, r7
 8009aac:	b004      	add	sp, #16
 8009aae:	bd80      	pop	{r7, pc}

08009ab0 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, const ip4_addr_t *ipaddr, const ip4_addr_t *netmask,
               const ip4_addr_t *gw)
{
 8009ab0:	b580      	push	{r7, lr}
 8009ab2:	b088      	sub	sp, #32
 8009ab4:	af00      	add	r7, sp, #0
 8009ab6:	60f8      	str	r0, [r7, #12]
 8009ab8:	60b9      	str	r1, [r7, #8]
 8009aba:	607a      	str	r2, [r7, #4]
 8009abc:	603b      	str	r3, [r7, #0]
  ip_addr_t old_nm_val;
  ip_addr_t old_gw_val;
  ip_addr_t *old_nm = &old_nm_val;
  ip_addr_t *old_gw = &old_gw_val;
#else
  ip_addr_t *old_nm = NULL;
 8009abe:	2300      	movs	r3, #0
 8009ac0:	61fb      	str	r3, [r7, #28]
  ip_addr_t *old_gw = NULL;
 8009ac2:	2300      	movs	r3, #0
 8009ac4:	61bb      	str	r3, [r7, #24]
  int remove;

  LWIP_ASSERT_CORE_LOCKED();

  /* Don't propagate NULL pointer (IPv4 ANY) to subsequent functions */
  if (ipaddr == NULL) {
 8009ac6:	68bb      	ldr	r3, [r7, #8]
 8009ac8:	2b00      	cmp	r3, #0
 8009aca:	d101      	bne.n	8009ad0 <netif_set_addr+0x20>
    ipaddr = IP4_ADDR_ANY4;
 8009acc:	4b1d      	ldr	r3, [pc, #116]	; (8009b44 <netif_set_addr+0x94>)
 8009ace:	60bb      	str	r3, [r7, #8]
  }
  if (netmask == NULL) {
 8009ad0:	687b      	ldr	r3, [r7, #4]
 8009ad2:	2b00      	cmp	r3, #0
 8009ad4:	d101      	bne.n	8009ada <netif_set_addr+0x2a>
    netmask = IP4_ADDR_ANY4;
 8009ad6:	4b1b      	ldr	r3, [pc, #108]	; (8009b44 <netif_set_addr+0x94>)
 8009ad8:	607b      	str	r3, [r7, #4]
  }
  if (gw == NULL) {
 8009ada:	683b      	ldr	r3, [r7, #0]
 8009adc:	2b00      	cmp	r3, #0
 8009ade:	d101      	bne.n	8009ae4 <netif_set_addr+0x34>
    gw = IP4_ADDR_ANY4;
 8009ae0:	4b18      	ldr	r3, [pc, #96]	; (8009b44 <netif_set_addr+0x94>)
 8009ae2:	603b      	str	r3, [r7, #0]
  }

  remove = ip4_addr_isany(ipaddr);
 8009ae4:	68bb      	ldr	r3, [r7, #8]
 8009ae6:	2b00      	cmp	r3, #0
 8009ae8:	d003      	beq.n	8009af2 <netif_set_addr+0x42>
 8009aea:	68bb      	ldr	r3, [r7, #8]
 8009aec:	681b      	ldr	r3, [r3, #0]
 8009aee:	2b00      	cmp	r3, #0
 8009af0:	d101      	bne.n	8009af6 <netif_set_addr+0x46>
 8009af2:	2301      	movs	r3, #1
 8009af4:	e000      	b.n	8009af8 <netif_set_addr+0x48>
 8009af6:	2300      	movs	r3, #0
 8009af8:	617b      	str	r3, [r7, #20]
  if (remove) {
 8009afa:	697b      	ldr	r3, [r7, #20]
 8009afc:	2b00      	cmp	r3, #0
 8009afe:	d006      	beq.n	8009b0e <netif_set_addr+0x5e>
    /* when removing an address, we have to remove it *before* changing netmask/gw
       to ensure that tcp RST segment can be sent correctly */
    if (netif_do_set_ipaddr(netif, ipaddr, &old_addr)) {
 8009b00:	2310      	movs	r3, #16
 8009b02:	18fa      	adds	r2, r7, r3
 8009b04:	68b9      	ldr	r1, [r7, #8]
 8009b06:	68fb      	ldr	r3, [r7, #12]
 8009b08:	0018      	movs	r0, r3
 8009b0a:	f7ff ff43 	bl	8009994 <netif_do_set_ipaddr>
      change_reason |= LWIP_NSC_IPV4_ADDRESS_CHANGED;
      cb_args.ipv4_changed.old_address = &old_addr;
#endif
    }
  }
  if (netif_do_set_netmask(netif, netmask, old_nm)) {
 8009b0e:	69fa      	ldr	r2, [r7, #28]
 8009b10:	6879      	ldr	r1, [r7, #4]
 8009b12:	68fb      	ldr	r3, [r7, #12]
 8009b14:	0018      	movs	r0, r3
 8009b16:	f7ff ff91 	bl	8009a3c <netif_do_set_netmask>
#if LWIP_NETIF_EXT_STATUS_CALLBACK
    change_reason |= LWIP_NSC_IPV4_NETMASK_CHANGED;
    cb_args.ipv4_changed.old_netmask = old_nm;
#endif
  }
  if (netif_do_set_gw(netif, gw, old_gw)) {
 8009b1a:	69ba      	ldr	r2, [r7, #24]
 8009b1c:	6839      	ldr	r1, [r7, #0]
 8009b1e:	68fb      	ldr	r3, [r7, #12]
 8009b20:	0018      	movs	r0, r3
 8009b22:	f7ff ffa8 	bl	8009a76 <netif_do_set_gw>
#if LWIP_NETIF_EXT_STATUS_CALLBACK
    change_reason |= LWIP_NSC_IPV4_GATEWAY_CHANGED;
    cb_args.ipv4_changed.old_gw = old_gw;
#endif
  }
  if (!remove) {
 8009b26:	697b      	ldr	r3, [r7, #20]
 8009b28:	2b00      	cmp	r3, #0
 8009b2a:	d106      	bne.n	8009b3a <netif_set_addr+0x8a>
    /* set ipaddr last to ensure netmask/gw have been set when status callback is called */
    if (netif_do_set_ipaddr(netif, ipaddr, &old_addr)) {
 8009b2c:	2310      	movs	r3, #16
 8009b2e:	18fa      	adds	r2, r7, r3
 8009b30:	68b9      	ldr	r1, [r7, #8]
 8009b32:	68fb      	ldr	r3, [r7, #12]
 8009b34:	0018      	movs	r0, r3
 8009b36:	f7ff ff2d 	bl	8009994 <netif_do_set_ipaddr>
  if (change_reason != LWIP_NSC_NONE) {
    change_reason |= LWIP_NSC_IPV4_SETTINGS_CHANGED;
    netif_invoke_ext_callback(netif, change_reason, &cb_args);
  }
#endif
}
 8009b3a:	46c0      	nop			; (mov r8, r8)
 8009b3c:	46bd      	mov	sp, r7
 8009b3e:	b008      	add	sp, #32
 8009b40:	bd80      	pop	{r7, pc}
 8009b42:	46c0      	nop			; (mov r8, r8)
 8009b44:	08023a8c 	.word	0x08023a8c

08009b48 <netif_remove>:
 *
 * @param netif the network interface to remove
 */
void
netif_remove(struct netif *netif)
{
 8009b48:	b580      	push	{r7, lr}
 8009b4a:	b084      	sub	sp, #16
 8009b4c:	af00      	add	r7, sp, #0
 8009b4e:	6078      	str	r0, [r7, #4]
  int i;
#endif

  LWIP_ASSERT_CORE_LOCKED();

  if (netif == NULL) {
 8009b50:	687b      	ldr	r3, [r7, #4]
 8009b52:	2b00      	cmp	r3, #0
 8009b54:	d03e      	beq.n	8009bd4 <netif_remove+0x8c>
  }

  netif_invoke_ext_callback(netif, LWIP_NSC_NETIF_REMOVED, NULL);

#if LWIP_IPV4
  if (!ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 8009b56:	687b      	ldr	r3, [r7, #4]
 8009b58:	3304      	adds	r3, #4
 8009b5a:	681b      	ldr	r3, [r3, #0]
 8009b5c:	2b00      	cmp	r3, #0
 8009b5e:	d005      	beq.n	8009b6c <netif_remove+0x24>
    netif_do_ip_addr_changed(netif_ip_addr4(netif), NULL);
 8009b60:	687b      	ldr	r3, [r7, #4]
 8009b62:	3304      	adds	r3, #4
 8009b64:	2100      	movs	r1, #0
 8009b66:	0018      	movs	r0, r3
 8009b68:	f7ff fefe 	bl	8009968 <netif_do_ip_addr_changed>
#if LWIP_IPV6_MLD
  /* stop MLD processing */
  mld6_stop(netif);
#endif /* LWIP_IPV6_MLD */
#endif /* LWIP_IPV6 */
  if (netif_is_up(netif)) {
 8009b6c:	687b      	ldr	r3, [r7, #4]
 8009b6e:	2231      	movs	r2, #49	; 0x31
 8009b70:	5c9b      	ldrb	r3, [r3, r2]
 8009b72:	1c1a      	adds	r2, r3, #0
 8009b74:	2301      	movs	r3, #1
 8009b76:	4013      	ands	r3, r2
 8009b78:	b2db      	uxtb	r3, r3
 8009b7a:	2b00      	cmp	r3, #0
 8009b7c:	d003      	beq.n	8009b86 <netif_remove+0x3e>
    /* set netif down before removing (call callback function) */
    netif_set_down(netif);
 8009b7e:	687b      	ldr	r3, [r7, #4]
 8009b80:	0018      	movs	r0, r3
 8009b82:	f000 f867 	bl	8009c54 <netif_set_down>
  }

  mib2_remove_ip4(netif);

  /* this netif is default? */
  if (netif_default == netif) {
 8009b86:	4b15      	ldr	r3, [pc, #84]	; (8009bdc <netif_remove+0x94>)
 8009b88:	681b      	ldr	r3, [r3, #0]
 8009b8a:	687a      	ldr	r2, [r7, #4]
 8009b8c:	429a      	cmp	r2, r3
 8009b8e:	d102      	bne.n	8009b96 <netif_remove+0x4e>
    /* reset default netif */
    netif_set_default(NULL);
 8009b90:	2000      	movs	r0, #0
 8009b92:	f000 f827 	bl	8009be4 <netif_set_default>
  }
#if !LWIP_SINGLE_NETIF
  /*  is it the first netif? */
  if (netif_list == netif) {
 8009b96:	4b12      	ldr	r3, [pc, #72]	; (8009be0 <netif_remove+0x98>)
 8009b98:	681b      	ldr	r3, [r3, #0]
 8009b9a:	687a      	ldr	r2, [r7, #4]
 8009b9c:	429a      	cmp	r2, r3
 8009b9e:	d104      	bne.n	8009baa <netif_remove+0x62>
    netif_list = netif->next;
 8009ba0:	687b      	ldr	r3, [r7, #4]
 8009ba2:	681a      	ldr	r2, [r3, #0]
 8009ba4:	4b0e      	ldr	r3, [pc, #56]	; (8009be0 <netif_remove+0x98>)
 8009ba6:	601a      	str	r2, [r3, #0]
 8009ba8:	e015      	b.n	8009bd6 <netif_remove+0x8e>
  } else {
    /*  look for netif further down the list */
    struct netif *tmp_netif;
    NETIF_FOREACH(tmp_netif) {
 8009baa:	4b0d      	ldr	r3, [pc, #52]	; (8009be0 <netif_remove+0x98>)
 8009bac:	681b      	ldr	r3, [r3, #0]
 8009bae:	60fb      	str	r3, [r7, #12]
 8009bb0:	e00c      	b.n	8009bcc <netif_remove+0x84>
      if (tmp_netif->next == netif) {
 8009bb2:	68fb      	ldr	r3, [r7, #12]
 8009bb4:	681b      	ldr	r3, [r3, #0]
 8009bb6:	687a      	ldr	r2, [r7, #4]
 8009bb8:	429a      	cmp	r2, r3
 8009bba:	d104      	bne.n	8009bc6 <netif_remove+0x7e>
        tmp_netif->next = netif->next;
 8009bbc:	687b      	ldr	r3, [r7, #4]
 8009bbe:	681a      	ldr	r2, [r3, #0]
 8009bc0:	68fb      	ldr	r3, [r7, #12]
 8009bc2:	601a      	str	r2, [r3, #0]
        break;
 8009bc4:	e007      	b.n	8009bd6 <netif_remove+0x8e>
    NETIF_FOREACH(tmp_netif) {
 8009bc6:	68fb      	ldr	r3, [r7, #12]
 8009bc8:	681b      	ldr	r3, [r3, #0]
 8009bca:	60fb      	str	r3, [r7, #12]
 8009bcc:	68fb      	ldr	r3, [r7, #12]
 8009bce:	2b00      	cmp	r3, #0
 8009bd0:	d1ef      	bne.n	8009bb2 <netif_remove+0x6a>
 8009bd2:	e000      	b.n	8009bd6 <netif_remove+0x8e>
    return;
 8009bd4:	46c0      	nop			; (mov r8, r8)
  if (netif->remove_callback) {
    netif->remove_callback(netif);
  }
#endif /* LWIP_NETIF_REMOVE_CALLBACK */
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
 8009bd6:	46bd      	mov	sp, r7
 8009bd8:	b004      	add	sp, #16
 8009bda:	bd80      	pop	{r7, pc}
 8009bdc:	20002780 	.word	0x20002780
 8009be0:	2000277c 	.word	0x2000277c

08009be4 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
 8009be4:	b580      	push	{r7, lr}
 8009be6:	b082      	sub	sp, #8
 8009be8:	af00      	add	r7, sp, #0
 8009bea:	6078      	str	r0, [r7, #4]
    mib2_remove_route_ip4(1, netif);
  } else {
    /* install default route */
    mib2_add_route_ip4(1, netif);
  }
  netif_default = netif;
 8009bec:	4b03      	ldr	r3, [pc, #12]	; (8009bfc <netif_set_default+0x18>)
 8009bee:	687a      	ldr	r2, [r7, #4]
 8009bf0:	601a      	str	r2, [r3, #0]
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
                            netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
 8009bf2:	46c0      	nop			; (mov r8, r8)
 8009bf4:	46bd      	mov	sp, r7
 8009bf6:	b002      	add	sp, #8
 8009bf8:	bd80      	pop	{r7, pc}
 8009bfa:	46c0      	nop			; (mov r8, r8)
 8009bfc:	20002780 	.word	0x20002780

08009c00 <netif_issue_reports>:

/** Send ARP/IGMP/MLD/RS events, e.g. on link-up/netif-up or addr-change
 */
static void
netif_issue_reports(struct netif *netif, u8_t report_type)
{
 8009c00:	b580      	push	{r7, lr}
 8009c02:	b082      	sub	sp, #8
 8009c04:	af00      	add	r7, sp, #0
 8009c06:	6078      	str	r0, [r7, #4]
 8009c08:	000a      	movs	r2, r1
 8009c0a:	1cfb      	adds	r3, r7, #3
 8009c0c:	701a      	strb	r2, [r3, #0]
  LWIP_ASSERT("netif_issue_reports: invalid netif", netif != NULL);
 8009c0e:	687b      	ldr	r3, [r7, #4]
 8009c10:	2b00      	cmp	r3, #0
 8009c12:	d106      	bne.n	8009c22 <netif_issue_reports+0x22>
 8009c14:	4b0c      	ldr	r3, [pc, #48]	; (8009c48 <netif_issue_reports+0x48>)
 8009c16:	22dc      	movs	r2, #220	; 0xdc
 8009c18:	0092      	lsls	r2, r2, #2
 8009c1a:	490c      	ldr	r1, [pc, #48]	; (8009c4c <netif_issue_reports+0x4c>)
 8009c1c:	480c      	ldr	r0, [pc, #48]	; (8009c50 <netif_issue_reports+0x50>)
 8009c1e:	f7f8 fae1 	bl	80021e4 <app_debug_rtt_raw>

  /* Only send reports when both link and admin states are up */
  if (!(netif->flags & NETIF_FLAG_LINK_UP) ||
 8009c22:	687b      	ldr	r3, [r7, #4]
 8009c24:	2231      	movs	r2, #49	; 0x31
 8009c26:	5c9b      	ldrb	r3, [r3, r2]
 8009c28:	001a      	movs	r2, r3
 8009c2a:	2304      	movs	r3, #4
 8009c2c:	4013      	ands	r3, r2
 8009c2e:	d007      	beq.n	8009c40 <netif_issue_reports+0x40>
      !(netif->flags & NETIF_FLAG_UP)) {
 8009c30:	687b      	ldr	r3, [r7, #4]
 8009c32:	2231      	movs	r2, #49	; 0x31
 8009c34:	5c9b      	ldrb	r3, [r3, r2]
 8009c36:	001a      	movs	r2, r3
 8009c38:	2301      	movs	r3, #1
 8009c3a:	4013      	ands	r3, r2
  if (!(netif->flags & NETIF_FLAG_LINK_UP) ||
 8009c3c:	d000      	beq.n	8009c40 <netif_issue_reports+0x40>
 8009c3e:	e000      	b.n	8009c42 <netif_issue_reports+0x42>
    return;
 8009c40:	46c0      	nop			; (mov r8, r8)
    /* send mld memberships */
    mld6_report_groups(netif);
#endif /* LWIP_IPV6_MLD */
  }
#endif /* LWIP_IPV6 */
}
 8009c42:	46bd      	mov	sp, r7
 8009c44:	b002      	add	sp, #8
 8009c46:	bd80      	pop	{r7, pc}
 8009c48:	080202ec 	.word	0x080202ec
 8009c4c:	08020488 	.word	0x08020488
 8009c50:	08020330 	.word	0x08020330

08009c54 <netif_set_down>:
 * @ingroup netif
 * Bring an interface down, disabling any traffic processing.
 */
void
netif_set_down(struct netif *netif)
{
 8009c54:	b580      	push	{r7, lr}
 8009c56:	b082      	sub	sp, #8
 8009c58:	af00      	add	r7, sp, #0
 8009c5a:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif_set_down: invalid netif", netif != NULL, return);
 8009c5c:	687b      	ldr	r3, [r7, #4]
 8009c5e:	2b00      	cmp	r3, #0
 8009c60:	d104      	bne.n	8009c6c <netif_set_down+0x18>
 8009c62:	4b10      	ldr	r3, [pc, #64]	; (8009ca4 <netif_set_down+0x50>)
 8009c64:	0018      	movs	r0, r3
 8009c66:	f7f8 fabd 	bl	80021e4 <app_debug_rtt_raw>
 8009c6a:	e018      	b.n	8009c9e <netif_set_down+0x4a>

  if (netif->flags & NETIF_FLAG_UP) {
 8009c6c:	687b      	ldr	r3, [r7, #4]
 8009c6e:	2231      	movs	r2, #49	; 0x31
 8009c70:	5c9b      	ldrb	r3, [r3, r2]
 8009c72:	001a      	movs	r2, r3
 8009c74:	2301      	movs	r3, #1
 8009c76:	4013      	ands	r3, r2
 8009c78:	d011      	beq.n	8009c9e <netif_set_down+0x4a>
      args.status_changed.state = 0;
      netif_invoke_ext_callback(netif, LWIP_NSC_STATUS_CHANGED, &args);
    }
#endif

    netif_clear_flags(netif, NETIF_FLAG_UP);
 8009c7a:	687b      	ldr	r3, [r7, #4]
 8009c7c:	2231      	movs	r2, #49	; 0x31
 8009c7e:	5c9b      	ldrb	r3, [r3, r2]
 8009c80:	2201      	movs	r2, #1
 8009c82:	4393      	bics	r3, r2
 8009c84:	b2d9      	uxtb	r1, r3
 8009c86:	687b      	ldr	r3, [r7, #4]
 8009c88:	2231      	movs	r2, #49	; 0x31
 8009c8a:	5499      	strb	r1, [r3, r2]

#if LWIP_IPV6
    nd6_cleanup_netif(netif);
#endif /* LWIP_IPV6 */

    NETIF_STATUS_CALLBACK(netif);
 8009c8c:	687b      	ldr	r3, [r7, #4]
 8009c8e:	69db      	ldr	r3, [r3, #28]
 8009c90:	2b00      	cmp	r3, #0
 8009c92:	d004      	beq.n	8009c9e <netif_set_down+0x4a>
 8009c94:	687b      	ldr	r3, [r7, #4]
 8009c96:	69db      	ldr	r3, [r3, #28]
 8009c98:	687a      	ldr	r2, [r7, #4]
 8009c9a:	0010      	movs	r0, r2
 8009c9c:	4798      	blx	r3
  }
}
 8009c9e:	46bd      	mov	sp, r7
 8009ca0:	b002      	add	sp, #8
 8009ca2:	bd80      	pop	{r7, pc}
 8009ca4:	080204ac 	.word	0x080204ac

08009ca8 <netif_set_link_up>:
 * @ingroup netif
 * Called by a driver when its link goes up
 */
void
netif_set_link_up(struct netif *netif)
{
 8009ca8:	b580      	push	{r7, lr}
 8009caa:	b082      	sub	sp, #8
 8009cac:	af00      	add	r7, sp, #0
 8009cae:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif_set_link_up: invalid netif", netif != NULL, return);
 8009cb0:	687b      	ldr	r3, [r7, #4]
 8009cb2:	2b00      	cmp	r3, #0
 8009cb4:	d104      	bne.n	8009cc0 <netif_set_link_up+0x18>
 8009cb6:	4b13      	ldr	r3, [pc, #76]	; (8009d04 <netif_set_link_up+0x5c>)
 8009cb8:	0018      	movs	r0, r3
 8009cba:	f7f8 fa93 	bl	80021e4 <app_debug_rtt_raw>
 8009cbe:	e01d      	b.n	8009cfc <netif_set_link_up+0x54>

  if (!(netif->flags & NETIF_FLAG_LINK_UP)) {
 8009cc0:	687b      	ldr	r3, [r7, #4]
 8009cc2:	2231      	movs	r2, #49	; 0x31
 8009cc4:	5c9b      	ldrb	r3, [r3, r2]
 8009cc6:	001a      	movs	r2, r3
 8009cc8:	2304      	movs	r3, #4
 8009cca:	4013      	ands	r3, r2
 8009ccc:	d116      	bne.n	8009cfc <netif_set_link_up+0x54>
    netif_set_flags(netif, NETIF_FLAG_LINK_UP);
 8009cce:	687b      	ldr	r3, [r7, #4]
 8009cd0:	2231      	movs	r2, #49	; 0x31
 8009cd2:	5c9b      	ldrb	r3, [r3, r2]
 8009cd4:	2204      	movs	r2, #4
 8009cd6:	4313      	orrs	r3, r2
 8009cd8:	b2d9      	uxtb	r1, r3
 8009cda:	687b      	ldr	r3, [r7, #4]
 8009cdc:	2231      	movs	r2, #49	; 0x31
 8009cde:	5499      	strb	r1, [r3, r2]

#if LWIP_AUTOIP
    autoip_network_changed(netif);
#endif /* LWIP_AUTOIP */

    netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4 | NETIF_REPORT_TYPE_IPV6);
 8009ce0:	687b      	ldr	r3, [r7, #4]
 8009ce2:	2103      	movs	r1, #3
 8009ce4:	0018      	movs	r0, r3
 8009ce6:	f7ff ff8b 	bl	8009c00 <netif_issue_reports>
#if LWIP_IPV6
    nd6_restart_netif(netif);
#endif /* LWIP_IPV6 */

    NETIF_LINK_CALLBACK(netif);
 8009cea:	687b      	ldr	r3, [r7, #4]
 8009cec:	6a1b      	ldr	r3, [r3, #32]
 8009cee:	2b00      	cmp	r3, #0
 8009cf0:	d004      	beq.n	8009cfc <netif_set_link_up+0x54>
 8009cf2:	687b      	ldr	r3, [r7, #4]
 8009cf4:	6a1b      	ldr	r3, [r3, #32]
 8009cf6:	687a      	ldr	r2, [r7, #4]
 8009cf8:	0010      	movs	r0, r2
 8009cfa:	4798      	blx	r3
      args.link_changed.state = 1;
      netif_invoke_ext_callback(netif, LWIP_NSC_LINK_CHANGED, &args);
    }
#endif
  }
}
 8009cfc:	46bd      	mov	sp, r7
 8009cfe:	b002      	add	sp, #8
 8009d00:	bd80      	pop	{r7, pc}
 8009d02:	46c0      	nop			; (mov r8, r8)
 8009d04:	080204cc 	.word	0x080204cc

08009d08 <netif_set_link_down>:
 * @ingroup netif
 * Called by a driver when its link goes down
 */
void
netif_set_link_down(struct netif *netif)
{
 8009d08:	b580      	push	{r7, lr}
 8009d0a:	b082      	sub	sp, #8
 8009d0c:	af00      	add	r7, sp, #0
 8009d0e:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif_set_link_down: invalid netif", netif != NULL, return);
 8009d10:	687b      	ldr	r3, [r7, #4]
 8009d12:	2b00      	cmp	r3, #0
 8009d14:	d104      	bne.n	8009d20 <netif_set_link_down+0x18>
 8009d16:	4b10      	ldr	r3, [pc, #64]	; (8009d58 <netif_set_link_down+0x50>)
 8009d18:	0018      	movs	r0, r3
 8009d1a:	f7f8 fa63 	bl	80021e4 <app_debug_rtt_raw>
 8009d1e:	e018      	b.n	8009d52 <netif_set_link_down+0x4a>

  if (netif->flags & NETIF_FLAG_LINK_UP) {
 8009d20:	687b      	ldr	r3, [r7, #4]
 8009d22:	2231      	movs	r2, #49	; 0x31
 8009d24:	5c9b      	ldrb	r3, [r3, r2]
 8009d26:	001a      	movs	r2, r3
 8009d28:	2304      	movs	r3, #4
 8009d2a:	4013      	ands	r3, r2
 8009d2c:	d011      	beq.n	8009d52 <netif_set_link_down+0x4a>
    netif_clear_flags(netif, NETIF_FLAG_LINK_UP);
 8009d2e:	687b      	ldr	r3, [r7, #4]
 8009d30:	2231      	movs	r2, #49	; 0x31
 8009d32:	5c9b      	ldrb	r3, [r3, r2]
 8009d34:	2204      	movs	r2, #4
 8009d36:	4393      	bics	r3, r2
 8009d38:	b2d9      	uxtb	r1, r3
 8009d3a:	687b      	ldr	r3, [r7, #4]
 8009d3c:	2231      	movs	r2, #49	; 0x31
 8009d3e:	5499      	strb	r1, [r3, r2]
#if LWIP_IPV6 && LWIP_ND6_ALLOW_RA_UPDATES
    netif->mtu6 = netif->mtu;
#endif

    NETIF_LINK_CALLBACK(netif);
 8009d40:	687b      	ldr	r3, [r7, #4]
 8009d42:	6a1b      	ldr	r3, [r3, #32]
 8009d44:	2b00      	cmp	r3, #0
 8009d46:	d004      	beq.n	8009d52 <netif_set_link_down+0x4a>
 8009d48:	687b      	ldr	r3, [r7, #4]
 8009d4a:	6a1b      	ldr	r3, [r3, #32]
 8009d4c:	687a      	ldr	r2, [r7, #4]
 8009d4e:	0010      	movs	r0, r2
 8009d50:	4798      	blx	r3
      args.link_changed.state = 0;
      netif_invoke_ext_callback(netif, LWIP_NSC_LINK_CHANGED, &args);
    }
#endif
  }
}
 8009d52:	46bd      	mov	sp, r7
 8009d54:	b002      	add	sp, #8
 8009d56:	bd80      	pop	{r7, pc}
 8009d58:	080204f0 	.word	0x080204f0

08009d5c <netif_null_output_ip4>:
#if LWIP_IPV4
/** Dummy IPv4 output function for netifs not supporting IPv4
 */
static err_t
netif_null_output_ip4(struct netif *netif, struct pbuf *p, const ip4_addr_t *ipaddr)
{
 8009d5c:	b580      	push	{r7, lr}
 8009d5e:	b084      	sub	sp, #16
 8009d60:	af00      	add	r7, sp, #0
 8009d62:	60f8      	str	r0, [r7, #12]
 8009d64:	60b9      	str	r1, [r7, #8]
 8009d66:	607a      	str	r2, [r7, #4]
  LWIP_UNUSED_ARG(netif);
  LWIP_UNUSED_ARG(p);
  LWIP_UNUSED_ARG(ipaddr);

  return ERR_IF;
 8009d68:	230c      	movs	r3, #12
 8009d6a:	425b      	negs	r3, r3
}
 8009d6c:	0018      	movs	r0, r3
 8009d6e:	46bd      	mov	sp, r7
 8009d70:	b004      	add	sp, #16
 8009d72:	bd80      	pop	{r7, pc}

08009d74 <netif_get_by_index>:
*
* @param idx index of netif to find
*/
struct netif *
netif_get_by_index(u8_t idx)
{
 8009d74:	b580      	push	{r7, lr}
 8009d76:	b084      	sub	sp, #16
 8009d78:	af00      	add	r7, sp, #0
 8009d7a:	0002      	movs	r2, r0
 8009d7c:	1dfb      	adds	r3, r7, #7
 8009d7e:	701a      	strb	r2, [r3, #0]
  struct netif *netif;

  LWIP_ASSERT_CORE_LOCKED();

  if (idx != NETIF_NO_INDEX) {
 8009d80:	1dfb      	adds	r3, r7, #7
 8009d82:	781b      	ldrb	r3, [r3, #0]
 8009d84:	2b00      	cmp	r3, #0
 8009d86:	d014      	beq.n	8009db2 <netif_get_by_index+0x3e>
    NETIF_FOREACH(netif) {
 8009d88:	4b0c      	ldr	r3, [pc, #48]	; (8009dbc <netif_get_by_index+0x48>)
 8009d8a:	681b      	ldr	r3, [r3, #0]
 8009d8c:	60fb      	str	r3, [r7, #12]
 8009d8e:	e00d      	b.n	8009dac <netif_get_by_index+0x38>
      if (idx == netif_get_index(netif)) {
 8009d90:	68fb      	ldr	r3, [r7, #12]
 8009d92:	2234      	movs	r2, #52	; 0x34
 8009d94:	5c9b      	ldrb	r3, [r3, r2]
 8009d96:	3301      	adds	r3, #1
 8009d98:	b2db      	uxtb	r3, r3
 8009d9a:	1dfa      	adds	r2, r7, #7
 8009d9c:	7812      	ldrb	r2, [r2, #0]
 8009d9e:	429a      	cmp	r2, r3
 8009da0:	d101      	bne.n	8009da6 <netif_get_by_index+0x32>
        return netif; /* found! */
 8009da2:	68fb      	ldr	r3, [r7, #12]
 8009da4:	e006      	b.n	8009db4 <netif_get_by_index+0x40>
    NETIF_FOREACH(netif) {
 8009da6:	68fb      	ldr	r3, [r7, #12]
 8009da8:	681b      	ldr	r3, [r3, #0]
 8009daa:	60fb      	str	r3, [r7, #12]
 8009dac:	68fb      	ldr	r3, [r7, #12]
 8009dae:	2b00      	cmp	r3, #0
 8009db0:	d1ee      	bne.n	8009d90 <netif_get_by_index+0x1c>
      }
    }
  }

  return NULL;
 8009db2:	2300      	movs	r3, #0
}
 8009db4:	0018      	movs	r0, r3
 8009db6:	46bd      	mov	sp, r7
 8009db8:	b004      	add	sp, #16
 8009dba:	bd80      	pop	{r7, pc}
 8009dbc:	2000277c 	.word	0x2000277c

08009dc0 <pbuf_free_ooseq>:
#if !NO_SYS
static
#endif /* !NO_SYS */
void
pbuf_free_ooseq(void)
{
 8009dc0:	b580      	push	{r7, lr}
 8009dc2:	b082      	sub	sp, #8
 8009dc4:	af00      	add	r7, sp, #0
  struct tcp_pcb *pcb;
  SYS_ARCH_SET(pbuf_free_ooseq_pending, 0);
 8009dc6:	4b0c      	ldr	r3, [pc, #48]	; (8009df8 <pbuf_free_ooseq+0x38>)
 8009dc8:	2200      	movs	r2, #0
 8009dca:	701a      	strb	r2, [r3, #0]

  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
 8009dcc:	4b0b      	ldr	r3, [pc, #44]	; (8009dfc <pbuf_free_ooseq+0x3c>)
 8009dce:	681b      	ldr	r3, [r3, #0]
 8009dd0:	607b      	str	r3, [r7, #4]
 8009dd2:	e00b      	b.n	8009dec <pbuf_free_ooseq+0x2c>
    if (pcb->ooseq != NULL) {
 8009dd4:	687b      	ldr	r3, [r7, #4]
 8009dd6:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8009dd8:	2b00      	cmp	r3, #0
 8009dda:	d004      	beq.n	8009de6 <pbuf_free_ooseq+0x26>
      /** Free the ooseq pbufs of one PCB only */
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free_ooseq: freeing out-of-sequence pbufs\n"));
      tcp_free_ooseq(pcb);
 8009ddc:	687b      	ldr	r3, [r7, #4]
 8009dde:	0018      	movs	r0, r3
 8009de0:	f003 f878 	bl	800ced4 <tcp_free_ooseq>
      return;
 8009de4:	e005      	b.n	8009df2 <pbuf_free_ooseq+0x32>
  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
 8009de6:	687b      	ldr	r3, [r7, #4]
 8009de8:	691b      	ldr	r3, [r3, #16]
 8009dea:	607b      	str	r3, [r7, #4]
 8009dec:	687b      	ldr	r3, [r7, #4]
 8009dee:	2b00      	cmp	r3, #0
 8009df0:	d1f0      	bne.n	8009dd4 <pbuf_free_ooseq+0x14>
    }
  }
}
 8009df2:	46bd      	mov	sp, r7
 8009df4:	b002      	add	sp, #8
 8009df6:	bd80      	pop	{r7, pc}
 8009df8:	20002784 	.word	0x20002784
 8009dfc:	2000278c 	.word	0x2000278c

08009e00 <pbuf_pool_is_empty>:
#endif /* !NO_SYS */

/** Queue a call to pbuf_free_ooseq if not already queued. */
static void
pbuf_pool_is_empty(void)
{
 8009e00:	b580      	push	{r7, lr}
 8009e02:	af00      	add	r7, sp, #0
#ifndef PBUF_POOL_FREE_OOSEQ_QUEUE_CALL
  SYS_ARCH_SET(pbuf_free_ooseq_pending, 1);
 8009e04:	4b02      	ldr	r3, [pc, #8]	; (8009e10 <pbuf_pool_is_empty+0x10>)
 8009e06:	2201      	movs	r2, #1
 8009e08:	701a      	strb	r2, [r3, #0]
  if (!queued) {
    /* queue a call to pbuf_free_ooseq if not already queued */
    PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
  }
#endif /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
}
 8009e0a:	46c0      	nop			; (mov r8, r8)
 8009e0c:	46bd      	mov	sp, r7
 8009e0e:	bd80      	pop	{r7, pc}
 8009e10:	20002784 	.word	0x20002784

08009e14 <pbuf_init_alloced_pbuf>:
#endif /* !LWIP_TCP || !TCP_QUEUE_OOSEQ || !PBUF_POOL_FREE_OOSEQ */

/* Initialize members of struct pbuf after allocation */
static void
pbuf_init_alloced_pbuf(struct pbuf *p, void *payload, u16_t tot_len, u16_t len, pbuf_type type, u8_t flags)
{
 8009e14:	b580      	push	{r7, lr}
 8009e16:	b084      	sub	sp, #16
 8009e18:	af00      	add	r7, sp, #0
 8009e1a:	60f8      	str	r0, [r7, #12]
 8009e1c:	60b9      	str	r1, [r7, #8]
 8009e1e:	0019      	movs	r1, r3
 8009e20:	1dbb      	adds	r3, r7, #6
 8009e22:	801a      	strh	r2, [r3, #0]
 8009e24:	1d3b      	adds	r3, r7, #4
 8009e26:	1c0a      	adds	r2, r1, #0
 8009e28:	801a      	strh	r2, [r3, #0]
  p->next = NULL;
 8009e2a:	68fb      	ldr	r3, [r7, #12]
 8009e2c:	2200      	movs	r2, #0
 8009e2e:	601a      	str	r2, [r3, #0]
  p->payload = payload;
 8009e30:	68fb      	ldr	r3, [r7, #12]
 8009e32:	68ba      	ldr	r2, [r7, #8]
 8009e34:	605a      	str	r2, [r3, #4]
  p->tot_len = tot_len;
 8009e36:	68fb      	ldr	r3, [r7, #12]
 8009e38:	1dba      	adds	r2, r7, #6
 8009e3a:	8812      	ldrh	r2, [r2, #0]
 8009e3c:	811a      	strh	r2, [r3, #8]
  p->len = len;
 8009e3e:	68fb      	ldr	r3, [r7, #12]
 8009e40:	1d3a      	adds	r2, r7, #4
 8009e42:	8812      	ldrh	r2, [r2, #0]
 8009e44:	815a      	strh	r2, [r3, #10]
  p->type_internal = (u8_t)type;
 8009e46:	2318      	movs	r3, #24
 8009e48:	18fb      	adds	r3, r7, r3
 8009e4a:	881b      	ldrh	r3, [r3, #0]
 8009e4c:	b2da      	uxtb	r2, r3
 8009e4e:	68fb      	ldr	r3, [r7, #12]
 8009e50:	731a      	strb	r2, [r3, #12]
  p->flags = flags;
 8009e52:	68fb      	ldr	r3, [r7, #12]
 8009e54:	221c      	movs	r2, #28
 8009e56:	18ba      	adds	r2, r7, r2
 8009e58:	7812      	ldrb	r2, [r2, #0]
 8009e5a:	735a      	strb	r2, [r3, #13]
  p->ref = 1;
 8009e5c:	68fb      	ldr	r3, [r7, #12]
 8009e5e:	2201      	movs	r2, #1
 8009e60:	739a      	strb	r2, [r3, #14]
  p->if_idx = NETIF_NO_INDEX;
 8009e62:	68fb      	ldr	r3, [r7, #12]
 8009e64:	2200      	movs	r2, #0
 8009e66:	73da      	strb	r2, [r3, #15]
}
 8009e68:	46c0      	nop			; (mov r8, r8)
 8009e6a:	46bd      	mov	sp, r7
 8009e6c:	b004      	add	sp, #16
 8009e6e:	bd80      	pop	{r7, pc}

08009e70 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
 8009e70:	b590      	push	{r4, r7, lr}
 8009e72:	b08d      	sub	sp, #52	; 0x34
 8009e74:	af02      	add	r7, sp, #8
 8009e76:	0004      	movs	r4, r0
 8009e78:	0008      	movs	r0, r1
 8009e7a:	0011      	movs	r1, r2
 8009e7c:	1dfb      	adds	r3, r7, #7
 8009e7e:	1c22      	adds	r2, r4, #0
 8009e80:	701a      	strb	r2, [r3, #0]
 8009e82:	1d3b      	adds	r3, r7, #4
 8009e84:	1c02      	adds	r2, r0, #0
 8009e86:	801a      	strh	r2, [r3, #0]
 8009e88:	1cbb      	adds	r3, r7, #2
 8009e8a:	1c0a      	adds	r2, r1, #0
 8009e8c:	801a      	strh	r2, [r3, #0]
  struct pbuf *p;
  u16_t offset = (u16_t)layer;
 8009e8e:	2322      	movs	r3, #34	; 0x22
 8009e90:	18fb      	adds	r3, r7, r3
 8009e92:	1dfa      	adds	r2, r7, #7
 8009e94:	7812      	ldrb	r2, [r2, #0]
 8009e96:	801a      	strh	r2, [r3, #0]
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));

  switch (type) {
 8009e98:	1cbb      	adds	r3, r7, #2
 8009e9a:	881b      	ldrh	r3, [r3, #0]
 8009e9c:	22a0      	movs	r2, #160	; 0xa0
 8009e9e:	0092      	lsls	r2, r2, #2
 8009ea0:	4293      	cmp	r3, r2
 8009ea2:	d100      	bne.n	8009ea6 <pbuf_alloc+0x36>
 8009ea4:	e0a8      	b.n	8009ff8 <pbuf_alloc+0x188>
 8009ea6:	22a0      	movs	r2, #160	; 0xa0
 8009ea8:	0092      	lsls	r2, r2, #2
 8009eaa:	4293      	cmp	r3, r2
 8009eac:	dd00      	ble.n	8009eb0 <pbuf_alloc+0x40>
 8009eae:	e103      	b.n	800a0b8 <pbuf_alloc+0x248>
 8009eb0:	22c1      	movs	r2, #193	; 0xc1
 8009eb2:	0052      	lsls	r2, r2, #1
 8009eb4:	4293      	cmp	r3, r2
 8009eb6:	d014      	beq.n	8009ee2 <pbuf_alloc+0x72>
 8009eb8:	22c1      	movs	r2, #193	; 0xc1
 8009eba:	0052      	lsls	r2, r2, #1
 8009ebc:	4293      	cmp	r3, r2
 8009ebe:	dd00      	ble.n	8009ec2 <pbuf_alloc+0x52>
 8009ec0:	e0fa      	b.n	800a0b8 <pbuf_alloc+0x248>
 8009ec2:	2b01      	cmp	r3, #1
 8009ec4:	d002      	beq.n	8009ecc <pbuf_alloc+0x5c>
 8009ec6:	2b41      	cmp	r3, #65	; 0x41
 8009ec8:	d000      	beq.n	8009ecc <pbuf_alloc+0x5c>
 8009eca:	e0f5      	b.n	800a0b8 <pbuf_alloc+0x248>
    case PBUF_REF: /* fall through */
    case PBUF_ROM:
      p = pbuf_alloc_reference(NULL, length, type);
 8009ecc:	1cbb      	adds	r3, r7, #2
 8009ece:	881a      	ldrh	r2, [r3, #0]
 8009ed0:	1d3b      	adds	r3, r7, #4
 8009ed2:	881b      	ldrh	r3, [r3, #0]
 8009ed4:	0019      	movs	r1, r3
 8009ed6:	2000      	movs	r0, #0
 8009ed8:	f000 f90a 	bl	800a0f0 <pbuf_alloc_reference>
 8009edc:	0003      	movs	r3, r0
 8009ede:	627b      	str	r3, [r7, #36]	; 0x24
      break;
 8009ee0:	e0f4      	b.n	800a0cc <pbuf_alloc+0x25c>
    case PBUF_POOL: {
      struct pbuf *q, *last;
      u16_t rem_len; /* remaining length */
      p = NULL;
 8009ee2:	2300      	movs	r3, #0
 8009ee4:	627b      	str	r3, [r7, #36]	; 0x24
      last = NULL;
 8009ee6:	2300      	movs	r3, #0
 8009ee8:	61fb      	str	r3, [r7, #28]
      rem_len = length;
 8009eea:	231a      	movs	r3, #26
 8009eec:	18fb      	adds	r3, r7, r3
 8009eee:	1d3a      	adds	r2, r7, #4
 8009ef0:	8812      	ldrh	r2, [r2, #0]
 8009ef2:	801a      	strh	r2, [r3, #0]
      do {
        u16_t qlen;
        q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 8009ef4:	2006      	movs	r0, #6
 8009ef6:	f7ff fbcd 	bl	8009694 <memp_malloc>
 8009efa:	0003      	movs	r3, r0
 8009efc:	613b      	str	r3, [r7, #16]
        if (q == NULL) {
 8009efe:	693b      	ldr	r3, [r7, #16]
 8009f00:	2b00      	cmp	r3, #0
 8009f02:	d10a      	bne.n	8009f1a <pbuf_alloc+0xaa>
          PBUF_POOL_IS_EMPTY();
 8009f04:	f7ff ff7c 	bl	8009e00 <pbuf_pool_is_empty>
          /* free chain so far allocated */
          if (p) {
 8009f08:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009f0a:	2b00      	cmp	r3, #0
 8009f0c:	d003      	beq.n	8009f16 <pbuf_alloc+0xa6>
            pbuf_free(p);
 8009f0e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009f10:	0018      	movs	r0, r3
 8009f12:	f000 fae3 	bl	800a4dc <pbuf_free>
          }
          /* bail out unsuccessfully */
          return NULL;
 8009f16:	2300      	movs	r3, #0
 8009f18:	e0d9      	b.n	800a0ce <pbuf_alloc+0x25e>
        }
        qlen = LWIP_MIN(rem_len, (u16_t)(PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)));
 8009f1a:	2322      	movs	r3, #34	; 0x22
 8009f1c:	18fb      	adds	r3, r7, r3
 8009f1e:	881b      	ldrh	r3, [r3, #0]
 8009f20:	3303      	adds	r3, #3
 8009f22:	b29b      	uxth	r3, r3
 8009f24:	2203      	movs	r2, #3
 8009f26:	4393      	bics	r3, r2
 8009f28:	b29b      	uxth	r3, r3
 8009f2a:	2294      	movs	r2, #148	; 0x94
 8009f2c:	0092      	lsls	r2, r2, #2
 8009f2e:	1ad3      	subs	r3, r2, r3
 8009f30:	b299      	uxth	r1, r3
 8009f32:	230e      	movs	r3, #14
 8009f34:	18fa      	adds	r2, r7, r3
 8009f36:	231a      	movs	r3, #26
 8009f38:	18fb      	adds	r3, r7, r3
 8009f3a:	1c0c      	adds	r4, r1, #0
 8009f3c:	881b      	ldrh	r3, [r3, #0]
 8009f3e:	b298      	uxth	r0, r3
 8009f40:	b2a1      	uxth	r1, r4
 8009f42:	4288      	cmp	r0, r1
 8009f44:	d900      	bls.n	8009f48 <pbuf_alloc+0xd8>
 8009f46:	1c23      	adds	r3, r4, #0
 8009f48:	8013      	strh	r3, [r2, #0]
        pbuf_init_alloced_pbuf(q, LWIP_MEM_ALIGN((void *)((u8_t *)q + SIZEOF_STRUCT_PBUF + offset)),
 8009f4a:	2322      	movs	r3, #34	; 0x22
 8009f4c:	18fb      	adds	r3, r7, r3
 8009f4e:	881b      	ldrh	r3, [r3, #0]
 8009f50:	3310      	adds	r3, #16
 8009f52:	693a      	ldr	r2, [r7, #16]
 8009f54:	18d3      	adds	r3, r2, r3
 8009f56:	3303      	adds	r3, #3
 8009f58:	2203      	movs	r2, #3
 8009f5a:	4393      	bics	r3, r2
 8009f5c:	001c      	movs	r4, r3
 8009f5e:	230e      	movs	r3, #14
 8009f60:	18fb      	adds	r3, r7, r3
 8009f62:	8819      	ldrh	r1, [r3, #0]
 8009f64:	231a      	movs	r3, #26
 8009f66:	18fb      	adds	r3, r7, r3
 8009f68:	881a      	ldrh	r2, [r3, #0]
 8009f6a:	6938      	ldr	r0, [r7, #16]
 8009f6c:	2300      	movs	r3, #0
 8009f6e:	9301      	str	r3, [sp, #4]
 8009f70:	1cbb      	adds	r3, r7, #2
 8009f72:	881b      	ldrh	r3, [r3, #0]
 8009f74:	9300      	str	r3, [sp, #0]
 8009f76:	000b      	movs	r3, r1
 8009f78:	0021      	movs	r1, r4
 8009f7a:	f7ff ff4b 	bl	8009e14 <pbuf_init_alloced_pbuf>
                               rem_len, qlen, type, 0);
        LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
 8009f7e:	693b      	ldr	r3, [r7, #16]
 8009f80:	685b      	ldr	r3, [r3, #4]
 8009f82:	001a      	movs	r2, r3
 8009f84:	2303      	movs	r3, #3
 8009f86:	4013      	ands	r3, r2
 8009f88:	d006      	beq.n	8009f98 <pbuf_alloc+0x128>
 8009f8a:	4b53      	ldr	r3, [pc, #332]	; (800a0d8 <pbuf_alloc+0x268>)
 8009f8c:	2280      	movs	r2, #128	; 0x80
 8009f8e:	0052      	lsls	r2, r2, #1
 8009f90:	4952      	ldr	r1, [pc, #328]	; (800a0dc <pbuf_alloc+0x26c>)
 8009f92:	4853      	ldr	r0, [pc, #332]	; (800a0e0 <pbuf_alloc+0x270>)
 8009f94:	f7f8 f926 	bl	80021e4 <app_debug_rtt_raw>
                    ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
        LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
 8009f98:	2322      	movs	r3, #34	; 0x22
 8009f9a:	18fb      	adds	r3, r7, r3
 8009f9c:	881b      	ldrh	r3, [r3, #0]
 8009f9e:	3303      	adds	r3, #3
 8009fa0:	2203      	movs	r2, #3
 8009fa2:	4393      	bics	r3, r2
 8009fa4:	001a      	movs	r2, r3
 8009fa6:	2394      	movs	r3, #148	; 0x94
 8009fa8:	009b      	lsls	r3, r3, #2
 8009faa:	429a      	cmp	r2, r3
 8009fac:	d106      	bne.n	8009fbc <pbuf_alloc+0x14c>
 8009fae:	4b4a      	ldr	r3, [pc, #296]	; (800a0d8 <pbuf_alloc+0x268>)
 8009fb0:	2281      	movs	r2, #129	; 0x81
 8009fb2:	0052      	lsls	r2, r2, #1
 8009fb4:	494b      	ldr	r1, [pc, #300]	; (800a0e4 <pbuf_alloc+0x274>)
 8009fb6:	484a      	ldr	r0, [pc, #296]	; (800a0e0 <pbuf_alloc+0x270>)
 8009fb8:	f7f8 f914 	bl	80021e4 <app_debug_rtt_raw>
                    (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
        if (p == NULL) {
 8009fbc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009fbe:	2b00      	cmp	r3, #0
 8009fc0:	d102      	bne.n	8009fc8 <pbuf_alloc+0x158>
          /* allocated head of pbuf chain (into p) */
          p = q;
 8009fc2:	693b      	ldr	r3, [r7, #16]
 8009fc4:	627b      	str	r3, [r7, #36]	; 0x24
 8009fc6:	e002      	b.n	8009fce <pbuf_alloc+0x15e>
        } else {
          /* make previous pbuf point to this pbuf */
          last->next = q;
 8009fc8:	69fb      	ldr	r3, [r7, #28]
 8009fca:	693a      	ldr	r2, [r7, #16]
 8009fcc:	601a      	str	r2, [r3, #0]
        }
        last = q;
 8009fce:	693b      	ldr	r3, [r7, #16]
 8009fd0:	61fb      	str	r3, [r7, #28]
        rem_len = (u16_t)(rem_len - qlen);
 8009fd2:	201a      	movs	r0, #26
 8009fd4:	183b      	adds	r3, r7, r0
 8009fd6:	1839      	adds	r1, r7, r0
 8009fd8:	220e      	movs	r2, #14
 8009fda:	18ba      	adds	r2, r7, r2
 8009fdc:	8809      	ldrh	r1, [r1, #0]
 8009fde:	8812      	ldrh	r2, [r2, #0]
 8009fe0:	1a8a      	subs	r2, r1, r2
 8009fe2:	801a      	strh	r2, [r3, #0]
        offset = 0;
 8009fe4:	2322      	movs	r3, #34	; 0x22
 8009fe6:	18fb      	adds	r3, r7, r3
 8009fe8:	2200      	movs	r2, #0
 8009fea:	801a      	strh	r2, [r3, #0]
      } while (rem_len > 0);
 8009fec:	183b      	adds	r3, r7, r0
 8009fee:	881b      	ldrh	r3, [r3, #0]
 8009ff0:	2b00      	cmp	r3, #0
 8009ff2:	d000      	beq.n	8009ff6 <pbuf_alloc+0x186>
 8009ff4:	e77e      	b.n	8009ef4 <pbuf_alloc+0x84>
      break;
 8009ff6:	e069      	b.n	800a0cc <pbuf_alloc+0x25c>
    }
    case PBUF_RAM: {
      mem_size_t payload_len = (mem_size_t)(LWIP_MEM_ALIGN_SIZE(offset) + LWIP_MEM_ALIGN_SIZE(length));
 8009ff8:	2322      	movs	r3, #34	; 0x22
 8009ffa:	18fb      	adds	r3, r7, r3
 8009ffc:	881b      	ldrh	r3, [r3, #0]
 8009ffe:	3303      	adds	r3, #3
 800a000:	b29b      	uxth	r3, r3
 800a002:	2203      	movs	r2, #3
 800a004:	4393      	bics	r3, r2
 800a006:	b299      	uxth	r1, r3
 800a008:	1d3b      	adds	r3, r7, #4
 800a00a:	881b      	ldrh	r3, [r3, #0]
 800a00c:	3303      	adds	r3, #3
 800a00e:	b29b      	uxth	r3, r3
 800a010:	2203      	movs	r2, #3
 800a012:	4393      	bics	r3, r2
 800a014:	b29a      	uxth	r2, r3
 800a016:	2018      	movs	r0, #24
 800a018:	183b      	adds	r3, r7, r0
 800a01a:	188a      	adds	r2, r1, r2
 800a01c:	801a      	strh	r2, [r3, #0]
      mem_size_t alloc_len = (mem_size_t)(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF) + payload_len);
 800a01e:	2416      	movs	r4, #22
 800a020:	193b      	adds	r3, r7, r4
 800a022:	183a      	adds	r2, r7, r0
 800a024:	8812      	ldrh	r2, [r2, #0]
 800a026:	3210      	adds	r2, #16
 800a028:	801a      	strh	r2, [r3, #0]

      /* bug #50040: Check for integer overflow when calculating alloc_len */
      if ((payload_len < LWIP_MEM_ALIGN_SIZE(length)) ||
 800a02a:	183b      	adds	r3, r7, r0
 800a02c:	881a      	ldrh	r2, [r3, #0]
 800a02e:	1d3b      	adds	r3, r7, #4
 800a030:	881b      	ldrh	r3, [r3, #0]
 800a032:	3303      	adds	r3, #3
 800a034:	2103      	movs	r1, #3
 800a036:	438b      	bics	r3, r1
 800a038:	429a      	cmp	r2, r3
 800a03a:	d308      	bcc.n	800a04e <pbuf_alloc+0x1de>
          (alloc_len < LWIP_MEM_ALIGN_SIZE(length))) {
 800a03c:	193b      	adds	r3, r7, r4
 800a03e:	881a      	ldrh	r2, [r3, #0]
 800a040:	1d3b      	adds	r3, r7, #4
 800a042:	881b      	ldrh	r3, [r3, #0]
 800a044:	3303      	adds	r3, #3
 800a046:	2103      	movs	r1, #3
 800a048:	438b      	bics	r3, r1
      if ((payload_len < LWIP_MEM_ALIGN_SIZE(length)) ||
 800a04a:	429a      	cmp	r2, r3
 800a04c:	d201      	bcs.n	800a052 <pbuf_alloc+0x1e2>
        return NULL;
 800a04e:	2300      	movs	r3, #0
 800a050:	e03d      	b.n	800a0ce <pbuf_alloc+0x25e>
      }

      /* If pbuf is to be allocated in RAM, allocate memory for it. */
      p = (struct pbuf *)mem_malloc(alloc_len);
 800a052:	2316      	movs	r3, #22
 800a054:	18fb      	adds	r3, r7, r3
 800a056:	881b      	ldrh	r3, [r3, #0]
 800a058:	0018      	movs	r0, r3
 800a05a:	f7ff f955 	bl	8009308 <mem_malloc>
 800a05e:	0003      	movs	r3, r0
 800a060:	627b      	str	r3, [r7, #36]	; 0x24
      if (p == NULL) {
 800a062:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a064:	2b00      	cmp	r3, #0
 800a066:	d101      	bne.n	800a06c <pbuf_alloc+0x1fc>
        return NULL;
 800a068:	2300      	movs	r3, #0
 800a06a:	e030      	b.n	800a0ce <pbuf_alloc+0x25e>
      }
      pbuf_init_alloced_pbuf(p, LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset)),
 800a06c:	2322      	movs	r3, #34	; 0x22
 800a06e:	18fb      	adds	r3, r7, r3
 800a070:	881b      	ldrh	r3, [r3, #0]
 800a072:	3310      	adds	r3, #16
 800a074:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800a076:	18d3      	adds	r3, r2, r3
 800a078:	3303      	adds	r3, #3
 800a07a:	2203      	movs	r2, #3
 800a07c:	4393      	bics	r3, r2
 800a07e:	001c      	movs	r4, r3
 800a080:	1d3b      	adds	r3, r7, #4
 800a082:	8819      	ldrh	r1, [r3, #0]
 800a084:	1d3b      	adds	r3, r7, #4
 800a086:	881a      	ldrh	r2, [r3, #0]
 800a088:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800a08a:	2300      	movs	r3, #0
 800a08c:	9301      	str	r3, [sp, #4]
 800a08e:	1cbb      	adds	r3, r7, #2
 800a090:	881b      	ldrh	r3, [r3, #0]
 800a092:	9300      	str	r3, [sp, #0]
 800a094:	000b      	movs	r3, r1
 800a096:	0021      	movs	r1, r4
 800a098:	f7ff febc 	bl	8009e14 <pbuf_init_alloced_pbuf>
                             length, length, type, 0);
      LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
 800a09c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a09e:	685b      	ldr	r3, [r3, #4]
 800a0a0:	001a      	movs	r2, r3
 800a0a2:	2303      	movs	r3, #3
 800a0a4:	4013      	ands	r3, r2
 800a0a6:	d010      	beq.n	800a0ca <pbuf_alloc+0x25a>
 800a0a8:	4b0b      	ldr	r3, [pc, #44]	; (800a0d8 <pbuf_alloc+0x268>)
 800a0aa:	2291      	movs	r2, #145	; 0x91
 800a0ac:	0052      	lsls	r2, r2, #1
 800a0ae:	490e      	ldr	r1, [pc, #56]	; (800a0e8 <pbuf_alloc+0x278>)
 800a0b0:	480b      	ldr	r0, [pc, #44]	; (800a0e0 <pbuf_alloc+0x270>)
 800a0b2:	f7f8 f897 	bl	80021e4 <app_debug_rtt_raw>
                  ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
      break;
 800a0b6:	e008      	b.n	800a0ca <pbuf_alloc+0x25a>
    }
    default:
      LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
 800a0b8:	4b07      	ldr	r3, [pc, #28]	; (800a0d8 <pbuf_alloc+0x268>)
 800a0ba:	2228      	movs	r2, #40	; 0x28
 800a0bc:	32ff      	adds	r2, #255	; 0xff
 800a0be:	490b      	ldr	r1, [pc, #44]	; (800a0ec <pbuf_alloc+0x27c>)
 800a0c0:	4807      	ldr	r0, [pc, #28]	; (800a0e0 <pbuf_alloc+0x270>)
 800a0c2:	f7f8 f88f 	bl	80021e4 <app_debug_rtt_raw>
      return NULL;
 800a0c6:	2300      	movs	r3, #0
 800a0c8:	e001      	b.n	800a0ce <pbuf_alloc+0x25e>
      break;
 800a0ca:	46c0      	nop			; (mov r8, r8)
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
 800a0cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 800a0ce:	0018      	movs	r0, r3
 800a0d0:	46bd      	mov	sp, r7
 800a0d2:	b00b      	add	sp, #44	; 0x2c
 800a0d4:	bd90      	pop	{r4, r7, pc}
 800a0d6:	46c0      	nop			; (mov r8, r8)
 800a0d8:	08020514 	.word	0x08020514
 800a0dc:	0802053c 	.word	0x0802053c
 800a0e0:	0802056c 	.word	0x0802056c
 800a0e4:	08020598 	.word	0x08020598
 800a0e8:	080205cc 	.word	0x080205cc
 800a0ec:	080205f8 	.word	0x080205f8

0800a0f0 <pbuf_alloc_reference>:
 *
 * @return the allocated pbuf.
 */
struct pbuf *
pbuf_alloc_reference(void *payload, u16_t length, pbuf_type type)
{
 800a0f0:	b590      	push	{r4, r7, lr}
 800a0f2:	b087      	sub	sp, #28
 800a0f4:	af02      	add	r7, sp, #8
 800a0f6:	6078      	str	r0, [r7, #4]
 800a0f8:	0008      	movs	r0, r1
 800a0fa:	0011      	movs	r1, r2
 800a0fc:	1cbb      	adds	r3, r7, #2
 800a0fe:	1c02      	adds	r2, r0, #0
 800a100:	801a      	strh	r2, [r3, #0]
 800a102:	003b      	movs	r3, r7
 800a104:	1c0a      	adds	r2, r1, #0
 800a106:	801a      	strh	r2, [r3, #0]
  struct pbuf *p;
  LWIP_ASSERT("invalid pbuf_type", (type == PBUF_REF) || (type == PBUF_ROM));
 800a108:	003b      	movs	r3, r7
 800a10a:	881b      	ldrh	r3, [r3, #0]
 800a10c:	2b41      	cmp	r3, #65	; 0x41
 800a10e:	d00a      	beq.n	800a126 <pbuf_alloc_reference+0x36>
 800a110:	003b      	movs	r3, r7
 800a112:	881b      	ldrh	r3, [r3, #0]
 800a114:	2b01      	cmp	r3, #1
 800a116:	d006      	beq.n	800a126 <pbuf_alloc_reference+0x36>
 800a118:	4b11      	ldr	r3, [pc, #68]	; (800a160 <pbuf_alloc_reference+0x70>)
 800a11a:	22a5      	movs	r2, #165	; 0xa5
 800a11c:	0052      	lsls	r2, r2, #1
 800a11e:	4911      	ldr	r1, [pc, #68]	; (800a164 <pbuf_alloc_reference+0x74>)
 800a120:	4811      	ldr	r0, [pc, #68]	; (800a168 <pbuf_alloc_reference+0x78>)
 800a122:	f7f8 f85f 	bl	80021e4 <app_debug_rtt_raw>
  /* only allocate memory for the pbuf structure */
  p = (struct pbuf *)memp_malloc(MEMP_PBUF);
 800a126:	2005      	movs	r0, #5
 800a128:	f7ff fab4 	bl	8009694 <memp_malloc>
 800a12c:	0003      	movs	r3, r0
 800a12e:	60fb      	str	r3, [r7, #12]
  if (p == NULL) {
 800a130:	68fb      	ldr	r3, [r7, #12]
 800a132:	2b00      	cmp	r3, #0
 800a134:	d101      	bne.n	800a13a <pbuf_alloc_reference+0x4a>
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                ("pbuf_alloc_reference: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                 (type == PBUF_ROM) ? "ROM" : "REF"));
    return NULL;
 800a136:	2300      	movs	r3, #0
 800a138:	e00e      	b.n	800a158 <pbuf_alloc_reference+0x68>
  }
  pbuf_init_alloced_pbuf(p, payload, length, length, type, 0);
 800a13a:	1cbb      	adds	r3, r7, #2
 800a13c:	881c      	ldrh	r4, [r3, #0]
 800a13e:	1cbb      	adds	r3, r7, #2
 800a140:	881a      	ldrh	r2, [r3, #0]
 800a142:	6879      	ldr	r1, [r7, #4]
 800a144:	68f8      	ldr	r0, [r7, #12]
 800a146:	2300      	movs	r3, #0
 800a148:	9301      	str	r3, [sp, #4]
 800a14a:	003b      	movs	r3, r7
 800a14c:	881b      	ldrh	r3, [r3, #0]
 800a14e:	9300      	str	r3, [sp, #0]
 800a150:	0023      	movs	r3, r4
 800a152:	f7ff fe5f 	bl	8009e14 <pbuf_init_alloced_pbuf>
  return p;
 800a156:	68fb      	ldr	r3, [r7, #12]
}
 800a158:	0018      	movs	r0, r3
 800a15a:	46bd      	mov	sp, r7
 800a15c:	b005      	add	sp, #20
 800a15e:	bd90      	pop	{r4, r7, pc}
 800a160:	08020514 	.word	0x08020514
 800a164:	08020614 	.word	0x08020614
 800a168:	0802056c 	.word	0x0802056c

0800a16c <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
 800a16c:	b580      	push	{r7, lr}
 800a16e:	b084      	sub	sp, #16
 800a170:	af00      	add	r7, sp, #0
 800a172:	6078      	str	r0, [r7, #4]
 800a174:	000a      	movs	r2, r1
 800a176:	1cbb      	adds	r3, r7, #2
 800a178:	801a      	strh	r2, [r3, #0]
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  u16_t shrink;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
 800a17a:	687b      	ldr	r3, [r7, #4]
 800a17c:	2b00      	cmp	r3, #0
 800a17e:	d106      	bne.n	800a18e <pbuf_realloc+0x22>
 800a180:	4b44      	ldr	r3, [pc, #272]	; (800a294 <pbuf_realloc+0x128>)
 800a182:	22cc      	movs	r2, #204	; 0xcc
 800a184:	0052      	lsls	r2, r2, #1
 800a186:	4944      	ldr	r1, [pc, #272]	; (800a298 <pbuf_realloc+0x12c>)
 800a188:	4844      	ldr	r0, [pc, #272]	; (800a29c <pbuf_realloc+0x130>)
 800a18a:	f7f8 f82b 	bl	80021e4 <app_debug_rtt_raw>

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
 800a18e:	687b      	ldr	r3, [r7, #4]
 800a190:	891b      	ldrh	r3, [r3, #8]
 800a192:	1cba      	adds	r2, r7, #2
 800a194:	8812      	ldrh	r2, [r2, #0]
 800a196:	429a      	cmp	r2, r3
 800a198:	d300      	bcc.n	800a19c <pbuf_realloc+0x30>
 800a19a:	e076      	b.n	800a28a <pbuf_realloc+0x11e>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  shrink = (u16_t)(p->tot_len - new_len);
 800a19c:	687b      	ldr	r3, [r7, #4]
 800a19e:	8919      	ldrh	r1, [r3, #8]
 800a1a0:	2308      	movs	r3, #8
 800a1a2:	18fb      	adds	r3, r7, r3
 800a1a4:	1cba      	adds	r2, r7, #2
 800a1a6:	8812      	ldrh	r2, [r2, #0]
 800a1a8:	1a8a      	subs	r2, r1, r2
 800a1aa:	801a      	strh	r2, [r3, #0]

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
 800a1ac:	230a      	movs	r3, #10
 800a1ae:	18fb      	adds	r3, r7, r3
 800a1b0:	1cba      	adds	r2, r7, #2
 800a1b2:	8812      	ldrh	r2, [r2, #0]
 800a1b4:	801a      	strh	r2, [r3, #0]
  q = p;
 800a1b6:	687b      	ldr	r3, [r7, #4]
 800a1b8:	60fb      	str	r3, [r7, #12]
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
 800a1ba:	e01d      	b.n	800a1f8 <pbuf_realloc+0x8c>
    /* decrease remaining length by pbuf length */
    rem_len = (u16_t)(rem_len - q->len);
 800a1bc:	68fb      	ldr	r3, [r7, #12]
 800a1be:	895a      	ldrh	r2, [r3, #10]
 800a1c0:	210a      	movs	r1, #10
 800a1c2:	187b      	adds	r3, r7, r1
 800a1c4:	1879      	adds	r1, r7, r1
 800a1c6:	8809      	ldrh	r1, [r1, #0]
 800a1c8:	1a8a      	subs	r2, r1, r2
 800a1ca:	801a      	strh	r2, [r3, #0]
    /* decrease total length indicator */
    q->tot_len = (u16_t)(q->tot_len - shrink);
 800a1cc:	68fb      	ldr	r3, [r7, #12]
 800a1ce:	891a      	ldrh	r2, [r3, #8]
 800a1d0:	2308      	movs	r3, #8
 800a1d2:	18fb      	adds	r3, r7, r3
 800a1d4:	881b      	ldrh	r3, [r3, #0]
 800a1d6:	1ad3      	subs	r3, r2, r3
 800a1d8:	b29a      	uxth	r2, r3
 800a1da:	68fb      	ldr	r3, [r7, #12]
 800a1dc:	811a      	strh	r2, [r3, #8]
    /* proceed to next pbuf in chain */
    q = q->next;
 800a1de:	68fb      	ldr	r3, [r7, #12]
 800a1e0:	681b      	ldr	r3, [r3, #0]
 800a1e2:	60fb      	str	r3, [r7, #12]
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
 800a1e4:	68fb      	ldr	r3, [r7, #12]
 800a1e6:	2b00      	cmp	r3, #0
 800a1e8:	d106      	bne.n	800a1f8 <pbuf_realloc+0x8c>
 800a1ea:	4b2a      	ldr	r3, [pc, #168]	; (800a294 <pbuf_realloc+0x128>)
 800a1ec:	22b0      	movs	r2, #176	; 0xb0
 800a1ee:	32ff      	adds	r2, #255	; 0xff
 800a1f0:	492b      	ldr	r1, [pc, #172]	; (800a2a0 <pbuf_realloc+0x134>)
 800a1f2:	482a      	ldr	r0, [pc, #168]	; (800a29c <pbuf_realloc+0x130>)
 800a1f4:	f7f7 fff6 	bl	80021e4 <app_debug_rtt_raw>
  while (rem_len > q->len) {
 800a1f8:	68fb      	ldr	r3, [r7, #12]
 800a1fa:	895b      	ldrh	r3, [r3, #10]
 800a1fc:	210a      	movs	r1, #10
 800a1fe:	187a      	adds	r2, r7, r1
 800a200:	8812      	ldrh	r2, [r2, #0]
 800a202:	429a      	cmp	r2, r3
 800a204:	d8da      	bhi.n	800a1bc <pbuf_realloc+0x50>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if (pbuf_match_allocsrc(q, PBUF_TYPE_ALLOC_SRC_MASK_STD_HEAP) && (rem_len != q->len)
 800a206:	68fb      	ldr	r3, [r7, #12]
 800a208:	7b1b      	ldrb	r3, [r3, #12]
 800a20a:	001a      	movs	r2, r3
 800a20c:	230f      	movs	r3, #15
 800a20e:	4013      	ands	r3, r2
 800a210:	d125      	bne.n	800a25e <pbuf_realloc+0xf2>
 800a212:	68fb      	ldr	r3, [r7, #12]
 800a214:	895b      	ldrh	r3, [r3, #10]
 800a216:	187a      	adds	r2, r7, r1
 800a218:	8812      	ldrh	r2, [r2, #0]
 800a21a:	429a      	cmp	r2, r3
 800a21c:	d01f      	beq.n	800a25e <pbuf_realloc+0xf2>
#if LWIP_SUPPORT_CUSTOM_PBUF
      && ((q->flags & PBUF_FLAG_IS_CUSTOM) == 0)
 800a21e:	68fb      	ldr	r3, [r7, #12]
 800a220:	7b5b      	ldrb	r3, [r3, #13]
 800a222:	001a      	movs	r2, r3
 800a224:	2302      	movs	r3, #2
 800a226:	4013      	ands	r3, r2
 800a228:	d119      	bne.n	800a25e <pbuf_realloc+0xf2>
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
     ) {
    /* reallocate and adjust the length of the pbuf that will be split */
    q = (struct pbuf *)mem_trim(q, (mem_size_t)(((u8_t *)q->payload - (u8_t *)q) + rem_len));
 800a22a:	68fb      	ldr	r3, [r7, #12]
 800a22c:	685a      	ldr	r2, [r3, #4]
 800a22e:	68fb      	ldr	r3, [r7, #12]
 800a230:	1ad3      	subs	r3, r2, r3
 800a232:	b29a      	uxth	r2, r3
 800a234:	187b      	adds	r3, r7, r1
 800a236:	881b      	ldrh	r3, [r3, #0]
 800a238:	18d3      	adds	r3, r2, r3
 800a23a:	b29a      	uxth	r2, r3
 800a23c:	68fb      	ldr	r3, [r7, #12]
 800a23e:	0011      	movs	r1, r2
 800a240:	0018      	movs	r0, r3
 800a242:	f7fe ff1d 	bl	8009080 <mem_trim>
 800a246:	0003      	movs	r3, r0
 800a248:	60fb      	str	r3, [r7, #12]
    LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
 800a24a:	68fb      	ldr	r3, [r7, #12]
 800a24c:	2b00      	cmp	r3, #0
 800a24e:	d106      	bne.n	800a25e <pbuf_realloc+0xf2>
 800a250:	4b10      	ldr	r3, [pc, #64]	; (800a294 <pbuf_realloc+0x128>)
 800a252:	22be      	movs	r2, #190	; 0xbe
 800a254:	32ff      	adds	r2, #255	; 0xff
 800a256:	4913      	ldr	r1, [pc, #76]	; (800a2a4 <pbuf_realloc+0x138>)
 800a258:	4810      	ldr	r0, [pc, #64]	; (800a29c <pbuf_realloc+0x130>)
 800a25a:	f7f7 ffc3 	bl	80021e4 <app_debug_rtt_raw>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
 800a25e:	68fb      	ldr	r3, [r7, #12]
 800a260:	220a      	movs	r2, #10
 800a262:	18ba      	adds	r2, r7, r2
 800a264:	8812      	ldrh	r2, [r2, #0]
 800a266:	815a      	strh	r2, [r3, #10]
  q->tot_len = q->len;
 800a268:	68fb      	ldr	r3, [r7, #12]
 800a26a:	895a      	ldrh	r2, [r3, #10]
 800a26c:	68fb      	ldr	r3, [r7, #12]
 800a26e:	811a      	strh	r2, [r3, #8]

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
 800a270:	68fb      	ldr	r3, [r7, #12]
 800a272:	681b      	ldr	r3, [r3, #0]
 800a274:	2b00      	cmp	r3, #0
 800a276:	d004      	beq.n	800a282 <pbuf_realloc+0x116>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
 800a278:	68fb      	ldr	r3, [r7, #12]
 800a27a:	681b      	ldr	r3, [r3, #0]
 800a27c:	0018      	movs	r0, r3
 800a27e:	f000 f92d 	bl	800a4dc <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
 800a282:	68fb      	ldr	r3, [r7, #12]
 800a284:	2200      	movs	r2, #0
 800a286:	601a      	str	r2, [r3, #0]
 800a288:	e000      	b.n	800a28c <pbuf_realloc+0x120>
    return;
 800a28a:	46c0      	nop			; (mov r8, r8)

}
 800a28c:	46bd      	mov	sp, r7
 800a28e:	b004      	add	sp, #16
 800a290:	bd80      	pop	{r7, pc}
 800a292:	46c0      	nop			; (mov r8, r8)
 800a294:	08020514 	.word	0x08020514
 800a298:	08020628 	.word	0x08020628
 800a29c:	0802056c 	.word	0x0802056c
 800a2a0:	08020640 	.word	0x08020640
 800a2a4:	08020658 	.word	0x08020658

0800a2a8 <pbuf_add_header_impl>:
 * @return non-zero on failure, zero on success.
 *
 */
static u8_t
pbuf_add_header_impl(struct pbuf *p, size_t header_size_increment, u8_t force)
{
 800a2a8:	b580      	push	{r7, lr}
 800a2aa:	b086      	sub	sp, #24
 800a2ac:	af00      	add	r7, sp, #0
 800a2ae:	60f8      	str	r0, [r7, #12]
 800a2b0:	60b9      	str	r1, [r7, #8]
 800a2b2:	1dfb      	adds	r3, r7, #7
 800a2b4:	701a      	strb	r2, [r3, #0]
  u16_t type_internal;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
 800a2b6:	68fb      	ldr	r3, [r7, #12]
 800a2b8:	2b00      	cmp	r3, #0
 800a2ba:	d106      	bne.n	800a2ca <pbuf_add_header_impl+0x22>
 800a2bc:	4b31      	ldr	r3, [pc, #196]	; (800a384 <pbuf_add_header_impl+0xdc>)
 800a2be:	22e0      	movs	r2, #224	; 0xe0
 800a2c0:	32ff      	adds	r2, #255	; 0xff
 800a2c2:	4931      	ldr	r1, [pc, #196]	; (800a388 <pbuf_add_header_impl+0xe0>)
 800a2c4:	4831      	ldr	r0, [pc, #196]	; (800a38c <pbuf_add_header_impl+0xe4>)
 800a2c6:	f7f7 ff8d 	bl	80021e4 <app_debug_rtt_raw>
  if ((p == NULL) || (header_size_increment > 0xFFFF)) {
 800a2ca:	68fb      	ldr	r3, [r7, #12]
 800a2cc:	2b00      	cmp	r3, #0
 800a2ce:	d004      	beq.n	800a2da <pbuf_add_header_impl+0x32>
 800a2d0:	68ba      	ldr	r2, [r7, #8]
 800a2d2:	2380      	movs	r3, #128	; 0x80
 800a2d4:	025b      	lsls	r3, r3, #9
 800a2d6:	429a      	cmp	r2, r3
 800a2d8:	d301      	bcc.n	800a2de <pbuf_add_header_impl+0x36>
    return 1;
 800a2da:	2301      	movs	r3, #1
 800a2dc:	e04d      	b.n	800a37a <pbuf_add_header_impl+0xd2>
  }
  if (header_size_increment == 0) {
 800a2de:	68bb      	ldr	r3, [r7, #8]
 800a2e0:	2b00      	cmp	r3, #0
 800a2e2:	d101      	bne.n	800a2e8 <pbuf_add_header_impl+0x40>
    return 0;
 800a2e4:	2300      	movs	r3, #0
 800a2e6:	e048      	b.n	800a37a <pbuf_add_header_impl+0xd2>
  }

  increment_magnitude = (u16_t)header_size_increment;
 800a2e8:	2112      	movs	r1, #18
 800a2ea:	187b      	adds	r3, r7, r1
 800a2ec:	68ba      	ldr	r2, [r7, #8]
 800a2ee:	801a      	strh	r2, [r3, #0]
  /* Do not allow tot_len to wrap as a result. */
  if ((u16_t)(increment_magnitude + p->tot_len) < increment_magnitude) {
 800a2f0:	68fb      	ldr	r3, [r7, #12]
 800a2f2:	891a      	ldrh	r2, [r3, #8]
 800a2f4:	187b      	adds	r3, r7, r1
 800a2f6:	881b      	ldrh	r3, [r3, #0]
 800a2f8:	18d3      	adds	r3, r2, r3
 800a2fa:	b29b      	uxth	r3, r3
 800a2fc:	187a      	adds	r2, r7, r1
 800a2fe:	8812      	ldrh	r2, [r2, #0]
 800a300:	429a      	cmp	r2, r3
 800a302:	d901      	bls.n	800a308 <pbuf_add_header_impl+0x60>
    return 1;
 800a304:	2301      	movs	r3, #1
 800a306:	e038      	b.n	800a37a <pbuf_add_header_impl+0xd2>
  }

  type_internal = p->type_internal;
 800a308:	68fb      	ldr	r3, [r7, #12]
 800a30a:	7b1a      	ldrb	r2, [r3, #12]
 800a30c:	2110      	movs	r1, #16
 800a30e:	187b      	adds	r3, r7, r1
 800a310:	801a      	strh	r2, [r3, #0]

  /* pbuf types containing payloads? */
  if (type_internal & PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS) {
 800a312:	187b      	adds	r3, r7, r1
 800a314:	881b      	ldrh	r3, [r3, #0]
 800a316:	2280      	movs	r2, #128	; 0x80
 800a318:	4013      	ands	r3, r2
 800a31a:	d00c      	beq.n	800a336 <pbuf_add_header_impl+0x8e>
    /* set new payload pointer */
    payload = (u8_t *)p->payload - header_size_increment;
 800a31c:	68fb      	ldr	r3, [r7, #12]
 800a31e:	685a      	ldr	r2, [r3, #4]
 800a320:	68bb      	ldr	r3, [r7, #8]
 800a322:	425b      	negs	r3, r3
 800a324:	18d3      	adds	r3, r2, r3
 800a326:	617b      	str	r3, [r7, #20]
    /* boundary check fails? */
    if ((u8_t *)payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
 800a328:	68fb      	ldr	r3, [r7, #12]
 800a32a:	3310      	adds	r3, #16
 800a32c:	697a      	ldr	r2, [r7, #20]
 800a32e:	429a      	cmp	r2, r3
 800a330:	d20e      	bcs.n	800a350 <pbuf_add_header_impl+0xa8>
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE,
                   ("pbuf_add_header: failed as %p < %p (not enough space for new header size)\n",
                    (void *)payload, (void *)((u8_t *)p + SIZEOF_STRUCT_PBUF)));
      /* bail out unsuccessfully */
      return 1;
 800a332:	2301      	movs	r3, #1
 800a334:	e021      	b.n	800a37a <pbuf_add_header_impl+0xd2>
    }
    /* pbuf types referring to external payloads? */
  } else {
    /* hide a header in the payload? */
    if (force) {
 800a336:	1dfb      	adds	r3, r7, #7
 800a338:	781b      	ldrb	r3, [r3, #0]
 800a33a:	2b00      	cmp	r3, #0
 800a33c:	d006      	beq.n	800a34c <pbuf_add_header_impl+0xa4>
      payload = (u8_t *)p->payload - header_size_increment;
 800a33e:	68fb      	ldr	r3, [r7, #12]
 800a340:	685a      	ldr	r2, [r3, #4]
 800a342:	68bb      	ldr	r3, [r7, #8]
 800a344:	425b      	negs	r3, r3
 800a346:	18d3      	adds	r3, r2, r3
 800a348:	617b      	str	r3, [r7, #20]
 800a34a:	e001      	b.n	800a350 <pbuf_add_header_impl+0xa8>
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccessfully */
      return 1;
 800a34c:	2301      	movs	r3, #1
 800a34e:	e014      	b.n	800a37a <pbuf_add_header_impl+0xd2>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_add_header: old %p new %p (%"U16_F")\n",
              (void *)p->payload, (void *)payload, increment_magnitude));

  /* modify pbuf fields */
  p->payload = payload;
 800a350:	68fb      	ldr	r3, [r7, #12]
 800a352:	697a      	ldr	r2, [r7, #20]
 800a354:	605a      	str	r2, [r3, #4]
  p->len = (u16_t)(p->len + increment_magnitude);
 800a356:	68fb      	ldr	r3, [r7, #12]
 800a358:	895a      	ldrh	r2, [r3, #10]
 800a35a:	2112      	movs	r1, #18
 800a35c:	187b      	adds	r3, r7, r1
 800a35e:	881b      	ldrh	r3, [r3, #0]
 800a360:	18d3      	adds	r3, r2, r3
 800a362:	b29a      	uxth	r2, r3
 800a364:	68fb      	ldr	r3, [r7, #12]
 800a366:	815a      	strh	r2, [r3, #10]
  p->tot_len = (u16_t)(p->tot_len + increment_magnitude);
 800a368:	68fb      	ldr	r3, [r7, #12]
 800a36a:	891a      	ldrh	r2, [r3, #8]
 800a36c:	187b      	adds	r3, r7, r1
 800a36e:	881b      	ldrh	r3, [r3, #0]
 800a370:	18d3      	adds	r3, r2, r3
 800a372:	b29a      	uxth	r2, r3
 800a374:	68fb      	ldr	r3, [r7, #12]
 800a376:	811a      	strh	r2, [r3, #8]


  return 0;
 800a378:	2300      	movs	r3, #0
}
 800a37a:	0018      	movs	r0, r3
 800a37c:	46bd      	mov	sp, r7
 800a37e:	b006      	add	sp, #24
 800a380:	bd80      	pop	{r7, pc}
 800a382:	46c0      	nop			; (mov r8, r8)
 800a384:	08020514 	.word	0x08020514
 800a388:	08020674 	.word	0x08020674
 800a38c:	0802056c 	.word	0x0802056c

0800a390 <pbuf_add_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_add_header(struct pbuf *p, size_t header_size_increment)
{
 800a390:	b580      	push	{r7, lr}
 800a392:	b082      	sub	sp, #8
 800a394:	af00      	add	r7, sp, #0
 800a396:	6078      	str	r0, [r7, #4]
 800a398:	6039      	str	r1, [r7, #0]
  return pbuf_add_header_impl(p, header_size_increment, 0);
 800a39a:	6839      	ldr	r1, [r7, #0]
 800a39c:	687b      	ldr	r3, [r7, #4]
 800a39e:	2200      	movs	r2, #0
 800a3a0:	0018      	movs	r0, r3
 800a3a2:	f7ff ff81 	bl	800a2a8 <pbuf_add_header_impl>
 800a3a6:	0003      	movs	r3, r0
}
 800a3a8:	0018      	movs	r0, r3
 800a3aa:	46bd      	mov	sp, r7
 800a3ac:	b002      	add	sp, #8
 800a3ae:	bd80      	pop	{r7, pc}

0800a3b0 <pbuf_remove_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_remove_header(struct pbuf *p, size_t header_size_decrement)
{
 800a3b0:	b580      	push	{r7, lr}
 800a3b2:	b084      	sub	sp, #16
 800a3b4:	af00      	add	r7, sp, #0
 800a3b6:	6078      	str	r0, [r7, #4]
 800a3b8:	6039      	str	r1, [r7, #0]
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
 800a3ba:	687b      	ldr	r3, [r7, #4]
 800a3bc:	2b00      	cmp	r3, #0
 800a3be:	d105      	bne.n	800a3cc <pbuf_remove_header+0x1c>
 800a3c0:	4b21      	ldr	r3, [pc, #132]	; (800a448 <pbuf_remove_header+0x98>)
 800a3c2:	4a22      	ldr	r2, [pc, #136]	; (800a44c <pbuf_remove_header+0x9c>)
 800a3c4:	4922      	ldr	r1, [pc, #136]	; (800a450 <pbuf_remove_header+0xa0>)
 800a3c6:	4823      	ldr	r0, [pc, #140]	; (800a454 <pbuf_remove_header+0xa4>)
 800a3c8:	f7f7 ff0c 	bl	80021e4 <app_debug_rtt_raw>
  if ((p == NULL) || (header_size_decrement > 0xFFFF)) {
 800a3cc:	687b      	ldr	r3, [r7, #4]
 800a3ce:	2b00      	cmp	r3, #0
 800a3d0:	d004      	beq.n	800a3dc <pbuf_remove_header+0x2c>
 800a3d2:	683a      	ldr	r2, [r7, #0]
 800a3d4:	2380      	movs	r3, #128	; 0x80
 800a3d6:	025b      	lsls	r3, r3, #9
 800a3d8:	429a      	cmp	r2, r3
 800a3da:	d301      	bcc.n	800a3e0 <pbuf_remove_header+0x30>
    return 1;
 800a3dc:	2301      	movs	r3, #1
 800a3de:	e02f      	b.n	800a440 <pbuf_remove_header+0x90>
  }
  if (header_size_decrement == 0) {
 800a3e0:	683b      	ldr	r3, [r7, #0]
 800a3e2:	2b00      	cmp	r3, #0
 800a3e4:	d101      	bne.n	800a3ea <pbuf_remove_header+0x3a>
    return 0;
 800a3e6:	2300      	movs	r3, #0
 800a3e8:	e02a      	b.n	800a440 <pbuf_remove_header+0x90>
  }

  increment_magnitude = (u16_t)header_size_decrement;
 800a3ea:	210e      	movs	r1, #14
 800a3ec:	187b      	adds	r3, r7, r1
 800a3ee:	683a      	ldr	r2, [r7, #0]
 800a3f0:	801a      	strh	r2, [r3, #0]
  /* Check that we aren't going to move off the end of the pbuf */
  LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 800a3f2:	687b      	ldr	r3, [r7, #4]
 800a3f4:	895b      	ldrh	r3, [r3, #10]
 800a3f6:	187a      	adds	r2, r7, r1
 800a3f8:	8812      	ldrh	r2, [r2, #0]
 800a3fa:	429a      	cmp	r2, r3
 800a3fc:	d905      	bls.n	800a40a <pbuf_remove_header+0x5a>
 800a3fe:	4b16      	ldr	r3, [pc, #88]	; (800a458 <pbuf_remove_header+0xa8>)
 800a400:	0018      	movs	r0, r3
 800a402:	f7f7 feef 	bl	80021e4 <app_debug_rtt_raw>
 800a406:	2301      	movs	r3, #1
 800a408:	e01a      	b.n	800a440 <pbuf_remove_header+0x90>

  /* remember current payload pointer */
  payload = p->payload;
 800a40a:	687b      	ldr	r3, [r7, #4]
 800a40c:	685b      	ldr	r3, [r3, #4]
 800a40e:	60bb      	str	r3, [r7, #8]
  LWIP_UNUSED_ARG(payload); /* only used in LWIP_DEBUGF below */

  /* increase payload pointer (guarded by length check above) */
  p->payload = (u8_t *)p->payload + header_size_decrement;
 800a410:	687b      	ldr	r3, [r7, #4]
 800a412:	685a      	ldr	r2, [r3, #4]
 800a414:	683b      	ldr	r3, [r7, #0]
 800a416:	18d2      	adds	r2, r2, r3
 800a418:	687b      	ldr	r3, [r7, #4]
 800a41a:	605a      	str	r2, [r3, #4]
  /* modify pbuf length fields */
  p->len = (u16_t)(p->len - increment_magnitude);
 800a41c:	687b      	ldr	r3, [r7, #4]
 800a41e:	895a      	ldrh	r2, [r3, #10]
 800a420:	210e      	movs	r1, #14
 800a422:	187b      	adds	r3, r7, r1
 800a424:	881b      	ldrh	r3, [r3, #0]
 800a426:	1ad3      	subs	r3, r2, r3
 800a428:	b29a      	uxth	r2, r3
 800a42a:	687b      	ldr	r3, [r7, #4]
 800a42c:	815a      	strh	r2, [r3, #10]
  p->tot_len = (u16_t)(p->tot_len - increment_magnitude);
 800a42e:	687b      	ldr	r3, [r7, #4]
 800a430:	891a      	ldrh	r2, [r3, #8]
 800a432:	187b      	adds	r3, r7, r1
 800a434:	881b      	ldrh	r3, [r3, #0]
 800a436:	1ad3      	subs	r3, r2, r3
 800a438:	b29a      	uxth	r2, r3
 800a43a:	687b      	ldr	r3, [r7, #4]
 800a43c:	811a      	strh	r2, [r3, #8]

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_remove_header: old %p new %p (%"U16_F")\n",
              (void *)payload, (void *)p->payload, increment_magnitude));

  return 0;
 800a43e:	2300      	movs	r3, #0
}
 800a440:	0018      	movs	r0, r3
 800a442:	46bd      	mov	sp, r7
 800a444:	b004      	add	sp, #16
 800a446:	bd80      	pop	{r7, pc}
 800a448:	08020514 	.word	0x08020514
 800a44c:	0000024b 	.word	0x0000024b
 800a450:	08020674 	.word	0x08020674
 800a454:	0802056c 	.word	0x0802056c
 800a458:	08020680 	.word	0x08020680

0800a45c <pbuf_header_impl>:

static u8_t
pbuf_header_impl(struct pbuf *p, s16_t header_size_increment, u8_t force)
{
 800a45c:	b580      	push	{r7, lr}
 800a45e:	b082      	sub	sp, #8
 800a460:	af00      	add	r7, sp, #0
 800a462:	6078      	str	r0, [r7, #4]
 800a464:	0008      	movs	r0, r1
 800a466:	0011      	movs	r1, r2
 800a468:	1cbb      	adds	r3, r7, #2
 800a46a:	1c02      	adds	r2, r0, #0
 800a46c:	801a      	strh	r2, [r3, #0]
 800a46e:	1c7b      	adds	r3, r7, #1
 800a470:	1c0a      	adds	r2, r1, #0
 800a472:	701a      	strb	r2, [r3, #0]
  if (header_size_increment < 0) {
 800a474:	1cbb      	adds	r3, r7, #2
 800a476:	2200      	movs	r2, #0
 800a478:	5e9b      	ldrsh	r3, [r3, r2]
 800a47a:	2b00      	cmp	r3, #0
 800a47c:	da0b      	bge.n	800a496 <pbuf_header_impl+0x3a>
    return pbuf_remove_header(p, (size_t) - header_size_increment);
 800a47e:	1cbb      	adds	r3, r7, #2
 800a480:	2200      	movs	r2, #0
 800a482:	5e9b      	ldrsh	r3, [r3, r2]
 800a484:	425b      	negs	r3, r3
 800a486:	001a      	movs	r2, r3
 800a488:	687b      	ldr	r3, [r7, #4]
 800a48a:	0011      	movs	r1, r2
 800a48c:	0018      	movs	r0, r3
 800a48e:	f7ff ff8f 	bl	800a3b0 <pbuf_remove_header>
 800a492:	0003      	movs	r3, r0
 800a494:	e009      	b.n	800a4aa <pbuf_header_impl+0x4e>
  } else {
    return pbuf_add_header_impl(p, (size_t)header_size_increment, force);
 800a496:	1cbb      	adds	r3, r7, #2
 800a498:	2100      	movs	r1, #0
 800a49a:	5e59      	ldrsh	r1, [r3, r1]
 800a49c:	1c7b      	adds	r3, r7, #1
 800a49e:	781a      	ldrb	r2, [r3, #0]
 800a4a0:	687b      	ldr	r3, [r7, #4]
 800a4a2:	0018      	movs	r0, r3
 800a4a4:	f7ff ff00 	bl	800a2a8 <pbuf_add_header_impl>
 800a4a8:	0003      	movs	r3, r0
  }
}
 800a4aa:	0018      	movs	r0, r3
 800a4ac:	46bd      	mov	sp, r7
 800a4ae:	b002      	add	sp, #8
 800a4b0:	bd80      	pop	{r7, pc}

0800a4b2 <pbuf_header_force>:
 * Same as pbuf_header but does not check if 'header_size > 0' is allowed.
 * This is used internally only, to allow PBUF_REF for RX.
 */
u8_t
pbuf_header_force(struct pbuf *p, s16_t header_size_increment)
{
 800a4b2:	b580      	push	{r7, lr}
 800a4b4:	b082      	sub	sp, #8
 800a4b6:	af00      	add	r7, sp, #0
 800a4b8:	6078      	str	r0, [r7, #4]
 800a4ba:	000a      	movs	r2, r1
 800a4bc:	1cbb      	adds	r3, r7, #2
 800a4be:	801a      	strh	r2, [r3, #0]
  return pbuf_header_impl(p, header_size_increment, 1);
 800a4c0:	1cbb      	adds	r3, r7, #2
 800a4c2:	2100      	movs	r1, #0
 800a4c4:	5e59      	ldrsh	r1, [r3, r1]
 800a4c6:	687b      	ldr	r3, [r7, #4]
 800a4c8:	2201      	movs	r2, #1
 800a4ca:	0018      	movs	r0, r3
 800a4cc:	f7ff ffc6 	bl	800a45c <pbuf_header_impl>
 800a4d0:	0003      	movs	r3, r0
}
 800a4d2:	0018      	movs	r0, r3
 800a4d4:	46bd      	mov	sp, r7
 800a4d6:	b002      	add	sp, #8
 800a4d8:	bd80      	pop	{r7, pc}
	...

0800a4dc <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
 800a4dc:	b580      	push	{r7, lr}
 800a4de:	b086      	sub	sp, #24
 800a4e0:	af00      	add	r7, sp, #0
 800a4e2:	6078      	str	r0, [r7, #4]
  u8_t alloc_src;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
 800a4e4:	687b      	ldr	r3, [r7, #4]
 800a4e6:	2b00      	cmp	r3, #0
 800a4e8:	d10b      	bne.n	800a502 <pbuf_free+0x26>
    LWIP_ASSERT("p != NULL", p != NULL);
 800a4ea:	687b      	ldr	r3, [r7, #4]
 800a4ec:	2b00      	cmp	r3, #0
 800a4ee:	d106      	bne.n	800a4fe <pbuf_free+0x22>
 800a4f0:	4b41      	ldr	r3, [pc, #260]	; (800a5f8 <pbuf_free+0x11c>)
 800a4f2:	22b7      	movs	r2, #183	; 0xb7
 800a4f4:	0092      	lsls	r2, r2, #2
 800a4f6:	4941      	ldr	r1, [pc, #260]	; (800a5fc <pbuf_free+0x120>)
 800a4f8:	4841      	ldr	r0, [pc, #260]	; (800a600 <pbuf_free+0x124>)
 800a4fa:	f7f7 fe73 	bl	80021e4 <app_debug_rtt_raw>
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                ("pbuf_free(p == NULL) was called.\n"));
    return 0;
 800a4fe:	2300      	movs	r3, #0
 800a500:	e076      	b.n	800a5f0 <pbuf_free+0x114>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  count = 0;
 800a502:	2317      	movs	r3, #23
 800a504:	18fb      	adds	r3, r7, r3
 800a506:	2200      	movs	r2, #0
 800a508:	701a      	strb	r2, [r3, #0]
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
 800a50a:	e06b      	b.n	800a5e4 <pbuf_free+0x108>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
 800a50c:	687b      	ldr	r3, [r7, #4]
 800a50e:	7b9b      	ldrb	r3, [r3, #14]
 800a510:	2b00      	cmp	r3, #0
 800a512:	d105      	bne.n	800a520 <pbuf_free+0x44>
 800a514:	4b38      	ldr	r3, [pc, #224]	; (800a5f8 <pbuf_free+0x11c>)
 800a516:	4a3b      	ldr	r2, [pc, #236]	; (800a604 <pbuf_free+0x128>)
 800a518:	493b      	ldr	r1, [pc, #236]	; (800a608 <pbuf_free+0x12c>)
 800a51a:	4839      	ldr	r0, [pc, #228]	; (800a600 <pbuf_free+0x124>)
 800a51c:	f7f7 fe62 	bl	80021e4 <app_debug_rtt_raw>
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
 800a520:	687b      	ldr	r3, [r7, #4]
 800a522:	7b9b      	ldrb	r3, [r3, #14]
 800a524:	3b01      	subs	r3, #1
 800a526:	b2da      	uxtb	r2, r3
 800a528:	687b      	ldr	r3, [r7, #4]
 800a52a:	739a      	strb	r2, [r3, #14]
 800a52c:	2116      	movs	r1, #22
 800a52e:	187b      	adds	r3, r7, r1
 800a530:	687a      	ldr	r2, [r7, #4]
 800a532:	7b92      	ldrb	r2, [r2, #14]
 800a534:	701a      	strb	r2, [r3, #0]
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
 800a536:	187b      	adds	r3, r7, r1
 800a538:	781b      	ldrb	r3, [r3, #0]
 800a53a:	2b00      	cmp	r3, #0
 800a53c:	d150      	bne.n	800a5e0 <pbuf_free+0x104>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
 800a53e:	687b      	ldr	r3, [r7, #4]
 800a540:	681b      	ldr	r3, [r3, #0]
 800a542:	613b      	str	r3, [r7, #16]
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      alloc_src = pbuf_get_allocsrc(p);
 800a544:	687b      	ldr	r3, [r7, #4]
 800a546:	7b1a      	ldrb	r2, [r3, #12]
 800a548:	230f      	movs	r3, #15
 800a54a:	18fb      	adds	r3, r7, r3
 800a54c:	210f      	movs	r1, #15
 800a54e:	400a      	ands	r2, r1
 800a550:	701a      	strb	r2, [r3, #0]
#if LWIP_SUPPORT_CUSTOM_PBUF
      /* is this a custom pbuf? */
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
 800a552:	687b      	ldr	r3, [r7, #4]
 800a554:	7b5b      	ldrb	r3, [r3, #13]
 800a556:	001a      	movs	r2, r3
 800a558:	2302      	movs	r3, #2
 800a55a:	4013      	ands	r3, r2
 800a55c:	d011      	beq.n	800a582 <pbuf_free+0xa6>
        struct pbuf_custom *pc = (struct pbuf_custom *)p;
 800a55e:	687b      	ldr	r3, [r7, #4]
 800a560:	60bb      	str	r3, [r7, #8]
        LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
 800a562:	68bb      	ldr	r3, [r7, #8]
 800a564:	691b      	ldr	r3, [r3, #16]
 800a566:	2b00      	cmp	r3, #0
 800a568:	d105      	bne.n	800a576 <pbuf_free+0x9a>
 800a56a:	4b23      	ldr	r3, [pc, #140]	; (800a5f8 <pbuf_free+0x11c>)
 800a56c:	4a27      	ldr	r2, [pc, #156]	; (800a60c <pbuf_free+0x130>)
 800a56e:	4928      	ldr	r1, [pc, #160]	; (800a610 <pbuf_free+0x134>)
 800a570:	4823      	ldr	r0, [pc, #140]	; (800a600 <pbuf_free+0x124>)
 800a572:	f7f7 fe37 	bl	80021e4 <app_debug_rtt_raw>
        pc->custom_free_function(p);
 800a576:	68bb      	ldr	r3, [r7, #8]
 800a578:	691b      	ldr	r3, [r3, #16]
 800a57a:	687a      	ldr	r2, [r7, #4]
 800a57c:	0010      	movs	r0, r2
 800a57e:	4798      	blx	r3
 800a580:	e025      	b.n	800a5ce <pbuf_free+0xf2>
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (alloc_src == PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF_POOL) {
 800a582:	230f      	movs	r3, #15
 800a584:	18fb      	adds	r3, r7, r3
 800a586:	781b      	ldrb	r3, [r3, #0]
 800a588:	2b02      	cmp	r3, #2
 800a58a:	d105      	bne.n	800a598 <pbuf_free+0xbc>
          memp_free(MEMP_PBUF_POOL, p);
 800a58c:	687b      	ldr	r3, [r7, #4]
 800a58e:	0019      	movs	r1, r3
 800a590:	2006      	movs	r0, #6
 800a592:	f7ff f8ef 	bl	8009774 <memp_free>
 800a596:	e01a      	b.n	800a5ce <pbuf_free+0xf2>
          /* is this a ROM or RAM referencing pbuf? */
        } else if (alloc_src == PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF) {
 800a598:	230f      	movs	r3, #15
 800a59a:	18fb      	adds	r3, r7, r3
 800a59c:	781b      	ldrb	r3, [r3, #0]
 800a59e:	2b01      	cmp	r3, #1
 800a5a0:	d105      	bne.n	800a5ae <pbuf_free+0xd2>
          memp_free(MEMP_PBUF, p);
 800a5a2:	687b      	ldr	r3, [r7, #4]
 800a5a4:	0019      	movs	r1, r3
 800a5a6:	2005      	movs	r0, #5
 800a5a8:	f7ff f8e4 	bl	8009774 <memp_free>
 800a5ac:	e00f      	b.n	800a5ce <pbuf_free+0xf2>
          /* type == PBUF_RAM */
        } else if (alloc_src == PBUF_TYPE_ALLOC_SRC_MASK_STD_HEAP) {
 800a5ae:	230f      	movs	r3, #15
 800a5b0:	18fb      	adds	r3, r7, r3
 800a5b2:	781b      	ldrb	r3, [r3, #0]
 800a5b4:	2b00      	cmp	r3, #0
 800a5b6:	d104      	bne.n	800a5c2 <pbuf_free+0xe6>
          mem_free(p);
 800a5b8:	687b      	ldr	r3, [r7, #4]
 800a5ba:	0018      	movs	r0, r3
 800a5bc:	f7fe fcf2 	bl	8008fa4 <mem_free>
 800a5c0:	e005      	b.n	800a5ce <pbuf_free+0xf2>
        } else {
          /* @todo: support freeing other types */
          LWIP_ASSERT("invalid pbuf type", 0);
 800a5c2:	4b0d      	ldr	r3, [pc, #52]	; (800a5f8 <pbuf_free+0x11c>)
 800a5c4:	4a13      	ldr	r2, [pc, #76]	; (800a614 <pbuf_free+0x138>)
 800a5c6:	4914      	ldr	r1, [pc, #80]	; (800a618 <pbuf_free+0x13c>)
 800a5c8:	480d      	ldr	r0, [pc, #52]	; (800a600 <pbuf_free+0x124>)
 800a5ca:	f7f7 fe0b 	bl	80021e4 <app_debug_rtt_raw>
        }
      }
      count++;
 800a5ce:	2117      	movs	r1, #23
 800a5d0:	187b      	adds	r3, r7, r1
 800a5d2:	781a      	ldrb	r2, [r3, #0]
 800a5d4:	187b      	adds	r3, r7, r1
 800a5d6:	3201      	adds	r2, #1
 800a5d8:	701a      	strb	r2, [r3, #0]
      /* proceed to next pbuf */
      p = q;
 800a5da:	693b      	ldr	r3, [r7, #16]
 800a5dc:	607b      	str	r3, [r7, #4]
 800a5de:	e001      	b.n	800a5e4 <pbuf_free+0x108>
      /* p->ref > 0, this pbuf is still referenced to */
      /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, (u16_t)ref));
      /* stop walking through the chain */
      p = NULL;
 800a5e0:	2300      	movs	r3, #0
 800a5e2:	607b      	str	r3, [r7, #4]
  while (p != NULL) {
 800a5e4:	687b      	ldr	r3, [r7, #4]
 800a5e6:	2b00      	cmp	r3, #0
 800a5e8:	d190      	bne.n	800a50c <pbuf_free+0x30>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
 800a5ea:	2317      	movs	r3, #23
 800a5ec:	18fb      	adds	r3, r7, r3
 800a5ee:	781b      	ldrb	r3, [r3, #0]
}
 800a5f0:	0018      	movs	r0, r3
 800a5f2:	46bd      	mov	sp, r7
 800a5f4:	b006      	add	sp, #24
 800a5f6:	bd80      	pop	{r7, pc}
 800a5f8:	08020514 	.word	0x08020514
 800a5fc:	08020674 	.word	0x08020674
 800a600:	0802056c 	.word	0x0802056c
 800a604:	000002f1 	.word	0x000002f1
 800a608:	080206a0 	.word	0x080206a0
 800a60c:	000002ff 	.word	0x000002ff
 800a610:	080206b8 	.word	0x080206b8
 800a614:	0000030f 	.word	0x0000030f
 800a618:	080206dc 	.word	0x080206dc

0800a61c <pbuf_clen>:
 * @param p first pbuf of chain
 * @return the number of pbufs in a chain
 */
u16_t
pbuf_clen(const struct pbuf *p)
{
 800a61c:	b580      	push	{r7, lr}
 800a61e:	b084      	sub	sp, #16
 800a620:	af00      	add	r7, sp, #0
 800a622:	6078      	str	r0, [r7, #4]
  u16_t len;

  len = 0;
 800a624:	230e      	movs	r3, #14
 800a626:	18fb      	adds	r3, r7, r3
 800a628:	2200      	movs	r2, #0
 800a62a:	801a      	strh	r2, [r3, #0]
  while (p != NULL) {
 800a62c:	e008      	b.n	800a640 <pbuf_clen+0x24>
    ++len;
 800a62e:	220e      	movs	r2, #14
 800a630:	18bb      	adds	r3, r7, r2
 800a632:	18ba      	adds	r2, r7, r2
 800a634:	8812      	ldrh	r2, [r2, #0]
 800a636:	3201      	adds	r2, #1
 800a638:	801a      	strh	r2, [r3, #0]
    p = p->next;
 800a63a:	687b      	ldr	r3, [r7, #4]
 800a63c:	681b      	ldr	r3, [r3, #0]
 800a63e:	607b      	str	r3, [r7, #4]
  while (p != NULL) {
 800a640:	687b      	ldr	r3, [r7, #4]
 800a642:	2b00      	cmp	r3, #0
 800a644:	d1f3      	bne.n	800a62e <pbuf_clen+0x12>
  }
  return len;
 800a646:	230e      	movs	r3, #14
 800a648:	18fb      	adds	r3, r7, r3
 800a64a:	881b      	ldrh	r3, [r3, #0]
}
 800a64c:	0018      	movs	r0, r3
 800a64e:	46bd      	mov	sp, r7
 800a650:	b004      	add	sp, #16
 800a652:	bd80      	pop	{r7, pc}

0800a654 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
 800a654:	b580      	push	{r7, lr}
 800a656:	b082      	sub	sp, #8
 800a658:	af00      	add	r7, sp, #0
 800a65a:	6078      	str	r0, [r7, #4]
  /* pbuf given? */
  if (p != NULL) {
 800a65c:	687b      	ldr	r3, [r7, #4]
 800a65e:	2b00      	cmp	r3, #0
 800a660:	d00f      	beq.n	800a682 <pbuf_ref+0x2e>
    SYS_ARCH_SET(p->ref, (LWIP_PBUF_REF_T)(p->ref + 1));
 800a662:	687b      	ldr	r3, [r7, #4]
 800a664:	7b9b      	ldrb	r3, [r3, #14]
 800a666:	3301      	adds	r3, #1
 800a668:	b2da      	uxtb	r2, r3
 800a66a:	687b      	ldr	r3, [r7, #4]
 800a66c:	739a      	strb	r2, [r3, #14]
    LWIP_ASSERT("pbuf ref overflow", p->ref > 0);
 800a66e:	687b      	ldr	r3, [r7, #4]
 800a670:	7b9b      	ldrb	r3, [r3, #14]
 800a672:	2b00      	cmp	r3, #0
 800a674:	d105      	bne.n	800a682 <pbuf_ref+0x2e>
 800a676:	4b05      	ldr	r3, [pc, #20]	; (800a68c <pbuf_ref+0x38>)
 800a678:	4a05      	ldr	r2, [pc, #20]	; (800a690 <pbuf_ref+0x3c>)
 800a67a:	4906      	ldr	r1, [pc, #24]	; (800a694 <pbuf_ref+0x40>)
 800a67c:	4806      	ldr	r0, [pc, #24]	; (800a698 <pbuf_ref+0x44>)
 800a67e:	f7f7 fdb1 	bl	80021e4 <app_debug_rtt_raw>
  }
}
 800a682:	46c0      	nop			; (mov r8, r8)
 800a684:	46bd      	mov	sp, r7
 800a686:	b002      	add	sp, #8
 800a688:	bd80      	pop	{r7, pc}
 800a68a:	46c0      	nop			; (mov r8, r8)
 800a68c:	08020514 	.word	0x08020514
 800a690:	00000342 	.word	0x00000342
 800a694:	080206f0 	.word	0x080206f0
 800a698:	0802056c 	.word	0x0802056c

0800a69c <pbuf_cat>:
 *
 * @see pbuf_chain()
 */
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
 800a69c:	b580      	push	{r7, lr}
 800a69e:	b084      	sub	sp, #16
 800a6a0:	af00      	add	r7, sp, #0
 800a6a2:	6078      	str	r0, [r7, #4]
 800a6a4:	6039      	str	r1, [r7, #0]
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 800a6a6:	687b      	ldr	r3, [r7, #4]
 800a6a8:	2b00      	cmp	r3, #0
 800a6aa:	d002      	beq.n	800a6b2 <pbuf_cat+0x16>
 800a6ac:	683b      	ldr	r3, [r7, #0]
 800a6ae:	2b00      	cmp	r3, #0
 800a6b0:	d104      	bne.n	800a6bc <pbuf_cat+0x20>
 800a6b2:	4b1d      	ldr	r3, [pc, #116]	; (800a728 <pbuf_cat+0x8c>)
 800a6b4:	0018      	movs	r0, r3
 800a6b6:	f7f7 fd95 	bl	80021e4 <app_debug_rtt_raw>
 800a6ba:	e032      	b.n	800a722 <pbuf_cat+0x86>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 800a6bc:	687b      	ldr	r3, [r7, #4]
 800a6be:	60fb      	str	r3, [r7, #12]
 800a6c0:	e00a      	b.n	800a6d8 <pbuf_cat+0x3c>
    /* add total length of second chain to all totals of first chain */
    p->tot_len = (u16_t)(p->tot_len + t->tot_len);
 800a6c2:	68fb      	ldr	r3, [r7, #12]
 800a6c4:	891a      	ldrh	r2, [r3, #8]
 800a6c6:	683b      	ldr	r3, [r7, #0]
 800a6c8:	891b      	ldrh	r3, [r3, #8]
 800a6ca:	18d3      	adds	r3, r2, r3
 800a6cc:	b29a      	uxth	r2, r3
 800a6ce:	68fb      	ldr	r3, [r7, #12]
 800a6d0:	811a      	strh	r2, [r3, #8]
  for (p = h; p->next != NULL; p = p->next) {
 800a6d2:	68fb      	ldr	r3, [r7, #12]
 800a6d4:	681b      	ldr	r3, [r3, #0]
 800a6d6:	60fb      	str	r3, [r7, #12]
 800a6d8:	68fb      	ldr	r3, [r7, #12]
 800a6da:	681b      	ldr	r3, [r3, #0]
 800a6dc:	2b00      	cmp	r3, #0
 800a6de:	d1f0      	bne.n	800a6c2 <pbuf_cat+0x26>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
 800a6e0:	68fb      	ldr	r3, [r7, #12]
 800a6e2:	891a      	ldrh	r2, [r3, #8]
 800a6e4:	68fb      	ldr	r3, [r7, #12]
 800a6e6:	895b      	ldrh	r3, [r3, #10]
 800a6e8:	429a      	cmp	r2, r3
 800a6ea:	d005      	beq.n	800a6f8 <pbuf_cat+0x5c>
 800a6ec:	4b0f      	ldr	r3, [pc, #60]	; (800a72c <pbuf_cat+0x90>)
 800a6ee:	4a10      	ldr	r2, [pc, #64]	; (800a730 <pbuf_cat+0x94>)
 800a6f0:	4910      	ldr	r1, [pc, #64]	; (800a734 <pbuf_cat+0x98>)
 800a6f2:	4811      	ldr	r0, [pc, #68]	; (800a738 <pbuf_cat+0x9c>)
 800a6f4:	f7f7 fd76 	bl	80021e4 <app_debug_rtt_raw>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
 800a6f8:	68fb      	ldr	r3, [r7, #12]
 800a6fa:	681b      	ldr	r3, [r3, #0]
 800a6fc:	2b00      	cmp	r3, #0
 800a6fe:	d005      	beq.n	800a70c <pbuf_cat+0x70>
 800a700:	4b0a      	ldr	r3, [pc, #40]	; (800a72c <pbuf_cat+0x90>)
 800a702:	4a0e      	ldr	r2, [pc, #56]	; (800a73c <pbuf_cat+0xa0>)
 800a704:	490e      	ldr	r1, [pc, #56]	; (800a740 <pbuf_cat+0xa4>)
 800a706:	480c      	ldr	r0, [pc, #48]	; (800a738 <pbuf_cat+0x9c>)
 800a708:	f7f7 fd6c 	bl	80021e4 <app_debug_rtt_raw>
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len = (u16_t)(p->tot_len + t->tot_len);
 800a70c:	68fb      	ldr	r3, [r7, #12]
 800a70e:	891a      	ldrh	r2, [r3, #8]
 800a710:	683b      	ldr	r3, [r7, #0]
 800a712:	891b      	ldrh	r3, [r3, #8]
 800a714:	18d3      	adds	r3, r2, r3
 800a716:	b29a      	uxth	r2, r3
 800a718:	68fb      	ldr	r3, [r7, #12]
 800a71a:	811a      	strh	r2, [r3, #8]
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
 800a71c:	68fb      	ldr	r3, [r7, #12]
 800a71e:	683a      	ldr	r2, [r7, #0]
 800a720:	601a      	str	r2, [r3, #0]
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
 800a722:	46bd      	mov	sp, r7
 800a724:	b004      	add	sp, #16
 800a726:	bd80      	pop	{r7, pc}
 800a728:	08020704 	.word	0x08020704
 800a72c:	08020514 	.word	0x08020514
 800a730:	00000362 	.word	0x00000362
 800a734:	0802073c 	.word	0x0802073c
 800a738:	0802056c 	.word	0x0802056c
 800a73c:	00000363 	.word	0x00000363
 800a740:	0802076c 	.word	0x0802076c

0800a744 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
 800a744:	b580      	push	{r7, lr}
 800a746:	b082      	sub	sp, #8
 800a748:	af00      	add	r7, sp, #0
 800a74a:	6078      	str	r0, [r7, #4]
 800a74c:	6039      	str	r1, [r7, #0]
  pbuf_cat(h, t);
 800a74e:	683a      	ldr	r2, [r7, #0]
 800a750:	687b      	ldr	r3, [r7, #4]
 800a752:	0011      	movs	r1, r2
 800a754:	0018      	movs	r0, r3
 800a756:	f7ff ffa1 	bl	800a69c <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
 800a75a:	683b      	ldr	r3, [r7, #0]
 800a75c:	0018      	movs	r0, r3
 800a75e:	f7ff ff79 	bl	800a654 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
 800a762:	46c0      	nop			; (mov r8, r8)
 800a764:	46bd      	mov	sp, r7
 800a766:	b002      	add	sp, #8
 800a768:	bd80      	pop	{r7, pc}
	...

0800a76c <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
 800a76c:	b590      	push	{r4, r7, lr}
 800a76e:	b085      	sub	sp, #20
 800a770:	af00      	add	r7, sp, #0
 800a772:	6078      	str	r0, [r7, #4]
  struct pbuf *q;
  u8_t tail_gone = 1;
 800a774:	230f      	movs	r3, #15
 800a776:	18fb      	adds	r3, r7, r3
 800a778:	2201      	movs	r2, #1
 800a77a:	701a      	strb	r2, [r3, #0]
  /* tail */
  q = p->next;
 800a77c:	687b      	ldr	r3, [r7, #4]
 800a77e:	681b      	ldr	r3, [r3, #0]
 800a780:	60bb      	str	r3, [r7, #8]
  /* pbuf has successor in chain? */
  if (q != NULL) {
 800a782:	68bb      	ldr	r3, [r7, #8]
 800a784:	2b00      	cmp	r3, #0
 800a786:	d027      	beq.n	800a7d8 <pbuf_dechain+0x6c>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
 800a788:	68bb      	ldr	r3, [r7, #8]
 800a78a:	891b      	ldrh	r3, [r3, #8]
 800a78c:	001a      	movs	r2, r3
 800a78e:	687b      	ldr	r3, [r7, #4]
 800a790:	891b      	ldrh	r3, [r3, #8]
 800a792:	0019      	movs	r1, r3
 800a794:	687b      	ldr	r3, [r7, #4]
 800a796:	895b      	ldrh	r3, [r3, #10]
 800a798:	1acb      	subs	r3, r1, r3
 800a79a:	429a      	cmp	r2, r3
 800a79c:	d005      	beq.n	800a7aa <pbuf_dechain+0x3e>
 800a79e:	4b1a      	ldr	r3, [pc, #104]	; (800a808 <pbuf_dechain+0x9c>)
 800a7a0:	4a1a      	ldr	r2, [pc, #104]	; (800a80c <pbuf_dechain+0xa0>)
 800a7a2:	491b      	ldr	r1, [pc, #108]	; (800a810 <pbuf_dechain+0xa4>)
 800a7a4:	481b      	ldr	r0, [pc, #108]	; (800a814 <pbuf_dechain+0xa8>)
 800a7a6:	f7f7 fd1d 	bl	80021e4 <app_debug_rtt_raw>
    /* enforce invariant if assertion is disabled */
    q->tot_len = (u16_t)(p->tot_len - p->len);
 800a7aa:	687b      	ldr	r3, [r7, #4]
 800a7ac:	891a      	ldrh	r2, [r3, #8]
 800a7ae:	687b      	ldr	r3, [r7, #4]
 800a7b0:	895b      	ldrh	r3, [r3, #10]
 800a7b2:	1ad3      	subs	r3, r2, r3
 800a7b4:	b29a      	uxth	r2, r3
 800a7b6:	68bb      	ldr	r3, [r7, #8]
 800a7b8:	811a      	strh	r2, [r3, #8]
    /* decouple pbuf from remainder */
    p->next = NULL;
 800a7ba:	687b      	ldr	r3, [r7, #4]
 800a7bc:	2200      	movs	r2, #0
 800a7be:	601a      	str	r2, [r3, #0]
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
 800a7c0:	687b      	ldr	r3, [r7, #4]
 800a7c2:	895a      	ldrh	r2, [r3, #10]
 800a7c4:	687b      	ldr	r3, [r7, #4]
 800a7c6:	811a      	strh	r2, [r3, #8]
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
 800a7c8:	230f      	movs	r3, #15
 800a7ca:	18fc      	adds	r4, r7, r3
 800a7cc:	68bb      	ldr	r3, [r7, #8]
 800a7ce:	0018      	movs	r0, r3
 800a7d0:	f7ff fe84 	bl	800a4dc <pbuf_free>
 800a7d4:	0003      	movs	r3, r0
 800a7d6:	7023      	strb	r3, [r4, #0]
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
 800a7d8:	687b      	ldr	r3, [r7, #4]
 800a7da:	891a      	ldrh	r2, [r3, #8]
 800a7dc:	687b      	ldr	r3, [r7, #4]
 800a7de:	895b      	ldrh	r3, [r3, #10]
 800a7e0:	429a      	cmp	r2, r3
 800a7e2:	d005      	beq.n	800a7f0 <pbuf_dechain+0x84>
 800a7e4:	4b08      	ldr	r3, [pc, #32]	; (800a808 <pbuf_dechain+0x9c>)
 800a7e6:	4a0c      	ldr	r2, [pc, #48]	; (800a818 <pbuf_dechain+0xac>)
 800a7e8:	490c      	ldr	r1, [pc, #48]	; (800a81c <pbuf_dechain+0xb0>)
 800a7ea:	480a      	ldr	r0, [pc, #40]	; (800a814 <pbuf_dechain+0xa8>)
 800a7ec:	f7f7 fcfa 	bl	80021e4 <app_debug_rtt_raw>
  return ((tail_gone > 0) ? NULL : q);
 800a7f0:	230f      	movs	r3, #15
 800a7f2:	18fb      	adds	r3, r7, r3
 800a7f4:	781b      	ldrb	r3, [r3, #0]
 800a7f6:	2b00      	cmp	r3, #0
 800a7f8:	d101      	bne.n	800a7fe <pbuf_dechain+0x92>
 800a7fa:	68bb      	ldr	r3, [r7, #8]
 800a7fc:	e000      	b.n	800a800 <pbuf_dechain+0x94>
 800a7fe:	2300      	movs	r3, #0
}
 800a800:	0018      	movs	r0, r3
 800a802:	46bd      	mov	sp, r7
 800a804:	b005      	add	sp, #20
 800a806:	bd90      	pop	{r4, r7, pc}
 800a808:	08020514 	.word	0x08020514
 800a80c:	00000399 	.word	0x00000399
 800a810:	0802077c 	.word	0x0802077c
 800a814:	0802056c 	.word	0x0802056c
 800a818:	000003aa 	.word	0x000003aa
 800a81c:	080207a0 	.word	0x080207a0

0800a820 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, const struct pbuf *p_from)
{
 800a820:	b580      	push	{r7, lr}
 800a822:	b082      	sub	sp, #8
 800a824:	af00      	add	r7, sp, #0
 800a826:	6078      	str	r0, [r7, #4]
 800a828:	6039      	str	r1, [r7, #0]
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
              (const void *)p_to, (const void *)p_from));

  LWIP_ERROR("pbuf_copy: invalid source", p_from != NULL, return ERR_ARG;);
 800a82a:	683b      	ldr	r3, [r7, #0]
 800a82c:	2b00      	cmp	r3, #0
 800a82e:	d106      	bne.n	800a83e <pbuf_copy+0x1e>
 800a830:	4b09      	ldr	r3, [pc, #36]	; (800a858 <pbuf_copy+0x38>)
 800a832:	0018      	movs	r0, r3
 800a834:	f7f7 fcd6 	bl	80021e4 <app_debug_rtt_raw>
 800a838:	2310      	movs	r3, #16
 800a83a:	425b      	negs	r3, r3
 800a83c:	e007      	b.n	800a84e <pbuf_copy+0x2e>
  return pbuf_copy_partial_pbuf(p_to, p_from, p_from->tot_len, 0);
 800a83e:	683b      	ldr	r3, [r7, #0]
 800a840:	891a      	ldrh	r2, [r3, #8]
 800a842:	6839      	ldr	r1, [r7, #0]
 800a844:	6878      	ldr	r0, [r7, #4]
 800a846:	2300      	movs	r3, #0
 800a848:	f000 f808 	bl	800a85c <pbuf_copy_partial_pbuf>
 800a84c:	0003      	movs	r3, r0
}
 800a84e:	0018      	movs	r0, r3
 800a850:	46bd      	mov	sp, r7
 800a852:	b002      	add	sp, #8
 800a854:	bd80      	pop	{r7, pc}
 800a856:	46c0      	nop			; (mov r8, r8)
 800a858:	080207b8 	.word	0x080207b8

0800a85c <pbuf_copy_partial_pbuf>:
 *                 or p_to is not big enough to hold copy_len at offset
 *         ERR_VAL if any of the pbufs are part of a queue
 */
err_t
pbuf_copy_partial_pbuf(struct pbuf *p_to, const struct pbuf *p_from, u16_t copy_len, u16_t offset)
{
 800a85c:	b590      	push	{r4, r7, lr}
 800a85e:	b089      	sub	sp, #36	; 0x24
 800a860:	af00      	add	r7, sp, #0
 800a862:	60f8      	str	r0, [r7, #12]
 800a864:	60b9      	str	r1, [r7, #8]
 800a866:	0019      	movs	r1, r3
 800a868:	1dbb      	adds	r3, r7, #6
 800a86a:	801a      	strh	r2, [r3, #0]
 800a86c:	1d3b      	adds	r3, r7, #4
 800a86e:	1c0a      	adds	r2, r1, #0
 800a870:	801a      	strh	r2, [r3, #0]
  size_t offset_to = offset, offset_from = 0, len_calc;
 800a872:	1d3b      	adds	r3, r7, #4
 800a874:	881b      	ldrh	r3, [r3, #0]
 800a876:	61fb      	str	r3, [r7, #28]
 800a878:	2300      	movs	r3, #0
 800a87a:	61bb      	str	r3, [r7, #24]

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy_partial_pbuf(%p, %p, %"U16_F", %"U16_F")\n",
              (const void *)p_to, (const void *)p_from, copy_len, offset));

  /* is the copy_len in range? */
  LWIP_ERROR("pbuf_copy_partial_pbuf: copy_len bigger than source", ((p_from != NULL) &&
 800a87c:	68bb      	ldr	r3, [r7, #8]
 800a87e:	2b00      	cmp	r3, #0
 800a880:	d005      	beq.n	800a88e <pbuf_copy_partial_pbuf+0x32>
 800a882:	68bb      	ldr	r3, [r7, #8]
 800a884:	891b      	ldrh	r3, [r3, #8]
 800a886:	1dba      	adds	r2, r7, #6
 800a888:	8812      	ldrh	r2, [r2, #0]
 800a88a:	429a      	cmp	r2, r3
 800a88c:	d906      	bls.n	800a89c <pbuf_copy_partial_pbuf+0x40>
 800a88e:	4b6d      	ldr	r3, [pc, #436]	; (800aa44 <pbuf_copy_partial_pbuf+0x1e8>)
 800a890:	0018      	movs	r0, r3
 800a892:	f7f7 fca7 	bl	80021e4 <app_debug_rtt_raw>
 800a896:	2310      	movs	r3, #16
 800a898:	425b      	negs	r3, r3
 800a89a:	e0cf      	b.n	800aa3c <pbuf_copy_partial_pbuf+0x1e0>
             (p_from->tot_len >= copy_len)), return ERR_ARG;);
  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy_partial_pbuf: target not big enough", ((p_to != NULL) &&
 800a89c:	68fb      	ldr	r3, [r7, #12]
 800a89e:	2b00      	cmp	r3, #0
 800a8a0:	d009      	beq.n	800a8b6 <pbuf_copy_partial_pbuf+0x5a>
 800a8a2:	68fb      	ldr	r3, [r7, #12]
 800a8a4:	891b      	ldrh	r3, [r3, #8]
 800a8a6:	0019      	movs	r1, r3
 800a8a8:	1d3b      	adds	r3, r7, #4
 800a8aa:	881a      	ldrh	r2, [r3, #0]
 800a8ac:	1dbb      	adds	r3, r7, #6
 800a8ae:	881b      	ldrh	r3, [r3, #0]
 800a8b0:	18d3      	adds	r3, r2, r3
 800a8b2:	4299      	cmp	r1, r3
 800a8b4:	da06      	bge.n	800a8c4 <pbuf_copy_partial_pbuf+0x68>
 800a8b6:	4b64      	ldr	r3, [pc, #400]	; (800aa48 <pbuf_copy_partial_pbuf+0x1ec>)
 800a8b8:	0018      	movs	r0, r3
 800a8ba:	f7f7 fc93 	bl	80021e4 <app_debug_rtt_raw>
 800a8be:	2310      	movs	r3, #16
 800a8c0:	425b      	negs	r3, r3
 800a8c2:	e0bb      	b.n	800aa3c <pbuf_copy_partial_pbuf+0x1e0>
             (p_to->tot_len >= (offset + copy_len))), return ERR_ARG;);

  /* iterate through pbuf chain */
  do {
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
 800a8c4:	68fb      	ldr	r3, [r7, #12]
 800a8c6:	895b      	ldrh	r3, [r3, #10]
 800a8c8:	001a      	movs	r2, r3
 800a8ca:	69fb      	ldr	r3, [r7, #28]
 800a8cc:	1ad2      	subs	r2, r2, r3
 800a8ce:	68bb      	ldr	r3, [r7, #8]
 800a8d0:	895b      	ldrh	r3, [r3, #10]
 800a8d2:	0019      	movs	r1, r3
 800a8d4:	69bb      	ldr	r3, [r7, #24]
 800a8d6:	1acb      	subs	r3, r1, r3
 800a8d8:	429a      	cmp	r2, r3
 800a8da:	d306      	bcc.n	800a8ea <pbuf_copy_partial_pbuf+0x8e>
      /* complete current p_from fits into current p_to */
      len_calc = p_from->len - offset_from;
 800a8dc:	68bb      	ldr	r3, [r7, #8]
 800a8de:	895b      	ldrh	r3, [r3, #10]
 800a8e0:	001a      	movs	r2, r3
 800a8e2:	69bb      	ldr	r3, [r7, #24]
 800a8e4:	1ad3      	subs	r3, r2, r3
 800a8e6:	617b      	str	r3, [r7, #20]
 800a8e8:	e005      	b.n	800a8f6 <pbuf_copy_partial_pbuf+0x9a>
    } else {
      /* current p_from does not fit into current p_to */
      len_calc = p_to->len - offset_to;
 800a8ea:	68fb      	ldr	r3, [r7, #12]
 800a8ec:	895b      	ldrh	r3, [r3, #10]
 800a8ee:	001a      	movs	r2, r3
 800a8f0:	69fb      	ldr	r3, [r7, #28]
 800a8f2:	1ad3      	subs	r3, r2, r3
 800a8f4:	617b      	str	r3, [r7, #20]
    }
    len = (u16_t)LWIP_MIN(copy_len, len_calc);
 800a8f6:	1dbb      	adds	r3, r7, #6
 800a8f8:	881b      	ldrh	r3, [r3, #0]
 800a8fa:	697a      	ldr	r2, [r7, #20]
 800a8fc:	429a      	cmp	r2, r3
 800a8fe:	d802      	bhi.n	800a906 <pbuf_copy_partial_pbuf+0xaa>
 800a900:	697b      	ldr	r3, [r7, #20]
 800a902:	b29b      	uxth	r3, r3
 800a904:	e001      	b.n	800a90a <pbuf_copy_partial_pbuf+0xae>
 800a906:	1dbb      	adds	r3, r7, #6
 800a908:	881b      	ldrh	r3, [r3, #0]
 800a90a:	2412      	movs	r4, #18
 800a90c:	193a      	adds	r2, r7, r4
 800a90e:	8013      	strh	r3, [r2, #0]
    MEMCPY((u8_t *)p_to->payload + offset_to, (u8_t *)p_from->payload + offset_from, len);
 800a910:	68fb      	ldr	r3, [r7, #12]
 800a912:	685a      	ldr	r2, [r3, #4]
 800a914:	69fb      	ldr	r3, [r7, #28]
 800a916:	18d0      	adds	r0, r2, r3
 800a918:	68bb      	ldr	r3, [r7, #8]
 800a91a:	685a      	ldr	r2, [r3, #4]
 800a91c:	69bb      	ldr	r3, [r7, #24]
 800a91e:	18d1      	adds	r1, r2, r3
 800a920:	193b      	adds	r3, r7, r4
 800a922:	881b      	ldrh	r3, [r3, #0]
 800a924:	001a      	movs	r2, r3
 800a926:	f013 fb39 	bl	801df9c <memcpy>
    offset_to += len;
 800a92a:	193b      	adds	r3, r7, r4
 800a92c:	881b      	ldrh	r3, [r3, #0]
 800a92e:	69fa      	ldr	r2, [r7, #28]
 800a930:	18d3      	adds	r3, r2, r3
 800a932:	61fb      	str	r3, [r7, #28]
    offset_from += len;
 800a934:	193b      	adds	r3, r7, r4
 800a936:	881b      	ldrh	r3, [r3, #0]
 800a938:	69ba      	ldr	r2, [r7, #24]
 800a93a:	18d3      	adds	r3, r2, r3
 800a93c:	61bb      	str	r3, [r7, #24]
    copy_len -= len;
 800a93e:	1dbb      	adds	r3, r7, #6
 800a940:	1db9      	adds	r1, r7, #6
 800a942:	193a      	adds	r2, r7, r4
 800a944:	8809      	ldrh	r1, [r1, #0]
 800a946:	8812      	ldrh	r2, [r2, #0]
 800a948:	1a8a      	subs	r2, r1, r2
 800a94a:	801a      	strh	r2, [r3, #0]
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 800a94c:	68fb      	ldr	r3, [r7, #12]
 800a94e:	895b      	ldrh	r3, [r3, #10]
 800a950:	001a      	movs	r2, r3
 800a952:	69fb      	ldr	r3, [r7, #28]
 800a954:	4293      	cmp	r3, r2
 800a956:	d905      	bls.n	800a964 <pbuf_copy_partial_pbuf+0x108>
 800a958:	4b3c      	ldr	r3, [pc, #240]	; (800aa4c <pbuf_copy_partial_pbuf+0x1f0>)
 800a95a:	4a3d      	ldr	r2, [pc, #244]	; (800aa50 <pbuf_copy_partial_pbuf+0x1f4>)
 800a95c:	493d      	ldr	r1, [pc, #244]	; (800aa54 <pbuf_copy_partial_pbuf+0x1f8>)
 800a95e:	483e      	ldr	r0, [pc, #248]	; (800aa58 <pbuf_copy_partial_pbuf+0x1fc>)
 800a960:	f7f7 fc40 	bl	80021e4 <app_debug_rtt_raw>
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
 800a964:	68bb      	ldr	r3, [r7, #8]
 800a966:	895b      	ldrh	r3, [r3, #10]
 800a968:	001a      	movs	r2, r3
 800a96a:	69bb      	ldr	r3, [r7, #24]
 800a96c:	4293      	cmp	r3, r2
 800a96e:	d905      	bls.n	800a97c <pbuf_copy_partial_pbuf+0x120>
 800a970:	4b36      	ldr	r3, [pc, #216]	; (800aa4c <pbuf_copy_partial_pbuf+0x1f0>)
 800a972:	4a3a      	ldr	r2, [pc, #232]	; (800aa5c <pbuf_copy_partial_pbuf+0x200>)
 800a974:	493a      	ldr	r1, [pc, #232]	; (800aa60 <pbuf_copy_partial_pbuf+0x204>)
 800a976:	4838      	ldr	r0, [pc, #224]	; (800aa58 <pbuf_copy_partial_pbuf+0x1fc>)
 800a978:	f7f7 fc34 	bl	80021e4 <app_debug_rtt_raw>
    if (offset_from >= p_from->len) {
 800a97c:	68bb      	ldr	r3, [r7, #8]
 800a97e:	895b      	ldrh	r3, [r3, #10]
 800a980:	001a      	movs	r2, r3
 800a982:	69bb      	ldr	r3, [r7, #24]
 800a984:	4293      	cmp	r3, r2
 800a986:	d312      	bcc.n	800a9ae <pbuf_copy_partial_pbuf+0x152>
      /* on to next p_from (if any) */
      offset_from = 0;
 800a988:	2300      	movs	r3, #0
 800a98a:	61bb      	str	r3, [r7, #24]
      p_from = p_from->next;
 800a98c:	68bb      	ldr	r3, [r7, #8]
 800a98e:	681b      	ldr	r3, [r3, #0]
 800a990:	60bb      	str	r3, [r7, #8]
      LWIP_ERROR("p_from != NULL", (p_from != NULL) || (copy_len == 0), return ERR_ARG;);
 800a992:	68bb      	ldr	r3, [r7, #8]
 800a994:	2b00      	cmp	r3, #0
 800a996:	d10a      	bne.n	800a9ae <pbuf_copy_partial_pbuf+0x152>
 800a998:	1dbb      	adds	r3, r7, #6
 800a99a:	881b      	ldrh	r3, [r3, #0]
 800a99c:	2b00      	cmp	r3, #0
 800a99e:	d006      	beq.n	800a9ae <pbuf_copy_partial_pbuf+0x152>
 800a9a0:	4b30      	ldr	r3, [pc, #192]	; (800aa64 <pbuf_copy_partial_pbuf+0x208>)
 800a9a2:	0018      	movs	r0, r3
 800a9a4:	f7f7 fc1e 	bl	80021e4 <app_debug_rtt_raw>
 800a9a8:	2310      	movs	r3, #16
 800a9aa:	425b      	negs	r3, r3
 800a9ac:	e046      	b.n	800aa3c <pbuf_copy_partial_pbuf+0x1e0>
    }
    if (offset_to == p_to->len) {
 800a9ae:	68fb      	ldr	r3, [r7, #12]
 800a9b0:	895b      	ldrh	r3, [r3, #10]
 800a9b2:	001a      	movs	r2, r3
 800a9b4:	69fb      	ldr	r3, [r7, #28]
 800a9b6:	4293      	cmp	r3, r2
 800a9b8:	d112      	bne.n	800a9e0 <pbuf_copy_partial_pbuf+0x184>
      /* on to next p_to (if any) */
      offset_to = 0;
 800a9ba:	2300      	movs	r3, #0
 800a9bc:	61fb      	str	r3, [r7, #28]
      p_to = p_to->next;
 800a9be:	68fb      	ldr	r3, [r7, #12]
 800a9c0:	681b      	ldr	r3, [r3, #0]
 800a9c2:	60fb      	str	r3, [r7, #12]
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (copy_len == 0), return ERR_ARG;);
 800a9c4:	68fb      	ldr	r3, [r7, #12]
 800a9c6:	2b00      	cmp	r3, #0
 800a9c8:	d10a      	bne.n	800a9e0 <pbuf_copy_partial_pbuf+0x184>
 800a9ca:	1dbb      	adds	r3, r7, #6
 800a9cc:	881b      	ldrh	r3, [r3, #0]
 800a9ce:	2b00      	cmp	r3, #0
 800a9d0:	d006      	beq.n	800a9e0 <pbuf_copy_partial_pbuf+0x184>
 800a9d2:	4b25      	ldr	r3, [pc, #148]	; (800aa68 <pbuf_copy_partial_pbuf+0x20c>)
 800a9d4:	0018      	movs	r0, r3
 800a9d6:	f7f7 fc05 	bl	80021e4 <app_debug_rtt_raw>
 800a9da:	2310      	movs	r3, #16
 800a9dc:	425b      	negs	r3, r3
 800a9de:	e02d      	b.n	800aa3c <pbuf_copy_partial_pbuf+0x1e0>
    }

    if ((p_from != NULL) && (p_from->len == p_from->tot_len)) {
 800a9e0:	68bb      	ldr	r3, [r7, #8]
 800a9e2:	2b00      	cmp	r3, #0
 800a9e4:	d010      	beq.n	800aa08 <pbuf_copy_partial_pbuf+0x1ac>
 800a9e6:	68bb      	ldr	r3, [r7, #8]
 800a9e8:	895a      	ldrh	r2, [r3, #10]
 800a9ea:	68bb      	ldr	r3, [r7, #8]
 800a9ec:	891b      	ldrh	r3, [r3, #8]
 800a9ee:	429a      	cmp	r2, r3
 800a9f0:	d10a      	bne.n	800aa08 <pbuf_copy_partial_pbuf+0x1ac>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy_partial_pbuf() does not allow packet queues!",
 800a9f2:	68bb      	ldr	r3, [r7, #8]
 800a9f4:	681b      	ldr	r3, [r3, #0]
 800a9f6:	2b00      	cmp	r3, #0
 800a9f8:	d006      	beq.n	800aa08 <pbuf_copy_partial_pbuf+0x1ac>
 800a9fa:	4b1c      	ldr	r3, [pc, #112]	; (800aa6c <pbuf_copy_partial_pbuf+0x210>)
 800a9fc:	0018      	movs	r0, r3
 800a9fe:	f7f7 fbf1 	bl	80021e4 <app_debug_rtt_raw>
 800aa02:	2306      	movs	r3, #6
 800aa04:	425b      	negs	r3, r3
 800aa06:	e019      	b.n	800aa3c <pbuf_copy_partial_pbuf+0x1e0>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if ((p_to != NULL) && (p_to->len == p_to->tot_len)) {
 800aa08:	68fb      	ldr	r3, [r7, #12]
 800aa0a:	2b00      	cmp	r3, #0
 800aa0c:	d010      	beq.n	800aa30 <pbuf_copy_partial_pbuf+0x1d4>
 800aa0e:	68fb      	ldr	r3, [r7, #12]
 800aa10:	895a      	ldrh	r2, [r3, #10]
 800aa12:	68fb      	ldr	r3, [r7, #12]
 800aa14:	891b      	ldrh	r3, [r3, #8]
 800aa16:	429a      	cmp	r2, r3
 800aa18:	d10a      	bne.n	800aa30 <pbuf_copy_partial_pbuf+0x1d4>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy_partial_pbuf() does not allow packet queues!",
 800aa1a:	68fb      	ldr	r3, [r7, #12]
 800aa1c:	681b      	ldr	r3, [r3, #0]
 800aa1e:	2b00      	cmp	r3, #0
 800aa20:	d006      	beq.n	800aa30 <pbuf_copy_partial_pbuf+0x1d4>
 800aa22:	4b12      	ldr	r3, [pc, #72]	; (800aa6c <pbuf_copy_partial_pbuf+0x210>)
 800aa24:	0018      	movs	r0, r3
 800aa26:	f7f7 fbdd 	bl	80021e4 <app_debug_rtt_raw>
 800aa2a:	2306      	movs	r3, #6
 800aa2c:	425b      	negs	r3, r3
 800aa2e:	e005      	b.n	800aa3c <pbuf_copy_partial_pbuf+0x1e0>
                 (p_to->next == NULL), return ERR_VAL;);
    }
  } while (copy_len);
 800aa30:	1dbb      	adds	r3, r7, #6
 800aa32:	881b      	ldrh	r3, [r3, #0]
 800aa34:	2b00      	cmp	r3, #0
 800aa36:	d000      	beq.n	800aa3a <pbuf_copy_partial_pbuf+0x1de>
 800aa38:	e744      	b.n	800a8c4 <pbuf_copy_partial_pbuf+0x68>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy_partial_pbuf: copy complete.\n"));
  return ERR_OK;
 800aa3a:	2300      	movs	r3, #0
}
 800aa3c:	0018      	movs	r0, r3
 800aa3e:	46bd      	mov	sp, r7
 800aa40:	b009      	add	sp, #36	; 0x24
 800aa42:	bd90      	pop	{r4, r7, pc}
 800aa44:	080207d4 	.word	0x080207d4
 800aa48:	08020808 	.word	0x08020808
 800aa4c:	08020514 	.word	0x08020514
 800aa50:	000003fa 	.word	0x000003fa
 800aa54:	08020838 	.word	0x08020838
 800aa58:	0802056c 	.word	0x0802056c
 800aa5c:	000003fb 	.word	0x000003fb
 800aa60:	08020850 	.word	0x08020850
 800aa64:	0802086c 	.word	0x0802086c
 800aa68:	0802087c 	.word	0x0802087c
 800aa6c:	0802088c 	.word	0x0802088c

0800aa70 <pbuf_copy_partial>:
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t
pbuf_copy_partial(const struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
 800aa70:	b5b0      	push	{r4, r5, r7, lr}
 800aa72:	b088      	sub	sp, #32
 800aa74:	af00      	add	r7, sp, #0
 800aa76:	60f8      	str	r0, [r7, #12]
 800aa78:	60b9      	str	r1, [r7, #8]
 800aa7a:	0019      	movs	r1, r3
 800aa7c:	1dbb      	adds	r3, r7, #6
 800aa7e:	801a      	strh	r2, [r3, #0]
 800aa80:	1d3b      	adds	r3, r7, #4
 800aa82:	1c0a      	adds	r2, r1, #0
 800aa84:	801a      	strh	r2, [r3, #0]
  const struct pbuf *p;
  u16_t left = 0;
 800aa86:	231a      	movs	r3, #26
 800aa88:	18fb      	adds	r3, r7, r3
 800aa8a:	2200      	movs	r2, #0
 800aa8c:	801a      	strh	r2, [r3, #0]
  u16_t buf_copy_len;
  u16_t copied_total = 0;
 800aa8e:	2316      	movs	r3, #22
 800aa90:	18fb      	adds	r3, r7, r3
 800aa92:	2200      	movs	r2, #0
 800aa94:	801a      	strh	r2, [r3, #0]

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 800aa96:	68fb      	ldr	r3, [r7, #12]
 800aa98:	2b00      	cmp	r3, #0
 800aa9a:	d105      	bne.n	800aaa8 <pbuf_copy_partial+0x38>
 800aa9c:	4b38      	ldr	r3, [pc, #224]	; (800ab80 <pbuf_copy_partial+0x110>)
 800aa9e:	0018      	movs	r0, r3
 800aaa0:	f7f7 fba0 	bl	80021e4 <app_debug_rtt_raw>
 800aaa4:	2300      	movs	r3, #0
 800aaa6:	e066      	b.n	800ab76 <pbuf_copy_partial+0x106>
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 800aaa8:	68bb      	ldr	r3, [r7, #8]
 800aaaa:	2b00      	cmp	r3, #0
 800aaac:	d105      	bne.n	800aaba <pbuf_copy_partial+0x4a>
 800aaae:	4b35      	ldr	r3, [pc, #212]	; (800ab84 <pbuf_copy_partial+0x114>)
 800aab0:	0018      	movs	r0, r3
 800aab2:	f7f7 fb97 	bl	80021e4 <app_debug_rtt_raw>
 800aab6:	2300      	movs	r3, #0
 800aab8:	e05d      	b.n	800ab76 <pbuf_copy_partial+0x106>

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for (p = buf; len != 0 && p != NULL; p = p->next) {
 800aaba:	68fb      	ldr	r3, [r7, #12]
 800aabc:	61fb      	str	r3, [r7, #28]
 800aabe:	e050      	b.n	800ab62 <pbuf_copy_partial+0xf2>
    if ((offset != 0) && (offset >= p->len)) {
 800aac0:	1d3b      	adds	r3, r7, #4
 800aac2:	881b      	ldrh	r3, [r3, #0]
 800aac4:	2b00      	cmp	r3, #0
 800aac6:	d00d      	beq.n	800aae4 <pbuf_copy_partial+0x74>
 800aac8:	69fb      	ldr	r3, [r7, #28]
 800aaca:	895b      	ldrh	r3, [r3, #10]
 800aacc:	1d3a      	adds	r2, r7, #4
 800aace:	8812      	ldrh	r2, [r2, #0]
 800aad0:	429a      	cmp	r2, r3
 800aad2:	d307      	bcc.n	800aae4 <pbuf_copy_partial+0x74>
      /* don't copy from this buffer -> on to the next */
      offset = (u16_t)(offset - p->len);
 800aad4:	69fb      	ldr	r3, [r7, #28]
 800aad6:	895a      	ldrh	r2, [r3, #10]
 800aad8:	1d3b      	adds	r3, r7, #4
 800aada:	1d39      	adds	r1, r7, #4
 800aadc:	8809      	ldrh	r1, [r1, #0]
 800aade:	1a8a      	subs	r2, r1, r2
 800aae0:	801a      	strh	r2, [r3, #0]
 800aae2:	e03b      	b.n	800ab5c <pbuf_copy_partial+0xec>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = (u16_t)(p->len - offset);
 800aae4:	69fb      	ldr	r3, [r7, #28]
 800aae6:	8959      	ldrh	r1, [r3, #10]
 800aae8:	2018      	movs	r0, #24
 800aaea:	183b      	adds	r3, r7, r0
 800aaec:	1d3a      	adds	r2, r7, #4
 800aaee:	8812      	ldrh	r2, [r2, #0]
 800aaf0:	1a8a      	subs	r2, r1, r2
 800aaf2:	801a      	strh	r2, [r3, #0]
      if (buf_copy_len > len) {
 800aaf4:	183a      	adds	r2, r7, r0
 800aaf6:	1dbb      	adds	r3, r7, #6
 800aaf8:	8812      	ldrh	r2, [r2, #0]
 800aafa:	881b      	ldrh	r3, [r3, #0]
 800aafc:	429a      	cmp	r2, r3
 800aafe:	d903      	bls.n	800ab08 <pbuf_copy_partial+0x98>
        buf_copy_len = len;
 800ab00:	183b      	adds	r3, r7, r0
 800ab02:	1dba      	adds	r2, r7, #6
 800ab04:	8812      	ldrh	r2, [r2, #0]
 800ab06:	801a      	strh	r2, [r3, #0]
      }
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char *)dataptr)[left], &((char *)p->payload)[offset], buf_copy_len);
 800ab08:	251a      	movs	r5, #26
 800ab0a:	197b      	adds	r3, r7, r5
 800ab0c:	881b      	ldrh	r3, [r3, #0]
 800ab0e:	68ba      	ldr	r2, [r7, #8]
 800ab10:	18d0      	adds	r0, r2, r3
 800ab12:	69fb      	ldr	r3, [r7, #28]
 800ab14:	685a      	ldr	r2, [r3, #4]
 800ab16:	1d3b      	adds	r3, r7, #4
 800ab18:	881b      	ldrh	r3, [r3, #0]
 800ab1a:	18d1      	adds	r1, r2, r3
 800ab1c:	2418      	movs	r4, #24
 800ab1e:	193b      	adds	r3, r7, r4
 800ab20:	881b      	ldrh	r3, [r3, #0]
 800ab22:	001a      	movs	r2, r3
 800ab24:	f013 fa3a 	bl	801df9c <memcpy>
      copied_total = (u16_t)(copied_total + buf_copy_len);
 800ab28:	2216      	movs	r2, #22
 800ab2a:	18bb      	adds	r3, r7, r2
 800ab2c:	18b9      	adds	r1, r7, r2
 800ab2e:	0020      	movs	r0, r4
 800ab30:	183a      	adds	r2, r7, r0
 800ab32:	8809      	ldrh	r1, [r1, #0]
 800ab34:	8812      	ldrh	r2, [r2, #0]
 800ab36:	188a      	adds	r2, r1, r2
 800ab38:	801a      	strh	r2, [r3, #0]
      left = (u16_t)(left + buf_copy_len);
 800ab3a:	197b      	adds	r3, r7, r5
 800ab3c:	1979      	adds	r1, r7, r5
 800ab3e:	183a      	adds	r2, r7, r0
 800ab40:	8809      	ldrh	r1, [r1, #0]
 800ab42:	8812      	ldrh	r2, [r2, #0]
 800ab44:	188a      	adds	r2, r1, r2
 800ab46:	801a      	strh	r2, [r3, #0]
      len = (u16_t)(len - buf_copy_len);
 800ab48:	1dbb      	adds	r3, r7, #6
 800ab4a:	1db9      	adds	r1, r7, #6
 800ab4c:	183a      	adds	r2, r7, r0
 800ab4e:	8809      	ldrh	r1, [r1, #0]
 800ab50:	8812      	ldrh	r2, [r2, #0]
 800ab52:	1a8a      	subs	r2, r1, r2
 800ab54:	801a      	strh	r2, [r3, #0]
      offset = 0;
 800ab56:	1d3b      	adds	r3, r7, #4
 800ab58:	2200      	movs	r2, #0
 800ab5a:	801a      	strh	r2, [r3, #0]
  for (p = buf; len != 0 && p != NULL; p = p->next) {
 800ab5c:	69fb      	ldr	r3, [r7, #28]
 800ab5e:	681b      	ldr	r3, [r3, #0]
 800ab60:	61fb      	str	r3, [r7, #28]
 800ab62:	1dbb      	adds	r3, r7, #6
 800ab64:	881b      	ldrh	r3, [r3, #0]
 800ab66:	2b00      	cmp	r3, #0
 800ab68:	d002      	beq.n	800ab70 <pbuf_copy_partial+0x100>
 800ab6a:	69fb      	ldr	r3, [r7, #28]
 800ab6c:	2b00      	cmp	r3, #0
 800ab6e:	d1a7      	bne.n	800aac0 <pbuf_copy_partial+0x50>
    }
  }
  return copied_total;
 800ab70:	2316      	movs	r3, #22
 800ab72:	18fb      	adds	r3, r7, r3
 800ab74:	881b      	ldrh	r3, [r3, #0]
}
 800ab76:	0018      	movs	r0, r3
 800ab78:	46bd      	mov	sp, r7
 800ab7a:	b008      	add	sp, #32
 800ab7c:	bdb0      	pop	{r4, r5, r7, pc}
 800ab7e:	46c0      	nop			; (mov r8, r8)
 800ab80:	080208c4 	.word	0x080208c4
 800ab84:	080208e4 	.word	0x080208e4

0800ab88 <pbuf_skip_const>:
#endif /* LWIP_TCP && TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */

/* Actual implementation of pbuf_skip() but returning const pointer... */
static const struct pbuf *
pbuf_skip_const(const struct pbuf *in, u16_t in_offset, u16_t *out_offset)
{
 800ab88:	b580      	push	{r7, lr}
 800ab8a:	b086      	sub	sp, #24
 800ab8c:	af00      	add	r7, sp, #0
 800ab8e:	60f8      	str	r0, [r7, #12]
 800ab90:	607a      	str	r2, [r7, #4]
 800ab92:	200a      	movs	r0, #10
 800ab94:	183b      	adds	r3, r7, r0
 800ab96:	1c0a      	adds	r2, r1, #0
 800ab98:	801a      	strh	r2, [r3, #0]
  u16_t offset_left = in_offset;
 800ab9a:	2316      	movs	r3, #22
 800ab9c:	18fb      	adds	r3, r7, r3
 800ab9e:	183a      	adds	r2, r7, r0
 800aba0:	8812      	ldrh	r2, [r2, #0]
 800aba2:	801a      	strh	r2, [r3, #0]
  const struct pbuf *q = in;
 800aba4:	68fb      	ldr	r3, [r7, #12]
 800aba6:	613b      	str	r3, [r7, #16]

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= offset_left)) {
 800aba8:	e00a      	b.n	800abc0 <pbuf_skip_const+0x38>
    offset_left = (u16_t)(offset_left - q->len);
 800abaa:	693b      	ldr	r3, [r7, #16]
 800abac:	895a      	ldrh	r2, [r3, #10]
 800abae:	2116      	movs	r1, #22
 800abb0:	187b      	adds	r3, r7, r1
 800abb2:	1879      	adds	r1, r7, r1
 800abb4:	8809      	ldrh	r1, [r1, #0]
 800abb6:	1a8a      	subs	r2, r1, r2
 800abb8:	801a      	strh	r2, [r3, #0]
    q = q->next;
 800abba:	693b      	ldr	r3, [r7, #16]
 800abbc:	681b      	ldr	r3, [r3, #0]
 800abbe:	613b      	str	r3, [r7, #16]
  while ((q != NULL) && (q->len <= offset_left)) {
 800abc0:	693b      	ldr	r3, [r7, #16]
 800abc2:	2b00      	cmp	r3, #0
 800abc4:	d006      	beq.n	800abd4 <pbuf_skip_const+0x4c>
 800abc6:	693b      	ldr	r3, [r7, #16]
 800abc8:	895b      	ldrh	r3, [r3, #10]
 800abca:	2216      	movs	r2, #22
 800abcc:	18ba      	adds	r2, r7, r2
 800abce:	8812      	ldrh	r2, [r2, #0]
 800abd0:	429a      	cmp	r2, r3
 800abd2:	d2ea      	bcs.n	800abaa <pbuf_skip_const+0x22>
  }
  if (out_offset != NULL) {
 800abd4:	687b      	ldr	r3, [r7, #4]
 800abd6:	2b00      	cmp	r3, #0
 800abd8:	d004      	beq.n	800abe4 <pbuf_skip_const+0x5c>
    *out_offset = offset_left;
 800abda:	687b      	ldr	r3, [r7, #4]
 800abdc:	2216      	movs	r2, #22
 800abde:	18ba      	adds	r2, r7, r2
 800abe0:	8812      	ldrh	r2, [r2, #0]
 800abe2:	801a      	strh	r2, [r3, #0]
  }
  return q;
 800abe4:	693b      	ldr	r3, [r7, #16]
}
 800abe6:	0018      	movs	r0, r3
 800abe8:	46bd      	mov	sp, r7
 800abea:	b006      	add	sp, #24
 800abec:	bd80      	pop	{r7, pc}

0800abee <pbuf_skip>:
 * @param out_offset resulting offset in the returned pbuf
 * @return the pbuf in the queue where the offset is
 */
struct pbuf *
pbuf_skip(struct pbuf *in, u16_t in_offset, u16_t *out_offset)
{
 800abee:	b580      	push	{r7, lr}
 800abf0:	b086      	sub	sp, #24
 800abf2:	af00      	add	r7, sp, #0
 800abf4:	60f8      	str	r0, [r7, #12]
 800abf6:	607a      	str	r2, [r7, #4]
 800abf8:	200a      	movs	r0, #10
 800abfa:	183b      	adds	r3, r7, r0
 800abfc:	1c0a      	adds	r2, r1, #0
 800abfe:	801a      	strh	r2, [r3, #0]
  const struct pbuf *out = pbuf_skip_const(in, in_offset, out_offset);
 800ac00:	687a      	ldr	r2, [r7, #4]
 800ac02:	183b      	adds	r3, r7, r0
 800ac04:	8819      	ldrh	r1, [r3, #0]
 800ac06:	68fb      	ldr	r3, [r7, #12]
 800ac08:	0018      	movs	r0, r3
 800ac0a:	f7ff ffbd 	bl	800ab88 <pbuf_skip_const>
 800ac0e:	0003      	movs	r3, r0
 800ac10:	617b      	str	r3, [r7, #20]
  return LWIP_CONST_CAST(struct pbuf *, out);
 800ac12:	697b      	ldr	r3, [r7, #20]
}
 800ac14:	0018      	movs	r0, r3
 800ac16:	46bd      	mov	sp, r7
 800ac18:	b006      	add	sp, #24
 800ac1a:	bd80      	pop	{r7, pc}

0800ac1c <pbuf_take>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
{
 800ac1c:	b580      	push	{r7, lr}
 800ac1e:	b088      	sub	sp, #32
 800ac20:	af00      	add	r7, sp, #0
 800ac22:	60f8      	str	r0, [r7, #12]
 800ac24:	60b9      	str	r1, [r7, #8]
 800ac26:	1dbb      	adds	r3, r7, #6
 800ac28:	801a      	strh	r2, [r3, #0]
  struct pbuf *p;
  size_t buf_copy_len;
  size_t total_copy_len = len;
 800ac2a:	1dbb      	adds	r3, r7, #6
 800ac2c:	881b      	ldrh	r3, [r3, #0]
 800ac2e:	617b      	str	r3, [r7, #20]
  size_t copied_total = 0;
 800ac30:	2300      	movs	r3, #0
 800ac32:	613b      	str	r3, [r7, #16]

  LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return ERR_ARG;);
 800ac34:	68fb      	ldr	r3, [r7, #12]
 800ac36:	2b00      	cmp	r3, #0
 800ac38:	d106      	bne.n	800ac48 <pbuf_take+0x2c>
 800ac3a:	4b37      	ldr	r3, [pc, #220]	; (800ad18 <pbuf_take+0xfc>)
 800ac3c:	0018      	movs	r0, r3
 800ac3e:	f7f7 fad1 	bl	80021e4 <app_debug_rtt_raw>
 800ac42:	2310      	movs	r3, #16
 800ac44:	425b      	negs	r3, r3
 800ac46:	e062      	b.n	800ad0e <pbuf_take+0xf2>
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
 800ac48:	68bb      	ldr	r3, [r7, #8]
 800ac4a:	2b00      	cmp	r3, #0
 800ac4c:	d106      	bne.n	800ac5c <pbuf_take+0x40>
 800ac4e:	4b33      	ldr	r3, [pc, #204]	; (800ad1c <pbuf_take+0x100>)
 800ac50:	0018      	movs	r0, r3
 800ac52:	f7f7 fac7 	bl	80021e4 <app_debug_rtt_raw>
 800ac56:	2310      	movs	r3, #16
 800ac58:	425b      	negs	r3, r3
 800ac5a:	e058      	b.n	800ad0e <pbuf_take+0xf2>
  LWIP_ERROR("pbuf_take: buf not large enough", (buf->tot_len >= len), return ERR_MEM;);
 800ac5c:	68fb      	ldr	r3, [r7, #12]
 800ac5e:	891b      	ldrh	r3, [r3, #8]
 800ac60:	1dba      	adds	r2, r7, #6
 800ac62:	8812      	ldrh	r2, [r2, #0]
 800ac64:	429a      	cmp	r2, r3
 800ac66:	d906      	bls.n	800ac76 <pbuf_take+0x5a>
 800ac68:	4b2d      	ldr	r3, [pc, #180]	; (800ad20 <pbuf_take+0x104>)
 800ac6a:	0018      	movs	r0, r3
 800ac6c:	f7f7 faba 	bl	80021e4 <app_debug_rtt_raw>
 800ac70:	2301      	movs	r3, #1
 800ac72:	425b      	negs	r3, r3
 800ac74:	e04b      	b.n	800ad0e <pbuf_take+0xf2>

  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
 800ac76:	68fb      	ldr	r3, [r7, #12]
 800ac78:	2b00      	cmp	r3, #0
 800ac7a:	d008      	beq.n	800ac8e <pbuf_take+0x72>
 800ac7c:	68bb      	ldr	r3, [r7, #8]
 800ac7e:	2b00      	cmp	r3, #0
 800ac80:	d005      	beq.n	800ac8e <pbuf_take+0x72>
 800ac82:	68fb      	ldr	r3, [r7, #12]
 800ac84:	891b      	ldrh	r3, [r3, #8]
 800ac86:	1dba      	adds	r2, r7, #6
 800ac88:	8812      	ldrh	r2, [r2, #0]
 800ac8a:	429a      	cmp	r2, r3
 800ac8c:	d902      	bls.n	800ac94 <pbuf_take+0x78>
    return ERR_ARG;
 800ac8e:	2310      	movs	r3, #16
 800ac90:	425b      	negs	r3, r3
 800ac92:	e03c      	b.n	800ad0e <pbuf_take+0xf2>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for (p = buf; total_copy_len != 0; p = p->next) {
 800ac94:	68fb      	ldr	r3, [r7, #12]
 800ac96:	61fb      	str	r3, [r7, #28]
 800ac98:	e027      	b.n	800acea <pbuf_take+0xce>
    LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
 800ac9a:	69fb      	ldr	r3, [r7, #28]
 800ac9c:	2b00      	cmp	r3, #0
 800ac9e:	d105      	bne.n	800acac <pbuf_take+0x90>
 800aca0:	4b20      	ldr	r3, [pc, #128]	; (800ad24 <pbuf_take+0x108>)
 800aca2:	4a21      	ldr	r2, [pc, #132]	; (800ad28 <pbuf_take+0x10c>)
 800aca4:	4921      	ldr	r1, [pc, #132]	; (800ad2c <pbuf_take+0x110>)
 800aca6:	4822      	ldr	r0, [pc, #136]	; (800ad30 <pbuf_take+0x114>)
 800aca8:	f7f7 fa9c 	bl	80021e4 <app_debug_rtt_raw>
    buf_copy_len = total_copy_len;
 800acac:	697b      	ldr	r3, [r7, #20]
 800acae:	61bb      	str	r3, [r7, #24]
    if (buf_copy_len > p->len) {
 800acb0:	69fb      	ldr	r3, [r7, #28]
 800acb2:	895b      	ldrh	r3, [r3, #10]
 800acb4:	001a      	movs	r2, r3
 800acb6:	69bb      	ldr	r3, [r7, #24]
 800acb8:	4293      	cmp	r3, r2
 800acba:	d902      	bls.n	800acc2 <pbuf_take+0xa6>
      /* this pbuf cannot hold all remaining data */
      buf_copy_len = p->len;
 800acbc:	69fb      	ldr	r3, [r7, #28]
 800acbe:	895b      	ldrh	r3, [r3, #10]
 800acc0:	61bb      	str	r3, [r7, #24]
    }
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((const char *)dataptr)[copied_total], buf_copy_len);
 800acc2:	69fb      	ldr	r3, [r7, #28]
 800acc4:	6858      	ldr	r0, [r3, #4]
 800acc6:	68ba      	ldr	r2, [r7, #8]
 800acc8:	693b      	ldr	r3, [r7, #16]
 800acca:	18d3      	adds	r3, r2, r3
 800accc:	69ba      	ldr	r2, [r7, #24]
 800acce:	0019      	movs	r1, r3
 800acd0:	f013 f964 	bl	801df9c <memcpy>
    total_copy_len -= buf_copy_len;
 800acd4:	697a      	ldr	r2, [r7, #20]
 800acd6:	69bb      	ldr	r3, [r7, #24]
 800acd8:	1ad3      	subs	r3, r2, r3
 800acda:	617b      	str	r3, [r7, #20]
    copied_total += buf_copy_len;
 800acdc:	693a      	ldr	r2, [r7, #16]
 800acde:	69bb      	ldr	r3, [r7, #24]
 800ace0:	18d3      	adds	r3, r2, r3
 800ace2:	613b      	str	r3, [r7, #16]
  for (p = buf; total_copy_len != 0; p = p->next) {
 800ace4:	69fb      	ldr	r3, [r7, #28]
 800ace6:	681b      	ldr	r3, [r3, #0]
 800ace8:	61fb      	str	r3, [r7, #28]
 800acea:	697b      	ldr	r3, [r7, #20]
 800acec:	2b00      	cmp	r3, #0
 800acee:	d1d4      	bne.n	800ac9a <pbuf_take+0x7e>
  }
  LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
 800acf0:	697b      	ldr	r3, [r7, #20]
 800acf2:	2b00      	cmp	r3, #0
 800acf4:	d104      	bne.n	800ad00 <pbuf_take+0xe4>
 800acf6:	1dbb      	adds	r3, r7, #6
 800acf8:	881b      	ldrh	r3, [r3, #0]
 800acfa:	693a      	ldr	r2, [r7, #16]
 800acfc:	429a      	cmp	r2, r3
 800acfe:	d005      	beq.n	800ad0c <pbuf_take+0xf0>
 800ad00:	4b08      	ldr	r3, [pc, #32]	; (800ad24 <pbuf_take+0x108>)
 800ad02:	4a0c      	ldr	r2, [pc, #48]	; (800ad34 <pbuf_take+0x118>)
 800ad04:	490c      	ldr	r1, [pc, #48]	; (800ad38 <pbuf_take+0x11c>)
 800ad06:	480a      	ldr	r0, [pc, #40]	; (800ad30 <pbuf_take+0x114>)
 800ad08:	f7f7 fa6c 	bl	80021e4 <app_debug_rtt_raw>
  return ERR_OK;
 800ad0c:	2300      	movs	r3, #0
}
 800ad0e:	0018      	movs	r0, r3
 800ad10:	46bd      	mov	sp, r7
 800ad12:	b008      	add	sp, #32
 800ad14:	bd80      	pop	{r7, pc}
 800ad16:	46c0      	nop			; (mov r8, r8)
 800ad18:	08020954 	.word	0x08020954
 800ad1c:	0802096c 	.word	0x0802096c
 800ad20:	08020988 	.word	0x08020988
 800ad24:	08020514 	.word	0x08020514
 800ad28:	000004df 	.word	0x000004df
 800ad2c:	080209a8 	.word	0x080209a8
 800ad30:	0802056c 	.word	0x0802056c
 800ad34:	000004ea 	.word	0x000004ea
 800ad38:	080209c0 	.word	0x080209c0

0800ad3c <pbuf_take_at>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take_at(struct pbuf *buf, const void *dataptr, u16_t len, u16_t offset)
{
 800ad3c:	b590      	push	{r4, r7, lr}
 800ad3e:	b089      	sub	sp, #36	; 0x24
 800ad40:	af00      	add	r7, sp, #0
 800ad42:	60f8      	str	r0, [r7, #12]
 800ad44:	60b9      	str	r1, [r7, #8]
 800ad46:	0019      	movs	r1, r3
 800ad48:	1dbb      	adds	r3, r7, #6
 800ad4a:	801a      	strh	r2, [r3, #0]
 800ad4c:	1d3b      	adds	r3, r7, #4
 800ad4e:	1c0a      	adds	r2, r1, #0
 800ad50:	801a      	strh	r2, [r3, #0]
  u16_t target_offset;
  struct pbuf *q = pbuf_skip(buf, offset, &target_offset);
 800ad52:	2410      	movs	r4, #16
 800ad54:	193a      	adds	r2, r7, r4
 800ad56:	1d3b      	adds	r3, r7, #4
 800ad58:	8819      	ldrh	r1, [r3, #0]
 800ad5a:	68fb      	ldr	r3, [r7, #12]
 800ad5c:	0018      	movs	r0, r3
 800ad5e:	f7ff ff46 	bl	800abee <pbuf_skip>
 800ad62:	0003      	movs	r3, r0
 800ad64:	61fb      	str	r3, [r7, #28]

  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->tot_len >= target_offset + len)) {
 800ad66:	69fb      	ldr	r3, [r7, #28]
 800ad68:	2b00      	cmp	r3, #0
 800ad6a:	d060      	beq.n	800ae2e <pbuf_take_at+0xf2>
 800ad6c:	69fb      	ldr	r3, [r7, #28]
 800ad6e:	891b      	ldrh	r3, [r3, #8]
 800ad70:	001a      	movs	r2, r3
 800ad72:	0020      	movs	r0, r4
 800ad74:	183b      	adds	r3, r7, r0
 800ad76:	881b      	ldrh	r3, [r3, #0]
 800ad78:	0019      	movs	r1, r3
 800ad7a:	1dbb      	adds	r3, r7, #6
 800ad7c:	881b      	ldrh	r3, [r3, #0]
 800ad7e:	18cb      	adds	r3, r1, r3
 800ad80:	429a      	cmp	r2, r3
 800ad82:	db54      	blt.n	800ae2e <pbuf_take_at+0xf2>
    u16_t remaining_len = len;
 800ad84:	231a      	movs	r3, #26
 800ad86:	18fb      	adds	r3, r7, r3
 800ad88:	1dba      	adds	r2, r7, #6
 800ad8a:	8812      	ldrh	r2, [r2, #0]
 800ad8c:	801a      	strh	r2, [r3, #0]
    const u8_t *src_ptr = (const u8_t *)dataptr;
 800ad8e:	68bb      	ldr	r3, [r7, #8]
 800ad90:	617b      	str	r3, [r7, #20]
    /* copy the part that goes into the first pbuf */
    u16_t first_copy_len;
    LWIP_ASSERT("check pbuf_skip result", target_offset < q->len);
 800ad92:	69fb      	ldr	r3, [r7, #28]
 800ad94:	895a      	ldrh	r2, [r3, #10]
 800ad96:	183b      	adds	r3, r7, r0
 800ad98:	881b      	ldrh	r3, [r3, #0]
 800ad9a:	429a      	cmp	r2, r3
 800ad9c:	d805      	bhi.n	800adaa <pbuf_take_at+0x6e>
 800ad9e:	4b27      	ldr	r3, [pc, #156]	; (800ae3c <pbuf_take_at+0x100>)
 800ada0:	4a27      	ldr	r2, [pc, #156]	; (800ae40 <pbuf_take_at+0x104>)
 800ada2:	4928      	ldr	r1, [pc, #160]	; (800ae44 <pbuf_take_at+0x108>)
 800ada4:	4828      	ldr	r0, [pc, #160]	; (800ae48 <pbuf_take_at+0x10c>)
 800ada6:	f7f7 fa1d 	bl	80021e4 <app_debug_rtt_raw>
    first_copy_len = (u16_t)LWIP_MIN(q->len - target_offset, len);
 800adaa:	69fb      	ldr	r3, [r7, #28]
 800adac:	895b      	ldrh	r3, [r3, #10]
 800adae:	001a      	movs	r2, r3
 800adb0:	2110      	movs	r1, #16
 800adb2:	187b      	adds	r3, r7, r1
 800adb4:	881b      	ldrh	r3, [r3, #0]
 800adb6:	1ad2      	subs	r2, r2, r3
 800adb8:	1dbb      	adds	r3, r7, #6
 800adba:	881b      	ldrh	r3, [r3, #0]
 800adbc:	429a      	cmp	r2, r3
 800adbe:	da06      	bge.n	800adce <pbuf_take_at+0x92>
 800adc0:	69fb      	ldr	r3, [r7, #28]
 800adc2:	895a      	ldrh	r2, [r3, #10]
 800adc4:	187b      	adds	r3, r7, r1
 800adc6:	881b      	ldrh	r3, [r3, #0]
 800adc8:	1ad3      	subs	r3, r2, r3
 800adca:	b29b      	uxth	r3, r3
 800adcc:	e001      	b.n	800add2 <pbuf_take_at+0x96>
 800adce:	1dbb      	adds	r3, r7, #6
 800add0:	881b      	ldrh	r3, [r3, #0]
 800add2:	2112      	movs	r1, #18
 800add4:	187a      	adds	r2, r7, r1
 800add6:	8013      	strh	r3, [r2, #0]
    MEMCPY(((u8_t *)q->payload) + target_offset, dataptr, first_copy_len);
 800add8:	69fb      	ldr	r3, [r7, #28]
 800adda:	685b      	ldr	r3, [r3, #4]
 800addc:	2210      	movs	r2, #16
 800adde:	18ba      	adds	r2, r7, r2
 800ade0:	8812      	ldrh	r2, [r2, #0]
 800ade2:	1898      	adds	r0, r3, r2
 800ade4:	000c      	movs	r4, r1
 800ade6:	187b      	adds	r3, r7, r1
 800ade8:	881a      	ldrh	r2, [r3, #0]
 800adea:	68bb      	ldr	r3, [r7, #8]
 800adec:	0019      	movs	r1, r3
 800adee:	f013 f8d5 	bl	801df9c <memcpy>
    remaining_len = (u16_t)(remaining_len - first_copy_len);
 800adf2:	201a      	movs	r0, #26
 800adf4:	183b      	adds	r3, r7, r0
 800adf6:	1839      	adds	r1, r7, r0
 800adf8:	193a      	adds	r2, r7, r4
 800adfa:	8809      	ldrh	r1, [r1, #0]
 800adfc:	8812      	ldrh	r2, [r2, #0]
 800adfe:	1a8a      	subs	r2, r1, r2
 800ae00:	801a      	strh	r2, [r3, #0]
    src_ptr += first_copy_len;
 800ae02:	193b      	adds	r3, r7, r4
 800ae04:	881b      	ldrh	r3, [r3, #0]
 800ae06:	697a      	ldr	r2, [r7, #20]
 800ae08:	18d3      	adds	r3, r2, r3
 800ae0a:	617b      	str	r3, [r7, #20]
    if (remaining_len > 0) {
 800ae0c:	0002      	movs	r2, r0
 800ae0e:	18bb      	adds	r3, r7, r2
 800ae10:	881b      	ldrh	r3, [r3, #0]
 800ae12:	2b00      	cmp	r3, #0
 800ae14:	d009      	beq.n	800ae2a <pbuf_take_at+0xee>
      return pbuf_take(q->next, src_ptr, remaining_len);
 800ae16:	69fb      	ldr	r3, [r7, #28]
 800ae18:	6818      	ldr	r0, [r3, #0]
 800ae1a:	18bb      	adds	r3, r7, r2
 800ae1c:	881a      	ldrh	r2, [r3, #0]
 800ae1e:	697b      	ldr	r3, [r7, #20]
 800ae20:	0019      	movs	r1, r3
 800ae22:	f7ff fefb 	bl	800ac1c <pbuf_take>
 800ae26:	0003      	movs	r3, r0
 800ae28:	e003      	b.n	800ae32 <pbuf_take_at+0xf6>
    }
    return ERR_OK;
 800ae2a:	2300      	movs	r3, #0
 800ae2c:	e001      	b.n	800ae32 <pbuf_take_at+0xf6>
  }
  return ERR_MEM;
 800ae2e:	2301      	movs	r3, #1
 800ae30:	425b      	negs	r3, r3
}
 800ae32:	0018      	movs	r0, r3
 800ae34:	46bd      	mov	sp, r7
 800ae36:	b009      	add	sp, #36	; 0x24
 800ae38:	bd90      	pop	{r4, r7, pc}
 800ae3a:	46c0      	nop			; (mov r8, r8)
 800ae3c:	08020514 	.word	0x08020514
 800ae40:	00000505 	.word	0x00000505
 800ae44:	080209d8 	.word	0x080209d8
 800ae48:	0802056c 	.word	0x0802056c

0800ae4c <pbuf_coalesce>:
 * @return a new, single pbuf (p->next is NULL)
 *         or the old pbuf if allocation fails
 */
struct pbuf *
pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
{
 800ae4c:	b580      	push	{r7, lr}
 800ae4e:	b084      	sub	sp, #16
 800ae50:	af00      	add	r7, sp, #0
 800ae52:	6078      	str	r0, [r7, #4]
 800ae54:	000a      	movs	r2, r1
 800ae56:	1cfb      	adds	r3, r7, #3
 800ae58:	701a      	strb	r2, [r3, #0]
  struct pbuf *q;
  if (p->next == NULL) {
 800ae5a:	687b      	ldr	r3, [r7, #4]
 800ae5c:	681b      	ldr	r3, [r3, #0]
 800ae5e:	2b00      	cmp	r3, #0
 800ae60:	d101      	bne.n	800ae66 <pbuf_coalesce+0x1a>
    return p;
 800ae62:	687b      	ldr	r3, [r7, #4]
 800ae64:	e013      	b.n	800ae8e <pbuf_coalesce+0x42>
  }
  q = pbuf_clone(layer, PBUF_RAM, p);
 800ae66:	687a      	ldr	r2, [r7, #4]
 800ae68:	23a0      	movs	r3, #160	; 0xa0
 800ae6a:	0099      	lsls	r1, r3, #2
 800ae6c:	1cfb      	adds	r3, r7, #3
 800ae6e:	781b      	ldrb	r3, [r3, #0]
 800ae70:	0018      	movs	r0, r3
 800ae72:	f000 f811 	bl	800ae98 <pbuf_clone>
 800ae76:	0003      	movs	r3, r0
 800ae78:	60fb      	str	r3, [r7, #12]
  if (q == NULL) {
 800ae7a:	68fb      	ldr	r3, [r7, #12]
 800ae7c:	2b00      	cmp	r3, #0
 800ae7e:	d101      	bne.n	800ae84 <pbuf_coalesce+0x38>
    /* @todo: what do we do now? */
    return p;
 800ae80:	687b      	ldr	r3, [r7, #4]
 800ae82:	e004      	b.n	800ae8e <pbuf_coalesce+0x42>
  }
  pbuf_free(p);
 800ae84:	687b      	ldr	r3, [r7, #4]
 800ae86:	0018      	movs	r0, r3
 800ae88:	f7ff fb28 	bl	800a4dc <pbuf_free>
  return q;
 800ae8c:	68fb      	ldr	r3, [r7, #12]
}
 800ae8e:	0018      	movs	r0, r3
 800ae90:	46bd      	mov	sp, r7
 800ae92:	b004      	add	sp, #16
 800ae94:	bd80      	pop	{r7, pc}
	...

0800ae98 <pbuf_clone>:
 *
 * @return a new pbuf or NULL if allocation fails
 */
struct pbuf *
pbuf_clone(pbuf_layer layer, pbuf_type type, struct pbuf *p)
{
 800ae98:	b5b0      	push	{r4, r5, r7, lr}
 800ae9a:	b084      	sub	sp, #16
 800ae9c:	af00      	add	r7, sp, #0
 800ae9e:	603a      	str	r2, [r7, #0]
 800aea0:	1dfb      	adds	r3, r7, #7
 800aea2:	1c02      	adds	r2, r0, #0
 800aea4:	701a      	strb	r2, [r3, #0]
 800aea6:	1d3b      	adds	r3, r7, #4
 800aea8:	1c0a      	adds	r2, r1, #0
 800aeaa:	801a      	strh	r2, [r3, #0]
  struct pbuf *q;
  err_t err;
  q = pbuf_alloc(layer, p->tot_len, type);
 800aeac:	683b      	ldr	r3, [r7, #0]
 800aeae:	8919      	ldrh	r1, [r3, #8]
 800aeb0:	1d3b      	adds	r3, r7, #4
 800aeb2:	881a      	ldrh	r2, [r3, #0]
 800aeb4:	1dfb      	adds	r3, r7, #7
 800aeb6:	781b      	ldrb	r3, [r3, #0]
 800aeb8:	0018      	movs	r0, r3
 800aeba:	f7fe ffd9 	bl	8009e70 <pbuf_alloc>
 800aebe:	0003      	movs	r3, r0
 800aec0:	60fb      	str	r3, [r7, #12]
  if (q == NULL) {
 800aec2:	68fb      	ldr	r3, [r7, #12]
 800aec4:	2b00      	cmp	r3, #0
 800aec6:	d101      	bne.n	800aecc <pbuf_clone+0x34>
    return NULL;
 800aec8:	2300      	movs	r3, #0
 800aeca:	e015      	b.n	800aef8 <pbuf_clone+0x60>
  }
  err = pbuf_copy(q, p);
 800aecc:	250b      	movs	r5, #11
 800aece:	197c      	adds	r4, r7, r5
 800aed0:	683a      	ldr	r2, [r7, #0]
 800aed2:	68fb      	ldr	r3, [r7, #12]
 800aed4:	0011      	movs	r1, r2
 800aed6:	0018      	movs	r0, r3
 800aed8:	f7ff fca2 	bl	800a820 <pbuf_copy>
 800aedc:	0003      	movs	r3, r0
 800aede:	7023      	strb	r3, [r4, #0]
  LWIP_UNUSED_ARG(err); /* in case of LWIP_NOASSERT */
  LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
 800aee0:	197b      	adds	r3, r7, r5
 800aee2:	781b      	ldrb	r3, [r3, #0]
 800aee4:	b25b      	sxtb	r3, r3
 800aee6:	2b00      	cmp	r3, #0
 800aee8:	d005      	beq.n	800aef6 <pbuf_clone+0x5e>
 800aeea:	4b05      	ldr	r3, [pc, #20]	; (800af00 <pbuf_clone+0x68>)
 800aeec:	4a05      	ldr	r2, [pc, #20]	; (800af04 <pbuf_clone+0x6c>)
 800aeee:	4906      	ldr	r1, [pc, #24]	; (800af08 <pbuf_clone+0x70>)
 800aef0:	4806      	ldr	r0, [pc, #24]	; (800af0c <pbuf_clone+0x74>)
 800aef2:	f7f7 f977 	bl	80021e4 <app_debug_rtt_raw>
  return q;
 800aef6:	68fb      	ldr	r3, [r7, #12]
}
 800aef8:	0018      	movs	r0, r3
 800aefa:	46bd      	mov	sp, r7
 800aefc:	b004      	add	sp, #16
 800aefe:	bdb0      	pop	{r4, r5, r7, pc}
 800af00:	08020514 	.word	0x08020514
 800af04:	00000546 	.word	0x00000546
 800af08:	080209f0 	.word	0x080209f0
 800af0c:	0802056c 	.word	0x0802056c

0800af10 <pbuf_get_at>:
 * @param offset offset into p of the byte to return
 * @return byte at an offset into p OR ZERO IF 'offset' >= p->tot_len
 */
u8_t
pbuf_get_at(const struct pbuf *p, u16_t offset)
{
 800af10:	b580      	push	{r7, lr}
 800af12:	b084      	sub	sp, #16
 800af14:	af00      	add	r7, sp, #0
 800af16:	6078      	str	r0, [r7, #4]
 800af18:	000a      	movs	r2, r1
 800af1a:	1cbb      	adds	r3, r7, #2
 800af1c:	801a      	strh	r2, [r3, #0]
  int ret = pbuf_try_get_at(p, offset);
 800af1e:	1cbb      	adds	r3, r7, #2
 800af20:	881a      	ldrh	r2, [r3, #0]
 800af22:	687b      	ldr	r3, [r7, #4]
 800af24:	0011      	movs	r1, r2
 800af26:	0018      	movs	r0, r3
 800af28:	f000 f80d 	bl	800af46 <pbuf_try_get_at>
 800af2c:	0003      	movs	r3, r0
 800af2e:	60fb      	str	r3, [r7, #12]
  if (ret >= 0) {
 800af30:	68fb      	ldr	r3, [r7, #12]
 800af32:	2b00      	cmp	r3, #0
 800af34:	db02      	blt.n	800af3c <pbuf_get_at+0x2c>
    return (u8_t)ret;
 800af36:	68fb      	ldr	r3, [r7, #12]
 800af38:	b2db      	uxtb	r3, r3
 800af3a:	e000      	b.n	800af3e <pbuf_get_at+0x2e>
  }
  return 0;
 800af3c:	2300      	movs	r3, #0
}
 800af3e:	0018      	movs	r0, r3
 800af40:	46bd      	mov	sp, r7
 800af42:	b004      	add	sp, #16
 800af44:	bd80      	pop	{r7, pc}

0800af46 <pbuf_try_get_at>:
 * @param offset offset into p of the byte to return
 * @return byte at an offset into p [0..0xFF] OR negative if 'offset' >= p->tot_len
 */
int
pbuf_try_get_at(const struct pbuf *p, u16_t offset)
{
 800af46:	b590      	push	{r4, r7, lr}
 800af48:	b085      	sub	sp, #20
 800af4a:	af00      	add	r7, sp, #0
 800af4c:	6078      	str	r0, [r7, #4]
 800af4e:	000a      	movs	r2, r1
 800af50:	1cbb      	adds	r3, r7, #2
 800af52:	801a      	strh	r2, [r3, #0]
  u16_t q_idx;
  const struct pbuf *q = pbuf_skip_const(p, offset, &q_idx);
 800af54:	240a      	movs	r4, #10
 800af56:	193a      	adds	r2, r7, r4
 800af58:	1cbb      	adds	r3, r7, #2
 800af5a:	8819      	ldrh	r1, [r3, #0]
 800af5c:	687b      	ldr	r3, [r7, #4]
 800af5e:	0018      	movs	r0, r3
 800af60:	f7ff fe12 	bl	800ab88 <pbuf_skip_const>
 800af64:	0003      	movs	r3, r0
 800af66:	60fb      	str	r3, [r7, #12]

  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > q_idx)) {
 800af68:	68fb      	ldr	r3, [r7, #12]
 800af6a:	2b00      	cmp	r3, #0
 800af6c:	d00c      	beq.n	800af88 <pbuf_try_get_at+0x42>
 800af6e:	68fb      	ldr	r3, [r7, #12]
 800af70:	895a      	ldrh	r2, [r3, #10]
 800af72:	193b      	adds	r3, r7, r4
 800af74:	881b      	ldrh	r3, [r3, #0]
 800af76:	429a      	cmp	r2, r3
 800af78:	d906      	bls.n	800af88 <pbuf_try_get_at+0x42>
    return ((u8_t *)q->payload)[q_idx];
 800af7a:	68fb      	ldr	r3, [r7, #12]
 800af7c:	685b      	ldr	r3, [r3, #4]
 800af7e:	193a      	adds	r2, r7, r4
 800af80:	8812      	ldrh	r2, [r2, #0]
 800af82:	189b      	adds	r3, r3, r2
 800af84:	781b      	ldrb	r3, [r3, #0]
 800af86:	e001      	b.n	800af8c <pbuf_try_get_at+0x46>
  }
  return -1;
 800af88:	2301      	movs	r3, #1
 800af8a:	425b      	negs	r3, r3
}
 800af8c:	0018      	movs	r0, r3
 800af8e:	46bd      	mov	sp, r7
 800af90:	b005      	add	sp, #20
 800af92:	bd90      	pop	{r4, r7, pc}

0800af94 <pbuf_put_at>:
 * @param offset offset into p of the byte to write
 * @param data byte to write at an offset into p
 */
void
pbuf_put_at(struct pbuf *p, u16_t offset, u8_t data)
{
 800af94:	b590      	push	{r4, r7, lr}
 800af96:	b085      	sub	sp, #20
 800af98:	af00      	add	r7, sp, #0
 800af9a:	6078      	str	r0, [r7, #4]
 800af9c:	0008      	movs	r0, r1
 800af9e:	0011      	movs	r1, r2
 800afa0:	1cbb      	adds	r3, r7, #2
 800afa2:	1c02      	adds	r2, r0, #0
 800afa4:	801a      	strh	r2, [r3, #0]
 800afa6:	1c7b      	adds	r3, r7, #1
 800afa8:	1c0a      	adds	r2, r1, #0
 800afaa:	701a      	strb	r2, [r3, #0]
  u16_t q_idx;
  struct pbuf *q = pbuf_skip(p, offset, &q_idx);
 800afac:	240a      	movs	r4, #10
 800afae:	193a      	adds	r2, r7, r4
 800afb0:	1cbb      	adds	r3, r7, #2
 800afb2:	8819      	ldrh	r1, [r3, #0]
 800afb4:	687b      	ldr	r3, [r7, #4]
 800afb6:	0018      	movs	r0, r3
 800afb8:	f7ff fe19 	bl	800abee <pbuf_skip>
 800afbc:	0003      	movs	r3, r0
 800afbe:	60fb      	str	r3, [r7, #12]

  /* write requested data if pbuf is OK */
  if ((q != NULL) && (q->len > q_idx)) {
 800afc0:	68fb      	ldr	r3, [r7, #12]
 800afc2:	2b00      	cmp	r3, #0
 800afc4:	d00d      	beq.n	800afe2 <pbuf_put_at+0x4e>
 800afc6:	68fb      	ldr	r3, [r7, #12]
 800afc8:	895a      	ldrh	r2, [r3, #10]
 800afca:	193b      	adds	r3, r7, r4
 800afcc:	881b      	ldrh	r3, [r3, #0]
 800afce:	429a      	cmp	r2, r3
 800afd0:	d907      	bls.n	800afe2 <pbuf_put_at+0x4e>
    ((u8_t *)q->payload)[q_idx] = data;
 800afd2:	68fb      	ldr	r3, [r7, #12]
 800afd4:	685b      	ldr	r3, [r3, #4]
 800afd6:	193a      	adds	r2, r7, r4
 800afd8:	8812      	ldrh	r2, [r2, #0]
 800afda:	189b      	adds	r3, r3, r2
 800afdc:	1c7a      	adds	r2, r7, #1
 800afde:	7812      	ldrb	r2, [r2, #0]
 800afe0:	701a      	strb	r2, [r3, #0]
  }
}
 800afe2:	46c0      	nop			; (mov r8, r8)
 800afe4:	46bd      	mov	sp, r7
 800afe6:	b005      	add	sp, #20
 800afe8:	bd90      	pop	{r4, r7, pc}
	...

0800afec <tcp_init>:
/**
 * Initialize this module.
 */
void
tcp_init(void)
{
 800afec:	b580      	push	{r7, lr}
 800afee:	af00      	add	r7, sp, #0
#ifdef LWIP_RAND
  tcp_port = TCP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
 800aff0:	f012 ff76 	bl	801dee0 <sys_rand>
 800aff4:	0003      	movs	r3, r0
 800aff6:	b29b      	uxth	r3, r3
 800aff8:	049b      	lsls	r3, r3, #18
 800affa:	0c9b      	lsrs	r3, r3, #18
 800affc:	b29b      	uxth	r3, r3
 800affe:	4a04      	ldr	r2, [pc, #16]	; (800b010 <tcp_init+0x24>)
 800b000:	4694      	mov	ip, r2
 800b002:	4463      	add	r3, ip
 800b004:	b29a      	uxth	r2, r3
 800b006:	4b03      	ldr	r3, [pc, #12]	; (800b014 <tcp_init+0x28>)
 800b008:	801a      	strh	r2, [r3, #0]
#endif /* LWIP_RAND */
}
 800b00a:	46c0      	nop			; (mov r8, r8)
 800b00c:	46bd      	mov	sp, r7
 800b00e:	bd80      	pop	{r7, pc}
 800b010:	ffffc000 	.word	0xffffc000
 800b014:	20000022 	.word	0x20000022

0800b018 <tcp_free>:

/** Free a tcp pcb */
void
tcp_free(struct tcp_pcb *pcb)
{
 800b018:	b580      	push	{r7, lr}
 800b01a:	b082      	sub	sp, #8
 800b01c:	af00      	add	r7, sp, #0
 800b01e:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_free: LISTEN", pcb->state != LISTEN);
 800b020:	687b      	ldr	r3, [r7, #4]
 800b022:	7e1b      	ldrb	r3, [r3, #24]
 800b024:	2b01      	cmp	r3, #1
 800b026:	d105      	bne.n	800b034 <tcp_free+0x1c>
 800b028:	4b07      	ldr	r3, [pc, #28]	; (800b048 <tcp_free+0x30>)
 800b02a:	4908      	ldr	r1, [pc, #32]	; (800b04c <tcp_free+0x34>)
 800b02c:	4808      	ldr	r0, [pc, #32]	; (800b050 <tcp_free+0x38>)
 800b02e:	22d4      	movs	r2, #212	; 0xd4
 800b030:	f7f7 f8d8 	bl	80021e4 <app_debug_rtt_raw>
#if LWIP_TCP_PCB_NUM_EXT_ARGS
  tcp_ext_arg_invoke_callbacks_destroyed(pcb->ext_args);
#endif
  memp_free(MEMP_TCP_PCB, pcb);
 800b034:	687b      	ldr	r3, [r7, #4]
 800b036:	0019      	movs	r1, r3
 800b038:	2001      	movs	r0, #1
 800b03a:	f7fe fb9b 	bl	8009774 <memp_free>
}
 800b03e:	46c0      	nop			; (mov r8, r8)
 800b040:	46bd      	mov	sp, r7
 800b042:	b002      	add	sp, #8
 800b044:	bd80      	pop	{r7, pc}
 800b046:	46c0      	nop			; (mov r8, r8)
 800b048:	08020aa8 	.word	0x08020aa8
 800b04c:	08020ad0 	.word	0x08020ad0
 800b050:	08020ae4 	.word	0x08020ae4

0800b054 <tcp_free_listen>:

/** Free a tcp listen pcb */
static void
tcp_free_listen(struct tcp_pcb *pcb)
{
 800b054:	b580      	push	{r7, lr}
 800b056:	b082      	sub	sp, #8
 800b058:	af00      	add	r7, sp, #0
 800b05a:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_free_listen: !LISTEN", pcb->state != LISTEN);
 800b05c:	687b      	ldr	r3, [r7, #4]
 800b05e:	7e1b      	ldrb	r3, [r3, #24]
 800b060:	2b01      	cmp	r3, #1
 800b062:	d105      	bne.n	800b070 <tcp_free_listen+0x1c>
 800b064:	4b07      	ldr	r3, [pc, #28]	; (800b084 <tcp_free_listen+0x30>)
 800b066:	4908      	ldr	r1, [pc, #32]	; (800b088 <tcp_free_listen+0x34>)
 800b068:	4808      	ldr	r0, [pc, #32]	; (800b08c <tcp_free_listen+0x38>)
 800b06a:	22df      	movs	r2, #223	; 0xdf
 800b06c:	f7f7 f8ba 	bl	80021e4 <app_debug_rtt_raw>
#if LWIP_TCP_PCB_NUM_EXT_ARGS
  tcp_ext_arg_invoke_callbacks_destroyed(pcb->ext_args);
#endif
  memp_free(MEMP_TCP_PCB_LISTEN, pcb);
 800b070:	687b      	ldr	r3, [r7, #4]
 800b072:	0019      	movs	r1, r3
 800b074:	2002      	movs	r0, #2
 800b076:	f7fe fb7d 	bl	8009774 <memp_free>
}
 800b07a:	46c0      	nop			; (mov r8, r8)
 800b07c:	46bd      	mov	sp, r7
 800b07e:	b002      	add	sp, #8
 800b080:	bd80      	pop	{r7, pc}
 800b082:	46c0      	nop			; (mov r8, r8)
 800b084:	08020aa8 	.word	0x08020aa8
 800b088:	08020b10 	.word	0x08020b10
 800b08c:	08020ae4 	.word	0x08020ae4

0800b090 <tcp_tmr>:
/**
 * Called periodically to dispatch TCP timers.
 */
void
tcp_tmr(void)
{
 800b090:	b580      	push	{r7, lr}
 800b092:	af00      	add	r7, sp, #0
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
 800b094:	f001 f978 	bl	800c388 <tcp_fasttmr>

  if (++tcp_timer & 1) {
 800b098:	4b08      	ldr	r3, [pc, #32]	; (800b0bc <tcp_tmr+0x2c>)
 800b09a:	781b      	ldrb	r3, [r3, #0]
 800b09c:	3301      	adds	r3, #1
 800b09e:	b2da      	uxtb	r2, r3
 800b0a0:	4b06      	ldr	r3, [pc, #24]	; (800b0bc <tcp_tmr+0x2c>)
 800b0a2:	701a      	strb	r2, [r3, #0]
 800b0a4:	4b05      	ldr	r3, [pc, #20]	; (800b0bc <tcp_tmr+0x2c>)
 800b0a6:	781b      	ldrb	r3, [r3, #0]
 800b0a8:	001a      	movs	r2, r3
 800b0aa:	2301      	movs	r3, #1
 800b0ac:	4013      	ands	r3, r2
 800b0ae:	d001      	beq.n	800b0b4 <tcp_tmr+0x24>
    /* Call tcp_slowtmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
 800b0b0:	f000 fdde 	bl	800bc70 <tcp_slowtmr>
  }
}
 800b0b4:	46c0      	nop			; (mov r8, r8)
 800b0b6:	46bd      	mov	sp, r7
 800b0b8:	bd80      	pop	{r7, pc}
 800b0ba:	46c0      	nop			; (mov r8, r8)
 800b0bc:	20000c45 	.word	0x20000c45

0800b0c0 <tcp_remove_listener>:
/** Called when a listen pcb is closed. Iterates one pcb list and removes the
 * closed listener pcb from pcb->listener if matching.
 */
static void
tcp_remove_listener(struct tcp_pcb *list, struct tcp_pcb_listen *lpcb)
{
 800b0c0:	b580      	push	{r7, lr}
 800b0c2:	b084      	sub	sp, #16
 800b0c4:	af00      	add	r7, sp, #0
 800b0c6:	6078      	str	r0, [r7, #4]
 800b0c8:	6039      	str	r1, [r7, #0]
  struct tcp_pcb *pcb;

  LWIP_ASSERT("tcp_remove_listener: invalid listener", lpcb != NULL);
 800b0ca:	683b      	ldr	r3, [r7, #0]
 800b0cc:	2b00      	cmp	r3, #0
 800b0ce:	d105      	bne.n	800b0dc <tcp_remove_listener+0x1c>
 800b0d0:	4b0e      	ldr	r3, [pc, #56]	; (800b10c <tcp_remove_listener+0x4c>)
 800b0d2:	490f      	ldr	r1, [pc, #60]	; (800b110 <tcp_remove_listener+0x50>)
 800b0d4:	480f      	ldr	r0, [pc, #60]	; (800b114 <tcp_remove_listener+0x54>)
 800b0d6:	22ff      	movs	r2, #255	; 0xff
 800b0d8:	f7f7 f884 	bl	80021e4 <app_debug_rtt_raw>

  for (pcb = list; pcb != NULL; pcb = pcb->next) {
 800b0dc:	687b      	ldr	r3, [r7, #4]
 800b0de:	60fb      	str	r3, [r7, #12]
 800b0e0:	e00c      	b.n	800b0fc <tcp_remove_listener+0x3c>
    if (pcb->listener == lpcb) {
 800b0e2:	68fb      	ldr	r3, [r7, #12]
 800b0e4:	2280      	movs	r2, #128	; 0x80
 800b0e6:	589b      	ldr	r3, [r3, r2]
 800b0e8:	683a      	ldr	r2, [r7, #0]
 800b0ea:	429a      	cmp	r2, r3
 800b0ec:	d103      	bne.n	800b0f6 <tcp_remove_listener+0x36>
      pcb->listener = NULL;
 800b0ee:	68fb      	ldr	r3, [r7, #12]
 800b0f0:	2280      	movs	r2, #128	; 0x80
 800b0f2:	2100      	movs	r1, #0
 800b0f4:	5099      	str	r1, [r3, r2]
  for (pcb = list; pcb != NULL; pcb = pcb->next) {
 800b0f6:	68fb      	ldr	r3, [r7, #12]
 800b0f8:	691b      	ldr	r3, [r3, #16]
 800b0fa:	60fb      	str	r3, [r7, #12]
 800b0fc:	68fb      	ldr	r3, [r7, #12]
 800b0fe:	2b00      	cmp	r3, #0
 800b100:	d1ef      	bne.n	800b0e2 <tcp_remove_listener+0x22>
    }
  }
}
 800b102:	46c0      	nop			; (mov r8, r8)
 800b104:	46c0      	nop			; (mov r8, r8)
 800b106:	46bd      	mov	sp, r7
 800b108:	b004      	add	sp, #16
 800b10a:	bd80      	pop	{r7, pc}
 800b10c:	08020aa8 	.word	0x08020aa8
 800b110:	08020b2c 	.word	0x08020b2c
 800b114:	08020ae4 	.word	0x08020ae4

0800b118 <tcp_listen_closed>:
/** Called when a listen pcb is closed. Iterates all pcb lists and removes the
 * closed listener pcb from pcb->listener if matching.
 */
static void
tcp_listen_closed(struct tcp_pcb *pcb)
{
 800b118:	b580      	push	{r7, lr}
 800b11a:	b084      	sub	sp, #16
 800b11c:	af00      	add	r7, sp, #0
 800b11e:	6078      	str	r0, [r7, #4]
#if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
  size_t i;
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
 800b120:	687b      	ldr	r3, [r7, #4]
 800b122:	2b00      	cmp	r3, #0
 800b124:	d106      	bne.n	800b134 <tcp_listen_closed+0x1c>
 800b126:	4b15      	ldr	r3, [pc, #84]	; (800b17c <tcp_listen_closed+0x64>)
 800b128:	2212      	movs	r2, #18
 800b12a:	32ff      	adds	r2, #255	; 0xff
 800b12c:	4914      	ldr	r1, [pc, #80]	; (800b180 <tcp_listen_closed+0x68>)
 800b12e:	4815      	ldr	r0, [pc, #84]	; (800b184 <tcp_listen_closed+0x6c>)
 800b130:	f7f7 f858 	bl	80021e4 <app_debug_rtt_raw>
  LWIP_ASSERT("pcb->state == LISTEN", pcb->state == LISTEN);
 800b134:	687b      	ldr	r3, [r7, #4]
 800b136:	7e1b      	ldrb	r3, [r3, #24]
 800b138:	2b01      	cmp	r3, #1
 800b13a:	d006      	beq.n	800b14a <tcp_listen_closed+0x32>
 800b13c:	4b0f      	ldr	r3, [pc, #60]	; (800b17c <tcp_listen_closed+0x64>)
 800b13e:	2289      	movs	r2, #137	; 0x89
 800b140:	0052      	lsls	r2, r2, #1
 800b142:	4911      	ldr	r1, [pc, #68]	; (800b188 <tcp_listen_closed+0x70>)
 800b144:	480f      	ldr	r0, [pc, #60]	; (800b184 <tcp_listen_closed+0x6c>)
 800b146:	f7f7 f84d 	bl	80021e4 <app_debug_rtt_raw>
  for (i = 1; i < LWIP_ARRAYSIZE(tcp_pcb_lists); i++) {
 800b14a:	2301      	movs	r3, #1
 800b14c:	60fb      	str	r3, [r7, #12]
 800b14e:	e00c      	b.n	800b16a <tcp_listen_closed+0x52>
    tcp_remove_listener(*tcp_pcb_lists[i], (struct tcp_pcb_listen *)pcb);
 800b150:	4b0e      	ldr	r3, [pc, #56]	; (800b18c <tcp_listen_closed+0x74>)
 800b152:	68fa      	ldr	r2, [r7, #12]
 800b154:	0092      	lsls	r2, r2, #2
 800b156:	58d3      	ldr	r3, [r2, r3]
 800b158:	681b      	ldr	r3, [r3, #0]
 800b15a:	687a      	ldr	r2, [r7, #4]
 800b15c:	0011      	movs	r1, r2
 800b15e:	0018      	movs	r0, r3
 800b160:	f7ff ffae 	bl	800b0c0 <tcp_remove_listener>
  for (i = 1; i < LWIP_ARRAYSIZE(tcp_pcb_lists); i++) {
 800b164:	68fb      	ldr	r3, [r7, #12]
 800b166:	3301      	adds	r3, #1
 800b168:	60fb      	str	r3, [r7, #12]
 800b16a:	68fb      	ldr	r3, [r7, #12]
 800b16c:	2b03      	cmp	r3, #3
 800b16e:	d9ef      	bls.n	800b150 <tcp_listen_closed+0x38>
  }
#endif
  LWIP_UNUSED_ARG(pcb);
}
 800b170:	46c0      	nop			; (mov r8, r8)
 800b172:	46c0      	nop			; (mov r8, r8)
 800b174:	46bd      	mov	sp, r7
 800b176:	b004      	add	sp, #16
 800b178:	bd80      	pop	{r7, pc}
 800b17a:	46c0      	nop			; (mov r8, r8)
 800b17c:	08020aa8 	.word	0x08020aa8
 800b180:	08020b54 	.word	0x08020b54
 800b184:	08020ae4 	.word	0x08020ae4
 800b188:	08020b60 	.word	0x08020b60
 800b18c:	08023a44 	.word	0x08023a44

0800b190 <tcp_close_shutdown>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
static err_t
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
 800b190:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b192:	b089      	sub	sp, #36	; 0x24
 800b194:	af04      	add	r7, sp, #16
 800b196:	6078      	str	r0, [r7, #4]
 800b198:	000a      	movs	r2, r1
 800b19a:	1cfb      	adds	r3, r7, #3
 800b19c:	701a      	strb	r2, [r3, #0]
  LWIP_ASSERT("tcp_close_shutdown: invalid pcb", pcb != NULL);
 800b19e:	687b      	ldr	r3, [r7, #4]
 800b1a0:	2b00      	cmp	r3, #0
 800b1a2:	d106      	bne.n	800b1b2 <tcp_close_shutdown+0x22>
 800b1a4:	4b69      	ldr	r3, [pc, #420]	; (800b34c <tcp_close_shutdown+0x1bc>)
 800b1a6:	22af      	movs	r2, #175	; 0xaf
 800b1a8:	0052      	lsls	r2, r2, #1
 800b1aa:	4969      	ldr	r1, [pc, #420]	; (800b350 <tcp_close_shutdown+0x1c0>)
 800b1ac:	4869      	ldr	r0, [pc, #420]	; (800b354 <tcp_close_shutdown+0x1c4>)
 800b1ae:	f7f7 f819 	bl	80021e4 <app_debug_rtt_raw>

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
 800b1b2:	1cfb      	adds	r3, r7, #3
 800b1b4:	781b      	ldrb	r3, [r3, #0]
 800b1b6:	2b00      	cmp	r3, #0
 800b1b8:	d100      	bne.n	800b1bc <tcp_close_shutdown+0x2c>
 800b1ba:	e069      	b.n	800b290 <tcp_close_shutdown+0x100>
 800b1bc:	687b      	ldr	r3, [r7, #4]
 800b1be:	7e1b      	ldrb	r3, [r3, #24]
 800b1c0:	2b04      	cmp	r3, #4
 800b1c2:	d003      	beq.n	800b1cc <tcp_close_shutdown+0x3c>
 800b1c4:	687b      	ldr	r3, [r7, #4]
 800b1c6:	7e1b      	ldrb	r3, [r3, #24]
 800b1c8:	2b07      	cmp	r3, #7
 800b1ca:	d161      	bne.n	800b290 <tcp_close_shutdown+0x100>
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND_MAX(pcb))) {
 800b1cc:	687b      	ldr	r3, [r7, #4]
 800b1ce:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800b1d0:	2b00      	cmp	r3, #0
 800b1d2:	d105      	bne.n	800b1e0 <tcp_close_shutdown+0x50>
 800b1d4:	687b      	ldr	r3, [r7, #4]
 800b1d6:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800b1d8:	2386      	movs	r3, #134	; 0x86
 800b1da:	00db      	lsls	r3, r3, #3
 800b1dc:	429a      	cmp	r2, r3
 800b1de:	d057      	beq.n	800b290 <tcp_close_shutdown+0x100>
      /* Not all data received by application, send RST to tell the remote
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
 800b1e0:	687b      	ldr	r3, [r7, #4]
 800b1e2:	8bdb      	ldrh	r3, [r3, #30]
 800b1e4:	001a      	movs	r2, r3
 800b1e6:	2310      	movs	r3, #16
 800b1e8:	4013      	ands	r3, r2
 800b1ea:	d106      	bne.n	800b1fa <tcp_close_shutdown+0x6a>
 800b1ec:	4b57      	ldr	r3, [pc, #348]	; (800b34c <tcp_close_shutdown+0x1bc>)
 800b1ee:	22b2      	movs	r2, #178	; 0xb2
 800b1f0:	0052      	lsls	r2, r2, #1
 800b1f2:	4959      	ldr	r1, [pc, #356]	; (800b358 <tcp_close_shutdown+0x1c8>)
 800b1f4:	4857      	ldr	r0, [pc, #348]	; (800b354 <tcp_close_shutdown+0x1c4>)
 800b1f6:	f7f6 fff5 	bl	80021e4 <app_debug_rtt_raw>

      /* don't call tcp_abort here: we must not deallocate the pcb since
         that might not be expected when calling tcp_close */
      tcp_rst(pcb, pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 800b1fa:	687b      	ldr	r3, [r7, #4]
 800b1fc:	6d5c      	ldr	r4, [r3, #84]	; 0x54
 800b1fe:	687b      	ldr	r3, [r7, #4]
 800b200:	6a9d      	ldr	r5, [r3, #40]	; 0x28
 800b202:	687e      	ldr	r6, [r7, #4]
 800b204:	687b      	ldr	r3, [r7, #4]
 800b206:	3304      	adds	r3, #4
 800b208:	687a      	ldr	r2, [r7, #4]
 800b20a:	8b52      	ldrh	r2, [r2, #26]
 800b20c:	6879      	ldr	r1, [r7, #4]
 800b20e:	8b89      	ldrh	r1, [r1, #28]
 800b210:	6878      	ldr	r0, [r7, #4]
 800b212:	9102      	str	r1, [sp, #8]
 800b214:	9201      	str	r2, [sp, #4]
 800b216:	9300      	str	r3, [sp, #0]
 800b218:	0033      	movs	r3, r6
 800b21a:	002a      	movs	r2, r5
 800b21c:	0021      	movs	r1, r4
 800b21e:	f007 f909 	bl	8012434 <tcp_rst>
              pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
 800b222:	687b      	ldr	r3, [r7, #4]
 800b224:	0018      	movs	r0, r3
 800b226:	f001 fc85 	bl	800cb34 <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 800b22a:	4b4c      	ldr	r3, [pc, #304]	; (800b35c <tcp_close_shutdown+0x1cc>)
 800b22c:	681b      	ldr	r3, [r3, #0]
 800b22e:	687a      	ldr	r2, [r7, #4]
 800b230:	429a      	cmp	r2, r3
 800b232:	d105      	bne.n	800b240 <tcp_close_shutdown+0xb0>
 800b234:	4b49      	ldr	r3, [pc, #292]	; (800b35c <tcp_close_shutdown+0x1cc>)
 800b236:	681b      	ldr	r3, [r3, #0]
 800b238:	691a      	ldr	r2, [r3, #16]
 800b23a:	4b48      	ldr	r3, [pc, #288]	; (800b35c <tcp_close_shutdown+0x1cc>)
 800b23c:	601a      	str	r2, [r3, #0]
 800b23e:	e013      	b.n	800b268 <tcp_close_shutdown+0xd8>
 800b240:	4b46      	ldr	r3, [pc, #280]	; (800b35c <tcp_close_shutdown+0x1cc>)
 800b242:	681b      	ldr	r3, [r3, #0]
 800b244:	60fb      	str	r3, [r7, #12]
 800b246:	e00c      	b.n	800b262 <tcp_close_shutdown+0xd2>
 800b248:	68fb      	ldr	r3, [r7, #12]
 800b24a:	691b      	ldr	r3, [r3, #16]
 800b24c:	687a      	ldr	r2, [r7, #4]
 800b24e:	429a      	cmp	r2, r3
 800b250:	d104      	bne.n	800b25c <tcp_close_shutdown+0xcc>
 800b252:	687b      	ldr	r3, [r7, #4]
 800b254:	691a      	ldr	r2, [r3, #16]
 800b256:	68fb      	ldr	r3, [r7, #12]
 800b258:	611a      	str	r2, [r3, #16]
 800b25a:	e005      	b.n	800b268 <tcp_close_shutdown+0xd8>
 800b25c:	68fb      	ldr	r3, [r7, #12]
 800b25e:	691b      	ldr	r3, [r3, #16]
 800b260:	60fb      	str	r3, [r7, #12]
 800b262:	68fb      	ldr	r3, [r7, #12]
 800b264:	2b00      	cmp	r3, #0
 800b266:	d1ef      	bne.n	800b248 <tcp_close_shutdown+0xb8>
 800b268:	687b      	ldr	r3, [r7, #4]
 800b26a:	2200      	movs	r2, #0
 800b26c:	611a      	str	r2, [r3, #16]
 800b26e:	4b3c      	ldr	r3, [pc, #240]	; (800b360 <tcp_close_shutdown+0x1d0>)
 800b270:	2201      	movs	r2, #1
 800b272:	701a      	strb	r2, [r3, #0]
      /* Deallocate the pcb since we already sent a RST for it */
      if (tcp_input_pcb == pcb) {
 800b274:	4b3b      	ldr	r3, [pc, #236]	; (800b364 <tcp_close_shutdown+0x1d4>)
 800b276:	681b      	ldr	r3, [r3, #0]
 800b278:	687a      	ldr	r2, [r7, #4]
 800b27a:	429a      	cmp	r2, r3
 800b27c:	d102      	bne.n	800b284 <tcp_close_shutdown+0xf4>
        /* prevent using a deallocated pcb: free it from tcp_input later */
        tcp_trigger_input_pcb_close();
 800b27e:	f004 fcd5 	bl	800fc2c <tcp_trigger_input_pcb_close>
 800b282:	e003      	b.n	800b28c <tcp_close_shutdown+0xfc>
      } else {
        tcp_free(pcb);
 800b284:	687b      	ldr	r3, [r7, #4]
 800b286:	0018      	movs	r0, r3
 800b288:	f7ff fec6 	bl	800b018 <tcp_free>
      }
      return ERR_OK;
 800b28c:	2300      	movs	r3, #0
 800b28e:	e058      	b.n	800b342 <tcp_close_shutdown+0x1b2>
    }
  }

  /* - states which free the pcb are handled here,
     - states which send FIN and change state are handled in tcp_close_shutdown_fin() */
  switch (pcb->state) {
 800b290:	687b      	ldr	r3, [r7, #4]
 800b292:	7e1b      	ldrb	r3, [r3, #24]
 800b294:	2b02      	cmp	r3, #2
 800b296:	d03f      	beq.n	800b318 <tcp_close_shutdown+0x188>
 800b298:	dc4c      	bgt.n	800b334 <tcp_close_shutdown+0x1a4>
 800b29a:	2b00      	cmp	r3, #0
 800b29c:	d002      	beq.n	800b2a4 <tcp_close_shutdown+0x114>
 800b29e:	2b01      	cmp	r3, #1
 800b2a0:	d02b      	beq.n	800b2fa <tcp_close_shutdown+0x16a>
 800b2a2:	e047      	b.n	800b334 <tcp_close_shutdown+0x1a4>
       * and the user needs some way to free it should the need arise.
       * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
       * or for a pcb that has been used and then entered the CLOSED state
       * is erroneous, but this should never happen as the pcb has in those cases
       * been freed, and so any remaining handles are bogus. */
      if (pcb->local_port != 0) {
 800b2a4:	687b      	ldr	r3, [r7, #4]
 800b2a6:	8b5b      	ldrh	r3, [r3, #26]
 800b2a8:	2b00      	cmp	r3, #0
 800b2aa:	d021      	beq.n	800b2f0 <tcp_close_shutdown+0x160>
        TCP_RMV(&tcp_bound_pcbs, pcb);
 800b2ac:	4b2e      	ldr	r3, [pc, #184]	; (800b368 <tcp_close_shutdown+0x1d8>)
 800b2ae:	681b      	ldr	r3, [r3, #0]
 800b2b0:	687a      	ldr	r2, [r7, #4]
 800b2b2:	429a      	cmp	r2, r3
 800b2b4:	d105      	bne.n	800b2c2 <tcp_close_shutdown+0x132>
 800b2b6:	4b2c      	ldr	r3, [pc, #176]	; (800b368 <tcp_close_shutdown+0x1d8>)
 800b2b8:	681b      	ldr	r3, [r3, #0]
 800b2ba:	691a      	ldr	r2, [r3, #16]
 800b2bc:	4b2a      	ldr	r3, [pc, #168]	; (800b368 <tcp_close_shutdown+0x1d8>)
 800b2be:	601a      	str	r2, [r3, #0]
 800b2c0:	e013      	b.n	800b2ea <tcp_close_shutdown+0x15a>
 800b2c2:	4b29      	ldr	r3, [pc, #164]	; (800b368 <tcp_close_shutdown+0x1d8>)
 800b2c4:	681b      	ldr	r3, [r3, #0]
 800b2c6:	60bb      	str	r3, [r7, #8]
 800b2c8:	e00c      	b.n	800b2e4 <tcp_close_shutdown+0x154>
 800b2ca:	68bb      	ldr	r3, [r7, #8]
 800b2cc:	691b      	ldr	r3, [r3, #16]
 800b2ce:	687a      	ldr	r2, [r7, #4]
 800b2d0:	429a      	cmp	r2, r3
 800b2d2:	d104      	bne.n	800b2de <tcp_close_shutdown+0x14e>
 800b2d4:	687b      	ldr	r3, [r7, #4]
 800b2d6:	691a      	ldr	r2, [r3, #16]
 800b2d8:	68bb      	ldr	r3, [r7, #8]
 800b2da:	611a      	str	r2, [r3, #16]
 800b2dc:	e005      	b.n	800b2ea <tcp_close_shutdown+0x15a>
 800b2de:	68bb      	ldr	r3, [r7, #8]
 800b2e0:	691b      	ldr	r3, [r3, #16]
 800b2e2:	60bb      	str	r3, [r7, #8]
 800b2e4:	68bb      	ldr	r3, [r7, #8]
 800b2e6:	2b00      	cmp	r3, #0
 800b2e8:	d1ef      	bne.n	800b2ca <tcp_close_shutdown+0x13a>
 800b2ea:	687b      	ldr	r3, [r7, #4]
 800b2ec:	2200      	movs	r2, #0
 800b2ee:	611a      	str	r2, [r3, #16]
      }
      tcp_free(pcb);
 800b2f0:	687b      	ldr	r3, [r7, #4]
 800b2f2:	0018      	movs	r0, r3
 800b2f4:	f7ff fe90 	bl	800b018 <tcp_free>
      break;
 800b2f8:	e022      	b.n	800b340 <tcp_close_shutdown+0x1b0>
    case LISTEN:
      tcp_listen_closed(pcb);
 800b2fa:	687b      	ldr	r3, [r7, #4]
 800b2fc:	0018      	movs	r0, r3
 800b2fe:	f7ff ff0b 	bl	800b118 <tcp_listen_closed>
      tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
 800b302:	687a      	ldr	r2, [r7, #4]
 800b304:	4b19      	ldr	r3, [pc, #100]	; (800b36c <tcp_close_shutdown+0x1dc>)
 800b306:	0011      	movs	r1, r2
 800b308:	0018      	movs	r0, r3
 800b30a:	f001 fc5d 	bl	800cbc8 <tcp_pcb_remove>
      tcp_free_listen(pcb);
 800b30e:	687b      	ldr	r3, [r7, #4]
 800b310:	0018      	movs	r0, r3
 800b312:	f7ff fe9f 	bl	800b054 <tcp_free_listen>
      break;
 800b316:	e013      	b.n	800b340 <tcp_close_shutdown+0x1b0>
    case SYN_SENT:
      TCP_PCB_REMOVE_ACTIVE(pcb);
 800b318:	687a      	ldr	r2, [r7, #4]
 800b31a:	4b10      	ldr	r3, [pc, #64]	; (800b35c <tcp_close_shutdown+0x1cc>)
 800b31c:	0011      	movs	r1, r2
 800b31e:	0018      	movs	r0, r3
 800b320:	f001 fc52 	bl	800cbc8 <tcp_pcb_remove>
 800b324:	4b0e      	ldr	r3, [pc, #56]	; (800b360 <tcp_close_shutdown+0x1d0>)
 800b326:	2201      	movs	r2, #1
 800b328:	701a      	strb	r2, [r3, #0]
      tcp_free(pcb);
 800b32a:	687b      	ldr	r3, [r7, #4]
 800b32c:	0018      	movs	r0, r3
 800b32e:	f7ff fe73 	bl	800b018 <tcp_free>
      MIB2_STATS_INC(mib2.tcpattemptfails);
      break;
 800b332:	e005      	b.n	800b340 <tcp_close_shutdown+0x1b0>
    default:
      return tcp_close_shutdown_fin(pcb);
 800b334:	687b      	ldr	r3, [r7, #4]
 800b336:	0018      	movs	r0, r3
 800b338:	f000 f81a 	bl	800b370 <tcp_close_shutdown_fin>
 800b33c:	0003      	movs	r3, r0
 800b33e:	e000      	b.n	800b342 <tcp_close_shutdown+0x1b2>
  }
  return ERR_OK;
 800b340:	2300      	movs	r3, #0
}
 800b342:	0018      	movs	r0, r3
 800b344:	46bd      	mov	sp, r7
 800b346:	b005      	add	sp, #20
 800b348:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800b34a:	46c0      	nop			; (mov r8, r8)
 800b34c:	08020aa8 	.word	0x08020aa8
 800b350:	08020b78 	.word	0x08020b78
 800b354:	08020ae4 	.word	0x08020ae4
 800b358:	08020b98 	.word	0x08020b98
 800b35c:	2000278c 	.word	0x2000278c
 800b360:	20002788 	.word	0x20002788
 800b364:	200027a0 	.word	0x200027a0
 800b368:	20002798 	.word	0x20002798
 800b36c:	20002794 	.word	0x20002794

0800b370 <tcp_close_shutdown_fin>:

static err_t
tcp_close_shutdown_fin(struct tcp_pcb *pcb)
{
 800b370:	b5b0      	push	{r4, r5, r7, lr}
 800b372:	b084      	sub	sp, #16
 800b374:	af00      	add	r7, sp, #0
 800b376:	6078      	str	r0, [r7, #4]
  err_t err;
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
 800b378:	687b      	ldr	r3, [r7, #4]
 800b37a:	2b00      	cmp	r3, #0
 800b37c:	d106      	bne.n	800b38c <tcp_close_shutdown_fin+0x1c>
 800b37e:	4b36      	ldr	r3, [pc, #216]	; (800b458 <tcp_close_shutdown_fin+0xe8>)
 800b380:	22ce      	movs	r2, #206	; 0xce
 800b382:	0052      	lsls	r2, r2, #1
 800b384:	4935      	ldr	r1, [pc, #212]	; (800b45c <tcp_close_shutdown_fin+0xec>)
 800b386:	4836      	ldr	r0, [pc, #216]	; (800b460 <tcp_close_shutdown_fin+0xf0>)
 800b388:	f7f6 ff2c 	bl	80021e4 <app_debug_rtt_raw>

  switch (pcb->state) {
 800b38c:	687b      	ldr	r3, [r7, #4]
 800b38e:	7e1b      	ldrb	r3, [r3, #24]
 800b390:	2b07      	cmp	r3, #7
 800b392:	d027      	beq.n	800b3e4 <tcp_close_shutdown_fin+0x74>
 800b394:	dc37      	bgt.n	800b406 <tcp_close_shutdown_fin+0x96>
 800b396:	2b03      	cmp	r3, #3
 800b398:	d002      	beq.n	800b3a0 <tcp_close_shutdown_fin+0x30>
 800b39a:	2b04      	cmp	r3, #4
 800b39c:	d011      	beq.n	800b3c2 <tcp_close_shutdown_fin+0x52>
 800b39e:	e032      	b.n	800b406 <tcp_close_shutdown_fin+0x96>
    case SYN_RCVD:
      err = tcp_send_fin(pcb);
 800b3a0:	250f      	movs	r5, #15
 800b3a2:	197c      	adds	r4, r7, r5
 800b3a4:	687b      	ldr	r3, [r7, #4]
 800b3a6:	0018      	movs	r0, r3
 800b3a8:	f005 fe80 	bl	80110ac <tcp_send_fin>
 800b3ac:	0003      	movs	r3, r0
 800b3ae:	7023      	strb	r3, [r4, #0]
      if (err == ERR_OK) {
 800b3b0:	197b      	adds	r3, r7, r5
 800b3b2:	781b      	ldrb	r3, [r3, #0]
 800b3b4:	b25b      	sxtb	r3, r3
 800b3b6:	2b00      	cmp	r3, #0
 800b3b8:	d127      	bne.n	800b40a <tcp_close_shutdown_fin+0x9a>
        tcp_backlog_accepted(pcb);
        MIB2_STATS_INC(mib2.tcpattemptfails);
        pcb->state = FIN_WAIT_1;
 800b3ba:	687b      	ldr	r3, [r7, #4]
 800b3bc:	2205      	movs	r2, #5
 800b3be:	761a      	strb	r2, [r3, #24]
      }
      break;
 800b3c0:	e023      	b.n	800b40a <tcp_close_shutdown_fin+0x9a>
    case ESTABLISHED:
      err = tcp_send_fin(pcb);
 800b3c2:	250f      	movs	r5, #15
 800b3c4:	197c      	adds	r4, r7, r5
 800b3c6:	687b      	ldr	r3, [r7, #4]
 800b3c8:	0018      	movs	r0, r3
 800b3ca:	f005 fe6f 	bl	80110ac <tcp_send_fin>
 800b3ce:	0003      	movs	r3, r0
 800b3d0:	7023      	strb	r3, [r4, #0]
      if (err == ERR_OK) {
 800b3d2:	197b      	adds	r3, r7, r5
 800b3d4:	781b      	ldrb	r3, [r3, #0]
 800b3d6:	b25b      	sxtb	r3, r3
 800b3d8:	2b00      	cmp	r3, #0
 800b3da:	d118      	bne.n	800b40e <tcp_close_shutdown_fin+0x9e>
        MIB2_STATS_INC(mib2.tcpestabresets);
        pcb->state = FIN_WAIT_1;
 800b3dc:	687b      	ldr	r3, [r7, #4]
 800b3de:	2205      	movs	r2, #5
 800b3e0:	761a      	strb	r2, [r3, #24]
      }
      break;
 800b3e2:	e014      	b.n	800b40e <tcp_close_shutdown_fin+0x9e>
    case CLOSE_WAIT:
      err = tcp_send_fin(pcb);
 800b3e4:	250f      	movs	r5, #15
 800b3e6:	197c      	adds	r4, r7, r5
 800b3e8:	687b      	ldr	r3, [r7, #4]
 800b3ea:	0018      	movs	r0, r3
 800b3ec:	f005 fe5e 	bl	80110ac <tcp_send_fin>
 800b3f0:	0003      	movs	r3, r0
 800b3f2:	7023      	strb	r3, [r4, #0]
      if (err == ERR_OK) {
 800b3f4:	197b      	adds	r3, r7, r5
 800b3f6:	781b      	ldrb	r3, [r3, #0]
 800b3f8:	b25b      	sxtb	r3, r3
 800b3fa:	2b00      	cmp	r3, #0
 800b3fc:	d109      	bne.n	800b412 <tcp_close_shutdown_fin+0xa2>
        MIB2_STATS_INC(mib2.tcpestabresets);
        pcb->state = LAST_ACK;
 800b3fe:	687b      	ldr	r3, [r7, #4]
 800b400:	2209      	movs	r2, #9
 800b402:	761a      	strb	r2, [r3, #24]
      }
      break;
 800b404:	e005      	b.n	800b412 <tcp_close_shutdown_fin+0xa2>
    default:
      /* Has already been closed, do nothing. */
      return ERR_OK;
 800b406:	2300      	movs	r3, #0
 800b408:	e022      	b.n	800b450 <tcp_close_shutdown_fin+0xe0>
      break;
 800b40a:	46c0      	nop			; (mov r8, r8)
 800b40c:	e002      	b.n	800b414 <tcp_close_shutdown_fin+0xa4>
      break;
 800b40e:	46c0      	nop			; (mov r8, r8)
 800b410:	e000      	b.n	800b414 <tcp_close_shutdown_fin+0xa4>
      break;
 800b412:	46c0      	nop			; (mov r8, r8)
  }

  if (err == ERR_OK) {
 800b414:	230f      	movs	r3, #15
 800b416:	18fb      	adds	r3, r7, r3
 800b418:	781b      	ldrb	r3, [r3, #0]
 800b41a:	b25b      	sxtb	r3, r3
 800b41c:	2b00      	cmp	r3, #0
 800b41e:	d104      	bne.n	800b42a <tcp_close_shutdown_fin+0xba>
    /* To ensure all data has been sent when tcp_close returns, we have
       to make sure tcp_output doesn't fail.
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    tcp_output(pcb);
 800b420:	687b      	ldr	r3, [r7, #4]
 800b422:	0018      	movs	r0, r3
 800b424:	f005 ffb2 	bl	801138c <tcp_output>
 800b428:	e00e      	b.n	800b448 <tcp_close_shutdown_fin+0xd8>
  } else if (err == ERR_MEM) {
 800b42a:	230f      	movs	r3, #15
 800b42c:	18fb      	adds	r3, r7, r3
 800b42e:	781b      	ldrb	r3, [r3, #0]
 800b430:	b25b      	sxtb	r3, r3
 800b432:	3301      	adds	r3, #1
 800b434:	d108      	bne.n	800b448 <tcp_close_shutdown_fin+0xd8>
    /* Mark this pcb for closing. Closing is retried from tcp_tmr. */
    tcp_set_flags(pcb, TF_CLOSEPEND);
 800b436:	687b      	ldr	r3, [r7, #4]
 800b438:	8bdb      	ldrh	r3, [r3, #30]
 800b43a:	2208      	movs	r2, #8
 800b43c:	4313      	orrs	r3, r2
 800b43e:	b29a      	uxth	r2, r3
 800b440:	687b      	ldr	r3, [r7, #4]
 800b442:	83da      	strh	r2, [r3, #30]
    /* We have to return ERR_OK from here to indicate to the callers that this
       pcb should not be used any more as it will be freed soon via tcp_tmr.
       This is OK here since sending FIN does not guarantee a time frime for
       actually freeing the pcb, either (it is left in closure states for
       remote ACK or timeout) */
    return ERR_OK;
 800b444:	2300      	movs	r3, #0
 800b446:	e003      	b.n	800b450 <tcp_close_shutdown_fin+0xe0>
  }
  return err;
 800b448:	230f      	movs	r3, #15
 800b44a:	18fb      	adds	r3, r7, r3
 800b44c:	781b      	ldrb	r3, [r3, #0]
 800b44e:	b25b      	sxtb	r3, r3
}
 800b450:	0018      	movs	r0, r3
 800b452:	46bd      	mov	sp, r7
 800b454:	b004      	add	sp, #16
 800b456:	bdb0      	pop	{r4, r5, r7, pc}
 800b458:	08020aa8 	.word	0x08020aa8
 800b45c:	08020b54 	.word	0x08020b54
 800b460:	08020ae4 	.word	0x08020ae4

0800b464 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
 800b464:	b580      	push	{r7, lr}
 800b466:	b082      	sub	sp, #8
 800b468:	af00      	add	r7, sp, #0
 800b46a:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_close: invalid pcb", pcb != NULL, return ERR_ARG);
 800b46c:	687b      	ldr	r3, [r7, #4]
 800b46e:	2b00      	cmp	r3, #0
 800b470:	d106      	bne.n	800b480 <tcp_close+0x1c>
 800b472:	4b0e      	ldr	r3, [pc, #56]	; (800b4ac <tcp_close+0x48>)
 800b474:	0018      	movs	r0, r3
 800b476:	f7f6 feb5 	bl	80021e4 <app_debug_rtt_raw>
 800b47a:	2310      	movs	r3, #16
 800b47c:	425b      	negs	r3, r3
 800b47e:	e010      	b.n	800b4a2 <tcp_close+0x3e>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));

  tcp_debug_print_state(pcb->state);

  if (pcb->state != LISTEN) {
 800b480:	687b      	ldr	r3, [r7, #4]
 800b482:	7e1b      	ldrb	r3, [r3, #24]
 800b484:	2b01      	cmp	r3, #1
 800b486:	d006      	beq.n	800b496 <tcp_close+0x32>
    /* Set a flag not to receive any more data... */
    tcp_set_flags(pcb, TF_RXCLOSED);
 800b488:	687b      	ldr	r3, [r7, #4]
 800b48a:	8bdb      	ldrh	r3, [r3, #30]
 800b48c:	2210      	movs	r2, #16
 800b48e:	4313      	orrs	r3, r2
 800b490:	b29a      	uxth	r2, r3
 800b492:	687b      	ldr	r3, [r7, #4]
 800b494:	83da      	strh	r2, [r3, #30]
  }
  /* ... and close */
  return tcp_close_shutdown(pcb, 1);
 800b496:	687b      	ldr	r3, [r7, #4]
 800b498:	2101      	movs	r1, #1
 800b49a:	0018      	movs	r0, r3
 800b49c:	f7ff fe78 	bl	800b190 <tcp_close_shutdown>
 800b4a0:	0003      	movs	r3, r0
}
 800b4a2:	0018      	movs	r0, r3
 800b4a4:	46bd      	mov	sp, r7
 800b4a6:	b002      	add	sp, #8
 800b4a8:	bd80      	pop	{r7, pc}
 800b4aa:	46c0      	nop			; (mov r8, r8)
 800b4ac:	08020bb4 	.word	0x08020bb4

0800b4b0 <tcp_abandon>:
 * @param pcb the tcp_pcb to abort
 * @param reset boolean to indicate whether a reset should be sent
 */
void
tcp_abandon(struct tcp_pcb *pcb, int reset)
{
 800b4b0:	b5b0      	push	{r4, r5, r7, lr}
 800b4b2:	b08e      	sub	sp, #56	; 0x38
 800b4b4:	af04      	add	r7, sp, #16
 800b4b6:	6078      	str	r0, [r7, #4]
 800b4b8:	6039      	str	r1, [r7, #0]
#endif /* LWIP_CALLBACK_API */
  void *errf_arg;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_abandon: invalid pcb", pcb != NULL, return);
 800b4ba:	687b      	ldr	r3, [r7, #4]
 800b4bc:	2b00      	cmp	r3, #0
 800b4be:	d104      	bne.n	800b4ca <tcp_abandon+0x1a>
 800b4c0:	4b58      	ldr	r3, [pc, #352]	; (800b624 <tcp_abandon+0x174>)
 800b4c2:	0018      	movs	r0, r3
 800b4c4:	f7f6 fe8e 	bl	80021e4 <app_debug_rtt_raw>
 800b4c8:	e0a9      	b.n	800b61e <tcp_abandon+0x16e>

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
 800b4ca:	687b      	ldr	r3, [r7, #4]
 800b4cc:	7e1b      	ldrb	r3, [r3, #24]
 800b4ce:	2b01      	cmp	r3, #1
 800b4d0:	d106      	bne.n	800b4e0 <tcp_abandon+0x30>
 800b4d2:	4b55      	ldr	r3, [pc, #340]	; (800b628 <tcp_abandon+0x178>)
 800b4d4:	2290      	movs	r2, #144	; 0x90
 800b4d6:	0092      	lsls	r2, r2, #2
 800b4d8:	4954      	ldr	r1, [pc, #336]	; (800b62c <tcp_abandon+0x17c>)
 800b4da:	4855      	ldr	r0, [pc, #340]	; (800b630 <tcp_abandon+0x180>)
 800b4dc:	f7f6 fe82 	bl	80021e4 <app_debug_rtt_raw>
              pcb->state != LISTEN);
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
 800b4e0:	687b      	ldr	r3, [r7, #4]
 800b4e2:	7e1b      	ldrb	r3, [r3, #24]
 800b4e4:	2b0a      	cmp	r3, #10
 800b4e6:	d10a      	bne.n	800b4fe <tcp_abandon+0x4e>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
 800b4e8:	687a      	ldr	r2, [r7, #4]
 800b4ea:	4b52      	ldr	r3, [pc, #328]	; (800b634 <tcp_abandon+0x184>)
 800b4ec:	0011      	movs	r1, r2
 800b4ee:	0018      	movs	r0, r3
 800b4f0:	f001 fb6a 	bl	800cbc8 <tcp_pcb_remove>
    tcp_free(pcb);
 800b4f4:	687b      	ldr	r3, [r7, #4]
 800b4f6:	0018      	movs	r0, r3
 800b4f8:	f7ff fd8e 	bl	800b018 <tcp_free>
 800b4fc:	e08f      	b.n	800b61e <tcp_abandon+0x16e>
  } else {
    int send_rst = 0;
 800b4fe:	2300      	movs	r3, #0
 800b500:	627b      	str	r3, [r7, #36]	; 0x24
    u16_t local_port = 0;
 800b502:	2322      	movs	r3, #34	; 0x22
 800b504:	18fb      	adds	r3, r7, r3
 800b506:	2200      	movs	r2, #0
 800b508:	801a      	strh	r2, [r3, #0]
    enum tcp_state last_state;
    seqno = pcb->snd_nxt;
 800b50a:	687b      	ldr	r3, [r7, #4]
 800b50c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800b50e:	61bb      	str	r3, [r7, #24]
    ackno = pcb->rcv_nxt;
 800b510:	687b      	ldr	r3, [r7, #4]
 800b512:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b514:	617b      	str	r3, [r7, #20]
#if LWIP_CALLBACK_API
    errf = pcb->errf;
 800b516:	687b      	ldr	r3, [r7, #4]
 800b518:	2294      	movs	r2, #148	; 0x94
 800b51a:	589b      	ldr	r3, [r3, r2]
 800b51c:	613b      	str	r3, [r7, #16]
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
 800b51e:	687b      	ldr	r3, [r7, #4]
 800b520:	695b      	ldr	r3, [r3, #20]
 800b522:	60fb      	str	r3, [r7, #12]
    if (pcb->state == CLOSED) {
 800b524:	687b      	ldr	r3, [r7, #4]
 800b526:	7e1b      	ldrb	r3, [r3, #24]
 800b528:	2b00      	cmp	r3, #0
 800b52a:	d126      	bne.n	800b57a <tcp_abandon+0xca>
      if (pcb->local_port != 0) {
 800b52c:	687b      	ldr	r3, [r7, #4]
 800b52e:	8b5b      	ldrh	r3, [r3, #26]
 800b530:	2b00      	cmp	r3, #0
 800b532:	d032      	beq.n	800b59a <tcp_abandon+0xea>
        /* bound, not yet opened */
        TCP_RMV(&tcp_bound_pcbs, pcb);
 800b534:	4b40      	ldr	r3, [pc, #256]	; (800b638 <tcp_abandon+0x188>)
 800b536:	681b      	ldr	r3, [r3, #0]
 800b538:	687a      	ldr	r2, [r7, #4]
 800b53a:	429a      	cmp	r2, r3
 800b53c:	d105      	bne.n	800b54a <tcp_abandon+0x9a>
 800b53e:	4b3e      	ldr	r3, [pc, #248]	; (800b638 <tcp_abandon+0x188>)
 800b540:	681b      	ldr	r3, [r3, #0]
 800b542:	691a      	ldr	r2, [r3, #16]
 800b544:	4b3c      	ldr	r3, [pc, #240]	; (800b638 <tcp_abandon+0x188>)
 800b546:	601a      	str	r2, [r3, #0]
 800b548:	e013      	b.n	800b572 <tcp_abandon+0xc2>
 800b54a:	4b3b      	ldr	r3, [pc, #236]	; (800b638 <tcp_abandon+0x188>)
 800b54c:	681b      	ldr	r3, [r3, #0]
 800b54e:	61fb      	str	r3, [r7, #28]
 800b550:	e00c      	b.n	800b56c <tcp_abandon+0xbc>
 800b552:	69fb      	ldr	r3, [r7, #28]
 800b554:	691b      	ldr	r3, [r3, #16]
 800b556:	687a      	ldr	r2, [r7, #4]
 800b558:	429a      	cmp	r2, r3
 800b55a:	d104      	bne.n	800b566 <tcp_abandon+0xb6>
 800b55c:	687b      	ldr	r3, [r7, #4]
 800b55e:	691a      	ldr	r2, [r3, #16]
 800b560:	69fb      	ldr	r3, [r7, #28]
 800b562:	611a      	str	r2, [r3, #16]
 800b564:	e005      	b.n	800b572 <tcp_abandon+0xc2>
 800b566:	69fb      	ldr	r3, [r7, #28]
 800b568:	691b      	ldr	r3, [r3, #16]
 800b56a:	61fb      	str	r3, [r7, #28]
 800b56c:	69fb      	ldr	r3, [r7, #28]
 800b56e:	2b00      	cmp	r3, #0
 800b570:	d1ef      	bne.n	800b552 <tcp_abandon+0xa2>
 800b572:	687b      	ldr	r3, [r7, #4]
 800b574:	2200      	movs	r2, #0
 800b576:	611a      	str	r2, [r3, #16]
 800b578:	e00f      	b.n	800b59a <tcp_abandon+0xea>
      }
    } else {
      send_rst = reset;
 800b57a:	683b      	ldr	r3, [r7, #0]
 800b57c:	627b      	str	r3, [r7, #36]	; 0x24
      local_port = pcb->local_port;
 800b57e:	2322      	movs	r3, #34	; 0x22
 800b580:	18fb      	adds	r3, r7, r3
 800b582:	687a      	ldr	r2, [r7, #4]
 800b584:	8b52      	ldrh	r2, [r2, #26]
 800b586:	801a      	strh	r2, [r3, #0]
      TCP_PCB_REMOVE_ACTIVE(pcb);
 800b588:	687a      	ldr	r2, [r7, #4]
 800b58a:	4b2c      	ldr	r3, [pc, #176]	; (800b63c <tcp_abandon+0x18c>)
 800b58c:	0011      	movs	r1, r2
 800b58e:	0018      	movs	r0, r3
 800b590:	f001 fb1a 	bl	800cbc8 <tcp_pcb_remove>
 800b594:	4b2a      	ldr	r3, [pc, #168]	; (800b640 <tcp_abandon+0x190>)
 800b596:	2201      	movs	r2, #1
 800b598:	701a      	strb	r2, [r3, #0]
    }
    if (pcb->unacked != NULL) {
 800b59a:	687b      	ldr	r3, [r7, #4]
 800b59c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800b59e:	2b00      	cmp	r3, #0
 800b5a0:	d004      	beq.n	800b5ac <tcp_abandon+0xfc>
      tcp_segs_free(pcb->unacked);
 800b5a2:	687b      	ldr	r3, [r7, #4]
 800b5a4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800b5a6:	0018      	movs	r0, r3
 800b5a8:	f000 ffde 	bl	800c568 <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
 800b5ac:	687b      	ldr	r3, [r7, #4]
 800b5ae:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800b5b0:	2b00      	cmp	r3, #0
 800b5b2:	d004      	beq.n	800b5be <tcp_abandon+0x10e>
      tcp_segs_free(pcb->unsent);
 800b5b4:	687b      	ldr	r3, [r7, #4]
 800b5b6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800b5b8:	0018      	movs	r0, r3
 800b5ba:	f000 ffd5 	bl	800c568 <tcp_segs_free>
    }
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
 800b5be:	687b      	ldr	r3, [r7, #4]
 800b5c0:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800b5c2:	2b00      	cmp	r3, #0
 800b5c4:	d004      	beq.n	800b5d0 <tcp_abandon+0x120>
      tcp_segs_free(pcb->ooseq);
 800b5c6:	687b      	ldr	r3, [r7, #4]
 800b5c8:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800b5ca:	0018      	movs	r0, r3
 800b5cc:	f000 ffcc 	bl	800c568 <tcp_segs_free>
    }
#endif /* TCP_QUEUE_OOSEQ */
    tcp_backlog_accepted(pcb);
    if (send_rst) {
 800b5d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b5d2:	2b00      	cmp	r3, #0
 800b5d4:	d011      	beq.n	800b5fa <tcp_abandon+0x14a>
      LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
      tcp_rst(pcb, seqno, ackno, &pcb->local_ip, &pcb->remote_ip, local_port, pcb->remote_port);
 800b5d6:	687d      	ldr	r5, [r7, #4]
 800b5d8:	687b      	ldr	r3, [r7, #4]
 800b5da:	3304      	adds	r3, #4
 800b5dc:	687a      	ldr	r2, [r7, #4]
 800b5de:	8b92      	ldrh	r2, [r2, #28]
 800b5e0:	697c      	ldr	r4, [r7, #20]
 800b5e2:	69b9      	ldr	r1, [r7, #24]
 800b5e4:	6878      	ldr	r0, [r7, #4]
 800b5e6:	9202      	str	r2, [sp, #8]
 800b5e8:	2222      	movs	r2, #34	; 0x22
 800b5ea:	18ba      	adds	r2, r7, r2
 800b5ec:	8812      	ldrh	r2, [r2, #0]
 800b5ee:	9201      	str	r2, [sp, #4]
 800b5f0:	9300      	str	r3, [sp, #0]
 800b5f2:	002b      	movs	r3, r5
 800b5f4:	0022      	movs	r2, r4
 800b5f6:	f006 ff1d 	bl	8012434 <tcp_rst>
    }
    last_state = pcb->state;
 800b5fa:	230b      	movs	r3, #11
 800b5fc:	18fb      	adds	r3, r7, r3
 800b5fe:	687a      	ldr	r2, [r7, #4]
 800b600:	7e12      	ldrb	r2, [r2, #24]
 800b602:	701a      	strb	r2, [r3, #0]
    tcp_free(pcb);
 800b604:	687b      	ldr	r3, [r7, #4]
 800b606:	0018      	movs	r0, r3
 800b608:	f7ff fd06 	bl	800b018 <tcp_free>
    TCP_EVENT_ERR(last_state, errf, errf_arg, ERR_ABRT);
 800b60c:	693b      	ldr	r3, [r7, #16]
 800b60e:	2b00      	cmp	r3, #0
 800b610:	d005      	beq.n	800b61e <tcp_abandon+0x16e>
 800b612:	230d      	movs	r3, #13
 800b614:	4259      	negs	r1, r3
 800b616:	68fa      	ldr	r2, [r7, #12]
 800b618:	693b      	ldr	r3, [r7, #16]
 800b61a:	0010      	movs	r0, r2
 800b61c:	4798      	blx	r3
  }
}
 800b61e:	46bd      	mov	sp, r7
 800b620:	b00a      	add	sp, #40	; 0x28
 800b622:	bdb0      	pop	{r4, r5, r7, pc}
 800b624:	08020be8 	.word	0x08020be8
 800b628:	08020aa8 	.word	0x08020aa8
 800b62c:	08020c04 	.word	0x08020c04
 800b630:	08020ae4 	.word	0x08020ae4
 800b634:	2000279c 	.word	0x2000279c
 800b638:	20002798 	.word	0x20002798
 800b63c:	2000278c 	.word	0x2000278c
 800b640:	20002788 	.word	0x20002788

0800b644 <tcp_abort>:
 *
 * @param pcb the tcp pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
 800b644:	b580      	push	{r7, lr}
 800b646:	b082      	sub	sp, #8
 800b648:	af00      	add	r7, sp, #0
 800b64a:	6078      	str	r0, [r7, #4]
  tcp_abandon(pcb, 1);
 800b64c:	687b      	ldr	r3, [r7, #4]
 800b64e:	2101      	movs	r1, #1
 800b650:	0018      	movs	r0, r3
 800b652:	f7ff ff2d 	bl	800b4b0 <tcp_abandon>
}
 800b656:	46c0      	nop			; (mov r8, r8)
 800b658:	46bd      	mov	sp, r7
 800b65a:	b002      	add	sp, #8
 800b65c:	bd80      	pop	{r7, pc}
	...

0800b660 <tcp_bind>:
 *         ERR_VAL if bind failed because the PCB is not in a valid state
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
{
 800b660:	b590      	push	{r4, r7, lr}
 800b662:	b089      	sub	sp, #36	; 0x24
 800b664:	af00      	add	r7, sp, #0
 800b666:	60f8      	str	r0, [r7, #12]
 800b668:	60b9      	str	r1, [r7, #8]
 800b66a:	1dbb      	adds	r3, r7, #6
 800b66c:	801a      	strh	r2, [r3, #0]
  int i;
  int max_pcb_list = NUM_TCP_PCB_LISTS;
 800b66e:	2304      	movs	r3, #4
 800b670:	61bb      	str	r3, [r7, #24]

  LWIP_ASSERT_CORE_LOCKED();

#if LWIP_IPV4
  /* Don't propagate NULL pointer (IPv4 ANY) to subsequent functions */
  if (ipaddr == NULL) {
 800b672:	68bb      	ldr	r3, [r7, #8]
 800b674:	2b00      	cmp	r3, #0
 800b676:	d101      	bne.n	800b67c <tcp_bind+0x1c>
    ipaddr = IP4_ADDR_ANY;
 800b678:	4b48      	ldr	r3, [pc, #288]	; (800b79c <tcp_bind+0x13c>)
 800b67a:	60bb      	str	r3, [r7, #8]
  }
#else /* LWIP_IPV4 */
  LWIP_ERROR("tcp_bind: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
#endif /* LWIP_IPV4 */

  LWIP_ERROR("tcp_bind: invalid pcb", pcb != NULL, return ERR_ARG);
 800b67c:	68fb      	ldr	r3, [r7, #12]
 800b67e:	2b00      	cmp	r3, #0
 800b680:	d106      	bne.n	800b690 <tcp_bind+0x30>
 800b682:	4b47      	ldr	r3, [pc, #284]	; (800b7a0 <tcp_bind+0x140>)
 800b684:	0018      	movs	r0, r3
 800b686:	f7f6 fdad 	bl	80021e4 <app_debug_rtt_raw>
 800b68a:	2310      	movs	r3, #16
 800b68c:	425b      	negs	r3, r3
 800b68e:	e080      	b.n	800b792 <tcp_bind+0x132>

  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
 800b690:	68fb      	ldr	r3, [r7, #12]
 800b692:	7e1b      	ldrb	r3, [r3, #24]
 800b694:	2b00      	cmp	r3, #0
 800b696:	d006      	beq.n	800b6a6 <tcp_bind+0x46>
 800b698:	4b42      	ldr	r3, [pc, #264]	; (800b7a4 <tcp_bind+0x144>)
 800b69a:	0018      	movs	r0, r3
 800b69c:	f7f6 fda2 	bl	80021e4 <app_debug_rtt_raw>
 800b6a0:	2306      	movs	r3, #6
 800b6a2:	425b      	negs	r3, r3
 800b6a4:	e075      	b.n	800b792 <tcp_bind+0x132>
  /* Unless the REUSEADDR flag is set,
     we have to check the pcbs in TIME-WAIT state, also.
     We do not dump TIME_WAIT pcb's; they can still be matched by incoming
     packets using both local and remote IP addresses and ports to distinguish.
   */
  if (ip_get_option(pcb, SOF_REUSEADDR)) {
 800b6a6:	68fb      	ldr	r3, [r7, #12]
 800b6a8:	7a5b      	ldrb	r3, [r3, #9]
 800b6aa:	001a      	movs	r2, r3
 800b6ac:	2304      	movs	r3, #4
 800b6ae:	4013      	ands	r3, r2
 800b6b0:	d001      	beq.n	800b6b6 <tcp_bind+0x56>
    max_pcb_list = NUM_TCP_PCB_LISTS_NO_TIME_WAIT;
 800b6b2:	2303      	movs	r3, #3
 800b6b4:	61bb      	str	r3, [r7, #24]
    ip6_addr_select_zone(ip_2_ip6(&zoned_ipaddr), ip_2_ip6(&zoned_ipaddr));
    ipaddr = &zoned_ipaddr;
  }
#endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */

  if (port == 0) {
 800b6b6:	1dbb      	adds	r3, r7, #6
 800b6b8:	881b      	ldrh	r3, [r3, #0]
 800b6ba:	2b00      	cmp	r3, #0
 800b6bc:	d10b      	bne.n	800b6d6 <tcp_bind+0x76>
    port = tcp_new_port();
 800b6be:	1dbc      	adds	r4, r7, #6
 800b6c0:	f000 f932 	bl	800b928 <tcp_new_port>
 800b6c4:	0003      	movs	r3, r0
 800b6c6:	8023      	strh	r3, [r4, #0]
    if (port == 0) {
 800b6c8:	1dbb      	adds	r3, r7, #6
 800b6ca:	881b      	ldrh	r3, [r3, #0]
 800b6cc:	2b00      	cmp	r3, #0
 800b6ce:	d142      	bne.n	800b756 <tcp_bind+0xf6>
      return ERR_BUF;
 800b6d0:	2302      	movs	r3, #2
 800b6d2:	425b      	negs	r3, r3
 800b6d4:	e05d      	b.n	800b792 <tcp_bind+0x132>
    }
  } else {
    /* Check if the address already is in use (on all lists) */
    for (i = 0; i < max_pcb_list; i++) {
 800b6d6:	2300      	movs	r3, #0
 800b6d8:	61fb      	str	r3, [r7, #28]
 800b6da:	e038      	b.n	800b74e <tcp_bind+0xee>
      for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 800b6dc:	4b32      	ldr	r3, [pc, #200]	; (800b7a8 <tcp_bind+0x148>)
 800b6de:	69fa      	ldr	r2, [r7, #28]
 800b6e0:	0092      	lsls	r2, r2, #2
 800b6e2:	58d3      	ldr	r3, [r2, r3]
 800b6e4:	681b      	ldr	r3, [r3, #0]
 800b6e6:	617b      	str	r3, [r7, #20]
 800b6e8:	e02b      	b.n	800b742 <tcp_bind+0xe2>
        if (cpcb->local_port == port) {
 800b6ea:	697b      	ldr	r3, [r7, #20]
 800b6ec:	8b5b      	ldrh	r3, [r3, #26]
 800b6ee:	1dba      	adds	r2, r7, #6
 800b6f0:	8812      	ldrh	r2, [r2, #0]
 800b6f2:	429a      	cmp	r2, r3
 800b6f4:	d122      	bne.n	800b73c <tcp_bind+0xdc>
#if SO_REUSE
          /* Omit checking for the same port if both pcbs have REUSEADDR set.
             For SO_REUSEADDR, the duplicate-check for a 5-tuple is done in
             tcp_connect. */
          if (!ip_get_option(pcb, SOF_REUSEADDR) ||
 800b6f6:	68fb      	ldr	r3, [r7, #12]
 800b6f8:	7a5b      	ldrb	r3, [r3, #9]
 800b6fa:	001a      	movs	r2, r3
 800b6fc:	2304      	movs	r3, #4
 800b6fe:	4013      	ands	r3, r2
 800b700:	d005      	beq.n	800b70e <tcp_bind+0xae>
              !ip_get_option(cpcb, SOF_REUSEADDR))
 800b702:	697b      	ldr	r3, [r7, #20]
 800b704:	7a5b      	ldrb	r3, [r3, #9]
 800b706:	001a      	movs	r2, r3
 800b708:	2304      	movs	r3, #4
 800b70a:	4013      	ands	r3, r2
          if (!ip_get_option(pcb, SOF_REUSEADDR) ||
 800b70c:	d116      	bne.n	800b73c <tcp_bind+0xdc>
#endif /* SO_REUSE */
          {
            /* @todo: check accept_any_ip_version */
            if ((IP_IS_V6(ipaddr) == IP_IS_V6_VAL(cpcb->local_ip)) &&
                (ip_addr_isany(&cpcb->local_ip) ||
 800b70e:	697b      	ldr	r3, [r7, #20]
            if ((IP_IS_V6(ipaddr) == IP_IS_V6_VAL(cpcb->local_ip)) &&
 800b710:	2b00      	cmp	r3, #0
 800b712:	d010      	beq.n	800b736 <tcp_bind+0xd6>
                (ip_addr_isany(&cpcb->local_ip) ||
 800b714:	697b      	ldr	r3, [r7, #20]
 800b716:	681b      	ldr	r3, [r3, #0]
 800b718:	2b00      	cmp	r3, #0
 800b71a:	d00c      	beq.n	800b736 <tcp_bind+0xd6>
 800b71c:	68bb      	ldr	r3, [r7, #8]
 800b71e:	2b00      	cmp	r3, #0
 800b720:	d009      	beq.n	800b736 <tcp_bind+0xd6>
                 ip_addr_isany(ipaddr) ||
 800b722:	68bb      	ldr	r3, [r7, #8]
 800b724:	681b      	ldr	r3, [r3, #0]
 800b726:	2b00      	cmp	r3, #0
 800b728:	d005      	beq.n	800b736 <tcp_bind+0xd6>
                 ip_addr_cmp(&cpcb->local_ip, ipaddr))) {
 800b72a:	697b      	ldr	r3, [r7, #20]
 800b72c:	681a      	ldr	r2, [r3, #0]
 800b72e:	68bb      	ldr	r3, [r7, #8]
 800b730:	681b      	ldr	r3, [r3, #0]
            if ((IP_IS_V6(ipaddr) == IP_IS_V6_VAL(cpcb->local_ip)) &&
 800b732:	429a      	cmp	r2, r3
 800b734:	d102      	bne.n	800b73c <tcp_bind+0xdc>
              return ERR_USE;
 800b736:	2308      	movs	r3, #8
 800b738:	425b      	negs	r3, r3
 800b73a:	e02a      	b.n	800b792 <tcp_bind+0x132>
      for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 800b73c:	697b      	ldr	r3, [r7, #20]
 800b73e:	691b      	ldr	r3, [r3, #16]
 800b740:	617b      	str	r3, [r7, #20]
 800b742:	697b      	ldr	r3, [r7, #20]
 800b744:	2b00      	cmp	r3, #0
 800b746:	d1d0      	bne.n	800b6ea <tcp_bind+0x8a>
    for (i = 0; i < max_pcb_list; i++) {
 800b748:	69fb      	ldr	r3, [r7, #28]
 800b74a:	3301      	adds	r3, #1
 800b74c:	61fb      	str	r3, [r7, #28]
 800b74e:	69fa      	ldr	r2, [r7, #28]
 800b750:	69bb      	ldr	r3, [r7, #24]
 800b752:	429a      	cmp	r2, r3
 800b754:	dbc2      	blt.n	800b6dc <tcp_bind+0x7c>
        }
      }
    }
  }

  if (!ip_addr_isany(ipaddr)
 800b756:	68bb      	ldr	r3, [r7, #8]
 800b758:	2b00      	cmp	r3, #0
 800b75a:	d00c      	beq.n	800b776 <tcp_bind+0x116>
 800b75c:	68bb      	ldr	r3, [r7, #8]
 800b75e:	681b      	ldr	r3, [r3, #0]
 800b760:	2b00      	cmp	r3, #0
 800b762:	d008      	beq.n	800b776 <tcp_bind+0x116>
#if LWIP_IPV4 && LWIP_IPV6
      || (IP_GET_TYPE(ipaddr) != IP_GET_TYPE(&pcb->local_ip))
#endif /* LWIP_IPV4 && LWIP_IPV6 */
     ) {
    ip_addr_set(&pcb->local_ip, ipaddr);
 800b764:	68bb      	ldr	r3, [r7, #8]
 800b766:	2b00      	cmp	r3, #0
 800b768:	d002      	beq.n	800b770 <tcp_bind+0x110>
 800b76a:	68bb      	ldr	r3, [r7, #8]
 800b76c:	681a      	ldr	r2, [r3, #0]
 800b76e:	e000      	b.n	800b772 <tcp_bind+0x112>
 800b770:	2200      	movs	r2, #0
 800b772:	68fb      	ldr	r3, [r7, #12]
 800b774:	601a      	str	r2, [r3, #0]
  }
  pcb->local_port = port;
 800b776:	68fb      	ldr	r3, [r7, #12]
 800b778:	1dba      	adds	r2, r7, #6
 800b77a:	8812      	ldrh	r2, [r2, #0]
 800b77c:	835a      	strh	r2, [r3, #26]
  TCP_REG(&tcp_bound_pcbs, pcb);
 800b77e:	4b0b      	ldr	r3, [pc, #44]	; (800b7ac <tcp_bind+0x14c>)
 800b780:	681a      	ldr	r2, [r3, #0]
 800b782:	68fb      	ldr	r3, [r7, #12]
 800b784:	611a      	str	r2, [r3, #16]
 800b786:	4b09      	ldr	r3, [pc, #36]	; (800b7ac <tcp_bind+0x14c>)
 800b788:	68fa      	ldr	r2, [r7, #12]
 800b78a:	601a      	str	r2, [r3, #0]
 800b78c:	f007 f87c 	bl	8012888 <tcp_timer_needed>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
 800b790:	2300      	movs	r3, #0
}
 800b792:	0018      	movs	r0, r3
 800b794:	46bd      	mov	sp, r7
 800b796:	b009      	add	sp, #36	; 0x24
 800b798:	bd90      	pop	{r4, r7, pc}
 800b79a:	46c0      	nop			; (mov r8, r8)
 800b79c:	08023a8c 	.word	0x08023a8c
 800b7a0:	08020c38 	.word	0x08020c38
 800b7a4:	08020c50 	.word	0x08020c50
 800b7a8:	08023a44 	.word	0x08023a44
 800b7ac:	20002798 	.word	0x20002798

0800b7b0 <tcp_update_rcv_ann_wnd>:
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t
tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
 800b7b0:	b580      	push	{r7, lr}
 800b7b2:	b084      	sub	sp, #16
 800b7b4:	af00      	add	r7, sp, #0
 800b7b6:	6078      	str	r0, [r7, #4]
  u32_t new_right_edge;

  LWIP_ASSERT("tcp_update_rcv_ann_wnd: invalid pcb", pcb != NULL);
 800b7b8:	687b      	ldr	r3, [r7, #4]
 800b7ba:	2b00      	cmp	r3, #0
 800b7bc:	d105      	bne.n	800b7ca <tcp_update_rcv_ann_wnd+0x1a>
 800b7be:	4b26      	ldr	r3, [pc, #152]	; (800b858 <tcp_update_rcv_ann_wnd+0xa8>)
 800b7c0:	4a26      	ldr	r2, [pc, #152]	; (800b85c <tcp_update_rcv_ann_wnd+0xac>)
 800b7c2:	4927      	ldr	r1, [pc, #156]	; (800b860 <tcp_update_rcv_ann_wnd+0xb0>)
 800b7c4:	4827      	ldr	r0, [pc, #156]	; (800b864 <tcp_update_rcv_ann_wnd+0xb4>)
 800b7c6:	f7f6 fd0d 	bl	80021e4 <app_debug_rtt_raw>
  new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 800b7ca:	687b      	ldr	r3, [r7, #4]
 800b7cc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b7ce:	687a      	ldr	r2, [r7, #4]
 800b7d0:	8d92      	ldrh	r2, [r2, #44]	; 0x2c
 800b7d2:	189b      	adds	r3, r3, r2
 800b7d4:	60fb      	str	r3, [r7, #12]

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 800b7d6:	687b      	ldr	r3, [r7, #4]
 800b7d8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b7da:	687a      	ldr	r2, [r7, #4]
 800b7dc:	8ed2      	ldrh	r2, [r2, #54]	; 0x36
 800b7de:	1c10      	adds	r0, r2, #0
 800b7e0:	b281      	uxth	r1, r0
 800b7e2:	2286      	movs	r2, #134	; 0x86
 800b7e4:	0092      	lsls	r2, r2, #2
 800b7e6:	4291      	cmp	r1, r2
 800b7e8:	d902      	bls.n	800b7f0 <tcp_update_rcv_ann_wnd+0x40>
 800b7ea:	2286      	movs	r2, #134	; 0x86
 800b7ec:	0092      	lsls	r2, r2, #2
 800b7ee:	1c10      	adds	r0, r2, #0
 800b7f0:	b282      	uxth	r2, r0
 800b7f2:	189b      	adds	r3, r3, r2
 800b7f4:	68fa      	ldr	r2, [r7, #12]
 800b7f6:	1ad3      	subs	r3, r2, r3
 800b7f8:	d408      	bmi.n	800b80c <tcp_update_rcv_ann_wnd+0x5c>
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
 800b7fa:	687b      	ldr	r3, [r7, #4]
 800b7fc:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800b7fe:	687b      	ldr	r3, [r7, #4]
 800b800:	85da      	strh	r2, [r3, #46]	; 0x2e
    return new_right_edge - pcb->rcv_ann_right_edge;
 800b802:	687b      	ldr	r3, [r7, #4]
 800b804:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b806:	68fa      	ldr	r2, [r7, #12]
 800b808:	1ad3      	subs	r3, r2, r3
 800b80a:	e020      	b.n	800b84e <tcp_update_rcv_ann_wnd+0x9e>
  } else {
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
 800b80c:	687b      	ldr	r3, [r7, #4]
 800b80e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800b810:	687b      	ldr	r3, [r7, #4]
 800b812:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b814:	1ad3      	subs	r3, r2, r3
 800b816:	2b00      	cmp	r3, #0
 800b818:	dd03      	ble.n	800b822 <tcp_update_rcv_ann_wnd+0x72>
      /* Can happen due to other end sending out of advertised window,
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
 800b81a:	687b      	ldr	r3, [r7, #4]
 800b81c:	2200      	movs	r2, #0
 800b81e:	85da      	strh	r2, [r3, #46]	; 0x2e
 800b820:	e014      	b.n	800b84c <tcp_update_rcv_ann_wnd+0x9c>
    } else {
      /* keep the right edge of window constant */
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
 800b822:	687b      	ldr	r3, [r7, #4]
 800b824:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800b826:	687b      	ldr	r3, [r7, #4]
 800b828:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b82a:	1ad3      	subs	r3, r2, r3
 800b82c:	60bb      	str	r3, [r7, #8]
#if !LWIP_WND_SCALE
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
 800b82e:	68ba      	ldr	r2, [r7, #8]
 800b830:	2380      	movs	r3, #128	; 0x80
 800b832:	025b      	lsls	r3, r3, #9
 800b834:	429a      	cmp	r2, r3
 800b836:	d305      	bcc.n	800b844 <tcp_update_rcv_ann_wnd+0x94>
 800b838:	4b07      	ldr	r3, [pc, #28]	; (800b858 <tcp_update_rcv_ann_wnd+0xa8>)
 800b83a:	4a0b      	ldr	r2, [pc, #44]	; (800b868 <tcp_update_rcv_ann_wnd+0xb8>)
 800b83c:	490b      	ldr	r1, [pc, #44]	; (800b86c <tcp_update_rcv_ann_wnd+0xbc>)
 800b83e:	4809      	ldr	r0, [pc, #36]	; (800b864 <tcp_update_rcv_ann_wnd+0xb4>)
 800b840:	f7f6 fcd0 	bl	80021e4 <app_debug_rtt_raw>
#endif
      pcb->rcv_ann_wnd = (tcpwnd_size_t)new_rcv_ann_wnd;
 800b844:	68bb      	ldr	r3, [r7, #8]
 800b846:	b29a      	uxth	r2, r3
 800b848:	687b      	ldr	r3, [r7, #4]
 800b84a:	85da      	strh	r2, [r3, #46]	; 0x2e
    }
    return 0;
 800b84c:	2300      	movs	r3, #0
  }
}
 800b84e:	0018      	movs	r0, r3
 800b850:	46bd      	mov	sp, r7
 800b852:	b004      	add	sp, #16
 800b854:	bd80      	pop	{r7, pc}
 800b856:	46c0      	nop			; (mov r8, r8)
 800b858:	08020aa8 	.word	0x08020aa8
 800b85c:	000003a7 	.word	0x000003a7
 800b860:	08020d00 	.word	0x08020d00
 800b864:	08020ae4 	.word	0x08020ae4
 800b868:	000003b7 	.word	0x000003b7
 800b86c:	08020d24 	.word	0x08020d24

0800b870 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
 800b870:	b580      	push	{r7, lr}
 800b872:	b084      	sub	sp, #16
 800b874:	af00      	add	r7, sp, #0
 800b876:	6078      	str	r0, [r7, #4]
 800b878:	000a      	movs	r2, r1
 800b87a:	1cbb      	adds	r3, r7, #2
 800b87c:	801a      	strh	r2, [r3, #0]
  u32_t wnd_inflation;
  tcpwnd_size_t rcv_wnd;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_recved: invalid pcb", pcb != NULL, return);
 800b87e:	687b      	ldr	r3, [r7, #4]
 800b880:	2b00      	cmp	r3, #0
 800b882:	d104      	bne.n	800b88e <tcp_recved+0x1e>
 800b884:	4b23      	ldr	r3, [pc, #140]	; (800b914 <tcp_recved+0xa4>)
 800b886:	0018      	movs	r0, r3
 800b888:	f7f6 fcac 	bl	80021e4 <app_debug_rtt_raw>
 800b88c:	e03e      	b.n	800b90c <tcp_recved+0x9c>

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
 800b88e:	687b      	ldr	r3, [r7, #4]
 800b890:	7e1b      	ldrb	r3, [r3, #24]
 800b892:	2b01      	cmp	r3, #1
 800b894:	d105      	bne.n	800b8a2 <tcp_recved+0x32>
 800b896:	4b20      	ldr	r3, [pc, #128]	; (800b918 <tcp_recved+0xa8>)
 800b898:	4a20      	ldr	r2, [pc, #128]	; (800b91c <tcp_recved+0xac>)
 800b89a:	4921      	ldr	r1, [pc, #132]	; (800b920 <tcp_recved+0xb0>)
 800b89c:	4821      	ldr	r0, [pc, #132]	; (800b924 <tcp_recved+0xb4>)
 800b89e:	f7f6 fca1 	bl	80021e4 <app_debug_rtt_raw>
              pcb->state != LISTEN);

  rcv_wnd = (tcpwnd_size_t)(pcb->rcv_wnd + len);
 800b8a2:	687b      	ldr	r3, [r7, #4]
 800b8a4:	8d99      	ldrh	r1, [r3, #44]	; 0x2c
 800b8a6:	200e      	movs	r0, #14
 800b8a8:	183b      	adds	r3, r7, r0
 800b8aa:	1cba      	adds	r2, r7, #2
 800b8ac:	8812      	ldrh	r2, [r2, #0]
 800b8ae:	188a      	adds	r2, r1, r2
 800b8b0:	801a      	strh	r2, [r3, #0]
  if ((rcv_wnd > TCP_WND_MAX(pcb)) || (rcv_wnd < pcb->rcv_wnd)) {
 800b8b2:	0001      	movs	r1, r0
 800b8b4:	187b      	adds	r3, r7, r1
 800b8b6:	881a      	ldrh	r2, [r3, #0]
 800b8b8:	2386      	movs	r3, #134	; 0x86
 800b8ba:	00db      	lsls	r3, r3, #3
 800b8bc:	429a      	cmp	r2, r3
 800b8be:	d805      	bhi.n	800b8cc <tcp_recved+0x5c>
 800b8c0:	687b      	ldr	r3, [r7, #4]
 800b8c2:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 800b8c4:	187a      	adds	r2, r7, r1
 800b8c6:	8812      	ldrh	r2, [r2, #0]
 800b8c8:	429a      	cmp	r2, r3
 800b8ca:	d204      	bcs.n	800b8d6 <tcp_recved+0x66>
    /* window got too big or tcpwnd_size_t overflow */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: window got too big or tcpwnd_size_t overflow\n"));
    pcb->rcv_wnd = TCP_WND_MAX(pcb);
 800b8cc:	687b      	ldr	r3, [r7, #4]
 800b8ce:	2286      	movs	r2, #134	; 0x86
 800b8d0:	00d2      	lsls	r2, r2, #3
 800b8d2:	859a      	strh	r2, [r3, #44]	; 0x2c
 800b8d4:	e004      	b.n	800b8e0 <tcp_recved+0x70>
  } else  {
    pcb->rcv_wnd = rcv_wnd;
 800b8d6:	687b      	ldr	r3, [r7, #4]
 800b8d8:	220e      	movs	r2, #14
 800b8da:	18ba      	adds	r2, r7, r2
 800b8dc:	8812      	ldrh	r2, [r2, #0]
 800b8de:	859a      	strh	r2, [r3, #44]	; 0x2c
  }

  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
 800b8e0:	687b      	ldr	r3, [r7, #4]
 800b8e2:	0018      	movs	r0, r3
 800b8e4:	f7ff ff64 	bl	800b7b0 <tcp_update_rcv_ann_wnd>
 800b8e8:	0003      	movs	r3, r0
 800b8ea:	60bb      	str	r3, [r7, #8]

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
 800b8ec:	68ba      	ldr	r2, [r7, #8]
 800b8ee:	2386      	movs	r3, #134	; 0x86
 800b8f0:	005b      	lsls	r3, r3, #1
 800b8f2:	429a      	cmp	r2, r3
 800b8f4:	d30a      	bcc.n	800b90c <tcp_recved+0x9c>
    tcp_ack_now(pcb);
 800b8f6:	687b      	ldr	r3, [r7, #4]
 800b8f8:	8bdb      	ldrh	r3, [r3, #30]
 800b8fa:	2202      	movs	r2, #2
 800b8fc:	4313      	orrs	r3, r2
 800b8fe:	b29a      	uxth	r2, r3
 800b900:	687b      	ldr	r3, [r7, #4]
 800b902:	83da      	strh	r2, [r3, #30]
    tcp_output(pcb);
 800b904:	687b      	ldr	r3, [r7, #4]
 800b906:	0018      	movs	r0, r3
 800b908:	f005 fd40 	bl	801138c <tcp_output>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: received %"U16_F" bytes, wnd %"TCPWNDSIZE_F" (%"TCPWNDSIZE_F").\n",
                          len, pcb->rcv_wnd, (u16_t)(TCP_WND_MAX(pcb) - pcb->rcv_wnd)));
}
 800b90c:	46bd      	mov	sp, r7
 800b90e:	b004      	add	sp, #16
 800b910:	bd80      	pop	{r7, pc}
 800b912:	46c0      	nop			; (mov r8, r8)
 800b914:	08020d40 	.word	0x08020d40
 800b918:	08020aa8 	.word	0x08020aa8
 800b91c:	000003d3 	.word	0x000003d3
 800b920:	08020d58 	.word	0x08020d58
 800b924:	08020ae4 	.word	0x08020ae4

0800b928 <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
 800b928:	b580      	push	{r7, lr}
 800b92a:	b082      	sub	sp, #8
 800b92c:	af00      	add	r7, sp, #0
  u8_t i;
  u16_t n = 0;
 800b92e:	1d3b      	adds	r3, r7, #4
 800b930:	2200      	movs	r2, #0
 800b932:	801a      	strh	r2, [r3, #0]
  struct tcp_pcb *pcb;

again:
  tcp_port++;
 800b934:	4b20      	ldr	r3, [pc, #128]	; (800b9b8 <tcp_new_port+0x90>)
 800b936:	881b      	ldrh	r3, [r3, #0]
 800b938:	3301      	adds	r3, #1
 800b93a:	b29a      	uxth	r2, r3
 800b93c:	4b1e      	ldr	r3, [pc, #120]	; (800b9b8 <tcp_new_port+0x90>)
 800b93e:	801a      	strh	r2, [r3, #0]
  if (tcp_port == TCP_LOCAL_PORT_RANGE_END) {
 800b940:	4b1d      	ldr	r3, [pc, #116]	; (800b9b8 <tcp_new_port+0x90>)
 800b942:	881b      	ldrh	r3, [r3, #0]
 800b944:	4a1d      	ldr	r2, [pc, #116]	; (800b9bc <tcp_new_port+0x94>)
 800b946:	4293      	cmp	r3, r2
 800b948:	d102      	bne.n	800b950 <tcp_new_port+0x28>
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
 800b94a:	4b1b      	ldr	r3, [pc, #108]	; (800b9b8 <tcp_new_port+0x90>)
 800b94c:	4a1c      	ldr	r2, [pc, #112]	; (800b9c0 <tcp_new_port+0x98>)
 800b94e:	801a      	strh	r2, [r3, #0]
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
 800b950:	1dfb      	adds	r3, r7, #7
 800b952:	2200      	movs	r2, #0
 800b954:	701a      	strb	r2, [r3, #0]
 800b956:	e025      	b.n	800b9a4 <tcp_new_port+0x7c>
    for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 800b958:	1dfb      	adds	r3, r7, #7
 800b95a:	781a      	ldrb	r2, [r3, #0]
 800b95c:	4b19      	ldr	r3, [pc, #100]	; (800b9c4 <tcp_new_port+0x9c>)
 800b95e:	0092      	lsls	r2, r2, #2
 800b960:	58d3      	ldr	r3, [r2, r3]
 800b962:	681b      	ldr	r3, [r3, #0]
 800b964:	603b      	str	r3, [r7, #0]
 800b966:	e015      	b.n	800b994 <tcp_new_port+0x6c>
      if (pcb->local_port == tcp_port) {
 800b968:	683b      	ldr	r3, [r7, #0]
 800b96a:	8b5a      	ldrh	r2, [r3, #26]
 800b96c:	4b12      	ldr	r3, [pc, #72]	; (800b9b8 <tcp_new_port+0x90>)
 800b96e:	881b      	ldrh	r3, [r3, #0]
 800b970:	429a      	cmp	r2, r3
 800b972:	d10c      	bne.n	800b98e <tcp_new_port+0x66>
        n++;
 800b974:	1d3b      	adds	r3, r7, #4
 800b976:	881a      	ldrh	r2, [r3, #0]
 800b978:	1d3b      	adds	r3, r7, #4
 800b97a:	3201      	adds	r2, #1
 800b97c:	801a      	strh	r2, [r3, #0]
        if (n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
 800b97e:	1d3b      	adds	r3, r7, #4
 800b980:	881a      	ldrh	r2, [r3, #0]
 800b982:	2380      	movs	r3, #128	; 0x80
 800b984:	01db      	lsls	r3, r3, #7
 800b986:	429a      	cmp	r2, r3
 800b988:	d3d4      	bcc.n	800b934 <tcp_new_port+0xc>
          return 0;
 800b98a:	2300      	movs	r3, #0
 800b98c:	e010      	b.n	800b9b0 <tcp_new_port+0x88>
    for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 800b98e:	683b      	ldr	r3, [r7, #0]
 800b990:	691b      	ldr	r3, [r3, #16]
 800b992:	603b      	str	r3, [r7, #0]
 800b994:	683b      	ldr	r3, [r7, #0]
 800b996:	2b00      	cmp	r3, #0
 800b998:	d1e6      	bne.n	800b968 <tcp_new_port+0x40>
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
 800b99a:	1dfb      	adds	r3, r7, #7
 800b99c:	781a      	ldrb	r2, [r3, #0]
 800b99e:	1dfb      	adds	r3, r7, #7
 800b9a0:	3201      	adds	r2, #1
 800b9a2:	701a      	strb	r2, [r3, #0]
 800b9a4:	1dfb      	adds	r3, r7, #7
 800b9a6:	781b      	ldrb	r3, [r3, #0]
 800b9a8:	2b03      	cmp	r3, #3
 800b9aa:	d9d5      	bls.n	800b958 <tcp_new_port+0x30>
        }
        goto again;
      }
    }
  }
  return tcp_port;
 800b9ac:	4b02      	ldr	r3, [pc, #8]	; (800b9b8 <tcp_new_port+0x90>)
 800b9ae:	881b      	ldrh	r3, [r3, #0]
}
 800b9b0:	0018      	movs	r0, r3
 800b9b2:	46bd      	mov	sp, r7
 800b9b4:	b002      	add	sp, #8
 800b9b6:	bd80      	pop	{r7, pc}
 800b9b8:	20000022 	.word	0x20000022
 800b9bc:	0000ffff 	.word	0x0000ffff
 800b9c0:	ffffc000 	.word	0xffffc000
 800b9c4:	08023a44 	.word	0x08023a44

0800b9c8 <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port,
            tcp_connected_fn connected)
{
 800b9c8:	b5b0      	push	{r4, r5, r7, lr}
 800b9ca:	b08c      	sub	sp, #48	; 0x30
 800b9cc:	af00      	add	r7, sp, #0
 800b9ce:	60f8      	str	r0, [r7, #12]
 800b9d0:	60b9      	str	r1, [r7, #8]
 800b9d2:	603b      	str	r3, [r7, #0]
 800b9d4:	1dbb      	adds	r3, r7, #6
 800b9d6:	801a      	strh	r2, [r3, #0]
  struct netif *netif = NULL;
 800b9d8:	2300      	movs	r3, #0
 800b9da:	62fb      	str	r3, [r7, #44]	; 0x2c
  u32_t iss;
  u16_t old_local_port;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_connect: invalid pcb", pcb != NULL, return ERR_ARG);
 800b9dc:	68fb      	ldr	r3, [r7, #12]
 800b9de:	2b00      	cmp	r3, #0
 800b9e0:	d106      	bne.n	800b9f0 <tcp_connect+0x28>
 800b9e2:	4b9c      	ldr	r3, [pc, #624]	; (800bc54 <tcp_connect+0x28c>)
 800b9e4:	0018      	movs	r0, r3
 800b9e6:	f7f6 fbfd 	bl	80021e4 <app_debug_rtt_raw>
 800b9ea:	2310      	movs	r3, #16
 800b9ec:	425b      	negs	r3, r3
 800b9ee:	e12d      	b.n	800bc4c <tcp_connect+0x284>
  LWIP_ERROR("tcp_connect: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
 800b9f0:	68bb      	ldr	r3, [r7, #8]
 800b9f2:	2b00      	cmp	r3, #0
 800b9f4:	d106      	bne.n	800ba04 <tcp_connect+0x3c>
 800b9f6:	4b98      	ldr	r3, [pc, #608]	; (800bc58 <tcp_connect+0x290>)
 800b9f8:	0018      	movs	r0, r3
 800b9fa:	f7f6 fbf3 	bl	80021e4 <app_debug_rtt_raw>
 800b9fe:	2310      	movs	r3, #16
 800ba00:	425b      	negs	r3, r3
 800ba02:	e123      	b.n	800bc4c <tcp_connect+0x284>

  LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
 800ba04:	68fb      	ldr	r3, [r7, #12]
 800ba06:	7e1b      	ldrb	r3, [r3, #24]
 800ba08:	2b00      	cmp	r3, #0
 800ba0a:	d006      	beq.n	800ba1a <tcp_connect+0x52>
 800ba0c:	4b93      	ldr	r3, [pc, #588]	; (800bc5c <tcp_connect+0x294>)
 800ba0e:	0018      	movs	r0, r3
 800ba10:	f7f6 fbe8 	bl	80021e4 <app_debug_rtt_raw>
 800ba14:	230a      	movs	r3, #10
 800ba16:	425b      	negs	r3, r3
 800ba18:	e118      	b.n	800bc4c <tcp_connect+0x284>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  ip_addr_set(&pcb->remote_ip, ipaddr);
 800ba1a:	68bb      	ldr	r3, [r7, #8]
 800ba1c:	2b00      	cmp	r3, #0
 800ba1e:	d002      	beq.n	800ba26 <tcp_connect+0x5e>
 800ba20:	68bb      	ldr	r3, [r7, #8]
 800ba22:	681a      	ldr	r2, [r3, #0]
 800ba24:	e000      	b.n	800ba28 <tcp_connect+0x60>
 800ba26:	2200      	movs	r2, #0
 800ba28:	68fb      	ldr	r3, [r7, #12]
 800ba2a:	605a      	str	r2, [r3, #4]
  pcb->remote_port = port;
 800ba2c:	68fb      	ldr	r3, [r7, #12]
 800ba2e:	1dba      	adds	r2, r7, #6
 800ba30:	8812      	ldrh	r2, [r2, #0]
 800ba32:	839a      	strh	r2, [r3, #28]

  if (pcb->netif_idx != NETIF_NO_INDEX) {
 800ba34:	68fb      	ldr	r3, [r7, #12]
 800ba36:	7a1b      	ldrb	r3, [r3, #8]
 800ba38:	2b00      	cmp	r3, #0
 800ba3a:	d007      	beq.n	800ba4c <tcp_connect+0x84>
    netif = netif_get_by_index(pcb->netif_idx);
 800ba3c:	68fb      	ldr	r3, [r7, #12]
 800ba3e:	7a1b      	ldrb	r3, [r3, #8]
 800ba40:	0018      	movs	r0, r3
 800ba42:	f7fe f997 	bl	8009d74 <netif_get_by_index>
 800ba46:	0003      	movs	r3, r0
 800ba48:	62fb      	str	r3, [r7, #44]	; 0x2c
 800ba4a:	e006      	b.n	800ba5a <tcp_connect+0x92>
  } else {
    /* check if we have a route to the remote host */
    netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
 800ba4c:	68fb      	ldr	r3, [r7, #12]
 800ba4e:	3304      	adds	r3, #4
 800ba50:	0018      	movs	r0, r3
 800ba52:	f008 f931 	bl	8013cb8 <ip4_route>
 800ba56:	0003      	movs	r3, r0
 800ba58:	62fb      	str	r3, [r7, #44]	; 0x2c
  }
  if (netif == NULL) {
 800ba5a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ba5c:	2b00      	cmp	r3, #0
 800ba5e:	d102      	bne.n	800ba66 <tcp_connect+0x9e>
    /* Don't even try to send a SYN packet if we have no route since that will fail. */
    return ERR_RTE;
 800ba60:	2304      	movs	r3, #4
 800ba62:	425b      	negs	r3, r3
 800ba64:	e0f2      	b.n	800bc4c <tcp_connect+0x284>
  }

  /* check if local IP has been assigned to pcb, if not, get one */
  if (ip_addr_isany(&pcb->local_ip)) {
 800ba66:	68fb      	ldr	r3, [r7, #12]
 800ba68:	2b00      	cmp	r3, #0
 800ba6a:	d003      	beq.n	800ba74 <tcp_connect+0xac>
 800ba6c:	68fb      	ldr	r3, [r7, #12]
 800ba6e:	681b      	ldr	r3, [r3, #0]
 800ba70:	2b00      	cmp	r3, #0
 800ba72:	d111      	bne.n	800ba98 <tcp_connect+0xd0>
    const ip_addr_t *local_ip = ip_netif_get_local_ip(netif, ipaddr);
 800ba74:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ba76:	2b00      	cmp	r3, #0
 800ba78:	d002      	beq.n	800ba80 <tcp_connect+0xb8>
 800ba7a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ba7c:	3304      	adds	r3, #4
 800ba7e:	e000      	b.n	800ba82 <tcp_connect+0xba>
 800ba80:	2300      	movs	r3, #0
 800ba82:	61fb      	str	r3, [r7, #28]
    if (local_ip == NULL) {
 800ba84:	69fb      	ldr	r3, [r7, #28]
 800ba86:	2b00      	cmp	r3, #0
 800ba88:	d102      	bne.n	800ba90 <tcp_connect+0xc8>
      return ERR_RTE;
 800ba8a:	2304      	movs	r3, #4
 800ba8c:	425b      	negs	r3, r3
 800ba8e:	e0dd      	b.n	800bc4c <tcp_connect+0x284>
    }
    ip_addr_copy(pcb->local_ip, *local_ip);
 800ba90:	69fb      	ldr	r3, [r7, #28]
 800ba92:	681a      	ldr	r2, [r3, #0]
 800ba94:	68fb      	ldr	r3, [r7, #12]
 800ba96:	601a      	str	r2, [r3, #0]
      ip6_addr_lacks_zone(ip_2_ip6(&pcb->remote_ip), IP6_UNICAST)) {
    ip6_addr_assign_zone(ip_2_ip6(&pcb->remote_ip), IP6_UNICAST, netif);
  }
#endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */

  old_local_port = pcb->local_port;
 800ba98:	231a      	movs	r3, #26
 800ba9a:	18fb      	adds	r3, r7, r3
 800ba9c:	68fa      	ldr	r2, [r7, #12]
 800ba9e:	8b52      	ldrh	r2, [r2, #26]
 800baa0:	801a      	strh	r2, [r3, #0]
  if (pcb->local_port == 0) {
 800baa2:	68fb      	ldr	r3, [r7, #12]
 800baa4:	8b5b      	ldrh	r3, [r3, #26]
 800baa6:	2b00      	cmp	r3, #0
 800baa8:	d10c      	bne.n	800bac4 <tcp_connect+0xfc>
    pcb->local_port = tcp_new_port();
 800baaa:	f7ff ff3d 	bl	800b928 <tcp_new_port>
 800baae:	0003      	movs	r3, r0
 800bab0:	001a      	movs	r2, r3
 800bab2:	68fb      	ldr	r3, [r7, #12]
 800bab4:	835a      	strh	r2, [r3, #26]
    if (pcb->local_port == 0) {
 800bab6:	68fb      	ldr	r3, [r7, #12]
 800bab8:	8b5b      	ldrh	r3, [r3, #26]
 800baba:	2b00      	cmp	r3, #0
 800babc:	d139      	bne.n	800bb32 <tcp_connect+0x16a>
      return ERR_BUF;
 800babe:	2302      	movs	r3, #2
 800bac0:	425b      	negs	r3, r3
 800bac2:	e0c3      	b.n	800bc4c <tcp_connect+0x284>
    }
  } else {
#if SO_REUSE
    if (ip_get_option(pcb, SOF_REUSEADDR)) {
 800bac4:	68fb      	ldr	r3, [r7, #12]
 800bac6:	7a5b      	ldrb	r3, [r3, #9]
 800bac8:	001a      	movs	r2, r3
 800baca:	2304      	movs	r3, #4
 800bacc:	4013      	ands	r3, r2
 800bace:	d030      	beq.n	800bb32 <tcp_connect+0x16a>
      /* Since SOF_REUSEADDR allows reusing a local address, we have to make sure
         now that the 5-tuple is unique. */
      struct tcp_pcb *cpcb;
      int i;
      /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
      for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
 800bad0:	2302      	movs	r3, #2
 800bad2:	627b      	str	r3, [r7, #36]	; 0x24
 800bad4:	e02a      	b.n	800bb2c <tcp_connect+0x164>
        for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 800bad6:	4b62      	ldr	r3, [pc, #392]	; (800bc60 <tcp_connect+0x298>)
 800bad8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800bada:	0092      	lsls	r2, r2, #2
 800badc:	58d3      	ldr	r3, [r2, r3]
 800bade:	681b      	ldr	r3, [r3, #0]
 800bae0:	62bb      	str	r3, [r7, #40]	; 0x28
 800bae2:	e01d      	b.n	800bb20 <tcp_connect+0x158>
          if ((cpcb->local_port == pcb->local_port) &&
 800bae4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bae6:	8b5a      	ldrh	r2, [r3, #26]
 800bae8:	68fb      	ldr	r3, [r7, #12]
 800baea:	8b5b      	ldrh	r3, [r3, #26]
 800baec:	429a      	cmp	r2, r3
 800baee:	d114      	bne.n	800bb1a <tcp_connect+0x152>
              (cpcb->remote_port == port) &&
 800baf0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800baf2:	8b9b      	ldrh	r3, [r3, #28]
          if ((cpcb->local_port == pcb->local_port) &&
 800baf4:	1dba      	adds	r2, r7, #6
 800baf6:	8812      	ldrh	r2, [r2, #0]
 800baf8:	429a      	cmp	r2, r3
 800bafa:	d10e      	bne.n	800bb1a <tcp_connect+0x152>
              ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
 800bafc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bafe:	681a      	ldr	r2, [r3, #0]
 800bb00:	68fb      	ldr	r3, [r7, #12]
 800bb02:	681b      	ldr	r3, [r3, #0]
              (cpcb->remote_port == port) &&
 800bb04:	429a      	cmp	r2, r3
 800bb06:	d108      	bne.n	800bb1a <tcp_connect+0x152>
              ip_addr_cmp(&cpcb->remote_ip, ipaddr)) {
 800bb08:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bb0a:	685a      	ldr	r2, [r3, #4]
 800bb0c:	68bb      	ldr	r3, [r7, #8]
 800bb0e:	681b      	ldr	r3, [r3, #0]
              ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
 800bb10:	429a      	cmp	r2, r3
 800bb12:	d102      	bne.n	800bb1a <tcp_connect+0x152>
            /* linux returns EISCONN here, but ERR_USE should be OK for us */
            return ERR_USE;
 800bb14:	2308      	movs	r3, #8
 800bb16:	425b      	negs	r3, r3
 800bb18:	e098      	b.n	800bc4c <tcp_connect+0x284>
        for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 800bb1a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bb1c:	691b      	ldr	r3, [r3, #16]
 800bb1e:	62bb      	str	r3, [r7, #40]	; 0x28
 800bb20:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bb22:	2b00      	cmp	r3, #0
 800bb24:	d1de      	bne.n	800bae4 <tcp_connect+0x11c>
      for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
 800bb26:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bb28:	3301      	adds	r3, #1
 800bb2a:	627b      	str	r3, [r7, #36]	; 0x24
 800bb2c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bb2e:	2b03      	cmp	r3, #3
 800bb30:	ddd1      	ble.n	800bad6 <tcp_connect+0x10e>
      }
    }
#endif /* SO_REUSE */
  }

  iss = tcp_next_iss(pcb);
 800bb32:	68fb      	ldr	r3, [r7, #12]
 800bb34:	0018      	movs	r0, r3
 800bb36:	f001 f8e1 	bl	800ccfc <tcp_next_iss>
 800bb3a:	0003      	movs	r3, r0
 800bb3c:	617b      	str	r3, [r7, #20]
  pcb->rcv_nxt = 0;
 800bb3e:	68fb      	ldr	r3, [r7, #12]
 800bb40:	2200      	movs	r2, #0
 800bb42:	629a      	str	r2, [r3, #40]	; 0x28
  pcb->snd_nxt = iss;
 800bb44:	68fb      	ldr	r3, [r7, #12]
 800bb46:	697a      	ldr	r2, [r7, #20]
 800bb48:	655a      	str	r2, [r3, #84]	; 0x54
  pcb->lastack = iss - 1;
 800bb4a:	697b      	ldr	r3, [r7, #20]
 800bb4c:	1e5a      	subs	r2, r3, #1
 800bb4e:	68fb      	ldr	r3, [r7, #12]
 800bb50:	649a      	str	r2, [r3, #72]	; 0x48
  pcb->snd_wl2 = iss - 1;
 800bb52:	697b      	ldr	r3, [r7, #20]
 800bb54:	1e5a      	subs	r2, r3, #1
 800bb56:	68fb      	ldr	r3, [r7, #12]
 800bb58:	65da      	str	r2, [r3, #92]	; 0x5c
  pcb->snd_lbb = iss - 1;
 800bb5a:	697b      	ldr	r3, [r7, #20]
 800bb5c:	1e5a      	subs	r2, r3, #1
 800bb5e:	68fb      	ldr	r3, [r7, #12]
 800bb60:	661a      	str	r2, [r3, #96]	; 0x60
  /* Start with a window that does not need scaling. When window scaling is
     enabled and used, the window is enlarged when both sides agree on scaling. */
  pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
 800bb62:	68fb      	ldr	r3, [r7, #12]
 800bb64:	2286      	movs	r2, #134	; 0x86
 800bb66:	00d2      	lsls	r2, r2, #3
 800bb68:	85da      	strh	r2, [r3, #46]	; 0x2e
 800bb6a:	68fb      	ldr	r3, [r7, #12]
 800bb6c:	8dda      	ldrh	r2, [r3, #46]	; 0x2e
 800bb6e:	68fb      	ldr	r3, [r7, #12]
 800bb70:	859a      	strh	r2, [r3, #44]	; 0x2c
  pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 800bb72:	68fb      	ldr	r3, [r7, #12]
 800bb74:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800bb76:	68fb      	ldr	r3, [r7, #12]
 800bb78:	631a      	str	r2, [r3, #48]	; 0x30
  pcb->snd_wnd = TCP_WND;
 800bb7a:	68fb      	ldr	r3, [r7, #12]
 800bb7c:	2264      	movs	r2, #100	; 0x64
 800bb7e:	2186      	movs	r1, #134	; 0x86
 800bb80:	00c9      	lsls	r1, r1, #3
 800bb82:	5299      	strh	r1, [r3, r2]
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = INITIAL_MSS;
 800bb84:	68fb      	ldr	r3, [r7, #12]
 800bb86:	2286      	movs	r2, #134	; 0x86
 800bb88:	0092      	lsls	r2, r2, #2
 800bb8a:	86da      	strh	r2, [r3, #54]	; 0x36
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss_netif(pcb->mss, netif, &pcb->remote_ip);
 800bb8c:	68fb      	ldr	r3, [r7, #12]
 800bb8e:	8ed8      	ldrh	r0, [r3, #54]	; 0x36
 800bb90:	68fb      	ldr	r3, [r7, #12]
 800bb92:	1d1a      	adds	r2, r3, #4
 800bb94:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bb96:	0019      	movs	r1, r3
 800bb98:	f001 f8d6 	bl	800cd48 <tcp_eff_send_mss_netif>
 800bb9c:	0003      	movs	r3, r0
 800bb9e:	001a      	movs	r2, r3
 800bba0:	68fb      	ldr	r3, [r7, #12]
 800bba2:	86da      	strh	r2, [r3, #54]	; 0x36
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
 800bba4:	68fb      	ldr	r3, [r7, #12]
 800bba6:	224c      	movs	r2, #76	; 0x4c
 800bba8:	2101      	movs	r1, #1
 800bbaa:	5299      	strh	r1, [r3, r2]
#if LWIP_CALLBACK_API
  pcb->connected = connected;
 800bbac:	68fb      	ldr	r3, [r7, #12]
 800bbae:	218c      	movs	r1, #140	; 0x8c
 800bbb0:	683a      	ldr	r2, [r7, #0]
 800bbb2:	505a      	str	r2, [r3, r1]
#else /* LWIP_CALLBACK_API */
  LWIP_UNUSED_ARG(connected);
#endif /* LWIP_CALLBACK_API */

  /* Send a SYN together with the MSS option. */
  ret = tcp_enqueue_flags(pcb, TCP_SYN);
 800bbb4:	2513      	movs	r5, #19
 800bbb6:	197c      	adds	r4, r7, r5
 800bbb8:	68fb      	ldr	r3, [r7, #12]
 800bbba:	2102      	movs	r1, #2
 800bbbc:	0018      	movs	r0, r3
 800bbbe:	f005 fadf 	bl	8011180 <tcp_enqueue_flags>
 800bbc2:	0003      	movs	r3, r0
 800bbc4:	7023      	strb	r3, [r4, #0]
  if (ret == ERR_OK) {
 800bbc6:	197b      	adds	r3, r7, r5
 800bbc8:	781b      	ldrb	r3, [r3, #0]
 800bbca:	b25b      	sxtb	r3, r3
 800bbcc:	2b00      	cmp	r3, #0
 800bbce:	d139      	bne.n	800bc44 <tcp_connect+0x27c>
    /* SYN segment was enqueued, changed the pcbs state now */
    pcb->state = SYN_SENT;
 800bbd0:	68fb      	ldr	r3, [r7, #12]
 800bbd2:	2202      	movs	r2, #2
 800bbd4:	761a      	strb	r2, [r3, #24]
    if (old_local_port != 0) {
 800bbd6:	231a      	movs	r3, #26
 800bbd8:	18fb      	adds	r3, r7, r3
 800bbda:	881b      	ldrh	r3, [r3, #0]
 800bbdc:	2b00      	cmp	r3, #0
 800bbde:	d021      	beq.n	800bc24 <tcp_connect+0x25c>
      TCP_RMV(&tcp_bound_pcbs, pcb);
 800bbe0:	4b20      	ldr	r3, [pc, #128]	; (800bc64 <tcp_connect+0x29c>)
 800bbe2:	681b      	ldr	r3, [r3, #0]
 800bbe4:	68fa      	ldr	r2, [r7, #12]
 800bbe6:	429a      	cmp	r2, r3
 800bbe8:	d105      	bne.n	800bbf6 <tcp_connect+0x22e>
 800bbea:	4b1e      	ldr	r3, [pc, #120]	; (800bc64 <tcp_connect+0x29c>)
 800bbec:	681b      	ldr	r3, [r3, #0]
 800bbee:	691a      	ldr	r2, [r3, #16]
 800bbf0:	4b1c      	ldr	r3, [pc, #112]	; (800bc64 <tcp_connect+0x29c>)
 800bbf2:	601a      	str	r2, [r3, #0]
 800bbf4:	e013      	b.n	800bc1e <tcp_connect+0x256>
 800bbf6:	4b1b      	ldr	r3, [pc, #108]	; (800bc64 <tcp_connect+0x29c>)
 800bbf8:	681b      	ldr	r3, [r3, #0]
 800bbfa:	623b      	str	r3, [r7, #32]
 800bbfc:	e00c      	b.n	800bc18 <tcp_connect+0x250>
 800bbfe:	6a3b      	ldr	r3, [r7, #32]
 800bc00:	691b      	ldr	r3, [r3, #16]
 800bc02:	68fa      	ldr	r2, [r7, #12]
 800bc04:	429a      	cmp	r2, r3
 800bc06:	d104      	bne.n	800bc12 <tcp_connect+0x24a>
 800bc08:	68fb      	ldr	r3, [r7, #12]
 800bc0a:	691a      	ldr	r2, [r3, #16]
 800bc0c:	6a3b      	ldr	r3, [r7, #32]
 800bc0e:	611a      	str	r2, [r3, #16]
 800bc10:	e005      	b.n	800bc1e <tcp_connect+0x256>
 800bc12:	6a3b      	ldr	r3, [r7, #32]
 800bc14:	691b      	ldr	r3, [r3, #16]
 800bc16:	623b      	str	r3, [r7, #32]
 800bc18:	6a3b      	ldr	r3, [r7, #32]
 800bc1a:	2b00      	cmp	r3, #0
 800bc1c:	d1ef      	bne.n	800bbfe <tcp_connect+0x236>
 800bc1e:	68fb      	ldr	r3, [r7, #12]
 800bc20:	2200      	movs	r2, #0
 800bc22:	611a      	str	r2, [r3, #16]
    }
    TCP_REG_ACTIVE(pcb);
 800bc24:	4b10      	ldr	r3, [pc, #64]	; (800bc68 <tcp_connect+0x2a0>)
 800bc26:	681a      	ldr	r2, [r3, #0]
 800bc28:	68fb      	ldr	r3, [r7, #12]
 800bc2a:	611a      	str	r2, [r3, #16]
 800bc2c:	4b0e      	ldr	r3, [pc, #56]	; (800bc68 <tcp_connect+0x2a0>)
 800bc2e:	68fa      	ldr	r2, [r7, #12]
 800bc30:	601a      	str	r2, [r3, #0]
 800bc32:	f006 fe29 	bl	8012888 <tcp_timer_needed>
 800bc36:	4b0d      	ldr	r3, [pc, #52]	; (800bc6c <tcp_connect+0x2a4>)
 800bc38:	2201      	movs	r2, #1
 800bc3a:	701a      	strb	r2, [r3, #0]
    MIB2_STATS_INC(mib2.tcpactiveopens);

    tcp_output(pcb);
 800bc3c:	68fb      	ldr	r3, [r7, #12]
 800bc3e:	0018      	movs	r0, r3
 800bc40:	f005 fba4 	bl	801138c <tcp_output>
  }
  return ret;
 800bc44:	2313      	movs	r3, #19
 800bc46:	18fb      	adds	r3, r7, r3
 800bc48:	781b      	ldrb	r3, [r3, #0]
 800bc4a:	b25b      	sxtb	r3, r3
}
 800bc4c:	0018      	movs	r0, r3
 800bc4e:	46bd      	mov	sp, r7
 800bc50:	b00c      	add	sp, #48	; 0x30
 800bc52:	bdb0      	pop	{r4, r5, r7, pc}
 800bc54:	08020d80 	.word	0x08020d80
 800bc58:	08020d9c 	.word	0x08020d9c
 800bc5c:	08020db8 	.word	0x08020db8
 800bc60:	08023a44 	.word	0x08023a44
 800bc64:	20002798 	.word	0x20002798
 800bc68:	2000278c 	.word	0x2000278c
 800bc6c:	20002788 	.word	0x20002788

0800bc70 <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
 800bc70:	b5f0      	push	{r4, r5, r6, r7, lr}
 800bc72:	b091      	sub	sp, #68	; 0x44
 800bc74:	af04      	add	r7, sp, #16
  tcpwnd_size_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;
 800bc76:	2325      	movs	r3, #37	; 0x25
 800bc78:	18fb      	adds	r3, r7, r3
 800bc7a:	2200      	movs	r2, #0
 800bc7c:	701a      	strb	r2, [r3, #0]

  ++tcp_ticks;
 800bc7e:	4b9c      	ldr	r3, [pc, #624]	; (800bef0 <tcp_slowtmr+0x280>)
 800bc80:	681b      	ldr	r3, [r3, #0]
 800bc82:	1c5a      	adds	r2, r3, #1
 800bc84:	4b9a      	ldr	r3, [pc, #616]	; (800bef0 <tcp_slowtmr+0x280>)
 800bc86:	601a      	str	r2, [r3, #0]
  ++tcp_timer_ctr;
 800bc88:	4b9a      	ldr	r3, [pc, #616]	; (800bef4 <tcp_slowtmr+0x284>)
 800bc8a:	781b      	ldrb	r3, [r3, #0]
 800bc8c:	3301      	adds	r3, #1
 800bc8e:	b2da      	uxtb	r2, r3
 800bc90:	4b98      	ldr	r3, [pc, #608]	; (800bef4 <tcp_slowtmr+0x284>)
 800bc92:	701a      	strb	r2, [r3, #0]

tcp_slowtmr_start:
  /* Steps through all of the active PCBs. */
  prev = NULL;
 800bc94:	2300      	movs	r3, #0
 800bc96:	62bb      	str	r3, [r7, #40]	; 0x28
  pcb = tcp_active_pcbs;
 800bc98:	4b97      	ldr	r3, [pc, #604]	; (800bef8 <tcp_slowtmr+0x288>)
 800bc9a:	681b      	ldr	r3, [r3, #0]
 800bc9c:	62fb      	str	r3, [r7, #44]	; 0x2c
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
 800bc9e:	e2e2      	b.n	800c266 <tcp_slowtmr+0x5f6>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
 800bca0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bca2:	7e1b      	ldrb	r3, [r3, #24]
 800bca4:	2b00      	cmp	r3, #0
 800bca6:	d105      	bne.n	800bcb4 <tcp_slowtmr+0x44>
 800bca8:	4b94      	ldr	r3, [pc, #592]	; (800befc <tcp_slowtmr+0x28c>)
 800bcaa:	4a95      	ldr	r2, [pc, #596]	; (800bf00 <tcp_slowtmr+0x290>)
 800bcac:	4995      	ldr	r1, [pc, #596]	; (800bf04 <tcp_slowtmr+0x294>)
 800bcae:	4896      	ldr	r0, [pc, #600]	; (800bf08 <tcp_slowtmr+0x298>)
 800bcb0:	f7f6 fa98 	bl	80021e4 <app_debug_rtt_raw>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
 800bcb4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bcb6:	7e1b      	ldrb	r3, [r3, #24]
 800bcb8:	2b01      	cmp	r3, #1
 800bcba:	d106      	bne.n	800bcca <tcp_slowtmr+0x5a>
 800bcbc:	4b8f      	ldr	r3, [pc, #572]	; (800befc <tcp_slowtmr+0x28c>)
 800bcbe:	2298      	movs	r2, #152	; 0x98
 800bcc0:	00d2      	lsls	r2, r2, #3
 800bcc2:	4992      	ldr	r1, [pc, #584]	; (800bf0c <tcp_slowtmr+0x29c>)
 800bcc4:	4890      	ldr	r0, [pc, #576]	; (800bf08 <tcp_slowtmr+0x298>)
 800bcc6:	f7f6 fa8d 	bl	80021e4 <app_debug_rtt_raw>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
 800bcca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bccc:	7e1b      	ldrb	r3, [r3, #24]
 800bcce:	2b0a      	cmp	r3, #10
 800bcd0:	d105      	bne.n	800bcde <tcp_slowtmr+0x6e>
 800bcd2:	4b8a      	ldr	r3, [pc, #552]	; (800befc <tcp_slowtmr+0x28c>)
 800bcd4:	4a8e      	ldr	r2, [pc, #568]	; (800bf10 <tcp_slowtmr+0x2a0>)
 800bcd6:	498f      	ldr	r1, [pc, #572]	; (800bf14 <tcp_slowtmr+0x2a4>)
 800bcd8:	488b      	ldr	r0, [pc, #556]	; (800bf08 <tcp_slowtmr+0x298>)
 800bcda:	f7f6 fa83 	bl	80021e4 <app_debug_rtt_raw>
    if (pcb->last_timer == tcp_timer_ctr) {
 800bcde:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bce0:	2222      	movs	r2, #34	; 0x22
 800bce2:	5c9a      	ldrb	r2, [r3, r2]
 800bce4:	4b83      	ldr	r3, [pc, #524]	; (800bef4 <tcp_slowtmr+0x284>)
 800bce6:	781b      	ldrb	r3, [r3, #0]
 800bce8:	429a      	cmp	r2, r3
 800bcea:	d105      	bne.n	800bcf8 <tcp_slowtmr+0x88>
      /* skip this pcb, we have already processed it */
      prev = pcb;
 800bcec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bcee:	62bb      	str	r3, [r7, #40]	; 0x28
      pcb = pcb->next;
 800bcf0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bcf2:	691b      	ldr	r3, [r3, #16]
 800bcf4:	62fb      	str	r3, [r7, #44]	; 0x2c
      continue;
 800bcf6:	e2b6      	b.n	800c266 <tcp_slowtmr+0x5f6>
    }
    pcb->last_timer = tcp_timer_ctr;
 800bcf8:	4b7e      	ldr	r3, [pc, #504]	; (800bef4 <tcp_slowtmr+0x284>)
 800bcfa:	7819      	ldrb	r1, [r3, #0]
 800bcfc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bcfe:	2222      	movs	r2, #34	; 0x22
 800bd00:	5499      	strb	r1, [r3, r2]

    pcb_remove = 0;
 800bd02:	2127      	movs	r1, #39	; 0x27
 800bd04:	187b      	adds	r3, r7, r1
 800bd06:	2200      	movs	r2, #0
 800bd08:	701a      	strb	r2, [r3, #0]
    pcb_reset = 0;
 800bd0a:	2326      	movs	r3, #38	; 0x26
 800bd0c:	18fb      	adds	r3, r7, r3
 800bd0e:	2200      	movs	r2, #0
 800bd10:	701a      	strb	r2, [r3, #0]

    if (pcb->state == SYN_SENT && pcb->nrtx >= TCP_SYNMAXRTX) {
 800bd12:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bd14:	7e1b      	ldrb	r3, [r3, #24]
 800bd16:	2b02      	cmp	r3, #2
 800bd18:	d10a      	bne.n	800bd30 <tcp_slowtmr+0xc0>
 800bd1a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bd1c:	2246      	movs	r2, #70	; 0x46
 800bd1e:	5c9b      	ldrb	r3, [r3, r2]
 800bd20:	2b05      	cmp	r3, #5
 800bd22:	d905      	bls.n	800bd30 <tcp_slowtmr+0xc0>
      ++pcb_remove;
 800bd24:	187b      	adds	r3, r7, r1
 800bd26:	187a      	adds	r2, r7, r1
 800bd28:	7812      	ldrb	r2, [r2, #0]
 800bd2a:	3201      	adds	r2, #1
 800bd2c:	701a      	strb	r2, [r3, #0]
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
 800bd2e:	e13f      	b.n	800bfb0 <tcp_slowtmr+0x340>
    } else if (pcb->nrtx >= TCP_MAXRTX) {
 800bd30:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bd32:	2246      	movs	r2, #70	; 0x46
 800bd34:	5c9b      	ldrb	r3, [r3, r2]
 800bd36:	2b0b      	cmp	r3, #11
 800bd38:	d906      	bls.n	800bd48 <tcp_slowtmr+0xd8>
      ++pcb_remove;
 800bd3a:	2227      	movs	r2, #39	; 0x27
 800bd3c:	18bb      	adds	r3, r7, r2
 800bd3e:	18ba      	adds	r2, r7, r2
 800bd40:	7812      	ldrb	r2, [r2, #0]
 800bd42:	3201      	adds	r2, #1
 800bd44:	701a      	strb	r2, [r3, #0]
 800bd46:	e133      	b.n	800bfb0 <tcp_slowtmr+0x340>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
 800bd48:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bd4a:	22a5      	movs	r2, #165	; 0xa5
 800bd4c:	5c9b      	ldrb	r3, [r3, r2]
 800bd4e:	2b00      	cmp	r3, #0
 800bd50:	d100      	bne.n	800bd54 <tcp_slowtmr+0xe4>
 800bd52:	e079      	b.n	800be48 <tcp_slowtmr+0x1d8>
        LWIP_ASSERT("tcp_slowtimr: persist ticking with in-flight data", pcb->unacked == NULL);
 800bd54:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bd56:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800bd58:	2b00      	cmp	r3, #0
 800bd5a:	d005      	beq.n	800bd68 <tcp_slowtmr+0xf8>
 800bd5c:	4b67      	ldr	r3, [pc, #412]	; (800befc <tcp_slowtmr+0x28c>)
 800bd5e:	4a6e      	ldr	r2, [pc, #440]	; (800bf18 <tcp_slowtmr+0x2a8>)
 800bd60:	496e      	ldr	r1, [pc, #440]	; (800bf1c <tcp_slowtmr+0x2ac>)
 800bd62:	4869      	ldr	r0, [pc, #420]	; (800bf08 <tcp_slowtmr+0x298>)
 800bd64:	f7f6 fa3e 	bl	80021e4 <app_debug_rtt_raw>
        LWIP_ASSERT("tcp_slowtimr: persist ticking with empty send buffer", pcb->unsent != NULL);
 800bd68:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bd6a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800bd6c:	2b00      	cmp	r3, #0
 800bd6e:	d105      	bne.n	800bd7c <tcp_slowtmr+0x10c>
 800bd70:	4b62      	ldr	r3, [pc, #392]	; (800befc <tcp_slowtmr+0x28c>)
 800bd72:	4a6b      	ldr	r2, [pc, #428]	; (800bf20 <tcp_slowtmr+0x2b0>)
 800bd74:	496b      	ldr	r1, [pc, #428]	; (800bf24 <tcp_slowtmr+0x2b4>)
 800bd76:	4864      	ldr	r0, [pc, #400]	; (800bf08 <tcp_slowtmr+0x298>)
 800bd78:	f7f6 fa34 	bl	80021e4 <app_debug_rtt_raw>
        if (pcb->persist_probe >= TCP_MAXRTX) {
 800bd7c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bd7e:	22a6      	movs	r2, #166	; 0xa6
 800bd80:	5c9b      	ldrb	r3, [r3, r2]
 800bd82:	2b0b      	cmp	r3, #11
 800bd84:	d906      	bls.n	800bd94 <tcp_slowtmr+0x124>
          ++pcb_remove; /* max probes reached */
 800bd86:	2227      	movs	r2, #39	; 0x27
 800bd88:	18bb      	adds	r3, r7, r2
 800bd8a:	18ba      	adds	r2, r7, r2
 800bd8c:	7812      	ldrb	r2, [r2, #0]
 800bd8e:	3201      	adds	r2, #1
 800bd90:	701a      	strb	r2, [r3, #0]
 800bd92:	e10d      	b.n	800bfb0 <tcp_slowtmr+0x340>
        } else {
          u8_t backoff_cnt = tcp_persist_backoff[pcb->persist_backoff - 1];
 800bd94:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bd96:	22a5      	movs	r2, #165	; 0xa5
 800bd98:	5c9b      	ldrb	r3, [r3, r2]
 800bd9a:	1e5a      	subs	r2, r3, #1
 800bd9c:	2011      	movs	r0, #17
 800bd9e:	183b      	adds	r3, r7, r0
 800bda0:	4961      	ldr	r1, [pc, #388]	; (800bf28 <tcp_slowtmr+0x2b8>)
 800bda2:	5c8a      	ldrb	r2, [r1, r2]
 800bda4:	701a      	strb	r2, [r3, #0]
          if (pcb->persist_cnt < backoff_cnt) {
 800bda6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bda8:	22a4      	movs	r2, #164	; 0xa4
 800bdaa:	5c9b      	ldrb	r3, [r3, r2]
 800bdac:	183a      	adds	r2, r7, r0
 800bdae:	7812      	ldrb	r2, [r2, #0]
 800bdb0:	429a      	cmp	r2, r3
 800bdb2:	d907      	bls.n	800bdc4 <tcp_slowtmr+0x154>
            pcb->persist_cnt++;
 800bdb4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bdb6:	22a4      	movs	r2, #164	; 0xa4
 800bdb8:	5c9b      	ldrb	r3, [r3, r2]
 800bdba:	3301      	adds	r3, #1
 800bdbc:	b2d9      	uxtb	r1, r3
 800bdbe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bdc0:	22a4      	movs	r2, #164	; 0xa4
 800bdc2:	5499      	strb	r1, [r3, r2]
          }
          if (pcb->persist_cnt >= backoff_cnt) {
 800bdc4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bdc6:	22a4      	movs	r2, #164	; 0xa4
 800bdc8:	5c9b      	ldrb	r3, [r3, r2]
 800bdca:	2211      	movs	r2, #17
 800bdcc:	18ba      	adds	r2, r7, r2
 800bdce:	7812      	ldrb	r2, [r2, #0]
 800bdd0:	429a      	cmp	r2, r3
 800bdd2:	d900      	bls.n	800bdd6 <tcp_slowtmr+0x166>
 800bdd4:	e0ec      	b.n	800bfb0 <tcp_slowtmr+0x340>
            int next_slot = 1; /* increment timer to next slot */
 800bdd6:	2301      	movs	r3, #1
 800bdd8:	623b      	str	r3, [r7, #32]
            /* If snd_wnd is zero, send 1 byte probes */
            if (pcb->snd_wnd == 0) {
 800bdda:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bddc:	2264      	movs	r2, #100	; 0x64
 800bdde:	5a9b      	ldrh	r3, [r3, r2]
 800bde0:	2b00      	cmp	r3, #0
 800bde2:	d108      	bne.n	800bdf6 <tcp_slowtmr+0x186>
              if (tcp_zero_window_probe(pcb) != ERR_OK) {
 800bde4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bde6:	0018      	movs	r0, r3
 800bde8:	f006 fc44 	bl	8012674 <tcp_zero_window_probe>
 800bdec:	1e03      	subs	r3, r0, #0
 800bdee:	d014      	beq.n	800be1a <tcp_slowtmr+0x1aa>
                next_slot = 0; /* try probe again with current slot */
 800bdf0:	2300      	movs	r3, #0
 800bdf2:	623b      	str	r3, [r7, #32]
 800bdf4:	e011      	b.n	800be1a <tcp_slowtmr+0x1aa>
              }
              /* snd_wnd not fully closed, split unsent head and fill window */
            } else {
              if (tcp_split_unsent_seg(pcb, (u16_t)pcb->snd_wnd) == ERR_OK) {
 800bdf6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bdf8:	2264      	movs	r2, #100	; 0x64
 800bdfa:	5a9a      	ldrh	r2, [r3, r2]
 800bdfc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bdfe:	0011      	movs	r1, r2
 800be00:	0018      	movs	r0, r3
 800be02:	f004 ff17 	bl	8010c34 <tcp_split_unsent_seg>
 800be06:	1e03      	subs	r3, r0, #0
 800be08:	d107      	bne.n	800be1a <tcp_slowtmr+0x1aa>
                if (tcp_output(pcb) == ERR_OK) {
 800be0a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800be0c:	0018      	movs	r0, r3
 800be0e:	f005 fabd 	bl	801138c <tcp_output>
 800be12:	1e03      	subs	r3, r0, #0
 800be14:	d101      	bne.n	800be1a <tcp_slowtmr+0x1aa>
                  /* sending will cancel persist timer, else retry with current slot */
                  next_slot = 0;
 800be16:	2300      	movs	r3, #0
 800be18:	623b      	str	r3, [r7, #32]
                }
              }
            }
            if (next_slot) {
 800be1a:	6a3b      	ldr	r3, [r7, #32]
 800be1c:	2b00      	cmp	r3, #0
 800be1e:	d100      	bne.n	800be22 <tcp_slowtmr+0x1b2>
 800be20:	e0c6      	b.n	800bfb0 <tcp_slowtmr+0x340>
              pcb->persist_cnt = 0;
 800be22:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800be24:	22a4      	movs	r2, #164	; 0xa4
 800be26:	2100      	movs	r1, #0
 800be28:	5499      	strb	r1, [r3, r2]
              if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
 800be2a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800be2c:	22a5      	movs	r2, #165	; 0xa5
 800be2e:	5c9b      	ldrb	r3, [r3, r2]
 800be30:	2b06      	cmp	r3, #6
 800be32:	d900      	bls.n	800be36 <tcp_slowtmr+0x1c6>
 800be34:	e0bc      	b.n	800bfb0 <tcp_slowtmr+0x340>
                pcb->persist_backoff++;
 800be36:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800be38:	22a5      	movs	r2, #165	; 0xa5
 800be3a:	5c9b      	ldrb	r3, [r3, r2]
 800be3c:	3301      	adds	r3, #1
 800be3e:	b2d9      	uxtb	r1, r3
 800be40:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800be42:	22a5      	movs	r2, #165	; 0xa5
 800be44:	5499      	strb	r1, [r3, r2]
 800be46:	e0b3      	b.n	800bfb0 <tcp_slowtmr+0x340>
            }
          }
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if ((pcb->rtime >= 0) && (pcb->rtime < 0x7FFF)) {
 800be48:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800be4a:	2234      	movs	r2, #52	; 0x34
 800be4c:	5e9b      	ldrsh	r3, [r3, r2]
 800be4e:	2b00      	cmp	r3, #0
 800be50:	db0e      	blt.n	800be70 <tcp_slowtmr+0x200>
 800be52:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800be54:	2234      	movs	r2, #52	; 0x34
 800be56:	5e9b      	ldrsh	r3, [r3, r2]
 800be58:	4a34      	ldr	r2, [pc, #208]	; (800bf2c <tcp_slowtmr+0x2bc>)
 800be5a:	4293      	cmp	r3, r2
 800be5c:	d008      	beq.n	800be70 <tcp_slowtmr+0x200>
          ++pcb->rtime;
 800be5e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800be60:	2234      	movs	r2, #52	; 0x34
 800be62:	5e9b      	ldrsh	r3, [r3, r2]
 800be64:	b29b      	uxth	r3, r3
 800be66:	3301      	adds	r3, #1
 800be68:	b29b      	uxth	r3, r3
 800be6a:	b21a      	sxth	r2, r3
 800be6c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800be6e:	869a      	strh	r2, [r3, #52]	; 0x34
        }

        if (pcb->rtime >= pcb->rto) {
 800be70:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800be72:	2234      	movs	r2, #52	; 0x34
 800be74:	5e9a      	ldrsh	r2, [r3, r2]
 800be76:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800be78:	2144      	movs	r1, #68	; 0x44
 800be7a:	5e5b      	ldrsh	r3, [r3, r1]
 800be7c:	429a      	cmp	r2, r3
 800be7e:	da00      	bge.n	800be82 <tcp_slowtmr+0x212>
 800be80:	e096      	b.n	800bfb0 <tcp_slowtmr+0x340>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));
          /* If prepare phase fails but we have unsent data but no unacked data,
             still execute the backoff calculations below, as this means we somehow
             failed to send segment. */
          if ((tcp_rexmit_rto_prepare(pcb) == ERR_OK) || ((pcb->unacked == NULL) && (pcb->unsent != NULL))) {
 800be82:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800be84:	0018      	movs	r0, r3
 800be86:	f005 fedb 	bl	8011c40 <tcp_rexmit_rto_prepare>
 800be8a:	1e03      	subs	r3, r0, #0
 800be8c:	d009      	beq.n	800bea2 <tcp_slowtmr+0x232>
 800be8e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800be90:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800be92:	2b00      	cmp	r3, #0
 800be94:	d000      	beq.n	800be98 <tcp_slowtmr+0x228>
 800be96:	e08b      	b.n	800bfb0 <tcp_slowtmr+0x340>
 800be98:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800be9a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800be9c:	2b00      	cmp	r3, #0
 800be9e:	d100      	bne.n	800bea2 <tcp_slowtmr+0x232>
 800bea0:	e086      	b.n	800bfb0 <tcp_slowtmr+0x340>
            /* Double retransmission time-out unless we are trying to
             * connect to somebody (i.e., we are in SYN_SENT). */
            if (pcb->state != SYN_SENT) {
 800bea2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bea4:	7e1b      	ldrb	r3, [r3, #24]
 800bea6:	2b02      	cmp	r3, #2
 800bea8:	d04a      	beq.n	800bf40 <tcp_slowtmr+0x2d0>
              u8_t backoff_idx = LWIP_MIN(pcb->nrtx, sizeof(tcp_backoff) - 1);
 800beaa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800beac:	2246      	movs	r2, #70	; 0x46
 800beae:	5c9b      	ldrb	r3, [r3, r2]
 800beb0:	221b      	movs	r2, #27
 800beb2:	18ba      	adds	r2, r7, r2
 800beb4:	b2d9      	uxtb	r1, r3
 800beb6:	290c      	cmp	r1, #12
 800beb8:	d900      	bls.n	800bebc <tcp_slowtmr+0x24c>
 800beba:	230c      	movs	r3, #12
 800bebc:	7013      	strb	r3, [r2, #0]
              int calc_rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[backoff_idx];
 800bebe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bec0:	2240      	movs	r2, #64	; 0x40
 800bec2:	5e9b      	ldrsh	r3, [r3, r2]
 800bec4:	10db      	asrs	r3, r3, #3
 800bec6:	b21b      	sxth	r3, r3
 800bec8:	0019      	movs	r1, r3
 800beca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800becc:	2242      	movs	r2, #66	; 0x42
 800bece:	5e9b      	ldrsh	r3, [r3, r2]
 800bed0:	18cb      	adds	r3, r1, r3
 800bed2:	221b      	movs	r2, #27
 800bed4:	18ba      	adds	r2, r7, r2
 800bed6:	7812      	ldrb	r2, [r2, #0]
 800bed8:	4915      	ldr	r1, [pc, #84]	; (800bf30 <tcp_slowtmr+0x2c0>)
 800beda:	5c8a      	ldrb	r2, [r1, r2]
 800bedc:	4093      	lsls	r3, r2
 800bede:	617b      	str	r3, [r7, #20]
              pcb->rto = (s16_t)LWIP_MIN(calc_rto, 0x7FFF);
 800bee0:	697b      	ldr	r3, [r7, #20]
 800bee2:	4a14      	ldr	r2, [pc, #80]	; (800bf34 <tcp_slowtmr+0x2c4>)
 800bee4:	4293      	cmp	r3, r2
 800bee6:	dc27      	bgt.n	800bf38 <tcp_slowtmr+0x2c8>
 800bee8:	697b      	ldr	r3, [r7, #20]
 800beea:	b21a      	sxth	r2, r3
 800beec:	e025      	b.n	800bf3a <tcp_slowtmr+0x2ca>
 800beee:	46c0      	nop			; (mov r8, r8)
 800bef0:	20002790 	.word	0x20002790
 800bef4:	20000c46 	.word	0x20000c46
 800bef8:	2000278c 	.word	0x2000278c
 800befc:	08020aa8 	.word	0x08020aa8
 800bf00:	000004bf 	.word	0x000004bf
 800bf04:	08020de8 	.word	0x08020de8
 800bf08:	08020ae4 	.word	0x08020ae4
 800bf0c:	08020e14 	.word	0x08020e14
 800bf10:	000004c1 	.word	0x000004c1
 800bf14:	08020e40 	.word	0x08020e40
 800bf18:	000004d5 	.word	0x000004d5
 800bf1c:	08020e70 	.word	0x08020e70
 800bf20:	000004d6 	.word	0x000004d6
 800bf24:	08020ea4 	.word	0x08020ea4
 800bf28:	08023a3c 	.word	0x08023a3c
 800bf2c:	00007fff 	.word	0x00007fff
 800bf30:	08023a2c 	.word	0x08023a2c
 800bf34:	00007ffe 	.word	0x00007ffe
 800bf38:	4ad0      	ldr	r2, [pc, #832]	; (800c27c <tcp_slowtmr+0x60c>)
 800bf3a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bf3c:	2144      	movs	r1, #68	; 0x44
 800bf3e:	525a      	strh	r2, [r3, r1]
            }

            /* Reset the retransmission timer. */
            pcb->rtime = 0;
 800bf40:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bf42:	2200      	movs	r2, #0
 800bf44:	869a      	strh	r2, [r3, #52]	; 0x34

            /* Reduce congestion window and ssthresh. */
            eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
 800bf46:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bf48:	2264      	movs	r2, #100	; 0x64
 800bf4a:	5a99      	ldrh	r1, [r3, r2]
 800bf4c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bf4e:	224c      	movs	r2, #76	; 0x4c
 800bf50:	5a9b      	ldrh	r3, [r3, r2]
 800bf52:	2212      	movs	r2, #18
 800bf54:	18ba      	adds	r2, r7, r2
 800bf56:	1c1c      	adds	r4, r3, #0
 800bf58:	1c0b      	adds	r3, r1, #0
 800bf5a:	b298      	uxth	r0, r3
 800bf5c:	b2a1      	uxth	r1, r4
 800bf5e:	4288      	cmp	r0, r1
 800bf60:	d900      	bls.n	800bf64 <tcp_slowtmr+0x2f4>
 800bf62:	1c23      	adds	r3, r4, #0
 800bf64:	8013      	strh	r3, [r2, #0]
            pcb->ssthresh = eff_wnd >> 1;
 800bf66:	2312      	movs	r3, #18
 800bf68:	18fb      	adds	r3, r7, r3
 800bf6a:	881b      	ldrh	r3, [r3, #0]
 800bf6c:	085b      	lsrs	r3, r3, #1
 800bf6e:	b299      	uxth	r1, r3
 800bf70:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bf72:	224e      	movs	r2, #78	; 0x4e
 800bf74:	5299      	strh	r1, [r3, r2]
            if (pcb->ssthresh < (tcpwnd_size_t)(pcb->mss << 1)) {
 800bf76:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bf78:	224e      	movs	r2, #78	; 0x4e
 800bf7a:	5a9a      	ldrh	r2, [r3, r2]
 800bf7c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bf7e:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800bf80:	18db      	adds	r3, r3, r3
 800bf82:	b29b      	uxth	r3, r3
 800bf84:	429a      	cmp	r2, r3
 800bf86:	d206      	bcs.n	800bf96 <tcp_slowtmr+0x326>
              pcb->ssthresh = (tcpwnd_size_t)(pcb->mss << 1);
 800bf88:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bf8a:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800bf8c:	18db      	adds	r3, r3, r3
 800bf8e:	b299      	uxth	r1, r3
 800bf90:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bf92:	224e      	movs	r2, #78	; 0x4e
 800bf94:	5299      	strh	r1, [r3, r2]
            }
            pcb->cwnd = pcb->mss;
 800bf96:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bf98:	8ed9      	ldrh	r1, [r3, #54]	; 0x36
 800bf9a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bf9c:	224c      	movs	r2, #76	; 0x4c
 800bf9e:	5299      	strh	r1, [r3, r2]
            LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: cwnd %"TCPWNDSIZE_F
                                         " ssthresh %"TCPWNDSIZE_F"\n",
                                         pcb->cwnd, pcb->ssthresh));
            pcb->bytes_acked = 0;
 800bfa0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bfa2:	226e      	movs	r2, #110	; 0x6e
 800bfa4:	2100      	movs	r1, #0
 800bfa6:	5299      	strh	r1, [r3, r2]

            /* The following needs to be called AFTER cwnd is set to one
               mss - STJ */
            tcp_rexmit_rto_commit(pcb);
 800bfa8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bfaa:	0018      	movs	r0, r3
 800bfac:	f005 fed0 	bl	8011d50 <tcp_rexmit_rto_commit>
          }
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
 800bfb0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bfb2:	7e1b      	ldrb	r3, [r3, #24]
 800bfb4:	2b06      	cmp	r3, #6
 800bfb6:	d112      	bne.n	800bfde <tcp_slowtmr+0x36e>
      /* If this PCB is in FIN_WAIT_2 because of SHUT_WR don't let it time out. */
      if (pcb->flags & TF_RXCLOSED) {
 800bfb8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bfba:	8bdb      	ldrh	r3, [r3, #30]
 800bfbc:	001a      	movs	r2, r3
 800bfbe:	2310      	movs	r3, #16
 800bfc0:	4013      	ands	r3, r2
 800bfc2:	d00c      	beq.n	800bfde <tcp_slowtmr+0x36e>
        /* PCB was fully closed (either through close() or SHUT_RDWR):
           normal FIN-WAIT timeout handling. */
        if ((u32_t)(tcp_ticks - pcb->tmr) >
 800bfc4:	4bae      	ldr	r3, [pc, #696]	; (800c280 <tcp_slowtmr+0x610>)
 800bfc6:	681a      	ldr	r2, [r3, #0]
 800bfc8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bfca:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800bfcc:	1ad3      	subs	r3, r2, r3
 800bfce:	2b14      	cmp	r3, #20
 800bfd0:	d905      	bls.n	800bfde <tcp_slowtmr+0x36e>
            TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
          ++pcb_remove;
 800bfd2:	2227      	movs	r2, #39	; 0x27
 800bfd4:	18bb      	adds	r3, r7, r2
 800bfd6:	18ba      	adds	r2, r7, r2
 800bfd8:	7812      	ldrb	r2, [r2, #0]
 800bfda:	3201      	adds	r2, #1
 800bfdc:	701a      	strb	r2, [r3, #0]
        }
      }
    }

    /* Check if KEEPALIVE should be sent */
    if (ip_get_option(pcb, SOF_KEEPALIVE) &&
 800bfde:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bfe0:	7a5b      	ldrb	r3, [r3, #9]
 800bfe2:	001a      	movs	r2, r3
 800bfe4:	2308      	movs	r3, #8
 800bfe6:	4013      	ands	r3, r2
 800bfe8:	d05a      	beq.n	800c0a0 <tcp_slowtmr+0x430>
        ((pcb->state == ESTABLISHED) ||
 800bfea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bfec:	7e1b      	ldrb	r3, [r3, #24]
    if (ip_get_option(pcb, SOF_KEEPALIVE) &&
 800bfee:	2b04      	cmp	r3, #4
 800bff0:	d003      	beq.n	800bffa <tcp_slowtmr+0x38a>
         (pcb->state == CLOSE_WAIT))) {
 800bff2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bff4:	7e1b      	ldrb	r3, [r3, #24]
        ((pcb->state == ESTABLISHED) ||
 800bff6:	2b07      	cmp	r3, #7
 800bff8:	d152      	bne.n	800c0a0 <tcp_slowtmr+0x430>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 800bffa:	4ba1      	ldr	r3, [pc, #644]	; (800c280 <tcp_slowtmr+0x610>)
 800bffc:	681a      	ldr	r2, [r3, #0]
 800bffe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c000:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c002:	1ad4      	subs	r4, r2, r3
          (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL) {
 800c004:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c006:	2298      	movs	r2, #152	; 0x98
 800c008:	589a      	ldr	r2, [r3, r2]
 800c00a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c00c:	21a0      	movs	r1, #160	; 0xa0
 800c00e:	585b      	ldr	r3, [r3, r1]
 800c010:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800c012:	209c      	movs	r0, #156	; 0x9c
 800c014:	5809      	ldr	r1, [r1, r0]
 800c016:	434b      	muls	r3, r1
 800c018:	18d3      	adds	r3, r2, r3
 800c01a:	22fa      	movs	r2, #250	; 0xfa
 800c01c:	0091      	lsls	r1, r2, #2
 800c01e:	0018      	movs	r0, r3
 800c020:	f7f4 f88e 	bl	8000140 <__udivsi3>
 800c024:	0003      	movs	r3, r0
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 800c026:	429c      	cmp	r4, r3
 800c028:	d90c      	bls.n	800c044 <tcp_slowtmr+0x3d4>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to "));
        ip_addr_debug_print_val(TCP_DEBUG, pcb->remote_ip);
        LWIP_DEBUGF(TCP_DEBUG, ("\n"));

        ++pcb_remove;
 800c02a:	2227      	movs	r2, #39	; 0x27
 800c02c:	18bb      	adds	r3, r7, r2
 800c02e:	18ba      	adds	r2, r7, r2
 800c030:	7812      	ldrb	r2, [r2, #0]
 800c032:	3201      	adds	r2, #1
 800c034:	701a      	strb	r2, [r3, #0]
        ++pcb_reset;
 800c036:	2226      	movs	r2, #38	; 0x26
 800c038:	18bb      	adds	r3, r7, r2
 800c03a:	18ba      	adds	r2, r7, r2
 800c03c:	7812      	ldrb	r2, [r2, #0]
 800c03e:	3201      	adds	r2, #1
 800c040:	701a      	strb	r2, [r3, #0]
 800c042:	e02d      	b.n	800c0a0 <tcp_slowtmr+0x430>
      } else if ((u32_t)(tcp_ticks - pcb->tmr) >
 800c044:	4b8e      	ldr	r3, [pc, #568]	; (800c280 <tcp_slowtmr+0x610>)
 800c046:	681a      	ldr	r2, [r3, #0]
 800c048:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c04a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c04c:	1ad4      	subs	r4, r2, r3
                 (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
 800c04e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c050:	2298      	movs	r2, #152	; 0x98
 800c052:	589a      	ldr	r2, [r3, r2]
 800c054:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c056:	21a7      	movs	r1, #167	; 0xa7
 800c058:	5c5b      	ldrb	r3, [r3, r1]
 800c05a:	0018      	movs	r0, r3
 800c05c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c05e:	219c      	movs	r1, #156	; 0x9c
 800c060:	585b      	ldr	r3, [r3, r1]
 800c062:	4343      	muls	r3, r0
 800c064:	18d3      	adds	r3, r2, r3
                 / TCP_SLOW_INTERVAL) {
 800c066:	22fa      	movs	r2, #250	; 0xfa
 800c068:	0091      	lsls	r1, r2, #2
 800c06a:	0018      	movs	r0, r3
 800c06c:	f7f4 f868 	bl	8000140 <__udivsi3>
 800c070:	0003      	movs	r3, r0
      } else if ((u32_t)(tcp_ticks - pcb->tmr) >
 800c072:	429c      	cmp	r4, r3
 800c074:	d914      	bls.n	800c0a0 <tcp_slowtmr+0x430>
        err = tcp_keepalive(pcb);
 800c076:	2525      	movs	r5, #37	; 0x25
 800c078:	197c      	adds	r4, r7, r5
 800c07a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c07c:	0018      	movs	r0, r3
 800c07e:	f006 faaf 	bl	80125e0 <tcp_keepalive>
 800c082:	0003      	movs	r3, r0
 800c084:	7023      	strb	r3, [r4, #0]
        if (err == ERR_OK) {
 800c086:	197b      	adds	r3, r7, r5
 800c088:	781b      	ldrb	r3, [r3, #0]
 800c08a:	b25b      	sxtb	r3, r3
 800c08c:	2b00      	cmp	r3, #0
 800c08e:	d107      	bne.n	800c0a0 <tcp_slowtmr+0x430>
          pcb->keep_cnt_sent++;
 800c090:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c092:	22a7      	movs	r2, #167	; 0xa7
 800c094:	5c9b      	ldrb	r3, [r3, r2]
 800c096:	3301      	adds	r3, #1
 800c098:	b2d9      	uxtb	r1, r3
 800c09a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c09c:	22a7      	movs	r2, #167	; 0xa7
 800c09e:	5499      	strb	r1, [r3, r2]

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL &&
 800c0a0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c0a2:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800c0a4:	2b00      	cmp	r3, #0
 800c0a6:	d012      	beq.n	800c0ce <tcp_slowtmr+0x45e>
        (tcp_ticks - pcb->tmr >= (u32_t)pcb->rto * TCP_OOSEQ_TIMEOUT)) {
 800c0a8:	4b75      	ldr	r3, [pc, #468]	; (800c280 <tcp_slowtmr+0x610>)
 800c0aa:	681a      	ldr	r2, [r3, #0]
 800c0ac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c0ae:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c0b0:	1ad2      	subs	r2, r2, r3
 800c0b2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c0b4:	2144      	movs	r1, #68	; 0x44
 800c0b6:	5e5b      	ldrsh	r3, [r3, r1]
 800c0b8:	0019      	movs	r1, r3
 800c0ba:	000b      	movs	r3, r1
 800c0bc:	005b      	lsls	r3, r3, #1
 800c0be:	185b      	adds	r3, r3, r1
 800c0c0:	005b      	lsls	r3, r3, #1
    if (pcb->ooseq != NULL &&
 800c0c2:	429a      	cmp	r2, r3
 800c0c4:	d303      	bcc.n	800c0ce <tcp_slowtmr+0x45e>
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
      tcp_free_ooseq(pcb);
 800c0c6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c0c8:	0018      	movs	r0, r3
 800c0ca:	f000 ff03 	bl	800ced4 <tcp_free_ooseq>
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
 800c0ce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c0d0:	7e1b      	ldrb	r3, [r3, #24]
 800c0d2:	2b03      	cmp	r3, #3
 800c0d4:	d10c      	bne.n	800c0f0 <tcp_slowtmr+0x480>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 800c0d6:	4b6a      	ldr	r3, [pc, #424]	; (800c280 <tcp_slowtmr+0x610>)
 800c0d8:	681a      	ldr	r2, [r3, #0]
 800c0da:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c0dc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c0de:	1ad3      	subs	r3, r2, r3
 800c0e0:	2b14      	cmp	r3, #20
 800c0e2:	d905      	bls.n	800c0f0 <tcp_slowtmr+0x480>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
 800c0e4:	2227      	movs	r2, #39	; 0x27
 800c0e6:	18bb      	adds	r3, r7, r2
 800c0e8:	18ba      	adds	r2, r7, r2
 800c0ea:	7812      	ldrb	r2, [r2, #0]
 800c0ec:	3201      	adds	r2, #1
 800c0ee:	701a      	strb	r2, [r3, #0]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
 800c0f0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c0f2:	7e1b      	ldrb	r3, [r3, #24]
 800c0f4:	2b09      	cmp	r3, #9
 800c0f6:	d10c      	bne.n	800c112 <tcp_slowtmr+0x4a2>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 800c0f8:	4b61      	ldr	r3, [pc, #388]	; (800c280 <tcp_slowtmr+0x610>)
 800c0fa:	681a      	ldr	r2, [r3, #0]
 800c0fc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c0fe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c100:	1ad3      	subs	r3, r2, r3
 800c102:	2b78      	cmp	r3, #120	; 0x78
 800c104:	d905      	bls.n	800c112 <tcp_slowtmr+0x4a2>
        ++pcb_remove;
 800c106:	2227      	movs	r2, #39	; 0x27
 800c108:	18bb      	adds	r3, r7, r2
 800c10a:	18ba      	adds	r2, r7, r2
 800c10c:	7812      	ldrb	r2, [r2, #0]
 800c10e:	3201      	adds	r2, #1
 800c110:	701a      	strb	r2, [r3, #0]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
 800c112:	2327      	movs	r3, #39	; 0x27
 800c114:	18fb      	adds	r3, r7, r3
 800c116:	781b      	ldrb	r3, [r3, #0]
 800c118:	2b00      	cmp	r3, #0
 800c11a:	d063      	beq.n	800c1e4 <tcp_slowtmr+0x574>
      struct tcp_pcb *pcb2;
#if LWIP_CALLBACK_API
      tcp_err_fn err_fn = pcb->errf;
 800c11c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c11e:	2294      	movs	r2, #148	; 0x94
 800c120:	589b      	ldr	r3, [r3, r2]
 800c122:	60fb      	str	r3, [r7, #12]
#endif /* LWIP_CALLBACK_API */
      void *err_arg;
      enum tcp_state last_state;
      tcp_pcb_purge(pcb);
 800c124:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c126:	0018      	movs	r0, r3
 800c128:	f000 fd04 	bl	800cb34 <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
 800c12c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c12e:	2b00      	cmp	r3, #0
 800c130:	d00f      	beq.n	800c152 <tcp_slowtmr+0x4e2>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
 800c132:	4b54      	ldr	r3, [pc, #336]	; (800c284 <tcp_slowtmr+0x614>)
 800c134:	681b      	ldr	r3, [r3, #0]
 800c136:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800c138:	429a      	cmp	r2, r3
 800c13a:	d105      	bne.n	800c148 <tcp_slowtmr+0x4d8>
 800c13c:	4b52      	ldr	r3, [pc, #328]	; (800c288 <tcp_slowtmr+0x618>)
 800c13e:	4a53      	ldr	r2, [pc, #332]	; (800c28c <tcp_slowtmr+0x61c>)
 800c140:	4953      	ldr	r1, [pc, #332]	; (800c290 <tcp_slowtmr+0x620>)
 800c142:	4854      	ldr	r0, [pc, #336]	; (800c294 <tcp_slowtmr+0x624>)
 800c144:	f7f6 f84e 	bl	80021e4 <app_debug_rtt_raw>
        prev->next = pcb->next;
 800c148:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c14a:	691a      	ldr	r2, [r3, #16]
 800c14c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c14e:	611a      	str	r2, [r3, #16]
 800c150:	e00e      	b.n	800c170 <tcp_slowtmr+0x500>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
 800c152:	4b4c      	ldr	r3, [pc, #304]	; (800c284 <tcp_slowtmr+0x614>)
 800c154:	681b      	ldr	r3, [r3, #0]
 800c156:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800c158:	429a      	cmp	r2, r3
 800c15a:	d005      	beq.n	800c168 <tcp_slowtmr+0x4f8>
 800c15c:	4b4a      	ldr	r3, [pc, #296]	; (800c288 <tcp_slowtmr+0x618>)
 800c15e:	4a4e      	ldr	r2, [pc, #312]	; (800c298 <tcp_slowtmr+0x628>)
 800c160:	494e      	ldr	r1, [pc, #312]	; (800c29c <tcp_slowtmr+0x62c>)
 800c162:	484c      	ldr	r0, [pc, #304]	; (800c294 <tcp_slowtmr+0x624>)
 800c164:	f7f6 f83e 	bl	80021e4 <app_debug_rtt_raw>
        tcp_active_pcbs = pcb->next;
 800c168:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c16a:	691a      	ldr	r2, [r3, #16]
 800c16c:	4b45      	ldr	r3, [pc, #276]	; (800c284 <tcp_slowtmr+0x614>)
 800c16e:	601a      	str	r2, [r3, #0]
      }

      if (pcb_reset) {
 800c170:	2326      	movs	r3, #38	; 0x26
 800c172:	18fb      	adds	r3, r7, r3
 800c174:	781b      	ldrb	r3, [r3, #0]
 800c176:	2b00      	cmp	r3, #0
 800c178:	d013      	beq.n	800c1a2 <tcp_slowtmr+0x532>
        tcp_rst(pcb, pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 800c17a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c17c:	6d5c      	ldr	r4, [r3, #84]	; 0x54
 800c17e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c180:	6a9d      	ldr	r5, [r3, #40]	; 0x28
 800c182:	6afe      	ldr	r6, [r7, #44]	; 0x2c
 800c184:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c186:	3304      	adds	r3, #4
 800c188:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800c18a:	8b52      	ldrh	r2, [r2, #26]
 800c18c:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800c18e:	8b89      	ldrh	r1, [r1, #28]
 800c190:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800c192:	9102      	str	r1, [sp, #8]
 800c194:	9201      	str	r2, [sp, #4]
 800c196:	9300      	str	r3, [sp, #0]
 800c198:	0033      	movs	r3, r6
 800c19a:	002a      	movs	r2, r5
 800c19c:	0021      	movs	r1, r4
 800c19e:	f006 f949 	bl	8012434 <tcp_rst>
                pcb->local_port, pcb->remote_port);
      }

      err_arg = pcb->callback_arg;
 800c1a2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c1a4:	695b      	ldr	r3, [r3, #20]
 800c1a6:	60bb      	str	r3, [r7, #8]
      last_state = pcb->state;
 800c1a8:	1dfb      	adds	r3, r7, #7
 800c1aa:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800c1ac:	7e12      	ldrb	r2, [r2, #24]
 800c1ae:	701a      	strb	r2, [r3, #0]
      pcb2 = pcb;
 800c1b0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c1b2:	603b      	str	r3, [r7, #0]
      pcb = pcb->next;
 800c1b4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c1b6:	691b      	ldr	r3, [r3, #16]
 800c1b8:	62fb      	str	r3, [r7, #44]	; 0x2c
      tcp_free(pcb2);
 800c1ba:	683b      	ldr	r3, [r7, #0]
 800c1bc:	0018      	movs	r0, r3
 800c1be:	f7fe ff2b 	bl	800b018 <tcp_free>

      tcp_active_pcbs_changed = 0;
 800c1c2:	4b37      	ldr	r3, [pc, #220]	; (800c2a0 <tcp_slowtmr+0x630>)
 800c1c4:	2200      	movs	r2, #0
 800c1c6:	701a      	strb	r2, [r3, #0]
      TCP_EVENT_ERR(last_state, err_fn, err_arg, ERR_ABRT);
 800c1c8:	68fb      	ldr	r3, [r7, #12]
 800c1ca:	2b00      	cmp	r3, #0
 800c1cc:	d005      	beq.n	800c1da <tcp_slowtmr+0x56a>
 800c1ce:	230d      	movs	r3, #13
 800c1d0:	4259      	negs	r1, r3
 800c1d2:	68ba      	ldr	r2, [r7, #8]
 800c1d4:	68fb      	ldr	r3, [r7, #12]
 800c1d6:	0010      	movs	r0, r2
 800c1d8:	4798      	blx	r3
      if (tcp_active_pcbs_changed) {
 800c1da:	4b31      	ldr	r3, [pc, #196]	; (800c2a0 <tcp_slowtmr+0x630>)
 800c1dc:	781b      	ldrb	r3, [r3, #0]
 800c1de:	2b00      	cmp	r3, #0
 800c1e0:	d041      	beq.n	800c266 <tcp_slowtmr+0x5f6>
        goto tcp_slowtmr_start;
 800c1e2:	e557      	b.n	800bc94 <tcp_slowtmr+0x24>
      }
    } else {
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
 800c1e4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c1e6:	62bb      	str	r3, [r7, #40]	; 0x28
      pcb = pcb->next;
 800c1e8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c1ea:	691b      	ldr	r3, [r3, #16]
 800c1ec:	62fb      	str	r3, [r7, #44]	; 0x2c

      /* We check if we should poll the connection. */
      ++prev->polltmr;
 800c1ee:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c1f0:	2220      	movs	r2, #32
 800c1f2:	5c9b      	ldrb	r3, [r3, r2]
 800c1f4:	3301      	adds	r3, #1
 800c1f6:	b2d9      	uxtb	r1, r3
 800c1f8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c1fa:	2220      	movs	r2, #32
 800c1fc:	5499      	strb	r1, [r3, r2]
      if (prev->polltmr >= prev->pollinterval) {
 800c1fe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c200:	2220      	movs	r2, #32
 800c202:	5c9a      	ldrb	r2, [r3, r2]
 800c204:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c206:	2121      	movs	r1, #33	; 0x21
 800c208:	5c5b      	ldrb	r3, [r3, r1]
 800c20a:	429a      	cmp	r2, r3
 800c20c:	d32b      	bcc.n	800c266 <tcp_slowtmr+0x5f6>
        prev->polltmr = 0;
 800c20e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c210:	2220      	movs	r2, #32
 800c212:	2100      	movs	r1, #0
 800c214:	5499      	strb	r1, [r3, r2]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        tcp_active_pcbs_changed = 0;
 800c216:	4b22      	ldr	r3, [pc, #136]	; (800c2a0 <tcp_slowtmr+0x630>)
 800c218:	2200      	movs	r2, #0
 800c21a:	701a      	strb	r2, [r3, #0]
        TCP_EVENT_POLL(prev, err);
 800c21c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c21e:	2290      	movs	r2, #144	; 0x90
 800c220:	589b      	ldr	r3, [r3, r2]
 800c222:	2b00      	cmp	r3, #0
 800c224:	d00c      	beq.n	800c240 <tcp_slowtmr+0x5d0>
 800c226:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c228:	2290      	movs	r2, #144	; 0x90
 800c22a:	589a      	ldr	r2, [r3, r2]
 800c22c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c22e:	695b      	ldr	r3, [r3, #20]
 800c230:	2125      	movs	r1, #37	; 0x25
 800c232:	187c      	adds	r4, r7, r1
 800c234:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800c236:	0018      	movs	r0, r3
 800c238:	4790      	blx	r2
 800c23a:	0003      	movs	r3, r0
 800c23c:	7023      	strb	r3, [r4, #0]
 800c23e:	e003      	b.n	800c248 <tcp_slowtmr+0x5d8>
 800c240:	2325      	movs	r3, #37	; 0x25
 800c242:	18fb      	adds	r3, r7, r3
 800c244:	2200      	movs	r2, #0
 800c246:	701a      	strb	r2, [r3, #0]
        if (tcp_active_pcbs_changed) {
 800c248:	4b15      	ldr	r3, [pc, #84]	; (800c2a0 <tcp_slowtmr+0x630>)
 800c24a:	781b      	ldrb	r3, [r3, #0]
 800c24c:	2b00      	cmp	r3, #0
 800c24e:	d000      	beq.n	800c252 <tcp_slowtmr+0x5e2>
          goto tcp_slowtmr_start;
 800c250:	e520      	b.n	800bc94 <tcp_slowtmr+0x24>
        }
        /* if err == ERR_ABRT, 'prev' is already deallocated */
        if (err == ERR_OK) {
 800c252:	2325      	movs	r3, #37	; 0x25
 800c254:	18fb      	adds	r3, r7, r3
 800c256:	781b      	ldrb	r3, [r3, #0]
 800c258:	b25b      	sxtb	r3, r3
 800c25a:	2b00      	cmp	r3, #0
 800c25c:	d103      	bne.n	800c266 <tcp_slowtmr+0x5f6>
          tcp_output(prev);
 800c25e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c260:	0018      	movs	r0, r3
 800c262:	f005 f893 	bl	801138c <tcp_output>
  while (pcb != NULL) {
 800c266:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c268:	2b00      	cmp	r3, #0
 800c26a:	d000      	beq.n	800c26e <tcp_slowtmr+0x5fe>
 800c26c:	e518      	b.n	800bca0 <tcp_slowtmr+0x30>
    }
  }


  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
 800c26e:	2300      	movs	r3, #0
 800c270:	62bb      	str	r3, [r7, #40]	; 0x28
  pcb = tcp_tw_pcbs;
 800c272:	4b0c      	ldr	r3, [pc, #48]	; (800c2a4 <tcp_slowtmr+0x634>)
 800c274:	681b      	ldr	r3, [r3, #0]
 800c276:	62fb      	str	r3, [r7, #44]	; 0x2c
  while (pcb != NULL) {
 800c278:	e06b      	b.n	800c352 <tcp_slowtmr+0x6e2>
 800c27a:	46c0      	nop			; (mov r8, r8)
 800c27c:	00007fff 	.word	0x00007fff
 800c280:	20002790 	.word	0x20002790
 800c284:	2000278c 	.word	0x2000278c
 800c288:	08020aa8 	.word	0x08020aa8
 800c28c:	0000056e 	.word	0x0000056e
 800c290:	08020edc 	.word	0x08020edc
 800c294:	08020ae4 	.word	0x08020ae4
 800c298:	00000572 	.word	0x00000572
 800c29c:	08020f08 	.word	0x08020f08
 800c2a0:	20002788 	.word	0x20002788
 800c2a4:	2000279c 	.word	0x2000279c
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 800c2a8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c2aa:	7e1b      	ldrb	r3, [r3, #24]
 800c2ac:	2b0a      	cmp	r3, #10
 800c2ae:	d005      	beq.n	800c2bc <tcp_slowtmr+0x64c>
 800c2b0:	4b2c      	ldr	r3, [pc, #176]	; (800c364 <tcp_slowtmr+0x6f4>)
 800c2b2:	4a2d      	ldr	r2, [pc, #180]	; (800c368 <tcp_slowtmr+0x6f8>)
 800c2b4:	492d      	ldr	r1, [pc, #180]	; (800c36c <tcp_slowtmr+0x6fc>)
 800c2b6:	482e      	ldr	r0, [pc, #184]	; (800c370 <tcp_slowtmr+0x700>)
 800c2b8:	f7f5 ff94 	bl	80021e4 <app_debug_rtt_raw>
    pcb_remove = 0;
 800c2bc:	2127      	movs	r1, #39	; 0x27
 800c2be:	187b      	adds	r3, r7, r1
 800c2c0:	2200      	movs	r2, #0
 800c2c2:	701a      	strb	r2, [r3, #0]

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 800c2c4:	4b2b      	ldr	r3, [pc, #172]	; (800c374 <tcp_slowtmr+0x704>)
 800c2c6:	681a      	ldr	r2, [r3, #0]
 800c2c8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c2ca:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c2cc:	1ad3      	subs	r3, r2, r3
 800c2ce:	2b78      	cmp	r3, #120	; 0x78
 800c2d0:	d904      	bls.n	800c2dc <tcp_slowtmr+0x66c>
      ++pcb_remove;
 800c2d2:	187b      	adds	r3, r7, r1
 800c2d4:	187a      	adds	r2, r7, r1
 800c2d6:	7812      	ldrb	r2, [r2, #0]
 800c2d8:	3201      	adds	r2, #1
 800c2da:	701a      	strb	r2, [r3, #0]
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
 800c2dc:	2327      	movs	r3, #39	; 0x27
 800c2de:	18fb      	adds	r3, r7, r3
 800c2e0:	781b      	ldrb	r3, [r3, #0]
 800c2e2:	2b00      	cmp	r3, #0
 800c2e4:	d030      	beq.n	800c348 <tcp_slowtmr+0x6d8>
      struct tcp_pcb *pcb2;
      tcp_pcb_purge(pcb);
 800c2e6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c2e8:	0018      	movs	r0, r3
 800c2ea:	f000 fc23 	bl	800cb34 <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
 800c2ee:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c2f0:	2b00      	cmp	r3, #0
 800c2f2:	d010      	beq.n	800c316 <tcp_slowtmr+0x6a6>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
 800c2f4:	4b20      	ldr	r3, [pc, #128]	; (800c378 <tcp_slowtmr+0x708>)
 800c2f6:	681b      	ldr	r3, [r3, #0]
 800c2f8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800c2fa:	429a      	cmp	r2, r3
 800c2fc:	d106      	bne.n	800c30c <tcp_slowtmr+0x69c>
 800c2fe:	4b19      	ldr	r3, [pc, #100]	; (800c364 <tcp_slowtmr+0x6f4>)
 800c300:	22b6      	movs	r2, #182	; 0xb6
 800c302:	00d2      	lsls	r2, r2, #3
 800c304:	491d      	ldr	r1, [pc, #116]	; (800c37c <tcp_slowtmr+0x70c>)
 800c306:	481a      	ldr	r0, [pc, #104]	; (800c370 <tcp_slowtmr+0x700>)
 800c308:	f7f5 ff6c 	bl	80021e4 <app_debug_rtt_raw>
        prev->next = pcb->next;
 800c30c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c30e:	691a      	ldr	r2, [r3, #16]
 800c310:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c312:	611a      	str	r2, [r3, #16]
 800c314:	e00e      	b.n	800c334 <tcp_slowtmr+0x6c4>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
 800c316:	4b18      	ldr	r3, [pc, #96]	; (800c378 <tcp_slowtmr+0x708>)
 800c318:	681b      	ldr	r3, [r3, #0]
 800c31a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800c31c:	429a      	cmp	r2, r3
 800c31e:	d005      	beq.n	800c32c <tcp_slowtmr+0x6bc>
 800c320:	4b10      	ldr	r3, [pc, #64]	; (800c364 <tcp_slowtmr+0x6f4>)
 800c322:	4a17      	ldr	r2, [pc, #92]	; (800c380 <tcp_slowtmr+0x710>)
 800c324:	4917      	ldr	r1, [pc, #92]	; (800c384 <tcp_slowtmr+0x714>)
 800c326:	4812      	ldr	r0, [pc, #72]	; (800c370 <tcp_slowtmr+0x700>)
 800c328:	f7f5 ff5c 	bl	80021e4 <app_debug_rtt_raw>
        tcp_tw_pcbs = pcb->next;
 800c32c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c32e:	691a      	ldr	r2, [r3, #16]
 800c330:	4b11      	ldr	r3, [pc, #68]	; (800c378 <tcp_slowtmr+0x708>)
 800c332:	601a      	str	r2, [r3, #0]
      }
      pcb2 = pcb;
 800c334:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c336:	61fb      	str	r3, [r7, #28]
      pcb = pcb->next;
 800c338:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c33a:	691b      	ldr	r3, [r3, #16]
 800c33c:	62fb      	str	r3, [r7, #44]	; 0x2c
      tcp_free(pcb2);
 800c33e:	69fb      	ldr	r3, [r7, #28]
 800c340:	0018      	movs	r0, r3
 800c342:	f7fe fe69 	bl	800b018 <tcp_free>
 800c346:	e004      	b.n	800c352 <tcp_slowtmr+0x6e2>
    } else {
      prev = pcb;
 800c348:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c34a:	62bb      	str	r3, [r7, #40]	; 0x28
      pcb = pcb->next;
 800c34c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c34e:	691b      	ldr	r3, [r3, #16]
 800c350:	62fb      	str	r3, [r7, #44]	; 0x2c
  while (pcb != NULL) {
 800c352:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c354:	2b00      	cmp	r3, #0
 800c356:	d1a7      	bne.n	800c2a8 <tcp_slowtmr+0x638>
    }
  }
}
 800c358:	46c0      	nop			; (mov r8, r8)
 800c35a:	46c0      	nop			; (mov r8, r8)
 800c35c:	46bd      	mov	sp, r7
 800c35e:	b00d      	add	sp, #52	; 0x34
 800c360:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800c362:	46c0      	nop			; (mov r8, r8)
 800c364:	08020aa8 	.word	0x08020aa8
 800c368:	000005a2 	.word	0x000005a2
 800c36c:	08020f34 	.word	0x08020f34
 800c370:	08020ae4 	.word	0x08020ae4
 800c374:	20002790 	.word	0x20002790
 800c378:	2000279c 	.word	0x2000279c
 800c37c:	08020f64 	.word	0x08020f64
 800c380:	000005b4 	.word	0x000005b4
 800c384:	08020f8c 	.word	0x08020f8c

0800c388 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
 800c388:	b580      	push	{r7, lr}
 800c38a:	b082      	sub	sp, #8
 800c38c:	af00      	add	r7, sp, #0
  struct tcp_pcb *pcb;

  ++tcp_timer_ctr;
 800c38e:	4b30      	ldr	r3, [pc, #192]	; (800c450 <tcp_fasttmr+0xc8>)
 800c390:	781b      	ldrb	r3, [r3, #0]
 800c392:	3301      	adds	r3, #1
 800c394:	b2da      	uxtb	r2, r3
 800c396:	4b2e      	ldr	r3, [pc, #184]	; (800c450 <tcp_fasttmr+0xc8>)
 800c398:	701a      	strb	r2, [r3, #0]

tcp_fasttmr_start:
  pcb = tcp_active_pcbs;
 800c39a:	4b2e      	ldr	r3, [pc, #184]	; (800c454 <tcp_fasttmr+0xcc>)
 800c39c:	681b      	ldr	r3, [r3, #0]
 800c39e:	607b      	str	r3, [r7, #4]

  while (pcb != NULL) {
 800c3a0:	e04d      	b.n	800c43e <tcp_fasttmr+0xb6>
    if (pcb->last_timer != tcp_timer_ctr) {
 800c3a2:	687b      	ldr	r3, [r7, #4]
 800c3a4:	2222      	movs	r2, #34	; 0x22
 800c3a6:	5c9a      	ldrb	r2, [r3, r2]
 800c3a8:	4b29      	ldr	r3, [pc, #164]	; (800c450 <tcp_fasttmr+0xc8>)
 800c3aa:	781b      	ldrb	r3, [r3, #0]
 800c3ac:	429a      	cmp	r2, r3
 800c3ae:	d043      	beq.n	800c438 <tcp_fasttmr+0xb0>
      struct tcp_pcb *next;
      pcb->last_timer = tcp_timer_ctr;
 800c3b0:	4b27      	ldr	r3, [pc, #156]	; (800c450 <tcp_fasttmr+0xc8>)
 800c3b2:	7819      	ldrb	r1, [r3, #0]
 800c3b4:	687b      	ldr	r3, [r7, #4]
 800c3b6:	2222      	movs	r2, #34	; 0x22
 800c3b8:	5499      	strb	r1, [r3, r2]
      /* send delayed ACKs */
      if (pcb->flags & TF_ACK_DELAY) {
 800c3ba:	687b      	ldr	r3, [r7, #4]
 800c3bc:	8bdb      	ldrh	r3, [r3, #30]
 800c3be:	001a      	movs	r2, r3
 800c3c0:	2301      	movs	r3, #1
 800c3c2:	4013      	ands	r3, r2
 800c3c4:	d011      	beq.n	800c3ea <tcp_fasttmr+0x62>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
        tcp_ack_now(pcb);
 800c3c6:	687b      	ldr	r3, [r7, #4]
 800c3c8:	8bdb      	ldrh	r3, [r3, #30]
 800c3ca:	2202      	movs	r2, #2
 800c3cc:	4313      	orrs	r3, r2
 800c3ce:	b29a      	uxth	r2, r3
 800c3d0:	687b      	ldr	r3, [r7, #4]
 800c3d2:	83da      	strh	r2, [r3, #30]
        tcp_output(pcb);
 800c3d4:	687b      	ldr	r3, [r7, #4]
 800c3d6:	0018      	movs	r0, r3
 800c3d8:	f004 ffd8 	bl	801138c <tcp_output>
        tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 800c3dc:	687b      	ldr	r3, [r7, #4]
 800c3de:	8bdb      	ldrh	r3, [r3, #30]
 800c3e0:	2203      	movs	r2, #3
 800c3e2:	4393      	bics	r3, r2
 800c3e4:	b29a      	uxth	r2, r3
 800c3e6:	687b      	ldr	r3, [r7, #4]
 800c3e8:	83da      	strh	r2, [r3, #30]
      }
      /* send pending FIN */
      if (pcb->flags & TF_CLOSEPEND) {
 800c3ea:	687b      	ldr	r3, [r7, #4]
 800c3ec:	8bdb      	ldrh	r3, [r3, #30]
 800c3ee:	001a      	movs	r2, r3
 800c3f0:	2308      	movs	r3, #8
 800c3f2:	4013      	ands	r3, r2
 800c3f4:	d00a      	beq.n	800c40c <tcp_fasttmr+0x84>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: pending FIN\n"));
        tcp_clear_flags(pcb, TF_CLOSEPEND);
 800c3f6:	687b      	ldr	r3, [r7, #4]
 800c3f8:	8bdb      	ldrh	r3, [r3, #30]
 800c3fa:	2208      	movs	r2, #8
 800c3fc:	4393      	bics	r3, r2
 800c3fe:	b29a      	uxth	r2, r3
 800c400:	687b      	ldr	r3, [r7, #4]
 800c402:	83da      	strh	r2, [r3, #30]
        tcp_close_shutdown_fin(pcb);
 800c404:	687b      	ldr	r3, [r7, #4]
 800c406:	0018      	movs	r0, r3
 800c408:	f7fe ffb2 	bl	800b370 <tcp_close_shutdown_fin>
      }

      next = pcb->next;
 800c40c:	687b      	ldr	r3, [r7, #4]
 800c40e:	691b      	ldr	r3, [r3, #16]
 800c410:	603b      	str	r3, [r7, #0]

      /* If there is data which was previously "refused" by upper layer */
      if (pcb->refused_data != NULL) {
 800c412:	687b      	ldr	r3, [r7, #4]
 800c414:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800c416:	2b00      	cmp	r3, #0
 800c418:	d00b      	beq.n	800c432 <tcp_fasttmr+0xaa>
        tcp_active_pcbs_changed = 0;
 800c41a:	4b0f      	ldr	r3, [pc, #60]	; (800c458 <tcp_fasttmr+0xd0>)
 800c41c:	2200      	movs	r2, #0
 800c41e:	701a      	strb	r2, [r3, #0]
        tcp_process_refused_data(pcb);
 800c420:	687b      	ldr	r3, [r7, #4]
 800c422:	0018      	movs	r0, r3
 800c424:	f000 f81a 	bl	800c45c <tcp_process_refused_data>
        if (tcp_active_pcbs_changed) {
 800c428:	4b0b      	ldr	r3, [pc, #44]	; (800c458 <tcp_fasttmr+0xd0>)
 800c42a:	781b      	ldrb	r3, [r3, #0]
 800c42c:	2b00      	cmp	r3, #0
 800c42e:	d000      	beq.n	800c432 <tcp_fasttmr+0xaa>
          /* application callback has changed the pcb list: restart the loop */
          goto tcp_fasttmr_start;
 800c430:	e7b3      	b.n	800c39a <tcp_fasttmr+0x12>
        }
      }
      pcb = next;
 800c432:	683b      	ldr	r3, [r7, #0]
 800c434:	607b      	str	r3, [r7, #4]
 800c436:	e002      	b.n	800c43e <tcp_fasttmr+0xb6>
    } else {
      pcb = pcb->next;
 800c438:	687b      	ldr	r3, [r7, #4]
 800c43a:	691b      	ldr	r3, [r3, #16]
 800c43c:	607b      	str	r3, [r7, #4]
  while (pcb != NULL) {
 800c43e:	687b      	ldr	r3, [r7, #4]
 800c440:	2b00      	cmp	r3, #0
 800c442:	d1ae      	bne.n	800c3a2 <tcp_fasttmr+0x1a>
    }
  }
}
 800c444:	46c0      	nop			; (mov r8, r8)
 800c446:	46c0      	nop			; (mov r8, r8)
 800c448:	46bd      	mov	sp, r7
 800c44a:	b002      	add	sp, #8
 800c44c:	bd80      	pop	{r7, pc}
 800c44e:	46c0      	nop			; (mov r8, r8)
 800c450:	20000c46 	.word	0x20000c46
 800c454:	2000278c 	.word	0x2000278c
 800c458:	20002788 	.word	0x20002788

0800c45c <tcp_process_refused_data>:
}

/** Pass pcb->refused_data to the recv callback */
err_t
tcp_process_refused_data(struct tcp_pcb *pcb)
{
 800c45c:	b5b0      	push	{r4, r5, r7, lr}
 800c45e:	b084      	sub	sp, #16
 800c460:	af00      	add	r7, sp, #0
 800c462:	6078      	str	r0, [r7, #4]
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
  struct pbuf *rest;
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */

  LWIP_ERROR("tcp_process_refused_data: invalid pcb", pcb != NULL, return ERR_ARG);
 800c464:	687b      	ldr	r3, [r7, #4]
 800c466:	2b00      	cmp	r3, #0
 800c468:	d106      	bne.n	800c478 <tcp_process_refused_data+0x1c>
 800c46a:	4b3e      	ldr	r3, [pc, #248]	; (800c564 <tcp_process_refused_data+0x108>)
 800c46c:	0018      	movs	r0, r3
 800c46e:	f7f5 feb9 	bl	80021e4 <app_debug_rtt_raw>
 800c472:	2310      	movs	r3, #16
 800c474:	425b      	negs	r3, r3
 800c476:	e070      	b.n	800c55a <tcp_process_refused_data+0xfe>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
  while (pcb->refused_data != NULL)
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
  {
    err_t err;
    u8_t refused_flags = pcb->refused_data->flags;
 800c478:	687b      	ldr	r3, [r7, #4]
 800c47a:	6fda      	ldr	r2, [r3, #124]	; 0x7c
 800c47c:	230e      	movs	r3, #14
 800c47e:	18fb      	adds	r3, r7, r3
 800c480:	7b52      	ldrb	r2, [r2, #13]
 800c482:	701a      	strb	r2, [r3, #0]
    /* set pcb->refused_data to NULL in case the callback frees it and then
       closes the pcb */
    struct pbuf *refused_data = pcb->refused_data;
 800c484:	687b      	ldr	r3, [r7, #4]
 800c486:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800c488:	60bb      	str	r3, [r7, #8]
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
    pbuf_split_64k(refused_data, &rest);
    pcb->refused_data = rest;
#else /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
    pcb->refused_data = NULL;
 800c48a:	687b      	ldr	r3, [r7, #4]
 800c48c:	2200      	movs	r2, #0
 800c48e:	67da      	str	r2, [r3, #124]	; 0x7c
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
    /* Notify again application with data previously received. */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
    TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 800c490:	687b      	ldr	r3, [r7, #4]
 800c492:	2288      	movs	r2, #136	; 0x88
 800c494:	589b      	ldr	r3, [r3, r2]
 800c496:	2b00      	cmp	r3, #0
 800c498:	d00d      	beq.n	800c4b6 <tcp_process_refused_data+0x5a>
 800c49a:	687b      	ldr	r3, [r7, #4]
 800c49c:	2288      	movs	r2, #136	; 0x88
 800c49e:	589d      	ldr	r5, [r3, r2]
 800c4a0:	687b      	ldr	r3, [r7, #4]
 800c4a2:	6958      	ldr	r0, [r3, #20]
 800c4a4:	230f      	movs	r3, #15
 800c4a6:	18fc      	adds	r4, r7, r3
 800c4a8:	68ba      	ldr	r2, [r7, #8]
 800c4aa:	6879      	ldr	r1, [r7, #4]
 800c4ac:	2300      	movs	r3, #0
 800c4ae:	47a8      	blx	r5
 800c4b0:	0003      	movs	r3, r0
 800c4b2:	7023      	strb	r3, [r4, #0]
 800c4b4:	e009      	b.n	800c4ca <tcp_process_refused_data+0x6e>
 800c4b6:	230f      	movs	r3, #15
 800c4b8:	18fc      	adds	r4, r7, r3
 800c4ba:	68ba      	ldr	r2, [r7, #8]
 800c4bc:	6879      	ldr	r1, [r7, #4]
 800c4be:	2300      	movs	r3, #0
 800c4c0:	2000      	movs	r0, #0
 800c4c2:	f000 f8b1 	bl	800c628 <tcp_recv_null>
 800c4c6:	0003      	movs	r3, r0
 800c4c8:	7023      	strb	r3, [r4, #0]
    if (err == ERR_OK) {
 800c4ca:	230f      	movs	r3, #15
 800c4cc:	18fb      	adds	r3, r7, r3
 800c4ce:	781b      	ldrb	r3, [r3, #0]
 800c4d0:	b25b      	sxtb	r3, r3
 800c4d2:	2b00      	cmp	r3, #0
 800c4d4:	d131      	bne.n	800c53a <tcp_process_refused_data+0xde>
      /* did refused_data include a FIN? */
      if ((refused_flags & PBUF_FLAG_TCP_FIN)
 800c4d6:	230e      	movs	r3, #14
 800c4d8:	18fb      	adds	r3, r7, r3
 800c4da:	781b      	ldrb	r3, [r3, #0]
 800c4dc:	2220      	movs	r2, #32
 800c4de:	4013      	ands	r3, r2
 800c4e0:	d03a      	beq.n	800c558 <tcp_process_refused_data+0xfc>
          && (rest == NULL)
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
         ) {
        /* correct rcv_wnd as the application won't call tcp_recved()
           for the FIN's seqno */
        if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
 800c4e2:	687b      	ldr	r3, [r7, #4]
 800c4e4:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800c4e6:	2386      	movs	r3, #134	; 0x86
 800c4e8:	00db      	lsls	r3, r3, #3
 800c4ea:	429a      	cmp	r2, r3
 800c4ec:	d005      	beq.n	800c4fa <tcp_process_refused_data+0x9e>
          pcb->rcv_wnd++;
 800c4ee:	687b      	ldr	r3, [r7, #4]
 800c4f0:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 800c4f2:	3301      	adds	r3, #1
 800c4f4:	b29a      	uxth	r2, r3
 800c4f6:	687b      	ldr	r3, [r7, #4]
 800c4f8:	859a      	strh	r2, [r3, #44]	; 0x2c
        }
        TCP_EVENT_CLOSED(pcb, err);
 800c4fa:	687b      	ldr	r3, [r7, #4]
 800c4fc:	2288      	movs	r2, #136	; 0x88
 800c4fe:	589b      	ldr	r3, [r3, r2]
 800c500:	2b00      	cmp	r3, #0
 800c502:	d00d      	beq.n	800c520 <tcp_process_refused_data+0xc4>
 800c504:	687b      	ldr	r3, [r7, #4]
 800c506:	2288      	movs	r2, #136	; 0x88
 800c508:	589d      	ldr	r5, [r3, r2]
 800c50a:	687b      	ldr	r3, [r7, #4]
 800c50c:	6958      	ldr	r0, [r3, #20]
 800c50e:	230f      	movs	r3, #15
 800c510:	18fc      	adds	r4, r7, r3
 800c512:	6879      	ldr	r1, [r7, #4]
 800c514:	2300      	movs	r3, #0
 800c516:	2200      	movs	r2, #0
 800c518:	47a8      	blx	r5
 800c51a:	0003      	movs	r3, r0
 800c51c:	7023      	strb	r3, [r4, #0]
 800c51e:	e003      	b.n	800c528 <tcp_process_refused_data+0xcc>
 800c520:	230f      	movs	r3, #15
 800c522:	18fb      	adds	r3, r7, r3
 800c524:	2200      	movs	r2, #0
 800c526:	701a      	strb	r2, [r3, #0]
        if (err == ERR_ABRT) {
 800c528:	230f      	movs	r3, #15
 800c52a:	18fb      	adds	r3, r7, r3
 800c52c:	781b      	ldrb	r3, [r3, #0]
 800c52e:	b25b      	sxtb	r3, r3
 800c530:	330d      	adds	r3, #13
 800c532:	d111      	bne.n	800c558 <tcp_process_refused_data+0xfc>
          return ERR_ABRT;
 800c534:	230d      	movs	r3, #13
 800c536:	425b      	negs	r3, r3
 800c538:	e00f      	b.n	800c55a <tcp_process_refused_data+0xfe>
        }
      }
    } else if (err == ERR_ABRT) {
 800c53a:	230f      	movs	r3, #15
 800c53c:	18fb      	adds	r3, r7, r3
 800c53e:	781b      	ldrb	r3, [r3, #0]
 800c540:	b25b      	sxtb	r3, r3
 800c542:	330d      	adds	r3, #13
 800c544:	d102      	bne.n	800c54c <tcp_process_refused_data+0xf0>
      /* if err == ERR_ABRT, 'pcb' is already deallocated */
      /* Drop incoming packets because pcb is "full" (only if the incoming
         segment contains data). */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
      return ERR_ABRT;
 800c546:	230d      	movs	r3, #13
 800c548:	425b      	negs	r3, r3
 800c54a:	e006      	b.n	800c55a <tcp_process_refused_data+0xfe>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
      if (rest != NULL) {
        pbuf_cat(refused_data, rest);
      }
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
      pcb->refused_data = refused_data;
 800c54c:	687b      	ldr	r3, [r7, #4]
 800c54e:	68ba      	ldr	r2, [r7, #8]
 800c550:	67da      	str	r2, [r3, #124]	; 0x7c
      return ERR_INPROGRESS;
 800c552:	2305      	movs	r3, #5
 800c554:	425b      	negs	r3, r3
 800c556:	e000      	b.n	800c55a <tcp_process_refused_data+0xfe>
    }
  }
  return ERR_OK;
 800c558:	2300      	movs	r3, #0
}
 800c55a:	0018      	movs	r0, r3
 800c55c:	46bd      	mov	sp, r7
 800c55e:	b004      	add	sp, #16
 800c560:	bdb0      	pop	{r4, r5, r7, pc}
 800c562:	46c0      	nop			; (mov r8, r8)
 800c564:	08020fb4 	.word	0x08020fb4

0800c568 <tcp_segs_free>:
 *
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
 800c568:	b580      	push	{r7, lr}
 800c56a:	b084      	sub	sp, #16
 800c56c:	af00      	add	r7, sp, #0
 800c56e:	6078      	str	r0, [r7, #4]
  while (seg != NULL) {
 800c570:	e008      	b.n	800c584 <tcp_segs_free+0x1c>
    struct tcp_seg *next = seg->next;
 800c572:	687b      	ldr	r3, [r7, #4]
 800c574:	681b      	ldr	r3, [r3, #0]
 800c576:	60fb      	str	r3, [r7, #12]
    tcp_seg_free(seg);
 800c578:	687b      	ldr	r3, [r7, #4]
 800c57a:	0018      	movs	r0, r3
 800c57c:	f000 f80a 	bl	800c594 <tcp_seg_free>
    seg = next;
 800c580:	68fb      	ldr	r3, [r7, #12]
 800c582:	607b      	str	r3, [r7, #4]
  while (seg != NULL) {
 800c584:	687b      	ldr	r3, [r7, #4]
 800c586:	2b00      	cmp	r3, #0
 800c588:	d1f3      	bne.n	800c572 <tcp_segs_free+0xa>
  }
}
 800c58a:	46c0      	nop			; (mov r8, r8)
 800c58c:	46c0      	nop			; (mov r8, r8)
 800c58e:	46bd      	mov	sp, r7
 800c590:	b004      	add	sp, #16
 800c592:	bd80      	pop	{r7, pc}

0800c594 <tcp_seg_free>:
 *
 * @param seg single tcp_seg to free
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
 800c594:	b580      	push	{r7, lr}
 800c596:	b082      	sub	sp, #8
 800c598:	af00      	add	r7, sp, #0
 800c59a:	6078      	str	r0, [r7, #4]
  if (seg != NULL) {
 800c59c:	687b      	ldr	r3, [r7, #4]
 800c59e:	2b00      	cmp	r3, #0
 800c5a0:	d00d      	beq.n	800c5be <tcp_seg_free+0x2a>
    if (seg->p != NULL) {
 800c5a2:	687b      	ldr	r3, [r7, #4]
 800c5a4:	685b      	ldr	r3, [r3, #4]
 800c5a6:	2b00      	cmp	r3, #0
 800c5a8:	d004      	beq.n	800c5b4 <tcp_seg_free+0x20>
      pbuf_free(seg->p);
 800c5aa:	687b      	ldr	r3, [r7, #4]
 800c5ac:	685b      	ldr	r3, [r3, #4]
 800c5ae:	0018      	movs	r0, r3
 800c5b0:	f7fd ff94 	bl	800a4dc <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 800c5b4:	687b      	ldr	r3, [r7, #4]
 800c5b6:	0019      	movs	r1, r3
 800c5b8:	2003      	movs	r0, #3
 800c5ba:	f7fd f8db 	bl	8009774 <memp_free>
  }
}
 800c5be:	46c0      	nop			; (mov r8, r8)
 800c5c0:	46bd      	mov	sp, r7
 800c5c2:	b002      	add	sp, #8
 800c5c4:	bd80      	pop	{r7, pc}
	...

0800c5c8 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
 800c5c8:	b580      	push	{r7, lr}
 800c5ca:	b084      	sub	sp, #16
 800c5cc:	af00      	add	r7, sp, #0
 800c5ce:	6078      	str	r0, [r7, #4]
  struct tcp_seg *cseg;

  LWIP_ASSERT("tcp_seg_copy: invalid seg", seg != NULL);
 800c5d0:	687b      	ldr	r3, [r7, #4]
 800c5d2:	2b00      	cmp	r3, #0
 800c5d4:	d105      	bne.n	800c5e2 <tcp_seg_copy+0x1a>
 800c5d6:	4b10      	ldr	r3, [pc, #64]	; (800c618 <tcp_seg_copy+0x50>)
 800c5d8:	4a10      	ldr	r2, [pc, #64]	; (800c61c <tcp_seg_copy+0x54>)
 800c5da:	4911      	ldr	r1, [pc, #68]	; (800c620 <tcp_seg_copy+0x58>)
 800c5dc:	4811      	ldr	r0, [pc, #68]	; (800c624 <tcp_seg_copy+0x5c>)
 800c5de:	f7f5 fe01 	bl	80021e4 <app_debug_rtt_raw>

  cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
 800c5e2:	2003      	movs	r0, #3
 800c5e4:	f7fd f856 	bl	8009694 <memp_malloc>
 800c5e8:	0003      	movs	r3, r0
 800c5ea:	60fb      	str	r3, [r7, #12]
  if (cseg == NULL) {
 800c5ec:	68fb      	ldr	r3, [r7, #12]
 800c5ee:	2b00      	cmp	r3, #0
 800c5f0:	d101      	bne.n	800c5f6 <tcp_seg_copy+0x2e>
    return NULL;
 800c5f2:	2300      	movs	r3, #0
 800c5f4:	e00b      	b.n	800c60e <tcp_seg_copy+0x46>
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg));
 800c5f6:	6879      	ldr	r1, [r7, #4]
 800c5f8:	68fb      	ldr	r3, [r7, #12]
 800c5fa:	2214      	movs	r2, #20
 800c5fc:	0018      	movs	r0, r3
 800c5fe:	f011 fccd 	bl	801df9c <memcpy>
  pbuf_ref(cseg->p);
 800c602:	68fb      	ldr	r3, [r7, #12]
 800c604:	685b      	ldr	r3, [r3, #4]
 800c606:	0018      	movs	r0, r3
 800c608:	f7fe f824 	bl	800a654 <pbuf_ref>
  return cseg;
 800c60c:	68fb      	ldr	r3, [r7, #12]
}
 800c60e:	0018      	movs	r0, r3
 800c610:	46bd      	mov	sp, r7
 800c612:	b004      	add	sp, #16
 800c614:	bd80      	pop	{r7, pc}
 800c616:	46c0      	nop			; (mov r8, r8)
 800c618:	08020aa8 	.word	0x08020aa8
 800c61c:	00000683 	.word	0x00000683
 800c620:	08020ff8 	.word	0x08020ff8
 800c624:	08020ae4 	.word	0x08020ae4

0800c628 <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
 800c628:	b580      	push	{r7, lr}
 800c62a:	b084      	sub	sp, #16
 800c62c:	af00      	add	r7, sp, #0
 800c62e:	60f8      	str	r0, [r7, #12]
 800c630:	60b9      	str	r1, [r7, #8]
 800c632:	607a      	str	r2, [r7, #4]
 800c634:	001a      	movs	r2, r3
 800c636:	1cfb      	adds	r3, r7, #3
 800c638:	701a      	strb	r2, [r3, #0]
  LWIP_UNUSED_ARG(arg);

  LWIP_ERROR("tcp_recv_null: invalid pcb", pcb != NULL, return ERR_ARG);
 800c63a:	68bb      	ldr	r3, [r7, #8]
 800c63c:	2b00      	cmp	r3, #0
 800c63e:	d106      	bne.n	800c64e <tcp_recv_null+0x26>
 800c640:	4b12      	ldr	r3, [pc, #72]	; (800c68c <tcp_recv_null+0x64>)
 800c642:	0018      	movs	r0, r3
 800c644:	f7f5 fdce 	bl	80021e4 <app_debug_rtt_raw>
 800c648:	2310      	movs	r3, #16
 800c64a:	425b      	negs	r3, r3
 800c64c:	e01a      	b.n	800c684 <tcp_recv_null+0x5c>

  if (p != NULL) {
 800c64e:	687b      	ldr	r3, [r7, #4]
 800c650:	2b00      	cmp	r3, #0
 800c652:	d00b      	beq.n	800c66c <tcp_recv_null+0x44>
    tcp_recved(pcb, p->tot_len);
 800c654:	687b      	ldr	r3, [r7, #4]
 800c656:	891a      	ldrh	r2, [r3, #8]
 800c658:	68bb      	ldr	r3, [r7, #8]
 800c65a:	0011      	movs	r1, r2
 800c65c:	0018      	movs	r0, r3
 800c65e:	f7ff f907 	bl	800b870 <tcp_recved>
    pbuf_free(p);
 800c662:	687b      	ldr	r3, [r7, #4]
 800c664:	0018      	movs	r0, r3
 800c666:	f7fd ff39 	bl	800a4dc <pbuf_free>
 800c66a:	e00a      	b.n	800c682 <tcp_recv_null+0x5a>
  } else if (err == ERR_OK) {
 800c66c:	1cfb      	adds	r3, r7, #3
 800c66e:	781b      	ldrb	r3, [r3, #0]
 800c670:	b25b      	sxtb	r3, r3
 800c672:	2b00      	cmp	r3, #0
 800c674:	d105      	bne.n	800c682 <tcp_recv_null+0x5a>
    return tcp_close(pcb);
 800c676:	68bb      	ldr	r3, [r7, #8]
 800c678:	0018      	movs	r0, r3
 800c67a:	f7fe fef3 	bl	800b464 <tcp_close>
 800c67e:	0003      	movs	r3, r0
 800c680:	e000      	b.n	800c684 <tcp_recv_null+0x5c>
  }
  return ERR_OK;
 800c682:	2300      	movs	r3, #0
}
 800c684:	0018      	movs	r0, r3
 800c686:	46bd      	mov	sp, r7
 800c688:	b004      	add	sp, #16
 800c68a:	bd80      	pop	{r7, pc}
 800c68c:	08021014 	.word	0x08021014

0800c690 <tcp_kill_prio>:
 *
 * @param prio minimum priority
 */
static void
tcp_kill_prio(u8_t prio)
{
 800c690:	b580      	push	{r7, lr}
 800c692:	b086      	sub	sp, #24
 800c694:	af00      	add	r7, sp, #0
 800c696:	0002      	movs	r2, r0
 800c698:	1dfb      	adds	r3, r7, #7
 800c69a:	701a      	strb	r2, [r3, #0]
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;

  mprio = LWIP_MIN(TCP_PRIO_MAX, prio);
 800c69c:	1dfb      	adds	r3, r7, #7
 800c69e:	781b      	ldrb	r3, [r3, #0]
 800c6a0:	b25b      	sxtb	r3, r3
 800c6a2:	2b00      	cmp	r3, #0
 800c6a4:	db02      	blt.n	800c6ac <tcp_kill_prio+0x1c>
 800c6a6:	1dfb      	adds	r3, r7, #7
 800c6a8:	781a      	ldrb	r2, [r3, #0]
 800c6aa:	e000      	b.n	800c6ae <tcp_kill_prio+0x1e>
 800c6ac:	227f      	movs	r2, #127	; 0x7f
 800c6ae:	210b      	movs	r1, #11
 800c6b0:	187b      	adds	r3, r7, r1
 800c6b2:	701a      	strb	r2, [r3, #0]

  /* We want to kill connections with a lower prio, so bail out if 
   * supplied prio is 0 - there can never be a lower prio
   */
  if (mprio == 0) {
 800c6b4:	187b      	adds	r3, r7, r1
 800c6b6:	781b      	ldrb	r3, [r3, #0]
 800c6b8:	2b00      	cmp	r3, #0
 800c6ba:	d03c      	beq.n	800c736 <tcp_kill_prio+0xa6>
  /* We only want kill connections with a lower prio, so decrement prio by one 
   * and start searching for oldest connection with same or lower priority than mprio.
   * We want to find the connections with the lowest possible prio, and among
   * these the one with the longest inactivity time.
   */
  mprio--;
 800c6bc:	187b      	adds	r3, r7, r1
 800c6be:	781a      	ldrb	r2, [r3, #0]
 800c6c0:	187b      	adds	r3, r7, r1
 800c6c2:	3a01      	subs	r2, #1
 800c6c4:	701a      	strb	r2, [r3, #0]

  inactivity = 0;
 800c6c6:	2300      	movs	r3, #0
 800c6c8:	60fb      	str	r3, [r7, #12]
  inactive = NULL;
 800c6ca:	2300      	movs	r3, #0
 800c6cc:	613b      	str	r3, [r7, #16]
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800c6ce:	4b1c      	ldr	r3, [pc, #112]	; (800c740 <tcp_kill_prio+0xb0>)
 800c6d0:	681b      	ldr	r3, [r3, #0]
 800c6d2:	617b      	str	r3, [r7, #20]
 800c6d4:	e024      	b.n	800c720 <tcp_kill_prio+0x90>
        /* lower prio is always a kill candidate */
    if ((pcb->prio < mprio) ||
 800c6d6:	697b      	ldr	r3, [r7, #20]
 800c6d8:	7e5b      	ldrb	r3, [r3, #25]
 800c6da:	210b      	movs	r1, #11
 800c6dc:	187a      	adds	r2, r7, r1
 800c6de:	7812      	ldrb	r2, [r2, #0]
 800c6e0:	429a      	cmp	r2, r3
 800c6e2:	d80d      	bhi.n	800c700 <tcp_kill_prio+0x70>
        /* longer inactivity is also a kill candidate */
        ((pcb->prio == mprio) && ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity))) {
 800c6e4:	697b      	ldr	r3, [r7, #20]
 800c6e6:	7e5b      	ldrb	r3, [r3, #25]
    if ((pcb->prio < mprio) ||
 800c6e8:	187a      	adds	r2, r7, r1
 800c6ea:	7812      	ldrb	r2, [r2, #0]
 800c6ec:	429a      	cmp	r2, r3
 800c6ee:	d114      	bne.n	800c71a <tcp_kill_prio+0x8a>
        ((pcb->prio == mprio) && ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity))) {
 800c6f0:	4b14      	ldr	r3, [pc, #80]	; (800c744 <tcp_kill_prio+0xb4>)
 800c6f2:	681a      	ldr	r2, [r3, #0]
 800c6f4:	697b      	ldr	r3, [r7, #20]
 800c6f6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c6f8:	1ad3      	subs	r3, r2, r3
 800c6fa:	68fa      	ldr	r2, [r7, #12]
 800c6fc:	429a      	cmp	r2, r3
 800c6fe:	d80c      	bhi.n	800c71a <tcp_kill_prio+0x8a>
      inactivity = tcp_ticks - pcb->tmr;
 800c700:	4b10      	ldr	r3, [pc, #64]	; (800c744 <tcp_kill_prio+0xb4>)
 800c702:	681a      	ldr	r2, [r3, #0]
 800c704:	697b      	ldr	r3, [r7, #20]
 800c706:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c708:	1ad3      	subs	r3, r2, r3
 800c70a:	60fb      	str	r3, [r7, #12]
      inactive   = pcb;
 800c70c:	697b      	ldr	r3, [r7, #20]
 800c70e:	613b      	str	r3, [r7, #16]
      mprio      = pcb->prio;
 800c710:	230b      	movs	r3, #11
 800c712:	18fb      	adds	r3, r7, r3
 800c714:	697a      	ldr	r2, [r7, #20]
 800c716:	7e52      	ldrb	r2, [r2, #25]
 800c718:	701a      	strb	r2, [r3, #0]
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800c71a:	697b      	ldr	r3, [r7, #20]
 800c71c:	691b      	ldr	r3, [r3, #16]
 800c71e:	617b      	str	r3, [r7, #20]
 800c720:	697b      	ldr	r3, [r7, #20]
 800c722:	2b00      	cmp	r3, #0
 800c724:	d1d7      	bne.n	800c6d6 <tcp_kill_prio+0x46>
    }
  }
  if (inactive != NULL) {
 800c726:	693b      	ldr	r3, [r7, #16]
 800c728:	2b00      	cmp	r3, #0
 800c72a:	d005      	beq.n	800c738 <tcp_kill_prio+0xa8>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
                            (void *)inactive, inactivity));
    tcp_abort(inactive);
 800c72c:	693b      	ldr	r3, [r7, #16]
 800c72e:	0018      	movs	r0, r3
 800c730:	f7fe ff88 	bl	800b644 <tcp_abort>
 800c734:	e000      	b.n	800c738 <tcp_kill_prio+0xa8>
    return;
 800c736:	46c0      	nop			; (mov r8, r8)
  }
}
 800c738:	46bd      	mov	sp, r7
 800c73a:	b006      	add	sp, #24
 800c73c:	bd80      	pop	{r7, pc}
 800c73e:	46c0      	nop			; (mov r8, r8)
 800c740:	2000278c 	.word	0x2000278c
 800c744:	20002790 	.word	0x20002790

0800c748 <tcp_kill_state>:
 * Kills the oldest connection that is in specific state.
 * Called from tcp_alloc() for LAST_ACK and CLOSING if no more connections are available.
 */
static void
tcp_kill_state(enum tcp_state state)
{
 800c748:	b580      	push	{r7, lr}
 800c74a:	b086      	sub	sp, #24
 800c74c:	af00      	add	r7, sp, #0
 800c74e:	0002      	movs	r2, r0
 800c750:	1dfb      	adds	r3, r7, #7
 800c752:	701a      	strb	r2, [r3, #0]
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  LWIP_ASSERT("invalid state", (state == CLOSING) || (state == LAST_ACK));
 800c754:	1dfb      	adds	r3, r7, #7
 800c756:	781b      	ldrb	r3, [r3, #0]
 800c758:	2b08      	cmp	r3, #8
 800c75a:	d009      	beq.n	800c770 <tcp_kill_state+0x28>
 800c75c:	1dfb      	adds	r3, r7, #7
 800c75e:	781b      	ldrb	r3, [r3, #0]
 800c760:	2b09      	cmp	r3, #9
 800c762:	d005      	beq.n	800c770 <tcp_kill_state+0x28>
 800c764:	4b1a      	ldr	r3, [pc, #104]	; (800c7d0 <tcp_kill_state+0x88>)
 800c766:	4a1b      	ldr	r2, [pc, #108]	; (800c7d4 <tcp_kill_state+0x8c>)
 800c768:	491b      	ldr	r1, [pc, #108]	; (800c7d8 <tcp_kill_state+0x90>)
 800c76a:	481c      	ldr	r0, [pc, #112]	; (800c7dc <tcp_kill_state+0x94>)
 800c76c:	f7f5 fd3a 	bl	80021e4 <app_debug_rtt_raw>

  inactivity = 0;
 800c770:	2300      	movs	r3, #0
 800c772:	60fb      	str	r3, [r7, #12]
  inactive = NULL;
 800c774:	2300      	movs	r3, #0
 800c776:	613b      	str	r3, [r7, #16]
  /* Go through the list of active pcbs and get the oldest pcb that is in state
     CLOSING/LAST_ACK. */
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800c778:	4b19      	ldr	r3, [pc, #100]	; (800c7e0 <tcp_kill_state+0x98>)
 800c77a:	681b      	ldr	r3, [r3, #0]
 800c77c:	617b      	str	r3, [r7, #20]
 800c77e:	e018      	b.n	800c7b2 <tcp_kill_state+0x6a>
    if (pcb->state == state) {
 800c780:	697b      	ldr	r3, [r7, #20]
 800c782:	7e1b      	ldrb	r3, [r3, #24]
 800c784:	1dfa      	adds	r2, r7, #7
 800c786:	7812      	ldrb	r2, [r2, #0]
 800c788:	429a      	cmp	r2, r3
 800c78a:	d10f      	bne.n	800c7ac <tcp_kill_state+0x64>
      if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 800c78c:	4b15      	ldr	r3, [pc, #84]	; (800c7e4 <tcp_kill_state+0x9c>)
 800c78e:	681a      	ldr	r2, [r3, #0]
 800c790:	697b      	ldr	r3, [r7, #20]
 800c792:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c794:	1ad3      	subs	r3, r2, r3
 800c796:	68fa      	ldr	r2, [r7, #12]
 800c798:	429a      	cmp	r2, r3
 800c79a:	d807      	bhi.n	800c7ac <tcp_kill_state+0x64>
        inactivity = tcp_ticks - pcb->tmr;
 800c79c:	4b11      	ldr	r3, [pc, #68]	; (800c7e4 <tcp_kill_state+0x9c>)
 800c79e:	681a      	ldr	r2, [r3, #0]
 800c7a0:	697b      	ldr	r3, [r7, #20]
 800c7a2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c7a4:	1ad3      	subs	r3, r2, r3
 800c7a6:	60fb      	str	r3, [r7, #12]
        inactive = pcb;
 800c7a8:	697b      	ldr	r3, [r7, #20]
 800c7aa:	613b      	str	r3, [r7, #16]
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800c7ac:	697b      	ldr	r3, [r7, #20]
 800c7ae:	691b      	ldr	r3, [r3, #16]
 800c7b0:	617b      	str	r3, [r7, #20]
 800c7b2:	697b      	ldr	r3, [r7, #20]
 800c7b4:	2b00      	cmp	r3, #0
 800c7b6:	d1e3      	bne.n	800c780 <tcp_kill_state+0x38>
      }
    }
  }
  if (inactive != NULL) {
 800c7b8:	693b      	ldr	r3, [r7, #16]
 800c7ba:	2b00      	cmp	r3, #0
 800c7bc:	d004      	beq.n	800c7c8 <tcp_kill_state+0x80>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_closing: killing oldest %s PCB %p (%"S32_F")\n",
                            tcp_state_str[state], (void *)inactive, inactivity));
    /* Don't send a RST, since no data is lost. */
    tcp_abandon(inactive, 0);
 800c7be:	693b      	ldr	r3, [r7, #16]
 800c7c0:	2100      	movs	r1, #0
 800c7c2:	0018      	movs	r0, r3
 800c7c4:	f7fe fe74 	bl	800b4b0 <tcp_abandon>
  }
}
 800c7c8:	46c0      	nop			; (mov r8, r8)
 800c7ca:	46bd      	mov	sp, r7
 800c7cc:	b006      	add	sp, #24
 800c7ce:	bd80      	pop	{r7, pc}
 800c7d0:	08020aa8 	.word	0x08020aa8
 800c7d4:	000006de 	.word	0x000006de
 800c7d8:	08021030 	.word	0x08021030
 800c7dc:	08020ae4 	.word	0x08020ae4
 800c7e0:	2000278c 	.word	0x2000278c
 800c7e4:	20002790 	.word	0x20002790

0800c7e8 <tcp_kill_timewait>:
 * Kills the oldest connection that is in TIME_WAIT state.
 * Called from tcp_alloc() if no more connections are available.
 */
static void
tcp_kill_timewait(void)
{
 800c7e8:	b580      	push	{r7, lr}
 800c7ea:	b084      	sub	sp, #16
 800c7ec:	af00      	add	r7, sp, #0
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
 800c7ee:	2300      	movs	r3, #0
 800c7f0:	607b      	str	r3, [r7, #4]
  inactive = NULL;
 800c7f2:	2300      	movs	r3, #0
 800c7f4:	60bb      	str	r3, [r7, #8]
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800c7f6:	4b12      	ldr	r3, [pc, #72]	; (800c840 <tcp_kill_timewait+0x58>)
 800c7f8:	681b      	ldr	r3, [r3, #0]
 800c7fa:	60fb      	str	r3, [r7, #12]
 800c7fc:	e012      	b.n	800c824 <tcp_kill_timewait+0x3c>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 800c7fe:	4b11      	ldr	r3, [pc, #68]	; (800c844 <tcp_kill_timewait+0x5c>)
 800c800:	681a      	ldr	r2, [r3, #0]
 800c802:	68fb      	ldr	r3, [r7, #12]
 800c804:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c806:	1ad3      	subs	r3, r2, r3
 800c808:	687a      	ldr	r2, [r7, #4]
 800c80a:	429a      	cmp	r2, r3
 800c80c:	d807      	bhi.n	800c81e <tcp_kill_timewait+0x36>
      inactivity = tcp_ticks - pcb->tmr;
 800c80e:	4b0d      	ldr	r3, [pc, #52]	; (800c844 <tcp_kill_timewait+0x5c>)
 800c810:	681a      	ldr	r2, [r3, #0]
 800c812:	68fb      	ldr	r3, [r7, #12]
 800c814:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c816:	1ad3      	subs	r3, r2, r3
 800c818:	607b      	str	r3, [r7, #4]
      inactive = pcb;
 800c81a:	68fb      	ldr	r3, [r7, #12]
 800c81c:	60bb      	str	r3, [r7, #8]
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800c81e:	68fb      	ldr	r3, [r7, #12]
 800c820:	691b      	ldr	r3, [r3, #16]
 800c822:	60fb      	str	r3, [r7, #12]
 800c824:	68fb      	ldr	r3, [r7, #12]
 800c826:	2b00      	cmp	r3, #0
 800c828:	d1e9      	bne.n	800c7fe <tcp_kill_timewait+0x16>
    }
  }
  if (inactive != NULL) {
 800c82a:	68bb      	ldr	r3, [r7, #8]
 800c82c:	2b00      	cmp	r3, #0
 800c82e:	d003      	beq.n	800c838 <tcp_kill_timewait+0x50>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
                            (void *)inactive, inactivity));
    tcp_abort(inactive);
 800c830:	68bb      	ldr	r3, [r7, #8]
 800c832:	0018      	movs	r0, r3
 800c834:	f7fe ff06 	bl	800b644 <tcp_abort>
  }
}
 800c838:	46c0      	nop			; (mov r8, r8)
 800c83a:	46bd      	mov	sp, r7
 800c83c:	b004      	add	sp, #16
 800c83e:	bd80      	pop	{r7, pc}
 800c840:	2000279c 	.word	0x2000279c
 800c844:	20002790 	.word	0x20002790

0800c848 <tcp_handle_closepend>:
 * now send the FIN (which failed before), the pcb might be in a state that is
 * OK for us to now free it.
 */
static void
tcp_handle_closepend(void)
{
 800c848:	b580      	push	{r7, lr}
 800c84a:	b082      	sub	sp, #8
 800c84c:	af00      	add	r7, sp, #0
  struct tcp_pcb *pcb = tcp_active_pcbs;
 800c84e:	4b11      	ldr	r3, [pc, #68]	; (800c894 <tcp_handle_closepend+0x4c>)
 800c850:	681b      	ldr	r3, [r3, #0]
 800c852:	607b      	str	r3, [r7, #4]

  while (pcb != NULL) {
 800c854:	e015      	b.n	800c882 <tcp_handle_closepend+0x3a>
    struct tcp_pcb *next = pcb->next;
 800c856:	687b      	ldr	r3, [r7, #4]
 800c858:	691b      	ldr	r3, [r3, #16]
 800c85a:	603b      	str	r3, [r7, #0]
    /* send pending FIN */
    if (pcb->flags & TF_CLOSEPEND) {
 800c85c:	687b      	ldr	r3, [r7, #4]
 800c85e:	8bdb      	ldrh	r3, [r3, #30]
 800c860:	001a      	movs	r2, r3
 800c862:	2308      	movs	r3, #8
 800c864:	4013      	ands	r3, r2
 800c866:	d00a      	beq.n	800c87e <tcp_handle_closepend+0x36>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_handle_closepend: pending FIN\n"));
      tcp_clear_flags(pcb, TF_CLOSEPEND);
 800c868:	687b      	ldr	r3, [r7, #4]
 800c86a:	8bdb      	ldrh	r3, [r3, #30]
 800c86c:	2208      	movs	r2, #8
 800c86e:	4393      	bics	r3, r2
 800c870:	b29a      	uxth	r2, r3
 800c872:	687b      	ldr	r3, [r7, #4]
 800c874:	83da      	strh	r2, [r3, #30]
      tcp_close_shutdown_fin(pcb);
 800c876:	687b      	ldr	r3, [r7, #4]
 800c878:	0018      	movs	r0, r3
 800c87a:	f7fe fd79 	bl	800b370 <tcp_close_shutdown_fin>
    }
    pcb = next;
 800c87e:	683b      	ldr	r3, [r7, #0]
 800c880:	607b      	str	r3, [r7, #4]
  while (pcb != NULL) {
 800c882:	687b      	ldr	r3, [r7, #4]
 800c884:	2b00      	cmp	r3, #0
 800c886:	d1e6      	bne.n	800c856 <tcp_handle_closepend+0xe>
  }
}
 800c888:	46c0      	nop			; (mov r8, r8)
 800c88a:	46c0      	nop			; (mov r8, r8)
 800c88c:	46bd      	mov	sp, r7
 800c88e:	b002      	add	sp, #8
 800c890:	bd80      	pop	{r7, pc}
 800c892:	46c0      	nop			; (mov r8, r8)
 800c894:	2000278c 	.word	0x2000278c

0800c898 <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
 800c898:	b580      	push	{r7, lr}
 800c89a:	b084      	sub	sp, #16
 800c89c:	af00      	add	r7, sp, #0
 800c89e:	0002      	movs	r2, r0
 800c8a0:	1dfb      	adds	r3, r7, #7
 800c8a2:	701a      	strb	r2, [r3, #0]
  struct tcp_pcb *pcb;

  LWIP_ASSERT_CORE_LOCKED();

  pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800c8a4:	2001      	movs	r0, #1
 800c8a6:	f7fc fef5 	bl	8009694 <memp_malloc>
 800c8aa:	0003      	movs	r3, r0
 800c8ac:	60fb      	str	r3, [r7, #12]
  if (pcb == NULL) {
 800c8ae:	68fb      	ldr	r3, [r7, #12]
 800c8b0:	2b00      	cmp	r3, #0
 800c8b2:	d12b      	bne.n	800c90c <tcp_alloc+0x74>
    /* Try to send FIN for all pcbs stuck in TF_CLOSEPEND first */
    tcp_handle_closepend();
 800c8b4:	f7ff ffc8 	bl	800c848 <tcp_handle_closepend>

    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
 800c8b8:	f7ff ff96 	bl	800c7e8 <tcp_kill_timewait>
    /* Try to allocate a tcp_pcb again. */
    pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800c8bc:	2001      	movs	r0, #1
 800c8be:	f7fc fee9 	bl	8009694 <memp_malloc>
 800c8c2:	0003      	movs	r3, r0
 800c8c4:	60fb      	str	r3, [r7, #12]
    if (pcb == NULL) {
 800c8c6:	68fb      	ldr	r3, [r7, #12]
 800c8c8:	2b00      	cmp	r3, #0
 800c8ca:	d11f      	bne.n	800c90c <tcp_alloc+0x74>
      /* Try killing oldest connection in LAST-ACK (these wouldn't go to TIME-WAIT). */
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest LAST-ACK connection\n"));
      tcp_kill_state(LAST_ACK);
 800c8cc:	2009      	movs	r0, #9
 800c8ce:	f7ff ff3b 	bl	800c748 <tcp_kill_state>
      /* Try to allocate a tcp_pcb again. */
      pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800c8d2:	2001      	movs	r0, #1
 800c8d4:	f7fc fede 	bl	8009694 <memp_malloc>
 800c8d8:	0003      	movs	r3, r0
 800c8da:	60fb      	str	r3, [r7, #12]
      if (pcb == NULL) {
 800c8dc:	68fb      	ldr	r3, [r7, #12]
 800c8de:	2b00      	cmp	r3, #0
 800c8e0:	d114      	bne.n	800c90c <tcp_alloc+0x74>
        /* Try killing oldest connection in CLOSING. */
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest CLOSING connection\n"));
        tcp_kill_state(CLOSING);
 800c8e2:	2008      	movs	r0, #8
 800c8e4:	f7ff ff30 	bl	800c748 <tcp_kill_state>
        /* Try to allocate a tcp_pcb again. */
        pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800c8e8:	2001      	movs	r0, #1
 800c8ea:	f7fc fed3 	bl	8009694 <memp_malloc>
 800c8ee:	0003      	movs	r3, r0
 800c8f0:	60fb      	str	r3, [r7, #12]
        if (pcb == NULL) {
 800c8f2:	68fb      	ldr	r3, [r7, #12]
 800c8f4:	2b00      	cmp	r3, #0
 800c8f6:	d109      	bne.n	800c90c <tcp_alloc+0x74>
          /* Try killing oldest active connection with lower priority than the new one. */
          LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing oldest connection with prio lower than %d\n", prio));
          tcp_kill_prio(prio);
 800c8f8:	1dfb      	adds	r3, r7, #7
 800c8fa:	781b      	ldrb	r3, [r3, #0]
 800c8fc:	0018      	movs	r0, r3
 800c8fe:	f7ff fec7 	bl	800c690 <tcp_kill_prio>
          /* Try to allocate a tcp_pcb again. */
          pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800c902:	2001      	movs	r0, #1
 800c904:	f7fc fec6 	bl	8009694 <memp_malloc>
 800c908:	0003      	movs	r3, r0
 800c90a:	60fb      	str	r3, [r7, #12]
    if (pcb != NULL) {
      /* adjust err stats: memp_malloc failed above */
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
    }
  }
  if (pcb != NULL) {
 800c90c:	68fb      	ldr	r3, [r7, #12]
 800c90e:	2b00      	cmp	r3, #0
 800c910:	d04c      	beq.n	800c9ac <tcp_alloc+0x114>
    /* zero out the whole pcb, so there is no need to initialize members to zero */
    memset(pcb, 0, sizeof(struct tcp_pcb));
 800c912:	68fb      	ldr	r3, [r7, #12]
 800c914:	22a8      	movs	r2, #168	; 0xa8
 800c916:	2100      	movs	r1, #0
 800c918:	0018      	movs	r0, r3
 800c91a:	f011 fb5b 	bl	801dfd4 <memset>
    pcb->prio = prio;
 800c91e:	68fb      	ldr	r3, [r7, #12]
 800c920:	1dfa      	adds	r2, r7, #7
 800c922:	7812      	ldrb	r2, [r2, #0]
 800c924:	765a      	strb	r2, [r3, #25]
    pcb->snd_buf = TCP_SND_BUF;
 800c926:	68fb      	ldr	r3, [r7, #12]
 800c928:	2268      	movs	r2, #104	; 0x68
 800c92a:	2186      	movs	r1, #134	; 0x86
 800c92c:	00c9      	lsls	r1, r1, #3
 800c92e:	5299      	strh	r1, [r3, r2]
    /* Start with a window that does not need scaling. When window scaling is
       enabled and used, the window is enlarged when both sides agree on scaling. */
    pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
 800c930:	68fb      	ldr	r3, [r7, #12]
 800c932:	2286      	movs	r2, #134	; 0x86
 800c934:	00d2      	lsls	r2, r2, #3
 800c936:	85da      	strh	r2, [r3, #46]	; 0x2e
 800c938:	68fb      	ldr	r3, [r7, #12]
 800c93a:	8dda      	ldrh	r2, [r3, #46]	; 0x2e
 800c93c:	68fb      	ldr	r3, [r7, #12]
 800c93e:	859a      	strh	r2, [r3, #44]	; 0x2c
    pcb->ttl = TCP_TTL;
 800c940:	68fb      	ldr	r3, [r7, #12]
 800c942:	22ff      	movs	r2, #255	; 0xff
 800c944:	72da      	strb	r2, [r3, #11]
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = INITIAL_MSS;
 800c946:	68fb      	ldr	r3, [r7, #12]
 800c948:	2286      	movs	r2, #134	; 0x86
 800c94a:	0092      	lsls	r2, r2, #2
 800c94c:	86da      	strh	r2, [r3, #54]	; 0x36
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
 800c94e:	68fb      	ldr	r3, [r7, #12]
 800c950:	2244      	movs	r2, #68	; 0x44
 800c952:	2103      	movs	r1, #3
 800c954:	5299      	strh	r1, [r3, r2]
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
 800c956:	68fb      	ldr	r3, [r7, #12]
 800c958:	2242      	movs	r2, #66	; 0x42
 800c95a:	2103      	movs	r1, #3
 800c95c:	5299      	strh	r1, [r3, r2]
    pcb->rtime = -1;
 800c95e:	68fb      	ldr	r3, [r7, #12]
 800c960:	2201      	movs	r2, #1
 800c962:	4252      	negs	r2, r2
 800c964:	869a      	strh	r2, [r3, #52]	; 0x34
    pcb->cwnd = 1;
 800c966:	68fb      	ldr	r3, [r7, #12]
 800c968:	224c      	movs	r2, #76	; 0x4c
 800c96a:	2101      	movs	r1, #1
 800c96c:	5299      	strh	r1, [r3, r2]
    pcb->tmr = tcp_ticks;
 800c96e:	4b12      	ldr	r3, [pc, #72]	; (800c9b8 <tcp_alloc+0x120>)
 800c970:	681a      	ldr	r2, [r3, #0]
 800c972:	68fb      	ldr	r3, [r7, #12]
 800c974:	625a      	str	r2, [r3, #36]	; 0x24
    pcb->last_timer = tcp_timer_ctr;
 800c976:	4b11      	ldr	r3, [pc, #68]	; (800c9bc <tcp_alloc+0x124>)
 800c978:	7819      	ldrb	r1, [r3, #0]
 800c97a:	68fb      	ldr	r3, [r7, #12]
 800c97c:	2222      	movs	r2, #34	; 0x22
 800c97e:	5499      	strb	r1, [r3, r2]
    of using the largest advertised receive window.  We've seen complications with
    receiving TCPs that use window scaling and/or window auto-tuning where the
    initial advertised window is very small and then grows rapidly once the
    connection is established. To avoid these complications, we set ssthresh to the
    largest effective cwnd (amount of in-flight data) that the sender can have. */
    pcb->ssthresh = TCP_SND_BUF;
 800c980:	68fb      	ldr	r3, [r7, #12]
 800c982:	224e      	movs	r2, #78	; 0x4e
 800c984:	2186      	movs	r1, #134	; 0x86
 800c986:	00c9      	lsls	r1, r1, #3
 800c988:	5299      	strh	r1, [r3, r2]

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
 800c98a:	68fb      	ldr	r3, [r7, #12]
 800c98c:	2188      	movs	r1, #136	; 0x88
 800c98e:	4a0c      	ldr	r2, [pc, #48]	; (800c9c0 <tcp_alloc+0x128>)
 800c990:	505a      	str	r2, [r3, r1]
#endif /* LWIP_CALLBACK_API */

    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
 800c992:	68fb      	ldr	r3, [r7, #12]
 800c994:	2298      	movs	r2, #152	; 0x98
 800c996:	490b      	ldr	r1, [pc, #44]	; (800c9c4 <tcp_alloc+0x12c>)
 800c998:	5099      	str	r1, [r3, r2]

#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
 800c99a:	68fb      	ldr	r3, [r7, #12]
 800c99c:	219c      	movs	r1, #156	; 0x9c
 800c99e:	22fa      	movs	r2, #250	; 0xfa
 800c9a0:	00d2      	lsls	r2, r2, #3
 800c9a2:	505a      	str	r2, [r3, r1]
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
 800c9a4:	68fb      	ldr	r3, [r7, #12]
 800c9a6:	22a0      	movs	r2, #160	; 0xa0
 800c9a8:	2109      	movs	r1, #9
 800c9aa:	5099      	str	r1, [r3, r2]
#endif /* LWIP_TCP_KEEPALIVE */
  }
  return pcb;
 800c9ac:	68fb      	ldr	r3, [r7, #12]
}
 800c9ae:	0018      	movs	r0, r3
 800c9b0:	46bd      	mov	sp, r7
 800c9b2:	b004      	add	sp, #16
 800c9b4:	bd80      	pop	{r7, pc}
 800c9b6:	46c0      	nop			; (mov r8, r8)
 800c9b8:	20002790 	.word	0x20002790
 800c9bc:	20000c46 	.word	0x20000c46
 800c9c0:	0800c629 	.word	0x0800c629
 800c9c4:	00002710 	.word	0x00002710

0800c9c8 <tcp_new_ip_type>:
 * supply @ref IPADDR_TYPE_ANY as argument and bind to @ref IP_ANY_TYPE.
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new_ip_type(u8_t type)
{
 800c9c8:	b580      	push	{r7, lr}
 800c9ca:	b084      	sub	sp, #16
 800c9cc:	af00      	add	r7, sp, #0
 800c9ce:	0002      	movs	r2, r0
 800c9d0:	1dfb      	adds	r3, r7, #7
 800c9d2:	701a      	strb	r2, [r3, #0]
  struct tcp_pcb *pcb;
  pcb = tcp_alloc(TCP_PRIO_NORMAL);
 800c9d4:	2040      	movs	r0, #64	; 0x40
 800c9d6:	f7ff ff5f 	bl	800c898 <tcp_alloc>
 800c9da:	0003      	movs	r3, r0
 800c9dc:	60fb      	str	r3, [r7, #12]
    IP_SET_TYPE_VAL(pcb->remote_ip, type);
  }
#else
  LWIP_UNUSED_ARG(type);
#endif /* LWIP_IPV4 && LWIP_IPV6 */
  return pcb;
 800c9de:	68fb      	ldr	r3, [r7, #12]
}
 800c9e0:	0018      	movs	r0, r3
 800c9e2:	46bd      	mov	sp, r7
 800c9e4:	b004      	add	sp, #16
 800c9e6:	bd80      	pop	{r7, pc}

0800c9e8 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{
 800c9e8:	b580      	push	{r7, lr}
 800c9ea:	b082      	sub	sp, #8
 800c9ec:	af00      	add	r7, sp, #0
 800c9ee:	6078      	str	r0, [r7, #4]
 800c9f0:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT_CORE_LOCKED();
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  if (pcb != NULL) {
 800c9f2:	687b      	ldr	r3, [r7, #4]
 800c9f4:	2b00      	cmp	r3, #0
 800c9f6:	d002      	beq.n	800c9fe <tcp_arg+0x16>
    pcb->callback_arg = arg;
 800c9f8:	687b      	ldr	r3, [r7, #4]
 800c9fa:	683a      	ldr	r2, [r7, #0]
 800c9fc:	615a      	str	r2, [r3, #20]
  }
}
 800c9fe:	46c0      	nop			; (mov r8, r8)
 800ca00:	46bd      	mov	sp, r7
 800ca02:	b002      	add	sp, #8
 800ca04:	bd80      	pop	{r7, pc}
	...

0800ca08 <tcp_recv>:
 * @param pcb tcp_pcb to set the recv callback
 * @param recv callback function to call for this pcb when data is received
 */
void
tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
 800ca08:	b580      	push	{r7, lr}
 800ca0a:	b082      	sub	sp, #8
 800ca0c:	af00      	add	r7, sp, #0
 800ca0e:	6078      	str	r0, [r7, #4]
 800ca10:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb != NULL) {
 800ca12:	687b      	ldr	r3, [r7, #4]
 800ca14:	2b00      	cmp	r3, #0
 800ca16:	d00d      	beq.n	800ca34 <tcp_recv+0x2c>
    LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
 800ca18:	687b      	ldr	r3, [r7, #4]
 800ca1a:	7e1b      	ldrb	r3, [r3, #24]
 800ca1c:	2b01      	cmp	r3, #1
 800ca1e:	d105      	bne.n	800ca2c <tcp_recv+0x24>
 800ca20:	4b06      	ldr	r3, [pc, #24]	; (800ca3c <tcp_recv+0x34>)
 800ca22:	4a07      	ldr	r2, [pc, #28]	; (800ca40 <tcp_recv+0x38>)
 800ca24:	4907      	ldr	r1, [pc, #28]	; (800ca44 <tcp_recv+0x3c>)
 800ca26:	4808      	ldr	r0, [pc, #32]	; (800ca48 <tcp_recv+0x40>)
 800ca28:	f7f5 fbdc 	bl	80021e4 <app_debug_rtt_raw>
    pcb->recv = recv;
 800ca2c:	687b      	ldr	r3, [r7, #4]
 800ca2e:	2188      	movs	r1, #136	; 0x88
 800ca30:	683a      	ldr	r2, [r7, #0]
 800ca32:	505a      	str	r2, [r3, r1]
  }
}
 800ca34:	46c0      	nop			; (mov r8, r8)
 800ca36:	46bd      	mov	sp, r7
 800ca38:	b002      	add	sp, #8
 800ca3a:	bd80      	pop	{r7, pc}
 800ca3c:	08020aa8 	.word	0x08020aa8
 800ca40:	000007e2 	.word	0x000007e2
 800ca44:	08021040 	.word	0x08021040
 800ca48:	08020ae4 	.word	0x08020ae4

0800ca4c <tcp_sent>:
 * @param pcb tcp_pcb to set the sent callback
 * @param sent callback function to call for this pcb when data is successfully sent
 */
void
tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
 800ca4c:	b580      	push	{r7, lr}
 800ca4e:	b082      	sub	sp, #8
 800ca50:	af00      	add	r7, sp, #0
 800ca52:	6078      	str	r0, [r7, #4]
 800ca54:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb != NULL) {
 800ca56:	687b      	ldr	r3, [r7, #4]
 800ca58:	2b00      	cmp	r3, #0
 800ca5a:	d00d      	beq.n	800ca78 <tcp_sent+0x2c>
    LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
 800ca5c:	687b      	ldr	r3, [r7, #4]
 800ca5e:	7e1b      	ldrb	r3, [r3, #24]
 800ca60:	2b01      	cmp	r3, #1
 800ca62:	d105      	bne.n	800ca70 <tcp_sent+0x24>
 800ca64:	4b06      	ldr	r3, [pc, #24]	; (800ca80 <tcp_sent+0x34>)
 800ca66:	4a07      	ldr	r2, [pc, #28]	; (800ca84 <tcp_sent+0x38>)
 800ca68:	4907      	ldr	r1, [pc, #28]	; (800ca88 <tcp_sent+0x3c>)
 800ca6a:	4808      	ldr	r0, [pc, #32]	; (800ca8c <tcp_sent+0x40>)
 800ca6c:	f7f5 fbba 	bl	80021e4 <app_debug_rtt_raw>
    pcb->sent = sent;
 800ca70:	687b      	ldr	r3, [r7, #4]
 800ca72:	2184      	movs	r1, #132	; 0x84
 800ca74:	683a      	ldr	r2, [r7, #0]
 800ca76:	505a      	str	r2, [r3, r1]
  }
}
 800ca78:	46c0      	nop			; (mov r8, r8)
 800ca7a:	46bd      	mov	sp, r7
 800ca7c:	b002      	add	sp, #8
 800ca7e:	bd80      	pop	{r7, pc}
 800ca80:	08020aa8 	.word	0x08020aa8
 800ca84:	000007f6 	.word	0x000007f6
 800ca88:	08021068 	.word	0x08021068
 800ca8c:	08020ae4 	.word	0x08020ae4

0800ca90 <tcp_err>:
 * @param err callback function to call for this pcb when a fatal error
 *        has occurred on the connection
 */
void
tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
 800ca90:	b580      	push	{r7, lr}
 800ca92:	b082      	sub	sp, #8
 800ca94:	af00      	add	r7, sp, #0
 800ca96:	6078      	str	r0, [r7, #4]
 800ca98:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb != NULL) {
 800ca9a:	687b      	ldr	r3, [r7, #4]
 800ca9c:	2b00      	cmp	r3, #0
 800ca9e:	d00e      	beq.n	800cabe <tcp_err+0x2e>
    LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
 800caa0:	687b      	ldr	r3, [r7, #4]
 800caa2:	7e1b      	ldrb	r3, [r3, #24]
 800caa4:	2b01      	cmp	r3, #1
 800caa6:	d106      	bne.n	800cab6 <tcp_err+0x26>
 800caa8:	4b07      	ldr	r3, [pc, #28]	; (800cac8 <tcp_err+0x38>)
 800caaa:	2281      	movs	r2, #129	; 0x81
 800caac:	0112      	lsls	r2, r2, #4
 800caae:	4907      	ldr	r1, [pc, #28]	; (800cacc <tcp_err+0x3c>)
 800cab0:	4807      	ldr	r0, [pc, #28]	; (800cad0 <tcp_err+0x40>)
 800cab2:	f7f5 fb97 	bl	80021e4 <app_debug_rtt_raw>
    pcb->errf = err;
 800cab6:	687b      	ldr	r3, [r7, #4]
 800cab8:	2194      	movs	r1, #148	; 0x94
 800caba:	683a      	ldr	r2, [r7, #0]
 800cabc:	505a      	str	r2, [r3, r1]
  }
}
 800cabe:	46c0      	nop			; (mov r8, r8)
 800cac0:	46bd      	mov	sp, r7
 800cac2:	b002      	add	sp, #8
 800cac4:	bd80      	pop	{r7, pc}
 800cac6:	46c0      	nop			; (mov r8, r8)
 800cac8:	08020aa8 	.word	0x08020aa8
 800cacc:	08021090 	.word	0x08021090
 800cad0:	08020ae4 	.word	0x08020ae4

0800cad4 <tcp_poll>:
 * the application may use the polling functionality to call tcp_write()
 * again when the connection has been idle for a while.
 */
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
 800cad4:	b580      	push	{r7, lr}
 800cad6:	b084      	sub	sp, #16
 800cad8:	af00      	add	r7, sp, #0
 800cada:	60f8      	str	r0, [r7, #12]
 800cadc:	60b9      	str	r1, [r7, #8]
 800cade:	1dfb      	adds	r3, r7, #7
 800cae0:	701a      	strb	r2, [r3, #0]
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_poll: invalid pcb", pcb != NULL, return);
 800cae2:	68fb      	ldr	r3, [r7, #12]
 800cae4:	2b00      	cmp	r3, #0
 800cae6:	d104      	bne.n	800caf2 <tcp_poll+0x1e>
 800cae8:	4b0d      	ldr	r3, [pc, #52]	; (800cb20 <tcp_poll+0x4c>)
 800caea:	0018      	movs	r0, r3
 800caec:	f7f5 fb7a 	bl	80021e4 <app_debug_rtt_raw>
 800caf0:	e012      	b.n	800cb18 <tcp_poll+0x44>
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
 800caf2:	68fb      	ldr	r3, [r7, #12]
 800caf4:	7e1b      	ldrb	r3, [r3, #24]
 800caf6:	2b01      	cmp	r3, #1
 800caf8:	d105      	bne.n	800cb06 <tcp_poll+0x32>
 800cafa:	4b0a      	ldr	r3, [pc, #40]	; (800cb24 <tcp_poll+0x50>)
 800cafc:	4a0a      	ldr	r2, [pc, #40]	; (800cb28 <tcp_poll+0x54>)
 800cafe:	490b      	ldr	r1, [pc, #44]	; (800cb2c <tcp_poll+0x58>)
 800cb00:	480b      	ldr	r0, [pc, #44]	; (800cb30 <tcp_poll+0x5c>)
 800cb02:	f7f5 fb6f 	bl	80021e4 <app_debug_rtt_raw>

#if LWIP_CALLBACK_API
  pcb->poll = poll;
 800cb06:	68fb      	ldr	r3, [r7, #12]
 800cb08:	2190      	movs	r1, #144	; 0x90
 800cb0a:	68ba      	ldr	r2, [r7, #8]
 800cb0c:	505a      	str	r2, [r3, r1]
#else /* LWIP_CALLBACK_API */
  LWIP_UNUSED_ARG(poll);
#endif /* LWIP_CALLBACK_API */
  pcb->pollinterval = interval;
 800cb0e:	68fb      	ldr	r3, [r7, #12]
 800cb10:	1dfa      	adds	r2, r7, #7
 800cb12:	2121      	movs	r1, #33	; 0x21
 800cb14:	7812      	ldrb	r2, [r2, #0]
 800cb16:	545a      	strb	r2, [r3, r1]
}
 800cb18:	46bd      	mov	sp, r7
 800cb1a:	b004      	add	sp, #16
 800cb1c:	bd80      	pop	{r7, pc}
 800cb1e:	46c0      	nop			; (mov r8, r8)
 800cb20:	080210b8 	.word	0x080210b8
 800cb24:	08020aa8 	.word	0x08020aa8
 800cb28:	00000842 	.word	0x00000842
 800cb2c:	080210d0 	.word	0x080210d0
 800cb30:	08020ae4 	.word	0x08020ae4

0800cb34 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
 800cb34:	b580      	push	{r7, lr}
 800cb36:	b082      	sub	sp, #8
 800cb38:	af00      	add	r7, sp, #0
 800cb3a:	6078      	str	r0, [r7, #4]
  LWIP_ERROR("tcp_pcb_purge: invalid pcb", pcb != NULL, return);
 800cb3c:	687b      	ldr	r3, [r7, #4]
 800cb3e:	2b00      	cmp	r3, #0
 800cb40:	d104      	bne.n	800cb4c <tcp_pcb_purge+0x18>
 800cb42:	4b20      	ldr	r3, [pc, #128]	; (800cbc4 <tcp_pcb_purge+0x90>)
 800cb44:	0018      	movs	r0, r3
 800cb46:	f7f5 fb4d 	bl	80021e4 <app_debug_rtt_raw>
 800cb4a:	e038      	b.n	800cbbe <tcp_pcb_purge+0x8a>

  if (pcb->state != CLOSED &&
 800cb4c:	687b      	ldr	r3, [r7, #4]
 800cb4e:	7e1b      	ldrb	r3, [r3, #24]
 800cb50:	2b00      	cmp	r3, #0
 800cb52:	d034      	beq.n	800cbbe <tcp_pcb_purge+0x8a>
      pcb->state != TIME_WAIT &&
 800cb54:	687b      	ldr	r3, [r7, #4]
 800cb56:	7e1b      	ldrb	r3, [r3, #24]
  if (pcb->state != CLOSED &&
 800cb58:	2b0a      	cmp	r3, #10
 800cb5a:	d030      	beq.n	800cbbe <tcp_pcb_purge+0x8a>
      pcb->state != LISTEN) {
 800cb5c:	687b      	ldr	r3, [r7, #4]
 800cb5e:	7e1b      	ldrb	r3, [r3, #24]
      pcb->state != TIME_WAIT &&
 800cb60:	2b01      	cmp	r3, #1
 800cb62:	d02c      	beq.n	800cbbe <tcp_pcb_purge+0x8a>

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    tcp_backlog_accepted(pcb);

    if (pcb->refused_data != NULL) {
 800cb64:	687b      	ldr	r3, [r7, #4]
 800cb66:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800cb68:	2b00      	cmp	r3, #0
 800cb6a:	d007      	beq.n	800cb7c <tcp_pcb_purge+0x48>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
 800cb6c:	687b      	ldr	r3, [r7, #4]
 800cb6e:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800cb70:	0018      	movs	r0, r3
 800cb72:	f7fd fcb3 	bl	800a4dc <pbuf_free>
      pcb->refused_data = NULL;
 800cb76:	687b      	ldr	r3, [r7, #4]
 800cb78:	2200      	movs	r2, #0
 800cb7a:	67da      	str	r2, [r3, #124]	; 0x7c
    }
    if (pcb->unacked != NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->unacked\n"));
    }
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
 800cb7c:	687b      	ldr	r3, [r7, #4]
 800cb7e:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800cb80:	2b00      	cmp	r3, #0
 800cb82:	d003      	beq.n	800cb8c <tcp_pcb_purge+0x58>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
      tcp_free_ooseq(pcb);
 800cb84:	687b      	ldr	r3, [r7, #4]
 800cb86:	0018      	movs	r0, r3
 800cb88:	f000 f9a4 	bl	800ced4 <tcp_free_ooseq>
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
 800cb8c:	687b      	ldr	r3, [r7, #4]
 800cb8e:	2201      	movs	r2, #1
 800cb90:	4252      	negs	r2, r2
 800cb92:	869a      	strh	r2, [r3, #52]	; 0x34

    tcp_segs_free(pcb->unsent);
 800cb94:	687b      	ldr	r3, [r7, #4]
 800cb96:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800cb98:	0018      	movs	r0, r3
 800cb9a:	f7ff fce5 	bl	800c568 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
 800cb9e:	687b      	ldr	r3, [r7, #4]
 800cba0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800cba2:	0018      	movs	r0, r3
 800cba4:	f7ff fce0 	bl	800c568 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
 800cba8:	687b      	ldr	r3, [r7, #4]
 800cbaa:	2200      	movs	r2, #0
 800cbac:	671a      	str	r2, [r3, #112]	; 0x70
 800cbae:	687b      	ldr	r3, [r7, #4]
 800cbb0:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800cbb2:	687b      	ldr	r3, [r7, #4]
 800cbb4:	675a      	str	r2, [r3, #116]	; 0x74
#if TCP_OVERSIZE
    pcb->unsent_oversize = 0;
 800cbb6:	687b      	ldr	r3, [r7, #4]
 800cbb8:	226c      	movs	r2, #108	; 0x6c
 800cbba:	2100      	movs	r1, #0
 800cbbc:	5299      	strh	r1, [r3, r2]
#endif /* TCP_OVERSIZE */
  }
}
 800cbbe:	46bd      	mov	sp, r7
 800cbc0:	b002      	add	sp, #8
 800cbc2:	bd80      	pop	{r7, pc}
 800cbc4:	080210f0 	.word	0x080210f0

0800cbc8 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
 800cbc8:	b580      	push	{r7, lr}
 800cbca:	b084      	sub	sp, #16
 800cbcc:	af00      	add	r7, sp, #0
 800cbce:	6078      	str	r0, [r7, #4]
 800cbd0:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT("tcp_pcb_remove: invalid pcb", pcb != NULL);
 800cbd2:	683b      	ldr	r3, [r7, #0]
 800cbd4:	2b00      	cmp	r3, #0
 800cbd6:	d105      	bne.n	800cbe4 <tcp_pcb_remove+0x1c>
 800cbd8:	4b3c      	ldr	r3, [pc, #240]	; (800cccc <tcp_pcb_remove+0x104>)
 800cbda:	4a3d      	ldr	r2, [pc, #244]	; (800ccd0 <tcp_pcb_remove+0x108>)
 800cbdc:	493d      	ldr	r1, [pc, #244]	; (800ccd4 <tcp_pcb_remove+0x10c>)
 800cbde:	483e      	ldr	r0, [pc, #248]	; (800ccd8 <tcp_pcb_remove+0x110>)
 800cbe0:	f7f5 fb00 	bl	80021e4 <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_pcb_remove: invalid pcblist", pcblist != NULL);
 800cbe4:	687b      	ldr	r3, [r7, #4]
 800cbe6:	2b00      	cmp	r3, #0
 800cbe8:	d105      	bne.n	800cbf6 <tcp_pcb_remove+0x2e>
 800cbea:	4b38      	ldr	r3, [pc, #224]	; (800cccc <tcp_pcb_remove+0x104>)
 800cbec:	4a3b      	ldr	r2, [pc, #236]	; (800ccdc <tcp_pcb_remove+0x114>)
 800cbee:	493c      	ldr	r1, [pc, #240]	; (800cce0 <tcp_pcb_remove+0x118>)
 800cbf0:	4839      	ldr	r0, [pc, #228]	; (800ccd8 <tcp_pcb_remove+0x110>)
 800cbf2:	f7f5 faf7 	bl	80021e4 <app_debug_rtt_raw>

  TCP_RMV(pcblist, pcb);
 800cbf6:	687b      	ldr	r3, [r7, #4]
 800cbf8:	681b      	ldr	r3, [r3, #0]
 800cbfa:	683a      	ldr	r2, [r7, #0]
 800cbfc:	429a      	cmp	r2, r3
 800cbfe:	d105      	bne.n	800cc0c <tcp_pcb_remove+0x44>
 800cc00:	687b      	ldr	r3, [r7, #4]
 800cc02:	681b      	ldr	r3, [r3, #0]
 800cc04:	691a      	ldr	r2, [r3, #16]
 800cc06:	687b      	ldr	r3, [r7, #4]
 800cc08:	601a      	str	r2, [r3, #0]
 800cc0a:	e013      	b.n	800cc34 <tcp_pcb_remove+0x6c>
 800cc0c:	687b      	ldr	r3, [r7, #4]
 800cc0e:	681b      	ldr	r3, [r3, #0]
 800cc10:	60fb      	str	r3, [r7, #12]
 800cc12:	e00c      	b.n	800cc2e <tcp_pcb_remove+0x66>
 800cc14:	68fb      	ldr	r3, [r7, #12]
 800cc16:	691b      	ldr	r3, [r3, #16]
 800cc18:	683a      	ldr	r2, [r7, #0]
 800cc1a:	429a      	cmp	r2, r3
 800cc1c:	d104      	bne.n	800cc28 <tcp_pcb_remove+0x60>
 800cc1e:	683b      	ldr	r3, [r7, #0]
 800cc20:	691a      	ldr	r2, [r3, #16]
 800cc22:	68fb      	ldr	r3, [r7, #12]
 800cc24:	611a      	str	r2, [r3, #16]
 800cc26:	e005      	b.n	800cc34 <tcp_pcb_remove+0x6c>
 800cc28:	68fb      	ldr	r3, [r7, #12]
 800cc2a:	691b      	ldr	r3, [r3, #16]
 800cc2c:	60fb      	str	r3, [r7, #12]
 800cc2e:	68fb      	ldr	r3, [r7, #12]
 800cc30:	2b00      	cmp	r3, #0
 800cc32:	d1ef      	bne.n	800cc14 <tcp_pcb_remove+0x4c>
 800cc34:	683b      	ldr	r3, [r7, #0]
 800cc36:	2200      	movs	r2, #0
 800cc38:	611a      	str	r2, [r3, #16]

  tcp_pcb_purge(pcb);
 800cc3a:	683b      	ldr	r3, [r7, #0]
 800cc3c:	0018      	movs	r0, r3
 800cc3e:	f7ff ff79 	bl	800cb34 <tcp_pcb_purge>

  /* if there is an outstanding delayed ACKs, send it */
  if ((pcb->state != TIME_WAIT) &&
 800cc42:	683b      	ldr	r3, [r7, #0]
 800cc44:	7e1b      	ldrb	r3, [r3, #24]
 800cc46:	2b0a      	cmp	r3, #10
 800cc48:	d014      	beq.n	800cc74 <tcp_pcb_remove+0xac>
      (pcb->state != LISTEN) &&
 800cc4a:	683b      	ldr	r3, [r7, #0]
 800cc4c:	7e1b      	ldrb	r3, [r3, #24]
  if ((pcb->state != TIME_WAIT) &&
 800cc4e:	2b01      	cmp	r3, #1
 800cc50:	d010      	beq.n	800cc74 <tcp_pcb_remove+0xac>
      (pcb->flags & TF_ACK_DELAY)) {
 800cc52:	683b      	ldr	r3, [r7, #0]
 800cc54:	8bdb      	ldrh	r3, [r3, #30]
 800cc56:	001a      	movs	r2, r3
 800cc58:	2301      	movs	r3, #1
 800cc5a:	4013      	ands	r3, r2
      (pcb->state != LISTEN) &&
 800cc5c:	d00a      	beq.n	800cc74 <tcp_pcb_remove+0xac>
    tcp_ack_now(pcb);
 800cc5e:	683b      	ldr	r3, [r7, #0]
 800cc60:	8bdb      	ldrh	r3, [r3, #30]
 800cc62:	2202      	movs	r2, #2
 800cc64:	4313      	orrs	r3, r2
 800cc66:	b29a      	uxth	r2, r3
 800cc68:	683b      	ldr	r3, [r7, #0]
 800cc6a:	83da      	strh	r2, [r3, #30]
    tcp_output(pcb);
 800cc6c:	683b      	ldr	r3, [r7, #0]
 800cc6e:	0018      	movs	r0, r3
 800cc70:	f004 fb8c 	bl	801138c <tcp_output>
  }

  if (pcb->state != LISTEN) {
 800cc74:	683b      	ldr	r3, [r7, #0]
 800cc76:	7e1b      	ldrb	r3, [r3, #24]
 800cc78:	2b01      	cmp	r3, #1
 800cc7a:	d01d      	beq.n	800ccb8 <tcp_pcb_remove+0xf0>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
 800cc7c:	683b      	ldr	r3, [r7, #0]
 800cc7e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800cc80:	2b00      	cmp	r3, #0
 800cc82:	d005      	beq.n	800cc90 <tcp_pcb_remove+0xc8>
 800cc84:	4b11      	ldr	r3, [pc, #68]	; (800cccc <tcp_pcb_remove+0x104>)
 800cc86:	4a17      	ldr	r2, [pc, #92]	; (800cce4 <tcp_pcb_remove+0x11c>)
 800cc88:	4917      	ldr	r1, [pc, #92]	; (800cce8 <tcp_pcb_remove+0x120>)
 800cc8a:	4813      	ldr	r0, [pc, #76]	; (800ccd8 <tcp_pcb_remove+0x110>)
 800cc8c:	f7f5 faaa 	bl	80021e4 <app_debug_rtt_raw>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
 800cc90:	683b      	ldr	r3, [r7, #0]
 800cc92:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800cc94:	2b00      	cmp	r3, #0
 800cc96:	d005      	beq.n	800cca4 <tcp_pcb_remove+0xdc>
 800cc98:	4b0c      	ldr	r3, [pc, #48]	; (800cccc <tcp_pcb_remove+0x104>)
 800cc9a:	4a14      	ldr	r2, [pc, #80]	; (800ccec <tcp_pcb_remove+0x124>)
 800cc9c:	4914      	ldr	r1, [pc, #80]	; (800ccf0 <tcp_pcb_remove+0x128>)
 800cc9e:	480e      	ldr	r0, [pc, #56]	; (800ccd8 <tcp_pcb_remove+0x110>)
 800cca0:	f7f5 faa0 	bl	80021e4 <app_debug_rtt_raw>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
 800cca4:	683b      	ldr	r3, [r7, #0]
 800cca6:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800cca8:	2b00      	cmp	r3, #0
 800ccaa:	d005      	beq.n	800ccb8 <tcp_pcb_remove+0xf0>
 800ccac:	4b07      	ldr	r3, [pc, #28]	; (800cccc <tcp_pcb_remove+0x104>)
 800ccae:	4a11      	ldr	r2, [pc, #68]	; (800ccf4 <tcp_pcb_remove+0x12c>)
 800ccb0:	4911      	ldr	r1, [pc, #68]	; (800ccf8 <tcp_pcb_remove+0x130>)
 800ccb2:	4809      	ldr	r0, [pc, #36]	; (800ccd8 <tcp_pcb_remove+0x110>)
 800ccb4:	f7f5 fa96 	bl	80021e4 <app_debug_rtt_raw>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
 800ccb8:	683b      	ldr	r3, [r7, #0]
 800ccba:	2200      	movs	r2, #0
 800ccbc:	761a      	strb	r2, [r3, #24]
  /* reset the local port to prevent the pcb from being 'bound' */
  pcb->local_port = 0;
 800ccbe:	683b      	ldr	r3, [r7, #0]
 800ccc0:	2200      	movs	r2, #0
 800ccc2:	835a      	strh	r2, [r3, #26]

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
 800ccc4:	46c0      	nop			; (mov r8, r8)
 800ccc6:	46bd      	mov	sp, r7
 800ccc8:	b004      	add	sp, #16
 800ccca:	bd80      	pop	{r7, pc}
 800cccc:	08020aa8 	.word	0x08020aa8
 800ccd0:	00000887 	.word	0x00000887
 800ccd4:	0802110c 	.word	0x0802110c
 800ccd8:	08020ae4 	.word	0x08020ae4
 800ccdc:	00000888 	.word	0x00000888
 800cce0:	08021128 	.word	0x08021128
 800cce4:	00000897 	.word	0x00000897
 800cce8:	08021148 	.word	0x08021148
 800ccec:	00000898 	.word	0x00000898
 800ccf0:	08021160 	.word	0x08021160
 800ccf4:	0000089a 	.word	0x0000089a
 800ccf8:	0802117c 	.word	0x0802117c

0800ccfc <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(struct tcp_pcb *pcb)
{
 800ccfc:	b580      	push	{r7, lr}
 800ccfe:	b082      	sub	sp, #8
 800cd00:	af00      	add	r7, sp, #0
 800cd02:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_next_iss: invalid pcb", pcb != NULL);
  return LWIP_HOOK_TCP_ISN(&pcb->local_ip, pcb->local_port, &pcb->remote_ip, pcb->remote_port);
#else /* LWIP_HOOK_TCP_ISN */
  static u32_t iss = 6510;

  LWIP_ASSERT("tcp_next_iss: invalid pcb", pcb != NULL);
 800cd04:	687b      	ldr	r3, [r7, #4]
 800cd06:	2b00      	cmp	r3, #0
 800cd08:	d105      	bne.n	800cd16 <tcp_next_iss+0x1a>
 800cd0a:	4b09      	ldr	r3, [pc, #36]	; (800cd30 <tcp_next_iss+0x34>)
 800cd0c:	4a09      	ldr	r2, [pc, #36]	; (800cd34 <tcp_next_iss+0x38>)
 800cd0e:	490a      	ldr	r1, [pc, #40]	; (800cd38 <tcp_next_iss+0x3c>)
 800cd10:	480a      	ldr	r0, [pc, #40]	; (800cd3c <tcp_next_iss+0x40>)
 800cd12:	f7f5 fa67 	bl	80021e4 <app_debug_rtt_raw>
  LWIP_UNUSED_ARG(pcb);

  iss += tcp_ticks;       /* XXX */
 800cd16:	4b0a      	ldr	r3, [pc, #40]	; (800cd40 <tcp_next_iss+0x44>)
 800cd18:	681a      	ldr	r2, [r3, #0]
 800cd1a:	4b0a      	ldr	r3, [pc, #40]	; (800cd44 <tcp_next_iss+0x48>)
 800cd1c:	681b      	ldr	r3, [r3, #0]
 800cd1e:	18d2      	adds	r2, r2, r3
 800cd20:	4b07      	ldr	r3, [pc, #28]	; (800cd40 <tcp_next_iss+0x44>)
 800cd22:	601a      	str	r2, [r3, #0]
  return iss;
 800cd24:	4b06      	ldr	r3, [pc, #24]	; (800cd40 <tcp_next_iss+0x44>)
 800cd26:	681b      	ldr	r3, [r3, #0]
#endif /* LWIP_HOOK_TCP_ISN */
}
 800cd28:	0018      	movs	r0, r3
 800cd2a:	46bd      	mov	sp, r7
 800cd2c:	b002      	add	sp, #8
 800cd2e:	bd80      	pop	{r7, pc}
 800cd30:	08020aa8 	.word	0x08020aa8
 800cd34:	000008b3 	.word	0x000008b3
 800cd38:	08021194 	.word	0x08021194
 800cd3c:	08020ae4 	.word	0x08020ae4
 800cd40:	20000024 	.word	0x20000024
 800cd44:	20002790 	.word	0x20002790

0800cd48 <tcp_eff_send_mss_netif>:
 * by calculating the minimum of TCP_MSS and the mtu (if set) of the target
 * netif (if not NULL).
 */
u16_t
tcp_eff_send_mss_netif(u16_t sendmss, struct netif *outif, const ip_addr_t *dest)
{
 800cd48:	b590      	push	{r4, r7, lr}
 800cd4a:	b087      	sub	sp, #28
 800cd4c:	af00      	add	r7, sp, #0
 800cd4e:	60b9      	str	r1, [r7, #8]
 800cd50:	607a      	str	r2, [r7, #4]
 800cd52:	230e      	movs	r3, #14
 800cd54:	18fb      	adds	r3, r7, r3
 800cd56:	1c02      	adds	r2, r0, #0
 800cd58:	801a      	strh	r2, [r3, #0]
  u16_t mss_s;
  u16_t mtu;

  LWIP_UNUSED_ARG(dest); /* in case IPv6 is disabled */

  LWIP_ASSERT("tcp_eff_send_mss_netif: invalid dst_ip", dest != NULL);
 800cd5a:	687b      	ldr	r3, [r7, #4]
 800cd5c:	2b00      	cmp	r3, #0
 800cd5e:	d105      	bne.n	800cd6c <tcp_eff_send_mss_netif+0x24>
 800cd60:	4b1e      	ldr	r3, [pc, #120]	; (800cddc <tcp_eff_send_mss_netif+0x94>)
 800cd62:	4a1f      	ldr	r2, [pc, #124]	; (800cde0 <tcp_eff_send_mss_netif+0x98>)
 800cd64:	491f      	ldr	r1, [pc, #124]	; (800cde4 <tcp_eff_send_mss_netif+0x9c>)
 800cd66:	4820      	ldr	r0, [pc, #128]	; (800cde8 <tcp_eff_send_mss_netif+0xa0>)
 800cd68:	f7f5 fa3c 	bl	80021e4 <app_debug_rtt_raw>
  else
#endif /* LWIP_IPV4 */
#endif /* LWIP_IPV6 */
#if LWIP_IPV4
  {
    if (outif == NULL) {
 800cd6c:	68bb      	ldr	r3, [r7, #8]
 800cd6e:	2b00      	cmp	r3, #0
 800cd70:	d103      	bne.n	800cd7a <tcp_eff_send_mss_netif+0x32>
      return sendmss;
 800cd72:	230e      	movs	r3, #14
 800cd74:	18fb      	adds	r3, r7, r3
 800cd76:	881b      	ldrh	r3, [r3, #0]
 800cd78:	e02c      	b.n	800cdd4 <tcp_eff_send_mss_netif+0x8c>
    }
    mtu = outif->mtu;
 800cd7a:	2116      	movs	r1, #22
 800cd7c:	187b      	adds	r3, r7, r1
 800cd7e:	68ba      	ldr	r2, [r7, #8]
 800cd80:	8d12      	ldrh	r2, [r2, #40]	; 0x28
 800cd82:	801a      	strh	r2, [r3, #0]
  }
#endif /* LWIP_IPV4 */

  if (mtu != 0) {
 800cd84:	187b      	adds	r3, r7, r1
 800cd86:	881b      	ldrh	r3, [r3, #0]
 800cd88:	2b00      	cmp	r3, #0
 800cd8a:	d020      	beq.n	800cdce <tcp_eff_send_mss_netif+0x86>
    else
#endif /* LWIP_IPV4 */
#endif /* LWIP_IPV6 */
#if LWIP_IPV4
    {
      offset = IP_HLEN + TCP_HLEN;
 800cd8c:	2014      	movs	r0, #20
 800cd8e:	183b      	adds	r3, r7, r0
 800cd90:	2228      	movs	r2, #40	; 0x28
 800cd92:	801a      	strh	r2, [r3, #0]
    }
#endif /* LWIP_IPV4 */
    mss_s = (mtu > offset) ? (u16_t)(mtu - offset) : 0;
 800cd94:	187a      	adds	r2, r7, r1
 800cd96:	183b      	adds	r3, r7, r0
 800cd98:	8812      	ldrh	r2, [r2, #0]
 800cd9a:	881b      	ldrh	r3, [r3, #0]
 800cd9c:	429a      	cmp	r2, r3
 800cd9e:	d906      	bls.n	800cdae <tcp_eff_send_mss_netif+0x66>
 800cda0:	187a      	adds	r2, r7, r1
 800cda2:	183b      	adds	r3, r7, r0
 800cda4:	8812      	ldrh	r2, [r2, #0]
 800cda6:	881b      	ldrh	r3, [r3, #0]
 800cda8:	1ad3      	subs	r3, r2, r3
 800cdaa:	b29a      	uxth	r2, r3
 800cdac:	e000      	b.n	800cdb0 <tcp_eff_send_mss_netif+0x68>
 800cdae:	2200      	movs	r2, #0
 800cdb0:	2112      	movs	r1, #18
 800cdb2:	187b      	adds	r3, r7, r1
 800cdb4:	801a      	strh	r2, [r3, #0]
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * We correct for TCP options in tcp_write(), and don't support IP options.
     */
    sendmss = LWIP_MIN(sendmss, mss_s);
 800cdb6:	200e      	movs	r0, #14
 800cdb8:	183a      	adds	r2, r7, r0
 800cdba:	187b      	adds	r3, r7, r1
 800cdbc:	1839      	adds	r1, r7, r0
 800cdbe:	880c      	ldrh	r4, [r1, #0]
 800cdc0:	881b      	ldrh	r3, [r3, #0]
 800cdc2:	b298      	uxth	r0, r3
 800cdc4:	b2a1      	uxth	r1, r4
 800cdc6:	4288      	cmp	r0, r1
 800cdc8:	d900      	bls.n	800cdcc <tcp_eff_send_mss_netif+0x84>
 800cdca:	1c23      	adds	r3, r4, #0
 800cdcc:	8013      	strh	r3, [r2, #0]
  }
  return sendmss;
 800cdce:	230e      	movs	r3, #14
 800cdd0:	18fb      	adds	r3, r7, r3
 800cdd2:	881b      	ldrh	r3, [r3, #0]
}
 800cdd4:	0018      	movs	r0, r3
 800cdd6:	46bd      	mov	sp, r7
 800cdd8:	b007      	add	sp, #28
 800cdda:	bd90      	pop	{r4, r7, pc}
 800cddc:	08020aa8 	.word	0x08020aa8
 800cde0:	000008c9 	.word	0x000008c9
 800cde4:	080211b0 	.word	0x080211b0
 800cde8:	08020ae4 	.word	0x08020ae4

0800cdec <tcp_netif_ip_addr_changed_pcblist>:
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

/** Helper function for tcp_netif_ip_addr_changed() that iterates a pcb list */
static void
tcp_netif_ip_addr_changed_pcblist(const ip_addr_t *old_addr, struct tcp_pcb *pcb_list)
{
 800cdec:	b580      	push	{r7, lr}
 800cdee:	b084      	sub	sp, #16
 800cdf0:	af00      	add	r7, sp, #0
 800cdf2:	6078      	str	r0, [r7, #4]
 800cdf4:	6039      	str	r1, [r7, #0]
  struct tcp_pcb *pcb;
  pcb = pcb_list;
 800cdf6:	683b      	ldr	r3, [r7, #0]
 800cdf8:	60fb      	str	r3, [r7, #12]

  LWIP_ASSERT("tcp_netif_ip_addr_changed_pcblist: invalid old_addr", old_addr != NULL);
 800cdfa:	687b      	ldr	r3, [r7, #4]
 800cdfc:	2b00      	cmp	r3, #0
 800cdfe:	d119      	bne.n	800ce34 <tcp_netif_ip_addr_changed_pcblist+0x48>
 800ce00:	4b10      	ldr	r3, [pc, #64]	; (800ce44 <tcp_netif_ip_addr_changed_pcblist+0x58>)
 800ce02:	4a11      	ldr	r2, [pc, #68]	; (800ce48 <tcp_netif_ip_addr_changed_pcblist+0x5c>)
 800ce04:	4911      	ldr	r1, [pc, #68]	; (800ce4c <tcp_netif_ip_addr_changed_pcblist+0x60>)
 800ce06:	4812      	ldr	r0, [pc, #72]	; (800ce50 <tcp_netif_ip_addr_changed_pcblist+0x64>)
 800ce08:	f7f5 f9ec 	bl	80021e4 <app_debug_rtt_raw>

  while (pcb != NULL) {
 800ce0c:	e012      	b.n	800ce34 <tcp_netif_ip_addr_changed_pcblist+0x48>
    /* PCB bound to current local interface address? */
    if (ip_addr_cmp(&pcb->local_ip, old_addr)
 800ce0e:	68fb      	ldr	r3, [r7, #12]
 800ce10:	681a      	ldr	r2, [r3, #0]
 800ce12:	687b      	ldr	r3, [r7, #4]
 800ce14:	681b      	ldr	r3, [r3, #0]
 800ce16:	429a      	cmp	r2, r3
 800ce18:	d109      	bne.n	800ce2e <tcp_netif_ip_addr_changed_pcblist+0x42>
        /* connections to link-local addresses must persist (RFC3927 ch. 1.9) */
        && (!IP_IS_V4_VAL(pcb->local_ip) || !ip4_addr_islinklocal(ip_2_ip4(&pcb->local_ip)))
#endif /* LWIP_AUTOIP */
       ) {
      /* this connection must be aborted */
      struct tcp_pcb *next = pcb->next;
 800ce1a:	68fb      	ldr	r3, [r7, #12]
 800ce1c:	691b      	ldr	r3, [r3, #16]
 800ce1e:	60bb      	str	r3, [r7, #8]
      LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
      tcp_abort(pcb);
 800ce20:	68fb      	ldr	r3, [r7, #12]
 800ce22:	0018      	movs	r0, r3
 800ce24:	f7fe fc0e 	bl	800b644 <tcp_abort>
      pcb = next;
 800ce28:	68bb      	ldr	r3, [r7, #8]
 800ce2a:	60fb      	str	r3, [r7, #12]
 800ce2c:	e002      	b.n	800ce34 <tcp_netif_ip_addr_changed_pcblist+0x48>
    } else {
      pcb = pcb->next;
 800ce2e:	68fb      	ldr	r3, [r7, #12]
 800ce30:	691b      	ldr	r3, [r3, #16]
 800ce32:	60fb      	str	r3, [r7, #12]
  while (pcb != NULL) {
 800ce34:	68fb      	ldr	r3, [r7, #12]
 800ce36:	2b00      	cmp	r3, #0
 800ce38:	d1e9      	bne.n	800ce0e <tcp_netif_ip_addr_changed_pcblist+0x22>
    }
  }
}
 800ce3a:	46c0      	nop			; (mov r8, r8)
 800ce3c:	46c0      	nop			; (mov r8, r8)
 800ce3e:	46bd      	mov	sp, r7
 800ce40:	b004      	add	sp, #16
 800ce42:	bd80      	pop	{r7, pc}
 800ce44:	08020aa8 	.word	0x08020aa8
 800ce48:	00000904 	.word	0x00000904
 800ce4c:	080211d8 	.word	0x080211d8
 800ce50:	08020ae4 	.word	0x08020ae4

0800ce54 <tcp_netif_ip_addr_changed>:
 * @param old_addr IP address of the netif before change
 * @param new_addr IP address of the netif after change or NULL if netif has been removed
 */
void
tcp_netif_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_addr)
{
 800ce54:	b580      	push	{r7, lr}
 800ce56:	b084      	sub	sp, #16
 800ce58:	af00      	add	r7, sp, #0
 800ce5a:	6078      	str	r0, [r7, #4]
 800ce5c:	6039      	str	r1, [r7, #0]
  struct tcp_pcb_listen *lpcb;

  if (!ip_addr_isany(old_addr)) {
 800ce5e:	687b      	ldr	r3, [r7, #4]
 800ce60:	2b00      	cmp	r3, #0
 800ce62:	d02c      	beq.n	800cebe <tcp_netif_ip_addr_changed+0x6a>
 800ce64:	687b      	ldr	r3, [r7, #4]
 800ce66:	681b      	ldr	r3, [r3, #0]
 800ce68:	2b00      	cmp	r3, #0
 800ce6a:	d028      	beq.n	800cebe <tcp_netif_ip_addr_changed+0x6a>
    tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_active_pcbs);
 800ce6c:	4b16      	ldr	r3, [pc, #88]	; (800cec8 <tcp_netif_ip_addr_changed+0x74>)
 800ce6e:	681a      	ldr	r2, [r3, #0]
 800ce70:	687b      	ldr	r3, [r7, #4]
 800ce72:	0011      	movs	r1, r2
 800ce74:	0018      	movs	r0, r3
 800ce76:	f7ff ffb9 	bl	800cdec <tcp_netif_ip_addr_changed_pcblist>
    tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_bound_pcbs);
 800ce7a:	4b14      	ldr	r3, [pc, #80]	; (800cecc <tcp_netif_ip_addr_changed+0x78>)
 800ce7c:	681a      	ldr	r2, [r3, #0]
 800ce7e:	687b      	ldr	r3, [r7, #4]
 800ce80:	0011      	movs	r1, r2
 800ce82:	0018      	movs	r0, r3
 800ce84:	f7ff ffb2 	bl	800cdec <tcp_netif_ip_addr_changed_pcblist>

    if (!ip_addr_isany(new_addr)) {
 800ce88:	683b      	ldr	r3, [r7, #0]
 800ce8a:	2b00      	cmp	r3, #0
 800ce8c:	d017      	beq.n	800cebe <tcp_netif_ip_addr_changed+0x6a>
 800ce8e:	683b      	ldr	r3, [r7, #0]
 800ce90:	681b      	ldr	r3, [r3, #0]
 800ce92:	2b00      	cmp	r3, #0
 800ce94:	d013      	beq.n	800cebe <tcp_netif_ip_addr_changed+0x6a>
      /* PCB bound to current local interface address? */
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 800ce96:	4b0e      	ldr	r3, [pc, #56]	; (800ced0 <tcp_netif_ip_addr_changed+0x7c>)
 800ce98:	681b      	ldr	r3, [r3, #0]
 800ce9a:	60fb      	str	r3, [r7, #12]
 800ce9c:	e00c      	b.n	800ceb8 <tcp_netif_ip_addr_changed+0x64>
        /* PCB bound to current local interface address? */
        if (ip_addr_cmp(&lpcb->local_ip, old_addr)) {
 800ce9e:	68fb      	ldr	r3, [r7, #12]
 800cea0:	681a      	ldr	r2, [r3, #0]
 800cea2:	687b      	ldr	r3, [r7, #4]
 800cea4:	681b      	ldr	r3, [r3, #0]
 800cea6:	429a      	cmp	r2, r3
 800cea8:	d103      	bne.n	800ceb2 <tcp_netif_ip_addr_changed+0x5e>
          /* The PCB is listening to the old ipaddr and
            * is set to listen to the new one instead */
          ip_addr_copy(lpcb->local_ip, *new_addr);
 800ceaa:	683b      	ldr	r3, [r7, #0]
 800ceac:	681a      	ldr	r2, [r3, #0]
 800ceae:	68fb      	ldr	r3, [r7, #12]
 800ceb0:	601a      	str	r2, [r3, #0]
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 800ceb2:	68fb      	ldr	r3, [r7, #12]
 800ceb4:	691b      	ldr	r3, [r3, #16]
 800ceb6:	60fb      	str	r3, [r7, #12]
 800ceb8:	68fb      	ldr	r3, [r7, #12]
 800ceba:	2b00      	cmp	r3, #0
 800cebc:	d1ef      	bne.n	800ce9e <tcp_netif_ip_addr_changed+0x4a>
        }
      }
    }
  }
}
 800cebe:	46c0      	nop			; (mov r8, r8)
 800cec0:	46bd      	mov	sp, r7
 800cec2:	b004      	add	sp, #16
 800cec4:	bd80      	pop	{r7, pc}
 800cec6:	46c0      	nop			; (mov r8, r8)
 800cec8:	2000278c 	.word	0x2000278c
 800cecc:	20002798 	.word	0x20002798
 800ced0:	20002794 	.word	0x20002794

0800ced4 <tcp_free_ooseq>:

#if TCP_QUEUE_OOSEQ
/* Free all ooseq pbufs (and possibly reset SACK state) */
void
tcp_free_ooseq(struct tcp_pcb *pcb)
{
 800ced4:	b580      	push	{r7, lr}
 800ced6:	b082      	sub	sp, #8
 800ced8:	af00      	add	r7, sp, #0
 800ceda:	6078      	str	r0, [r7, #4]
  if (pcb->ooseq) {
 800cedc:	687b      	ldr	r3, [r7, #4]
 800cede:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800cee0:	2b00      	cmp	r3, #0
 800cee2:	d007      	beq.n	800cef4 <tcp_free_ooseq+0x20>
    tcp_segs_free(pcb->ooseq);
 800cee4:	687b      	ldr	r3, [r7, #4]
 800cee6:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800cee8:	0018      	movs	r0, r3
 800ceea:	f7ff fb3d 	bl	800c568 <tcp_segs_free>
    pcb->ooseq = NULL;
 800ceee:	687b      	ldr	r3, [r7, #4]
 800cef0:	2200      	movs	r2, #0
 800cef2:	679a      	str	r2, [r3, #120]	; 0x78
#if LWIP_TCP_SACK_OUT
    memset(pcb->rcv_sacks, 0, sizeof(pcb->rcv_sacks));
#endif /* LWIP_TCP_SACK_OUT */
  }
}
 800cef4:	46c0      	nop			; (mov r8, r8)
 800cef6:	46bd      	mov	sp, r7
 800cef8:	b002      	add	sp, #8
 800cefa:	bd80      	pop	{r7, pc}

0800cefc <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the TCP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
 800cefc:	b5f0      	push	{r4, r5, r6, r7, lr}
 800cefe:	b08f      	sub	sp, #60	; 0x3c
 800cf00:	af04      	add	r7, sp, #16
 800cf02:	6078      	str	r0, [r7, #4]
 800cf04:	6039      	str	r1, [r7, #0]
  struct tcp_pcb *pcb, *prev;
  struct tcp_pcb_listen *lpcb;
#if SO_REUSE
  struct tcp_pcb *lpcb_prev = NULL;
 800cf06:	2300      	movs	r3, #0
 800cf08:	61bb      	str	r3, [r7, #24]
  struct tcp_pcb_listen *lpcb_any = NULL;
 800cf0a:	2300      	movs	r3, #0
 800cf0c:	617b      	str	r3, [r7, #20]
  u8_t hdrlen_bytes;
  err_t err;

  LWIP_UNUSED_ARG(inp);
  LWIP_ASSERT_CORE_LOCKED();
  LWIP_ASSERT("tcp_input: invalid pbuf", p != NULL);
 800cf0e:	687b      	ldr	r3, [r7, #4]
 800cf10:	2b00      	cmp	r3, #0
 800cf12:	d105      	bne.n	800cf20 <tcp_input+0x24>
 800cf14:	4b3a      	ldr	r3, [pc, #232]	; (800d000 <tcp_input+0x104>)
 800cf16:	493b      	ldr	r1, [pc, #236]	; (800d004 <tcp_input+0x108>)
 800cf18:	483b      	ldr	r0, [pc, #236]	; (800d008 <tcp_input+0x10c>)
 800cf1a:	2283      	movs	r2, #131	; 0x83
 800cf1c:	f7f5 f962 	bl	80021e4 <app_debug_rtt_raw>
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  MIB2_STATS_INC(mib2.tcpinsegs);

  tcphdr = (struct tcp_hdr *)p->payload;
 800cf20:	687b      	ldr	r3, [r7, #4]
 800cf22:	685a      	ldr	r2, [r3, #4]
 800cf24:	4b39      	ldr	r3, [pc, #228]	; (800d00c <tcp_input+0x110>)
 800cf26:	601a      	str	r2, [r3, #0]
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* Check that TCP header fits in payload */
  if (p->len < TCP_HLEN) {
 800cf28:	687b      	ldr	r3, [r7, #4]
 800cf2a:	895b      	ldrh	r3, [r3, #10]
 800cf2c:	2b13      	cmp	r3, #19
 800cf2e:	d801      	bhi.n	800cf34 <tcp_input+0x38>
 800cf30:	f000 fd03 	bl	800d93a <tcp_input+0xa3e>
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||
 800cf34:	4b36      	ldr	r3, [pc, #216]	; (800d010 <tcp_input+0x114>)
 800cf36:	695a      	ldr	r2, [r3, #20]
 800cf38:	4b35      	ldr	r3, [pc, #212]	; (800d010 <tcp_input+0x114>)
 800cf3a:	681b      	ldr	r3, [r3, #0]
 800cf3c:	0019      	movs	r1, r3
 800cf3e:	0010      	movs	r0, r2
 800cf40:	f007 fae2 	bl	8014508 <ip4_addr_isbroadcast_u32>
 800cf44:	1e03      	subs	r3, r0, #0
 800cf46:	d001      	beq.n	800cf4c <tcp_input+0x50>
 800cf48:	f000 fcf9 	bl	800d93e <tcp_input+0xa42>
      ip_addr_ismulticast(ip_current_dest_addr())) {
 800cf4c:	4b30      	ldr	r3, [pc, #192]	; (800d010 <tcp_input+0x114>)
 800cf4e:	695b      	ldr	r3, [r3, #20]
 800cf50:	22f0      	movs	r2, #240	; 0xf0
 800cf52:	4013      	ands	r3, r2
  if (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||
 800cf54:	2be0      	cmp	r3, #224	; 0xe0
 800cf56:	d101      	bne.n	800cf5c <tcp_input+0x60>
 800cf58:	f000 fcf1 	bl	800d93e <tcp_input+0xa42>
  }

#if CHECKSUM_CHECK_TCP
  IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_TCP) {
    /* Verify TCP checksum. */
    u16_t chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
 800cf5c:	687b      	ldr	r3, [r7, #4]
 800cf5e:	891a      	ldrh	r2, [r3, #8]
 800cf60:	2510      	movs	r5, #16
 800cf62:	197c      	adds	r4, r7, r5
 800cf64:	492b      	ldr	r1, [pc, #172]	; (800d014 <tcp_input+0x118>)
 800cf66:	6878      	ldr	r0, [r7, #4]
 800cf68:	4b2b      	ldr	r3, [pc, #172]	; (800d018 <tcp_input+0x11c>)
 800cf6a:	9300      	str	r3, [sp, #0]
 800cf6c:	000b      	movs	r3, r1
 800cf6e:	2106      	movs	r1, #6
 800cf70:	f7fb fcef 	bl	8008952 <ip_chksum_pseudo>
 800cf74:	0003      	movs	r3, r0
 800cf76:	8023      	strh	r3, [r4, #0]
                                    ip_current_src_addr(), ip_current_dest_addr());
    if (chksum != 0) {
 800cf78:	197b      	adds	r3, r7, r5
 800cf7a:	881b      	ldrh	r3, [r3, #0]
 800cf7c:	2b00      	cmp	r3, #0
 800cf7e:	d001      	beq.n	800cf84 <tcp_input+0x88>
 800cf80:	f000 fcdf 	bl	800d942 <tcp_input+0xa46>
    }
  }
#endif /* CHECKSUM_CHECK_TCP */

  /* sanity-check header length */
  hdrlen_bytes = TCPH_HDRLEN_BYTES(tcphdr);
 800cf84:	4b21      	ldr	r3, [pc, #132]	; (800d00c <tcp_input+0x110>)
 800cf86:	681b      	ldr	r3, [r3, #0]
 800cf88:	7b1a      	ldrb	r2, [r3, #12]
 800cf8a:	7b5b      	ldrb	r3, [r3, #13]
 800cf8c:	021b      	lsls	r3, r3, #8
 800cf8e:	4313      	orrs	r3, r2
 800cf90:	b29b      	uxth	r3, r3
 800cf92:	0018      	movs	r0, r3
 800cf94:	f7fa fa34 	bl	8007400 <lwip_htons>
 800cf98:	0003      	movs	r3, r0
 800cf9a:	0b1b      	lsrs	r3, r3, #12
 800cf9c:	b29b      	uxth	r3, r3
 800cf9e:	b2da      	uxtb	r2, r3
 800cfa0:	210f      	movs	r1, #15
 800cfa2:	187b      	adds	r3, r7, r1
 800cfa4:	0092      	lsls	r2, r2, #2
 800cfa6:	701a      	strb	r2, [r3, #0]
  if ((hdrlen_bytes < TCP_HLEN) || (hdrlen_bytes > p->tot_len)) {
 800cfa8:	187b      	adds	r3, r7, r1
 800cfaa:	781b      	ldrb	r3, [r3, #0]
 800cfac:	2b13      	cmp	r3, #19
 800cfae:	d801      	bhi.n	800cfb4 <tcp_input+0xb8>
 800cfb0:	f000 fcc9 	bl	800d946 <tcp_input+0xa4a>
 800cfb4:	187b      	adds	r3, r7, r1
 800cfb6:	781b      	ldrb	r3, [r3, #0]
 800cfb8:	b29a      	uxth	r2, r3
 800cfba:	687b      	ldr	r3, [r7, #4]
 800cfbc:	891b      	ldrh	r3, [r3, #8]
 800cfbe:	429a      	cmp	r2, r3
 800cfc0:	d901      	bls.n	800cfc6 <tcp_input+0xca>
 800cfc2:	f000 fcc0 	bl	800d946 <tcp_input+0xa4a>
    goto dropped;
  }

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  tcphdr_optlen = (u16_t)(hdrlen_bytes - TCP_HLEN);
 800cfc6:	187b      	adds	r3, r7, r1
 800cfc8:	781b      	ldrb	r3, [r3, #0]
 800cfca:	b29b      	uxth	r3, r3
 800cfcc:	3b14      	subs	r3, #20
 800cfce:	b29a      	uxth	r2, r3
 800cfd0:	4b12      	ldr	r3, [pc, #72]	; (800d01c <tcp_input+0x120>)
 800cfd2:	801a      	strh	r2, [r3, #0]
  tcphdr_opt2 = NULL;
 800cfd4:	4b12      	ldr	r3, [pc, #72]	; (800d020 <tcp_input+0x124>)
 800cfd6:	2200      	movs	r2, #0
 800cfd8:	601a      	str	r2, [r3, #0]
  if (p->len >= hdrlen_bytes) {
 800cfda:	687b      	ldr	r3, [r7, #4]
 800cfdc:	895a      	ldrh	r2, [r3, #10]
 800cfde:	187b      	adds	r3, r7, r1
 800cfe0:	781b      	ldrb	r3, [r3, #0]
 800cfe2:	b29b      	uxth	r3, r3
 800cfe4:	429a      	cmp	r2, r3
 800cfe6:	d31f      	bcc.n	800d028 <tcp_input+0x12c>
    /* all options are in the first pbuf */
    tcphdr_opt1len = tcphdr_optlen;
 800cfe8:	4b0c      	ldr	r3, [pc, #48]	; (800d01c <tcp_input+0x120>)
 800cfea:	881a      	ldrh	r2, [r3, #0]
 800cfec:	4b0d      	ldr	r3, [pc, #52]	; (800d024 <tcp_input+0x128>)
 800cfee:	801a      	strh	r2, [r3, #0]
    pbuf_remove_header(p, hdrlen_bytes); /* cannot fail */
 800cff0:	187b      	adds	r3, r7, r1
 800cff2:	781a      	ldrb	r2, [r3, #0]
 800cff4:	687b      	ldr	r3, [r7, #4]
 800cff6:	0011      	movs	r1, r2
 800cff8:	0018      	movs	r0, r3
 800cffa:	f7fd f9d9 	bl	800a3b0 <pbuf_remove_header>
 800cffe:	e06b      	b.n	800d0d8 <tcp_input+0x1dc>
 800d000:	0802120c 	.word	0x0802120c
 800d004:	08021234 	.word	0x08021234
 800d008:	0802124c 	.word	0x0802124c
 800d00c:	20000c5c 	.word	0x20000c5c
 800d010:	20001138 	.word	0x20001138
 800d014:	20001148 	.word	0x20001148
 800d018:	2000114c 	.word	0x2000114c
 800d01c:	20000c60 	.word	0x20000c60
 800d020:	20000c64 	.word	0x20000c64
 800d024:	20000c62 	.word	0x20000c62
  } else {
    u16_t opt2len;
    /* TCP header fits into first pbuf, options don't - data is in the next pbuf */
    /* there must be a next pbuf, due to hdrlen_bytes sanity check above */
    LWIP_ASSERT("p->next != NULL", p->next != NULL);
 800d028:	687b      	ldr	r3, [r7, #4]
 800d02a:	681b      	ldr	r3, [r3, #0]
 800d02c:	2b00      	cmp	r3, #0
 800d02e:	d105      	bne.n	800d03c <tcp_input+0x140>
 800d030:	4bd0      	ldr	r3, [pc, #832]	; (800d374 <tcp_input+0x478>)
 800d032:	49d1      	ldr	r1, [pc, #836]	; (800d378 <tcp_input+0x47c>)
 800d034:	48d1      	ldr	r0, [pc, #836]	; (800d37c <tcp_input+0x480>)
 800d036:	22c2      	movs	r2, #194	; 0xc2
 800d038:	f7f5 f8d4 	bl	80021e4 <app_debug_rtt_raw>

    /* advance over the TCP header (cannot fail) */
    pbuf_remove_header(p, TCP_HLEN);
 800d03c:	687b      	ldr	r3, [r7, #4]
 800d03e:	2114      	movs	r1, #20
 800d040:	0018      	movs	r0, r3
 800d042:	f7fd f9b5 	bl	800a3b0 <pbuf_remove_header>

    /* determine how long the first and second parts of the options are */
    tcphdr_opt1len = p->len;
 800d046:	687b      	ldr	r3, [r7, #4]
 800d048:	895a      	ldrh	r2, [r3, #10]
 800d04a:	4bcd      	ldr	r3, [pc, #820]	; (800d380 <tcp_input+0x484>)
 800d04c:	801a      	strh	r2, [r3, #0]
    opt2len = (u16_t)(tcphdr_optlen - tcphdr_opt1len);
 800d04e:	4bcd      	ldr	r3, [pc, #820]	; (800d384 <tcp_input+0x488>)
 800d050:	8819      	ldrh	r1, [r3, #0]
 800d052:	4bcb      	ldr	r3, [pc, #812]	; (800d380 <tcp_input+0x484>)
 800d054:	881a      	ldrh	r2, [r3, #0]
 800d056:	240c      	movs	r4, #12
 800d058:	193b      	adds	r3, r7, r4
 800d05a:	1a8a      	subs	r2, r1, r2
 800d05c:	801a      	strh	r2, [r3, #0]

    /* options continue in the next pbuf: set p to zero length and hide the
        options in the next pbuf (adjusting p->tot_len) */
    pbuf_remove_header(p, tcphdr_opt1len);
 800d05e:	4bc8      	ldr	r3, [pc, #800]	; (800d380 <tcp_input+0x484>)
 800d060:	881b      	ldrh	r3, [r3, #0]
 800d062:	001a      	movs	r2, r3
 800d064:	687b      	ldr	r3, [r7, #4]
 800d066:	0011      	movs	r1, r2
 800d068:	0018      	movs	r0, r3
 800d06a:	f7fd f9a1 	bl	800a3b0 <pbuf_remove_header>

    /* check that the options fit in the second pbuf */
    if (opt2len > p->next->len) {
 800d06e:	687b      	ldr	r3, [r7, #4]
 800d070:	681b      	ldr	r3, [r3, #0]
 800d072:	895b      	ldrh	r3, [r3, #10]
 800d074:	193a      	adds	r2, r7, r4
 800d076:	8812      	ldrh	r2, [r2, #0]
 800d078:	429a      	cmp	r2, r3
 800d07a:	d901      	bls.n	800d080 <tcp_input+0x184>
 800d07c:	f000 fc65 	bl	800d94a <tcp_input+0xa4e>
      TCP_STATS_INC(tcp.lenerr);
      goto dropped;
    }

    /* remember the pointer to the second part of the options */
    tcphdr_opt2 = (u8_t *)p->next->payload;
 800d080:	687b      	ldr	r3, [r7, #4]
 800d082:	681b      	ldr	r3, [r3, #0]
 800d084:	685a      	ldr	r2, [r3, #4]
 800d086:	4bc0      	ldr	r3, [pc, #768]	; (800d388 <tcp_input+0x48c>)
 800d088:	601a      	str	r2, [r3, #0]

    /* advance p->next to point after the options, and manually
        adjust p->tot_len to keep it consistent with the changed p->next */
    pbuf_remove_header(p->next, opt2len);
 800d08a:	687b      	ldr	r3, [r7, #4]
 800d08c:	681a      	ldr	r2, [r3, #0]
 800d08e:	193b      	adds	r3, r7, r4
 800d090:	881b      	ldrh	r3, [r3, #0]
 800d092:	0019      	movs	r1, r3
 800d094:	0010      	movs	r0, r2
 800d096:	f7fd f98b 	bl	800a3b0 <pbuf_remove_header>
    p->tot_len = (u16_t)(p->tot_len - opt2len);
 800d09a:	687b      	ldr	r3, [r7, #4]
 800d09c:	891a      	ldrh	r2, [r3, #8]
 800d09e:	193b      	adds	r3, r7, r4
 800d0a0:	881b      	ldrh	r3, [r3, #0]
 800d0a2:	1ad3      	subs	r3, r2, r3
 800d0a4:	b29a      	uxth	r2, r3
 800d0a6:	687b      	ldr	r3, [r7, #4]
 800d0a8:	811a      	strh	r2, [r3, #8]

    LWIP_ASSERT("p->len == 0", p->len == 0);
 800d0aa:	687b      	ldr	r3, [r7, #4]
 800d0ac:	895b      	ldrh	r3, [r3, #10]
 800d0ae:	2b00      	cmp	r3, #0
 800d0b0:	d005      	beq.n	800d0be <tcp_input+0x1c2>
 800d0b2:	4bb0      	ldr	r3, [pc, #704]	; (800d374 <tcp_input+0x478>)
 800d0b4:	49b5      	ldr	r1, [pc, #724]	; (800d38c <tcp_input+0x490>)
 800d0b6:	48b1      	ldr	r0, [pc, #708]	; (800d37c <tcp_input+0x480>)
 800d0b8:	22df      	movs	r2, #223	; 0xdf
 800d0ba:	f7f5 f893 	bl	80021e4 <app_debug_rtt_raw>
    LWIP_ASSERT("p->tot_len == p->next->tot_len", p->tot_len == p->next->tot_len);
 800d0be:	687b      	ldr	r3, [r7, #4]
 800d0c0:	891a      	ldrh	r2, [r3, #8]
 800d0c2:	687b      	ldr	r3, [r7, #4]
 800d0c4:	681b      	ldr	r3, [r3, #0]
 800d0c6:	891b      	ldrh	r3, [r3, #8]
 800d0c8:	429a      	cmp	r2, r3
 800d0ca:	d005      	beq.n	800d0d8 <tcp_input+0x1dc>
 800d0cc:	4ba9      	ldr	r3, [pc, #676]	; (800d374 <tcp_input+0x478>)
 800d0ce:	49b0      	ldr	r1, [pc, #704]	; (800d390 <tcp_input+0x494>)
 800d0d0:	48aa      	ldr	r0, [pc, #680]	; (800d37c <tcp_input+0x480>)
 800d0d2:	22e0      	movs	r2, #224	; 0xe0
 800d0d4:	f7f5 f886 	bl	80021e4 <app_debug_rtt_raw>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = lwip_ntohs(tcphdr->src);
 800d0d8:	4bae      	ldr	r3, [pc, #696]	; (800d394 <tcp_input+0x498>)
 800d0da:	681b      	ldr	r3, [r3, #0]
 800d0dc:	781a      	ldrb	r2, [r3, #0]
 800d0de:	785b      	ldrb	r3, [r3, #1]
 800d0e0:	021b      	lsls	r3, r3, #8
 800d0e2:	4313      	orrs	r3, r2
 800d0e4:	b29a      	uxth	r2, r3
 800d0e6:	4bab      	ldr	r3, [pc, #684]	; (800d394 <tcp_input+0x498>)
 800d0e8:	681c      	ldr	r4, [r3, #0]
 800d0ea:	0010      	movs	r0, r2
 800d0ec:	f7fa f988 	bl	8007400 <lwip_htons>
 800d0f0:	0003      	movs	r3, r0
 800d0f2:	22ff      	movs	r2, #255	; 0xff
 800d0f4:	401a      	ands	r2, r3
 800d0f6:	0010      	movs	r0, r2
 800d0f8:	7822      	ldrb	r2, [r4, #0]
 800d0fa:	2100      	movs	r1, #0
 800d0fc:	400a      	ands	r2, r1
 800d0fe:	1c11      	adds	r1, r2, #0
 800d100:	1c02      	adds	r2, r0, #0
 800d102:	430a      	orrs	r2, r1
 800d104:	7022      	strb	r2, [r4, #0]
 800d106:	0a1b      	lsrs	r3, r3, #8
 800d108:	b299      	uxth	r1, r3
 800d10a:	7863      	ldrb	r3, [r4, #1]
 800d10c:	2200      	movs	r2, #0
 800d10e:	4013      	ands	r3, r2
 800d110:	1c1a      	adds	r2, r3, #0
 800d112:	1c0b      	adds	r3, r1, #0
 800d114:	4313      	orrs	r3, r2
 800d116:	7063      	strb	r3, [r4, #1]
  tcphdr->dest = lwip_ntohs(tcphdr->dest);
 800d118:	4b9e      	ldr	r3, [pc, #632]	; (800d394 <tcp_input+0x498>)
 800d11a:	681b      	ldr	r3, [r3, #0]
 800d11c:	789a      	ldrb	r2, [r3, #2]
 800d11e:	78db      	ldrb	r3, [r3, #3]
 800d120:	021b      	lsls	r3, r3, #8
 800d122:	4313      	orrs	r3, r2
 800d124:	b29a      	uxth	r2, r3
 800d126:	4b9b      	ldr	r3, [pc, #620]	; (800d394 <tcp_input+0x498>)
 800d128:	681c      	ldr	r4, [r3, #0]
 800d12a:	0010      	movs	r0, r2
 800d12c:	f7fa f968 	bl	8007400 <lwip_htons>
 800d130:	0003      	movs	r3, r0
 800d132:	22ff      	movs	r2, #255	; 0xff
 800d134:	401a      	ands	r2, r3
 800d136:	0010      	movs	r0, r2
 800d138:	78a2      	ldrb	r2, [r4, #2]
 800d13a:	2100      	movs	r1, #0
 800d13c:	400a      	ands	r2, r1
 800d13e:	1c11      	adds	r1, r2, #0
 800d140:	1c02      	adds	r2, r0, #0
 800d142:	430a      	orrs	r2, r1
 800d144:	70a2      	strb	r2, [r4, #2]
 800d146:	0a1b      	lsrs	r3, r3, #8
 800d148:	b299      	uxth	r1, r3
 800d14a:	78e3      	ldrb	r3, [r4, #3]
 800d14c:	2200      	movs	r2, #0
 800d14e:	4013      	ands	r3, r2
 800d150:	1c1a      	adds	r2, r3, #0
 800d152:	1c0b      	adds	r3, r1, #0
 800d154:	4313      	orrs	r3, r2
 800d156:	70e3      	strb	r3, [r4, #3]
  seqno = tcphdr->seqno = lwip_ntohl(tcphdr->seqno);
 800d158:	4b8e      	ldr	r3, [pc, #568]	; (800d394 <tcp_input+0x498>)
 800d15a:	681b      	ldr	r3, [r3, #0]
 800d15c:	791a      	ldrb	r2, [r3, #4]
 800d15e:	7959      	ldrb	r1, [r3, #5]
 800d160:	0209      	lsls	r1, r1, #8
 800d162:	430a      	orrs	r2, r1
 800d164:	7999      	ldrb	r1, [r3, #6]
 800d166:	0409      	lsls	r1, r1, #16
 800d168:	430a      	orrs	r2, r1
 800d16a:	79db      	ldrb	r3, [r3, #7]
 800d16c:	061b      	lsls	r3, r3, #24
 800d16e:	4313      	orrs	r3, r2
 800d170:	001a      	movs	r2, r3
 800d172:	4b88      	ldr	r3, [pc, #544]	; (800d394 <tcp_input+0x498>)
 800d174:	681c      	ldr	r4, [r3, #0]
 800d176:	0010      	movs	r0, r2
 800d178:	f7fa f958 	bl	800742c <lwip_htonl>
 800d17c:	0003      	movs	r3, r0
 800d17e:	22ff      	movs	r2, #255	; 0xff
 800d180:	401a      	ands	r2, r3
 800d182:	0010      	movs	r0, r2
 800d184:	7922      	ldrb	r2, [r4, #4]
 800d186:	2100      	movs	r1, #0
 800d188:	400a      	ands	r2, r1
 800d18a:	1c11      	adds	r1, r2, #0
 800d18c:	1c02      	adds	r2, r0, #0
 800d18e:	430a      	orrs	r2, r1
 800d190:	7122      	strb	r2, [r4, #4]
 800d192:	0a1a      	lsrs	r2, r3, #8
 800d194:	21ff      	movs	r1, #255	; 0xff
 800d196:	400a      	ands	r2, r1
 800d198:	0010      	movs	r0, r2
 800d19a:	7962      	ldrb	r2, [r4, #5]
 800d19c:	2100      	movs	r1, #0
 800d19e:	400a      	ands	r2, r1
 800d1a0:	1c11      	adds	r1, r2, #0
 800d1a2:	1c02      	adds	r2, r0, #0
 800d1a4:	430a      	orrs	r2, r1
 800d1a6:	7162      	strb	r2, [r4, #5]
 800d1a8:	0c1a      	lsrs	r2, r3, #16
 800d1aa:	21ff      	movs	r1, #255	; 0xff
 800d1ac:	400a      	ands	r2, r1
 800d1ae:	0010      	movs	r0, r2
 800d1b0:	79a2      	ldrb	r2, [r4, #6]
 800d1b2:	2100      	movs	r1, #0
 800d1b4:	400a      	ands	r2, r1
 800d1b6:	1c11      	adds	r1, r2, #0
 800d1b8:	1c02      	adds	r2, r0, #0
 800d1ba:	430a      	orrs	r2, r1
 800d1bc:	71a2      	strb	r2, [r4, #6]
 800d1be:	0e19      	lsrs	r1, r3, #24
 800d1c0:	79e3      	ldrb	r3, [r4, #7]
 800d1c2:	2200      	movs	r2, #0
 800d1c4:	4013      	ands	r3, r2
 800d1c6:	1c1a      	adds	r2, r3, #0
 800d1c8:	1c0b      	adds	r3, r1, #0
 800d1ca:	4313      	orrs	r3, r2
 800d1cc:	71e3      	strb	r3, [r4, #7]
 800d1ce:	7923      	ldrb	r3, [r4, #4]
 800d1d0:	7962      	ldrb	r2, [r4, #5]
 800d1d2:	0212      	lsls	r2, r2, #8
 800d1d4:	4313      	orrs	r3, r2
 800d1d6:	79a2      	ldrb	r2, [r4, #6]
 800d1d8:	0412      	lsls	r2, r2, #16
 800d1da:	4313      	orrs	r3, r2
 800d1dc:	79e2      	ldrb	r2, [r4, #7]
 800d1de:	0612      	lsls	r2, r2, #24
 800d1e0:	4313      	orrs	r3, r2
 800d1e2:	001a      	movs	r2, r3
 800d1e4:	4b6c      	ldr	r3, [pc, #432]	; (800d398 <tcp_input+0x49c>)
 800d1e6:	601a      	str	r2, [r3, #0]
  ackno = tcphdr->ackno = lwip_ntohl(tcphdr->ackno);
 800d1e8:	4b6a      	ldr	r3, [pc, #424]	; (800d394 <tcp_input+0x498>)
 800d1ea:	681b      	ldr	r3, [r3, #0]
 800d1ec:	7a1a      	ldrb	r2, [r3, #8]
 800d1ee:	7a59      	ldrb	r1, [r3, #9]
 800d1f0:	0209      	lsls	r1, r1, #8
 800d1f2:	430a      	orrs	r2, r1
 800d1f4:	7a99      	ldrb	r1, [r3, #10]
 800d1f6:	0409      	lsls	r1, r1, #16
 800d1f8:	430a      	orrs	r2, r1
 800d1fa:	7adb      	ldrb	r3, [r3, #11]
 800d1fc:	061b      	lsls	r3, r3, #24
 800d1fe:	4313      	orrs	r3, r2
 800d200:	001a      	movs	r2, r3
 800d202:	4b64      	ldr	r3, [pc, #400]	; (800d394 <tcp_input+0x498>)
 800d204:	681c      	ldr	r4, [r3, #0]
 800d206:	0010      	movs	r0, r2
 800d208:	f7fa f910 	bl	800742c <lwip_htonl>
 800d20c:	0003      	movs	r3, r0
 800d20e:	22ff      	movs	r2, #255	; 0xff
 800d210:	401a      	ands	r2, r3
 800d212:	0010      	movs	r0, r2
 800d214:	7a22      	ldrb	r2, [r4, #8]
 800d216:	2100      	movs	r1, #0
 800d218:	400a      	ands	r2, r1
 800d21a:	1c11      	adds	r1, r2, #0
 800d21c:	1c02      	adds	r2, r0, #0
 800d21e:	430a      	orrs	r2, r1
 800d220:	7222      	strb	r2, [r4, #8]
 800d222:	0a1a      	lsrs	r2, r3, #8
 800d224:	21ff      	movs	r1, #255	; 0xff
 800d226:	400a      	ands	r2, r1
 800d228:	0010      	movs	r0, r2
 800d22a:	7a62      	ldrb	r2, [r4, #9]
 800d22c:	2100      	movs	r1, #0
 800d22e:	400a      	ands	r2, r1
 800d230:	1c11      	adds	r1, r2, #0
 800d232:	1c02      	adds	r2, r0, #0
 800d234:	430a      	orrs	r2, r1
 800d236:	7262      	strb	r2, [r4, #9]
 800d238:	0c1a      	lsrs	r2, r3, #16
 800d23a:	21ff      	movs	r1, #255	; 0xff
 800d23c:	400a      	ands	r2, r1
 800d23e:	0010      	movs	r0, r2
 800d240:	7aa2      	ldrb	r2, [r4, #10]
 800d242:	2100      	movs	r1, #0
 800d244:	400a      	ands	r2, r1
 800d246:	1c11      	adds	r1, r2, #0
 800d248:	1c02      	adds	r2, r0, #0
 800d24a:	430a      	orrs	r2, r1
 800d24c:	72a2      	strb	r2, [r4, #10]
 800d24e:	0e19      	lsrs	r1, r3, #24
 800d250:	7ae3      	ldrb	r3, [r4, #11]
 800d252:	2200      	movs	r2, #0
 800d254:	4013      	ands	r3, r2
 800d256:	1c1a      	adds	r2, r3, #0
 800d258:	1c0b      	adds	r3, r1, #0
 800d25a:	4313      	orrs	r3, r2
 800d25c:	72e3      	strb	r3, [r4, #11]
 800d25e:	7a23      	ldrb	r3, [r4, #8]
 800d260:	7a62      	ldrb	r2, [r4, #9]
 800d262:	0212      	lsls	r2, r2, #8
 800d264:	4313      	orrs	r3, r2
 800d266:	7aa2      	ldrb	r2, [r4, #10]
 800d268:	0412      	lsls	r2, r2, #16
 800d26a:	4313      	orrs	r3, r2
 800d26c:	7ae2      	ldrb	r2, [r4, #11]
 800d26e:	0612      	lsls	r2, r2, #24
 800d270:	4313      	orrs	r3, r2
 800d272:	001a      	movs	r2, r3
 800d274:	4b49      	ldr	r3, [pc, #292]	; (800d39c <tcp_input+0x4a0>)
 800d276:	601a      	str	r2, [r3, #0]
  tcphdr->wnd = lwip_ntohs(tcphdr->wnd);
 800d278:	4b46      	ldr	r3, [pc, #280]	; (800d394 <tcp_input+0x498>)
 800d27a:	681b      	ldr	r3, [r3, #0]
 800d27c:	7b9a      	ldrb	r2, [r3, #14]
 800d27e:	7bdb      	ldrb	r3, [r3, #15]
 800d280:	021b      	lsls	r3, r3, #8
 800d282:	4313      	orrs	r3, r2
 800d284:	b29a      	uxth	r2, r3
 800d286:	4b43      	ldr	r3, [pc, #268]	; (800d394 <tcp_input+0x498>)
 800d288:	681c      	ldr	r4, [r3, #0]
 800d28a:	0010      	movs	r0, r2
 800d28c:	f7fa f8b8 	bl	8007400 <lwip_htons>
 800d290:	0003      	movs	r3, r0
 800d292:	22ff      	movs	r2, #255	; 0xff
 800d294:	401a      	ands	r2, r3
 800d296:	0010      	movs	r0, r2
 800d298:	7ba2      	ldrb	r2, [r4, #14]
 800d29a:	2100      	movs	r1, #0
 800d29c:	400a      	ands	r2, r1
 800d29e:	1c11      	adds	r1, r2, #0
 800d2a0:	1c02      	adds	r2, r0, #0
 800d2a2:	430a      	orrs	r2, r1
 800d2a4:	73a2      	strb	r2, [r4, #14]
 800d2a6:	0a1b      	lsrs	r3, r3, #8
 800d2a8:	b299      	uxth	r1, r3
 800d2aa:	7be3      	ldrb	r3, [r4, #15]
 800d2ac:	2200      	movs	r2, #0
 800d2ae:	4013      	ands	r3, r2
 800d2b0:	1c1a      	adds	r2, r3, #0
 800d2b2:	1c0b      	adds	r3, r1, #0
 800d2b4:	4313      	orrs	r3, r2
 800d2b6:	73e3      	strb	r3, [r4, #15]

  flags = TCPH_FLAGS(tcphdr);
 800d2b8:	4b36      	ldr	r3, [pc, #216]	; (800d394 <tcp_input+0x498>)
 800d2ba:	681b      	ldr	r3, [r3, #0]
 800d2bc:	7b1a      	ldrb	r2, [r3, #12]
 800d2be:	7b5b      	ldrb	r3, [r3, #13]
 800d2c0:	021b      	lsls	r3, r3, #8
 800d2c2:	4313      	orrs	r3, r2
 800d2c4:	b29b      	uxth	r3, r3
 800d2c6:	0018      	movs	r0, r3
 800d2c8:	f7fa f89a 	bl	8007400 <lwip_htons>
 800d2cc:	0003      	movs	r3, r0
 800d2ce:	b2db      	uxtb	r3, r3
 800d2d0:	223f      	movs	r2, #63	; 0x3f
 800d2d2:	4013      	ands	r3, r2
 800d2d4:	b2da      	uxtb	r2, r3
 800d2d6:	4b32      	ldr	r3, [pc, #200]	; (800d3a0 <tcp_input+0x4a4>)
 800d2d8:	701a      	strb	r2, [r3, #0]
  tcplen = p->tot_len;
 800d2da:	687b      	ldr	r3, [r7, #4]
 800d2dc:	891a      	ldrh	r2, [r3, #8]
 800d2de:	4b31      	ldr	r3, [pc, #196]	; (800d3a4 <tcp_input+0x4a8>)
 800d2e0:	801a      	strh	r2, [r3, #0]
  if (flags & (TCP_FIN | TCP_SYN)) {
 800d2e2:	4b2f      	ldr	r3, [pc, #188]	; (800d3a0 <tcp_input+0x4a4>)
 800d2e4:	781b      	ldrb	r3, [r3, #0]
 800d2e6:	001a      	movs	r2, r3
 800d2e8:	2303      	movs	r3, #3
 800d2ea:	4013      	ands	r3, r2
 800d2ec:	d00c      	beq.n	800d308 <tcp_input+0x40c>
    tcplen++;
 800d2ee:	4b2d      	ldr	r3, [pc, #180]	; (800d3a4 <tcp_input+0x4a8>)
 800d2f0:	881b      	ldrh	r3, [r3, #0]
 800d2f2:	3301      	adds	r3, #1
 800d2f4:	b29a      	uxth	r2, r3
 800d2f6:	4b2b      	ldr	r3, [pc, #172]	; (800d3a4 <tcp_input+0x4a8>)
 800d2f8:	801a      	strh	r2, [r3, #0]
    if (tcplen < p->tot_len) {
 800d2fa:	687b      	ldr	r3, [r7, #4]
 800d2fc:	891a      	ldrh	r2, [r3, #8]
 800d2fe:	4b29      	ldr	r3, [pc, #164]	; (800d3a4 <tcp_input+0x4a8>)
 800d300:	881b      	ldrh	r3, [r3, #0]
 800d302:	429a      	cmp	r2, r3
 800d304:	d900      	bls.n	800d308 <tcp_input+0x40c>
 800d306:	e322      	b.n	800d94e <tcp_input+0xa52>
    }
  }

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
 800d308:	2300      	movs	r3, #0
 800d30a:	627b      	str	r3, [r7, #36]	; 0x24

  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800d30c:	4b26      	ldr	r3, [pc, #152]	; (800d3a8 <tcp_input+0x4ac>)
 800d30e:	681b      	ldr	r3, [r3, #0]
 800d310:	623b      	str	r3, [r7, #32]
 800d312:	e0a1      	b.n	800d458 <tcp_input+0x55c>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
 800d314:	6a3b      	ldr	r3, [r7, #32]
 800d316:	7e1b      	ldrb	r3, [r3, #24]
 800d318:	2b00      	cmp	r3, #0
 800d31a:	d105      	bne.n	800d328 <tcp_input+0x42c>
 800d31c:	4b15      	ldr	r3, [pc, #84]	; (800d374 <tcp_input+0x478>)
 800d31e:	4923      	ldr	r1, [pc, #140]	; (800d3ac <tcp_input+0x4b0>)
 800d320:	4816      	ldr	r0, [pc, #88]	; (800d37c <tcp_input+0x480>)
 800d322:	22fb      	movs	r2, #251	; 0xfb
 800d324:	f7f4 ff5e 	bl	80021e4 <app_debug_rtt_raw>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
 800d328:	6a3b      	ldr	r3, [r7, #32]
 800d32a:	7e1b      	ldrb	r3, [r3, #24]
 800d32c:	2b0a      	cmp	r3, #10
 800d32e:	d105      	bne.n	800d33c <tcp_input+0x440>
 800d330:	4b10      	ldr	r3, [pc, #64]	; (800d374 <tcp_input+0x478>)
 800d332:	491f      	ldr	r1, [pc, #124]	; (800d3b0 <tcp_input+0x4b4>)
 800d334:	4811      	ldr	r0, [pc, #68]	; (800d37c <tcp_input+0x480>)
 800d336:	22fc      	movs	r2, #252	; 0xfc
 800d338:	f7f4 ff54 	bl	80021e4 <app_debug_rtt_raw>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
 800d33c:	6a3b      	ldr	r3, [r7, #32]
 800d33e:	7e1b      	ldrb	r3, [r3, #24]
 800d340:	2b01      	cmp	r3, #1
 800d342:	d105      	bne.n	800d350 <tcp_input+0x454>
 800d344:	4b0b      	ldr	r3, [pc, #44]	; (800d374 <tcp_input+0x478>)
 800d346:	491b      	ldr	r1, [pc, #108]	; (800d3b4 <tcp_input+0x4b8>)
 800d348:	480c      	ldr	r0, [pc, #48]	; (800d37c <tcp_input+0x480>)
 800d34a:	22fd      	movs	r2, #253	; 0xfd
 800d34c:	f7f4 ff4a 	bl	80021e4 <app_debug_rtt_raw>

    /* check if PCB is bound to specific netif */
    if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 800d350:	6a3b      	ldr	r3, [r7, #32]
 800d352:	7a1b      	ldrb	r3, [r3, #8]
 800d354:	2b00      	cmp	r3, #0
 800d356:	d031      	beq.n	800d3bc <tcp_input+0x4c0>
        (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 800d358:	6a3b      	ldr	r3, [r7, #32]
 800d35a:	7a1a      	ldrb	r2, [r3, #8]
 800d35c:	4b16      	ldr	r3, [pc, #88]	; (800d3b8 <tcp_input+0x4bc>)
 800d35e:	685b      	ldr	r3, [r3, #4]
 800d360:	2134      	movs	r1, #52	; 0x34
 800d362:	5c5b      	ldrb	r3, [r3, r1]
 800d364:	3301      	adds	r3, #1
 800d366:	b2db      	uxtb	r3, r3
    if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 800d368:	429a      	cmp	r2, r3
 800d36a:	d027      	beq.n	800d3bc <tcp_input+0x4c0>
      prev = pcb;
 800d36c:	6a3b      	ldr	r3, [r7, #32]
 800d36e:	627b      	str	r3, [r7, #36]	; 0x24
      continue;
 800d370:	e06f      	b.n	800d452 <tcp_input+0x556>
 800d372:	46c0      	nop			; (mov r8, r8)
 800d374:	0802120c 	.word	0x0802120c
 800d378:	08021278 	.word	0x08021278
 800d37c:	0802124c 	.word	0x0802124c
 800d380:	20000c62 	.word	0x20000c62
 800d384:	20000c60 	.word	0x20000c60
 800d388:	20000c64 	.word	0x20000c64
 800d38c:	08021288 	.word	0x08021288
 800d390:	08021294 	.word	0x08021294
 800d394:	20000c5c 	.word	0x20000c5c
 800d398:	20000c6c 	.word	0x20000c6c
 800d39c:	20000c70 	.word	0x20000c70
 800d3a0:	20000c78 	.word	0x20000c78
 800d3a4:	20000c76 	.word	0x20000c76
 800d3a8:	2000278c 	.word	0x2000278c
 800d3ac:	080212b4 	.word	0x080212b4
 800d3b0:	080212dc 	.word	0x080212dc
 800d3b4:	08021308 	.word	0x08021308
 800d3b8:	20001138 	.word	0x20001138
    }

    if (pcb->remote_port == tcphdr->src &&
 800d3bc:	6a3b      	ldr	r3, [r7, #32]
 800d3be:	8b9a      	ldrh	r2, [r3, #28]
 800d3c0:	4bcb      	ldr	r3, [pc, #812]	; (800d6f0 <tcp_input+0x7f4>)
 800d3c2:	681b      	ldr	r3, [r3, #0]
 800d3c4:	7819      	ldrb	r1, [r3, #0]
 800d3c6:	785b      	ldrb	r3, [r3, #1]
 800d3c8:	021b      	lsls	r3, r3, #8
 800d3ca:	430b      	orrs	r3, r1
 800d3cc:	b29b      	uxth	r3, r3
 800d3ce:	429a      	cmp	r2, r3
 800d3d0:	d13d      	bne.n	800d44e <tcp_input+0x552>
        pcb->local_port == tcphdr->dest &&
 800d3d2:	6a3b      	ldr	r3, [r7, #32]
 800d3d4:	8b5a      	ldrh	r2, [r3, #26]
 800d3d6:	4bc6      	ldr	r3, [pc, #792]	; (800d6f0 <tcp_input+0x7f4>)
 800d3d8:	681b      	ldr	r3, [r3, #0]
 800d3da:	7899      	ldrb	r1, [r3, #2]
 800d3dc:	78db      	ldrb	r3, [r3, #3]
 800d3de:	021b      	lsls	r3, r3, #8
 800d3e0:	430b      	orrs	r3, r1
 800d3e2:	b29b      	uxth	r3, r3
    if (pcb->remote_port == tcphdr->src &&
 800d3e4:	429a      	cmp	r2, r3
 800d3e6:	d132      	bne.n	800d44e <tcp_input+0x552>
        ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 800d3e8:	6a3b      	ldr	r3, [r7, #32]
 800d3ea:	685a      	ldr	r2, [r3, #4]
 800d3ec:	4bc1      	ldr	r3, [pc, #772]	; (800d6f4 <tcp_input+0x7f8>)
 800d3ee:	691b      	ldr	r3, [r3, #16]
        pcb->local_port == tcphdr->dest &&
 800d3f0:	429a      	cmp	r2, r3
 800d3f2:	d12c      	bne.n	800d44e <tcp_input+0x552>
        ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 800d3f4:	6a3b      	ldr	r3, [r7, #32]
 800d3f6:	681a      	ldr	r2, [r3, #0]
 800d3f8:	4bbe      	ldr	r3, [pc, #760]	; (800d6f4 <tcp_input+0x7f8>)
 800d3fa:	695b      	ldr	r3, [r3, #20]
        ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 800d3fc:	429a      	cmp	r2, r3
 800d3fe:	d126      	bne.n	800d44e <tcp_input+0x552>
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
 800d400:	6a3b      	ldr	r3, [r7, #32]
 800d402:	691b      	ldr	r3, [r3, #16]
 800d404:	6a3a      	ldr	r2, [r7, #32]
 800d406:	429a      	cmp	r2, r3
 800d408:	d106      	bne.n	800d418 <tcp_input+0x51c>
 800d40a:	4bbb      	ldr	r3, [pc, #748]	; (800d6f8 <tcp_input+0x7fc>)
 800d40c:	220e      	movs	r2, #14
 800d40e:	32ff      	adds	r2, #255	; 0xff
 800d410:	49ba      	ldr	r1, [pc, #744]	; (800d6fc <tcp_input+0x800>)
 800d412:	48bb      	ldr	r0, [pc, #748]	; (800d700 <tcp_input+0x804>)
 800d414:	f7f4 fee6 	bl	80021e4 <app_debug_rtt_raw>
      if (prev != NULL) {
 800d418:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d41a:	2b00      	cmp	r3, #0
 800d41c:	d00a      	beq.n	800d434 <tcp_input+0x538>
        prev->next = pcb->next;
 800d41e:	6a3b      	ldr	r3, [r7, #32]
 800d420:	691a      	ldr	r2, [r3, #16]
 800d422:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d424:	611a      	str	r2, [r3, #16]
        pcb->next = tcp_active_pcbs;
 800d426:	4bb7      	ldr	r3, [pc, #732]	; (800d704 <tcp_input+0x808>)
 800d428:	681a      	ldr	r2, [r3, #0]
 800d42a:	6a3b      	ldr	r3, [r7, #32]
 800d42c:	611a      	str	r2, [r3, #16]
        tcp_active_pcbs = pcb;
 800d42e:	4bb5      	ldr	r3, [pc, #724]	; (800d704 <tcp_input+0x808>)
 800d430:	6a3a      	ldr	r2, [r7, #32]
 800d432:	601a      	str	r2, [r3, #0]
      } else {
        TCP_STATS_INC(tcp.cachehit);
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
 800d434:	6a3b      	ldr	r3, [r7, #32]
 800d436:	691b      	ldr	r3, [r3, #16]
 800d438:	6a3a      	ldr	r2, [r7, #32]
 800d43a:	429a      	cmp	r2, r3
 800d43c:	d111      	bne.n	800d462 <tcp_input+0x566>
 800d43e:	4bae      	ldr	r3, [pc, #696]	; (800d6f8 <tcp_input+0x7fc>)
 800d440:	2216      	movs	r2, #22
 800d442:	32ff      	adds	r2, #255	; 0xff
 800d444:	49b0      	ldr	r1, [pc, #704]	; (800d708 <tcp_input+0x80c>)
 800d446:	48ae      	ldr	r0, [pc, #696]	; (800d700 <tcp_input+0x804>)
 800d448:	f7f4 fecc 	bl	80021e4 <app_debug_rtt_raw>
      break;
 800d44c:	e009      	b.n	800d462 <tcp_input+0x566>
    }
    prev = pcb;
 800d44e:	6a3b      	ldr	r3, [r7, #32]
 800d450:	627b      	str	r3, [r7, #36]	; 0x24
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800d452:	6a3b      	ldr	r3, [r7, #32]
 800d454:	691b      	ldr	r3, [r3, #16]
 800d456:	623b      	str	r3, [r7, #32]
 800d458:	6a3b      	ldr	r3, [r7, #32]
 800d45a:	2b00      	cmp	r3, #0
 800d45c:	d000      	beq.n	800d460 <tcp_input+0x564>
 800d45e:	e759      	b.n	800d314 <tcp_input+0x418>
 800d460:	e000      	b.n	800d464 <tcp_input+0x568>
      break;
 800d462:	46c0      	nop			; (mov r8, r8)
  }

  if (pcb == NULL) {
 800d464:	6a3b      	ldr	r3, [r7, #32]
 800d466:	2b00      	cmp	r3, #0
 800d468:	d000      	beq.n	800d46c <tcp_input+0x570>
 800d46a:	e0ac      	b.n	800d5c6 <tcp_input+0x6ca>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800d46c:	4ba7      	ldr	r3, [pc, #668]	; (800d70c <tcp_input+0x810>)
 800d46e:	681b      	ldr	r3, [r3, #0]
 800d470:	623b      	str	r3, [r7, #32]
 800d472:	e047      	b.n	800d504 <tcp_input+0x608>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 800d474:	6a3b      	ldr	r3, [r7, #32]
 800d476:	7e1b      	ldrb	r3, [r3, #24]
 800d478:	2b0a      	cmp	r3, #10
 800d47a:	d006      	beq.n	800d48a <tcp_input+0x58e>
 800d47c:	4b9e      	ldr	r3, [pc, #632]	; (800d6f8 <tcp_input+0x7fc>)
 800d47e:	2220      	movs	r2, #32
 800d480:	32ff      	adds	r2, #255	; 0xff
 800d482:	49a3      	ldr	r1, [pc, #652]	; (800d710 <tcp_input+0x814>)
 800d484:	489e      	ldr	r0, [pc, #632]	; (800d700 <tcp_input+0x804>)
 800d486:	f7f4 fead 	bl	80021e4 <app_debug_rtt_raw>

      /* check if PCB is bound to specific netif */
      if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 800d48a:	6a3b      	ldr	r3, [r7, #32]
 800d48c:	7a1b      	ldrb	r3, [r3, #8]
 800d48e:	2b00      	cmp	r3, #0
 800d490:	d009      	beq.n	800d4a6 <tcp_input+0x5aa>
          (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 800d492:	6a3b      	ldr	r3, [r7, #32]
 800d494:	7a1a      	ldrb	r2, [r3, #8]
 800d496:	4b97      	ldr	r3, [pc, #604]	; (800d6f4 <tcp_input+0x7f8>)
 800d498:	685b      	ldr	r3, [r3, #4]
 800d49a:	2134      	movs	r1, #52	; 0x34
 800d49c:	5c5b      	ldrb	r3, [r3, r1]
 800d49e:	3301      	adds	r3, #1
 800d4a0:	b2db      	uxtb	r3, r3
      if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 800d4a2:	429a      	cmp	r2, r3
 800d4a4:	d12a      	bne.n	800d4fc <tcp_input+0x600>
        continue;
      }

      if (pcb->remote_port == tcphdr->src &&
 800d4a6:	6a3b      	ldr	r3, [r7, #32]
 800d4a8:	8b9a      	ldrh	r2, [r3, #28]
 800d4aa:	4b91      	ldr	r3, [pc, #580]	; (800d6f0 <tcp_input+0x7f4>)
 800d4ac:	681b      	ldr	r3, [r3, #0]
 800d4ae:	7819      	ldrb	r1, [r3, #0]
 800d4b0:	785b      	ldrb	r3, [r3, #1]
 800d4b2:	021b      	lsls	r3, r3, #8
 800d4b4:	430b      	orrs	r3, r1
 800d4b6:	b29b      	uxth	r3, r3
 800d4b8:	429a      	cmp	r2, r3
 800d4ba:	d120      	bne.n	800d4fe <tcp_input+0x602>
          pcb->local_port == tcphdr->dest &&
 800d4bc:	6a3b      	ldr	r3, [r7, #32]
 800d4be:	8b5a      	ldrh	r2, [r3, #26]
 800d4c0:	4b8b      	ldr	r3, [pc, #556]	; (800d6f0 <tcp_input+0x7f4>)
 800d4c2:	681b      	ldr	r3, [r3, #0]
 800d4c4:	7899      	ldrb	r1, [r3, #2]
 800d4c6:	78db      	ldrb	r3, [r3, #3]
 800d4c8:	021b      	lsls	r3, r3, #8
 800d4ca:	430b      	orrs	r3, r1
 800d4cc:	b29b      	uxth	r3, r3
      if (pcb->remote_port == tcphdr->src &&
 800d4ce:	429a      	cmp	r2, r3
 800d4d0:	d115      	bne.n	800d4fe <tcp_input+0x602>
          ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 800d4d2:	6a3b      	ldr	r3, [r7, #32]
 800d4d4:	685a      	ldr	r2, [r3, #4]
 800d4d6:	4b87      	ldr	r3, [pc, #540]	; (800d6f4 <tcp_input+0x7f8>)
 800d4d8:	691b      	ldr	r3, [r3, #16]
          pcb->local_port == tcphdr->dest &&
 800d4da:	429a      	cmp	r2, r3
 800d4dc:	d10f      	bne.n	800d4fe <tcp_input+0x602>
          ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 800d4de:	6a3b      	ldr	r3, [r7, #32]
 800d4e0:	681a      	ldr	r2, [r3, #0]
 800d4e2:	4b84      	ldr	r3, [pc, #528]	; (800d6f4 <tcp_input+0x7f8>)
 800d4e4:	695b      	ldr	r3, [r3, #20]
          ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 800d4e6:	429a      	cmp	r2, r3
 800d4e8:	d109      	bne.n	800d4fe <tcp_input+0x602>
#ifdef LWIP_HOOK_TCP_INPACKET_PCB
        if (LWIP_HOOK_TCP_INPACKET_PCB(pcb, tcphdr, tcphdr_optlen, tcphdr_opt1len,
                                       tcphdr_opt2, p) == ERR_OK)
#endif
        {
          tcp_timewait_input(pcb);
 800d4ea:	6a3b      	ldr	r3, [r7, #32]
 800d4ec:	0018      	movs	r0, r3
 800d4ee:	f000 fbb5 	bl	800dc5c <tcp_timewait_input>
        }
        pbuf_free(p);
 800d4f2:	687b      	ldr	r3, [r7, #4]
 800d4f4:	0018      	movs	r0, r3
 800d4f6:	f7fc fff1 	bl	800a4dc <pbuf_free>
        return;
 800d4fa:	e22f      	b.n	800d95c <tcp_input+0xa60>
        continue;
 800d4fc:	46c0      	nop			; (mov r8, r8)
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800d4fe:	6a3b      	ldr	r3, [r7, #32]
 800d500:	691b      	ldr	r3, [r3, #16]
 800d502:	623b      	str	r3, [r7, #32]
 800d504:	6a3b      	ldr	r3, [r7, #32]
 800d506:	2b00      	cmp	r3, #0
 800d508:	d1b4      	bne.n	800d474 <tcp_input+0x578>
      }
    }

    /* Finally, if we still did not get a match, we check all PCBs that
       are LISTENing for incoming connections. */
    prev = NULL;
 800d50a:	2300      	movs	r3, #0
 800d50c:	627b      	str	r3, [r7, #36]	; 0x24
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 800d50e:	4b81      	ldr	r3, [pc, #516]	; (800d714 <tcp_input+0x818>)
 800d510:	681b      	ldr	r3, [r3, #0]
 800d512:	61fb      	str	r3, [r7, #28]
 800d514:	e031      	b.n	800d57a <tcp_input+0x67e>
      /* check if PCB is bound to specific netif */
      if ((lpcb->netif_idx != NETIF_NO_INDEX) &&
 800d516:	69fb      	ldr	r3, [r7, #28]
 800d518:	7a1b      	ldrb	r3, [r3, #8]
 800d51a:	2b00      	cmp	r3, #0
 800d51c:	d00c      	beq.n	800d538 <tcp_input+0x63c>
          (lpcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 800d51e:	69fb      	ldr	r3, [r7, #28]
 800d520:	7a1a      	ldrb	r2, [r3, #8]
 800d522:	4b74      	ldr	r3, [pc, #464]	; (800d6f4 <tcp_input+0x7f8>)
 800d524:	685b      	ldr	r3, [r3, #4]
 800d526:	2134      	movs	r1, #52	; 0x34
 800d528:	5c5b      	ldrb	r3, [r3, r1]
 800d52a:	3301      	adds	r3, #1
 800d52c:	b2db      	uxtb	r3, r3
      if ((lpcb->netif_idx != NETIF_NO_INDEX) &&
 800d52e:	429a      	cmp	r2, r3
 800d530:	d002      	beq.n	800d538 <tcp_input+0x63c>
        prev = (struct tcp_pcb *)lpcb;
 800d532:	69fb      	ldr	r3, [r7, #28]
 800d534:	627b      	str	r3, [r7, #36]	; 0x24
        continue;
 800d536:	e01d      	b.n	800d574 <tcp_input+0x678>
      }

      if (lpcb->local_port == tcphdr->dest) {
 800d538:	69fb      	ldr	r3, [r7, #28]
 800d53a:	8b5a      	ldrh	r2, [r3, #26]
 800d53c:	4b6c      	ldr	r3, [pc, #432]	; (800d6f0 <tcp_input+0x7f4>)
 800d53e:	681b      	ldr	r3, [r3, #0]
 800d540:	7899      	ldrb	r1, [r3, #2]
 800d542:	78db      	ldrb	r3, [r3, #3]
 800d544:	021b      	lsls	r3, r3, #8
 800d546:	430b      	orrs	r3, r1
 800d548:	b29b      	uxth	r3, r3
 800d54a:	429a      	cmp	r2, r3
 800d54c:	d110      	bne.n	800d570 <tcp_input+0x674>
          lpcb_prev = prev;
#else /* SO_REUSE */
          break;
#endif /* SO_REUSE */
        } else if (IP_ADDR_PCB_VERSION_MATCH_EXACT(lpcb, ip_current_dest_addr())) {
          if (ip_addr_cmp(&lpcb->local_ip, ip_current_dest_addr())) {
 800d54e:	69fb      	ldr	r3, [r7, #28]
 800d550:	681a      	ldr	r2, [r3, #0]
 800d552:	4b68      	ldr	r3, [pc, #416]	; (800d6f4 <tcp_input+0x7f8>)
 800d554:	695b      	ldr	r3, [r3, #20]
 800d556:	429a      	cmp	r2, r3
 800d558:	d013      	beq.n	800d582 <tcp_input+0x686>
            /* found an exact match */
            break;
          } else if (ip_addr_isany(&lpcb->local_ip)) {
 800d55a:	69fb      	ldr	r3, [r7, #28]
 800d55c:	2b00      	cmp	r3, #0
 800d55e:	d003      	beq.n	800d568 <tcp_input+0x66c>
 800d560:	69fb      	ldr	r3, [r7, #28]
 800d562:	681b      	ldr	r3, [r3, #0]
 800d564:	2b00      	cmp	r3, #0
 800d566:	d103      	bne.n	800d570 <tcp_input+0x674>
            /* found an ANY-match */
#if SO_REUSE
            lpcb_any = lpcb;
 800d568:	69fb      	ldr	r3, [r7, #28]
 800d56a:	617b      	str	r3, [r7, #20]
            lpcb_prev = prev;
 800d56c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d56e:	61bb      	str	r3, [r7, #24]
            break;
#endif /* SO_REUSE */
          }
        }
      }
      prev = (struct tcp_pcb *)lpcb;
 800d570:	69fb      	ldr	r3, [r7, #28]
 800d572:	627b      	str	r3, [r7, #36]	; 0x24
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 800d574:	69fb      	ldr	r3, [r7, #28]
 800d576:	691b      	ldr	r3, [r3, #16]
 800d578:	61fb      	str	r3, [r7, #28]
 800d57a:	69fb      	ldr	r3, [r7, #28]
 800d57c:	2b00      	cmp	r3, #0
 800d57e:	d1ca      	bne.n	800d516 <tcp_input+0x61a>
 800d580:	e000      	b.n	800d584 <tcp_input+0x688>
            break;
 800d582:	46c0      	nop			; (mov r8, r8)
    }
#if SO_REUSE
    /* first try specific local IP */
    if (lpcb == NULL) {
 800d584:	69fb      	ldr	r3, [r7, #28]
 800d586:	2b00      	cmp	r3, #0
 800d588:	d103      	bne.n	800d592 <tcp_input+0x696>
      /* only pass to ANY if no specific local IP has been found */
      lpcb = lpcb_any;
 800d58a:	697b      	ldr	r3, [r7, #20]
 800d58c:	61fb      	str	r3, [r7, #28]
      prev = lpcb_prev;
 800d58e:	69bb      	ldr	r3, [r7, #24]
 800d590:	627b      	str	r3, [r7, #36]	; 0x24
    }
#endif /* SO_REUSE */
    if (lpcb != NULL) {
 800d592:	69fb      	ldr	r3, [r7, #28]
 800d594:	2b00      	cmp	r3, #0
 800d596:	d016      	beq.n	800d5c6 <tcp_input+0x6ca>
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      if (prev != NULL) {
 800d598:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d59a:	2b00      	cmp	r3, #0
 800d59c:	d00a      	beq.n	800d5b4 <tcp_input+0x6b8>
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
 800d59e:	69fb      	ldr	r3, [r7, #28]
 800d5a0:	691a      	ldr	r2, [r3, #16]
 800d5a2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d5a4:	611a      	str	r2, [r3, #16]
        /* our successor is the remainder of the listening list */
        lpcb->next = tcp_listen_pcbs.listen_pcbs;
 800d5a6:	4b5b      	ldr	r3, [pc, #364]	; (800d714 <tcp_input+0x818>)
 800d5a8:	681a      	ldr	r2, [r3, #0]
 800d5aa:	69fb      	ldr	r3, [r7, #28]
 800d5ac:	611a      	str	r2, [r3, #16]
        /* put this listening pcb at the head of the listening list */
        tcp_listen_pcbs.listen_pcbs = lpcb;
 800d5ae:	4b59      	ldr	r3, [pc, #356]	; (800d714 <tcp_input+0x818>)
 800d5b0:	69fa      	ldr	r2, [r7, #28]
 800d5b2:	601a      	str	r2, [r3, #0]
#ifdef LWIP_HOOK_TCP_INPACKET_PCB
      if (LWIP_HOOK_TCP_INPACKET_PCB((struct tcp_pcb *)lpcb, tcphdr, tcphdr_optlen,
                                     tcphdr_opt1len, tcphdr_opt2, p) == ERR_OK)
#endif
      {
        tcp_listen_input(lpcb);
 800d5b4:	69fb      	ldr	r3, [r7, #28]
 800d5b6:	0018      	movs	r0, r3
 800d5b8:	f000 fa34 	bl	800da24 <tcp_listen_input>
      }
      pbuf_free(p);
 800d5bc:	687b      	ldr	r3, [r7, #4]
 800d5be:	0018      	movs	r0, r3
 800d5c0:	f7fc ff8c 	bl	800a4dc <pbuf_free>
      return;
 800d5c4:	e1ca      	b.n	800d95c <tcp_input+0xa60>
      tcphdr_opt1len, tcphdr_opt2, p) != ERR_OK) {
    pbuf_free(p);
    return;
  }
#endif
  if (pcb != NULL) {
 800d5c6:	6a3b      	ldr	r3, [r7, #32]
 800d5c8:	2b00      	cmp	r3, #0
 800d5ca:	d100      	bne.n	800d5ce <tcp_input+0x6d2>
 800d5cc:	e17f      	b.n	800d8ce <tcp_input+0x9d2>
#if TCP_INPUT_DEBUG
    tcp_debug_print_state(pcb->state);
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
 800d5ce:	4b52      	ldr	r3, [pc, #328]	; (800d718 <tcp_input+0x81c>)
 800d5d0:	2200      	movs	r2, #0
 800d5d2:	601a      	str	r2, [r3, #0]
    inseg.len = p->tot_len;
 800d5d4:	687b      	ldr	r3, [r7, #4]
 800d5d6:	891a      	ldrh	r2, [r3, #8]
 800d5d8:	4b4f      	ldr	r3, [pc, #316]	; (800d718 <tcp_input+0x81c>)
 800d5da:	811a      	strh	r2, [r3, #8]
    inseg.p = p;
 800d5dc:	4b4e      	ldr	r3, [pc, #312]	; (800d718 <tcp_input+0x81c>)
 800d5de:	687a      	ldr	r2, [r7, #4]
 800d5e0:	605a      	str	r2, [r3, #4]
    inseg.tcphdr = tcphdr;
 800d5e2:	4b43      	ldr	r3, [pc, #268]	; (800d6f0 <tcp_input+0x7f4>)
 800d5e4:	681a      	ldr	r2, [r3, #0]
 800d5e6:	4b4c      	ldr	r3, [pc, #304]	; (800d718 <tcp_input+0x81c>)
 800d5e8:	611a      	str	r2, [r3, #16]

    recv_data = NULL;
 800d5ea:	4b4c      	ldr	r3, [pc, #304]	; (800d71c <tcp_input+0x820>)
 800d5ec:	2200      	movs	r2, #0
 800d5ee:	601a      	str	r2, [r3, #0]
    recv_flags = 0;
 800d5f0:	4b4b      	ldr	r3, [pc, #300]	; (800d720 <tcp_input+0x824>)
 800d5f2:	2200      	movs	r2, #0
 800d5f4:	701a      	strb	r2, [r3, #0]
    recv_acked = 0;
 800d5f6:	4b4b      	ldr	r3, [pc, #300]	; (800d724 <tcp_input+0x828>)
 800d5f8:	2200      	movs	r2, #0
 800d5fa:	801a      	strh	r2, [r3, #0]

    if (flags & TCP_PSH) {
 800d5fc:	4b4a      	ldr	r3, [pc, #296]	; (800d728 <tcp_input+0x82c>)
 800d5fe:	781b      	ldrb	r3, [r3, #0]
 800d600:	001a      	movs	r2, r3
 800d602:	2308      	movs	r3, #8
 800d604:	4013      	ands	r3, r2
 800d606:	d006      	beq.n	800d616 <tcp_input+0x71a>
      p->flags |= PBUF_FLAG_PUSH;
 800d608:	687b      	ldr	r3, [r7, #4]
 800d60a:	7b5b      	ldrb	r3, [r3, #13]
 800d60c:	2201      	movs	r2, #1
 800d60e:	4313      	orrs	r3, r2
 800d610:	b2da      	uxtb	r2, r3
 800d612:	687b      	ldr	r3, [r7, #4]
 800d614:	735a      	strb	r2, [r3, #13]
    }

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
 800d616:	6a3b      	ldr	r3, [r7, #32]
 800d618:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800d61a:	2b00      	cmp	r3, #0
 800d61c:	d018      	beq.n	800d650 <tcp_input+0x754>
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 800d61e:	6a3b      	ldr	r3, [r7, #32]
 800d620:	0018      	movs	r0, r3
 800d622:	f7fe ff1b 	bl	800c45c <tcp_process_refused_data>
 800d626:	0003      	movs	r3, r0
 800d628:	330d      	adds	r3, #13
 800d62a:	d007      	beq.n	800d63c <tcp_input+0x740>
          ((pcb->refused_data != NULL) && (tcplen > 0))) {
 800d62c:	6a3b      	ldr	r3, [r7, #32]
 800d62e:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 800d630:	2b00      	cmp	r3, #0
 800d632:	d00d      	beq.n	800d650 <tcp_input+0x754>
          ((pcb->refused_data != NULL) && (tcplen > 0))) {
 800d634:	4b3d      	ldr	r3, [pc, #244]	; (800d72c <tcp_input+0x830>)
 800d636:	881b      	ldrh	r3, [r3, #0]
 800d638:	2b00      	cmp	r3, #0
 800d63a:	d009      	beq.n	800d650 <tcp_input+0x754>
        /* pcb has been aborted or refused data is still refused and the new
           segment contains data */
        if (pcb->rcv_ann_wnd == 0) {
 800d63c:	6a3b      	ldr	r3, [r7, #32]
 800d63e:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
 800d640:	2b00      	cmp	r3, #0
 800d642:	d000      	beq.n	800d646 <tcp_input+0x74a>
 800d644:	e123      	b.n	800d88e <tcp_input+0x992>
          /* this is a zero-window probe, we respond to it with current RCV.NXT
          and drop the data segment */
          tcp_send_empty_ack(pcb);
 800d646:	6a3b      	ldr	r3, [r7, #32]
 800d648:	0018      	movs	r0, r3
 800d64a:	f004 ff53 	bl	80124f4 <tcp_send_empty_ack>
        }
        TCP_STATS_INC(tcp.drop);
        MIB2_STATS_INC(mib2.tcpinerrs);
        goto aborted;
 800d64e:	e11e      	b.n	800d88e <tcp_input+0x992>
      }
    }
    tcp_input_pcb = pcb;
 800d650:	4b37      	ldr	r3, [pc, #220]	; (800d730 <tcp_input+0x834>)
 800d652:	6a3a      	ldr	r2, [r7, #32]
 800d654:	601a      	str	r2, [r3, #0]
    err = tcp_process(pcb);
 800d656:	2513      	movs	r5, #19
 800d658:	197c      	adds	r4, r7, r5
 800d65a:	6a3b      	ldr	r3, [r7, #32]
 800d65c:	0018      	movs	r0, r3
 800d65e:	f000 fb81 	bl	800dd64 <tcp_process>
 800d662:	0003      	movs	r3, r0
 800d664:	7023      	strb	r3, [r4, #0]
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
 800d666:	197b      	adds	r3, r7, r5
 800d668:	781b      	ldrb	r3, [r3, #0]
 800d66a:	b25b      	sxtb	r3, r3
 800d66c:	330d      	adds	r3, #13
 800d66e:	d100      	bne.n	800d672 <tcp_input+0x776>
 800d670:	e10f      	b.n	800d892 <tcp_input+0x996>
      if (recv_flags & TF_RESET) {
 800d672:	4b2b      	ldr	r3, [pc, #172]	; (800d720 <tcp_input+0x824>)
 800d674:	781b      	ldrb	r3, [r3, #0]
 800d676:	001a      	movs	r2, r3
 800d678:	2308      	movs	r3, #8
 800d67a:	4013      	ands	r3, r2
 800d67c:	d018      	beq.n	800d6b0 <tcp_input+0x7b4>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_RST);
 800d67e:	6a3b      	ldr	r3, [r7, #32]
 800d680:	2294      	movs	r2, #148	; 0x94
 800d682:	589b      	ldr	r3, [r3, r2]
 800d684:	2b00      	cmp	r3, #0
 800d686:	d008      	beq.n	800d69a <tcp_input+0x79e>
 800d688:	6a3b      	ldr	r3, [r7, #32]
 800d68a:	2294      	movs	r2, #148	; 0x94
 800d68c:	589a      	ldr	r2, [r3, r2]
 800d68e:	6a3b      	ldr	r3, [r7, #32]
 800d690:	695b      	ldr	r3, [r3, #20]
 800d692:	210e      	movs	r1, #14
 800d694:	4249      	negs	r1, r1
 800d696:	0018      	movs	r0, r3
 800d698:	4790      	blx	r2
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
 800d69a:	6a3a      	ldr	r2, [r7, #32]
 800d69c:	4b19      	ldr	r3, [pc, #100]	; (800d704 <tcp_input+0x808>)
 800d69e:	0011      	movs	r1, r2
 800d6a0:	0018      	movs	r0, r3
 800d6a2:	f7ff fa91 	bl	800cbc8 <tcp_pcb_remove>
        tcp_free(pcb);
 800d6a6:	6a3b      	ldr	r3, [r7, #32]
 800d6a8:	0018      	movs	r0, r3
 800d6aa:	f7fd fcb5 	bl	800b018 <tcp_free>
 800d6ae:	e0fb      	b.n	800d8a8 <tcp_input+0x9ac>
      } else {
        err = ERR_OK;
 800d6b0:	2113      	movs	r1, #19
 800d6b2:	187b      	adds	r3, r7, r1
 800d6b4:	2200      	movs	r2, #0
 800d6b6:	701a      	strb	r2, [r3, #0]
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (recv_acked > 0) {
 800d6b8:	4b1a      	ldr	r3, [pc, #104]	; (800d724 <tcp_input+0x828>)
 800d6ba:	881b      	ldrh	r3, [r3, #0]
 800d6bc:	2b00      	cmp	r3, #0
 800d6be:	d047      	beq.n	800d750 <tcp_input+0x854>
          while (acked > 0) {
            acked16 = (u16_t)LWIP_MIN(acked, 0xffffu);
            acked -= acked16;
#else
          {
            acked16 = recv_acked;
 800d6c0:	260a      	movs	r6, #10
 800d6c2:	19bb      	adds	r3, r7, r6
 800d6c4:	4a17      	ldr	r2, [pc, #92]	; (800d724 <tcp_input+0x828>)
 800d6c6:	8812      	ldrh	r2, [r2, #0]
 800d6c8:	801a      	strh	r2, [r3, #0]
#endif
            TCP_EVENT_SENT(pcb, (u16_t)acked16, err);
 800d6ca:	6a3b      	ldr	r3, [r7, #32]
 800d6cc:	2284      	movs	r2, #132	; 0x84
 800d6ce:	589b      	ldr	r3, [r3, r2]
 800d6d0:	2b00      	cmp	r3, #0
 800d6d2:	d02f      	beq.n	800d734 <tcp_input+0x838>
 800d6d4:	6a3b      	ldr	r3, [r7, #32]
 800d6d6:	2284      	movs	r2, #132	; 0x84
 800d6d8:	589d      	ldr	r5, [r3, r2]
 800d6da:	6a3b      	ldr	r3, [r7, #32]
 800d6dc:	6958      	ldr	r0, [r3, #20]
 800d6de:	187c      	adds	r4, r7, r1
 800d6e0:	19bb      	adds	r3, r7, r6
 800d6e2:	881a      	ldrh	r2, [r3, #0]
 800d6e4:	6a3b      	ldr	r3, [r7, #32]
 800d6e6:	0019      	movs	r1, r3
 800d6e8:	47a8      	blx	r5
 800d6ea:	0003      	movs	r3, r0
 800d6ec:	7023      	strb	r3, [r4, #0]
 800d6ee:	e025      	b.n	800d73c <tcp_input+0x840>
 800d6f0:	20000c5c 	.word	0x20000c5c
 800d6f4:	20001138 	.word	0x20001138
 800d6f8:	0802120c 	.word	0x0802120c
 800d6fc:	08021330 	.word	0x08021330
 800d700:	0802124c 	.word	0x0802124c
 800d704:	2000278c 	.word	0x2000278c
 800d708:	0802135c 	.word	0x0802135c
 800d70c:	2000279c 	.word	0x2000279c
 800d710:	08021388 	.word	0x08021388
 800d714:	20002794 	.word	0x20002794
 800d718:	20000c48 	.word	0x20000c48
 800d71c:	20000c7c 	.word	0x20000c7c
 800d720:	20000c79 	.word	0x20000c79
 800d724:	20000c74 	.word	0x20000c74
 800d728:	20000c78 	.word	0x20000c78
 800d72c:	20000c76 	.word	0x20000c76
 800d730:	200027a0 	.word	0x200027a0
 800d734:	2313      	movs	r3, #19
 800d736:	18fb      	adds	r3, r7, r3
 800d738:	2200      	movs	r2, #0
 800d73a:	701a      	strb	r2, [r3, #0]
            if (err == ERR_ABRT) {
 800d73c:	2313      	movs	r3, #19
 800d73e:	18fb      	adds	r3, r7, r3
 800d740:	781b      	ldrb	r3, [r3, #0]
 800d742:	b25b      	sxtb	r3, r3
 800d744:	330d      	adds	r3, #13
 800d746:	d100      	bne.n	800d74a <tcp_input+0x84e>
 800d748:	e0a5      	b.n	800d896 <tcp_input+0x99a>
              goto aborted;
            }
          }
          recv_acked = 0;
 800d74a:	4b86      	ldr	r3, [pc, #536]	; (800d964 <tcp_input+0xa68>)
 800d74c:	2200      	movs	r2, #0
 800d74e:	801a      	strh	r2, [r3, #0]
        }
        if (tcp_input_delayed_close(pcb)) {
 800d750:	6a3b      	ldr	r3, [r7, #32]
 800d752:	0018      	movs	r0, r3
 800d754:	f000 f922 	bl	800d99c <tcp_input_delayed_close>
 800d758:	1e03      	subs	r3, r0, #0
 800d75a:	d000      	beq.n	800d75e <tcp_input+0x862>
 800d75c:	e09d      	b.n	800d89a <tcp_input+0x99e>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
        while (recv_data != NULL) {
          struct pbuf *rest = NULL;
          pbuf_split_64k(recv_data, &rest);
#else /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
        if (recv_data != NULL) {
 800d75e:	4b82      	ldr	r3, [pc, #520]	; (800d968 <tcp_input+0xa6c>)
 800d760:	681b      	ldr	r3, [r3, #0]
 800d762:	2b00      	cmp	r3, #0
 800d764:	d048      	beq.n	800d7f8 <tcp_input+0x8fc>
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */

          LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
 800d766:	6a3b      	ldr	r3, [r7, #32]
 800d768:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800d76a:	2b00      	cmp	r3, #0
 800d76c:	d006      	beq.n	800d77c <tcp_input+0x880>
 800d76e:	4b7f      	ldr	r3, [pc, #508]	; (800d96c <tcp_input+0xa70>)
 800d770:	22f3      	movs	r2, #243	; 0xf3
 800d772:	0052      	lsls	r2, r2, #1
 800d774:	497e      	ldr	r1, [pc, #504]	; (800d970 <tcp_input+0xa74>)
 800d776:	487f      	ldr	r0, [pc, #508]	; (800d974 <tcp_input+0xa78>)
 800d778:	f7f4 fd34 	bl	80021e4 <app_debug_rtt_raw>
          if (pcb->flags & TF_RXCLOSED) {
 800d77c:	6a3b      	ldr	r3, [r7, #32]
 800d77e:	8bdb      	ldrh	r3, [r3, #30]
 800d780:	001a      	movs	r2, r3
 800d782:	2310      	movs	r3, #16
 800d784:	4013      	ands	r3, r2
 800d786:	d009      	beq.n	800d79c <tcp_input+0x8a0>
            /* received data although already closed -> abort (send RST) to
               notify the remote host that not all data has been processed */
            pbuf_free(recv_data);
 800d788:	4b77      	ldr	r3, [pc, #476]	; (800d968 <tcp_input+0xa6c>)
 800d78a:	681b      	ldr	r3, [r3, #0]
 800d78c:	0018      	movs	r0, r3
 800d78e:	f7fc fea5 	bl	800a4dc <pbuf_free>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
            if (rest != NULL) {
              pbuf_free(rest);
            }
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
            tcp_abort(pcb);
 800d792:	6a3b      	ldr	r3, [r7, #32]
 800d794:	0018      	movs	r0, r3
 800d796:	f7fd ff55 	bl	800b644 <tcp_abort>
            goto aborted;
 800d79a:	e085      	b.n	800d8a8 <tcp_input+0x9ac>
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 800d79c:	6a3b      	ldr	r3, [r7, #32]
 800d79e:	2288      	movs	r2, #136	; 0x88
 800d7a0:	589b      	ldr	r3, [r3, r2]
 800d7a2:	2b00      	cmp	r3, #0
 800d7a4:	d00e      	beq.n	800d7c4 <tcp_input+0x8c8>
 800d7a6:	6a3b      	ldr	r3, [r7, #32]
 800d7a8:	2288      	movs	r2, #136	; 0x88
 800d7aa:	589d      	ldr	r5, [r3, r2]
 800d7ac:	6a3b      	ldr	r3, [r7, #32]
 800d7ae:	6958      	ldr	r0, [r3, #20]
 800d7b0:	4b6d      	ldr	r3, [pc, #436]	; (800d968 <tcp_input+0xa6c>)
 800d7b2:	681a      	ldr	r2, [r3, #0]
 800d7b4:	2313      	movs	r3, #19
 800d7b6:	18fc      	adds	r4, r7, r3
 800d7b8:	6a39      	ldr	r1, [r7, #32]
 800d7ba:	2300      	movs	r3, #0
 800d7bc:	47a8      	blx	r5
 800d7be:	0003      	movs	r3, r0
 800d7c0:	7023      	strb	r3, [r4, #0]
 800d7c2:	e00a      	b.n	800d7da <tcp_input+0x8de>
 800d7c4:	4b68      	ldr	r3, [pc, #416]	; (800d968 <tcp_input+0xa6c>)
 800d7c6:	681a      	ldr	r2, [r3, #0]
 800d7c8:	2313      	movs	r3, #19
 800d7ca:	18fc      	adds	r4, r7, r3
 800d7cc:	6a39      	ldr	r1, [r7, #32]
 800d7ce:	2300      	movs	r3, #0
 800d7d0:	2000      	movs	r0, #0
 800d7d2:	f7fe ff29 	bl	800c628 <tcp_recv_null>
 800d7d6:	0003      	movs	r3, r0
 800d7d8:	7023      	strb	r3, [r4, #0]
          if (err == ERR_ABRT) {
 800d7da:	2213      	movs	r2, #19
 800d7dc:	18bb      	adds	r3, r7, r2
 800d7de:	781b      	ldrb	r3, [r3, #0]
 800d7e0:	b25b      	sxtb	r3, r3
 800d7e2:	330d      	adds	r3, #13
 800d7e4:	d05b      	beq.n	800d89e <tcp_input+0x9a2>
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
            goto aborted;
          }

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
 800d7e6:	18bb      	adds	r3, r7, r2
 800d7e8:	781b      	ldrb	r3, [r3, #0]
 800d7ea:	b25b      	sxtb	r3, r3
 800d7ec:	2b00      	cmp	r3, #0
 800d7ee:	d003      	beq.n	800d7f8 <tcp_input+0x8fc>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
            if (rest != NULL) {
              pbuf_cat(recv_data, rest);
            }
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
            pcb->refused_data = recv_data;
 800d7f0:	4b5d      	ldr	r3, [pc, #372]	; (800d968 <tcp_input+0xa6c>)
 800d7f2:	681a      	ldr	r2, [r3, #0]
 800d7f4:	6a3b      	ldr	r3, [r7, #32]
 800d7f6:	67da      	str	r2, [r3, #124]	; 0x7c
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
 800d7f8:	4b5f      	ldr	r3, [pc, #380]	; (800d978 <tcp_input+0xa7c>)
 800d7fa:	781b      	ldrb	r3, [r3, #0]
 800d7fc:	001a      	movs	r2, r3
 800d7fe:	2320      	movs	r3, #32
 800d800:	4013      	ands	r3, r2
 800d802:	d036      	beq.n	800d872 <tcp_input+0x976>
          if (pcb->refused_data != NULL) {
 800d804:	6a3b      	ldr	r3, [r7, #32]
 800d806:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800d808:	2b00      	cmp	r3, #0
 800d80a:	d009      	beq.n	800d820 <tcp_input+0x924>
            /* Delay this if we have refused data. */
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
 800d80c:	6a3b      	ldr	r3, [r7, #32]
 800d80e:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800d810:	7b5a      	ldrb	r2, [r3, #13]
 800d812:	6a3b      	ldr	r3, [r7, #32]
 800d814:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800d816:	2120      	movs	r1, #32
 800d818:	430a      	orrs	r2, r1
 800d81a:	b2d2      	uxtb	r2, r2
 800d81c:	735a      	strb	r2, [r3, #13]
 800d81e:	e028      	b.n	800d872 <tcp_input+0x976>
          } else {
            /* correct rcv_wnd as the application won't call tcp_recved()
               for the FIN's seqno */
            if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
 800d820:	6a3b      	ldr	r3, [r7, #32]
 800d822:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800d824:	2386      	movs	r3, #134	; 0x86
 800d826:	00db      	lsls	r3, r3, #3
 800d828:	429a      	cmp	r2, r3
 800d82a:	d005      	beq.n	800d838 <tcp_input+0x93c>
              pcb->rcv_wnd++;
 800d82c:	6a3b      	ldr	r3, [r7, #32]
 800d82e:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 800d830:	3301      	adds	r3, #1
 800d832:	b29a      	uxth	r2, r3
 800d834:	6a3b      	ldr	r3, [r7, #32]
 800d836:	859a      	strh	r2, [r3, #44]	; 0x2c
            }
            TCP_EVENT_CLOSED(pcb, err);
 800d838:	6a3b      	ldr	r3, [r7, #32]
 800d83a:	2288      	movs	r2, #136	; 0x88
 800d83c:	589b      	ldr	r3, [r3, r2]
 800d83e:	2b00      	cmp	r3, #0
 800d840:	d00d      	beq.n	800d85e <tcp_input+0x962>
 800d842:	6a3b      	ldr	r3, [r7, #32]
 800d844:	2288      	movs	r2, #136	; 0x88
 800d846:	589d      	ldr	r5, [r3, r2]
 800d848:	6a3b      	ldr	r3, [r7, #32]
 800d84a:	6958      	ldr	r0, [r3, #20]
 800d84c:	2313      	movs	r3, #19
 800d84e:	18fc      	adds	r4, r7, r3
 800d850:	6a39      	ldr	r1, [r7, #32]
 800d852:	2300      	movs	r3, #0
 800d854:	2200      	movs	r2, #0
 800d856:	47a8      	blx	r5
 800d858:	0003      	movs	r3, r0
 800d85a:	7023      	strb	r3, [r4, #0]
 800d85c:	e003      	b.n	800d866 <tcp_input+0x96a>
 800d85e:	2313      	movs	r3, #19
 800d860:	18fb      	adds	r3, r7, r3
 800d862:	2200      	movs	r2, #0
 800d864:	701a      	strb	r2, [r3, #0]
            if (err == ERR_ABRT) {
 800d866:	2313      	movs	r3, #19
 800d868:	18fb      	adds	r3, r7, r3
 800d86a:	781b      	ldrb	r3, [r3, #0]
 800d86c:	b25b      	sxtb	r3, r3
 800d86e:	330d      	adds	r3, #13
 800d870:	d017      	beq.n	800d8a2 <tcp_input+0x9a6>
              goto aborted;
            }
          }
        }

        tcp_input_pcb = NULL;
 800d872:	4b42      	ldr	r3, [pc, #264]	; (800d97c <tcp_input+0xa80>)
 800d874:	2200      	movs	r2, #0
 800d876:	601a      	str	r2, [r3, #0]
        if (tcp_input_delayed_close(pcb)) {
 800d878:	6a3b      	ldr	r3, [r7, #32]
 800d87a:	0018      	movs	r0, r3
 800d87c:	f000 f88e 	bl	800d99c <tcp_input_delayed_close>
 800d880:	1e03      	subs	r3, r0, #0
 800d882:	d110      	bne.n	800d8a6 <tcp_input+0x9aa>
          goto aborted;
        }
        /* Try to send something out. */
        tcp_output(pcb);
 800d884:	6a3b      	ldr	r3, [r7, #32]
 800d886:	0018      	movs	r0, r3
 800d888:	f003 fd80 	bl	801138c <tcp_output>
 800d88c:	e00c      	b.n	800d8a8 <tcp_input+0x9ac>
        goto aborted;
 800d88e:	46c0      	nop			; (mov r8, r8)
 800d890:	e00a      	b.n	800d8a8 <tcp_input+0x9ac>
#endif /* TCP_INPUT_DEBUG */
      }
    }
    /* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).
       Below this line, 'pcb' may not be dereferenced! */
aborted:
 800d892:	46c0      	nop			; (mov r8, r8)
 800d894:	e008      	b.n	800d8a8 <tcp_input+0x9ac>
              goto aborted;
 800d896:	46c0      	nop			; (mov r8, r8)
 800d898:	e006      	b.n	800d8a8 <tcp_input+0x9ac>
          goto aborted;
 800d89a:	46c0      	nop			; (mov r8, r8)
 800d89c:	e004      	b.n	800d8a8 <tcp_input+0x9ac>
            goto aborted;
 800d89e:	46c0      	nop			; (mov r8, r8)
 800d8a0:	e002      	b.n	800d8a8 <tcp_input+0x9ac>
              goto aborted;
 800d8a2:	46c0      	nop			; (mov r8, r8)
 800d8a4:	e000      	b.n	800d8a8 <tcp_input+0x9ac>
          goto aborted;
 800d8a6:	46c0      	nop			; (mov r8, r8)
    tcp_input_pcb = NULL;
 800d8a8:	4b34      	ldr	r3, [pc, #208]	; (800d97c <tcp_input+0xa80>)
 800d8aa:	2200      	movs	r2, #0
 800d8ac:	601a      	str	r2, [r3, #0]
    recv_data = NULL;
 800d8ae:	4b2e      	ldr	r3, [pc, #184]	; (800d968 <tcp_input+0xa6c>)
 800d8b0:	2200      	movs	r2, #0
 800d8b2:	601a      	str	r2, [r3, #0]

    /* give up our reference to inseg.p */
    if (inseg.p != NULL) {
 800d8b4:	4b32      	ldr	r3, [pc, #200]	; (800d980 <tcp_input+0xa84>)
 800d8b6:	685b      	ldr	r3, [r3, #4]
 800d8b8:	2b00      	cmp	r3, #0
 800d8ba:	d04e      	beq.n	800d95a <tcp_input+0xa5e>
      pbuf_free(inseg.p);
 800d8bc:	4b30      	ldr	r3, [pc, #192]	; (800d980 <tcp_input+0xa84>)
 800d8be:	685b      	ldr	r3, [r3, #4]
 800d8c0:	0018      	movs	r0, r3
 800d8c2:	f7fc fe0b 	bl	800a4dc <pbuf_free>
      inseg.p = NULL;
 800d8c6:	4b2e      	ldr	r3, [pc, #184]	; (800d980 <tcp_input+0xa84>)
 800d8c8:	2200      	movs	r2, #0
 800d8ca:	605a      	str	r2, [r3, #4]
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
 800d8cc:	e045      	b.n	800d95a <tcp_input+0xa5e>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
 800d8ce:	4b2d      	ldr	r3, [pc, #180]	; (800d984 <tcp_input+0xa88>)
 800d8d0:	681b      	ldr	r3, [r3, #0]
 800d8d2:	7b1a      	ldrb	r2, [r3, #12]
 800d8d4:	7b5b      	ldrb	r3, [r3, #13]
 800d8d6:	021b      	lsls	r3, r3, #8
 800d8d8:	4313      	orrs	r3, r2
 800d8da:	b29b      	uxth	r3, r3
 800d8dc:	0018      	movs	r0, r3
 800d8de:	f7f9 fd8f 	bl	8007400 <lwip_htons>
 800d8e2:	0003      	movs	r3, r0
 800d8e4:	b2db      	uxtb	r3, r3
 800d8e6:	001a      	movs	r2, r3
 800d8e8:	2304      	movs	r3, #4
 800d8ea:	4013      	ands	r3, r2
 800d8ec:	d120      	bne.n	800d930 <tcp_input+0xa34>
      tcp_rst(NULL, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d8ee:	4b26      	ldr	r3, [pc, #152]	; (800d988 <tcp_input+0xa8c>)
 800d8f0:	6818      	ldr	r0, [r3, #0]
 800d8f2:	4b26      	ldr	r3, [pc, #152]	; (800d98c <tcp_input+0xa90>)
 800d8f4:	881b      	ldrh	r3, [r3, #0]
 800d8f6:	001a      	movs	r2, r3
 800d8f8:	4b25      	ldr	r3, [pc, #148]	; (800d990 <tcp_input+0xa94>)
 800d8fa:	681b      	ldr	r3, [r3, #0]
 800d8fc:	18d4      	adds	r4, r2, r3
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800d8fe:	4b21      	ldr	r3, [pc, #132]	; (800d984 <tcp_input+0xa88>)
 800d900:	681b      	ldr	r3, [r3, #0]
      tcp_rst(NULL, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d902:	789a      	ldrb	r2, [r3, #2]
 800d904:	78db      	ldrb	r3, [r3, #3]
 800d906:	021b      	lsls	r3, r3, #8
 800d908:	4313      	orrs	r3, r2
 800d90a:	b29a      	uxth	r2, r3
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800d90c:	4b1d      	ldr	r3, [pc, #116]	; (800d984 <tcp_input+0xa88>)
 800d90e:	681b      	ldr	r3, [r3, #0]
      tcp_rst(NULL, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d910:	7819      	ldrb	r1, [r3, #0]
 800d912:	785b      	ldrb	r3, [r3, #1]
 800d914:	021b      	lsls	r3, r3, #8
 800d916:	430b      	orrs	r3, r1
 800d918:	b29b      	uxth	r3, r3
 800d91a:	491e      	ldr	r1, [pc, #120]	; (800d994 <tcp_input+0xa98>)
 800d91c:	9302      	str	r3, [sp, #8]
 800d91e:	9201      	str	r2, [sp, #4]
 800d920:	4b1d      	ldr	r3, [pc, #116]	; (800d998 <tcp_input+0xa9c>)
 800d922:	9300      	str	r3, [sp, #0]
 800d924:	000b      	movs	r3, r1
 800d926:	0022      	movs	r2, r4
 800d928:	0001      	movs	r1, r0
 800d92a:	2000      	movs	r0, #0
 800d92c:	f004 fd82 	bl	8012434 <tcp_rst>
    pbuf_free(p);
 800d930:	687b      	ldr	r3, [r7, #4]
 800d932:	0018      	movs	r0, r3
 800d934:	f7fc fdd2 	bl	800a4dc <pbuf_free>
  return;
 800d938:	e00f      	b.n	800d95a <tcp_input+0xa5e>
    goto dropped;
 800d93a:	46c0      	nop			; (mov r8, r8)
 800d93c:	e008      	b.n	800d950 <tcp_input+0xa54>
    goto dropped;
 800d93e:	46c0      	nop			; (mov r8, r8)
 800d940:	e006      	b.n	800d950 <tcp_input+0xa54>
      goto dropped;
 800d942:	46c0      	nop			; (mov r8, r8)
 800d944:	e004      	b.n	800d950 <tcp_input+0xa54>
    goto dropped;
 800d946:	46c0      	nop			; (mov r8, r8)
 800d948:	e002      	b.n	800d950 <tcp_input+0xa54>
      goto dropped;
 800d94a:	46c0      	nop			; (mov r8, r8)
 800d94c:	e000      	b.n	800d950 <tcp_input+0xa54>
      goto dropped;
 800d94e:	46c0      	nop			; (mov r8, r8)
dropped:
  TCP_STATS_INC(tcp.drop);
  MIB2_STATS_INC(mib2.tcpinerrs);
  pbuf_free(p);
 800d950:	687b      	ldr	r3, [r7, #4]
 800d952:	0018      	movs	r0, r3
 800d954:	f7fc fdc2 	bl	800a4dc <pbuf_free>
 800d958:	e000      	b.n	800d95c <tcp_input+0xa60>
  return;
 800d95a:	46c0      	nop			; (mov r8, r8)
}
 800d95c:	46bd      	mov	sp, r7
 800d95e:	b00b      	add	sp, #44	; 0x2c
 800d960:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800d962:	46c0      	nop			; (mov r8, r8)
 800d964:	20000c74 	.word	0x20000c74
 800d968:	20000c7c 	.word	0x20000c7c
 800d96c:	0802120c 	.word	0x0802120c
 800d970:	080213b8 	.word	0x080213b8
 800d974:	0802124c 	.word	0x0802124c
 800d978:	20000c79 	.word	0x20000c79
 800d97c:	200027a0 	.word	0x200027a0
 800d980:	20000c48 	.word	0x20000c48
 800d984:	20000c5c 	.word	0x20000c5c
 800d988:	20000c70 	.word	0x20000c70
 800d98c:	20000c76 	.word	0x20000c76
 800d990:	20000c6c 	.word	0x20000c6c
 800d994:	2000114c 	.word	0x2000114c
 800d998:	20001148 	.word	0x20001148

0800d99c <tcp_input_delayed_close>:
 * any more.
 * @returns 1 if the pcb has been closed and deallocated, 0 otherwise
 */
static int
tcp_input_delayed_close(struct tcp_pcb *pcb)
{
 800d99c:	b580      	push	{r7, lr}
 800d99e:	b082      	sub	sp, #8
 800d9a0:	af00      	add	r7, sp, #0
 800d9a2:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_input_delayed_close: invalid pcb", pcb != NULL);
 800d9a4:	687b      	ldr	r3, [r7, #4]
 800d9a6:	2b00      	cmp	r3, #0
 800d9a8:	d105      	bne.n	800d9b6 <tcp_input_delayed_close+0x1a>
 800d9aa:	4b18      	ldr	r3, [pc, #96]	; (800da0c <tcp_input_delayed_close+0x70>)
 800d9ac:	4a18      	ldr	r2, [pc, #96]	; (800da10 <tcp_input_delayed_close+0x74>)
 800d9ae:	4919      	ldr	r1, [pc, #100]	; (800da14 <tcp_input_delayed_close+0x78>)
 800d9b0:	4819      	ldr	r0, [pc, #100]	; (800da18 <tcp_input_delayed_close+0x7c>)
 800d9b2:	f7f4 fc17 	bl	80021e4 <app_debug_rtt_raw>

  if (recv_flags & TF_CLOSED) {
 800d9b6:	4b19      	ldr	r3, [pc, #100]	; (800da1c <tcp_input_delayed_close+0x80>)
 800d9b8:	781b      	ldrb	r3, [r3, #0]
 800d9ba:	001a      	movs	r2, r3
 800d9bc:	2310      	movs	r3, #16
 800d9be:	4013      	ands	r3, r2
 800d9c0:	d01f      	beq.n	800da02 <tcp_input_delayed_close+0x66>
    /* The connection has been closed and we will deallocate the
        PCB. */
    if (!(pcb->flags & TF_RXCLOSED)) {
 800d9c2:	687b      	ldr	r3, [r7, #4]
 800d9c4:	8bdb      	ldrh	r3, [r3, #30]
 800d9c6:	001a      	movs	r2, r3
 800d9c8:	2310      	movs	r3, #16
 800d9ca:	4013      	ands	r3, r2
 800d9cc:	d10d      	bne.n	800d9ea <tcp_input_delayed_close+0x4e>
      /* Connection closed although the application has only shut down the
          tx side: call the PCB's err callback and indicate the closure to
          ensure the application doesn't continue using the PCB. */
      TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_CLSD);
 800d9ce:	687b      	ldr	r3, [r7, #4]
 800d9d0:	2294      	movs	r2, #148	; 0x94
 800d9d2:	589b      	ldr	r3, [r3, r2]
 800d9d4:	2b00      	cmp	r3, #0
 800d9d6:	d008      	beq.n	800d9ea <tcp_input_delayed_close+0x4e>
 800d9d8:	687b      	ldr	r3, [r7, #4]
 800d9da:	2294      	movs	r2, #148	; 0x94
 800d9dc:	589a      	ldr	r2, [r3, r2]
 800d9de:	687b      	ldr	r3, [r7, #4]
 800d9e0:	695b      	ldr	r3, [r3, #20]
 800d9e2:	210f      	movs	r1, #15
 800d9e4:	4249      	negs	r1, r1
 800d9e6:	0018      	movs	r0, r3
 800d9e8:	4790      	blx	r2
    }
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
 800d9ea:	687a      	ldr	r2, [r7, #4]
 800d9ec:	4b0c      	ldr	r3, [pc, #48]	; (800da20 <tcp_input_delayed_close+0x84>)
 800d9ee:	0011      	movs	r1, r2
 800d9f0:	0018      	movs	r0, r3
 800d9f2:	f7ff f8e9 	bl	800cbc8 <tcp_pcb_remove>
    tcp_free(pcb);
 800d9f6:	687b      	ldr	r3, [r7, #4]
 800d9f8:	0018      	movs	r0, r3
 800d9fa:	f7fd fb0d 	bl	800b018 <tcp_free>
    return 1;
 800d9fe:	2301      	movs	r3, #1
 800da00:	e000      	b.n	800da04 <tcp_input_delayed_close+0x68>
  }
  return 0;
 800da02:	2300      	movs	r3, #0
}
 800da04:	0018      	movs	r0, r3
 800da06:	46bd      	mov	sp, r7
 800da08:	b002      	add	sp, #8
 800da0a:	bd80      	pop	{r7, pc}
 800da0c:	0802120c 	.word	0x0802120c
 800da10:	0000025a 	.word	0x0000025a
 800da14:	080213d4 	.word	0x080213d4
 800da18:	0802124c 	.word	0x0802124c
 800da1c:	20000c79 	.word	0x20000c79
 800da20:	2000278c 	.word	0x2000278c

0800da24 <tcp_listen_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static void
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
 800da24:	b5b0      	push	{r4, r5, r7, lr}
 800da26:	b08a      	sub	sp, #40	; 0x28
 800da28:	af04      	add	r7, sp, #16
 800da2a:	6078      	str	r0, [r7, #4]
  struct tcp_pcb *npcb;
  u32_t iss;
  err_t rc;

  if (flags & TCP_RST) {
 800da2c:	4b7d      	ldr	r3, [pc, #500]	; (800dc24 <tcp_listen_input+0x200>)
 800da2e:	781b      	ldrb	r3, [r3, #0]
 800da30:	001a      	movs	r2, r3
 800da32:	2304      	movs	r3, #4
 800da34:	4013      	ands	r3, r2
 800da36:	d000      	beq.n	800da3a <tcp_listen_input+0x16>
 800da38:	e0ee      	b.n	800dc18 <tcp_listen_input+0x1f4>
    /* An incoming RST should be ignored. Return. */
    return;
  }

  LWIP_ASSERT("tcp_listen_input: invalid pcb", pcb != NULL);
 800da3a:	687b      	ldr	r3, [r7, #4]
 800da3c:	2b00      	cmp	r3, #0
 800da3e:	d105      	bne.n	800da4c <tcp_listen_input+0x28>
 800da40:	4b79      	ldr	r3, [pc, #484]	; (800dc28 <tcp_listen_input+0x204>)
 800da42:	4a7a      	ldr	r2, [pc, #488]	; (800dc2c <tcp_listen_input+0x208>)
 800da44:	497a      	ldr	r1, [pc, #488]	; (800dc30 <tcp_listen_input+0x20c>)
 800da46:	487b      	ldr	r0, [pc, #492]	; (800dc34 <tcp_listen_input+0x210>)
 800da48:	f7f4 fbcc 	bl	80021e4 <app_debug_rtt_raw>

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
 800da4c:	4b75      	ldr	r3, [pc, #468]	; (800dc24 <tcp_listen_input+0x200>)
 800da4e:	781b      	ldrb	r3, [r3, #0]
 800da50:	001a      	movs	r2, r3
 800da52:	2310      	movs	r3, #16
 800da54:	4013      	ands	r3, r2
 800da56:	d021      	beq.n	800da9c <tcp_listen_input+0x78>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst((const struct tcp_pcb *)pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800da58:	4b77      	ldr	r3, [pc, #476]	; (800dc38 <tcp_listen_input+0x214>)
 800da5a:	681c      	ldr	r4, [r3, #0]
 800da5c:	4b77      	ldr	r3, [pc, #476]	; (800dc3c <tcp_listen_input+0x218>)
 800da5e:	881b      	ldrh	r3, [r3, #0]
 800da60:	001a      	movs	r2, r3
 800da62:	4b77      	ldr	r3, [pc, #476]	; (800dc40 <tcp_listen_input+0x21c>)
 800da64:	681b      	ldr	r3, [r3, #0]
 800da66:	18d5      	adds	r5, r2, r3
            ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800da68:	4b76      	ldr	r3, [pc, #472]	; (800dc44 <tcp_listen_input+0x220>)
 800da6a:	681b      	ldr	r3, [r3, #0]
    tcp_rst((const struct tcp_pcb *)pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800da6c:	789a      	ldrb	r2, [r3, #2]
 800da6e:	78db      	ldrb	r3, [r3, #3]
 800da70:	021b      	lsls	r3, r3, #8
 800da72:	4313      	orrs	r3, r2
 800da74:	b29a      	uxth	r2, r3
            ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800da76:	4b73      	ldr	r3, [pc, #460]	; (800dc44 <tcp_listen_input+0x220>)
 800da78:	681b      	ldr	r3, [r3, #0]
    tcp_rst((const struct tcp_pcb *)pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800da7a:	7819      	ldrb	r1, [r3, #0]
 800da7c:	785b      	ldrb	r3, [r3, #1]
 800da7e:	021b      	lsls	r3, r3, #8
 800da80:	430b      	orrs	r3, r1
 800da82:	b29b      	uxth	r3, r3
 800da84:	4970      	ldr	r1, [pc, #448]	; (800dc48 <tcp_listen_input+0x224>)
 800da86:	6878      	ldr	r0, [r7, #4]
 800da88:	9302      	str	r3, [sp, #8]
 800da8a:	9201      	str	r2, [sp, #4]
 800da8c:	4b6f      	ldr	r3, [pc, #444]	; (800dc4c <tcp_listen_input+0x228>)
 800da8e:	9300      	str	r3, [sp, #0]
 800da90:	000b      	movs	r3, r1
 800da92:	002a      	movs	r2, r5
 800da94:	0021      	movs	r1, r4
 800da96:	f004 fccd 	bl	8012434 <tcp_rst>
      tcp_abandon(npcb, 0);
      return;
    }
    tcp_output(npcb);
  }
  return;
 800da9a:	e0bf      	b.n	800dc1c <tcp_listen_input+0x1f8>
  } else if (flags & TCP_SYN) {
 800da9c:	4b61      	ldr	r3, [pc, #388]	; (800dc24 <tcp_listen_input+0x200>)
 800da9e:	781b      	ldrb	r3, [r3, #0]
 800daa0:	001a      	movs	r2, r3
 800daa2:	2302      	movs	r3, #2
 800daa4:	4013      	ands	r3, r2
 800daa6:	d100      	bne.n	800daaa <tcp_listen_input+0x86>
 800daa8:	e0b8      	b.n	800dc1c <tcp_listen_input+0x1f8>
    npcb = tcp_alloc(pcb->prio);
 800daaa:	687b      	ldr	r3, [r7, #4]
 800daac:	7e5b      	ldrb	r3, [r3, #25]
 800daae:	0018      	movs	r0, r3
 800dab0:	f7fe fef2 	bl	800c898 <tcp_alloc>
 800dab4:	0003      	movs	r3, r0
 800dab6:	617b      	str	r3, [r7, #20]
    if (npcb == NULL) {
 800dab8:	697b      	ldr	r3, [r7, #20]
 800daba:	2b00      	cmp	r3, #0
 800dabc:	d116      	bne.n	800daec <tcp_listen_input+0xc8>
      TCP_EVENT_ACCEPT(pcb, NULL, pcb->callback_arg, ERR_MEM, err);
 800dabe:	687b      	ldr	r3, [r7, #4]
 800dac0:	69db      	ldr	r3, [r3, #28]
 800dac2:	2b00      	cmp	r3, #0
 800dac4:	d00d      	beq.n	800dae2 <tcp_listen_input+0xbe>
 800dac6:	687b      	ldr	r3, [r7, #4]
 800dac8:	69dd      	ldr	r5, [r3, #28]
 800daca:	687b      	ldr	r3, [r7, #4]
 800dacc:	695b      	ldr	r3, [r3, #20]
 800dace:	220e      	movs	r2, #14
 800dad0:	18bc      	adds	r4, r7, r2
 800dad2:	2201      	movs	r2, #1
 800dad4:	4252      	negs	r2, r2
 800dad6:	2100      	movs	r1, #0
 800dad8:	0018      	movs	r0, r3
 800dada:	47a8      	blx	r5
 800dadc:	0003      	movs	r3, r0
 800dade:	7023      	strb	r3, [r4, #0]
      return;
 800dae0:	e09d      	b.n	800dc1e <tcp_listen_input+0x1fa>
      TCP_EVENT_ACCEPT(pcb, NULL, pcb->callback_arg, ERR_MEM, err);
 800dae2:	230e      	movs	r3, #14
 800dae4:	18fb      	adds	r3, r7, r3
 800dae6:	22f0      	movs	r2, #240	; 0xf0
 800dae8:	701a      	strb	r2, [r3, #0]
      return;
 800daea:	e098      	b.n	800dc1e <tcp_listen_input+0x1fa>
    ip_addr_copy(npcb->local_ip, *ip_current_dest_addr());
 800daec:	4b58      	ldr	r3, [pc, #352]	; (800dc50 <tcp_listen_input+0x22c>)
 800daee:	695a      	ldr	r2, [r3, #20]
 800daf0:	697b      	ldr	r3, [r7, #20]
 800daf2:	601a      	str	r2, [r3, #0]
    ip_addr_copy(npcb->remote_ip, *ip_current_src_addr());
 800daf4:	4b56      	ldr	r3, [pc, #344]	; (800dc50 <tcp_listen_input+0x22c>)
 800daf6:	691a      	ldr	r2, [r3, #16]
 800daf8:	697b      	ldr	r3, [r7, #20]
 800dafa:	605a      	str	r2, [r3, #4]
    npcb->local_port = pcb->local_port;
 800dafc:	687b      	ldr	r3, [r7, #4]
 800dafe:	8b5a      	ldrh	r2, [r3, #26]
 800db00:	697b      	ldr	r3, [r7, #20]
 800db02:	835a      	strh	r2, [r3, #26]
    npcb->remote_port = tcphdr->src;
 800db04:	4b4f      	ldr	r3, [pc, #316]	; (800dc44 <tcp_listen_input+0x220>)
 800db06:	681b      	ldr	r3, [r3, #0]
 800db08:	781a      	ldrb	r2, [r3, #0]
 800db0a:	785b      	ldrb	r3, [r3, #1]
 800db0c:	021b      	lsls	r3, r3, #8
 800db0e:	4313      	orrs	r3, r2
 800db10:	b29a      	uxth	r2, r3
 800db12:	697b      	ldr	r3, [r7, #20]
 800db14:	839a      	strh	r2, [r3, #28]
    npcb->state = SYN_RCVD;
 800db16:	697b      	ldr	r3, [r7, #20]
 800db18:	2203      	movs	r2, #3
 800db1a:	761a      	strb	r2, [r3, #24]
    npcb->rcv_nxt = seqno + 1;
 800db1c:	4b48      	ldr	r3, [pc, #288]	; (800dc40 <tcp_listen_input+0x21c>)
 800db1e:	681b      	ldr	r3, [r3, #0]
 800db20:	1c5a      	adds	r2, r3, #1
 800db22:	697b      	ldr	r3, [r7, #20]
 800db24:	629a      	str	r2, [r3, #40]	; 0x28
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
 800db26:	697b      	ldr	r3, [r7, #20]
 800db28:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800db2a:	697b      	ldr	r3, [r7, #20]
 800db2c:	631a      	str	r2, [r3, #48]	; 0x30
    iss = tcp_next_iss(npcb);
 800db2e:	697b      	ldr	r3, [r7, #20]
 800db30:	0018      	movs	r0, r3
 800db32:	f7ff f8e3 	bl	800ccfc <tcp_next_iss>
 800db36:	0003      	movs	r3, r0
 800db38:	613b      	str	r3, [r7, #16]
    npcb->snd_wl2 = iss;
 800db3a:	697b      	ldr	r3, [r7, #20]
 800db3c:	693a      	ldr	r2, [r7, #16]
 800db3e:	65da      	str	r2, [r3, #92]	; 0x5c
    npcb->snd_nxt = iss;
 800db40:	697b      	ldr	r3, [r7, #20]
 800db42:	693a      	ldr	r2, [r7, #16]
 800db44:	655a      	str	r2, [r3, #84]	; 0x54
    npcb->lastack = iss;
 800db46:	697b      	ldr	r3, [r7, #20]
 800db48:	693a      	ldr	r2, [r7, #16]
 800db4a:	649a      	str	r2, [r3, #72]	; 0x48
    npcb->snd_lbb = iss;
 800db4c:	697b      	ldr	r3, [r7, #20]
 800db4e:	693a      	ldr	r2, [r7, #16]
 800db50:	661a      	str	r2, [r3, #96]	; 0x60
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
 800db52:	4b3b      	ldr	r3, [pc, #236]	; (800dc40 <tcp_listen_input+0x21c>)
 800db54:	681b      	ldr	r3, [r3, #0]
 800db56:	1e5a      	subs	r2, r3, #1
 800db58:	697b      	ldr	r3, [r7, #20]
 800db5a:	659a      	str	r2, [r3, #88]	; 0x58
    npcb->callback_arg = pcb->callback_arg;
 800db5c:	687b      	ldr	r3, [r7, #4]
 800db5e:	695a      	ldr	r2, [r3, #20]
 800db60:	697b      	ldr	r3, [r7, #20]
 800db62:	615a      	str	r2, [r3, #20]
    npcb->listener = pcb;
 800db64:	697b      	ldr	r3, [r7, #20]
 800db66:	2180      	movs	r1, #128	; 0x80
 800db68:	687a      	ldr	r2, [r7, #4]
 800db6a:	505a      	str	r2, [r3, r1]
    npcb->so_options = pcb->so_options & SOF_INHERITED;
 800db6c:	687b      	ldr	r3, [r7, #4]
 800db6e:	7a5b      	ldrb	r3, [r3, #9]
 800db70:	220c      	movs	r2, #12
 800db72:	4013      	ands	r3, r2
 800db74:	b2da      	uxtb	r2, r3
 800db76:	697b      	ldr	r3, [r7, #20]
 800db78:	725a      	strb	r2, [r3, #9]
    npcb->netif_idx = pcb->netif_idx;
 800db7a:	687b      	ldr	r3, [r7, #4]
 800db7c:	7a1a      	ldrb	r2, [r3, #8]
 800db7e:	697b      	ldr	r3, [r7, #20]
 800db80:	721a      	strb	r2, [r3, #8]
    TCP_REG_ACTIVE(npcb);
 800db82:	4b34      	ldr	r3, [pc, #208]	; (800dc54 <tcp_listen_input+0x230>)
 800db84:	681a      	ldr	r2, [r3, #0]
 800db86:	697b      	ldr	r3, [r7, #20]
 800db88:	611a      	str	r2, [r3, #16]
 800db8a:	4b32      	ldr	r3, [pc, #200]	; (800dc54 <tcp_listen_input+0x230>)
 800db8c:	697a      	ldr	r2, [r7, #20]
 800db8e:	601a      	str	r2, [r3, #0]
 800db90:	f004 fe7a 	bl	8012888 <tcp_timer_needed>
 800db94:	4b30      	ldr	r3, [pc, #192]	; (800dc58 <tcp_listen_input+0x234>)
 800db96:	2201      	movs	r2, #1
 800db98:	701a      	strb	r2, [r3, #0]
    tcp_parseopt(npcb);
 800db9a:	697b      	ldr	r3, [r7, #20]
 800db9c:	0018      	movs	r0, r3
 800db9e:	f001 ffbf 	bl	800fb20 <tcp_parseopt>
    npcb->snd_wnd = tcphdr->wnd;
 800dba2:	4b28      	ldr	r3, [pc, #160]	; (800dc44 <tcp_listen_input+0x220>)
 800dba4:	681b      	ldr	r3, [r3, #0]
 800dba6:	7b9a      	ldrb	r2, [r3, #14]
 800dba8:	7bdb      	ldrb	r3, [r3, #15]
 800dbaa:	021b      	lsls	r3, r3, #8
 800dbac:	4313      	orrs	r3, r2
 800dbae:	b299      	uxth	r1, r3
 800dbb0:	697b      	ldr	r3, [r7, #20]
 800dbb2:	2264      	movs	r2, #100	; 0x64
 800dbb4:	5299      	strh	r1, [r3, r2]
    npcb->snd_wnd_max = npcb->snd_wnd;
 800dbb6:	697b      	ldr	r3, [r7, #20]
 800dbb8:	2264      	movs	r2, #100	; 0x64
 800dbba:	5a99      	ldrh	r1, [r3, r2]
 800dbbc:	697b      	ldr	r3, [r7, #20]
 800dbbe:	2266      	movs	r2, #102	; 0x66
 800dbc0:	5299      	strh	r1, [r3, r2]
    npcb->mss = tcp_eff_send_mss(npcb->mss, &npcb->local_ip, &npcb->remote_ip);
 800dbc2:	697b      	ldr	r3, [r7, #20]
 800dbc4:	8edc      	ldrh	r4, [r3, #54]	; 0x36
 800dbc6:	697b      	ldr	r3, [r7, #20]
 800dbc8:	3304      	adds	r3, #4
 800dbca:	0018      	movs	r0, r3
 800dbcc:	f006 f874 	bl	8013cb8 <ip4_route>
 800dbd0:	0001      	movs	r1, r0
 800dbd2:	697b      	ldr	r3, [r7, #20]
 800dbd4:	3304      	adds	r3, #4
 800dbd6:	001a      	movs	r2, r3
 800dbd8:	0020      	movs	r0, r4
 800dbda:	f7ff f8b5 	bl	800cd48 <tcp_eff_send_mss_netif>
 800dbde:	0003      	movs	r3, r0
 800dbe0:	001a      	movs	r2, r3
 800dbe2:	697b      	ldr	r3, [r7, #20]
 800dbe4:	86da      	strh	r2, [r3, #54]	; 0x36
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
 800dbe6:	250f      	movs	r5, #15
 800dbe8:	197c      	adds	r4, r7, r5
 800dbea:	697b      	ldr	r3, [r7, #20]
 800dbec:	2112      	movs	r1, #18
 800dbee:	0018      	movs	r0, r3
 800dbf0:	f003 fac6 	bl	8011180 <tcp_enqueue_flags>
 800dbf4:	0003      	movs	r3, r0
 800dbf6:	7023      	strb	r3, [r4, #0]
    if (rc != ERR_OK) {
 800dbf8:	197b      	adds	r3, r7, r5
 800dbfa:	781b      	ldrb	r3, [r3, #0]
 800dbfc:	b25b      	sxtb	r3, r3
 800dbfe:	2b00      	cmp	r3, #0
 800dc00:	d005      	beq.n	800dc0e <tcp_listen_input+0x1ea>
      tcp_abandon(npcb, 0);
 800dc02:	697b      	ldr	r3, [r7, #20]
 800dc04:	2100      	movs	r1, #0
 800dc06:	0018      	movs	r0, r3
 800dc08:	f7fd fc52 	bl	800b4b0 <tcp_abandon>
      return;
 800dc0c:	e007      	b.n	800dc1e <tcp_listen_input+0x1fa>
    tcp_output(npcb);
 800dc0e:	697b      	ldr	r3, [r7, #20]
 800dc10:	0018      	movs	r0, r3
 800dc12:	f003 fbbb 	bl	801138c <tcp_output>
  return;
 800dc16:	e001      	b.n	800dc1c <tcp_listen_input+0x1f8>
    return;
 800dc18:	46c0      	nop			; (mov r8, r8)
 800dc1a:	e000      	b.n	800dc1e <tcp_listen_input+0x1fa>
  return;
 800dc1c:	46c0      	nop			; (mov r8, r8)
}
 800dc1e:	46bd      	mov	sp, r7
 800dc20:	b006      	add	sp, #24
 800dc22:	bdb0      	pop	{r4, r5, r7, pc}
 800dc24:	20000c78 	.word	0x20000c78
 800dc28:	0802120c 	.word	0x0802120c
 800dc2c:	00000281 	.word	0x00000281
 800dc30:	080213fc 	.word	0x080213fc
 800dc34:	0802124c 	.word	0x0802124c
 800dc38:	20000c70 	.word	0x20000c70
 800dc3c:	20000c76 	.word	0x20000c76
 800dc40:	20000c6c 	.word	0x20000c6c
 800dc44:	20000c5c 	.word	0x20000c5c
 800dc48:	2000114c 	.word	0x2000114c
 800dc4c:	20001148 	.word	0x20001148
 800dc50:	20001138 	.word	0x20001138
 800dc54:	2000278c 	.word	0x2000278c
 800dc58:	20002788 	.word	0x20002788

0800dc5c <tcp_timewait_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static void
tcp_timewait_input(struct tcp_pcb *pcb)
{
 800dc5c:	b5b0      	push	{r4, r5, r7, lr}
 800dc5e:	b086      	sub	sp, #24
 800dc60:	af04      	add	r7, sp, #16
 800dc62:	6078      	str	r0, [r7, #4]
  /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
  /* RFC 793 3.9 Event Processing - Segment Arrives:
   * - first check sequence number - we skip that one in TIME_WAIT (always
   *   acceptable since we only send ACKs)
   * - second check the RST bit (... return) */
  if (flags & TCP_RST) {
 800dc64:	4b33      	ldr	r3, [pc, #204]	; (800dd34 <tcp_timewait_input+0xd8>)
 800dc66:	781b      	ldrb	r3, [r3, #0]
 800dc68:	001a      	movs	r2, r3
 800dc6a:	2304      	movs	r3, #4
 800dc6c:	4013      	ands	r3, r2
 800dc6e:	d15a      	bne.n	800dd26 <tcp_timewait_input+0xca>
    return;
  }

  LWIP_ASSERT("tcp_timewait_input: invalid pcb", pcb != NULL);
 800dc70:	687b      	ldr	r3, [r7, #4]
 800dc72:	2b00      	cmp	r3, #0
 800dc74:	d105      	bne.n	800dc82 <tcp_timewait_input+0x26>
 800dc76:	4b30      	ldr	r3, [pc, #192]	; (800dd38 <tcp_timewait_input+0xdc>)
 800dc78:	4a30      	ldr	r2, [pc, #192]	; (800dd3c <tcp_timewait_input+0xe0>)
 800dc7a:	4931      	ldr	r1, [pc, #196]	; (800dd40 <tcp_timewait_input+0xe4>)
 800dc7c:	4831      	ldr	r0, [pc, #196]	; (800dd44 <tcp_timewait_input+0xe8>)
 800dc7e:	f7f4 fab1 	bl	80021e4 <app_debug_rtt_raw>

  /* - fourth, check the SYN bit, */
  if (flags & TCP_SYN) {
 800dc82:	4b2c      	ldr	r3, [pc, #176]	; (800dd34 <tcp_timewait_input+0xd8>)
 800dc84:	781b      	ldrb	r3, [r3, #0]
 800dc86:	001a      	movs	r2, r3
 800dc88:	2302      	movs	r3, #2
 800dc8a:	4013      	ands	r3, r2
 800dc8c:	d031      	beq.n	800dcf2 <tcp_timewait_input+0x96>
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd)) {
 800dc8e:	4b2e      	ldr	r3, [pc, #184]	; (800dd48 <tcp_timewait_input+0xec>)
 800dc90:	681a      	ldr	r2, [r3, #0]
 800dc92:	687b      	ldr	r3, [r7, #4]
 800dc94:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800dc96:	1ad3      	subs	r3, r2, r3
 800dc98:	d435      	bmi.n	800dd06 <tcp_timewait_input+0xaa>
 800dc9a:	4b2b      	ldr	r3, [pc, #172]	; (800dd48 <tcp_timewait_input+0xec>)
 800dc9c:	681a      	ldr	r2, [r3, #0]
 800dc9e:	687b      	ldr	r3, [r7, #4]
 800dca0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800dca2:	6879      	ldr	r1, [r7, #4]
 800dca4:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
 800dca6:	185b      	adds	r3, r3, r1
 800dca8:	1ad3      	subs	r3, r2, r3
 800dcaa:	2b00      	cmp	r3, #0
 800dcac:	dc2b      	bgt.n	800dd06 <tcp_timewait_input+0xaa>
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800dcae:	4b27      	ldr	r3, [pc, #156]	; (800dd4c <tcp_timewait_input+0xf0>)
 800dcb0:	681c      	ldr	r4, [r3, #0]
 800dcb2:	4b27      	ldr	r3, [pc, #156]	; (800dd50 <tcp_timewait_input+0xf4>)
 800dcb4:	881b      	ldrh	r3, [r3, #0]
 800dcb6:	001a      	movs	r2, r3
 800dcb8:	4b23      	ldr	r3, [pc, #140]	; (800dd48 <tcp_timewait_input+0xec>)
 800dcba:	681b      	ldr	r3, [r3, #0]
 800dcbc:	18d5      	adds	r5, r2, r3
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800dcbe:	4b25      	ldr	r3, [pc, #148]	; (800dd54 <tcp_timewait_input+0xf8>)
 800dcc0:	681b      	ldr	r3, [r3, #0]
      tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800dcc2:	789a      	ldrb	r2, [r3, #2]
 800dcc4:	78db      	ldrb	r3, [r3, #3]
 800dcc6:	021b      	lsls	r3, r3, #8
 800dcc8:	4313      	orrs	r3, r2
 800dcca:	b29a      	uxth	r2, r3
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800dccc:	4b21      	ldr	r3, [pc, #132]	; (800dd54 <tcp_timewait_input+0xf8>)
 800dcce:	681b      	ldr	r3, [r3, #0]
      tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800dcd0:	7819      	ldrb	r1, [r3, #0]
 800dcd2:	785b      	ldrb	r3, [r3, #1]
 800dcd4:	021b      	lsls	r3, r3, #8
 800dcd6:	430b      	orrs	r3, r1
 800dcd8:	b29b      	uxth	r3, r3
 800dcda:	491f      	ldr	r1, [pc, #124]	; (800dd58 <tcp_timewait_input+0xfc>)
 800dcdc:	6878      	ldr	r0, [r7, #4]
 800dcde:	9302      	str	r3, [sp, #8]
 800dce0:	9201      	str	r2, [sp, #4]
 800dce2:	4b1e      	ldr	r3, [pc, #120]	; (800dd5c <tcp_timewait_input+0x100>)
 800dce4:	9300      	str	r3, [sp, #0]
 800dce6:	000b      	movs	r3, r1
 800dce8:	002a      	movs	r2, r5
 800dcea:	0021      	movs	r1, r4
 800dcec:	f004 fba2 	bl	8012434 <tcp_rst>
      return;
 800dcf0:	e01c      	b.n	800dd2c <tcp_timewait_input+0xd0>
    }
  } else if (flags & TCP_FIN) {
 800dcf2:	4b10      	ldr	r3, [pc, #64]	; (800dd34 <tcp_timewait_input+0xd8>)
 800dcf4:	781b      	ldrb	r3, [r3, #0]
 800dcf6:	001a      	movs	r2, r3
 800dcf8:	2301      	movs	r3, #1
 800dcfa:	4013      	ands	r3, r2
 800dcfc:	d003      	beq.n	800dd06 <tcp_timewait_input+0xaa>
    /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
         Restart the 2 MSL time-wait timeout.*/
    pcb->tmr = tcp_ticks;
 800dcfe:	4b18      	ldr	r3, [pc, #96]	; (800dd60 <tcp_timewait_input+0x104>)
 800dd00:	681a      	ldr	r2, [r3, #0]
 800dd02:	687b      	ldr	r3, [r7, #4]
 800dd04:	625a      	str	r2, [r3, #36]	; 0x24
  }

  if ((tcplen > 0)) {
 800dd06:	4b12      	ldr	r3, [pc, #72]	; (800dd50 <tcp_timewait_input+0xf4>)
 800dd08:	881b      	ldrh	r3, [r3, #0]
 800dd0a:	2b00      	cmp	r3, #0
 800dd0c:	d00d      	beq.n	800dd2a <tcp_timewait_input+0xce>
    /* Acknowledge data, FIN or out-of-window SYN */
    tcp_ack_now(pcb);
 800dd0e:	687b      	ldr	r3, [r7, #4]
 800dd10:	8bdb      	ldrh	r3, [r3, #30]
 800dd12:	2202      	movs	r2, #2
 800dd14:	4313      	orrs	r3, r2
 800dd16:	b29a      	uxth	r2, r3
 800dd18:	687b      	ldr	r3, [r7, #4]
 800dd1a:	83da      	strh	r2, [r3, #30]
    tcp_output(pcb);
 800dd1c:	687b      	ldr	r3, [r7, #4]
 800dd1e:	0018      	movs	r0, r3
 800dd20:	f003 fb34 	bl	801138c <tcp_output>
  }
  return;
 800dd24:	e001      	b.n	800dd2a <tcp_timewait_input+0xce>
    return;
 800dd26:	46c0      	nop			; (mov r8, r8)
 800dd28:	e000      	b.n	800dd2c <tcp_timewait_input+0xd0>
  return;
 800dd2a:	46c0      	nop			; (mov r8, r8)
}
 800dd2c:	46bd      	mov	sp, r7
 800dd2e:	b002      	add	sp, #8
 800dd30:	bdb0      	pop	{r4, r5, r7, pc}
 800dd32:	46c0      	nop			; (mov r8, r8)
 800dd34:	20000c78 	.word	0x20000c78
 800dd38:	0802120c 	.word	0x0802120c
 800dd3c:	000002ee 	.word	0x000002ee
 800dd40:	0802141c 	.word	0x0802141c
 800dd44:	0802124c 	.word	0x0802124c
 800dd48:	20000c6c 	.word	0x20000c6c
 800dd4c:	20000c70 	.word	0x20000c70
 800dd50:	20000c76 	.word	0x20000c76
 800dd54:	20000c5c 	.word	0x20000c5c
 800dd58:	2000114c 	.word	0x2000114c
 800dd5c:	20001148 	.word	0x20001148
 800dd60:	20002790 	.word	0x20002790

0800dd64 <tcp_process>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
 800dd64:	b5b0      	push	{r4, r5, r7, lr}
 800dd66:	b08c      	sub	sp, #48	; 0x30
 800dd68:	af04      	add	r7, sp, #16
 800dd6a:	6078      	str	r0, [r7, #4]
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
 800dd6c:	231f      	movs	r3, #31
 800dd6e:	18fb      	adds	r3, r7, r3
 800dd70:	2200      	movs	r2, #0
 800dd72:	701a      	strb	r2, [r3, #0]
  err_t err;

  err = ERR_OK;
 800dd74:	231e      	movs	r3, #30
 800dd76:	18fb      	adds	r3, r7, r3
 800dd78:	2200      	movs	r2, #0
 800dd7a:	701a      	strb	r2, [r3, #0]

  LWIP_ASSERT("tcp_process: invalid pcb", pcb != NULL);
 800dd7c:	687b      	ldr	r3, [r7, #4]
 800dd7e:	2b00      	cmp	r3, #0
 800dd80:	d106      	bne.n	800dd90 <tcp_process+0x2c>
 800dd82:	4bd4      	ldr	r3, [pc, #848]	; (800e0d4 <tcp_process+0x370>)
 800dd84:	22c7      	movs	r2, #199	; 0xc7
 800dd86:	0092      	lsls	r2, r2, #2
 800dd88:	49d3      	ldr	r1, [pc, #844]	; (800e0d8 <tcp_process+0x374>)
 800dd8a:	48d4      	ldr	r0, [pc, #848]	; (800e0dc <tcp_process+0x378>)
 800dd8c:	f7f4 fa2a 	bl	80021e4 <app_debug_rtt_raw>

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
 800dd90:	4bd3      	ldr	r3, [pc, #844]	; (800e0e0 <tcp_process+0x37c>)
 800dd92:	781b      	ldrb	r3, [r3, #0]
 800dd94:	001a      	movs	r2, r3
 800dd96:	2304      	movs	r3, #4
 800dd98:	4013      	ands	r3, r2
 800dd9a:	d055      	beq.n	800de48 <tcp_process+0xe4>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
 800dd9c:	687b      	ldr	r3, [r7, #4]
 800dd9e:	7e1b      	ldrb	r3, [r3, #24]
 800dda0:	2b02      	cmp	r3, #2
 800dda2:	d10a      	bne.n	800ddba <tcp_process+0x56>
      /* "In the SYN-SENT state (a RST received in response to an initial SYN),
          the RST is acceptable if the ACK field acknowledges the SYN." */
      if (ackno == pcb->snd_nxt) {
 800dda4:	687b      	ldr	r3, [r7, #4]
 800dda6:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800dda8:	4bce      	ldr	r3, [pc, #824]	; (800e0e4 <tcp_process+0x380>)
 800ddaa:	681b      	ldr	r3, [r3, #0]
 800ddac:	429a      	cmp	r2, r3
 800ddae:	d126      	bne.n	800ddfe <tcp_process+0x9a>
        acceptable = 1;
 800ddb0:	231f      	movs	r3, #31
 800ddb2:	18fb      	adds	r3, r7, r3
 800ddb4:	2201      	movs	r2, #1
 800ddb6:	701a      	strb	r2, [r3, #0]
 800ddb8:	e021      	b.n	800ddfe <tcp_process+0x9a>
      }
    } else {
      /* "In all states except SYN-SENT, all reset (RST) segments are validated
          by checking their SEQ-fields." */
      if (seqno == pcb->rcv_nxt) {
 800ddba:	687b      	ldr	r3, [r7, #4]
 800ddbc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800ddbe:	4bca      	ldr	r3, [pc, #808]	; (800e0e8 <tcp_process+0x384>)
 800ddc0:	681b      	ldr	r3, [r3, #0]
 800ddc2:	429a      	cmp	r2, r3
 800ddc4:	d104      	bne.n	800ddd0 <tcp_process+0x6c>
        acceptable = 1;
 800ddc6:	231f      	movs	r3, #31
 800ddc8:	18fb      	adds	r3, r7, r3
 800ddca:	2201      	movs	r2, #1
 800ddcc:	701a      	strb	r2, [r3, #0]
 800ddce:	e016      	b.n	800ddfe <tcp_process+0x9a>
      } else  if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
 800ddd0:	4bc5      	ldr	r3, [pc, #788]	; (800e0e8 <tcp_process+0x384>)
 800ddd2:	681a      	ldr	r2, [r3, #0]
 800ddd4:	687b      	ldr	r3, [r7, #4]
 800ddd6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ddd8:	1ad3      	subs	r3, r2, r3
 800ddda:	d410      	bmi.n	800ddfe <tcp_process+0x9a>
 800dddc:	4bc2      	ldr	r3, [pc, #776]	; (800e0e8 <tcp_process+0x384>)
 800ddde:	681a      	ldr	r2, [r3, #0]
 800dde0:	687b      	ldr	r3, [r7, #4]
 800dde2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800dde4:	6879      	ldr	r1, [r7, #4]
 800dde6:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
 800dde8:	185b      	adds	r3, r3, r1
 800ddea:	1ad3      	subs	r3, r2, r3
 800ddec:	2b00      	cmp	r3, #0
 800ddee:	dc06      	bgt.n	800ddfe <tcp_process+0x9a>
                                  pcb->rcv_nxt + pcb->rcv_wnd)) {
        /* If the sequence number is inside the window, we send a challenge ACK
           and wait for a re-send with matching sequence number.
           This follows RFC 5961 section 3.2 and addresses CVE-2004-0230
           (RST spoofing attack), which is present in RFC 793 RST handling. */
        tcp_ack_now(pcb);
 800ddf0:	687b      	ldr	r3, [r7, #4]
 800ddf2:	8bdb      	ldrh	r3, [r3, #30]
 800ddf4:	2202      	movs	r2, #2
 800ddf6:	4313      	orrs	r3, r2
 800ddf8:	b29a      	uxth	r2, r3
 800ddfa:	687b      	ldr	r3, [r7, #4]
 800ddfc:	83da      	strh	r2, [r3, #30]
      }
    }

    if (acceptable) {
 800ddfe:	231f      	movs	r3, #31
 800de00:	18fb      	adds	r3, r7, r3
 800de02:	781b      	ldrb	r3, [r3, #0]
 800de04:	2b00      	cmp	r3, #0
 800de06:	d01c      	beq.n	800de42 <tcp_process+0xde>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
 800de08:	687b      	ldr	r3, [r7, #4]
 800de0a:	7e1b      	ldrb	r3, [r3, #24]
 800de0c:	2b00      	cmp	r3, #0
 800de0e:	d106      	bne.n	800de1e <tcp_process+0xba>
 800de10:	4bb0      	ldr	r3, [pc, #704]	; (800e0d4 <tcp_process+0x370>)
 800de12:	22ce      	movs	r2, #206	; 0xce
 800de14:	0092      	lsls	r2, r2, #2
 800de16:	49b5      	ldr	r1, [pc, #724]	; (800e0ec <tcp_process+0x388>)
 800de18:	48b0      	ldr	r0, [pc, #704]	; (800e0dc <tcp_process+0x378>)
 800de1a:	f7f4 f9e3 	bl	80021e4 <app_debug_rtt_raw>
      recv_flags |= TF_RESET;
 800de1e:	4bb4      	ldr	r3, [pc, #720]	; (800e0f0 <tcp_process+0x38c>)
 800de20:	781b      	ldrb	r3, [r3, #0]
 800de22:	2208      	movs	r2, #8
 800de24:	4313      	orrs	r3, r2
 800de26:	b2da      	uxtb	r2, r3
 800de28:	4bb1      	ldr	r3, [pc, #708]	; (800e0f0 <tcp_process+0x38c>)
 800de2a:	701a      	strb	r2, [r3, #0]
      tcp_clear_flags(pcb, TF_ACK_DELAY);
 800de2c:	687b      	ldr	r3, [r7, #4]
 800de2e:	8bdb      	ldrh	r3, [r3, #30]
 800de30:	2201      	movs	r2, #1
 800de32:	4393      	bics	r3, r2
 800de34:	b29a      	uxth	r2, r3
 800de36:	687b      	ldr	r3, [r7, #4]
 800de38:	83da      	strh	r2, [r3, #30]
      return ERR_RST;
 800de3a:	230e      	movs	r3, #14
 800de3c:	425b      	negs	r3, r3
 800de3e:	f000 fbb1 	bl	800e5a4 <tcp_process+0x840>
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
                                    seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
                              seqno, pcb->rcv_nxt));
      return ERR_OK;
 800de42:	2300      	movs	r3, #0
 800de44:	f000 fbae 	bl	800e5a4 <tcp_process+0x840>
    }
  }

  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) {
 800de48:	4ba5      	ldr	r3, [pc, #660]	; (800e0e0 <tcp_process+0x37c>)
 800de4a:	781b      	ldrb	r3, [r3, #0]
 800de4c:	001a      	movs	r2, r3
 800de4e:	2302      	movs	r3, #2
 800de50:	4013      	ands	r3, r2
 800de52:	d011      	beq.n	800de78 <tcp_process+0x114>
 800de54:	687b      	ldr	r3, [r7, #4]
 800de56:	7e1b      	ldrb	r3, [r3, #24]
 800de58:	2b02      	cmp	r3, #2
 800de5a:	d00d      	beq.n	800de78 <tcp_process+0x114>
 800de5c:	687b      	ldr	r3, [r7, #4]
 800de5e:	7e1b      	ldrb	r3, [r3, #24]
 800de60:	2b03      	cmp	r3, #3
 800de62:	d009      	beq.n	800de78 <tcp_process+0x114>
    /* Cope with new connection attempt after remote end crashed */
    tcp_ack_now(pcb);
 800de64:	687b      	ldr	r3, [r7, #4]
 800de66:	8bdb      	ldrh	r3, [r3, #30]
 800de68:	2202      	movs	r2, #2
 800de6a:	4313      	orrs	r3, r2
 800de6c:	b29a      	uxth	r2, r3
 800de6e:	687b      	ldr	r3, [r7, #4]
 800de70:	83da      	strh	r2, [r3, #30]
    return ERR_OK;
 800de72:	2300      	movs	r3, #0
 800de74:	f000 fb96 	bl	800e5a4 <tcp_process+0x840>
  }

  if ((pcb->flags & TF_RXCLOSED) == 0) {
 800de78:	687b      	ldr	r3, [r7, #4]
 800de7a:	8bdb      	ldrh	r3, [r3, #30]
 800de7c:	001a      	movs	r2, r3
 800de7e:	2310      	movs	r3, #16
 800de80:	4013      	ands	r3, r2
 800de82:	d103      	bne.n	800de8c <tcp_process+0x128>
    /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
    pcb->tmr = tcp_ticks;
 800de84:	4b9b      	ldr	r3, [pc, #620]	; (800e0f4 <tcp_process+0x390>)
 800de86:	681a      	ldr	r2, [r3, #0]
 800de88:	687b      	ldr	r3, [r7, #4]
 800de8a:	625a      	str	r2, [r3, #36]	; 0x24
  }
  pcb->keep_cnt_sent = 0;
 800de8c:	687b      	ldr	r3, [r7, #4]
 800de8e:	22a7      	movs	r2, #167	; 0xa7
 800de90:	2100      	movs	r1, #0
 800de92:	5499      	strb	r1, [r3, r2]
  pcb->persist_probe = 0;
 800de94:	687b      	ldr	r3, [r7, #4]
 800de96:	22a6      	movs	r2, #166	; 0xa6
 800de98:	2100      	movs	r1, #0
 800de9a:	5499      	strb	r1, [r3, r2]

  tcp_parseopt(pcb);
 800de9c:	687b      	ldr	r3, [r7, #4]
 800de9e:	0018      	movs	r0, r3
 800dea0:	f001 fe3e 	bl	800fb20 <tcp_parseopt>

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
 800dea4:	687b      	ldr	r3, [r7, #4]
 800dea6:	7e1b      	ldrb	r3, [r3, #24]
 800dea8:	2b09      	cmp	r3, #9
 800deaa:	d901      	bls.n	800deb0 <tcp_process+0x14c>
 800deac:	f000 fb6a 	bl	800e584 <tcp_process+0x820>
 800deb0:	009a      	lsls	r2, r3, #2
 800deb2:	4b91      	ldr	r3, [pc, #580]	; (800e0f8 <tcp_process+0x394>)
 800deb4:	18d3      	adds	r3, r2, r3
 800deb6:	681b      	ldr	r3, [r3, #0]
 800deb8:	469f      	mov	pc, r3
    case SYN_SENT:
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %s %"U32_F"\n",
                                    ackno, pcb->snd_nxt, pcb->unacked ? "" : " empty:",
                                    pcb->unacked ? lwip_ntohl(pcb->unacked->tcphdr->seqno) : 0));
      /* received SYN ACK with expected sequence number? */
      if ((flags & TCP_ACK) && (flags & TCP_SYN)
 800deba:	4b89      	ldr	r3, [pc, #548]	; (800e0e0 <tcp_process+0x37c>)
 800debc:	781b      	ldrb	r3, [r3, #0]
 800debe:	001a      	movs	r2, r3
 800dec0:	2310      	movs	r3, #16
 800dec2:	4013      	ands	r3, r2
 800dec4:	d100      	bne.n	800dec8 <tcp_process+0x164>
 800dec6:	e0cf      	b.n	800e068 <tcp_process+0x304>
 800dec8:	4b85      	ldr	r3, [pc, #532]	; (800e0e0 <tcp_process+0x37c>)
 800deca:	781b      	ldrb	r3, [r3, #0]
 800decc:	001a      	movs	r2, r3
 800dece:	2302      	movs	r3, #2
 800ded0:	4013      	ands	r3, r2
 800ded2:	d100      	bne.n	800ded6 <tcp_process+0x172>
 800ded4:	e0c8      	b.n	800e068 <tcp_process+0x304>
          && (ackno == pcb->lastack + 1)) {
 800ded6:	687b      	ldr	r3, [r7, #4]
 800ded8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800deda:	1c5a      	adds	r2, r3, #1
 800dedc:	4b81      	ldr	r3, [pc, #516]	; (800e0e4 <tcp_process+0x380>)
 800dede:	681b      	ldr	r3, [r3, #0]
 800dee0:	429a      	cmp	r2, r3
 800dee2:	d000      	beq.n	800dee6 <tcp_process+0x182>
 800dee4:	e0c0      	b.n	800e068 <tcp_process+0x304>
        pcb->rcv_nxt = seqno + 1;
 800dee6:	4b80      	ldr	r3, [pc, #512]	; (800e0e8 <tcp_process+0x384>)
 800dee8:	681b      	ldr	r3, [r3, #0]
 800deea:	1c5a      	adds	r2, r3, #1
 800deec:	687b      	ldr	r3, [r7, #4]
 800deee:	629a      	str	r2, [r3, #40]	; 0x28
        pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 800def0:	687b      	ldr	r3, [r7, #4]
 800def2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800def4:	687b      	ldr	r3, [r7, #4]
 800def6:	631a      	str	r2, [r3, #48]	; 0x30
        pcb->lastack = ackno;
 800def8:	4b7a      	ldr	r3, [pc, #488]	; (800e0e4 <tcp_process+0x380>)
 800defa:	681a      	ldr	r2, [r3, #0]
 800defc:	687b      	ldr	r3, [r7, #4]
 800defe:	649a      	str	r2, [r3, #72]	; 0x48
        pcb->snd_wnd = tcphdr->wnd;
 800df00:	4b7e      	ldr	r3, [pc, #504]	; (800e0fc <tcp_process+0x398>)
 800df02:	681b      	ldr	r3, [r3, #0]
 800df04:	7b9a      	ldrb	r2, [r3, #14]
 800df06:	7bdb      	ldrb	r3, [r3, #15]
 800df08:	021b      	lsls	r3, r3, #8
 800df0a:	4313      	orrs	r3, r2
 800df0c:	b299      	uxth	r1, r3
 800df0e:	687b      	ldr	r3, [r7, #4]
 800df10:	2264      	movs	r2, #100	; 0x64
 800df12:	5299      	strh	r1, [r3, r2]
        pcb->snd_wnd_max = pcb->snd_wnd;
 800df14:	687b      	ldr	r3, [r7, #4]
 800df16:	2264      	movs	r2, #100	; 0x64
 800df18:	5a99      	ldrh	r1, [r3, r2]
 800df1a:	687b      	ldr	r3, [r7, #4]
 800df1c:	2266      	movs	r2, #102	; 0x66
 800df1e:	5299      	strh	r1, [r3, r2]
        pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
 800df20:	4b71      	ldr	r3, [pc, #452]	; (800e0e8 <tcp_process+0x384>)
 800df22:	681b      	ldr	r3, [r3, #0]
 800df24:	1e5a      	subs	r2, r3, #1
 800df26:	687b      	ldr	r3, [r7, #4]
 800df28:	659a      	str	r2, [r3, #88]	; 0x58
        pcb->state = ESTABLISHED;
 800df2a:	687b      	ldr	r3, [r7, #4]
 800df2c:	2204      	movs	r2, #4
 800df2e:	761a      	strb	r2, [r3, #24]

#if TCP_CALCULATE_EFF_SEND_MSS
        pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip);
 800df30:	687b      	ldr	r3, [r7, #4]
 800df32:	8edc      	ldrh	r4, [r3, #54]	; 0x36
 800df34:	687b      	ldr	r3, [r7, #4]
 800df36:	3304      	adds	r3, #4
 800df38:	0018      	movs	r0, r3
 800df3a:	f005 febd 	bl	8013cb8 <ip4_route>
 800df3e:	0001      	movs	r1, r0
 800df40:	687b      	ldr	r3, [r7, #4]
 800df42:	3304      	adds	r3, #4
 800df44:	001a      	movs	r2, r3
 800df46:	0020      	movs	r0, r4
 800df48:	f7fe fefe 	bl	800cd48 <tcp_eff_send_mss_netif>
 800df4c:	0003      	movs	r3, r0
 800df4e:	001a      	movs	r2, r3
 800df50:	687b      	ldr	r3, [r7, #4]
 800df52:	86da      	strh	r2, [r3, #54]	; 0x36
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

        pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
 800df54:	687b      	ldr	r3, [r7, #4]
 800df56:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800df58:	009a      	lsls	r2, r3, #2
 800df5a:	687b      	ldr	r3, [r7, #4]
 800df5c:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800df5e:	005b      	lsls	r3, r3, #1
 800df60:	4967      	ldr	r1, [pc, #412]	; (800e100 <tcp_process+0x39c>)
 800df62:	428b      	cmp	r3, r1
 800df64:	d200      	bcs.n	800df68 <tcp_process+0x204>
 800df66:	4b66      	ldr	r3, [pc, #408]	; (800e100 <tcp_process+0x39c>)
 800df68:	429a      	cmp	r2, r3
 800df6a:	d204      	bcs.n	800df76 <tcp_process+0x212>
 800df6c:	687b      	ldr	r3, [r7, #4]
 800df6e:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800df70:	009b      	lsls	r3, r3, #2
 800df72:	b29b      	uxth	r3, r3
 800df74:	e00b      	b.n	800df8e <tcp_process+0x22a>
 800df76:	687b      	ldr	r3, [r7, #4]
 800df78:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800df7a:	005b      	lsls	r3, r3, #1
 800df7c:	4a60      	ldr	r2, [pc, #384]	; (800e100 <tcp_process+0x39c>)
 800df7e:	4293      	cmp	r3, r2
 800df80:	d904      	bls.n	800df8c <tcp_process+0x228>
 800df82:	687b      	ldr	r3, [r7, #4]
 800df84:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800df86:	18db      	adds	r3, r3, r3
 800df88:	b29b      	uxth	r3, r3
 800df8a:	e000      	b.n	800df8e <tcp_process+0x22a>
 800df8c:	4b5c      	ldr	r3, [pc, #368]	; (800e100 <tcp_process+0x39c>)
 800df8e:	687a      	ldr	r2, [r7, #4]
 800df90:	214c      	movs	r1, #76	; 0x4c
 800df92:	5253      	strh	r3, [r2, r1]
        LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SENT): cwnd %"TCPWNDSIZE_F
                                     " ssthresh %"TCPWNDSIZE_F"\n",
                                     pcb->cwnd, pcb->ssthresh));
        LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
 800df94:	687b      	ldr	r3, [r7, #4]
 800df96:	226a      	movs	r2, #106	; 0x6a
 800df98:	5a9b      	ldrh	r3, [r3, r2]
 800df9a:	2b00      	cmp	r3, #0
 800df9c:	d105      	bne.n	800dfaa <tcp_process+0x246>
 800df9e:	4b4d      	ldr	r3, [pc, #308]	; (800e0d4 <tcp_process+0x370>)
 800dfa0:	4a58      	ldr	r2, [pc, #352]	; (800e104 <tcp_process+0x3a0>)
 800dfa2:	4959      	ldr	r1, [pc, #356]	; (800e108 <tcp_process+0x3a4>)
 800dfa4:	484d      	ldr	r0, [pc, #308]	; (800e0dc <tcp_process+0x378>)
 800dfa6:	f7f4 f91d 	bl	80021e4 <app_debug_rtt_raw>
        --pcb->snd_queuelen;
 800dfaa:	687b      	ldr	r3, [r7, #4]
 800dfac:	226a      	movs	r2, #106	; 0x6a
 800dfae:	5a9b      	ldrh	r3, [r3, r2]
 800dfb0:	3b01      	subs	r3, #1
 800dfb2:	b299      	uxth	r1, r3
 800dfb4:	687b      	ldr	r3, [r7, #4]
 800dfb6:	226a      	movs	r2, #106	; 0x6a
 800dfb8:	5299      	strh	r1, [r3, r2]
        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"TCPWNDSIZE_F"\n", (tcpwnd_size_t)pcb->snd_queuelen));
        rseg = pcb->unacked;
 800dfba:	687b      	ldr	r3, [r7, #4]
 800dfbc:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800dfbe:	617b      	str	r3, [r7, #20]
        if (rseg == NULL) {
 800dfc0:	697b      	ldr	r3, [r7, #20]
 800dfc2:	2b00      	cmp	r3, #0
 800dfc4:	d110      	bne.n	800dfe8 <tcp_process+0x284>
          /* might happen if tcp_output fails in tcp_rexmit_rto()
             in which case the segment is on the unsent list */
          rseg = pcb->unsent;
 800dfc6:	687b      	ldr	r3, [r7, #4]
 800dfc8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800dfca:	617b      	str	r3, [r7, #20]
          LWIP_ASSERT("no segment to free", rseg != NULL);
 800dfcc:	697b      	ldr	r3, [r7, #20]
 800dfce:	2b00      	cmp	r3, #0
 800dfd0:	d105      	bne.n	800dfde <tcp_process+0x27a>
 800dfd2:	4b40      	ldr	r3, [pc, #256]	; (800e0d4 <tcp_process+0x370>)
 800dfd4:	4a4d      	ldr	r2, [pc, #308]	; (800e10c <tcp_process+0x3a8>)
 800dfd6:	494e      	ldr	r1, [pc, #312]	; (800e110 <tcp_process+0x3ac>)
 800dfd8:	4840      	ldr	r0, [pc, #256]	; (800e0dc <tcp_process+0x378>)
 800dfda:	f7f4 f903 	bl	80021e4 <app_debug_rtt_raw>
          pcb->unsent = rseg->next;
 800dfde:	697b      	ldr	r3, [r7, #20]
 800dfe0:	681a      	ldr	r2, [r3, #0]
 800dfe2:	687b      	ldr	r3, [r7, #4]
 800dfe4:	671a      	str	r2, [r3, #112]	; 0x70
 800dfe6:	e003      	b.n	800dff0 <tcp_process+0x28c>
        } else {
          pcb->unacked = rseg->next;
 800dfe8:	697b      	ldr	r3, [r7, #20]
 800dfea:	681a      	ldr	r2, [r3, #0]
 800dfec:	687b      	ldr	r3, [r7, #4]
 800dfee:	675a      	str	r2, [r3, #116]	; 0x74
        }
        tcp_seg_free(rseg);
 800dff0:	697b      	ldr	r3, [r7, #20]
 800dff2:	0018      	movs	r0, r3
 800dff4:	f7fe face 	bl	800c594 <tcp_seg_free>

        /* If there's nothing left to acknowledge, stop the retransmit
           timer, otherwise reset it to start again */
        if (pcb->unacked == NULL) {
 800dff8:	687b      	ldr	r3, [r7, #4]
 800dffa:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800dffc:	2b00      	cmp	r3, #0
 800dffe:	d104      	bne.n	800e00a <tcp_process+0x2a6>
          pcb->rtime = -1;
 800e000:	687b      	ldr	r3, [r7, #4]
 800e002:	2201      	movs	r2, #1
 800e004:	4252      	negs	r2, r2
 800e006:	869a      	strh	r2, [r3, #52]	; 0x34
 800e008:	e006      	b.n	800e018 <tcp_process+0x2b4>
        } else {
          pcb->rtime = 0;
 800e00a:	687b      	ldr	r3, [r7, #4]
 800e00c:	2200      	movs	r2, #0
 800e00e:	869a      	strh	r2, [r3, #52]	; 0x34
          pcb->nrtx = 0;
 800e010:	687b      	ldr	r3, [r7, #4]
 800e012:	2246      	movs	r2, #70	; 0x46
 800e014:	2100      	movs	r1, #0
 800e016:	5499      	strb	r1, [r3, r2]
        }

        /* Call the user specified function to call when successfully
         * connected. */
        TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
 800e018:	687b      	ldr	r3, [r7, #4]
 800e01a:	228c      	movs	r2, #140	; 0x8c
 800e01c:	589b      	ldr	r3, [r3, r2]
 800e01e:	2b00      	cmp	r3, #0
 800e020:	d00d      	beq.n	800e03e <tcp_process+0x2da>
 800e022:	687b      	ldr	r3, [r7, #4]
 800e024:	228c      	movs	r2, #140	; 0x8c
 800e026:	589d      	ldr	r5, [r3, r2]
 800e028:	687b      	ldr	r3, [r7, #4]
 800e02a:	695b      	ldr	r3, [r3, #20]
 800e02c:	221e      	movs	r2, #30
 800e02e:	18bc      	adds	r4, r7, r2
 800e030:	6879      	ldr	r1, [r7, #4]
 800e032:	2200      	movs	r2, #0
 800e034:	0018      	movs	r0, r3
 800e036:	47a8      	blx	r5
 800e038:	0003      	movs	r3, r0
 800e03a:	7023      	strb	r3, [r4, #0]
 800e03c:	e003      	b.n	800e046 <tcp_process+0x2e2>
 800e03e:	231e      	movs	r3, #30
 800e040:	18fb      	adds	r3, r7, r3
 800e042:	2200      	movs	r2, #0
 800e044:	701a      	strb	r2, [r3, #0]
        if (err == ERR_ABRT) {
 800e046:	231e      	movs	r3, #30
 800e048:	18fb      	adds	r3, r7, r3
 800e04a:	781b      	ldrb	r3, [r3, #0]
 800e04c:	b25b      	sxtb	r3, r3
 800e04e:	330d      	adds	r3, #13
 800e050:	d102      	bne.n	800e058 <tcp_process+0x2f4>
          return ERR_ABRT;
 800e052:	230d      	movs	r3, #13
 800e054:	425b      	negs	r3, r3
 800e056:	e2a5      	b.n	800e5a4 <tcp_process+0x840>
        }
        tcp_ack_now(pcb);
 800e058:	687b      	ldr	r3, [r7, #4]
 800e05a:	8bdb      	ldrh	r3, [r3, #30]
 800e05c:	2202      	movs	r2, #2
 800e05e:	4313      	orrs	r3, r2
 800e060:	b29a      	uxth	r2, r3
 800e062:	687b      	ldr	r3, [r7, #4]
 800e064:	83da      	strh	r2, [r3, #30]
        if (pcb->nrtx < TCP_SYNMAXRTX) {
          pcb->rtime = 0;
          tcp_rexmit_rto(pcb);
        }
      }
      break;
 800e066:	e28f      	b.n	800e588 <tcp_process+0x824>
      else if (flags & TCP_ACK) {
 800e068:	4b1d      	ldr	r3, [pc, #116]	; (800e0e0 <tcp_process+0x37c>)
 800e06a:	781b      	ldrb	r3, [r3, #0]
 800e06c:	001a      	movs	r2, r3
 800e06e:	2310      	movs	r3, #16
 800e070:	4013      	ands	r3, r2
 800e072:	d100      	bne.n	800e076 <tcp_process+0x312>
 800e074:	e288      	b.n	800e588 <tcp_process+0x824>
        tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800e076:	4b1b      	ldr	r3, [pc, #108]	; (800e0e4 <tcp_process+0x380>)
 800e078:	681c      	ldr	r4, [r3, #0]
 800e07a:	4b26      	ldr	r3, [pc, #152]	; (800e114 <tcp_process+0x3b0>)
 800e07c:	881b      	ldrh	r3, [r3, #0]
 800e07e:	001a      	movs	r2, r3
 800e080:	4b19      	ldr	r3, [pc, #100]	; (800e0e8 <tcp_process+0x384>)
 800e082:	681b      	ldr	r3, [r3, #0]
 800e084:	18d5      	adds	r5, r2, r3
                ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800e086:	4b1d      	ldr	r3, [pc, #116]	; (800e0fc <tcp_process+0x398>)
 800e088:	681b      	ldr	r3, [r3, #0]
        tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800e08a:	789a      	ldrb	r2, [r3, #2]
 800e08c:	78db      	ldrb	r3, [r3, #3]
 800e08e:	021b      	lsls	r3, r3, #8
 800e090:	4313      	orrs	r3, r2
 800e092:	b29a      	uxth	r2, r3
                ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800e094:	4b19      	ldr	r3, [pc, #100]	; (800e0fc <tcp_process+0x398>)
 800e096:	681b      	ldr	r3, [r3, #0]
        tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800e098:	7819      	ldrb	r1, [r3, #0]
 800e09a:	785b      	ldrb	r3, [r3, #1]
 800e09c:	021b      	lsls	r3, r3, #8
 800e09e:	430b      	orrs	r3, r1
 800e0a0:	b29b      	uxth	r3, r3
 800e0a2:	491d      	ldr	r1, [pc, #116]	; (800e118 <tcp_process+0x3b4>)
 800e0a4:	6878      	ldr	r0, [r7, #4]
 800e0a6:	9302      	str	r3, [sp, #8]
 800e0a8:	9201      	str	r2, [sp, #4]
 800e0aa:	4b1c      	ldr	r3, [pc, #112]	; (800e11c <tcp_process+0x3b8>)
 800e0ac:	9300      	str	r3, [sp, #0]
 800e0ae:	000b      	movs	r3, r1
 800e0b0:	002a      	movs	r2, r5
 800e0b2:	0021      	movs	r1, r4
 800e0b4:	f004 f9be 	bl	8012434 <tcp_rst>
        if (pcb->nrtx < TCP_SYNMAXRTX) {
 800e0b8:	687b      	ldr	r3, [r7, #4]
 800e0ba:	2246      	movs	r2, #70	; 0x46
 800e0bc:	5c9b      	ldrb	r3, [r3, r2]
 800e0be:	2b05      	cmp	r3, #5
 800e0c0:	d900      	bls.n	800e0c4 <tcp_process+0x360>
 800e0c2:	e261      	b.n	800e588 <tcp_process+0x824>
          pcb->rtime = 0;
 800e0c4:	687b      	ldr	r3, [r7, #4]
 800e0c6:	2200      	movs	r2, #0
 800e0c8:	869a      	strh	r2, [r3, #52]	; 0x34
          tcp_rexmit_rto(pcb);
 800e0ca:	687b      	ldr	r3, [r7, #4]
 800e0cc:	0018      	movs	r0, r3
 800e0ce:	f003 fe69 	bl	8011da4 <tcp_rexmit_rto>
      break;
 800e0d2:	e259      	b.n	800e588 <tcp_process+0x824>
 800e0d4:	0802120c 	.word	0x0802120c
 800e0d8:	0802143c 	.word	0x0802143c
 800e0dc:	0802124c 	.word	0x0802124c
 800e0e0:	20000c78 	.word	0x20000c78
 800e0e4:	20000c70 	.word	0x20000c70
 800e0e8:	20000c6c 	.word	0x20000c6c
 800e0ec:	08021458 	.word	0x08021458
 800e0f0:	20000c79 	.word	0x20000c79
 800e0f4:	20002790 	.word	0x20002790
 800e0f8:	08023a54 	.word	0x08023a54
 800e0fc:	20000c5c 	.word	0x20000c5c
 800e100:	0000111c 	.word	0x0000111c
 800e104:	0000036d 	.word	0x0000036d
 800e108:	08021478 	.word	0x08021478
 800e10c:	00000375 	.word	0x00000375
 800e110:	08021490 	.word	0x08021490
 800e114:	20000c76 	.word	0x20000c76
 800e118:	2000114c 	.word	0x2000114c
 800e11c:	20001148 	.word	0x20001148
    case SYN_RCVD:
      if (flags & TCP_ACK) {
 800e120:	4bc7      	ldr	r3, [pc, #796]	; (800e440 <tcp_process+0x6dc>)
 800e122:	781b      	ldrb	r3, [r3, #0]
 800e124:	001a      	movs	r2, r3
 800e126:	2310      	movs	r3, #16
 800e128:	4013      	ands	r3, r2
 800e12a:	d100      	bne.n	800e12e <tcp_process+0x3ca>
 800e12c:	e0b5      	b.n	800e29a <tcp_process+0x536>
        /* expected ACK number? */
        if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 800e12e:	4bc5      	ldr	r3, [pc, #788]	; (800e444 <tcp_process+0x6e0>)
 800e130:	681a      	ldr	r2, [r3, #0]
 800e132:	687b      	ldr	r3, [r7, #4]
 800e134:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800e136:	1ad3      	subs	r3, r2, r3
 800e138:	3b01      	subs	r3, #1
 800e13a:	2b00      	cmp	r3, #0
 800e13c:	da00      	bge.n	800e140 <tcp_process+0x3dc>
 800e13e:	e08a      	b.n	800e256 <tcp_process+0x4f2>
 800e140:	4bc0      	ldr	r3, [pc, #768]	; (800e444 <tcp_process+0x6e0>)
 800e142:	681a      	ldr	r2, [r3, #0]
 800e144:	687b      	ldr	r3, [r7, #4]
 800e146:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800e148:	1ad3      	subs	r3, r2, r3
 800e14a:	2b00      	cmp	r3, #0
 800e14c:	dd00      	ble.n	800e150 <tcp_process+0x3ec>
 800e14e:	e082      	b.n	800e256 <tcp_process+0x4f2>
          pcb->state = ESTABLISHED;
 800e150:	687b      	ldr	r3, [r7, #4]
 800e152:	2204      	movs	r2, #4
 800e154:	761a      	strb	r2, [r3, #24]
          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
          if (pcb->listener == NULL) {
 800e156:	687b      	ldr	r3, [r7, #4]
 800e158:	2280      	movs	r2, #128	; 0x80
 800e15a:	589b      	ldr	r3, [r3, r2]
 800e15c:	2b00      	cmp	r3, #0
 800e15e:	d104      	bne.n	800e16a <tcp_process+0x406>
            /* listen pcb might be closed by now */
            err = ERR_VAL;
 800e160:	231e      	movs	r3, #30
 800e162:	18fb      	adds	r3, r7, r3
 800e164:	22fa      	movs	r2, #250	; 0xfa
 800e166:	701a      	strb	r2, [r3, #0]
 800e168:	e024      	b.n	800e1b4 <tcp_process+0x450>
          } else
#endif /* LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG */
          {
#if LWIP_CALLBACK_API
            LWIP_ASSERT("pcb->listener->accept != NULL", pcb->listener->accept != NULL);
 800e16a:	687b      	ldr	r3, [r7, #4]
 800e16c:	2280      	movs	r2, #128	; 0x80
 800e16e:	589b      	ldr	r3, [r3, r2]
 800e170:	69db      	ldr	r3, [r3, #28]
 800e172:	2b00      	cmp	r3, #0
 800e174:	d105      	bne.n	800e182 <tcp_process+0x41e>
 800e176:	4bb4      	ldr	r3, [pc, #720]	; (800e448 <tcp_process+0x6e4>)
 800e178:	4ab4      	ldr	r2, [pc, #720]	; (800e44c <tcp_process+0x6e8>)
 800e17a:	49b5      	ldr	r1, [pc, #724]	; (800e450 <tcp_process+0x6ec>)
 800e17c:	48b5      	ldr	r0, [pc, #724]	; (800e454 <tcp_process+0x6f0>)
 800e17e:	f7f4 f831 	bl	80021e4 <app_debug_rtt_raw>
#endif
            tcp_backlog_accepted(pcb);
            /* Call the accept function. */
            TCP_EVENT_ACCEPT(pcb->listener, pcb, pcb->callback_arg, ERR_OK, err);
 800e182:	687b      	ldr	r3, [r7, #4]
 800e184:	2280      	movs	r2, #128	; 0x80
 800e186:	589b      	ldr	r3, [r3, r2]
 800e188:	69db      	ldr	r3, [r3, #28]
 800e18a:	2b00      	cmp	r3, #0
 800e18c:	d00e      	beq.n	800e1ac <tcp_process+0x448>
 800e18e:	687b      	ldr	r3, [r7, #4]
 800e190:	2280      	movs	r2, #128	; 0x80
 800e192:	589b      	ldr	r3, [r3, r2]
 800e194:	69dd      	ldr	r5, [r3, #28]
 800e196:	687b      	ldr	r3, [r7, #4]
 800e198:	695b      	ldr	r3, [r3, #20]
 800e19a:	221e      	movs	r2, #30
 800e19c:	18bc      	adds	r4, r7, r2
 800e19e:	6879      	ldr	r1, [r7, #4]
 800e1a0:	2200      	movs	r2, #0
 800e1a2:	0018      	movs	r0, r3
 800e1a4:	47a8      	blx	r5
 800e1a6:	0003      	movs	r3, r0
 800e1a8:	7023      	strb	r3, [r4, #0]
 800e1aa:	e003      	b.n	800e1b4 <tcp_process+0x450>
 800e1ac:	231e      	movs	r3, #30
 800e1ae:	18fb      	adds	r3, r7, r3
 800e1b0:	22f0      	movs	r2, #240	; 0xf0
 800e1b2:	701a      	strb	r2, [r3, #0]
          }
          if (err != ERR_OK) {
 800e1b4:	221e      	movs	r2, #30
 800e1b6:	18bb      	adds	r3, r7, r2
 800e1b8:	781b      	ldrb	r3, [r3, #0]
 800e1ba:	b25b      	sxtb	r3, r3
 800e1bc:	2b00      	cmp	r3, #0
 800e1be:	d00b      	beq.n	800e1d8 <tcp_process+0x474>
            /* If the accept function returns with an error, we abort
             * the connection. */
            /* Already aborted? */
            if (err != ERR_ABRT) {
 800e1c0:	18bb      	adds	r3, r7, r2
 800e1c2:	781b      	ldrb	r3, [r3, #0]
 800e1c4:	b25b      	sxtb	r3, r3
 800e1c6:	330d      	adds	r3, #13
 800e1c8:	d003      	beq.n	800e1d2 <tcp_process+0x46e>
              tcp_abort(pcb);
 800e1ca:	687b      	ldr	r3, [r7, #4]
 800e1cc:	0018      	movs	r0, r3
 800e1ce:	f7fd fa39 	bl	800b644 <tcp_abort>
            }
            return ERR_ABRT;
 800e1d2:	230d      	movs	r3, #13
 800e1d4:	425b      	negs	r3, r3
 800e1d6:	e1e5      	b.n	800e5a4 <tcp_process+0x840>
          }
          /* If there was any data contained within this ACK,
           * we'd better pass it on to the application as well. */
          tcp_receive(pcb);
 800e1d8:	687b      	ldr	r3, [r7, #4]
 800e1da:	0018      	movs	r0, r3
 800e1dc:	f000 fb42 	bl	800e864 <tcp_receive>

          /* Prevent ACK for SYN to generate a sent event */
          if (recv_acked != 0) {
 800e1e0:	4b9d      	ldr	r3, [pc, #628]	; (800e458 <tcp_process+0x6f4>)
 800e1e2:	881b      	ldrh	r3, [r3, #0]
 800e1e4:	2b00      	cmp	r3, #0
 800e1e6:	d005      	beq.n	800e1f4 <tcp_process+0x490>
            recv_acked--;
 800e1e8:	4b9b      	ldr	r3, [pc, #620]	; (800e458 <tcp_process+0x6f4>)
 800e1ea:	881b      	ldrh	r3, [r3, #0]
 800e1ec:	3b01      	subs	r3, #1
 800e1ee:	b29a      	uxth	r2, r3
 800e1f0:	4b99      	ldr	r3, [pc, #612]	; (800e458 <tcp_process+0x6f4>)
 800e1f2:	801a      	strh	r2, [r3, #0]
          }

          pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
 800e1f4:	687b      	ldr	r3, [r7, #4]
 800e1f6:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800e1f8:	009a      	lsls	r2, r3, #2
 800e1fa:	687b      	ldr	r3, [r7, #4]
 800e1fc:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800e1fe:	005b      	lsls	r3, r3, #1
 800e200:	4996      	ldr	r1, [pc, #600]	; (800e45c <tcp_process+0x6f8>)
 800e202:	428b      	cmp	r3, r1
 800e204:	d200      	bcs.n	800e208 <tcp_process+0x4a4>
 800e206:	4b95      	ldr	r3, [pc, #596]	; (800e45c <tcp_process+0x6f8>)
 800e208:	429a      	cmp	r2, r3
 800e20a:	d204      	bcs.n	800e216 <tcp_process+0x4b2>
 800e20c:	687b      	ldr	r3, [r7, #4]
 800e20e:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800e210:	009b      	lsls	r3, r3, #2
 800e212:	b29b      	uxth	r3, r3
 800e214:	e00b      	b.n	800e22e <tcp_process+0x4ca>
 800e216:	687b      	ldr	r3, [r7, #4]
 800e218:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800e21a:	005b      	lsls	r3, r3, #1
 800e21c:	4a8f      	ldr	r2, [pc, #572]	; (800e45c <tcp_process+0x6f8>)
 800e21e:	4293      	cmp	r3, r2
 800e220:	d904      	bls.n	800e22c <tcp_process+0x4c8>
 800e222:	687b      	ldr	r3, [r7, #4]
 800e224:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800e226:	18db      	adds	r3, r3, r3
 800e228:	b29b      	uxth	r3, r3
 800e22a:	e000      	b.n	800e22e <tcp_process+0x4ca>
 800e22c:	4b8b      	ldr	r3, [pc, #556]	; (800e45c <tcp_process+0x6f8>)
 800e22e:	687a      	ldr	r2, [r7, #4]
 800e230:	214c      	movs	r1, #76	; 0x4c
 800e232:	5253      	strh	r3, [r2, r1]
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SYN_RCVD): cwnd %"TCPWNDSIZE_F
                                       " ssthresh %"TCPWNDSIZE_F"\n",
                                       pcb->cwnd, pcb->ssthresh));

          if (recv_flags & TF_GOT_FIN) {
 800e234:	4b8a      	ldr	r3, [pc, #552]	; (800e460 <tcp_process+0x6fc>)
 800e236:	781b      	ldrb	r3, [r3, #0]
 800e238:	001a      	movs	r2, r3
 800e23a:	2320      	movs	r3, #32
 800e23c:	4013      	ands	r3, r2
 800e23e:	d040      	beq.n	800e2c2 <tcp_process+0x55e>
            tcp_ack_now(pcb);
 800e240:	687b      	ldr	r3, [r7, #4]
 800e242:	8bdb      	ldrh	r3, [r3, #30]
 800e244:	2202      	movs	r2, #2
 800e246:	4313      	orrs	r3, r2
 800e248:	b29a      	uxth	r2, r3
 800e24a:	687b      	ldr	r3, [r7, #4]
 800e24c:	83da      	strh	r2, [r3, #30]
            pcb->state = CLOSE_WAIT;
 800e24e:	687b      	ldr	r3, [r7, #4]
 800e250:	2207      	movs	r2, #7
 800e252:	761a      	strb	r2, [r3, #24]
          if (recv_flags & TF_GOT_FIN) {
 800e254:	e035      	b.n	800e2c2 <tcp_process+0x55e>
          }
        } else {
          /* incorrect ACK number, send RST */
          tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800e256:	4b7b      	ldr	r3, [pc, #492]	; (800e444 <tcp_process+0x6e0>)
 800e258:	681c      	ldr	r4, [r3, #0]
 800e25a:	4b82      	ldr	r3, [pc, #520]	; (800e464 <tcp_process+0x700>)
 800e25c:	881b      	ldrh	r3, [r3, #0]
 800e25e:	001a      	movs	r2, r3
 800e260:	4b81      	ldr	r3, [pc, #516]	; (800e468 <tcp_process+0x704>)
 800e262:	681b      	ldr	r3, [r3, #0]
 800e264:	18d5      	adds	r5, r2, r3
                  ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800e266:	4b81      	ldr	r3, [pc, #516]	; (800e46c <tcp_process+0x708>)
 800e268:	681b      	ldr	r3, [r3, #0]
          tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800e26a:	789a      	ldrb	r2, [r3, #2]
 800e26c:	78db      	ldrb	r3, [r3, #3]
 800e26e:	021b      	lsls	r3, r3, #8
 800e270:	4313      	orrs	r3, r2
 800e272:	b29a      	uxth	r2, r3
                  ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800e274:	4b7d      	ldr	r3, [pc, #500]	; (800e46c <tcp_process+0x708>)
 800e276:	681b      	ldr	r3, [r3, #0]
          tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800e278:	7819      	ldrb	r1, [r3, #0]
 800e27a:	785b      	ldrb	r3, [r3, #1]
 800e27c:	021b      	lsls	r3, r3, #8
 800e27e:	430b      	orrs	r3, r1
 800e280:	b29b      	uxth	r3, r3
 800e282:	497b      	ldr	r1, [pc, #492]	; (800e470 <tcp_process+0x70c>)
 800e284:	6878      	ldr	r0, [r7, #4]
 800e286:	9302      	str	r3, [sp, #8]
 800e288:	9201      	str	r2, [sp, #4]
 800e28a:	4b7a      	ldr	r3, [pc, #488]	; (800e474 <tcp_process+0x710>)
 800e28c:	9300      	str	r3, [sp, #0]
 800e28e:	000b      	movs	r3, r1
 800e290:	002a      	movs	r2, r5
 800e292:	0021      	movs	r1, r4
 800e294:	f004 f8ce 	bl	8012434 <tcp_rst>
        }
      } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
        /* Looks like another copy of the SYN - retransmit our SYN-ACK */
        tcp_rexmit(pcb);
      }
      break;
 800e298:	e178      	b.n	800e58c <tcp_process+0x828>
      } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
 800e29a:	4b69      	ldr	r3, [pc, #420]	; (800e440 <tcp_process+0x6dc>)
 800e29c:	781b      	ldrb	r3, [r3, #0]
 800e29e:	001a      	movs	r2, r3
 800e2a0:	2302      	movs	r3, #2
 800e2a2:	4013      	ands	r3, r2
 800e2a4:	d100      	bne.n	800e2a8 <tcp_process+0x544>
 800e2a6:	e171      	b.n	800e58c <tcp_process+0x828>
 800e2a8:	687b      	ldr	r3, [r7, #4]
 800e2aa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800e2ac:	1e5a      	subs	r2, r3, #1
 800e2ae:	4b6e      	ldr	r3, [pc, #440]	; (800e468 <tcp_process+0x704>)
 800e2b0:	681b      	ldr	r3, [r3, #0]
 800e2b2:	429a      	cmp	r2, r3
 800e2b4:	d000      	beq.n	800e2b8 <tcp_process+0x554>
 800e2b6:	e169      	b.n	800e58c <tcp_process+0x828>
        tcp_rexmit(pcb);
 800e2b8:	687b      	ldr	r3, [r7, #4]
 800e2ba:	0018      	movs	r0, r3
 800e2bc:	f003 fd96 	bl	8011dec <tcp_rexmit>
      break;
 800e2c0:	e164      	b.n	800e58c <tcp_process+0x828>
 800e2c2:	e163      	b.n	800e58c <tcp_process+0x828>
    case CLOSE_WAIT:
    /* FALLTHROUGH */
    case ESTABLISHED:
      tcp_receive(pcb);
 800e2c4:	687b      	ldr	r3, [r7, #4]
 800e2c6:	0018      	movs	r0, r3
 800e2c8:	f000 facc 	bl	800e864 <tcp_receive>
      if (recv_flags & TF_GOT_FIN) { /* passive close */
 800e2cc:	4b64      	ldr	r3, [pc, #400]	; (800e460 <tcp_process+0x6fc>)
 800e2ce:	781b      	ldrb	r3, [r3, #0]
 800e2d0:	001a      	movs	r2, r3
 800e2d2:	2320      	movs	r3, #32
 800e2d4:	4013      	ands	r3, r2
 800e2d6:	d100      	bne.n	800e2da <tcp_process+0x576>
 800e2d8:	e15a      	b.n	800e590 <tcp_process+0x82c>
        tcp_ack_now(pcb);
 800e2da:	687b      	ldr	r3, [r7, #4]
 800e2dc:	8bdb      	ldrh	r3, [r3, #30]
 800e2de:	2202      	movs	r2, #2
 800e2e0:	4313      	orrs	r3, r2
 800e2e2:	b29a      	uxth	r2, r3
 800e2e4:	687b      	ldr	r3, [r7, #4]
 800e2e6:	83da      	strh	r2, [r3, #30]
        pcb->state = CLOSE_WAIT;
 800e2e8:	687b      	ldr	r3, [r7, #4]
 800e2ea:	2207      	movs	r2, #7
 800e2ec:	761a      	strb	r2, [r3, #24]
      }
      break;
 800e2ee:	e14f      	b.n	800e590 <tcp_process+0x82c>
    case FIN_WAIT_1:
      tcp_receive(pcb);
 800e2f0:	687b      	ldr	r3, [r7, #4]
 800e2f2:	0018      	movs	r0, r3
 800e2f4:	f000 fab6 	bl	800e864 <tcp_receive>
      if (recv_flags & TF_GOT_FIN) {
 800e2f8:	4b59      	ldr	r3, [pc, #356]	; (800e460 <tcp_process+0x6fc>)
 800e2fa:	781b      	ldrb	r3, [r3, #0]
 800e2fc:	001a      	movs	r2, r3
 800e2fe:	2320      	movs	r3, #32
 800e300:	4013      	ands	r3, r2
 800e302:	d057      	beq.n	800e3b4 <tcp_process+0x650>
        if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 800e304:	4b4e      	ldr	r3, [pc, #312]	; (800e440 <tcp_process+0x6dc>)
 800e306:	781b      	ldrb	r3, [r3, #0]
 800e308:	001a      	movs	r2, r3
 800e30a:	2310      	movs	r3, #16
 800e30c:	4013      	ands	r3, r2
 800e30e:	d046      	beq.n	800e39e <tcp_process+0x63a>
 800e310:	687b      	ldr	r3, [r7, #4]
 800e312:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800e314:	4b4b      	ldr	r3, [pc, #300]	; (800e444 <tcp_process+0x6e0>)
 800e316:	681b      	ldr	r3, [r3, #0]
 800e318:	429a      	cmp	r2, r3
 800e31a:	d140      	bne.n	800e39e <tcp_process+0x63a>
            pcb->unsent == NULL) {
 800e31c:	687b      	ldr	r3, [r7, #4]
 800e31e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
        if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 800e320:	2b00      	cmp	r3, #0
 800e322:	d13c      	bne.n	800e39e <tcp_process+0x63a>
          LWIP_DEBUGF(TCP_DEBUG,
                      ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
          tcp_ack_now(pcb);
 800e324:	687b      	ldr	r3, [r7, #4]
 800e326:	8bdb      	ldrh	r3, [r3, #30]
 800e328:	2202      	movs	r2, #2
 800e32a:	4313      	orrs	r3, r2
 800e32c:	b29a      	uxth	r2, r3
 800e32e:	687b      	ldr	r3, [r7, #4]
 800e330:	83da      	strh	r2, [r3, #30]
          tcp_pcb_purge(pcb);
 800e332:	687b      	ldr	r3, [r7, #4]
 800e334:	0018      	movs	r0, r3
 800e336:	f7fe fbfd 	bl	800cb34 <tcp_pcb_purge>
          TCP_RMV_ACTIVE(pcb);
 800e33a:	4b4f      	ldr	r3, [pc, #316]	; (800e478 <tcp_process+0x714>)
 800e33c:	681b      	ldr	r3, [r3, #0]
 800e33e:	687a      	ldr	r2, [r7, #4]
 800e340:	429a      	cmp	r2, r3
 800e342:	d105      	bne.n	800e350 <tcp_process+0x5ec>
 800e344:	4b4c      	ldr	r3, [pc, #304]	; (800e478 <tcp_process+0x714>)
 800e346:	681b      	ldr	r3, [r3, #0]
 800e348:	691a      	ldr	r2, [r3, #16]
 800e34a:	4b4b      	ldr	r3, [pc, #300]	; (800e478 <tcp_process+0x714>)
 800e34c:	601a      	str	r2, [r3, #0]
 800e34e:	e013      	b.n	800e378 <tcp_process+0x614>
 800e350:	4b49      	ldr	r3, [pc, #292]	; (800e478 <tcp_process+0x714>)
 800e352:	681b      	ldr	r3, [r3, #0]
 800e354:	613b      	str	r3, [r7, #16]
 800e356:	e00c      	b.n	800e372 <tcp_process+0x60e>
 800e358:	693b      	ldr	r3, [r7, #16]
 800e35a:	691b      	ldr	r3, [r3, #16]
 800e35c:	687a      	ldr	r2, [r7, #4]
 800e35e:	429a      	cmp	r2, r3
 800e360:	d104      	bne.n	800e36c <tcp_process+0x608>
 800e362:	687b      	ldr	r3, [r7, #4]
 800e364:	691a      	ldr	r2, [r3, #16]
 800e366:	693b      	ldr	r3, [r7, #16]
 800e368:	611a      	str	r2, [r3, #16]
 800e36a:	e005      	b.n	800e378 <tcp_process+0x614>
 800e36c:	693b      	ldr	r3, [r7, #16]
 800e36e:	691b      	ldr	r3, [r3, #16]
 800e370:	613b      	str	r3, [r7, #16]
 800e372:	693b      	ldr	r3, [r7, #16]
 800e374:	2b00      	cmp	r3, #0
 800e376:	d1ef      	bne.n	800e358 <tcp_process+0x5f4>
 800e378:	687b      	ldr	r3, [r7, #4]
 800e37a:	2200      	movs	r2, #0
 800e37c:	611a      	str	r2, [r3, #16]
 800e37e:	4b3f      	ldr	r3, [pc, #252]	; (800e47c <tcp_process+0x718>)
 800e380:	2201      	movs	r2, #1
 800e382:	701a      	strb	r2, [r3, #0]
          pcb->state = TIME_WAIT;
 800e384:	687b      	ldr	r3, [r7, #4]
 800e386:	220a      	movs	r2, #10
 800e388:	761a      	strb	r2, [r3, #24]
          TCP_REG(&tcp_tw_pcbs, pcb);
 800e38a:	4b3d      	ldr	r3, [pc, #244]	; (800e480 <tcp_process+0x71c>)
 800e38c:	681a      	ldr	r2, [r3, #0]
 800e38e:	687b      	ldr	r3, [r7, #4]
 800e390:	611a      	str	r2, [r3, #16]
 800e392:	4b3b      	ldr	r3, [pc, #236]	; (800e480 <tcp_process+0x71c>)
 800e394:	687a      	ldr	r2, [r7, #4]
 800e396:	601a      	str	r2, [r3, #0]
 800e398:	f004 fa76 	bl	8012888 <tcp_timer_needed>
        }
      } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
                 pcb->unsent == NULL) {
        pcb->state = FIN_WAIT_2;
      }
      break;
 800e39c:	e0fa      	b.n	800e594 <tcp_process+0x830>
          tcp_ack_now(pcb);
 800e39e:	687b      	ldr	r3, [r7, #4]
 800e3a0:	8bdb      	ldrh	r3, [r3, #30]
 800e3a2:	2202      	movs	r2, #2
 800e3a4:	4313      	orrs	r3, r2
 800e3a6:	b29a      	uxth	r2, r3
 800e3a8:	687b      	ldr	r3, [r7, #4]
 800e3aa:	83da      	strh	r2, [r3, #30]
          pcb->state = CLOSING;
 800e3ac:	687b      	ldr	r3, [r7, #4]
 800e3ae:	2208      	movs	r2, #8
 800e3b0:	761a      	strb	r2, [r3, #24]
      break;
 800e3b2:	e0ef      	b.n	800e594 <tcp_process+0x830>
      } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 800e3b4:	4b22      	ldr	r3, [pc, #136]	; (800e440 <tcp_process+0x6dc>)
 800e3b6:	781b      	ldrb	r3, [r3, #0]
 800e3b8:	001a      	movs	r2, r3
 800e3ba:	2310      	movs	r3, #16
 800e3bc:	4013      	ands	r3, r2
 800e3be:	d100      	bne.n	800e3c2 <tcp_process+0x65e>
 800e3c0:	e0e8      	b.n	800e594 <tcp_process+0x830>
 800e3c2:	687b      	ldr	r3, [r7, #4]
 800e3c4:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800e3c6:	4b1f      	ldr	r3, [pc, #124]	; (800e444 <tcp_process+0x6e0>)
 800e3c8:	681b      	ldr	r3, [r3, #0]
 800e3ca:	429a      	cmp	r2, r3
 800e3cc:	d000      	beq.n	800e3d0 <tcp_process+0x66c>
 800e3ce:	e0e1      	b.n	800e594 <tcp_process+0x830>
                 pcb->unsent == NULL) {
 800e3d0:	687b      	ldr	r3, [r7, #4]
 800e3d2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
      } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 800e3d4:	2b00      	cmp	r3, #0
 800e3d6:	d000      	beq.n	800e3da <tcp_process+0x676>
 800e3d8:	e0dc      	b.n	800e594 <tcp_process+0x830>
        pcb->state = FIN_WAIT_2;
 800e3da:	687b      	ldr	r3, [r7, #4]
 800e3dc:	2206      	movs	r2, #6
 800e3de:	761a      	strb	r2, [r3, #24]
      break;
 800e3e0:	e0d8      	b.n	800e594 <tcp_process+0x830>
    case FIN_WAIT_2:
      tcp_receive(pcb);
 800e3e2:	687b      	ldr	r3, [r7, #4]
 800e3e4:	0018      	movs	r0, r3
 800e3e6:	f000 fa3d 	bl	800e864 <tcp_receive>
      if (recv_flags & TF_GOT_FIN) {
 800e3ea:	4b1d      	ldr	r3, [pc, #116]	; (800e460 <tcp_process+0x6fc>)
 800e3ec:	781b      	ldrb	r3, [r3, #0]
 800e3ee:	001a      	movs	r2, r3
 800e3f0:	2320      	movs	r3, #32
 800e3f2:	4013      	ands	r3, r2
 800e3f4:	d100      	bne.n	800e3f8 <tcp_process+0x694>
 800e3f6:	e0cf      	b.n	800e598 <tcp_process+0x834>
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
 800e3f8:	687b      	ldr	r3, [r7, #4]
 800e3fa:	8bdb      	ldrh	r3, [r3, #30]
 800e3fc:	2202      	movs	r2, #2
 800e3fe:	4313      	orrs	r3, r2
 800e400:	b29a      	uxth	r2, r3
 800e402:	687b      	ldr	r3, [r7, #4]
 800e404:	83da      	strh	r2, [r3, #30]
        tcp_pcb_purge(pcb);
 800e406:	687b      	ldr	r3, [r7, #4]
 800e408:	0018      	movs	r0, r3
 800e40a:	f7fe fb93 	bl	800cb34 <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
 800e40e:	4b1a      	ldr	r3, [pc, #104]	; (800e478 <tcp_process+0x714>)
 800e410:	681b      	ldr	r3, [r3, #0]
 800e412:	687a      	ldr	r2, [r7, #4]
 800e414:	429a      	cmp	r2, r3
 800e416:	d105      	bne.n	800e424 <tcp_process+0x6c0>
 800e418:	4b17      	ldr	r3, [pc, #92]	; (800e478 <tcp_process+0x714>)
 800e41a:	681b      	ldr	r3, [r3, #0]
 800e41c:	691a      	ldr	r2, [r3, #16]
 800e41e:	4b16      	ldr	r3, [pc, #88]	; (800e478 <tcp_process+0x714>)
 800e420:	601a      	str	r2, [r3, #0]
 800e422:	e035      	b.n	800e490 <tcp_process+0x72c>
 800e424:	4b14      	ldr	r3, [pc, #80]	; (800e478 <tcp_process+0x714>)
 800e426:	681b      	ldr	r3, [r3, #0]
 800e428:	60fb      	str	r3, [r7, #12]
 800e42a:	e02e      	b.n	800e48a <tcp_process+0x726>
 800e42c:	68fb      	ldr	r3, [r7, #12]
 800e42e:	691b      	ldr	r3, [r3, #16]
 800e430:	687a      	ldr	r2, [r7, #4]
 800e432:	429a      	cmp	r2, r3
 800e434:	d126      	bne.n	800e484 <tcp_process+0x720>
 800e436:	687b      	ldr	r3, [r7, #4]
 800e438:	691a      	ldr	r2, [r3, #16]
 800e43a:	68fb      	ldr	r3, [r7, #12]
 800e43c:	611a      	str	r2, [r3, #16]
 800e43e:	e027      	b.n	800e490 <tcp_process+0x72c>
 800e440:	20000c78 	.word	0x20000c78
 800e444:	20000c70 	.word	0x20000c70
 800e448:	0802120c 	.word	0x0802120c
 800e44c:	000003a9 	.word	0x000003a9
 800e450:	080214a4 	.word	0x080214a4
 800e454:	0802124c 	.word	0x0802124c
 800e458:	20000c74 	.word	0x20000c74
 800e45c:	0000111c 	.word	0x0000111c
 800e460:	20000c79 	.word	0x20000c79
 800e464:	20000c76 	.word	0x20000c76
 800e468:	20000c6c 	.word	0x20000c6c
 800e46c:	20000c5c 	.word	0x20000c5c
 800e470:	2000114c 	.word	0x2000114c
 800e474:	20001148 	.word	0x20001148
 800e478:	2000278c 	.word	0x2000278c
 800e47c:	20002788 	.word	0x20002788
 800e480:	2000279c 	.word	0x2000279c
 800e484:	68fb      	ldr	r3, [r7, #12]
 800e486:	691b      	ldr	r3, [r3, #16]
 800e488:	60fb      	str	r3, [r7, #12]
 800e48a:	68fb      	ldr	r3, [r7, #12]
 800e48c:	2b00      	cmp	r3, #0
 800e48e:	d1cd      	bne.n	800e42c <tcp_process+0x6c8>
 800e490:	687b      	ldr	r3, [r7, #4]
 800e492:	2200      	movs	r2, #0
 800e494:	611a      	str	r2, [r3, #16]
 800e496:	4b45      	ldr	r3, [pc, #276]	; (800e5ac <tcp_process+0x848>)
 800e498:	2201      	movs	r2, #1
 800e49a:	701a      	strb	r2, [r3, #0]
        pcb->state = TIME_WAIT;
 800e49c:	687b      	ldr	r3, [r7, #4]
 800e49e:	220a      	movs	r2, #10
 800e4a0:	761a      	strb	r2, [r3, #24]
        TCP_REG(&tcp_tw_pcbs, pcb);
 800e4a2:	4b43      	ldr	r3, [pc, #268]	; (800e5b0 <tcp_process+0x84c>)
 800e4a4:	681a      	ldr	r2, [r3, #0]
 800e4a6:	687b      	ldr	r3, [r7, #4]
 800e4a8:	611a      	str	r2, [r3, #16]
 800e4aa:	4b41      	ldr	r3, [pc, #260]	; (800e5b0 <tcp_process+0x84c>)
 800e4ac:	687a      	ldr	r2, [r7, #4]
 800e4ae:	601a      	str	r2, [r3, #0]
 800e4b0:	f004 f9ea 	bl	8012888 <tcp_timer_needed>
      }
      break;
 800e4b4:	e070      	b.n	800e598 <tcp_process+0x834>
    case CLOSING:
      tcp_receive(pcb);
 800e4b6:	687b      	ldr	r3, [r7, #4]
 800e4b8:	0018      	movs	r0, r3
 800e4ba:	f000 f9d3 	bl	800e864 <tcp_receive>
      if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
 800e4be:	4b3d      	ldr	r3, [pc, #244]	; (800e5b4 <tcp_process+0x850>)
 800e4c0:	781b      	ldrb	r3, [r3, #0]
 800e4c2:	001a      	movs	r2, r3
 800e4c4:	2310      	movs	r3, #16
 800e4c6:	4013      	ands	r3, r2
 800e4c8:	d100      	bne.n	800e4cc <tcp_process+0x768>
 800e4ca:	e067      	b.n	800e59c <tcp_process+0x838>
 800e4cc:	687b      	ldr	r3, [r7, #4]
 800e4ce:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800e4d0:	4b39      	ldr	r3, [pc, #228]	; (800e5b8 <tcp_process+0x854>)
 800e4d2:	681b      	ldr	r3, [r3, #0]
 800e4d4:	429a      	cmp	r2, r3
 800e4d6:	d161      	bne.n	800e59c <tcp_process+0x838>
 800e4d8:	687b      	ldr	r3, [r7, #4]
 800e4da:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800e4dc:	2b00      	cmp	r3, #0
 800e4de:	d15d      	bne.n	800e59c <tcp_process+0x838>
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_pcb_purge(pcb);
 800e4e0:	687b      	ldr	r3, [r7, #4]
 800e4e2:	0018      	movs	r0, r3
 800e4e4:	f7fe fb26 	bl	800cb34 <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
 800e4e8:	4b34      	ldr	r3, [pc, #208]	; (800e5bc <tcp_process+0x858>)
 800e4ea:	681b      	ldr	r3, [r3, #0]
 800e4ec:	687a      	ldr	r2, [r7, #4]
 800e4ee:	429a      	cmp	r2, r3
 800e4f0:	d105      	bne.n	800e4fe <tcp_process+0x79a>
 800e4f2:	4b32      	ldr	r3, [pc, #200]	; (800e5bc <tcp_process+0x858>)
 800e4f4:	681b      	ldr	r3, [r3, #0]
 800e4f6:	691a      	ldr	r2, [r3, #16]
 800e4f8:	4b30      	ldr	r3, [pc, #192]	; (800e5bc <tcp_process+0x858>)
 800e4fa:	601a      	str	r2, [r3, #0]
 800e4fc:	e013      	b.n	800e526 <tcp_process+0x7c2>
 800e4fe:	4b2f      	ldr	r3, [pc, #188]	; (800e5bc <tcp_process+0x858>)
 800e500:	681b      	ldr	r3, [r3, #0]
 800e502:	61bb      	str	r3, [r7, #24]
 800e504:	e00c      	b.n	800e520 <tcp_process+0x7bc>
 800e506:	69bb      	ldr	r3, [r7, #24]
 800e508:	691b      	ldr	r3, [r3, #16]
 800e50a:	687a      	ldr	r2, [r7, #4]
 800e50c:	429a      	cmp	r2, r3
 800e50e:	d104      	bne.n	800e51a <tcp_process+0x7b6>
 800e510:	687b      	ldr	r3, [r7, #4]
 800e512:	691a      	ldr	r2, [r3, #16]
 800e514:	69bb      	ldr	r3, [r7, #24]
 800e516:	611a      	str	r2, [r3, #16]
 800e518:	e005      	b.n	800e526 <tcp_process+0x7c2>
 800e51a:	69bb      	ldr	r3, [r7, #24]
 800e51c:	691b      	ldr	r3, [r3, #16]
 800e51e:	61bb      	str	r3, [r7, #24]
 800e520:	69bb      	ldr	r3, [r7, #24]
 800e522:	2b00      	cmp	r3, #0
 800e524:	d1ef      	bne.n	800e506 <tcp_process+0x7a2>
 800e526:	687b      	ldr	r3, [r7, #4]
 800e528:	2200      	movs	r2, #0
 800e52a:	611a      	str	r2, [r3, #16]
 800e52c:	4b1f      	ldr	r3, [pc, #124]	; (800e5ac <tcp_process+0x848>)
 800e52e:	2201      	movs	r2, #1
 800e530:	701a      	strb	r2, [r3, #0]
        pcb->state = TIME_WAIT;
 800e532:	687b      	ldr	r3, [r7, #4]
 800e534:	220a      	movs	r2, #10
 800e536:	761a      	strb	r2, [r3, #24]
        TCP_REG(&tcp_tw_pcbs, pcb);
 800e538:	4b1d      	ldr	r3, [pc, #116]	; (800e5b0 <tcp_process+0x84c>)
 800e53a:	681a      	ldr	r2, [r3, #0]
 800e53c:	687b      	ldr	r3, [r7, #4]
 800e53e:	611a      	str	r2, [r3, #16]
 800e540:	4b1b      	ldr	r3, [pc, #108]	; (800e5b0 <tcp_process+0x84c>)
 800e542:	687a      	ldr	r2, [r7, #4]
 800e544:	601a      	str	r2, [r3, #0]
 800e546:	f004 f99f 	bl	8012888 <tcp_timer_needed>
      }
      break;
 800e54a:	e027      	b.n	800e59c <tcp_process+0x838>
    case LAST_ACK:
      tcp_receive(pcb);
 800e54c:	687b      	ldr	r3, [r7, #4]
 800e54e:	0018      	movs	r0, r3
 800e550:	f000 f988 	bl	800e864 <tcp_receive>
      if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
 800e554:	4b17      	ldr	r3, [pc, #92]	; (800e5b4 <tcp_process+0x850>)
 800e556:	781b      	ldrb	r3, [r3, #0]
 800e558:	001a      	movs	r2, r3
 800e55a:	2310      	movs	r3, #16
 800e55c:	4013      	ands	r3, r2
 800e55e:	d01f      	beq.n	800e5a0 <tcp_process+0x83c>
 800e560:	687b      	ldr	r3, [r7, #4]
 800e562:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800e564:	4b14      	ldr	r3, [pc, #80]	; (800e5b8 <tcp_process+0x854>)
 800e566:	681b      	ldr	r3, [r3, #0]
 800e568:	429a      	cmp	r2, r3
 800e56a:	d119      	bne.n	800e5a0 <tcp_process+0x83c>
 800e56c:	687b      	ldr	r3, [r7, #4]
 800e56e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800e570:	2b00      	cmp	r3, #0
 800e572:	d115      	bne.n	800e5a0 <tcp_process+0x83c>
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
        recv_flags |= TF_CLOSED;
 800e574:	4b12      	ldr	r3, [pc, #72]	; (800e5c0 <tcp_process+0x85c>)
 800e576:	781b      	ldrb	r3, [r3, #0]
 800e578:	2210      	movs	r2, #16
 800e57a:	4313      	orrs	r3, r2
 800e57c:	b2da      	uxtb	r2, r3
 800e57e:	4b10      	ldr	r3, [pc, #64]	; (800e5c0 <tcp_process+0x85c>)
 800e580:	701a      	strb	r2, [r3, #0]
      }
      break;
 800e582:	e00d      	b.n	800e5a0 <tcp_process+0x83c>
    default:
      break;
 800e584:	46c0      	nop			; (mov r8, r8)
 800e586:	e00c      	b.n	800e5a2 <tcp_process+0x83e>
      break;
 800e588:	46c0      	nop			; (mov r8, r8)
 800e58a:	e00a      	b.n	800e5a2 <tcp_process+0x83e>
      break;
 800e58c:	46c0      	nop			; (mov r8, r8)
 800e58e:	e008      	b.n	800e5a2 <tcp_process+0x83e>
      break;
 800e590:	46c0      	nop			; (mov r8, r8)
 800e592:	e006      	b.n	800e5a2 <tcp_process+0x83e>
      break;
 800e594:	46c0      	nop			; (mov r8, r8)
 800e596:	e004      	b.n	800e5a2 <tcp_process+0x83e>
      break;
 800e598:	46c0      	nop			; (mov r8, r8)
 800e59a:	e002      	b.n	800e5a2 <tcp_process+0x83e>
      break;
 800e59c:	46c0      	nop			; (mov r8, r8)
 800e59e:	e000      	b.n	800e5a2 <tcp_process+0x83e>
      break;
 800e5a0:	46c0      	nop			; (mov r8, r8)
  }
  return ERR_OK;
 800e5a2:	2300      	movs	r3, #0
}
 800e5a4:	0018      	movs	r0, r3
 800e5a6:	46bd      	mov	sp, r7
 800e5a8:	b008      	add	sp, #32
 800e5aa:	bdb0      	pop	{r4, r5, r7, pc}
 800e5ac:	20002788 	.word	0x20002788
 800e5b0:	2000279c 	.word	0x2000279c
 800e5b4:	20000c78 	.word	0x20000c78
 800e5b8:	20000c70 	.word	0x20000c70
 800e5bc:	2000278c 	.word	0x2000278c
 800e5c0:	20000c79 	.word	0x20000c79

0800e5c4 <tcp_oos_insert_segment>:
 *
 * Called from tcp_receive()
 */
static void
tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
{
 800e5c4:	b590      	push	{r4, r7, lr}
 800e5c6:	b085      	sub	sp, #20
 800e5c8:	af00      	add	r7, sp, #0
 800e5ca:	6078      	str	r0, [r7, #4]
 800e5cc:	6039      	str	r1, [r7, #0]
  struct tcp_seg *old_seg;

  LWIP_ASSERT("tcp_oos_insert_segment: invalid cseg", cseg != NULL);
 800e5ce:	687b      	ldr	r3, [r7, #4]
 800e5d0:	2b00      	cmp	r3, #0
 800e5d2:	d106      	bne.n	800e5e2 <tcp_oos_insert_segment+0x1e>
 800e5d4:	4b57      	ldr	r3, [pc, #348]	; (800e734 <tcp_oos_insert_segment+0x170>)
 800e5d6:	2284      	movs	r2, #132	; 0x84
 800e5d8:	00d2      	lsls	r2, r2, #3
 800e5da:	4957      	ldr	r1, [pc, #348]	; (800e738 <tcp_oos_insert_segment+0x174>)
 800e5dc:	4857      	ldr	r0, [pc, #348]	; (800e73c <tcp_oos_insert_segment+0x178>)
 800e5de:	f7f3 fe01 	bl	80021e4 <app_debug_rtt_raw>

  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 800e5e2:	687b      	ldr	r3, [r7, #4]
 800e5e4:	691b      	ldr	r3, [r3, #16]
 800e5e6:	7b1a      	ldrb	r2, [r3, #12]
 800e5e8:	7b5b      	ldrb	r3, [r3, #13]
 800e5ea:	021b      	lsls	r3, r3, #8
 800e5ec:	4313      	orrs	r3, r2
 800e5ee:	b29b      	uxth	r3, r3
 800e5f0:	0018      	movs	r0, r3
 800e5f2:	f7f8 ff05 	bl	8007400 <lwip_htons>
 800e5f6:	0003      	movs	r3, r0
 800e5f8:	b2db      	uxtb	r3, r3
 800e5fa:	001a      	movs	r2, r3
 800e5fc:	2301      	movs	r3, #1
 800e5fe:	4013      	ands	r3, r2
 800e600:	d042      	beq.n	800e688 <tcp_oos_insert_segment+0xc4>
    /* received segment overlaps all following segments */
    tcp_segs_free(next);
 800e602:	683b      	ldr	r3, [r7, #0]
 800e604:	0018      	movs	r0, r3
 800e606:	f7fd ffaf 	bl	800c568 <tcp_segs_free>
    next = NULL;
 800e60a:	2300      	movs	r3, #0
 800e60c:	603b      	str	r3, [r7, #0]
 800e60e:	e08a      	b.n	800e726 <tcp_oos_insert_segment+0x162>
       oos queue may have segments with FIN flag */
    while (next &&
           TCP_SEQ_GEQ((seqno + cseg->len),
                       (next->tcphdr->seqno + next->len))) {
      /* cseg with FIN already processed */
      if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 800e610:	683b      	ldr	r3, [r7, #0]
 800e612:	691b      	ldr	r3, [r3, #16]
 800e614:	7b1a      	ldrb	r2, [r3, #12]
 800e616:	7b5b      	ldrb	r3, [r3, #13]
 800e618:	021b      	lsls	r3, r3, #8
 800e61a:	4313      	orrs	r3, r2
 800e61c:	b29b      	uxth	r3, r3
 800e61e:	0018      	movs	r0, r3
 800e620:	f7f8 feee 	bl	8007400 <lwip_htons>
 800e624:	0003      	movs	r3, r0
 800e626:	b2db      	uxtb	r3, r3
 800e628:	001a      	movs	r2, r3
 800e62a:	2301      	movs	r3, #1
 800e62c:	4013      	ands	r3, r2
 800e62e:	d022      	beq.n	800e676 <tcp_oos_insert_segment+0xb2>
        TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
 800e630:	687b      	ldr	r3, [r7, #4]
 800e632:	691b      	ldr	r3, [r3, #16]
 800e634:	7b1a      	ldrb	r2, [r3, #12]
 800e636:	7b5b      	ldrb	r3, [r3, #13]
 800e638:	021b      	lsls	r3, r3, #8
 800e63a:	4313      	orrs	r3, r2
 800e63c:	b29c      	uxth	r4, r3
 800e63e:	2001      	movs	r0, #1
 800e640:	f7f8 fede 	bl	8007400 <lwip_htons>
 800e644:	0003      	movs	r3, r0
 800e646:	001a      	movs	r2, r3
 800e648:	687b      	ldr	r3, [r7, #4]
 800e64a:	691b      	ldr	r3, [r3, #16]
 800e64c:	4322      	orrs	r2, r4
 800e64e:	b292      	uxth	r2, r2
 800e650:	21ff      	movs	r1, #255	; 0xff
 800e652:	4011      	ands	r1, r2
 800e654:	000c      	movs	r4, r1
 800e656:	7b19      	ldrb	r1, [r3, #12]
 800e658:	2000      	movs	r0, #0
 800e65a:	4001      	ands	r1, r0
 800e65c:	1c08      	adds	r0, r1, #0
 800e65e:	1c21      	adds	r1, r4, #0
 800e660:	4301      	orrs	r1, r0
 800e662:	7319      	strb	r1, [r3, #12]
 800e664:	0a12      	lsrs	r2, r2, #8
 800e666:	b290      	uxth	r0, r2
 800e668:	7b5a      	ldrb	r2, [r3, #13]
 800e66a:	2100      	movs	r1, #0
 800e66c:	400a      	ands	r2, r1
 800e66e:	1c11      	adds	r1, r2, #0
 800e670:	1c02      	adds	r2, r0, #0
 800e672:	430a      	orrs	r2, r1
 800e674:	735a      	strb	r2, [r3, #13]
      }
      old_seg = next;
 800e676:	683b      	ldr	r3, [r7, #0]
 800e678:	60fb      	str	r3, [r7, #12]
      next = next->next;
 800e67a:	683b      	ldr	r3, [r7, #0]
 800e67c:	681b      	ldr	r3, [r3, #0]
 800e67e:	603b      	str	r3, [r7, #0]
      tcp_seg_free(old_seg);
 800e680:	68fb      	ldr	r3, [r7, #12]
 800e682:	0018      	movs	r0, r3
 800e684:	f7fd ff86 	bl	800c594 <tcp_seg_free>
    while (next &&
 800e688:	683b      	ldr	r3, [r7, #0]
 800e68a:	2b00      	cmp	r3, #0
 800e68c:	d017      	beq.n	800e6be <tcp_oos_insert_segment+0xfa>
           TCP_SEQ_GEQ((seqno + cseg->len),
 800e68e:	687b      	ldr	r3, [r7, #4]
 800e690:	891b      	ldrh	r3, [r3, #8]
 800e692:	001a      	movs	r2, r3
 800e694:	4b2a      	ldr	r3, [pc, #168]	; (800e740 <tcp_oos_insert_segment+0x17c>)
 800e696:	681b      	ldr	r3, [r3, #0]
 800e698:	18d2      	adds	r2, r2, r3
 800e69a:	683b      	ldr	r3, [r7, #0]
 800e69c:	691b      	ldr	r3, [r3, #16]
 800e69e:	7919      	ldrb	r1, [r3, #4]
 800e6a0:	7958      	ldrb	r0, [r3, #5]
 800e6a2:	0200      	lsls	r0, r0, #8
 800e6a4:	4301      	orrs	r1, r0
 800e6a6:	7998      	ldrb	r0, [r3, #6]
 800e6a8:	0400      	lsls	r0, r0, #16
 800e6aa:	4301      	orrs	r1, r0
 800e6ac:	79db      	ldrb	r3, [r3, #7]
 800e6ae:	061b      	lsls	r3, r3, #24
 800e6b0:	430b      	orrs	r3, r1
 800e6b2:	0019      	movs	r1, r3
 800e6b4:	683b      	ldr	r3, [r7, #0]
 800e6b6:	891b      	ldrh	r3, [r3, #8]
 800e6b8:	18cb      	adds	r3, r1, r3
 800e6ba:	1ad3      	subs	r3, r2, r3
    while (next &&
 800e6bc:	d5a8      	bpl.n	800e610 <tcp_oos_insert_segment+0x4c>
    }
    if (next &&
 800e6be:	683b      	ldr	r3, [r7, #0]
 800e6c0:	2b00      	cmp	r3, #0
 800e6c2:	d030      	beq.n	800e726 <tcp_oos_insert_segment+0x162>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
 800e6c4:	687b      	ldr	r3, [r7, #4]
 800e6c6:	891b      	ldrh	r3, [r3, #8]
 800e6c8:	001a      	movs	r2, r3
 800e6ca:	4b1d      	ldr	r3, [pc, #116]	; (800e740 <tcp_oos_insert_segment+0x17c>)
 800e6cc:	681b      	ldr	r3, [r3, #0]
 800e6ce:	18d2      	adds	r2, r2, r3
 800e6d0:	683b      	ldr	r3, [r7, #0]
 800e6d2:	691b      	ldr	r3, [r3, #16]
 800e6d4:	7919      	ldrb	r1, [r3, #4]
 800e6d6:	7958      	ldrb	r0, [r3, #5]
 800e6d8:	0200      	lsls	r0, r0, #8
 800e6da:	4301      	orrs	r1, r0
 800e6dc:	7998      	ldrb	r0, [r3, #6]
 800e6de:	0400      	lsls	r0, r0, #16
 800e6e0:	4301      	orrs	r1, r0
 800e6e2:	79db      	ldrb	r3, [r3, #7]
 800e6e4:	061b      	lsls	r3, r3, #24
 800e6e6:	430b      	orrs	r3, r1
 800e6e8:	1ad3      	subs	r3, r2, r3
    if (next &&
 800e6ea:	2b00      	cmp	r3, #0
 800e6ec:	dd1b      	ble.n	800e726 <tcp_oos_insert_segment+0x162>
      /* We need to trim the incoming segment. */
      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
 800e6ee:	683b      	ldr	r3, [r7, #0]
 800e6f0:	691b      	ldr	r3, [r3, #16]
 800e6f2:	791a      	ldrb	r2, [r3, #4]
 800e6f4:	7959      	ldrb	r1, [r3, #5]
 800e6f6:	0209      	lsls	r1, r1, #8
 800e6f8:	430a      	orrs	r2, r1
 800e6fa:	7999      	ldrb	r1, [r3, #6]
 800e6fc:	0409      	lsls	r1, r1, #16
 800e6fe:	430a      	orrs	r2, r1
 800e700:	79db      	ldrb	r3, [r3, #7]
 800e702:	061b      	lsls	r3, r3, #24
 800e704:	4313      	orrs	r3, r2
 800e706:	b29a      	uxth	r2, r3
 800e708:	4b0d      	ldr	r3, [pc, #52]	; (800e740 <tcp_oos_insert_segment+0x17c>)
 800e70a:	681b      	ldr	r3, [r3, #0]
 800e70c:	b29b      	uxth	r3, r3
 800e70e:	1ad3      	subs	r3, r2, r3
 800e710:	b29a      	uxth	r2, r3
 800e712:	687b      	ldr	r3, [r7, #4]
 800e714:	811a      	strh	r2, [r3, #8]
      pbuf_realloc(cseg->p, cseg->len);
 800e716:	687b      	ldr	r3, [r7, #4]
 800e718:	685a      	ldr	r2, [r3, #4]
 800e71a:	687b      	ldr	r3, [r7, #4]
 800e71c:	891b      	ldrh	r3, [r3, #8]
 800e71e:	0019      	movs	r1, r3
 800e720:	0010      	movs	r0, r2
 800e722:	f7fb fd23 	bl	800a16c <pbuf_realloc>
    }
  }
  cseg->next = next;
 800e726:	687b      	ldr	r3, [r7, #4]
 800e728:	683a      	ldr	r2, [r7, #0]
 800e72a:	601a      	str	r2, [r3, #0]
}
 800e72c:	46c0      	nop			; (mov r8, r8)
 800e72e:	46bd      	mov	sp, r7
 800e730:	b005      	add	sp, #20
 800e732:	bd90      	pop	{r4, r7, pc}
 800e734:	0802120c 	.word	0x0802120c
 800e738:	080214c4 	.word	0x080214c4
 800e73c:	0802124c 	.word	0x0802124c
 800e740:	20000c6c 	.word	0x20000c6c

0800e744 <tcp_free_acked_segments>:

/** Remove segments from a list if the incoming ACK acknowledges them */
static struct tcp_seg *
tcp_free_acked_segments(struct tcp_pcb *pcb, struct tcp_seg *seg_list, const char *dbg_list_name,
                        struct tcp_seg *dbg_other_seg_list)
{
 800e744:	b5b0      	push	{r4, r5, r7, lr}
 800e746:	b086      	sub	sp, #24
 800e748:	af00      	add	r7, sp, #0
 800e74a:	60f8      	str	r0, [r7, #12]
 800e74c:	60b9      	str	r1, [r7, #8]
 800e74e:	607a      	str	r2, [r7, #4]
 800e750:	603b      	str	r3, [r7, #0]
  u16_t clen;

  LWIP_UNUSED_ARG(dbg_list_name);
  LWIP_UNUSED_ARG(dbg_other_seg_list);

  while (seg_list != NULL &&
 800e752:	e043      	b.n	800e7dc <tcp_free_acked_segments+0x98>
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->%s\n",
                                  lwip_ntohl(seg_list->tcphdr->seqno),
                                  lwip_ntohl(seg_list->tcphdr->seqno) + TCP_TCPLEN(seg_list),
                                  dbg_list_name));

    next = seg_list;
 800e754:	68bb      	ldr	r3, [r7, #8]
 800e756:	617b      	str	r3, [r7, #20]
    seg_list = seg_list->next;
 800e758:	68bb      	ldr	r3, [r7, #8]
 800e75a:	681b      	ldr	r3, [r3, #0]
 800e75c:	60bb      	str	r3, [r7, #8]

    clen = pbuf_clen(next->p);
 800e75e:	697b      	ldr	r3, [r7, #20]
 800e760:	685b      	ldr	r3, [r3, #4]
 800e762:	2512      	movs	r5, #18
 800e764:	197c      	adds	r4, r7, r5
 800e766:	0018      	movs	r0, r3
 800e768:	f7fb ff58 	bl	800a61c <pbuf_clen>
 800e76c:	0003      	movs	r3, r0
 800e76e:	8023      	strh	r3, [r4, #0]
    LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"TCPWNDSIZE_F" ... ",
                                 (tcpwnd_size_t)pcb->snd_queuelen));
    LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= clen));
 800e770:	68fb      	ldr	r3, [r7, #12]
 800e772:	226a      	movs	r2, #106	; 0x6a
 800e774:	5a9b      	ldrh	r3, [r3, r2]
 800e776:	197a      	adds	r2, r7, r5
 800e778:	8812      	ldrh	r2, [r2, #0]
 800e77a:	429a      	cmp	r2, r3
 800e77c:	d906      	bls.n	800e78c <tcp_free_acked_segments+0x48>
 800e77e:	4b32      	ldr	r3, [pc, #200]	; (800e848 <tcp_free_acked_segments+0x104>)
 800e780:	228b      	movs	r2, #139	; 0x8b
 800e782:	00d2      	lsls	r2, r2, #3
 800e784:	4931      	ldr	r1, [pc, #196]	; (800e84c <tcp_free_acked_segments+0x108>)
 800e786:	4832      	ldr	r0, [pc, #200]	; (800e850 <tcp_free_acked_segments+0x10c>)
 800e788:	f7f3 fd2c 	bl	80021e4 <app_debug_rtt_raw>

    pcb->snd_queuelen = (u16_t)(pcb->snd_queuelen - clen);
 800e78c:	68fb      	ldr	r3, [r7, #12]
 800e78e:	226a      	movs	r2, #106	; 0x6a
 800e790:	5a9a      	ldrh	r2, [r3, r2]
 800e792:	2312      	movs	r3, #18
 800e794:	18fb      	adds	r3, r7, r3
 800e796:	881b      	ldrh	r3, [r3, #0]
 800e798:	1ad3      	subs	r3, r2, r3
 800e79a:	b299      	uxth	r1, r3
 800e79c:	68fb      	ldr	r3, [r7, #12]
 800e79e:	226a      	movs	r2, #106	; 0x6a
 800e7a0:	5299      	strh	r1, [r3, r2]
    recv_acked = (tcpwnd_size_t)(recv_acked + next->len);
 800e7a2:	697b      	ldr	r3, [r7, #20]
 800e7a4:	891a      	ldrh	r2, [r3, #8]
 800e7a6:	4b2b      	ldr	r3, [pc, #172]	; (800e854 <tcp_free_acked_segments+0x110>)
 800e7a8:	881b      	ldrh	r3, [r3, #0]
 800e7aa:	18d3      	adds	r3, r2, r3
 800e7ac:	b29a      	uxth	r2, r3
 800e7ae:	4b29      	ldr	r3, [pc, #164]	; (800e854 <tcp_free_acked_segments+0x110>)
 800e7b0:	801a      	strh	r2, [r3, #0]
    tcp_seg_free(next);
 800e7b2:	697b      	ldr	r3, [r7, #20]
 800e7b4:	0018      	movs	r0, r3
 800e7b6:	f7fd feed 	bl	800c594 <tcp_seg_free>

    LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"TCPWNDSIZE_F" (after freeing %s)\n",
                                 (tcpwnd_size_t)pcb->snd_queuelen,
                                 dbg_list_name));
    if (pcb->snd_queuelen != 0) {
 800e7ba:	68fb      	ldr	r3, [r7, #12]
 800e7bc:	226a      	movs	r2, #106	; 0x6a
 800e7be:	5a9b      	ldrh	r3, [r3, r2]
 800e7c0:	2b00      	cmp	r3, #0
 800e7c2:	d00b      	beq.n	800e7dc <tcp_free_acked_segments+0x98>
      LWIP_ASSERT("tcp_receive: valid queue length",
 800e7c4:	68bb      	ldr	r3, [r7, #8]
 800e7c6:	2b00      	cmp	r3, #0
 800e7c8:	d108      	bne.n	800e7dc <tcp_free_acked_segments+0x98>
 800e7ca:	683b      	ldr	r3, [r7, #0]
 800e7cc:	2b00      	cmp	r3, #0
 800e7ce:	d105      	bne.n	800e7dc <tcp_free_acked_segments+0x98>
 800e7d0:	4b1d      	ldr	r3, [pc, #116]	; (800e848 <tcp_free_acked_segments+0x104>)
 800e7d2:	4a21      	ldr	r2, [pc, #132]	; (800e858 <tcp_free_acked_segments+0x114>)
 800e7d4:	4921      	ldr	r1, [pc, #132]	; (800e85c <tcp_free_acked_segments+0x118>)
 800e7d6:	481e      	ldr	r0, [pc, #120]	; (800e850 <tcp_free_acked_segments+0x10c>)
 800e7d8:	f7f3 fd04 	bl	80021e4 <app_debug_rtt_raw>
  while (seg_list != NULL &&
 800e7dc:	68bb      	ldr	r3, [r7, #8]
 800e7de:	2b00      	cmp	r3, #0
 800e7e0:	d02c      	beq.n	800e83c <tcp_free_acked_segments+0xf8>
         TCP_SEQ_LEQ(lwip_ntohl(seg_list->tcphdr->seqno) +
 800e7e2:	68bb      	ldr	r3, [r7, #8]
 800e7e4:	691b      	ldr	r3, [r3, #16]
 800e7e6:	791a      	ldrb	r2, [r3, #4]
 800e7e8:	7959      	ldrb	r1, [r3, #5]
 800e7ea:	0209      	lsls	r1, r1, #8
 800e7ec:	430a      	orrs	r2, r1
 800e7ee:	7999      	ldrb	r1, [r3, #6]
 800e7f0:	0409      	lsls	r1, r1, #16
 800e7f2:	430a      	orrs	r2, r1
 800e7f4:	79db      	ldrb	r3, [r3, #7]
 800e7f6:	061b      	lsls	r3, r3, #24
 800e7f8:	4313      	orrs	r3, r2
 800e7fa:	0018      	movs	r0, r3
 800e7fc:	f7f8 fe16 	bl	800742c <lwip_htonl>
 800e800:	0004      	movs	r4, r0
 800e802:	68bb      	ldr	r3, [r7, #8]
 800e804:	891b      	ldrh	r3, [r3, #8]
 800e806:	001d      	movs	r5, r3
 800e808:	68bb      	ldr	r3, [r7, #8]
 800e80a:	691b      	ldr	r3, [r3, #16]
 800e80c:	7b1a      	ldrb	r2, [r3, #12]
 800e80e:	7b5b      	ldrb	r3, [r3, #13]
 800e810:	021b      	lsls	r3, r3, #8
 800e812:	4313      	orrs	r3, r2
 800e814:	b29b      	uxth	r3, r3
 800e816:	0018      	movs	r0, r3
 800e818:	f7f8 fdf2 	bl	8007400 <lwip_htons>
 800e81c:	0003      	movs	r3, r0
 800e81e:	b2db      	uxtb	r3, r3
 800e820:	001a      	movs	r2, r3
 800e822:	2303      	movs	r3, #3
 800e824:	4013      	ands	r3, r2
 800e826:	d001      	beq.n	800e82c <tcp_free_acked_segments+0xe8>
 800e828:	2301      	movs	r3, #1
 800e82a:	e000      	b.n	800e82e <tcp_free_acked_segments+0xea>
 800e82c:	2300      	movs	r3, #0
 800e82e:	195b      	adds	r3, r3, r5
 800e830:	18e2      	adds	r2, r4, r3
 800e832:	4b0b      	ldr	r3, [pc, #44]	; (800e860 <tcp_free_acked_segments+0x11c>)
 800e834:	681b      	ldr	r3, [r3, #0]
 800e836:	1ad3      	subs	r3, r2, r3
  while (seg_list != NULL &&
 800e838:	2b00      	cmp	r3, #0
 800e83a:	dd8b      	ble.n	800e754 <tcp_free_acked_segments+0x10>
                  seg_list != NULL || dbg_other_seg_list != NULL);
    }
  }
  return seg_list;
 800e83c:	68bb      	ldr	r3, [r7, #8]
}
 800e83e:	0018      	movs	r0, r3
 800e840:	46bd      	mov	sp, r7
 800e842:	b006      	add	sp, #24
 800e844:	bdb0      	pop	{r4, r5, r7, pc}
 800e846:	46c0      	nop			; (mov r8, r8)
 800e848:	0802120c 	.word	0x0802120c
 800e84c:	080214ec 	.word	0x080214ec
 800e850:	0802124c 	.word	0x0802124c
 800e854:	20000c74 	.word	0x20000c74
 800e858:	00000462 	.word	0x00000462
 800e85c:	08021514 	.word	0x08021514
 800e860:	20000c70 	.word	0x20000c70

0800e864 <tcp_receive>:
 *
 * Called from tcp_process().
 */
static void
tcp_receive(struct tcp_pcb *pcb)
{
 800e864:	b5b0      	push	{r4, r5, r7, lr}
 800e866:	b094      	sub	sp, #80	; 0x50
 800e868:	af00      	add	r7, sp, #0
 800e86a:	6078      	str	r0, [r7, #4]
  s16_t m;
  u32_t right_wnd_edge;
  int found_dupack = 0;
 800e86c:	2300      	movs	r3, #0
 800e86e:	64bb      	str	r3, [r7, #72]	; 0x48

  LWIP_ASSERT("tcp_receive: invalid pcb", pcb != NULL);
 800e870:	687b      	ldr	r3, [r7, #4]
 800e872:	2b00      	cmp	r3, #0
 800e874:	d105      	bne.n	800e882 <tcp_receive+0x1e>
 800e876:	4bba      	ldr	r3, [pc, #744]	; (800eb60 <tcp_receive+0x2fc>)
 800e878:	4aba      	ldr	r2, [pc, #744]	; (800eb64 <tcp_receive+0x300>)
 800e87a:	49bb      	ldr	r1, [pc, #748]	; (800eb68 <tcp_receive+0x304>)
 800e87c:	48bb      	ldr	r0, [pc, #748]	; (800eb6c <tcp_receive+0x308>)
 800e87e:	f7f3 fcb1 	bl	80021e4 <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 800e882:	687b      	ldr	r3, [r7, #4]
 800e884:	7e1b      	ldrb	r3, [r3, #24]
 800e886:	2b03      	cmp	r3, #3
 800e888:	d805      	bhi.n	800e896 <tcp_receive+0x32>
 800e88a:	4bb5      	ldr	r3, [pc, #724]	; (800eb60 <tcp_receive+0x2fc>)
 800e88c:	4ab8      	ldr	r2, [pc, #736]	; (800eb70 <tcp_receive+0x30c>)
 800e88e:	49b9      	ldr	r1, [pc, #740]	; (800eb74 <tcp_receive+0x310>)
 800e890:	48b6      	ldr	r0, [pc, #728]	; (800eb6c <tcp_receive+0x308>)
 800e892:	f7f3 fca7 	bl	80021e4 <app_debug_rtt_raw>

  if (flags & TCP_ACK) {
 800e896:	4bb8      	ldr	r3, [pc, #736]	; (800eb78 <tcp_receive+0x314>)
 800e898:	781b      	ldrb	r3, [r3, #0]
 800e89a:	001a      	movs	r2, r3
 800e89c:	2310      	movs	r3, #16
 800e89e:	4013      	ands	r3, r2
 800e8a0:	d100      	bne.n	800e8a4 <tcp_receive+0x40>
 800e8a2:	e294      	b.n	800edce <tcp_receive+0x56a>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 800e8a4:	687b      	ldr	r3, [r7, #4]
 800e8a6:	2264      	movs	r2, #100	; 0x64
 800e8a8:	5a9b      	ldrh	r3, [r3, r2]
 800e8aa:	001a      	movs	r2, r3
 800e8ac:	687b      	ldr	r3, [r7, #4]
 800e8ae:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800e8b0:	18d3      	adds	r3, r2, r3
 800e8b2:	633b      	str	r3, [r7, #48]	; 0x30

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 800e8b4:	687b      	ldr	r3, [r7, #4]
 800e8b6:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800e8b8:	4bb0      	ldr	r3, [pc, #704]	; (800eb7c <tcp_receive+0x318>)
 800e8ba:	681b      	ldr	r3, [r3, #0]
 800e8bc:	1ad3      	subs	r3, r2, r3
 800e8be:	d41d      	bmi.n	800e8fc <tcp_receive+0x98>
        (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 800e8c0:	687b      	ldr	r3, [r7, #4]
 800e8c2:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800e8c4:	4bad      	ldr	r3, [pc, #692]	; (800eb7c <tcp_receive+0x318>)
 800e8c6:	681b      	ldr	r3, [r3, #0]
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 800e8c8:	429a      	cmp	r2, r3
 800e8ca:	d105      	bne.n	800e8d8 <tcp_receive+0x74>
        (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 800e8cc:	687b      	ldr	r3, [r7, #4]
 800e8ce:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 800e8d0:	4bab      	ldr	r3, [pc, #684]	; (800eb80 <tcp_receive+0x31c>)
 800e8d2:	681b      	ldr	r3, [r3, #0]
 800e8d4:	1ad3      	subs	r3, r2, r3
 800e8d6:	d411      	bmi.n	800e8fc <tcp_receive+0x98>
        (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
 800e8d8:	687b      	ldr	r3, [r7, #4]
 800e8da:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 800e8dc:	4ba8      	ldr	r3, [pc, #672]	; (800eb80 <tcp_receive+0x31c>)
 800e8de:	681b      	ldr	r3, [r3, #0]
        (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 800e8e0:	429a      	cmp	r2, r3
 800e8e2:	d12b      	bne.n	800e93c <tcp_receive+0xd8>
        (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
 800e8e4:	4ba7      	ldr	r3, [pc, #668]	; (800eb84 <tcp_receive+0x320>)
 800e8e6:	681b      	ldr	r3, [r3, #0]
 800e8e8:	7b9a      	ldrb	r2, [r3, #14]
 800e8ea:	7bdb      	ldrb	r3, [r3, #15]
 800e8ec:	021b      	lsls	r3, r3, #8
 800e8ee:	4313      	orrs	r3, r2
 800e8f0:	b29a      	uxth	r2, r3
 800e8f2:	687b      	ldr	r3, [r7, #4]
 800e8f4:	2164      	movs	r1, #100	; 0x64
 800e8f6:	5a5b      	ldrh	r3, [r3, r1]
 800e8f8:	429a      	cmp	r2, r3
 800e8fa:	d91f      	bls.n	800e93c <tcp_receive+0xd8>
      pcb->snd_wnd = SND_WND_SCALE(pcb, tcphdr->wnd);
 800e8fc:	4ba1      	ldr	r3, [pc, #644]	; (800eb84 <tcp_receive+0x320>)
 800e8fe:	681b      	ldr	r3, [r3, #0]
 800e900:	7b9a      	ldrb	r2, [r3, #14]
 800e902:	7bdb      	ldrb	r3, [r3, #15]
 800e904:	021b      	lsls	r3, r3, #8
 800e906:	4313      	orrs	r3, r2
 800e908:	b299      	uxth	r1, r3
 800e90a:	687b      	ldr	r3, [r7, #4]
 800e90c:	2264      	movs	r2, #100	; 0x64
 800e90e:	5299      	strh	r1, [r3, r2]
      /* keep track of the biggest window announced by the remote host to calculate
         the maximum segment size */
      if (pcb->snd_wnd_max < pcb->snd_wnd) {
 800e910:	687b      	ldr	r3, [r7, #4]
 800e912:	2266      	movs	r2, #102	; 0x66
 800e914:	5a9a      	ldrh	r2, [r3, r2]
 800e916:	687b      	ldr	r3, [r7, #4]
 800e918:	2164      	movs	r1, #100	; 0x64
 800e91a:	5a5b      	ldrh	r3, [r3, r1]
 800e91c:	429a      	cmp	r2, r3
 800e91e:	d205      	bcs.n	800e92c <tcp_receive+0xc8>
        pcb->snd_wnd_max = pcb->snd_wnd;
 800e920:	687b      	ldr	r3, [r7, #4]
 800e922:	2264      	movs	r2, #100	; 0x64
 800e924:	5a99      	ldrh	r1, [r3, r2]
 800e926:	687b      	ldr	r3, [r7, #4]
 800e928:	2266      	movs	r2, #102	; 0x66
 800e92a:	5299      	strh	r1, [r3, r2]
      }
      pcb->snd_wl1 = seqno;
 800e92c:	4b93      	ldr	r3, [pc, #588]	; (800eb7c <tcp_receive+0x318>)
 800e92e:	681a      	ldr	r2, [r3, #0]
 800e930:	687b      	ldr	r3, [r7, #4]
 800e932:	659a      	str	r2, [r3, #88]	; 0x58
      pcb->snd_wl2 = ackno;
 800e934:	4b92      	ldr	r3, [pc, #584]	; (800eb80 <tcp_receive+0x31c>)
 800e936:	681a      	ldr	r2, [r3, #0]
 800e938:	687b      	ldr	r3, [r7, #4]
 800e93a:	65da      	str	r2, [r3, #92]	; 0x5c
     * If it only passes 1, should reset dupack counter
     *
     */

    /* Clause 1 */
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
 800e93c:	4b90      	ldr	r3, [pc, #576]	; (800eb80 <tcp_receive+0x31c>)
 800e93e:	681a      	ldr	r2, [r3, #0]
 800e940:	687b      	ldr	r3, [r7, #4]
 800e942:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800e944:	1ad3      	subs	r3, r2, r3
 800e946:	2b00      	cmp	r3, #0
 800e948:	dc59      	bgt.n	800e9fe <tcp_receive+0x19a>
      /* Clause 2 */
      if (tcplen == 0) {
 800e94a:	4b8f      	ldr	r3, [pc, #572]	; (800eb88 <tcp_receive+0x324>)
 800e94c:	881b      	ldrh	r3, [r3, #0]
 800e94e:	2b00      	cmp	r3, #0
 800e950:	d14c      	bne.n	800e9ec <tcp_receive+0x188>
        /* Clause 3 */
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge) {
 800e952:	687b      	ldr	r3, [r7, #4]
 800e954:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800e956:	687a      	ldr	r2, [r7, #4]
 800e958:	2164      	movs	r1, #100	; 0x64
 800e95a:	5a52      	ldrh	r2, [r2, r1]
 800e95c:	189b      	adds	r3, r3, r2
 800e95e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800e960:	429a      	cmp	r2, r3
 800e962:	d143      	bne.n	800e9ec <tcp_receive+0x188>
          /* Clause 4 */
          if (pcb->rtime >= 0) {
 800e964:	687b      	ldr	r3, [r7, #4]
 800e966:	2234      	movs	r2, #52	; 0x34
 800e968:	5e9b      	ldrsh	r3, [r3, r2]
 800e96a:	2b00      	cmp	r3, #0
 800e96c:	db3e      	blt.n	800e9ec <tcp_receive+0x188>
            /* Clause 5 */
            if (pcb->lastack == ackno) {
 800e96e:	687b      	ldr	r3, [r7, #4]
 800e970:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800e972:	4b83      	ldr	r3, [pc, #524]	; (800eb80 <tcp_receive+0x31c>)
 800e974:	681b      	ldr	r3, [r3, #0]
 800e976:	429a      	cmp	r2, r3
 800e978:	d138      	bne.n	800e9ec <tcp_receive+0x188>
              found_dupack = 1;
 800e97a:	2301      	movs	r3, #1
 800e97c:	64bb      	str	r3, [r7, #72]	; 0x48
              if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
 800e97e:	687b      	ldr	r3, [r7, #4]
 800e980:	2247      	movs	r2, #71	; 0x47
 800e982:	5c9b      	ldrb	r3, [r3, r2]
 800e984:	2bff      	cmp	r3, #255	; 0xff
 800e986:	d007      	beq.n	800e998 <tcp_receive+0x134>
                ++pcb->dupacks;
 800e988:	687b      	ldr	r3, [r7, #4]
 800e98a:	2247      	movs	r2, #71	; 0x47
 800e98c:	5c9b      	ldrb	r3, [r3, r2]
 800e98e:	3301      	adds	r3, #1
 800e990:	b2d9      	uxtb	r1, r3
 800e992:	687b      	ldr	r3, [r7, #4]
 800e994:	2247      	movs	r2, #71	; 0x47
 800e996:	5499      	strb	r1, [r3, r2]
              }
              if (pcb->dupacks > 3) {
 800e998:	687b      	ldr	r3, [r7, #4]
 800e99a:	2247      	movs	r2, #71	; 0x47
 800e99c:	5c9b      	ldrb	r3, [r3, r2]
 800e99e:	2b03      	cmp	r3, #3
 800e9a0:	d91b      	bls.n	800e9da <tcp_receive+0x176>
                /* Inflate the congestion window */
                TCP_WND_INC(pcb->cwnd, pcb->mss);
 800e9a2:	687b      	ldr	r3, [r7, #4]
 800e9a4:	224c      	movs	r2, #76	; 0x4c
 800e9a6:	5a9a      	ldrh	r2, [r3, r2]
 800e9a8:	687b      	ldr	r3, [r7, #4]
 800e9aa:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800e9ac:	18d3      	adds	r3, r2, r3
 800e9ae:	b29a      	uxth	r2, r3
 800e9b0:	687b      	ldr	r3, [r7, #4]
 800e9b2:	214c      	movs	r1, #76	; 0x4c
 800e9b4:	5a5b      	ldrh	r3, [r3, r1]
 800e9b6:	429a      	cmp	r2, r3
 800e9b8:	d30a      	bcc.n	800e9d0 <tcp_receive+0x16c>
 800e9ba:	687b      	ldr	r3, [r7, #4]
 800e9bc:	224c      	movs	r2, #76	; 0x4c
 800e9be:	5a9a      	ldrh	r2, [r3, r2]
 800e9c0:	687b      	ldr	r3, [r7, #4]
 800e9c2:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800e9c4:	18d3      	adds	r3, r2, r3
 800e9c6:	b299      	uxth	r1, r3
 800e9c8:	687b      	ldr	r3, [r7, #4]
 800e9ca:	224c      	movs	r2, #76	; 0x4c
 800e9cc:	5299      	strh	r1, [r3, r2]
 800e9ce:	e004      	b.n	800e9da <tcp_receive+0x176>
 800e9d0:	687b      	ldr	r3, [r7, #4]
 800e9d2:	224c      	movs	r2, #76	; 0x4c
 800e9d4:	2101      	movs	r1, #1
 800e9d6:	4249      	negs	r1, r1
 800e9d8:	5299      	strh	r1, [r3, r2]
              }
              if (pcb->dupacks >= 3) {
 800e9da:	687b      	ldr	r3, [r7, #4]
 800e9dc:	2247      	movs	r2, #71	; 0x47
 800e9de:	5c9b      	ldrb	r3, [r3, r2]
 800e9e0:	2b02      	cmp	r3, #2
 800e9e2:	d903      	bls.n	800e9ec <tcp_receive+0x188>
                /* Do fast retransmit (checked via TF_INFR, not via dupacks count) */
                tcp_rexmit_fast(pcb);
 800e9e4:	687b      	ldr	r3, [r7, #4]
 800e9e6:	0018      	movs	r0, r3
 800e9e8:	f003 fa7e 	bl	8011ee8 <tcp_rexmit_fast>
          }
        }
      }
      /* If Clause (1) or more is true, but not a duplicate ack, reset
       * count of consecutive duplicate acks */
      if (!found_dupack) {
 800e9ec:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800e9ee:	2b00      	cmp	r3, #0
 800e9f0:	d000      	beq.n	800e9f4 <tcp_receive+0x190>
 800e9f2:	e188      	b.n	800ed06 <tcp_receive+0x4a2>
        pcb->dupacks = 0;
 800e9f4:	687b      	ldr	r3, [r7, #4]
 800e9f6:	2247      	movs	r2, #71	; 0x47
 800e9f8:	2100      	movs	r1, #0
 800e9fa:	5499      	strb	r1, [r3, r2]
 800e9fc:	e183      	b.n	800ed06 <tcp_receive+0x4a2>
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 800e9fe:	4b60      	ldr	r3, [pc, #384]	; (800eb80 <tcp_receive+0x31c>)
 800ea00:	681a      	ldr	r2, [r3, #0]
 800ea02:	687b      	ldr	r3, [r7, #4]
 800ea04:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800ea06:	1ad3      	subs	r3, r2, r3
 800ea08:	3b01      	subs	r3, #1
 800ea0a:	2b00      	cmp	r3, #0
 800ea0c:	da00      	bge.n	800ea10 <tcp_receive+0x1ac>
 800ea0e:	e174      	b.n	800ecfa <tcp_receive+0x496>
 800ea10:	4b5b      	ldr	r3, [pc, #364]	; (800eb80 <tcp_receive+0x31c>)
 800ea12:	681a      	ldr	r2, [r3, #0]
 800ea14:	687b      	ldr	r3, [r7, #4]
 800ea16:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800ea18:	1ad3      	subs	r3, r2, r3
 800ea1a:	2b00      	cmp	r3, #0
 800ea1c:	dd00      	ble.n	800ea20 <tcp_receive+0x1bc>
 800ea1e:	e16c      	b.n	800ecfa <tcp_receive+0x496>
      tcpwnd_size_t acked;

      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
 800ea20:	687b      	ldr	r3, [r7, #4]
 800ea22:	8bdb      	ldrh	r3, [r3, #30]
 800ea24:	001a      	movs	r2, r3
 800ea26:	2304      	movs	r3, #4
 800ea28:	4013      	ands	r3, r2
 800ea2a:	d010      	beq.n	800ea4e <tcp_receive+0x1ea>
        tcp_clear_flags(pcb, TF_INFR);
 800ea2c:	687b      	ldr	r3, [r7, #4]
 800ea2e:	8bdb      	ldrh	r3, [r3, #30]
 800ea30:	2204      	movs	r2, #4
 800ea32:	4393      	bics	r3, r2
 800ea34:	b29a      	uxth	r2, r3
 800ea36:	687b      	ldr	r3, [r7, #4]
 800ea38:	83da      	strh	r2, [r3, #30]
        pcb->cwnd = pcb->ssthresh;
 800ea3a:	687b      	ldr	r3, [r7, #4]
 800ea3c:	224e      	movs	r2, #78	; 0x4e
 800ea3e:	5a99      	ldrh	r1, [r3, r2]
 800ea40:	687b      	ldr	r3, [r7, #4]
 800ea42:	224c      	movs	r2, #76	; 0x4c
 800ea44:	5299      	strh	r1, [r3, r2]
        pcb->bytes_acked = 0;
 800ea46:	687b      	ldr	r3, [r7, #4]
 800ea48:	226e      	movs	r2, #110	; 0x6e
 800ea4a:	2100      	movs	r1, #0
 800ea4c:	5299      	strh	r1, [r3, r2]
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
 800ea4e:	687b      	ldr	r3, [r7, #4]
 800ea50:	2246      	movs	r2, #70	; 0x46
 800ea52:	2100      	movs	r1, #0
 800ea54:	5499      	strb	r1, [r3, r2]

      /* Reset the retransmission time-out. */
      pcb->rto = (s16_t)((pcb->sa >> 3) + pcb->sv);
 800ea56:	687b      	ldr	r3, [r7, #4]
 800ea58:	2240      	movs	r2, #64	; 0x40
 800ea5a:	5e9b      	ldrsh	r3, [r3, r2]
 800ea5c:	10db      	asrs	r3, r3, #3
 800ea5e:	b21b      	sxth	r3, r3
 800ea60:	b29a      	uxth	r2, r3
 800ea62:	687b      	ldr	r3, [r7, #4]
 800ea64:	2142      	movs	r1, #66	; 0x42
 800ea66:	5e5b      	ldrsh	r3, [r3, r1]
 800ea68:	b29b      	uxth	r3, r3
 800ea6a:	18d3      	adds	r3, r2, r3
 800ea6c:	b29b      	uxth	r3, r3
 800ea6e:	b219      	sxth	r1, r3
 800ea70:	687b      	ldr	r3, [r7, #4]
 800ea72:	2244      	movs	r2, #68	; 0x44
 800ea74:	5299      	strh	r1, [r3, r2]

      /* Record how much data this ACK acks */
      acked = (tcpwnd_size_t)(ackno - pcb->lastack);
 800ea76:	4b42      	ldr	r3, [pc, #264]	; (800eb80 <tcp_receive+0x31c>)
 800ea78:	681b      	ldr	r3, [r3, #0]
 800ea7a:	b299      	uxth	r1, r3
 800ea7c:	687b      	ldr	r3, [r7, #4]
 800ea7e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800ea80:	b29a      	uxth	r2, r3
 800ea82:	232e      	movs	r3, #46	; 0x2e
 800ea84:	18fb      	adds	r3, r7, r3
 800ea86:	1a8a      	subs	r2, r1, r2
 800ea88:	801a      	strh	r2, [r3, #0]

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
 800ea8a:	687b      	ldr	r3, [r7, #4]
 800ea8c:	2247      	movs	r2, #71	; 0x47
 800ea8e:	2100      	movs	r1, #0
 800ea90:	5499      	strb	r1, [r3, r2]
      pcb->lastack = ackno;
 800ea92:	4b3b      	ldr	r3, [pc, #236]	; (800eb80 <tcp_receive+0x31c>)
 800ea94:	681a      	ldr	r2, [r3, #0]
 800ea96:	687b      	ldr	r3, [r7, #4]
 800ea98:	649a      	str	r2, [r3, #72]	; 0x48

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
 800ea9a:	687b      	ldr	r3, [r7, #4]
 800ea9c:	7e1b      	ldrb	r3, [r3, #24]
 800ea9e:	2b03      	cmp	r3, #3
 800eaa0:	d800      	bhi.n	800eaa4 <tcp_receive+0x240>
 800eaa2:	e0a7      	b.n	800ebf4 <tcp_receive+0x390>
        if (pcb->cwnd < pcb->ssthresh) {
 800eaa4:	687b      	ldr	r3, [r7, #4]
 800eaa6:	224c      	movs	r2, #76	; 0x4c
 800eaa8:	5a9a      	ldrh	r2, [r3, r2]
 800eaaa:	687b      	ldr	r3, [r7, #4]
 800eaac:	214e      	movs	r1, #78	; 0x4e
 800eaae:	5a5b      	ldrh	r3, [r3, r1]
 800eab0:	429a      	cmp	r2, r3
 800eab2:	d23d      	bcs.n	800eb30 <tcp_receive+0x2cc>
          tcpwnd_size_t increase;
          /* limit to 1 SMSS segment during period following RTO */
          u8_t num_seg = (pcb->flags & TF_RTO) ? 1 : 2;
 800eab4:	687b      	ldr	r3, [r7, #4]
 800eab6:	8bdb      	ldrh	r3, [r3, #30]
 800eab8:	001a      	movs	r2, r3
 800eaba:	2380      	movs	r3, #128	; 0x80
 800eabc:	011b      	lsls	r3, r3, #4
 800eabe:	4013      	ands	r3, r2
 800eac0:	d001      	beq.n	800eac6 <tcp_receive+0x262>
 800eac2:	2201      	movs	r2, #1
 800eac4:	e000      	b.n	800eac8 <tcp_receive+0x264>
 800eac6:	2202      	movs	r2, #2
 800eac8:	212d      	movs	r1, #45	; 0x2d
 800eaca:	187b      	adds	r3, r7, r1
 800eacc:	701a      	strb	r2, [r3, #0]
          /* RFC 3465, section 2.2 Slow Start */
          increase = LWIP_MIN(acked, (tcpwnd_size_t)(num_seg * pcb->mss));
 800eace:	187b      	adds	r3, r7, r1
 800ead0:	781b      	ldrb	r3, [r3, #0]
 800ead2:	b29b      	uxth	r3, r3
 800ead4:	687a      	ldr	r2, [r7, #4]
 800ead6:	8ed2      	ldrh	r2, [r2, #54]	; 0x36
 800ead8:	4353      	muls	r3, r2
 800eada:	b299      	uxth	r1, r3
 800eadc:	232a      	movs	r3, #42	; 0x2a
 800eade:	18fa      	adds	r2, r7, r3
 800eae0:	232e      	movs	r3, #46	; 0x2e
 800eae2:	18fb      	adds	r3, r7, r3
 800eae4:	1c0c      	adds	r4, r1, #0
 800eae6:	881b      	ldrh	r3, [r3, #0]
 800eae8:	b298      	uxth	r0, r3
 800eaea:	b2a1      	uxth	r1, r4
 800eaec:	4288      	cmp	r0, r1
 800eaee:	d900      	bls.n	800eaf2 <tcp_receive+0x28e>
 800eaf0:	1c23      	adds	r3, r4, #0
 800eaf2:	8013      	strh	r3, [r2, #0]
          TCP_WND_INC(pcb->cwnd, increase);
 800eaf4:	687b      	ldr	r3, [r7, #4]
 800eaf6:	224c      	movs	r2, #76	; 0x4c
 800eaf8:	5a9a      	ldrh	r2, [r3, r2]
 800eafa:	202a      	movs	r0, #42	; 0x2a
 800eafc:	183b      	adds	r3, r7, r0
 800eafe:	881b      	ldrh	r3, [r3, #0]
 800eb00:	18d3      	adds	r3, r2, r3
 800eb02:	b29a      	uxth	r2, r3
 800eb04:	687b      	ldr	r3, [r7, #4]
 800eb06:	214c      	movs	r1, #76	; 0x4c
 800eb08:	5a5b      	ldrh	r3, [r3, r1]
 800eb0a:	429a      	cmp	r2, r3
 800eb0c:	d30a      	bcc.n	800eb24 <tcp_receive+0x2c0>
 800eb0e:	687b      	ldr	r3, [r7, #4]
 800eb10:	224c      	movs	r2, #76	; 0x4c
 800eb12:	5a9a      	ldrh	r2, [r3, r2]
 800eb14:	183b      	adds	r3, r7, r0
 800eb16:	881b      	ldrh	r3, [r3, #0]
 800eb18:	18d3      	adds	r3, r2, r3
 800eb1a:	b299      	uxth	r1, r3
 800eb1c:	687b      	ldr	r3, [r7, #4]
 800eb1e:	224c      	movs	r2, #76	; 0x4c
 800eb20:	5299      	strh	r1, [r3, r2]
 800eb22:	e067      	b.n	800ebf4 <tcp_receive+0x390>
 800eb24:	687b      	ldr	r3, [r7, #4]
 800eb26:	224c      	movs	r2, #76	; 0x4c
 800eb28:	2101      	movs	r1, #1
 800eb2a:	4249      	negs	r1, r1
 800eb2c:	5299      	strh	r1, [r3, r2]
 800eb2e:	e061      	b.n	800ebf4 <tcp_receive+0x390>
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"TCPWNDSIZE_F"\n", pcb->cwnd));
        } else {
          /* RFC 3465, section 2.1 Congestion Avoidance */
          TCP_WND_INC(pcb->bytes_acked, acked);
 800eb30:	687b      	ldr	r3, [r7, #4]
 800eb32:	226e      	movs	r2, #110	; 0x6e
 800eb34:	5a9a      	ldrh	r2, [r3, r2]
 800eb36:	202e      	movs	r0, #46	; 0x2e
 800eb38:	183b      	adds	r3, r7, r0
 800eb3a:	881b      	ldrh	r3, [r3, #0]
 800eb3c:	18d3      	adds	r3, r2, r3
 800eb3e:	b29a      	uxth	r2, r3
 800eb40:	687b      	ldr	r3, [r7, #4]
 800eb42:	216e      	movs	r1, #110	; 0x6e
 800eb44:	5a5b      	ldrh	r3, [r3, r1]
 800eb46:	429a      	cmp	r2, r3
 800eb48:	d320      	bcc.n	800eb8c <tcp_receive+0x328>
 800eb4a:	687b      	ldr	r3, [r7, #4]
 800eb4c:	226e      	movs	r2, #110	; 0x6e
 800eb4e:	5a9a      	ldrh	r2, [r3, r2]
 800eb50:	183b      	adds	r3, r7, r0
 800eb52:	881b      	ldrh	r3, [r3, #0]
 800eb54:	18d3      	adds	r3, r2, r3
 800eb56:	b299      	uxth	r1, r3
 800eb58:	687b      	ldr	r3, [r7, #4]
 800eb5a:	226e      	movs	r2, #110	; 0x6e
 800eb5c:	5299      	strh	r1, [r3, r2]
 800eb5e:	e01a      	b.n	800eb96 <tcp_receive+0x332>
 800eb60:	0802120c 	.word	0x0802120c
 800eb64:	0000047c 	.word	0x0000047c
 800eb68:	08021534 	.word	0x08021534
 800eb6c:	0802124c 	.word	0x0802124c
 800eb70:	0000047d 	.word	0x0000047d
 800eb74:	08021550 	.word	0x08021550
 800eb78:	20000c78 	.word	0x20000c78
 800eb7c:	20000c6c 	.word	0x20000c6c
 800eb80:	20000c70 	.word	0x20000c70
 800eb84:	20000c5c 	.word	0x20000c5c
 800eb88:	20000c76 	.word	0x20000c76
 800eb8c:	687b      	ldr	r3, [r7, #4]
 800eb8e:	226e      	movs	r2, #110	; 0x6e
 800eb90:	2101      	movs	r1, #1
 800eb92:	4249      	negs	r1, r1
 800eb94:	5299      	strh	r1, [r3, r2]
          if (pcb->bytes_acked >= pcb->cwnd) {
 800eb96:	687b      	ldr	r3, [r7, #4]
 800eb98:	226e      	movs	r2, #110	; 0x6e
 800eb9a:	5a9a      	ldrh	r2, [r3, r2]
 800eb9c:	687b      	ldr	r3, [r7, #4]
 800eb9e:	214c      	movs	r1, #76	; 0x4c
 800eba0:	5a5b      	ldrh	r3, [r3, r1]
 800eba2:	429a      	cmp	r2, r3
 800eba4:	d326      	bcc.n	800ebf4 <tcp_receive+0x390>
            pcb->bytes_acked = (tcpwnd_size_t)(pcb->bytes_acked - pcb->cwnd);
 800eba6:	687b      	ldr	r3, [r7, #4]
 800eba8:	226e      	movs	r2, #110	; 0x6e
 800ebaa:	5a9a      	ldrh	r2, [r3, r2]
 800ebac:	687b      	ldr	r3, [r7, #4]
 800ebae:	214c      	movs	r1, #76	; 0x4c
 800ebb0:	5a5b      	ldrh	r3, [r3, r1]
 800ebb2:	1ad3      	subs	r3, r2, r3
 800ebb4:	b299      	uxth	r1, r3
 800ebb6:	687b      	ldr	r3, [r7, #4]
 800ebb8:	226e      	movs	r2, #110	; 0x6e
 800ebba:	5299      	strh	r1, [r3, r2]
            TCP_WND_INC(pcb->cwnd, pcb->mss);
 800ebbc:	687b      	ldr	r3, [r7, #4]
 800ebbe:	224c      	movs	r2, #76	; 0x4c
 800ebc0:	5a9a      	ldrh	r2, [r3, r2]
 800ebc2:	687b      	ldr	r3, [r7, #4]
 800ebc4:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800ebc6:	18d3      	adds	r3, r2, r3
 800ebc8:	b29a      	uxth	r2, r3
 800ebca:	687b      	ldr	r3, [r7, #4]
 800ebcc:	214c      	movs	r1, #76	; 0x4c
 800ebce:	5a5b      	ldrh	r3, [r3, r1]
 800ebd0:	429a      	cmp	r2, r3
 800ebd2:	d30a      	bcc.n	800ebea <tcp_receive+0x386>
 800ebd4:	687b      	ldr	r3, [r7, #4]
 800ebd6:	224c      	movs	r2, #76	; 0x4c
 800ebd8:	5a9a      	ldrh	r2, [r3, r2]
 800ebda:	687b      	ldr	r3, [r7, #4]
 800ebdc:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800ebde:	18d3      	adds	r3, r2, r3
 800ebe0:	b299      	uxth	r1, r3
 800ebe2:	687b      	ldr	r3, [r7, #4]
 800ebe4:	224c      	movs	r2, #76	; 0x4c
 800ebe6:	5299      	strh	r1, [r3, r2]
 800ebe8:	e004      	b.n	800ebf4 <tcp_receive+0x390>
 800ebea:	687b      	ldr	r3, [r7, #4]
 800ebec:	224c      	movs	r2, #76	; 0x4c
 800ebee:	2101      	movs	r1, #1
 800ebf0:	4249      	negs	r1, r1
 800ebf2:	5299      	strh	r1, [r3, r2]
                                    pcb->unacked != NULL ?
                                    lwip_ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked) : 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowledges them. */
      pcb->unacked = tcp_free_acked_segments(pcb, pcb->unacked, "unacked", pcb->unsent);
 800ebf4:	687b      	ldr	r3, [r7, #4]
 800ebf6:	6f59      	ldr	r1, [r3, #116]	; 0x74
 800ebf8:	687b      	ldr	r3, [r7, #4]
 800ebfa:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800ebfc:	4acf      	ldr	r2, [pc, #828]	; (800ef3c <tcp_receive+0x6d8>)
 800ebfe:	6878      	ldr	r0, [r7, #4]
 800ec00:	f7ff fda0 	bl	800e744 <tcp_free_acked_segments>
 800ec04:	0002      	movs	r2, r0
 800ec06:	687b      	ldr	r3, [r7, #4]
 800ec08:	675a      	str	r2, [r3, #116]	; 0x74
         on the list are acknowledged by the ACK. This may seem
         strange since an "unsent" segment shouldn't be acked. The
         rationale is that lwIP puts all outstanding segments on the
         ->unsent list after a retransmission, so these segments may
         in fact have been sent once. */
      pcb->unsent = tcp_free_acked_segments(pcb, pcb->unsent, "unsent", pcb->unacked);
 800ec0a:	687b      	ldr	r3, [r7, #4]
 800ec0c:	6f19      	ldr	r1, [r3, #112]	; 0x70
 800ec0e:	687b      	ldr	r3, [r7, #4]
 800ec10:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800ec12:	4acb      	ldr	r2, [pc, #812]	; (800ef40 <tcp_receive+0x6dc>)
 800ec14:	6878      	ldr	r0, [r7, #4]
 800ec16:	f7ff fd95 	bl	800e744 <tcp_free_acked_segments>
 800ec1a:	0002      	movs	r2, r0
 800ec1c:	687b      	ldr	r3, [r7, #4]
 800ec1e:	671a      	str	r2, [r3, #112]	; 0x70

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if (pcb->unacked == NULL) {
 800ec20:	687b      	ldr	r3, [r7, #4]
 800ec22:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800ec24:	2b00      	cmp	r3, #0
 800ec26:	d104      	bne.n	800ec32 <tcp_receive+0x3ce>
        pcb->rtime = -1;
 800ec28:	687b      	ldr	r3, [r7, #4]
 800ec2a:	2201      	movs	r2, #1
 800ec2c:	4252      	negs	r2, r2
 800ec2e:	869a      	strh	r2, [r3, #52]	; 0x34
 800ec30:	e002      	b.n	800ec38 <tcp_receive+0x3d4>
      } else {
        pcb->rtime = 0;
 800ec32:	687b      	ldr	r3, [r7, #4]
 800ec34:	2200      	movs	r2, #0
 800ec36:	869a      	strh	r2, [r3, #52]	; 0x34
      }

      pcb->polltmr = 0;
 800ec38:	687b      	ldr	r3, [r7, #4]
 800ec3a:	2220      	movs	r2, #32
 800ec3c:	2100      	movs	r1, #0
 800ec3e:	5499      	strb	r1, [r3, r2]

#if TCP_OVERSIZE
      if (pcb->unsent == NULL) {
 800ec40:	687b      	ldr	r3, [r7, #4]
 800ec42:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800ec44:	2b00      	cmp	r3, #0
 800ec46:	d103      	bne.n	800ec50 <tcp_receive+0x3ec>
        pcb->unsent_oversize = 0;
 800ec48:	687b      	ldr	r3, [r7, #4]
 800ec4a:	226c      	movs	r2, #108	; 0x6c
 800ec4c:	2100      	movs	r1, #0
 800ec4e:	5299      	strh	r1, [r3, r2]
        /* Inform neighbor reachability of forward progress. */
        nd6_reachability_hint(ip6_current_src_addr());
      }
#endif /* LWIP_IPV6 && LWIP_ND6_TCP_REACHABILITY_HINTS*/

      pcb->snd_buf = (tcpwnd_size_t)(pcb->snd_buf + recv_acked);
 800ec50:	687b      	ldr	r3, [r7, #4]
 800ec52:	2268      	movs	r2, #104	; 0x68
 800ec54:	5a9a      	ldrh	r2, [r3, r2]
 800ec56:	4bbb      	ldr	r3, [pc, #748]	; (800ef44 <tcp_receive+0x6e0>)
 800ec58:	881b      	ldrh	r3, [r3, #0]
 800ec5a:	18d3      	adds	r3, r2, r3
 800ec5c:	b299      	uxth	r1, r3
 800ec5e:	687b      	ldr	r3, [r7, #4]
 800ec60:	2268      	movs	r2, #104	; 0x68
 800ec62:	5299      	strh	r1, [r3, r2]
      /* check if this ACK ends our retransmission of in-flight data */
      if (pcb->flags & TF_RTO) {
 800ec64:	687b      	ldr	r3, [r7, #4]
 800ec66:	8bdb      	ldrh	r3, [r3, #30]
 800ec68:	001a      	movs	r2, r3
 800ec6a:	2380      	movs	r3, #128	; 0x80
 800ec6c:	011b      	lsls	r3, r3, #4
 800ec6e:	4013      	ands	r3, r2
 800ec70:	d048      	beq.n	800ed04 <tcp_receive+0x4a0>
        /* RTO is done if
            1) both queues are empty or
            2) unacked is empty and unsent head contains data not part of RTO or
            3) unacked head contains data not part of RTO */
        if (pcb->unacked == NULL) {
 800ec72:	687b      	ldr	r3, [r7, #4]
 800ec74:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800ec76:	2b00      	cmp	r3, #0
 800ec78:	d121      	bne.n	800ecbe <tcp_receive+0x45a>
          if ((pcb->unsent == NULL) ||
 800ec7a:	687b      	ldr	r3, [r7, #4]
 800ec7c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800ec7e:	2b00      	cmp	r3, #0
 800ec80:	d015      	beq.n	800ecae <tcp_receive+0x44a>
              (TCP_SEQ_LEQ(pcb->rto_end, lwip_ntohl(pcb->unsent->tcphdr->seqno)))) {
 800ec82:	687b      	ldr	r3, [r7, #4]
 800ec84:	6d1c      	ldr	r4, [r3, #80]	; 0x50
 800ec86:	687b      	ldr	r3, [r7, #4]
 800ec88:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800ec8a:	691b      	ldr	r3, [r3, #16]
 800ec8c:	791a      	ldrb	r2, [r3, #4]
 800ec8e:	7959      	ldrb	r1, [r3, #5]
 800ec90:	0209      	lsls	r1, r1, #8
 800ec92:	430a      	orrs	r2, r1
 800ec94:	7999      	ldrb	r1, [r3, #6]
 800ec96:	0409      	lsls	r1, r1, #16
 800ec98:	430a      	orrs	r2, r1
 800ec9a:	79db      	ldrb	r3, [r3, #7]
 800ec9c:	061b      	lsls	r3, r3, #24
 800ec9e:	4313      	orrs	r3, r2
 800eca0:	0018      	movs	r0, r3
 800eca2:	f7f8 fbc3 	bl	800742c <lwip_htonl>
 800eca6:	0003      	movs	r3, r0
 800eca8:	1ae3      	subs	r3, r4, r3
          if ((pcb->unsent == NULL) ||
 800ecaa:	2b00      	cmp	r3, #0
 800ecac:	dc2a      	bgt.n	800ed04 <tcp_receive+0x4a0>
            tcp_clear_flags(pcb, TF_RTO);
 800ecae:	687b      	ldr	r3, [r7, #4]
 800ecb0:	8bdb      	ldrh	r3, [r3, #30]
 800ecb2:	4aa5      	ldr	r2, [pc, #660]	; (800ef48 <tcp_receive+0x6e4>)
 800ecb4:	4013      	ands	r3, r2
 800ecb6:	b29a      	uxth	r2, r3
 800ecb8:	687b      	ldr	r3, [r7, #4]
 800ecba:	83da      	strh	r2, [r3, #30]
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 800ecbc:	e022      	b.n	800ed04 <tcp_receive+0x4a0>
          }
        } else if (TCP_SEQ_LEQ(pcb->rto_end, lwip_ntohl(pcb->unacked->tcphdr->seqno))) {
 800ecbe:	687b      	ldr	r3, [r7, #4]
 800ecc0:	6d1c      	ldr	r4, [r3, #80]	; 0x50
 800ecc2:	687b      	ldr	r3, [r7, #4]
 800ecc4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800ecc6:	691b      	ldr	r3, [r3, #16]
 800ecc8:	791a      	ldrb	r2, [r3, #4]
 800ecca:	7959      	ldrb	r1, [r3, #5]
 800eccc:	0209      	lsls	r1, r1, #8
 800ecce:	430a      	orrs	r2, r1
 800ecd0:	7999      	ldrb	r1, [r3, #6]
 800ecd2:	0409      	lsls	r1, r1, #16
 800ecd4:	430a      	orrs	r2, r1
 800ecd6:	79db      	ldrb	r3, [r3, #7]
 800ecd8:	061b      	lsls	r3, r3, #24
 800ecda:	4313      	orrs	r3, r2
 800ecdc:	0018      	movs	r0, r3
 800ecde:	f7f8 fba5 	bl	800742c <lwip_htonl>
 800ece2:	0003      	movs	r3, r0
 800ece4:	1ae3      	subs	r3, r4, r3
 800ece6:	2b00      	cmp	r3, #0
 800ece8:	dc0c      	bgt.n	800ed04 <tcp_receive+0x4a0>
          tcp_clear_flags(pcb, TF_RTO);
 800ecea:	687b      	ldr	r3, [r7, #4]
 800ecec:	8bdb      	ldrh	r3, [r3, #30]
 800ecee:	4a96      	ldr	r2, [pc, #600]	; (800ef48 <tcp_receive+0x6e4>)
 800ecf0:	4013      	ands	r3, r2
 800ecf2:	b29a      	uxth	r2, r3
 800ecf4:	687b      	ldr	r3, [r7, #4]
 800ecf6:	83da      	strh	r2, [r3, #30]
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 800ecf8:	e004      	b.n	800ed04 <tcp_receive+0x4a0>
        }
      }
      /* End of ACK for new data processing. */
    } else {
      /* Out of sequence ACK, didn't really ack anything */
      tcp_send_empty_ack(pcb);
 800ecfa:	687b      	ldr	r3, [r7, #4]
 800ecfc:	0018      	movs	r0, r3
 800ecfe:	f003 fbf9 	bl	80124f4 <tcp_send_empty_ack>
 800ed02:	e000      	b.n	800ed06 <tcp_receive+0x4a2>
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 800ed04:	46c0      	nop			; (mov r8, r8)
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
 800ed06:	687b      	ldr	r3, [r7, #4]
 800ed08:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ed0a:	2b00      	cmp	r3, #0
 800ed0c:	d05f      	beq.n	800edce <tcp_receive+0x56a>
 800ed0e:	687b      	ldr	r3, [r7, #4]
 800ed10:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800ed12:	4b8e      	ldr	r3, [pc, #568]	; (800ef4c <tcp_receive+0x6e8>)
 800ed14:	681b      	ldr	r3, [r3, #0]
 800ed16:	1ad3      	subs	r3, r2, r3
 800ed18:	d559      	bpl.n	800edce <tcp_receive+0x56a>
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
 800ed1a:	4b8d      	ldr	r3, [pc, #564]	; (800ef50 <tcp_receive+0x6ec>)
 800ed1c:	681b      	ldr	r3, [r3, #0]
 800ed1e:	b29a      	uxth	r2, r3
 800ed20:	687b      	ldr	r3, [r7, #4]
 800ed22:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ed24:	b29b      	uxth	r3, r3
 800ed26:	1ad3      	subs	r3, r2, r3
 800ed28:	b29a      	uxth	r2, r3
 800ed2a:	204e      	movs	r0, #78	; 0x4e
 800ed2c:	183b      	adds	r3, r7, r0
 800ed2e:	801a      	strh	r2, [r3, #0]

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, (u16_t)(m * TCP_SLOW_INTERVAL)));

      /* This is taken directly from VJs original code in his paper */
      m = (s16_t)(m - (pcb->sa >> 3));
 800ed30:	183b      	adds	r3, r7, r0
 800ed32:	881a      	ldrh	r2, [r3, #0]
 800ed34:	687b      	ldr	r3, [r7, #4]
 800ed36:	2140      	movs	r1, #64	; 0x40
 800ed38:	5e5b      	ldrsh	r3, [r3, r1]
 800ed3a:	10db      	asrs	r3, r3, #3
 800ed3c:	b21b      	sxth	r3, r3
 800ed3e:	b29b      	uxth	r3, r3
 800ed40:	1ad3      	subs	r3, r2, r3
 800ed42:	b29a      	uxth	r2, r3
 800ed44:	183b      	adds	r3, r7, r0
 800ed46:	801a      	strh	r2, [r3, #0]
      pcb->sa = (s16_t)(pcb->sa + m);
 800ed48:	687b      	ldr	r3, [r7, #4]
 800ed4a:	2240      	movs	r2, #64	; 0x40
 800ed4c:	5e9b      	ldrsh	r3, [r3, r2]
 800ed4e:	b29a      	uxth	r2, r3
 800ed50:	183b      	adds	r3, r7, r0
 800ed52:	881b      	ldrh	r3, [r3, #0]
 800ed54:	18d3      	adds	r3, r2, r3
 800ed56:	b29b      	uxth	r3, r3
 800ed58:	b219      	sxth	r1, r3
 800ed5a:	687b      	ldr	r3, [r7, #4]
 800ed5c:	2240      	movs	r2, #64	; 0x40
 800ed5e:	5299      	strh	r1, [r3, r2]
      if (m < 0) {
 800ed60:	183b      	adds	r3, r7, r0
 800ed62:	2200      	movs	r2, #0
 800ed64:	5e9b      	ldrsh	r3, [r3, r2]
 800ed66:	2b00      	cmp	r3, #0
 800ed68:	da05      	bge.n	800ed76 <tcp_receive+0x512>
        m = (s16_t) - m;
 800ed6a:	183b      	adds	r3, r7, r0
 800ed6c:	881b      	ldrh	r3, [r3, #0]
 800ed6e:	425b      	negs	r3, r3
 800ed70:	b29a      	uxth	r2, r3
 800ed72:	183b      	adds	r3, r7, r0
 800ed74:	801a      	strh	r2, [r3, #0]
      }
      m = (s16_t)(m - (pcb->sv >> 2));
 800ed76:	204e      	movs	r0, #78	; 0x4e
 800ed78:	183b      	adds	r3, r7, r0
 800ed7a:	881a      	ldrh	r2, [r3, #0]
 800ed7c:	687b      	ldr	r3, [r7, #4]
 800ed7e:	2142      	movs	r1, #66	; 0x42
 800ed80:	5e5b      	ldrsh	r3, [r3, r1]
 800ed82:	109b      	asrs	r3, r3, #2
 800ed84:	b21b      	sxth	r3, r3
 800ed86:	b29b      	uxth	r3, r3
 800ed88:	1ad3      	subs	r3, r2, r3
 800ed8a:	b29a      	uxth	r2, r3
 800ed8c:	183b      	adds	r3, r7, r0
 800ed8e:	801a      	strh	r2, [r3, #0]
      pcb->sv = (s16_t)(pcb->sv + m);
 800ed90:	687b      	ldr	r3, [r7, #4]
 800ed92:	2242      	movs	r2, #66	; 0x42
 800ed94:	5e9b      	ldrsh	r3, [r3, r2]
 800ed96:	b29a      	uxth	r2, r3
 800ed98:	183b      	adds	r3, r7, r0
 800ed9a:	881b      	ldrh	r3, [r3, #0]
 800ed9c:	18d3      	adds	r3, r2, r3
 800ed9e:	b29b      	uxth	r3, r3
 800eda0:	b219      	sxth	r1, r3
 800eda2:	687b      	ldr	r3, [r7, #4]
 800eda4:	2242      	movs	r2, #66	; 0x42
 800eda6:	5299      	strh	r1, [r3, r2]
      pcb->rto = (s16_t)((pcb->sa >> 3) + pcb->sv);
 800eda8:	687b      	ldr	r3, [r7, #4]
 800edaa:	2240      	movs	r2, #64	; 0x40
 800edac:	5e9b      	ldrsh	r3, [r3, r2]
 800edae:	10db      	asrs	r3, r3, #3
 800edb0:	b21b      	sxth	r3, r3
 800edb2:	b29a      	uxth	r2, r3
 800edb4:	687b      	ldr	r3, [r7, #4]
 800edb6:	2142      	movs	r1, #66	; 0x42
 800edb8:	5e5b      	ldrsh	r3, [r3, r1]
 800edba:	b29b      	uxth	r3, r3
 800edbc:	18d3      	adds	r3, r2, r3
 800edbe:	b29b      	uxth	r3, r3
 800edc0:	b219      	sxth	r1, r3
 800edc2:	687b      	ldr	r3, [r7, #4]
 800edc4:	2244      	movs	r2, #68	; 0x44
 800edc6:	5299      	strh	r1, [r3, r2]

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, (u16_t)(pcb->rto * TCP_SLOW_INTERVAL)));

      pcb->rttest = 0;
 800edc8:	687b      	ldr	r3, [r7, #4]
 800edca:	2200      	movs	r2, #0
 800edcc:	639a      	str	r2, [r3, #56]	; 0x38

  /* If the incoming segment contains data, we must process it
     further unless the pcb already received a FIN.
     (RFC 793, chapter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
     LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
  if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
 800edce:	4b61      	ldr	r3, [pc, #388]	; (800ef54 <tcp_receive+0x6f0>)
 800edd0:	881b      	ldrh	r3, [r3, #0]
 800edd2:	2b00      	cmp	r3, #0
 800edd4:	d101      	bne.n	800edda <tcp_receive+0x576>
 800edd6:	f000 fe3b 	bl	800fa50 <tcp_receive+0x11ec>
 800edda:	687b      	ldr	r3, [r7, #4]
 800eddc:	7e1b      	ldrb	r3, [r3, #24]
 800edde:	2b06      	cmp	r3, #6
 800ede0:	d901      	bls.n	800ede6 <tcp_receive+0x582>
 800ede2:	f000 fe35 	bl	800fa50 <tcp_receive+0x11ec>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
 800ede6:	687b      	ldr	r3, [r7, #4]
 800ede8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800edea:	4b5b      	ldr	r3, [pc, #364]	; (800ef58 <tcp_receive+0x6f4>)
 800edec:	681b      	ldr	r3, [r3, #0]
 800edee:	1ad3      	subs	r3, r2, r3
 800edf0:	3b01      	subs	r3, #1
 800edf2:	2b00      	cmp	r3, #0
 800edf4:	da00      	bge.n	800edf8 <tcp_receive+0x594>
 800edf6:	e0c3      	b.n	800ef80 <tcp_receive+0x71c>
 800edf8:	687b      	ldr	r3, [r7, #4]
 800edfa:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800edfc:	4b55      	ldr	r3, [pc, #340]	; (800ef54 <tcp_receive+0x6f0>)
 800edfe:	881b      	ldrh	r3, [r3, #0]
 800ee00:	0019      	movs	r1, r3
 800ee02:	4b55      	ldr	r3, [pc, #340]	; (800ef58 <tcp_receive+0x6f4>)
 800ee04:	681b      	ldr	r3, [r3, #0]
 800ee06:	18cb      	adds	r3, r1, r3
 800ee08:	1ad3      	subs	r3, r2, r3
 800ee0a:	3301      	adds	r3, #1
 800ee0c:	2b00      	cmp	r3, #0
 800ee0e:	dd00      	ble.n	800ee12 <tcp_receive+0x5ae>
 800ee10:	e0b6      	b.n	800ef80 <tcp_receive+0x71c>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      struct pbuf *p = inseg.p;
 800ee12:	4b52      	ldr	r3, [pc, #328]	; (800ef5c <tcp_receive+0x6f8>)
 800ee14:	685b      	ldr	r3, [r3, #4]
 800ee16:	647b      	str	r3, [r7, #68]	; 0x44
      u32_t off32 = pcb->rcv_nxt - seqno;
 800ee18:	687b      	ldr	r3, [r7, #4]
 800ee1a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800ee1c:	4b4e      	ldr	r3, [pc, #312]	; (800ef58 <tcp_receive+0x6f4>)
 800ee1e:	681b      	ldr	r3, [r3, #0]
 800ee20:	1ad3      	subs	r3, r2, r3
 800ee22:	627b      	str	r3, [r7, #36]	; 0x24
      u16_t new_tot_len, off;
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
 800ee24:	4b4d      	ldr	r3, [pc, #308]	; (800ef5c <tcp_receive+0x6f8>)
 800ee26:	685b      	ldr	r3, [r3, #4]
 800ee28:	2b00      	cmp	r3, #0
 800ee2a:	d105      	bne.n	800ee38 <tcp_receive+0x5d4>
 800ee2c:	4b4c      	ldr	r3, [pc, #304]	; (800ef60 <tcp_receive+0x6fc>)
 800ee2e:	4a4d      	ldr	r2, [pc, #308]	; (800ef64 <tcp_receive+0x700>)
 800ee30:	494d      	ldr	r1, [pc, #308]	; (800ef68 <tcp_receive+0x704>)
 800ee32:	484e      	ldr	r0, [pc, #312]	; (800ef6c <tcp_receive+0x708>)
 800ee34:	f7f3 f9d6 	bl	80021e4 <app_debug_rtt_raw>
      LWIP_ASSERT("insane offset!", (off32 < 0xffff));
 800ee38:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ee3a:	4a4d      	ldr	r2, [pc, #308]	; (800ef70 <tcp_receive+0x70c>)
 800ee3c:	4293      	cmp	r3, r2
 800ee3e:	d905      	bls.n	800ee4c <tcp_receive+0x5e8>
 800ee40:	4b47      	ldr	r3, [pc, #284]	; (800ef60 <tcp_receive+0x6fc>)
 800ee42:	4a4c      	ldr	r2, [pc, #304]	; (800ef74 <tcp_receive+0x710>)
 800ee44:	494c      	ldr	r1, [pc, #304]	; (800ef78 <tcp_receive+0x714>)
 800ee46:	4849      	ldr	r0, [pc, #292]	; (800ef6c <tcp_receive+0x708>)
 800ee48:	f7f3 f9cc 	bl	80021e4 <app_debug_rtt_raw>
      off = (u16_t)off32;
 800ee4c:	2142      	movs	r1, #66	; 0x42
 800ee4e:	187b      	adds	r3, r7, r1
 800ee50:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800ee52:	801a      	strh	r2, [r3, #0]
      LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
 800ee54:	4b41      	ldr	r3, [pc, #260]	; (800ef5c <tcp_receive+0x6f8>)
 800ee56:	685b      	ldr	r3, [r3, #4]
 800ee58:	891b      	ldrh	r3, [r3, #8]
 800ee5a:	187a      	adds	r2, r7, r1
 800ee5c:	8812      	ldrh	r2, [r2, #0]
 800ee5e:	429a      	cmp	r2, r3
 800ee60:	d906      	bls.n	800ee70 <tcp_receive+0x60c>
 800ee62:	4b3f      	ldr	r3, [pc, #252]	; (800ef60 <tcp_receive+0x6fc>)
 800ee64:	22b3      	movs	r2, #179	; 0xb3
 800ee66:	00d2      	lsls	r2, r2, #3
 800ee68:	4944      	ldr	r1, [pc, #272]	; (800ef7c <tcp_receive+0x718>)
 800ee6a:	4840      	ldr	r0, [pc, #256]	; (800ef6c <tcp_receive+0x708>)
 800ee6c:	f7f3 f9ba 	bl	80021e4 <app_debug_rtt_raw>
      inseg.len -= off;
 800ee70:	4b3a      	ldr	r3, [pc, #232]	; (800ef5c <tcp_receive+0x6f8>)
 800ee72:	891a      	ldrh	r2, [r3, #8]
 800ee74:	2042      	movs	r0, #66	; 0x42
 800ee76:	183b      	adds	r3, r7, r0
 800ee78:	881b      	ldrh	r3, [r3, #0]
 800ee7a:	1ad3      	subs	r3, r2, r3
 800ee7c:	b29a      	uxth	r2, r3
 800ee7e:	4b37      	ldr	r3, [pc, #220]	; (800ef5c <tcp_receive+0x6f8>)
 800ee80:	811a      	strh	r2, [r3, #8]
      new_tot_len = (u16_t)(inseg.p->tot_len - off);
 800ee82:	4b36      	ldr	r3, [pc, #216]	; (800ef5c <tcp_receive+0x6f8>)
 800ee84:	685b      	ldr	r3, [r3, #4]
 800ee86:	8919      	ldrh	r1, [r3, #8]
 800ee88:	2322      	movs	r3, #34	; 0x22
 800ee8a:	18fb      	adds	r3, r7, r3
 800ee8c:	183a      	adds	r2, r7, r0
 800ee8e:	8812      	ldrh	r2, [r2, #0]
 800ee90:	1a8a      	subs	r2, r1, r2
 800ee92:	801a      	strh	r2, [r3, #0]
      while (p->len < off) {
 800ee94:	e012      	b.n	800eebc <tcp_receive+0x658>
        off -= p->len;
 800ee96:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800ee98:	895a      	ldrh	r2, [r3, #10]
 800ee9a:	2142      	movs	r1, #66	; 0x42
 800ee9c:	187b      	adds	r3, r7, r1
 800ee9e:	1879      	adds	r1, r7, r1
 800eea0:	8809      	ldrh	r1, [r1, #0]
 800eea2:	1a8a      	subs	r2, r1, r2
 800eea4:	801a      	strh	r2, [r3, #0]
        /* all pbufs up to and including this one have len==0, so tot_len is equal */
        p->tot_len = new_tot_len;
 800eea6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800eea8:	2222      	movs	r2, #34	; 0x22
 800eeaa:	18ba      	adds	r2, r7, r2
 800eeac:	8812      	ldrh	r2, [r2, #0]
 800eeae:	811a      	strh	r2, [r3, #8]
        p->len = 0;
 800eeb0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800eeb2:	2200      	movs	r2, #0
 800eeb4:	815a      	strh	r2, [r3, #10]
        p = p->next;
 800eeb6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800eeb8:	681b      	ldr	r3, [r3, #0]
 800eeba:	647b      	str	r3, [r7, #68]	; 0x44
      while (p->len < off) {
 800eebc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800eebe:	895b      	ldrh	r3, [r3, #10]
 800eec0:	2142      	movs	r1, #66	; 0x42
 800eec2:	187a      	adds	r2, r7, r1
 800eec4:	8812      	ldrh	r2, [r2, #0]
 800eec6:	429a      	cmp	r2, r3
 800eec8:	d8e5      	bhi.n	800ee96 <tcp_receive+0x632>
      }
      /* cannot fail... */
      pbuf_remove_header(p, off);
 800eeca:	187b      	adds	r3, r7, r1
 800eecc:	881a      	ldrh	r2, [r3, #0]
 800eece:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800eed0:	0011      	movs	r1, r2
 800eed2:	0018      	movs	r0, r3
 800eed4:	f7fb fa6c 	bl	800a3b0 <pbuf_remove_header>
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
 800eed8:	687b      	ldr	r3, [r7, #4]
 800eeda:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800eedc:	4b1e      	ldr	r3, [pc, #120]	; (800ef58 <tcp_receive+0x6f4>)
 800eede:	601a      	str	r2, [r3, #0]
 800eee0:	4b1e      	ldr	r3, [pc, #120]	; (800ef5c <tcp_receive+0x6f8>)
 800eee2:	691b      	ldr	r3, [r3, #16]
 800eee4:	4a1c      	ldr	r2, [pc, #112]	; (800ef58 <tcp_receive+0x6f4>)
 800eee6:	6812      	ldr	r2, [r2, #0]
 800eee8:	21ff      	movs	r1, #255	; 0xff
 800eeea:	4011      	ands	r1, r2
 800eeec:	000c      	movs	r4, r1
 800eeee:	7919      	ldrb	r1, [r3, #4]
 800eef0:	2000      	movs	r0, #0
 800eef2:	4001      	ands	r1, r0
 800eef4:	1c08      	adds	r0, r1, #0
 800eef6:	1c21      	adds	r1, r4, #0
 800eef8:	4301      	orrs	r1, r0
 800eefa:	7119      	strb	r1, [r3, #4]
 800eefc:	0a11      	lsrs	r1, r2, #8
 800eefe:	20ff      	movs	r0, #255	; 0xff
 800ef00:	4001      	ands	r1, r0
 800ef02:	000c      	movs	r4, r1
 800ef04:	7959      	ldrb	r1, [r3, #5]
 800ef06:	2000      	movs	r0, #0
 800ef08:	4001      	ands	r1, r0
 800ef0a:	1c08      	adds	r0, r1, #0
 800ef0c:	1c21      	adds	r1, r4, #0
 800ef0e:	4301      	orrs	r1, r0
 800ef10:	7159      	strb	r1, [r3, #5]
 800ef12:	0c11      	lsrs	r1, r2, #16
 800ef14:	20ff      	movs	r0, #255	; 0xff
 800ef16:	4001      	ands	r1, r0
 800ef18:	000c      	movs	r4, r1
 800ef1a:	7999      	ldrb	r1, [r3, #6]
 800ef1c:	2000      	movs	r0, #0
 800ef1e:	4001      	ands	r1, r0
 800ef20:	1c08      	adds	r0, r1, #0
 800ef22:	1c21      	adds	r1, r4, #0
 800ef24:	4301      	orrs	r1, r0
 800ef26:	7199      	strb	r1, [r3, #6]
 800ef28:	0e10      	lsrs	r0, r2, #24
 800ef2a:	79da      	ldrb	r2, [r3, #7]
 800ef2c:	2100      	movs	r1, #0
 800ef2e:	400a      	ands	r2, r1
 800ef30:	1c11      	adds	r1, r2, #0
 800ef32:	1c02      	adds	r2, r0, #0
 800ef34:	430a      	orrs	r2, r1
 800ef36:	71da      	strb	r2, [r3, #7]
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
 800ef38:	e02f      	b.n	800ef9a <tcp_receive+0x736>
 800ef3a:	46c0      	nop			; (mov r8, r8)
 800ef3c:	0802156c 	.word	0x0802156c
 800ef40:	08021574 	.word	0x08021574
 800ef44:	20000c74 	.word	0x20000c74
 800ef48:	fffff7ff 	.word	0xfffff7ff
 800ef4c:	20000c70 	.word	0x20000c70
 800ef50:	20002790 	.word	0x20002790
 800ef54:	20000c76 	.word	0x20000c76
 800ef58:	20000c6c 	.word	0x20000c6c
 800ef5c:	20000c48 	.word	0x20000c48
 800ef60:	0802120c 	.word	0x0802120c
 800ef64:	00000595 	.word	0x00000595
 800ef68:	0802157c 	.word	0x0802157c
 800ef6c:	0802124c 	.word	0x0802124c
 800ef70:	0000fffe 	.word	0x0000fffe
 800ef74:	00000596 	.word	0x00000596
 800ef78:	0802158c 	.word	0x0802158c
 800ef7c:	0802159c 	.word	0x0802159c
    } else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
 800ef80:	4bb0      	ldr	r3, [pc, #704]	; (800f244 <tcp_receive+0x9e0>)
 800ef82:	681a      	ldr	r2, [r3, #0]
 800ef84:	687b      	ldr	r3, [r7, #4]
 800ef86:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ef88:	1ad3      	subs	r3, r2, r3
 800ef8a:	d506      	bpl.n	800ef9a <tcp_receive+0x736>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
 800ef8c:	687b      	ldr	r3, [r7, #4]
 800ef8e:	8bdb      	ldrh	r3, [r3, #30]
 800ef90:	2202      	movs	r2, #2
 800ef92:	4313      	orrs	r3, r2
 800ef94:	b29a      	uxth	r2, r3
 800ef96:	687b      	ldr	r3, [r7, #4]
 800ef98:	83da      	strh	r2, [r3, #30]
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
 800ef9a:	4baa      	ldr	r3, [pc, #680]	; (800f244 <tcp_receive+0x9e0>)
 800ef9c:	681a      	ldr	r2, [r3, #0]
 800ef9e:	687b      	ldr	r3, [r7, #4]
 800efa0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800efa2:	1ad3      	subs	r3, r2, r3
 800efa4:	d501      	bpl.n	800efaa <tcp_receive+0x746>
 800efa6:	f000 fd4d 	bl	800fa44 <tcp_receive+0x11e0>
 800efaa:	4ba6      	ldr	r3, [pc, #664]	; (800f244 <tcp_receive+0x9e0>)
 800efac:	681a      	ldr	r2, [r3, #0]
 800efae:	687b      	ldr	r3, [r7, #4]
 800efb0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800efb2:	6879      	ldr	r1, [r7, #4]
 800efb4:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
 800efb6:	185b      	adds	r3, r3, r1
 800efb8:	1ad3      	subs	r3, r2, r3
 800efba:	3301      	adds	r3, #1
 800efbc:	2b00      	cmp	r3, #0
 800efbe:	dd01      	ble.n	800efc4 <tcp_receive+0x760>
 800efc0:	f000 fd40 	bl	800fa44 <tcp_receive+0x11e0>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
      if (pcb->rcv_nxt == seqno) {
 800efc4:	687b      	ldr	r3, [r7, #4]
 800efc6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800efc8:	4b9e      	ldr	r3, [pc, #632]	; (800f244 <tcp_receive+0x9e0>)
 800efca:	681b      	ldr	r3, [r3, #0]
 800efcc:	429a      	cmp	r2, r3
 800efce:	d000      	beq.n	800efd2 <tcp_receive+0x76e>
 800efd0:	e337      	b.n	800f642 <tcp_receive+0xdde>
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
        tcplen = TCP_TCPLEN(&inseg);
 800efd2:	4b9d      	ldr	r3, [pc, #628]	; (800f248 <tcp_receive+0x9e4>)
 800efd4:	891c      	ldrh	r4, [r3, #8]
 800efd6:	4b9c      	ldr	r3, [pc, #624]	; (800f248 <tcp_receive+0x9e4>)
 800efd8:	691b      	ldr	r3, [r3, #16]
 800efda:	7b1a      	ldrb	r2, [r3, #12]
 800efdc:	7b5b      	ldrb	r3, [r3, #13]
 800efde:	021b      	lsls	r3, r3, #8
 800efe0:	4313      	orrs	r3, r2
 800efe2:	b29b      	uxth	r3, r3
 800efe4:	0018      	movs	r0, r3
 800efe6:	f7f8 fa0b 	bl	8007400 <lwip_htons>
 800efea:	0003      	movs	r3, r0
 800efec:	b2db      	uxtb	r3, r3
 800efee:	001a      	movs	r2, r3
 800eff0:	2303      	movs	r3, #3
 800eff2:	4013      	ands	r3, r2
 800eff4:	d001      	beq.n	800effa <tcp_receive+0x796>
 800eff6:	2301      	movs	r3, #1
 800eff8:	e000      	b.n	800effc <tcp_receive+0x798>
 800effa:	2300      	movs	r3, #0
 800effc:	191b      	adds	r3, r3, r4
 800effe:	b29a      	uxth	r2, r3
 800f000:	4b92      	ldr	r3, [pc, #584]	; (800f24c <tcp_receive+0x9e8>)
 800f002:	801a      	strh	r2, [r3, #0]

        if (tcplen > pcb->rcv_wnd) {
 800f004:	687b      	ldr	r3, [r7, #4]
 800f006:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800f008:	4b90      	ldr	r3, [pc, #576]	; (800f24c <tcp_receive+0x9e8>)
 800f00a:	881b      	ldrh	r3, [r3, #0]
 800f00c:	429a      	cmp	r2, r3
 800f00e:	d300      	bcc.n	800f012 <tcp_receive+0x7ae>
 800f010:	e095      	b.n	800f13e <tcp_receive+0x8da>
          LWIP_DEBUGF(TCP_INPUT_DEBUG,
                      ("tcp_receive: other end overran receive window"
                       "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                       seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 800f012:	4b8d      	ldr	r3, [pc, #564]	; (800f248 <tcp_receive+0x9e4>)
 800f014:	691b      	ldr	r3, [r3, #16]
 800f016:	7b1a      	ldrb	r2, [r3, #12]
 800f018:	7b5b      	ldrb	r3, [r3, #13]
 800f01a:	021b      	lsls	r3, r3, #8
 800f01c:	4313      	orrs	r3, r2
 800f01e:	b29b      	uxth	r3, r3
 800f020:	0018      	movs	r0, r3
 800f022:	f7f8 f9ed 	bl	8007400 <lwip_htons>
 800f026:	0003      	movs	r3, r0
 800f028:	b2db      	uxtb	r3, r3
 800f02a:	001a      	movs	r2, r3
 800f02c:	2301      	movs	r3, #1
 800f02e:	4013      	ands	r3, r2
 800f030:	d037      	beq.n	800f0a2 <tcp_receive+0x83e>
            /* Must remove the FIN from the header as we're trimming
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) & ~(unsigned int)TCP_FIN);
 800f032:	4b85      	ldr	r3, [pc, #532]	; (800f248 <tcp_receive+0x9e4>)
 800f034:	691b      	ldr	r3, [r3, #16]
 800f036:	7b1a      	ldrb	r2, [r3, #12]
 800f038:	7b5b      	ldrb	r3, [r3, #13]
 800f03a:	021b      	lsls	r3, r3, #8
 800f03c:	4313      	orrs	r3, r2
 800f03e:	b29b      	uxth	r3, r3
 800f040:	b21b      	sxth	r3, r3
 800f042:	4a83      	ldr	r2, [pc, #524]	; (800f250 <tcp_receive+0x9ec>)
 800f044:	4013      	ands	r3, r2
 800f046:	b21c      	sxth	r4, r3
 800f048:	4b7f      	ldr	r3, [pc, #508]	; (800f248 <tcp_receive+0x9e4>)
 800f04a:	691b      	ldr	r3, [r3, #16]
 800f04c:	7b1a      	ldrb	r2, [r3, #12]
 800f04e:	7b5b      	ldrb	r3, [r3, #13]
 800f050:	021b      	lsls	r3, r3, #8
 800f052:	4313      	orrs	r3, r2
 800f054:	b29b      	uxth	r3, r3
 800f056:	0018      	movs	r0, r3
 800f058:	f7f8 f9d2 	bl	8007400 <lwip_htons>
 800f05c:	0003      	movs	r3, r0
 800f05e:	b2db      	uxtb	r3, r3
 800f060:	b29b      	uxth	r3, r3
 800f062:	223e      	movs	r2, #62	; 0x3e
 800f064:	4013      	ands	r3, r2
 800f066:	b29b      	uxth	r3, r3
 800f068:	0018      	movs	r0, r3
 800f06a:	f7f8 f9c9 	bl	8007400 <lwip_htons>
 800f06e:	0003      	movs	r3, r0
 800f070:	b21b      	sxth	r3, r3
 800f072:	4323      	orrs	r3, r4
 800f074:	b21a      	sxth	r2, r3
 800f076:	4b74      	ldr	r3, [pc, #464]	; (800f248 <tcp_receive+0x9e4>)
 800f078:	691b      	ldr	r3, [r3, #16]
 800f07a:	b292      	uxth	r2, r2
 800f07c:	21ff      	movs	r1, #255	; 0xff
 800f07e:	4011      	ands	r1, r2
 800f080:	000c      	movs	r4, r1
 800f082:	7b19      	ldrb	r1, [r3, #12]
 800f084:	2000      	movs	r0, #0
 800f086:	4001      	ands	r1, r0
 800f088:	1c08      	adds	r0, r1, #0
 800f08a:	1c21      	adds	r1, r4, #0
 800f08c:	4301      	orrs	r1, r0
 800f08e:	7319      	strb	r1, [r3, #12]
 800f090:	0a12      	lsrs	r2, r2, #8
 800f092:	b290      	uxth	r0, r2
 800f094:	7b5a      	ldrb	r2, [r3, #13]
 800f096:	2100      	movs	r1, #0
 800f098:	400a      	ands	r2, r1
 800f09a:	1c11      	adds	r1, r2, #0
 800f09c:	1c02      	adds	r2, r0, #0
 800f09e:	430a      	orrs	r2, r1
 800f0a0:	735a      	strb	r2, [r3, #13]
          }
          /* Adjust length of segment to fit in the window. */
          TCPWND_CHECK16(pcb->rcv_wnd);
          inseg.len = (u16_t)pcb->rcv_wnd;
 800f0a2:	687b      	ldr	r3, [r7, #4]
 800f0a4:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800f0a6:	4b68      	ldr	r3, [pc, #416]	; (800f248 <tcp_receive+0x9e4>)
 800f0a8:	811a      	strh	r2, [r3, #8]
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 800f0aa:	4b67      	ldr	r3, [pc, #412]	; (800f248 <tcp_receive+0x9e4>)
 800f0ac:	691b      	ldr	r3, [r3, #16]
 800f0ae:	7b1a      	ldrb	r2, [r3, #12]
 800f0b0:	7b5b      	ldrb	r3, [r3, #13]
 800f0b2:	021b      	lsls	r3, r3, #8
 800f0b4:	4313      	orrs	r3, r2
 800f0b6:	b29b      	uxth	r3, r3
 800f0b8:	0018      	movs	r0, r3
 800f0ba:	f7f8 f9a1 	bl	8007400 <lwip_htons>
 800f0be:	0003      	movs	r3, r0
 800f0c0:	b2db      	uxtb	r3, r3
 800f0c2:	001a      	movs	r2, r3
 800f0c4:	2302      	movs	r3, #2
 800f0c6:	4013      	ands	r3, r2
 800f0c8:	d005      	beq.n	800f0d6 <tcp_receive+0x872>
            inseg.len -= 1;
 800f0ca:	4b5f      	ldr	r3, [pc, #380]	; (800f248 <tcp_receive+0x9e4>)
 800f0cc:	891b      	ldrh	r3, [r3, #8]
 800f0ce:	3b01      	subs	r3, #1
 800f0d0:	b29a      	uxth	r2, r3
 800f0d2:	4b5d      	ldr	r3, [pc, #372]	; (800f248 <tcp_receive+0x9e4>)
 800f0d4:	811a      	strh	r2, [r3, #8]
          }
          pbuf_realloc(inseg.p, inseg.len);
 800f0d6:	4b5c      	ldr	r3, [pc, #368]	; (800f248 <tcp_receive+0x9e4>)
 800f0d8:	685a      	ldr	r2, [r3, #4]
 800f0da:	4b5b      	ldr	r3, [pc, #364]	; (800f248 <tcp_receive+0x9e4>)
 800f0dc:	891b      	ldrh	r3, [r3, #8]
 800f0de:	0019      	movs	r1, r3
 800f0e0:	0010      	movs	r0, r2
 800f0e2:	f7fb f843 	bl	800a16c <pbuf_realloc>
          tcplen = TCP_TCPLEN(&inseg);
 800f0e6:	4b58      	ldr	r3, [pc, #352]	; (800f248 <tcp_receive+0x9e4>)
 800f0e8:	891c      	ldrh	r4, [r3, #8]
 800f0ea:	4b57      	ldr	r3, [pc, #348]	; (800f248 <tcp_receive+0x9e4>)
 800f0ec:	691b      	ldr	r3, [r3, #16]
 800f0ee:	7b1a      	ldrb	r2, [r3, #12]
 800f0f0:	7b5b      	ldrb	r3, [r3, #13]
 800f0f2:	021b      	lsls	r3, r3, #8
 800f0f4:	4313      	orrs	r3, r2
 800f0f6:	b29b      	uxth	r3, r3
 800f0f8:	0018      	movs	r0, r3
 800f0fa:	f7f8 f981 	bl	8007400 <lwip_htons>
 800f0fe:	0003      	movs	r3, r0
 800f100:	b2db      	uxtb	r3, r3
 800f102:	001a      	movs	r2, r3
 800f104:	2303      	movs	r3, #3
 800f106:	4013      	ands	r3, r2
 800f108:	d001      	beq.n	800f10e <tcp_receive+0x8aa>
 800f10a:	2301      	movs	r3, #1
 800f10c:	e000      	b.n	800f110 <tcp_receive+0x8ac>
 800f10e:	2300      	movs	r3, #0
 800f110:	191b      	adds	r3, r3, r4
 800f112:	b29a      	uxth	r2, r3
 800f114:	4b4d      	ldr	r3, [pc, #308]	; (800f24c <tcp_receive+0x9e8>)
 800f116:	801a      	strh	r2, [r3, #0]
          LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 800f118:	4b4c      	ldr	r3, [pc, #304]	; (800f24c <tcp_receive+0x9e8>)
 800f11a:	881b      	ldrh	r3, [r3, #0]
 800f11c:	001a      	movs	r2, r3
 800f11e:	4b49      	ldr	r3, [pc, #292]	; (800f244 <tcp_receive+0x9e0>)
 800f120:	681b      	ldr	r3, [r3, #0]
 800f122:	18d2      	adds	r2, r2, r3
 800f124:	687b      	ldr	r3, [r7, #4]
 800f126:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800f128:	6879      	ldr	r1, [r7, #4]
 800f12a:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
 800f12c:	185b      	adds	r3, r3, r1
 800f12e:	429a      	cmp	r2, r3
 800f130:	d005      	beq.n	800f13e <tcp_receive+0x8da>
 800f132:	4b48      	ldr	r3, [pc, #288]	; (800f254 <tcp_receive+0x9f0>)
 800f134:	4a48      	ldr	r2, [pc, #288]	; (800f258 <tcp_receive+0x9f4>)
 800f136:	4949      	ldr	r1, [pc, #292]	; (800f25c <tcp_receive+0x9f8>)
 800f138:	4849      	ldr	r0, [pc, #292]	; (800f260 <tcp_receive+0x9fc>)
 800f13a:	f7f3 f853 	bl	80021e4 <app_debug_rtt_raw>
        }
#if TCP_QUEUE_OOSEQ
        /* Received in-sequence data, adjust ooseq data if:
           - FIN has been received or
           - inseq overlaps with ooseq */
        if (pcb->ooseq != NULL) {
 800f13e:	687b      	ldr	r3, [r7, #4]
 800f140:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800f142:	2b00      	cmp	r3, #0
 800f144:	d100      	bne.n	800f148 <tcp_receive+0x8e4>
 800f146:	e138      	b.n	800f3ba <tcp_receive+0xb56>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 800f148:	4b3f      	ldr	r3, [pc, #252]	; (800f248 <tcp_receive+0x9e4>)
 800f14a:	691b      	ldr	r3, [r3, #16]
 800f14c:	7b1a      	ldrb	r2, [r3, #12]
 800f14e:	7b5b      	ldrb	r3, [r3, #13]
 800f150:	021b      	lsls	r3, r3, #8
 800f152:	4313      	orrs	r3, r2
 800f154:	b29b      	uxth	r3, r3
 800f156:	0018      	movs	r0, r3
 800f158:	f7f8 f952 	bl	8007400 <lwip_htons>
 800f15c:	0003      	movs	r3, r0
 800f15e:	b2db      	uxtb	r3, r3
 800f160:	001a      	movs	r2, r3
 800f162:	2301      	movs	r3, #1
 800f164:	4013      	ands	r3, r2
 800f166:	d011      	beq.n	800f18c <tcp_receive+0x928>
            LWIP_DEBUGF(TCP_INPUT_DEBUG,
                        ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
            /* Received in-order FIN means anything that was received
             * out of order must now have been received in-order, so
             * bin the ooseq queue */
            while (pcb->ooseq != NULL) {
 800f168:	e00b      	b.n	800f182 <tcp_receive+0x91e>
              struct tcp_seg *old_ooseq = pcb->ooseq;
 800f16a:	687b      	ldr	r3, [r7, #4]
 800f16c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800f16e:	60fb      	str	r3, [r7, #12]
              pcb->ooseq = pcb->ooseq->next;
 800f170:	687b      	ldr	r3, [r7, #4]
 800f172:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800f174:	681a      	ldr	r2, [r3, #0]
 800f176:	687b      	ldr	r3, [r7, #4]
 800f178:	679a      	str	r2, [r3, #120]	; 0x78
              tcp_seg_free(old_ooseq);
 800f17a:	68fb      	ldr	r3, [r7, #12]
 800f17c:	0018      	movs	r0, r3
 800f17e:	f7fd fa09 	bl	800c594 <tcp_seg_free>
            while (pcb->ooseq != NULL) {
 800f182:	687b      	ldr	r3, [r7, #4]
 800f184:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800f186:	2b00      	cmp	r3, #0
 800f188:	d1ef      	bne.n	800f16a <tcp_receive+0x906>
 800f18a:	e116      	b.n	800f3ba <tcp_receive+0xb56>
            }
          } else {
            struct tcp_seg *next = pcb->ooseq;
 800f18c:	687b      	ldr	r3, [r7, #4]
 800f18e:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800f190:	63fb      	str	r3, [r7, #60]	; 0x3c
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
 800f192:	e075      	b.n	800f280 <tcp_receive+0xa1c>
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              struct tcp_seg *tmp;
              /* inseg cannot have FIN here (already processed above) */
              if ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0 &&
 800f194:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f196:	691b      	ldr	r3, [r3, #16]
 800f198:	7b1a      	ldrb	r2, [r3, #12]
 800f19a:	7b5b      	ldrb	r3, [r3, #13]
 800f19c:	021b      	lsls	r3, r3, #8
 800f19e:	4313      	orrs	r3, r2
 800f1a0:	b29b      	uxth	r3, r3
 800f1a2:	0018      	movs	r0, r3
 800f1a4:	f7f8 f92c 	bl	8007400 <lwip_htons>
 800f1a8:	0003      	movs	r3, r0
 800f1aa:	b2db      	uxtb	r3, r3
 800f1ac:	001a      	movs	r2, r3
 800f1ae:	2301      	movs	r3, #1
 800f1b0:	4013      	ands	r3, r2
 800f1b2:	d05c      	beq.n	800f26e <tcp_receive+0xa0a>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
 800f1b4:	4b24      	ldr	r3, [pc, #144]	; (800f248 <tcp_receive+0x9e4>)
 800f1b6:	691b      	ldr	r3, [r3, #16]
 800f1b8:	7b1a      	ldrb	r2, [r3, #12]
 800f1ba:	7b5b      	ldrb	r3, [r3, #13]
 800f1bc:	021b      	lsls	r3, r3, #8
 800f1be:	4313      	orrs	r3, r2
 800f1c0:	b29b      	uxth	r3, r3
 800f1c2:	0018      	movs	r0, r3
 800f1c4:	f7f8 f91c 	bl	8007400 <lwip_htons>
 800f1c8:	0003      	movs	r3, r0
 800f1ca:	b2db      	uxtb	r3, r3
 800f1cc:	001a      	movs	r2, r3
 800f1ce:	2302      	movs	r3, #2
 800f1d0:	4013      	ands	r3, r2
              if ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0 &&
 800f1d2:	d14c      	bne.n	800f26e <tcp_receive+0xa0a>
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
 800f1d4:	4b1c      	ldr	r3, [pc, #112]	; (800f248 <tcp_receive+0x9e4>)
 800f1d6:	691b      	ldr	r3, [r3, #16]
 800f1d8:	7b1a      	ldrb	r2, [r3, #12]
 800f1da:	7b5b      	ldrb	r3, [r3, #13]
 800f1dc:	021b      	lsls	r3, r3, #8
 800f1de:	4313      	orrs	r3, r2
 800f1e0:	b29c      	uxth	r4, r3
 800f1e2:	2001      	movs	r0, #1
 800f1e4:	f7f8 f90c 	bl	8007400 <lwip_htons>
 800f1e8:	0003      	movs	r3, r0
 800f1ea:	001a      	movs	r2, r3
 800f1ec:	4b16      	ldr	r3, [pc, #88]	; (800f248 <tcp_receive+0x9e4>)
 800f1ee:	691b      	ldr	r3, [r3, #16]
 800f1f0:	4322      	orrs	r2, r4
 800f1f2:	b292      	uxth	r2, r2
 800f1f4:	21ff      	movs	r1, #255	; 0xff
 800f1f6:	4011      	ands	r1, r2
 800f1f8:	000c      	movs	r4, r1
 800f1fa:	7b19      	ldrb	r1, [r3, #12]
 800f1fc:	2000      	movs	r0, #0
 800f1fe:	4001      	ands	r1, r0
 800f200:	1c08      	adds	r0, r1, #0
 800f202:	1c21      	adds	r1, r4, #0
 800f204:	4301      	orrs	r1, r0
 800f206:	7319      	strb	r1, [r3, #12]
 800f208:	0a12      	lsrs	r2, r2, #8
 800f20a:	b290      	uxth	r0, r2
 800f20c:	7b5a      	ldrb	r2, [r3, #13]
 800f20e:	2100      	movs	r1, #0
 800f210:	400a      	ands	r2, r1
 800f212:	1c11      	adds	r1, r2, #0
 800f214:	1c02      	adds	r2, r0, #0
 800f216:	430a      	orrs	r2, r1
 800f218:	735a      	strb	r2, [r3, #13]
                tcplen = TCP_TCPLEN(&inseg);
 800f21a:	4b0b      	ldr	r3, [pc, #44]	; (800f248 <tcp_receive+0x9e4>)
 800f21c:	891c      	ldrh	r4, [r3, #8]
 800f21e:	4b0a      	ldr	r3, [pc, #40]	; (800f248 <tcp_receive+0x9e4>)
 800f220:	691b      	ldr	r3, [r3, #16]
 800f222:	7b1a      	ldrb	r2, [r3, #12]
 800f224:	7b5b      	ldrb	r3, [r3, #13]
 800f226:	021b      	lsls	r3, r3, #8
 800f228:	4313      	orrs	r3, r2
 800f22a:	b29b      	uxth	r3, r3
 800f22c:	0018      	movs	r0, r3
 800f22e:	f7f8 f8e7 	bl	8007400 <lwip_htons>
 800f232:	0003      	movs	r3, r0
 800f234:	b2db      	uxtb	r3, r3
 800f236:	001a      	movs	r2, r3
 800f238:	2303      	movs	r3, #3
 800f23a:	4013      	ands	r3, r2
 800f23c:	d012      	beq.n	800f264 <tcp_receive+0xa00>
 800f23e:	2301      	movs	r3, #1
 800f240:	e011      	b.n	800f266 <tcp_receive+0xa02>
 800f242:	46c0      	nop			; (mov r8, r8)
 800f244:	20000c6c 	.word	0x20000c6c
 800f248:	20000c48 	.word	0x20000c48
 800f24c:	20000c76 	.word	0x20000c76
 800f250:	ffffc0ff 	.word	0xffffc0ff
 800f254:	0802120c 	.word	0x0802120c
 800f258:	000005cc 	.word	0x000005cc
 800f25c:	080215ac 	.word	0x080215ac
 800f260:	0802124c 	.word	0x0802124c
 800f264:	2300      	movs	r3, #0
 800f266:	191b      	adds	r3, r3, r4
 800f268:	b29a      	uxth	r2, r3
 800f26a:	4bb9      	ldr	r3, [pc, #740]	; (800f550 <tcp_receive+0xcec>)
 800f26c:	801a      	strh	r2, [r3, #0]
              }
              tmp = next;
 800f26e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f270:	613b      	str	r3, [r7, #16]
              next = next->next;
 800f272:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f274:	681b      	ldr	r3, [r3, #0]
 800f276:	63fb      	str	r3, [r7, #60]	; 0x3c
              tcp_seg_free(tmp);
 800f278:	693b      	ldr	r3, [r7, #16]
 800f27a:	0018      	movs	r0, r3
 800f27c:	f7fd f98a 	bl	800c594 <tcp_seg_free>
            while (next &&
 800f280:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f282:	2b00      	cmp	r3, #0
 800f284:	d018      	beq.n	800f2b8 <tcp_receive+0xa54>
                   TCP_SEQ_GEQ(seqno + tcplen,
 800f286:	4bb2      	ldr	r3, [pc, #712]	; (800f550 <tcp_receive+0xcec>)
 800f288:	881b      	ldrh	r3, [r3, #0]
 800f28a:	001a      	movs	r2, r3
 800f28c:	4bb1      	ldr	r3, [pc, #708]	; (800f554 <tcp_receive+0xcf0>)
 800f28e:	681b      	ldr	r3, [r3, #0]
 800f290:	18d2      	adds	r2, r2, r3
 800f292:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f294:	691b      	ldr	r3, [r3, #16]
 800f296:	7919      	ldrb	r1, [r3, #4]
 800f298:	7958      	ldrb	r0, [r3, #5]
 800f29a:	0200      	lsls	r0, r0, #8
 800f29c:	4301      	orrs	r1, r0
 800f29e:	7998      	ldrb	r0, [r3, #6]
 800f2a0:	0400      	lsls	r0, r0, #16
 800f2a2:	4301      	orrs	r1, r0
 800f2a4:	79db      	ldrb	r3, [r3, #7]
 800f2a6:	061b      	lsls	r3, r3, #24
 800f2a8:	430b      	orrs	r3, r1
 800f2aa:	0019      	movs	r1, r3
 800f2ac:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f2ae:	891b      	ldrh	r3, [r3, #8]
 800f2b0:	18cb      	adds	r3, r1, r3
 800f2b2:	1ad3      	subs	r3, r2, r3
            while (next &&
 800f2b4:	d400      	bmi.n	800f2b8 <tcp_receive+0xa54>
 800f2b6:	e76d      	b.n	800f194 <tcp_receive+0x930>
            }
            /* Now trim right side of inseg if it overlaps with the first
             * segment on ooseq */
            if (next &&
 800f2b8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f2ba:	2b00      	cmp	r3, #0
 800f2bc:	d100      	bne.n	800f2c0 <tcp_receive+0xa5c>
 800f2be:	e079      	b.n	800f3b4 <tcp_receive+0xb50>
                TCP_SEQ_GT(seqno + tcplen,
 800f2c0:	4ba3      	ldr	r3, [pc, #652]	; (800f550 <tcp_receive+0xcec>)
 800f2c2:	881b      	ldrh	r3, [r3, #0]
 800f2c4:	001a      	movs	r2, r3
 800f2c6:	4ba3      	ldr	r3, [pc, #652]	; (800f554 <tcp_receive+0xcf0>)
 800f2c8:	681b      	ldr	r3, [r3, #0]
 800f2ca:	18d2      	adds	r2, r2, r3
 800f2cc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f2ce:	691b      	ldr	r3, [r3, #16]
 800f2d0:	7919      	ldrb	r1, [r3, #4]
 800f2d2:	7958      	ldrb	r0, [r3, #5]
 800f2d4:	0200      	lsls	r0, r0, #8
 800f2d6:	4301      	orrs	r1, r0
 800f2d8:	7998      	ldrb	r0, [r3, #6]
 800f2da:	0400      	lsls	r0, r0, #16
 800f2dc:	4301      	orrs	r1, r0
 800f2de:	79db      	ldrb	r3, [r3, #7]
 800f2e0:	061b      	lsls	r3, r3, #24
 800f2e2:	430b      	orrs	r3, r1
 800f2e4:	1ad3      	subs	r3, r2, r3
            if (next &&
 800f2e6:	2b00      	cmp	r3, #0
 800f2e8:	dd64      	ble.n	800f3b4 <tcp_receive+0xb50>
                           next->tcphdr->seqno)) {
              /* inseg cannot have FIN here (already processed above) */
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
 800f2ea:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f2ec:	691b      	ldr	r3, [r3, #16]
 800f2ee:	791a      	ldrb	r2, [r3, #4]
 800f2f0:	7959      	ldrb	r1, [r3, #5]
 800f2f2:	0209      	lsls	r1, r1, #8
 800f2f4:	430a      	orrs	r2, r1
 800f2f6:	7999      	ldrb	r1, [r3, #6]
 800f2f8:	0409      	lsls	r1, r1, #16
 800f2fa:	430a      	orrs	r2, r1
 800f2fc:	79db      	ldrb	r3, [r3, #7]
 800f2fe:	061b      	lsls	r3, r3, #24
 800f300:	4313      	orrs	r3, r2
 800f302:	b29a      	uxth	r2, r3
 800f304:	4b93      	ldr	r3, [pc, #588]	; (800f554 <tcp_receive+0xcf0>)
 800f306:	681b      	ldr	r3, [r3, #0]
 800f308:	b29b      	uxth	r3, r3
 800f30a:	1ad3      	subs	r3, r2, r3
 800f30c:	b29a      	uxth	r2, r3
 800f30e:	4b92      	ldr	r3, [pc, #584]	; (800f558 <tcp_receive+0xcf4>)
 800f310:	811a      	strh	r2, [r3, #8]
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 800f312:	4b91      	ldr	r3, [pc, #580]	; (800f558 <tcp_receive+0xcf4>)
 800f314:	691b      	ldr	r3, [r3, #16]
 800f316:	7b1a      	ldrb	r2, [r3, #12]
 800f318:	7b5b      	ldrb	r3, [r3, #13]
 800f31a:	021b      	lsls	r3, r3, #8
 800f31c:	4313      	orrs	r3, r2
 800f31e:	b29b      	uxth	r3, r3
 800f320:	0018      	movs	r0, r3
 800f322:	f7f8 f86d 	bl	8007400 <lwip_htons>
 800f326:	0003      	movs	r3, r0
 800f328:	b2db      	uxtb	r3, r3
 800f32a:	001a      	movs	r2, r3
 800f32c:	2302      	movs	r3, #2
 800f32e:	4013      	ands	r3, r2
 800f330:	d005      	beq.n	800f33e <tcp_receive+0xada>
                inseg.len -= 1;
 800f332:	4b89      	ldr	r3, [pc, #548]	; (800f558 <tcp_receive+0xcf4>)
 800f334:	891b      	ldrh	r3, [r3, #8]
 800f336:	3b01      	subs	r3, #1
 800f338:	b29a      	uxth	r2, r3
 800f33a:	4b87      	ldr	r3, [pc, #540]	; (800f558 <tcp_receive+0xcf4>)
 800f33c:	811a      	strh	r2, [r3, #8]
              }
              pbuf_realloc(inseg.p, inseg.len);
 800f33e:	4b86      	ldr	r3, [pc, #536]	; (800f558 <tcp_receive+0xcf4>)
 800f340:	685a      	ldr	r2, [r3, #4]
 800f342:	4b85      	ldr	r3, [pc, #532]	; (800f558 <tcp_receive+0xcf4>)
 800f344:	891b      	ldrh	r3, [r3, #8]
 800f346:	0019      	movs	r1, r3
 800f348:	0010      	movs	r0, r2
 800f34a:	f7fa ff0f 	bl	800a16c <pbuf_realloc>
              tcplen = TCP_TCPLEN(&inseg);
 800f34e:	4b82      	ldr	r3, [pc, #520]	; (800f558 <tcp_receive+0xcf4>)
 800f350:	891c      	ldrh	r4, [r3, #8]
 800f352:	4b81      	ldr	r3, [pc, #516]	; (800f558 <tcp_receive+0xcf4>)
 800f354:	691b      	ldr	r3, [r3, #16]
 800f356:	7b1a      	ldrb	r2, [r3, #12]
 800f358:	7b5b      	ldrb	r3, [r3, #13]
 800f35a:	021b      	lsls	r3, r3, #8
 800f35c:	4313      	orrs	r3, r2
 800f35e:	b29b      	uxth	r3, r3
 800f360:	0018      	movs	r0, r3
 800f362:	f7f8 f84d 	bl	8007400 <lwip_htons>
 800f366:	0003      	movs	r3, r0
 800f368:	b2db      	uxtb	r3, r3
 800f36a:	001a      	movs	r2, r3
 800f36c:	2303      	movs	r3, #3
 800f36e:	4013      	ands	r3, r2
 800f370:	d001      	beq.n	800f376 <tcp_receive+0xb12>
 800f372:	2301      	movs	r3, #1
 800f374:	e000      	b.n	800f378 <tcp_receive+0xb14>
 800f376:	2300      	movs	r3, #0
 800f378:	191b      	adds	r3, r3, r4
 800f37a:	b29a      	uxth	r2, r3
 800f37c:	4b74      	ldr	r3, [pc, #464]	; (800f550 <tcp_receive+0xcec>)
 800f37e:	801a      	strh	r2, [r3, #0]
              LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
 800f380:	4b73      	ldr	r3, [pc, #460]	; (800f550 <tcp_receive+0xcec>)
 800f382:	881b      	ldrh	r3, [r3, #0]
 800f384:	001a      	movs	r2, r3
 800f386:	4b73      	ldr	r3, [pc, #460]	; (800f554 <tcp_receive+0xcf0>)
 800f388:	681b      	ldr	r3, [r3, #0]
 800f38a:	18d2      	adds	r2, r2, r3
 800f38c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f38e:	691b      	ldr	r3, [r3, #16]
 800f390:	7919      	ldrb	r1, [r3, #4]
 800f392:	7958      	ldrb	r0, [r3, #5]
 800f394:	0200      	lsls	r0, r0, #8
 800f396:	4301      	orrs	r1, r0
 800f398:	7998      	ldrb	r0, [r3, #6]
 800f39a:	0400      	lsls	r0, r0, #16
 800f39c:	4301      	orrs	r1, r0
 800f39e:	79db      	ldrb	r3, [r3, #7]
 800f3a0:	061b      	lsls	r3, r3, #24
 800f3a2:	430b      	orrs	r3, r1
 800f3a4:	429a      	cmp	r2, r3
 800f3a6:	d005      	beq.n	800f3b4 <tcp_receive+0xb50>
 800f3a8:	4b6c      	ldr	r3, [pc, #432]	; (800f55c <tcp_receive+0xcf8>)
 800f3aa:	4a6d      	ldr	r2, [pc, #436]	; (800f560 <tcp_receive+0xcfc>)
 800f3ac:	496d      	ldr	r1, [pc, #436]	; (800f564 <tcp_receive+0xd00>)
 800f3ae:	486e      	ldr	r0, [pc, #440]	; (800f568 <tcp_receive+0xd04>)
 800f3b0:	f7f2 ff18 	bl	80021e4 <app_debug_rtt_raw>
                          (seqno + tcplen) == next->tcphdr->seqno);
            }
            pcb->ooseq = next;
 800f3b4:	687b      	ldr	r3, [r7, #4]
 800f3b6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800f3b8:	679a      	str	r2, [r3, #120]	; 0x78
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;
 800f3ba:	4b65      	ldr	r3, [pc, #404]	; (800f550 <tcp_receive+0xcec>)
 800f3bc:	881b      	ldrh	r3, [r3, #0]
 800f3be:	001a      	movs	r2, r3
 800f3c0:	4b64      	ldr	r3, [pc, #400]	; (800f554 <tcp_receive+0xcf0>)
 800f3c2:	681b      	ldr	r3, [r3, #0]
 800f3c4:	18d2      	adds	r2, r2, r3
 800f3c6:	687b      	ldr	r3, [r7, #4]
 800f3c8:	629a      	str	r2, [r3, #40]	; 0x28

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
 800f3ca:	687b      	ldr	r3, [r7, #4]
 800f3cc:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800f3ce:	4b60      	ldr	r3, [pc, #384]	; (800f550 <tcp_receive+0xcec>)
 800f3d0:	881b      	ldrh	r3, [r3, #0]
 800f3d2:	429a      	cmp	r2, r3
 800f3d4:	d206      	bcs.n	800f3e4 <tcp_receive+0xb80>
 800f3d6:	4b61      	ldr	r3, [pc, #388]	; (800f55c <tcp_receive+0xcf8>)
 800f3d8:	22c1      	movs	r2, #193	; 0xc1
 800f3da:	00d2      	lsls	r2, r2, #3
 800f3dc:	4963      	ldr	r1, [pc, #396]	; (800f56c <tcp_receive+0xd08>)
 800f3de:	4862      	ldr	r0, [pc, #392]	; (800f568 <tcp_receive+0xd04>)
 800f3e0:	f7f2 ff00 	bl	80021e4 <app_debug_rtt_raw>
        pcb->rcv_wnd -= tcplen;
 800f3e4:	687b      	ldr	r3, [r7, #4]
 800f3e6:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800f3e8:	4b59      	ldr	r3, [pc, #356]	; (800f550 <tcp_receive+0xcec>)
 800f3ea:	881b      	ldrh	r3, [r3, #0]
 800f3ec:	1ad3      	subs	r3, r2, r3
 800f3ee:	b29a      	uxth	r2, r3
 800f3f0:	687b      	ldr	r3, [r7, #4]
 800f3f2:	859a      	strh	r2, [r3, #44]	; 0x2c

        tcp_update_rcv_ann_wnd(pcb);
 800f3f4:	687b      	ldr	r3, [r7, #4]
 800f3f6:	0018      	movs	r0, r3
 800f3f8:	f7fc f9da 	bl	800b7b0 <tcp_update_rcv_ann_wnd>
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
 800f3fc:	4b56      	ldr	r3, [pc, #344]	; (800f558 <tcp_receive+0xcf4>)
 800f3fe:	685b      	ldr	r3, [r3, #4]
 800f400:	891b      	ldrh	r3, [r3, #8]
 800f402:	2b00      	cmp	r3, #0
 800f404:	d006      	beq.n	800f414 <tcp_receive+0xbb0>
          recv_data = inseg.p;
 800f406:	4b54      	ldr	r3, [pc, #336]	; (800f558 <tcp_receive+0xcf4>)
 800f408:	685a      	ldr	r2, [r3, #4]
 800f40a:	4b59      	ldr	r3, [pc, #356]	; (800f570 <tcp_receive+0xd0c>)
 800f40c:	601a      	str	r2, [r3, #0]
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
 800f40e:	4b52      	ldr	r3, [pc, #328]	; (800f558 <tcp_receive+0xcf4>)
 800f410:	2200      	movs	r2, #0
 800f412:	605a      	str	r2, [r3, #4]
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 800f414:	4b50      	ldr	r3, [pc, #320]	; (800f558 <tcp_receive+0xcf4>)
 800f416:	691b      	ldr	r3, [r3, #16]
 800f418:	7b1a      	ldrb	r2, [r3, #12]
 800f41a:	7b5b      	ldrb	r3, [r3, #13]
 800f41c:	021b      	lsls	r3, r3, #8
 800f41e:	4313      	orrs	r3, r2
 800f420:	b29b      	uxth	r3, r3
 800f422:	0018      	movs	r0, r3
 800f424:	f7f7 ffec 	bl	8007400 <lwip_htons>
 800f428:	0003      	movs	r3, r0
 800f42a:	b2db      	uxtb	r3, r3
 800f42c:	001a      	movs	r2, r3
 800f42e:	2301      	movs	r3, #1
 800f430:	4013      	ands	r3, r2
 800f432:	d100      	bne.n	800f436 <tcp_receive+0xbd2>
 800f434:	e0d1      	b.n	800f5da <tcp_receive+0xd76>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags |= TF_GOT_FIN;
 800f436:	4b4f      	ldr	r3, [pc, #316]	; (800f574 <tcp_receive+0xd10>)
 800f438:	781b      	ldrb	r3, [r3, #0]
 800f43a:	2220      	movs	r2, #32
 800f43c:	4313      	orrs	r3, r2
 800f43e:	b2da      	uxtb	r2, r3
 800f440:	4b4c      	ldr	r3, [pc, #304]	; (800f574 <tcp_receive+0xd10>)
 800f442:	701a      	strb	r2, [r3, #0]
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
 800f444:	e0c9      	b.n	800f5da <tcp_receive+0xd76>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          struct tcp_seg *cseg = pcb->ooseq;
 800f446:	687b      	ldr	r3, [r7, #4]
 800f448:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800f44a:	60bb      	str	r3, [r7, #8]
          seqno = pcb->ooseq->tcphdr->seqno;
 800f44c:	687b      	ldr	r3, [r7, #4]
 800f44e:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800f450:	691b      	ldr	r3, [r3, #16]
 800f452:	791a      	ldrb	r2, [r3, #4]
 800f454:	7959      	ldrb	r1, [r3, #5]
 800f456:	0209      	lsls	r1, r1, #8
 800f458:	430a      	orrs	r2, r1
 800f45a:	7999      	ldrb	r1, [r3, #6]
 800f45c:	0409      	lsls	r1, r1, #16
 800f45e:	430a      	orrs	r2, r1
 800f460:	79db      	ldrb	r3, [r3, #7]
 800f462:	061b      	lsls	r3, r3, #24
 800f464:	4313      	orrs	r3, r2
 800f466:	001a      	movs	r2, r3
 800f468:	4b3a      	ldr	r3, [pc, #232]	; (800f554 <tcp_receive+0xcf0>)
 800f46a:	601a      	str	r2, [r3, #0]

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
 800f46c:	68bb      	ldr	r3, [r7, #8]
 800f46e:	891b      	ldrh	r3, [r3, #8]
 800f470:	001c      	movs	r4, r3
 800f472:	68bb      	ldr	r3, [r7, #8]
 800f474:	691b      	ldr	r3, [r3, #16]
 800f476:	7b1a      	ldrb	r2, [r3, #12]
 800f478:	7b5b      	ldrb	r3, [r3, #13]
 800f47a:	021b      	lsls	r3, r3, #8
 800f47c:	4313      	orrs	r3, r2
 800f47e:	b29b      	uxth	r3, r3
 800f480:	0018      	movs	r0, r3
 800f482:	f7f7 ffbd 	bl	8007400 <lwip_htons>
 800f486:	0003      	movs	r3, r0
 800f488:	b2db      	uxtb	r3, r3
 800f48a:	001a      	movs	r2, r3
 800f48c:	2303      	movs	r3, #3
 800f48e:	4013      	ands	r3, r2
 800f490:	d001      	beq.n	800f496 <tcp_receive+0xc32>
 800f492:	2301      	movs	r3, #1
 800f494:	e000      	b.n	800f498 <tcp_receive+0xc34>
 800f496:	2300      	movs	r3, #0
 800f498:	191a      	adds	r2, r3, r4
 800f49a:	687b      	ldr	r3, [r7, #4]
 800f49c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800f49e:	18d2      	adds	r2, r2, r3
 800f4a0:	687b      	ldr	r3, [r7, #4]
 800f4a2:	629a      	str	r2, [r3, #40]	; 0x28
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
 800f4a4:	687b      	ldr	r3, [r7, #4]
 800f4a6:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 800f4a8:	001c      	movs	r4, r3
 800f4aa:	68bb      	ldr	r3, [r7, #8]
 800f4ac:	891b      	ldrh	r3, [r3, #8]
 800f4ae:	001d      	movs	r5, r3
 800f4b0:	68bb      	ldr	r3, [r7, #8]
 800f4b2:	691b      	ldr	r3, [r3, #16]
 800f4b4:	7b1a      	ldrb	r2, [r3, #12]
 800f4b6:	7b5b      	ldrb	r3, [r3, #13]
 800f4b8:	021b      	lsls	r3, r3, #8
 800f4ba:	4313      	orrs	r3, r2
 800f4bc:	b29b      	uxth	r3, r3
 800f4be:	0018      	movs	r0, r3
 800f4c0:	f7f7 ff9e 	bl	8007400 <lwip_htons>
 800f4c4:	0003      	movs	r3, r0
 800f4c6:	b2db      	uxtb	r3, r3
 800f4c8:	001a      	movs	r2, r3
 800f4ca:	2303      	movs	r3, #3
 800f4cc:	4013      	ands	r3, r2
 800f4ce:	d001      	beq.n	800f4d4 <tcp_receive+0xc70>
 800f4d0:	2301      	movs	r3, #1
 800f4d2:	e000      	b.n	800f4d6 <tcp_receive+0xc72>
 800f4d4:	2300      	movs	r3, #0
 800f4d6:	195b      	adds	r3, r3, r5
 800f4d8:	429c      	cmp	r4, r3
 800f4da:	d205      	bcs.n	800f4e8 <tcp_receive+0xc84>
 800f4dc:	4b1f      	ldr	r3, [pc, #124]	; (800f55c <tcp_receive+0xcf8>)
 800f4de:	4a26      	ldr	r2, [pc, #152]	; (800f578 <tcp_receive+0xd14>)
 800f4e0:	4926      	ldr	r1, [pc, #152]	; (800f57c <tcp_receive+0xd18>)
 800f4e2:	4821      	ldr	r0, [pc, #132]	; (800f568 <tcp_receive+0xd04>)
 800f4e4:	f7f2 fe7e 	bl	80021e4 <app_debug_rtt_raw>
                      pcb->rcv_wnd >= TCP_TCPLEN(cseg));
          pcb->rcv_wnd -= TCP_TCPLEN(cseg);
 800f4e8:	68bb      	ldr	r3, [r7, #8]
 800f4ea:	891b      	ldrh	r3, [r3, #8]
 800f4ec:	001c      	movs	r4, r3
 800f4ee:	68bb      	ldr	r3, [r7, #8]
 800f4f0:	691b      	ldr	r3, [r3, #16]
 800f4f2:	7b1a      	ldrb	r2, [r3, #12]
 800f4f4:	7b5b      	ldrb	r3, [r3, #13]
 800f4f6:	021b      	lsls	r3, r3, #8
 800f4f8:	4313      	orrs	r3, r2
 800f4fa:	b29b      	uxth	r3, r3
 800f4fc:	0018      	movs	r0, r3
 800f4fe:	f7f7 ff7f 	bl	8007400 <lwip_htons>
 800f502:	0003      	movs	r3, r0
 800f504:	b2db      	uxtb	r3, r3
 800f506:	001a      	movs	r2, r3
 800f508:	2303      	movs	r3, #3
 800f50a:	4013      	ands	r3, r2
 800f50c:	d001      	beq.n	800f512 <tcp_receive+0xcae>
 800f50e:	2301      	movs	r3, #1
 800f510:	e000      	b.n	800f514 <tcp_receive+0xcb0>
 800f512:	2300      	movs	r3, #0
 800f514:	1919      	adds	r1, r3, r4
 800f516:	687b      	ldr	r3, [r7, #4]
 800f518:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800f51a:	b28b      	uxth	r3, r1
 800f51c:	1ad3      	subs	r3, r2, r3
 800f51e:	b29a      	uxth	r2, r3
 800f520:	687b      	ldr	r3, [r7, #4]
 800f522:	859a      	strh	r2, [r3, #44]	; 0x2c

          tcp_update_rcv_ann_wnd(pcb);
 800f524:	687b      	ldr	r3, [r7, #4]
 800f526:	0018      	movs	r0, r3
 800f528:	f7fc f942 	bl	800b7b0 <tcp_update_rcv_ann_wnd>

          if (cseg->p->tot_len > 0) {
 800f52c:	68bb      	ldr	r3, [r7, #8]
 800f52e:	685b      	ldr	r3, [r3, #4]
 800f530:	891b      	ldrh	r3, [r3, #8]
 800f532:	2b00      	cmp	r3, #0
 800f534:	d02b      	beq.n	800f58e <tcp_receive+0xd2a>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            /* With window scaling, this can overflow recv_data->tot_len, but
               that's not a problem since we explicitly fix that before passing
               recv_data to the application. */
            if (recv_data) {
 800f536:	4b0e      	ldr	r3, [pc, #56]	; (800f570 <tcp_receive+0xd0c>)
 800f538:	681b      	ldr	r3, [r3, #0]
 800f53a:	2b00      	cmp	r3, #0
 800f53c:	d020      	beq.n	800f580 <tcp_receive+0xd1c>
              pbuf_cat(recv_data, cseg->p);
 800f53e:	4b0c      	ldr	r3, [pc, #48]	; (800f570 <tcp_receive+0xd0c>)
 800f540:	681a      	ldr	r2, [r3, #0]
 800f542:	68bb      	ldr	r3, [r7, #8]
 800f544:	685b      	ldr	r3, [r3, #4]
 800f546:	0019      	movs	r1, r3
 800f548:	0010      	movs	r0, r2
 800f54a:	f7fb f8a7 	bl	800a69c <pbuf_cat>
 800f54e:	e01b      	b.n	800f588 <tcp_receive+0xd24>
 800f550:	20000c76 	.word	0x20000c76
 800f554:	20000c6c 	.word	0x20000c6c
 800f558:	20000c48 	.word	0x20000c48
 800f55c:	0802120c 	.word	0x0802120c
 800f560:	000005fd 	.word	0x000005fd
 800f564:	080215e4 	.word	0x080215e4
 800f568:	0802124c 	.word	0x0802124c
 800f56c:	08021620 	.word	0x08021620
 800f570:	20000c7c 	.word	0x20000c7c
 800f574:	20000c79 	.word	0x20000c79
 800f578:	0000062c 	.word	0x0000062c
 800f57c:	08021640 	.word	0x08021640
            } else {
              recv_data = cseg->p;
 800f580:	68bb      	ldr	r3, [r7, #8]
 800f582:	685a      	ldr	r2, [r3, #4]
 800f584:	4b9a      	ldr	r3, [pc, #616]	; (800f7f0 <tcp_receive+0xf8c>)
 800f586:	601a      	str	r2, [r3, #0]
            }
            cseg->p = NULL;
 800f588:	68bb      	ldr	r3, [r7, #8]
 800f58a:	2200      	movs	r2, #0
 800f58c:	605a      	str	r2, [r3, #4]
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 800f58e:	68bb      	ldr	r3, [r7, #8]
 800f590:	691b      	ldr	r3, [r3, #16]
 800f592:	7b1a      	ldrb	r2, [r3, #12]
 800f594:	7b5b      	ldrb	r3, [r3, #13]
 800f596:	021b      	lsls	r3, r3, #8
 800f598:	4313      	orrs	r3, r2
 800f59a:	b29b      	uxth	r3, r3
 800f59c:	0018      	movs	r0, r3
 800f59e:	f7f7 ff2f 	bl	8007400 <lwip_htons>
 800f5a2:	0003      	movs	r3, r0
 800f5a4:	b2db      	uxtb	r3, r3
 800f5a6:	001a      	movs	r2, r3
 800f5a8:	2301      	movs	r3, #1
 800f5aa:	4013      	ands	r3, r2
 800f5ac:	d00d      	beq.n	800f5ca <tcp_receive+0xd66>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags |= TF_GOT_FIN;
 800f5ae:	4b91      	ldr	r3, [pc, #580]	; (800f7f4 <tcp_receive+0xf90>)
 800f5b0:	781b      	ldrb	r3, [r3, #0]
 800f5b2:	2220      	movs	r2, #32
 800f5b4:	4313      	orrs	r3, r2
 800f5b6:	b2da      	uxtb	r2, r3
 800f5b8:	4b8e      	ldr	r3, [pc, #568]	; (800f7f4 <tcp_receive+0xf90>)
 800f5ba:	701a      	strb	r2, [r3, #0]
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
 800f5bc:	687b      	ldr	r3, [r7, #4]
 800f5be:	7e1b      	ldrb	r3, [r3, #24]
 800f5c0:	2b04      	cmp	r3, #4
 800f5c2:	d102      	bne.n	800f5ca <tcp_receive+0xd66>
              pcb->state = CLOSE_WAIT;
 800f5c4:	687b      	ldr	r3, [r7, #4]
 800f5c6:	2207      	movs	r2, #7
 800f5c8:	761a      	strb	r2, [r3, #24]
            }
          }

          pcb->ooseq = cseg->next;
 800f5ca:	68bb      	ldr	r3, [r7, #8]
 800f5cc:	681a      	ldr	r2, [r3, #0]
 800f5ce:	687b      	ldr	r3, [r7, #4]
 800f5d0:	679a      	str	r2, [r3, #120]	; 0x78
          tcp_seg_free(cseg);
 800f5d2:	68bb      	ldr	r3, [r7, #8]
 800f5d4:	0018      	movs	r0, r3
 800f5d6:	f7fc ffdd 	bl	800c594 <tcp_seg_free>
        while (pcb->ooseq != NULL &&
 800f5da:	687b      	ldr	r3, [r7, #4]
 800f5dc:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800f5de:	2b00      	cmp	r3, #0
 800f5e0:	d012      	beq.n	800f608 <tcp_receive+0xda4>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
 800f5e2:	687b      	ldr	r3, [r7, #4]
 800f5e4:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800f5e6:	691b      	ldr	r3, [r3, #16]
 800f5e8:	791a      	ldrb	r2, [r3, #4]
 800f5ea:	7959      	ldrb	r1, [r3, #5]
 800f5ec:	0209      	lsls	r1, r1, #8
 800f5ee:	430a      	orrs	r2, r1
 800f5f0:	7999      	ldrb	r1, [r3, #6]
 800f5f2:	0409      	lsls	r1, r1, #16
 800f5f4:	430a      	orrs	r2, r1
 800f5f6:	79db      	ldrb	r3, [r3, #7]
 800f5f8:	061b      	lsls	r3, r3, #24
 800f5fa:	4313      	orrs	r3, r2
 800f5fc:	001a      	movs	r2, r3
 800f5fe:	687b      	ldr	r3, [r7, #4]
 800f600:	6a9b      	ldr	r3, [r3, #40]	; 0x28
        while (pcb->ooseq != NULL &&
 800f602:	429a      	cmp	r2, r3
 800f604:	d100      	bne.n	800f608 <tcp_receive+0xda4>
 800f606:	e71e      	b.n	800f446 <tcp_receive+0xbe2>
#endif /* LWIP_TCP_SACK_OUT */
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
 800f608:	687b      	ldr	r3, [r7, #4]
 800f60a:	8bdb      	ldrh	r3, [r3, #30]
 800f60c:	001a      	movs	r2, r3
 800f60e:	2301      	movs	r3, #1
 800f610:	4013      	ands	r3, r2
 800f612:	d00e      	beq.n	800f632 <tcp_receive+0xdce>
 800f614:	687b      	ldr	r3, [r7, #4]
 800f616:	8bdb      	ldrh	r3, [r3, #30]
 800f618:	2201      	movs	r2, #1
 800f61a:	4393      	bics	r3, r2
 800f61c:	b29a      	uxth	r2, r3
 800f61e:	687b      	ldr	r3, [r7, #4]
 800f620:	83da      	strh	r2, [r3, #30]
 800f622:	687b      	ldr	r3, [r7, #4]
 800f624:	8bdb      	ldrh	r3, [r3, #30]
 800f626:	2202      	movs	r2, #2
 800f628:	4313      	orrs	r3, r2
 800f62a:	b29a      	uxth	r2, r3
 800f62c:	687b      	ldr	r3, [r7, #4]
 800f62e:	83da      	strh	r2, [r3, #30]
      if (pcb->rcv_nxt == seqno) {
 800f630:	e20d      	b.n	800fa4e <tcp_receive+0x11ea>
        tcp_ack(pcb);
 800f632:	687b      	ldr	r3, [r7, #4]
 800f634:	8bdb      	ldrh	r3, [r3, #30]
 800f636:	2201      	movs	r2, #1
 800f638:	4313      	orrs	r3, r2
 800f63a:	b29a      	uxth	r2, r3
 800f63c:	687b      	ldr	r3, [r7, #4]
 800f63e:	83da      	strh	r2, [r3, #30]
      if (pcb->rcv_nxt == seqno) {
 800f640:	e205      	b.n	800fa4e <tcp_receive+0x11ea>
      } else {
        /* We get here if the incoming segment is out-of-sequence. */

#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
 800f642:	687b      	ldr	r3, [r7, #4]
 800f644:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800f646:	2b00      	cmp	r3, #0
 800f648:	d107      	bne.n	800f65a <tcp_receive+0xdf6>
          pcb->ooseq = tcp_seg_copy(&inseg);
 800f64a:	4b6b      	ldr	r3, [pc, #428]	; (800f7f8 <tcp_receive+0xf94>)
 800f64c:	0018      	movs	r0, r3
 800f64e:	f7fc ffbb 	bl	800c5c8 <tcp_seg_copy>
 800f652:	0002      	movs	r2, r0
 800f654:	687b      	ldr	r3, [r7, #4]
 800f656:	679a      	str	r2, [r3, #120]	; 0x78
 800f658:	e1ef      	b.n	800fa3a <tcp_receive+0x11d6>
#if LWIP_TCP_SACK_OUT
          /* This is the left edge of the lowest possible SACK range.
             It may start before the newly received segment (possibly adjusted below). */
          u32_t sackbeg = TCP_SEQ_LT(seqno, pcb->ooseq->tcphdr->seqno) ? seqno : pcb->ooseq->tcphdr->seqno;
#endif /* LWIP_TCP_SACK_OUT */
          struct tcp_seg *next, *prev = NULL;
 800f65a:	2300      	movs	r3, #0
 800f65c:	637b      	str	r3, [r7, #52]	; 0x34
          for (next = pcb->ooseq; next != NULL; next = next->next) {
 800f65e:	687b      	ldr	r3, [r7, #4]
 800f660:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800f662:	63bb      	str	r3, [r7, #56]	; 0x38
 800f664:	e1d9      	b.n	800fa1a <tcp_receive+0x11b6>
            if (seqno == next->tcphdr->seqno) {
 800f666:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f668:	691b      	ldr	r3, [r3, #16]
 800f66a:	791a      	ldrb	r2, [r3, #4]
 800f66c:	7959      	ldrb	r1, [r3, #5]
 800f66e:	0209      	lsls	r1, r1, #8
 800f670:	430a      	orrs	r2, r1
 800f672:	7999      	ldrb	r1, [r3, #6]
 800f674:	0409      	lsls	r1, r1, #16
 800f676:	430a      	orrs	r2, r1
 800f678:	79db      	ldrb	r3, [r3, #7]
 800f67a:	061b      	lsls	r3, r3, #24
 800f67c:	4313      	orrs	r3, r2
 800f67e:	001a      	movs	r2, r3
 800f680:	4b5e      	ldr	r3, [pc, #376]	; (800f7fc <tcp_receive+0xf98>)
 800f682:	681b      	ldr	r3, [r3, #0]
 800f684:	429a      	cmp	r2, r3
 800f686:	d121      	bne.n	800f6cc <tcp_receive+0xe68>
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
 800f688:	4b5b      	ldr	r3, [pc, #364]	; (800f7f8 <tcp_receive+0xf94>)
 800f68a:	891a      	ldrh	r2, [r3, #8]
 800f68c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f68e:	891b      	ldrh	r3, [r3, #8]
 800f690:	429a      	cmp	r2, r3
 800f692:	d800      	bhi.n	800f696 <tcp_receive+0xe32>
 800f694:	e1c6      	b.n	800fa24 <tcp_receive+0x11c0>
                /* The incoming segment is larger than the old
                   segment. We replace some segments with the new
                   one. */
                struct tcp_seg *cseg = tcp_seg_copy(&inseg);
 800f696:	4b58      	ldr	r3, [pc, #352]	; (800f7f8 <tcp_receive+0xf94>)
 800f698:	0018      	movs	r0, r3
 800f69a:	f7fc ff95 	bl	800c5c8 <tcp_seg_copy>
 800f69e:	0003      	movs	r3, r0
 800f6a0:	617b      	str	r3, [r7, #20]
                if (cseg != NULL) {
 800f6a2:	697b      	ldr	r3, [r7, #20]
 800f6a4:	2b00      	cmp	r3, #0
 800f6a6:	d100      	bne.n	800f6aa <tcp_receive+0xe46>
 800f6a8:	e1be      	b.n	800fa28 <tcp_receive+0x11c4>
                  if (prev != NULL) {
 800f6aa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f6ac:	2b00      	cmp	r3, #0
 800f6ae:	d003      	beq.n	800f6b8 <tcp_receive+0xe54>
                    prev->next = cseg;
 800f6b0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f6b2:	697a      	ldr	r2, [r7, #20]
 800f6b4:	601a      	str	r2, [r3, #0]
 800f6b6:	e002      	b.n	800f6be <tcp_receive+0xe5a>
                  } else {
                    pcb->ooseq = cseg;
 800f6b8:	687b      	ldr	r3, [r7, #4]
 800f6ba:	697a      	ldr	r2, [r7, #20]
 800f6bc:	679a      	str	r2, [r3, #120]	; 0x78
                  }
                  tcp_oos_insert_segment(cseg, next);
 800f6be:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800f6c0:	697b      	ldr	r3, [r7, #20]
 800f6c2:	0011      	movs	r1, r2
 800f6c4:	0018      	movs	r0, r3
 800f6c6:	f7fe ff7d 	bl	800e5c4 <tcp_oos_insert_segment>
                }
                break;
 800f6ca:	e1ad      	b.n	800fa28 <tcp_receive+0x11c4>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
 800f6cc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f6ce:	2b00      	cmp	r3, #0
 800f6d0:	d124      	bne.n	800f71c <tcp_receive+0xeb8>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
 800f6d2:	4b4a      	ldr	r3, [pc, #296]	; (800f7fc <tcp_receive+0xf98>)
 800f6d4:	681a      	ldr	r2, [r3, #0]
 800f6d6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f6d8:	691b      	ldr	r3, [r3, #16]
 800f6da:	7919      	ldrb	r1, [r3, #4]
 800f6dc:	7958      	ldrb	r0, [r3, #5]
 800f6de:	0200      	lsls	r0, r0, #8
 800f6e0:	4301      	orrs	r1, r0
 800f6e2:	7998      	ldrb	r0, [r3, #6]
 800f6e4:	0400      	lsls	r0, r0, #16
 800f6e6:	4301      	orrs	r1, r0
 800f6e8:	79db      	ldrb	r3, [r3, #7]
 800f6ea:	061b      	lsls	r3, r3, #24
 800f6ec:	430b      	orrs	r3, r1
 800f6ee:	1ad3      	subs	r3, r2, r3
 800f6f0:	d400      	bmi.n	800f6f4 <tcp_receive+0xe90>
 800f6f2:	e085      	b.n	800f800 <tcp_receive+0xf9c>
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */
                  struct tcp_seg *cseg = tcp_seg_copy(&inseg);
 800f6f4:	4b40      	ldr	r3, [pc, #256]	; (800f7f8 <tcp_receive+0xf94>)
 800f6f6:	0018      	movs	r0, r3
 800f6f8:	f7fc ff66 	bl	800c5c8 <tcp_seg_copy>
 800f6fc:	0003      	movs	r3, r0
 800f6fe:	61bb      	str	r3, [r7, #24]
                  if (cseg != NULL) {
 800f700:	69bb      	ldr	r3, [r7, #24]
 800f702:	2b00      	cmp	r3, #0
 800f704:	d100      	bne.n	800f708 <tcp_receive+0xea4>
 800f706:	e191      	b.n	800fa2c <tcp_receive+0x11c8>
                    pcb->ooseq = cseg;
 800f708:	687b      	ldr	r3, [r7, #4]
 800f70a:	69ba      	ldr	r2, [r7, #24]
 800f70c:	679a      	str	r2, [r3, #120]	; 0x78
                    tcp_oos_insert_segment(cseg, next);
 800f70e:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800f710:	69bb      	ldr	r3, [r7, #24]
 800f712:	0011      	movs	r1, r2
 800f714:	0018      	movs	r0, r3
 800f716:	f7fe ff55 	bl	800e5c4 <tcp_oos_insert_segment>
                  }
                  break;
 800f71a:	e187      	b.n	800fa2c <tcp_receive+0x11c8>
                }
              } else {
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno + 1, next->tcphdr->seqno - 1)) {
 800f71c:	4b37      	ldr	r3, [pc, #220]	; (800f7fc <tcp_receive+0xf98>)
 800f71e:	681a      	ldr	r2, [r3, #0]
 800f720:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f722:	691b      	ldr	r3, [r3, #16]
 800f724:	7919      	ldrb	r1, [r3, #4]
 800f726:	7958      	ldrb	r0, [r3, #5]
 800f728:	0200      	lsls	r0, r0, #8
 800f72a:	4301      	orrs	r1, r0
 800f72c:	7998      	ldrb	r0, [r3, #6]
 800f72e:	0400      	lsls	r0, r0, #16
 800f730:	4301      	orrs	r1, r0
 800f732:	79db      	ldrb	r3, [r3, #7]
 800f734:	061b      	lsls	r3, r3, #24
 800f736:	430b      	orrs	r3, r1
 800f738:	1ad3      	subs	r3, r2, r3
 800f73a:	3b01      	subs	r3, #1
 800f73c:	2b00      	cmp	r3, #0
 800f73e:	db5f      	blt.n	800f800 <tcp_receive+0xf9c>
 800f740:	4b2e      	ldr	r3, [pc, #184]	; (800f7fc <tcp_receive+0xf98>)
 800f742:	681a      	ldr	r2, [r3, #0]
 800f744:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f746:	691b      	ldr	r3, [r3, #16]
 800f748:	7919      	ldrb	r1, [r3, #4]
 800f74a:	7958      	ldrb	r0, [r3, #5]
 800f74c:	0200      	lsls	r0, r0, #8
 800f74e:	4301      	orrs	r1, r0
 800f750:	7998      	ldrb	r0, [r3, #6]
 800f752:	0400      	lsls	r0, r0, #16
 800f754:	4301      	orrs	r1, r0
 800f756:	79db      	ldrb	r3, [r3, #7]
 800f758:	061b      	lsls	r3, r3, #24
 800f75a:	430b      	orrs	r3, r1
 800f75c:	1ad3      	subs	r3, r2, r3
 800f75e:	3301      	adds	r3, #1
 800f760:	2b00      	cmp	r3, #0
 800f762:	dc4d      	bgt.n	800f800 <tcp_receive+0xf9c>
                  /* The sequence number of the incoming segment is in
                     between the sequence numbers of the previous and
                     the next segment on ->ooseq. We trim trim the previous
                     segment, delete next segments that included in received segment
                     and trim received, if needed. */
                  struct tcp_seg *cseg = tcp_seg_copy(&inseg);
 800f764:	4b24      	ldr	r3, [pc, #144]	; (800f7f8 <tcp_receive+0xf94>)
 800f766:	0018      	movs	r0, r3
 800f768:	f7fc ff2e 	bl	800c5c8 <tcp_seg_copy>
 800f76c:	0003      	movs	r3, r0
 800f76e:	61fb      	str	r3, [r7, #28]
                  if (cseg != NULL) {
 800f770:	69fb      	ldr	r3, [r7, #28]
 800f772:	2b00      	cmp	r3, #0
 800f774:	d100      	bne.n	800f778 <tcp_receive+0xf14>
 800f776:	e15b      	b.n	800fa30 <tcp_receive+0x11cc>
                    if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
 800f778:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f77a:	691b      	ldr	r3, [r3, #16]
 800f77c:	791a      	ldrb	r2, [r3, #4]
 800f77e:	7959      	ldrb	r1, [r3, #5]
 800f780:	0209      	lsls	r1, r1, #8
 800f782:	430a      	orrs	r2, r1
 800f784:	7999      	ldrb	r1, [r3, #6]
 800f786:	0409      	lsls	r1, r1, #16
 800f788:	430a      	orrs	r2, r1
 800f78a:	79db      	ldrb	r3, [r3, #7]
 800f78c:	061b      	lsls	r3, r3, #24
 800f78e:	4313      	orrs	r3, r2
 800f790:	001a      	movs	r2, r3
 800f792:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f794:	891b      	ldrh	r3, [r3, #8]
 800f796:	18d2      	adds	r2, r2, r3
 800f798:	4b18      	ldr	r3, [pc, #96]	; (800f7fc <tcp_receive+0xf98>)
 800f79a:	681b      	ldr	r3, [r3, #0]
 800f79c:	1ad3      	subs	r3, r2, r3
 800f79e:	2b00      	cmp	r3, #0
 800f7a0:	dd1b      	ble.n	800f7da <tcp_receive+0xf76>
                      /* We need to trim the prev segment. */
                      prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
 800f7a2:	4b16      	ldr	r3, [pc, #88]	; (800f7fc <tcp_receive+0xf98>)
 800f7a4:	681b      	ldr	r3, [r3, #0]
 800f7a6:	b29a      	uxth	r2, r3
 800f7a8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f7aa:	691b      	ldr	r3, [r3, #16]
 800f7ac:	7919      	ldrb	r1, [r3, #4]
 800f7ae:	7958      	ldrb	r0, [r3, #5]
 800f7b0:	0200      	lsls	r0, r0, #8
 800f7b2:	4301      	orrs	r1, r0
 800f7b4:	7998      	ldrb	r0, [r3, #6]
 800f7b6:	0400      	lsls	r0, r0, #16
 800f7b8:	4301      	orrs	r1, r0
 800f7ba:	79db      	ldrb	r3, [r3, #7]
 800f7bc:	061b      	lsls	r3, r3, #24
 800f7be:	430b      	orrs	r3, r1
 800f7c0:	b29b      	uxth	r3, r3
 800f7c2:	1ad3      	subs	r3, r2, r3
 800f7c4:	b29a      	uxth	r2, r3
 800f7c6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f7c8:	811a      	strh	r2, [r3, #8]
                      pbuf_realloc(prev->p, prev->len);
 800f7ca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f7cc:	685a      	ldr	r2, [r3, #4]
 800f7ce:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f7d0:	891b      	ldrh	r3, [r3, #8]
 800f7d2:	0019      	movs	r1, r3
 800f7d4:	0010      	movs	r0, r2
 800f7d6:	f7fa fcc9 	bl	800a16c <pbuf_realloc>
                    }
                    prev->next = cseg;
 800f7da:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f7dc:	69fa      	ldr	r2, [r7, #28]
 800f7de:	601a      	str	r2, [r3, #0]
                    tcp_oos_insert_segment(cseg, next);
 800f7e0:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800f7e2:	69fb      	ldr	r3, [r7, #28]
 800f7e4:	0011      	movs	r1, r2
 800f7e6:	0018      	movs	r0, r3
 800f7e8:	f7fe feec 	bl	800e5c4 <tcp_oos_insert_segment>
                  }
                  break;
 800f7ec:	e120      	b.n	800fa30 <tcp_receive+0x11cc>
 800f7ee:	46c0      	nop			; (mov r8, r8)
 800f7f0:	20000c7c 	.word	0x20000c7c
 800f7f4:	20000c79 	.word	0x20000c79
 800f7f8:	20000c48 	.word	0x20000c48
 800f7fc:	20000c6c 	.word	0x20000c6c
#endif /* LWIP_TCP_SACK_OUT */

              /* We don't use 'prev' below, so let's set it to current 'next'.
                 This way even if we break the loop below, 'prev' will be pointing
                 at the segment right in front of the newly added one. */
              prev = next;
 800f800:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f802:	637b      	str	r3, [r7, #52]	; 0x34

              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
 800f804:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f806:	681b      	ldr	r3, [r3, #0]
 800f808:	2b00      	cmp	r3, #0
 800f80a:	d000      	beq.n	800f80e <tcp_receive+0xfaa>
 800f80c:	e102      	b.n	800fa14 <tcp_receive+0x11b0>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
 800f80e:	4b9f      	ldr	r3, [pc, #636]	; (800fa8c <tcp_receive+0x1228>)
 800f810:	681a      	ldr	r2, [r3, #0]
 800f812:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f814:	691b      	ldr	r3, [r3, #16]
 800f816:	7919      	ldrb	r1, [r3, #4]
 800f818:	7958      	ldrb	r0, [r3, #5]
 800f81a:	0200      	lsls	r0, r0, #8
 800f81c:	4301      	orrs	r1, r0
 800f81e:	7998      	ldrb	r0, [r3, #6]
 800f820:	0400      	lsls	r0, r0, #16
 800f822:	4301      	orrs	r1, r0
 800f824:	79db      	ldrb	r3, [r3, #7]
 800f826:	061b      	lsls	r3, r3, #24
 800f828:	430b      	orrs	r3, r1
 800f82a:	1ad3      	subs	r3, r2, r3
              if (next->next == NULL &&
 800f82c:	2b00      	cmp	r3, #0
 800f82e:	dc00      	bgt.n	800f832 <tcp_receive+0xfce>
 800f830:	e0f0      	b.n	800fa14 <tcp_receive+0x11b0>
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 800f832:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f834:	691b      	ldr	r3, [r3, #16]
 800f836:	7b1a      	ldrb	r2, [r3, #12]
 800f838:	7b5b      	ldrb	r3, [r3, #13]
 800f83a:	021b      	lsls	r3, r3, #8
 800f83c:	4313      	orrs	r3, r2
 800f83e:	b29b      	uxth	r3, r3
 800f840:	0018      	movs	r0, r3
 800f842:	f7f7 fddd 	bl	8007400 <lwip_htons>
 800f846:	0003      	movs	r3, r0
 800f848:	b2db      	uxtb	r3, r3
 800f84a:	001a      	movs	r2, r3
 800f84c:	2301      	movs	r3, #1
 800f84e:	4013      	ands	r3, r2
 800f850:	d000      	beq.n	800f854 <tcp_receive+0xff0>
 800f852:	e0ef      	b.n	800fa34 <tcp_receive+0x11d0>
                  /* segment "next" already contains all data */
                  break;
                }
                next->next = tcp_seg_copy(&inseg);
 800f854:	4b8e      	ldr	r3, [pc, #568]	; (800fa90 <tcp_receive+0x122c>)
 800f856:	0018      	movs	r0, r3
 800f858:	f7fc feb6 	bl	800c5c8 <tcp_seg_copy>
 800f85c:	0002      	movs	r2, r0
 800f85e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f860:	601a      	str	r2, [r3, #0]
                if (next->next != NULL) {
 800f862:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f864:	681b      	ldr	r3, [r3, #0]
 800f866:	2b00      	cmp	r3, #0
 800f868:	d100      	bne.n	800f86c <tcp_receive+0x1008>
 800f86a:	e0e5      	b.n	800fa38 <tcp_receive+0x11d4>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
 800f86c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f86e:	691b      	ldr	r3, [r3, #16]
 800f870:	791a      	ldrb	r2, [r3, #4]
 800f872:	7959      	ldrb	r1, [r3, #5]
 800f874:	0209      	lsls	r1, r1, #8
 800f876:	430a      	orrs	r2, r1
 800f878:	7999      	ldrb	r1, [r3, #6]
 800f87a:	0409      	lsls	r1, r1, #16
 800f87c:	430a      	orrs	r2, r1
 800f87e:	79db      	ldrb	r3, [r3, #7]
 800f880:	061b      	lsls	r3, r3, #24
 800f882:	4313      	orrs	r3, r2
 800f884:	001a      	movs	r2, r3
 800f886:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f888:	891b      	ldrh	r3, [r3, #8]
 800f88a:	18d2      	adds	r2, r2, r3
 800f88c:	4b7f      	ldr	r3, [pc, #508]	; (800fa8c <tcp_receive+0x1228>)
 800f88e:	681b      	ldr	r3, [r3, #0]
 800f890:	1ad3      	subs	r3, r2, r3
 800f892:	2b00      	cmp	r3, #0
 800f894:	dd1b      	ble.n	800f8ce <tcp_receive+0x106a>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
 800f896:	4b7d      	ldr	r3, [pc, #500]	; (800fa8c <tcp_receive+0x1228>)
 800f898:	681b      	ldr	r3, [r3, #0]
 800f89a:	b29a      	uxth	r2, r3
 800f89c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f89e:	691b      	ldr	r3, [r3, #16]
 800f8a0:	7919      	ldrb	r1, [r3, #4]
 800f8a2:	7958      	ldrb	r0, [r3, #5]
 800f8a4:	0200      	lsls	r0, r0, #8
 800f8a6:	4301      	orrs	r1, r0
 800f8a8:	7998      	ldrb	r0, [r3, #6]
 800f8aa:	0400      	lsls	r0, r0, #16
 800f8ac:	4301      	orrs	r1, r0
 800f8ae:	79db      	ldrb	r3, [r3, #7]
 800f8b0:	061b      	lsls	r3, r3, #24
 800f8b2:	430b      	orrs	r3, r1
 800f8b4:	b29b      	uxth	r3, r3
 800f8b6:	1ad3      	subs	r3, r2, r3
 800f8b8:	b29a      	uxth	r2, r3
 800f8ba:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f8bc:	811a      	strh	r2, [r3, #8]
                    pbuf_realloc(next->p, next->len);
 800f8be:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f8c0:	685a      	ldr	r2, [r3, #4]
 800f8c2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f8c4:	891b      	ldrh	r3, [r3, #8]
 800f8c6:	0019      	movs	r1, r3
 800f8c8:	0010      	movs	r0, r2
 800f8ca:	f7fa fc4f 	bl	800a16c <pbuf_realloc>
                  }
                  /* check if the remote side overruns our receive window */
                  if (TCP_SEQ_GT((u32_t)tcplen + seqno, pcb->rcv_nxt + (u32_t)pcb->rcv_wnd)) {
 800f8ce:	4b71      	ldr	r3, [pc, #452]	; (800fa94 <tcp_receive+0x1230>)
 800f8d0:	881b      	ldrh	r3, [r3, #0]
 800f8d2:	001a      	movs	r2, r3
 800f8d4:	4b6d      	ldr	r3, [pc, #436]	; (800fa8c <tcp_receive+0x1228>)
 800f8d6:	681b      	ldr	r3, [r3, #0]
 800f8d8:	18d2      	adds	r2, r2, r3
 800f8da:	687b      	ldr	r3, [r7, #4]
 800f8dc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800f8de:	6879      	ldr	r1, [r7, #4]
 800f8e0:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
 800f8e2:	185b      	adds	r3, r3, r1
 800f8e4:	1ad3      	subs	r3, r2, r3
 800f8e6:	2b00      	cmp	r3, #0
 800f8e8:	dc00      	bgt.n	800f8ec <tcp_receive+0x1088>
 800f8ea:	e0a5      	b.n	800fa38 <tcp_receive+0x11d4>
                    LWIP_DEBUGF(TCP_INPUT_DEBUG,
                                ("tcp_receive: other end overran receive window"
                                 "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                                 seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
                    if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
 800f8ec:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f8ee:	681b      	ldr	r3, [r3, #0]
 800f8f0:	691b      	ldr	r3, [r3, #16]
 800f8f2:	7b1a      	ldrb	r2, [r3, #12]
 800f8f4:	7b5b      	ldrb	r3, [r3, #13]
 800f8f6:	021b      	lsls	r3, r3, #8
 800f8f8:	4313      	orrs	r3, r2
 800f8fa:	b29b      	uxth	r3, r3
 800f8fc:	0018      	movs	r0, r3
 800f8fe:	f7f7 fd7f 	bl	8007400 <lwip_htons>
 800f902:	0003      	movs	r3, r0
 800f904:	b2db      	uxtb	r3, r3
 800f906:	001a      	movs	r2, r3
 800f908:	2301      	movs	r3, #1
 800f90a:	4013      	ands	r3, r2
 800f90c:	d03a      	beq.n	800f984 <tcp_receive+0x1120>
                      /* Must remove the FIN from the header as we're trimming
                       * that byte of sequence-space from the packet */
                      TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) & ~TCP_FIN);
 800f90e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f910:	681b      	ldr	r3, [r3, #0]
 800f912:	691b      	ldr	r3, [r3, #16]
 800f914:	7b1a      	ldrb	r2, [r3, #12]
 800f916:	7b5b      	ldrb	r3, [r3, #13]
 800f918:	021b      	lsls	r3, r3, #8
 800f91a:	4313      	orrs	r3, r2
 800f91c:	b29b      	uxth	r3, r3
 800f91e:	b21b      	sxth	r3, r3
 800f920:	4a5d      	ldr	r2, [pc, #372]	; (800fa98 <tcp_receive+0x1234>)
 800f922:	4013      	ands	r3, r2
 800f924:	b21c      	sxth	r4, r3
 800f926:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f928:	681b      	ldr	r3, [r3, #0]
 800f92a:	691b      	ldr	r3, [r3, #16]
 800f92c:	7b1a      	ldrb	r2, [r3, #12]
 800f92e:	7b5b      	ldrb	r3, [r3, #13]
 800f930:	021b      	lsls	r3, r3, #8
 800f932:	4313      	orrs	r3, r2
 800f934:	b29b      	uxth	r3, r3
 800f936:	0018      	movs	r0, r3
 800f938:	f7f7 fd62 	bl	8007400 <lwip_htons>
 800f93c:	0003      	movs	r3, r0
 800f93e:	b2db      	uxtb	r3, r3
 800f940:	b29b      	uxth	r3, r3
 800f942:	223e      	movs	r2, #62	; 0x3e
 800f944:	4013      	ands	r3, r2
 800f946:	b29b      	uxth	r3, r3
 800f948:	0018      	movs	r0, r3
 800f94a:	f7f7 fd59 	bl	8007400 <lwip_htons>
 800f94e:	0003      	movs	r3, r0
 800f950:	b21b      	sxth	r3, r3
 800f952:	4323      	orrs	r3, r4
 800f954:	b21a      	sxth	r2, r3
 800f956:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f958:	681b      	ldr	r3, [r3, #0]
 800f95a:	691b      	ldr	r3, [r3, #16]
 800f95c:	b292      	uxth	r2, r2
 800f95e:	21ff      	movs	r1, #255	; 0xff
 800f960:	4011      	ands	r1, r2
 800f962:	000c      	movs	r4, r1
 800f964:	7b19      	ldrb	r1, [r3, #12]
 800f966:	2000      	movs	r0, #0
 800f968:	4001      	ands	r1, r0
 800f96a:	1c08      	adds	r0, r1, #0
 800f96c:	1c21      	adds	r1, r4, #0
 800f96e:	4301      	orrs	r1, r0
 800f970:	7319      	strb	r1, [r3, #12]
 800f972:	0a12      	lsrs	r2, r2, #8
 800f974:	b290      	uxth	r0, r2
 800f976:	7b5a      	ldrb	r2, [r3, #13]
 800f978:	2100      	movs	r1, #0
 800f97a:	400a      	ands	r2, r1
 800f97c:	1c11      	adds	r1, r2, #0
 800f97e:	1c02      	adds	r2, r0, #0
 800f980:	430a      	orrs	r2, r1
 800f982:	735a      	strb	r2, [r3, #13]
                    }
                    /* Adjust length of segment to fit in the window. */
                    next->next->len = (u16_t)(pcb->rcv_nxt + pcb->rcv_wnd - seqno);
 800f984:	687b      	ldr	r3, [r7, #4]
 800f986:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800f988:	b29a      	uxth	r2, r3
 800f98a:	687b      	ldr	r3, [r7, #4]
 800f98c:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 800f98e:	18d3      	adds	r3, r2, r3
 800f990:	b299      	uxth	r1, r3
 800f992:	4b3e      	ldr	r3, [pc, #248]	; (800fa8c <tcp_receive+0x1228>)
 800f994:	681b      	ldr	r3, [r3, #0]
 800f996:	b29a      	uxth	r2, r3
 800f998:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f99a:	681b      	ldr	r3, [r3, #0]
 800f99c:	1a8a      	subs	r2, r1, r2
 800f99e:	b292      	uxth	r2, r2
 800f9a0:	811a      	strh	r2, [r3, #8]
                    pbuf_realloc(next->next->p, next->next->len);
 800f9a2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f9a4:	681b      	ldr	r3, [r3, #0]
 800f9a6:	685a      	ldr	r2, [r3, #4]
 800f9a8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f9aa:	681b      	ldr	r3, [r3, #0]
 800f9ac:	891b      	ldrh	r3, [r3, #8]
 800f9ae:	0019      	movs	r1, r3
 800f9b0:	0010      	movs	r0, r2
 800f9b2:	f7fa fbdb 	bl	800a16c <pbuf_realloc>
                    tcplen = TCP_TCPLEN(next->next);
 800f9b6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f9b8:	681b      	ldr	r3, [r3, #0]
 800f9ba:	891c      	ldrh	r4, [r3, #8]
 800f9bc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f9be:	681b      	ldr	r3, [r3, #0]
 800f9c0:	691b      	ldr	r3, [r3, #16]
 800f9c2:	7b1a      	ldrb	r2, [r3, #12]
 800f9c4:	7b5b      	ldrb	r3, [r3, #13]
 800f9c6:	021b      	lsls	r3, r3, #8
 800f9c8:	4313      	orrs	r3, r2
 800f9ca:	b29b      	uxth	r3, r3
 800f9cc:	0018      	movs	r0, r3
 800f9ce:	f7f7 fd17 	bl	8007400 <lwip_htons>
 800f9d2:	0003      	movs	r3, r0
 800f9d4:	b2db      	uxtb	r3, r3
 800f9d6:	001a      	movs	r2, r3
 800f9d8:	2303      	movs	r3, #3
 800f9da:	4013      	ands	r3, r2
 800f9dc:	d001      	beq.n	800f9e2 <tcp_receive+0x117e>
 800f9de:	2301      	movs	r3, #1
 800f9e0:	e000      	b.n	800f9e4 <tcp_receive+0x1180>
 800f9e2:	2300      	movs	r3, #0
 800f9e4:	191b      	adds	r3, r3, r4
 800f9e6:	b29a      	uxth	r2, r3
 800f9e8:	4b2a      	ldr	r3, [pc, #168]	; (800fa94 <tcp_receive+0x1230>)
 800f9ea:	801a      	strh	r2, [r3, #0]
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 800f9ec:	4b29      	ldr	r3, [pc, #164]	; (800fa94 <tcp_receive+0x1230>)
 800f9ee:	881b      	ldrh	r3, [r3, #0]
 800f9f0:	001a      	movs	r2, r3
 800f9f2:	4b26      	ldr	r3, [pc, #152]	; (800fa8c <tcp_receive+0x1228>)
 800f9f4:	681b      	ldr	r3, [r3, #0]
 800f9f6:	18d2      	adds	r2, r2, r3
 800f9f8:	687b      	ldr	r3, [r7, #4]
 800f9fa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800f9fc:	6879      	ldr	r1, [r7, #4]
 800f9fe:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
 800fa00:	185b      	adds	r3, r3, r1
 800fa02:	429a      	cmp	r2, r3
 800fa04:	d018      	beq.n	800fa38 <tcp_receive+0x11d4>
 800fa06:	4b25      	ldr	r3, [pc, #148]	; (800fa9c <tcp_receive+0x1238>)
 800fa08:	4a25      	ldr	r2, [pc, #148]	; (800faa0 <tcp_receive+0x123c>)
 800fa0a:	4926      	ldr	r1, [pc, #152]	; (800faa4 <tcp_receive+0x1240>)
 800fa0c:	4826      	ldr	r0, [pc, #152]	; (800faa8 <tcp_receive+0x1244>)
 800fa0e:	f7f2 fbe9 	bl	80021e4 <app_debug_rtt_raw>
                                (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
                  }
                }
                break;
 800fa12:	e011      	b.n	800fa38 <tcp_receive+0x11d4>
          for (next = pcb->ooseq; next != NULL; next = next->next) {
 800fa14:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800fa16:	681b      	ldr	r3, [r3, #0]
 800fa18:	63bb      	str	r3, [r7, #56]	; 0x38
 800fa1a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800fa1c:	2b00      	cmp	r3, #0
 800fa1e:	d000      	beq.n	800fa22 <tcp_receive+0x11be>
 800fa20:	e621      	b.n	800f666 <tcp_receive+0xe02>
 800fa22:	e00a      	b.n	800fa3a <tcp_receive+0x11d6>
                break;
 800fa24:	46c0      	nop			; (mov r8, r8)
 800fa26:	e008      	b.n	800fa3a <tcp_receive+0x11d6>
                break;
 800fa28:	46c0      	nop			; (mov r8, r8)
 800fa2a:	e006      	b.n	800fa3a <tcp_receive+0x11d6>
                  break;
 800fa2c:	46c0      	nop			; (mov r8, r8)
 800fa2e:	e004      	b.n	800fa3a <tcp_receive+0x11d6>
                  break;
 800fa30:	46c0      	nop			; (mov r8, r8)
 800fa32:	e002      	b.n	800fa3a <tcp_receive+0x11d6>
                  break;
 800fa34:	46c0      	nop			; (mov r8, r8)
 800fa36:	e000      	b.n	800fa3a <tcp_receive+0x11d6>
                break;
 800fa38:	46c0      	nop			; (mov r8, r8)
#endif /* TCP_OOSEQ_BYTES_LIMIT || TCP_OOSEQ_PBUFS_LIMIT */
#endif /* TCP_QUEUE_OOSEQ */

        /* We send the ACK packet after we've (potentially) dealt with SACKs,
           so they can be included in the acknowledgment. */
        tcp_send_empty_ack(pcb);
 800fa3a:	687b      	ldr	r3, [r7, #4]
 800fa3c:	0018      	movs	r0, r3
 800fa3e:	f002 fd59 	bl	80124f4 <tcp_send_empty_ack>
      if (pcb->rcv_nxt == seqno) {
 800fa42:	e004      	b.n	800fa4e <tcp_receive+0x11ea>
      }
    } else {
      /* The incoming segment is not within the window. */
      tcp_send_empty_ack(pcb);
 800fa44:	687b      	ldr	r3, [r7, #4]
 800fa46:	0018      	movs	r0, r3
 800fa48:	f002 fd54 	bl	80124f4 <tcp_send_empty_ack>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
 800fa4c:	e019      	b.n	800fa82 <tcp_receive+0x121e>
 800fa4e:	e018      	b.n	800fa82 <tcp_receive+0x121e>
    }
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    if (!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
 800fa50:	4b0e      	ldr	r3, [pc, #56]	; (800fa8c <tcp_receive+0x1228>)
 800fa52:	681a      	ldr	r2, [r3, #0]
 800fa54:	687b      	ldr	r3, [r7, #4]
 800fa56:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800fa58:	1ad3      	subs	r3, r2, r3
 800fa5a:	d40a      	bmi.n	800fa72 <tcp_receive+0x120e>
 800fa5c:	4b0b      	ldr	r3, [pc, #44]	; (800fa8c <tcp_receive+0x1228>)
 800fa5e:	681a      	ldr	r2, [r3, #0]
 800fa60:	687b      	ldr	r3, [r7, #4]
 800fa62:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800fa64:	6879      	ldr	r1, [r7, #4]
 800fa66:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
 800fa68:	185b      	adds	r3, r3, r1
 800fa6a:	1ad3      	subs	r3, r2, r3
 800fa6c:	3301      	adds	r3, #1
 800fa6e:	2b00      	cmp	r3, #0
 800fa70:	dd07      	ble.n	800fa82 <tcp_receive+0x121e>
      tcp_ack_now(pcb);
 800fa72:	687b      	ldr	r3, [r7, #4]
 800fa74:	8bdb      	ldrh	r3, [r3, #30]
 800fa76:	2202      	movs	r2, #2
 800fa78:	4313      	orrs	r3, r2
 800fa7a:	b29a      	uxth	r2, r3
 800fa7c:	687b      	ldr	r3, [r7, #4]
 800fa7e:	83da      	strh	r2, [r3, #30]
    }
  }
}
 800fa80:	e7ff      	b.n	800fa82 <tcp_receive+0x121e>
 800fa82:	46c0      	nop			; (mov r8, r8)
 800fa84:	46bd      	mov	sp, r7
 800fa86:	b014      	add	sp, #80	; 0x50
 800fa88:	bdb0      	pop	{r4, r5, r7, pc}
 800fa8a:	46c0      	nop			; (mov r8, r8)
 800fa8c:	20000c6c 	.word	0x20000c6c
 800fa90:	20000c48 	.word	0x20000c48
 800fa94:	20000c76 	.word	0x20000c76
 800fa98:	ffffc0ff 	.word	0xffffc0ff
 800fa9c:	0802120c 	.word	0x0802120c
 800faa0:	000006f9 	.word	0x000006f9
 800faa4:	080215ac 	.word	0x080215ac
 800faa8:	0802124c 	.word	0x0802124c

0800faac <tcp_get_next_optbyte>:

static u8_t
tcp_get_next_optbyte(void)
{
 800faac:	b580      	push	{r7, lr}
 800faae:	b082      	sub	sp, #8
 800fab0:	af00      	add	r7, sp, #0
  u16_t optidx = tcp_optidx++;
 800fab2:	4b17      	ldr	r3, [pc, #92]	; (800fb10 <tcp_get_next_optbyte+0x64>)
 800fab4:	881b      	ldrh	r3, [r3, #0]
 800fab6:	1c5a      	adds	r2, r3, #1
 800fab8:	b291      	uxth	r1, r2
 800faba:	4a15      	ldr	r2, [pc, #84]	; (800fb10 <tcp_get_next_optbyte+0x64>)
 800fabc:	8011      	strh	r1, [r2, #0]
 800fabe:	1dba      	adds	r2, r7, #6
 800fac0:	8013      	strh	r3, [r2, #0]
  if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 800fac2:	4b14      	ldr	r3, [pc, #80]	; (800fb14 <tcp_get_next_optbyte+0x68>)
 800fac4:	681b      	ldr	r3, [r3, #0]
 800fac6:	2b00      	cmp	r3, #0
 800fac8:	d005      	beq.n	800fad6 <tcp_get_next_optbyte+0x2a>
 800faca:	4b13      	ldr	r3, [pc, #76]	; (800fb18 <tcp_get_next_optbyte+0x6c>)
 800facc:	881b      	ldrh	r3, [r3, #0]
 800face:	1dba      	adds	r2, r7, #6
 800fad0:	8812      	ldrh	r2, [r2, #0]
 800fad2:	429a      	cmp	r2, r3
 800fad4:	d209      	bcs.n	800faea <tcp_get_next_optbyte+0x3e>
    u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
 800fad6:	4b11      	ldr	r3, [pc, #68]	; (800fb1c <tcp_get_next_optbyte+0x70>)
 800fad8:	681b      	ldr	r3, [r3, #0]
 800fada:	3314      	adds	r3, #20
 800fadc:	603b      	str	r3, [r7, #0]
    return opts[optidx];
 800fade:	1dbb      	adds	r3, r7, #6
 800fae0:	881b      	ldrh	r3, [r3, #0]
 800fae2:	683a      	ldr	r2, [r7, #0]
 800fae4:	18d3      	adds	r3, r2, r3
 800fae6:	781b      	ldrb	r3, [r3, #0]
 800fae8:	e00e      	b.n	800fb08 <tcp_get_next_optbyte+0x5c>
  } else {
    u8_t idx = (u8_t)(optidx - tcphdr_opt1len);
 800faea:	1dbb      	adds	r3, r7, #6
 800faec:	881b      	ldrh	r3, [r3, #0]
 800faee:	b2d9      	uxtb	r1, r3
 800faf0:	4b09      	ldr	r3, [pc, #36]	; (800fb18 <tcp_get_next_optbyte+0x6c>)
 800faf2:	881b      	ldrh	r3, [r3, #0]
 800faf4:	b2da      	uxtb	r2, r3
 800faf6:	1d7b      	adds	r3, r7, #5
 800faf8:	1a8a      	subs	r2, r1, r2
 800fafa:	701a      	strb	r2, [r3, #0]
    return tcphdr_opt2[idx];
 800fafc:	4b05      	ldr	r3, [pc, #20]	; (800fb14 <tcp_get_next_optbyte+0x68>)
 800fafe:	681a      	ldr	r2, [r3, #0]
 800fb00:	1d7b      	adds	r3, r7, #5
 800fb02:	781b      	ldrb	r3, [r3, #0]
 800fb04:	18d3      	adds	r3, r2, r3
 800fb06:	781b      	ldrb	r3, [r3, #0]
  }
}
 800fb08:	0018      	movs	r0, r3
 800fb0a:	46bd      	mov	sp, r7
 800fb0c:	b002      	add	sp, #8
 800fb0e:	bd80      	pop	{r7, pc}
 800fb10:	20000c68 	.word	0x20000c68
 800fb14:	20000c64 	.word	0x20000c64
 800fb18:	20000c62 	.word	0x20000c62
 800fb1c:	20000c5c 	.word	0x20000c5c

0800fb20 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
 800fb20:	b5b0      	push	{r4, r5, r7, lr}
 800fb22:	b084      	sub	sp, #16
 800fb24:	af00      	add	r7, sp, #0
 800fb26:	6078      	str	r0, [r7, #4]
  u16_t mss;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  LWIP_ASSERT("tcp_parseopt: invalid pcb", pcb != NULL);
 800fb28:	687b      	ldr	r3, [r7, #4]
 800fb2a:	2b00      	cmp	r3, #0
 800fb2c:	d105      	bne.n	800fb3a <tcp_parseopt+0x1a>
 800fb2e:	4b39      	ldr	r3, [pc, #228]	; (800fc14 <tcp_parseopt+0xf4>)
 800fb30:	4a39      	ldr	r2, [pc, #228]	; (800fc18 <tcp_parseopt+0xf8>)
 800fb32:	493a      	ldr	r1, [pc, #232]	; (800fc1c <tcp_parseopt+0xfc>)
 800fb34:	483a      	ldr	r0, [pc, #232]	; (800fc20 <tcp_parseopt+0x100>)
 800fb36:	f7f2 fb55 	bl	80021e4 <app_debug_rtt_raw>

  /* Parse the TCP MSS option, if present. */
  if (tcphdr_optlen != 0) {
 800fb3a:	4b3a      	ldr	r3, [pc, #232]	; (800fc24 <tcp_parseopt+0x104>)
 800fb3c:	881b      	ldrh	r3, [r3, #0]
 800fb3e:	2b00      	cmp	r3, #0
 800fb40:	d100      	bne.n	800fb44 <tcp_parseopt+0x24>
 800fb42:	e064      	b.n	800fc0e <tcp_parseopt+0xee>
    for (tcp_optidx = 0; tcp_optidx < tcphdr_optlen; ) {
 800fb44:	4b38      	ldr	r3, [pc, #224]	; (800fc28 <tcp_parseopt+0x108>)
 800fb46:	2200      	movs	r2, #0
 800fb48:	801a      	strh	r2, [r3, #0]
 800fb4a:	e054      	b.n	800fbf6 <tcp_parseopt+0xd6>
      u8_t opt = tcp_get_next_optbyte();
 800fb4c:	250f      	movs	r5, #15
 800fb4e:	197c      	adds	r4, r7, r5
 800fb50:	f7ff ffac 	bl	800faac <tcp_get_next_optbyte>
 800fb54:	0003      	movs	r3, r0
 800fb56:	7023      	strb	r3, [r4, #0]
      switch (opt) {
 800fb58:	197b      	adds	r3, r7, r5
 800fb5a:	781b      	ldrb	r3, [r3, #0]
 800fb5c:	2b02      	cmp	r3, #2
 800fb5e:	d005      	beq.n	800fb6c <tcp_parseopt+0x4c>
 800fb60:	dc33      	bgt.n	800fbca <tcp_parseopt+0xaa>
 800fb62:	2b00      	cmp	r3, #0
 800fb64:	d04e      	beq.n	800fc04 <tcp_parseopt+0xe4>
 800fb66:	2b01      	cmp	r3, #1
 800fb68:	d12f      	bne.n	800fbca <tcp_parseopt+0xaa>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
          return;
        case LWIP_TCP_OPT_NOP:
          /* NOP option. */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
          break;
 800fb6a:	e044      	b.n	800fbf6 <tcp_parseopt+0xd6>
        case LWIP_TCP_OPT_MSS:
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
          if (tcp_get_next_optbyte() != LWIP_TCP_OPT_LEN_MSS || (tcp_optidx - 2 + LWIP_TCP_OPT_LEN_MSS) > tcphdr_optlen) {
 800fb6c:	f7ff ff9e 	bl	800faac <tcp_get_next_optbyte>
 800fb70:	0003      	movs	r3, r0
 800fb72:	2b04      	cmp	r3, #4
 800fb74:	d148      	bne.n	800fc08 <tcp_parseopt+0xe8>
 800fb76:	4b2c      	ldr	r3, [pc, #176]	; (800fc28 <tcp_parseopt+0x108>)
 800fb78:	881b      	ldrh	r3, [r3, #0]
 800fb7a:	3301      	adds	r3, #1
 800fb7c:	4a29      	ldr	r2, [pc, #164]	; (800fc24 <tcp_parseopt+0x104>)
 800fb7e:	8812      	ldrh	r2, [r2, #0]
 800fb80:	4293      	cmp	r3, r2
 800fb82:	da41      	bge.n	800fc08 <tcp_parseopt+0xe8>
            /* Bad length */
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
            return;
          }
          /* An MSS option with the right option length. */
          mss = (u16_t)(tcp_get_next_optbyte() << 8);
 800fb84:	f7ff ff92 	bl	800faac <tcp_get_next_optbyte>
 800fb88:	0003      	movs	r3, r0
 800fb8a:	b29a      	uxth	r2, r3
 800fb8c:	240c      	movs	r4, #12
 800fb8e:	193b      	adds	r3, r7, r4
 800fb90:	0212      	lsls	r2, r2, #8
 800fb92:	801a      	strh	r2, [r3, #0]
          mss |= tcp_get_next_optbyte();
 800fb94:	f7ff ff8a 	bl	800faac <tcp_get_next_optbyte>
 800fb98:	0003      	movs	r3, r0
 800fb9a:	b299      	uxth	r1, r3
 800fb9c:	193b      	adds	r3, r7, r4
 800fb9e:	193a      	adds	r2, r7, r4
 800fba0:	8812      	ldrh	r2, [r2, #0]
 800fba2:	430a      	orrs	r2, r1
 800fba4:	801a      	strh	r2, [r3, #0]
          /* Limit the mss to the configured TCP_MSS and prevent division by zero */
          pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 800fba6:	193b      	adds	r3, r7, r4
 800fba8:	881a      	ldrh	r2, [r3, #0]
 800fbaa:	2386      	movs	r3, #134	; 0x86
 800fbac:	009b      	lsls	r3, r3, #2
 800fbae:	429a      	cmp	r2, r3
 800fbb0:	d806      	bhi.n	800fbc0 <tcp_parseopt+0xa0>
 800fbb2:	193b      	adds	r3, r7, r4
 800fbb4:	881b      	ldrh	r3, [r3, #0]
 800fbb6:	2b00      	cmp	r3, #0
 800fbb8:	d002      	beq.n	800fbc0 <tcp_parseopt+0xa0>
 800fbba:	193b      	adds	r3, r7, r4
 800fbbc:	881b      	ldrh	r3, [r3, #0]
 800fbbe:	e001      	b.n	800fbc4 <tcp_parseopt+0xa4>
 800fbc0:	2386      	movs	r3, #134	; 0x86
 800fbc2:	009b      	lsls	r3, r3, #2
 800fbc4:	687a      	ldr	r2, [r7, #4]
 800fbc6:	86d3      	strh	r3, [r2, #54]	; 0x36
          break;
 800fbc8:	e015      	b.n	800fbf6 <tcp_parseopt+0xd6>
          }
          break;
#endif /* LWIP_TCP_SACK_OUT */
        default:
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
          data = tcp_get_next_optbyte();
 800fbca:	250b      	movs	r5, #11
 800fbcc:	197c      	adds	r4, r7, r5
 800fbce:	f7ff ff6d 	bl	800faac <tcp_get_next_optbyte>
 800fbd2:	0003      	movs	r3, r0
 800fbd4:	7023      	strb	r3, [r4, #0]
          if (data < 2) {
 800fbd6:	002a      	movs	r2, r5
 800fbd8:	18bb      	adds	r3, r7, r2
 800fbda:	781b      	ldrb	r3, [r3, #0]
 800fbdc:	2b01      	cmp	r3, #1
 800fbde:	d915      	bls.n	800fc0c <tcp_parseopt+0xec>
               and we don't process them further. */
            return;
          }
          /* All other options have a length field, so that we easily
             can skip past them. */
          tcp_optidx += data - 2;
 800fbe0:	18bb      	adds	r3, r7, r2
 800fbe2:	781b      	ldrb	r3, [r3, #0]
 800fbe4:	b29a      	uxth	r2, r3
 800fbe6:	4b10      	ldr	r3, [pc, #64]	; (800fc28 <tcp_parseopt+0x108>)
 800fbe8:	881b      	ldrh	r3, [r3, #0]
 800fbea:	18d3      	adds	r3, r2, r3
 800fbec:	b29b      	uxth	r3, r3
 800fbee:	3b02      	subs	r3, #2
 800fbf0:	b29a      	uxth	r2, r3
 800fbf2:	4b0d      	ldr	r3, [pc, #52]	; (800fc28 <tcp_parseopt+0x108>)
 800fbf4:	801a      	strh	r2, [r3, #0]
    for (tcp_optidx = 0; tcp_optidx < tcphdr_optlen; ) {
 800fbf6:	4b0c      	ldr	r3, [pc, #48]	; (800fc28 <tcp_parseopt+0x108>)
 800fbf8:	881a      	ldrh	r2, [r3, #0]
 800fbfa:	4b0a      	ldr	r3, [pc, #40]	; (800fc24 <tcp_parseopt+0x104>)
 800fbfc:	881b      	ldrh	r3, [r3, #0]
 800fbfe:	429a      	cmp	r2, r3
 800fc00:	d3a4      	bcc.n	800fb4c <tcp_parseopt+0x2c>
 800fc02:	e004      	b.n	800fc0e <tcp_parseopt+0xee>
          return;
 800fc04:	46c0      	nop			; (mov r8, r8)
 800fc06:	e002      	b.n	800fc0e <tcp_parseopt+0xee>
            return;
 800fc08:	46c0      	nop			; (mov r8, r8)
 800fc0a:	e000      	b.n	800fc0e <tcp_parseopt+0xee>
            return;
 800fc0c:	46c0      	nop			; (mov r8, r8)
      }
    }
  }
}
 800fc0e:	46bd      	mov	sp, r7
 800fc10:	b004      	add	sp, #16
 800fc12:	bdb0      	pop	{r4, r5, r7, pc}
 800fc14:	0802120c 	.word	0x0802120c
 800fc18:	0000077e 	.word	0x0000077e
 800fc1c:	08021668 	.word	0x08021668
 800fc20:	0802124c 	.word	0x0802124c
 800fc24:	20000c60 	.word	0x20000c60
 800fc28:	20000c68 	.word	0x20000c68

0800fc2c <tcp_trigger_input_pcb_close>:

void
tcp_trigger_input_pcb_close(void)
{
 800fc2c:	b580      	push	{r7, lr}
 800fc2e:	af00      	add	r7, sp, #0
  recv_flags |= TF_CLOSED;
 800fc30:	4b04      	ldr	r3, [pc, #16]	; (800fc44 <tcp_trigger_input_pcb_close+0x18>)
 800fc32:	781b      	ldrb	r3, [r3, #0]
 800fc34:	2210      	movs	r2, #16
 800fc36:	4313      	orrs	r3, r2
 800fc38:	b2da      	uxtb	r2, r3
 800fc3a:	4b02      	ldr	r3, [pc, #8]	; (800fc44 <tcp_trigger_input_pcb_close+0x18>)
 800fc3c:	701a      	strb	r2, [r3, #0]
}
 800fc3e:	46c0      	nop			; (mov r8, r8)
 800fc40:	46bd      	mov	sp, r7
 800fc42:	bd80      	pop	{r7, pc}
 800fc44:	20000c79 	.word	0x20000c79

0800fc48 <tcp_route>:
static err_t tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb, struct netif *netif);

/* tcp_route: common code that returns a fixed bound netif or calls ip_route */
static struct netif *
tcp_route(const struct tcp_pcb *pcb, const ip_addr_t *src, const ip_addr_t *dst)
{
 800fc48:	b580      	push	{r7, lr}
 800fc4a:	b084      	sub	sp, #16
 800fc4c:	af00      	add	r7, sp, #0
 800fc4e:	60f8      	str	r0, [r7, #12]
 800fc50:	60b9      	str	r1, [r7, #8]
 800fc52:	607a      	str	r2, [r7, #4]
  LWIP_UNUSED_ARG(src); /* in case IPv4-only and source-based routing is disabled */

  if ((pcb != NULL) && (pcb->netif_idx != NETIF_NO_INDEX)) {
 800fc54:	68fb      	ldr	r3, [r7, #12]
 800fc56:	2b00      	cmp	r3, #0
 800fc58:	d00a      	beq.n	800fc70 <tcp_route+0x28>
 800fc5a:	68fb      	ldr	r3, [r7, #12]
 800fc5c:	7a1b      	ldrb	r3, [r3, #8]
 800fc5e:	2b00      	cmp	r3, #0
 800fc60:	d006      	beq.n	800fc70 <tcp_route+0x28>
    return netif_get_by_index(pcb->netif_idx);
 800fc62:	68fb      	ldr	r3, [r7, #12]
 800fc64:	7a1b      	ldrb	r3, [r3, #8]
 800fc66:	0018      	movs	r0, r3
 800fc68:	f7fa f884 	bl	8009d74 <netif_get_by_index>
 800fc6c:	0003      	movs	r3, r0
 800fc6e:	e004      	b.n	800fc7a <tcp_route+0x32>
  } else {
    return ip_route(src, dst);
 800fc70:	687b      	ldr	r3, [r7, #4]
 800fc72:	0018      	movs	r0, r3
 800fc74:	f004 f820 	bl	8013cb8 <ip4_route>
 800fc78:	0003      	movs	r3, r0
  }
}
 800fc7a:	0018      	movs	r0, r3
 800fc7c:	46bd      	mov	sp, r7
 800fc7e:	b004      	add	sp, #16
 800fc80:	bd80      	pop	{r7, pc}
	...

0800fc84 <tcp_create_segment>:
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *
tcp_create_segment(const struct tcp_pcb *pcb, struct pbuf *p, u8_t hdrflags, u32_t seqno, u8_t optflags)
{
 800fc84:	b590      	push	{r4, r7, lr}
 800fc86:	b087      	sub	sp, #28
 800fc88:	af00      	add	r7, sp, #0
 800fc8a:	60f8      	str	r0, [r7, #12]
 800fc8c:	60b9      	str	r1, [r7, #8]
 800fc8e:	603b      	str	r3, [r7, #0]
 800fc90:	1dfb      	adds	r3, r7, #7
 800fc92:	701a      	strb	r2, [r3, #0]
  struct tcp_seg *seg;
  u8_t optlen;

  LWIP_ASSERT("tcp_create_segment: invalid pcb", pcb != NULL);
 800fc94:	68fb      	ldr	r3, [r7, #12]
 800fc96:	2b00      	cmp	r3, #0
 800fc98:	d105      	bne.n	800fca6 <tcp_create_segment+0x22>
 800fc9a:	4b86      	ldr	r3, [pc, #536]	; (800feb4 <tcp_create_segment+0x230>)
 800fc9c:	4986      	ldr	r1, [pc, #536]	; (800feb8 <tcp_create_segment+0x234>)
 800fc9e:	4887      	ldr	r0, [pc, #540]	; (800febc <tcp_create_segment+0x238>)
 800fca0:	22a3      	movs	r2, #163	; 0xa3
 800fca2:	f7f2 fa9f 	bl	80021e4 <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_create_segment: invalid pbuf", p != NULL);
 800fca6:	68bb      	ldr	r3, [r7, #8]
 800fca8:	2b00      	cmp	r3, #0
 800fcaa:	d105      	bne.n	800fcb8 <tcp_create_segment+0x34>
 800fcac:	4b81      	ldr	r3, [pc, #516]	; (800feb4 <tcp_create_segment+0x230>)
 800fcae:	4984      	ldr	r1, [pc, #528]	; (800fec0 <tcp_create_segment+0x23c>)
 800fcb0:	4882      	ldr	r0, [pc, #520]	; (800febc <tcp_create_segment+0x238>)
 800fcb2:	22a4      	movs	r2, #164	; 0xa4
 800fcb4:	f7f2 fa96 	bl	80021e4 <app_debug_rtt_raw>

  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
 800fcb8:	2328      	movs	r3, #40	; 0x28
 800fcba:	18fb      	adds	r3, r7, r3
 800fcbc:	781b      	ldrb	r3, [r3, #0]
 800fcbe:	009b      	lsls	r3, r3, #2
 800fcc0:	b2da      	uxtb	r2, r3
 800fcc2:	2317      	movs	r3, #23
 800fcc4:	18fb      	adds	r3, r7, r3
 800fcc6:	2104      	movs	r1, #4
 800fcc8:	400a      	ands	r2, r1
 800fcca:	701a      	strb	r2, [r3, #0]

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 800fccc:	2003      	movs	r0, #3
 800fcce:	f7f9 fce1 	bl	8009694 <memp_malloc>
 800fcd2:	0003      	movs	r3, r0
 800fcd4:	613b      	str	r3, [r7, #16]
 800fcd6:	693b      	ldr	r3, [r7, #16]
 800fcd8:	2b00      	cmp	r3, #0
 800fcda:	d105      	bne.n	800fce8 <tcp_create_segment+0x64>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
 800fcdc:	68bb      	ldr	r3, [r7, #8]
 800fcde:	0018      	movs	r0, r3
 800fce0:	f7fa fbfc 	bl	800a4dc <pbuf_free>
    return NULL;
 800fce4:	2300      	movs	r3, #0
 800fce6:	e0e1      	b.n	800feac <tcp_create_segment+0x228>
  }
  seg->flags = optflags;
 800fce8:	693a      	ldr	r2, [r7, #16]
 800fcea:	2328      	movs	r3, #40	; 0x28
 800fcec:	18fb      	adds	r3, r7, r3
 800fcee:	781b      	ldrb	r3, [r3, #0]
 800fcf0:	73d3      	strb	r3, [r2, #15]
  seg->next = NULL;
 800fcf2:	693b      	ldr	r3, [r7, #16]
 800fcf4:	2200      	movs	r2, #0
 800fcf6:	601a      	str	r2, [r3, #0]
  seg->p = p;
 800fcf8:	693b      	ldr	r3, [r7, #16]
 800fcfa:	68ba      	ldr	r2, [r7, #8]
 800fcfc:	605a      	str	r2, [r3, #4]
  LWIP_ASSERT("p->tot_len >= optlen", p->tot_len >= optlen);
 800fcfe:	68bb      	ldr	r3, [r7, #8]
 800fd00:	891a      	ldrh	r2, [r3, #8]
 800fd02:	2317      	movs	r3, #23
 800fd04:	18fb      	adds	r3, r7, r3
 800fd06:	781b      	ldrb	r3, [r3, #0]
 800fd08:	b29b      	uxth	r3, r3
 800fd0a:	429a      	cmp	r2, r3
 800fd0c:	d205      	bcs.n	800fd1a <tcp_create_segment+0x96>
 800fd0e:	4b69      	ldr	r3, [pc, #420]	; (800feb4 <tcp_create_segment+0x230>)
 800fd10:	496c      	ldr	r1, [pc, #432]	; (800fec4 <tcp_create_segment+0x240>)
 800fd12:	486a      	ldr	r0, [pc, #424]	; (800febc <tcp_create_segment+0x238>)
 800fd14:	22b0      	movs	r2, #176	; 0xb0
 800fd16:	f7f2 fa65 	bl	80021e4 <app_debug_rtt_raw>
  seg->len = p->tot_len - optlen;
 800fd1a:	68bb      	ldr	r3, [r7, #8]
 800fd1c:	891a      	ldrh	r2, [r3, #8]
 800fd1e:	2317      	movs	r3, #23
 800fd20:	18fb      	adds	r3, r7, r3
 800fd22:	781b      	ldrb	r3, [r3, #0]
 800fd24:	b29b      	uxth	r3, r3
 800fd26:	1ad3      	subs	r3, r2, r3
 800fd28:	b29a      	uxth	r2, r3
 800fd2a:	693b      	ldr	r3, [r7, #16]
 800fd2c:	811a      	strh	r2, [r3, #8]
#if TCP_OVERSIZE_DBGCHECK
  seg->oversize_left = 0;
 800fd2e:	693b      	ldr	r3, [r7, #16]
 800fd30:	2200      	movs	r2, #0
 800fd32:	815a      	strh	r2, [r3, #10]
#endif /* TCP_OVERSIZE_DBGCHECK */
#if TCP_CHECKSUM_ON_COPY
  seg->chksum = 0;
 800fd34:	693b      	ldr	r3, [r7, #16]
 800fd36:	2200      	movs	r2, #0
 800fd38:	819a      	strh	r2, [r3, #12]
  seg->chksum_swapped = 0;
 800fd3a:	693b      	ldr	r3, [r7, #16]
 800fd3c:	2200      	movs	r2, #0
 800fd3e:	739a      	strb	r2, [r3, #14]
  /* check optflags */
  LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
 800fd40:	2328      	movs	r3, #40	; 0x28
 800fd42:	18fb      	adds	r3, r7, r3
 800fd44:	781b      	ldrb	r3, [r3, #0]
 800fd46:	2204      	movs	r2, #4
 800fd48:	4013      	ands	r3, r2
 800fd4a:	d005      	beq.n	800fd58 <tcp_create_segment+0xd4>
 800fd4c:	4b59      	ldr	r3, [pc, #356]	; (800feb4 <tcp_create_segment+0x230>)
 800fd4e:	495e      	ldr	r1, [pc, #376]	; (800fec8 <tcp_create_segment+0x244>)
 800fd50:	485a      	ldr	r0, [pc, #360]	; (800febc <tcp_create_segment+0x238>)
 800fd52:	22b9      	movs	r2, #185	; 0xb9
 800fd54:	f7f2 fa46 	bl	80021e4 <app_debug_rtt_raw>
              (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_add_header(p, TCP_HLEN)) {
 800fd58:	68bb      	ldr	r3, [r7, #8]
 800fd5a:	2114      	movs	r1, #20
 800fd5c:	0018      	movs	r0, r3
 800fd5e:	f7fa fb17 	bl	800a390 <pbuf_add_header>
 800fd62:	1e03      	subs	r3, r0, #0
 800fd64:	d005      	beq.n	800fd72 <tcp_create_segment+0xee>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
 800fd66:	693b      	ldr	r3, [r7, #16]
 800fd68:	0018      	movs	r0, r3
 800fd6a:	f7fc fc13 	bl	800c594 <tcp_seg_free>
    return NULL;
 800fd6e:	2300      	movs	r3, #0
 800fd70:	e09c      	b.n	800feac <tcp_create_segment+0x228>
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 800fd72:	693b      	ldr	r3, [r7, #16]
 800fd74:	685b      	ldr	r3, [r3, #4]
 800fd76:	685a      	ldr	r2, [r3, #4]
 800fd78:	693b      	ldr	r3, [r7, #16]
 800fd7a:	611a      	str	r2, [r3, #16]
  seg->tcphdr->src = lwip_htons(pcb->local_port);
 800fd7c:	68fb      	ldr	r3, [r7, #12]
 800fd7e:	8b5a      	ldrh	r2, [r3, #26]
 800fd80:	693b      	ldr	r3, [r7, #16]
 800fd82:	691c      	ldr	r4, [r3, #16]
 800fd84:	0010      	movs	r0, r2
 800fd86:	f7f7 fb3b 	bl	8007400 <lwip_htons>
 800fd8a:	0003      	movs	r3, r0
 800fd8c:	22ff      	movs	r2, #255	; 0xff
 800fd8e:	401a      	ands	r2, r3
 800fd90:	0010      	movs	r0, r2
 800fd92:	7822      	ldrb	r2, [r4, #0]
 800fd94:	2100      	movs	r1, #0
 800fd96:	400a      	ands	r2, r1
 800fd98:	1c11      	adds	r1, r2, #0
 800fd9a:	1c02      	adds	r2, r0, #0
 800fd9c:	430a      	orrs	r2, r1
 800fd9e:	7022      	strb	r2, [r4, #0]
 800fda0:	0a1b      	lsrs	r3, r3, #8
 800fda2:	b299      	uxth	r1, r3
 800fda4:	7863      	ldrb	r3, [r4, #1]
 800fda6:	2200      	movs	r2, #0
 800fda8:	4013      	ands	r3, r2
 800fdaa:	1c1a      	adds	r2, r3, #0
 800fdac:	1c0b      	adds	r3, r1, #0
 800fdae:	4313      	orrs	r3, r2
 800fdb0:	7063      	strb	r3, [r4, #1]
  seg->tcphdr->dest = lwip_htons(pcb->remote_port);
 800fdb2:	68fb      	ldr	r3, [r7, #12]
 800fdb4:	8b9a      	ldrh	r2, [r3, #28]
 800fdb6:	693b      	ldr	r3, [r7, #16]
 800fdb8:	691c      	ldr	r4, [r3, #16]
 800fdba:	0010      	movs	r0, r2
 800fdbc:	f7f7 fb20 	bl	8007400 <lwip_htons>
 800fdc0:	0003      	movs	r3, r0
 800fdc2:	22ff      	movs	r2, #255	; 0xff
 800fdc4:	401a      	ands	r2, r3
 800fdc6:	0010      	movs	r0, r2
 800fdc8:	78a2      	ldrb	r2, [r4, #2]
 800fdca:	2100      	movs	r1, #0
 800fdcc:	400a      	ands	r2, r1
 800fdce:	1c11      	adds	r1, r2, #0
 800fdd0:	1c02      	adds	r2, r0, #0
 800fdd2:	430a      	orrs	r2, r1
 800fdd4:	70a2      	strb	r2, [r4, #2]
 800fdd6:	0a1b      	lsrs	r3, r3, #8
 800fdd8:	b299      	uxth	r1, r3
 800fdda:	78e3      	ldrb	r3, [r4, #3]
 800fddc:	2200      	movs	r2, #0
 800fdde:	4013      	ands	r3, r2
 800fde0:	1c1a      	adds	r2, r3, #0
 800fde2:	1c0b      	adds	r3, r1, #0
 800fde4:	4313      	orrs	r3, r2
 800fde6:	70e3      	strb	r3, [r4, #3]
  seg->tcphdr->seqno = lwip_htonl(seqno);
 800fde8:	693b      	ldr	r3, [r7, #16]
 800fdea:	691c      	ldr	r4, [r3, #16]
 800fdec:	683b      	ldr	r3, [r7, #0]
 800fdee:	0018      	movs	r0, r3
 800fdf0:	f7f7 fb1c 	bl	800742c <lwip_htonl>
 800fdf4:	0003      	movs	r3, r0
 800fdf6:	22ff      	movs	r2, #255	; 0xff
 800fdf8:	401a      	ands	r2, r3
 800fdfa:	0010      	movs	r0, r2
 800fdfc:	7922      	ldrb	r2, [r4, #4]
 800fdfe:	2100      	movs	r1, #0
 800fe00:	400a      	ands	r2, r1
 800fe02:	1c11      	adds	r1, r2, #0
 800fe04:	1c02      	adds	r2, r0, #0
 800fe06:	430a      	orrs	r2, r1
 800fe08:	7122      	strb	r2, [r4, #4]
 800fe0a:	0a1a      	lsrs	r2, r3, #8
 800fe0c:	21ff      	movs	r1, #255	; 0xff
 800fe0e:	400a      	ands	r2, r1
 800fe10:	0010      	movs	r0, r2
 800fe12:	7962      	ldrb	r2, [r4, #5]
 800fe14:	2100      	movs	r1, #0
 800fe16:	400a      	ands	r2, r1
 800fe18:	1c11      	adds	r1, r2, #0
 800fe1a:	1c02      	adds	r2, r0, #0
 800fe1c:	430a      	orrs	r2, r1
 800fe1e:	7162      	strb	r2, [r4, #5]
 800fe20:	0c1a      	lsrs	r2, r3, #16
 800fe22:	21ff      	movs	r1, #255	; 0xff
 800fe24:	400a      	ands	r2, r1
 800fe26:	0010      	movs	r0, r2
 800fe28:	79a2      	ldrb	r2, [r4, #6]
 800fe2a:	2100      	movs	r1, #0
 800fe2c:	400a      	ands	r2, r1
 800fe2e:	1c11      	adds	r1, r2, #0
 800fe30:	1c02      	adds	r2, r0, #0
 800fe32:	430a      	orrs	r2, r1
 800fe34:	71a2      	strb	r2, [r4, #6]
 800fe36:	0e19      	lsrs	r1, r3, #24
 800fe38:	79e3      	ldrb	r3, [r4, #7]
 800fe3a:	2200      	movs	r2, #0
 800fe3c:	4013      	ands	r3, r2
 800fe3e:	1c1a      	adds	r2, r3, #0
 800fe40:	1c0b      	adds	r3, r1, #0
 800fe42:	4313      	orrs	r3, r2
 800fe44:	71e3      	strb	r3, [r4, #7]
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), hdrflags);
 800fe46:	2317      	movs	r3, #23
 800fe48:	18fb      	adds	r3, r7, r3
 800fe4a:	781b      	ldrb	r3, [r3, #0]
 800fe4c:	089b      	lsrs	r3, r3, #2
 800fe4e:	b2db      	uxtb	r3, r3
 800fe50:	b29b      	uxth	r3, r3
 800fe52:	3305      	adds	r3, #5
 800fe54:	b29b      	uxth	r3, r3
 800fe56:	031b      	lsls	r3, r3, #12
 800fe58:	b29a      	uxth	r2, r3
 800fe5a:	1dfb      	adds	r3, r7, #7
 800fe5c:	781b      	ldrb	r3, [r3, #0]
 800fe5e:	b29b      	uxth	r3, r3
 800fe60:	4313      	orrs	r3, r2
 800fe62:	b29a      	uxth	r2, r3
 800fe64:	693b      	ldr	r3, [r7, #16]
 800fe66:	691c      	ldr	r4, [r3, #16]
 800fe68:	0010      	movs	r0, r2
 800fe6a:	f7f7 fac9 	bl	8007400 <lwip_htons>
 800fe6e:	0003      	movs	r3, r0
 800fe70:	22ff      	movs	r2, #255	; 0xff
 800fe72:	401a      	ands	r2, r3
 800fe74:	0010      	movs	r0, r2
 800fe76:	7b22      	ldrb	r2, [r4, #12]
 800fe78:	2100      	movs	r1, #0
 800fe7a:	400a      	ands	r2, r1
 800fe7c:	1c11      	adds	r1, r2, #0
 800fe7e:	1c02      	adds	r2, r0, #0
 800fe80:	430a      	orrs	r2, r1
 800fe82:	7322      	strb	r2, [r4, #12]
 800fe84:	0a1b      	lsrs	r3, r3, #8
 800fe86:	b299      	uxth	r1, r3
 800fe88:	7b63      	ldrb	r3, [r4, #13]
 800fe8a:	2200      	movs	r2, #0
 800fe8c:	4013      	ands	r3, r2
 800fe8e:	1c1a      	adds	r2, r3, #0
 800fe90:	1c0b      	adds	r3, r1, #0
 800fe92:	4313      	orrs	r3, r2
 800fe94:	7363      	strb	r3, [r4, #13]
  /* wnd and chksum are set in tcp_output */
  seg->tcphdr->urgp = 0;
 800fe96:	693b      	ldr	r3, [r7, #16]
 800fe98:	691b      	ldr	r3, [r3, #16]
 800fe9a:	7c9a      	ldrb	r2, [r3, #18]
 800fe9c:	2100      	movs	r1, #0
 800fe9e:	400a      	ands	r2, r1
 800fea0:	749a      	strb	r2, [r3, #18]
 800fea2:	7cda      	ldrb	r2, [r3, #19]
 800fea4:	2100      	movs	r1, #0
 800fea6:	400a      	ands	r2, r1
 800fea8:	74da      	strb	r2, [r3, #19]
  return seg;
 800feaa:	693b      	ldr	r3, [r7, #16]
}
 800feac:	0018      	movs	r0, r3
 800feae:	46bd      	mov	sp, r7
 800feb0:	b007      	add	sp, #28
 800feb2:	bd90      	pop	{r4, r7, pc}
 800feb4:	08021684 	.word	0x08021684
 800feb8:	080216b0 	.word	0x080216b0
 800febc:	080216d0 	.word	0x080216d0
 800fec0:	080216fc 	.word	0x080216fc
 800fec4:	08021720 	.word	0x08021720
 800fec8:	08021738 	.word	0x08021738

0800fecc <tcp_pbuf_prealloc>:
#if TCP_OVERSIZE
static struct pbuf *
tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
                  u16_t *oversize, const struct tcp_pcb *pcb, u8_t apiflags,
                  u8_t first_seg)
{
 800fecc:	b590      	push	{r4, r7, lr}
 800fece:	b087      	sub	sp, #28
 800fed0:	af00      	add	r7, sp, #0
 800fed2:	0004      	movs	r4, r0
 800fed4:	0008      	movs	r0, r1
 800fed6:	0011      	movs	r1, r2
 800fed8:	607b      	str	r3, [r7, #4]
 800feda:	230f      	movs	r3, #15
 800fedc:	18fb      	adds	r3, r7, r3
 800fede:	1c22      	adds	r2, r4, #0
 800fee0:	701a      	strb	r2, [r3, #0]
 800fee2:	240c      	movs	r4, #12
 800fee4:	193b      	adds	r3, r7, r4
 800fee6:	1c02      	adds	r2, r0, #0
 800fee8:	801a      	strh	r2, [r3, #0]
 800feea:	230a      	movs	r3, #10
 800feec:	18fb      	adds	r3, r7, r3
 800feee:	1c0a      	adds	r2, r1, #0
 800fef0:	801a      	strh	r2, [r3, #0]
  struct pbuf *p;
  u16_t alloc = length;
 800fef2:	2316      	movs	r3, #22
 800fef4:	18fb      	adds	r3, r7, r3
 800fef6:	193a      	adds	r2, r7, r4
 800fef8:	8812      	ldrh	r2, [r2, #0]
 800fefa:	801a      	strh	r2, [r3, #0]

  LWIP_ASSERT("tcp_pbuf_prealloc: invalid oversize", oversize != NULL);
 800fefc:	687b      	ldr	r3, [r7, #4]
 800fefe:	2b00      	cmp	r3, #0
 800ff00:	d105      	bne.n	800ff0e <tcp_pbuf_prealloc+0x42>
 800ff02:	4b3a      	ldr	r3, [pc, #232]	; (800ffec <tcp_pbuf_prealloc+0x120>)
 800ff04:	493a      	ldr	r1, [pc, #232]	; (800fff0 <tcp_pbuf_prealloc+0x124>)
 800ff06:	483b      	ldr	r0, [pc, #236]	; (800fff4 <tcp_pbuf_prealloc+0x128>)
 800ff08:	22e8      	movs	r2, #232	; 0xe8
 800ff0a:	f7f2 f96b 	bl	80021e4 <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_pbuf_prealloc: invalid pcb", pcb != NULL);
 800ff0e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ff10:	2b00      	cmp	r3, #0
 800ff12:	d105      	bne.n	800ff20 <tcp_pbuf_prealloc+0x54>
 800ff14:	4b35      	ldr	r3, [pc, #212]	; (800ffec <tcp_pbuf_prealloc+0x120>)
 800ff16:	4938      	ldr	r1, [pc, #224]	; (800fff8 <tcp_pbuf_prealloc+0x12c>)
 800ff18:	4836      	ldr	r0, [pc, #216]	; (800fff4 <tcp_pbuf_prealloc+0x128>)
 800ff1a:	22e9      	movs	r2, #233	; 0xe9
 800ff1c:	f7f2 f962 	bl	80021e4 <app_debug_rtt_raw>
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(apiflags);
  LWIP_UNUSED_ARG(first_seg);
  alloc = max_length;
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (length < max_length) {
 800ff20:	230c      	movs	r3, #12
 800ff22:	18fa      	adds	r2, r7, r3
 800ff24:	230a      	movs	r3, #10
 800ff26:	18fb      	adds	r3, r7, r3
 800ff28:	8812      	ldrh	r2, [r2, #0]
 800ff2a:	881b      	ldrh	r3, [r3, #0]
 800ff2c:	429a      	cmp	r2, r3
 800ff2e:	d22a      	bcs.n	800ff86 <tcp_pbuf_prealloc+0xba>
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
 800ff30:	232c      	movs	r3, #44	; 0x2c
 800ff32:	18fb      	adds	r3, r7, r3
 800ff34:	781b      	ldrb	r3, [r3, #0]
 800ff36:	2202      	movs	r2, #2
 800ff38:	4013      	ands	r3, r2
 800ff3a:	d112      	bne.n	800ff62 <tcp_pbuf_prealloc+0x96>
        (!(pcb->flags & TF_NODELAY) &&
 800ff3c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ff3e:	8bdb      	ldrh	r3, [r3, #30]
 800ff40:	001a      	movs	r2, r3
 800ff42:	2340      	movs	r3, #64	; 0x40
 800ff44:	4013      	ands	r3, r2
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
 800ff46:	d11e      	bne.n	800ff86 <tcp_pbuf_prealloc+0xba>
        (!(pcb->flags & TF_NODELAY) &&
 800ff48:	2330      	movs	r3, #48	; 0x30
 800ff4a:	18fb      	adds	r3, r7, r3
 800ff4c:	781b      	ldrb	r3, [r3, #0]
 800ff4e:	2b00      	cmp	r3, #0
 800ff50:	d007      	beq.n	800ff62 <tcp_pbuf_prealloc+0x96>
         (!first_seg ||
          pcb->unsent != NULL ||
 800ff52:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ff54:	6f1b      	ldr	r3, [r3, #112]	; 0x70
         (!first_seg ||
 800ff56:	2b00      	cmp	r3, #0
 800ff58:	d103      	bne.n	800ff62 <tcp_pbuf_prealloc+0x96>
          pcb->unacked != NULL))) {
 800ff5a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ff5c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
          pcb->unsent != NULL ||
 800ff5e:	2b00      	cmp	r3, #0
 800ff60:	d011      	beq.n	800ff86 <tcp_pbuf_prealloc+0xba>
      alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(TCP_OVERSIZE_CALC_LENGTH(length)));
 800ff62:	230c      	movs	r3, #12
 800ff64:	18fb      	adds	r3, r7, r3
 800ff66:	881b      	ldrh	r3, [r3, #0]
 800ff68:	4a24      	ldr	r2, [pc, #144]	; (800fffc <tcp_pbuf_prealloc+0x130>)
 800ff6a:	4694      	mov	ip, r2
 800ff6c:	4463      	add	r3, ip
 800ff6e:	2203      	movs	r2, #3
 800ff70:	4393      	bics	r3, r2
 800ff72:	001a      	movs	r2, r3
 800ff74:	230a      	movs	r3, #10
 800ff76:	18fb      	adds	r3, r7, r3
 800ff78:	881b      	ldrh	r3, [r3, #0]
 800ff7a:	429a      	cmp	r2, r3
 800ff7c:	d900      	bls.n	800ff80 <tcp_pbuf_prealloc+0xb4>
 800ff7e:	001a      	movs	r2, r3
 800ff80:	2316      	movs	r3, #22
 800ff82:	18fb      	adds	r3, r7, r3
 800ff84:	801a      	strh	r2, [r3, #0]
    }
  }
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
 800ff86:	23a0      	movs	r3, #160	; 0xa0
 800ff88:	009a      	lsls	r2, r3, #2
 800ff8a:	2316      	movs	r3, #22
 800ff8c:	18fb      	adds	r3, r7, r3
 800ff8e:	8819      	ldrh	r1, [r3, #0]
 800ff90:	230f      	movs	r3, #15
 800ff92:	18fb      	adds	r3, r7, r3
 800ff94:	781b      	ldrb	r3, [r3, #0]
 800ff96:	0018      	movs	r0, r3
 800ff98:	f7f9 ff6a 	bl	8009e70 <pbuf_alloc>
 800ff9c:	0003      	movs	r3, r0
 800ff9e:	613b      	str	r3, [r7, #16]
  if (p == NULL) {
 800ffa0:	693b      	ldr	r3, [r7, #16]
 800ffa2:	2b00      	cmp	r3, #0
 800ffa4:	d101      	bne.n	800ffaa <tcp_pbuf_prealloc+0xde>
    return NULL;
 800ffa6:	2300      	movs	r3, #0
 800ffa8:	e01c      	b.n	800ffe4 <tcp_pbuf_prealloc+0x118>
  }
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
 800ffaa:	693b      	ldr	r3, [r7, #16]
 800ffac:	681b      	ldr	r3, [r3, #0]
 800ffae:	2b00      	cmp	r3, #0
 800ffb0:	d006      	beq.n	800ffc0 <tcp_pbuf_prealloc+0xf4>
 800ffb2:	4b0e      	ldr	r3, [pc, #56]	; (800ffec <tcp_pbuf_prealloc+0x120>)
 800ffb4:	220c      	movs	r2, #12
 800ffb6:	32ff      	adds	r2, #255	; 0xff
 800ffb8:	4911      	ldr	r1, [pc, #68]	; (8010000 <tcp_pbuf_prealloc+0x134>)
 800ffba:	480e      	ldr	r0, [pc, #56]	; (800fff4 <tcp_pbuf_prealloc+0x128>)
 800ffbc:	f7f2 f912 	bl	80021e4 <app_debug_rtt_raw>
  *oversize = p->len - length;
 800ffc0:	693b      	ldr	r3, [r7, #16]
 800ffc2:	895a      	ldrh	r2, [r3, #10]
 800ffc4:	210c      	movs	r1, #12
 800ffc6:	187b      	adds	r3, r7, r1
 800ffc8:	881b      	ldrh	r3, [r3, #0]
 800ffca:	1ad3      	subs	r3, r2, r3
 800ffcc:	b29a      	uxth	r2, r3
 800ffce:	687b      	ldr	r3, [r7, #4]
 800ffd0:	801a      	strh	r2, [r3, #0]
  /* trim p->len to the currently used size */
  p->len = p->tot_len = length;
 800ffd2:	693b      	ldr	r3, [r7, #16]
 800ffd4:	187a      	adds	r2, r7, r1
 800ffd6:	8812      	ldrh	r2, [r2, #0]
 800ffd8:	811a      	strh	r2, [r3, #8]
 800ffda:	693b      	ldr	r3, [r7, #16]
 800ffdc:	891a      	ldrh	r2, [r3, #8]
 800ffde:	693b      	ldr	r3, [r7, #16]
 800ffe0:	815a      	strh	r2, [r3, #10]
  return p;
 800ffe2:	693b      	ldr	r3, [r7, #16]
}
 800ffe4:	0018      	movs	r0, r3
 800ffe6:	46bd      	mov	sp, r7
 800ffe8:	b007      	add	sp, #28
 800ffea:	bd90      	pop	{r4, r7, pc}
 800ffec:	08021684 	.word	0x08021684
 800fff0:	0802176c 	.word	0x0802176c
 800fff4:	080216d0 	.word	0x080216d0
 800fff8:	08021790 	.word	0x08021790
 800fffc:	0000021b 	.word	0x0000021b
 8010000:	080217b0 	.word	0x080217b0

08010004 <tcp_seg_add_chksum>:
 * Called by tcp_write and tcp_split_unsent_seg.
 */
static void
tcp_seg_add_chksum(u16_t chksum, u16_t len, u16_t *seg_chksum,
                   u8_t *seg_chksum_swapped)
{
 8010004:	b5b0      	push	{r4, r5, r7, lr}
 8010006:	b086      	sub	sp, #24
 8010008:	af00      	add	r7, sp, #0
 801000a:	60ba      	str	r2, [r7, #8]
 801000c:	607b      	str	r3, [r7, #4]
 801000e:	240e      	movs	r4, #14
 8010010:	193b      	adds	r3, r7, r4
 8010012:	1c02      	adds	r2, r0, #0
 8010014:	801a      	strh	r2, [r3, #0]
 8010016:	250c      	movs	r5, #12
 8010018:	197b      	adds	r3, r7, r5
 801001a:	1c0a      	adds	r2, r1, #0
 801001c:	801a      	strh	r2, [r3, #0]
  u32_t helper;
  /* add chksum to old chksum and fold to u16_t */
  helper = chksum + *seg_chksum;
 801001e:	0020      	movs	r0, r4
 8010020:	183b      	adds	r3, r7, r0
 8010022:	881b      	ldrh	r3, [r3, #0]
 8010024:	68ba      	ldr	r2, [r7, #8]
 8010026:	8812      	ldrh	r2, [r2, #0]
 8010028:	189b      	adds	r3, r3, r2
 801002a:	617b      	str	r3, [r7, #20]
  chksum = FOLD_U32T(helper);
 801002c:	697b      	ldr	r3, [r7, #20]
 801002e:	0c1b      	lsrs	r3, r3, #16
 8010030:	b299      	uxth	r1, r3
 8010032:	697b      	ldr	r3, [r7, #20]
 8010034:	b29a      	uxth	r2, r3
 8010036:	183b      	adds	r3, r7, r0
 8010038:	188a      	adds	r2, r1, r2
 801003a:	801a      	strh	r2, [r3, #0]
  if ((len & 1) != 0) {
 801003c:	197b      	adds	r3, r7, r5
 801003e:	881b      	ldrh	r3, [r3, #0]
 8010040:	2201      	movs	r2, #1
 8010042:	4013      	ands	r3, r2
 8010044:	d013      	beq.n	801006e <tcp_seg_add_chksum+0x6a>
    *seg_chksum_swapped = 1 - *seg_chksum_swapped;
 8010046:	687b      	ldr	r3, [r7, #4]
 8010048:	781b      	ldrb	r3, [r3, #0]
 801004a:	2201      	movs	r2, #1
 801004c:	1ad3      	subs	r3, r2, r3
 801004e:	b2da      	uxtb	r2, r3
 8010050:	687b      	ldr	r3, [r7, #4]
 8010052:	701a      	strb	r2, [r3, #0]
    chksum = SWAP_BYTES_IN_WORD(chksum);
 8010054:	183b      	adds	r3, r7, r0
 8010056:	881b      	ldrh	r3, [r3, #0]
 8010058:	021b      	lsls	r3, r3, #8
 801005a:	b21a      	sxth	r2, r3
 801005c:	183b      	adds	r3, r7, r0
 801005e:	881b      	ldrh	r3, [r3, #0]
 8010060:	0a1b      	lsrs	r3, r3, #8
 8010062:	b29b      	uxth	r3, r3
 8010064:	b21b      	sxth	r3, r3
 8010066:	4313      	orrs	r3, r2
 8010068:	b21a      	sxth	r2, r3
 801006a:	183b      	adds	r3, r7, r0
 801006c:	801a      	strh	r2, [r3, #0]
  }
  *seg_chksum = chksum;
 801006e:	68bb      	ldr	r3, [r7, #8]
 8010070:	220e      	movs	r2, #14
 8010072:	18ba      	adds	r2, r7, r2
 8010074:	8812      	ldrh	r2, [r2, #0]
 8010076:	801a      	strh	r2, [r3, #0]
}
 8010078:	46c0      	nop			; (mov r8, r8)
 801007a:	46bd      	mov	sp, r7
 801007c:	b006      	add	sp, #24
 801007e:	bdb0      	pop	{r4, r5, r7, pc}

08010080 <tcp_write_checks>:
 * @param len length of data to send (checked agains snd_buf)
 * @return ERR_OK if tcp_write is allowed to proceed, another err_t otherwise
 */
static err_t
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
 8010080:	b580      	push	{r7, lr}
 8010082:	b082      	sub	sp, #8
 8010084:	af00      	add	r7, sp, #0
 8010086:	6078      	str	r0, [r7, #4]
 8010088:	000a      	movs	r2, r1
 801008a:	1cbb      	adds	r3, r7, #2
 801008c:	801a      	strh	r2, [r3, #0]
  LWIP_ASSERT("tcp_write_checks: invalid pcb", pcb != NULL);
 801008e:	687b      	ldr	r3, [r7, #4]
 8010090:	2b00      	cmp	r3, #0
 8010092:	d106      	bne.n	80100a2 <tcp_write_checks+0x22>
 8010094:	4b34      	ldr	r3, [pc, #208]	; (8010168 <tcp_write_checks+0xe8>)
 8010096:	2234      	movs	r2, #52	; 0x34
 8010098:	32ff      	adds	r2, #255	; 0xff
 801009a:	4934      	ldr	r1, [pc, #208]	; (801016c <tcp_write_checks+0xec>)
 801009c:	4834      	ldr	r0, [pc, #208]	; (8010170 <tcp_write_checks+0xf0>)
 801009e:	f7f2 f8a1 	bl	80021e4 <app_debug_rtt_raw>

  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
 80100a2:	687b      	ldr	r3, [r7, #4]
 80100a4:	7e1b      	ldrb	r3, [r3, #24]
 80100a6:	2b04      	cmp	r3, #4
 80100a8:	d00e      	beq.n	80100c8 <tcp_write_checks+0x48>
      (pcb->state != CLOSE_WAIT) &&
 80100aa:	687b      	ldr	r3, [r7, #4]
 80100ac:	7e1b      	ldrb	r3, [r3, #24]
  if ((pcb->state != ESTABLISHED) &&
 80100ae:	2b07      	cmp	r3, #7
 80100b0:	d00a      	beq.n	80100c8 <tcp_write_checks+0x48>
      (pcb->state != SYN_SENT) &&
 80100b2:	687b      	ldr	r3, [r7, #4]
 80100b4:	7e1b      	ldrb	r3, [r3, #24]
      (pcb->state != CLOSE_WAIT) &&
 80100b6:	2b02      	cmp	r3, #2
 80100b8:	d006      	beq.n	80100c8 <tcp_write_checks+0x48>
      (pcb->state != SYN_RCVD)) {
 80100ba:	687b      	ldr	r3, [r7, #4]
 80100bc:	7e1b      	ldrb	r3, [r3, #24]
      (pcb->state != SYN_SENT) &&
 80100be:	2b03      	cmp	r3, #3
 80100c0:	d002      	beq.n	80100c8 <tcp_write_checks+0x48>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
 80100c2:	230b      	movs	r3, #11
 80100c4:	425b      	negs	r3, r3
 80100c6:	e04a      	b.n	801015e <tcp_write_checks+0xde>
  } else if (len == 0) {
 80100c8:	1cbb      	adds	r3, r7, #2
 80100ca:	881b      	ldrh	r3, [r3, #0]
 80100cc:	2b00      	cmp	r3, #0
 80100ce:	d101      	bne.n	80100d4 <tcp_write_checks+0x54>
    return ERR_OK;
 80100d0:	2300      	movs	r3, #0
 80100d2:	e044      	b.n	801015e <tcp_write_checks+0xde>
  }

  /* fail on too much data */
  if (len > pcb->snd_buf) {
 80100d4:	687b      	ldr	r3, [r7, #4]
 80100d6:	2268      	movs	r2, #104	; 0x68
 80100d8:	5a9b      	ldrh	r3, [r3, r2]
 80100da:	1cba      	adds	r2, r7, #2
 80100dc:	8812      	ldrh	r2, [r2, #0]
 80100de:	429a      	cmp	r2, r3
 80100e0:	d909      	bls.n	80100f6 <tcp_write_checks+0x76>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("tcp_write: too much data (len=%"U16_F" > snd_buf=%"TCPWNDSIZE_F")\n",
                len, pcb->snd_buf));
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
 80100e2:	687b      	ldr	r3, [r7, #4]
 80100e4:	8bdb      	ldrh	r3, [r3, #30]
 80100e6:	2280      	movs	r2, #128	; 0x80
 80100e8:	4313      	orrs	r3, r2
 80100ea:	b29a      	uxth	r2, r3
 80100ec:	687b      	ldr	r3, [r7, #4]
 80100ee:	83da      	strh	r2, [r3, #30]
    return ERR_MEM;
 80100f0:	2301      	movs	r3, #1
 80100f2:	425b      	negs	r3, r3
 80100f4:	e033      	b.n	801015e <tcp_write_checks+0xde>
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"TCPWNDSIZE_F"\n", (tcpwnd_size_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  /* check for configured max queuelen and possible overflow */
  if (pcb->snd_queuelen >= LWIP_MIN(TCP_SND_QUEUELEN, (TCP_SNDQUEUELEN_OVERFLOW + 1))) {
 80100f6:	687b      	ldr	r3, [r7, #4]
 80100f8:	226a      	movs	r2, #106	; 0x6a
 80100fa:	5a9b      	ldrh	r3, [r3, r2]
 80100fc:	2b07      	cmp	r3, #7
 80100fe:	d909      	bls.n	8010114 <tcp_write_checks+0x94>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("tcp_write: too long queue %"U16_F" (max %"U16_F")\n",
                pcb->snd_queuelen, (u16_t)TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
 8010100:	687b      	ldr	r3, [r7, #4]
 8010102:	8bdb      	ldrh	r3, [r3, #30]
 8010104:	2280      	movs	r2, #128	; 0x80
 8010106:	4313      	orrs	r3, r2
 8010108:	b29a      	uxth	r2, r3
 801010a:	687b      	ldr	r3, [r7, #4]
 801010c:	83da      	strh	r2, [r3, #30]
    return ERR_MEM;
 801010e:	2301      	movs	r3, #1
 8010110:	425b      	negs	r3, r3
 8010112:	e024      	b.n	801015e <tcp_write_checks+0xde>
  }
  if (pcb->snd_queuelen != 0) {
 8010114:	687b      	ldr	r3, [r7, #4]
 8010116:	226a      	movs	r2, #106	; 0x6a
 8010118:	5a9b      	ldrh	r3, [r3, r2]
 801011a:	2b00      	cmp	r3, #0
 801011c:	d00f      	beq.n	801013e <tcp_write_checks+0xbe>
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
 801011e:	687b      	ldr	r3, [r7, #4]
 8010120:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8010122:	2b00      	cmp	r3, #0
 8010124:	d11a      	bne.n	801015c <tcp_write_checks+0xdc>
 8010126:	687b      	ldr	r3, [r7, #4]
 8010128:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801012a:	2b00      	cmp	r3, #0
 801012c:	d116      	bne.n	801015c <tcp_write_checks+0xdc>
 801012e:	4b0e      	ldr	r3, [pc, #56]	; (8010168 <tcp_write_checks+0xe8>)
 8010130:	2256      	movs	r2, #86	; 0x56
 8010132:	32ff      	adds	r2, #255	; 0xff
 8010134:	490f      	ldr	r1, [pc, #60]	; (8010174 <tcp_write_checks+0xf4>)
 8010136:	480e      	ldr	r0, [pc, #56]	; (8010170 <tcp_write_checks+0xf0>)
 8010138:	f7f2 f854 	bl	80021e4 <app_debug_rtt_raw>
 801013c:	e00e      	b.n	801015c <tcp_write_checks+0xdc>
                pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
 801013e:	687b      	ldr	r3, [r7, #4]
 8010140:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8010142:	2b00      	cmp	r3, #0
 8010144:	d103      	bne.n	801014e <tcp_write_checks+0xce>
 8010146:	687b      	ldr	r3, [r7, #4]
 8010148:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801014a:	2b00      	cmp	r3, #0
 801014c:	d006      	beq.n	801015c <tcp_write_checks+0xdc>
 801014e:	4b06      	ldr	r3, [pc, #24]	; (8010168 <tcp_write_checks+0xe8>)
 8010150:	22ac      	movs	r2, #172	; 0xac
 8010152:	0052      	lsls	r2, r2, #1
 8010154:	4908      	ldr	r1, [pc, #32]	; (8010178 <tcp_write_checks+0xf8>)
 8010156:	4806      	ldr	r0, [pc, #24]	; (8010170 <tcp_write_checks+0xf0>)
 8010158:	f7f2 f844 	bl	80021e4 <app_debug_rtt_raw>
                pcb->unacked == NULL && pcb->unsent == NULL);
  }
  return ERR_OK;
 801015c:	2300      	movs	r3, #0
}
 801015e:	0018      	movs	r0, r3
 8010160:	46bd      	mov	sp, r7
 8010162:	b002      	add	sp, #8
 8010164:	bd80      	pop	{r7, pc}
 8010166:	46c0      	nop			; (mov r8, r8)
 8010168:	08021684 	.word	0x08021684
 801016c:	080217c4 	.word	0x080217c4
 8010170:	080216d0 	.word	0x080216d0
 8010174:	080217e4 	.word	0x080217e4
 8010178:	08021820 	.word	0x08021820

0801017c <tcp_write>:
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will not be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
 801017c:	b5b0      	push	{r4, r5, r7, lr}
 801017e:	b09e      	sub	sp, #120	; 0x78
 8010180:	af04      	add	r7, sp, #16
 8010182:	60f8      	str	r0, [r7, #12]
 8010184:	60b9      	str	r1, [r7, #8]
 8010186:	0019      	movs	r1, r3
 8010188:	1dbb      	adds	r3, r7, #6
 801018a:	801a      	strh	r2, [r3, #0]
 801018c:	1d7b      	adds	r3, r7, #5
 801018e:	1c0a      	adds	r2, r1, #0
 8010190:	701a      	strb	r2, [r3, #0]
  struct pbuf *concat_p = NULL;
 8010192:	2300      	movs	r3, #0
 8010194:	64bb      	str	r3, [r7, #72]	; 0x48
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 8010196:	2300      	movs	r3, #0
 8010198:	64fb      	str	r3, [r7, #76]	; 0x4c
 801019a:	2300      	movs	r3, #0
 801019c:	65fb      	str	r3, [r7, #92]	; 0x5c
 801019e:	2300      	movs	r3, #0
 80101a0:	65bb      	str	r3, [r7, #88]	; 0x58
 80101a2:	2300      	movs	r3, #0
 80101a4:	657b      	str	r3, [r7, #84]	; 0x54
  u16_t pos = 0; /* position in 'arg' data */
 80101a6:	2352      	movs	r3, #82	; 0x52
 80101a8:	18fb      	adds	r3, r7, r3
 80101aa:	2200      	movs	r2, #0
 80101ac:	801a      	strh	r2, [r3, #0]
  u16_t queuelen;
  u8_t optlen;
  u8_t optflags = 0;
 80101ae:	2333      	movs	r3, #51	; 0x33
 80101b0:	18fb      	adds	r3, r7, r3
 80101b2:	2200      	movs	r2, #0
 80101b4:	701a      	strb	r2, [r3, #0]
#if TCP_OVERSIZE
  u16_t oversize = 0;
 80101b6:	231e      	movs	r3, #30
 80101b8:	18fb      	adds	r3, r7, r3
 80101ba:	2200      	movs	r2, #0
 80101bc:	801a      	strh	r2, [r3, #0]
  u16_t oversize_used = 0;
 80101be:	2362      	movs	r3, #98	; 0x62
 80101c0:	18fb      	adds	r3, r7, r3
 80101c2:	2200      	movs	r2, #0
 80101c4:	801a      	strh	r2, [r3, #0]
#if TCP_OVERSIZE_DBGCHECK
  u16_t oversize_add = 0;
 80101c6:	2366      	movs	r3, #102	; 0x66
 80101c8:	18fb      	adds	r3, r7, r3
 80101ca:	2200      	movs	r2, #0
 80101cc:	801a      	strh	r2, [r3, #0]
#endif /* TCP_OVERSIZE_DBGCHECK*/
#endif /* TCP_OVERSIZE */
  u16_t extendlen = 0;
 80101ce:	2364      	movs	r3, #100	; 0x64
 80101d0:	18fb      	adds	r3, r7, r3
 80101d2:	2200      	movs	r2, #0
 80101d4:	801a      	strh	r2, [r3, #0]
#if TCP_CHECKSUM_ON_COPY
  u16_t concat_chksum = 0;
 80101d6:	231c      	movs	r3, #28
 80101d8:	18fb      	adds	r3, r7, r3
 80101da:	2200      	movs	r2, #0
 80101dc:	801a      	strh	r2, [r3, #0]
  u8_t concat_chksum_swapped = 0;
 80101de:	231b      	movs	r3, #27
 80101e0:	18fb      	adds	r3, r7, r3
 80101e2:	2200      	movs	r2, #0
 80101e4:	701a      	strb	r2, [r3, #0]
  u16_t concat_chksummed = 0;
 80101e6:	2346      	movs	r3, #70	; 0x46
 80101e8:	18fb      	adds	r3, r7, r3
 80101ea:	2200      	movs	r2, #0
 80101ec:	801a      	strh	r2, [r3, #0]
#endif /* TCP_CHECKSUM_ON_COPY */
  err_t err;
  u16_t mss_local;

  LWIP_ERROR("tcp_write: invalid pcb", pcb != NULL, return ERR_ARG);
 80101ee:	68fb      	ldr	r3, [r7, #12]
 80101f0:	2b00      	cmp	r3, #0
 80101f2:	d107      	bne.n	8010204 <tcp_write+0x88>
 80101f4:	4bca      	ldr	r3, [pc, #808]	; (8010520 <tcp_write+0x3a4>)
 80101f6:	0018      	movs	r0, r3
 80101f8:	f7f1 fff4 	bl	80021e4 <app_debug_rtt_raw>
 80101fc:	2310      	movs	r3, #16
 80101fe:	425b      	negs	r3, r3
 8010200:	f000 fcfb 	bl	8010bfa <tcp_write+0xa7e>

  /* don't allocate segments bigger than half the maximum window we ever received */
  mss_local = LWIP_MIN(pcb->mss, TCPWND_MIN16(pcb->snd_wnd_max / 2));
 8010204:	68fb      	ldr	r3, [r7, #12]
 8010206:	2266      	movs	r2, #102	; 0x66
 8010208:	5a9b      	ldrh	r3, [r3, r2]
 801020a:	085b      	lsrs	r3, r3, #1
 801020c:	b299      	uxth	r1, r3
 801020e:	68fb      	ldr	r3, [r7, #12]
 8010210:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8010212:	2230      	movs	r2, #48	; 0x30
 8010214:	18ba      	adds	r2, r7, r2
 8010216:	1c1c      	adds	r4, r3, #0
 8010218:	1c0b      	adds	r3, r1, #0
 801021a:	b298      	uxth	r0, r3
 801021c:	b2a1      	uxth	r1, r4
 801021e:	4288      	cmp	r0, r1
 8010220:	d900      	bls.n	8010224 <tcp_write+0xa8>
 8010222:	1c23      	adds	r3, r4, #0
 8010224:	8013      	strh	r3, [r2, #0]
  mss_local = mss_local ? mss_local : pcb->mss;
 8010226:	2330      	movs	r3, #48	; 0x30
 8010228:	18fb      	adds	r3, r7, r3
 801022a:	881b      	ldrh	r3, [r3, #0]
 801022c:	2b00      	cmp	r3, #0
 801022e:	d102      	bne.n	8010236 <tcp_write+0xba>
 8010230:	68fb      	ldr	r3, [r7, #12]
 8010232:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8010234:	e002      	b.n	801023c <tcp_write+0xc0>
 8010236:	2330      	movs	r3, #48	; 0x30
 8010238:	18fb      	adds	r3, r7, r3
 801023a:	881b      	ldrh	r3, [r3, #0]
 801023c:	2230      	movs	r2, #48	; 0x30
 801023e:	18ba      	adds	r2, r7, r2
 8010240:	8013      	strh	r3, [r2, #0]
  apiflags |= TCP_WRITE_FLAG_COPY;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
                                 (void *)pcb, arg, len, (u16_t)apiflags));
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)",
 8010242:	68bb      	ldr	r3, [r7, #8]
 8010244:	2b00      	cmp	r3, #0
 8010246:	d107      	bne.n	8010258 <tcp_write+0xdc>
 8010248:	4bb6      	ldr	r3, [pc, #728]	; (8010524 <tcp_write+0x3a8>)
 801024a:	0018      	movs	r0, r3
 801024c:	f7f1 ffca 	bl	80021e4 <app_debug_rtt_raw>
 8010250:	2310      	movs	r3, #16
 8010252:	425b      	negs	r3, r3
 8010254:	f000 fcd1 	bl	8010bfa <tcp_write+0xa7e>
             arg != NULL, return ERR_ARG;);

  err = tcp_write_checks(pcb, len);
 8010258:	252f      	movs	r5, #47	; 0x2f
 801025a:	197c      	adds	r4, r7, r5
 801025c:	1dbb      	adds	r3, r7, #6
 801025e:	881a      	ldrh	r2, [r3, #0]
 8010260:	68fb      	ldr	r3, [r7, #12]
 8010262:	0011      	movs	r1, r2
 8010264:	0018      	movs	r0, r3
 8010266:	f7ff ff0b 	bl	8010080 <tcp_write_checks>
 801026a:	0003      	movs	r3, r0
 801026c:	7023      	strb	r3, [r4, #0]
  if (err != ERR_OK) {
 801026e:	197b      	adds	r3, r7, r5
 8010270:	781b      	ldrb	r3, [r3, #0]
 8010272:	b25b      	sxtb	r3, r3
 8010274:	2b00      	cmp	r3, #0
 8010276:	d004      	beq.n	8010282 <tcp_write+0x106>
    return err;
 8010278:	197b      	adds	r3, r7, r5
 801027a:	781b      	ldrb	r3, [r3, #0]
 801027c:	b25b      	sxtb	r3, r3
 801027e:	f000 fcbc 	bl	8010bfa <tcp_write+0xa7e>
  }
  queuelen = pcb->snd_queuelen;
 8010282:	2350      	movs	r3, #80	; 0x50
 8010284:	18fb      	adds	r3, r7, r3
 8010286:	68fa      	ldr	r2, [r7, #12]
 8010288:	216a      	movs	r1, #106	; 0x6a
 801028a:	5a52      	ldrh	r2, [r2, r1]
 801028c:	801a      	strh	r2, [r3, #0]
    /* ensure that segments can hold at least one data byte... */
    mss_local = LWIP_MAX(mss_local, LWIP_TCP_OPT_LEN_TS + 1);
  } else
#endif /* LWIP_TCP_TIMESTAMPS */
  {
    optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
 801028e:	232e      	movs	r3, #46	; 0x2e
 8010290:	18fb      	adds	r3, r7, r3
 8010292:	2200      	movs	r2, #0
 8010294:	701a      	strb	r2, [r3, #0]
   *
   * pos records progress as data is segmented.
   */

  /* Find the tail of the unsent queue. */
  if (pcb->unsent != NULL) {
 8010296:	68fb      	ldr	r3, [r7, #12]
 8010298:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801029a:	2b00      	cmp	r3, #0
 801029c:	d100      	bne.n	80102a0 <tcp_write+0x124>
 801029e:	e19e      	b.n	80105de <tcp_write+0x462>
    u16_t space;
    u16_t unsent_optlen;

    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 80102a0:	68fb      	ldr	r3, [r7, #12]
 80102a2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80102a4:	64fb      	str	r3, [r7, #76]	; 0x4c
 80102a6:	e002      	b.n	80102ae <tcp_write+0x132>
         last_unsent = last_unsent->next);
 80102a8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80102aa:	681b      	ldr	r3, [r3, #0]
 80102ac:	64fb      	str	r3, [r7, #76]	; 0x4c
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 80102ae:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80102b0:	681b      	ldr	r3, [r3, #0]
 80102b2:	2b00      	cmp	r3, #0
 80102b4:	d1f8      	bne.n	80102a8 <tcp_write+0x12c>

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(last_unsent->flags, pcb);
 80102b6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80102b8:	7bdb      	ldrb	r3, [r3, #15]
 80102ba:	009b      	lsls	r3, r3, #2
 80102bc:	b29a      	uxth	r2, r3
 80102be:	202c      	movs	r0, #44	; 0x2c
 80102c0:	183b      	adds	r3, r7, r0
 80102c2:	2104      	movs	r1, #4
 80102c4:	400a      	ands	r2, r1
 80102c6:	801a      	strh	r2, [r3, #0]
    LWIP_ASSERT("mss_local is too small", mss_local >= last_unsent->len + unsent_optlen);
 80102c8:	2330      	movs	r3, #48	; 0x30
 80102ca:	18fb      	adds	r3, r7, r3
 80102cc:	881a      	ldrh	r2, [r3, #0]
 80102ce:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80102d0:	891b      	ldrh	r3, [r3, #8]
 80102d2:	0019      	movs	r1, r3
 80102d4:	183b      	adds	r3, r7, r0
 80102d6:	881b      	ldrh	r3, [r3, #0]
 80102d8:	18cb      	adds	r3, r1, r3
 80102da:	429a      	cmp	r2, r3
 80102dc:	da06      	bge.n	80102ec <tcp_write+0x170>
 80102de:	4b92      	ldr	r3, [pc, #584]	; (8010528 <tcp_write+0x3ac>)
 80102e0:	22f3      	movs	r2, #243	; 0xf3
 80102e2:	0052      	lsls	r2, r2, #1
 80102e4:	4991      	ldr	r1, [pc, #580]	; (801052c <tcp_write+0x3b0>)
 80102e6:	4892      	ldr	r0, [pc, #584]	; (8010530 <tcp_write+0x3b4>)
 80102e8:	f7f1 ff7c 	bl	80021e4 <app_debug_rtt_raw>
    space = mss_local - (last_unsent->len + unsent_optlen);
 80102ec:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80102ee:	891a      	ldrh	r2, [r3, #8]
 80102f0:	232c      	movs	r3, #44	; 0x2c
 80102f2:	18fb      	adds	r3, r7, r3
 80102f4:	881b      	ldrh	r3, [r3, #0]
 80102f6:	18d3      	adds	r3, r2, r3
 80102f8:	b29a      	uxth	r2, r3
 80102fa:	2344      	movs	r3, #68	; 0x44
 80102fc:	18fb      	adds	r3, r7, r3
 80102fe:	2130      	movs	r1, #48	; 0x30
 8010300:	1879      	adds	r1, r7, r1
 8010302:	8809      	ldrh	r1, [r1, #0]
 8010304:	1a8a      	subs	r2, r1, r2
 8010306:	801a      	strh	r2, [r3, #0]
     * function.
     */
#if TCP_OVERSIZE
#if TCP_OVERSIZE_DBGCHECK
    /* check that pcb->unsent_oversize matches last_unsent->oversize_left */
    LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
 8010308:	68fb      	ldr	r3, [r7, #12]
 801030a:	226c      	movs	r2, #108	; 0x6c
 801030c:	5a9a      	ldrh	r2, [r3, r2]
 801030e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010310:	895b      	ldrh	r3, [r3, #10]
 8010312:	429a      	cmp	r2, r3
 8010314:	d006      	beq.n	8010324 <tcp_write+0x1a8>
 8010316:	4b84      	ldr	r3, [pc, #528]	; (8010528 <tcp_write+0x3ac>)
 8010318:	22f4      	movs	r2, #244	; 0xf4
 801031a:	32ff      	adds	r2, #255	; 0xff
 801031c:	4985      	ldr	r1, [pc, #532]	; (8010534 <tcp_write+0x3b8>)
 801031e:	4884      	ldr	r0, [pc, #528]	; (8010530 <tcp_write+0x3b4>)
 8010320:	f7f1 ff60 	bl	80021e4 <app_debug_rtt_raw>
                pcb->unsent_oversize == last_unsent->oversize_left);
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
 8010324:	68fb      	ldr	r3, [r7, #12]
 8010326:	226c      	movs	r2, #108	; 0x6c
 8010328:	5a9a      	ldrh	r2, [r3, r2]
 801032a:	211e      	movs	r1, #30
 801032c:	187b      	adds	r3, r7, r1
 801032e:	801a      	strh	r2, [r3, #0]
    if (oversize > 0) {
 8010330:	000a      	movs	r2, r1
 8010332:	18bb      	adds	r3, r7, r2
 8010334:	881b      	ldrh	r3, [r3, #0]
 8010336:	2b00      	cmp	r3, #0
 8010338:	d041      	beq.n	80103be <tcp_write+0x242>
      LWIP_ASSERT("inconsistent oversize vs. space", oversize <= space);
 801033a:	18bb      	adds	r3, r7, r2
 801033c:	881b      	ldrh	r3, [r3, #0]
 801033e:	2244      	movs	r2, #68	; 0x44
 8010340:	18ba      	adds	r2, r7, r2
 8010342:	8812      	ldrh	r2, [r2, #0]
 8010344:	429a      	cmp	r2, r3
 8010346:	d206      	bcs.n	8010356 <tcp_write+0x1da>
 8010348:	4b77      	ldr	r3, [pc, #476]	; (8010528 <tcp_write+0x3ac>)
 801034a:	22fc      	movs	r2, #252	; 0xfc
 801034c:	0052      	lsls	r2, r2, #1
 801034e:	497a      	ldr	r1, [pc, #488]	; (8010538 <tcp_write+0x3bc>)
 8010350:	4877      	ldr	r0, [pc, #476]	; (8010530 <tcp_write+0x3b4>)
 8010352:	f7f1 ff47 	bl	80021e4 <app_debug_rtt_raw>
      seg = last_unsent;
 8010356:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010358:	65fb      	str	r3, [r7, #92]	; 0x5c
      oversize_used = LWIP_MIN(space, LWIP_MIN(oversize, len));
 801035a:	231e      	movs	r3, #30
 801035c:	18fb      	adds	r3, r7, r3
 801035e:	881a      	ldrh	r2, [r3, #0]
 8010360:	1dbb      	adds	r3, r7, #6
 8010362:	1c10      	adds	r0, r2, #0
 8010364:	881b      	ldrh	r3, [r3, #0]
 8010366:	b299      	uxth	r1, r3
 8010368:	b282      	uxth	r2, r0
 801036a:	4291      	cmp	r1, r2
 801036c:	d900      	bls.n	8010370 <tcp_write+0x1f4>
 801036e:	1c03      	adds	r3, r0, #0
 8010370:	b299      	uxth	r1, r3
 8010372:	2362      	movs	r3, #98	; 0x62
 8010374:	18fa      	adds	r2, r7, r3
 8010376:	2344      	movs	r3, #68	; 0x44
 8010378:	18fb      	adds	r3, r7, r3
 801037a:	1c0c      	adds	r4, r1, #0
 801037c:	881b      	ldrh	r3, [r3, #0]
 801037e:	b298      	uxth	r0, r3
 8010380:	b2a1      	uxth	r1, r4
 8010382:	4288      	cmp	r0, r1
 8010384:	d900      	bls.n	8010388 <tcp_write+0x20c>
 8010386:	1c23      	adds	r3, r4, #0
 8010388:	8013      	strh	r3, [r2, #0]
      pos += oversize_used;
 801038a:	2252      	movs	r2, #82	; 0x52
 801038c:	18bb      	adds	r3, r7, r2
 801038e:	18b9      	adds	r1, r7, r2
 8010390:	2062      	movs	r0, #98	; 0x62
 8010392:	183a      	adds	r2, r7, r0
 8010394:	8809      	ldrh	r1, [r1, #0]
 8010396:	8812      	ldrh	r2, [r2, #0]
 8010398:	188a      	adds	r2, r1, r2
 801039a:	801a      	strh	r2, [r3, #0]
      oversize -= oversize_used;
 801039c:	211e      	movs	r1, #30
 801039e:	187b      	adds	r3, r7, r1
 80103a0:	881a      	ldrh	r2, [r3, #0]
 80103a2:	183b      	adds	r3, r7, r0
 80103a4:	881b      	ldrh	r3, [r3, #0]
 80103a6:	1ad3      	subs	r3, r2, r3
 80103a8:	b29a      	uxth	r2, r3
 80103aa:	187b      	adds	r3, r7, r1
 80103ac:	801a      	strh	r2, [r3, #0]
      space -= oversize_used;
 80103ae:	2244      	movs	r2, #68	; 0x44
 80103b0:	18bb      	adds	r3, r7, r2
 80103b2:	18b9      	adds	r1, r7, r2
 80103b4:	183a      	adds	r2, r7, r0
 80103b6:	8809      	ldrh	r1, [r1, #0]
 80103b8:	8812      	ldrh	r2, [r2, #0]
 80103ba:	1a8a      	subs	r2, r1, r2
 80103bc:	801a      	strh	r2, [r3, #0]
    }
    /* now we are either finished or oversize is zero */
    LWIP_ASSERT("inconsistent oversize vs. len", (oversize == 0) || (pos == len));
 80103be:	231e      	movs	r3, #30
 80103c0:	18fb      	adds	r3, r7, r3
 80103c2:	881b      	ldrh	r3, [r3, #0]
 80103c4:	2b00      	cmp	r3, #0
 80103c6:	d00d      	beq.n	80103e4 <tcp_write+0x268>
 80103c8:	2352      	movs	r3, #82	; 0x52
 80103ca:	18fa      	adds	r2, r7, r3
 80103cc:	1dbb      	adds	r3, r7, #6
 80103ce:	8812      	ldrh	r2, [r2, #0]
 80103d0:	881b      	ldrh	r3, [r3, #0]
 80103d2:	429a      	cmp	r2, r3
 80103d4:	d006      	beq.n	80103e4 <tcp_write+0x268>
 80103d6:	4b54      	ldr	r3, [pc, #336]	; (8010528 <tcp_write+0x3ac>)
 80103d8:	2280      	movs	r2, #128	; 0x80
 80103da:	0092      	lsls	r2, r2, #2
 80103dc:	4957      	ldr	r1, [pc, #348]	; (801053c <tcp_write+0x3c0>)
 80103de:	4854      	ldr	r0, [pc, #336]	; (8010530 <tcp_write+0x3b4>)
 80103e0:	f7f1 ff00 	bl	80021e4 <app_debug_rtt_raw>
     *
     * This phase is skipped for LWIP_NETIF_TX_SINGLE_PBUF as we could only execute
     * it after rexmit puts a segment from unacked to unsent and at this point,
     * oversize info is lost.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
 80103e4:	2152      	movs	r1, #82	; 0x52
 80103e6:	187a      	adds	r2, r7, r1
 80103e8:	1dbb      	adds	r3, r7, #6
 80103ea:	8812      	ldrh	r2, [r2, #0]
 80103ec:	881b      	ldrh	r3, [r3, #0]
 80103ee:	429a      	cmp	r2, r3
 80103f0:	d300      	bcc.n	80103f4 <tcp_write+0x278>
 80103f2:	e23b      	b.n	801086c <tcp_write+0x6f0>
 80103f4:	2044      	movs	r0, #68	; 0x44
 80103f6:	183b      	adds	r3, r7, r0
 80103f8:	881b      	ldrh	r3, [r3, #0]
 80103fa:	2b00      	cmp	r3, #0
 80103fc:	d100      	bne.n	8010400 <tcp_write+0x284>
 80103fe:	e235      	b.n	801086c <tcp_write+0x6f0>
 8010400:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010402:	891b      	ldrh	r3, [r3, #8]
 8010404:	2b00      	cmp	r3, #0
 8010406:	d100      	bne.n	801040a <tcp_write+0x28e>
 8010408:	e230      	b.n	801086c <tcp_write+0x6f0>
      u16_t seglen = LWIP_MIN(space, len - pos);
 801040a:	1dbb      	adds	r3, r7, #6
 801040c:	881a      	ldrh	r2, [r3, #0]
 801040e:	187b      	adds	r3, r7, r1
 8010410:	881b      	ldrh	r3, [r3, #0]
 8010412:	1ad2      	subs	r2, r2, r3
 8010414:	183b      	adds	r3, r7, r0
 8010416:	881b      	ldrh	r3, [r3, #0]
 8010418:	429a      	cmp	r2, r3
 801041a:	dd00      	ble.n	801041e <tcp_write+0x2a2>
 801041c:	001a      	movs	r2, r3
 801041e:	242a      	movs	r4, #42	; 0x2a
 8010420:	193b      	adds	r3, r7, r4
 8010422:	801a      	strh	r2, [r3, #0]
      seg = last_unsent;
 8010424:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010426:	65fb      	str	r3, [r7, #92]	; 0x5c

      /* Create a pbuf with a copy or reference to seglen bytes. We
       * can use PBUF_RAW here since the data appears in the middle of
       * a segment. A header will never be prepended. */
      if (apiflags & TCP_WRITE_FLAG_COPY) {
 8010428:	1d7b      	adds	r3, r7, #5
 801042a:	781b      	ldrb	r3, [r3, #0]
 801042c:	2201      	movs	r2, #1
 801042e:	4013      	ands	r3, r2
 8010430:	d04b      	beq.n	80104ca <tcp_write+0x34e>
        /* Data is copied */
        if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
 8010432:	251e      	movs	r5, #30
 8010434:	1978      	adds	r0, r7, r5
 8010436:	2344      	movs	r3, #68	; 0x44
 8010438:	18fb      	adds	r3, r7, r3
 801043a:	881a      	ldrh	r2, [r3, #0]
 801043c:	193b      	adds	r3, r7, r4
 801043e:	8819      	ldrh	r1, [r3, #0]
 8010440:	2301      	movs	r3, #1
 8010442:	9302      	str	r3, [sp, #8]
 8010444:	1d7b      	adds	r3, r7, #5
 8010446:	781b      	ldrb	r3, [r3, #0]
 8010448:	9301      	str	r3, [sp, #4]
 801044a:	68fb      	ldr	r3, [r7, #12]
 801044c:	9300      	str	r3, [sp, #0]
 801044e:	0003      	movs	r3, r0
 8010450:	2000      	movs	r0, #0
 8010452:	f7ff fd3b 	bl	800fecc <tcp_pbuf_prealloc>
 8010456:	0003      	movs	r3, r0
 8010458:	64bb      	str	r3, [r7, #72]	; 0x48
 801045a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801045c:	2b00      	cmp	r3, #0
 801045e:	d101      	bne.n	8010464 <tcp_write+0x2e8>
 8010460:	f000 fb98 	bl	8010b94 <tcp_write+0xa18>
                      ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n",
                       seglen));
          goto memerr;
        }
#if TCP_OVERSIZE_DBGCHECK
        oversize_add = oversize;
 8010464:	2366      	movs	r3, #102	; 0x66
 8010466:	18fb      	adds	r3, r7, r3
 8010468:	197a      	adds	r2, r7, r5
 801046a:	8812      	ldrh	r2, [r2, #0]
 801046c:	801a      	strh	r2, [r3, #0]
#endif /* TCP_OVERSIZE_DBGCHECK */
        TCP_DATA_COPY2(concat_p->payload, (const u8_t *)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
 801046e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010470:	6858      	ldr	r0, [r3, #4]
 8010472:	2352      	movs	r3, #82	; 0x52
 8010474:	18fb      	adds	r3, r7, r3
 8010476:	881b      	ldrh	r3, [r3, #0]
 8010478:	68ba      	ldr	r2, [r7, #8]
 801047a:	18d1      	adds	r1, r2, r3
 801047c:	0025      	movs	r5, r4
 801047e:	193b      	adds	r3, r7, r4
 8010480:	881b      	ldrh	r3, [r3, #0]
 8010482:	001a      	movs	r2, r3
 8010484:	f7f8 fc09 	bl	8008c9a <lwip_chksum_copy>
 8010488:	0003      	movs	r3, r0
 801048a:	001c      	movs	r4, r3
 801048c:	231b      	movs	r3, #27
 801048e:	18f8      	adds	r0, r7, r3
 8010490:	231c      	movs	r3, #28
 8010492:	18fa      	adds	r2, r7, r3
 8010494:	197b      	adds	r3, r7, r5
 8010496:	8819      	ldrh	r1, [r3, #0]
 8010498:	0003      	movs	r3, r0
 801049a:	0020      	movs	r0, r4
 801049c:	f7ff fdb2 	bl	8010004 <tcp_seg_add_chksum>
#if TCP_CHECKSUM_ON_COPY
        concat_chksummed += seglen;
 80104a0:	2246      	movs	r2, #70	; 0x46
 80104a2:	18bb      	adds	r3, r7, r2
 80104a4:	18b9      	adds	r1, r7, r2
 80104a6:	197a      	adds	r2, r7, r5
 80104a8:	8809      	ldrh	r1, [r1, #0]
 80104aa:	8812      	ldrh	r2, [r2, #0]
 80104ac:	188a      	adds	r2, r1, r2
 80104ae:	801a      	strh	r2, [r3, #0]
#endif /* TCP_CHECKSUM_ON_COPY */
        queuelen += pbuf_clen(concat_p);
 80104b0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80104b2:	0018      	movs	r0, r3
 80104b4:	f7fa f8b2 	bl	800a61c <pbuf_clen>
 80104b8:	0003      	movs	r3, r0
 80104ba:	0019      	movs	r1, r3
 80104bc:	2250      	movs	r2, #80	; 0x50
 80104be:	18bb      	adds	r3, r7, r2
 80104c0:	18ba      	adds	r2, r7, r2
 80104c2:	8812      	ldrh	r2, [r2, #0]
 80104c4:	188a      	adds	r2, r1, r2
 80104c6:	801a      	strh	r2, [r3, #0]
 80104c8:	e07f      	b.n	80105ca <tcp_write+0x44e>
      } else {
        /* Data is not copied */
        /* If the last unsent pbuf is of type PBUF_ROM, try to extend it. */
        struct pbuf *p;
        for (p = last_unsent->p; p->next != NULL; p = p->next);
 80104ca:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80104cc:	685b      	ldr	r3, [r3, #4]
 80104ce:	643b      	str	r3, [r7, #64]	; 0x40
 80104d0:	e002      	b.n	80104d8 <tcp_write+0x35c>
 80104d2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80104d4:	681b      	ldr	r3, [r3, #0]
 80104d6:	643b      	str	r3, [r7, #64]	; 0x40
 80104d8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80104da:	681b      	ldr	r3, [r3, #0]
 80104dc:	2b00      	cmp	r3, #0
 80104de:	d1f8      	bne.n	80104d2 <tcp_write+0x356>
        if (((p->type_internal & (PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS | PBUF_TYPE_FLAG_DATA_VOLATILE)) == 0) &&
 80104e0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80104e2:	7b1b      	ldrb	r3, [r3, #12]
 80104e4:	001a      	movs	r2, r3
 80104e6:	23c0      	movs	r3, #192	; 0xc0
 80104e8:	4013      	ands	r3, r2
 80104ea:	d12d      	bne.n	8010548 <tcp_write+0x3cc>
            (const u8_t *)p->payload + p->len == (const u8_t *)arg) {
 80104ec:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80104ee:	685b      	ldr	r3, [r3, #4]
 80104f0:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80104f2:	8952      	ldrh	r2, [r2, #10]
 80104f4:	189b      	adds	r3, r3, r2
        if (((p->type_internal & (PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS | PBUF_TYPE_FLAG_DATA_VOLATILE)) == 0) &&
 80104f6:	68ba      	ldr	r2, [r7, #8]
 80104f8:	429a      	cmp	r2, r3
 80104fa:	d125      	bne.n	8010548 <tcp_write+0x3cc>
          LWIP_ASSERT("tcp_write: ROM pbufs cannot be oversized", pos == 0);
 80104fc:	2352      	movs	r3, #82	; 0x52
 80104fe:	18fb      	adds	r3, r7, r3
 8010500:	881b      	ldrh	r3, [r3, #0]
 8010502:	2b00      	cmp	r3, #0
 8010504:	d005      	beq.n	8010512 <tcp_write+0x396>
 8010506:	4b08      	ldr	r3, [pc, #32]	; (8010528 <tcp_write+0x3ac>)
 8010508:	4a0d      	ldr	r2, [pc, #52]	; (8010540 <tcp_write+0x3c4>)
 801050a:	490e      	ldr	r1, [pc, #56]	; (8010544 <tcp_write+0x3c8>)
 801050c:	4808      	ldr	r0, [pc, #32]	; (8010530 <tcp_write+0x3b4>)
 801050e:	f7f1 fe69 	bl	80021e4 <app_debug_rtt_raw>
          extendlen = seglen;
 8010512:	2364      	movs	r3, #100	; 0x64
 8010514:	18fb      	adds	r3, r7, r3
 8010516:	222a      	movs	r2, #42	; 0x2a
 8010518:	18ba      	adds	r2, r7, r2
 801051a:	8812      	ldrh	r2, [r2, #0]
 801051c:	801a      	strh	r2, [r3, #0]
 801051e:	e034      	b.n	801058a <tcp_write+0x40e>
 8010520:	08021854 	.word	0x08021854
 8010524:	0802186c 	.word	0x0802186c
 8010528:	08021684 	.word	0x08021684
 801052c:	080218a0 	.word	0x080218a0
 8010530:	080216d0 	.word	0x080216d0
 8010534:	080218b8 	.word	0x080218b8
 8010538:	080218e8 	.word	0x080218e8
 801053c:	08021908 	.word	0x08021908
 8010540:	00000231 	.word	0x00000231
 8010544:	08021928 	.word	0x08021928
        } else {
          if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
 8010548:	232a      	movs	r3, #42	; 0x2a
 801054a:	18fb      	adds	r3, r7, r3
 801054c:	881b      	ldrh	r3, [r3, #0]
 801054e:	2201      	movs	r2, #1
 8010550:	0019      	movs	r1, r3
 8010552:	2000      	movs	r0, #0
 8010554:	f7f9 fc8c 	bl	8009e70 <pbuf_alloc>
 8010558:	0003      	movs	r3, r0
 801055a:	64bb      	str	r3, [r7, #72]	; 0x48
 801055c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801055e:	2b00      	cmp	r3, #0
 8010560:	d100      	bne.n	8010564 <tcp_write+0x3e8>
 8010562:	e319      	b.n	8010b98 <tcp_write+0xa1c>
            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                        ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
            goto memerr;
          }
          /* reference the non-volatile payload data */
          ((struct pbuf_rom *)concat_p)->payload = (const u8_t *)arg + pos;
 8010564:	2352      	movs	r3, #82	; 0x52
 8010566:	18fb      	adds	r3, r7, r3
 8010568:	881b      	ldrh	r3, [r3, #0]
 801056a:	68ba      	ldr	r2, [r7, #8]
 801056c:	18d2      	adds	r2, r2, r3
 801056e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010570:	605a      	str	r2, [r3, #4]
          queuelen += pbuf_clen(concat_p);
 8010572:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010574:	0018      	movs	r0, r3
 8010576:	f7fa f851 	bl	800a61c <pbuf_clen>
 801057a:	0003      	movs	r3, r0
 801057c:	0019      	movs	r1, r3
 801057e:	2250      	movs	r2, #80	; 0x50
 8010580:	18bb      	adds	r3, r7, r2
 8010582:	18ba      	adds	r2, r7, r2
 8010584:	8812      	ldrh	r2, [r2, #0]
 8010586:	188a      	adds	r2, r1, r2
 8010588:	801a      	strh	r2, [r3, #0]
        }
#if TCP_CHECKSUM_ON_COPY
        /* calculate the checksum of nocopy-data */
        tcp_seg_add_chksum(~inet_chksum((const u8_t *)arg + pos, seglen), seglen,
 801058a:	2352      	movs	r3, #82	; 0x52
 801058c:	18fb      	adds	r3, r7, r3
 801058e:	881b      	ldrh	r3, [r3, #0]
 8010590:	68ba      	ldr	r2, [r7, #8]
 8010592:	18d2      	adds	r2, r2, r3
 8010594:	252a      	movs	r5, #42	; 0x2a
 8010596:	197b      	adds	r3, r7, r5
 8010598:	881b      	ldrh	r3, [r3, #0]
 801059a:	0019      	movs	r1, r3
 801059c:	0010      	movs	r0, r2
 801059e:	f7f8 fb17 	bl	8008bd0 <inet_chksum>
 80105a2:	0003      	movs	r3, r0
 80105a4:	43db      	mvns	r3, r3
 80105a6:	b298      	uxth	r0, r3
 80105a8:	231b      	movs	r3, #27
 80105aa:	18fc      	adds	r4, r7, r3
 80105ac:	231c      	movs	r3, #28
 80105ae:	18fa      	adds	r2, r7, r3
 80105b0:	197b      	adds	r3, r7, r5
 80105b2:	8819      	ldrh	r1, [r3, #0]
 80105b4:	0023      	movs	r3, r4
 80105b6:	f7ff fd25 	bl	8010004 <tcp_seg_add_chksum>
                           &concat_chksum, &concat_chksum_swapped);
        concat_chksummed += seglen;
 80105ba:	2246      	movs	r2, #70	; 0x46
 80105bc:	18bb      	adds	r3, r7, r2
 80105be:	18b9      	adds	r1, r7, r2
 80105c0:	197a      	adds	r2, r7, r5
 80105c2:	8809      	ldrh	r1, [r1, #0]
 80105c4:	8812      	ldrh	r2, [r2, #0]
 80105c6:	188a      	adds	r2, r1, r2
 80105c8:	801a      	strh	r2, [r3, #0]
#endif /* TCP_CHECKSUM_ON_COPY */
      }

      pos += seglen;
 80105ca:	2252      	movs	r2, #82	; 0x52
 80105cc:	18bb      	adds	r3, r7, r2
 80105ce:	18b9      	adds	r1, r7, r2
 80105d0:	222a      	movs	r2, #42	; 0x2a
 80105d2:	18ba      	adds	r2, r7, r2
 80105d4:	8809      	ldrh	r1, [r1, #0]
 80105d6:	8812      	ldrh	r2, [r2, #0]
 80105d8:	188a      	adds	r2, r1, r2
 80105da:	801a      	strh	r2, [r3, #0]
 80105dc:	e146      	b.n	801086c <tcp_write+0x6f0>
    }
#endif /* !LWIP_NETIF_TX_SINGLE_PBUF */
  } else {
#if TCP_OVERSIZE
    LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
 80105de:	68fb      	ldr	r3, [r7, #12]
 80105e0:	226c      	movs	r2, #108	; 0x6c
 80105e2:	5a9b      	ldrh	r3, [r3, r2]
 80105e4:	2b00      	cmp	r3, #0
 80105e6:	d100      	bne.n	80105ea <tcp_write+0x46e>
 80105e8:	e140      	b.n	801086c <tcp_write+0x6f0>
 80105ea:	4bb1      	ldr	r3, [pc, #708]	; (80108b0 <tcp_write+0x734>)
 80105ec:	4ab1      	ldr	r2, [pc, #708]	; (80108b4 <tcp_write+0x738>)
 80105ee:	49b2      	ldr	r1, [pc, #712]	; (80108b8 <tcp_write+0x73c>)
 80105f0:	48b2      	ldr	r0, [pc, #712]	; (80108bc <tcp_write+0x740>)
 80105f2:	f7f1 fdf7 	bl	80021e4 <app_debug_rtt_raw>
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
 80105f6:	e139      	b.n	801086c <tcp_write+0x6f0>
    struct pbuf *p;
    u16_t left = len - pos;
 80105f8:	2028      	movs	r0, #40	; 0x28
 80105fa:	183b      	adds	r3, r7, r0
 80105fc:	1db9      	adds	r1, r7, #6
 80105fe:	2252      	movs	r2, #82	; 0x52
 8010600:	18ba      	adds	r2, r7, r2
 8010602:	8809      	ldrh	r1, [r1, #0]
 8010604:	8812      	ldrh	r2, [r2, #0]
 8010606:	1a8a      	subs	r2, r1, r2
 8010608:	801a      	strh	r2, [r3, #0]
    u16_t max_len = mss_local - optlen;
 801060a:	232e      	movs	r3, #46	; 0x2e
 801060c:	18fb      	adds	r3, r7, r3
 801060e:	781b      	ldrb	r3, [r3, #0]
 8010610:	b29a      	uxth	r2, r3
 8010612:	2426      	movs	r4, #38	; 0x26
 8010614:	193b      	adds	r3, r7, r4
 8010616:	2130      	movs	r1, #48	; 0x30
 8010618:	1879      	adds	r1, r7, r1
 801061a:	8809      	ldrh	r1, [r1, #0]
 801061c:	1a8a      	subs	r2, r1, r2
 801061e:	801a      	strh	r2, [r3, #0]
    u16_t seglen = LWIP_MIN(left, max_len);
 8010620:	2324      	movs	r3, #36	; 0x24
 8010622:	18fa      	adds	r2, r7, r3
 8010624:	193b      	adds	r3, r7, r4
 8010626:	1839      	adds	r1, r7, r0
 8010628:	880c      	ldrh	r4, [r1, #0]
 801062a:	881b      	ldrh	r3, [r3, #0]
 801062c:	b298      	uxth	r0, r3
 801062e:	b2a1      	uxth	r1, r4
 8010630:	4288      	cmp	r0, r1
 8010632:	d900      	bls.n	8010636 <tcp_write+0x4ba>
 8010634:	1c23      	adds	r3, r4, #0
 8010636:	8013      	strh	r3, [r2, #0]
#if TCP_CHECKSUM_ON_COPY
    u16_t chksum = 0;
 8010638:	2318      	movs	r3, #24
 801063a:	18fb      	adds	r3, r7, r3
 801063c:	2200      	movs	r2, #0
 801063e:	801a      	strh	r2, [r3, #0]
    u8_t chksum_swapped = 0;
 8010640:	2317      	movs	r3, #23
 8010642:	18fb      	adds	r3, r7, r3
 8010644:	2200      	movs	r2, #0
 8010646:	701a      	strb	r2, [r3, #0]
#endif /* TCP_CHECKSUM_ON_COPY */

    if (apiflags & TCP_WRITE_FLAG_COPY) {
 8010648:	1d7b      	adds	r3, r7, #5
 801064a:	781b      	ldrb	r3, [r3, #0]
 801064c:	2201      	movs	r2, #1
 801064e:	4013      	ands	r3, r2
 8010650:	d04c      	beq.n	80106ec <tcp_write+0x570>
      /* If copy is set, memory should be allocated and data copied
       * into pbuf */
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
 8010652:	232e      	movs	r3, #46	; 0x2e
 8010654:	18fb      	adds	r3, r7, r3
 8010656:	781b      	ldrb	r3, [r3, #0]
 8010658:	b29a      	uxth	r2, r3
 801065a:	2524      	movs	r5, #36	; 0x24
 801065c:	197b      	adds	r3, r7, r5
 801065e:	881b      	ldrh	r3, [r3, #0]
 8010660:	18d3      	adds	r3, r2, r3
 8010662:	b299      	uxth	r1, r3
 8010664:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010666:	425a      	negs	r2, r3
 8010668:	4153      	adcs	r3, r2
 801066a:	b2db      	uxtb	r3, r3
 801066c:	001c      	movs	r4, r3
 801066e:	231e      	movs	r3, #30
 8010670:	18f8      	adds	r0, r7, r3
 8010672:	2330      	movs	r3, #48	; 0x30
 8010674:	18fb      	adds	r3, r7, r3
 8010676:	881a      	ldrh	r2, [r3, #0]
 8010678:	9402      	str	r4, [sp, #8]
 801067a:	1d7b      	adds	r3, r7, #5
 801067c:	781b      	ldrb	r3, [r3, #0]
 801067e:	9301      	str	r3, [sp, #4]
 8010680:	68fb      	ldr	r3, [r7, #12]
 8010682:	9300      	str	r3, [sp, #0]
 8010684:	0003      	movs	r3, r0
 8010686:	2038      	movs	r0, #56	; 0x38
 8010688:	f7ff fc20 	bl	800fecc <tcp_pbuf_prealloc>
 801068c:	0003      	movs	r3, r0
 801068e:	63fb      	str	r3, [r7, #60]	; 0x3c
 8010690:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010692:	2b00      	cmp	r3, #0
 8010694:	d100      	bne.n	8010698 <tcp_write+0x51c>
 8010696:	e281      	b.n	8010b9c <tcp_write+0xa20>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
 8010698:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801069a:	895b      	ldrh	r3, [r3, #10]
 801069c:	197a      	adds	r2, r7, r5
 801069e:	8812      	ldrh	r2, [r2, #0]
 80106a0:	429a      	cmp	r2, r3
 80106a2:	d905      	bls.n	80106b0 <tcp_write+0x534>
 80106a4:	4b82      	ldr	r3, [pc, #520]	; (80108b0 <tcp_write+0x734>)
 80106a6:	4a86      	ldr	r2, [pc, #536]	; (80108c0 <tcp_write+0x744>)
 80106a8:	4986      	ldr	r1, [pc, #536]	; (80108c4 <tcp_write+0x748>)
 80106aa:	4884      	ldr	r0, [pc, #528]	; (80108bc <tcp_write+0x740>)
 80106ac:	f7f1 fd9a 	bl	80021e4 <app_debug_rtt_raw>
                  (p->len >= seglen));
      TCP_DATA_COPY2((char *)p->payload + optlen, (const u8_t *)arg + pos, seglen, &chksum, &chksum_swapped);
 80106b0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80106b2:	685a      	ldr	r2, [r3, #4]
 80106b4:	232e      	movs	r3, #46	; 0x2e
 80106b6:	18fb      	adds	r3, r7, r3
 80106b8:	781b      	ldrb	r3, [r3, #0]
 80106ba:	18d0      	adds	r0, r2, r3
 80106bc:	2352      	movs	r3, #82	; 0x52
 80106be:	18fb      	adds	r3, r7, r3
 80106c0:	881b      	ldrh	r3, [r3, #0]
 80106c2:	68ba      	ldr	r2, [r7, #8]
 80106c4:	18d1      	adds	r1, r2, r3
 80106c6:	2524      	movs	r5, #36	; 0x24
 80106c8:	197b      	adds	r3, r7, r5
 80106ca:	881b      	ldrh	r3, [r3, #0]
 80106cc:	001a      	movs	r2, r3
 80106ce:	f7f8 fae4 	bl	8008c9a <lwip_chksum_copy>
 80106d2:	0003      	movs	r3, r0
 80106d4:	001c      	movs	r4, r3
 80106d6:	2317      	movs	r3, #23
 80106d8:	18f8      	adds	r0, r7, r3
 80106da:	2318      	movs	r3, #24
 80106dc:	18fa      	adds	r2, r7, r3
 80106de:	197b      	adds	r3, r7, r5
 80106e0:	8819      	ldrh	r1, [r3, #0]
 80106e2:	0003      	movs	r3, r0
 80106e4:	0020      	movs	r0, r4
 80106e6:	f7ff fc8d 	bl	8010004 <tcp_seg_add_chksum>
 80106ea:	e061      	b.n	80107b0 <tcp_write+0x634>
       * sent out on the link (as it has to be ACKed by the remote
       * party) we can safely use PBUF_ROM instead of PBUF_REF here.
       */
      struct pbuf *p2;
#if TCP_OVERSIZE
      LWIP_ASSERT("oversize == 0", oversize == 0);
 80106ec:	231e      	movs	r3, #30
 80106ee:	18fb      	adds	r3, r7, r3
 80106f0:	881b      	ldrh	r3, [r3, #0]
 80106f2:	2b00      	cmp	r3, #0
 80106f4:	d005      	beq.n	8010702 <tcp_write+0x586>
 80106f6:	4b6e      	ldr	r3, [pc, #440]	; (80108b0 <tcp_write+0x734>)
 80106f8:	4a73      	ldr	r2, [pc, #460]	; (80108c8 <tcp_write+0x74c>)
 80106fa:	4974      	ldr	r1, [pc, #464]	; (80108cc <tcp_write+0x750>)
 80106fc:	486f      	ldr	r0, [pc, #444]	; (80108bc <tcp_write+0x740>)
 80106fe:	f7f1 fd71 	bl	80021e4 <app_debug_rtt_raw>
#endif /* TCP_OVERSIZE */
      if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
 8010702:	2424      	movs	r4, #36	; 0x24
 8010704:	193b      	adds	r3, r7, r4
 8010706:	881b      	ldrh	r3, [r3, #0]
 8010708:	2201      	movs	r2, #1
 801070a:	0019      	movs	r1, r3
 801070c:	2038      	movs	r0, #56	; 0x38
 801070e:	f7f9 fbaf 	bl	8009e70 <pbuf_alloc>
 8010712:	0003      	movs	r3, r0
 8010714:	623b      	str	r3, [r7, #32]
 8010716:	6a3b      	ldr	r3, [r7, #32]
 8010718:	2b00      	cmp	r3, #0
 801071a:	d100      	bne.n	801071e <tcp_write+0x5a2>
 801071c:	e240      	b.n	8010ba0 <tcp_write+0xa24>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
#if TCP_CHECKSUM_ON_COPY
      /* calculate the checksum of nocopy-data */
      chksum = ~inet_chksum((const u8_t *)arg + pos, seglen);
 801071e:	2352      	movs	r3, #82	; 0x52
 8010720:	18fb      	adds	r3, r7, r3
 8010722:	881b      	ldrh	r3, [r3, #0]
 8010724:	68ba      	ldr	r2, [r7, #8]
 8010726:	18d2      	adds	r2, r2, r3
 8010728:	193b      	adds	r3, r7, r4
 801072a:	881b      	ldrh	r3, [r3, #0]
 801072c:	0019      	movs	r1, r3
 801072e:	0010      	movs	r0, r2
 8010730:	f7f8 fa4e 	bl	8008bd0 <inet_chksum>
 8010734:	0003      	movs	r3, r0
 8010736:	43db      	mvns	r3, r3
 8010738:	b29a      	uxth	r2, r3
 801073a:	2118      	movs	r1, #24
 801073c:	187b      	adds	r3, r7, r1
 801073e:	801a      	strh	r2, [r3, #0]
      if (seglen & 1) {
 8010740:	193b      	adds	r3, r7, r4
 8010742:	881b      	ldrh	r3, [r3, #0]
 8010744:	2201      	movs	r2, #1
 8010746:	4013      	ands	r3, r2
 8010748:	d011      	beq.n	801076e <tcp_write+0x5f2>
        chksum_swapped = 1;
 801074a:	2317      	movs	r3, #23
 801074c:	18fb      	adds	r3, r7, r3
 801074e:	2201      	movs	r2, #1
 8010750:	701a      	strb	r2, [r3, #0]
        chksum = SWAP_BYTES_IN_WORD(chksum);
 8010752:	187b      	adds	r3, r7, r1
 8010754:	881b      	ldrh	r3, [r3, #0]
 8010756:	021b      	lsls	r3, r3, #8
 8010758:	b21a      	sxth	r2, r3
 801075a:	187b      	adds	r3, r7, r1
 801075c:	881b      	ldrh	r3, [r3, #0]
 801075e:	0a1b      	lsrs	r3, r3, #8
 8010760:	b29b      	uxth	r3, r3
 8010762:	b21b      	sxth	r3, r3
 8010764:	4313      	orrs	r3, r2
 8010766:	b21b      	sxth	r3, r3
 8010768:	b29a      	uxth	r2, r3
 801076a:	187b      	adds	r3, r7, r1
 801076c:	801a      	strh	r2, [r3, #0]
      }
#endif /* TCP_CHECKSUM_ON_COPY */
      /* reference the non-volatile payload data */
      ((struct pbuf_rom *)p2)->payload = (const u8_t *)arg + pos;
 801076e:	2352      	movs	r3, #82	; 0x52
 8010770:	18fb      	adds	r3, r7, r3
 8010772:	881b      	ldrh	r3, [r3, #0]
 8010774:	68ba      	ldr	r2, [r7, #8]
 8010776:	18d2      	adds	r2, r2, r3
 8010778:	6a3b      	ldr	r3, [r7, #32]
 801077a:	605a      	str	r2, [r3, #4]

      /* Second, allocate a pbuf for the headers. */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 801077c:	232e      	movs	r3, #46	; 0x2e
 801077e:	18fb      	adds	r3, r7, r3
 8010780:	781b      	ldrb	r3, [r3, #0]
 8010782:	b29b      	uxth	r3, r3
 8010784:	22a0      	movs	r2, #160	; 0xa0
 8010786:	0092      	lsls	r2, r2, #2
 8010788:	0019      	movs	r1, r3
 801078a:	2038      	movs	r0, #56	; 0x38
 801078c:	f7f9 fb70 	bl	8009e70 <pbuf_alloc>
 8010790:	0003      	movs	r3, r0
 8010792:	63fb      	str	r3, [r7, #60]	; 0x3c
 8010794:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010796:	2b00      	cmp	r3, #0
 8010798:	d104      	bne.n	80107a4 <tcp_write+0x628>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p2);
 801079a:	6a3b      	ldr	r3, [r7, #32]
 801079c:	0018      	movs	r0, r3
 801079e:	f7f9 fe9d 	bl	800a4dc <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: could not allocate memory for header pbuf\n"));
        goto memerr;
 80107a2:	e200      	b.n	8010ba6 <tcp_write+0xa2a>
      }
      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(p/*header*/, p2/*data*/);
 80107a4:	6a3a      	ldr	r2, [r7, #32]
 80107a6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80107a8:	0011      	movs	r1, r2
 80107aa:	0018      	movs	r0, r3
 80107ac:	f7f9 ff76 	bl	800a69c <pbuf_cat>
    }

    queuelen += pbuf_clen(p);
 80107b0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80107b2:	0018      	movs	r0, r3
 80107b4:	f7f9 ff32 	bl	800a61c <pbuf_clen>
 80107b8:	0003      	movs	r3, r0
 80107ba:	0019      	movs	r1, r3
 80107bc:	2050      	movs	r0, #80	; 0x50
 80107be:	183b      	adds	r3, r7, r0
 80107c0:	183a      	adds	r2, r7, r0
 80107c2:	8812      	ldrh	r2, [r2, #0]
 80107c4:	188a      	adds	r2, r1, r2
 80107c6:	801a      	strh	r2, [r3, #0]

    /* Now that there are more segments queued, we check again if the
     * length of the queue exceeds the configured maximum or
     * overflows. */
    if (queuelen > LWIP_MIN(TCP_SND_QUEUELEN, TCP_SNDQUEUELEN_OVERFLOW)) {
 80107c8:	183b      	adds	r3, r7, r0
 80107ca:	881b      	ldrh	r3, [r3, #0]
 80107cc:	2b08      	cmp	r3, #8
 80107ce:	d904      	bls.n	80107da <tcp_write+0x65e>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: queue too long %"U16_F" (%d)\n",
                  queuelen, (int)TCP_SND_QUEUELEN));
      pbuf_free(p);
 80107d0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80107d2:	0018      	movs	r0, r3
 80107d4:	f7f9 fe82 	bl	800a4dc <pbuf_free>
      goto memerr;
 80107d8:	e1e5      	b.n	8010ba6 <tcp_write+0xa2a>
    }

    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
 80107da:	68fb      	ldr	r3, [r7, #12]
 80107dc:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80107de:	2352      	movs	r3, #82	; 0x52
 80107e0:	18fb      	adds	r3, r7, r3
 80107e2:	881b      	ldrh	r3, [r3, #0]
 80107e4:	18d2      	adds	r2, r2, r3
 80107e6:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 80107e8:	68f8      	ldr	r0, [r7, #12]
 80107ea:	2333      	movs	r3, #51	; 0x33
 80107ec:	18fb      	adds	r3, r7, r3
 80107ee:	781b      	ldrb	r3, [r3, #0]
 80107f0:	9300      	str	r3, [sp, #0]
 80107f2:	0013      	movs	r3, r2
 80107f4:	2200      	movs	r2, #0
 80107f6:	f7ff fa45 	bl	800fc84 <tcp_create_segment>
 80107fa:	0003      	movs	r3, r0
 80107fc:	65fb      	str	r3, [r7, #92]	; 0x5c
 80107fe:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010800:	2b00      	cmp	r3, #0
 8010802:	d100      	bne.n	8010806 <tcp_write+0x68a>
 8010804:	e1ce      	b.n	8010ba4 <tcp_write+0xa28>
      goto memerr;
    }
#if TCP_OVERSIZE_DBGCHECK
    seg->oversize_left = oversize;
 8010806:	231e      	movs	r3, #30
 8010808:	18fb      	adds	r3, r7, r3
 801080a:	881a      	ldrh	r2, [r3, #0]
 801080c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801080e:	815a      	strh	r2, [r3, #10]
#endif /* TCP_OVERSIZE_DBGCHECK */
#if TCP_CHECKSUM_ON_COPY
    seg->chksum = chksum;
 8010810:	2318      	movs	r3, #24
 8010812:	18fb      	adds	r3, r7, r3
 8010814:	881a      	ldrh	r2, [r3, #0]
 8010816:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010818:	819a      	strh	r2, [r3, #12]
    seg->chksum_swapped = chksum_swapped;
 801081a:	2317      	movs	r3, #23
 801081c:	18fb      	adds	r3, r7, r3
 801081e:	781a      	ldrb	r2, [r3, #0]
 8010820:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010822:	739a      	strb	r2, [r3, #14]
    seg->flags |= TF_SEG_DATA_CHECKSUMMED;
 8010824:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010826:	7bdb      	ldrb	r3, [r3, #15]
 8010828:	2204      	movs	r2, #4
 801082a:	4313      	orrs	r3, r2
 801082c:	b2da      	uxtb	r2, r3
 801082e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010830:	73da      	strb	r2, [r3, #15]
#endif /* TCP_CHECKSUM_ON_COPY */

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
 8010832:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010834:	2b00      	cmp	r3, #0
 8010836:	d102      	bne.n	801083e <tcp_write+0x6c2>
      queue = seg;
 8010838:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801083a:	657b      	str	r3, [r7, #84]	; 0x54
 801083c:	e00b      	b.n	8010856 <tcp_write+0x6da>
    } else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
 801083e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010840:	2b00      	cmp	r3, #0
 8010842:	d105      	bne.n	8010850 <tcp_write+0x6d4>
 8010844:	4b1a      	ldr	r3, [pc, #104]	; (80108b0 <tcp_write+0x734>)
 8010846:	4a22      	ldr	r2, [pc, #136]	; (80108d0 <tcp_write+0x754>)
 8010848:	4922      	ldr	r1, [pc, #136]	; (80108d4 <tcp_write+0x758>)
 801084a:	481c      	ldr	r0, [pc, #112]	; (80108bc <tcp_write+0x740>)
 801084c:	f7f1 fcca 	bl	80021e4 <app_debug_rtt_raw>
      prev_seg->next = seg;
 8010850:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010852:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8010854:	601a      	str	r2, [r3, #0]
    }
    /* remember last segment of to-be-queued data for next iteration */
    prev_seg = seg;
 8010856:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010858:	65bb      	str	r3, [r7, #88]	; 0x58

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
                lwip_ntohl(seg->tcphdr->seqno),
                lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));

    pos += seglen;
 801085a:	2252      	movs	r2, #82	; 0x52
 801085c:	18bb      	adds	r3, r7, r2
 801085e:	18b9      	adds	r1, r7, r2
 8010860:	2224      	movs	r2, #36	; 0x24
 8010862:	18ba      	adds	r2, r7, r2
 8010864:	8809      	ldrh	r1, [r1, #0]
 8010866:	8812      	ldrh	r2, [r2, #0]
 8010868:	188a      	adds	r2, r1, r2
 801086a:	801a      	strh	r2, [r3, #0]
  while (pos < len) {
 801086c:	2352      	movs	r3, #82	; 0x52
 801086e:	18fa      	adds	r2, r7, r3
 8010870:	1dbb      	adds	r3, r7, #6
 8010872:	8812      	ldrh	r2, [r2, #0]
 8010874:	881b      	ldrh	r3, [r3, #0]
 8010876:	429a      	cmp	r2, r3
 8010878:	d200      	bcs.n	801087c <tcp_write+0x700>
 801087a:	e6bd      	b.n	80105f8 <tcp_write+0x47c>
  /*
   * All three segmentation phases were successful. We can commit the
   * transaction.
   */
#if TCP_OVERSIZE_DBGCHECK
  if ((last_unsent != NULL) && (oversize_add != 0)) {
 801087c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801087e:	2b00      	cmp	r3, #0
 8010880:	d00c      	beq.n	801089c <tcp_write+0x720>
 8010882:	2166      	movs	r1, #102	; 0x66
 8010884:	187b      	adds	r3, r7, r1
 8010886:	881b      	ldrh	r3, [r3, #0]
 8010888:	2b00      	cmp	r3, #0
 801088a:	d007      	beq.n	801089c <tcp_write+0x720>
    last_unsent->oversize_left += oversize_add;
 801088c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801088e:	895a      	ldrh	r2, [r3, #10]
 8010890:	187b      	adds	r3, r7, r1
 8010892:	881b      	ldrh	r3, [r3, #0]
 8010894:	18d3      	adds	r3, r2, r3
 8010896:	b29a      	uxth	r2, r3
 8010898:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801089a:	815a      	strh	r2, [r3, #10]
  /*
   * Phase 1: If data has been added to the preallocated tail of
   * last_unsent, we update the length fields of the pbuf chain.
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
 801089c:	2362      	movs	r3, #98	; 0x62
 801089e:	18fb      	adds	r3, r7, r3
 80108a0:	881b      	ldrh	r3, [r3, #0]
 80108a2:	2b00      	cmp	r3, #0
 80108a4:	d100      	bne.n	80108a8 <tcp_write+0x72c>
 80108a6:	e071      	b.n	801098c <tcp_write+0x810>
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
 80108a8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80108aa:	685b      	ldr	r3, [r3, #4]
 80108ac:	63bb      	str	r3, [r7, #56]	; 0x38
 80108ae:	e04c      	b.n	801094a <tcp_write+0x7ce>
 80108b0:	08021684 	.word	0x08021684
 80108b4:	0000024a 	.word	0x0000024a
 80108b8:	08021954 	.word	0x08021954
 80108bc:	080216d0 	.word	0x080216d0
 80108c0:	00000266 	.word	0x00000266
 80108c4:	08021984 	.word	0x08021984
 80108c8:	00000271 	.word	0x00000271
 80108cc:	080219c4 	.word	0x080219c4
 80108d0:	000002ab 	.word	0x000002ab
 80108d4:	080219d4 	.word	0x080219d4
      p->tot_len += oversize_used;
 80108d8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80108da:	891a      	ldrh	r2, [r3, #8]
 80108dc:	2162      	movs	r1, #98	; 0x62
 80108de:	187b      	adds	r3, r7, r1
 80108e0:	881b      	ldrh	r3, [r3, #0]
 80108e2:	18d3      	adds	r3, r2, r3
 80108e4:	b29a      	uxth	r2, r3
 80108e6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80108e8:	811a      	strh	r2, [r3, #8]
      if (p->next == NULL) {
 80108ea:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80108ec:	681b      	ldr	r3, [r3, #0]
 80108ee:	2b00      	cmp	r3, #0
 80108f0:	d128      	bne.n	8010944 <tcp_write+0x7c8>
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
 80108f2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80108f4:	685b      	ldr	r3, [r3, #4]
 80108f6:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80108f8:	8952      	ldrh	r2, [r2, #10]
 80108fa:	1898      	adds	r0, r3, r2
 80108fc:	000d      	movs	r5, r1
 80108fe:	197b      	adds	r3, r7, r5
 8010900:	881a      	ldrh	r2, [r3, #0]
 8010902:	68bb      	ldr	r3, [r7, #8]
 8010904:	0019      	movs	r1, r3
 8010906:	f7f8 f9c8 	bl	8008c9a <lwip_chksum_copy>
 801090a:	0003      	movs	r3, r0
 801090c:	001c      	movs	r4, r3
 801090e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010910:	330c      	adds	r3, #12
 8010912:	001a      	movs	r2, r3
 8010914:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010916:	330e      	adds	r3, #14
 8010918:	0018      	movs	r0, r3
 801091a:	197b      	adds	r3, r7, r5
 801091c:	8819      	ldrh	r1, [r3, #0]
 801091e:	0003      	movs	r3, r0
 8010920:	0020      	movs	r0, r4
 8010922:	f7ff fb6f 	bl	8010004 <tcp_seg_add_chksum>
 8010926:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010928:	7bdb      	ldrb	r3, [r3, #15]
 801092a:	2204      	movs	r2, #4
 801092c:	4313      	orrs	r3, r2
 801092e:	b2da      	uxtb	r2, r3
 8010930:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010932:	73da      	strb	r2, [r3, #15]
        p->len += oversize_used;
 8010934:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010936:	895a      	ldrh	r2, [r3, #10]
 8010938:	197b      	adds	r3, r7, r5
 801093a:	881b      	ldrh	r3, [r3, #0]
 801093c:	18d3      	adds	r3, r2, r3
 801093e:	b29a      	uxth	r2, r3
 8010940:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010942:	815a      	strh	r2, [r3, #10]
    for (p = last_unsent->p; p; p = p->next) {
 8010944:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010946:	681b      	ldr	r3, [r3, #0]
 8010948:	63bb      	str	r3, [r7, #56]	; 0x38
 801094a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801094c:	2b00      	cmp	r3, #0
 801094e:	d1c3      	bne.n	80108d8 <tcp_write+0x75c>
      }
    }
    last_unsent->len += oversize_used;
 8010950:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010952:	891a      	ldrh	r2, [r3, #8]
 8010954:	2162      	movs	r1, #98	; 0x62
 8010956:	187b      	adds	r3, r7, r1
 8010958:	881b      	ldrh	r3, [r3, #0]
 801095a:	18d3      	adds	r3, r2, r3
 801095c:	b29a      	uxth	r2, r3
 801095e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010960:	811a      	strh	r2, [r3, #8]
#if TCP_OVERSIZE_DBGCHECK
    LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
 8010962:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010964:	895b      	ldrh	r3, [r3, #10]
 8010966:	187a      	adds	r2, r7, r1
 8010968:	8812      	ldrh	r2, [r2, #0]
 801096a:	429a      	cmp	r2, r3
 801096c:	d905      	bls.n	801097a <tcp_write+0x7fe>
 801096e:	4ba5      	ldr	r3, [pc, #660]	; (8010c04 <tcp_write+0xa88>)
 8010970:	4aa5      	ldr	r2, [pc, #660]	; (8010c08 <tcp_write+0xa8c>)
 8010972:	49a6      	ldr	r1, [pc, #664]	; (8010c0c <tcp_write+0xa90>)
 8010974:	48a6      	ldr	r0, [pc, #664]	; (8010c10 <tcp_write+0xa94>)
 8010976:	f7f1 fc35 	bl	80021e4 <app_debug_rtt_raw>
                last_unsent->oversize_left >= oversize_used);
    last_unsent->oversize_left -= oversize_used;
 801097a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801097c:	895a      	ldrh	r2, [r3, #10]
 801097e:	2362      	movs	r3, #98	; 0x62
 8010980:	18fb      	adds	r3, r7, r3
 8010982:	881b      	ldrh	r3, [r3, #0]
 8010984:	1ad3      	subs	r3, r2, r3
 8010986:	b29a      	uxth	r2, r3
 8010988:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801098a:	815a      	strh	r2, [r3, #10]
#endif /* TCP_OVERSIZE_DBGCHECK */
  }
  pcb->unsent_oversize = oversize;
 801098c:	231e      	movs	r3, #30
 801098e:	18fb      	adds	r3, r7, r3
 8010990:	8819      	ldrh	r1, [r3, #0]
 8010992:	68fb      	ldr	r3, [r7, #12]
 8010994:	226c      	movs	r2, #108	; 0x6c
 8010996:	5299      	strh	r1, [r3, r2]

  /*
   * Phase 2: concat_p can be concatenated onto last_unsent->p, unless we
   * determined that the last ROM pbuf can be extended to include the new data.
   */
  if (concat_p != NULL) {
 8010998:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801099a:	2b00      	cmp	r3, #0
 801099c:	d019      	beq.n	80109d2 <tcp_write+0x856>
    LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
 801099e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80109a0:	2b00      	cmp	r3, #0
 80109a2:	d106      	bne.n	80109b2 <tcp_write+0x836>
 80109a4:	4b97      	ldr	r3, [pc, #604]	; (8010c04 <tcp_write+0xa88>)
 80109a6:	22b8      	movs	r2, #184	; 0xb8
 80109a8:	0092      	lsls	r2, r2, #2
 80109aa:	499a      	ldr	r1, [pc, #616]	; (8010c14 <tcp_write+0xa98>)
 80109ac:	4898      	ldr	r0, [pc, #608]	; (8010c10 <tcp_write+0xa94>)
 80109ae:	f7f1 fc19 	bl	80021e4 <app_debug_rtt_raw>
                (last_unsent != NULL));
    pbuf_cat(last_unsent->p, concat_p);
 80109b2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80109b4:	685b      	ldr	r3, [r3, #4]
 80109b6:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80109b8:	0011      	movs	r1, r2
 80109ba:	0018      	movs	r0, r3
 80109bc:	f7f9 fe6e 	bl	800a69c <pbuf_cat>
    last_unsent->len += concat_p->tot_len;
 80109c0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80109c2:	891a      	ldrh	r2, [r3, #8]
 80109c4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80109c6:	891b      	ldrh	r3, [r3, #8]
 80109c8:	18d3      	adds	r3, r2, r3
 80109ca:	b29a      	uxth	r2, r3
 80109cc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80109ce:	811a      	strh	r2, [r3, #8]
 80109d0:	e03e      	b.n	8010a50 <tcp_write+0x8d4>
  } else if (extendlen > 0) {
 80109d2:	2364      	movs	r3, #100	; 0x64
 80109d4:	18fb      	adds	r3, r7, r3
 80109d6:	881b      	ldrh	r3, [r3, #0]
 80109d8:	2b00      	cmp	r3, #0
 80109da:	d039      	beq.n	8010a50 <tcp_write+0x8d4>
    struct pbuf *p;
    LWIP_ASSERT("tcp_write: extension of reference requires reference",
 80109dc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80109de:	2b00      	cmp	r3, #0
 80109e0:	d003      	beq.n	80109ea <tcp_write+0x86e>
 80109e2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80109e4:	685b      	ldr	r3, [r3, #4]
 80109e6:	2b00      	cmp	r3, #0
 80109e8:	d105      	bne.n	80109f6 <tcp_write+0x87a>
 80109ea:	4b86      	ldr	r3, [pc, #536]	; (8010c04 <tcp_write+0xa88>)
 80109ec:	4a8a      	ldr	r2, [pc, #552]	; (8010c18 <tcp_write+0xa9c>)
 80109ee:	498b      	ldr	r1, [pc, #556]	; (8010c1c <tcp_write+0xaa0>)
 80109f0:	4887      	ldr	r0, [pc, #540]	; (8010c10 <tcp_write+0xa94>)
 80109f2:	f7f1 fbf7 	bl	80021e4 <app_debug_rtt_raw>
                last_unsent != NULL && last_unsent->p != NULL);
    for (p = last_unsent->p; p->next != NULL; p = p->next) {
 80109f6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80109f8:	685b      	ldr	r3, [r3, #4]
 80109fa:	637b      	str	r3, [r7, #52]	; 0x34
 80109fc:	e00b      	b.n	8010a16 <tcp_write+0x89a>
      p->tot_len += extendlen;
 80109fe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010a00:	891a      	ldrh	r2, [r3, #8]
 8010a02:	2364      	movs	r3, #100	; 0x64
 8010a04:	18fb      	adds	r3, r7, r3
 8010a06:	881b      	ldrh	r3, [r3, #0]
 8010a08:	18d3      	adds	r3, r2, r3
 8010a0a:	b29a      	uxth	r2, r3
 8010a0c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010a0e:	811a      	strh	r2, [r3, #8]
    for (p = last_unsent->p; p->next != NULL; p = p->next) {
 8010a10:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010a12:	681b      	ldr	r3, [r3, #0]
 8010a14:	637b      	str	r3, [r7, #52]	; 0x34
 8010a16:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010a18:	681b      	ldr	r3, [r3, #0]
 8010a1a:	2b00      	cmp	r3, #0
 8010a1c:	d1ef      	bne.n	80109fe <tcp_write+0x882>
    }
    p->tot_len += extendlen;
 8010a1e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010a20:	891a      	ldrh	r2, [r3, #8]
 8010a22:	2164      	movs	r1, #100	; 0x64
 8010a24:	187b      	adds	r3, r7, r1
 8010a26:	881b      	ldrh	r3, [r3, #0]
 8010a28:	18d3      	adds	r3, r2, r3
 8010a2a:	b29a      	uxth	r2, r3
 8010a2c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010a2e:	811a      	strh	r2, [r3, #8]
    p->len += extendlen;
 8010a30:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010a32:	895a      	ldrh	r2, [r3, #10]
 8010a34:	187b      	adds	r3, r7, r1
 8010a36:	881b      	ldrh	r3, [r3, #0]
 8010a38:	18d3      	adds	r3, r2, r3
 8010a3a:	b29a      	uxth	r2, r3
 8010a3c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010a3e:	815a      	strh	r2, [r3, #10]
    last_unsent->len += extendlen;
 8010a40:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010a42:	891a      	ldrh	r2, [r3, #8]
 8010a44:	187b      	adds	r3, r7, r1
 8010a46:	881b      	ldrh	r3, [r3, #0]
 8010a48:	18d3      	adds	r3, r2, r3
 8010a4a:	b29a      	uxth	r2, r3
 8010a4c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010a4e:	811a      	strh	r2, [r3, #8]
  }

#if TCP_CHECKSUM_ON_COPY
  if (concat_chksummed) {
 8010a50:	2346      	movs	r3, #70	; 0x46
 8010a52:	18fb      	adds	r3, r7, r3
 8010a54:	881b      	ldrh	r3, [r3, #0]
 8010a56:	2b00      	cmp	r3, #0
 8010a58:	d037      	beq.n	8010aca <tcp_write+0x94e>
    LWIP_ASSERT("tcp_write: concat checksum needs concatenated data",
 8010a5a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010a5c:	2b00      	cmp	r3, #0
 8010a5e:	d10a      	bne.n	8010a76 <tcp_write+0x8fa>
 8010a60:	2364      	movs	r3, #100	; 0x64
 8010a62:	18fb      	adds	r3, r7, r3
 8010a64:	881b      	ldrh	r3, [r3, #0]
 8010a66:	2b00      	cmp	r3, #0
 8010a68:	d105      	bne.n	8010a76 <tcp_write+0x8fa>
 8010a6a:	4b66      	ldr	r3, [pc, #408]	; (8010c04 <tcp_write+0xa88>)
 8010a6c:	4a6c      	ldr	r2, [pc, #432]	; (8010c20 <tcp_write+0xaa4>)
 8010a6e:	496d      	ldr	r1, [pc, #436]	; (8010c24 <tcp_write+0xaa8>)
 8010a70:	4867      	ldr	r0, [pc, #412]	; (8010c10 <tcp_write+0xa94>)
 8010a72:	f7f1 fbb7 	bl	80021e4 <app_debug_rtt_raw>
                concat_p != NULL || extendlen > 0);
    /*if concat checksumm swapped - swap it back */
    if (concat_chksum_swapped) {
 8010a76:	231b      	movs	r3, #27
 8010a78:	18fb      	adds	r3, r7, r3
 8010a7a:	781b      	ldrb	r3, [r3, #0]
 8010a7c:	2b00      	cmp	r3, #0
 8010a7e:	d00e      	beq.n	8010a9e <tcp_write+0x922>
      concat_chksum = SWAP_BYTES_IN_WORD(concat_chksum);
 8010a80:	211c      	movs	r1, #28
 8010a82:	187b      	adds	r3, r7, r1
 8010a84:	881b      	ldrh	r3, [r3, #0]
 8010a86:	021b      	lsls	r3, r3, #8
 8010a88:	b21a      	sxth	r2, r3
 8010a8a:	187b      	adds	r3, r7, r1
 8010a8c:	881b      	ldrh	r3, [r3, #0]
 8010a8e:	0a1b      	lsrs	r3, r3, #8
 8010a90:	b29b      	uxth	r3, r3
 8010a92:	b21b      	sxth	r3, r3
 8010a94:	4313      	orrs	r3, r2
 8010a96:	b21b      	sxth	r3, r3
 8010a98:	b29a      	uxth	r2, r3
 8010a9a:	187b      	adds	r3, r7, r1
 8010a9c:	801a      	strh	r2, [r3, #0]
    }
    tcp_seg_add_chksum(concat_chksum, concat_chksummed, &last_unsent->chksum,
 8010a9e:	231c      	movs	r3, #28
 8010aa0:	18fb      	adds	r3, r7, r3
 8010aa2:	8818      	ldrh	r0, [r3, #0]
 8010aa4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010aa6:	330c      	adds	r3, #12
 8010aa8:	001a      	movs	r2, r3
 8010aaa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010aac:	330e      	adds	r3, #14
 8010aae:	001c      	movs	r4, r3
 8010ab0:	2346      	movs	r3, #70	; 0x46
 8010ab2:	18fb      	adds	r3, r7, r3
 8010ab4:	8819      	ldrh	r1, [r3, #0]
 8010ab6:	0023      	movs	r3, r4
 8010ab8:	f7ff faa4 	bl	8010004 <tcp_seg_add_chksum>
                       &last_unsent->chksum_swapped);
    last_unsent->flags |= TF_SEG_DATA_CHECKSUMMED;
 8010abc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010abe:	7bdb      	ldrb	r3, [r3, #15]
 8010ac0:	2204      	movs	r2, #4
 8010ac2:	4313      	orrs	r3, r2
 8010ac4:	b2da      	uxtb	r2, r3
 8010ac6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010ac8:	73da      	strb	r2, [r3, #15]

  /*
   * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
   * is harmless
   */
  if (last_unsent == NULL) {
 8010aca:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010acc:	2b00      	cmp	r3, #0
 8010ace:	d103      	bne.n	8010ad8 <tcp_write+0x95c>
    pcb->unsent = queue;
 8010ad0:	68fb      	ldr	r3, [r7, #12]
 8010ad2:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8010ad4:	671a      	str	r2, [r3, #112]	; 0x70
 8010ad6:	e002      	b.n	8010ade <tcp_write+0x962>
  } else {
    last_unsent->next = queue;
 8010ad8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010ada:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8010adc:	601a      	str	r2, [r3, #0]
  }

  /*
   * Finally update the pcb state.
   */
  pcb->snd_lbb += len;
 8010ade:	68fb      	ldr	r3, [r7, #12]
 8010ae0:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8010ae2:	1dbb      	adds	r3, r7, #6
 8010ae4:	881b      	ldrh	r3, [r3, #0]
 8010ae6:	18d2      	adds	r2, r2, r3
 8010ae8:	68fb      	ldr	r3, [r7, #12]
 8010aea:	661a      	str	r2, [r3, #96]	; 0x60
  pcb->snd_buf -= len;
 8010aec:	68fb      	ldr	r3, [r7, #12]
 8010aee:	2268      	movs	r2, #104	; 0x68
 8010af0:	5a9a      	ldrh	r2, [r3, r2]
 8010af2:	1dbb      	adds	r3, r7, #6
 8010af4:	881b      	ldrh	r3, [r3, #0]
 8010af6:	1ad3      	subs	r3, r2, r3
 8010af8:	b299      	uxth	r1, r3
 8010afa:	68fb      	ldr	r3, [r7, #12]
 8010afc:	2268      	movs	r2, #104	; 0x68
 8010afe:	5299      	strh	r1, [r3, r2]
  pcb->snd_queuelen = queuelen;
 8010b00:	68fb      	ldr	r3, [r7, #12]
 8010b02:	2250      	movs	r2, #80	; 0x50
 8010b04:	18ba      	adds	r2, r7, r2
 8010b06:	216a      	movs	r1, #106	; 0x6a
 8010b08:	8812      	ldrh	r2, [r2, #0]
 8010b0a:	525a      	strh	r2, [r3, r1]

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: %"S16_F" (after enqueued)\n",
                               pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
 8010b0c:	68fb      	ldr	r3, [r7, #12]
 8010b0e:	226a      	movs	r2, #106	; 0x6a
 8010b10:	5a9b      	ldrh	r3, [r3, r2]
 8010b12:	2b00      	cmp	r3, #0
 8010b14:	d00d      	beq.n	8010b32 <tcp_write+0x9b6>
    LWIP_ASSERT("tcp_write: valid queue length",
 8010b16:	68fb      	ldr	r3, [r7, #12]
 8010b18:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8010b1a:	2b00      	cmp	r3, #0
 8010b1c:	d109      	bne.n	8010b32 <tcp_write+0x9b6>
 8010b1e:	68fb      	ldr	r3, [r7, #12]
 8010b20:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010b22:	2b00      	cmp	r3, #0
 8010b24:	d105      	bne.n	8010b32 <tcp_write+0x9b6>
 8010b26:	4b37      	ldr	r3, [pc, #220]	; (8010c04 <tcp_write+0xa88>)
 8010b28:	4a3f      	ldr	r2, [pc, #252]	; (8010c28 <tcp_write+0xaac>)
 8010b2a:	4940      	ldr	r1, [pc, #256]	; (8010c2c <tcp_write+0xab0>)
 8010b2c:	4838      	ldr	r0, [pc, #224]	; (8010c10 <tcp_write+0xa94>)
 8010b2e:	f7f1 fb59 	bl	80021e4 <app_debug_rtt_raw>
                pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued. */
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE) == 0)) {
 8010b32:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010b34:	2b00      	cmp	r3, #0
 8010b36:	d02b      	beq.n	8010b90 <tcp_write+0xa14>
 8010b38:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010b3a:	691b      	ldr	r3, [r3, #16]
 8010b3c:	2b00      	cmp	r3, #0
 8010b3e:	d027      	beq.n	8010b90 <tcp_write+0xa14>
 8010b40:	1d7b      	adds	r3, r7, #5
 8010b42:	781b      	ldrb	r3, [r3, #0]
 8010b44:	2202      	movs	r2, #2
 8010b46:	4013      	ands	r3, r2
 8010b48:	d122      	bne.n	8010b90 <tcp_write+0xa14>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
 8010b4a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010b4c:	691b      	ldr	r3, [r3, #16]
 8010b4e:	7b1a      	ldrb	r2, [r3, #12]
 8010b50:	7b5b      	ldrb	r3, [r3, #13]
 8010b52:	021b      	lsls	r3, r3, #8
 8010b54:	4313      	orrs	r3, r2
 8010b56:	b29c      	uxth	r4, r3
 8010b58:	2008      	movs	r0, #8
 8010b5a:	f7f6 fc51 	bl	8007400 <lwip_htons>
 8010b5e:	0003      	movs	r3, r0
 8010b60:	001a      	movs	r2, r3
 8010b62:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010b64:	691b      	ldr	r3, [r3, #16]
 8010b66:	4322      	orrs	r2, r4
 8010b68:	b292      	uxth	r2, r2
 8010b6a:	21ff      	movs	r1, #255	; 0xff
 8010b6c:	4011      	ands	r1, r2
 8010b6e:	000c      	movs	r4, r1
 8010b70:	7b19      	ldrb	r1, [r3, #12]
 8010b72:	2000      	movs	r0, #0
 8010b74:	4001      	ands	r1, r0
 8010b76:	1c08      	adds	r0, r1, #0
 8010b78:	1c21      	adds	r1, r4, #0
 8010b7a:	4301      	orrs	r1, r0
 8010b7c:	7319      	strb	r1, [r3, #12]
 8010b7e:	0a12      	lsrs	r2, r2, #8
 8010b80:	b290      	uxth	r0, r2
 8010b82:	7b5a      	ldrb	r2, [r3, #13]
 8010b84:	2100      	movs	r1, #0
 8010b86:	400a      	ands	r2, r1
 8010b88:	1c11      	adds	r1, r2, #0
 8010b8a:	1c02      	adds	r2, r0, #0
 8010b8c:	430a      	orrs	r2, r1
 8010b8e:	735a      	strb	r2, [r3, #13]
  }

  return ERR_OK;
 8010b90:	2300      	movs	r3, #0
 8010b92:	e032      	b.n	8010bfa <tcp_write+0xa7e>
          goto memerr;
 8010b94:	46c0      	nop			; (mov r8, r8)
 8010b96:	e006      	b.n	8010ba6 <tcp_write+0xa2a>
            goto memerr;
 8010b98:	46c0      	nop			; (mov r8, r8)
 8010b9a:	e004      	b.n	8010ba6 <tcp_write+0xa2a>
        goto memerr;
 8010b9c:	46c0      	nop			; (mov r8, r8)
 8010b9e:	e002      	b.n	8010ba6 <tcp_write+0xa2a>
        goto memerr;
 8010ba0:	46c0      	nop			; (mov r8, r8)
 8010ba2:	e000      	b.n	8010ba6 <tcp_write+0xa2a>
      goto memerr;
 8010ba4:	46c0      	nop			; (mov r8, r8)
memerr:
  tcp_set_flags(pcb, TF_NAGLEMEMERR);
 8010ba6:	68fb      	ldr	r3, [r7, #12]
 8010ba8:	8bdb      	ldrh	r3, [r3, #30]
 8010baa:	2280      	movs	r2, #128	; 0x80
 8010bac:	4313      	orrs	r3, r2
 8010bae:	b29a      	uxth	r2, r3
 8010bb0:	68fb      	ldr	r3, [r7, #12]
 8010bb2:	83da      	strh	r2, [r3, #30]
  TCP_STATS_INC(tcp.memerr);

  if (concat_p != NULL) {
 8010bb4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010bb6:	2b00      	cmp	r3, #0
 8010bb8:	d003      	beq.n	8010bc2 <tcp_write+0xa46>
    pbuf_free(concat_p);
 8010bba:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010bbc:	0018      	movs	r0, r3
 8010bbe:	f7f9 fc8d 	bl	800a4dc <pbuf_free>
  }
  if (queue != NULL) {
 8010bc2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010bc4:	2b00      	cmp	r3, #0
 8010bc6:	d003      	beq.n	8010bd0 <tcp_write+0xa54>
    tcp_segs_free(queue);
 8010bc8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010bca:	0018      	movs	r0, r3
 8010bcc:	f7fb fccc 	bl	800c568 <tcp_segs_free>
  }
  if (pcb->snd_queuelen != 0) {
 8010bd0:	68fb      	ldr	r3, [r7, #12]
 8010bd2:	226a      	movs	r2, #106	; 0x6a
 8010bd4:	5a9b      	ldrh	r3, [r3, r2]
 8010bd6:	2b00      	cmp	r3, #0
 8010bd8:	d00d      	beq.n	8010bf6 <tcp_write+0xa7a>
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
 8010bda:	68fb      	ldr	r3, [r7, #12]
 8010bdc:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8010bde:	2b00      	cmp	r3, #0
 8010be0:	d109      	bne.n	8010bf6 <tcp_write+0xa7a>
 8010be2:	68fb      	ldr	r3, [r7, #12]
 8010be4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010be6:	2b00      	cmp	r3, #0
 8010be8:	d105      	bne.n	8010bf6 <tcp_write+0xa7a>
 8010bea:	4b06      	ldr	r3, [pc, #24]	; (8010c04 <tcp_write+0xa88>)
 8010bec:	4a10      	ldr	r2, [pc, #64]	; (8010c30 <tcp_write+0xab4>)
 8010bee:	490f      	ldr	r1, [pc, #60]	; (8010c2c <tcp_write+0xab0>)
 8010bf0:	4807      	ldr	r0, [pc, #28]	; (8010c10 <tcp_write+0xa94>)
 8010bf2:	f7f1 faf7 	bl	80021e4 <app_debug_rtt_raw>
                pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
 8010bf6:	2301      	movs	r3, #1
 8010bf8:	425b      	negs	r3, r3
}
 8010bfa:	0018      	movs	r0, r3
 8010bfc:	46bd      	mov	sp, r7
 8010bfe:	b01a      	add	sp, #104	; 0x68
 8010c00:	bdb0      	pop	{r4, r5, r7, pc}
 8010c02:	46c0      	nop			; (mov r8, r8)
 8010c04:	08021684 	.word	0x08021684
 8010c08:	000002d3 	.word	0x000002d3
 8010c0c:	080219e8 	.word	0x080219e8
 8010c10:	080216d0 	.word	0x080216d0
 8010c14:	08021a14 	.word	0x08021a14
 8010c18:	000002e6 	.word	0x000002e6
 8010c1c:	08021a4c 	.word	0x08021a4c
 8010c20:	000002f2 	.word	0x000002f2
 8010c24:	08021a84 	.word	0x08021a84
 8010c28:	00000312 	.word	0x00000312
 8010c2c:	08021ab8 	.word	0x08021ab8
 8010c30:	00000327 	.word	0x00000327

08010c34 <tcp_split_unsent_seg>:
 * @param pcb the tcp_pcb for which to split the unsent head
 * @param split the amount of payload to remain in the head
 */
err_t
tcp_split_unsent_seg(struct tcp_pcb *pcb, u16_t split)
{
 8010c34:	b5f0      	push	{r4, r5, r6, r7, lr}
 8010c36:	b08d      	sub	sp, #52	; 0x34
 8010c38:	af02      	add	r7, sp, #8
 8010c3a:	6078      	str	r0, [r7, #4]
 8010c3c:	000a      	movs	r2, r1
 8010c3e:	1cbb      	adds	r3, r7, #2
 8010c40:	801a      	strh	r2, [r3, #0]
  struct tcp_seg *seg = NULL, *useg = NULL;
 8010c42:	2300      	movs	r3, #0
 8010c44:	61fb      	str	r3, [r7, #28]
 8010c46:	2300      	movs	r3, #0
 8010c48:	613b      	str	r3, [r7, #16]
  struct pbuf *p = NULL;
 8010c4a:	2300      	movs	r3, #0
 8010c4c:	623b      	str	r3, [r7, #32]
  u8_t split_flags;
  u8_t remainder_flags;
  u16_t remainder;
  u16_t offset;
#if TCP_CHECKSUM_ON_COPY
  u16_t chksum = 0;
 8010c4e:	230a      	movs	r3, #10
 8010c50:	18fb      	adds	r3, r7, r3
 8010c52:	2200      	movs	r2, #0
 8010c54:	801a      	strh	r2, [r3, #0]
  u8_t chksum_swapped = 0;
 8010c56:	2309      	movs	r3, #9
 8010c58:	18fb      	adds	r3, r7, r3
 8010c5a:	2200      	movs	r2, #0
 8010c5c:	701a      	strb	r2, [r3, #0]
  struct pbuf *q;
#endif /* TCP_CHECKSUM_ON_COPY */

  LWIP_ASSERT("tcp_split_unsent_seg: invalid pcb", pcb != NULL);
 8010c5e:	687b      	ldr	r3, [r7, #4]
 8010c60:	2b00      	cmp	r3, #0
 8010c62:	d105      	bne.n	8010c70 <tcp_split_unsent_seg+0x3c>
 8010c64:	4bd2      	ldr	r3, [pc, #840]	; (8010fb0 <tcp_split_unsent_seg+0x37c>)
 8010c66:	4ad3      	ldr	r2, [pc, #844]	; (8010fb4 <tcp_split_unsent_seg+0x380>)
 8010c68:	49d3      	ldr	r1, [pc, #844]	; (8010fb8 <tcp_split_unsent_seg+0x384>)
 8010c6a:	48d4      	ldr	r0, [pc, #848]	; (8010fbc <tcp_split_unsent_seg+0x388>)
 8010c6c:	f7f1 faba 	bl	80021e4 <app_debug_rtt_raw>

  useg = pcb->unsent;
 8010c70:	687b      	ldr	r3, [r7, #4]
 8010c72:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010c74:	613b      	str	r3, [r7, #16]
  if (useg == NULL) {
 8010c76:	693b      	ldr	r3, [r7, #16]
 8010c78:	2b00      	cmp	r3, #0
 8010c7a:	d102      	bne.n	8010c82 <tcp_split_unsent_seg+0x4e>
    return ERR_MEM;
 8010c7c:	2301      	movs	r3, #1
 8010c7e:	425b      	negs	r3, r3
 8010c80:	e207      	b.n	8011092 <tcp_split_unsent_seg+0x45e>
  }

  if (split == 0) {
 8010c82:	1cbb      	adds	r3, r7, #2
 8010c84:	881b      	ldrh	r3, [r3, #0]
 8010c86:	2b00      	cmp	r3, #0
 8010c88:	d108      	bne.n	8010c9c <tcp_split_unsent_seg+0x68>
    LWIP_ASSERT("Can't split segment into length 0", 0);
 8010c8a:	4bc9      	ldr	r3, [pc, #804]	; (8010fb0 <tcp_split_unsent_seg+0x37c>)
 8010c8c:	4acc      	ldr	r2, [pc, #816]	; (8010fc0 <tcp_split_unsent_seg+0x38c>)
 8010c8e:	49cd      	ldr	r1, [pc, #820]	; (8010fc4 <tcp_split_unsent_seg+0x390>)
 8010c90:	48ca      	ldr	r0, [pc, #808]	; (8010fbc <tcp_split_unsent_seg+0x388>)
 8010c92:	f7f1 faa7 	bl	80021e4 <app_debug_rtt_raw>
    return ERR_VAL;
 8010c96:	2306      	movs	r3, #6
 8010c98:	425b      	negs	r3, r3
 8010c9a:	e1fa      	b.n	8011092 <tcp_split_unsent_seg+0x45e>
  }

  if (useg->len <= split) {
 8010c9c:	693b      	ldr	r3, [r7, #16]
 8010c9e:	891b      	ldrh	r3, [r3, #8]
 8010ca0:	1cba      	adds	r2, r7, #2
 8010ca2:	8812      	ldrh	r2, [r2, #0]
 8010ca4:	429a      	cmp	r2, r3
 8010ca6:	d301      	bcc.n	8010cac <tcp_split_unsent_seg+0x78>
    return ERR_OK;
 8010ca8:	2300      	movs	r3, #0
 8010caa:	e1f2      	b.n	8011092 <tcp_split_unsent_seg+0x45e>
  }

  LWIP_ASSERT("split <= mss", split <= pcb->mss);
 8010cac:	687b      	ldr	r3, [r7, #4]
 8010cae:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8010cb0:	1cba      	adds	r2, r7, #2
 8010cb2:	8812      	ldrh	r2, [r2, #0]
 8010cb4:	429a      	cmp	r2, r3
 8010cb6:	d905      	bls.n	8010cc4 <tcp_split_unsent_seg+0x90>
 8010cb8:	4bbd      	ldr	r3, [pc, #756]	; (8010fb0 <tcp_split_unsent_seg+0x37c>)
 8010cba:	4ac3      	ldr	r2, [pc, #780]	; (8010fc8 <tcp_split_unsent_seg+0x394>)
 8010cbc:	49c3      	ldr	r1, [pc, #780]	; (8010fcc <tcp_split_unsent_seg+0x398>)
 8010cbe:	48bf      	ldr	r0, [pc, #764]	; (8010fbc <tcp_split_unsent_seg+0x388>)
 8010cc0:	f7f1 fa90 	bl	80021e4 <app_debug_rtt_raw>
  LWIP_ASSERT("useg->len > 0", useg->len > 0);
 8010cc4:	693b      	ldr	r3, [r7, #16]
 8010cc6:	891b      	ldrh	r3, [r3, #8]
 8010cc8:	2b00      	cmp	r3, #0
 8010cca:	d106      	bne.n	8010cda <tcp_split_unsent_seg+0xa6>
 8010ccc:	4bb8      	ldr	r3, [pc, #736]	; (8010fb0 <tcp_split_unsent_seg+0x37c>)
 8010cce:	22d7      	movs	r2, #215	; 0xd7
 8010cd0:	0092      	lsls	r2, r2, #2
 8010cd2:	49bf      	ldr	r1, [pc, #764]	; (8010fd0 <tcp_split_unsent_seg+0x39c>)
 8010cd4:	48b9      	ldr	r0, [pc, #740]	; (8010fbc <tcp_split_unsent_seg+0x388>)
 8010cd6:	f7f1 fa85 	bl	80021e4 <app_debug_rtt_raw>
   * to split this packet so we may actually exceed the max value by
   * one!
   */
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: split_unsent_seg: %u\n", (unsigned int)pcb->snd_queuelen));

  optflags = useg->flags;
 8010cda:	200f      	movs	r0, #15
 8010cdc:	183b      	adds	r3, r7, r0
 8010cde:	693a      	ldr	r2, [r7, #16]
 8010ce0:	7bd2      	ldrb	r2, [r2, #15]
 8010ce2:	701a      	strb	r2, [r3, #0]
#if TCP_CHECKSUM_ON_COPY
  /* Remove since checksum is not stored until after tcp_create_segment() */
  optflags &= ~TF_SEG_DATA_CHECKSUMMED;
 8010ce4:	183b      	adds	r3, r7, r0
 8010ce6:	183a      	adds	r2, r7, r0
 8010ce8:	7812      	ldrb	r2, [r2, #0]
 8010cea:	2104      	movs	r1, #4
 8010cec:	438a      	bics	r2, r1
 8010cee:	701a      	strb	r2, [r3, #0]
#endif /* TCP_CHECKSUM_ON_COPY */
  optlen = LWIP_TCP_OPT_LENGTH(optflags);
 8010cf0:	183b      	adds	r3, r7, r0
 8010cf2:	781b      	ldrb	r3, [r3, #0]
 8010cf4:	009b      	lsls	r3, r3, #2
 8010cf6:	b2da      	uxtb	r2, r3
 8010cf8:	240e      	movs	r4, #14
 8010cfa:	193b      	adds	r3, r7, r4
 8010cfc:	2104      	movs	r1, #4
 8010cfe:	400a      	ands	r2, r1
 8010d00:	701a      	strb	r2, [r3, #0]
  remainder = useg->len - split;
 8010d02:	693b      	ldr	r3, [r7, #16]
 8010d04:	8919      	ldrh	r1, [r3, #8]
 8010d06:	250c      	movs	r5, #12
 8010d08:	197b      	adds	r3, r7, r5
 8010d0a:	1cba      	adds	r2, r7, #2
 8010d0c:	8812      	ldrh	r2, [r2, #0]
 8010d0e:	1a8a      	subs	r2, r1, r2
 8010d10:	801a      	strh	r2, [r3, #0]

  /* Create new pbuf for the remainder of the split */
  p = pbuf_alloc(PBUF_TRANSPORT, remainder + optlen, PBUF_RAM);
 8010d12:	193b      	adds	r3, r7, r4
 8010d14:	781b      	ldrb	r3, [r3, #0]
 8010d16:	b29a      	uxth	r2, r3
 8010d18:	197b      	adds	r3, r7, r5
 8010d1a:	881b      	ldrh	r3, [r3, #0]
 8010d1c:	18d3      	adds	r3, r2, r3
 8010d1e:	b29b      	uxth	r3, r3
 8010d20:	22a0      	movs	r2, #160	; 0xa0
 8010d22:	0092      	lsls	r2, r2, #2
 8010d24:	0019      	movs	r1, r3
 8010d26:	2038      	movs	r0, #56	; 0x38
 8010d28:	f7f9 f8a2 	bl	8009e70 <pbuf_alloc>
 8010d2c:	0003      	movs	r3, r0
 8010d2e:	623b      	str	r3, [r7, #32]
  if (p == NULL) {
 8010d30:	6a3b      	ldr	r3, [r7, #32]
 8010d32:	2b00      	cmp	r3, #0
 8010d34:	d100      	bne.n	8010d38 <tcp_split_unsent_seg+0x104>
 8010d36:	e197      	b.n	8011068 <tcp_split_unsent_seg+0x434>
                ("tcp_split_unsent_seg: could not allocate memory for pbuf remainder %u\n", remainder));
    goto memerr;
  }

  /* Offset into the original pbuf is past TCP/IP headers, options, and split amount */
  offset = useg->p->tot_len - useg->len + split;
 8010d38:	693b      	ldr	r3, [r7, #16]
 8010d3a:	685b      	ldr	r3, [r3, #4]
 8010d3c:	891a      	ldrh	r2, [r3, #8]
 8010d3e:	693b      	ldr	r3, [r7, #16]
 8010d40:	891b      	ldrh	r3, [r3, #8]
 8010d42:	1ad3      	subs	r3, r2, r3
 8010d44:	b299      	uxth	r1, r3
 8010d46:	2318      	movs	r3, #24
 8010d48:	18fb      	adds	r3, r7, r3
 8010d4a:	1cba      	adds	r2, r7, #2
 8010d4c:	8812      	ldrh	r2, [r2, #0]
 8010d4e:	188a      	adds	r2, r1, r2
 8010d50:	801a      	strh	r2, [r3, #0]
  /* Copy remainder into new pbuf, headers and options will not be filled out */
  if (pbuf_copy_partial(useg->p, (u8_t *)p->payload + optlen, remainder, offset ) != remainder) {
 8010d52:	693b      	ldr	r3, [r7, #16]
 8010d54:	6858      	ldr	r0, [r3, #4]
 8010d56:	6a3b      	ldr	r3, [r7, #32]
 8010d58:	685a      	ldr	r2, [r3, #4]
 8010d5a:	0026      	movs	r6, r4
 8010d5c:	193b      	adds	r3, r7, r4
 8010d5e:	781b      	ldrb	r3, [r3, #0]
 8010d60:	18d1      	adds	r1, r2, r3
 8010d62:	2318      	movs	r3, #24
 8010d64:	18fb      	adds	r3, r7, r3
 8010d66:	881c      	ldrh	r4, [r3, #0]
 8010d68:	197b      	adds	r3, r7, r5
 8010d6a:	881a      	ldrh	r2, [r3, #0]
 8010d6c:	0023      	movs	r3, r4
 8010d6e:	f7f9 fe7f 	bl	800aa70 <pbuf_copy_partial>
 8010d72:	0003      	movs	r3, r0
 8010d74:	001a      	movs	r2, r3
 8010d76:	197b      	adds	r3, r7, r5
 8010d78:	881b      	ldrh	r3, [r3, #0]
 8010d7a:	4293      	cmp	r3, r2
 8010d7c:	d000      	beq.n	8010d80 <tcp_split_unsent_seg+0x14c>
 8010d7e:	e175      	b.n	801106c <tcp_split_unsent_seg+0x438>
                ("tcp_split_unsent_seg: could not copy pbuf remainder %u\n", remainder));
    goto memerr;
  }
#if TCP_CHECKSUM_ON_COPY
  /* calculate the checksum on remainder data */
  tcp_seg_add_chksum(~inet_chksum((const u8_t *)p->payload + optlen, remainder), remainder,
 8010d80:	6a3b      	ldr	r3, [r7, #32]
 8010d82:	685a      	ldr	r2, [r3, #4]
 8010d84:	19bb      	adds	r3, r7, r6
 8010d86:	781b      	ldrb	r3, [r3, #0]
 8010d88:	18d2      	adds	r2, r2, r3
 8010d8a:	197b      	adds	r3, r7, r5
 8010d8c:	881b      	ldrh	r3, [r3, #0]
 8010d8e:	0019      	movs	r1, r3
 8010d90:	0010      	movs	r0, r2
 8010d92:	f7f7 ff1d 	bl	8008bd0 <inet_chksum>
 8010d96:	0003      	movs	r3, r0
 8010d98:	43db      	mvns	r3, r3
 8010d9a:	b298      	uxth	r0, r3
 8010d9c:	2309      	movs	r3, #9
 8010d9e:	18fc      	adds	r4, r7, r3
 8010da0:	230a      	movs	r3, #10
 8010da2:	18fa      	adds	r2, r7, r3
 8010da4:	197b      	adds	r3, r7, r5
 8010da6:	8819      	ldrh	r1, [r3, #0]
 8010da8:	0023      	movs	r3, r4
 8010daa:	f7ff f92b 	bl	8010004 <tcp_seg_add_chksum>
#endif /* TCP_CHECKSUM_ON_COPY */

  /* Options are created when calling tcp_output() */

  /* Migrate flags from original segment */
  split_flags = TCPH_FLAGS(useg->tcphdr);
 8010dae:	693b      	ldr	r3, [r7, #16]
 8010db0:	691b      	ldr	r3, [r3, #16]
 8010db2:	7b1a      	ldrb	r2, [r3, #12]
 8010db4:	7b5b      	ldrb	r3, [r3, #13]
 8010db6:	021b      	lsls	r3, r3, #8
 8010db8:	4313      	orrs	r3, r2
 8010dba:	b29b      	uxth	r3, r3
 8010dbc:	0018      	movs	r0, r3
 8010dbe:	f7f6 fb1f 	bl	8007400 <lwip_htons>
 8010dc2:	0003      	movs	r3, r0
 8010dc4:	b2da      	uxtb	r2, r3
 8010dc6:	2027      	movs	r0, #39	; 0x27
 8010dc8:	183b      	adds	r3, r7, r0
 8010dca:	213f      	movs	r1, #63	; 0x3f
 8010dcc:	400a      	ands	r2, r1
 8010dce:	701a      	strb	r2, [r3, #0]
  remainder_flags = 0; /* ACK added in tcp_output() */
 8010dd0:	241b      	movs	r4, #27
 8010dd2:	193b      	adds	r3, r7, r4
 8010dd4:	2200      	movs	r2, #0
 8010dd6:	701a      	strb	r2, [r3, #0]

  if (split_flags & TCP_PSH) {
 8010dd8:	183b      	adds	r3, r7, r0
 8010dda:	781b      	ldrb	r3, [r3, #0]
 8010ddc:	2208      	movs	r2, #8
 8010dde:	4013      	ands	r3, r2
 8010de0:	d00b      	beq.n	8010dfa <tcp_split_unsent_seg+0x1c6>
    split_flags &= ~TCP_PSH;
 8010de2:	183b      	adds	r3, r7, r0
 8010de4:	183a      	adds	r2, r7, r0
 8010de6:	7812      	ldrb	r2, [r2, #0]
 8010de8:	2108      	movs	r1, #8
 8010dea:	438a      	bics	r2, r1
 8010dec:	701a      	strb	r2, [r3, #0]
    remainder_flags |= TCP_PSH;
 8010dee:	193b      	adds	r3, r7, r4
 8010df0:	193a      	adds	r2, r7, r4
 8010df2:	7812      	ldrb	r2, [r2, #0]
 8010df4:	2108      	movs	r1, #8
 8010df6:	430a      	orrs	r2, r1
 8010df8:	701a      	strb	r2, [r3, #0]
  }
  if (split_flags & TCP_FIN) {
 8010dfa:	2127      	movs	r1, #39	; 0x27
 8010dfc:	187b      	adds	r3, r7, r1
 8010dfe:	781b      	ldrb	r3, [r3, #0]
 8010e00:	2201      	movs	r2, #1
 8010e02:	4013      	ands	r3, r2
 8010e04:	d00c      	beq.n	8010e20 <tcp_split_unsent_seg+0x1ec>
    split_flags &= ~TCP_FIN;
 8010e06:	187b      	adds	r3, r7, r1
 8010e08:	187a      	adds	r2, r7, r1
 8010e0a:	7812      	ldrb	r2, [r2, #0]
 8010e0c:	2101      	movs	r1, #1
 8010e0e:	438a      	bics	r2, r1
 8010e10:	701a      	strb	r2, [r3, #0]
    remainder_flags |= TCP_FIN;
 8010e12:	221b      	movs	r2, #27
 8010e14:	18bb      	adds	r3, r7, r2
 8010e16:	18ba      	adds	r2, r7, r2
 8010e18:	7812      	ldrb	r2, [r2, #0]
 8010e1a:	2101      	movs	r1, #1
 8010e1c:	430a      	orrs	r2, r1
 8010e1e:	701a      	strb	r2, [r3, #0]
  }
  /* SYN should be left on split, RST should not be present with data */

  seg = tcp_create_segment(pcb, p, remainder_flags, lwip_ntohl(useg->tcphdr->seqno) + split, optflags);
 8010e20:	693b      	ldr	r3, [r7, #16]
 8010e22:	691b      	ldr	r3, [r3, #16]
 8010e24:	791a      	ldrb	r2, [r3, #4]
 8010e26:	7959      	ldrb	r1, [r3, #5]
 8010e28:	0209      	lsls	r1, r1, #8
 8010e2a:	430a      	orrs	r2, r1
 8010e2c:	7999      	ldrb	r1, [r3, #6]
 8010e2e:	0409      	lsls	r1, r1, #16
 8010e30:	430a      	orrs	r2, r1
 8010e32:	79db      	ldrb	r3, [r3, #7]
 8010e34:	061b      	lsls	r3, r3, #24
 8010e36:	4313      	orrs	r3, r2
 8010e38:	0018      	movs	r0, r3
 8010e3a:	f7f6 faf7 	bl	800742c <lwip_htonl>
 8010e3e:	0002      	movs	r2, r0
 8010e40:	1cbb      	adds	r3, r7, #2
 8010e42:	881b      	ldrh	r3, [r3, #0]
 8010e44:	18d4      	adds	r4, r2, r3
 8010e46:	231b      	movs	r3, #27
 8010e48:	18fb      	adds	r3, r7, r3
 8010e4a:	781a      	ldrb	r2, [r3, #0]
 8010e4c:	6a39      	ldr	r1, [r7, #32]
 8010e4e:	6878      	ldr	r0, [r7, #4]
 8010e50:	230f      	movs	r3, #15
 8010e52:	18fb      	adds	r3, r7, r3
 8010e54:	781b      	ldrb	r3, [r3, #0]
 8010e56:	9300      	str	r3, [sp, #0]
 8010e58:	0023      	movs	r3, r4
 8010e5a:	f7fe ff13 	bl	800fc84 <tcp_create_segment>
 8010e5e:	0003      	movs	r3, r0
 8010e60:	61fb      	str	r3, [r7, #28]
  if (seg == NULL) {
 8010e62:	69fb      	ldr	r3, [r7, #28]
 8010e64:	2b00      	cmp	r3, #0
 8010e66:	d102      	bne.n	8010e6e <tcp_split_unsent_seg+0x23a>
    p = NULL; /* Freed by tcp_create_segment */
 8010e68:	2300      	movs	r3, #0
 8010e6a:	623b      	str	r3, [r7, #32]
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                ("tcp_split_unsent_seg: could not create new TCP segment\n"));
    goto memerr;
 8010e6c:	e0ff      	b.n	801106e <tcp_split_unsent_seg+0x43a>
  }

#if TCP_CHECKSUM_ON_COPY
  seg->chksum = chksum;
 8010e6e:	230a      	movs	r3, #10
 8010e70:	18fb      	adds	r3, r7, r3
 8010e72:	881a      	ldrh	r2, [r3, #0]
 8010e74:	69fb      	ldr	r3, [r7, #28]
 8010e76:	819a      	strh	r2, [r3, #12]
  seg->chksum_swapped = chksum_swapped;
 8010e78:	2309      	movs	r3, #9
 8010e7a:	18fb      	adds	r3, r7, r3
 8010e7c:	781a      	ldrb	r2, [r3, #0]
 8010e7e:	69fb      	ldr	r3, [r7, #28]
 8010e80:	739a      	strb	r2, [r3, #14]
  seg->flags |= TF_SEG_DATA_CHECKSUMMED;
 8010e82:	69fb      	ldr	r3, [r7, #28]
 8010e84:	7bdb      	ldrb	r3, [r3, #15]
 8010e86:	2204      	movs	r2, #4
 8010e88:	4313      	orrs	r3, r2
 8010e8a:	b2da      	uxtb	r2, r3
 8010e8c:	69fb      	ldr	r3, [r7, #28]
 8010e8e:	73da      	strb	r2, [r3, #15]
#endif /* TCP_CHECKSUM_ON_COPY */

  /* Remove this segment from the queue since trimming it may free pbufs */
  pcb->snd_queuelen -= pbuf_clen(useg->p);
 8010e90:	693b      	ldr	r3, [r7, #16]
 8010e92:	685b      	ldr	r3, [r3, #4]
 8010e94:	0018      	movs	r0, r3
 8010e96:	f7f9 fbc1 	bl	800a61c <pbuf_clen>
 8010e9a:	0003      	movs	r3, r0
 8010e9c:	0019      	movs	r1, r3
 8010e9e:	687b      	ldr	r3, [r7, #4]
 8010ea0:	226a      	movs	r2, #106	; 0x6a
 8010ea2:	5a9b      	ldrh	r3, [r3, r2]
 8010ea4:	1a5b      	subs	r3, r3, r1
 8010ea6:	b299      	uxth	r1, r3
 8010ea8:	687b      	ldr	r3, [r7, #4]
 8010eaa:	226a      	movs	r2, #106	; 0x6a
 8010eac:	5299      	strh	r1, [r3, r2]

  /* Trim the original pbuf into our split size.  At this point our remainder segment must be setup
  successfully because we are modifying the original segment */
  pbuf_realloc(useg->p, useg->p->tot_len - remainder);
 8010eae:	693b      	ldr	r3, [r7, #16]
 8010eb0:	6858      	ldr	r0, [r3, #4]
 8010eb2:	693b      	ldr	r3, [r7, #16]
 8010eb4:	685b      	ldr	r3, [r3, #4]
 8010eb6:	891a      	ldrh	r2, [r3, #8]
 8010eb8:	240c      	movs	r4, #12
 8010eba:	193b      	adds	r3, r7, r4
 8010ebc:	881b      	ldrh	r3, [r3, #0]
 8010ebe:	1ad3      	subs	r3, r2, r3
 8010ec0:	b29b      	uxth	r3, r3
 8010ec2:	0019      	movs	r1, r3
 8010ec4:	f7f9 f952 	bl	800a16c <pbuf_realloc>
  useg->len -= remainder;
 8010ec8:	693b      	ldr	r3, [r7, #16]
 8010eca:	891a      	ldrh	r2, [r3, #8]
 8010ecc:	193b      	adds	r3, r7, r4
 8010ece:	881b      	ldrh	r3, [r3, #0]
 8010ed0:	1ad3      	subs	r3, r2, r3
 8010ed2:	b29a      	uxth	r2, r3
 8010ed4:	693b      	ldr	r3, [r7, #16]
 8010ed6:	811a      	strh	r2, [r3, #8]
  TCPH_SET_FLAG(useg->tcphdr, split_flags);
 8010ed8:	693b      	ldr	r3, [r7, #16]
 8010eda:	691b      	ldr	r3, [r3, #16]
 8010edc:	7b1a      	ldrb	r2, [r3, #12]
 8010ede:	7b5b      	ldrb	r3, [r3, #13]
 8010ee0:	021b      	lsls	r3, r3, #8
 8010ee2:	4313      	orrs	r3, r2
 8010ee4:	b29c      	uxth	r4, r3
 8010ee6:	2327      	movs	r3, #39	; 0x27
 8010ee8:	18fb      	adds	r3, r7, r3
 8010eea:	781b      	ldrb	r3, [r3, #0]
 8010eec:	b29b      	uxth	r3, r3
 8010eee:	0018      	movs	r0, r3
 8010ef0:	f7f6 fa86 	bl	8007400 <lwip_htons>
 8010ef4:	0003      	movs	r3, r0
 8010ef6:	001a      	movs	r2, r3
 8010ef8:	693b      	ldr	r3, [r7, #16]
 8010efa:	691b      	ldr	r3, [r3, #16]
 8010efc:	4322      	orrs	r2, r4
 8010efe:	b292      	uxth	r2, r2
 8010f00:	21ff      	movs	r1, #255	; 0xff
 8010f02:	4011      	ands	r1, r2
 8010f04:	000c      	movs	r4, r1
 8010f06:	7b19      	ldrb	r1, [r3, #12]
 8010f08:	2000      	movs	r0, #0
 8010f0a:	4001      	ands	r1, r0
 8010f0c:	1c08      	adds	r0, r1, #0
 8010f0e:	1c21      	adds	r1, r4, #0
 8010f10:	4301      	orrs	r1, r0
 8010f12:	7319      	strb	r1, [r3, #12]
 8010f14:	0a12      	lsrs	r2, r2, #8
 8010f16:	b290      	uxth	r0, r2
 8010f18:	7b5a      	ldrb	r2, [r3, #13]
 8010f1a:	2100      	movs	r1, #0
 8010f1c:	400a      	ands	r2, r1
 8010f1e:	1c11      	adds	r1, r2, #0
 8010f20:	1c02      	adds	r2, r0, #0
 8010f22:	430a      	orrs	r2, r1
 8010f24:	735a      	strb	r2, [r3, #13]
#if TCP_OVERSIZE_DBGCHECK
  /* By trimming, realloc may have actually shrunk the pbuf, so clear oversize_left */
  useg->oversize_left = 0;
 8010f26:	693b      	ldr	r3, [r7, #16]
 8010f28:	2200      	movs	r2, #0
 8010f2a:	815a      	strh	r2, [r3, #10]
#endif /* TCP_OVERSIZE_DBGCHECK */

  /* Add back to the queue with new trimmed pbuf */
  pcb->snd_queuelen += pbuf_clen(useg->p);
 8010f2c:	693b      	ldr	r3, [r7, #16]
 8010f2e:	685b      	ldr	r3, [r3, #4]
 8010f30:	0018      	movs	r0, r3
 8010f32:	f7f9 fb73 	bl	800a61c <pbuf_clen>
 8010f36:	0003      	movs	r3, r0
 8010f38:	0019      	movs	r1, r3
 8010f3a:	687b      	ldr	r3, [r7, #4]
 8010f3c:	226a      	movs	r2, #106	; 0x6a
 8010f3e:	5a9b      	ldrh	r3, [r3, r2]
 8010f40:	18cb      	adds	r3, r1, r3
 8010f42:	b299      	uxth	r1, r3
 8010f44:	687b      	ldr	r3, [r7, #4]
 8010f46:	226a      	movs	r2, #106	; 0x6a
 8010f48:	5299      	strh	r1, [r3, r2]

#if TCP_CHECKSUM_ON_COPY
  /* The checksum on the split segment is now incorrect. We need to re-run it over the split */
  useg->chksum = 0;
 8010f4a:	693b      	ldr	r3, [r7, #16]
 8010f4c:	2200      	movs	r2, #0
 8010f4e:	819a      	strh	r2, [r3, #12]
  useg->chksum_swapped = 0;
 8010f50:	693b      	ldr	r3, [r7, #16]
 8010f52:	2200      	movs	r2, #0
 8010f54:	739a      	strb	r2, [r3, #14]
  q = useg->p;
 8010f56:	693b      	ldr	r3, [r7, #16]
 8010f58:	685b      	ldr	r3, [r3, #4]
 8010f5a:	617b      	str	r3, [r7, #20]
  offset = q->tot_len - useg->len; /* Offset due to exposed headers */
 8010f5c:	697b      	ldr	r3, [r7, #20]
 8010f5e:	8919      	ldrh	r1, [r3, #8]
 8010f60:	693b      	ldr	r3, [r7, #16]
 8010f62:	891a      	ldrh	r2, [r3, #8]
 8010f64:	2318      	movs	r3, #24
 8010f66:	18fb      	adds	r3, r7, r3
 8010f68:	1a8a      	subs	r2, r1, r2
 8010f6a:	801a      	strh	r2, [r3, #0]

  /* Advance to the pbuf where the offset ends */
  while (q != NULL && offset > q->len) {
 8010f6c:	e00a      	b.n	8010f84 <tcp_split_unsent_seg+0x350>
    offset -= q->len;
 8010f6e:	697b      	ldr	r3, [r7, #20]
 8010f70:	895a      	ldrh	r2, [r3, #10]
 8010f72:	2118      	movs	r1, #24
 8010f74:	187b      	adds	r3, r7, r1
 8010f76:	1879      	adds	r1, r7, r1
 8010f78:	8809      	ldrh	r1, [r1, #0]
 8010f7a:	1a8a      	subs	r2, r1, r2
 8010f7c:	801a      	strh	r2, [r3, #0]
    q = q->next;
 8010f7e:	697b      	ldr	r3, [r7, #20]
 8010f80:	681b      	ldr	r3, [r3, #0]
 8010f82:	617b      	str	r3, [r7, #20]
  while (q != NULL && offset > q->len) {
 8010f84:	697b      	ldr	r3, [r7, #20]
 8010f86:	2b00      	cmp	r3, #0
 8010f88:	d006      	beq.n	8010f98 <tcp_split_unsent_seg+0x364>
 8010f8a:	697b      	ldr	r3, [r7, #20]
 8010f8c:	895b      	ldrh	r3, [r3, #10]
 8010f8e:	2218      	movs	r2, #24
 8010f90:	18ba      	adds	r2, r7, r2
 8010f92:	8812      	ldrh	r2, [r2, #0]
 8010f94:	429a      	cmp	r2, r3
 8010f96:	d8ea      	bhi.n	8010f6e <tcp_split_unsent_seg+0x33a>
  }
  LWIP_ASSERT("Found start of payload pbuf", q != NULL);
 8010f98:	697b      	ldr	r3, [r7, #20]
 8010f9a:	2b00      	cmp	r3, #0
 8010f9c:	d141      	bne.n	8011022 <tcp_split_unsent_seg+0x3ee>
 8010f9e:	4b04      	ldr	r3, [pc, #16]	; (8010fb0 <tcp_split_unsent_seg+0x37c>)
 8010fa0:	22ef      	movs	r2, #239	; 0xef
 8010fa2:	0092      	lsls	r2, r2, #2
 8010fa4:	490b      	ldr	r1, [pc, #44]	; (8010fd4 <tcp_split_unsent_seg+0x3a0>)
 8010fa6:	4805      	ldr	r0, [pc, #20]	; (8010fbc <tcp_split_unsent_seg+0x388>)
 8010fa8:	f7f1 f91c 	bl	80021e4 <app_debug_rtt_raw>
  /* Checksum the first payload pbuf accounting for offset, then other pbufs are all payload */
  for (; q != NULL; offset = 0, q = q->next) {
 8010fac:	e039      	b.n	8011022 <tcp_split_unsent_seg+0x3ee>
 8010fae:	46c0      	nop			; (mov r8, r8)
 8010fb0:	08021684 	.word	0x08021684
 8010fb4:	0000034b 	.word	0x0000034b
 8010fb8:	08021ad8 	.word	0x08021ad8
 8010fbc:	080216d0 	.word	0x080216d0
 8010fc0:	00000353 	.word	0x00000353
 8010fc4:	08021afc 	.word	0x08021afc
 8010fc8:	0000035b 	.word	0x0000035b
 8010fcc:	08021b20 	.word	0x08021b20
 8010fd0:	08021b30 	.word	0x08021b30
 8010fd4:	08021b40 	.word	0x08021b40
    tcp_seg_add_chksum(~inet_chksum((const u8_t *)q->payload + offset, q->len - offset), q->len - offset,
 8010fd8:	697b      	ldr	r3, [r7, #20]
 8010fda:	685a      	ldr	r2, [r3, #4]
 8010fdc:	2418      	movs	r4, #24
 8010fde:	193b      	adds	r3, r7, r4
 8010fe0:	881b      	ldrh	r3, [r3, #0]
 8010fe2:	18d0      	adds	r0, r2, r3
 8010fe4:	697b      	ldr	r3, [r7, #20]
 8010fe6:	895a      	ldrh	r2, [r3, #10]
 8010fe8:	193b      	adds	r3, r7, r4
 8010fea:	881b      	ldrh	r3, [r3, #0]
 8010fec:	1ad3      	subs	r3, r2, r3
 8010fee:	b29b      	uxth	r3, r3
 8010ff0:	0019      	movs	r1, r3
 8010ff2:	f7f7 fded 	bl	8008bd0 <inet_chksum>
 8010ff6:	0003      	movs	r3, r0
 8010ff8:	43db      	mvns	r3, r3
 8010ffa:	b298      	uxth	r0, r3
 8010ffc:	697b      	ldr	r3, [r7, #20]
 8010ffe:	895a      	ldrh	r2, [r3, #10]
 8011000:	193b      	adds	r3, r7, r4
 8011002:	881b      	ldrh	r3, [r3, #0]
 8011004:	1ad3      	subs	r3, r2, r3
 8011006:	b299      	uxth	r1, r3
 8011008:	693b      	ldr	r3, [r7, #16]
 801100a:	330c      	adds	r3, #12
 801100c:	001a      	movs	r2, r3
 801100e:	693b      	ldr	r3, [r7, #16]
 8011010:	330e      	adds	r3, #14
 8011012:	f7fe fff7 	bl	8010004 <tcp_seg_add_chksum>
  for (; q != NULL; offset = 0, q = q->next) {
 8011016:	193b      	adds	r3, r7, r4
 8011018:	2200      	movs	r2, #0
 801101a:	801a      	strh	r2, [r3, #0]
 801101c:	697b      	ldr	r3, [r7, #20]
 801101e:	681b      	ldr	r3, [r3, #0]
 8011020:	617b      	str	r3, [r7, #20]
 8011022:	697b      	ldr	r3, [r7, #20]
 8011024:	2b00      	cmp	r3, #0
 8011026:	d1d7      	bne.n	8010fd8 <tcp_split_unsent_seg+0x3a4>
#endif /* TCP_CHECKSUM_ON_COPY */

  /* Update number of segments on the queues. Note that length now may
   * exceed TCP_SND_QUEUELEN! We don't have to touch pcb->snd_buf
   * because the total amount of data is constant when packet is split */
  pcb->snd_queuelen += pbuf_clen(seg->p);
 8011028:	69fb      	ldr	r3, [r7, #28]
 801102a:	685b      	ldr	r3, [r3, #4]
 801102c:	0018      	movs	r0, r3
 801102e:	f7f9 faf5 	bl	800a61c <pbuf_clen>
 8011032:	0003      	movs	r3, r0
 8011034:	0019      	movs	r1, r3
 8011036:	687b      	ldr	r3, [r7, #4]
 8011038:	226a      	movs	r2, #106	; 0x6a
 801103a:	5a9b      	ldrh	r3, [r3, r2]
 801103c:	18cb      	adds	r3, r1, r3
 801103e:	b299      	uxth	r1, r3
 8011040:	687b      	ldr	r3, [r7, #4]
 8011042:	226a      	movs	r2, #106	; 0x6a
 8011044:	5299      	strh	r1, [r3, r2]

  /* Finally insert remainder into queue after split (which stays head) */
  seg->next = useg->next;
 8011046:	693b      	ldr	r3, [r7, #16]
 8011048:	681a      	ldr	r2, [r3, #0]
 801104a:	69fb      	ldr	r3, [r7, #28]
 801104c:	601a      	str	r2, [r3, #0]
  useg->next = seg;
 801104e:	693b      	ldr	r3, [r7, #16]
 8011050:	69fa      	ldr	r2, [r7, #28]
 8011052:	601a      	str	r2, [r3, #0]

#if TCP_OVERSIZE
  /* If remainder is last segment on the unsent, ensure we clear the oversize amount
   * because the remainder is always sized to the exact remaining amount */
  if (seg->next == NULL) {
 8011054:	69fb      	ldr	r3, [r7, #28]
 8011056:	681b      	ldr	r3, [r3, #0]
 8011058:	2b00      	cmp	r3, #0
 801105a:	d103      	bne.n	8011064 <tcp_split_unsent_seg+0x430>
    pcb->unsent_oversize = 0;
 801105c:	687b      	ldr	r3, [r7, #4]
 801105e:	226c      	movs	r2, #108	; 0x6c
 8011060:	2100      	movs	r1, #0
 8011062:	5299      	strh	r1, [r3, r2]
  }
#endif /* TCP_OVERSIZE */

  return ERR_OK;
 8011064:	2300      	movs	r3, #0
 8011066:	e014      	b.n	8011092 <tcp_split_unsent_seg+0x45e>
    goto memerr;
 8011068:	46c0      	nop			; (mov r8, r8)
 801106a:	e000      	b.n	801106e <tcp_split_unsent_seg+0x43a>
    goto memerr;
 801106c:	46c0      	nop			; (mov r8, r8)
memerr:
  TCP_STATS_INC(tcp.memerr);

  LWIP_ASSERT("seg == NULL", seg == NULL);
 801106e:	69fb      	ldr	r3, [r7, #28]
 8011070:	2b00      	cmp	r3, #0
 8011072:	d005      	beq.n	8011080 <tcp_split_unsent_seg+0x44c>
 8011074:	4b09      	ldr	r3, [pc, #36]	; (801109c <tcp_split_unsent_seg+0x468>)
 8011076:	4a0a      	ldr	r2, [pc, #40]	; (80110a0 <tcp_split_unsent_seg+0x46c>)
 8011078:	490a      	ldr	r1, [pc, #40]	; (80110a4 <tcp_split_unsent_seg+0x470>)
 801107a:	480b      	ldr	r0, [pc, #44]	; (80110a8 <tcp_split_unsent_seg+0x474>)
 801107c:	f7f1 f8b2 	bl	80021e4 <app_debug_rtt_raw>
  if (p != NULL) {
 8011080:	6a3b      	ldr	r3, [r7, #32]
 8011082:	2b00      	cmp	r3, #0
 8011084:	d003      	beq.n	801108e <tcp_split_unsent_seg+0x45a>
    pbuf_free(p);
 8011086:	6a3b      	ldr	r3, [r7, #32]
 8011088:	0018      	movs	r0, r3
 801108a:	f7f9 fa27 	bl	800a4dc <pbuf_free>
  }

  return ERR_MEM;
 801108e:	2301      	movs	r3, #1
 8011090:	425b      	negs	r3, r3
}
 8011092:	0018      	movs	r0, r3
 8011094:	46bd      	mov	sp, r7
 8011096:	b00b      	add	sp, #44	; 0x2c
 8011098:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801109a:	46c0      	nop			; (mov r8, r8)
 801109c:	08021684 	.word	0x08021684
 80110a0:	000003d9 	.word	0x000003d9
 80110a4:	08021b5c 	.word	0x08021b5c
 80110a8:	080216d0 	.word	0x080216d0

080110ac <tcp_send_fin>:
 * @param pcb the tcp_pcb over which to send a segment
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_fin(struct tcp_pcb *pcb)
{
 80110ac:	b590      	push	{r4, r7, lr}
 80110ae:	b085      	sub	sp, #20
 80110b0:	af00      	add	r7, sp, #0
 80110b2:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_send_fin: invalid pcb", pcb != NULL);
 80110b4:	687b      	ldr	r3, [r7, #4]
 80110b6:	2b00      	cmp	r3, #0
 80110b8:	d106      	bne.n	80110c8 <tcp_send_fin+0x1c>
 80110ba:	4b2e      	ldr	r3, [pc, #184]	; (8011174 <tcp_send_fin+0xc8>)
 80110bc:	22fb      	movs	r2, #251	; 0xfb
 80110be:	0092      	lsls	r2, r2, #2
 80110c0:	492d      	ldr	r1, [pc, #180]	; (8011178 <tcp_send_fin+0xcc>)
 80110c2:	482e      	ldr	r0, [pc, #184]	; (801117c <tcp_send_fin+0xd0>)
 80110c4:	f7f1 f88e 	bl	80021e4 <app_debug_rtt_raw>

  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
 80110c8:	687b      	ldr	r3, [r7, #4]
 80110ca:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80110cc:	2b00      	cmp	r3, #0
 80110ce:	d046      	beq.n	801115e <tcp_send_fin+0xb2>
    struct tcp_seg *last_unsent;
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 80110d0:	687b      	ldr	r3, [r7, #4]
 80110d2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80110d4:	60fb      	str	r3, [r7, #12]
 80110d6:	e002      	b.n	80110de <tcp_send_fin+0x32>
         last_unsent = last_unsent->next);
 80110d8:	68fb      	ldr	r3, [r7, #12]
 80110da:	681b      	ldr	r3, [r3, #0]
 80110dc:	60fb      	str	r3, [r7, #12]
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 80110de:	68fb      	ldr	r3, [r7, #12]
 80110e0:	681b      	ldr	r3, [r3, #0]
 80110e2:	2b00      	cmp	r3, #0
 80110e4:	d1f8      	bne.n	80110d8 <tcp_send_fin+0x2c>

    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
 80110e6:	68fb      	ldr	r3, [r7, #12]
 80110e8:	691b      	ldr	r3, [r3, #16]
 80110ea:	7b1a      	ldrb	r2, [r3, #12]
 80110ec:	7b5b      	ldrb	r3, [r3, #13]
 80110ee:	021b      	lsls	r3, r3, #8
 80110f0:	4313      	orrs	r3, r2
 80110f2:	b29b      	uxth	r3, r3
 80110f4:	0018      	movs	r0, r3
 80110f6:	f7f6 f983 	bl	8007400 <lwip_htons>
 80110fa:	0003      	movs	r3, r0
 80110fc:	b2db      	uxtb	r3, r3
 80110fe:	001a      	movs	r2, r3
 8011100:	2307      	movs	r3, #7
 8011102:	4013      	ands	r3, r2
 8011104:	d12b      	bne.n	801115e <tcp_send_fin+0xb2>
      /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
 8011106:	68fb      	ldr	r3, [r7, #12]
 8011108:	691b      	ldr	r3, [r3, #16]
 801110a:	7b1a      	ldrb	r2, [r3, #12]
 801110c:	7b5b      	ldrb	r3, [r3, #13]
 801110e:	021b      	lsls	r3, r3, #8
 8011110:	4313      	orrs	r3, r2
 8011112:	b29c      	uxth	r4, r3
 8011114:	2001      	movs	r0, #1
 8011116:	f7f6 f973 	bl	8007400 <lwip_htons>
 801111a:	0003      	movs	r3, r0
 801111c:	001a      	movs	r2, r3
 801111e:	68fb      	ldr	r3, [r7, #12]
 8011120:	691b      	ldr	r3, [r3, #16]
 8011122:	4322      	orrs	r2, r4
 8011124:	b292      	uxth	r2, r2
 8011126:	21ff      	movs	r1, #255	; 0xff
 8011128:	4011      	ands	r1, r2
 801112a:	000c      	movs	r4, r1
 801112c:	7b19      	ldrb	r1, [r3, #12]
 801112e:	2000      	movs	r0, #0
 8011130:	4001      	ands	r1, r0
 8011132:	1c08      	adds	r0, r1, #0
 8011134:	1c21      	adds	r1, r4, #0
 8011136:	4301      	orrs	r1, r0
 8011138:	7319      	strb	r1, [r3, #12]
 801113a:	0a12      	lsrs	r2, r2, #8
 801113c:	b290      	uxth	r0, r2
 801113e:	7b5a      	ldrb	r2, [r3, #13]
 8011140:	2100      	movs	r1, #0
 8011142:	400a      	ands	r2, r1
 8011144:	1c11      	adds	r1, r2, #0
 8011146:	1c02      	adds	r2, r0, #0
 8011148:	430a      	orrs	r2, r1
 801114a:	735a      	strb	r2, [r3, #13]
      tcp_set_flags(pcb, TF_FIN);
 801114c:	687b      	ldr	r3, [r7, #4]
 801114e:	8bdb      	ldrh	r3, [r3, #30]
 8011150:	2220      	movs	r2, #32
 8011152:	4313      	orrs	r3, r2
 8011154:	b29a      	uxth	r2, r3
 8011156:	687b      	ldr	r3, [r7, #4]
 8011158:	83da      	strh	r2, [r3, #30]
      return ERR_OK;
 801115a:	2300      	movs	r3, #0
 801115c:	e005      	b.n	801116a <tcp_send_fin+0xbe>
    }
  }
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue_flags(pcb, TCP_FIN);
 801115e:	687b      	ldr	r3, [r7, #4]
 8011160:	2101      	movs	r1, #1
 8011162:	0018      	movs	r0, r3
 8011164:	f000 f80c 	bl	8011180 <tcp_enqueue_flags>
 8011168:	0003      	movs	r3, r0
}
 801116a:	0018      	movs	r0, r3
 801116c:	46bd      	mov	sp, r7
 801116e:	b005      	add	sp, #20
 8011170:	bd90      	pop	{r4, r7, pc}
 8011172:	46c0      	nop			; (mov r8, r8)
 8011174:	08021684 	.word	0x08021684
 8011178:	08021b68 	.word	0x08021b68
 801117c:	080216d0 	.word	0x080216d0

08011180 <tcp_enqueue_flags>:
 * @param pcb Protocol control block for the TCP connection.
 * @param flags TCP header flags to set in the outgoing segment.
 */
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
 8011180:	b590      	push	{r4, r7, lr}
 8011182:	b089      	sub	sp, #36	; 0x24
 8011184:	af02      	add	r7, sp, #8
 8011186:	6078      	str	r0, [r7, #4]
 8011188:	000a      	movs	r2, r1
 801118a:	1cfb      	adds	r3, r7, #3
 801118c:	701a      	strb	r2, [r3, #0]
  struct pbuf *p;
  struct tcp_seg *seg;
  u8_t optflags = 0;
 801118e:	2317      	movs	r3, #23
 8011190:	18fb      	adds	r3, r7, r3
 8011192:	2200      	movs	r2, #0
 8011194:	701a      	strb	r2, [r3, #0]
  u8_t optlen = 0;
 8011196:	2316      	movs	r3, #22
 8011198:	18fb      	adds	r3, r7, r3
 801119a:	2200      	movs	r2, #0
 801119c:	701a      	strb	r2, [r3, #0]

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
 801119e:	1cfb      	adds	r3, r7, #3
 80111a0:	781b      	ldrb	r3, [r3, #0]
 80111a2:	2203      	movs	r2, #3
 80111a4:	4013      	ands	r3, r2
 80111a6:	d105      	bne.n	80111b4 <tcp_enqueue_flags+0x34>
 80111a8:	4b6a      	ldr	r3, [pc, #424]	; (8011354 <tcp_enqueue_flags+0x1d4>)
 80111aa:	4a6b      	ldr	r2, [pc, #428]	; (8011358 <tcp_enqueue_flags+0x1d8>)
 80111ac:	496b      	ldr	r1, [pc, #428]	; (801135c <tcp_enqueue_flags+0x1dc>)
 80111ae:	486c      	ldr	r0, [pc, #432]	; (8011360 <tcp_enqueue_flags+0x1e0>)
 80111b0:	f7f1 f818 	bl	80021e4 <app_debug_rtt_raw>
              (flags & (TCP_SYN | TCP_FIN)) != 0);
  LWIP_ASSERT("tcp_enqueue_flags: invalid pcb", pcb != NULL);
 80111b4:	687b      	ldr	r3, [r7, #4]
 80111b6:	2b00      	cmp	r3, #0
 80111b8:	d105      	bne.n	80111c6 <tcp_enqueue_flags+0x46>
 80111ba:	4b66      	ldr	r3, [pc, #408]	; (8011354 <tcp_enqueue_flags+0x1d4>)
 80111bc:	4a69      	ldr	r2, [pc, #420]	; (8011364 <tcp_enqueue_flags+0x1e4>)
 80111be:	496a      	ldr	r1, [pc, #424]	; (8011368 <tcp_enqueue_flags+0x1e8>)
 80111c0:	4867      	ldr	r0, [pc, #412]	; (8011360 <tcp_enqueue_flags+0x1e0>)
 80111c2:	f7f1 f80f 	bl	80021e4 <app_debug_rtt_raw>

  /* No need to check pcb->snd_queuelen if only SYN or FIN are allowed! */

  /* Get options for this segment. This is a special case since this is the
     only place where a SYN can be sent. */
  if (flags & TCP_SYN) {
 80111c6:	1cfb      	adds	r3, r7, #3
 80111c8:	781b      	ldrb	r3, [r3, #0]
 80111ca:	2202      	movs	r2, #2
 80111cc:	4013      	ands	r3, r2
 80111ce:	d003      	beq.n	80111d8 <tcp_enqueue_flags+0x58>
    optflags = TF_SEG_OPTS_MSS;
 80111d0:	2317      	movs	r3, #23
 80111d2:	18fb      	adds	r3, r7, r3
 80111d4:	2201      	movs	r2, #1
 80111d6:	701a      	strb	r2, [r3, #0]
    /* Make sure the timestamp option is only included in data segments if we
       agreed about it with the remote host (and in active open SYN segments). */
    optflags |= TF_SEG_OPTS_TS;
  }
#endif /* LWIP_TCP_TIMESTAMPS */
  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
 80111d8:	2317      	movs	r3, #23
 80111da:	18fb      	adds	r3, r7, r3
 80111dc:	781b      	ldrb	r3, [r3, #0]
 80111de:	009b      	lsls	r3, r3, #2
 80111e0:	b2da      	uxtb	r2, r3
 80111e2:	2016      	movs	r0, #22
 80111e4:	183b      	adds	r3, r7, r0
 80111e6:	2104      	movs	r1, #4
 80111e8:	400a      	ands	r2, r1
 80111ea:	701a      	strb	r2, [r3, #0]

  /* Allocate pbuf with room for TCP header + options */
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 80111ec:	183b      	adds	r3, r7, r0
 80111ee:	781b      	ldrb	r3, [r3, #0]
 80111f0:	b29b      	uxth	r3, r3
 80111f2:	22a0      	movs	r2, #160	; 0xa0
 80111f4:	0092      	lsls	r2, r2, #2
 80111f6:	0019      	movs	r1, r3
 80111f8:	2038      	movs	r0, #56	; 0x38
 80111fa:	f7f8 fe39 	bl	8009e70 <pbuf_alloc>
 80111fe:	0003      	movs	r3, r0
 8011200:	60fb      	str	r3, [r7, #12]
 8011202:	68fb      	ldr	r3, [r7, #12]
 8011204:	2b00      	cmp	r3, #0
 8011206:	d109      	bne.n	801121c <tcp_enqueue_flags+0x9c>
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
 8011208:	687b      	ldr	r3, [r7, #4]
 801120a:	8bdb      	ldrh	r3, [r3, #30]
 801120c:	2280      	movs	r2, #128	; 0x80
 801120e:	4313      	orrs	r3, r2
 8011210:	b29a      	uxth	r2, r3
 8011212:	687b      	ldr	r3, [r7, #4]
 8011214:	83da      	strh	r2, [r3, #30]
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
 8011216:	2301      	movs	r3, #1
 8011218:	425b      	negs	r3, r3
 801121a:	e097      	b.n	801134c <tcp_enqueue_flags+0x1cc>
  }
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
 801121c:	68fb      	ldr	r3, [r7, #12]
 801121e:	895a      	ldrh	r2, [r3, #10]
 8011220:	2316      	movs	r3, #22
 8011222:	18fb      	adds	r3, r7, r3
 8011224:	781b      	ldrb	r3, [r3, #0]
 8011226:	b29b      	uxth	r3, r3
 8011228:	429a      	cmp	r2, r3
 801122a:	d205      	bcs.n	8011238 <tcp_enqueue_flags+0xb8>
 801122c:	4b49      	ldr	r3, [pc, #292]	; (8011354 <tcp_enqueue_flags+0x1d4>)
 801122e:	4a4f      	ldr	r2, [pc, #316]	; (801136c <tcp_enqueue_flags+0x1ec>)
 8011230:	494f      	ldr	r1, [pc, #316]	; (8011370 <tcp_enqueue_flags+0x1f0>)
 8011232:	484b      	ldr	r0, [pc, #300]	; (8011360 <tcp_enqueue_flags+0x1e0>)
 8011234:	f7f0 ffd6 	bl	80021e4 <app_debug_rtt_raw>
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
 8011238:	687b      	ldr	r3, [r7, #4]
 801123a:	6e1c      	ldr	r4, [r3, #96]	; 0x60
 801123c:	1cfb      	adds	r3, r7, #3
 801123e:	781a      	ldrb	r2, [r3, #0]
 8011240:	68f9      	ldr	r1, [r7, #12]
 8011242:	6878      	ldr	r0, [r7, #4]
 8011244:	2317      	movs	r3, #23
 8011246:	18fb      	adds	r3, r7, r3
 8011248:	781b      	ldrb	r3, [r3, #0]
 801124a:	9300      	str	r3, [sp, #0]
 801124c:	0023      	movs	r3, r4
 801124e:	f7fe fd19 	bl	800fc84 <tcp_create_segment>
 8011252:	0003      	movs	r3, r0
 8011254:	60bb      	str	r3, [r7, #8]
 8011256:	68bb      	ldr	r3, [r7, #8]
 8011258:	2b00      	cmp	r3, #0
 801125a:	d109      	bne.n	8011270 <tcp_enqueue_flags+0xf0>
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
 801125c:	687b      	ldr	r3, [r7, #4]
 801125e:	8bdb      	ldrh	r3, [r3, #30]
 8011260:	2280      	movs	r2, #128	; 0x80
 8011262:	4313      	orrs	r3, r2
 8011264:	b29a      	uxth	r2, r3
 8011266:	687b      	ldr	r3, [r7, #4]
 8011268:	83da      	strh	r2, [r3, #30]
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
 801126a:	2301      	movs	r3, #1
 801126c:	425b      	negs	r3, r3
 801126e:	e06d      	b.n	801134c <tcp_enqueue_flags+0x1cc>
  }
  LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % LWIP_MIN(MEM_ALIGNMENT, 4)) == 0);
 8011270:	68bb      	ldr	r3, [r7, #8]
 8011272:	691b      	ldr	r3, [r3, #16]
 8011274:	001a      	movs	r2, r3
 8011276:	2303      	movs	r3, #3
 8011278:	4013      	ands	r3, r2
 801127a:	d005      	beq.n	8011288 <tcp_enqueue_flags+0x108>
 801127c:	4b35      	ldr	r3, [pc, #212]	; (8011354 <tcp_enqueue_flags+0x1d4>)
 801127e:	4a3d      	ldr	r2, [pc, #244]	; (8011374 <tcp_enqueue_flags+0x1f4>)
 8011280:	493d      	ldr	r1, [pc, #244]	; (8011378 <tcp_enqueue_flags+0x1f8>)
 8011282:	4837      	ldr	r0, [pc, #220]	; (8011360 <tcp_enqueue_flags+0x1e0>)
 8011284:	f7f0 ffae 	bl	80021e4 <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
 8011288:	68bb      	ldr	r3, [r7, #8]
 801128a:	891b      	ldrh	r3, [r3, #8]
 801128c:	2b00      	cmp	r3, #0
 801128e:	d005      	beq.n	801129c <tcp_enqueue_flags+0x11c>
 8011290:	4b30      	ldr	r3, [pc, #192]	; (8011354 <tcp_enqueue_flags+0x1d4>)
 8011292:	4a3a      	ldr	r2, [pc, #232]	; (801137c <tcp_enqueue_flags+0x1fc>)
 8011294:	493a      	ldr	r1, [pc, #232]	; (8011380 <tcp_enqueue_flags+0x200>)
 8011296:	4832      	ldr	r0, [pc, #200]	; (8011360 <tcp_enqueue_flags+0x1e0>)
 8011298:	f7f0 ffa4 	bl	80021e4 <app_debug_rtt_raw>
               lwip_ntohl(seg->tcphdr->seqno),
               lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
 801129c:	687b      	ldr	r3, [r7, #4]
 801129e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80112a0:	2b00      	cmp	r3, #0
 80112a2:	d103      	bne.n	80112ac <tcp_enqueue_flags+0x12c>
    pcb->unsent = seg;
 80112a4:	687b      	ldr	r3, [r7, #4]
 80112a6:	68ba      	ldr	r2, [r7, #8]
 80112a8:	671a      	str	r2, [r3, #112]	; 0x70
 80112aa:	e00d      	b.n	80112c8 <tcp_enqueue_flags+0x148>
  } else {
    struct tcp_seg *useg;
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
 80112ac:	687b      	ldr	r3, [r7, #4]
 80112ae:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80112b0:	613b      	str	r3, [r7, #16]
 80112b2:	e002      	b.n	80112ba <tcp_enqueue_flags+0x13a>
 80112b4:	693b      	ldr	r3, [r7, #16]
 80112b6:	681b      	ldr	r3, [r3, #0]
 80112b8:	613b      	str	r3, [r7, #16]
 80112ba:	693b      	ldr	r3, [r7, #16]
 80112bc:	681b      	ldr	r3, [r3, #0]
 80112be:	2b00      	cmp	r3, #0
 80112c0:	d1f8      	bne.n	80112b4 <tcp_enqueue_flags+0x134>
    useg->next = seg;
 80112c2:	693b      	ldr	r3, [r7, #16]
 80112c4:	68ba      	ldr	r2, [r7, #8]
 80112c6:	601a      	str	r2, [r3, #0]
  }
#if TCP_OVERSIZE
  /* The new unsent tail has no space */
  pcb->unsent_oversize = 0;
 80112c8:	687b      	ldr	r3, [r7, #4]
 80112ca:	226c      	movs	r2, #108	; 0x6c
 80112cc:	2100      	movs	r1, #0
 80112ce:	5299      	strh	r1, [r3, r2]
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
 80112d0:	1cfb      	adds	r3, r7, #3
 80112d2:	781b      	ldrb	r3, [r3, #0]
 80112d4:	2202      	movs	r2, #2
 80112d6:	4013      	ands	r3, r2
 80112d8:	d104      	bne.n	80112e4 <tcp_enqueue_flags+0x164>
 80112da:	1cfb      	adds	r3, r7, #3
 80112dc:	781b      	ldrb	r3, [r3, #0]
 80112de:	2201      	movs	r2, #1
 80112e0:	4013      	ands	r3, r2
 80112e2:	d004      	beq.n	80112ee <tcp_enqueue_flags+0x16e>
    pcb->snd_lbb++;
 80112e4:	687b      	ldr	r3, [r7, #4]
 80112e6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80112e8:	1c5a      	adds	r2, r3, #1
 80112ea:	687b      	ldr	r3, [r7, #4]
 80112ec:	661a      	str	r2, [r3, #96]	; 0x60
    /* optlen does not influence snd_buf */
  }
  if (flags & TCP_FIN) {
 80112ee:	1cfb      	adds	r3, r7, #3
 80112f0:	781b      	ldrb	r3, [r3, #0]
 80112f2:	2201      	movs	r2, #1
 80112f4:	4013      	ands	r3, r2
 80112f6:	d006      	beq.n	8011306 <tcp_enqueue_flags+0x186>
    tcp_set_flags(pcb, TF_FIN);
 80112f8:	687b      	ldr	r3, [r7, #4]
 80112fa:	8bdb      	ldrh	r3, [r3, #30]
 80112fc:	2220      	movs	r2, #32
 80112fe:	4313      	orrs	r3, r2
 8011300:	b29a      	uxth	r2, r3
 8011302:	687b      	ldr	r3, [r7, #4]
 8011304:	83da      	strh	r2, [r3, #30]
  }

  /* update number of segments on the queues */
  pcb->snd_queuelen += pbuf_clen(seg->p);
 8011306:	68bb      	ldr	r3, [r7, #8]
 8011308:	685b      	ldr	r3, [r3, #4]
 801130a:	0018      	movs	r0, r3
 801130c:	f7f9 f986 	bl	800a61c <pbuf_clen>
 8011310:	0003      	movs	r3, r0
 8011312:	0019      	movs	r1, r3
 8011314:	687b      	ldr	r3, [r7, #4]
 8011316:	226a      	movs	r2, #106	; 0x6a
 8011318:	5a9b      	ldrh	r3, [r3, r2]
 801131a:	18cb      	adds	r3, r1, r3
 801131c:	b299      	uxth	r1, r3
 801131e:	687b      	ldr	r3, [r7, #4]
 8011320:	226a      	movs	r2, #106	; 0x6a
 8011322:	5299      	strh	r1, [r3, r2]
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
 8011324:	687b      	ldr	r3, [r7, #4]
 8011326:	226a      	movs	r2, #106	; 0x6a
 8011328:	5a9b      	ldrh	r3, [r3, r2]
 801132a:	2b00      	cmp	r3, #0
 801132c:	d00d      	beq.n	801134a <tcp_enqueue_flags+0x1ca>
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
 801132e:	687b      	ldr	r3, [r7, #4]
 8011330:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8011332:	2b00      	cmp	r3, #0
 8011334:	d109      	bne.n	801134a <tcp_enqueue_flags+0x1ca>
 8011336:	687b      	ldr	r3, [r7, #4]
 8011338:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801133a:	2b00      	cmp	r3, #0
 801133c:	d105      	bne.n	801134a <tcp_enqueue_flags+0x1ca>
 801133e:	4b05      	ldr	r3, [pc, #20]	; (8011354 <tcp_enqueue_flags+0x1d4>)
 8011340:	4a10      	ldr	r2, [pc, #64]	; (8011384 <tcp_enqueue_flags+0x204>)
 8011342:	4911      	ldr	r1, [pc, #68]	; (8011388 <tcp_enqueue_flags+0x208>)
 8011344:	4806      	ldr	r0, [pc, #24]	; (8011360 <tcp_enqueue_flags+0x1e0>)
 8011346:	f7f0 ff4d 	bl	80021e4 <app_debug_rtt_raw>
                pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
 801134a:	2300      	movs	r3, #0
}
 801134c:	0018      	movs	r0, r3
 801134e:	46bd      	mov	sp, r7
 8011350:	b007      	add	sp, #28
 8011352:	bd90      	pop	{r4, r7, pc}
 8011354:	08021684 	.word	0x08021684
 8011358:	00000412 	.word	0x00000412
 801135c:	08021b84 	.word	0x08021b84
 8011360:	080216d0 	.word	0x080216d0
 8011364:	00000414 	.word	0x00000414
 8011368:	08021bdc 	.word	0x08021bdc
 801136c:	0000043a 	.word	0x0000043a
 8011370:	08021bfc 	.word	0x08021bfc
 8011374:	00000443 	.word	0x00000443
 8011378:	08021c38 	.word	0x08021c38
 801137c:	00000444 	.word	0x00000444
 8011380:	08021c50 	.word	0x08021c50
 8011384:	00000466 	.word	0x00000466
 8011388:	08021c7c 	.word	0x08021c7c

0801138c <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
 801138c:	b5b0      	push	{r4, r5, r7, lr}
 801138e:	b08a      	sub	sp, #40	; 0x28
 8011390:	af00      	add	r7, sp, #0
 8011392:	6078      	str	r0, [r7, #4]
  s16_t i = 0;
#endif /* TCP_CWND_DEBUG */

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ASSERT("tcp_output: invalid pcb", pcb != NULL);
 8011394:	687b      	ldr	r3, [r7, #4]
 8011396:	2b00      	cmp	r3, #0
 8011398:	d105      	bne.n	80113a6 <tcp_output+0x1a>
 801139a:	4bcb      	ldr	r3, [pc, #812]	; (80116c8 <tcp_output+0x33c>)
 801139c:	4acb      	ldr	r2, [pc, #812]	; (80116cc <tcp_output+0x340>)
 801139e:	49cc      	ldr	r1, [pc, #816]	; (80116d0 <tcp_output+0x344>)
 80113a0:	48cc      	ldr	r0, [pc, #816]	; (80116d4 <tcp_output+0x348>)
 80113a2:	f7f0 ff1f 	bl	80021e4 <app_debug_rtt_raw>
  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_output for listen-pcbs",
 80113a6:	687b      	ldr	r3, [r7, #4]
 80113a8:	7e1b      	ldrb	r3, [r3, #24]
 80113aa:	2b01      	cmp	r3, #1
 80113ac:	d105      	bne.n	80113ba <tcp_output+0x2e>
 80113ae:	4bc6      	ldr	r3, [pc, #792]	; (80116c8 <tcp_output+0x33c>)
 80113b0:	4ac9      	ldr	r2, [pc, #804]	; (80116d8 <tcp_output+0x34c>)
 80113b2:	49ca      	ldr	r1, [pc, #808]	; (80116dc <tcp_output+0x350>)
 80113b4:	48c7      	ldr	r0, [pc, #796]	; (80116d4 <tcp_output+0x348>)
 80113b6:	f7f0 ff15 	bl	80021e4 <app_debug_rtt_raw>

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
 80113ba:	4bc9      	ldr	r3, [pc, #804]	; (80116e0 <tcp_output+0x354>)
 80113bc:	681b      	ldr	r3, [r3, #0]
 80113be:	687a      	ldr	r2, [r7, #4]
 80113c0:	429a      	cmp	r2, r3
 80113c2:	d101      	bne.n	80113c8 <tcp_output+0x3c>
    return ERR_OK;
 80113c4:	2300      	movs	r3, #0
 80113c6:	e23d      	b.n	8011844 <tcp_output+0x4b8>
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
 80113c8:	687b      	ldr	r3, [r7, #4]
 80113ca:	224c      	movs	r2, #76	; 0x4c
 80113cc:	5a99      	ldrh	r1, [r3, r2]
 80113ce:	687b      	ldr	r3, [r7, #4]
 80113d0:	2264      	movs	r2, #100	; 0x64
 80113d2:	5a9b      	ldrh	r3, [r3, r2]
 80113d4:	1c18      	adds	r0, r3, #0
 80113d6:	b28a      	uxth	r2, r1
 80113d8:	b283      	uxth	r3, r0
 80113da:	429a      	cmp	r2, r3
 80113dc:	d900      	bls.n	80113e0 <tcp_output+0x54>
 80113de:	1c01      	adds	r1, r0, #0
 80113e0:	b28b      	uxth	r3, r1
 80113e2:	61bb      	str	r3, [r7, #24]

  seg = pcb->unsent;
 80113e4:	687b      	ldr	r3, [r7, #4]
 80113e6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80113e8:	627b      	str	r3, [r7, #36]	; 0x24

  if (seg == NULL) {
 80113ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80113ec:	2b00      	cmp	r3, #0
 80113ee:	d10c      	bne.n	801140a <tcp_output+0x7e>
                                 ", seg == NULL, ack %"U32_F"\n",
                                 pcb->snd_wnd, pcb->cwnd, wnd, pcb->lastack));

    /* If the TF_ACK_NOW flag is set and the ->unsent queue is empty, construct
     * an empty ACK segment and send it. */
    if (pcb->flags & TF_ACK_NOW) {
 80113f0:	687b      	ldr	r3, [r7, #4]
 80113f2:	8bdb      	ldrh	r3, [r3, #30]
 80113f4:	001a      	movs	r2, r3
 80113f6:	2302      	movs	r3, #2
 80113f8:	4013      	ands	r3, r2
 80113fa:	d100      	bne.n	80113fe <tcp_output+0x72>
 80113fc:	e215      	b.n	801182a <tcp_output+0x49e>
      return tcp_send_empty_ack(pcb);
 80113fe:	687b      	ldr	r3, [r7, #4]
 8011400:	0018      	movs	r0, r3
 8011402:	f001 f877 	bl	80124f4 <tcp_send_empty_ack>
 8011406:	0003      	movs	r3, r0
 8011408:	e21c      	b.n	8011844 <tcp_output+0x4b8>
                 pcb->snd_wnd, pcb->cwnd, wnd,
                 lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 lwip_ntohl(seg->tcphdr->seqno), pcb->lastack));
  }

  netif = tcp_route(pcb, &pcb->local_ip, &pcb->remote_ip);
 801140a:	6879      	ldr	r1, [r7, #4]
 801140c:	687b      	ldr	r3, [r7, #4]
 801140e:	1d1a      	adds	r2, r3, #4
 8011410:	687b      	ldr	r3, [r7, #4]
 8011412:	0018      	movs	r0, r3
 8011414:	f7fe fc18 	bl	800fc48 <tcp_route>
 8011418:	0003      	movs	r3, r0
 801141a:	617b      	str	r3, [r7, #20]
  if (netif == NULL) {
 801141c:	697b      	ldr	r3, [r7, #20]
 801141e:	2b00      	cmp	r3, #0
 8011420:	d102      	bne.n	8011428 <tcp_output+0x9c>
    return ERR_RTE;
 8011422:	2304      	movs	r3, #4
 8011424:	425b      	negs	r3, r3
 8011426:	e20d      	b.n	8011844 <tcp_output+0x4b8>
  }

  /* If we don't have a local IP address, we get one from netif */
  if (ip_addr_isany(&pcb->local_ip)) {
 8011428:	687b      	ldr	r3, [r7, #4]
 801142a:	2b00      	cmp	r3, #0
 801142c:	d003      	beq.n	8011436 <tcp_output+0xaa>
 801142e:	687b      	ldr	r3, [r7, #4]
 8011430:	681b      	ldr	r3, [r3, #0]
 8011432:	2b00      	cmp	r3, #0
 8011434:	d111      	bne.n	801145a <tcp_output+0xce>
    const ip_addr_t *local_ip = ip_netif_get_local_ip(netif, &pcb->remote_ip);
 8011436:	697b      	ldr	r3, [r7, #20]
 8011438:	2b00      	cmp	r3, #0
 801143a:	d002      	beq.n	8011442 <tcp_output+0xb6>
 801143c:	697b      	ldr	r3, [r7, #20]
 801143e:	3304      	adds	r3, #4
 8011440:	e000      	b.n	8011444 <tcp_output+0xb8>
 8011442:	2300      	movs	r3, #0
 8011444:	613b      	str	r3, [r7, #16]
    if (local_ip == NULL) {
 8011446:	693b      	ldr	r3, [r7, #16]
 8011448:	2b00      	cmp	r3, #0
 801144a:	d102      	bne.n	8011452 <tcp_output+0xc6>
      return ERR_RTE;
 801144c:	2304      	movs	r3, #4
 801144e:	425b      	negs	r3, r3
 8011450:	e1f8      	b.n	8011844 <tcp_output+0x4b8>
    }
    ip_addr_copy(pcb->local_ip, *local_ip);
 8011452:	693b      	ldr	r3, [r7, #16]
 8011454:	681a      	ldr	r2, [r3, #0]
 8011456:	687b      	ldr	r3, [r7, #4]
 8011458:	601a      	str	r2, [r3, #0]
  }

  /* Handle the current segment not fitting within the window */
  if (lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd) {
 801145a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801145c:	691b      	ldr	r3, [r3, #16]
 801145e:	791a      	ldrb	r2, [r3, #4]
 8011460:	7959      	ldrb	r1, [r3, #5]
 8011462:	0209      	lsls	r1, r1, #8
 8011464:	430a      	orrs	r2, r1
 8011466:	7999      	ldrb	r1, [r3, #6]
 8011468:	0409      	lsls	r1, r1, #16
 801146a:	430a      	orrs	r2, r1
 801146c:	79db      	ldrb	r3, [r3, #7]
 801146e:	061b      	lsls	r3, r3, #24
 8011470:	4313      	orrs	r3, r2
 8011472:	0018      	movs	r0, r3
 8011474:	f7f5 ffda 	bl	800742c <lwip_htonl>
 8011478:	0002      	movs	r2, r0
 801147a:	687b      	ldr	r3, [r7, #4]
 801147c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801147e:	1ad3      	subs	r3, r2, r3
 8011480:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8011482:	8912      	ldrh	r2, [r2, #8]
 8011484:	189b      	adds	r3, r3, r2
 8011486:	69ba      	ldr	r2, [r7, #24]
 8011488:	429a      	cmp	r2, r3
 801148a:	d228      	bcs.n	80114de <tcp_output+0x152>
     * within the remaining (could be 0) send window and RTO timer is not running (we
     * have no in-flight data). If window is still too small after persist timer fires,
     * then we split the segment. We don't consider the congestion window since a cwnd
     * smaller than 1 SMSS implies in-flight data
     */
    if (wnd == pcb->snd_wnd && pcb->unacked == NULL && pcb->persist_backoff == 0) {
 801148c:	687b      	ldr	r3, [r7, #4]
 801148e:	2264      	movs	r2, #100	; 0x64
 8011490:	5a9b      	ldrh	r3, [r3, r2]
 8011492:	001a      	movs	r2, r3
 8011494:	69bb      	ldr	r3, [r7, #24]
 8011496:	4293      	cmp	r3, r2
 8011498:	d114      	bne.n	80114c4 <tcp_output+0x138>
 801149a:	687b      	ldr	r3, [r7, #4]
 801149c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 801149e:	2b00      	cmp	r3, #0
 80114a0:	d110      	bne.n	80114c4 <tcp_output+0x138>
 80114a2:	687b      	ldr	r3, [r7, #4]
 80114a4:	22a5      	movs	r2, #165	; 0xa5
 80114a6:	5c9b      	ldrb	r3, [r3, r2]
 80114a8:	2b00      	cmp	r3, #0
 80114aa:	d10b      	bne.n	80114c4 <tcp_output+0x138>
      pcb->persist_cnt = 0;
 80114ac:	687b      	ldr	r3, [r7, #4]
 80114ae:	22a4      	movs	r2, #164	; 0xa4
 80114b0:	2100      	movs	r1, #0
 80114b2:	5499      	strb	r1, [r3, r2]
      pcb->persist_backoff = 1;
 80114b4:	687b      	ldr	r3, [r7, #4]
 80114b6:	22a5      	movs	r2, #165	; 0xa5
 80114b8:	2101      	movs	r1, #1
 80114ba:	5499      	strb	r1, [r3, r2]
      pcb->persist_probe = 0;
 80114bc:	687b      	ldr	r3, [r7, #4]
 80114be:	22a6      	movs	r2, #166	; 0xa6
 80114c0:	2100      	movs	r1, #0
 80114c2:	5499      	strb	r1, [r3, r2]
    }
    /* We need an ACK, but can't send data now, so send an empty ACK */
    if (pcb->flags & TF_ACK_NOW) {
 80114c4:	687b      	ldr	r3, [r7, #4]
 80114c6:	8bdb      	ldrh	r3, [r3, #30]
 80114c8:	001a      	movs	r2, r3
 80114ca:	2302      	movs	r3, #2
 80114cc:	4013      	ands	r3, r2
 80114ce:	d100      	bne.n	80114d2 <tcp_output+0x146>
 80114d0:	e1ad      	b.n	801182e <tcp_output+0x4a2>
      return tcp_send_empty_ack(pcb);
 80114d2:	687b      	ldr	r3, [r7, #4]
 80114d4:	0018      	movs	r0, r3
 80114d6:	f001 f80d 	bl	80124f4 <tcp_send_empty_ack>
 80114da:	0003      	movs	r3, r0
 80114dc:	e1b2      	b.n	8011844 <tcp_output+0x4b8>
    }
    goto output_done;
  }
  /* Stop persist timer, above conditions are not active */
  pcb->persist_backoff = 0;
 80114de:	687b      	ldr	r3, [r7, #4]
 80114e0:	22a5      	movs	r2, #165	; 0xa5
 80114e2:	2100      	movs	r1, #0
 80114e4:	5499      	strb	r1, [r3, r2]

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
 80114e6:	687b      	ldr	r3, [r7, #4]
 80114e8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80114ea:	623b      	str	r3, [r7, #32]
  if (useg != NULL) {
 80114ec:	6a3b      	ldr	r3, [r7, #32]
 80114ee:	2b00      	cmp	r3, #0
 80114f0:	d100      	bne.n	80114f4 <tcp_output+0x168>
 80114f2:	e172      	b.n	80117da <tcp_output+0x44e>
    for (; useg->next != NULL; useg = useg->next);
 80114f4:	e002      	b.n	80114fc <tcp_output+0x170>
 80114f6:	6a3b      	ldr	r3, [r7, #32]
 80114f8:	681b      	ldr	r3, [r3, #0]
 80114fa:	623b      	str	r3, [r7, #32]
 80114fc:	6a3b      	ldr	r3, [r7, #32]
 80114fe:	681b      	ldr	r3, [r3, #0]
 8011500:	2b00      	cmp	r3, #0
 8011502:	d1f8      	bne.n	80114f6 <tcp_output+0x16a>
  }
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 8011504:	e169      	b.n	80117da <tcp_output+0x44e>
         lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!",
 8011506:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011508:	691b      	ldr	r3, [r3, #16]
 801150a:	7b1a      	ldrb	r2, [r3, #12]
 801150c:	7b5b      	ldrb	r3, [r3, #13]
 801150e:	021b      	lsls	r3, r3, #8
 8011510:	4313      	orrs	r3, r2
 8011512:	b29b      	uxth	r3, r3
 8011514:	0018      	movs	r0, r3
 8011516:	f7f5 ff73 	bl	8007400 <lwip_htons>
 801151a:	0003      	movs	r3, r0
 801151c:	b2db      	uxtb	r3, r3
 801151e:	001a      	movs	r2, r3
 8011520:	2304      	movs	r3, #4
 8011522:	4013      	ands	r3, r2
 8011524:	d005      	beq.n	8011532 <tcp_output+0x1a6>
 8011526:	4b68      	ldr	r3, [pc, #416]	; (80116c8 <tcp_output+0x33c>)
 8011528:	4a6e      	ldr	r2, [pc, #440]	; (80116e4 <tcp_output+0x358>)
 801152a:	496f      	ldr	r1, [pc, #444]	; (80116e8 <tcp_output+0x35c>)
 801152c:	4869      	ldr	r0, [pc, #420]	; (80116d4 <tcp_output+0x348>)
 801152e:	f7f0 fe59 	bl	80021e4 <app_debug_rtt_raw>
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if ((tcp_do_output_nagle(pcb) == 0) &&
 8011532:	687b      	ldr	r3, [r7, #4]
 8011534:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8011536:	2b00      	cmp	r3, #0
 8011538:	d01f      	beq.n	801157a <tcp_output+0x1ee>
 801153a:	687b      	ldr	r3, [r7, #4]
 801153c:	8bdb      	ldrh	r3, [r3, #30]
 801153e:	001a      	movs	r2, r3
 8011540:	2344      	movs	r3, #68	; 0x44
 8011542:	4013      	ands	r3, r2
 8011544:	d119      	bne.n	801157a <tcp_output+0x1ee>
 8011546:	687b      	ldr	r3, [r7, #4]
 8011548:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801154a:	2b00      	cmp	r3, #0
 801154c:	d00b      	beq.n	8011566 <tcp_output+0x1da>
 801154e:	687b      	ldr	r3, [r7, #4]
 8011550:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8011552:	681b      	ldr	r3, [r3, #0]
 8011554:	2b00      	cmp	r3, #0
 8011556:	d110      	bne.n	801157a <tcp_output+0x1ee>
 8011558:	687b      	ldr	r3, [r7, #4]
 801155a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801155c:	891a      	ldrh	r2, [r3, #8]
 801155e:	687b      	ldr	r3, [r7, #4]
 8011560:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8011562:	429a      	cmp	r2, r3
 8011564:	d209      	bcs.n	801157a <tcp_output+0x1ee>
 8011566:	687b      	ldr	r3, [r7, #4]
 8011568:	2268      	movs	r2, #104	; 0x68
 801156a:	5a9b      	ldrh	r3, [r3, r2]
 801156c:	2b00      	cmp	r3, #0
 801156e:	d004      	beq.n	801157a <tcp_output+0x1ee>
 8011570:	687b      	ldr	r3, [r7, #4]
 8011572:	226a      	movs	r2, #106	; 0x6a
 8011574:	5a9b      	ldrh	r3, [r3, r2]
 8011576:	2b07      	cmp	r3, #7
 8011578:	d901      	bls.n	801157e <tcp_output+0x1f2>
 801157a:	2301      	movs	r3, #1
 801157c:	e000      	b.n	8011580 <tcp_output+0x1f4>
 801157e:	2300      	movs	r3, #0
 8011580:	2b00      	cmp	r3, #0
 8011582:	d106      	bne.n	8011592 <tcp_output+0x206>
        ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)) {
 8011584:	687b      	ldr	r3, [r7, #4]
 8011586:	8bdb      	ldrh	r3, [r3, #30]
 8011588:	001a      	movs	r2, r3
 801158a:	23a0      	movs	r3, #160	; 0xa0
 801158c:	4013      	ands	r3, r2
    if ((tcp_do_output_nagle(pcb) == 0) &&
 801158e:	d100      	bne.n	8011592 <tcp_output+0x206>
 8011590:	e141      	b.n	8011816 <tcp_output+0x48a>
                                 pcb->lastack,
                                 lwip_ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    if (pcb->state != SYN_SENT) {
 8011592:	687b      	ldr	r3, [r7, #4]
 8011594:	7e1b      	ldrb	r3, [r3, #24]
 8011596:	2b02      	cmp	r3, #2
 8011598:	d022      	beq.n	80115e0 <tcp_output+0x254>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
 801159a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801159c:	691b      	ldr	r3, [r3, #16]
 801159e:	7b1a      	ldrb	r2, [r3, #12]
 80115a0:	7b5b      	ldrb	r3, [r3, #13]
 80115a2:	021b      	lsls	r3, r3, #8
 80115a4:	4313      	orrs	r3, r2
 80115a6:	b29c      	uxth	r4, r3
 80115a8:	2010      	movs	r0, #16
 80115aa:	f7f5 ff29 	bl	8007400 <lwip_htons>
 80115ae:	0003      	movs	r3, r0
 80115b0:	001a      	movs	r2, r3
 80115b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80115b4:	691b      	ldr	r3, [r3, #16]
 80115b6:	4322      	orrs	r2, r4
 80115b8:	b292      	uxth	r2, r2
 80115ba:	21ff      	movs	r1, #255	; 0xff
 80115bc:	4011      	ands	r1, r2
 80115be:	000c      	movs	r4, r1
 80115c0:	7b19      	ldrb	r1, [r3, #12]
 80115c2:	2000      	movs	r0, #0
 80115c4:	4001      	ands	r1, r0
 80115c6:	1c08      	adds	r0, r1, #0
 80115c8:	1c21      	adds	r1, r4, #0
 80115ca:	4301      	orrs	r1, r0
 80115cc:	7319      	strb	r1, [r3, #12]
 80115ce:	0a12      	lsrs	r2, r2, #8
 80115d0:	b290      	uxth	r0, r2
 80115d2:	7b5a      	ldrb	r2, [r3, #13]
 80115d4:	2100      	movs	r1, #0
 80115d6:	400a      	ands	r2, r1
 80115d8:	1c11      	adds	r1, r2, #0
 80115da:	1c02      	adds	r2, r0, #0
 80115dc:	430a      	orrs	r2, r1
 80115de:	735a      	strb	r2, [r3, #13]
    }

    err = tcp_output_segment(seg, pcb, netif);
 80115e0:	250f      	movs	r5, #15
 80115e2:	197c      	adds	r4, r7, r5
 80115e4:	697a      	ldr	r2, [r7, #20]
 80115e6:	6879      	ldr	r1, [r7, #4]
 80115e8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80115ea:	0018      	movs	r0, r3
 80115ec:	f000 f950 	bl	8011890 <tcp_output_segment>
 80115f0:	0003      	movs	r3, r0
 80115f2:	7023      	strb	r3, [r4, #0]
    if (err != ERR_OK) {
 80115f4:	0029      	movs	r1, r5
 80115f6:	187b      	adds	r3, r7, r1
 80115f8:	781b      	ldrb	r3, [r3, #0]
 80115fa:	b25b      	sxtb	r3, r3
 80115fc:	2b00      	cmp	r3, #0
 80115fe:	d00a      	beq.n	8011616 <tcp_output+0x28a>
      /* segment could not be sent, for whatever reason */
      tcp_set_flags(pcb, TF_NAGLEMEMERR);
 8011600:	687b      	ldr	r3, [r7, #4]
 8011602:	8bdb      	ldrh	r3, [r3, #30]
 8011604:	2280      	movs	r2, #128	; 0x80
 8011606:	4313      	orrs	r3, r2
 8011608:	b29a      	uxth	r2, r3
 801160a:	687b      	ldr	r3, [r7, #4]
 801160c:	83da      	strh	r2, [r3, #30]
      return err;
 801160e:	187b      	adds	r3, r7, r1
 8011610:	781b      	ldrb	r3, [r3, #0]
 8011612:	b25b      	sxtb	r3, r3
 8011614:	e116      	b.n	8011844 <tcp_output+0x4b8>
    }
#if TCP_OVERSIZE_DBGCHECK
    seg->oversize_left = 0;
 8011616:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011618:	2200      	movs	r2, #0
 801161a:	815a      	strh	r2, [r3, #10]
#endif /* TCP_OVERSIZE_DBGCHECK */
    pcb->unsent = seg->next;
 801161c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801161e:	681a      	ldr	r2, [r3, #0]
 8011620:	687b      	ldr	r3, [r7, #4]
 8011622:	671a      	str	r2, [r3, #112]	; 0x70
    if (pcb->state != SYN_SENT) {
 8011624:	687b      	ldr	r3, [r7, #4]
 8011626:	7e1b      	ldrb	r3, [r3, #24]
 8011628:	2b02      	cmp	r3, #2
 801162a:	d006      	beq.n	801163a <tcp_output+0x2ae>
      tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 801162c:	687b      	ldr	r3, [r7, #4]
 801162e:	8bdb      	ldrh	r3, [r3, #30]
 8011630:	2203      	movs	r2, #3
 8011632:	4393      	bics	r3, r2
 8011634:	b29a      	uxth	r2, r3
 8011636:	687b      	ldr	r3, [r7, #4]
 8011638:	83da      	strh	r2, [r3, #30]
    }
    snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 801163a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801163c:	691b      	ldr	r3, [r3, #16]
 801163e:	791a      	ldrb	r2, [r3, #4]
 8011640:	7959      	ldrb	r1, [r3, #5]
 8011642:	0209      	lsls	r1, r1, #8
 8011644:	430a      	orrs	r2, r1
 8011646:	7999      	ldrb	r1, [r3, #6]
 8011648:	0409      	lsls	r1, r1, #16
 801164a:	430a      	orrs	r2, r1
 801164c:	79db      	ldrb	r3, [r3, #7]
 801164e:	061b      	lsls	r3, r3, #24
 8011650:	4313      	orrs	r3, r2
 8011652:	0018      	movs	r0, r3
 8011654:	f7f5 feea 	bl	800742c <lwip_htonl>
 8011658:	0004      	movs	r4, r0
 801165a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801165c:	891b      	ldrh	r3, [r3, #8]
 801165e:	001d      	movs	r5, r3
 8011660:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011662:	691b      	ldr	r3, [r3, #16]
 8011664:	7b1a      	ldrb	r2, [r3, #12]
 8011666:	7b5b      	ldrb	r3, [r3, #13]
 8011668:	021b      	lsls	r3, r3, #8
 801166a:	4313      	orrs	r3, r2
 801166c:	b29b      	uxth	r3, r3
 801166e:	0018      	movs	r0, r3
 8011670:	f7f5 fec6 	bl	8007400 <lwip_htons>
 8011674:	0003      	movs	r3, r0
 8011676:	b2db      	uxtb	r3, r3
 8011678:	001a      	movs	r2, r3
 801167a:	2303      	movs	r3, #3
 801167c:	4013      	ands	r3, r2
 801167e:	d001      	beq.n	8011684 <tcp_output+0x2f8>
 8011680:	2301      	movs	r3, #1
 8011682:	e000      	b.n	8011686 <tcp_output+0x2fa>
 8011684:	2300      	movs	r3, #0
 8011686:	195b      	adds	r3, r3, r5
 8011688:	18e3      	adds	r3, r4, r3
 801168a:	60bb      	str	r3, [r7, #8]
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 801168c:	687b      	ldr	r3, [r7, #4]
 801168e:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8011690:	68bb      	ldr	r3, [r7, #8]
 8011692:	1ad3      	subs	r3, r2, r3
 8011694:	d502      	bpl.n	801169c <tcp_output+0x310>
      pcb->snd_nxt = snd_nxt;
 8011696:	687b      	ldr	r3, [r7, #4]
 8011698:	68ba      	ldr	r2, [r7, #8]
 801169a:	655a      	str	r2, [r3, #84]	; 0x54
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
 801169c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801169e:	891b      	ldrh	r3, [r3, #8]
 80116a0:	001c      	movs	r4, r3
 80116a2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80116a4:	691b      	ldr	r3, [r3, #16]
 80116a6:	7b1a      	ldrb	r2, [r3, #12]
 80116a8:	7b5b      	ldrb	r3, [r3, #13]
 80116aa:	021b      	lsls	r3, r3, #8
 80116ac:	4313      	orrs	r3, r2
 80116ae:	b29b      	uxth	r3, r3
 80116b0:	0018      	movs	r0, r3
 80116b2:	f7f5 fea5 	bl	8007400 <lwip_htons>
 80116b6:	0003      	movs	r3, r0
 80116b8:	b2db      	uxtb	r3, r3
 80116ba:	001a      	movs	r2, r3
 80116bc:	2303      	movs	r3, #3
 80116be:	4013      	ands	r3, r2
 80116c0:	d014      	beq.n	80116ec <tcp_output+0x360>
 80116c2:	2301      	movs	r3, #1
 80116c4:	e013      	b.n	80116ee <tcp_output+0x362>
 80116c6:	46c0      	nop			; (mov r8, r8)
 80116c8:	08021684 	.word	0x08021684
 80116cc:	000004e2 	.word	0x000004e2
 80116d0:	08021ca4 	.word	0x08021ca4
 80116d4:	080216d0 	.word	0x080216d0
 80116d8:	000004e4 	.word	0x000004e4
 80116dc:	08021cbc 	.word	0x08021cbc
 80116e0:	200027a0 	.word	0x200027a0
 80116e4:	00000537 	.word	0x00000537
 80116e8:	08021ce4 	.word	0x08021ce4
 80116ec:	2300      	movs	r3, #0
 80116ee:	191b      	adds	r3, r3, r4
 80116f0:	2b00      	cmp	r3, #0
 80116f2:	d06b      	beq.n	80117cc <tcp_output+0x440>
      seg->next = NULL;
 80116f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80116f6:	2200      	movs	r2, #0
 80116f8:	601a      	str	r2, [r3, #0]
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
 80116fa:	687b      	ldr	r3, [r7, #4]
 80116fc:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80116fe:	2b00      	cmp	r3, #0
 8011700:	d105      	bne.n	801170e <tcp_output+0x382>
        pcb->unacked = seg;
 8011702:	687b      	ldr	r3, [r7, #4]
 8011704:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8011706:	675a      	str	r2, [r3, #116]	; 0x74
        useg = seg;
 8011708:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801170a:	623b      	str	r3, [r7, #32]
 801170c:	e062      	b.n	80117d4 <tcp_output+0x448>
        /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(lwip_ntohl(seg->tcphdr->seqno), lwip_ntohl(useg->tcphdr->seqno))) {
 801170e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011710:	691b      	ldr	r3, [r3, #16]
 8011712:	791a      	ldrb	r2, [r3, #4]
 8011714:	7959      	ldrb	r1, [r3, #5]
 8011716:	0209      	lsls	r1, r1, #8
 8011718:	430a      	orrs	r2, r1
 801171a:	7999      	ldrb	r1, [r3, #6]
 801171c:	0409      	lsls	r1, r1, #16
 801171e:	430a      	orrs	r2, r1
 8011720:	79db      	ldrb	r3, [r3, #7]
 8011722:	061b      	lsls	r3, r3, #24
 8011724:	4313      	orrs	r3, r2
 8011726:	0018      	movs	r0, r3
 8011728:	f7f5 fe80 	bl	800742c <lwip_htonl>
 801172c:	0004      	movs	r4, r0
 801172e:	6a3b      	ldr	r3, [r7, #32]
 8011730:	691b      	ldr	r3, [r3, #16]
 8011732:	791a      	ldrb	r2, [r3, #4]
 8011734:	7959      	ldrb	r1, [r3, #5]
 8011736:	0209      	lsls	r1, r1, #8
 8011738:	430a      	orrs	r2, r1
 801173a:	7999      	ldrb	r1, [r3, #6]
 801173c:	0409      	lsls	r1, r1, #16
 801173e:	430a      	orrs	r2, r1
 8011740:	79db      	ldrb	r3, [r3, #7]
 8011742:	061b      	lsls	r3, r3, #24
 8011744:	4313      	orrs	r3, r2
 8011746:	0018      	movs	r0, r3
 8011748:	f7f5 fe70 	bl	800742c <lwip_htonl>
 801174c:	0003      	movs	r3, r0
 801174e:	1ae3      	subs	r3, r4, r3
 8011750:	d535      	bpl.n	80117be <tcp_output+0x432>
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
 8011752:	687b      	ldr	r3, [r7, #4]
 8011754:	3374      	adds	r3, #116	; 0x74
 8011756:	61fb      	str	r3, [r7, #28]
          while (*cur_seg &&
 8011758:	e002      	b.n	8011760 <tcp_output+0x3d4>
                 TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
            cur_seg = &((*cur_seg)->next );
 801175a:	69fb      	ldr	r3, [r7, #28]
 801175c:	681b      	ldr	r3, [r3, #0]
 801175e:	61fb      	str	r3, [r7, #28]
          while (*cur_seg &&
 8011760:	69fb      	ldr	r3, [r7, #28]
 8011762:	681b      	ldr	r3, [r3, #0]
 8011764:	2b00      	cmp	r3, #0
 8011766:	d022      	beq.n	80117ae <tcp_output+0x422>
                 TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
 8011768:	69fb      	ldr	r3, [r7, #28]
 801176a:	681b      	ldr	r3, [r3, #0]
 801176c:	691b      	ldr	r3, [r3, #16]
 801176e:	791a      	ldrb	r2, [r3, #4]
 8011770:	7959      	ldrb	r1, [r3, #5]
 8011772:	0209      	lsls	r1, r1, #8
 8011774:	430a      	orrs	r2, r1
 8011776:	7999      	ldrb	r1, [r3, #6]
 8011778:	0409      	lsls	r1, r1, #16
 801177a:	430a      	orrs	r2, r1
 801177c:	79db      	ldrb	r3, [r3, #7]
 801177e:	061b      	lsls	r3, r3, #24
 8011780:	4313      	orrs	r3, r2
 8011782:	0018      	movs	r0, r3
 8011784:	f7f5 fe52 	bl	800742c <lwip_htonl>
 8011788:	0004      	movs	r4, r0
 801178a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801178c:	691b      	ldr	r3, [r3, #16]
 801178e:	791a      	ldrb	r2, [r3, #4]
 8011790:	7959      	ldrb	r1, [r3, #5]
 8011792:	0209      	lsls	r1, r1, #8
 8011794:	430a      	orrs	r2, r1
 8011796:	7999      	ldrb	r1, [r3, #6]
 8011798:	0409      	lsls	r1, r1, #16
 801179a:	430a      	orrs	r2, r1
 801179c:	79db      	ldrb	r3, [r3, #7]
 801179e:	061b      	lsls	r3, r3, #24
 80117a0:	4313      	orrs	r3, r2
 80117a2:	0018      	movs	r0, r3
 80117a4:	f7f5 fe42 	bl	800742c <lwip_htonl>
 80117a8:	0003      	movs	r3, r0
 80117aa:	1ae3      	subs	r3, r4, r3
          while (*cur_seg &&
 80117ac:	d4d5      	bmi.n	801175a <tcp_output+0x3ce>
          }
          seg->next = (*cur_seg);
 80117ae:	69fb      	ldr	r3, [r7, #28]
 80117b0:	681a      	ldr	r2, [r3, #0]
 80117b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80117b4:	601a      	str	r2, [r3, #0]
          (*cur_seg) = seg;
 80117b6:	69fb      	ldr	r3, [r7, #28]
 80117b8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80117ba:	601a      	str	r2, [r3, #0]
 80117bc:	e00a      	b.n	80117d4 <tcp_output+0x448>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
 80117be:	6a3b      	ldr	r3, [r7, #32]
 80117c0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80117c2:	601a      	str	r2, [r3, #0]
          useg = useg->next;
 80117c4:	6a3b      	ldr	r3, [r7, #32]
 80117c6:	681b      	ldr	r3, [r3, #0]
 80117c8:	623b      	str	r3, [r7, #32]
 80117ca:	e003      	b.n	80117d4 <tcp_output+0x448>
        }
      }
      /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
 80117cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80117ce:	0018      	movs	r0, r3
 80117d0:	f7fa fee0 	bl	800c594 <tcp_seg_free>
    }
    seg = pcb->unsent;
 80117d4:	687b      	ldr	r3, [r7, #4]
 80117d6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80117d8:	627b      	str	r3, [r7, #36]	; 0x24
  while (seg != NULL &&
 80117da:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80117dc:	2b00      	cmp	r3, #0
 80117de:	d01b      	beq.n	8011818 <tcp_output+0x48c>
         lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
 80117e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80117e2:	691b      	ldr	r3, [r3, #16]
 80117e4:	791a      	ldrb	r2, [r3, #4]
 80117e6:	7959      	ldrb	r1, [r3, #5]
 80117e8:	0209      	lsls	r1, r1, #8
 80117ea:	430a      	orrs	r2, r1
 80117ec:	7999      	ldrb	r1, [r3, #6]
 80117ee:	0409      	lsls	r1, r1, #16
 80117f0:	430a      	orrs	r2, r1
 80117f2:	79db      	ldrb	r3, [r3, #7]
 80117f4:	061b      	lsls	r3, r3, #24
 80117f6:	4313      	orrs	r3, r2
 80117f8:	0018      	movs	r0, r3
 80117fa:	f7f5 fe17 	bl	800742c <lwip_htonl>
 80117fe:	0002      	movs	r2, r0
 8011800:	687b      	ldr	r3, [r7, #4]
 8011802:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8011804:	1ad3      	subs	r3, r2, r3
 8011806:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8011808:	8912      	ldrh	r2, [r2, #8]
 801180a:	189b      	adds	r3, r3, r2
  while (seg != NULL &&
 801180c:	69ba      	ldr	r2, [r7, #24]
 801180e:	429a      	cmp	r2, r3
 8011810:	d300      	bcc.n	8011814 <tcp_output+0x488>
 8011812:	e678      	b.n	8011506 <tcp_output+0x17a>
 8011814:	e000      	b.n	8011818 <tcp_output+0x48c>
      break;
 8011816:	46c0      	nop			; (mov r8, r8)
  }
#if TCP_OVERSIZE
  if (pcb->unsent == NULL) {
 8011818:	687b      	ldr	r3, [r7, #4]
 801181a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801181c:	2b00      	cmp	r3, #0
 801181e:	d108      	bne.n	8011832 <tcp_output+0x4a6>
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
 8011820:	687b      	ldr	r3, [r7, #4]
 8011822:	226c      	movs	r2, #108	; 0x6c
 8011824:	2100      	movs	r1, #0
 8011826:	5299      	strh	r1, [r3, r2]
 8011828:	e004      	b.n	8011834 <tcp_output+0x4a8>
    goto output_done;
 801182a:	46c0      	nop			; (mov r8, r8)
 801182c:	e002      	b.n	8011834 <tcp_output+0x4a8>
    goto output_done;
 801182e:	46c0      	nop			; (mov r8, r8)
 8011830:	e000      	b.n	8011834 <tcp_output+0x4a8>
  }
#endif /* TCP_OVERSIZE */

output_done:
 8011832:	46c0      	nop			; (mov r8, r8)
  tcp_clear_flags(pcb, TF_NAGLEMEMERR);
 8011834:	687b      	ldr	r3, [r7, #4]
 8011836:	8bdb      	ldrh	r3, [r3, #30]
 8011838:	2280      	movs	r2, #128	; 0x80
 801183a:	4393      	bics	r3, r2
 801183c:	b29a      	uxth	r2, r3
 801183e:	687b      	ldr	r3, [r7, #4]
 8011840:	83da      	strh	r2, [r3, #30]
  return ERR_OK;
 8011842:	2300      	movs	r3, #0
}
 8011844:	0018      	movs	r0, r3
 8011846:	46bd      	mov	sp, r7
 8011848:	b00a      	add	sp, #40	; 0x28
 801184a:	bdb0      	pop	{r4, r5, r7, pc}

0801184c <tcp_output_segment_busy>:
 * @arg seg the tcp segment to check
 * @return 1 if ref != 1, 0 if ref == 1
 */
static int
tcp_output_segment_busy(const struct tcp_seg *seg)
{
 801184c:	b580      	push	{r7, lr}
 801184e:	b082      	sub	sp, #8
 8011850:	af00      	add	r7, sp, #0
 8011852:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_output_segment_busy: invalid seg", seg != NULL);
 8011854:	687b      	ldr	r3, [r7, #4]
 8011856:	2b00      	cmp	r3, #0
 8011858:	d105      	bne.n	8011866 <tcp_output_segment_busy+0x1a>
 801185a:	4b09      	ldr	r3, [pc, #36]	; (8011880 <tcp_output_segment_busy+0x34>)
 801185c:	4a09      	ldr	r2, [pc, #36]	; (8011884 <tcp_output_segment_busy+0x38>)
 801185e:	490a      	ldr	r1, [pc, #40]	; (8011888 <tcp_output_segment_busy+0x3c>)
 8011860:	480a      	ldr	r0, [pc, #40]	; (801188c <tcp_output_segment_busy+0x40>)
 8011862:	f7f0 fcbf 	bl	80021e4 <app_debug_rtt_raw>

  /* We only need to check the first pbuf here:
     If a pbuf is queued for transmission, a driver calls pbuf_ref(),
     which only changes the ref count of the first pbuf */
  if (seg->p->ref != 1) {
 8011866:	687b      	ldr	r3, [r7, #4]
 8011868:	685b      	ldr	r3, [r3, #4]
 801186a:	7b9b      	ldrb	r3, [r3, #14]
 801186c:	2b01      	cmp	r3, #1
 801186e:	d001      	beq.n	8011874 <tcp_output_segment_busy+0x28>
    /* other reference found */
    return 1;
 8011870:	2301      	movs	r3, #1
 8011872:	e000      	b.n	8011876 <tcp_output_segment_busy+0x2a>
  }
  /* no other references found */
  return 0;
 8011874:	2300      	movs	r3, #0
}
 8011876:	0018      	movs	r0, r3
 8011878:	46bd      	mov	sp, r7
 801187a:	b002      	add	sp, #8
 801187c:	bd80      	pop	{r7, pc}
 801187e:	46c0      	nop			; (mov r8, r8)
 8011880:	08021684 	.word	0x08021684
 8011884:	0000059b 	.word	0x0000059b
 8011888:	08021cfc 	.word	0x08021cfc
 801188c:	080216d0 	.word	0x080216d0

08011890 <tcp_output_segment>:
 * @param pcb the tcp_pcb for the TCP connection used to send the segment
 * @param netif the netif used to send the segment
 */
static err_t
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb, struct netif *netif)
{
 8011890:	b5f0      	push	{r4, r5, r6, r7, lr}
 8011892:	b08f      	sub	sp, #60	; 0x3c
 8011894:	af04      	add	r7, sp, #16
 8011896:	60f8      	str	r0, [r7, #12]
 8011898:	60b9      	str	r1, [r7, #8]
 801189a:	607a      	str	r2, [r7, #4]
  err_t err;
  u16_t len;
  u32_t *opts;
#if TCP_CHECKSUM_ON_COPY
  int seg_chksum_was_swapped = 0;
 801189c:	2300      	movs	r3, #0
 801189e:	623b      	str	r3, [r7, #32]
#endif

  LWIP_ASSERT("tcp_output_segment: invalid seg", seg != NULL);
 80118a0:	68fb      	ldr	r3, [r7, #12]
 80118a2:	2b00      	cmp	r3, #0
 80118a4:	d105      	bne.n	80118b2 <tcp_output_segment+0x22>
 80118a6:	4bda      	ldr	r3, [pc, #872]	; (8011c10 <tcp_output_segment+0x380>)
 80118a8:	4ada      	ldr	r2, [pc, #872]	; (8011c14 <tcp_output_segment+0x384>)
 80118aa:	49db      	ldr	r1, [pc, #876]	; (8011c18 <tcp_output_segment+0x388>)
 80118ac:	48db      	ldr	r0, [pc, #876]	; (8011c1c <tcp_output_segment+0x38c>)
 80118ae:	f7f0 fc99 	bl	80021e4 <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_output_segment: invalid pcb", pcb != NULL);
 80118b2:	68bb      	ldr	r3, [r7, #8]
 80118b4:	2b00      	cmp	r3, #0
 80118b6:	d105      	bne.n	80118c4 <tcp_output_segment+0x34>
 80118b8:	4bd5      	ldr	r3, [pc, #852]	; (8011c10 <tcp_output_segment+0x380>)
 80118ba:	4ad9      	ldr	r2, [pc, #868]	; (8011c20 <tcp_output_segment+0x390>)
 80118bc:	49d9      	ldr	r1, [pc, #868]	; (8011c24 <tcp_output_segment+0x394>)
 80118be:	48d7      	ldr	r0, [pc, #860]	; (8011c1c <tcp_output_segment+0x38c>)
 80118c0:	f7f0 fc90 	bl	80021e4 <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_output_segment: invalid netif", netif != NULL);
 80118c4:	687b      	ldr	r3, [r7, #4]
 80118c6:	2b00      	cmp	r3, #0
 80118c8:	d105      	bne.n	80118d6 <tcp_output_segment+0x46>
 80118ca:	4bd1      	ldr	r3, [pc, #836]	; (8011c10 <tcp_output_segment+0x380>)
 80118cc:	4ad6      	ldr	r2, [pc, #856]	; (8011c28 <tcp_output_segment+0x398>)
 80118ce:	49d7      	ldr	r1, [pc, #860]	; (8011c2c <tcp_output_segment+0x39c>)
 80118d0:	48d2      	ldr	r0, [pc, #840]	; (8011c1c <tcp_output_segment+0x38c>)
 80118d2:	f7f0 fc87 	bl	80021e4 <app_debug_rtt_raw>

  if (tcp_output_segment_busy(seg)) {
 80118d6:	68fb      	ldr	r3, [r7, #12]
 80118d8:	0018      	movs	r0, r3
 80118da:	f7ff ffb7 	bl	801184c <tcp_output_segment_busy>
 80118de:	1e03      	subs	r3, r0, #0
 80118e0:	d001      	beq.n	80118e6 <tcp_output_segment+0x56>
    /* This should not happen: rexmit functions should have checked this.
       However, since this function modifies p->len, we must not continue in this case. */
    LWIP_DEBUGF(TCP_RTO_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_output_segment: segment busy\n"));
    return ERR_OK;
 80118e2:	2300      	movs	r3, #0
 80118e4:	e190      	b.n	8011c08 <tcp_output_segment+0x378>
  }

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = lwip_htonl(pcb->rcv_nxt);
 80118e6:	68bb      	ldr	r3, [r7, #8]
 80118e8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80118ea:	68fb      	ldr	r3, [r7, #12]
 80118ec:	691c      	ldr	r4, [r3, #16]
 80118ee:	0010      	movs	r0, r2
 80118f0:	f7f5 fd9c 	bl	800742c <lwip_htonl>
 80118f4:	0003      	movs	r3, r0
 80118f6:	22ff      	movs	r2, #255	; 0xff
 80118f8:	401a      	ands	r2, r3
 80118fa:	0010      	movs	r0, r2
 80118fc:	7a22      	ldrb	r2, [r4, #8]
 80118fe:	2100      	movs	r1, #0
 8011900:	400a      	ands	r2, r1
 8011902:	1c11      	adds	r1, r2, #0
 8011904:	1c02      	adds	r2, r0, #0
 8011906:	430a      	orrs	r2, r1
 8011908:	7222      	strb	r2, [r4, #8]
 801190a:	0a1a      	lsrs	r2, r3, #8
 801190c:	21ff      	movs	r1, #255	; 0xff
 801190e:	400a      	ands	r2, r1
 8011910:	0010      	movs	r0, r2
 8011912:	7a62      	ldrb	r2, [r4, #9]
 8011914:	2100      	movs	r1, #0
 8011916:	400a      	ands	r2, r1
 8011918:	1c11      	adds	r1, r2, #0
 801191a:	1c02      	adds	r2, r0, #0
 801191c:	430a      	orrs	r2, r1
 801191e:	7262      	strb	r2, [r4, #9]
 8011920:	0c1a      	lsrs	r2, r3, #16
 8011922:	21ff      	movs	r1, #255	; 0xff
 8011924:	400a      	ands	r2, r1
 8011926:	0010      	movs	r0, r2
 8011928:	7aa2      	ldrb	r2, [r4, #10]
 801192a:	2100      	movs	r1, #0
 801192c:	400a      	ands	r2, r1
 801192e:	1c11      	adds	r1, r2, #0
 8011930:	1c02      	adds	r2, r0, #0
 8011932:	430a      	orrs	r2, r1
 8011934:	72a2      	strb	r2, [r4, #10]
 8011936:	0e19      	lsrs	r1, r3, #24
 8011938:	7ae3      	ldrb	r3, [r4, #11]
 801193a:	2200      	movs	r2, #0
 801193c:	4013      	ands	r3, r2
 801193e:	1c1a      	adds	r2, r3, #0
 8011940:	1c0b      	adds	r3, r1, #0
 8011942:	4313      	orrs	r3, r2
 8011944:	72e3      	strb	r3, [r4, #11]
       the window scale option) is never scaled. */
    seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(pcb->rcv_ann_wnd));
  } else
#endif /* LWIP_WND_SCALE */
  {
    seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
 8011946:	68bb      	ldr	r3, [r7, #8]
 8011948:	8dda      	ldrh	r2, [r3, #46]	; 0x2e
 801194a:	68fb      	ldr	r3, [r7, #12]
 801194c:	691c      	ldr	r4, [r3, #16]
 801194e:	0010      	movs	r0, r2
 8011950:	f7f5 fd56 	bl	8007400 <lwip_htons>
 8011954:	0003      	movs	r3, r0
 8011956:	22ff      	movs	r2, #255	; 0xff
 8011958:	401a      	ands	r2, r3
 801195a:	0010      	movs	r0, r2
 801195c:	7ba2      	ldrb	r2, [r4, #14]
 801195e:	2100      	movs	r1, #0
 8011960:	400a      	ands	r2, r1
 8011962:	1c11      	adds	r1, r2, #0
 8011964:	1c02      	adds	r2, r0, #0
 8011966:	430a      	orrs	r2, r1
 8011968:	73a2      	strb	r2, [r4, #14]
 801196a:	0a1b      	lsrs	r3, r3, #8
 801196c:	b299      	uxth	r1, r3
 801196e:	7be3      	ldrb	r3, [r4, #15]
 8011970:	2200      	movs	r2, #0
 8011972:	4013      	ands	r3, r2
 8011974:	1c1a      	adds	r2, r3, #0
 8011976:	1c0b      	adds	r3, r1, #0
 8011978:	4313      	orrs	r3, r2
 801197a:	73e3      	strb	r3, [r4, #15]
  }

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 801197c:	68bb      	ldr	r3, [r7, #8]
 801197e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8011980:	68ba      	ldr	r2, [r7, #8]
 8011982:	8dd2      	ldrh	r2, [r2, #46]	; 0x2e
 8011984:	189a      	adds	r2, r3, r2
 8011986:	68bb      	ldr	r3, [r7, #8]
 8011988:	631a      	str	r2, [r3, #48]	; 0x30

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  /* cast through void* to get rid of alignment warnings */
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
 801198a:	68fb      	ldr	r3, [r7, #12]
 801198c:	691b      	ldr	r3, [r3, #16]
 801198e:	3314      	adds	r3, #20
 8011990:	627b      	str	r3, [r7, #36]	; 0x24
  if (seg->flags & TF_SEG_OPTS_MSS) {
 8011992:	68fb      	ldr	r3, [r7, #12]
 8011994:	7bdb      	ldrb	r3, [r3, #15]
 8011996:	001a      	movs	r2, r3
 8011998:	2301      	movs	r3, #1
 801199a:	4013      	ands	r3, r2
 801199c:	d019      	beq.n	80119d2 <tcp_output_segment+0x142>
    u16_t mss;
#if TCP_CALCULATE_EFF_SEND_MSS
    mss = tcp_eff_send_mss_netif(TCP_MSS, netif, &pcb->remote_ip);
 801199e:	68bb      	ldr	r3, [r7, #8]
 80119a0:	1d1a      	adds	r2, r3, #4
 80119a2:	251e      	movs	r5, #30
 80119a4:	197c      	adds	r4, r7, r5
 80119a6:	6879      	ldr	r1, [r7, #4]
 80119a8:	2386      	movs	r3, #134	; 0x86
 80119aa:	009b      	lsls	r3, r3, #2
 80119ac:	0018      	movs	r0, r3
 80119ae:	f7fb f9cb 	bl	800cd48 <tcp_eff_send_mss_netif>
 80119b2:	0003      	movs	r3, r0
 80119b4:	8023      	strh	r3, [r4, #0]
#else /* TCP_CALCULATE_EFF_SEND_MSS */
    mss = TCP_MSS;
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
    *opts = TCP_BUILD_MSS_OPTION(mss);
 80119b6:	197b      	adds	r3, r7, r5
 80119b8:	881b      	ldrh	r3, [r3, #0]
 80119ba:	2281      	movs	r2, #129	; 0x81
 80119bc:	0492      	lsls	r2, r2, #18
 80119be:	4313      	orrs	r3, r2
 80119c0:	0018      	movs	r0, r3
 80119c2:	f7f5 fd33 	bl	800742c <lwip_htonl>
 80119c6:	0002      	movs	r2, r0
 80119c8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80119ca:	601a      	str	r2, [r3, #0]
    opts += 1;
 80119cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80119ce:	3304      	adds	r3, #4
 80119d0:	627b      	str	r3, [r7, #36]	; 0x24
  }
#endif

  /* Set retransmission timer running if it is not currently enabled
     This must be set before checking the route. */
  if (pcb->rtime < 0) {
 80119d2:	68bb      	ldr	r3, [r7, #8]
 80119d4:	2234      	movs	r2, #52	; 0x34
 80119d6:	5e9b      	ldrsh	r3, [r3, r2]
 80119d8:	2b00      	cmp	r3, #0
 80119da:	da02      	bge.n	80119e2 <tcp_output_segment+0x152>
    pcb->rtime = 0;
 80119dc:	68bb      	ldr	r3, [r7, #8]
 80119de:	2200      	movs	r2, #0
 80119e0:	869a      	strh	r2, [r3, #52]	; 0x34
  }

  if (pcb->rttest == 0) {
 80119e2:	68bb      	ldr	r3, [r7, #8]
 80119e4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80119e6:	2b00      	cmp	r3, #0
 80119e8:	d115      	bne.n	8011a16 <tcp_output_segment+0x186>
    pcb->rttest = tcp_ticks;
 80119ea:	4b91      	ldr	r3, [pc, #580]	; (8011c30 <tcp_output_segment+0x3a0>)
 80119ec:	681a      	ldr	r2, [r3, #0]
 80119ee:	68bb      	ldr	r3, [r7, #8]
 80119f0:	639a      	str	r2, [r3, #56]	; 0x38
    pcb->rtseq = lwip_ntohl(seg->tcphdr->seqno);
 80119f2:	68fb      	ldr	r3, [r7, #12]
 80119f4:	691b      	ldr	r3, [r3, #16]
 80119f6:	791a      	ldrb	r2, [r3, #4]
 80119f8:	7959      	ldrb	r1, [r3, #5]
 80119fa:	0209      	lsls	r1, r1, #8
 80119fc:	430a      	orrs	r2, r1
 80119fe:	7999      	ldrb	r1, [r3, #6]
 8011a00:	0409      	lsls	r1, r1, #16
 8011a02:	430a      	orrs	r2, r1
 8011a04:	79db      	ldrb	r3, [r3, #7]
 8011a06:	061b      	lsls	r3, r3, #24
 8011a08:	4313      	orrs	r3, r2
 8011a0a:	0018      	movs	r0, r3
 8011a0c:	f7f5 fd0e 	bl	800742c <lwip_htonl>
 8011a10:	0002      	movs	r2, r0
 8011a12:	68bb      	ldr	r3, [r7, #8]
 8011a14:	63da      	str	r2, [r3, #60]	; 0x3c
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
                                 lwip_htonl(seg->tcphdr->seqno), lwip_htonl(seg->tcphdr->seqno) +
                                 seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 8011a16:	68fb      	ldr	r3, [r7, #12]
 8011a18:	691a      	ldr	r2, [r3, #16]
 8011a1a:	68fb      	ldr	r3, [r7, #12]
 8011a1c:	685b      	ldr	r3, [r3, #4]
 8011a1e:	685b      	ldr	r3, [r3, #4]
 8011a20:	1ad2      	subs	r2, r2, r3
 8011a22:	201c      	movs	r0, #28
 8011a24:	183b      	adds	r3, r7, r0
 8011a26:	801a      	strh	r2, [r3, #0]
  if (len == 0) {
    /** Exclude retransmitted segments from this count. */
    MIB2_STATS_INC(mib2.tcpoutsegs);
  }

  seg->p->len -= len;
 8011a28:	68fb      	ldr	r3, [r7, #12]
 8011a2a:	685b      	ldr	r3, [r3, #4]
 8011a2c:	8959      	ldrh	r1, [r3, #10]
 8011a2e:	68fb      	ldr	r3, [r7, #12]
 8011a30:	685b      	ldr	r3, [r3, #4]
 8011a32:	183a      	adds	r2, r7, r0
 8011a34:	8812      	ldrh	r2, [r2, #0]
 8011a36:	1a8a      	subs	r2, r1, r2
 8011a38:	b292      	uxth	r2, r2
 8011a3a:	815a      	strh	r2, [r3, #10]
  seg->p->tot_len -= len;
 8011a3c:	68fb      	ldr	r3, [r7, #12]
 8011a3e:	685b      	ldr	r3, [r3, #4]
 8011a40:	8919      	ldrh	r1, [r3, #8]
 8011a42:	68fb      	ldr	r3, [r7, #12]
 8011a44:	685b      	ldr	r3, [r3, #4]
 8011a46:	183a      	adds	r2, r7, r0
 8011a48:	8812      	ldrh	r2, [r2, #0]
 8011a4a:	1a8a      	subs	r2, r1, r2
 8011a4c:	b292      	uxth	r2, r2
 8011a4e:	811a      	strh	r2, [r3, #8]

  seg->p->payload = seg->tcphdr;
 8011a50:	68fb      	ldr	r3, [r7, #12]
 8011a52:	685b      	ldr	r3, [r3, #4]
 8011a54:	68fa      	ldr	r2, [r7, #12]
 8011a56:	6912      	ldr	r2, [r2, #16]
 8011a58:	605a      	str	r2, [r3, #4]

  seg->tcphdr->chksum = 0;
 8011a5a:	68fb      	ldr	r3, [r7, #12]
 8011a5c:	691b      	ldr	r3, [r3, #16]
 8011a5e:	7c1a      	ldrb	r2, [r3, #16]
 8011a60:	2100      	movs	r1, #0
 8011a62:	400a      	ands	r2, r1
 8011a64:	741a      	strb	r2, [r3, #16]
 8011a66:	7c5a      	ldrb	r2, [r3, #17]
 8011a68:	2100      	movs	r1, #0
 8011a6a:	400a      	ands	r2, r1
 8011a6c:	745a      	strb	r2, [r3, #17]

#ifdef LWIP_HOOK_TCP_OUT_ADD_TCPOPTS
  opts = LWIP_HOOK_TCP_OUT_ADD_TCPOPTS(seg->p, seg->tcphdr, pcb, opts);
#endif
  LWIP_ASSERT("options not filled", (u8_t *)opts == ((u8_t *)(seg->tcphdr + 1)) + LWIP_TCP_OPT_LENGTH_SEGMENT(seg->flags, pcb));
 8011a6e:	68fb      	ldr	r3, [r7, #12]
 8011a70:	691b      	ldr	r3, [r3, #16]
 8011a72:	3314      	adds	r3, #20
 8011a74:	001a      	movs	r2, r3
 8011a76:	68fb      	ldr	r3, [r7, #12]
 8011a78:	7bdb      	ldrb	r3, [r3, #15]
 8011a7a:	009b      	lsls	r3, r3, #2
 8011a7c:	2104      	movs	r1, #4
 8011a7e:	400b      	ands	r3, r1
 8011a80:	18d3      	adds	r3, r2, r3
 8011a82:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8011a84:	429a      	cmp	r2, r3
 8011a86:	d005      	beq.n	8011a94 <tcp_output_segment+0x204>
 8011a88:	4b61      	ldr	r3, [pc, #388]	; (8011c10 <tcp_output_segment+0x380>)
 8011a8a:	4a6a      	ldr	r2, [pc, #424]	; (8011c34 <tcp_output_segment+0x3a4>)
 8011a8c:	496a      	ldr	r1, [pc, #424]	; (8011c38 <tcp_output_segment+0x3a8>)
 8011a8e:	4863      	ldr	r0, [pc, #396]	; (8011c1c <tcp_output_segment+0x38c>)
 8011a90:	f7f0 fba8 	bl	80021e4 <app_debug_rtt_raw>
    u32_t acc;
#if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
    u16_t chksum_slow = ip_chksum_pseudo(seg->p, IP_PROTO_TCP,
                                         seg->p->tot_len, &pcb->local_ip, &pcb->remote_ip);
#endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
    if ((seg->flags & TF_SEG_DATA_CHECKSUMMED) == 0) {
 8011a94:	68fb      	ldr	r3, [r7, #12]
 8011a96:	7bdb      	ldrb	r3, [r3, #15]
 8011a98:	001a      	movs	r2, r3
 8011a9a:	2304      	movs	r3, #4
 8011a9c:	4013      	ands	r3, r2
 8011a9e:	d11c      	bne.n	8011ada <tcp_output_segment+0x24a>
      LWIP_ASSERT("data included but not checksummed",
 8011aa0:	68fb      	ldr	r3, [r7, #12]
 8011aa2:	685b      	ldr	r3, [r3, #4]
 8011aa4:	891c      	ldrh	r4, [r3, #8]
 8011aa6:	68fb      	ldr	r3, [r7, #12]
 8011aa8:	691b      	ldr	r3, [r3, #16]
 8011aaa:	7b1a      	ldrb	r2, [r3, #12]
 8011aac:	7b5b      	ldrb	r3, [r3, #13]
 8011aae:	021b      	lsls	r3, r3, #8
 8011ab0:	4313      	orrs	r3, r2
 8011ab2:	b29b      	uxth	r3, r3
 8011ab4:	0018      	movs	r0, r3
 8011ab6:	f7f5 fca3 	bl	8007400 <lwip_htons>
 8011aba:	0003      	movs	r3, r0
 8011abc:	0b1b      	lsrs	r3, r3, #12
 8011abe:	b29b      	uxth	r3, r3
 8011ac0:	b2db      	uxtb	r3, r3
 8011ac2:	009b      	lsls	r3, r3, #2
 8011ac4:	b2db      	uxtb	r3, r3
 8011ac6:	b29b      	uxth	r3, r3
 8011ac8:	429c      	cmp	r4, r3
 8011aca:	d006      	beq.n	8011ada <tcp_output_segment+0x24a>
 8011acc:	4b50      	ldr	r3, [pc, #320]	; (8011c10 <tcp_output_segment+0x380>)
 8011ace:	22c5      	movs	r2, #197	; 0xc5
 8011ad0:	00d2      	lsls	r2, r2, #3
 8011ad2:	495a      	ldr	r1, [pc, #360]	; (8011c3c <tcp_output_segment+0x3ac>)
 8011ad4:	4851      	ldr	r0, [pc, #324]	; (8011c1c <tcp_output_segment+0x38c>)
 8011ad6:	f7f0 fb85 	bl	80021e4 <app_debug_rtt_raw>
                  seg->p->tot_len == TCPH_HDRLEN_BYTES(seg->tcphdr));
    }

    /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
    acc = ip_chksum_pseudo_partial(seg->p, IP_PROTO_TCP,
 8011ada:	68fb      	ldr	r3, [r7, #12]
 8011adc:	685c      	ldr	r4, [r3, #4]
                                   seg->p->tot_len, TCPH_HDRLEN_BYTES(seg->tcphdr), &pcb->local_ip, &pcb->remote_ip);
 8011ade:	68fb      	ldr	r3, [r7, #12]
 8011ae0:	685b      	ldr	r3, [r3, #4]
    acc = ip_chksum_pseudo_partial(seg->p, IP_PROTO_TCP,
 8011ae2:	891d      	ldrh	r5, [r3, #8]
                                   seg->p->tot_len, TCPH_HDRLEN_BYTES(seg->tcphdr), &pcb->local_ip, &pcb->remote_ip);
 8011ae4:	68fb      	ldr	r3, [r7, #12]
 8011ae6:	691b      	ldr	r3, [r3, #16]
 8011ae8:	7b1a      	ldrb	r2, [r3, #12]
 8011aea:	7b5b      	ldrb	r3, [r3, #13]
 8011aec:	021b      	lsls	r3, r3, #8
 8011aee:	4313      	orrs	r3, r2
 8011af0:	b29b      	uxth	r3, r3
 8011af2:	0018      	movs	r0, r3
 8011af4:	f7f5 fc84 	bl	8007400 <lwip_htons>
 8011af8:	0003      	movs	r3, r0
 8011afa:	0b1b      	lsrs	r3, r3, #12
 8011afc:	b29b      	uxth	r3, r3
 8011afe:	b2db      	uxtb	r3, r3
 8011b00:	009b      	lsls	r3, r3, #2
 8011b02:	b2db      	uxtb	r3, r3
    acc = ip_chksum_pseudo_partial(seg->p, IP_PROTO_TCP,
 8011b04:	b299      	uxth	r1, r3
                                   seg->p->tot_len, TCPH_HDRLEN_BYTES(seg->tcphdr), &pcb->local_ip, &pcb->remote_ip);
 8011b06:	68bb      	ldr	r3, [r7, #8]
 8011b08:	68ba      	ldr	r2, [r7, #8]
 8011b0a:	3204      	adds	r2, #4
    acc = ip_chksum_pseudo_partial(seg->p, IP_PROTO_TCP,
 8011b0c:	9201      	str	r2, [sp, #4]
 8011b0e:	9300      	str	r3, [sp, #0]
 8011b10:	000b      	movs	r3, r1
 8011b12:	002a      	movs	r2, r5
 8011b14:	2106      	movs	r1, #6
 8011b16:	0020      	movs	r0, r4
 8011b18:	f7f7 f835 	bl	8008b86 <ip_chksum_pseudo_partial>
 8011b1c:	0003      	movs	r3, r0
 8011b1e:	61bb      	str	r3, [r7, #24]
    /* add payload checksum */
    if (seg->chksum_swapped) {
 8011b20:	68fb      	ldr	r3, [r7, #12]
 8011b22:	7b9b      	ldrb	r3, [r3, #14]
 8011b24:	2b00      	cmp	r3, #0
 8011b26:	d012      	beq.n	8011b4e <tcp_output_segment+0x2be>
      seg_chksum_was_swapped = 1;
 8011b28:	2301      	movs	r3, #1
 8011b2a:	623b      	str	r3, [r7, #32]
      seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
 8011b2c:	68fb      	ldr	r3, [r7, #12]
 8011b2e:	899b      	ldrh	r3, [r3, #12]
 8011b30:	021b      	lsls	r3, r3, #8
 8011b32:	b21a      	sxth	r2, r3
 8011b34:	68fb      	ldr	r3, [r7, #12]
 8011b36:	899b      	ldrh	r3, [r3, #12]
 8011b38:	0a1b      	lsrs	r3, r3, #8
 8011b3a:	b29b      	uxth	r3, r3
 8011b3c:	b21b      	sxth	r3, r3
 8011b3e:	4313      	orrs	r3, r2
 8011b40:	b21b      	sxth	r3, r3
 8011b42:	b29a      	uxth	r2, r3
 8011b44:	68fb      	ldr	r3, [r7, #12]
 8011b46:	819a      	strh	r2, [r3, #12]
      seg->chksum_swapped = 0;
 8011b48:	68fb      	ldr	r3, [r7, #12]
 8011b4a:	2200      	movs	r2, #0
 8011b4c:	739a      	strb	r2, [r3, #14]
    }
    acc = (u16_t)~acc + seg->chksum;
 8011b4e:	69bb      	ldr	r3, [r7, #24]
 8011b50:	b29b      	uxth	r3, r3
 8011b52:	43db      	mvns	r3, r3
 8011b54:	b29b      	uxth	r3, r3
 8011b56:	001a      	movs	r2, r3
 8011b58:	68fb      	ldr	r3, [r7, #12]
 8011b5a:	899b      	ldrh	r3, [r3, #12]
 8011b5c:	18d3      	adds	r3, r2, r3
 8011b5e:	61bb      	str	r3, [r7, #24]
    seg->tcphdr->chksum = (u16_t)~FOLD_U32T(acc);
 8011b60:	69bb      	ldr	r3, [r7, #24]
 8011b62:	0c1b      	lsrs	r3, r3, #16
 8011b64:	b29a      	uxth	r2, r3
 8011b66:	69bb      	ldr	r3, [r7, #24]
 8011b68:	b29b      	uxth	r3, r3
 8011b6a:	18d3      	adds	r3, r2, r3
 8011b6c:	b29a      	uxth	r2, r3
 8011b6e:	68fb      	ldr	r3, [r7, #12]
 8011b70:	691b      	ldr	r3, [r3, #16]
 8011b72:	43d2      	mvns	r2, r2
 8011b74:	b292      	uxth	r2, r2
 8011b76:	21ff      	movs	r1, #255	; 0xff
 8011b78:	4011      	ands	r1, r2
 8011b7a:	000c      	movs	r4, r1
 8011b7c:	7c19      	ldrb	r1, [r3, #16]
 8011b7e:	2000      	movs	r0, #0
 8011b80:	4001      	ands	r1, r0
 8011b82:	1c08      	adds	r0, r1, #0
 8011b84:	1c21      	adds	r1, r4, #0
 8011b86:	4301      	orrs	r1, r0
 8011b88:	7419      	strb	r1, [r3, #16]
 8011b8a:	0a12      	lsrs	r2, r2, #8
 8011b8c:	b290      	uxth	r0, r2
 8011b8e:	7c5a      	ldrb	r2, [r3, #17]
 8011b90:	2100      	movs	r1, #0
 8011b92:	400a      	ands	r2, r1
 8011b94:	1c11      	adds	r1, r2, #0
 8011b96:	1c02      	adds	r2, r0, #0
 8011b98:	430a      	orrs	r2, r1
 8011b9a:	745a      	strb	r2, [r3, #17]
#endif /* TCP_CHECKSUM_ON_COPY */
  }
#endif /* CHECKSUM_GEN_TCP */
  TCP_STATS_INC(tcp.xmit);

  NETIF_SET_HINTS(netif, &(pcb->netif_hints));
 8011b9c:	68bb      	ldr	r3, [r7, #8]
 8011b9e:	330c      	adds	r3, #12
 8011ba0:	001a      	movs	r2, r3
 8011ba2:	687b      	ldr	r3, [r7, #4]
 8011ba4:	639a      	str	r2, [r3, #56]	; 0x38
  err = ip_output_if(seg->p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
 8011ba6:	68fb      	ldr	r3, [r7, #12]
 8011ba8:	6858      	ldr	r0, [r3, #4]
 8011baa:	68b9      	ldr	r1, [r7, #8]
 8011bac:	68bb      	ldr	r3, [r7, #8]
 8011bae:	1d1d      	adds	r5, r3, #4
 8011bb0:	68bb      	ldr	r3, [r7, #8]
 8011bb2:	7ade      	ldrb	r6, [r3, #11]
 8011bb4:	68bb      	ldr	r3, [r7, #8]
 8011bb6:	7a9b      	ldrb	r3, [r3, #10]
 8011bb8:	2217      	movs	r2, #23
 8011bba:	18bc      	adds	r4, r7, r2
 8011bbc:	687a      	ldr	r2, [r7, #4]
 8011bbe:	9202      	str	r2, [sp, #8]
 8011bc0:	2206      	movs	r2, #6
 8011bc2:	9201      	str	r2, [sp, #4]
 8011bc4:	9300      	str	r3, [sp, #0]
 8011bc6:	0033      	movs	r3, r6
 8011bc8:	002a      	movs	r2, r5
 8011bca:	f002 fa77 	bl	80140bc <ip4_output_if>
 8011bce:	0003      	movs	r3, r0
 8011bd0:	7023      	strb	r3, [r4, #0]
                     pcb->tos, IP_PROTO_TCP, netif);
  NETIF_RESET_HINTS(netif);
 8011bd2:	687b      	ldr	r3, [r7, #4]
 8011bd4:	2200      	movs	r2, #0
 8011bd6:	639a      	str	r2, [r3, #56]	; 0x38

#if TCP_CHECKSUM_ON_COPY
  if (seg_chksum_was_swapped) {
 8011bd8:	6a3b      	ldr	r3, [r7, #32]
 8011bda:	2b00      	cmp	r3, #0
 8011bdc:	d010      	beq.n	8011c00 <tcp_output_segment+0x370>
    /* if data is added to this segment later, chksum needs to be swapped,
       so restore this now */
    seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
 8011bde:	68fb      	ldr	r3, [r7, #12]
 8011be0:	899b      	ldrh	r3, [r3, #12]
 8011be2:	021b      	lsls	r3, r3, #8
 8011be4:	b21a      	sxth	r2, r3
 8011be6:	68fb      	ldr	r3, [r7, #12]
 8011be8:	899b      	ldrh	r3, [r3, #12]
 8011bea:	0a1b      	lsrs	r3, r3, #8
 8011bec:	b29b      	uxth	r3, r3
 8011bee:	b21b      	sxth	r3, r3
 8011bf0:	4313      	orrs	r3, r2
 8011bf2:	b21b      	sxth	r3, r3
 8011bf4:	b29a      	uxth	r2, r3
 8011bf6:	68fb      	ldr	r3, [r7, #12]
 8011bf8:	819a      	strh	r2, [r3, #12]
    seg->chksum_swapped = 1;
 8011bfa:	68fb      	ldr	r3, [r7, #12]
 8011bfc:	2201      	movs	r2, #1
 8011bfe:	739a      	strb	r2, [r3, #14]
  }
#endif

  return err;
 8011c00:	2317      	movs	r3, #23
 8011c02:	18fb      	adds	r3, r7, r3
 8011c04:	781b      	ldrb	r3, [r3, #0]
 8011c06:	b25b      	sxtb	r3, r3
}
 8011c08:	0018      	movs	r0, r3
 8011c0a:	46bd      	mov	sp, r7
 8011c0c:	b00b      	add	sp, #44	; 0x2c
 8011c0e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8011c10:	08021684 	.word	0x08021684
 8011c14:	000005b9 	.word	0x000005b9
 8011c18:	08021d24 	.word	0x08021d24
 8011c1c:	080216d0 	.word	0x080216d0
 8011c20:	000005ba 	.word	0x000005ba
 8011c24:	08021d44 	.word	0x08021d44
 8011c28:	000005bb 	.word	0x000005bb
 8011c2c:	08021d64 	.word	0x08021d64
 8011c30:	20002790 	.word	0x20002790
 8011c34:	0000061d 	.word	0x0000061d
 8011c38:	08021d88 	.word	0x08021d88
 8011c3c:	08021d9c 	.word	0x08021d9c

08011c40 <tcp_rexmit_rto_prepare>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
err_t
tcp_rexmit_rto_prepare(struct tcp_pcb *pcb)
{
 8011c40:	b5b0      	push	{r4, r5, r7, lr}
 8011c42:	b084      	sub	sp, #16
 8011c44:	af00      	add	r7, sp, #0
 8011c46:	6078      	str	r0, [r7, #4]
  struct tcp_seg *seg;

  LWIP_ASSERT("tcp_rexmit_rto_prepare: invalid pcb", pcb != NULL);
 8011c48:	687b      	ldr	r3, [r7, #4]
 8011c4a:	2b00      	cmp	r3, #0
 8011c4c:	d105      	bne.n	8011c5a <tcp_rexmit_rto_prepare+0x1a>
 8011c4e:	4b3c      	ldr	r3, [pc, #240]	; (8011d40 <tcp_rexmit_rto_prepare+0x100>)
 8011c50:	4a3c      	ldr	r2, [pc, #240]	; (8011d44 <tcp_rexmit_rto_prepare+0x104>)
 8011c52:	493d      	ldr	r1, [pc, #244]	; (8011d48 <tcp_rexmit_rto_prepare+0x108>)
 8011c54:	483d      	ldr	r0, [pc, #244]	; (8011d4c <tcp_rexmit_rto_prepare+0x10c>)
 8011c56:	f7f0 fac5 	bl	80021e4 <app_debug_rtt_raw>

  if (pcb->unacked == NULL) {
 8011c5a:	687b      	ldr	r3, [r7, #4]
 8011c5c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8011c5e:	2b00      	cmp	r3, #0
 8011c60:	d102      	bne.n	8011c68 <tcp_rexmit_rto_prepare+0x28>
    return ERR_VAL;
 8011c62:	2306      	movs	r3, #6
 8011c64:	425b      	negs	r3, r3
 8011c66:	e066      	b.n	8011d36 <tcp_rexmit_rto_prepare+0xf6>

  /* Move all unacked segments to the head of the unsent queue.
     However, give up if any of the unsent pbufs are still referenced by the
     netif driver due to deferred transmission. No point loading the link further
     if it is struggling to flush its buffered writes. */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next) {
 8011c68:	687b      	ldr	r3, [r7, #4]
 8011c6a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8011c6c:	60fb      	str	r3, [r7, #12]
 8011c6e:	e00b      	b.n	8011c88 <tcp_rexmit_rto_prepare+0x48>
    if (tcp_output_segment_busy(seg)) {
 8011c70:	68fb      	ldr	r3, [r7, #12]
 8011c72:	0018      	movs	r0, r3
 8011c74:	f7ff fdea 	bl	801184c <tcp_output_segment_busy>
 8011c78:	1e03      	subs	r3, r0, #0
 8011c7a:	d002      	beq.n	8011c82 <tcp_rexmit_rto_prepare+0x42>
      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_rexmit_rto: segment busy\n"));
      return ERR_VAL;
 8011c7c:	2306      	movs	r3, #6
 8011c7e:	425b      	negs	r3, r3
 8011c80:	e059      	b.n	8011d36 <tcp_rexmit_rto_prepare+0xf6>
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next) {
 8011c82:	68fb      	ldr	r3, [r7, #12]
 8011c84:	681b      	ldr	r3, [r3, #0]
 8011c86:	60fb      	str	r3, [r7, #12]
 8011c88:	68fb      	ldr	r3, [r7, #12]
 8011c8a:	681b      	ldr	r3, [r3, #0]
 8011c8c:	2b00      	cmp	r3, #0
 8011c8e:	d1ef      	bne.n	8011c70 <tcp_rexmit_rto_prepare+0x30>
    }
  }
  if (tcp_output_segment_busy(seg)) {
 8011c90:	68fb      	ldr	r3, [r7, #12]
 8011c92:	0018      	movs	r0, r3
 8011c94:	f7ff fdda 	bl	801184c <tcp_output_segment_busy>
 8011c98:	1e03      	subs	r3, r0, #0
 8011c9a:	d002      	beq.n	8011ca2 <tcp_rexmit_rto_prepare+0x62>
    LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_rexmit_rto: segment busy\n"));
    return ERR_VAL;
 8011c9c:	2306      	movs	r3, #6
 8011c9e:	425b      	negs	r3, r3
 8011ca0:	e049      	b.n	8011d36 <tcp_rexmit_rto_prepare+0xf6>
  }
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
 8011ca2:	687b      	ldr	r3, [r7, #4]
 8011ca4:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8011ca6:	68fb      	ldr	r3, [r7, #12]
 8011ca8:	601a      	str	r2, [r3, #0]
#if TCP_OVERSIZE_DBGCHECK
  /* if last unsent changed, we need to update unsent_oversize */
  if (pcb->unsent == NULL) {
 8011caa:	687b      	ldr	r3, [r7, #4]
 8011cac:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8011cae:	2b00      	cmp	r3, #0
 8011cb0:	d104      	bne.n	8011cbc <tcp_rexmit_rto_prepare+0x7c>
    pcb->unsent_oversize = seg->oversize_left;
 8011cb2:	68fb      	ldr	r3, [r7, #12]
 8011cb4:	8959      	ldrh	r1, [r3, #10]
 8011cb6:	687b      	ldr	r3, [r7, #4]
 8011cb8:	226c      	movs	r2, #108	; 0x6c
 8011cba:	5299      	strh	r1, [r3, r2]
  }
#endif /* TCP_OVERSIZE_DBGCHECK */
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
 8011cbc:	687b      	ldr	r3, [r7, #4]
 8011cbe:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8011cc0:	687b      	ldr	r3, [r7, #4]
 8011cc2:	671a      	str	r2, [r3, #112]	; 0x70
  /* unacked queue is now empty */
  pcb->unacked = NULL;
 8011cc4:	687b      	ldr	r3, [r7, #4]
 8011cc6:	2200      	movs	r2, #0
 8011cc8:	675a      	str	r2, [r3, #116]	; 0x74

  /* Mark RTO in-progress */
  tcp_set_flags(pcb, TF_RTO);
 8011cca:	687b      	ldr	r3, [r7, #4]
 8011ccc:	8bdb      	ldrh	r3, [r3, #30]
 8011cce:	2280      	movs	r2, #128	; 0x80
 8011cd0:	0112      	lsls	r2, r2, #4
 8011cd2:	4313      	orrs	r3, r2
 8011cd4:	b29a      	uxth	r2, r3
 8011cd6:	687b      	ldr	r3, [r7, #4]
 8011cd8:	83da      	strh	r2, [r3, #30]
  /* Record the next byte following retransmit */
  pcb->rto_end = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 8011cda:	68fb      	ldr	r3, [r7, #12]
 8011cdc:	691b      	ldr	r3, [r3, #16]
 8011cde:	791a      	ldrb	r2, [r3, #4]
 8011ce0:	7959      	ldrb	r1, [r3, #5]
 8011ce2:	0209      	lsls	r1, r1, #8
 8011ce4:	430a      	orrs	r2, r1
 8011ce6:	7999      	ldrb	r1, [r3, #6]
 8011ce8:	0409      	lsls	r1, r1, #16
 8011cea:	430a      	orrs	r2, r1
 8011cec:	79db      	ldrb	r3, [r3, #7]
 8011cee:	061b      	lsls	r3, r3, #24
 8011cf0:	4313      	orrs	r3, r2
 8011cf2:	0018      	movs	r0, r3
 8011cf4:	f7f5 fb9a 	bl	800742c <lwip_htonl>
 8011cf8:	0004      	movs	r4, r0
 8011cfa:	68fb      	ldr	r3, [r7, #12]
 8011cfc:	891b      	ldrh	r3, [r3, #8]
 8011cfe:	001d      	movs	r5, r3
 8011d00:	68fb      	ldr	r3, [r7, #12]
 8011d02:	691b      	ldr	r3, [r3, #16]
 8011d04:	7b1a      	ldrb	r2, [r3, #12]
 8011d06:	7b5b      	ldrb	r3, [r3, #13]
 8011d08:	021b      	lsls	r3, r3, #8
 8011d0a:	4313      	orrs	r3, r2
 8011d0c:	b29b      	uxth	r3, r3
 8011d0e:	0018      	movs	r0, r3
 8011d10:	f7f5 fb76 	bl	8007400 <lwip_htons>
 8011d14:	0003      	movs	r3, r0
 8011d16:	b2db      	uxtb	r3, r3
 8011d18:	001a      	movs	r2, r3
 8011d1a:	2303      	movs	r3, #3
 8011d1c:	4013      	ands	r3, r2
 8011d1e:	d001      	beq.n	8011d24 <tcp_rexmit_rto_prepare+0xe4>
 8011d20:	2301      	movs	r3, #1
 8011d22:	e000      	b.n	8011d26 <tcp_rexmit_rto_prepare+0xe6>
 8011d24:	2300      	movs	r3, #0
 8011d26:	195b      	adds	r3, r3, r5
 8011d28:	18e2      	adds	r2, r4, r3
 8011d2a:	687b      	ldr	r3, [r7, #4]
 8011d2c:	651a      	str	r2, [r3, #80]	; 0x50
  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
 8011d2e:	687b      	ldr	r3, [r7, #4]
 8011d30:	2200      	movs	r2, #0
 8011d32:	639a      	str	r2, [r3, #56]	; 0x38

  return ERR_OK;
 8011d34:	2300      	movs	r3, #0
}
 8011d36:	0018      	movs	r0, r3
 8011d38:	46bd      	mov	sp, r7
 8011d3a:	b004      	add	sp, #16
 8011d3c:	bdb0      	pop	{r4, r5, r7, pc}
 8011d3e:	46c0      	nop			; (mov r8, r8)
 8011d40:	08021684 	.word	0x08021684
 8011d44:	00000664 	.word	0x00000664
 8011d48:	08021dc0 	.word	0x08021dc0
 8011d4c:	080216d0 	.word	0x080216d0

08011d50 <tcp_rexmit_rto_commit>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto_commit(struct tcp_pcb *pcb)
{
 8011d50:	b580      	push	{r7, lr}
 8011d52:	b082      	sub	sp, #8
 8011d54:	af00      	add	r7, sp, #0
 8011d56:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_rexmit_rto_commit: invalid pcb", pcb != NULL);
 8011d58:	687b      	ldr	r3, [r7, #4]
 8011d5a:	2b00      	cmp	r3, #0
 8011d5c:	d105      	bne.n	8011d6a <tcp_rexmit_rto_commit+0x1a>
 8011d5e:	4b0d      	ldr	r3, [pc, #52]	; (8011d94 <tcp_rexmit_rto_commit+0x44>)
 8011d60:	4a0d      	ldr	r2, [pc, #52]	; (8011d98 <tcp_rexmit_rto_commit+0x48>)
 8011d62:	490e      	ldr	r1, [pc, #56]	; (8011d9c <tcp_rexmit_rto_commit+0x4c>)
 8011d64:	480e      	ldr	r0, [pc, #56]	; (8011da0 <tcp_rexmit_rto_commit+0x50>)
 8011d66:	f7f0 fa3d 	bl	80021e4 <app_debug_rtt_raw>

  /* increment number of retransmissions */
  if (pcb->nrtx < 0xFF) {
 8011d6a:	687b      	ldr	r3, [r7, #4]
 8011d6c:	2246      	movs	r2, #70	; 0x46
 8011d6e:	5c9b      	ldrb	r3, [r3, r2]
 8011d70:	2bff      	cmp	r3, #255	; 0xff
 8011d72:	d007      	beq.n	8011d84 <tcp_rexmit_rto_commit+0x34>
    ++pcb->nrtx;
 8011d74:	687b      	ldr	r3, [r7, #4]
 8011d76:	2246      	movs	r2, #70	; 0x46
 8011d78:	5c9b      	ldrb	r3, [r3, r2]
 8011d7a:	3301      	adds	r3, #1
 8011d7c:	b2d9      	uxtb	r1, r3
 8011d7e:	687b      	ldr	r3, [r7, #4]
 8011d80:	2246      	movs	r2, #70	; 0x46
 8011d82:	5499      	strb	r1, [r3, r2]
  }
  /* Do the actual retransmission */
  tcp_output(pcb);
 8011d84:	687b      	ldr	r3, [r7, #4]
 8011d86:	0018      	movs	r0, r3
 8011d88:	f7ff fb00 	bl	801138c <tcp_output>
}
 8011d8c:	46c0      	nop			; (mov r8, r8)
 8011d8e:	46bd      	mov	sp, r7
 8011d90:	b002      	add	sp, #8
 8011d92:	bd80      	pop	{r7, pc}
 8011d94:	08021684 	.word	0x08021684
 8011d98:	00000699 	.word	0x00000699
 8011d9c:	08021de4 	.word	0x08021de4
 8011da0:	080216d0 	.word	0x080216d0

08011da4 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
 8011da4:	b580      	push	{r7, lr}
 8011da6:	b082      	sub	sp, #8
 8011da8:	af00      	add	r7, sp, #0
 8011daa:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_rexmit_rto: invalid pcb", pcb != NULL);
 8011dac:	687b      	ldr	r3, [r7, #4]
 8011dae:	2b00      	cmp	r3, #0
 8011db0:	d105      	bne.n	8011dbe <tcp_rexmit_rto+0x1a>
 8011db2:	4b0a      	ldr	r3, [pc, #40]	; (8011ddc <tcp_rexmit_rto+0x38>)
 8011db4:	4a0a      	ldr	r2, [pc, #40]	; (8011de0 <tcp_rexmit_rto+0x3c>)
 8011db6:	490b      	ldr	r1, [pc, #44]	; (8011de4 <tcp_rexmit_rto+0x40>)
 8011db8:	480b      	ldr	r0, [pc, #44]	; (8011de8 <tcp_rexmit_rto+0x44>)
 8011dba:	f7f0 fa13 	bl	80021e4 <app_debug_rtt_raw>

  if (tcp_rexmit_rto_prepare(pcb) == ERR_OK) {
 8011dbe:	687b      	ldr	r3, [r7, #4]
 8011dc0:	0018      	movs	r0, r3
 8011dc2:	f7ff ff3d 	bl	8011c40 <tcp_rexmit_rto_prepare>
 8011dc6:	1e03      	subs	r3, r0, #0
 8011dc8:	d103      	bne.n	8011dd2 <tcp_rexmit_rto+0x2e>
    tcp_rexmit_rto_commit(pcb);
 8011dca:	687b      	ldr	r3, [r7, #4]
 8011dcc:	0018      	movs	r0, r3
 8011dce:	f7ff ffbf 	bl	8011d50 <tcp_rexmit_rto_commit>
  }
}
 8011dd2:	46c0      	nop			; (mov r8, r8)
 8011dd4:	46bd      	mov	sp, r7
 8011dd6:	b002      	add	sp, #8
 8011dd8:	bd80      	pop	{r7, pc}
 8011dda:	46c0      	nop			; (mov r8, r8)
 8011ddc:	08021684 	.word	0x08021684
 8011de0:	000006ae 	.word	0x000006ae
 8011de4:	08021e08 	.word	0x08021e08
 8011de8:	080216d0 	.word	0x080216d0

08011dec <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
err_t
tcp_rexmit(struct tcp_pcb *pcb)
{
 8011dec:	b590      	push	{r4, r7, lr}
 8011dee:	b085      	sub	sp, #20
 8011df0:	af00      	add	r7, sp, #0
 8011df2:	6078      	str	r0, [r7, #4]
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  LWIP_ASSERT("tcp_rexmit: invalid pcb", pcb != NULL);
 8011df4:	687b      	ldr	r3, [r7, #4]
 8011df6:	2b00      	cmp	r3, #0
 8011df8:	d105      	bne.n	8011e06 <tcp_rexmit+0x1a>
 8011dfa:	4b37      	ldr	r3, [pc, #220]	; (8011ed8 <tcp_rexmit+0xec>)
 8011dfc:	4a37      	ldr	r2, [pc, #220]	; (8011edc <tcp_rexmit+0xf0>)
 8011dfe:	4938      	ldr	r1, [pc, #224]	; (8011ee0 <tcp_rexmit+0xf4>)
 8011e00:	4838      	ldr	r0, [pc, #224]	; (8011ee4 <tcp_rexmit+0xf8>)
 8011e02:	f7f0 f9ef 	bl	80021e4 <app_debug_rtt_raw>

  if (pcb->unacked == NULL) {
 8011e06:	687b      	ldr	r3, [r7, #4]
 8011e08:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8011e0a:	2b00      	cmp	r3, #0
 8011e0c:	d102      	bne.n	8011e14 <tcp_rexmit+0x28>
    return ERR_VAL;
 8011e0e:	2306      	movs	r3, #6
 8011e10:	425b      	negs	r3, r3
 8011e12:	e05d      	b.n	8011ed0 <tcp_rexmit+0xe4>
  }

  seg = pcb->unacked;
 8011e14:	687b      	ldr	r3, [r7, #4]
 8011e16:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8011e18:	60bb      	str	r3, [r7, #8]

  /* Give up if the segment is still referenced by the netif driver
     due to deferred transmission. */
  if (tcp_output_segment_busy(seg)) {
 8011e1a:	68bb      	ldr	r3, [r7, #8]
 8011e1c:	0018      	movs	r0, r3
 8011e1e:	f7ff fd15 	bl	801184c <tcp_output_segment_busy>
 8011e22:	1e03      	subs	r3, r0, #0
 8011e24:	d002      	beq.n	8011e2c <tcp_rexmit+0x40>
    LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_rexmit busy\n"));
    return ERR_VAL;
 8011e26:	2306      	movs	r3, #6
 8011e28:	425b      	negs	r3, r3
 8011e2a:	e051      	b.n	8011ed0 <tcp_rexmit+0xe4>
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  pcb->unacked = seg->next;
 8011e2c:	68bb      	ldr	r3, [r7, #8]
 8011e2e:	681a      	ldr	r2, [r3, #0]
 8011e30:	687b      	ldr	r3, [r7, #4]
 8011e32:	675a      	str	r2, [r3, #116]	; 0x74

  cur_seg = &(pcb->unsent);
 8011e34:	687b      	ldr	r3, [r7, #4]
 8011e36:	3370      	adds	r3, #112	; 0x70
 8011e38:	60fb      	str	r3, [r7, #12]
  while (*cur_seg &&
 8011e3a:	e002      	b.n	8011e42 <tcp_rexmit+0x56>
         TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
    cur_seg = &((*cur_seg)->next );
 8011e3c:	68fb      	ldr	r3, [r7, #12]
 8011e3e:	681b      	ldr	r3, [r3, #0]
 8011e40:	60fb      	str	r3, [r7, #12]
  while (*cur_seg &&
 8011e42:	68fb      	ldr	r3, [r7, #12]
 8011e44:	681b      	ldr	r3, [r3, #0]
 8011e46:	2b00      	cmp	r3, #0
 8011e48:	d022      	beq.n	8011e90 <tcp_rexmit+0xa4>
         TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
 8011e4a:	68fb      	ldr	r3, [r7, #12]
 8011e4c:	681b      	ldr	r3, [r3, #0]
 8011e4e:	691b      	ldr	r3, [r3, #16]
 8011e50:	791a      	ldrb	r2, [r3, #4]
 8011e52:	7959      	ldrb	r1, [r3, #5]
 8011e54:	0209      	lsls	r1, r1, #8
 8011e56:	430a      	orrs	r2, r1
 8011e58:	7999      	ldrb	r1, [r3, #6]
 8011e5a:	0409      	lsls	r1, r1, #16
 8011e5c:	430a      	orrs	r2, r1
 8011e5e:	79db      	ldrb	r3, [r3, #7]
 8011e60:	061b      	lsls	r3, r3, #24
 8011e62:	4313      	orrs	r3, r2
 8011e64:	0018      	movs	r0, r3
 8011e66:	f7f5 fae1 	bl	800742c <lwip_htonl>
 8011e6a:	0004      	movs	r4, r0
 8011e6c:	68bb      	ldr	r3, [r7, #8]
 8011e6e:	691b      	ldr	r3, [r3, #16]
 8011e70:	791a      	ldrb	r2, [r3, #4]
 8011e72:	7959      	ldrb	r1, [r3, #5]
 8011e74:	0209      	lsls	r1, r1, #8
 8011e76:	430a      	orrs	r2, r1
 8011e78:	7999      	ldrb	r1, [r3, #6]
 8011e7a:	0409      	lsls	r1, r1, #16
 8011e7c:	430a      	orrs	r2, r1
 8011e7e:	79db      	ldrb	r3, [r3, #7]
 8011e80:	061b      	lsls	r3, r3, #24
 8011e82:	4313      	orrs	r3, r2
 8011e84:	0018      	movs	r0, r3
 8011e86:	f7f5 fad1 	bl	800742c <lwip_htonl>
 8011e8a:	0003      	movs	r3, r0
 8011e8c:	1ae3      	subs	r3, r4, r3
  while (*cur_seg &&
 8011e8e:	d4d5      	bmi.n	8011e3c <tcp_rexmit+0x50>
  }
  seg->next = *cur_seg;
 8011e90:	68fb      	ldr	r3, [r7, #12]
 8011e92:	681a      	ldr	r2, [r3, #0]
 8011e94:	68bb      	ldr	r3, [r7, #8]
 8011e96:	601a      	str	r2, [r3, #0]
  *cur_seg = seg;
 8011e98:	68fb      	ldr	r3, [r7, #12]
 8011e9a:	68ba      	ldr	r2, [r7, #8]
 8011e9c:	601a      	str	r2, [r3, #0]
#if TCP_OVERSIZE
  if (seg->next == NULL) {
 8011e9e:	68bb      	ldr	r3, [r7, #8]
 8011ea0:	681b      	ldr	r3, [r3, #0]
 8011ea2:	2b00      	cmp	r3, #0
 8011ea4:	d103      	bne.n	8011eae <tcp_rexmit+0xc2>
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
 8011ea6:	687b      	ldr	r3, [r7, #4]
 8011ea8:	226c      	movs	r2, #108	; 0x6c
 8011eaa:	2100      	movs	r1, #0
 8011eac:	5299      	strh	r1, [r3, r2]
  }
#endif /* TCP_OVERSIZE */

  if (pcb->nrtx < 0xFF) {
 8011eae:	687b      	ldr	r3, [r7, #4]
 8011eb0:	2246      	movs	r2, #70	; 0x46
 8011eb2:	5c9b      	ldrb	r3, [r3, r2]
 8011eb4:	2bff      	cmp	r3, #255	; 0xff
 8011eb6:	d007      	beq.n	8011ec8 <tcp_rexmit+0xdc>
    ++pcb->nrtx;
 8011eb8:	687b      	ldr	r3, [r7, #4]
 8011eba:	2246      	movs	r2, #70	; 0x46
 8011ebc:	5c9b      	ldrb	r3, [r3, r2]
 8011ebe:	3301      	adds	r3, #1
 8011ec0:	b2d9      	uxtb	r1, r3
 8011ec2:	687b      	ldr	r3, [r7, #4]
 8011ec4:	2246      	movs	r2, #70	; 0x46
 8011ec6:	5499      	strb	r1, [r3, r2]
  }

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
 8011ec8:	687b      	ldr	r3, [r7, #4]
 8011eca:	2200      	movs	r2, #0
 8011ecc:	639a      	str	r2, [r3, #56]	; 0x38

  /* Do the actual retransmission. */
  MIB2_STATS_INC(mib2.tcpretranssegs);
  /* No need to call tcp_output: we are always called from tcp_input()
     and thus tcp_output directly returns. */
  return ERR_OK;
 8011ece:	2300      	movs	r3, #0
}
 8011ed0:	0018      	movs	r0, r3
 8011ed2:	46bd      	mov	sp, r7
 8011ed4:	b005      	add	sp, #20
 8011ed6:	bd90      	pop	{r4, r7, pc}
 8011ed8:	08021684 	.word	0x08021684
 8011edc:	000006c2 	.word	0x000006c2
 8011ee0:	08021e24 	.word	0x08021e24
 8011ee4:	080216d0 	.word	0x080216d0

08011ee8 <tcp_rexmit_fast>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
 8011ee8:	b580      	push	{r7, lr}
 8011eea:	b082      	sub	sp, #8
 8011eec:	af00      	add	r7, sp, #0
 8011eee:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_rexmit_fast: invalid pcb", pcb != NULL);
 8011ef0:	687b      	ldr	r3, [r7, #4]
 8011ef2:	2b00      	cmp	r3, #0
 8011ef4:	d105      	bne.n	8011f02 <tcp_rexmit_fast+0x1a>
 8011ef6:	4b2c      	ldr	r3, [pc, #176]	; (8011fa8 <tcp_rexmit_fast+0xc0>)
 8011ef8:	4a2c      	ldr	r2, [pc, #176]	; (8011fac <tcp_rexmit_fast+0xc4>)
 8011efa:	492d      	ldr	r1, [pc, #180]	; (8011fb0 <tcp_rexmit_fast+0xc8>)
 8011efc:	482d      	ldr	r0, [pc, #180]	; (8011fb4 <tcp_rexmit_fast+0xcc>)
 8011efe:	f7f0 f971 	bl	80021e4 <app_debug_rtt_raw>

  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
 8011f02:	687b      	ldr	r3, [r7, #4]
 8011f04:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8011f06:	2b00      	cmp	r3, #0
 8011f08:	d049      	beq.n	8011f9e <tcp_rexmit_fast+0xb6>
 8011f0a:	687b      	ldr	r3, [r7, #4]
 8011f0c:	8bdb      	ldrh	r3, [r3, #30]
 8011f0e:	001a      	movs	r2, r3
 8011f10:	2304      	movs	r3, #4
 8011f12:	4013      	ands	r3, r2
 8011f14:	d143      	bne.n	8011f9e <tcp_rexmit_fast+0xb6>
    LWIP_DEBUGF(TCP_FR_DEBUG,
                ("tcp_receive: dupacks %"U16_F" (%"U32_F
                 "), fast retransmit %"U32_F"\n",
                 (u16_t)pcb->dupacks, pcb->lastack,
                 lwip_ntohl(pcb->unacked->tcphdr->seqno)));
    if (tcp_rexmit(pcb) == ERR_OK) {
 8011f16:	687b      	ldr	r3, [r7, #4]
 8011f18:	0018      	movs	r0, r3
 8011f1a:	f7ff ff67 	bl	8011dec <tcp_rexmit>
 8011f1e:	1e03      	subs	r3, r0, #0
 8011f20:	d13d      	bne.n	8011f9e <tcp_rexmit_fast+0xb6>
      /* Set ssthresh to half of the minimum of the current
       * cwnd and the advertised window */
      pcb->ssthresh = LWIP_MIN(pcb->cwnd, pcb->snd_wnd) / 2;
 8011f22:	687b      	ldr	r3, [r7, #4]
 8011f24:	2264      	movs	r2, #100	; 0x64
 8011f26:	5a99      	ldrh	r1, [r3, r2]
 8011f28:	687b      	ldr	r3, [r7, #4]
 8011f2a:	224c      	movs	r2, #76	; 0x4c
 8011f2c:	5a9b      	ldrh	r3, [r3, r2]
 8011f2e:	1c18      	adds	r0, r3, #0
 8011f30:	b28a      	uxth	r2, r1
 8011f32:	b283      	uxth	r3, r0
 8011f34:	429a      	cmp	r2, r3
 8011f36:	d900      	bls.n	8011f3a <tcp_rexmit_fast+0x52>
 8011f38:	1c01      	adds	r1, r0, #0
 8011f3a:	b28b      	uxth	r3, r1
 8011f3c:	2b00      	cmp	r3, #0
 8011f3e:	da00      	bge.n	8011f42 <tcp_rexmit_fast+0x5a>
 8011f40:	3301      	adds	r3, #1
 8011f42:	105b      	asrs	r3, r3, #1
 8011f44:	b299      	uxth	r1, r3
 8011f46:	687b      	ldr	r3, [r7, #4]
 8011f48:	224e      	movs	r2, #78	; 0x4e
 8011f4a:	5299      	strh	r1, [r3, r2]

      /* The minimum value for ssthresh should be 2 MSS */
      if (pcb->ssthresh < (2U * pcb->mss)) {
 8011f4c:	687b      	ldr	r3, [r7, #4]
 8011f4e:	224e      	movs	r2, #78	; 0x4e
 8011f50:	5a9b      	ldrh	r3, [r3, r2]
 8011f52:	001a      	movs	r2, r3
 8011f54:	687b      	ldr	r3, [r7, #4]
 8011f56:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8011f58:	005b      	lsls	r3, r3, #1
 8011f5a:	429a      	cmp	r2, r3
 8011f5c:	d206      	bcs.n	8011f6c <tcp_rexmit_fast+0x84>
        LWIP_DEBUGF(TCP_FR_DEBUG,
                    ("tcp_receive: The minimum value for ssthresh %"TCPWNDSIZE_F
                     " should be min 2 mss %"U16_F"...\n",
                     pcb->ssthresh, (u16_t)(2 * pcb->mss)));
        pcb->ssthresh = 2 * pcb->mss;
 8011f5e:	687b      	ldr	r3, [r7, #4]
 8011f60:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8011f62:	18db      	adds	r3, r3, r3
 8011f64:	b299      	uxth	r1, r3
 8011f66:	687b      	ldr	r3, [r7, #4]
 8011f68:	224e      	movs	r2, #78	; 0x4e
 8011f6a:	5299      	strh	r1, [r3, r2]
      }

      pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
 8011f6c:	687b      	ldr	r3, [r7, #4]
 8011f6e:	224e      	movs	r2, #78	; 0x4e
 8011f70:	5a9a      	ldrh	r2, [r3, r2]
 8011f72:	687b      	ldr	r3, [r7, #4]
 8011f74:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8011f76:	1c19      	adds	r1, r3, #0
 8011f78:	1c0b      	adds	r3, r1, #0
 8011f7a:	18db      	adds	r3, r3, r3
 8011f7c:	185b      	adds	r3, r3, r1
 8011f7e:	b29b      	uxth	r3, r3
 8011f80:	18d3      	adds	r3, r2, r3
 8011f82:	b299      	uxth	r1, r3
 8011f84:	687b      	ldr	r3, [r7, #4]
 8011f86:	224c      	movs	r2, #76	; 0x4c
 8011f88:	5299      	strh	r1, [r3, r2]
      tcp_set_flags(pcb, TF_INFR);
 8011f8a:	687b      	ldr	r3, [r7, #4]
 8011f8c:	8bdb      	ldrh	r3, [r3, #30]
 8011f8e:	2204      	movs	r2, #4
 8011f90:	4313      	orrs	r3, r2
 8011f92:	b29a      	uxth	r2, r3
 8011f94:	687b      	ldr	r3, [r7, #4]
 8011f96:	83da      	strh	r2, [r3, #30]

      /* Reset the retransmission timer to prevent immediate rto retransmissions */
      pcb->rtime = 0;
 8011f98:	687b      	ldr	r3, [r7, #4]
 8011f9a:	2200      	movs	r2, #0
 8011f9c:	869a      	strh	r2, [r3, #52]	; 0x34
    }
  }
}
 8011f9e:	46c0      	nop			; (mov r8, r8)
 8011fa0:	46bd      	mov	sp, r7
 8011fa2:	b002      	add	sp, #8
 8011fa4:	bd80      	pop	{r7, pc}
 8011fa6:	46c0      	nop			; (mov r8, r8)
 8011fa8:	08021684 	.word	0x08021684
 8011fac:	000006fa 	.word	0x000006fa
 8011fb0:	08021e3c 	.word	0x08021e3c
 8011fb4:	080216d0 	.word	0x080216d0

08011fb8 <tcp_output_alloc_header_common>:

static struct pbuf *
tcp_output_alloc_header_common(u32_t ackno, u16_t optlen, u16_t datalen,
                        u32_t seqno_be /* already in network byte order */,
                        u16_t src_port, u16_t dst_port, u8_t flags, u16_t wnd)
{
 8011fb8:	b590      	push	{r4, r7, lr}
 8011fba:	b087      	sub	sp, #28
 8011fbc:	af00      	add	r7, sp, #0
 8011fbe:	60f8      	str	r0, [r7, #12]
 8011fc0:	0008      	movs	r0, r1
 8011fc2:	0011      	movs	r1, r2
 8011fc4:	607b      	str	r3, [r7, #4]
 8011fc6:	240a      	movs	r4, #10
 8011fc8:	193b      	adds	r3, r7, r4
 8011fca:	1c02      	adds	r2, r0, #0
 8011fcc:	801a      	strh	r2, [r3, #0]
 8011fce:	2008      	movs	r0, #8
 8011fd0:	183b      	adds	r3, r7, r0
 8011fd2:	1c0a      	adds	r2, r1, #0
 8011fd4:	801a      	strh	r2, [r3, #0]
  struct tcp_hdr *tcphdr;
  struct pbuf *p;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 8011fd6:	193a      	adds	r2, r7, r4
 8011fd8:	183b      	adds	r3, r7, r0
 8011fda:	8812      	ldrh	r2, [r2, #0]
 8011fdc:	881b      	ldrh	r3, [r3, #0]
 8011fde:	18d3      	adds	r3, r2, r3
 8011fe0:	b29b      	uxth	r3, r3
 8011fe2:	3314      	adds	r3, #20
 8011fe4:	b29b      	uxth	r3, r3
 8011fe6:	22a0      	movs	r2, #160	; 0xa0
 8011fe8:	0092      	lsls	r2, r2, #2
 8011fea:	0019      	movs	r1, r3
 8011fec:	2024      	movs	r0, #36	; 0x24
 8011fee:	f7f7 ff3f 	bl	8009e70 <pbuf_alloc>
 8011ff2:	0003      	movs	r3, r0
 8011ff4:	617b      	str	r3, [r7, #20]
  if (p != NULL) {
 8011ff6:	697b      	ldr	r3, [r7, #20]
 8011ff8:	2b00      	cmp	r3, #0
 8011ffa:	d100      	bne.n	8011ffe <tcp_output_alloc_header_common+0x46>
 8011ffc:	e0f0      	b.n	80121e0 <tcp_output_alloc_header_common+0x228>
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
 8011ffe:	193b      	adds	r3, r7, r4
 8012000:	881b      	ldrh	r3, [r3, #0]
 8012002:	3313      	adds	r3, #19
 8012004:	697a      	ldr	r2, [r7, #20]
 8012006:	8952      	ldrh	r2, [r2, #10]
 8012008:	4293      	cmp	r3, r2
 801200a:	db05      	blt.n	8012018 <tcp_output_alloc_header_common+0x60>
 801200c:	4b77      	ldr	r3, [pc, #476]	; (80121ec <tcp_output_alloc_header_common+0x234>)
 801200e:	4a78      	ldr	r2, [pc, #480]	; (80121f0 <tcp_output_alloc_header_common+0x238>)
 8012010:	4978      	ldr	r1, [pc, #480]	; (80121f4 <tcp_output_alloc_header_common+0x23c>)
 8012012:	4879      	ldr	r0, [pc, #484]	; (80121f8 <tcp_output_alloc_header_common+0x240>)
 8012014:	f7f0 f8e6 	bl	80021e4 <app_debug_rtt_raw>
                (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
 8012018:	697b      	ldr	r3, [r7, #20]
 801201a:	685b      	ldr	r3, [r3, #4]
 801201c:	613b      	str	r3, [r7, #16]
    tcphdr->src = lwip_htons(src_port);
 801201e:	2328      	movs	r3, #40	; 0x28
 8012020:	18fb      	adds	r3, r7, r3
 8012022:	881b      	ldrh	r3, [r3, #0]
 8012024:	0018      	movs	r0, r3
 8012026:	f7f5 f9eb 	bl	8007400 <lwip_htons>
 801202a:	0003      	movs	r3, r0
 801202c:	001a      	movs	r2, r3
 801202e:	693b      	ldr	r3, [r7, #16]
 8012030:	21ff      	movs	r1, #255	; 0xff
 8012032:	4011      	ands	r1, r2
 8012034:	000c      	movs	r4, r1
 8012036:	7819      	ldrb	r1, [r3, #0]
 8012038:	2000      	movs	r0, #0
 801203a:	4001      	ands	r1, r0
 801203c:	1c08      	adds	r0, r1, #0
 801203e:	1c21      	adds	r1, r4, #0
 8012040:	4301      	orrs	r1, r0
 8012042:	7019      	strb	r1, [r3, #0]
 8012044:	0a12      	lsrs	r2, r2, #8
 8012046:	b290      	uxth	r0, r2
 8012048:	785a      	ldrb	r2, [r3, #1]
 801204a:	2100      	movs	r1, #0
 801204c:	400a      	ands	r2, r1
 801204e:	1c11      	adds	r1, r2, #0
 8012050:	1c02      	adds	r2, r0, #0
 8012052:	430a      	orrs	r2, r1
 8012054:	705a      	strb	r2, [r3, #1]
    tcphdr->dest = lwip_htons(dst_port);
 8012056:	232c      	movs	r3, #44	; 0x2c
 8012058:	18fb      	adds	r3, r7, r3
 801205a:	881b      	ldrh	r3, [r3, #0]
 801205c:	0018      	movs	r0, r3
 801205e:	f7f5 f9cf 	bl	8007400 <lwip_htons>
 8012062:	0003      	movs	r3, r0
 8012064:	001a      	movs	r2, r3
 8012066:	693b      	ldr	r3, [r7, #16]
 8012068:	21ff      	movs	r1, #255	; 0xff
 801206a:	4011      	ands	r1, r2
 801206c:	000c      	movs	r4, r1
 801206e:	7899      	ldrb	r1, [r3, #2]
 8012070:	2000      	movs	r0, #0
 8012072:	4001      	ands	r1, r0
 8012074:	1c08      	adds	r0, r1, #0
 8012076:	1c21      	adds	r1, r4, #0
 8012078:	4301      	orrs	r1, r0
 801207a:	7099      	strb	r1, [r3, #2]
 801207c:	0a12      	lsrs	r2, r2, #8
 801207e:	b290      	uxth	r0, r2
 8012080:	78da      	ldrb	r2, [r3, #3]
 8012082:	2100      	movs	r1, #0
 8012084:	400a      	ands	r2, r1
 8012086:	1c11      	adds	r1, r2, #0
 8012088:	1c02      	adds	r2, r0, #0
 801208a:	430a      	orrs	r2, r1
 801208c:	70da      	strb	r2, [r3, #3]
    tcphdr->seqno = seqno_be;
 801208e:	693b      	ldr	r3, [r7, #16]
 8012090:	1d3a      	adds	r2, r7, #4
 8012092:	7810      	ldrb	r0, [r2, #0]
 8012094:	791a      	ldrb	r2, [r3, #4]
 8012096:	2100      	movs	r1, #0
 8012098:	400a      	ands	r2, r1
 801209a:	1c11      	adds	r1, r2, #0
 801209c:	1c02      	adds	r2, r0, #0
 801209e:	430a      	orrs	r2, r1
 80120a0:	711a      	strb	r2, [r3, #4]
 80120a2:	1d7a      	adds	r2, r7, #5
 80120a4:	7810      	ldrb	r0, [r2, #0]
 80120a6:	795a      	ldrb	r2, [r3, #5]
 80120a8:	2100      	movs	r1, #0
 80120aa:	400a      	ands	r2, r1
 80120ac:	1c11      	adds	r1, r2, #0
 80120ae:	1c02      	adds	r2, r0, #0
 80120b0:	430a      	orrs	r2, r1
 80120b2:	715a      	strb	r2, [r3, #5]
 80120b4:	1dba      	adds	r2, r7, #6
 80120b6:	7810      	ldrb	r0, [r2, #0]
 80120b8:	799a      	ldrb	r2, [r3, #6]
 80120ba:	2100      	movs	r1, #0
 80120bc:	400a      	ands	r2, r1
 80120be:	1c11      	adds	r1, r2, #0
 80120c0:	1c02      	adds	r2, r0, #0
 80120c2:	430a      	orrs	r2, r1
 80120c4:	719a      	strb	r2, [r3, #6]
 80120c6:	1dfa      	adds	r2, r7, #7
 80120c8:	7810      	ldrb	r0, [r2, #0]
 80120ca:	79da      	ldrb	r2, [r3, #7]
 80120cc:	2100      	movs	r1, #0
 80120ce:	400a      	ands	r2, r1
 80120d0:	1c11      	adds	r1, r2, #0
 80120d2:	1c02      	adds	r2, r0, #0
 80120d4:	430a      	orrs	r2, r1
 80120d6:	71da      	strb	r2, [r3, #7]
    tcphdr->ackno = lwip_htonl(ackno);
 80120d8:	68fb      	ldr	r3, [r7, #12]
 80120da:	0018      	movs	r0, r3
 80120dc:	f7f5 f9a6 	bl	800742c <lwip_htonl>
 80120e0:	0002      	movs	r2, r0
 80120e2:	693b      	ldr	r3, [r7, #16]
 80120e4:	21ff      	movs	r1, #255	; 0xff
 80120e6:	4011      	ands	r1, r2
 80120e8:	000c      	movs	r4, r1
 80120ea:	7a19      	ldrb	r1, [r3, #8]
 80120ec:	2000      	movs	r0, #0
 80120ee:	4001      	ands	r1, r0
 80120f0:	1c08      	adds	r0, r1, #0
 80120f2:	1c21      	adds	r1, r4, #0
 80120f4:	4301      	orrs	r1, r0
 80120f6:	7219      	strb	r1, [r3, #8]
 80120f8:	0a11      	lsrs	r1, r2, #8
 80120fa:	20ff      	movs	r0, #255	; 0xff
 80120fc:	4001      	ands	r1, r0
 80120fe:	000c      	movs	r4, r1
 8012100:	7a59      	ldrb	r1, [r3, #9]
 8012102:	2000      	movs	r0, #0
 8012104:	4001      	ands	r1, r0
 8012106:	1c08      	adds	r0, r1, #0
 8012108:	1c21      	adds	r1, r4, #0
 801210a:	4301      	orrs	r1, r0
 801210c:	7259      	strb	r1, [r3, #9]
 801210e:	0c11      	lsrs	r1, r2, #16
 8012110:	20ff      	movs	r0, #255	; 0xff
 8012112:	4001      	ands	r1, r0
 8012114:	000c      	movs	r4, r1
 8012116:	7a99      	ldrb	r1, [r3, #10]
 8012118:	2000      	movs	r0, #0
 801211a:	4001      	ands	r1, r0
 801211c:	1c08      	adds	r0, r1, #0
 801211e:	1c21      	adds	r1, r4, #0
 8012120:	4301      	orrs	r1, r0
 8012122:	7299      	strb	r1, [r3, #10]
 8012124:	0e10      	lsrs	r0, r2, #24
 8012126:	7ada      	ldrb	r2, [r3, #11]
 8012128:	2100      	movs	r1, #0
 801212a:	400a      	ands	r2, r1
 801212c:	1c11      	adds	r1, r2, #0
 801212e:	1c02      	adds	r2, r0, #0
 8012130:	430a      	orrs	r2, r1
 8012132:	72da      	strb	r2, [r3, #11]
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), flags);
 8012134:	230a      	movs	r3, #10
 8012136:	18fb      	adds	r3, r7, r3
 8012138:	881b      	ldrh	r3, [r3, #0]
 801213a:	089b      	lsrs	r3, r3, #2
 801213c:	b29b      	uxth	r3, r3
 801213e:	3305      	adds	r3, #5
 8012140:	b29b      	uxth	r3, r3
 8012142:	031b      	lsls	r3, r3, #12
 8012144:	b29a      	uxth	r2, r3
 8012146:	2330      	movs	r3, #48	; 0x30
 8012148:	18fb      	adds	r3, r7, r3
 801214a:	781b      	ldrb	r3, [r3, #0]
 801214c:	b29b      	uxth	r3, r3
 801214e:	4313      	orrs	r3, r2
 8012150:	b29b      	uxth	r3, r3
 8012152:	0018      	movs	r0, r3
 8012154:	f7f5 f954 	bl	8007400 <lwip_htons>
 8012158:	0003      	movs	r3, r0
 801215a:	001a      	movs	r2, r3
 801215c:	693b      	ldr	r3, [r7, #16]
 801215e:	21ff      	movs	r1, #255	; 0xff
 8012160:	4011      	ands	r1, r2
 8012162:	000c      	movs	r4, r1
 8012164:	7b19      	ldrb	r1, [r3, #12]
 8012166:	2000      	movs	r0, #0
 8012168:	4001      	ands	r1, r0
 801216a:	1c08      	adds	r0, r1, #0
 801216c:	1c21      	adds	r1, r4, #0
 801216e:	4301      	orrs	r1, r0
 8012170:	7319      	strb	r1, [r3, #12]
 8012172:	0a12      	lsrs	r2, r2, #8
 8012174:	b290      	uxth	r0, r2
 8012176:	7b5a      	ldrb	r2, [r3, #13]
 8012178:	2100      	movs	r1, #0
 801217a:	400a      	ands	r2, r1
 801217c:	1c11      	adds	r1, r2, #0
 801217e:	1c02      	adds	r2, r0, #0
 8012180:	430a      	orrs	r2, r1
 8012182:	735a      	strb	r2, [r3, #13]
    tcphdr->wnd = lwip_htons(wnd);
 8012184:	2334      	movs	r3, #52	; 0x34
 8012186:	18fb      	adds	r3, r7, r3
 8012188:	881b      	ldrh	r3, [r3, #0]
 801218a:	0018      	movs	r0, r3
 801218c:	f7f5 f938 	bl	8007400 <lwip_htons>
 8012190:	0003      	movs	r3, r0
 8012192:	001a      	movs	r2, r3
 8012194:	693b      	ldr	r3, [r7, #16]
 8012196:	21ff      	movs	r1, #255	; 0xff
 8012198:	4011      	ands	r1, r2
 801219a:	000c      	movs	r4, r1
 801219c:	7b99      	ldrb	r1, [r3, #14]
 801219e:	2000      	movs	r0, #0
 80121a0:	4001      	ands	r1, r0
 80121a2:	1c08      	adds	r0, r1, #0
 80121a4:	1c21      	adds	r1, r4, #0
 80121a6:	4301      	orrs	r1, r0
 80121a8:	7399      	strb	r1, [r3, #14]
 80121aa:	0a12      	lsrs	r2, r2, #8
 80121ac:	b290      	uxth	r0, r2
 80121ae:	7bda      	ldrb	r2, [r3, #15]
 80121b0:	2100      	movs	r1, #0
 80121b2:	400a      	ands	r2, r1
 80121b4:	1c11      	adds	r1, r2, #0
 80121b6:	1c02      	adds	r2, r0, #0
 80121b8:	430a      	orrs	r2, r1
 80121ba:	73da      	strb	r2, [r3, #15]
    tcphdr->chksum = 0;
 80121bc:	693b      	ldr	r3, [r7, #16]
 80121be:	7c1a      	ldrb	r2, [r3, #16]
 80121c0:	2100      	movs	r1, #0
 80121c2:	400a      	ands	r2, r1
 80121c4:	741a      	strb	r2, [r3, #16]
 80121c6:	7c5a      	ldrb	r2, [r3, #17]
 80121c8:	2100      	movs	r1, #0
 80121ca:	400a      	ands	r2, r1
 80121cc:	745a      	strb	r2, [r3, #17]
    tcphdr->urgp = 0;
 80121ce:	693b      	ldr	r3, [r7, #16]
 80121d0:	7c9a      	ldrb	r2, [r3, #18]
 80121d2:	2100      	movs	r1, #0
 80121d4:	400a      	ands	r2, r1
 80121d6:	749a      	strb	r2, [r3, #18]
 80121d8:	7cda      	ldrb	r2, [r3, #19]
 80121da:	2100      	movs	r1, #0
 80121dc:	400a      	ands	r2, r1
 80121de:	74da      	strb	r2, [r3, #19]
  }
  return p;
 80121e0:	697b      	ldr	r3, [r7, #20]
}
 80121e2:	0018      	movs	r0, r3
 80121e4:	46bd      	mov	sp, r7
 80121e6:	b007      	add	sp, #28
 80121e8:	bd90      	pop	{r4, r7, pc}
 80121ea:	46c0      	nop			; (mov r8, r8)
 80121ec:	08021684 	.word	0x08021684
 80121f0:	00000724 	.word	0x00000724
 80121f4:	08021e5c 	.word	0x08021e5c
 80121f8:	080216d0 	.word	0x080216d0

080121fc <tcp_output_alloc_header>:
 * @return pbuf with p->payload being the tcp_hdr
 */
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
                        u32_t seqno_be /* already in network byte order */)
{
 80121fc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80121fe:	b08b      	sub	sp, #44	; 0x2c
 8012200:	af04      	add	r7, sp, #16
 8012202:	60f8      	str	r0, [r7, #12]
 8012204:	0008      	movs	r0, r1
 8012206:	0011      	movs	r1, r2
 8012208:	607b      	str	r3, [r7, #4]
 801220a:	230a      	movs	r3, #10
 801220c:	18fb      	adds	r3, r7, r3
 801220e:	1c02      	adds	r2, r0, #0
 8012210:	801a      	strh	r2, [r3, #0]
 8012212:	2308      	movs	r3, #8
 8012214:	18fb      	adds	r3, r7, r3
 8012216:	1c0a      	adds	r2, r1, #0
 8012218:	801a      	strh	r2, [r3, #0]
  struct pbuf *p;

  LWIP_ASSERT("tcp_output_alloc_header: invalid pcb", pcb != NULL);
 801221a:	68fb      	ldr	r3, [r7, #12]
 801221c:	2b00      	cmp	r3, #0
 801221e:	d105      	bne.n	801222c <tcp_output_alloc_header+0x30>
 8012220:	4b18      	ldr	r3, [pc, #96]	; (8012284 <tcp_output_alloc_header+0x88>)
 8012222:	4a19      	ldr	r2, [pc, #100]	; (8012288 <tcp_output_alloc_header+0x8c>)
 8012224:	4919      	ldr	r1, [pc, #100]	; (801228c <tcp_output_alloc_header+0x90>)
 8012226:	481a      	ldr	r0, [pc, #104]	; (8012290 <tcp_output_alloc_header+0x94>)
 8012228:	f7ef ffdc 	bl	80021e4 <app_debug_rtt_raw>

  p = tcp_output_alloc_header_common(pcb->rcv_nxt, optlen, datalen,
 801222c:	68fb      	ldr	r3, [r7, #12]
 801222e:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 8012230:	68fb      	ldr	r3, [r7, #12]
 8012232:	8b5b      	ldrh	r3, [r3, #26]
 8012234:	68fa      	ldr	r2, [r7, #12]
 8012236:	8b92      	ldrh	r2, [r2, #28]
 8012238:	68f9      	ldr	r1, [r7, #12]
 801223a:	8dc9      	ldrh	r1, [r1, #46]	; 0x2e
 801223c:	687e      	ldr	r6, [r7, #4]
 801223e:	2008      	movs	r0, #8
 8012240:	1838      	adds	r0, r7, r0
 8012242:	8805      	ldrh	r5, [r0, #0]
 8012244:	200a      	movs	r0, #10
 8012246:	1838      	adds	r0, r7, r0
 8012248:	8800      	ldrh	r0, [r0, #0]
 801224a:	9103      	str	r1, [sp, #12]
 801224c:	2110      	movs	r1, #16
 801224e:	9102      	str	r1, [sp, #8]
 8012250:	9201      	str	r2, [sp, #4]
 8012252:	9300      	str	r3, [sp, #0]
 8012254:	0033      	movs	r3, r6
 8012256:	002a      	movs	r2, r5
 8012258:	0001      	movs	r1, r0
 801225a:	0020      	movs	r0, r4
 801225c:	f7ff feac 	bl	8011fb8 <tcp_output_alloc_header_common>
 8012260:	0003      	movs	r3, r0
 8012262:	617b      	str	r3, [r7, #20]
    seqno_be, pcb->local_port, pcb->remote_port, TCP_ACK,
    TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
  if (p != NULL) {
 8012264:	697b      	ldr	r3, [r7, #20]
 8012266:	2b00      	cmp	r3, #0
 8012268:	d006      	beq.n	8012278 <tcp_output_alloc_header+0x7c>
    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 801226a:	68fb      	ldr	r3, [r7, #12]
 801226c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801226e:	68fa      	ldr	r2, [r7, #12]
 8012270:	8dd2      	ldrh	r2, [r2, #46]	; 0x2e
 8012272:	189a      	adds	r2, r3, r2
 8012274:	68fb      	ldr	r3, [r7, #12]
 8012276:	631a      	str	r2, [r3, #48]	; 0x30
  }
  return p;
 8012278:	697b      	ldr	r3, [r7, #20]
}
 801227a:	0018      	movs	r0, r3
 801227c:	46bd      	mov	sp, r7
 801227e:	b007      	add	sp, #28
 8012280:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8012282:	46c0      	nop			; (mov r8, r8)
 8012284:	08021684 	.word	0x08021684
 8012288:	00000743 	.word	0x00000743
 801228c:	08021e8c 	.word	0x08021e8c
 8012290:	080216d0 	.word	0x080216d0

08012294 <tcp_output_fill_options>:

/* Fill in options for control segments */
static void
tcp_output_fill_options(const struct tcp_pcb *pcb, struct pbuf *p, u8_t optflags, u8_t num_sacks)
{
 8012294:	b580      	push	{r7, lr}
 8012296:	b088      	sub	sp, #32
 8012298:	af00      	add	r7, sp, #0
 801229a:	60f8      	str	r0, [r7, #12]
 801229c:	60b9      	str	r1, [r7, #8]
 801229e:	0019      	movs	r1, r3
 80122a0:	1dfb      	adds	r3, r7, #7
 80122a2:	701a      	strb	r2, [r3, #0]
 80122a4:	1dbb      	adds	r3, r7, #6
 80122a6:	1c0a      	adds	r2, r1, #0
 80122a8:	701a      	strb	r2, [r3, #0]
  struct tcp_hdr *tcphdr;
  u32_t *opts;
  u16_t sacks_len = 0;
 80122aa:	231e      	movs	r3, #30
 80122ac:	18fb      	adds	r3, r7, r3
 80122ae:	2200      	movs	r2, #0
 80122b0:	801a      	strh	r2, [r3, #0]

  LWIP_ASSERT("tcp_output_fill_options: invalid pbuf", p != NULL);
 80122b2:	68bb      	ldr	r3, [r7, #8]
 80122b4:	2b00      	cmp	r3, #0
 80122b6:	d105      	bne.n	80122c4 <tcp_output_fill_options+0x30>
 80122b8:	4b13      	ldr	r3, [pc, #76]	; (8012308 <tcp_output_fill_options+0x74>)
 80122ba:	4a14      	ldr	r2, [pc, #80]	; (801230c <tcp_output_fill_options+0x78>)
 80122bc:	4914      	ldr	r1, [pc, #80]	; (8012310 <tcp_output_fill_options+0x7c>)
 80122be:	4815      	ldr	r0, [pc, #84]	; (8012314 <tcp_output_fill_options+0x80>)
 80122c0:	f7ef ff90 	bl	80021e4 <app_debug_rtt_raw>

  tcphdr = (struct tcp_hdr *)p->payload;
 80122c4:	68bb      	ldr	r3, [r7, #8]
 80122c6:	685b      	ldr	r3, [r3, #4]
 80122c8:	61bb      	str	r3, [r7, #24]
  opts = (u32_t *)(void *)(tcphdr + 1);
 80122ca:	69bb      	ldr	r3, [r7, #24]
 80122cc:	3314      	adds	r3, #20
 80122ce:	617b      	str	r3, [r7, #20]
  opts = LWIP_HOOK_TCP_OUT_ADD_TCPOPTS(p, tcphdr, pcb, opts);
#endif

  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(sacks_len);
  LWIP_ASSERT("options not filled", (u8_t *)opts == ((u8_t *)(tcphdr + 1)) + sacks_len * 4 + LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb));
 80122d0:	69bb      	ldr	r3, [r7, #24]
 80122d2:	3314      	adds	r3, #20
 80122d4:	001a      	movs	r2, r3
 80122d6:	231e      	movs	r3, #30
 80122d8:	18fb      	adds	r3, r7, r3
 80122da:	881b      	ldrh	r3, [r3, #0]
 80122dc:	009b      	lsls	r3, r3, #2
 80122de:	0018      	movs	r0, r3
 80122e0:	1dfb      	adds	r3, r7, #7
 80122e2:	781b      	ldrb	r3, [r3, #0]
 80122e4:	009b      	lsls	r3, r3, #2
 80122e6:	2104      	movs	r1, #4
 80122e8:	400b      	ands	r3, r1
 80122ea:	18c3      	adds	r3, r0, r3
 80122ec:	18d3      	adds	r3, r2, r3
 80122ee:	697a      	ldr	r2, [r7, #20]
 80122f0:	429a      	cmp	r2, r3
 80122f2:	d005      	beq.n	8012300 <tcp_output_fill_options+0x6c>
 80122f4:	4b04      	ldr	r3, [pc, #16]	; (8012308 <tcp_output_fill_options+0x74>)
 80122f6:	4a08      	ldr	r2, [pc, #32]	; (8012318 <tcp_output_fill_options+0x84>)
 80122f8:	4908      	ldr	r1, [pc, #32]	; (801231c <tcp_output_fill_options+0x88>)
 80122fa:	4806      	ldr	r0, [pc, #24]	; (8012314 <tcp_output_fill_options+0x80>)
 80122fc:	f7ef ff72 	bl	80021e4 <app_debug_rtt_raw>
  LWIP_UNUSED_ARG(optflags); /* for LWIP_NOASSERT */
  LWIP_UNUSED_ARG(opts); /* for LWIP_NOASSERT */
}
 8012300:	46c0      	nop			; (mov r8, r8)
 8012302:	46bd      	mov	sp, r7
 8012304:	b008      	add	sp, #32
 8012306:	bd80      	pop	{r7, pc}
 8012308:	08021684 	.word	0x08021684
 801230c:	00000757 	.word	0x00000757
 8012310:	08021eb4 	.word	0x08021eb4
 8012314:	080216d0 	.word	0x080216d0
 8012318:	00000776 	.word	0x00000776
 801231c:	08021d88 	.word	0x08021d88

08012320 <tcp_output_control_segment>:
 * header checksum and calling ip_output_if while handling netif hints and stats.
 */
static err_t
tcp_output_control_segment(const struct tcp_pcb *pcb, struct pbuf *p,
                           const ip_addr_t *src, const ip_addr_t *dst)
{
 8012320:	b5b0      	push	{r4, r5, r7, lr}
 8012322:	b08c      	sub	sp, #48	; 0x30
 8012324:	af04      	add	r7, sp, #16
 8012326:	60f8      	str	r0, [r7, #12]
 8012328:	60b9      	str	r1, [r7, #8]
 801232a:	607a      	str	r2, [r7, #4]
 801232c:	603b      	str	r3, [r7, #0]
  err_t err;
  struct netif *netif;

  LWIP_ASSERT("tcp_output_control_segment: invalid pbuf", p != NULL);
 801232e:	68bb      	ldr	r3, [r7, #8]
 8012330:	2b00      	cmp	r3, #0
 8012332:	d106      	bne.n	8012342 <tcp_output_control_segment+0x22>
 8012334:	4b3c      	ldr	r3, [pc, #240]	; (8012428 <tcp_output_control_segment+0x108>)
 8012336:	22f1      	movs	r2, #241	; 0xf1
 8012338:	00d2      	lsls	r2, r2, #3
 801233a:	493c      	ldr	r1, [pc, #240]	; (801242c <tcp_output_control_segment+0x10c>)
 801233c:	483c      	ldr	r0, [pc, #240]	; (8012430 <tcp_output_control_segment+0x110>)
 801233e:	f7ef ff51 	bl	80021e4 <app_debug_rtt_raw>

  netif = tcp_route(pcb, src, dst);
 8012342:	683a      	ldr	r2, [r7, #0]
 8012344:	6879      	ldr	r1, [r7, #4]
 8012346:	68fb      	ldr	r3, [r7, #12]
 8012348:	0018      	movs	r0, r3
 801234a:	f7fd fc7d 	bl	800fc48 <tcp_route>
 801234e:	0003      	movs	r3, r0
 8012350:	61bb      	str	r3, [r7, #24]
  if (netif == NULL) {
 8012352:	69bb      	ldr	r3, [r7, #24]
 8012354:	2b00      	cmp	r3, #0
 8012356:	d104      	bne.n	8012362 <tcp_output_control_segment+0x42>
    err = ERR_RTE;
 8012358:	231f      	movs	r3, #31
 801235a:	18fb      	adds	r3, r7, r3
 801235c:	22fc      	movs	r2, #252	; 0xfc
 801235e:	701a      	strb	r2, [r3, #0]
 8012360:	e055      	b.n	801240e <tcp_output_control_segment+0xee>
  } else {
    u8_t ttl, tos;
#if CHECKSUM_GEN_TCP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_TCP) {
      struct tcp_hdr *tcphdr = (struct tcp_hdr *)p->payload;
 8012362:	68bb      	ldr	r3, [r7, #8]
 8012364:	685b      	ldr	r3, [r3, #4]
 8012366:	617b      	str	r3, [r7, #20]
      tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
 8012368:	68bb      	ldr	r3, [r7, #8]
 801236a:	891a      	ldrh	r2, [r3, #8]
 801236c:	6879      	ldr	r1, [r7, #4]
 801236e:	68b8      	ldr	r0, [r7, #8]
 8012370:	683b      	ldr	r3, [r7, #0]
 8012372:	9300      	str	r3, [sp, #0]
 8012374:	000b      	movs	r3, r1
 8012376:	2106      	movs	r1, #6
 8012378:	f7f6 faeb 	bl	8008952 <ip_chksum_pseudo>
 801237c:	0003      	movs	r3, r0
 801237e:	001a      	movs	r2, r3
 8012380:	697b      	ldr	r3, [r7, #20]
 8012382:	21ff      	movs	r1, #255	; 0xff
 8012384:	4011      	ands	r1, r2
 8012386:	000c      	movs	r4, r1
 8012388:	7c19      	ldrb	r1, [r3, #16]
 801238a:	2000      	movs	r0, #0
 801238c:	4001      	ands	r1, r0
 801238e:	1c08      	adds	r0, r1, #0
 8012390:	1c21      	adds	r1, r4, #0
 8012392:	4301      	orrs	r1, r0
 8012394:	7419      	strb	r1, [r3, #16]
 8012396:	0a12      	lsrs	r2, r2, #8
 8012398:	b290      	uxth	r0, r2
 801239a:	7c5a      	ldrb	r2, [r3, #17]
 801239c:	2100      	movs	r1, #0
 801239e:	400a      	ands	r2, r1
 80123a0:	1c11      	adds	r1, r2, #0
 80123a2:	1c02      	adds	r2, r0, #0
 80123a4:	430a      	orrs	r2, r1
 80123a6:	745a      	strb	r2, [r3, #17]
                                        src, dst);
    }
#endif
    if (pcb != NULL) {
 80123a8:	68fb      	ldr	r3, [r7, #12]
 80123aa:	2b00      	cmp	r3, #0
 80123ac:	d00f      	beq.n	80123ce <tcp_output_control_segment+0xae>
      NETIF_SET_HINTS(netif, LWIP_CONST_CAST(struct netif_hint*, &(pcb->netif_hints)));
 80123ae:	68fb      	ldr	r3, [r7, #12]
 80123b0:	330c      	adds	r3, #12
 80123b2:	001a      	movs	r2, r3
 80123b4:	69bb      	ldr	r3, [r7, #24]
 80123b6:	639a      	str	r2, [r3, #56]	; 0x38
      ttl = pcb->ttl;
 80123b8:	231e      	movs	r3, #30
 80123ba:	18fb      	adds	r3, r7, r3
 80123bc:	68fa      	ldr	r2, [r7, #12]
 80123be:	7ad2      	ldrb	r2, [r2, #11]
 80123c0:	701a      	strb	r2, [r3, #0]
      tos = pcb->tos;
 80123c2:	231d      	movs	r3, #29
 80123c4:	18fb      	adds	r3, r7, r3
 80123c6:	68fa      	ldr	r2, [r7, #12]
 80123c8:	7a92      	ldrb	r2, [r2, #10]
 80123ca:	701a      	strb	r2, [r3, #0]
 80123cc:	e007      	b.n	80123de <tcp_output_control_segment+0xbe>
    } else {
      /* Send output with hardcoded TTL/HL since we have no access to the pcb */
      ttl = TCP_TTL;
 80123ce:	231e      	movs	r3, #30
 80123d0:	18fb      	adds	r3, r7, r3
 80123d2:	22ff      	movs	r2, #255	; 0xff
 80123d4:	701a      	strb	r2, [r3, #0]
      tos = 0;
 80123d6:	231d      	movs	r3, #29
 80123d8:	18fb      	adds	r3, r7, r3
 80123da:	2200      	movs	r2, #0
 80123dc:	701a      	strb	r2, [r3, #0]
    }
    TCP_STATS_INC(tcp.xmit);
    err = ip_output_if(p, src, dst, ttl, tos, IP_PROTO_TCP, netif);
 80123de:	231f      	movs	r3, #31
 80123e0:	18fc      	adds	r4, r7, r3
 80123e2:	231e      	movs	r3, #30
 80123e4:	18fb      	adds	r3, r7, r3
 80123e6:	781d      	ldrb	r5, [r3, #0]
 80123e8:	683a      	ldr	r2, [r7, #0]
 80123ea:	6879      	ldr	r1, [r7, #4]
 80123ec:	68b8      	ldr	r0, [r7, #8]
 80123ee:	69bb      	ldr	r3, [r7, #24]
 80123f0:	9302      	str	r3, [sp, #8]
 80123f2:	2306      	movs	r3, #6
 80123f4:	9301      	str	r3, [sp, #4]
 80123f6:	231d      	movs	r3, #29
 80123f8:	18fb      	adds	r3, r7, r3
 80123fa:	781b      	ldrb	r3, [r3, #0]
 80123fc:	9300      	str	r3, [sp, #0]
 80123fe:	002b      	movs	r3, r5
 8012400:	f001 fe5c 	bl	80140bc <ip4_output_if>
 8012404:	0003      	movs	r3, r0
 8012406:	7023      	strb	r3, [r4, #0]
    NETIF_RESET_HINTS(netif);
 8012408:	69bb      	ldr	r3, [r7, #24]
 801240a:	2200      	movs	r2, #0
 801240c:	639a      	str	r2, [r3, #56]	; 0x38
  }
  pbuf_free(p);
 801240e:	68bb      	ldr	r3, [r7, #8]
 8012410:	0018      	movs	r0, r3
 8012412:	f7f8 f863 	bl	800a4dc <pbuf_free>
  return err;
 8012416:	231f      	movs	r3, #31
 8012418:	18fb      	adds	r3, r7, r3
 801241a:	781b      	ldrb	r3, [r3, #0]
 801241c:	b25b      	sxtb	r3, r3
}
 801241e:	0018      	movs	r0, r3
 8012420:	46bd      	mov	sp, r7
 8012422:	b008      	add	sp, #32
 8012424:	bdb0      	pop	{r4, r5, r7, pc}
 8012426:	46c0      	nop			; (mov r8, r8)
 8012428:	08021684 	.word	0x08021684
 801242c:	08021edc 	.word	0x08021edc
 8012430:	080216d0 	.word	0x080216d0

08012434 <tcp_rst>:
 */
void
tcp_rst(const struct tcp_pcb *pcb, u32_t seqno, u32_t ackno,
        const ip_addr_t *local_ip, const ip_addr_t *remote_ip,
        u16_t local_port, u16_t remote_port)
{
 8012434:	b5b0      	push	{r4, r5, r7, lr}
 8012436:	b08a      	sub	sp, #40	; 0x28
 8012438:	af04      	add	r7, sp, #16
 801243a:	60f8      	str	r0, [r7, #12]
 801243c:	60b9      	str	r1, [r7, #8]
 801243e:	607a      	str	r2, [r7, #4]
 8012440:	603b      	str	r3, [r7, #0]
  struct pbuf *p;
  u16_t wnd;
  u8_t optlen;

  LWIP_ASSERT("tcp_rst: invalid local_ip", local_ip != NULL);
 8012442:	683b      	ldr	r3, [r7, #0]
 8012444:	2b00      	cmp	r3, #0
 8012446:	d105      	bne.n	8012454 <tcp_rst+0x20>
 8012448:	4b23      	ldr	r3, [pc, #140]	; (80124d8 <tcp_rst+0xa4>)
 801244a:	4a24      	ldr	r2, [pc, #144]	; (80124dc <tcp_rst+0xa8>)
 801244c:	4924      	ldr	r1, [pc, #144]	; (80124e0 <tcp_rst+0xac>)
 801244e:	4825      	ldr	r0, [pc, #148]	; (80124e4 <tcp_rst+0xb0>)
 8012450:	f7ef fec8 	bl	80021e4 <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_rst: invalid remote_ip", remote_ip != NULL);
 8012454:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012456:	2b00      	cmp	r3, #0
 8012458:	d105      	bne.n	8012466 <tcp_rst+0x32>
 801245a:	4b1f      	ldr	r3, [pc, #124]	; (80124d8 <tcp_rst+0xa4>)
 801245c:	4a22      	ldr	r2, [pc, #136]	; (80124e8 <tcp_rst+0xb4>)
 801245e:	4923      	ldr	r1, [pc, #140]	; (80124ec <tcp_rst+0xb8>)
 8012460:	4820      	ldr	r0, [pc, #128]	; (80124e4 <tcp_rst+0xb0>)
 8012462:	f7ef febf 	bl	80021e4 <app_debug_rtt_raw>

  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
 8012466:	2117      	movs	r1, #23
 8012468:	187b      	adds	r3, r7, r1
 801246a:	2200      	movs	r2, #0
 801246c:	701a      	strb	r2, [r3, #0]

#if LWIP_WND_SCALE
  wnd = PP_HTONS(((TCP_WND >> TCP_RCV_SCALE) & 0xFFFF));
#else
  wnd = PP_HTONS(TCP_WND);
 801246e:	2514      	movs	r5, #20
 8012470:	197b      	adds	r3, r7, r5
 8012472:	4a1f      	ldr	r2, [pc, #124]	; (80124f0 <tcp_rst+0xbc>)
 8012474:	801a      	strh	r2, [r3, #0]
#endif

  p = tcp_output_alloc_header_common(ackno, optlen, 0, lwip_htonl(seqno), local_port,
 8012476:	187b      	adds	r3, r7, r1
 8012478:	781b      	ldrb	r3, [r3, #0]
 801247a:	b29c      	uxth	r4, r3
 801247c:	68bb      	ldr	r3, [r7, #8]
 801247e:	0018      	movs	r0, r3
 8012480:	f7f4 ffd4 	bl	800742c <lwip_htonl>
 8012484:	0002      	movs	r2, r0
 8012486:	6878      	ldr	r0, [r7, #4]
 8012488:	197b      	adds	r3, r7, r5
 801248a:	881b      	ldrh	r3, [r3, #0]
 801248c:	9303      	str	r3, [sp, #12]
 801248e:	2314      	movs	r3, #20
 8012490:	9302      	str	r3, [sp, #8]
 8012492:	2330      	movs	r3, #48	; 0x30
 8012494:	18fb      	adds	r3, r7, r3
 8012496:	881b      	ldrh	r3, [r3, #0]
 8012498:	9301      	str	r3, [sp, #4]
 801249a:	232c      	movs	r3, #44	; 0x2c
 801249c:	18fb      	adds	r3, r7, r3
 801249e:	881b      	ldrh	r3, [r3, #0]
 80124a0:	9300      	str	r3, [sp, #0]
 80124a2:	0013      	movs	r3, r2
 80124a4:	2200      	movs	r2, #0
 80124a6:	0021      	movs	r1, r4
 80124a8:	f7ff fd86 	bl	8011fb8 <tcp_output_alloc_header_common>
 80124ac:	0003      	movs	r3, r0
 80124ae:	613b      	str	r3, [r7, #16]
    remote_port, TCP_RST | TCP_ACK, wnd);
  if (p == NULL) {
 80124b0:	693b      	ldr	r3, [r7, #16]
 80124b2:	2b00      	cmp	r3, #0
 80124b4:	d00c      	beq.n	80124d0 <tcp_rst+0x9c>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
    return;
  }
  tcp_output_fill_options(pcb, p, 0, 0);
 80124b6:	6939      	ldr	r1, [r7, #16]
 80124b8:	68f8      	ldr	r0, [r7, #12]
 80124ba:	2300      	movs	r3, #0
 80124bc:	2200      	movs	r2, #0
 80124be:	f7ff fee9 	bl	8012294 <tcp_output_fill_options>

  MIB2_STATS_INC(mib2.tcpoutrsts);

  tcp_output_control_segment(pcb, p, local_ip, remote_ip);
 80124c2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80124c4:	683a      	ldr	r2, [r7, #0]
 80124c6:	6939      	ldr	r1, [r7, #16]
 80124c8:	68f8      	ldr	r0, [r7, #12]
 80124ca:	f7ff ff29 	bl	8012320 <tcp_output_control_segment>
 80124ce:	e000      	b.n	80124d2 <tcp_rst+0x9e>
    return;
 80124d0:	46c0      	nop			; (mov r8, r8)
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
 80124d2:	46bd      	mov	sp, r7
 80124d4:	b006      	add	sp, #24
 80124d6:	bdb0      	pop	{r4, r5, r7, pc}
 80124d8:	08021684 	.word	0x08021684
 80124dc:	000007c5 	.word	0x000007c5
 80124e0:	08021f08 	.word	0x08021f08
 80124e4:	080216d0 	.word	0x080216d0
 80124e8:	000007c6 	.word	0x000007c6
 80124ec:	08021f24 	.word	0x08021f24
 80124f0:	00003004 	.word	0x00003004

080124f4 <tcp_send_empty_ack>:
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
 80124f4:	b5b0      	push	{r4, r5, r7, lr}
 80124f6:	b086      	sub	sp, #24
 80124f8:	af00      	add	r7, sp, #0
 80124fa:	6078      	str	r0, [r7, #4]
  err_t err;
  struct pbuf *p;
  u8_t optlen, optflags = 0;
 80124fc:	2317      	movs	r3, #23
 80124fe:	18fb      	adds	r3, r7, r3
 8012500:	2200      	movs	r2, #0
 8012502:	701a      	strb	r2, [r3, #0]
  u8_t num_sacks = 0;
 8012504:	2316      	movs	r3, #22
 8012506:	18fb      	adds	r3, r7, r3
 8012508:	2200      	movs	r2, #0
 801250a:	701a      	strb	r2, [r3, #0]

  LWIP_ASSERT("tcp_send_empty_ack: invalid pcb", pcb != NULL);
 801250c:	687b      	ldr	r3, [r7, #4]
 801250e:	2b00      	cmp	r3, #0
 8012510:	d105      	bne.n	801251e <tcp_send_empty_ack+0x2a>
 8012512:	4b2f      	ldr	r3, [pc, #188]	; (80125d0 <tcp_send_empty_ack+0xdc>)
 8012514:	4a2f      	ldr	r2, [pc, #188]	; (80125d4 <tcp_send_empty_ack+0xe0>)
 8012516:	4930      	ldr	r1, [pc, #192]	; (80125d8 <tcp_send_empty_ack+0xe4>)
 8012518:	4830      	ldr	r0, [pc, #192]	; (80125dc <tcp_send_empty_ack+0xe8>)
 801251a:	f7ef fe63 	bl	80021e4 <app_debug_rtt_raw>
#if LWIP_TCP_TIMESTAMPS
  if (pcb->flags & TF_TIMESTAMP) {
    optflags = TF_SEG_OPTS_TS;
  }
#endif
  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
 801251e:	2317      	movs	r3, #23
 8012520:	18fb      	adds	r3, r7, r3
 8012522:	781b      	ldrb	r3, [r3, #0]
 8012524:	009b      	lsls	r3, r3, #2
 8012526:	b2da      	uxtb	r2, r3
 8012528:	2015      	movs	r0, #21
 801252a:	183b      	adds	r3, r7, r0
 801252c:	2104      	movs	r1, #4
 801252e:	400a      	ands	r2, r1
 8012530:	701a      	strb	r2, [r3, #0]
  if ((num_sacks = tcp_get_num_sacks(pcb, optlen)) > 0) {
    optlen += 4 + num_sacks * 8; /* 4 bytes for header (including 2*NOP), plus 8B for each SACK */
  }
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, lwip_htonl(pcb->snd_nxt));
 8012532:	183b      	adds	r3, r7, r0
 8012534:	781b      	ldrb	r3, [r3, #0]
 8012536:	b29c      	uxth	r4, r3
 8012538:	687b      	ldr	r3, [r7, #4]
 801253a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801253c:	0018      	movs	r0, r3
 801253e:	f7f4 ff75 	bl	800742c <lwip_htonl>
 8012542:	0003      	movs	r3, r0
 8012544:	6878      	ldr	r0, [r7, #4]
 8012546:	2200      	movs	r2, #0
 8012548:	0021      	movs	r1, r4
 801254a:	f7ff fe57 	bl	80121fc <tcp_output_alloc_header>
 801254e:	0003      	movs	r3, r0
 8012550:	613b      	str	r3, [r7, #16]
  if (p == NULL) {
 8012552:	693b      	ldr	r3, [r7, #16]
 8012554:	2b00      	cmp	r3, #0
 8012556:	d109      	bne.n	801256c <tcp_send_empty_ack+0x78>
    /* let tcp_fasttmr retry sending this ACK */
    tcp_set_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 8012558:	687b      	ldr	r3, [r7, #4]
 801255a:	8bdb      	ldrh	r3, [r3, #30]
 801255c:	2203      	movs	r2, #3
 801255e:	4313      	orrs	r3, r2
 8012560:	b29a      	uxth	r2, r3
 8012562:	687b      	ldr	r3, [r7, #4]
 8012564:	83da      	strh	r2, [r3, #30]
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
 8012566:	2302      	movs	r3, #2
 8012568:	425b      	negs	r3, r3
 801256a:	e02d      	b.n	80125c8 <tcp_send_empty_ack+0xd4>
  }
  tcp_output_fill_options(pcb, p, optflags, num_sacks);
 801256c:	2316      	movs	r3, #22
 801256e:	18fb      	adds	r3, r7, r3
 8012570:	781c      	ldrb	r4, [r3, #0]
 8012572:	2317      	movs	r3, #23
 8012574:	18fb      	adds	r3, r7, r3
 8012576:	781a      	ldrb	r2, [r3, #0]
 8012578:	6939      	ldr	r1, [r7, #16]
 801257a:	6878      	ldr	r0, [r7, #4]
 801257c:	0023      	movs	r3, r4
 801257e:	f7ff fe89 	bl	8012294 <tcp_output_fill_options>
  pcb->ts_lastacksent = pcb->rcv_nxt;
#endif

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG,
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
 8012582:	687a      	ldr	r2, [r7, #4]
 8012584:	687b      	ldr	r3, [r7, #4]
 8012586:	3304      	adds	r3, #4
 8012588:	250f      	movs	r5, #15
 801258a:	197c      	adds	r4, r7, r5
 801258c:	6939      	ldr	r1, [r7, #16]
 801258e:	6878      	ldr	r0, [r7, #4]
 8012590:	f7ff fec6 	bl	8012320 <tcp_output_control_segment>
 8012594:	0003      	movs	r3, r0
 8012596:	7023      	strb	r3, [r4, #0]
  if (err != ERR_OK) {
 8012598:	197b      	adds	r3, r7, r5
 801259a:	781b      	ldrb	r3, [r3, #0]
 801259c:	b25b      	sxtb	r3, r3
 801259e:	2b00      	cmp	r3, #0
 80125a0:	d007      	beq.n	80125b2 <tcp_send_empty_ack+0xbe>
    /* let tcp_fasttmr retry sending this ACK */
    tcp_set_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 80125a2:	687b      	ldr	r3, [r7, #4]
 80125a4:	8bdb      	ldrh	r3, [r3, #30]
 80125a6:	2203      	movs	r2, #3
 80125a8:	4313      	orrs	r3, r2
 80125aa:	b29a      	uxth	r2, r3
 80125ac:	687b      	ldr	r3, [r7, #4]
 80125ae:	83da      	strh	r2, [r3, #30]
 80125b0:	e006      	b.n	80125c0 <tcp_send_empty_ack+0xcc>
  } else {
    /* remove ACK flags from the PCB, as we sent an empty ACK now */
    tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 80125b2:	687b      	ldr	r3, [r7, #4]
 80125b4:	8bdb      	ldrh	r3, [r3, #30]
 80125b6:	2203      	movs	r2, #3
 80125b8:	4393      	bics	r3, r2
 80125ba:	b29a      	uxth	r2, r3
 80125bc:	687b      	ldr	r3, [r7, #4]
 80125be:	83da      	strh	r2, [r3, #30]
  }

  return err;
 80125c0:	230f      	movs	r3, #15
 80125c2:	18fb      	adds	r3, r7, r3
 80125c4:	781b      	ldrb	r3, [r3, #0]
 80125c6:	b25b      	sxtb	r3, r3
}
 80125c8:	0018      	movs	r0, r3
 80125ca:	46bd      	mov	sp, r7
 80125cc:	b006      	add	sp, #24
 80125ce:	bdb0      	pop	{r4, r5, r7, pc}
 80125d0:	08021684 	.word	0x08021684
 80125d4:	000007eb 	.word	0x000007eb
 80125d8:	08021f40 	.word	0x08021f40
 80125dc:	080216d0 	.word	0x080216d0

080125e0 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
err_t
tcp_keepalive(struct tcp_pcb *pcb)
{
 80125e0:	b5b0      	push	{r4, r5, r7, lr}
 80125e2:	b084      	sub	sp, #16
 80125e4:	af00      	add	r7, sp, #0
 80125e6:	6078      	str	r0, [r7, #4]
  err_t err;
  struct pbuf *p;
  u8_t optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
 80125e8:	230a      	movs	r3, #10
 80125ea:	18fb      	adds	r3, r7, r3
 80125ec:	2200      	movs	r2, #0
 80125ee:	701a      	strb	r2, [r3, #0]

  LWIP_ASSERT("tcp_keepalive: invalid pcb", pcb != NULL);
 80125f0:	687b      	ldr	r3, [r7, #4]
 80125f2:	2b00      	cmp	r3, #0
 80125f4:	d105      	bne.n	8012602 <tcp_keepalive+0x22>
 80125f6:	4b1b      	ldr	r3, [pc, #108]	; (8012664 <tcp_keepalive+0x84>)
 80125f8:	4a1b      	ldr	r2, [pc, #108]	; (8012668 <tcp_keepalive+0x88>)
 80125fa:	491c      	ldr	r1, [pc, #112]	; (801266c <tcp_keepalive+0x8c>)
 80125fc:	481c      	ldr	r0, [pc, #112]	; (8012670 <tcp_keepalive+0x90>)
 80125fe:	f7ef fdf1 	bl	80021e4 <app_debug_rtt_raw>
  LWIP_DEBUGF(TCP_DEBUG, ("\n"));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
                          tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));

  p = tcp_output_alloc_header(pcb, optlen, 0, lwip_htonl(pcb->snd_nxt - 1));
 8012602:	230a      	movs	r3, #10
 8012604:	18fb      	adds	r3, r7, r3
 8012606:	781b      	ldrb	r3, [r3, #0]
 8012608:	b29c      	uxth	r4, r3
 801260a:	687b      	ldr	r3, [r7, #4]
 801260c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801260e:	3b01      	subs	r3, #1
 8012610:	0018      	movs	r0, r3
 8012612:	f7f4 ff0b 	bl	800742c <lwip_htonl>
 8012616:	0003      	movs	r3, r0
 8012618:	6878      	ldr	r0, [r7, #4]
 801261a:	2200      	movs	r2, #0
 801261c:	0021      	movs	r1, r4
 801261e:	f7ff fded 	bl	80121fc <tcp_output_alloc_header>
 8012622:	0003      	movs	r3, r0
 8012624:	60fb      	str	r3, [r7, #12]
  if (p == NULL) {
 8012626:	68fb      	ldr	r3, [r7, #12]
 8012628:	2b00      	cmp	r3, #0
 801262a:	d102      	bne.n	8012632 <tcp_keepalive+0x52>
    LWIP_DEBUGF(TCP_DEBUG,
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return ERR_MEM;
 801262c:	2301      	movs	r3, #1
 801262e:	425b      	negs	r3, r3
 8012630:	e013      	b.n	801265a <tcp_keepalive+0x7a>
  }
  tcp_output_fill_options(pcb, p, 0, 0);
 8012632:	68f9      	ldr	r1, [r7, #12]
 8012634:	6878      	ldr	r0, [r7, #4]
 8012636:	2300      	movs	r3, #0
 8012638:	2200      	movs	r2, #0
 801263a:	f7ff fe2b 	bl	8012294 <tcp_output_fill_options>
  err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
 801263e:	687a      	ldr	r2, [r7, #4]
 8012640:	687b      	ldr	r3, [r7, #4]
 8012642:	3304      	adds	r3, #4
 8012644:	250b      	movs	r5, #11
 8012646:	197c      	adds	r4, r7, r5
 8012648:	68f9      	ldr	r1, [r7, #12]
 801264a:	6878      	ldr	r0, [r7, #4]
 801264c:	f7ff fe68 	bl	8012320 <tcp_output_control_segment>
 8012650:	0003      	movs	r3, r0
 8012652:	7023      	strb	r3, [r4, #0]

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F" err %d.\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
  return err;
 8012654:	197b      	adds	r3, r7, r5
 8012656:	781b      	ldrb	r3, [r3, #0]
 8012658:	b25b      	sxtb	r3, r3
}
 801265a:	0018      	movs	r0, r3
 801265c:	46bd      	mov	sp, r7
 801265e:	b004      	add	sp, #16
 8012660:	bdb0      	pop	{r4, r5, r7, pc}
 8012662:	46c0      	nop			; (mov r8, r8)
 8012664:	08021684 	.word	0x08021684
 8012668:	00000825 	.word	0x00000825
 801266c:	08021f60 	.word	0x08021f60
 8012670:	080216d0 	.word	0x080216d0

08012674 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
err_t
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
 8012674:	b5b0      	push	{r4, r5, r7, lr}
 8012676:	b08a      	sub	sp, #40	; 0x28
 8012678:	af00      	add	r7, sp, #0
 801267a:	6078      	str	r0, [r7, #4]
  struct tcp_hdr *tcphdr;
  struct tcp_seg *seg;
  u16_t len;
  u8_t is_fin;
  u32_t snd_nxt;
  u8_t optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
 801267c:	2313      	movs	r3, #19
 801267e:	18fb      	adds	r3, r7, r3
 8012680:	2200      	movs	r2, #0
 8012682:	701a      	strb	r2, [r3, #0]

  LWIP_ASSERT("tcp_zero_window_probe: invalid pcb", pcb != NULL);
 8012684:	687b      	ldr	r3, [r7, #4]
 8012686:	2b00      	cmp	r3, #0
 8012688:	d106      	bne.n	8012698 <tcp_zero_window_probe+0x24>
 801268a:	4b68      	ldr	r3, [pc, #416]	; (801282c <tcp_zero_window_probe+0x1b8>)
 801268c:	2285      	movs	r2, #133	; 0x85
 801268e:	0112      	lsls	r2, r2, #4
 8012690:	4967      	ldr	r1, [pc, #412]	; (8012830 <tcp_zero_window_probe+0x1bc>)
 8012692:	4868      	ldr	r0, [pc, #416]	; (8012834 <tcp_zero_window_probe+0x1c0>)
 8012694:	f7ef fda6 	bl	80021e4 <app_debug_rtt_raw>
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
               tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));

  /* Only consider unsent, persist timer should be off when there is data in-flight */
  seg = pcb->unsent;
 8012698:	687b      	ldr	r3, [r7, #4]
 801269a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801269c:	627b      	str	r3, [r7, #36]	; 0x24
  if (seg == NULL) {
 801269e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80126a0:	2b00      	cmp	r3, #0
 80126a2:	d101      	bne.n	80126a8 <tcp_zero_window_probe+0x34>
    /* Not expected, persist timer should be off when the send buffer is empty */
    return ERR_OK;
 80126a4:	2300      	movs	r3, #0
 80126a6:	e0bc      	b.n	8012822 <tcp_zero_window_probe+0x1ae>

  /* increment probe count. NOTE: we record probe even if it fails
     to actually transmit due to an error. This ensures memory exhaustion/
     routing problem doesn't leave a zero-window pcb as an indefinite zombie.
     RTO mechanism has similar behavior, see pcb->nrtx */
  if (pcb->persist_probe < 0xFF) {
 80126a8:	687b      	ldr	r3, [r7, #4]
 80126aa:	22a6      	movs	r2, #166	; 0xa6
 80126ac:	5c9b      	ldrb	r3, [r3, r2]
 80126ae:	2bff      	cmp	r3, #255	; 0xff
 80126b0:	d007      	beq.n	80126c2 <tcp_zero_window_probe+0x4e>
    ++pcb->persist_probe;
 80126b2:	687b      	ldr	r3, [r7, #4]
 80126b4:	22a6      	movs	r2, #166	; 0xa6
 80126b6:	5c9b      	ldrb	r3, [r3, r2]
 80126b8:	3301      	adds	r3, #1
 80126ba:	b2d9      	uxtb	r1, r3
 80126bc:	687b      	ldr	r3, [r7, #4]
 80126be:	22a6      	movs	r2, #166	; 0xa6
 80126c0:	5499      	strb	r1, [r3, r2]
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 80126c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80126c4:	691b      	ldr	r3, [r3, #16]
 80126c6:	7b1a      	ldrb	r2, [r3, #12]
 80126c8:	7b5b      	ldrb	r3, [r3, #13]
 80126ca:	021b      	lsls	r3, r3, #8
 80126cc:	4313      	orrs	r3, r2
 80126ce:	b29b      	uxth	r3, r3
 80126d0:	0018      	movs	r0, r3
 80126d2:	f7f4 fe95 	bl	8007400 <lwip_htons>
 80126d6:	0003      	movs	r3, r0
 80126d8:	b2db      	uxtb	r3, r3
 80126da:	001a      	movs	r2, r3
 80126dc:	2301      	movs	r3, #1
 80126de:	4013      	ands	r3, r2
 80126e0:	d005      	beq.n	80126ee <tcp_zero_window_probe+0x7a>
 80126e2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80126e4:	891b      	ldrh	r3, [r3, #8]
 80126e6:	2b00      	cmp	r3, #0
 80126e8:	d101      	bne.n	80126ee <tcp_zero_window_probe+0x7a>
 80126ea:	2201      	movs	r2, #1
 80126ec:	e000      	b.n	80126f0 <tcp_zero_window_probe+0x7c>
 80126ee:	2200      	movs	r2, #0
 80126f0:	2123      	movs	r1, #35	; 0x23
 80126f2:	187b      	adds	r3, r7, r1
 80126f4:	701a      	strb	r2, [r3, #0]
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;
 80126f6:	187b      	adds	r3, r7, r1
 80126f8:	781b      	ldrb	r3, [r3, #0]
 80126fa:	425a      	negs	r2, r3
 80126fc:	4153      	adcs	r3, r2
 80126fe:	b2da      	uxtb	r2, r3
 8012700:	2020      	movs	r0, #32
 8012702:	183b      	adds	r3, r7, r0
 8012704:	801a      	strh	r2, [r3, #0]

  p = tcp_output_alloc_header(pcb, optlen, len, seg->tcphdr->seqno);
 8012706:	2313      	movs	r3, #19
 8012708:	18fb      	adds	r3, r7, r3
 801270a:	781b      	ldrb	r3, [r3, #0]
 801270c:	b29c      	uxth	r4, r3
 801270e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012710:	691b      	ldr	r3, [r3, #16]
 8012712:	791a      	ldrb	r2, [r3, #4]
 8012714:	7959      	ldrb	r1, [r3, #5]
 8012716:	0209      	lsls	r1, r1, #8
 8012718:	430a      	orrs	r2, r1
 801271a:	7999      	ldrb	r1, [r3, #6]
 801271c:	0409      	lsls	r1, r1, #16
 801271e:	430a      	orrs	r2, r1
 8012720:	79db      	ldrb	r3, [r3, #7]
 8012722:	061b      	lsls	r3, r3, #24
 8012724:	4313      	orrs	r3, r2
 8012726:	0019      	movs	r1, r3
 8012728:	183b      	adds	r3, r7, r0
 801272a:	881a      	ldrh	r2, [r3, #0]
 801272c:	6878      	ldr	r0, [r7, #4]
 801272e:	000b      	movs	r3, r1
 8012730:	0021      	movs	r1, r4
 8012732:	f7ff fd63 	bl	80121fc <tcp_output_alloc_header>
 8012736:	0003      	movs	r3, r0
 8012738:	61fb      	str	r3, [r7, #28]
  if (p == NULL) {
 801273a:	69fb      	ldr	r3, [r7, #28]
 801273c:	2b00      	cmp	r3, #0
 801273e:	d102      	bne.n	8012746 <tcp_zero_window_probe+0xd2>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return ERR_MEM;
 8012740:	2301      	movs	r3, #1
 8012742:	425b      	negs	r3, r3
 8012744:	e06d      	b.n	8012822 <tcp_zero_window_probe+0x1ae>
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 8012746:	69fb      	ldr	r3, [r7, #28]
 8012748:	685b      	ldr	r3, [r3, #4]
 801274a:	61bb      	str	r3, [r7, #24]

  if (is_fin) {
 801274c:	2323      	movs	r3, #35	; 0x23
 801274e:	18fb      	adds	r3, r7, r3
 8012750:	781b      	ldrb	r3, [r3, #0]
 8012752:	2b00      	cmp	r3, #0
 8012754:	d026      	beq.n	80127a4 <tcp_zero_window_probe+0x130>
    /* FIN segment, no data */
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
 8012756:	69bb      	ldr	r3, [r7, #24]
 8012758:	7b1a      	ldrb	r2, [r3, #12]
 801275a:	7b5b      	ldrb	r3, [r3, #13]
 801275c:	021b      	lsls	r3, r3, #8
 801275e:	4313      	orrs	r3, r2
 8012760:	b29b      	uxth	r3, r3
 8012762:	b21b      	sxth	r3, r3
 8012764:	4a34      	ldr	r2, [pc, #208]	; (8012838 <tcp_zero_window_probe+0x1c4>)
 8012766:	4013      	ands	r3, r2
 8012768:	b21c      	sxth	r4, r3
 801276a:	2011      	movs	r0, #17
 801276c:	f7f4 fe48 	bl	8007400 <lwip_htons>
 8012770:	0003      	movs	r3, r0
 8012772:	b21b      	sxth	r3, r3
 8012774:	4323      	orrs	r3, r4
 8012776:	b21b      	sxth	r3, r3
 8012778:	b29a      	uxth	r2, r3
 801277a:	69bb      	ldr	r3, [r7, #24]
 801277c:	21ff      	movs	r1, #255	; 0xff
 801277e:	4011      	ands	r1, r2
 8012780:	000c      	movs	r4, r1
 8012782:	7b19      	ldrb	r1, [r3, #12]
 8012784:	2000      	movs	r0, #0
 8012786:	4001      	ands	r1, r0
 8012788:	1c08      	adds	r0, r1, #0
 801278a:	1c21      	adds	r1, r4, #0
 801278c:	4301      	orrs	r1, r0
 801278e:	7319      	strb	r1, [r3, #12]
 8012790:	0a12      	lsrs	r2, r2, #8
 8012792:	b290      	uxth	r0, r2
 8012794:	7b5a      	ldrb	r2, [r3, #13]
 8012796:	2100      	movs	r1, #0
 8012798:	400a      	ands	r2, r1
 801279a:	1c11      	adds	r1, r2, #0
 801279c:	1c02      	adds	r2, r0, #0
 801279e:	430a      	orrs	r2, r1
 80127a0:	735a      	strb	r2, [r3, #13]
 80127a2:	e010      	b.n	80127c6 <tcp_zero_window_probe+0x152>
  } else {
    /* Data segment, copy in one byte from the head of the unacked queue */
    char *d = ((char *)p->payload + TCP_HLEN);
 80127a4:	69fb      	ldr	r3, [r7, #28]
 80127a6:	685b      	ldr	r3, [r3, #4]
 80127a8:	3314      	adds	r3, #20
 80127aa:	617b      	str	r3, [r7, #20]
    /* Depending on whether the segment has already been sent (unacked) or not
       (unsent), seg->p->payload points to the IP header or TCP header.
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
 80127ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80127ae:	6858      	ldr	r0, [r3, #4]
 80127b0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80127b2:	685b      	ldr	r3, [r3, #4]
 80127b4:	891a      	ldrh	r2, [r3, #8]
 80127b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80127b8:	891b      	ldrh	r3, [r3, #8]
 80127ba:	1ad3      	subs	r3, r2, r3
 80127bc:	b29b      	uxth	r3, r3
 80127be:	6979      	ldr	r1, [r7, #20]
 80127c0:	2201      	movs	r2, #1
 80127c2:	f7f8 f955 	bl	800aa70 <pbuf_copy_partial>
  }

  /* The byte may be acknowledged without the window being opened. */
  snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + 1;
 80127c6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80127c8:	691b      	ldr	r3, [r3, #16]
 80127ca:	791a      	ldrb	r2, [r3, #4]
 80127cc:	7959      	ldrb	r1, [r3, #5]
 80127ce:	0209      	lsls	r1, r1, #8
 80127d0:	430a      	orrs	r2, r1
 80127d2:	7999      	ldrb	r1, [r3, #6]
 80127d4:	0409      	lsls	r1, r1, #16
 80127d6:	430a      	orrs	r2, r1
 80127d8:	79db      	ldrb	r3, [r3, #7]
 80127da:	061b      	lsls	r3, r3, #24
 80127dc:	4313      	orrs	r3, r2
 80127de:	0018      	movs	r0, r3
 80127e0:	f7f4 fe24 	bl	800742c <lwip_htonl>
 80127e4:	0003      	movs	r3, r0
 80127e6:	3301      	adds	r3, #1
 80127e8:	60fb      	str	r3, [r7, #12]
  if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 80127ea:	687b      	ldr	r3, [r7, #4]
 80127ec:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80127ee:	68fb      	ldr	r3, [r7, #12]
 80127f0:	1ad3      	subs	r3, r2, r3
 80127f2:	d502      	bpl.n	80127fa <tcp_zero_window_probe+0x186>
    pcb->snd_nxt = snd_nxt;
 80127f4:	687b      	ldr	r3, [r7, #4]
 80127f6:	68fa      	ldr	r2, [r7, #12]
 80127f8:	655a      	str	r2, [r3, #84]	; 0x54
  }
  tcp_output_fill_options(pcb, p, 0, 0);
 80127fa:	69f9      	ldr	r1, [r7, #28]
 80127fc:	6878      	ldr	r0, [r7, #4]
 80127fe:	2300      	movs	r3, #0
 8012800:	2200      	movs	r2, #0
 8012802:	f7ff fd47 	bl	8012294 <tcp_output_fill_options>

  err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
 8012806:	687a      	ldr	r2, [r7, #4]
 8012808:	687b      	ldr	r3, [r7, #4]
 801280a:	3304      	adds	r3, #4
 801280c:	250b      	movs	r5, #11
 801280e:	197c      	adds	r4, r7, r5
 8012810:	69f9      	ldr	r1, [r7, #28]
 8012812:	6878      	ldr	r0, [r7, #4]
 8012814:	f7ff fd84 	bl	8012320 <tcp_output_control_segment>
 8012818:	0003      	movs	r3, r0
 801281a:	7023      	strb	r3, [r4, #0]

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F" err %d.\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
  return err;
 801281c:	197b      	adds	r3, r7, r5
 801281e:	781b      	ldrb	r3, [r3, #0]
 8012820:	b25b      	sxtb	r3, r3
}
 8012822:	0018      	movs	r0, r3
 8012824:	46bd      	mov	sp, r7
 8012826:	b00a      	add	sp, #40	; 0x28
 8012828:	bdb0      	pop	{r4, r5, r7, pc}
 801282a:	46c0      	nop			; (mov r8, r8)
 801282c:	08021684 	.word	0x08021684
 8012830:	08021f7c 	.word	0x08021f7c
 8012834:	080216d0 	.word	0x080216d0
 8012838:	ffffc0ff 	.word	0xffffc0ff

0801283c <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
 801283c:	b580      	push	{r7, lr}
 801283e:	b082      	sub	sp, #8
 8012840:	af00      	add	r7, sp, #0
 8012842:	6078      	str	r0, [r7, #4]
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
 8012844:	f7f8 fc24 	bl	800b090 <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
 8012848:	4b0b      	ldr	r3, [pc, #44]	; (8012878 <tcpip_tcp_timer+0x3c>)
 801284a:	681b      	ldr	r3, [r3, #0]
 801284c:	2b00      	cmp	r3, #0
 801284e:	d103      	bne.n	8012858 <tcpip_tcp_timer+0x1c>
 8012850:	4b0a      	ldr	r3, [pc, #40]	; (801287c <tcpip_tcp_timer+0x40>)
 8012852:	681b      	ldr	r3, [r3, #0]
 8012854:	2b00      	cmp	r3, #0
 8012856:	d007      	beq.n	8012868 <tcpip_tcp_timer+0x2c>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 8012858:	4909      	ldr	r1, [pc, #36]	; (8012880 <tcpip_tcp_timer+0x44>)
 801285a:	23fa      	movs	r3, #250	; 0xfa
 801285c:	005b      	lsls	r3, r3, #1
 801285e:	2200      	movs	r2, #0
 8012860:	0018      	movs	r0, r3
 8012862:	f000 f8ff 	bl	8012a64 <sys_timeout>
 8012866:	e003      	b.n	8012870 <tcpip_tcp_timer+0x34>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
 8012868:	4b06      	ldr	r3, [pc, #24]	; (8012884 <tcpip_tcp_timer+0x48>)
 801286a:	2200      	movs	r2, #0
 801286c:	601a      	str	r2, [r3, #0]
  }
}
 801286e:	46c0      	nop			; (mov r8, r8)
 8012870:	46c0      	nop			; (mov r8, r8)
 8012872:	46bd      	mov	sp, r7
 8012874:	b002      	add	sp, #8
 8012876:	bd80      	pop	{r7, pc}
 8012878:	2000278c 	.word	0x2000278c
 801287c:	2000279c 	.word	0x2000279c
 8012880:	0801283d 	.word	0x0801283d
 8012884:	20000c88 	.word	0x20000c88

08012888 <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
 8012888:	b580      	push	{r7, lr}
 801288a:	af00      	add	r7, sp, #0
  LWIP_ASSERT_CORE_LOCKED();

  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
 801288c:	4b0c      	ldr	r3, [pc, #48]	; (80128c0 <tcp_timer_needed+0x38>)
 801288e:	681b      	ldr	r3, [r3, #0]
 8012890:	2b00      	cmp	r3, #0
 8012892:	d111      	bne.n	80128b8 <tcp_timer_needed+0x30>
 8012894:	4b0b      	ldr	r3, [pc, #44]	; (80128c4 <tcp_timer_needed+0x3c>)
 8012896:	681b      	ldr	r3, [r3, #0]
 8012898:	2b00      	cmp	r3, #0
 801289a:	d103      	bne.n	80128a4 <tcp_timer_needed+0x1c>
 801289c:	4b0a      	ldr	r3, [pc, #40]	; (80128c8 <tcp_timer_needed+0x40>)
 801289e:	681b      	ldr	r3, [r3, #0]
 80128a0:	2b00      	cmp	r3, #0
 80128a2:	d009      	beq.n	80128b8 <tcp_timer_needed+0x30>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
 80128a4:	4b06      	ldr	r3, [pc, #24]	; (80128c0 <tcp_timer_needed+0x38>)
 80128a6:	2201      	movs	r2, #1
 80128a8:	601a      	str	r2, [r3, #0]
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 80128aa:	4908      	ldr	r1, [pc, #32]	; (80128cc <tcp_timer_needed+0x44>)
 80128ac:	23fa      	movs	r3, #250	; 0xfa
 80128ae:	005b      	lsls	r3, r3, #1
 80128b0:	2200      	movs	r2, #0
 80128b2:	0018      	movs	r0, r3
 80128b4:	f000 f8d6 	bl	8012a64 <sys_timeout>
  }
}
 80128b8:	46c0      	nop			; (mov r8, r8)
 80128ba:	46bd      	mov	sp, r7
 80128bc:	bd80      	pop	{r7, pc}
 80128be:	46c0      	nop			; (mov r8, r8)
 80128c0:	20000c88 	.word	0x20000c88
 80128c4:	2000278c 	.word	0x2000278c
 80128c8:	2000279c 	.word	0x2000279c
 80128cc:	0801283d 	.word	0x0801283d

080128d0 <sys_timeout_abs>:
#if LWIP_DEBUG_TIMERNAMES
sys_timeout_abs(u32_t abs_time, sys_timeout_handler handler, void *arg, const char *handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
sys_timeout_abs(u32_t abs_time, sys_timeout_handler handler, void *arg)
#endif
{
 80128d0:	b580      	push	{r7, lr}
 80128d2:	b086      	sub	sp, #24
 80128d4:	af00      	add	r7, sp, #0
 80128d6:	60f8      	str	r0, [r7, #12]
 80128d8:	60b9      	str	r1, [r7, #8]
 80128da:	607a      	str	r2, [r7, #4]
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
 80128dc:	2004      	movs	r0, #4
 80128de:	f7f6 fed9 	bl	8009694 <memp_malloc>
 80128e2:	0003      	movs	r3, r0
 80128e4:	613b      	str	r3, [r7, #16]
  if (timeout == NULL) {
 80128e6:	693b      	ldr	r3, [r7, #16]
 80128e8:	2b00      	cmp	r3, #0
 80128ea:	d109      	bne.n	8012900 <sys_timeout_abs+0x30>
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
 80128ec:	693b      	ldr	r3, [r7, #16]
 80128ee:	2b00      	cmp	r3, #0
 80128f0:	d153      	bne.n	801299a <sys_timeout_abs+0xca>
 80128f2:	4b2c      	ldr	r3, [pc, #176]	; (80129a4 <sys_timeout_abs+0xd4>)
 80128f4:	492c      	ldr	r1, [pc, #176]	; (80129a8 <sys_timeout_abs+0xd8>)
 80128f6:	482d      	ldr	r0, [pc, #180]	; (80129ac <sys_timeout_abs+0xdc>)
 80128f8:	22be      	movs	r2, #190	; 0xbe
 80128fa:	f7ef fc73 	bl	80021e4 <app_debug_rtt_raw>
    return;
 80128fe:	e04c      	b.n	801299a <sys_timeout_abs+0xca>
  }

  timeout->next = NULL;
 8012900:	693b      	ldr	r3, [r7, #16]
 8012902:	2200      	movs	r2, #0
 8012904:	601a      	str	r2, [r3, #0]
  timeout->h = handler;
 8012906:	693b      	ldr	r3, [r7, #16]
 8012908:	68ba      	ldr	r2, [r7, #8]
 801290a:	609a      	str	r2, [r3, #8]
  timeout->arg = arg;
 801290c:	693b      	ldr	r3, [r7, #16]
 801290e:	687a      	ldr	r2, [r7, #4]
 8012910:	60da      	str	r2, [r3, #12]
  timeout->time = abs_time;
 8012912:	693b      	ldr	r3, [r7, #16]
 8012914:	68fa      	ldr	r2, [r7, #12]
 8012916:	605a      	str	r2, [r3, #4]
  timeout->handler_name = handler_name;
  LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p abs_time=%"U32_F" handler=%s arg=%p\n",
                             (void *)timeout, abs_time, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

  if (next_timeout == NULL) {
 8012918:	4b25      	ldr	r3, [pc, #148]	; (80129b0 <sys_timeout_abs+0xe0>)
 801291a:	681b      	ldr	r3, [r3, #0]
 801291c:	2b00      	cmp	r3, #0
 801291e:	d103      	bne.n	8012928 <sys_timeout_abs+0x58>
    next_timeout = timeout;
 8012920:	4b23      	ldr	r3, [pc, #140]	; (80129b0 <sys_timeout_abs+0xe0>)
 8012922:	693a      	ldr	r2, [r7, #16]
 8012924:	601a      	str	r2, [r3, #0]
    return;
 8012926:	e039      	b.n	801299c <sys_timeout_abs+0xcc>
  }
  if (TIME_LESS_THAN(timeout->time, next_timeout->time)) {
 8012928:	693b      	ldr	r3, [r7, #16]
 801292a:	685a      	ldr	r2, [r3, #4]
 801292c:	4b20      	ldr	r3, [pc, #128]	; (80129b0 <sys_timeout_abs+0xe0>)
 801292e:	681b      	ldr	r3, [r3, #0]
 8012930:	685b      	ldr	r3, [r3, #4]
 8012932:	1ad3      	subs	r3, r2, r3
 8012934:	0fdb      	lsrs	r3, r3, #31
 8012936:	1c1a      	adds	r2, r3, #0
 8012938:	2301      	movs	r3, #1
 801293a:	4013      	ands	r3, r2
 801293c:	b2db      	uxtb	r3, r3
 801293e:	2b00      	cmp	r3, #0
 8012940:	d007      	beq.n	8012952 <sys_timeout_abs+0x82>
    timeout->next = next_timeout;
 8012942:	4b1b      	ldr	r3, [pc, #108]	; (80129b0 <sys_timeout_abs+0xe0>)
 8012944:	681a      	ldr	r2, [r3, #0]
 8012946:	693b      	ldr	r3, [r7, #16]
 8012948:	601a      	str	r2, [r3, #0]
    next_timeout = timeout;
 801294a:	4b19      	ldr	r3, [pc, #100]	; (80129b0 <sys_timeout_abs+0xe0>)
 801294c:	693a      	ldr	r2, [r7, #16]
 801294e:	601a      	str	r2, [r3, #0]
 8012950:	e024      	b.n	801299c <sys_timeout_abs+0xcc>
  } else {
    for (t = next_timeout; t != NULL; t = t->next) {
 8012952:	4b17      	ldr	r3, [pc, #92]	; (80129b0 <sys_timeout_abs+0xe0>)
 8012954:	681b      	ldr	r3, [r3, #0]
 8012956:	617b      	str	r3, [r7, #20]
 8012958:	e01b      	b.n	8012992 <sys_timeout_abs+0xc2>
      if ((t->next == NULL) || TIME_LESS_THAN(timeout->time, t->next->time)) {
 801295a:	697b      	ldr	r3, [r7, #20]
 801295c:	681b      	ldr	r3, [r3, #0]
 801295e:	2b00      	cmp	r3, #0
 8012960:	d00c      	beq.n	801297c <sys_timeout_abs+0xac>
 8012962:	693b      	ldr	r3, [r7, #16]
 8012964:	685a      	ldr	r2, [r3, #4]
 8012966:	697b      	ldr	r3, [r7, #20]
 8012968:	681b      	ldr	r3, [r3, #0]
 801296a:	685b      	ldr	r3, [r3, #4]
 801296c:	1ad3      	subs	r3, r2, r3
 801296e:	0fdb      	lsrs	r3, r3, #31
 8012970:	1c1a      	adds	r2, r3, #0
 8012972:	2301      	movs	r3, #1
 8012974:	4013      	ands	r3, r2
 8012976:	b2db      	uxtb	r3, r3
 8012978:	2b00      	cmp	r3, #0
 801297a:	d007      	beq.n	801298c <sys_timeout_abs+0xbc>
        timeout->next = t->next;
 801297c:	697b      	ldr	r3, [r7, #20]
 801297e:	681a      	ldr	r2, [r3, #0]
 8012980:	693b      	ldr	r3, [r7, #16]
 8012982:	601a      	str	r2, [r3, #0]
        t->next = timeout;
 8012984:	697b      	ldr	r3, [r7, #20]
 8012986:	693a      	ldr	r2, [r7, #16]
 8012988:	601a      	str	r2, [r3, #0]
        break;
 801298a:	e007      	b.n	801299c <sys_timeout_abs+0xcc>
    for (t = next_timeout; t != NULL; t = t->next) {
 801298c:	697b      	ldr	r3, [r7, #20]
 801298e:	681b      	ldr	r3, [r3, #0]
 8012990:	617b      	str	r3, [r7, #20]
 8012992:	697b      	ldr	r3, [r7, #20]
 8012994:	2b00      	cmp	r3, #0
 8012996:	d1e0      	bne.n	801295a <sys_timeout_abs+0x8a>
 8012998:	e000      	b.n	801299c <sys_timeout_abs+0xcc>
    return;
 801299a:	46c0      	nop			; (mov r8, r8)
      }
    }
  }
}
 801299c:	46bd      	mov	sp, r7
 801299e:	b006      	add	sp, #24
 80129a0:	bd80      	pop	{r7, pc}
 80129a2:	46c0      	nop			; (mov r8, r8)
 80129a4:	08021fa0 	.word	0x08021fa0
 80129a8:	08021fcc 	.word	0x08021fcc
 80129ac:	0802200c 	.word	0x0802200c
 80129b0:	20000c80 	.word	0x20000c80

080129b4 <lwip_cyclic_timer>:
#if !LWIP_TESTMODE
static
#endif
void
lwip_cyclic_timer(void *arg)
{
 80129b4:	b580      	push	{r7, lr}
 80129b6:	b086      	sub	sp, #24
 80129b8:	af00      	add	r7, sp, #0
 80129ba:	6078      	str	r0, [r7, #4]
  u32_t now;
  u32_t next_timeout_time;
  const struct lwip_cyclic_timer *cyclic = (const struct lwip_cyclic_timer *)arg;
 80129bc:	687b      	ldr	r3, [r7, #4]
 80129be:	617b      	str	r3, [r7, #20]

#if LWIP_DEBUG_TIMERNAMES
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: %s()\n", cyclic->handler_name));
#endif
  cyclic->handler();
 80129c0:	697b      	ldr	r3, [r7, #20]
 80129c2:	685b      	ldr	r3, [r3, #4]
 80129c4:	4798      	blx	r3

  now = sys_now();
 80129c6:	f00b fa9d 	bl	801df04 <sys_now>
 80129ca:	0003      	movs	r3, r0
 80129cc:	613b      	str	r3, [r7, #16]
  next_timeout_time = (u32_t)(current_timeout_due_time + cyclic->interval_ms);  /* overflow handled by TIME_LESS_THAN macro */ 
 80129ce:	697b      	ldr	r3, [r7, #20]
 80129d0:	681a      	ldr	r2, [r3, #0]
 80129d2:	4b11      	ldr	r3, [pc, #68]	; (8012a18 <lwip_cyclic_timer+0x64>)
 80129d4:	681b      	ldr	r3, [r3, #0]
 80129d6:	18d3      	adds	r3, r2, r3
 80129d8:	60fb      	str	r3, [r7, #12]
  if (TIME_LESS_THAN(next_timeout_time, now)) {
 80129da:	68fa      	ldr	r2, [r7, #12]
 80129dc:	693b      	ldr	r3, [r7, #16]
 80129de:	1ad3      	subs	r3, r2, r3
 80129e0:	0fdb      	lsrs	r3, r3, #31
 80129e2:	1c1a      	adds	r2, r3, #0
 80129e4:	2301      	movs	r3, #1
 80129e6:	4013      	ands	r3, r2
 80129e8:	b2db      	uxtb	r3, r3
 80129ea:	2b00      	cmp	r3, #0
 80129ec:	d009      	beq.n	8012a02 <lwip_cyclic_timer+0x4e>
    /* timer would immediately expire again -> "overload" -> restart without any correction */
#if LWIP_DEBUG_TIMERNAMES
    sys_timeout_abs((u32_t)(now + cyclic->interval_ms), lwip_cyclic_timer, arg, cyclic->handler_name);
#else
    sys_timeout_abs((u32_t)(now + cyclic->interval_ms), lwip_cyclic_timer, arg);
 80129ee:	697b      	ldr	r3, [r7, #20]
 80129f0:	681a      	ldr	r2, [r3, #0]
 80129f2:	693b      	ldr	r3, [r7, #16]
 80129f4:	18d3      	adds	r3, r2, r3
 80129f6:	687a      	ldr	r2, [r7, #4]
 80129f8:	4908      	ldr	r1, [pc, #32]	; (8012a1c <lwip_cyclic_timer+0x68>)
 80129fa:	0018      	movs	r0, r3
 80129fc:	f7ff ff68 	bl	80128d0 <sys_timeout_abs>
    sys_timeout_abs(next_timeout_time, lwip_cyclic_timer, arg, cyclic->handler_name);
#else
    sys_timeout_abs(next_timeout_time, lwip_cyclic_timer, arg);
#endif
  }
}
 8012a00:	e005      	b.n	8012a0e <lwip_cyclic_timer+0x5a>
    sys_timeout_abs(next_timeout_time, lwip_cyclic_timer, arg);
 8012a02:	687a      	ldr	r2, [r7, #4]
 8012a04:	4905      	ldr	r1, [pc, #20]	; (8012a1c <lwip_cyclic_timer+0x68>)
 8012a06:	68fb      	ldr	r3, [r7, #12]
 8012a08:	0018      	movs	r0, r3
 8012a0a:	f7ff ff61 	bl	80128d0 <sys_timeout_abs>
}
 8012a0e:	46c0      	nop			; (mov r8, r8)
 8012a10:	46bd      	mov	sp, r7
 8012a12:	b006      	add	sp, #24
 8012a14:	bd80      	pop	{r7, pc}
 8012a16:	46c0      	nop			; (mov r8, r8)
 8012a18:	20000c84 	.word	0x20000c84
 8012a1c:	080129b5 	.word	0x080129b5

08012a20 <sys_timeouts_init>:

/** Initialize this module */
void sys_timeouts_init(void)
{
 8012a20:	b580      	push	{r7, lr}
 8012a22:	b082      	sub	sp, #8
 8012a24:	af00      	add	r7, sp, #0
  size_t i;
  /* tcp_tmr() at index 0 is started on demand */
  for (i = (LWIP_TCP ? 1 : 0); i < LWIP_ARRAYSIZE(lwip_cyclic_timers); i++) {
 8012a26:	2301      	movs	r3, #1
 8012a28:	607b      	str	r3, [r7, #4]
 8012a2a:	e00e      	b.n	8012a4a <sys_timeouts_init+0x2a>
    /* we have to cast via size_t to get rid of const warning
      (this is OK as cyclic_timer() casts back to const* */
    sys_timeout(lwip_cyclic_timers[i].interval_ms, lwip_cyclic_timer, LWIP_CONST_CAST(void *, &lwip_cyclic_timers[i]));
 8012a2c:	4b0b      	ldr	r3, [pc, #44]	; (8012a5c <sys_timeouts_init+0x3c>)
 8012a2e:	687a      	ldr	r2, [r7, #4]
 8012a30:	00d2      	lsls	r2, r2, #3
 8012a32:	58d0      	ldr	r0, [r2, r3]
 8012a34:	687b      	ldr	r3, [r7, #4]
 8012a36:	00da      	lsls	r2, r3, #3
 8012a38:	4b08      	ldr	r3, [pc, #32]	; (8012a5c <sys_timeouts_init+0x3c>)
 8012a3a:	18d2      	adds	r2, r2, r3
 8012a3c:	4b08      	ldr	r3, [pc, #32]	; (8012a60 <sys_timeouts_init+0x40>)
 8012a3e:	0019      	movs	r1, r3
 8012a40:	f000 f810 	bl	8012a64 <sys_timeout>
  for (i = (LWIP_TCP ? 1 : 0); i < LWIP_ARRAYSIZE(lwip_cyclic_timers); i++) {
 8012a44:	687b      	ldr	r3, [r7, #4]
 8012a46:	3301      	adds	r3, #1
 8012a48:	607b      	str	r3, [r7, #4]
 8012a4a:	687b      	ldr	r3, [r7, #4]
 8012a4c:	2b01      	cmp	r3, #1
 8012a4e:	d9ed      	bls.n	8012a2c <sys_timeouts_init+0xc>
  }
}
 8012a50:	46c0      	nop			; (mov r8, r8)
 8012a52:	46c0      	nop			; (mov r8, r8)
 8012a54:	46bd      	mov	sp, r7
 8012a56:	b002      	add	sp, #8
 8012a58:	bd80      	pop	{r7, pc}
 8012a5a:	46c0      	nop			; (mov r8, r8)
 8012a5c:	08023a7c 	.word	0x08023a7c
 8012a60:	080129b5 	.word	0x080129b5

08012a64 <sys_timeout>:
sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char *handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
void
sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
 8012a64:	b580      	push	{r7, lr}
 8012a66:	b086      	sub	sp, #24
 8012a68:	af00      	add	r7, sp, #0
 8012a6a:	60f8      	str	r0, [r7, #12]
 8012a6c:	60b9      	str	r1, [r7, #8]
 8012a6e:	607a      	str	r2, [r7, #4]
  u32_t next_timeout_time;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ASSERT("Timeout time too long, max is LWIP_UINT32_MAX/4 msecs", msecs <= (LWIP_UINT32_MAX / 4));
 8012a70:	68fa      	ldr	r2, [r7, #12]
 8012a72:	2380      	movs	r3, #128	; 0x80
 8012a74:	05db      	lsls	r3, r3, #23
 8012a76:	429a      	cmp	r2, r3
 8012a78:	d306      	bcc.n	8012a88 <sys_timeout+0x24>
 8012a7a:	4b0b      	ldr	r3, [pc, #44]	; (8012aa8 <sys_timeout+0x44>)
 8012a7c:	222a      	movs	r2, #42	; 0x2a
 8012a7e:	32ff      	adds	r2, #255	; 0xff
 8012a80:	490a      	ldr	r1, [pc, #40]	; (8012aac <sys_timeout+0x48>)
 8012a82:	480b      	ldr	r0, [pc, #44]	; (8012ab0 <sys_timeout+0x4c>)
 8012a84:	f7ef fbae 	bl	80021e4 <app_debug_rtt_raw>

  next_timeout_time = (u32_t)(sys_now() + msecs); /* overflow handled by TIME_LESS_THAN macro */ 
 8012a88:	f00b fa3c 	bl	801df04 <sys_now>
 8012a8c:	0002      	movs	r2, r0
 8012a8e:	68fb      	ldr	r3, [r7, #12]
 8012a90:	189b      	adds	r3, r3, r2
 8012a92:	617b      	str	r3, [r7, #20]

#if LWIP_DEBUG_TIMERNAMES
  sys_timeout_abs(next_timeout_time, handler, arg, handler_name);
#else
  sys_timeout_abs(next_timeout_time, handler, arg);
 8012a94:	687a      	ldr	r2, [r7, #4]
 8012a96:	68b9      	ldr	r1, [r7, #8]
 8012a98:	697b      	ldr	r3, [r7, #20]
 8012a9a:	0018      	movs	r0, r3
 8012a9c:	f7ff ff18 	bl	80128d0 <sys_timeout_abs>
#endif
}
 8012aa0:	46c0      	nop			; (mov r8, r8)
 8012aa2:	46bd      	mov	sp, r7
 8012aa4:	b006      	add	sp, #24
 8012aa6:	bd80      	pop	{r7, pc}
 8012aa8:	08021fa0 	.word	0x08021fa0
 8012aac:	08022038 	.word	0x08022038
 8012ab0:	0802200c 	.word	0x0802200c

08012ab4 <sys_untimeout>:
 * @param handler callback function that would be called by the timeout
 * @param arg callback argument that would be passed to handler
*/
void
sys_untimeout(sys_timeout_handler handler, void *arg)
{
 8012ab4:	b580      	push	{r7, lr}
 8012ab6:	b084      	sub	sp, #16
 8012ab8:	af00      	add	r7, sp, #0
 8012aba:	6078      	str	r0, [r7, #4]
 8012abc:	6039      	str	r1, [r7, #0]
  struct sys_timeo *prev_t, *t;

  LWIP_ASSERT_CORE_LOCKED();

  if (next_timeout == NULL) {
 8012abe:	4b19      	ldr	r3, [pc, #100]	; (8012b24 <sys_untimeout+0x70>)
 8012ac0:	681b      	ldr	r3, [r3, #0]
 8012ac2:	2b00      	cmp	r3, #0
 8012ac4:	d02a      	beq.n	8012b1c <sys_untimeout+0x68>
    return;
  }

  for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
 8012ac6:	4b17      	ldr	r3, [pc, #92]	; (8012b24 <sys_untimeout+0x70>)
 8012ac8:	681b      	ldr	r3, [r3, #0]
 8012aca:	60bb      	str	r3, [r7, #8]
 8012acc:	2300      	movs	r3, #0
 8012ace:	60fb      	str	r3, [r7, #12]
 8012ad0:	e020      	b.n	8012b14 <sys_untimeout+0x60>
    if ((t->h == handler) && (t->arg == arg)) {
 8012ad2:	68bb      	ldr	r3, [r7, #8]
 8012ad4:	689b      	ldr	r3, [r3, #8]
 8012ad6:	687a      	ldr	r2, [r7, #4]
 8012ad8:	429a      	cmp	r2, r3
 8012ada:	d116      	bne.n	8012b0a <sys_untimeout+0x56>
 8012adc:	68bb      	ldr	r3, [r7, #8]
 8012ade:	68db      	ldr	r3, [r3, #12]
 8012ae0:	683a      	ldr	r2, [r7, #0]
 8012ae2:	429a      	cmp	r2, r3
 8012ae4:	d111      	bne.n	8012b0a <sys_untimeout+0x56>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL) {
 8012ae6:	68fb      	ldr	r3, [r7, #12]
 8012ae8:	2b00      	cmp	r3, #0
 8012aea:	d104      	bne.n	8012af6 <sys_untimeout+0x42>
        next_timeout = t->next;
 8012aec:	68bb      	ldr	r3, [r7, #8]
 8012aee:	681a      	ldr	r2, [r3, #0]
 8012af0:	4b0c      	ldr	r3, [pc, #48]	; (8012b24 <sys_untimeout+0x70>)
 8012af2:	601a      	str	r2, [r3, #0]
 8012af4:	e003      	b.n	8012afe <sys_untimeout+0x4a>
      } else {
        prev_t->next = t->next;
 8012af6:	68bb      	ldr	r3, [r7, #8]
 8012af8:	681a      	ldr	r2, [r3, #0]
 8012afa:	68fb      	ldr	r3, [r7, #12]
 8012afc:	601a      	str	r2, [r3, #0]
      }
      memp_free(MEMP_SYS_TIMEOUT, t);
 8012afe:	68bb      	ldr	r3, [r7, #8]
 8012b00:	0019      	movs	r1, r3
 8012b02:	2004      	movs	r0, #4
 8012b04:	f7f6 fe36 	bl	8009774 <memp_free>
      return;
 8012b08:	e009      	b.n	8012b1e <sys_untimeout+0x6a>
  for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
 8012b0a:	68bb      	ldr	r3, [r7, #8]
 8012b0c:	60fb      	str	r3, [r7, #12]
 8012b0e:	68bb      	ldr	r3, [r7, #8]
 8012b10:	681b      	ldr	r3, [r3, #0]
 8012b12:	60bb      	str	r3, [r7, #8]
 8012b14:	68bb      	ldr	r3, [r7, #8]
 8012b16:	2b00      	cmp	r3, #0
 8012b18:	d1db      	bne.n	8012ad2 <sys_untimeout+0x1e>
    }
  }
  return;
 8012b1a:	e000      	b.n	8012b1e <sys_untimeout+0x6a>
    return;
 8012b1c:	46c0      	nop			; (mov r8, r8)
}
 8012b1e:	46bd      	mov	sp, r7
 8012b20:	b004      	add	sp, #16
 8012b22:	bd80      	pop	{r7, pc}
 8012b24:	20000c80 	.word	0x20000c80

08012b28 <sys_check_timeouts>:
 *
 * Must be called periodically from your main loop.
 */
void
sys_check_timeouts(void)
{
 8012b28:	b580      	push	{r7, lr}
 8012b2a:	b084      	sub	sp, #16
 8012b2c:	af00      	add	r7, sp, #0
  u32_t now;

  LWIP_ASSERT_CORE_LOCKED();

  /* Process only timers expired at the start of the function. */
  now = sys_now();
 8012b2e:	f00b f9e9 	bl	801df04 <sys_now>
 8012b32:	0003      	movs	r3, r0
 8012b34:	60fb      	str	r3, [r7, #12]
  do {
    struct sys_timeo *tmptimeout;
    sys_timeout_handler handler;
    void *arg;

    PBUF_CHECK_FREE_OOSEQ();
 8012b36:	4b1c      	ldr	r3, [pc, #112]	; (8012ba8 <sys_check_timeouts+0x80>)
 8012b38:	781b      	ldrb	r3, [r3, #0]
 8012b3a:	b2db      	uxtb	r3, r3
 8012b3c:	2b00      	cmp	r3, #0
 8012b3e:	d001      	beq.n	8012b44 <sys_check_timeouts+0x1c>
 8012b40:	f7f7 f93e 	bl	8009dc0 <pbuf_free_ooseq>

    tmptimeout = next_timeout;
 8012b44:	4b19      	ldr	r3, [pc, #100]	; (8012bac <sys_check_timeouts+0x84>)
 8012b46:	681b      	ldr	r3, [r3, #0]
 8012b48:	60bb      	str	r3, [r7, #8]
    if (tmptimeout == NULL) {
 8012b4a:	68bb      	ldr	r3, [r7, #8]
 8012b4c:	2b00      	cmp	r3, #0
 8012b4e:	d025      	beq.n	8012b9c <sys_check_timeouts+0x74>
      return;
    }

    if (TIME_LESS_THAN(now, tmptimeout->time)) {
 8012b50:	68bb      	ldr	r3, [r7, #8]
 8012b52:	685b      	ldr	r3, [r3, #4]
 8012b54:	68fa      	ldr	r2, [r7, #12]
 8012b56:	1ad3      	subs	r3, r2, r3
 8012b58:	0fdb      	lsrs	r3, r3, #31
 8012b5a:	1c1a      	adds	r2, r3, #0
 8012b5c:	2301      	movs	r3, #1
 8012b5e:	4013      	ands	r3, r2
 8012b60:	b2db      	uxtb	r3, r3
 8012b62:	2b00      	cmp	r3, #0
 8012b64:	d11c      	bne.n	8012ba0 <sys_check_timeouts+0x78>
      return;
    }

    /* Timeout has expired */
    next_timeout = tmptimeout->next;
 8012b66:	68bb      	ldr	r3, [r7, #8]
 8012b68:	681a      	ldr	r2, [r3, #0]
 8012b6a:	4b10      	ldr	r3, [pc, #64]	; (8012bac <sys_check_timeouts+0x84>)
 8012b6c:	601a      	str	r2, [r3, #0]
    handler = tmptimeout->h;
 8012b6e:	68bb      	ldr	r3, [r7, #8]
 8012b70:	689b      	ldr	r3, [r3, #8]
 8012b72:	607b      	str	r3, [r7, #4]
    arg = tmptimeout->arg;
 8012b74:	68bb      	ldr	r3, [r7, #8]
 8012b76:	68db      	ldr	r3, [r3, #12]
 8012b78:	603b      	str	r3, [r7, #0]
    current_timeout_due_time = tmptimeout->time;
 8012b7a:	68bb      	ldr	r3, [r7, #8]
 8012b7c:	685a      	ldr	r2, [r3, #4]
 8012b7e:	4b0c      	ldr	r3, [pc, #48]	; (8012bb0 <sys_check_timeouts+0x88>)
 8012b80:	601a      	str	r2, [r3, #0]
    if (handler != NULL) {
      LWIP_DEBUGF(TIMERS_DEBUG, ("sct calling h=%s t=%"U32_F" arg=%p\n",
                                 tmptimeout->handler_name, sys_now() - tmptimeout->time, arg));
    }
#endif /* LWIP_DEBUG_TIMERNAMES */
    memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
 8012b82:	68bb      	ldr	r3, [r7, #8]
 8012b84:	0019      	movs	r1, r3
 8012b86:	2004      	movs	r0, #4
 8012b88:	f7f6 fdf4 	bl	8009774 <memp_free>
    if (handler != NULL) {
 8012b8c:	687b      	ldr	r3, [r7, #4]
 8012b8e:	2b00      	cmp	r3, #0
 8012b90:	d0d1      	beq.n	8012b36 <sys_check_timeouts+0xe>
      handler(arg);
 8012b92:	683a      	ldr	r2, [r7, #0]
 8012b94:	687b      	ldr	r3, [r7, #4]
 8012b96:	0010      	movs	r0, r2
 8012b98:	4798      	blx	r3
  do {
 8012b9a:	e7cc      	b.n	8012b36 <sys_check_timeouts+0xe>
      return;
 8012b9c:	46c0      	nop			; (mov r8, r8)
 8012b9e:	e000      	b.n	8012ba2 <sys_check_timeouts+0x7a>
      return;
 8012ba0:	46c0      	nop			; (mov r8, r8)
    }
    LWIP_TCPIP_THREAD_ALIVE();

    /* Repeat until all expired timers have been called */
  } while (1);
}
 8012ba2:	46bd      	mov	sp, r7
 8012ba4:	b004      	add	sp, #16
 8012ba6:	bd80      	pop	{r7, pc}
 8012ba8:	20002784 	.word	0x20002784
 8012bac:	20000c80 	.word	0x20000c80
 8012bb0:	20000c84 	.word	0x20000c84

08012bb4 <udp_init>:
/**
 * Initialize this module.
 */
void
udp_init(void)
{
 8012bb4:	b580      	push	{r7, lr}
 8012bb6:	af00      	add	r7, sp, #0
#ifdef LWIP_RAND
  udp_port = UDP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
 8012bb8:	f00b f992 	bl	801dee0 <sys_rand>
 8012bbc:	0003      	movs	r3, r0
 8012bbe:	b29b      	uxth	r3, r3
 8012bc0:	049b      	lsls	r3, r3, #18
 8012bc2:	0c9b      	lsrs	r3, r3, #18
 8012bc4:	b29b      	uxth	r3, r3
 8012bc6:	4a04      	ldr	r2, [pc, #16]	; (8012bd8 <udp_init+0x24>)
 8012bc8:	4694      	mov	ip, r2
 8012bca:	4463      	add	r3, ip
 8012bcc:	b29a      	uxth	r2, r3
 8012bce:	4b03      	ldr	r3, [pc, #12]	; (8012bdc <udp_init+0x28>)
 8012bd0:	801a      	strh	r2, [r3, #0]
#endif /* LWIP_RAND */
}
 8012bd2:	46c0      	nop			; (mov r8, r8)
 8012bd4:	46bd      	mov	sp, r7
 8012bd6:	bd80      	pop	{r7, pc}
 8012bd8:	ffffc000 	.word	0xffffc000
 8012bdc:	20000028 	.word	0x20000028

08012be0 <udp_new_port>:
 *
 * @return a new (free) local UDP port number
 */
static u16_t
udp_new_port(void)
{
 8012be0:	b580      	push	{r7, lr}
 8012be2:	b082      	sub	sp, #8
 8012be4:	af00      	add	r7, sp, #0
  u16_t n = 0;
 8012be6:	1dbb      	adds	r3, r7, #6
 8012be8:	2200      	movs	r2, #0
 8012bea:	801a      	strh	r2, [r3, #0]
  struct udp_pcb *pcb;

again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
 8012bec:	4b17      	ldr	r3, [pc, #92]	; (8012c4c <udp_new_port+0x6c>)
 8012bee:	881b      	ldrh	r3, [r3, #0]
 8012bf0:	1c5a      	adds	r2, r3, #1
 8012bf2:	b291      	uxth	r1, r2
 8012bf4:	4a15      	ldr	r2, [pc, #84]	; (8012c4c <udp_new_port+0x6c>)
 8012bf6:	8011      	strh	r1, [r2, #0]
 8012bf8:	4a15      	ldr	r2, [pc, #84]	; (8012c50 <udp_new_port+0x70>)
 8012bfa:	4293      	cmp	r3, r2
 8012bfc:	d102      	bne.n	8012c04 <udp_new_port+0x24>
    udp_port = UDP_LOCAL_PORT_RANGE_START;
 8012bfe:	4b13      	ldr	r3, [pc, #76]	; (8012c4c <udp_new_port+0x6c>)
 8012c00:	4a14      	ldr	r2, [pc, #80]	; (8012c54 <udp_new_port+0x74>)
 8012c02:	801a      	strh	r2, [r3, #0]
  }
  /* Check all PCBs. */
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8012c04:	4b14      	ldr	r3, [pc, #80]	; (8012c58 <udp_new_port+0x78>)
 8012c06:	681b      	ldr	r3, [r3, #0]
 8012c08:	603b      	str	r3, [r7, #0]
 8012c0a:	e015      	b.n	8012c38 <udp_new_port+0x58>
    if (pcb->local_port == udp_port) {
 8012c0c:	683b      	ldr	r3, [r7, #0]
 8012c0e:	8ada      	ldrh	r2, [r3, #22]
 8012c10:	4b0e      	ldr	r3, [pc, #56]	; (8012c4c <udp_new_port+0x6c>)
 8012c12:	881b      	ldrh	r3, [r3, #0]
 8012c14:	429a      	cmp	r2, r3
 8012c16:	d10c      	bne.n	8012c32 <udp_new_port+0x52>
      if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
 8012c18:	1dbb      	adds	r3, r7, #6
 8012c1a:	1dba      	adds	r2, r7, #6
 8012c1c:	8812      	ldrh	r2, [r2, #0]
 8012c1e:	3201      	adds	r2, #1
 8012c20:	801a      	strh	r2, [r3, #0]
 8012c22:	1dbb      	adds	r3, r7, #6
 8012c24:	881a      	ldrh	r2, [r3, #0]
 8012c26:	2380      	movs	r3, #128	; 0x80
 8012c28:	01db      	lsls	r3, r3, #7
 8012c2a:	429a      	cmp	r2, r3
 8012c2c:	d3de      	bcc.n	8012bec <udp_new_port+0xc>
        return 0;
 8012c2e:	2300      	movs	r3, #0
 8012c30:	e007      	b.n	8012c42 <udp_new_port+0x62>
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8012c32:	683b      	ldr	r3, [r7, #0]
 8012c34:	691b      	ldr	r3, [r3, #16]
 8012c36:	603b      	str	r3, [r7, #0]
 8012c38:	683b      	ldr	r3, [r7, #0]
 8012c3a:	2b00      	cmp	r3, #0
 8012c3c:	d1e6      	bne.n	8012c0c <udp_new_port+0x2c>
      }
      goto again;
    }
  }
  return udp_port;
 8012c3e:	4b03      	ldr	r3, [pc, #12]	; (8012c4c <udp_new_port+0x6c>)
 8012c40:	881b      	ldrh	r3, [r3, #0]
}
 8012c42:	0018      	movs	r0, r3
 8012c44:	46bd      	mov	sp, r7
 8012c46:	b002      	add	sp, #8
 8012c48:	bd80      	pop	{r7, pc}
 8012c4a:	46c0      	nop			; (mov r8, r8)
 8012c4c:	20000028 	.word	0x20000028
 8012c50:	0000ffff 	.word	0x0000ffff
 8012c54:	ffffc000 	.word	0xffffc000
 8012c58:	200027a4 	.word	0x200027a4

08012c5c <udp_input_local_match>:
 * @param broadcast 1 if his is an IPv4 broadcast (global or subnet-only), 0 otherwise (only used for IPv4)
 * @return 1 on match, 0 otherwise
 */
static u8_t
udp_input_local_match(struct udp_pcb *pcb, struct netif *inp, u8_t broadcast)
{
 8012c5c:	b580      	push	{r7, lr}
 8012c5e:	b084      	sub	sp, #16
 8012c60:	af00      	add	r7, sp, #0
 8012c62:	60f8      	str	r0, [r7, #12]
 8012c64:	60b9      	str	r1, [r7, #8]
 8012c66:	1dfb      	adds	r3, r7, #7
 8012c68:	701a      	strb	r2, [r3, #0]
  LWIP_UNUSED_ARG(inp);       /* in IPv6 only case */
  LWIP_UNUSED_ARG(broadcast); /* in IPv6 only case */

  LWIP_ASSERT("udp_input_local_match: invalid pcb", pcb != NULL);
 8012c6a:	68fb      	ldr	r3, [r7, #12]
 8012c6c:	2b00      	cmp	r3, #0
 8012c6e:	d105      	bne.n	8012c7c <udp_input_local_match+0x20>
 8012c70:	4b26      	ldr	r3, [pc, #152]	; (8012d0c <udp_input_local_match+0xb0>)
 8012c72:	4927      	ldr	r1, [pc, #156]	; (8012d10 <udp_input_local_match+0xb4>)
 8012c74:	4827      	ldr	r0, [pc, #156]	; (8012d14 <udp_input_local_match+0xb8>)
 8012c76:	2287      	movs	r2, #135	; 0x87
 8012c78:	f7ef fab4 	bl	80021e4 <app_debug_rtt_raw>
  LWIP_ASSERT("udp_input_local_match: invalid netif", inp != NULL);
 8012c7c:	68bb      	ldr	r3, [r7, #8]
 8012c7e:	2b00      	cmp	r3, #0
 8012c80:	d105      	bne.n	8012c8e <udp_input_local_match+0x32>
 8012c82:	4b22      	ldr	r3, [pc, #136]	; (8012d0c <udp_input_local_match+0xb0>)
 8012c84:	4924      	ldr	r1, [pc, #144]	; (8012d18 <udp_input_local_match+0xbc>)
 8012c86:	4823      	ldr	r0, [pc, #140]	; (8012d14 <udp_input_local_match+0xb8>)
 8012c88:	2288      	movs	r2, #136	; 0x88
 8012c8a:	f7ef faab 	bl	80021e4 <app_debug_rtt_raw>

  /* check if PCB is bound to specific netif */
  if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 8012c8e:	68fb      	ldr	r3, [r7, #12]
 8012c90:	7a1b      	ldrb	r3, [r3, #8]
 8012c92:	2b00      	cmp	r3, #0
 8012c94:	d00b      	beq.n	8012cae <udp_input_local_match+0x52>
      (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 8012c96:	68fb      	ldr	r3, [r7, #12]
 8012c98:	7a1a      	ldrb	r2, [r3, #8]
 8012c9a:	4b20      	ldr	r3, [pc, #128]	; (8012d1c <udp_input_local_match+0xc0>)
 8012c9c:	685b      	ldr	r3, [r3, #4]
 8012c9e:	2134      	movs	r1, #52	; 0x34
 8012ca0:	5c5b      	ldrb	r3, [r3, r1]
 8012ca2:	3301      	adds	r3, #1
 8012ca4:	b2db      	uxtb	r3, r3
  if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 8012ca6:	429a      	cmp	r2, r3
 8012ca8:	d001      	beq.n	8012cae <udp_input_local_match+0x52>
    return 0;
 8012caa:	2300      	movs	r3, #0
 8012cac:	e02a      	b.n	8012d04 <udp_input_local_match+0xa8>
  /* Only need to check PCB if incoming IP version matches PCB IP version */
  if (IP_ADDR_PCB_VERSION_MATCH_EXACT(pcb, ip_current_dest_addr())) {
#if LWIP_IPV4
    /* Special case: IPv4 broadcast: all or broadcasts in my subnet
     * Note: broadcast variable can only be 1 if it is an IPv4 broadcast */
    if (broadcast != 0) {
 8012cae:	1dfb      	adds	r3, r7, #7
 8012cb0:	781b      	ldrb	r3, [r3, #0]
 8012cb2:	2b00      	cmp	r3, #0
 8012cb4:	d016      	beq.n	8012ce4 <udp_input_local_match+0x88>
#if IP_SOF_BROADCAST_RECV
      if (ip_get_option(pcb, SOF_BROADCAST))
#endif /* IP_SOF_BROADCAST_RECV */
      {
        if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 8012cb6:	68fb      	ldr	r3, [r7, #12]
 8012cb8:	2b00      	cmp	r3, #0
 8012cba:	d011      	beq.n	8012ce0 <udp_input_local_match+0x84>
 8012cbc:	68fb      	ldr	r3, [r7, #12]
 8012cbe:	681b      	ldr	r3, [r3, #0]
 8012cc0:	2b00      	cmp	r3, #0
 8012cc2:	d00d      	beq.n	8012ce0 <udp_input_local_match+0x84>
            ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
 8012cc4:	4b15      	ldr	r3, [pc, #84]	; (8012d1c <udp_input_local_match+0xc0>)
 8012cc6:	695b      	ldr	r3, [r3, #20]
        if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 8012cc8:	3301      	adds	r3, #1
 8012cca:	d009      	beq.n	8012ce0 <udp_input_local_match+0x84>
            ip4_addr_netcmp(ip_2_ip4(&pcb->local_ip), ip4_current_dest_addr(), netif_ip4_netmask(inp))) {
 8012ccc:	68fb      	ldr	r3, [r7, #12]
 8012cce:	681a      	ldr	r2, [r3, #0]
 8012cd0:	4b12      	ldr	r3, [pc, #72]	; (8012d1c <udp_input_local_match+0xc0>)
 8012cd2:	695b      	ldr	r3, [r3, #20]
 8012cd4:	405a      	eors	r2, r3
 8012cd6:	68bb      	ldr	r3, [r7, #8]
 8012cd8:	3308      	adds	r3, #8
 8012cda:	681b      	ldr	r3, [r3, #0]
 8012cdc:	4013      	ands	r3, r2
            ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
 8012cde:	d110      	bne.n	8012d02 <udp_input_local_match+0xa6>
          return 1;
 8012ce0:	2301      	movs	r3, #1
 8012ce2:	e00f      	b.n	8012d04 <udp_input_local_match+0xa8>
        }
      }
    } else
#endif /* LWIP_IPV4 */
      /* Handle IPv4 and IPv6: all or exact match */
      if (ip_addr_isany(&pcb->local_ip) || ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 8012ce4:	68fb      	ldr	r3, [r7, #12]
 8012ce6:	2b00      	cmp	r3, #0
 8012ce8:	d009      	beq.n	8012cfe <udp_input_local_match+0xa2>
 8012cea:	68fb      	ldr	r3, [r7, #12]
 8012cec:	681b      	ldr	r3, [r3, #0]
 8012cee:	2b00      	cmp	r3, #0
 8012cf0:	d005      	beq.n	8012cfe <udp_input_local_match+0xa2>
 8012cf2:	68fb      	ldr	r3, [r7, #12]
 8012cf4:	681a      	ldr	r2, [r3, #0]
 8012cf6:	4b09      	ldr	r3, [pc, #36]	; (8012d1c <udp_input_local_match+0xc0>)
 8012cf8:	695b      	ldr	r3, [r3, #20]
 8012cfa:	429a      	cmp	r2, r3
 8012cfc:	d101      	bne.n	8012d02 <udp_input_local_match+0xa6>
        return 1;
 8012cfe:	2301      	movs	r3, #1
 8012d00:	e000      	b.n	8012d04 <udp_input_local_match+0xa8>
      }
  }

  return 0;
 8012d02:	2300      	movs	r3, #0
}
 8012d04:	0018      	movs	r0, r3
 8012d06:	46bd      	mov	sp, r7
 8012d08:	b004      	add	sp, #16
 8012d0a:	bd80      	pop	{r7, pc}
 8012d0c:	08022084 	.word	0x08022084
 8012d10:	080220ac 	.word	0x080220ac
 8012d14:	080220d0 	.word	0x080220d0
 8012d18:	080220fc 	.word	0x080220fc
 8012d1c:	20001138 	.word	0x20001138

08012d20 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
 8012d20:	b5b0      	push	{r4, r5, r7, lr}
 8012d22:	b08c      	sub	sp, #48	; 0x30
 8012d24:	af02      	add	r7, sp, #8
 8012d26:	6078      	str	r0, [r7, #4]
 8012d28:	6039      	str	r1, [r7, #0]
  struct udp_hdr *udphdr;
  struct udp_pcb *pcb, *prev;
  struct udp_pcb *uncon_pcb;
  u16_t src, dest;
  u8_t broadcast;
  u8_t for_us = 0;
 8012d2a:	231b      	movs	r3, #27
 8012d2c:	18fb      	adds	r3, r7, r3
 8012d2e:	2200      	movs	r2, #0
 8012d30:	701a      	strb	r2, [r3, #0]

  LWIP_UNUSED_ARG(inp);

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ASSERT("udp_input: invalid pbuf", p != NULL);
 8012d32:	687b      	ldr	r3, [r7, #4]
 8012d34:	2b00      	cmp	r3, #0
 8012d36:	d105      	bne.n	8012d44 <udp_input+0x24>
 8012d38:	4ba1      	ldr	r3, [pc, #644]	; (8012fc0 <udp_input+0x2a0>)
 8012d3a:	49a2      	ldr	r1, [pc, #648]	; (8012fc4 <udp_input+0x2a4>)
 8012d3c:	48a2      	ldr	r0, [pc, #648]	; (8012fc8 <udp_input+0x2a8>)
 8012d3e:	22cf      	movs	r2, #207	; 0xcf
 8012d40:	f7ef fa50 	bl	80021e4 <app_debug_rtt_raw>
  LWIP_ASSERT("udp_input: invalid netif", inp != NULL);
 8012d44:	683b      	ldr	r3, [r7, #0]
 8012d46:	2b00      	cmp	r3, #0
 8012d48:	d105      	bne.n	8012d56 <udp_input+0x36>
 8012d4a:	4b9d      	ldr	r3, [pc, #628]	; (8012fc0 <udp_input+0x2a0>)
 8012d4c:	499f      	ldr	r1, [pc, #636]	; (8012fcc <udp_input+0x2ac>)
 8012d4e:	489e      	ldr	r0, [pc, #632]	; (8012fc8 <udp_input+0x2a8>)
 8012d50:	22d0      	movs	r2, #208	; 0xd0
 8012d52:	f7ef fa47 	bl	80021e4 <app_debug_rtt_raw>
  PERF_START;

  UDP_STATS_INC(udp.recv);

  /* Check minimum length (UDP header) */
  if (p->len < UDP_HLEN) {
 8012d56:	687b      	ldr	r3, [r7, #4]
 8012d58:	895b      	ldrh	r3, [r3, #10]
 8012d5a:	2b07      	cmp	r3, #7
 8012d5c:	d804      	bhi.n	8012d68 <udp_input+0x48>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    MIB2_STATS_INC(mib2.udpinerrors);
    pbuf_free(p);
 8012d5e:	687b      	ldr	r3, [r7, #4]
 8012d60:	0018      	movs	r0, r3
 8012d62:	f7f7 fbbb 	bl	800a4dc <pbuf_free>
    goto end;
 8012d66:	e121      	b.n	8012fac <udp_input+0x28c>
  }

  udphdr = (struct udp_hdr *)p->payload;
 8012d68:	687b      	ldr	r3, [r7, #4]
 8012d6a:	685b      	ldr	r3, [r3, #4]
 8012d6c:	617b      	str	r3, [r7, #20]

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif());
 8012d6e:	4b98      	ldr	r3, [pc, #608]	; (8012fd0 <udp_input+0x2b0>)
 8012d70:	695a      	ldr	r2, [r3, #20]
 8012d72:	4b97      	ldr	r3, [pc, #604]	; (8012fd0 <udp_input+0x2b0>)
 8012d74:	681b      	ldr	r3, [r3, #0]
 8012d76:	2113      	movs	r1, #19
 8012d78:	187c      	adds	r4, r7, r1
 8012d7a:	0019      	movs	r1, r3
 8012d7c:	0010      	movs	r0, r2
 8012d7e:	f001 fbc3 	bl	8014508 <ip4_addr_isbroadcast_u32>
 8012d82:	0003      	movs	r3, r0
 8012d84:	7023      	strb	r3, [r4, #0]

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = lwip_ntohs(udphdr->src);
 8012d86:	697b      	ldr	r3, [r7, #20]
 8012d88:	781a      	ldrb	r2, [r3, #0]
 8012d8a:	785b      	ldrb	r3, [r3, #1]
 8012d8c:	021b      	lsls	r3, r3, #8
 8012d8e:	4313      	orrs	r3, r2
 8012d90:	b29b      	uxth	r3, r3
 8012d92:	2210      	movs	r2, #16
 8012d94:	18bc      	adds	r4, r7, r2
 8012d96:	0018      	movs	r0, r3
 8012d98:	f7f4 fb32 	bl	8007400 <lwip_htons>
 8012d9c:	0003      	movs	r3, r0
 8012d9e:	8023      	strh	r3, [r4, #0]
  dest = lwip_ntohs(udphdr->dest);
 8012da0:	697b      	ldr	r3, [r7, #20]
 8012da2:	789a      	ldrb	r2, [r3, #2]
 8012da4:	78db      	ldrb	r3, [r3, #3]
 8012da6:	021b      	lsls	r3, r3, #8
 8012da8:	4313      	orrs	r3, r2
 8012daa:	b29b      	uxth	r3, r3
 8012dac:	220e      	movs	r2, #14
 8012dae:	18bc      	adds	r4, r7, r2
 8012db0:	0018      	movs	r0, r3
 8012db2:	f7f4 fb25 	bl	8007400 <lwip_htons>
 8012db6:	0003      	movs	r3, r0
 8012db8:	8023      	strh	r3, [r4, #0]
  ip_addr_debug_print_val(UDP_DEBUG, *ip_current_dest_addr());
  LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F") <-- (", lwip_ntohs(udphdr->dest)));
  ip_addr_debug_print_val(UDP_DEBUG, *ip_current_src_addr());
  LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F")\n", lwip_ntohs(udphdr->src)));

  pcb = NULL;
 8012dba:	2300      	movs	r3, #0
 8012dbc:	61fb      	str	r3, [r7, #28]
  prev = NULL;
 8012dbe:	2300      	movs	r3, #0
 8012dc0:	623b      	str	r3, [r7, #32]
  uncon_pcb = NULL;
 8012dc2:	2300      	movs	r3, #0
 8012dc4:	627b      	str	r3, [r7, #36]	; 0x24
  /* Iterate through the UDP pcb list for a matching pcb.
   * 'Perfect match' pcbs (connected to the remote port & ip address) are
   * preferred. If no perfect match is found, the first unconnected pcb that
   * matches the local port and ip address gets the datagram. */
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8012dc6:	4b83      	ldr	r3, [pc, #524]	; (8012fd4 <udp_input+0x2b4>)
 8012dc8:	681b      	ldr	r3, [r3, #0]
 8012dca:	61fb      	str	r3, [r7, #28]
 8012dcc:	e066      	b.n	8012e9c <udp_input+0x17c>
    LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F") <-- (", pcb->local_port));
    ip_addr_debug_print_val(UDP_DEBUG, pcb->remote_ip);
    LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F")\n", pcb->remote_port));

    /* compare PCB local addr+port to UDP destination addr+port */
    if ((pcb->local_port == dest) &&
 8012dce:	69fb      	ldr	r3, [r7, #28]
 8012dd0:	8adb      	ldrh	r3, [r3, #22]
 8012dd2:	220e      	movs	r2, #14
 8012dd4:	18ba      	adds	r2, r7, r2
 8012dd6:	8812      	ldrh	r2, [r2, #0]
 8012dd8:	429a      	cmp	r2, r3
 8012dda:	d15a      	bne.n	8012e92 <udp_input+0x172>
        (udp_input_local_match(pcb, inp, broadcast) != 0)) {
 8012ddc:	2313      	movs	r3, #19
 8012dde:	18fb      	adds	r3, r7, r3
 8012de0:	781a      	ldrb	r2, [r3, #0]
 8012de2:	6839      	ldr	r1, [r7, #0]
 8012de4:	69fb      	ldr	r3, [r7, #28]
 8012de6:	0018      	movs	r0, r3
 8012de8:	f7ff ff38 	bl	8012c5c <udp_input_local_match>
 8012dec:	1e03      	subs	r3, r0, #0
    if ((pcb->local_port == dest) &&
 8012dee:	d050      	beq.n	8012e92 <udp_input+0x172>
      if ((pcb->flags & UDP_FLAGS_CONNECTED) == 0) {
 8012df0:	69fb      	ldr	r3, [r7, #28]
 8012df2:	7d1b      	ldrb	r3, [r3, #20]
 8012df4:	001a      	movs	r2, r3
 8012df6:	2304      	movs	r3, #4
 8012df8:	4013      	ands	r3, r2
 8012dfa:	d12a      	bne.n	8012e52 <udp_input+0x132>
        if (uncon_pcb == NULL) {
 8012dfc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012dfe:	2b00      	cmp	r3, #0
 8012e00:	d102      	bne.n	8012e08 <udp_input+0xe8>
          /* the first unconnected matching PCB */
          uncon_pcb = pcb;
 8012e02:	69fb      	ldr	r3, [r7, #28]
 8012e04:	627b      	str	r3, [r7, #36]	; 0x24
 8012e06:	e024      	b.n	8012e52 <udp_input+0x132>
#if LWIP_IPV4
        } else if (broadcast && ip4_current_dest_addr()->addr == IPADDR_BROADCAST) {
 8012e08:	2313      	movs	r3, #19
 8012e0a:	18fb      	adds	r3, r7, r3
 8012e0c:	781b      	ldrb	r3, [r3, #0]
 8012e0e:	2b00      	cmp	r3, #0
 8012e10:	d014      	beq.n	8012e3c <udp_input+0x11c>
 8012e12:	4b6f      	ldr	r3, [pc, #444]	; (8012fd0 <udp_input+0x2b0>)
 8012e14:	695b      	ldr	r3, [r3, #20]
 8012e16:	3301      	adds	r3, #1
 8012e18:	d110      	bne.n	8012e3c <udp_input+0x11c>
          /* global broadcast address (only valid for IPv4; match was checked before) */
          if (!IP_IS_V4_VAL(uncon_pcb->local_ip) || !ip4_addr_cmp(ip_2_ip4(&uncon_pcb->local_ip), netif_ip4_addr(inp))) {
 8012e1a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012e1c:	681a      	ldr	r2, [r3, #0]
 8012e1e:	683b      	ldr	r3, [r7, #0]
 8012e20:	3304      	adds	r3, #4
 8012e22:	681b      	ldr	r3, [r3, #0]
 8012e24:	429a      	cmp	r2, r3
 8012e26:	d013      	beq.n	8012e50 <udp_input+0x130>
            /* uncon_pcb does not match the input netif, check this pcb */
            if (IP_IS_V4_VAL(pcb->local_ip) && ip4_addr_cmp(ip_2_ip4(&pcb->local_ip), netif_ip4_addr(inp))) {
 8012e28:	69fb      	ldr	r3, [r7, #28]
 8012e2a:	681a      	ldr	r2, [r3, #0]
 8012e2c:	683b      	ldr	r3, [r7, #0]
 8012e2e:	3304      	adds	r3, #4
 8012e30:	681b      	ldr	r3, [r3, #0]
 8012e32:	429a      	cmp	r2, r3
 8012e34:	d10c      	bne.n	8012e50 <udp_input+0x130>
              /* better match */
              uncon_pcb = pcb;
 8012e36:	69fb      	ldr	r3, [r7, #28]
 8012e38:	627b      	str	r3, [r7, #36]	; 0x24
          if (!IP_IS_V4_VAL(uncon_pcb->local_ip) || !ip4_addr_cmp(ip_2_ip4(&uncon_pcb->local_ip), netif_ip4_addr(inp))) {
 8012e3a:	e009      	b.n	8012e50 <udp_input+0x130>
            }
          }
#endif /* LWIP_IPV4 */
        }
#if SO_REUSE
        else if (!ip_addr_isany(&pcb->local_ip)) {
 8012e3c:	69fb      	ldr	r3, [r7, #28]
 8012e3e:	2b00      	cmp	r3, #0
 8012e40:	d007      	beq.n	8012e52 <udp_input+0x132>
 8012e42:	69fb      	ldr	r3, [r7, #28]
 8012e44:	681b      	ldr	r3, [r3, #0]
 8012e46:	2b00      	cmp	r3, #0
 8012e48:	d003      	beq.n	8012e52 <udp_input+0x132>
          /* prefer specific IPs over catch-all */
          uncon_pcb = pcb;
 8012e4a:	69fb      	ldr	r3, [r7, #28]
 8012e4c:	627b      	str	r3, [r7, #36]	; 0x24
 8012e4e:	e000      	b.n	8012e52 <udp_input+0x132>
          if (!IP_IS_V4_VAL(uncon_pcb->local_ip) || !ip4_addr_cmp(ip_2_ip4(&uncon_pcb->local_ip), netif_ip4_addr(inp))) {
 8012e50:	46c0      	nop			; (mov r8, r8)
        }
#endif /* SO_REUSE */
      }

      /* compare PCB remote addr+port to UDP source addr+port */
      if ((pcb->remote_port == src) &&
 8012e52:	69fb      	ldr	r3, [r7, #28]
 8012e54:	8b1b      	ldrh	r3, [r3, #24]
 8012e56:	2210      	movs	r2, #16
 8012e58:	18ba      	adds	r2, r7, r2
 8012e5a:	8812      	ldrh	r2, [r2, #0]
 8012e5c:	429a      	cmp	r2, r3
 8012e5e:	d118      	bne.n	8012e92 <udp_input+0x172>
          (ip_addr_isany_val(pcb->remote_ip) ||
 8012e60:	69fb      	ldr	r3, [r7, #28]
 8012e62:	685b      	ldr	r3, [r3, #4]
      if ((pcb->remote_port == src) &&
 8012e64:	2b00      	cmp	r3, #0
 8012e66:	d005      	beq.n	8012e74 <udp_input+0x154>
           ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()))) {
 8012e68:	69fb      	ldr	r3, [r7, #28]
 8012e6a:	685a      	ldr	r2, [r3, #4]
 8012e6c:	4b58      	ldr	r3, [pc, #352]	; (8012fd0 <udp_input+0x2b0>)
 8012e6e:	691b      	ldr	r3, [r3, #16]
          (ip_addr_isany_val(pcb->remote_ip) ||
 8012e70:	429a      	cmp	r2, r3
 8012e72:	d10e      	bne.n	8012e92 <udp_input+0x172>
        /* the first fully matching PCB */
        if (prev != NULL) {
 8012e74:	6a3b      	ldr	r3, [r7, #32]
 8012e76:	2b00      	cmp	r3, #0
 8012e78:	d014      	beq.n	8012ea4 <udp_input+0x184>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
 8012e7a:	69fb      	ldr	r3, [r7, #28]
 8012e7c:	691a      	ldr	r2, [r3, #16]
 8012e7e:	6a3b      	ldr	r3, [r7, #32]
 8012e80:	611a      	str	r2, [r3, #16]
          pcb->next = udp_pcbs;
 8012e82:	4b54      	ldr	r3, [pc, #336]	; (8012fd4 <udp_input+0x2b4>)
 8012e84:	681a      	ldr	r2, [r3, #0]
 8012e86:	69fb      	ldr	r3, [r7, #28]
 8012e88:	611a      	str	r2, [r3, #16]
          udp_pcbs = pcb;
 8012e8a:	4b52      	ldr	r3, [pc, #328]	; (8012fd4 <udp_input+0x2b4>)
 8012e8c:	69fa      	ldr	r2, [r7, #28]
 8012e8e:	601a      	str	r2, [r3, #0]
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
 8012e90:	e008      	b.n	8012ea4 <udp_input+0x184>
      }
    }

    prev = pcb;
 8012e92:	69fb      	ldr	r3, [r7, #28]
 8012e94:	623b      	str	r3, [r7, #32]
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8012e96:	69fb      	ldr	r3, [r7, #28]
 8012e98:	691b      	ldr	r3, [r3, #16]
 8012e9a:	61fb      	str	r3, [r7, #28]
 8012e9c:	69fb      	ldr	r3, [r7, #28]
 8012e9e:	2b00      	cmp	r3, #0
 8012ea0:	d195      	bne.n	8012dce <udp_input+0xae>
 8012ea2:	e000      	b.n	8012ea6 <udp_input+0x186>
        break;
 8012ea4:	46c0      	nop			; (mov r8, r8)
  }
  /* no fully matching pcb found? then look for an unconnected pcb */
  if (pcb == NULL) {
 8012ea6:	69fb      	ldr	r3, [r7, #28]
 8012ea8:	2b00      	cmp	r3, #0
 8012eaa:	d101      	bne.n	8012eb0 <udp_input+0x190>
    pcb = uncon_pcb;
 8012eac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012eae:	61fb      	str	r3, [r7, #28]
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL) {
 8012eb0:	69fb      	ldr	r3, [r7, #28]
 8012eb2:	2b00      	cmp	r3, #0
 8012eb4:	d004      	beq.n	8012ec0 <udp_input+0x1a0>
    for_us = 1;
 8012eb6:	231b      	movs	r3, #27
 8012eb8:	18fb      	adds	r3, r7, r3
 8012eba:	2201      	movs	r2, #1
 8012ebc:	701a      	strb	r2, [r3, #0]
 8012ebe:	e00b      	b.n	8012ed8 <udp_input+0x1b8>
      for_us = netif_get_ip6_addr_match(inp, ip6_current_dest_addr()) >= 0;
    }
#endif /* LWIP_IPV6 */
#if LWIP_IPV4
    if (!ip_current_is_v6()) {
      for_us = ip4_addr_cmp(netif_ip4_addr(inp), ip4_current_dest_addr());
 8012ec0:	683b      	ldr	r3, [r7, #0]
 8012ec2:	3304      	adds	r3, #4
 8012ec4:	681a      	ldr	r2, [r3, #0]
 8012ec6:	4b42      	ldr	r3, [pc, #264]	; (8012fd0 <udp_input+0x2b0>)
 8012ec8:	695b      	ldr	r3, [r3, #20]
 8012eca:	1ad3      	subs	r3, r2, r3
 8012ecc:	425a      	negs	r2, r3
 8012ece:	4153      	adcs	r3, r2
 8012ed0:	b2da      	uxtb	r2, r3
 8012ed2:	231b      	movs	r3, #27
 8012ed4:	18fb      	adds	r3, r7, r3
 8012ed6:	701a      	strb	r2, [r3, #0]
    }
#endif /* LWIP_IPV4 */
  }

  if (for_us) {
 8012ed8:	231b      	movs	r3, #27
 8012eda:	18fb      	adds	r3, r7, r3
 8012edc:	781b      	ldrb	r3, [r3, #0]
 8012ede:	2b00      	cmp	r3, #0
 8012ee0:	d05f      	beq.n	8012fa2 <udp_input+0x282>
          goto chkerr;
        }
      } else
#endif /* LWIP_UDPLITE */
      {
        if (udphdr->chksum != 0) {
 8012ee2:	697b      	ldr	r3, [r7, #20]
 8012ee4:	799a      	ldrb	r2, [r3, #6]
 8012ee6:	79db      	ldrb	r3, [r3, #7]
 8012ee8:	021b      	lsls	r3, r3, #8
 8012eea:	4313      	orrs	r3, r2
 8012eec:	b29b      	uxth	r3, r3
 8012eee:	2b00      	cmp	r3, #0
 8012ef0:	d00b      	beq.n	8012f0a <udp_input+0x1ea>
          if (ip_chksum_pseudo(p, IP_PROTO_UDP, p->tot_len,
 8012ef2:	687b      	ldr	r3, [r7, #4]
 8012ef4:	891a      	ldrh	r2, [r3, #8]
 8012ef6:	4938      	ldr	r1, [pc, #224]	; (8012fd8 <udp_input+0x2b8>)
 8012ef8:	6878      	ldr	r0, [r7, #4]
 8012efa:	4b38      	ldr	r3, [pc, #224]	; (8012fdc <udp_input+0x2bc>)
 8012efc:	9300      	str	r3, [sp, #0]
 8012efe:	000b      	movs	r3, r1
 8012f00:	2111      	movs	r1, #17
 8012f02:	f7f5 fd26 	bl	8008952 <ip_chksum_pseudo>
 8012f06:	1e03      	subs	r3, r0, #0
 8012f08:	d151      	bne.n	8012fae <udp_input+0x28e>
          }
        }
      }
    }
#endif /* CHECKSUM_CHECK_UDP */
    if (pbuf_remove_header(p, UDP_HLEN)) {
 8012f0a:	687b      	ldr	r3, [r7, #4]
 8012f0c:	2108      	movs	r1, #8
 8012f0e:	0018      	movs	r0, r3
 8012f10:	f7f7 fa4e 	bl	800a3b0 <pbuf_remove_header>
 8012f14:	1e03      	subs	r3, r0, #0
 8012f16:	d00b      	beq.n	8012f30 <udp_input+0x210>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_remove_header failed\n", 0);
 8012f18:	4b29      	ldr	r3, [pc, #164]	; (8012fc0 <udp_input+0x2a0>)
 8012f1a:	22b8      	movs	r2, #184	; 0xb8
 8012f1c:	0052      	lsls	r2, r2, #1
 8012f1e:	4930      	ldr	r1, [pc, #192]	; (8012fe0 <udp_input+0x2c0>)
 8012f20:	4829      	ldr	r0, [pc, #164]	; (8012fc8 <udp_input+0x2a8>)
 8012f22:	f7ef f95f 	bl	80021e4 <app_debug_rtt_raw>
      UDP_STATS_INC(udp.drop);
      MIB2_STATS_INC(mib2.udpinerrors);
      pbuf_free(p);
 8012f26:	687b      	ldr	r3, [r7, #4]
 8012f28:	0018      	movs	r0, r3
 8012f2a:	f7f7 fad7 	bl	800a4dc <pbuf_free>
      goto end;
 8012f2e:	e03d      	b.n	8012fac <udp_input+0x28c>
    }

    if (pcb != NULL) {
 8012f30:	69fb      	ldr	r3, [r7, #28]
 8012f32:	2b00      	cmp	r3, #0
 8012f34:	d016      	beq.n	8012f64 <udp_input+0x244>
          }
        }
      }
#endif /* SO_REUSE && SO_REUSE_RXTOALL */
      /* callback */
      if (pcb->recv != NULL) {
 8012f36:	69fb      	ldr	r3, [r7, #28]
 8012f38:	69db      	ldr	r3, [r3, #28]
 8012f3a:	2b00      	cmp	r3, #0
 8012f3c:	d00d      	beq.n	8012f5a <udp_input+0x23a>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
 8012f3e:	69fb      	ldr	r3, [r7, #28]
 8012f40:	69dc      	ldr	r4, [r3, #28]
 8012f42:	69fb      	ldr	r3, [r7, #28]
 8012f44:	6a18      	ldr	r0, [r3, #32]
 8012f46:	4d24      	ldr	r5, [pc, #144]	; (8012fd8 <udp_input+0x2b8>)
 8012f48:	687a      	ldr	r2, [r7, #4]
 8012f4a:	69f9      	ldr	r1, [r7, #28]
 8012f4c:	2310      	movs	r3, #16
 8012f4e:	18fb      	adds	r3, r7, r3
 8012f50:	881b      	ldrh	r3, [r3, #0]
 8012f52:	9300      	str	r3, [sp, #0]
 8012f54:	002b      	movs	r3, r5
 8012f56:	47a0      	blx	r4
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
  return;
 8012f58:	e02e      	b.n	8012fb8 <udp_input+0x298>
        pbuf_free(p);
 8012f5a:	687b      	ldr	r3, [r7, #4]
 8012f5c:	0018      	movs	r0, r3
 8012f5e:	f7f7 fabd 	bl	800a4dc <pbuf_free>
        goto end;
 8012f62:	e023      	b.n	8012fac <udp_input+0x28c>
      if (!broadcast && !ip_addr_ismulticast(ip_current_dest_addr())) {
 8012f64:	2313      	movs	r3, #19
 8012f66:	18fb      	adds	r3, r7, r3
 8012f68:	781b      	ldrb	r3, [r3, #0]
 8012f6a:	2b00      	cmp	r3, #0
 8012f6c:	d114      	bne.n	8012f98 <udp_input+0x278>
 8012f6e:	4b18      	ldr	r3, [pc, #96]	; (8012fd0 <udp_input+0x2b0>)
 8012f70:	695b      	ldr	r3, [r3, #20]
 8012f72:	22f0      	movs	r2, #240	; 0xf0
 8012f74:	4013      	ands	r3, r2
 8012f76:	2be0      	cmp	r3, #224	; 0xe0
 8012f78:	d00e      	beq.n	8012f98 <udp_input+0x278>
        pbuf_header_force(p, (s16_t)(ip_current_header_tot_len() + UDP_HLEN));
 8012f7a:	4b15      	ldr	r3, [pc, #84]	; (8012fd0 <udp_input+0x2b0>)
 8012f7c:	899b      	ldrh	r3, [r3, #12]
 8012f7e:	3308      	adds	r3, #8
 8012f80:	b29b      	uxth	r3, r3
 8012f82:	b21a      	sxth	r2, r3
 8012f84:	687b      	ldr	r3, [r7, #4]
 8012f86:	0011      	movs	r1, r2
 8012f88:	0018      	movs	r0, r3
 8012f8a:	f7f7 fa92 	bl	800a4b2 <pbuf_header_force>
        icmp_port_unreach(ip_current_is_v6(), p);
 8012f8e:	687b      	ldr	r3, [r7, #4]
 8012f90:	2103      	movs	r1, #3
 8012f92:	0018      	movs	r0, r3
 8012f94:	f000 fdc0 	bl	8013b18 <icmp_dest_unreach>
      pbuf_free(p);
 8012f98:	687b      	ldr	r3, [r7, #4]
 8012f9a:	0018      	movs	r0, r3
 8012f9c:	f7f7 fa9e 	bl	800a4dc <pbuf_free>
  return;
 8012fa0:	e00a      	b.n	8012fb8 <udp_input+0x298>
    pbuf_free(p);
 8012fa2:	687b      	ldr	r3, [r7, #4]
 8012fa4:	0018      	movs	r0, r3
 8012fa6:	f7f7 fa99 	bl	800a4dc <pbuf_free>
  return;
 8012faa:	e005      	b.n	8012fb8 <udp_input+0x298>
 8012fac:	e004      	b.n	8012fb8 <udp_input+0x298>
            goto chkerr;
 8012fae:	46c0      	nop			; (mov r8, r8)
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
              ("udp_input: UDP (or UDP Lite) datagram discarded due to failing checksum\n"));
  UDP_STATS_INC(udp.chkerr);
  UDP_STATS_INC(udp.drop);
  MIB2_STATS_INC(mib2.udpinerrors);
  pbuf_free(p);
 8012fb0:	687b      	ldr	r3, [r7, #4]
 8012fb2:	0018      	movs	r0, r3
 8012fb4:	f7f7 fa92 	bl	800a4dc <pbuf_free>
  PERF_STOP("udp_input");
#endif /* CHECKSUM_CHECK_UDP */
}
 8012fb8:	46bd      	mov	sp, r7
 8012fba:	b00a      	add	sp, #40	; 0x28
 8012fbc:	bdb0      	pop	{r4, r5, r7, pc}
 8012fbe:	46c0      	nop			; (mov r8, r8)
 8012fc0:	08022084 	.word	0x08022084
 8012fc4:	08022124 	.word	0x08022124
 8012fc8:	080220d0 	.word	0x080220d0
 8012fcc:	0802213c 	.word	0x0802213c
 8012fd0:	20001138 	.word	0x20001138
 8012fd4:	200027a4 	.word	0x200027a4
 8012fd8:	20001148 	.word	0x20001148
 8012fdc:	2000114c 	.word	0x2000114c
 8012fe0:	08022158 	.word	0x08022158

08012fe4 <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
           const ip_addr_t *dst_ip, u16_t dst_port)
{
 8012fe4:	b590      	push	{r4, r7, lr}
 8012fe6:	b087      	sub	sp, #28
 8012fe8:	af02      	add	r7, sp, #8
 8012fea:	60f8      	str	r0, [r7, #12]
 8012fec:	60b9      	str	r1, [r7, #8]
 8012fee:	607a      	str	r2, [r7, #4]
 8012ff0:	001a      	movs	r2, r3
 8012ff2:	1cbb      	adds	r3, r7, #2
 8012ff4:	801a      	strh	r2, [r3, #0]
#if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
  return udp_sendto_chksum(pcb, p, dst_ip, dst_port, 0, 0);
 8012ff6:	1cbb      	adds	r3, r7, #2
 8012ff8:	881b      	ldrh	r3, [r3, #0]
 8012ffa:	687a      	ldr	r2, [r7, #4]
 8012ffc:	68b9      	ldr	r1, [r7, #8]
 8012ffe:	68f8      	ldr	r0, [r7, #12]
 8013000:	2400      	movs	r4, #0
 8013002:	9401      	str	r4, [sp, #4]
 8013004:	2400      	movs	r4, #0
 8013006:	9400      	str	r4, [sp, #0]
 8013008:	f000 f806 	bl	8013018 <udp_sendto_chksum>
 801300c:	0003      	movs	r3, r0
}
 801300e:	0018      	movs	r0, r3
 8013010:	46bd      	mov	sp, r7
 8013012:	b005      	add	sp, #20
 8013014:	bd90      	pop	{r4, r7, pc}
	...

08013018 <udp_sendto_chksum>:
/** @ingroup udp_raw
 * Same as udp_sendto(), but with checksum */
err_t
udp_sendto_chksum(struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip,
                  u16_t dst_port, u8_t have_chksum, u16_t chksum)
{
 8013018:	b590      	push	{r4, r7, lr}
 801301a:	b08b      	sub	sp, #44	; 0x2c
 801301c:	af04      	add	r7, sp, #16
 801301e:	60f8      	str	r0, [r7, #12]
 8013020:	60b9      	str	r1, [r7, #8]
 8013022:	607a      	str	r2, [r7, #4]
 8013024:	001a      	movs	r2, r3
 8013026:	1cbb      	adds	r3, r7, #2
 8013028:	801a      	strh	r2, [r3, #0]
#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
  struct netif *netif;

  LWIP_ERROR("udp_sendto: invalid pcb", pcb != NULL, return ERR_ARG);
 801302a:	68fb      	ldr	r3, [r7, #12]
 801302c:	2b00      	cmp	r3, #0
 801302e:	d106      	bne.n	801303e <udp_sendto_chksum+0x26>
 8013030:	4b24      	ldr	r3, [pc, #144]	; (80130c4 <udp_sendto_chksum+0xac>)
 8013032:	0018      	movs	r0, r3
 8013034:	f7ef f8d6 	bl	80021e4 <app_debug_rtt_raw>
 8013038:	2310      	movs	r3, #16
 801303a:	425b      	negs	r3, r3
 801303c:	e03e      	b.n	80130bc <udp_sendto_chksum+0xa4>
  LWIP_ERROR("udp_sendto: invalid pbuf", p != NULL, return ERR_ARG);
 801303e:	68bb      	ldr	r3, [r7, #8]
 8013040:	2b00      	cmp	r3, #0
 8013042:	d106      	bne.n	8013052 <udp_sendto_chksum+0x3a>
 8013044:	4b20      	ldr	r3, [pc, #128]	; (80130c8 <udp_sendto_chksum+0xb0>)
 8013046:	0018      	movs	r0, r3
 8013048:	f7ef f8cc 	bl	80021e4 <app_debug_rtt_raw>
 801304c:	2310      	movs	r3, #16
 801304e:	425b      	negs	r3, r3
 8013050:	e034      	b.n	80130bc <udp_sendto_chksum+0xa4>
  LWIP_ERROR("udp_sendto: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 8013052:	687b      	ldr	r3, [r7, #4]
 8013054:	2b00      	cmp	r3, #0
 8013056:	d106      	bne.n	8013066 <udp_sendto_chksum+0x4e>
 8013058:	4b1c      	ldr	r3, [pc, #112]	; (80130cc <udp_sendto_chksum+0xb4>)
 801305a:	0018      	movs	r0, r3
 801305c:	f7ef f8c2 	bl	80021e4 <app_debug_rtt_raw>
 8013060:	2310      	movs	r3, #16
 8013062:	425b      	negs	r3, r3
 8013064:	e02a      	b.n	80130bc <udp_sendto_chksum+0xa4>
    return ERR_VAL;
  }

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send\n"));

  if (pcb->netif_idx != NETIF_NO_INDEX) {
 8013066:	68fb      	ldr	r3, [r7, #12]
 8013068:	7a1b      	ldrb	r3, [r3, #8]
 801306a:	2b00      	cmp	r3, #0
 801306c:	d007      	beq.n	801307e <udp_sendto_chksum+0x66>
    netif = netif_get_by_index(pcb->netif_idx);
 801306e:	68fb      	ldr	r3, [r7, #12]
 8013070:	7a1b      	ldrb	r3, [r3, #8]
 8013072:	0018      	movs	r0, r3
 8013074:	f7f6 fe7e 	bl	8009d74 <netif_get_by_index>
 8013078:	0003      	movs	r3, r0
 801307a:	617b      	str	r3, [r7, #20]
 801307c:	e005      	b.n	801308a <udp_sendto_chksum+0x72>

    if (netif == NULL)
#endif /* LWIP_MULTICAST_TX_OPTIONS */
    {
      /* find the outgoing network interface for this packet */
      netif = ip_route(&pcb->local_ip, dst_ip);
 801307e:	687b      	ldr	r3, [r7, #4]
 8013080:	0018      	movs	r0, r3
 8013082:	f000 fe19 	bl	8013cb8 <ip4_route>
 8013086:	0003      	movs	r3, r0
 8013088:	617b      	str	r3, [r7, #20]
    }
  }

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
 801308a:	697b      	ldr	r3, [r7, #20]
 801308c:	2b00      	cmp	r3, #0
 801308e:	d102      	bne.n	8013096 <udp_sendto_chksum+0x7e>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to "));
    ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, dst_ip);
    LWIP_DEBUGF(UDP_DEBUG, ("\n"));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
 8013090:	2304      	movs	r3, #4
 8013092:	425b      	negs	r3, r3
 8013094:	e012      	b.n	80130bc <udp_sendto_chksum+0xa4>
  }
#if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
  return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum);
 8013096:	1cbb      	adds	r3, r7, #2
 8013098:	881c      	ldrh	r4, [r3, #0]
 801309a:	687a      	ldr	r2, [r7, #4]
 801309c:	68b9      	ldr	r1, [r7, #8]
 801309e:	68f8      	ldr	r0, [r7, #12]
 80130a0:	232c      	movs	r3, #44	; 0x2c
 80130a2:	18fb      	adds	r3, r7, r3
 80130a4:	881b      	ldrh	r3, [r3, #0]
 80130a6:	9302      	str	r3, [sp, #8]
 80130a8:	2328      	movs	r3, #40	; 0x28
 80130aa:	18fb      	adds	r3, r7, r3
 80130ac:	781b      	ldrb	r3, [r3, #0]
 80130ae:	9301      	str	r3, [sp, #4]
 80130b0:	697b      	ldr	r3, [r7, #20]
 80130b2:	9300      	str	r3, [sp, #0]
 80130b4:	0023      	movs	r3, r4
 80130b6:	f000 f80b 	bl	80130d0 <udp_sendto_if_chksum>
 80130ba:	0003      	movs	r3, r0
#else /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
}
 80130bc:	0018      	movs	r0, r3
 80130be:	46bd      	mov	sp, r7
 80130c0:	b007      	add	sp, #28
 80130c2:	bd90      	pop	{r4, r7, pc}
 80130c4:	080221e4 	.word	0x080221e4
 80130c8:	080221fc 	.word	0x080221fc
 80130cc:	08022218 	.word	0x08022218

080130d0 <udp_sendto_if_chksum>:
/** Same as udp_sendto_if(), but with checksum */
err_t
udp_sendto_if_chksum(struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip,
                     u16_t dst_port, struct netif *netif, u8_t have_chksum,
                     u16_t chksum)
{
 80130d0:	b590      	push	{r4, r7, lr}
 80130d2:	b08b      	sub	sp, #44	; 0x2c
 80130d4:	af04      	add	r7, sp, #16
 80130d6:	60f8      	str	r0, [r7, #12]
 80130d8:	60b9      	str	r1, [r7, #8]
 80130da:	607a      	str	r2, [r7, #4]
 80130dc:	001a      	movs	r2, r3
 80130de:	1cbb      	adds	r3, r7, #2
 80130e0:	801a      	strh	r2, [r3, #0]
#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
  const ip_addr_t *src_ip;

  LWIP_ERROR("udp_sendto_if: invalid pcb", pcb != NULL, return ERR_ARG);
 80130e2:	68fb      	ldr	r3, [r7, #12]
 80130e4:	2b00      	cmp	r3, #0
 80130e6:	d106      	bne.n	80130f6 <udp_sendto_if_chksum+0x26>
 80130e8:	4b2d      	ldr	r3, [pc, #180]	; (80131a0 <udp_sendto_if_chksum+0xd0>)
 80130ea:	0018      	movs	r0, r3
 80130ec:	f7ef f87a 	bl	80021e4 <app_debug_rtt_raw>
 80130f0:	2310      	movs	r3, #16
 80130f2:	425b      	negs	r3, r3
 80130f4:	e04f      	b.n	8013196 <udp_sendto_if_chksum+0xc6>
  LWIP_ERROR("udp_sendto_if: invalid pbuf", p != NULL, return ERR_ARG);
 80130f6:	68bb      	ldr	r3, [r7, #8]
 80130f8:	2b00      	cmp	r3, #0
 80130fa:	d106      	bne.n	801310a <udp_sendto_if_chksum+0x3a>
 80130fc:	4b29      	ldr	r3, [pc, #164]	; (80131a4 <udp_sendto_if_chksum+0xd4>)
 80130fe:	0018      	movs	r0, r3
 8013100:	f7ef f870 	bl	80021e4 <app_debug_rtt_raw>
 8013104:	2310      	movs	r3, #16
 8013106:	425b      	negs	r3, r3
 8013108:	e045      	b.n	8013196 <udp_sendto_if_chksum+0xc6>
  LWIP_ERROR("udp_sendto_if: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 801310a:	687b      	ldr	r3, [r7, #4]
 801310c:	2b00      	cmp	r3, #0
 801310e:	d106      	bne.n	801311e <udp_sendto_if_chksum+0x4e>
 8013110:	4b25      	ldr	r3, [pc, #148]	; (80131a8 <udp_sendto_if_chksum+0xd8>)
 8013112:	0018      	movs	r0, r3
 8013114:	f7ef f866 	bl	80021e4 <app_debug_rtt_raw>
 8013118:	2310      	movs	r3, #16
 801311a:	425b      	negs	r3, r3
 801311c:	e03b      	b.n	8013196 <udp_sendto_if_chksum+0xc6>
  LWIP_ERROR("udp_sendto_if: invalid netif", netif != NULL, return ERR_ARG);
 801311e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013120:	2b00      	cmp	r3, #0
 8013122:	d106      	bne.n	8013132 <udp_sendto_if_chksum+0x62>
 8013124:	4b21      	ldr	r3, [pc, #132]	; (80131ac <udp_sendto_if_chksum+0xdc>)
 8013126:	0018      	movs	r0, r3
 8013128:	f7ef f85c 	bl	80021e4 <app_debug_rtt_raw>
 801312c:	2310      	movs	r3, #16
 801312e:	425b      	negs	r3, r3
 8013130:	e031      	b.n	8013196 <udp_sendto_if_chksum+0xc6>
#endif /* LWIP_IPV6 */
#if LWIP_IPV4 && LWIP_IPV6
  else
#endif /* LWIP_IPV4 && LWIP_IPV6 */
#if LWIP_IPV4
    if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 8013132:	68fb      	ldr	r3, [r7, #12]
 8013134:	2b00      	cmp	r3, #0
 8013136:	d009      	beq.n	801314c <udp_sendto_if_chksum+0x7c>
 8013138:	68fb      	ldr	r3, [r7, #12]
 801313a:	681b      	ldr	r3, [r3, #0]
 801313c:	2b00      	cmp	r3, #0
 801313e:	d005      	beq.n	801314c <udp_sendto_if_chksum+0x7c>
        ip4_addr_ismulticast(ip_2_ip4(&pcb->local_ip))) {
 8013140:	68fb      	ldr	r3, [r7, #12]
 8013142:	681b      	ldr	r3, [r3, #0]
 8013144:	22f0      	movs	r2, #240	; 0xf0
 8013146:	4013      	ands	r3, r2
    if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 8013148:	2be0      	cmp	r3, #224	; 0xe0
 801314a:	d103      	bne.n	8013154 <udp_sendto_if_chksum+0x84>
      /* if the local_ip is any or multicast
       * use the outgoing network interface IP address as source address */
      src_ip = netif_ip_addr4(netif);
 801314c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801314e:	3304      	adds	r3, #4
 8013150:	617b      	str	r3, [r7, #20]
 8013152:	e00b      	b.n	801316c <udp_sendto_if_chksum+0x9c>
    } else {
      /* check if UDP PCB local IP address is correct
       * this could be an old address if netif->ip_addr has changed */
      if (!ip4_addr_cmp(ip_2_ip4(&(pcb->local_ip)), netif_ip4_addr(netif))) {
 8013154:	68fb      	ldr	r3, [r7, #12]
 8013156:	681a      	ldr	r2, [r3, #0]
 8013158:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801315a:	3304      	adds	r3, #4
 801315c:	681b      	ldr	r3, [r3, #0]
 801315e:	429a      	cmp	r2, r3
 8013160:	d002      	beq.n	8013168 <udp_sendto_if_chksum+0x98>
        /* local_ip doesn't match, drop the packet */
        return ERR_RTE;
 8013162:	2304      	movs	r3, #4
 8013164:	425b      	negs	r3, r3
 8013166:	e016      	b.n	8013196 <udp_sendto_if_chksum+0xc6>
      }
      /* use UDP PCB local IP address as source address */
      src_ip = &pcb->local_ip;
 8013168:	68fb      	ldr	r3, [r7, #12]
 801316a:	617b      	str	r3, [r7, #20]
    }
#endif /* LWIP_IPV4 */
#if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
  return udp_sendto_if_src_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum, src_ip);
 801316c:	1cbb      	adds	r3, r7, #2
 801316e:	881c      	ldrh	r4, [r3, #0]
 8013170:	687a      	ldr	r2, [r7, #4]
 8013172:	68b9      	ldr	r1, [r7, #8]
 8013174:	68f8      	ldr	r0, [r7, #12]
 8013176:	697b      	ldr	r3, [r7, #20]
 8013178:	9303      	str	r3, [sp, #12]
 801317a:	2330      	movs	r3, #48	; 0x30
 801317c:	18fb      	adds	r3, r7, r3
 801317e:	881b      	ldrh	r3, [r3, #0]
 8013180:	9302      	str	r3, [sp, #8]
 8013182:	232c      	movs	r3, #44	; 0x2c
 8013184:	18fb      	adds	r3, r7, r3
 8013186:	781b      	ldrb	r3, [r3, #0]
 8013188:	9301      	str	r3, [sp, #4]
 801318a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801318c:	9300      	str	r3, [sp, #0]
 801318e:	0023      	movs	r3, r4
 8013190:	f000 f80e 	bl	80131b0 <udp_sendto_if_src_chksum>
 8013194:	0003      	movs	r3, r0
#else /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
  return udp_sendto_if_src(pcb, p, dst_ip, dst_port, netif, src_ip);
#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
}
 8013196:	0018      	movs	r0, r3
 8013198:	46bd      	mov	sp, r7
 801319a:	b007      	add	sp, #28
 801319c:	bd90      	pop	{r4, r7, pc}
 801319e:	46c0      	nop			; (mov r8, r8)
 80131a0:	08022234 	.word	0x08022234
 80131a4:	08022250 	.word	0x08022250
 80131a8:	0802226c 	.word	0x0802226c
 80131ac:	0802228c 	.word	0x0802228c

080131b0 <udp_sendto_if_src_chksum>:
/** Same as udp_sendto_if_src(), but with checksum */
err_t
udp_sendto_if_src_chksum(struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip,
                         u16_t dst_port, struct netif *netif, u8_t have_chksum,
                         u16_t chksum, const ip_addr_t *src_ip)
{
 80131b0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80131b2:	b08f      	sub	sp, #60	; 0x3c
 80131b4:	af04      	add	r7, sp, #16
 80131b6:	60f8      	str	r0, [r7, #12]
 80131b8:	60b9      	str	r1, [r7, #8]
 80131ba:	607a      	str	r2, [r7, #4]
 80131bc:	001a      	movs	r2, r3
 80131be:	1cbb      	adds	r3, r7, #2
 80131c0:	801a      	strh	r2, [r3, #0]
  u8_t ip_proto;
  u8_t ttl;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_sendto_if_src: invalid pcb", pcb != NULL, return ERR_ARG);
 80131c2:	68fb      	ldr	r3, [r7, #12]
 80131c4:	2b00      	cmp	r3, #0
 80131c6:	d106      	bne.n	80131d6 <udp_sendto_if_src_chksum+0x26>
 80131c8:	4bb4      	ldr	r3, [pc, #720]	; (801349c <udp_sendto_if_src_chksum+0x2ec>)
 80131ca:	0018      	movs	r0, r3
 80131cc:	f7ef f80a 	bl	80021e4 <app_debug_rtt_raw>
 80131d0:	2310      	movs	r3, #16
 80131d2:	425b      	negs	r3, r3
 80131d4:	e15d      	b.n	8013492 <udp_sendto_if_src_chksum+0x2e2>
  LWIP_ERROR("udp_sendto_if_src: invalid pbuf", p != NULL, return ERR_ARG);
 80131d6:	68bb      	ldr	r3, [r7, #8]
 80131d8:	2b00      	cmp	r3, #0
 80131da:	d106      	bne.n	80131ea <udp_sendto_if_src_chksum+0x3a>
 80131dc:	4bb0      	ldr	r3, [pc, #704]	; (80134a0 <udp_sendto_if_src_chksum+0x2f0>)
 80131de:	0018      	movs	r0, r3
 80131e0:	f7ef f800 	bl	80021e4 <app_debug_rtt_raw>
 80131e4:	2310      	movs	r3, #16
 80131e6:	425b      	negs	r3, r3
 80131e8:	e153      	b.n	8013492 <udp_sendto_if_src_chksum+0x2e2>
  LWIP_ERROR("udp_sendto_if_src: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 80131ea:	687b      	ldr	r3, [r7, #4]
 80131ec:	2b00      	cmp	r3, #0
 80131ee:	d106      	bne.n	80131fe <udp_sendto_if_src_chksum+0x4e>
 80131f0:	4bac      	ldr	r3, [pc, #688]	; (80134a4 <udp_sendto_if_src_chksum+0x2f4>)
 80131f2:	0018      	movs	r0, r3
 80131f4:	f7ee fff6 	bl	80021e4 <app_debug_rtt_raw>
 80131f8:	2310      	movs	r3, #16
 80131fa:	425b      	negs	r3, r3
 80131fc:	e149      	b.n	8013492 <udp_sendto_if_src_chksum+0x2e2>
  LWIP_ERROR("udp_sendto_if_src: invalid src_ip", src_ip != NULL, return ERR_ARG);
 80131fe:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8013200:	2b00      	cmp	r3, #0
 8013202:	d106      	bne.n	8013212 <udp_sendto_if_src_chksum+0x62>
 8013204:	4ba8      	ldr	r3, [pc, #672]	; (80134a8 <udp_sendto_if_src_chksum+0x2f8>)
 8013206:	0018      	movs	r0, r3
 8013208:	f7ee ffec 	bl	80021e4 <app_debug_rtt_raw>
 801320c:	2310      	movs	r3, #16
 801320e:	425b      	negs	r3, r3
 8013210:	e13f      	b.n	8013492 <udp_sendto_if_src_chksum+0x2e2>
  LWIP_ERROR("udp_sendto_if_src: invalid netif", netif != NULL, return ERR_ARG);
 8013212:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8013214:	2b00      	cmp	r3, #0
 8013216:	d106      	bne.n	8013226 <udp_sendto_if_src_chksum+0x76>
 8013218:	4ba4      	ldr	r3, [pc, #656]	; (80134ac <udp_sendto_if_src_chksum+0x2fc>)
 801321a:	0018      	movs	r0, r3
 801321c:	f7ee ffe2 	bl	80021e4 <app_debug_rtt_raw>
 8013220:	2310      	movs	r3, #16
 8013222:	425b      	negs	r3, r3
 8013224:	e135      	b.n	8013492 <udp_sendto_if_src_chksum+0x2e2>
    return ERR_VAL;
  }
#endif /* LWIP_IPV4 && IP_SOF_BROADCAST */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
 8013226:	68fb      	ldr	r3, [r7, #12]
 8013228:	8adb      	ldrh	r3, [r3, #22]
 801322a:	2b00      	cmp	r3, #0
 801322c:	d113      	bne.n	8013256 <udp_sendto_if_src_chksum+0xa6>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 801322e:	68f9      	ldr	r1, [r7, #12]
 8013230:	68fb      	ldr	r3, [r7, #12]
 8013232:	8ada      	ldrh	r2, [r3, #22]
 8013234:	251f      	movs	r5, #31
 8013236:	197c      	adds	r4, r7, r5
 8013238:	68fb      	ldr	r3, [r7, #12]
 801323a:	0018      	movs	r0, r3
 801323c:	f000 f942 	bl	80134c4 <udp_bind>
 8013240:	0003      	movs	r3, r0
 8013242:	7023      	strb	r3, [r4, #0]
    if (err != ERR_OK) {
 8013244:	197b      	adds	r3, r7, r5
 8013246:	781b      	ldrb	r3, [r3, #0]
 8013248:	b25b      	sxtb	r3, r3
 801324a:	2b00      	cmp	r3, #0
 801324c:	d003      	beq.n	8013256 <udp_sendto_if_src_chksum+0xa6>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind failed\n"));
      return err;
 801324e:	197b      	adds	r3, r7, r5
 8013250:	781b      	ldrb	r3, [r3, #0]
 8013252:	b25b      	sxtb	r3, r3
 8013254:	e11d      	b.n	8013492 <udp_sendto_if_src_chksum+0x2e2>
    }
  }

  /* packet too large to add a UDP header without causing an overflow? */
  if ((u16_t)(p->tot_len + UDP_HLEN) < p->tot_len) {
 8013256:	68bb      	ldr	r3, [r7, #8]
 8013258:	891b      	ldrh	r3, [r3, #8]
 801325a:	4a95      	ldr	r2, [pc, #596]	; (80134b0 <udp_sendto_if_src_chksum+0x300>)
 801325c:	4293      	cmp	r3, r2
 801325e:	d902      	bls.n	8013266 <udp_sendto_if_src_chksum+0xb6>
    return ERR_MEM;
 8013260:	2301      	movs	r3, #1
 8013262:	425b      	negs	r3, r3
 8013264:	e115      	b.n	8013492 <udp_sendto_if_src_chksum+0x2e2>
  }
  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_add_header(p, UDP_HLEN)) {
 8013266:	68bb      	ldr	r3, [r7, #8]
 8013268:	2108      	movs	r1, #8
 801326a:	0018      	movs	r0, r3
 801326c:	f7f7 f890 	bl	800a390 <pbuf_add_header>
 8013270:	1e03      	subs	r3, r0, #0
 8013272:	d019      	beq.n	80132a8 <udp_sendto_if_src_chksum+0xf8>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
 8013274:	23a0      	movs	r3, #160	; 0xa0
 8013276:	009b      	lsls	r3, r3, #2
 8013278:	001a      	movs	r2, r3
 801327a:	2108      	movs	r1, #8
 801327c:	2024      	movs	r0, #36	; 0x24
 801327e:	f7f6 fdf7 	bl	8009e70 <pbuf_alloc>
 8013282:	0003      	movs	r3, r0
 8013284:	623b      	str	r3, [r7, #32]
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
 8013286:	6a3b      	ldr	r3, [r7, #32]
 8013288:	2b00      	cmp	r3, #0
 801328a:	d102      	bne.n	8013292 <udp_sendto_if_src_chksum+0xe2>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
 801328c:	2301      	movs	r3, #1
 801328e:	425b      	negs	r3, r3
 8013290:	e0ff      	b.n	8013492 <udp_sendto_if_src_chksum+0x2e2>
    }
    if (p->tot_len != 0) {
 8013292:	68bb      	ldr	r3, [r7, #8]
 8013294:	891b      	ldrh	r3, [r3, #8]
 8013296:	2b00      	cmp	r3, #0
 8013298:	d008      	beq.n	80132ac <udp_sendto_if_src_chksum+0xfc>
      /* chain header q in front of given pbuf p (only if p contains data) */
      pbuf_chain(q, p);
 801329a:	68ba      	ldr	r2, [r7, #8]
 801329c:	6a3b      	ldr	r3, [r7, #32]
 801329e:	0011      	movs	r1, r2
 80132a0:	0018      	movs	r0, r3
 80132a2:	f7f7 fa4f 	bl	800a744 <pbuf_chain>
 80132a6:	e001      	b.n	80132ac <udp_sendto_if_src_chksum+0xfc>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
 80132a8:	68bb      	ldr	r3, [r7, #8]
 80132aa:	623b      	str	r3, [r7, #32]
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
 80132ac:	6a3b      	ldr	r3, [r7, #32]
 80132ae:	895b      	ldrh	r3, [r3, #10]
 80132b0:	2b07      	cmp	r3, #7
 80132b2:	d805      	bhi.n	80132c0 <udp_sendto_if_src_chksum+0x110>
 80132b4:	4b7f      	ldr	r3, [pc, #508]	; (80134b4 <udp_sendto_if_src_chksum+0x304>)
 80132b6:	4a80      	ldr	r2, [pc, #512]	; (80134b8 <udp_sendto_if_src_chksum+0x308>)
 80132b8:	4980      	ldr	r1, [pc, #512]	; (80134bc <udp_sendto_if_src_chksum+0x30c>)
 80132ba:	4881      	ldr	r0, [pc, #516]	; (80134c0 <udp_sendto_if_src_chksum+0x310>)
 80132bc:	f7ee ff92 	bl	80021e4 <app_debug_rtt_raw>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = (struct udp_hdr *)q->payload;
 80132c0:	6a3b      	ldr	r3, [r7, #32]
 80132c2:	685b      	ldr	r3, [r3, #4]
 80132c4:	61bb      	str	r3, [r7, #24]
  udphdr->src = lwip_htons(pcb->local_port);
 80132c6:	68fb      	ldr	r3, [r7, #12]
 80132c8:	8adb      	ldrh	r3, [r3, #22]
 80132ca:	0018      	movs	r0, r3
 80132cc:	f7f4 f898 	bl	8007400 <lwip_htons>
 80132d0:	0003      	movs	r3, r0
 80132d2:	001a      	movs	r2, r3
 80132d4:	69bb      	ldr	r3, [r7, #24]
 80132d6:	21ff      	movs	r1, #255	; 0xff
 80132d8:	4011      	ands	r1, r2
 80132da:	000c      	movs	r4, r1
 80132dc:	7819      	ldrb	r1, [r3, #0]
 80132de:	2000      	movs	r0, #0
 80132e0:	4001      	ands	r1, r0
 80132e2:	1c08      	adds	r0, r1, #0
 80132e4:	1c21      	adds	r1, r4, #0
 80132e6:	4301      	orrs	r1, r0
 80132e8:	7019      	strb	r1, [r3, #0]
 80132ea:	0a12      	lsrs	r2, r2, #8
 80132ec:	b290      	uxth	r0, r2
 80132ee:	785a      	ldrb	r2, [r3, #1]
 80132f0:	2100      	movs	r1, #0
 80132f2:	400a      	ands	r2, r1
 80132f4:	1c11      	adds	r1, r2, #0
 80132f6:	1c02      	adds	r2, r0, #0
 80132f8:	430a      	orrs	r2, r1
 80132fa:	705a      	strb	r2, [r3, #1]
  udphdr->dest = lwip_htons(dst_port);
 80132fc:	1cbb      	adds	r3, r7, #2
 80132fe:	881b      	ldrh	r3, [r3, #0]
 8013300:	0018      	movs	r0, r3
 8013302:	f7f4 f87d 	bl	8007400 <lwip_htons>
 8013306:	0003      	movs	r3, r0
 8013308:	001a      	movs	r2, r3
 801330a:	69bb      	ldr	r3, [r7, #24]
 801330c:	21ff      	movs	r1, #255	; 0xff
 801330e:	4011      	ands	r1, r2
 8013310:	000c      	movs	r4, r1
 8013312:	7899      	ldrb	r1, [r3, #2]
 8013314:	2000      	movs	r0, #0
 8013316:	4001      	ands	r1, r0
 8013318:	1c08      	adds	r0, r1, #0
 801331a:	1c21      	adds	r1, r4, #0
 801331c:	4301      	orrs	r1, r0
 801331e:	7099      	strb	r1, [r3, #2]
 8013320:	0a12      	lsrs	r2, r2, #8
 8013322:	b290      	uxth	r0, r2
 8013324:	78da      	ldrb	r2, [r3, #3]
 8013326:	2100      	movs	r1, #0
 8013328:	400a      	ands	r2, r1
 801332a:	1c11      	adds	r1, r2, #0
 801332c:	1c02      	adds	r2, r0, #0
 801332e:	430a      	orrs	r2, r1
 8013330:	70da      	strb	r2, [r3, #3]
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000;
 8013332:	69bb      	ldr	r3, [r7, #24]
 8013334:	799a      	ldrb	r2, [r3, #6]
 8013336:	2100      	movs	r1, #0
 8013338:	400a      	ands	r2, r1
 801333a:	719a      	strb	r2, [r3, #6]
 801333c:	79da      	ldrb	r2, [r3, #7]
 801333e:	2100      	movs	r1, #0
 8013340:	400a      	ands	r2, r1
 8013342:	71da      	strb	r2, [r3, #7]
    ip_proto = IP_PROTO_UDPLITE;
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = lwip_htons(q->tot_len);
 8013344:	6a3b      	ldr	r3, [r7, #32]
 8013346:	891b      	ldrh	r3, [r3, #8]
 8013348:	0018      	movs	r0, r3
 801334a:	f7f4 f859 	bl	8007400 <lwip_htons>
 801334e:	0003      	movs	r3, r0
 8013350:	001a      	movs	r2, r3
 8013352:	69bb      	ldr	r3, [r7, #24]
 8013354:	21ff      	movs	r1, #255	; 0xff
 8013356:	4011      	ands	r1, r2
 8013358:	000c      	movs	r4, r1
 801335a:	7919      	ldrb	r1, [r3, #4]
 801335c:	2000      	movs	r0, #0
 801335e:	4001      	ands	r1, r0
 8013360:	1c08      	adds	r0, r1, #0
 8013362:	1c21      	adds	r1, r4, #0
 8013364:	4301      	orrs	r1, r0
 8013366:	7119      	strb	r1, [r3, #4]
 8013368:	0a12      	lsrs	r2, r2, #8
 801336a:	b290      	uxth	r0, r2
 801336c:	795a      	ldrb	r2, [r3, #5]
 801336e:	2100      	movs	r1, #0
 8013370:	400a      	ands	r2, r1
 8013372:	1c11      	adds	r1, r2, #0
 8013374:	1c02      	adds	r2, r0, #0
 8013376:	430a      	orrs	r2, r1
 8013378:	715a      	strb	r2, [r3, #5]
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_UDP) {
      /* Checksum is mandatory over IPv6. */
      if (IP_IS_V6(dst_ip) || (pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
 801337a:	68fb      	ldr	r3, [r7, #12]
 801337c:	7d1b      	ldrb	r3, [r3, #20]
 801337e:	001a      	movs	r2, r3
 8013380:	2301      	movs	r3, #1
 8013382:	4013      	ands	r3, r2
 8013384:	d150      	bne.n	8013428 <udp_sendto_if_src_chksum+0x278>
        u16_t udpchksum;
#if LWIP_CHECKSUM_ON_COPY
        if (have_chksum) {
 8013386:	2344      	movs	r3, #68	; 0x44
 8013388:	18fb      	adds	r3, r7, r3
 801338a:	781b      	ldrb	r3, [r3, #0]
 801338c:	2b00      	cmp	r3, #0
 801338e:	d021      	beq.n	80133d4 <udp_sendto_if_src_chksum+0x224>
          u32_t acc;
          udpchksum = ip_chksum_pseudo_partial(q, IP_PROTO_UDP,
 8013390:	6a3b      	ldr	r3, [r7, #32]
 8013392:	891a      	ldrh	r2, [r3, #8]
 8013394:	2526      	movs	r5, #38	; 0x26
 8013396:	197c      	adds	r4, r7, r5
 8013398:	6a38      	ldr	r0, [r7, #32]
 801339a:	687b      	ldr	r3, [r7, #4]
 801339c:	9301      	str	r3, [sp, #4]
 801339e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80133a0:	9300      	str	r3, [sp, #0]
 80133a2:	2308      	movs	r3, #8
 80133a4:	2111      	movs	r1, #17
 80133a6:	f7f5 fbee 	bl	8008b86 <ip_chksum_pseudo_partial>
 80133aa:	0003      	movs	r3, r0
 80133ac:	8023      	strh	r3, [r4, #0]
                                               q->tot_len, UDP_HLEN, src_ip, dst_ip);
          acc = udpchksum + (u16_t)~(chksum);
 80133ae:	0028      	movs	r0, r5
 80133b0:	183b      	adds	r3, r7, r0
 80133b2:	881b      	ldrh	r3, [r3, #0]
 80133b4:	2248      	movs	r2, #72	; 0x48
 80133b6:	18ba      	adds	r2, r7, r2
 80133b8:	8812      	ldrh	r2, [r2, #0]
 80133ba:	43d2      	mvns	r2, r2
 80133bc:	b292      	uxth	r2, r2
 80133be:	189b      	adds	r3, r3, r2
 80133c0:	617b      	str	r3, [r7, #20]
          udpchksum = FOLD_U32T(acc);
 80133c2:	697b      	ldr	r3, [r7, #20]
 80133c4:	0c1b      	lsrs	r3, r3, #16
 80133c6:	b299      	uxth	r1, r3
 80133c8:	697b      	ldr	r3, [r7, #20]
 80133ca:	b29a      	uxth	r2, r3
 80133cc:	183b      	adds	r3, r7, r0
 80133ce:	188a      	adds	r2, r1, r2
 80133d0:	801a      	strh	r2, [r3, #0]
 80133d2:	e00d      	b.n	80133f0 <udp_sendto_if_src_chksum+0x240>
        } else
#endif /* LWIP_CHECKSUM_ON_COPY */
        {
          udpchksum = ip_chksum_pseudo(q, IP_PROTO_UDP, q->tot_len,
 80133d4:	6a3b      	ldr	r3, [r7, #32]
 80133d6:	891a      	ldrh	r2, [r3, #8]
 80133d8:	2326      	movs	r3, #38	; 0x26
 80133da:	18fc      	adds	r4, r7, r3
 80133dc:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 80133de:	6a38      	ldr	r0, [r7, #32]
 80133e0:	687b      	ldr	r3, [r7, #4]
 80133e2:	9300      	str	r3, [sp, #0]
 80133e4:	000b      	movs	r3, r1
 80133e6:	2111      	movs	r1, #17
 80133e8:	f7f5 fab3 	bl	8008952 <ip_chksum_pseudo>
 80133ec:	0003      	movs	r3, r0
 80133ee:	8023      	strh	r3, [r4, #0]
                                       src_ip, dst_ip);
        }

        /* chksum zero must become 0xffff, as zero means 'no checksum' */
        if (udpchksum == 0x0000) {
 80133f0:	2226      	movs	r2, #38	; 0x26
 80133f2:	18bb      	adds	r3, r7, r2
 80133f4:	881b      	ldrh	r3, [r3, #0]
 80133f6:	2b00      	cmp	r3, #0
 80133f8:	d103      	bne.n	8013402 <udp_sendto_if_src_chksum+0x252>
          udpchksum = 0xffff;
 80133fa:	18bb      	adds	r3, r7, r2
 80133fc:	2201      	movs	r2, #1
 80133fe:	4252      	negs	r2, r2
 8013400:	801a      	strh	r2, [r3, #0]
        }
        udphdr->chksum = udpchksum;
 8013402:	69bb      	ldr	r3, [r7, #24]
 8013404:	2226      	movs	r2, #38	; 0x26
 8013406:	18ba      	adds	r2, r7, r2
 8013408:	7814      	ldrb	r4, [r2, #0]
 801340a:	7999      	ldrb	r1, [r3, #6]
 801340c:	2000      	movs	r0, #0
 801340e:	4001      	ands	r1, r0
 8013410:	1c08      	adds	r0, r1, #0
 8013412:	1c21      	adds	r1, r4, #0
 8013414:	4301      	orrs	r1, r0
 8013416:	7199      	strb	r1, [r3, #6]
 8013418:	7850      	ldrb	r0, [r2, #1]
 801341a:	79da      	ldrb	r2, [r3, #7]
 801341c:	2100      	movs	r1, #0
 801341e:	400a      	ands	r2, r1
 8013420:	1c11      	adds	r1, r2, #0
 8013422:	1c02      	adds	r2, r0, #0
 8013424:	430a      	orrs	r2, r1
 8013426:	71da      	strb	r2, [r3, #7]
      }
    }
#endif /* CHECKSUM_GEN_UDP */
    ip_proto = IP_PROTO_UDP;
 8013428:	2313      	movs	r3, #19
 801342a:	18fb      	adds	r3, r7, r3
 801342c:	2211      	movs	r2, #17
 801342e:	701a      	strb	r2, [r3, #0]

  /* Determine TTL to use */
#if LWIP_MULTICAST_TX_OPTIONS
  ttl = (ip_addr_ismulticast(dst_ip) ? udp_get_multicast_ttl(pcb) : pcb->ttl);
#else /* LWIP_MULTICAST_TX_OPTIONS */
  ttl = pcb->ttl;
 8013430:	2112      	movs	r1, #18
 8013432:	187b      	adds	r3, r7, r1
 8013434:	68fa      	ldr	r2, [r7, #12]
 8013436:	7ad2      	ldrb	r2, [r2, #11]
 8013438:	701a      	strb	r2, [r3, #0]
#endif /* LWIP_MULTICAST_TX_OPTIONS */

  LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04"X16_F"\n", udphdr->chksum));
  LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,0x%02"X16_F",)\n", (u16_t)ip_proto));
  /* output to IP */
  NETIF_SET_HINTS(netif, &(pcb->netif_hints));
 801343a:	68fb      	ldr	r3, [r7, #12]
 801343c:	330c      	adds	r3, #12
 801343e:	001a      	movs	r2, r3
 8013440:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8013442:	639a      	str	r2, [r3, #56]	; 0x38
  err = ip_output_if_src(q, src_ip, dst_ip, ttl, pcb->tos, ip_proto, netif);
 8013444:	68fb      	ldr	r3, [r7, #12]
 8013446:	7a9b      	ldrb	r3, [r3, #10]
 8013448:	201f      	movs	r0, #31
 801344a:	183c      	adds	r4, r7, r0
 801344c:	187a      	adds	r2, r7, r1
 801344e:	7816      	ldrb	r6, [r2, #0]
 8013450:	687d      	ldr	r5, [r7, #4]
 8013452:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 8013454:	6a38      	ldr	r0, [r7, #32]
 8013456:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8013458:	9202      	str	r2, [sp, #8]
 801345a:	2213      	movs	r2, #19
 801345c:	18ba      	adds	r2, r7, r2
 801345e:	7812      	ldrb	r2, [r2, #0]
 8013460:	9201      	str	r2, [sp, #4]
 8013462:	9300      	str	r3, [sp, #0]
 8013464:	0033      	movs	r3, r6
 8013466:	002a      	movs	r2, r5
 8013468:	f000 fe58 	bl	801411c <ip4_output_if_src>
 801346c:	0003      	movs	r3, r0
 801346e:	7023      	strb	r3, [r4, #0]
  NETIF_RESET_HINTS(netif);
 8013470:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8013472:	2200      	movs	r2, #0
 8013474:	639a      	str	r2, [r3, #56]	; 0x38

  /* @todo: must this be increased even if error occurred? */
  MIB2_STATS_INC(mib2.udpoutdatagrams);

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
 8013476:	6a3a      	ldr	r2, [r7, #32]
 8013478:	68bb      	ldr	r3, [r7, #8]
 801347a:	429a      	cmp	r2, r3
 801347c:	d005      	beq.n	801348a <udp_sendto_if_src_chksum+0x2da>
    /* free the header pbuf */
    pbuf_free(q);
 801347e:	6a3b      	ldr	r3, [r7, #32]
 8013480:	0018      	movs	r0, r3
 8013482:	f7f7 f82b 	bl	800a4dc <pbuf_free>
    q = NULL;
 8013486:	2300      	movs	r3, #0
 8013488:	623b      	str	r3, [r7, #32]
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
 801348a:	231f      	movs	r3, #31
 801348c:	18fb      	adds	r3, r7, r3
 801348e:	781b      	ldrb	r3, [r3, #0]
 8013490:	b25b      	sxtb	r3, r3
}
 8013492:	0018      	movs	r0, r3
 8013494:	46bd      	mov	sp, r7
 8013496:	b00b      	add	sp, #44	; 0x2c
 8013498:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801349a:	46c0      	nop			; (mov r8, r8)
 801349c:	080222ac 	.word	0x080222ac
 80134a0:	080222cc 	.word	0x080222cc
 80134a4:	080222ec 	.word	0x080222ec
 80134a8:	08022310 	.word	0x08022310
 80134ac:	08022334 	.word	0x08022334
 80134b0:	0000fff7 	.word	0x0000fff7
 80134b4:	08022084 	.word	0x08022084
 80134b8:	0000030d 	.word	0x0000030d
 80134bc:	08022358 	.word	0x08022358
 80134c0:	080220d0 	.word	0x080220d0

080134c4 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
{
 80134c4:	b590      	push	{r4, r7, lr}
 80134c6:	b087      	sub	sp, #28
 80134c8:	af00      	add	r7, sp, #0
 80134ca:	60f8      	str	r0, [r7, #12]
 80134cc:	60b9      	str	r1, [r7, #8]
 80134ce:	1dbb      	adds	r3, r7, #6
 80134d0:	801a      	strh	r2, [r3, #0]

  LWIP_ASSERT_CORE_LOCKED();

#if LWIP_IPV4
  /* Don't propagate NULL pointer (IPv4 ANY) to subsequent functions */
  if (ipaddr == NULL) {
 80134d2:	68bb      	ldr	r3, [r7, #8]
 80134d4:	2b00      	cmp	r3, #0
 80134d6:	d101      	bne.n	80134dc <udp_bind+0x18>
    ipaddr = IP4_ADDR_ANY;
 80134d8:	4b43      	ldr	r3, [pc, #268]	; (80135e8 <udp_bind+0x124>)
 80134da:	60bb      	str	r3, [r7, #8]
  }
#else /* LWIP_IPV4 */
  LWIP_ERROR("udp_bind: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
#endif /* LWIP_IPV4 */

  LWIP_ERROR("udp_bind: invalid pcb", pcb != NULL, return ERR_ARG);
 80134dc:	68fb      	ldr	r3, [r7, #12]
 80134de:	2b00      	cmp	r3, #0
 80134e0:	d106      	bne.n	80134f0 <udp_bind+0x2c>
 80134e2:	4b42      	ldr	r3, [pc, #264]	; (80135ec <udp_bind+0x128>)
 80134e4:	0018      	movs	r0, r3
 80134e6:	f7ee fe7d 	bl	80021e4 <app_debug_rtt_raw>
 80134ea:	2310      	movs	r3, #16
 80134ec:	425b      	negs	r3, r3
 80134ee:	e077      	b.n	80135e0 <udp_bind+0x11c>

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_TRACE, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
 80134f0:	2313      	movs	r3, #19
 80134f2:	18fb      	adds	r3, r7, r3
 80134f4:	2200      	movs	r2, #0
 80134f6:	701a      	strb	r2, [r3, #0]
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 80134f8:	4b3d      	ldr	r3, [pc, #244]	; (80135f0 <udp_bind+0x12c>)
 80134fa:	681b      	ldr	r3, [r3, #0]
 80134fc:	617b      	str	r3, [r7, #20]
 80134fe:	e00b      	b.n	8013518 <udp_bind+0x54>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
 8013500:	68fa      	ldr	r2, [r7, #12]
 8013502:	697b      	ldr	r3, [r7, #20]
 8013504:	429a      	cmp	r2, r3
 8013506:	d104      	bne.n	8013512 <udp_bind+0x4e>
      rebind = 1;
 8013508:	2313      	movs	r3, #19
 801350a:	18fb      	adds	r3, r7, r3
 801350c:	2201      	movs	r2, #1
 801350e:	701a      	strb	r2, [r3, #0]
      break;
 8013510:	e005      	b.n	801351e <udp_bind+0x5a>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8013512:	697b      	ldr	r3, [r7, #20]
 8013514:	691b      	ldr	r3, [r3, #16]
 8013516:	617b      	str	r3, [r7, #20]
 8013518:	697b      	ldr	r3, [r7, #20]
 801351a:	2b00      	cmp	r3, #0
 801351c:	d1f0      	bne.n	8013500 <udp_bind+0x3c>
    ipaddr = &zoned_ipaddr;
  }
#endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */

  /* no port specified? */
  if (port == 0) {
 801351e:	1dbb      	adds	r3, r7, #6
 8013520:	881b      	ldrh	r3, [r3, #0]
 8013522:	2b00      	cmp	r3, #0
 8013524:	d10b      	bne.n	801353e <udp_bind+0x7a>
    port = udp_new_port();
 8013526:	1dbc      	adds	r4, r7, #6
 8013528:	f7ff fb5a 	bl	8012be0 <udp_new_port>
 801352c:	0003      	movs	r3, r0
 801352e:	8023      	strh	r3, [r4, #0]
    if (port == 0) {
 8013530:	1dbb      	adds	r3, r7, #6
 8013532:	881b      	ldrh	r3, [r3, #0]
 8013534:	2b00      	cmp	r3, #0
 8013536:	d139      	bne.n	80135ac <udp_bind+0xe8>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
 8013538:	2308      	movs	r3, #8
 801353a:	425b      	negs	r3, r3
 801353c:	e050      	b.n	80135e0 <udp_bind+0x11c>
    }
  } else {
    for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 801353e:	4b2c      	ldr	r3, [pc, #176]	; (80135f0 <udp_bind+0x12c>)
 8013540:	681b      	ldr	r3, [r3, #0]
 8013542:	617b      	str	r3, [r7, #20]
 8013544:	e02f      	b.n	80135a6 <udp_bind+0xe2>
      if (pcb != ipcb) {
 8013546:	68fa      	ldr	r2, [r7, #12]
 8013548:	697b      	ldr	r3, [r7, #20]
 801354a:	429a      	cmp	r2, r3
 801354c:	d028      	beq.n	80135a0 <udp_bind+0xdc>
        /* By default, we don't allow to bind to a port that any other udp
           PCB is already bound to, unless *all* PCBs with that port have tha
           REUSEADDR flag set. */
#if SO_REUSE
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
 801354e:	68fb      	ldr	r3, [r7, #12]
 8013550:	7a5b      	ldrb	r3, [r3, #9]
 8013552:	001a      	movs	r2, r3
 8013554:	2304      	movs	r3, #4
 8013556:	4013      	ands	r3, r2
 8013558:	d005      	beq.n	8013566 <udp_bind+0xa2>
            !ip_get_option(ipcb, SOF_REUSEADDR))
 801355a:	697b      	ldr	r3, [r7, #20]
 801355c:	7a5b      	ldrb	r3, [r3, #9]
 801355e:	001a      	movs	r2, r3
 8013560:	2304      	movs	r3, #4
 8013562:	4013      	ands	r3, r2
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
 8013564:	d11c      	bne.n	80135a0 <udp_bind+0xdc>
#endif /* SO_REUSE */
        {
          /* port matches that of PCB in list and REUSEADDR not set -> reject */
          if ((ipcb->local_port == port) &&
 8013566:	697b      	ldr	r3, [r7, #20]
 8013568:	8adb      	ldrh	r3, [r3, #22]
 801356a:	1dba      	adds	r2, r7, #6
 801356c:	8812      	ldrh	r2, [r2, #0]
 801356e:	429a      	cmp	r2, r3
 8013570:	d116      	bne.n	80135a0 <udp_bind+0xdc>
              (((IP_GET_TYPE(&ipcb->local_ip) == IP_GET_TYPE(ipaddr)) &&
              /* IP address matches or any IP used? */
              (ip_addr_cmp(&ipcb->local_ip, ipaddr) ||
 8013572:	697b      	ldr	r3, [r7, #20]
 8013574:	681a      	ldr	r2, [r3, #0]
 8013576:	68bb      	ldr	r3, [r7, #8]
 8013578:	681b      	ldr	r3, [r3, #0]
          if ((ipcb->local_port == port) &&
 801357a:	429a      	cmp	r2, r3
 801357c:	d00d      	beq.n	801359a <udp_bind+0xd6>
              (ip_addr_cmp(&ipcb->local_ip, ipaddr) ||
 801357e:	68bb      	ldr	r3, [r7, #8]
 8013580:	2b00      	cmp	r3, #0
 8013582:	d00a      	beq.n	801359a <udp_bind+0xd6>
              ip_addr_isany(ipaddr) ||
 8013584:	68bb      	ldr	r3, [r7, #8]
 8013586:	681b      	ldr	r3, [r3, #0]
 8013588:	2b00      	cmp	r3, #0
 801358a:	d006      	beq.n	801359a <udp_bind+0xd6>
              ip_addr_isany(&ipcb->local_ip))) ||
 801358c:	697b      	ldr	r3, [r7, #20]
              (IP_GET_TYPE(&ipcb->local_ip) == IPADDR_TYPE_ANY) ||
 801358e:	2b00      	cmp	r3, #0
 8013590:	d003      	beq.n	801359a <udp_bind+0xd6>
              ip_addr_isany(&ipcb->local_ip))) ||
 8013592:	697b      	ldr	r3, [r7, #20]
 8013594:	681b      	ldr	r3, [r3, #0]
 8013596:	2b00      	cmp	r3, #0
 8013598:	d102      	bne.n	80135a0 <udp_bind+0xdc>
              (IP_GET_TYPE(ipaddr) == IPADDR_TYPE_ANY))) {
            /* other PCB already binds to this local IP and port */
            LWIP_DEBUGF(UDP_DEBUG,
                        ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
            return ERR_USE;
 801359a:	2308      	movs	r3, #8
 801359c:	425b      	negs	r3, r3
 801359e:	e01f      	b.n	80135e0 <udp_bind+0x11c>
    for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 80135a0:	697b      	ldr	r3, [r7, #20]
 80135a2:	691b      	ldr	r3, [r3, #16]
 80135a4:	617b      	str	r3, [r7, #20]
 80135a6:	697b      	ldr	r3, [r7, #20]
 80135a8:	2b00      	cmp	r3, #0
 80135aa:	d1cc      	bne.n	8013546 <udp_bind+0x82>
        }
      }
    }
  }

  ip_addr_set_ipaddr(&pcb->local_ip, ipaddr);
 80135ac:	68bb      	ldr	r3, [r7, #8]
 80135ae:	2b00      	cmp	r3, #0
 80135b0:	d002      	beq.n	80135b8 <udp_bind+0xf4>
 80135b2:	68bb      	ldr	r3, [r7, #8]
 80135b4:	681a      	ldr	r2, [r3, #0]
 80135b6:	e000      	b.n	80135ba <udp_bind+0xf6>
 80135b8:	2200      	movs	r2, #0
 80135ba:	68fb      	ldr	r3, [r7, #12]
 80135bc:	601a      	str	r2, [r3, #0]

  pcb->local_port = port;
 80135be:	68fb      	ldr	r3, [r7, #12]
 80135c0:	1dba      	adds	r2, r7, #6
 80135c2:	8812      	ldrh	r2, [r2, #0]
 80135c4:	82da      	strh	r2, [r3, #22]
  mib2_udp_bind(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
 80135c6:	2313      	movs	r3, #19
 80135c8:	18fb      	adds	r3, r7, r3
 80135ca:	781b      	ldrb	r3, [r3, #0]
 80135cc:	2b00      	cmp	r3, #0
 80135ce:	d106      	bne.n	80135de <udp_bind+0x11a>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
 80135d0:	4b07      	ldr	r3, [pc, #28]	; (80135f0 <udp_bind+0x12c>)
 80135d2:	681a      	ldr	r2, [r3, #0]
 80135d4:	68fb      	ldr	r3, [r7, #12]
 80135d6:	611a      	str	r2, [r3, #16]
    udp_pcbs = pcb;
 80135d8:	4b05      	ldr	r3, [pc, #20]	; (80135f0 <udp_bind+0x12c>)
 80135da:	68fa      	ldr	r2, [r7, #12]
 80135dc:	601a      	str	r2, [r3, #0]
  }
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("udp_bind: bound to "));
  ip_addr_debug_print_val(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, pcb->local_ip);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, (", port %"U16_F")\n", pcb->local_port));
  return ERR_OK;
 80135de:	2300      	movs	r3, #0
}
 80135e0:	0018      	movs	r0, r3
 80135e2:	46bd      	mov	sp, r7
 80135e4:	b007      	add	sp, #28
 80135e6:	bd90      	pop	{r4, r7, pc}
 80135e8:	08023a8c 	.word	0x08023a8c
 80135ec:	08022388 	.word	0x08022388
 80135f0:	200027a4 	.word	0x200027a4

080135f4 <udp_recv>:
 * @param recv function pointer of the callback function
 * @param recv_arg additional argument to pass to the callback function
 */
void
udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
 80135f4:	b580      	push	{r7, lr}
 80135f6:	b084      	sub	sp, #16
 80135f8:	af00      	add	r7, sp, #0
 80135fa:	60f8      	str	r0, [r7, #12]
 80135fc:	60b9      	str	r1, [r7, #8]
 80135fe:	607a      	str	r2, [r7, #4]
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_recv: invalid pcb", pcb != NULL, return);
 8013600:	68fb      	ldr	r3, [r7, #12]
 8013602:	2b00      	cmp	r3, #0
 8013604:	d104      	bne.n	8013610 <udp_recv+0x1c>
 8013606:	4b07      	ldr	r3, [pc, #28]	; (8013624 <udp_recv+0x30>)
 8013608:	0018      	movs	r0, r3
 801360a:	f7ee fdeb 	bl	80021e4 <app_debug_rtt_raw>
 801360e:	e005      	b.n	801361c <udp_recv+0x28>

  /* remember recv() callback and user data */
  pcb->recv = recv;
 8013610:	68fb      	ldr	r3, [r7, #12]
 8013612:	68ba      	ldr	r2, [r7, #8]
 8013614:	61da      	str	r2, [r3, #28]
  pcb->recv_arg = recv_arg;
 8013616:	68fb      	ldr	r3, [r7, #12]
 8013618:	687a      	ldr	r2, [r7, #4]
 801361a:	621a      	str	r2, [r3, #32]
}
 801361c:	46bd      	mov	sp, r7
 801361e:	b004      	add	sp, #16
 8013620:	bd80      	pop	{r7, pc}
 8013622:	46c0      	nop			; (mov r8, r8)
 8013624:	080223f4 	.word	0x080223f4

08013628 <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
 8013628:	b580      	push	{r7, lr}
 801362a:	b084      	sub	sp, #16
 801362c:	af00      	add	r7, sp, #0
 801362e:	6078      	str	r0, [r7, #4]
  struct udp_pcb *pcb2;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_remove: invalid pcb", pcb != NULL, return);
 8013630:	687b      	ldr	r3, [r7, #4]
 8013632:	2b00      	cmp	r3, #0
 8013634:	d104      	bne.n	8013640 <udp_remove+0x18>
 8013636:	4b18      	ldr	r3, [pc, #96]	; (8013698 <udp_remove+0x70>)
 8013638:	0018      	movs	r0, r3
 801363a:	f7ee fdd3 	bl	80021e4 <app_debug_rtt_raw>
 801363e:	e027      	b.n	8013690 <udp_remove+0x68>

  mib2_udp_unbind(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
 8013640:	4b16      	ldr	r3, [pc, #88]	; (801369c <udp_remove+0x74>)
 8013642:	681b      	ldr	r3, [r3, #0]
 8013644:	687a      	ldr	r2, [r7, #4]
 8013646:	429a      	cmp	r2, r3
 8013648:	d105      	bne.n	8013656 <udp_remove+0x2e>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
 801364a:	4b14      	ldr	r3, [pc, #80]	; (801369c <udp_remove+0x74>)
 801364c:	681b      	ldr	r3, [r3, #0]
 801364e:	691a      	ldr	r2, [r3, #16]
 8013650:	4b12      	ldr	r3, [pc, #72]	; (801369c <udp_remove+0x74>)
 8013652:	601a      	str	r2, [r3, #0]
 8013654:	e017      	b.n	8013686 <udp_remove+0x5e>
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 8013656:	4b11      	ldr	r3, [pc, #68]	; (801369c <udp_remove+0x74>)
 8013658:	681b      	ldr	r3, [r3, #0]
 801365a:	60fb      	str	r3, [r7, #12]
 801365c:	e010      	b.n	8013680 <udp_remove+0x58>
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
 801365e:	68fb      	ldr	r3, [r7, #12]
 8013660:	691b      	ldr	r3, [r3, #16]
 8013662:	2b00      	cmp	r3, #0
 8013664:	d009      	beq.n	801367a <udp_remove+0x52>
 8013666:	68fb      	ldr	r3, [r7, #12]
 8013668:	691b      	ldr	r3, [r3, #16]
 801366a:	687a      	ldr	r2, [r7, #4]
 801366c:	429a      	cmp	r2, r3
 801366e:	d104      	bne.n	801367a <udp_remove+0x52>
        /* remove pcb from list */
        pcb2->next = pcb->next;
 8013670:	687b      	ldr	r3, [r7, #4]
 8013672:	691a      	ldr	r2, [r3, #16]
 8013674:	68fb      	ldr	r3, [r7, #12]
 8013676:	611a      	str	r2, [r3, #16]
        break;
 8013678:	e005      	b.n	8013686 <udp_remove+0x5e>
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 801367a:	68fb      	ldr	r3, [r7, #12]
 801367c:	691b      	ldr	r3, [r3, #16]
 801367e:	60fb      	str	r3, [r7, #12]
 8013680:	68fb      	ldr	r3, [r7, #12]
 8013682:	2b00      	cmp	r3, #0
 8013684:	d1eb      	bne.n	801365e <udp_remove+0x36>
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
 8013686:	687b      	ldr	r3, [r7, #4]
 8013688:	0019      	movs	r1, r3
 801368a:	2000      	movs	r0, #0
 801368c:	f7f6 f872 	bl	8009774 <memp_free>
}
 8013690:	46bd      	mov	sp, r7
 8013692:	b004      	add	sp, #16
 8013694:	bd80      	pop	{r7, pc}
 8013696:	46c0      	nop			; (mov r8, r8)
 8013698:	0802240c 	.word	0x0802240c
 801369c:	200027a4 	.word	0x200027a4

080136a0 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
 80136a0:	b580      	push	{r7, lr}
 80136a2:	b082      	sub	sp, #8
 80136a4:	af00      	add	r7, sp, #0
  struct udp_pcb *pcb;

  LWIP_ASSERT_CORE_LOCKED();

  pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
 80136a6:	2000      	movs	r0, #0
 80136a8:	f7f5 fff4 	bl	8009694 <memp_malloc>
 80136ac:	0003      	movs	r3, r0
 80136ae:	607b      	str	r3, [r7, #4]
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
 80136b0:	687b      	ldr	r3, [r7, #4]
 80136b2:	2b00      	cmp	r3, #0
 80136b4:	d008      	beq.n	80136c8 <udp_new+0x28>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
 80136b6:	687b      	ldr	r3, [r7, #4]
 80136b8:	2224      	movs	r2, #36	; 0x24
 80136ba:	2100      	movs	r1, #0
 80136bc:	0018      	movs	r0, r3
 80136be:	f00a fc89 	bl	801dfd4 <memset>
    pcb->ttl = UDP_TTL;
 80136c2:	687b      	ldr	r3, [r7, #4]
 80136c4:	22ff      	movs	r2, #255	; 0xff
 80136c6:	72da      	strb	r2, [r3, #11]
#if LWIP_MULTICAST_TX_OPTIONS
    udp_set_multicast_ttl(pcb, UDP_TTL);
#endif /* LWIP_MULTICAST_TX_OPTIONS */
  }
  return pcb;
 80136c8:	687b      	ldr	r3, [r7, #4]
}
 80136ca:	0018      	movs	r0, r3
 80136cc:	46bd      	mov	sp, r7
 80136ce:	b002      	add	sp, #8
 80136d0:	bd80      	pop	{r7, pc}

080136d2 <udp_new_ip_type>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new_ip_type(u8_t type)
{
 80136d2:	b580      	push	{r7, lr}
 80136d4:	b084      	sub	sp, #16
 80136d6:	af00      	add	r7, sp, #0
 80136d8:	0002      	movs	r2, r0
 80136da:	1dfb      	adds	r3, r7, #7
 80136dc:	701a      	strb	r2, [r3, #0]
  struct udp_pcb *pcb;

  LWIP_ASSERT_CORE_LOCKED();

  pcb = udp_new();
 80136de:	f7ff ffdf 	bl	80136a0 <udp_new>
 80136e2:	0003      	movs	r3, r0
 80136e4:	60fb      	str	r3, [r7, #12]
    IP_SET_TYPE_VAL(pcb->remote_ip, type);
  }
#else
  LWIP_UNUSED_ARG(type);
#endif /* LWIP_IPV4 && LWIP_IPV6 */
  return pcb;
 80136e6:	68fb      	ldr	r3, [r7, #12]
}
 80136e8:	0018      	movs	r0, r3
 80136ea:	46bd      	mov	sp, r7
 80136ec:	b004      	add	sp, #16
 80136ee:	bd80      	pop	{r7, pc}

080136f0 <udp_netif_ip_addr_changed>:
 *
 * @param old_addr IP address of the netif before change
 * @param new_addr IP address of the netif after change
 */
void udp_netif_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_addr)
{
 80136f0:	b580      	push	{r7, lr}
 80136f2:	b084      	sub	sp, #16
 80136f4:	af00      	add	r7, sp, #0
 80136f6:	6078      	str	r0, [r7, #4]
 80136f8:	6039      	str	r1, [r7, #0]
  struct udp_pcb *upcb;

  if (!ip_addr_isany(old_addr) && !ip_addr_isany(new_addr)) {
 80136fa:	687b      	ldr	r3, [r7, #4]
 80136fc:	2b00      	cmp	r3, #0
 80136fe:	d01e      	beq.n	801373e <udp_netif_ip_addr_changed+0x4e>
 8013700:	687b      	ldr	r3, [r7, #4]
 8013702:	681b      	ldr	r3, [r3, #0]
 8013704:	2b00      	cmp	r3, #0
 8013706:	d01a      	beq.n	801373e <udp_netif_ip_addr_changed+0x4e>
 8013708:	683b      	ldr	r3, [r7, #0]
 801370a:	2b00      	cmp	r3, #0
 801370c:	d017      	beq.n	801373e <udp_netif_ip_addr_changed+0x4e>
 801370e:	683b      	ldr	r3, [r7, #0]
 8013710:	681b      	ldr	r3, [r3, #0]
 8013712:	2b00      	cmp	r3, #0
 8013714:	d013      	beq.n	801373e <udp_netif_ip_addr_changed+0x4e>
    for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
 8013716:	4b0c      	ldr	r3, [pc, #48]	; (8013748 <udp_netif_ip_addr_changed+0x58>)
 8013718:	681b      	ldr	r3, [r3, #0]
 801371a:	60fb      	str	r3, [r7, #12]
 801371c:	e00c      	b.n	8013738 <udp_netif_ip_addr_changed+0x48>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&upcb->local_ip, old_addr)) {
 801371e:	68fb      	ldr	r3, [r7, #12]
 8013720:	681a      	ldr	r2, [r3, #0]
 8013722:	687b      	ldr	r3, [r7, #4]
 8013724:	681b      	ldr	r3, [r3, #0]
 8013726:	429a      	cmp	r2, r3
 8013728:	d103      	bne.n	8013732 <udp_netif_ip_addr_changed+0x42>
        /* The PCB is bound to the old ipaddr and
         * is set to bound to the new one instead */
        ip_addr_copy(upcb->local_ip, *new_addr);
 801372a:	683b      	ldr	r3, [r7, #0]
 801372c:	681a      	ldr	r2, [r3, #0]
 801372e:	68fb      	ldr	r3, [r7, #12]
 8013730:	601a      	str	r2, [r3, #0]
    for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
 8013732:	68fb      	ldr	r3, [r7, #12]
 8013734:	691b      	ldr	r3, [r3, #16]
 8013736:	60fb      	str	r3, [r7, #12]
 8013738:	68fb      	ldr	r3, [r7, #12]
 801373a:	2b00      	cmp	r3, #0
 801373c:	d1ef      	bne.n	801371e <udp_netif_ip_addr_changed+0x2e>
      }
    }
  }
}
 801373e:	46c0      	nop			; (mov r8, r8)
 8013740:	46bd      	mov	sp, r7
 8013742:	b004      	add	sp, #16
 8013744:	bd80      	pop	{r7, pc}
 8013746:	46c0      	nop			; (mov r8, r8)
 8013748:	200027a4 	.word	0x200027a4

0801374c <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the icmp header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
 801374c:	b590      	push	{r4, r7, lr}
 801374e:	b08f      	sub	sp, #60	; 0x3c
 8013750:	af04      	add	r7, sp, #16
 8013752:	6078      	str	r0, [r7, #4]
 8013754:	6039      	str	r1, [r7, #0]
  const ip4_addr_t *src;

  ICMP_STATS_INC(icmp.recv);
  MIB2_STATS_INC(mib2.icmpinmsgs);

  iphdr_in = ip4_current_header();
 8013756:	4bde      	ldr	r3, [pc, #888]	; (8013ad0 <icmp_input+0x384>)
 8013758:	689b      	ldr	r3, [r3, #8]
 801375a:	627b      	str	r3, [r7, #36]	; 0x24
  hlen = IPH_HL_BYTES(iphdr_in);
 801375c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801375e:	781b      	ldrb	r3, [r3, #0]
 8013760:	220f      	movs	r2, #15
 8013762:	4013      	ands	r3, r2
 8013764:	b2db      	uxtb	r3, r3
 8013766:	009b      	lsls	r3, r3, #2
 8013768:	b2da      	uxtb	r2, r3
 801376a:	2122      	movs	r1, #34	; 0x22
 801376c:	187b      	adds	r3, r7, r1
 801376e:	801a      	strh	r2, [r3, #0]
  if (hlen < IP_HLEN) {
 8013770:	187b      	adds	r3, r7, r1
 8013772:	881b      	ldrh	r3, [r3, #0]
 8013774:	2b13      	cmp	r3, #19
 8013776:	d800      	bhi.n	801377a <icmp_input+0x2e>
 8013778:	e1a5      	b.n	8013ac6 <icmp_input+0x37a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short IP header (%"S16_F" bytes) received\n", hlen));
    goto lenerr;
  }
  if (p->len < sizeof(u16_t) * 2) {
 801377a:	687b      	ldr	r3, [r7, #4]
 801377c:	895b      	ldrh	r3, [r3, #10]
 801377e:	2b03      	cmp	r3, #3
 8013780:	d800      	bhi.n	8013784 <icmp_input+0x38>
 8013782:	e1a2      	b.n	8013aca <icmp_input+0x37e>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
 8013784:	687b      	ldr	r3, [r7, #4]
 8013786:	685a      	ldr	r2, [r3, #4]
 8013788:	2121      	movs	r1, #33	; 0x21
 801378a:	187b      	adds	r3, r7, r1
 801378c:	7812      	ldrb	r2, [r2, #0]
 801378e:	701a      	strb	r2, [r3, #0]
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload) + 1);
 8013790:	687b      	ldr	r3, [r7, #4]
 8013792:	685a      	ldr	r2, [r3, #4]
 8013794:	2320      	movs	r3, #32
 8013796:	18fb      	adds	r3, r7, r3
 8013798:	7852      	ldrb	r2, [r2, #1]
 801379a:	701a      	strb	r2, [r3, #0]
  /* if debug is enabled but debug statement below is somehow disabled: */
  LWIP_UNUSED_ARG(code);
#endif /* LWIP_DEBUG */
  switch (type) {
 801379c:	187b      	adds	r3, r7, r1
 801379e:	781b      	ldrb	r3, [r3, #0]
 80137a0:	2b00      	cmp	r3, #0
 80137a2:	d100      	bne.n	80137a6 <icmp_input+0x5a>
 80137a4:	e187      	b.n	8013ab6 <icmp_input+0x36a>
 80137a6:	2b08      	cmp	r3, #8
 80137a8:	d000      	beq.n	80137ac <icmp_input+0x60>
 80137aa:	e187      	b.n	8013abc <icmp_input+0x370>
         (as obviously, an echo request has been sent, too). */
      MIB2_STATS_INC(mib2.icmpinechoreps);
      break;
    case ICMP_ECHO:
      MIB2_STATS_INC(mib2.icmpinechos);
      src = ip4_current_dest_addr();
 80137ac:	4bc9      	ldr	r3, [pc, #804]	; (8013ad4 <icmp_input+0x388>)
 80137ae:	61fb      	str	r3, [r7, #28]
      /* multicast destination address? */
      if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
 80137b0:	4bc7      	ldr	r3, [pc, #796]	; (8013ad0 <icmp_input+0x384>)
 80137b2:	695b      	ldr	r3, [r3, #20]
 80137b4:	22f0      	movs	r2, #240	; 0xf0
 80137b6:	4013      	ands	r3, r2
 80137b8:	2be0      	cmp	r3, #224	; 0xe0
 80137ba:	d100      	bne.n	80137be <icmp_input+0x72>
 80137bc:	e19c      	b.n	8013af8 <icmp_input+0x3ac>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast pings\n"));
        goto icmperr;
#endif /* LWIP_MULTICAST_PING */
      }
      /* broadcast destination address? */
      if (ip4_addr_isbroadcast(ip4_current_dest_addr(), ip_current_netif())) {
 80137be:	4bc4      	ldr	r3, [pc, #784]	; (8013ad0 <icmp_input+0x384>)
 80137c0:	695a      	ldr	r2, [r3, #20]
 80137c2:	4bc3      	ldr	r3, [pc, #780]	; (8013ad0 <icmp_input+0x384>)
 80137c4:	681b      	ldr	r3, [r3, #0]
 80137c6:	0019      	movs	r1, r3
 80137c8:	0010      	movs	r0, r2
 80137ca:	f000 fe9d 	bl	8014508 <ip4_addr_isbroadcast_u32>
 80137ce:	1e03      	subs	r3, r0, #0
 80137d0:	d000      	beq.n	80137d4 <icmp_input+0x88>
 80137d2:	e193      	b.n	8013afc <icmp_input+0x3b0>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to broadcast pings\n"));
        goto icmperr;
#endif /* LWIP_BROADCAST_PING */
      }
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
      if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
 80137d4:	687b      	ldr	r3, [r7, #4]
 80137d6:	891b      	ldrh	r3, [r3, #8]
 80137d8:	2b07      	cmp	r3, #7
 80137da:	d800      	bhi.n	80137de <icmp_input+0x92>
 80137dc:	e186      	b.n	8013aec <icmp_input+0x3a0>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
        goto lenerr;
      }
#if CHECKSUM_CHECK_ICMP
      IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_ICMP) {
        if (inet_chksum_pbuf(p) != 0) {
 80137de:	687b      	ldr	r3, [r7, #4]
 80137e0:	0018      	movs	r0, r3
 80137e2:	f7f5 fa0a 	bl	8008bfa <inet_chksum_pbuf>
 80137e6:	1e03      	subs	r3, r0, #0
 80137e8:	d004      	beq.n	80137f4 <icmp_input+0xa8>
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
          pbuf_free(p);
 80137ea:	687b      	ldr	r3, [r7, #4]
 80137ec:	0018      	movs	r0, r3
 80137ee:	f7f6 fe75 	bl	800a4dc <pbuf_free>
          ICMP_STATS_INC(icmp.chkerr);
          MIB2_STATS_INC(mib2.icmpinerrors);
          return;
 80137f2:	e18d      	b.n	8013b10 <icmp_input+0x3c4>
        }
      }
#endif
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
      if (pbuf_add_header(p, hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN)) {
 80137f4:	2422      	movs	r4, #34	; 0x22
 80137f6:	193b      	adds	r3, r7, r4
 80137f8:	881b      	ldrh	r3, [r3, #0]
 80137fa:	3310      	adds	r3, #16
 80137fc:	001a      	movs	r2, r3
 80137fe:	687b      	ldr	r3, [r7, #4]
 8013800:	0011      	movs	r1, r2
 8013802:	0018      	movs	r0, r3
 8013804:	f7f6 fdc4 	bl	800a390 <pbuf_add_header>
 8013808:	1e03      	subs	r3, r0, #0
 801380a:	d05a      	beq.n	80138c2 <icmp_input+0x176>
        /* p is not big enough to contain link headers
         * allocate a new one and copy p into it
         */
        struct pbuf *r;
        u16_t alloc_len = (u16_t)(p->tot_len + hlen);
 801380c:	687b      	ldr	r3, [r7, #4]
 801380e:	8919      	ldrh	r1, [r3, #8]
 8013810:	201a      	movs	r0, #26
 8013812:	183b      	adds	r3, r7, r0
 8013814:	193a      	adds	r2, r7, r4
 8013816:	8812      	ldrh	r2, [r2, #0]
 8013818:	188a      	adds	r2, r1, r2
 801381a:	801a      	strh	r2, [r3, #0]
        if (alloc_len < p->tot_len) {
 801381c:	687b      	ldr	r3, [r7, #4]
 801381e:	891b      	ldrh	r3, [r3, #8]
 8013820:	183a      	adds	r2, r7, r0
 8013822:	8812      	ldrh	r2, [r2, #0]
 8013824:	429a      	cmp	r2, r3
 8013826:	d200      	bcs.n	801382a <icmp_input+0xde>
 8013828:	e16a      	b.n	8013b00 <icmp_input+0x3b4>
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed (tot_len overflow)\n"));
          goto icmperr;
        }
        /* allocate new packet buffer with space for link headers */
        r = pbuf_alloc(PBUF_LINK, alloc_len, PBUF_RAM);
 801382a:	23a0      	movs	r3, #160	; 0xa0
 801382c:	009a      	lsls	r2, r3, #2
 801382e:	183b      	adds	r3, r7, r0
 8013830:	881b      	ldrh	r3, [r3, #0]
 8013832:	0019      	movs	r1, r3
 8013834:	2010      	movs	r0, #16
 8013836:	f7f6 fb1b 	bl	8009e70 <pbuf_alloc>
 801383a:	0003      	movs	r3, r0
 801383c:	617b      	str	r3, [r7, #20]
        if (r == NULL) {
 801383e:	697b      	ldr	r3, [r7, #20]
 8013840:	2b00      	cmp	r3, #0
 8013842:	d100      	bne.n	8013846 <icmp_input+0xfa>
 8013844:	e15e      	b.n	8013b04 <icmp_input+0x3b8>
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
          goto icmperr;
        }
        if (r->len < hlen + sizeof(struct icmp_echo_hdr)) {
 8013846:	697b      	ldr	r3, [r7, #20]
 8013848:	895b      	ldrh	r3, [r3, #10]
 801384a:	001a      	movs	r2, r3
 801384c:	193b      	adds	r3, r7, r4
 801384e:	881b      	ldrh	r3, [r3, #0]
 8013850:	3308      	adds	r3, #8
 8013852:	429a      	cmp	r2, r3
 8013854:	d204      	bcs.n	8013860 <icmp_input+0x114>
          LWIP_DEBUGF(ICMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("first pbuf cannot hold the ICMP header"));
          pbuf_free(r);
 8013856:	697b      	ldr	r3, [r7, #20]
 8013858:	0018      	movs	r0, r3
 801385a:	f7f6 fe3f 	bl	800a4dc <pbuf_free>
          goto icmperr;
 801385e:	e152      	b.n	8013b06 <icmp_input+0x3ba>
        }
        /* copy the ip header */
        MEMCPY(r->payload, iphdr_in, hlen);
 8013860:	697b      	ldr	r3, [r7, #20]
 8013862:	6858      	ldr	r0, [r3, #4]
 8013864:	2422      	movs	r4, #34	; 0x22
 8013866:	193b      	adds	r3, r7, r4
 8013868:	881a      	ldrh	r2, [r3, #0]
 801386a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801386c:	0019      	movs	r1, r3
 801386e:	f00a fb95 	bl	801df9c <memcpy>
        /* switch r->payload back to icmp header (cannot fail) */
        if (pbuf_remove_header(r, hlen)) {
 8013872:	193b      	adds	r3, r7, r4
 8013874:	881a      	ldrh	r2, [r3, #0]
 8013876:	697b      	ldr	r3, [r7, #20]
 8013878:	0011      	movs	r1, r2
 801387a:	0018      	movs	r0, r3
 801387c:	f7f6 fd98 	bl	800a3b0 <pbuf_remove_header>
 8013880:	1e03      	subs	r3, r0, #0
 8013882:	d00a      	beq.n	801389a <icmp_input+0x14e>
          LWIP_ASSERT("icmp_input: moving r->payload to icmp header failed\n", 0);
 8013884:	4b94      	ldr	r3, [pc, #592]	; (8013ad8 <icmp_input+0x38c>)
 8013886:	4995      	ldr	r1, [pc, #596]	; (8013adc <icmp_input+0x390>)
 8013888:	4895      	ldr	r0, [pc, #596]	; (8013ae0 <icmp_input+0x394>)
 801388a:	22b6      	movs	r2, #182	; 0xb6
 801388c:	f7ee fcaa 	bl	80021e4 <app_debug_rtt_raw>
          pbuf_free(r);
 8013890:	697b      	ldr	r3, [r7, #20]
 8013892:	0018      	movs	r0, r3
 8013894:	f7f6 fe22 	bl	800a4dc <pbuf_free>
          goto icmperr;
 8013898:	e135      	b.n	8013b06 <icmp_input+0x3ba>
        }
        /* copy the rest of the packet without ip header */
        if (pbuf_copy(r, p) != ERR_OK) {
 801389a:	687a      	ldr	r2, [r7, #4]
 801389c:	697b      	ldr	r3, [r7, #20]
 801389e:	0011      	movs	r1, r2
 80138a0:	0018      	movs	r0, r3
 80138a2:	f7f6 ffbd 	bl	800a820 <pbuf_copy>
 80138a6:	1e03      	subs	r3, r0, #0
 80138a8:	d004      	beq.n	80138b4 <icmp_input+0x168>
          LWIP_DEBUGF(ICMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("icmp_input: copying to new pbuf failed"));
          pbuf_free(r);
 80138aa:	697b      	ldr	r3, [r7, #20]
 80138ac:	0018      	movs	r0, r3
 80138ae:	f7f6 fe15 	bl	800a4dc <pbuf_free>
          goto icmperr;
 80138b2:	e128      	b.n	8013b06 <icmp_input+0x3ba>
        }
        /* free the original p */
        pbuf_free(p);
 80138b4:	687b      	ldr	r3, [r7, #4]
 80138b6:	0018      	movs	r0, r3
 80138b8:	f7f6 fe10 	bl	800a4dc <pbuf_free>
        /* we now have an identical copy of p that has room for link headers */
        p = r;
 80138bc:	697b      	ldr	r3, [r7, #20]
 80138be:	607b      	str	r3, [r7, #4]
 80138c0:	e012      	b.n	80138e8 <icmp_input+0x19c>
      } else {
        /* restore p->payload to point to icmp header (cannot fail) */
        if (pbuf_remove_header(p, hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN)) {
 80138c2:	2322      	movs	r3, #34	; 0x22
 80138c4:	18fb      	adds	r3, r7, r3
 80138c6:	881b      	ldrh	r3, [r3, #0]
 80138c8:	3310      	adds	r3, #16
 80138ca:	001a      	movs	r2, r3
 80138cc:	687b      	ldr	r3, [r7, #4]
 80138ce:	0011      	movs	r1, r2
 80138d0:	0018      	movs	r0, r3
 80138d2:	f7f6 fd6d 	bl	800a3b0 <pbuf_remove_header>
 80138d6:	1e03      	subs	r3, r0, #0
 80138d8:	d006      	beq.n	80138e8 <icmp_input+0x19c>
          LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
 80138da:	4b7f      	ldr	r3, [pc, #508]	; (8013ad8 <icmp_input+0x38c>)
 80138dc:	4981      	ldr	r1, [pc, #516]	; (8013ae4 <icmp_input+0x398>)
 80138de:	4880      	ldr	r0, [pc, #512]	; (8013ae0 <icmp_input+0x394>)
 80138e0:	22c7      	movs	r2, #199	; 0xc7
 80138e2:	f7ee fc7f 	bl	80021e4 <app_debug_rtt_raw>
          goto icmperr;
 80138e6:	e10e      	b.n	8013b06 <icmp_input+0x3ba>
      }
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
      /* At this point, all checks are OK. */
      /* We generate an answer by switching the dest and src ip addresses,
       * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
      iecho = (struct icmp_echo_hdr *)p->payload;
 80138e8:	687b      	ldr	r3, [r7, #4]
 80138ea:	685b      	ldr	r3, [r3, #4]
 80138ec:	613b      	str	r3, [r7, #16]
      if (pbuf_add_header(p, hlen)) {
 80138ee:	2322      	movs	r3, #34	; 0x22
 80138f0:	18fb      	adds	r3, r7, r3
 80138f2:	881a      	ldrh	r2, [r3, #0]
 80138f4:	687b      	ldr	r3, [r7, #4]
 80138f6:	0011      	movs	r1, r2
 80138f8:	0018      	movs	r0, r3
 80138fa:	f7f6 fd49 	bl	800a390 <pbuf_add_header>
 80138fe:	1e03      	subs	r3, r0, #0
 8013900:	d000      	beq.n	8013904 <icmp_input+0x1b8>
 8013902:	e0da      	b.n	8013aba <icmp_input+0x36e>
        LWIP_DEBUGF(ICMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Can't move over header in packet"));
      } else {
        err_t ret;
        struct ip_hdr *iphdr = (struct ip_hdr *)p->payload;
 8013904:	687b      	ldr	r3, [r7, #4]
 8013906:	685b      	ldr	r3, [r3, #4]
 8013908:	60fb      	str	r3, [r7, #12]
        ip4_addr_copy(iphdr->src, *src);
 801390a:	69fb      	ldr	r3, [r7, #28]
 801390c:	681a      	ldr	r2, [r3, #0]
 801390e:	68fb      	ldr	r3, [r7, #12]
 8013910:	21ff      	movs	r1, #255	; 0xff
 8013912:	4011      	ands	r1, r2
 8013914:	000c      	movs	r4, r1
 8013916:	7b19      	ldrb	r1, [r3, #12]
 8013918:	2000      	movs	r0, #0
 801391a:	4001      	ands	r1, r0
 801391c:	1c08      	adds	r0, r1, #0
 801391e:	1c21      	adds	r1, r4, #0
 8013920:	4301      	orrs	r1, r0
 8013922:	7319      	strb	r1, [r3, #12]
 8013924:	0a11      	lsrs	r1, r2, #8
 8013926:	20ff      	movs	r0, #255	; 0xff
 8013928:	4001      	ands	r1, r0
 801392a:	000c      	movs	r4, r1
 801392c:	7b59      	ldrb	r1, [r3, #13]
 801392e:	2000      	movs	r0, #0
 8013930:	4001      	ands	r1, r0
 8013932:	1c08      	adds	r0, r1, #0
 8013934:	1c21      	adds	r1, r4, #0
 8013936:	4301      	orrs	r1, r0
 8013938:	7359      	strb	r1, [r3, #13]
 801393a:	0c11      	lsrs	r1, r2, #16
 801393c:	20ff      	movs	r0, #255	; 0xff
 801393e:	4001      	ands	r1, r0
 8013940:	000c      	movs	r4, r1
 8013942:	7b99      	ldrb	r1, [r3, #14]
 8013944:	2000      	movs	r0, #0
 8013946:	4001      	ands	r1, r0
 8013948:	1c08      	adds	r0, r1, #0
 801394a:	1c21      	adds	r1, r4, #0
 801394c:	4301      	orrs	r1, r0
 801394e:	7399      	strb	r1, [r3, #14]
 8013950:	0e10      	lsrs	r0, r2, #24
 8013952:	7bda      	ldrb	r2, [r3, #15]
 8013954:	2100      	movs	r1, #0
 8013956:	400a      	ands	r2, r1
 8013958:	1c11      	adds	r1, r2, #0
 801395a:	1c02      	adds	r2, r0, #0
 801395c:	430a      	orrs	r2, r1
 801395e:	73da      	strb	r2, [r3, #15]
        ip4_addr_copy(iphdr->dest, *ip4_current_src_addr());
 8013960:	4b5b      	ldr	r3, [pc, #364]	; (8013ad0 <icmp_input+0x384>)
 8013962:	691a      	ldr	r2, [r3, #16]
 8013964:	68fb      	ldr	r3, [r7, #12]
 8013966:	21ff      	movs	r1, #255	; 0xff
 8013968:	4011      	ands	r1, r2
 801396a:	000c      	movs	r4, r1
 801396c:	7c19      	ldrb	r1, [r3, #16]
 801396e:	2000      	movs	r0, #0
 8013970:	4001      	ands	r1, r0
 8013972:	1c08      	adds	r0, r1, #0
 8013974:	1c21      	adds	r1, r4, #0
 8013976:	4301      	orrs	r1, r0
 8013978:	7419      	strb	r1, [r3, #16]
 801397a:	0a11      	lsrs	r1, r2, #8
 801397c:	20ff      	movs	r0, #255	; 0xff
 801397e:	4001      	ands	r1, r0
 8013980:	000c      	movs	r4, r1
 8013982:	7c59      	ldrb	r1, [r3, #17]
 8013984:	2000      	movs	r0, #0
 8013986:	4001      	ands	r1, r0
 8013988:	1c08      	adds	r0, r1, #0
 801398a:	1c21      	adds	r1, r4, #0
 801398c:	4301      	orrs	r1, r0
 801398e:	7459      	strb	r1, [r3, #17]
 8013990:	0c11      	lsrs	r1, r2, #16
 8013992:	20ff      	movs	r0, #255	; 0xff
 8013994:	4001      	ands	r1, r0
 8013996:	000c      	movs	r4, r1
 8013998:	7c99      	ldrb	r1, [r3, #18]
 801399a:	2000      	movs	r0, #0
 801399c:	4001      	ands	r1, r0
 801399e:	1c08      	adds	r0, r1, #0
 80139a0:	1c21      	adds	r1, r4, #0
 80139a2:	4301      	orrs	r1, r0
 80139a4:	7499      	strb	r1, [r3, #18]
 80139a6:	0e10      	lsrs	r0, r2, #24
 80139a8:	7cda      	ldrb	r2, [r3, #19]
 80139aa:	2100      	movs	r1, #0
 80139ac:	400a      	ands	r2, r1
 80139ae:	1c11      	adds	r1, r2, #0
 80139b0:	1c02      	adds	r2, r0, #0
 80139b2:	430a      	orrs	r2, r1
 80139b4:	74da      	strb	r2, [r3, #19]
        ICMPH_TYPE_SET(iecho, ICMP_ER);
 80139b6:	693b      	ldr	r3, [r7, #16]
 80139b8:	2200      	movs	r2, #0
 80139ba:	701a      	strb	r2, [r3, #0]
#if CHECKSUM_GEN_ICMP
        IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_GEN_ICMP) {
          /* adjust the checksum */
          if (iecho->chksum > PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
 80139bc:	693b      	ldr	r3, [r7, #16]
 80139be:	789a      	ldrb	r2, [r3, #2]
 80139c0:	78db      	ldrb	r3, [r3, #3]
 80139c2:	021b      	lsls	r3, r3, #8
 80139c4:	4313      	orrs	r3, r2
 80139c6:	b29b      	uxth	r3, r3
 80139c8:	4a47      	ldr	r2, [pc, #284]	; (8013ae8 <icmp_input+0x39c>)
 80139ca:	4293      	cmp	r3, r2
 80139cc:	d91c      	bls.n	8013a08 <icmp_input+0x2bc>
            iecho->chksum = (u16_t)(iecho->chksum + PP_HTONS((u16_t)(ICMP_ECHO << 8)) + 1);
 80139ce:	693b      	ldr	r3, [r7, #16]
 80139d0:	789a      	ldrb	r2, [r3, #2]
 80139d2:	78db      	ldrb	r3, [r3, #3]
 80139d4:	021b      	lsls	r3, r3, #8
 80139d6:	4313      	orrs	r3, r2
 80139d8:	b29b      	uxth	r3, r3
 80139da:	3309      	adds	r3, #9
 80139dc:	b29a      	uxth	r2, r3
 80139de:	693b      	ldr	r3, [r7, #16]
 80139e0:	21ff      	movs	r1, #255	; 0xff
 80139e2:	4011      	ands	r1, r2
 80139e4:	000c      	movs	r4, r1
 80139e6:	7899      	ldrb	r1, [r3, #2]
 80139e8:	2000      	movs	r0, #0
 80139ea:	4001      	ands	r1, r0
 80139ec:	1c08      	adds	r0, r1, #0
 80139ee:	1c21      	adds	r1, r4, #0
 80139f0:	4301      	orrs	r1, r0
 80139f2:	7099      	strb	r1, [r3, #2]
 80139f4:	0a12      	lsrs	r2, r2, #8
 80139f6:	b290      	uxth	r0, r2
 80139f8:	78da      	ldrb	r2, [r3, #3]
 80139fa:	2100      	movs	r1, #0
 80139fc:	400a      	ands	r2, r1
 80139fe:	1c11      	adds	r1, r2, #0
 8013a00:	1c02      	adds	r2, r0, #0
 8013a02:	430a      	orrs	r2, r1
 8013a04:	70da      	strb	r2, [r3, #3]
 8013a06:	e01b      	b.n	8013a40 <icmp_input+0x2f4>
          } else {
            iecho->chksum = (u16_t)(iecho->chksum + PP_HTONS(ICMP_ECHO << 8));
 8013a08:	693b      	ldr	r3, [r7, #16]
 8013a0a:	789a      	ldrb	r2, [r3, #2]
 8013a0c:	78db      	ldrb	r3, [r3, #3]
 8013a0e:	021b      	lsls	r3, r3, #8
 8013a10:	4313      	orrs	r3, r2
 8013a12:	b29b      	uxth	r3, r3
 8013a14:	3308      	adds	r3, #8
 8013a16:	b29a      	uxth	r2, r3
 8013a18:	693b      	ldr	r3, [r7, #16]
 8013a1a:	21ff      	movs	r1, #255	; 0xff
 8013a1c:	4011      	ands	r1, r2
 8013a1e:	000c      	movs	r4, r1
 8013a20:	7899      	ldrb	r1, [r3, #2]
 8013a22:	2000      	movs	r0, #0
 8013a24:	4001      	ands	r1, r0
 8013a26:	1c08      	adds	r0, r1, #0
 8013a28:	1c21      	adds	r1, r4, #0
 8013a2a:	4301      	orrs	r1, r0
 8013a2c:	7099      	strb	r1, [r3, #2]
 8013a2e:	0a12      	lsrs	r2, r2, #8
 8013a30:	b290      	uxth	r0, r2
 8013a32:	78da      	ldrb	r2, [r3, #3]
 8013a34:	2100      	movs	r1, #0
 8013a36:	400a      	ands	r2, r1
 8013a38:	1c11      	adds	r1, r2, #0
 8013a3a:	1c02      	adds	r2, r0, #0
 8013a3c:	430a      	orrs	r2, r1
 8013a3e:	70da      	strb	r2, [r3, #3]
#else /* CHECKSUM_GEN_ICMP */
        iecho->chksum = 0;
#endif /* CHECKSUM_GEN_ICMP */

        /* Set the correct TTL and recalculate the header checksum. */
        IPH_TTL_SET(iphdr, ICMP_TTL);
 8013a40:	68fb      	ldr	r3, [r7, #12]
 8013a42:	22ff      	movs	r2, #255	; 0xff
 8013a44:	721a      	strb	r2, [r3, #8]
        IPH_CHKSUM_SET(iphdr, 0);
 8013a46:	68fb      	ldr	r3, [r7, #12]
 8013a48:	7a9a      	ldrb	r2, [r3, #10]
 8013a4a:	2100      	movs	r1, #0
 8013a4c:	400a      	ands	r2, r1
 8013a4e:	729a      	strb	r2, [r3, #10]
 8013a50:	7ada      	ldrb	r2, [r3, #11]
 8013a52:	2100      	movs	r1, #0
 8013a54:	400a      	ands	r2, r1
 8013a56:	72da      	strb	r2, [r3, #11]
#if CHECKSUM_GEN_IP
        IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_GEN_IP) {
          IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, hlen));
 8013a58:	2322      	movs	r3, #34	; 0x22
 8013a5a:	18fb      	adds	r3, r7, r3
 8013a5c:	881a      	ldrh	r2, [r3, #0]
 8013a5e:	68fb      	ldr	r3, [r7, #12]
 8013a60:	0011      	movs	r1, r2
 8013a62:	0018      	movs	r0, r3
 8013a64:	f7f5 f8b4 	bl	8008bd0 <inet_chksum>
 8013a68:	0003      	movs	r3, r0
 8013a6a:	001a      	movs	r2, r3
 8013a6c:	68fb      	ldr	r3, [r7, #12]
 8013a6e:	21ff      	movs	r1, #255	; 0xff
 8013a70:	4011      	ands	r1, r2
 8013a72:	000c      	movs	r4, r1
 8013a74:	7a99      	ldrb	r1, [r3, #10]
 8013a76:	2000      	movs	r0, #0
 8013a78:	4001      	ands	r1, r0
 8013a7a:	1c08      	adds	r0, r1, #0
 8013a7c:	1c21      	adds	r1, r4, #0
 8013a7e:	4301      	orrs	r1, r0
 8013a80:	7299      	strb	r1, [r3, #10]
 8013a82:	0a12      	lsrs	r2, r2, #8
 8013a84:	b290      	uxth	r0, r2
 8013a86:	7ada      	ldrb	r2, [r3, #11]
 8013a88:	2100      	movs	r1, #0
 8013a8a:	400a      	ands	r2, r1
 8013a8c:	1c11      	adds	r1, r2, #0
 8013a8e:	1c02      	adds	r2, r0, #0
 8013a90:	430a      	orrs	r2, r1
 8013a92:	72da      	strb	r2, [r3, #11]
        MIB2_STATS_INC(mib2.icmpoutmsgs);
        /* increase number of echo replies attempted to send */
        MIB2_STATS_INC(mib2.icmpoutechoreps);

        /* send an ICMP packet */
        ret = ip4_output_if(p, src, LWIP_IP_HDRINCL,
 8013a94:	230b      	movs	r3, #11
 8013a96:	18fc      	adds	r4, r7, r3
 8013a98:	69f9      	ldr	r1, [r7, #28]
 8013a9a:	6878      	ldr	r0, [r7, #4]
 8013a9c:	683b      	ldr	r3, [r7, #0]
 8013a9e:	9302      	str	r3, [sp, #8]
 8013aa0:	2301      	movs	r3, #1
 8013aa2:	9301      	str	r3, [sp, #4]
 8013aa4:	2300      	movs	r3, #0
 8013aa6:	9300      	str	r3, [sp, #0]
 8013aa8:	23ff      	movs	r3, #255	; 0xff
 8013aaa:	2200      	movs	r2, #0
 8013aac:	f000 fb06 	bl	80140bc <ip4_output_if>
 8013ab0:	0003      	movs	r3, r0
 8013ab2:	7023      	strb	r3, [r4, #0]
                            ICMP_TTL, 0, IP_PROTO_ICMP, inp);
        if (ret != ERR_OK) {
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %s\n", lwip_strerr(ret)));
        }
      }
      break;
 8013ab4:	e001      	b.n	8013aba <icmp_input+0x36e>
      break;
 8013ab6:	46c0      	nop			; (mov r8, r8)
 8013ab8:	e000      	b.n	8013abc <icmp_input+0x370>
      break;
 8013aba:	46c0      	nop			; (mov r8, r8)
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n",
                               (s16_t)type, (s16_t)code));
      ICMP_STATS_INC(icmp.proterr);
      ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
 8013abc:	687b      	ldr	r3, [r7, #4]
 8013abe:	0018      	movs	r0, r3
 8013ac0:	f7f6 fd0c 	bl	800a4dc <pbuf_free>
  return;
 8013ac4:	e024      	b.n	8013b10 <icmp_input+0x3c4>
    goto lenerr;
 8013ac6:	46c0      	nop			; (mov r8, r8)
 8013ac8:	e011      	b.n	8013aee <icmp_input+0x3a2>
    goto lenerr;
 8013aca:	46c0      	nop			; (mov r8, r8)
 8013acc:	e00f      	b.n	8013aee <icmp_input+0x3a2>
 8013ace:	46c0      	nop			; (mov r8, r8)
 8013ad0:	20001138 	.word	0x20001138
 8013ad4:	2000114c 	.word	0x2000114c
 8013ad8:	08022424 	.word	0x08022424
 8013adc:	08022450 	.word	0x08022450
 8013ae0:	08022488 	.word	0x08022488
 8013ae4:	080224b4 	.word	0x080224b4
 8013ae8:	0000fff7 	.word	0x0000fff7
        goto lenerr;
 8013aec:	46c0      	nop			; (mov r8, r8)
lenerr:
  pbuf_free(p);
 8013aee:	687b      	ldr	r3, [r7, #4]
 8013af0:	0018      	movs	r0, r3
 8013af2:	f7f6 fcf3 	bl	800a4dc <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  MIB2_STATS_INC(mib2.icmpinerrors);
  return;
 8013af6:	e00b      	b.n	8013b10 <icmp_input+0x3c4>
        goto icmperr;
 8013af8:	46c0      	nop			; (mov r8, r8)
 8013afa:	e004      	b.n	8013b06 <icmp_input+0x3ba>
        goto icmperr;
 8013afc:	46c0      	nop			; (mov r8, r8)
 8013afe:	e002      	b.n	8013b06 <icmp_input+0x3ba>
          goto icmperr;
 8013b00:	46c0      	nop			; (mov r8, r8)
 8013b02:	e000      	b.n	8013b06 <icmp_input+0x3ba>
          goto icmperr;
 8013b04:	46c0      	nop			; (mov r8, r8)
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN || !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
icmperr:
  pbuf_free(p);
 8013b06:	687b      	ldr	r3, [r7, #4]
 8013b08:	0018      	movs	r0, r3
 8013b0a:	f7f6 fce7 	bl	800a4dc <pbuf_free>
  ICMP_STATS_INC(icmp.err);
  MIB2_STATS_INC(mib2.icmpinerrors);
  return;
 8013b0e:	46c0      	nop			; (mov r8, r8)
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN || !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
}
 8013b10:	46bd      	mov	sp, r7
 8013b12:	b00b      	add	sp, #44	; 0x2c
 8013b14:	bd90      	pop	{r4, r7, pc}
 8013b16:	46c0      	nop			; (mov r8, r8)

08013b18 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
 8013b18:	b580      	push	{r7, lr}
 8013b1a:	b082      	sub	sp, #8
 8013b1c:	af00      	add	r7, sp, #0
 8013b1e:	6078      	str	r0, [r7, #4]
 8013b20:	000a      	movs	r2, r1
 8013b22:	1cfb      	adds	r3, r7, #3
 8013b24:	701a      	strb	r2, [r3, #0]
  MIB2_STATS_INC(mib2.icmpoutdestunreachs);
  icmp_send_response(p, ICMP_DUR, t);
 8013b26:	1cfb      	adds	r3, r7, #3
 8013b28:	781a      	ldrb	r2, [r3, #0]
 8013b2a:	687b      	ldr	r3, [r7, #4]
 8013b2c:	2103      	movs	r1, #3
 8013b2e:	0018      	movs	r0, r3
 8013b30:	f000 f804 	bl	8013b3c <icmp_send_response>
}
 8013b34:	46c0      	nop			; (mov r8, r8)
 8013b36:	46bd      	mov	sp, r7
 8013b38:	b002      	add	sp, #8
 8013b3a:	bd80      	pop	{r7, pc}

08013b3c <icmp_send_response>:
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
 8013b3c:	b5b0      	push	{r4, r5, r7, lr}
 8013b3e:	b08c      	sub	sp, #48	; 0x30
 8013b40:	af04      	add	r7, sp, #16
 8013b42:	6078      	str	r0, [r7, #4]
 8013b44:	0008      	movs	r0, r1
 8013b46:	0011      	movs	r1, r2
 8013b48:	1cfb      	adds	r3, r7, #3
 8013b4a:	1c02      	adds	r2, r0, #0
 8013b4c:	701a      	strb	r2, [r3, #0]
 8013b4e:	1cbb      	adds	r3, r7, #2
 8013b50:	1c0a      	adds	r2, r1, #0
 8013b52:	701a      	strb	r2, [r3, #0]

  /* increase number of messages attempted to send */
  MIB2_STATS_INC(mib2.icmpoutmsgs);

  /* Keep IP header + up to 8 bytes */
  response_pkt_len = IP_HLEN + ICMP_DEST_UNREACH_DATASIZE;
 8013b54:	211a      	movs	r1, #26
 8013b56:	187b      	adds	r3, r7, r1
 8013b58:	221c      	movs	r2, #28
 8013b5a:	801a      	strh	r2, [r3, #0]
  if (p->tot_len < response_pkt_len) {
 8013b5c:	687b      	ldr	r3, [r7, #4]
 8013b5e:	891b      	ldrh	r3, [r3, #8]
 8013b60:	187a      	adds	r2, r7, r1
 8013b62:	8812      	ldrh	r2, [r2, #0]
 8013b64:	429a      	cmp	r2, r3
 8013b66:	d903      	bls.n	8013b70 <icmp_send_response+0x34>
    response_pkt_len = p->tot_len;
 8013b68:	187b      	adds	r3, r7, r1
 8013b6a:	687a      	ldr	r2, [r7, #4]
 8013b6c:	8912      	ldrh	r2, [r2, #8]
 8013b6e:	801a      	strh	r2, [r3, #0]
  }

  /* ICMP header + part of original packet */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + response_pkt_len, PBUF_RAM);
 8013b70:	241a      	movs	r4, #26
 8013b72:	193b      	adds	r3, r7, r4
 8013b74:	881b      	ldrh	r3, [r3, #0]
 8013b76:	3308      	adds	r3, #8
 8013b78:	b29b      	uxth	r3, r3
 8013b7a:	22a0      	movs	r2, #160	; 0xa0
 8013b7c:	0092      	lsls	r2, r2, #2
 8013b7e:	0019      	movs	r1, r3
 8013b80:	2024      	movs	r0, #36	; 0x24
 8013b82:	f7f6 f975 	bl	8009e70 <pbuf_alloc>
 8013b86:	0003      	movs	r3, r0
 8013b88:	617b      	str	r3, [r7, #20]
  if (q == NULL) {
 8013b8a:	697b      	ldr	r3, [r7, #20]
 8013b8c:	2b00      	cmp	r3, #0
 8013b8e:	d100      	bne.n	8013b92 <icmp_send_response+0x56>
 8013b90:	e087      	b.n	8013ca2 <icmp_send_response+0x166>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    MIB2_STATS_INC(mib2.icmpouterrors);
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
 8013b92:	697b      	ldr	r3, [r7, #20]
 8013b94:	895b      	ldrh	r3, [r3, #10]
 8013b96:	001a      	movs	r2, r3
 8013b98:	193b      	adds	r3, r7, r4
 8013b9a:	881b      	ldrh	r3, [r3, #0]
 8013b9c:	3308      	adds	r3, #8
 8013b9e:	429a      	cmp	r2, r3
 8013ba0:	d206      	bcs.n	8013bb0 <icmp_send_response+0x74>
 8013ba2:	4b42      	ldr	r3, [pc, #264]	; (8013cac <icmp_send_response+0x170>)
 8013ba4:	22b7      	movs	r2, #183	; 0xb7
 8013ba6:	0052      	lsls	r2, r2, #1
 8013ba8:	4941      	ldr	r1, [pc, #260]	; (8013cb0 <icmp_send_response+0x174>)
 8013baa:	4842      	ldr	r0, [pc, #264]	; (8013cb4 <icmp_send_response+0x178>)
 8013bac:	f7ee fb1a 	bl	80021e4 <app_debug_rtt_raw>
              (q->len >= (sizeof(struct icmp_echo_hdr) + response_pkt_len)));

  iphdr = (struct ip_hdr *)p->payload;
 8013bb0:	687b      	ldr	r3, [r7, #4]
 8013bb2:	685b      	ldr	r3, [r3, #4]
 8013bb4:	613b      	str	r3, [r7, #16]
  ip4_addr_debug_print_val(ICMP_DEBUG, iphdr->src);
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip4_addr_debug_print_val(ICMP_DEBUG, iphdr->dest);
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
 8013bb6:	697b      	ldr	r3, [r7, #20]
 8013bb8:	685b      	ldr	r3, [r3, #4]
 8013bba:	60fb      	str	r3, [r7, #12]
  icmphdr->type = type;
 8013bbc:	68fb      	ldr	r3, [r7, #12]
 8013bbe:	1cfa      	adds	r2, r7, #3
 8013bc0:	7812      	ldrb	r2, [r2, #0]
 8013bc2:	701a      	strb	r2, [r3, #0]
  icmphdr->code = code;
 8013bc4:	68fb      	ldr	r3, [r7, #12]
 8013bc6:	1cba      	adds	r2, r7, #2
 8013bc8:	7812      	ldrb	r2, [r2, #0]
 8013bca:	705a      	strb	r2, [r3, #1]
  icmphdr->id = 0;
 8013bcc:	68fb      	ldr	r3, [r7, #12]
 8013bce:	791a      	ldrb	r2, [r3, #4]
 8013bd0:	2100      	movs	r1, #0
 8013bd2:	400a      	ands	r2, r1
 8013bd4:	711a      	strb	r2, [r3, #4]
 8013bd6:	795a      	ldrb	r2, [r3, #5]
 8013bd8:	2100      	movs	r1, #0
 8013bda:	400a      	ands	r2, r1
 8013bdc:	715a      	strb	r2, [r3, #5]
  icmphdr->seqno = 0;
 8013bde:	68fb      	ldr	r3, [r7, #12]
 8013be0:	799a      	ldrb	r2, [r3, #6]
 8013be2:	2100      	movs	r1, #0
 8013be4:	400a      	ands	r2, r1
 8013be6:	719a      	strb	r2, [r3, #6]
 8013be8:	79da      	ldrb	r2, [r3, #7]
 8013bea:	2100      	movs	r1, #0
 8013bec:	400a      	ands	r2, r1
 8013bee:	71da      	strb	r2, [r3, #7]

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 8013bf0:	697b      	ldr	r3, [r7, #20]
 8013bf2:	685b      	ldr	r3, [r3, #4]
 8013bf4:	3308      	adds	r3, #8
 8013bf6:	0018      	movs	r0, r3
 8013bf8:	687b      	ldr	r3, [r7, #4]
 8013bfa:	6859      	ldr	r1, [r3, #4]
 8013bfc:	231a      	movs	r3, #26
 8013bfe:	18fb      	adds	r3, r7, r3
 8013c00:	881b      	ldrh	r3, [r3, #0]
 8013c02:	001a      	movs	r2, r3
 8013c04:	f00a f9ca 	bl	801df9c <memcpy>
          response_pkt_len);

  ip4_addr_copy(iphdr_src, iphdr->src);
 8013c08:	693b      	ldr	r3, [r7, #16]
 8013c0a:	7b1a      	ldrb	r2, [r3, #12]
 8013c0c:	7b59      	ldrb	r1, [r3, #13]
 8013c0e:	0209      	lsls	r1, r1, #8
 8013c10:	430a      	orrs	r2, r1
 8013c12:	7b99      	ldrb	r1, [r3, #14]
 8013c14:	0409      	lsls	r1, r1, #16
 8013c16:	430a      	orrs	r2, r1
 8013c18:	7bdb      	ldrb	r3, [r3, #15]
 8013c1a:	061b      	lsls	r3, r3, #24
 8013c1c:	4313      	orrs	r3, r2
 8013c1e:	60bb      	str	r3, [r7, #8]
    ip4_addr_t iphdr_dst;
    ip4_addr_copy(iphdr_dst, iphdr->dest);
    netif = ip4_route_src(&iphdr_dst, &iphdr_src);
  }
#else
  netif = ip4_route(&iphdr_src);
 8013c20:	2508      	movs	r5, #8
 8013c22:	197b      	adds	r3, r7, r5
 8013c24:	0018      	movs	r0, r3
 8013c26:	f000 f847 	bl	8013cb8 <ip4_route>
 8013c2a:	0003      	movs	r3, r0
 8013c2c:	61fb      	str	r3, [r7, #28]
#endif
  if (netif != NULL) {
 8013c2e:	69fb      	ldr	r3, [r7, #28]
 8013c30:	2b00      	cmp	r3, #0
 8013c32:	d031      	beq.n	8013c98 <icmp_send_response+0x15c>
    /* calculate checksum */
    icmphdr->chksum = 0;
 8013c34:	68fb      	ldr	r3, [r7, #12]
 8013c36:	789a      	ldrb	r2, [r3, #2]
 8013c38:	2100      	movs	r1, #0
 8013c3a:	400a      	ands	r2, r1
 8013c3c:	709a      	strb	r2, [r3, #2]
 8013c3e:	78da      	ldrb	r2, [r3, #3]
 8013c40:	2100      	movs	r1, #0
 8013c42:	400a      	ands	r2, r1
 8013c44:	70da      	strb	r2, [r3, #3]
#if CHECKSUM_GEN_ICMP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_ICMP) {
      icmphdr->chksum = inet_chksum(icmphdr, q->len);
 8013c46:	697b      	ldr	r3, [r7, #20]
 8013c48:	895a      	ldrh	r2, [r3, #10]
 8013c4a:	68fb      	ldr	r3, [r7, #12]
 8013c4c:	0011      	movs	r1, r2
 8013c4e:	0018      	movs	r0, r3
 8013c50:	f7f4 ffbe 	bl	8008bd0 <inet_chksum>
 8013c54:	0003      	movs	r3, r0
 8013c56:	001a      	movs	r2, r3
 8013c58:	68fb      	ldr	r3, [r7, #12]
 8013c5a:	21ff      	movs	r1, #255	; 0xff
 8013c5c:	4011      	ands	r1, r2
 8013c5e:	000c      	movs	r4, r1
 8013c60:	7899      	ldrb	r1, [r3, #2]
 8013c62:	2000      	movs	r0, #0
 8013c64:	4001      	ands	r1, r0
 8013c66:	1c08      	adds	r0, r1, #0
 8013c68:	1c21      	adds	r1, r4, #0
 8013c6a:	4301      	orrs	r1, r0
 8013c6c:	7099      	strb	r1, [r3, #2]
 8013c6e:	0a12      	lsrs	r2, r2, #8
 8013c70:	b290      	uxth	r0, r2
 8013c72:	78da      	ldrb	r2, [r3, #3]
 8013c74:	2100      	movs	r1, #0
 8013c76:	400a      	ands	r2, r1
 8013c78:	1c11      	adds	r1, r2, #0
 8013c7a:	1c02      	adds	r2, r0, #0
 8013c7c:	430a      	orrs	r2, r1
 8013c7e:	70da      	strb	r2, [r3, #3]
    }
#endif
    ICMP_STATS_INC(icmp.xmit);
    ip4_output_if(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP, netif);
 8013c80:	197a      	adds	r2, r7, r5
 8013c82:	6978      	ldr	r0, [r7, #20]
 8013c84:	69fb      	ldr	r3, [r7, #28]
 8013c86:	9302      	str	r3, [sp, #8]
 8013c88:	2301      	movs	r3, #1
 8013c8a:	9301      	str	r3, [sp, #4]
 8013c8c:	2300      	movs	r3, #0
 8013c8e:	9300      	str	r3, [sp, #0]
 8013c90:	23ff      	movs	r3, #255	; 0xff
 8013c92:	2100      	movs	r1, #0
 8013c94:	f000 fa12 	bl	80140bc <ip4_output_if>
  }
  pbuf_free(q);
 8013c98:	697b      	ldr	r3, [r7, #20]
 8013c9a:	0018      	movs	r0, r3
 8013c9c:	f7f6 fc1e 	bl	800a4dc <pbuf_free>
 8013ca0:	e000      	b.n	8013ca4 <icmp_send_response+0x168>
    return;
 8013ca2:	46c0      	nop			; (mov r8, r8)
}
 8013ca4:	46bd      	mov	sp, r7
 8013ca6:	b008      	add	sp, #32
 8013ca8:	bdb0      	pop	{r4, r5, r7, pc}
 8013caa:	46c0      	nop			; (mov r8, r8)
 8013cac:	08022424 	.word	0x08022424
 8013cb0:	080224e8 	.word	0x080224e8
 8013cb4:	08022488 	.word	0x08022488

08013cb8 <ip4_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip4_route(const ip4_addr_t *dest)
{
 8013cb8:	b580      	push	{r7, lr}
 8013cba:	b084      	sub	sp, #16
 8013cbc:	af00      	add	r7, sp, #0
 8013cbe:	6078      	str	r0, [r7, #4]

  /* bug #54569: in case LWIP_SINGLE_NETIF=1 and LWIP_DEBUGF() disabled, the following loop is optimized away */
  LWIP_UNUSED_ARG(dest);

  /* iterate through netifs */
  NETIF_FOREACH(netif) {
 8013cc0:	4b33      	ldr	r3, [pc, #204]	; (8013d90 <ip4_route+0xd8>)
 8013cc2:	681b      	ldr	r3, [r3, #0]
 8013cc4:	60fb      	str	r3, [r7, #12]
 8013cc6:	e037      	b.n	8013d38 <ip4_route+0x80>
    /* is the netif up, does it have a link and a valid address? */
    if (netif_is_up(netif) && netif_is_link_up(netif) && !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 8013cc8:	68fb      	ldr	r3, [r7, #12]
 8013cca:	2231      	movs	r2, #49	; 0x31
 8013ccc:	5c9b      	ldrb	r3, [r3, r2]
 8013cce:	1c1a      	adds	r2, r3, #0
 8013cd0:	2301      	movs	r3, #1
 8013cd2:	4013      	ands	r3, r2
 8013cd4:	b2db      	uxtb	r3, r3
 8013cd6:	2b00      	cmp	r3, #0
 8013cd8:	d02b      	beq.n	8013d32 <ip4_route+0x7a>
 8013cda:	68fb      	ldr	r3, [r7, #12]
 8013cdc:	2231      	movs	r2, #49	; 0x31
 8013cde:	5c9b      	ldrb	r3, [r3, r2]
 8013ce0:	089b      	lsrs	r3, r3, #2
 8013ce2:	1c1a      	adds	r2, r3, #0
 8013ce4:	2301      	movs	r3, #1
 8013ce6:	4013      	ands	r3, r2
 8013ce8:	b2db      	uxtb	r3, r3
 8013cea:	2b00      	cmp	r3, #0
 8013cec:	d021      	beq.n	8013d32 <ip4_route+0x7a>
 8013cee:	68fb      	ldr	r3, [r7, #12]
 8013cf0:	3304      	adds	r3, #4
 8013cf2:	681b      	ldr	r3, [r3, #0]
 8013cf4:	2b00      	cmp	r3, #0
 8013cf6:	d01c      	beq.n	8013d32 <ip4_route+0x7a>
      /* network mask matches? */
      if (ip4_addr_netcmp(dest, netif_ip4_addr(netif), netif_ip4_netmask(netif))) {
 8013cf8:	687b      	ldr	r3, [r7, #4]
 8013cfa:	681a      	ldr	r2, [r3, #0]
 8013cfc:	68fb      	ldr	r3, [r7, #12]
 8013cfe:	3304      	adds	r3, #4
 8013d00:	681b      	ldr	r3, [r3, #0]
 8013d02:	405a      	eors	r2, r3
 8013d04:	68fb      	ldr	r3, [r7, #12]
 8013d06:	3308      	adds	r3, #8
 8013d08:	681b      	ldr	r3, [r3, #0]
 8013d0a:	4013      	ands	r3, r2
 8013d0c:	d101      	bne.n	8013d12 <ip4_route+0x5a>
        /* return netif on which to forward IP packet */
        return netif;
 8013d0e:	68fb      	ldr	r3, [r7, #12]
 8013d10:	e039      	b.n	8013d86 <ip4_route+0xce>
      }
      /* gateway matches on a non broadcast interface? (i.e. peer in a point to point interface) */
      if (((netif->flags & NETIF_FLAG_BROADCAST) == 0) && ip4_addr_cmp(dest, netif_ip4_gw(netif))) {
 8013d12:	68fb      	ldr	r3, [r7, #12]
 8013d14:	2231      	movs	r2, #49	; 0x31
 8013d16:	5c9b      	ldrb	r3, [r3, r2]
 8013d18:	001a      	movs	r2, r3
 8013d1a:	2302      	movs	r3, #2
 8013d1c:	4013      	ands	r3, r2
 8013d1e:	d108      	bne.n	8013d32 <ip4_route+0x7a>
 8013d20:	687b      	ldr	r3, [r7, #4]
 8013d22:	681a      	ldr	r2, [r3, #0]
 8013d24:	68fb      	ldr	r3, [r7, #12]
 8013d26:	330c      	adds	r3, #12
 8013d28:	681b      	ldr	r3, [r3, #0]
 8013d2a:	429a      	cmp	r2, r3
 8013d2c:	d101      	bne.n	8013d32 <ip4_route+0x7a>
        /* return netif on which to forward IP packet */
        return netif;
 8013d2e:	68fb      	ldr	r3, [r7, #12]
 8013d30:	e029      	b.n	8013d86 <ip4_route+0xce>
  NETIF_FOREACH(netif) {
 8013d32:	68fb      	ldr	r3, [r7, #12]
 8013d34:	681b      	ldr	r3, [r3, #0]
 8013d36:	60fb      	str	r3, [r7, #12]
 8013d38:	68fb      	ldr	r3, [r7, #12]
 8013d3a:	2b00      	cmp	r3, #0
 8013d3c:	d1c4      	bne.n	8013cc8 <ip4_route+0x10>
    return netif;
  }
#endif
#endif /* !LWIP_SINGLE_NETIF */

  if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
 8013d3e:	4b15      	ldr	r3, [pc, #84]	; (8013d94 <ip4_route+0xdc>)
 8013d40:	681b      	ldr	r3, [r3, #0]
 8013d42:	2b00      	cmp	r3, #0
 8013d44:	d01b      	beq.n	8013d7e <ip4_route+0xc6>
 8013d46:	4b13      	ldr	r3, [pc, #76]	; (8013d94 <ip4_route+0xdc>)
 8013d48:	681b      	ldr	r3, [r3, #0]
 8013d4a:	2231      	movs	r2, #49	; 0x31
 8013d4c:	5c9b      	ldrb	r3, [r3, r2]
 8013d4e:	001a      	movs	r2, r3
 8013d50:	2301      	movs	r3, #1
 8013d52:	4013      	ands	r3, r2
 8013d54:	d013      	beq.n	8013d7e <ip4_route+0xc6>
 8013d56:	4b0f      	ldr	r3, [pc, #60]	; (8013d94 <ip4_route+0xdc>)
 8013d58:	681b      	ldr	r3, [r3, #0]
 8013d5a:	2231      	movs	r2, #49	; 0x31
 8013d5c:	5c9b      	ldrb	r3, [r3, r2]
 8013d5e:	001a      	movs	r2, r3
 8013d60:	2304      	movs	r3, #4
 8013d62:	4013      	ands	r3, r2
 8013d64:	d00b      	beq.n	8013d7e <ip4_route+0xc6>
      ip4_addr_isany_val(*netif_ip4_addr(netif_default)) || ip4_addr_isloopback(dest)) {
 8013d66:	4b0b      	ldr	r3, [pc, #44]	; (8013d94 <ip4_route+0xdc>)
 8013d68:	681b      	ldr	r3, [r3, #0]
 8013d6a:	3304      	adds	r3, #4
 8013d6c:	681b      	ldr	r3, [r3, #0]
  if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
 8013d6e:	2b00      	cmp	r3, #0
 8013d70:	d005      	beq.n	8013d7e <ip4_route+0xc6>
      ip4_addr_isany_val(*netif_ip4_addr(netif_default)) || ip4_addr_isloopback(dest)) {
 8013d72:	687b      	ldr	r3, [r7, #4]
 8013d74:	681b      	ldr	r3, [r3, #0]
 8013d76:	22ff      	movs	r2, #255	; 0xff
 8013d78:	4013      	ands	r3, r2
 8013d7a:	2b7f      	cmp	r3, #127	; 0x7f
 8013d7c:	d101      	bne.n	8013d82 <ip4_route+0xca>
       If this is not good enough for you, use LWIP_HOOK_IP4_ROUTE() */
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_route: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
                ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
    MIB2_STATS_INC(mib2.ipoutnoroutes);
    return NULL;
 8013d7e:	2300      	movs	r3, #0
 8013d80:	e001      	b.n	8013d86 <ip4_route+0xce>
  }

  return netif_default;
 8013d82:	4b04      	ldr	r3, [pc, #16]	; (8013d94 <ip4_route+0xdc>)
 8013d84:	681b      	ldr	r3, [r3, #0]
}
 8013d86:	0018      	movs	r0, r3
 8013d88:	46bd      	mov	sp, r7
 8013d8a:	b004      	add	sp, #16
 8013d8c:	bd80      	pop	{r7, pc}
 8013d8e:	46c0      	nop			; (mov r8, r8)
 8013d90:	2000277c 	.word	0x2000277c
 8013d94:	20002780 	.word	0x20002780

08013d98 <ip4_input_accept>:
#endif /* IP_FORWARD */

/** Return true if the current input packet should be accepted on this netif */
static int
ip4_input_accept(struct netif *netif)
{
 8013d98:	b580      	push	{r7, lr}
 8013d9a:	b082      	sub	sp, #8
 8013d9c:	af00      	add	r7, sp, #0
 8013d9e:	6078      	str	r0, [r7, #4]
                         ip4_addr_get_u32(ip4_current_dest_addr()) & ip4_addr_get_u32(netif_ip4_netmask(netif)),
                         ip4_addr_get_u32(netif_ip4_addr(netif)) & ip4_addr_get_u32(netif_ip4_netmask(netif)),
                         ip4_addr_get_u32(ip4_current_dest_addr()) & ~ip4_addr_get_u32(netif_ip4_netmask(netif))));

  /* interface is up and configured? */
  if ((netif_is_up(netif)) && (!ip4_addr_isany_val(*netif_ip4_addr(netif)))) {
 8013da0:	687b      	ldr	r3, [r7, #4]
 8013da2:	2231      	movs	r2, #49	; 0x31
 8013da4:	5c9b      	ldrb	r3, [r3, r2]
 8013da6:	1c1a      	adds	r2, r3, #0
 8013da8:	2301      	movs	r3, #1
 8013daa:	4013      	ands	r3, r2
 8013dac:	b2db      	uxtb	r3, r3
 8013dae:	2b00      	cmp	r3, #0
 8013db0:	d016      	beq.n	8013de0 <ip4_input_accept+0x48>
 8013db2:	687b      	ldr	r3, [r7, #4]
 8013db4:	3304      	adds	r3, #4
 8013db6:	681b      	ldr	r3, [r3, #0]
 8013db8:	2b00      	cmp	r3, #0
 8013dba:	d011      	beq.n	8013de0 <ip4_input_accept+0x48>
    /* unicast to this interface address? */
    if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
 8013dbc:	4b0b      	ldr	r3, [pc, #44]	; (8013dec <ip4_input_accept+0x54>)
 8013dbe:	695a      	ldr	r2, [r3, #20]
 8013dc0:	687b      	ldr	r3, [r7, #4]
 8013dc2:	3304      	adds	r3, #4
 8013dc4:	681b      	ldr	r3, [r3, #0]
 8013dc6:	429a      	cmp	r2, r3
 8013dc8:	d008      	beq.n	8013ddc <ip4_input_accept+0x44>
        /* or broadcast on this interface network address? */
        ip4_addr_isbroadcast(ip4_current_dest_addr(), netif)
 8013dca:	4b08      	ldr	r3, [pc, #32]	; (8013dec <ip4_input_accept+0x54>)
 8013dcc:	695b      	ldr	r3, [r3, #20]
 8013dce:	687a      	ldr	r2, [r7, #4]
 8013dd0:	0011      	movs	r1, r2
 8013dd2:	0018      	movs	r0, r3
 8013dd4:	f000 fb98 	bl	8014508 <ip4_addr_isbroadcast_u32>
 8013dd8:	1e03      	subs	r3, r0, #0
    if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
 8013dda:	d001      	beq.n	8013de0 <ip4_input_accept+0x48>
#endif /* LWIP_NETIF_LOOPBACK && !LWIP_HAVE_LOOPIF */
       ) {
      LWIP_DEBUGF(IP_DEBUG, ("ip4_input: packet accepted on interface %c%c\n",
                             netif->name[0], netif->name[1]));
      /* accept on this netif */
      return 1;
 8013ddc:	2301      	movs	r3, #1
 8013dde:	e000      	b.n	8013de2 <ip4_input_accept+0x4a>
      /* accept on this netif */
      return 1;
    }
#endif /* LWIP_AUTOIP */
  }
  return 0;
 8013de0:	2300      	movs	r3, #0
}
 8013de2:	0018      	movs	r0, r3
 8013de4:	46bd      	mov	sp, r7
 8013de6:	b002      	add	sp, #8
 8013de8:	bd80      	pop	{r7, pc}
 8013dea:	46c0      	nop			; (mov r8, r8)
 8013dec:	20001138 	.word	0x20001138

08013df0 <ip4_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip4_input(struct pbuf *p, struct netif *inp)
{
 8013df0:	b5b0      	push	{r4, r5, r7, lr}
 8013df2:	b086      	sub	sp, #24
 8013df4:	af00      	add	r7, sp, #0
 8013df6:	6078      	str	r0, [r7, #4]
 8013df8:	6039      	str	r1, [r7, #0]

  IP_STATS_INC(ip.recv);
  MIB2_STATS_INC(mib2.ipinreceives);

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
 8013dfa:	687b      	ldr	r3, [r7, #4]
 8013dfc:	685b      	ldr	r3, [r3, #4]
 8013dfe:	613b      	str	r3, [r7, #16]
  if (IPH_V(iphdr) != 4) {
 8013e00:	693b      	ldr	r3, [r7, #16]
 8013e02:	781b      	ldrb	r3, [r3, #0]
 8013e04:	091b      	lsrs	r3, r3, #4
 8013e06:	b2db      	uxtb	r3, r3
 8013e08:	2b04      	cmp	r3, #4
 8013e0a:	d005      	beq.n	8013e18 <ip4_input+0x28>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", (u16_t)IPH_V(iphdr)));
    ip4_debug_print(p);
    pbuf_free(p);
 8013e0c:	687b      	ldr	r3, [r7, #4]
 8013e0e:	0018      	movs	r0, r3
 8013e10:	f7f6 fb64 	bl	800a4dc <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    MIB2_STATS_INC(mib2.ipinhdrerrors);
    return ERR_OK;
 8013e14:	2300      	movs	r3, #0
 8013e16:	e147      	b.n	80140a8 <ip4_input+0x2b8>
    return ERR_OK;
  }
#endif

  /* obtain IP header length in bytes */
  iphdr_hlen = IPH_HL_BYTES(iphdr);
 8013e18:	693b      	ldr	r3, [r7, #16]
 8013e1a:	781b      	ldrb	r3, [r3, #0]
 8013e1c:	220f      	movs	r2, #15
 8013e1e:	4013      	ands	r3, r2
 8013e20:	b2db      	uxtb	r3, r3
 8013e22:	009b      	lsls	r3, r3, #2
 8013e24:	b2da      	uxtb	r2, r3
 8013e26:	2316      	movs	r3, #22
 8013e28:	18fb      	adds	r3, r7, r3
 8013e2a:	801a      	strh	r2, [r3, #0]
  /* obtain ip length in bytes */
  iphdr_len = lwip_ntohs(IPH_LEN(iphdr));
 8013e2c:	693b      	ldr	r3, [r7, #16]
 8013e2e:	789a      	ldrb	r2, [r3, #2]
 8013e30:	78db      	ldrb	r3, [r3, #3]
 8013e32:	021b      	lsls	r3, r3, #8
 8013e34:	4313      	orrs	r3, r2
 8013e36:	b29b      	uxth	r3, r3
 8013e38:	2514      	movs	r5, #20
 8013e3a:	197c      	adds	r4, r7, r5
 8013e3c:	0018      	movs	r0, r3
 8013e3e:	f7f3 fadf 	bl	8007400 <lwip_htons>
 8013e42:	0003      	movs	r3, r0
 8013e44:	8023      	strh	r3, [r4, #0]

  /* Trim pbuf. This is especially required for packets < 60 bytes. */
  if (iphdr_len < p->tot_len) {
 8013e46:	687b      	ldr	r3, [r7, #4]
 8013e48:	891b      	ldrh	r3, [r3, #8]
 8013e4a:	197a      	adds	r2, r7, r5
 8013e4c:	8812      	ldrh	r2, [r2, #0]
 8013e4e:	429a      	cmp	r2, r3
 8013e50:	d206      	bcs.n	8013e60 <ip4_input+0x70>
    pbuf_realloc(p, iphdr_len);
 8013e52:	197b      	adds	r3, r7, r5
 8013e54:	881a      	ldrh	r2, [r3, #0]
 8013e56:	687b      	ldr	r3, [r7, #4]
 8013e58:	0011      	movs	r1, r2
 8013e5a:	0018      	movs	r0, r3
 8013e5c:	f7f6 f986 	bl	800a16c <pbuf_realloc>
  }

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len) || (iphdr_hlen < IP_HLEN)) {
 8013e60:	687b      	ldr	r3, [r7, #4]
 8013e62:	895b      	ldrh	r3, [r3, #10]
 8013e64:	2116      	movs	r1, #22
 8013e66:	187a      	adds	r2, r7, r1
 8013e68:	8812      	ldrh	r2, [r2, #0]
 8013e6a:	429a      	cmp	r2, r3
 8013e6c:	d80a      	bhi.n	8013e84 <ip4_input+0x94>
 8013e6e:	687b      	ldr	r3, [r7, #4]
 8013e70:	891b      	ldrh	r3, [r3, #8]
 8013e72:	2214      	movs	r2, #20
 8013e74:	18ba      	adds	r2, r7, r2
 8013e76:	8812      	ldrh	r2, [r2, #0]
 8013e78:	429a      	cmp	r2, r3
 8013e7a:	d803      	bhi.n	8013e84 <ip4_input+0x94>
 8013e7c:	187b      	adds	r3, r7, r1
 8013e7e:	881b      	ldrh	r3, [r3, #0]
 8013e80:	2b13      	cmp	r3, #19
 8013e82:	d805      	bhi.n	8013e90 <ip4_input+0xa0>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                  ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
                   iphdr_len, p->tot_len));
    }
    /* free (drop) packet pbufs */
    pbuf_free(p);
 8013e84:	687b      	ldr	r3, [r7, #4]
 8013e86:	0018      	movs	r0, r3
 8013e88:	f7f6 fb28 	bl	800a4dc <pbuf_free>
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    MIB2_STATS_INC(mib2.ipindiscards);
    return ERR_OK;
 8013e8c:	2300      	movs	r3, #0
 8013e8e:	e10b      	b.n	80140a8 <ip4_input+0x2b8>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_IP) {
    if (inet_chksum(iphdr, iphdr_hlen) != 0) {
 8013e90:	2316      	movs	r3, #22
 8013e92:	18fb      	adds	r3, r7, r3
 8013e94:	881a      	ldrh	r2, [r3, #0]
 8013e96:	693b      	ldr	r3, [r7, #16]
 8013e98:	0011      	movs	r1, r2
 8013e9a:	0018      	movs	r0, r3
 8013e9c:	f7f4 fe98 	bl	8008bd0 <inet_chksum>
 8013ea0:	1e03      	subs	r3, r0, #0
 8013ea2:	d005      	beq.n	8013eb0 <ip4_input+0xc0>

      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                  ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
      ip4_debug_print(p);
      pbuf_free(p);
 8013ea4:	687b      	ldr	r3, [r7, #4]
 8013ea6:	0018      	movs	r0, r3
 8013ea8:	f7f6 fb18 	bl	800a4dc <pbuf_free>
      IP_STATS_INC(ip.chkerr);
      IP_STATS_INC(ip.drop);
      MIB2_STATS_INC(mib2.ipinhdrerrors);
      return ERR_OK;
 8013eac:	2300      	movs	r3, #0
 8013eae:	e0fb      	b.n	80140a8 <ip4_input+0x2b8>
    }
  }
#endif

  /* copy IP addresses to aligned ip_addr_t */
  ip_addr_copy_from_ip4(ip_data.current_iphdr_dest, iphdr->dest);
 8013eb0:	693b      	ldr	r3, [r7, #16]
 8013eb2:	7c1a      	ldrb	r2, [r3, #16]
 8013eb4:	7c59      	ldrb	r1, [r3, #17]
 8013eb6:	0209      	lsls	r1, r1, #8
 8013eb8:	430a      	orrs	r2, r1
 8013eba:	7c99      	ldrb	r1, [r3, #18]
 8013ebc:	0409      	lsls	r1, r1, #16
 8013ebe:	430a      	orrs	r2, r1
 8013ec0:	7cdb      	ldrb	r3, [r3, #19]
 8013ec2:	061b      	lsls	r3, r3, #24
 8013ec4:	4313      	orrs	r3, r2
 8013ec6:	001a      	movs	r2, r3
 8013ec8:	4b79      	ldr	r3, [pc, #484]	; (80140b0 <ip4_input+0x2c0>)
 8013eca:	615a      	str	r2, [r3, #20]
  ip_addr_copy_from_ip4(ip_data.current_iphdr_src, iphdr->src);
 8013ecc:	693b      	ldr	r3, [r7, #16]
 8013ece:	7b1a      	ldrb	r2, [r3, #12]
 8013ed0:	7b59      	ldrb	r1, [r3, #13]
 8013ed2:	0209      	lsls	r1, r1, #8
 8013ed4:	430a      	orrs	r2, r1
 8013ed6:	7b99      	ldrb	r1, [r3, #14]
 8013ed8:	0409      	lsls	r1, r1, #16
 8013eda:	430a      	orrs	r2, r1
 8013edc:	7bdb      	ldrb	r3, [r3, #15]
 8013ede:	061b      	lsls	r3, r3, #24
 8013ee0:	4313      	orrs	r3, r2
 8013ee2:	001a      	movs	r2, r3
 8013ee4:	4b72      	ldr	r3, [pc, #456]	; (80140b0 <ip4_input+0x2c0>)
 8013ee6:	611a      	str	r2, [r3, #16]

  /* match packet against an interface, i.e. is this packet for us? */
  if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
 8013ee8:	4b71      	ldr	r3, [pc, #452]	; (80140b0 <ip4_input+0x2c0>)
 8013eea:	695b      	ldr	r3, [r3, #20]
 8013eec:	22f0      	movs	r2, #240	; 0xf0
 8013eee:	4013      	ands	r3, r2
 8013ef0:	2be0      	cmp	r3, #224	; 0xe0
 8013ef2:	d113      	bne.n	8013f1c <ip4_input+0x12c>
      netif = inp;
    } else {
      netif = NULL;
    }
#else /* LWIP_IGMP */
    if ((netif_is_up(inp)) && (!ip4_addr_isany_val(*netif_ip4_addr(inp)))) {
 8013ef4:	683b      	ldr	r3, [r7, #0]
 8013ef6:	2231      	movs	r2, #49	; 0x31
 8013ef8:	5c9b      	ldrb	r3, [r3, r2]
 8013efa:	1c1a      	adds	r2, r3, #0
 8013efc:	2301      	movs	r3, #1
 8013efe:	4013      	ands	r3, r2
 8013f00:	b2db      	uxtb	r3, r3
 8013f02:	2b00      	cmp	r3, #0
 8013f04:	d007      	beq.n	8013f16 <ip4_input+0x126>
 8013f06:	683b      	ldr	r3, [r7, #0]
 8013f08:	3304      	adds	r3, #4
 8013f0a:	681b      	ldr	r3, [r3, #0]
 8013f0c:	2b00      	cmp	r3, #0
 8013f0e:	d002      	beq.n	8013f16 <ip4_input+0x126>
      netif = inp;
 8013f10:	683b      	ldr	r3, [r7, #0]
 8013f12:	60fb      	str	r3, [r7, #12]
 8013f14:	e02b      	b.n	8013f6e <ip4_input+0x17e>
    } else {
      netif = NULL;
 8013f16:	2300      	movs	r3, #0
 8013f18:	60fb      	str	r3, [r7, #12]
 8013f1a:	e028      	b.n	8013f6e <ip4_input+0x17e>
    }
#endif /* LWIP_IGMP */
  } else {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs. */
    if (ip4_input_accept(inp)) {
 8013f1c:	683b      	ldr	r3, [r7, #0]
 8013f1e:	0018      	movs	r0, r3
 8013f20:	f7ff ff3a 	bl	8013d98 <ip4_input_accept>
 8013f24:	1e03      	subs	r3, r0, #0
 8013f26:	d002      	beq.n	8013f2e <ip4_input+0x13e>
      netif = inp;
 8013f28:	683b      	ldr	r3, [r7, #0]
 8013f2a:	60fb      	str	r3, [r7, #12]
 8013f2c:	e01f      	b.n	8013f6e <ip4_input+0x17e>
    } else {
      netif = NULL;
 8013f2e:	2300      	movs	r3, #0
 8013f30:	60fb      	str	r3, [r7, #12]
#if !LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF
      /* Packets sent to the loopback address must not be accepted on an
       * interface that does not have the loopback address assigned to it,
       * unless a non-loopback interface is used for loopback traffic. */
      if (!ip4_addr_isloopback(ip4_current_dest_addr()))
 8013f32:	4b5f      	ldr	r3, [pc, #380]	; (80140b0 <ip4_input+0x2c0>)
 8013f34:	695b      	ldr	r3, [r3, #20]
 8013f36:	22ff      	movs	r2, #255	; 0xff
 8013f38:	4013      	ands	r3, r2
 8013f3a:	2b7f      	cmp	r3, #127	; 0x7f
 8013f3c:	d017      	beq.n	8013f6e <ip4_input+0x17e>
#endif /* !LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF */
      {
#if !LWIP_SINGLE_NETIF
        NETIF_FOREACH(netif) {
 8013f3e:	4b5d      	ldr	r3, [pc, #372]	; (80140b4 <ip4_input+0x2c4>)
 8013f40:	681b      	ldr	r3, [r3, #0]
 8013f42:	60fb      	str	r3, [r7, #12]
 8013f44:	e00e      	b.n	8013f64 <ip4_input+0x174>
          if (netif == inp) {
 8013f46:	68fa      	ldr	r2, [r7, #12]
 8013f48:	683b      	ldr	r3, [r7, #0]
 8013f4a:	429a      	cmp	r2, r3
 8013f4c:	d006      	beq.n	8013f5c <ip4_input+0x16c>
            /* we checked that before already */
            continue;
          }
          if (ip4_input_accept(netif)) {
 8013f4e:	68fb      	ldr	r3, [r7, #12]
 8013f50:	0018      	movs	r0, r3
 8013f52:	f7ff ff21 	bl	8013d98 <ip4_input_accept>
 8013f56:	1e03      	subs	r3, r0, #0
 8013f58:	d108      	bne.n	8013f6c <ip4_input+0x17c>
 8013f5a:	e000      	b.n	8013f5e <ip4_input+0x16e>
            continue;
 8013f5c:	46c0      	nop			; (mov r8, r8)
        NETIF_FOREACH(netif) {
 8013f5e:	68fb      	ldr	r3, [r7, #12]
 8013f60:	681b      	ldr	r3, [r3, #0]
 8013f62:	60fb      	str	r3, [r7, #12]
 8013f64:	68fb      	ldr	r3, [r7, #12]
 8013f66:	2b00      	cmp	r3, #0
 8013f68:	d1ed      	bne.n	8013f46 <ip4_input+0x156>
 8013f6a:	e000      	b.n	8013f6e <ip4_input+0x17e>
            break;
 8013f6c:	46c0      	nop			; (mov r8, r8)
      && !ip4_addr_isany_val(*ip4_current_src_addr())
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
     )
#endif /* LWIP_IGMP || IP_ACCEPT_LINK_LAYER_ADDRESSING */
  {
    if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
 8013f6e:	4b50      	ldr	r3, [pc, #320]	; (80140b0 <ip4_input+0x2c0>)
 8013f70:	691b      	ldr	r3, [r3, #16]
 8013f72:	683a      	ldr	r2, [r7, #0]
 8013f74:	0011      	movs	r1, r2
 8013f76:	0018      	movs	r0, r3
 8013f78:	f000 fac6 	bl	8014508 <ip4_addr_isbroadcast_u32>
 8013f7c:	1e03      	subs	r3, r0, #0
 8013f7e:	d105      	bne.n	8013f8c <ip4_input+0x19c>
        (ip4_addr_ismulticast(ip4_current_src_addr()))) {
 8013f80:	4b4b      	ldr	r3, [pc, #300]	; (80140b0 <ip4_input+0x2c0>)
 8013f82:	691b      	ldr	r3, [r3, #16]
 8013f84:	22f0      	movs	r2, #240	; 0xf0
 8013f86:	4013      	ands	r3, r2
    if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
 8013f88:	2be0      	cmp	r3, #224	; 0xe0
 8013f8a:	d105      	bne.n	8013f98 <ip4_input+0x1a8>
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("ip4_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
 8013f8c:	687b      	ldr	r3, [r7, #4]
 8013f8e:	0018      	movs	r0, r3
 8013f90:	f7f6 faa4 	bl	800a4dc <pbuf_free>
      IP_STATS_INC(ip.drop);
      MIB2_STATS_INC(mib2.ipinaddrerrors);
      MIB2_STATS_INC(mib2.ipindiscards);
      return ERR_OK;
 8013f94:	2300      	movs	r3, #0
 8013f96:	e087      	b.n	80140a8 <ip4_input+0x2b8>
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
 8013f98:	68fb      	ldr	r3, [r7, #12]
 8013f9a:	2b00      	cmp	r3, #0
 8013f9c:	d105      	bne.n	8013faa <ip4_input+0x1ba>
    {
      IP_STATS_INC(ip.drop);
      MIB2_STATS_INC(mib2.ipinaddrerrors);
      MIB2_STATS_INC(mib2.ipindiscards);
    }
    pbuf_free(p);
 8013f9e:	687b      	ldr	r3, [r7, #4]
 8013fa0:	0018      	movs	r0, r3
 8013fa2:	f7f6 fa9b 	bl	800a4dc <pbuf_free>
    return ERR_OK;
 8013fa6:	2300      	movs	r3, #0
 8013fa8:	e07e      	b.n	80140a8 <ip4_input+0x2b8>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
 8013faa:	693b      	ldr	r3, [r7, #16]
 8013fac:	799a      	ldrb	r2, [r3, #6]
 8013fae:	79db      	ldrb	r3, [r3, #7]
 8013fb0:	021b      	lsls	r3, r3, #8
 8013fb2:	4313      	orrs	r3, r2
 8013fb4:	b29b      	uxth	r3, r3
 8013fb6:	001a      	movs	r2, r3
 8013fb8:	4b3f      	ldr	r3, [pc, #252]	; (80140b8 <ip4_input+0x2c8>)
 8013fba:	4013      	ands	r3, r2
 8013fbc:	d005      	beq.n	8013fca <ip4_input+0x1da>
    if (p == NULL) {
      return ERR_OK;
    }
    iphdr = (const struct ip_hdr *)p->payload;
#else /* IP_REASSEMBLY == 0, no packet fragment reassembly code present */
    pbuf_free(p);
 8013fbe:	687b      	ldr	r3, [r7, #4]
 8013fc0:	0018      	movs	r0, r3
 8013fc2:	f7f6 fa8b 	bl	800a4dc <pbuf_free>
                lwip_ntohs(IPH_OFFSET(iphdr))));
    IP_STATS_INC(ip.opterr);
    IP_STATS_INC(ip.drop);
    /* unsupported protocol feature */
    MIB2_STATS_INC(mib2.ipinunknownprotos);
    return ERR_OK;
 8013fc6:	2300      	movs	r3, #0
 8013fc8:	e06e      	b.n	80140a8 <ip4_input+0x2b8>
  /* send to upper layers */
  LWIP_DEBUGF(IP_DEBUG, ("ip4_input: \n"));
  ip4_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip4_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

  ip_data.current_netif = netif;
 8013fca:	4b39      	ldr	r3, [pc, #228]	; (80140b0 <ip4_input+0x2c0>)
 8013fcc:	68fa      	ldr	r2, [r7, #12]
 8013fce:	601a      	str	r2, [r3, #0]
  ip_data.current_input_netif = inp;
 8013fd0:	4b37      	ldr	r3, [pc, #220]	; (80140b0 <ip4_input+0x2c0>)
 8013fd2:	683a      	ldr	r2, [r7, #0]
 8013fd4:	605a      	str	r2, [r3, #4]
  ip_data.current_ip4_header = iphdr;
 8013fd6:	4b36      	ldr	r3, [pc, #216]	; (80140b0 <ip4_input+0x2c0>)
 8013fd8:	693a      	ldr	r2, [r7, #16]
 8013fda:	609a      	str	r2, [r3, #8]
  ip_data.current_ip_header_tot_len = IPH_HL_BYTES(iphdr);
 8013fdc:	693b      	ldr	r3, [r7, #16]
 8013fde:	781b      	ldrb	r3, [r3, #0]
 8013fe0:	220f      	movs	r2, #15
 8013fe2:	4013      	ands	r3, r2
 8013fe4:	b2db      	uxtb	r3, r3
 8013fe6:	009b      	lsls	r3, r3, #2
 8013fe8:	b2db      	uxtb	r3, r3
 8013fea:	b29a      	uxth	r2, r3
 8013fec:	4b30      	ldr	r3, [pc, #192]	; (80140b0 <ip4_input+0x2c0>)
 8013fee:	819a      	strh	r2, [r3, #12]
  /* raw input did not eat the packet? */
  raw_status = raw_input(p, inp);
  if (raw_status != RAW_INPUT_EATEN)
#endif /* LWIP_RAW */
  {
    pbuf_remove_header(p, iphdr_hlen); /* Move to payload, no check necessary. */
 8013ff0:	2316      	movs	r3, #22
 8013ff2:	18fb      	adds	r3, r7, r3
 8013ff4:	881a      	ldrh	r2, [r3, #0]
 8013ff6:	687b      	ldr	r3, [r7, #4]
 8013ff8:	0011      	movs	r1, r2
 8013ffa:	0018      	movs	r0, r3
 8013ffc:	f7f6 f9d8 	bl	800a3b0 <pbuf_remove_header>

    switch (IPH_PROTO(iphdr)) {
 8014000:	693b      	ldr	r3, [r7, #16]
 8014002:	7a5b      	ldrb	r3, [r3, #9]
 8014004:	2b11      	cmp	r3, #17
 8014006:	d005      	beq.n	8014014 <ip4_input+0x224>
 8014008:	dc19      	bgt.n	801403e <ip4_input+0x24e>
 801400a:	2b01      	cmp	r3, #1
 801400c:	d010      	beq.n	8014030 <ip4_input+0x240>
 801400e:	2b06      	cmp	r3, #6
 8014010:	d007      	beq.n	8014022 <ip4_input+0x232>
 8014012:	e014      	b.n	801403e <ip4_input+0x24e>
      case IP_PROTO_UDP:
#if LWIP_UDPLITE
      case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
        MIB2_STATS_INC(mib2.ipindelivers);
        udp_input(p, inp);
 8014014:	683a      	ldr	r2, [r7, #0]
 8014016:	687b      	ldr	r3, [r7, #4]
 8014018:	0011      	movs	r1, r2
 801401a:	0018      	movs	r0, r3
 801401c:	f7fe fe80 	bl	8012d20 <udp_input>
        break;
 8014020:	e02f      	b.n	8014082 <ip4_input+0x292>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case IP_PROTO_TCP:
        MIB2_STATS_INC(mib2.ipindelivers);
        tcp_input(p, inp);
 8014022:	683a      	ldr	r2, [r7, #0]
 8014024:	687b      	ldr	r3, [r7, #4]
 8014026:	0011      	movs	r1, r2
 8014028:	0018      	movs	r0, r3
 801402a:	f7f8 ff67 	bl	800cefc <tcp_input>
        break;
 801402e:	e028      	b.n	8014082 <ip4_input+0x292>
#endif /* LWIP_TCP */
#if LWIP_ICMP
      case IP_PROTO_ICMP:
        MIB2_STATS_INC(mib2.ipindelivers);
        icmp_input(p, inp);
 8014030:	683a      	ldr	r2, [r7, #0]
 8014032:	687b      	ldr	r3, [r7, #4]
 8014034:	0011      	movs	r1, r2
 8014036:	0018      	movs	r0, r3
 8014038:	f7ff fb88 	bl	801374c <icmp_input>
        break;
 801403c:	e021      	b.n	8014082 <ip4_input+0x292>
        } else
#endif /* LWIP_RAW */
        {
#if LWIP_ICMP
          /* send ICMP destination protocol unreachable unless is was a broadcast */
          if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
 801403e:	4b1c      	ldr	r3, [pc, #112]	; (80140b0 <ip4_input+0x2c0>)
 8014040:	695b      	ldr	r3, [r3, #20]
 8014042:	68fa      	ldr	r2, [r7, #12]
 8014044:	0011      	movs	r1, r2
 8014046:	0018      	movs	r0, r3
 8014048:	f000 fa5e 	bl	8014508 <ip4_addr_isbroadcast_u32>
 801404c:	1e03      	subs	r3, r0, #0
 801404e:	d113      	bne.n	8014078 <ip4_input+0x288>
              !ip4_addr_ismulticast(ip4_current_dest_addr())) {
 8014050:	4b17      	ldr	r3, [pc, #92]	; (80140b0 <ip4_input+0x2c0>)
 8014052:	695b      	ldr	r3, [r3, #20]
 8014054:	22f0      	movs	r2, #240	; 0xf0
 8014056:	4013      	ands	r3, r2
          if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
 8014058:	2be0      	cmp	r3, #224	; 0xe0
 801405a:	d00d      	beq.n	8014078 <ip4_input+0x288>
            pbuf_header_force(p, (s16_t)iphdr_hlen); /* Move to ip header, no check necessary. */
 801405c:	2316      	movs	r3, #22
 801405e:	18fb      	adds	r3, r7, r3
 8014060:	2200      	movs	r2, #0
 8014062:	5e9a      	ldrsh	r2, [r3, r2]
 8014064:	687b      	ldr	r3, [r7, #4]
 8014066:	0011      	movs	r1, r2
 8014068:	0018      	movs	r0, r3
 801406a:	f7f6 fa22 	bl	800a4b2 <pbuf_header_force>
            icmp_dest_unreach(p, ICMP_DUR_PROTO);
 801406e:	687b      	ldr	r3, [r7, #4]
 8014070:	2102      	movs	r1, #2
 8014072:	0018      	movs	r0, r3
 8014074:	f7ff fd50 	bl	8013b18 <icmp_dest_unreach>

          IP_STATS_INC(ip.proterr);
          IP_STATS_INC(ip.drop);
          MIB2_STATS_INC(mib2.ipinunknownprotos);
        }
        pbuf_free(p);
 8014078:	687b      	ldr	r3, [r7, #4]
 801407a:	0018      	movs	r0, r3
 801407c:	f7f6 fa2e 	bl	800a4dc <pbuf_free>
        break;
 8014080:	46c0      	nop			; (mov r8, r8)
    }
  }

  /* @todo: this is not really necessary... */
  ip_data.current_netif = NULL;
 8014082:	4b0b      	ldr	r3, [pc, #44]	; (80140b0 <ip4_input+0x2c0>)
 8014084:	2200      	movs	r2, #0
 8014086:	601a      	str	r2, [r3, #0]
  ip_data.current_input_netif = NULL;
 8014088:	4b09      	ldr	r3, [pc, #36]	; (80140b0 <ip4_input+0x2c0>)
 801408a:	2200      	movs	r2, #0
 801408c:	605a      	str	r2, [r3, #4]
  ip_data.current_ip4_header = NULL;
 801408e:	4b08      	ldr	r3, [pc, #32]	; (80140b0 <ip4_input+0x2c0>)
 8014090:	2200      	movs	r2, #0
 8014092:	609a      	str	r2, [r3, #8]
  ip_data.current_ip_header_tot_len = 0;
 8014094:	4b06      	ldr	r3, [pc, #24]	; (80140b0 <ip4_input+0x2c0>)
 8014096:	2200      	movs	r2, #0
 8014098:	819a      	strh	r2, [r3, #12]
  ip4_addr_set_any(ip4_current_src_addr());
 801409a:	4b05      	ldr	r3, [pc, #20]	; (80140b0 <ip4_input+0x2c0>)
 801409c:	2200      	movs	r2, #0
 801409e:	611a      	str	r2, [r3, #16]
  ip4_addr_set_any(ip4_current_dest_addr());
 80140a0:	4b03      	ldr	r3, [pc, #12]	; (80140b0 <ip4_input+0x2c0>)
 80140a2:	2200      	movs	r2, #0
 80140a4:	615a      	str	r2, [r3, #20]

  return ERR_OK;
 80140a6:	2300      	movs	r3, #0
}
 80140a8:	0018      	movs	r0, r3
 80140aa:	46bd      	mov	sp, r7
 80140ac:	b006      	add	sp, #24
 80140ae:	bdb0      	pop	{r4, r5, r7, pc}
 80140b0:	20001138 	.word	0x20001138
 80140b4:	2000277c 	.word	0x2000277c
 80140b8:	0000ff3f 	.word	0x0000ff3f

080140bc <ip4_output_if>:
 */
err_t
ip4_output_if(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
              u8_t ttl, u8_t tos,
              u8_t proto, struct netif *netif)
{
 80140bc:	b590      	push	{r4, r7, lr}
 80140be:	b08b      	sub	sp, #44	; 0x2c
 80140c0:	af04      	add	r7, sp, #16
 80140c2:	60f8      	str	r0, [r7, #12]
 80140c4:	60b9      	str	r1, [r7, #8]
 80140c6:	607a      	str	r2, [r7, #4]
 80140c8:	001a      	movs	r2, r3
 80140ca:	1cfb      	adds	r3, r7, #3
 80140cc:	701a      	strb	r2, [r3, #0]
ip4_output_if_opt(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
                  u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
                  u16_t optlen)
{
#endif /* IP_OPTIONS_SEND */
  const ip4_addr_t *src_used = src;
 80140ce:	68bb      	ldr	r3, [r7, #8]
 80140d0:	617b      	str	r3, [r7, #20]
  if (dest != LWIP_IP_HDRINCL) {
 80140d2:	687b      	ldr	r3, [r7, #4]
 80140d4:	2b00      	cmp	r3, #0
 80140d6:	d009      	beq.n	80140ec <ip4_output_if+0x30>
    if (ip4_addr_isany(src)) {
 80140d8:	68bb      	ldr	r3, [r7, #8]
 80140da:	2b00      	cmp	r3, #0
 80140dc:	d003      	beq.n	80140e6 <ip4_output_if+0x2a>
 80140de:	68bb      	ldr	r3, [r7, #8]
 80140e0:	681b      	ldr	r3, [r3, #0]
 80140e2:	2b00      	cmp	r3, #0
 80140e4:	d102      	bne.n	80140ec <ip4_output_if+0x30>
      src_used = netif_ip4_addr(netif);
 80140e6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80140e8:	3304      	adds	r3, #4
 80140ea:	617b      	str	r3, [r7, #20]

#if IP_OPTIONS_SEND
  return ip4_output_if_opt_src(p, src_used, dest, ttl, tos, proto, netif,
                               ip_options, optlen);
#else /* IP_OPTIONS_SEND */
  return ip4_output_if_src(p, src_used, dest, ttl, tos, proto, netif);
 80140ec:	1cfb      	adds	r3, r7, #3
 80140ee:	781c      	ldrb	r4, [r3, #0]
 80140f0:	687a      	ldr	r2, [r7, #4]
 80140f2:	6979      	ldr	r1, [r7, #20]
 80140f4:	68f8      	ldr	r0, [r7, #12]
 80140f6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80140f8:	9302      	str	r3, [sp, #8]
 80140fa:	232c      	movs	r3, #44	; 0x2c
 80140fc:	18fb      	adds	r3, r7, r3
 80140fe:	781b      	ldrb	r3, [r3, #0]
 8014100:	9301      	str	r3, [sp, #4]
 8014102:	2328      	movs	r3, #40	; 0x28
 8014104:	18fb      	adds	r3, r7, r3
 8014106:	781b      	ldrb	r3, [r3, #0]
 8014108:	9300      	str	r3, [sp, #0]
 801410a:	0023      	movs	r3, r4
 801410c:	f000 f806 	bl	801411c <ip4_output_if_src>
 8014110:	0003      	movs	r3, r0
#endif /* IP_OPTIONS_SEND */
}
 8014112:	0018      	movs	r0, r3
 8014114:	46bd      	mov	sp, r7
 8014116:	b007      	add	sp, #28
 8014118:	bd90      	pop	{r4, r7, pc}
	...

0801411c <ip4_output_if_src>:
 */
err_t
ip4_output_if_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
                  u8_t ttl, u8_t tos,
                  u8_t proto, struct netif *netif)
{
 801411c:	b590      	push	{r4, r7, lr}
 801411e:	b089      	sub	sp, #36	; 0x24
 8014120:	af00      	add	r7, sp, #0
 8014122:	60f8      	str	r0, [r7, #12]
 8014124:	60b9      	str	r1, [r7, #8]
 8014126:	607a      	str	r2, [r7, #4]
 8014128:	001a      	movs	r2, r3
 801412a:	1cfb      	adds	r3, r7, #3
 801412c:	701a      	strb	r2, [r3, #0]
{
#endif /* IP_OPTIONS_SEND */
  struct ip_hdr *iphdr;
  ip4_addr_t dest_addr;
#if CHECKSUM_GEN_IP_INLINE
  u32_t chk_sum = 0;
 801412e:	2300      	movs	r3, #0
 8014130:	61fb      	str	r3, [r7, #28]
#endif /* CHECKSUM_GEN_IP_INLINE */

  LWIP_ASSERT_CORE_LOCKED();
  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
 8014132:	68fb      	ldr	r3, [r7, #12]
 8014134:	7b9b      	ldrb	r3, [r3, #14]
 8014136:	2b01      	cmp	r3, #1
 8014138:	d006      	beq.n	8014148 <ip4_output_if_src+0x2c>
 801413a:	4bde      	ldr	r3, [pc, #888]	; (80144b4 <ip4_output_if_src+0x398>)
 801413c:	22d5      	movs	r2, #213	; 0xd5
 801413e:	0092      	lsls	r2, r2, #2
 8014140:	49dd      	ldr	r1, [pc, #884]	; (80144b8 <ip4_output_if_src+0x39c>)
 8014142:	48de      	ldr	r0, [pc, #888]	; (80144bc <ip4_output_if_src+0x3a0>)
 8014144:	f7ee f84e 	bl	80021e4 <app_debug_rtt_raw>

  MIB2_STATS_INC(mib2.ipoutrequests);

  /* Should the IP header be generated or is it already included in p? */
  if (dest != LWIP_IP_HDRINCL) {
 8014148:	687b      	ldr	r3, [r7, #4]
 801414a:	2b00      	cmp	r3, #0
 801414c:	d100      	bne.n	8014150 <ip4_output_if_src+0x34>
 801414e:	e1aa      	b.n	80144a6 <ip4_output_if_src+0x38a>
    u16_t ip_hlen = IP_HLEN;
 8014150:	2316      	movs	r3, #22
 8014152:	18fb      	adds	r3, r7, r3
 8014154:	2214      	movs	r2, #20
 8014156:	801a      	strh	r2, [r3, #0]
      }
#endif /* CHECKSUM_GEN_IP_INLINE */
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_add_header(p, IP_HLEN)) {
 8014158:	68fb      	ldr	r3, [r7, #12]
 801415a:	2114      	movs	r1, #20
 801415c:	0018      	movs	r0, r3
 801415e:	f7f6 f917 	bl	800a390 <pbuf_add_header>
 8014162:	1e03      	subs	r3, r0, #0
 8014164:	d002      	beq.n	801416c <ip4_output_if_src+0x50>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      MIB2_STATS_INC(mib2.ipoutdiscards);
      return ERR_BUF;
 8014166:	2302      	movs	r3, #2
 8014168:	425b      	negs	r3, r3
 801416a:	e1c8      	b.n	80144fe <ip4_output_if_src+0x3e2>
    }

    iphdr = (struct ip_hdr *)p->payload;
 801416c:	68fb      	ldr	r3, [r7, #12]
 801416e:	685b      	ldr	r3, [r3, #4]
 8014170:	61bb      	str	r3, [r7, #24]
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
 8014172:	68fb      	ldr	r3, [r7, #12]
 8014174:	895b      	ldrh	r3, [r3, #10]
 8014176:	2b13      	cmp	r3, #19
 8014178:	d806      	bhi.n	8014188 <ip4_output_if_src+0x6c>
 801417a:	4bce      	ldr	r3, [pc, #824]	; (80144b4 <ip4_output_if_src+0x398>)
 801417c:	22e2      	movs	r2, #226	; 0xe2
 801417e:	0092      	lsls	r2, r2, #2
 8014180:	49cf      	ldr	r1, [pc, #828]	; (80144c0 <ip4_output_if_src+0x3a4>)
 8014182:	48ce      	ldr	r0, [pc, #824]	; (80144bc <ip4_output_if_src+0x3a0>)
 8014184:	f7ee f82e 	bl	80021e4 <app_debug_rtt_raw>
                (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
 8014188:	69bb      	ldr	r3, [r7, #24]
 801418a:	1cfa      	adds	r2, r7, #3
 801418c:	7812      	ldrb	r2, [r2, #0]
 801418e:	721a      	strb	r2, [r3, #8]
    IPH_PROTO_SET(iphdr, proto);
 8014190:	69bb      	ldr	r3, [r7, #24]
 8014192:	2134      	movs	r1, #52	; 0x34
 8014194:	187a      	adds	r2, r7, r1
 8014196:	7812      	ldrb	r2, [r2, #0]
 8014198:	725a      	strb	r2, [r3, #9]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += PP_NTOHS(proto | (ttl << 8));
 801419a:	187b      	adds	r3, r7, r1
 801419c:	781a      	ldrb	r2, [r3, #0]
 801419e:	1cfb      	adds	r3, r7, #3
 80141a0:	781b      	ldrb	r3, [r3, #0]
 80141a2:	021b      	lsls	r3, r3, #8
 80141a4:	4313      	orrs	r3, r2
 80141a6:	021b      	lsls	r3, r3, #8
 80141a8:	b21a      	sxth	r2, r3
 80141aa:	187b      	adds	r3, r7, r1
 80141ac:	7819      	ldrb	r1, [r3, #0]
 80141ae:	1cfb      	adds	r3, r7, #3
 80141b0:	781b      	ldrb	r3, [r3, #0]
 80141b2:	021b      	lsls	r3, r3, #8
 80141b4:	430b      	orrs	r3, r1
 80141b6:	121b      	asrs	r3, r3, #8
 80141b8:	b21b      	sxth	r3, r3
 80141ba:	21ff      	movs	r1, #255	; 0xff
 80141bc:	400b      	ands	r3, r1
 80141be:	b21b      	sxth	r3, r3
 80141c0:	4313      	orrs	r3, r2
 80141c2:	b21b      	sxth	r3, r3
 80141c4:	b29b      	uxth	r3, r3
 80141c6:	001a      	movs	r2, r3
 80141c8:	69fb      	ldr	r3, [r7, #28]
 80141ca:	189b      	adds	r3, r3, r2
 80141cc:	61fb      	str	r3, [r7, #28]
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip4_addr_copy(iphdr->dest, *dest);
 80141ce:	687b      	ldr	r3, [r7, #4]
 80141d0:	681a      	ldr	r2, [r3, #0]
 80141d2:	69bb      	ldr	r3, [r7, #24]
 80141d4:	21ff      	movs	r1, #255	; 0xff
 80141d6:	4011      	ands	r1, r2
 80141d8:	000c      	movs	r4, r1
 80141da:	7c19      	ldrb	r1, [r3, #16]
 80141dc:	2000      	movs	r0, #0
 80141de:	4001      	ands	r1, r0
 80141e0:	1c08      	adds	r0, r1, #0
 80141e2:	1c21      	adds	r1, r4, #0
 80141e4:	4301      	orrs	r1, r0
 80141e6:	7419      	strb	r1, [r3, #16]
 80141e8:	0a11      	lsrs	r1, r2, #8
 80141ea:	20ff      	movs	r0, #255	; 0xff
 80141ec:	4001      	ands	r1, r0
 80141ee:	000c      	movs	r4, r1
 80141f0:	7c59      	ldrb	r1, [r3, #17]
 80141f2:	2000      	movs	r0, #0
 80141f4:	4001      	ands	r1, r0
 80141f6:	1c08      	adds	r0, r1, #0
 80141f8:	1c21      	adds	r1, r4, #0
 80141fa:	4301      	orrs	r1, r0
 80141fc:	7459      	strb	r1, [r3, #17]
 80141fe:	0c11      	lsrs	r1, r2, #16
 8014200:	20ff      	movs	r0, #255	; 0xff
 8014202:	4001      	ands	r1, r0
 8014204:	000c      	movs	r4, r1
 8014206:	7c99      	ldrb	r1, [r3, #18]
 8014208:	2000      	movs	r0, #0
 801420a:	4001      	ands	r1, r0
 801420c:	1c08      	adds	r0, r1, #0
 801420e:	1c21      	adds	r1, r4, #0
 8014210:	4301      	orrs	r1, r0
 8014212:	7499      	strb	r1, [r3, #18]
 8014214:	0e10      	lsrs	r0, r2, #24
 8014216:	7cda      	ldrb	r2, [r3, #19]
 8014218:	2100      	movs	r1, #0
 801421a:	400a      	ands	r2, r1
 801421c:	1c11      	adds	r1, r2, #0
 801421e:	1c02      	adds	r2, r0, #0
 8014220:	430a      	orrs	r2, r1
 8014222:	74da      	strb	r2, [r3, #19]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
 8014224:	69bb      	ldr	r3, [r7, #24]
 8014226:	7c1a      	ldrb	r2, [r3, #16]
 8014228:	7c59      	ldrb	r1, [r3, #17]
 801422a:	0209      	lsls	r1, r1, #8
 801422c:	430a      	orrs	r2, r1
 801422e:	7c99      	ldrb	r1, [r3, #18]
 8014230:	0409      	lsls	r1, r1, #16
 8014232:	430a      	orrs	r2, r1
 8014234:	7cdb      	ldrb	r3, [r3, #19]
 8014236:	061b      	lsls	r3, r3, #24
 8014238:	4313      	orrs	r3, r2
 801423a:	041b      	lsls	r3, r3, #16
 801423c:	0c1b      	lsrs	r3, r3, #16
 801423e:	69fa      	ldr	r2, [r7, #28]
 8014240:	18d3      	adds	r3, r2, r3
 8014242:	61fb      	str	r3, [r7, #28]
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
 8014244:	69bb      	ldr	r3, [r7, #24]
 8014246:	7c1a      	ldrb	r2, [r3, #16]
 8014248:	7c59      	ldrb	r1, [r3, #17]
 801424a:	0209      	lsls	r1, r1, #8
 801424c:	430a      	orrs	r2, r1
 801424e:	7c99      	ldrb	r1, [r3, #18]
 8014250:	0409      	lsls	r1, r1, #16
 8014252:	430a      	orrs	r2, r1
 8014254:	7cdb      	ldrb	r3, [r3, #19]
 8014256:	061b      	lsls	r3, r3, #24
 8014258:	4313      	orrs	r3, r2
 801425a:	0c1b      	lsrs	r3, r3, #16
 801425c:	69fa      	ldr	r2, [r7, #28]
 801425e:	18d3      	adds	r3, r2, r3
 8014260:	61fb      	str	r3, [r7, #28]
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
 8014262:	2316      	movs	r3, #22
 8014264:	18fb      	adds	r3, r7, r3
 8014266:	881b      	ldrh	r3, [r3, #0]
 8014268:	089b      	lsrs	r3, r3, #2
 801426a:	b29b      	uxth	r3, r3
 801426c:	b2db      	uxtb	r3, r3
 801426e:	2240      	movs	r2, #64	; 0x40
 8014270:	4313      	orrs	r3, r2
 8014272:	b2da      	uxtb	r2, r3
 8014274:	69bb      	ldr	r3, [r7, #24]
 8014276:	701a      	strb	r2, [r3, #0]
    IPH_TOS_SET(iphdr, tos);
 8014278:	69ba      	ldr	r2, [r7, #24]
 801427a:	2130      	movs	r1, #48	; 0x30
 801427c:	187b      	adds	r3, r7, r1
 801427e:	781b      	ldrb	r3, [r3, #0]
 8014280:	7053      	strb	r3, [r2, #1]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += PP_NTOHS(tos | (iphdr->_v_hl << 8));
 8014282:	187b      	adds	r3, r7, r1
 8014284:	781a      	ldrb	r2, [r3, #0]
 8014286:	69bb      	ldr	r3, [r7, #24]
 8014288:	781b      	ldrb	r3, [r3, #0]
 801428a:	021b      	lsls	r3, r3, #8
 801428c:	4313      	orrs	r3, r2
 801428e:	021b      	lsls	r3, r3, #8
 8014290:	b21a      	sxth	r2, r3
 8014292:	187b      	adds	r3, r7, r1
 8014294:	7819      	ldrb	r1, [r3, #0]
 8014296:	69bb      	ldr	r3, [r7, #24]
 8014298:	781b      	ldrb	r3, [r3, #0]
 801429a:	021b      	lsls	r3, r3, #8
 801429c:	430b      	orrs	r3, r1
 801429e:	121b      	asrs	r3, r3, #8
 80142a0:	b21b      	sxth	r3, r3
 80142a2:	21ff      	movs	r1, #255	; 0xff
 80142a4:	400b      	ands	r3, r1
 80142a6:	b21b      	sxth	r3, r3
 80142a8:	4313      	orrs	r3, r2
 80142aa:	b21b      	sxth	r3, r3
 80142ac:	b29b      	uxth	r3, r3
 80142ae:	001a      	movs	r2, r3
 80142b0:	69fb      	ldr	r3, [r7, #28]
 80142b2:	189b      	adds	r3, r3, r2
 80142b4:	61fb      	str	r3, [r7, #28]
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, lwip_htons(p->tot_len));
 80142b6:	68fb      	ldr	r3, [r7, #12]
 80142b8:	891b      	ldrh	r3, [r3, #8]
 80142ba:	0018      	movs	r0, r3
 80142bc:	f7f3 f8a0 	bl	8007400 <lwip_htons>
 80142c0:	0003      	movs	r3, r0
 80142c2:	001a      	movs	r2, r3
 80142c4:	69bb      	ldr	r3, [r7, #24]
 80142c6:	21ff      	movs	r1, #255	; 0xff
 80142c8:	4011      	ands	r1, r2
 80142ca:	000c      	movs	r4, r1
 80142cc:	7899      	ldrb	r1, [r3, #2]
 80142ce:	2000      	movs	r0, #0
 80142d0:	4001      	ands	r1, r0
 80142d2:	1c08      	adds	r0, r1, #0
 80142d4:	1c21      	adds	r1, r4, #0
 80142d6:	4301      	orrs	r1, r0
 80142d8:	7099      	strb	r1, [r3, #2]
 80142da:	0a12      	lsrs	r2, r2, #8
 80142dc:	b290      	uxth	r0, r2
 80142de:	78da      	ldrb	r2, [r3, #3]
 80142e0:	2100      	movs	r1, #0
 80142e2:	400a      	ands	r2, r1
 80142e4:	1c11      	adds	r1, r2, #0
 80142e6:	1c02      	adds	r2, r0, #0
 80142e8:	430a      	orrs	r2, r1
 80142ea:	70da      	strb	r2, [r3, #3]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
 80142ec:	69bb      	ldr	r3, [r7, #24]
 80142ee:	789a      	ldrb	r2, [r3, #2]
 80142f0:	78db      	ldrb	r3, [r3, #3]
 80142f2:	021b      	lsls	r3, r3, #8
 80142f4:	4313      	orrs	r3, r2
 80142f6:	b29b      	uxth	r3, r3
 80142f8:	001a      	movs	r2, r3
 80142fa:	69fb      	ldr	r3, [r7, #28]
 80142fc:	189b      	adds	r3, r3, r2
 80142fe:	61fb      	str	r3, [r7, #28]
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
 8014300:	69bb      	ldr	r3, [r7, #24]
 8014302:	799a      	ldrb	r2, [r3, #6]
 8014304:	2100      	movs	r1, #0
 8014306:	400a      	ands	r2, r1
 8014308:	719a      	strb	r2, [r3, #6]
 801430a:	79da      	ldrb	r2, [r3, #7]
 801430c:	2100      	movs	r1, #0
 801430e:	400a      	ands	r2, r1
 8014310:	71da      	strb	r2, [r3, #7]
    IPH_ID_SET(iphdr, lwip_htons(ip_id));
 8014312:	4b6c      	ldr	r3, [pc, #432]	; (80144c4 <ip4_output_if_src+0x3a8>)
 8014314:	881b      	ldrh	r3, [r3, #0]
 8014316:	0018      	movs	r0, r3
 8014318:	f7f3 f872 	bl	8007400 <lwip_htons>
 801431c:	0003      	movs	r3, r0
 801431e:	001a      	movs	r2, r3
 8014320:	69bb      	ldr	r3, [r7, #24]
 8014322:	21ff      	movs	r1, #255	; 0xff
 8014324:	4011      	ands	r1, r2
 8014326:	000c      	movs	r4, r1
 8014328:	7919      	ldrb	r1, [r3, #4]
 801432a:	2000      	movs	r0, #0
 801432c:	4001      	ands	r1, r0
 801432e:	1c08      	adds	r0, r1, #0
 8014330:	1c21      	adds	r1, r4, #0
 8014332:	4301      	orrs	r1, r0
 8014334:	7119      	strb	r1, [r3, #4]
 8014336:	0a12      	lsrs	r2, r2, #8
 8014338:	b290      	uxth	r0, r2
 801433a:	795a      	ldrb	r2, [r3, #5]
 801433c:	2100      	movs	r1, #0
 801433e:	400a      	ands	r2, r1
 8014340:	1c11      	adds	r1, r2, #0
 8014342:	1c02      	adds	r2, r0, #0
 8014344:	430a      	orrs	r2, r1
 8014346:	715a      	strb	r2, [r3, #5]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
 8014348:	69bb      	ldr	r3, [r7, #24]
 801434a:	791a      	ldrb	r2, [r3, #4]
 801434c:	795b      	ldrb	r3, [r3, #5]
 801434e:	021b      	lsls	r3, r3, #8
 8014350:	4313      	orrs	r3, r2
 8014352:	b29b      	uxth	r3, r3
 8014354:	001a      	movs	r2, r3
 8014356:	69fb      	ldr	r3, [r7, #28]
 8014358:	189b      	adds	r3, r3, r2
 801435a:	61fb      	str	r3, [r7, #28]
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
 801435c:	4b59      	ldr	r3, [pc, #356]	; (80144c4 <ip4_output_if_src+0x3a8>)
 801435e:	881b      	ldrh	r3, [r3, #0]
 8014360:	3301      	adds	r3, #1
 8014362:	b29a      	uxth	r2, r3
 8014364:	4b57      	ldr	r3, [pc, #348]	; (80144c4 <ip4_output_if_src+0x3a8>)
 8014366:	801a      	strh	r2, [r3, #0]

    if (src == NULL) {
 8014368:	68bb      	ldr	r3, [r7, #8]
 801436a:	2b00      	cmp	r3, #0
 801436c:	d12b      	bne.n	80143c6 <ip4_output_if_src+0x2aa>
      ip4_addr_copy(iphdr->src, *IP4_ADDR_ANY4);
 801436e:	4b56      	ldr	r3, [pc, #344]	; (80144c8 <ip4_output_if_src+0x3ac>)
 8014370:	681a      	ldr	r2, [r3, #0]
 8014372:	69bb      	ldr	r3, [r7, #24]
 8014374:	21ff      	movs	r1, #255	; 0xff
 8014376:	4011      	ands	r1, r2
 8014378:	000c      	movs	r4, r1
 801437a:	7b19      	ldrb	r1, [r3, #12]
 801437c:	2000      	movs	r0, #0
 801437e:	4001      	ands	r1, r0
 8014380:	1c08      	adds	r0, r1, #0
 8014382:	1c21      	adds	r1, r4, #0
 8014384:	4301      	orrs	r1, r0
 8014386:	7319      	strb	r1, [r3, #12]
 8014388:	0a11      	lsrs	r1, r2, #8
 801438a:	20ff      	movs	r0, #255	; 0xff
 801438c:	4001      	ands	r1, r0
 801438e:	000c      	movs	r4, r1
 8014390:	7b59      	ldrb	r1, [r3, #13]
 8014392:	2000      	movs	r0, #0
 8014394:	4001      	ands	r1, r0
 8014396:	1c08      	adds	r0, r1, #0
 8014398:	1c21      	adds	r1, r4, #0
 801439a:	4301      	orrs	r1, r0
 801439c:	7359      	strb	r1, [r3, #13]
 801439e:	0c11      	lsrs	r1, r2, #16
 80143a0:	20ff      	movs	r0, #255	; 0xff
 80143a2:	4001      	ands	r1, r0
 80143a4:	000c      	movs	r4, r1
 80143a6:	7b99      	ldrb	r1, [r3, #14]
 80143a8:	2000      	movs	r0, #0
 80143aa:	4001      	ands	r1, r0
 80143ac:	1c08      	adds	r0, r1, #0
 80143ae:	1c21      	adds	r1, r4, #0
 80143b0:	4301      	orrs	r1, r0
 80143b2:	7399      	strb	r1, [r3, #14]
 80143b4:	0e10      	lsrs	r0, r2, #24
 80143b6:	7bda      	ldrb	r2, [r3, #15]
 80143b8:	2100      	movs	r1, #0
 80143ba:	400a      	ands	r2, r1
 80143bc:	1c11      	adds	r1, r2, #0
 80143be:	1c02      	adds	r2, r0, #0
 80143c0:	430a      	orrs	r2, r1
 80143c2:	73da      	strb	r2, [r3, #15]
 80143c4:	e02a      	b.n	801441c <ip4_output_if_src+0x300>
    } else {
      /* src cannot be NULL here */
      ip4_addr_copy(iphdr->src, *src);
 80143c6:	68bb      	ldr	r3, [r7, #8]
 80143c8:	681a      	ldr	r2, [r3, #0]
 80143ca:	69bb      	ldr	r3, [r7, #24]
 80143cc:	21ff      	movs	r1, #255	; 0xff
 80143ce:	4011      	ands	r1, r2
 80143d0:	000c      	movs	r4, r1
 80143d2:	7b19      	ldrb	r1, [r3, #12]
 80143d4:	2000      	movs	r0, #0
 80143d6:	4001      	ands	r1, r0
 80143d8:	1c08      	adds	r0, r1, #0
 80143da:	1c21      	adds	r1, r4, #0
 80143dc:	4301      	orrs	r1, r0
 80143de:	7319      	strb	r1, [r3, #12]
 80143e0:	0a11      	lsrs	r1, r2, #8
 80143e2:	20ff      	movs	r0, #255	; 0xff
 80143e4:	4001      	ands	r1, r0
 80143e6:	000c      	movs	r4, r1
 80143e8:	7b59      	ldrb	r1, [r3, #13]
 80143ea:	2000      	movs	r0, #0
 80143ec:	4001      	ands	r1, r0
 80143ee:	1c08      	adds	r0, r1, #0
 80143f0:	1c21      	adds	r1, r4, #0
 80143f2:	4301      	orrs	r1, r0
 80143f4:	7359      	strb	r1, [r3, #13]
 80143f6:	0c11      	lsrs	r1, r2, #16
 80143f8:	20ff      	movs	r0, #255	; 0xff
 80143fa:	4001      	ands	r1, r0
 80143fc:	000c      	movs	r4, r1
 80143fe:	7b99      	ldrb	r1, [r3, #14]
 8014400:	2000      	movs	r0, #0
 8014402:	4001      	ands	r1, r0
 8014404:	1c08      	adds	r0, r1, #0
 8014406:	1c21      	adds	r1, r4, #0
 8014408:	4301      	orrs	r1, r0
 801440a:	7399      	strb	r1, [r3, #14]
 801440c:	0e10      	lsrs	r0, r2, #24
 801440e:	7bda      	ldrb	r2, [r3, #15]
 8014410:	2100      	movs	r1, #0
 8014412:	400a      	ands	r2, r1
 8014414:	1c11      	adds	r1, r2, #0
 8014416:	1c02      	adds	r2, r0, #0
 8014418:	430a      	orrs	r2, r1
 801441a:	73da      	strb	r2, [r3, #15]
    }

#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
 801441c:	69bb      	ldr	r3, [r7, #24]
 801441e:	7b1a      	ldrb	r2, [r3, #12]
 8014420:	7b59      	ldrb	r1, [r3, #13]
 8014422:	0209      	lsls	r1, r1, #8
 8014424:	430a      	orrs	r2, r1
 8014426:	7b99      	ldrb	r1, [r3, #14]
 8014428:	0409      	lsls	r1, r1, #16
 801442a:	430a      	orrs	r2, r1
 801442c:	7bdb      	ldrb	r3, [r3, #15]
 801442e:	061b      	lsls	r3, r3, #24
 8014430:	4313      	orrs	r3, r2
 8014432:	041b      	lsls	r3, r3, #16
 8014434:	0c1b      	lsrs	r3, r3, #16
 8014436:	69fa      	ldr	r2, [r7, #28]
 8014438:	18d3      	adds	r3, r2, r3
 801443a:	61fb      	str	r3, [r7, #28]
    chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
 801443c:	69bb      	ldr	r3, [r7, #24]
 801443e:	7b1a      	ldrb	r2, [r3, #12]
 8014440:	7b59      	ldrb	r1, [r3, #13]
 8014442:	0209      	lsls	r1, r1, #8
 8014444:	430a      	orrs	r2, r1
 8014446:	7b99      	ldrb	r1, [r3, #14]
 8014448:	0409      	lsls	r1, r1, #16
 801444a:	430a      	orrs	r2, r1
 801444c:	7bdb      	ldrb	r3, [r3, #15]
 801444e:	061b      	lsls	r3, r3, #24
 8014450:	4313      	orrs	r3, r2
 8014452:	0c1b      	lsrs	r3, r3, #16
 8014454:	69fa      	ldr	r2, [r7, #28]
 8014456:	18d3      	adds	r3, r2, r3
 8014458:	61fb      	str	r3, [r7, #28]
    chk_sum = (chk_sum >> 16) + (chk_sum & 0xFFFF);
 801445a:	69fb      	ldr	r3, [r7, #28]
 801445c:	0c1a      	lsrs	r2, r3, #16
 801445e:	69fb      	ldr	r3, [r7, #28]
 8014460:	041b      	lsls	r3, r3, #16
 8014462:	0c1b      	lsrs	r3, r3, #16
 8014464:	18d3      	adds	r3, r2, r3
 8014466:	61fb      	str	r3, [r7, #28]
    chk_sum = (chk_sum >> 16) + chk_sum;
 8014468:	69fb      	ldr	r3, [r7, #28]
 801446a:	0c1b      	lsrs	r3, r3, #16
 801446c:	69fa      	ldr	r2, [r7, #28]
 801446e:	18d3      	adds	r3, r2, r3
 8014470:	61fb      	str	r3, [r7, #28]
    chk_sum = ~chk_sum;
 8014472:	69fb      	ldr	r3, [r7, #28]
 8014474:	43db      	mvns	r3, r3
 8014476:	61fb      	str	r3, [r7, #28]
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_IP) {
      iphdr->_chksum = (u16_t)chk_sum; /* network order */
 8014478:	69fb      	ldr	r3, [r7, #28]
 801447a:	b29a      	uxth	r2, r3
 801447c:	69bb      	ldr	r3, [r7, #24]
 801447e:	21ff      	movs	r1, #255	; 0xff
 8014480:	4011      	ands	r1, r2
 8014482:	000c      	movs	r4, r1
 8014484:	7a99      	ldrb	r1, [r3, #10]
 8014486:	2000      	movs	r0, #0
 8014488:	4001      	ands	r1, r0
 801448a:	1c08      	adds	r0, r1, #0
 801448c:	1c21      	adds	r1, r4, #0
 801448e:	4301      	orrs	r1, r0
 8014490:	7299      	strb	r1, [r3, #10]
 8014492:	0a12      	lsrs	r2, r2, #8
 8014494:	b290      	uxth	r0, r2
 8014496:	7ada      	ldrb	r2, [r3, #11]
 8014498:	2100      	movs	r1, #0
 801449a:	400a      	ands	r2, r1
 801449c:	1c11      	adds	r1, r2, #0
 801449e:	1c02      	adds	r2, r0, #0
 80144a0:	430a      	orrs	r2, r1
 80144a2:	72da      	strb	r2, [r3, #11]
 80144a4:	e024      	b.n	80144f0 <ip4_output_if_src+0x3d4>
    }
#endif /* CHECKSUM_GEN_IP */
#endif /* CHECKSUM_GEN_IP_INLINE */
  } else {
    /* IP header already included in p */
    if (p->len < IP_HLEN) {
 80144a6:	68fb      	ldr	r3, [r7, #12]
 80144a8:	895b      	ldrh	r3, [r3, #10]
 80144aa:	2b13      	cmp	r3, #19
 80144ac:	d80e      	bhi.n	80144cc <ip4_output_if_src+0x3b0>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output: LWIP_IP_HDRINCL but pbuf is too short\n"));
      IP_STATS_INC(ip.err);
      MIB2_STATS_INC(mib2.ipoutdiscards);
      return ERR_BUF;
 80144ae:	2302      	movs	r3, #2
 80144b0:	425b      	negs	r3, r3
 80144b2:	e024      	b.n	80144fe <ip4_output_if_src+0x3e2>
 80144b4:	08022514 	.word	0x08022514
 80144b8:	08022540 	.word	0x08022540
 80144bc:	0802254c 	.word	0x0802254c
 80144c0:	08022578 	.word	0x08022578
 80144c4:	20000c8c 	.word	0x20000c8c
 80144c8:	08023a8c 	.word	0x08023a8c
    }
    iphdr = (struct ip_hdr *)p->payload;
 80144cc:	68fb      	ldr	r3, [r7, #12]
 80144ce:	685b      	ldr	r3, [r3, #4]
 80144d0:	61bb      	str	r3, [r7, #24]
    ip4_addr_copy(dest_addr, iphdr->dest);
 80144d2:	69bb      	ldr	r3, [r7, #24]
 80144d4:	7c1a      	ldrb	r2, [r3, #16]
 80144d6:	7c59      	ldrb	r1, [r3, #17]
 80144d8:	0209      	lsls	r1, r1, #8
 80144da:	430a      	orrs	r2, r1
 80144dc:	7c99      	ldrb	r1, [r3, #18]
 80144de:	0409      	lsls	r1, r1, #16
 80144e0:	430a      	orrs	r2, r1
 80144e2:	7cdb      	ldrb	r3, [r3, #19]
 80144e4:	061b      	lsls	r3, r3, #24
 80144e6:	4313      	orrs	r3, r2
 80144e8:	613b      	str	r3, [r7, #16]
    dest = &dest_addr;
 80144ea:	2310      	movs	r3, #16
 80144ec:	18fb      	adds	r3, r7, r3
 80144ee:	607b      	str	r3, [r7, #4]
    return ip4_frag(p, netif, dest);
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("ip4_output_if: call netif->output()\n"));
  return netif->output(netif, p, dest);
 80144f0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80144f2:	695b      	ldr	r3, [r3, #20]
 80144f4:	687a      	ldr	r2, [r7, #4]
 80144f6:	68f9      	ldr	r1, [r7, #12]
 80144f8:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 80144fa:	4798      	blx	r3
 80144fc:	0003      	movs	r3, r0
}
 80144fe:	0018      	movs	r0, r3
 8014500:	46bd      	mov	sp, r7
 8014502:	b009      	add	sp, #36	; 0x24
 8014504:	bd90      	pop	{r4, r7, pc}
 8014506:	46c0      	nop			; (mov r8, r8)

08014508 <ip4_addr_isbroadcast_u32>:
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t
ip4_addr_isbroadcast_u32(u32_t addr, const struct netif *netif)
{
 8014508:	b580      	push	{r7, lr}
 801450a:	b084      	sub	sp, #16
 801450c:	af00      	add	r7, sp, #0
 801450e:	6078      	str	r0, [r7, #4]
 8014510:	6039      	str	r1, [r7, #0]
  ip4_addr_t ipaddr;
  ip4_addr_set_u32(&ipaddr, addr);
 8014512:	687b      	ldr	r3, [r7, #4]
 8014514:	60fb      	str	r3, [r7, #12]

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
 8014516:	687b      	ldr	r3, [r7, #4]
 8014518:	3301      	adds	r3, #1
 801451a:	d002      	beq.n	8014522 <ip4_addr_isbroadcast_u32+0x1a>
 801451c:	687b      	ldr	r3, [r7, #4]
 801451e:	2b00      	cmp	r3, #0
 8014520:	d101      	bne.n	8014526 <ip4_addr_isbroadcast_u32+0x1e>
      (addr == IPADDR_ANY)) {
    return 1;
 8014522:	2301      	movs	r3, #1
 8014524:	e029      	b.n	801457a <ip4_addr_isbroadcast_u32+0x72>
    /* no broadcast support on this network interface? */
  } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
 8014526:	683b      	ldr	r3, [r7, #0]
 8014528:	2231      	movs	r2, #49	; 0x31
 801452a:	5c9b      	ldrb	r3, [r3, r2]
 801452c:	001a      	movs	r2, r3
 801452e:	2302      	movs	r3, #2
 8014530:	4013      	ands	r3, r2
 8014532:	d101      	bne.n	8014538 <ip4_addr_isbroadcast_u32+0x30>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
 8014534:	2300      	movs	r3, #0
 8014536:	e020      	b.n	801457a <ip4_addr_isbroadcast_u32+0x72>
    /* address matches network interface address exactly? => no broadcast */
  } else if (addr == ip4_addr_get_u32(netif_ip4_addr(netif))) {
 8014538:	683b      	ldr	r3, [r7, #0]
 801453a:	3304      	adds	r3, #4
 801453c:	681b      	ldr	r3, [r3, #0]
 801453e:	687a      	ldr	r2, [r7, #4]
 8014540:	429a      	cmp	r2, r3
 8014542:	d101      	bne.n	8014548 <ip4_addr_isbroadcast_u32+0x40>
    return 0;
 8014544:	2300      	movs	r3, #0
 8014546:	e018      	b.n	801457a <ip4_addr_isbroadcast_u32+0x72>
    /*  on the same (sub) network... */
  } else if (ip4_addr_netcmp(&ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif))
 8014548:	68fa      	ldr	r2, [r7, #12]
 801454a:	683b      	ldr	r3, [r7, #0]
 801454c:	3304      	adds	r3, #4
 801454e:	681b      	ldr	r3, [r3, #0]
 8014550:	405a      	eors	r2, r3
 8014552:	683b      	ldr	r3, [r7, #0]
 8014554:	3308      	adds	r3, #8
 8014556:	681b      	ldr	r3, [r3, #0]
 8014558:	4013      	ands	r3, r2
 801455a:	d10d      	bne.n	8014578 <ip4_addr_isbroadcast_u32+0x70>
             /* ...and host identifier bits are all ones? =>... */
             && ((addr & ~ip4_addr_get_u32(netif_ip4_netmask(netif))) ==
 801455c:	683b      	ldr	r3, [r7, #0]
 801455e:	3308      	adds	r3, #8
 8014560:	681b      	ldr	r3, [r3, #0]
 8014562:	43db      	mvns	r3, r3
 8014564:	687a      	ldr	r2, [r7, #4]
 8014566:	401a      	ands	r2, r3
                 (IPADDR_BROADCAST & ~ip4_addr_get_u32(netif_ip4_netmask(netif))))) {
 8014568:	683b      	ldr	r3, [r7, #0]
 801456a:	3308      	adds	r3, #8
 801456c:	681b      	ldr	r3, [r3, #0]
 801456e:	43db      	mvns	r3, r3
             && ((addr & ~ip4_addr_get_u32(netif_ip4_netmask(netif))) ==
 8014570:	429a      	cmp	r2, r3
 8014572:	d101      	bne.n	8014578 <ip4_addr_isbroadcast_u32+0x70>
    /* => network broadcast address */
    return 1;
 8014574:	2301      	movs	r3, #1
 8014576:	e000      	b.n	801457a <ip4_addr_isbroadcast_u32+0x72>
  } else {
    return 0;
 8014578:	2300      	movs	r3, #0
  }
}
 801457a:	0018      	movs	r0, r3
 801457c:	46bd      	mov	sp, r7
 801457e:	b004      	add	sp, #16
 8014580:	bd80      	pop	{r7, pc}
	...

08014584 <ip4addr_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
ip4addr_aton(const char *cp, ip4_addr_t *addr)
{
 8014584:	b580      	push	{r7, lr}
 8014586:	b08a      	sub	sp, #40	; 0x28
 8014588:	af00      	add	r7, sp, #0
 801458a:	6078      	str	r0, [r7, #4]
 801458c:	6039      	str	r1, [r7, #0]
  u32_t val;
  u8_t base;
  char c;
  u32_t parts[4];
  u32_t *pp = parts;
 801458e:	230c      	movs	r3, #12
 8014590:	18fb      	adds	r3, r7, r3
 8014592:	61fb      	str	r3, [r7, #28]

  c = *cp;
 8014594:	2322      	movs	r3, #34	; 0x22
 8014596:	18fb      	adds	r3, r7, r3
 8014598:	687a      	ldr	r2, [r7, #4]
 801459a:	7812      	ldrb	r2, [r2, #0]
 801459c:	701a      	strb	r2, [r3, #0]
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!lwip_isdigit(c)) {
 801459e:	2322      	movs	r3, #34	; 0x22
 80145a0:	18fb      	adds	r3, r7, r3
 80145a2:	781b      	ldrb	r3, [r3, #0]
 80145a4:	1c5a      	adds	r2, r3, #1
 80145a6:	4b9d      	ldr	r3, [pc, #628]	; (801481c <ip4addr_aton+0x298>)
 80145a8:	18d3      	adds	r3, r2, r3
 80145aa:	781b      	ldrb	r3, [r3, #0]
 80145ac:	001a      	movs	r2, r3
 80145ae:	2304      	movs	r3, #4
 80145b0:	4013      	ands	r3, r2
 80145b2:	d101      	bne.n	80145b8 <ip4addr_aton+0x34>
      return 0;
 80145b4:	2300      	movs	r3, #0
 80145b6:	e12d      	b.n	8014814 <ip4addr_aton+0x290>
    }
    val = 0;
 80145b8:	2300      	movs	r3, #0
 80145ba:	627b      	str	r3, [r7, #36]	; 0x24
    base = 10;
 80145bc:	2323      	movs	r3, #35	; 0x23
 80145be:	18fb      	adds	r3, r7, r3
 80145c0:	220a      	movs	r2, #10
 80145c2:	701a      	strb	r2, [r3, #0]
    if (c == '0') {
 80145c4:	2222      	movs	r2, #34	; 0x22
 80145c6:	18bb      	adds	r3, r7, r2
 80145c8:	781b      	ldrb	r3, [r3, #0]
 80145ca:	2b30      	cmp	r3, #48	; 0x30
 80145cc:	d121      	bne.n	8014612 <ip4addr_aton+0x8e>
      c = *++cp;
 80145ce:	687b      	ldr	r3, [r7, #4]
 80145d0:	3301      	adds	r3, #1
 80145d2:	607b      	str	r3, [r7, #4]
 80145d4:	0011      	movs	r1, r2
 80145d6:	18bb      	adds	r3, r7, r2
 80145d8:	687a      	ldr	r2, [r7, #4]
 80145da:	7812      	ldrb	r2, [r2, #0]
 80145dc:	701a      	strb	r2, [r3, #0]
      if (c == 'x' || c == 'X') {
 80145de:	000a      	movs	r2, r1
 80145e0:	18bb      	adds	r3, r7, r2
 80145e2:	781b      	ldrb	r3, [r3, #0]
 80145e4:	2b78      	cmp	r3, #120	; 0x78
 80145e6:	d003      	beq.n	80145f0 <ip4addr_aton+0x6c>
 80145e8:	18bb      	adds	r3, r7, r2
 80145ea:	781b      	ldrb	r3, [r3, #0]
 80145ec:	2b58      	cmp	r3, #88	; 0x58
 80145ee:	d10c      	bne.n	801460a <ip4addr_aton+0x86>
        base = 16;
 80145f0:	2323      	movs	r3, #35	; 0x23
 80145f2:	18fb      	adds	r3, r7, r3
 80145f4:	2210      	movs	r2, #16
 80145f6:	701a      	strb	r2, [r3, #0]
        c = *++cp;
 80145f8:	687b      	ldr	r3, [r7, #4]
 80145fa:	3301      	adds	r3, #1
 80145fc:	607b      	str	r3, [r7, #4]
 80145fe:	2322      	movs	r3, #34	; 0x22
 8014600:	18fb      	adds	r3, r7, r3
 8014602:	687a      	ldr	r2, [r7, #4]
 8014604:	7812      	ldrb	r2, [r2, #0]
 8014606:	701a      	strb	r2, [r3, #0]
 8014608:	e003      	b.n	8014612 <ip4addr_aton+0x8e>
      } else {
        base = 8;
 801460a:	2323      	movs	r3, #35	; 0x23
 801460c:	18fb      	adds	r3, r7, r3
 801460e:	2208      	movs	r2, #8
 8014610:	701a      	strb	r2, [r3, #0]
      }
    }
    for (;;) {
      if (lwip_isdigit(c)) {
 8014612:	2122      	movs	r1, #34	; 0x22
 8014614:	187b      	adds	r3, r7, r1
 8014616:	781b      	ldrb	r3, [r3, #0]
 8014618:	1c5a      	adds	r2, r3, #1
 801461a:	4b80      	ldr	r3, [pc, #512]	; (801481c <ip4addr_aton+0x298>)
 801461c:	18d3      	adds	r3, r2, r3
 801461e:	781b      	ldrb	r3, [r3, #0]
 8014620:	001a      	movs	r2, r3
 8014622:	2304      	movs	r3, #4
 8014624:	4013      	ands	r3, r2
 8014626:	d01c      	beq.n	8014662 <ip4addr_aton+0xde>
        if((base == 8) && ((u32_t)(c - '0') >= 8))
 8014628:	2323      	movs	r3, #35	; 0x23
 801462a:	18fb      	adds	r3, r7, r3
 801462c:	781b      	ldrb	r3, [r3, #0]
 801462e:	2b08      	cmp	r3, #8
 8014630:	d104      	bne.n	801463c <ip4addr_aton+0xb8>
 8014632:	187b      	adds	r3, r7, r1
 8014634:	781b      	ldrb	r3, [r3, #0]
 8014636:	3b30      	subs	r3, #48	; 0x30
 8014638:	2b07      	cmp	r3, #7
 801463a:	d843      	bhi.n	80146c4 <ip4addr_aton+0x140>
          break;
        val = (val * base) + (u32_t)(c - '0');
 801463c:	2323      	movs	r3, #35	; 0x23
 801463e:	18fb      	adds	r3, r7, r3
 8014640:	781b      	ldrb	r3, [r3, #0]
 8014642:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8014644:	435a      	muls	r2, r3
 8014646:	2122      	movs	r1, #34	; 0x22
 8014648:	187b      	adds	r3, r7, r1
 801464a:	781b      	ldrb	r3, [r3, #0]
 801464c:	18d3      	adds	r3, r2, r3
 801464e:	3b30      	subs	r3, #48	; 0x30
 8014650:	627b      	str	r3, [r7, #36]	; 0x24
        c = *++cp;
 8014652:	687b      	ldr	r3, [r7, #4]
 8014654:	3301      	adds	r3, #1
 8014656:	607b      	str	r3, [r7, #4]
 8014658:	187b      	adds	r3, r7, r1
 801465a:	687a      	ldr	r2, [r7, #4]
 801465c:	7812      	ldrb	r2, [r2, #0]
 801465e:	701a      	strb	r2, [r3, #0]
 8014660:	e7d7      	b.n	8014612 <ip4addr_aton+0x8e>
      } else if (base == 16 && lwip_isxdigit(c)) {
 8014662:	2323      	movs	r3, #35	; 0x23
 8014664:	18fb      	adds	r3, r7, r3
 8014666:	781b      	ldrb	r3, [r3, #0]
 8014668:	2b10      	cmp	r3, #16
 801466a:	d12c      	bne.n	80146c6 <ip4addr_aton+0x142>
 801466c:	2122      	movs	r1, #34	; 0x22
 801466e:	187b      	adds	r3, r7, r1
 8014670:	781b      	ldrb	r3, [r3, #0]
 8014672:	1c5a      	adds	r2, r3, #1
 8014674:	4b69      	ldr	r3, [pc, #420]	; (801481c <ip4addr_aton+0x298>)
 8014676:	18d3      	adds	r3, r2, r3
 8014678:	781b      	ldrb	r3, [r3, #0]
 801467a:	001a      	movs	r2, r3
 801467c:	2344      	movs	r3, #68	; 0x44
 801467e:	4013      	ands	r3, r2
 8014680:	d021      	beq.n	80146c6 <ip4addr_aton+0x142>
        val = (val << 4) | (u32_t)(c + 10 - (lwip_islower(c) ? 'a' : 'A'));
 8014682:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014684:	011a      	lsls	r2, r3, #4
 8014686:	0008      	movs	r0, r1
 8014688:	187b      	adds	r3, r7, r1
 801468a:	781b      	ldrb	r3, [r3, #0]
 801468c:	330a      	adds	r3, #10
 801468e:	0019      	movs	r1, r3
 8014690:	183b      	adds	r3, r7, r0
 8014692:	781b      	ldrb	r3, [r3, #0]
 8014694:	1c58      	adds	r0, r3, #1
 8014696:	4b61      	ldr	r3, [pc, #388]	; (801481c <ip4addr_aton+0x298>)
 8014698:	18c3      	adds	r3, r0, r3
 801469a:	781b      	ldrb	r3, [r3, #0]
 801469c:	0018      	movs	r0, r3
 801469e:	2303      	movs	r3, #3
 80146a0:	4003      	ands	r3, r0
 80146a2:	2b02      	cmp	r3, #2
 80146a4:	d101      	bne.n	80146aa <ip4addr_aton+0x126>
 80146a6:	2361      	movs	r3, #97	; 0x61
 80146a8:	e000      	b.n	80146ac <ip4addr_aton+0x128>
 80146aa:	2341      	movs	r3, #65	; 0x41
 80146ac:	1acb      	subs	r3, r1, r3
 80146ae:	4313      	orrs	r3, r2
 80146b0:	627b      	str	r3, [r7, #36]	; 0x24
        c = *++cp;
 80146b2:	687b      	ldr	r3, [r7, #4]
 80146b4:	3301      	adds	r3, #1
 80146b6:	607b      	str	r3, [r7, #4]
 80146b8:	2322      	movs	r3, #34	; 0x22
 80146ba:	18fb      	adds	r3, r7, r3
 80146bc:	687a      	ldr	r2, [r7, #4]
 80146be:	7812      	ldrb	r2, [r2, #0]
 80146c0:	701a      	strb	r2, [r3, #0]
      if (lwip_isdigit(c)) {
 80146c2:	e7a6      	b.n	8014612 <ip4addr_aton+0x8e>
          break;
 80146c4:	46c0      	nop			; (mov r8, r8)
      } else {
        break;
      }
    }
    if (c == '.') {
 80146c6:	2322      	movs	r3, #34	; 0x22
 80146c8:	18fb      	adds	r3, r7, r3
 80146ca:	781b      	ldrb	r3, [r3, #0]
 80146cc:	2b2e      	cmp	r3, #46	; 0x2e
 80146ce:	d115      	bne.n	80146fc <ip4addr_aton+0x178>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3) {
 80146d0:	230c      	movs	r3, #12
 80146d2:	18fb      	adds	r3, r7, r3
 80146d4:	330c      	adds	r3, #12
 80146d6:	69fa      	ldr	r2, [r7, #28]
 80146d8:	429a      	cmp	r2, r3
 80146da:	d301      	bcc.n	80146e0 <ip4addr_aton+0x15c>
        return 0;
 80146dc:	2300      	movs	r3, #0
 80146de:	e099      	b.n	8014814 <ip4addr_aton+0x290>
      }
      *pp++ = val;
 80146e0:	69fb      	ldr	r3, [r7, #28]
 80146e2:	1d1a      	adds	r2, r3, #4
 80146e4:	61fa      	str	r2, [r7, #28]
 80146e6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80146e8:	601a      	str	r2, [r3, #0]
      c = *++cp;
 80146ea:	687b      	ldr	r3, [r7, #4]
 80146ec:	3301      	adds	r3, #1
 80146ee:	607b      	str	r3, [r7, #4]
 80146f0:	2322      	movs	r3, #34	; 0x22
 80146f2:	18fb      	adds	r3, r7, r3
 80146f4:	687a      	ldr	r2, [r7, #4]
 80146f6:	7812      	ldrb	r2, [r2, #0]
 80146f8:	701a      	strb	r2, [r3, #0]
    if (!lwip_isdigit(c)) {
 80146fa:	e750      	b.n	801459e <ip4addr_aton+0x1a>
    } else {
      break;
 80146fc:	46c0      	nop			; (mov r8, r8)
    }
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && !lwip_isspace(c)) {
 80146fe:	2222      	movs	r2, #34	; 0x22
 8014700:	18bb      	adds	r3, r7, r2
 8014702:	781b      	ldrb	r3, [r3, #0]
 8014704:	2b00      	cmp	r3, #0
 8014706:	d00b      	beq.n	8014720 <ip4addr_aton+0x19c>
 8014708:	18bb      	adds	r3, r7, r2
 801470a:	781b      	ldrb	r3, [r3, #0]
 801470c:	1c5a      	adds	r2, r3, #1
 801470e:	4b43      	ldr	r3, [pc, #268]	; (801481c <ip4addr_aton+0x298>)
 8014710:	18d3      	adds	r3, r2, r3
 8014712:	781b      	ldrb	r3, [r3, #0]
 8014714:	001a      	movs	r2, r3
 8014716:	2308      	movs	r3, #8
 8014718:	4013      	ands	r3, r2
 801471a:	d101      	bne.n	8014720 <ip4addr_aton+0x19c>
    return 0;
 801471c:	2300      	movs	r3, #0
 801471e:	e079      	b.n	8014814 <ip4addr_aton+0x290>
  }
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  switch (pp - parts + 1) {
 8014720:	230c      	movs	r3, #12
 8014722:	18fb      	adds	r3, r7, r3
 8014724:	69fa      	ldr	r2, [r7, #28]
 8014726:	1ad3      	subs	r3, r2, r3
 8014728:	109b      	asrs	r3, r3, #2
 801472a:	3301      	adds	r3, #1
 801472c:	2b04      	cmp	r3, #4
 801472e:	d85e      	bhi.n	80147ee <ip4addr_aton+0x26a>
 8014730:	009a      	lsls	r2, r3, #2
 8014732:	4b3b      	ldr	r3, [pc, #236]	; (8014820 <ip4addr_aton+0x29c>)
 8014734:	18d3      	adds	r3, r2, r3
 8014736:	681b      	ldr	r3, [r3, #0]
 8014738:	469f      	mov	pc, r3

    case 0:
      return 0;       /* initial nondigit */
 801473a:	2300      	movs	r3, #0
 801473c:	e06a      	b.n	8014814 <ip4addr_aton+0x290>

    case 1:             /* a -- 32 bits */
      break;

    case 2:             /* a.b -- 8.24 bits */
      if (val > 0xffffffUL) {
 801473e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8014740:	2380      	movs	r3, #128	; 0x80
 8014742:	045b      	lsls	r3, r3, #17
 8014744:	429a      	cmp	r2, r3
 8014746:	d301      	bcc.n	801474c <ip4addr_aton+0x1c8>
        return 0;
 8014748:	2300      	movs	r3, #0
 801474a:	e063      	b.n	8014814 <ip4addr_aton+0x290>
      }
      if (parts[0] > 0xff) {
 801474c:	230c      	movs	r3, #12
 801474e:	18fb      	adds	r3, r7, r3
 8014750:	681b      	ldr	r3, [r3, #0]
 8014752:	2bff      	cmp	r3, #255	; 0xff
 8014754:	d901      	bls.n	801475a <ip4addr_aton+0x1d6>
        return 0;
 8014756:	2300      	movs	r3, #0
 8014758:	e05c      	b.n	8014814 <ip4addr_aton+0x290>
      }
      val |= parts[0] << 24;
 801475a:	230c      	movs	r3, #12
 801475c:	18fb      	adds	r3, r7, r3
 801475e:	681b      	ldr	r3, [r3, #0]
 8014760:	061b      	lsls	r3, r3, #24
 8014762:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8014764:	4313      	orrs	r3, r2
 8014766:	627b      	str	r3, [r7, #36]	; 0x24
      break;
 8014768:	e049      	b.n	80147fe <ip4addr_aton+0x27a>

    case 3:             /* a.b.c -- 8.8.16 bits */
      if (val > 0xffff) {
 801476a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801476c:	2380      	movs	r3, #128	; 0x80
 801476e:	025b      	lsls	r3, r3, #9
 8014770:	429a      	cmp	r2, r3
 8014772:	d301      	bcc.n	8014778 <ip4addr_aton+0x1f4>
        return 0;
 8014774:	2300      	movs	r3, #0
 8014776:	e04d      	b.n	8014814 <ip4addr_aton+0x290>
      }
      if ((parts[0] > 0xff) || (parts[1] > 0xff)) {
 8014778:	220c      	movs	r2, #12
 801477a:	18bb      	adds	r3, r7, r2
 801477c:	681b      	ldr	r3, [r3, #0]
 801477e:	2bff      	cmp	r3, #255	; 0xff
 8014780:	d803      	bhi.n	801478a <ip4addr_aton+0x206>
 8014782:	18bb      	adds	r3, r7, r2
 8014784:	685b      	ldr	r3, [r3, #4]
 8014786:	2bff      	cmp	r3, #255	; 0xff
 8014788:	d901      	bls.n	801478e <ip4addr_aton+0x20a>
        return 0;
 801478a:	2300      	movs	r3, #0
 801478c:	e042      	b.n	8014814 <ip4addr_aton+0x290>
      }
      val |= (parts[0] << 24) | (parts[1] << 16);
 801478e:	210c      	movs	r1, #12
 8014790:	187b      	adds	r3, r7, r1
 8014792:	681b      	ldr	r3, [r3, #0]
 8014794:	061a      	lsls	r2, r3, #24
 8014796:	187b      	adds	r3, r7, r1
 8014798:	685b      	ldr	r3, [r3, #4]
 801479a:	041b      	lsls	r3, r3, #16
 801479c:	4313      	orrs	r3, r2
 801479e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80147a0:	4313      	orrs	r3, r2
 80147a2:	627b      	str	r3, [r7, #36]	; 0x24
      break;
 80147a4:	e02b      	b.n	80147fe <ip4addr_aton+0x27a>

    case 4:             /* a.b.c.d -- 8.8.8.8 bits */
      if (val > 0xff) {
 80147a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80147a8:	2bff      	cmp	r3, #255	; 0xff
 80147aa:	d901      	bls.n	80147b0 <ip4addr_aton+0x22c>
        return 0;
 80147ac:	2300      	movs	r3, #0
 80147ae:	e031      	b.n	8014814 <ip4addr_aton+0x290>
      }
      if ((parts[0] > 0xff) || (parts[1] > 0xff) || (parts[2] > 0xff)) {
 80147b0:	220c      	movs	r2, #12
 80147b2:	18bb      	adds	r3, r7, r2
 80147b4:	681b      	ldr	r3, [r3, #0]
 80147b6:	2bff      	cmp	r3, #255	; 0xff
 80147b8:	d807      	bhi.n	80147ca <ip4addr_aton+0x246>
 80147ba:	18bb      	adds	r3, r7, r2
 80147bc:	685b      	ldr	r3, [r3, #4]
 80147be:	2bff      	cmp	r3, #255	; 0xff
 80147c0:	d803      	bhi.n	80147ca <ip4addr_aton+0x246>
 80147c2:	18bb      	adds	r3, r7, r2
 80147c4:	689b      	ldr	r3, [r3, #8]
 80147c6:	2bff      	cmp	r3, #255	; 0xff
 80147c8:	d901      	bls.n	80147ce <ip4addr_aton+0x24a>
        return 0;
 80147ca:	2300      	movs	r3, #0
 80147cc:	e022      	b.n	8014814 <ip4addr_aton+0x290>
      }
      val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
 80147ce:	210c      	movs	r1, #12
 80147d0:	187b      	adds	r3, r7, r1
 80147d2:	681b      	ldr	r3, [r3, #0]
 80147d4:	061a      	lsls	r2, r3, #24
 80147d6:	187b      	adds	r3, r7, r1
 80147d8:	685b      	ldr	r3, [r3, #4]
 80147da:	041b      	lsls	r3, r3, #16
 80147dc:	431a      	orrs	r2, r3
 80147de:	187b      	adds	r3, r7, r1
 80147e0:	689b      	ldr	r3, [r3, #8]
 80147e2:	021b      	lsls	r3, r3, #8
 80147e4:	4313      	orrs	r3, r2
 80147e6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80147e8:	4313      	orrs	r3, r2
 80147ea:	627b      	str	r3, [r7, #36]	; 0x24
      break;
 80147ec:	e007      	b.n	80147fe <ip4addr_aton+0x27a>
    default:
      LWIP_ASSERT("unhandled", 0);
 80147ee:	4b0d      	ldr	r3, [pc, #52]	; (8014824 <ip4addr_aton+0x2a0>)
 80147f0:	490d      	ldr	r1, [pc, #52]	; (8014828 <ip4addr_aton+0x2a4>)
 80147f2:	480e      	ldr	r0, [pc, #56]	; (801482c <ip4addr_aton+0x2a8>)
 80147f4:	22fb      	movs	r2, #251	; 0xfb
 80147f6:	f7ed fcf5 	bl	80021e4 <app_debug_rtt_raw>
      break;
 80147fa:	e000      	b.n	80147fe <ip4addr_aton+0x27a>
      break;
 80147fc:	46c0      	nop			; (mov r8, r8)
  }
  if (addr) {
 80147fe:	683b      	ldr	r3, [r7, #0]
 8014800:	2b00      	cmp	r3, #0
 8014802:	d006      	beq.n	8014812 <ip4addr_aton+0x28e>
    ip4_addr_set_u32(addr, lwip_htonl(val));
 8014804:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014806:	0018      	movs	r0, r3
 8014808:	f7f2 fe10 	bl	800742c <lwip_htonl>
 801480c:	0002      	movs	r2, r0
 801480e:	683b      	ldr	r3, [r7, #0]
 8014810:	601a      	str	r2, [r3, #0]
  }
  return 1;
 8014812:	2301      	movs	r3, #1
}
 8014814:	0018      	movs	r0, r3
 8014816:	46bd      	mov	sp, r7
 8014818:	b00a      	add	sp, #40	; 0x28
 801481a:	bd80      	pop	{r7, pc}
 801481c:	08024088 	.word	0x08024088
 8014820:	08023a94 	.word	0x08023a94
 8014824:	080225a8 	.word	0x080225a8
 8014828:	080225d8 	.word	0x080225d8
 801482c:	080225e4 	.word	0x080225e4

08014830 <ip4addr_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         representation of addr
 */
char *
ip4addr_ntoa(const ip4_addr_t *addr)
{
 8014830:	b580      	push	{r7, lr}
 8014832:	b082      	sub	sp, #8
 8014834:	af00      	add	r7, sp, #0
 8014836:	6078      	str	r0, [r7, #4]
  static char str[IP4ADDR_STRLEN_MAX];
  return ip4addr_ntoa_r(addr, str, IP4ADDR_STRLEN_MAX);
 8014838:	4905      	ldr	r1, [pc, #20]	; (8014850 <ip4addr_ntoa+0x20>)
 801483a:	687b      	ldr	r3, [r7, #4]
 801483c:	2210      	movs	r2, #16
 801483e:	0018      	movs	r0, r3
 8014840:	f000 f808 	bl	8014854 <ip4addr_ntoa_r>
 8014844:	0003      	movs	r3, r0
}
 8014846:	0018      	movs	r0, r3
 8014848:	46bd      	mov	sp, r7
 801484a:	b002      	add	sp, #8
 801484c:	bd80      	pop	{r7, pc}
 801484e:	46c0      	nop			; (mov r8, r8)
 8014850:	20000c90 	.word	0x20000c90

08014854 <ip4addr_ntoa_r>:
 * @return either pointer to buf which now holds the ASCII
 *         representation of addr or NULL if buf was too small
 */
char *
ip4addr_ntoa_r(const ip4_addr_t *addr, char *buf, int buflen)
{
 8014854:	b5b0      	push	{r4, r5, r7, lr}
 8014856:	b08c      	sub	sp, #48	; 0x30
 8014858:	af00      	add	r7, sp, #0
 801485a:	60f8      	str	r0, [r7, #12]
 801485c:	60b9      	str	r1, [r7, #8]
 801485e:	607a      	str	r2, [r7, #4]
  char *rp;
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;
  int len = 0;
 8014860:	2300      	movs	r3, #0
 8014862:	623b      	str	r3, [r7, #32]

  s_addr = ip4_addr_get_u32(addr);
 8014864:	68fb      	ldr	r3, [r7, #12]
 8014866:	681b      	ldr	r3, [r3, #0]
 8014868:	61bb      	str	r3, [r7, #24]

  rp = buf;
 801486a:	68bb      	ldr	r3, [r7, #8]
 801486c:	62fb      	str	r3, [r7, #44]	; 0x2c
  ap = (u8_t *)&s_addr;
 801486e:	2318      	movs	r3, #24
 8014870:	18fb      	adds	r3, r7, r3
 8014872:	62bb      	str	r3, [r7, #40]	; 0x28
  for (n = 0; n < 4; n++) {
 8014874:	2327      	movs	r3, #39	; 0x27
 8014876:	18fb      	adds	r3, r7, r3
 8014878:	2200      	movs	r2, #0
 801487a:	701a      	strb	r2, [r3, #0]
 801487c:	e05a      	b.n	8014934 <ip4addr_ntoa_r+0xe0>
    i = 0;
 801487e:	2326      	movs	r3, #38	; 0x26
 8014880:	18fb      	adds	r3, r7, r3
 8014882:	2200      	movs	r2, #0
 8014884:	701a      	strb	r2, [r3, #0]
    do {
      rem = *ap % (u8_t)10;
 8014886:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014888:	781b      	ldrb	r3, [r3, #0]
 801488a:	251f      	movs	r5, #31
 801488c:	197c      	adds	r4, r7, r5
 801488e:	210a      	movs	r1, #10
 8014890:	0018      	movs	r0, r3
 8014892:	f7eb fcdb 	bl	800024c <__aeabi_uidivmod>
 8014896:	000b      	movs	r3, r1
 8014898:	7023      	strb	r3, [r4, #0]
      *ap /= (u8_t)10;
 801489a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801489c:	781b      	ldrb	r3, [r3, #0]
 801489e:	210a      	movs	r1, #10
 80148a0:	0018      	movs	r0, r3
 80148a2:	f7eb fc4d 	bl	8000140 <__udivsi3>
 80148a6:	0003      	movs	r3, r0
 80148a8:	b2da      	uxtb	r2, r3
 80148aa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80148ac:	701a      	strb	r2, [r3, #0]
      inv[i++] = (char)('0' + rem);
 80148ae:	2226      	movs	r2, #38	; 0x26
 80148b0:	18bb      	adds	r3, r7, r2
 80148b2:	781b      	ldrb	r3, [r3, #0]
 80148b4:	18ba      	adds	r2, r7, r2
 80148b6:	1c59      	adds	r1, r3, #1
 80148b8:	7011      	strb	r1, [r2, #0]
 80148ba:	001a      	movs	r2, r3
 80148bc:	197b      	adds	r3, r7, r5
 80148be:	781b      	ldrb	r3, [r3, #0]
 80148c0:	3330      	adds	r3, #48	; 0x30
 80148c2:	b2d9      	uxtb	r1, r3
 80148c4:	2314      	movs	r3, #20
 80148c6:	18fb      	adds	r3, r7, r3
 80148c8:	5499      	strb	r1, [r3, r2]
    } while (*ap);
 80148ca:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80148cc:	781b      	ldrb	r3, [r3, #0]
 80148ce:	2b00      	cmp	r3, #0
 80148d0:	d1d9      	bne.n	8014886 <ip4addr_ntoa_r+0x32>
    while (i--) {
 80148d2:	e011      	b.n	80148f8 <ip4addr_ntoa_r+0xa4>
      if (len++ >= buflen) {
 80148d4:	6a3b      	ldr	r3, [r7, #32]
 80148d6:	1c5a      	adds	r2, r3, #1
 80148d8:	623a      	str	r2, [r7, #32]
 80148da:	687a      	ldr	r2, [r7, #4]
 80148dc:	429a      	cmp	r2, r3
 80148de:	dc01      	bgt.n	80148e4 <ip4addr_ntoa_r+0x90>
        return NULL;
 80148e0:	2300      	movs	r3, #0
 80148e2:	e033      	b.n	801494c <ip4addr_ntoa_r+0xf8>
      }
      *rp++ = inv[i];
 80148e4:	2326      	movs	r3, #38	; 0x26
 80148e6:	18fb      	adds	r3, r7, r3
 80148e8:	781a      	ldrb	r2, [r3, #0]
 80148ea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80148ec:	1c59      	adds	r1, r3, #1
 80148ee:	62f9      	str	r1, [r7, #44]	; 0x2c
 80148f0:	2114      	movs	r1, #20
 80148f2:	1879      	adds	r1, r7, r1
 80148f4:	5c8a      	ldrb	r2, [r1, r2]
 80148f6:	701a      	strb	r2, [r3, #0]
    while (i--) {
 80148f8:	2226      	movs	r2, #38	; 0x26
 80148fa:	18bb      	adds	r3, r7, r2
 80148fc:	781b      	ldrb	r3, [r3, #0]
 80148fe:	18ba      	adds	r2, r7, r2
 8014900:	1e59      	subs	r1, r3, #1
 8014902:	7011      	strb	r1, [r2, #0]
 8014904:	2b00      	cmp	r3, #0
 8014906:	d1e5      	bne.n	80148d4 <ip4addr_ntoa_r+0x80>
    }
    if (len++ >= buflen) {
 8014908:	6a3b      	ldr	r3, [r7, #32]
 801490a:	1c5a      	adds	r2, r3, #1
 801490c:	623a      	str	r2, [r7, #32]
 801490e:	687a      	ldr	r2, [r7, #4]
 8014910:	429a      	cmp	r2, r3
 8014912:	dc01      	bgt.n	8014918 <ip4addr_ntoa_r+0xc4>
      return NULL;
 8014914:	2300      	movs	r3, #0
 8014916:	e019      	b.n	801494c <ip4addr_ntoa_r+0xf8>
    }
    *rp++ = '.';
 8014918:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801491a:	1c5a      	adds	r2, r3, #1
 801491c:	62fa      	str	r2, [r7, #44]	; 0x2c
 801491e:	222e      	movs	r2, #46	; 0x2e
 8014920:	701a      	strb	r2, [r3, #0]
    ap++;
 8014922:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014924:	3301      	adds	r3, #1
 8014926:	62bb      	str	r3, [r7, #40]	; 0x28
  for (n = 0; n < 4; n++) {
 8014928:	2127      	movs	r1, #39	; 0x27
 801492a:	187b      	adds	r3, r7, r1
 801492c:	781a      	ldrb	r2, [r3, #0]
 801492e:	187b      	adds	r3, r7, r1
 8014930:	3201      	adds	r2, #1
 8014932:	701a      	strb	r2, [r3, #0]
 8014934:	2327      	movs	r3, #39	; 0x27
 8014936:	18fb      	adds	r3, r7, r3
 8014938:	781b      	ldrb	r3, [r3, #0]
 801493a:	2b03      	cmp	r3, #3
 801493c:	d99f      	bls.n	801487e <ip4addr_ntoa_r+0x2a>
  }
  *--rp = 0;
 801493e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014940:	3b01      	subs	r3, #1
 8014942:	62fb      	str	r3, [r7, #44]	; 0x2c
 8014944:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014946:	2200      	movs	r2, #0
 8014948:	701a      	strb	r2, [r3, #0]
  return buf;
 801494a:	68bb      	ldr	r3, [r7, #8]
}
 801494c:	0018      	movs	r0, r3
 801494e:	46bd      	mov	sp, r7
 8014950:	b00c      	add	sp, #48	; 0x30
 8014952:	bdb0      	pop	{r4, r5, r7, pc}

08014954 <link_required>:
#endif

/*
 * An Open on LCP has requested a change from Dead to Establish phase.
 */
void link_required(ppp_pcb *pcb) {
 8014954:	b580      	push	{r7, lr}
 8014956:	b082      	sub	sp, #8
 8014958:	af00      	add	r7, sp, #0
 801495a:	6078      	str	r0, [r7, #4]
    LWIP_UNUSED_ARG(pcb);
}
 801495c:	46c0      	nop			; (mov r8, r8)
 801495e:	46bd      	mov	sp, r7
 8014960:	b002      	add	sp, #8
 8014962:	bd80      	pop	{r7, pc}

08014964 <link_terminated>:

/*
 * LCP has terminated the link; go to the Dead phase and take the
 * physical layer down.
 */
void link_terminated(ppp_pcb *pcb) {
 8014964:	b580      	push	{r7, lr}
 8014966:	b082      	sub	sp, #8
 8014968:	af00      	add	r7, sp, #0
 801496a:	6078      	str	r0, [r7, #4]
    if (pcb->phase == PPP_PHASE_DEAD
 801496c:	687b      	ldr	r3, [r7, #4]
 801496e:	2224      	movs	r2, #36	; 0x24
 8014970:	5c9b      	ldrb	r3, [r3, r2]
 8014972:	2b00      	cmp	r3, #0
 8014974:	d011      	beq.n	801499a <link_terminated+0x36>
#ifdef HAVE_MULTILINK
    || pcb->phase == PPP_PHASE_MASTER
#endif /* HAVE_MULTILINK */
    )
	return;
    new_phase(pcb, PPP_PHASE_DISCONNECT);
 8014976:	687b      	ldr	r3, [r7, #4]
 8014978:	210c      	movs	r1, #12
 801497a:	0018      	movs	r0, r3
 801497c:	f006 f837 	bl	801a9ee <new_phase>
    }
    session_end(devnam);
#endif /* UNUSED */

    if (!doing_multilink) {
	ppp_notice("Connection terminated.");
 8014980:	4b08      	ldr	r3, [pc, #32]	; (80149a4 <link_terminated+0x40>)
 8014982:	0018      	movs	r0, r3
 8014984:	f007 fb05 	bl	801bf92 <ppp_notice>
	print_link_stats();
#endif /* PPP_STATS_SUPPORT */
    } else
	ppp_notice("Link terminated.");

    lcp_lowerdown(pcb);
 8014988:	687b      	ldr	r3, [r7, #4]
 801498a:	0018      	movs	r0, r3
 801498c:	f003 fcfc 	bl	8018388 <lcp_lowerdown>

    ppp_link_terminated(pcb);
 8014990:	687b      	ldr	r3, [r7, #4]
 8014992:	0018      	movs	r0, r3
 8014994:	f006 f81b 	bl	801a9ce <ppp_link_terminated>
 8014998:	e000      	b.n	801499c <link_terminated+0x38>
	return;
 801499a:	46c0      	nop			; (mov r8, r8)
	else
	    mp_bundle_terminated();
    } else
	new_phase(pcb, PPP_PHASE_DEAD);
#endif
}
 801499c:	46bd      	mov	sp, r7
 801499e:	b002      	add	sp, #8
 80149a0:	bd80      	pop	{r7, pc}
 80149a2:	46c0      	nop			; (mov r8, r8)
 80149a4:	08022610 	.word	0x08022610

080149a8 <link_down>:

/*
 * LCP has gone down; it will either die or try to re-establish.
 */
void link_down(ppp_pcb *pcb) {
 80149a8:	b580      	push	{r7, lr}
 80149aa:	b082      	sub	sp, #8
 80149ac:	af00      	add	r7, sp, #0
 80149ae:	6078      	str	r0, [r7, #4]
#if PPP_NOTIFY
    notify(link_down_notifier, 0);
#endif /* PPP_NOTIFY */

    if (!doing_multilink) {
	upper_layers_down(pcb);
 80149b0:	687b      	ldr	r3, [r7, #4]
 80149b2:	0018      	movs	r0, r3
 80149b4:	f000 f80e 	bl	80149d4 <upper_layers_down>
	if (pcb->phase != PPP_PHASE_DEAD
 80149b8:	687b      	ldr	r3, [r7, #4]
 80149ba:	2224      	movs	r2, #36	; 0x24
 80149bc:	5c9b      	ldrb	r3, [r3, r2]
 80149be:	2b00      	cmp	r3, #0
 80149c0:	d004      	beq.n	80149cc <link_down+0x24>
#ifdef HAVE_MULTILINK
	&& pcb->phase != PPP_PHASE_MASTER
#endif /* HAVE_MULTILINK */
	)
	    new_phase(pcb, PPP_PHASE_ESTABLISH);
 80149c2:	687b      	ldr	r3, [r7, #4]
 80149c4:	2106      	movs	r1, #6
 80149c6:	0018      	movs	r0, r3
 80149c8:	f006 f811 	bl	801a9ee <new_phase>
    }
    /* XXX if doing_multilink, should do something to stop
       network-layer traffic on the link */
}
 80149cc:	46c0      	nop			; (mov r8, r8)
 80149ce:	46bd      	mov	sp, r7
 80149d0:	b002      	add	sp, #8
 80149d2:	bd80      	pop	{r7, pc}

080149d4 <upper_layers_down>:

void upper_layers_down(ppp_pcb *pcb) {
 80149d4:	b580      	push	{r7, lr}
 80149d6:	b084      	sub	sp, #16
 80149d8:	af00      	add	r7, sp, #0
 80149da:	6078      	str	r0, [r7, #4]
    int i;
    const struct protent *protp;

    for (i = 0; (protp = protocols[i]) != NULL; ++i) {
 80149dc:	2300      	movs	r3, #0
 80149de:	60fb      	str	r3, [r7, #12]
 80149e0:	e01f      	b.n	8014a22 <upper_layers_down+0x4e>
        if (protp->protocol != PPP_LCP && protp->lowerdown != NULL)
 80149e2:	68bb      	ldr	r3, [r7, #8]
 80149e4:	881b      	ldrh	r3, [r3, #0]
 80149e6:	4a19      	ldr	r2, [pc, #100]	; (8014a4c <upper_layers_down+0x78>)
 80149e8:	4293      	cmp	r3, r2
 80149ea:	d008      	beq.n	80149fe <upper_layers_down+0x2a>
 80149ec:	68bb      	ldr	r3, [r7, #8]
 80149ee:	695b      	ldr	r3, [r3, #20]
 80149f0:	2b00      	cmp	r3, #0
 80149f2:	d004      	beq.n	80149fe <upper_layers_down+0x2a>
	    (*protp->lowerdown)(pcb);
 80149f4:	68bb      	ldr	r3, [r7, #8]
 80149f6:	695b      	ldr	r3, [r3, #20]
 80149f8:	687a      	ldr	r2, [r7, #4]
 80149fa:	0010      	movs	r0, r2
 80149fc:	4798      	blx	r3
        if (protp->protocol < 0xC000 && protp->close != NULL)
 80149fe:	68bb      	ldr	r3, [r7, #8]
 8014a00:	881b      	ldrh	r3, [r3, #0]
 8014a02:	4a13      	ldr	r2, [pc, #76]	; (8014a50 <upper_layers_down+0x7c>)
 8014a04:	4293      	cmp	r3, r2
 8014a06:	d809      	bhi.n	8014a1c <upper_layers_down+0x48>
 8014a08:	68bb      	ldr	r3, [r7, #8]
 8014a0a:	69db      	ldr	r3, [r3, #28]
 8014a0c:	2b00      	cmp	r3, #0
 8014a0e:	d005      	beq.n	8014a1c <upper_layers_down+0x48>
	    (*protp->close)(pcb, "LCP down");
 8014a10:	68bb      	ldr	r3, [r7, #8]
 8014a12:	69db      	ldr	r3, [r3, #28]
 8014a14:	490f      	ldr	r1, [pc, #60]	; (8014a54 <upper_layers_down+0x80>)
 8014a16:	687a      	ldr	r2, [r7, #4]
 8014a18:	0010      	movs	r0, r2
 8014a1a:	4798      	blx	r3
    for (i = 0; (protp = protocols[i]) != NULL; ++i) {
 8014a1c:	68fb      	ldr	r3, [r7, #12]
 8014a1e:	3301      	adds	r3, #1
 8014a20:	60fb      	str	r3, [r7, #12]
 8014a22:	4b0d      	ldr	r3, [pc, #52]	; (8014a58 <upper_layers_down+0x84>)
 8014a24:	68fa      	ldr	r2, [r7, #12]
 8014a26:	0092      	lsls	r2, r2, #2
 8014a28:	58d3      	ldr	r3, [r2, r3]
 8014a2a:	60bb      	str	r3, [r7, #8]
 8014a2c:	68bb      	ldr	r3, [r7, #8]
 8014a2e:	2b00      	cmp	r3, #0
 8014a30:	d1d7      	bne.n	80149e2 <upper_layers_down+0xe>
    }
    pcb->num_np_open = 0;
 8014a32:	687b      	ldr	r3, [r7, #4]
 8014a34:	22d8      	movs	r2, #216	; 0xd8
 8014a36:	2100      	movs	r1, #0
 8014a38:	5499      	strb	r1, [r3, r2]
    pcb->num_np_up = 0;
 8014a3a:	687b      	ldr	r3, [r7, #4]
 8014a3c:	22d9      	movs	r2, #217	; 0xd9
 8014a3e:	2100      	movs	r1, #0
 8014a40:	5499      	strb	r1, [r3, r2]
}
 8014a42:	46c0      	nop			; (mov r8, r8)
 8014a44:	46bd      	mov	sp, r7
 8014a46:	b004      	add	sp, #16
 8014a48:	bd80      	pop	{r7, pc}
 8014a4a:	46c0      	nop			; (mov r8, r8)
 8014a4c:	0000c021 	.word	0x0000c021
 8014a50:	0000bfff 	.word	0x0000bfff
 8014a54:	08022628 	.word	0x08022628
 8014a58:	08023cf8 	.word	0x08023cf8

08014a5c <link_established>:

/*
 * The link is established.
 * Proceed to the Dead, Authenticate or Network phase as appropriate.
 */
void link_established(ppp_pcb *pcb) {
 8014a5c:	b580      	push	{r7, lr}
 8014a5e:	b084      	sub	sp, #16
 8014a60:	af00      	add	r7, sp, #0
 8014a62:	6078      	str	r0, [r7, #4]

    /*
     * Tell higher-level protocols that LCP is up.
     */
    if (!doing_multilink) {
	for (i = 0; (protp = protocols[i]) != NULL; ++i)
 8014a64:	2300      	movs	r3, #0
 8014a66:	60fb      	str	r3, [r7, #12]
 8014a68:	e010      	b.n	8014a8c <link_established+0x30>
	    if (protp->protocol != PPP_LCP
 8014a6a:	68bb      	ldr	r3, [r7, #8]
 8014a6c:	881b      	ldrh	r3, [r3, #0]
 8014a6e:	4a0f      	ldr	r2, [pc, #60]	; (8014aac <link_established+0x50>)
 8014a70:	4293      	cmp	r3, r2
 8014a72:	d008      	beq.n	8014a86 <link_established+0x2a>
		&& protp->lowerup != NULL)
 8014a74:	68bb      	ldr	r3, [r7, #8]
 8014a76:	691b      	ldr	r3, [r3, #16]
 8014a78:	2b00      	cmp	r3, #0
 8014a7a:	d004      	beq.n	8014a86 <link_established+0x2a>
		(*protp->lowerup)(pcb);
 8014a7c:	68bb      	ldr	r3, [r7, #8]
 8014a7e:	691b      	ldr	r3, [r3, #16]
 8014a80:	687a      	ldr	r2, [r7, #4]
 8014a82:	0010      	movs	r0, r2
 8014a84:	4798      	blx	r3
	for (i = 0; (protp = protocols[i]) != NULL; ++i)
 8014a86:	68fb      	ldr	r3, [r7, #12]
 8014a88:	3301      	adds	r3, #1
 8014a8a:	60fb      	str	r3, [r7, #12]
 8014a8c:	4b08      	ldr	r3, [pc, #32]	; (8014ab0 <link_established+0x54>)
 8014a8e:	68fa      	ldr	r2, [r7, #12]
 8014a90:	0092      	lsls	r2, r2, #2
 8014a92:	58d3      	ldr	r3, [r2, r3]
 8014a94:	60bb      	str	r3, [r7, #8]
 8014a96:	68bb      	ldr	r3, [r7, #8]
 8014a98:	2b00      	cmp	r3, #0
 8014a9a:	d1e6      	bne.n	8014a6a <link_established+0xe>
    pcb->auth_pending = auth;
    pcb->auth_done = 0;

    if (!auth)
#endif /* PPP_AUTH_SUPPORT */
	network_phase(pcb);
 8014a9c:	687b      	ldr	r3, [r7, #4]
 8014a9e:	0018      	movs	r0, r3
 8014aa0:	f000 f808 	bl	8014ab4 <network_phase>
}
 8014aa4:	46c0      	nop			; (mov r8, r8)
 8014aa6:	46bd      	mov	sp, r7
 8014aa8:	b004      	add	sp, #16
 8014aaa:	bd80      	pop	{r7, pc}
 8014aac:	0000c021 	.word	0x0000c021
 8014ab0:	08023cf8 	.word	0x08023cf8

08014ab4 <network_phase>:

/*
 * Proceed to the network phase.
 */
static void network_phase(ppp_pcb *pcb) {
 8014ab4:	b580      	push	{r7, lr}
 8014ab6:	b082      	sub	sp, #8
 8014ab8:	af00      	add	r7, sp, #0
 8014aba:	6078      	str	r0, [r7, #4]
	options_from_list(extra_options, 1);
	free_wordlist(extra_options);
	extra_options = 0;
    }
#endif /* PPP_OPTIONS */
    start_networks(pcb);
 8014abc:	687b      	ldr	r3, [r7, #4]
 8014abe:	0018      	movs	r0, r3
 8014ac0:	f000 f804 	bl	8014acc <start_networks>
}
 8014ac4:	46c0      	nop			; (mov r8, r8)
 8014ac6:	46bd      	mov	sp, r7
 8014ac8:	b002      	add	sp, #8
 8014aca:	bd80      	pop	{r7, pc}

08014acc <start_networks>:

void start_networks(ppp_pcb *pcb) {
 8014acc:	b580      	push	{r7, lr}
 8014ace:	b082      	sub	sp, #8
 8014ad0:	af00      	add	r7, sp, #0
 8014ad2:	6078      	str	r0, [r7, #4]
#if CCP_SUPPORT || ECP_SUPPORT
    int i;
    const struct protent *protp;
#endif /* CCP_SUPPORT || ECP_SUPPORT */

    new_phase(pcb, PPP_PHASE_NETWORK);
 8014ad4:	687b      	ldr	r3, [r7, #4]
 8014ad6:	2109      	movs	r1, #9
 8014ad8:	0018      	movs	r0, r3
 8014ada:	f005 ff88 	bl	801a9ee <new_phase>
#endif /* ECP_SUPPORT */
#if MPPE_SUPPORT
        && !pcb->ccp_gotoptions.mppe
#endif /* MPPE_SUPPORT */
        )
	continue_networks(pcb);
 8014ade:	687b      	ldr	r3, [r7, #4]
 8014ae0:	0018      	movs	r0, r3
 8014ae2:	f000 f805 	bl	8014af0 <continue_networks>
}
 8014ae6:	46c0      	nop			; (mov r8, r8)
 8014ae8:	46bd      	mov	sp, r7
 8014aea:	b002      	add	sp, #8
 8014aec:	bd80      	pop	{r7, pc}
	...

08014af0 <continue_networks>:

void continue_networks(ppp_pcb *pcb) {
 8014af0:	b580      	push	{r7, lr}
 8014af2:	b084      	sub	sp, #16
 8014af4:	af00      	add	r7, sp, #0
 8014af6:	6078      	str	r0, [r7, #4]
    const struct protent *protp;

    /*
     * Start the "real" network protocols.
     */
    for (i = 0; (protp = protocols[i]) != NULL; ++i)
 8014af8:	2300      	movs	r3, #0
 8014afa:	60fb      	str	r3, [r7, #12]
 8014afc:	e018      	b.n	8014b30 <continue_networks+0x40>
	if (protp->protocol < 0xC000
 8014afe:	68bb      	ldr	r3, [r7, #8]
 8014b00:	881b      	ldrh	r3, [r3, #0]
 8014b02:	4a17      	ldr	r2, [pc, #92]	; (8014b60 <continue_networks+0x70>)
 8014b04:	4293      	cmp	r3, r2
 8014b06:	d810      	bhi.n	8014b2a <continue_networks+0x3a>
	    && protp->protocol != PPP_CCP
#endif /* CCP_SUPPORT */
#if ECP_SUPPORT
	    && protp->protocol != PPP_ECP
#endif /* ECP_SUPPORT */
	    && protp->open != NULL) {
 8014b08:	68bb      	ldr	r3, [r7, #8]
 8014b0a:	699b      	ldr	r3, [r3, #24]
 8014b0c:	2b00      	cmp	r3, #0
 8014b0e:	d00c      	beq.n	8014b2a <continue_networks+0x3a>
	    (*protp->open)(pcb);
 8014b10:	68bb      	ldr	r3, [r7, #8]
 8014b12:	699b      	ldr	r3, [r3, #24]
 8014b14:	687a      	ldr	r2, [r7, #4]
 8014b16:	0010      	movs	r0, r2
 8014b18:	4798      	blx	r3
	    ++pcb->num_np_open;
 8014b1a:	687b      	ldr	r3, [r7, #4]
 8014b1c:	22d8      	movs	r2, #216	; 0xd8
 8014b1e:	5c9b      	ldrb	r3, [r3, r2]
 8014b20:	3301      	adds	r3, #1
 8014b22:	b2d9      	uxtb	r1, r3
 8014b24:	687b      	ldr	r3, [r7, #4]
 8014b26:	22d8      	movs	r2, #216	; 0xd8
 8014b28:	5499      	strb	r1, [r3, r2]
    for (i = 0; (protp = protocols[i]) != NULL; ++i)
 8014b2a:	68fb      	ldr	r3, [r7, #12]
 8014b2c:	3301      	adds	r3, #1
 8014b2e:	60fb      	str	r3, [r7, #12]
 8014b30:	4b0c      	ldr	r3, [pc, #48]	; (8014b64 <continue_networks+0x74>)
 8014b32:	68fa      	ldr	r2, [r7, #12]
 8014b34:	0092      	lsls	r2, r2, #2
 8014b36:	58d3      	ldr	r3, [r2, r3]
 8014b38:	60bb      	str	r3, [r7, #8]
 8014b3a:	68bb      	ldr	r3, [r7, #8]
 8014b3c:	2b00      	cmp	r3, #0
 8014b3e:	d1de      	bne.n	8014afe <continue_networks+0xe>
	}

    if (pcb->num_np_open == 0)
 8014b40:	687b      	ldr	r3, [r7, #4]
 8014b42:	22d8      	movs	r2, #216	; 0xd8
 8014b44:	5c9b      	ldrb	r3, [r3, r2]
 8014b46:	2b00      	cmp	r3, #0
 8014b48:	d105      	bne.n	8014b56 <continue_networks+0x66>
	/* nothing to do */
	lcp_close(pcb, "No network protocols running");
 8014b4a:	4a07      	ldr	r2, [pc, #28]	; (8014b68 <continue_networks+0x78>)
 8014b4c:	687b      	ldr	r3, [r7, #4]
 8014b4e:	0011      	movs	r1, r2
 8014b50:	0018      	movs	r0, r3
 8014b52:	f003 fb75 	bl	8018240 <lcp_close>
}
 8014b56:	46c0      	nop			; (mov r8, r8)
 8014b58:	46bd      	mov	sp, r7
 8014b5a:	b004      	add	sp, #16
 8014b5c:	bd80      	pop	{r7, pc}
 8014b5e:	46c0      	nop			; (mov r8, r8)
 8014b60:	0000bfff 	.word	0x0000bfff
 8014b64:	08023cf8 	.word	0x08023cf8
 8014b68:	08022634 	.word	0x08022634

08014b6c <np_up>:


/*
 * np_up - a network protocol has come up.
 */
void np_up(ppp_pcb *pcb, int proto) {
 8014b6c:	b580      	push	{r7, lr}
 8014b6e:	b082      	sub	sp, #8
 8014b70:	af00      	add	r7, sp, #0
 8014b72:	6078      	str	r0, [r7, #4]
 8014b74:	6039      	str	r1, [r7, #0]
#if PPP_IDLETIMELIMIT
    int tlim;
#endif /* PPP_IDLETIMELIMIT */
    LWIP_UNUSED_ARG(proto);

    if (pcb->num_np_up == 0) {
 8014b76:	687b      	ldr	r3, [r7, #4]
 8014b78:	22d9      	movs	r2, #217	; 0xd9
 8014b7a:	5c9b      	ldrb	r3, [r3, r2]
 8014b7c:	2b00      	cmp	r3, #0
 8014b7e:	d104      	bne.n	8014b8a <np_up+0x1e>
	/*
	 * At this point we consider that the link has come up successfully.
	 */
	new_phase(pcb, PPP_PHASE_RUNNING);
 8014b80:	687b      	ldr	r3, [r7, #4]
 8014b82:	210a      	movs	r1, #10
 8014b84:	0018      	movs	r0, r3
 8014b86:	f005 ff32 	bl	801a9ee <new_phase>
	 */
	if (updetach && !nodetach)
	    detach();
#endif /* Unused */
    }
    ++pcb->num_np_up;
 8014b8a:	687b      	ldr	r3, [r7, #4]
 8014b8c:	22d9      	movs	r2, #217	; 0xd9
 8014b8e:	5c9b      	ldrb	r3, [r3, r2]
 8014b90:	3301      	adds	r3, #1
 8014b92:	b2d9      	uxtb	r1, r3
 8014b94:	687b      	ldr	r3, [r7, #4]
 8014b96:	22d9      	movs	r2, #217	; 0xd9
 8014b98:	5499      	strb	r1, [r3, r2]
}
 8014b9a:	46c0      	nop			; (mov r8, r8)
 8014b9c:	46bd      	mov	sp, r7
 8014b9e:	b002      	add	sp, #8
 8014ba0:	bd80      	pop	{r7, pc}

08014ba2 <np_down>:

/*
 * np_down - a network protocol has gone down.
 */
void np_down(ppp_pcb *pcb, int proto) {
 8014ba2:	b580      	push	{r7, lr}
 8014ba4:	b082      	sub	sp, #8
 8014ba6:	af00      	add	r7, sp, #0
 8014ba8:	6078      	str	r0, [r7, #4]
 8014baa:	6039      	str	r1, [r7, #0]
    LWIP_UNUSED_ARG(proto);
    if (--pcb->num_np_up == 0) {
 8014bac:	687b      	ldr	r3, [r7, #4]
 8014bae:	22d9      	movs	r2, #217	; 0xd9
 8014bb0:	5c9b      	ldrb	r3, [r3, r2]
 8014bb2:	3b01      	subs	r3, #1
 8014bb4:	b2d9      	uxtb	r1, r3
 8014bb6:	687b      	ldr	r3, [r7, #4]
 8014bb8:	22d9      	movs	r2, #217	; 0xd9
 8014bba:	5499      	strb	r1, [r3, r2]
 8014bbc:	687b      	ldr	r3, [r7, #4]
 8014bbe:	22d9      	movs	r2, #217	; 0xd9
 8014bc0:	5c9b      	ldrb	r3, [r3, r2]
 8014bc2:	2b00      	cmp	r3, #0
 8014bc4:	d104      	bne.n	8014bd0 <np_down+0x2e>
	UNTIMEOUT(connect_time_expired, NULL);
#endif /* PPP_MAXCONNECT */
#ifdef MAXOCTETS
	UNTIMEOUT(check_maxoctets, NULL);
#endif
	new_phase(pcb, PPP_PHASE_NETWORK);
 8014bc6:	687b      	ldr	r3, [r7, #4]
 8014bc8:	2109      	movs	r1, #9
 8014bca:	0018      	movs	r0, r3
 8014bcc:	f005 ff0f 	bl	801a9ee <new_phase>
    }
}
 8014bd0:	46c0      	nop			; (mov r8, r8)
 8014bd2:	46bd      	mov	sp, r7
 8014bd4:	b002      	add	sp, #8
 8014bd6:	bd80      	pop	{r7, pc}

08014bd8 <np_finished>:

/*
 * np_finished - a network protocol has finished using the link.
 */
void np_finished(ppp_pcb *pcb, int proto) {
 8014bd8:	b580      	push	{r7, lr}
 8014bda:	b082      	sub	sp, #8
 8014bdc:	af00      	add	r7, sp, #0
 8014bde:	6078      	str	r0, [r7, #4]
 8014be0:	6039      	str	r1, [r7, #0]
    LWIP_UNUSED_ARG(proto);
    if (--pcb->num_np_open <= 0) {
 8014be2:	687b      	ldr	r3, [r7, #4]
 8014be4:	22d8      	movs	r2, #216	; 0xd8
 8014be6:	5c9b      	ldrb	r3, [r3, r2]
 8014be8:	3b01      	subs	r3, #1
 8014bea:	b2d9      	uxtb	r1, r3
 8014bec:	687b      	ldr	r3, [r7, #4]
 8014bee:	22d8      	movs	r2, #216	; 0xd8
 8014bf0:	5499      	strb	r1, [r3, r2]
 8014bf2:	687b      	ldr	r3, [r7, #4]
 8014bf4:	22d8      	movs	r2, #216	; 0xd8
 8014bf6:	5c9b      	ldrb	r3, [r3, r2]
 8014bf8:	2b00      	cmp	r3, #0
 8014bfa:	d105      	bne.n	8014c08 <np_finished+0x30>
	/* no further use for the link: shut up shop. */
	lcp_close(pcb, "No network protocols running");
 8014bfc:	4a04      	ldr	r2, [pc, #16]	; (8014c10 <np_finished+0x38>)
 8014bfe:	687b      	ldr	r3, [r7, #4]
 8014c00:	0011      	movs	r1, r2
 8014c02:	0018      	movs	r0, r3
 8014c04:	f003 fb1c 	bl	8018240 <lcp_close>
    }
}
 8014c08:	46c0      	nop			; (mov r8, r8)
 8014c0a:	46bd      	mov	sp, r7
 8014c0c:	b002      	add	sp, #8
 8014c0e:	bd80      	pop	{r7, pc}
 8014c10:	08022634 	.word	0x08022634

08014c14 <fsm_init>:
/*
 * fsm_init - Initialize fsm.
 *
 * Initialize fsm state.
 */
void fsm_init(fsm *f) {
 8014c14:	b580      	push	{r7, lr}
 8014c16:	b084      	sub	sp, #16
 8014c18:	af00      	add	r7, sp, #0
 8014c1a:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8014c1c:	687b      	ldr	r3, [r7, #4]
 8014c1e:	681b      	ldr	r3, [r3, #0]
 8014c20:	60fb      	str	r3, [r7, #12]
    f->state = PPP_FSM_INITIAL;
 8014c22:	687b      	ldr	r3, [r7, #4]
 8014c24:	2200      	movs	r2, #0
 8014c26:	741a      	strb	r2, [r3, #16]
    f->flags = 0;
 8014c28:	687b      	ldr	r3, [r7, #4]
 8014c2a:	2200      	movs	r2, #0
 8014c2c:	745a      	strb	r2, [r3, #17]
    f->id = 0;				/* XXX Start with random id? */
 8014c2e:	687b      	ldr	r3, [r7, #4]
 8014c30:	2200      	movs	r2, #0
 8014c32:	749a      	strb	r2, [r3, #18]
    f->maxnakloops = pcb->settings.fsm_max_nak_loops;
 8014c34:	68fb      	ldr	r3, [r7, #12]
 8014c36:	79da      	ldrb	r2, [r3, #7]
 8014c38:	687b      	ldr	r3, [r7, #4]
 8014c3a:	75da      	strb	r2, [r3, #23]
    f->term_reason_len = 0;
 8014c3c:	687b      	ldr	r3, [r7, #4]
 8014c3e:	2200      	movs	r2, #0
 8014c40:	761a      	strb	r2, [r3, #24]
}
 8014c42:	46c0      	nop			; (mov r8, r8)
 8014c44:	46bd      	mov	sp, r7
 8014c46:	b004      	add	sp, #16
 8014c48:	bd80      	pop	{r7, pc}

08014c4a <fsm_lowerup>:


/*
 * fsm_lowerup - The lower layer is up.
 */
void fsm_lowerup(fsm *f) {
 8014c4a:	b580      	push	{r7, lr}
 8014c4c:	b082      	sub	sp, #8
 8014c4e:	af00      	add	r7, sp, #0
 8014c50:	6078      	str	r0, [r7, #4]
    switch( f->state ){
 8014c52:	687b      	ldr	r3, [r7, #4]
 8014c54:	7c1b      	ldrb	r3, [r3, #16]
 8014c56:	2b00      	cmp	r3, #0
 8014c58:	d002      	beq.n	8014c60 <fsm_lowerup+0x16>
 8014c5a:	2b01      	cmp	r3, #1
 8014c5c:	d004      	beq.n	8014c68 <fsm_lowerup+0x1e>

    default:
	FSMDEBUG(("%s: Up event in state %d!", PROTO_NAME(f), f->state));
	/* no break */
    }
}
 8014c5e:	e016      	b.n	8014c8e <fsm_lowerup+0x44>
	f->state = PPP_FSM_CLOSED;
 8014c60:	687b      	ldr	r3, [r7, #4]
 8014c62:	2202      	movs	r2, #2
 8014c64:	741a      	strb	r2, [r3, #16]
	break;
 8014c66:	e012      	b.n	8014c8e <fsm_lowerup+0x44>
	if( f->flags & OPT_SILENT )
 8014c68:	687b      	ldr	r3, [r7, #4]
 8014c6a:	7c5b      	ldrb	r3, [r3, #17]
 8014c6c:	001a      	movs	r2, r3
 8014c6e:	2304      	movs	r3, #4
 8014c70:	4013      	ands	r3, r2
 8014c72:	d003      	beq.n	8014c7c <fsm_lowerup+0x32>
	    f->state = PPP_FSM_STOPPED;
 8014c74:	687b      	ldr	r3, [r7, #4]
 8014c76:	2203      	movs	r2, #3
 8014c78:	741a      	strb	r2, [r3, #16]
	break;
 8014c7a:	e007      	b.n	8014c8c <fsm_lowerup+0x42>
	    fsm_sconfreq(f, 0);
 8014c7c:	687b      	ldr	r3, [r7, #4]
 8014c7e:	2100      	movs	r1, #0
 8014c80:	0018      	movs	r0, r3
 8014c82:	f000 fded 	bl	8015860 <fsm_sconfreq>
	    f->state = PPP_FSM_REQSENT;
 8014c86:	687b      	ldr	r3, [r7, #4]
 8014c88:	2206      	movs	r2, #6
 8014c8a:	741a      	strb	r2, [r3, #16]
	break;
 8014c8c:	46c0      	nop			; (mov r8, r8)
}
 8014c8e:	46c0      	nop			; (mov r8, r8)
 8014c90:	46bd      	mov	sp, r7
 8014c92:	b002      	add	sp, #8
 8014c94:	bd80      	pop	{r7, pc}
	...

08014c98 <fsm_lowerdown>:
/*
 * fsm_lowerdown - The lower layer is down.
 *
 * Cancel all timeouts and inform upper layers.
 */
void fsm_lowerdown(fsm *f) {
 8014c98:	b580      	push	{r7, lr}
 8014c9a:	b082      	sub	sp, #8
 8014c9c:	af00      	add	r7, sp, #0
 8014c9e:	6078      	str	r0, [r7, #4]
    switch( f->state ){
 8014ca0:	687b      	ldr	r3, [r7, #4]
 8014ca2:	7c1b      	ldrb	r3, [r3, #16]
 8014ca4:	2b09      	cmp	r3, #9
 8014ca6:	d83b      	bhi.n	8014d20 <fsm_lowerdown+0x88>
 8014ca8:	009a      	lsls	r2, r3, #2
 8014caa:	4b1f      	ldr	r3, [pc, #124]	; (8014d28 <fsm_lowerdown+0x90>)
 8014cac:	18d3      	adds	r3, r2, r3
 8014cae:	681b      	ldr	r3, [r3, #0]
 8014cb0:	469f      	mov	pc, r3
    case PPP_FSM_CLOSED:
	f->state = PPP_FSM_INITIAL;
 8014cb2:	687b      	ldr	r3, [r7, #4]
 8014cb4:	2200      	movs	r2, #0
 8014cb6:	741a      	strb	r2, [r3, #16]
	break;
 8014cb8:	e032      	b.n	8014d20 <fsm_lowerdown+0x88>

    case PPP_FSM_STOPPED:
	f->state = PPP_FSM_STARTING;
 8014cba:	687b      	ldr	r3, [r7, #4]
 8014cbc:	2201      	movs	r2, #1
 8014cbe:	741a      	strb	r2, [r3, #16]
	if( f->callbacks->starting )
 8014cc0:	687b      	ldr	r3, [r7, #4]
 8014cc2:	685b      	ldr	r3, [r3, #4]
 8014cc4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8014cc6:	2b00      	cmp	r3, #0
 8014cc8:	d029      	beq.n	8014d1e <fsm_lowerdown+0x86>
	    (*f->callbacks->starting)(f);
 8014cca:	687b      	ldr	r3, [r7, #4]
 8014ccc:	685b      	ldr	r3, [r3, #4]
 8014cce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8014cd0:	687a      	ldr	r2, [r7, #4]
 8014cd2:	0010      	movs	r0, r2
 8014cd4:	4798      	blx	r3
	break;
 8014cd6:	e022      	b.n	8014d1e <fsm_lowerdown+0x86>

    case PPP_FSM_CLOSING:
	f->state = PPP_FSM_INITIAL;
 8014cd8:	687b      	ldr	r3, [r7, #4]
 8014cda:	2200      	movs	r2, #0
 8014cdc:	741a      	strb	r2, [r3, #16]
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 8014cde:	687a      	ldr	r2, [r7, #4]
 8014ce0:	4b12      	ldr	r3, [pc, #72]	; (8014d2c <fsm_lowerdown+0x94>)
 8014ce2:	0011      	movs	r1, r2
 8014ce4:	0018      	movs	r0, r3
 8014ce6:	f7fd fee5 	bl	8012ab4 <sys_untimeout>
	break;
 8014cea:	e019      	b.n	8014d20 <fsm_lowerdown+0x88>

    case PPP_FSM_STOPPING:
    case PPP_FSM_REQSENT:
    case PPP_FSM_ACKRCVD:
    case PPP_FSM_ACKSENT:
	f->state = PPP_FSM_STARTING;
 8014cec:	687b      	ldr	r3, [r7, #4]
 8014cee:	2201      	movs	r2, #1
 8014cf0:	741a      	strb	r2, [r3, #16]
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 8014cf2:	687a      	ldr	r2, [r7, #4]
 8014cf4:	4b0d      	ldr	r3, [pc, #52]	; (8014d2c <fsm_lowerdown+0x94>)
 8014cf6:	0011      	movs	r1, r2
 8014cf8:	0018      	movs	r0, r3
 8014cfa:	f7fd fedb 	bl	8012ab4 <sys_untimeout>
	break;
 8014cfe:	e00f      	b.n	8014d20 <fsm_lowerdown+0x88>

    case PPP_FSM_OPENED:
	if( f->callbacks->down )
 8014d00:	687b      	ldr	r3, [r7, #4]
 8014d02:	685b      	ldr	r3, [r3, #4]
 8014d04:	6a1b      	ldr	r3, [r3, #32]
 8014d06:	2b00      	cmp	r3, #0
 8014d08:	d005      	beq.n	8014d16 <fsm_lowerdown+0x7e>
	    (*f->callbacks->down)(f);
 8014d0a:	687b      	ldr	r3, [r7, #4]
 8014d0c:	685b      	ldr	r3, [r3, #4]
 8014d0e:	6a1b      	ldr	r3, [r3, #32]
 8014d10:	687a      	ldr	r2, [r7, #4]
 8014d12:	0010      	movs	r0, r2
 8014d14:	4798      	blx	r3
	f->state = PPP_FSM_STARTING;
 8014d16:	687b      	ldr	r3, [r7, #4]
 8014d18:	2201      	movs	r2, #1
 8014d1a:	741a      	strb	r2, [r3, #16]
	break;
 8014d1c:	e000      	b.n	8014d20 <fsm_lowerdown+0x88>
	break;
 8014d1e:	46c0      	nop			; (mov r8, r8)

    default:
	FSMDEBUG(("%s: Down event in state %d!", PROTO_NAME(f), f->state));
	/* no break */
    }
}
 8014d20:	46c0      	nop			; (mov r8, r8)
 8014d22:	46bd      	mov	sp, r7
 8014d24:	b002      	add	sp, #8
 8014d26:	bd80      	pop	{r7, pc}
 8014d28:	08023aa8 	.word	0x08023aa8
 8014d2c:	08014f3d 	.word	0x08014f3d

08014d30 <fsm_open>:


/*
 * fsm_open - Link is allowed to come up.
 */
void fsm_open(fsm *f) {
 8014d30:	b580      	push	{r7, lr}
 8014d32:	b082      	sub	sp, #8
 8014d34:	af00      	add	r7, sp, #0
 8014d36:	6078      	str	r0, [r7, #4]
    switch( f->state ){
 8014d38:	687b      	ldr	r3, [r7, #4]
 8014d3a:	7c1b      	ldrb	r3, [r3, #16]
 8014d3c:	2b09      	cmp	r3, #9
 8014d3e:	d838      	bhi.n	8014db2 <fsm_open+0x82>
 8014d40:	009a      	lsls	r2, r3, #2
 8014d42:	4b20      	ldr	r3, [pc, #128]	; (8014dc4 <fsm_open+0x94>)
 8014d44:	18d3      	adds	r3, r2, r3
 8014d46:	681b      	ldr	r3, [r3, #0]
 8014d48:	469f      	mov	pc, r3
    case PPP_FSM_INITIAL:
	f->state = PPP_FSM_STARTING;
 8014d4a:	687b      	ldr	r3, [r7, #4]
 8014d4c:	2201      	movs	r2, #1
 8014d4e:	741a      	strb	r2, [r3, #16]
	if( f->callbacks->starting )
 8014d50:	687b      	ldr	r3, [r7, #4]
 8014d52:	685b      	ldr	r3, [r3, #4]
 8014d54:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8014d56:	2b00      	cmp	r3, #0
 8014d58:	d02d      	beq.n	8014db6 <fsm_open+0x86>
	    (*f->callbacks->starting)(f);
 8014d5a:	687b      	ldr	r3, [r7, #4]
 8014d5c:	685b      	ldr	r3, [r3, #4]
 8014d5e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8014d60:	687a      	ldr	r2, [r7, #4]
 8014d62:	0010      	movs	r0, r2
 8014d64:	4798      	blx	r3
	break;
 8014d66:	e026      	b.n	8014db6 <fsm_open+0x86>

    case PPP_FSM_CLOSED:
	if( f->flags & OPT_SILENT )
 8014d68:	687b      	ldr	r3, [r7, #4]
 8014d6a:	7c5b      	ldrb	r3, [r3, #17]
 8014d6c:	001a      	movs	r2, r3
 8014d6e:	2304      	movs	r3, #4
 8014d70:	4013      	ands	r3, r2
 8014d72:	d003      	beq.n	8014d7c <fsm_open+0x4c>
	    f->state = PPP_FSM_STOPPED;
 8014d74:	687b      	ldr	r3, [r7, #4]
 8014d76:	2203      	movs	r2, #3
 8014d78:	741a      	strb	r2, [r3, #16]
	else {
	    /* Send an initial configure-request */
	    fsm_sconfreq(f, 0);
	    f->state = PPP_FSM_REQSENT;
	}
	break;
 8014d7a:	e01f      	b.n	8014dbc <fsm_open+0x8c>
	    fsm_sconfreq(f, 0);
 8014d7c:	687b      	ldr	r3, [r7, #4]
 8014d7e:	2100      	movs	r1, #0
 8014d80:	0018      	movs	r0, r3
 8014d82:	f000 fd6d 	bl	8015860 <fsm_sconfreq>
	    f->state = PPP_FSM_REQSENT;
 8014d86:	687b      	ldr	r3, [r7, #4]
 8014d88:	2206      	movs	r2, #6
 8014d8a:	741a      	strb	r2, [r3, #16]
	break;
 8014d8c:	e016      	b.n	8014dbc <fsm_open+0x8c>

    case PPP_FSM_CLOSING:
	f->state = PPP_FSM_STOPPING;
 8014d8e:	687b      	ldr	r3, [r7, #4]
 8014d90:	2205      	movs	r2, #5
 8014d92:	741a      	strb	r2, [r3, #16]
	/* fall through */
	/* no break */
    case PPP_FSM_STOPPED:
    case PPP_FSM_OPENED:
	if( f->flags & OPT_RESTART ){
 8014d94:	687b      	ldr	r3, [r7, #4]
 8014d96:	7c5b      	ldrb	r3, [r3, #17]
 8014d98:	001a      	movs	r2, r3
 8014d9a:	2302      	movs	r3, #2
 8014d9c:	4013      	ands	r3, r2
 8014d9e:	d00c      	beq.n	8014dba <fsm_open+0x8a>
	    fsm_lowerdown(f);
 8014da0:	687b      	ldr	r3, [r7, #4]
 8014da2:	0018      	movs	r0, r3
 8014da4:	f7ff ff78 	bl	8014c98 <fsm_lowerdown>
	    fsm_lowerup(f);
 8014da8:	687b      	ldr	r3, [r7, #4]
 8014daa:	0018      	movs	r0, r3
 8014dac:	f7ff ff4d 	bl	8014c4a <fsm_lowerup>
	}
	break;
 8014db0:	e003      	b.n	8014dba <fsm_open+0x8a>
    default:
	break;
 8014db2:	46c0      	nop			; (mov r8, r8)
 8014db4:	e002      	b.n	8014dbc <fsm_open+0x8c>
	break;
 8014db6:	46c0      	nop			; (mov r8, r8)
 8014db8:	e000      	b.n	8014dbc <fsm_open+0x8c>
	break;
 8014dba:	46c0      	nop			; (mov r8, r8)
    }
}
 8014dbc:	46c0      	nop			; (mov r8, r8)
 8014dbe:	46bd      	mov	sp, r7
 8014dc0:	b002      	add	sp, #8
 8014dc2:	bd80      	pop	{r7, pc}
 8014dc4:	08023ad0 	.word	0x08023ad0

08014dc8 <terminate_layer>:
 * terminate_layer - Start process of shutting down the FSM
 *
 * Cancel any timeout running, notify upper layers we're done, and
 * send a terminate-request message as configured.
 */
static void terminate_layer(fsm *f, int nextstate) {
 8014dc8:	b580      	push	{r7, lr}
 8014dca:	b086      	sub	sp, #24
 8014dcc:	af02      	add	r7, sp, #8
 8014dce:	6078      	str	r0, [r7, #4]
 8014dd0:	6039      	str	r1, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 8014dd2:	687b      	ldr	r3, [r7, #4]
 8014dd4:	681b      	ldr	r3, [r3, #0]
 8014dd6:	60fb      	str	r3, [r7, #12]

    if( f->state != PPP_FSM_OPENED )
 8014dd8:	687b      	ldr	r3, [r7, #4]
 8014dda:	7c1b      	ldrb	r3, [r3, #16]
 8014ddc:	2b09      	cmp	r3, #9
 8014dde:	d006      	beq.n	8014dee <terminate_layer+0x26>
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 8014de0:	687a      	ldr	r2, [r7, #4]
 8014de2:	4b33      	ldr	r3, [pc, #204]	; (8014eb0 <terminate_layer+0xe8>)
 8014de4:	0011      	movs	r1, r2
 8014de6:	0018      	movs	r0, r3
 8014de8:	f7fd fe64 	bl	8012ab4 <sys_untimeout>
 8014dec:	e00a      	b.n	8014e04 <terminate_layer+0x3c>
    else if( f->callbacks->down )
 8014dee:	687b      	ldr	r3, [r7, #4]
 8014df0:	685b      	ldr	r3, [r3, #4]
 8014df2:	6a1b      	ldr	r3, [r3, #32]
 8014df4:	2b00      	cmp	r3, #0
 8014df6:	d005      	beq.n	8014e04 <terminate_layer+0x3c>
	(*f->callbacks->down)(f);	/* Inform upper layers we're down */
 8014df8:	687b      	ldr	r3, [r7, #4]
 8014dfa:	685b      	ldr	r3, [r3, #4]
 8014dfc:	6a1b      	ldr	r3, [r3, #32]
 8014dfe:	687a      	ldr	r2, [r7, #4]
 8014e00:	0010      	movs	r0, r2
 8014e02:	4798      	blx	r3

    /* Init restart counter and send Terminate-Request */
    f->retransmits = pcb->settings.fsm_max_term_transmits;
 8014e04:	68fb      	ldr	r3, [r7, #12]
 8014e06:	799a      	ldrb	r2, [r3, #6]
 8014e08:	687b      	ldr	r3, [r7, #4]
 8014e0a:	751a      	strb	r2, [r3, #20]
    fsm_sdata(f, TERMREQ, f->reqid = ++f->id,
 8014e0c:	687b      	ldr	r3, [r7, #4]
 8014e0e:	7c9b      	ldrb	r3, [r3, #18]
 8014e10:	3301      	adds	r3, #1
 8014e12:	b2da      	uxtb	r2, r3
 8014e14:	687b      	ldr	r3, [r7, #4]
 8014e16:	749a      	strb	r2, [r3, #18]
 8014e18:	687b      	ldr	r3, [r7, #4]
 8014e1a:	7c9a      	ldrb	r2, [r3, #18]
 8014e1c:	687b      	ldr	r3, [r7, #4]
 8014e1e:	74da      	strb	r2, [r3, #19]
 8014e20:	687b      	ldr	r3, [r7, #4]
 8014e22:	7cda      	ldrb	r2, [r3, #19]
	      (const u_char *) f->term_reason, f->term_reason_len);
 8014e24:	687b      	ldr	r3, [r7, #4]
 8014e26:	6899      	ldr	r1, [r3, #8]
 8014e28:	687b      	ldr	r3, [r7, #4]
 8014e2a:	7e1b      	ldrb	r3, [r3, #24]
    fsm_sdata(f, TERMREQ, f->reqid = ++f->id,
 8014e2c:	6878      	ldr	r0, [r7, #4]
 8014e2e:	9300      	str	r3, [sp, #0]
 8014e30:	000b      	movs	r3, r1
 8014e32:	2105      	movs	r1, #5
 8014e34:	f000 fe0a 	bl	8015a4c <fsm_sdata>

    if (f->retransmits == 0) {
 8014e38:	687b      	ldr	r3, [r7, #4]
 8014e3a:	7d1b      	ldrb	r3, [r3, #20]
 8014e3c:	2b00      	cmp	r3, #0
 8014e3e:	d113      	bne.n	8014e68 <terminate_layer+0xa0>
	/*
	 * User asked for no terminate requests at all; just close it.
	 * We've already fired off one Terminate-Request just to be nice
	 * to the peer, but we're not going to wait for a reply.
	 */
	f->state = nextstate == PPP_FSM_CLOSING ? PPP_FSM_CLOSED : PPP_FSM_STOPPED;
 8014e40:	683b      	ldr	r3, [r7, #0]
 8014e42:	2b04      	cmp	r3, #4
 8014e44:	d101      	bne.n	8014e4a <terminate_layer+0x82>
 8014e46:	2202      	movs	r2, #2
 8014e48:	e000      	b.n	8014e4c <terminate_layer+0x84>
 8014e4a:	2203      	movs	r2, #3
 8014e4c:	687b      	ldr	r3, [r7, #4]
 8014e4e:	741a      	strb	r2, [r3, #16]
	if( f->callbacks->finished )
 8014e50:	687b      	ldr	r3, [r7, #4]
 8014e52:	685b      	ldr	r3, [r3, #4]
 8014e54:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014e56:	2b00      	cmp	r3, #0
 8014e58:	d026      	beq.n	8014ea8 <terminate_layer+0xe0>
	    (*f->callbacks->finished)(f);
 8014e5a:	687b      	ldr	r3, [r7, #4]
 8014e5c:	685b      	ldr	r3, [r3, #4]
 8014e5e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014e60:	687a      	ldr	r2, [r7, #4]
 8014e62:	0010      	movs	r0, r2
 8014e64:	4798      	blx	r3
	return;
 8014e66:	e01f      	b.n	8014ea8 <terminate_layer+0xe0>
    }

    TIMEOUT(fsm_timeout, f, pcb->settings.fsm_timeout_time);
 8014e68:	687a      	ldr	r2, [r7, #4]
 8014e6a:	4b11      	ldr	r3, [pc, #68]	; (8014eb0 <terminate_layer+0xe8>)
 8014e6c:	0011      	movs	r1, r2
 8014e6e:	0018      	movs	r0, r3
 8014e70:	f7fd fe20 	bl	8012ab4 <sys_untimeout>
 8014e74:	68fb      	ldr	r3, [r7, #12]
 8014e76:	791b      	ldrb	r3, [r3, #4]
 8014e78:	001a      	movs	r2, r3
 8014e7a:	0013      	movs	r3, r2
 8014e7c:	015b      	lsls	r3, r3, #5
 8014e7e:	1a9b      	subs	r3, r3, r2
 8014e80:	009b      	lsls	r3, r3, #2
 8014e82:	189b      	adds	r3, r3, r2
 8014e84:	00db      	lsls	r3, r3, #3
 8014e86:	0018      	movs	r0, r3
 8014e88:	687a      	ldr	r2, [r7, #4]
 8014e8a:	4b09      	ldr	r3, [pc, #36]	; (8014eb0 <terminate_layer+0xe8>)
 8014e8c:	0019      	movs	r1, r3
 8014e8e:	f7fd fde9 	bl	8012a64 <sys_timeout>
    --f->retransmits;
 8014e92:	687b      	ldr	r3, [r7, #4]
 8014e94:	7d1b      	ldrb	r3, [r3, #20]
 8014e96:	3b01      	subs	r3, #1
 8014e98:	b2da      	uxtb	r2, r3
 8014e9a:	687b      	ldr	r3, [r7, #4]
 8014e9c:	751a      	strb	r2, [r3, #20]

    f->state = nextstate;
 8014e9e:	683b      	ldr	r3, [r7, #0]
 8014ea0:	b2da      	uxtb	r2, r3
 8014ea2:	687b      	ldr	r3, [r7, #4]
 8014ea4:	741a      	strb	r2, [r3, #16]
 8014ea6:	e000      	b.n	8014eaa <terminate_layer+0xe2>
	return;
 8014ea8:	46c0      	nop			; (mov r8, r8)
}
 8014eaa:	46bd      	mov	sp, r7
 8014eac:	b004      	add	sp, #16
 8014eae:	bd80      	pop	{r7, pc}
 8014eb0:	08014f3d 	.word	0x08014f3d

08014eb4 <fsm_close>:
 * fsm_close - Start closing connection.
 *
 * Cancel timeouts and either initiate close or possibly go directly to
 * the PPP_FSM_CLOSED state.
 */
void fsm_close(fsm *f, const char *reason) {
 8014eb4:	b580      	push	{r7, lr}
 8014eb6:	b082      	sub	sp, #8
 8014eb8:	af00      	add	r7, sp, #0
 8014eba:	6078      	str	r0, [r7, #4]
 8014ebc:	6039      	str	r1, [r7, #0]
    f->term_reason = reason;
 8014ebe:	687b      	ldr	r3, [r7, #4]
 8014ec0:	683a      	ldr	r2, [r7, #0]
 8014ec2:	609a      	str	r2, [r3, #8]
    f->term_reason_len = (reason == NULL? 0: (u8_t)LWIP_MIN(strlen(reason), 0xFF) );
 8014ec4:	683b      	ldr	r3, [r7, #0]
 8014ec6:	2b00      	cmp	r3, #0
 8014ec8:	d00f      	beq.n	8014eea <fsm_close+0x36>
 8014eca:	683b      	ldr	r3, [r7, #0]
 8014ecc:	0018      	movs	r0, r3
 8014ece:	f7eb f925 	bl	800011c <strlen>
 8014ed2:	0003      	movs	r3, r0
 8014ed4:	2bfe      	cmp	r3, #254	; 0xfe
 8014ed6:	d806      	bhi.n	8014ee6 <fsm_close+0x32>
 8014ed8:	683b      	ldr	r3, [r7, #0]
 8014eda:	0018      	movs	r0, r3
 8014edc:	f7eb f91e 	bl	800011c <strlen>
 8014ee0:	0003      	movs	r3, r0
 8014ee2:	b2db      	uxtb	r3, r3
 8014ee4:	e002      	b.n	8014eec <fsm_close+0x38>
 8014ee6:	23ff      	movs	r3, #255	; 0xff
 8014ee8:	e000      	b.n	8014eec <fsm_close+0x38>
 8014eea:	2300      	movs	r3, #0
 8014eec:	687a      	ldr	r2, [r7, #4]
 8014eee:	7613      	strb	r3, [r2, #24]
    switch( f->state ){
 8014ef0:	687b      	ldr	r3, [r7, #4]
 8014ef2:	7c1b      	ldrb	r3, [r3, #16]
 8014ef4:	2b09      	cmp	r3, #9
 8014ef6:	dc1b      	bgt.n	8014f30 <fsm_close+0x7c>
 8014ef8:	2b06      	cmp	r3, #6
 8014efa:	da13      	bge.n	8014f24 <fsm_close+0x70>
 8014efc:	2b05      	cmp	r3, #5
 8014efe:	d00d      	beq.n	8014f1c <fsm_close+0x68>
 8014f00:	dc16      	bgt.n	8014f30 <fsm_close+0x7c>
 8014f02:	2b01      	cmp	r3, #1
 8014f04:	d002      	beq.n	8014f0c <fsm_close+0x58>
 8014f06:	2b03      	cmp	r3, #3
 8014f08:	d004      	beq.n	8014f14 <fsm_close+0x60>
    case PPP_FSM_ACKSENT:
    case PPP_FSM_OPENED:
	terminate_layer(f, PPP_FSM_CLOSING);
	break;
    default:
	break;
 8014f0a:	e011      	b.n	8014f30 <fsm_close+0x7c>
	f->state = PPP_FSM_INITIAL;
 8014f0c:	687b      	ldr	r3, [r7, #4]
 8014f0e:	2200      	movs	r2, #0
 8014f10:	741a      	strb	r2, [r3, #16]
	break;
 8014f12:	e00e      	b.n	8014f32 <fsm_close+0x7e>
	f->state = PPP_FSM_CLOSED;
 8014f14:	687b      	ldr	r3, [r7, #4]
 8014f16:	2202      	movs	r2, #2
 8014f18:	741a      	strb	r2, [r3, #16]
	break;
 8014f1a:	e00a      	b.n	8014f32 <fsm_close+0x7e>
	f->state = PPP_FSM_CLOSING;
 8014f1c:	687b      	ldr	r3, [r7, #4]
 8014f1e:	2204      	movs	r2, #4
 8014f20:	741a      	strb	r2, [r3, #16]
	break;
 8014f22:	e006      	b.n	8014f32 <fsm_close+0x7e>
	terminate_layer(f, PPP_FSM_CLOSING);
 8014f24:	687b      	ldr	r3, [r7, #4]
 8014f26:	2104      	movs	r1, #4
 8014f28:	0018      	movs	r0, r3
 8014f2a:	f7ff ff4d 	bl	8014dc8 <terminate_layer>
	break;
 8014f2e:	e000      	b.n	8014f32 <fsm_close+0x7e>
	break;
 8014f30:	46c0      	nop			; (mov r8, r8)
    }
}
 8014f32:	46c0      	nop			; (mov r8, r8)
 8014f34:	46bd      	mov	sp, r7
 8014f36:	b002      	add	sp, #8
 8014f38:	bd80      	pop	{r7, pc}
	...

08014f3c <fsm_timeout>:


/*
 * fsm_timeout - Timeout expired.
 */
static void fsm_timeout(void *arg) {
 8014f3c:	b580      	push	{r7, lr}
 8014f3e:	b086      	sub	sp, #24
 8014f40:	af02      	add	r7, sp, #8
 8014f42:	6078      	str	r0, [r7, #4]
    fsm *f = (fsm *) arg;
 8014f44:	687b      	ldr	r3, [r7, #4]
 8014f46:	60fb      	str	r3, [r7, #12]
    ppp_pcb *pcb = f->pcb;
 8014f48:	68fb      	ldr	r3, [r7, #12]
 8014f4a:	681b      	ldr	r3, [r3, #0]
 8014f4c:	60bb      	str	r3, [r7, #8]

    switch (f->state) {
 8014f4e:	68fb      	ldr	r3, [r7, #12]
 8014f50:	7c1b      	ldrb	r3, [r3, #16]
 8014f52:	2b05      	cmp	r3, #5
 8014f54:	dc02      	bgt.n	8014f5c <fsm_timeout+0x20>
 8014f56:	2b04      	cmp	r3, #4
 8014f58:	da05      	bge.n	8014f66 <fsm_timeout+0x2a>

    default:
	FSMDEBUG(("%s: Timeout event in state %d!", PROTO_NAME(f), f->state));
	/* no break */
    }
}
 8014f5a:	e08c      	b.n	8015076 <fsm_timeout+0x13a>
 8014f5c:	3b06      	subs	r3, #6
    switch (f->state) {
 8014f5e:	2b02      	cmp	r3, #2
 8014f60:	d900      	bls.n	8014f64 <fsm_timeout+0x28>
 8014f62:	e088      	b.n	8015076 <fsm_timeout+0x13a>
 8014f64:	e04b      	b.n	8014ffe <fsm_timeout+0xc2>
	if( f->retransmits <= 0 ){
 8014f66:	68fb      	ldr	r3, [r7, #12]
 8014f68:	7d1b      	ldrb	r3, [r3, #20]
 8014f6a:	2b00      	cmp	r3, #0
 8014f6c:	d115      	bne.n	8014f9a <fsm_timeout+0x5e>
	    f->state = (f->state == PPP_FSM_CLOSING)? PPP_FSM_CLOSED: PPP_FSM_STOPPED;
 8014f6e:	68fb      	ldr	r3, [r7, #12]
 8014f70:	7c1b      	ldrb	r3, [r3, #16]
 8014f72:	2b04      	cmp	r3, #4
 8014f74:	d101      	bne.n	8014f7a <fsm_timeout+0x3e>
 8014f76:	2202      	movs	r2, #2
 8014f78:	e000      	b.n	8014f7c <fsm_timeout+0x40>
 8014f7a:	2203      	movs	r2, #3
 8014f7c:	68fb      	ldr	r3, [r7, #12]
 8014f7e:	741a      	strb	r2, [r3, #16]
	    if( f->callbacks->finished )
 8014f80:	68fb      	ldr	r3, [r7, #12]
 8014f82:	685b      	ldr	r3, [r3, #4]
 8014f84:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014f86:	2b00      	cmp	r3, #0
 8014f88:	d100      	bne.n	8014f8c <fsm_timeout+0x50>
 8014f8a:	e071      	b.n	8015070 <fsm_timeout+0x134>
		(*f->callbacks->finished)(f);
 8014f8c:	68fb      	ldr	r3, [r7, #12]
 8014f8e:	685b      	ldr	r3, [r3, #4]
 8014f90:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014f92:	68fa      	ldr	r2, [r7, #12]
 8014f94:	0010      	movs	r0, r2
 8014f96:	4798      	blx	r3
	break;
 8014f98:	e06a      	b.n	8015070 <fsm_timeout+0x134>
	    fsm_sdata(f, TERMREQ, f->reqid = ++f->id,
 8014f9a:	68fb      	ldr	r3, [r7, #12]
 8014f9c:	7c9b      	ldrb	r3, [r3, #18]
 8014f9e:	3301      	adds	r3, #1
 8014fa0:	b2da      	uxtb	r2, r3
 8014fa2:	68fb      	ldr	r3, [r7, #12]
 8014fa4:	749a      	strb	r2, [r3, #18]
 8014fa6:	68fb      	ldr	r3, [r7, #12]
 8014fa8:	7c9a      	ldrb	r2, [r3, #18]
 8014faa:	68fb      	ldr	r3, [r7, #12]
 8014fac:	74da      	strb	r2, [r3, #19]
 8014fae:	68fb      	ldr	r3, [r7, #12]
 8014fb0:	7cda      	ldrb	r2, [r3, #19]
		      (const u_char *) f->term_reason, f->term_reason_len);
 8014fb2:	68fb      	ldr	r3, [r7, #12]
 8014fb4:	6899      	ldr	r1, [r3, #8]
 8014fb6:	68fb      	ldr	r3, [r7, #12]
 8014fb8:	7e1b      	ldrb	r3, [r3, #24]
	    fsm_sdata(f, TERMREQ, f->reqid = ++f->id,
 8014fba:	68f8      	ldr	r0, [r7, #12]
 8014fbc:	9300      	str	r3, [sp, #0]
 8014fbe:	000b      	movs	r3, r1
 8014fc0:	2105      	movs	r1, #5
 8014fc2:	f000 fd43 	bl	8015a4c <fsm_sdata>
	    TIMEOUT(fsm_timeout, f, pcb->settings.fsm_timeout_time);
 8014fc6:	68fa      	ldr	r2, [r7, #12]
 8014fc8:	4b2d      	ldr	r3, [pc, #180]	; (8015080 <fsm_timeout+0x144>)
 8014fca:	0011      	movs	r1, r2
 8014fcc:	0018      	movs	r0, r3
 8014fce:	f7fd fd71 	bl	8012ab4 <sys_untimeout>
 8014fd2:	68bb      	ldr	r3, [r7, #8]
 8014fd4:	791b      	ldrb	r3, [r3, #4]
 8014fd6:	001a      	movs	r2, r3
 8014fd8:	0013      	movs	r3, r2
 8014fda:	015b      	lsls	r3, r3, #5
 8014fdc:	1a9b      	subs	r3, r3, r2
 8014fde:	009b      	lsls	r3, r3, #2
 8014fe0:	189b      	adds	r3, r3, r2
 8014fe2:	00db      	lsls	r3, r3, #3
 8014fe4:	0018      	movs	r0, r3
 8014fe6:	68fa      	ldr	r2, [r7, #12]
 8014fe8:	4b25      	ldr	r3, [pc, #148]	; (8015080 <fsm_timeout+0x144>)
 8014fea:	0019      	movs	r1, r3
 8014fec:	f7fd fd3a 	bl	8012a64 <sys_timeout>
	    --f->retransmits;
 8014ff0:	68fb      	ldr	r3, [r7, #12]
 8014ff2:	7d1b      	ldrb	r3, [r3, #20]
 8014ff4:	3b01      	subs	r3, #1
 8014ff6:	b2da      	uxtb	r2, r3
 8014ff8:	68fb      	ldr	r3, [r7, #12]
 8014ffa:	751a      	strb	r2, [r3, #20]
	break;
 8014ffc:	e038      	b.n	8015070 <fsm_timeout+0x134>
	if (f->retransmits <= 0) {
 8014ffe:	68fb      	ldr	r3, [r7, #12]
 8015000:	7d1b      	ldrb	r3, [r3, #20]
 8015002:	2b00      	cmp	r3, #0
 8015004:	d11c      	bne.n	8015040 <fsm_timeout+0x104>
	    ppp_warn("%s: timeout sending Config-Requests", PROTO_NAME(f));
 8015006:	68fb      	ldr	r3, [r7, #12]
 8015008:	685b      	ldr	r3, [r3, #4]
 801500a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 801500c:	4b1d      	ldr	r3, [pc, #116]	; (8015084 <fsm_timeout+0x148>)
 801500e:	0011      	movs	r1, r2
 8015010:	0018      	movs	r0, r3
 8015012:	f006 ffaa 	bl	801bf6a <ppp_warn>
	    f->state = PPP_FSM_STOPPED;
 8015016:	68fb      	ldr	r3, [r7, #12]
 8015018:	2203      	movs	r2, #3
 801501a:	741a      	strb	r2, [r3, #16]
	    if( (f->flags & OPT_PASSIVE) == 0 && f->callbacks->finished )
 801501c:	68fb      	ldr	r3, [r7, #12]
 801501e:	7c5b      	ldrb	r3, [r3, #17]
 8015020:	001a      	movs	r2, r3
 8015022:	2301      	movs	r3, #1
 8015024:	4013      	ands	r3, r2
 8015026:	d125      	bne.n	8015074 <fsm_timeout+0x138>
 8015028:	68fb      	ldr	r3, [r7, #12]
 801502a:	685b      	ldr	r3, [r3, #4]
 801502c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801502e:	2b00      	cmp	r3, #0
 8015030:	d020      	beq.n	8015074 <fsm_timeout+0x138>
		(*f->callbacks->finished)(f);
 8015032:	68fb      	ldr	r3, [r7, #12]
 8015034:	685b      	ldr	r3, [r3, #4]
 8015036:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8015038:	68fa      	ldr	r2, [r7, #12]
 801503a:	0010      	movs	r0, r2
 801503c:	4798      	blx	r3
	break;
 801503e:	e019      	b.n	8015074 <fsm_timeout+0x138>
	    if (f->callbacks->retransmit)
 8015040:	68fb      	ldr	r3, [r7, #12]
 8015042:	685b      	ldr	r3, [r3, #4]
 8015044:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8015046:	2b00      	cmp	r3, #0
 8015048:	d005      	beq.n	8015056 <fsm_timeout+0x11a>
		(*f->callbacks->retransmit)(f);
 801504a:	68fb      	ldr	r3, [r7, #12]
 801504c:	685b      	ldr	r3, [r3, #4]
 801504e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8015050:	68fa      	ldr	r2, [r7, #12]
 8015052:	0010      	movs	r0, r2
 8015054:	4798      	blx	r3
	    fsm_sconfreq(f, 1);		/* Re-send Configure-Request */
 8015056:	68fb      	ldr	r3, [r7, #12]
 8015058:	2101      	movs	r1, #1
 801505a:	0018      	movs	r0, r3
 801505c:	f000 fc00 	bl	8015860 <fsm_sconfreq>
	    if( f->state == PPP_FSM_ACKRCVD )
 8015060:	68fb      	ldr	r3, [r7, #12]
 8015062:	7c1b      	ldrb	r3, [r3, #16]
 8015064:	2b07      	cmp	r3, #7
 8015066:	d105      	bne.n	8015074 <fsm_timeout+0x138>
		f->state = PPP_FSM_REQSENT;
 8015068:	68fb      	ldr	r3, [r7, #12]
 801506a:	2206      	movs	r2, #6
 801506c:	741a      	strb	r2, [r3, #16]
	break;
 801506e:	e001      	b.n	8015074 <fsm_timeout+0x138>
	break;
 8015070:	46c0      	nop			; (mov r8, r8)
 8015072:	e000      	b.n	8015076 <fsm_timeout+0x13a>
	break;
 8015074:	46c0      	nop			; (mov r8, r8)
}
 8015076:	46c0      	nop			; (mov r8, r8)
 8015078:	46bd      	mov	sp, r7
 801507a:	b004      	add	sp, #16
 801507c:	bd80      	pop	{r7, pc}
 801507e:	46c0      	nop			; (mov r8, r8)
 8015080:	08014f3d 	.word	0x08014f3d
 8015084:	08022654 	.word	0x08022654

08015088 <fsm_input>:


/*
 * fsm_input - Input packet.
 */
void fsm_input(fsm *f, u_char *inpacket, int l) {
 8015088:	b5b0      	push	{r4, r5, r7, lr}
 801508a:	b08a      	sub	sp, #40	; 0x28
 801508c:	af02      	add	r7, sp, #8
 801508e:	60f8      	str	r0, [r7, #12]
 8015090:	60b9      	str	r1, [r7, #8]
 8015092:	607a      	str	r2, [r7, #4]

    /*
     * Parse header (code, id and length).
     * If packet too short, drop it.
     */
    inp = inpacket;
 8015094:	68bb      	ldr	r3, [r7, #8]
 8015096:	61fb      	str	r3, [r7, #28]
    if (l < HEADERLEN) {
 8015098:	687b      	ldr	r3, [r7, #4]
 801509a:	2b03      	cmp	r3, #3
 801509c:	dc00      	bgt.n	80150a0 <fsm_input+0x18>
 801509e:	e097      	b.n	80151d0 <fsm_input+0x148>
	FSMDEBUG(("fsm_input(%x): Rcvd short header.", f->protocol));
	return;
    }
    GETCHAR(code, inp);
 80150a0:	69fb      	ldr	r3, [r7, #28]
 80150a2:	1c5a      	adds	r2, r3, #1
 80150a4:	61fa      	str	r2, [r7, #28]
 80150a6:	211b      	movs	r1, #27
 80150a8:	187a      	adds	r2, r7, r1
 80150aa:	781b      	ldrb	r3, [r3, #0]
 80150ac:	7013      	strb	r3, [r2, #0]
    GETCHAR(id, inp);
 80150ae:	69fb      	ldr	r3, [r7, #28]
 80150b0:	1c5a      	adds	r2, r3, #1
 80150b2:	61fa      	str	r2, [r7, #28]
 80150b4:	221a      	movs	r2, #26
 80150b6:	18ba      	adds	r2, r7, r2
 80150b8:	781b      	ldrb	r3, [r3, #0]
 80150ba:	7013      	strb	r3, [r2, #0]
    GETSHORT(len, inp);
 80150bc:	69fb      	ldr	r3, [r7, #28]
 80150be:	1c5a      	adds	r2, r3, #1
 80150c0:	61fa      	str	r2, [r7, #28]
 80150c2:	781b      	ldrb	r3, [r3, #0]
 80150c4:	021b      	lsls	r3, r3, #8
 80150c6:	617b      	str	r3, [r7, #20]
 80150c8:	69fb      	ldr	r3, [r7, #28]
 80150ca:	1c5a      	adds	r2, r3, #1
 80150cc:	61fa      	str	r2, [r7, #28]
 80150ce:	781b      	ldrb	r3, [r3, #0]
 80150d0:	001a      	movs	r2, r3
 80150d2:	697b      	ldr	r3, [r7, #20]
 80150d4:	4313      	orrs	r3, r2
 80150d6:	617b      	str	r3, [r7, #20]
    if (len < HEADERLEN) {
 80150d8:	697b      	ldr	r3, [r7, #20]
 80150da:	2b03      	cmp	r3, #3
 80150dc:	dc00      	bgt.n	80150e0 <fsm_input+0x58>
 80150de:	e079      	b.n	80151d4 <fsm_input+0x14c>
	FSMDEBUG(("fsm_input(%x): Rcvd illegal length.", f->protocol));
	return;
    }
    if (len > l) {
 80150e0:	697a      	ldr	r2, [r7, #20]
 80150e2:	687b      	ldr	r3, [r7, #4]
 80150e4:	429a      	cmp	r2, r3
 80150e6:	dd00      	ble.n	80150ea <fsm_input+0x62>
 80150e8:	e076      	b.n	80151d8 <fsm_input+0x150>
	FSMDEBUG(("fsm_input(%x): Rcvd short packet.", f->protocol));
	return;
    }
    len -= HEADERLEN;		/* subtract header length */
 80150ea:	697b      	ldr	r3, [r7, #20]
 80150ec:	3b04      	subs	r3, #4
 80150ee:	617b      	str	r3, [r7, #20]

    if( f->state == PPP_FSM_INITIAL || f->state == PPP_FSM_STARTING ){
 80150f0:	68fb      	ldr	r3, [r7, #12]
 80150f2:	7c1b      	ldrb	r3, [r3, #16]
 80150f4:	2b00      	cmp	r3, #0
 80150f6:	d100      	bne.n	80150fa <fsm_input+0x72>
 80150f8:	e070      	b.n	80151dc <fsm_input+0x154>
 80150fa:	68fb      	ldr	r3, [r7, #12]
 80150fc:	7c1b      	ldrb	r3, [r3, #16]
 80150fe:	2b01      	cmp	r3, #1
 8015100:	d06c      	beq.n	80151dc <fsm_input+0x154>
    }

    /*
     * Action depends on code.
     */
    switch (code) {
 8015102:	187b      	adds	r3, r7, r1
 8015104:	781b      	ldrb	r3, [r3, #0]
 8015106:	2b07      	cmp	r3, #7
 8015108:	d83a      	bhi.n	8015180 <fsm_input+0xf8>
 801510a:	009a      	lsls	r2, r3, #2
 801510c:	4b36      	ldr	r3, [pc, #216]	; (80151e8 <fsm_input+0x160>)
 801510e:	18d3      	adds	r3, r2, r3
 8015110:	681b      	ldr	r3, [r3, #0]
 8015112:	469f      	mov	pc, r3
    case CONFREQ:
	fsm_rconfreq(f, id, inp, len);
 8015114:	697c      	ldr	r4, [r7, #20]
 8015116:	69fa      	ldr	r2, [r7, #28]
 8015118:	231a      	movs	r3, #26
 801511a:	18fb      	adds	r3, r7, r3
 801511c:	7819      	ldrb	r1, [r3, #0]
 801511e:	68f8      	ldr	r0, [r7, #12]
 8015120:	0023      	movs	r3, r4
 8015122:	f000 f863 	bl	80151ec <fsm_rconfreq>
	break;
 8015126:	e05c      	b.n	80151e2 <fsm_input+0x15a>
    
    case CONFACK:
	fsm_rconfack(f, id, inp, len);
 8015128:	231a      	movs	r3, #26
 801512a:	18fb      	adds	r3, r7, r3
 801512c:	7819      	ldrb	r1, [r3, #0]
 801512e:	697b      	ldr	r3, [r7, #20]
 8015130:	69fa      	ldr	r2, [r7, #28]
 8015132:	68f8      	ldr	r0, [r7, #12]
 8015134:	f000 f904 	bl	8015340 <fsm_rconfack>
	break;
 8015138:	e053      	b.n	80151e2 <fsm_input+0x15a>
    
    case CONFNAK:
    case CONFREJ:
	fsm_rconfnakrej(f, code, id, inp, len);
 801513a:	231b      	movs	r3, #27
 801513c:	18fb      	adds	r3, r7, r3
 801513e:	7819      	ldrb	r1, [r3, #0]
 8015140:	231a      	movs	r3, #26
 8015142:	18fb      	adds	r3, r7, r3
 8015144:	781a      	ldrb	r2, [r3, #0]
 8015146:	69fc      	ldr	r4, [r7, #28]
 8015148:	68f8      	ldr	r0, [r7, #12]
 801514a:	697b      	ldr	r3, [r7, #20]
 801514c:	9300      	str	r3, [sp, #0]
 801514e:	0023      	movs	r3, r4
 8015150:	f000 f996 	bl	8015480 <fsm_rconfnakrej>
	break;
 8015154:	e045      	b.n	80151e2 <fsm_input+0x15a>
    
    case TERMREQ:
	fsm_rtermreq(f, id, inp, len);
 8015156:	231a      	movs	r3, #26
 8015158:	18fb      	adds	r3, r7, r3
 801515a:	7819      	ldrb	r1, [r3, #0]
 801515c:	697b      	ldr	r3, [r7, #20]
 801515e:	69fa      	ldr	r2, [r7, #28]
 8015160:	68f8      	ldr	r0, [r7, #12]
 8015162:	f000 fa41 	bl	80155e8 <fsm_rtermreq>
	break;
 8015166:	e03c      	b.n	80151e2 <fsm_input+0x15a>
    
    case TERMACK:
	fsm_rtermack(f);
 8015168:	68fb      	ldr	r3, [r7, #12]
 801516a:	0018      	movs	r0, r3
 801516c:	f000 faa2 	bl	80156b4 <fsm_rtermack>
	break;
 8015170:	e037      	b.n	80151e2 <fsm_input+0x15a>
    
    case CODEREJ:
	fsm_rcoderej(f, inp, len);
 8015172:	697a      	ldr	r2, [r7, #20]
 8015174:	69f9      	ldr	r1, [r7, #28]
 8015176:	68fb      	ldr	r3, [r7, #12]
 8015178:	0018      	movs	r0, r3
 801517a:	f000 faf9 	bl	8015770 <fsm_rcoderej>
	break;
 801517e:	e030      	b.n	80151e2 <fsm_input+0x15a>
    
    default:
	if( !f->callbacks->extcode
 8015180:	68fb      	ldr	r3, [r7, #12]
 8015182:	685b      	ldr	r3, [r3, #4]
 8015184:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8015186:	2b00      	cmp	r3, #0
 8015188:	d010      	beq.n	80151ac <fsm_input+0x124>
	   || !(*f->callbacks->extcode)(f, code, id, inp, len) )
 801518a:	68fb      	ldr	r3, [r7, #12]
 801518c:	685b      	ldr	r3, [r3, #4]
 801518e:	6b5c      	ldr	r4, [r3, #52]	; 0x34
 8015190:	231b      	movs	r3, #27
 8015192:	18fb      	adds	r3, r7, r3
 8015194:	7819      	ldrb	r1, [r3, #0]
 8015196:	231a      	movs	r3, #26
 8015198:	18fb      	adds	r3, r7, r3
 801519a:	781a      	ldrb	r2, [r3, #0]
 801519c:	69fd      	ldr	r5, [r7, #28]
 801519e:	68f8      	ldr	r0, [r7, #12]
 80151a0:	697b      	ldr	r3, [r7, #20]
 80151a2:	9300      	str	r3, [sp, #0]
 80151a4:	002b      	movs	r3, r5
 80151a6:	47a0      	blx	r4
 80151a8:	1e03      	subs	r3, r0, #0
 80151aa:	d119      	bne.n	80151e0 <fsm_input+0x158>
	    fsm_sdata(f, CODEREJ, ++f->id, inpacket, len + HEADERLEN);
 80151ac:	68fb      	ldr	r3, [r7, #12]
 80151ae:	7c9b      	ldrb	r3, [r3, #18]
 80151b0:	3301      	adds	r3, #1
 80151b2:	b2da      	uxtb	r2, r3
 80151b4:	68fb      	ldr	r3, [r7, #12]
 80151b6:	749a      	strb	r2, [r3, #18]
 80151b8:	68fb      	ldr	r3, [r7, #12]
 80151ba:	7c9a      	ldrb	r2, [r3, #18]
 80151bc:	697b      	ldr	r3, [r7, #20]
 80151be:	3304      	adds	r3, #4
 80151c0:	68b9      	ldr	r1, [r7, #8]
 80151c2:	68f8      	ldr	r0, [r7, #12]
 80151c4:	9300      	str	r3, [sp, #0]
 80151c6:	000b      	movs	r3, r1
 80151c8:	2107      	movs	r1, #7
 80151ca:	f000 fc3f 	bl	8015a4c <fsm_sdata>
	break;
 80151ce:	e007      	b.n	80151e0 <fsm_input+0x158>
	return;
 80151d0:	46c0      	nop			; (mov r8, r8)
 80151d2:	e006      	b.n	80151e2 <fsm_input+0x15a>
	return;
 80151d4:	46c0      	nop			; (mov r8, r8)
 80151d6:	e004      	b.n	80151e2 <fsm_input+0x15a>
	return;
 80151d8:	46c0      	nop			; (mov r8, r8)
 80151da:	e002      	b.n	80151e2 <fsm_input+0x15a>
	return;
 80151dc:	46c0      	nop			; (mov r8, r8)
 80151de:	e000      	b.n	80151e2 <fsm_input+0x15a>
	break;
 80151e0:	46c0      	nop			; (mov r8, r8)
    }
}
 80151e2:	46bd      	mov	sp, r7
 80151e4:	b008      	add	sp, #32
 80151e6:	bdb0      	pop	{r4, r5, r7, pc}
 80151e8:	08023af8 	.word	0x08023af8

080151ec <fsm_rconfreq>:


/*
 * fsm_rconfreq - Receive Configure-Request.
 */
static void fsm_rconfreq(fsm *f, u_char id, u_char *inp, int len) {
 80151ec:	b590      	push	{r4, r7, lr}
 80151ee:	b089      	sub	sp, #36	; 0x24
 80151f0:	af02      	add	r7, sp, #8
 80151f2:	60f8      	str	r0, [r7, #12]
 80151f4:	607a      	str	r2, [r7, #4]
 80151f6:	603b      	str	r3, [r7, #0]
 80151f8:	230b      	movs	r3, #11
 80151fa:	18fb      	adds	r3, r7, r3
 80151fc:	1c0a      	adds	r2, r1, #0
 80151fe:	701a      	strb	r2, [r3, #0]
    int code, reject_if_disagree;

    switch( f->state ){
 8015200:	68fb      	ldr	r3, [r7, #12]
 8015202:	7c1b      	ldrb	r3, [r3, #16]
 8015204:	2b09      	cmp	r3, #9
 8015206:	d015      	beq.n	8015234 <fsm_rconfreq+0x48>
 8015208:	dc31      	bgt.n	801526e <fsm_rconfreq+0x82>
 801520a:	2b05      	cmp	r3, #5
 801520c:	dc2f      	bgt.n	801526e <fsm_rconfreq+0x82>
 801520e:	2b04      	cmp	r3, #4
 8015210:	db00      	blt.n	8015214 <fsm_rconfreq+0x28>
 8015212:	e08e      	b.n	8015332 <fsm_rconfreq+0x146>
 8015214:	2b02      	cmp	r3, #2
 8015216:	d002      	beq.n	801521e <fsm_rconfreq+0x32>
 8015218:	2b03      	cmp	r3, #3
 801521a:	d01f      	beq.n	801525c <fsm_rconfreq+0x70>
	/* Negotiation started by our peer */
	fsm_sconfreq(f, 0);		/* Send initial Configure-Request */
	f->state = PPP_FSM_REQSENT;
	break;
    default:
	break;
 801521c:	e027      	b.n	801526e <fsm_rconfreq+0x82>
	fsm_sdata(f, TERMACK, id, NULL, 0);
 801521e:	230b      	movs	r3, #11
 8015220:	18fb      	adds	r3, r7, r3
 8015222:	781a      	ldrb	r2, [r3, #0]
 8015224:	68f8      	ldr	r0, [r7, #12]
 8015226:	2300      	movs	r3, #0
 8015228:	9300      	str	r3, [sp, #0]
 801522a:	2300      	movs	r3, #0
 801522c:	2106      	movs	r1, #6
 801522e:	f000 fc0d 	bl	8015a4c <fsm_sdata>
	return;
 8015232:	e07f      	b.n	8015334 <fsm_rconfreq+0x148>
	if( f->callbacks->down )
 8015234:	68fb      	ldr	r3, [r7, #12]
 8015236:	685b      	ldr	r3, [r3, #4]
 8015238:	6a1b      	ldr	r3, [r3, #32]
 801523a:	2b00      	cmp	r3, #0
 801523c:	d005      	beq.n	801524a <fsm_rconfreq+0x5e>
	    (*f->callbacks->down)(f);	/* Inform upper layers */
 801523e:	68fb      	ldr	r3, [r7, #12]
 8015240:	685b      	ldr	r3, [r3, #4]
 8015242:	6a1b      	ldr	r3, [r3, #32]
 8015244:	68fa      	ldr	r2, [r7, #12]
 8015246:	0010      	movs	r0, r2
 8015248:	4798      	blx	r3
	fsm_sconfreq(f, 0);		/* Send initial Configure-Request */
 801524a:	68fb      	ldr	r3, [r7, #12]
 801524c:	2100      	movs	r1, #0
 801524e:	0018      	movs	r0, r3
 8015250:	f000 fb06 	bl	8015860 <fsm_sconfreq>
	f->state = PPP_FSM_REQSENT;
 8015254:	68fb      	ldr	r3, [r7, #12]
 8015256:	2206      	movs	r2, #6
 8015258:	741a      	strb	r2, [r3, #16]
	break;
 801525a:	e009      	b.n	8015270 <fsm_rconfreq+0x84>
	fsm_sconfreq(f, 0);		/* Send initial Configure-Request */
 801525c:	68fb      	ldr	r3, [r7, #12]
 801525e:	2100      	movs	r1, #0
 8015260:	0018      	movs	r0, r3
 8015262:	f000 fafd 	bl	8015860 <fsm_sconfreq>
	f->state = PPP_FSM_REQSENT;
 8015266:	68fb      	ldr	r3, [r7, #12]
 8015268:	2206      	movs	r2, #6
 801526a:	741a      	strb	r2, [r3, #16]
	break;
 801526c:	e000      	b.n	8015270 <fsm_rconfreq+0x84>
	break;
 801526e:	46c0      	nop			; (mov r8, r8)

    /*
     * Pass the requested configuration options
     * to protocol-specific code for checking.
     */
    if (f->callbacks->reqci){		/* Check CI */
 8015270:	68fb      	ldr	r3, [r7, #12]
 8015272:	685b      	ldr	r3, [r3, #4]
 8015274:	699b      	ldr	r3, [r3, #24]
 8015276:	2b00      	cmp	r3, #0
 8015278:	d013      	beq.n	80152a2 <fsm_rconfreq+0xb6>
	reject_if_disagree = (f->nakloops >= f->maxnakloops);
 801527a:	68fb      	ldr	r3, [r7, #12]
 801527c:	7d59      	ldrb	r1, [r3, #21]
 801527e:	68fb      	ldr	r3, [r7, #12]
 8015280:	7dda      	ldrb	r2, [r3, #23]
 8015282:	2300      	movs	r3, #0
 8015284:	4291      	cmp	r1, r2
 8015286:	415b      	adcs	r3, r3
 8015288:	b2db      	uxtb	r3, r3
 801528a:	613b      	str	r3, [r7, #16]
	code = (*f->callbacks->reqci)(f, inp, &len, reject_if_disagree);
 801528c:	68fb      	ldr	r3, [r7, #12]
 801528e:	685b      	ldr	r3, [r3, #4]
 8015290:	699c      	ldr	r4, [r3, #24]
 8015292:	693b      	ldr	r3, [r7, #16]
 8015294:	003a      	movs	r2, r7
 8015296:	6879      	ldr	r1, [r7, #4]
 8015298:	68f8      	ldr	r0, [r7, #12]
 801529a:	47a0      	blx	r4
 801529c:	0003      	movs	r3, r0
 801529e:	617b      	str	r3, [r7, #20]
 80152a0:	e007      	b.n	80152b2 <fsm_rconfreq+0xc6>
    } else if (len)
 80152a2:	683b      	ldr	r3, [r7, #0]
 80152a4:	2b00      	cmp	r3, #0
 80152a6:	d002      	beq.n	80152ae <fsm_rconfreq+0xc2>
	code = CONFREJ;			/* Reject all CI */
 80152a8:	2304      	movs	r3, #4
 80152aa:	617b      	str	r3, [r7, #20]
 80152ac:	e001      	b.n	80152b2 <fsm_rconfreq+0xc6>
    else
	code = CONFACK;
 80152ae:	2302      	movs	r3, #2
 80152b0:	617b      	str	r3, [r7, #20]

    /* send the Ack, Nak or Rej to the peer */
    fsm_sdata(f, code, id, inp, len);
 80152b2:	697b      	ldr	r3, [r7, #20]
 80152b4:	b2d9      	uxtb	r1, r3
 80152b6:	683b      	ldr	r3, [r7, #0]
 80152b8:	687c      	ldr	r4, [r7, #4]
 80152ba:	220b      	movs	r2, #11
 80152bc:	18ba      	adds	r2, r7, r2
 80152be:	7812      	ldrb	r2, [r2, #0]
 80152c0:	68f8      	ldr	r0, [r7, #12]
 80152c2:	9300      	str	r3, [sp, #0]
 80152c4:	0023      	movs	r3, r4
 80152c6:	f000 fbc1 	bl	8015a4c <fsm_sdata>

    if (code == CONFACK) {
 80152ca:	697b      	ldr	r3, [r7, #20]
 80152cc:	2b02      	cmp	r3, #2
 80152ce:	d11f      	bne.n	8015310 <fsm_rconfreq+0x124>
	if (f->state == PPP_FSM_ACKRCVD) {
 80152d0:	68fb      	ldr	r3, [r7, #12]
 80152d2:	7c1b      	ldrb	r3, [r3, #16]
 80152d4:	2b07      	cmp	r3, #7
 80152d6:	d114      	bne.n	8015302 <fsm_rconfreq+0x116>
	    UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 80152d8:	68fa      	ldr	r2, [r7, #12]
 80152da:	4b18      	ldr	r3, [pc, #96]	; (801533c <fsm_rconfreq+0x150>)
 80152dc:	0011      	movs	r1, r2
 80152de:	0018      	movs	r0, r3
 80152e0:	f7fd fbe8 	bl	8012ab4 <sys_untimeout>
	    f->state = PPP_FSM_OPENED;
 80152e4:	68fb      	ldr	r3, [r7, #12]
 80152e6:	2209      	movs	r2, #9
 80152e8:	741a      	strb	r2, [r3, #16]
	    if (f->callbacks->up)
 80152ea:	68fb      	ldr	r3, [r7, #12]
 80152ec:	685b      	ldr	r3, [r3, #4]
 80152ee:	69db      	ldr	r3, [r3, #28]
 80152f0:	2b00      	cmp	r3, #0
 80152f2:	d009      	beq.n	8015308 <fsm_rconfreq+0x11c>
		(*f->callbacks->up)(f);	/* Inform upper layers */
 80152f4:	68fb      	ldr	r3, [r7, #12]
 80152f6:	685b      	ldr	r3, [r3, #4]
 80152f8:	69db      	ldr	r3, [r3, #28]
 80152fa:	68fa      	ldr	r2, [r7, #12]
 80152fc:	0010      	movs	r0, r2
 80152fe:	4798      	blx	r3
 8015300:	e002      	b.n	8015308 <fsm_rconfreq+0x11c>
	} else
	    f->state = PPP_FSM_ACKSENT;
 8015302:	68fb      	ldr	r3, [r7, #12]
 8015304:	2208      	movs	r2, #8
 8015306:	741a      	strb	r2, [r3, #16]
	f->nakloops = 0;
 8015308:	68fb      	ldr	r3, [r7, #12]
 801530a:	2200      	movs	r2, #0
 801530c:	755a      	strb	r2, [r3, #21]
 801530e:	e011      	b.n	8015334 <fsm_rconfreq+0x148>

    } else {
	/* we sent CONFACK or CONFREJ */
	if (f->state != PPP_FSM_ACKRCVD)
 8015310:	68fb      	ldr	r3, [r7, #12]
 8015312:	7c1b      	ldrb	r3, [r3, #16]
 8015314:	2b07      	cmp	r3, #7
 8015316:	d002      	beq.n	801531e <fsm_rconfreq+0x132>
	    f->state = PPP_FSM_REQSENT;
 8015318:	68fb      	ldr	r3, [r7, #12]
 801531a:	2206      	movs	r2, #6
 801531c:	741a      	strb	r2, [r3, #16]
	if( code == CONFNAK )
 801531e:	697b      	ldr	r3, [r7, #20]
 8015320:	2b03      	cmp	r3, #3
 8015322:	d107      	bne.n	8015334 <fsm_rconfreq+0x148>
	    ++f->nakloops;
 8015324:	68fb      	ldr	r3, [r7, #12]
 8015326:	7d5b      	ldrb	r3, [r3, #21]
 8015328:	3301      	adds	r3, #1
 801532a:	b2da      	uxtb	r2, r3
 801532c:	68fb      	ldr	r3, [r7, #12]
 801532e:	755a      	strb	r2, [r3, #21]
 8015330:	e000      	b.n	8015334 <fsm_rconfreq+0x148>
	return;
 8015332:	46c0      	nop			; (mov r8, r8)
    }
}
 8015334:	46bd      	mov	sp, r7
 8015336:	b007      	add	sp, #28
 8015338:	bd90      	pop	{r4, r7, pc}
 801533a:	46c0      	nop			; (mov r8, r8)
 801533c:	08014f3d 	.word	0x08014f3d

08015340 <fsm_rconfack>:


/*
 * fsm_rconfack - Receive Configure-Ack.
 */
static void fsm_rconfack(fsm *f, int id, u_char *inp, int len) {
 8015340:	b580      	push	{r7, lr}
 8015342:	b088      	sub	sp, #32
 8015344:	af02      	add	r7, sp, #8
 8015346:	60f8      	str	r0, [r7, #12]
 8015348:	60b9      	str	r1, [r7, #8]
 801534a:	607a      	str	r2, [r7, #4]
 801534c:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 801534e:	68fb      	ldr	r3, [r7, #12]
 8015350:	681b      	ldr	r3, [r3, #0]
 8015352:	617b      	str	r3, [r7, #20]

    if (id != f->reqid || f->seen_ack)		/* Expected id? */
 8015354:	68fb      	ldr	r3, [r7, #12]
 8015356:	7cdb      	ldrb	r3, [r3, #19]
 8015358:	001a      	movs	r2, r3
 801535a:	68bb      	ldr	r3, [r7, #8]
 801535c:	4293      	cmp	r3, r2
 801535e:	d000      	beq.n	8015362 <fsm_rconfack+0x22>
 8015360:	e07f      	b.n	8015462 <fsm_rconfack+0x122>
 8015362:	68fb      	ldr	r3, [r7, #12]
 8015364:	7b1b      	ldrb	r3, [r3, #12]
 8015366:	2b00      	cmp	r3, #0
 8015368:	d000      	beq.n	801536c <fsm_rconfack+0x2c>
 801536a:	e07a      	b.n	8015462 <fsm_rconfack+0x122>
	return;					/* Nope, toss... */
    if( !(f->callbacks->ackci? (*f->callbacks->ackci)(f, inp, len):
 801536c:	68fb      	ldr	r3, [r7, #12]
 801536e:	685b      	ldr	r3, [r3, #4]
 8015370:	68db      	ldr	r3, [r3, #12]
 8015372:	2b00      	cmp	r3, #0
 8015374:	d00b      	beq.n	801538e <fsm_rconfack+0x4e>
 8015376:	68fb      	ldr	r3, [r7, #12]
 8015378:	685b      	ldr	r3, [r3, #4]
 801537a:	68db      	ldr	r3, [r3, #12]
 801537c:	683a      	ldr	r2, [r7, #0]
 801537e:	6879      	ldr	r1, [r7, #4]
 8015380:	68f8      	ldr	r0, [r7, #12]
 8015382:	4798      	blx	r3
 8015384:	0003      	movs	r3, r0
 8015386:	425a      	negs	r2, r3
 8015388:	4153      	adcs	r3, r2
 801538a:	b2db      	uxtb	r3, r3
 801538c:	e003      	b.n	8015396 <fsm_rconfack+0x56>
 801538e:	683b      	ldr	r3, [r7, #0]
 8015390:	1e5a      	subs	r2, r3, #1
 8015392:	4193      	sbcs	r3, r2
 8015394:	b2db      	uxtb	r3, r3
 8015396:	2b00      	cmp	r3, #0
 8015398:	d006      	beq.n	80153a8 <fsm_rconfack+0x68>
	  (len == 0)) ){
	/* Ack is bad - ignore it */
	ppp_error("Received bad configure-ack: %P", inp, len);
 801539a:	683a      	ldr	r2, [r7, #0]
 801539c:	6879      	ldr	r1, [r7, #4]
 801539e:	4b35      	ldr	r3, [pc, #212]	; (8015474 <fsm_rconfack+0x134>)
 80153a0:	0018      	movs	r0, r3
 80153a2:	f006 fdce 	bl	801bf42 <ppp_error>
	return;
 80153a6:	e061      	b.n	801546c <fsm_rconfack+0x12c>
    }
    f->seen_ack = 1;
 80153a8:	68fb      	ldr	r3, [r7, #12]
 80153aa:	2201      	movs	r2, #1
 80153ac:	731a      	strb	r2, [r3, #12]
    f->rnakloops = 0;
 80153ae:	68fb      	ldr	r3, [r7, #12]
 80153b0:	2200      	movs	r2, #0
 80153b2:	759a      	strb	r2, [r3, #22]

    switch (f->state) {
 80153b4:	68fb      	ldr	r3, [r7, #12]
 80153b6:	7c1b      	ldrb	r3, [r3, #16]
 80153b8:	2b09      	cmp	r3, #9
 80153ba:	d854      	bhi.n	8015466 <fsm_rconfack+0x126>
 80153bc:	009a      	lsls	r2, r3, #2
 80153be:	4b2e      	ldr	r3, [pc, #184]	; (8015478 <fsm_rconfack+0x138>)
 80153c0:	18d3      	adds	r3, r2, r3
 80153c2:	681b      	ldr	r3, [r3, #0]
 80153c4:	469f      	mov	pc, r3
    case PPP_FSM_CLOSED:
    case PPP_FSM_STOPPED:
	fsm_sdata(f, TERMACK, id, NULL, 0);
 80153c6:	68bb      	ldr	r3, [r7, #8]
 80153c8:	b2da      	uxtb	r2, r3
 80153ca:	68f8      	ldr	r0, [r7, #12]
 80153cc:	2300      	movs	r3, #0
 80153ce:	9300      	str	r3, [sp, #0]
 80153d0:	2300      	movs	r3, #0
 80153d2:	2106      	movs	r1, #6
 80153d4:	f000 fb3a 	bl	8015a4c <fsm_sdata>
	break;
 80153d8:	e048      	b.n	801546c <fsm_rconfack+0x12c>

    case PPP_FSM_REQSENT:
	f->state = PPP_FSM_ACKRCVD;
 80153da:	68fb      	ldr	r3, [r7, #12]
 80153dc:	2207      	movs	r2, #7
 80153de:	741a      	strb	r2, [r3, #16]
	f->retransmits = pcb->settings.fsm_max_conf_req_transmits;
 80153e0:	697b      	ldr	r3, [r7, #20]
 80153e2:	795a      	ldrb	r2, [r3, #5]
 80153e4:	68fb      	ldr	r3, [r7, #12]
 80153e6:	751a      	strb	r2, [r3, #20]
	break;
 80153e8:	e040      	b.n	801546c <fsm_rconfack+0x12c>

    case PPP_FSM_ACKRCVD:
	/* Huh? an extra valid Ack? oh well... */
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 80153ea:	68fa      	ldr	r2, [r7, #12]
 80153ec:	4b23      	ldr	r3, [pc, #140]	; (801547c <fsm_rconfack+0x13c>)
 80153ee:	0011      	movs	r1, r2
 80153f0:	0018      	movs	r0, r3
 80153f2:	f7fd fb5f 	bl	8012ab4 <sys_untimeout>
	fsm_sconfreq(f, 0);
 80153f6:	68fb      	ldr	r3, [r7, #12]
 80153f8:	2100      	movs	r1, #0
 80153fa:	0018      	movs	r0, r3
 80153fc:	f000 fa30 	bl	8015860 <fsm_sconfreq>
	f->state = PPP_FSM_REQSENT;
 8015400:	68fb      	ldr	r3, [r7, #12]
 8015402:	2206      	movs	r2, #6
 8015404:	741a      	strb	r2, [r3, #16]
	break;
 8015406:	e031      	b.n	801546c <fsm_rconfack+0x12c>

    case PPP_FSM_ACKSENT:
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 8015408:	68fa      	ldr	r2, [r7, #12]
 801540a:	4b1c      	ldr	r3, [pc, #112]	; (801547c <fsm_rconfack+0x13c>)
 801540c:	0011      	movs	r1, r2
 801540e:	0018      	movs	r0, r3
 8015410:	f7fd fb50 	bl	8012ab4 <sys_untimeout>
	f->state = PPP_FSM_OPENED;
 8015414:	68fb      	ldr	r3, [r7, #12]
 8015416:	2209      	movs	r2, #9
 8015418:	741a      	strb	r2, [r3, #16]
	f->retransmits = pcb->settings.fsm_max_conf_req_transmits;
 801541a:	697b      	ldr	r3, [r7, #20]
 801541c:	795a      	ldrb	r2, [r3, #5]
 801541e:	68fb      	ldr	r3, [r7, #12]
 8015420:	751a      	strb	r2, [r3, #20]
	if (f->callbacks->up)
 8015422:	68fb      	ldr	r3, [r7, #12]
 8015424:	685b      	ldr	r3, [r3, #4]
 8015426:	69db      	ldr	r3, [r3, #28]
 8015428:	2b00      	cmp	r3, #0
 801542a:	d01e      	beq.n	801546a <fsm_rconfack+0x12a>
	    (*f->callbacks->up)(f);	/* Inform upper layers */
 801542c:	68fb      	ldr	r3, [r7, #12]
 801542e:	685b      	ldr	r3, [r3, #4]
 8015430:	69db      	ldr	r3, [r3, #28]
 8015432:	68fa      	ldr	r2, [r7, #12]
 8015434:	0010      	movs	r0, r2
 8015436:	4798      	blx	r3
	break;
 8015438:	e017      	b.n	801546a <fsm_rconfack+0x12a>

    case PPP_FSM_OPENED:
	/* Go down and restart negotiation */
	if (f->callbacks->down)
 801543a:	68fb      	ldr	r3, [r7, #12]
 801543c:	685b      	ldr	r3, [r3, #4]
 801543e:	6a1b      	ldr	r3, [r3, #32]
 8015440:	2b00      	cmp	r3, #0
 8015442:	d005      	beq.n	8015450 <fsm_rconfack+0x110>
	    (*f->callbacks->down)(f);	/* Inform upper layers */
 8015444:	68fb      	ldr	r3, [r7, #12]
 8015446:	685b      	ldr	r3, [r3, #4]
 8015448:	6a1b      	ldr	r3, [r3, #32]
 801544a:	68fa      	ldr	r2, [r7, #12]
 801544c:	0010      	movs	r0, r2
 801544e:	4798      	blx	r3
	fsm_sconfreq(f, 0);		/* Send initial Configure-Request */
 8015450:	68fb      	ldr	r3, [r7, #12]
 8015452:	2100      	movs	r1, #0
 8015454:	0018      	movs	r0, r3
 8015456:	f000 fa03 	bl	8015860 <fsm_sconfreq>
	f->state = PPP_FSM_REQSENT;
 801545a:	68fb      	ldr	r3, [r7, #12]
 801545c:	2206      	movs	r2, #6
 801545e:	741a      	strb	r2, [r3, #16]
	break;
 8015460:	e004      	b.n	801546c <fsm_rconfack+0x12c>
	return;					/* Nope, toss... */
 8015462:	46c0      	nop			; (mov r8, r8)
 8015464:	e002      	b.n	801546c <fsm_rconfack+0x12c>
    default:
	break;
 8015466:	46c0      	nop			; (mov r8, r8)
 8015468:	e000      	b.n	801546c <fsm_rconfack+0x12c>
	break;
 801546a:	46c0      	nop			; (mov r8, r8)
    }
}
 801546c:	46bd      	mov	sp, r7
 801546e:	b006      	add	sp, #24
 8015470:	bd80      	pop	{r7, pc}
 8015472:	46c0      	nop			; (mov r8, r8)
 8015474:	08022678 	.word	0x08022678
 8015478:	08023b18 	.word	0x08023b18
 801547c:	08014f3d 	.word	0x08014f3d

08015480 <fsm_rconfnakrej>:


/*
 * fsm_rconfnakrej - Receive Configure-Nak or Configure-Reject.
 */
static void fsm_rconfnakrej(fsm *f, int code, int id, u_char *inp, int len) {
 8015480:	b590      	push	{r4, r7, lr}
 8015482:	b089      	sub	sp, #36	; 0x24
 8015484:	af02      	add	r7, sp, #8
 8015486:	60f8      	str	r0, [r7, #12]
 8015488:	60b9      	str	r1, [r7, #8]
 801548a:	607a      	str	r2, [r7, #4]
 801548c:	603b      	str	r3, [r7, #0]
    int ret;
    int treat_as_reject;

    if (id != f->reqid || f->seen_ack)	/* Expected id? */
 801548e:	68fb      	ldr	r3, [r7, #12]
 8015490:	7cdb      	ldrb	r3, [r3, #19]
 8015492:	001a      	movs	r2, r3
 8015494:	687b      	ldr	r3, [r7, #4]
 8015496:	4293      	cmp	r3, r2
 8015498:	d000      	beq.n	801549c <fsm_rconfnakrej+0x1c>
 801549a:	e096      	b.n	80155ca <fsm_rconfnakrej+0x14a>
 801549c:	68fb      	ldr	r3, [r7, #12]
 801549e:	7b1b      	ldrb	r3, [r3, #12]
 80154a0:	2b00      	cmp	r3, #0
 80154a2:	d000      	beq.n	80154a6 <fsm_rconfnakrej+0x26>
 80154a4:	e091      	b.n	80155ca <fsm_rconfnakrej+0x14a>
	return;				/* Nope, toss... */

    if (code == CONFNAK) {
 80154a6:	68bb      	ldr	r3, [r7, #8]
 80154a8:	2b03      	cmp	r3, #3
 80154aa:	d127      	bne.n	80154fc <fsm_rconfnakrej+0x7c>
	++f->rnakloops;
 80154ac:	68fb      	ldr	r3, [r7, #12]
 80154ae:	7d9b      	ldrb	r3, [r3, #22]
 80154b0:	3301      	adds	r3, #1
 80154b2:	b2da      	uxtb	r2, r3
 80154b4:	68fb      	ldr	r3, [r7, #12]
 80154b6:	759a      	strb	r2, [r3, #22]
	treat_as_reject = (f->rnakloops >= f->maxnakloops);
 80154b8:	68fb      	ldr	r3, [r7, #12]
 80154ba:	7d99      	ldrb	r1, [r3, #22]
 80154bc:	68fb      	ldr	r3, [r7, #12]
 80154be:	7dda      	ldrb	r2, [r3, #23]
 80154c0:	2300      	movs	r3, #0
 80154c2:	4291      	cmp	r1, r2
 80154c4:	415b      	adcs	r3, r3
 80154c6:	b2db      	uxtb	r3, r3
 80154c8:	613b      	str	r3, [r7, #16]
	if (f->callbacks->nakci == NULL
 80154ca:	68fb      	ldr	r3, [r7, #12]
 80154cc:	685b      	ldr	r3, [r3, #4]
 80154ce:	691b      	ldr	r3, [r3, #16]
 80154d0:	2b00      	cmp	r3, #0
 80154d2:	d00c      	beq.n	80154ee <fsm_rconfnakrej+0x6e>
	    || !(ret = f->callbacks->nakci(f, inp, len, treat_as_reject))) {
 80154d4:	68fb      	ldr	r3, [r7, #12]
 80154d6:	685b      	ldr	r3, [r3, #4]
 80154d8:	691c      	ldr	r4, [r3, #16]
 80154da:	693b      	ldr	r3, [r7, #16]
 80154dc:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80154de:	6839      	ldr	r1, [r7, #0]
 80154e0:	68f8      	ldr	r0, [r7, #12]
 80154e2:	47a0      	blx	r4
 80154e4:	0003      	movs	r3, r0
 80154e6:	617b      	str	r3, [r7, #20]
 80154e8:	697b      	ldr	r3, [r7, #20]
 80154ea:	2b00      	cmp	r3, #0
 80154ec:	d121      	bne.n	8015532 <fsm_rconfnakrej+0xb2>
	    ppp_error("Received bad configure-nak: %P", inp, len);
 80154ee:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80154f0:	6839      	ldr	r1, [r7, #0]
 80154f2:	4b39      	ldr	r3, [pc, #228]	; (80155d8 <fsm_rconfnakrej+0x158>)
 80154f4:	0018      	movs	r0, r3
 80154f6:	f006 fd24 	bl	801bf42 <ppp_error>
	    return;
 80154fa:	e069      	b.n	80155d0 <fsm_rconfnakrej+0x150>
	}
    } else {
	f->rnakloops = 0;
 80154fc:	68fb      	ldr	r3, [r7, #12]
 80154fe:	2200      	movs	r2, #0
 8015500:	759a      	strb	r2, [r3, #22]
	if (f->callbacks->rejci == NULL
 8015502:	68fb      	ldr	r3, [r7, #12]
 8015504:	685b      	ldr	r3, [r3, #4]
 8015506:	695b      	ldr	r3, [r3, #20]
 8015508:	2b00      	cmp	r3, #0
 801550a:	d00b      	beq.n	8015524 <fsm_rconfnakrej+0xa4>
	    || !(ret = f->callbacks->rejci(f, inp, len))) {
 801550c:	68fb      	ldr	r3, [r7, #12]
 801550e:	685b      	ldr	r3, [r3, #4]
 8015510:	695b      	ldr	r3, [r3, #20]
 8015512:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8015514:	6839      	ldr	r1, [r7, #0]
 8015516:	68f8      	ldr	r0, [r7, #12]
 8015518:	4798      	blx	r3
 801551a:	0003      	movs	r3, r0
 801551c:	617b      	str	r3, [r7, #20]
 801551e:	697b      	ldr	r3, [r7, #20]
 8015520:	2b00      	cmp	r3, #0
 8015522:	d106      	bne.n	8015532 <fsm_rconfnakrej+0xb2>
	    ppp_error("Received bad configure-rej: %P", inp, len);
 8015524:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8015526:	6839      	ldr	r1, [r7, #0]
 8015528:	4b2c      	ldr	r3, [pc, #176]	; (80155dc <fsm_rconfnakrej+0x15c>)
 801552a:	0018      	movs	r0, r3
 801552c:	f006 fd09 	bl	801bf42 <ppp_error>
	    return;
 8015530:	e04e      	b.n	80155d0 <fsm_rconfnakrej+0x150>
	}
    }

    f->seen_ack = 1;
 8015532:	68fb      	ldr	r3, [r7, #12]
 8015534:	2201      	movs	r2, #1
 8015536:	731a      	strb	r2, [r3, #12]

    switch (f->state) {
 8015538:	68fb      	ldr	r3, [r7, #12]
 801553a:	7c1b      	ldrb	r3, [r3, #16]
 801553c:	2b09      	cmp	r3, #9
 801553e:	d846      	bhi.n	80155ce <fsm_rconfnakrej+0x14e>
 8015540:	009a      	lsls	r2, r3, #2
 8015542:	4b27      	ldr	r3, [pc, #156]	; (80155e0 <fsm_rconfnakrej+0x160>)
 8015544:	18d3      	adds	r3, r2, r3
 8015546:	681b      	ldr	r3, [r3, #0]
 8015548:	469f      	mov	pc, r3
    case PPP_FSM_CLOSED:
    case PPP_FSM_STOPPED:
	fsm_sdata(f, TERMACK, id, NULL, 0);
 801554a:	687b      	ldr	r3, [r7, #4]
 801554c:	b2da      	uxtb	r2, r3
 801554e:	68f8      	ldr	r0, [r7, #12]
 8015550:	2300      	movs	r3, #0
 8015552:	9300      	str	r3, [sp, #0]
 8015554:	2300      	movs	r3, #0
 8015556:	2106      	movs	r1, #6
 8015558:	f000 fa78 	bl	8015a4c <fsm_sdata>
	break;
 801555c:	e038      	b.n	80155d0 <fsm_rconfnakrej+0x150>

    case PPP_FSM_REQSENT:
    case PPP_FSM_ACKSENT:
	/* They didn't agree to what we wanted - try another request */
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 801555e:	68fa      	ldr	r2, [r7, #12]
 8015560:	4b20      	ldr	r3, [pc, #128]	; (80155e4 <fsm_rconfnakrej+0x164>)
 8015562:	0011      	movs	r1, r2
 8015564:	0018      	movs	r0, r3
 8015566:	f7fd faa5 	bl	8012ab4 <sys_untimeout>
	if (ret < 0)
 801556a:	697b      	ldr	r3, [r7, #20]
 801556c:	2b00      	cmp	r3, #0
 801556e:	da03      	bge.n	8015578 <fsm_rconfnakrej+0xf8>
	    f->state = PPP_FSM_STOPPED;		/* kludge for stopping CCP */
 8015570:	68fb      	ldr	r3, [r7, #12]
 8015572:	2203      	movs	r2, #3
 8015574:	741a      	strb	r2, [r3, #16]
	else
	    fsm_sconfreq(f, 0);		/* Send Configure-Request */
	break;
 8015576:	e02b      	b.n	80155d0 <fsm_rconfnakrej+0x150>
	    fsm_sconfreq(f, 0);		/* Send Configure-Request */
 8015578:	68fb      	ldr	r3, [r7, #12]
 801557a:	2100      	movs	r1, #0
 801557c:	0018      	movs	r0, r3
 801557e:	f000 f96f 	bl	8015860 <fsm_sconfreq>
	break;
 8015582:	e025      	b.n	80155d0 <fsm_rconfnakrej+0x150>

    case PPP_FSM_ACKRCVD:
	/* Got a Nak/reject when we had already had an Ack?? oh well... */
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 8015584:	68fa      	ldr	r2, [r7, #12]
 8015586:	4b17      	ldr	r3, [pc, #92]	; (80155e4 <fsm_rconfnakrej+0x164>)
 8015588:	0011      	movs	r1, r2
 801558a:	0018      	movs	r0, r3
 801558c:	f7fd fa92 	bl	8012ab4 <sys_untimeout>
	fsm_sconfreq(f, 0);
 8015590:	68fb      	ldr	r3, [r7, #12]
 8015592:	2100      	movs	r1, #0
 8015594:	0018      	movs	r0, r3
 8015596:	f000 f963 	bl	8015860 <fsm_sconfreq>
	f->state = PPP_FSM_REQSENT;
 801559a:	68fb      	ldr	r3, [r7, #12]
 801559c:	2206      	movs	r2, #6
 801559e:	741a      	strb	r2, [r3, #16]
	break;
 80155a0:	e016      	b.n	80155d0 <fsm_rconfnakrej+0x150>

    case PPP_FSM_OPENED:
	/* Go down and restart negotiation */
	if (f->callbacks->down)
 80155a2:	68fb      	ldr	r3, [r7, #12]
 80155a4:	685b      	ldr	r3, [r3, #4]
 80155a6:	6a1b      	ldr	r3, [r3, #32]
 80155a8:	2b00      	cmp	r3, #0
 80155aa:	d005      	beq.n	80155b8 <fsm_rconfnakrej+0x138>
	    (*f->callbacks->down)(f);	/* Inform upper layers */
 80155ac:	68fb      	ldr	r3, [r7, #12]
 80155ae:	685b      	ldr	r3, [r3, #4]
 80155b0:	6a1b      	ldr	r3, [r3, #32]
 80155b2:	68fa      	ldr	r2, [r7, #12]
 80155b4:	0010      	movs	r0, r2
 80155b6:	4798      	blx	r3
	fsm_sconfreq(f, 0);		/* Send initial Configure-Request */
 80155b8:	68fb      	ldr	r3, [r7, #12]
 80155ba:	2100      	movs	r1, #0
 80155bc:	0018      	movs	r0, r3
 80155be:	f000 f94f 	bl	8015860 <fsm_sconfreq>
	f->state = PPP_FSM_REQSENT;
 80155c2:	68fb      	ldr	r3, [r7, #12]
 80155c4:	2206      	movs	r2, #6
 80155c6:	741a      	strb	r2, [r3, #16]
	break;
 80155c8:	e002      	b.n	80155d0 <fsm_rconfnakrej+0x150>
	return;				/* Nope, toss... */
 80155ca:	46c0      	nop			; (mov r8, r8)
 80155cc:	e000      	b.n	80155d0 <fsm_rconfnakrej+0x150>
    default:
	break;
 80155ce:	46c0      	nop			; (mov r8, r8)
    }
}
 80155d0:	46bd      	mov	sp, r7
 80155d2:	b007      	add	sp, #28
 80155d4:	bd90      	pop	{r4, r7, pc}
 80155d6:	46c0      	nop			; (mov r8, r8)
 80155d8:	08022698 	.word	0x08022698
 80155dc:	080226b8 	.word	0x080226b8
 80155e0:	08023b40 	.word	0x08023b40
 80155e4:	08014f3d 	.word	0x08014f3d

080155e8 <fsm_rtermreq>:


/*
 * fsm_rtermreq - Receive Terminate-Req.
 */
static void fsm_rtermreq(fsm *f, int id, u_char *p, int len) {
 80155e8:	b580      	push	{r7, lr}
 80155ea:	b088      	sub	sp, #32
 80155ec:	af02      	add	r7, sp, #8
 80155ee:	60f8      	str	r0, [r7, #12]
 80155f0:	60b9      	str	r1, [r7, #8]
 80155f2:	607a      	str	r2, [r7, #4]
 80155f4:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 80155f6:	68fb      	ldr	r3, [r7, #12]
 80155f8:	681b      	ldr	r3, [r3, #0]
 80155fa:	617b      	str	r3, [r7, #20]

    switch (f->state) {
 80155fc:	68fb      	ldr	r3, [r7, #12]
 80155fe:	7c1b      	ldrb	r3, [r3, #16]
 8015600:	2b08      	cmp	r3, #8
 8015602:	dc02      	bgt.n	801560a <fsm_rtermreq+0x22>
 8015604:	2b07      	cmp	r3, #7
 8015606:	da03      	bge.n	8015610 <fsm_rtermreq+0x28>
	if (f->callbacks->down)
	    (*f->callbacks->down)(f);	/* Inform upper layers */
	TIMEOUT(fsm_timeout, f, pcb->settings.fsm_timeout_time);
	break;
    default:
	break;
 8015608:	e041      	b.n	801568e <fsm_rtermreq+0xa6>
    switch (f->state) {
 801560a:	2b09      	cmp	r3, #9
 801560c:	d004      	beq.n	8015618 <fsm_rtermreq+0x30>
	break;
 801560e:	e03e      	b.n	801568e <fsm_rtermreq+0xa6>
	f->state = PPP_FSM_REQSENT;		/* Start over but keep trying */
 8015610:	68fb      	ldr	r3, [r7, #12]
 8015612:	2206      	movs	r2, #6
 8015614:	741a      	strb	r2, [r3, #16]
	break;
 8015616:	e03a      	b.n	801568e <fsm_rtermreq+0xa6>
	if (len > 0) {
 8015618:	683b      	ldr	r3, [r7, #0]
 801561a:	2b00      	cmp	r3, #0
 801561c:	dd08      	ble.n	8015630 <fsm_rtermreq+0x48>
	    ppp_info("%s terminated by peer (%0.*v)", PROTO_NAME(f), len, p);
 801561e:	68fb      	ldr	r3, [r7, #12]
 8015620:	685b      	ldr	r3, [r3, #4]
 8015622:	6b99      	ldr	r1, [r3, #56]	; 0x38
 8015624:	687b      	ldr	r3, [r7, #4]
 8015626:	683a      	ldr	r2, [r7, #0]
 8015628:	481f      	ldr	r0, [pc, #124]	; (80156a8 <fsm_rtermreq+0xc0>)
 801562a:	f006 fcc6 	bl	801bfba <ppp_info>
 801562e:	e007      	b.n	8015640 <fsm_rtermreq+0x58>
	    ppp_info("%s terminated by peer", PROTO_NAME(f));
 8015630:	68fb      	ldr	r3, [r7, #12]
 8015632:	685b      	ldr	r3, [r3, #4]
 8015634:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8015636:	4b1d      	ldr	r3, [pc, #116]	; (80156ac <fsm_rtermreq+0xc4>)
 8015638:	0011      	movs	r1, r2
 801563a:	0018      	movs	r0, r3
 801563c:	f006 fcbd 	bl	801bfba <ppp_info>
	f->retransmits = 0;
 8015640:	68fb      	ldr	r3, [r7, #12]
 8015642:	2200      	movs	r2, #0
 8015644:	751a      	strb	r2, [r3, #20]
	f->state = PPP_FSM_STOPPING;
 8015646:	68fb      	ldr	r3, [r7, #12]
 8015648:	2205      	movs	r2, #5
 801564a:	741a      	strb	r2, [r3, #16]
	if (f->callbacks->down)
 801564c:	68fb      	ldr	r3, [r7, #12]
 801564e:	685b      	ldr	r3, [r3, #4]
 8015650:	6a1b      	ldr	r3, [r3, #32]
 8015652:	2b00      	cmp	r3, #0
 8015654:	d005      	beq.n	8015662 <fsm_rtermreq+0x7a>
	    (*f->callbacks->down)(f);	/* Inform upper layers */
 8015656:	68fb      	ldr	r3, [r7, #12]
 8015658:	685b      	ldr	r3, [r3, #4]
 801565a:	6a1b      	ldr	r3, [r3, #32]
 801565c:	68fa      	ldr	r2, [r7, #12]
 801565e:	0010      	movs	r0, r2
 8015660:	4798      	blx	r3
	TIMEOUT(fsm_timeout, f, pcb->settings.fsm_timeout_time);
 8015662:	68fa      	ldr	r2, [r7, #12]
 8015664:	4b12      	ldr	r3, [pc, #72]	; (80156b0 <fsm_rtermreq+0xc8>)
 8015666:	0011      	movs	r1, r2
 8015668:	0018      	movs	r0, r3
 801566a:	f7fd fa23 	bl	8012ab4 <sys_untimeout>
 801566e:	697b      	ldr	r3, [r7, #20]
 8015670:	791b      	ldrb	r3, [r3, #4]
 8015672:	001a      	movs	r2, r3
 8015674:	0013      	movs	r3, r2
 8015676:	015b      	lsls	r3, r3, #5
 8015678:	1a9b      	subs	r3, r3, r2
 801567a:	009b      	lsls	r3, r3, #2
 801567c:	189b      	adds	r3, r3, r2
 801567e:	00db      	lsls	r3, r3, #3
 8015680:	0018      	movs	r0, r3
 8015682:	68fa      	ldr	r2, [r7, #12]
 8015684:	4b0a      	ldr	r3, [pc, #40]	; (80156b0 <fsm_rtermreq+0xc8>)
 8015686:	0019      	movs	r1, r3
 8015688:	f7fd f9ec 	bl	8012a64 <sys_timeout>
	break;
 801568c:	46c0      	nop			; (mov r8, r8)
    }

    fsm_sdata(f, TERMACK, id, NULL, 0);
 801568e:	68bb      	ldr	r3, [r7, #8]
 8015690:	b2da      	uxtb	r2, r3
 8015692:	68f8      	ldr	r0, [r7, #12]
 8015694:	2300      	movs	r3, #0
 8015696:	9300      	str	r3, [sp, #0]
 8015698:	2300      	movs	r3, #0
 801569a:	2106      	movs	r1, #6
 801569c:	f000 f9d6 	bl	8015a4c <fsm_sdata>
}
 80156a0:	46c0      	nop			; (mov r8, r8)
 80156a2:	46bd      	mov	sp, r7
 80156a4:	b006      	add	sp, #24
 80156a6:	bd80      	pop	{r7, pc}
 80156a8:	080226d8 	.word	0x080226d8
 80156ac:	080226f8 	.word	0x080226f8
 80156b0:	08014f3d 	.word	0x08014f3d

080156b4 <fsm_rtermack>:


/*
 * fsm_rtermack - Receive Terminate-Ack.
 */
static void fsm_rtermack(fsm *f) {
 80156b4:	b580      	push	{r7, lr}
 80156b6:	b082      	sub	sp, #8
 80156b8:	af00      	add	r7, sp, #0
 80156ba:	6078      	str	r0, [r7, #4]
    switch (f->state) {
 80156bc:	687b      	ldr	r3, [r7, #4]
 80156be:	7c1b      	ldrb	r3, [r3, #16]
 80156c0:	2b09      	cmp	r3, #9
 80156c2:	d036      	beq.n	8015732 <fsm_rtermack+0x7e>
 80156c4:	dc49      	bgt.n	801575a <fsm_rtermack+0xa6>
 80156c6:	2b07      	cmp	r3, #7
 80156c8:	d02f      	beq.n	801572a <fsm_rtermack+0x76>
 80156ca:	dc46      	bgt.n	801575a <fsm_rtermack+0xa6>
 80156cc:	2b04      	cmp	r3, #4
 80156ce:	d002      	beq.n	80156d6 <fsm_rtermack+0x22>
 80156d0:	2b05      	cmp	r3, #5
 80156d2:	d015      	beq.n	8015700 <fsm_rtermack+0x4c>
	    (*f->callbacks->down)(f);	/* Inform upper layers */
	fsm_sconfreq(f, 0);
	f->state = PPP_FSM_REQSENT;
	break;
    default:
	break;
 80156d4:	e041      	b.n	801575a <fsm_rtermack+0xa6>
	UNTIMEOUT(fsm_timeout, f);
 80156d6:	687a      	ldr	r2, [r7, #4]
 80156d8:	4b24      	ldr	r3, [pc, #144]	; (801576c <fsm_rtermack+0xb8>)
 80156da:	0011      	movs	r1, r2
 80156dc:	0018      	movs	r0, r3
 80156de:	f7fd f9e9 	bl	8012ab4 <sys_untimeout>
	f->state = PPP_FSM_CLOSED;
 80156e2:	687b      	ldr	r3, [r7, #4]
 80156e4:	2202      	movs	r2, #2
 80156e6:	741a      	strb	r2, [r3, #16]
	if( f->callbacks->finished )
 80156e8:	687b      	ldr	r3, [r7, #4]
 80156ea:	685b      	ldr	r3, [r3, #4]
 80156ec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80156ee:	2b00      	cmp	r3, #0
 80156f0:	d035      	beq.n	801575e <fsm_rtermack+0xaa>
	    (*f->callbacks->finished)(f);
 80156f2:	687b      	ldr	r3, [r7, #4]
 80156f4:	685b      	ldr	r3, [r3, #4]
 80156f6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80156f8:	687a      	ldr	r2, [r7, #4]
 80156fa:	0010      	movs	r0, r2
 80156fc:	4798      	blx	r3
	break;
 80156fe:	e02e      	b.n	801575e <fsm_rtermack+0xaa>
	UNTIMEOUT(fsm_timeout, f);
 8015700:	687a      	ldr	r2, [r7, #4]
 8015702:	4b1a      	ldr	r3, [pc, #104]	; (801576c <fsm_rtermack+0xb8>)
 8015704:	0011      	movs	r1, r2
 8015706:	0018      	movs	r0, r3
 8015708:	f7fd f9d4 	bl	8012ab4 <sys_untimeout>
	f->state = PPP_FSM_STOPPED;
 801570c:	687b      	ldr	r3, [r7, #4]
 801570e:	2203      	movs	r2, #3
 8015710:	741a      	strb	r2, [r3, #16]
	if( f->callbacks->finished )
 8015712:	687b      	ldr	r3, [r7, #4]
 8015714:	685b      	ldr	r3, [r3, #4]
 8015716:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8015718:	2b00      	cmp	r3, #0
 801571a:	d022      	beq.n	8015762 <fsm_rtermack+0xae>
	    (*f->callbacks->finished)(f);
 801571c:	687b      	ldr	r3, [r7, #4]
 801571e:	685b      	ldr	r3, [r3, #4]
 8015720:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8015722:	687a      	ldr	r2, [r7, #4]
 8015724:	0010      	movs	r0, r2
 8015726:	4798      	blx	r3
	break;
 8015728:	e01b      	b.n	8015762 <fsm_rtermack+0xae>
	f->state = PPP_FSM_REQSENT;
 801572a:	687b      	ldr	r3, [r7, #4]
 801572c:	2206      	movs	r2, #6
 801572e:	741a      	strb	r2, [r3, #16]
	break;
 8015730:	e018      	b.n	8015764 <fsm_rtermack+0xb0>
	if (f->callbacks->down)
 8015732:	687b      	ldr	r3, [r7, #4]
 8015734:	685b      	ldr	r3, [r3, #4]
 8015736:	6a1b      	ldr	r3, [r3, #32]
 8015738:	2b00      	cmp	r3, #0
 801573a:	d005      	beq.n	8015748 <fsm_rtermack+0x94>
	    (*f->callbacks->down)(f);	/* Inform upper layers */
 801573c:	687b      	ldr	r3, [r7, #4]
 801573e:	685b      	ldr	r3, [r3, #4]
 8015740:	6a1b      	ldr	r3, [r3, #32]
 8015742:	687a      	ldr	r2, [r7, #4]
 8015744:	0010      	movs	r0, r2
 8015746:	4798      	blx	r3
	fsm_sconfreq(f, 0);
 8015748:	687b      	ldr	r3, [r7, #4]
 801574a:	2100      	movs	r1, #0
 801574c:	0018      	movs	r0, r3
 801574e:	f000 f887 	bl	8015860 <fsm_sconfreq>
	f->state = PPP_FSM_REQSENT;
 8015752:	687b      	ldr	r3, [r7, #4]
 8015754:	2206      	movs	r2, #6
 8015756:	741a      	strb	r2, [r3, #16]
	break;
 8015758:	e004      	b.n	8015764 <fsm_rtermack+0xb0>
	break;
 801575a:	46c0      	nop			; (mov r8, r8)
 801575c:	e002      	b.n	8015764 <fsm_rtermack+0xb0>
	break;
 801575e:	46c0      	nop			; (mov r8, r8)
 8015760:	e000      	b.n	8015764 <fsm_rtermack+0xb0>
	break;
 8015762:	46c0      	nop			; (mov r8, r8)
    }
}
 8015764:	46c0      	nop			; (mov r8, r8)
 8015766:	46bd      	mov	sp, r7
 8015768:	b002      	add	sp, #8
 801576a:	bd80      	pop	{r7, pc}
 801576c:	08014f3d 	.word	0x08014f3d

08015770 <fsm_rcoderej>:


/*
 * fsm_rcoderej - Receive an Code-Reject.
 */
static void fsm_rcoderej(fsm *f, u_char *inp, int len) {
 8015770:	b590      	push	{r4, r7, lr}
 8015772:	b087      	sub	sp, #28
 8015774:	af00      	add	r7, sp, #0
 8015776:	60f8      	str	r0, [r7, #12]
 8015778:	60b9      	str	r1, [r7, #8]
 801577a:	607a      	str	r2, [r7, #4]
    u_char code, id;

    if (len < HEADERLEN) {
 801577c:	687b      	ldr	r3, [r7, #4]
 801577e:	2b03      	cmp	r3, #3
 8015780:	dd1f      	ble.n	80157c2 <fsm_rcoderej+0x52>
	FSMDEBUG(("fsm_rcoderej: Rcvd short Code-Reject packet!"));
	return;
    }
    GETCHAR(code, inp);
 8015782:	68bb      	ldr	r3, [r7, #8]
 8015784:	1c5a      	adds	r2, r3, #1
 8015786:	60ba      	str	r2, [r7, #8]
 8015788:	2017      	movs	r0, #23
 801578a:	183a      	adds	r2, r7, r0
 801578c:	781b      	ldrb	r3, [r3, #0]
 801578e:	7013      	strb	r3, [r2, #0]
    GETCHAR(id, inp);
 8015790:	68bb      	ldr	r3, [r7, #8]
 8015792:	1c5a      	adds	r2, r3, #1
 8015794:	60ba      	str	r2, [r7, #8]
 8015796:	2416      	movs	r4, #22
 8015798:	193a      	adds	r2, r7, r4
 801579a:	781b      	ldrb	r3, [r3, #0]
 801579c:	7013      	strb	r3, [r2, #0]
    ppp_warn("%s: Rcvd Code-Reject for code %d, id %d", PROTO_NAME(f), code, id);
 801579e:	68fb      	ldr	r3, [r7, #12]
 80157a0:	685b      	ldr	r3, [r3, #4]
 80157a2:	6b99      	ldr	r1, [r3, #56]	; 0x38
 80157a4:	183b      	adds	r3, r7, r0
 80157a6:	781a      	ldrb	r2, [r3, #0]
 80157a8:	193b      	adds	r3, r7, r4
 80157aa:	781b      	ldrb	r3, [r3, #0]
 80157ac:	4807      	ldr	r0, [pc, #28]	; (80157cc <fsm_rcoderej+0x5c>)
 80157ae:	f006 fbdc 	bl	801bf6a <ppp_warn>

    if( f->state == PPP_FSM_ACKRCVD )
 80157b2:	68fb      	ldr	r3, [r7, #12]
 80157b4:	7c1b      	ldrb	r3, [r3, #16]
 80157b6:	2b07      	cmp	r3, #7
 80157b8:	d104      	bne.n	80157c4 <fsm_rcoderej+0x54>
	f->state = PPP_FSM_REQSENT;
 80157ba:	68fb      	ldr	r3, [r7, #12]
 80157bc:	2206      	movs	r2, #6
 80157be:	741a      	strb	r2, [r3, #16]
 80157c0:	e000      	b.n	80157c4 <fsm_rcoderej+0x54>
	return;
 80157c2:	46c0      	nop			; (mov r8, r8)
}
 80157c4:	46bd      	mov	sp, r7
 80157c6:	b007      	add	sp, #28
 80157c8:	bd90      	pop	{r4, r7, pc}
 80157ca:	46c0      	nop			; (mov r8, r8)
 80157cc:	08022710 	.word	0x08022710

080157d0 <fsm_protreject>:
/*
 * fsm_protreject - Peer doesn't speak this protocol.
 *
 * Treat this as a catastrophic error (RXJ-).
 */
void fsm_protreject(fsm *f) {
 80157d0:	b580      	push	{r7, lr}
 80157d2:	b082      	sub	sp, #8
 80157d4:	af00      	add	r7, sp, #0
 80157d6:	6078      	str	r0, [r7, #4]
    switch( f->state ){
 80157d8:	687b      	ldr	r3, [r7, #4]
 80157da:	7c1b      	ldrb	r3, [r3, #16]
 80157dc:	2b09      	cmp	r3, #9
 80157de:	d837      	bhi.n	8015850 <fsm_protreject+0x80>
 80157e0:	009a      	lsls	r2, r3, #2
 80157e2:	4b1d      	ldr	r3, [pc, #116]	; (8015858 <fsm_protreject+0x88>)
 80157e4:	18d3      	adds	r3, r2, r3
 80157e6:	681b      	ldr	r3, [r3, #0]
 80157e8:	469f      	mov	pc, r3
    case PPP_FSM_CLOSING:
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 80157ea:	687a      	ldr	r2, [r7, #4]
 80157ec:	4b1b      	ldr	r3, [pc, #108]	; (801585c <fsm_protreject+0x8c>)
 80157ee:	0011      	movs	r1, r2
 80157f0:	0018      	movs	r0, r3
 80157f2:	f7fd f95f 	bl	8012ab4 <sys_untimeout>
	/* fall through */
	/* no break */
    case PPP_FSM_CLOSED:
	f->state = PPP_FSM_CLOSED;
 80157f6:	687b      	ldr	r3, [r7, #4]
 80157f8:	2202      	movs	r2, #2
 80157fa:	741a      	strb	r2, [r3, #16]
	if( f->callbacks->finished )
 80157fc:	687b      	ldr	r3, [r7, #4]
 80157fe:	685b      	ldr	r3, [r3, #4]
 8015800:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8015802:	2b00      	cmp	r3, #0
 8015804:	d021      	beq.n	801584a <fsm_protreject+0x7a>
	    (*f->callbacks->finished)(f);
 8015806:	687b      	ldr	r3, [r7, #4]
 8015808:	685b      	ldr	r3, [r3, #4]
 801580a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801580c:	687a      	ldr	r2, [r7, #4]
 801580e:	0010      	movs	r0, r2
 8015810:	4798      	blx	r3
	break;
 8015812:	e01a      	b.n	801584a <fsm_protreject+0x7a>

    case PPP_FSM_STOPPING:
    case PPP_FSM_REQSENT:
    case PPP_FSM_ACKRCVD:
    case PPP_FSM_ACKSENT:
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 8015814:	687a      	ldr	r2, [r7, #4]
 8015816:	4b11      	ldr	r3, [pc, #68]	; (801585c <fsm_protreject+0x8c>)
 8015818:	0011      	movs	r1, r2
 801581a:	0018      	movs	r0, r3
 801581c:	f7fd f94a 	bl	8012ab4 <sys_untimeout>
	/* fall through */
	/* no break */
    case PPP_FSM_STOPPED:
	f->state = PPP_FSM_STOPPED;
 8015820:	687b      	ldr	r3, [r7, #4]
 8015822:	2203      	movs	r2, #3
 8015824:	741a      	strb	r2, [r3, #16]
	if( f->callbacks->finished )
 8015826:	687b      	ldr	r3, [r7, #4]
 8015828:	685b      	ldr	r3, [r3, #4]
 801582a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801582c:	2b00      	cmp	r3, #0
 801582e:	d00e      	beq.n	801584e <fsm_protreject+0x7e>
	    (*f->callbacks->finished)(f);
 8015830:	687b      	ldr	r3, [r7, #4]
 8015832:	685b      	ldr	r3, [r3, #4]
 8015834:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8015836:	687a      	ldr	r2, [r7, #4]
 8015838:	0010      	movs	r0, r2
 801583a:	4798      	blx	r3
	break;
 801583c:	e007      	b.n	801584e <fsm_protreject+0x7e>

    case PPP_FSM_OPENED:
	terminate_layer(f, PPP_FSM_STOPPING);
 801583e:	687b      	ldr	r3, [r7, #4]
 8015840:	2105      	movs	r1, #5
 8015842:	0018      	movs	r0, r3
 8015844:	f7ff fac0 	bl	8014dc8 <terminate_layer>
	break;
 8015848:	e002      	b.n	8015850 <fsm_protreject+0x80>
	break;
 801584a:	46c0      	nop			; (mov r8, r8)
 801584c:	e000      	b.n	8015850 <fsm_protreject+0x80>
	break;
 801584e:	46c0      	nop			; (mov r8, r8)
    default:
	FSMDEBUG(("%s: Protocol-reject event in state %d!",
		  PROTO_NAME(f), f->state));
	/* no break */
    }
}
 8015850:	46c0      	nop			; (mov r8, r8)
 8015852:	46bd      	mov	sp, r7
 8015854:	b002      	add	sp, #8
 8015856:	bd80      	pop	{r7, pc}
 8015858:	08023b68 	.word	0x08023b68
 801585c:	08014f3d 	.word	0x08014f3d

08015860 <fsm_sconfreq>:


/*
 * fsm_sconfreq - Send a Configure-Request.
 */
static void fsm_sconfreq(fsm *f, int retransmit) {
 8015860:	b580      	push	{r7, lr}
 8015862:	b086      	sub	sp, #24
 8015864:	af00      	add	r7, sp, #0
 8015866:	6078      	str	r0, [r7, #4]
 8015868:	6039      	str	r1, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 801586a:	687b      	ldr	r3, [r7, #4]
 801586c:	681b      	ldr	r3, [r3, #0]
 801586e:	617b      	str	r3, [r7, #20]
    struct pbuf *p;
    u_char *outp;
    int cilen;

    if( f->state != PPP_FSM_REQSENT && f->state != PPP_FSM_ACKRCVD && f->state != PPP_FSM_ACKSENT ){
 8015870:	687b      	ldr	r3, [r7, #4]
 8015872:	7c1b      	ldrb	r3, [r3, #16]
 8015874:	2b06      	cmp	r3, #6
 8015876:	d018      	beq.n	80158aa <fsm_sconfreq+0x4a>
 8015878:	687b      	ldr	r3, [r7, #4]
 801587a:	7c1b      	ldrb	r3, [r3, #16]
 801587c:	2b07      	cmp	r3, #7
 801587e:	d014      	beq.n	80158aa <fsm_sconfreq+0x4a>
 8015880:	687b      	ldr	r3, [r7, #4]
 8015882:	7c1b      	ldrb	r3, [r3, #16]
 8015884:	2b08      	cmp	r3, #8
 8015886:	d010      	beq.n	80158aa <fsm_sconfreq+0x4a>
	/* Not currently negotiating - reset options */
	if( f->callbacks->resetci )
 8015888:	687b      	ldr	r3, [r7, #4]
 801588a:	685b      	ldr	r3, [r3, #4]
 801588c:	681b      	ldr	r3, [r3, #0]
 801588e:	2b00      	cmp	r3, #0
 8015890:	d005      	beq.n	801589e <fsm_sconfreq+0x3e>
	    (*f->callbacks->resetci)(f);
 8015892:	687b      	ldr	r3, [r7, #4]
 8015894:	685b      	ldr	r3, [r3, #4]
 8015896:	681b      	ldr	r3, [r3, #0]
 8015898:	687a      	ldr	r2, [r7, #4]
 801589a:	0010      	movs	r0, r2
 801589c:	4798      	blx	r3
	f->nakloops = 0;
 801589e:	687b      	ldr	r3, [r7, #4]
 80158a0:	2200      	movs	r2, #0
 80158a2:	755a      	strb	r2, [r3, #21]
	f->rnakloops = 0;
 80158a4:	687b      	ldr	r3, [r7, #4]
 80158a6:	2200      	movs	r2, #0
 80158a8:	759a      	strb	r2, [r3, #22]
    }

    if( !retransmit ){
 80158aa:	683b      	ldr	r3, [r7, #0]
 80158ac:	2b00      	cmp	r3, #0
 80158ae:	d10d      	bne.n	80158cc <fsm_sconfreq+0x6c>
	/* New request - reset retransmission counter, use new ID */
	f->retransmits = pcb->settings.fsm_max_conf_req_transmits;
 80158b0:	697b      	ldr	r3, [r7, #20]
 80158b2:	795a      	ldrb	r2, [r3, #5]
 80158b4:	687b      	ldr	r3, [r7, #4]
 80158b6:	751a      	strb	r2, [r3, #20]
	f->reqid = ++f->id;
 80158b8:	687b      	ldr	r3, [r7, #4]
 80158ba:	7c9b      	ldrb	r3, [r3, #18]
 80158bc:	3301      	adds	r3, #1
 80158be:	b2da      	uxtb	r2, r3
 80158c0:	687b      	ldr	r3, [r7, #4]
 80158c2:	749a      	strb	r2, [r3, #18]
 80158c4:	687b      	ldr	r3, [r7, #4]
 80158c6:	7c9a      	ldrb	r2, [r3, #18]
 80158c8:	687b      	ldr	r3, [r7, #4]
 80158ca:	74da      	strb	r2, [r3, #19]
    }

    f->seen_ack = 0;
 80158cc:	687b      	ldr	r3, [r7, #4]
 80158ce:	2200      	movs	r2, #0
 80158d0:	731a      	strb	r2, [r3, #12]

    /*
     * Make up the request packet
     */
    if( f->callbacks->cilen && f->callbacks->addci ){
 80158d2:	687b      	ldr	r3, [r7, #4]
 80158d4:	685b      	ldr	r3, [r3, #4]
 80158d6:	685b      	ldr	r3, [r3, #4]
 80158d8:	2b00      	cmp	r3, #0
 80158da:	d019      	beq.n	8015910 <fsm_sconfreq+0xb0>
 80158dc:	687b      	ldr	r3, [r7, #4]
 80158de:	685b      	ldr	r3, [r3, #4]
 80158e0:	689b      	ldr	r3, [r3, #8]
 80158e2:	2b00      	cmp	r3, #0
 80158e4:	d014      	beq.n	8015910 <fsm_sconfreq+0xb0>
	cilen = (*f->callbacks->cilen)(f);
 80158e6:	687b      	ldr	r3, [r7, #4]
 80158e8:	685b      	ldr	r3, [r3, #4]
 80158ea:	685b      	ldr	r3, [r3, #4]
 80158ec:	687a      	ldr	r2, [r7, #4]
 80158ee:	0010      	movs	r0, r2
 80158f0:	4798      	blx	r3
 80158f2:	0003      	movs	r3, r0
 80158f4:	60bb      	str	r3, [r7, #8]
	if( cilen > pcb->peer_mru - HEADERLEN )
 80158f6:	697b      	ldr	r3, [r7, #20]
 80158f8:	22d4      	movs	r2, #212	; 0xd4
 80158fa:	5a9b      	ldrh	r3, [r3, r2]
 80158fc:	1eda      	subs	r2, r3, #3
 80158fe:	68bb      	ldr	r3, [r7, #8]
 8015900:	429a      	cmp	r2, r3
 8015902:	dc07      	bgt.n	8015914 <fsm_sconfreq+0xb4>
	    cilen = pcb->peer_mru - HEADERLEN;
 8015904:	697b      	ldr	r3, [r7, #20]
 8015906:	22d4      	movs	r2, #212	; 0xd4
 8015908:	5a9b      	ldrh	r3, [r3, r2]
 801590a:	3b04      	subs	r3, #4
 801590c:	60bb      	str	r3, [r7, #8]
	if( cilen > pcb->peer_mru - HEADERLEN )
 801590e:	e001      	b.n	8015914 <fsm_sconfreq+0xb4>
    } else
	cilen = 0;
 8015910:	2300      	movs	r3, #0
 8015912:	60bb      	str	r3, [r7, #8]

    p = pbuf_alloc(PBUF_RAW, (u16_t)(cilen + HEADERLEN + PPP_HDRLEN), PPP_CTRL_PBUF_TYPE);
 8015914:	68bb      	ldr	r3, [r7, #8]
 8015916:	b29b      	uxth	r3, r3
 8015918:	3308      	adds	r3, #8
 801591a:	b29b      	uxth	r3, r3
 801591c:	22c1      	movs	r2, #193	; 0xc1
 801591e:	0052      	lsls	r2, r2, #1
 8015920:	0019      	movs	r1, r3
 8015922:	2000      	movs	r0, #0
 8015924:	f7f4 faa4 	bl	8009e70 <pbuf_alloc>
 8015928:	0003      	movs	r3, r0
 801592a:	613b      	str	r3, [r7, #16]
    if(NULL == p)
 801592c:	693b      	ldr	r3, [r7, #16]
 801592e:	2b00      	cmp	r3, #0
 8015930:	d100      	bne.n	8015934 <fsm_sconfreq+0xd4>
 8015932:	e07c      	b.n	8015a2e <fsm_sconfreq+0x1ce>
        return;
    if(p->tot_len != p->len) {
 8015934:	693b      	ldr	r3, [r7, #16]
 8015936:	891a      	ldrh	r2, [r3, #8]
 8015938:	693b      	ldr	r3, [r7, #16]
 801593a:	895b      	ldrh	r3, [r3, #10]
 801593c:	429a      	cmp	r2, r3
 801593e:	d004      	beq.n	801594a <fsm_sconfreq+0xea>
        pbuf_free(p);
 8015940:	693b      	ldr	r3, [r7, #16]
 8015942:	0018      	movs	r0, r3
 8015944:	f7f4 fdca 	bl	800a4dc <pbuf_free>
        return;
 8015948:	e072      	b.n	8015a30 <fsm_sconfreq+0x1d0>
    }

    /* send the request to our peer */
    outp = (u_char*)p->payload;
 801594a:	693b      	ldr	r3, [r7, #16]
 801594c:	685b      	ldr	r3, [r3, #4]
 801594e:	60fb      	str	r3, [r7, #12]
    MAKEHEADER(outp, f->protocol);
 8015950:	68fb      	ldr	r3, [r7, #12]
 8015952:	1c5a      	adds	r2, r3, #1
 8015954:	60fa      	str	r2, [r7, #12]
 8015956:	22ff      	movs	r2, #255	; 0xff
 8015958:	701a      	strb	r2, [r3, #0]
 801595a:	68fb      	ldr	r3, [r7, #12]
 801595c:	1c5a      	adds	r2, r3, #1
 801595e:	60fa      	str	r2, [r7, #12]
 8015960:	2203      	movs	r2, #3
 8015962:	701a      	strb	r2, [r3, #0]
 8015964:	687b      	ldr	r3, [r7, #4]
 8015966:	89db      	ldrh	r3, [r3, #14]
 8015968:	0a1b      	lsrs	r3, r3, #8
 801596a:	b299      	uxth	r1, r3
 801596c:	68fb      	ldr	r3, [r7, #12]
 801596e:	1c5a      	adds	r2, r3, #1
 8015970:	60fa      	str	r2, [r7, #12]
 8015972:	b2ca      	uxtb	r2, r1
 8015974:	701a      	strb	r2, [r3, #0]
 8015976:	687b      	ldr	r3, [r7, #4]
 8015978:	89d9      	ldrh	r1, [r3, #14]
 801597a:	68fb      	ldr	r3, [r7, #12]
 801597c:	1c5a      	adds	r2, r3, #1
 801597e:	60fa      	str	r2, [r7, #12]
 8015980:	b2ca      	uxtb	r2, r1
 8015982:	701a      	strb	r2, [r3, #0]
    PUTCHAR(CONFREQ, outp);
 8015984:	68fb      	ldr	r3, [r7, #12]
 8015986:	1c5a      	adds	r2, r3, #1
 8015988:	60fa      	str	r2, [r7, #12]
 801598a:	2201      	movs	r2, #1
 801598c:	701a      	strb	r2, [r3, #0]
    PUTCHAR(f->reqid, outp);
 801598e:	68fb      	ldr	r3, [r7, #12]
 8015990:	1c5a      	adds	r2, r3, #1
 8015992:	60fa      	str	r2, [r7, #12]
 8015994:	687a      	ldr	r2, [r7, #4]
 8015996:	7cd2      	ldrb	r2, [r2, #19]
 8015998:	701a      	strb	r2, [r3, #0]
    PUTSHORT(cilen + HEADERLEN, outp);
 801599a:	68bb      	ldr	r3, [r7, #8]
 801599c:	3304      	adds	r3, #4
 801599e:	1219      	asrs	r1, r3, #8
 80159a0:	68fb      	ldr	r3, [r7, #12]
 80159a2:	1c5a      	adds	r2, r3, #1
 80159a4:	60fa      	str	r2, [r7, #12]
 80159a6:	b2ca      	uxtb	r2, r1
 80159a8:	701a      	strb	r2, [r3, #0]
 80159aa:	68bb      	ldr	r3, [r7, #8]
 80159ac:	b2da      	uxtb	r2, r3
 80159ae:	68fb      	ldr	r3, [r7, #12]
 80159b0:	1c59      	adds	r1, r3, #1
 80159b2:	60f9      	str	r1, [r7, #12]
 80159b4:	3204      	adds	r2, #4
 80159b6:	b2d2      	uxtb	r2, r2
 80159b8:	701a      	strb	r2, [r3, #0]
    if (cilen != 0) {
 80159ba:	68bb      	ldr	r3, [r7, #8]
 80159bc:	2b00      	cmp	r3, #0
 80159be:	d014      	beq.n	80159ea <fsm_sconfreq+0x18a>
	(*f->callbacks->addci)(f, outp, &cilen);
 80159c0:	687b      	ldr	r3, [r7, #4]
 80159c2:	685b      	ldr	r3, [r3, #4]
 80159c4:	689b      	ldr	r3, [r3, #8]
 80159c6:	2208      	movs	r2, #8
 80159c8:	18ba      	adds	r2, r7, r2
 80159ca:	68f9      	ldr	r1, [r7, #12]
 80159cc:	6878      	ldr	r0, [r7, #4]
 80159ce:	4798      	blx	r3
	LWIP_ASSERT("cilen == p->len - HEADERLEN - PPP_HDRLEN", cilen == p->len - HEADERLEN - PPP_HDRLEN);
 80159d0:	693b      	ldr	r3, [r7, #16]
 80159d2:	895b      	ldrh	r3, [r3, #10]
 80159d4:	3b08      	subs	r3, #8
 80159d6:	001a      	movs	r2, r3
 80159d8:	68bb      	ldr	r3, [r7, #8]
 80159da:	429a      	cmp	r2, r3
 80159dc:	d005      	beq.n	80159ea <fsm_sconfreq+0x18a>
 80159de:	4b16      	ldr	r3, [pc, #88]	; (8015a38 <fsm_sconfreq+0x1d8>)
 80159e0:	4a16      	ldr	r2, [pc, #88]	; (8015a3c <fsm_sconfreq+0x1dc>)
 80159e2:	4917      	ldr	r1, [pc, #92]	; (8015a40 <fsm_sconfreq+0x1e0>)
 80159e4:	4817      	ldr	r0, [pc, #92]	; (8015a44 <fsm_sconfreq+0x1e4>)
 80159e6:	f7ec fbfd 	bl	80021e4 <app_debug_rtt_raw>
    }

    ppp_write(pcb, p);
 80159ea:	693a      	ldr	r2, [r7, #16]
 80159ec:	697b      	ldr	r3, [r7, #20]
 80159ee:	0011      	movs	r1, r2
 80159f0:	0018      	movs	r0, r3
 80159f2:	f004 ffd9 	bl	801a9a8 <ppp_write>

    /* start the retransmit timer */
    --f->retransmits;
 80159f6:	687b      	ldr	r3, [r7, #4]
 80159f8:	7d1b      	ldrb	r3, [r3, #20]
 80159fa:	3b01      	subs	r3, #1
 80159fc:	b2da      	uxtb	r2, r3
 80159fe:	687b      	ldr	r3, [r7, #4]
 8015a00:	751a      	strb	r2, [r3, #20]
    TIMEOUT(fsm_timeout, f, pcb->settings.fsm_timeout_time);
 8015a02:	687a      	ldr	r2, [r7, #4]
 8015a04:	4b10      	ldr	r3, [pc, #64]	; (8015a48 <fsm_sconfreq+0x1e8>)
 8015a06:	0011      	movs	r1, r2
 8015a08:	0018      	movs	r0, r3
 8015a0a:	f7fd f853 	bl	8012ab4 <sys_untimeout>
 8015a0e:	697b      	ldr	r3, [r7, #20]
 8015a10:	791b      	ldrb	r3, [r3, #4]
 8015a12:	001a      	movs	r2, r3
 8015a14:	0013      	movs	r3, r2
 8015a16:	015b      	lsls	r3, r3, #5
 8015a18:	1a9b      	subs	r3, r3, r2
 8015a1a:	009b      	lsls	r3, r3, #2
 8015a1c:	189b      	adds	r3, r3, r2
 8015a1e:	00db      	lsls	r3, r3, #3
 8015a20:	0018      	movs	r0, r3
 8015a22:	687a      	ldr	r2, [r7, #4]
 8015a24:	4b08      	ldr	r3, [pc, #32]	; (8015a48 <fsm_sconfreq+0x1e8>)
 8015a26:	0019      	movs	r1, r3
 8015a28:	f7fd f81c 	bl	8012a64 <sys_timeout>
 8015a2c:	e000      	b.n	8015a30 <fsm_sconfreq+0x1d0>
        return;
 8015a2e:	46c0      	nop			; (mov r8, r8)
}
 8015a30:	46bd      	mov	sp, r7
 8015a32:	b006      	add	sp, #24
 8015a34:	bd80      	pop	{r7, pc}
 8015a36:	46c0      	nop			; (mov r8, r8)
 8015a38:	08022738 	.word	0x08022738
 8015a3c:	000002f2 	.word	0x000002f2
 8015a40:	08022764 	.word	0x08022764
 8015a44:	08022790 	.word	0x08022790
 8015a48:	08014f3d 	.word	0x08014f3d

08015a4c <fsm_sdata>:
/*
 * fsm_sdata - Send some data.
 *
 * Used for all packets sent to our peer by this module.
 */
void fsm_sdata(fsm *f, u_char code, u_char id, const u_char *data, int datalen) {
 8015a4c:	b580      	push	{r7, lr}
 8015a4e:	b088      	sub	sp, #32
 8015a50:	af00      	add	r7, sp, #0
 8015a52:	60f8      	str	r0, [r7, #12]
 8015a54:	0008      	movs	r0, r1
 8015a56:	0011      	movs	r1, r2
 8015a58:	607b      	str	r3, [r7, #4]
 8015a5a:	230b      	movs	r3, #11
 8015a5c:	18fb      	adds	r3, r7, r3
 8015a5e:	1c02      	adds	r2, r0, #0
 8015a60:	701a      	strb	r2, [r3, #0]
 8015a62:	230a      	movs	r3, #10
 8015a64:	18fb      	adds	r3, r7, r3
 8015a66:	1c0a      	adds	r2, r1, #0
 8015a68:	701a      	strb	r2, [r3, #0]
    ppp_pcb *pcb = f->pcb;
 8015a6a:	68fb      	ldr	r3, [r7, #12]
 8015a6c:	681b      	ldr	r3, [r3, #0]
 8015a6e:	61fb      	str	r3, [r7, #28]
    struct pbuf *p;
    u_char *outp;
    int outlen;

    /* Adjust length to be smaller than MTU */
    if (datalen > pcb->peer_mru - HEADERLEN)
 8015a70:	69fb      	ldr	r3, [r7, #28]
 8015a72:	22d4      	movs	r2, #212	; 0xd4
 8015a74:	5a9b      	ldrh	r3, [r3, r2]
 8015a76:	3b03      	subs	r3, #3
 8015a78:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8015a7a:	429a      	cmp	r2, r3
 8015a7c:	db04      	blt.n	8015a88 <fsm_sdata+0x3c>
	datalen = pcb->peer_mru - HEADERLEN;
 8015a7e:	69fb      	ldr	r3, [r7, #28]
 8015a80:	22d4      	movs	r2, #212	; 0xd4
 8015a82:	5a9b      	ldrh	r3, [r3, r2]
 8015a84:	3b04      	subs	r3, #4
 8015a86:	62bb      	str	r3, [r7, #40]	; 0x28
    outlen = datalen + HEADERLEN;
 8015a88:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015a8a:	3304      	adds	r3, #4
 8015a8c:	61bb      	str	r3, [r7, #24]

    p = pbuf_alloc(PBUF_RAW, (u16_t)(outlen + PPP_HDRLEN), PPP_CTRL_PBUF_TYPE);
 8015a8e:	69bb      	ldr	r3, [r7, #24]
 8015a90:	b29b      	uxth	r3, r3
 8015a92:	3304      	adds	r3, #4
 8015a94:	b29b      	uxth	r3, r3
 8015a96:	22c1      	movs	r2, #193	; 0xc1
 8015a98:	0052      	lsls	r2, r2, #1
 8015a9a:	0019      	movs	r1, r3
 8015a9c:	2000      	movs	r0, #0
 8015a9e:	f7f4 f9e7 	bl	8009e70 <pbuf_alloc>
 8015aa2:	0003      	movs	r3, r0
 8015aa4:	617b      	str	r3, [r7, #20]
    if(NULL == p)
 8015aa6:	697b      	ldr	r3, [r7, #20]
 8015aa8:	2b00      	cmp	r3, #0
 8015aaa:	d053      	beq.n	8015b54 <fsm_sdata+0x108>
        return;
    if(p->tot_len != p->len) {
 8015aac:	697b      	ldr	r3, [r7, #20]
 8015aae:	891a      	ldrh	r2, [r3, #8]
 8015ab0:	697b      	ldr	r3, [r7, #20]
 8015ab2:	895b      	ldrh	r3, [r3, #10]
 8015ab4:	429a      	cmp	r2, r3
 8015ab6:	d004      	beq.n	8015ac2 <fsm_sdata+0x76>
        pbuf_free(p);
 8015ab8:	697b      	ldr	r3, [r7, #20]
 8015aba:	0018      	movs	r0, r3
 8015abc:	f7f4 fd0e 	bl	800a4dc <pbuf_free>
        return;
 8015ac0:	e049      	b.n	8015b56 <fsm_sdata+0x10a>
    }

    outp = (u_char*)p->payload;
 8015ac2:	697b      	ldr	r3, [r7, #20]
 8015ac4:	685b      	ldr	r3, [r3, #4]
 8015ac6:	613b      	str	r3, [r7, #16]
    if (datalen) /* && data != outp + PPP_HDRLEN + HEADERLEN)  -- was only for fsm_sconfreq() */
 8015ac8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015aca:	2b00      	cmp	r3, #0
 8015acc:	d006      	beq.n	8015adc <fsm_sdata+0x90>
	MEMCPY(outp + PPP_HDRLEN + HEADERLEN, data, datalen);
 8015ace:	693b      	ldr	r3, [r7, #16]
 8015ad0:	3308      	adds	r3, #8
 8015ad2:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8015ad4:	6879      	ldr	r1, [r7, #4]
 8015ad6:	0018      	movs	r0, r3
 8015ad8:	f008 fa60 	bl	801df9c <memcpy>
    MAKEHEADER(outp, f->protocol);
 8015adc:	693b      	ldr	r3, [r7, #16]
 8015ade:	1c5a      	adds	r2, r3, #1
 8015ae0:	613a      	str	r2, [r7, #16]
 8015ae2:	22ff      	movs	r2, #255	; 0xff
 8015ae4:	701a      	strb	r2, [r3, #0]
 8015ae6:	693b      	ldr	r3, [r7, #16]
 8015ae8:	1c5a      	adds	r2, r3, #1
 8015aea:	613a      	str	r2, [r7, #16]
 8015aec:	2203      	movs	r2, #3
 8015aee:	701a      	strb	r2, [r3, #0]
 8015af0:	68fb      	ldr	r3, [r7, #12]
 8015af2:	89db      	ldrh	r3, [r3, #14]
 8015af4:	0a1b      	lsrs	r3, r3, #8
 8015af6:	b299      	uxth	r1, r3
 8015af8:	693b      	ldr	r3, [r7, #16]
 8015afa:	1c5a      	adds	r2, r3, #1
 8015afc:	613a      	str	r2, [r7, #16]
 8015afe:	b2ca      	uxtb	r2, r1
 8015b00:	701a      	strb	r2, [r3, #0]
 8015b02:	68fb      	ldr	r3, [r7, #12]
 8015b04:	89d9      	ldrh	r1, [r3, #14]
 8015b06:	693b      	ldr	r3, [r7, #16]
 8015b08:	1c5a      	adds	r2, r3, #1
 8015b0a:	613a      	str	r2, [r7, #16]
 8015b0c:	b2ca      	uxtb	r2, r1
 8015b0e:	701a      	strb	r2, [r3, #0]
    PUTCHAR(code, outp);
 8015b10:	693b      	ldr	r3, [r7, #16]
 8015b12:	1c5a      	adds	r2, r3, #1
 8015b14:	613a      	str	r2, [r7, #16]
 8015b16:	220b      	movs	r2, #11
 8015b18:	18ba      	adds	r2, r7, r2
 8015b1a:	7812      	ldrb	r2, [r2, #0]
 8015b1c:	701a      	strb	r2, [r3, #0]
    PUTCHAR(id, outp);
 8015b1e:	693b      	ldr	r3, [r7, #16]
 8015b20:	1c5a      	adds	r2, r3, #1
 8015b22:	613a      	str	r2, [r7, #16]
 8015b24:	220a      	movs	r2, #10
 8015b26:	18ba      	adds	r2, r7, r2
 8015b28:	7812      	ldrb	r2, [r2, #0]
 8015b2a:	701a      	strb	r2, [r3, #0]
    PUTSHORT(outlen, outp);
 8015b2c:	69bb      	ldr	r3, [r7, #24]
 8015b2e:	1219      	asrs	r1, r3, #8
 8015b30:	693b      	ldr	r3, [r7, #16]
 8015b32:	1c5a      	adds	r2, r3, #1
 8015b34:	613a      	str	r2, [r7, #16]
 8015b36:	b2ca      	uxtb	r2, r1
 8015b38:	701a      	strb	r2, [r3, #0]
 8015b3a:	693b      	ldr	r3, [r7, #16]
 8015b3c:	1c5a      	adds	r2, r3, #1
 8015b3e:	613a      	str	r2, [r7, #16]
 8015b40:	69ba      	ldr	r2, [r7, #24]
 8015b42:	b2d2      	uxtb	r2, r2
 8015b44:	701a      	strb	r2, [r3, #0]
    ppp_write(pcb, p);
 8015b46:	697a      	ldr	r2, [r7, #20]
 8015b48:	69fb      	ldr	r3, [r7, #28]
 8015b4a:	0011      	movs	r1, r2
 8015b4c:	0018      	movs	r0, r3
 8015b4e:	f004 ff2b 	bl	801a9a8 <ppp_write>
 8015b52:	e000      	b.n	8015b56 <fsm_sdata+0x10a>
        return;
 8015b54:	46c0      	nop			; (mov r8, r8)
}
 8015b56:	46bd      	mov	sp, r7
 8015b58:	b008      	add	sp, #32
 8015b5a:	bd80      	pop	{r7, pc}

08015b5c <ipcp_init>:
#endif /* PPP_OPTIONS */

/*
 * ipcp_init - Initialize IPCP.
 */
static void ipcp_init(ppp_pcb *pcb) {
 8015b5c:	b580      	push	{r7, lr}
 8015b5e:	b086      	sub	sp, #24
 8015b60:	af00      	add	r7, sp, #0
 8015b62:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->ipcp_fsm;
 8015b64:	687b      	ldr	r3, [r7, #4]
 8015b66:	4a34      	ldr	r2, [pc, #208]	; (8015c38 <ipcp_init+0xdc>)
 8015b68:	4694      	mov	ip, r2
 8015b6a:	4463      	add	r3, ip
 8015b6c:	617b      	str	r3, [r7, #20]

    ipcp_options *wo = &pcb->ipcp_wantoptions;
 8015b6e:	687b      	ldr	r3, [r7, #4]
 8015b70:	4a32      	ldr	r2, [pc, #200]	; (8015c3c <ipcp_init+0xe0>)
 8015b72:	4694      	mov	ip, r2
 8015b74:	4463      	add	r3, ip
 8015b76:	613b      	str	r3, [r7, #16]
    ipcp_options *ao = &pcb->ipcp_allowoptions;
 8015b78:	687b      	ldr	r3, [r7, #4]
 8015b7a:	4a31      	ldr	r2, [pc, #196]	; (8015c40 <ipcp_init+0xe4>)
 8015b7c:	4694      	mov	ip, r2
 8015b7e:	4463      	add	r3, ip
 8015b80:	60fb      	str	r3, [r7, #12]

    f->pcb = pcb;
 8015b82:	697b      	ldr	r3, [r7, #20]
 8015b84:	687a      	ldr	r2, [r7, #4]
 8015b86:	601a      	str	r2, [r3, #0]
    f->protocol = PPP_IPCP;
 8015b88:	697b      	ldr	r3, [r7, #20]
 8015b8a:	4a2e      	ldr	r2, [pc, #184]	; (8015c44 <ipcp_init+0xe8>)
 8015b8c:	81da      	strh	r2, [r3, #14]
    f->callbacks = &ipcp_callbacks;
 8015b8e:	697b      	ldr	r3, [r7, #20]
 8015b90:	4a2d      	ldr	r2, [pc, #180]	; (8015c48 <ipcp_init+0xec>)
 8015b92:	605a      	str	r2, [r3, #4]
    fsm_init(f);
 8015b94:	697b      	ldr	r3, [r7, #20]
 8015b96:	0018      	movs	r0, r3
 8015b98:	f7ff f83c 	bl	8014c14 <fsm_init>
     * Some 3G modems use repeated IPCP NAKs as a way of stalling
     * until they can contact a server on the network, so we increase
     * the default number of NAKs we accept before we start treating
     * them as rejects.
     */
    f->maxnakloops = 100;
 8015b9c:	697b      	ldr	r3, [r7, #20]
 8015b9e:	2264      	movs	r2, #100	; 0x64
 8015ba0:	75da      	strb	r2, [r3, #23]
#if 0 /* Not necessary, everything is cleared in ppp_new() */
    memset(wo, 0, sizeof(*wo));
    memset(ao, 0, sizeof(*ao));
#endif /* 0 */

    wo->neg_addr = wo->old_addrs = 1;
 8015ba2:	693b      	ldr	r3, [r7, #16]
 8015ba4:	781a      	ldrb	r2, [r3, #0]
 8015ba6:	2102      	movs	r1, #2
 8015ba8:	430a      	orrs	r2, r1
 8015baa:	701a      	strb	r2, [r3, #0]
 8015bac:	693b      	ldr	r3, [r7, #16]
 8015bae:	781b      	ldrb	r3, [r3, #0]
 8015bb0:	079b      	lsls	r3, r3, #30
 8015bb2:	0fdb      	lsrs	r3, r3, #31
 8015bb4:	b2da      	uxtb	r2, r3
 8015bb6:	693b      	ldr	r3, [r7, #16]
 8015bb8:	2101      	movs	r1, #1
 8015bba:	400a      	ands	r2, r1
 8015bbc:	0010      	movs	r0, r2
 8015bbe:	781a      	ldrb	r2, [r3, #0]
 8015bc0:	2101      	movs	r1, #1
 8015bc2:	438a      	bics	r2, r1
 8015bc4:	1c11      	adds	r1, r2, #0
 8015bc6:	1c02      	adds	r2, r0, #0
 8015bc8:	430a      	orrs	r2, r1
 8015bca:	701a      	strb	r2, [r3, #0]
#if VJ_SUPPORT
    wo->neg_vj = 1;
 8015bcc:	693b      	ldr	r3, [r7, #16]
 8015bce:	781a      	ldrb	r2, [r3, #0]
 8015bd0:	2108      	movs	r1, #8
 8015bd2:	430a      	orrs	r2, r1
 8015bd4:	701a      	strb	r2, [r3, #0]
    wo->vj_protocol = IPCP_VJ_COMP;
 8015bd6:	693b      	ldr	r3, [r7, #16]
 8015bd8:	222d      	movs	r2, #45	; 0x2d
 8015bda:	829a      	strh	r2, [r3, #20]
    wo->maxslotindex = MAX_STATES - 1; /* really max index */
 8015bdc:	693b      	ldr	r3, [r7, #16]
 8015bde:	220f      	movs	r2, #15
 8015be0:	759a      	strb	r2, [r3, #22]
    wo->cflag = 1;
 8015be2:	693b      	ldr	r3, [r7, #16]
 8015be4:	781a      	ldrb	r2, [r3, #0]
 8015be6:	2120      	movs	r1, #32
 8015be8:	430a      	orrs	r2, r1
 8015bea:	701a      	strb	r2, [r3, #0]
#if 0 /* UNUSED */
    /* wanting default route by default */
    wo->default_route = 1;
#endif /* UNUSED */

    ao->neg_addr = ao->old_addrs = 1;
 8015bec:	68fb      	ldr	r3, [r7, #12]
 8015bee:	781a      	ldrb	r2, [r3, #0]
 8015bf0:	2102      	movs	r1, #2
 8015bf2:	430a      	orrs	r2, r1
 8015bf4:	701a      	strb	r2, [r3, #0]
 8015bf6:	68fb      	ldr	r3, [r7, #12]
 8015bf8:	781b      	ldrb	r3, [r3, #0]
 8015bfa:	079b      	lsls	r3, r3, #30
 8015bfc:	0fdb      	lsrs	r3, r3, #31
 8015bfe:	b2da      	uxtb	r2, r3
 8015c00:	68fb      	ldr	r3, [r7, #12]
 8015c02:	2101      	movs	r1, #1
 8015c04:	400a      	ands	r2, r1
 8015c06:	0010      	movs	r0, r2
 8015c08:	781a      	ldrb	r2, [r3, #0]
 8015c0a:	2101      	movs	r1, #1
 8015c0c:	438a      	bics	r2, r1
 8015c0e:	1c11      	adds	r1, r2, #0
 8015c10:	1c02      	adds	r2, r0, #0
 8015c12:	430a      	orrs	r2, r1
 8015c14:	701a      	strb	r2, [r3, #0]
#if VJ_SUPPORT
    /* max slots and slot-id compression are currently hardwired in */
    /* ppp_if.c to 16 and 1, this needs to be changed (among other */
    /* things) gmc */

    ao->neg_vj = 1;
 8015c16:	68fb      	ldr	r3, [r7, #12]
 8015c18:	781a      	ldrb	r2, [r3, #0]
 8015c1a:	2108      	movs	r1, #8
 8015c1c:	430a      	orrs	r2, r1
 8015c1e:	701a      	strb	r2, [r3, #0]
    ao->maxslotindex = MAX_STATES - 1;
 8015c20:	68fb      	ldr	r3, [r7, #12]
 8015c22:	220f      	movs	r2, #15
 8015c24:	759a      	strb	r2, [r3, #22]
    ao->cflag = 1;
 8015c26:	68fb      	ldr	r3, [r7, #12]
 8015c28:	781a      	ldrb	r2, [r3, #0]
 8015c2a:	2120      	movs	r1, #32
 8015c2c:	430a      	orrs	r2, r1
 8015c2e:	701a      	strb	r2, [r3, #0]
     * and defaultroute options.
     */
    ao->proxy_arp = 1;
    ao->default_route = 1;
#endif /* UNUSED */
}
 8015c30:	46c0      	nop			; (mov r8, r8)
 8015c32:	46bd      	mov	sp, r7
 8015c34:	b006      	add	sp, #24
 8015c36:	bd80      	pop	{r7, pc}
 8015c38:	000011e8 	.word	0x000011e8
 8015c3c:	00001204 	.word	0x00001204
 8015c40:	00001234 	.word	0x00001234
 8015c44:	ffff8021 	.word	0xffff8021
 8015c48:	08023b90 	.word	0x08023b90

08015c4c <ipcp_open>:


/*
 * ipcp_open - IPCP is allowed to come up.
 */
static void ipcp_open(ppp_pcb *pcb) {
 8015c4c:	b580      	push	{r7, lr}
 8015c4e:	b084      	sub	sp, #16
 8015c50:	af00      	add	r7, sp, #0
 8015c52:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->ipcp_fsm;
 8015c54:	687b      	ldr	r3, [r7, #4]
 8015c56:	4a09      	ldr	r2, [pc, #36]	; (8015c7c <ipcp_open+0x30>)
 8015c58:	4694      	mov	ip, r2
 8015c5a:	4463      	add	r3, ip
 8015c5c:	60fb      	str	r3, [r7, #12]
    fsm_open(f);
 8015c5e:	68fb      	ldr	r3, [r7, #12]
 8015c60:	0018      	movs	r0, r3
 8015c62:	f7ff f865 	bl	8014d30 <fsm_open>
    pcb->ipcp_is_open = 1;
 8015c66:	687b      	ldr	r3, [r7, #4]
 8015c68:	2226      	movs	r2, #38	; 0x26
 8015c6a:	5c99      	ldrb	r1, [r3, r2]
 8015c6c:	2002      	movs	r0, #2
 8015c6e:	4301      	orrs	r1, r0
 8015c70:	5499      	strb	r1, [r3, r2]
}
 8015c72:	46c0      	nop			; (mov r8, r8)
 8015c74:	46bd      	mov	sp, r7
 8015c76:	b004      	add	sp, #16
 8015c78:	bd80      	pop	{r7, pc}
 8015c7a:	46c0      	nop			; (mov r8, r8)
 8015c7c:	000011e8 	.word	0x000011e8

08015c80 <ipcp_close>:


/*
 * ipcp_close - Take IPCP down.
 */
static void ipcp_close(ppp_pcb *pcb, const char *reason) {
 8015c80:	b580      	push	{r7, lr}
 8015c82:	b084      	sub	sp, #16
 8015c84:	af00      	add	r7, sp, #0
 8015c86:	6078      	str	r0, [r7, #4]
 8015c88:	6039      	str	r1, [r7, #0]
    fsm *f = &pcb->ipcp_fsm;
 8015c8a:	687b      	ldr	r3, [r7, #4]
 8015c8c:	4a06      	ldr	r2, [pc, #24]	; (8015ca8 <ipcp_close+0x28>)
 8015c8e:	4694      	mov	ip, r2
 8015c90:	4463      	add	r3, ip
 8015c92:	60fb      	str	r3, [r7, #12]
    fsm_close(f, reason);
 8015c94:	683a      	ldr	r2, [r7, #0]
 8015c96:	68fb      	ldr	r3, [r7, #12]
 8015c98:	0011      	movs	r1, r2
 8015c9a:	0018      	movs	r0, r3
 8015c9c:	f7ff f90a 	bl	8014eb4 <fsm_close>
}
 8015ca0:	46c0      	nop			; (mov r8, r8)
 8015ca2:	46bd      	mov	sp, r7
 8015ca4:	b004      	add	sp, #16
 8015ca6:	bd80      	pop	{r7, pc}
 8015ca8:	000011e8 	.word	0x000011e8

08015cac <ipcp_lowerup>:


/*
 * ipcp_lowerup - The lower layer is up.
 */
static void ipcp_lowerup(ppp_pcb *pcb) {
 8015cac:	b580      	push	{r7, lr}
 8015cae:	b084      	sub	sp, #16
 8015cb0:	af00      	add	r7, sp, #0
 8015cb2:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->ipcp_fsm;
 8015cb4:	687b      	ldr	r3, [r7, #4]
 8015cb6:	4a06      	ldr	r2, [pc, #24]	; (8015cd0 <ipcp_lowerup+0x24>)
 8015cb8:	4694      	mov	ip, r2
 8015cba:	4463      	add	r3, ip
 8015cbc:	60fb      	str	r3, [r7, #12]
    fsm_lowerup(f);
 8015cbe:	68fb      	ldr	r3, [r7, #12]
 8015cc0:	0018      	movs	r0, r3
 8015cc2:	f7fe ffc2 	bl	8014c4a <fsm_lowerup>
}
 8015cc6:	46c0      	nop			; (mov r8, r8)
 8015cc8:	46bd      	mov	sp, r7
 8015cca:	b004      	add	sp, #16
 8015ccc:	bd80      	pop	{r7, pc}
 8015cce:	46c0      	nop			; (mov r8, r8)
 8015cd0:	000011e8 	.word	0x000011e8

08015cd4 <ipcp_lowerdown>:


/*
 * ipcp_lowerdown - The lower layer is down.
 */
static void ipcp_lowerdown(ppp_pcb *pcb) {
 8015cd4:	b580      	push	{r7, lr}
 8015cd6:	b084      	sub	sp, #16
 8015cd8:	af00      	add	r7, sp, #0
 8015cda:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->ipcp_fsm;
 8015cdc:	687b      	ldr	r3, [r7, #4]
 8015cde:	4a06      	ldr	r2, [pc, #24]	; (8015cf8 <ipcp_lowerdown+0x24>)
 8015ce0:	4694      	mov	ip, r2
 8015ce2:	4463      	add	r3, ip
 8015ce4:	60fb      	str	r3, [r7, #12]
    fsm_lowerdown(f);
 8015ce6:	68fb      	ldr	r3, [r7, #12]
 8015ce8:	0018      	movs	r0, r3
 8015cea:	f7fe ffd5 	bl	8014c98 <fsm_lowerdown>
}
 8015cee:	46c0      	nop			; (mov r8, r8)
 8015cf0:	46bd      	mov	sp, r7
 8015cf2:	b004      	add	sp, #16
 8015cf4:	bd80      	pop	{r7, pc}
 8015cf6:	46c0      	nop			; (mov r8, r8)
 8015cf8:	000011e8 	.word	0x000011e8

08015cfc <ipcp_input>:


/*
 * ipcp_input - Input IPCP packet.
 */
static void ipcp_input(ppp_pcb *pcb, u_char *p, int len) {
 8015cfc:	b580      	push	{r7, lr}
 8015cfe:	b086      	sub	sp, #24
 8015d00:	af00      	add	r7, sp, #0
 8015d02:	60f8      	str	r0, [r7, #12]
 8015d04:	60b9      	str	r1, [r7, #8]
 8015d06:	607a      	str	r2, [r7, #4]
    fsm *f = &pcb->ipcp_fsm;
 8015d08:	68fb      	ldr	r3, [r7, #12]
 8015d0a:	4a07      	ldr	r2, [pc, #28]	; (8015d28 <ipcp_input+0x2c>)
 8015d0c:	4694      	mov	ip, r2
 8015d0e:	4463      	add	r3, ip
 8015d10:	617b      	str	r3, [r7, #20]
    fsm_input(f, p, len);
 8015d12:	687a      	ldr	r2, [r7, #4]
 8015d14:	68b9      	ldr	r1, [r7, #8]
 8015d16:	697b      	ldr	r3, [r7, #20]
 8015d18:	0018      	movs	r0, r3
 8015d1a:	f7ff f9b5 	bl	8015088 <fsm_input>
}
 8015d1e:	46c0      	nop			; (mov r8, r8)
 8015d20:	46bd      	mov	sp, r7
 8015d22:	b006      	add	sp, #24
 8015d24:	bd80      	pop	{r7, pc}
 8015d26:	46c0      	nop			; (mov r8, r8)
 8015d28:	000011e8 	.word	0x000011e8

08015d2c <ipcp_protrej>:
/*
 * ipcp_protrej - A Protocol-Reject was received for IPCP.
 *
 * Pretend the lower layer went down, so we shut up.
 */
static void ipcp_protrej(ppp_pcb *pcb) {
 8015d2c:	b580      	push	{r7, lr}
 8015d2e:	b084      	sub	sp, #16
 8015d30:	af00      	add	r7, sp, #0
 8015d32:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->ipcp_fsm;
 8015d34:	687b      	ldr	r3, [r7, #4]
 8015d36:	4a06      	ldr	r2, [pc, #24]	; (8015d50 <ipcp_protrej+0x24>)
 8015d38:	4694      	mov	ip, r2
 8015d3a:	4463      	add	r3, ip
 8015d3c:	60fb      	str	r3, [r7, #12]
    fsm_lowerdown(f);
 8015d3e:	68fb      	ldr	r3, [r7, #12]
 8015d40:	0018      	movs	r0, r3
 8015d42:	f7fe ffa9 	bl	8014c98 <fsm_lowerdown>
}
 8015d46:	46c0      	nop			; (mov r8, r8)
 8015d48:	46bd      	mov	sp, r7
 8015d4a:	b004      	add	sp, #16
 8015d4c:	bd80      	pop	{r7, pc}
 8015d4e:	46c0      	nop			; (mov r8, r8)
 8015d50:	000011e8 	.word	0x000011e8

08015d54 <ipcp_resetci>:

/*
 * ipcp_resetci - Reset our CI.
 * Called by fsm_sconfreq, Send Configure Request.
 */
static void ipcp_resetci(fsm *f) {
 8015d54:	b590      	push	{r4, r7, lr}
 8015d56:	b087      	sub	sp, #28
 8015d58:	af00      	add	r7, sp, #0
 8015d5a:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8015d5c:	687b      	ldr	r3, [r7, #4]
 8015d5e:	681b      	ldr	r3, [r3, #0]
 8015d60:	617b      	str	r3, [r7, #20]
    ipcp_options *wo = &pcb->ipcp_wantoptions;
 8015d62:	697b      	ldr	r3, [r7, #20]
 8015d64:	4a46      	ldr	r2, [pc, #280]	; (8015e80 <ipcp_resetci+0x12c>)
 8015d66:	4694      	mov	ip, r2
 8015d68:	4463      	add	r3, ip
 8015d6a:	613b      	str	r3, [r7, #16]
    ipcp_options *go = &pcb->ipcp_gotoptions;
 8015d6c:	697b      	ldr	r3, [r7, #20]
 8015d6e:	4a45      	ldr	r2, [pc, #276]	; (8015e84 <ipcp_resetci+0x130>)
 8015d70:	4694      	mov	ip, r2
 8015d72:	4463      	add	r3, ip
 8015d74:	60fb      	str	r3, [r7, #12]
    ipcp_options *ao = &pcb->ipcp_allowoptions;
 8015d76:	697b      	ldr	r3, [r7, #20]
 8015d78:	4a43      	ldr	r2, [pc, #268]	; (8015e88 <ipcp_resetci+0x134>)
 8015d7a:	4694      	mov	ip, r2
 8015d7c:	4463      	add	r3, ip
 8015d7e:	60bb      	str	r3, [r7, #8]

    wo->req_addr = (wo->neg_addr || wo->old_addrs) &&
 8015d80:	693b      	ldr	r3, [r7, #16]
 8015d82:	781b      	ldrb	r3, [r3, #0]
 8015d84:	2201      	movs	r2, #1
 8015d86:	4013      	ands	r3, r2
 8015d88:	b2db      	uxtb	r3, r3
 8015d8a:	2b00      	cmp	r3, #0
 8015d8c:	d106      	bne.n	8015d9c <ipcp_resetci+0x48>
 8015d8e:	693b      	ldr	r3, [r7, #16]
 8015d90:	781b      	ldrb	r3, [r3, #0]
 8015d92:	2202      	movs	r2, #2
 8015d94:	4013      	ands	r3, r2
 8015d96:	b2db      	uxtb	r3, r3
 8015d98:	2b00      	cmp	r3, #0
 8015d9a:	d00f      	beq.n	8015dbc <ipcp_resetci+0x68>
	(ao->neg_addr || ao->old_addrs);
 8015d9c:	68bb      	ldr	r3, [r7, #8]
 8015d9e:	781b      	ldrb	r3, [r3, #0]
 8015da0:	2201      	movs	r2, #1
 8015da2:	4013      	ands	r3, r2
 8015da4:	b2db      	uxtb	r3, r3
    wo->req_addr = (wo->neg_addr || wo->old_addrs) &&
 8015da6:	2b00      	cmp	r3, #0
 8015da8:	d106      	bne.n	8015db8 <ipcp_resetci+0x64>
	(ao->neg_addr || ao->old_addrs);
 8015daa:	68bb      	ldr	r3, [r7, #8]
 8015dac:	781b      	ldrb	r3, [r3, #0]
 8015dae:	2202      	movs	r2, #2
 8015db0:	4013      	ands	r3, r2
 8015db2:	b2db      	uxtb	r3, r3
 8015db4:	2b00      	cmp	r3, #0
 8015db6:	d001      	beq.n	8015dbc <ipcp_resetci+0x68>
    wo->req_addr = (wo->neg_addr || wo->old_addrs) &&
 8015db8:	2301      	movs	r3, #1
 8015dba:	e000      	b.n	8015dbe <ipcp_resetci+0x6a>
 8015dbc:	2300      	movs	r3, #0
 8015dbe:	1c1a      	adds	r2, r3, #0
 8015dc0:	2301      	movs	r3, #1
 8015dc2:	4013      	ands	r3, r2
 8015dc4:	b2da      	uxtb	r2, r3
 8015dc6:	693b      	ldr	r3, [r7, #16]
 8015dc8:	2101      	movs	r1, #1
 8015dca:	400a      	ands	r2, r1
 8015dcc:	0090      	lsls	r0, r2, #2
 8015dce:	781a      	ldrb	r2, [r3, #0]
 8015dd0:	2104      	movs	r1, #4
 8015dd2:	438a      	bics	r2, r1
 8015dd4:	1c11      	adds	r1, r2, #0
 8015dd6:	1c02      	adds	r2, r0, #0
 8015dd8:	430a      	orrs	r2, r1
 8015dda:	701a      	strb	r2, [r3, #0]
    if (wo->ouraddr == 0)
 8015ddc:	693b      	ldr	r3, [r7, #16]
 8015dde:	685b      	ldr	r3, [r3, #4]
 8015de0:	2b00      	cmp	r3, #0
 8015de2:	d104      	bne.n	8015dee <ipcp_resetci+0x9a>
	wo->accept_local = 1;
 8015de4:	693b      	ldr	r3, [r7, #16]
 8015de6:	781a      	ldrb	r2, [r3, #0]
 8015de8:	2140      	movs	r1, #64	; 0x40
 8015dea:	430a      	orrs	r2, r1
 8015dec:	701a      	strb	r2, [r3, #0]
    if (wo->hisaddr == 0)
 8015dee:	693b      	ldr	r3, [r7, #16]
 8015df0:	689b      	ldr	r3, [r3, #8]
 8015df2:	2b00      	cmp	r3, #0
 8015df4:	d105      	bne.n	8015e02 <ipcp_resetci+0xae>
	wo->accept_remote = 1;
 8015df6:	693b      	ldr	r3, [r7, #16]
 8015df8:	781a      	ldrb	r2, [r3, #0]
 8015dfa:	2180      	movs	r1, #128	; 0x80
 8015dfc:	4249      	negs	r1, r1
 8015dfe:	430a      	orrs	r2, r1
 8015e00:	701a      	strb	r2, [r3, #0]
#if LWIP_DNS
    wo->req_dns1 = wo->req_dns2 = pcb->settings.usepeerdns;	/* Request DNS addresses from the peer */
 8015e02:	697b      	ldr	r3, [r7, #20]
 8015e04:	781b      	ldrb	r3, [r3, #0]
 8015e06:	07db      	lsls	r3, r3, #31
 8015e08:	0fdb      	lsrs	r3, r3, #31
 8015e0a:	b2da      	uxtb	r2, r3
 8015e0c:	693b      	ldr	r3, [r7, #16]
 8015e0e:	2101      	movs	r1, #1
 8015e10:	400a      	ands	r2, r1
 8015e12:	1890      	adds	r0, r2, r2
 8015e14:	785a      	ldrb	r2, [r3, #1]
 8015e16:	2102      	movs	r1, #2
 8015e18:	438a      	bics	r2, r1
 8015e1a:	1c11      	adds	r1, r2, #0
 8015e1c:	1c02      	adds	r2, r0, #0
 8015e1e:	430a      	orrs	r2, r1
 8015e20:	705a      	strb	r2, [r3, #1]
 8015e22:	693b      	ldr	r3, [r7, #16]
 8015e24:	785b      	ldrb	r3, [r3, #1]
 8015e26:	079b      	lsls	r3, r3, #30
 8015e28:	0fdb      	lsrs	r3, r3, #31
 8015e2a:	b2da      	uxtb	r2, r3
 8015e2c:	693b      	ldr	r3, [r7, #16]
 8015e2e:	2101      	movs	r1, #1
 8015e30:	400a      	ands	r2, r1
 8015e32:	0010      	movs	r0, r2
 8015e34:	785a      	ldrb	r2, [r3, #1]
 8015e36:	2101      	movs	r1, #1
 8015e38:	438a      	bics	r2, r1
 8015e3a:	1c11      	adds	r1, r2, #0
 8015e3c:	1c02      	adds	r2, r0, #0
 8015e3e:	430a      	orrs	r2, r1
 8015e40:	705a      	strb	r2, [r3, #1]
#endif /* LWIP_DNS */
    *go = *wo;
 8015e42:	68fb      	ldr	r3, [r7, #12]
 8015e44:	693a      	ldr	r2, [r7, #16]
 8015e46:	ca13      	ldmia	r2!, {r0, r1, r4}
 8015e48:	c313      	stmia	r3!, {r0, r1, r4}
 8015e4a:	ca13      	ldmia	r2!, {r0, r1, r4}
 8015e4c:	c313      	stmia	r3!, {r0, r1, r4}
    if (!pcb->ask_for_local)
 8015e4e:	697b      	ldr	r3, [r7, #20]
 8015e50:	2226      	movs	r2, #38	; 0x26
 8015e52:	5c9b      	ldrb	r3, [r3, r2]
 8015e54:	2201      	movs	r2, #1
 8015e56:	4013      	ands	r3, r2
 8015e58:	b2db      	uxtb	r3, r3
 8015e5a:	2b00      	cmp	r3, #0
 8015e5c:	d102      	bne.n	8015e64 <ipcp_resetci+0x110>
	go->ouraddr = 0;
 8015e5e:	68fb      	ldr	r3, [r7, #12]
 8015e60:	2200      	movs	r2, #0
 8015e62:	605a      	str	r2, [r3, #4]
	if (wo->hisaddr) {
	    wo->accept_remote = 0;
	}
    }
#endif /* UNUSED */
    BZERO(&pcb->ipcp_hisoptions, sizeof(ipcp_options));
 8015e64:	697b      	ldr	r3, [r7, #20]
 8015e66:	4a09      	ldr	r2, [pc, #36]	; (8015e8c <ipcp_resetci+0x138>)
 8015e68:	4694      	mov	ip, r2
 8015e6a:	4463      	add	r3, ip
 8015e6c:	2218      	movs	r2, #24
 8015e6e:	2100      	movs	r1, #0
 8015e70:	0018      	movs	r0, r3
 8015e72:	f008 f8af 	bl	801dfd4 <memset>
}
 8015e76:	46c0      	nop			; (mov r8, r8)
 8015e78:	46bd      	mov	sp, r7
 8015e7a:	b007      	add	sp, #28
 8015e7c:	bd90      	pop	{r4, r7, pc}
 8015e7e:	46c0      	nop			; (mov r8, r8)
 8015e80:	00001204 	.word	0x00001204
 8015e84:	0000121c 	.word	0x0000121c
 8015e88:	00001234 	.word	0x00001234
 8015e8c:	0000124c 	.word	0x0000124c

08015e90 <ipcp_cilen>:

/*
 * ipcp_cilen - Return length of our CI.
 * Called by fsm_sconfreq, Send Configure Request.
 */
static int ipcp_cilen(fsm *f) {
 8015e90:	b580      	push	{r7, lr}
 8015e92:	b086      	sub	sp, #24
 8015e94:	af00      	add	r7, sp, #0
 8015e96:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8015e98:	687b      	ldr	r3, [r7, #4]
 8015e9a:	681b      	ldr	r3, [r3, #0]
 8015e9c:	617b      	str	r3, [r7, #20]
    ipcp_options *go = &pcb->ipcp_gotoptions;
 8015e9e:	697b      	ldr	r3, [r7, #20]
 8015ea0:	4a54      	ldr	r2, [pc, #336]	; (8015ff4 <ipcp_cilen+0x164>)
 8015ea2:	4694      	mov	ip, r2
 8015ea4:	4463      	add	r3, ip
 8015ea6:	613b      	str	r3, [r7, #16]
#if VJ_SUPPORT
    ipcp_options *wo = &pcb->ipcp_wantoptions;
 8015ea8:	697b      	ldr	r3, [r7, #20]
 8015eaa:	4a53      	ldr	r2, [pc, #332]	; (8015ff8 <ipcp_cilen+0x168>)
 8015eac:	4694      	mov	ip, r2
 8015eae:	4463      	add	r3, ip
 8015eb0:	60fb      	str	r3, [r7, #12]
#endif /* VJ_SUPPORT */
    ipcp_options *ho = &pcb->ipcp_hisoptions;
 8015eb2:	697b      	ldr	r3, [r7, #20]
 8015eb4:	4a51      	ldr	r2, [pc, #324]	; (8015ffc <ipcp_cilen+0x16c>)
 8015eb6:	4694      	mov	ip, r2
 8015eb8:	4463      	add	r3, ip
 8015eba:	60bb      	str	r3, [r7, #8]

    /*
     * First see if we want to change our options to the old
     * forms because we have received old forms from the peer.
     */
    if (go->neg_addr && go->old_addrs && !ho->neg_addr && ho->old_addrs)
 8015ebc:	693b      	ldr	r3, [r7, #16]
 8015ebe:	781b      	ldrb	r3, [r3, #0]
 8015ec0:	2201      	movs	r2, #1
 8015ec2:	4013      	ands	r3, r2
 8015ec4:	b2db      	uxtb	r3, r3
 8015ec6:	2b00      	cmp	r3, #0
 8015ec8:	d019      	beq.n	8015efe <ipcp_cilen+0x6e>
 8015eca:	693b      	ldr	r3, [r7, #16]
 8015ecc:	781b      	ldrb	r3, [r3, #0]
 8015ece:	2202      	movs	r2, #2
 8015ed0:	4013      	ands	r3, r2
 8015ed2:	b2db      	uxtb	r3, r3
 8015ed4:	2b00      	cmp	r3, #0
 8015ed6:	d012      	beq.n	8015efe <ipcp_cilen+0x6e>
 8015ed8:	68bb      	ldr	r3, [r7, #8]
 8015eda:	781b      	ldrb	r3, [r3, #0]
 8015edc:	2201      	movs	r2, #1
 8015ede:	4013      	ands	r3, r2
 8015ee0:	b2db      	uxtb	r3, r3
 8015ee2:	2b00      	cmp	r3, #0
 8015ee4:	d10b      	bne.n	8015efe <ipcp_cilen+0x6e>
 8015ee6:	68bb      	ldr	r3, [r7, #8]
 8015ee8:	781b      	ldrb	r3, [r3, #0]
 8015eea:	2202      	movs	r2, #2
 8015eec:	4013      	ands	r3, r2
 8015eee:	b2db      	uxtb	r3, r3
 8015ef0:	2b00      	cmp	r3, #0
 8015ef2:	d004      	beq.n	8015efe <ipcp_cilen+0x6e>
	go->neg_addr = 0;
 8015ef4:	693b      	ldr	r3, [r7, #16]
 8015ef6:	781a      	ldrb	r2, [r3, #0]
 8015ef8:	2101      	movs	r1, #1
 8015efa:	438a      	bics	r2, r1
 8015efc:	701a      	strb	r2, [r3, #0]

#if VJ_SUPPORT
    if (wo->neg_vj && !go->neg_vj && !go->old_vj) {
 8015efe:	68fb      	ldr	r3, [r7, #12]
 8015f00:	781b      	ldrb	r3, [r3, #0]
 8015f02:	2208      	movs	r2, #8
 8015f04:	4013      	ands	r3, r2
 8015f06:	b2db      	uxtb	r3, r3
 8015f08:	2b00      	cmp	r3, #0
 8015f0a:	d029      	beq.n	8015f60 <ipcp_cilen+0xd0>
 8015f0c:	693b      	ldr	r3, [r7, #16]
 8015f0e:	781b      	ldrb	r3, [r3, #0]
 8015f10:	2208      	movs	r2, #8
 8015f12:	4013      	ands	r3, r2
 8015f14:	b2db      	uxtb	r3, r3
 8015f16:	2b00      	cmp	r3, #0
 8015f18:	d122      	bne.n	8015f60 <ipcp_cilen+0xd0>
 8015f1a:	693b      	ldr	r3, [r7, #16]
 8015f1c:	781b      	ldrb	r3, [r3, #0]
 8015f1e:	2210      	movs	r2, #16
 8015f20:	4013      	ands	r3, r2
 8015f22:	b2db      	uxtb	r3, r3
 8015f24:	2b00      	cmp	r3, #0
 8015f26:	d11b      	bne.n	8015f60 <ipcp_cilen+0xd0>
	/* try an older style of VJ negotiation */
	/* use the old style only if the peer did */
	if (ho->neg_vj && ho->old_vj) {
 8015f28:	68bb      	ldr	r3, [r7, #8]
 8015f2a:	781b      	ldrb	r3, [r3, #0]
 8015f2c:	2208      	movs	r2, #8
 8015f2e:	4013      	ands	r3, r2
 8015f30:	b2db      	uxtb	r3, r3
 8015f32:	2b00      	cmp	r3, #0
 8015f34:	d014      	beq.n	8015f60 <ipcp_cilen+0xd0>
 8015f36:	68bb      	ldr	r3, [r7, #8]
 8015f38:	781b      	ldrb	r3, [r3, #0]
 8015f3a:	2210      	movs	r2, #16
 8015f3c:	4013      	ands	r3, r2
 8015f3e:	b2db      	uxtb	r3, r3
 8015f40:	2b00      	cmp	r3, #0
 8015f42:	d00d      	beq.n	8015f60 <ipcp_cilen+0xd0>
	    go->neg_vj = 1;
 8015f44:	693b      	ldr	r3, [r7, #16]
 8015f46:	781a      	ldrb	r2, [r3, #0]
 8015f48:	2108      	movs	r1, #8
 8015f4a:	430a      	orrs	r2, r1
 8015f4c:	701a      	strb	r2, [r3, #0]
	    go->old_vj = 1;
 8015f4e:	693b      	ldr	r3, [r7, #16]
 8015f50:	781a      	ldrb	r2, [r3, #0]
 8015f52:	2110      	movs	r1, #16
 8015f54:	430a      	orrs	r2, r1
 8015f56:	701a      	strb	r2, [r3, #0]
	    go->vj_protocol = ho->vj_protocol;
 8015f58:	68bb      	ldr	r3, [r7, #8]
 8015f5a:	8a9a      	ldrh	r2, [r3, #20]
 8015f5c:	693b      	ldr	r3, [r7, #16]
 8015f5e:	829a      	strh	r2, [r3, #20]
	}
    }
#endif /* VJ_SUPPORT */

    return (LENCIADDRS(!go->neg_addr && go->old_addrs) +
 8015f60:	693b      	ldr	r3, [r7, #16]
 8015f62:	781b      	ldrb	r3, [r3, #0]
 8015f64:	2201      	movs	r2, #1
 8015f66:	4013      	ands	r3, r2
 8015f68:	b2db      	uxtb	r3, r3
 8015f6a:	2b00      	cmp	r3, #0
 8015f6c:	d108      	bne.n	8015f80 <ipcp_cilen+0xf0>
 8015f6e:	693b      	ldr	r3, [r7, #16]
 8015f70:	781b      	ldrb	r3, [r3, #0]
 8015f72:	2202      	movs	r2, #2
 8015f74:	4013      	ands	r3, r2
 8015f76:	b2db      	uxtb	r3, r3
 8015f78:	2b00      	cmp	r3, #0
 8015f7a:	d001      	beq.n	8015f80 <ipcp_cilen+0xf0>
 8015f7c:	220a      	movs	r2, #10
 8015f7e:	e000      	b.n	8015f82 <ipcp_cilen+0xf2>
 8015f80:	2200      	movs	r2, #0
#if VJ_SUPPORT
	    LENCIVJ(go->neg_vj, go->old_vj) +
 8015f82:	693b      	ldr	r3, [r7, #16]
 8015f84:	781b      	ldrb	r3, [r3, #0]
 8015f86:	2108      	movs	r1, #8
 8015f88:	400b      	ands	r3, r1
 8015f8a:	b2db      	uxtb	r3, r3
 8015f8c:	2b00      	cmp	r3, #0
 8015f8e:	d00a      	beq.n	8015fa6 <ipcp_cilen+0x116>
 8015f90:	693b      	ldr	r3, [r7, #16]
 8015f92:	781b      	ldrb	r3, [r3, #0]
 8015f94:	2110      	movs	r1, #16
 8015f96:	400b      	ands	r3, r1
 8015f98:	b2db      	uxtb	r3, r3
 8015f9a:	2b00      	cmp	r3, #0
 8015f9c:	d001      	beq.n	8015fa2 <ipcp_cilen+0x112>
 8015f9e:	2304      	movs	r3, #4
 8015fa0:	e002      	b.n	8015fa8 <ipcp_cilen+0x118>
 8015fa2:	2306      	movs	r3, #6
 8015fa4:	e000      	b.n	8015fa8 <ipcp_cilen+0x118>
 8015fa6:	2300      	movs	r3, #0
    return (LENCIADDRS(!go->neg_addr && go->old_addrs) +
 8015fa8:	18d2      	adds	r2, r2, r3
#endif /* VJ_SUPPORT */
	    LENCIADDR(go->neg_addr) +
 8015faa:	693b      	ldr	r3, [r7, #16]
 8015fac:	781b      	ldrb	r3, [r3, #0]
 8015fae:	2101      	movs	r1, #1
 8015fb0:	400b      	ands	r3, r1
 8015fb2:	b2db      	uxtb	r3, r3
 8015fb4:	2b00      	cmp	r3, #0
 8015fb6:	d001      	beq.n	8015fbc <ipcp_cilen+0x12c>
 8015fb8:	2306      	movs	r3, #6
 8015fba:	e000      	b.n	8015fbe <ipcp_cilen+0x12e>
 8015fbc:	2300      	movs	r3, #0
	    LENCIVJ(go->neg_vj, go->old_vj) +
 8015fbe:	189a      	adds	r2, r3, r2
#if LWIP_DNS
	    LENCIDNS(go->req_dns1) +
 8015fc0:	693b      	ldr	r3, [r7, #16]
 8015fc2:	785b      	ldrb	r3, [r3, #1]
 8015fc4:	2101      	movs	r1, #1
 8015fc6:	400b      	ands	r3, r1
 8015fc8:	b2db      	uxtb	r3, r3
 8015fca:	2b00      	cmp	r3, #0
 8015fcc:	d001      	beq.n	8015fd2 <ipcp_cilen+0x142>
 8015fce:	2306      	movs	r3, #6
 8015fd0:	e000      	b.n	8015fd4 <ipcp_cilen+0x144>
 8015fd2:	2300      	movs	r3, #0
	    LENCIADDR(go->neg_addr) +
 8015fd4:	189a      	adds	r2, r3, r2
	    LENCIDNS(go->req_dns2) +
 8015fd6:	693b      	ldr	r3, [r7, #16]
 8015fd8:	785b      	ldrb	r3, [r3, #1]
 8015fda:	2102      	movs	r1, #2
 8015fdc:	400b      	ands	r3, r1
 8015fde:	b2db      	uxtb	r3, r3
 8015fe0:	2b00      	cmp	r3, #0
 8015fe2:	d001      	beq.n	8015fe8 <ipcp_cilen+0x158>
 8015fe4:	2306      	movs	r3, #6
 8015fe6:	e000      	b.n	8015fea <ipcp_cilen+0x15a>
 8015fe8:	2300      	movs	r3, #0
 8015fea:	189b      	adds	r3, r3, r2
#if 0 /* UNUSED - WINS */
	    LENCIWINS(go->winsaddr[0]) +
	    LENCIWINS(go->winsaddr[1]) +
#endif /* UNUSED - WINS */
	    0);
}
 8015fec:	0018      	movs	r0, r3
 8015fee:	46bd      	mov	sp, r7
 8015ff0:	b006      	add	sp, #24
 8015ff2:	bd80      	pop	{r7, pc}
 8015ff4:	0000121c 	.word	0x0000121c
 8015ff8:	00001204 	.word	0x00001204
 8015ffc:	0000124c 	.word	0x0000124c

08016000 <ipcp_addci>:

/*
 * ipcp_addci - Add our desired CIs to a packet.
 * Called by fsm_sconfreq, Send Configure Request.
 */
static void ipcp_addci(fsm *f, u_char *ucp, int *lenp) {
 8016000:	b580      	push	{r7, lr}
 8016002:	b08c      	sub	sp, #48	; 0x30
 8016004:	af00      	add	r7, sp, #0
 8016006:	60f8      	str	r0, [r7, #12]
 8016008:	60b9      	str	r1, [r7, #8]
 801600a:	607a      	str	r2, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 801600c:	68fb      	ldr	r3, [r7, #12]
 801600e:	681b      	ldr	r3, [r3, #0]
 8016010:	62bb      	str	r3, [r7, #40]	; 0x28
    ipcp_options *go = &pcb->ipcp_gotoptions;
 8016012:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016014:	4ac3      	ldr	r2, [pc, #780]	; (8016324 <ipcp_addci+0x324>)
 8016016:	4694      	mov	ip, r2
 8016018:	4463      	add	r3, ip
 801601a:	627b      	str	r3, [r7, #36]	; 0x24
    int len = *lenp;
 801601c:	687b      	ldr	r3, [r7, #4]
 801601e:	681b      	ldr	r3, [r3, #0]
 8016020:	62fb      	str	r3, [r7, #44]	; 0x2c
	} else \
	    addr = 0; \
    }
#endif /* UNUSED - WINS */

    ADDCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs, go->ouraddr,
 8016022:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016024:	781b      	ldrb	r3, [r3, #0]
 8016026:	2201      	movs	r2, #1
 8016028:	4013      	ands	r3, r2
 801602a:	b2db      	uxtb	r3, r3
 801602c:	2b00      	cmp	r3, #0
 801602e:	d160      	bne.n	80160f2 <ipcp_addci+0xf2>
 8016030:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016032:	781b      	ldrb	r3, [r3, #0]
 8016034:	2202      	movs	r2, #2
 8016036:	4013      	ands	r3, r2
 8016038:	b2db      	uxtb	r3, r3
 801603a:	2b00      	cmp	r3, #0
 801603c:	d059      	beq.n	80160f2 <ipcp_addci+0xf2>
 801603e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016040:	2b09      	cmp	r3, #9
 8016042:	dd51      	ble.n	80160e8 <ipcp_addci+0xe8>
 8016044:	68bb      	ldr	r3, [r7, #8]
 8016046:	1c5a      	adds	r2, r3, #1
 8016048:	60ba      	str	r2, [r7, #8]
 801604a:	2201      	movs	r2, #1
 801604c:	701a      	strb	r2, [r3, #0]
 801604e:	68bb      	ldr	r3, [r7, #8]
 8016050:	1c5a      	adds	r2, r3, #1
 8016052:	60ba      	str	r2, [r7, #8]
 8016054:	220a      	movs	r2, #10
 8016056:	701a      	strb	r2, [r3, #0]
 8016058:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801605a:	685b      	ldr	r3, [r3, #4]
 801605c:	0018      	movs	r0, r3
 801605e:	f7f1 f9e5 	bl	800742c <lwip_htonl>
 8016062:	0003      	movs	r3, r0
 8016064:	623b      	str	r3, [r7, #32]
 8016066:	6a3b      	ldr	r3, [r7, #32]
 8016068:	0e19      	lsrs	r1, r3, #24
 801606a:	68bb      	ldr	r3, [r7, #8]
 801606c:	1c5a      	adds	r2, r3, #1
 801606e:	60ba      	str	r2, [r7, #8]
 8016070:	b2ca      	uxtb	r2, r1
 8016072:	701a      	strb	r2, [r3, #0]
 8016074:	6a3b      	ldr	r3, [r7, #32]
 8016076:	0c19      	lsrs	r1, r3, #16
 8016078:	68bb      	ldr	r3, [r7, #8]
 801607a:	1c5a      	adds	r2, r3, #1
 801607c:	60ba      	str	r2, [r7, #8]
 801607e:	b2ca      	uxtb	r2, r1
 8016080:	701a      	strb	r2, [r3, #0]
 8016082:	6a3b      	ldr	r3, [r7, #32]
 8016084:	0a19      	lsrs	r1, r3, #8
 8016086:	68bb      	ldr	r3, [r7, #8]
 8016088:	1c5a      	adds	r2, r3, #1
 801608a:	60ba      	str	r2, [r7, #8]
 801608c:	b2ca      	uxtb	r2, r1
 801608e:	701a      	strb	r2, [r3, #0]
 8016090:	68bb      	ldr	r3, [r7, #8]
 8016092:	1c5a      	adds	r2, r3, #1
 8016094:	60ba      	str	r2, [r7, #8]
 8016096:	6a3a      	ldr	r2, [r7, #32]
 8016098:	b2d2      	uxtb	r2, r2
 801609a:	701a      	strb	r2, [r3, #0]
 801609c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801609e:	689b      	ldr	r3, [r3, #8]
 80160a0:	0018      	movs	r0, r3
 80160a2:	f7f1 f9c3 	bl	800742c <lwip_htonl>
 80160a6:	0003      	movs	r3, r0
 80160a8:	623b      	str	r3, [r7, #32]
 80160aa:	6a3b      	ldr	r3, [r7, #32]
 80160ac:	0e19      	lsrs	r1, r3, #24
 80160ae:	68bb      	ldr	r3, [r7, #8]
 80160b0:	1c5a      	adds	r2, r3, #1
 80160b2:	60ba      	str	r2, [r7, #8]
 80160b4:	b2ca      	uxtb	r2, r1
 80160b6:	701a      	strb	r2, [r3, #0]
 80160b8:	6a3b      	ldr	r3, [r7, #32]
 80160ba:	0c19      	lsrs	r1, r3, #16
 80160bc:	68bb      	ldr	r3, [r7, #8]
 80160be:	1c5a      	adds	r2, r3, #1
 80160c0:	60ba      	str	r2, [r7, #8]
 80160c2:	b2ca      	uxtb	r2, r1
 80160c4:	701a      	strb	r2, [r3, #0]
 80160c6:	6a3b      	ldr	r3, [r7, #32]
 80160c8:	0a19      	lsrs	r1, r3, #8
 80160ca:	68bb      	ldr	r3, [r7, #8]
 80160cc:	1c5a      	adds	r2, r3, #1
 80160ce:	60ba      	str	r2, [r7, #8]
 80160d0:	b2ca      	uxtb	r2, r1
 80160d2:	701a      	strb	r2, [r3, #0]
 80160d4:	68bb      	ldr	r3, [r7, #8]
 80160d6:	1c5a      	adds	r2, r3, #1
 80160d8:	60ba      	str	r2, [r7, #8]
 80160da:	6a3a      	ldr	r2, [r7, #32]
 80160dc:	b2d2      	uxtb	r2, r2
 80160de:	701a      	strb	r2, [r3, #0]
 80160e0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80160e2:	3b0a      	subs	r3, #10
 80160e4:	62fb      	str	r3, [r7, #44]	; 0x2c
 80160e6:	e004      	b.n	80160f2 <ipcp_addci+0xf2>
 80160e8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80160ea:	781a      	ldrb	r2, [r3, #0]
 80160ec:	2102      	movs	r1, #2
 80160ee:	438a      	bics	r2, r1
 80160f0:	701a      	strb	r2, [r3, #0]
	       go->hisaddr);

#if VJ_SUPPORT
    ADDCIVJ(CI_COMPRESSTYPE, go->neg_vj, go->vj_protocol, go->old_vj,
 80160f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80160f4:	781b      	ldrb	r3, [r3, #0]
 80160f6:	2208      	movs	r2, #8
 80160f8:	4013      	ands	r3, r2
 80160fa:	b2db      	uxtb	r3, r3
 80160fc:	2b00      	cmp	r3, #0
 80160fe:	d04a      	beq.n	8016196 <ipcp_addci+0x196>
 8016100:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016102:	781b      	ldrb	r3, [r3, #0]
 8016104:	2210      	movs	r2, #16
 8016106:	4013      	ands	r3, r2
 8016108:	b2db      	uxtb	r3, r3
 801610a:	2b00      	cmp	r3, #0
 801610c:	d001      	beq.n	8016112 <ipcp_addci+0x112>
 801610e:	2304      	movs	r3, #4
 8016110:	e000      	b.n	8016114 <ipcp_addci+0x114>
 8016112:	2306      	movs	r3, #6
 8016114:	61fb      	str	r3, [r7, #28]
 8016116:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8016118:	69fb      	ldr	r3, [r7, #28]
 801611a:	429a      	cmp	r2, r3
 801611c:	db36      	blt.n	801618c <ipcp_addci+0x18c>
 801611e:	68bb      	ldr	r3, [r7, #8]
 8016120:	1c5a      	adds	r2, r3, #1
 8016122:	60ba      	str	r2, [r7, #8]
 8016124:	2202      	movs	r2, #2
 8016126:	701a      	strb	r2, [r3, #0]
 8016128:	68bb      	ldr	r3, [r7, #8]
 801612a:	1c5a      	adds	r2, r3, #1
 801612c:	60ba      	str	r2, [r7, #8]
 801612e:	69fa      	ldr	r2, [r7, #28]
 8016130:	b2d2      	uxtb	r2, r2
 8016132:	701a      	strb	r2, [r3, #0]
 8016134:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016136:	8a9b      	ldrh	r3, [r3, #20]
 8016138:	0a1b      	lsrs	r3, r3, #8
 801613a:	b299      	uxth	r1, r3
 801613c:	68bb      	ldr	r3, [r7, #8]
 801613e:	1c5a      	adds	r2, r3, #1
 8016140:	60ba      	str	r2, [r7, #8]
 8016142:	b2ca      	uxtb	r2, r1
 8016144:	701a      	strb	r2, [r3, #0]
 8016146:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016148:	8a99      	ldrh	r1, [r3, #20]
 801614a:	68bb      	ldr	r3, [r7, #8]
 801614c:	1c5a      	adds	r2, r3, #1
 801614e:	60ba      	str	r2, [r7, #8]
 8016150:	b2ca      	uxtb	r2, r1
 8016152:	701a      	strb	r2, [r3, #0]
 8016154:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016156:	781b      	ldrb	r3, [r3, #0]
 8016158:	2210      	movs	r2, #16
 801615a:	4013      	ands	r3, r2
 801615c:	b2db      	uxtb	r3, r3
 801615e:	2b00      	cmp	r3, #0
 8016160:	d10f      	bne.n	8016182 <ipcp_addci+0x182>
 8016162:	68bb      	ldr	r3, [r7, #8]
 8016164:	1c5a      	adds	r2, r3, #1
 8016166:	60ba      	str	r2, [r7, #8]
 8016168:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801616a:	7d92      	ldrb	r2, [r2, #22]
 801616c:	701a      	strb	r2, [r3, #0]
 801616e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016170:	781b      	ldrb	r3, [r3, #0]
 8016172:	069b      	lsls	r3, r3, #26
 8016174:	0fdb      	lsrs	r3, r3, #31
 8016176:	b2d9      	uxtb	r1, r3
 8016178:	68bb      	ldr	r3, [r7, #8]
 801617a:	1c5a      	adds	r2, r3, #1
 801617c:	60ba      	str	r2, [r7, #8]
 801617e:	000a      	movs	r2, r1
 8016180:	701a      	strb	r2, [r3, #0]
 8016182:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8016184:	69fb      	ldr	r3, [r7, #28]
 8016186:	1ad3      	subs	r3, r2, r3
 8016188:	62fb      	str	r3, [r7, #44]	; 0x2c
 801618a:	e004      	b.n	8016196 <ipcp_addci+0x196>
 801618c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801618e:	781a      	ldrb	r2, [r3, #0]
 8016190:	2108      	movs	r1, #8
 8016192:	438a      	bics	r2, r1
 8016194:	701a      	strb	r2, [r3, #0]
	    go->maxslotindex, go->cflag);
#endif /* VJ_SUPPORT */

    ADDCIADDR(CI_ADDR, go->neg_addr, go->ouraddr);
 8016196:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016198:	781b      	ldrb	r3, [r3, #0]
 801619a:	2201      	movs	r2, #1
 801619c:	4013      	ands	r3, r2
 801619e:	b2db      	uxtb	r3, r3
 80161a0:	2b00      	cmp	r3, #0
 80161a2:	d037      	beq.n	8016214 <ipcp_addci+0x214>
 80161a4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80161a6:	2b05      	cmp	r3, #5
 80161a8:	dd2f      	ble.n	801620a <ipcp_addci+0x20a>
 80161aa:	68bb      	ldr	r3, [r7, #8]
 80161ac:	1c5a      	adds	r2, r3, #1
 80161ae:	60ba      	str	r2, [r7, #8]
 80161b0:	2203      	movs	r2, #3
 80161b2:	701a      	strb	r2, [r3, #0]
 80161b4:	68bb      	ldr	r3, [r7, #8]
 80161b6:	1c5a      	adds	r2, r3, #1
 80161b8:	60ba      	str	r2, [r7, #8]
 80161ba:	2206      	movs	r2, #6
 80161bc:	701a      	strb	r2, [r3, #0]
 80161be:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80161c0:	685b      	ldr	r3, [r3, #4]
 80161c2:	0018      	movs	r0, r3
 80161c4:	f7f1 f932 	bl	800742c <lwip_htonl>
 80161c8:	0003      	movs	r3, r0
 80161ca:	61bb      	str	r3, [r7, #24]
 80161cc:	69bb      	ldr	r3, [r7, #24]
 80161ce:	0e19      	lsrs	r1, r3, #24
 80161d0:	68bb      	ldr	r3, [r7, #8]
 80161d2:	1c5a      	adds	r2, r3, #1
 80161d4:	60ba      	str	r2, [r7, #8]
 80161d6:	b2ca      	uxtb	r2, r1
 80161d8:	701a      	strb	r2, [r3, #0]
 80161da:	69bb      	ldr	r3, [r7, #24]
 80161dc:	0c19      	lsrs	r1, r3, #16
 80161de:	68bb      	ldr	r3, [r7, #8]
 80161e0:	1c5a      	adds	r2, r3, #1
 80161e2:	60ba      	str	r2, [r7, #8]
 80161e4:	b2ca      	uxtb	r2, r1
 80161e6:	701a      	strb	r2, [r3, #0]
 80161e8:	69bb      	ldr	r3, [r7, #24]
 80161ea:	0a19      	lsrs	r1, r3, #8
 80161ec:	68bb      	ldr	r3, [r7, #8]
 80161ee:	1c5a      	adds	r2, r3, #1
 80161f0:	60ba      	str	r2, [r7, #8]
 80161f2:	b2ca      	uxtb	r2, r1
 80161f4:	701a      	strb	r2, [r3, #0]
 80161f6:	68bb      	ldr	r3, [r7, #8]
 80161f8:	1c5a      	adds	r2, r3, #1
 80161fa:	60ba      	str	r2, [r7, #8]
 80161fc:	69ba      	ldr	r2, [r7, #24]
 80161fe:	b2d2      	uxtb	r2, r2
 8016200:	701a      	strb	r2, [r3, #0]
 8016202:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016204:	3b06      	subs	r3, #6
 8016206:	62fb      	str	r3, [r7, #44]	; 0x2c
 8016208:	e004      	b.n	8016214 <ipcp_addci+0x214>
 801620a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801620c:	781a      	ldrb	r2, [r3, #0]
 801620e:	2101      	movs	r1, #1
 8016210:	438a      	bics	r2, r1
 8016212:	701a      	strb	r2, [r3, #0]

#if LWIP_DNS
    ADDCIDNS(CI_MS_DNS1, go->req_dns1, go->dnsaddr[0]);
 8016214:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016216:	785b      	ldrb	r3, [r3, #1]
 8016218:	2201      	movs	r2, #1
 801621a:	4013      	ands	r3, r2
 801621c:	b2db      	uxtb	r3, r3
 801621e:	2b00      	cmp	r3, #0
 8016220:	d037      	beq.n	8016292 <ipcp_addci+0x292>
 8016222:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016224:	2b05      	cmp	r3, #5
 8016226:	dd2f      	ble.n	8016288 <ipcp_addci+0x288>
 8016228:	68bb      	ldr	r3, [r7, #8]
 801622a:	1c5a      	adds	r2, r3, #1
 801622c:	60ba      	str	r2, [r7, #8]
 801622e:	2281      	movs	r2, #129	; 0x81
 8016230:	701a      	strb	r2, [r3, #0]
 8016232:	68bb      	ldr	r3, [r7, #8]
 8016234:	1c5a      	adds	r2, r3, #1
 8016236:	60ba      	str	r2, [r7, #8]
 8016238:	2206      	movs	r2, #6
 801623a:	701a      	strb	r2, [r3, #0]
 801623c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801623e:	68db      	ldr	r3, [r3, #12]
 8016240:	0018      	movs	r0, r3
 8016242:	f7f1 f8f3 	bl	800742c <lwip_htonl>
 8016246:	0003      	movs	r3, r0
 8016248:	617b      	str	r3, [r7, #20]
 801624a:	697b      	ldr	r3, [r7, #20]
 801624c:	0e19      	lsrs	r1, r3, #24
 801624e:	68bb      	ldr	r3, [r7, #8]
 8016250:	1c5a      	adds	r2, r3, #1
 8016252:	60ba      	str	r2, [r7, #8]
 8016254:	b2ca      	uxtb	r2, r1
 8016256:	701a      	strb	r2, [r3, #0]
 8016258:	697b      	ldr	r3, [r7, #20]
 801625a:	0c19      	lsrs	r1, r3, #16
 801625c:	68bb      	ldr	r3, [r7, #8]
 801625e:	1c5a      	adds	r2, r3, #1
 8016260:	60ba      	str	r2, [r7, #8]
 8016262:	b2ca      	uxtb	r2, r1
 8016264:	701a      	strb	r2, [r3, #0]
 8016266:	697b      	ldr	r3, [r7, #20]
 8016268:	0a19      	lsrs	r1, r3, #8
 801626a:	68bb      	ldr	r3, [r7, #8]
 801626c:	1c5a      	adds	r2, r3, #1
 801626e:	60ba      	str	r2, [r7, #8]
 8016270:	b2ca      	uxtb	r2, r1
 8016272:	701a      	strb	r2, [r3, #0]
 8016274:	68bb      	ldr	r3, [r7, #8]
 8016276:	1c5a      	adds	r2, r3, #1
 8016278:	60ba      	str	r2, [r7, #8]
 801627a:	697a      	ldr	r2, [r7, #20]
 801627c:	b2d2      	uxtb	r2, r2
 801627e:	701a      	strb	r2, [r3, #0]
 8016280:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016282:	3b06      	subs	r3, #6
 8016284:	62fb      	str	r3, [r7, #44]	; 0x2c
 8016286:	e004      	b.n	8016292 <ipcp_addci+0x292>
 8016288:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801628a:	785a      	ldrb	r2, [r3, #1]
 801628c:	2101      	movs	r1, #1
 801628e:	438a      	bics	r2, r1
 8016290:	705a      	strb	r2, [r3, #1]

    ADDCIDNS(CI_MS_DNS2, go->req_dns2, go->dnsaddr[1]);
 8016292:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016294:	785b      	ldrb	r3, [r3, #1]
 8016296:	2202      	movs	r2, #2
 8016298:	4013      	ands	r3, r2
 801629a:	b2db      	uxtb	r3, r3
 801629c:	2b00      	cmp	r3, #0
 801629e:	d037      	beq.n	8016310 <ipcp_addci+0x310>
 80162a0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80162a2:	2b05      	cmp	r3, #5
 80162a4:	dd2f      	ble.n	8016306 <ipcp_addci+0x306>
 80162a6:	68bb      	ldr	r3, [r7, #8]
 80162a8:	1c5a      	adds	r2, r3, #1
 80162aa:	60ba      	str	r2, [r7, #8]
 80162ac:	2283      	movs	r2, #131	; 0x83
 80162ae:	701a      	strb	r2, [r3, #0]
 80162b0:	68bb      	ldr	r3, [r7, #8]
 80162b2:	1c5a      	adds	r2, r3, #1
 80162b4:	60ba      	str	r2, [r7, #8]
 80162b6:	2206      	movs	r2, #6
 80162b8:	701a      	strb	r2, [r3, #0]
 80162ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80162bc:	691b      	ldr	r3, [r3, #16]
 80162be:	0018      	movs	r0, r3
 80162c0:	f7f1 f8b4 	bl	800742c <lwip_htonl>
 80162c4:	0003      	movs	r3, r0
 80162c6:	613b      	str	r3, [r7, #16]
 80162c8:	693b      	ldr	r3, [r7, #16]
 80162ca:	0e19      	lsrs	r1, r3, #24
 80162cc:	68bb      	ldr	r3, [r7, #8]
 80162ce:	1c5a      	adds	r2, r3, #1
 80162d0:	60ba      	str	r2, [r7, #8]
 80162d2:	b2ca      	uxtb	r2, r1
 80162d4:	701a      	strb	r2, [r3, #0]
 80162d6:	693b      	ldr	r3, [r7, #16]
 80162d8:	0c19      	lsrs	r1, r3, #16
 80162da:	68bb      	ldr	r3, [r7, #8]
 80162dc:	1c5a      	adds	r2, r3, #1
 80162de:	60ba      	str	r2, [r7, #8]
 80162e0:	b2ca      	uxtb	r2, r1
 80162e2:	701a      	strb	r2, [r3, #0]
 80162e4:	693b      	ldr	r3, [r7, #16]
 80162e6:	0a19      	lsrs	r1, r3, #8
 80162e8:	68bb      	ldr	r3, [r7, #8]
 80162ea:	1c5a      	adds	r2, r3, #1
 80162ec:	60ba      	str	r2, [r7, #8]
 80162ee:	b2ca      	uxtb	r2, r1
 80162f0:	701a      	strb	r2, [r3, #0]
 80162f2:	68bb      	ldr	r3, [r7, #8]
 80162f4:	1c5a      	adds	r2, r3, #1
 80162f6:	60ba      	str	r2, [r7, #8]
 80162f8:	693a      	ldr	r2, [r7, #16]
 80162fa:	b2d2      	uxtb	r2, r2
 80162fc:	701a      	strb	r2, [r3, #0]
 80162fe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016300:	3b06      	subs	r3, #6
 8016302:	62fb      	str	r3, [r7, #44]	; 0x2c
 8016304:	e004      	b.n	8016310 <ipcp_addci+0x310>
 8016306:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016308:	785a      	ldrb	r2, [r3, #1]
 801630a:	2102      	movs	r1, #2
 801630c:	438a      	bics	r2, r1
 801630e:	705a      	strb	r2, [r3, #1]
    ADDCIWINS(CI_MS_WINS1, go->winsaddr[0]);

    ADDCIWINS(CI_MS_WINS2, go->winsaddr[1]);
#endif /* UNUSED - WINS */
    
    *lenp -= len;
 8016310:	687b      	ldr	r3, [r7, #4]
 8016312:	681a      	ldr	r2, [r3, #0]
 8016314:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016316:	1ad2      	subs	r2, r2, r3
 8016318:	687b      	ldr	r3, [r7, #4]
 801631a:	601a      	str	r2, [r3, #0]
}
 801631c:	46c0      	nop			; (mov r8, r8)
 801631e:	46bd      	mov	sp, r7
 8016320:	b00c      	add	sp, #48	; 0x30
 8016322:	bd80      	pop	{r7, pc}
 8016324:	0000121c 	.word	0x0000121c

08016328 <ipcp_ackci>:
 *
 * Returns:
 *	0 - Ack was bad.
 *	1 - Ack was good.
 */
static int ipcp_ackci(fsm *f, u_char *p, int len) {
 8016328:	b580      	push	{r7, lr}
 801632a:	b08e      	sub	sp, #56	; 0x38
 801632c:	af00      	add	r7, sp, #0
 801632e:	60f8      	str	r0, [r7, #12]
 8016330:	60b9      	str	r1, [r7, #8]
 8016332:	607a      	str	r2, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8016334:	68fb      	ldr	r3, [r7, #12]
 8016336:	681b      	ldr	r3, [r3, #0]
 8016338:	637b      	str	r3, [r7, #52]	; 0x34
    ipcp_options *go = &pcb->ipcp_gotoptions;
 801633a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801633c:	4a51      	ldr	r2, [pc, #324]	; (8016484 <ipcp_ackci+0x15c>)
 801633e:	4694      	mov	ip, r2
 8016340:	4463      	add	r3, ip
 8016342:	633b      	str	r3, [r7, #48]	; 0x30
	if (addr != cilong) \
	    goto bad; \
    }
#endif /* UNUSED - WINS */

    ACKCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs, go->ouraddr,
 8016344:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016346:	781b      	ldrb	r3, [r3, #0]
 8016348:	2201      	movs	r2, #1
 801634a:	4013      	ands	r3, r2
 801634c:	b2db      	uxtb	r3, r3
 801634e:	2b00      	cmp	r3, #0
 8016350:	d000      	beq.n	8016354 <ipcp_ackci+0x2c>
 8016352:	e086      	b.n	8016462 <ipcp_ackci+0x13a>
 8016354:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016356:	781b      	ldrb	r3, [r3, #0]
 8016358:	2202      	movs	r2, #2
 801635a:	4013      	ands	r3, r2
 801635c:	b2db      	uxtb	r3, r3
 801635e:	2b00      	cmp	r3, #0
 8016360:	d100      	bne.n	8016364 <ipcp_ackci+0x3c>
 8016362:	e07e      	b.n	8016462 <ipcp_ackci+0x13a>
 8016364:	687b      	ldr	r3, [r7, #4]
 8016366:	3b0a      	subs	r3, #10
 8016368:	607b      	str	r3, [r7, #4]
 801636a:	687b      	ldr	r3, [r7, #4]
 801636c:	2b00      	cmp	r3, #0
 801636e:	da00      	bge.n	8016372 <ipcp_ackci+0x4a>
 8016370:	e1f2      	b.n	8016758 <ipcp_ackci+0x430>
 8016372:	68bb      	ldr	r3, [r7, #8]
 8016374:	1c5a      	adds	r2, r3, #1
 8016376:	60ba      	str	r2, [r7, #8]
 8016378:	781a      	ldrb	r2, [r3, #0]
 801637a:	212e      	movs	r1, #46	; 0x2e
 801637c:	187b      	adds	r3, r7, r1
 801637e:	801a      	strh	r2, [r3, #0]
 8016380:	68bb      	ldr	r3, [r7, #8]
 8016382:	1c5a      	adds	r2, r3, #1
 8016384:	60ba      	str	r2, [r7, #8]
 8016386:	781a      	ldrb	r2, [r3, #0]
 8016388:	202c      	movs	r0, #44	; 0x2c
 801638a:	183b      	adds	r3, r7, r0
 801638c:	801a      	strh	r2, [r3, #0]
 801638e:	183b      	adds	r3, r7, r0
 8016390:	881b      	ldrh	r3, [r3, #0]
 8016392:	2b0a      	cmp	r3, #10
 8016394:	d000      	beq.n	8016398 <ipcp_ackci+0x70>
 8016396:	e1e1      	b.n	801675c <ipcp_ackci+0x434>
 8016398:	187b      	adds	r3, r7, r1
 801639a:	881b      	ldrh	r3, [r3, #0]
 801639c:	2b01      	cmp	r3, #1
 801639e:	d000      	beq.n	80163a2 <ipcp_ackci+0x7a>
 80163a0:	e1dc      	b.n	801675c <ipcp_ackci+0x434>
 80163a2:	68bb      	ldr	r3, [r7, #8]
 80163a4:	1c5a      	adds	r2, r3, #1
 80163a6:	60ba      	str	r2, [r7, #8]
 80163a8:	781b      	ldrb	r3, [r3, #0]
 80163aa:	021b      	lsls	r3, r3, #8
 80163ac:	62bb      	str	r3, [r7, #40]	; 0x28
 80163ae:	68bb      	ldr	r3, [r7, #8]
 80163b0:	1c5a      	adds	r2, r3, #1
 80163b2:	60ba      	str	r2, [r7, #8]
 80163b4:	781b      	ldrb	r3, [r3, #0]
 80163b6:	001a      	movs	r2, r3
 80163b8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80163ba:	4313      	orrs	r3, r2
 80163bc:	62bb      	str	r3, [r7, #40]	; 0x28
 80163be:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80163c0:	021b      	lsls	r3, r3, #8
 80163c2:	62bb      	str	r3, [r7, #40]	; 0x28
 80163c4:	68bb      	ldr	r3, [r7, #8]
 80163c6:	1c5a      	adds	r2, r3, #1
 80163c8:	60ba      	str	r2, [r7, #8]
 80163ca:	781b      	ldrb	r3, [r3, #0]
 80163cc:	001a      	movs	r2, r3
 80163ce:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80163d0:	4313      	orrs	r3, r2
 80163d2:	62bb      	str	r3, [r7, #40]	; 0x28
 80163d4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80163d6:	021b      	lsls	r3, r3, #8
 80163d8:	62bb      	str	r3, [r7, #40]	; 0x28
 80163da:	68bb      	ldr	r3, [r7, #8]
 80163dc:	1c5a      	adds	r2, r3, #1
 80163de:	60ba      	str	r2, [r7, #8]
 80163e0:	781b      	ldrb	r3, [r3, #0]
 80163e2:	001a      	movs	r2, r3
 80163e4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80163e6:	4313      	orrs	r3, r2
 80163e8:	62bb      	str	r3, [r7, #40]	; 0x28
 80163ea:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80163ec:	0018      	movs	r0, r3
 80163ee:	f7f1 f81d 	bl	800742c <lwip_htonl>
 80163f2:	0003      	movs	r3, r0
 80163f4:	627b      	str	r3, [r7, #36]	; 0x24
 80163f6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80163f8:	685b      	ldr	r3, [r3, #4]
 80163fa:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80163fc:	429a      	cmp	r2, r3
 80163fe:	d000      	beq.n	8016402 <ipcp_ackci+0xda>
 8016400:	e1ae      	b.n	8016760 <ipcp_ackci+0x438>
 8016402:	68bb      	ldr	r3, [r7, #8]
 8016404:	1c5a      	adds	r2, r3, #1
 8016406:	60ba      	str	r2, [r7, #8]
 8016408:	781b      	ldrb	r3, [r3, #0]
 801640a:	021b      	lsls	r3, r3, #8
 801640c:	62bb      	str	r3, [r7, #40]	; 0x28
 801640e:	68bb      	ldr	r3, [r7, #8]
 8016410:	1c5a      	adds	r2, r3, #1
 8016412:	60ba      	str	r2, [r7, #8]
 8016414:	781b      	ldrb	r3, [r3, #0]
 8016416:	001a      	movs	r2, r3
 8016418:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801641a:	4313      	orrs	r3, r2
 801641c:	62bb      	str	r3, [r7, #40]	; 0x28
 801641e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016420:	021b      	lsls	r3, r3, #8
 8016422:	62bb      	str	r3, [r7, #40]	; 0x28
 8016424:	68bb      	ldr	r3, [r7, #8]
 8016426:	1c5a      	adds	r2, r3, #1
 8016428:	60ba      	str	r2, [r7, #8]
 801642a:	781b      	ldrb	r3, [r3, #0]
 801642c:	001a      	movs	r2, r3
 801642e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016430:	4313      	orrs	r3, r2
 8016432:	62bb      	str	r3, [r7, #40]	; 0x28
 8016434:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016436:	021b      	lsls	r3, r3, #8
 8016438:	62bb      	str	r3, [r7, #40]	; 0x28
 801643a:	68bb      	ldr	r3, [r7, #8]
 801643c:	1c5a      	adds	r2, r3, #1
 801643e:	60ba      	str	r2, [r7, #8]
 8016440:	781b      	ldrb	r3, [r3, #0]
 8016442:	001a      	movs	r2, r3
 8016444:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016446:	4313      	orrs	r3, r2
 8016448:	62bb      	str	r3, [r7, #40]	; 0x28
 801644a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801644c:	0018      	movs	r0, r3
 801644e:	f7f0 ffed 	bl	800742c <lwip_htonl>
 8016452:	0003      	movs	r3, r0
 8016454:	627b      	str	r3, [r7, #36]	; 0x24
 8016456:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016458:	689b      	ldr	r3, [r3, #8]
 801645a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801645c:	429a      	cmp	r2, r3
 801645e:	d000      	beq.n	8016462 <ipcp_ackci+0x13a>
 8016460:	e180      	b.n	8016764 <ipcp_ackci+0x43c>
	       go->hisaddr);

#if VJ_SUPPORT
    ACKCIVJ(CI_COMPRESSTYPE, go->neg_vj, go->vj_protocol, go->old_vj,
 8016462:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016464:	781b      	ldrb	r3, [r3, #0]
 8016466:	2208      	movs	r2, #8
 8016468:	4013      	ands	r3, r2
 801646a:	b2db      	uxtb	r3, r3
 801646c:	2b00      	cmp	r3, #0
 801646e:	d100      	bne.n	8016472 <ipcp_ackci+0x14a>
 8016470:	e06e      	b.n	8016550 <ipcp_ackci+0x228>
 8016472:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016474:	781b      	ldrb	r3, [r3, #0]
 8016476:	2210      	movs	r2, #16
 8016478:	4013      	ands	r3, r2
 801647a:	b2db      	uxtb	r3, r3
 801647c:	2b00      	cmp	r3, #0
 801647e:	d003      	beq.n	8016488 <ipcp_ackci+0x160>
 8016480:	2304      	movs	r3, #4
 8016482:	e002      	b.n	801648a <ipcp_ackci+0x162>
 8016484:	0000121c 	.word	0x0000121c
 8016488:	2306      	movs	r3, #6
 801648a:	623b      	str	r3, [r7, #32]
 801648c:	687a      	ldr	r2, [r7, #4]
 801648e:	6a3b      	ldr	r3, [r7, #32]
 8016490:	1ad3      	subs	r3, r2, r3
 8016492:	607b      	str	r3, [r7, #4]
 8016494:	687b      	ldr	r3, [r7, #4]
 8016496:	2b00      	cmp	r3, #0
 8016498:	da00      	bge.n	801649c <ipcp_ackci+0x174>
 801649a:	e165      	b.n	8016768 <ipcp_ackci+0x440>
 801649c:	68bb      	ldr	r3, [r7, #8]
 801649e:	1c5a      	adds	r2, r3, #1
 80164a0:	60ba      	str	r2, [r7, #8]
 80164a2:	781a      	ldrb	r2, [r3, #0]
 80164a4:	212e      	movs	r1, #46	; 0x2e
 80164a6:	187b      	adds	r3, r7, r1
 80164a8:	801a      	strh	r2, [r3, #0]
 80164aa:	68bb      	ldr	r3, [r7, #8]
 80164ac:	1c5a      	adds	r2, r3, #1
 80164ae:	60ba      	str	r2, [r7, #8]
 80164b0:	781a      	ldrb	r2, [r3, #0]
 80164b2:	202c      	movs	r0, #44	; 0x2c
 80164b4:	183b      	adds	r3, r7, r0
 80164b6:	801a      	strh	r2, [r3, #0]
 80164b8:	183b      	adds	r3, r7, r0
 80164ba:	881b      	ldrh	r3, [r3, #0]
 80164bc:	6a3a      	ldr	r2, [r7, #32]
 80164be:	429a      	cmp	r2, r3
 80164c0:	d000      	beq.n	80164c4 <ipcp_ackci+0x19c>
 80164c2:	e153      	b.n	801676c <ipcp_ackci+0x444>
 80164c4:	187b      	adds	r3, r7, r1
 80164c6:	881b      	ldrh	r3, [r3, #0]
 80164c8:	2b02      	cmp	r3, #2
 80164ca:	d000      	beq.n	80164ce <ipcp_ackci+0x1a6>
 80164cc:	e14e      	b.n	801676c <ipcp_ackci+0x444>
 80164ce:	68bb      	ldr	r3, [r7, #8]
 80164d0:	1c5a      	adds	r2, r3, #1
 80164d2:	60ba      	str	r2, [r7, #8]
 80164d4:	781b      	ldrb	r3, [r3, #0]
 80164d6:	b29a      	uxth	r2, r3
 80164d8:	201e      	movs	r0, #30
 80164da:	183b      	adds	r3, r7, r0
 80164dc:	0212      	lsls	r2, r2, #8
 80164de:	801a      	strh	r2, [r3, #0]
 80164e0:	68bb      	ldr	r3, [r7, #8]
 80164e2:	1c5a      	adds	r2, r3, #1
 80164e4:	60ba      	str	r2, [r7, #8]
 80164e6:	781b      	ldrb	r3, [r3, #0]
 80164e8:	b299      	uxth	r1, r3
 80164ea:	183b      	adds	r3, r7, r0
 80164ec:	183a      	adds	r2, r7, r0
 80164ee:	8812      	ldrh	r2, [r2, #0]
 80164f0:	430a      	orrs	r2, r1
 80164f2:	801a      	strh	r2, [r3, #0]
 80164f4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80164f6:	8a9b      	ldrh	r3, [r3, #20]
 80164f8:	183a      	adds	r2, r7, r0
 80164fa:	8812      	ldrh	r2, [r2, #0]
 80164fc:	429a      	cmp	r2, r3
 80164fe:	d000      	beq.n	8016502 <ipcp_ackci+0x1da>
 8016500:	e136      	b.n	8016770 <ipcp_ackci+0x448>
 8016502:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016504:	781b      	ldrb	r3, [r3, #0]
 8016506:	2210      	movs	r2, #16
 8016508:	4013      	ands	r3, r2
 801650a:	b2db      	uxtb	r3, r3
 801650c:	2b00      	cmp	r3, #0
 801650e:	d11f      	bne.n	8016550 <ipcp_ackci+0x228>
 8016510:	68bb      	ldr	r3, [r7, #8]
 8016512:	1c5a      	adds	r2, r3, #1
 8016514:	60ba      	str	r2, [r7, #8]
 8016516:	211d      	movs	r1, #29
 8016518:	187a      	adds	r2, r7, r1
 801651a:	781b      	ldrb	r3, [r3, #0]
 801651c:	7013      	strb	r3, [r2, #0]
 801651e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016520:	7d9b      	ldrb	r3, [r3, #22]
 8016522:	187a      	adds	r2, r7, r1
 8016524:	7812      	ldrb	r2, [r2, #0]
 8016526:	429a      	cmp	r2, r3
 8016528:	d000      	beq.n	801652c <ipcp_ackci+0x204>
 801652a:	e123      	b.n	8016774 <ipcp_ackci+0x44c>
 801652c:	68bb      	ldr	r3, [r7, #8]
 801652e:	1c5a      	adds	r2, r3, #1
 8016530:	60ba      	str	r2, [r7, #8]
 8016532:	211c      	movs	r1, #28
 8016534:	187a      	adds	r2, r7, r1
 8016536:	781b      	ldrb	r3, [r3, #0]
 8016538:	7013      	strb	r3, [r2, #0]
 801653a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801653c:	781b      	ldrb	r3, [r3, #0]
 801653e:	069b      	lsls	r3, r3, #26
 8016540:	0fdb      	lsrs	r3, r3, #31
 8016542:	b2db      	uxtb	r3, r3
 8016544:	001a      	movs	r2, r3
 8016546:	187b      	adds	r3, r7, r1
 8016548:	781b      	ldrb	r3, [r3, #0]
 801654a:	4293      	cmp	r3, r2
 801654c:	d000      	beq.n	8016550 <ipcp_ackci+0x228>
 801654e:	e113      	b.n	8016778 <ipcp_ackci+0x450>
	    go->maxslotindex, go->cflag);
#endif /* VJ_SUPPORT */

    ACKCIADDR(CI_ADDR, go->neg_addr, go->ouraddr);
 8016550:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016552:	781b      	ldrb	r3, [r3, #0]
 8016554:	2201      	movs	r2, #1
 8016556:	4013      	ands	r3, r2
 8016558:	b2db      	uxtb	r3, r3
 801655a:	2b00      	cmp	r3, #0
 801655c:	d04e      	beq.n	80165fc <ipcp_ackci+0x2d4>
 801655e:	687b      	ldr	r3, [r7, #4]
 8016560:	3b06      	subs	r3, #6
 8016562:	607b      	str	r3, [r7, #4]
 8016564:	687b      	ldr	r3, [r7, #4]
 8016566:	2b00      	cmp	r3, #0
 8016568:	da00      	bge.n	801656c <ipcp_ackci+0x244>
 801656a:	e107      	b.n	801677c <ipcp_ackci+0x454>
 801656c:	68bb      	ldr	r3, [r7, #8]
 801656e:	1c5a      	adds	r2, r3, #1
 8016570:	60ba      	str	r2, [r7, #8]
 8016572:	781a      	ldrb	r2, [r3, #0]
 8016574:	212e      	movs	r1, #46	; 0x2e
 8016576:	187b      	adds	r3, r7, r1
 8016578:	801a      	strh	r2, [r3, #0]
 801657a:	68bb      	ldr	r3, [r7, #8]
 801657c:	1c5a      	adds	r2, r3, #1
 801657e:	60ba      	str	r2, [r7, #8]
 8016580:	781a      	ldrb	r2, [r3, #0]
 8016582:	202c      	movs	r0, #44	; 0x2c
 8016584:	183b      	adds	r3, r7, r0
 8016586:	801a      	strh	r2, [r3, #0]
 8016588:	183b      	adds	r3, r7, r0
 801658a:	881b      	ldrh	r3, [r3, #0]
 801658c:	2b06      	cmp	r3, #6
 801658e:	d000      	beq.n	8016592 <ipcp_ackci+0x26a>
 8016590:	e0f6      	b.n	8016780 <ipcp_ackci+0x458>
 8016592:	187b      	adds	r3, r7, r1
 8016594:	881b      	ldrh	r3, [r3, #0]
 8016596:	2b03      	cmp	r3, #3
 8016598:	d000      	beq.n	801659c <ipcp_ackci+0x274>
 801659a:	e0f1      	b.n	8016780 <ipcp_ackci+0x458>
 801659c:	68bb      	ldr	r3, [r7, #8]
 801659e:	1c5a      	adds	r2, r3, #1
 80165a0:	60ba      	str	r2, [r7, #8]
 80165a2:	781b      	ldrb	r3, [r3, #0]
 80165a4:	021b      	lsls	r3, r3, #8
 80165a6:	61bb      	str	r3, [r7, #24]
 80165a8:	68bb      	ldr	r3, [r7, #8]
 80165aa:	1c5a      	adds	r2, r3, #1
 80165ac:	60ba      	str	r2, [r7, #8]
 80165ae:	781b      	ldrb	r3, [r3, #0]
 80165b0:	001a      	movs	r2, r3
 80165b2:	69bb      	ldr	r3, [r7, #24]
 80165b4:	4313      	orrs	r3, r2
 80165b6:	61bb      	str	r3, [r7, #24]
 80165b8:	69bb      	ldr	r3, [r7, #24]
 80165ba:	021b      	lsls	r3, r3, #8
 80165bc:	61bb      	str	r3, [r7, #24]
 80165be:	68bb      	ldr	r3, [r7, #8]
 80165c0:	1c5a      	adds	r2, r3, #1
 80165c2:	60ba      	str	r2, [r7, #8]
 80165c4:	781b      	ldrb	r3, [r3, #0]
 80165c6:	001a      	movs	r2, r3
 80165c8:	69bb      	ldr	r3, [r7, #24]
 80165ca:	4313      	orrs	r3, r2
 80165cc:	61bb      	str	r3, [r7, #24]
 80165ce:	69bb      	ldr	r3, [r7, #24]
 80165d0:	021b      	lsls	r3, r3, #8
 80165d2:	61bb      	str	r3, [r7, #24]
 80165d4:	68bb      	ldr	r3, [r7, #8]
 80165d6:	1c5a      	adds	r2, r3, #1
 80165d8:	60ba      	str	r2, [r7, #8]
 80165da:	781b      	ldrb	r3, [r3, #0]
 80165dc:	001a      	movs	r2, r3
 80165de:	69bb      	ldr	r3, [r7, #24]
 80165e0:	4313      	orrs	r3, r2
 80165e2:	61bb      	str	r3, [r7, #24]
 80165e4:	69bb      	ldr	r3, [r7, #24]
 80165e6:	0018      	movs	r0, r3
 80165e8:	f7f0 ff20 	bl	800742c <lwip_htonl>
 80165ec:	0003      	movs	r3, r0
 80165ee:	627b      	str	r3, [r7, #36]	; 0x24
 80165f0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80165f2:	685b      	ldr	r3, [r3, #4]
 80165f4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80165f6:	429a      	cmp	r2, r3
 80165f8:	d000      	beq.n	80165fc <ipcp_ackci+0x2d4>
 80165fa:	e0c3      	b.n	8016784 <ipcp_ackci+0x45c>

#if LWIP_DNS
    ACKCIDNS(CI_MS_DNS1, go->req_dns1, go->dnsaddr[0]);
 80165fc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80165fe:	785b      	ldrb	r3, [r3, #1]
 8016600:	2201      	movs	r2, #1
 8016602:	4013      	ands	r3, r2
 8016604:	b2db      	uxtb	r3, r3
 8016606:	2b00      	cmp	r3, #0
 8016608:	d04e      	beq.n	80166a8 <ipcp_ackci+0x380>
 801660a:	687b      	ldr	r3, [r7, #4]
 801660c:	3b06      	subs	r3, #6
 801660e:	607b      	str	r3, [r7, #4]
 8016610:	687b      	ldr	r3, [r7, #4]
 8016612:	2b00      	cmp	r3, #0
 8016614:	da00      	bge.n	8016618 <ipcp_ackci+0x2f0>
 8016616:	e0b7      	b.n	8016788 <ipcp_ackci+0x460>
 8016618:	68bb      	ldr	r3, [r7, #8]
 801661a:	1c5a      	adds	r2, r3, #1
 801661c:	60ba      	str	r2, [r7, #8]
 801661e:	781a      	ldrb	r2, [r3, #0]
 8016620:	212e      	movs	r1, #46	; 0x2e
 8016622:	187b      	adds	r3, r7, r1
 8016624:	801a      	strh	r2, [r3, #0]
 8016626:	68bb      	ldr	r3, [r7, #8]
 8016628:	1c5a      	adds	r2, r3, #1
 801662a:	60ba      	str	r2, [r7, #8]
 801662c:	781a      	ldrb	r2, [r3, #0]
 801662e:	202c      	movs	r0, #44	; 0x2c
 8016630:	183b      	adds	r3, r7, r0
 8016632:	801a      	strh	r2, [r3, #0]
 8016634:	183b      	adds	r3, r7, r0
 8016636:	881b      	ldrh	r3, [r3, #0]
 8016638:	2b06      	cmp	r3, #6
 801663a:	d000      	beq.n	801663e <ipcp_ackci+0x316>
 801663c:	e0a6      	b.n	801678c <ipcp_ackci+0x464>
 801663e:	187b      	adds	r3, r7, r1
 8016640:	881b      	ldrh	r3, [r3, #0]
 8016642:	2b81      	cmp	r3, #129	; 0x81
 8016644:	d000      	beq.n	8016648 <ipcp_ackci+0x320>
 8016646:	e0a1      	b.n	801678c <ipcp_ackci+0x464>
 8016648:	68bb      	ldr	r3, [r7, #8]
 801664a:	1c5a      	adds	r2, r3, #1
 801664c:	60ba      	str	r2, [r7, #8]
 801664e:	781b      	ldrb	r3, [r3, #0]
 8016650:	021b      	lsls	r3, r3, #8
 8016652:	617b      	str	r3, [r7, #20]
 8016654:	68bb      	ldr	r3, [r7, #8]
 8016656:	1c5a      	adds	r2, r3, #1
 8016658:	60ba      	str	r2, [r7, #8]
 801665a:	781b      	ldrb	r3, [r3, #0]
 801665c:	001a      	movs	r2, r3
 801665e:	697b      	ldr	r3, [r7, #20]
 8016660:	4313      	orrs	r3, r2
 8016662:	617b      	str	r3, [r7, #20]
 8016664:	697b      	ldr	r3, [r7, #20]
 8016666:	021b      	lsls	r3, r3, #8
 8016668:	617b      	str	r3, [r7, #20]
 801666a:	68bb      	ldr	r3, [r7, #8]
 801666c:	1c5a      	adds	r2, r3, #1
 801666e:	60ba      	str	r2, [r7, #8]
 8016670:	781b      	ldrb	r3, [r3, #0]
 8016672:	001a      	movs	r2, r3
 8016674:	697b      	ldr	r3, [r7, #20]
 8016676:	4313      	orrs	r3, r2
 8016678:	617b      	str	r3, [r7, #20]
 801667a:	697b      	ldr	r3, [r7, #20]
 801667c:	021b      	lsls	r3, r3, #8
 801667e:	617b      	str	r3, [r7, #20]
 8016680:	68bb      	ldr	r3, [r7, #8]
 8016682:	1c5a      	adds	r2, r3, #1
 8016684:	60ba      	str	r2, [r7, #8]
 8016686:	781b      	ldrb	r3, [r3, #0]
 8016688:	001a      	movs	r2, r3
 801668a:	697b      	ldr	r3, [r7, #20]
 801668c:	4313      	orrs	r3, r2
 801668e:	617b      	str	r3, [r7, #20]
 8016690:	697b      	ldr	r3, [r7, #20]
 8016692:	0018      	movs	r0, r3
 8016694:	f7f0 feca 	bl	800742c <lwip_htonl>
 8016698:	0003      	movs	r3, r0
 801669a:	627b      	str	r3, [r7, #36]	; 0x24
 801669c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801669e:	68db      	ldr	r3, [r3, #12]
 80166a0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80166a2:	429a      	cmp	r2, r3
 80166a4:	d000      	beq.n	80166a8 <ipcp_ackci+0x380>
 80166a6:	e073      	b.n	8016790 <ipcp_ackci+0x468>

    ACKCIDNS(CI_MS_DNS2, go->req_dns2, go->dnsaddr[1]);
 80166a8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80166aa:	785b      	ldrb	r3, [r3, #1]
 80166ac:	2202      	movs	r2, #2
 80166ae:	4013      	ands	r3, r2
 80166b0:	b2db      	uxtb	r3, r3
 80166b2:	2b00      	cmp	r3, #0
 80166b4:	d04b      	beq.n	801674e <ipcp_ackci+0x426>
 80166b6:	687b      	ldr	r3, [r7, #4]
 80166b8:	3b06      	subs	r3, #6
 80166ba:	607b      	str	r3, [r7, #4]
 80166bc:	687b      	ldr	r3, [r7, #4]
 80166be:	2b00      	cmp	r3, #0
 80166c0:	da00      	bge.n	80166c4 <ipcp_ackci+0x39c>
 80166c2:	e067      	b.n	8016794 <ipcp_ackci+0x46c>
 80166c4:	68bb      	ldr	r3, [r7, #8]
 80166c6:	1c5a      	adds	r2, r3, #1
 80166c8:	60ba      	str	r2, [r7, #8]
 80166ca:	781a      	ldrb	r2, [r3, #0]
 80166cc:	212e      	movs	r1, #46	; 0x2e
 80166ce:	187b      	adds	r3, r7, r1
 80166d0:	801a      	strh	r2, [r3, #0]
 80166d2:	68bb      	ldr	r3, [r7, #8]
 80166d4:	1c5a      	adds	r2, r3, #1
 80166d6:	60ba      	str	r2, [r7, #8]
 80166d8:	781a      	ldrb	r2, [r3, #0]
 80166da:	202c      	movs	r0, #44	; 0x2c
 80166dc:	183b      	adds	r3, r7, r0
 80166de:	801a      	strh	r2, [r3, #0]
 80166e0:	183b      	adds	r3, r7, r0
 80166e2:	881b      	ldrh	r3, [r3, #0]
 80166e4:	2b06      	cmp	r3, #6
 80166e6:	d157      	bne.n	8016798 <ipcp_ackci+0x470>
 80166e8:	187b      	adds	r3, r7, r1
 80166ea:	881b      	ldrh	r3, [r3, #0]
 80166ec:	2b83      	cmp	r3, #131	; 0x83
 80166ee:	d153      	bne.n	8016798 <ipcp_ackci+0x470>
 80166f0:	68bb      	ldr	r3, [r7, #8]
 80166f2:	1c5a      	adds	r2, r3, #1
 80166f4:	60ba      	str	r2, [r7, #8]
 80166f6:	781b      	ldrb	r3, [r3, #0]
 80166f8:	021b      	lsls	r3, r3, #8
 80166fa:	613b      	str	r3, [r7, #16]
 80166fc:	68bb      	ldr	r3, [r7, #8]
 80166fe:	1c5a      	adds	r2, r3, #1
 8016700:	60ba      	str	r2, [r7, #8]
 8016702:	781b      	ldrb	r3, [r3, #0]
 8016704:	001a      	movs	r2, r3
 8016706:	693b      	ldr	r3, [r7, #16]
 8016708:	4313      	orrs	r3, r2
 801670a:	613b      	str	r3, [r7, #16]
 801670c:	693b      	ldr	r3, [r7, #16]
 801670e:	021b      	lsls	r3, r3, #8
 8016710:	613b      	str	r3, [r7, #16]
 8016712:	68bb      	ldr	r3, [r7, #8]
 8016714:	1c5a      	adds	r2, r3, #1
 8016716:	60ba      	str	r2, [r7, #8]
 8016718:	781b      	ldrb	r3, [r3, #0]
 801671a:	001a      	movs	r2, r3
 801671c:	693b      	ldr	r3, [r7, #16]
 801671e:	4313      	orrs	r3, r2
 8016720:	613b      	str	r3, [r7, #16]
 8016722:	693b      	ldr	r3, [r7, #16]
 8016724:	021b      	lsls	r3, r3, #8
 8016726:	613b      	str	r3, [r7, #16]
 8016728:	68bb      	ldr	r3, [r7, #8]
 801672a:	1c5a      	adds	r2, r3, #1
 801672c:	60ba      	str	r2, [r7, #8]
 801672e:	781b      	ldrb	r3, [r3, #0]
 8016730:	001a      	movs	r2, r3
 8016732:	693b      	ldr	r3, [r7, #16]
 8016734:	4313      	orrs	r3, r2
 8016736:	613b      	str	r3, [r7, #16]
 8016738:	693b      	ldr	r3, [r7, #16]
 801673a:	0018      	movs	r0, r3
 801673c:	f7f0 fe76 	bl	800742c <lwip_htonl>
 8016740:	0003      	movs	r3, r0
 8016742:	627b      	str	r3, [r7, #36]	; 0x24
 8016744:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016746:	691b      	ldr	r3, [r3, #16]
 8016748:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801674a:	429a      	cmp	r2, r3
 801674c:	d126      	bne.n	801679c <ipcp_ackci+0x474>
#endif /* UNUSED - WINS */

    /*
     * If there are any remaining CIs, then this packet is bad.
     */
    if (len != 0)
 801674e:	687b      	ldr	r3, [r7, #4]
 8016750:	2b00      	cmp	r3, #0
 8016752:	d125      	bne.n	80167a0 <ipcp_ackci+0x478>
	goto bad;
    return (1);
 8016754:	2301      	movs	r3, #1
 8016756:	e025      	b.n	80167a4 <ipcp_ackci+0x47c>
    ACKCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs, go->ouraddr,
 8016758:	46c0      	nop			; (mov r8, r8)
 801675a:	e022      	b.n	80167a2 <ipcp_ackci+0x47a>
 801675c:	46c0      	nop			; (mov r8, r8)
 801675e:	e020      	b.n	80167a2 <ipcp_ackci+0x47a>
 8016760:	46c0      	nop			; (mov r8, r8)
 8016762:	e01e      	b.n	80167a2 <ipcp_ackci+0x47a>
 8016764:	46c0      	nop			; (mov r8, r8)
 8016766:	e01c      	b.n	80167a2 <ipcp_ackci+0x47a>
    ACKCIVJ(CI_COMPRESSTYPE, go->neg_vj, go->vj_protocol, go->old_vj,
 8016768:	46c0      	nop			; (mov r8, r8)
 801676a:	e01a      	b.n	80167a2 <ipcp_ackci+0x47a>
 801676c:	46c0      	nop			; (mov r8, r8)
 801676e:	e018      	b.n	80167a2 <ipcp_ackci+0x47a>
 8016770:	46c0      	nop			; (mov r8, r8)
 8016772:	e016      	b.n	80167a2 <ipcp_ackci+0x47a>
 8016774:	46c0      	nop			; (mov r8, r8)
 8016776:	e014      	b.n	80167a2 <ipcp_ackci+0x47a>
 8016778:	46c0      	nop			; (mov r8, r8)
 801677a:	e012      	b.n	80167a2 <ipcp_ackci+0x47a>
    ACKCIADDR(CI_ADDR, go->neg_addr, go->ouraddr);
 801677c:	46c0      	nop			; (mov r8, r8)
 801677e:	e010      	b.n	80167a2 <ipcp_ackci+0x47a>
 8016780:	46c0      	nop			; (mov r8, r8)
 8016782:	e00e      	b.n	80167a2 <ipcp_ackci+0x47a>
 8016784:	46c0      	nop			; (mov r8, r8)
 8016786:	e00c      	b.n	80167a2 <ipcp_ackci+0x47a>
    ACKCIDNS(CI_MS_DNS1, go->req_dns1, go->dnsaddr[0]);
 8016788:	46c0      	nop			; (mov r8, r8)
 801678a:	e00a      	b.n	80167a2 <ipcp_ackci+0x47a>
 801678c:	46c0      	nop			; (mov r8, r8)
 801678e:	e008      	b.n	80167a2 <ipcp_ackci+0x47a>
 8016790:	46c0      	nop			; (mov r8, r8)
 8016792:	e006      	b.n	80167a2 <ipcp_ackci+0x47a>
    ACKCIDNS(CI_MS_DNS2, go->req_dns2, go->dnsaddr[1]);
 8016794:	46c0      	nop			; (mov r8, r8)
 8016796:	e004      	b.n	80167a2 <ipcp_ackci+0x47a>
 8016798:	46c0      	nop			; (mov r8, r8)
 801679a:	e002      	b.n	80167a2 <ipcp_ackci+0x47a>
 801679c:	46c0      	nop			; (mov r8, r8)
 801679e:	e000      	b.n	80167a2 <ipcp_ackci+0x47a>
	goto bad;
 80167a0:	46c0      	nop			; (mov r8, r8)

bad:
    IPCPDEBUG(("ipcp_ackci: received bad Ack!"));
    return (0);
 80167a2:	2300      	movs	r3, #0
}
 80167a4:	0018      	movs	r0, r3
 80167a6:	46bd      	mov	sp, r7
 80167a8:	b00e      	add	sp, #56	; 0x38
 80167aa:	bd80      	pop	{r7, pc}

080167ac <ipcp_nakci>:
 *
 * Returns:
 *	0 - Nak was bad.
 *	1 - Nak was good.
 */
static int ipcp_nakci(fsm *f, u_char *p, int len, int treat_as_reject) {
 80167ac:	b5f0      	push	{r4, r5, r6, r7, lr}
 80167ae:	b09b      	sub	sp, #108	; 0x6c
 80167b0:	af00      	add	r7, sp, #0
 80167b2:	60f8      	str	r0, [r7, #12]
 80167b4:	60b9      	str	r1, [r7, #8]
 80167b6:	607a      	str	r2, [r7, #4]
 80167b8:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 80167ba:	68fb      	ldr	r3, [r7, #12]
 80167bc:	681b      	ldr	r3, [r3, #0]
 80167be:	667b      	str	r3, [r7, #100]	; 0x64
    ipcp_options *go = &pcb->ipcp_gotoptions;
 80167c0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80167c2:	4ae0      	ldr	r2, [pc, #896]	; (8016b44 <ipcp_nakci+0x398>)
 80167c4:	4694      	mov	ip, r2
 80167c6:	4463      	add	r3, ip
 80167c8:	663b      	str	r3, [r7, #96]	; 0x60
    u32_t cidnsaddr;
#endif /* LWIP_DNS */
    ipcp_options no;		/* options we've seen Naks for */
    ipcp_options try_;		/* options to request next time */

    BZERO(&no, sizeof(no));
 80167ca:	2428      	movs	r4, #40	; 0x28
 80167cc:	193b      	adds	r3, r7, r4
 80167ce:	2218      	movs	r2, #24
 80167d0:	2100      	movs	r1, #0
 80167d2:	0018      	movs	r0, r3
 80167d4:	f007 fbfe 	bl	801dfd4 <memset>
    try_ = *go;
 80167d8:	2510      	movs	r5, #16
 80167da:	197b      	adds	r3, r7, r5
 80167dc:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 80167de:	ca43      	ldmia	r2!, {r0, r1, r6}
 80167e0:	c343      	stmia	r3!, {r0, r1, r6}
 80167e2:	ca43      	ldmia	r2!, {r0, r1, r6}
 80167e4:	c343      	stmia	r3!, {r0, r1, r6}

    /*
     * Accept the peer's idea of {our,his} address, if different
     * from our idea, only if the accept_{local,remote} flag is set.
     */
    NAKCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs,
 80167e6:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80167e8:	781b      	ldrb	r3, [r3, #0]
 80167ea:	2201      	movs	r2, #1
 80167ec:	4013      	ands	r3, r2
 80167ee:	b2db      	uxtb	r3, r3
 80167f0:	2b00      	cmp	r3, #0
 80167f2:	d000      	beq.n	80167f6 <ipcp_nakci+0x4a>
 80167f4:	e0a2      	b.n	801693c <ipcp_nakci+0x190>
 80167f6:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80167f8:	781b      	ldrb	r3, [r3, #0]
 80167fa:	2202      	movs	r2, #2
 80167fc:	4013      	ands	r3, r2
 80167fe:	b2db      	uxtb	r3, r3
 8016800:	2b00      	cmp	r3, #0
 8016802:	d100      	bne.n	8016806 <ipcp_nakci+0x5a>
 8016804:	e09a      	b.n	801693c <ipcp_nakci+0x190>
 8016806:	215f      	movs	r1, #95	; 0x5f
 8016808:	187b      	adds	r3, r7, r1
 801680a:	68ba      	ldr	r2, [r7, #8]
 801680c:	7852      	ldrb	r2, [r2, #1]
 801680e:	701a      	strb	r2, [r3, #0]
 8016810:	187b      	adds	r3, r7, r1
 8016812:	781b      	ldrb	r3, [r3, #0]
 8016814:	2b0a      	cmp	r3, #10
 8016816:	d000      	beq.n	801681a <ipcp_nakci+0x6e>
 8016818:	e090      	b.n	801693c <ipcp_nakci+0x190>
 801681a:	187b      	adds	r3, r7, r1
 801681c:	781b      	ldrb	r3, [r3, #0]
 801681e:	687a      	ldr	r2, [r7, #4]
 8016820:	429a      	cmp	r2, r3
 8016822:	da00      	bge.n	8016826 <ipcp_nakci+0x7a>
 8016824:	e08a      	b.n	801693c <ipcp_nakci+0x190>
 8016826:	68bb      	ldr	r3, [r7, #8]
 8016828:	781b      	ldrb	r3, [r3, #0]
 801682a:	2b01      	cmp	r3, #1
 801682c:	d000      	beq.n	8016830 <ipcp_nakci+0x84>
 801682e:	e085      	b.n	801693c <ipcp_nakci+0x190>
 8016830:	187b      	adds	r3, r7, r1
 8016832:	781b      	ldrb	r3, [r3, #0]
 8016834:	687a      	ldr	r2, [r7, #4]
 8016836:	1ad3      	subs	r3, r2, r3
 8016838:	607b      	str	r3, [r7, #4]
 801683a:	68bb      	ldr	r3, [r7, #8]
 801683c:	3302      	adds	r3, #2
 801683e:	60bb      	str	r3, [r7, #8]
 8016840:	68bb      	ldr	r3, [r7, #8]
 8016842:	1c5a      	adds	r2, r3, #1
 8016844:	60ba      	str	r2, [r7, #8]
 8016846:	781b      	ldrb	r3, [r3, #0]
 8016848:	021b      	lsls	r3, r3, #8
 801684a:	65bb      	str	r3, [r7, #88]	; 0x58
 801684c:	68bb      	ldr	r3, [r7, #8]
 801684e:	1c5a      	adds	r2, r3, #1
 8016850:	60ba      	str	r2, [r7, #8]
 8016852:	781b      	ldrb	r3, [r3, #0]
 8016854:	001a      	movs	r2, r3
 8016856:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016858:	4313      	orrs	r3, r2
 801685a:	65bb      	str	r3, [r7, #88]	; 0x58
 801685c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801685e:	021b      	lsls	r3, r3, #8
 8016860:	65bb      	str	r3, [r7, #88]	; 0x58
 8016862:	68bb      	ldr	r3, [r7, #8]
 8016864:	1c5a      	adds	r2, r3, #1
 8016866:	60ba      	str	r2, [r7, #8]
 8016868:	781b      	ldrb	r3, [r3, #0]
 801686a:	001a      	movs	r2, r3
 801686c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801686e:	4313      	orrs	r3, r2
 8016870:	65bb      	str	r3, [r7, #88]	; 0x58
 8016872:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016874:	021b      	lsls	r3, r3, #8
 8016876:	65bb      	str	r3, [r7, #88]	; 0x58
 8016878:	68bb      	ldr	r3, [r7, #8]
 801687a:	1c5a      	adds	r2, r3, #1
 801687c:	60ba      	str	r2, [r7, #8]
 801687e:	781b      	ldrb	r3, [r3, #0]
 8016880:	001a      	movs	r2, r3
 8016882:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016884:	4313      	orrs	r3, r2
 8016886:	65bb      	str	r3, [r7, #88]	; 0x58
 8016888:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801688a:	0018      	movs	r0, r3
 801688c:	f7f0 fdce 	bl	800742c <lwip_htonl>
 8016890:	0003      	movs	r3, r0
 8016892:	657b      	str	r3, [r7, #84]	; 0x54
 8016894:	68bb      	ldr	r3, [r7, #8]
 8016896:	1c5a      	adds	r2, r3, #1
 8016898:	60ba      	str	r2, [r7, #8]
 801689a:	781b      	ldrb	r3, [r3, #0]
 801689c:	021b      	lsls	r3, r3, #8
 801689e:	65bb      	str	r3, [r7, #88]	; 0x58
 80168a0:	68bb      	ldr	r3, [r7, #8]
 80168a2:	1c5a      	adds	r2, r3, #1
 80168a4:	60ba      	str	r2, [r7, #8]
 80168a6:	781b      	ldrb	r3, [r3, #0]
 80168a8:	001a      	movs	r2, r3
 80168aa:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80168ac:	4313      	orrs	r3, r2
 80168ae:	65bb      	str	r3, [r7, #88]	; 0x58
 80168b0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80168b2:	021b      	lsls	r3, r3, #8
 80168b4:	65bb      	str	r3, [r7, #88]	; 0x58
 80168b6:	68bb      	ldr	r3, [r7, #8]
 80168b8:	1c5a      	adds	r2, r3, #1
 80168ba:	60ba      	str	r2, [r7, #8]
 80168bc:	781b      	ldrb	r3, [r3, #0]
 80168be:	001a      	movs	r2, r3
 80168c0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80168c2:	4313      	orrs	r3, r2
 80168c4:	65bb      	str	r3, [r7, #88]	; 0x58
 80168c6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80168c8:	021b      	lsls	r3, r3, #8
 80168ca:	65bb      	str	r3, [r7, #88]	; 0x58
 80168cc:	68bb      	ldr	r3, [r7, #8]
 80168ce:	1c5a      	adds	r2, r3, #1
 80168d0:	60ba      	str	r2, [r7, #8]
 80168d2:	781b      	ldrb	r3, [r3, #0]
 80168d4:	001a      	movs	r2, r3
 80168d6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80168d8:	4313      	orrs	r3, r2
 80168da:	65bb      	str	r3, [r7, #88]	; 0x58
 80168dc:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80168de:	0018      	movs	r0, r3
 80168e0:	f7f0 fda4 	bl	800742c <lwip_htonl>
 80168e4:	0003      	movs	r3, r0
 80168e6:	653b      	str	r3, [r7, #80]	; 0x50
 80168e8:	193b      	adds	r3, r7, r4
 80168ea:	781a      	ldrb	r2, [r3, #0]
 80168ec:	2102      	movs	r1, #2
 80168ee:	430a      	orrs	r2, r1
 80168f0:	701a      	strb	r2, [r3, #0]
 80168f2:	683b      	ldr	r3, [r7, #0]
 80168f4:	2b00      	cmp	r3, #0
 80168f6:	d005      	beq.n	8016904 <ipcp_nakci+0x158>
 80168f8:	197b      	adds	r3, r7, r5
 80168fa:	781a      	ldrb	r2, [r3, #0]
 80168fc:	2102      	movs	r1, #2
 80168fe:	438a      	bics	r2, r1
 8016900:	701a      	strb	r2, [r3, #0]
 8016902:	e01b      	b.n	801693c <ipcp_nakci+0x190>
 8016904:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016906:	781b      	ldrb	r3, [r3, #0]
 8016908:	2240      	movs	r2, #64	; 0x40
 801690a:	4013      	ands	r3, r2
 801690c:	b2db      	uxtb	r3, r3
 801690e:	2b00      	cmp	r3, #0
 8016910:	d006      	beq.n	8016920 <ipcp_nakci+0x174>
 8016912:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016914:	2b00      	cmp	r3, #0
 8016916:	d003      	beq.n	8016920 <ipcp_nakci+0x174>
 8016918:	2310      	movs	r3, #16
 801691a:	18fb      	adds	r3, r7, r3
 801691c:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801691e:	605a      	str	r2, [r3, #4]
 8016920:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016922:	781b      	ldrb	r3, [r3, #0]
 8016924:	227f      	movs	r2, #127	; 0x7f
 8016926:	4393      	bics	r3, r2
 8016928:	b2db      	uxtb	r3, r3
 801692a:	2b00      	cmp	r3, #0
 801692c:	d006      	beq.n	801693c <ipcp_nakci+0x190>
 801692e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016930:	2b00      	cmp	r3, #0
 8016932:	d003      	beq.n	801693c <ipcp_nakci+0x190>
 8016934:	2310      	movs	r3, #16
 8016936:	18fb      	adds	r3, r7, r3
 8016938:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 801693a:	609a      	str	r2, [r3, #8]
     * Accept the peer's value of maxslotindex provided that it
     * is less than what we asked for.  Turn off slot-ID compression
     * if the peer wants.  Send old-style compress-type option if
     * the peer wants.
     */
    NAKCIVJ(CI_COMPRESSTYPE, neg_vj,
 801693c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801693e:	781b      	ldrb	r3, [r3, #0]
 8016940:	2208      	movs	r2, #8
 8016942:	4013      	ands	r3, r2
 8016944:	b2db      	uxtb	r3, r3
 8016946:	2b00      	cmp	r3, #0
 8016948:	d100      	bne.n	801694c <ipcp_nakci+0x1a0>
 801694a:	e09b      	b.n	8016a84 <ipcp_nakci+0x2d8>
 801694c:	215f      	movs	r1, #95	; 0x5f
 801694e:	187b      	adds	r3, r7, r1
 8016950:	68ba      	ldr	r2, [r7, #8]
 8016952:	7852      	ldrb	r2, [r2, #1]
 8016954:	701a      	strb	r2, [r3, #0]
 8016956:	000a      	movs	r2, r1
 8016958:	18bb      	adds	r3, r7, r2
 801695a:	781b      	ldrb	r3, [r3, #0]
 801695c:	2b04      	cmp	r3, #4
 801695e:	d004      	beq.n	801696a <ipcp_nakci+0x1be>
 8016960:	18bb      	adds	r3, r7, r2
 8016962:	781b      	ldrb	r3, [r3, #0]
 8016964:	2b06      	cmp	r3, #6
 8016966:	d000      	beq.n	801696a <ipcp_nakci+0x1be>
 8016968:	e08c      	b.n	8016a84 <ipcp_nakci+0x2d8>
 801696a:	215f      	movs	r1, #95	; 0x5f
 801696c:	187b      	adds	r3, r7, r1
 801696e:	781b      	ldrb	r3, [r3, #0]
 8016970:	687a      	ldr	r2, [r7, #4]
 8016972:	429a      	cmp	r2, r3
 8016974:	da00      	bge.n	8016978 <ipcp_nakci+0x1cc>
 8016976:	e085      	b.n	8016a84 <ipcp_nakci+0x2d8>
 8016978:	68bb      	ldr	r3, [r7, #8]
 801697a:	781b      	ldrb	r3, [r3, #0]
 801697c:	2b02      	cmp	r3, #2
 801697e:	d000      	beq.n	8016982 <ipcp_nakci+0x1d6>
 8016980:	e080      	b.n	8016a84 <ipcp_nakci+0x2d8>
 8016982:	187b      	adds	r3, r7, r1
 8016984:	781b      	ldrb	r3, [r3, #0]
 8016986:	687a      	ldr	r2, [r7, #4]
 8016988:	1ad3      	subs	r3, r2, r3
 801698a:	607b      	str	r3, [r7, #4]
 801698c:	68bb      	ldr	r3, [r7, #8]
 801698e:	3302      	adds	r3, #2
 8016990:	60bb      	str	r3, [r7, #8]
 8016992:	68bb      	ldr	r3, [r7, #8]
 8016994:	1c5a      	adds	r2, r3, #1
 8016996:	60ba      	str	r2, [r7, #8]
 8016998:	781b      	ldrb	r3, [r3, #0]
 801699a:	b29a      	uxth	r2, r3
 801699c:	204e      	movs	r0, #78	; 0x4e
 801699e:	183b      	adds	r3, r7, r0
 80169a0:	0212      	lsls	r2, r2, #8
 80169a2:	801a      	strh	r2, [r3, #0]
 80169a4:	68bb      	ldr	r3, [r7, #8]
 80169a6:	1c5a      	adds	r2, r3, #1
 80169a8:	60ba      	str	r2, [r7, #8]
 80169aa:	781b      	ldrb	r3, [r3, #0]
 80169ac:	b299      	uxth	r1, r3
 80169ae:	183b      	adds	r3, r7, r0
 80169b0:	183a      	adds	r2, r7, r0
 80169b2:	8812      	ldrh	r2, [r2, #0]
 80169b4:	430a      	orrs	r2, r1
 80169b6:	801a      	strh	r2, [r3, #0]
 80169b8:	2328      	movs	r3, #40	; 0x28
 80169ba:	18fb      	adds	r3, r7, r3
 80169bc:	781a      	ldrb	r2, [r3, #0]
 80169be:	2108      	movs	r1, #8
 80169c0:	430a      	orrs	r2, r1
 80169c2:	701a      	strb	r2, [r3, #0]
 80169c4:	683b      	ldr	r3, [r7, #0]
 80169c6:	2b00      	cmp	r3, #0
 80169c8:	d006      	beq.n	80169d8 <ipcp_nakci+0x22c>
 80169ca:	2310      	movs	r3, #16
 80169cc:	18fb      	adds	r3, r7, r3
 80169ce:	781a      	ldrb	r2, [r3, #0]
 80169d0:	2108      	movs	r1, #8
 80169d2:	438a      	bics	r2, r1
 80169d4:	701a      	strb	r2, [r3, #0]
 80169d6:	e055      	b.n	8016a84 <ipcp_nakci+0x2d8>
 80169d8:	235f      	movs	r3, #95	; 0x5f
 80169da:	18fb      	adds	r3, r7, r3
 80169dc:	781b      	ldrb	r3, [r3, #0]
 80169de:	2b06      	cmp	r3, #6
 80169e0:	d135      	bne.n	8016a4e <ipcp_nakci+0x2a2>
 80169e2:	68bb      	ldr	r3, [r7, #8]
 80169e4:	1c5a      	adds	r2, r3, #1
 80169e6:	60ba      	str	r2, [r7, #8]
 80169e8:	204d      	movs	r0, #77	; 0x4d
 80169ea:	183a      	adds	r2, r7, r0
 80169ec:	781b      	ldrb	r3, [r3, #0]
 80169ee:	7013      	strb	r3, [r2, #0]
 80169f0:	68bb      	ldr	r3, [r7, #8]
 80169f2:	1c5a      	adds	r2, r3, #1
 80169f4:	60ba      	str	r2, [r7, #8]
 80169f6:	224c      	movs	r2, #76	; 0x4c
 80169f8:	18ba      	adds	r2, r7, r2
 80169fa:	781b      	ldrb	r3, [r3, #0]
 80169fc:	7013      	strb	r3, [r2, #0]
 80169fe:	234e      	movs	r3, #78	; 0x4e
 8016a00:	18fb      	adds	r3, r7, r3
 8016a02:	881b      	ldrh	r3, [r3, #0]
 8016a04:	2b2d      	cmp	r3, #45	; 0x2d
 8016a06:	d11b      	bne.n	8016a40 <ipcp_nakci+0x294>
 8016a08:	2410      	movs	r4, #16
 8016a0a:	193b      	adds	r3, r7, r4
 8016a0c:	781a      	ldrb	r2, [r3, #0]
 8016a0e:	2110      	movs	r1, #16
 8016a10:	438a      	bics	r2, r1
 8016a12:	701a      	strb	r2, [r3, #0]
 8016a14:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016a16:	7d9b      	ldrb	r3, [r3, #22]
 8016a18:	183a      	adds	r2, r7, r0
 8016a1a:	7812      	ldrb	r2, [r2, #0]
 8016a1c:	429a      	cmp	r2, r3
 8016a1e:	d203      	bcs.n	8016a28 <ipcp_nakci+0x27c>
 8016a20:	193b      	adds	r3, r7, r4
 8016a22:	183a      	adds	r2, r7, r0
 8016a24:	7812      	ldrb	r2, [r2, #0]
 8016a26:	759a      	strb	r2, [r3, #22]
 8016a28:	234c      	movs	r3, #76	; 0x4c
 8016a2a:	18fb      	adds	r3, r7, r3
 8016a2c:	781b      	ldrb	r3, [r3, #0]
 8016a2e:	2b00      	cmp	r3, #0
 8016a30:	d128      	bne.n	8016a84 <ipcp_nakci+0x2d8>
 8016a32:	2310      	movs	r3, #16
 8016a34:	18fb      	adds	r3, r7, r3
 8016a36:	781a      	ldrb	r2, [r3, #0]
 8016a38:	2120      	movs	r1, #32
 8016a3a:	438a      	bics	r2, r1
 8016a3c:	701a      	strb	r2, [r3, #0]
 8016a3e:	e021      	b.n	8016a84 <ipcp_nakci+0x2d8>
 8016a40:	2310      	movs	r3, #16
 8016a42:	18fb      	adds	r3, r7, r3
 8016a44:	781a      	ldrb	r2, [r3, #0]
 8016a46:	2108      	movs	r1, #8
 8016a48:	438a      	bics	r2, r1
 8016a4a:	701a      	strb	r2, [r3, #0]
 8016a4c:	e01a      	b.n	8016a84 <ipcp_nakci+0x2d8>
 8016a4e:	224e      	movs	r2, #78	; 0x4e
 8016a50:	18bb      	adds	r3, r7, r2
 8016a52:	881b      	ldrh	r3, [r3, #0]
 8016a54:	2b2d      	cmp	r3, #45	; 0x2d
 8016a56:	d003      	beq.n	8016a60 <ipcp_nakci+0x2b4>
 8016a58:	18bb      	adds	r3, r7, r2
 8016a5a:	881b      	ldrh	r3, [r3, #0]
 8016a5c:	2b37      	cmp	r3, #55	; 0x37
 8016a5e:	d10b      	bne.n	8016a78 <ipcp_nakci+0x2cc>
 8016a60:	2010      	movs	r0, #16
 8016a62:	183b      	adds	r3, r7, r0
 8016a64:	781a      	ldrb	r2, [r3, #0]
 8016a66:	2110      	movs	r1, #16
 8016a68:	430a      	orrs	r2, r1
 8016a6a:	701a      	strb	r2, [r3, #0]
 8016a6c:	183b      	adds	r3, r7, r0
 8016a6e:	224e      	movs	r2, #78	; 0x4e
 8016a70:	18ba      	adds	r2, r7, r2
 8016a72:	8812      	ldrh	r2, [r2, #0]
 8016a74:	829a      	strh	r2, [r3, #20]
 8016a76:	e005      	b.n	8016a84 <ipcp_nakci+0x2d8>
 8016a78:	2310      	movs	r3, #16
 8016a7a:	18fb      	adds	r3, r7, r3
 8016a7c:	781a      	ldrb	r2, [r3, #0]
 8016a7e:	2108      	movs	r1, #8
 8016a80:	438a      	bics	r2, r1
 8016a82:	701a      	strb	r2, [r3, #0]
		}
	    }
	    );
#endif /* VJ_SUPPORT */

    NAKCIADDR(CI_ADDR, neg_addr,
 8016a84:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016a86:	781b      	ldrb	r3, [r3, #0]
 8016a88:	2201      	movs	r2, #1
 8016a8a:	4013      	ands	r3, r2
 8016a8c:	b2db      	uxtb	r3, r3
 8016a8e:	2b00      	cmp	r3, #0
 8016a90:	d068      	beq.n	8016b64 <ipcp_nakci+0x3b8>
 8016a92:	215f      	movs	r1, #95	; 0x5f
 8016a94:	187b      	adds	r3, r7, r1
 8016a96:	68ba      	ldr	r2, [r7, #8]
 8016a98:	7852      	ldrb	r2, [r2, #1]
 8016a9a:	701a      	strb	r2, [r3, #0]
 8016a9c:	187b      	adds	r3, r7, r1
 8016a9e:	781b      	ldrb	r3, [r3, #0]
 8016aa0:	2b06      	cmp	r3, #6
 8016aa2:	d15f      	bne.n	8016b64 <ipcp_nakci+0x3b8>
 8016aa4:	187b      	adds	r3, r7, r1
 8016aa6:	781b      	ldrb	r3, [r3, #0]
 8016aa8:	687a      	ldr	r2, [r7, #4]
 8016aaa:	429a      	cmp	r2, r3
 8016aac:	db5a      	blt.n	8016b64 <ipcp_nakci+0x3b8>
 8016aae:	68bb      	ldr	r3, [r7, #8]
 8016ab0:	781b      	ldrb	r3, [r3, #0]
 8016ab2:	2b03      	cmp	r3, #3
 8016ab4:	d156      	bne.n	8016b64 <ipcp_nakci+0x3b8>
 8016ab6:	187b      	adds	r3, r7, r1
 8016ab8:	781b      	ldrb	r3, [r3, #0]
 8016aba:	687a      	ldr	r2, [r7, #4]
 8016abc:	1ad3      	subs	r3, r2, r3
 8016abe:	607b      	str	r3, [r7, #4]
 8016ac0:	68bb      	ldr	r3, [r7, #8]
 8016ac2:	3302      	adds	r3, #2
 8016ac4:	60bb      	str	r3, [r7, #8]
 8016ac6:	68bb      	ldr	r3, [r7, #8]
 8016ac8:	1c5a      	adds	r2, r3, #1
 8016aca:	60ba      	str	r2, [r7, #8]
 8016acc:	781b      	ldrb	r3, [r3, #0]
 8016ace:	021b      	lsls	r3, r3, #8
 8016ad0:	65bb      	str	r3, [r7, #88]	; 0x58
 8016ad2:	68bb      	ldr	r3, [r7, #8]
 8016ad4:	1c5a      	adds	r2, r3, #1
 8016ad6:	60ba      	str	r2, [r7, #8]
 8016ad8:	781b      	ldrb	r3, [r3, #0]
 8016ada:	001a      	movs	r2, r3
 8016adc:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016ade:	4313      	orrs	r3, r2
 8016ae0:	65bb      	str	r3, [r7, #88]	; 0x58
 8016ae2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016ae4:	021b      	lsls	r3, r3, #8
 8016ae6:	65bb      	str	r3, [r7, #88]	; 0x58
 8016ae8:	68bb      	ldr	r3, [r7, #8]
 8016aea:	1c5a      	adds	r2, r3, #1
 8016aec:	60ba      	str	r2, [r7, #8]
 8016aee:	781b      	ldrb	r3, [r3, #0]
 8016af0:	001a      	movs	r2, r3
 8016af2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016af4:	4313      	orrs	r3, r2
 8016af6:	65bb      	str	r3, [r7, #88]	; 0x58
 8016af8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016afa:	021b      	lsls	r3, r3, #8
 8016afc:	65bb      	str	r3, [r7, #88]	; 0x58
 8016afe:	68bb      	ldr	r3, [r7, #8]
 8016b00:	1c5a      	adds	r2, r3, #1
 8016b02:	60ba      	str	r2, [r7, #8]
 8016b04:	781b      	ldrb	r3, [r3, #0]
 8016b06:	001a      	movs	r2, r3
 8016b08:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016b0a:	4313      	orrs	r3, r2
 8016b0c:	65bb      	str	r3, [r7, #88]	; 0x58
 8016b0e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016b10:	0018      	movs	r0, r3
 8016b12:	f7f0 fc8b 	bl	800742c <lwip_htonl>
 8016b16:	0003      	movs	r3, r0
 8016b18:	657b      	str	r3, [r7, #84]	; 0x54
 8016b1a:	2328      	movs	r3, #40	; 0x28
 8016b1c:	18fb      	adds	r3, r7, r3
 8016b1e:	781a      	ldrb	r2, [r3, #0]
 8016b20:	2101      	movs	r1, #1
 8016b22:	430a      	orrs	r2, r1
 8016b24:	701a      	strb	r2, [r3, #0]
 8016b26:	683b      	ldr	r3, [r7, #0]
 8016b28:	2b00      	cmp	r3, #0
 8016b2a:	d00d      	beq.n	8016b48 <ipcp_nakci+0x39c>
 8016b2c:	2010      	movs	r0, #16
 8016b2e:	183b      	adds	r3, r7, r0
 8016b30:	781a      	ldrb	r2, [r3, #0]
 8016b32:	2101      	movs	r1, #1
 8016b34:	438a      	bics	r2, r1
 8016b36:	701a      	strb	r2, [r3, #0]
 8016b38:	183b      	adds	r3, r7, r0
 8016b3a:	781a      	ldrb	r2, [r3, #0]
 8016b3c:	2102      	movs	r1, #2
 8016b3e:	438a      	bics	r2, r1
 8016b40:	701a      	strb	r2, [r3, #0]
 8016b42:	e00f      	b.n	8016b64 <ipcp_nakci+0x3b8>
 8016b44:	0000121c 	.word	0x0000121c
 8016b48:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016b4a:	781b      	ldrb	r3, [r3, #0]
 8016b4c:	2240      	movs	r2, #64	; 0x40
 8016b4e:	4013      	ands	r3, r2
 8016b50:	b2db      	uxtb	r3, r3
 8016b52:	2b00      	cmp	r3, #0
 8016b54:	d006      	beq.n	8016b64 <ipcp_nakci+0x3b8>
 8016b56:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016b58:	2b00      	cmp	r3, #0
 8016b5a:	d003      	beq.n	8016b64 <ipcp_nakci+0x3b8>
 8016b5c:	2310      	movs	r3, #16
 8016b5e:	18fb      	adds	r3, r7, r3
 8016b60:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8016b62:	605a      	str	r2, [r3, #4]
		  try_.ouraddr = ciaddr1;
	      }
	      );

#if LWIP_DNS
    NAKCIDNS(CI_MS_DNS1, req_dns1,
 8016b64:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016b66:	785b      	ldrb	r3, [r3, #1]
 8016b68:	2201      	movs	r2, #1
 8016b6a:	4013      	ands	r3, r2
 8016b6c:	b2db      	uxtb	r3, r3
 8016b6e:	2b00      	cmp	r3, #0
 8016b70:	d057      	beq.n	8016c22 <ipcp_nakci+0x476>
 8016b72:	215f      	movs	r1, #95	; 0x5f
 8016b74:	187b      	adds	r3, r7, r1
 8016b76:	68ba      	ldr	r2, [r7, #8]
 8016b78:	7852      	ldrb	r2, [r2, #1]
 8016b7a:	701a      	strb	r2, [r3, #0]
 8016b7c:	187b      	adds	r3, r7, r1
 8016b7e:	781b      	ldrb	r3, [r3, #0]
 8016b80:	2b06      	cmp	r3, #6
 8016b82:	d14e      	bne.n	8016c22 <ipcp_nakci+0x476>
 8016b84:	187b      	adds	r3, r7, r1
 8016b86:	781b      	ldrb	r3, [r3, #0]
 8016b88:	687a      	ldr	r2, [r7, #4]
 8016b8a:	429a      	cmp	r2, r3
 8016b8c:	db49      	blt.n	8016c22 <ipcp_nakci+0x476>
 8016b8e:	68bb      	ldr	r3, [r7, #8]
 8016b90:	781b      	ldrb	r3, [r3, #0]
 8016b92:	2b81      	cmp	r3, #129	; 0x81
 8016b94:	d145      	bne.n	8016c22 <ipcp_nakci+0x476>
 8016b96:	187b      	adds	r3, r7, r1
 8016b98:	781b      	ldrb	r3, [r3, #0]
 8016b9a:	687a      	ldr	r2, [r7, #4]
 8016b9c:	1ad3      	subs	r3, r2, r3
 8016b9e:	607b      	str	r3, [r7, #4]
 8016ba0:	68bb      	ldr	r3, [r7, #8]
 8016ba2:	3302      	adds	r3, #2
 8016ba4:	60bb      	str	r3, [r7, #8]
 8016ba6:	68bb      	ldr	r3, [r7, #8]
 8016ba8:	1c5a      	adds	r2, r3, #1
 8016baa:	60ba      	str	r2, [r7, #8]
 8016bac:	781b      	ldrb	r3, [r3, #0]
 8016bae:	021b      	lsls	r3, r3, #8
 8016bb0:	65bb      	str	r3, [r7, #88]	; 0x58
 8016bb2:	68bb      	ldr	r3, [r7, #8]
 8016bb4:	1c5a      	adds	r2, r3, #1
 8016bb6:	60ba      	str	r2, [r7, #8]
 8016bb8:	781b      	ldrb	r3, [r3, #0]
 8016bba:	001a      	movs	r2, r3
 8016bbc:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016bbe:	4313      	orrs	r3, r2
 8016bc0:	65bb      	str	r3, [r7, #88]	; 0x58
 8016bc2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016bc4:	021b      	lsls	r3, r3, #8
 8016bc6:	65bb      	str	r3, [r7, #88]	; 0x58
 8016bc8:	68bb      	ldr	r3, [r7, #8]
 8016bca:	1c5a      	adds	r2, r3, #1
 8016bcc:	60ba      	str	r2, [r7, #8]
 8016bce:	781b      	ldrb	r3, [r3, #0]
 8016bd0:	001a      	movs	r2, r3
 8016bd2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016bd4:	4313      	orrs	r3, r2
 8016bd6:	65bb      	str	r3, [r7, #88]	; 0x58
 8016bd8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016bda:	021b      	lsls	r3, r3, #8
 8016bdc:	65bb      	str	r3, [r7, #88]	; 0x58
 8016bde:	68bb      	ldr	r3, [r7, #8]
 8016be0:	1c5a      	adds	r2, r3, #1
 8016be2:	60ba      	str	r2, [r7, #8]
 8016be4:	781b      	ldrb	r3, [r3, #0]
 8016be6:	001a      	movs	r2, r3
 8016be8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016bea:	4313      	orrs	r3, r2
 8016bec:	65bb      	str	r3, [r7, #88]	; 0x58
 8016bee:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016bf0:	0018      	movs	r0, r3
 8016bf2:	f7f0 fc1b 	bl	800742c <lwip_htonl>
 8016bf6:	0003      	movs	r3, r0
 8016bf8:	64bb      	str	r3, [r7, #72]	; 0x48
 8016bfa:	2328      	movs	r3, #40	; 0x28
 8016bfc:	18fb      	adds	r3, r7, r3
 8016bfe:	785a      	ldrb	r2, [r3, #1]
 8016c00:	2101      	movs	r1, #1
 8016c02:	430a      	orrs	r2, r1
 8016c04:	705a      	strb	r2, [r3, #1]
 8016c06:	683b      	ldr	r3, [r7, #0]
 8016c08:	2b00      	cmp	r3, #0
 8016c0a:	d006      	beq.n	8016c1a <ipcp_nakci+0x46e>
 8016c0c:	2310      	movs	r3, #16
 8016c0e:	18fb      	adds	r3, r7, r3
 8016c10:	785a      	ldrb	r2, [r3, #1]
 8016c12:	2101      	movs	r1, #1
 8016c14:	438a      	bics	r2, r1
 8016c16:	705a      	strb	r2, [r3, #1]
 8016c18:	e003      	b.n	8016c22 <ipcp_nakci+0x476>
 8016c1a:	2310      	movs	r3, #16
 8016c1c:	18fb      	adds	r3, r7, r3
 8016c1e:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8016c20:	60da      	str	r2, [r3, #12]
	     } else {
		 try_.dnsaddr[0] = cidnsaddr;
	     }
	     );

    NAKCIDNS(CI_MS_DNS2, req_dns2,
 8016c22:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016c24:	785b      	ldrb	r3, [r3, #1]
 8016c26:	2202      	movs	r2, #2
 8016c28:	4013      	ands	r3, r2
 8016c2a:	b2db      	uxtb	r3, r3
 8016c2c:	2b00      	cmp	r3, #0
 8016c2e:	d100      	bne.n	8016c32 <ipcp_nakci+0x486>
 8016c30:	e24f      	b.n	80170d2 <ipcp_nakci+0x926>
 8016c32:	215f      	movs	r1, #95	; 0x5f
 8016c34:	187b      	adds	r3, r7, r1
 8016c36:	68ba      	ldr	r2, [r7, #8]
 8016c38:	7852      	ldrb	r2, [r2, #1]
 8016c3a:	701a      	strb	r2, [r3, #0]
 8016c3c:	187b      	adds	r3, r7, r1
 8016c3e:	781b      	ldrb	r3, [r3, #0]
 8016c40:	2b06      	cmp	r3, #6
 8016c42:	d000      	beq.n	8016c46 <ipcp_nakci+0x49a>
 8016c44:	e245      	b.n	80170d2 <ipcp_nakci+0x926>
 8016c46:	187b      	adds	r3, r7, r1
 8016c48:	781b      	ldrb	r3, [r3, #0]
 8016c4a:	687a      	ldr	r2, [r7, #4]
 8016c4c:	429a      	cmp	r2, r3
 8016c4e:	da00      	bge.n	8016c52 <ipcp_nakci+0x4a6>
 8016c50:	e23f      	b.n	80170d2 <ipcp_nakci+0x926>
 8016c52:	68bb      	ldr	r3, [r7, #8]
 8016c54:	781b      	ldrb	r3, [r3, #0]
 8016c56:	2b83      	cmp	r3, #131	; 0x83
 8016c58:	d000      	beq.n	8016c5c <ipcp_nakci+0x4b0>
 8016c5a:	e23a      	b.n	80170d2 <ipcp_nakci+0x926>
 8016c5c:	187b      	adds	r3, r7, r1
 8016c5e:	781b      	ldrb	r3, [r3, #0]
 8016c60:	687a      	ldr	r2, [r7, #4]
 8016c62:	1ad3      	subs	r3, r2, r3
 8016c64:	607b      	str	r3, [r7, #4]
 8016c66:	68bb      	ldr	r3, [r7, #8]
 8016c68:	3302      	adds	r3, #2
 8016c6a:	60bb      	str	r3, [r7, #8]
 8016c6c:	68bb      	ldr	r3, [r7, #8]
 8016c6e:	1c5a      	adds	r2, r3, #1
 8016c70:	60ba      	str	r2, [r7, #8]
 8016c72:	781b      	ldrb	r3, [r3, #0]
 8016c74:	021b      	lsls	r3, r3, #8
 8016c76:	65bb      	str	r3, [r7, #88]	; 0x58
 8016c78:	68bb      	ldr	r3, [r7, #8]
 8016c7a:	1c5a      	adds	r2, r3, #1
 8016c7c:	60ba      	str	r2, [r7, #8]
 8016c7e:	781b      	ldrb	r3, [r3, #0]
 8016c80:	001a      	movs	r2, r3
 8016c82:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016c84:	4313      	orrs	r3, r2
 8016c86:	65bb      	str	r3, [r7, #88]	; 0x58
 8016c88:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016c8a:	021b      	lsls	r3, r3, #8
 8016c8c:	65bb      	str	r3, [r7, #88]	; 0x58
 8016c8e:	68bb      	ldr	r3, [r7, #8]
 8016c90:	1c5a      	adds	r2, r3, #1
 8016c92:	60ba      	str	r2, [r7, #8]
 8016c94:	781b      	ldrb	r3, [r3, #0]
 8016c96:	001a      	movs	r2, r3
 8016c98:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016c9a:	4313      	orrs	r3, r2
 8016c9c:	65bb      	str	r3, [r7, #88]	; 0x58
 8016c9e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016ca0:	021b      	lsls	r3, r3, #8
 8016ca2:	65bb      	str	r3, [r7, #88]	; 0x58
 8016ca4:	68bb      	ldr	r3, [r7, #8]
 8016ca6:	1c5a      	adds	r2, r3, #1
 8016ca8:	60ba      	str	r2, [r7, #8]
 8016caa:	781b      	ldrb	r3, [r3, #0]
 8016cac:	001a      	movs	r2, r3
 8016cae:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016cb0:	4313      	orrs	r3, r2
 8016cb2:	65bb      	str	r3, [r7, #88]	; 0x58
 8016cb4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016cb6:	0018      	movs	r0, r3
 8016cb8:	f7f0 fbb8 	bl	800742c <lwip_htonl>
 8016cbc:	0003      	movs	r3, r0
 8016cbe:	64bb      	str	r3, [r7, #72]	; 0x48
 8016cc0:	2328      	movs	r3, #40	; 0x28
 8016cc2:	18fb      	adds	r3, r7, r3
 8016cc4:	785a      	ldrb	r2, [r3, #1]
 8016cc6:	2102      	movs	r1, #2
 8016cc8:	430a      	orrs	r2, r1
 8016cca:	705a      	strb	r2, [r3, #1]
 8016ccc:	683b      	ldr	r3, [r7, #0]
 8016cce:	2b00      	cmp	r3, #0
 8016cd0:	d006      	beq.n	8016ce0 <ipcp_nakci+0x534>
 8016cd2:	2310      	movs	r3, #16
 8016cd4:	18fb      	adds	r3, r7, r3
 8016cd6:	785a      	ldrb	r2, [r3, #1]
 8016cd8:	2102      	movs	r1, #2
 8016cda:	438a      	bics	r2, r1
 8016cdc:	705a      	strb	r2, [r3, #1]
 8016cde:	e1f8      	b.n	80170d2 <ipcp_nakci+0x926>
 8016ce0:	2310      	movs	r3, #16
 8016ce2:	18fb      	adds	r3, r7, r3
 8016ce4:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8016ce6:	611a      	str	r2, [r3, #16]
     * If they want to negotiate about IP addresses, we comply.
     * If they want us to ask for compression, we refuse.
     * If they want us to ask for ms-dns, we do that, since some
     * peers get huffy if we don't.
     */
    while (len >= CILEN_VOID) {
 8016ce8:	e1f3      	b.n	80170d2 <ipcp_nakci+0x926>
	GETCHAR(citype, p);
 8016cea:	68bb      	ldr	r3, [r7, #8]
 8016cec:	1c5a      	adds	r2, r3, #1
 8016cee:	60ba      	str	r2, [r7, #8]
 8016cf0:	2047      	movs	r0, #71	; 0x47
 8016cf2:	183a      	adds	r2, r7, r0
 8016cf4:	781b      	ldrb	r3, [r3, #0]
 8016cf6:	7013      	strb	r3, [r2, #0]
	GETCHAR(cilen, p);
 8016cf8:	68bb      	ldr	r3, [r7, #8]
 8016cfa:	1c5a      	adds	r2, r3, #1
 8016cfc:	60ba      	str	r2, [r7, #8]
 8016cfe:	215f      	movs	r1, #95	; 0x5f
 8016d00:	187a      	adds	r2, r7, r1
 8016d02:	781b      	ldrb	r3, [r3, #0]
 8016d04:	7013      	strb	r3, [r2, #0]
	if ( cilen < CILEN_VOID || (len -= cilen) < 0 )
 8016d06:	187b      	adds	r3, r7, r1
 8016d08:	781b      	ldrb	r3, [r3, #0]
 8016d0a:	2b01      	cmp	r3, #1
 8016d0c:	d800      	bhi.n	8016d10 <ipcp_nakci+0x564>
 8016d0e:	e1f1      	b.n	80170f4 <ipcp_nakci+0x948>
 8016d10:	187b      	adds	r3, r7, r1
 8016d12:	781b      	ldrb	r3, [r3, #0]
 8016d14:	687a      	ldr	r2, [r7, #4]
 8016d16:	1ad3      	subs	r3, r2, r3
 8016d18:	607b      	str	r3, [r7, #4]
 8016d1a:	687b      	ldr	r3, [r7, #4]
 8016d1c:	2b00      	cmp	r3, #0
 8016d1e:	da00      	bge.n	8016d22 <ipcp_nakci+0x576>
 8016d20:	e1e8      	b.n	80170f4 <ipcp_nakci+0x948>
	    goto bad;
	next = p + cilen - 2;
 8016d22:	187b      	adds	r3, r7, r1
 8016d24:	781b      	ldrb	r3, [r3, #0]
 8016d26:	3b02      	subs	r3, #2
 8016d28:	68ba      	ldr	r2, [r7, #8]
 8016d2a:	18d3      	adds	r3, r2, r3
 8016d2c:	643b      	str	r3, [r7, #64]	; 0x40

	switch (citype) {
 8016d2e:	183b      	adds	r3, r7, r0
 8016d30:	781b      	ldrb	r3, [r3, #0]
 8016d32:	2b83      	cmp	r3, #131	; 0x83
 8016d34:	d100      	bne.n	8016d38 <ipcp_nakci+0x58c>
 8016d36:	e17e      	b.n	8017036 <ipcp_nakci+0x88a>
 8016d38:	dd00      	ble.n	8016d3c <ipcp_nakci+0x590>
 8016d3a:	e1c7      	b.n	80170cc <ipcp_nakci+0x920>
 8016d3c:	2b81      	cmp	r3, #129	; 0x81
 8016d3e:	d100      	bne.n	8016d42 <ipcp_nakci+0x596>
 8016d40:	e12b      	b.n	8016f9a <ipcp_nakci+0x7ee>
 8016d42:	dd00      	ble.n	8016d46 <ipcp_nakci+0x59a>
 8016d44:	e1c2      	b.n	80170cc <ipcp_nakci+0x920>
 8016d46:	2b03      	cmp	r3, #3
 8016d48:	d100      	bne.n	8016d4c <ipcp_nakci+0x5a0>
 8016d4a:	e0c1      	b.n	8016ed0 <ipcp_nakci+0x724>
 8016d4c:	dd00      	ble.n	8016d50 <ipcp_nakci+0x5a4>
 8016d4e:	e1bd      	b.n	80170cc <ipcp_nakci+0x920>
 8016d50:	2b01      	cmp	r3, #1
 8016d52:	d023      	beq.n	8016d9c <ipcp_nakci+0x5f0>
 8016d54:	2b02      	cmp	r3, #2
 8016d56:	d000      	beq.n	8016d5a <ipcp_nakci+0x5ae>
 8016d58:	e1b8      	b.n	80170cc <ipcp_nakci+0x920>
#if VJ_SUPPORT
	case CI_COMPRESSTYPE:
	    if (go->neg_vj || no.neg_vj ||
 8016d5a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016d5c:	781b      	ldrb	r3, [r3, #0]
 8016d5e:	2208      	movs	r2, #8
 8016d60:	4013      	ands	r3, r2
 8016d62:	b2db      	uxtb	r3, r3
 8016d64:	2b00      	cmp	r3, #0
 8016d66:	d000      	beq.n	8016d6a <ipcp_nakci+0x5be>
 8016d68:	e1c6      	b.n	80170f8 <ipcp_nakci+0x94c>
 8016d6a:	2328      	movs	r3, #40	; 0x28
 8016d6c:	18fb      	adds	r3, r7, r3
 8016d6e:	781b      	ldrb	r3, [r3, #0]
 8016d70:	2208      	movs	r2, #8
 8016d72:	4013      	ands	r3, r2
 8016d74:	b2db      	uxtb	r3, r3
 8016d76:	2b00      	cmp	r3, #0
 8016d78:	d000      	beq.n	8016d7c <ipcp_nakci+0x5d0>
 8016d7a:	e1bd      	b.n	80170f8 <ipcp_nakci+0x94c>
 8016d7c:	187b      	adds	r3, r7, r1
 8016d7e:	781b      	ldrb	r3, [r3, #0]
 8016d80:	2b06      	cmp	r3, #6
 8016d82:	d004      	beq.n	8016d8e <ipcp_nakci+0x5e2>
		(cilen != CILEN_VJ && cilen != CILEN_COMPRESS))
 8016d84:	187b      	adds	r3, r7, r1
 8016d86:	781b      	ldrb	r3, [r3, #0]
 8016d88:	2b04      	cmp	r3, #4
 8016d8a:	d000      	beq.n	8016d8e <ipcp_nakci+0x5e2>
 8016d8c:	e1b4      	b.n	80170f8 <ipcp_nakci+0x94c>
		goto bad;
	    no.neg_vj = 1;
 8016d8e:	2328      	movs	r3, #40	; 0x28
 8016d90:	18fb      	adds	r3, r7, r3
 8016d92:	781a      	ldrb	r2, [r3, #0]
 8016d94:	2108      	movs	r1, #8
 8016d96:	430a      	orrs	r2, r1
 8016d98:	701a      	strb	r2, [r3, #0]
	    break;
 8016d9a:	e198      	b.n	80170ce <ipcp_nakci+0x922>
#endif /* VJ_SUPPORT */
	case CI_ADDRS:
	    if ((!go->neg_addr && go->old_addrs) || no.old_addrs
 8016d9c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016d9e:	781b      	ldrb	r3, [r3, #0]
 8016da0:	2201      	movs	r2, #1
 8016da2:	4013      	ands	r3, r2
 8016da4:	b2db      	uxtb	r3, r3
 8016da6:	2b00      	cmp	r3, #0
 8016da8:	d107      	bne.n	8016dba <ipcp_nakci+0x60e>
 8016daa:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016dac:	781b      	ldrb	r3, [r3, #0]
 8016dae:	2202      	movs	r2, #2
 8016db0:	4013      	ands	r3, r2
 8016db2:	b2db      	uxtb	r3, r3
 8016db4:	2b00      	cmp	r3, #0
 8016db6:	d000      	beq.n	8016dba <ipcp_nakci+0x60e>
 8016db8:	e1a0      	b.n	80170fc <ipcp_nakci+0x950>
 8016dba:	2328      	movs	r3, #40	; 0x28
 8016dbc:	18fb      	adds	r3, r7, r3
 8016dbe:	781b      	ldrb	r3, [r3, #0]
 8016dc0:	2202      	movs	r2, #2
 8016dc2:	4013      	ands	r3, r2
 8016dc4:	b2db      	uxtb	r3, r3
 8016dc6:	2b00      	cmp	r3, #0
 8016dc8:	d000      	beq.n	8016dcc <ipcp_nakci+0x620>
 8016dca:	e197      	b.n	80170fc <ipcp_nakci+0x950>
		|| cilen != CILEN_ADDRS)
 8016dcc:	235f      	movs	r3, #95	; 0x5f
 8016dce:	18fb      	adds	r3, r7, r3
 8016dd0:	781b      	ldrb	r3, [r3, #0]
 8016dd2:	2b0a      	cmp	r3, #10
 8016dd4:	d000      	beq.n	8016dd8 <ipcp_nakci+0x62c>
 8016dd6:	e191      	b.n	80170fc <ipcp_nakci+0x950>
		goto bad;
	    try_.neg_addr = 0;
 8016dd8:	2410      	movs	r4, #16
 8016dda:	193b      	adds	r3, r7, r4
 8016ddc:	781a      	ldrb	r2, [r3, #0]
 8016dde:	2101      	movs	r1, #1
 8016de0:	438a      	bics	r2, r1
 8016de2:	701a      	strb	r2, [r3, #0]
	    GETLONG(l, p);
 8016de4:	68bb      	ldr	r3, [r7, #8]
 8016de6:	1c5a      	adds	r2, r3, #1
 8016de8:	60ba      	str	r2, [r7, #8]
 8016dea:	781b      	ldrb	r3, [r3, #0]
 8016dec:	021b      	lsls	r3, r3, #8
 8016dee:	65bb      	str	r3, [r7, #88]	; 0x58
 8016df0:	68bb      	ldr	r3, [r7, #8]
 8016df2:	1c5a      	adds	r2, r3, #1
 8016df4:	60ba      	str	r2, [r7, #8]
 8016df6:	781b      	ldrb	r3, [r3, #0]
 8016df8:	001a      	movs	r2, r3
 8016dfa:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016dfc:	4313      	orrs	r3, r2
 8016dfe:	65bb      	str	r3, [r7, #88]	; 0x58
 8016e00:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016e02:	021b      	lsls	r3, r3, #8
 8016e04:	65bb      	str	r3, [r7, #88]	; 0x58
 8016e06:	68bb      	ldr	r3, [r7, #8]
 8016e08:	1c5a      	adds	r2, r3, #1
 8016e0a:	60ba      	str	r2, [r7, #8]
 8016e0c:	781b      	ldrb	r3, [r3, #0]
 8016e0e:	001a      	movs	r2, r3
 8016e10:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016e12:	4313      	orrs	r3, r2
 8016e14:	65bb      	str	r3, [r7, #88]	; 0x58
 8016e16:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016e18:	021b      	lsls	r3, r3, #8
 8016e1a:	65bb      	str	r3, [r7, #88]	; 0x58
 8016e1c:	68bb      	ldr	r3, [r7, #8]
 8016e1e:	1c5a      	adds	r2, r3, #1
 8016e20:	60ba      	str	r2, [r7, #8]
 8016e22:	781b      	ldrb	r3, [r3, #0]
 8016e24:	001a      	movs	r2, r3
 8016e26:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016e28:	4313      	orrs	r3, r2
 8016e2a:	65bb      	str	r3, [r7, #88]	; 0x58
	    ciaddr1 = lwip_htonl(l);
 8016e2c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016e2e:	0018      	movs	r0, r3
 8016e30:	f7f0 fafc 	bl	800742c <lwip_htonl>
 8016e34:	0003      	movs	r3, r0
 8016e36:	657b      	str	r3, [r7, #84]	; 0x54
	    if (ciaddr1 && go->accept_local)
 8016e38:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016e3a:	2b00      	cmp	r3, #0
 8016e3c:	d009      	beq.n	8016e52 <ipcp_nakci+0x6a6>
 8016e3e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016e40:	781b      	ldrb	r3, [r3, #0]
 8016e42:	2240      	movs	r2, #64	; 0x40
 8016e44:	4013      	ands	r3, r2
 8016e46:	b2db      	uxtb	r3, r3
 8016e48:	2b00      	cmp	r3, #0
 8016e4a:	d002      	beq.n	8016e52 <ipcp_nakci+0x6a6>
		try_.ouraddr = ciaddr1;
 8016e4c:	193b      	adds	r3, r7, r4
 8016e4e:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8016e50:	605a      	str	r2, [r3, #4]
	    GETLONG(l, p);
 8016e52:	68bb      	ldr	r3, [r7, #8]
 8016e54:	1c5a      	adds	r2, r3, #1
 8016e56:	60ba      	str	r2, [r7, #8]
 8016e58:	781b      	ldrb	r3, [r3, #0]
 8016e5a:	021b      	lsls	r3, r3, #8
 8016e5c:	65bb      	str	r3, [r7, #88]	; 0x58
 8016e5e:	68bb      	ldr	r3, [r7, #8]
 8016e60:	1c5a      	adds	r2, r3, #1
 8016e62:	60ba      	str	r2, [r7, #8]
 8016e64:	781b      	ldrb	r3, [r3, #0]
 8016e66:	001a      	movs	r2, r3
 8016e68:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016e6a:	4313      	orrs	r3, r2
 8016e6c:	65bb      	str	r3, [r7, #88]	; 0x58
 8016e6e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016e70:	021b      	lsls	r3, r3, #8
 8016e72:	65bb      	str	r3, [r7, #88]	; 0x58
 8016e74:	68bb      	ldr	r3, [r7, #8]
 8016e76:	1c5a      	adds	r2, r3, #1
 8016e78:	60ba      	str	r2, [r7, #8]
 8016e7a:	781b      	ldrb	r3, [r3, #0]
 8016e7c:	001a      	movs	r2, r3
 8016e7e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016e80:	4313      	orrs	r3, r2
 8016e82:	65bb      	str	r3, [r7, #88]	; 0x58
 8016e84:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016e86:	021b      	lsls	r3, r3, #8
 8016e88:	65bb      	str	r3, [r7, #88]	; 0x58
 8016e8a:	68bb      	ldr	r3, [r7, #8]
 8016e8c:	1c5a      	adds	r2, r3, #1
 8016e8e:	60ba      	str	r2, [r7, #8]
 8016e90:	781b      	ldrb	r3, [r3, #0]
 8016e92:	001a      	movs	r2, r3
 8016e94:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016e96:	4313      	orrs	r3, r2
 8016e98:	65bb      	str	r3, [r7, #88]	; 0x58
	    ciaddr2 = lwip_htonl(l);
 8016e9a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016e9c:	0018      	movs	r0, r3
 8016e9e:	f7f0 fac5 	bl	800742c <lwip_htonl>
 8016ea2:	0003      	movs	r3, r0
 8016ea4:	653b      	str	r3, [r7, #80]	; 0x50
	    if (ciaddr2 && go->accept_remote)
 8016ea6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016ea8:	2b00      	cmp	r3, #0
 8016eaa:	d00a      	beq.n	8016ec2 <ipcp_nakci+0x716>
 8016eac:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016eae:	781b      	ldrb	r3, [r3, #0]
 8016eb0:	227f      	movs	r2, #127	; 0x7f
 8016eb2:	4393      	bics	r3, r2
 8016eb4:	b2db      	uxtb	r3, r3
 8016eb6:	2b00      	cmp	r3, #0
 8016eb8:	d003      	beq.n	8016ec2 <ipcp_nakci+0x716>
		try_.hisaddr = ciaddr2;
 8016eba:	2310      	movs	r3, #16
 8016ebc:	18fb      	adds	r3, r7, r3
 8016ebe:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8016ec0:	609a      	str	r2, [r3, #8]
	    no.old_addrs = 1;
 8016ec2:	2328      	movs	r3, #40	; 0x28
 8016ec4:	18fb      	adds	r3, r7, r3
 8016ec6:	781a      	ldrb	r2, [r3, #0]
 8016ec8:	2102      	movs	r1, #2
 8016eca:	430a      	orrs	r2, r1
 8016ecc:	701a      	strb	r2, [r3, #0]
	    break;
 8016ece:	e0fe      	b.n	80170ce <ipcp_nakci+0x922>
	case CI_ADDR:
	    if (go->neg_addr || no.neg_addr || cilen != CILEN_ADDR)
 8016ed0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016ed2:	781b      	ldrb	r3, [r3, #0]
 8016ed4:	2201      	movs	r2, #1
 8016ed6:	4013      	ands	r3, r2
 8016ed8:	b2db      	uxtb	r3, r3
 8016eda:	2b00      	cmp	r3, #0
 8016edc:	d000      	beq.n	8016ee0 <ipcp_nakci+0x734>
 8016ede:	e10f      	b.n	8017100 <ipcp_nakci+0x954>
 8016ee0:	2328      	movs	r3, #40	; 0x28
 8016ee2:	18fb      	adds	r3, r7, r3
 8016ee4:	781b      	ldrb	r3, [r3, #0]
 8016ee6:	2201      	movs	r2, #1
 8016ee8:	4013      	ands	r3, r2
 8016eea:	b2db      	uxtb	r3, r3
 8016eec:	2b00      	cmp	r3, #0
 8016eee:	d000      	beq.n	8016ef2 <ipcp_nakci+0x746>
 8016ef0:	e106      	b.n	8017100 <ipcp_nakci+0x954>
 8016ef2:	235f      	movs	r3, #95	; 0x5f
 8016ef4:	18fb      	adds	r3, r7, r3
 8016ef6:	781b      	ldrb	r3, [r3, #0]
 8016ef8:	2b06      	cmp	r3, #6
 8016efa:	d000      	beq.n	8016efe <ipcp_nakci+0x752>
 8016efc:	e100      	b.n	8017100 <ipcp_nakci+0x954>
		goto bad;
	    try_.old_addrs = 0;
 8016efe:	2410      	movs	r4, #16
 8016f00:	193b      	adds	r3, r7, r4
 8016f02:	781a      	ldrb	r2, [r3, #0]
 8016f04:	2102      	movs	r1, #2
 8016f06:	438a      	bics	r2, r1
 8016f08:	701a      	strb	r2, [r3, #0]
	    GETLONG(l, p);
 8016f0a:	68bb      	ldr	r3, [r7, #8]
 8016f0c:	1c5a      	adds	r2, r3, #1
 8016f0e:	60ba      	str	r2, [r7, #8]
 8016f10:	781b      	ldrb	r3, [r3, #0]
 8016f12:	021b      	lsls	r3, r3, #8
 8016f14:	65bb      	str	r3, [r7, #88]	; 0x58
 8016f16:	68bb      	ldr	r3, [r7, #8]
 8016f18:	1c5a      	adds	r2, r3, #1
 8016f1a:	60ba      	str	r2, [r7, #8]
 8016f1c:	781b      	ldrb	r3, [r3, #0]
 8016f1e:	001a      	movs	r2, r3
 8016f20:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016f22:	4313      	orrs	r3, r2
 8016f24:	65bb      	str	r3, [r7, #88]	; 0x58
 8016f26:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016f28:	021b      	lsls	r3, r3, #8
 8016f2a:	65bb      	str	r3, [r7, #88]	; 0x58
 8016f2c:	68bb      	ldr	r3, [r7, #8]
 8016f2e:	1c5a      	adds	r2, r3, #1
 8016f30:	60ba      	str	r2, [r7, #8]
 8016f32:	781b      	ldrb	r3, [r3, #0]
 8016f34:	001a      	movs	r2, r3
 8016f36:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016f38:	4313      	orrs	r3, r2
 8016f3a:	65bb      	str	r3, [r7, #88]	; 0x58
 8016f3c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016f3e:	021b      	lsls	r3, r3, #8
 8016f40:	65bb      	str	r3, [r7, #88]	; 0x58
 8016f42:	68bb      	ldr	r3, [r7, #8]
 8016f44:	1c5a      	adds	r2, r3, #1
 8016f46:	60ba      	str	r2, [r7, #8]
 8016f48:	781b      	ldrb	r3, [r3, #0]
 8016f4a:	001a      	movs	r2, r3
 8016f4c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016f4e:	4313      	orrs	r3, r2
 8016f50:	65bb      	str	r3, [r7, #88]	; 0x58
	    ciaddr1 = lwip_htonl(l);
 8016f52:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016f54:	0018      	movs	r0, r3
 8016f56:	f7f0 fa69 	bl	800742c <lwip_htonl>
 8016f5a:	0003      	movs	r3, r0
 8016f5c:	657b      	str	r3, [r7, #84]	; 0x54
	    if (ciaddr1 && go->accept_local)
 8016f5e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016f60:	2b00      	cmp	r3, #0
 8016f62:	d009      	beq.n	8016f78 <ipcp_nakci+0x7cc>
 8016f64:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016f66:	781b      	ldrb	r3, [r3, #0]
 8016f68:	2240      	movs	r2, #64	; 0x40
 8016f6a:	4013      	ands	r3, r2
 8016f6c:	b2db      	uxtb	r3, r3
 8016f6e:	2b00      	cmp	r3, #0
 8016f70:	d002      	beq.n	8016f78 <ipcp_nakci+0x7cc>
		try_.ouraddr = ciaddr1;
 8016f72:	193b      	adds	r3, r7, r4
 8016f74:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8016f76:	605a      	str	r2, [r3, #4]
	    if (try_.ouraddr != 0)
 8016f78:	2210      	movs	r2, #16
 8016f7a:	18bb      	adds	r3, r7, r2
 8016f7c:	685b      	ldr	r3, [r3, #4]
 8016f7e:	2b00      	cmp	r3, #0
 8016f80:	d004      	beq.n	8016f8c <ipcp_nakci+0x7e0>
		try_.neg_addr = 1;
 8016f82:	18bb      	adds	r3, r7, r2
 8016f84:	781a      	ldrb	r2, [r3, #0]
 8016f86:	2101      	movs	r1, #1
 8016f88:	430a      	orrs	r2, r1
 8016f8a:	701a      	strb	r2, [r3, #0]
	    no.neg_addr = 1;
 8016f8c:	2328      	movs	r3, #40	; 0x28
 8016f8e:	18fb      	adds	r3, r7, r3
 8016f90:	781a      	ldrb	r2, [r3, #0]
 8016f92:	2101      	movs	r1, #1
 8016f94:	430a      	orrs	r2, r1
 8016f96:	701a      	strb	r2, [r3, #0]
	    break;
 8016f98:	e099      	b.n	80170ce <ipcp_nakci+0x922>
#if LWIP_DNS
	case CI_MS_DNS1:
	    if (go->req_dns1 || no.req_dns1 || cilen != CILEN_ADDR)
 8016f9a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016f9c:	785b      	ldrb	r3, [r3, #1]
 8016f9e:	2201      	movs	r2, #1
 8016fa0:	4013      	ands	r3, r2
 8016fa2:	b2db      	uxtb	r3, r3
 8016fa4:	2b00      	cmp	r3, #0
 8016fa6:	d000      	beq.n	8016faa <ipcp_nakci+0x7fe>
 8016fa8:	e0ac      	b.n	8017104 <ipcp_nakci+0x958>
 8016faa:	2428      	movs	r4, #40	; 0x28
 8016fac:	193b      	adds	r3, r7, r4
 8016fae:	785b      	ldrb	r3, [r3, #1]
 8016fb0:	2201      	movs	r2, #1
 8016fb2:	4013      	ands	r3, r2
 8016fb4:	b2db      	uxtb	r3, r3
 8016fb6:	2b00      	cmp	r3, #0
 8016fb8:	d000      	beq.n	8016fbc <ipcp_nakci+0x810>
 8016fba:	e0a3      	b.n	8017104 <ipcp_nakci+0x958>
 8016fbc:	235f      	movs	r3, #95	; 0x5f
 8016fbe:	18fb      	adds	r3, r7, r3
 8016fc0:	781b      	ldrb	r3, [r3, #0]
 8016fc2:	2b06      	cmp	r3, #6
 8016fc4:	d000      	beq.n	8016fc8 <ipcp_nakci+0x81c>
 8016fc6:	e09d      	b.n	8017104 <ipcp_nakci+0x958>
		goto bad;
	    GETLONG(l, p);
 8016fc8:	68bb      	ldr	r3, [r7, #8]
 8016fca:	1c5a      	adds	r2, r3, #1
 8016fcc:	60ba      	str	r2, [r7, #8]
 8016fce:	781b      	ldrb	r3, [r3, #0]
 8016fd0:	021b      	lsls	r3, r3, #8
 8016fd2:	65bb      	str	r3, [r7, #88]	; 0x58
 8016fd4:	68bb      	ldr	r3, [r7, #8]
 8016fd6:	1c5a      	adds	r2, r3, #1
 8016fd8:	60ba      	str	r2, [r7, #8]
 8016fda:	781b      	ldrb	r3, [r3, #0]
 8016fdc:	001a      	movs	r2, r3
 8016fde:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016fe0:	4313      	orrs	r3, r2
 8016fe2:	65bb      	str	r3, [r7, #88]	; 0x58
 8016fe4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016fe6:	021b      	lsls	r3, r3, #8
 8016fe8:	65bb      	str	r3, [r7, #88]	; 0x58
 8016fea:	68bb      	ldr	r3, [r7, #8]
 8016fec:	1c5a      	adds	r2, r3, #1
 8016fee:	60ba      	str	r2, [r7, #8]
 8016ff0:	781b      	ldrb	r3, [r3, #0]
 8016ff2:	001a      	movs	r2, r3
 8016ff4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016ff6:	4313      	orrs	r3, r2
 8016ff8:	65bb      	str	r3, [r7, #88]	; 0x58
 8016ffa:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016ffc:	021b      	lsls	r3, r3, #8
 8016ffe:	65bb      	str	r3, [r7, #88]	; 0x58
 8017000:	68bb      	ldr	r3, [r7, #8]
 8017002:	1c5a      	adds	r2, r3, #1
 8017004:	60ba      	str	r2, [r7, #8]
 8017006:	781b      	ldrb	r3, [r3, #0]
 8017008:	001a      	movs	r2, r3
 801700a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801700c:	4313      	orrs	r3, r2
 801700e:	65bb      	str	r3, [r7, #88]	; 0x58
	    try_.dnsaddr[0] = lwip_htonl(l);
 8017010:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8017012:	0018      	movs	r0, r3
 8017014:	f7f0 fa0a 	bl	800742c <lwip_htonl>
 8017018:	0002      	movs	r2, r0
 801701a:	2110      	movs	r1, #16
 801701c:	187b      	adds	r3, r7, r1
 801701e:	60da      	str	r2, [r3, #12]
	    try_.req_dns1 = 1;
 8017020:	187b      	adds	r3, r7, r1
 8017022:	785a      	ldrb	r2, [r3, #1]
 8017024:	2101      	movs	r1, #1
 8017026:	430a      	orrs	r2, r1
 8017028:	705a      	strb	r2, [r3, #1]
	    no.req_dns1 = 1;
 801702a:	193b      	adds	r3, r7, r4
 801702c:	785a      	ldrb	r2, [r3, #1]
 801702e:	2101      	movs	r1, #1
 8017030:	430a      	orrs	r2, r1
 8017032:	705a      	strb	r2, [r3, #1]
	    break;
 8017034:	e04b      	b.n	80170ce <ipcp_nakci+0x922>
	case CI_MS_DNS2:
	    if (go->req_dns2 || no.req_dns2 || cilen != CILEN_ADDR)
 8017036:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8017038:	785b      	ldrb	r3, [r3, #1]
 801703a:	2202      	movs	r2, #2
 801703c:	4013      	ands	r3, r2
 801703e:	b2db      	uxtb	r3, r3
 8017040:	2b00      	cmp	r3, #0
 8017042:	d161      	bne.n	8017108 <ipcp_nakci+0x95c>
 8017044:	2428      	movs	r4, #40	; 0x28
 8017046:	193b      	adds	r3, r7, r4
 8017048:	785b      	ldrb	r3, [r3, #1]
 801704a:	2202      	movs	r2, #2
 801704c:	4013      	ands	r3, r2
 801704e:	b2db      	uxtb	r3, r3
 8017050:	2b00      	cmp	r3, #0
 8017052:	d159      	bne.n	8017108 <ipcp_nakci+0x95c>
 8017054:	235f      	movs	r3, #95	; 0x5f
 8017056:	18fb      	adds	r3, r7, r3
 8017058:	781b      	ldrb	r3, [r3, #0]
 801705a:	2b06      	cmp	r3, #6
 801705c:	d154      	bne.n	8017108 <ipcp_nakci+0x95c>
		goto bad;
	    GETLONG(l, p);
 801705e:	68bb      	ldr	r3, [r7, #8]
 8017060:	1c5a      	adds	r2, r3, #1
 8017062:	60ba      	str	r2, [r7, #8]
 8017064:	781b      	ldrb	r3, [r3, #0]
 8017066:	021b      	lsls	r3, r3, #8
 8017068:	65bb      	str	r3, [r7, #88]	; 0x58
 801706a:	68bb      	ldr	r3, [r7, #8]
 801706c:	1c5a      	adds	r2, r3, #1
 801706e:	60ba      	str	r2, [r7, #8]
 8017070:	781b      	ldrb	r3, [r3, #0]
 8017072:	001a      	movs	r2, r3
 8017074:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8017076:	4313      	orrs	r3, r2
 8017078:	65bb      	str	r3, [r7, #88]	; 0x58
 801707a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801707c:	021b      	lsls	r3, r3, #8
 801707e:	65bb      	str	r3, [r7, #88]	; 0x58
 8017080:	68bb      	ldr	r3, [r7, #8]
 8017082:	1c5a      	adds	r2, r3, #1
 8017084:	60ba      	str	r2, [r7, #8]
 8017086:	781b      	ldrb	r3, [r3, #0]
 8017088:	001a      	movs	r2, r3
 801708a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801708c:	4313      	orrs	r3, r2
 801708e:	65bb      	str	r3, [r7, #88]	; 0x58
 8017090:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8017092:	021b      	lsls	r3, r3, #8
 8017094:	65bb      	str	r3, [r7, #88]	; 0x58
 8017096:	68bb      	ldr	r3, [r7, #8]
 8017098:	1c5a      	adds	r2, r3, #1
 801709a:	60ba      	str	r2, [r7, #8]
 801709c:	781b      	ldrb	r3, [r3, #0]
 801709e:	001a      	movs	r2, r3
 80170a0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80170a2:	4313      	orrs	r3, r2
 80170a4:	65bb      	str	r3, [r7, #88]	; 0x58
	    try_.dnsaddr[1] = lwip_htonl(l);
 80170a6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80170a8:	0018      	movs	r0, r3
 80170aa:	f7f0 f9bf 	bl	800742c <lwip_htonl>
 80170ae:	0002      	movs	r2, r0
 80170b0:	2110      	movs	r1, #16
 80170b2:	187b      	adds	r3, r7, r1
 80170b4:	611a      	str	r2, [r3, #16]
	    try_.req_dns2 = 1;
 80170b6:	187b      	adds	r3, r7, r1
 80170b8:	785a      	ldrb	r2, [r3, #1]
 80170ba:	2102      	movs	r1, #2
 80170bc:	430a      	orrs	r2, r1
 80170be:	705a      	strb	r2, [r3, #1]
	    no.req_dns2 = 1;
 80170c0:	193b      	adds	r3, r7, r4
 80170c2:	785a      	ldrb	r2, [r3, #1]
 80170c4:	2102      	movs	r1, #2
 80170c6:	430a      	orrs	r2, r1
 80170c8:	705a      	strb	r2, [r3, #1]
	    break;
 80170ca:	e000      	b.n	80170ce <ipcp_nakci+0x922>
	    if (ciaddr1)
		try_.winsaddr[citype == CI_MS_WINS2] = ciaddr1;
	    break;
#endif /* UNUSED - WINS */
	default:
	    break;
 80170cc:	46c0      	nop			; (mov r8, r8)
	}
	p = next;
 80170ce:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80170d0:	60bb      	str	r3, [r7, #8]
    while (len >= CILEN_VOID) {
 80170d2:	687b      	ldr	r3, [r7, #4]
 80170d4:	2b01      	cmp	r3, #1
 80170d6:	dd00      	ble.n	80170da <ipcp_nakci+0x92e>
 80170d8:	e607      	b.n	8016cea <ipcp_nakci+0x53e>

    /*
     * OK, the Nak is good.  Now we can update state.
     * If there are any remaining options, we ignore them.
     */
    if (f->state != PPP_FSM_OPENED)
 80170da:	68fb      	ldr	r3, [r7, #12]
 80170dc:	7c1b      	ldrb	r3, [r3, #16]
 80170de:	2b09      	cmp	r3, #9
 80170e0:	d006      	beq.n	80170f0 <ipcp_nakci+0x944>
	*go = try_;
 80170e2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80170e4:	2210      	movs	r2, #16
 80170e6:	18ba      	adds	r2, r7, r2
 80170e8:	ca13      	ldmia	r2!, {r0, r1, r4}
 80170ea:	c313      	stmia	r3!, {r0, r1, r4}
 80170ec:	ca13      	ldmia	r2!, {r0, r1, r4}
 80170ee:	c313      	stmia	r3!, {r0, r1, r4}

    return 1;
 80170f0:	2301      	movs	r3, #1
 80170f2:	e00b      	b.n	801710c <ipcp_nakci+0x960>
	    goto bad;
 80170f4:	46c0      	nop			; (mov r8, r8)
 80170f6:	e008      	b.n	801710a <ipcp_nakci+0x95e>
		goto bad;
 80170f8:	46c0      	nop			; (mov r8, r8)
 80170fa:	e006      	b.n	801710a <ipcp_nakci+0x95e>
		goto bad;
 80170fc:	46c0      	nop			; (mov r8, r8)
 80170fe:	e004      	b.n	801710a <ipcp_nakci+0x95e>
		goto bad;
 8017100:	46c0      	nop			; (mov r8, r8)
 8017102:	e002      	b.n	801710a <ipcp_nakci+0x95e>
		goto bad;
 8017104:	46c0      	nop			; (mov r8, r8)
 8017106:	e000      	b.n	801710a <ipcp_nakci+0x95e>
		goto bad;
 8017108:	46c0      	nop			; (mov r8, r8)

bad:
    IPCPDEBUG(("ipcp_nakci: received bad Nak!"));
    return 0;
 801710a:	2300      	movs	r3, #0
}
 801710c:	0018      	movs	r0, r3
 801710e:	46bd      	mov	sp, r7
 8017110:	b01b      	add	sp, #108	; 0x6c
 8017112:	bdf0      	pop	{r4, r5, r6, r7, pc}

08017114 <ipcp_rejci>:

/*
 * ipcp_rejci - Reject some of our CIs.
 * Callback from fsm_rconfnakrej.
 */
static int ipcp_rejci(fsm *f, u_char *p, int len) {
 8017114:	b5b0      	push	{r4, r5, r7, lr}
 8017116:	b094      	sub	sp, #80	; 0x50
 8017118:	af00      	add	r7, sp, #0
 801711a:	60f8      	str	r0, [r7, #12]
 801711c:	60b9      	str	r1, [r7, #8]
 801711e:	607a      	str	r2, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8017120:	68fb      	ldr	r3, [r7, #12]
 8017122:	681b      	ldr	r3, [r3, #0]
 8017124:	64fb      	str	r3, [r7, #76]	; 0x4c
    ipcp_options *go = &pcb->ipcp_gotoptions;
 8017126:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8017128:	4a57      	ldr	r2, [pc, #348]	; (8017288 <ipcp_rejci+0x174>)
 801712a:	4694      	mov	ip, r2
 801712c:	4463      	add	r3, ip
 801712e:	64bb      	str	r3, [r7, #72]	; 0x48
    u_short cishort;
#endif /* VJ_SUPPORT */
    u32_t cilong;
    ipcp_options try_;		/* options to request next time */

    try_ = *go;
 8017130:	2414      	movs	r4, #20
 8017132:	193b      	adds	r3, r7, r4
 8017134:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8017136:	ca23      	ldmia	r2!, {r0, r1, r5}
 8017138:	c323      	stmia	r3!, {r0, r1, r5}
 801713a:	ca23      	ldmia	r2!, {r0, r1, r5}
 801713c:	c323      	stmia	r3!, {r0, r1, r5}
	    goto bad; \
	try_.winsaddr[opt == CI_MS_WINS2] = 0; \
    }
#endif /* UNUSED - WINS */

    REJCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs,
 801713e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8017140:	781b      	ldrb	r3, [r3, #0]
 8017142:	2201      	movs	r2, #1
 8017144:	4013      	ands	r3, r2
 8017146:	b2db      	uxtb	r3, r3
 8017148:	2b00      	cmp	r3, #0
 801714a:	d000      	beq.n	801714e <ipcp_rejci+0x3a>
 801714c:	e086      	b.n	801725c <ipcp_rejci+0x148>
 801714e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8017150:	781b      	ldrb	r3, [r3, #0]
 8017152:	2202      	movs	r2, #2
 8017154:	4013      	ands	r3, r2
 8017156:	b2db      	uxtb	r3, r3
 8017158:	2b00      	cmp	r3, #0
 801715a:	d100      	bne.n	801715e <ipcp_rejci+0x4a>
 801715c:	e07e      	b.n	801725c <ipcp_rejci+0x148>
 801715e:	2147      	movs	r1, #71	; 0x47
 8017160:	187b      	adds	r3, r7, r1
 8017162:	68ba      	ldr	r2, [r7, #8]
 8017164:	7852      	ldrb	r2, [r2, #1]
 8017166:	701a      	strb	r2, [r3, #0]
 8017168:	187b      	adds	r3, r7, r1
 801716a:	781b      	ldrb	r3, [r3, #0]
 801716c:	2b0a      	cmp	r3, #10
 801716e:	d175      	bne.n	801725c <ipcp_rejci+0x148>
 8017170:	187b      	adds	r3, r7, r1
 8017172:	781b      	ldrb	r3, [r3, #0]
 8017174:	687a      	ldr	r2, [r7, #4]
 8017176:	429a      	cmp	r2, r3
 8017178:	db70      	blt.n	801725c <ipcp_rejci+0x148>
 801717a:	68bb      	ldr	r3, [r7, #8]
 801717c:	781b      	ldrb	r3, [r3, #0]
 801717e:	2b01      	cmp	r3, #1
 8017180:	d16c      	bne.n	801725c <ipcp_rejci+0x148>
 8017182:	187b      	adds	r3, r7, r1
 8017184:	781b      	ldrb	r3, [r3, #0]
 8017186:	687a      	ldr	r2, [r7, #4]
 8017188:	1ad3      	subs	r3, r2, r3
 801718a:	607b      	str	r3, [r7, #4]
 801718c:	68bb      	ldr	r3, [r7, #8]
 801718e:	3302      	adds	r3, #2
 8017190:	60bb      	str	r3, [r7, #8]
 8017192:	68bb      	ldr	r3, [r7, #8]
 8017194:	1c5a      	adds	r2, r3, #1
 8017196:	60ba      	str	r2, [r7, #8]
 8017198:	781b      	ldrb	r3, [r3, #0]
 801719a:	021b      	lsls	r3, r3, #8
 801719c:	643b      	str	r3, [r7, #64]	; 0x40
 801719e:	68bb      	ldr	r3, [r7, #8]
 80171a0:	1c5a      	adds	r2, r3, #1
 80171a2:	60ba      	str	r2, [r7, #8]
 80171a4:	781b      	ldrb	r3, [r3, #0]
 80171a6:	001a      	movs	r2, r3
 80171a8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80171aa:	4313      	orrs	r3, r2
 80171ac:	643b      	str	r3, [r7, #64]	; 0x40
 80171ae:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80171b0:	021b      	lsls	r3, r3, #8
 80171b2:	643b      	str	r3, [r7, #64]	; 0x40
 80171b4:	68bb      	ldr	r3, [r7, #8]
 80171b6:	1c5a      	adds	r2, r3, #1
 80171b8:	60ba      	str	r2, [r7, #8]
 80171ba:	781b      	ldrb	r3, [r3, #0]
 80171bc:	001a      	movs	r2, r3
 80171be:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80171c0:	4313      	orrs	r3, r2
 80171c2:	643b      	str	r3, [r7, #64]	; 0x40
 80171c4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80171c6:	021b      	lsls	r3, r3, #8
 80171c8:	643b      	str	r3, [r7, #64]	; 0x40
 80171ca:	68bb      	ldr	r3, [r7, #8]
 80171cc:	1c5a      	adds	r2, r3, #1
 80171ce:	60ba      	str	r2, [r7, #8]
 80171d0:	781b      	ldrb	r3, [r3, #0]
 80171d2:	001a      	movs	r2, r3
 80171d4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80171d6:	4313      	orrs	r3, r2
 80171d8:	643b      	str	r3, [r7, #64]	; 0x40
 80171da:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80171dc:	0018      	movs	r0, r3
 80171de:	f7f0 f925 	bl	800742c <lwip_htonl>
 80171e2:	0003      	movs	r3, r0
 80171e4:	63fb      	str	r3, [r7, #60]	; 0x3c
 80171e6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80171e8:	685b      	ldr	r3, [r3, #4]
 80171ea:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80171ec:	429a      	cmp	r2, r3
 80171ee:	d000      	beq.n	80171f2 <ipcp_rejci+0xde>
 80171f0:	e1bf      	b.n	8017572 <ipcp_rejci+0x45e>
 80171f2:	68bb      	ldr	r3, [r7, #8]
 80171f4:	1c5a      	adds	r2, r3, #1
 80171f6:	60ba      	str	r2, [r7, #8]
 80171f8:	781b      	ldrb	r3, [r3, #0]
 80171fa:	021b      	lsls	r3, r3, #8
 80171fc:	643b      	str	r3, [r7, #64]	; 0x40
 80171fe:	68bb      	ldr	r3, [r7, #8]
 8017200:	1c5a      	adds	r2, r3, #1
 8017202:	60ba      	str	r2, [r7, #8]
 8017204:	781b      	ldrb	r3, [r3, #0]
 8017206:	001a      	movs	r2, r3
 8017208:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801720a:	4313      	orrs	r3, r2
 801720c:	643b      	str	r3, [r7, #64]	; 0x40
 801720e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8017210:	021b      	lsls	r3, r3, #8
 8017212:	643b      	str	r3, [r7, #64]	; 0x40
 8017214:	68bb      	ldr	r3, [r7, #8]
 8017216:	1c5a      	adds	r2, r3, #1
 8017218:	60ba      	str	r2, [r7, #8]
 801721a:	781b      	ldrb	r3, [r3, #0]
 801721c:	001a      	movs	r2, r3
 801721e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8017220:	4313      	orrs	r3, r2
 8017222:	643b      	str	r3, [r7, #64]	; 0x40
 8017224:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8017226:	021b      	lsls	r3, r3, #8
 8017228:	643b      	str	r3, [r7, #64]	; 0x40
 801722a:	68bb      	ldr	r3, [r7, #8]
 801722c:	1c5a      	adds	r2, r3, #1
 801722e:	60ba      	str	r2, [r7, #8]
 8017230:	781b      	ldrb	r3, [r3, #0]
 8017232:	001a      	movs	r2, r3
 8017234:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8017236:	4313      	orrs	r3, r2
 8017238:	643b      	str	r3, [r7, #64]	; 0x40
 801723a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801723c:	0018      	movs	r0, r3
 801723e:	f7f0 f8f5 	bl	800742c <lwip_htonl>
 8017242:	0003      	movs	r3, r0
 8017244:	63fb      	str	r3, [r7, #60]	; 0x3c
 8017246:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8017248:	689b      	ldr	r3, [r3, #8]
 801724a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801724c:	429a      	cmp	r2, r3
 801724e:	d000      	beq.n	8017252 <ipcp_rejci+0x13e>
 8017250:	e191      	b.n	8017576 <ipcp_rejci+0x462>
 8017252:	193b      	adds	r3, r7, r4
 8017254:	781a      	ldrb	r2, [r3, #0]
 8017256:	2102      	movs	r1, #2
 8017258:	438a      	bics	r2, r1
 801725a:	701a      	strb	r2, [r3, #0]
	       go->ouraddr, go->hisaddr);

#if VJ_SUPPORT
    REJCIVJ(CI_COMPRESSTYPE, neg_vj, go->vj_protocol, go->old_vj,
 801725c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801725e:	781b      	ldrb	r3, [r3, #0]
 8017260:	2208      	movs	r2, #8
 8017262:	4013      	ands	r3, r2
 8017264:	b2db      	uxtb	r3, r3
 8017266:	2b00      	cmp	r3, #0
 8017268:	d100      	bne.n	801726c <ipcp_rejci+0x158>
 801726a:	e06e      	b.n	801734a <ipcp_rejci+0x236>
 801726c:	68bb      	ldr	r3, [r7, #8]
 801726e:	3301      	adds	r3, #1
 8017270:	781b      	ldrb	r3, [r3, #0]
 8017272:	0019      	movs	r1, r3
 8017274:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8017276:	781b      	ldrb	r3, [r3, #0]
 8017278:	2210      	movs	r2, #16
 801727a:	4013      	ands	r3, r2
 801727c:	b2db      	uxtb	r3, r3
 801727e:	2b00      	cmp	r3, #0
 8017280:	d004      	beq.n	801728c <ipcp_rejci+0x178>
 8017282:	2304      	movs	r3, #4
 8017284:	e003      	b.n	801728e <ipcp_rejci+0x17a>
 8017286:	46c0      	nop			; (mov r8, r8)
 8017288:	0000121c 	.word	0x0000121c
 801728c:	2306      	movs	r3, #6
 801728e:	428b      	cmp	r3, r1
 8017290:	d15b      	bne.n	801734a <ipcp_rejci+0x236>
 8017292:	68bb      	ldr	r3, [r7, #8]
 8017294:	3301      	adds	r3, #1
 8017296:	781b      	ldrb	r3, [r3, #0]
 8017298:	001a      	movs	r2, r3
 801729a:	687b      	ldr	r3, [r7, #4]
 801729c:	4293      	cmp	r3, r2
 801729e:	db54      	blt.n	801734a <ipcp_rejci+0x236>
 80172a0:	68bb      	ldr	r3, [r7, #8]
 80172a2:	781b      	ldrb	r3, [r3, #0]
 80172a4:	2b02      	cmp	r3, #2
 80172a6:	d150      	bne.n	801734a <ipcp_rejci+0x236>
 80172a8:	68bb      	ldr	r3, [r7, #8]
 80172aa:	3301      	adds	r3, #1
 80172ac:	781b      	ldrb	r3, [r3, #0]
 80172ae:	001a      	movs	r2, r3
 80172b0:	687b      	ldr	r3, [r7, #4]
 80172b2:	1a9b      	subs	r3, r3, r2
 80172b4:	607b      	str	r3, [r7, #4]
 80172b6:	68bb      	ldr	r3, [r7, #8]
 80172b8:	3302      	adds	r3, #2
 80172ba:	60bb      	str	r3, [r7, #8]
 80172bc:	68bb      	ldr	r3, [r7, #8]
 80172be:	1c5a      	adds	r2, r3, #1
 80172c0:	60ba      	str	r2, [r7, #8]
 80172c2:	781b      	ldrb	r3, [r3, #0]
 80172c4:	b29a      	uxth	r2, r3
 80172c6:	203a      	movs	r0, #58	; 0x3a
 80172c8:	183b      	adds	r3, r7, r0
 80172ca:	0212      	lsls	r2, r2, #8
 80172cc:	801a      	strh	r2, [r3, #0]
 80172ce:	68bb      	ldr	r3, [r7, #8]
 80172d0:	1c5a      	adds	r2, r3, #1
 80172d2:	60ba      	str	r2, [r7, #8]
 80172d4:	781b      	ldrb	r3, [r3, #0]
 80172d6:	b299      	uxth	r1, r3
 80172d8:	183b      	adds	r3, r7, r0
 80172da:	183a      	adds	r2, r7, r0
 80172dc:	8812      	ldrh	r2, [r2, #0]
 80172de:	430a      	orrs	r2, r1
 80172e0:	801a      	strh	r2, [r3, #0]
 80172e2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80172e4:	8a9b      	ldrh	r3, [r3, #20]
 80172e6:	183a      	adds	r2, r7, r0
 80172e8:	8812      	ldrh	r2, [r2, #0]
 80172ea:	429a      	cmp	r2, r3
 80172ec:	d000      	beq.n	80172f0 <ipcp_rejci+0x1dc>
 80172ee:	e144      	b.n	801757a <ipcp_rejci+0x466>
 80172f0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80172f2:	781b      	ldrb	r3, [r3, #0]
 80172f4:	2210      	movs	r2, #16
 80172f6:	4013      	ands	r3, r2
 80172f8:	b2db      	uxtb	r3, r3
 80172fa:	2b00      	cmp	r3, #0
 80172fc:	d11f      	bne.n	801733e <ipcp_rejci+0x22a>
 80172fe:	68bb      	ldr	r3, [r7, #8]
 8017300:	1c5a      	adds	r2, r3, #1
 8017302:	60ba      	str	r2, [r7, #8]
 8017304:	2139      	movs	r1, #57	; 0x39
 8017306:	187a      	adds	r2, r7, r1
 8017308:	781b      	ldrb	r3, [r3, #0]
 801730a:	7013      	strb	r3, [r2, #0]
 801730c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801730e:	7d9b      	ldrb	r3, [r3, #22]
 8017310:	187a      	adds	r2, r7, r1
 8017312:	7812      	ldrb	r2, [r2, #0]
 8017314:	429a      	cmp	r2, r3
 8017316:	d000      	beq.n	801731a <ipcp_rejci+0x206>
 8017318:	e131      	b.n	801757e <ipcp_rejci+0x46a>
 801731a:	68bb      	ldr	r3, [r7, #8]
 801731c:	1c5a      	adds	r2, r3, #1
 801731e:	60ba      	str	r2, [r7, #8]
 8017320:	2138      	movs	r1, #56	; 0x38
 8017322:	187a      	adds	r2, r7, r1
 8017324:	781b      	ldrb	r3, [r3, #0]
 8017326:	7013      	strb	r3, [r2, #0]
 8017328:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801732a:	781b      	ldrb	r3, [r3, #0]
 801732c:	069b      	lsls	r3, r3, #26
 801732e:	0fdb      	lsrs	r3, r3, #31
 8017330:	b2db      	uxtb	r3, r3
 8017332:	001a      	movs	r2, r3
 8017334:	187b      	adds	r3, r7, r1
 8017336:	781b      	ldrb	r3, [r3, #0]
 8017338:	4293      	cmp	r3, r2
 801733a:	d000      	beq.n	801733e <ipcp_rejci+0x22a>
 801733c:	e121      	b.n	8017582 <ipcp_rejci+0x46e>
 801733e:	2314      	movs	r3, #20
 8017340:	18fb      	adds	r3, r7, r3
 8017342:	781a      	ldrb	r2, [r3, #0]
 8017344:	2108      	movs	r1, #8
 8017346:	438a      	bics	r2, r1
 8017348:	701a      	strb	r2, [r3, #0]
	    go->maxslotindex, go->cflag);
#endif /* VJ_SUPPORT */

    REJCIADDR(CI_ADDR, neg_addr, go->ouraddr);
 801734a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801734c:	781b      	ldrb	r3, [r3, #0]
 801734e:	2201      	movs	r2, #1
 8017350:	4013      	ands	r3, r2
 8017352:	b2db      	uxtb	r3, r3
 8017354:	2b00      	cmp	r3, #0
 8017356:	d04f      	beq.n	80173f8 <ipcp_rejci+0x2e4>
 8017358:	2147      	movs	r1, #71	; 0x47
 801735a:	187b      	adds	r3, r7, r1
 801735c:	68ba      	ldr	r2, [r7, #8]
 801735e:	7852      	ldrb	r2, [r2, #1]
 8017360:	701a      	strb	r2, [r3, #0]
 8017362:	187b      	adds	r3, r7, r1
 8017364:	781b      	ldrb	r3, [r3, #0]
 8017366:	2b06      	cmp	r3, #6
 8017368:	d146      	bne.n	80173f8 <ipcp_rejci+0x2e4>
 801736a:	187b      	adds	r3, r7, r1
 801736c:	781b      	ldrb	r3, [r3, #0]
 801736e:	687a      	ldr	r2, [r7, #4]
 8017370:	429a      	cmp	r2, r3
 8017372:	db41      	blt.n	80173f8 <ipcp_rejci+0x2e4>
 8017374:	68bb      	ldr	r3, [r7, #8]
 8017376:	781b      	ldrb	r3, [r3, #0]
 8017378:	2b03      	cmp	r3, #3
 801737a:	d13d      	bne.n	80173f8 <ipcp_rejci+0x2e4>
 801737c:	187b      	adds	r3, r7, r1
 801737e:	781b      	ldrb	r3, [r3, #0]
 8017380:	687a      	ldr	r2, [r7, #4]
 8017382:	1ad3      	subs	r3, r2, r3
 8017384:	607b      	str	r3, [r7, #4]
 8017386:	68bb      	ldr	r3, [r7, #8]
 8017388:	3302      	adds	r3, #2
 801738a:	60bb      	str	r3, [r7, #8]
 801738c:	68bb      	ldr	r3, [r7, #8]
 801738e:	1c5a      	adds	r2, r3, #1
 8017390:	60ba      	str	r2, [r7, #8]
 8017392:	781b      	ldrb	r3, [r3, #0]
 8017394:	021b      	lsls	r3, r3, #8
 8017396:	637b      	str	r3, [r7, #52]	; 0x34
 8017398:	68bb      	ldr	r3, [r7, #8]
 801739a:	1c5a      	adds	r2, r3, #1
 801739c:	60ba      	str	r2, [r7, #8]
 801739e:	781b      	ldrb	r3, [r3, #0]
 80173a0:	001a      	movs	r2, r3
 80173a2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80173a4:	4313      	orrs	r3, r2
 80173a6:	637b      	str	r3, [r7, #52]	; 0x34
 80173a8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80173aa:	021b      	lsls	r3, r3, #8
 80173ac:	637b      	str	r3, [r7, #52]	; 0x34
 80173ae:	68bb      	ldr	r3, [r7, #8]
 80173b0:	1c5a      	adds	r2, r3, #1
 80173b2:	60ba      	str	r2, [r7, #8]
 80173b4:	781b      	ldrb	r3, [r3, #0]
 80173b6:	001a      	movs	r2, r3
 80173b8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80173ba:	4313      	orrs	r3, r2
 80173bc:	637b      	str	r3, [r7, #52]	; 0x34
 80173be:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80173c0:	021b      	lsls	r3, r3, #8
 80173c2:	637b      	str	r3, [r7, #52]	; 0x34
 80173c4:	68bb      	ldr	r3, [r7, #8]
 80173c6:	1c5a      	adds	r2, r3, #1
 80173c8:	60ba      	str	r2, [r7, #8]
 80173ca:	781b      	ldrb	r3, [r3, #0]
 80173cc:	001a      	movs	r2, r3
 80173ce:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80173d0:	4313      	orrs	r3, r2
 80173d2:	637b      	str	r3, [r7, #52]	; 0x34
 80173d4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80173d6:	0018      	movs	r0, r3
 80173d8:	f7f0 f828 	bl	800742c <lwip_htonl>
 80173dc:	0003      	movs	r3, r0
 80173de:	63fb      	str	r3, [r7, #60]	; 0x3c
 80173e0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80173e2:	685b      	ldr	r3, [r3, #4]
 80173e4:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80173e6:	429a      	cmp	r2, r3
 80173e8:	d000      	beq.n	80173ec <ipcp_rejci+0x2d8>
 80173ea:	e0cc      	b.n	8017586 <ipcp_rejci+0x472>
 80173ec:	2314      	movs	r3, #20
 80173ee:	18fb      	adds	r3, r7, r3
 80173f0:	781a      	ldrb	r2, [r3, #0]
 80173f2:	2101      	movs	r1, #1
 80173f4:	438a      	bics	r2, r1
 80173f6:	701a      	strb	r2, [r3, #0]

#if LWIP_DNS
    REJCIDNS(CI_MS_DNS1, req_dns1, go->dnsaddr[0]);
 80173f8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80173fa:	785b      	ldrb	r3, [r3, #1]
 80173fc:	2201      	movs	r2, #1
 80173fe:	4013      	ands	r3, r2
 8017400:	b2db      	uxtb	r3, r3
 8017402:	2b00      	cmp	r3, #0
 8017404:	d04f      	beq.n	80174a6 <ipcp_rejci+0x392>
 8017406:	2147      	movs	r1, #71	; 0x47
 8017408:	187b      	adds	r3, r7, r1
 801740a:	68ba      	ldr	r2, [r7, #8]
 801740c:	7852      	ldrb	r2, [r2, #1]
 801740e:	701a      	strb	r2, [r3, #0]
 8017410:	187b      	adds	r3, r7, r1
 8017412:	781b      	ldrb	r3, [r3, #0]
 8017414:	2b06      	cmp	r3, #6
 8017416:	d146      	bne.n	80174a6 <ipcp_rejci+0x392>
 8017418:	187b      	adds	r3, r7, r1
 801741a:	781b      	ldrb	r3, [r3, #0]
 801741c:	687a      	ldr	r2, [r7, #4]
 801741e:	429a      	cmp	r2, r3
 8017420:	db41      	blt.n	80174a6 <ipcp_rejci+0x392>
 8017422:	68bb      	ldr	r3, [r7, #8]
 8017424:	781b      	ldrb	r3, [r3, #0]
 8017426:	2b81      	cmp	r3, #129	; 0x81
 8017428:	d13d      	bne.n	80174a6 <ipcp_rejci+0x392>
 801742a:	187b      	adds	r3, r7, r1
 801742c:	781b      	ldrb	r3, [r3, #0]
 801742e:	687a      	ldr	r2, [r7, #4]
 8017430:	1ad3      	subs	r3, r2, r3
 8017432:	607b      	str	r3, [r7, #4]
 8017434:	68bb      	ldr	r3, [r7, #8]
 8017436:	3302      	adds	r3, #2
 8017438:	60bb      	str	r3, [r7, #8]
 801743a:	68bb      	ldr	r3, [r7, #8]
 801743c:	1c5a      	adds	r2, r3, #1
 801743e:	60ba      	str	r2, [r7, #8]
 8017440:	781b      	ldrb	r3, [r3, #0]
 8017442:	021b      	lsls	r3, r3, #8
 8017444:	633b      	str	r3, [r7, #48]	; 0x30
 8017446:	68bb      	ldr	r3, [r7, #8]
 8017448:	1c5a      	adds	r2, r3, #1
 801744a:	60ba      	str	r2, [r7, #8]
 801744c:	781b      	ldrb	r3, [r3, #0]
 801744e:	001a      	movs	r2, r3
 8017450:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017452:	4313      	orrs	r3, r2
 8017454:	633b      	str	r3, [r7, #48]	; 0x30
 8017456:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017458:	021b      	lsls	r3, r3, #8
 801745a:	633b      	str	r3, [r7, #48]	; 0x30
 801745c:	68bb      	ldr	r3, [r7, #8]
 801745e:	1c5a      	adds	r2, r3, #1
 8017460:	60ba      	str	r2, [r7, #8]
 8017462:	781b      	ldrb	r3, [r3, #0]
 8017464:	001a      	movs	r2, r3
 8017466:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017468:	4313      	orrs	r3, r2
 801746a:	633b      	str	r3, [r7, #48]	; 0x30
 801746c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801746e:	021b      	lsls	r3, r3, #8
 8017470:	633b      	str	r3, [r7, #48]	; 0x30
 8017472:	68bb      	ldr	r3, [r7, #8]
 8017474:	1c5a      	adds	r2, r3, #1
 8017476:	60ba      	str	r2, [r7, #8]
 8017478:	781b      	ldrb	r3, [r3, #0]
 801747a:	001a      	movs	r2, r3
 801747c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801747e:	4313      	orrs	r3, r2
 8017480:	633b      	str	r3, [r7, #48]	; 0x30
 8017482:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017484:	0018      	movs	r0, r3
 8017486:	f7ef ffd1 	bl	800742c <lwip_htonl>
 801748a:	0003      	movs	r3, r0
 801748c:	63fb      	str	r3, [r7, #60]	; 0x3c
 801748e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8017490:	68db      	ldr	r3, [r3, #12]
 8017492:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8017494:	429a      	cmp	r2, r3
 8017496:	d000      	beq.n	801749a <ipcp_rejci+0x386>
 8017498:	e077      	b.n	801758a <ipcp_rejci+0x476>
 801749a:	2314      	movs	r3, #20
 801749c:	18fb      	adds	r3, r7, r3
 801749e:	785a      	ldrb	r2, [r3, #1]
 80174a0:	2101      	movs	r1, #1
 80174a2:	438a      	bics	r2, r1
 80174a4:	705a      	strb	r2, [r3, #1]

    REJCIDNS(CI_MS_DNS2, req_dns2, go->dnsaddr[1]);
 80174a6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80174a8:	785b      	ldrb	r3, [r3, #1]
 80174aa:	2202      	movs	r2, #2
 80174ac:	4013      	ands	r3, r2
 80174ae:	b2db      	uxtb	r3, r3
 80174b0:	2b00      	cmp	r3, #0
 80174b2:	d04e      	beq.n	8017552 <ipcp_rejci+0x43e>
 80174b4:	2147      	movs	r1, #71	; 0x47
 80174b6:	187b      	adds	r3, r7, r1
 80174b8:	68ba      	ldr	r2, [r7, #8]
 80174ba:	7852      	ldrb	r2, [r2, #1]
 80174bc:	701a      	strb	r2, [r3, #0]
 80174be:	187b      	adds	r3, r7, r1
 80174c0:	781b      	ldrb	r3, [r3, #0]
 80174c2:	2b06      	cmp	r3, #6
 80174c4:	d145      	bne.n	8017552 <ipcp_rejci+0x43e>
 80174c6:	187b      	adds	r3, r7, r1
 80174c8:	781b      	ldrb	r3, [r3, #0]
 80174ca:	687a      	ldr	r2, [r7, #4]
 80174cc:	429a      	cmp	r2, r3
 80174ce:	db40      	blt.n	8017552 <ipcp_rejci+0x43e>
 80174d0:	68bb      	ldr	r3, [r7, #8]
 80174d2:	781b      	ldrb	r3, [r3, #0]
 80174d4:	2b83      	cmp	r3, #131	; 0x83
 80174d6:	d13c      	bne.n	8017552 <ipcp_rejci+0x43e>
 80174d8:	187b      	adds	r3, r7, r1
 80174da:	781b      	ldrb	r3, [r3, #0]
 80174dc:	687a      	ldr	r2, [r7, #4]
 80174de:	1ad3      	subs	r3, r2, r3
 80174e0:	607b      	str	r3, [r7, #4]
 80174e2:	68bb      	ldr	r3, [r7, #8]
 80174e4:	3302      	adds	r3, #2
 80174e6:	60bb      	str	r3, [r7, #8]
 80174e8:	68bb      	ldr	r3, [r7, #8]
 80174ea:	1c5a      	adds	r2, r3, #1
 80174ec:	60ba      	str	r2, [r7, #8]
 80174ee:	781b      	ldrb	r3, [r3, #0]
 80174f0:	021b      	lsls	r3, r3, #8
 80174f2:	62fb      	str	r3, [r7, #44]	; 0x2c
 80174f4:	68bb      	ldr	r3, [r7, #8]
 80174f6:	1c5a      	adds	r2, r3, #1
 80174f8:	60ba      	str	r2, [r7, #8]
 80174fa:	781b      	ldrb	r3, [r3, #0]
 80174fc:	001a      	movs	r2, r3
 80174fe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017500:	4313      	orrs	r3, r2
 8017502:	62fb      	str	r3, [r7, #44]	; 0x2c
 8017504:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017506:	021b      	lsls	r3, r3, #8
 8017508:	62fb      	str	r3, [r7, #44]	; 0x2c
 801750a:	68bb      	ldr	r3, [r7, #8]
 801750c:	1c5a      	adds	r2, r3, #1
 801750e:	60ba      	str	r2, [r7, #8]
 8017510:	781b      	ldrb	r3, [r3, #0]
 8017512:	001a      	movs	r2, r3
 8017514:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017516:	4313      	orrs	r3, r2
 8017518:	62fb      	str	r3, [r7, #44]	; 0x2c
 801751a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801751c:	021b      	lsls	r3, r3, #8
 801751e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8017520:	68bb      	ldr	r3, [r7, #8]
 8017522:	1c5a      	adds	r2, r3, #1
 8017524:	60ba      	str	r2, [r7, #8]
 8017526:	781b      	ldrb	r3, [r3, #0]
 8017528:	001a      	movs	r2, r3
 801752a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801752c:	4313      	orrs	r3, r2
 801752e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8017530:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017532:	0018      	movs	r0, r3
 8017534:	f7ef ff7a 	bl	800742c <lwip_htonl>
 8017538:	0003      	movs	r3, r0
 801753a:	63fb      	str	r3, [r7, #60]	; 0x3c
 801753c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801753e:	691b      	ldr	r3, [r3, #16]
 8017540:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8017542:	429a      	cmp	r2, r3
 8017544:	d123      	bne.n	801758e <ipcp_rejci+0x47a>
 8017546:	2314      	movs	r3, #20
 8017548:	18fb      	adds	r3, r7, r3
 801754a:	785a      	ldrb	r2, [r3, #1]
 801754c:	2102      	movs	r1, #2
 801754e:	438a      	bics	r2, r1
 8017550:	705a      	strb	r2, [r3, #1]
#endif /* UNUSED - WINS */

    /*
     * If there are any remaining CIs, then this packet is bad.
     */
    if (len != 0)
 8017552:	687b      	ldr	r3, [r7, #4]
 8017554:	2b00      	cmp	r3, #0
 8017556:	d11c      	bne.n	8017592 <ipcp_rejci+0x47e>
	goto bad;
    /*
     * Now we can update state.
     */
    if (f->state != PPP_FSM_OPENED)
 8017558:	68fb      	ldr	r3, [r7, #12]
 801755a:	7c1b      	ldrb	r3, [r3, #16]
 801755c:	2b09      	cmp	r3, #9
 801755e:	d006      	beq.n	801756e <ipcp_rejci+0x45a>
	*go = try_;
 8017560:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8017562:	2214      	movs	r2, #20
 8017564:	18ba      	adds	r2, r7, r2
 8017566:	ca13      	ldmia	r2!, {r0, r1, r4}
 8017568:	c313      	stmia	r3!, {r0, r1, r4}
 801756a:	ca13      	ldmia	r2!, {r0, r1, r4}
 801756c:	c313      	stmia	r3!, {r0, r1, r4}
    return 1;
 801756e:	2301      	movs	r3, #1
 8017570:	e011      	b.n	8017596 <ipcp_rejci+0x482>
    REJCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs,
 8017572:	46c0      	nop			; (mov r8, r8)
 8017574:	e00e      	b.n	8017594 <ipcp_rejci+0x480>
 8017576:	46c0      	nop			; (mov r8, r8)
 8017578:	e00c      	b.n	8017594 <ipcp_rejci+0x480>
    REJCIVJ(CI_COMPRESSTYPE, neg_vj, go->vj_protocol, go->old_vj,
 801757a:	46c0      	nop			; (mov r8, r8)
 801757c:	e00a      	b.n	8017594 <ipcp_rejci+0x480>
 801757e:	46c0      	nop			; (mov r8, r8)
 8017580:	e008      	b.n	8017594 <ipcp_rejci+0x480>
 8017582:	46c0      	nop			; (mov r8, r8)
 8017584:	e006      	b.n	8017594 <ipcp_rejci+0x480>
    REJCIADDR(CI_ADDR, neg_addr, go->ouraddr);
 8017586:	46c0      	nop			; (mov r8, r8)
 8017588:	e004      	b.n	8017594 <ipcp_rejci+0x480>
    REJCIDNS(CI_MS_DNS1, req_dns1, go->dnsaddr[0]);
 801758a:	46c0      	nop			; (mov r8, r8)
 801758c:	e002      	b.n	8017594 <ipcp_rejci+0x480>
    REJCIDNS(CI_MS_DNS2, req_dns2, go->dnsaddr[1]);
 801758e:	46c0      	nop			; (mov r8, r8)
 8017590:	e000      	b.n	8017594 <ipcp_rejci+0x480>
	goto bad;
 8017592:	46c0      	nop			; (mov r8, r8)

bad:
    IPCPDEBUG(("ipcp_rejci: received bad Reject!"));
    return 0;
 8017594:	2300      	movs	r3, #0
}
 8017596:	0018      	movs	r0, r3
 8017598:	46bd      	mov	sp, r7
 801759a:	b014      	add	sp, #80	; 0x50
 801759c:	bdb0      	pop	{r4, r5, r7, pc}
 801759e:	46c0      	nop			; (mov r8, r8)

080175a0 <ipcp_reqci>:
 * CONFNAK; returns CONFREJ if it can't return CONFACK.
 *
 * inp = Requested CIs
 * len = Length of requested CIs
 */
static int ipcp_reqci(fsm *f, u_char *inp, int *len, int reject_if_disagree) {
 80175a0:	b580      	push	{r7, lr}
 80175a2:	b096      	sub	sp, #88	; 0x58
 80175a4:	af00      	add	r7, sp, #0
 80175a6:	60f8      	str	r0, [r7, #12]
 80175a8:	60b9      	str	r1, [r7, #8]
 80175aa:	607a      	str	r2, [r7, #4]
 80175ac:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 80175ae:	68fb      	ldr	r3, [r7, #12]
 80175b0:	681b      	ldr	r3, [r3, #0]
 80175b2:	63bb      	str	r3, [r7, #56]	; 0x38
    ipcp_options *wo = &pcb->ipcp_wantoptions;
 80175b4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80175b6:	4abe      	ldr	r2, [pc, #760]	; (80178b0 <ipcp_reqci+0x310>)
 80175b8:	4694      	mov	ip, r2
 80175ba:	4463      	add	r3, ip
 80175bc:	637b      	str	r3, [r7, #52]	; 0x34
    ipcp_options *ho = &pcb->ipcp_hisoptions;
 80175be:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80175c0:	4abc      	ldr	r2, [pc, #752]	; (80178b4 <ipcp_reqci+0x314>)
 80175c2:	4694      	mov	ip, r2
 80175c4:	4463      	add	r3, ip
 80175c6:	633b      	str	r3, [r7, #48]	; 0x30
    ipcp_options *ao = &pcb->ipcp_allowoptions;
 80175c8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80175ca:	4abb      	ldr	r2, [pc, #748]	; (80178b8 <ipcp_reqci+0x318>)
 80175cc:	4694      	mov	ip, r2
 80175ce:	4463      	add	r3, ip
 80175d0:	62fb      	str	r3, [r7, #44]	; 0x2c
    u_short cilen, citype;	/* Parsed len, type */
#if VJ_SUPPORT
    u_short cishort;		/* Parsed short value */
#endif /* VJ_SUPPORT */
    u32_t tl, ciaddr1, ciaddr2;/* Parsed address values */
    int rc = CONFACK;		/* Final packet return code */
 80175d2:	2302      	movs	r3, #2
 80175d4:	64fb      	str	r3, [r7, #76]	; 0x4c
    int orc;			/* Individual option return code */
    u_char *p;			/* Pointer to next char to parse */
    u_char *ucp = inp;		/* Pointer to current output char */
 80175d6:	68bb      	ldr	r3, [r7, #8]
 80175d8:	643b      	str	r3, [r7, #64]	; 0x40
    int l = *len;		/* Length left */
 80175da:	687b      	ldr	r3, [r7, #4]
 80175dc:	681b      	ldr	r3, [r3, #0]
 80175de:	63fb      	str	r3, [r7, #60]	; 0x3c
#endif /* LWIP_DNS */

    /*
     * Reset all his options.
     */
    BZERO(ho, sizeof(*ho));
 80175e0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80175e2:	2218      	movs	r2, #24
 80175e4:	2100      	movs	r1, #0
 80175e6:	0018      	movs	r0, r3
 80175e8:	f006 fcf4 	bl	801dfd4 <memset>
    
    /*
     * Process all his options.
     */
    next = inp;
 80175ec:	68bb      	ldr	r3, [r7, #8]
 80175ee:	657b      	str	r3, [r7, #84]	; 0x54
    while (l) {
 80175f0:	e33d      	b.n	8017c6e <ipcp_reqci+0x6ce>
	orc = CONFACK;			/* Assume success */
 80175f2:	2302      	movs	r3, #2
 80175f4:	64bb      	str	r3, [r7, #72]	; 0x48
	cip = p = next;			/* Remember begining of CI */
 80175f6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80175f8:	647b      	str	r3, [r7, #68]	; 0x44
 80175fa:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80175fc:	627b      	str	r3, [r7, #36]	; 0x24
	if (l < 2 ||			/* Not enough data for CI header or */
 80175fe:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8017600:	2b01      	cmp	r3, #1
 8017602:	dd0b      	ble.n	801761c <ipcp_reqci+0x7c>
	    p[1] < 2 ||			/*  CI length too small or */
 8017604:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017606:	3301      	adds	r3, #1
 8017608:	781b      	ldrb	r3, [r3, #0]
	if (l < 2 ||			/* Not enough data for CI header or */
 801760a:	2b01      	cmp	r3, #1
 801760c:	d906      	bls.n	801761c <ipcp_reqci+0x7c>
	    p[1] > l) {			/*  CI length too big? */
 801760e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017610:	3301      	adds	r3, #1
 8017612:	781b      	ldrb	r3, [r3, #0]
 8017614:	001a      	movs	r2, r3
	    p[1] < 2 ||			/*  CI length too small or */
 8017616:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8017618:	4293      	cmp	r3, r2
 801761a:	da08      	bge.n	801762e <ipcp_reqci+0x8e>
	    IPCPDEBUG(("ipcp_reqci: bad CI length!"));
	    orc = CONFREJ;		/* Reject bad CI */
 801761c:	2304      	movs	r3, #4
 801761e:	64bb      	str	r3, [r7, #72]	; 0x48
	    cilen = l;			/* Reject till end of packet */
 8017620:	2352      	movs	r3, #82	; 0x52
 8017622:	18fb      	adds	r3, r7, r3
 8017624:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8017626:	801a      	strh	r2, [r3, #0]
	    l = 0;			/* Don't loop again */
 8017628:	2300      	movs	r3, #0
 801762a:	63fb      	str	r3, [r7, #60]	; 0x3c
	    goto endswitch;
 801762c:	e2e8      	b.n	8017c00 <ipcp_reqci+0x660>
	}
	GETCHAR(citype, p);		/* Parse CI type */
 801762e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017630:	1c5a      	adds	r2, r3, #1
 8017632:	647a      	str	r2, [r7, #68]	; 0x44
 8017634:	781a      	ldrb	r2, [r3, #0]
 8017636:	2022      	movs	r0, #34	; 0x22
 8017638:	183b      	adds	r3, r7, r0
 801763a:	801a      	strh	r2, [r3, #0]
	GETCHAR(cilen, p);		/* Parse CI length */
 801763c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801763e:	1c5a      	adds	r2, r3, #1
 8017640:	647a      	str	r2, [r7, #68]	; 0x44
 8017642:	781a      	ldrb	r2, [r3, #0]
 8017644:	2152      	movs	r1, #82	; 0x52
 8017646:	187b      	adds	r3, r7, r1
 8017648:	801a      	strh	r2, [r3, #0]
	l -= cilen;			/* Adjust remaining length */
 801764a:	187b      	adds	r3, r7, r1
 801764c:	881b      	ldrh	r3, [r3, #0]
 801764e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8017650:	1ad3      	subs	r3, r2, r3
 8017652:	63fb      	str	r3, [r7, #60]	; 0x3c
	next += cilen;			/* Step to next CI */
 8017654:	187b      	adds	r3, r7, r1
 8017656:	881b      	ldrh	r3, [r3, #0]
 8017658:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801765a:	18d3      	adds	r3, r2, r3
 801765c:	657b      	str	r3, [r7, #84]	; 0x54

	switch (citype) {		/* Check CI type */
 801765e:	183b      	adds	r3, r7, r0
 8017660:	881b      	ldrh	r3, [r3, #0]
 8017662:	2b83      	cmp	r3, #131	; 0x83
 8017664:	d100      	bne.n	8017668 <ipcp_reqci+0xc8>
 8017666:	e1a5      	b.n	80179b4 <ipcp_reqci+0x414>
 8017668:	dd00      	ble.n	801766c <ipcp_reqci+0xcc>
 801766a:	e2c5      	b.n	8017bf8 <ipcp_reqci+0x658>
 801766c:	2b81      	cmp	r3, #129	; 0x81
 801766e:	d100      	bne.n	8017672 <ipcp_reqci+0xd2>
 8017670:	e1a0      	b.n	80179b4 <ipcp_reqci+0x414>
 8017672:	dd00      	ble.n	8017676 <ipcp_reqci+0xd6>
 8017674:	e2c0      	b.n	8017bf8 <ipcp_reqci+0x658>
 8017676:	2b03      	cmp	r3, #3
 8017678:	d100      	bne.n	801767c <ipcp_reqci+0xdc>
 801767a:	e103      	b.n	8017884 <ipcp_reqci+0x2e4>
 801767c:	dd00      	ble.n	8017680 <ipcp_reqci+0xe0>
 801767e:	e2bb      	b.n	8017bf8 <ipcp_reqci+0x658>
 8017680:	2b01      	cmp	r3, #1
 8017682:	d003      	beq.n	801768c <ipcp_reqci+0xec>
 8017684:	2b02      	cmp	r3, #2
 8017686:	d100      	bne.n	801768a <ipcp_reqci+0xea>
 8017688:	e20d      	b.n	8017aa6 <ipcp_reqci+0x506>
 801768a:	e2b5      	b.n	8017bf8 <ipcp_reqci+0x658>
	case CI_ADDRS:
	    if (!ao->old_addrs || ho->neg_addr ||
 801768c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801768e:	781b      	ldrb	r3, [r3, #0]
 8017690:	2202      	movs	r2, #2
 8017692:	4013      	ands	r3, r2
 8017694:	b2db      	uxtb	r3, r3
 8017696:	2b00      	cmp	r3, #0
 8017698:	d00b      	beq.n	80176b2 <ipcp_reqci+0x112>
 801769a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801769c:	781b      	ldrb	r3, [r3, #0]
 801769e:	2201      	movs	r2, #1
 80176a0:	4013      	ands	r3, r2
 80176a2:	b2db      	uxtb	r3, r3
 80176a4:	2b00      	cmp	r3, #0
 80176a6:	d104      	bne.n	80176b2 <ipcp_reqci+0x112>
 80176a8:	2352      	movs	r3, #82	; 0x52
 80176aa:	18fb      	adds	r3, r7, r3
 80176ac:	881b      	ldrh	r3, [r3, #0]
 80176ae:	2b0a      	cmp	r3, #10
 80176b0:	d002      	beq.n	80176b8 <ipcp_reqci+0x118>
		cilen != CILEN_ADDRS) {	/* Check CI length */
		orc = CONFREJ;		/* Reject CI */
 80176b2:	2304      	movs	r3, #4
 80176b4:	64bb      	str	r3, [r7, #72]	; 0x48
		break;
 80176b6:	e2a3      	b.n	8017c00 <ipcp_reqci+0x660>
	     * If he has no address, or if we both have his address but
	     * disagree about it, then NAK it with our idea.
	     * In particular, if we don't know his address, but he does,
	     * then accept it.
	     */
	    GETLONG(tl, p);		/* Parse source address (his) */
 80176b8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80176ba:	1c5a      	adds	r2, r3, #1
 80176bc:	647a      	str	r2, [r7, #68]	; 0x44
 80176be:	781b      	ldrb	r3, [r3, #0]
 80176c0:	021b      	lsls	r3, r3, #8
 80176c2:	62bb      	str	r3, [r7, #40]	; 0x28
 80176c4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80176c6:	1c5a      	adds	r2, r3, #1
 80176c8:	647a      	str	r2, [r7, #68]	; 0x44
 80176ca:	781b      	ldrb	r3, [r3, #0]
 80176cc:	001a      	movs	r2, r3
 80176ce:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80176d0:	4313      	orrs	r3, r2
 80176d2:	62bb      	str	r3, [r7, #40]	; 0x28
 80176d4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80176d6:	021b      	lsls	r3, r3, #8
 80176d8:	62bb      	str	r3, [r7, #40]	; 0x28
 80176da:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80176dc:	1c5a      	adds	r2, r3, #1
 80176de:	647a      	str	r2, [r7, #68]	; 0x44
 80176e0:	781b      	ldrb	r3, [r3, #0]
 80176e2:	001a      	movs	r2, r3
 80176e4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80176e6:	4313      	orrs	r3, r2
 80176e8:	62bb      	str	r3, [r7, #40]	; 0x28
 80176ea:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80176ec:	021b      	lsls	r3, r3, #8
 80176ee:	62bb      	str	r3, [r7, #40]	; 0x28
 80176f0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80176f2:	1c5a      	adds	r2, r3, #1
 80176f4:	647a      	str	r2, [r7, #68]	; 0x44
 80176f6:	781b      	ldrb	r3, [r3, #0]
 80176f8:	001a      	movs	r2, r3
 80176fa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80176fc:	4313      	orrs	r3, r2
 80176fe:	62bb      	str	r3, [r7, #40]	; 0x28
	    ciaddr1 = lwip_htonl(tl);
 8017700:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017702:	0018      	movs	r0, r3
 8017704:	f7ef fe92 	bl	800742c <lwip_htonl>
 8017708:	0003      	movs	r3, r0
 801770a:	61bb      	str	r3, [r7, #24]
	    if (ciaddr1 != wo->hisaddr
 801770c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801770e:	689b      	ldr	r3, [r3, #8]
 8017710:	69ba      	ldr	r2, [r7, #24]
 8017712:	429a      	cmp	r2, r3
 8017714:	d034      	beq.n	8017780 <ipcp_reqci+0x1e0>
		&& (ciaddr1 == 0 || !wo->accept_remote)) {
 8017716:	69bb      	ldr	r3, [r7, #24]
 8017718:	2b00      	cmp	r3, #0
 801771a:	d006      	beq.n	801772a <ipcp_reqci+0x18a>
 801771c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801771e:	781b      	ldrb	r3, [r3, #0]
 8017720:	227f      	movs	r2, #127	; 0x7f
 8017722:	4393      	bics	r3, r2
 8017724:	b2db      	uxtb	r3, r3
 8017726:	2b00      	cmp	r3, #0
 8017728:	d12a      	bne.n	8017780 <ipcp_reqci+0x1e0>
		orc = CONFNAK;
 801772a:	2303      	movs	r3, #3
 801772c:	64bb      	str	r3, [r7, #72]	; 0x48
		if (!reject_if_disagree) {
 801772e:	683b      	ldr	r3, [r7, #0]
 8017730:	2b00      	cmp	r3, #0
 8017732:	d134      	bne.n	801779e <ipcp_reqci+0x1fe>
		    DECPTR(sizeof(u32_t), p);
 8017734:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017736:	3b04      	subs	r3, #4
 8017738:	647b      	str	r3, [r7, #68]	; 0x44
		    tl = lwip_ntohl(wo->hisaddr);
 801773a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801773c:	689b      	ldr	r3, [r3, #8]
 801773e:	0018      	movs	r0, r3
 8017740:	f7ef fe74 	bl	800742c <lwip_htonl>
 8017744:	0003      	movs	r3, r0
 8017746:	62bb      	str	r3, [r7, #40]	; 0x28
		    PUTLONG(tl, p);
 8017748:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801774a:	0e19      	lsrs	r1, r3, #24
 801774c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801774e:	1c5a      	adds	r2, r3, #1
 8017750:	647a      	str	r2, [r7, #68]	; 0x44
 8017752:	b2ca      	uxtb	r2, r1
 8017754:	701a      	strb	r2, [r3, #0]
 8017756:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017758:	0c19      	lsrs	r1, r3, #16
 801775a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801775c:	1c5a      	adds	r2, r3, #1
 801775e:	647a      	str	r2, [r7, #68]	; 0x44
 8017760:	b2ca      	uxtb	r2, r1
 8017762:	701a      	strb	r2, [r3, #0]
 8017764:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017766:	0a19      	lsrs	r1, r3, #8
 8017768:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801776a:	1c5a      	adds	r2, r3, #1
 801776c:	647a      	str	r2, [r7, #68]	; 0x44
 801776e:	b2ca      	uxtb	r2, r1
 8017770:	701a      	strb	r2, [r3, #0]
 8017772:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017774:	1c5a      	adds	r2, r3, #1
 8017776:	647a      	str	r2, [r7, #68]	; 0x44
 8017778:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801777a:	b2d2      	uxtb	r2, r2
 801777c:	701a      	strb	r2, [r3, #0]
		if (!reject_if_disagree) {
 801777e:	e00e      	b.n	801779e <ipcp_reqci+0x1fe>
		}
	    } else if (ciaddr1 == 0 && wo->hisaddr == 0) {
 8017780:	69bb      	ldr	r3, [r7, #24]
 8017782:	2b00      	cmp	r3, #0
 8017784:	d10b      	bne.n	801779e <ipcp_reqci+0x1fe>
 8017786:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017788:	689b      	ldr	r3, [r3, #8]
 801778a:	2b00      	cmp	r3, #0
 801778c:	d107      	bne.n	801779e <ipcp_reqci+0x1fe>
		/*
		 * If neither we nor he knows his address, reject the option.
		 */
		orc = CONFREJ;
 801778e:	2304      	movs	r3, #4
 8017790:	64bb      	str	r3, [r7, #72]	; 0x48
		wo->req_addr = 0;	/* don't NAK with 0.0.0.0 later */
 8017792:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017794:	781a      	ldrb	r2, [r3, #0]
 8017796:	2104      	movs	r1, #4
 8017798:	438a      	bics	r2, r1
 801779a:	701a      	strb	r2, [r3, #0]
		break;
 801779c:	e230      	b.n	8017c00 <ipcp_reqci+0x660>

	    /*
	     * If he doesn't know our address, or if we both have our address
	     * but disagree about it, then NAK it with our idea.
	     */
	    GETLONG(tl, p);		/* Parse desination address (ours) */
 801779e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80177a0:	1c5a      	adds	r2, r3, #1
 80177a2:	647a      	str	r2, [r7, #68]	; 0x44
 80177a4:	781b      	ldrb	r3, [r3, #0]
 80177a6:	021b      	lsls	r3, r3, #8
 80177a8:	62bb      	str	r3, [r7, #40]	; 0x28
 80177aa:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80177ac:	1c5a      	adds	r2, r3, #1
 80177ae:	647a      	str	r2, [r7, #68]	; 0x44
 80177b0:	781b      	ldrb	r3, [r3, #0]
 80177b2:	001a      	movs	r2, r3
 80177b4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80177b6:	4313      	orrs	r3, r2
 80177b8:	62bb      	str	r3, [r7, #40]	; 0x28
 80177ba:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80177bc:	021b      	lsls	r3, r3, #8
 80177be:	62bb      	str	r3, [r7, #40]	; 0x28
 80177c0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80177c2:	1c5a      	adds	r2, r3, #1
 80177c4:	647a      	str	r2, [r7, #68]	; 0x44
 80177c6:	781b      	ldrb	r3, [r3, #0]
 80177c8:	001a      	movs	r2, r3
 80177ca:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80177cc:	4313      	orrs	r3, r2
 80177ce:	62bb      	str	r3, [r7, #40]	; 0x28
 80177d0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80177d2:	021b      	lsls	r3, r3, #8
 80177d4:	62bb      	str	r3, [r7, #40]	; 0x28
 80177d6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80177d8:	1c5a      	adds	r2, r3, #1
 80177da:	647a      	str	r2, [r7, #68]	; 0x44
 80177dc:	781b      	ldrb	r3, [r3, #0]
 80177de:	001a      	movs	r2, r3
 80177e0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80177e2:	4313      	orrs	r3, r2
 80177e4:	62bb      	str	r3, [r7, #40]	; 0x28
	    ciaddr2 = lwip_htonl(tl);
 80177e6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80177e8:	0018      	movs	r0, r3
 80177ea:	f7ef fe1f 	bl	800742c <lwip_htonl>
 80177ee:	0003      	movs	r3, r0
 80177f0:	613b      	str	r3, [r7, #16]
	    if (ciaddr2 != wo->ouraddr) {
 80177f2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80177f4:	685b      	ldr	r3, [r3, #4]
 80177f6:	693a      	ldr	r2, [r7, #16]
 80177f8:	429a      	cmp	r2, r3
 80177fa:	d037      	beq.n	801786c <ipcp_reqci+0x2cc>
		if (ciaddr2 == 0 || !wo->accept_local) {
 80177fc:	693b      	ldr	r3, [r7, #16]
 80177fe:	2b00      	cmp	r3, #0
 8017800:	d006      	beq.n	8017810 <ipcp_reqci+0x270>
 8017802:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017804:	781b      	ldrb	r3, [r3, #0]
 8017806:	2240      	movs	r2, #64	; 0x40
 8017808:	4013      	ands	r3, r2
 801780a:	b2db      	uxtb	r3, r3
 801780c:	2b00      	cmp	r3, #0
 801780e:	d12a      	bne.n	8017866 <ipcp_reqci+0x2c6>
		    orc = CONFNAK;
 8017810:	2303      	movs	r3, #3
 8017812:	64bb      	str	r3, [r7, #72]	; 0x48
		    if (!reject_if_disagree) {
 8017814:	683b      	ldr	r3, [r7, #0]
 8017816:	2b00      	cmp	r3, #0
 8017818:	d128      	bne.n	801786c <ipcp_reqci+0x2cc>
			DECPTR(sizeof(u32_t), p);
 801781a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801781c:	3b04      	subs	r3, #4
 801781e:	647b      	str	r3, [r7, #68]	; 0x44
			tl = lwip_ntohl(wo->ouraddr);
 8017820:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017822:	685b      	ldr	r3, [r3, #4]
 8017824:	0018      	movs	r0, r3
 8017826:	f7ef fe01 	bl	800742c <lwip_htonl>
 801782a:	0003      	movs	r3, r0
 801782c:	62bb      	str	r3, [r7, #40]	; 0x28
			PUTLONG(tl, p);
 801782e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017830:	0e19      	lsrs	r1, r3, #24
 8017832:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017834:	1c5a      	adds	r2, r3, #1
 8017836:	647a      	str	r2, [r7, #68]	; 0x44
 8017838:	b2ca      	uxtb	r2, r1
 801783a:	701a      	strb	r2, [r3, #0]
 801783c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801783e:	0c19      	lsrs	r1, r3, #16
 8017840:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017842:	1c5a      	adds	r2, r3, #1
 8017844:	647a      	str	r2, [r7, #68]	; 0x44
 8017846:	b2ca      	uxtb	r2, r1
 8017848:	701a      	strb	r2, [r3, #0]
 801784a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801784c:	0a19      	lsrs	r1, r3, #8
 801784e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017850:	1c5a      	adds	r2, r3, #1
 8017852:	647a      	str	r2, [r7, #68]	; 0x44
 8017854:	b2ca      	uxtb	r2, r1
 8017856:	701a      	strb	r2, [r3, #0]
 8017858:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801785a:	1c5a      	adds	r2, r3, #1
 801785c:	647a      	str	r2, [r7, #68]	; 0x44
 801785e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8017860:	b2d2      	uxtb	r2, r2
 8017862:	701a      	strb	r2, [r3, #0]
		    if (!reject_if_disagree) {
 8017864:	e002      	b.n	801786c <ipcp_reqci+0x2cc>
		    }
		} else {
		    wo->ouraddr = ciaddr2;	/* accept peer's idea */
 8017866:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017868:	693a      	ldr	r2, [r7, #16]
 801786a:	605a      	str	r2, [r3, #4]
		}
	    }

	    ho->old_addrs = 1;
 801786c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801786e:	781a      	ldrb	r2, [r3, #0]
 8017870:	2102      	movs	r1, #2
 8017872:	430a      	orrs	r2, r1
 8017874:	701a      	strb	r2, [r3, #0]
	    ho->hisaddr = ciaddr1;
 8017876:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017878:	69ba      	ldr	r2, [r7, #24]
 801787a:	609a      	str	r2, [r3, #8]
	    ho->ouraddr = ciaddr2;
 801787c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801787e:	693a      	ldr	r2, [r7, #16]
 8017880:	605a      	str	r2, [r3, #4]
	    break;
 8017882:	e1bd      	b.n	8017c00 <ipcp_reqci+0x660>

	case CI_ADDR:
	    if (!ao->neg_addr || ho->old_addrs ||
 8017884:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017886:	781b      	ldrb	r3, [r3, #0]
 8017888:	2201      	movs	r2, #1
 801788a:	4013      	ands	r3, r2
 801788c:	b2db      	uxtb	r3, r3
 801788e:	2b00      	cmp	r3, #0
 8017890:	d00b      	beq.n	80178aa <ipcp_reqci+0x30a>
 8017892:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017894:	781b      	ldrb	r3, [r3, #0]
 8017896:	2202      	movs	r2, #2
 8017898:	4013      	ands	r3, r2
 801789a:	b2db      	uxtb	r3, r3
 801789c:	2b00      	cmp	r3, #0
 801789e:	d104      	bne.n	80178aa <ipcp_reqci+0x30a>
 80178a0:	2352      	movs	r3, #82	; 0x52
 80178a2:	18fb      	adds	r3, r7, r3
 80178a4:	881b      	ldrh	r3, [r3, #0]
 80178a6:	2b06      	cmp	r3, #6
 80178a8:	d008      	beq.n	80178bc <ipcp_reqci+0x31c>
		cilen != CILEN_ADDR) {	/* Check CI length */
		orc = CONFREJ;		/* Reject CI */
 80178aa:	2304      	movs	r3, #4
 80178ac:	64bb      	str	r3, [r7, #72]	; 0x48
		break;
 80178ae:	e1a7      	b.n	8017c00 <ipcp_reqci+0x660>
 80178b0:	00001204 	.word	0x00001204
 80178b4:	0000124c 	.word	0x0000124c
 80178b8:	00001234 	.word	0x00001234
	     * If he has no address, or if we both have his address but
	     * disagree about it, then NAK it with our idea.
	     * In particular, if we don't know his address, but he does,
	     * then accept it.
	     */
	    GETLONG(tl, p);	/* Parse source address (his) */
 80178bc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80178be:	1c5a      	adds	r2, r3, #1
 80178c0:	647a      	str	r2, [r7, #68]	; 0x44
 80178c2:	781b      	ldrb	r3, [r3, #0]
 80178c4:	021b      	lsls	r3, r3, #8
 80178c6:	62bb      	str	r3, [r7, #40]	; 0x28
 80178c8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80178ca:	1c5a      	adds	r2, r3, #1
 80178cc:	647a      	str	r2, [r7, #68]	; 0x44
 80178ce:	781b      	ldrb	r3, [r3, #0]
 80178d0:	001a      	movs	r2, r3
 80178d2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80178d4:	4313      	orrs	r3, r2
 80178d6:	62bb      	str	r3, [r7, #40]	; 0x28
 80178d8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80178da:	021b      	lsls	r3, r3, #8
 80178dc:	62bb      	str	r3, [r7, #40]	; 0x28
 80178de:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80178e0:	1c5a      	adds	r2, r3, #1
 80178e2:	647a      	str	r2, [r7, #68]	; 0x44
 80178e4:	781b      	ldrb	r3, [r3, #0]
 80178e6:	001a      	movs	r2, r3
 80178e8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80178ea:	4313      	orrs	r3, r2
 80178ec:	62bb      	str	r3, [r7, #40]	; 0x28
 80178ee:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80178f0:	021b      	lsls	r3, r3, #8
 80178f2:	62bb      	str	r3, [r7, #40]	; 0x28
 80178f4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80178f6:	1c5a      	adds	r2, r3, #1
 80178f8:	647a      	str	r2, [r7, #68]	; 0x44
 80178fa:	781b      	ldrb	r3, [r3, #0]
 80178fc:	001a      	movs	r2, r3
 80178fe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017900:	4313      	orrs	r3, r2
 8017902:	62bb      	str	r3, [r7, #40]	; 0x28
	    ciaddr1 = lwip_htonl(tl);
 8017904:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017906:	0018      	movs	r0, r3
 8017908:	f7ef fd90 	bl	800742c <lwip_htonl>
 801790c:	0003      	movs	r3, r0
 801790e:	61bb      	str	r3, [r7, #24]
	    if (ciaddr1 != wo->hisaddr
 8017910:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017912:	689b      	ldr	r3, [r3, #8]
 8017914:	69ba      	ldr	r2, [r7, #24]
 8017916:	429a      	cmp	r2, r3
 8017918:	d034      	beq.n	8017984 <ipcp_reqci+0x3e4>
		&& (ciaddr1 == 0 || !wo->accept_remote)) {
 801791a:	69bb      	ldr	r3, [r7, #24]
 801791c:	2b00      	cmp	r3, #0
 801791e:	d006      	beq.n	801792e <ipcp_reqci+0x38e>
 8017920:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017922:	781b      	ldrb	r3, [r3, #0]
 8017924:	227f      	movs	r2, #127	; 0x7f
 8017926:	4393      	bics	r3, r2
 8017928:	b2db      	uxtb	r3, r3
 801792a:	2b00      	cmp	r3, #0
 801792c:	d12a      	bne.n	8017984 <ipcp_reqci+0x3e4>
		orc = CONFNAK;
 801792e:	2303      	movs	r3, #3
 8017930:	64bb      	str	r3, [r7, #72]	; 0x48
		if (!reject_if_disagree) {
 8017932:	683b      	ldr	r3, [r7, #0]
 8017934:	2b00      	cmp	r3, #0
 8017936:	d134      	bne.n	80179a2 <ipcp_reqci+0x402>
		    DECPTR(sizeof(u32_t), p);
 8017938:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801793a:	3b04      	subs	r3, #4
 801793c:	647b      	str	r3, [r7, #68]	; 0x44
		    tl = lwip_ntohl(wo->hisaddr);
 801793e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017940:	689b      	ldr	r3, [r3, #8]
 8017942:	0018      	movs	r0, r3
 8017944:	f7ef fd72 	bl	800742c <lwip_htonl>
 8017948:	0003      	movs	r3, r0
 801794a:	62bb      	str	r3, [r7, #40]	; 0x28
		    PUTLONG(tl, p);
 801794c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801794e:	0e19      	lsrs	r1, r3, #24
 8017950:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017952:	1c5a      	adds	r2, r3, #1
 8017954:	647a      	str	r2, [r7, #68]	; 0x44
 8017956:	b2ca      	uxtb	r2, r1
 8017958:	701a      	strb	r2, [r3, #0]
 801795a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801795c:	0c19      	lsrs	r1, r3, #16
 801795e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017960:	1c5a      	adds	r2, r3, #1
 8017962:	647a      	str	r2, [r7, #68]	; 0x44
 8017964:	b2ca      	uxtb	r2, r1
 8017966:	701a      	strb	r2, [r3, #0]
 8017968:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801796a:	0a19      	lsrs	r1, r3, #8
 801796c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801796e:	1c5a      	adds	r2, r3, #1
 8017970:	647a      	str	r2, [r7, #68]	; 0x44
 8017972:	b2ca      	uxtb	r2, r1
 8017974:	701a      	strb	r2, [r3, #0]
 8017976:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017978:	1c5a      	adds	r2, r3, #1
 801797a:	647a      	str	r2, [r7, #68]	; 0x44
 801797c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801797e:	b2d2      	uxtb	r2, r2
 8017980:	701a      	strb	r2, [r3, #0]
		if (!reject_if_disagree) {
 8017982:	e00e      	b.n	80179a2 <ipcp_reqci+0x402>
		}
	    } else if (ciaddr1 == 0 && wo->hisaddr == 0) {
 8017984:	69bb      	ldr	r3, [r7, #24]
 8017986:	2b00      	cmp	r3, #0
 8017988:	d10b      	bne.n	80179a2 <ipcp_reqci+0x402>
 801798a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801798c:	689b      	ldr	r3, [r3, #8]
 801798e:	2b00      	cmp	r3, #0
 8017990:	d107      	bne.n	80179a2 <ipcp_reqci+0x402>
		/*
		 * Don't ACK an address of 0.0.0.0 - reject it instead.
		 */
		orc = CONFREJ;
 8017992:	2304      	movs	r3, #4
 8017994:	64bb      	str	r3, [r7, #72]	; 0x48
		wo->req_addr = 0;	/* don't NAK with 0.0.0.0 later */
 8017996:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017998:	781a      	ldrb	r2, [r3, #0]
 801799a:	2104      	movs	r1, #4
 801799c:	438a      	bics	r2, r1
 801799e:	701a      	strb	r2, [r3, #0]
		break;
 80179a0:	e12e      	b.n	8017c00 <ipcp_reqci+0x660>
	    }
	
	    ho->neg_addr = 1;
 80179a2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80179a4:	781a      	ldrb	r2, [r3, #0]
 80179a6:	2101      	movs	r1, #1
 80179a8:	430a      	orrs	r2, r1
 80179aa:	701a      	strb	r2, [r3, #0]
	    ho->hisaddr = ciaddr1;
 80179ac:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80179ae:	69ba      	ldr	r2, [r7, #24]
 80179b0:	609a      	str	r2, [r3, #8]
	    break;
 80179b2:	e125      	b.n	8017c00 <ipcp_reqci+0x660>

#if LWIP_DNS
	case CI_MS_DNS1:
	case CI_MS_DNS2:
	    /* Microsoft primary or secondary DNS request */
	    d = citype == CI_MS_DNS2;
 80179b4:	2322      	movs	r3, #34	; 0x22
 80179b6:	18fb      	adds	r3, r7, r3
 80179b8:	881b      	ldrh	r3, [r3, #0]
 80179ba:	3b83      	subs	r3, #131	; 0x83
 80179bc:	425a      	negs	r2, r3
 80179be:	4153      	adcs	r3, r2
 80179c0:	b2db      	uxtb	r3, r3
 80179c2:	61fb      	str	r3, [r7, #28]

	    /* If we do not have a DNS address then we cannot send it */
	    if (ao->dnsaddr[d] == 0 ||
 80179c4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80179c6:	69fb      	ldr	r3, [r7, #28]
 80179c8:	3302      	adds	r3, #2
 80179ca:	009b      	lsls	r3, r3, #2
 80179cc:	18d3      	adds	r3, r2, r3
 80179ce:	3304      	adds	r3, #4
 80179d0:	681b      	ldr	r3, [r3, #0]
 80179d2:	2b00      	cmp	r3, #0
 80179d4:	d004      	beq.n	80179e0 <ipcp_reqci+0x440>
 80179d6:	2352      	movs	r3, #82	; 0x52
 80179d8:	18fb      	adds	r3, r7, r3
 80179da:	881b      	ldrh	r3, [r3, #0]
 80179dc:	2b06      	cmp	r3, #6
 80179de:	d002      	beq.n	80179e6 <ipcp_reqci+0x446>
		cilen != CILEN_ADDR) {	/* Check CI length */
		orc = CONFREJ;		/* Reject CI */
 80179e0:	2304      	movs	r3, #4
 80179e2:	64bb      	str	r3, [r7, #72]	; 0x48
		break;
 80179e4:	e10c      	b.n	8017c00 <ipcp_reqci+0x660>
	    }
	    GETLONG(tl, p);
 80179e6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80179e8:	1c5a      	adds	r2, r3, #1
 80179ea:	647a      	str	r2, [r7, #68]	; 0x44
 80179ec:	781b      	ldrb	r3, [r3, #0]
 80179ee:	021b      	lsls	r3, r3, #8
 80179f0:	62bb      	str	r3, [r7, #40]	; 0x28
 80179f2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80179f4:	1c5a      	adds	r2, r3, #1
 80179f6:	647a      	str	r2, [r7, #68]	; 0x44
 80179f8:	781b      	ldrb	r3, [r3, #0]
 80179fa:	001a      	movs	r2, r3
 80179fc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80179fe:	4313      	orrs	r3, r2
 8017a00:	62bb      	str	r3, [r7, #40]	; 0x28
 8017a02:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017a04:	021b      	lsls	r3, r3, #8
 8017a06:	62bb      	str	r3, [r7, #40]	; 0x28
 8017a08:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017a0a:	1c5a      	adds	r2, r3, #1
 8017a0c:	647a      	str	r2, [r7, #68]	; 0x44
 8017a0e:	781b      	ldrb	r3, [r3, #0]
 8017a10:	001a      	movs	r2, r3
 8017a12:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017a14:	4313      	orrs	r3, r2
 8017a16:	62bb      	str	r3, [r7, #40]	; 0x28
 8017a18:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017a1a:	021b      	lsls	r3, r3, #8
 8017a1c:	62bb      	str	r3, [r7, #40]	; 0x28
 8017a1e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017a20:	1c5a      	adds	r2, r3, #1
 8017a22:	647a      	str	r2, [r7, #68]	; 0x44
 8017a24:	781b      	ldrb	r3, [r3, #0]
 8017a26:	001a      	movs	r2, r3
 8017a28:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017a2a:	4313      	orrs	r3, r2
 8017a2c:	62bb      	str	r3, [r7, #40]	; 0x28
	    if (lwip_htonl(tl) != ao->dnsaddr[d]) {
 8017a2e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017a30:	0018      	movs	r0, r3
 8017a32:	f7ef fcfb 	bl	800742c <lwip_htonl>
 8017a36:	0001      	movs	r1, r0
 8017a38:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8017a3a:	69fb      	ldr	r3, [r7, #28]
 8017a3c:	3302      	adds	r3, #2
 8017a3e:	009b      	lsls	r3, r3, #2
 8017a40:	18d3      	adds	r3, r2, r3
 8017a42:	3304      	adds	r3, #4
 8017a44:	681b      	ldr	r3, [r3, #0]
 8017a46:	4299      	cmp	r1, r3
 8017a48:	d100      	bne.n	8017a4c <ipcp_reqci+0x4ac>
 8017a4a:	e0d8      	b.n	8017bfe <ipcp_reqci+0x65e>
                DECPTR(sizeof(u32_t), p);
 8017a4c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017a4e:	3b04      	subs	r3, #4
 8017a50:	647b      	str	r3, [r7, #68]	; 0x44
		tl = lwip_ntohl(ao->dnsaddr[d]);
 8017a52:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8017a54:	69fb      	ldr	r3, [r7, #28]
 8017a56:	3302      	adds	r3, #2
 8017a58:	009b      	lsls	r3, r3, #2
 8017a5a:	18d3      	adds	r3, r2, r3
 8017a5c:	3304      	adds	r3, #4
 8017a5e:	681b      	ldr	r3, [r3, #0]
 8017a60:	0018      	movs	r0, r3
 8017a62:	f7ef fce3 	bl	800742c <lwip_htonl>
 8017a66:	0003      	movs	r3, r0
 8017a68:	62bb      	str	r3, [r7, #40]	; 0x28
		PUTLONG(tl, p);
 8017a6a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017a6c:	0e19      	lsrs	r1, r3, #24
 8017a6e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017a70:	1c5a      	adds	r2, r3, #1
 8017a72:	647a      	str	r2, [r7, #68]	; 0x44
 8017a74:	b2ca      	uxtb	r2, r1
 8017a76:	701a      	strb	r2, [r3, #0]
 8017a78:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017a7a:	0c19      	lsrs	r1, r3, #16
 8017a7c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017a7e:	1c5a      	adds	r2, r3, #1
 8017a80:	647a      	str	r2, [r7, #68]	; 0x44
 8017a82:	b2ca      	uxtb	r2, r1
 8017a84:	701a      	strb	r2, [r3, #0]
 8017a86:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017a88:	0a19      	lsrs	r1, r3, #8
 8017a8a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017a8c:	1c5a      	adds	r2, r3, #1
 8017a8e:	647a      	str	r2, [r7, #68]	; 0x44
 8017a90:	b2ca      	uxtb	r2, r1
 8017a92:	701a      	strb	r2, [r3, #0]
 8017a94:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017a96:	1c5a      	adds	r2, r3, #1
 8017a98:	647a      	str	r2, [r7, #68]	; 0x44
 8017a9a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8017a9c:	b2d2      	uxtb	r2, r2
 8017a9e:	701a      	strb	r2, [r3, #0]
		orc = CONFNAK;
 8017aa0:	2303      	movs	r3, #3
 8017aa2:	64bb      	str	r3, [r7, #72]	; 0x48
            }
            break;
 8017aa4:	e0ab      	b.n	8017bfe <ipcp_reqci+0x65e>
            break;
#endif /* UNUSED - WINS */

#if VJ_SUPPORT
	case CI_COMPRESSTYPE:
	    if (!ao->neg_vj ||
 8017aa6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017aa8:	781b      	ldrb	r3, [r3, #0]
 8017aaa:	2208      	movs	r2, #8
 8017aac:	4013      	ands	r3, r2
 8017aae:	b2db      	uxtb	r3, r3
 8017ab0:	2b00      	cmp	r3, #0
 8017ab2:	d008      	beq.n	8017ac6 <ipcp_reqci+0x526>
 8017ab4:	2252      	movs	r2, #82	; 0x52
 8017ab6:	18bb      	adds	r3, r7, r2
 8017ab8:	881b      	ldrh	r3, [r3, #0]
 8017aba:	2b06      	cmp	r3, #6
 8017abc:	d006      	beq.n	8017acc <ipcp_reqci+0x52c>
		(cilen != CILEN_VJ && cilen != CILEN_COMPRESS)) {
 8017abe:	18bb      	adds	r3, r7, r2
 8017ac0:	881b      	ldrh	r3, [r3, #0]
 8017ac2:	2b04      	cmp	r3, #4
 8017ac4:	d002      	beq.n	8017acc <ipcp_reqci+0x52c>
		orc = CONFREJ;
 8017ac6:	2304      	movs	r3, #4
 8017ac8:	64bb      	str	r3, [r7, #72]	; 0x48
		break;
 8017aca:	e099      	b.n	8017c00 <ipcp_reqci+0x660>
	    }
	    GETSHORT(cishort, p);
 8017acc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017ace:	1c5a      	adds	r2, r3, #1
 8017ad0:	647a      	str	r2, [r7, #68]	; 0x44
 8017ad2:	781b      	ldrb	r3, [r3, #0]
 8017ad4:	b29a      	uxth	r2, r3
 8017ad6:	2016      	movs	r0, #22
 8017ad8:	183b      	adds	r3, r7, r0
 8017ada:	0212      	lsls	r2, r2, #8
 8017adc:	801a      	strh	r2, [r3, #0]
 8017ade:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017ae0:	1c5a      	adds	r2, r3, #1
 8017ae2:	647a      	str	r2, [r7, #68]	; 0x44
 8017ae4:	781b      	ldrb	r3, [r3, #0]
 8017ae6:	b299      	uxth	r1, r3
 8017ae8:	183b      	adds	r3, r7, r0
 8017aea:	183a      	adds	r2, r7, r0
 8017aec:	8812      	ldrh	r2, [r2, #0]
 8017aee:	430a      	orrs	r2, r1
 8017af0:	801a      	strh	r2, [r3, #0]

	    if (!(cishort == IPCP_VJ_COMP ||
 8017af2:	183b      	adds	r3, r7, r0
 8017af4:	881b      	ldrh	r3, [r3, #0]
 8017af6:	2b2d      	cmp	r3, #45	; 0x2d
 8017af8:	d00b      	beq.n	8017b12 <ipcp_reqci+0x572>
 8017afa:	183b      	adds	r3, r7, r0
 8017afc:	881b      	ldrh	r3, [r3, #0]
 8017afe:	2b37      	cmp	r3, #55	; 0x37
 8017b00:	d104      	bne.n	8017b0c <ipcp_reqci+0x56c>
		  (cishort == IPCP_VJ_COMP_OLD && cilen == CILEN_COMPRESS))) {
 8017b02:	2352      	movs	r3, #82	; 0x52
 8017b04:	18fb      	adds	r3, r7, r3
 8017b06:	881b      	ldrh	r3, [r3, #0]
 8017b08:	2b04      	cmp	r3, #4
 8017b0a:	d002      	beq.n	8017b12 <ipcp_reqci+0x572>
		orc = CONFREJ;
 8017b0c:	2304      	movs	r3, #4
 8017b0e:	64bb      	str	r3, [r7, #72]	; 0x48
		break;
 8017b10:	e076      	b.n	8017c00 <ipcp_reqci+0x660>
	    }

	    ho->neg_vj = 1;
 8017b12:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017b14:	781a      	ldrb	r2, [r3, #0]
 8017b16:	2108      	movs	r1, #8
 8017b18:	430a      	orrs	r2, r1
 8017b1a:	701a      	strb	r2, [r3, #0]
	    ho->vj_protocol = cishort;
 8017b1c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017b1e:	2216      	movs	r2, #22
 8017b20:	18ba      	adds	r2, r7, r2
 8017b22:	8812      	ldrh	r2, [r2, #0]
 8017b24:	829a      	strh	r2, [r3, #20]
	    if (cilen == CILEN_VJ) {
 8017b26:	2352      	movs	r3, #82	; 0x52
 8017b28:	18fb      	adds	r3, r7, r3
 8017b2a:	881b      	ldrh	r3, [r3, #0]
 8017b2c:	2b06      	cmp	r3, #6
 8017b2e:	d155      	bne.n	8017bdc <ipcp_reqci+0x63c>
		GETCHAR(maxslotindex, p);
 8017b30:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017b32:	1c5a      	adds	r2, r3, #1
 8017b34:	647a      	str	r2, [r7, #68]	; 0x44
 8017b36:	2115      	movs	r1, #21
 8017b38:	187a      	adds	r2, r7, r1
 8017b3a:	781b      	ldrb	r3, [r3, #0]
 8017b3c:	7013      	strb	r3, [r2, #0]
		if (maxslotindex > ao->maxslotindex) { 
 8017b3e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017b40:	7d9b      	ldrb	r3, [r3, #22]
 8017b42:	187a      	adds	r2, r7, r1
 8017b44:	7812      	ldrb	r2, [r2, #0]
 8017b46:	429a      	cmp	r2, r3
 8017b48:	d90d      	bls.n	8017b66 <ipcp_reqci+0x5c6>
		    orc = CONFNAK;
 8017b4a:	2303      	movs	r3, #3
 8017b4c:	64bb      	str	r3, [r7, #72]	; 0x48
		    if (!reject_if_disagree){
 8017b4e:	683b      	ldr	r3, [r7, #0]
 8017b50:	2b00      	cmp	r3, #0
 8017b52:	d108      	bne.n	8017b66 <ipcp_reqci+0x5c6>
			DECPTR(1, p);
 8017b54:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017b56:	3b01      	subs	r3, #1
 8017b58:	647b      	str	r3, [r7, #68]	; 0x44
			PUTCHAR(ao->maxslotindex, p);
 8017b5a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017b5c:	1c5a      	adds	r2, r3, #1
 8017b5e:	647a      	str	r2, [r7, #68]	; 0x44
 8017b60:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8017b62:	7d92      	ldrb	r2, [r2, #22]
 8017b64:	701a      	strb	r2, [r3, #0]
		    }
		}
		GETCHAR(cflag, p);
 8017b66:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017b68:	1c5a      	adds	r2, r3, #1
 8017b6a:	647a      	str	r2, [r7, #68]	; 0x44
 8017b6c:	2114      	movs	r1, #20
 8017b6e:	187a      	adds	r2, r7, r1
 8017b70:	781b      	ldrb	r3, [r3, #0]
 8017b72:	7013      	strb	r3, [r2, #0]
		if (cflag && !ao->cflag) {
 8017b74:	187b      	adds	r3, r7, r1
 8017b76:	781b      	ldrb	r3, [r3, #0]
 8017b78:	2b00      	cmp	r3, #0
 8017b7a:	d018      	beq.n	8017bae <ipcp_reqci+0x60e>
 8017b7c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017b7e:	781b      	ldrb	r3, [r3, #0]
 8017b80:	2220      	movs	r2, #32
 8017b82:	4013      	ands	r3, r2
 8017b84:	b2db      	uxtb	r3, r3
 8017b86:	2b00      	cmp	r3, #0
 8017b88:	d111      	bne.n	8017bae <ipcp_reqci+0x60e>
		    orc = CONFNAK;
 8017b8a:	2303      	movs	r3, #3
 8017b8c:	64bb      	str	r3, [r7, #72]	; 0x48
		    if (!reject_if_disagree){
 8017b8e:	683b      	ldr	r3, [r7, #0]
 8017b90:	2b00      	cmp	r3, #0
 8017b92:	d10c      	bne.n	8017bae <ipcp_reqci+0x60e>
			DECPTR(1, p);
 8017b94:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017b96:	3b01      	subs	r3, #1
 8017b98:	647b      	str	r3, [r7, #68]	; 0x44
			PUTCHAR(wo->cflag, p);
 8017b9a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017b9c:	781b      	ldrb	r3, [r3, #0]
 8017b9e:	069b      	lsls	r3, r3, #26
 8017ba0:	0fdb      	lsrs	r3, r3, #31
 8017ba2:	b2d9      	uxtb	r1, r3
 8017ba4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017ba6:	1c5a      	adds	r2, r3, #1
 8017ba8:	647a      	str	r2, [r7, #68]	; 0x44
 8017baa:	000a      	movs	r2, r1
 8017bac:	701a      	strb	r2, [r3, #0]
		    }
		}
		ho->maxslotindex = maxslotindex;
 8017bae:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017bb0:	2215      	movs	r2, #21
 8017bb2:	18ba      	adds	r2, r7, r2
 8017bb4:	7812      	ldrb	r2, [r2, #0]
 8017bb6:	759a      	strb	r2, [r3, #22]
		ho->cflag = cflag;
 8017bb8:	2314      	movs	r3, #20
 8017bba:	18fb      	adds	r3, r7, r3
 8017bbc:	781b      	ldrb	r3, [r3, #0]
 8017bbe:	2201      	movs	r2, #1
 8017bc0:	4013      	ands	r3, r2
 8017bc2:	b2da      	uxtb	r2, r3
 8017bc4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017bc6:	2101      	movs	r1, #1
 8017bc8:	400a      	ands	r2, r1
 8017bca:	0150      	lsls	r0, r2, #5
 8017bcc:	781a      	ldrb	r2, [r3, #0]
 8017bce:	2120      	movs	r1, #32
 8017bd0:	438a      	bics	r2, r1
 8017bd2:	1c11      	adds	r1, r2, #0
 8017bd4:	1c02      	adds	r2, r0, #0
 8017bd6:	430a      	orrs	r2, r1
 8017bd8:	701a      	strb	r2, [r3, #0]
	    } else {
		ho->old_vj = 1;
		ho->maxslotindex = MAX_STATES - 1;
		ho->cflag = 1;
	    }
	    break;
 8017bda:	e011      	b.n	8017c00 <ipcp_reqci+0x660>
		ho->old_vj = 1;
 8017bdc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017bde:	781a      	ldrb	r2, [r3, #0]
 8017be0:	2110      	movs	r1, #16
 8017be2:	430a      	orrs	r2, r1
 8017be4:	701a      	strb	r2, [r3, #0]
		ho->maxslotindex = MAX_STATES - 1;
 8017be6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017be8:	220f      	movs	r2, #15
 8017bea:	759a      	strb	r2, [r3, #22]
		ho->cflag = 1;
 8017bec:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017bee:	781a      	ldrb	r2, [r3, #0]
 8017bf0:	2120      	movs	r1, #32
 8017bf2:	430a      	orrs	r2, r1
 8017bf4:	701a      	strb	r2, [r3, #0]
	    break;
 8017bf6:	e003      	b.n	8017c00 <ipcp_reqci+0x660>
#endif /* VJ_SUPPORT */

	default:
	    orc = CONFREJ;
 8017bf8:	2304      	movs	r3, #4
 8017bfa:	64bb      	str	r3, [r7, #72]	; 0x48
	    break;
 8017bfc:	e000      	b.n	8017c00 <ipcp_reqci+0x660>
            break;
 8017bfe:	46c0      	nop			; (mov r8, r8)
	}
endswitch:
	if (orc == CONFACK &&		/* Good CI */
 8017c00:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8017c02:	2b02      	cmp	r3, #2
 8017c04:	d103      	bne.n	8017c0e <ipcp_reqci+0x66e>
 8017c06:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8017c08:	2b02      	cmp	r3, #2
 8017c0a:	d000      	beq.n	8017c0e <ipcp_reqci+0x66e>
	    rc != CONFACK)		/*  but prior CI wasnt? */
	    continue;			/* Don't send this one */
 8017c0c:	e02f      	b.n	8017c6e <ipcp_reqci+0x6ce>

	if (orc == CONFNAK) {		/* Nak this CI? */
 8017c0e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8017c10:	2b03      	cmp	r3, #3
 8017c12:	d110      	bne.n	8017c36 <ipcp_reqci+0x696>
	    if (reject_if_disagree)	/* Getting fed up with sending NAKs? */
 8017c14:	683b      	ldr	r3, [r7, #0]
 8017c16:	2b00      	cmp	r3, #0
 8017c18:	d002      	beq.n	8017c20 <ipcp_reqci+0x680>
		orc = CONFREJ;		/* Get tough if so */
 8017c1a:	2304      	movs	r3, #4
 8017c1c:	64bb      	str	r3, [r7, #72]	; 0x48
 8017c1e:	e00a      	b.n	8017c36 <ipcp_reqci+0x696>
	    else {
		if (rc == CONFREJ)	/* Rejecting prior CI? */
 8017c20:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8017c22:	2b04      	cmp	r3, #4
 8017c24:	d100      	bne.n	8017c28 <ipcp_reqci+0x688>
		    continue;		/* Don't send this one */
 8017c26:	e022      	b.n	8017c6e <ipcp_reqci+0x6ce>
		if (rc == CONFACK) {	/* Ack'd all prior CIs? */
 8017c28:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8017c2a:	2b02      	cmp	r3, #2
 8017c2c:	d103      	bne.n	8017c36 <ipcp_reqci+0x696>
		    rc = CONFNAK;	/* Not anymore... */
 8017c2e:	2303      	movs	r3, #3
 8017c30:	64fb      	str	r3, [r7, #76]	; 0x4c
		    ucp = inp;		/* Backup */
 8017c32:	68bb      	ldr	r3, [r7, #8]
 8017c34:	643b      	str	r3, [r7, #64]	; 0x40
		}
	    }
	}

	if (orc == CONFREJ &&		/* Reject this CI */
 8017c36:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8017c38:	2b04      	cmp	r3, #4
 8017c3a:	d106      	bne.n	8017c4a <ipcp_reqci+0x6aa>
 8017c3c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8017c3e:	2b04      	cmp	r3, #4
 8017c40:	d003      	beq.n	8017c4a <ipcp_reqci+0x6aa>
	    rc != CONFREJ) {		/*  but no prior ones? */
	    rc = CONFREJ;
 8017c42:	2304      	movs	r3, #4
 8017c44:	64fb      	str	r3, [r7, #76]	; 0x4c
	    ucp = inp;			/* Backup */
 8017c46:	68bb      	ldr	r3, [r7, #8]
 8017c48:	643b      	str	r3, [r7, #64]	; 0x40
	}

	/* Need to move CI? */
	if (ucp != cip)
 8017c4a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8017c4c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017c4e:	429a      	cmp	r2, r3
 8017c50:	d007      	beq.n	8017c62 <ipcp_reqci+0x6c2>
	    MEMCPY(ucp, cip, cilen);	/* Move it */
 8017c52:	2352      	movs	r3, #82	; 0x52
 8017c54:	18fb      	adds	r3, r7, r3
 8017c56:	881a      	ldrh	r2, [r3, #0]
 8017c58:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8017c5a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8017c5c:	0018      	movs	r0, r3
 8017c5e:	f006 f99d 	bl	801df9c <memcpy>

	/* Update output pointer */
	INCPTR(cilen, ucp);
 8017c62:	2352      	movs	r3, #82	; 0x52
 8017c64:	18fb      	adds	r3, r7, r3
 8017c66:	881b      	ldrh	r3, [r3, #0]
 8017c68:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8017c6a:	18d3      	adds	r3, r2, r3
 8017c6c:	643b      	str	r3, [r7, #64]	; 0x40
    while (l) {
 8017c6e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8017c70:	2b00      	cmp	r3, #0
 8017c72:	d000      	beq.n	8017c76 <ipcp_reqci+0x6d6>
 8017c74:	e4bd      	b.n	80175f2 <ipcp_reqci+0x52>
     * their address, and they didn't send their address, then we
     * send a NAK with a CI_ADDR option appended.  We assume the
     * input buffer is long enough that we can append the extra
     * option safely.
     */
    if (rc != CONFREJ && !ho->neg_addr && !ho->old_addrs &&
 8017c76:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8017c78:	2b04      	cmp	r3, #4
 8017c7a:	d056      	beq.n	8017d2a <ipcp_reqci+0x78a>
 8017c7c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017c7e:	781b      	ldrb	r3, [r3, #0]
 8017c80:	2201      	movs	r2, #1
 8017c82:	4013      	ands	r3, r2
 8017c84:	b2db      	uxtb	r3, r3
 8017c86:	2b00      	cmp	r3, #0
 8017c88:	d14f      	bne.n	8017d2a <ipcp_reqci+0x78a>
 8017c8a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017c8c:	781b      	ldrb	r3, [r3, #0]
 8017c8e:	2202      	movs	r2, #2
 8017c90:	4013      	ands	r3, r2
 8017c92:	b2db      	uxtb	r3, r3
 8017c94:	2b00      	cmp	r3, #0
 8017c96:	d148      	bne.n	8017d2a <ipcp_reqci+0x78a>
 8017c98:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017c9a:	781b      	ldrb	r3, [r3, #0]
 8017c9c:	2204      	movs	r2, #4
 8017c9e:	4013      	ands	r3, r2
 8017ca0:	b2db      	uxtb	r3, r3
 8017ca2:	2b00      	cmp	r3, #0
 8017ca4:	d041      	beq.n	8017d2a <ipcp_reqci+0x78a>
	wo->req_addr && !reject_if_disagree && !pcb->settings.noremoteip) {
 8017ca6:	683b      	ldr	r3, [r7, #0]
 8017ca8:	2b00      	cmp	r3, #0
 8017caa:	d13e      	bne.n	8017d2a <ipcp_reqci+0x78a>
 8017cac:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8017cae:	781b      	ldrb	r3, [r3, #0]
 8017cb0:	2204      	movs	r2, #4
 8017cb2:	4013      	ands	r3, r2
 8017cb4:	b2db      	uxtb	r3, r3
 8017cb6:	2b00      	cmp	r3, #0
 8017cb8:	d137      	bne.n	8017d2a <ipcp_reqci+0x78a>
	if (rc == CONFACK) {
 8017cba:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8017cbc:	2b02      	cmp	r3, #2
 8017cbe:	d108      	bne.n	8017cd2 <ipcp_reqci+0x732>
	    rc = CONFNAK;
 8017cc0:	2303      	movs	r3, #3
 8017cc2:	64fb      	str	r3, [r7, #76]	; 0x4c
	    ucp = inp;			/* reset pointer */
 8017cc4:	68bb      	ldr	r3, [r7, #8]
 8017cc6:	643b      	str	r3, [r7, #64]	; 0x40
	    wo->req_addr = 0;		/* don't ask again */
 8017cc8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017cca:	781a      	ldrb	r2, [r3, #0]
 8017ccc:	2104      	movs	r1, #4
 8017cce:	438a      	bics	r2, r1
 8017cd0:	701a      	strb	r2, [r3, #0]
	}
	PUTCHAR(CI_ADDR, ucp);
 8017cd2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8017cd4:	1c5a      	adds	r2, r3, #1
 8017cd6:	643a      	str	r2, [r7, #64]	; 0x40
 8017cd8:	2203      	movs	r2, #3
 8017cda:	701a      	strb	r2, [r3, #0]
	PUTCHAR(CILEN_ADDR, ucp);
 8017cdc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8017cde:	1c5a      	adds	r2, r3, #1
 8017ce0:	643a      	str	r2, [r7, #64]	; 0x40
 8017ce2:	2206      	movs	r2, #6
 8017ce4:	701a      	strb	r2, [r3, #0]
	tl = lwip_ntohl(wo->hisaddr);
 8017ce6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017ce8:	689b      	ldr	r3, [r3, #8]
 8017cea:	0018      	movs	r0, r3
 8017cec:	f7ef fb9e 	bl	800742c <lwip_htonl>
 8017cf0:	0003      	movs	r3, r0
 8017cf2:	62bb      	str	r3, [r7, #40]	; 0x28
	PUTLONG(tl, ucp);
 8017cf4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017cf6:	0e19      	lsrs	r1, r3, #24
 8017cf8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8017cfa:	1c5a      	adds	r2, r3, #1
 8017cfc:	643a      	str	r2, [r7, #64]	; 0x40
 8017cfe:	b2ca      	uxtb	r2, r1
 8017d00:	701a      	strb	r2, [r3, #0]
 8017d02:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017d04:	0c19      	lsrs	r1, r3, #16
 8017d06:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8017d08:	1c5a      	adds	r2, r3, #1
 8017d0a:	643a      	str	r2, [r7, #64]	; 0x40
 8017d0c:	b2ca      	uxtb	r2, r1
 8017d0e:	701a      	strb	r2, [r3, #0]
 8017d10:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017d12:	0a19      	lsrs	r1, r3, #8
 8017d14:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8017d16:	1c5a      	adds	r2, r3, #1
 8017d18:	643a      	str	r2, [r7, #64]	; 0x40
 8017d1a:	b2ca      	uxtb	r2, r1
 8017d1c:	701a      	strb	r2, [r3, #0]
 8017d1e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8017d20:	1c5a      	adds	r2, r3, #1
 8017d22:	643a      	str	r2, [r7, #64]	; 0x40
 8017d24:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8017d26:	b2d2      	uxtb	r2, r2
 8017d28:	701a      	strb	r2, [r3, #0]
    }

    *len = ucp - inp;			/* Compute output length */
 8017d2a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8017d2c:	68bb      	ldr	r3, [r7, #8]
 8017d2e:	1ad2      	subs	r2, r2, r3
 8017d30:	687b      	ldr	r3, [r7, #4]
 8017d32:	601a      	str	r2, [r3, #0]
    IPCPDEBUG(("ipcp: returning Configure-%s", CODENAME(rc)));
    return (rc);			/* Return final code */
 8017d34:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
}
 8017d36:	0018      	movs	r0, r3
 8017d38:	46bd      	mov	sp, r7
 8017d3a:	b016      	add	sp, #88	; 0x58
 8017d3c:	bd80      	pop	{r7, pc}
 8017d3e:	46c0      	nop			; (mov r8, r8)

08017d40 <ipcp_up>:
/*
 * ipcp_up - IPCP has come UP.
 *
 * Configure the IP network interface appropriately and bring it up.
 */
static void ipcp_up(fsm *f) {
 8017d40:	b580      	push	{r7, lr}
 8017d42:	b088      	sub	sp, #32
 8017d44:	af00      	add	r7, sp, #0
 8017d46:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8017d48:	687b      	ldr	r3, [r7, #4]
 8017d4a:	681b      	ldr	r3, [r3, #0]
 8017d4c:	61fb      	str	r3, [r7, #28]
    u32_t mask;
    ipcp_options *ho = &pcb->ipcp_hisoptions;
 8017d4e:	69fb      	ldr	r3, [r7, #28]
 8017d50:	4a9e      	ldr	r2, [pc, #632]	; (8017fcc <ipcp_up+0x28c>)
 8017d52:	4694      	mov	ip, r2
 8017d54:	4463      	add	r3, ip
 8017d56:	61bb      	str	r3, [r7, #24]
    ipcp_options *go = &pcb->ipcp_gotoptions;
 8017d58:	69fb      	ldr	r3, [r7, #28]
 8017d5a:	4a9d      	ldr	r2, [pc, #628]	; (8017fd0 <ipcp_up+0x290>)
 8017d5c:	4694      	mov	ip, r2
 8017d5e:	4463      	add	r3, ip
 8017d60:	617b      	str	r3, [r7, #20]
    ipcp_options *wo = &pcb->ipcp_wantoptions;
 8017d62:	69fb      	ldr	r3, [r7, #28]
 8017d64:	4a9b      	ldr	r2, [pc, #620]	; (8017fd4 <ipcp_up+0x294>)
 8017d66:	4694      	mov	ip, r2
 8017d68:	4463      	add	r3, ip
 8017d6a:	613b      	str	r3, [r7, #16]
    IPCPDEBUG(("ipcp: up"));

    /*
     * We must have a non-zero IP address for both ends of the link.
     */
    if (!ho->neg_addr && !ho->old_addrs)
 8017d6c:	69bb      	ldr	r3, [r7, #24]
 8017d6e:	781b      	ldrb	r3, [r3, #0]
 8017d70:	2201      	movs	r2, #1
 8017d72:	4013      	ands	r3, r2
 8017d74:	b2db      	uxtb	r3, r3
 8017d76:	2b00      	cmp	r3, #0
 8017d78:	d10a      	bne.n	8017d90 <ipcp_up+0x50>
 8017d7a:	69bb      	ldr	r3, [r7, #24]
 8017d7c:	781b      	ldrb	r3, [r3, #0]
 8017d7e:	2202      	movs	r2, #2
 8017d80:	4013      	ands	r3, r2
 8017d82:	b2db      	uxtb	r3, r3
 8017d84:	2b00      	cmp	r3, #0
 8017d86:	d103      	bne.n	8017d90 <ipcp_up+0x50>
	ho->hisaddr = wo->hisaddr;
 8017d88:	693b      	ldr	r3, [r7, #16]
 8017d8a:	689a      	ldr	r2, [r3, #8]
 8017d8c:	69bb      	ldr	r3, [r7, #24]
 8017d8e:	609a      	str	r2, [r3, #8]

    if (!(go->neg_addr || go->old_addrs) && (wo->neg_addr || wo->old_addrs)
 8017d90:	697b      	ldr	r3, [r7, #20]
 8017d92:	781b      	ldrb	r3, [r3, #0]
 8017d94:	2201      	movs	r2, #1
 8017d96:	4013      	ands	r3, r2
 8017d98:	b2db      	uxtb	r3, r3
 8017d9a:	2b00      	cmp	r3, #0
 8017d9c:	d124      	bne.n	8017de8 <ipcp_up+0xa8>
 8017d9e:	697b      	ldr	r3, [r7, #20]
 8017da0:	781b      	ldrb	r3, [r3, #0]
 8017da2:	2202      	movs	r2, #2
 8017da4:	4013      	ands	r3, r2
 8017da6:	b2db      	uxtb	r3, r3
 8017da8:	2b00      	cmp	r3, #0
 8017daa:	d11d      	bne.n	8017de8 <ipcp_up+0xa8>
 8017dac:	693b      	ldr	r3, [r7, #16]
 8017dae:	781b      	ldrb	r3, [r3, #0]
 8017db0:	2201      	movs	r2, #1
 8017db2:	4013      	ands	r3, r2
 8017db4:	b2db      	uxtb	r3, r3
 8017db6:	2b00      	cmp	r3, #0
 8017db8:	d106      	bne.n	8017dc8 <ipcp_up+0x88>
 8017dba:	693b      	ldr	r3, [r7, #16]
 8017dbc:	781b      	ldrb	r3, [r3, #0]
 8017dbe:	2202      	movs	r2, #2
 8017dc0:	4013      	ands	r3, r2
 8017dc2:	b2db      	uxtb	r3, r3
 8017dc4:	2b00      	cmp	r3, #0
 8017dc6:	d00f      	beq.n	8017de8 <ipcp_up+0xa8>
	&& wo->ouraddr != 0) {
 8017dc8:	693b      	ldr	r3, [r7, #16]
 8017dca:	685b      	ldr	r3, [r3, #4]
 8017dcc:	2b00      	cmp	r3, #0
 8017dce:	d00b      	beq.n	8017de8 <ipcp_up+0xa8>
	ppp_error("Peer refused to agree to our IP address");
 8017dd0:	4b81      	ldr	r3, [pc, #516]	; (8017fd8 <ipcp_up+0x298>)
 8017dd2:	0018      	movs	r0, r3
 8017dd4:	f004 f8b5 	bl	801bf42 <ppp_error>
	ipcp_close(f->pcb, "Refused our IP address");
 8017dd8:	687b      	ldr	r3, [r7, #4]
 8017dda:	681b      	ldr	r3, [r3, #0]
 8017ddc:	4a7f      	ldr	r2, [pc, #508]	; (8017fdc <ipcp_up+0x29c>)
 8017dde:	0011      	movs	r1, r2
 8017de0:	0018      	movs	r0, r3
 8017de2:	f7fd ff4d 	bl	8015c80 <ipcp_close>
	return;
 8017de6:	e0ed      	b.n	8017fc4 <ipcp_up+0x284>
    }
    if (go->ouraddr == 0) {
 8017de8:	697b      	ldr	r3, [r7, #20]
 8017dea:	685b      	ldr	r3, [r3, #4]
 8017dec:	2b00      	cmp	r3, #0
 8017dee:	d10b      	bne.n	8017e08 <ipcp_up+0xc8>
	ppp_error("Could not determine local IP address");
 8017df0:	4b7b      	ldr	r3, [pc, #492]	; (8017fe0 <ipcp_up+0x2a0>)
 8017df2:	0018      	movs	r0, r3
 8017df4:	f004 f8a5 	bl	801bf42 <ppp_error>
	ipcp_close(f->pcb, "Could not determine local IP address");
 8017df8:	687b      	ldr	r3, [r7, #4]
 8017dfa:	681b      	ldr	r3, [r3, #0]
 8017dfc:	4a78      	ldr	r2, [pc, #480]	; (8017fe0 <ipcp_up+0x2a0>)
 8017dfe:	0011      	movs	r1, r2
 8017e00:	0018      	movs	r0, r3
 8017e02:	f7fd ff3d 	bl	8015c80 <ipcp_close>
	return;
 8017e06:	e0dd      	b.n	8017fc4 <ipcp_up+0x284>
    }
    if (ho->hisaddr == 0 && !pcb->settings.noremoteip) {
 8017e08:	69bb      	ldr	r3, [r7, #24]
 8017e0a:	689b      	ldr	r3, [r3, #8]
 8017e0c:	2b00      	cmp	r3, #0
 8017e0e:	d114      	bne.n	8017e3a <ipcp_up+0xfa>
 8017e10:	69fb      	ldr	r3, [r7, #28]
 8017e12:	781b      	ldrb	r3, [r3, #0]
 8017e14:	2204      	movs	r2, #4
 8017e16:	4013      	ands	r3, r2
 8017e18:	b2db      	uxtb	r3, r3
 8017e1a:	2b00      	cmp	r3, #0
 8017e1c:	d10d      	bne.n	8017e3a <ipcp_up+0xfa>
	ho->hisaddr = lwip_htonl(0x0a404040);
 8017e1e:	4b71      	ldr	r3, [pc, #452]	; (8017fe4 <ipcp_up+0x2a4>)
 8017e20:	0018      	movs	r0, r3
 8017e22:	f7ef fb03 	bl	800742c <lwip_htonl>
 8017e26:	0002      	movs	r2, r0
 8017e28:	69bb      	ldr	r3, [r7, #24]
 8017e2a:	609a      	str	r2, [r3, #8]
	ppp_warn("Could not determine remote IP address: defaulting to %I",
 8017e2c:	69bb      	ldr	r3, [r7, #24]
 8017e2e:	689a      	ldr	r2, [r3, #8]
 8017e30:	4b6d      	ldr	r3, [pc, #436]	; (8017fe8 <ipcp_up+0x2a8>)
 8017e32:	0011      	movs	r1, r2
 8017e34:	0018      	movs	r0, r3
 8017e36:	f004 f898 	bl	801bf6a <ppp_warn>
    if (ho->hisaddr != 0)
	script_setenv("IPREMOTE", ip_ntoa(ho->hisaddr), 1);
#endif /* UNUSED */

#if LWIP_DNS
    if (!go->req_dns1)
 8017e3a:	697b      	ldr	r3, [r7, #20]
 8017e3c:	785b      	ldrb	r3, [r3, #1]
 8017e3e:	2201      	movs	r2, #1
 8017e40:	4013      	ands	r3, r2
 8017e42:	b2db      	uxtb	r3, r3
 8017e44:	2b00      	cmp	r3, #0
 8017e46:	d102      	bne.n	8017e4e <ipcp_up+0x10e>
	    go->dnsaddr[0] = 0;
 8017e48:	697b      	ldr	r3, [r7, #20]
 8017e4a:	2200      	movs	r2, #0
 8017e4c:	60da      	str	r2, [r3, #12]
    if (!go->req_dns2)
 8017e4e:	697b      	ldr	r3, [r7, #20]
 8017e50:	785b      	ldrb	r3, [r3, #1]
 8017e52:	2202      	movs	r2, #2
 8017e54:	4013      	ands	r3, r2
 8017e56:	b2db      	uxtb	r3, r3
 8017e58:	2b00      	cmp	r3, #0
 8017e5a:	d102      	bne.n	8017e62 <ipcp_up+0x122>
	    go->dnsaddr[1] = 0;
 8017e5c:	697b      	ldr	r3, [r7, #20]
 8017e5e:	2200      	movs	r2, #0
 8017e60:	611a      	str	r2, [r3, #16]
    if (go->dnsaddr[0])
	script_setenv("DNS1", ip_ntoa(go->dnsaddr[0]), 0);
    if (go->dnsaddr[1])
	script_setenv("DNS2", ip_ntoa(go->dnsaddr[1]), 0);
#endif /* UNUSED */
    if (pcb->settings.usepeerdns && (go->dnsaddr[0] || go->dnsaddr[1])) {
 8017e62:	69fb      	ldr	r3, [r7, #28]
 8017e64:	781b      	ldrb	r3, [r3, #0]
 8017e66:	2201      	movs	r2, #1
 8017e68:	4013      	ands	r3, r2
 8017e6a:	b2db      	uxtb	r3, r3
 8017e6c:	2b00      	cmp	r3, #0
 8017e6e:	d00f      	beq.n	8017e90 <ipcp_up+0x150>
 8017e70:	697b      	ldr	r3, [r7, #20]
 8017e72:	68db      	ldr	r3, [r3, #12]
 8017e74:	2b00      	cmp	r3, #0
 8017e76:	d103      	bne.n	8017e80 <ipcp_up+0x140>
 8017e78:	697b      	ldr	r3, [r7, #20]
 8017e7a:	691b      	ldr	r3, [r3, #16]
 8017e7c:	2b00      	cmp	r3, #0
 8017e7e:	d007      	beq.n	8017e90 <ipcp_up+0x150>
	sdns(pcb, go->dnsaddr[0], go->dnsaddr[1]);
 8017e80:	697b      	ldr	r3, [r7, #20]
 8017e82:	68d9      	ldr	r1, [r3, #12]
 8017e84:	697b      	ldr	r3, [r7, #20]
 8017e86:	691a      	ldr	r2, [r3, #16]
 8017e88:	69fb      	ldr	r3, [r7, #28]
 8017e8a:	0018      	movs	r0, r3
 8017e8c:	f002 fe36 	bl	801aafc <sdns>
#endif /* LWIP_DNS */

    /*
     * Check that the peer is allowed to use the IP address it wants.
     */
    if (ho->hisaddr != 0) {
 8017e90:	69bb      	ldr	r3, [r7, #24]
 8017e92:	689b      	ldr	r3, [r3, #8]
 8017e94:	2b00      	cmp	r3, #0
 8017e96:	d026      	beq.n	8017ee6 <ipcp_up+0x1a6>
	u32_t addr = lwip_ntohl(ho->hisaddr);
 8017e98:	69bb      	ldr	r3, [r7, #24]
 8017e9a:	689b      	ldr	r3, [r3, #8]
 8017e9c:	0018      	movs	r0, r3
 8017e9e:	f7ef fac5 	bl	800742c <lwip_htonl>
 8017ea2:	0003      	movs	r3, r0
 8017ea4:	60fb      	str	r3, [r7, #12]
	if ((addr >> IP_CLASSA_NSHIFT) == IP_LOOPBACKNET
 8017ea6:	68fb      	ldr	r3, [r7, #12]
 8017ea8:	0e1b      	lsrs	r3, r3, #24
 8017eaa:	2b7f      	cmp	r3, #127	; 0x7f
 8017eac:	d00d      	beq.n	8017eca <ipcp_up+0x18a>
	    || IP_MULTICAST(addr) || IP_BADCLASS(addr)
 8017eae:	68fb      	ldr	r3, [r7, #12]
 8017eb0:	0f1b      	lsrs	r3, r3, #28
 8017eb2:	071a      	lsls	r2, r3, #28
 8017eb4:	23e0      	movs	r3, #224	; 0xe0
 8017eb6:	061b      	lsls	r3, r3, #24
 8017eb8:	429a      	cmp	r2, r3
 8017eba:	d006      	beq.n	8017eca <ipcp_up+0x18a>
 8017ebc:	68fb      	ldr	r3, [r7, #12]
 8017ebe:	0f1b      	lsrs	r3, r3, #28
 8017ec0:	071a      	lsls	r2, r3, #28
 8017ec2:	23f0      	movs	r3, #240	; 0xf0
 8017ec4:	061b      	lsls	r3, r3, #24
 8017ec6:	429a      	cmp	r2, r3
 8017ec8:	d10d      	bne.n	8017ee6 <ipcp_up+0x1a6>
	     */
#if PPP_SERVER && PPP_AUTH_SUPPORT
	    || (pcb->settings.auth_required && wo->hisaddr != ho->hisaddr)
#endif /* PPP_SERVER && PPP_AUTH_SUPPORT */
	    ) {
		ppp_error("Peer is not authorized to use remote address %I", ho->hisaddr);
 8017eca:	69bb      	ldr	r3, [r7, #24]
 8017ecc:	689a      	ldr	r2, [r3, #8]
 8017ece:	4b47      	ldr	r3, [pc, #284]	; (8017fec <ipcp_up+0x2ac>)
 8017ed0:	0011      	movs	r1, r2
 8017ed2:	0018      	movs	r0, r3
 8017ed4:	f004 f835 	bl	801bf42 <ppp_error>
		ipcp_close(pcb, "Unauthorized remote IP address");
 8017ed8:	4a45      	ldr	r2, [pc, #276]	; (8017ff0 <ipcp_up+0x2b0>)
 8017eda:	69fb      	ldr	r3, [r7, #28]
 8017edc:	0011      	movs	r1, r2
 8017ede:	0018      	movs	r0, r3
 8017ee0:	f7fd fece 	bl	8015c80 <ipcp_close>
		return;
 8017ee4:	e06e      	b.n	8017fc4 <ipcp_up+0x284>
    }
#endif /* Unused */

#if VJ_SUPPORT
    /* set tcp compression */
    sifvjcomp(pcb, ho->neg_vj, ho->cflag, ho->maxslotindex);
 8017ee6:	69bb      	ldr	r3, [r7, #24]
 8017ee8:	781b      	ldrb	r3, [r3, #0]
 8017eea:	071b      	lsls	r3, r3, #28
 8017eec:	0fdb      	lsrs	r3, r3, #31
 8017eee:	b2db      	uxtb	r3, r3
 8017ef0:	0019      	movs	r1, r3
 8017ef2:	69bb      	ldr	r3, [r7, #24]
 8017ef4:	781b      	ldrb	r3, [r3, #0]
 8017ef6:	069b      	lsls	r3, r3, #26
 8017ef8:	0fdb      	lsrs	r3, r3, #31
 8017efa:	b2db      	uxtb	r3, r3
 8017efc:	001a      	movs	r2, r3
 8017efe:	69bb      	ldr	r3, [r7, #24]
 8017f00:	7d9b      	ldrb	r3, [r3, #22]
 8017f02:	69f8      	ldr	r0, [r7, #28]
 8017f04:	f002 fe44 	bl	801ab90 <sifvjcomp>
#endif /* DEMAND_SUPPORT */
    {
	/*
	 * Set IP addresses and (if specified) netmask.
	 */
	mask = get_mask(go->ouraddr);
 8017f08:	697b      	ldr	r3, [r7, #20]
 8017f0a:	685b      	ldr	r3, [r3, #4]
 8017f0c:	0018      	movs	r0, r3
 8017f0e:	f002 fe9d 	bl	801ac4c <get_mask>
 8017f12:	0003      	movs	r3, r0
 8017f14:	60bb      	str	r3, [r7, #8]

#if !(defined(SVR4) && (defined(SNI) || defined(__USLC__)))
	if (!sifaddr(pcb, go->ouraddr, ho->hisaddr, mask)) {
 8017f16:	697b      	ldr	r3, [r7, #20]
 8017f18:	6859      	ldr	r1, [r3, #4]
 8017f1a:	69bb      	ldr	r3, [r7, #24]
 8017f1c:	689a      	ldr	r2, [r3, #8]
 8017f1e:	68bb      	ldr	r3, [r7, #8]
 8017f20:	69f8      	ldr	r0, [r7, #28]
 8017f22:	f002 fdb9 	bl	801aa98 <sifaddr>
 8017f26:	1e03      	subs	r3, r0, #0
 8017f28:	d107      	bne.n	8017f3a <ipcp_up+0x1fa>
#if PPP_DEBUG
	    ppp_warn("Interface configuration failed");
#endif /* PPP_DEBUG */
	    ipcp_close(f->pcb, "Interface configuration failed");
 8017f2a:	687b      	ldr	r3, [r7, #4]
 8017f2c:	681b      	ldr	r3, [r3, #0]
 8017f2e:	4a31      	ldr	r2, [pc, #196]	; (8017ff4 <ipcp_up+0x2b4>)
 8017f30:	0011      	movs	r1, r2
 8017f32:	0018      	movs	r0, r3
 8017f34:	f7fd fea4 	bl	8015c80 <ipcp_close>
	    return;
 8017f38:	e044      	b.n	8017fc4 <ipcp_up+0x284>
	}
#endif

	/* bring the interface up for IP */
	if (!sifup(pcb)) {
 8017f3a:	69fb      	ldr	r3, [r7, #28]
 8017f3c:	0018      	movs	r0, r3
 8017f3e:	f002 fe4e 	bl	801abde <sifup>
 8017f42:	1e03      	subs	r3, r0, #0
 8017f44:	d107      	bne.n	8017f56 <ipcp_up+0x216>
#if PPP_DEBUG
	    ppp_warn("Interface failed to come up");
#endif /* PPP_DEBUG */
	    ipcp_close(f->pcb, "Interface configuration failed");
 8017f46:	687b      	ldr	r3, [r7, #4]
 8017f48:	681b      	ldr	r3, [r3, #0]
 8017f4a:	4a2a      	ldr	r2, [pc, #168]	; (8017ff4 <ipcp_up+0x2b4>)
 8017f4c:	0011      	movs	r1, r2
 8017f4e:	0018      	movs	r0, r3
 8017f50:	f7fd fe96 	bl	8015c80 <ipcp_close>
	    return;
 8017f54:	e036      	b.n	8017fc4 <ipcp_up+0x284>
	if (ho->hisaddr != 0 && wo->proxy_arp)
	    if (sifproxyarp(pcb, ho->hisaddr))
		pcb->proxy_arp_set = 1;
#endif /* UNUSED - PROXY ARP */

	wo->ouraddr = go->ouraddr;
 8017f56:	697b      	ldr	r3, [r7, #20]
 8017f58:	685a      	ldr	r2, [r3, #4]
 8017f5a:	693b      	ldr	r3, [r7, #16]
 8017f5c:	605a      	str	r2, [r3, #4]

	ppp_notice("local  IP address %I", go->ouraddr);
 8017f5e:	697b      	ldr	r3, [r7, #20]
 8017f60:	685a      	ldr	r2, [r3, #4]
 8017f62:	4b25      	ldr	r3, [pc, #148]	; (8017ff8 <ipcp_up+0x2b8>)
 8017f64:	0011      	movs	r1, r2
 8017f66:	0018      	movs	r0, r3
 8017f68:	f004 f813 	bl	801bf92 <ppp_notice>
	if (ho->hisaddr != 0)
 8017f6c:	69bb      	ldr	r3, [r7, #24]
 8017f6e:	689b      	ldr	r3, [r3, #8]
 8017f70:	2b00      	cmp	r3, #0
 8017f72:	d006      	beq.n	8017f82 <ipcp_up+0x242>
	    ppp_notice("remote IP address %I", ho->hisaddr);
 8017f74:	69bb      	ldr	r3, [r7, #24]
 8017f76:	689a      	ldr	r2, [r3, #8]
 8017f78:	4b20      	ldr	r3, [pc, #128]	; (8017ffc <ipcp_up+0x2bc>)
 8017f7a:	0011      	movs	r1, r2
 8017f7c:	0018      	movs	r0, r3
 8017f7e:	f004 f808 	bl	801bf92 <ppp_notice>
#if LWIP_DNS
	if (go->dnsaddr[0])
 8017f82:	697b      	ldr	r3, [r7, #20]
 8017f84:	68db      	ldr	r3, [r3, #12]
 8017f86:	2b00      	cmp	r3, #0
 8017f88:	d006      	beq.n	8017f98 <ipcp_up+0x258>
	    ppp_notice("primary   DNS address %I", go->dnsaddr[0]);
 8017f8a:	697b      	ldr	r3, [r7, #20]
 8017f8c:	68da      	ldr	r2, [r3, #12]
 8017f8e:	4b1c      	ldr	r3, [pc, #112]	; (8018000 <ipcp_up+0x2c0>)
 8017f90:	0011      	movs	r1, r2
 8017f92:	0018      	movs	r0, r3
 8017f94:	f003 fffd 	bl	801bf92 <ppp_notice>
	if (go->dnsaddr[1])
 8017f98:	697b      	ldr	r3, [r7, #20]
 8017f9a:	691b      	ldr	r3, [r3, #16]
 8017f9c:	2b00      	cmp	r3, #0
 8017f9e:	d006      	beq.n	8017fae <ipcp_up+0x26e>
	    ppp_notice("secondary DNS address %I", go->dnsaddr[1]);
 8017fa0:	697b      	ldr	r3, [r7, #20]
 8017fa2:	691a      	ldr	r2, [r3, #16]
 8017fa4:	4b17      	ldr	r3, [pc, #92]	; (8018004 <ipcp_up+0x2c4>)
 8017fa6:	0011      	movs	r1, r2
 8017fa8:	0018      	movs	r0, r3
 8017faa:	f003 fff2 	bl	801bf92 <ppp_notice>

#if PPP_STATS_SUPPORT
    reset_link_stats(f->unit);
#endif /* PPP_STATS_SUPPORT */

    np_up(pcb, PPP_IP);
 8017fae:	69fb      	ldr	r3, [r7, #28]
 8017fb0:	2121      	movs	r1, #33	; 0x21
 8017fb2:	0018      	movs	r0, r3
 8017fb4:	f7fc fdda 	bl	8014b6c <np_up>
    pcb->ipcp_is_up = 1;
 8017fb8:	69fb      	ldr	r3, [r7, #28]
 8017fba:	2226      	movs	r2, #38	; 0x26
 8017fbc:	5c99      	ldrb	r1, [r3, r2]
 8017fbe:	2004      	movs	r0, #4
 8017fc0:	4301      	orrs	r1, r0
 8017fc2:	5499      	strb	r1, [r3, r2]
#endif /* PPP_NOTIFY */
#if 0 /* UNUSED */
    if (ip_up_hook)
	ip_up_hook();
#endif /* UNUSED */
}
 8017fc4:	46bd      	mov	sp, r7
 8017fc6:	b008      	add	sp, #32
 8017fc8:	bd80      	pop	{r7, pc}
 8017fca:	46c0      	nop			; (mov r8, r8)
 8017fcc:	0000124c 	.word	0x0000124c
 8017fd0:	0000121c 	.word	0x0000121c
 8017fd4:	00001204 	.word	0x00001204
 8017fd8:	080227c4 	.word	0x080227c4
 8017fdc:	080227ec 	.word	0x080227ec
 8017fe0:	08022804 	.word	0x08022804
 8017fe4:	0a404040 	.word	0x0a404040
 8017fe8:	0802282c 	.word	0x0802282c
 8017fec:	08022864 	.word	0x08022864
 8017ff0:	08022894 	.word	0x08022894
 8017ff4:	080228b4 	.word	0x080228b4
 8017ff8:	080228d4 	.word	0x080228d4
 8017ffc:	080228ec 	.word	0x080228ec
 8018000:	08022904 	.word	0x08022904
 8018004:	08022920 	.word	0x08022920

08018008 <ipcp_down>:
 * ipcp_down - IPCP has gone DOWN.
 *
 * Take the IP network interface down, clear its addresses
 * and delete routes through it.
 */
static void ipcp_down(fsm *f) {
 8018008:	b580      	push	{r7, lr}
 801800a:	b086      	sub	sp, #24
 801800c:	af00      	add	r7, sp, #0
 801800e:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8018010:	687b      	ldr	r3, [r7, #4]
 8018012:	681b      	ldr	r3, [r3, #0]
 8018014:	617b      	str	r3, [r7, #20]
    ipcp_options *ho = &pcb->ipcp_hisoptions;
 8018016:	697b      	ldr	r3, [r7, #20]
 8018018:	4a1c      	ldr	r2, [pc, #112]	; (801808c <ipcp_down+0x84>)
 801801a:	4694      	mov	ip, r2
 801801c:	4463      	add	r3, ip
 801801e:	613b      	str	r3, [r7, #16]
    ipcp_options *go = &pcb->ipcp_gotoptions;
 8018020:	697b      	ldr	r3, [r7, #20]
 8018022:	4a1b      	ldr	r2, [pc, #108]	; (8018090 <ipcp_down+0x88>)
 8018024:	4694      	mov	ip, r2
 8018026:	4463      	add	r3, ip
 8018028:	60fb      	str	r3, [r7, #12]
#endif /* PPP_NOTIFY */
#if 0 /* UNUSED */
    if (ip_down_hook)
	ip_down_hook();
#endif /* UNUSED */
    if (pcb->ipcp_is_up) {
 801802a:	697b      	ldr	r3, [r7, #20]
 801802c:	2226      	movs	r2, #38	; 0x26
 801802e:	5c9b      	ldrb	r3, [r3, r2]
 8018030:	2204      	movs	r2, #4
 8018032:	4013      	ands	r3, r2
 8018034:	b2db      	uxtb	r3, r3
 8018036:	2b00      	cmp	r3, #0
 8018038:	d00a      	beq.n	8018050 <ipcp_down+0x48>
	pcb->ipcp_is_up = 0;
 801803a:	697b      	ldr	r3, [r7, #20]
 801803c:	2226      	movs	r2, #38	; 0x26
 801803e:	5c99      	ldrb	r1, [r3, r2]
 8018040:	2004      	movs	r0, #4
 8018042:	4381      	bics	r1, r0
 8018044:	5499      	strb	r1, [r3, r2]
	np_down(pcb, PPP_IP);
 8018046:	697b      	ldr	r3, [r7, #20]
 8018048:	2121      	movs	r1, #33	; 0x21
 801804a:	0018      	movs	r0, r3
 801804c:	f7fc fda9 	bl	8014ba2 <np_down>
    }
#if VJ_SUPPORT
    sifvjcomp(pcb, 0, 0, 0);
 8018050:	6978      	ldr	r0, [r7, #20]
 8018052:	2300      	movs	r3, #0
 8018054:	2200      	movs	r2, #0
 8018056:	2100      	movs	r1, #0
 8018058:	f002 fd9a 	bl	801ab90 <sifvjcomp>
#endif /* DEMAND_SUPPORT */
    {
#if DEMAND_SUPPORT
	sifnpmode(pcb, PPP_IP, NPMODE_DROP);
#endif /* DEMAND_SUPPORT */
	sifdown(pcb);
 801805c:	697b      	ldr	r3, [r7, #20]
 801805e:	0018      	movs	r0, r3
 8018060:	f002 fde0 	bl	801ac24 <sifdown>
	ipcp_clear_addrs(pcb, go->ouraddr,
 8018064:	68fb      	ldr	r3, [r7, #12]
 8018066:	6859      	ldr	r1, [r3, #4]
 8018068:	693b      	ldr	r3, [r7, #16]
 801806a:	689a      	ldr	r2, [r3, #8]
 801806c:	6978      	ldr	r0, [r7, #20]
 801806e:	2300      	movs	r3, #0
 8018070:	f000 f810 	bl	8018094 <ipcp_clear_addrs>
			 ho->hisaddr, 0);
#if LWIP_DNS
	cdns(pcb, go->dnsaddr[0], go->dnsaddr[1]);
 8018074:	68fb      	ldr	r3, [r7, #12]
 8018076:	68d9      	ldr	r1, [r3, #12]
 8018078:	68fb      	ldr	r3, [r7, #12]
 801807a:	691a      	ldr	r2, [r3, #16]
 801807c:	697b      	ldr	r3, [r7, #20]
 801807e:	0018      	movs	r0, r3
 8018080:	f002 fd56 	bl	801ab30 <cdns>
#endif /* LWIP_DNS */
    }
}
 8018084:	46c0      	nop			; (mov r8, r8)
 8018086:	46bd      	mov	sp, r7
 8018088:	b006      	add	sp, #24
 801808a:	bd80      	pop	{r7, pc}
 801808c:	0000124c 	.word	0x0000124c
 8018090:	0000121c 	.word	0x0000121c

08018094 <ipcp_clear_addrs>:

/*
 * ipcp_clear_addrs() - clear the interface addresses, routes,
 * proxy arp entries, etc.
 */
static void ipcp_clear_addrs(ppp_pcb *pcb, u32_t ouraddr, u32_t hisaddr, u8_t replacedefaultroute) {
 8018094:	b580      	push	{r7, lr}
 8018096:	b084      	sub	sp, #16
 8018098:	af00      	add	r7, sp, #0
 801809a:	60f8      	str	r0, [r7, #12]
 801809c:	60b9      	str	r1, [r7, #8]
 801809e:	607a      	str	r2, [r7, #4]
 80180a0:	001a      	movs	r2, r3
 80180a2:	1cfb      	adds	r3, r7, #3
 80180a4:	701a      	strb	r2, [r3, #0]
    if (!replacedefaultroute && pcb->default_route_set) {
	cifdefaultroute(pcb, ouraddr, hisaddr);
	pcb->default_route_set = 0;
    }
#endif /* UNUSED */
    cifaddr(pcb, ouraddr, hisaddr);
 80180a6:	687a      	ldr	r2, [r7, #4]
 80180a8:	68b9      	ldr	r1, [r7, #8]
 80180aa:	68fb      	ldr	r3, [r7, #12]
 80180ac:	0018      	movs	r0, r3
 80180ae:	f002 fd0f 	bl	801aad0 <cifaddr>
}
 80180b2:	46c0      	nop			; (mov r8, r8)
 80180b4:	46bd      	mov	sp, r7
 80180b6:	b004      	add	sp, #16
 80180b8:	bd80      	pop	{r7, pc}

080180ba <ipcp_finished>:


/*
 * ipcp_finished - possibly shut down the lower layers.
 */
static void ipcp_finished(fsm *f) {
 80180ba:	b580      	push	{r7, lr}
 80180bc:	b084      	sub	sp, #16
 80180be:	af00      	add	r7, sp, #0
 80180c0:	6078      	str	r0, [r7, #4]
	ppp_pcb *pcb = f->pcb;
 80180c2:	687b      	ldr	r3, [r7, #4]
 80180c4:	681b      	ldr	r3, [r3, #0]
 80180c6:	60fb      	str	r3, [r7, #12]
	if (pcb->ipcp_is_open) {
 80180c8:	68fb      	ldr	r3, [r7, #12]
 80180ca:	2226      	movs	r2, #38	; 0x26
 80180cc:	5c9b      	ldrb	r3, [r3, r2]
 80180ce:	2202      	movs	r2, #2
 80180d0:	4013      	ands	r3, r2
 80180d2:	b2db      	uxtb	r3, r3
 80180d4:	2b00      	cmp	r3, #0
 80180d6:	d00a      	beq.n	80180ee <ipcp_finished+0x34>
		pcb->ipcp_is_open = 0;
 80180d8:	68fb      	ldr	r3, [r7, #12]
 80180da:	2226      	movs	r2, #38	; 0x26
 80180dc:	5c99      	ldrb	r1, [r3, r2]
 80180de:	2002      	movs	r0, #2
 80180e0:	4381      	bics	r1, r0
 80180e2:	5499      	strb	r1, [r3, r2]
		np_finished(pcb, PPP_IP);
 80180e4:	68fb      	ldr	r3, [r7, #12]
 80180e6:	2121      	movs	r1, #33	; 0x21
 80180e8:	0018      	movs	r0, r3
 80180ea:	f7fc fd75 	bl	8014bd8 <np_finished>
	}
}
 80180ee:	46c0      	nop			; (mov r8, r8)
 80180f0:	46bd      	mov	sp, r7
 80180f2:	b004      	add	sp, #16
 80180f4:	bd80      	pop	{r7, pc}
	...

080180f8 <lcp_init>:
#endif /* HAVE_MULTILINK */

/*
 * lcp_init - Initialize LCP.
 */
static void lcp_init(ppp_pcb *pcb) {
 80180f8:	b580      	push	{r7, lr}
 80180fa:	b086      	sub	sp, #24
 80180fc:	af00      	add	r7, sp, #0
 80180fe:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->lcp_fsm;
 8018100:	687b      	ldr	r3, [r7, #4]
 8018102:	3328      	adds	r3, #40	; 0x28
 8018104:	617b      	str	r3, [r7, #20]
    lcp_options *wo = &pcb->lcp_wantoptions;
 8018106:	687b      	ldr	r3, [r7, #4]
 8018108:	3344      	adds	r3, #68	; 0x44
 801810a:	613b      	str	r3, [r7, #16]
    lcp_options *ao = &pcb->lcp_allowoptions;
 801810c:	687b      	ldr	r3, [r7, #4]
 801810e:	338c      	adds	r3, #140	; 0x8c
 8018110:	60fb      	str	r3, [r7, #12]

    f->pcb = pcb;
 8018112:	697b      	ldr	r3, [r7, #20]
 8018114:	687a      	ldr	r2, [r7, #4]
 8018116:	601a      	str	r2, [r3, #0]
    f->protocol = PPP_LCP;
 8018118:	697b      	ldr	r3, [r7, #20]
 801811a:	4a2b      	ldr	r2, [pc, #172]	; (80181c8 <lcp_init+0xd0>)
 801811c:	81da      	strh	r2, [r3, #14]
    f->callbacks = &lcp_callbacks;
 801811e:	697b      	ldr	r3, [r7, #20]
 8018120:	4a2a      	ldr	r2, [pc, #168]	; (80181cc <lcp_init+0xd4>)
 8018122:	605a      	str	r2, [r3, #4]

    fsm_init(f);
 8018124:	697b      	ldr	r3, [r7, #20]
 8018126:	0018      	movs	r0, r3
 8018128:	f7fc fd74 	bl	8014c14 <fsm_init>

    BZERO(wo, sizeof(*wo));
 801812c:	693b      	ldr	r3, [r7, #16]
 801812e:	2224      	movs	r2, #36	; 0x24
 8018130:	2100      	movs	r1, #0
 8018132:	0018      	movs	r0, r3
 8018134:	f005 ff4e 	bl	801dfd4 <memset>
    wo->neg_mru = 1;
 8018138:	693b      	ldr	r3, [r7, #16]
 801813a:	781a      	ldrb	r2, [r3, #0]
 801813c:	2104      	movs	r1, #4
 801813e:	430a      	orrs	r2, r1
 8018140:	701a      	strb	r2, [r3, #0]
    wo->mru = PPP_DEFMRU;
 8018142:	693b      	ldr	r3, [r7, #16]
 8018144:	4a22      	ldr	r2, [pc, #136]	; (80181d0 <lcp_init+0xd8>)
 8018146:	805a      	strh	r2, [r3, #2]
    wo->neg_asyncmap = 1;
 8018148:	693b      	ldr	r3, [r7, #16]
 801814a:	781a      	ldrb	r2, [r3, #0]
 801814c:	2108      	movs	r1, #8
 801814e:	430a      	orrs	r2, r1
 8018150:	701a      	strb	r2, [r3, #0]
    wo->neg_magicnumber = 1;
 8018152:	693b      	ldr	r3, [r7, #16]
 8018154:	781a      	ldrb	r2, [r3, #0]
 8018156:	2110      	movs	r1, #16
 8018158:	430a      	orrs	r2, r1
 801815a:	701a      	strb	r2, [r3, #0]
    wo->neg_pcompression = 1;
 801815c:	693b      	ldr	r3, [r7, #16]
 801815e:	781a      	ldrb	r2, [r3, #0]
 8018160:	2120      	movs	r1, #32
 8018162:	430a      	orrs	r2, r1
 8018164:	701a      	strb	r2, [r3, #0]
    wo->neg_accompression = 1;
 8018166:	693b      	ldr	r3, [r7, #16]
 8018168:	781a      	ldrb	r2, [r3, #0]
 801816a:	2140      	movs	r1, #64	; 0x40
 801816c:	430a      	orrs	r2, r1
 801816e:	701a      	strb	r2, [r3, #0]

    BZERO(ao, sizeof(*ao));
 8018170:	68fb      	ldr	r3, [r7, #12]
 8018172:	2224      	movs	r2, #36	; 0x24
 8018174:	2100      	movs	r1, #0
 8018176:	0018      	movs	r0, r3
 8018178:	f005 ff2c 	bl	801dfd4 <memset>
    ao->neg_mru = 1;
 801817c:	68fb      	ldr	r3, [r7, #12]
 801817e:	781a      	ldrb	r2, [r3, #0]
 8018180:	2104      	movs	r1, #4
 8018182:	430a      	orrs	r2, r1
 8018184:	701a      	strb	r2, [r3, #0]
    ao->mru = PPP_MAXMRU;
 8018186:	68fb      	ldr	r3, [r7, #12]
 8018188:	4a11      	ldr	r2, [pc, #68]	; (80181d0 <lcp_init+0xd8>)
 801818a:	805a      	strh	r2, [r3, #2]
    ao->neg_asyncmap = 1;
 801818c:	68fb      	ldr	r3, [r7, #12]
 801818e:	781a      	ldrb	r2, [r3, #0]
 8018190:	2108      	movs	r1, #8
 8018192:	430a      	orrs	r2, r1
 8018194:	701a      	strb	r2, [r3, #0]
    ao->neg_upap = 1;
#endif /* PAP_SUPPORT */
#if EAP_SUPPORT
    ao->neg_eap = 1;
#endif /* EAP_SUPPORT */
    ao->neg_magicnumber = 1;
 8018196:	68fb      	ldr	r3, [r7, #12]
 8018198:	781a      	ldrb	r2, [r3, #0]
 801819a:	2110      	movs	r1, #16
 801819c:	430a      	orrs	r2, r1
 801819e:	701a      	strb	r2, [r3, #0]
    ao->neg_pcompression = 1;
 80181a0:	68fb      	ldr	r3, [r7, #12]
 80181a2:	781a      	ldrb	r2, [r3, #0]
 80181a4:	2120      	movs	r1, #32
 80181a6:	430a      	orrs	r2, r1
 80181a8:	701a      	strb	r2, [r3, #0]
    ao->neg_accompression = 1;
 80181aa:	68fb      	ldr	r3, [r7, #12]
 80181ac:	781a      	ldrb	r2, [r3, #0]
 80181ae:	2140      	movs	r1, #64	; 0x40
 80181b0:	430a      	orrs	r2, r1
 80181b2:	701a      	strb	r2, [r3, #0]
    ao->neg_endpoint = 1;
 80181b4:	68fb      	ldr	r3, [r7, #12]
 80181b6:	785a      	ldrb	r2, [r3, #1]
 80181b8:	2102      	movs	r1, #2
 80181ba:	430a      	orrs	r2, r1
 80181bc:	705a      	strb	r2, [r3, #1]
}
 80181be:	46c0      	nop			; (mov r8, r8)
 80181c0:	46bd      	mov	sp, r7
 80181c2:	b006      	add	sp, #24
 80181c4:	bd80      	pop	{r7, pc}
 80181c6:	46c0      	nop			; (mov r8, r8)
 80181c8:	ffffc021 	.word	0xffffc021
 80181cc:	08023bec 	.word	0x08023bec
 80181d0:	000005dc 	.word	0x000005dc

080181d4 <lcp_open>:


/*
 * lcp_open - LCP is allowed to come up.
 */
void lcp_open(ppp_pcb *pcb) {
 80181d4:	b580      	push	{r7, lr}
 80181d6:	b084      	sub	sp, #16
 80181d8:	af00      	add	r7, sp, #0
 80181da:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->lcp_fsm;
 80181dc:	687b      	ldr	r3, [r7, #4]
 80181de:	3328      	adds	r3, #40	; 0x28
 80181e0:	60fb      	str	r3, [r7, #12]
    lcp_options *wo = &pcb->lcp_wantoptions;
 80181e2:	687b      	ldr	r3, [r7, #4]
 80181e4:	3344      	adds	r3, #68	; 0x44
 80181e6:	60bb      	str	r3, [r7, #8]

    f->flags &= ~(OPT_PASSIVE | OPT_SILENT);
 80181e8:	68fb      	ldr	r3, [r7, #12]
 80181ea:	7c5b      	ldrb	r3, [r3, #17]
 80181ec:	2205      	movs	r2, #5
 80181ee:	4393      	bics	r3, r2
 80181f0:	b2da      	uxtb	r2, r3
 80181f2:	68fb      	ldr	r3, [r7, #12]
 80181f4:	745a      	strb	r2, [r3, #17]
    if (wo->passive)
 80181f6:	68bb      	ldr	r3, [r7, #8]
 80181f8:	781b      	ldrb	r3, [r3, #0]
 80181fa:	2201      	movs	r2, #1
 80181fc:	4013      	ands	r3, r2
 80181fe:	b2db      	uxtb	r3, r3
 8018200:	2b00      	cmp	r3, #0
 8018202:	d006      	beq.n	8018212 <lcp_open+0x3e>
	f->flags |= OPT_PASSIVE;
 8018204:	68fb      	ldr	r3, [r7, #12]
 8018206:	7c5b      	ldrb	r3, [r3, #17]
 8018208:	2201      	movs	r2, #1
 801820a:	4313      	orrs	r3, r2
 801820c:	b2da      	uxtb	r2, r3
 801820e:	68fb      	ldr	r3, [r7, #12]
 8018210:	745a      	strb	r2, [r3, #17]
    if (wo->silent)
 8018212:	68bb      	ldr	r3, [r7, #8]
 8018214:	781b      	ldrb	r3, [r3, #0]
 8018216:	2202      	movs	r2, #2
 8018218:	4013      	ands	r3, r2
 801821a:	b2db      	uxtb	r3, r3
 801821c:	2b00      	cmp	r3, #0
 801821e:	d006      	beq.n	801822e <lcp_open+0x5a>
	f->flags |= OPT_SILENT;
 8018220:	68fb      	ldr	r3, [r7, #12]
 8018222:	7c5b      	ldrb	r3, [r3, #17]
 8018224:	2204      	movs	r2, #4
 8018226:	4313      	orrs	r3, r2
 8018228:	b2da      	uxtb	r2, r3
 801822a:	68fb      	ldr	r3, [r7, #12]
 801822c:	745a      	strb	r2, [r3, #17]
    fsm_open(f);
 801822e:	68fb      	ldr	r3, [r7, #12]
 8018230:	0018      	movs	r0, r3
 8018232:	f7fc fd7d 	bl	8014d30 <fsm_open>
}
 8018236:	46c0      	nop			; (mov r8, r8)
 8018238:	46bd      	mov	sp, r7
 801823a:	b004      	add	sp, #16
 801823c:	bd80      	pop	{r7, pc}
	...

08018240 <lcp_close>:


/*
 * lcp_close - Take LCP down.
 */
void lcp_close(ppp_pcb *pcb, const char *reason) {
 8018240:	b580      	push	{r7, lr}
 8018242:	b084      	sub	sp, #16
 8018244:	af00      	add	r7, sp, #0
 8018246:	6078      	str	r0, [r7, #4]
 8018248:	6039      	str	r1, [r7, #0]
    fsm *f = &pcb->lcp_fsm;
 801824a:	687b      	ldr	r3, [r7, #4]
 801824c:	3328      	adds	r3, #40	; 0x28
 801824e:	60fb      	str	r3, [r7, #12]
    int oldstate;

    if (pcb->phase != PPP_PHASE_DEAD
 8018250:	687b      	ldr	r3, [r7, #4]
 8018252:	2224      	movs	r2, #36	; 0x24
 8018254:	5c9b      	ldrb	r3, [r3, r2]
 8018256:	2b00      	cmp	r3, #0
 8018258:	d004      	beq.n	8018264 <lcp_close+0x24>
#ifdef HAVE_MULTILINK
    && pcb->phase != PPP_PHASE_MASTER
#endif /* HAVE_MULTILINK */
    )
	new_phase(pcb, PPP_PHASE_TERMINATE);
 801825a:	687b      	ldr	r3, [r7, #4]
 801825c:	210b      	movs	r1, #11
 801825e:	0018      	movs	r0, r3
 8018260:	f002 fbc5 	bl	801a9ee <new_phase>

    if (f->flags & DELAYED_UP) {
 8018264:	68fb      	ldr	r3, [r7, #12]
 8018266:	7c5b      	ldrb	r3, [r3, #17]
 8018268:	b25b      	sxtb	r3, r3
 801826a:	2b00      	cmp	r3, #0
 801826c:	da08      	bge.n	8018280 <lcp_close+0x40>
	UNTIMEOUT(lcp_delayed_up, f);
 801826e:	68fa      	ldr	r2, [r7, #12]
 8018270:	4b14      	ldr	r3, [pc, #80]	; (80182c4 <lcp_close+0x84>)
 8018272:	0011      	movs	r1, r2
 8018274:	0018      	movs	r0, r3
 8018276:	f7fa fc1d 	bl	8012ab4 <sys_untimeout>
	f->state = PPP_FSM_STOPPED;
 801827a:	68fb      	ldr	r3, [r7, #12]
 801827c:	2203      	movs	r2, #3
 801827e:	741a      	strb	r2, [r3, #16]
    }
    oldstate = f->state;
 8018280:	68fb      	ldr	r3, [r7, #12]
 8018282:	7c1b      	ldrb	r3, [r3, #16]
 8018284:	60bb      	str	r3, [r7, #8]

    fsm_close(f, reason);
 8018286:	683a      	ldr	r2, [r7, #0]
 8018288:	68fb      	ldr	r3, [r7, #12]
 801828a:	0011      	movs	r1, r2
 801828c:	0018      	movs	r0, r3
 801828e:	f7fc fe11 	bl	8014eb4 <fsm_close>
    if (oldstate == PPP_FSM_STOPPED && (f->flags & (OPT_PASSIVE|OPT_SILENT|DELAYED_UP))) {
 8018292:	68bb      	ldr	r3, [r7, #8]
 8018294:	2b03      	cmp	r3, #3
 8018296:	d110      	bne.n	80182ba <lcp_close+0x7a>
 8018298:	68fb      	ldr	r3, [r7, #12]
 801829a:	7c5b      	ldrb	r3, [r3, #17]
 801829c:	001a      	movs	r2, r3
 801829e:	2385      	movs	r3, #133	; 0x85
 80182a0:	4013      	ands	r3, r2
 80182a2:	d00a      	beq.n	80182ba <lcp_close+0x7a>
	 * but it does mean that the program terminates if you do a
	 * lcp_close() when a connection hasn't been established
	 * because we are in passive/silent mode or because we have
	 * delayed the fsm_lowerup() call and it hasn't happened yet.
	 */
	f->flags &= ~DELAYED_UP;
 80182a4:	68fb      	ldr	r3, [r7, #12]
 80182a6:	7c5b      	ldrb	r3, [r3, #17]
 80182a8:	227f      	movs	r2, #127	; 0x7f
 80182aa:	4013      	ands	r3, r2
 80182ac:	b2da      	uxtb	r2, r3
 80182ae:	68fb      	ldr	r3, [r7, #12]
 80182b0:	745a      	strb	r2, [r3, #17]
	lcp_finished(f);
 80182b2:	68fb      	ldr	r3, [r7, #12]
 80182b4:	0018      	movs	r0, r3
 80182b6:	f001 fe64 	bl	8019f82 <lcp_finished>
    }
}
 80182ba:	46c0      	nop			; (mov r8, r8)
 80182bc:	46bd      	mov	sp, r7
 80182be:	b004      	add	sp, #16
 80182c0:	bd80      	pop	{r7, pc}
 80182c2:	46c0      	nop			; (mov r8, r8)
 80182c4:	080183d1 	.word	0x080183d1

080182c8 <lcp_lowerup>:


/*
 * lcp_lowerup - The lower layer is up.
 */
void lcp_lowerup(ppp_pcb *pcb) {
 80182c8:	b590      	push	{r4, r7, lr}
 80182ca:	b087      	sub	sp, #28
 80182cc:	af02      	add	r7, sp, #8
 80182ce:	6078      	str	r0, [r7, #4]
    lcp_options *wo = &pcb->lcp_wantoptions;
 80182d0:	687b      	ldr	r3, [r7, #4]
 80182d2:	3344      	adds	r3, #68	; 0x44
 80182d4:	60fb      	str	r3, [r7, #12]
    fsm *f = &pcb->lcp_fsm;
 80182d6:	687b      	ldr	r3, [r7, #4]
 80182d8:	3328      	adds	r3, #40	; 0x28
 80182da:	60bb      	str	r3, [r7, #8]
    /*
     * Don't use A/C or protocol compression on transmission,
     * but accept A/C and protocol compressed packets
     * if we are going to ask for A/C and protocol compression.
     */
    if (ppp_send_config(pcb, PPP_MRU, 0xffffffff, 0, 0) < 0
 80182dc:	2301      	movs	r3, #1
 80182de:	425a      	negs	r2, r3
 80182e0:	4927      	ldr	r1, [pc, #156]	; (8018380 <lcp_lowerup+0xb8>)
 80182e2:	6878      	ldr	r0, [r7, #4]
 80182e4:	2300      	movs	r3, #0
 80182e6:	9300      	str	r3, [sp, #0]
 80182e8:	2300      	movs	r3, #0
 80182ea:	f002 fb9b 	bl	801aa24 <ppp_send_config>
 80182ee:	1e03      	subs	r3, r0, #0
 80182f0:	db41      	blt.n	8018376 <lcp_lowerup+0xae>
	|| ppp_recv_config(pcb, PPP_MRU, (pcb->settings.lax_recv? 0: 0xffffffff),
 80182f2:	687b      	ldr	r3, [r7, #4]
 80182f4:	781b      	ldrb	r3, [r3, #0]
 80182f6:	2208      	movs	r2, #8
 80182f8:	4013      	ands	r3, r2
 80182fa:	b2db      	uxtb	r3, r3
 80182fc:	2b00      	cmp	r3, #0
 80182fe:	d001      	beq.n	8018304 <lcp_lowerup+0x3c>
 8018300:	2200      	movs	r2, #0
 8018302:	e001      	b.n	8018308 <lcp_lowerup+0x40>
 8018304:	2301      	movs	r3, #1
 8018306:	425a      	negs	r2, r3
			   wo->neg_pcompression, wo->neg_accompression) < 0)
 8018308:	68fb      	ldr	r3, [r7, #12]
 801830a:	781b      	ldrb	r3, [r3, #0]
 801830c:	069b      	lsls	r3, r3, #26
 801830e:	0fdb      	lsrs	r3, r3, #31
 8018310:	b2db      	uxtb	r3, r3
	|| ppp_recv_config(pcb, PPP_MRU, (pcb->settings.lax_recv? 0: 0xffffffff),
 8018312:	001c      	movs	r4, r3
			   wo->neg_pcompression, wo->neg_accompression) < 0)
 8018314:	68fb      	ldr	r3, [r7, #12]
 8018316:	781b      	ldrb	r3, [r3, #0]
 8018318:	065b      	lsls	r3, r3, #25
 801831a:	0fdb      	lsrs	r3, r3, #31
 801831c:	b2db      	uxtb	r3, r3
	|| ppp_recv_config(pcb, PPP_MRU, (pcb->settings.lax_recv? 0: 0xffffffff),
 801831e:	4918      	ldr	r1, [pc, #96]	; (8018380 <lcp_lowerup+0xb8>)
 8018320:	6878      	ldr	r0, [r7, #4]
 8018322:	9300      	str	r3, [sp, #0]
 8018324:	0023      	movs	r3, r4
 8018326:	f002 fb9a 	bl	801aa5e <ppp_recv_config>
 801832a:	1e03      	subs	r3, r0, #0
 801832c:	db23      	blt.n	8018376 <lcp_lowerup+0xae>
	    return;
    pcb->peer_mru = PPP_MRU;
 801832e:	687b      	ldr	r3, [r7, #4]
 8018330:	22d4      	movs	r2, #212	; 0xd4
 8018332:	4913      	ldr	r1, [pc, #76]	; (8018380 <lcp_lowerup+0xb8>)
 8018334:	5299      	strh	r1, [r3, r2]

    if (pcb->settings.listen_time != 0) {
 8018336:	687b      	ldr	r3, [r7, #4]
 8018338:	885b      	ldrh	r3, [r3, #2]
 801833a:	2b00      	cmp	r3, #0
 801833c:	d016      	beq.n	801836c <lcp_lowerup+0xa4>
	f->flags |= DELAYED_UP;
 801833e:	68bb      	ldr	r3, [r7, #8]
 8018340:	7c5b      	ldrb	r3, [r3, #17]
 8018342:	2280      	movs	r2, #128	; 0x80
 8018344:	4252      	negs	r2, r2
 8018346:	4313      	orrs	r3, r2
 8018348:	b2da      	uxtb	r2, r3
 801834a:	68bb      	ldr	r3, [r7, #8]
 801834c:	745a      	strb	r2, [r3, #17]
	TIMEOUTMS(lcp_delayed_up, f, pcb->settings.listen_time);
 801834e:	68ba      	ldr	r2, [r7, #8]
 8018350:	4b0c      	ldr	r3, [pc, #48]	; (8018384 <lcp_lowerup+0xbc>)
 8018352:	0011      	movs	r1, r2
 8018354:	0018      	movs	r0, r3
 8018356:	f7fa fbad 	bl	8012ab4 <sys_untimeout>
 801835a:	687b      	ldr	r3, [r7, #4]
 801835c:	885b      	ldrh	r3, [r3, #2]
 801835e:	0018      	movs	r0, r3
 8018360:	68ba      	ldr	r2, [r7, #8]
 8018362:	4b08      	ldr	r3, [pc, #32]	; (8018384 <lcp_lowerup+0xbc>)
 8018364:	0019      	movs	r1, r3
 8018366:	f7fa fb7d 	bl	8012a64 <sys_timeout>
 801836a:	e005      	b.n	8018378 <lcp_lowerup+0xb0>
    } else
	fsm_lowerup(f);
 801836c:	68bb      	ldr	r3, [r7, #8]
 801836e:	0018      	movs	r0, r3
 8018370:	f7fc fc6b 	bl	8014c4a <fsm_lowerup>
 8018374:	e000      	b.n	8018378 <lcp_lowerup+0xb0>
	    return;
 8018376:	46c0      	nop			; (mov r8, r8)
}
 8018378:	46bd      	mov	sp, r7
 801837a:	b005      	add	sp, #20
 801837c:	bd90      	pop	{r4, r7, pc}
 801837e:	46c0      	nop			; (mov r8, r8)
 8018380:	000005dc 	.word	0x000005dc
 8018384:	080183d1 	.word	0x080183d1

08018388 <lcp_lowerdown>:


/*
 * lcp_lowerdown - The lower layer is down.
 */
void lcp_lowerdown(ppp_pcb *pcb) {
 8018388:	b580      	push	{r7, lr}
 801838a:	b084      	sub	sp, #16
 801838c:	af00      	add	r7, sp, #0
 801838e:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->lcp_fsm;
 8018390:	687b      	ldr	r3, [r7, #4]
 8018392:	3328      	adds	r3, #40	; 0x28
 8018394:	60fb      	str	r3, [r7, #12]

    if (f->flags & DELAYED_UP) {
 8018396:	68fb      	ldr	r3, [r7, #12]
 8018398:	7c5b      	ldrb	r3, [r3, #17]
 801839a:	b25b      	sxtb	r3, r3
 801839c:	2b00      	cmp	r3, #0
 801839e:	da0d      	bge.n	80183bc <lcp_lowerdown+0x34>
	f->flags &= ~DELAYED_UP;
 80183a0:	68fb      	ldr	r3, [r7, #12]
 80183a2:	7c5b      	ldrb	r3, [r3, #17]
 80183a4:	227f      	movs	r2, #127	; 0x7f
 80183a6:	4013      	ands	r3, r2
 80183a8:	b2da      	uxtb	r2, r3
 80183aa:	68fb      	ldr	r3, [r7, #12]
 80183ac:	745a      	strb	r2, [r3, #17]
	UNTIMEOUT(lcp_delayed_up, f);
 80183ae:	68fa      	ldr	r2, [r7, #12]
 80183b0:	4b06      	ldr	r3, [pc, #24]	; (80183cc <lcp_lowerdown+0x44>)
 80183b2:	0011      	movs	r1, r2
 80183b4:	0018      	movs	r0, r3
 80183b6:	f7fa fb7d 	bl	8012ab4 <sys_untimeout>
    } else
	fsm_lowerdown(f);
}
 80183ba:	e003      	b.n	80183c4 <lcp_lowerdown+0x3c>
	fsm_lowerdown(f);
 80183bc:	68fb      	ldr	r3, [r7, #12]
 80183be:	0018      	movs	r0, r3
 80183c0:	f7fc fc6a 	bl	8014c98 <fsm_lowerdown>
}
 80183c4:	46c0      	nop			; (mov r8, r8)
 80183c6:	46bd      	mov	sp, r7
 80183c8:	b004      	add	sp, #16
 80183ca:	bd80      	pop	{r7, pc}
 80183cc:	080183d1 	.word	0x080183d1

080183d0 <lcp_delayed_up>:


/*
 * lcp_delayed_up - Bring the lower layer up now.
 */
static void lcp_delayed_up(void *arg) {
 80183d0:	b580      	push	{r7, lr}
 80183d2:	b084      	sub	sp, #16
 80183d4:	af00      	add	r7, sp, #0
 80183d6:	6078      	str	r0, [r7, #4]
    fsm *f = (fsm*)arg;
 80183d8:	687b      	ldr	r3, [r7, #4]
 80183da:	60fb      	str	r3, [r7, #12]

    if (f->flags & DELAYED_UP) {
 80183dc:	68fb      	ldr	r3, [r7, #12]
 80183de:	7c5b      	ldrb	r3, [r3, #17]
 80183e0:	b25b      	sxtb	r3, r3
 80183e2:	2b00      	cmp	r3, #0
 80183e4:	da0a      	bge.n	80183fc <lcp_delayed_up+0x2c>
	f->flags &= ~DELAYED_UP;
 80183e6:	68fb      	ldr	r3, [r7, #12]
 80183e8:	7c5b      	ldrb	r3, [r3, #17]
 80183ea:	227f      	movs	r2, #127	; 0x7f
 80183ec:	4013      	ands	r3, r2
 80183ee:	b2da      	uxtb	r2, r3
 80183f0:	68fb      	ldr	r3, [r7, #12]
 80183f2:	745a      	strb	r2, [r3, #17]
	fsm_lowerup(f);
 80183f4:	68fb      	ldr	r3, [r7, #12]
 80183f6:	0018      	movs	r0, r3
 80183f8:	f7fc fc27 	bl	8014c4a <fsm_lowerup>
    }
}
 80183fc:	46c0      	nop			; (mov r8, r8)
 80183fe:	46bd      	mov	sp, r7
 8018400:	b004      	add	sp, #16
 8018402:	bd80      	pop	{r7, pc}

08018404 <lcp_input>:


/*
 * lcp_input - Input LCP packet.
 */
static void lcp_input(ppp_pcb *pcb, u_char *p, int len) {
 8018404:	b580      	push	{r7, lr}
 8018406:	b086      	sub	sp, #24
 8018408:	af00      	add	r7, sp, #0
 801840a:	60f8      	str	r0, [r7, #12]
 801840c:	60b9      	str	r1, [r7, #8]
 801840e:	607a      	str	r2, [r7, #4]
    fsm *f = &pcb->lcp_fsm;
 8018410:	68fb      	ldr	r3, [r7, #12]
 8018412:	3328      	adds	r3, #40	; 0x28
 8018414:	617b      	str	r3, [r7, #20]

    if (f->flags & DELAYED_UP) {
 8018416:	697b      	ldr	r3, [r7, #20]
 8018418:	7c5b      	ldrb	r3, [r3, #17]
 801841a:	b25b      	sxtb	r3, r3
 801841c:	2b00      	cmp	r3, #0
 801841e:	da10      	bge.n	8018442 <lcp_input+0x3e>
	f->flags &= ~DELAYED_UP;
 8018420:	697b      	ldr	r3, [r7, #20]
 8018422:	7c5b      	ldrb	r3, [r3, #17]
 8018424:	227f      	movs	r2, #127	; 0x7f
 8018426:	4013      	ands	r3, r2
 8018428:	b2da      	uxtb	r2, r3
 801842a:	697b      	ldr	r3, [r7, #20]
 801842c:	745a      	strb	r2, [r3, #17]
	UNTIMEOUT(lcp_delayed_up, f);
 801842e:	697a      	ldr	r2, [r7, #20]
 8018430:	4b09      	ldr	r3, [pc, #36]	; (8018458 <lcp_input+0x54>)
 8018432:	0011      	movs	r1, r2
 8018434:	0018      	movs	r0, r3
 8018436:	f7fa fb3d 	bl	8012ab4 <sys_untimeout>
	fsm_lowerup(f);
 801843a:	697b      	ldr	r3, [r7, #20]
 801843c:	0018      	movs	r0, r3
 801843e:	f7fc fc04 	bl	8014c4a <fsm_lowerup>
    }
    fsm_input(f, p, len);
 8018442:	687a      	ldr	r2, [r7, #4]
 8018444:	68b9      	ldr	r1, [r7, #8]
 8018446:	697b      	ldr	r3, [r7, #20]
 8018448:	0018      	movs	r0, r3
 801844a:	f7fc fe1d 	bl	8015088 <fsm_input>
}
 801844e:	46c0      	nop			; (mov r8, r8)
 8018450:	46bd      	mov	sp, r7
 8018452:	b006      	add	sp, #24
 8018454:	bd80      	pop	{r7, pc}
 8018456:	46c0      	nop			; (mov r8, r8)
 8018458:	080183d1 	.word	0x080183d1

0801845c <lcp_extcode>:

/*
 * lcp_extcode - Handle a LCP-specific code.
 */
static int lcp_extcode(fsm *f, int code, int id, u_char *inp, int len) {
 801845c:	b580      	push	{r7, lr}
 801845e:	b08a      	sub	sp, #40	; 0x28
 8018460:	af02      	add	r7, sp, #8
 8018462:	60f8      	str	r0, [r7, #12]
 8018464:	60b9      	str	r1, [r7, #8]
 8018466:	607a      	str	r2, [r7, #4]
 8018468:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 801846a:	68fb      	ldr	r3, [r7, #12]
 801846c:	681b      	ldr	r3, [r3, #0]
 801846e:	61fb      	str	r3, [r7, #28]
    lcp_options *go = &pcb->lcp_gotoptions;
 8018470:	69fb      	ldr	r3, [r7, #28]
 8018472:	3368      	adds	r3, #104	; 0x68
 8018474:	61bb      	str	r3, [r7, #24]
    u_char *magp;

    switch( code ){
 8018476:	68bb      	ldr	r3, [r7, #8]
 8018478:	2b0d      	cmp	r3, #13
 801847a:	dc4d      	bgt.n	8018518 <lcp_extcode+0xbc>
 801847c:	68bb      	ldr	r3, [r7, #8]
 801847e:	2b0b      	cmp	r3, #11
 8018480:	da4c      	bge.n	801851c <lcp_extcode+0xc0>
 8018482:	68bb      	ldr	r3, [r7, #8]
 8018484:	2b0a      	cmp	r3, #10
 8018486:	d040      	beq.n	801850a <lcp_extcode+0xae>
 8018488:	68bb      	ldr	r3, [r7, #8]
 801848a:	2b0a      	cmp	r3, #10
 801848c:	dc44      	bgt.n	8018518 <lcp_extcode+0xbc>
 801848e:	68bb      	ldr	r3, [r7, #8]
 8018490:	2b08      	cmp	r3, #8
 8018492:	d003      	beq.n	801849c <lcp_extcode+0x40>
 8018494:	68bb      	ldr	r3, [r7, #8]
 8018496:	2b09      	cmp	r3, #9
 8018498:	d007      	beq.n	80184aa <lcp_extcode+0x4e>
 801849a:	e03d      	b.n	8018518 <lcp_extcode+0xbc>
    case PROTREJ:
	lcp_rprotrej(f, inp, len);
 801849c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801849e:	6839      	ldr	r1, [r7, #0]
 80184a0:	68fb      	ldr	r3, [r7, #12]
 80184a2:	0018      	movs	r0, r3
 80184a4:	f000 f842 	bl	801852c <lcp_rprotrej>
	break;
 80184a8:	e03b      	b.n	8018522 <lcp_extcode+0xc6>
    
    case ECHOREQ:
	if (f->state != PPP_FSM_OPENED)
 80184aa:	68fb      	ldr	r3, [r7, #12]
 80184ac:	7c1b      	ldrb	r3, [r3, #16]
 80184ae:	2b09      	cmp	r3, #9
 80184b0:	d136      	bne.n	8018520 <lcp_extcode+0xc4>
	    break;
	magp = inp;
 80184b2:	683b      	ldr	r3, [r7, #0]
 80184b4:	617b      	str	r3, [r7, #20]
	PUTLONG(go->magicnumber, magp);
 80184b6:	69bb      	ldr	r3, [r7, #24]
 80184b8:	689b      	ldr	r3, [r3, #8]
 80184ba:	0e19      	lsrs	r1, r3, #24
 80184bc:	697b      	ldr	r3, [r7, #20]
 80184be:	1c5a      	adds	r2, r3, #1
 80184c0:	617a      	str	r2, [r7, #20]
 80184c2:	b2ca      	uxtb	r2, r1
 80184c4:	701a      	strb	r2, [r3, #0]
 80184c6:	69bb      	ldr	r3, [r7, #24]
 80184c8:	689b      	ldr	r3, [r3, #8]
 80184ca:	0c19      	lsrs	r1, r3, #16
 80184cc:	697b      	ldr	r3, [r7, #20]
 80184ce:	1c5a      	adds	r2, r3, #1
 80184d0:	617a      	str	r2, [r7, #20]
 80184d2:	b2ca      	uxtb	r2, r1
 80184d4:	701a      	strb	r2, [r3, #0]
 80184d6:	69bb      	ldr	r3, [r7, #24]
 80184d8:	689b      	ldr	r3, [r3, #8]
 80184da:	0a19      	lsrs	r1, r3, #8
 80184dc:	697b      	ldr	r3, [r7, #20]
 80184de:	1c5a      	adds	r2, r3, #1
 80184e0:	617a      	str	r2, [r7, #20]
 80184e2:	b2ca      	uxtb	r2, r1
 80184e4:	701a      	strb	r2, [r3, #0]
 80184e6:	69bb      	ldr	r3, [r7, #24]
 80184e8:	6899      	ldr	r1, [r3, #8]
 80184ea:	697b      	ldr	r3, [r7, #20]
 80184ec:	1c5a      	adds	r2, r3, #1
 80184ee:	617a      	str	r2, [r7, #20]
 80184f0:	b2ca      	uxtb	r2, r1
 80184f2:	701a      	strb	r2, [r3, #0]
	fsm_sdata(f, ECHOREP, id, inp, len);
 80184f4:	687b      	ldr	r3, [r7, #4]
 80184f6:	b2da      	uxtb	r2, r3
 80184f8:	6839      	ldr	r1, [r7, #0]
 80184fa:	68f8      	ldr	r0, [r7, #12]
 80184fc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80184fe:	9300      	str	r3, [sp, #0]
 8018500:	000b      	movs	r3, r1
 8018502:	210a      	movs	r1, #10
 8018504:	f7fd faa2 	bl	8015a4c <fsm_sdata>
	break;
 8018508:	e00b      	b.n	8018522 <lcp_extcode+0xc6>
    
    case ECHOREP:
	lcp_received_echo_reply(f, id, inp, len);
 801850a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801850c:	683a      	ldr	r2, [r7, #0]
 801850e:	6879      	ldr	r1, [r7, #4]
 8018510:	68f8      	ldr	r0, [r7, #12]
 8018512:	f001 fdd1 	bl	801a0b8 <lcp_received_echo_reply>
	break;
 8018516:	e004      	b.n	8018522 <lcp_extcode+0xc6>
    case IDENTIF:
    case TIMEREM:
	break;

    default:
	return 0;
 8018518:	2300      	movs	r3, #0
 801851a:	e003      	b.n	8018524 <lcp_extcode+0xc8>
	break;
 801851c:	46c0      	nop			; (mov r8, r8)
 801851e:	e000      	b.n	8018522 <lcp_extcode+0xc6>
	    break;
 8018520:	46c0      	nop			; (mov r8, r8)
    }
    return 1;
 8018522:	2301      	movs	r3, #1
}
 8018524:	0018      	movs	r0, r3
 8018526:	46bd      	mov	sp, r7
 8018528:	b008      	add	sp, #32
 801852a:	bd80      	pop	{r7, pc}

0801852c <lcp_rprotrej>:
/*
 * lcp_rprotrej - Receive an Protocol-Reject.
 *
 * Figure out which protocol is rejected and inform it.
 */
static void lcp_rprotrej(fsm *f, u_char *inp, int len) {
 801852c:	b580      	push	{r7, lr}
 801852e:	b088      	sub	sp, #32
 8018530:	af00      	add	r7, sp, #0
 8018532:	60f8      	str	r0, [r7, #12]
 8018534:	60b9      	str	r1, [r7, #8]
 8018536:	607a      	str	r2, [r7, #4]
    u_short prot;
#if PPP_PROTOCOLNAME
    const char *pname;
#endif /* PPP_PROTOCOLNAME */

    if (len < 2) {
 8018538:	687b      	ldr	r3, [r7, #4]
 801853a:	2b01      	cmp	r3, #1
 801853c:	dd42      	ble.n	80185c4 <lcp_rprotrej+0x98>
	LCPDEBUG(("lcp_rprotrej: Rcvd short Protocol-Reject packet!"));
	return;
    }

    GETSHORT(prot, inp);
 801853e:	68bb      	ldr	r3, [r7, #8]
 8018540:	1c5a      	adds	r2, r3, #1
 8018542:	60ba      	str	r2, [r7, #8]
 8018544:	781b      	ldrb	r3, [r3, #0]
 8018546:	b29a      	uxth	r2, r3
 8018548:	201a      	movs	r0, #26
 801854a:	183b      	adds	r3, r7, r0
 801854c:	0212      	lsls	r2, r2, #8
 801854e:	801a      	strh	r2, [r3, #0]
 8018550:	68bb      	ldr	r3, [r7, #8]
 8018552:	1c5a      	adds	r2, r3, #1
 8018554:	60ba      	str	r2, [r7, #8]
 8018556:	781b      	ldrb	r3, [r3, #0]
 8018558:	b299      	uxth	r1, r3
 801855a:	183b      	adds	r3, r7, r0
 801855c:	183a      	adds	r2, r7, r0
 801855e:	8812      	ldrh	r2, [r2, #0]
 8018560:	430a      	orrs	r2, r1
 8018562:	801a      	strh	r2, [r3, #0]

    /*
     * Protocol-Reject packets received in any state other than the LCP
     * OPENED state SHOULD be silently discarded.
     */
    if( f->state != PPP_FSM_OPENED ){
 8018564:	68fb      	ldr	r3, [r7, #12]
 8018566:	7c1b      	ldrb	r3, [r3, #16]
 8018568:	2b09      	cmp	r3, #9
 801856a:	d12d      	bne.n	80185c8 <lcp_rprotrej+0x9c>
#endif /* PPP_PROTOCOLNAME */

    /*
     * Upcall the proper Protocol-Reject routine.
     */
    for (i = 0; (protp = protocols[i]) != NULL; ++i)
 801856c:	2300      	movs	r3, #0
 801856e:	61fb      	str	r3, [r7, #28]
 8018570:	e017      	b.n	80185a2 <lcp_rprotrej+0x76>
	if (protp->protocol == prot) {
 8018572:	697b      	ldr	r3, [r7, #20]
 8018574:	881b      	ldrh	r3, [r3, #0]
 8018576:	211a      	movs	r1, #26
 8018578:	187a      	adds	r2, r7, r1
 801857a:	8812      	ldrh	r2, [r2, #0]
 801857c:	429a      	cmp	r2, r3
 801857e:	d10d      	bne.n	801859c <lcp_rprotrej+0x70>
	    if (pname != NULL)
		ppp_dbglog("Protocol-Reject for '%s' (0x%x) received", pname,
		       prot);
	    else
#endif /* PPP_PROTOCOLNAME */
		ppp_dbglog("Protocol-Reject for 0x%x received", prot);
 8018580:	187b      	adds	r3, r7, r1
 8018582:	881a      	ldrh	r2, [r3, #0]
 8018584:	4b12      	ldr	r3, [pc, #72]	; (80185d0 <lcp_rprotrej+0xa4>)
 8018586:	0011      	movs	r1, r2
 8018588:	0018      	movs	r0, r3
 801858a:	f003 fd2a 	bl	801bfe2 <ppp_dbglog>
	    (*protp->protrej)(f->pcb);
 801858e:	697b      	ldr	r3, [r7, #20]
 8018590:	68da      	ldr	r2, [r3, #12]
 8018592:	68fb      	ldr	r3, [r7, #12]
 8018594:	681b      	ldr	r3, [r3, #0]
 8018596:	0018      	movs	r0, r3
 8018598:	4790      	blx	r2
	    return;
 801859a:	e016      	b.n	80185ca <lcp_rprotrej+0x9e>
    for (i = 0; (protp = protocols[i]) != NULL; ++i)
 801859c:	69fb      	ldr	r3, [r7, #28]
 801859e:	3301      	adds	r3, #1
 80185a0:	61fb      	str	r3, [r7, #28]
 80185a2:	4b0c      	ldr	r3, [pc, #48]	; (80185d4 <lcp_rprotrej+0xa8>)
 80185a4:	69fa      	ldr	r2, [r7, #28]
 80185a6:	0092      	lsls	r2, r2, #2
 80185a8:	58d3      	ldr	r3, [r2, r3]
 80185aa:	617b      	str	r3, [r7, #20]
 80185ac:	697b      	ldr	r3, [r7, #20]
 80185ae:	2b00      	cmp	r3, #0
 80185b0:	d1df      	bne.n	8018572 <lcp_rprotrej+0x46>
    if (pname != NULL)
	ppp_warn("Protocol-Reject for unsupported protocol '%s' (0x%x)", pname,
	     prot);
    else
#endif /* #if PPP_PROTOCOLNAME */
	ppp_warn("Protocol-Reject for unsupported protocol 0x%x", prot);
 80185b2:	231a      	movs	r3, #26
 80185b4:	18fb      	adds	r3, r7, r3
 80185b6:	881a      	ldrh	r2, [r3, #0]
 80185b8:	4b07      	ldr	r3, [pc, #28]	; (80185d8 <lcp_rprotrej+0xac>)
 80185ba:	0011      	movs	r1, r2
 80185bc:	0018      	movs	r0, r3
 80185be:	f003 fcd4 	bl	801bf6a <ppp_warn>
 80185c2:	e002      	b.n	80185ca <lcp_rprotrej+0x9e>
	return;
 80185c4:	46c0      	nop			; (mov r8, r8)
 80185c6:	e000      	b.n	80185ca <lcp_rprotrej+0x9e>
	return;
 80185c8:	46c0      	nop			; (mov r8, r8)
}
 80185ca:	46bd      	mov	sp, r7
 80185cc:	b008      	add	sp, #32
 80185ce:	bd80      	pop	{r7, pc}
 80185d0:	08022940 	.word	0x08022940
 80185d4:	08023cf8 	.word	0x08023cf8
 80185d8:	08022964 	.word	0x08022964

080185dc <lcp_protrej>:

/*
 * lcp_protrej - A Protocol-Reject was received.
 */
/*ARGSUSED*/
static void lcp_protrej(ppp_pcb *pcb) {
 80185dc:	b580      	push	{r7, lr}
 80185de:	b082      	sub	sp, #8
 80185e0:	af00      	add	r7, sp, #0
 80185e2:	6078      	str	r0, [r7, #4]
    /*
     * Can't reject LCP!
     */
    ppp_error("Received Protocol-Reject for LCP!");
 80185e4:	4b06      	ldr	r3, [pc, #24]	; (8018600 <lcp_protrej+0x24>)
 80185e6:	0018      	movs	r0, r3
 80185e8:	f003 fcab 	bl	801bf42 <ppp_error>
    fsm_protreject(&pcb->lcp_fsm);
 80185ec:	687b      	ldr	r3, [r7, #4]
 80185ee:	3328      	adds	r3, #40	; 0x28
 80185f0:	0018      	movs	r0, r3
 80185f2:	f7fd f8ed 	bl	80157d0 <fsm_protreject>
}
 80185f6:	46c0      	nop			; (mov r8, r8)
 80185f8:	46bd      	mov	sp, r7
 80185fa:	b002      	add	sp, #8
 80185fc:	bd80      	pop	{r7, pc}
 80185fe:	46c0      	nop			; (mov r8, r8)
 8018600:	08022994 	.word	0x08022994

08018604 <lcp_sprotrej>:


/*
 * lcp_sprotrej - Send a Protocol-Reject for some protocol.
 */
void lcp_sprotrej(ppp_pcb *pcb, u_char *p, int len) {
 8018604:	b580      	push	{r7, lr}
 8018606:	b088      	sub	sp, #32
 8018608:	af02      	add	r7, sp, #8
 801860a:	60f8      	str	r0, [r7, #12]
 801860c:	60b9      	str	r1, [r7, #8]
 801860e:	607a      	str	r2, [r7, #4]
    fsm *f = &pcb->lcp_fsm;
 8018610:	68fb      	ldr	r3, [r7, #12]
 8018612:	3328      	adds	r3, #40	; 0x28
 8018614:	617b      	str	r3, [r7, #20]
#if 0
    p += 2;
    len -= 2;
#endif

    fsm_sdata(f, PROTREJ, ++f->id,
 8018616:	697b      	ldr	r3, [r7, #20]
 8018618:	7c9b      	ldrb	r3, [r3, #18]
 801861a:	3301      	adds	r3, #1
 801861c:	b2da      	uxtb	r2, r3
 801861e:	697b      	ldr	r3, [r7, #20]
 8018620:	749a      	strb	r2, [r3, #18]
 8018622:	697b      	ldr	r3, [r7, #20]
 8018624:	7c9a      	ldrb	r2, [r3, #18]
 8018626:	68b9      	ldr	r1, [r7, #8]
 8018628:	6978      	ldr	r0, [r7, #20]
 801862a:	687b      	ldr	r3, [r7, #4]
 801862c:	9300      	str	r3, [sp, #0]
 801862e:	000b      	movs	r3, r1
 8018630:	2108      	movs	r1, #8
 8018632:	f7fd fa0b 	bl	8015a4c <fsm_sdata>
	      p, len);
}
 8018636:	46c0      	nop			; (mov r8, r8)
 8018638:	46bd      	mov	sp, r7
 801863a:	b006      	add	sp, #24
 801863c:	bd80      	pop	{r7, pc}
	...

08018640 <lcp_resetci>:


/*
 * lcp_resetci - Reset our CI.
 */
static void lcp_resetci(fsm *f) {
 8018640:	b590      	push	{r4, r7, lr}
 8018642:	b087      	sub	sp, #28
 8018644:	af00      	add	r7, sp, #0
 8018646:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8018648:	687b      	ldr	r3, [r7, #4]
 801864a:	681b      	ldr	r3, [r3, #0]
 801864c:	617b      	str	r3, [r7, #20]
    lcp_options *wo = &pcb->lcp_wantoptions;
 801864e:	697b      	ldr	r3, [r7, #20]
 8018650:	3344      	adds	r3, #68	; 0x44
 8018652:	613b      	str	r3, [r7, #16]
    lcp_options *go = &pcb->lcp_gotoptions;
 8018654:	697b      	ldr	r3, [r7, #20]
 8018656:	3368      	adds	r3, #104	; 0x68
 8018658:	60fb      	str	r3, [r7, #12]
    lcp_options *ao = &pcb->lcp_allowoptions;
 801865a:	697b      	ldr	r3, [r7, #20]
 801865c:	338c      	adds	r3, #140	; 0x8c
 801865e:	60bb      	str	r3, [r7, #8]
#endif /* EAP_SUPPORT */
    PPPDEBUG(LOG_DEBUG, ("\n"));

#endif /* PPP_AUTH_SUPPORT */

    wo->magicnumber = magic();
 8018660:	f001 fe46 	bl	801a2f0 <magic>
 8018664:	0002      	movs	r2, r0
 8018666:	693b      	ldr	r3, [r7, #16]
 8018668:	609a      	str	r2, [r3, #8]
    wo->numloops = 0;
 801866a:	693b      	ldr	r3, [r7, #16]
 801866c:	2200      	movs	r2, #0
 801866e:	731a      	strb	r2, [r3, #12]
    *go = *wo;
 8018670:	68fb      	ldr	r3, [r7, #12]
 8018672:	693a      	ldr	r2, [r7, #16]
 8018674:	ca13      	ldmia	r2!, {r0, r1, r4}
 8018676:	c313      	stmia	r3!, {r0, r1, r4}
 8018678:	ca13      	ldmia	r2!, {r0, r1, r4}
 801867a:	c313      	stmia	r3!, {r0, r1, r4}
 801867c:	ca13      	ldmia	r2!, {r0, r1, r4}
 801867e:	c313      	stmia	r3!, {r0, r1, r4}
#ifdef HAVE_MULTILINK
    if (!multilink) {
	go->neg_mrru = 0;
#endif /* HAVE_MULTILINK */
	go->neg_ssnhf = 0;
 8018680:	68fb      	ldr	r3, [r7, #12]
 8018682:	785a      	ldrb	r2, [r3, #1]
 8018684:	2101      	movs	r1, #1
 8018686:	438a      	bics	r2, r1
 8018688:	705a      	strb	r2, [r3, #1]
	go->neg_endpoint = 0;
 801868a:	68fb      	ldr	r3, [r7, #12]
 801868c:	785a      	ldrb	r2, [r3, #1]
 801868e:	2102      	movs	r1, #2
 8018690:	438a      	bics	r2, r1
 8018692:	705a      	strb	r2, [r3, #1]
#ifdef HAVE_MULTILINK
    }
#endif /* HAVE_MULTILINK */
    if (pcb->settings.noendpoint)
 8018694:	697b      	ldr	r3, [r7, #20]
 8018696:	781b      	ldrb	r3, [r3, #0]
 8018698:	2210      	movs	r2, #16
 801869a:	4013      	ands	r3, r2
 801869c:	b2db      	uxtb	r3, r3
 801869e:	2b00      	cmp	r3, #0
 80186a0:	d004      	beq.n	80186ac <lcp_resetci+0x6c>
	ao->neg_endpoint = 0;
 80186a2:	68bb      	ldr	r3, [r7, #8]
 80186a4:	785a      	ldrb	r2, [r3, #1]
 80186a6:	2102      	movs	r1, #2
 80186a8:	438a      	bics	r2, r1
 80186aa:	705a      	strb	r2, [r3, #1]
    pcb->peer_mru = PPP_MRU;
 80186ac:	697b      	ldr	r3, [r7, #20]
 80186ae:	22d4      	movs	r2, #212	; 0xd4
 80186b0:	4902      	ldr	r1, [pc, #8]	; (80186bc <lcp_resetci+0x7c>)
 80186b2:	5299      	strh	r1, [r3, r2]
#if 0 /* UNUSED */
    auth_reset(pcb);
#endif /* UNUSED */
}
 80186b4:	46c0      	nop			; (mov r8, r8)
 80186b6:	46bd      	mov	sp, r7
 80186b8:	b007      	add	sp, #28
 80186ba:	bd90      	pop	{r4, r7, pc}
 80186bc:	000005dc 	.word	0x000005dc

080186c0 <lcp_cilen>:


/*
 * lcp_cilen - Return length of our CI.
 */
static int lcp_cilen(fsm *f) {
 80186c0:	b580      	push	{r7, lr}
 80186c2:	b084      	sub	sp, #16
 80186c4:	af00      	add	r7, sp, #0
 80186c6:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 80186c8:	687b      	ldr	r3, [r7, #4]
 80186ca:	681b      	ldr	r3, [r3, #0]
 80186cc:	60fb      	str	r3, [r7, #12]
    lcp_options *go = &pcb->lcp_gotoptions;
 80186ce:	68fb      	ldr	r3, [r7, #12]
 80186d0:	3368      	adds	r3, #104	; 0x68
 80186d2:	60bb      	str	r3, [r7, #8]
    /*
     * NB: we only ask for one of CHAP, UPAP, or EAP, even if we will
     * accept more than one.  We prefer EAP first, then CHAP, then
     * PAP.
     */
    return (LENCISHORT(go->neg_mru && go->mru != PPP_DEFMRU) +
 80186d4:	68bb      	ldr	r3, [r7, #8]
 80186d6:	781b      	ldrb	r3, [r3, #0]
 80186d8:	2204      	movs	r2, #4
 80186da:	4013      	ands	r3, r2
 80186dc:	b2db      	uxtb	r3, r3
 80186de:	2b00      	cmp	r3, #0
 80186e0:	d006      	beq.n	80186f0 <lcp_cilen+0x30>
 80186e2:	68bb      	ldr	r3, [r7, #8]
 80186e4:	885b      	ldrh	r3, [r3, #2]
 80186e6:	4a29      	ldr	r2, [pc, #164]	; (801878c <lcp_cilen+0xcc>)
 80186e8:	4293      	cmp	r3, r2
 80186ea:	d001      	beq.n	80186f0 <lcp_cilen+0x30>
 80186ec:	2204      	movs	r2, #4
 80186ee:	e000      	b.n	80186f2 <lcp_cilen+0x32>
 80186f0:	2200      	movs	r2, #0
	    LENCILONG(go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF) +
 80186f2:	68bb      	ldr	r3, [r7, #8]
 80186f4:	781b      	ldrb	r3, [r3, #0]
 80186f6:	2108      	movs	r1, #8
 80186f8:	400b      	ands	r3, r1
 80186fa:	b2db      	uxtb	r3, r3
 80186fc:	2b00      	cmp	r3, #0
 80186fe:	d005      	beq.n	801870c <lcp_cilen+0x4c>
 8018700:	68bb      	ldr	r3, [r7, #8]
 8018702:	685b      	ldr	r3, [r3, #4]
 8018704:	3301      	adds	r3, #1
 8018706:	d001      	beq.n	801870c <lcp_cilen+0x4c>
 8018708:	2306      	movs	r3, #6
 801870a:	e000      	b.n	801870e <lcp_cilen+0x4e>
 801870c:	2300      	movs	r3, #0
    return (LENCISHORT(go->neg_mru && go->mru != PPP_DEFMRU) +
 801870e:	18d2      	adds	r2, r2, r3
#endif /* !EAP_SUPPORT && !CHAP_SUPPORT */
#endif /* PAP_SUPPORT */
#if LQR_SUPPORT
	    LENCILQR(go->neg_lqr) +
#endif /* LQR_SUPPORT */
	    LENCICBCP(go->neg_cbcp) +
 8018710:	68bb      	ldr	r3, [r7, #8]
 8018712:	781b      	ldrb	r3, [r3, #0]
 8018714:	217f      	movs	r1, #127	; 0x7f
 8018716:	438b      	bics	r3, r1
 8018718:	b2db      	uxtb	r3, r3
 801871a:	2b00      	cmp	r3, #0
 801871c:	d001      	beq.n	8018722 <lcp_cilen+0x62>
 801871e:	2303      	movs	r3, #3
 8018720:	e000      	b.n	8018724 <lcp_cilen+0x64>
 8018722:	2300      	movs	r3, #0
	    LENCILONG(go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF) +
 8018724:	189a      	adds	r2, r3, r2
	    LENCILONG(go->neg_magicnumber) +
 8018726:	68bb      	ldr	r3, [r7, #8]
 8018728:	781b      	ldrb	r3, [r3, #0]
 801872a:	2110      	movs	r1, #16
 801872c:	400b      	ands	r3, r1
 801872e:	b2db      	uxtb	r3, r3
 8018730:	2b00      	cmp	r3, #0
 8018732:	d001      	beq.n	8018738 <lcp_cilen+0x78>
 8018734:	2306      	movs	r3, #6
 8018736:	e000      	b.n	801873a <lcp_cilen+0x7a>
 8018738:	2300      	movs	r3, #0
	    LENCICBCP(go->neg_cbcp) +
 801873a:	189a      	adds	r2, r3, r2
	    LENCIVOID(go->neg_pcompression) +
 801873c:	68bb      	ldr	r3, [r7, #8]
 801873e:	781b      	ldrb	r3, [r3, #0]
 8018740:	091b      	lsrs	r3, r3, #4
 8018742:	b2db      	uxtb	r3, r3
 8018744:	0019      	movs	r1, r3
 8018746:	2302      	movs	r3, #2
 8018748:	400b      	ands	r3, r1
	    LENCILONG(go->neg_magicnumber) +
 801874a:	18d2      	adds	r2, r2, r3
	    LENCIVOID(go->neg_accompression) +
 801874c:	68bb      	ldr	r3, [r7, #8]
 801874e:	781b      	ldrb	r3, [r3, #0]
 8018750:	095b      	lsrs	r3, r3, #5
 8018752:	b2db      	uxtb	r3, r3
 8018754:	0019      	movs	r1, r3
 8018756:	2302      	movs	r3, #2
 8018758:	400b      	ands	r3, r1
	    LENCIVOID(go->neg_pcompression) +
 801875a:	18d2      	adds	r2, r2, r3
#ifdef HAVE_MULTILINK
	    LENCISHORT(go->neg_mrru) +
#endif /* HAVE_MULTILINK */
	    LENCIVOID(go->neg_ssnhf) +
 801875c:	68bb      	ldr	r3, [r7, #8]
 801875e:	785b      	ldrb	r3, [r3, #1]
 8018760:	005b      	lsls	r3, r3, #1
 8018762:	2102      	movs	r1, #2
 8018764:	400b      	ands	r3, r1
	    LENCIVOID(go->neg_accompression) +
 8018766:	18d2      	adds	r2, r2, r3
	    (go->neg_endpoint? CILEN_CHAR + go->endpoint.length: 0));
 8018768:	68bb      	ldr	r3, [r7, #8]
 801876a:	785b      	ldrb	r3, [r3, #1]
 801876c:	2102      	movs	r1, #2
 801876e:	400b      	ands	r3, r1
 8018770:	b2db      	uxtb	r3, r3
 8018772:	2b00      	cmp	r3, #0
 8018774:	d003      	beq.n	801877e <lcp_cilen+0xbe>
 8018776:	68bb      	ldr	r3, [r7, #8]
 8018778:	7b9b      	ldrb	r3, [r3, #14]
 801877a:	3303      	adds	r3, #3
 801877c:	e000      	b.n	8018780 <lcp_cilen+0xc0>
 801877e:	2300      	movs	r3, #0
	    LENCIVOID(go->neg_ssnhf) +
 8018780:	189b      	adds	r3, r3, r2
}
 8018782:	0018      	movs	r0, r3
 8018784:	46bd      	mov	sp, r7
 8018786:	b004      	add	sp, #16
 8018788:	bd80      	pop	{r7, pc}
 801878a:	46c0      	nop			; (mov r8, r8)
 801878c:	000005dc 	.word	0x000005dc

08018790 <lcp_addci>:


/*
 * lcp_addci - Add our desired CIs to a packet.
 */
static void lcp_addci(fsm *f, u_char *ucp, int *lenp) {
 8018790:	b580      	push	{r7, lr}
 8018792:	b088      	sub	sp, #32
 8018794:	af00      	add	r7, sp, #0
 8018796:	60f8      	str	r0, [r7, #12]
 8018798:	60b9      	str	r1, [r7, #8]
 801879a:	607a      	str	r2, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 801879c:	68fb      	ldr	r3, [r7, #12]
 801879e:	681b      	ldr	r3, [r3, #0]
 80187a0:	61bb      	str	r3, [r7, #24]
    lcp_options *go = &pcb->lcp_gotoptions;
 80187a2:	69bb      	ldr	r3, [r7, #24]
 80187a4:	3368      	adds	r3, #104	; 0x68
 80187a6:	617b      	str	r3, [r7, #20]
    u_char *start_ucp = ucp;
 80187a8:	68bb      	ldr	r3, [r7, #8]
 80187aa:	613b      	str	r3, [r7, #16]
	PUTCHAR(class, ucp); \
	for (i = 0; i < len; ++i) \
	    PUTCHAR(val[i], ucp); \
    }

    ADDCISHORT(CI_MRU, go->neg_mru && go->mru != PPP_DEFMRU, go->mru);
 80187ac:	697b      	ldr	r3, [r7, #20]
 80187ae:	781b      	ldrb	r3, [r3, #0]
 80187b0:	2204      	movs	r2, #4
 80187b2:	4013      	ands	r3, r2
 80187b4:	b2db      	uxtb	r3, r3
 80187b6:	2b00      	cmp	r3, #0
 80187b8:	d01e      	beq.n	80187f8 <lcp_addci+0x68>
 80187ba:	697b      	ldr	r3, [r7, #20]
 80187bc:	885b      	ldrh	r3, [r3, #2]
 80187be:	4a84      	ldr	r2, [pc, #528]	; (80189d0 <lcp_addci+0x240>)
 80187c0:	4293      	cmp	r3, r2
 80187c2:	d019      	beq.n	80187f8 <lcp_addci+0x68>
 80187c4:	68bb      	ldr	r3, [r7, #8]
 80187c6:	1c5a      	adds	r2, r3, #1
 80187c8:	60ba      	str	r2, [r7, #8]
 80187ca:	2201      	movs	r2, #1
 80187cc:	701a      	strb	r2, [r3, #0]
 80187ce:	68bb      	ldr	r3, [r7, #8]
 80187d0:	1c5a      	adds	r2, r3, #1
 80187d2:	60ba      	str	r2, [r7, #8]
 80187d4:	2204      	movs	r2, #4
 80187d6:	701a      	strb	r2, [r3, #0]
 80187d8:	697b      	ldr	r3, [r7, #20]
 80187da:	885b      	ldrh	r3, [r3, #2]
 80187dc:	0a1b      	lsrs	r3, r3, #8
 80187de:	b299      	uxth	r1, r3
 80187e0:	68bb      	ldr	r3, [r7, #8]
 80187e2:	1c5a      	adds	r2, r3, #1
 80187e4:	60ba      	str	r2, [r7, #8]
 80187e6:	b2ca      	uxtb	r2, r1
 80187e8:	701a      	strb	r2, [r3, #0]
 80187ea:	697b      	ldr	r3, [r7, #20]
 80187ec:	8859      	ldrh	r1, [r3, #2]
 80187ee:	68bb      	ldr	r3, [r7, #8]
 80187f0:	1c5a      	adds	r2, r3, #1
 80187f2:	60ba      	str	r2, [r7, #8]
 80187f4:	b2ca      	uxtb	r2, r1
 80187f6:	701a      	strb	r2, [r3, #0]
    ADDCILONG(CI_ASYNCMAP, go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF,
 80187f8:	697b      	ldr	r3, [r7, #20]
 80187fa:	781b      	ldrb	r3, [r3, #0]
 80187fc:	2208      	movs	r2, #8
 80187fe:	4013      	ands	r3, r2
 8018800:	b2db      	uxtb	r3, r3
 8018802:	2b00      	cmp	r3, #0
 8018804:	d02c      	beq.n	8018860 <lcp_addci+0xd0>
 8018806:	697b      	ldr	r3, [r7, #20]
 8018808:	685b      	ldr	r3, [r3, #4]
 801880a:	3301      	adds	r3, #1
 801880c:	d028      	beq.n	8018860 <lcp_addci+0xd0>
 801880e:	68bb      	ldr	r3, [r7, #8]
 8018810:	1c5a      	adds	r2, r3, #1
 8018812:	60ba      	str	r2, [r7, #8]
 8018814:	2202      	movs	r2, #2
 8018816:	701a      	strb	r2, [r3, #0]
 8018818:	68bb      	ldr	r3, [r7, #8]
 801881a:	1c5a      	adds	r2, r3, #1
 801881c:	60ba      	str	r2, [r7, #8]
 801881e:	2206      	movs	r2, #6
 8018820:	701a      	strb	r2, [r3, #0]
 8018822:	697b      	ldr	r3, [r7, #20]
 8018824:	685b      	ldr	r3, [r3, #4]
 8018826:	0e19      	lsrs	r1, r3, #24
 8018828:	68bb      	ldr	r3, [r7, #8]
 801882a:	1c5a      	adds	r2, r3, #1
 801882c:	60ba      	str	r2, [r7, #8]
 801882e:	b2ca      	uxtb	r2, r1
 8018830:	701a      	strb	r2, [r3, #0]
 8018832:	697b      	ldr	r3, [r7, #20]
 8018834:	685b      	ldr	r3, [r3, #4]
 8018836:	0c19      	lsrs	r1, r3, #16
 8018838:	68bb      	ldr	r3, [r7, #8]
 801883a:	1c5a      	adds	r2, r3, #1
 801883c:	60ba      	str	r2, [r7, #8]
 801883e:	b2ca      	uxtb	r2, r1
 8018840:	701a      	strb	r2, [r3, #0]
 8018842:	697b      	ldr	r3, [r7, #20]
 8018844:	685b      	ldr	r3, [r3, #4]
 8018846:	0a19      	lsrs	r1, r3, #8
 8018848:	68bb      	ldr	r3, [r7, #8]
 801884a:	1c5a      	adds	r2, r3, #1
 801884c:	60ba      	str	r2, [r7, #8]
 801884e:	b2ca      	uxtb	r2, r1
 8018850:	701a      	strb	r2, [r3, #0]
 8018852:	697b      	ldr	r3, [r7, #20]
 8018854:	6859      	ldr	r1, [r3, #4]
 8018856:	68bb      	ldr	r3, [r7, #8]
 8018858:	1c5a      	adds	r2, r3, #1
 801885a:	60ba      	str	r2, [r7, #8]
 801885c:	b2ca      	uxtb	r2, r1
 801885e:	701a      	strb	r2, [r3, #0]
#endif /* !EAP_SUPPORT && !CHAP_SUPPORT */
#endif /* PAP_SUPPORT */
#if LQR_SUPPORT
    ADDCILQR(CI_QUALITY, go->neg_lqr, go->lqr_period);
#endif /* LQR_SUPPORT */
    ADDCICHAR(CI_CALLBACK, go->neg_cbcp, CBCP_OPT);
 8018860:	697b      	ldr	r3, [r7, #20]
 8018862:	781b      	ldrb	r3, [r3, #0]
 8018864:	227f      	movs	r2, #127	; 0x7f
 8018866:	4393      	bics	r3, r2
 8018868:	b2db      	uxtb	r3, r3
 801886a:	2b00      	cmp	r3, #0
 801886c:	d00e      	beq.n	801888c <lcp_addci+0xfc>
 801886e:	68bb      	ldr	r3, [r7, #8]
 8018870:	1c5a      	adds	r2, r3, #1
 8018872:	60ba      	str	r2, [r7, #8]
 8018874:	220d      	movs	r2, #13
 8018876:	701a      	strb	r2, [r3, #0]
 8018878:	68bb      	ldr	r3, [r7, #8]
 801887a:	1c5a      	adds	r2, r3, #1
 801887c:	60ba      	str	r2, [r7, #8]
 801887e:	2203      	movs	r2, #3
 8018880:	701a      	strb	r2, [r3, #0]
 8018882:	68bb      	ldr	r3, [r7, #8]
 8018884:	1c5a      	adds	r2, r3, #1
 8018886:	60ba      	str	r2, [r7, #8]
 8018888:	2206      	movs	r2, #6
 801888a:	701a      	strb	r2, [r3, #0]
    ADDCILONG(CI_MAGICNUMBER, go->neg_magicnumber, go->magicnumber);
 801888c:	697b      	ldr	r3, [r7, #20]
 801888e:	781b      	ldrb	r3, [r3, #0]
 8018890:	2210      	movs	r2, #16
 8018892:	4013      	ands	r3, r2
 8018894:	b2db      	uxtb	r3, r3
 8018896:	2b00      	cmp	r3, #0
 8018898:	d028      	beq.n	80188ec <lcp_addci+0x15c>
 801889a:	68bb      	ldr	r3, [r7, #8]
 801889c:	1c5a      	adds	r2, r3, #1
 801889e:	60ba      	str	r2, [r7, #8]
 80188a0:	2205      	movs	r2, #5
 80188a2:	701a      	strb	r2, [r3, #0]
 80188a4:	68bb      	ldr	r3, [r7, #8]
 80188a6:	1c5a      	adds	r2, r3, #1
 80188a8:	60ba      	str	r2, [r7, #8]
 80188aa:	2206      	movs	r2, #6
 80188ac:	701a      	strb	r2, [r3, #0]
 80188ae:	697b      	ldr	r3, [r7, #20]
 80188b0:	689b      	ldr	r3, [r3, #8]
 80188b2:	0e19      	lsrs	r1, r3, #24
 80188b4:	68bb      	ldr	r3, [r7, #8]
 80188b6:	1c5a      	adds	r2, r3, #1
 80188b8:	60ba      	str	r2, [r7, #8]
 80188ba:	b2ca      	uxtb	r2, r1
 80188bc:	701a      	strb	r2, [r3, #0]
 80188be:	697b      	ldr	r3, [r7, #20]
 80188c0:	689b      	ldr	r3, [r3, #8]
 80188c2:	0c19      	lsrs	r1, r3, #16
 80188c4:	68bb      	ldr	r3, [r7, #8]
 80188c6:	1c5a      	adds	r2, r3, #1
 80188c8:	60ba      	str	r2, [r7, #8]
 80188ca:	b2ca      	uxtb	r2, r1
 80188cc:	701a      	strb	r2, [r3, #0]
 80188ce:	697b      	ldr	r3, [r7, #20]
 80188d0:	689b      	ldr	r3, [r3, #8]
 80188d2:	0a19      	lsrs	r1, r3, #8
 80188d4:	68bb      	ldr	r3, [r7, #8]
 80188d6:	1c5a      	adds	r2, r3, #1
 80188d8:	60ba      	str	r2, [r7, #8]
 80188da:	b2ca      	uxtb	r2, r1
 80188dc:	701a      	strb	r2, [r3, #0]
 80188de:	697b      	ldr	r3, [r7, #20]
 80188e0:	6899      	ldr	r1, [r3, #8]
 80188e2:	68bb      	ldr	r3, [r7, #8]
 80188e4:	1c5a      	adds	r2, r3, #1
 80188e6:	60ba      	str	r2, [r7, #8]
 80188e8:	b2ca      	uxtb	r2, r1
 80188ea:	701a      	strb	r2, [r3, #0]
    ADDCIVOID(CI_PCOMPRESSION, go->neg_pcompression);
 80188ec:	697b      	ldr	r3, [r7, #20]
 80188ee:	781b      	ldrb	r3, [r3, #0]
 80188f0:	2220      	movs	r2, #32
 80188f2:	4013      	ands	r3, r2
 80188f4:	b2db      	uxtb	r3, r3
 80188f6:	2b00      	cmp	r3, #0
 80188f8:	d009      	beq.n	801890e <lcp_addci+0x17e>
 80188fa:	68bb      	ldr	r3, [r7, #8]
 80188fc:	1c5a      	adds	r2, r3, #1
 80188fe:	60ba      	str	r2, [r7, #8]
 8018900:	2207      	movs	r2, #7
 8018902:	701a      	strb	r2, [r3, #0]
 8018904:	68bb      	ldr	r3, [r7, #8]
 8018906:	1c5a      	adds	r2, r3, #1
 8018908:	60ba      	str	r2, [r7, #8]
 801890a:	2202      	movs	r2, #2
 801890c:	701a      	strb	r2, [r3, #0]
    ADDCIVOID(CI_ACCOMPRESSION, go->neg_accompression);
 801890e:	697b      	ldr	r3, [r7, #20]
 8018910:	781b      	ldrb	r3, [r3, #0]
 8018912:	2240      	movs	r2, #64	; 0x40
 8018914:	4013      	ands	r3, r2
 8018916:	b2db      	uxtb	r3, r3
 8018918:	2b00      	cmp	r3, #0
 801891a:	d009      	beq.n	8018930 <lcp_addci+0x1a0>
 801891c:	68bb      	ldr	r3, [r7, #8]
 801891e:	1c5a      	adds	r2, r3, #1
 8018920:	60ba      	str	r2, [r7, #8]
 8018922:	2208      	movs	r2, #8
 8018924:	701a      	strb	r2, [r3, #0]
 8018926:	68bb      	ldr	r3, [r7, #8]
 8018928:	1c5a      	adds	r2, r3, #1
 801892a:	60ba      	str	r2, [r7, #8]
 801892c:	2202      	movs	r2, #2
 801892e:	701a      	strb	r2, [r3, #0]
#ifdef HAVE_MULTILINK
    ADDCISHORT(CI_MRRU, go->neg_mrru, go->mrru);
#endif
    ADDCIVOID(CI_SSNHF, go->neg_ssnhf);
 8018930:	697b      	ldr	r3, [r7, #20]
 8018932:	785b      	ldrb	r3, [r3, #1]
 8018934:	2201      	movs	r2, #1
 8018936:	4013      	ands	r3, r2
 8018938:	b2db      	uxtb	r3, r3
 801893a:	2b00      	cmp	r3, #0
 801893c:	d009      	beq.n	8018952 <lcp_addci+0x1c2>
 801893e:	68bb      	ldr	r3, [r7, #8]
 8018940:	1c5a      	adds	r2, r3, #1
 8018942:	60ba      	str	r2, [r7, #8]
 8018944:	2212      	movs	r2, #18
 8018946:	701a      	strb	r2, [r3, #0]
 8018948:	68bb      	ldr	r3, [r7, #8]
 801894a:	1c5a      	adds	r2, r3, #1
 801894c:	60ba      	str	r2, [r7, #8]
 801894e:	2202      	movs	r2, #2
 8018950:	701a      	strb	r2, [r3, #0]
    ADDCIENDP(CI_EPDISC, go->neg_endpoint, go->endpoint.class_,
 8018952:	697b      	ldr	r3, [r7, #20]
 8018954:	785b      	ldrb	r3, [r3, #1]
 8018956:	2202      	movs	r2, #2
 8018958:	4013      	ands	r3, r2
 801895a:	b2db      	uxtb	r3, r3
 801895c:	2b00      	cmp	r3, #0
 801895e:	d027      	beq.n	80189b0 <lcp_addci+0x220>
 8018960:	68bb      	ldr	r3, [r7, #8]
 8018962:	1c5a      	adds	r2, r3, #1
 8018964:	60ba      	str	r2, [r7, #8]
 8018966:	2213      	movs	r2, #19
 8018968:	701a      	strb	r2, [r3, #0]
 801896a:	697b      	ldr	r3, [r7, #20]
 801896c:	7b9a      	ldrb	r2, [r3, #14]
 801896e:	68bb      	ldr	r3, [r7, #8]
 8018970:	1c59      	adds	r1, r3, #1
 8018972:	60b9      	str	r1, [r7, #8]
 8018974:	3203      	adds	r2, #3
 8018976:	b2d2      	uxtb	r2, r2
 8018978:	701a      	strb	r2, [r3, #0]
 801897a:	68bb      	ldr	r3, [r7, #8]
 801897c:	1c5a      	adds	r2, r3, #1
 801897e:	60ba      	str	r2, [r7, #8]
 8018980:	697a      	ldr	r2, [r7, #20]
 8018982:	7b52      	ldrb	r2, [r2, #13]
 8018984:	701a      	strb	r2, [r3, #0]
 8018986:	2300      	movs	r3, #0
 8018988:	61fb      	str	r3, [r7, #28]
 801898a:	e00b      	b.n	80189a4 <lcp_addci+0x214>
 801898c:	68bb      	ldr	r3, [r7, #8]
 801898e:	1c5a      	adds	r2, r3, #1
 8018990:	60ba      	str	r2, [r7, #8]
 8018992:	6979      	ldr	r1, [r7, #20]
 8018994:	69fa      	ldr	r2, [r7, #28]
 8018996:	188a      	adds	r2, r1, r2
 8018998:	320f      	adds	r2, #15
 801899a:	7812      	ldrb	r2, [r2, #0]
 801899c:	701a      	strb	r2, [r3, #0]
 801899e:	69fb      	ldr	r3, [r7, #28]
 80189a0:	3301      	adds	r3, #1
 80189a2:	61fb      	str	r3, [r7, #28]
 80189a4:	697b      	ldr	r3, [r7, #20]
 80189a6:	7b9b      	ldrb	r3, [r3, #14]
 80189a8:	001a      	movs	r2, r3
 80189aa:	69fb      	ldr	r3, [r7, #28]
 80189ac:	4293      	cmp	r3, r2
 80189ae:	dbed      	blt.n	801898c <lcp_addci+0x1fc>
	      go->endpoint.value, go->endpoint.length);

    if (ucp - start_ucp != *lenp) {
 80189b0:	68ba      	ldr	r2, [r7, #8]
 80189b2:	693b      	ldr	r3, [r7, #16]
 80189b4:	1ad2      	subs	r2, r2, r3
 80189b6:	687b      	ldr	r3, [r7, #4]
 80189b8:	681b      	ldr	r3, [r3, #0]
 80189ba:	429a      	cmp	r2, r3
 80189bc:	d003      	beq.n	80189c6 <lcp_addci+0x236>
	/* this should never happen, because peer_mtu should be 1500 */
	ppp_error("Bug in lcp_addci: wrong length");
 80189be:	4b05      	ldr	r3, [pc, #20]	; (80189d4 <lcp_addci+0x244>)
 80189c0:	0018      	movs	r0, r3
 80189c2:	f003 fabe 	bl	801bf42 <ppp_error>
    }
}
 80189c6:	46c0      	nop			; (mov r8, r8)
 80189c8:	46bd      	mov	sp, r7
 80189ca:	b008      	add	sp, #32
 80189cc:	bd80      	pop	{r7, pc}
 80189ce:	46c0      	nop			; (mov r8, r8)
 80189d0:	000005dc 	.word	0x000005dc
 80189d4:	080229b8 	.word	0x080229b8

080189d8 <lcp_ackci>:
 *
 * Returns:
 *	0 - Ack was bad.
 *	1 - Ack was good.
 */
static int lcp_ackci(fsm *f, u_char *p, int len) {
 80189d8:	b580      	push	{r7, lr}
 80189da:	b08a      	sub	sp, #40	; 0x28
 80189dc:	af00      	add	r7, sp, #0
 80189de:	60f8      	str	r0, [r7, #12]
 80189e0:	60b9      	str	r1, [r7, #8]
 80189e2:	607a      	str	r2, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 80189e4:	68fb      	ldr	r3, [r7, #12]
 80189e6:	681b      	ldr	r3, [r3, #0]
 80189e8:	623b      	str	r3, [r7, #32]
    lcp_options *go = &pcb->lcp_gotoptions;
 80189ea:	6a3b      	ldr	r3, [r7, #32]
 80189ec:	3368      	adds	r3, #104	; 0x68
 80189ee:	61fb      	str	r3, [r7, #28]
	    if (cichar != val[i]) \
		goto bad; \
	} \
    }

    ACKCISHORT(CI_MRU, go->neg_mru && go->mru != PPP_DEFMRU, go->mru);
 80189f0:	69fb      	ldr	r3, [r7, #28]
 80189f2:	781b      	ldrb	r3, [r3, #0]
 80189f4:	2204      	movs	r2, #4
 80189f6:	4013      	ands	r3, r2
 80189f8:	b2db      	uxtb	r3, r3
 80189fa:	2b00      	cmp	r3, #0
 80189fc:	d03d      	beq.n	8018a7a <lcp_ackci+0xa2>
 80189fe:	69fb      	ldr	r3, [r7, #28]
 8018a00:	885b      	ldrh	r3, [r3, #2]
 8018a02:	4adf      	ldr	r2, [pc, #892]	; (8018d80 <lcp_ackci+0x3a8>)
 8018a04:	4293      	cmp	r3, r2
 8018a06:	d038      	beq.n	8018a7a <lcp_ackci+0xa2>
 8018a08:	687b      	ldr	r3, [r7, #4]
 8018a0a:	3b04      	subs	r3, #4
 8018a0c:	607b      	str	r3, [r7, #4]
 8018a0e:	687b      	ldr	r3, [r7, #4]
 8018a10:	2b00      	cmp	r3, #0
 8018a12:	da00      	bge.n	8018a16 <lcp_ackci+0x3e>
 8018a14:	e1d4      	b.n	8018dc0 <lcp_ackci+0x3e8>
 8018a16:	68bb      	ldr	r3, [r7, #8]
 8018a18:	1c5a      	adds	r2, r3, #1
 8018a1a:	60ba      	str	r2, [r7, #8]
 8018a1c:	211b      	movs	r1, #27
 8018a1e:	187a      	adds	r2, r7, r1
 8018a20:	781b      	ldrb	r3, [r3, #0]
 8018a22:	7013      	strb	r3, [r2, #0]
 8018a24:	68bb      	ldr	r3, [r7, #8]
 8018a26:	1c5a      	adds	r2, r3, #1
 8018a28:	60ba      	str	r2, [r7, #8]
 8018a2a:	201a      	movs	r0, #26
 8018a2c:	183a      	adds	r2, r7, r0
 8018a2e:	781b      	ldrb	r3, [r3, #0]
 8018a30:	7013      	strb	r3, [r2, #0]
 8018a32:	183b      	adds	r3, r7, r0
 8018a34:	781b      	ldrb	r3, [r3, #0]
 8018a36:	2b04      	cmp	r3, #4
 8018a38:	d000      	beq.n	8018a3c <lcp_ackci+0x64>
 8018a3a:	e1c3      	b.n	8018dc4 <lcp_ackci+0x3ec>
 8018a3c:	187b      	adds	r3, r7, r1
 8018a3e:	781b      	ldrb	r3, [r3, #0]
 8018a40:	2b01      	cmp	r3, #1
 8018a42:	d000      	beq.n	8018a46 <lcp_ackci+0x6e>
 8018a44:	e1be      	b.n	8018dc4 <lcp_ackci+0x3ec>
 8018a46:	68bb      	ldr	r3, [r7, #8]
 8018a48:	1c5a      	adds	r2, r3, #1
 8018a4a:	60ba      	str	r2, [r7, #8]
 8018a4c:	781b      	ldrb	r3, [r3, #0]
 8018a4e:	b29a      	uxth	r2, r3
 8018a50:	2018      	movs	r0, #24
 8018a52:	183b      	adds	r3, r7, r0
 8018a54:	0212      	lsls	r2, r2, #8
 8018a56:	801a      	strh	r2, [r3, #0]
 8018a58:	68bb      	ldr	r3, [r7, #8]
 8018a5a:	1c5a      	adds	r2, r3, #1
 8018a5c:	60ba      	str	r2, [r7, #8]
 8018a5e:	781b      	ldrb	r3, [r3, #0]
 8018a60:	b299      	uxth	r1, r3
 8018a62:	183b      	adds	r3, r7, r0
 8018a64:	183a      	adds	r2, r7, r0
 8018a66:	8812      	ldrh	r2, [r2, #0]
 8018a68:	430a      	orrs	r2, r1
 8018a6a:	801a      	strh	r2, [r3, #0]
 8018a6c:	69fb      	ldr	r3, [r7, #28]
 8018a6e:	885b      	ldrh	r3, [r3, #2]
 8018a70:	183a      	adds	r2, r7, r0
 8018a72:	8812      	ldrh	r2, [r2, #0]
 8018a74:	429a      	cmp	r2, r3
 8018a76:	d000      	beq.n	8018a7a <lcp_ackci+0xa2>
 8018a78:	e1a6      	b.n	8018dc8 <lcp_ackci+0x3f0>
    ACKCILONG(CI_ASYNCMAP, go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF,
 8018a7a:	69fb      	ldr	r3, [r7, #28]
 8018a7c:	781b      	ldrb	r3, [r3, #0]
 8018a7e:	2208      	movs	r2, #8
 8018a80:	4013      	ands	r3, r2
 8018a82:	b2db      	uxtb	r3, r3
 8018a84:	2b00      	cmp	r3, #0
 8018a86:	d04c      	beq.n	8018b22 <lcp_ackci+0x14a>
 8018a88:	69fb      	ldr	r3, [r7, #28]
 8018a8a:	685b      	ldr	r3, [r3, #4]
 8018a8c:	3301      	adds	r3, #1
 8018a8e:	d048      	beq.n	8018b22 <lcp_ackci+0x14a>
 8018a90:	687b      	ldr	r3, [r7, #4]
 8018a92:	3b06      	subs	r3, #6
 8018a94:	607b      	str	r3, [r7, #4]
 8018a96:	687b      	ldr	r3, [r7, #4]
 8018a98:	2b00      	cmp	r3, #0
 8018a9a:	da00      	bge.n	8018a9e <lcp_ackci+0xc6>
 8018a9c:	e196      	b.n	8018dcc <lcp_ackci+0x3f4>
 8018a9e:	68bb      	ldr	r3, [r7, #8]
 8018aa0:	1c5a      	adds	r2, r3, #1
 8018aa2:	60ba      	str	r2, [r7, #8]
 8018aa4:	211b      	movs	r1, #27
 8018aa6:	187a      	adds	r2, r7, r1
 8018aa8:	781b      	ldrb	r3, [r3, #0]
 8018aaa:	7013      	strb	r3, [r2, #0]
 8018aac:	68bb      	ldr	r3, [r7, #8]
 8018aae:	1c5a      	adds	r2, r3, #1
 8018ab0:	60ba      	str	r2, [r7, #8]
 8018ab2:	201a      	movs	r0, #26
 8018ab4:	183a      	adds	r2, r7, r0
 8018ab6:	781b      	ldrb	r3, [r3, #0]
 8018ab8:	7013      	strb	r3, [r2, #0]
 8018aba:	183b      	adds	r3, r7, r0
 8018abc:	781b      	ldrb	r3, [r3, #0]
 8018abe:	2b06      	cmp	r3, #6
 8018ac0:	d000      	beq.n	8018ac4 <lcp_ackci+0xec>
 8018ac2:	e185      	b.n	8018dd0 <lcp_ackci+0x3f8>
 8018ac4:	187b      	adds	r3, r7, r1
 8018ac6:	781b      	ldrb	r3, [r3, #0]
 8018ac8:	2b02      	cmp	r3, #2
 8018aca:	d000      	beq.n	8018ace <lcp_ackci+0xf6>
 8018acc:	e180      	b.n	8018dd0 <lcp_ackci+0x3f8>
 8018ace:	68bb      	ldr	r3, [r7, #8]
 8018ad0:	1c5a      	adds	r2, r3, #1
 8018ad2:	60ba      	str	r2, [r7, #8]
 8018ad4:	781b      	ldrb	r3, [r3, #0]
 8018ad6:	021b      	lsls	r3, r3, #8
 8018ad8:	617b      	str	r3, [r7, #20]
 8018ada:	68bb      	ldr	r3, [r7, #8]
 8018adc:	1c5a      	adds	r2, r3, #1
 8018ade:	60ba      	str	r2, [r7, #8]
 8018ae0:	781b      	ldrb	r3, [r3, #0]
 8018ae2:	001a      	movs	r2, r3
 8018ae4:	697b      	ldr	r3, [r7, #20]
 8018ae6:	4313      	orrs	r3, r2
 8018ae8:	617b      	str	r3, [r7, #20]
 8018aea:	697b      	ldr	r3, [r7, #20]
 8018aec:	021b      	lsls	r3, r3, #8
 8018aee:	617b      	str	r3, [r7, #20]
 8018af0:	68bb      	ldr	r3, [r7, #8]
 8018af2:	1c5a      	adds	r2, r3, #1
 8018af4:	60ba      	str	r2, [r7, #8]
 8018af6:	781b      	ldrb	r3, [r3, #0]
 8018af8:	001a      	movs	r2, r3
 8018afa:	697b      	ldr	r3, [r7, #20]
 8018afc:	4313      	orrs	r3, r2
 8018afe:	617b      	str	r3, [r7, #20]
 8018b00:	697b      	ldr	r3, [r7, #20]
 8018b02:	021b      	lsls	r3, r3, #8
 8018b04:	617b      	str	r3, [r7, #20]
 8018b06:	68bb      	ldr	r3, [r7, #8]
 8018b08:	1c5a      	adds	r2, r3, #1
 8018b0a:	60ba      	str	r2, [r7, #8]
 8018b0c:	781b      	ldrb	r3, [r3, #0]
 8018b0e:	001a      	movs	r2, r3
 8018b10:	697b      	ldr	r3, [r7, #20]
 8018b12:	4313      	orrs	r3, r2
 8018b14:	617b      	str	r3, [r7, #20]
 8018b16:	69fb      	ldr	r3, [r7, #28]
 8018b18:	685b      	ldr	r3, [r3, #4]
 8018b1a:	697a      	ldr	r2, [r7, #20]
 8018b1c:	429a      	cmp	r2, r3
 8018b1e:	d000      	beq.n	8018b22 <lcp_ackci+0x14a>
 8018b20:	e158      	b.n	8018dd4 <lcp_ackci+0x3fc>
#endif /* !EAP_SUPPORT && !CHAP_SUPPORT */
#endif /* PAP_SUPPORT */
#if LQR_SUPPORT
    ACKCILQR(CI_QUALITY, go->neg_lqr, go->lqr_period);
#endif /* LQR_SUPPORT */
    ACKCICHAR(CI_CALLBACK, go->neg_cbcp, CBCP_OPT);
 8018b22:	69fb      	ldr	r3, [r7, #28]
 8018b24:	781b      	ldrb	r3, [r3, #0]
 8018b26:	227f      	movs	r2, #127	; 0x7f
 8018b28:	4393      	bics	r3, r2
 8018b2a:	b2db      	uxtb	r3, r3
 8018b2c:	2b00      	cmp	r3, #0
 8018b2e:	d02a      	beq.n	8018b86 <lcp_ackci+0x1ae>
 8018b30:	687b      	ldr	r3, [r7, #4]
 8018b32:	3b03      	subs	r3, #3
 8018b34:	607b      	str	r3, [r7, #4]
 8018b36:	687b      	ldr	r3, [r7, #4]
 8018b38:	2b00      	cmp	r3, #0
 8018b3a:	da00      	bge.n	8018b3e <lcp_ackci+0x166>
 8018b3c:	e14c      	b.n	8018dd8 <lcp_ackci+0x400>
 8018b3e:	68bb      	ldr	r3, [r7, #8]
 8018b40:	1c5a      	adds	r2, r3, #1
 8018b42:	60ba      	str	r2, [r7, #8]
 8018b44:	211b      	movs	r1, #27
 8018b46:	187a      	adds	r2, r7, r1
 8018b48:	781b      	ldrb	r3, [r3, #0]
 8018b4a:	7013      	strb	r3, [r2, #0]
 8018b4c:	68bb      	ldr	r3, [r7, #8]
 8018b4e:	1c5a      	adds	r2, r3, #1
 8018b50:	60ba      	str	r2, [r7, #8]
 8018b52:	201a      	movs	r0, #26
 8018b54:	183a      	adds	r2, r7, r0
 8018b56:	781b      	ldrb	r3, [r3, #0]
 8018b58:	7013      	strb	r3, [r2, #0]
 8018b5a:	183b      	adds	r3, r7, r0
 8018b5c:	781b      	ldrb	r3, [r3, #0]
 8018b5e:	2b03      	cmp	r3, #3
 8018b60:	d000      	beq.n	8018b64 <lcp_ackci+0x18c>
 8018b62:	e13b      	b.n	8018ddc <lcp_ackci+0x404>
 8018b64:	187b      	adds	r3, r7, r1
 8018b66:	781b      	ldrb	r3, [r3, #0]
 8018b68:	2b0d      	cmp	r3, #13
 8018b6a:	d000      	beq.n	8018b6e <lcp_ackci+0x196>
 8018b6c:	e136      	b.n	8018ddc <lcp_ackci+0x404>
 8018b6e:	68bb      	ldr	r3, [r7, #8]
 8018b70:	1c5a      	adds	r2, r3, #1
 8018b72:	60ba      	str	r2, [r7, #8]
 8018b74:	2113      	movs	r1, #19
 8018b76:	187a      	adds	r2, r7, r1
 8018b78:	781b      	ldrb	r3, [r3, #0]
 8018b7a:	7013      	strb	r3, [r2, #0]
 8018b7c:	187b      	adds	r3, r7, r1
 8018b7e:	781b      	ldrb	r3, [r3, #0]
 8018b80:	2b06      	cmp	r3, #6
 8018b82:	d000      	beq.n	8018b86 <lcp_ackci+0x1ae>
 8018b84:	e12c      	b.n	8018de0 <lcp_ackci+0x408>
    ACKCILONG(CI_MAGICNUMBER, go->neg_magicnumber, go->magicnumber);
 8018b86:	69fb      	ldr	r3, [r7, #28]
 8018b88:	781b      	ldrb	r3, [r3, #0]
 8018b8a:	2210      	movs	r2, #16
 8018b8c:	4013      	ands	r3, r2
 8018b8e:	b2db      	uxtb	r3, r3
 8018b90:	2b00      	cmp	r3, #0
 8018b92:	d048      	beq.n	8018c26 <lcp_ackci+0x24e>
 8018b94:	687b      	ldr	r3, [r7, #4]
 8018b96:	3b06      	subs	r3, #6
 8018b98:	607b      	str	r3, [r7, #4]
 8018b9a:	687b      	ldr	r3, [r7, #4]
 8018b9c:	2b00      	cmp	r3, #0
 8018b9e:	da00      	bge.n	8018ba2 <lcp_ackci+0x1ca>
 8018ba0:	e120      	b.n	8018de4 <lcp_ackci+0x40c>
 8018ba2:	68bb      	ldr	r3, [r7, #8]
 8018ba4:	1c5a      	adds	r2, r3, #1
 8018ba6:	60ba      	str	r2, [r7, #8]
 8018ba8:	211b      	movs	r1, #27
 8018baa:	187a      	adds	r2, r7, r1
 8018bac:	781b      	ldrb	r3, [r3, #0]
 8018bae:	7013      	strb	r3, [r2, #0]
 8018bb0:	68bb      	ldr	r3, [r7, #8]
 8018bb2:	1c5a      	adds	r2, r3, #1
 8018bb4:	60ba      	str	r2, [r7, #8]
 8018bb6:	201a      	movs	r0, #26
 8018bb8:	183a      	adds	r2, r7, r0
 8018bba:	781b      	ldrb	r3, [r3, #0]
 8018bbc:	7013      	strb	r3, [r2, #0]
 8018bbe:	183b      	adds	r3, r7, r0
 8018bc0:	781b      	ldrb	r3, [r3, #0]
 8018bc2:	2b06      	cmp	r3, #6
 8018bc4:	d000      	beq.n	8018bc8 <lcp_ackci+0x1f0>
 8018bc6:	e10f      	b.n	8018de8 <lcp_ackci+0x410>
 8018bc8:	187b      	adds	r3, r7, r1
 8018bca:	781b      	ldrb	r3, [r3, #0]
 8018bcc:	2b05      	cmp	r3, #5
 8018bce:	d000      	beq.n	8018bd2 <lcp_ackci+0x1fa>
 8018bd0:	e10a      	b.n	8018de8 <lcp_ackci+0x410>
 8018bd2:	68bb      	ldr	r3, [r7, #8]
 8018bd4:	1c5a      	adds	r2, r3, #1
 8018bd6:	60ba      	str	r2, [r7, #8]
 8018bd8:	781b      	ldrb	r3, [r3, #0]
 8018bda:	021b      	lsls	r3, r3, #8
 8018bdc:	617b      	str	r3, [r7, #20]
 8018bde:	68bb      	ldr	r3, [r7, #8]
 8018be0:	1c5a      	adds	r2, r3, #1
 8018be2:	60ba      	str	r2, [r7, #8]
 8018be4:	781b      	ldrb	r3, [r3, #0]
 8018be6:	001a      	movs	r2, r3
 8018be8:	697b      	ldr	r3, [r7, #20]
 8018bea:	4313      	orrs	r3, r2
 8018bec:	617b      	str	r3, [r7, #20]
 8018bee:	697b      	ldr	r3, [r7, #20]
 8018bf0:	021b      	lsls	r3, r3, #8
 8018bf2:	617b      	str	r3, [r7, #20]
 8018bf4:	68bb      	ldr	r3, [r7, #8]
 8018bf6:	1c5a      	adds	r2, r3, #1
 8018bf8:	60ba      	str	r2, [r7, #8]
 8018bfa:	781b      	ldrb	r3, [r3, #0]
 8018bfc:	001a      	movs	r2, r3
 8018bfe:	697b      	ldr	r3, [r7, #20]
 8018c00:	4313      	orrs	r3, r2
 8018c02:	617b      	str	r3, [r7, #20]
 8018c04:	697b      	ldr	r3, [r7, #20]
 8018c06:	021b      	lsls	r3, r3, #8
 8018c08:	617b      	str	r3, [r7, #20]
 8018c0a:	68bb      	ldr	r3, [r7, #8]
 8018c0c:	1c5a      	adds	r2, r3, #1
 8018c0e:	60ba      	str	r2, [r7, #8]
 8018c10:	781b      	ldrb	r3, [r3, #0]
 8018c12:	001a      	movs	r2, r3
 8018c14:	697b      	ldr	r3, [r7, #20]
 8018c16:	4313      	orrs	r3, r2
 8018c18:	617b      	str	r3, [r7, #20]
 8018c1a:	69fb      	ldr	r3, [r7, #28]
 8018c1c:	689b      	ldr	r3, [r3, #8]
 8018c1e:	697a      	ldr	r2, [r7, #20]
 8018c20:	429a      	cmp	r2, r3
 8018c22:	d000      	beq.n	8018c26 <lcp_ackci+0x24e>
 8018c24:	e0e2      	b.n	8018dec <lcp_ackci+0x414>
    ACKCIVOID(CI_PCOMPRESSION, go->neg_pcompression);
 8018c26:	69fb      	ldr	r3, [r7, #28]
 8018c28:	781b      	ldrb	r3, [r3, #0]
 8018c2a:	2220      	movs	r2, #32
 8018c2c:	4013      	ands	r3, r2
 8018c2e:	b2db      	uxtb	r3, r3
 8018c30:	2b00      	cmp	r3, #0
 8018c32:	d01e      	beq.n	8018c72 <lcp_ackci+0x29a>
 8018c34:	687b      	ldr	r3, [r7, #4]
 8018c36:	3b02      	subs	r3, #2
 8018c38:	607b      	str	r3, [r7, #4]
 8018c3a:	687b      	ldr	r3, [r7, #4]
 8018c3c:	2b00      	cmp	r3, #0
 8018c3e:	da00      	bge.n	8018c42 <lcp_ackci+0x26a>
 8018c40:	e0d6      	b.n	8018df0 <lcp_ackci+0x418>
 8018c42:	68bb      	ldr	r3, [r7, #8]
 8018c44:	1c5a      	adds	r2, r3, #1
 8018c46:	60ba      	str	r2, [r7, #8]
 8018c48:	211b      	movs	r1, #27
 8018c4a:	187a      	adds	r2, r7, r1
 8018c4c:	781b      	ldrb	r3, [r3, #0]
 8018c4e:	7013      	strb	r3, [r2, #0]
 8018c50:	68bb      	ldr	r3, [r7, #8]
 8018c52:	1c5a      	adds	r2, r3, #1
 8018c54:	60ba      	str	r2, [r7, #8]
 8018c56:	201a      	movs	r0, #26
 8018c58:	183a      	adds	r2, r7, r0
 8018c5a:	781b      	ldrb	r3, [r3, #0]
 8018c5c:	7013      	strb	r3, [r2, #0]
 8018c5e:	183b      	adds	r3, r7, r0
 8018c60:	781b      	ldrb	r3, [r3, #0]
 8018c62:	2b02      	cmp	r3, #2
 8018c64:	d000      	beq.n	8018c68 <lcp_ackci+0x290>
 8018c66:	e0c5      	b.n	8018df4 <lcp_ackci+0x41c>
 8018c68:	187b      	adds	r3, r7, r1
 8018c6a:	781b      	ldrb	r3, [r3, #0]
 8018c6c:	2b07      	cmp	r3, #7
 8018c6e:	d000      	beq.n	8018c72 <lcp_ackci+0x29a>
 8018c70:	e0c0      	b.n	8018df4 <lcp_ackci+0x41c>
    ACKCIVOID(CI_ACCOMPRESSION, go->neg_accompression);
 8018c72:	69fb      	ldr	r3, [r7, #28]
 8018c74:	781b      	ldrb	r3, [r3, #0]
 8018c76:	2240      	movs	r2, #64	; 0x40
 8018c78:	4013      	ands	r3, r2
 8018c7a:	b2db      	uxtb	r3, r3
 8018c7c:	2b00      	cmp	r3, #0
 8018c7e:	d01e      	beq.n	8018cbe <lcp_ackci+0x2e6>
 8018c80:	687b      	ldr	r3, [r7, #4]
 8018c82:	3b02      	subs	r3, #2
 8018c84:	607b      	str	r3, [r7, #4]
 8018c86:	687b      	ldr	r3, [r7, #4]
 8018c88:	2b00      	cmp	r3, #0
 8018c8a:	da00      	bge.n	8018c8e <lcp_ackci+0x2b6>
 8018c8c:	e0b4      	b.n	8018df8 <lcp_ackci+0x420>
 8018c8e:	68bb      	ldr	r3, [r7, #8]
 8018c90:	1c5a      	adds	r2, r3, #1
 8018c92:	60ba      	str	r2, [r7, #8]
 8018c94:	211b      	movs	r1, #27
 8018c96:	187a      	adds	r2, r7, r1
 8018c98:	781b      	ldrb	r3, [r3, #0]
 8018c9a:	7013      	strb	r3, [r2, #0]
 8018c9c:	68bb      	ldr	r3, [r7, #8]
 8018c9e:	1c5a      	adds	r2, r3, #1
 8018ca0:	60ba      	str	r2, [r7, #8]
 8018ca2:	201a      	movs	r0, #26
 8018ca4:	183a      	adds	r2, r7, r0
 8018ca6:	781b      	ldrb	r3, [r3, #0]
 8018ca8:	7013      	strb	r3, [r2, #0]
 8018caa:	183b      	adds	r3, r7, r0
 8018cac:	781b      	ldrb	r3, [r3, #0]
 8018cae:	2b02      	cmp	r3, #2
 8018cb0:	d000      	beq.n	8018cb4 <lcp_ackci+0x2dc>
 8018cb2:	e0a3      	b.n	8018dfc <lcp_ackci+0x424>
 8018cb4:	187b      	adds	r3, r7, r1
 8018cb6:	781b      	ldrb	r3, [r3, #0]
 8018cb8:	2b08      	cmp	r3, #8
 8018cba:	d000      	beq.n	8018cbe <lcp_ackci+0x2e6>
 8018cbc:	e09e      	b.n	8018dfc <lcp_ackci+0x424>
#ifdef HAVE_MULTILINK
    ACKCISHORT(CI_MRRU, go->neg_mrru, go->mrru);
#endif /* HAVE_MULTILINK */
    ACKCIVOID(CI_SSNHF, go->neg_ssnhf);
 8018cbe:	69fb      	ldr	r3, [r7, #28]
 8018cc0:	785b      	ldrb	r3, [r3, #1]
 8018cc2:	2201      	movs	r2, #1
 8018cc4:	4013      	ands	r3, r2
 8018cc6:	b2db      	uxtb	r3, r3
 8018cc8:	2b00      	cmp	r3, #0
 8018cca:	d01e      	beq.n	8018d0a <lcp_ackci+0x332>
 8018ccc:	687b      	ldr	r3, [r7, #4]
 8018cce:	3b02      	subs	r3, #2
 8018cd0:	607b      	str	r3, [r7, #4]
 8018cd2:	687b      	ldr	r3, [r7, #4]
 8018cd4:	2b00      	cmp	r3, #0
 8018cd6:	da00      	bge.n	8018cda <lcp_ackci+0x302>
 8018cd8:	e092      	b.n	8018e00 <lcp_ackci+0x428>
 8018cda:	68bb      	ldr	r3, [r7, #8]
 8018cdc:	1c5a      	adds	r2, r3, #1
 8018cde:	60ba      	str	r2, [r7, #8]
 8018ce0:	211b      	movs	r1, #27
 8018ce2:	187a      	adds	r2, r7, r1
 8018ce4:	781b      	ldrb	r3, [r3, #0]
 8018ce6:	7013      	strb	r3, [r2, #0]
 8018ce8:	68bb      	ldr	r3, [r7, #8]
 8018cea:	1c5a      	adds	r2, r3, #1
 8018cec:	60ba      	str	r2, [r7, #8]
 8018cee:	201a      	movs	r0, #26
 8018cf0:	183a      	adds	r2, r7, r0
 8018cf2:	781b      	ldrb	r3, [r3, #0]
 8018cf4:	7013      	strb	r3, [r2, #0]
 8018cf6:	183b      	adds	r3, r7, r0
 8018cf8:	781b      	ldrb	r3, [r3, #0]
 8018cfa:	2b02      	cmp	r3, #2
 8018cfc:	d000      	beq.n	8018d00 <lcp_ackci+0x328>
 8018cfe:	e081      	b.n	8018e04 <lcp_ackci+0x42c>
 8018d00:	187b      	adds	r3, r7, r1
 8018d02:	781b      	ldrb	r3, [r3, #0]
 8018d04:	2b12      	cmp	r3, #18
 8018d06:	d000      	beq.n	8018d0a <lcp_ackci+0x332>
 8018d08:	e07c      	b.n	8018e04 <lcp_ackci+0x42c>
    ACKCIENDP(CI_EPDISC, go->neg_endpoint, go->endpoint.class_,
 8018d0a:	69fb      	ldr	r3, [r7, #28]
 8018d0c:	785b      	ldrb	r3, [r3, #1]
 8018d0e:	2202      	movs	r2, #2
 8018d10:	4013      	ands	r3, r2
 8018d12:	b2db      	uxtb	r3, r3
 8018d14:	2b00      	cmp	r3, #0
 8018d16:	d04e      	beq.n	8018db6 <lcp_ackci+0x3de>
 8018d18:	69fb      	ldr	r3, [r7, #28]
 8018d1a:	7b9b      	ldrb	r3, [r3, #14]
 8018d1c:	3303      	adds	r3, #3
 8018d1e:	687a      	ldr	r2, [r7, #4]
 8018d20:	1ad3      	subs	r3, r2, r3
 8018d22:	607b      	str	r3, [r7, #4]
 8018d24:	687b      	ldr	r3, [r7, #4]
 8018d26:	2b00      	cmp	r3, #0
 8018d28:	da00      	bge.n	8018d2c <lcp_ackci+0x354>
 8018d2a:	e06d      	b.n	8018e08 <lcp_ackci+0x430>
 8018d2c:	68bb      	ldr	r3, [r7, #8]
 8018d2e:	1c5a      	adds	r2, r3, #1
 8018d30:	60ba      	str	r2, [r7, #8]
 8018d32:	211b      	movs	r1, #27
 8018d34:	187a      	adds	r2, r7, r1
 8018d36:	781b      	ldrb	r3, [r3, #0]
 8018d38:	7013      	strb	r3, [r2, #0]
 8018d3a:	68bb      	ldr	r3, [r7, #8]
 8018d3c:	1c5a      	adds	r2, r3, #1
 8018d3e:	60ba      	str	r2, [r7, #8]
 8018d40:	201a      	movs	r0, #26
 8018d42:	183a      	adds	r2, r7, r0
 8018d44:	781b      	ldrb	r3, [r3, #0]
 8018d46:	7013      	strb	r3, [r2, #0]
 8018d48:	183b      	adds	r3, r7, r0
 8018d4a:	781a      	ldrb	r2, [r3, #0]
 8018d4c:	69fb      	ldr	r3, [r7, #28]
 8018d4e:	7b9b      	ldrb	r3, [r3, #14]
 8018d50:	3303      	adds	r3, #3
 8018d52:	429a      	cmp	r2, r3
 8018d54:	d15a      	bne.n	8018e0c <lcp_ackci+0x434>
 8018d56:	187b      	adds	r3, r7, r1
 8018d58:	781b      	ldrb	r3, [r3, #0]
 8018d5a:	2b13      	cmp	r3, #19
 8018d5c:	d156      	bne.n	8018e0c <lcp_ackci+0x434>
 8018d5e:	68bb      	ldr	r3, [r7, #8]
 8018d60:	1c5a      	adds	r2, r3, #1
 8018d62:	60ba      	str	r2, [r7, #8]
 8018d64:	2113      	movs	r1, #19
 8018d66:	187a      	adds	r2, r7, r1
 8018d68:	781b      	ldrb	r3, [r3, #0]
 8018d6a:	7013      	strb	r3, [r2, #0]
 8018d6c:	69fb      	ldr	r3, [r7, #28]
 8018d6e:	7b5b      	ldrb	r3, [r3, #13]
 8018d70:	187a      	adds	r2, r7, r1
 8018d72:	7812      	ldrb	r2, [r2, #0]
 8018d74:	429a      	cmp	r2, r3
 8018d76:	d14b      	bne.n	8018e10 <lcp_ackci+0x438>
 8018d78:	2300      	movs	r3, #0
 8018d7a:	627b      	str	r3, [r7, #36]	; 0x24
 8018d7c:	e015      	b.n	8018daa <lcp_ackci+0x3d2>
 8018d7e:	46c0      	nop			; (mov r8, r8)
 8018d80:	000005dc 	.word	0x000005dc
 8018d84:	68bb      	ldr	r3, [r7, #8]
 8018d86:	1c5a      	adds	r2, r3, #1
 8018d88:	60ba      	str	r2, [r7, #8]
 8018d8a:	2113      	movs	r1, #19
 8018d8c:	187a      	adds	r2, r7, r1
 8018d8e:	781b      	ldrb	r3, [r3, #0]
 8018d90:	7013      	strb	r3, [r2, #0]
 8018d92:	69fa      	ldr	r2, [r7, #28]
 8018d94:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018d96:	18d3      	adds	r3, r2, r3
 8018d98:	330f      	adds	r3, #15
 8018d9a:	781b      	ldrb	r3, [r3, #0]
 8018d9c:	187a      	adds	r2, r7, r1
 8018d9e:	7812      	ldrb	r2, [r2, #0]
 8018da0:	429a      	cmp	r2, r3
 8018da2:	d137      	bne.n	8018e14 <lcp_ackci+0x43c>
 8018da4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018da6:	3301      	adds	r3, #1
 8018da8:	627b      	str	r3, [r7, #36]	; 0x24
 8018daa:	69fb      	ldr	r3, [r7, #28]
 8018dac:	7b9b      	ldrb	r3, [r3, #14]
 8018dae:	001a      	movs	r2, r3
 8018db0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018db2:	4293      	cmp	r3, r2
 8018db4:	dbe6      	blt.n	8018d84 <lcp_ackci+0x3ac>
	      go->endpoint.value, go->endpoint.length);

    /*
     * If there are any remaining CIs, then this packet is bad.
     */
    if (len != 0)
 8018db6:	687b      	ldr	r3, [r7, #4]
 8018db8:	2b00      	cmp	r3, #0
 8018dba:	d12d      	bne.n	8018e18 <lcp_ackci+0x440>
	goto bad;
    return (1);
 8018dbc:	2301      	movs	r3, #1
 8018dbe:	e02d      	b.n	8018e1c <lcp_ackci+0x444>
    ACKCISHORT(CI_MRU, go->neg_mru && go->mru != PPP_DEFMRU, go->mru);
 8018dc0:	46c0      	nop			; (mov r8, r8)
 8018dc2:	e02a      	b.n	8018e1a <lcp_ackci+0x442>
 8018dc4:	46c0      	nop			; (mov r8, r8)
 8018dc6:	e028      	b.n	8018e1a <lcp_ackci+0x442>
 8018dc8:	46c0      	nop			; (mov r8, r8)
 8018dca:	e026      	b.n	8018e1a <lcp_ackci+0x442>
    ACKCILONG(CI_ASYNCMAP, go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF,
 8018dcc:	46c0      	nop			; (mov r8, r8)
 8018dce:	e024      	b.n	8018e1a <lcp_ackci+0x442>
 8018dd0:	46c0      	nop			; (mov r8, r8)
 8018dd2:	e022      	b.n	8018e1a <lcp_ackci+0x442>
 8018dd4:	46c0      	nop			; (mov r8, r8)
 8018dd6:	e020      	b.n	8018e1a <lcp_ackci+0x442>
    ACKCICHAR(CI_CALLBACK, go->neg_cbcp, CBCP_OPT);
 8018dd8:	46c0      	nop			; (mov r8, r8)
 8018dda:	e01e      	b.n	8018e1a <lcp_ackci+0x442>
 8018ddc:	46c0      	nop			; (mov r8, r8)
 8018dde:	e01c      	b.n	8018e1a <lcp_ackci+0x442>
 8018de0:	46c0      	nop			; (mov r8, r8)
 8018de2:	e01a      	b.n	8018e1a <lcp_ackci+0x442>
    ACKCILONG(CI_MAGICNUMBER, go->neg_magicnumber, go->magicnumber);
 8018de4:	46c0      	nop			; (mov r8, r8)
 8018de6:	e018      	b.n	8018e1a <lcp_ackci+0x442>
 8018de8:	46c0      	nop			; (mov r8, r8)
 8018dea:	e016      	b.n	8018e1a <lcp_ackci+0x442>
 8018dec:	46c0      	nop			; (mov r8, r8)
 8018dee:	e014      	b.n	8018e1a <lcp_ackci+0x442>
    ACKCIVOID(CI_PCOMPRESSION, go->neg_pcompression);
 8018df0:	46c0      	nop			; (mov r8, r8)
 8018df2:	e012      	b.n	8018e1a <lcp_ackci+0x442>
 8018df4:	46c0      	nop			; (mov r8, r8)
 8018df6:	e010      	b.n	8018e1a <lcp_ackci+0x442>
    ACKCIVOID(CI_ACCOMPRESSION, go->neg_accompression);
 8018df8:	46c0      	nop			; (mov r8, r8)
 8018dfa:	e00e      	b.n	8018e1a <lcp_ackci+0x442>
 8018dfc:	46c0      	nop			; (mov r8, r8)
 8018dfe:	e00c      	b.n	8018e1a <lcp_ackci+0x442>
    ACKCIVOID(CI_SSNHF, go->neg_ssnhf);
 8018e00:	46c0      	nop			; (mov r8, r8)
 8018e02:	e00a      	b.n	8018e1a <lcp_ackci+0x442>
 8018e04:	46c0      	nop			; (mov r8, r8)
 8018e06:	e008      	b.n	8018e1a <lcp_ackci+0x442>
    ACKCIENDP(CI_EPDISC, go->neg_endpoint, go->endpoint.class_,
 8018e08:	46c0      	nop			; (mov r8, r8)
 8018e0a:	e006      	b.n	8018e1a <lcp_ackci+0x442>
 8018e0c:	46c0      	nop			; (mov r8, r8)
 8018e0e:	e004      	b.n	8018e1a <lcp_ackci+0x442>
 8018e10:	46c0      	nop			; (mov r8, r8)
 8018e12:	e002      	b.n	8018e1a <lcp_ackci+0x442>
 8018e14:	46c0      	nop			; (mov r8, r8)
 8018e16:	e000      	b.n	8018e1a <lcp_ackci+0x442>
	goto bad;
 8018e18:	46c0      	nop			; (mov r8, r8)
bad:
    LCPDEBUG(("lcp_acki: received bad Ack!"));
    return (0);
 8018e1a:	2300      	movs	r3, #0
}
 8018e1c:	0018      	movs	r0, r3
 8018e1e:	46bd      	mov	sp, r7
 8018e20:	b00a      	add	sp, #40	; 0x28
 8018e22:	bd80      	pop	{r7, pc}

08018e24 <lcp_nakci>:
 *
 * Returns:
 *	0 - Nak was bad.
 *	1 - Nak was good.
 */
static int lcp_nakci(fsm *f, u_char *p, int len, int treat_as_reject) {
 8018e24:	b5b0      	push	{r4, r5, r7, lr}
 8018e26:	b0a0      	sub	sp, #128	; 0x80
 8018e28:	af00      	add	r7, sp, #0
 8018e2a:	60f8      	str	r0, [r7, #12]
 8018e2c:	60b9      	str	r1, [r7, #8]
 8018e2e:	607a      	str	r2, [r7, #4]
 8018e30:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 8018e32:	68fb      	ldr	r3, [r7, #12]
 8018e34:	681b      	ldr	r3, [r3, #0]
 8018e36:	67bb      	str	r3, [r7, #120]	; 0x78
    lcp_options *go = &pcb->lcp_gotoptions;
 8018e38:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8018e3a:	3368      	adds	r3, #104	; 0x68
 8018e3c:	677b      	str	r3, [r7, #116]	; 0x74
    lcp_options *wo = &pcb->lcp_wantoptions;
 8018e3e:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8018e40:	3344      	adds	r3, #68	; 0x44
 8018e42:	673b      	str	r3, [r7, #112]	; 0x70
    u_char citype, cichar, *next;
    u_short cishort;
    u32_t cilong;
    lcp_options no;		/* options we've seen Naks for */
    lcp_options try_;		/* options to request next time */
    int looped_back = 0;
 8018e44:	2300      	movs	r3, #0
 8018e46:	67fb      	str	r3, [r7, #124]	; 0x7c
    int cilen;

    BZERO(&no, sizeof(no));
 8018e48:	2438      	movs	r4, #56	; 0x38
 8018e4a:	193b      	adds	r3, r7, r4
 8018e4c:	2224      	movs	r2, #36	; 0x24
 8018e4e:	2100      	movs	r1, #0
 8018e50:	0018      	movs	r0, r3
 8018e52:	f005 f8bf 	bl	801dfd4 <memset>
    try_ = *go;
 8018e56:	2314      	movs	r3, #20
 8018e58:	18fb      	adds	r3, r7, r3
 8018e5a:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8018e5c:	ca23      	ldmia	r2!, {r0, r1, r5}
 8018e5e:	c323      	stmia	r3!, {r0, r1, r5}
 8018e60:	ca23      	ldmia	r2!, {r0, r1, r5}
 8018e62:	c323      	stmia	r3!, {r0, r1, r5}
 8018e64:	ca23      	ldmia	r2!, {r0, r1, r5}
 8018e66:	c323      	stmia	r3!, {r0, r1, r5}
     * we want.  Therefore, accept any MRU less than what we asked for,
     * but then ignore the new value when setting the MRU in the kernel.
     * If they send us a bigger MRU than what we asked, accept it, up to
     * the limit of the default MRU we'd get if we didn't negotiate.
     */
    if (go->neg_mru && go->mru != PPP_DEFMRU) {
 8018e68:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018e6a:	781b      	ldrb	r3, [r3, #0]
 8018e6c:	2204      	movs	r2, #4
 8018e6e:	4013      	ands	r3, r2
 8018e70:	b2db      	uxtb	r3, r3
 8018e72:	2b00      	cmp	r3, #0
 8018e74:	d04a      	beq.n	8018f0c <lcp_nakci+0xe8>
 8018e76:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018e78:	885b      	ldrh	r3, [r3, #2]
 8018e7a:	4a20      	ldr	r2, [pc, #128]	; (8018efc <lcp_nakci+0xd8>)
 8018e7c:	4293      	cmp	r3, r2
 8018e7e:	d045      	beq.n	8018f0c <lcp_nakci+0xe8>
	NAKCISHORT(CI_MRU, neg_mru,
 8018e80:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018e82:	781b      	ldrb	r3, [r3, #0]
 8018e84:	2204      	movs	r2, #4
 8018e86:	4013      	ands	r3, r2
 8018e88:	b2db      	uxtb	r3, r3
 8018e8a:	2b00      	cmp	r3, #0
 8018e8c:	d03e      	beq.n	8018f0c <lcp_nakci+0xe8>
 8018e8e:	687b      	ldr	r3, [r7, #4]
 8018e90:	2b03      	cmp	r3, #3
 8018e92:	dd3b      	ble.n	8018f0c <lcp_nakci+0xe8>
 8018e94:	68bb      	ldr	r3, [r7, #8]
 8018e96:	3301      	adds	r3, #1
 8018e98:	781b      	ldrb	r3, [r3, #0]
 8018e9a:	2b04      	cmp	r3, #4
 8018e9c:	d136      	bne.n	8018f0c <lcp_nakci+0xe8>
 8018e9e:	68bb      	ldr	r3, [r7, #8]
 8018ea0:	781b      	ldrb	r3, [r3, #0]
 8018ea2:	2b01      	cmp	r3, #1
 8018ea4:	d132      	bne.n	8018f0c <lcp_nakci+0xe8>
 8018ea6:	687b      	ldr	r3, [r7, #4]
 8018ea8:	3b04      	subs	r3, #4
 8018eaa:	607b      	str	r3, [r7, #4]
 8018eac:	68bb      	ldr	r3, [r7, #8]
 8018eae:	3302      	adds	r3, #2
 8018eb0:	60bb      	str	r3, [r7, #8]
 8018eb2:	68bb      	ldr	r3, [r7, #8]
 8018eb4:	1c5a      	adds	r2, r3, #1
 8018eb6:	60ba      	str	r2, [r7, #8]
 8018eb8:	781b      	ldrb	r3, [r3, #0]
 8018eba:	b29a      	uxth	r2, r3
 8018ebc:	206e      	movs	r0, #110	; 0x6e
 8018ebe:	183b      	adds	r3, r7, r0
 8018ec0:	0212      	lsls	r2, r2, #8
 8018ec2:	801a      	strh	r2, [r3, #0]
 8018ec4:	68bb      	ldr	r3, [r7, #8]
 8018ec6:	1c5a      	adds	r2, r3, #1
 8018ec8:	60ba      	str	r2, [r7, #8]
 8018eca:	781b      	ldrb	r3, [r3, #0]
 8018ecc:	b299      	uxth	r1, r3
 8018ece:	183b      	adds	r3, r7, r0
 8018ed0:	183a      	adds	r2, r7, r0
 8018ed2:	8812      	ldrh	r2, [r2, #0]
 8018ed4:	430a      	orrs	r2, r1
 8018ed6:	801a      	strh	r2, [r3, #0]
 8018ed8:	193b      	adds	r3, r7, r4
 8018eda:	781a      	ldrb	r2, [r3, #0]
 8018edc:	2104      	movs	r1, #4
 8018ede:	430a      	orrs	r2, r1
 8018ee0:	701a      	strb	r2, [r3, #0]
 8018ee2:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8018ee4:	885b      	ldrh	r3, [r3, #2]
 8018ee6:	183a      	adds	r2, r7, r0
 8018ee8:	8812      	ldrh	r2, [r2, #0]
 8018eea:	429a      	cmp	r2, r3
 8018eec:	d908      	bls.n	8018f00 <lcp_nakci+0xdc>
 8018eee:	183b      	adds	r3, r7, r0
 8018ef0:	881b      	ldrh	r3, [r3, #0]
 8018ef2:	4a02      	ldr	r2, [pc, #8]	; (8018efc <lcp_nakci+0xd8>)
 8018ef4:	4293      	cmp	r3, r2
 8018ef6:	d809      	bhi.n	8018f0c <lcp_nakci+0xe8>
 8018ef8:	e002      	b.n	8018f00 <lcp_nakci+0xdc>
 8018efa:	46c0      	nop			; (mov r8, r8)
 8018efc:	000005dc 	.word	0x000005dc
 8018f00:	2314      	movs	r3, #20
 8018f02:	18fb      	adds	r3, r7, r3
 8018f04:	226e      	movs	r2, #110	; 0x6e
 8018f06:	18ba      	adds	r2, r7, r2
 8018f08:	8812      	ldrh	r2, [r2, #0]
 8018f0a:	805a      	strh	r2, [r3, #2]
    }

    /*
     * Add any characters they want to our (receive-side) asyncmap.
     */
    if (go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF) {
 8018f0c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018f0e:	781b      	ldrb	r3, [r3, #0]
 8018f10:	2208      	movs	r2, #8
 8018f12:	4013      	ands	r3, r2
 8018f14:	b2db      	uxtb	r3, r3
 8018f16:	2b00      	cmp	r3, #0
 8018f18:	d04d      	beq.n	8018fb6 <lcp_nakci+0x192>
 8018f1a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018f1c:	685b      	ldr	r3, [r3, #4]
 8018f1e:	3301      	adds	r3, #1
 8018f20:	d049      	beq.n	8018fb6 <lcp_nakci+0x192>
	NAKCILONG(CI_ASYNCMAP, neg_asyncmap,
 8018f22:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018f24:	781b      	ldrb	r3, [r3, #0]
 8018f26:	2208      	movs	r2, #8
 8018f28:	4013      	ands	r3, r2
 8018f2a:	b2db      	uxtb	r3, r3
 8018f2c:	2b00      	cmp	r3, #0
 8018f2e:	d042      	beq.n	8018fb6 <lcp_nakci+0x192>
 8018f30:	687b      	ldr	r3, [r7, #4]
 8018f32:	2b05      	cmp	r3, #5
 8018f34:	dd3f      	ble.n	8018fb6 <lcp_nakci+0x192>
 8018f36:	68bb      	ldr	r3, [r7, #8]
 8018f38:	3301      	adds	r3, #1
 8018f3a:	781b      	ldrb	r3, [r3, #0]
 8018f3c:	2b06      	cmp	r3, #6
 8018f3e:	d13a      	bne.n	8018fb6 <lcp_nakci+0x192>
 8018f40:	68bb      	ldr	r3, [r7, #8]
 8018f42:	781b      	ldrb	r3, [r3, #0]
 8018f44:	2b02      	cmp	r3, #2
 8018f46:	d136      	bne.n	8018fb6 <lcp_nakci+0x192>
 8018f48:	687b      	ldr	r3, [r7, #4]
 8018f4a:	3b06      	subs	r3, #6
 8018f4c:	607b      	str	r3, [r7, #4]
 8018f4e:	68bb      	ldr	r3, [r7, #8]
 8018f50:	3302      	adds	r3, #2
 8018f52:	60bb      	str	r3, [r7, #8]
 8018f54:	68bb      	ldr	r3, [r7, #8]
 8018f56:	1c5a      	adds	r2, r3, #1
 8018f58:	60ba      	str	r2, [r7, #8]
 8018f5a:	781b      	ldrb	r3, [r3, #0]
 8018f5c:	021b      	lsls	r3, r3, #8
 8018f5e:	66bb      	str	r3, [r7, #104]	; 0x68
 8018f60:	68bb      	ldr	r3, [r7, #8]
 8018f62:	1c5a      	adds	r2, r3, #1
 8018f64:	60ba      	str	r2, [r7, #8]
 8018f66:	781b      	ldrb	r3, [r3, #0]
 8018f68:	001a      	movs	r2, r3
 8018f6a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018f6c:	4313      	orrs	r3, r2
 8018f6e:	66bb      	str	r3, [r7, #104]	; 0x68
 8018f70:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018f72:	021b      	lsls	r3, r3, #8
 8018f74:	66bb      	str	r3, [r7, #104]	; 0x68
 8018f76:	68bb      	ldr	r3, [r7, #8]
 8018f78:	1c5a      	adds	r2, r3, #1
 8018f7a:	60ba      	str	r2, [r7, #8]
 8018f7c:	781b      	ldrb	r3, [r3, #0]
 8018f7e:	001a      	movs	r2, r3
 8018f80:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018f82:	4313      	orrs	r3, r2
 8018f84:	66bb      	str	r3, [r7, #104]	; 0x68
 8018f86:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018f88:	021b      	lsls	r3, r3, #8
 8018f8a:	66bb      	str	r3, [r7, #104]	; 0x68
 8018f8c:	68bb      	ldr	r3, [r7, #8]
 8018f8e:	1c5a      	adds	r2, r3, #1
 8018f90:	60ba      	str	r2, [r7, #8]
 8018f92:	781b      	ldrb	r3, [r3, #0]
 8018f94:	001a      	movs	r2, r3
 8018f96:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018f98:	4313      	orrs	r3, r2
 8018f9a:	66bb      	str	r3, [r7, #104]	; 0x68
 8018f9c:	2338      	movs	r3, #56	; 0x38
 8018f9e:	18fb      	adds	r3, r7, r3
 8018fa0:	781a      	ldrb	r2, [r3, #0]
 8018fa2:	2108      	movs	r1, #8
 8018fa4:	430a      	orrs	r2, r1
 8018fa6:	701a      	strb	r2, [r3, #0]
 8018fa8:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018faa:	685a      	ldr	r2, [r3, #4]
 8018fac:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018fae:	431a      	orrs	r2, r3
 8018fb0:	2314      	movs	r3, #20
 8018fb2:	18fb      	adds	r3, r7, r3
 8018fb4:	605a      	str	r2, [r3, #4]
#endif /* LQR_SUPPORT */

    /*
     * Only implementing CBCP...not the rest of the callback options
     */
    NAKCICHAR(CI_CALLBACK, neg_cbcp,
 8018fb6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018fb8:	781b      	ldrb	r3, [r3, #0]
 8018fba:	227f      	movs	r2, #127	; 0x7f
 8018fbc:	4393      	bics	r3, r2
 8018fbe:	b2db      	uxtb	r3, r3
 8018fc0:	2b00      	cmp	r3, #0
 8018fc2:	d025      	beq.n	8019010 <lcp_nakci+0x1ec>
 8018fc4:	687b      	ldr	r3, [r7, #4]
 8018fc6:	2b02      	cmp	r3, #2
 8018fc8:	dd22      	ble.n	8019010 <lcp_nakci+0x1ec>
 8018fca:	68bb      	ldr	r3, [r7, #8]
 8018fcc:	3301      	adds	r3, #1
 8018fce:	781b      	ldrb	r3, [r3, #0]
 8018fd0:	2b03      	cmp	r3, #3
 8018fd2:	d11d      	bne.n	8019010 <lcp_nakci+0x1ec>
 8018fd4:	68bb      	ldr	r3, [r7, #8]
 8018fd6:	781b      	ldrb	r3, [r3, #0]
 8018fd8:	2b0d      	cmp	r3, #13
 8018fda:	d119      	bne.n	8019010 <lcp_nakci+0x1ec>
 8018fdc:	687b      	ldr	r3, [r7, #4]
 8018fde:	3b03      	subs	r3, #3
 8018fe0:	607b      	str	r3, [r7, #4]
 8018fe2:	68bb      	ldr	r3, [r7, #8]
 8018fe4:	3302      	adds	r3, #2
 8018fe6:	60bb      	str	r3, [r7, #8]
 8018fe8:	68bb      	ldr	r3, [r7, #8]
 8018fea:	1c5a      	adds	r2, r3, #1
 8018fec:	60ba      	str	r2, [r7, #8]
 8018fee:	2267      	movs	r2, #103	; 0x67
 8018ff0:	18ba      	adds	r2, r7, r2
 8018ff2:	781b      	ldrb	r3, [r3, #0]
 8018ff4:	7013      	strb	r3, [r2, #0]
 8018ff6:	2338      	movs	r3, #56	; 0x38
 8018ff8:	18fb      	adds	r3, r7, r3
 8018ffa:	781a      	ldrb	r2, [r3, #0]
 8018ffc:	2180      	movs	r1, #128	; 0x80
 8018ffe:	4249      	negs	r1, r1
 8019000:	430a      	orrs	r2, r1
 8019002:	701a      	strb	r2, [r3, #0]
 8019004:	2314      	movs	r3, #20
 8019006:	18fb      	adds	r3, r7, r3
 8019008:	781a      	ldrb	r2, [r3, #0]
 801900a:	217f      	movs	r1, #127	; 0x7f
 801900c:	400a      	ands	r2, r1
 801900e:	701a      	strb	r2, [r3, #0]
              );

    /*
     * Check for a looped-back line.
     */
    NAKCILONG(CI_MAGICNUMBER, neg_magicnumber,
 8019010:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8019012:	781b      	ldrb	r3, [r3, #0]
 8019014:	2210      	movs	r2, #16
 8019016:	4013      	ands	r3, r2
 8019018:	b2db      	uxtb	r3, r3
 801901a:	2b00      	cmp	r3, #0
 801901c:	d043      	beq.n	80190a6 <lcp_nakci+0x282>
 801901e:	687b      	ldr	r3, [r7, #4]
 8019020:	2b05      	cmp	r3, #5
 8019022:	dd40      	ble.n	80190a6 <lcp_nakci+0x282>
 8019024:	68bb      	ldr	r3, [r7, #8]
 8019026:	3301      	adds	r3, #1
 8019028:	781b      	ldrb	r3, [r3, #0]
 801902a:	2b06      	cmp	r3, #6
 801902c:	d13b      	bne.n	80190a6 <lcp_nakci+0x282>
 801902e:	68bb      	ldr	r3, [r7, #8]
 8019030:	781b      	ldrb	r3, [r3, #0]
 8019032:	2b05      	cmp	r3, #5
 8019034:	d137      	bne.n	80190a6 <lcp_nakci+0x282>
 8019036:	687b      	ldr	r3, [r7, #4]
 8019038:	3b06      	subs	r3, #6
 801903a:	607b      	str	r3, [r7, #4]
 801903c:	68bb      	ldr	r3, [r7, #8]
 801903e:	3302      	adds	r3, #2
 8019040:	60bb      	str	r3, [r7, #8]
 8019042:	68bb      	ldr	r3, [r7, #8]
 8019044:	1c5a      	adds	r2, r3, #1
 8019046:	60ba      	str	r2, [r7, #8]
 8019048:	781b      	ldrb	r3, [r3, #0]
 801904a:	021b      	lsls	r3, r3, #8
 801904c:	66bb      	str	r3, [r7, #104]	; 0x68
 801904e:	68bb      	ldr	r3, [r7, #8]
 8019050:	1c5a      	adds	r2, r3, #1
 8019052:	60ba      	str	r2, [r7, #8]
 8019054:	781b      	ldrb	r3, [r3, #0]
 8019056:	001a      	movs	r2, r3
 8019058:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801905a:	4313      	orrs	r3, r2
 801905c:	66bb      	str	r3, [r7, #104]	; 0x68
 801905e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8019060:	021b      	lsls	r3, r3, #8
 8019062:	66bb      	str	r3, [r7, #104]	; 0x68
 8019064:	68bb      	ldr	r3, [r7, #8]
 8019066:	1c5a      	adds	r2, r3, #1
 8019068:	60ba      	str	r2, [r7, #8]
 801906a:	781b      	ldrb	r3, [r3, #0]
 801906c:	001a      	movs	r2, r3
 801906e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8019070:	4313      	orrs	r3, r2
 8019072:	66bb      	str	r3, [r7, #104]	; 0x68
 8019074:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8019076:	021b      	lsls	r3, r3, #8
 8019078:	66bb      	str	r3, [r7, #104]	; 0x68
 801907a:	68bb      	ldr	r3, [r7, #8]
 801907c:	1c5a      	adds	r2, r3, #1
 801907e:	60ba      	str	r2, [r7, #8]
 8019080:	781b      	ldrb	r3, [r3, #0]
 8019082:	001a      	movs	r2, r3
 8019084:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8019086:	4313      	orrs	r3, r2
 8019088:	66bb      	str	r3, [r7, #104]	; 0x68
 801908a:	2338      	movs	r3, #56	; 0x38
 801908c:	18fb      	adds	r3, r7, r3
 801908e:	781a      	ldrb	r2, [r3, #0]
 8019090:	2110      	movs	r1, #16
 8019092:	430a      	orrs	r2, r1
 8019094:	701a      	strb	r2, [r3, #0]
 8019096:	f001 f92b 	bl	801a2f0 <magic>
 801909a:	0002      	movs	r2, r0
 801909c:	2314      	movs	r3, #20
 801909e:	18fb      	adds	r3, r7, r3
 80190a0:	609a      	str	r2, [r3, #8]
 80190a2:	2301      	movs	r3, #1
 80190a4:	67fb      	str	r3, [r7, #124]	; 0x7c
    /*
     * Peer shouldn't send Nak for protocol compression or
     * address/control compression requests; they should send
     * a Reject instead.  If they send a Nak, treat it as a Reject.
     */
    NAKCIVOID(CI_PCOMPRESSION, neg_pcompression);
 80190a6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80190a8:	781b      	ldrb	r3, [r3, #0]
 80190aa:	2220      	movs	r2, #32
 80190ac:	4013      	ands	r3, r2
 80190ae:	b2db      	uxtb	r3, r3
 80190b0:	2b00      	cmp	r3, #0
 80190b2:	d01d      	beq.n	80190f0 <lcp_nakci+0x2cc>
 80190b4:	687b      	ldr	r3, [r7, #4]
 80190b6:	2b01      	cmp	r3, #1
 80190b8:	dd1a      	ble.n	80190f0 <lcp_nakci+0x2cc>
 80190ba:	68bb      	ldr	r3, [r7, #8]
 80190bc:	3301      	adds	r3, #1
 80190be:	781b      	ldrb	r3, [r3, #0]
 80190c0:	2b02      	cmp	r3, #2
 80190c2:	d115      	bne.n	80190f0 <lcp_nakci+0x2cc>
 80190c4:	68bb      	ldr	r3, [r7, #8]
 80190c6:	781b      	ldrb	r3, [r3, #0]
 80190c8:	2b07      	cmp	r3, #7
 80190ca:	d111      	bne.n	80190f0 <lcp_nakci+0x2cc>
 80190cc:	687b      	ldr	r3, [r7, #4]
 80190ce:	3b02      	subs	r3, #2
 80190d0:	607b      	str	r3, [r7, #4]
 80190d2:	68bb      	ldr	r3, [r7, #8]
 80190d4:	3302      	adds	r3, #2
 80190d6:	60bb      	str	r3, [r7, #8]
 80190d8:	2338      	movs	r3, #56	; 0x38
 80190da:	18fb      	adds	r3, r7, r3
 80190dc:	781a      	ldrb	r2, [r3, #0]
 80190de:	2120      	movs	r1, #32
 80190e0:	430a      	orrs	r2, r1
 80190e2:	701a      	strb	r2, [r3, #0]
 80190e4:	2314      	movs	r3, #20
 80190e6:	18fb      	adds	r3, r7, r3
 80190e8:	781a      	ldrb	r2, [r3, #0]
 80190ea:	2120      	movs	r1, #32
 80190ec:	438a      	bics	r2, r1
 80190ee:	701a      	strb	r2, [r3, #0]
    NAKCIVOID(CI_ACCOMPRESSION, neg_accompression);
 80190f0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80190f2:	781b      	ldrb	r3, [r3, #0]
 80190f4:	2240      	movs	r2, #64	; 0x40
 80190f6:	4013      	ands	r3, r2
 80190f8:	b2db      	uxtb	r3, r3
 80190fa:	2b00      	cmp	r3, #0
 80190fc:	d01d      	beq.n	801913a <lcp_nakci+0x316>
 80190fe:	687b      	ldr	r3, [r7, #4]
 8019100:	2b01      	cmp	r3, #1
 8019102:	dd1a      	ble.n	801913a <lcp_nakci+0x316>
 8019104:	68bb      	ldr	r3, [r7, #8]
 8019106:	3301      	adds	r3, #1
 8019108:	781b      	ldrb	r3, [r3, #0]
 801910a:	2b02      	cmp	r3, #2
 801910c:	d115      	bne.n	801913a <lcp_nakci+0x316>
 801910e:	68bb      	ldr	r3, [r7, #8]
 8019110:	781b      	ldrb	r3, [r3, #0]
 8019112:	2b08      	cmp	r3, #8
 8019114:	d111      	bne.n	801913a <lcp_nakci+0x316>
 8019116:	687b      	ldr	r3, [r7, #4]
 8019118:	3b02      	subs	r3, #2
 801911a:	607b      	str	r3, [r7, #4]
 801911c:	68bb      	ldr	r3, [r7, #8]
 801911e:	3302      	adds	r3, #2
 8019120:	60bb      	str	r3, [r7, #8]
 8019122:	2338      	movs	r3, #56	; 0x38
 8019124:	18fb      	adds	r3, r7, r3
 8019126:	781a      	ldrb	r2, [r3, #0]
 8019128:	2140      	movs	r1, #64	; 0x40
 801912a:	430a      	orrs	r2, r1
 801912c:	701a      	strb	r2, [r3, #0]
 801912e:	2314      	movs	r3, #20
 8019130:	18fb      	adds	r3, r7, r3
 8019132:	781a      	ldrb	r2, [r3, #0]
 8019134:	2140      	movs	r1, #64	; 0x40
 8019136:	438a      	bics	r2, r1
 8019138:	701a      	strb	r2, [r3, #0]

    /*
     * Nak for short sequence numbers shouldn't be sent, treat it
     * like a reject.
     */
    NAKCIVOID(CI_SSNHF, neg_ssnhf);
 801913a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801913c:	785b      	ldrb	r3, [r3, #1]
 801913e:	2201      	movs	r2, #1
 8019140:	4013      	ands	r3, r2
 8019142:	b2db      	uxtb	r3, r3
 8019144:	2b00      	cmp	r3, #0
 8019146:	d01d      	beq.n	8019184 <lcp_nakci+0x360>
 8019148:	687b      	ldr	r3, [r7, #4]
 801914a:	2b01      	cmp	r3, #1
 801914c:	dd1a      	ble.n	8019184 <lcp_nakci+0x360>
 801914e:	68bb      	ldr	r3, [r7, #8]
 8019150:	3301      	adds	r3, #1
 8019152:	781b      	ldrb	r3, [r3, #0]
 8019154:	2b02      	cmp	r3, #2
 8019156:	d115      	bne.n	8019184 <lcp_nakci+0x360>
 8019158:	68bb      	ldr	r3, [r7, #8]
 801915a:	781b      	ldrb	r3, [r3, #0]
 801915c:	2b12      	cmp	r3, #18
 801915e:	d111      	bne.n	8019184 <lcp_nakci+0x360>
 8019160:	687b      	ldr	r3, [r7, #4]
 8019162:	3b02      	subs	r3, #2
 8019164:	607b      	str	r3, [r7, #4]
 8019166:	68bb      	ldr	r3, [r7, #8]
 8019168:	3302      	adds	r3, #2
 801916a:	60bb      	str	r3, [r7, #8]
 801916c:	2338      	movs	r3, #56	; 0x38
 801916e:	18fb      	adds	r3, r7, r3
 8019170:	785a      	ldrb	r2, [r3, #1]
 8019172:	2101      	movs	r1, #1
 8019174:	430a      	orrs	r2, r1
 8019176:	705a      	strb	r2, [r3, #1]
 8019178:	2314      	movs	r3, #20
 801917a:	18fb      	adds	r3, r7, r3
 801917c:	785a      	ldrb	r2, [r3, #1]
 801917e:	2101      	movs	r1, #1
 8019180:	438a      	bics	r2, r1
 8019182:	705a      	strb	r2, [r3, #1]

    /*
     * Nak of the endpoint discriminator option is not permitted,
     * treat it like a reject.
     */
    NAKCIENDP(CI_EPDISC, neg_endpoint);
 8019184:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8019186:	785b      	ldrb	r3, [r3, #1]
 8019188:	2202      	movs	r2, #2
 801918a:	4013      	ands	r3, r2
 801918c:	b2db      	uxtb	r3, r3
 801918e:	2b00      	cmp	r3, #0
 8019190:	d100      	bne.n	8019194 <lcp_nakci+0x370>
 8019192:	e12b      	b.n	80193ec <lcp_nakci+0x5c8>
 8019194:	687b      	ldr	r3, [r7, #4]
 8019196:	2b02      	cmp	r3, #2
 8019198:	dc00      	bgt.n	801919c <lcp_nakci+0x378>
 801919a:	e127      	b.n	80193ec <lcp_nakci+0x5c8>
 801919c:	68bb      	ldr	r3, [r7, #8]
 801919e:	781b      	ldrb	r3, [r3, #0]
 80191a0:	2b13      	cmp	r3, #19
 80191a2:	d000      	beq.n	80191a6 <lcp_nakci+0x382>
 80191a4:	e122      	b.n	80193ec <lcp_nakci+0x5c8>
 80191a6:	68bb      	ldr	r3, [r7, #8]
 80191a8:	3301      	adds	r3, #1
 80191aa:	781b      	ldrb	r3, [r3, #0]
 80191ac:	2b02      	cmp	r3, #2
 80191ae:	d800      	bhi.n	80191b2 <lcp_nakci+0x38e>
 80191b0:	e11c      	b.n	80193ec <lcp_nakci+0x5c8>
 80191b2:	68bb      	ldr	r3, [r7, #8]
 80191b4:	3301      	adds	r3, #1
 80191b6:	781b      	ldrb	r3, [r3, #0]
 80191b8:	001a      	movs	r2, r3
 80191ba:	687b      	ldr	r3, [r7, #4]
 80191bc:	4293      	cmp	r3, r2
 80191be:	da00      	bge.n	80191c2 <lcp_nakci+0x39e>
 80191c0:	e114      	b.n	80193ec <lcp_nakci+0x5c8>
 80191c2:	68bb      	ldr	r3, [r7, #8]
 80191c4:	3301      	adds	r3, #1
 80191c6:	781b      	ldrb	r3, [r3, #0]
 80191c8:	001a      	movs	r2, r3
 80191ca:	687b      	ldr	r3, [r7, #4]
 80191cc:	1a9b      	subs	r3, r3, r2
 80191ce:	607b      	str	r3, [r7, #4]
 80191d0:	68bb      	ldr	r3, [r7, #8]
 80191d2:	3301      	adds	r3, #1
 80191d4:	781b      	ldrb	r3, [r3, #0]
 80191d6:	001a      	movs	r2, r3
 80191d8:	68bb      	ldr	r3, [r7, #8]
 80191da:	189b      	adds	r3, r3, r2
 80191dc:	60bb      	str	r3, [r7, #8]
 80191de:	2338      	movs	r3, #56	; 0x38
 80191e0:	18fb      	adds	r3, r7, r3
 80191e2:	785a      	ldrb	r2, [r3, #1]
 80191e4:	2102      	movs	r1, #2
 80191e6:	430a      	orrs	r2, r1
 80191e8:	705a      	strb	r2, [r3, #1]
 80191ea:	2314      	movs	r3, #20
 80191ec:	18fb      	adds	r3, r7, r3
 80191ee:	785a      	ldrb	r2, [r3, #1]
 80191f0:	2102      	movs	r1, #2
 80191f2:	438a      	bics	r2, r1
 80191f4:	705a      	strb	r2, [r3, #1]
     * For the quality protocol, the Nak means `ask me to send you quality
     * reports', but if we didn't ask for them, we don't want them.
     * An option we don't recognize represents the peer asking to
     * negotiate some option we don't support, so ignore it.
     */
    while (len >= CILEN_VOID) {
 80191f6:	e0f9      	b.n	80193ec <lcp_nakci+0x5c8>
	GETCHAR(citype, p);
 80191f8:	68bb      	ldr	r3, [r7, #8]
 80191fa:	1c5a      	adds	r2, r3, #1
 80191fc:	60ba      	str	r2, [r7, #8]
 80191fe:	2166      	movs	r1, #102	; 0x66
 8019200:	187a      	adds	r2, r7, r1
 8019202:	781b      	ldrb	r3, [r3, #0]
 8019204:	7013      	strb	r3, [r2, #0]
	GETCHAR(cilen, p);
 8019206:	68bb      	ldr	r3, [r7, #8]
 8019208:	1c5a      	adds	r2, r3, #1
 801920a:	60ba      	str	r2, [r7, #8]
 801920c:	781b      	ldrb	r3, [r3, #0]
 801920e:	663b      	str	r3, [r7, #96]	; 0x60
	if (cilen < CILEN_VOID || (len -= cilen) < 0)
 8019210:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8019212:	2b01      	cmp	r3, #1
 8019214:	dc00      	bgt.n	8019218 <lcp_nakci+0x3f4>
 8019216:	e120      	b.n	801945a <lcp_nakci+0x636>
 8019218:	687a      	ldr	r2, [r7, #4]
 801921a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801921c:	1ad3      	subs	r3, r2, r3
 801921e:	607b      	str	r3, [r7, #4]
 8019220:	687b      	ldr	r3, [r7, #4]
 8019222:	2b00      	cmp	r3, #0
 8019224:	da00      	bge.n	8019228 <lcp_nakci+0x404>
 8019226:	e118      	b.n	801945a <lcp_nakci+0x636>
	    goto bad;
	next = p + cilen - 2;
 8019228:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801922a:	3b02      	subs	r3, #2
 801922c:	68ba      	ldr	r2, [r7, #8]
 801922e:	18d3      	adds	r3, r2, r3
 8019230:	65fb      	str	r3, [r7, #92]	; 0x5c

	switch (citype) {
 8019232:	187b      	adds	r3, r7, r1
 8019234:	781b      	ldrb	r3, [r3, #0]
 8019236:	2b13      	cmp	r3, #19
 8019238:	d900      	bls.n	801923c <lcp_nakci+0x418>
 801923a:	e0ca      	b.n	80193d2 <lcp_nakci+0x5ae>
 801923c:	009a      	lsls	r2, r3, #2
 801923e:	4b91      	ldr	r3, [pc, #580]	; (8019484 <lcp_nakci+0x660>)
 8019240:	18d3      	adds	r3, r2, r3
 8019242:	681b      	ldr	r3, [r3, #0]
 8019244:	469f      	mov	pc, r3
	case CI_MRU:
	    if ((go->neg_mru && go->mru != PPP_DEFMRU)
 8019246:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8019248:	781b      	ldrb	r3, [r3, #0]
 801924a:	2204      	movs	r2, #4
 801924c:	4013      	ands	r3, r2
 801924e:	b2db      	uxtb	r3, r3
 8019250:	2b00      	cmp	r3, #0
 8019252:	d005      	beq.n	8019260 <lcp_nakci+0x43c>
 8019254:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8019256:	885b      	ldrh	r3, [r3, #2]
 8019258:	4a8b      	ldr	r2, [pc, #556]	; (8019488 <lcp_nakci+0x664>)
 801925a:	4293      	cmp	r3, r2
 801925c:	d000      	beq.n	8019260 <lcp_nakci+0x43c>
 801925e:	e0fe      	b.n	801945e <lcp_nakci+0x63a>
		|| no.neg_mru || cilen != CILEN_SHORT)
 8019260:	2338      	movs	r3, #56	; 0x38
 8019262:	18fb      	adds	r3, r7, r3
 8019264:	781b      	ldrb	r3, [r3, #0]
 8019266:	2204      	movs	r2, #4
 8019268:	4013      	ands	r3, r2
 801926a:	b2db      	uxtb	r3, r3
 801926c:	2b00      	cmp	r3, #0
 801926e:	d000      	beq.n	8019272 <lcp_nakci+0x44e>
 8019270:	e0f5      	b.n	801945e <lcp_nakci+0x63a>
 8019272:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8019274:	2b04      	cmp	r3, #4
 8019276:	d000      	beq.n	801927a <lcp_nakci+0x456>
 8019278:	e0f1      	b.n	801945e <lcp_nakci+0x63a>
		goto bad;
	    GETSHORT(cishort, p);
 801927a:	68bb      	ldr	r3, [r7, #8]
 801927c:	1c5a      	adds	r2, r3, #1
 801927e:	60ba      	str	r2, [r7, #8]
 8019280:	781b      	ldrb	r3, [r3, #0]
 8019282:	b29a      	uxth	r2, r3
 8019284:	206e      	movs	r0, #110	; 0x6e
 8019286:	183b      	adds	r3, r7, r0
 8019288:	0212      	lsls	r2, r2, #8
 801928a:	801a      	strh	r2, [r3, #0]
 801928c:	68bb      	ldr	r3, [r7, #8]
 801928e:	1c5a      	adds	r2, r3, #1
 8019290:	60ba      	str	r2, [r7, #8]
 8019292:	781b      	ldrb	r3, [r3, #0]
 8019294:	b299      	uxth	r1, r3
 8019296:	183b      	adds	r3, r7, r0
 8019298:	183a      	adds	r2, r7, r0
 801929a:	8812      	ldrh	r2, [r2, #0]
 801929c:	430a      	orrs	r2, r1
 801929e:	801a      	strh	r2, [r3, #0]
	    if (cishort < PPP_DEFMRU) {
 80192a0:	183b      	adds	r3, r7, r0
 80192a2:	881b      	ldrh	r3, [r3, #0]
 80192a4:	4a79      	ldr	r2, [pc, #484]	; (801948c <lcp_nakci+0x668>)
 80192a6:	4293      	cmp	r3, r2
 80192a8:	d900      	bls.n	80192ac <lcp_nakci+0x488>
 80192aa:	e094      	b.n	80193d6 <lcp_nakci+0x5b2>
		try_.neg_mru = 1;
 80192ac:	2414      	movs	r4, #20
 80192ae:	193b      	adds	r3, r7, r4
 80192b0:	781a      	ldrb	r2, [r3, #0]
 80192b2:	2104      	movs	r1, #4
 80192b4:	430a      	orrs	r2, r1
 80192b6:	701a      	strb	r2, [r3, #0]
		try_.mru = cishort;
 80192b8:	193b      	adds	r3, r7, r4
 80192ba:	183a      	adds	r2, r7, r0
 80192bc:	8812      	ldrh	r2, [r2, #0]
 80192be:	805a      	strh	r2, [r3, #2]
	    }
	    break;
 80192c0:	e089      	b.n	80193d6 <lcp_nakci+0x5b2>
	case CI_ASYNCMAP:
	    if ((go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF)
 80192c2:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80192c4:	781b      	ldrb	r3, [r3, #0]
 80192c6:	2208      	movs	r2, #8
 80192c8:	4013      	ands	r3, r2
 80192ca:	b2db      	uxtb	r3, r3
 80192cc:	2b00      	cmp	r3, #0
 80192ce:	d004      	beq.n	80192da <lcp_nakci+0x4b6>
 80192d0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80192d2:	685b      	ldr	r3, [r3, #4]
 80192d4:	3301      	adds	r3, #1
 80192d6:	d000      	beq.n	80192da <lcp_nakci+0x4b6>
 80192d8:	e0c3      	b.n	8019462 <lcp_nakci+0x63e>
		|| no.neg_asyncmap || cilen != CILEN_LONG)
 80192da:	2338      	movs	r3, #56	; 0x38
 80192dc:	18fb      	adds	r3, r7, r3
 80192de:	781b      	ldrb	r3, [r3, #0]
 80192e0:	2208      	movs	r2, #8
 80192e2:	4013      	ands	r3, r2
 80192e4:	b2db      	uxtb	r3, r3
 80192e6:	2b00      	cmp	r3, #0
 80192e8:	d000      	beq.n	80192ec <lcp_nakci+0x4c8>
 80192ea:	e0ba      	b.n	8019462 <lcp_nakci+0x63e>
 80192ec:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80192ee:	2b06      	cmp	r3, #6
 80192f0:	d100      	bne.n	80192f4 <lcp_nakci+0x4d0>
 80192f2:	e072      	b.n	80193da <lcp_nakci+0x5b6>
		goto bad;
 80192f4:	e0b5      	b.n	8019462 <lcp_nakci+0x63e>
#endif /* EAP_SUPPORT */
		)
		goto bad;
	    break;
	case CI_MAGICNUMBER:
	    if (go->neg_magicnumber || no.neg_magicnumber ||
 80192f6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80192f8:	781b      	ldrb	r3, [r3, #0]
 80192fa:	2210      	movs	r2, #16
 80192fc:	4013      	ands	r3, r2
 80192fe:	b2db      	uxtb	r3, r3
 8019300:	2b00      	cmp	r3, #0
 8019302:	d000      	beq.n	8019306 <lcp_nakci+0x4e2>
 8019304:	e0af      	b.n	8019466 <lcp_nakci+0x642>
 8019306:	2338      	movs	r3, #56	; 0x38
 8019308:	18fb      	adds	r3, r7, r3
 801930a:	781b      	ldrb	r3, [r3, #0]
 801930c:	2210      	movs	r2, #16
 801930e:	4013      	ands	r3, r2
 8019310:	b2db      	uxtb	r3, r3
 8019312:	2b00      	cmp	r3, #0
 8019314:	d000      	beq.n	8019318 <lcp_nakci+0x4f4>
 8019316:	e0a6      	b.n	8019466 <lcp_nakci+0x642>
 8019318:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801931a:	2b06      	cmp	r3, #6
 801931c:	d05f      	beq.n	80193de <lcp_nakci+0x5ba>
		cilen != CILEN_LONG)
		goto bad;
 801931e:	e0a2      	b.n	8019466 <lcp_nakci+0x642>
	    break;
	case CI_PCOMPRESSION:
	    if (go->neg_pcompression || no.neg_pcompression
 8019320:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8019322:	781b      	ldrb	r3, [r3, #0]
 8019324:	2220      	movs	r2, #32
 8019326:	4013      	ands	r3, r2
 8019328:	b2db      	uxtb	r3, r3
 801932a:	2b00      	cmp	r3, #0
 801932c:	d000      	beq.n	8019330 <lcp_nakci+0x50c>
 801932e:	e09c      	b.n	801946a <lcp_nakci+0x646>
 8019330:	2338      	movs	r3, #56	; 0x38
 8019332:	18fb      	adds	r3, r7, r3
 8019334:	781b      	ldrb	r3, [r3, #0]
 8019336:	2220      	movs	r2, #32
 8019338:	4013      	ands	r3, r2
 801933a:	b2db      	uxtb	r3, r3
 801933c:	2b00      	cmp	r3, #0
 801933e:	d000      	beq.n	8019342 <lcp_nakci+0x51e>
 8019340:	e093      	b.n	801946a <lcp_nakci+0x646>
		|| cilen != CILEN_VOID)
 8019342:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8019344:	2b02      	cmp	r3, #2
 8019346:	d04c      	beq.n	80193e2 <lcp_nakci+0x5be>
		goto bad;
 8019348:	e08f      	b.n	801946a <lcp_nakci+0x646>
	    break;
	case CI_ACCOMPRESSION:
	    if (go->neg_accompression || no.neg_accompression
 801934a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801934c:	781b      	ldrb	r3, [r3, #0]
 801934e:	2240      	movs	r2, #64	; 0x40
 8019350:	4013      	ands	r3, r2
 8019352:	b2db      	uxtb	r3, r3
 8019354:	2b00      	cmp	r3, #0
 8019356:	d000      	beq.n	801935a <lcp_nakci+0x536>
 8019358:	e089      	b.n	801946e <lcp_nakci+0x64a>
 801935a:	2338      	movs	r3, #56	; 0x38
 801935c:	18fb      	adds	r3, r7, r3
 801935e:	781b      	ldrb	r3, [r3, #0]
 8019360:	2240      	movs	r2, #64	; 0x40
 8019362:	4013      	ands	r3, r2
 8019364:	b2db      	uxtb	r3, r3
 8019366:	2b00      	cmp	r3, #0
 8019368:	d000      	beq.n	801936c <lcp_nakci+0x548>
 801936a:	e080      	b.n	801946e <lcp_nakci+0x64a>
		|| cilen != CILEN_VOID)
 801936c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801936e:	2b02      	cmp	r3, #2
 8019370:	d039      	beq.n	80193e6 <lcp_nakci+0x5c2>
		goto bad;
 8019372:	e07c      	b.n	801946e <lcp_nakci+0x64a>
	    if (go->neg_mrru || no.neg_mrru || cilen != CILEN_SHORT)
		goto bad;
	    break;
#endif /* HAVE_MULTILINK */
	case CI_SSNHF:
	    if (go->neg_ssnhf || no.neg_ssnhf || cilen != CILEN_VOID)
 8019374:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8019376:	785b      	ldrb	r3, [r3, #1]
 8019378:	2201      	movs	r2, #1
 801937a:	4013      	ands	r3, r2
 801937c:	b2db      	uxtb	r3, r3
 801937e:	2b00      	cmp	r3, #0
 8019380:	d000      	beq.n	8019384 <lcp_nakci+0x560>
 8019382:	e076      	b.n	8019472 <lcp_nakci+0x64e>
 8019384:	2338      	movs	r3, #56	; 0x38
 8019386:	18fb      	adds	r3, r7, r3
 8019388:	785b      	ldrb	r3, [r3, #1]
 801938a:	2201      	movs	r2, #1
 801938c:	4013      	ands	r3, r2
 801938e:	b2db      	uxtb	r3, r3
 8019390:	2b00      	cmp	r3, #0
 8019392:	d000      	beq.n	8019396 <lcp_nakci+0x572>
 8019394:	e06d      	b.n	8019472 <lcp_nakci+0x64e>
 8019396:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8019398:	2b02      	cmp	r3, #2
 801939a:	d000      	beq.n	801939e <lcp_nakci+0x57a>
 801939c:	e069      	b.n	8019472 <lcp_nakci+0x64e>
		goto bad;
	    try_.neg_ssnhf = 1;
 801939e:	2314      	movs	r3, #20
 80193a0:	18fb      	adds	r3, r7, r3
 80193a2:	785a      	ldrb	r2, [r3, #1]
 80193a4:	2101      	movs	r1, #1
 80193a6:	430a      	orrs	r2, r1
 80193a8:	705a      	strb	r2, [r3, #1]
	    break;
 80193aa:	e01d      	b.n	80193e8 <lcp_nakci+0x5c4>
	case CI_EPDISC:
	    if (go->neg_endpoint || no.neg_endpoint || cilen < CILEN_CHAR)
 80193ac:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80193ae:	785b      	ldrb	r3, [r3, #1]
 80193b0:	2202      	movs	r2, #2
 80193b2:	4013      	ands	r3, r2
 80193b4:	b2db      	uxtb	r3, r3
 80193b6:	2b00      	cmp	r3, #0
 80193b8:	d15d      	bne.n	8019476 <lcp_nakci+0x652>
 80193ba:	2338      	movs	r3, #56	; 0x38
 80193bc:	18fb      	adds	r3, r7, r3
 80193be:	785b      	ldrb	r3, [r3, #1]
 80193c0:	2202      	movs	r2, #2
 80193c2:	4013      	ands	r3, r2
 80193c4:	b2db      	uxtb	r3, r3
 80193c6:	2b00      	cmp	r3, #0
 80193c8:	d155      	bne.n	8019476 <lcp_nakci+0x652>
 80193ca:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80193cc:	2b02      	cmp	r3, #2
 80193ce:	dd52      	ble.n	8019476 <lcp_nakci+0x652>
		goto bad;
	    break;
 80193d0:	e00a      	b.n	80193e8 <lcp_nakci+0x5c4>
	default:
	    break;
 80193d2:	46c0      	nop			; (mov r8, r8)
 80193d4:	e008      	b.n	80193e8 <lcp_nakci+0x5c4>
	    break;
 80193d6:	46c0      	nop			; (mov r8, r8)
 80193d8:	e006      	b.n	80193e8 <lcp_nakci+0x5c4>
	    break;
 80193da:	46c0      	nop			; (mov r8, r8)
 80193dc:	e004      	b.n	80193e8 <lcp_nakci+0x5c4>
	    break;
 80193de:	46c0      	nop			; (mov r8, r8)
 80193e0:	e002      	b.n	80193e8 <lcp_nakci+0x5c4>
	    break;
 80193e2:	46c0      	nop			; (mov r8, r8)
 80193e4:	e000      	b.n	80193e8 <lcp_nakci+0x5c4>
	    break;
 80193e6:	46c0      	nop			; (mov r8, r8)
	}
	p = next;
 80193e8:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80193ea:	60bb      	str	r3, [r7, #8]
    while (len >= CILEN_VOID) {
 80193ec:	687b      	ldr	r3, [r7, #4]
 80193ee:	2b01      	cmp	r3, #1
 80193f0:	dd00      	ble.n	80193f4 <lcp_nakci+0x5d0>
 80193f2:	e701      	b.n	80191f8 <lcp_nakci+0x3d4>

    /*
     * OK, the Nak is good.  Now we can update state.
     * If there are any options left we ignore them.
     */
    if (f->state != PPP_FSM_OPENED) {
 80193f4:	68fb      	ldr	r3, [r7, #12]
 80193f6:	7c1b      	ldrb	r3, [r3, #16]
 80193f8:	2b09      	cmp	r3, #9
 80193fa:	d02c      	beq.n	8019456 <lcp_nakci+0x632>
	if (looped_back) {
 80193fc:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 80193fe:	2b00      	cmp	r3, #0
 8019400:	d01c      	beq.n	801943c <lcp_nakci+0x618>
	    if (++try_.numloops >= pcb->settings.lcp_loopbackfail) {
 8019402:	2114      	movs	r1, #20
 8019404:	187b      	adds	r3, r7, r1
 8019406:	7b1b      	ldrb	r3, [r3, #12]
 8019408:	3301      	adds	r3, #1
 801940a:	b2da      	uxtb	r2, r3
 801940c:	187b      	adds	r3, r7, r1
 801940e:	731a      	strb	r2, [r3, #12]
 8019410:	187b      	adds	r3, r7, r1
 8019412:	7b1a      	ldrb	r2, [r3, #12]
 8019414:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8019416:	7a1b      	ldrb	r3, [r3, #8]
 8019418:	429a      	cmp	r2, r3
 801941a:	d313      	bcc.n	8019444 <lcp_nakci+0x620>
		ppp_notice("Serial line is looped back.");
 801941c:	4b1c      	ldr	r3, [pc, #112]	; (8019490 <lcp_nakci+0x66c>)
 801941e:	0018      	movs	r0, r3
 8019420:	f002 fdb7 	bl	801bf92 <ppp_notice>
		pcb->err_code = PPPERR_LOOPBACK;
 8019424:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8019426:	2225      	movs	r2, #37	; 0x25
 8019428:	210c      	movs	r1, #12
 801942a:	5499      	strb	r1, [r3, r2]
		lcp_close(f->pcb, "Loopback detected");
 801942c:	68fb      	ldr	r3, [r7, #12]
 801942e:	681b      	ldr	r3, [r3, #0]
 8019430:	4a18      	ldr	r2, [pc, #96]	; (8019494 <lcp_nakci+0x670>)
 8019432:	0011      	movs	r1, r2
 8019434:	0018      	movs	r0, r3
 8019436:	f7fe ff03 	bl	8018240 <lcp_close>
 801943a:	e003      	b.n	8019444 <lcp_nakci+0x620>
	    }
	} else
	    try_.numloops = 0;
 801943c:	2314      	movs	r3, #20
 801943e:	18fb      	adds	r3, r7, r3
 8019440:	2200      	movs	r2, #0
 8019442:	731a      	strb	r2, [r3, #12]
	*go = try_;
 8019444:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8019446:	2214      	movs	r2, #20
 8019448:	18ba      	adds	r2, r7, r2
 801944a:	ca13      	ldmia	r2!, {r0, r1, r4}
 801944c:	c313      	stmia	r3!, {r0, r1, r4}
 801944e:	ca13      	ldmia	r2!, {r0, r1, r4}
 8019450:	c313      	stmia	r3!, {r0, r1, r4}
 8019452:	ca13      	ldmia	r2!, {r0, r1, r4}
 8019454:	c313      	stmia	r3!, {r0, r1, r4}
    }

    return 1;
 8019456:	2301      	movs	r3, #1
 8019458:	e00f      	b.n	801947a <lcp_nakci+0x656>
	    goto bad;
 801945a:	46c0      	nop			; (mov r8, r8)
 801945c:	e00c      	b.n	8019478 <lcp_nakci+0x654>
		goto bad;
 801945e:	46c0      	nop			; (mov r8, r8)
 8019460:	e00a      	b.n	8019478 <lcp_nakci+0x654>
		goto bad;
 8019462:	46c0      	nop			; (mov r8, r8)
 8019464:	e008      	b.n	8019478 <lcp_nakci+0x654>
		goto bad;
 8019466:	46c0      	nop			; (mov r8, r8)
 8019468:	e006      	b.n	8019478 <lcp_nakci+0x654>
		goto bad;
 801946a:	46c0      	nop			; (mov r8, r8)
 801946c:	e004      	b.n	8019478 <lcp_nakci+0x654>
		goto bad;
 801946e:	46c0      	nop			; (mov r8, r8)
 8019470:	e002      	b.n	8019478 <lcp_nakci+0x654>
		goto bad;
 8019472:	46c0      	nop			; (mov r8, r8)
 8019474:	e000      	b.n	8019478 <lcp_nakci+0x654>
		goto bad;
 8019476:	46c0      	nop			; (mov r8, r8)

bad:
    LCPDEBUG(("lcp_nakci: received bad Nak!"));
    return 0;
 8019478:	2300      	movs	r3, #0
}
 801947a:	0018      	movs	r0, r3
 801947c:	46bd      	mov	sp, r7
 801947e:	b020      	add	sp, #128	; 0x80
 8019480:	bdb0      	pop	{r4, r5, r7, pc}
 8019482:	46c0      	nop			; (mov r8, r8)
 8019484:	08023c48 	.word	0x08023c48
 8019488:	000005dc 	.word	0x000005dc
 801948c:	000005db 	.word	0x000005db
 8019490:	080229d8 	.word	0x080229d8
 8019494:	080229f4 	.word	0x080229f4

08019498 <lcp_rejci>:
 *
 * Returns:
 *	0 - Reject was bad.
 *	1 - Reject was good.
 */
static int lcp_rejci(fsm *f, u_char *p, int len) {
 8019498:	b5b0      	push	{r4, r5, r7, lr}
 801949a:	b094      	sub	sp, #80	; 0x50
 801949c:	af00      	add	r7, sp, #0
 801949e:	60f8      	str	r0, [r7, #12]
 80194a0:	60b9      	str	r1, [r7, #8]
 80194a2:	607a      	str	r2, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 80194a4:	68fb      	ldr	r3, [r7, #12]
 80194a6:	681b      	ldr	r3, [r3, #0]
 80194a8:	64bb      	str	r3, [r7, #72]	; 0x48
    lcp_options *go = &pcb->lcp_gotoptions;
 80194aa:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80194ac:	3368      	adds	r3, #104	; 0x68
 80194ae:	647b      	str	r3, [r7, #68]	; 0x44
    u_char cichar;
    u_short cishort;
    u32_t cilong;
    lcp_options try_;		/* options to request next time */

    try_ = *go;
 80194b0:	2414      	movs	r4, #20
 80194b2:	193b      	adds	r3, r7, r4
 80194b4:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80194b6:	ca23      	ldmia	r2!, {r0, r1, r5}
 80194b8:	c323      	stmia	r3!, {r0, r1, r5}
 80194ba:	ca23      	ldmia	r2!, {r0, r1, r5}
 80194bc:	c323      	stmia	r3!, {r0, r1, r5}
 80194be:	ca23      	ldmia	r2!, {r0, r1, r5}
 80194c0:	c323      	stmia	r3!, {r0, r1, r5}
		goto bad; \
	} \
	try_.neg = 0; \
    }

    REJCISHORT(CI_MRU, neg_mru, go->mru);
 80194c2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80194c4:	781b      	ldrb	r3, [r3, #0]
 80194c6:	2204      	movs	r2, #4
 80194c8:	4013      	ands	r3, r2
 80194ca:	b2db      	uxtb	r3, r3
 80194cc:	2b00      	cmp	r3, #0
 80194ce:	d030      	beq.n	8019532 <lcp_rejci+0x9a>
 80194d0:	687b      	ldr	r3, [r7, #4]
 80194d2:	2b03      	cmp	r3, #3
 80194d4:	dd2d      	ble.n	8019532 <lcp_rejci+0x9a>
 80194d6:	68bb      	ldr	r3, [r7, #8]
 80194d8:	3301      	adds	r3, #1
 80194da:	781b      	ldrb	r3, [r3, #0]
 80194dc:	2b04      	cmp	r3, #4
 80194de:	d128      	bne.n	8019532 <lcp_rejci+0x9a>
 80194e0:	68bb      	ldr	r3, [r7, #8]
 80194e2:	781b      	ldrb	r3, [r3, #0]
 80194e4:	2b01      	cmp	r3, #1
 80194e6:	d124      	bne.n	8019532 <lcp_rejci+0x9a>
 80194e8:	687b      	ldr	r3, [r7, #4]
 80194ea:	3b04      	subs	r3, #4
 80194ec:	607b      	str	r3, [r7, #4]
 80194ee:	68bb      	ldr	r3, [r7, #8]
 80194f0:	3302      	adds	r3, #2
 80194f2:	60bb      	str	r3, [r7, #8]
 80194f4:	68bb      	ldr	r3, [r7, #8]
 80194f6:	1c5a      	adds	r2, r3, #1
 80194f8:	60ba      	str	r2, [r7, #8]
 80194fa:	781b      	ldrb	r3, [r3, #0]
 80194fc:	b29a      	uxth	r2, r3
 80194fe:	2042      	movs	r0, #66	; 0x42
 8019500:	183b      	adds	r3, r7, r0
 8019502:	0212      	lsls	r2, r2, #8
 8019504:	801a      	strh	r2, [r3, #0]
 8019506:	68bb      	ldr	r3, [r7, #8]
 8019508:	1c5a      	adds	r2, r3, #1
 801950a:	60ba      	str	r2, [r7, #8]
 801950c:	781b      	ldrb	r3, [r3, #0]
 801950e:	b299      	uxth	r1, r3
 8019510:	183b      	adds	r3, r7, r0
 8019512:	183a      	adds	r2, r7, r0
 8019514:	8812      	ldrh	r2, [r2, #0]
 8019516:	430a      	orrs	r2, r1
 8019518:	801a      	strh	r2, [r3, #0]
 801951a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801951c:	885b      	ldrh	r3, [r3, #2]
 801951e:	183a      	adds	r2, r7, r0
 8019520:	8812      	ldrh	r2, [r2, #0]
 8019522:	429a      	cmp	r2, r3
 8019524:	d000      	beq.n	8019528 <lcp_rejci+0x90>
 8019526:	e182      	b.n	801982e <lcp_rejci+0x396>
 8019528:	193b      	adds	r3, r7, r4
 801952a:	781a      	ldrb	r2, [r3, #0]
 801952c:	2104      	movs	r1, #4
 801952e:	438a      	bics	r2, r1
 8019530:	701a      	strb	r2, [r3, #0]
    REJCILONG(CI_ASYNCMAP, neg_asyncmap, go->asyncmap);
 8019532:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8019534:	781b      	ldrb	r3, [r3, #0]
 8019536:	2208      	movs	r2, #8
 8019538:	4013      	ands	r3, r2
 801953a:	b2db      	uxtb	r3, r3
 801953c:	2b00      	cmp	r3, #0
 801953e:	d041      	beq.n	80195c4 <lcp_rejci+0x12c>
 8019540:	687b      	ldr	r3, [r7, #4]
 8019542:	2b05      	cmp	r3, #5
 8019544:	dd3e      	ble.n	80195c4 <lcp_rejci+0x12c>
 8019546:	68bb      	ldr	r3, [r7, #8]
 8019548:	3301      	adds	r3, #1
 801954a:	781b      	ldrb	r3, [r3, #0]
 801954c:	2b06      	cmp	r3, #6
 801954e:	d139      	bne.n	80195c4 <lcp_rejci+0x12c>
 8019550:	68bb      	ldr	r3, [r7, #8]
 8019552:	781b      	ldrb	r3, [r3, #0]
 8019554:	2b02      	cmp	r3, #2
 8019556:	d135      	bne.n	80195c4 <lcp_rejci+0x12c>
 8019558:	687b      	ldr	r3, [r7, #4]
 801955a:	3b06      	subs	r3, #6
 801955c:	607b      	str	r3, [r7, #4]
 801955e:	68bb      	ldr	r3, [r7, #8]
 8019560:	3302      	adds	r3, #2
 8019562:	60bb      	str	r3, [r7, #8]
 8019564:	68bb      	ldr	r3, [r7, #8]
 8019566:	1c5a      	adds	r2, r3, #1
 8019568:	60ba      	str	r2, [r7, #8]
 801956a:	781b      	ldrb	r3, [r3, #0]
 801956c:	021b      	lsls	r3, r3, #8
 801956e:	63fb      	str	r3, [r7, #60]	; 0x3c
 8019570:	68bb      	ldr	r3, [r7, #8]
 8019572:	1c5a      	adds	r2, r3, #1
 8019574:	60ba      	str	r2, [r7, #8]
 8019576:	781b      	ldrb	r3, [r3, #0]
 8019578:	001a      	movs	r2, r3
 801957a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801957c:	4313      	orrs	r3, r2
 801957e:	63fb      	str	r3, [r7, #60]	; 0x3c
 8019580:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8019582:	021b      	lsls	r3, r3, #8
 8019584:	63fb      	str	r3, [r7, #60]	; 0x3c
 8019586:	68bb      	ldr	r3, [r7, #8]
 8019588:	1c5a      	adds	r2, r3, #1
 801958a:	60ba      	str	r2, [r7, #8]
 801958c:	781b      	ldrb	r3, [r3, #0]
 801958e:	001a      	movs	r2, r3
 8019590:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8019592:	4313      	orrs	r3, r2
 8019594:	63fb      	str	r3, [r7, #60]	; 0x3c
 8019596:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8019598:	021b      	lsls	r3, r3, #8
 801959a:	63fb      	str	r3, [r7, #60]	; 0x3c
 801959c:	68bb      	ldr	r3, [r7, #8]
 801959e:	1c5a      	adds	r2, r3, #1
 80195a0:	60ba      	str	r2, [r7, #8]
 80195a2:	781b      	ldrb	r3, [r3, #0]
 80195a4:	001a      	movs	r2, r3
 80195a6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80195a8:	4313      	orrs	r3, r2
 80195aa:	63fb      	str	r3, [r7, #60]	; 0x3c
 80195ac:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80195ae:	685b      	ldr	r3, [r3, #4]
 80195b0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80195b2:	429a      	cmp	r2, r3
 80195b4:	d000      	beq.n	80195b8 <lcp_rejci+0x120>
 80195b6:	e13c      	b.n	8019832 <lcp_rejci+0x39a>
 80195b8:	2314      	movs	r3, #20
 80195ba:	18fb      	adds	r3, r7, r3
 80195bc:	781a      	ldrb	r2, [r3, #0]
 80195be:	2108      	movs	r1, #8
 80195c0:	438a      	bics	r2, r1
 80195c2:	701a      	strb	r2, [r3, #0]
    }
#endif /* EAP_SUPPORT */
#if LQR_SUPPORT
    REJCILQR(CI_QUALITY, neg_lqr, go->lqr_period);
#endif /* LQR_SUPPORT */
    REJCICBCP(CI_CALLBACK, neg_cbcp, CBCP_OPT);
 80195c4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80195c6:	781b      	ldrb	r3, [r3, #0]
 80195c8:	227f      	movs	r2, #127	; 0x7f
 80195ca:	4393      	bics	r3, r2
 80195cc:	b2db      	uxtb	r3, r3
 80195ce:	2b00      	cmp	r3, #0
 80195d0:	d023      	beq.n	801961a <lcp_rejci+0x182>
 80195d2:	687b      	ldr	r3, [r7, #4]
 80195d4:	2b02      	cmp	r3, #2
 80195d6:	dd20      	ble.n	801961a <lcp_rejci+0x182>
 80195d8:	68bb      	ldr	r3, [r7, #8]
 80195da:	3301      	adds	r3, #1
 80195dc:	781b      	ldrb	r3, [r3, #0]
 80195de:	2b03      	cmp	r3, #3
 80195e0:	d11b      	bne.n	801961a <lcp_rejci+0x182>
 80195e2:	68bb      	ldr	r3, [r7, #8]
 80195e4:	781b      	ldrb	r3, [r3, #0]
 80195e6:	2b0d      	cmp	r3, #13
 80195e8:	d117      	bne.n	801961a <lcp_rejci+0x182>
 80195ea:	687b      	ldr	r3, [r7, #4]
 80195ec:	3b03      	subs	r3, #3
 80195ee:	607b      	str	r3, [r7, #4]
 80195f0:	68bb      	ldr	r3, [r7, #8]
 80195f2:	3302      	adds	r3, #2
 80195f4:	60bb      	str	r3, [r7, #8]
 80195f6:	68bb      	ldr	r3, [r7, #8]
 80195f8:	1c5a      	adds	r2, r3, #1
 80195fa:	60ba      	str	r2, [r7, #8]
 80195fc:	213b      	movs	r1, #59	; 0x3b
 80195fe:	187a      	adds	r2, r7, r1
 8019600:	781b      	ldrb	r3, [r3, #0]
 8019602:	7013      	strb	r3, [r2, #0]
 8019604:	187b      	adds	r3, r7, r1
 8019606:	781b      	ldrb	r3, [r3, #0]
 8019608:	2b06      	cmp	r3, #6
 801960a:	d000      	beq.n	801960e <lcp_rejci+0x176>
 801960c:	e113      	b.n	8019836 <lcp_rejci+0x39e>
 801960e:	2314      	movs	r3, #20
 8019610:	18fb      	adds	r3, r7, r3
 8019612:	781a      	ldrb	r2, [r3, #0]
 8019614:	217f      	movs	r1, #127	; 0x7f
 8019616:	400a      	ands	r2, r1
 8019618:	701a      	strb	r2, [r3, #0]
    REJCILONG(CI_MAGICNUMBER, neg_magicnumber, go->magicnumber);
 801961a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801961c:	781b      	ldrb	r3, [r3, #0]
 801961e:	2210      	movs	r2, #16
 8019620:	4013      	ands	r3, r2
 8019622:	b2db      	uxtb	r3, r3
 8019624:	2b00      	cmp	r3, #0
 8019626:	d041      	beq.n	80196ac <lcp_rejci+0x214>
 8019628:	687b      	ldr	r3, [r7, #4]
 801962a:	2b05      	cmp	r3, #5
 801962c:	dd3e      	ble.n	80196ac <lcp_rejci+0x214>
 801962e:	68bb      	ldr	r3, [r7, #8]
 8019630:	3301      	adds	r3, #1
 8019632:	781b      	ldrb	r3, [r3, #0]
 8019634:	2b06      	cmp	r3, #6
 8019636:	d139      	bne.n	80196ac <lcp_rejci+0x214>
 8019638:	68bb      	ldr	r3, [r7, #8]
 801963a:	781b      	ldrb	r3, [r3, #0]
 801963c:	2b05      	cmp	r3, #5
 801963e:	d135      	bne.n	80196ac <lcp_rejci+0x214>
 8019640:	687b      	ldr	r3, [r7, #4]
 8019642:	3b06      	subs	r3, #6
 8019644:	607b      	str	r3, [r7, #4]
 8019646:	68bb      	ldr	r3, [r7, #8]
 8019648:	3302      	adds	r3, #2
 801964a:	60bb      	str	r3, [r7, #8]
 801964c:	68bb      	ldr	r3, [r7, #8]
 801964e:	1c5a      	adds	r2, r3, #1
 8019650:	60ba      	str	r2, [r7, #8]
 8019652:	781b      	ldrb	r3, [r3, #0]
 8019654:	021b      	lsls	r3, r3, #8
 8019656:	63fb      	str	r3, [r7, #60]	; 0x3c
 8019658:	68bb      	ldr	r3, [r7, #8]
 801965a:	1c5a      	adds	r2, r3, #1
 801965c:	60ba      	str	r2, [r7, #8]
 801965e:	781b      	ldrb	r3, [r3, #0]
 8019660:	001a      	movs	r2, r3
 8019662:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8019664:	4313      	orrs	r3, r2
 8019666:	63fb      	str	r3, [r7, #60]	; 0x3c
 8019668:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801966a:	021b      	lsls	r3, r3, #8
 801966c:	63fb      	str	r3, [r7, #60]	; 0x3c
 801966e:	68bb      	ldr	r3, [r7, #8]
 8019670:	1c5a      	adds	r2, r3, #1
 8019672:	60ba      	str	r2, [r7, #8]
 8019674:	781b      	ldrb	r3, [r3, #0]
 8019676:	001a      	movs	r2, r3
 8019678:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801967a:	4313      	orrs	r3, r2
 801967c:	63fb      	str	r3, [r7, #60]	; 0x3c
 801967e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8019680:	021b      	lsls	r3, r3, #8
 8019682:	63fb      	str	r3, [r7, #60]	; 0x3c
 8019684:	68bb      	ldr	r3, [r7, #8]
 8019686:	1c5a      	adds	r2, r3, #1
 8019688:	60ba      	str	r2, [r7, #8]
 801968a:	781b      	ldrb	r3, [r3, #0]
 801968c:	001a      	movs	r2, r3
 801968e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8019690:	4313      	orrs	r3, r2
 8019692:	63fb      	str	r3, [r7, #60]	; 0x3c
 8019694:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8019696:	689b      	ldr	r3, [r3, #8]
 8019698:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801969a:	429a      	cmp	r2, r3
 801969c:	d000      	beq.n	80196a0 <lcp_rejci+0x208>
 801969e:	e0cc      	b.n	801983a <lcp_rejci+0x3a2>
 80196a0:	2314      	movs	r3, #20
 80196a2:	18fb      	adds	r3, r7, r3
 80196a4:	781a      	ldrb	r2, [r3, #0]
 80196a6:	2110      	movs	r1, #16
 80196a8:	438a      	bics	r2, r1
 80196aa:	701a      	strb	r2, [r3, #0]
    REJCIVOID(CI_PCOMPRESSION, neg_pcompression);
 80196ac:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80196ae:	781b      	ldrb	r3, [r3, #0]
 80196b0:	2220      	movs	r2, #32
 80196b2:	4013      	ands	r3, r2
 80196b4:	b2db      	uxtb	r3, r3
 80196b6:	2b00      	cmp	r3, #0
 80196b8:	d017      	beq.n	80196ea <lcp_rejci+0x252>
 80196ba:	687b      	ldr	r3, [r7, #4]
 80196bc:	2b01      	cmp	r3, #1
 80196be:	dd14      	ble.n	80196ea <lcp_rejci+0x252>
 80196c0:	68bb      	ldr	r3, [r7, #8]
 80196c2:	3301      	adds	r3, #1
 80196c4:	781b      	ldrb	r3, [r3, #0]
 80196c6:	2b02      	cmp	r3, #2
 80196c8:	d10f      	bne.n	80196ea <lcp_rejci+0x252>
 80196ca:	68bb      	ldr	r3, [r7, #8]
 80196cc:	781b      	ldrb	r3, [r3, #0]
 80196ce:	2b07      	cmp	r3, #7
 80196d0:	d10b      	bne.n	80196ea <lcp_rejci+0x252>
 80196d2:	687b      	ldr	r3, [r7, #4]
 80196d4:	3b02      	subs	r3, #2
 80196d6:	607b      	str	r3, [r7, #4]
 80196d8:	68bb      	ldr	r3, [r7, #8]
 80196da:	3302      	adds	r3, #2
 80196dc:	60bb      	str	r3, [r7, #8]
 80196de:	2314      	movs	r3, #20
 80196e0:	18fb      	adds	r3, r7, r3
 80196e2:	781a      	ldrb	r2, [r3, #0]
 80196e4:	2120      	movs	r1, #32
 80196e6:	438a      	bics	r2, r1
 80196e8:	701a      	strb	r2, [r3, #0]
    REJCIVOID(CI_ACCOMPRESSION, neg_accompression);
 80196ea:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80196ec:	781b      	ldrb	r3, [r3, #0]
 80196ee:	2240      	movs	r2, #64	; 0x40
 80196f0:	4013      	ands	r3, r2
 80196f2:	b2db      	uxtb	r3, r3
 80196f4:	2b00      	cmp	r3, #0
 80196f6:	d017      	beq.n	8019728 <lcp_rejci+0x290>
 80196f8:	687b      	ldr	r3, [r7, #4]
 80196fa:	2b01      	cmp	r3, #1
 80196fc:	dd14      	ble.n	8019728 <lcp_rejci+0x290>
 80196fe:	68bb      	ldr	r3, [r7, #8]
 8019700:	3301      	adds	r3, #1
 8019702:	781b      	ldrb	r3, [r3, #0]
 8019704:	2b02      	cmp	r3, #2
 8019706:	d10f      	bne.n	8019728 <lcp_rejci+0x290>
 8019708:	68bb      	ldr	r3, [r7, #8]
 801970a:	781b      	ldrb	r3, [r3, #0]
 801970c:	2b08      	cmp	r3, #8
 801970e:	d10b      	bne.n	8019728 <lcp_rejci+0x290>
 8019710:	687b      	ldr	r3, [r7, #4]
 8019712:	3b02      	subs	r3, #2
 8019714:	607b      	str	r3, [r7, #4]
 8019716:	68bb      	ldr	r3, [r7, #8]
 8019718:	3302      	adds	r3, #2
 801971a:	60bb      	str	r3, [r7, #8]
 801971c:	2314      	movs	r3, #20
 801971e:	18fb      	adds	r3, r7, r3
 8019720:	781a      	ldrb	r2, [r3, #0]
 8019722:	2140      	movs	r1, #64	; 0x40
 8019724:	438a      	bics	r2, r1
 8019726:	701a      	strb	r2, [r3, #0]
#ifdef HAVE_MULTILINK
    REJCISHORT(CI_MRRU, neg_mrru, go->mrru);
#endif /* HAVE_MULTILINK */
    REJCIVOID(CI_SSNHF, neg_ssnhf);
 8019728:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801972a:	785b      	ldrb	r3, [r3, #1]
 801972c:	2201      	movs	r2, #1
 801972e:	4013      	ands	r3, r2
 8019730:	b2db      	uxtb	r3, r3
 8019732:	2b00      	cmp	r3, #0
 8019734:	d017      	beq.n	8019766 <lcp_rejci+0x2ce>
 8019736:	687b      	ldr	r3, [r7, #4]
 8019738:	2b01      	cmp	r3, #1
 801973a:	dd14      	ble.n	8019766 <lcp_rejci+0x2ce>
 801973c:	68bb      	ldr	r3, [r7, #8]
 801973e:	3301      	adds	r3, #1
 8019740:	781b      	ldrb	r3, [r3, #0]
 8019742:	2b02      	cmp	r3, #2
 8019744:	d10f      	bne.n	8019766 <lcp_rejci+0x2ce>
 8019746:	68bb      	ldr	r3, [r7, #8]
 8019748:	781b      	ldrb	r3, [r3, #0]
 801974a:	2b12      	cmp	r3, #18
 801974c:	d10b      	bne.n	8019766 <lcp_rejci+0x2ce>
 801974e:	687b      	ldr	r3, [r7, #4]
 8019750:	3b02      	subs	r3, #2
 8019752:	607b      	str	r3, [r7, #4]
 8019754:	68bb      	ldr	r3, [r7, #8]
 8019756:	3302      	adds	r3, #2
 8019758:	60bb      	str	r3, [r7, #8]
 801975a:	2314      	movs	r3, #20
 801975c:	18fb      	adds	r3, r7, r3
 801975e:	785a      	ldrb	r2, [r3, #1]
 8019760:	2101      	movs	r1, #1
 8019762:	438a      	bics	r2, r1
 8019764:	705a      	strb	r2, [r3, #1]
    REJCIENDP(CI_EPDISC, neg_endpoint, go->endpoint.class_,
 8019766:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8019768:	785b      	ldrb	r3, [r3, #1]
 801976a:	2202      	movs	r2, #2
 801976c:	4013      	ands	r3, r2
 801976e:	b2db      	uxtb	r3, r3
 8019770:	2b00      	cmp	r3, #0
 8019772:	d04a      	beq.n	801980a <lcp_rejci+0x372>
 8019774:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8019776:	7b9b      	ldrb	r3, [r3, #14]
 8019778:	3302      	adds	r3, #2
 801977a:	687a      	ldr	r2, [r7, #4]
 801977c:	429a      	cmp	r2, r3
 801977e:	dd44      	ble.n	801980a <lcp_rejci+0x372>
 8019780:	68bb      	ldr	r3, [r7, #8]
 8019782:	781b      	ldrb	r3, [r3, #0]
 8019784:	2b13      	cmp	r3, #19
 8019786:	d140      	bne.n	801980a <lcp_rejci+0x372>
 8019788:	68bb      	ldr	r3, [r7, #8]
 801978a:	3301      	adds	r3, #1
 801978c:	781b      	ldrb	r3, [r3, #0]
 801978e:	001a      	movs	r2, r3
 8019790:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8019792:	7b9b      	ldrb	r3, [r3, #14]
 8019794:	3303      	adds	r3, #3
 8019796:	429a      	cmp	r2, r3
 8019798:	d137      	bne.n	801980a <lcp_rejci+0x372>
 801979a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801979c:	7b9b      	ldrb	r3, [r3, #14]
 801979e:	3303      	adds	r3, #3
 80197a0:	687a      	ldr	r2, [r7, #4]
 80197a2:	1ad3      	subs	r3, r2, r3
 80197a4:	607b      	str	r3, [r7, #4]
 80197a6:	68bb      	ldr	r3, [r7, #8]
 80197a8:	3302      	adds	r3, #2
 80197aa:	60bb      	str	r3, [r7, #8]
 80197ac:	68bb      	ldr	r3, [r7, #8]
 80197ae:	1c5a      	adds	r2, r3, #1
 80197b0:	60ba      	str	r2, [r7, #8]
 80197b2:	213b      	movs	r1, #59	; 0x3b
 80197b4:	187a      	adds	r2, r7, r1
 80197b6:	781b      	ldrb	r3, [r3, #0]
 80197b8:	7013      	strb	r3, [r2, #0]
 80197ba:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80197bc:	7b5b      	ldrb	r3, [r3, #13]
 80197be:	187a      	adds	r2, r7, r1
 80197c0:	7812      	ldrb	r2, [r2, #0]
 80197c2:	429a      	cmp	r2, r3
 80197c4:	d13b      	bne.n	801983e <lcp_rejci+0x3a6>
 80197c6:	2300      	movs	r3, #0
 80197c8:	64fb      	str	r3, [r7, #76]	; 0x4c
 80197ca:	e012      	b.n	80197f2 <lcp_rejci+0x35a>
 80197cc:	68bb      	ldr	r3, [r7, #8]
 80197ce:	1c5a      	adds	r2, r3, #1
 80197d0:	60ba      	str	r2, [r7, #8]
 80197d2:	213b      	movs	r1, #59	; 0x3b
 80197d4:	187a      	adds	r2, r7, r1
 80197d6:	781b      	ldrb	r3, [r3, #0]
 80197d8:	7013      	strb	r3, [r2, #0]
 80197da:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80197dc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80197de:	18d3      	adds	r3, r2, r3
 80197e0:	330f      	adds	r3, #15
 80197e2:	781b      	ldrb	r3, [r3, #0]
 80197e4:	187a      	adds	r2, r7, r1
 80197e6:	7812      	ldrb	r2, [r2, #0]
 80197e8:	429a      	cmp	r2, r3
 80197ea:	d12a      	bne.n	8019842 <lcp_rejci+0x3aa>
 80197ec:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80197ee:	3301      	adds	r3, #1
 80197f0:	64fb      	str	r3, [r7, #76]	; 0x4c
 80197f2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80197f4:	7b9b      	ldrb	r3, [r3, #14]
 80197f6:	001a      	movs	r2, r3
 80197f8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80197fa:	4293      	cmp	r3, r2
 80197fc:	dbe6      	blt.n	80197cc <lcp_rejci+0x334>
 80197fe:	2314      	movs	r3, #20
 8019800:	18fb      	adds	r3, r7, r3
 8019802:	785a      	ldrb	r2, [r3, #1]
 8019804:	2102      	movs	r1, #2
 8019806:	438a      	bics	r2, r1
 8019808:	705a      	strb	r2, [r3, #1]
	      go->endpoint.value, go->endpoint.length);

    /*
     * If there are any remaining CIs, then this packet is bad.
     */
    if (len != 0)
 801980a:	687b      	ldr	r3, [r7, #4]
 801980c:	2b00      	cmp	r3, #0
 801980e:	d11a      	bne.n	8019846 <lcp_rejci+0x3ae>
	goto bad;
    /*
     * Now we can update state.
     */
    if (f->state != PPP_FSM_OPENED)
 8019810:	68fb      	ldr	r3, [r7, #12]
 8019812:	7c1b      	ldrb	r3, [r3, #16]
 8019814:	2b09      	cmp	r3, #9
 8019816:	d008      	beq.n	801982a <lcp_rejci+0x392>
	*go = try_;
 8019818:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801981a:	2214      	movs	r2, #20
 801981c:	18ba      	adds	r2, r7, r2
 801981e:	ca13      	ldmia	r2!, {r0, r1, r4}
 8019820:	c313      	stmia	r3!, {r0, r1, r4}
 8019822:	ca13      	ldmia	r2!, {r0, r1, r4}
 8019824:	c313      	stmia	r3!, {r0, r1, r4}
 8019826:	ca13      	ldmia	r2!, {r0, r1, r4}
 8019828:	c313      	stmia	r3!, {r0, r1, r4}
    return 1;
 801982a:	2301      	movs	r3, #1
 801982c:	e00d      	b.n	801984a <lcp_rejci+0x3b2>
    REJCISHORT(CI_MRU, neg_mru, go->mru);
 801982e:	46c0      	nop			; (mov r8, r8)
 8019830:	e00a      	b.n	8019848 <lcp_rejci+0x3b0>
    REJCILONG(CI_ASYNCMAP, neg_asyncmap, go->asyncmap);
 8019832:	46c0      	nop			; (mov r8, r8)
 8019834:	e008      	b.n	8019848 <lcp_rejci+0x3b0>
    REJCICBCP(CI_CALLBACK, neg_cbcp, CBCP_OPT);
 8019836:	46c0      	nop			; (mov r8, r8)
 8019838:	e006      	b.n	8019848 <lcp_rejci+0x3b0>
    REJCILONG(CI_MAGICNUMBER, neg_magicnumber, go->magicnumber);
 801983a:	46c0      	nop			; (mov r8, r8)
 801983c:	e004      	b.n	8019848 <lcp_rejci+0x3b0>
    REJCIENDP(CI_EPDISC, neg_endpoint, go->endpoint.class_,
 801983e:	46c0      	nop			; (mov r8, r8)
 8019840:	e002      	b.n	8019848 <lcp_rejci+0x3b0>
 8019842:	46c0      	nop			; (mov r8, r8)
 8019844:	e000      	b.n	8019848 <lcp_rejci+0x3b0>
	goto bad;
 8019846:	46c0      	nop			; (mov r8, r8)

bad:
    LCPDEBUG(("lcp_rejci: received bad Reject!"));
    return 0;
 8019848:	2300      	movs	r3, #0
}
 801984a:	0018      	movs	r0, r3
 801984c:	46bd      	mov	sp, r7
 801984e:	b014      	add	sp, #80	; 0x50
 8019850:	bdb0      	pop	{r4, r5, r7, pc}
	...

08019854 <lcp_reqci>:
 * CONFNAK; returns CONFREJ if it can't return CONFACK.
 *
 * inp = Requested CIs
 * lenp = Length of requested CIs
 */
static int lcp_reqci(fsm *f, u_char *inp, int *lenp, int reject_if_disagree) {
 8019854:	b580      	push	{r7, lr}
 8019856:	b096      	sub	sp, #88	; 0x58
 8019858:	af00      	add	r7, sp, #0
 801985a:	60f8      	str	r0, [r7, #12]
 801985c:	60b9      	str	r1, [r7, #8]
 801985e:	607a      	str	r2, [r7, #4]
 8019860:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 8019862:	68fb      	ldr	r3, [r7, #12]
 8019864:	681b      	ldr	r3, [r3, #0]
 8019866:	637b      	str	r3, [r7, #52]	; 0x34
    lcp_options *go = &pcb->lcp_gotoptions;
 8019868:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801986a:	3368      	adds	r3, #104	; 0x68
 801986c:	633b      	str	r3, [r7, #48]	; 0x30
    lcp_options *ho = &pcb->lcp_hisoptions;
 801986e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8019870:	33b0      	adds	r3, #176	; 0xb0
 8019872:	62fb      	str	r3, [r7, #44]	; 0x2c
    lcp_options *ao = &pcb->lcp_allowoptions;
 8019874:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8019876:	338c      	adds	r3, #140	; 0x8c
 8019878:	62bb      	str	r3, [r7, #40]	; 0x28
    u_char *cip, *next;		/* Pointer to current and next CIs */
    int cilen, citype, cichar;	/* Parsed len, type, char value */
    u_short cishort;		/* Parsed short value */
    u32_t cilong;		/* Parse long value */
    int rc = CONFACK;		/* Final packet return code */
 801987a:	2302      	movs	r3, #2
 801987c:	64bb      	str	r3, [r7, #72]	; 0x48
    int orc;			/* Individual option return code */
    u_char *p;			/* Pointer to next char to parse */
    u_char *rejp;		/* Pointer to next char in reject frame */
    struct pbuf *nakp;          /* Nak buffer */
    u_char *nakoutp;		/* Pointer to next char in Nak frame */
    int l = *lenp;		/* Length left */
 801987e:	687b      	ldr	r3, [r7, #4]
 8019880:	681b      	ldr	r3, [r3, #0]
 8019882:	63bb      	str	r3, [r7, #56]	; 0x38

    /*
     * Reset all his options.
     */
    BZERO(ho, sizeof(*ho));
 8019884:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019886:	2224      	movs	r2, #36	; 0x24
 8019888:	2100      	movs	r1, #0
 801988a:	0018      	movs	r0, r3
 801988c:	f004 fba2 	bl	801dfd4 <memset>

    /*
     * Process all his options.
     */
    next = inp;
 8019890:	68bb      	ldr	r3, [r7, #8]
 8019892:	657b      	str	r3, [r7, #84]	; 0x54
    nakp = pbuf_alloc(PBUF_RAW, (u16_t)(PPP_CTRL_PBUF_MAX_SIZE), PPP_CTRL_PBUF_TYPE);
 8019894:	23c1      	movs	r3, #193	; 0xc1
 8019896:	005a      	lsls	r2, r3, #1
 8019898:	2394      	movs	r3, #148	; 0x94
 801989a:	009b      	lsls	r3, r3, #2
 801989c:	0019      	movs	r1, r3
 801989e:	2000      	movs	r0, #0
 80198a0:	f7f0 fae6 	bl	8009e70 <pbuf_alloc>
 80198a4:	0003      	movs	r3, r0
 80198a6:	627b      	str	r3, [r7, #36]	; 0x24
    if(NULL == nakp)
 80198a8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80198aa:	2b00      	cmp	r3, #0
 80198ac:	d101      	bne.n	80198b2 <lcp_reqci+0x5e>
        return 0;
 80198ae:	2300      	movs	r3, #0
 80198b0:	e258      	b.n	8019d64 <lcp_reqci+0x510>
    if(nakp->tot_len != nakp->len) {
 80198b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80198b4:	891a      	ldrh	r2, [r3, #8]
 80198b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80198b8:	895b      	ldrh	r3, [r3, #10]
 80198ba:	429a      	cmp	r2, r3
 80198bc:	d005      	beq.n	80198ca <lcp_reqci+0x76>
        pbuf_free(nakp);
 80198be:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80198c0:	0018      	movs	r0, r3
 80198c2:	f7f0 fe0b 	bl	800a4dc <pbuf_free>
        return 0;
 80198c6:	2300      	movs	r3, #0
 80198c8:	e24c      	b.n	8019d64 <lcp_reqci+0x510>
    }

    nakoutp = (u_char*)nakp->payload;
 80198ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80198cc:	685b      	ldr	r3, [r3, #4]
 80198ce:	63fb      	str	r3, [r7, #60]	; 0x3c
    rejp = inp;
 80198d0:	68bb      	ldr	r3, [r7, #8]
 80198d2:	643b      	str	r3, [r7, #64]	; 0x40
    while (l) {
 80198d4:	e213      	b.n	8019cfe <lcp_reqci+0x4aa>
	orc = CONFACK;			/* Assume success */
 80198d6:	2302      	movs	r3, #2
 80198d8:	647b      	str	r3, [r7, #68]	; 0x44
	cip = p = next;			/* Remember begining of CI */
 80198da:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80198dc:	623b      	str	r3, [r7, #32]
 80198de:	6a3b      	ldr	r3, [r7, #32]
 80198e0:	61fb      	str	r3, [r7, #28]
	if (l < 2 ||			/* Not enough data for CI header or */
 80198e2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80198e4:	2b01      	cmp	r3, #1
 80198e6:	dd0b      	ble.n	8019900 <lcp_reqci+0xac>
	    p[1] < 2 ||			/*  CI length too small or */
 80198e8:	6a3b      	ldr	r3, [r7, #32]
 80198ea:	3301      	adds	r3, #1
 80198ec:	781b      	ldrb	r3, [r3, #0]
	if (l < 2 ||			/* Not enough data for CI header or */
 80198ee:	2b01      	cmp	r3, #1
 80198f0:	d906      	bls.n	8019900 <lcp_reqci+0xac>
	    p[1] > l) {			/*  CI length too big? */
 80198f2:	6a3b      	ldr	r3, [r7, #32]
 80198f4:	3301      	adds	r3, #1
 80198f6:	781b      	ldrb	r3, [r3, #0]
 80198f8:	001a      	movs	r2, r3
	    p[1] < 2 ||			/*  CI length too small or */
 80198fa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80198fc:	4293      	cmp	r3, r2
 80198fe:	da08      	bge.n	8019912 <lcp_reqci+0xbe>
	    LCPDEBUG(("lcp_reqci: bad CI length!"));
	    orc = CONFREJ;		/* Reject bad CI */
 8019900:	2304      	movs	r3, #4
 8019902:	647b      	str	r3, [r7, #68]	; 0x44
	    cilen = l;			/* Reject till end of packet */
 8019904:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8019906:	653b      	str	r3, [r7, #80]	; 0x50
	    l = 0;			/* Don't loop again */
 8019908:	2300      	movs	r3, #0
 801990a:	63bb      	str	r3, [r7, #56]	; 0x38
	    citype = 0;
 801990c:	2300      	movs	r3, #0
 801990e:	64fb      	str	r3, [r7, #76]	; 0x4c
	    goto endswitch;
 8019910:	e1c4      	b.n	8019c9c <lcp_reqci+0x448>
	}
	GETCHAR(citype, p);		/* Parse CI type */
 8019912:	6a3b      	ldr	r3, [r7, #32]
 8019914:	1c5a      	adds	r2, r3, #1
 8019916:	623a      	str	r2, [r7, #32]
 8019918:	781b      	ldrb	r3, [r3, #0]
 801991a:	64fb      	str	r3, [r7, #76]	; 0x4c
	GETCHAR(cilen, p);		/* Parse CI length */
 801991c:	6a3b      	ldr	r3, [r7, #32]
 801991e:	1c5a      	adds	r2, r3, #1
 8019920:	623a      	str	r2, [r7, #32]
 8019922:	781b      	ldrb	r3, [r3, #0]
 8019924:	653b      	str	r3, [r7, #80]	; 0x50
	l -= cilen;			/* Adjust remaining length */
 8019926:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8019928:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801992a:	1ad3      	subs	r3, r2, r3
 801992c:	63bb      	str	r3, [r7, #56]	; 0x38
	next += cilen;			/* Step to next CI */
 801992e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019930:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8019932:	18d3      	adds	r3, r2, r3
 8019934:	657b      	str	r3, [r7, #84]	; 0x54
 8019936:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8019938:	2b13      	cmp	r3, #19
 801993a:	d900      	bls.n	801993e <lcp_reqci+0xea>
 801993c:	e1ab      	b.n	8019c96 <lcp_reqci+0x442>
 801993e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8019940:	009a      	lsls	r2, r3, #2
 8019942:	4bda      	ldr	r3, [pc, #872]	; (8019cac <lcp_reqci+0x458>)
 8019944:	18d3      	adds	r3, r2, r3
 8019946:	681b      	ldr	r3, [r3, #0]
 8019948:	469f      	mov	pc, r3

	switch (citype) {		/* Check CI type */
	case CI_MRU:
	    if (!ao->neg_mru ||		/* Allow option? */
 801994a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801994c:	781b      	ldrb	r3, [r3, #0]
 801994e:	2204      	movs	r2, #4
 8019950:	4013      	ands	r3, r2
 8019952:	b2db      	uxtb	r3, r3
 8019954:	2b00      	cmp	r3, #0
 8019956:	d002      	beq.n	801995e <lcp_reqci+0x10a>
 8019958:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801995a:	2b04      	cmp	r3, #4
 801995c:	d002      	beq.n	8019964 <lcp_reqci+0x110>
		cilen != CILEN_SHORT) {	/* Check CI length */
		orc = CONFREJ;		/* Reject CI */
 801995e:	2304      	movs	r3, #4
 8019960:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 8019962:	e19b      	b.n	8019c9c <lcp_reqci+0x448>
	    }
	    GETSHORT(cishort, p);	/* Parse MRU */
 8019964:	6a3b      	ldr	r3, [r7, #32]
 8019966:	1c5a      	adds	r2, r3, #1
 8019968:	623a      	str	r2, [r7, #32]
 801996a:	781b      	ldrb	r3, [r3, #0]
 801996c:	b29a      	uxth	r2, r3
 801996e:	2012      	movs	r0, #18
 8019970:	183b      	adds	r3, r7, r0
 8019972:	0212      	lsls	r2, r2, #8
 8019974:	801a      	strh	r2, [r3, #0]
 8019976:	6a3b      	ldr	r3, [r7, #32]
 8019978:	1c5a      	adds	r2, r3, #1
 801997a:	623a      	str	r2, [r7, #32]
 801997c:	781b      	ldrb	r3, [r3, #0]
 801997e:	b299      	uxth	r1, r3
 8019980:	183b      	adds	r3, r7, r0
 8019982:	183a      	adds	r2, r7, r0
 8019984:	8812      	ldrh	r2, [r2, #0]
 8019986:	430a      	orrs	r2, r1
 8019988:	801a      	strh	r2, [r3, #0]
	    /*
	     * He must be able to receive at least our minimum.
	     * No need to check a maximum.  If he sends a large number,
	     * we'll just ignore it.
	     */
	    if (cishort < PPP_MINMRU) {
 801998a:	183b      	adds	r3, r7, r0
 801998c:	881b      	ldrh	r3, [r3, #0]
 801998e:	2b7f      	cmp	r3, #127	; 0x7f
 8019990:	d816      	bhi.n	80199c0 <lcp_reqci+0x16c>
		orc = CONFNAK;		/* Nak CI */
 8019992:	2303      	movs	r3, #3
 8019994:	647b      	str	r3, [r7, #68]	; 0x44
		PUTCHAR(CI_MRU, nakoutp);
 8019996:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8019998:	1c5a      	adds	r2, r3, #1
 801999a:	63fa      	str	r2, [r7, #60]	; 0x3c
 801999c:	2201      	movs	r2, #1
 801999e:	701a      	strb	r2, [r3, #0]
		PUTCHAR(CILEN_SHORT, nakoutp);
 80199a0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80199a2:	1c5a      	adds	r2, r3, #1
 80199a4:	63fa      	str	r2, [r7, #60]	; 0x3c
 80199a6:	2204      	movs	r2, #4
 80199a8:	701a      	strb	r2, [r3, #0]
		PUTSHORT(PPP_MINMRU, nakoutp);	/* Give him a hint */
 80199aa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80199ac:	1c5a      	adds	r2, r3, #1
 80199ae:	63fa      	str	r2, [r7, #60]	; 0x3c
 80199b0:	2200      	movs	r2, #0
 80199b2:	701a      	strb	r2, [r3, #0]
 80199b4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80199b6:	1c5a      	adds	r2, r3, #1
 80199b8:	63fa      	str	r2, [r7, #60]	; 0x3c
 80199ba:	2280      	movs	r2, #128	; 0x80
 80199bc:	701a      	strb	r2, [r3, #0]
		break;
 80199be:	e16d      	b.n	8019c9c <lcp_reqci+0x448>
	    }
	    ho->neg_mru = 1;		/* Remember he sent MRU */
 80199c0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80199c2:	781a      	ldrb	r2, [r3, #0]
 80199c4:	2104      	movs	r1, #4
 80199c6:	430a      	orrs	r2, r1
 80199c8:	701a      	strb	r2, [r3, #0]
	    ho->mru = cishort;		/* And remember value */
 80199ca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80199cc:	2212      	movs	r2, #18
 80199ce:	18ba      	adds	r2, r7, r2
 80199d0:	8812      	ldrh	r2, [r2, #0]
 80199d2:	805a      	strh	r2, [r3, #2]
	    break;
 80199d4:	e162      	b.n	8019c9c <lcp_reqci+0x448>

	case CI_ASYNCMAP:
	    if (!ao->neg_asyncmap ||
 80199d6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80199d8:	781b      	ldrb	r3, [r3, #0]
 80199da:	2208      	movs	r2, #8
 80199dc:	4013      	ands	r3, r2
 80199de:	b2db      	uxtb	r3, r3
 80199e0:	2b00      	cmp	r3, #0
 80199e2:	d002      	beq.n	80199ea <lcp_reqci+0x196>
 80199e4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80199e6:	2b06      	cmp	r3, #6
 80199e8:	d002      	beq.n	80199f0 <lcp_reqci+0x19c>
		cilen != CILEN_LONG) {
		orc = CONFREJ;
 80199ea:	2304      	movs	r3, #4
 80199ec:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 80199ee:	e155      	b.n	8019c9c <lcp_reqci+0x448>
	    }
	    GETLONG(cilong, p);
 80199f0:	6a3b      	ldr	r3, [r7, #32]
 80199f2:	1c5a      	adds	r2, r3, #1
 80199f4:	623a      	str	r2, [r7, #32]
 80199f6:	781b      	ldrb	r3, [r3, #0]
 80199f8:	021b      	lsls	r3, r3, #8
 80199fa:	617b      	str	r3, [r7, #20]
 80199fc:	6a3b      	ldr	r3, [r7, #32]
 80199fe:	1c5a      	adds	r2, r3, #1
 8019a00:	623a      	str	r2, [r7, #32]
 8019a02:	781b      	ldrb	r3, [r3, #0]
 8019a04:	001a      	movs	r2, r3
 8019a06:	697b      	ldr	r3, [r7, #20]
 8019a08:	4313      	orrs	r3, r2
 8019a0a:	617b      	str	r3, [r7, #20]
 8019a0c:	697b      	ldr	r3, [r7, #20]
 8019a0e:	021b      	lsls	r3, r3, #8
 8019a10:	617b      	str	r3, [r7, #20]
 8019a12:	6a3b      	ldr	r3, [r7, #32]
 8019a14:	1c5a      	adds	r2, r3, #1
 8019a16:	623a      	str	r2, [r7, #32]
 8019a18:	781b      	ldrb	r3, [r3, #0]
 8019a1a:	001a      	movs	r2, r3
 8019a1c:	697b      	ldr	r3, [r7, #20]
 8019a1e:	4313      	orrs	r3, r2
 8019a20:	617b      	str	r3, [r7, #20]
 8019a22:	697b      	ldr	r3, [r7, #20]
 8019a24:	021b      	lsls	r3, r3, #8
 8019a26:	617b      	str	r3, [r7, #20]
 8019a28:	6a3b      	ldr	r3, [r7, #32]
 8019a2a:	1c5a      	adds	r2, r3, #1
 8019a2c:	623a      	str	r2, [r7, #32]
 8019a2e:	781b      	ldrb	r3, [r3, #0]
 8019a30:	001a      	movs	r2, r3
 8019a32:	697b      	ldr	r3, [r7, #20]
 8019a34:	4313      	orrs	r3, r2
 8019a36:	617b      	str	r3, [r7, #20]

	    /*
	     * Asyncmap must have set at least the bits
	     * which are set in lcp_allowoptions[unit].asyncmap.
	     */
	    if ((ao->asyncmap & ~cilong) != 0) {
 8019a38:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019a3a:	685b      	ldr	r3, [r3, #4]
 8019a3c:	697a      	ldr	r2, [r7, #20]
 8019a3e:	43d2      	mvns	r2, r2
 8019a40:	4013      	ands	r3, r2
 8019a42:	d035      	beq.n	8019ab0 <lcp_reqci+0x25c>
		orc = CONFNAK;
 8019a44:	2303      	movs	r3, #3
 8019a46:	647b      	str	r3, [r7, #68]	; 0x44
		PUTCHAR(CI_ASYNCMAP, nakoutp);
 8019a48:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8019a4a:	1c5a      	adds	r2, r3, #1
 8019a4c:	63fa      	str	r2, [r7, #60]	; 0x3c
 8019a4e:	2202      	movs	r2, #2
 8019a50:	701a      	strb	r2, [r3, #0]
		PUTCHAR(CILEN_LONG, nakoutp);
 8019a52:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8019a54:	1c5a      	adds	r2, r3, #1
 8019a56:	63fa      	str	r2, [r7, #60]	; 0x3c
 8019a58:	2206      	movs	r2, #6
 8019a5a:	701a      	strb	r2, [r3, #0]
		PUTLONG(ao->asyncmap | cilong, nakoutp);
 8019a5c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019a5e:	685a      	ldr	r2, [r3, #4]
 8019a60:	697b      	ldr	r3, [r7, #20]
 8019a62:	4313      	orrs	r3, r2
 8019a64:	0e19      	lsrs	r1, r3, #24
 8019a66:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8019a68:	1c5a      	adds	r2, r3, #1
 8019a6a:	63fa      	str	r2, [r7, #60]	; 0x3c
 8019a6c:	b2ca      	uxtb	r2, r1
 8019a6e:	701a      	strb	r2, [r3, #0]
 8019a70:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019a72:	685a      	ldr	r2, [r3, #4]
 8019a74:	697b      	ldr	r3, [r7, #20]
 8019a76:	4313      	orrs	r3, r2
 8019a78:	0c19      	lsrs	r1, r3, #16
 8019a7a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8019a7c:	1c5a      	adds	r2, r3, #1
 8019a7e:	63fa      	str	r2, [r7, #60]	; 0x3c
 8019a80:	b2ca      	uxtb	r2, r1
 8019a82:	701a      	strb	r2, [r3, #0]
 8019a84:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019a86:	685a      	ldr	r2, [r3, #4]
 8019a88:	697b      	ldr	r3, [r7, #20]
 8019a8a:	4313      	orrs	r3, r2
 8019a8c:	0a19      	lsrs	r1, r3, #8
 8019a8e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8019a90:	1c5a      	adds	r2, r3, #1
 8019a92:	63fa      	str	r2, [r7, #60]	; 0x3c
 8019a94:	b2ca      	uxtb	r2, r1
 8019a96:	701a      	strb	r2, [r3, #0]
 8019a98:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019a9a:	685b      	ldr	r3, [r3, #4]
 8019a9c:	b2d9      	uxtb	r1, r3
 8019a9e:	697b      	ldr	r3, [r7, #20]
 8019aa0:	b2da      	uxtb	r2, r3
 8019aa2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8019aa4:	1c58      	adds	r0, r3, #1
 8019aa6:	63f8      	str	r0, [r7, #60]	; 0x3c
 8019aa8:	430a      	orrs	r2, r1
 8019aaa:	b2d2      	uxtb	r2, r2
 8019aac:	701a      	strb	r2, [r3, #0]
		break;
 8019aae:	e0f5      	b.n	8019c9c <lcp_reqci+0x448>
	    }
	    ho->neg_asyncmap = 1;
 8019ab0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019ab2:	781a      	ldrb	r2, [r3, #0]
 8019ab4:	2108      	movs	r1, #8
 8019ab6:	430a      	orrs	r2, r1
 8019ab8:	701a      	strb	r2, [r3, #0]
	    ho->asyncmap = cilong;
 8019aba:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019abc:	697a      	ldr	r2, [r7, #20]
 8019abe:	605a      	str	r2, [r3, #4]
	    break;
 8019ac0:	e0ec      	b.n	8019c9c <lcp_reqci+0x448>
#endif /* EAP_SUPPORT */
		)) {
		/*
		 * Reject the option if we're not willing to authenticate.
		 */
		ppp_dbglog("No auth is possible");
 8019ac2:	4b7b      	ldr	r3, [pc, #492]	; (8019cb0 <lcp_reqci+0x45c>)
 8019ac4:	0018      	movs	r0, r3
 8019ac6:	f002 fa8c 	bl	801bfe2 <ppp_dbglog>
		orc = CONFREJ;
 8019aca:	2304      	movs	r3, #4
 8019acc:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 8019ace:	e0e5      	b.n	8019c9c <lcp_reqci+0x448>
	    }
	    break;
#endif /* LQR_SUPPORT */

	case CI_MAGICNUMBER:
	    if (!(ao->neg_magicnumber || go->neg_magicnumber) ||
 8019ad0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019ad2:	781b      	ldrb	r3, [r3, #0]
 8019ad4:	2210      	movs	r2, #16
 8019ad6:	4013      	ands	r3, r2
 8019ad8:	b2db      	uxtb	r3, r3
 8019ada:	2b00      	cmp	r3, #0
 8019adc:	d106      	bne.n	8019aec <lcp_reqci+0x298>
 8019ade:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019ae0:	781b      	ldrb	r3, [r3, #0]
 8019ae2:	2210      	movs	r2, #16
 8019ae4:	4013      	ands	r3, r2
 8019ae6:	b2db      	uxtb	r3, r3
 8019ae8:	2b00      	cmp	r3, #0
 8019aea:	d002      	beq.n	8019af2 <lcp_reqci+0x29e>
 8019aec:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019aee:	2b06      	cmp	r3, #6
 8019af0:	d002      	beq.n	8019af8 <lcp_reqci+0x2a4>
		cilen != CILEN_LONG) {
		orc = CONFREJ;
 8019af2:	2304      	movs	r3, #4
 8019af4:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 8019af6:	e0d1      	b.n	8019c9c <lcp_reqci+0x448>
	    }
	    GETLONG(cilong, p);
 8019af8:	6a3b      	ldr	r3, [r7, #32]
 8019afa:	1c5a      	adds	r2, r3, #1
 8019afc:	623a      	str	r2, [r7, #32]
 8019afe:	781b      	ldrb	r3, [r3, #0]
 8019b00:	021b      	lsls	r3, r3, #8
 8019b02:	617b      	str	r3, [r7, #20]
 8019b04:	6a3b      	ldr	r3, [r7, #32]
 8019b06:	1c5a      	adds	r2, r3, #1
 8019b08:	623a      	str	r2, [r7, #32]
 8019b0a:	781b      	ldrb	r3, [r3, #0]
 8019b0c:	001a      	movs	r2, r3
 8019b0e:	697b      	ldr	r3, [r7, #20]
 8019b10:	4313      	orrs	r3, r2
 8019b12:	617b      	str	r3, [r7, #20]
 8019b14:	697b      	ldr	r3, [r7, #20]
 8019b16:	021b      	lsls	r3, r3, #8
 8019b18:	617b      	str	r3, [r7, #20]
 8019b1a:	6a3b      	ldr	r3, [r7, #32]
 8019b1c:	1c5a      	adds	r2, r3, #1
 8019b1e:	623a      	str	r2, [r7, #32]
 8019b20:	781b      	ldrb	r3, [r3, #0]
 8019b22:	001a      	movs	r2, r3
 8019b24:	697b      	ldr	r3, [r7, #20]
 8019b26:	4313      	orrs	r3, r2
 8019b28:	617b      	str	r3, [r7, #20]
 8019b2a:	697b      	ldr	r3, [r7, #20]
 8019b2c:	021b      	lsls	r3, r3, #8
 8019b2e:	617b      	str	r3, [r7, #20]
 8019b30:	6a3b      	ldr	r3, [r7, #32]
 8019b32:	1c5a      	adds	r2, r3, #1
 8019b34:	623a      	str	r2, [r7, #32]
 8019b36:	781b      	ldrb	r3, [r3, #0]
 8019b38:	001a      	movs	r2, r3
 8019b3a:	697b      	ldr	r3, [r7, #20]
 8019b3c:	4313      	orrs	r3, r2
 8019b3e:	617b      	str	r3, [r7, #20]

	    /*
	     * He must have a different magic number.
	     */
	    if (go->neg_magicnumber &&
 8019b40:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019b42:	781b      	ldrb	r3, [r3, #0]
 8019b44:	2210      	movs	r2, #16
 8019b46:	4013      	ands	r3, r2
 8019b48:	b2db      	uxtb	r3, r3
 8019b4a:	2b00      	cmp	r3, #0
 8019b4c:	d030      	beq.n	8019bb0 <lcp_reqci+0x35c>
		cilong == go->magicnumber) {
 8019b4e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019b50:	689b      	ldr	r3, [r3, #8]
	    if (go->neg_magicnumber &&
 8019b52:	697a      	ldr	r2, [r7, #20]
 8019b54:	429a      	cmp	r2, r3
 8019b56:	d12b      	bne.n	8019bb0 <lcp_reqci+0x35c>
		cilong = magic();	/* Don't put magic() inside macro! */
 8019b58:	f000 fbca 	bl	801a2f0 <magic>
 8019b5c:	0003      	movs	r3, r0
 8019b5e:	617b      	str	r3, [r7, #20]
		orc = CONFNAK;
 8019b60:	2303      	movs	r3, #3
 8019b62:	647b      	str	r3, [r7, #68]	; 0x44
		PUTCHAR(CI_MAGICNUMBER, nakoutp);
 8019b64:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8019b66:	1c5a      	adds	r2, r3, #1
 8019b68:	63fa      	str	r2, [r7, #60]	; 0x3c
 8019b6a:	2205      	movs	r2, #5
 8019b6c:	701a      	strb	r2, [r3, #0]
		PUTCHAR(CILEN_LONG, nakoutp);
 8019b6e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8019b70:	1c5a      	adds	r2, r3, #1
 8019b72:	63fa      	str	r2, [r7, #60]	; 0x3c
 8019b74:	2206      	movs	r2, #6
 8019b76:	701a      	strb	r2, [r3, #0]
		PUTLONG(cilong, nakoutp);
 8019b78:	697b      	ldr	r3, [r7, #20]
 8019b7a:	0e19      	lsrs	r1, r3, #24
 8019b7c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8019b7e:	1c5a      	adds	r2, r3, #1
 8019b80:	63fa      	str	r2, [r7, #60]	; 0x3c
 8019b82:	b2ca      	uxtb	r2, r1
 8019b84:	701a      	strb	r2, [r3, #0]
 8019b86:	697b      	ldr	r3, [r7, #20]
 8019b88:	0c19      	lsrs	r1, r3, #16
 8019b8a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8019b8c:	1c5a      	adds	r2, r3, #1
 8019b8e:	63fa      	str	r2, [r7, #60]	; 0x3c
 8019b90:	b2ca      	uxtb	r2, r1
 8019b92:	701a      	strb	r2, [r3, #0]
 8019b94:	697b      	ldr	r3, [r7, #20]
 8019b96:	0a19      	lsrs	r1, r3, #8
 8019b98:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8019b9a:	1c5a      	adds	r2, r3, #1
 8019b9c:	63fa      	str	r2, [r7, #60]	; 0x3c
 8019b9e:	b2ca      	uxtb	r2, r1
 8019ba0:	701a      	strb	r2, [r3, #0]
 8019ba2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8019ba4:	1c5a      	adds	r2, r3, #1
 8019ba6:	63fa      	str	r2, [r7, #60]	; 0x3c
 8019ba8:	697a      	ldr	r2, [r7, #20]
 8019baa:	b2d2      	uxtb	r2, r2
 8019bac:	701a      	strb	r2, [r3, #0]
		break;
 8019bae:	e075      	b.n	8019c9c <lcp_reqci+0x448>
	    }
	    ho->neg_magicnumber = 1;
 8019bb0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019bb2:	781a      	ldrb	r2, [r3, #0]
 8019bb4:	2110      	movs	r1, #16
 8019bb6:	430a      	orrs	r2, r1
 8019bb8:	701a      	strb	r2, [r3, #0]
	    ho->magicnumber = cilong;
 8019bba:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019bbc:	697a      	ldr	r2, [r7, #20]
 8019bbe:	609a      	str	r2, [r3, #8]
	    break;
 8019bc0:	e06c      	b.n	8019c9c <lcp_reqci+0x448>


	case CI_PCOMPRESSION:
	    if (!ao->neg_pcompression ||
 8019bc2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019bc4:	781b      	ldrb	r3, [r3, #0]
 8019bc6:	2220      	movs	r2, #32
 8019bc8:	4013      	ands	r3, r2
 8019bca:	b2db      	uxtb	r3, r3
 8019bcc:	2b00      	cmp	r3, #0
 8019bce:	d002      	beq.n	8019bd6 <lcp_reqci+0x382>
 8019bd0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019bd2:	2b02      	cmp	r3, #2
 8019bd4:	d002      	beq.n	8019bdc <lcp_reqci+0x388>
		cilen != CILEN_VOID) {
		orc = CONFREJ;
 8019bd6:	2304      	movs	r3, #4
 8019bd8:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 8019bda:	e05f      	b.n	8019c9c <lcp_reqci+0x448>
	    }
	    ho->neg_pcompression = 1;
 8019bdc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019bde:	781a      	ldrb	r2, [r3, #0]
 8019be0:	2120      	movs	r1, #32
 8019be2:	430a      	orrs	r2, r1
 8019be4:	701a      	strb	r2, [r3, #0]
	    break;
 8019be6:	e059      	b.n	8019c9c <lcp_reqci+0x448>

	case CI_ACCOMPRESSION:
	    if (!ao->neg_accompression ||
 8019be8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019bea:	781b      	ldrb	r3, [r3, #0]
 8019bec:	2240      	movs	r2, #64	; 0x40
 8019bee:	4013      	ands	r3, r2
 8019bf0:	b2db      	uxtb	r3, r3
 8019bf2:	2b00      	cmp	r3, #0
 8019bf4:	d002      	beq.n	8019bfc <lcp_reqci+0x3a8>
 8019bf6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019bf8:	2b02      	cmp	r3, #2
 8019bfa:	d002      	beq.n	8019c02 <lcp_reqci+0x3ae>
		cilen != CILEN_VOID) {
		orc = CONFREJ;
 8019bfc:	2304      	movs	r3, #4
 8019bfe:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 8019c00:	e04c      	b.n	8019c9c <lcp_reqci+0x448>
	    }
	    ho->neg_accompression = 1;
 8019c02:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019c04:	781a      	ldrb	r2, [r3, #0]
 8019c06:	2140      	movs	r1, #64	; 0x40
 8019c08:	430a      	orrs	r2, r1
 8019c0a:	701a      	strb	r2, [r3, #0]
	    break;
 8019c0c:	e046      	b.n	8019c9c <lcp_reqci+0x448>
	    ho->mrru = cishort;
	    break;
#endif /* HAVE_MULTILINK */

	case CI_SSNHF:
	    if (!ao->neg_ssnhf
 8019c0e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019c10:	785b      	ldrb	r3, [r3, #1]
 8019c12:	2201      	movs	r2, #1
 8019c14:	4013      	ands	r3, r2
 8019c16:	b2db      	uxtb	r3, r3
 8019c18:	2b00      	cmp	r3, #0
 8019c1a:	d002      	beq.n	8019c22 <lcp_reqci+0x3ce>
#ifdef HAVE_MULTILINK
		|| !multilink
#endif /* HAVE_MULTILINK */
		|| cilen != CILEN_VOID) {
 8019c1c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019c1e:	2b02      	cmp	r3, #2
 8019c20:	d002      	beq.n	8019c28 <lcp_reqci+0x3d4>
		orc = CONFREJ;
 8019c22:	2304      	movs	r3, #4
 8019c24:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 8019c26:	e039      	b.n	8019c9c <lcp_reqci+0x448>
	    }
	    ho->neg_ssnhf = 1;
 8019c28:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019c2a:	785a      	ldrb	r2, [r3, #1]
 8019c2c:	2101      	movs	r1, #1
 8019c2e:	430a      	orrs	r2, r1
 8019c30:	705a      	strb	r2, [r3, #1]
	    break;
 8019c32:	e033      	b.n	8019c9c <lcp_reqci+0x448>

	case CI_EPDISC:
	    if (!ao->neg_endpoint ||
 8019c34:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019c36:	785b      	ldrb	r3, [r3, #1]
 8019c38:	2202      	movs	r2, #2
 8019c3a:	4013      	ands	r3, r2
 8019c3c:	b2db      	uxtb	r3, r3
 8019c3e:	2b00      	cmp	r3, #0
 8019c40:	d005      	beq.n	8019c4e <lcp_reqci+0x3fa>
 8019c42:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019c44:	2b02      	cmp	r3, #2
 8019c46:	dd02      	ble.n	8019c4e <lcp_reqci+0x3fa>
		cilen < CILEN_CHAR ||
 8019c48:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019c4a:	2b17      	cmp	r3, #23
 8019c4c:	dd02      	ble.n	8019c54 <lcp_reqci+0x400>
		cilen > CILEN_CHAR + MAX_ENDP_LEN) {
		orc = CONFREJ;
 8019c4e:	2304      	movs	r3, #4
 8019c50:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 8019c52:	e023      	b.n	8019c9c <lcp_reqci+0x448>
	    }
	    GETCHAR(cichar, p);
 8019c54:	6a3b      	ldr	r3, [r7, #32]
 8019c56:	1c5a      	adds	r2, r3, #1
 8019c58:	623a      	str	r2, [r7, #32]
 8019c5a:	781b      	ldrb	r3, [r3, #0]
 8019c5c:	61bb      	str	r3, [r7, #24]
	    cilen -= CILEN_CHAR;
 8019c5e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019c60:	3b03      	subs	r3, #3
 8019c62:	653b      	str	r3, [r7, #80]	; 0x50
	    ho->neg_endpoint = 1;
 8019c64:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019c66:	785a      	ldrb	r2, [r3, #1]
 8019c68:	2102      	movs	r1, #2
 8019c6a:	430a      	orrs	r2, r1
 8019c6c:	705a      	strb	r2, [r3, #1]
	    ho->endpoint.class_ = cichar;
 8019c6e:	69bb      	ldr	r3, [r7, #24]
 8019c70:	b2da      	uxtb	r2, r3
 8019c72:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019c74:	735a      	strb	r2, [r3, #13]
	    ho->endpoint.length = cilen;
 8019c76:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019c78:	b2da      	uxtb	r2, r3
 8019c7a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019c7c:	739a      	strb	r2, [r3, #14]
	    MEMCPY(ho->endpoint.value, p, cilen);
 8019c7e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019c80:	330f      	adds	r3, #15
 8019c82:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8019c84:	6a39      	ldr	r1, [r7, #32]
 8019c86:	0018      	movs	r0, r3
 8019c88:	f004 f988 	bl	801df9c <memcpy>
	    INCPTR(cilen, p);
 8019c8c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019c8e:	6a3a      	ldr	r2, [r7, #32]
 8019c90:	18d3      	adds	r3, r2, r3
 8019c92:	623b      	str	r3, [r7, #32]
	    break;
 8019c94:	e002      	b.n	8019c9c <lcp_reqci+0x448>

	default:
	    LCPDEBUG(("lcp_reqci: rcvd unknown option %d", citype));
	    orc = CONFREJ;
 8019c96:	2304      	movs	r3, #4
 8019c98:	647b      	str	r3, [r7, #68]	; 0x44
	    break;
 8019c9a:	46c0      	nop			; (mov r8, r8)
	}

endswitch:
	if (orc == CONFACK &&		/* Good CI */
 8019c9c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8019c9e:	2b02      	cmp	r3, #2
 8019ca0:	d108      	bne.n	8019cb4 <lcp_reqci+0x460>
 8019ca2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8019ca4:	2b02      	cmp	r3, #2
 8019ca6:	d005      	beq.n	8019cb4 <lcp_reqci+0x460>
	    rc != CONFACK)		/*  but prior CI wasnt? */
	    continue;			/* Don't send this one */
 8019ca8:	e029      	b.n	8019cfe <lcp_reqci+0x4aa>
 8019caa:	46c0      	nop			; (mov r8, r8)
 8019cac:	08023c98 	.word	0x08023c98
 8019cb0:	08022a08 	.word	0x08022a08

	if (orc == CONFNAK) {		/* Nak this CI? */
 8019cb4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8019cb6:	2b03      	cmp	r3, #3
 8019cb8:	d10e      	bne.n	8019cd8 <lcp_reqci+0x484>
	    if (reject_if_disagree	/* Getting fed up with sending NAKs? */
 8019cba:	683b      	ldr	r3, [r7, #0]
 8019cbc:	2b00      	cmp	r3, #0
 8019cbe:	d005      	beq.n	8019ccc <lcp_reqci+0x478>
		&& citype != CI_MAGICNUMBER) {
 8019cc0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8019cc2:	2b05      	cmp	r3, #5
 8019cc4:	d002      	beq.n	8019ccc <lcp_reqci+0x478>
		orc = CONFREJ;		/* Get tough if so */
 8019cc6:	2304      	movs	r3, #4
 8019cc8:	647b      	str	r3, [r7, #68]	; 0x44
 8019cca:	e005      	b.n	8019cd8 <lcp_reqci+0x484>
	    } else {
		if (rc == CONFREJ)	/* Rejecting prior CI? */
 8019ccc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8019cce:	2b04      	cmp	r3, #4
 8019cd0:	d100      	bne.n	8019cd4 <lcp_reqci+0x480>
		    continue;		/* Don't send this one */
 8019cd2:	e014      	b.n	8019cfe <lcp_reqci+0x4aa>
		rc = CONFNAK;
 8019cd4:	2303      	movs	r3, #3
 8019cd6:	64bb      	str	r3, [r7, #72]	; 0x48
	    }
	}
	if (orc == CONFREJ) {		/* Reject this CI */
 8019cd8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8019cda:	2b04      	cmp	r3, #4
 8019cdc:	d10f      	bne.n	8019cfe <lcp_reqci+0x4aa>
	    rc = CONFREJ;
 8019cde:	2304      	movs	r3, #4
 8019ce0:	64bb      	str	r3, [r7, #72]	; 0x48
	    if (cip != rejp)		/* Need to move rejected CI? */
 8019ce2:	69fa      	ldr	r2, [r7, #28]
 8019ce4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8019ce6:	429a      	cmp	r2, r3
 8019ce8:	d005      	beq.n	8019cf6 <lcp_reqci+0x4a2>
		MEMCPY(rejp, cip, cilen); /* Move it */
 8019cea:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8019cec:	69f9      	ldr	r1, [r7, #28]
 8019cee:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8019cf0:	0018      	movs	r0, r3
 8019cf2:	f004 f953 	bl	801df9c <memcpy>
	    INCPTR(cilen, rejp);	/* Update output pointer */
 8019cf6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019cf8:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8019cfa:	18d3      	adds	r3, r2, r3
 8019cfc:	643b      	str	r3, [r7, #64]	; 0x40
    while (l) {
 8019cfe:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8019d00:	2b00      	cmp	r3, #0
 8019d02:	d000      	beq.n	8019d06 <lcp_reqci+0x4b2>
 8019d04:	e5e7      	b.n	80198d6 <lcp_reqci+0x82>
     * code would go here.  The extra NAKs would go at *nakoutp.
     * At present there are no cases where we want to ask the
     * peer to negotiate an option.
     */

    switch (rc) {
 8019d06:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8019d08:	2b04      	cmp	r3, #4
 8019d0a:	d01f      	beq.n	8019d4c <lcp_reqci+0x4f8>
 8019d0c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8019d0e:	2b04      	cmp	r3, #4
 8019d10:	dc22      	bgt.n	8019d58 <lcp_reqci+0x504>
 8019d12:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8019d14:	2b02      	cmp	r3, #2
 8019d16:	d003      	beq.n	8019d20 <lcp_reqci+0x4cc>
 8019d18:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8019d1a:	2b03      	cmp	r3, #3
 8019d1c:	d006      	beq.n	8019d2c <lcp_reqci+0x4d8>
	break;
    case CONFREJ:
	*lenp = rejp - inp;
	break;
    default:
	break;
 8019d1e:	e01b      	b.n	8019d58 <lcp_reqci+0x504>
	*lenp = next - inp;
 8019d20:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8019d22:	68bb      	ldr	r3, [r7, #8]
 8019d24:	1ad2      	subs	r2, r2, r3
 8019d26:	687b      	ldr	r3, [r7, #4]
 8019d28:	601a      	str	r2, [r3, #0]
	break;
 8019d2a:	e016      	b.n	8019d5a <lcp_reqci+0x506>
	*lenp = nakoutp - (u_char*)nakp->payload;
 8019d2c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019d2e:	685b      	ldr	r3, [r3, #4]
 8019d30:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8019d32:	1ad2      	subs	r2, r2, r3
 8019d34:	687b      	ldr	r3, [r7, #4]
 8019d36:	601a      	str	r2, [r3, #0]
	MEMCPY(inp, nakp->payload, *lenp);
 8019d38:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019d3a:	6859      	ldr	r1, [r3, #4]
 8019d3c:	687b      	ldr	r3, [r7, #4]
 8019d3e:	681b      	ldr	r3, [r3, #0]
 8019d40:	001a      	movs	r2, r3
 8019d42:	68bb      	ldr	r3, [r7, #8]
 8019d44:	0018      	movs	r0, r3
 8019d46:	f004 f929 	bl	801df9c <memcpy>
	break;
 8019d4a:	e006      	b.n	8019d5a <lcp_reqci+0x506>
	*lenp = rejp - inp;
 8019d4c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8019d4e:	68bb      	ldr	r3, [r7, #8]
 8019d50:	1ad2      	subs	r2, r2, r3
 8019d52:	687b      	ldr	r3, [r7, #4]
 8019d54:	601a      	str	r2, [r3, #0]
	break;
 8019d56:	e000      	b.n	8019d5a <lcp_reqci+0x506>
	break;
 8019d58:	46c0      	nop			; (mov r8, r8)
    }

    pbuf_free(nakp);
 8019d5a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019d5c:	0018      	movs	r0, r3
 8019d5e:	f7f0 fbbd 	bl	800a4dc <pbuf_free>
    LCPDEBUG(("lcp_reqci: returning CONF%s.", CODENAME(rc)));
    return (rc);			/* Return final code */
 8019d62:	6cbb      	ldr	r3, [r7, #72]	; 0x48
}
 8019d64:	0018      	movs	r0, r3
 8019d66:	46bd      	mov	sp, r7
 8019d68:	b016      	add	sp, #88	; 0x58
 8019d6a:	bd80      	pop	{r7, pc}

08019d6c <lcp_up>:


/*
 * lcp_up - LCP has come UP.
 */
static void lcp_up(fsm *f) {
 8019d6c:	b590      	push	{r4, r7, lr}
 8019d6e:	b08d      	sub	sp, #52	; 0x34
 8019d70:	af02      	add	r7, sp, #8
 8019d72:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8019d74:	687b      	ldr	r3, [r7, #4]
 8019d76:	681b      	ldr	r3, [r3, #0]
 8019d78:	627b      	str	r3, [r7, #36]	; 0x24
    lcp_options *wo = &pcb->lcp_wantoptions;
 8019d7a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019d7c:	3344      	adds	r3, #68	; 0x44
 8019d7e:	623b      	str	r3, [r7, #32]
    lcp_options *ho = &pcb->lcp_hisoptions;
 8019d80:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019d82:	33b0      	adds	r3, #176	; 0xb0
 8019d84:	61fb      	str	r3, [r7, #28]
    lcp_options *go = &pcb->lcp_gotoptions;
 8019d86:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019d88:	3368      	adds	r3, #104	; 0x68
 8019d8a:	61bb      	str	r3, [r7, #24]
    lcp_options *ao = &pcb->lcp_allowoptions;
 8019d8c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019d8e:	338c      	adds	r3, #140	; 0x8c
 8019d90:	617b      	str	r3, [r7, #20]
    int mtu, mru;

    if (!go->neg_magicnumber)
 8019d92:	69bb      	ldr	r3, [r7, #24]
 8019d94:	781b      	ldrb	r3, [r3, #0]
 8019d96:	2210      	movs	r2, #16
 8019d98:	4013      	ands	r3, r2
 8019d9a:	b2db      	uxtb	r3, r3
 8019d9c:	2b00      	cmp	r3, #0
 8019d9e:	d102      	bne.n	8019da6 <lcp_up+0x3a>
	go->magicnumber = 0;
 8019da0:	69bb      	ldr	r3, [r7, #24]
 8019da2:	2200      	movs	r2, #0
 8019da4:	609a      	str	r2, [r3, #8]
    if (!ho->neg_magicnumber)
 8019da6:	69fb      	ldr	r3, [r7, #28]
 8019da8:	781b      	ldrb	r3, [r3, #0]
 8019daa:	2210      	movs	r2, #16
 8019dac:	4013      	ands	r3, r2
 8019dae:	b2db      	uxtb	r3, r3
 8019db0:	2b00      	cmp	r3, #0
 8019db2:	d102      	bne.n	8019dba <lcp_up+0x4e>
	ho->magicnumber = 0;
 8019db4:	69fb      	ldr	r3, [r7, #28]
 8019db6:	2200      	movs	r2, #0
 8019db8:	609a      	str	r2, [r3, #8]
     * the value we got in the negotiation.
     * Note on the MTU: the link MTU can be the MRU the peer wanted,
     * the interface MTU is set to the lowest of that, the
     * MTU we want to use, and our link MRU.
     */
    mtu = ho->neg_mru? ho->mru: PPP_MRU;
 8019dba:	69fb      	ldr	r3, [r7, #28]
 8019dbc:	781b      	ldrb	r3, [r3, #0]
 8019dbe:	2204      	movs	r2, #4
 8019dc0:	4013      	ands	r3, r2
 8019dc2:	b2db      	uxtb	r3, r3
 8019dc4:	2b00      	cmp	r3, #0
 8019dc6:	d002      	beq.n	8019dce <lcp_up+0x62>
 8019dc8:	69fb      	ldr	r3, [r7, #28]
 8019dca:	885b      	ldrh	r3, [r3, #2]
 8019dcc:	e000      	b.n	8019dd0 <lcp_up+0x64>
 8019dce:	4b42      	ldr	r3, [pc, #264]	; (8019ed8 <lcp_up+0x16c>)
 8019dd0:	613b      	str	r3, [r7, #16]
    mru = go->neg_mru? LWIP_MAX(wo->mru, go->mru): PPP_MRU;
 8019dd2:	69bb      	ldr	r3, [r7, #24]
 8019dd4:	781b      	ldrb	r3, [r3, #0]
 8019dd6:	2204      	movs	r2, #4
 8019dd8:	4013      	ands	r3, r2
 8019dda:	b2db      	uxtb	r3, r3
 8019ddc:	2b00      	cmp	r3, #0
 8019dde:	d00c      	beq.n	8019dfa <lcp_up+0x8e>
 8019de0:	69bb      	ldr	r3, [r7, #24]
 8019de2:	885a      	ldrh	r2, [r3, #2]
 8019de4:	6a3b      	ldr	r3, [r7, #32]
 8019de6:	885b      	ldrh	r3, [r3, #2]
 8019de8:	1c18      	adds	r0, r3, #0
 8019dea:	1c11      	adds	r1, r2, #0
 8019dec:	b28a      	uxth	r2, r1
 8019dee:	b283      	uxth	r3, r0
 8019df0:	429a      	cmp	r2, r3
 8019df2:	d200      	bcs.n	8019df6 <lcp_up+0x8a>
 8019df4:	1c01      	adds	r1, r0, #0
 8019df6:	b28b      	uxth	r3, r1
 8019df8:	e000      	b.n	8019dfc <lcp_up+0x90>
 8019dfa:	4b37      	ldr	r3, [pc, #220]	; (8019ed8 <lcp_up+0x16c>)
 8019dfc:	60fb      	str	r3, [r7, #12]
#ifdef HAVE_MULTILINK
    if (!(multilink && go->neg_mrru && ho->neg_mrru))
#endif /* HAVE_MULTILINK */
	netif_set_mtu(pcb, LWIP_MIN(LWIP_MIN(mtu, mru), ao->mru));
 8019dfe:	697b      	ldr	r3, [r7, #20]
 8019e00:	885b      	ldrh	r3, [r3, #2]
 8019e02:	0019      	movs	r1, r3
 8019e04:	693a      	ldr	r2, [r7, #16]
 8019e06:	68fb      	ldr	r3, [r7, #12]
 8019e08:	4293      	cmp	r3, r2
 8019e0a:	dd00      	ble.n	8019e0e <lcp_up+0xa2>
 8019e0c:	0013      	movs	r3, r2
 8019e0e:	000a      	movs	r2, r1
 8019e10:	429a      	cmp	r2, r3
 8019e12:	dd00      	ble.n	8019e16 <lcp_up+0xaa>
 8019e14:	001a      	movs	r2, r3
 8019e16:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019e18:	0011      	movs	r1, r2
 8019e1a:	0018      	movs	r0, r3
 8019e1c:	f000 ff20 	bl	801ac60 <netif_set_mtu>
    ppp_send_config(pcb, mtu,
		    (ho->neg_asyncmap? ho->asyncmap: 0xffffffff),
 8019e20:	69fb      	ldr	r3, [r7, #28]
 8019e22:	781b      	ldrb	r3, [r3, #0]
 8019e24:	2208      	movs	r2, #8
 8019e26:	4013      	ands	r3, r2
 8019e28:	b2db      	uxtb	r3, r3
    ppp_send_config(pcb, mtu,
 8019e2a:	2b00      	cmp	r3, #0
 8019e2c:	d002      	beq.n	8019e34 <lcp_up+0xc8>
 8019e2e:	69fb      	ldr	r3, [r7, #28]
 8019e30:	685a      	ldr	r2, [r3, #4]
 8019e32:	e001      	b.n	8019e38 <lcp_up+0xcc>
 8019e34:	2301      	movs	r3, #1
 8019e36:	425a      	negs	r2, r3
		    ho->neg_pcompression, ho->neg_accompression);
 8019e38:	69fb      	ldr	r3, [r7, #28]
 8019e3a:	781b      	ldrb	r3, [r3, #0]
 8019e3c:	069b      	lsls	r3, r3, #26
 8019e3e:	0fdb      	lsrs	r3, r3, #31
 8019e40:	b2db      	uxtb	r3, r3
    ppp_send_config(pcb, mtu,
 8019e42:	001c      	movs	r4, r3
		    ho->neg_pcompression, ho->neg_accompression);
 8019e44:	69fb      	ldr	r3, [r7, #28]
 8019e46:	781b      	ldrb	r3, [r3, #0]
 8019e48:	065b      	lsls	r3, r3, #25
 8019e4a:	0fdb      	lsrs	r3, r3, #31
 8019e4c:	b2db      	uxtb	r3, r3
    ppp_send_config(pcb, mtu,
 8019e4e:	6939      	ldr	r1, [r7, #16]
 8019e50:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8019e52:	9300      	str	r3, [sp, #0]
 8019e54:	0023      	movs	r3, r4
 8019e56:	f000 fde5 	bl	801aa24 <ppp_send_config>
    ppp_recv_config(pcb, mru,
		    (pcb->settings.lax_recv? 0: go->neg_asyncmap? go->asyncmap: 0xffffffff),
 8019e5a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019e5c:	781b      	ldrb	r3, [r3, #0]
 8019e5e:	2208      	movs	r2, #8
 8019e60:	4013      	ands	r3, r2
 8019e62:	b2db      	uxtb	r3, r3
    ppp_recv_config(pcb, mru,
 8019e64:	2b00      	cmp	r3, #0
 8019e66:	d10c      	bne.n	8019e82 <lcp_up+0x116>
		    (pcb->settings.lax_recv? 0: go->neg_asyncmap? go->asyncmap: 0xffffffff),
 8019e68:	69bb      	ldr	r3, [r7, #24]
 8019e6a:	781b      	ldrb	r3, [r3, #0]
 8019e6c:	2208      	movs	r2, #8
 8019e6e:	4013      	ands	r3, r2
 8019e70:	b2db      	uxtb	r3, r3
 8019e72:	2b00      	cmp	r3, #0
 8019e74:	d002      	beq.n	8019e7c <lcp_up+0x110>
 8019e76:	69bb      	ldr	r3, [r7, #24]
 8019e78:	685a      	ldr	r2, [r3, #4]
 8019e7a:	e003      	b.n	8019e84 <lcp_up+0x118>
 8019e7c:	2301      	movs	r3, #1
 8019e7e:	425a      	negs	r2, r3
 8019e80:	e000      	b.n	8019e84 <lcp_up+0x118>
    ppp_recv_config(pcb, mru,
 8019e82:	2200      	movs	r2, #0
		    go->neg_pcompression, go->neg_accompression);
 8019e84:	69bb      	ldr	r3, [r7, #24]
 8019e86:	781b      	ldrb	r3, [r3, #0]
 8019e88:	069b      	lsls	r3, r3, #26
 8019e8a:	0fdb      	lsrs	r3, r3, #31
 8019e8c:	b2db      	uxtb	r3, r3
    ppp_recv_config(pcb, mru,
 8019e8e:	001c      	movs	r4, r3
		    go->neg_pcompression, go->neg_accompression);
 8019e90:	69bb      	ldr	r3, [r7, #24]
 8019e92:	781b      	ldrb	r3, [r3, #0]
 8019e94:	065b      	lsls	r3, r3, #25
 8019e96:	0fdb      	lsrs	r3, r3, #31
 8019e98:	b2db      	uxtb	r3, r3
    ppp_recv_config(pcb, mru,
 8019e9a:	68f9      	ldr	r1, [r7, #12]
 8019e9c:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8019e9e:	9300      	str	r3, [sp, #0]
 8019ea0:	0023      	movs	r3, r4
 8019ea2:	f000 fddc 	bl	801aa5e <ppp_recv_config>

    if (ho->neg_mru)
 8019ea6:	69fb      	ldr	r3, [r7, #28]
 8019ea8:	781b      	ldrb	r3, [r3, #0]
 8019eaa:	2204      	movs	r2, #4
 8019eac:	4013      	ands	r3, r2
 8019eae:	b2db      	uxtb	r3, r3
 8019eb0:	2b00      	cmp	r3, #0
 8019eb2:	d004      	beq.n	8019ebe <lcp_up+0x152>
	pcb->peer_mru = ho->mru;
 8019eb4:	69fb      	ldr	r3, [r7, #28]
 8019eb6:	8859      	ldrh	r1, [r3, #2]
 8019eb8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019eba:	22d4      	movs	r2, #212	; 0xd4
 8019ebc:	5299      	strh	r1, [r3, r2]

    lcp_echo_lowerup(f->pcb);  /* Enable echo messages */
 8019ebe:	687b      	ldr	r3, [r7, #4]
 8019ec0:	681b      	ldr	r3, [r3, #0]
 8019ec2:	0018      	movs	r0, r3
 8019ec4:	f000 f9b0 	bl	801a228 <lcp_echo_lowerup>

    link_established(pcb);
 8019ec8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019eca:	0018      	movs	r0, r3
 8019ecc:	f7fa fdc6 	bl	8014a5c <link_established>
}
 8019ed0:	46c0      	nop			; (mov r8, r8)
 8019ed2:	46bd      	mov	sp, r7
 8019ed4:	b00b      	add	sp, #44	; 0x2c
 8019ed6:	bd90      	pop	{r4, r7, pc}
 8019ed8:	000005dc 	.word	0x000005dc

08019edc <lcp_down>:
/*
 * lcp_down - LCP has gone DOWN.
 *
 * Alert other protocols.
 */
static void lcp_down(fsm *f) {
 8019edc:	b590      	push	{r4, r7, lr}
 8019ede:	b087      	sub	sp, #28
 8019ee0:	af02      	add	r7, sp, #8
 8019ee2:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8019ee4:	687b      	ldr	r3, [r7, #4]
 8019ee6:	681b      	ldr	r3, [r3, #0]
 8019ee8:	60fb      	str	r3, [r7, #12]
    lcp_options *go = &pcb->lcp_gotoptions;
 8019eea:	68fb      	ldr	r3, [r7, #12]
 8019eec:	3368      	adds	r3, #104	; 0x68
 8019eee:	60bb      	str	r3, [r7, #8]

    lcp_echo_lowerdown(f->pcb);
 8019ef0:	687b      	ldr	r3, [r7, #4]
 8019ef2:	681b      	ldr	r3, [r3, #0]
 8019ef4:	0018      	movs	r0, r3
 8019ef6:	f000 f9b9 	bl	801a26c <lcp_echo_lowerdown>

    link_down(pcb);
 8019efa:	68fb      	ldr	r3, [r7, #12]
 8019efc:	0018      	movs	r0, r3
 8019efe:	f7fa fd53 	bl	80149a8 <link_down>

    ppp_send_config(pcb, PPP_MRU, 0xffffffff, 0, 0);
 8019f02:	2301      	movs	r3, #1
 8019f04:	425a      	negs	r2, r3
 8019f06:	4916      	ldr	r1, [pc, #88]	; (8019f60 <lcp_down+0x84>)
 8019f08:	68f8      	ldr	r0, [r7, #12]
 8019f0a:	2300      	movs	r3, #0
 8019f0c:	9300      	str	r3, [sp, #0]
 8019f0e:	2300      	movs	r3, #0
 8019f10:	f000 fd88 	bl	801aa24 <ppp_send_config>
    ppp_recv_config(pcb, PPP_MRU,
		    (go->neg_asyncmap? go->asyncmap: 0xffffffff),
 8019f14:	68bb      	ldr	r3, [r7, #8]
 8019f16:	781b      	ldrb	r3, [r3, #0]
 8019f18:	2208      	movs	r2, #8
 8019f1a:	4013      	ands	r3, r2
 8019f1c:	b2db      	uxtb	r3, r3
    ppp_recv_config(pcb, PPP_MRU,
 8019f1e:	2b00      	cmp	r3, #0
 8019f20:	d002      	beq.n	8019f28 <lcp_down+0x4c>
 8019f22:	68bb      	ldr	r3, [r7, #8]
 8019f24:	685a      	ldr	r2, [r3, #4]
 8019f26:	e001      	b.n	8019f2c <lcp_down+0x50>
 8019f28:	2301      	movs	r3, #1
 8019f2a:	425a      	negs	r2, r3
		    go->neg_pcompression, go->neg_accompression);
 8019f2c:	68bb      	ldr	r3, [r7, #8]
 8019f2e:	781b      	ldrb	r3, [r3, #0]
 8019f30:	069b      	lsls	r3, r3, #26
 8019f32:	0fdb      	lsrs	r3, r3, #31
 8019f34:	b2db      	uxtb	r3, r3
    ppp_recv_config(pcb, PPP_MRU,
 8019f36:	001c      	movs	r4, r3
		    go->neg_pcompression, go->neg_accompression);
 8019f38:	68bb      	ldr	r3, [r7, #8]
 8019f3a:	781b      	ldrb	r3, [r3, #0]
 8019f3c:	065b      	lsls	r3, r3, #25
 8019f3e:	0fdb      	lsrs	r3, r3, #31
 8019f40:	b2db      	uxtb	r3, r3
    ppp_recv_config(pcb, PPP_MRU,
 8019f42:	4907      	ldr	r1, [pc, #28]	; (8019f60 <lcp_down+0x84>)
 8019f44:	68f8      	ldr	r0, [r7, #12]
 8019f46:	9300      	str	r3, [sp, #0]
 8019f48:	0023      	movs	r3, r4
 8019f4a:	f000 fd88 	bl	801aa5e <ppp_recv_config>
    pcb->peer_mru = PPP_MRU;
 8019f4e:	68fb      	ldr	r3, [r7, #12]
 8019f50:	22d4      	movs	r2, #212	; 0xd4
 8019f52:	4903      	ldr	r1, [pc, #12]	; (8019f60 <lcp_down+0x84>)
 8019f54:	5299      	strh	r1, [r3, r2]
}
 8019f56:	46c0      	nop			; (mov r8, r8)
 8019f58:	46bd      	mov	sp, r7
 8019f5a:	b005      	add	sp, #20
 8019f5c:	bd90      	pop	{r4, r7, pc}
 8019f5e:	46c0      	nop			; (mov r8, r8)
 8019f60:	000005dc 	.word	0x000005dc

08019f64 <lcp_starting>:


/*
 * lcp_starting - LCP needs the lower layer up.
 */
static void lcp_starting(fsm *f) {
 8019f64:	b580      	push	{r7, lr}
 8019f66:	b084      	sub	sp, #16
 8019f68:	af00      	add	r7, sp, #0
 8019f6a:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8019f6c:	687b      	ldr	r3, [r7, #4]
 8019f6e:	681b      	ldr	r3, [r3, #0]
 8019f70:	60fb      	str	r3, [r7, #12]
    link_required(pcb);
 8019f72:	68fb      	ldr	r3, [r7, #12]
 8019f74:	0018      	movs	r0, r3
 8019f76:	f7fa fced 	bl	8014954 <link_required>
}
 8019f7a:	46c0      	nop			; (mov r8, r8)
 8019f7c:	46bd      	mov	sp, r7
 8019f7e:	b004      	add	sp, #16
 8019f80:	bd80      	pop	{r7, pc}

08019f82 <lcp_finished>:


/*
 * lcp_finished - LCP has finished with the lower layer.
 */
static void lcp_finished(fsm *f) {
 8019f82:	b580      	push	{r7, lr}
 8019f84:	b084      	sub	sp, #16
 8019f86:	af00      	add	r7, sp, #0
 8019f88:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8019f8a:	687b      	ldr	r3, [r7, #4]
 8019f8c:	681b      	ldr	r3, [r3, #0]
 8019f8e:	60fb      	str	r3, [r7, #12]
    link_terminated(pcb);
 8019f90:	68fb      	ldr	r3, [r7, #12]
 8019f92:	0018      	movs	r0, r3
 8019f94:	f7fa fce6 	bl	8014964 <link_terminated>
}
 8019f98:	46c0      	nop			; (mov r8, r8)
 8019f9a:	46bd      	mov	sp, r7
 8019f9c:	b004      	add	sp, #16
 8019f9e:	bd80      	pop	{r7, pc}

08019fa0 <LcpLinkFailure>:

/*
 * Time to shut down the link because there is nothing out there.
 */

static void LcpLinkFailure(fsm *f) {
 8019fa0:	b580      	push	{r7, lr}
 8019fa2:	b084      	sub	sp, #16
 8019fa4:	af00      	add	r7, sp, #0
 8019fa6:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8019fa8:	687b      	ldr	r3, [r7, #4]
 8019faa:	681b      	ldr	r3, [r3, #0]
 8019fac:	60fb      	str	r3, [r7, #12]
    if (f->state == PPP_FSM_OPENED) {
 8019fae:	687b      	ldr	r3, [r7, #4]
 8019fb0:	7c1b      	ldrb	r3, [r3, #16]
 8019fb2:	2b09      	cmp	r3, #9
 8019fb4:	d116      	bne.n	8019fe4 <LcpLinkFailure+0x44>
	ppp_info("No response to %d echo-requests", pcb->lcp_echos_pending);
 8019fb6:	68fb      	ldr	r3, [r7, #12]
 8019fb8:	22d6      	movs	r2, #214	; 0xd6
 8019fba:	5c9b      	ldrb	r3, [r3, r2]
 8019fbc:	001a      	movs	r2, r3
 8019fbe:	4b0b      	ldr	r3, [pc, #44]	; (8019fec <LcpLinkFailure+0x4c>)
 8019fc0:	0011      	movs	r1, r2
 8019fc2:	0018      	movs	r0, r3
 8019fc4:	f001 fff9 	bl	801bfba <ppp_info>
        ppp_notice("Serial link appears to be disconnected.");
 8019fc8:	4b09      	ldr	r3, [pc, #36]	; (8019ff0 <LcpLinkFailure+0x50>)
 8019fca:	0018      	movs	r0, r3
 8019fcc:	f001 ffe1 	bl	801bf92 <ppp_notice>
	pcb->err_code = PPPERR_PEERDEAD;
 8019fd0:	68fb      	ldr	r3, [r7, #12]
 8019fd2:	2225      	movs	r2, #37	; 0x25
 8019fd4:	2109      	movs	r1, #9
 8019fd6:	5499      	strb	r1, [r3, r2]
	lcp_close(pcb, "Peer not responding");
 8019fd8:	4a06      	ldr	r2, [pc, #24]	; (8019ff4 <LcpLinkFailure+0x54>)
 8019fda:	68fb      	ldr	r3, [r7, #12]
 8019fdc:	0011      	movs	r1, r2
 8019fde:	0018      	movs	r0, r3
 8019fe0:	f7fe f92e 	bl	8018240 <lcp_close>
    }
}
 8019fe4:	46c0      	nop			; (mov r8, r8)
 8019fe6:	46bd      	mov	sp, r7
 8019fe8:	b004      	add	sp, #16
 8019fea:	bd80      	pop	{r7, pc}
 8019fec:	08022a1c 	.word	0x08022a1c
 8019ff0:	08022a3c 	.word	0x08022a3c
 8019ff4:	08022a64 	.word	0x08022a64

08019ff8 <LcpEchoCheck>:

/*
 * Timer expired for the LCP echo requests from this process.
 */

static void LcpEchoCheck(fsm *f) {
 8019ff8:	b580      	push	{r7, lr}
 8019ffa:	b084      	sub	sp, #16
 8019ffc:	af00      	add	r7, sp, #0
 8019ffe:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 801a000:	687b      	ldr	r3, [r7, #4]
 801a002:	681b      	ldr	r3, [r3, #0]
 801a004:	60fb      	str	r3, [r7, #12]

    LcpSendEchoRequest (f);
 801a006:	687b      	ldr	r3, [r7, #4]
 801a008:	0018      	movs	r0, r3
 801a00a:	f000 f8ad 	bl	801a168 <LcpSendEchoRequest>
    if (f->state != PPP_FSM_OPENED)
 801a00e:	687b      	ldr	r3, [r7, #4]
 801a010:	7c1b      	ldrb	r3, [r3, #16]
 801a012:	2b09      	cmp	r3, #9
 801a014:	d127      	bne.n	801a066 <LcpEchoCheck+0x6e>
	return;

    /*
     * Start the timer for the next interval.
     */
    if (pcb->lcp_echo_timer_running)
 801a016:	68fb      	ldr	r3, [r7, #12]
 801a018:	2226      	movs	r2, #38	; 0x26
 801a01a:	5c9b      	ldrb	r3, [r3, r2]
 801a01c:	2210      	movs	r2, #16
 801a01e:	4013      	ands	r3, r2
 801a020:	b2db      	uxtb	r3, r3
 801a022:	2b00      	cmp	r3, #0
 801a024:	d003      	beq.n	801a02e <LcpEchoCheck+0x36>
	ppp_warn("assertion lcp_echo_timer_running==0 failed");
 801a026:	4b12      	ldr	r3, [pc, #72]	; (801a070 <LcpEchoCheck+0x78>)
 801a028:	0018      	movs	r0, r3
 801a02a:	f001 ff9e 	bl	801bf6a <ppp_warn>
    TIMEOUT (LcpEchoTimeout, f, pcb->settings.lcp_echo_interval);
 801a02e:	687a      	ldr	r2, [r7, #4]
 801a030:	4b10      	ldr	r3, [pc, #64]	; (801a074 <LcpEchoCheck+0x7c>)
 801a032:	0011      	movs	r1, r2
 801a034:	0018      	movs	r0, r3
 801a036:	f7f8 fd3d 	bl	8012ab4 <sys_untimeout>
 801a03a:	68fb      	ldr	r3, [r7, #12]
 801a03c:	7a5b      	ldrb	r3, [r3, #9]
 801a03e:	001a      	movs	r2, r3
 801a040:	0013      	movs	r3, r2
 801a042:	015b      	lsls	r3, r3, #5
 801a044:	1a9b      	subs	r3, r3, r2
 801a046:	009b      	lsls	r3, r3, #2
 801a048:	189b      	adds	r3, r3, r2
 801a04a:	00db      	lsls	r3, r3, #3
 801a04c:	0018      	movs	r0, r3
 801a04e:	687a      	ldr	r2, [r7, #4]
 801a050:	4b08      	ldr	r3, [pc, #32]	; (801a074 <LcpEchoCheck+0x7c>)
 801a052:	0019      	movs	r1, r3
 801a054:	f7f8 fd06 	bl	8012a64 <sys_timeout>
    pcb->lcp_echo_timer_running = 1;
 801a058:	68fb      	ldr	r3, [r7, #12]
 801a05a:	2226      	movs	r2, #38	; 0x26
 801a05c:	5c99      	ldrb	r1, [r3, r2]
 801a05e:	2010      	movs	r0, #16
 801a060:	4301      	orrs	r1, r0
 801a062:	5499      	strb	r1, [r3, r2]
 801a064:	e000      	b.n	801a068 <LcpEchoCheck+0x70>
	return;
 801a066:	46c0      	nop			; (mov r8, r8)
}
 801a068:	46bd      	mov	sp, r7
 801a06a:	b004      	add	sp, #16
 801a06c:	bd80      	pop	{r7, pc}
 801a06e:	46c0      	nop			; (mov r8, r8)
 801a070:	08022a78 	.word	0x08022a78
 801a074:	0801a079 	.word	0x0801a079

0801a078 <LcpEchoTimeout>:

/*
 * LcpEchoTimeout - Timer expired on the LCP echo
 */

static void LcpEchoTimeout(void *arg) {
 801a078:	b580      	push	{r7, lr}
 801a07a:	b084      	sub	sp, #16
 801a07c:	af00      	add	r7, sp, #0
 801a07e:	6078      	str	r0, [r7, #4]
    fsm *f = (fsm*)arg;
 801a080:	687b      	ldr	r3, [r7, #4]
 801a082:	60fb      	str	r3, [r7, #12]
    ppp_pcb *pcb = f->pcb;
 801a084:	68fb      	ldr	r3, [r7, #12]
 801a086:	681b      	ldr	r3, [r3, #0]
 801a088:	60bb      	str	r3, [r7, #8]
    if (pcb->lcp_echo_timer_running != 0) {
 801a08a:	68bb      	ldr	r3, [r7, #8]
 801a08c:	2226      	movs	r2, #38	; 0x26
 801a08e:	5c9b      	ldrb	r3, [r3, r2]
 801a090:	2210      	movs	r2, #16
 801a092:	4013      	ands	r3, r2
 801a094:	b2db      	uxtb	r3, r3
 801a096:	2b00      	cmp	r3, #0
 801a098:	d009      	beq.n	801a0ae <LcpEchoTimeout+0x36>
        pcb->lcp_echo_timer_running = 0;
 801a09a:	68bb      	ldr	r3, [r7, #8]
 801a09c:	2226      	movs	r2, #38	; 0x26
 801a09e:	5c99      	ldrb	r1, [r3, r2]
 801a0a0:	2010      	movs	r0, #16
 801a0a2:	4381      	bics	r1, r0
 801a0a4:	5499      	strb	r1, [r3, r2]
        LcpEchoCheck ((fsm *) arg);
 801a0a6:	687b      	ldr	r3, [r7, #4]
 801a0a8:	0018      	movs	r0, r3
 801a0aa:	f7ff ffa5 	bl	8019ff8 <LcpEchoCheck>
    }
}
 801a0ae:	46c0      	nop			; (mov r8, r8)
 801a0b0:	46bd      	mov	sp, r7
 801a0b2:	b004      	add	sp, #16
 801a0b4:	bd80      	pop	{r7, pc}
	...

0801a0b8 <lcp_received_echo_reply>:

/*
 * LcpEchoReply - LCP has received a reply to the echo
 */

static void lcp_received_echo_reply(fsm *f, int id, u_char *inp, int len) {
 801a0b8:	b580      	push	{r7, lr}
 801a0ba:	b088      	sub	sp, #32
 801a0bc:	af00      	add	r7, sp, #0
 801a0be:	60f8      	str	r0, [r7, #12]
 801a0c0:	60b9      	str	r1, [r7, #8]
 801a0c2:	607a      	str	r2, [r7, #4]
 801a0c4:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 801a0c6:	68fb      	ldr	r3, [r7, #12]
 801a0c8:	681b      	ldr	r3, [r3, #0]
 801a0ca:	61fb      	str	r3, [r7, #28]
    lcp_options *go = &pcb->lcp_gotoptions;
 801a0cc:	69fb      	ldr	r3, [r7, #28]
 801a0ce:	3368      	adds	r3, #104	; 0x68
 801a0d0:	61bb      	str	r3, [r7, #24]
    u32_t magic_val;
    LWIP_UNUSED_ARG(id);

    /* Check the magic number - don't count replies from ourselves. */
    if (len < 4) {
 801a0d2:	683b      	ldr	r3, [r7, #0]
 801a0d4:	2b03      	cmp	r3, #3
 801a0d6:	dc06      	bgt.n	801a0e6 <lcp_received_echo_reply+0x2e>
	ppp_dbglog("lcp: received short Echo-Reply, length %d", len);
 801a0d8:	683a      	ldr	r2, [r7, #0]
 801a0da:	4b21      	ldr	r3, [pc, #132]	; (801a160 <lcp_received_echo_reply+0xa8>)
 801a0dc:	0011      	movs	r1, r2
 801a0de:	0018      	movs	r0, r3
 801a0e0:	f001 ff7f 	bl	801bfe2 <ppp_dbglog>
	return;
 801a0e4:	e038      	b.n	801a158 <lcp_received_echo_reply+0xa0>
    }
    GETLONG(magic_val, inp);
 801a0e6:	687b      	ldr	r3, [r7, #4]
 801a0e8:	1c5a      	adds	r2, r3, #1
 801a0ea:	607a      	str	r2, [r7, #4]
 801a0ec:	781b      	ldrb	r3, [r3, #0]
 801a0ee:	021b      	lsls	r3, r3, #8
 801a0f0:	617b      	str	r3, [r7, #20]
 801a0f2:	687b      	ldr	r3, [r7, #4]
 801a0f4:	1c5a      	adds	r2, r3, #1
 801a0f6:	607a      	str	r2, [r7, #4]
 801a0f8:	781b      	ldrb	r3, [r3, #0]
 801a0fa:	001a      	movs	r2, r3
 801a0fc:	697b      	ldr	r3, [r7, #20]
 801a0fe:	4313      	orrs	r3, r2
 801a100:	617b      	str	r3, [r7, #20]
 801a102:	697b      	ldr	r3, [r7, #20]
 801a104:	021b      	lsls	r3, r3, #8
 801a106:	617b      	str	r3, [r7, #20]
 801a108:	687b      	ldr	r3, [r7, #4]
 801a10a:	1c5a      	adds	r2, r3, #1
 801a10c:	607a      	str	r2, [r7, #4]
 801a10e:	781b      	ldrb	r3, [r3, #0]
 801a110:	001a      	movs	r2, r3
 801a112:	697b      	ldr	r3, [r7, #20]
 801a114:	4313      	orrs	r3, r2
 801a116:	617b      	str	r3, [r7, #20]
 801a118:	697b      	ldr	r3, [r7, #20]
 801a11a:	021b      	lsls	r3, r3, #8
 801a11c:	617b      	str	r3, [r7, #20]
 801a11e:	687b      	ldr	r3, [r7, #4]
 801a120:	1c5a      	adds	r2, r3, #1
 801a122:	607a      	str	r2, [r7, #4]
 801a124:	781b      	ldrb	r3, [r3, #0]
 801a126:	001a      	movs	r2, r3
 801a128:	697b      	ldr	r3, [r7, #20]
 801a12a:	4313      	orrs	r3, r2
 801a12c:	617b      	str	r3, [r7, #20]
    if (go->neg_magicnumber
 801a12e:	69bb      	ldr	r3, [r7, #24]
 801a130:	781b      	ldrb	r3, [r3, #0]
 801a132:	2210      	movs	r2, #16
 801a134:	4013      	ands	r3, r2
 801a136:	b2db      	uxtb	r3, r3
 801a138:	2b00      	cmp	r3, #0
 801a13a:	d009      	beq.n	801a150 <lcp_received_echo_reply+0x98>
	&& magic_val == go->magicnumber) {
 801a13c:	69bb      	ldr	r3, [r7, #24]
 801a13e:	689b      	ldr	r3, [r3, #8]
 801a140:	697a      	ldr	r2, [r7, #20]
 801a142:	429a      	cmp	r2, r3
 801a144:	d104      	bne.n	801a150 <lcp_received_echo_reply+0x98>
	ppp_warn("appear to have received our own echo-reply!");
 801a146:	4b07      	ldr	r3, [pc, #28]	; (801a164 <lcp_received_echo_reply+0xac>)
 801a148:	0018      	movs	r0, r3
 801a14a:	f001 ff0e 	bl	801bf6a <ppp_warn>
	return;
 801a14e:	e003      	b.n	801a158 <lcp_received_echo_reply+0xa0>
    }

    /* Reset the number of outstanding echo frames */
    pcb->lcp_echos_pending = 0;
 801a150:	69fb      	ldr	r3, [r7, #28]
 801a152:	22d6      	movs	r2, #214	; 0xd6
 801a154:	2100      	movs	r1, #0
 801a156:	5499      	strb	r1, [r3, r2]
}
 801a158:	46bd      	mov	sp, r7
 801a15a:	b008      	add	sp, #32
 801a15c:	bd80      	pop	{r7, pc}
 801a15e:	46c0      	nop			; (mov r8, r8)
 801a160:	08022aa4 	.word	0x08022aa4
 801a164:	08022ad0 	.word	0x08022ad0

0801a168 <LcpSendEchoRequest>:

/*
 * LcpSendEchoRequest - Send an echo request frame to the peer
 */

static void LcpSendEchoRequest(fsm *f) {
 801a168:	b590      	push	{r4, r7, lr}
 801a16a:	b08b      	sub	sp, #44	; 0x2c
 801a16c:	af02      	add	r7, sp, #8
 801a16e:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 801a170:	687b      	ldr	r3, [r7, #4]
 801a172:	681b      	ldr	r3, [r3, #0]
 801a174:	61fb      	str	r3, [r7, #28]
    lcp_options *go = &pcb->lcp_gotoptions;
 801a176:	69fb      	ldr	r3, [r7, #28]
 801a178:	3368      	adds	r3, #104	; 0x68
 801a17a:	61bb      	str	r3, [r7, #24]
    u_char pkt[4], *pktp;

    /*
     * Detect the failure of the peer at this point.
     */
    if (pcb->settings.lcp_echo_fails != 0) {
 801a17c:	69fb      	ldr	r3, [r7, #28]
 801a17e:	7a9b      	ldrb	r3, [r3, #10]
 801a180:	2b00      	cmp	r3, #0
 801a182:	d00e      	beq.n	801a1a2 <LcpSendEchoRequest+0x3a>
        if (pcb->lcp_echos_pending >= pcb->settings.lcp_echo_fails) {
 801a184:	69fb      	ldr	r3, [r7, #28]
 801a186:	22d6      	movs	r2, #214	; 0xd6
 801a188:	5c9a      	ldrb	r2, [r3, r2]
 801a18a:	69fb      	ldr	r3, [r7, #28]
 801a18c:	7a9b      	ldrb	r3, [r3, #10]
 801a18e:	429a      	cmp	r2, r3
 801a190:	d307      	bcc.n	801a1a2 <LcpSendEchoRequest+0x3a>
            LcpLinkFailure(f);
 801a192:	687b      	ldr	r3, [r7, #4]
 801a194:	0018      	movs	r0, r3
 801a196:	f7ff ff03 	bl	8019fa0 <LcpLinkFailure>
            pcb->lcp_echos_pending = 0;
 801a19a:	69fb      	ldr	r3, [r7, #28]
 801a19c:	22d6      	movs	r2, #214	; 0xd6
 801a19e:	2100      	movs	r1, #0
 801a1a0:	5499      	strb	r1, [r3, r2]
#endif

    /*
     * Make and send the echo request frame.
     */
    if (f->state == PPP_FSM_OPENED) {
 801a1a2:	687b      	ldr	r3, [r7, #4]
 801a1a4:	7c1b      	ldrb	r3, [r3, #16]
 801a1a6:	2b09      	cmp	r3, #9
 801a1a8:	d13a      	bne.n	801a220 <LcpSendEchoRequest+0xb8>
        lcp_magic = go->magicnumber;
 801a1aa:	69bb      	ldr	r3, [r7, #24]
 801a1ac:	689b      	ldr	r3, [r3, #8]
 801a1ae:	617b      	str	r3, [r7, #20]
	pktp = pkt;
 801a1b0:	240c      	movs	r4, #12
 801a1b2:	193b      	adds	r3, r7, r4
 801a1b4:	613b      	str	r3, [r7, #16]
	PUTLONG(lcp_magic, pktp);
 801a1b6:	697b      	ldr	r3, [r7, #20]
 801a1b8:	0e19      	lsrs	r1, r3, #24
 801a1ba:	693b      	ldr	r3, [r7, #16]
 801a1bc:	1c5a      	adds	r2, r3, #1
 801a1be:	613a      	str	r2, [r7, #16]
 801a1c0:	b2ca      	uxtb	r2, r1
 801a1c2:	701a      	strb	r2, [r3, #0]
 801a1c4:	697b      	ldr	r3, [r7, #20]
 801a1c6:	0c19      	lsrs	r1, r3, #16
 801a1c8:	693b      	ldr	r3, [r7, #16]
 801a1ca:	1c5a      	adds	r2, r3, #1
 801a1cc:	613a      	str	r2, [r7, #16]
 801a1ce:	b2ca      	uxtb	r2, r1
 801a1d0:	701a      	strb	r2, [r3, #0]
 801a1d2:	697b      	ldr	r3, [r7, #20]
 801a1d4:	0a19      	lsrs	r1, r3, #8
 801a1d6:	693b      	ldr	r3, [r7, #16]
 801a1d8:	1c5a      	adds	r2, r3, #1
 801a1da:	613a      	str	r2, [r7, #16]
 801a1dc:	b2ca      	uxtb	r2, r1
 801a1de:	701a      	strb	r2, [r3, #0]
 801a1e0:	693b      	ldr	r3, [r7, #16]
 801a1e2:	1c5a      	adds	r2, r3, #1
 801a1e4:	613a      	str	r2, [r7, #16]
 801a1e6:	697a      	ldr	r2, [r7, #20]
 801a1e8:	b2d2      	uxtb	r2, r2
 801a1ea:	701a      	strb	r2, [r3, #0]
        fsm_sdata(f, ECHOREQ, pcb->lcp_echo_number++, pkt, pktp - pkt);
 801a1ec:	69fb      	ldr	r3, [r7, #28]
 801a1ee:	22d7      	movs	r2, #215	; 0xd7
 801a1f0:	5c9a      	ldrb	r2, [r3, r2]
 801a1f2:	1c53      	adds	r3, r2, #1
 801a1f4:	b2d8      	uxtb	r0, r3
 801a1f6:	69fb      	ldr	r3, [r7, #28]
 801a1f8:	21d7      	movs	r1, #215	; 0xd7
 801a1fa:	5458      	strb	r0, [r3, r1]
 801a1fc:	193b      	adds	r3, r7, r4
 801a1fe:	6939      	ldr	r1, [r7, #16]
 801a200:	1acb      	subs	r3, r1, r3
 801a202:	1939      	adds	r1, r7, r4
 801a204:	6878      	ldr	r0, [r7, #4]
 801a206:	9300      	str	r3, [sp, #0]
 801a208:	000b      	movs	r3, r1
 801a20a:	2109      	movs	r1, #9
 801a20c:	f7fb fc1e 	bl	8015a4c <fsm_sdata>
	++pcb->lcp_echos_pending;
 801a210:	69fb      	ldr	r3, [r7, #28]
 801a212:	22d6      	movs	r2, #214	; 0xd6
 801a214:	5c9b      	ldrb	r3, [r3, r2]
 801a216:	3301      	adds	r3, #1
 801a218:	b2d9      	uxtb	r1, r3
 801a21a:	69fb      	ldr	r3, [r7, #28]
 801a21c:	22d6      	movs	r2, #214	; 0xd6
 801a21e:	5499      	strb	r1, [r3, r2]
    }
}
 801a220:	46c0      	nop			; (mov r8, r8)
 801a222:	46bd      	mov	sp, r7
 801a224:	b009      	add	sp, #36	; 0x24
 801a226:	bd90      	pop	{r4, r7, pc}

0801a228 <lcp_echo_lowerup>:

/*
 * lcp_echo_lowerup - Start the timer for the LCP frame
 */

static void lcp_echo_lowerup(ppp_pcb *pcb) {
 801a228:	b580      	push	{r7, lr}
 801a22a:	b084      	sub	sp, #16
 801a22c:	af00      	add	r7, sp, #0
 801a22e:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->lcp_fsm;
 801a230:	687b      	ldr	r3, [r7, #4]
 801a232:	3328      	adds	r3, #40	; 0x28
 801a234:	60fb      	str	r3, [r7, #12]

    /* Clear the parameters for generating echo frames */
    pcb->lcp_echos_pending      = 0;
 801a236:	687b      	ldr	r3, [r7, #4]
 801a238:	22d6      	movs	r2, #214	; 0xd6
 801a23a:	2100      	movs	r1, #0
 801a23c:	5499      	strb	r1, [r3, r2]
    pcb->lcp_echo_number        = 0;
 801a23e:	687b      	ldr	r3, [r7, #4]
 801a240:	22d7      	movs	r2, #215	; 0xd7
 801a242:	2100      	movs	r1, #0
 801a244:	5499      	strb	r1, [r3, r2]
    pcb->lcp_echo_timer_running = 0;
 801a246:	687b      	ldr	r3, [r7, #4]
 801a248:	2226      	movs	r2, #38	; 0x26
 801a24a:	5c99      	ldrb	r1, [r3, r2]
 801a24c:	2010      	movs	r0, #16
 801a24e:	4381      	bics	r1, r0
 801a250:	5499      	strb	r1, [r3, r2]
  
    /* If a timeout interval is specified then start the timer */
    if (pcb->settings.lcp_echo_interval != 0)
 801a252:	687b      	ldr	r3, [r7, #4]
 801a254:	7a5b      	ldrb	r3, [r3, #9]
 801a256:	2b00      	cmp	r3, #0
 801a258:	d003      	beq.n	801a262 <lcp_echo_lowerup+0x3a>
        LcpEchoCheck (f);
 801a25a:	68fb      	ldr	r3, [r7, #12]
 801a25c:	0018      	movs	r0, r3
 801a25e:	f7ff fecb 	bl	8019ff8 <LcpEchoCheck>
}
 801a262:	46c0      	nop			; (mov r8, r8)
 801a264:	46bd      	mov	sp, r7
 801a266:	b004      	add	sp, #16
 801a268:	bd80      	pop	{r7, pc}
	...

0801a26c <lcp_echo_lowerdown>:

/*
 * lcp_echo_lowerdown - Stop the timer for the LCP frame
 */

static void lcp_echo_lowerdown(ppp_pcb *pcb) {
 801a26c:	b580      	push	{r7, lr}
 801a26e:	b084      	sub	sp, #16
 801a270:	af00      	add	r7, sp, #0
 801a272:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->lcp_fsm;
 801a274:	687b      	ldr	r3, [r7, #4]
 801a276:	3328      	adds	r3, #40	; 0x28
 801a278:	60fb      	str	r3, [r7, #12]

    if (pcb->lcp_echo_timer_running != 0) {
 801a27a:	687b      	ldr	r3, [r7, #4]
 801a27c:	2226      	movs	r2, #38	; 0x26
 801a27e:	5c9b      	ldrb	r3, [r3, r2]
 801a280:	2210      	movs	r2, #16
 801a282:	4013      	ands	r3, r2
 801a284:	b2db      	uxtb	r3, r3
 801a286:	2b00      	cmp	r3, #0
 801a288:	d00b      	beq.n	801a2a2 <lcp_echo_lowerdown+0x36>
        UNTIMEOUT (LcpEchoTimeout, f);
 801a28a:	68fa      	ldr	r2, [r7, #12]
 801a28c:	4b07      	ldr	r3, [pc, #28]	; (801a2ac <lcp_echo_lowerdown+0x40>)
 801a28e:	0011      	movs	r1, r2
 801a290:	0018      	movs	r0, r3
 801a292:	f7f8 fc0f 	bl	8012ab4 <sys_untimeout>
        pcb->lcp_echo_timer_running = 0;
 801a296:	687b      	ldr	r3, [r7, #4]
 801a298:	2226      	movs	r2, #38	; 0x26
 801a29a:	5c99      	ldrb	r1, [r3, r2]
 801a29c:	2010      	movs	r0, #16
 801a29e:	4381      	bics	r1, r0
 801a2a0:	5499      	strb	r1, [r3, r2]
    }
}
 801a2a2:	46c0      	nop			; (mov r8, r8)
 801a2a4:	46bd      	mov	sp, r7
 801a2a6:	b004      	add	sp, #16
 801a2a8:	bd80      	pop	{r7, pc}
 801a2aa:	46c0      	nop			; (mov r8, r8)
 801a2ac:	0801a079 	.word	0x0801a079

0801a2b0 <magic_init>:
 * in startup(), then the idle counter and timer values may
 * repeat after each boot and the real time clock may not be
 * operational.  Thus we call it again on the first random
 * event.
 */
void magic_init(void) {
 801a2b0:	b580      	push	{r7, lr}
 801a2b2:	af00      	add	r7, sp, #0
  magic_randomseed += sys_jiffies();
 801a2b4:	f003 fe2e 	bl	801df14 <sys_jiffies>
 801a2b8:	0002      	movs	r2, r0
 801a2ba:	4b04      	ldr	r3, [pc, #16]	; (801a2cc <magic_init+0x1c>)
 801a2bc:	681b      	ldr	r3, [r3, #0]
 801a2be:	18d2      	adds	r2, r2, r3
 801a2c0:	4b02      	ldr	r3, [pc, #8]	; (801a2cc <magic_init+0x1c>)
 801a2c2:	601a      	str	r2, [r3, #0]
#ifndef LWIP_RAND
  /* Initialize the Borland random number generator. */
  srand((unsigned)magic_randomseed);
#endif /* LWIP_RAND */
}
 801a2c4:	46c0      	nop			; (mov r8, r8)
 801a2c6:	46bd      	mov	sp, r7
 801a2c8:	bd80      	pop	{r7, pc}
 801a2ca:	46c0      	nop			; (mov r8, r8)
 801a2cc:	20000ca0 	.word	0x20000ca0

0801a2d0 <magic_randomize>:
 * this function is called at *truely random* times by the polling
 * and network functions.  Here we only get 16 bits of new random
 * value but we use the previous value to randomize the other 16
 * bits.
 */
void magic_randomize(void) {
 801a2d0:	b580      	push	{r7, lr}
 801a2d2:	af00      	add	r7, sp, #0
    magic_randomized = !0;
    magic_init();
    /* The initialization function also updates the seed. */
  } else {
#endif /* LWIP_RAND */
    magic_randomseed += sys_jiffies();
 801a2d4:	f003 fe1e 	bl	801df14 <sys_jiffies>
 801a2d8:	0002      	movs	r2, r0
 801a2da:	4b04      	ldr	r3, [pc, #16]	; (801a2ec <magic_randomize+0x1c>)
 801a2dc:	681b      	ldr	r3, [r3, #0]
 801a2de:	18d2      	adds	r2, r2, r3
 801a2e0:	4b02      	ldr	r3, [pc, #8]	; (801a2ec <magic_randomize+0x1c>)
 801a2e2:	601a      	str	r2, [r3, #0]
#ifndef LWIP_RAND
  }
#endif /* LWIP_RAND */
}
 801a2e4:	46c0      	nop			; (mov r8, r8)
 801a2e6:	46bd      	mov	sp, r7
 801a2e8:	bd80      	pop	{r7, pc}
 801a2ea:	46c0      	nop			; (mov r8, r8)
 801a2ec:	20000ca0 	.word	0x20000ca0

0801a2f0 <magic>:
 * seed which is randomized by truely random events.
 * Thus the numbers will be truely random unless there have been no
 * operator or network events in which case it will be pseudo random
 * seeded by the real time clock.
 */
u32_t magic(void) {
 801a2f0:	b580      	push	{r7, lr}
 801a2f2:	af00      	add	r7, sp, #0
#ifdef LWIP_RAND
  return LWIP_RAND() + magic_randomseed;
 801a2f4:	f003 fdf4 	bl	801dee0 <sys_rand>
 801a2f8:	0002      	movs	r2, r0
 801a2fa:	4b03      	ldr	r3, [pc, #12]	; (801a308 <magic+0x18>)
 801a2fc:	681b      	ldr	r3, [r3, #0]
 801a2fe:	18d3      	adds	r3, r2, r3
#else /* LWIP_RAND */
  return ((u32_t)rand() << 16) + (u32_t)rand() + magic_randomseed;
#endif /* LWIP_RAND */
}
 801a300:	0018      	movs	r0, r3
 801a302:	46bd      	mov	sp, r7
 801a304:	bd80      	pop	{r7, pc}
 801a306:	46c0      	nop			; (mov r8, r8)
 801a308:	20000ca0 	.word	0x20000ca0

0801a30c <ppp_set_notify_phase_callback>:
  pcb->settings.refuse_mppe_128 = !!(flags & PPP_MPPE_REFUSE_128);
}
#endif /* MPPE_SUPPORT */

#if PPP_NOTIFY_PHASE
void ppp_set_notify_phase_callback(ppp_pcb *pcb, ppp_notify_phase_cb_fn notify_phase_cb) {
 801a30c:	b580      	push	{r7, lr}
 801a30e:	b082      	sub	sp, #8
 801a310:	af00      	add	r7, sp, #0
 801a312:	6078      	str	r0, [r7, #4]
 801a314:	6039      	str	r1, [r7, #0]
  pcb->notify_phase_cb = notify_phase_cb;
 801a316:	687b      	ldr	r3, [r7, #4]
 801a318:	683a      	ldr	r2, [r7, #0]
 801a31a:	619a      	str	r2, [r3, #24]
  notify_phase_cb(pcb, pcb->phase, pcb->ctx_cb);
 801a31c:	687b      	ldr	r3, [r7, #4]
 801a31e:	2224      	movs	r2, #36	; 0x24
 801a320:	5c99      	ldrb	r1, [r3, r2]
 801a322:	687b      	ldr	r3, [r7, #4]
 801a324:	69da      	ldr	r2, [r3, #28]
 801a326:	6878      	ldr	r0, [r7, #4]
 801a328:	683b      	ldr	r3, [r7, #0]
 801a32a:	4798      	blx	r3
}
 801a32c:	46c0      	nop			; (mov r8, r8)
 801a32e:	46bd      	mov	sp, r7
 801a330:	b002      	add	sp, #8
 801a332:	bd80      	pop	{r7, pc}

0801a334 <ppp_connect>:
 * the connection.
 *
 * If this port connects to a modem, the modem connection must be
 * established before calling this.
 */
err_t ppp_connect(ppp_pcb *pcb, u16_t holdoff) {
 801a334:	b580      	push	{r7, lr}
 801a336:	b082      	sub	sp, #8
 801a338:	af00      	add	r7, sp, #0
 801a33a:	6078      	str	r0, [r7, #4]
 801a33c:	000a      	movs	r2, r1
 801a33e:	1cbb      	adds	r3, r7, #2
 801a340:	801a      	strh	r2, [r3, #0]
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb->phase != PPP_PHASE_DEAD) {
 801a342:	687b      	ldr	r3, [r7, #4]
 801a344:	2224      	movs	r2, #36	; 0x24
 801a346:	5c9b      	ldrb	r3, [r3, r2]
 801a348:	2b00      	cmp	r3, #0
 801a34a:	d002      	beq.n	801a352 <ppp_connect+0x1e>
    return ERR_ALREADY;
 801a34c:	2309      	movs	r3, #9
 801a34e:	425b      	negs	r3, r3
 801a350:	e01f      	b.n	801a392 <ppp_connect+0x5e>
  }

  PPPDEBUG(LOG_DEBUG, ("ppp_connect[%d]: holdoff=%d\n", pcb->netif->num, holdoff));

  magic_randomize();
 801a352:	f7ff ffbd 	bl	801a2d0 <magic_randomize>

  if (holdoff == 0) {
 801a356:	1cbb      	adds	r3, r7, #2
 801a358:	881b      	ldrh	r3, [r3, #0]
 801a35a:	2b00      	cmp	r3, #0
 801a35c:	d105      	bne.n	801a36a <ppp_connect+0x36>
    ppp_do_connect(pcb);
 801a35e:	687b      	ldr	r3, [r7, #4]
 801a360:	0018      	movs	r0, r3
 801a362:	f000 f8b1 	bl	801a4c8 <ppp_do_connect>
    return ERR_OK;
 801a366:	2300      	movs	r3, #0
 801a368:	e013      	b.n	801a392 <ppp_connect+0x5e>
  }

  new_phase(pcb, PPP_PHASE_HOLDOFF);
 801a36a:	687b      	ldr	r3, [r7, #4]
 801a36c:	2102      	movs	r1, #2
 801a36e:	0018      	movs	r0, r3
 801a370:	f000 fb3d 	bl	801a9ee <new_phase>
  sys_timeout((u32_t)(holdoff*1000), ppp_do_connect, pcb);
 801a374:	1cbb      	adds	r3, r7, #2
 801a376:	881a      	ldrh	r2, [r3, #0]
 801a378:	0013      	movs	r3, r2
 801a37a:	015b      	lsls	r3, r3, #5
 801a37c:	1a9b      	subs	r3, r3, r2
 801a37e:	009b      	lsls	r3, r3, #2
 801a380:	189b      	adds	r3, r3, r2
 801a382:	00db      	lsls	r3, r3, #3
 801a384:	0018      	movs	r0, r3
 801a386:	687a      	ldr	r2, [r7, #4]
 801a388:	4b04      	ldr	r3, [pc, #16]	; (801a39c <ppp_connect+0x68>)
 801a38a:	0019      	movs	r1, r3
 801a38c:	f7f8 fb6a 	bl	8012a64 <sys_timeout>
  return ERR_OK;
 801a390:	2300      	movs	r3, #0
}
 801a392:	0018      	movs	r0, r3
 801a394:	46bd      	mov	sp, r7
 801a396:	b002      	add	sp, #8
 801a398:	bd80      	pop	{r7, pc}
 801a39a:	46c0      	nop			; (mov r8, r8)
 801a39c:	0801a4c9 	.word	0x0801a4c9

0801a3a0 <ppp_close>:
 *
 * Return 0 on success, an error code on failure.
 */
err_t
ppp_close(ppp_pcb *pcb, u8_t nocarrier)
{
 801a3a0:	b590      	push	{r4, r7, lr}
 801a3a2:	b083      	sub	sp, #12
 801a3a4:	af00      	add	r7, sp, #0
 801a3a6:	6078      	str	r0, [r7, #4]
 801a3a8:	000a      	movs	r2, r1
 801a3aa:	1cfb      	adds	r3, r7, #3
 801a3ac:	701a      	strb	r2, [r3, #0]
  LWIP_ASSERT_CORE_LOCKED();

  pcb->err_code = PPPERR_USER;
 801a3ae:	687b      	ldr	r3, [r7, #4]
 801a3b0:	2225      	movs	r2, #37	; 0x25
 801a3b2:	2105      	movs	r1, #5
 801a3b4:	5499      	strb	r1, [r3, r2]

  /* holdoff phase, cancel the reconnection */
  if (pcb->phase == PPP_PHASE_HOLDOFF) {
 801a3b6:	687b      	ldr	r3, [r7, #4]
 801a3b8:	2224      	movs	r2, #36	; 0x24
 801a3ba:	5c9b      	ldrb	r3, [r3, r2]
 801a3bc:	2b02      	cmp	r3, #2
 801a3be:	d10a      	bne.n	801a3d6 <ppp_close+0x36>
    sys_untimeout(ppp_do_connect, pcb);
 801a3c0:	687a      	ldr	r2, [r7, #4]
 801a3c2:	4b29      	ldr	r3, [pc, #164]	; (801a468 <ppp_close+0xc8>)
 801a3c4:	0011      	movs	r1, r2
 801a3c6:	0018      	movs	r0, r3
 801a3c8:	f7f8 fb74 	bl	8012ab4 <sys_untimeout>
    new_phase(pcb, PPP_PHASE_DEAD);
 801a3cc:	687b      	ldr	r3, [r7, #4]
 801a3ce:	2100      	movs	r1, #0
 801a3d0:	0018      	movs	r0, r3
 801a3d2:	f000 fb0c 	bl	801a9ee <new_phase>
  }

  /* dead phase, nothing to do, call the status callback to be consistent */
  if (pcb->phase == PPP_PHASE_DEAD) {
 801a3d6:	687b      	ldr	r3, [r7, #4]
 801a3d8:	2224      	movs	r2, #36	; 0x24
 801a3da:	5c9b      	ldrb	r3, [r3, r2]
 801a3dc:	2b00      	cmp	r3, #0
 801a3de:	d10c      	bne.n	801a3fa <ppp_close+0x5a>
    pcb->link_status_cb(pcb, pcb->err_code, pcb->ctx_cb);
 801a3e0:	687b      	ldr	r3, [r7, #4]
 801a3e2:	695c      	ldr	r4, [r3, #20]
 801a3e4:	687b      	ldr	r3, [r7, #4]
 801a3e6:	2225      	movs	r2, #37	; 0x25
 801a3e8:	5c9b      	ldrb	r3, [r3, r2]
 801a3ea:	0019      	movs	r1, r3
 801a3ec:	687b      	ldr	r3, [r7, #4]
 801a3ee:	69da      	ldr	r2, [r3, #28]
 801a3f0:	687b      	ldr	r3, [r7, #4]
 801a3f2:	0018      	movs	r0, r3
 801a3f4:	47a0      	blx	r4
    return ERR_OK;
 801a3f6:	2300      	movs	r3, #0
 801a3f8:	e031      	b.n	801a45e <ppp_close+0xbe>
  }

  /* Already terminating, nothing to do */
  if (pcb->phase >= PPP_PHASE_TERMINATE) {
 801a3fa:	687b      	ldr	r3, [r7, #4]
 801a3fc:	2224      	movs	r2, #36	; 0x24
 801a3fe:	5c9b      	ldrb	r3, [r3, r2]
 801a400:	2b0a      	cmp	r3, #10
 801a402:	d902      	bls.n	801a40a <ppp_close+0x6a>
    return ERR_INPROGRESS;
 801a404:	2305      	movs	r3, #5
 801a406:	425b      	negs	r3, r3
 801a408:	e029      	b.n	801a45e <ppp_close+0xbe>
  }

  /* LCP not open, close link protocol */
  if (pcb->phase < PPP_PHASE_ESTABLISH) {
 801a40a:	687b      	ldr	r3, [r7, #4]
 801a40c:	2224      	movs	r2, #36	; 0x24
 801a40e:	5c9b      	ldrb	r3, [r3, r2]
 801a410:	2b05      	cmp	r3, #5
 801a412:	d80a      	bhi.n	801a42a <ppp_close+0x8a>
    new_phase(pcb, PPP_PHASE_DISCONNECT);
 801a414:	687b      	ldr	r3, [r7, #4]
 801a416:	210c      	movs	r1, #12
 801a418:	0018      	movs	r0, r3
 801a41a:	f000 fae8 	bl	801a9ee <new_phase>
    ppp_link_terminated(pcb);
 801a41e:	687b      	ldr	r3, [r7, #4]
 801a420:	0018      	movs	r0, r3
 801a422:	f000 fad4 	bl	801a9ce <ppp_link_terminated>
    return ERR_OK;
 801a426:	2300      	movs	r3, #0
 801a428:	e019      	b.n	801a45e <ppp_close+0xbe>
   * to prevent changing the PPP phase FSM in transition phases.
   *
   * Always using nocarrier = 0 is still recommended, this is going to
   * take a little longer time, but is a safer choice from FSM point of view.
   */
  if (nocarrier && pcb->phase == PPP_PHASE_RUNNING) {
 801a42a:	1cfb      	adds	r3, r7, #3
 801a42c:	781b      	ldrb	r3, [r3, #0]
 801a42e:	2b00      	cmp	r3, #0
 801a430:	d00e      	beq.n	801a450 <ppp_close+0xb0>
 801a432:	687b      	ldr	r3, [r7, #4]
 801a434:	2224      	movs	r2, #36	; 0x24
 801a436:	5c9b      	ldrb	r3, [r3, r2]
 801a438:	2b0a      	cmp	r3, #10
 801a43a:	d109      	bne.n	801a450 <ppp_close+0xb0>
    PPPDEBUG(LOG_DEBUG, ("ppp_close[%d]: carrier lost -> lcp_lowerdown\n", pcb->netif->num));
    lcp_lowerdown(pcb);
 801a43c:	687b      	ldr	r3, [r7, #4]
 801a43e:	0018      	movs	r0, r3
 801a440:	f7fd ffa2 	bl	8018388 <lcp_lowerdown>
    /* forced link termination, this will force link protocol to disconnect. */
    link_terminated(pcb);
 801a444:	687b      	ldr	r3, [r7, #4]
 801a446:	0018      	movs	r0, r3
 801a448:	f7fa fa8c 	bl	8014964 <link_terminated>
    return ERR_OK;
 801a44c:	2300      	movs	r3, #0
 801a44e:	e006      	b.n	801a45e <ppp_close+0xbe>
  }

  /* Disconnect */
  PPPDEBUG(LOG_DEBUG, ("ppp_close[%d]: kill_link -> lcp_close\n", pcb->netif->num));
  /* LCP soft close request. */
  lcp_close(pcb, "User request");
 801a450:	4a06      	ldr	r2, [pc, #24]	; (801a46c <ppp_close+0xcc>)
 801a452:	687b      	ldr	r3, [r7, #4]
 801a454:	0011      	movs	r1, r2
 801a456:	0018      	movs	r0, r3
 801a458:	f7fd fef2 	bl	8018240 <lcp_close>
  return ERR_OK;
 801a45c:	2300      	movs	r3, #0
}
 801a45e:	0018      	movs	r0, r3
 801a460:	46bd      	mov	sp, r7
 801a462:	b003      	add	sp, #12
 801a464:	bd90      	pop	{r4, r7, pc}
 801a466:	46c0      	nop			; (mov r8, r8)
 801a468:	0801a4c9 	.word	0x0801a4c9
 801a46c:	08022b04 	.word	0x08022b04

0801a470 <ppp_free>:
 * You must use ppp_close() before if you wish to terminate
 * an established PPP session.
 *
 * Return 0 on success, an error code on failure.
 */
err_t ppp_free(ppp_pcb *pcb) {
 801a470:	b5b0      	push	{r4, r5, r7, lr}
 801a472:	b084      	sub	sp, #16
 801a474:	af00      	add	r7, sp, #0
 801a476:	6078      	str	r0, [r7, #4]
  err_t err;
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb->phase != PPP_PHASE_DEAD) {
 801a478:	687b      	ldr	r3, [r7, #4]
 801a47a:	2224      	movs	r2, #36	; 0x24
 801a47c:	5c9b      	ldrb	r3, [r3, r2]
 801a47e:	2b00      	cmp	r3, #0
 801a480:	d002      	beq.n	801a488 <ppp_free+0x18>
    return ERR_CONN;
 801a482:	230b      	movs	r3, #11
 801a484:	425b      	negs	r3, r3
 801a486:	e019      	b.n	801a4bc <ppp_free+0x4c>
  }

  PPPDEBUG(LOG_DEBUG, ("ppp_free[%d]\n", pcb->netif->num));

  netif_remove(pcb->netif);
 801a488:	687b      	ldr	r3, [r7, #4]
 801a48a:	6a1b      	ldr	r3, [r3, #32]
 801a48c:	0018      	movs	r0, r3
 801a48e:	f7ef fb5b 	bl	8009b48 <netif_remove>

  err = pcb->link_cb->free(pcb, pcb->link_ctx_cb);
 801a492:	687b      	ldr	r3, [r7, #4]
 801a494:	68db      	ldr	r3, [r3, #12]
 801a496:	689a      	ldr	r2, [r3, #8]
 801a498:	687b      	ldr	r3, [r7, #4]
 801a49a:	6919      	ldr	r1, [r3, #16]
 801a49c:	250f      	movs	r5, #15
 801a49e:	197c      	adds	r4, r7, r5
 801a4a0:	687b      	ldr	r3, [r7, #4]
 801a4a2:	0018      	movs	r0, r3
 801a4a4:	4790      	blx	r2
 801a4a6:	0003      	movs	r3, r0
 801a4a8:	7023      	strb	r3, [r4, #0]

  LWIP_MEMPOOL_FREE(PPP_PCB, pcb);
 801a4aa:	687a      	ldr	r2, [r7, #4]
 801a4ac:	4b05      	ldr	r3, [pc, #20]	; (801a4c4 <ppp_free+0x54>)
 801a4ae:	0011      	movs	r1, r2
 801a4b0:	0018      	movs	r0, r3
 801a4b2:	f7ef f939 	bl	8009728 <memp_free_pool>
  return err;
 801a4b6:	197b      	adds	r3, r7, r5
 801a4b8:	781b      	ldrb	r3, [r3, #0]
 801a4ba:	b25b      	sxtb	r3, r3
}
 801a4bc:	0018      	movs	r0, r3
 801a4be:	46bd      	mov	sp, r7
 801a4c0:	b004      	add	sp, #16
 801a4c2:	bdb0      	pop	{r4, r5, r7, pc}
 801a4c4:	08023ce8 	.word	0x08023ce8

0801a4c8 <ppp_do_connect>:

/**********************************/
/*** LOCAL FUNCTION DEFINITIONS ***/
/**********************************/

static void ppp_do_connect(void *arg) {
 801a4c8:	b580      	push	{r7, lr}
 801a4ca:	b084      	sub	sp, #16
 801a4cc:	af00      	add	r7, sp, #0
 801a4ce:	6078      	str	r0, [r7, #4]
  ppp_pcb *pcb = (ppp_pcb*)arg;
 801a4d0:	687b      	ldr	r3, [r7, #4]
 801a4d2:	60fb      	str	r3, [r7, #12]

  LWIP_ASSERT("pcb->phase == PPP_PHASE_DEAD || pcb->phase == PPP_PHASE_HOLDOFF", pcb->phase == PPP_PHASE_DEAD || pcb->phase == PPP_PHASE_HOLDOFF);
 801a4d4:	68fb      	ldr	r3, [r7, #12]
 801a4d6:	2224      	movs	r2, #36	; 0x24
 801a4d8:	5c9b      	ldrb	r3, [r3, r2]
 801a4da:	2b00      	cmp	r3, #0
 801a4dc:	d00b      	beq.n	801a4f6 <ppp_do_connect+0x2e>
 801a4de:	68fb      	ldr	r3, [r7, #12]
 801a4e0:	2224      	movs	r2, #36	; 0x24
 801a4e2:	5c9b      	ldrb	r3, [r3, r2]
 801a4e4:	2b02      	cmp	r3, #2
 801a4e6:	d006      	beq.n	801a4f6 <ppp_do_connect+0x2e>
 801a4e8:	4b0b      	ldr	r3, [pc, #44]	; (801a518 <ppp_do_connect+0x50>)
 801a4ea:	22ce      	movs	r2, #206	; 0xce
 801a4ec:	32ff      	adds	r2, #255	; 0xff
 801a4ee:	490b      	ldr	r1, [pc, #44]	; (801a51c <ppp_do_connect+0x54>)
 801a4f0:	480b      	ldr	r0, [pc, #44]	; (801a520 <ppp_do_connect+0x58>)
 801a4f2:	f7e7 fe77 	bl	80021e4 <app_debug_rtt_raw>

  new_phase(pcb, PPP_PHASE_INITIALIZE);
 801a4f6:	68fb      	ldr	r3, [r7, #12]
 801a4f8:	2103      	movs	r1, #3
 801a4fa:	0018      	movs	r0, r3
 801a4fc:	f000 fa77 	bl	801a9ee <new_phase>
  pcb->link_cb->connect(pcb, pcb->link_ctx_cb);
 801a500:	68fb      	ldr	r3, [r7, #12]
 801a502:	68db      	ldr	r3, [r3, #12]
 801a504:	681a      	ldr	r2, [r3, #0]
 801a506:	68fb      	ldr	r3, [r7, #12]
 801a508:	6919      	ldr	r1, [r3, #16]
 801a50a:	68fb      	ldr	r3, [r7, #12]
 801a50c:	0018      	movs	r0, r3
 801a50e:	4790      	blx	r2
}
 801a510:	46c0      	nop			; (mov r8, r8)
 801a512:	46bd      	mov	sp, r7
 801a514:	b004      	add	sp, #16
 801a516:	bd80      	pop	{r7, pc}
 801a518:	08022b14 	.word	0x08022b14
 801a51c:	08022b40 	.word	0x08022b40
 801a520:	08022b80 	.word	0x08022b80

0801a524 <ppp_netif_init_cb>:

/*
 * ppp_netif_init_cb - netif init callback
 */
static err_t ppp_netif_init_cb(struct netif *netif) {
 801a524:	b580      	push	{r7, lr}
 801a526:	b082      	sub	sp, #8
 801a528:	af00      	add	r7, sp, #0
 801a52a:	6078      	str	r0, [r7, #4]
  netif->name[0] = 'p';
 801a52c:	687b      	ldr	r3, [r7, #4]
 801a52e:	2232      	movs	r2, #50	; 0x32
 801a530:	2170      	movs	r1, #112	; 0x70
 801a532:	5499      	strb	r1, [r3, r2]
  netif->name[1] = 'p';
 801a534:	687b      	ldr	r3, [r7, #4]
 801a536:	2233      	movs	r2, #51	; 0x33
 801a538:	2170      	movs	r1, #112	; 0x70
 801a53a:	5499      	strb	r1, [r3, r2]
#if PPP_IPV4_SUPPORT
  netif->output = ppp_netif_output_ip4;
 801a53c:	687b      	ldr	r3, [r7, #4]
 801a53e:	4a05      	ldr	r2, [pc, #20]	; (801a554 <ppp_netif_init_cb+0x30>)
 801a540:	615a      	str	r2, [r3, #20]
#endif /* PPP_IPV4_SUPPORT */
#if PPP_IPV6_SUPPORT
  netif->output_ip6 = ppp_netif_output_ip6;
#endif /* PPP_IPV6_SUPPORT */
  netif->flags = NETIF_FLAG_UP;
 801a542:	687b      	ldr	r3, [r7, #4]
 801a544:	2231      	movs	r2, #49	; 0x31
 801a546:	2101      	movs	r1, #1
 801a548:	5499      	strb	r1, [r3, r2]
#if LWIP_NETIF_HOSTNAME
  /* @todo: Initialize interface hostname */
  /* netif_set_hostname(netif, "lwip"); */
#endif /* LWIP_NETIF_HOSTNAME */
  return ERR_OK;
 801a54a:	2300      	movs	r3, #0
}
 801a54c:	0018      	movs	r0, r3
 801a54e:	46bd      	mov	sp, r7
 801a550:	b002      	add	sp, #8
 801a552:	bd80      	pop	{r7, pc}
 801a554:	0801a559 	.word	0x0801a559

0801a558 <ppp_netif_output_ip4>:

#if PPP_IPV4_SUPPORT
/*
 * Send an IPv4 packet on the given connection.
 */
static err_t ppp_netif_output_ip4(struct netif *netif, struct pbuf *pb, const ip4_addr_t *ipaddr) {
 801a558:	b580      	push	{r7, lr}
 801a55a:	b084      	sub	sp, #16
 801a55c:	af00      	add	r7, sp, #0
 801a55e:	60f8      	str	r0, [r7, #12]
 801a560:	60b9      	str	r1, [r7, #8]
 801a562:	607a      	str	r2, [r7, #4]
  LWIP_UNUSED_ARG(ipaddr);
  return ppp_netif_output(netif, pb, PPP_IP);
 801a564:	68b9      	ldr	r1, [r7, #8]
 801a566:	68fb      	ldr	r3, [r7, #12]
 801a568:	2221      	movs	r2, #33	; 0x21
 801a56a:	0018      	movs	r0, r3
 801a56c:	f000 f805 	bl	801a57a <ppp_netif_output>
 801a570:	0003      	movs	r3, r0
}
 801a572:	0018      	movs	r0, r3
 801a574:	46bd      	mov	sp, r7
 801a576:	b004      	add	sp, #16
 801a578:	bd80      	pop	{r7, pc}

0801a57a <ppp_netif_output>:
  LWIP_UNUSED_ARG(ipaddr);
  return ppp_netif_output(netif, pb, PPP_IPV6);
}
#endif /* PPP_IPV6_SUPPORT */

static err_t ppp_netif_output(struct netif *netif, struct pbuf *pb, u16_t protocol) {
 801a57a:	b5b0      	push	{r4, r5, r7, lr}
 801a57c:	b088      	sub	sp, #32
 801a57e:	af00      	add	r7, sp, #0
 801a580:	60f8      	str	r0, [r7, #12]
 801a582:	60b9      	str	r1, [r7, #8]
 801a584:	1dbb      	adds	r3, r7, #6
 801a586:	801a      	strh	r2, [r3, #0]
  ppp_pcb *pcb = (ppp_pcb*)netif->state;
 801a588:	68fb      	ldr	r3, [r7, #12]
 801a58a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801a58c:	617b      	str	r3, [r7, #20]
  err_t err;
  struct pbuf *fpb = NULL;
 801a58e:	2300      	movs	r3, #0
 801a590:	61bb      	str	r3, [r7, #24]

  /* Check that the link is up. */
  if (0
 801a592:	1dbb      	adds	r3, r7, #6
 801a594:	881b      	ldrh	r3, [r3, #0]
 801a596:	2b21      	cmp	r3, #33	; 0x21
 801a598:	d107      	bne.n	801a5aa <ppp_netif_output+0x30>
#if PPP_IPV4_SUPPORT
      || (protocol == PPP_IP && !pcb->if4_up)
 801a59a:	697b      	ldr	r3, [r7, #20]
 801a59c:	2226      	movs	r2, #38	; 0x26
 801a59e:	5c9b      	ldrb	r3, [r3, r2]
 801a5a0:	2208      	movs	r2, #8
 801a5a2:	4013      	ands	r3, r2
 801a5a4:	b2db      	uxtb	r3, r3
 801a5a6:	2b00      	cmp	r3, #0
 801a5a8:	d03d      	beq.n	801a626 <ppp_netif_output+0xac>
#if VJ_SUPPORT
  /*
   * Attempt Van Jacobson header compression if VJ is configured and
   * this is an IP packet.
   */
  if (protocol == PPP_IP && pcb->vj_enabled) {
 801a5aa:	1dbb      	adds	r3, r7, #6
 801a5ac:	881b      	ldrh	r3, [r3, #0]
 801a5ae:	2b21      	cmp	r3, #33	; 0x21
 801a5b0:	d127      	bne.n	801a602 <ppp_netif_output+0x88>
 801a5b2:	697b      	ldr	r3, [r7, #20]
 801a5b4:	2226      	movs	r2, #38	; 0x26
 801a5b6:	5c9b      	ldrb	r3, [r3, r2]
 801a5b8:	2220      	movs	r2, #32
 801a5ba:	4013      	ands	r3, r2
 801a5bc:	b2db      	uxtb	r3, r3
 801a5be:	2b00      	cmp	r3, #0
 801a5c0:	d01f      	beq.n	801a602 <ppp_netif_output+0x88>
    switch (vj_compress_tcp(&pcb->vj_comp, &pb)) {
 801a5c2:	697b      	ldr	r3, [r7, #20]
 801a5c4:	33dc      	adds	r3, #220	; 0xdc
 801a5c6:	2208      	movs	r2, #8
 801a5c8:	18ba      	adds	r2, r7, r2
 801a5ca:	0011      	movs	r1, r2
 801a5cc:	0018      	movs	r0, r3
 801a5ce:	f001 fd73 	bl	801c0b8 <vj_compress_tcp>
 801a5d2:	0003      	movs	r3, r0
 801a5d4:	2b80      	cmp	r3, #128	; 0x80
 801a5d6:	d005      	beq.n	801a5e4 <ppp_netif_output+0x6a>
 801a5d8:	dc10      	bgt.n	801a5fc <ppp_netif_output+0x82>
 801a5da:	2b40      	cmp	r3, #64	; 0x40
 801a5dc:	d013      	beq.n	801a606 <ppp_netif_output+0x8c>
 801a5de:	2b70      	cmp	r3, #112	; 0x70
 801a5e0:	d006      	beq.n	801a5f0 <ppp_netif_output+0x76>
 801a5e2:	e00b      	b.n	801a5fc <ppp_netif_output+0x82>
           protocol = PPP_IP; */
        break;
      case TYPE_COMPRESSED_TCP:
        /* vj_compress_tcp() returns a new allocated pbuf, indicate we should free
         * our duplicated pbuf later */
        fpb = pb;
 801a5e4:	68bb      	ldr	r3, [r7, #8]
 801a5e6:	61bb      	str	r3, [r7, #24]
        protocol = PPP_VJC_COMP;
 801a5e8:	1dbb      	adds	r3, r7, #6
 801a5ea:	222d      	movs	r2, #45	; 0x2d
 801a5ec:	801a      	strh	r2, [r3, #0]
        break;
 801a5ee:	e00b      	b.n	801a608 <ppp_netif_output+0x8e>
      case TYPE_UNCOMPRESSED_TCP:
        /* vj_compress_tcp() returns a new allocated pbuf, indicate we should free
         * our duplicated pbuf later */
        fpb = pb;
 801a5f0:	68bb      	ldr	r3, [r7, #8]
 801a5f2:	61bb      	str	r3, [r7, #24]
        protocol = PPP_VJC_UNCOMP;
 801a5f4:	1dbb      	adds	r3, r7, #6
 801a5f6:	222f      	movs	r2, #47	; 0x2f
 801a5f8:	801a      	strh	r2, [r3, #0]
        break;
 801a5fa:	e005      	b.n	801a608 <ppp_netif_output+0x8e>
      default:
        PPPDEBUG(LOG_WARNING, ("ppp_netif_output[%d]: bad IP packet\n", pcb->netif->num));
        LINK_STATS_INC(link.proterr);
        LINK_STATS_INC(link.drop);
        MIB2_STATS_NETIF_INC(pcb->netif, ifoutdiscards);
        return ERR_VAL;
 801a5fc:	2306      	movs	r3, #6
 801a5fe:	425b      	negs	r3, r3
 801a600:	e021      	b.n	801a646 <ppp_netif_output+0xcc>
    }
  }
 801a602:	46c0      	nop			; (mov r8, r8)
 801a604:	e000      	b.n	801a608 <ppp_netif_output+0x8e>
        break;
 801a606:	46c0      	nop			; (mov r8, r8)
    PPPDEBUG(LOG_ERR, ("ppp_netif_output[%d]: bad CCP transmit method\n", pcb->netif->num));
    goto err_rte_drop; /* Cannot really happen, we only negotiate what we are able to do */
  }
#endif /* CCP_SUPPORT */

  err = pcb->link_cb->netif_output(pcb, pcb->link_ctx_cb, pb, protocol);
 801a608:	697b      	ldr	r3, [r7, #20]
 801a60a:	68db      	ldr	r3, [r3, #12]
 801a60c:	691d      	ldr	r5, [r3, #16]
 801a60e:	697b      	ldr	r3, [r7, #20]
 801a610:	6919      	ldr	r1, [r3, #16]
 801a612:	68ba      	ldr	r2, [r7, #8]
 801a614:	231f      	movs	r3, #31
 801a616:	18fc      	adds	r4, r7, r3
 801a618:	1dbb      	adds	r3, r7, #6
 801a61a:	881b      	ldrh	r3, [r3, #0]
 801a61c:	6978      	ldr	r0, [r7, #20]
 801a61e:	47a8      	blx	r5
 801a620:	0003      	movs	r3, r0
 801a622:	7023      	strb	r3, [r4, #0]
  goto err;
 801a624:	e004      	b.n	801a630 <ppp_netif_output+0xb6>
    goto err_rte_drop;
 801a626:	46c0      	nop			; (mov r8, r8)

err_rte_drop:
  err = ERR_RTE;
 801a628:	231f      	movs	r3, #31
 801a62a:	18fb      	adds	r3, r7, r3
 801a62c:	22fc      	movs	r2, #252	; 0xfc
 801a62e:	701a      	strb	r2, [r3, #0]
  LINK_STATS_INC(link.rterr);
  LINK_STATS_INC(link.drop);
  MIB2_STATS_NETIF_INC(netif, ifoutdiscards);
err:
  if (fpb) {
 801a630:	69bb      	ldr	r3, [r7, #24]
 801a632:	2b00      	cmp	r3, #0
 801a634:	d003      	beq.n	801a63e <ppp_netif_output+0xc4>
    pbuf_free(fpb);
 801a636:	69bb      	ldr	r3, [r7, #24]
 801a638:	0018      	movs	r0, r3
 801a63a:	f7ef ff4f 	bl	800a4dc <pbuf_free>
  }
  return err;
 801a63e:	231f      	movs	r3, #31
 801a640:	18fb      	adds	r3, r7, r3
 801a642:	781b      	ldrb	r3, [r3, #0]
 801a644:	b25b      	sxtb	r3, r3
}
 801a646:	0018      	movs	r0, r3
 801a648:	46bd      	mov	sp, r7
 801a64a:	b008      	add	sp, #32
 801a64c:	bdb0      	pop	{r4, r5, r7, pc}
	...

0801a650 <ppp_init>:
/*** PRIVATE FUNCTION DEFINITIONS ***/
/************************************/

/* Initialize the PPP subsystem. */
int ppp_init(void)
{
 801a650:	b580      	push	{r7, lr}
 801a652:	af00      	add	r7, sp, #0
#if PPPOS_SUPPORT
  LWIP_MEMPOOL_INIT(PPPOS_PCB);
 801a654:	4b06      	ldr	r3, [pc, #24]	; (801a670 <ppp_init+0x20>)
 801a656:	0018      	movs	r0, r3
 801a658:	f7ee ff84 	bl	8009564 <memp_init_pool>
#endif
#if LWIP_PPP_API && LWIP_MPU_COMPATIBLE
  LWIP_MEMPOOL_INIT(PPPAPI_MSG);
#endif

  LWIP_MEMPOOL_INIT(PPP_PCB);
 801a65c:	4b05      	ldr	r3, [pc, #20]	; (801a674 <ppp_init+0x24>)
 801a65e:	0018      	movs	r0, r3
 801a660:	f7ee ff80 	bl	8009564 <memp_init_pool>

  /*
   * Initialize magic number generator now so that protocols may
   * use magic numbers in initialization.
   */
  magic_init();
 801a664:	f7ff fe24 	bl	801a2b0 <magic_init>

  return 0;
 801a668:	2300      	movs	r3, #0
}
 801a66a:	0018      	movs	r0, r3
 801a66c:	46bd      	mov	sp, r7
 801a66e:	bd80      	pop	{r7, pc}
 801a670:	08023d04 	.word	0x08023d04
 801a674:	08023ce8 	.word	0x08023ce8

0801a678 <ppp_new>:
 * attempt to negotiate the LCP session.
 *
 * Return a new PPP connection control block pointer
 * on success or a null pointer on failure.
 */
ppp_pcb *ppp_new(struct netif *pppif, const struct link_callbacks *callbacks, void *link_ctx_cb, ppp_link_status_cb_fn link_status_cb, void *ctx_cb) {
 801a678:	b590      	push	{r4, r7, lr}
 801a67a:	b08d      	sub	sp, #52	; 0x34
 801a67c:	af04      	add	r7, sp, #16
 801a67e:	60f8      	str	r0, [r7, #12]
 801a680:	60b9      	str	r1, [r7, #8]
 801a682:	607a      	str	r2, [r7, #4]
 801a684:	603b      	str	r3, [r7, #0]
  const struct protent *protp;
  int i;

  /* PPP is single-threaded: without a callback,
   * there is no way to know when the link is up. */
  if (link_status_cb == NULL) {
 801a686:	683b      	ldr	r3, [r7, #0]
 801a688:	2b00      	cmp	r3, #0
 801a68a:	d101      	bne.n	801a690 <ppp_new+0x18>
    return NULL;
 801a68c:	2300      	movs	r3, #0
 801a68e:	e065      	b.n	801a75c <ppp_new+0xe4>
  }

  pcb = (ppp_pcb*)LWIP_MEMPOOL_ALLOC(PPP_PCB);
 801a690:	4b34      	ldr	r3, [pc, #208]	; (801a764 <ppp_new+0xec>)
 801a692:	0018      	movs	r0, r3
 801a694:	f7ee ffdc 	bl	8009650 <memp_malloc_pool>
 801a698:	0003      	movs	r3, r0
 801a69a:	61bb      	str	r3, [r7, #24]
  if (pcb == NULL) {
 801a69c:	69bb      	ldr	r3, [r7, #24]
 801a69e:	2b00      	cmp	r3, #0
 801a6a0:	d101      	bne.n	801a6a6 <ppp_new+0x2e>
    return NULL;
 801a6a2:	2300      	movs	r3, #0
 801a6a4:	e05a      	b.n	801a75c <ppp_new+0xe4>
  }

  memset(pcb, 0, sizeof(ppp_pcb));
 801a6a6:	4a30      	ldr	r2, [pc, #192]	; (801a768 <ppp_new+0xf0>)
 801a6a8:	69bb      	ldr	r3, [r7, #24]
 801a6aa:	2100      	movs	r1, #0
 801a6ac:	0018      	movs	r0, r3
 801a6ae:	f003 fc91 	bl	801dfd4 <memset>
  pcb->settings.eap_timeout_time = EAP_DEFTIMEOUT;
  pcb->settings.eap_max_transmits = EAP_DEFTRANSMITS;
#endif /* PPP_SERVER */
#endif /* EAP_SUPPORT */

  pcb->settings.lcp_loopbackfail = LCP_DEFLOOPBACKFAIL;
 801a6b2:	69bb      	ldr	r3, [r7, #24]
 801a6b4:	220a      	movs	r2, #10
 801a6b6:	721a      	strb	r2, [r3, #8]
  pcb->settings.lcp_echo_interval = LCP_ECHOINTERVAL;
 801a6b8:	69bb      	ldr	r3, [r7, #24]
 801a6ba:	2200      	movs	r2, #0
 801a6bc:	725a      	strb	r2, [r3, #9]
  pcb->settings.lcp_echo_fails = LCP_MAXECHOFAILS;
 801a6be:	69bb      	ldr	r3, [r7, #24]
 801a6c0:	2203      	movs	r2, #3
 801a6c2:	729a      	strb	r2, [r3, #10]

  pcb->settings.fsm_timeout_time = FSM_DEFTIMEOUT;
 801a6c4:	69bb      	ldr	r3, [r7, #24]
 801a6c6:	2206      	movs	r2, #6
 801a6c8:	711a      	strb	r2, [r3, #4]
  pcb->settings.fsm_max_conf_req_transmits = FSM_DEFMAXCONFREQS;
 801a6ca:	69bb      	ldr	r3, [r7, #24]
 801a6cc:	220a      	movs	r2, #10
 801a6ce:	715a      	strb	r2, [r3, #5]
  pcb->settings.fsm_max_term_transmits = FSM_DEFMAXTERMREQS;
 801a6d0:	69bb      	ldr	r3, [r7, #24]
 801a6d2:	2202      	movs	r2, #2
 801a6d4:	719a      	strb	r2, [r3, #6]
  pcb->settings.fsm_max_nak_loops = FSM_DEFMAXNAKLOOPS;
 801a6d6:	69bb      	ldr	r3, [r7, #24]
 801a6d8:	2205      	movs	r2, #5
 801a6da:	71da      	strb	r2, [r3, #7]

  pcb->netif = pppif;
 801a6dc:	69bb      	ldr	r3, [r7, #24]
 801a6de:	68fa      	ldr	r2, [r7, #12]
 801a6e0:	621a      	str	r2, [r3, #32]
  MIB2_INIT_NETIF(pppif, snmp_ifType_ppp, 0);
  if (!netif_add(pcb->netif,
 801a6e2:	69bb      	ldr	r3, [r7, #24]
 801a6e4:	6a18      	ldr	r0, [r3, #32]
 801a6e6:	4c21      	ldr	r4, [pc, #132]	; (801a76c <ppp_new+0xf4>)
 801a6e8:	4a21      	ldr	r2, [pc, #132]	; (801a770 <ppp_new+0xf8>)
 801a6ea:	4920      	ldr	r1, [pc, #128]	; (801a76c <ppp_new+0xf4>)
 801a6ec:	2300      	movs	r3, #0
 801a6ee:	9302      	str	r3, [sp, #8]
 801a6f0:	4b20      	ldr	r3, [pc, #128]	; (801a774 <ppp_new+0xfc>)
 801a6f2:	9301      	str	r3, [sp, #4]
 801a6f4:	69bb      	ldr	r3, [r7, #24]
 801a6f6:	9300      	str	r3, [sp, #0]
 801a6f8:	0023      	movs	r3, r4
 801a6fa:	f7ef f867 	bl	80097cc <netif_add>
 801a6fe:	1e03      	subs	r3, r0, #0
 801a700:	d107      	bne.n	801a712 <ppp_new+0x9a>
#if LWIP_IPV4
                 IP4_ADDR_ANY4, IP4_ADDR_BROADCAST, IP4_ADDR_ANY4,
#endif /* LWIP_IPV4 */
                 (void *)pcb, ppp_netif_init_cb, NULL)) {
    LWIP_MEMPOOL_FREE(PPP_PCB, pcb);
 801a702:	69ba      	ldr	r2, [r7, #24]
 801a704:	4b17      	ldr	r3, [pc, #92]	; (801a764 <ppp_new+0xec>)
 801a706:	0011      	movs	r1, r2
 801a708:	0018      	movs	r0, r3
 801a70a:	f7ef f80d 	bl	8009728 <memp_free_pool>
    PPPDEBUG(LOG_ERR, ("ppp_new: netif_add failed\n"));
    return NULL;
 801a70e:	2300      	movs	r3, #0
 801a710:	e024      	b.n	801a75c <ppp_new+0xe4>
  }

  pcb->link_cb = callbacks;
 801a712:	69bb      	ldr	r3, [r7, #24]
 801a714:	68ba      	ldr	r2, [r7, #8]
 801a716:	60da      	str	r2, [r3, #12]
  pcb->link_ctx_cb = link_ctx_cb;
 801a718:	69bb      	ldr	r3, [r7, #24]
 801a71a:	687a      	ldr	r2, [r7, #4]
 801a71c:	611a      	str	r2, [r3, #16]
  pcb->link_status_cb = link_status_cb;
 801a71e:	69bb      	ldr	r3, [r7, #24]
 801a720:	683a      	ldr	r2, [r7, #0]
 801a722:	615a      	str	r2, [r3, #20]
  pcb->ctx_cb = ctx_cb;
 801a724:	69bb      	ldr	r3, [r7, #24]
 801a726:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801a728:	61da      	str	r2, [r3, #28]

  /*
   * Initialize each protocol.
   */
  for (i = 0; (protp = protocols[i]) != NULL; ++i) {
 801a72a:	2300      	movs	r3, #0
 801a72c:	61fb      	str	r3, [r7, #28]
 801a72e:	e007      	b.n	801a740 <ppp_new+0xc8>
      (*protp->init)(pcb);
 801a730:	697b      	ldr	r3, [r7, #20]
 801a732:	685b      	ldr	r3, [r3, #4]
 801a734:	69ba      	ldr	r2, [r7, #24]
 801a736:	0010      	movs	r0, r2
 801a738:	4798      	blx	r3
  for (i = 0; (protp = protocols[i]) != NULL; ++i) {
 801a73a:	69fb      	ldr	r3, [r7, #28]
 801a73c:	3301      	adds	r3, #1
 801a73e:	61fb      	str	r3, [r7, #28]
 801a740:	4b0d      	ldr	r3, [pc, #52]	; (801a778 <ppp_new+0x100>)
 801a742:	69fa      	ldr	r2, [r7, #28]
 801a744:	0092      	lsls	r2, r2, #2
 801a746:	58d3      	ldr	r3, [r2, r3]
 801a748:	617b      	str	r3, [r7, #20]
 801a74a:	697b      	ldr	r3, [r7, #20]
 801a74c:	2b00      	cmp	r3, #0
 801a74e:	d1ef      	bne.n	801a730 <ppp_new+0xb8>
  }

  new_phase(pcb, PPP_PHASE_DEAD);
 801a750:	69bb      	ldr	r3, [r7, #24]
 801a752:	2100      	movs	r1, #0
 801a754:	0018      	movs	r0, r3
 801a756:	f000 f94a 	bl	801a9ee <new_phase>
  return pcb;
 801a75a:	69bb      	ldr	r3, [r7, #24]
}
 801a75c:	0018      	movs	r0, r3
 801a75e:	46bd      	mov	sp, r7
 801a760:	b009      	add	sp, #36	; 0x24
 801a762:	bd90      	pop	{r4, r7, pc}
 801a764:	08023ce8 	.word	0x08023ce8
 801a768:	00001264 	.word	0x00001264
 801a76c:	08023a8c 	.word	0x08023a8c
 801a770:	08023a90 	.word	0x08023a90
 801a774:	0801a525 	.word	0x0801a525
 801a778:	08023cf8 	.word	0x08023cf8

0801a77c <ppp_start>:

/** Initiate LCP open request */
void ppp_start(ppp_pcb *pcb) {
 801a77c:	b580      	push	{r7, lr}
 801a77e:	b082      	sub	sp, #8
 801a780:	af00      	add	r7, sp, #0
 801a782:	6078      	str	r0, [r7, #4]
  pcb->mppe_keys_set = 0;
  memset(&pcb->mppe_comp, 0, sizeof(pcb->mppe_comp));
  memset(&pcb->mppe_decomp, 0, sizeof(pcb->mppe_decomp));
#endif /* MPPE_SUPPORT */
#if VJ_SUPPORT
  vj_compress_init(&pcb->vj_comp);
 801a784:	687b      	ldr	r3, [r7, #4]
 801a786:	33dc      	adds	r3, #220	; 0xdc
 801a788:	0018      	movs	r0, r3
 801a78a:	f001 fc3e 	bl	801c00a <vj_compress_init>
#endif /* VJ_SUPPORT */

  /* Start protocol */
  new_phase(pcb, PPP_PHASE_ESTABLISH);
 801a78e:	687b      	ldr	r3, [r7, #4]
 801a790:	2106      	movs	r1, #6
 801a792:	0018      	movs	r0, r3
 801a794:	f000 f92b 	bl	801a9ee <new_phase>
  lcp_open(pcb);
 801a798:	687b      	ldr	r3, [r7, #4]
 801a79a:	0018      	movs	r0, r3
 801a79c:	f7fd fd1a 	bl	80181d4 <lcp_open>
  lcp_lowerup(pcb);
 801a7a0:	687b      	ldr	r3, [r7, #4]
 801a7a2:	0018      	movs	r0, r3
 801a7a4:	f7fd fd90 	bl	80182c8 <lcp_lowerup>
  PPPDEBUG(LOG_DEBUG, ("ppp_start[%d]: finished\n", pcb->netif->num));
}
 801a7a8:	46c0      	nop			; (mov r8, r8)
 801a7aa:	46bd      	mov	sp, r7
 801a7ac:	b002      	add	sp, #8
 801a7ae:	bd80      	pop	{r7, pc}

0801a7b0 <ppp_link_end>:
  pcb->err_code = PPPERR_OPEN;
  pcb->link_status_cb(pcb, pcb->err_code, pcb->ctx_cb);
}

/** Called when link is normally down (i.e. it was asked to end) */
void ppp_link_end(ppp_pcb *pcb) {
 801a7b0:	b590      	push	{r4, r7, lr}
 801a7b2:	b083      	sub	sp, #12
 801a7b4:	af00      	add	r7, sp, #0
 801a7b6:	6078      	str	r0, [r7, #4]
  PPPDEBUG(LOG_DEBUG, ("ppp_link_end[%d]\n", pcb->netif->num));
  new_phase(pcb, PPP_PHASE_DEAD);
 801a7b8:	687b      	ldr	r3, [r7, #4]
 801a7ba:	2100      	movs	r1, #0
 801a7bc:	0018      	movs	r0, r3
 801a7be:	f000 f916 	bl	801a9ee <new_phase>
  if (pcb->err_code == PPPERR_NONE) {
 801a7c2:	687b      	ldr	r3, [r7, #4]
 801a7c4:	2225      	movs	r2, #37	; 0x25
 801a7c6:	5c9b      	ldrb	r3, [r3, r2]
 801a7c8:	2b00      	cmp	r3, #0
 801a7ca:	d103      	bne.n	801a7d4 <ppp_link_end+0x24>
    pcb->err_code = PPPERR_CONNECT;
 801a7cc:	687b      	ldr	r3, [r7, #4]
 801a7ce:	2225      	movs	r2, #37	; 0x25
 801a7d0:	2106      	movs	r1, #6
 801a7d2:	5499      	strb	r1, [r3, r2]
  }
  pcb->link_status_cb(pcb, pcb->err_code, pcb->ctx_cb);
 801a7d4:	687b      	ldr	r3, [r7, #4]
 801a7d6:	695c      	ldr	r4, [r3, #20]
 801a7d8:	687b      	ldr	r3, [r7, #4]
 801a7da:	2225      	movs	r2, #37	; 0x25
 801a7dc:	5c9b      	ldrb	r3, [r3, r2]
 801a7de:	0019      	movs	r1, r3
 801a7e0:	687b      	ldr	r3, [r7, #4]
 801a7e2:	69da      	ldr	r2, [r3, #28]
 801a7e4:	687b      	ldr	r3, [r7, #4]
 801a7e6:	0018      	movs	r0, r3
 801a7e8:	47a0      	blx	r4
}
 801a7ea:	46c0      	nop			; (mov r8, r8)
 801a7ec:	46bd      	mov	sp, r7
 801a7ee:	b003      	add	sp, #12
 801a7f0:	bd90      	pop	{r4, r7, pc}
	...

0801a7f4 <ppp_input>:

/*
 * Pass the processed input packet to the appropriate handler.
 * This function and all handlers run in the context of the tcpip_thread
 */
void ppp_input(ppp_pcb *pcb, struct pbuf *pb) {
 801a7f4:	b590      	push	{r4, r7, lr}
 801a7f6:	b087      	sub	sp, #28
 801a7f8:	af00      	add	r7, sp, #0
 801a7fa:	6078      	str	r0, [r7, #4]
 801a7fc:	6039      	str	r1, [r7, #0]
  u16_t protocol;
#if PPP_DEBUG && PPP_PROTOCOLNAME
    const char *pname;
#endif /* PPP_DEBUG && PPP_PROTOCOLNAME */

  magic_randomize();
 801a7fe:	f7ff fd67 	bl	801a2d0 <magic_randomize>

  if (pb->len < 2) {
 801a802:	683b      	ldr	r3, [r7, #0]
 801a804:	895b      	ldrh	r3, [r3, #10]
 801a806:	2b01      	cmp	r3, #1
 801a808:	d800      	bhi.n	801a80c <ppp_input+0x18>
 801a80a:	e0b6      	b.n	801a97a <ppp_input+0x186>
    PPPDEBUG(LOG_ERR, ("ppp_input[%d]: packet too short\n", pcb->netif->num));
    goto drop;
  }
  protocol = (((u8_t *)pb->payload)[0] << 8) | ((u8_t*)pb->payload)[1];
 801a80c:	683b      	ldr	r3, [r7, #0]
 801a80e:	685b      	ldr	r3, [r3, #4]
 801a810:	781b      	ldrb	r3, [r3, #0]
 801a812:	021b      	lsls	r3, r3, #8
 801a814:	b21a      	sxth	r2, r3
 801a816:	683b      	ldr	r3, [r7, #0]
 801a818:	685b      	ldr	r3, [r3, #4]
 801a81a:	3301      	adds	r3, #1
 801a81c:	781b      	ldrb	r3, [r3, #0]
 801a81e:	b21b      	sxth	r3, r3
 801a820:	4313      	orrs	r3, r2
 801a822:	b21a      	sxth	r2, r3
 801a824:	2412      	movs	r4, #18
 801a826:	193b      	adds	r3, r7, r4
 801a828:	801a      	strh	r2, [r3, #0]

#if PRINTPKT_SUPPORT
  ppp_dump_packet(pcb, "rcvd", (unsigned char *)pb->payload, pb->len);
#endif /* PRINTPKT_SUPPORT */

  pbuf_remove_header(pb, sizeof(protocol));
 801a82a:	683b      	ldr	r3, [r7, #0]
 801a82c:	2102      	movs	r1, #2
 801a82e:	0018      	movs	r0, r3
 801a830:	f7ef fdbe 	bl	800a3b0 <pbuf_remove_header>
  MIB2_STATS_NETIF_ADD(pcb->netif, ifinoctets, pb->tot_len);

  /*
   * Toss all non-LCP packets unless LCP is OPEN.
   */
  if (protocol != PPP_LCP && pcb->lcp_fsm.state != PPP_FSM_OPENED) {
 801a834:	193b      	adds	r3, r7, r4
 801a836:	881b      	ldrh	r3, [r3, #0]
 801a838:	4a57      	ldr	r2, [pc, #348]	; (801a998 <ppp_input+0x1a4>)
 801a83a:	4293      	cmp	r3, r2
 801a83c:	d009      	beq.n	801a852 <ppp_input+0x5e>
 801a83e:	687b      	ldr	r3, [r7, #4]
 801a840:	2238      	movs	r2, #56	; 0x38
 801a842:	5c9b      	ldrb	r3, [r3, r2]
 801a844:	2b09      	cmp	r3, #9
 801a846:	d004      	beq.n	801a852 <ppp_input+0x5e>
    ppp_dbglog("Discarded non-LCP packet when LCP not open");
 801a848:	4b54      	ldr	r3, [pc, #336]	; (801a99c <ppp_input+0x1a8>)
 801a84a:	0018      	movs	r0, r3
 801a84c:	f001 fbc9 	bl	801bfe2 <ppp_dbglog>
    goto drop;
 801a850:	e09a      	b.n	801a988 <ppp_input+0x194>

  /*
   * Until we get past the authentication phase, toss all packets
   * except LCP, LQR and authentication packets.
   */
  if (pcb->phase <= PPP_PHASE_AUTHENTICATE
 801a852:	687b      	ldr	r3, [r7, #4]
 801a854:	2224      	movs	r2, #36	; 0x24
 801a856:	5c9b      	ldrb	r3, [r3, r2]
 801a858:	2b07      	cmp	r3, #7
 801a85a:	d810      	bhi.n	801a87e <ppp_input+0x8a>
   && !(protocol == PPP_LCP
 801a85c:	2112      	movs	r1, #18
 801a85e:	187b      	adds	r3, r7, r1
 801a860:	881b      	ldrh	r3, [r3, #0]
 801a862:	4a4d      	ldr	r2, [pc, #308]	; (801a998 <ppp_input+0x1a4>)
 801a864:	4293      	cmp	r3, r2
 801a866:	d00a      	beq.n	801a87e <ppp_input+0x8a>
#endif /* CHAP_SUPPORT */
#if EAP_SUPPORT
   || protocol == PPP_EAP
#endif /* EAP_SUPPORT */
   )) {
    ppp_dbglog("discarding proto 0x%x in phase %d", protocol, pcb->phase);
 801a868:	187b      	adds	r3, r7, r1
 801a86a:	8819      	ldrh	r1, [r3, #0]
 801a86c:	687b      	ldr	r3, [r7, #4]
 801a86e:	2224      	movs	r2, #36	; 0x24
 801a870:	5c9b      	ldrb	r3, [r3, r2]
 801a872:	001a      	movs	r2, r3
 801a874:	4b4a      	ldr	r3, [pc, #296]	; (801a9a0 <ppp_input+0x1ac>)
 801a876:	0018      	movs	r0, r3
 801a878:	f001 fbb3 	bl	801bfe2 <ppp_dbglog>
    goto drop;
 801a87c:	e084      	b.n	801a988 <ppp_input+0x194>
      pbuf_remove_header(pb, 2);
    }
  }
#endif /* CCP_SUPPORT */

  switch(protocol) {
 801a87e:	2312      	movs	r3, #18
 801a880:	18fb      	adds	r3, r7, r3
 801a882:	881b      	ldrh	r3, [r3, #0]
 801a884:	2b2f      	cmp	r3, #47	; 0x2f
 801a886:	d027      	beq.n	801a8d8 <ppp_input+0xe4>
 801a888:	dc3f      	bgt.n	801a90a <ppp_input+0x116>
 801a88a:	2b21      	cmp	r3, #33	; 0x21
 801a88c:	d002      	beq.n	801a894 <ppp_input+0xa0>
 801a88e:	2b2d      	cmp	r3, #45	; 0x2d
 801a890:	d008      	beq.n	801a8a4 <ppp_input+0xb0>
 801a892:	e03a      	b.n	801a90a <ppp_input+0x116>

#if PPP_IPV4_SUPPORT
    case PPP_IP:            /* Internet Protocol */
      PPPDEBUG(LOG_INFO, ("ppp_input[%d]: ip in pbuf len=%d\n", pcb->netif->num, pb->tot_len));
      ip4_input(pb, pcb->netif);
 801a894:	683a      	ldr	r2, [r7, #0]
 801a896:	687b      	ldr	r3, [r7, #4]
 801a898:	6a1b      	ldr	r3, [r3, #32]
 801a89a:	0019      	movs	r1, r3
 801a89c:	0010      	movs	r0, r2
 801a89e:	f7f9 faa7 	bl	8013df0 <ip4_input>
      return;
 801a8a2:	e075      	b.n	801a990 <ppp_input+0x19c>
      /*
       * Clip off the VJ header and prepend the rebuilt TCP/IP header and
       * pass the result to IP.
       */
      PPPDEBUG(LOG_INFO, ("ppp_input[%d]: vj_comp in pbuf len=%d\n", pcb->netif->num, pb->tot_len));
      if (pcb->vj_enabled && vj_uncompress_tcp(&pb, &pcb->vj_comp) >= 0) {
 801a8a4:	687b      	ldr	r3, [r7, #4]
 801a8a6:	2226      	movs	r2, #38	; 0x26
 801a8a8:	5c9b      	ldrb	r3, [r3, r2]
 801a8aa:	2220      	movs	r2, #32
 801a8ac:	4013      	ands	r3, r2
 801a8ae:	b2db      	uxtb	r3, r3
 801a8b0:	2b00      	cmp	r3, #0
 801a8b2:	d064      	beq.n	801a97e <ppp_input+0x18a>
 801a8b4:	687b      	ldr	r3, [r7, #4]
 801a8b6:	33dc      	adds	r3, #220	; 0xdc
 801a8b8:	001a      	movs	r2, r3
 801a8ba:	003b      	movs	r3, r7
 801a8bc:	0011      	movs	r1, r2
 801a8be:	0018      	movs	r0, r3
 801a8c0:	f002 f8fe 	bl	801cac0 <vj_uncompress_tcp>
 801a8c4:	1e03      	subs	r3, r0, #0
 801a8c6:	db5a      	blt.n	801a97e <ppp_input+0x18a>
        ip4_input(pb, pcb->netif);
 801a8c8:	683a      	ldr	r2, [r7, #0]
 801a8ca:	687b      	ldr	r3, [r7, #4]
 801a8cc:	6a1b      	ldr	r3, [r3, #32]
 801a8ce:	0019      	movs	r1, r3
 801a8d0:	0010      	movs	r0, r2
 801a8d2:	f7f9 fa8d 	bl	8013df0 <ip4_input>
        return;
 801a8d6:	e05b      	b.n	801a990 <ppp_input+0x19c>
      /*
       * Process the TCP/IP header for VJ header compression and then pass
       * the packet to IP.
       */
      PPPDEBUG(LOG_INFO, ("ppp_input[%d]: vj_un in pbuf len=%d\n", pcb->netif->num, pb->tot_len));
      if (pcb->vj_enabled && vj_uncompress_uncomp(pb, &pcb->vj_comp) >= 0) {
 801a8d8:	687b      	ldr	r3, [r7, #4]
 801a8da:	2226      	movs	r2, #38	; 0x26
 801a8dc:	5c9b      	ldrb	r3, [r3, r2]
 801a8de:	2220      	movs	r2, #32
 801a8e0:	4013      	ands	r3, r2
 801a8e2:	b2db      	uxtb	r3, r3
 801a8e4:	2b00      	cmp	r3, #0
 801a8e6:	d04c      	beq.n	801a982 <ppp_input+0x18e>
 801a8e8:	683a      	ldr	r2, [r7, #0]
 801a8ea:	687b      	ldr	r3, [r7, #4]
 801a8ec:	33dc      	adds	r3, #220	; 0xdc
 801a8ee:	0019      	movs	r1, r3
 801a8f0:	0010      	movs	r0, r2
 801a8f2:	f002 f877 	bl	801c9e4 <vj_uncompress_uncomp>
 801a8f6:	1e03      	subs	r3, r0, #0
 801a8f8:	db43      	blt.n	801a982 <ppp_input+0x18e>
        ip4_input(pb, pcb->netif);
 801a8fa:	683a      	ldr	r2, [r7, #0]
 801a8fc:	687b      	ldr	r3, [r7, #4]
 801a8fe:	6a1b      	ldr	r3, [r3, #32]
 801a900:	0019      	movs	r1, r3
 801a902:	0010      	movs	r0, r2
 801a904:	f7f9 fa74 	bl	8013df0 <ip4_input>
        return;
 801a908:	e042      	b.n	801a990 <ppp_input+0x19c>
      const struct protent *protp;

      /*
       * Upcall the proper protocol input routine.
       */
      for (i = 0; (protp = protocols[i]) != NULL; ++i) {
 801a90a:	2300      	movs	r3, #0
 801a90c:	617b      	str	r3, [r7, #20]
 801a90e:	e01b      	b.n	801a948 <ppp_input+0x154>
        if (protp->protocol == protocol) {
 801a910:	68fb      	ldr	r3, [r7, #12]
 801a912:	881b      	ldrh	r3, [r3, #0]
 801a914:	2212      	movs	r2, #18
 801a916:	18ba      	adds	r2, r7, r2
 801a918:	8812      	ldrh	r2, [r2, #0]
 801a91a:	429a      	cmp	r2, r3
 801a91c:	d111      	bne.n	801a942 <ppp_input+0x14e>
          pb = pbuf_coalesce(pb, PBUF_RAW);
 801a91e:	683b      	ldr	r3, [r7, #0]
 801a920:	2100      	movs	r1, #0
 801a922:	0018      	movs	r0, r3
 801a924:	f7f0 fa92 	bl	800ae4c <pbuf_coalesce>
 801a928:	0003      	movs	r3, r0
 801a92a:	603b      	str	r3, [r7, #0]
          (*protp->input)(pcb, (u8_t*)pb->payload, pb->len);
 801a92c:	68fb      	ldr	r3, [r7, #12]
 801a92e:	689c      	ldr	r4, [r3, #8]
 801a930:	683b      	ldr	r3, [r7, #0]
 801a932:	6859      	ldr	r1, [r3, #4]
 801a934:	683b      	ldr	r3, [r7, #0]
 801a936:	895b      	ldrh	r3, [r3, #10]
 801a938:	001a      	movs	r2, r3
 801a93a:	687b      	ldr	r3, [r7, #4]
 801a93c:	0018      	movs	r0, r3
 801a93e:	47a0      	blx	r4
          goto out;
 801a940:	e022      	b.n	801a988 <ppp_input+0x194>
      for (i = 0; (protp = protocols[i]) != NULL; ++i) {
 801a942:	697b      	ldr	r3, [r7, #20]
 801a944:	3301      	adds	r3, #1
 801a946:	617b      	str	r3, [r7, #20]
 801a948:	4b16      	ldr	r3, [pc, #88]	; (801a9a4 <ppp_input+0x1b0>)
 801a94a:	697a      	ldr	r2, [r7, #20]
 801a94c:	0092      	lsls	r2, r2, #2
 801a94e:	58d3      	ldr	r3, [r2, r3]
 801a950:	60fb      	str	r3, [r7, #12]
 801a952:	68fb      	ldr	r3, [r7, #12]
 801a954:	2b00      	cmp	r3, #0
 801a956:	d1db      	bne.n	801a910 <ppp_input+0x11c>
        ppp_warn("Unsupported protocol '%s' (0x%x) received", pname, protocol);
      } else
#endif /* PPP_PROTOCOLNAME */
        ppp_warn("Unsupported protocol 0x%x received", protocol);
#endif /* PPP_DEBUG */
        if (pbuf_add_header(pb, sizeof(protocol))) {
 801a958:	683b      	ldr	r3, [r7, #0]
 801a95a:	2102      	movs	r1, #2
 801a95c:	0018      	movs	r0, r3
 801a95e:	f7ef fd17 	bl	800a390 <pbuf_add_header>
 801a962:	1e03      	subs	r3, r0, #0
 801a964:	d10f      	bne.n	801a986 <ppp_input+0x192>
          PPPDEBUG(LOG_WARNING, ("ppp_input[%d]: Dropping (pbuf_add_header failed)\n", pcb->netif->num));
          goto drop;
        }
        lcp_sprotrej(pcb, (u8_t*)pb->payload, pb->len);
 801a966:	683b      	ldr	r3, [r7, #0]
 801a968:	6859      	ldr	r1, [r3, #4]
 801a96a:	683b      	ldr	r3, [r7, #0]
 801a96c:	895b      	ldrh	r3, [r3, #10]
 801a96e:	001a      	movs	r2, r3
 801a970:	687b      	ldr	r3, [r7, #4]
 801a972:	0018      	movs	r0, r3
 801a974:	f7fd fe46 	bl	8018604 <lcp_sprotrej>
      }
      break;
 801a978:	e006      	b.n	801a988 <ppp_input+0x194>
    goto drop;
 801a97a:	46c0      	nop			; (mov r8, r8)
 801a97c:	e004      	b.n	801a988 <ppp_input+0x194>
      break;
 801a97e:	46c0      	nop			; (mov r8, r8)
 801a980:	e002      	b.n	801a988 <ppp_input+0x194>
      break;
 801a982:	46c0      	nop			; (mov r8, r8)
 801a984:	e000      	b.n	801a988 <ppp_input+0x194>
          goto drop;
 801a986:	46c0      	nop			; (mov r8, r8)
drop:
  LINK_STATS_INC(link.drop);
  MIB2_STATS_NETIF_INC(pcb->netif, ifindiscards);

out:
  pbuf_free(pb);
 801a988:	683b      	ldr	r3, [r7, #0]
 801a98a:	0018      	movs	r0, r3
 801a98c:	f7ef fda6 	bl	800a4dc <pbuf_free>
}
 801a990:	46bd      	mov	sp, r7
 801a992:	b007      	add	sp, #28
 801a994:	bd90      	pop	{r4, r7, pc}
 801a996:	46c0      	nop			; (mov r8, r8)
 801a998:	0000c021 	.word	0x0000c021
 801a99c:	08022bac 	.word	0x08022bac
 801a9a0:	08022bd8 	.word	0x08022bd8
 801a9a4:	08023cf8 	.word	0x08023cf8

0801a9a8 <ppp_write>:
 *
 * IPv4 and IPv6 packets from lwIP are sent, respectively,
 * with ppp_netif_output_ip4() and ppp_netif_output_ip6()
 * functions (which are callbacks of the netif PPP interface).
 */
err_t ppp_write(ppp_pcb *pcb, struct pbuf *p) {
 801a9a8:	b590      	push	{r4, r7, lr}
 801a9aa:	b083      	sub	sp, #12
 801a9ac:	af00      	add	r7, sp, #0
 801a9ae:	6078      	str	r0, [r7, #4]
 801a9b0:	6039      	str	r1, [r7, #0]
#if PRINTPKT_SUPPORT
  ppp_dump_packet(pcb, "sent", (unsigned char *)p->payload+2, p->len-2);
#endif /* PRINTPKT_SUPPORT */
  return pcb->link_cb->write(pcb, pcb->link_ctx_cb, p);
 801a9b2:	687b      	ldr	r3, [r7, #4]
 801a9b4:	68db      	ldr	r3, [r3, #12]
 801a9b6:	68dc      	ldr	r4, [r3, #12]
 801a9b8:	687b      	ldr	r3, [r7, #4]
 801a9ba:	6919      	ldr	r1, [r3, #16]
 801a9bc:	683a      	ldr	r2, [r7, #0]
 801a9be:	687b      	ldr	r3, [r7, #4]
 801a9c0:	0018      	movs	r0, r3
 801a9c2:	47a0      	blx	r4
 801a9c4:	0003      	movs	r3, r0
}
 801a9c6:	0018      	movs	r0, r3
 801a9c8:	46bd      	mov	sp, r7
 801a9ca:	b003      	add	sp, #12
 801a9cc:	bd90      	pop	{r4, r7, pc}

0801a9ce <ppp_link_terminated>:

void ppp_link_terminated(ppp_pcb *pcb) {
 801a9ce:	b580      	push	{r7, lr}
 801a9d0:	b082      	sub	sp, #8
 801a9d2:	af00      	add	r7, sp, #0
 801a9d4:	6078      	str	r0, [r7, #4]
  PPPDEBUG(LOG_DEBUG, ("ppp_link_terminated[%d]\n", pcb->netif->num));
  pcb->link_cb->disconnect(pcb, pcb->link_ctx_cb);
 801a9d6:	687b      	ldr	r3, [r7, #4]
 801a9d8:	68db      	ldr	r3, [r3, #12]
 801a9da:	685a      	ldr	r2, [r3, #4]
 801a9dc:	687b      	ldr	r3, [r7, #4]
 801a9de:	6919      	ldr	r1, [r3, #16]
 801a9e0:	687b      	ldr	r3, [r7, #4]
 801a9e2:	0018      	movs	r0, r3
 801a9e4:	4790      	blx	r2
  PPPDEBUG(LOG_DEBUG, ("ppp_link_terminated[%d]: finished.\n", pcb->netif->num));
}
 801a9e6:	46c0      	nop			; (mov r8, r8)
 801a9e8:	46bd      	mov	sp, r7
 801a9ea:	b002      	add	sp, #8
 801a9ec:	bd80      	pop	{r7, pc}

0801a9ee <new_phase>:
 */

/*
 * new_phase - signal the start of a new phase of pppd's operation.
 */
void new_phase(ppp_pcb *pcb, int p) {
 801a9ee:	b590      	push	{r4, r7, lr}
 801a9f0:	b083      	sub	sp, #12
 801a9f2:	af00      	add	r7, sp, #0
 801a9f4:	6078      	str	r0, [r7, #4]
 801a9f6:	6039      	str	r1, [r7, #0]
  pcb->phase = p;
 801a9f8:	683b      	ldr	r3, [r7, #0]
 801a9fa:	b2d9      	uxtb	r1, r3
 801a9fc:	687b      	ldr	r3, [r7, #4]
 801a9fe:	2224      	movs	r2, #36	; 0x24
 801aa00:	5499      	strb	r1, [r3, r2]
  PPPDEBUG(LOG_DEBUG, ("ppp phase changed[%d]: phase=%d\n", pcb->netif->num, pcb->phase));
#if PPP_NOTIFY_PHASE
  if (pcb->notify_phase_cb != NULL) {
 801aa02:	687b      	ldr	r3, [r7, #4]
 801aa04:	699b      	ldr	r3, [r3, #24]
 801aa06:	2b00      	cmp	r3, #0
 801aa08:	d008      	beq.n	801aa1c <new_phase+0x2e>
    pcb->notify_phase_cb(pcb, p, pcb->ctx_cb);
 801aa0a:	687b      	ldr	r3, [r7, #4]
 801aa0c:	699c      	ldr	r4, [r3, #24]
 801aa0e:	683b      	ldr	r3, [r7, #0]
 801aa10:	b2d9      	uxtb	r1, r3
 801aa12:	687b      	ldr	r3, [r7, #4]
 801aa14:	69da      	ldr	r2, [r3, #28]
 801aa16:	687b      	ldr	r3, [r7, #4]
 801aa18:	0018      	movs	r0, r3
 801aa1a:	47a0      	blx	r4
  }
#endif /* PPP_NOTIFY_PHASE */
}
 801aa1c:	46c0      	nop			; (mov r8, r8)
 801aa1e:	46bd      	mov	sp, r7
 801aa20:	b003      	add	sp, #12
 801aa22:	bd90      	pop	{r4, r7, pc}

0801aa24 <ppp_send_config>:

/*
 * ppp_send_config - configure the transmit-side characteristics of
 * the ppp interface.
 */
int ppp_send_config(ppp_pcb *pcb, int mtu, u32_t accm, int pcomp, int accomp) {
 801aa24:	b5b0      	push	{r4, r5, r7, lr}
 801aa26:	b086      	sub	sp, #24
 801aa28:	af02      	add	r7, sp, #8
 801aa2a:	60f8      	str	r0, [r7, #12]
 801aa2c:	60b9      	str	r1, [r7, #8]
 801aa2e:	607a      	str	r2, [r7, #4]
 801aa30:	603b      	str	r3, [r7, #0]
  LWIP_UNUSED_ARG(mtu);
  /* pcb->mtu = mtu; -- set correctly with netif_set_mtu */

  if (pcb->link_cb->send_config) {
 801aa32:	68fb      	ldr	r3, [r7, #12]
 801aa34:	68db      	ldr	r3, [r3, #12]
 801aa36:	695b      	ldr	r3, [r3, #20]
 801aa38:	2b00      	cmp	r3, #0
 801aa3a:	d00b      	beq.n	801aa54 <ppp_send_config+0x30>
    pcb->link_cb->send_config(pcb, pcb->link_ctx_cb, accm, pcomp, accomp);
 801aa3c:	68fb      	ldr	r3, [r7, #12]
 801aa3e:	68db      	ldr	r3, [r3, #12]
 801aa40:	695c      	ldr	r4, [r3, #20]
 801aa42:	68fb      	ldr	r3, [r7, #12]
 801aa44:	6919      	ldr	r1, [r3, #16]
 801aa46:	683d      	ldr	r5, [r7, #0]
 801aa48:	687a      	ldr	r2, [r7, #4]
 801aa4a:	68f8      	ldr	r0, [r7, #12]
 801aa4c:	6a3b      	ldr	r3, [r7, #32]
 801aa4e:	9300      	str	r3, [sp, #0]
 801aa50:	002b      	movs	r3, r5
 801aa52:	47a0      	blx	r4
  }

  PPPDEBUG(LOG_INFO, ("ppp_send_config[%d]\n", pcb->netif->num) );
  return 0;
 801aa54:	2300      	movs	r3, #0
}
 801aa56:	0018      	movs	r0, r3
 801aa58:	46bd      	mov	sp, r7
 801aa5a:	b004      	add	sp, #16
 801aa5c:	bdb0      	pop	{r4, r5, r7, pc}

0801aa5e <ppp_recv_config>:

/*
 * ppp_recv_config - configure the receive-side characteristics of
 * the ppp interface.
 */
int ppp_recv_config(ppp_pcb *pcb, int mru, u32_t accm, int pcomp, int accomp) {
 801aa5e:	b5b0      	push	{r4, r5, r7, lr}
 801aa60:	b086      	sub	sp, #24
 801aa62:	af02      	add	r7, sp, #8
 801aa64:	60f8      	str	r0, [r7, #12]
 801aa66:	60b9      	str	r1, [r7, #8]
 801aa68:	607a      	str	r2, [r7, #4]
 801aa6a:	603b      	str	r3, [r7, #0]
  LWIP_UNUSED_ARG(mru);

  if (pcb->link_cb->recv_config) {
 801aa6c:	68fb      	ldr	r3, [r7, #12]
 801aa6e:	68db      	ldr	r3, [r3, #12]
 801aa70:	699b      	ldr	r3, [r3, #24]
 801aa72:	2b00      	cmp	r3, #0
 801aa74:	d00b      	beq.n	801aa8e <ppp_recv_config+0x30>
    pcb->link_cb->recv_config(pcb, pcb->link_ctx_cb, accm, pcomp, accomp);
 801aa76:	68fb      	ldr	r3, [r7, #12]
 801aa78:	68db      	ldr	r3, [r3, #12]
 801aa7a:	699c      	ldr	r4, [r3, #24]
 801aa7c:	68fb      	ldr	r3, [r7, #12]
 801aa7e:	6919      	ldr	r1, [r3, #16]
 801aa80:	683d      	ldr	r5, [r7, #0]
 801aa82:	687a      	ldr	r2, [r7, #4]
 801aa84:	68f8      	ldr	r0, [r7, #12]
 801aa86:	6a3b      	ldr	r3, [r7, #32]
 801aa88:	9300      	str	r3, [sp, #0]
 801aa8a:	002b      	movs	r3, r5
 801aa8c:	47a0      	blx	r4
  }

  PPPDEBUG(LOG_INFO, ("ppp_recv_config[%d]\n", pcb->netif->num));
  return 0;
 801aa8e:	2300      	movs	r3, #0
}
 801aa90:	0018      	movs	r0, r3
 801aa92:	46bd      	mov	sp, r7
 801aa94:	b004      	add	sp, #16
 801aa96:	bdb0      	pop	{r4, r5, r7, pc}

0801aa98 <sifaddr>:

#if PPP_IPV4_SUPPORT
/*
 * sifaddr - Config the interface IP addresses and netmask.
 */
int sifaddr(ppp_pcb *pcb, u32_t our_adr, u32_t his_adr, u32_t netmask) {
 801aa98:	b580      	push	{r7, lr}
 801aa9a:	b088      	sub	sp, #32
 801aa9c:	af00      	add	r7, sp, #0
 801aa9e:	60f8      	str	r0, [r7, #12]
 801aaa0:	60b9      	str	r1, [r7, #8]
 801aaa2:	607a      	str	r2, [r7, #4]
 801aaa4:	603b      	str	r3, [r7, #0]
  ip4_addr_t ip, nm, gw;

  ip4_addr_set_u32(&ip, our_adr);
 801aaa6:	68bb      	ldr	r3, [r7, #8]
 801aaa8:	61fb      	str	r3, [r7, #28]
  ip4_addr_set_u32(&nm, netmask);
 801aaaa:	683b      	ldr	r3, [r7, #0]
 801aaac:	61bb      	str	r3, [r7, #24]
  ip4_addr_set_u32(&gw, his_adr);
 801aaae:	687b      	ldr	r3, [r7, #4]
 801aab0:	617b      	str	r3, [r7, #20]
  netif_set_addr(pcb->netif, &ip, &nm, &gw);
 801aab2:	68fb      	ldr	r3, [r7, #12]
 801aab4:	6a18      	ldr	r0, [r3, #32]
 801aab6:	2314      	movs	r3, #20
 801aab8:	18fb      	adds	r3, r7, r3
 801aaba:	2218      	movs	r2, #24
 801aabc:	18ba      	adds	r2, r7, r2
 801aabe:	211c      	movs	r1, #28
 801aac0:	1879      	adds	r1, r7, r1
 801aac2:	f7ee fff5 	bl	8009ab0 <netif_set_addr>
  return 1;
 801aac6:	2301      	movs	r3, #1
}
 801aac8:	0018      	movs	r0, r3
 801aaca:	46bd      	mov	sp, r7
 801aacc:	b008      	add	sp, #32
 801aace:	bd80      	pop	{r7, pc}

0801aad0 <cifaddr>:
/********************************************************************
 *
 * cifaddr - Clear the interface IP addresses, and delete routes
 * through the interface if possible.
 */
int cifaddr(ppp_pcb *pcb, u32_t our_adr, u32_t his_adr) {
 801aad0:	b580      	push	{r7, lr}
 801aad2:	b084      	sub	sp, #16
 801aad4:	af00      	add	r7, sp, #0
 801aad6:	60f8      	str	r0, [r7, #12]
 801aad8:	60b9      	str	r1, [r7, #8]
 801aada:	607a      	str	r2, [r7, #4]
  LWIP_UNUSED_ARG(our_adr);
  LWIP_UNUSED_ARG(his_adr);

  netif_set_addr(pcb->netif, IP4_ADDR_ANY4, IP4_ADDR_BROADCAST, IP4_ADDR_ANY4);
 801aadc:	68fb      	ldr	r3, [r7, #12]
 801aade:	6a18      	ldr	r0, [r3, #32]
 801aae0:	4b04      	ldr	r3, [pc, #16]	; (801aaf4 <cifaddr+0x24>)
 801aae2:	4a05      	ldr	r2, [pc, #20]	; (801aaf8 <cifaddr+0x28>)
 801aae4:	4903      	ldr	r1, [pc, #12]	; (801aaf4 <cifaddr+0x24>)
 801aae6:	f7ee ffe3 	bl	8009ab0 <netif_set_addr>
  return 1;
 801aaea:	2301      	movs	r3, #1
}
 801aaec:	0018      	movs	r0, r3
 801aaee:	46bd      	mov	sp, r7
 801aaf0:	b004      	add	sp, #16
 801aaf2:	bd80      	pop	{r7, pc}
 801aaf4:	08023a8c 	.word	0x08023a8c
 801aaf8:	08023a90 	.word	0x08023a90

0801aafc <sdns>:

#if LWIP_DNS
/*
 * sdns - Config the DNS servers
 */
int sdns(ppp_pcb *pcb, u32_t ns1, u32_t ns2) {
 801aafc:	b590      	push	{r4, r7, lr}
 801aafe:	b087      	sub	sp, #28
 801ab00:	af00      	add	r7, sp, #0
 801ab02:	60f8      	str	r0, [r7, #12]
 801ab04:	60b9      	str	r1, [r7, #8]
 801ab06:	607a      	str	r2, [r7, #4]
  ip_addr_t ns;
  LWIP_UNUSED_ARG(pcb);

  ip_addr_set_ip4_u32_val(ns, ns1);
 801ab08:	68bb      	ldr	r3, [r7, #8]
 801ab0a:	617b      	str	r3, [r7, #20]
  dns_setserver(0, &ns);
 801ab0c:	2414      	movs	r4, #20
 801ab0e:	193b      	adds	r3, r7, r4
 801ab10:	0019      	movs	r1, r3
 801ab12:	2000      	movs	r0, #0
 801ab14:	f7ec fcf4 	bl	8007500 <dns_setserver>
  ip_addr_set_ip4_u32_val(ns, ns2);
 801ab18:	687b      	ldr	r3, [r7, #4]
 801ab1a:	617b      	str	r3, [r7, #20]
  dns_setserver(1, &ns);
 801ab1c:	193b      	adds	r3, r7, r4
 801ab1e:	0019      	movs	r1, r3
 801ab20:	2001      	movs	r0, #1
 801ab22:	f7ec fced 	bl	8007500 <dns_setserver>
  return 1;
 801ab26:	2301      	movs	r3, #1
}
 801ab28:	0018      	movs	r0, r3
 801ab2a:	46bd      	mov	sp, r7
 801ab2c:	b007      	add	sp, #28
 801ab2e:	bd90      	pop	{r4, r7, pc}

0801ab30 <cdns>:

/********************************************************************
 *
 * cdns - Clear the DNS servers
 */
int cdns(ppp_pcb *pcb, u32_t ns1, u32_t ns2) {
 801ab30:	b580      	push	{r7, lr}
 801ab32:	b086      	sub	sp, #24
 801ab34:	af00      	add	r7, sp, #0
 801ab36:	60f8      	str	r0, [r7, #12]
 801ab38:	60b9      	str	r1, [r7, #8]
 801ab3a:	607a      	str	r2, [r7, #4]
  const ip_addr_t *nsa;
  ip_addr_t nsb;
  LWIP_UNUSED_ARG(pcb);

  nsa = dns_getserver(0);
 801ab3c:	2000      	movs	r0, #0
 801ab3e:	f7ec fd05 	bl	800754c <dns_getserver>
 801ab42:	0003      	movs	r3, r0
 801ab44:	617b      	str	r3, [r7, #20]
  ip_addr_set_ip4_u32_val(nsb, ns1);
 801ab46:	68bb      	ldr	r3, [r7, #8]
 801ab48:	613b      	str	r3, [r7, #16]
  if (ip_addr_cmp(nsa, &nsb)) {
 801ab4a:	697b      	ldr	r3, [r7, #20]
 801ab4c:	681a      	ldr	r2, [r3, #0]
 801ab4e:	693b      	ldr	r3, [r7, #16]
 801ab50:	429a      	cmp	r2, r3
 801ab52:	d104      	bne.n	801ab5e <cdns+0x2e>
    dns_setserver(0, IP_ADDR_ANY);
 801ab54:	4b0d      	ldr	r3, [pc, #52]	; (801ab8c <cdns+0x5c>)
 801ab56:	0019      	movs	r1, r3
 801ab58:	2000      	movs	r0, #0
 801ab5a:	f7ec fcd1 	bl	8007500 <dns_setserver>
  }
  nsa = dns_getserver(1);
 801ab5e:	2001      	movs	r0, #1
 801ab60:	f7ec fcf4 	bl	800754c <dns_getserver>
 801ab64:	0003      	movs	r3, r0
 801ab66:	617b      	str	r3, [r7, #20]
  ip_addr_set_ip4_u32_val(nsb, ns2);
 801ab68:	687b      	ldr	r3, [r7, #4]
 801ab6a:	613b      	str	r3, [r7, #16]
  if (ip_addr_cmp(nsa, &nsb)) {
 801ab6c:	697b      	ldr	r3, [r7, #20]
 801ab6e:	681a      	ldr	r2, [r3, #0]
 801ab70:	693b      	ldr	r3, [r7, #16]
 801ab72:	429a      	cmp	r2, r3
 801ab74:	d104      	bne.n	801ab80 <cdns+0x50>
    dns_setserver(1, IP_ADDR_ANY);
 801ab76:	4b05      	ldr	r3, [pc, #20]	; (801ab8c <cdns+0x5c>)
 801ab78:	0019      	movs	r1, r3
 801ab7a:	2001      	movs	r0, #1
 801ab7c:	f7ec fcc0 	bl	8007500 <dns_setserver>
  }
  return 1;
 801ab80:	2301      	movs	r3, #1
}
 801ab82:	0018      	movs	r0, r3
 801ab84:	46bd      	mov	sp, r7
 801ab86:	b006      	add	sp, #24
 801ab88:	bd80      	pop	{r7, pc}
 801ab8a:	46c0      	nop			; (mov r8, r8)
 801ab8c:	08023a8c 	.word	0x08023a8c

0801ab90 <sifvjcomp>:
#if VJ_SUPPORT
/********************************************************************
 *
 * sifvjcomp - config tcp header compression
 */
int sifvjcomp(ppp_pcb *pcb, int vjcomp, int cidcomp, int maxcid) {
 801ab90:	b590      	push	{r4, r7, lr}
 801ab92:	b085      	sub	sp, #20
 801ab94:	af00      	add	r7, sp, #0
 801ab96:	60f8      	str	r0, [r7, #12]
 801ab98:	60b9      	str	r1, [r7, #8]
 801ab9a:	607a      	str	r2, [r7, #4]
 801ab9c:	603b      	str	r3, [r7, #0]
  pcb->vj_enabled = vjcomp;
 801ab9e:	68bb      	ldr	r3, [r7, #8]
 801aba0:	1c1a      	adds	r2, r3, #0
 801aba2:	2301      	movs	r3, #1
 801aba4:	4013      	ands	r3, r2
 801aba6:	b2d9      	uxtb	r1, r3
 801aba8:	68fb      	ldr	r3, [r7, #12]
 801abaa:	2226      	movs	r2, #38	; 0x26
 801abac:	2001      	movs	r0, #1
 801abae:	4001      	ands	r1, r0
 801abb0:	014c      	lsls	r4, r1, #5
 801abb2:	5c99      	ldrb	r1, [r3, r2]
 801abb4:	2020      	movs	r0, #32
 801abb6:	4381      	bics	r1, r0
 801abb8:	1c08      	adds	r0, r1, #0
 801abba:	1c21      	adds	r1, r4, #0
 801abbc:	4301      	orrs	r1, r0
 801abbe:	5499      	strb	r1, [r3, r2]
  pcb->vj_comp.compressSlot = cidcomp;
 801abc0:	687b      	ldr	r3, [r7, #4]
 801abc2:	b2d9      	uxtb	r1, r3
 801abc4:	68fb      	ldr	r3, [r7, #12]
 801abc6:	22e5      	movs	r2, #229	; 0xe5
 801abc8:	5499      	strb	r1, [r3, r2]
  pcb->vj_comp.maxSlotIndex = maxcid;
 801abca:	683b      	ldr	r3, [r7, #0]
 801abcc:	b2d9      	uxtb	r1, r3
 801abce:	68fb      	ldr	r3, [r7, #12]
 801abd0:	22e4      	movs	r2, #228	; 0xe4
 801abd2:	5499      	strb	r1, [r3, r2]
  PPPDEBUG(LOG_INFO, ("sifvjcomp[%d]: VJ compress enable=%d slot=%d max slot=%d\n",
            pcb->netif->num, vjcomp, cidcomp, maxcid));
  return 0;
 801abd4:	2300      	movs	r3, #0
}
 801abd6:	0018      	movs	r0, r3
 801abd8:	46bd      	mov	sp, r7
 801abda:	b005      	add	sp, #20
 801abdc:	bd90      	pop	{r4, r7, pc}

0801abde <sifup>:
#endif /* VJ_SUPPORT */

/*
 * sifup - Config the interface up and enable IP packets to pass.
 */
int sifup(ppp_pcb *pcb) {
 801abde:	b590      	push	{r4, r7, lr}
 801abe0:	b083      	sub	sp, #12
 801abe2:	af00      	add	r7, sp, #0
 801abe4:	6078      	str	r0, [r7, #4]
  pcb->if4_up = 1;
 801abe6:	687b      	ldr	r3, [r7, #4]
 801abe8:	2226      	movs	r2, #38	; 0x26
 801abea:	5c99      	ldrb	r1, [r3, r2]
 801abec:	2008      	movs	r0, #8
 801abee:	4301      	orrs	r1, r0
 801abf0:	5499      	strb	r1, [r3, r2]
  pcb->err_code = PPPERR_NONE;
 801abf2:	687b      	ldr	r3, [r7, #4]
 801abf4:	2225      	movs	r2, #37	; 0x25
 801abf6:	2100      	movs	r1, #0
 801abf8:	5499      	strb	r1, [r3, r2]
  netif_set_link_up(pcb->netif);
 801abfa:	687b      	ldr	r3, [r7, #4]
 801abfc:	6a1b      	ldr	r3, [r3, #32]
 801abfe:	0018      	movs	r0, r3
 801ac00:	f7ef f852 	bl	8009ca8 <netif_set_link_up>

  PPPDEBUG(LOG_DEBUG, ("sifup[%d]: err_code=%d\n", pcb->netif->num, pcb->err_code));
  pcb->link_status_cb(pcb, pcb->err_code, pcb->ctx_cb);
 801ac04:	687b      	ldr	r3, [r7, #4]
 801ac06:	695c      	ldr	r4, [r3, #20]
 801ac08:	687b      	ldr	r3, [r7, #4]
 801ac0a:	2225      	movs	r2, #37	; 0x25
 801ac0c:	5c9b      	ldrb	r3, [r3, r2]
 801ac0e:	0019      	movs	r1, r3
 801ac10:	687b      	ldr	r3, [r7, #4]
 801ac12:	69da      	ldr	r2, [r3, #28]
 801ac14:	687b      	ldr	r3, [r7, #4]
 801ac16:	0018      	movs	r0, r3
 801ac18:	47a0      	blx	r4
  return 1;
 801ac1a:	2301      	movs	r3, #1
}
 801ac1c:	0018      	movs	r0, r3
 801ac1e:	46bd      	mov	sp, r7
 801ac20:	b003      	add	sp, #12
 801ac22:	bd90      	pop	{r4, r7, pc}

0801ac24 <sifdown>:
/********************************************************************
 *
 * sifdown - Disable the indicated protocol and config the interface
 *           down if there are no remaining protocols.
 */
int sifdown(ppp_pcb *pcb) {
 801ac24:	b580      	push	{r7, lr}
 801ac26:	b082      	sub	sp, #8
 801ac28:	af00      	add	r7, sp, #0
 801ac2a:	6078      	str	r0, [r7, #4]

  pcb->if4_up = 0;
 801ac2c:	687b      	ldr	r3, [r7, #4]
 801ac2e:	2226      	movs	r2, #38	; 0x26
 801ac30:	5c99      	ldrb	r1, [r3, r2]
 801ac32:	2008      	movs	r0, #8
 801ac34:	4381      	bics	r1, r0
 801ac36:	5499      	strb	r1, [r3, r2]
   /* set the interface down if IPv6 is down as well */
   && !pcb->if6_up
#endif /* PPP_IPV6_SUPPORT */
  ) {
    /* make sure the netif link callback is called */
    netif_set_link_down(pcb->netif);
 801ac38:	687b      	ldr	r3, [r7, #4]
 801ac3a:	6a1b      	ldr	r3, [r3, #32]
 801ac3c:	0018      	movs	r0, r3
 801ac3e:	f7ef f863 	bl	8009d08 <netif_set_link_down>
  }
  PPPDEBUG(LOG_DEBUG, ("sifdown[%d]: err_code=%d\n", pcb->netif->num, pcb->err_code));
  return 1;
 801ac42:	2301      	movs	r3, #1
}
 801ac44:	0018      	movs	r0, r3
 801ac46:	46bd      	mov	sp, r7
 801ac48:	b002      	add	sp, #8
 801ac4a:	bd80      	pop	{r7, pc}

0801ac4c <get_mask>:
 * Here we scan through the system's list of interfaces, looking for
 * any non-point-to-point interfaces which might appear to be on the same
 * network as `addr'.  If we find any, we OR in their netmask to the
 * user-specified netmask.
 */
u32_t get_mask(u32_t addr) {
 801ac4c:	b580      	push	{r7, lr}
 801ac4e:	b082      	sub	sp, #8
 801ac50:	af00      	add	r7, sp, #0
 801ac52:	6078      	str	r0, [r7, #4]
   */
  /* return mask; */
  return mask;
#endif /* 0 */
  LWIP_UNUSED_ARG(addr);
  return IPADDR_BROADCAST;
 801ac54:	2301      	movs	r3, #1
 801ac56:	425b      	negs	r3, r3
}
 801ac58:	0018      	movs	r0, r3
 801ac5a:	46bd      	mov	sp, r7
 801ac5c:	b002      	add	sp, #8
 801ac5e:	bd80      	pop	{r7, pc}

0801ac60 <netif_set_mtu>:
#endif /* DEMAND_SUPPORT */

/*
 * netif_set_mtu - set the MTU on the PPP network interface.
 */
void netif_set_mtu(ppp_pcb *pcb, int mtu) {
 801ac60:	b580      	push	{r7, lr}
 801ac62:	b082      	sub	sp, #8
 801ac64:	af00      	add	r7, sp, #0
 801ac66:	6078      	str	r0, [r7, #4]
 801ac68:	6039      	str	r1, [r7, #0]

  pcb->netif->mtu = mtu;
 801ac6a:	687b      	ldr	r3, [r7, #4]
 801ac6c:	6a1b      	ldr	r3, [r3, #32]
 801ac6e:	683a      	ldr	r2, [r7, #0]
 801ac70:	b292      	uxth	r2, r2
 801ac72:	851a      	strh	r2, [r3, #40]	; 0x28
  PPPDEBUG(LOG_INFO, ("netif_set_mtu[%d]: mtu=%d\n", pcb->netif->num, mtu));
}
 801ac74:	46c0      	nop			; (mov r8, r8)
 801ac76:	46bd      	mov	sp, r7
 801ac78:	b002      	add	sp, #8
 801ac7a:	bd80      	pop	{r7, pc}

0801ac7c <pppos_create>:
 *
 * Return 0 on success, an error code on failure.
 */
ppp_pcb *pppos_create(struct netif *pppif, pppos_output_cb_fn output_cb,
       ppp_link_status_cb_fn link_status_cb, void *ctx_cb)
{
 801ac7c:	b590      	push	{r4, r7, lr}
 801ac7e:	b089      	sub	sp, #36	; 0x24
 801ac80:	af02      	add	r7, sp, #8
 801ac82:	60f8      	str	r0, [r7, #12]
 801ac84:	60b9      	str	r1, [r7, #8]
 801ac86:	607a      	str	r2, [r7, #4]
 801ac88:	603b      	str	r3, [r7, #0]
  pppos_pcb *pppos;
  ppp_pcb *ppp;
  LWIP_ASSERT_CORE_LOCKED();

  pppos = (pppos_pcb *)LWIP_MEMPOOL_ALLOC(PPPOS_PCB);
 801ac8a:	4b19      	ldr	r3, [pc, #100]	; (801acf0 <pppos_create+0x74>)
 801ac8c:	0018      	movs	r0, r3
 801ac8e:	f7ee fcdf 	bl	8009650 <memp_malloc_pool>
 801ac92:	0003      	movs	r3, r0
 801ac94:	617b      	str	r3, [r7, #20]
  if (pppos == NULL) {
 801ac96:	697b      	ldr	r3, [r7, #20]
 801ac98:	2b00      	cmp	r3, #0
 801ac9a:	d101      	bne.n	801aca0 <pppos_create+0x24>
    return NULL;
 801ac9c:	2300      	movs	r3, #0
 801ac9e:	e022      	b.n	801ace6 <pppos_create+0x6a>
  }

  ppp = ppp_new(pppif, &pppos_callbacks, pppos, link_status_cb, ctx_cb);
 801aca0:	687c      	ldr	r4, [r7, #4]
 801aca2:	697a      	ldr	r2, [r7, #20]
 801aca4:	4913      	ldr	r1, [pc, #76]	; (801acf4 <pppos_create+0x78>)
 801aca6:	68f8      	ldr	r0, [r7, #12]
 801aca8:	683b      	ldr	r3, [r7, #0]
 801acaa:	9300      	str	r3, [sp, #0]
 801acac:	0023      	movs	r3, r4
 801acae:	f7ff fce3 	bl	801a678 <ppp_new>
 801acb2:	0003      	movs	r3, r0
 801acb4:	613b      	str	r3, [r7, #16]
  if (ppp == NULL) {
 801acb6:	693b      	ldr	r3, [r7, #16]
 801acb8:	2b00      	cmp	r3, #0
 801acba:	d107      	bne.n	801accc <pppos_create+0x50>
    LWIP_MEMPOOL_FREE(PPPOS_PCB, pppos);
 801acbc:	697a      	ldr	r2, [r7, #20]
 801acbe:	4b0c      	ldr	r3, [pc, #48]	; (801acf0 <pppos_create+0x74>)
 801acc0:	0011      	movs	r1, r2
 801acc2:	0018      	movs	r0, r3
 801acc4:	f7ee fd30 	bl	8009728 <memp_free_pool>
    return NULL;
 801acc8:	2300      	movs	r3, #0
 801acca:	e00c      	b.n	801ace6 <pppos_create+0x6a>
  }

  memset(pppos, 0, sizeof(pppos_pcb));
 801accc:	697b      	ldr	r3, [r7, #20]
 801acce:	2260      	movs	r2, #96	; 0x60
 801acd0:	2100      	movs	r1, #0
 801acd2:	0018      	movs	r0, r3
 801acd4:	f003 f97e 	bl	801dfd4 <memset>
  pppos->ppp = ppp;
 801acd8:	697b      	ldr	r3, [r7, #20]
 801acda:	693a      	ldr	r2, [r7, #16]
 801acdc:	601a      	str	r2, [r3, #0]
  pppos->output_cb = output_cb;
 801acde:	697b      	ldr	r3, [r7, #20]
 801ace0:	68ba      	ldr	r2, [r7, #8]
 801ace2:	605a      	str	r2, [r3, #4]
  return ppp;
 801ace4:	693b      	ldr	r3, [r7, #16]
}
 801ace6:	0018      	movs	r0, r3
 801ace8:	46bd      	mov	sp, r7
 801acea:	b007      	add	sp, #28
 801acec:	bd90      	pop	{r4, r7, pc}
 801acee:	46c0      	nop			; (mov r8, r8)
 801acf0:	08023d04 	.word	0x08023d04
 801acf4:	08023d14 	.word	0x08023d14

0801acf8 <pppos_write>:

/* Called by PPP core */
static err_t
pppos_write(ppp_pcb *ppp, void *ctx, struct pbuf *p)
{
 801acf8:	b5f0      	push	{r4, r5, r6, r7, lr}
 801acfa:	b08d      	sub	sp, #52	; 0x34
 801acfc:	af02      	add	r7, sp, #8
 801acfe:	60f8      	str	r0, [r7, #12]
 801ad00:	60b9      	str	r1, [r7, #8]
 801ad02:	607a      	str	r2, [r7, #4]
  pppos_pcb *pppos = (pppos_pcb *)ctx;
 801ad04:	68bb      	ldr	r3, [r7, #8]
 801ad06:	61fb      	str	r3, [r7, #28]
  LWIP_UNUSED_ARG(ppp);

  /* Grab an output buffer. Using PBUF_POOL here for tx is ok since the pbuf
     gets freed by 'pppos_output_last' before this function returns and thus
     cannot starve rx. */
  nb = pbuf_alloc(PBUF_RAW, 0, PBUF_POOL);
 801ad08:	23c1      	movs	r3, #193	; 0xc1
 801ad0a:	005b      	lsls	r3, r3, #1
 801ad0c:	001a      	movs	r2, r3
 801ad0e:	2100      	movs	r1, #0
 801ad10:	2000      	movs	r0, #0
 801ad12:	f7ef f8ad 	bl	8009e70 <pbuf_alloc>
 801ad16:	0003      	movs	r3, r0
 801ad18:	61bb      	str	r3, [r7, #24]
  if (nb == NULL) {
 801ad1a:	69bb      	ldr	r3, [r7, #24]
 801ad1c:	2b00      	cmp	r3, #0
 801ad1e:	d106      	bne.n	801ad2e <pppos_write+0x36>
    PPPDEBUG(LOG_WARNING, ("pppos_write[%d]: alloc fail\n", ppp->netif->num));
    LINK_STATS_INC(link.memerr);
    LINK_STATS_INC(link.drop);
    MIB2_STATS_NETIF_INC(ppp->netif, ifoutdiscards);
    pbuf_free(p);
 801ad20:	687b      	ldr	r3, [r7, #4]
 801ad22:	0018      	movs	r0, r3
 801ad24:	f7ef fbda 	bl	800a4dc <pbuf_free>
    return ERR_MEM;
 801ad28:	2301      	movs	r3, #1
 801ad2a:	425b      	negs	r3, r3
 801ad2c:	e05f      	b.n	801adee <pppos_write+0xf6>
  }

  /* Set nb->tot_len to actual payload length */
  nb->tot_len = p->len;
 801ad2e:	687b      	ldr	r3, [r7, #4]
 801ad30:	895a      	ldrh	r2, [r3, #10]
 801ad32:	69bb      	ldr	r3, [r7, #24]
 801ad34:	811a      	strh	r2, [r3, #8]

  /* If the link has been idle, we'll send a fresh flag character to
   * flush any noise. */
  err = ERR_OK;
 801ad36:	2421      	movs	r4, #33	; 0x21
 801ad38:	193b      	adds	r3, r7, r4
 801ad3a:	2200      	movs	r2, #0
 801ad3c:	701a      	strb	r2, [r3, #0]
  if ((sys_now() - pppos->last_xmit) >= PPP_MAXIDLEFLAG) {
 801ad3e:	f003 f8e1 	bl	801df04 <sys_now>
 801ad42:	0002      	movs	r2, r0
 801ad44:	69fb      	ldr	r3, [r7, #28]
 801ad46:	689b      	ldr	r3, [r3, #8]
 801ad48:	1ad3      	subs	r3, r2, r3
 801ad4a:	2b63      	cmp	r3, #99	; 0x63
 801ad4c:	d90f      	bls.n	801ad6e <pppos_write+0x76>
    err = pppos_output_append(pppos, err,  nb, PPP_FLAG, 0, NULL);
 801ad4e:	0023      	movs	r3, r4
 801ad50:	18fc      	adds	r4, r7, r3
 801ad52:	69ba      	ldr	r2, [r7, #24]
 801ad54:	18fb      	adds	r3, r7, r3
 801ad56:	2100      	movs	r1, #0
 801ad58:	5659      	ldrsb	r1, [r3, r1]
 801ad5a:	69f8      	ldr	r0, [r7, #28]
 801ad5c:	2300      	movs	r3, #0
 801ad5e:	9301      	str	r3, [sp, #4]
 801ad60:	2300      	movs	r3, #0
 801ad62:	9300      	str	r3, [sp, #0]
 801ad64:	237e      	movs	r3, #126	; 0x7e
 801ad66:	f000 fbe3 	bl	801b530 <pppos_output_append>
 801ad6a:	0003      	movs	r3, r0
 801ad6c:	7023      	strb	r3, [r4, #0]
  }

  /* Load output buffer. */
  fcs_out = PPP_INITFCS;
 801ad6e:	2316      	movs	r3, #22
 801ad70:	18fb      	adds	r3, r7, r3
 801ad72:	2201      	movs	r2, #1
 801ad74:	4252      	negs	r2, r2
 801ad76:	801a      	strh	r2, [r3, #0]
  s = (u8_t*)p->payload;
 801ad78:	687b      	ldr	r3, [r7, #4]
 801ad7a:	685b      	ldr	r3, [r3, #4]
 801ad7c:	627b      	str	r3, [r7, #36]	; 0x24
  n = p->len;
 801ad7e:	2322      	movs	r3, #34	; 0x22
 801ad80:	18fb      	adds	r3, r7, r3
 801ad82:	687a      	ldr	r2, [r7, #4]
 801ad84:	8952      	ldrh	r2, [r2, #10]
 801ad86:	801a      	strh	r2, [r3, #0]
  while (n-- > 0) {
 801ad88:	e014      	b.n	801adb4 <pppos_write+0xbc>
    err = pppos_output_append(pppos, err,  nb, *s++, 1, &fcs_out);
 801ad8a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ad8c:	1c5a      	adds	r2, r3, #1
 801ad8e:	627a      	str	r2, [r7, #36]	; 0x24
 801ad90:	781d      	ldrb	r5, [r3, #0]
 801ad92:	2321      	movs	r3, #33	; 0x21
 801ad94:	18fc      	adds	r4, r7, r3
 801ad96:	69ba      	ldr	r2, [r7, #24]
 801ad98:	18fb      	adds	r3, r7, r3
 801ad9a:	2100      	movs	r1, #0
 801ad9c:	5659      	ldrsb	r1, [r3, r1]
 801ad9e:	69f8      	ldr	r0, [r7, #28]
 801ada0:	2316      	movs	r3, #22
 801ada2:	18fb      	adds	r3, r7, r3
 801ada4:	9301      	str	r3, [sp, #4]
 801ada6:	2301      	movs	r3, #1
 801ada8:	9300      	str	r3, [sp, #0]
 801adaa:	002b      	movs	r3, r5
 801adac:	f000 fbc0 	bl	801b530 <pppos_output_append>
 801adb0:	0003      	movs	r3, r0
 801adb2:	7023      	strb	r3, [r4, #0]
  while (n-- > 0) {
 801adb4:	2222      	movs	r2, #34	; 0x22
 801adb6:	18bb      	adds	r3, r7, r2
 801adb8:	881b      	ldrh	r3, [r3, #0]
 801adba:	18ba      	adds	r2, r7, r2
 801adbc:	1e59      	subs	r1, r3, #1
 801adbe:	8011      	strh	r1, [r2, #0]
 801adc0:	2b00      	cmp	r3, #0
 801adc2:	d1e2      	bne.n	801ad8a <pppos_write+0x92>
  }

  err = pppos_output_last(pppos, err, nb, &fcs_out);
 801adc4:	2621      	movs	r6, #33	; 0x21
 801adc6:	19bc      	adds	r4, r7, r6
 801adc8:	2316      	movs	r3, #22
 801adca:	18fd      	adds	r5, r7, r3
 801adcc:	69ba      	ldr	r2, [r7, #24]
 801adce:	19bb      	adds	r3, r7, r6
 801add0:	2100      	movs	r1, #0
 801add2:	5659      	ldrsb	r1, [r3, r1]
 801add4:	69f8      	ldr	r0, [r7, #28]
 801add6:	002b      	movs	r3, r5
 801add8:	f000 fc44 	bl	801b664 <pppos_output_last>
 801addc:	0003      	movs	r3, r0
 801adde:	7023      	strb	r3, [r4, #0]
  if (err == ERR_OK) {
    PPPDEBUG(LOG_INFO, ("pppos_write[%d]: len=%d\n", ppp->netif->num, p->len));
  } else {
    PPPDEBUG(LOG_WARNING, ("pppos_write[%d]: output failed len=%d\n", ppp->netif->num, p->len));
  }
  pbuf_free(p);
 801ade0:	687b      	ldr	r3, [r7, #4]
 801ade2:	0018      	movs	r0, r3
 801ade4:	f7ef fb7a 	bl	800a4dc <pbuf_free>
  return err;
 801ade8:	19bb      	adds	r3, r7, r6
 801adea:	781b      	ldrb	r3, [r3, #0]
 801adec:	b25b      	sxtb	r3, r3
}
 801adee:	0018      	movs	r0, r3
 801adf0:	46bd      	mov	sp, r7
 801adf2:	b00b      	add	sp, #44	; 0x2c
 801adf4:	bdf0      	pop	{r4, r5, r6, r7, pc}

0801adf6 <pppos_netif_output>:

/* Called by PPP core */
static err_t
pppos_netif_output(ppp_pcb *ppp, void *ctx, struct pbuf *pb, u16_t protocol)
{
 801adf6:	b5f0      	push	{r4, r5, r6, r7, lr}
 801adf8:	b08d      	sub	sp, #52	; 0x34
 801adfa:	af02      	add	r7, sp, #8
 801adfc:	60f8      	str	r0, [r7, #12]
 801adfe:	60b9      	str	r1, [r7, #8]
 801ae00:	607a      	str	r2, [r7, #4]
 801ae02:	001a      	movs	r2, r3
 801ae04:	1cbb      	adds	r3, r7, #2
 801ae06:	801a      	strh	r2, [r3, #0]
  pppos_pcb *pppos = (pppos_pcb *)ctx;
 801ae08:	68bb      	ldr	r3, [r7, #8]
 801ae0a:	61bb      	str	r3, [r7, #24]
  LWIP_UNUSED_ARG(ppp);

  /* Grab an output buffer. Using PBUF_POOL here for tx is ok since the pbuf
     gets freed by 'pppos_output_last' before this function returns and thus
     cannot starve rx. */
  nb = pbuf_alloc(PBUF_RAW, 0, PBUF_POOL);
 801ae0c:	23c1      	movs	r3, #193	; 0xc1
 801ae0e:	005b      	lsls	r3, r3, #1
 801ae10:	001a      	movs	r2, r3
 801ae12:	2100      	movs	r1, #0
 801ae14:	2000      	movs	r0, #0
 801ae16:	f7ef f82b 	bl	8009e70 <pbuf_alloc>
 801ae1a:	0003      	movs	r3, r0
 801ae1c:	617b      	str	r3, [r7, #20]
  if (nb == NULL) {
 801ae1e:	697b      	ldr	r3, [r7, #20]
 801ae20:	2b00      	cmp	r3, #0
 801ae22:	d102      	bne.n	801ae2a <pppos_netif_output+0x34>
    PPPDEBUG(LOG_WARNING, ("pppos_netif_output[%d]: alloc fail\n", ppp->netif->num));
    LINK_STATS_INC(link.memerr);
    LINK_STATS_INC(link.drop);
    MIB2_STATS_NETIF_INC(ppp->netif, ifoutdiscards);
    return ERR_MEM;
 801ae24:	2301      	movs	r3, #1
 801ae26:	425b      	negs	r3, r3
 801ae28:	e0c1      	b.n	801afae <pppos_netif_output+0x1b8>
  }

  /* Set nb->tot_len to actual payload length */
  nb->tot_len = pb->tot_len;
 801ae2a:	687b      	ldr	r3, [r7, #4]
 801ae2c:	891a      	ldrh	r2, [r3, #8]
 801ae2e:	697b      	ldr	r3, [r7, #20]
 801ae30:	811a      	strh	r2, [r3, #8]

  /* If the link has been idle, we'll send a fresh flag character to
   * flush any noise. */
  err = ERR_OK;
 801ae32:	2423      	movs	r4, #35	; 0x23
 801ae34:	193b      	adds	r3, r7, r4
 801ae36:	2200      	movs	r2, #0
 801ae38:	701a      	strb	r2, [r3, #0]
  if ((sys_now() - pppos->last_xmit) >= PPP_MAXIDLEFLAG) {
 801ae3a:	f003 f863 	bl	801df04 <sys_now>
 801ae3e:	0002      	movs	r2, r0
 801ae40:	69bb      	ldr	r3, [r7, #24]
 801ae42:	689b      	ldr	r3, [r3, #8]
 801ae44:	1ad3      	subs	r3, r2, r3
 801ae46:	2b63      	cmp	r3, #99	; 0x63
 801ae48:	d90f      	bls.n	801ae6a <pppos_netif_output+0x74>
    err = pppos_output_append(pppos, err,  nb, PPP_FLAG, 0, NULL);
 801ae4a:	0023      	movs	r3, r4
 801ae4c:	18fc      	adds	r4, r7, r3
 801ae4e:	697a      	ldr	r2, [r7, #20]
 801ae50:	18fb      	adds	r3, r7, r3
 801ae52:	2100      	movs	r1, #0
 801ae54:	5659      	ldrsb	r1, [r3, r1]
 801ae56:	69b8      	ldr	r0, [r7, #24]
 801ae58:	2300      	movs	r3, #0
 801ae5a:	9301      	str	r3, [sp, #4]
 801ae5c:	2300      	movs	r3, #0
 801ae5e:	9300      	str	r3, [sp, #0]
 801ae60:	237e      	movs	r3, #126	; 0x7e
 801ae62:	f000 fb65 	bl	801b530 <pppos_output_append>
 801ae66:	0003      	movs	r3, r0
 801ae68:	7023      	strb	r3, [r4, #0]
  }

  fcs_out = PPP_INITFCS;
 801ae6a:	2612      	movs	r6, #18
 801ae6c:	19bb      	adds	r3, r7, r6
 801ae6e:	2201      	movs	r2, #1
 801ae70:	4252      	negs	r2, r2
 801ae72:	801a      	strh	r2, [r3, #0]
  if (!pppos->accomp) {
 801ae74:	69bb      	ldr	r3, [r7, #24]
 801ae76:	222c      	movs	r2, #44	; 0x2c
 801ae78:	5c9b      	ldrb	r3, [r3, r2]
 801ae7a:	2204      	movs	r2, #4
 801ae7c:	4013      	ands	r3, r2
 801ae7e:	b2db      	uxtb	r3, r3
 801ae80:	2b00      	cmp	r3, #0
 801ae82:	d11e      	bne.n	801aec2 <pppos_netif_output+0xcc>
    err = pppos_output_append(pppos, err,  nb, PPP_ALLSTATIONS, 1, &fcs_out);
 801ae84:	2523      	movs	r5, #35	; 0x23
 801ae86:	197c      	adds	r4, r7, r5
 801ae88:	697a      	ldr	r2, [r7, #20]
 801ae8a:	197b      	adds	r3, r7, r5
 801ae8c:	2100      	movs	r1, #0
 801ae8e:	5659      	ldrsb	r1, [r3, r1]
 801ae90:	69b8      	ldr	r0, [r7, #24]
 801ae92:	19bb      	adds	r3, r7, r6
 801ae94:	9301      	str	r3, [sp, #4]
 801ae96:	2301      	movs	r3, #1
 801ae98:	9300      	str	r3, [sp, #0]
 801ae9a:	23ff      	movs	r3, #255	; 0xff
 801ae9c:	f000 fb48 	bl	801b530 <pppos_output_append>
 801aea0:	0003      	movs	r3, r0
 801aea2:	7023      	strb	r3, [r4, #0]
    err = pppos_output_append(pppos, err,  nb, PPP_UI, 1, &fcs_out);
 801aea4:	197c      	adds	r4, r7, r5
 801aea6:	697a      	ldr	r2, [r7, #20]
 801aea8:	197b      	adds	r3, r7, r5
 801aeaa:	2100      	movs	r1, #0
 801aeac:	5659      	ldrsb	r1, [r3, r1]
 801aeae:	69b8      	ldr	r0, [r7, #24]
 801aeb0:	19bb      	adds	r3, r7, r6
 801aeb2:	9301      	str	r3, [sp, #4]
 801aeb4:	2301      	movs	r3, #1
 801aeb6:	9300      	str	r3, [sp, #0]
 801aeb8:	2303      	movs	r3, #3
 801aeba:	f000 fb39 	bl	801b530 <pppos_output_append>
 801aebe:	0003      	movs	r3, r0
 801aec0:	7023      	strb	r3, [r4, #0]
  }
  if (!pppos->pcomp || protocol > 0xFF) {
 801aec2:	69bb      	ldr	r3, [r7, #24]
 801aec4:	222c      	movs	r2, #44	; 0x2c
 801aec6:	5c9b      	ldrb	r3, [r3, r2]
 801aec8:	2202      	movs	r2, #2
 801aeca:	4013      	ands	r3, r2
 801aecc:	b2db      	uxtb	r3, r3
 801aece:	2b00      	cmp	r3, #0
 801aed0:	d003      	beq.n	801aeda <pppos_netif_output+0xe4>
 801aed2:	1cbb      	adds	r3, r7, #2
 801aed4:	881b      	ldrh	r3, [r3, #0]
 801aed6:	2bff      	cmp	r3, #255	; 0xff
 801aed8:	d915      	bls.n	801af06 <pppos_netif_output+0x110>
    err = pppos_output_append(pppos, err,  nb, (protocol >> 8) & 0xFF, 1, &fcs_out);
 801aeda:	1cbb      	adds	r3, r7, #2
 801aedc:	881b      	ldrh	r3, [r3, #0]
 801aede:	0a1b      	lsrs	r3, r3, #8
 801aee0:	b29b      	uxth	r3, r3
 801aee2:	b2dd      	uxtb	r5, r3
 801aee4:	2323      	movs	r3, #35	; 0x23
 801aee6:	18fc      	adds	r4, r7, r3
 801aee8:	697a      	ldr	r2, [r7, #20]
 801aeea:	18fb      	adds	r3, r7, r3
 801aeec:	2100      	movs	r1, #0
 801aeee:	5659      	ldrsb	r1, [r3, r1]
 801aef0:	69b8      	ldr	r0, [r7, #24]
 801aef2:	2312      	movs	r3, #18
 801aef4:	18fb      	adds	r3, r7, r3
 801aef6:	9301      	str	r3, [sp, #4]
 801aef8:	2301      	movs	r3, #1
 801aefa:	9300      	str	r3, [sp, #0]
 801aefc:	002b      	movs	r3, r5
 801aefe:	f000 fb17 	bl	801b530 <pppos_output_append>
 801af02:	0003      	movs	r3, r0
 801af04:	7023      	strb	r3, [r4, #0]
  }
  err = pppos_output_append(pppos, err,  nb, protocol & 0xFF, 1, &fcs_out);
 801af06:	1cbb      	adds	r3, r7, #2
 801af08:	881b      	ldrh	r3, [r3, #0]
 801af0a:	b2dd      	uxtb	r5, r3
 801af0c:	2323      	movs	r3, #35	; 0x23
 801af0e:	18fc      	adds	r4, r7, r3
 801af10:	697a      	ldr	r2, [r7, #20]
 801af12:	18fb      	adds	r3, r7, r3
 801af14:	2100      	movs	r1, #0
 801af16:	5659      	ldrsb	r1, [r3, r1]
 801af18:	69b8      	ldr	r0, [r7, #24]
 801af1a:	2312      	movs	r3, #18
 801af1c:	18fb      	adds	r3, r7, r3
 801af1e:	9301      	str	r3, [sp, #4]
 801af20:	2301      	movs	r3, #1
 801af22:	9300      	str	r3, [sp, #0]
 801af24:	002b      	movs	r3, r5
 801af26:	f000 fb03 	bl	801b530 <pppos_output_append>
 801af2a:	0003      	movs	r3, r0
 801af2c:	7023      	strb	r3, [r4, #0]

  /* Load packet. */
  for(p = pb; p; p = p->next) {
 801af2e:	687b      	ldr	r3, [r7, #4]
 801af30:	627b      	str	r3, [r7, #36]	; 0x24
 801af32:	e028      	b.n	801af86 <pppos_netif_output+0x190>
    u16_t n = p->len;
 801af34:	2320      	movs	r3, #32
 801af36:	18fb      	adds	r3, r7, r3
 801af38:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801af3a:	8952      	ldrh	r2, [r2, #10]
 801af3c:	801a      	strh	r2, [r3, #0]
    u8_t *s = (u8_t*)p->payload;
 801af3e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801af40:	685b      	ldr	r3, [r3, #4]
 801af42:	61fb      	str	r3, [r7, #28]

    while (n-- > 0) {
 801af44:	e014      	b.n	801af70 <pppos_netif_output+0x17a>
      err = pppos_output_append(pppos, err,  nb, *s++, 1, &fcs_out);
 801af46:	69fb      	ldr	r3, [r7, #28]
 801af48:	1c5a      	adds	r2, r3, #1
 801af4a:	61fa      	str	r2, [r7, #28]
 801af4c:	781d      	ldrb	r5, [r3, #0]
 801af4e:	2323      	movs	r3, #35	; 0x23
 801af50:	18fc      	adds	r4, r7, r3
 801af52:	697a      	ldr	r2, [r7, #20]
 801af54:	18fb      	adds	r3, r7, r3
 801af56:	2100      	movs	r1, #0
 801af58:	5659      	ldrsb	r1, [r3, r1]
 801af5a:	69b8      	ldr	r0, [r7, #24]
 801af5c:	2312      	movs	r3, #18
 801af5e:	18fb      	adds	r3, r7, r3
 801af60:	9301      	str	r3, [sp, #4]
 801af62:	2301      	movs	r3, #1
 801af64:	9300      	str	r3, [sp, #0]
 801af66:	002b      	movs	r3, r5
 801af68:	f000 fae2 	bl	801b530 <pppos_output_append>
 801af6c:	0003      	movs	r3, r0
 801af6e:	7023      	strb	r3, [r4, #0]
    while (n-- > 0) {
 801af70:	2220      	movs	r2, #32
 801af72:	18bb      	adds	r3, r7, r2
 801af74:	881b      	ldrh	r3, [r3, #0]
 801af76:	18ba      	adds	r2, r7, r2
 801af78:	1e59      	subs	r1, r3, #1
 801af7a:	8011      	strh	r1, [r2, #0]
 801af7c:	2b00      	cmp	r3, #0
 801af7e:	d1e2      	bne.n	801af46 <pppos_netif_output+0x150>
  for(p = pb; p; p = p->next) {
 801af80:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801af82:	681b      	ldr	r3, [r3, #0]
 801af84:	627b      	str	r3, [r7, #36]	; 0x24
 801af86:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801af88:	2b00      	cmp	r3, #0
 801af8a:	d1d3      	bne.n	801af34 <pppos_netif_output+0x13e>
    }
  }

  err = pppos_output_last(pppos, err, nb, &fcs_out);
 801af8c:	2623      	movs	r6, #35	; 0x23
 801af8e:	19bc      	adds	r4, r7, r6
 801af90:	2312      	movs	r3, #18
 801af92:	18fd      	adds	r5, r7, r3
 801af94:	697a      	ldr	r2, [r7, #20]
 801af96:	19bb      	adds	r3, r7, r6
 801af98:	2100      	movs	r1, #0
 801af9a:	5659      	ldrsb	r1, [r3, r1]
 801af9c:	69b8      	ldr	r0, [r7, #24]
 801af9e:	002b      	movs	r3, r5
 801afa0:	f000 fb60 	bl	801b664 <pppos_output_last>
 801afa4:	0003      	movs	r3, r0
 801afa6:	7023      	strb	r3, [r4, #0]
  if (err == ERR_OK) {
    PPPDEBUG(LOG_INFO, ("pppos_netif_output[%d]: proto=0x%"X16_F", len = %d\n", ppp->netif->num, protocol, pb->tot_len));
  } else {
    PPPDEBUG(LOG_WARNING, ("pppos_netif_output[%d]: output failed proto=0x%"X16_F", len = %d\n", ppp->netif->num, protocol, pb->tot_len));
  }
  return err;
 801afa8:	19bb      	adds	r3, r7, r6
 801afaa:	781b      	ldrb	r3, [r3, #0]
 801afac:	b25b      	sxtb	r3, r3
}
 801afae:	0018      	movs	r0, r3
 801afb0:	46bd      	mov	sp, r7
 801afb2:	b00b      	add	sp, #44	; 0x2c
 801afb4:	bdf0      	pop	{r4, r5, r6, r7, pc}

0801afb6 <pppos_connect>:

static void
pppos_connect(ppp_pcb *ppp, void *ctx)
{
 801afb6:	b580      	push	{r7, lr}
 801afb8:	b084      	sub	sp, #16
 801afba:	af00      	add	r7, sp, #0
 801afbc:	6078      	str	r0, [r7, #4]
 801afbe:	6039      	str	r1, [r7, #0]
  pppos_pcb *pppos = (pppos_pcb *)ctx;
 801afc0:	683b      	ldr	r3, [r7, #0]
 801afc2:	60fb      	str	r3, [r7, #12]
  /* input pbuf left over from last session? */
  pppos_input_free_current_packet(pppos);
#endif /* PPP_INPROC_IRQ_SAFE */

  /* reset PPPoS control block to its initial state */
  memset(&pppos->last_xmit, 0, sizeof(pppos_pcb) - offsetof(pppos_pcb, last_xmit));
 801afc4:	68fb      	ldr	r3, [r7, #12]
 801afc6:	3308      	adds	r3, #8
 801afc8:	2258      	movs	r2, #88	; 0x58
 801afca:	2100      	movs	r1, #0
 801afcc:	0018      	movs	r0, r3
 801afce:	f003 f801 	bl	801dfd4 <memset>

  /*
   * Default the in and out accm so that escape and flag characters
   * are always escaped.
   */
  pppos->in_accm[15] = 0x60; /* no need to protect since RX is not running */
 801afd2:	68fb      	ldr	r3, [r7, #12]
 801afd4:	223c      	movs	r2, #60	; 0x3c
 801afd6:	2160      	movs	r1, #96	; 0x60
 801afd8:	5499      	strb	r1, [r3, r2]
  pppos->out_accm[15] = 0x60;
 801afda:	68fb      	ldr	r3, [r7, #12]
 801afdc:	2260      	movs	r2, #96	; 0x60
 801afde:	76da      	strb	r2, [r3, #27]
  PPPOS_PROTECT(lev);
  pppos->open = 1;
 801afe0:	68fb      	ldr	r3, [r7, #12]
 801afe2:	222c      	movs	r2, #44	; 0x2c
 801afe4:	5c99      	ldrb	r1, [r3, r2]
 801afe6:	2001      	movs	r0, #1
 801afe8:	4301      	orrs	r1, r0
 801afea:	5499      	strb	r1, [r3, r2]

  /*
   * Start the connection and handle incoming events (packet or timeout).
   */
  PPPDEBUG(LOG_INFO, ("pppos_connect: unit %d: connecting\n", ppp->netif->num));
  ppp_start(ppp); /* notify upper layers */
 801afec:	687b      	ldr	r3, [r7, #4]
 801afee:	0018      	movs	r0, r3
 801aff0:	f7ff fbc4 	bl	801a77c <ppp_start>
}
 801aff4:	46c0      	nop			; (mov r8, r8)
 801aff6:	46bd      	mov	sp, r7
 801aff8:	b004      	add	sp, #16
 801affa:	bd80      	pop	{r7, pc}

0801affc <pppos_disconnect>:
}
#endif /* PPP_SERVER */

static void
pppos_disconnect(ppp_pcb *ppp, void *ctx)
{
 801affc:	b580      	push	{r7, lr}
 801affe:	b084      	sub	sp, #16
 801b000:	af00      	add	r7, sp, #0
 801b002:	6078      	str	r0, [r7, #4]
 801b004:	6039      	str	r1, [r7, #0]
  pppos_pcb *pppos = (pppos_pcb *)ctx;
 801b006:	683b      	ldr	r3, [r7, #0]
 801b008:	60fb      	str	r3, [r7, #12]
  PPPOS_DECL_PROTECT(lev);

  PPPOS_PROTECT(lev);
  pppos->open = 0;
 801b00a:	68fb      	ldr	r3, [r7, #12]
 801b00c:	222c      	movs	r2, #44	; 0x2c
 801b00e:	5c99      	ldrb	r1, [r3, r2]
 801b010:	2001      	movs	r0, #1
 801b012:	4381      	bics	r1, r0
 801b014:	5499      	strb	r1, [r3, r2]
   * pppos_input_free_current_packet() here because
   * rx IRQ might still call pppos_input().
   */
#if !PPP_INPROC_IRQ_SAFE
  /* input pbuf left ? */
  pppos_input_free_current_packet(pppos);
 801b016:	68fb      	ldr	r3, [r7, #12]
 801b018:	0018      	movs	r0, r3
 801b01a:	f000 fa50 	bl	801b4be <pppos_input_free_current_packet>
#endif /* !PPP_INPROC_IRQ_SAFE */

  ppp_link_end(ppp); /* notify upper layers */
 801b01e:	687b      	ldr	r3, [r7, #4]
 801b020:	0018      	movs	r0, r3
 801b022:	f7ff fbc5 	bl	801a7b0 <ppp_link_end>
}
 801b026:	46c0      	nop			; (mov r8, r8)
 801b028:	46bd      	mov	sp, r7
 801b02a:	b004      	add	sp, #16
 801b02c:	bd80      	pop	{r7, pc}
	...

0801b030 <pppos_destroy>:

static err_t
pppos_destroy(ppp_pcb *ppp, void *ctx)
{
 801b030:	b580      	push	{r7, lr}
 801b032:	b084      	sub	sp, #16
 801b034:	af00      	add	r7, sp, #0
 801b036:	6078      	str	r0, [r7, #4]
 801b038:	6039      	str	r1, [r7, #0]
  pppos_pcb *pppos = (pppos_pcb *)ctx;
 801b03a:	683b      	ldr	r3, [r7, #0]
 801b03c:	60fb      	str	r3, [r7, #12]
#if PPP_INPROC_IRQ_SAFE
  /* input pbuf left ? */
  pppos_input_free_current_packet(pppos);
#endif /* PPP_INPROC_IRQ_SAFE */

  LWIP_MEMPOOL_FREE(PPPOS_PCB, pppos);
 801b03e:	68fa      	ldr	r2, [r7, #12]
 801b040:	4b04      	ldr	r3, [pc, #16]	; (801b054 <pppos_destroy+0x24>)
 801b042:	0011      	movs	r1, r2
 801b044:	0018      	movs	r0, r3
 801b046:	f7ee fb6f 	bl	8009728 <memp_free_pool>
  return ERR_OK;
 801b04a:	2300      	movs	r3, #0
}
 801b04c:	0018      	movs	r0, r3
 801b04e:	46bd      	mov	sp, r7
 801b050:	b004      	add	sp, #16
 801b052:	bd80      	pop	{r7, pc}
 801b054:	08023d04 	.word	0x08023d04

0801b058 <pppos_input>:
 * @param s received data
 * @param l length of received data
 */
void
pppos_input(ppp_pcb *ppp, u8_t *s, int l)
{
 801b058:	b580      	push	{r7, lr}
 801b05a:	b08a      	sub	sp, #40	; 0x28
 801b05c:	af00      	add	r7, sp, #0
 801b05e:	60f8      	str	r0, [r7, #12]
 801b060:	60b9      	str	r1, [r7, #8]
 801b062:	607a      	str	r2, [r7, #4]
  pppos_pcb *pppos = (pppos_pcb *)ppp->link_ctx_cb;
 801b064:	68fb      	ldr	r3, [r7, #12]
 801b066:	691b      	ldr	r3, [r3, #16]
 801b068:	623b      	str	r3, [r7, #32]
#if !PPP_INPROC_IRQ_SAFE
  LWIP_ASSERT_CORE_LOCKED();
#endif

  PPPDEBUG(LOG_DEBUG, ("pppos_input[%d]: got %d bytes\n", ppp->netif->num, l));
  while (l-- > 0) {
 801b06a:	e1ae      	b.n	801b3ca <pppos_input+0x372>
    cur_char = *s++;
 801b06c:	68bb      	ldr	r3, [r7, #8]
 801b06e:	1c5a      	adds	r2, r3, #1
 801b070:	60ba      	str	r2, [r7, #8]
 801b072:	2027      	movs	r0, #39	; 0x27
 801b074:	183a      	adds	r2, r7, r0
 801b076:	781b      	ldrb	r3, [r3, #0]
 801b078:	7013      	strb	r3, [r2, #0]
    /* ppp_input can disconnect the interface, we need to abort to prevent a memory
     * leak if there are remaining bytes because pppos_connect and pppos_listen
     * functions expect input buffer to be free. Furthermore there are no real
     * reason to continue reading bytes if we are disconnected.
     */
    if (!pppos->open) {
 801b07a:	6a3b      	ldr	r3, [r7, #32]
 801b07c:	222c      	movs	r2, #44	; 0x2c
 801b07e:	5c9b      	ldrb	r3, [r3, r2]
 801b080:	2201      	movs	r2, #1
 801b082:	4013      	ands	r3, r2
 801b084:	b2db      	uxtb	r3, r3
 801b086:	2b00      	cmp	r3, #0
 801b088:	d100      	bne.n	801b08c <pppos_input+0x34>
 801b08a:	e1a5      	b.n	801b3d8 <pppos_input+0x380>
      PPPOS_UNPROTECT(lev);
      return;
    }
    escaped = ESCAPE_P(pppos->in_accm, cur_char);
 801b08c:	183b      	adds	r3, r7, r0
 801b08e:	781b      	ldrb	r3, [r3, #0]
 801b090:	08db      	lsrs	r3, r3, #3
 801b092:	b2db      	uxtb	r3, r3
 801b094:	0019      	movs	r1, r3
 801b096:	6a3b      	ldr	r3, [r7, #32]
 801b098:	222d      	movs	r2, #45	; 0x2d
 801b09a:	185b      	adds	r3, r3, r1
 801b09c:	189b      	adds	r3, r3, r2
 801b09e:	781b      	ldrb	r3, [r3, #0]
 801b0a0:	b25b      	sxtb	r3, r3
 801b0a2:	183a      	adds	r2, r7, r0
 801b0a4:	7812      	ldrb	r2, [r2, #0]
 801b0a6:	2107      	movs	r1, #7
 801b0a8:	400a      	ands	r2, r1
 801b0aa:	2101      	movs	r1, #1
 801b0ac:	4091      	lsls	r1, r2
 801b0ae:	000a      	movs	r2, r1
 801b0b0:	b252      	sxtb	r2, r2
 801b0b2:	4013      	ands	r3, r2
 801b0b4:	b25a      	sxtb	r2, r3
 801b0b6:	211f      	movs	r1, #31
 801b0b8:	187b      	adds	r3, r7, r1
 801b0ba:	701a      	strb	r2, [r3, #0]
    PPPOS_UNPROTECT(lev);
    /* Handle special characters. */
    if (escaped) {
 801b0bc:	187b      	adds	r3, r7, r1
 801b0be:	781b      	ldrb	r3, [r3, #0]
 801b0c0:	2b00      	cmp	r3, #0
 801b0c2:	d100      	bne.n	801b0c6 <pppos_input+0x6e>
 801b0c4:	e086      	b.n	801b1d4 <pppos_input+0x17c>
      /* Check for escape sequences. */
      /* XXX Note that this does not handle an escaped 0x5d character which
       * would appear as an escape character.  Since this is an ASCII ']'
       * and there is no reason that I know of to escape it, I won't complicate
       * the code to handle this case. GLL */
      if (cur_char == PPP_ESCAPE) {
 801b0c6:	183b      	adds	r3, r7, r0
 801b0c8:	781b      	ldrb	r3, [r3, #0]
 801b0ca:	2b7d      	cmp	r3, #125	; 0x7d
 801b0cc:	d104      	bne.n	801b0d8 <pppos_input+0x80>
        pppos->in_escaped = 1;
 801b0ce:	6a3b      	ldr	r3, [r7, #32]
 801b0d0:	225d      	movs	r2, #93	; 0x5d
 801b0d2:	2101      	movs	r1, #1
 801b0d4:	5499      	strb	r1, [r3, r2]
 801b0d6:	e178      	b.n	801b3ca <pppos_input+0x372>
      /* Check for the flag character. */
      } else if (cur_char == PPP_FLAG) {
 801b0d8:	2327      	movs	r3, #39	; 0x27
 801b0da:	18fb      	adds	r3, r7, r3
 801b0dc:	781b      	ldrb	r3, [r3, #0]
 801b0de:	2b7e      	cmp	r3, #126	; 0x7e
 801b0e0:	d000      	beq.n	801b0e4 <pppos_input+0x8c>
 801b0e2:	e172      	b.n	801b3ca <pppos_input+0x372>
        /* If this is just an extra flag character, ignore it. */
        if (pppos->in_state <= PDADDRESS) {
 801b0e4:	6a3b      	ldr	r3, [r7, #32]
 801b0e6:	225c      	movs	r2, #92	; 0x5c
 801b0e8:	5c9b      	ldrb	r3, [r3, r2]
 801b0ea:	2b02      	cmp	r3, #2
 801b0ec:	d964      	bls.n	801b1b8 <pppos_input+0x160>
          /* ignore it */;
        /* If we haven't received the packet header, drop what has come in. */
        } else if (pppos->in_state < PDDATA) {
 801b0ee:	6a3b      	ldr	r3, [r7, #32]
 801b0f0:	225c      	movs	r2, #92	; 0x5c
 801b0f2:	5c9b      	ldrb	r3, [r3, r2]
 801b0f4:	2b05      	cmp	r3, #5
 801b0f6:	d804      	bhi.n	801b102 <pppos_input+0xaa>
          PPPDEBUG(LOG_WARNING,
                   ("pppos_input[%d]: Dropping incomplete packet %d\n",
                    ppp->netif->num, pppos->in_state));
          LINK_STATS_INC(link.lenerr);
          pppos_input_drop(pppos);
 801b0f8:	6a3b      	ldr	r3, [r7, #32]
 801b0fa:	0018      	movs	r0, r3
 801b0fc:	f000 fa05 	bl	801b50a <pppos_input_drop>
 801b100:	e05a      	b.n	801b1b8 <pppos_input+0x160>
        /* If the fcs is invalid, drop the packet. */
        } else if (pppos->in_fcs != PPP_GOODFCS) {
 801b102:	6a3b      	ldr	r3, [r7, #32]
 801b104:	225a      	movs	r2, #90	; 0x5a
 801b106:	5a9b      	ldrh	r3, [r3, r2]
 801b108:	4ab5      	ldr	r2, [pc, #724]	; (801b3e0 <pppos_input+0x388>)
 801b10a:	4293      	cmp	r3, r2
 801b10c:	d004      	beq.n	801b118 <pppos_input+0xc0>
          PPPDEBUG(LOG_INFO,
                   ("pppos_input[%d]: Dropping bad fcs 0x%"X16_F" proto=0x%"X16_F"\n",
                    ppp->netif->num, pppos->in_fcs, pppos->in_protocol));
          /* Note: If you get lots of these, check for UART frame errors or try different baud rate */
          LINK_STATS_INC(link.chkerr);
          pppos_input_drop(pppos);
 801b10e:	6a3b      	ldr	r3, [r7, #32]
 801b110:	0018      	movs	r0, r3
 801b112:	f000 f9fa 	bl	801b50a <pppos_input_drop>
 801b116:	e04f      	b.n	801b1b8 <pppos_input+0x160>
        /* Otherwise it's a good packet so pass it on. */
        } else {
          struct pbuf *inp;
          /* Trim off the checksum. */
          if(pppos->in_tail->len > 2) {
 801b118:	6a3b      	ldr	r3, [r7, #32]
 801b11a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801b11c:	895b      	ldrh	r3, [r3, #10]
 801b11e:	2b02      	cmp	r3, #2
 801b120:	d91c      	bls.n	801b15c <pppos_input+0x104>
            pppos->in_tail->len -= 2;
 801b122:	6a3b      	ldr	r3, [r7, #32]
 801b124:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801b126:	895a      	ldrh	r2, [r3, #10]
 801b128:	6a3b      	ldr	r3, [r7, #32]
 801b12a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801b12c:	3a02      	subs	r2, #2
 801b12e:	b292      	uxth	r2, r2
 801b130:	815a      	strh	r2, [r3, #10]

            pppos->in_tail->tot_len = pppos->in_tail->len;
 801b132:	6a3b      	ldr	r3, [r7, #32]
 801b134:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801b136:	6a3b      	ldr	r3, [r7, #32]
 801b138:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801b13a:	8952      	ldrh	r2, [r2, #10]
 801b13c:	811a      	strh	r2, [r3, #8]
            if (pppos->in_tail != pppos->in_head) {
 801b13e:	6a3b      	ldr	r3, [r7, #32]
 801b140:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801b142:	6a3b      	ldr	r3, [r7, #32]
 801b144:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801b146:	429a      	cmp	r2, r3
 801b148:	d027      	beq.n	801b19a <pppos_input+0x142>
              pbuf_cat(pppos->in_head, pppos->in_tail);
 801b14a:	6a3b      	ldr	r3, [r7, #32]
 801b14c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 801b14e:	6a3b      	ldr	r3, [r7, #32]
 801b150:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801b152:	0019      	movs	r1, r3
 801b154:	0010      	movs	r0, r2
 801b156:	f7ef faa1 	bl	800a69c <pbuf_cat>
 801b15a:	e01e      	b.n	801b19a <pppos_input+0x142>
            }
          } else {
            pppos->in_tail->tot_len = pppos->in_tail->len;
 801b15c:	6a3b      	ldr	r3, [r7, #32]
 801b15e:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801b160:	6a3b      	ldr	r3, [r7, #32]
 801b162:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801b164:	8952      	ldrh	r2, [r2, #10]
 801b166:	811a      	strh	r2, [r3, #8]
            if (pppos->in_tail != pppos->in_head) {
 801b168:	6a3b      	ldr	r3, [r7, #32]
 801b16a:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801b16c:	6a3b      	ldr	r3, [r7, #32]
 801b16e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801b170:	429a      	cmp	r2, r3
 801b172:	d007      	beq.n	801b184 <pppos_input+0x12c>
              pbuf_cat(pppos->in_head, pppos->in_tail);
 801b174:	6a3b      	ldr	r3, [r7, #32]
 801b176:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 801b178:	6a3b      	ldr	r3, [r7, #32]
 801b17a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801b17c:	0019      	movs	r1, r3
 801b17e:	0010      	movs	r0, r2
 801b180:	f7ef fa8c 	bl	800a69c <pbuf_cat>
            }

            pbuf_realloc(pppos->in_head, pppos->in_head->tot_len - 2);
 801b184:	6a3b      	ldr	r3, [r7, #32]
 801b186:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 801b188:	6a3b      	ldr	r3, [r7, #32]
 801b18a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801b18c:	891b      	ldrh	r3, [r3, #8]
 801b18e:	3b02      	subs	r3, #2
 801b190:	b29b      	uxth	r3, r3
 801b192:	0019      	movs	r1, r3
 801b194:	0010      	movs	r0, r2
 801b196:	f7ee ffe9 	bl	800a16c <pbuf_realloc>
          }

          /* Dispatch the packet thereby consuming it. */
          inp = pppos->in_head;
 801b19a:	6a3b      	ldr	r3, [r7, #32]
 801b19c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801b19e:	613b      	str	r3, [r7, #16]
          /* Packet consumed, release our references. */
          pppos->in_head = NULL;
 801b1a0:	6a3b      	ldr	r3, [r7, #32]
 801b1a2:	2200      	movs	r2, #0
 801b1a4:	651a      	str	r2, [r3, #80]	; 0x50
          pppos->in_tail = NULL;
 801b1a6:	6a3b      	ldr	r3, [r7, #32]
 801b1a8:	2200      	movs	r2, #0
 801b1aa:	655a      	str	r2, [r3, #84]	; 0x54
            pbuf_free(inp);
            LINK_STATS_INC(link.drop);
            MIB2_STATS_NETIF_INC(ppp->netif, ifindiscards);
          }
#else /* PPP_INPROC_IRQ_SAFE */
          ppp_input(ppp, inp);
 801b1ac:	693a      	ldr	r2, [r7, #16]
 801b1ae:	68fb      	ldr	r3, [r7, #12]
 801b1b0:	0011      	movs	r1, r2
 801b1b2:	0018      	movs	r0, r3
 801b1b4:	f7ff fb1e 	bl	801a7f4 <ppp_input>
#endif /* PPP_INPROC_IRQ_SAFE */
        }

        /* Prepare for a new packet. */
        pppos->in_fcs = PPP_INITFCS;
 801b1b8:	6a3b      	ldr	r3, [r7, #32]
 801b1ba:	225a      	movs	r2, #90	; 0x5a
 801b1bc:	2101      	movs	r1, #1
 801b1be:	4249      	negs	r1, r1
 801b1c0:	5299      	strh	r1, [r3, r2]
        pppos->in_state = PDADDRESS;
 801b1c2:	6a3b      	ldr	r3, [r7, #32]
 801b1c4:	225c      	movs	r2, #92	; 0x5c
 801b1c6:	2102      	movs	r1, #2
 801b1c8:	5499      	strb	r1, [r3, r2]
        pppos->in_escaped = 0;
 801b1ca:	6a3b      	ldr	r3, [r7, #32]
 801b1cc:	225d      	movs	r2, #93	; 0x5d
 801b1ce:	2100      	movs	r1, #0
 801b1d0:	5499      	strb	r1, [r3, r2]
 801b1d2:	e0fa      	b.n	801b3ca <pppos_input+0x372>
                 ("pppos_input[%d]: Dropping ACCM char <%d>\n", ppp->netif->num, cur_char));
      }
    /* Process other characters. */
    } else {
      /* Unencode escaped characters. */
      if (pppos->in_escaped) {
 801b1d4:	6a3b      	ldr	r3, [r7, #32]
 801b1d6:	225d      	movs	r2, #93	; 0x5d
 801b1d8:	5c9b      	ldrb	r3, [r3, r2]
 801b1da:	2b00      	cmp	r3, #0
 801b1dc:	d00a      	beq.n	801b1f4 <pppos_input+0x19c>
        pppos->in_escaped = 0;
 801b1de:	6a3b      	ldr	r3, [r7, #32]
 801b1e0:	225d      	movs	r2, #93	; 0x5d
 801b1e2:	2100      	movs	r1, #0
 801b1e4:	5499      	strb	r1, [r3, r2]
        cur_char ^= PPP_TRANS;
 801b1e6:	2227      	movs	r2, #39	; 0x27
 801b1e8:	18bb      	adds	r3, r7, r2
 801b1ea:	18ba      	adds	r2, r7, r2
 801b1ec:	7812      	ldrb	r2, [r2, #0]
 801b1ee:	2120      	movs	r1, #32
 801b1f0:	404a      	eors	r2, r1
 801b1f2:	701a      	strb	r2, [r3, #0]
      }

      /* Process character relative to current state. */
      switch(pppos->in_state) {
 801b1f4:	6a3b      	ldr	r3, [r7, #32]
 801b1f6:	225c      	movs	r2, #92	; 0x5c
 801b1f8:	5c9b      	ldrb	r3, [r3, r2]
 801b1fa:	2b06      	cmp	r3, #6
 801b1fc:	d900      	bls.n	801b200 <pppos_input+0x1a8>
 801b1fe:	e0ca      	b.n	801b396 <pppos_input+0x33e>
 801b200:	009a      	lsls	r2, r3, #2
 801b202:	4b78      	ldr	r3, [pc, #480]	; (801b3e4 <pppos_input+0x38c>)
 801b204:	18d3      	adds	r3, r2, r3
 801b206:	681b      	ldr	r3, [r3, #0]
 801b208:	469f      	mov	pc, r3
        case PDIDLE:                    /* Idle state - waiting. */
          /* Drop the character if it's not 0xff
           * we would have processed a flag character above. */
          if (cur_char != PPP_ALLSTATIONS) {
 801b20a:	2327      	movs	r3, #39	; 0x27
 801b20c:	18fb      	adds	r3, r7, r3
 801b20e:	781b      	ldrb	r3, [r3, #0]
 801b210:	2bff      	cmp	r3, #255	; 0xff
 801b212:	d000      	beq.n	801b216 <pppos_input+0x1be>
 801b214:	e0c1      	b.n	801b39a <pppos_input+0x342>
          /* no break */
          /* Fall through */

        case PDSTART:                   /* Process start flag. */
          /* Prepare for a new packet. */
          pppos->in_fcs = PPP_INITFCS;
 801b216:	6a3b      	ldr	r3, [r7, #32]
 801b218:	225a      	movs	r2, #90	; 0x5a
 801b21a:	2101      	movs	r1, #1
 801b21c:	4249      	negs	r1, r1
 801b21e:	5299      	strh	r1, [r3, r2]
          /* no break */
          /* Fall through */

        case PDADDRESS:                 /* Process address field. */
          if (cur_char == PPP_ALLSTATIONS) {
 801b220:	2327      	movs	r3, #39	; 0x27
 801b222:	18fb      	adds	r3, r7, r3
 801b224:	781b      	ldrb	r3, [r3, #0]
 801b226:	2bff      	cmp	r3, #255	; 0xff
 801b228:	d104      	bne.n	801b234 <pppos_input+0x1dc>
            pppos->in_state = PDCONTROL;
 801b22a:	6a3b      	ldr	r3, [r7, #32]
 801b22c:	225c      	movs	r2, #92	; 0x5c
 801b22e:	2103      	movs	r1, #3
 801b230:	5499      	strb	r1, [r3, r2]
            break;
 801b232:	e0b3      	b.n	801b39c <pppos_input+0x344>
          /* Else assume compressed address and control fields so
           * fall through to get the protocol... */
          /* Fall through */
        case PDCONTROL:                 /* Process control field. */
          /* If we don't get a valid control code, restart. */
          if (cur_char == PPP_UI) {
 801b234:	2327      	movs	r3, #39	; 0x27
 801b236:	18fb      	adds	r3, r7, r3
 801b238:	781b      	ldrb	r3, [r3, #0]
 801b23a:	2b03      	cmp	r3, #3
 801b23c:	d104      	bne.n	801b248 <pppos_input+0x1f0>
            pppos->in_state = PDPROTOCOL1;
 801b23e:	6a3b      	ldr	r3, [r7, #32]
 801b240:	225c      	movs	r2, #92	; 0x5c
 801b242:	2104      	movs	r1, #4
 801b244:	5499      	strb	r1, [r3, r2]
            break;
 801b246:	e0a9      	b.n	801b39c <pppos_input+0x344>
          /* Fall through */

      case PDPROTOCOL1:               /* Process protocol field 1. */
          /* If the lower bit is set, this is the end of the protocol
           * field. */
          if (cur_char & 1) {
 801b248:	2127      	movs	r1, #39	; 0x27
 801b24a:	187b      	adds	r3, r7, r1
 801b24c:	781b      	ldrb	r3, [r3, #0]
 801b24e:	2201      	movs	r2, #1
 801b250:	4013      	ands	r3, r2
 801b252:	d00a      	beq.n	801b26a <pppos_input+0x212>
            pppos->in_protocol = cur_char;
 801b254:	187b      	adds	r3, r7, r1
 801b256:	781b      	ldrb	r3, [r3, #0]
 801b258:	b299      	uxth	r1, r3
 801b25a:	6a3b      	ldr	r3, [r7, #32]
 801b25c:	2258      	movs	r2, #88	; 0x58
 801b25e:	5299      	strh	r1, [r3, r2]
            pppos->in_state = PDDATA;
 801b260:	6a3b      	ldr	r3, [r7, #32]
 801b262:	225c      	movs	r2, #92	; 0x5c
 801b264:	2106      	movs	r1, #6
 801b266:	5499      	strb	r1, [r3, r2]
          } else {
            pppos->in_protocol = (u16_t)cur_char << 8;
            pppos->in_state = PDPROTOCOL2;
          }
          break;
 801b268:	e098      	b.n	801b39c <pppos_input+0x344>
            pppos->in_protocol = (u16_t)cur_char << 8;
 801b26a:	2327      	movs	r3, #39	; 0x27
 801b26c:	18fb      	adds	r3, r7, r3
 801b26e:	781b      	ldrb	r3, [r3, #0]
 801b270:	b29b      	uxth	r3, r3
 801b272:	021b      	lsls	r3, r3, #8
 801b274:	b299      	uxth	r1, r3
 801b276:	6a3b      	ldr	r3, [r7, #32]
 801b278:	2258      	movs	r2, #88	; 0x58
 801b27a:	5299      	strh	r1, [r3, r2]
            pppos->in_state = PDPROTOCOL2;
 801b27c:	6a3b      	ldr	r3, [r7, #32]
 801b27e:	225c      	movs	r2, #92	; 0x5c
 801b280:	2105      	movs	r1, #5
 801b282:	5499      	strb	r1, [r3, r2]
          break;
 801b284:	e08a      	b.n	801b39c <pppos_input+0x344>
        case PDPROTOCOL2:               /* Process protocol field 2. */
          pppos->in_protocol |= cur_char;
 801b286:	6a3b      	ldr	r3, [r7, #32]
 801b288:	2258      	movs	r2, #88	; 0x58
 801b28a:	5a9a      	ldrh	r2, [r3, r2]
 801b28c:	2327      	movs	r3, #39	; 0x27
 801b28e:	18fb      	adds	r3, r7, r3
 801b290:	781b      	ldrb	r3, [r3, #0]
 801b292:	b29b      	uxth	r3, r3
 801b294:	4313      	orrs	r3, r2
 801b296:	b299      	uxth	r1, r3
 801b298:	6a3b      	ldr	r3, [r7, #32]
 801b29a:	2258      	movs	r2, #88	; 0x58
 801b29c:	5299      	strh	r1, [r3, r2]
          pppos->in_state = PDDATA;
 801b29e:	6a3b      	ldr	r3, [r7, #32]
 801b2a0:	225c      	movs	r2, #92	; 0x5c
 801b2a2:	2106      	movs	r1, #6
 801b2a4:	5499      	strb	r1, [r3, r2]
          break;
 801b2a6:	e079      	b.n	801b39c <pppos_input+0x344>
        case PDDATA:                    /* Process data byte. */
          /* Make space to receive processed data. */
          if (pppos->in_tail == NULL || pppos->in_tail->len == PBUF_POOL_BUFSIZE) {
 801b2a8:	6a3b      	ldr	r3, [r7, #32]
 801b2aa:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801b2ac:	2b00      	cmp	r3, #0
 801b2ae:	d006      	beq.n	801b2be <pppos_input+0x266>
 801b2b0:	6a3b      	ldr	r3, [r7, #32]
 801b2b2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801b2b4:	895a      	ldrh	r2, [r3, #10]
 801b2b6:	2394      	movs	r3, #148	; 0x94
 801b2b8:	009b      	lsls	r3, r3, #2
 801b2ba:	429a      	cmp	r2, r3
 801b2bc:	d15b      	bne.n	801b376 <pppos_input+0x31e>
            u16_t pbuf_alloc_len;
            if (pppos->in_tail != NULL) {
 801b2be:	6a3b      	ldr	r3, [r7, #32]
 801b2c0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801b2c2:	2b00      	cmp	r3, #0
 801b2c4:	d016      	beq.n	801b2f4 <pppos_input+0x29c>
              pppos->in_tail->tot_len = pppos->in_tail->len;
 801b2c6:	6a3b      	ldr	r3, [r7, #32]
 801b2c8:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801b2ca:	6a3b      	ldr	r3, [r7, #32]
 801b2cc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801b2ce:	8952      	ldrh	r2, [r2, #10]
 801b2d0:	811a      	strh	r2, [r3, #8]
              if (pppos->in_tail != pppos->in_head) {
 801b2d2:	6a3b      	ldr	r3, [r7, #32]
 801b2d4:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801b2d6:	6a3b      	ldr	r3, [r7, #32]
 801b2d8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801b2da:	429a      	cmp	r2, r3
 801b2dc:	d00a      	beq.n	801b2f4 <pppos_input+0x29c>
                pbuf_cat(pppos->in_head, pppos->in_tail);
 801b2de:	6a3b      	ldr	r3, [r7, #32]
 801b2e0:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 801b2e2:	6a3b      	ldr	r3, [r7, #32]
 801b2e4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801b2e6:	0019      	movs	r1, r3
 801b2e8:	0010      	movs	r0, r2
 801b2ea:	f7ef f9d7 	bl	800a69c <pbuf_cat>
                /* give up the in_tail reference now */
                pppos->in_tail = NULL;
 801b2ee:	6a3b      	ldr	r3, [r7, #32]
 801b2f0:	2200      	movs	r2, #0
 801b2f2:	655a      	str	r2, [r3, #84]	; 0x54
              }
            }
            /* If we haven't started a packet, we need a packet header. */
            pbuf_alloc_len = 0;
 801b2f4:	211c      	movs	r1, #28
 801b2f6:	187b      	adds	r3, r7, r1
 801b2f8:	2200      	movs	r2, #0
 801b2fa:	801a      	strh	r2, [r3, #0]
             */
            if (pppos->in_head == NULL) {
              pbuf_alloc_len = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN;
            }
#endif /* IP_FORWARD || LWIP_IPV6_FORWARD */
            next_pbuf = pbuf_alloc(PBUF_RAW, pbuf_alloc_len, PBUF_POOL);
 801b2fc:	23c1      	movs	r3, #193	; 0xc1
 801b2fe:	005a      	lsls	r2, r3, #1
 801b300:	187b      	adds	r3, r7, r1
 801b302:	881b      	ldrh	r3, [r3, #0]
 801b304:	0019      	movs	r1, r3
 801b306:	2000      	movs	r0, #0
 801b308:	f7ee fdb2 	bl	8009e70 <pbuf_alloc>
 801b30c:	0003      	movs	r3, r0
 801b30e:	61bb      	str	r3, [r7, #24]
            if (next_pbuf == NULL) {
 801b310:	69bb      	ldr	r3, [r7, #24]
 801b312:	2b00      	cmp	r3, #0
 801b314:	d108      	bne.n	801b328 <pppos_input+0x2d0>
              /* No free buffers.  Drop the input packet and let the
               * higher layers deal with it.  Continue processing
               * the received pbuf chain in case a new packet starts. */
              PPPDEBUG(LOG_ERR, ("pppos_input[%d]: NO FREE PBUFS!\n", ppp->netif->num));
              LINK_STATS_INC(link.memerr);
              pppos_input_drop(pppos);
 801b316:	6a3b      	ldr	r3, [r7, #32]
 801b318:	0018      	movs	r0, r3
 801b31a:	f000 f8f6 	bl	801b50a <pppos_input_drop>
              pppos->in_state = PDSTART;  /* Wait for flag sequence. */
 801b31e:	6a3b      	ldr	r3, [r7, #32]
 801b320:	225c      	movs	r2, #92	; 0x5c
 801b322:	2101      	movs	r1, #1
 801b324:	5499      	strb	r1, [r3, r2]
              break;
 801b326:	e039      	b.n	801b39c <pppos_input+0x344>
            }
            if (pppos->in_head == NULL) {
 801b328:	6a3b      	ldr	r3, [r7, #32]
 801b32a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801b32c:	2b00      	cmp	r3, #0
 801b32e:	d11f      	bne.n	801b370 <pppos_input+0x318>
              u8_t *payload = ((u8_t*)next_pbuf->payload) + pbuf_alloc_len;
 801b330:	69bb      	ldr	r3, [r7, #24]
 801b332:	685a      	ldr	r2, [r3, #4]
 801b334:	231c      	movs	r3, #28
 801b336:	18fb      	adds	r3, r7, r3
 801b338:	881b      	ldrh	r3, [r3, #0]
 801b33a:	18d3      	adds	r3, r2, r3
 801b33c:	617b      	str	r3, [r7, #20]
#if PPP_INPROC_IRQ_SAFE
              ((struct pppos_input_header*)payload)->ppp = ppp;
              payload += sizeof(struct pppos_input_header);
              next_pbuf->len += sizeof(struct pppos_input_header);
#endif /* PPP_INPROC_IRQ_SAFE */
              next_pbuf->len += sizeof(pppos->in_protocol);
 801b33e:	69bb      	ldr	r3, [r7, #24]
 801b340:	895b      	ldrh	r3, [r3, #10]
 801b342:	3302      	adds	r3, #2
 801b344:	b29a      	uxth	r2, r3
 801b346:	69bb      	ldr	r3, [r7, #24]
 801b348:	815a      	strh	r2, [r3, #10]
              *(payload++) = pppos->in_protocol >> 8;
 801b34a:	6a3b      	ldr	r3, [r7, #32]
 801b34c:	2258      	movs	r2, #88	; 0x58
 801b34e:	5a9b      	ldrh	r3, [r3, r2]
 801b350:	0a1b      	lsrs	r3, r3, #8
 801b352:	b299      	uxth	r1, r3
 801b354:	697b      	ldr	r3, [r7, #20]
 801b356:	1c5a      	adds	r2, r3, #1
 801b358:	617a      	str	r2, [r7, #20]
 801b35a:	b2ca      	uxtb	r2, r1
 801b35c:	701a      	strb	r2, [r3, #0]
              *(payload) = pppos->in_protocol & 0xFF;
 801b35e:	6a3b      	ldr	r3, [r7, #32]
 801b360:	2258      	movs	r2, #88	; 0x58
 801b362:	5a9b      	ldrh	r3, [r3, r2]
 801b364:	b2da      	uxtb	r2, r3
 801b366:	697b      	ldr	r3, [r7, #20]
 801b368:	701a      	strb	r2, [r3, #0]
              pppos->in_head = next_pbuf;
 801b36a:	6a3b      	ldr	r3, [r7, #32]
 801b36c:	69ba      	ldr	r2, [r7, #24]
 801b36e:	651a      	str	r2, [r3, #80]	; 0x50
            }
            pppos->in_tail = next_pbuf;
 801b370:	6a3b      	ldr	r3, [r7, #32]
 801b372:	69ba      	ldr	r2, [r7, #24]
 801b374:	655a      	str	r2, [r3, #84]	; 0x54
          }
          /* Load character into buffer. */
          ((u8_t*)pppos->in_tail->payload)[pppos->in_tail->len++] = cur_char;
 801b376:	6a3b      	ldr	r3, [r7, #32]
 801b378:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801b37a:	6859      	ldr	r1, [r3, #4]
 801b37c:	6a3b      	ldr	r3, [r7, #32]
 801b37e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801b380:	895a      	ldrh	r2, [r3, #10]
 801b382:	1c50      	adds	r0, r2, #1
 801b384:	b280      	uxth	r0, r0
 801b386:	8158      	strh	r0, [r3, #10]
 801b388:	0013      	movs	r3, r2
 801b38a:	18cb      	adds	r3, r1, r3
 801b38c:	2227      	movs	r2, #39	; 0x27
 801b38e:	18ba      	adds	r2, r7, r2
 801b390:	7812      	ldrb	r2, [r2, #0]
 801b392:	701a      	strb	r2, [r3, #0]
          break;
 801b394:	e002      	b.n	801b39c <pppos_input+0x344>
        default:
          break;
 801b396:	46c0      	nop			; (mov r8, r8)
 801b398:	e000      	b.n	801b39c <pppos_input+0x344>
            break;
 801b39a:	46c0      	nop			; (mov r8, r8)
      }

      /* update the frame check sequence number. */
      pppos->in_fcs = PPP_FCS(pppos->in_fcs, cur_char);
 801b39c:	6a3b      	ldr	r3, [r7, #32]
 801b39e:	225a      	movs	r2, #90	; 0x5a
 801b3a0:	5a9b      	ldrh	r3, [r3, r2]
 801b3a2:	0a1b      	lsrs	r3, r3, #8
 801b3a4:	b29a      	uxth	r2, r3
 801b3a6:	6a3b      	ldr	r3, [r7, #32]
 801b3a8:	215a      	movs	r1, #90	; 0x5a
 801b3aa:	5a5b      	ldrh	r3, [r3, r1]
 801b3ac:	0019      	movs	r1, r3
 801b3ae:	2327      	movs	r3, #39	; 0x27
 801b3b0:	18fb      	adds	r3, r7, r3
 801b3b2:	781b      	ldrb	r3, [r3, #0]
 801b3b4:	404b      	eors	r3, r1
 801b3b6:	21ff      	movs	r1, #255	; 0xff
 801b3b8:	4019      	ands	r1, r3
 801b3ba:	4b0b      	ldr	r3, [pc, #44]	; (801b3e8 <pppos_input+0x390>)
 801b3bc:	0049      	lsls	r1, r1, #1
 801b3be:	5acb      	ldrh	r3, [r1, r3]
 801b3c0:	4053      	eors	r3, r2
 801b3c2:	b299      	uxth	r1, r3
 801b3c4:	6a3b      	ldr	r3, [r7, #32]
 801b3c6:	225a      	movs	r2, #90	; 0x5a
 801b3c8:	5299      	strh	r1, [r3, r2]
  while (l-- > 0) {
 801b3ca:	687b      	ldr	r3, [r7, #4]
 801b3cc:	1e5a      	subs	r2, r3, #1
 801b3ce:	607a      	str	r2, [r7, #4]
 801b3d0:	2b00      	cmp	r3, #0
 801b3d2:	dd00      	ble.n	801b3d6 <pppos_input+0x37e>
 801b3d4:	e64a      	b.n	801b06c <pppos_input+0x14>
 801b3d6:	e000      	b.n	801b3da <pppos_input+0x382>
      return;
 801b3d8:	46c0      	nop			; (mov r8, r8)
    }
  } /* while (l-- > 0), all bytes processed */
}
 801b3da:	46bd      	mov	sp, r7
 801b3dc:	b00a      	add	sp, #40	; 0x28
 801b3de:	bd80      	pop	{r7, pc}
 801b3e0:	0000f0b8 	.word	0x0000f0b8
 801b3e4:	08023f30 	.word	0x08023f30
 801b3e8:	08023d30 	.word	0x08023d30

0801b3ec <pppos_send_config>:
}
#endif /* PPP_INPROC_IRQ_SAFE */

static void
pppos_send_config(ppp_pcb *ppp, void *ctx, u32_t accm, int pcomp, int accomp)
{
 801b3ec:	b590      	push	{r4, r7, lr}
 801b3ee:	b087      	sub	sp, #28
 801b3f0:	af00      	add	r7, sp, #0
 801b3f2:	60f8      	str	r0, [r7, #12]
 801b3f4:	60b9      	str	r1, [r7, #8]
 801b3f6:	607a      	str	r2, [r7, #4]
 801b3f8:	603b      	str	r3, [r7, #0]
  int i;
  pppos_pcb *pppos = (pppos_pcb *)ctx;
 801b3fa:	68bb      	ldr	r3, [r7, #8]
 801b3fc:	613b      	str	r3, [r7, #16]
  LWIP_UNUSED_ARG(ppp);

  pppos->pcomp = pcomp;
 801b3fe:	683b      	ldr	r3, [r7, #0]
 801b400:	1c1a      	adds	r2, r3, #0
 801b402:	2301      	movs	r3, #1
 801b404:	4013      	ands	r3, r2
 801b406:	b2d9      	uxtb	r1, r3
 801b408:	693b      	ldr	r3, [r7, #16]
 801b40a:	222c      	movs	r2, #44	; 0x2c
 801b40c:	2001      	movs	r0, #1
 801b40e:	4001      	ands	r1, r0
 801b410:	184c      	adds	r4, r1, r1
 801b412:	5c99      	ldrb	r1, [r3, r2]
 801b414:	2002      	movs	r0, #2
 801b416:	4381      	bics	r1, r0
 801b418:	1c08      	adds	r0, r1, #0
 801b41a:	1c21      	adds	r1, r4, #0
 801b41c:	4301      	orrs	r1, r0
 801b41e:	5499      	strb	r1, [r3, r2]
  pppos->accomp = accomp;
 801b420:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801b422:	1c1a      	adds	r2, r3, #0
 801b424:	2301      	movs	r3, #1
 801b426:	4013      	ands	r3, r2
 801b428:	b2d9      	uxtb	r1, r3
 801b42a:	693b      	ldr	r3, [r7, #16]
 801b42c:	222c      	movs	r2, #44	; 0x2c
 801b42e:	2001      	movs	r0, #1
 801b430:	4001      	ands	r1, r0
 801b432:	008c      	lsls	r4, r1, #2
 801b434:	5c99      	ldrb	r1, [r3, r2]
 801b436:	2004      	movs	r0, #4
 801b438:	4381      	bics	r1, r0
 801b43a:	1c08      	adds	r0, r1, #0
 801b43c:	1c21      	adds	r1, r4, #0
 801b43e:	4301      	orrs	r1, r0
 801b440:	5499      	strb	r1, [r3, r2]

  /* Load the ACCM bits for the 32 control codes. */
  for (i = 0; i < 32/8; i++) {
 801b442:	2300      	movs	r3, #0
 801b444:	617b      	str	r3, [r7, #20]
 801b446:	e00e      	b.n	801b466 <pppos_send_config+0x7a>
    pppos->out_accm[i] = (u8_t)((accm >> (8 * i)) & 0xFF);
 801b448:	697b      	ldr	r3, [r7, #20]
 801b44a:	00db      	lsls	r3, r3, #3
 801b44c:	687a      	ldr	r2, [r7, #4]
 801b44e:	40da      	lsrs	r2, r3
 801b450:	0013      	movs	r3, r2
 801b452:	b2d9      	uxtb	r1, r3
 801b454:	693a      	ldr	r2, [r7, #16]
 801b456:	697b      	ldr	r3, [r7, #20]
 801b458:	18d3      	adds	r3, r2, r3
 801b45a:	330c      	adds	r3, #12
 801b45c:	1c0a      	adds	r2, r1, #0
 801b45e:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < 32/8; i++) {
 801b460:	697b      	ldr	r3, [r7, #20]
 801b462:	3301      	adds	r3, #1
 801b464:	617b      	str	r3, [r7, #20]
 801b466:	697b      	ldr	r3, [r7, #20]
 801b468:	2b03      	cmp	r3, #3
 801b46a:	dded      	ble.n	801b448 <pppos_send_config+0x5c>
  }

  PPPDEBUG(LOG_INFO, ("pppos_send_config[%d]: out_accm=%X %X %X %X\n",
            pppos->ppp->netif->num,
            pppos->out_accm[0], pppos->out_accm[1], pppos->out_accm[2], pppos->out_accm[3]));
}
 801b46c:	46c0      	nop			; (mov r8, r8)
 801b46e:	46c0      	nop			; (mov r8, r8)
 801b470:	46bd      	mov	sp, r7
 801b472:	b007      	add	sp, #28
 801b474:	bd90      	pop	{r4, r7, pc}

0801b476 <pppos_recv_config>:

static void
pppos_recv_config(ppp_pcb *ppp, void *ctx, u32_t accm, int pcomp, int accomp)
{
 801b476:	b580      	push	{r7, lr}
 801b478:	b086      	sub	sp, #24
 801b47a:	af00      	add	r7, sp, #0
 801b47c:	60f8      	str	r0, [r7, #12]
 801b47e:	60b9      	str	r1, [r7, #8]
 801b480:	607a      	str	r2, [r7, #4]
 801b482:	603b      	str	r3, [r7, #0]
  int i;
  pppos_pcb *pppos = (pppos_pcb *)ctx;
 801b484:	68bb      	ldr	r3, [r7, #8]
 801b486:	613b      	str	r3, [r7, #16]
  LWIP_UNUSED_ARG(pcomp);
  LWIP_UNUSED_ARG(accomp);

  /* Load the ACCM bits for the 32 control codes. */
  PPPOS_PROTECT(lev);
  for (i = 0; i < 32 / 8; i++) {
 801b488:	2300      	movs	r3, #0
 801b48a:	617b      	str	r3, [r7, #20]
 801b48c:	e00f      	b.n	801b4ae <pppos_recv_config+0x38>
    pppos->in_accm[i] = (u8_t)(accm >> (i * 8));
 801b48e:	697b      	ldr	r3, [r7, #20]
 801b490:	00db      	lsls	r3, r3, #3
 801b492:	687a      	ldr	r2, [r7, #4]
 801b494:	40da      	lsrs	r2, r3
 801b496:	0013      	movs	r3, r2
 801b498:	b2d8      	uxtb	r0, r3
 801b49a:	693a      	ldr	r2, [r7, #16]
 801b49c:	212d      	movs	r1, #45	; 0x2d
 801b49e:	697b      	ldr	r3, [r7, #20]
 801b4a0:	18d3      	adds	r3, r2, r3
 801b4a2:	185b      	adds	r3, r3, r1
 801b4a4:	1c02      	adds	r2, r0, #0
 801b4a6:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < 32 / 8; i++) {
 801b4a8:	697b      	ldr	r3, [r7, #20]
 801b4aa:	3301      	adds	r3, #1
 801b4ac:	617b      	str	r3, [r7, #20]
 801b4ae:	697b      	ldr	r3, [r7, #20]
 801b4b0:	2b03      	cmp	r3, #3
 801b4b2:	ddec      	ble.n	801b48e <pppos_recv_config+0x18>
  PPPOS_UNPROTECT(lev);

  PPPDEBUG(LOG_INFO, ("pppos_recv_config[%d]: in_accm=%X %X %X %X\n",
            pppos->ppp->netif->num,
            pppos->in_accm[0], pppos->in_accm[1], pppos->in_accm[2], pppos->in_accm[3]));
}
 801b4b4:	46c0      	nop			; (mov r8, r8)
 801b4b6:	46c0      	nop			; (mov r8, r8)
 801b4b8:	46bd      	mov	sp, r7
 801b4ba:	b006      	add	sp, #24
 801b4bc:	bd80      	pop	{r7, pc}

0801b4be <pppos_input_free_current_packet>:
/*
 * Drop the input packet.
 */
static void
pppos_input_free_current_packet(pppos_pcb *pppos)
{
 801b4be:	b580      	push	{r7, lr}
 801b4c0:	b082      	sub	sp, #8
 801b4c2:	af00      	add	r7, sp, #0
 801b4c4:	6078      	str	r0, [r7, #4]
  if (pppos->in_head != NULL) {
 801b4c6:	687b      	ldr	r3, [r7, #4]
 801b4c8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801b4ca:	2b00      	cmp	r3, #0
 801b4cc:	d016      	beq.n	801b4fc <pppos_input_free_current_packet+0x3e>
    if (pppos->in_tail && (pppos->in_tail != pppos->in_head)) {
 801b4ce:	687b      	ldr	r3, [r7, #4]
 801b4d0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801b4d2:	2b00      	cmp	r3, #0
 801b4d4:	d00a      	beq.n	801b4ec <pppos_input_free_current_packet+0x2e>
 801b4d6:	687b      	ldr	r3, [r7, #4]
 801b4d8:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801b4da:	687b      	ldr	r3, [r7, #4]
 801b4dc:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801b4de:	429a      	cmp	r2, r3
 801b4e0:	d004      	beq.n	801b4ec <pppos_input_free_current_packet+0x2e>
      pbuf_free(pppos->in_tail);
 801b4e2:	687b      	ldr	r3, [r7, #4]
 801b4e4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801b4e6:	0018      	movs	r0, r3
 801b4e8:	f7ee fff8 	bl	800a4dc <pbuf_free>
    }
    pbuf_free(pppos->in_head);
 801b4ec:	687b      	ldr	r3, [r7, #4]
 801b4ee:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801b4f0:	0018      	movs	r0, r3
 801b4f2:	f7ee fff3 	bl	800a4dc <pbuf_free>
    pppos->in_head = NULL;
 801b4f6:	687b      	ldr	r3, [r7, #4]
 801b4f8:	2200      	movs	r2, #0
 801b4fa:	651a      	str	r2, [r3, #80]	; 0x50
  }
  pppos->in_tail = NULL;
 801b4fc:	687b      	ldr	r3, [r7, #4]
 801b4fe:	2200      	movs	r2, #0
 801b500:	655a      	str	r2, [r3, #84]	; 0x54
}
 801b502:	46c0      	nop			; (mov r8, r8)
 801b504:	46bd      	mov	sp, r7
 801b506:	b002      	add	sp, #8
 801b508:	bd80      	pop	{r7, pc}

0801b50a <pppos_input_drop>:
/*
 * Drop the input packet and increase error counters.
 */
static void
pppos_input_drop(pppos_pcb *pppos)
{
 801b50a:	b580      	push	{r7, lr}
 801b50c:	b082      	sub	sp, #8
 801b50e:	af00      	add	r7, sp, #0
 801b510:	6078      	str	r0, [r7, #4]
#if 0
    PPPDEBUG(LOG_INFO, ("pppos_input_drop: %d:%.*H\n", pppos->in_head->len, min(60, pppos->in_head->len * 2), pppos->in_head->payload));
#endif
    PPPDEBUG(LOG_INFO, ("pppos_input_drop: pbuf len=%d, addr %p\n", pppos->in_head->len, (void*)pppos->in_head));
  }
  pppos_input_free_current_packet(pppos);
 801b512:	687b      	ldr	r3, [r7, #4]
 801b514:	0018      	movs	r0, r3
 801b516:	f7ff ffd2 	bl	801b4be <pppos_input_free_current_packet>
#if VJ_SUPPORT
  vj_uncompress_err(&pppos->ppp->vj_comp);
 801b51a:	687b      	ldr	r3, [r7, #4]
 801b51c:	681b      	ldr	r3, [r3, #0]
 801b51e:	33dc      	adds	r3, #220	; 0xdc
 801b520:	0018      	movs	r0, r3
 801b522:	f001 fa4f 	bl	801c9c4 <vj_uncompress_err>
#endif /* VJ_SUPPORT */

  LINK_STATS_INC(link.drop);
  MIB2_STATS_NETIF_INC(pppos->ppp->netif, ifindiscards);
}
 801b526:	46c0      	nop			; (mov r8, r8)
 801b528:	46bd      	mov	sp, r7
 801b52a:	b002      	add	sp, #8
 801b52c:	bd80      	pop	{r7, pc}
	...

0801b530 <pppos_output_append>:
 * If pbuf is full, send the pbuf and reuse it.
 * Return the current pbuf.
 */
static err_t
pppos_output_append(pppos_pcb *pppos, err_t err, struct pbuf *nb, u8_t c, u8_t accm, u16_t *fcs)
{
 801b530:	b590      	push	{r4, r7, lr}
 801b532:	b087      	sub	sp, #28
 801b534:	af00      	add	r7, sp, #0
 801b536:	60f8      	str	r0, [r7, #12]
 801b538:	0008      	movs	r0, r1
 801b53a:	607a      	str	r2, [r7, #4]
 801b53c:	0019      	movs	r1, r3
 801b53e:	240b      	movs	r4, #11
 801b540:	193b      	adds	r3, r7, r4
 801b542:	1c02      	adds	r2, r0, #0
 801b544:	701a      	strb	r2, [r3, #0]
 801b546:	230a      	movs	r3, #10
 801b548:	18fb      	adds	r3, r7, r3
 801b54a:	1c0a      	adds	r2, r1, #0
 801b54c:	701a      	strb	r2, [r3, #0]
  if (err != ERR_OK) {
 801b54e:	193b      	adds	r3, r7, r4
 801b550:	781b      	ldrb	r3, [r3, #0]
 801b552:	b25b      	sxtb	r3, r3
 801b554:	2b00      	cmp	r3, #0
 801b556:	d003      	beq.n	801b560 <pppos_output_append+0x30>
    return err;
 801b558:	193b      	adds	r3, r7, r4
 801b55a:	781b      	ldrb	r3, [r3, #0]
 801b55c:	b25b      	sxtb	r3, r3
 801b55e:	e07a      	b.n	801b656 <pppos_output_append+0x126>
  }

  /* Make sure there is room for the character and an escape code.
   * Sure we don't quite fill the buffer if the character doesn't
   * get escaped but is one character worth complicating this? */
  if ((PBUF_POOL_BUFSIZE - nb->len) < 2) {
 801b560:	687b      	ldr	r3, [r7, #4]
 801b562:	895b      	ldrh	r3, [r3, #10]
 801b564:	001a      	movs	r2, r3
 801b566:	2394      	movs	r3, #148	; 0x94
 801b568:	009b      	lsls	r3, r3, #2
 801b56a:	1a9b      	subs	r3, r3, r2
 801b56c:	2b01      	cmp	r3, #1
 801b56e:	d81a      	bhi.n	801b5a6 <pppos_output_append+0x76>
    u32_t l = pppos->output_cb(pppos->ppp, (u8_t*)nb->payload, nb->len, pppos->ppp->ctx_cb);
 801b570:	68fb      	ldr	r3, [r7, #12]
 801b572:	685c      	ldr	r4, [r3, #4]
 801b574:	68fb      	ldr	r3, [r7, #12]
 801b576:	6818      	ldr	r0, [r3, #0]
 801b578:	687b      	ldr	r3, [r7, #4]
 801b57a:	6859      	ldr	r1, [r3, #4]
 801b57c:	687b      	ldr	r3, [r7, #4]
 801b57e:	895b      	ldrh	r3, [r3, #10]
 801b580:	001a      	movs	r2, r3
 801b582:	68fb      	ldr	r3, [r7, #12]
 801b584:	681b      	ldr	r3, [r3, #0]
 801b586:	69db      	ldr	r3, [r3, #28]
 801b588:	47a0      	blx	r4
 801b58a:	0003      	movs	r3, r0
 801b58c:	617b      	str	r3, [r7, #20]
    if (l != nb->len) {
 801b58e:	687b      	ldr	r3, [r7, #4]
 801b590:	895b      	ldrh	r3, [r3, #10]
 801b592:	001a      	movs	r2, r3
 801b594:	697b      	ldr	r3, [r7, #20]
 801b596:	4293      	cmp	r3, r2
 801b598:	d002      	beq.n	801b5a0 <pppos_output_append+0x70>
      return ERR_IF;
 801b59a:	230c      	movs	r3, #12
 801b59c:	425b      	negs	r3, r3
 801b59e:	e05a      	b.n	801b656 <pppos_output_append+0x126>
    }
    nb->len = 0;
 801b5a0:	687b      	ldr	r3, [r7, #4]
 801b5a2:	2200      	movs	r2, #0
 801b5a4:	815a      	strh	r2, [r3, #10]
  }

  /* Update FCS before checking for special characters. */
  if (fcs) {
 801b5a6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801b5a8:	2b00      	cmp	r3, #0
 801b5aa:	d013      	beq.n	801b5d4 <pppos_output_append+0xa4>
    *fcs = PPP_FCS(*fcs, c);
 801b5ac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801b5ae:	881b      	ldrh	r3, [r3, #0]
 801b5b0:	0a1b      	lsrs	r3, r3, #8
 801b5b2:	b29a      	uxth	r2, r3
 801b5b4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801b5b6:	881b      	ldrh	r3, [r3, #0]
 801b5b8:	0019      	movs	r1, r3
 801b5ba:	230a      	movs	r3, #10
 801b5bc:	18fb      	adds	r3, r7, r3
 801b5be:	781b      	ldrb	r3, [r3, #0]
 801b5c0:	404b      	eors	r3, r1
 801b5c2:	21ff      	movs	r1, #255	; 0xff
 801b5c4:	4019      	ands	r1, r3
 801b5c6:	4b26      	ldr	r3, [pc, #152]	; (801b660 <pppos_output_append+0x130>)
 801b5c8:	0049      	lsls	r1, r1, #1
 801b5ca:	5acb      	ldrh	r3, [r1, r3]
 801b5cc:	4053      	eors	r3, r2
 801b5ce:	b29a      	uxth	r2, r3
 801b5d0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801b5d2:	801a      	strh	r2, [r3, #0]
  }

  /* Copy to output buffer escaping special characters. */
  if (accm && ESCAPE_P(pppos->out_accm, c)) {
 801b5d4:	2328      	movs	r3, #40	; 0x28
 801b5d6:	18fb      	adds	r3, r7, r3
 801b5d8:	781b      	ldrb	r3, [r3, #0]
 801b5da:	2b00      	cmp	r3, #0
 801b5dc:	d02d      	beq.n	801b63a <pppos_output_append+0x10a>
 801b5de:	240a      	movs	r4, #10
 801b5e0:	193b      	adds	r3, r7, r4
 801b5e2:	781b      	ldrb	r3, [r3, #0]
 801b5e4:	08db      	lsrs	r3, r3, #3
 801b5e6:	b2db      	uxtb	r3, r3
 801b5e8:	001a      	movs	r2, r3
 801b5ea:	68fb      	ldr	r3, [r7, #12]
 801b5ec:	189b      	adds	r3, r3, r2
 801b5ee:	7b1b      	ldrb	r3, [r3, #12]
 801b5f0:	0019      	movs	r1, r3
 801b5f2:	193b      	adds	r3, r7, r4
 801b5f4:	781b      	ldrb	r3, [r3, #0]
 801b5f6:	2207      	movs	r2, #7
 801b5f8:	4013      	ands	r3, r2
 801b5fa:	4119      	asrs	r1, r3
 801b5fc:	000b      	movs	r3, r1
 801b5fe:	2201      	movs	r2, #1
 801b600:	4013      	ands	r3, r2
 801b602:	d01a      	beq.n	801b63a <pppos_output_append+0x10a>
    *((u8_t*)nb->payload + nb->len++) = PPP_ESCAPE;
 801b604:	687b      	ldr	r3, [r7, #4]
 801b606:	685a      	ldr	r2, [r3, #4]
 801b608:	687b      	ldr	r3, [r7, #4]
 801b60a:	895b      	ldrh	r3, [r3, #10]
 801b60c:	1c59      	adds	r1, r3, #1
 801b60e:	b288      	uxth	r0, r1
 801b610:	6879      	ldr	r1, [r7, #4]
 801b612:	8148      	strh	r0, [r1, #10]
 801b614:	18d3      	adds	r3, r2, r3
 801b616:	227d      	movs	r2, #125	; 0x7d
 801b618:	701a      	strb	r2, [r3, #0]
    *((u8_t*)nb->payload + nb->len++) = c ^ PPP_TRANS;
 801b61a:	687b      	ldr	r3, [r7, #4]
 801b61c:	685a      	ldr	r2, [r3, #4]
 801b61e:	687b      	ldr	r3, [r7, #4]
 801b620:	895b      	ldrh	r3, [r3, #10]
 801b622:	1c59      	adds	r1, r3, #1
 801b624:	b288      	uxth	r0, r1
 801b626:	6879      	ldr	r1, [r7, #4]
 801b628:	8148      	strh	r0, [r1, #10]
 801b62a:	18d3      	adds	r3, r2, r3
 801b62c:	193a      	adds	r2, r7, r4
 801b62e:	7812      	ldrb	r2, [r2, #0]
 801b630:	2120      	movs	r1, #32
 801b632:	404a      	eors	r2, r1
 801b634:	b2d2      	uxtb	r2, r2
 801b636:	701a      	strb	r2, [r3, #0]
 801b638:	e00c      	b.n	801b654 <pppos_output_append+0x124>
  } else {
    *((u8_t*)nb->payload + nb->len++) = c;
 801b63a:	687b      	ldr	r3, [r7, #4]
 801b63c:	685a      	ldr	r2, [r3, #4]
 801b63e:	687b      	ldr	r3, [r7, #4]
 801b640:	895b      	ldrh	r3, [r3, #10]
 801b642:	1c59      	adds	r1, r3, #1
 801b644:	b288      	uxth	r0, r1
 801b646:	6879      	ldr	r1, [r7, #4]
 801b648:	8148      	strh	r0, [r1, #10]
 801b64a:	18d3      	adds	r3, r2, r3
 801b64c:	220a      	movs	r2, #10
 801b64e:	18ba      	adds	r2, r7, r2
 801b650:	7812      	ldrb	r2, [r2, #0]
 801b652:	701a      	strb	r2, [r3, #0]
  }

  return ERR_OK;
 801b654:	2300      	movs	r3, #0
}
 801b656:	0018      	movs	r0, r3
 801b658:	46bd      	mov	sp, r7
 801b65a:	b007      	add	sp, #28
 801b65c:	bd90      	pop	{r4, r7, pc}
 801b65e:	46c0      	nop			; (mov r8, r8)
 801b660:	08023d30 	.word	0x08023d30

0801b664 <pppos_output_last>:

static err_t
pppos_output_last(pppos_pcb *pppos, err_t err, struct pbuf *nb, u16_t *fcs)
{
 801b664:	b5f0      	push	{r4, r5, r6, r7, lr}
 801b666:	b089      	sub	sp, #36	; 0x24
 801b668:	af02      	add	r7, sp, #8
 801b66a:	60f8      	str	r0, [r7, #12]
 801b66c:	607a      	str	r2, [r7, #4]
 801b66e:	603b      	str	r3, [r7, #0]
 801b670:	260b      	movs	r6, #11
 801b672:	19bb      	adds	r3, r7, r6
 801b674:	1c0a      	adds	r2, r1, #0
 801b676:	701a      	strb	r2, [r3, #0]
  ppp_pcb *ppp = pppos->ppp;
 801b678:	68fb      	ldr	r3, [r7, #12]
 801b67a:	681b      	ldr	r3, [r3, #0]
 801b67c:	617b      	str	r3, [r7, #20]

  /* Add FCS and trailing flag. */
  err = pppos_output_append(pppos, err,  nb, ~(*fcs) & 0xFF, 1, NULL);
 801b67e:	683b      	ldr	r3, [r7, #0]
 801b680:	881b      	ldrh	r3, [r3, #0]
 801b682:	b2db      	uxtb	r3, r3
 801b684:	43db      	mvns	r3, r3
 801b686:	b2dd      	uxtb	r5, r3
 801b688:	19bc      	adds	r4, r7, r6
 801b68a:	687a      	ldr	r2, [r7, #4]
 801b68c:	19bb      	adds	r3, r7, r6
 801b68e:	2100      	movs	r1, #0
 801b690:	5659      	ldrsb	r1, [r3, r1]
 801b692:	68f8      	ldr	r0, [r7, #12]
 801b694:	2300      	movs	r3, #0
 801b696:	9301      	str	r3, [sp, #4]
 801b698:	2301      	movs	r3, #1
 801b69a:	9300      	str	r3, [sp, #0]
 801b69c:	002b      	movs	r3, r5
 801b69e:	f7ff ff47 	bl	801b530 <pppos_output_append>
 801b6a2:	0003      	movs	r3, r0
 801b6a4:	7023      	strb	r3, [r4, #0]
  err = pppos_output_append(pppos, err,  nb, (~(*fcs) >> 8) & 0xFF, 1, NULL);
 801b6a6:	683b      	ldr	r3, [r7, #0]
 801b6a8:	881b      	ldrh	r3, [r3, #0]
 801b6aa:	43db      	mvns	r3, r3
 801b6ac:	121b      	asrs	r3, r3, #8
 801b6ae:	b2dd      	uxtb	r5, r3
 801b6b0:	19bc      	adds	r4, r7, r6
 801b6b2:	687a      	ldr	r2, [r7, #4]
 801b6b4:	19bb      	adds	r3, r7, r6
 801b6b6:	2100      	movs	r1, #0
 801b6b8:	5659      	ldrsb	r1, [r3, r1]
 801b6ba:	68f8      	ldr	r0, [r7, #12]
 801b6bc:	2300      	movs	r3, #0
 801b6be:	9301      	str	r3, [sp, #4]
 801b6c0:	2301      	movs	r3, #1
 801b6c2:	9300      	str	r3, [sp, #0]
 801b6c4:	002b      	movs	r3, r5
 801b6c6:	f7ff ff33 	bl	801b530 <pppos_output_append>
 801b6ca:	0003      	movs	r3, r0
 801b6cc:	7023      	strb	r3, [r4, #0]
  err = pppos_output_append(pppos, err,  nb, PPP_FLAG, 0, NULL);
 801b6ce:	0035      	movs	r5, r6
 801b6d0:	197c      	adds	r4, r7, r5
 801b6d2:	687a      	ldr	r2, [r7, #4]
 801b6d4:	197b      	adds	r3, r7, r5
 801b6d6:	2100      	movs	r1, #0
 801b6d8:	5659      	ldrsb	r1, [r3, r1]
 801b6da:	68f8      	ldr	r0, [r7, #12]
 801b6dc:	2300      	movs	r3, #0
 801b6de:	9301      	str	r3, [sp, #4]
 801b6e0:	2300      	movs	r3, #0
 801b6e2:	9300      	str	r3, [sp, #0]
 801b6e4:	237e      	movs	r3, #126	; 0x7e
 801b6e6:	f7ff ff23 	bl	801b530 <pppos_output_append>
 801b6ea:	0003      	movs	r3, r0
 801b6ec:	7023      	strb	r3, [r4, #0]

  if (err != ERR_OK) {
 801b6ee:	197b      	adds	r3, r7, r5
 801b6f0:	781b      	ldrb	r3, [r3, #0]
 801b6f2:	b25b      	sxtb	r3, r3
 801b6f4:	2b00      	cmp	r3, #0
 801b6f6:	d125      	bne.n	801b744 <pppos_output_last+0xe0>
    goto failed;
  }

  /* Send remaining buffer if not empty */
  if (nb->len > 0) {
 801b6f8:	687b      	ldr	r3, [r7, #4]
 801b6fa:	895b      	ldrh	r3, [r3, #10]
 801b6fc:	2b00      	cmp	r3, #0
 801b6fe:	d016      	beq.n	801b72e <pppos_output_last+0xca>
    u32_t l = pppos->output_cb(ppp, (u8_t*)nb->payload, nb->len, ppp->ctx_cb);
 801b700:	68fb      	ldr	r3, [r7, #12]
 801b702:	685c      	ldr	r4, [r3, #4]
 801b704:	687b      	ldr	r3, [r7, #4]
 801b706:	6859      	ldr	r1, [r3, #4]
 801b708:	687b      	ldr	r3, [r7, #4]
 801b70a:	895b      	ldrh	r3, [r3, #10]
 801b70c:	001a      	movs	r2, r3
 801b70e:	697b      	ldr	r3, [r7, #20]
 801b710:	69db      	ldr	r3, [r3, #28]
 801b712:	6978      	ldr	r0, [r7, #20]
 801b714:	47a0      	blx	r4
 801b716:	0003      	movs	r3, r0
 801b718:	613b      	str	r3, [r7, #16]
    if (l != nb->len) {
 801b71a:	687b      	ldr	r3, [r7, #4]
 801b71c:	895b      	ldrh	r3, [r3, #10]
 801b71e:	001a      	movs	r2, r3
 801b720:	693b      	ldr	r3, [r7, #16]
 801b722:	4293      	cmp	r3, r2
 801b724:	d003      	beq.n	801b72e <pppos_output_last+0xca>
      err = ERR_IF;
 801b726:	197b      	adds	r3, r7, r5
 801b728:	22f4      	movs	r2, #244	; 0xf4
 801b72a:	701a      	strb	r2, [r3, #0]
      goto failed;
 801b72c:	e00b      	b.n	801b746 <pppos_output_last+0xe2>
    }
  }

  pppos->last_xmit = sys_now();
 801b72e:	f002 fbe9 	bl	801df04 <sys_now>
 801b732:	0002      	movs	r2, r0
 801b734:	68fb      	ldr	r3, [r7, #12]
 801b736:	609a      	str	r2, [r3, #8]
  MIB2_STATS_NETIF_ADD(ppp->netif, ifoutoctets, nb->tot_len);
  MIB2_STATS_NETIF_INC(ppp->netif, ifoutucastpkts);
  LINK_STATS_INC(link.xmit);
  pbuf_free(nb);
 801b738:	687b      	ldr	r3, [r7, #4]
 801b73a:	0018      	movs	r0, r3
 801b73c:	f7ee fece 	bl	800a4dc <pbuf_free>
  return ERR_OK;
 801b740:	2300      	movs	r3, #0
 801b742:	e00b      	b.n	801b75c <pppos_output_last+0xf8>
    goto failed;
 801b744:	46c0      	nop			; (mov r8, r8)

failed:
  pppos->last_xmit = 0; /* prepend PPP_FLAG to next packet */
 801b746:	68fb      	ldr	r3, [r7, #12]
 801b748:	2200      	movs	r2, #0
 801b74a:	609a      	str	r2, [r3, #8]
  LINK_STATS_INC(link.err);
  LINK_STATS_INC(link.drop);
  MIB2_STATS_NETIF_INC(ppp->netif, ifoutdiscards);
  pbuf_free(nb);
 801b74c:	687b      	ldr	r3, [r7, #4]
 801b74e:	0018      	movs	r0, r3
 801b750:	f7ee fec4 	bl	800a4dc <pbuf_free>
  return err;
 801b754:	230b      	movs	r3, #11
 801b756:	18fb      	adds	r3, r7, r3
 801b758:	781b      	ldrb	r3, [r3, #0]
 801b75a:	b25b      	sxtb	r3, r3
}
 801b75c:	0018      	movs	r0, r3
 801b75e:	46bd      	mov	sp, r7
 801b760:	b007      	add	sp, #28
 801b762:	bdf0      	pop	{r4, r5, r6, r7, pc}

0801b764 <ppp_slprintf>:
 * %m (error message), %v (visible string),
 * %q (quoted string), %t (current time) and %I (IP address) formats.
 * Doesn't do floating-point formats.
 * Returns the number of chars put into buf.
 */
int ppp_slprintf(char *buf, int buflen, const char *fmt, ...) {
 801b764:	b40c      	push	{r2, r3}
 801b766:	b580      	push	{r7, lr}
 801b768:	b084      	sub	sp, #16
 801b76a:	af00      	add	r7, sp, #0
 801b76c:	6078      	str	r0, [r7, #4]
 801b76e:	6039      	str	r1, [r7, #0]
    va_list args;
    int n;

    va_start(args, fmt);
 801b770:	231c      	movs	r3, #28
 801b772:	18fb      	adds	r3, r7, r3
 801b774:	60bb      	str	r3, [r7, #8]
    n = ppp_vslprintf(buf, buflen, fmt, args);
 801b776:	68bb      	ldr	r3, [r7, #8]
 801b778:	69ba      	ldr	r2, [r7, #24]
 801b77a:	6839      	ldr	r1, [r7, #0]
 801b77c:	6878      	ldr	r0, [r7, #4]
 801b77e:	f000 f80b 	bl	801b798 <ppp_vslprintf>
 801b782:	0003      	movs	r3, r0
 801b784:	60fb      	str	r3, [r7, #12]
    va_end(args);
    return n;
 801b786:	68fb      	ldr	r3, [r7, #12]
}
 801b788:	0018      	movs	r0, r3
 801b78a:	46bd      	mov	sp, r7
 801b78c:	b004      	add	sp, #16
 801b78e:	bc80      	pop	{r7}
 801b790:	bc08      	pop	{r3}
 801b792:	b002      	add	sp, #8
 801b794:	4718      	bx	r3
	...

0801b798 <ppp_vslprintf>:
/*
 * ppp_vslprintf - like ppp_slprintf, takes a va_list instead of a list of args.
 */
#define OUTCHAR(c)	(buflen > 0? (--buflen, *buf++ = (c)): 0)

int ppp_vslprintf(char *buf, int buflen, const char *fmt, va_list args) {
 801b798:	b5f0      	push	{r4, r5, r6, r7, lr}
 801b79a:	b0a1      	sub	sp, #132	; 0x84
 801b79c:	af04      	add	r7, sp, #16
 801b79e:	60f8      	str	r0, [r7, #12]
 801b7a0:	60b9      	str	r1, [r7, #8]
 801b7a2:	607a      	str	r2, [r7, #4]
 801b7a4:	603b      	str	r3, [r7, #0]
    int c, i, n;
    int width, prec, fillch;
    int base, len, neg, quoted;
    unsigned long val = 0;
 801b7a6:	2300      	movs	r3, #0
 801b7a8:	64fb      	str	r3, [r7, #76]	; 0x4c
    static char hexchars[] = "0123456789abcdef";
#if PRINTPKT_SUPPORT
    struct buffer_info bufinfo;
#endif /* PRINTPKT_SUPPORT */

    buf0 = buf;
 801b7aa:	68fb      	ldr	r3, [r7, #12]
 801b7ac:	63fb      	str	r3, [r7, #60]	; 0x3c
    --buflen;
 801b7ae:	68bb      	ldr	r3, [r7, #8]
 801b7b0:	3b01      	subs	r3, #1
 801b7b2:	60bb      	str	r3, [r7, #8]
    while (buflen > 0) {
 801b7b4:	f000 fb8b 	bl	801bece <ppp_vslprintf+0x736>
	for (f = fmt; *f != '%' && *f != 0; ++f)
 801b7b8:	687b      	ldr	r3, [r7, #4]
 801b7ba:	64bb      	str	r3, [r7, #72]	; 0x48
 801b7bc:	e002      	b.n	801b7c4 <ppp_vslprintf+0x2c>
 801b7be:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801b7c0:	3301      	adds	r3, #1
 801b7c2:	64bb      	str	r3, [r7, #72]	; 0x48
 801b7c4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801b7c6:	781b      	ldrb	r3, [r3, #0]
 801b7c8:	2b25      	cmp	r3, #37	; 0x25
 801b7ca:	d003      	beq.n	801b7d4 <ppp_vslprintf+0x3c>
 801b7cc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801b7ce:	781b      	ldrb	r3, [r3, #0]
 801b7d0:	2b00      	cmp	r3, #0
 801b7d2:	d1f4      	bne.n	801b7be <ppp_vslprintf+0x26>
	    ;
	if (f > fmt) {
 801b7d4:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801b7d6:	687b      	ldr	r3, [r7, #4]
 801b7d8:	429a      	cmp	r2, r3
 801b7da:	d919      	bls.n	801b810 <ppp_vslprintf+0x78>
	    len = f - fmt;
 801b7dc:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801b7de:	687b      	ldr	r3, [r7, #4]
 801b7e0:	1ad3      	subs	r3, r2, r3
 801b7e2:	657b      	str	r3, [r7, #84]	; 0x54
	    if (len > buflen)
 801b7e4:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801b7e6:	68bb      	ldr	r3, [r7, #8]
 801b7e8:	429a      	cmp	r2, r3
 801b7ea:	dd01      	ble.n	801b7f0 <ppp_vslprintf+0x58>
		len = buflen;
 801b7ec:	68bb      	ldr	r3, [r7, #8]
 801b7ee:	657b      	str	r3, [r7, #84]	; 0x54
	    memcpy(buf, fmt, len);
 801b7f0:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801b7f2:	6879      	ldr	r1, [r7, #4]
 801b7f4:	68fb      	ldr	r3, [r7, #12]
 801b7f6:	0018      	movs	r0, r3
 801b7f8:	f002 fbd0 	bl	801df9c <memcpy>
	    buf += len;
 801b7fc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801b7fe:	68fa      	ldr	r2, [r7, #12]
 801b800:	18d3      	adds	r3, r2, r3
 801b802:	60fb      	str	r3, [r7, #12]
	    buflen -= len;
 801b804:	68ba      	ldr	r2, [r7, #8]
 801b806:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801b808:	1ad3      	subs	r3, r2, r3
 801b80a:	60bb      	str	r3, [r7, #8]
	    fmt = f;
 801b80c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801b80e:	607b      	str	r3, [r7, #4]
	}
	if (*fmt == 0)
 801b810:	687b      	ldr	r3, [r7, #4]
 801b812:	781b      	ldrb	r3, [r3, #0]
 801b814:	2b00      	cmp	r3, #0
 801b816:	d101      	bne.n	801b81c <ppp_vslprintf+0x84>
 801b818:	f000 fb5e 	bl	801bed8 <ppp_vslprintf+0x740>
	    break;
	c = *++fmt;
 801b81c:	687b      	ldr	r3, [r7, #4]
 801b81e:	3301      	adds	r3, #1
 801b820:	607b      	str	r3, [r7, #4]
 801b822:	687b      	ldr	r3, [r7, #4]
 801b824:	781b      	ldrb	r3, [r3, #0]
 801b826:	66fb      	str	r3, [r7, #108]	; 0x6c
	width = 0;
 801b828:	2300      	movs	r3, #0
 801b82a:	667b      	str	r3, [r7, #100]	; 0x64
	prec = -1;
 801b82c:	2301      	movs	r3, #1
 801b82e:	425b      	negs	r3, r3
 801b830:	663b      	str	r3, [r7, #96]	; 0x60
	fillch = ' ';
 801b832:	2320      	movs	r3, #32
 801b834:	65fb      	str	r3, [r7, #92]	; 0x5c
	if (c == '0') {
 801b836:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b838:	2b30      	cmp	r3, #48	; 0x30
 801b83a:	d107      	bne.n	801b84c <ppp_vslprintf+0xb4>
	    fillch = '0';
 801b83c:	2330      	movs	r3, #48	; 0x30
 801b83e:	65fb      	str	r3, [r7, #92]	; 0x5c
	    c = *++fmt;
 801b840:	687b      	ldr	r3, [r7, #4]
 801b842:	3301      	adds	r3, #1
 801b844:	607b      	str	r3, [r7, #4]
 801b846:	687b      	ldr	r3, [r7, #4]
 801b848:	781b      	ldrb	r3, [r3, #0]
 801b84a:	66fb      	str	r3, [r7, #108]	; 0x6c
	}
	if (c == '*') {
 801b84c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b84e:	2b2a      	cmp	r3, #42	; 0x2a
 801b850:	d11b      	bne.n	801b88a <ppp_vslprintf+0xf2>
	    width = va_arg(args, int);
 801b852:	683b      	ldr	r3, [r7, #0]
 801b854:	1d1a      	adds	r2, r3, #4
 801b856:	603a      	str	r2, [r7, #0]
 801b858:	681b      	ldr	r3, [r3, #0]
 801b85a:	667b      	str	r3, [r7, #100]	; 0x64
	    c = *++fmt;
 801b85c:	687b      	ldr	r3, [r7, #4]
 801b85e:	3301      	adds	r3, #1
 801b860:	607b      	str	r3, [r7, #4]
 801b862:	687b      	ldr	r3, [r7, #4]
 801b864:	781b      	ldrb	r3, [r3, #0]
 801b866:	66fb      	str	r3, [r7, #108]	; 0x6c
 801b868:	e019      	b.n	801b89e <ppp_vslprintf+0x106>
	} else {
	    while (lwip_isdigit(c)) {
		width = width * 10 + c - '0';
 801b86a:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 801b86c:	0013      	movs	r3, r2
 801b86e:	009b      	lsls	r3, r3, #2
 801b870:	189b      	adds	r3, r3, r2
 801b872:	005b      	lsls	r3, r3, #1
 801b874:	001a      	movs	r2, r3
 801b876:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b878:	18d3      	adds	r3, r2, r3
 801b87a:	3b30      	subs	r3, #48	; 0x30
 801b87c:	667b      	str	r3, [r7, #100]	; 0x64
		c = *++fmt;
 801b87e:	687b      	ldr	r3, [r7, #4]
 801b880:	3301      	adds	r3, #1
 801b882:	607b      	str	r3, [r7, #4]
 801b884:	687b      	ldr	r3, [r7, #4]
 801b886:	781b      	ldrb	r3, [r3, #0]
 801b888:	66fb      	str	r3, [r7, #108]	; 0x6c
	    while (lwip_isdigit(c)) {
 801b88a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b88c:	b2db      	uxtb	r3, r3
 801b88e:	1c5a      	adds	r2, r3, #1
 801b890:	4bcf      	ldr	r3, [pc, #828]	; (801bbd0 <ppp_vslprintf+0x438>)
 801b892:	18d3      	adds	r3, r2, r3
 801b894:	781b      	ldrb	r3, [r3, #0]
 801b896:	001a      	movs	r2, r3
 801b898:	2304      	movs	r3, #4
 801b89a:	4013      	ands	r3, r2
 801b89c:	d1e5      	bne.n	801b86a <ppp_vslprintf+0xd2>
	    }
	}
	if (c == '.') {
 801b89e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b8a0:	2b2e      	cmp	r3, #46	; 0x2e
 801b8a2:	d131      	bne.n	801b908 <ppp_vslprintf+0x170>
	    c = *++fmt;
 801b8a4:	687b      	ldr	r3, [r7, #4]
 801b8a6:	3301      	adds	r3, #1
 801b8a8:	607b      	str	r3, [r7, #4]
 801b8aa:	687b      	ldr	r3, [r7, #4]
 801b8ac:	781b      	ldrb	r3, [r3, #0]
 801b8ae:	66fb      	str	r3, [r7, #108]	; 0x6c
	    if (c == '*') {
 801b8b0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b8b2:	2b2a      	cmp	r3, #42	; 0x2a
 801b8b4:	d10b      	bne.n	801b8ce <ppp_vslprintf+0x136>
		prec = va_arg(args, int);
 801b8b6:	683b      	ldr	r3, [r7, #0]
 801b8b8:	1d1a      	adds	r2, r3, #4
 801b8ba:	603a      	str	r2, [r7, #0]
 801b8bc:	681b      	ldr	r3, [r3, #0]
 801b8be:	663b      	str	r3, [r7, #96]	; 0x60
		c = *++fmt;
 801b8c0:	687b      	ldr	r3, [r7, #4]
 801b8c2:	3301      	adds	r3, #1
 801b8c4:	607b      	str	r3, [r7, #4]
 801b8c6:	687b      	ldr	r3, [r7, #4]
 801b8c8:	781b      	ldrb	r3, [r3, #0]
 801b8ca:	66fb      	str	r3, [r7, #108]	; 0x6c
 801b8cc:	e01c      	b.n	801b908 <ppp_vslprintf+0x170>
	    } else {
		prec = 0;
 801b8ce:	2300      	movs	r3, #0
 801b8d0:	663b      	str	r3, [r7, #96]	; 0x60
		while (lwip_isdigit(c)) {
 801b8d2:	e00f      	b.n	801b8f4 <ppp_vslprintf+0x15c>
		    prec = prec * 10 + c - '0';
 801b8d4:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 801b8d6:	0013      	movs	r3, r2
 801b8d8:	009b      	lsls	r3, r3, #2
 801b8da:	189b      	adds	r3, r3, r2
 801b8dc:	005b      	lsls	r3, r3, #1
 801b8de:	001a      	movs	r2, r3
 801b8e0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b8e2:	18d3      	adds	r3, r2, r3
 801b8e4:	3b30      	subs	r3, #48	; 0x30
 801b8e6:	663b      	str	r3, [r7, #96]	; 0x60
		    c = *++fmt;
 801b8e8:	687b      	ldr	r3, [r7, #4]
 801b8ea:	3301      	adds	r3, #1
 801b8ec:	607b      	str	r3, [r7, #4]
 801b8ee:	687b      	ldr	r3, [r7, #4]
 801b8f0:	781b      	ldrb	r3, [r3, #0]
 801b8f2:	66fb      	str	r3, [r7, #108]	; 0x6c
		while (lwip_isdigit(c)) {
 801b8f4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b8f6:	b2db      	uxtb	r3, r3
 801b8f8:	1c5a      	adds	r2, r3, #1
 801b8fa:	4bb5      	ldr	r3, [pc, #724]	; (801bbd0 <ppp_vslprintf+0x438>)
 801b8fc:	18d3      	adds	r3, r2, r3
 801b8fe:	781b      	ldrb	r3, [r3, #0]
 801b900:	001a      	movs	r2, r3
 801b902:	2304      	movs	r3, #4
 801b904:	4013      	ands	r3, r2
 801b906:	d1e5      	bne.n	801b8d4 <ppp_vslprintf+0x13c>
		}
	    }
	}
	str = 0;
 801b908:	2300      	movs	r3, #0
 801b90a:	647b      	str	r3, [r7, #68]	; 0x44
	base = 0;
 801b90c:	2300      	movs	r3, #0
 801b90e:	65bb      	str	r3, [r7, #88]	; 0x58
	neg = 0;
 801b910:	2300      	movs	r3, #0
 801b912:	653b      	str	r3, [r7, #80]	; 0x50
	++fmt;
 801b914:	687b      	ldr	r3, [r7, #4]
 801b916:	3301      	adds	r3, #1
 801b918:	607b      	str	r3, [r7, #4]
 801b91a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b91c:	3b42      	subs	r3, #66	; 0x42
 801b91e:	2b36      	cmp	r3, #54	; 0x36
 801b920:	d900      	bls.n	801b924 <ppp_vslprintf+0x18c>
 801b922:	e229      	b.n	801bd78 <ppp_vslprintf+0x5e0>
 801b924:	009a      	lsls	r2, r3, #2
 801b926:	4bab      	ldr	r3, [pc, #684]	; (801bbd4 <ppp_vslprintf+0x43c>)
 801b928:	18d3      	adds	r3, r2, r3
 801b92a:	681b      	ldr	r3, [r3, #0]
 801b92c:	469f      	mov	pc, r3
	switch (c) {
	case 'l':
	    c = *fmt++;
 801b92e:	687b      	ldr	r3, [r7, #4]
 801b930:	1c5a      	adds	r2, r3, #1
 801b932:	607a      	str	r2, [r7, #4]
 801b934:	781b      	ldrb	r3, [r3, #0]
 801b936:	66fb      	str	r3, [r7, #108]	; 0x6c
 801b938:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b93a:	2b64      	cmp	r3, #100	; 0x64
 801b93c:	d003      	beq.n	801b946 <ppp_vslprintf+0x1ae>
 801b93e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801b940:	2b75      	cmp	r3, #117	; 0x75
 801b942:	d010      	beq.n	801b966 <ppp_vslprintf+0x1ce>
 801b944:	e017      	b.n	801b976 <ppp_vslprintf+0x1de>
	    switch (c) {
	    case 'd':
		val = va_arg(args, long);
 801b946:	683b      	ldr	r3, [r7, #0]
 801b948:	1d1a      	adds	r2, r3, #4
 801b94a:	603a      	str	r2, [r7, #0]
 801b94c:	681b      	ldr	r3, [r3, #0]
 801b94e:	64fb      	str	r3, [r7, #76]	; 0x4c
		if ((long)val < 0) {
 801b950:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b952:	2b00      	cmp	r3, #0
 801b954:	da04      	bge.n	801b960 <ppp_vslprintf+0x1c8>
		    neg = 1;
 801b956:	2301      	movs	r3, #1
 801b958:	653b      	str	r3, [r7, #80]	; 0x50
		    val = (unsigned long)-(long)val;
 801b95a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b95c:	425b      	negs	r3, r3
 801b95e:	64fb      	str	r3, [r7, #76]	; 0x4c
		}
		base = 10;
 801b960:	230a      	movs	r3, #10
 801b962:	65bb      	str	r3, [r7, #88]	; 0x58
		break;
 801b964:	e021      	b.n	801b9aa <ppp_vslprintf+0x212>
	    case 'u':
		val = va_arg(args, unsigned long);
 801b966:	683b      	ldr	r3, [r7, #0]
 801b968:	1d1a      	adds	r2, r3, #4
 801b96a:	603a      	str	r2, [r7, #0]
 801b96c:	681b      	ldr	r3, [r3, #0]
 801b96e:	64fb      	str	r3, [r7, #76]	; 0x4c
		base = 10;
 801b970:	230a      	movs	r3, #10
 801b972:	65bb      	str	r3, [r7, #88]	; 0x58
		break;
 801b974:	e019      	b.n	801b9aa <ppp_vslprintf+0x212>
	    default:
		OUTCHAR('%');
 801b976:	68bb      	ldr	r3, [r7, #8]
 801b978:	2b00      	cmp	r3, #0
 801b97a:	dd07      	ble.n	801b98c <ppp_vslprintf+0x1f4>
 801b97c:	68bb      	ldr	r3, [r7, #8]
 801b97e:	3b01      	subs	r3, #1
 801b980:	60bb      	str	r3, [r7, #8]
 801b982:	68fb      	ldr	r3, [r7, #12]
 801b984:	1c5a      	adds	r2, r3, #1
 801b986:	60fa      	str	r2, [r7, #12]
 801b988:	2225      	movs	r2, #37	; 0x25
 801b98a:	701a      	strb	r2, [r3, #0]
		OUTCHAR('l');
 801b98c:	68bb      	ldr	r3, [r7, #8]
 801b98e:	2b00      	cmp	r3, #0
 801b990:	dd07      	ble.n	801b9a2 <ppp_vslprintf+0x20a>
 801b992:	68bb      	ldr	r3, [r7, #8]
 801b994:	3b01      	subs	r3, #1
 801b996:	60bb      	str	r3, [r7, #8]
 801b998:	68fb      	ldr	r3, [r7, #12]
 801b99a:	1c5a      	adds	r2, r3, #1
 801b99c:	60fa      	str	r2, [r7, #12]
 801b99e:	226c      	movs	r2, #108	; 0x6c
 801b9a0:	701a      	strb	r2, [r3, #0]
		--fmt;		/* so %lz outputs %lz etc. */
 801b9a2:	687b      	ldr	r3, [r7, #4]
 801b9a4:	3b01      	subs	r3, #1
 801b9a6:	607b      	str	r3, [r7, #4]
		continue;
 801b9a8:	e291      	b.n	801bece <ppp_vslprintf+0x736>
	    }
	    break;
 801b9aa:	e1f4      	b.n	801bd96 <ppp_vslprintf+0x5fe>
	case 'd':
	    i = va_arg(args, int);
 801b9ac:	683b      	ldr	r3, [r7, #0]
 801b9ae:	1d1a      	adds	r2, r3, #4
 801b9b0:	603a      	str	r2, [r7, #0]
 801b9b2:	681b      	ldr	r3, [r3, #0]
 801b9b4:	637b      	str	r3, [r7, #52]	; 0x34
	    if (i < 0) {
 801b9b6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b9b8:	2b00      	cmp	r3, #0
 801b9ba:	da05      	bge.n	801b9c8 <ppp_vslprintf+0x230>
		neg = 1;
 801b9bc:	2301      	movs	r3, #1
 801b9be:	653b      	str	r3, [r7, #80]	; 0x50
		val = -i;
 801b9c0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b9c2:	425b      	negs	r3, r3
 801b9c4:	64fb      	str	r3, [r7, #76]	; 0x4c
 801b9c6:	e001      	b.n	801b9cc <ppp_vslprintf+0x234>
	    } else
		val = i;
 801b9c8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b9ca:	64fb      	str	r3, [r7, #76]	; 0x4c
	    base = 10;
 801b9cc:	230a      	movs	r3, #10
 801b9ce:	65bb      	str	r3, [r7, #88]	; 0x58
	    break;
 801b9d0:	e1e1      	b.n	801bd96 <ppp_vslprintf+0x5fe>
	case 'u':
	    val = va_arg(args, unsigned int);
 801b9d2:	683b      	ldr	r3, [r7, #0]
 801b9d4:	1d1a      	adds	r2, r3, #4
 801b9d6:	603a      	str	r2, [r7, #0]
 801b9d8:	681b      	ldr	r3, [r3, #0]
 801b9da:	64fb      	str	r3, [r7, #76]	; 0x4c
	    base = 10;
 801b9dc:	230a      	movs	r3, #10
 801b9de:	65bb      	str	r3, [r7, #88]	; 0x58
	    break;
 801b9e0:	e1d9      	b.n	801bd96 <ppp_vslprintf+0x5fe>
	case 'o':
	    val = va_arg(args, unsigned int);
 801b9e2:	683b      	ldr	r3, [r7, #0]
 801b9e4:	1d1a      	adds	r2, r3, #4
 801b9e6:	603a      	str	r2, [r7, #0]
 801b9e8:	681b      	ldr	r3, [r3, #0]
 801b9ea:	64fb      	str	r3, [r7, #76]	; 0x4c
	    base = 8;
 801b9ec:	2308      	movs	r3, #8
 801b9ee:	65bb      	str	r3, [r7, #88]	; 0x58
	    break;
 801b9f0:	e1d1      	b.n	801bd96 <ppp_vslprintf+0x5fe>
	case 'x':
	case 'X':
	    val = va_arg(args, unsigned int);
 801b9f2:	683b      	ldr	r3, [r7, #0]
 801b9f4:	1d1a      	adds	r2, r3, #4
 801b9f6:	603a      	str	r2, [r7, #0]
 801b9f8:	681b      	ldr	r3, [r3, #0]
 801b9fa:	64fb      	str	r3, [r7, #76]	; 0x4c
	    base = 16;
 801b9fc:	2310      	movs	r3, #16
 801b9fe:	65bb      	str	r3, [r7, #88]	; 0x58
	    break;
 801ba00:	e1c9      	b.n	801bd96 <ppp_vslprintf+0x5fe>
	    base = 16;
	    neg = 2;
	    break;
#endif /* unused (and wrong on LLP64 systems) */
	case 's':
	    str = va_arg(args, char *);
 801ba02:	683b      	ldr	r3, [r7, #0]
 801ba04:	1d1a      	adds	r2, r3, #4
 801ba06:	603a      	str	r2, [r7, #0]
 801ba08:	681b      	ldr	r3, [r3, #0]
 801ba0a:	647b      	str	r3, [r7, #68]	; 0x44
	    break;
 801ba0c:	e1c3      	b.n	801bd96 <ppp_vslprintf+0x5fe>
	case 'c':
	    num[0] = va_arg(args, int);
 801ba0e:	683b      	ldr	r3, [r7, #0]
 801ba10:	1d1a      	adds	r2, r3, #4
 801ba12:	603a      	str	r2, [r7, #0]
 801ba14:	681b      	ldr	r3, [r3, #0]
 801ba16:	b2da      	uxtb	r2, r3
 801ba18:	2110      	movs	r1, #16
 801ba1a:	187b      	adds	r3, r7, r1
 801ba1c:	701a      	strb	r2, [r3, #0]
	    num[1] = 0;
 801ba1e:	187b      	adds	r3, r7, r1
 801ba20:	2200      	movs	r2, #0
 801ba22:	705a      	strb	r2, [r3, #1]
	    str = num;
 801ba24:	187b      	adds	r3, r7, r1
 801ba26:	647b      	str	r3, [r7, #68]	; 0x44
	    break;
 801ba28:	e1b5      	b.n	801bd96 <ppp_vslprintf+0x5fe>
	case 'm':
	    str = strerror(errno);
	    break;
#endif /* do we always have strerror() in embedded ? */
	case 'I':
	    ip = va_arg(args, u32_t);
 801ba2a:	683b      	ldr	r3, [r7, #0]
 801ba2c:	1d1a      	adds	r2, r3, #4
 801ba2e:	603a      	str	r2, [r7, #0]
 801ba30:	681b      	ldr	r3, [r3, #0]
 801ba32:	633b      	str	r3, [r7, #48]	; 0x30
	    ip = lwip_ntohl(ip);
 801ba34:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ba36:	0018      	movs	r0, r3
 801ba38:	f7eb fcf8 	bl	800742c <lwip_htonl>
 801ba3c:	0003      	movs	r3, r0
 801ba3e:	633b      	str	r3, [r7, #48]	; 0x30
	    ppp_slprintf(num, sizeof(num), "%d.%d.%d.%d", (ip >> 24) & 0xff,
 801ba40:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ba42:	0e1d      	lsrs	r5, r3, #24
		     (ip >> 16) & 0xff, (ip >> 8) & 0xff, ip & 0xff);
 801ba44:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ba46:	0c1b      	lsrs	r3, r3, #16
	    ppp_slprintf(num, sizeof(num), "%d.%d.%d.%d", (ip >> 24) & 0xff,
 801ba48:	22ff      	movs	r2, #255	; 0xff
 801ba4a:	4013      	ands	r3, r2
		     (ip >> 16) & 0xff, (ip >> 8) & 0xff, ip & 0xff);
 801ba4c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801ba4e:	0a12      	lsrs	r2, r2, #8
	    ppp_slprintf(num, sizeof(num), "%d.%d.%d.%d", (ip >> 24) & 0xff,
 801ba50:	21ff      	movs	r1, #255	; 0xff
 801ba52:	400a      	ands	r2, r1
 801ba54:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801ba56:	20ff      	movs	r0, #255	; 0xff
 801ba58:	4001      	ands	r1, r0
 801ba5a:	4c5f      	ldr	r4, [pc, #380]	; (801bbd8 <ppp_vslprintf+0x440>)
 801ba5c:	2610      	movs	r6, #16
 801ba5e:	19b8      	adds	r0, r7, r6
 801ba60:	9102      	str	r1, [sp, #8]
 801ba62:	9201      	str	r2, [sp, #4]
 801ba64:	9300      	str	r3, [sp, #0]
 801ba66:	002b      	movs	r3, r5
 801ba68:	0022      	movs	r2, r4
 801ba6a:	2120      	movs	r1, #32
 801ba6c:	f7ff fe7a 	bl	801b764 <ppp_slprintf>
	    str = num;
 801ba70:	19bb      	adds	r3, r7, r6
 801ba72:	647b      	str	r3, [r7, #68]	; 0x44
	    break;
 801ba74:	e18f      	b.n	801bd96 <ppp_vslprintf+0x5fe>
	    str[15] = 0;	/* chop off year and newline */
	    break;
#endif /* need port */
	case 'v':		/* "visible" string */
	case 'q':		/* quoted string */
	    quoted = c == 'q';
 801ba76:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801ba78:	3b71      	subs	r3, #113	; 0x71
 801ba7a:	425a      	negs	r2, r3
 801ba7c:	4153      	adcs	r3, r2
 801ba7e:	b2db      	uxtb	r3, r3
 801ba80:	63bb      	str	r3, [r7, #56]	; 0x38
	    p = va_arg(args, unsigned char *);
 801ba82:	683b      	ldr	r3, [r7, #0]
 801ba84:	1d1a      	adds	r2, r3, #4
 801ba86:	603a      	str	r2, [r7, #0]
 801ba88:	681b      	ldr	r3, [r3, #0]
 801ba8a:	643b      	str	r3, [r7, #64]	; 0x40
	    if (p == NULL)
 801ba8c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801ba8e:	2b00      	cmp	r3, #0
 801ba90:	d101      	bne.n	801ba96 <ppp_vslprintf+0x2fe>
		p = (const unsigned char *)"<NULL>";
 801ba92:	4b52      	ldr	r3, [pc, #328]	; (801bbdc <ppp_vslprintf+0x444>)
 801ba94:	643b      	str	r3, [r7, #64]	; 0x40
	    if (fillch == '0' && prec >= 0) {
 801ba96:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801ba98:	2b30      	cmp	r3, #48	; 0x30
 801ba9a:	d105      	bne.n	801baa8 <ppp_vslprintf+0x310>
 801ba9c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801ba9e:	2b00      	cmp	r3, #0
 801baa0:	db02      	blt.n	801baa8 <ppp_vslprintf+0x310>
		n = prec;
 801baa2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801baa4:	66bb      	str	r3, [r7, #104]	; 0x68
 801baa6:	e010      	b.n	801baca <ppp_vslprintf+0x332>
	    } else {
		n = strlen((const char *)p);
 801baa8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801baaa:	0018      	movs	r0, r3
 801baac:	f7e4 fb36 	bl	800011c <strlen>
 801bab0:	0003      	movs	r3, r0
 801bab2:	66bb      	str	r3, [r7, #104]	; 0x68
		if (prec >= 0 && n > prec)
 801bab4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801bab6:	2b00      	cmp	r3, #0
 801bab8:	da00      	bge.n	801babc <ppp_vslprintf+0x324>
 801baba:	e113      	b.n	801bce4 <ppp_vslprintf+0x54c>
 801babc:	6eba      	ldr	r2, [r7, #104]	; 0x68
 801babe:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801bac0:	429a      	cmp	r2, r3
 801bac2:	dc00      	bgt.n	801bac6 <ppp_vslprintf+0x32e>
 801bac4:	e10e      	b.n	801bce4 <ppp_vslprintf+0x54c>
		    n = prec;
 801bac6:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801bac8:	66bb      	str	r3, [r7, #104]	; 0x68
	    }
	    while (n > 0 && buflen > 0) {
 801baca:	e10b      	b.n	801bce4 <ppp_vslprintf+0x54c>
		c = *p++;
 801bacc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bace:	1c5a      	adds	r2, r3, #1
 801bad0:	643a      	str	r2, [r7, #64]	; 0x40
 801bad2:	781b      	ldrb	r3, [r3, #0]
 801bad4:	66fb      	str	r3, [r7, #108]	; 0x6c
		--n;
 801bad6:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801bad8:	3b01      	subs	r3, #1
 801bada:	66bb      	str	r3, [r7, #104]	; 0x68
		if (!quoted && c >= 0x80) {
 801badc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801bade:	2b00      	cmp	r3, #0
 801bae0:	d11b      	bne.n	801bb1a <ppp_vslprintf+0x382>
 801bae2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801bae4:	2b7f      	cmp	r3, #127	; 0x7f
 801bae6:	dd18      	ble.n	801bb1a <ppp_vslprintf+0x382>
		    OUTCHAR('M');
 801bae8:	68bb      	ldr	r3, [r7, #8]
 801baea:	2b00      	cmp	r3, #0
 801baec:	dd07      	ble.n	801bafe <ppp_vslprintf+0x366>
 801baee:	68bb      	ldr	r3, [r7, #8]
 801baf0:	3b01      	subs	r3, #1
 801baf2:	60bb      	str	r3, [r7, #8]
 801baf4:	68fb      	ldr	r3, [r7, #12]
 801baf6:	1c5a      	adds	r2, r3, #1
 801baf8:	60fa      	str	r2, [r7, #12]
 801bafa:	224d      	movs	r2, #77	; 0x4d
 801bafc:	701a      	strb	r2, [r3, #0]
		    OUTCHAR('-');
 801bafe:	68bb      	ldr	r3, [r7, #8]
 801bb00:	2b00      	cmp	r3, #0
 801bb02:	dd07      	ble.n	801bb14 <ppp_vslprintf+0x37c>
 801bb04:	68bb      	ldr	r3, [r7, #8]
 801bb06:	3b01      	subs	r3, #1
 801bb08:	60bb      	str	r3, [r7, #8]
 801bb0a:	68fb      	ldr	r3, [r7, #12]
 801bb0c:	1c5a      	adds	r2, r3, #1
 801bb0e:	60fa      	str	r2, [r7, #12]
 801bb10:	222d      	movs	r2, #45	; 0x2d
 801bb12:	701a      	strb	r2, [r3, #0]
		    c -= 0x80;
 801bb14:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801bb16:	3b80      	subs	r3, #128	; 0x80
 801bb18:	66fb      	str	r3, [r7, #108]	; 0x6c
		}
		if (quoted && (c == '"' || c == '\\'))
 801bb1a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801bb1c:	2b00      	cmp	r3, #0
 801bb1e:	d010      	beq.n	801bb42 <ppp_vslprintf+0x3aa>
 801bb20:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801bb22:	2b22      	cmp	r3, #34	; 0x22
 801bb24:	d002      	beq.n	801bb2c <ppp_vslprintf+0x394>
 801bb26:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801bb28:	2b5c      	cmp	r3, #92	; 0x5c
 801bb2a:	d10a      	bne.n	801bb42 <ppp_vslprintf+0x3aa>
		    OUTCHAR('\\');
 801bb2c:	68bb      	ldr	r3, [r7, #8]
 801bb2e:	2b00      	cmp	r3, #0
 801bb30:	dd07      	ble.n	801bb42 <ppp_vslprintf+0x3aa>
 801bb32:	68bb      	ldr	r3, [r7, #8]
 801bb34:	3b01      	subs	r3, #1
 801bb36:	60bb      	str	r3, [r7, #8]
 801bb38:	68fb      	ldr	r3, [r7, #12]
 801bb3a:	1c5a      	adds	r2, r3, #1
 801bb3c:	60fa      	str	r2, [r7, #12]
 801bb3e:	225c      	movs	r2, #92	; 0x5c
 801bb40:	701a      	strb	r2, [r3, #0]
		if (c < 0x20 || (0x7f <= c && c < 0xa0)) {
 801bb42:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801bb44:	2b1f      	cmp	r3, #31
 801bb46:	dd07      	ble.n	801bb58 <ppp_vslprintf+0x3c0>
 801bb48:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801bb4a:	2b7e      	cmp	r3, #126	; 0x7e
 801bb4c:	dc00      	bgt.n	801bb50 <ppp_vslprintf+0x3b8>
 801bb4e:	e0bd      	b.n	801bccc <ppp_vslprintf+0x534>
 801bb50:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801bb52:	2b9f      	cmp	r3, #159	; 0x9f
 801bb54:	dd00      	ble.n	801bb58 <ppp_vslprintf+0x3c0>
 801bb56:	e0b9      	b.n	801bccc <ppp_vslprintf+0x534>
		    if (quoted) {
 801bb58:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801bb5a:	2b00      	cmp	r3, #0
 801bb5c:	d100      	bne.n	801bb60 <ppp_vslprintf+0x3c8>
 801bb5e:	e081      	b.n	801bc64 <ppp_vslprintf+0x4cc>
			OUTCHAR('\\');
 801bb60:	68bb      	ldr	r3, [r7, #8]
 801bb62:	2b00      	cmp	r3, #0
 801bb64:	dd07      	ble.n	801bb76 <ppp_vslprintf+0x3de>
 801bb66:	68bb      	ldr	r3, [r7, #8]
 801bb68:	3b01      	subs	r3, #1
 801bb6a:	60bb      	str	r3, [r7, #8]
 801bb6c:	68fb      	ldr	r3, [r7, #12]
 801bb6e:	1c5a      	adds	r2, r3, #1
 801bb70:	60fa      	str	r2, [r7, #12]
 801bb72:	225c      	movs	r2, #92	; 0x5c
 801bb74:	701a      	strb	r2, [r3, #0]
 801bb76:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801bb78:	2b0c      	cmp	r3, #12
 801bb7a:	d03e      	beq.n	801bbfa <ppp_vslprintf+0x462>
 801bb7c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801bb7e:	2b0c      	cmp	r3, #12
 801bb80:	dc47      	bgt.n	801bc12 <ppp_vslprintf+0x47a>
 801bb82:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801bb84:	2b0a      	cmp	r3, #10
 801bb86:	d015      	beq.n	801bbb4 <ppp_vslprintf+0x41c>
 801bb88:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801bb8a:	2b0a      	cmp	r3, #10
 801bb8c:	dc41      	bgt.n	801bc12 <ppp_vslprintf+0x47a>
 801bb8e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801bb90:	2b08      	cmp	r3, #8
 801bb92:	d025      	beq.n	801bbe0 <ppp_vslprintf+0x448>
 801bb94:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801bb96:	2b09      	cmp	r3, #9
 801bb98:	d13b      	bne.n	801bc12 <ppp_vslprintf+0x47a>
			switch (c) {
			case '\t':	OUTCHAR('t');	break;
 801bb9a:	68bb      	ldr	r3, [r7, #8]
 801bb9c:	2b00      	cmp	r3, #0
 801bb9e:	dc00      	bgt.n	801bba2 <ppp_vslprintf+0x40a>
 801bba0:	e08c      	b.n	801bcbc <ppp_vslprintf+0x524>
 801bba2:	68bb      	ldr	r3, [r7, #8]
 801bba4:	3b01      	subs	r3, #1
 801bba6:	60bb      	str	r3, [r7, #8]
 801bba8:	68fb      	ldr	r3, [r7, #12]
 801bbaa:	1c5a      	adds	r2, r3, #1
 801bbac:	60fa      	str	r2, [r7, #12]
 801bbae:	2274      	movs	r2, #116	; 0x74
 801bbb0:	701a      	strb	r2, [r3, #0]
 801bbb2:	e083      	b.n	801bcbc <ppp_vslprintf+0x524>
			case '\n':	OUTCHAR('n');	break;
 801bbb4:	68bb      	ldr	r3, [r7, #8]
 801bbb6:	2b00      	cmp	r3, #0
 801bbb8:	dc00      	bgt.n	801bbbc <ppp_vslprintf+0x424>
 801bbba:	e081      	b.n	801bcc0 <ppp_vslprintf+0x528>
 801bbbc:	68bb      	ldr	r3, [r7, #8]
 801bbbe:	3b01      	subs	r3, #1
 801bbc0:	60bb      	str	r3, [r7, #8]
 801bbc2:	68fb      	ldr	r3, [r7, #12]
 801bbc4:	1c5a      	adds	r2, r3, #1
 801bbc6:	60fa      	str	r2, [r7, #12]
 801bbc8:	226e      	movs	r2, #110	; 0x6e
 801bbca:	701a      	strb	r2, [r3, #0]
 801bbcc:	e078      	b.n	801bcc0 <ppp_vslprintf+0x528>
 801bbce:	46c0      	nop			; (mov r8, r8)
 801bbd0:	08024088 	.word	0x08024088
 801bbd4:	08023f4c 	.word	0x08023f4c
 801bbd8:	08022c08 	.word	0x08022c08
 801bbdc:	08022c14 	.word	0x08022c14
			case '\b':	OUTCHAR('b');	break;
 801bbe0:	68bb      	ldr	r3, [r7, #8]
 801bbe2:	2b00      	cmp	r3, #0
 801bbe4:	dc00      	bgt.n	801bbe8 <ppp_vslprintf+0x450>
 801bbe6:	e06d      	b.n	801bcc4 <ppp_vslprintf+0x52c>
 801bbe8:	68bb      	ldr	r3, [r7, #8]
 801bbea:	3b01      	subs	r3, #1
 801bbec:	60bb      	str	r3, [r7, #8]
 801bbee:	68fb      	ldr	r3, [r7, #12]
 801bbf0:	1c5a      	adds	r2, r3, #1
 801bbf2:	60fa      	str	r2, [r7, #12]
 801bbf4:	2262      	movs	r2, #98	; 0x62
 801bbf6:	701a      	strb	r2, [r3, #0]
 801bbf8:	e064      	b.n	801bcc4 <ppp_vslprintf+0x52c>
			case '\f':	OUTCHAR('f');	break;
 801bbfa:	68bb      	ldr	r3, [r7, #8]
 801bbfc:	2b00      	cmp	r3, #0
 801bbfe:	dd63      	ble.n	801bcc8 <ppp_vslprintf+0x530>
 801bc00:	68bb      	ldr	r3, [r7, #8]
 801bc02:	3b01      	subs	r3, #1
 801bc04:	60bb      	str	r3, [r7, #8]
 801bc06:	68fb      	ldr	r3, [r7, #12]
 801bc08:	1c5a      	adds	r2, r3, #1
 801bc0a:	60fa      	str	r2, [r7, #12]
 801bc0c:	2266      	movs	r2, #102	; 0x66
 801bc0e:	701a      	strb	r2, [r3, #0]
 801bc10:	e05a      	b.n	801bcc8 <ppp_vslprintf+0x530>
			default:
			    OUTCHAR('x');
 801bc12:	68bb      	ldr	r3, [r7, #8]
 801bc14:	2b00      	cmp	r3, #0
 801bc16:	dd07      	ble.n	801bc28 <ppp_vslprintf+0x490>
 801bc18:	68bb      	ldr	r3, [r7, #8]
 801bc1a:	3b01      	subs	r3, #1
 801bc1c:	60bb      	str	r3, [r7, #8]
 801bc1e:	68fb      	ldr	r3, [r7, #12]
 801bc20:	1c5a      	adds	r2, r3, #1
 801bc22:	60fa      	str	r2, [r7, #12]
 801bc24:	2278      	movs	r2, #120	; 0x78
 801bc26:	701a      	strb	r2, [r3, #0]
			    OUTCHAR(hexchars[c >> 4]);
 801bc28:	68bb      	ldr	r3, [r7, #8]
 801bc2a:	2b00      	cmp	r3, #0
 801bc2c:	dd0a      	ble.n	801bc44 <ppp_vslprintf+0x4ac>
 801bc2e:	68bb      	ldr	r3, [r7, #8]
 801bc30:	3b01      	subs	r3, #1
 801bc32:	60bb      	str	r3, [r7, #8]
 801bc34:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801bc36:	111a      	asrs	r2, r3, #4
 801bc38:	68fb      	ldr	r3, [r7, #12]
 801bc3a:	1c59      	adds	r1, r3, #1
 801bc3c:	60f9      	str	r1, [r7, #12]
 801bc3e:	49ac      	ldr	r1, [pc, #688]	; (801bef0 <ppp_vslprintf+0x758>)
 801bc40:	5c8a      	ldrb	r2, [r1, r2]
 801bc42:	701a      	strb	r2, [r3, #0]
			    OUTCHAR(hexchars[c & 0xf]);
 801bc44:	68bb      	ldr	r3, [r7, #8]
 801bc46:	2b00      	cmp	r3, #0
 801bc48:	dd4c      	ble.n	801bce4 <ppp_vslprintf+0x54c>
 801bc4a:	68bb      	ldr	r3, [r7, #8]
 801bc4c:	3b01      	subs	r3, #1
 801bc4e:	60bb      	str	r3, [r7, #8]
 801bc50:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801bc52:	220f      	movs	r2, #15
 801bc54:	401a      	ands	r2, r3
 801bc56:	68fb      	ldr	r3, [r7, #12]
 801bc58:	1c59      	adds	r1, r3, #1
 801bc5a:	60f9      	str	r1, [r7, #12]
 801bc5c:	49a4      	ldr	r1, [pc, #656]	; (801bef0 <ppp_vslprintf+0x758>)
 801bc5e:	5c8a      	ldrb	r2, [r1, r2]
 801bc60:	701a      	strb	r2, [r3, #0]
 801bc62:	e03f      	b.n	801bce4 <ppp_vslprintf+0x54c>
			}
		    } else {
			if (c == '\t')
 801bc64:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801bc66:	2b09      	cmp	r3, #9
 801bc68:	d10c      	bne.n	801bc84 <ppp_vslprintf+0x4ec>
			    OUTCHAR(c);
 801bc6a:	68bb      	ldr	r3, [r7, #8]
 801bc6c:	2b00      	cmp	r3, #0
 801bc6e:	dd39      	ble.n	801bce4 <ppp_vslprintf+0x54c>
 801bc70:	68bb      	ldr	r3, [r7, #8]
 801bc72:	3b01      	subs	r3, #1
 801bc74:	60bb      	str	r3, [r7, #8]
 801bc76:	68fb      	ldr	r3, [r7, #12]
 801bc78:	1c5a      	adds	r2, r3, #1
 801bc7a:	60fa      	str	r2, [r7, #12]
 801bc7c:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801bc7e:	b2d2      	uxtb	r2, r2
 801bc80:	701a      	strb	r2, [r3, #0]
 801bc82:	e02f      	b.n	801bce4 <ppp_vslprintf+0x54c>
			else {
			    OUTCHAR('^');
 801bc84:	68bb      	ldr	r3, [r7, #8]
 801bc86:	2b00      	cmp	r3, #0
 801bc88:	dd07      	ble.n	801bc9a <ppp_vslprintf+0x502>
 801bc8a:	68bb      	ldr	r3, [r7, #8]
 801bc8c:	3b01      	subs	r3, #1
 801bc8e:	60bb      	str	r3, [r7, #8]
 801bc90:	68fb      	ldr	r3, [r7, #12]
 801bc92:	1c5a      	adds	r2, r3, #1
 801bc94:	60fa      	str	r2, [r7, #12]
 801bc96:	225e      	movs	r2, #94	; 0x5e
 801bc98:	701a      	strb	r2, [r3, #0]
			    OUTCHAR(c ^ 0x40);
 801bc9a:	68bb      	ldr	r3, [r7, #8]
 801bc9c:	2b00      	cmp	r3, #0
 801bc9e:	dd21      	ble.n	801bce4 <ppp_vslprintf+0x54c>
 801bca0:	68bb      	ldr	r3, [r7, #8]
 801bca2:	3b01      	subs	r3, #1
 801bca4:	60bb      	str	r3, [r7, #8]
 801bca6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801bca8:	b25b      	sxtb	r3, r3
 801bcaa:	2240      	movs	r2, #64	; 0x40
 801bcac:	4053      	eors	r3, r2
 801bcae:	b259      	sxtb	r1, r3
 801bcb0:	68fb      	ldr	r3, [r7, #12]
 801bcb2:	1c5a      	adds	r2, r3, #1
 801bcb4:	60fa      	str	r2, [r7, #12]
 801bcb6:	b2ca      	uxtb	r2, r1
 801bcb8:	701a      	strb	r2, [r3, #0]
 801bcba:	e013      	b.n	801bce4 <ppp_vslprintf+0x54c>
			case '\t':	OUTCHAR('t');	break;
 801bcbc:	46c0      	nop			; (mov r8, r8)
 801bcbe:	e011      	b.n	801bce4 <ppp_vslprintf+0x54c>
			case '\n':	OUTCHAR('n');	break;
 801bcc0:	46c0      	nop			; (mov r8, r8)
 801bcc2:	e00f      	b.n	801bce4 <ppp_vslprintf+0x54c>
			case '\b':	OUTCHAR('b');	break;
 801bcc4:	46c0      	nop			; (mov r8, r8)
 801bcc6:	e00d      	b.n	801bce4 <ppp_vslprintf+0x54c>
			case '\f':	OUTCHAR('f');	break;
 801bcc8:	46c0      	nop			; (mov r8, r8)
		    if (quoted) {
 801bcca:	e00b      	b.n	801bce4 <ppp_vslprintf+0x54c>
			}
		    }
		} else
		    OUTCHAR(c);
 801bccc:	68bb      	ldr	r3, [r7, #8]
 801bcce:	2b00      	cmp	r3, #0
 801bcd0:	dd08      	ble.n	801bce4 <ppp_vslprintf+0x54c>
 801bcd2:	68bb      	ldr	r3, [r7, #8]
 801bcd4:	3b01      	subs	r3, #1
 801bcd6:	60bb      	str	r3, [r7, #8]
 801bcd8:	68fb      	ldr	r3, [r7, #12]
 801bcda:	1c5a      	adds	r2, r3, #1
 801bcdc:	60fa      	str	r2, [r7, #12]
 801bcde:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801bce0:	b2d2      	uxtb	r2, r2
 801bce2:	701a      	strb	r2, [r3, #0]
	    while (n > 0 && buflen > 0) {
 801bce4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801bce6:	2b00      	cmp	r3, #0
 801bce8:	dc00      	bgt.n	801bcec <ppp_vslprintf+0x554>
 801bcea:	e0f0      	b.n	801bece <ppp_vslprintf+0x736>
 801bcec:	68bb      	ldr	r3, [r7, #8]
 801bcee:	2b00      	cmp	r3, #0
 801bcf0:	dd00      	ble.n	801bcf4 <ppp_vslprintf+0x55c>
 801bcf2:	e6eb      	b.n	801bacc <ppp_vslprintf+0x334>
	    }
	    continue;
 801bcf4:	e0eb      	b.n	801bece <ppp_vslprintf+0x736>
	    buf = bufinfo.ptr;
	    buflen = bufinfo.len - 1;
	    continue;
#endif /* PRINTPKT_SUPPORT */
	case 'B':
	    p = va_arg(args, unsigned char *);
 801bcf6:	683b      	ldr	r3, [r7, #0]
 801bcf8:	1d1a      	adds	r2, r3, #4
 801bcfa:	603a      	str	r2, [r7, #0]
 801bcfc:	681b      	ldr	r3, [r3, #0]
 801bcfe:	643b      	str	r3, [r7, #64]	; 0x40
	    for (n = prec; n > 0; --n) {
 801bd00:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801bd02:	66bb      	str	r3, [r7, #104]	; 0x68
 801bd04:	e034      	b.n	801bd70 <ppp_vslprintf+0x5d8>
		c = *p++;
 801bd06:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bd08:	1c5a      	adds	r2, r3, #1
 801bd0a:	643a      	str	r2, [r7, #64]	; 0x40
 801bd0c:	781b      	ldrb	r3, [r3, #0]
 801bd0e:	66fb      	str	r3, [r7, #108]	; 0x6c
		if (fillch == ' ')
 801bd10:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801bd12:	2b20      	cmp	r3, #32
 801bd14:	d10a      	bne.n	801bd2c <ppp_vslprintf+0x594>
		    OUTCHAR(' ');
 801bd16:	68bb      	ldr	r3, [r7, #8]
 801bd18:	2b00      	cmp	r3, #0
 801bd1a:	dd07      	ble.n	801bd2c <ppp_vslprintf+0x594>
 801bd1c:	68bb      	ldr	r3, [r7, #8]
 801bd1e:	3b01      	subs	r3, #1
 801bd20:	60bb      	str	r3, [r7, #8]
 801bd22:	68fb      	ldr	r3, [r7, #12]
 801bd24:	1c5a      	adds	r2, r3, #1
 801bd26:	60fa      	str	r2, [r7, #12]
 801bd28:	2220      	movs	r2, #32
 801bd2a:	701a      	strb	r2, [r3, #0]
		OUTCHAR(hexchars[(c >> 4) & 0xf]);
 801bd2c:	68bb      	ldr	r3, [r7, #8]
 801bd2e:	2b00      	cmp	r3, #0
 801bd30:	dd0c      	ble.n	801bd4c <ppp_vslprintf+0x5b4>
 801bd32:	68bb      	ldr	r3, [r7, #8]
 801bd34:	3b01      	subs	r3, #1
 801bd36:	60bb      	str	r3, [r7, #8]
 801bd38:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801bd3a:	111b      	asrs	r3, r3, #4
 801bd3c:	220f      	movs	r2, #15
 801bd3e:	401a      	ands	r2, r3
 801bd40:	68fb      	ldr	r3, [r7, #12]
 801bd42:	1c59      	adds	r1, r3, #1
 801bd44:	60f9      	str	r1, [r7, #12]
 801bd46:	496a      	ldr	r1, [pc, #424]	; (801bef0 <ppp_vslprintf+0x758>)
 801bd48:	5c8a      	ldrb	r2, [r1, r2]
 801bd4a:	701a      	strb	r2, [r3, #0]
		OUTCHAR(hexchars[c & 0xf]);
 801bd4c:	68bb      	ldr	r3, [r7, #8]
 801bd4e:	2b00      	cmp	r3, #0
 801bd50:	dd0b      	ble.n	801bd6a <ppp_vslprintf+0x5d2>
 801bd52:	68bb      	ldr	r3, [r7, #8]
 801bd54:	3b01      	subs	r3, #1
 801bd56:	60bb      	str	r3, [r7, #8]
 801bd58:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801bd5a:	220f      	movs	r2, #15
 801bd5c:	401a      	ands	r2, r3
 801bd5e:	68fb      	ldr	r3, [r7, #12]
 801bd60:	1c59      	adds	r1, r3, #1
 801bd62:	60f9      	str	r1, [r7, #12]
 801bd64:	4962      	ldr	r1, [pc, #392]	; (801bef0 <ppp_vslprintf+0x758>)
 801bd66:	5c8a      	ldrb	r2, [r1, r2]
 801bd68:	701a      	strb	r2, [r3, #0]
	    for (n = prec; n > 0; --n) {
 801bd6a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801bd6c:	3b01      	subs	r3, #1
 801bd6e:	66bb      	str	r3, [r7, #104]	; 0x68
 801bd70:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801bd72:	2b00      	cmp	r3, #0
 801bd74:	dcc7      	bgt.n	801bd06 <ppp_vslprintf+0x56e>
	    }
	    continue;
 801bd76:	e0aa      	b.n	801bece <ppp_vslprintf+0x736>
	default:
	    *buf++ = '%';
 801bd78:	68fb      	ldr	r3, [r7, #12]
 801bd7a:	1c5a      	adds	r2, r3, #1
 801bd7c:	60fa      	str	r2, [r7, #12]
 801bd7e:	2225      	movs	r2, #37	; 0x25
 801bd80:	701a      	strb	r2, [r3, #0]
	    if (c != '%')
 801bd82:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801bd84:	2b25      	cmp	r3, #37	; 0x25
 801bd86:	d002      	beq.n	801bd8e <ppp_vslprintf+0x5f6>
		--fmt;		/* so %z outputs %z etc. */
 801bd88:	687b      	ldr	r3, [r7, #4]
 801bd8a:	3b01      	subs	r3, #1
 801bd8c:	607b      	str	r3, [r7, #4]
	    --buflen;
 801bd8e:	68bb      	ldr	r3, [r7, #8]
 801bd90:	3b01      	subs	r3, #1
 801bd92:	60bb      	str	r3, [r7, #8]
	    continue;
 801bd94:	e09b      	b.n	801bece <ppp_vslprintf+0x736>
	}
	if (base != 0) {
 801bd96:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801bd98:	2b00      	cmp	r3, #0
 801bd9a:	d054      	beq.n	801be46 <ppp_vslprintf+0x6ae>
	    str = num + sizeof(num);
 801bd9c:	2310      	movs	r3, #16
 801bd9e:	18fb      	adds	r3, r7, r3
 801bda0:	3320      	adds	r3, #32
 801bda2:	647b      	str	r3, [r7, #68]	; 0x44
	    *--str = 0;
 801bda4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801bda6:	3b01      	subs	r3, #1
 801bda8:	647b      	str	r3, [r7, #68]	; 0x44
 801bdaa:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801bdac:	2200      	movs	r2, #0
 801bdae:	701a      	strb	r2, [r3, #0]
	    while (str > num + neg) {
 801bdb0:	e01e      	b.n	801bdf0 <ppp_vslprintf+0x658>
		*--str = hexchars[val % base];
 801bdb2:	6dba      	ldr	r2, [r7, #88]	; 0x58
 801bdb4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bdb6:	0011      	movs	r1, r2
 801bdb8:	0018      	movs	r0, r3
 801bdba:	f7e4 fa47 	bl	800024c <__aeabi_uidivmod>
 801bdbe:	000b      	movs	r3, r1
 801bdc0:	001a      	movs	r2, r3
 801bdc2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801bdc4:	3b01      	subs	r3, #1
 801bdc6:	647b      	str	r3, [r7, #68]	; 0x44
 801bdc8:	4b49      	ldr	r3, [pc, #292]	; (801bef0 <ppp_vslprintf+0x758>)
 801bdca:	5c9a      	ldrb	r2, [r3, r2]
 801bdcc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801bdce:	701a      	strb	r2, [r3, #0]
		val = val / base;
 801bdd0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801bdd2:	0019      	movs	r1, r3
 801bdd4:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 801bdd6:	f7e4 f9b3 	bl	8000140 <__udivsi3>
 801bdda:	0003      	movs	r3, r0
 801bddc:	64fb      	str	r3, [r7, #76]	; 0x4c
		if (--prec <= 0 && val == 0)
 801bdde:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801bde0:	3b01      	subs	r3, #1
 801bde2:	663b      	str	r3, [r7, #96]	; 0x60
 801bde4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801bde6:	2b00      	cmp	r3, #0
 801bde8:	dc02      	bgt.n	801bdf0 <ppp_vslprintf+0x658>
 801bdea:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bdec:	2b00      	cmp	r3, #0
 801bdee:	d007      	beq.n	801be00 <ppp_vslprintf+0x668>
	    while (str > num + neg) {
 801bdf0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801bdf2:	2210      	movs	r2, #16
 801bdf4:	18ba      	adds	r2, r7, r2
 801bdf6:	18d3      	adds	r3, r2, r3
 801bdf8:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801bdfa:	429a      	cmp	r2, r3
 801bdfc:	d8d9      	bhi.n	801bdb2 <ppp_vslprintf+0x61a>
 801bdfe:	e000      	b.n	801be02 <ppp_vslprintf+0x66a>
		    break;
 801be00:	46c0      	nop			; (mov r8, r8)
	    }
	    switch (neg) {
 801be02:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801be04:	2b01      	cmp	r3, #1
 801be06:	d003      	beq.n	801be10 <ppp_vslprintf+0x678>
 801be08:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801be0a:	2b02      	cmp	r3, #2
 801be0c:	d007      	beq.n	801be1e <ppp_vslprintf+0x686>
	    case 2:
		*--str = 'x';
		*--str = '0';
		break;
	    default:
		break;
 801be0e:	e013      	b.n	801be38 <ppp_vslprintf+0x6a0>
		*--str = '-';
 801be10:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801be12:	3b01      	subs	r3, #1
 801be14:	647b      	str	r3, [r7, #68]	; 0x44
 801be16:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801be18:	222d      	movs	r2, #45	; 0x2d
 801be1a:	701a      	strb	r2, [r3, #0]
		break;
 801be1c:	e00c      	b.n	801be38 <ppp_vslprintf+0x6a0>
		*--str = 'x';
 801be1e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801be20:	3b01      	subs	r3, #1
 801be22:	647b      	str	r3, [r7, #68]	; 0x44
 801be24:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801be26:	2278      	movs	r2, #120	; 0x78
 801be28:	701a      	strb	r2, [r3, #0]
		*--str = '0';
 801be2a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801be2c:	3b01      	subs	r3, #1
 801be2e:	647b      	str	r3, [r7, #68]	; 0x44
 801be30:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801be32:	2230      	movs	r2, #48	; 0x30
 801be34:	701a      	strb	r2, [r3, #0]
		break;
 801be36:	46c0      	nop			; (mov r8, r8)
	    }
	    len = num + sizeof(num) - 1 - str;
 801be38:	2310      	movs	r3, #16
 801be3a:	18fb      	adds	r3, r7, r3
 801be3c:	331f      	adds	r3, #31
 801be3e:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801be40:	1a9b      	subs	r3, r3, r2
 801be42:	657b      	str	r3, [r7, #84]	; 0x54
 801be44:	e00e      	b.n	801be64 <ppp_vslprintf+0x6cc>
	} else {
	    len = strlen(str);
 801be46:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801be48:	0018      	movs	r0, r3
 801be4a:	f7e4 f967 	bl	800011c <strlen>
 801be4e:	0003      	movs	r3, r0
 801be50:	657b      	str	r3, [r7, #84]	; 0x54
	    if (prec >= 0 && len > prec)
 801be52:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801be54:	2b00      	cmp	r3, #0
 801be56:	db05      	blt.n	801be64 <ppp_vslprintf+0x6cc>
 801be58:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801be5a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801be5c:	429a      	cmp	r2, r3
 801be5e:	dd01      	ble.n	801be64 <ppp_vslprintf+0x6cc>
		len = prec;
 801be60:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801be62:	657b      	str	r3, [r7, #84]	; 0x54
	}
	if (width > 0) {
 801be64:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801be66:	2b00      	cmp	r3, #0
 801be68:	dd1d      	ble.n	801bea6 <ppp_vslprintf+0x70e>
	    if (width > buflen)
 801be6a:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 801be6c:	68bb      	ldr	r3, [r7, #8]
 801be6e:	429a      	cmp	r2, r3
 801be70:	dd01      	ble.n	801be76 <ppp_vslprintf+0x6de>
		width = buflen;
 801be72:	68bb      	ldr	r3, [r7, #8]
 801be74:	667b      	str	r3, [r7, #100]	; 0x64
	    if ((n = width - len) > 0) {
 801be76:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 801be78:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801be7a:	1ad3      	subs	r3, r2, r3
 801be7c:	66bb      	str	r3, [r7, #104]	; 0x68
 801be7e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801be80:	2b00      	cmp	r3, #0
 801be82:	dd10      	ble.n	801bea6 <ppp_vslprintf+0x70e>
		buflen -= n;
 801be84:	68ba      	ldr	r2, [r7, #8]
 801be86:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801be88:	1ad3      	subs	r3, r2, r3
 801be8a:	60bb      	str	r3, [r7, #8]
		for (; n > 0; --n)
 801be8c:	e008      	b.n	801bea0 <ppp_vslprintf+0x708>
		    *buf++ = fillch;
 801be8e:	68fb      	ldr	r3, [r7, #12]
 801be90:	1c5a      	adds	r2, r3, #1
 801be92:	60fa      	str	r2, [r7, #12]
 801be94:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 801be96:	b2d2      	uxtb	r2, r2
 801be98:	701a      	strb	r2, [r3, #0]
		for (; n > 0; --n)
 801be9a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801be9c:	3b01      	subs	r3, #1
 801be9e:	66bb      	str	r3, [r7, #104]	; 0x68
 801bea0:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801bea2:	2b00      	cmp	r3, #0
 801bea4:	dcf3      	bgt.n	801be8e <ppp_vslprintf+0x6f6>
	    }
	}
	if (len > buflen)
 801bea6:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801bea8:	68bb      	ldr	r3, [r7, #8]
 801beaa:	429a      	cmp	r2, r3
 801beac:	dd01      	ble.n	801beb2 <ppp_vslprintf+0x71a>
	    len = buflen;
 801beae:	68bb      	ldr	r3, [r7, #8]
 801beb0:	657b      	str	r3, [r7, #84]	; 0x54
	memcpy(buf, str, len);
 801beb2:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801beb4:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801beb6:	68fb      	ldr	r3, [r7, #12]
 801beb8:	0018      	movs	r0, r3
 801beba:	f002 f86f 	bl	801df9c <memcpy>
	buf += len;
 801bebe:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801bec0:	68fa      	ldr	r2, [r7, #12]
 801bec2:	18d3      	adds	r3, r2, r3
 801bec4:	60fb      	str	r3, [r7, #12]
	buflen -= len;
 801bec6:	68ba      	ldr	r2, [r7, #8]
 801bec8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801beca:	1ad3      	subs	r3, r2, r3
 801becc:	60bb      	str	r3, [r7, #8]
    while (buflen > 0) {
 801bece:	68bb      	ldr	r3, [r7, #8]
 801bed0:	2b00      	cmp	r3, #0
 801bed2:	dd00      	ble.n	801bed6 <ppp_vslprintf+0x73e>
 801bed4:	e470      	b.n	801b7b8 <ppp_vslprintf+0x20>
 801bed6:	e000      	b.n	801beda <ppp_vslprintf+0x742>
	    break;
 801bed8:	46c0      	nop			; (mov r8, r8)
    }
    *buf = 0;
 801beda:	68fb      	ldr	r3, [r7, #12]
 801bedc:	2200      	movs	r2, #0
 801bede:	701a      	strb	r2, [r3, #0]
    return buf - buf0;
 801bee0:	68fa      	ldr	r2, [r7, #12]
 801bee2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801bee4:	1ad3      	subs	r3, r2, r3
}
 801bee6:	0018      	movs	r0, r3
 801bee8:	46bd      	mov	sp, r7
 801beea:	b01d      	add	sp, #116	; 0x74
 801beec:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801beee:	46c0      	nop			; (mov r8, r8)
 801bef0:	2000002c 	.word	0x2000002c

0801bef4 <ppp_logit>:
}

/*
 * ppp_logit - does the hard work for fatal et al.
 */
static void ppp_logit(int level, const char *fmt, va_list args) {
 801bef4:	b590      	push	{r4, r7, lr}
 801bef6:	4c0c      	ldr	r4, [pc, #48]	; (801bf28 <ppp_logit+0x34>)
 801bef8:	44a5      	add	sp, r4
 801befa:	af00      	add	r7, sp, #0
 801befc:	60f8      	str	r0, [r7, #12]
 801befe:	60b9      	str	r1, [r7, #8]
 801bf00:	607a      	str	r2, [r7, #4]
    char buf[1024];

    ppp_vslprintf(buf, sizeof(buf), fmt, args);
 801bf02:	687b      	ldr	r3, [r7, #4]
 801bf04:	68ba      	ldr	r2, [r7, #8]
 801bf06:	2180      	movs	r1, #128	; 0x80
 801bf08:	00c9      	lsls	r1, r1, #3
 801bf0a:	2410      	movs	r4, #16
 801bf0c:	1938      	adds	r0, r7, r4
 801bf0e:	f7ff fc43 	bl	801b798 <ppp_vslprintf>
    ppp_log_write(level, buf);
 801bf12:	193a      	adds	r2, r7, r4
 801bf14:	68fb      	ldr	r3, [r7, #12]
 801bf16:	0011      	movs	r1, r2
 801bf18:	0018      	movs	r0, r3
 801bf1a:	f000 f809 	bl	801bf30 <ppp_log_write>
}
 801bf1e:	46c0      	nop			; (mov r8, r8)
 801bf20:	46bd      	mov	sp, r7
 801bf22:	4b02      	ldr	r3, [pc, #8]	; (801bf2c <ppp_logit+0x38>)
 801bf24:	449d      	add	sp, r3
 801bf26:	bd90      	pop	{r4, r7, pc}
 801bf28:	fffffbec 	.word	0xfffffbec
 801bf2c:	00000414 	.word	0x00000414

0801bf30 <ppp_log_write>:

static void ppp_log_write(int level, char *buf) {
 801bf30:	b580      	push	{r7, lr}
 801bf32:	b082      	sub	sp, #8
 801bf34:	af00      	add	r7, sp, #0
 801bf36:	6078      	str	r0, [r7, #4]
 801bf38:	6039      	str	r1, [r7, #0]
	if (write(log_to_fd, buf, n) != n
	    || write(log_to_fd, "\n", 1) != 1)
	    log_to_fd = -1;
    }
#endif
}
 801bf3a:	46c0      	nop			; (mov r8, r8)
 801bf3c:	46bd      	mov	sp, r7
 801bf3e:	b002      	add	sp, #8
 801bf40:	bd80      	pop	{r7, pc}

0801bf42 <ppp_error>:
}

/*
 * ppp_error - log an error message.
 */
void ppp_error(const char *fmt, ...) {
 801bf42:	b40f      	push	{r0, r1, r2, r3}
 801bf44:	b580      	push	{r7, lr}
 801bf46:	b082      	sub	sp, #8
 801bf48:	af00      	add	r7, sp, #0
    va_list pvar;

    va_start(pvar, fmt);
 801bf4a:	2314      	movs	r3, #20
 801bf4c:	18fb      	adds	r3, r7, r3
 801bf4e:	607b      	str	r3, [r7, #4]
    ppp_logit(LOG_ERR, fmt, pvar);
 801bf50:	687a      	ldr	r2, [r7, #4]
 801bf52:	693b      	ldr	r3, [r7, #16]
 801bf54:	0019      	movs	r1, r3
 801bf56:	2003      	movs	r0, #3
 801bf58:	f7ff ffcc 	bl	801bef4 <ppp_logit>
    va_end(pvar);
#if 0 /* UNUSED */
    ++error_count;
#endif /* UNUSED */
}
 801bf5c:	46c0      	nop			; (mov r8, r8)
 801bf5e:	46bd      	mov	sp, r7
 801bf60:	b002      	add	sp, #8
 801bf62:	bc80      	pop	{r7}
 801bf64:	bc08      	pop	{r3}
 801bf66:	b004      	add	sp, #16
 801bf68:	4718      	bx	r3

0801bf6a <ppp_warn>:

/*
 * ppp_warn - log a warning message.
 */
void ppp_warn(const char *fmt, ...) {
 801bf6a:	b40f      	push	{r0, r1, r2, r3}
 801bf6c:	b580      	push	{r7, lr}
 801bf6e:	b082      	sub	sp, #8
 801bf70:	af00      	add	r7, sp, #0
    va_list pvar;

    va_start(pvar, fmt);
 801bf72:	2314      	movs	r3, #20
 801bf74:	18fb      	adds	r3, r7, r3
 801bf76:	607b      	str	r3, [r7, #4]
    ppp_logit(LOG_WARNING, fmt, pvar);
 801bf78:	687a      	ldr	r2, [r7, #4]
 801bf7a:	693b      	ldr	r3, [r7, #16]
 801bf7c:	0019      	movs	r1, r3
 801bf7e:	2001      	movs	r0, #1
 801bf80:	f7ff ffb8 	bl	801bef4 <ppp_logit>
    va_end(pvar);
}
 801bf84:	46c0      	nop			; (mov r8, r8)
 801bf86:	46bd      	mov	sp, r7
 801bf88:	b002      	add	sp, #8
 801bf8a:	bc80      	pop	{r7}
 801bf8c:	bc08      	pop	{r3}
 801bf8e:	b004      	add	sp, #16
 801bf90:	4718      	bx	r3

0801bf92 <ppp_notice>:

/*
 * ppp_notice - log a notice-level message.
 */
void ppp_notice(const char *fmt, ...) {
 801bf92:	b40f      	push	{r0, r1, r2, r3}
 801bf94:	b580      	push	{r7, lr}
 801bf96:	b082      	sub	sp, #8
 801bf98:	af00      	add	r7, sp, #0
    va_list pvar;

    va_start(pvar, fmt);
 801bf9a:	2314      	movs	r3, #20
 801bf9c:	18fb      	adds	r3, r7, r3
 801bf9e:	607b      	str	r3, [r7, #4]
    ppp_logit(LOG_NOTICE, fmt, pvar);
 801bfa0:	687a      	ldr	r2, [r7, #4]
 801bfa2:	693b      	ldr	r3, [r7, #16]
 801bfa4:	0019      	movs	r1, r3
 801bfa6:	2001      	movs	r0, #1
 801bfa8:	f7ff ffa4 	bl	801bef4 <ppp_logit>
    va_end(pvar);
}
 801bfac:	46c0      	nop			; (mov r8, r8)
 801bfae:	46bd      	mov	sp, r7
 801bfb0:	b002      	add	sp, #8
 801bfb2:	bc80      	pop	{r7}
 801bfb4:	bc08      	pop	{r3}
 801bfb6:	b004      	add	sp, #16
 801bfb8:	4718      	bx	r3

0801bfba <ppp_info>:

/*
 * ppp_info - log an informational message.
 */
void ppp_info(const char *fmt, ...) {
 801bfba:	b40f      	push	{r0, r1, r2, r3}
 801bfbc:	b580      	push	{r7, lr}
 801bfbe:	b082      	sub	sp, #8
 801bfc0:	af00      	add	r7, sp, #0
    va_list pvar;

    va_start(pvar, fmt);
 801bfc2:	2314      	movs	r3, #20
 801bfc4:	18fb      	adds	r3, r7, r3
 801bfc6:	607b      	str	r3, [r7, #4]
    ppp_logit(LOG_INFO, fmt, pvar);
 801bfc8:	687a      	ldr	r2, [r7, #4]
 801bfca:	693b      	ldr	r3, [r7, #16]
 801bfcc:	0019      	movs	r1, r3
 801bfce:	2000      	movs	r0, #0
 801bfd0:	f7ff ff90 	bl	801bef4 <ppp_logit>
    va_end(pvar);
}
 801bfd4:	46c0      	nop			; (mov r8, r8)
 801bfd6:	46bd      	mov	sp, r7
 801bfd8:	b002      	add	sp, #8
 801bfda:	bc80      	pop	{r7}
 801bfdc:	bc08      	pop	{r3}
 801bfde:	b004      	add	sp, #16
 801bfe0:	4718      	bx	r3

0801bfe2 <ppp_dbglog>:

/*
 * ppp_dbglog - log a debug message.
 */
void ppp_dbglog(const char *fmt, ...) {
 801bfe2:	b40f      	push	{r0, r1, r2, r3}
 801bfe4:	b580      	push	{r7, lr}
 801bfe6:	b082      	sub	sp, #8
 801bfe8:	af00      	add	r7, sp, #0
    va_list pvar;

    va_start(pvar, fmt);
 801bfea:	2314      	movs	r3, #20
 801bfec:	18fb      	adds	r3, r7, r3
 801bfee:	607b      	str	r3, [r7, #4]
    ppp_logit(LOG_DEBUG, fmt, pvar);
 801bff0:	687a      	ldr	r2, [r7, #4]
 801bff2:	693b      	ldr	r3, [r7, #16]
 801bff4:	0019      	movs	r1, r3
 801bff6:	2000      	movs	r0, #0
 801bff8:	f7ff ff7c 	bl	801bef4 <ppp_logit>
    va_end(pvar);
}
 801bffc:	46c0      	nop			; (mov r8, r8)
 801bffe:	46bd      	mov	sp, r7
 801c000:	b002      	add	sp, #8
 801c002:	bc80      	pop	{r7}
 801c004:	bc08      	pop	{r3}
 801c006:	b004      	add	sp, #16
 801c008:	4718      	bx	r3

0801c00a <vj_compress_init>:
#define INCR(counter)
#endif

void
vj_compress_init(struct vjcompress *comp)
{
 801c00a:	b580      	push	{r7, lr}
 801c00c:	b084      	sub	sp, #16
 801c00e:	af00      	add	r7, sp, #0
 801c010:	6078      	str	r0, [r7, #4]
  u8_t i;
  struct cstate *tstate = comp->tstate;
 801c012:	687b      	ldr	r3, [r7, #4]
 801c014:	330c      	adds	r3, #12
 801c016:	60bb      	str	r3, [r7, #8]

#if MAX_SLOTS == 0
  memset((char *)comp, 0, sizeof(*comp));
#endif
  comp->maxSlotIndex = MAX_SLOTS - 1;
 801c018:	687b      	ldr	r3, [r7, #4]
 801c01a:	220f      	movs	r2, #15
 801c01c:	721a      	strb	r2, [r3, #8]
  comp->compressSlot = 0;    /* Disable slot ID compression by default. */
 801c01e:	687b      	ldr	r3, [r7, #4]
 801c020:	2200      	movs	r2, #0
 801c022:	725a      	strb	r2, [r3, #9]
  for (i = MAX_SLOTS - 1; i > 0; --i) {
 801c024:	230f      	movs	r3, #15
 801c026:	18fb      	adds	r3, r7, r3
 801c028:	220f      	movs	r2, #15
 801c02a:	701a      	strb	r2, [r3, #0]
 801c02c:	e025      	b.n	801c07a <vj_compress_init+0x70>
    tstate[i].cs_id = i;
 801c02e:	200f      	movs	r0, #15
 801c030:	183b      	adds	r3, r7, r0
 801c032:	781a      	ldrb	r2, [r3, #0]
 801c034:	0013      	movs	r3, r2
 801c036:	011b      	lsls	r3, r3, #4
 801c038:	189b      	adds	r3, r3, r2
 801c03a:	00db      	lsls	r3, r3, #3
 801c03c:	001a      	movs	r2, r3
 801c03e:	68bb      	ldr	r3, [r7, #8]
 801c040:	189b      	adds	r3, r3, r2
 801c042:	183a      	adds	r2, r7, r0
 801c044:	7812      	ldrb	r2, [r2, #0]
 801c046:	719a      	strb	r2, [r3, #6]
    tstate[i].cs_next = &tstate[i - 1];
 801c048:	183b      	adds	r3, r7, r0
 801c04a:	781a      	ldrb	r2, [r3, #0]
 801c04c:	0013      	movs	r3, r2
 801c04e:	011b      	lsls	r3, r3, #4
 801c050:	189b      	adds	r3, r3, r2
 801c052:	00db      	lsls	r3, r3, #3
 801c054:	3b88      	subs	r3, #136	; 0x88
 801c056:	0019      	movs	r1, r3
 801c058:	183b      	adds	r3, r7, r0
 801c05a:	781a      	ldrb	r2, [r3, #0]
 801c05c:	0013      	movs	r3, r2
 801c05e:	011b      	lsls	r3, r3, #4
 801c060:	189b      	adds	r3, r3, r2
 801c062:	00db      	lsls	r3, r3, #3
 801c064:	001a      	movs	r2, r3
 801c066:	68bb      	ldr	r3, [r7, #8]
 801c068:	189b      	adds	r3, r3, r2
 801c06a:	68ba      	ldr	r2, [r7, #8]
 801c06c:	1852      	adds	r2, r2, r1
 801c06e:	601a      	str	r2, [r3, #0]
  for (i = MAX_SLOTS - 1; i > 0; --i) {
 801c070:	183b      	adds	r3, r7, r0
 801c072:	183a      	adds	r2, r7, r0
 801c074:	7812      	ldrb	r2, [r2, #0]
 801c076:	3a01      	subs	r2, #1
 801c078:	701a      	strb	r2, [r3, #0]
 801c07a:	230f      	movs	r3, #15
 801c07c:	18fb      	adds	r3, r7, r3
 801c07e:	781b      	ldrb	r3, [r3, #0]
 801c080:	2b00      	cmp	r3, #0
 801c082:	d1d4      	bne.n	801c02e <vj_compress_init+0x24>
  }
  tstate[0].cs_next = &tstate[MAX_SLOTS - 1];
 801c084:	68bb      	ldr	r3, [r7, #8]
 801c086:	22ff      	movs	r2, #255	; 0xff
 801c088:	00d2      	lsls	r2, r2, #3
 801c08a:	189a      	adds	r2, r3, r2
 801c08c:	68bb      	ldr	r3, [r7, #8]
 801c08e:	601a      	str	r2, [r3, #0]
  tstate[0].cs_id = 0;
 801c090:	68bb      	ldr	r3, [r7, #8]
 801c092:	2200      	movs	r2, #0
 801c094:	719a      	strb	r2, [r3, #6]
  comp->last_cs = &tstate[0];
 801c096:	687b      	ldr	r3, [r7, #4]
 801c098:	68ba      	ldr	r2, [r7, #8]
 801c09a:	601a      	str	r2, [r3, #0]
  comp->last_recv = 255;
 801c09c:	687b      	ldr	r3, [r7, #4]
 801c09e:	22ff      	movs	r2, #255	; 0xff
 801c0a0:	711a      	strb	r2, [r3, #4]
  comp->last_xmit = 255;
 801c0a2:	687b      	ldr	r3, [r7, #4]
 801c0a4:	22ff      	movs	r2, #255	; 0xff
 801c0a6:	715a      	strb	r2, [r3, #5]
  comp->flags = VJF_TOSS;
 801c0a8:	687b      	ldr	r3, [r7, #4]
 801c0aa:	2201      	movs	r2, #1
 801c0ac:	80da      	strh	r2, [r3, #6]
}
 801c0ae:	46c0      	nop			; (mov r8, r8)
 801c0b0:	46bd      	mov	sp, r7
 801c0b2:	b004      	add	sp, #16
 801c0b4:	bd80      	pop	{r7, pc}
	...

0801c0b8 <vj_compress_tcp>:
 * Return the VJ type code indicating whether or not the packet was
 * compressed.
 */
u8_t
vj_compress_tcp(struct vjcompress *comp, struct pbuf **pb)
{
 801c0b8:	b5b0      	push	{r4, r5, r7, lr}
 801c0ba:	b094      	sub	sp, #80	; 0x50
 801c0bc:	af00      	add	r7, sp, #0
 801c0be:	6078      	str	r0, [r7, #4]
 801c0c0:	6039      	str	r1, [r7, #0]
  struct pbuf *np = *pb;
 801c0c2:	683b      	ldr	r3, [r7, #0]
 801c0c4:	681b      	ldr	r3, [r3, #0]
 801c0c6:	63fb      	str	r3, [r7, #60]	; 0x3c
  struct ip_hdr *ip = (struct ip_hdr *)np->payload;
 801c0c8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c0ca:	685b      	ldr	r3, [r3, #4]
 801c0cc:	63bb      	str	r3, [r7, #56]	; 0x38
  struct cstate *cs = comp->last_cs->cs_next;
 801c0ce:	687b      	ldr	r3, [r7, #4]
 801c0d0:	681b      	ldr	r3, [r3, #0]
 801c0d2:	681b      	ldr	r3, [r3, #0]
 801c0d4:	64fb      	str	r3, [r7, #76]	; 0x4c
  u16_t ilen = IPH_HL(ip);
 801c0d6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c0d8:	781b      	ldrb	r3, [r3, #0]
 801c0da:	b29a      	uxth	r2, r3
 801c0dc:	2336      	movs	r3, #54	; 0x36
 801c0de:	18fb      	adds	r3, r7, r3
 801c0e0:	210f      	movs	r1, #15
 801c0e2:	400a      	ands	r2, r1
 801c0e4:	801a      	strh	r2, [r3, #0]
  u16_t hlen;
  struct tcp_hdr *oth;
  struct tcp_hdr *th;
  u16_t deltaS, deltaA = 0;
 801c0e6:	2348      	movs	r3, #72	; 0x48
 801c0e8:	18fb      	adds	r3, r7, r3
 801c0ea:	2200      	movs	r2, #0
 801c0ec:	801a      	strh	r2, [r3, #0]
  u32_t deltaL;
  u32_t changes = 0;
 801c0ee:	2300      	movs	r3, #0
 801c0f0:	647b      	str	r3, [r7, #68]	; 0x44
  u8_t new_seq[16];
  u8_t *cp = new_seq;
 801c0f2:	230c      	movs	r3, #12
 801c0f4:	18fb      	adds	r3, r7, r3
 801c0f6:	643b      	str	r3, [r7, #64]	; 0x40

  /*
   * Check that the packet is IP proto TCP.
   */
  if (IPH_PROTO(ip) != IP_PROTO_TCP) {
 801c0f8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c0fa:	7a5b      	ldrb	r3, [r3, #9]
 801c0fc:	2b06      	cmp	r3, #6
 801c0fe:	d002      	beq.n	801c106 <vj_compress_tcp+0x4e>
    return (TYPE_IP);
 801c100:	2340      	movs	r3, #64	; 0x40
 801c102:	f000 fc53 	bl	801c9ac <vj_compress_tcp+0x8f4>
  /*
   * Bail if this is an IP fragment or if the TCP packet isn't
   * `compressible' (i.e., ACK isn't set or some other control bit is
   * set).
   */
  if ((IPH_OFFSET(ip) & PP_HTONS(0x3fff)) || np->tot_len < 40) {
 801c106:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c108:	799a      	ldrb	r2, [r3, #6]
 801c10a:	79db      	ldrb	r3, [r3, #7]
 801c10c:	021b      	lsls	r3, r3, #8
 801c10e:	4313      	orrs	r3, r2
 801c110:	b29b      	uxth	r3, r3
 801c112:	001a      	movs	r2, r3
 801c114:	4b7c      	ldr	r3, [pc, #496]	; (801c308 <vj_compress_tcp+0x250>)
 801c116:	4013      	ands	r3, r2
 801c118:	d103      	bne.n	801c122 <vj_compress_tcp+0x6a>
 801c11a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c11c:	891b      	ldrh	r3, [r3, #8]
 801c11e:	2b27      	cmp	r3, #39	; 0x27
 801c120:	d802      	bhi.n	801c128 <vj_compress_tcp+0x70>
    return (TYPE_IP);
 801c122:	2340      	movs	r3, #64	; 0x40
 801c124:	f000 fc42 	bl	801c9ac <vj_compress_tcp+0x8f4>
  }
  th = (struct tcp_hdr *)&((struct vj_u32_t*)ip)[ilen];
 801c128:	2336      	movs	r3, #54	; 0x36
 801c12a:	18fb      	adds	r3, r7, r3
 801c12c:	881b      	ldrh	r3, [r3, #0]
 801c12e:	009b      	lsls	r3, r3, #2
 801c130:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801c132:	18d3      	adds	r3, r2, r3
 801c134:	633b      	str	r3, [r7, #48]	; 0x30
  if ((TCPH_FLAGS(th) & (TCP_SYN|TCP_FIN|TCP_RST|TCP_ACK)) != TCP_ACK) {
 801c136:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c138:	7b1a      	ldrb	r2, [r3, #12]
 801c13a:	7b5b      	ldrb	r3, [r3, #13]
 801c13c:	021b      	lsls	r3, r3, #8
 801c13e:	4313      	orrs	r3, r2
 801c140:	b29b      	uxth	r3, r3
 801c142:	0018      	movs	r0, r3
 801c144:	f7eb f95c 	bl	8007400 <lwip_htons>
 801c148:	0003      	movs	r3, r0
 801c14a:	b2db      	uxtb	r3, r3
 801c14c:	001a      	movs	r2, r3
 801c14e:	2317      	movs	r3, #23
 801c150:	4013      	ands	r3, r2
 801c152:	2b10      	cmp	r3, #16
 801c154:	d002      	beq.n	801c15c <vj_compress_tcp+0xa4>
    return (TYPE_IP);
 801c156:	2340      	movs	r3, #64	; 0x40
 801c158:	f000 fc28 	bl	801c9ac <vj_compress_tcp+0x8f4>
  }

  /* Check that the TCP/IP headers are contained in the first buffer. */
  hlen = ilen + TCPH_HDRLEN(th);
 801c15c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c15e:	7b1a      	ldrb	r2, [r3, #12]
 801c160:	7b5b      	ldrb	r3, [r3, #13]
 801c162:	021b      	lsls	r3, r3, #8
 801c164:	4313      	orrs	r3, r2
 801c166:	b29b      	uxth	r3, r3
 801c168:	0018      	movs	r0, r3
 801c16a:	f7eb f949 	bl	8007400 <lwip_htons>
 801c16e:	0003      	movs	r3, r0
 801c170:	0b1b      	lsrs	r3, r3, #12
 801c172:	b299      	uxth	r1, r3
 801c174:	202e      	movs	r0, #46	; 0x2e
 801c176:	183b      	adds	r3, r7, r0
 801c178:	2236      	movs	r2, #54	; 0x36
 801c17a:	18ba      	adds	r2, r7, r2
 801c17c:	8812      	ldrh	r2, [r2, #0]
 801c17e:	188a      	adds	r2, r1, r2
 801c180:	801a      	strh	r2, [r3, #0]
  hlen <<= 2;
 801c182:	0001      	movs	r1, r0
 801c184:	187b      	adds	r3, r7, r1
 801c186:	187a      	adds	r2, r7, r1
 801c188:	8812      	ldrh	r2, [r2, #0]
 801c18a:	0092      	lsls	r2, r2, #2
 801c18c:	801a      	strh	r2, [r3, #0]
  if (np->len < hlen) {
 801c18e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c190:	895b      	ldrh	r3, [r3, #10]
 801c192:	187a      	adds	r2, r7, r1
 801c194:	8812      	ldrh	r2, [r2, #0]
 801c196:	429a      	cmp	r2, r3
 801c198:	d902      	bls.n	801c1a0 <vj_compress_tcp+0xe8>
    PPPDEBUG(LOG_INFO, ("vj_compress_tcp: header len %d spans buffers\n", hlen));
    return (TYPE_IP);
 801c19a:	2340      	movs	r3, #64	; 0x40
 801c19c:	f000 fc06 	bl	801c9ac <vj_compress_tcp+0x8f4>
  }

  /* TCP stack requires that we don't change the packet payload, therefore we copy
   * the whole packet before compression. */
  np = pbuf_clone(PBUF_RAW, PBUF_RAM, *pb);
 801c1a0:	683b      	ldr	r3, [r7, #0]
 801c1a2:	681a      	ldr	r2, [r3, #0]
 801c1a4:	23a0      	movs	r3, #160	; 0xa0
 801c1a6:	009b      	lsls	r3, r3, #2
 801c1a8:	0019      	movs	r1, r3
 801c1aa:	2000      	movs	r0, #0
 801c1ac:	f7ee fe74 	bl	800ae98 <pbuf_clone>
 801c1b0:	0003      	movs	r3, r0
 801c1b2:	63fb      	str	r3, [r7, #60]	; 0x3c
  if (!np) {
 801c1b4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c1b6:	2b00      	cmp	r3, #0
 801c1b8:	d102      	bne.n	801c1c0 <vj_compress_tcp+0x108>
    return (TYPE_IP);
 801c1ba:	2340      	movs	r3, #64	; 0x40
 801c1bc:	f000 fbf6 	bl	801c9ac <vj_compress_tcp+0x8f4>
  }

  *pb = np;
 801c1c0:	683b      	ldr	r3, [r7, #0]
 801c1c2:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801c1c4:	601a      	str	r2, [r3, #0]
  ip = (struct ip_hdr *)np->payload;
 801c1c6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c1c8:	685b      	ldr	r3, [r3, #4]
 801c1ca:	63bb      	str	r3, [r7, #56]	; 0x38
   * to locate (or create) the connection state.  Special case the
   * most recently used connection since it's most likely to be used
   * again & we don't have to do any reordering if it's used.
   */
  INCR(vjs_packets);
  if (!ip4_addr_cmp(&ip->src, &cs->cs_ip.src)
 801c1cc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c1ce:	7b1a      	ldrb	r2, [r3, #12]
 801c1d0:	7b59      	ldrb	r1, [r3, #13]
 801c1d2:	0209      	lsls	r1, r1, #8
 801c1d4:	430a      	orrs	r2, r1
 801c1d6:	7b99      	ldrb	r1, [r3, #14]
 801c1d8:	0409      	lsls	r1, r1, #16
 801c1da:	430a      	orrs	r2, r1
 801c1dc:	7bdb      	ldrb	r3, [r3, #15]
 801c1de:	061b      	lsls	r3, r3, #24
 801c1e0:	4313      	orrs	r3, r2
 801c1e2:	001a      	movs	r2, r3
 801c1e4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c1e6:	695b      	ldr	r3, [r3, #20]
 801c1e8:	429a      	cmp	r2, r3
 801c1ea:	d131      	bne.n	801c250 <vj_compress_tcp+0x198>
      || !ip4_addr_cmp(&ip->dest, &cs->cs_ip.dest)
 801c1ec:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c1ee:	7c1a      	ldrb	r2, [r3, #16]
 801c1f0:	7c59      	ldrb	r1, [r3, #17]
 801c1f2:	0209      	lsls	r1, r1, #8
 801c1f4:	430a      	orrs	r2, r1
 801c1f6:	7c99      	ldrb	r1, [r3, #18]
 801c1f8:	0409      	lsls	r1, r1, #16
 801c1fa:	430a      	orrs	r2, r1
 801c1fc:	7cdb      	ldrb	r3, [r3, #19]
 801c1fe:	061b      	lsls	r3, r3, #24
 801c200:	4313      	orrs	r3, r2
 801c202:	001a      	movs	r2, r3
 801c204:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c206:	699b      	ldr	r3, [r3, #24]
 801c208:	429a      	cmp	r2, r3
 801c20a:	d121      	bne.n	801c250 <vj_compress_tcp+0x198>
      || (*(struct vj_u32_t*)th).v != (((struct vj_u32_t*)&cs->cs_ip)[IPH_HL(&cs->cs_ip)]).v) {
 801c20c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c20e:	781a      	ldrb	r2, [r3, #0]
 801c210:	7859      	ldrb	r1, [r3, #1]
 801c212:	0209      	lsls	r1, r1, #8
 801c214:	430a      	orrs	r2, r1
 801c216:	7899      	ldrb	r1, [r3, #2]
 801c218:	0409      	lsls	r1, r1, #16
 801c21a:	430a      	orrs	r2, r1
 801c21c:	78db      	ldrb	r3, [r3, #3]
 801c21e:	061b      	lsls	r3, r3, #24
 801c220:	4313      	orrs	r3, r2
 801c222:	0018      	movs	r0, r3
 801c224:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c226:	3308      	adds	r3, #8
 801c228:	001a      	movs	r2, r3
 801c22a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c22c:	7a1b      	ldrb	r3, [r3, #8]
 801c22e:	0019      	movs	r1, r3
 801c230:	230f      	movs	r3, #15
 801c232:	400b      	ands	r3, r1
 801c234:	009b      	lsls	r3, r3, #2
 801c236:	18d3      	adds	r3, r2, r3
 801c238:	781a      	ldrb	r2, [r3, #0]
 801c23a:	7859      	ldrb	r1, [r3, #1]
 801c23c:	0209      	lsls	r1, r1, #8
 801c23e:	430a      	orrs	r2, r1
 801c240:	7899      	ldrb	r1, [r3, #2]
 801c242:	0409      	lsls	r1, r1, #16
 801c244:	430a      	orrs	r2, r1
 801c246:	78db      	ldrb	r3, [r3, #3]
 801c248:	061b      	lsls	r3, r3, #24
 801c24a:	4313      	orrs	r3, r2
 801c24c:	4298      	cmp	r0, r3
 801c24e:	d068      	beq.n	801c322 <vj_compress_tcp+0x26a>
     * we want is almost always near the front, we locate
     * states via linear search.  If we don't find a state
     * for the datagram, the oldest state is (re-)used.
     */
    struct cstate *lcs;
    struct cstate *lastcs = comp->last_cs;
 801c250:	687b      	ldr	r3, [r7, #4]
 801c252:	681b      	ldr	r3, [r3, #0]
 801c254:	62bb      	str	r3, [r7, #40]	; 0x28

    do {
      lcs = cs; cs = cs->cs_next;
 801c256:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c258:	627b      	str	r3, [r7, #36]	; 0x24
 801c25a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c25c:	681b      	ldr	r3, [r3, #0]
 801c25e:	64fb      	str	r3, [r7, #76]	; 0x4c
      INCR(vjs_searches);
      if (ip4_addr_cmp(&ip->src, &cs->cs_ip.src)
 801c260:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c262:	7b1a      	ldrb	r2, [r3, #12]
 801c264:	7b59      	ldrb	r1, [r3, #13]
 801c266:	0209      	lsls	r1, r1, #8
 801c268:	430a      	orrs	r2, r1
 801c26a:	7b99      	ldrb	r1, [r3, #14]
 801c26c:	0409      	lsls	r1, r1, #16
 801c26e:	430a      	orrs	r2, r1
 801c270:	7bdb      	ldrb	r3, [r3, #15]
 801c272:	061b      	lsls	r3, r3, #24
 801c274:	4313      	orrs	r3, r2
 801c276:	001a      	movs	r2, r3
 801c278:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c27a:	695b      	ldr	r3, [r3, #20]
 801c27c:	429a      	cmp	r2, r3
 801c27e:	d131      	bne.n	801c2e4 <vj_compress_tcp+0x22c>
          && ip4_addr_cmp(&ip->dest, &cs->cs_ip.dest)
 801c280:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c282:	7c1a      	ldrb	r2, [r3, #16]
 801c284:	7c59      	ldrb	r1, [r3, #17]
 801c286:	0209      	lsls	r1, r1, #8
 801c288:	430a      	orrs	r2, r1
 801c28a:	7c99      	ldrb	r1, [r3, #18]
 801c28c:	0409      	lsls	r1, r1, #16
 801c28e:	430a      	orrs	r2, r1
 801c290:	7cdb      	ldrb	r3, [r3, #19]
 801c292:	061b      	lsls	r3, r3, #24
 801c294:	4313      	orrs	r3, r2
 801c296:	001a      	movs	r2, r3
 801c298:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c29a:	699b      	ldr	r3, [r3, #24]
 801c29c:	429a      	cmp	r2, r3
 801c29e:	d121      	bne.n	801c2e4 <vj_compress_tcp+0x22c>
          && (*(struct vj_u32_t*)th).v == (((struct vj_u32_t*)&cs->cs_ip)[IPH_HL(&cs->cs_ip)]).v) {
 801c2a0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c2a2:	781a      	ldrb	r2, [r3, #0]
 801c2a4:	7859      	ldrb	r1, [r3, #1]
 801c2a6:	0209      	lsls	r1, r1, #8
 801c2a8:	430a      	orrs	r2, r1
 801c2aa:	7899      	ldrb	r1, [r3, #2]
 801c2ac:	0409      	lsls	r1, r1, #16
 801c2ae:	430a      	orrs	r2, r1
 801c2b0:	78db      	ldrb	r3, [r3, #3]
 801c2b2:	061b      	lsls	r3, r3, #24
 801c2b4:	4313      	orrs	r3, r2
 801c2b6:	0018      	movs	r0, r3
 801c2b8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c2ba:	3308      	adds	r3, #8
 801c2bc:	001a      	movs	r2, r3
 801c2be:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c2c0:	7a1b      	ldrb	r3, [r3, #8]
 801c2c2:	0019      	movs	r1, r3
 801c2c4:	230f      	movs	r3, #15
 801c2c6:	400b      	ands	r3, r1
 801c2c8:	009b      	lsls	r3, r3, #2
 801c2ca:	18d3      	adds	r3, r2, r3
 801c2cc:	781a      	ldrb	r2, [r3, #0]
 801c2ce:	7859      	ldrb	r1, [r3, #1]
 801c2d0:	0209      	lsls	r1, r1, #8
 801c2d2:	430a      	orrs	r2, r1
 801c2d4:	7899      	ldrb	r1, [r3, #2]
 801c2d6:	0409      	lsls	r1, r1, #16
 801c2d8:	430a      	orrs	r2, r1
 801c2da:	78db      	ldrb	r3, [r3, #3]
 801c2dc:	061b      	lsls	r3, r3, #24
 801c2de:	4313      	orrs	r3, r2
 801c2e0:	4298      	cmp	r0, r3
 801c2e2:	d007      	beq.n	801c2f4 <vj_compress_tcp+0x23c>
        goto found;
      }
    } while (cs != lastcs);
 801c2e4:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801c2e6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801c2e8:	429a      	cmp	r2, r3
 801c2ea:	d1b4      	bne.n	801c256 <vj_compress_tcp+0x19e>
     * Note that since the state list is circular, the oldest
     * state points to the newest and we only need to set
     * last_cs to update the lru linkage.
     */
    INCR(vjs_misses);
    comp->last_cs = lcs;
 801c2ec:	687b      	ldr	r3, [r7, #4]
 801c2ee:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801c2f0:	601a      	str	r2, [r3, #0]
    goto uncompressed;
 801c2f2:	e348      	b.n	801c986 <vj_compress_tcp+0x8ce>
        goto found;
 801c2f4:	46c0      	nop			; (mov r8, r8)

    found:
    /*
     * Found it -- move to the front on the connection list.
     */
    if (cs == lastcs) {
 801c2f6:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801c2f8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801c2fa:	429a      	cmp	r2, r3
 801c2fc:	d106      	bne.n	801c30c <vj_compress_tcp+0x254>
      comp->last_cs = lcs;
 801c2fe:	687b      	ldr	r3, [r7, #4]
 801c300:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801c302:	601a      	str	r2, [r3, #0]
 801c304:	e00d      	b.n	801c322 <vj_compress_tcp+0x26a>
 801c306:	46c0      	nop			; (mov r8, r8)
 801c308:	0000ff3f 	.word	0x0000ff3f
    } else {
      lcs->cs_next = cs->cs_next;
 801c30c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c30e:	681a      	ldr	r2, [r3, #0]
 801c310:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c312:	601a      	str	r2, [r3, #0]
      cs->cs_next = lastcs->cs_next;
 801c314:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801c316:	681a      	ldr	r2, [r3, #0]
 801c318:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c31a:	601a      	str	r2, [r3, #0]
      lastcs->cs_next = cs;
 801c31c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801c31e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801c320:	601a      	str	r2, [r3, #0]
    }
  }

  oth = (struct tcp_hdr *)&((struct vj_u32_t*)&cs->cs_ip)[ilen];
 801c322:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c324:	3308      	adds	r3, #8
 801c326:	001a      	movs	r2, r3
 801c328:	2136      	movs	r1, #54	; 0x36
 801c32a:	187b      	adds	r3, r7, r1
 801c32c:	881b      	ldrh	r3, [r3, #0]
 801c32e:	009b      	lsls	r3, r3, #2
 801c330:	18d3      	adds	r3, r2, r3
 801c332:	623b      	str	r3, [r7, #32]
  deltaS = ilen;
 801c334:	254a      	movs	r5, #74	; 0x4a
 801c336:	197b      	adds	r3, r7, r5
 801c338:	187a      	adds	r2, r7, r1
 801c33a:	8812      	ldrh	r2, [r2, #0]
 801c33c:	801a      	strh	r2, [r3, #0]
   * header length.  The 5th line checks IP options, if any.  The 6th
   * line checks TCP options, if any.  If any of these things are
   * different between the previous & current datagram, we send the
   * current datagram `uncompressed'.
   */
  if ((((struct vj_u16_t*)ip)[0]).v != (((struct vj_u16_t*)&cs->cs_ip)[0]).v
 801c33e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c340:	781a      	ldrb	r2, [r3, #0]
 801c342:	785b      	ldrb	r3, [r3, #1]
 801c344:	021b      	lsls	r3, r3, #8
 801c346:	4313      	orrs	r3, r2
 801c348:	b29a      	uxth	r2, r3
 801c34a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c34c:	3308      	adds	r3, #8
 801c34e:	7819      	ldrb	r1, [r3, #0]
 801c350:	785b      	ldrb	r3, [r3, #1]
 801c352:	021b      	lsls	r3, r3, #8
 801c354:	430b      	orrs	r3, r1
 801c356:	b29b      	uxth	r3, r3
 801c358:	429a      	cmp	r2, r3
 801c35a:	d000      	beq.n	801c35e <vj_compress_tcp+0x2a6>
 801c35c:	e30a      	b.n	801c974 <vj_compress_tcp+0x8bc>
      || (((struct vj_u16_t*)ip)[3]).v != (((struct vj_u16_t*)&cs->cs_ip)[3]).v
 801c35e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c360:	3306      	adds	r3, #6
 801c362:	781a      	ldrb	r2, [r3, #0]
 801c364:	785b      	ldrb	r3, [r3, #1]
 801c366:	021b      	lsls	r3, r3, #8
 801c368:	4313      	orrs	r3, r2
 801c36a:	b29a      	uxth	r2, r3
 801c36c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c36e:	3308      	adds	r3, #8
 801c370:	3306      	adds	r3, #6
 801c372:	7819      	ldrb	r1, [r3, #0]
 801c374:	785b      	ldrb	r3, [r3, #1]
 801c376:	021b      	lsls	r3, r3, #8
 801c378:	430b      	orrs	r3, r1
 801c37a:	b29b      	uxth	r3, r3
 801c37c:	429a      	cmp	r2, r3
 801c37e:	d000      	beq.n	801c382 <vj_compress_tcp+0x2ca>
 801c380:	e2f8      	b.n	801c974 <vj_compress_tcp+0x8bc>
      || (((struct vj_u16_t*)ip)[4]).v != (((struct vj_u16_t*)&cs->cs_ip)[4]).v
 801c382:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c384:	3308      	adds	r3, #8
 801c386:	781a      	ldrb	r2, [r3, #0]
 801c388:	785b      	ldrb	r3, [r3, #1]
 801c38a:	021b      	lsls	r3, r3, #8
 801c38c:	4313      	orrs	r3, r2
 801c38e:	b29a      	uxth	r2, r3
 801c390:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c392:	3308      	adds	r3, #8
 801c394:	3308      	adds	r3, #8
 801c396:	7819      	ldrb	r1, [r3, #0]
 801c398:	785b      	ldrb	r3, [r3, #1]
 801c39a:	021b      	lsls	r3, r3, #8
 801c39c:	430b      	orrs	r3, r1
 801c39e:	b29b      	uxth	r3, r3
 801c3a0:	429a      	cmp	r2, r3
 801c3a2:	d000      	beq.n	801c3a6 <vj_compress_tcp+0x2ee>
 801c3a4:	e2e6      	b.n	801c974 <vj_compress_tcp+0x8bc>
      || TCPH_HDRLEN(th) != TCPH_HDRLEN(oth)
 801c3a6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c3a8:	7b1a      	ldrb	r2, [r3, #12]
 801c3aa:	7b5b      	ldrb	r3, [r3, #13]
 801c3ac:	021b      	lsls	r3, r3, #8
 801c3ae:	4313      	orrs	r3, r2
 801c3b0:	b29b      	uxth	r3, r3
 801c3b2:	0018      	movs	r0, r3
 801c3b4:	f7eb f824 	bl	8007400 <lwip_htons>
 801c3b8:	0003      	movs	r3, r0
 801c3ba:	0b1b      	lsrs	r3, r3, #12
 801c3bc:	b29c      	uxth	r4, r3
 801c3be:	6a3b      	ldr	r3, [r7, #32]
 801c3c0:	7b1a      	ldrb	r2, [r3, #12]
 801c3c2:	7b5b      	ldrb	r3, [r3, #13]
 801c3c4:	021b      	lsls	r3, r3, #8
 801c3c6:	4313      	orrs	r3, r2
 801c3c8:	b29b      	uxth	r3, r3
 801c3ca:	0018      	movs	r0, r3
 801c3cc:	f7eb f818 	bl	8007400 <lwip_htons>
 801c3d0:	0003      	movs	r3, r0
 801c3d2:	0b1b      	lsrs	r3, r3, #12
 801c3d4:	b29b      	uxth	r3, r3
 801c3d6:	429c      	cmp	r4, r3
 801c3d8:	d000      	beq.n	801c3dc <vj_compress_tcp+0x324>
 801c3da:	e2cb      	b.n	801c974 <vj_compress_tcp+0x8bc>
      || (deltaS > 5 && BCMP(ip + 1, &cs->cs_ip + 1, (deltaS - 5) << 2))
 801c3dc:	197b      	adds	r3, r7, r5
 801c3de:	881b      	ldrh	r3, [r3, #0]
 801c3e0:	2b05      	cmp	r3, #5
 801c3e2:	d910      	bls.n	801c406 <vj_compress_tcp+0x34e>
 801c3e4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c3e6:	3314      	adds	r3, #20
 801c3e8:	0018      	movs	r0, r3
 801c3ea:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c3ec:	3308      	adds	r3, #8
 801c3ee:	3314      	adds	r3, #20
 801c3f0:	0019      	movs	r1, r3
 801c3f2:	197b      	adds	r3, r7, r5
 801c3f4:	881b      	ldrh	r3, [r3, #0]
 801c3f6:	3b05      	subs	r3, #5
 801c3f8:	009b      	lsls	r3, r3, #2
 801c3fa:	001a      	movs	r2, r3
 801c3fc:	f001 fdc0 	bl	801df80 <memcmp>
 801c400:	1e03      	subs	r3, r0, #0
 801c402:	d000      	beq.n	801c406 <vj_compress_tcp+0x34e>
 801c404:	e2b6      	b.n	801c974 <vj_compress_tcp+0x8bc>
      || (TCPH_HDRLEN(th) > 5 && BCMP(th + 1, oth + 1, (TCPH_HDRLEN(th) - 5) << 2))) {
 801c406:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c408:	7b1a      	ldrb	r2, [r3, #12]
 801c40a:	7b5b      	ldrb	r3, [r3, #13]
 801c40c:	021b      	lsls	r3, r3, #8
 801c40e:	4313      	orrs	r3, r2
 801c410:	b29b      	uxth	r3, r3
 801c412:	0018      	movs	r0, r3
 801c414:	f7ea fff4 	bl	8007400 <lwip_htons>
 801c418:	0003      	movs	r3, r0
 801c41a:	0b1b      	lsrs	r3, r3, #12
 801c41c:	b29b      	uxth	r3, r3
 801c41e:	2b05      	cmp	r3, #5
 801c420:	d91b      	bls.n	801c45a <vj_compress_tcp+0x3a2>
 801c422:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c424:	3314      	adds	r3, #20
 801c426:	001c      	movs	r4, r3
 801c428:	6a3b      	ldr	r3, [r7, #32]
 801c42a:	3314      	adds	r3, #20
 801c42c:	001d      	movs	r5, r3
 801c42e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c430:	7b1a      	ldrb	r2, [r3, #12]
 801c432:	7b5b      	ldrb	r3, [r3, #13]
 801c434:	021b      	lsls	r3, r3, #8
 801c436:	4313      	orrs	r3, r2
 801c438:	b29b      	uxth	r3, r3
 801c43a:	0018      	movs	r0, r3
 801c43c:	f7ea ffe0 	bl	8007400 <lwip_htons>
 801c440:	0003      	movs	r3, r0
 801c442:	0b1b      	lsrs	r3, r3, #12
 801c444:	b29b      	uxth	r3, r3
 801c446:	3b05      	subs	r3, #5
 801c448:	009b      	lsls	r3, r3, #2
 801c44a:	001a      	movs	r2, r3
 801c44c:	0029      	movs	r1, r5
 801c44e:	0020      	movs	r0, r4
 801c450:	f001 fd96 	bl	801df80 <memcmp>
 801c454:	1e03      	subs	r3, r0, #0
 801c456:	d000      	beq.n	801c45a <vj_compress_tcp+0x3a2>
 801c458:	e28c      	b.n	801c974 <vj_compress_tcp+0x8bc>
   * Figure out which of the changing fields changed.  The
   * receiver expects changes in the order: urgent, window,
   * ack, seq (the order minimizes the number of temporaries
   * needed in this section of code).
   */
  if (TCPH_FLAGS(th) & TCP_URG) {
 801c45a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c45c:	7b1a      	ldrb	r2, [r3, #12]
 801c45e:	7b5b      	ldrb	r3, [r3, #13]
 801c460:	021b      	lsls	r3, r3, #8
 801c462:	4313      	orrs	r3, r2
 801c464:	b29b      	uxth	r3, r3
 801c466:	0018      	movs	r0, r3
 801c468:	f7ea ffca 	bl	8007400 <lwip_htons>
 801c46c:	0003      	movs	r3, r0
 801c46e:	b2db      	uxtb	r3, r3
 801c470:	001a      	movs	r2, r3
 801c472:	2320      	movs	r3, #32
 801c474:	4013      	ands	r3, r2
 801c476:	d038      	beq.n	801c4ea <vj_compress_tcp+0x432>
    deltaS = lwip_ntohs(th->urgp);
 801c478:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c47a:	7c9a      	ldrb	r2, [r3, #18]
 801c47c:	7cdb      	ldrb	r3, [r3, #19]
 801c47e:	021b      	lsls	r3, r3, #8
 801c480:	4313      	orrs	r3, r2
 801c482:	b29b      	uxth	r3, r3
 801c484:	254a      	movs	r5, #74	; 0x4a
 801c486:	197c      	adds	r4, r7, r5
 801c488:	0018      	movs	r0, r3
 801c48a:	f7ea ffb9 	bl	8007400 <lwip_htons>
 801c48e:	0003      	movs	r3, r0
 801c490:	8023      	strh	r3, [r4, #0]
    ENCODEZ(deltaS);
 801c492:	197b      	adds	r3, r7, r5
 801c494:	881b      	ldrh	r3, [r3, #0]
 801c496:	2bff      	cmp	r3, #255	; 0xff
 801c498:	d803      	bhi.n	801c4a2 <vj_compress_tcp+0x3ea>
 801c49a:	197b      	adds	r3, r7, r5
 801c49c:	881b      	ldrh	r3, [r3, #0]
 801c49e:	2b00      	cmp	r3, #0
 801c4a0:	d116      	bne.n	801c4d0 <vj_compress_tcp+0x418>
 801c4a2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c4a4:	1c5a      	adds	r2, r3, #1
 801c4a6:	643a      	str	r2, [r7, #64]	; 0x40
 801c4a8:	2200      	movs	r2, #0
 801c4aa:	701a      	strb	r2, [r3, #0]
 801c4ac:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c4ae:	3301      	adds	r3, #1
 801c4b0:	214a      	movs	r1, #74	; 0x4a
 801c4b2:	187a      	adds	r2, r7, r1
 801c4b4:	8812      	ldrh	r2, [r2, #0]
 801c4b6:	b2d2      	uxtb	r2, r2
 801c4b8:	701a      	strb	r2, [r3, #0]
 801c4ba:	187b      	adds	r3, r7, r1
 801c4bc:	881b      	ldrh	r3, [r3, #0]
 801c4be:	0a1b      	lsrs	r3, r3, #8
 801c4c0:	b29b      	uxth	r3, r3
 801c4c2:	b2da      	uxtb	r2, r3
 801c4c4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c4c6:	701a      	strb	r2, [r3, #0]
 801c4c8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c4ca:	3302      	adds	r3, #2
 801c4cc:	643b      	str	r3, [r7, #64]	; 0x40
 801c4ce:	e007      	b.n	801c4e0 <vj_compress_tcp+0x428>
 801c4d0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c4d2:	1c5a      	adds	r2, r3, #1
 801c4d4:	643a      	str	r2, [r7, #64]	; 0x40
 801c4d6:	224a      	movs	r2, #74	; 0x4a
 801c4d8:	18ba      	adds	r2, r7, r2
 801c4da:	8812      	ldrh	r2, [r2, #0]
 801c4dc:	b2d2      	uxtb	r2, r2
 801c4de:	701a      	strb	r2, [r3, #0]
    changes |= NEW_U;
 801c4e0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c4e2:	2201      	movs	r2, #1
 801c4e4:	4313      	orrs	r3, r2
 801c4e6:	647b      	str	r3, [r7, #68]	; 0x44
 801c4e8:	e00e      	b.n	801c508 <vj_compress_tcp+0x450>
  } else if (th->urgp != oth->urgp) {
 801c4ea:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c4ec:	7c9a      	ldrb	r2, [r3, #18]
 801c4ee:	7cdb      	ldrb	r3, [r3, #19]
 801c4f0:	021b      	lsls	r3, r3, #8
 801c4f2:	4313      	orrs	r3, r2
 801c4f4:	b29a      	uxth	r2, r3
 801c4f6:	6a3b      	ldr	r3, [r7, #32]
 801c4f8:	7c99      	ldrb	r1, [r3, #18]
 801c4fa:	7cdb      	ldrb	r3, [r3, #19]
 801c4fc:	021b      	lsls	r3, r3, #8
 801c4fe:	430b      	orrs	r3, r1
 801c500:	b29b      	uxth	r3, r3
 801c502:	429a      	cmp	r2, r3
 801c504:	d000      	beq.n	801c508 <vj_compress_tcp+0x450>
 801c506:	e237      	b.n	801c978 <vj_compress_tcp+0x8c0>
     * doesn't prohibit the change so we have to deal
     * with it. */
    goto uncompressed;
  }

  if ((deltaS = (u16_t)(lwip_ntohs(th->wnd) - lwip_ntohs(oth->wnd))) != 0) {
 801c508:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c50a:	7b9a      	ldrb	r2, [r3, #14]
 801c50c:	7bdb      	ldrb	r3, [r3, #15]
 801c50e:	021b      	lsls	r3, r3, #8
 801c510:	4313      	orrs	r3, r2
 801c512:	b29b      	uxth	r3, r3
 801c514:	0018      	movs	r0, r3
 801c516:	f7ea ff73 	bl	8007400 <lwip_htons>
 801c51a:	0003      	movs	r3, r0
 801c51c:	001c      	movs	r4, r3
 801c51e:	6a3b      	ldr	r3, [r7, #32]
 801c520:	7b9a      	ldrb	r2, [r3, #14]
 801c522:	7bdb      	ldrb	r3, [r3, #15]
 801c524:	021b      	lsls	r3, r3, #8
 801c526:	4313      	orrs	r3, r2
 801c528:	b29b      	uxth	r3, r3
 801c52a:	0018      	movs	r0, r3
 801c52c:	f7ea ff68 	bl	8007400 <lwip_htons>
 801c530:	0003      	movs	r3, r0
 801c532:	001a      	movs	r2, r3
 801c534:	214a      	movs	r1, #74	; 0x4a
 801c536:	187b      	adds	r3, r7, r1
 801c538:	1aa2      	subs	r2, r4, r2
 801c53a:	801a      	strh	r2, [r3, #0]
 801c53c:	187b      	adds	r3, r7, r1
 801c53e:	881b      	ldrh	r3, [r3, #0]
 801c540:	2b00      	cmp	r3, #0
 801c542:	d025      	beq.n	801c590 <vj_compress_tcp+0x4d8>
    ENCODE(deltaS);
 801c544:	187b      	adds	r3, r7, r1
 801c546:	881b      	ldrh	r3, [r3, #0]
 801c548:	2bff      	cmp	r3, #255	; 0xff
 801c54a:	d915      	bls.n	801c578 <vj_compress_tcp+0x4c0>
 801c54c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c54e:	1c5a      	adds	r2, r3, #1
 801c550:	643a      	str	r2, [r7, #64]	; 0x40
 801c552:	2200      	movs	r2, #0
 801c554:	701a      	strb	r2, [r3, #0]
 801c556:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c558:	3301      	adds	r3, #1
 801c55a:	187a      	adds	r2, r7, r1
 801c55c:	8812      	ldrh	r2, [r2, #0]
 801c55e:	b2d2      	uxtb	r2, r2
 801c560:	701a      	strb	r2, [r3, #0]
 801c562:	187b      	adds	r3, r7, r1
 801c564:	881b      	ldrh	r3, [r3, #0]
 801c566:	0a1b      	lsrs	r3, r3, #8
 801c568:	b29b      	uxth	r3, r3
 801c56a:	b2da      	uxtb	r2, r3
 801c56c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c56e:	701a      	strb	r2, [r3, #0]
 801c570:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c572:	3302      	adds	r3, #2
 801c574:	643b      	str	r3, [r7, #64]	; 0x40
 801c576:	e007      	b.n	801c588 <vj_compress_tcp+0x4d0>
 801c578:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c57a:	1c5a      	adds	r2, r3, #1
 801c57c:	643a      	str	r2, [r7, #64]	; 0x40
 801c57e:	224a      	movs	r2, #74	; 0x4a
 801c580:	18ba      	adds	r2, r7, r2
 801c582:	8812      	ldrh	r2, [r2, #0]
 801c584:	b2d2      	uxtb	r2, r2
 801c586:	701a      	strb	r2, [r3, #0]
    changes |= NEW_W;
 801c588:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c58a:	2202      	movs	r2, #2
 801c58c:	4313      	orrs	r3, r2
 801c58e:	647b      	str	r3, [r7, #68]	; 0x44
  }

  if ((deltaL = lwip_ntohl(th->ackno) - lwip_ntohl(oth->ackno)) != 0) {
 801c590:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c592:	7a1a      	ldrb	r2, [r3, #8]
 801c594:	7a59      	ldrb	r1, [r3, #9]
 801c596:	0209      	lsls	r1, r1, #8
 801c598:	430a      	orrs	r2, r1
 801c59a:	7a99      	ldrb	r1, [r3, #10]
 801c59c:	0409      	lsls	r1, r1, #16
 801c59e:	430a      	orrs	r2, r1
 801c5a0:	7adb      	ldrb	r3, [r3, #11]
 801c5a2:	061b      	lsls	r3, r3, #24
 801c5a4:	4313      	orrs	r3, r2
 801c5a6:	0018      	movs	r0, r3
 801c5a8:	f7ea ff40 	bl	800742c <lwip_htonl>
 801c5ac:	0004      	movs	r4, r0
 801c5ae:	6a3b      	ldr	r3, [r7, #32]
 801c5b0:	7a1a      	ldrb	r2, [r3, #8]
 801c5b2:	7a59      	ldrb	r1, [r3, #9]
 801c5b4:	0209      	lsls	r1, r1, #8
 801c5b6:	430a      	orrs	r2, r1
 801c5b8:	7a99      	ldrb	r1, [r3, #10]
 801c5ba:	0409      	lsls	r1, r1, #16
 801c5bc:	430a      	orrs	r2, r1
 801c5be:	7adb      	ldrb	r3, [r3, #11]
 801c5c0:	061b      	lsls	r3, r3, #24
 801c5c2:	4313      	orrs	r3, r2
 801c5c4:	0018      	movs	r0, r3
 801c5c6:	f7ea ff31 	bl	800742c <lwip_htonl>
 801c5ca:	0003      	movs	r3, r0
 801c5cc:	1ae3      	subs	r3, r4, r3
 801c5ce:	61fb      	str	r3, [r7, #28]
 801c5d0:	69fb      	ldr	r3, [r7, #28]
 801c5d2:	2b00      	cmp	r3, #0
 801c5d4:	d02f      	beq.n	801c636 <vj_compress_tcp+0x57e>
    if (deltaL > 0xffff) {
 801c5d6:	69fa      	ldr	r2, [r7, #28]
 801c5d8:	2380      	movs	r3, #128	; 0x80
 801c5da:	025b      	lsls	r3, r3, #9
 801c5dc:	429a      	cmp	r2, r3
 801c5de:	d300      	bcc.n	801c5e2 <vj_compress_tcp+0x52a>
 801c5e0:	e1cc      	b.n	801c97c <vj_compress_tcp+0x8c4>
      goto uncompressed;
    }
    deltaA = (u16_t)deltaL;
 801c5e2:	2148      	movs	r1, #72	; 0x48
 801c5e4:	187b      	adds	r3, r7, r1
 801c5e6:	69fa      	ldr	r2, [r7, #28]
 801c5e8:	801a      	strh	r2, [r3, #0]
    ENCODE(deltaA);
 801c5ea:	187b      	adds	r3, r7, r1
 801c5ec:	881b      	ldrh	r3, [r3, #0]
 801c5ee:	2bff      	cmp	r3, #255	; 0xff
 801c5f0:	d915      	bls.n	801c61e <vj_compress_tcp+0x566>
 801c5f2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c5f4:	1c5a      	adds	r2, r3, #1
 801c5f6:	643a      	str	r2, [r7, #64]	; 0x40
 801c5f8:	2200      	movs	r2, #0
 801c5fa:	701a      	strb	r2, [r3, #0]
 801c5fc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c5fe:	3301      	adds	r3, #1
 801c600:	187a      	adds	r2, r7, r1
 801c602:	8812      	ldrh	r2, [r2, #0]
 801c604:	b2d2      	uxtb	r2, r2
 801c606:	701a      	strb	r2, [r3, #0]
 801c608:	187b      	adds	r3, r7, r1
 801c60a:	881b      	ldrh	r3, [r3, #0]
 801c60c:	0a1b      	lsrs	r3, r3, #8
 801c60e:	b29b      	uxth	r3, r3
 801c610:	b2da      	uxtb	r2, r3
 801c612:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c614:	701a      	strb	r2, [r3, #0]
 801c616:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c618:	3302      	adds	r3, #2
 801c61a:	643b      	str	r3, [r7, #64]	; 0x40
 801c61c:	e007      	b.n	801c62e <vj_compress_tcp+0x576>
 801c61e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c620:	1c5a      	adds	r2, r3, #1
 801c622:	643a      	str	r2, [r7, #64]	; 0x40
 801c624:	2248      	movs	r2, #72	; 0x48
 801c626:	18ba      	adds	r2, r7, r2
 801c628:	8812      	ldrh	r2, [r2, #0]
 801c62a:	b2d2      	uxtb	r2, r2
 801c62c:	701a      	strb	r2, [r3, #0]
    changes |= NEW_A;
 801c62e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c630:	2204      	movs	r2, #4
 801c632:	4313      	orrs	r3, r2
 801c634:	647b      	str	r3, [r7, #68]	; 0x44
  }

  if ((deltaL = lwip_ntohl(th->seqno) - lwip_ntohl(oth->seqno)) != 0) {
 801c636:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c638:	791a      	ldrb	r2, [r3, #4]
 801c63a:	7959      	ldrb	r1, [r3, #5]
 801c63c:	0209      	lsls	r1, r1, #8
 801c63e:	430a      	orrs	r2, r1
 801c640:	7999      	ldrb	r1, [r3, #6]
 801c642:	0409      	lsls	r1, r1, #16
 801c644:	430a      	orrs	r2, r1
 801c646:	79db      	ldrb	r3, [r3, #7]
 801c648:	061b      	lsls	r3, r3, #24
 801c64a:	4313      	orrs	r3, r2
 801c64c:	0018      	movs	r0, r3
 801c64e:	f7ea feed 	bl	800742c <lwip_htonl>
 801c652:	0004      	movs	r4, r0
 801c654:	6a3b      	ldr	r3, [r7, #32]
 801c656:	791a      	ldrb	r2, [r3, #4]
 801c658:	7959      	ldrb	r1, [r3, #5]
 801c65a:	0209      	lsls	r1, r1, #8
 801c65c:	430a      	orrs	r2, r1
 801c65e:	7999      	ldrb	r1, [r3, #6]
 801c660:	0409      	lsls	r1, r1, #16
 801c662:	430a      	orrs	r2, r1
 801c664:	79db      	ldrb	r3, [r3, #7]
 801c666:	061b      	lsls	r3, r3, #24
 801c668:	4313      	orrs	r3, r2
 801c66a:	0018      	movs	r0, r3
 801c66c:	f7ea fede 	bl	800742c <lwip_htonl>
 801c670:	0003      	movs	r3, r0
 801c672:	1ae3      	subs	r3, r4, r3
 801c674:	61fb      	str	r3, [r7, #28]
 801c676:	69fb      	ldr	r3, [r7, #28]
 801c678:	2b00      	cmp	r3, #0
 801c67a:	d02f      	beq.n	801c6dc <vj_compress_tcp+0x624>
    if (deltaL > 0xffff) {
 801c67c:	69fa      	ldr	r2, [r7, #28]
 801c67e:	2380      	movs	r3, #128	; 0x80
 801c680:	025b      	lsls	r3, r3, #9
 801c682:	429a      	cmp	r2, r3
 801c684:	d300      	bcc.n	801c688 <vj_compress_tcp+0x5d0>
 801c686:	e17b      	b.n	801c980 <vj_compress_tcp+0x8c8>
      goto uncompressed;
    }
    deltaS = (u16_t)deltaL;
 801c688:	214a      	movs	r1, #74	; 0x4a
 801c68a:	187b      	adds	r3, r7, r1
 801c68c:	69fa      	ldr	r2, [r7, #28]
 801c68e:	801a      	strh	r2, [r3, #0]
    ENCODE(deltaS);
 801c690:	187b      	adds	r3, r7, r1
 801c692:	881b      	ldrh	r3, [r3, #0]
 801c694:	2bff      	cmp	r3, #255	; 0xff
 801c696:	d915      	bls.n	801c6c4 <vj_compress_tcp+0x60c>
 801c698:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c69a:	1c5a      	adds	r2, r3, #1
 801c69c:	643a      	str	r2, [r7, #64]	; 0x40
 801c69e:	2200      	movs	r2, #0
 801c6a0:	701a      	strb	r2, [r3, #0]
 801c6a2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c6a4:	3301      	adds	r3, #1
 801c6a6:	187a      	adds	r2, r7, r1
 801c6a8:	8812      	ldrh	r2, [r2, #0]
 801c6aa:	b2d2      	uxtb	r2, r2
 801c6ac:	701a      	strb	r2, [r3, #0]
 801c6ae:	187b      	adds	r3, r7, r1
 801c6b0:	881b      	ldrh	r3, [r3, #0]
 801c6b2:	0a1b      	lsrs	r3, r3, #8
 801c6b4:	b29b      	uxth	r3, r3
 801c6b6:	b2da      	uxtb	r2, r3
 801c6b8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c6ba:	701a      	strb	r2, [r3, #0]
 801c6bc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c6be:	3302      	adds	r3, #2
 801c6c0:	643b      	str	r3, [r7, #64]	; 0x40
 801c6c2:	e007      	b.n	801c6d4 <vj_compress_tcp+0x61c>
 801c6c4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c6c6:	1c5a      	adds	r2, r3, #1
 801c6c8:	643a      	str	r2, [r7, #64]	; 0x40
 801c6ca:	224a      	movs	r2, #74	; 0x4a
 801c6cc:	18ba      	adds	r2, r7, r2
 801c6ce:	8812      	ldrh	r2, [r2, #0]
 801c6d0:	b2d2      	uxtb	r2, r2
 801c6d2:	701a      	strb	r2, [r3, #0]
    changes |= NEW_S;
 801c6d4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c6d6:	2208      	movs	r2, #8
 801c6d8:	4313      	orrs	r3, r2
 801c6da:	647b      	str	r3, [r7, #68]	; 0x44
 801c6dc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c6de:	2b0f      	cmp	r3, #15
 801c6e0:	d851      	bhi.n	801c786 <vj_compress_tcp+0x6ce>
 801c6e2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c6e4:	009a      	lsls	r2, r3, #2
 801c6e6:	4bb3      	ldr	r3, [pc, #716]	; (801c9b4 <vj_compress_tcp+0x8fc>)
 801c6e8:	18d3      	adds	r3, r2, r3
 801c6ea:	681b      	ldr	r3, [r3, #0]
 801c6ec:	469f      	mov	pc, r3
     * an ack (normal on an interactive connection) and we send
     * it compressed.  Otherwise it's probably a retransmit,
     * retransmitted ack or window probe.  Send it uncompressed
     * in case the other side missed the compressed version.
     */
    if (IPH_LEN(ip) != IPH_LEN(&cs->cs_ip) &&
 801c6ee:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c6f0:	789a      	ldrb	r2, [r3, #2]
 801c6f2:	78db      	ldrb	r3, [r3, #3]
 801c6f4:	021b      	lsls	r3, r3, #8
 801c6f6:	4313      	orrs	r3, r2
 801c6f8:	b29a      	uxth	r2, r3
 801c6fa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c6fc:	895b      	ldrh	r3, [r3, #10]
 801c6fe:	429a      	cmp	r2, r3
 801c700:	d100      	bne.n	801c704 <vj_compress_tcp+0x64c>
 801c702:	e13f      	b.n	801c984 <vj_compress_tcp+0x8cc>
      lwip_ntohs(IPH_LEN(&cs->cs_ip)) == hlen) {
 801c704:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c706:	895b      	ldrh	r3, [r3, #10]
 801c708:	0018      	movs	r0, r3
 801c70a:	f7ea fe79 	bl	8007400 <lwip_htons>
 801c70e:	0003      	movs	r3, r0
 801c710:	001a      	movs	r2, r3
    if (IPH_LEN(ip) != IPH_LEN(&cs->cs_ip) &&
 801c712:	232e      	movs	r3, #46	; 0x2e
 801c714:	18fb      	adds	r3, r7, r3
 801c716:	881b      	ldrh	r3, [r3, #0]
 801c718:	4293      	cmp	r3, r2
 801c71a:	d000      	beq.n	801c71e <vj_compress_tcp+0x666>
 801c71c:	e132      	b.n	801c984 <vj_compress_tcp+0x8cc>
      break;
 801c71e:	e037      	b.n	801c790 <vj_compress_tcp+0x6d8>
     * send packet uncompressed.
     */
    goto uncompressed;

  case NEW_S|NEW_A:
    if (deltaS == deltaA && deltaS == lwip_ntohs(IPH_LEN(&cs->cs_ip)) - hlen) {
 801c720:	214a      	movs	r1, #74	; 0x4a
 801c722:	187a      	adds	r2, r7, r1
 801c724:	2348      	movs	r3, #72	; 0x48
 801c726:	18fb      	adds	r3, r7, r3
 801c728:	8812      	ldrh	r2, [r2, #0]
 801c72a:	881b      	ldrh	r3, [r3, #0]
 801c72c:	429a      	cmp	r2, r3
 801c72e:	d12c      	bne.n	801c78a <vj_compress_tcp+0x6d2>
 801c730:	187b      	adds	r3, r7, r1
 801c732:	881c      	ldrh	r4, [r3, #0]
 801c734:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c736:	895b      	ldrh	r3, [r3, #10]
 801c738:	0018      	movs	r0, r3
 801c73a:	f7ea fe61 	bl	8007400 <lwip_htons>
 801c73e:	0003      	movs	r3, r0
 801c740:	001a      	movs	r2, r3
 801c742:	232e      	movs	r3, #46	; 0x2e
 801c744:	18fb      	adds	r3, r7, r3
 801c746:	881b      	ldrh	r3, [r3, #0]
 801c748:	1ad3      	subs	r3, r2, r3
 801c74a:	429c      	cmp	r4, r3
 801c74c:	d11d      	bne.n	801c78a <vj_compress_tcp+0x6d2>
      /* special case for echoed terminal traffic */
      changes = SPECIAL_I;
 801c74e:	230b      	movs	r3, #11
 801c750:	647b      	str	r3, [r7, #68]	; 0x44
      cp = new_seq;
 801c752:	230c      	movs	r3, #12
 801c754:	18fb      	adds	r3, r7, r3
 801c756:	643b      	str	r3, [r7, #64]	; 0x40
    }
    break;
 801c758:	e017      	b.n	801c78a <vj_compress_tcp+0x6d2>

  case NEW_S:
    if (deltaS == lwip_ntohs(IPH_LEN(&cs->cs_ip)) - hlen) {
 801c75a:	234a      	movs	r3, #74	; 0x4a
 801c75c:	18fb      	adds	r3, r7, r3
 801c75e:	881c      	ldrh	r4, [r3, #0]
 801c760:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c762:	895b      	ldrh	r3, [r3, #10]
 801c764:	0018      	movs	r0, r3
 801c766:	f7ea fe4b 	bl	8007400 <lwip_htons>
 801c76a:	0003      	movs	r3, r0
 801c76c:	001a      	movs	r2, r3
 801c76e:	232e      	movs	r3, #46	; 0x2e
 801c770:	18fb      	adds	r3, r7, r3
 801c772:	881b      	ldrh	r3, [r3, #0]
 801c774:	1ad3      	subs	r3, r2, r3
 801c776:	429c      	cmp	r4, r3
 801c778:	d109      	bne.n	801c78e <vj_compress_tcp+0x6d6>
      /* special case for data xfer */
      changes = SPECIAL_D;
 801c77a:	230f      	movs	r3, #15
 801c77c:	647b      	str	r3, [r7, #68]	; 0x44
      cp = new_seq;
 801c77e:	230c      	movs	r3, #12
 801c780:	18fb      	adds	r3, r7, r3
 801c782:	643b      	str	r3, [r7, #64]	; 0x40
    }
    break;
 801c784:	e003      	b.n	801c78e <vj_compress_tcp+0x6d6>
  default:
     break;
 801c786:	46c0      	nop			; (mov r8, r8)
 801c788:	e002      	b.n	801c790 <vj_compress_tcp+0x6d8>
    break;
 801c78a:	46c0      	nop			; (mov r8, r8)
 801c78c:	e000      	b.n	801c790 <vj_compress_tcp+0x6d8>
    break;
 801c78e:	46c0      	nop			; (mov r8, r8)
  }

  deltaS = (u16_t)(lwip_ntohs(IPH_ID(ip)) - lwip_ntohs(IPH_ID(&cs->cs_ip)));
 801c790:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c792:	791a      	ldrb	r2, [r3, #4]
 801c794:	795b      	ldrb	r3, [r3, #5]
 801c796:	021b      	lsls	r3, r3, #8
 801c798:	4313      	orrs	r3, r2
 801c79a:	b29b      	uxth	r3, r3
 801c79c:	0018      	movs	r0, r3
 801c79e:	f7ea fe2f 	bl	8007400 <lwip_htons>
 801c7a2:	0003      	movs	r3, r0
 801c7a4:	001c      	movs	r4, r3
 801c7a6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c7a8:	899b      	ldrh	r3, [r3, #12]
 801c7aa:	0018      	movs	r0, r3
 801c7ac:	f7ea fe28 	bl	8007400 <lwip_htons>
 801c7b0:	0003      	movs	r3, r0
 801c7b2:	001a      	movs	r2, r3
 801c7b4:	214a      	movs	r1, #74	; 0x4a
 801c7b6:	187b      	adds	r3, r7, r1
 801c7b8:	1aa2      	subs	r2, r4, r2
 801c7ba:	801a      	strh	r2, [r3, #0]
  if (deltaS != 1) {
 801c7bc:	187b      	adds	r3, r7, r1
 801c7be:	881b      	ldrh	r3, [r3, #0]
 801c7c0:	2b01      	cmp	r3, #1
 801c7c2:	d02a      	beq.n	801c81a <vj_compress_tcp+0x762>
    ENCODEZ(deltaS);
 801c7c4:	187b      	adds	r3, r7, r1
 801c7c6:	881b      	ldrh	r3, [r3, #0]
 801c7c8:	2bff      	cmp	r3, #255	; 0xff
 801c7ca:	d803      	bhi.n	801c7d4 <vj_compress_tcp+0x71c>
 801c7cc:	187b      	adds	r3, r7, r1
 801c7ce:	881b      	ldrh	r3, [r3, #0]
 801c7d0:	2b00      	cmp	r3, #0
 801c7d2:	d116      	bne.n	801c802 <vj_compress_tcp+0x74a>
 801c7d4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c7d6:	1c5a      	adds	r2, r3, #1
 801c7d8:	643a      	str	r2, [r7, #64]	; 0x40
 801c7da:	2200      	movs	r2, #0
 801c7dc:	701a      	strb	r2, [r3, #0]
 801c7de:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c7e0:	3301      	adds	r3, #1
 801c7e2:	214a      	movs	r1, #74	; 0x4a
 801c7e4:	187a      	adds	r2, r7, r1
 801c7e6:	8812      	ldrh	r2, [r2, #0]
 801c7e8:	b2d2      	uxtb	r2, r2
 801c7ea:	701a      	strb	r2, [r3, #0]
 801c7ec:	187b      	adds	r3, r7, r1
 801c7ee:	881b      	ldrh	r3, [r3, #0]
 801c7f0:	0a1b      	lsrs	r3, r3, #8
 801c7f2:	b29b      	uxth	r3, r3
 801c7f4:	b2da      	uxtb	r2, r3
 801c7f6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c7f8:	701a      	strb	r2, [r3, #0]
 801c7fa:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c7fc:	3302      	adds	r3, #2
 801c7fe:	643b      	str	r3, [r7, #64]	; 0x40
 801c800:	e007      	b.n	801c812 <vj_compress_tcp+0x75a>
 801c802:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c804:	1c5a      	adds	r2, r3, #1
 801c806:	643a      	str	r2, [r7, #64]	; 0x40
 801c808:	224a      	movs	r2, #74	; 0x4a
 801c80a:	18ba      	adds	r2, r7, r2
 801c80c:	8812      	ldrh	r2, [r2, #0]
 801c80e:	b2d2      	uxtb	r2, r2
 801c810:	701a      	strb	r2, [r3, #0]
    changes |= NEW_I;
 801c812:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c814:	2220      	movs	r2, #32
 801c816:	4313      	orrs	r3, r2
 801c818:	647b      	str	r3, [r7, #68]	; 0x44
  }
  if (TCPH_FLAGS(th) & TCP_PSH) {
 801c81a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c81c:	7b1a      	ldrb	r2, [r3, #12]
 801c81e:	7b5b      	ldrb	r3, [r3, #13]
 801c820:	021b      	lsls	r3, r3, #8
 801c822:	4313      	orrs	r3, r2
 801c824:	b29b      	uxth	r3, r3
 801c826:	0018      	movs	r0, r3
 801c828:	f7ea fdea 	bl	8007400 <lwip_htons>
 801c82c:	0003      	movs	r3, r0
 801c82e:	b2db      	uxtb	r3, r3
 801c830:	001a      	movs	r2, r3
 801c832:	2308      	movs	r3, #8
 801c834:	4013      	ands	r3, r2
 801c836:	d003      	beq.n	801c840 <vj_compress_tcp+0x788>
    changes |= TCP_PUSH_BIT;
 801c838:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c83a:	2210      	movs	r2, #16
 801c83c:	4313      	orrs	r3, r2
 801c83e:	647b      	str	r3, [r7, #68]	; 0x44
  }
  /*
   * Grab the cksum before we overwrite it below.  Then update our
   * state with this packet's header.
   */
  deltaA = lwip_ntohs(th->chksum);
 801c840:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c842:	7c1a      	ldrb	r2, [r3, #16]
 801c844:	7c5b      	ldrb	r3, [r3, #17]
 801c846:	021b      	lsls	r3, r3, #8
 801c848:	4313      	orrs	r3, r2
 801c84a:	b29b      	uxth	r3, r3
 801c84c:	2248      	movs	r2, #72	; 0x48
 801c84e:	18bc      	adds	r4, r7, r2
 801c850:	0018      	movs	r0, r3
 801c852:	f7ea fdd5 	bl	8007400 <lwip_htons>
 801c856:	0003      	movs	r3, r0
 801c858:	8023      	strh	r3, [r4, #0]
  MEMCPY(&cs->cs_ip, ip, hlen);
 801c85a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c85c:	3308      	adds	r3, #8
 801c85e:	0018      	movs	r0, r3
 801c860:	232e      	movs	r3, #46	; 0x2e
 801c862:	18fb      	adds	r3, r7, r3
 801c864:	881a      	ldrh	r2, [r3, #0]
 801c866:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c868:	0019      	movs	r1, r3
 801c86a:	f001 fb97 	bl	801df9c <memcpy>
   * mask, one for the connection id and two for the tcp checksum.
   * So, (cp - new_seq) + 4 bytes of header are needed.  hlen is how
   * many bytes of the original packet to toss so subtract the two to
   * get the new packet size.
   */
  deltaS = (u16_t)(cp - new_seq);
 801c86e:	230c      	movs	r3, #12
 801c870:	18fb      	adds	r3, r7, r3
 801c872:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801c874:	1ad2      	subs	r2, r2, r3
 801c876:	234a      	movs	r3, #74	; 0x4a
 801c878:	18fb      	adds	r3, r7, r3
 801c87a:	801a      	strh	r2, [r3, #0]
  if (!comp->compressSlot || comp->last_xmit != cs->cs_id) {
 801c87c:	687b      	ldr	r3, [r7, #4]
 801c87e:	7a5b      	ldrb	r3, [r3, #9]
 801c880:	2b00      	cmp	r3, #0
 801c882:	d005      	beq.n	801c890 <vj_compress_tcp+0x7d8>
 801c884:	687b      	ldr	r3, [r7, #4]
 801c886:	795a      	ldrb	r2, [r3, #5]
 801c888:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c88a:	799b      	ldrb	r3, [r3, #6]
 801c88c:	429a      	cmp	r2, r3
 801c88e:	d031      	beq.n	801c8f4 <vj_compress_tcp+0x83c>
    comp->last_xmit = cs->cs_id;
 801c890:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c892:	799a      	ldrb	r2, [r3, #6]
 801c894:	687b      	ldr	r3, [r7, #4]
 801c896:	715a      	strb	r2, [r3, #5]
    hlen -= deltaS + 4;
 801c898:	212e      	movs	r1, #46	; 0x2e
 801c89a:	187a      	adds	r2, r7, r1
 801c89c:	234a      	movs	r3, #74	; 0x4a
 801c89e:	18fb      	adds	r3, r7, r3
 801c8a0:	8812      	ldrh	r2, [r2, #0]
 801c8a2:	881b      	ldrh	r3, [r3, #0]
 801c8a4:	1ad3      	subs	r3, r2, r3
 801c8a6:	b29a      	uxth	r2, r3
 801c8a8:	187b      	adds	r3, r7, r1
 801c8aa:	3a04      	subs	r2, #4
 801c8ac:	801a      	strh	r2, [r3, #0]
    if (pbuf_remove_header(np, hlen)){
 801c8ae:	187b      	adds	r3, r7, r1
 801c8b0:	881a      	ldrh	r2, [r3, #0]
 801c8b2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c8b4:	0011      	movs	r1, r2
 801c8b6:	0018      	movs	r0, r3
 801c8b8:	f7ed fd7a 	bl	800a3b0 <pbuf_remove_header>
 801c8bc:	1e03      	subs	r3, r0, #0
 801c8be:	d006      	beq.n	801c8ce <vj_compress_tcp+0x816>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_remove_header failed\n", 0);
 801c8c0:	4b3d      	ldr	r3, [pc, #244]	; (801c9b8 <vj_compress_tcp+0x900>)
 801c8c2:	22ce      	movs	r2, #206	; 0xce
 801c8c4:	0052      	lsls	r2, r2, #1
 801c8c6:	493d      	ldr	r1, [pc, #244]	; (801c9bc <vj_compress_tcp+0x904>)
 801c8c8:	483d      	ldr	r0, [pc, #244]	; (801c9c0 <vj_compress_tcp+0x908>)
 801c8ca:	f7e5 fc8b 	bl	80021e4 <app_debug_rtt_raw>
    }
    cp = (u8_t*)np->payload;
 801c8ce:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c8d0:	685b      	ldr	r3, [r3, #4]
 801c8d2:	643b      	str	r3, [r7, #64]	; 0x40
    *cp++ = (u8_t)(changes | NEW_C);
 801c8d4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c8d6:	b2da      	uxtb	r2, r3
 801c8d8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c8da:	1c59      	adds	r1, r3, #1
 801c8dc:	6439      	str	r1, [r7, #64]	; 0x40
 801c8de:	2140      	movs	r1, #64	; 0x40
 801c8e0:	430a      	orrs	r2, r1
 801c8e2:	b2d2      	uxtb	r2, r2
 801c8e4:	701a      	strb	r2, [r3, #0]
    *cp++ = cs->cs_id;
 801c8e6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c8e8:	1c5a      	adds	r2, r3, #1
 801c8ea:	643a      	str	r2, [r7, #64]	; 0x40
 801c8ec:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801c8ee:	7992      	ldrb	r2, [r2, #6]
 801c8f0:	701a      	strb	r2, [r3, #0]
 801c8f2:	e023      	b.n	801c93c <vj_compress_tcp+0x884>
  } else {
    hlen -= deltaS + 3;
 801c8f4:	212e      	movs	r1, #46	; 0x2e
 801c8f6:	187a      	adds	r2, r7, r1
 801c8f8:	234a      	movs	r3, #74	; 0x4a
 801c8fa:	18fb      	adds	r3, r7, r3
 801c8fc:	8812      	ldrh	r2, [r2, #0]
 801c8fe:	881b      	ldrh	r3, [r3, #0]
 801c900:	1ad3      	subs	r3, r2, r3
 801c902:	b29a      	uxth	r2, r3
 801c904:	187b      	adds	r3, r7, r1
 801c906:	3a03      	subs	r2, #3
 801c908:	801a      	strh	r2, [r3, #0]
    if (pbuf_remove_header(np, hlen)) {
 801c90a:	187b      	adds	r3, r7, r1
 801c90c:	881a      	ldrh	r2, [r3, #0]
 801c90e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c910:	0011      	movs	r1, r2
 801c912:	0018      	movs	r0, r3
 801c914:	f7ed fd4c 	bl	800a3b0 <pbuf_remove_header>
 801c918:	1e03      	subs	r3, r0, #0
 801c91a:	d006      	beq.n	801c92a <vj_compress_tcp+0x872>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_remove_header failed\n", 0);
 801c91c:	4b26      	ldr	r3, [pc, #152]	; (801c9b8 <vj_compress_tcp+0x900>)
 801c91e:	22a6      	movs	r2, #166	; 0xa6
 801c920:	32ff      	adds	r2, #255	; 0xff
 801c922:	4926      	ldr	r1, [pc, #152]	; (801c9bc <vj_compress_tcp+0x904>)
 801c924:	4826      	ldr	r0, [pc, #152]	; (801c9c0 <vj_compress_tcp+0x908>)
 801c926:	f7e5 fc5d 	bl	80021e4 <app_debug_rtt_raw>
    }
    cp = (u8_t*)np->payload;
 801c92a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c92c:	685b      	ldr	r3, [r3, #4]
 801c92e:	643b      	str	r3, [r7, #64]	; 0x40
    *cp++ = (u8_t)changes;
 801c930:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c932:	1c5a      	adds	r2, r3, #1
 801c934:	643a      	str	r2, [r7, #64]	; 0x40
 801c936:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801c938:	b2d2      	uxtb	r2, r2
 801c93a:	701a      	strb	r2, [r3, #0]
  }
  *cp++ = (u8_t)(deltaA >> 8);
 801c93c:	2048      	movs	r0, #72	; 0x48
 801c93e:	183b      	adds	r3, r7, r0
 801c940:	881b      	ldrh	r3, [r3, #0]
 801c942:	0a1b      	lsrs	r3, r3, #8
 801c944:	b299      	uxth	r1, r3
 801c946:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c948:	1c5a      	adds	r2, r3, #1
 801c94a:	643a      	str	r2, [r7, #64]	; 0x40
 801c94c:	b2ca      	uxtb	r2, r1
 801c94e:	701a      	strb	r2, [r3, #0]
  *cp++ = (u8_t)deltaA;
 801c950:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c952:	1c5a      	adds	r2, r3, #1
 801c954:	643a      	str	r2, [r7, #64]	; 0x40
 801c956:	183a      	adds	r2, r7, r0
 801c958:	8812      	ldrh	r2, [r2, #0]
 801c95a:	b2d2      	uxtb	r2, r2
 801c95c:	701a      	strb	r2, [r3, #0]
  MEMCPY(cp, new_seq, deltaS);
 801c95e:	234a      	movs	r3, #74	; 0x4a
 801c960:	18fb      	adds	r3, r7, r3
 801c962:	881a      	ldrh	r2, [r3, #0]
 801c964:	230c      	movs	r3, #12
 801c966:	18f9      	adds	r1, r7, r3
 801c968:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c96a:	0018      	movs	r0, r3
 801c96c:	f001 fb16 	bl	801df9c <memcpy>
  INCR(vjs_compressed);
  return (TYPE_COMPRESSED_TCP);
 801c970:	2380      	movs	r3, #128	; 0x80
 801c972:	e01b      	b.n	801c9ac <vj_compress_tcp+0x8f4>
    goto uncompressed;
 801c974:	46c0      	nop			; (mov r8, r8)
 801c976:	e006      	b.n	801c986 <vj_compress_tcp+0x8ce>
    goto uncompressed;
 801c978:	46c0      	nop			; (mov r8, r8)
 801c97a:	e004      	b.n	801c986 <vj_compress_tcp+0x8ce>
      goto uncompressed;
 801c97c:	46c0      	nop			; (mov r8, r8)
 801c97e:	e002      	b.n	801c986 <vj_compress_tcp+0x8ce>
      goto uncompressed;
 801c980:	46c0      	nop			; (mov r8, r8)
 801c982:	e000      	b.n	801c986 <vj_compress_tcp+0x8ce>
    goto uncompressed;
 801c984:	46c0      	nop			; (mov r8, r8)
   * Update connection state cs & send uncompressed packet (that is,
   * a regular ip/tcp packet but with the 'conversation id' we hope
   * to use on future compressed packets in the protocol field).
   */
uncompressed:
  MEMCPY(&cs->cs_ip, ip, hlen);
 801c986:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c988:	3308      	adds	r3, #8
 801c98a:	0018      	movs	r0, r3
 801c98c:	232e      	movs	r3, #46	; 0x2e
 801c98e:	18fb      	adds	r3, r7, r3
 801c990:	881a      	ldrh	r2, [r3, #0]
 801c992:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c994:	0019      	movs	r1, r3
 801c996:	f001 fb01 	bl	801df9c <memcpy>
  IPH_PROTO_SET(ip, cs->cs_id);
 801c99a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c99c:	799a      	ldrb	r2, [r3, #6]
 801c99e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c9a0:	725a      	strb	r2, [r3, #9]
  comp->last_xmit = cs->cs_id;
 801c9a2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c9a4:	799a      	ldrb	r2, [r3, #6]
 801c9a6:	687b      	ldr	r3, [r7, #4]
 801c9a8:	715a      	strb	r2, [r3, #5]
  return (TYPE_UNCOMPRESSED_TCP);
 801c9aa:	2370      	movs	r3, #112	; 0x70
}
 801c9ac:	0018      	movs	r0, r3
 801c9ae:	46bd      	mov	sp, r7
 801c9b0:	b014      	add	sp, #80	; 0x50
 801c9b2:	bdb0      	pop	{r4, r5, r7, pc}
 801c9b4:	08024028 	.word	0x08024028
 801c9b8:	08022ca0 	.word	0x08022ca0
 801c9bc:	08022ccc 	.word	0x08022ccc
 801c9c0:	08022ce8 	.word	0x08022ce8

0801c9c4 <vj_uncompress_err>:
/*
 * Called when we may have missed a packet.
 */
void
vj_uncompress_err(struct vjcompress *comp)
{
 801c9c4:	b580      	push	{r7, lr}
 801c9c6:	b082      	sub	sp, #8
 801c9c8:	af00      	add	r7, sp, #0
 801c9ca:	6078      	str	r0, [r7, #4]
  comp->flags |= VJF_TOSS;
 801c9cc:	687b      	ldr	r3, [r7, #4]
 801c9ce:	88db      	ldrh	r3, [r3, #6]
 801c9d0:	2201      	movs	r2, #1
 801c9d2:	4313      	orrs	r3, r2
 801c9d4:	b29a      	uxth	r2, r3
 801c9d6:	687b      	ldr	r3, [r7, #4]
 801c9d8:	80da      	strh	r2, [r3, #6]
  INCR(vjs_errorin);
}
 801c9da:	46c0      	nop			; (mov r8, r8)
 801c9dc:	46bd      	mov	sp, r7
 801c9de:	b002      	add	sp, #8
 801c9e0:	bd80      	pop	{r7, pc}
	...

0801c9e4 <vj_uncompress_uncomp>:
 * "Uncompress" a packet of type TYPE_UNCOMPRESSED_TCP.
 * Return 0 on success, -1 on failure.
 */
int
vj_uncompress_uncomp(struct pbuf *nb, struct vjcompress *comp)
{
 801c9e4:	b580      	push	{r7, lr}
 801c9e6:	b086      	sub	sp, #24
 801c9e8:	af00      	add	r7, sp, #0
 801c9ea:	6078      	str	r0, [r7, #4]
 801c9ec:	6039      	str	r1, [r7, #0]
  u32_t hlen;
  struct cstate *cs;
  struct ip_hdr *ip;

  ip = (struct ip_hdr *)nb->payload;
 801c9ee:	687b      	ldr	r3, [r7, #4]
 801c9f0:	685b      	ldr	r3, [r3, #4]
 801c9f2:	617b      	str	r3, [r7, #20]
  hlen = IPH_HL(ip) << 2;
 801c9f4:	697b      	ldr	r3, [r7, #20]
 801c9f6:	781b      	ldrb	r3, [r3, #0]
 801c9f8:	009b      	lsls	r3, r3, #2
 801c9fa:	001a      	movs	r2, r3
 801c9fc:	233c      	movs	r3, #60	; 0x3c
 801c9fe:	4013      	ands	r3, r2
 801ca00:	613b      	str	r3, [r7, #16]
  if (IPH_PROTO(ip) >= MAX_SLOTS
 801ca02:	697b      	ldr	r3, [r7, #20]
 801ca04:	7a5b      	ldrb	r3, [r3, #9]
 801ca06:	2b0f      	cmp	r3, #15
 801ca08:	d823      	bhi.n	801ca52 <vj_uncompress_uncomp+0x6e>
      || hlen + sizeof(struct tcp_hdr) > nb->len
 801ca0a:	693b      	ldr	r3, [r7, #16]
 801ca0c:	3314      	adds	r3, #20
 801ca0e:	687a      	ldr	r2, [r7, #4]
 801ca10:	8952      	ldrh	r2, [r2, #10]
 801ca12:	4293      	cmp	r3, r2
 801ca14:	d81d      	bhi.n	801ca52 <vj_uncompress_uncomp+0x6e>
      || (hlen += TCPH_HDRLEN_BYTES((struct tcp_hdr *)&((char *)ip)[hlen]))
 801ca16:	697a      	ldr	r2, [r7, #20]
 801ca18:	693b      	ldr	r3, [r7, #16]
 801ca1a:	18d3      	adds	r3, r2, r3
 801ca1c:	7b1a      	ldrb	r2, [r3, #12]
 801ca1e:	7b5b      	ldrb	r3, [r3, #13]
 801ca20:	021b      	lsls	r3, r3, #8
 801ca22:	4313      	orrs	r3, r2
 801ca24:	b29b      	uxth	r3, r3
 801ca26:	0018      	movs	r0, r3
 801ca28:	f7ea fcea 	bl	8007400 <lwip_htons>
 801ca2c:	0003      	movs	r3, r0
 801ca2e:	0b1b      	lsrs	r3, r3, #12
 801ca30:	b29b      	uxth	r3, r3
 801ca32:	b2db      	uxtb	r3, r3
 801ca34:	009b      	lsls	r3, r3, #2
 801ca36:	b2db      	uxtb	r3, r3
 801ca38:	001a      	movs	r2, r3
 801ca3a:	693b      	ldr	r3, [r7, #16]
 801ca3c:	189b      	adds	r3, r3, r2
 801ca3e:	613b      	str	r3, [r7, #16]
          > nb->len
 801ca40:	687b      	ldr	r3, [r7, #4]
 801ca42:	895b      	ldrh	r3, [r3, #10]
 801ca44:	001a      	movs	r2, r3
      || (hlen += TCPH_HDRLEN_BYTES((struct tcp_hdr *)&((char *)ip)[hlen]))
 801ca46:	693b      	ldr	r3, [r7, #16]
 801ca48:	4293      	cmp	r3, r2
 801ca4a:	d802      	bhi.n	801ca52 <vj_uncompress_uncomp+0x6e>
      || hlen > MAX_HDR) {
 801ca4c:	693b      	ldr	r3, [r7, #16]
 801ca4e:	2b80      	cmp	r3, #128	; 0x80
 801ca50:	d906      	bls.n	801ca60 <vj_uncompress_uncomp+0x7c>
    PPPDEBUG(LOG_INFO, ("vj_uncompress_uncomp: bad cid=%d, hlen=%d buflen=%d\n",
      IPH_PROTO(ip), hlen, nb->len));
    vj_uncompress_err(comp);
 801ca52:	683b      	ldr	r3, [r7, #0]
 801ca54:	0018      	movs	r0, r3
 801ca56:	f7ff ffb5 	bl	801c9c4 <vj_uncompress_err>
    return -1;
 801ca5a:	2301      	movs	r3, #1
 801ca5c:	425b      	negs	r3, r3
 801ca5e:	e029      	b.n	801cab4 <vj_uncompress_uncomp+0xd0>
  }
  cs = &comp->rstate[comp->last_recv = IPH_PROTO(ip)];
 801ca60:	697b      	ldr	r3, [r7, #20]
 801ca62:	7a5a      	ldrb	r2, [r3, #9]
 801ca64:	683b      	ldr	r3, [r7, #0]
 801ca66:	711a      	strb	r2, [r3, #4]
 801ca68:	683b      	ldr	r3, [r7, #0]
 801ca6a:	791b      	ldrb	r3, [r3, #4]
 801ca6c:	001a      	movs	r2, r3
 801ca6e:	0013      	movs	r3, r2
 801ca70:	011b      	lsls	r3, r3, #4
 801ca72:	189b      	adds	r3, r3, r2
 801ca74:	00db      	lsls	r3, r3, #3
 801ca76:	4a11      	ldr	r2, [pc, #68]	; (801cabc <vj_uncompress_uncomp+0xd8>)
 801ca78:	4694      	mov	ip, r2
 801ca7a:	4463      	add	r3, ip
 801ca7c:	683a      	ldr	r2, [r7, #0]
 801ca7e:	18d3      	adds	r3, r2, r3
 801ca80:	3304      	adds	r3, #4
 801ca82:	60fb      	str	r3, [r7, #12]
  comp->flags &=~ VJF_TOSS;
 801ca84:	683b      	ldr	r3, [r7, #0]
 801ca86:	88db      	ldrh	r3, [r3, #6]
 801ca88:	2201      	movs	r2, #1
 801ca8a:	4393      	bics	r3, r2
 801ca8c:	b29a      	uxth	r2, r3
 801ca8e:	683b      	ldr	r3, [r7, #0]
 801ca90:	80da      	strh	r2, [r3, #6]
  IPH_PROTO_SET(ip, IP_PROTO_TCP);
 801ca92:	697b      	ldr	r3, [r7, #20]
 801ca94:	2206      	movs	r2, #6
 801ca96:	725a      	strb	r2, [r3, #9]
  /* copy from/to bigger buffers checked above instead of cs->cs_ip and ip
     just to help static code analysis to see this is correct ;-) */
  MEMCPY(&cs->cs_hdr, nb->payload, hlen);
 801ca98:	68fb      	ldr	r3, [r7, #12]
 801ca9a:	3308      	adds	r3, #8
 801ca9c:	0018      	movs	r0, r3
 801ca9e:	687b      	ldr	r3, [r7, #4]
 801caa0:	685b      	ldr	r3, [r3, #4]
 801caa2:	693a      	ldr	r2, [r7, #16]
 801caa4:	0019      	movs	r1, r3
 801caa6:	f001 fa79 	bl	801df9c <memcpy>
  cs->cs_hlen = (u16_t)hlen;
 801caaa:	693b      	ldr	r3, [r7, #16]
 801caac:	b29a      	uxth	r2, r3
 801caae:	68fb      	ldr	r3, [r7, #12]
 801cab0:	809a      	strh	r2, [r3, #4]
  INCR(vjs_uncompressedin);
  return 0;
 801cab2:	2300      	movs	r3, #0
}
 801cab4:	0018      	movs	r0, r3
 801cab6:	46bd      	mov	sp, r7
 801cab8:	b006      	add	sp, #24
 801caba:	bd80      	pop	{r7, pc}
 801cabc:	00000888 	.word	0x00000888

0801cac0 <vj_uncompress_tcp>:
 * This procedure replaces the compressed header with the uncompressed
 * header and returns the length of the VJ header.
 */
int
vj_uncompress_tcp(struct pbuf **nb, struct vjcompress *comp)
{
 801cac0:	b590      	push	{r4, r7, lr}
 801cac2:	b095      	sub	sp, #84	; 0x54
 801cac4:	af00      	add	r7, sp, #0
 801cac6:	6078      	str	r0, [r7, #4]
 801cac8:	6039      	str	r1, [r7, #0]
  u8_t *cp;
  struct tcp_hdr *th;
  struct cstate *cs;
  struct vj_u16_t *bp;
  struct pbuf *n0 = *nb;
 801caca:	687b      	ldr	r3, [r7, #4]
 801cacc:	681b      	ldr	r3, [r3, #0]
 801cace:	647b      	str	r3, [r7, #68]	; 0x44
  u32_t tmp;
  u32_t vjlen, hlen, changes;

  INCR(vjs_compressedin);
  cp = (u8_t*)n0->payload;
 801cad0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801cad2:	685b      	ldr	r3, [r3, #4]
 801cad4:	64fb      	str	r3, [r7, #76]	; 0x4c
  changes = *cp++;
 801cad6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801cad8:	1c5a      	adds	r2, r3, #1
 801cada:	64fa      	str	r2, [r7, #76]	; 0x4c
 801cadc:	781b      	ldrb	r3, [r3, #0]
 801cade:	63bb      	str	r3, [r7, #56]	; 0x38
  if (changes & NEW_C) {
 801cae0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801cae2:	2240      	movs	r2, #64	; 0x40
 801cae4:	4013      	ands	r3, r2
 801cae6:	d013      	beq.n	801cb10 <vj_uncompress_tcp+0x50>
    /*
     * Make sure the state index is in range, then grab the state.
     * If we have a good state index, clear the 'discard' flag.
     */
    if (*cp >= MAX_SLOTS) {
 801cae8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801caea:	781b      	ldrb	r3, [r3, #0]
 801caec:	2b0f      	cmp	r3, #15
 801caee:	d901      	bls.n	801caf4 <vj_uncompress_tcp+0x34>
 801caf0:	f000 fd00 	bl	801d4f4 <vj_uncompress_tcp+0xa34>
      PPPDEBUG(LOG_INFO, ("vj_uncompress_tcp: bad cid=%d\n", *cp));
      goto bad;
    }

    comp->flags &=~ VJF_TOSS;
 801caf4:	683b      	ldr	r3, [r7, #0]
 801caf6:	88db      	ldrh	r3, [r3, #6]
 801caf8:	2201      	movs	r2, #1
 801cafa:	4393      	bics	r3, r2
 801cafc:	b29a      	uxth	r2, r3
 801cafe:	683b      	ldr	r3, [r7, #0]
 801cb00:	80da      	strh	r2, [r3, #6]
    comp->last_recv = *cp++;
 801cb02:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801cb04:	1c5a      	adds	r2, r3, #1
 801cb06:	64fa      	str	r2, [r7, #76]	; 0x4c
 801cb08:	781a      	ldrb	r2, [r3, #0]
 801cb0a:	683b      	ldr	r3, [r7, #0]
 801cb0c:	711a      	strb	r2, [r3, #4]
 801cb0e:	e009      	b.n	801cb24 <vj_uncompress_tcp+0x64>
    /*
     * this packet has an implicit state index.  If we've
     * had a line error since the last time we got an
     * explicit state index, we have to toss the packet.
     */
    if (comp->flags & VJF_TOSS) {
 801cb10:	683b      	ldr	r3, [r7, #0]
 801cb12:	88db      	ldrh	r3, [r3, #6]
 801cb14:	001a      	movs	r2, r3
 801cb16:	2301      	movs	r3, #1
 801cb18:	4013      	ands	r3, r2
 801cb1a:	d003      	beq.n	801cb24 <vj_uncompress_tcp+0x64>
      PPPDEBUG(LOG_INFO, ("vj_uncompress_tcp: tossing\n"));
      INCR(vjs_tossed);
      return (-1);
 801cb1c:	2301      	movs	r3, #1
 801cb1e:	425b      	negs	r3, r3
 801cb20:	f000 fcf5 	bl	801d50e <vj_uncompress_tcp+0xa4e>
    }
  }
  cs = &comp->rstate[comp->last_recv];
 801cb24:	683b      	ldr	r3, [r7, #0]
 801cb26:	791b      	ldrb	r3, [r3, #4]
 801cb28:	001a      	movs	r2, r3
 801cb2a:	0013      	movs	r3, r2
 801cb2c:	011b      	lsls	r3, r3, #4
 801cb2e:	189b      	adds	r3, r3, r2
 801cb30:	00db      	lsls	r3, r3, #3
 801cb32:	4ae9      	ldr	r2, [pc, #932]	; (801ced8 <vj_uncompress_tcp+0x418>)
 801cb34:	4694      	mov	ip, r2
 801cb36:	4463      	add	r3, ip
 801cb38:	683a      	ldr	r2, [r7, #0]
 801cb3a:	18d3      	adds	r3, r2, r3
 801cb3c:	3304      	adds	r3, #4
 801cb3e:	637b      	str	r3, [r7, #52]	; 0x34
  hlen = IPH_HL(&cs->cs_ip) << 2;
 801cb40:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cb42:	7a1b      	ldrb	r3, [r3, #8]
 801cb44:	009b      	lsls	r3, r3, #2
 801cb46:	001a      	movs	r2, r3
 801cb48:	233c      	movs	r3, #60	; 0x3c
 801cb4a:	4013      	ands	r3, r2
 801cb4c:	63fb      	str	r3, [r7, #60]	; 0x3c
  th = (struct tcp_hdr *)&((u8_t*)&cs->cs_ip)[hlen];
 801cb4e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cb50:	3308      	adds	r3, #8
 801cb52:	001a      	movs	r2, r3
 801cb54:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801cb56:	18d3      	adds	r3, r2, r3
 801cb58:	633b      	str	r3, [r7, #48]	; 0x30
  th->chksum = lwip_htons((*cp << 8) | cp[1]);
 801cb5a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801cb5c:	781b      	ldrb	r3, [r3, #0]
 801cb5e:	021b      	lsls	r3, r3, #8
 801cb60:	b21a      	sxth	r2, r3
 801cb62:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801cb64:	3301      	adds	r3, #1
 801cb66:	781b      	ldrb	r3, [r3, #0]
 801cb68:	b21b      	sxth	r3, r3
 801cb6a:	4313      	orrs	r3, r2
 801cb6c:	b21b      	sxth	r3, r3
 801cb6e:	b29b      	uxth	r3, r3
 801cb70:	0018      	movs	r0, r3
 801cb72:	f7ea fc45 	bl	8007400 <lwip_htons>
 801cb76:	0003      	movs	r3, r0
 801cb78:	001a      	movs	r2, r3
 801cb7a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cb7c:	21ff      	movs	r1, #255	; 0xff
 801cb7e:	4011      	ands	r1, r2
 801cb80:	000c      	movs	r4, r1
 801cb82:	7c19      	ldrb	r1, [r3, #16]
 801cb84:	2000      	movs	r0, #0
 801cb86:	4001      	ands	r1, r0
 801cb88:	1c08      	adds	r0, r1, #0
 801cb8a:	1c21      	adds	r1, r4, #0
 801cb8c:	4301      	orrs	r1, r0
 801cb8e:	7419      	strb	r1, [r3, #16]
 801cb90:	0a12      	lsrs	r2, r2, #8
 801cb92:	b290      	uxth	r0, r2
 801cb94:	7c5a      	ldrb	r2, [r3, #17]
 801cb96:	2100      	movs	r1, #0
 801cb98:	400a      	ands	r2, r1
 801cb9a:	1c11      	adds	r1, r2, #0
 801cb9c:	1c02      	adds	r2, r0, #0
 801cb9e:	430a      	orrs	r2, r1
 801cba0:	745a      	strb	r2, [r3, #17]
  cp += 2;
 801cba2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801cba4:	3302      	adds	r3, #2
 801cba6:	64fb      	str	r3, [r7, #76]	; 0x4c
  if (changes & TCP_PUSH_BIT) {
 801cba8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801cbaa:	2210      	movs	r2, #16
 801cbac:	4013      	ands	r3, r2
 801cbae:	d020      	beq.n	801cbf2 <vj_uncompress_tcp+0x132>
    TCPH_SET_FLAG(th, TCP_PSH);
 801cbb0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cbb2:	7b1a      	ldrb	r2, [r3, #12]
 801cbb4:	7b5b      	ldrb	r3, [r3, #13]
 801cbb6:	021b      	lsls	r3, r3, #8
 801cbb8:	4313      	orrs	r3, r2
 801cbba:	b29c      	uxth	r4, r3
 801cbbc:	2008      	movs	r0, #8
 801cbbe:	f7ea fc1f 	bl	8007400 <lwip_htons>
 801cbc2:	0003      	movs	r3, r0
 801cbc4:	4323      	orrs	r3, r4
 801cbc6:	b29a      	uxth	r2, r3
 801cbc8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cbca:	21ff      	movs	r1, #255	; 0xff
 801cbcc:	4011      	ands	r1, r2
 801cbce:	000c      	movs	r4, r1
 801cbd0:	7b19      	ldrb	r1, [r3, #12]
 801cbd2:	2000      	movs	r0, #0
 801cbd4:	4001      	ands	r1, r0
 801cbd6:	1c08      	adds	r0, r1, #0
 801cbd8:	1c21      	adds	r1, r4, #0
 801cbda:	4301      	orrs	r1, r0
 801cbdc:	7319      	strb	r1, [r3, #12]
 801cbde:	0a12      	lsrs	r2, r2, #8
 801cbe0:	b290      	uxth	r0, r2
 801cbe2:	7b5a      	ldrb	r2, [r3, #13]
 801cbe4:	2100      	movs	r1, #0
 801cbe6:	400a      	ands	r2, r1
 801cbe8:	1c11      	adds	r1, r2, #0
 801cbea:	1c02      	adds	r2, r0, #0
 801cbec:	430a      	orrs	r2, r1
 801cbee:	735a      	strb	r2, [r3, #13]
 801cbf0:	e024      	b.n	801cc3c <vj_uncompress_tcp+0x17c>
  } else {
    TCPH_UNSET_FLAG(th, TCP_PSH);
 801cbf2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cbf4:	7b1a      	ldrb	r2, [r3, #12]
 801cbf6:	7b5b      	ldrb	r3, [r3, #13]
 801cbf8:	021b      	lsls	r3, r3, #8
 801cbfa:	4313      	orrs	r3, r2
 801cbfc:	b29b      	uxth	r3, r3
 801cbfe:	b21c      	sxth	r4, r3
 801cc00:	2008      	movs	r0, #8
 801cc02:	f7ea fbfd 	bl	8007400 <lwip_htons>
 801cc06:	0003      	movs	r3, r0
 801cc08:	b21b      	sxth	r3, r3
 801cc0a:	43db      	mvns	r3, r3
 801cc0c:	b21b      	sxth	r3, r3
 801cc0e:	4023      	ands	r3, r4
 801cc10:	b21b      	sxth	r3, r3
 801cc12:	b29a      	uxth	r2, r3
 801cc14:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cc16:	21ff      	movs	r1, #255	; 0xff
 801cc18:	4011      	ands	r1, r2
 801cc1a:	000c      	movs	r4, r1
 801cc1c:	7b19      	ldrb	r1, [r3, #12]
 801cc1e:	2000      	movs	r0, #0
 801cc20:	4001      	ands	r1, r0
 801cc22:	1c08      	adds	r0, r1, #0
 801cc24:	1c21      	adds	r1, r4, #0
 801cc26:	4301      	orrs	r1, r0
 801cc28:	7319      	strb	r1, [r3, #12]
 801cc2a:	0a12      	lsrs	r2, r2, #8
 801cc2c:	b290      	uxth	r0, r2
 801cc2e:	7b5a      	ldrb	r2, [r3, #13]
 801cc30:	2100      	movs	r1, #0
 801cc32:	400a      	ands	r2, r1
 801cc34:	1c11      	adds	r1, r2, #0
 801cc36:	1c02      	adds	r2, r0, #0
 801cc38:	430a      	orrs	r2, r1
 801cc3a:	735a      	strb	r2, [r3, #13]
  }

  switch (changes & SPECIALS_MASK) {
 801cc3c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801cc3e:	220f      	movs	r2, #15
 801cc40:	4013      	ands	r3, r2
 801cc42:	2b0b      	cmp	r3, #11
 801cc44:	d003      	beq.n	801cc4e <vj_uncompress_tcp+0x18e>
 801cc46:	2b0f      	cmp	r3, #15
 801cc48:	d100      	bne.n	801cc4c <vj_uncompress_tcp+0x18c>
 801cc4a:	e08c      	b.n	801cd66 <vj_uncompress_tcp+0x2a6>
 801cc4c:	e0d4      	b.n	801cdf8 <vj_uncompress_tcp+0x338>
  case SPECIAL_I:
    {
      u32_t i = lwip_ntohs(IPH_LEN(&cs->cs_ip)) - cs->cs_hlen;
 801cc4e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cc50:	895b      	ldrh	r3, [r3, #10]
 801cc52:	0018      	movs	r0, r3
 801cc54:	f7ea fbd4 	bl	8007400 <lwip_htons>
 801cc58:	0003      	movs	r3, r0
 801cc5a:	001a      	movs	r2, r3
 801cc5c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cc5e:	889b      	ldrh	r3, [r3, #4]
 801cc60:	1ad3      	subs	r3, r2, r3
 801cc62:	62fb      	str	r3, [r7, #44]	; 0x2c
      /* some compilers can't nest inline assembler.. */
      tmp = lwip_ntohl(th->ackno) + i;
 801cc64:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cc66:	7a1a      	ldrb	r2, [r3, #8]
 801cc68:	7a59      	ldrb	r1, [r3, #9]
 801cc6a:	0209      	lsls	r1, r1, #8
 801cc6c:	430a      	orrs	r2, r1
 801cc6e:	7a99      	ldrb	r1, [r3, #10]
 801cc70:	0409      	lsls	r1, r1, #16
 801cc72:	430a      	orrs	r2, r1
 801cc74:	7adb      	ldrb	r3, [r3, #11]
 801cc76:	061b      	lsls	r3, r3, #24
 801cc78:	4313      	orrs	r3, r2
 801cc7a:	0018      	movs	r0, r3
 801cc7c:	f7ea fbd6 	bl	800742c <lwip_htonl>
 801cc80:	0002      	movs	r2, r0
 801cc82:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801cc84:	189b      	adds	r3, r3, r2
 801cc86:	643b      	str	r3, [r7, #64]	; 0x40
      th->ackno = lwip_htonl(tmp);
 801cc88:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801cc8a:	0018      	movs	r0, r3
 801cc8c:	f7ea fbce 	bl	800742c <lwip_htonl>
 801cc90:	0002      	movs	r2, r0
 801cc92:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cc94:	21ff      	movs	r1, #255	; 0xff
 801cc96:	4011      	ands	r1, r2
 801cc98:	000c      	movs	r4, r1
 801cc9a:	7a19      	ldrb	r1, [r3, #8]
 801cc9c:	2000      	movs	r0, #0
 801cc9e:	4001      	ands	r1, r0
 801cca0:	1c08      	adds	r0, r1, #0
 801cca2:	1c21      	adds	r1, r4, #0
 801cca4:	4301      	orrs	r1, r0
 801cca6:	7219      	strb	r1, [r3, #8]
 801cca8:	0a11      	lsrs	r1, r2, #8
 801ccaa:	20ff      	movs	r0, #255	; 0xff
 801ccac:	4001      	ands	r1, r0
 801ccae:	000c      	movs	r4, r1
 801ccb0:	7a59      	ldrb	r1, [r3, #9]
 801ccb2:	2000      	movs	r0, #0
 801ccb4:	4001      	ands	r1, r0
 801ccb6:	1c08      	adds	r0, r1, #0
 801ccb8:	1c21      	adds	r1, r4, #0
 801ccba:	4301      	orrs	r1, r0
 801ccbc:	7259      	strb	r1, [r3, #9]
 801ccbe:	0c11      	lsrs	r1, r2, #16
 801ccc0:	20ff      	movs	r0, #255	; 0xff
 801ccc2:	4001      	ands	r1, r0
 801ccc4:	000c      	movs	r4, r1
 801ccc6:	7a99      	ldrb	r1, [r3, #10]
 801ccc8:	2000      	movs	r0, #0
 801ccca:	4001      	ands	r1, r0
 801cccc:	1c08      	adds	r0, r1, #0
 801ccce:	1c21      	adds	r1, r4, #0
 801ccd0:	4301      	orrs	r1, r0
 801ccd2:	7299      	strb	r1, [r3, #10]
 801ccd4:	0e10      	lsrs	r0, r2, #24
 801ccd6:	7ada      	ldrb	r2, [r3, #11]
 801ccd8:	2100      	movs	r1, #0
 801ccda:	400a      	ands	r2, r1
 801ccdc:	1c11      	adds	r1, r2, #0
 801ccde:	1c02      	adds	r2, r0, #0
 801cce0:	430a      	orrs	r2, r1
 801cce2:	72da      	strb	r2, [r3, #11]
      tmp = lwip_ntohl(th->seqno) + i;
 801cce4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cce6:	791a      	ldrb	r2, [r3, #4]
 801cce8:	7959      	ldrb	r1, [r3, #5]
 801ccea:	0209      	lsls	r1, r1, #8
 801ccec:	430a      	orrs	r2, r1
 801ccee:	7999      	ldrb	r1, [r3, #6]
 801ccf0:	0409      	lsls	r1, r1, #16
 801ccf2:	430a      	orrs	r2, r1
 801ccf4:	79db      	ldrb	r3, [r3, #7]
 801ccf6:	061b      	lsls	r3, r3, #24
 801ccf8:	4313      	orrs	r3, r2
 801ccfa:	0018      	movs	r0, r3
 801ccfc:	f7ea fb96 	bl	800742c <lwip_htonl>
 801cd00:	0002      	movs	r2, r0
 801cd02:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801cd04:	189b      	adds	r3, r3, r2
 801cd06:	643b      	str	r3, [r7, #64]	; 0x40
      th->seqno = lwip_htonl(tmp);
 801cd08:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801cd0a:	0018      	movs	r0, r3
 801cd0c:	f7ea fb8e 	bl	800742c <lwip_htonl>
 801cd10:	0002      	movs	r2, r0
 801cd12:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cd14:	21ff      	movs	r1, #255	; 0xff
 801cd16:	4011      	ands	r1, r2
 801cd18:	000c      	movs	r4, r1
 801cd1a:	7919      	ldrb	r1, [r3, #4]
 801cd1c:	2000      	movs	r0, #0
 801cd1e:	4001      	ands	r1, r0
 801cd20:	1c08      	adds	r0, r1, #0
 801cd22:	1c21      	adds	r1, r4, #0
 801cd24:	4301      	orrs	r1, r0
 801cd26:	7119      	strb	r1, [r3, #4]
 801cd28:	0a11      	lsrs	r1, r2, #8
 801cd2a:	20ff      	movs	r0, #255	; 0xff
 801cd2c:	4001      	ands	r1, r0
 801cd2e:	000c      	movs	r4, r1
 801cd30:	7959      	ldrb	r1, [r3, #5]
 801cd32:	2000      	movs	r0, #0
 801cd34:	4001      	ands	r1, r0
 801cd36:	1c08      	adds	r0, r1, #0
 801cd38:	1c21      	adds	r1, r4, #0
 801cd3a:	4301      	orrs	r1, r0
 801cd3c:	7159      	strb	r1, [r3, #5]
 801cd3e:	0c11      	lsrs	r1, r2, #16
 801cd40:	20ff      	movs	r0, #255	; 0xff
 801cd42:	4001      	ands	r1, r0
 801cd44:	000c      	movs	r4, r1
 801cd46:	7999      	ldrb	r1, [r3, #6]
 801cd48:	2000      	movs	r0, #0
 801cd4a:	4001      	ands	r1, r0
 801cd4c:	1c08      	adds	r0, r1, #0
 801cd4e:	1c21      	adds	r1, r4, #0
 801cd50:	4301      	orrs	r1, r0
 801cd52:	7199      	strb	r1, [r3, #6]
 801cd54:	0e10      	lsrs	r0, r2, #24
 801cd56:	79da      	ldrb	r2, [r3, #7]
 801cd58:	2100      	movs	r1, #0
 801cd5a:	400a      	ands	r2, r1
 801cd5c:	1c11      	adds	r1, r2, #0
 801cd5e:	1c02      	adds	r2, r0, #0
 801cd60:	430a      	orrs	r2, r1
 801cd62:	71da      	strb	r2, [r3, #7]
    }
    break;
 801cd64:	e27f      	b.n	801d266 <vj_uncompress_tcp+0x7a6>

  case SPECIAL_D:
    /* some compilers can't nest inline assembler.. */
    tmp = lwip_ntohl(th->seqno) + lwip_ntohs(IPH_LEN(&cs->cs_ip)) - cs->cs_hlen;
 801cd66:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cd68:	791a      	ldrb	r2, [r3, #4]
 801cd6a:	7959      	ldrb	r1, [r3, #5]
 801cd6c:	0209      	lsls	r1, r1, #8
 801cd6e:	430a      	orrs	r2, r1
 801cd70:	7999      	ldrb	r1, [r3, #6]
 801cd72:	0409      	lsls	r1, r1, #16
 801cd74:	430a      	orrs	r2, r1
 801cd76:	79db      	ldrb	r3, [r3, #7]
 801cd78:	061b      	lsls	r3, r3, #24
 801cd7a:	4313      	orrs	r3, r2
 801cd7c:	0018      	movs	r0, r3
 801cd7e:	f7ea fb55 	bl	800742c <lwip_htonl>
 801cd82:	0004      	movs	r4, r0
 801cd84:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cd86:	895b      	ldrh	r3, [r3, #10]
 801cd88:	0018      	movs	r0, r3
 801cd8a:	f7ea fb39 	bl	8007400 <lwip_htons>
 801cd8e:	0003      	movs	r3, r0
 801cd90:	18e3      	adds	r3, r4, r3
 801cd92:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801cd94:	8892      	ldrh	r2, [r2, #4]
 801cd96:	1a9b      	subs	r3, r3, r2
 801cd98:	643b      	str	r3, [r7, #64]	; 0x40
    th->seqno = lwip_htonl(tmp);
 801cd9a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801cd9c:	0018      	movs	r0, r3
 801cd9e:	f7ea fb45 	bl	800742c <lwip_htonl>
 801cda2:	0002      	movs	r2, r0
 801cda4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cda6:	21ff      	movs	r1, #255	; 0xff
 801cda8:	4011      	ands	r1, r2
 801cdaa:	000c      	movs	r4, r1
 801cdac:	7919      	ldrb	r1, [r3, #4]
 801cdae:	2000      	movs	r0, #0
 801cdb0:	4001      	ands	r1, r0
 801cdb2:	1c08      	adds	r0, r1, #0
 801cdb4:	1c21      	adds	r1, r4, #0
 801cdb6:	4301      	orrs	r1, r0
 801cdb8:	7119      	strb	r1, [r3, #4]
 801cdba:	0a11      	lsrs	r1, r2, #8
 801cdbc:	20ff      	movs	r0, #255	; 0xff
 801cdbe:	4001      	ands	r1, r0
 801cdc0:	000c      	movs	r4, r1
 801cdc2:	7959      	ldrb	r1, [r3, #5]
 801cdc4:	2000      	movs	r0, #0
 801cdc6:	4001      	ands	r1, r0
 801cdc8:	1c08      	adds	r0, r1, #0
 801cdca:	1c21      	adds	r1, r4, #0
 801cdcc:	4301      	orrs	r1, r0
 801cdce:	7159      	strb	r1, [r3, #5]
 801cdd0:	0c11      	lsrs	r1, r2, #16
 801cdd2:	20ff      	movs	r0, #255	; 0xff
 801cdd4:	4001      	ands	r1, r0
 801cdd6:	000c      	movs	r4, r1
 801cdd8:	7999      	ldrb	r1, [r3, #6]
 801cdda:	2000      	movs	r0, #0
 801cddc:	4001      	ands	r1, r0
 801cdde:	1c08      	adds	r0, r1, #0
 801cde0:	1c21      	adds	r1, r4, #0
 801cde2:	4301      	orrs	r1, r0
 801cde4:	7199      	strb	r1, [r3, #6]
 801cde6:	0e10      	lsrs	r0, r2, #24
 801cde8:	79da      	ldrb	r2, [r3, #7]
 801cdea:	2100      	movs	r1, #0
 801cdec:	400a      	ands	r2, r1
 801cdee:	1c11      	adds	r1, r2, #0
 801cdf0:	1c02      	adds	r2, r0, #0
 801cdf2:	430a      	orrs	r2, r1
 801cdf4:	71da      	strb	r2, [r3, #7]
    break;
 801cdf6:	e236      	b.n	801d266 <vj_uncompress_tcp+0x7a6>

  default:
    if (changes & NEW_U) {
 801cdf8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801cdfa:	2201      	movs	r2, #1
 801cdfc:	4013      	ands	r3, r2
 801cdfe:	d06d      	beq.n	801cedc <vj_uncompress_tcp+0x41c>
      TCPH_SET_FLAG(th, TCP_URG);
 801ce00:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ce02:	7b1a      	ldrb	r2, [r3, #12]
 801ce04:	7b5b      	ldrb	r3, [r3, #13]
 801ce06:	021b      	lsls	r3, r3, #8
 801ce08:	4313      	orrs	r3, r2
 801ce0a:	b29c      	uxth	r4, r3
 801ce0c:	2020      	movs	r0, #32
 801ce0e:	f7ea faf7 	bl	8007400 <lwip_htons>
 801ce12:	0003      	movs	r3, r0
 801ce14:	4323      	orrs	r3, r4
 801ce16:	b29a      	uxth	r2, r3
 801ce18:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ce1a:	21ff      	movs	r1, #255	; 0xff
 801ce1c:	4011      	ands	r1, r2
 801ce1e:	000c      	movs	r4, r1
 801ce20:	7b19      	ldrb	r1, [r3, #12]
 801ce22:	2000      	movs	r0, #0
 801ce24:	4001      	ands	r1, r0
 801ce26:	1c08      	adds	r0, r1, #0
 801ce28:	1c21      	adds	r1, r4, #0
 801ce2a:	4301      	orrs	r1, r0
 801ce2c:	7319      	strb	r1, [r3, #12]
 801ce2e:	0a12      	lsrs	r2, r2, #8
 801ce30:	b290      	uxth	r0, r2
 801ce32:	7b5a      	ldrb	r2, [r3, #13]
 801ce34:	2100      	movs	r1, #0
 801ce36:	400a      	ands	r2, r1
 801ce38:	1c11      	adds	r1, r2, #0
 801ce3a:	1c02      	adds	r2, r0, #0
 801ce3c:	430a      	orrs	r2, r1
 801ce3e:	735a      	strb	r2, [r3, #13]
      DECODEU(th->urgp);
 801ce40:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801ce42:	781b      	ldrb	r3, [r3, #0]
 801ce44:	2b00      	cmp	r3, #0
 801ce46:	d128      	bne.n	801ce9a <vj_uncompress_tcp+0x3da>
 801ce48:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801ce4a:	3301      	adds	r3, #1
 801ce4c:	781b      	ldrb	r3, [r3, #0]
 801ce4e:	021b      	lsls	r3, r3, #8
 801ce50:	b21a      	sxth	r2, r3
 801ce52:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801ce54:	3302      	adds	r3, #2
 801ce56:	781b      	ldrb	r3, [r3, #0]
 801ce58:	b21b      	sxth	r3, r3
 801ce5a:	4313      	orrs	r3, r2
 801ce5c:	b21b      	sxth	r3, r3
 801ce5e:	b29b      	uxth	r3, r3
 801ce60:	0018      	movs	r0, r3
 801ce62:	f7ea facd 	bl	8007400 <lwip_htons>
 801ce66:	0003      	movs	r3, r0
 801ce68:	001a      	movs	r2, r3
 801ce6a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ce6c:	21ff      	movs	r1, #255	; 0xff
 801ce6e:	4011      	ands	r1, r2
 801ce70:	000c      	movs	r4, r1
 801ce72:	7c99      	ldrb	r1, [r3, #18]
 801ce74:	2000      	movs	r0, #0
 801ce76:	4001      	ands	r1, r0
 801ce78:	1c08      	adds	r0, r1, #0
 801ce7a:	1c21      	adds	r1, r4, #0
 801ce7c:	4301      	orrs	r1, r0
 801ce7e:	7499      	strb	r1, [r3, #18]
 801ce80:	0a12      	lsrs	r2, r2, #8
 801ce82:	b290      	uxth	r0, r2
 801ce84:	7cda      	ldrb	r2, [r3, #19]
 801ce86:	2100      	movs	r1, #0
 801ce88:	400a      	ands	r2, r1
 801ce8a:	1c11      	adds	r1, r2, #0
 801ce8c:	1c02      	adds	r2, r0, #0
 801ce8e:	430a      	orrs	r2, r1
 801ce90:	74da      	strb	r2, [r3, #19]
 801ce92:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801ce94:	3303      	adds	r3, #3
 801ce96:	64fb      	str	r3, [r7, #76]	; 0x4c
 801ce98:	e045      	b.n	801cf26 <vj_uncompress_tcp+0x466>
 801ce9a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801ce9c:	1c5a      	adds	r2, r3, #1
 801ce9e:	64fa      	str	r2, [r7, #76]	; 0x4c
 801cea0:	781b      	ldrb	r3, [r3, #0]
 801cea2:	b29b      	uxth	r3, r3
 801cea4:	0018      	movs	r0, r3
 801cea6:	f7ea faab 	bl	8007400 <lwip_htons>
 801ceaa:	0003      	movs	r3, r0
 801ceac:	001a      	movs	r2, r3
 801ceae:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ceb0:	21ff      	movs	r1, #255	; 0xff
 801ceb2:	4011      	ands	r1, r2
 801ceb4:	000c      	movs	r4, r1
 801ceb6:	7c99      	ldrb	r1, [r3, #18]
 801ceb8:	2000      	movs	r0, #0
 801ceba:	4001      	ands	r1, r0
 801cebc:	1c08      	adds	r0, r1, #0
 801cebe:	1c21      	adds	r1, r4, #0
 801cec0:	4301      	orrs	r1, r0
 801cec2:	7499      	strb	r1, [r3, #18]
 801cec4:	0a12      	lsrs	r2, r2, #8
 801cec6:	b290      	uxth	r0, r2
 801cec8:	7cda      	ldrb	r2, [r3, #19]
 801ceca:	2100      	movs	r1, #0
 801cecc:	400a      	ands	r2, r1
 801cece:	1c11      	adds	r1, r2, #0
 801ced0:	1c02      	adds	r2, r0, #0
 801ced2:	430a      	orrs	r2, r1
 801ced4:	74da      	strb	r2, [r3, #19]
 801ced6:	e026      	b.n	801cf26 <vj_uncompress_tcp+0x466>
 801ced8:	00000888 	.word	0x00000888
    } else {
      TCPH_UNSET_FLAG(th, TCP_URG);
 801cedc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cede:	7b1a      	ldrb	r2, [r3, #12]
 801cee0:	7b5b      	ldrb	r3, [r3, #13]
 801cee2:	021b      	lsls	r3, r3, #8
 801cee4:	4313      	orrs	r3, r2
 801cee6:	b29b      	uxth	r3, r3
 801cee8:	b21c      	sxth	r4, r3
 801ceea:	2020      	movs	r0, #32
 801ceec:	f7ea fa88 	bl	8007400 <lwip_htons>
 801cef0:	0003      	movs	r3, r0
 801cef2:	b21b      	sxth	r3, r3
 801cef4:	43db      	mvns	r3, r3
 801cef6:	b21b      	sxth	r3, r3
 801cef8:	4023      	ands	r3, r4
 801cefa:	b21b      	sxth	r3, r3
 801cefc:	b29a      	uxth	r2, r3
 801cefe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cf00:	21ff      	movs	r1, #255	; 0xff
 801cf02:	4011      	ands	r1, r2
 801cf04:	000c      	movs	r4, r1
 801cf06:	7b19      	ldrb	r1, [r3, #12]
 801cf08:	2000      	movs	r0, #0
 801cf0a:	4001      	ands	r1, r0
 801cf0c:	1c08      	adds	r0, r1, #0
 801cf0e:	1c21      	adds	r1, r4, #0
 801cf10:	4301      	orrs	r1, r0
 801cf12:	7319      	strb	r1, [r3, #12]
 801cf14:	0a12      	lsrs	r2, r2, #8
 801cf16:	b290      	uxth	r0, r2
 801cf18:	7b5a      	ldrb	r2, [r3, #13]
 801cf1a:	2100      	movs	r1, #0
 801cf1c:	400a      	ands	r2, r1
 801cf1e:	1c11      	adds	r1, r2, #0
 801cf20:	1c02      	adds	r2, r0, #0
 801cf22:	430a      	orrs	r2, r1
 801cf24:	735a      	strb	r2, [r3, #13]
    }
    if (changes & NEW_W) {
 801cf26:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801cf28:	2202      	movs	r2, #2
 801cf2a:	4013      	ands	r3, r2
 801cf2c:	d06c      	beq.n	801d008 <vj_uncompress_tcp+0x548>
      DECODES(th->wnd);
 801cf2e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801cf30:	781b      	ldrb	r3, [r3, #0]
 801cf32:	2b00      	cmp	r3, #0
 801cf34:	d139      	bne.n	801cfaa <vj_uncompress_tcp+0x4ea>
 801cf36:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cf38:	7b9a      	ldrb	r2, [r3, #14]
 801cf3a:	7bdb      	ldrb	r3, [r3, #15]
 801cf3c:	021b      	lsls	r3, r3, #8
 801cf3e:	4313      	orrs	r3, r2
 801cf40:	b29b      	uxth	r3, r3
 801cf42:	0018      	movs	r0, r3
 801cf44:	f7ea fa5c 	bl	8007400 <lwip_htons>
 801cf48:	0003      	movs	r3, r0
 801cf4a:	0019      	movs	r1, r3
 801cf4c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801cf4e:	3301      	adds	r3, #1
 801cf50:	781b      	ldrb	r3, [r3, #0]
 801cf52:	021b      	lsls	r3, r3, #8
 801cf54:	b21a      	sxth	r2, r3
 801cf56:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801cf58:	3302      	adds	r3, #2
 801cf5a:	781b      	ldrb	r3, [r3, #0]
 801cf5c:	b21b      	sxth	r3, r3
 801cf5e:	4313      	orrs	r3, r2
 801cf60:	b21b      	sxth	r3, r3
 801cf62:	b29a      	uxth	r2, r3
 801cf64:	2028      	movs	r0, #40	; 0x28
 801cf66:	183b      	adds	r3, r7, r0
 801cf68:	188a      	adds	r2, r1, r2
 801cf6a:	801a      	strh	r2, [r3, #0]
 801cf6c:	183b      	adds	r3, r7, r0
 801cf6e:	881b      	ldrh	r3, [r3, #0]
 801cf70:	0018      	movs	r0, r3
 801cf72:	f7ea fa45 	bl	8007400 <lwip_htons>
 801cf76:	0003      	movs	r3, r0
 801cf78:	001a      	movs	r2, r3
 801cf7a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cf7c:	21ff      	movs	r1, #255	; 0xff
 801cf7e:	4011      	ands	r1, r2
 801cf80:	000c      	movs	r4, r1
 801cf82:	7b99      	ldrb	r1, [r3, #14]
 801cf84:	2000      	movs	r0, #0
 801cf86:	4001      	ands	r1, r0
 801cf88:	1c08      	adds	r0, r1, #0
 801cf8a:	1c21      	adds	r1, r4, #0
 801cf8c:	4301      	orrs	r1, r0
 801cf8e:	7399      	strb	r1, [r3, #14]
 801cf90:	0a12      	lsrs	r2, r2, #8
 801cf92:	b290      	uxth	r0, r2
 801cf94:	7bda      	ldrb	r2, [r3, #15]
 801cf96:	2100      	movs	r1, #0
 801cf98:	400a      	ands	r2, r1
 801cf9a:	1c11      	adds	r1, r2, #0
 801cf9c:	1c02      	adds	r2, r0, #0
 801cf9e:	430a      	orrs	r2, r1
 801cfa0:	73da      	strb	r2, [r3, #15]
 801cfa2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801cfa4:	3303      	adds	r3, #3
 801cfa6:	64fb      	str	r3, [r7, #76]	; 0x4c
 801cfa8:	e02e      	b.n	801d008 <vj_uncompress_tcp+0x548>
 801cfaa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cfac:	7b9a      	ldrb	r2, [r3, #14]
 801cfae:	7bdb      	ldrb	r3, [r3, #15]
 801cfb0:	021b      	lsls	r3, r3, #8
 801cfb2:	4313      	orrs	r3, r2
 801cfb4:	b29b      	uxth	r3, r3
 801cfb6:	0018      	movs	r0, r3
 801cfb8:	f7ea fa22 	bl	8007400 <lwip_htons>
 801cfbc:	0003      	movs	r3, r0
 801cfbe:	0019      	movs	r1, r3
 801cfc0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801cfc2:	1c5a      	adds	r2, r3, #1
 801cfc4:	64fa      	str	r2, [r7, #76]	; 0x4c
 801cfc6:	781b      	ldrb	r3, [r3, #0]
 801cfc8:	b29a      	uxth	r2, r3
 801cfca:	202a      	movs	r0, #42	; 0x2a
 801cfcc:	183b      	adds	r3, r7, r0
 801cfce:	188a      	adds	r2, r1, r2
 801cfd0:	801a      	strh	r2, [r3, #0]
 801cfd2:	183b      	adds	r3, r7, r0
 801cfd4:	881b      	ldrh	r3, [r3, #0]
 801cfd6:	0018      	movs	r0, r3
 801cfd8:	f7ea fa12 	bl	8007400 <lwip_htons>
 801cfdc:	0003      	movs	r3, r0
 801cfde:	001a      	movs	r2, r3
 801cfe0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cfe2:	21ff      	movs	r1, #255	; 0xff
 801cfe4:	4011      	ands	r1, r2
 801cfe6:	000c      	movs	r4, r1
 801cfe8:	7b99      	ldrb	r1, [r3, #14]
 801cfea:	2000      	movs	r0, #0
 801cfec:	4001      	ands	r1, r0
 801cfee:	1c08      	adds	r0, r1, #0
 801cff0:	1c21      	adds	r1, r4, #0
 801cff2:	4301      	orrs	r1, r0
 801cff4:	7399      	strb	r1, [r3, #14]
 801cff6:	0a12      	lsrs	r2, r2, #8
 801cff8:	b290      	uxth	r0, r2
 801cffa:	7bda      	ldrb	r2, [r3, #15]
 801cffc:	2100      	movs	r1, #0
 801cffe:	400a      	ands	r2, r1
 801d000:	1c11      	adds	r1, r2, #0
 801d002:	1c02      	adds	r2, r0, #0
 801d004:	430a      	orrs	r2, r1
 801d006:	73da      	strb	r2, [r3, #15]
    }
    if (changes & NEW_A) {
 801d008:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801d00a:	2204      	movs	r2, #4
 801d00c:	4013      	ands	r3, r2
 801d00e:	d100      	bne.n	801d012 <vj_uncompress_tcp+0x552>
 801d010:	e091      	b.n	801d136 <vj_uncompress_tcp+0x676>
      DECODEL(th->ackno);
 801d012:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801d014:	781b      	ldrb	r3, [r3, #0]
 801d016:	2b00      	cmp	r3, #0
 801d018:	d14a      	bne.n	801d0b0 <vj_uncompress_tcp+0x5f0>
 801d01a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801d01c:	7a1a      	ldrb	r2, [r3, #8]
 801d01e:	7a59      	ldrb	r1, [r3, #9]
 801d020:	0209      	lsls	r1, r1, #8
 801d022:	430a      	orrs	r2, r1
 801d024:	7a99      	ldrb	r1, [r3, #10]
 801d026:	0409      	lsls	r1, r1, #16
 801d028:	430a      	orrs	r2, r1
 801d02a:	7adb      	ldrb	r3, [r3, #11]
 801d02c:	061b      	lsls	r3, r3, #24
 801d02e:	4313      	orrs	r3, r2
 801d030:	0018      	movs	r0, r3
 801d032:	f7ea f9fb 	bl	800742c <lwip_htonl>
 801d036:	0001      	movs	r1, r0
 801d038:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801d03a:	3301      	adds	r3, #1
 801d03c:	781b      	ldrb	r3, [r3, #0]
 801d03e:	021b      	lsls	r3, r3, #8
 801d040:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801d042:	3202      	adds	r2, #2
 801d044:	7812      	ldrb	r2, [r2, #0]
 801d046:	4313      	orrs	r3, r2
 801d048:	18cb      	adds	r3, r1, r3
 801d04a:	623b      	str	r3, [r7, #32]
 801d04c:	6a3b      	ldr	r3, [r7, #32]
 801d04e:	0018      	movs	r0, r3
 801d050:	f7ea f9ec 	bl	800742c <lwip_htonl>
 801d054:	0002      	movs	r2, r0
 801d056:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801d058:	21ff      	movs	r1, #255	; 0xff
 801d05a:	4011      	ands	r1, r2
 801d05c:	000c      	movs	r4, r1
 801d05e:	7a19      	ldrb	r1, [r3, #8]
 801d060:	2000      	movs	r0, #0
 801d062:	4001      	ands	r1, r0
 801d064:	1c08      	adds	r0, r1, #0
 801d066:	1c21      	adds	r1, r4, #0
 801d068:	4301      	orrs	r1, r0
 801d06a:	7219      	strb	r1, [r3, #8]
 801d06c:	0a11      	lsrs	r1, r2, #8
 801d06e:	20ff      	movs	r0, #255	; 0xff
 801d070:	4001      	ands	r1, r0
 801d072:	000c      	movs	r4, r1
 801d074:	7a59      	ldrb	r1, [r3, #9]
 801d076:	2000      	movs	r0, #0
 801d078:	4001      	ands	r1, r0
 801d07a:	1c08      	adds	r0, r1, #0
 801d07c:	1c21      	adds	r1, r4, #0
 801d07e:	4301      	orrs	r1, r0
 801d080:	7259      	strb	r1, [r3, #9]
 801d082:	0c11      	lsrs	r1, r2, #16
 801d084:	20ff      	movs	r0, #255	; 0xff
 801d086:	4001      	ands	r1, r0
 801d088:	000c      	movs	r4, r1
 801d08a:	7a99      	ldrb	r1, [r3, #10]
 801d08c:	2000      	movs	r0, #0
 801d08e:	4001      	ands	r1, r0
 801d090:	1c08      	adds	r0, r1, #0
 801d092:	1c21      	adds	r1, r4, #0
 801d094:	4301      	orrs	r1, r0
 801d096:	7299      	strb	r1, [r3, #10]
 801d098:	0e10      	lsrs	r0, r2, #24
 801d09a:	7ada      	ldrb	r2, [r3, #11]
 801d09c:	2100      	movs	r1, #0
 801d09e:	400a      	ands	r2, r1
 801d0a0:	1c11      	adds	r1, r2, #0
 801d0a2:	1c02      	adds	r2, r0, #0
 801d0a4:	430a      	orrs	r2, r1
 801d0a6:	72da      	strb	r2, [r3, #11]
 801d0a8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801d0aa:	3303      	adds	r3, #3
 801d0ac:	64fb      	str	r3, [r7, #76]	; 0x4c
 801d0ae:	e042      	b.n	801d136 <vj_uncompress_tcp+0x676>
 801d0b0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801d0b2:	7a1a      	ldrb	r2, [r3, #8]
 801d0b4:	7a59      	ldrb	r1, [r3, #9]
 801d0b6:	0209      	lsls	r1, r1, #8
 801d0b8:	430a      	orrs	r2, r1
 801d0ba:	7a99      	ldrb	r1, [r3, #10]
 801d0bc:	0409      	lsls	r1, r1, #16
 801d0be:	430a      	orrs	r2, r1
 801d0c0:	7adb      	ldrb	r3, [r3, #11]
 801d0c2:	061b      	lsls	r3, r3, #24
 801d0c4:	4313      	orrs	r3, r2
 801d0c6:	0018      	movs	r0, r3
 801d0c8:	f7ea f9b0 	bl	800742c <lwip_htonl>
 801d0cc:	0001      	movs	r1, r0
 801d0ce:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801d0d0:	1c5a      	adds	r2, r3, #1
 801d0d2:	64fa      	str	r2, [r7, #76]	; 0x4c
 801d0d4:	781b      	ldrb	r3, [r3, #0]
 801d0d6:	18cb      	adds	r3, r1, r3
 801d0d8:	627b      	str	r3, [r7, #36]	; 0x24
 801d0da:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801d0dc:	0018      	movs	r0, r3
 801d0de:	f7ea f9a5 	bl	800742c <lwip_htonl>
 801d0e2:	0002      	movs	r2, r0
 801d0e4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801d0e6:	21ff      	movs	r1, #255	; 0xff
 801d0e8:	4011      	ands	r1, r2
 801d0ea:	000c      	movs	r4, r1
 801d0ec:	7a19      	ldrb	r1, [r3, #8]
 801d0ee:	2000      	movs	r0, #0
 801d0f0:	4001      	ands	r1, r0
 801d0f2:	1c08      	adds	r0, r1, #0
 801d0f4:	1c21      	adds	r1, r4, #0
 801d0f6:	4301      	orrs	r1, r0
 801d0f8:	7219      	strb	r1, [r3, #8]
 801d0fa:	0a11      	lsrs	r1, r2, #8
 801d0fc:	20ff      	movs	r0, #255	; 0xff
 801d0fe:	4001      	ands	r1, r0
 801d100:	000c      	movs	r4, r1
 801d102:	7a59      	ldrb	r1, [r3, #9]
 801d104:	2000      	movs	r0, #0
 801d106:	4001      	ands	r1, r0
 801d108:	1c08      	adds	r0, r1, #0
 801d10a:	1c21      	adds	r1, r4, #0
 801d10c:	4301      	orrs	r1, r0
 801d10e:	7259      	strb	r1, [r3, #9]
 801d110:	0c11      	lsrs	r1, r2, #16
 801d112:	20ff      	movs	r0, #255	; 0xff
 801d114:	4001      	ands	r1, r0
 801d116:	000c      	movs	r4, r1
 801d118:	7a99      	ldrb	r1, [r3, #10]
 801d11a:	2000      	movs	r0, #0
 801d11c:	4001      	ands	r1, r0
 801d11e:	1c08      	adds	r0, r1, #0
 801d120:	1c21      	adds	r1, r4, #0
 801d122:	4301      	orrs	r1, r0
 801d124:	7299      	strb	r1, [r3, #10]
 801d126:	0e10      	lsrs	r0, r2, #24
 801d128:	7ada      	ldrb	r2, [r3, #11]
 801d12a:	2100      	movs	r1, #0
 801d12c:	400a      	ands	r2, r1
 801d12e:	1c11      	adds	r1, r2, #0
 801d130:	1c02      	adds	r2, r0, #0
 801d132:	430a      	orrs	r2, r1
 801d134:	72da      	strb	r2, [r3, #11]
    }
    if (changes & NEW_S) {
 801d136:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801d138:	2208      	movs	r2, #8
 801d13a:	4013      	ands	r3, r2
 801d13c:	d100      	bne.n	801d140 <vj_uncompress_tcp+0x680>
 801d13e:	e091      	b.n	801d264 <vj_uncompress_tcp+0x7a4>

    	DECODEL(th->seqno);
 801d140:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801d142:	781b      	ldrb	r3, [r3, #0]
 801d144:	2b00      	cmp	r3, #0
 801d146:	d14a      	bne.n	801d1de <vj_uncompress_tcp+0x71e>
 801d148:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801d14a:	791a      	ldrb	r2, [r3, #4]
 801d14c:	7959      	ldrb	r1, [r3, #5]
 801d14e:	0209      	lsls	r1, r1, #8
 801d150:	430a      	orrs	r2, r1
 801d152:	7999      	ldrb	r1, [r3, #6]
 801d154:	0409      	lsls	r1, r1, #16
 801d156:	430a      	orrs	r2, r1
 801d158:	79db      	ldrb	r3, [r3, #7]
 801d15a:	061b      	lsls	r3, r3, #24
 801d15c:	4313      	orrs	r3, r2
 801d15e:	0018      	movs	r0, r3
 801d160:	f7ea f964 	bl	800742c <lwip_htonl>
 801d164:	0001      	movs	r1, r0
 801d166:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801d168:	3301      	adds	r3, #1
 801d16a:	781b      	ldrb	r3, [r3, #0]
 801d16c:	021b      	lsls	r3, r3, #8
 801d16e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801d170:	3202      	adds	r2, #2
 801d172:	7812      	ldrb	r2, [r2, #0]
 801d174:	4313      	orrs	r3, r2
 801d176:	18cb      	adds	r3, r1, r3
 801d178:	61bb      	str	r3, [r7, #24]
 801d17a:	69bb      	ldr	r3, [r7, #24]
 801d17c:	0018      	movs	r0, r3
 801d17e:	f7ea f955 	bl	800742c <lwip_htonl>
 801d182:	0002      	movs	r2, r0
 801d184:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801d186:	21ff      	movs	r1, #255	; 0xff
 801d188:	4011      	ands	r1, r2
 801d18a:	000c      	movs	r4, r1
 801d18c:	7919      	ldrb	r1, [r3, #4]
 801d18e:	2000      	movs	r0, #0
 801d190:	4001      	ands	r1, r0
 801d192:	1c08      	adds	r0, r1, #0
 801d194:	1c21      	adds	r1, r4, #0
 801d196:	4301      	orrs	r1, r0
 801d198:	7119      	strb	r1, [r3, #4]
 801d19a:	0a11      	lsrs	r1, r2, #8
 801d19c:	20ff      	movs	r0, #255	; 0xff
 801d19e:	4001      	ands	r1, r0
 801d1a0:	000c      	movs	r4, r1
 801d1a2:	7959      	ldrb	r1, [r3, #5]
 801d1a4:	2000      	movs	r0, #0
 801d1a6:	4001      	ands	r1, r0
 801d1a8:	1c08      	adds	r0, r1, #0
 801d1aa:	1c21      	adds	r1, r4, #0
 801d1ac:	4301      	orrs	r1, r0
 801d1ae:	7159      	strb	r1, [r3, #5]
 801d1b0:	0c11      	lsrs	r1, r2, #16
 801d1b2:	20ff      	movs	r0, #255	; 0xff
 801d1b4:	4001      	ands	r1, r0
 801d1b6:	000c      	movs	r4, r1
 801d1b8:	7999      	ldrb	r1, [r3, #6]
 801d1ba:	2000      	movs	r0, #0
 801d1bc:	4001      	ands	r1, r0
 801d1be:	1c08      	adds	r0, r1, #0
 801d1c0:	1c21      	adds	r1, r4, #0
 801d1c2:	4301      	orrs	r1, r0
 801d1c4:	7199      	strb	r1, [r3, #6]
 801d1c6:	0e10      	lsrs	r0, r2, #24
 801d1c8:	79da      	ldrb	r2, [r3, #7]
 801d1ca:	2100      	movs	r1, #0
 801d1cc:	400a      	ands	r2, r1
 801d1ce:	1c11      	adds	r1, r2, #0
 801d1d0:	1c02      	adds	r2, r0, #0
 801d1d2:	430a      	orrs	r2, r1
 801d1d4:	71da      	strb	r2, [r3, #7]
 801d1d6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801d1d8:	3303      	adds	r3, #3
 801d1da:	64fb      	str	r3, [r7, #76]	; 0x4c
    }
    break;
 801d1dc:	e042      	b.n	801d264 <vj_uncompress_tcp+0x7a4>
    	DECODEL(th->seqno);
 801d1de:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801d1e0:	791a      	ldrb	r2, [r3, #4]
 801d1e2:	7959      	ldrb	r1, [r3, #5]
 801d1e4:	0209      	lsls	r1, r1, #8
 801d1e6:	430a      	orrs	r2, r1
 801d1e8:	7999      	ldrb	r1, [r3, #6]
 801d1ea:	0409      	lsls	r1, r1, #16
 801d1ec:	430a      	orrs	r2, r1
 801d1ee:	79db      	ldrb	r3, [r3, #7]
 801d1f0:	061b      	lsls	r3, r3, #24
 801d1f2:	4313      	orrs	r3, r2
 801d1f4:	0018      	movs	r0, r3
 801d1f6:	f7ea f919 	bl	800742c <lwip_htonl>
 801d1fa:	0001      	movs	r1, r0
 801d1fc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801d1fe:	1c5a      	adds	r2, r3, #1
 801d200:	64fa      	str	r2, [r7, #76]	; 0x4c
 801d202:	781b      	ldrb	r3, [r3, #0]
 801d204:	18cb      	adds	r3, r1, r3
 801d206:	61fb      	str	r3, [r7, #28]
 801d208:	69fb      	ldr	r3, [r7, #28]
 801d20a:	0018      	movs	r0, r3
 801d20c:	f7ea f90e 	bl	800742c <lwip_htonl>
 801d210:	0002      	movs	r2, r0
 801d212:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801d214:	21ff      	movs	r1, #255	; 0xff
 801d216:	4011      	ands	r1, r2
 801d218:	000c      	movs	r4, r1
 801d21a:	7919      	ldrb	r1, [r3, #4]
 801d21c:	2000      	movs	r0, #0
 801d21e:	4001      	ands	r1, r0
 801d220:	1c08      	adds	r0, r1, #0
 801d222:	1c21      	adds	r1, r4, #0
 801d224:	4301      	orrs	r1, r0
 801d226:	7119      	strb	r1, [r3, #4]
 801d228:	0a11      	lsrs	r1, r2, #8
 801d22a:	20ff      	movs	r0, #255	; 0xff
 801d22c:	4001      	ands	r1, r0
 801d22e:	000c      	movs	r4, r1
 801d230:	7959      	ldrb	r1, [r3, #5]
 801d232:	2000      	movs	r0, #0
 801d234:	4001      	ands	r1, r0
 801d236:	1c08      	adds	r0, r1, #0
 801d238:	1c21      	adds	r1, r4, #0
 801d23a:	4301      	orrs	r1, r0
 801d23c:	7159      	strb	r1, [r3, #5]
 801d23e:	0c11      	lsrs	r1, r2, #16
 801d240:	20ff      	movs	r0, #255	; 0xff
 801d242:	4001      	ands	r1, r0
 801d244:	000c      	movs	r4, r1
 801d246:	7999      	ldrb	r1, [r3, #6]
 801d248:	2000      	movs	r0, #0
 801d24a:	4001      	ands	r1, r0
 801d24c:	1c08      	adds	r0, r1, #0
 801d24e:	1c21      	adds	r1, r4, #0
 801d250:	4301      	orrs	r1, r0
 801d252:	7199      	strb	r1, [r3, #6]
 801d254:	0e10      	lsrs	r0, r2, #24
 801d256:	79da      	ldrb	r2, [r3, #7]
 801d258:	2100      	movs	r1, #0
 801d25a:	400a      	ands	r2, r1
 801d25c:	1c11      	adds	r1, r2, #0
 801d25e:	1c02      	adds	r2, r0, #0
 801d260:	430a      	orrs	r2, r1
 801d262:	71da      	strb	r2, [r3, #7]
    break;
 801d264:	46c0      	nop			; (mov r8, r8)
  }
  if (changes & NEW_I) {
 801d266:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801d268:	2220      	movs	r2, #32
 801d26a:	4013      	ands	r3, r2
 801d26c:	d041      	beq.n	801d2f2 <vj_uncompress_tcp+0x832>
    DECODES(cs->cs_ip._id);
 801d26e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801d270:	781b      	ldrb	r3, [r3, #0]
 801d272:	2b00      	cmp	r3, #0
 801d274:	d123      	bne.n	801d2be <vj_uncompress_tcp+0x7fe>
 801d276:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d278:	899b      	ldrh	r3, [r3, #12]
 801d27a:	0018      	movs	r0, r3
 801d27c:	f7ea f8c0 	bl	8007400 <lwip_htons>
 801d280:	0003      	movs	r3, r0
 801d282:	0019      	movs	r1, r3
 801d284:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801d286:	3301      	adds	r3, #1
 801d288:	781b      	ldrb	r3, [r3, #0]
 801d28a:	021b      	lsls	r3, r3, #8
 801d28c:	b21a      	sxth	r2, r3
 801d28e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801d290:	3302      	adds	r3, #2
 801d292:	781b      	ldrb	r3, [r3, #0]
 801d294:	b21b      	sxth	r3, r3
 801d296:	4313      	orrs	r3, r2
 801d298:	b21b      	sxth	r3, r3
 801d29a:	b29a      	uxth	r2, r3
 801d29c:	2014      	movs	r0, #20
 801d29e:	183b      	adds	r3, r7, r0
 801d2a0:	188a      	adds	r2, r1, r2
 801d2a2:	801a      	strh	r2, [r3, #0]
 801d2a4:	183b      	adds	r3, r7, r0
 801d2a6:	881b      	ldrh	r3, [r3, #0]
 801d2a8:	0018      	movs	r0, r3
 801d2aa:	f7ea f8a9 	bl	8007400 <lwip_htons>
 801d2ae:	0003      	movs	r3, r0
 801d2b0:	001a      	movs	r2, r3
 801d2b2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d2b4:	819a      	strh	r2, [r3, #12]
 801d2b6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801d2b8:	3303      	adds	r3, #3
 801d2ba:	64fb      	str	r3, [r7, #76]	; 0x4c
 801d2bc:	e02c      	b.n	801d318 <vj_uncompress_tcp+0x858>
 801d2be:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d2c0:	899b      	ldrh	r3, [r3, #12]
 801d2c2:	0018      	movs	r0, r3
 801d2c4:	f7ea f89c 	bl	8007400 <lwip_htons>
 801d2c8:	0003      	movs	r3, r0
 801d2ca:	0019      	movs	r1, r3
 801d2cc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801d2ce:	1c5a      	adds	r2, r3, #1
 801d2d0:	64fa      	str	r2, [r7, #76]	; 0x4c
 801d2d2:	781b      	ldrb	r3, [r3, #0]
 801d2d4:	b29a      	uxth	r2, r3
 801d2d6:	2016      	movs	r0, #22
 801d2d8:	183b      	adds	r3, r7, r0
 801d2da:	188a      	adds	r2, r1, r2
 801d2dc:	801a      	strh	r2, [r3, #0]
 801d2de:	183b      	adds	r3, r7, r0
 801d2e0:	881b      	ldrh	r3, [r3, #0]
 801d2e2:	0018      	movs	r0, r3
 801d2e4:	f7ea f88c 	bl	8007400 <lwip_htons>
 801d2e8:	0003      	movs	r3, r0
 801d2ea:	001a      	movs	r2, r3
 801d2ec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d2ee:	819a      	strh	r2, [r3, #12]
 801d2f0:	e012      	b.n	801d318 <vj_uncompress_tcp+0x858>
  } else {
    IPH_ID_SET(&cs->cs_ip, lwip_ntohs(IPH_ID(&cs->cs_ip)) + 1);
 801d2f2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d2f4:	899b      	ldrh	r3, [r3, #12]
 801d2f6:	0018      	movs	r0, r3
 801d2f8:	f7ea f882 	bl	8007400 <lwip_htons>
 801d2fc:	0003      	movs	r3, r0
 801d2fe:	3301      	adds	r3, #1
 801d300:	b29a      	uxth	r2, r3
 801d302:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d304:	819a      	strh	r2, [r3, #12]
    IPH_ID_SET(&cs->cs_ip, lwip_htons(IPH_ID(&cs->cs_ip)));
 801d306:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d308:	899b      	ldrh	r3, [r3, #12]
 801d30a:	0018      	movs	r0, r3
 801d30c:	f7ea f878 	bl	8007400 <lwip_htons>
 801d310:	0003      	movs	r3, r0
 801d312:	001a      	movs	r2, r3
 801d314:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d316:	819a      	strh	r2, [r3, #12]
  /*
   * At this point, cp points to the first byte of data in the
   * packet.  Fill in the IP total length and update the IP
   * header checksum.
   */
  vjlen = (u16_t)(cp - (u8_t*)n0->payload);
 801d318:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801d31a:	685b      	ldr	r3, [r3, #4]
 801d31c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801d31e:	1ad3      	subs	r3, r2, r3
 801d320:	b29b      	uxth	r3, r3
 801d322:	613b      	str	r3, [r7, #16]
  if (n0->len < vjlen) {
 801d324:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801d326:	895b      	ldrh	r3, [r3, #10]
 801d328:	001a      	movs	r2, r3
 801d32a:	693b      	ldr	r3, [r7, #16]
 801d32c:	4293      	cmp	r3, r2
 801d32e:	d900      	bls.n	801d332 <vj_uncompress_tcp+0x872>
 801d330:	e0e2      	b.n	801d4f8 <vj_uncompress_tcp+0xa38>
          n0->len, vjlen));
    goto bad;
  }

#if BYTE_ORDER == LITTLE_ENDIAN
  tmp = n0->tot_len - vjlen + cs->cs_hlen;
 801d332:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801d334:	891b      	ldrh	r3, [r3, #8]
 801d336:	001a      	movs	r2, r3
 801d338:	693b      	ldr	r3, [r7, #16]
 801d33a:	1ad3      	subs	r3, r2, r3
 801d33c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801d33e:	8892      	ldrh	r2, [r2, #4]
 801d340:	189b      	adds	r3, r3, r2
 801d342:	643b      	str	r3, [r7, #64]	; 0x40
  IPH_LEN_SET(&cs->cs_ip, lwip_htons((u16_t)tmp));
 801d344:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801d346:	b29b      	uxth	r3, r3
 801d348:	0018      	movs	r0, r3
 801d34a:	f7ea f859 	bl	8007400 <lwip_htons>
 801d34e:	0003      	movs	r3, r0
 801d350:	001a      	movs	r2, r3
 801d352:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d354:	815a      	strh	r2, [r3, #10]
#else
  IPH_LEN_SET(&cs->cs_ip, lwip_htons(n0->tot_len - vjlen + cs->cs_hlen));
#endif

  /* recompute the ip header checksum */
  bp = (struct vj_u16_t*) &cs->cs_ip;
 801d356:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d358:	3308      	adds	r3, #8
 801d35a:	64bb      	str	r3, [r7, #72]	; 0x48
  IPH_CHKSUM_SET(&cs->cs_ip, 0);
 801d35c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d35e:	2200      	movs	r2, #0
 801d360:	825a      	strh	r2, [r3, #18]
  for (tmp = 0; hlen > 0; hlen -= 2) {
 801d362:	2300      	movs	r3, #0
 801d364:	643b      	str	r3, [r7, #64]	; 0x40
 801d366:	e00e      	b.n	801d386 <vj_uncompress_tcp+0x8c6>
    tmp += (*bp++).v;
 801d368:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801d36a:	1c9a      	adds	r2, r3, #2
 801d36c:	64ba      	str	r2, [r7, #72]	; 0x48
 801d36e:	781a      	ldrb	r2, [r3, #0]
 801d370:	785b      	ldrb	r3, [r3, #1]
 801d372:	021b      	lsls	r3, r3, #8
 801d374:	4313      	orrs	r3, r2
 801d376:	b29b      	uxth	r3, r3
 801d378:	001a      	movs	r2, r3
 801d37a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801d37c:	189b      	adds	r3, r3, r2
 801d37e:	643b      	str	r3, [r7, #64]	; 0x40
  for (tmp = 0; hlen > 0; hlen -= 2) {
 801d380:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801d382:	3b02      	subs	r3, #2
 801d384:	63fb      	str	r3, [r7, #60]	; 0x3c
 801d386:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801d388:	2b00      	cmp	r3, #0
 801d38a:	d1ed      	bne.n	801d368 <vj_uncompress_tcp+0x8a8>
  }
  tmp = (tmp & 0xffff) + (tmp >> 16);
 801d38c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801d38e:	041b      	lsls	r3, r3, #16
 801d390:	0c1a      	lsrs	r2, r3, #16
 801d392:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801d394:	0c1b      	lsrs	r3, r3, #16
 801d396:	18d3      	adds	r3, r2, r3
 801d398:	643b      	str	r3, [r7, #64]	; 0x40
  tmp = (tmp & 0xffff) + (tmp >> 16);
 801d39a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801d39c:	041b      	lsls	r3, r3, #16
 801d39e:	0c1a      	lsrs	r2, r3, #16
 801d3a0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801d3a2:	0c1b      	lsrs	r3, r3, #16
 801d3a4:	18d3      	adds	r3, r2, r3
 801d3a6:	643b      	str	r3, [r7, #64]	; 0x40
  IPH_CHKSUM_SET(&cs->cs_ip,  (u16_t)(~tmp));
 801d3a8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801d3aa:	b29b      	uxth	r3, r3
 801d3ac:	43db      	mvns	r3, r3
 801d3ae:	b29a      	uxth	r2, r3
 801d3b0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d3b2:	825a      	strh	r2, [r3, #18]

  /* Remove the compressed header and prepend the uncompressed header. */
  if (pbuf_remove_header(n0, vjlen)) {
 801d3b4:	693a      	ldr	r2, [r7, #16]
 801d3b6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801d3b8:	0011      	movs	r1, r2
 801d3ba:	0018      	movs	r0, r3
 801d3bc:	f7ec fff8 	bl	800a3b0 <pbuf_remove_header>
 801d3c0:	1e03      	subs	r3, r0, #0
 801d3c2:	d006      	beq.n	801d3d2 <vj_uncompress_tcp+0x912>
    /* Can we cope with this failing?  Just assert for now */
    LWIP_ASSERT("pbuf_remove_header failed\n", 0);
 801d3c4:	4b54      	ldr	r3, [pc, #336]	; (801d518 <vj_uncompress_tcp+0xa58>)
 801d3c6:	4a55      	ldr	r2, [pc, #340]	; (801d51c <vj_uncompress_tcp+0xa5c>)
 801d3c8:	4955      	ldr	r1, [pc, #340]	; (801d520 <vj_uncompress_tcp+0xa60>)
 801d3ca:	4856      	ldr	r0, [pc, #344]	; (801d524 <vj_uncompress_tcp+0xa64>)
 801d3cc:	f7e4 ff0a 	bl	80021e4 <app_debug_rtt_raw>
    goto bad;
 801d3d0:	e097      	b.n	801d502 <vj_uncompress_tcp+0xa42>
  }

  if(LWIP_MEM_ALIGN(n0->payload) != n0->payload) {
 801d3d2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801d3d4:	685b      	ldr	r3, [r3, #4]
 801d3d6:	3303      	adds	r3, #3
 801d3d8:	2203      	movs	r2, #3
 801d3da:	4393      	bics	r3, r2
 801d3dc:	001a      	movs	r2, r3
 801d3de:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801d3e0:	685b      	ldr	r3, [r3, #4]
 801d3e2:	429a      	cmp	r2, r3
 801d3e4:	d040      	beq.n	801d468 <vj_uncompress_tcp+0x9a8>
     * the packet is being allocated with enough header space to be
     * forwarded (to Ethernet for example).
     */
    np = pbuf_alloc(PBUF_LINK, n0->len + cs->cs_hlen, PBUF_POOL);
#else /* IP_FORWARD */
    np = pbuf_alloc(PBUF_RAW, n0->len + cs->cs_hlen, PBUF_POOL);
 801d3e6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801d3e8:	895a      	ldrh	r2, [r3, #10]
 801d3ea:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d3ec:	889b      	ldrh	r3, [r3, #4]
 801d3ee:	18d3      	adds	r3, r2, r3
 801d3f0:	b29b      	uxth	r3, r3
 801d3f2:	22c1      	movs	r2, #193	; 0xc1
 801d3f4:	0052      	lsls	r2, r2, #1
 801d3f6:	0019      	movs	r1, r3
 801d3f8:	2000      	movs	r0, #0
 801d3fa:	f7ec fd39 	bl	8009e70 <pbuf_alloc>
 801d3fe:	0003      	movs	r3, r0
 801d400:	60fb      	str	r3, [r7, #12]
#endif /* IP_FORWARD */
    if(!np) {
 801d402:	68fb      	ldr	r3, [r7, #12]
 801d404:	2b00      	cmp	r3, #0
 801d406:	d100      	bne.n	801d40a <vj_uncompress_tcp+0x94a>
 801d408:	e078      	b.n	801d4fc <vj_uncompress_tcp+0xa3c>
      PPPDEBUG(LOG_WARNING, ("vj_uncompress_tcp: realign failed\n"));
      goto bad;
    }

    if (pbuf_remove_header(np, cs->cs_hlen)) {
 801d40a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d40c:	889b      	ldrh	r3, [r3, #4]
 801d40e:	001a      	movs	r2, r3
 801d410:	68fb      	ldr	r3, [r7, #12]
 801d412:	0011      	movs	r1, r2
 801d414:	0018      	movs	r0, r3
 801d416:	f7ec ffcb 	bl	800a3b0 <pbuf_remove_header>
 801d41a:	1e03      	subs	r3, r0, #0
 801d41c:	d007      	beq.n	801d42e <vj_uncompress_tcp+0x96e>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_remove_header failed\n", 0);
 801d41e:	4b3e      	ldr	r3, [pc, #248]	; (801d518 <vj_uncompress_tcp+0xa58>)
 801d420:	22a2      	movs	r2, #162	; 0xa2
 801d422:	0092      	lsls	r2, r2, #2
 801d424:	493e      	ldr	r1, [pc, #248]	; (801d520 <vj_uncompress_tcp+0xa60>)
 801d426:	483f      	ldr	r0, [pc, #252]	; (801d524 <vj_uncompress_tcp+0xa64>)
 801d428:	f7e4 fedc 	bl	80021e4 <app_debug_rtt_raw>
      goto bad;
 801d42c:	e069      	b.n	801d502 <vj_uncompress_tcp+0xa42>
    }

    pbuf_take(np, n0->payload, n0->len);
 801d42e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801d430:	6859      	ldr	r1, [r3, #4]
 801d432:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801d434:	895a      	ldrh	r2, [r3, #10]
 801d436:	68fb      	ldr	r3, [r7, #12]
 801d438:	0018      	movs	r0, r3
 801d43a:	f7ed fbef 	bl	800ac1c <pbuf_take>

    if(n0->next) {
 801d43e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801d440:	681b      	ldr	r3, [r3, #0]
 801d442:	2b00      	cmp	r3, #0
 801d444:	d00a      	beq.n	801d45c <vj_uncompress_tcp+0x99c>
      pbuf_chain(np, n0->next);
 801d446:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801d448:	681a      	ldr	r2, [r3, #0]
 801d44a:	68fb      	ldr	r3, [r7, #12]
 801d44c:	0011      	movs	r1, r2
 801d44e:	0018      	movs	r0, r3
 801d450:	f7ed f978 	bl	800a744 <pbuf_chain>
      pbuf_dechain(n0);
 801d454:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801d456:	0018      	movs	r0, r3
 801d458:	f7ed f988 	bl	800a76c <pbuf_dechain>
    }
    pbuf_free(n0);
 801d45c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801d45e:	0018      	movs	r0, r3
 801d460:	f7ed f83c 	bl	800a4dc <pbuf_free>
    n0 = np;
 801d464:	68fb      	ldr	r3, [r7, #12]
 801d466:	647b      	str	r3, [r7, #68]	; 0x44
  }

  if (pbuf_add_header(n0, cs->cs_hlen)) {
 801d468:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d46a:	889b      	ldrh	r3, [r3, #4]
 801d46c:	001a      	movs	r2, r3
 801d46e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801d470:	0011      	movs	r1, r2
 801d472:	0018      	movs	r0, r3
 801d474:	f7ec ff8c 	bl	800a390 <pbuf_add_header>
 801d478:	1e03      	subs	r3, r0, #0
 801d47a:	d020      	beq.n	801d4be <vj_uncompress_tcp+0x9fe>
    struct pbuf *np;

    LWIP_ASSERT("vj_uncompress_tcp: cs->cs_hlen <= PBUF_POOL_BUFSIZE", cs->cs_hlen <= PBUF_POOL_BUFSIZE);
 801d47c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d47e:	889a      	ldrh	r2, [r3, #4]
 801d480:	2394      	movs	r3, #148	; 0x94
 801d482:	009b      	lsls	r3, r3, #2
 801d484:	429a      	cmp	r2, r3
 801d486:	d905      	bls.n	801d494 <vj_uncompress_tcp+0x9d4>
 801d488:	4b23      	ldr	r3, [pc, #140]	; (801d518 <vj_uncompress_tcp+0xa58>)
 801d48a:	4a27      	ldr	r2, [pc, #156]	; (801d528 <vj_uncompress_tcp+0xa68>)
 801d48c:	4927      	ldr	r1, [pc, #156]	; (801d52c <vj_uncompress_tcp+0xa6c>)
 801d48e:	4825      	ldr	r0, [pc, #148]	; (801d524 <vj_uncompress_tcp+0xa64>)
 801d490:	f7e4 fea8 	bl	80021e4 <app_debug_rtt_raw>
    np = pbuf_alloc(PBUF_RAW, cs->cs_hlen, PBUF_POOL);
 801d494:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d496:	889b      	ldrh	r3, [r3, #4]
 801d498:	22c1      	movs	r2, #193	; 0xc1
 801d49a:	0052      	lsls	r2, r2, #1
 801d49c:	0019      	movs	r1, r3
 801d49e:	2000      	movs	r0, #0
 801d4a0:	f7ec fce6 	bl	8009e70 <pbuf_alloc>
 801d4a4:	0003      	movs	r3, r0
 801d4a6:	60bb      	str	r3, [r7, #8]
    if(!np) {
 801d4a8:	68bb      	ldr	r3, [r7, #8]
 801d4aa:	2b00      	cmp	r3, #0
 801d4ac:	d028      	beq.n	801d500 <vj_uncompress_tcp+0xa40>
      PPPDEBUG(LOG_WARNING, ("vj_uncompress_tcp: prepend failed\n"));
      goto bad;
    }
    pbuf_cat(np, n0);
 801d4ae:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801d4b0:	68bb      	ldr	r3, [r7, #8]
 801d4b2:	0011      	movs	r1, r2
 801d4b4:	0018      	movs	r0, r3
 801d4b6:	f7ed f8f1 	bl	800a69c <pbuf_cat>
    n0 = np;
 801d4ba:	68bb      	ldr	r3, [r7, #8]
 801d4bc:	647b      	str	r3, [r7, #68]	; 0x44
  }
  LWIP_ASSERT("n0->len >= cs->cs_hlen", n0->len >= cs->cs_hlen);
 801d4be:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801d4c0:	895a      	ldrh	r2, [r3, #10]
 801d4c2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d4c4:	889b      	ldrh	r3, [r3, #4]
 801d4c6:	429a      	cmp	r2, r3
 801d4c8:	d205      	bcs.n	801d4d6 <vj_uncompress_tcp+0xa16>
 801d4ca:	4b13      	ldr	r3, [pc, #76]	; (801d518 <vj_uncompress_tcp+0xa58>)
 801d4cc:	4a18      	ldr	r2, [pc, #96]	; (801d530 <vj_uncompress_tcp+0xa70>)
 801d4ce:	4919      	ldr	r1, [pc, #100]	; (801d534 <vj_uncompress_tcp+0xa74>)
 801d4d0:	4814      	ldr	r0, [pc, #80]	; (801d524 <vj_uncompress_tcp+0xa64>)
 801d4d2:	f7e4 fe87 	bl	80021e4 <app_debug_rtt_raw>
  MEMCPY(n0->payload, &cs->cs_ip, cs->cs_hlen);
 801d4d6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801d4d8:	6858      	ldr	r0, [r3, #4]
 801d4da:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d4dc:	3308      	adds	r3, #8
 801d4de:	0019      	movs	r1, r3
 801d4e0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d4e2:	889b      	ldrh	r3, [r3, #4]
 801d4e4:	001a      	movs	r2, r3
 801d4e6:	f000 fd59 	bl	801df9c <memcpy>

  *nb = n0;
 801d4ea:	687b      	ldr	r3, [r7, #4]
 801d4ec:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801d4ee:	601a      	str	r2, [r3, #0]

  return vjlen;
 801d4f0:	693b      	ldr	r3, [r7, #16]
 801d4f2:	e00c      	b.n	801d50e <vj_uncompress_tcp+0xa4e>
      goto bad;
 801d4f4:	46c0      	nop			; (mov r8, r8)
 801d4f6:	e004      	b.n	801d502 <vj_uncompress_tcp+0xa42>
    goto bad;
 801d4f8:	46c0      	nop			; (mov r8, r8)
 801d4fa:	e002      	b.n	801d502 <vj_uncompress_tcp+0xa42>
      goto bad;
 801d4fc:	46c0      	nop			; (mov r8, r8)
 801d4fe:	e000      	b.n	801d502 <vj_uncompress_tcp+0xa42>
      goto bad;
 801d500:	46c0      	nop			; (mov r8, r8)

bad:
  vj_uncompress_err(comp);
 801d502:	683b      	ldr	r3, [r7, #0]
 801d504:	0018      	movs	r0, r3
 801d506:	f7ff fa5d 	bl	801c9c4 <vj_uncompress_err>
  return (-1);
 801d50a:	2301      	movs	r3, #1
 801d50c:	425b      	negs	r3, r3
}
 801d50e:	0018      	movs	r0, r3
 801d510:	46bd      	mov	sp, r7
 801d512:	b015      	add	sp, #84	; 0x54
 801d514:	bd90      	pop	{r4, r7, pc}
 801d516:	46c0      	nop			; (mov r8, r8)
 801d518:	08022ca0 	.word	0x08022ca0
 801d51c:	00000271 	.word	0x00000271
 801d520:	08022ccc 	.word	0x08022ccc
 801d524:	08022ce8 	.word	0x08022ce8
 801d528:	00000299 	.word	0x00000299
 801d52c:	08022d14 	.word	0x08022d14
 801d530:	000002a2 	.word	0x000002a2
 801d534:	08022d48 	.word	0x08022d48

0801d538 <__NVIC_SystemReset>:
{
 801d538:	b580      	push	{r7, lr}
 801d53a:	af00      	add	r7, sp, #0
  __ASM volatile ("dsb 0xF":::"memory");
 801d53c:	f3bf 8f4f 	dsb	sy
}
 801d540:	46c0      	nop			; (mov r8, r8)
  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 801d542:	4b04      	ldr	r3, [pc, #16]	; (801d554 <__NVIC_SystemReset+0x1c>)
 801d544:	4a04      	ldr	r2, [pc, #16]	; (801d558 <__NVIC_SystemReset+0x20>)
 801d546:	60da      	str	r2, [r3, #12]
  __ASM volatile ("dsb 0xF":::"memory");
 801d548:	f3bf 8f4f 	dsb	sy
}
 801d54c:	46c0      	nop			; (mov r8, r8)
    __NOP();
 801d54e:	46c0      	nop			; (mov r8, r8)
 801d550:	e7fd      	b.n	801d54e <__NVIC_SystemReset+0x16>
 801d552:	46c0      	nop			; (mov r8, r8)
 801d554:	e000ed00 	.word	0xe000ed00
 801d558:	05fa0004 	.word	0x05fa0004

0801d55c <MQTT_Client_Init>:
static bool m_is_dns_resolved = false;
static uint8_t Retry_Send_Subcribe = 0;
static bool m_is_valid_sub_topic = false;

void MQTT_Client_Init (MQTT_Client_Config_TypDef* cfg)
{
 801d55c:	b580      	push	{r7, lr}
 801d55e:	b084      	sub	sp, #16
 801d560:	af02      	add	r7, sp, #8
 801d562:	6078      	str	r0, [r7, #4]
    memcpy(&MQTT_Client_Config, cfg, sizeof(MQTT_Client_Config_TypDef));
 801d564:	6879      	ldr	r1, [r7, #4]
 801d566:	4b0d      	ldr	r3, [pc, #52]	; (801d59c <MQTT_Client_Init+0x40>)
 801d568:	2218      	movs	r2, #24
 801d56a:	0018      	movs	r0, r3
 801d56c:	f000 fd16 	bl	801df9c <memcpy>
    snprintf(MQTT_Publish_Topic_Name, sizeof(MQTT_Publish_Topic_Name), "%s%s",
 801d570:	490b      	ldr	r1, [pc, #44]	; (801d5a0 <MQTT_Client_Init+0x44>)
 801d572:	4a0c      	ldr	r2, [pc, #48]	; (801d5a4 <MQTT_Client_Init+0x48>)
 801d574:	480c      	ldr	r0, [pc, #48]	; (801d5a8 <MQTT_Client_Init+0x4c>)
 801d576:	4b0d      	ldr	r3, [pc, #52]	; (801d5ac <MQTT_Client_Init+0x50>)
 801d578:	9300      	str	r3, [sp, #0]
 801d57a:	000b      	movs	r3, r1
 801d57c:	2130      	movs	r1, #48	; 0x30
 801d57e:	f000 fdeb 	bl	801e158 <sniprintf>
                                             TOPIC_PUB_HEADER, "Test_Publish");
    snprintf(MQTT_Subscribe_Topic_Name, sizeof(MQTT_Subscribe_Topic_Name), "%s%s",
 801d582:	490b      	ldr	r1, [pc, #44]	; (801d5b0 <MQTT_Client_Init+0x54>)
 801d584:	4a07      	ldr	r2, [pc, #28]	; (801d5a4 <MQTT_Client_Init+0x48>)
 801d586:	480b      	ldr	r0, [pc, #44]	; (801d5b4 <MQTT_Client_Init+0x58>)
 801d588:	4b0b      	ldr	r3, [pc, #44]	; (801d5b8 <MQTT_Client_Init+0x5c>)
 801d58a:	9300      	str	r3, [sp, #0]
 801d58c:	000b      	movs	r3, r1
 801d58e:	2130      	movs	r1, #48	; 0x30
 801d590:	f000 fde2 	bl	801e158 <sniprintf>
                                             TOPIC_SUB_HEADER, "Test_Subcribe");
}
 801d594:	46c0      	nop			; (mov r8, r8)
 801d596:	46bd      	mov	sp, r7
 801d598:	b002      	add	sp, #8
 801d59a:	bd80      	pop	{r7, pc}
 801d59c:	20001000 	.word	0x20001000
 801d5a0:	08022d60 	.word	0x08022d60
 801d5a4:	08022d74 	.word	0x08022d74
 801d5a8:	20000cac 	.word	0x20000cac
 801d5ac:	08022d7c 	.word	0x08022d7c
 801d5b0:	08022d8c 	.word	0x08022d8c
 801d5b4:	20000cdc 	.word	0x20000cdc
 801d5b8:	08022da0 	.word	0x08022da0

0801d5bc <MQTT_Subcribe_Request_Callback>:
static void MQTT_Subcribe_Request_Callback(void *arg, err_t result)
{
 801d5bc:	b5b0      	push	{r4, r5, r7, lr}
 801d5be:	b086      	sub	sp, #24
 801d5c0:	af02      	add	r7, sp, #8
 801d5c2:	6078      	str	r0, [r7, #4]
 801d5c4:	000a      	movs	r2, r1
 801d5c6:	1cfb      	adds	r3, r7, #3
 801d5c8:	701a      	strb	r2, [r3, #0]
    if(result != ERR_OK)
 801d5ca:	1cfb      	adds	r3, r7, #3
 801d5cc:	781b      	ldrb	r3, [r3, #0]
 801d5ce:	b25b      	sxtb	r3, r3
 801d5d0:	2b00      	cmp	r3, #0
 801d5d2:	d04c      	beq.n	801d66e <MQTT_Subcribe_Request_Callback+0xb2>
    {
        DEBUG_INFO("Retry send subscribe %d\r\n", Retry_Send_Subcribe);
 801d5d4:	f000 fc8e 	bl	801def4 <sys_get_tick_ms>
 801d5d8:	0001      	movs	r1, r0
 801d5da:	4b2c      	ldr	r3, [pc, #176]	; (801d68c <MQTT_Subcribe_Request_Callback+0xd0>)
 801d5dc:	781b      	ldrb	r3, [r3, #0]
 801d5de:	4a2c      	ldr	r2, [pc, #176]	; (801d690 <MQTT_Subcribe_Request_Callback+0xd4>)
 801d5e0:	482c      	ldr	r0, [pc, #176]	; (801d694 <MQTT_Subcribe_Request_Callback+0xd8>)
 801d5e2:	f7e4 fdff 	bl	80021e4 <app_debug_rtt_raw>
        if(++Retry_Send_Subcribe >= MAXTIME_RETRY_SEND_SUBCRIBE)
 801d5e6:	4b29      	ldr	r3, [pc, #164]	; (801d68c <MQTT_Subcribe_Request_Callback+0xd0>)
 801d5e8:	781b      	ldrb	r3, [r3, #0]
 801d5ea:	3301      	adds	r3, #1
 801d5ec:	b2da      	uxtb	r2, r3
 801d5ee:	4b27      	ldr	r3, [pc, #156]	; (801d68c <MQTT_Subcribe_Request_Callback+0xd0>)
 801d5f0:	701a      	strb	r2, [r3, #0]
 801d5f2:	4b26      	ldr	r3, [pc, #152]	; (801d68c <MQTT_Subcribe_Request_Callback+0xd0>)
 801d5f4:	781b      	ldrb	r3, [r3, #0]
 801d5f6:	2b04      	cmp	r3, #4
 801d5f8:	d90e      	bls.n	801d618 <MQTT_Subcribe_Request_Callback+0x5c>
        {
            Retry_Send_Subcribe = 0;
 801d5fa:	4b24      	ldr	r3, [pc, #144]	; (801d68c <MQTT_Subcribe_Request_Callback+0xd0>)
 801d5fc:	2200      	movs	r2, #0
 801d5fe:	701a      	strb	r2, [r3, #0]
            /* close mqtt connection */
            mqtt_disconnect(&MQTT_Static_Client);
 801d600:	4b25      	ldr	r3, [pc, #148]	; (801d698 <MQTT_Subcribe_Request_Callback+0xdc>)
 801d602:	0018      	movs	r0, r3
 801d604:	f7e9 fc34 	bl	8006e70 <mqtt_disconnect>
            MQTT_Client_State = MQTT_CLIENT_STATE_DISCONNECTED;
 801d608:	4b24      	ldr	r3, [pc, #144]	; (801d69c <MQTT_Subcribe_Request_Callback+0xe0>)
 801d60a:	2200      	movs	r2, #0
 801d60c:	701a      	strb	r2, [r3, #0]
            DEBUG_RAW("MQTT_CLIENT_STATE_DISCONNECTED\r\n");
 801d60e:	4b24      	ldr	r3, [pc, #144]	; (801d6a0 <MQTT_Subcribe_Request_Callback+0xe4>)
 801d610:	0018      	movs	r0, r3
 801d612:	f7e4 fde7 	bl	80021e4 <app_debug_rtt_raw>
    else
    {
        MQTT_Process_Now = true;
        DEBUG_INFO("Subscribed\r\n");
    }
}
 801d616:	e035      	b.n	801d684 <MQTT_Subcribe_Request_Callback+0xc8>
            err_t err = mqtt_subscribe(&MQTT_Static_Client,
 801d618:	250f      	movs	r5, #15
 801d61a:	197c      	adds	r4, r7, r5
 801d61c:	4a21      	ldr	r2, [pc, #132]	; (801d6a4 <MQTT_Subcribe_Request_Callback+0xe8>)
 801d61e:	4922      	ldr	r1, [pc, #136]	; (801d6a8 <MQTT_Subcribe_Request_Callback+0xec>)
 801d620:	481d      	ldr	r0, [pc, #116]	; (801d698 <MQTT_Subcribe_Request_Callback+0xdc>)
 801d622:	2301      	movs	r3, #1
 801d624:	9301      	str	r3, [sp, #4]
 801d626:	687b      	ldr	r3, [r7, #4]
 801d628:	9300      	str	r3, [sp, #0]
 801d62a:	0013      	movs	r3, r2
 801d62c:	2201      	movs	r2, #1
 801d62e:	f7e9 f863 	bl	80066f8 <mqtt_sub_unsub>
 801d632:	0003      	movs	r3, r0
 801d634:	7023      	strb	r3, [r4, #0]
            if(err == ERR_OK)
 801d636:	197b      	adds	r3, r7, r5
 801d638:	781b      	ldrb	r3, [r3, #0]
 801d63a:	b25b      	sxtb	r3, r3
 801d63c:	2b00      	cmp	r3, #0
 801d63e:	d10a      	bne.n	801d656 <MQTT_Subcribe_Request_Callback+0x9a>
                DEBUG_INFO("mqtt_subscribe ok: %d\r\n", err);
 801d640:	f000 fc58 	bl	801def4 <sys_get_tick_ms>
 801d644:	0001      	movs	r1, r0
 801d646:	197b      	adds	r3, r7, r5
 801d648:	781b      	ldrb	r3, [r3, #0]
 801d64a:	b25b      	sxtb	r3, r3
 801d64c:	4a10      	ldr	r2, [pc, #64]	; (801d690 <MQTT_Subcribe_Request_Callback+0xd4>)
 801d64e:	4817      	ldr	r0, [pc, #92]	; (801d6ac <MQTT_Subcribe_Request_Callback+0xf0>)
 801d650:	f7e4 fdc8 	bl	80021e4 <app_debug_rtt_raw>
}
 801d654:	e016      	b.n	801d684 <MQTT_Subcribe_Request_Callback+0xc8>
                DEBUG_INFO("mqtt_subscribe error: %d\r\n", err);
 801d656:	f000 fc4d 	bl	801def4 <sys_get_tick_ms>
 801d65a:	0001      	movs	r1, r0
 801d65c:	230f      	movs	r3, #15
 801d65e:	18fb      	adds	r3, r7, r3
 801d660:	781b      	ldrb	r3, [r3, #0]
 801d662:	b25b      	sxtb	r3, r3
 801d664:	4a0a      	ldr	r2, [pc, #40]	; (801d690 <MQTT_Subcribe_Request_Callback+0xd4>)
 801d666:	4812      	ldr	r0, [pc, #72]	; (801d6b0 <MQTT_Subcribe_Request_Callback+0xf4>)
 801d668:	f7e4 fdbc 	bl	80021e4 <app_debug_rtt_raw>
}
 801d66c:	e00a      	b.n	801d684 <MQTT_Subcribe_Request_Callback+0xc8>
        MQTT_Process_Now = true;
 801d66e:	4b11      	ldr	r3, [pc, #68]	; (801d6b4 <MQTT_Subcribe_Request_Callback+0xf8>)
 801d670:	2201      	movs	r2, #1
 801d672:	701a      	strb	r2, [r3, #0]
        DEBUG_INFO("Subscribed\r\n");
 801d674:	f000 fc3e 	bl	801def4 <sys_get_tick_ms>
 801d678:	0001      	movs	r1, r0
 801d67a:	4a05      	ldr	r2, [pc, #20]	; (801d690 <MQTT_Subcribe_Request_Callback+0xd4>)
 801d67c:	4b0e      	ldr	r3, [pc, #56]	; (801d6b8 <MQTT_Subcribe_Request_Callback+0xfc>)
 801d67e:	0018      	movs	r0, r3
 801d680:	f7e4 fdb0 	bl	80021e4 <app_debug_rtt_raw>
}
 801d684:	46c0      	nop			; (mov r8, r8)
 801d686:	46bd      	mov	sp, r7
 801d688:	b004      	add	sp, #16
 801d68a:	bdb0      	pop	{r4, r5, r7, pc}
 801d68c:	2000101e 	.word	0x2000101e
 801d690:	08022db0 	.word	0x08022db0
 801d694:	08022db4 	.word	0x08022db4
 801d698:	20000e0c 	.word	0x20000e0c
 801d69c:	20000ffc 	.word	0x20000ffc
 801d6a0:	08022de8 	.word	0x08022de8
 801d6a4:	0801d5bd 	.word	0x0801d5bd
 801d6a8:	20000cdc 	.word	0x20000cdc
 801d6ac:	08022e0c 	.word	0x08022e0c
 801d6b0:	08022e40 	.word	0x08022e40
 801d6b4:	2000101c 	.word	0x2000101c
 801d6b8:	08022e74 	.word	0x08022e74

0801d6bc <MQTT_Incoming_Publish_Callback>:
   Example here uses a global variable, better would be to use a member in arg
   If RAM and CPU budget allows it, the easiest implementation might be to just take a copy of
   the topic string and use it in mqtt_incoming_data_cb
*/
static void MQTT_Incoming_Publish_Callback (void *arg, const char *topic, u32_t topic_len)
{
 801d6bc:	b590      	push	{r4, r7, lr}
 801d6be:	b087      	sub	sp, #28
 801d6c0:	af02      	add	r7, sp, #8
 801d6c2:	60f8      	str	r0, [r7, #12]
 801d6c4:	60b9      	str	r1, [r7, #8]
 801d6c6:	607a      	str	r2, [r7, #4]
    DEBUG_INFO("MQTT publish topic %s, length %u\r\n", topic, (unsigned int) topic_len);
 801d6c8:	f000 fc14 	bl	801def4 <sys_get_tick_ms>
 801d6cc:	0004      	movs	r4, r0
 801d6ce:	68b9      	ldr	r1, [r7, #8]
 801d6d0:	4a0d      	ldr	r2, [pc, #52]	; (801d708 <MQTT_Incoming_Publish_Callback+0x4c>)
 801d6d2:	480e      	ldr	r0, [pc, #56]	; (801d70c <MQTT_Incoming_Publish_Callback+0x50>)
 801d6d4:	687b      	ldr	r3, [r7, #4]
 801d6d6:	9300      	str	r3, [sp, #0]
 801d6d8:	000b      	movs	r3, r1
 801d6da:	0021      	movs	r1, r4
 801d6dc:	f7e4 fd82 	bl	80021e4 <app_debug_rtt_raw>
    /* Decode topic string into a user defined reference */
    if(strcmp(topic, MQTT_Subscribe_Topic_Name) == 0)
 801d6e0:	4a0b      	ldr	r2, [pc, #44]	; (801d710 <MQTT_Incoming_Publish_Callback+0x54>)
 801d6e2:	68bb      	ldr	r3, [r7, #8]
 801d6e4:	0011      	movs	r1, r2
 801d6e6:	0018      	movs	r0, r3
 801d6e8:	f7e2 fd0e 	bl	8000108 <strcmp>
 801d6ec:	1e03      	subs	r3, r0, #0
 801d6ee:	d103      	bne.n	801d6f8 <MQTT_Incoming_Publish_Callback+0x3c>
    {
        m_is_valid_sub_topic = true;
 801d6f0:	4b08      	ldr	r3, [pc, #32]	; (801d714 <MQTT_Incoming_Publish_Callback+0x58>)
 801d6f2:	2201      	movs	r2, #1
 801d6f4:	701a      	strb	r2, [r3, #0]
    }
    else
    {
        m_is_valid_sub_topic = false;
    }
}
 801d6f6:	e002      	b.n	801d6fe <MQTT_Incoming_Publish_Callback+0x42>
        m_is_valid_sub_topic = false;
 801d6f8:	4b06      	ldr	r3, [pc, #24]	; (801d714 <MQTT_Incoming_Publish_Callback+0x58>)
 801d6fa:	2200      	movs	r2, #0
 801d6fc:	701a      	strb	r2, [r3, #0]
}
 801d6fe:	46c0      	nop			; (mov r8, r8)
 801d700:	46bd      	mov	sp, r7
 801d702:	b005      	add	sp, #20
 801d704:	bd90      	pop	{r4, r7, pc}
 801d706:	46c0      	nop			; (mov r8, r8)
 801d708:	08022db0 	.word	0x08022db0
 801d70c:	08022e9c 	.word	0x08022e9c
 801d710:	20000cdc 	.word	0x20000cdc
 801d714:	2000101f 	.word	0x2000101f

0801d718 <MQTT_Incoming_Data_Callback>:
static void MQTT_Incoming_Data_Callback(void *arg, const u8_t *data, u16_t len, u8_t flags)
{
 801d718:	b590      	push	{r4, r7, lr}
 801d71a:	b087      	sub	sp, #28
 801d71c:	af02      	add	r7, sp, #8
 801d71e:	60f8      	str	r0, [r7, #12]
 801d720:	60b9      	str	r1, [r7, #8]
 801d722:	0019      	movs	r1, r3
 801d724:	1dbb      	adds	r3, r7, #6
 801d726:	801a      	strh	r2, [r3, #0]
 801d728:	1d7b      	adds	r3, r7, #5
 801d72a:	1c0a      	adds	r2, r1, #0
 801d72c:	701a      	strb	r2, [r3, #0]
    DEBUG_INFO("MQTT data cb, length %d, flags %u\r\n", len, (unsigned int)flags);
 801d72e:	f000 fbe1 	bl	801def4 <sys_get_tick_ms>
 801d732:	0004      	movs	r4, r0
 801d734:	1dbb      	adds	r3, r7, #6
 801d736:	8819      	ldrh	r1, [r3, #0]
 801d738:	1d7b      	adds	r3, r7, #5
 801d73a:	781b      	ldrb	r3, [r3, #0]
 801d73c:	4a1f      	ldr	r2, [pc, #124]	; (801d7bc <MQTT_Incoming_Data_Callback+0xa4>)
 801d73e:	4820      	ldr	r0, [pc, #128]	; (801d7c0 <MQTT_Incoming_Data_Callback+0xa8>)
 801d740:	9300      	str	r3, [sp, #0]
 801d742:	000b      	movs	r3, r1
 801d744:	0021      	movs	r1, r4
 801d746:	f7e4 fd4d 	bl	80021e4 <app_debug_rtt_raw>
    if(flags & MQTT_DATA_FLAG_LAST)
 801d74a:	1d7b      	adds	r3, r7, #5
 801d74c:	781b      	ldrb	r3, [r3, #0]
 801d74e:	2201      	movs	r2, #1
 801d750:	4013      	ands	r3, r2
 801d752:	d02f      	beq.n	801d7b4 <MQTT_Incoming_Data_Callback+0x9c>
    {
        DEBUG_INFO("Payload data: %s\r\n", (const char *)data);
 801d754:	f000 fbce 	bl	801def4 <sys_get_tick_ms>
 801d758:	0001      	movs	r1, r0
 801d75a:	68bb      	ldr	r3, [r7, #8]
 801d75c:	4a17      	ldr	r2, [pc, #92]	; (801d7bc <MQTT_Incoming_Data_Callback+0xa4>)
 801d75e:	4819      	ldr	r0, [pc, #100]	; (801d7c4 <MQTT_Incoming_Data_Callback+0xac>)
 801d760:	f7e4 fd40 	bl	80021e4 <app_debug_rtt_raw>
        if(m_is_valid_sub_topic)
 801d764:	4b18      	ldr	r3, [pc, #96]	; (801d7c8 <MQTT_Incoming_Data_Callback+0xb0>)
 801d766:	781b      	ldrb	r3, [r3, #0]
 801d768:	2b00      	cmp	r3, #0
 801d76a:	d01d      	beq.n	801d7a8 <MQTT_Incoming_Data_Callback+0x90>
        {
            m_is_valid_sub_topic = false;
 801d76c:	4b16      	ldr	r3, [pc, #88]	; (801d7c8 <MQTT_Incoming_Data_Callback+0xb0>)
 801d76e:	2200      	movs	r2, #0
 801d770:	701a      	strb	r2, [r3, #0]
            /* Update firmware message  */
            if (strstr((char *)data, "UDFW,"))
 801d772:	4a16      	ldr	r2, [pc, #88]	; (801d7cc <MQTT_Incoming_Data_Callback+0xb4>)
 801d774:	68bb      	ldr	r3, [r7, #8]
 801d776:	0011      	movs	r1, r2
 801d778:	0018      	movs	r0, r3
 801d77a:	f000 fd35 	bl	801e1e8 <strstr>
 801d77e:	1e03      	subs	r3, r0, #0
 801d780:	d008      	beq.n	801d794 <MQTT_Incoming_Data_Callback+0x7c>
            {
                DEBUG_INFO("Update firmware\r\n");
 801d782:	f000 fbb7 	bl	801def4 <sys_get_tick_ms>
 801d786:	0001      	movs	r1, r0
 801d788:	4a0c      	ldr	r2, [pc, #48]	; (801d7bc <MQTT_Incoming_Data_Callback+0xa4>)
 801d78a:	4b11      	ldr	r3, [pc, #68]	; (801d7d0 <MQTT_Incoming_Data_Callback+0xb8>)
 801d78c:	0018      	movs	r0, r3
 801d78e:	f7e4 fd29 	bl	80021e4 <app_debug_rtt_raw>
 801d792:	e009      	b.n	801d7a8 <MQTT_Incoming_Data_Callback+0x90>
            }
            else if (strstr((char *)data, "PLEASE RESET"))
 801d794:	4a0f      	ldr	r2, [pc, #60]	; (801d7d4 <MQTT_Incoming_Data_Callback+0xbc>)
 801d796:	68bb      	ldr	r3, [r7, #8]
 801d798:	0011      	movs	r1, r2
 801d79a:	0018      	movs	r0, r3
 801d79c:	f000 fd24 	bl	801e1e8 <strstr>
 801d7a0:	1e03      	subs	r3, r0, #0
 801d7a2:	d001      	beq.n	801d7a8 <MQTT_Incoming_Data_Callback+0x90>
            {
                NVIC_SystemReset();
 801d7a4:	f7ff fec8 	bl	801d538 <__NVIC_SystemReset>
            }
        }
        // Clear received buffer of client -> du lieu nhan lan sau khong bi thua cua lan truoc,
        // neu lan truoc gui length > MQTT_VAR_HEADER_BUFFER_LEN
        memset(MQTT_Static_Client.rx_buffer, 0, MQTT_VAR_HEADER_BUFFER_LEN);
 801d7a8:	4b0b      	ldr	r3, [pc, #44]	; (801d7d8 <MQTT_Incoming_Data_Callback+0xc0>)
 801d7aa:	2280      	movs	r2, #128	; 0x80
 801d7ac:	2100      	movs	r1, #0
 801d7ae:	0018      	movs	r0, r3
 801d7b0:	f000 fc10 	bl	801dfd4 <memset>
    }
    else
    {
        /* Handle fragmented payload, store in buffer, write to file or whatever */
    }
}
 801d7b4:	46c0      	nop			; (mov r8, r8)
 801d7b6:	46bd      	mov	sp, r7
 801d7b8:	b005      	add	sp, #20
 801d7ba:	bd90      	pop	{r4, r7, pc}
 801d7bc:	08022db0 	.word	0x08022db0
 801d7c0:	08022ed8 	.word	0x08022ed8
 801d7c4:	08022f18 	.word	0x08022f18
 801d7c8:	2000101f 	.word	0x2000101f
 801d7cc:	08022f44 	.word	0x08022f44
 801d7d0:	08022f4c 	.word	0x08022f4c
 801d7d4:	08022f78 	.word	0x08022f78
 801d7d8:	20000e78 	.word	0x20000e78

0801d7dc <MQTT_Client_Connection_Callback>:
void MQTT_Client_Connection_Callback(mqtt_client_t *client, void *arg, mqtt_connection_status_t status)
{
 801d7dc:	b5b0      	push	{r4, r5, r7, lr}
 801d7de:	b088      	sub	sp, #32
 801d7e0:	af02      	add	r7, sp, #8
 801d7e2:	60f8      	str	r0, [r7, #12]
 801d7e4:	60b9      	str	r1, [r7, #8]
 801d7e6:	1dbb      	adds	r3, r7, #6
 801d7e8:	801a      	strh	r2, [r3, #0]
    DEBUG_INFO("mqtt_client_connection_callback reason: %d\r\n", status);
 801d7ea:	f000 fb83 	bl	801def4 <sys_get_tick_ms>
 801d7ee:	0001      	movs	r1, r0
 801d7f0:	1dbb      	adds	r3, r7, #6
 801d7f2:	881b      	ldrh	r3, [r3, #0]
 801d7f4:	4a34      	ldr	r2, [pc, #208]	; (801d8c8 <MQTT_Client_Connection_Callback+0xec>)
 801d7f6:	4835      	ldr	r0, [pc, #212]	; (801d8cc <MQTT_Client_Connection_Callback+0xf0>)
 801d7f8:	f7e4 fcf4 	bl	80021e4 <app_debug_rtt_raw>
    if(status == MQTT_CONNECT_ACCEPTED)
 801d7fc:	1dbb      	adds	r3, r7, #6
 801d7fe:	881b      	ldrh	r3, [r3, #0]
 801d800:	2b00      	cmp	r3, #0
 801d802:	d14a      	bne.n	801d89a <MQTT_Client_Connection_Callback+0xbe>
    {
        DEBUG_INFO("mqtt_connection_cb: Successfully connected.\r\n");
 801d804:	f000 fb76 	bl	801def4 <sys_get_tick_ms>
 801d808:	0001      	movs	r1, r0
 801d80a:	4a2f      	ldr	r2, [pc, #188]	; (801d8c8 <MQTT_Client_Connection_Callback+0xec>)
 801d80c:	4b30      	ldr	r3, [pc, #192]	; (801d8d0 <MQTT_Client_Connection_Callback+0xf4>)
 801d80e:	0018      	movs	r0, r3
 801d810:	f7e4 fce8 	bl	80021e4 <app_debug_rtt_raw>
        MQTT_Process_Now = true;
 801d814:	4b2f      	ldr	r3, [pc, #188]	; (801d8d4 <MQTT_Client_Connection_Callback+0xf8>)
 801d816:	2201      	movs	r2, #1
 801d818:	701a      	strb	r2, [r3, #0]
        MQTT_Client_State = MQTT_CLIENT_STATE_CONNECTED;
 801d81a:	4b2f      	ldr	r3, [pc, #188]	; (801d8d8 <MQTT_Client_Connection_Callback+0xfc>)
 801d81c:	2203      	movs	r2, #3
 801d81e:	701a      	strb	r2, [r3, #0]
        DEBUG_RAW("MQTT_CLIENT_STATE_CONNECTED\r\n");
 801d820:	4b2e      	ldr	r3, [pc, #184]	; (801d8dc <MQTT_Client_Connection_Callback+0x100>)
 801d822:	0018      	movs	r0, r3
 801d824:	f7e4 fcde 	bl	80021e4 <app_debug_rtt_raw>

        /* Setup callback for incoming publish requests */
        mqtt_set_inpub_callback(client, MQTT_Incoming_Publish_Callback, MQTT_Incoming_Data_Callback, arg);
 801d828:	68bb      	ldr	r3, [r7, #8]
 801d82a:	4a2d      	ldr	r2, [pc, #180]	; (801d8e0 <MQTT_Client_Connection_Callback+0x104>)
 801d82c:	492d      	ldr	r1, [pc, #180]	; (801d8e4 <MQTT_Client_Connection_Callback+0x108>)
 801d82e:	68f8      	ldr	r0, [r7, #12]
 801d830:	f7e9 f852 	bl	80068d8 <mqtt_set_inpub_callback>

        /* Subscribe to a topic named "fire/sub/IMEI" with QoS level 1,
        call mqtt_sub_request_cb with result */
        DEBUG_INFO("Subcribe %s\r\n", MQTT_Subscribe_Topic_Name);
 801d834:	f000 fb5e 	bl	801def4 <sys_get_tick_ms>
 801d838:	0001      	movs	r1, r0
 801d83a:	4b2b      	ldr	r3, [pc, #172]	; (801d8e8 <MQTT_Client_Connection_Callback+0x10c>)
 801d83c:	4a22      	ldr	r2, [pc, #136]	; (801d8c8 <MQTT_Client_Connection_Callback+0xec>)
 801d83e:	482b      	ldr	r0, [pc, #172]	; (801d8ec <MQTT_Client_Connection_Callback+0x110>)
 801d840:	f7e4 fcd0 	bl	80021e4 <app_debug_rtt_raw>
        err_t err = mqtt_subscribe( &MQTT_Static_Client,
 801d844:	2517      	movs	r5, #23
 801d846:	197c      	adds	r4, r7, r5
 801d848:	4a29      	ldr	r2, [pc, #164]	; (801d8f0 <MQTT_Client_Connection_Callback+0x114>)
 801d84a:	4927      	ldr	r1, [pc, #156]	; (801d8e8 <MQTT_Client_Connection_Callback+0x10c>)
 801d84c:	4829      	ldr	r0, [pc, #164]	; (801d8f4 <MQTT_Client_Connection_Callback+0x118>)
 801d84e:	2301      	movs	r3, #1
 801d850:	9301      	str	r3, [sp, #4]
 801d852:	68bb      	ldr	r3, [r7, #8]
 801d854:	9300      	str	r3, [sp, #0]
 801d856:	0013      	movs	r3, r2
 801d858:	2201      	movs	r2, #1
 801d85a:	f7e8 ff4d 	bl	80066f8 <mqtt_sub_unsub>
 801d85e:	0003      	movs	r3, r0
 801d860:	7023      	strb	r3, [r4, #0]
                                    MQTT_Subscribe_Topic_Name,
                                    SUB_QoS,
                                    MQTT_Subcribe_Request_Callback, arg);
        if(err == ERR_OK)
 801d862:	197b      	adds	r3, r7, r5
 801d864:	781b      	ldrb	r3, [r3, #0]
 801d866:	b25b      	sxtb	r3, r3
 801d868:	2b00      	cmp	r3, #0
 801d86a:	d10a      	bne.n	801d882 <MQTT_Client_Connection_Callback+0xa6>
        {
            DEBUG_INFO("mqtt_subscribe ok: %d\r\n", err);
 801d86c:	f000 fb42 	bl	801def4 <sys_get_tick_ms>
 801d870:	0001      	movs	r1, r0
 801d872:	197b      	adds	r3, r7, r5
 801d874:	781b      	ldrb	r3, [r3, #0]
 801d876:	b25b      	sxtb	r3, r3
 801d878:	4a13      	ldr	r2, [pc, #76]	; (801d8c8 <MQTT_Client_Connection_Callback+0xec>)
 801d87a:	481f      	ldr	r0, [pc, #124]	; (801d8f8 <MQTT_Client_Connection_Callback+0x11c>)
 801d87c:	f7e4 fcb2 	bl	80021e4 <app_debug_rtt_raw>
        DEBUG_INFO("[%s] mqtt connection status %d\r\n", __FUNCTION__);
        mqtt_disconnect(&MQTT_Static_Client);
        MQTT_Client_State = MQTT_CLIENT_STATE_DISCONNECTED;
        DEBUG_RAW("MQTT_CLIENT_STATE_DISCONNECTED\r\n");
    }
}
 801d880:	e01e      	b.n	801d8c0 <MQTT_Client_Connection_Callback+0xe4>
            DEBUG_INFO("mqtt_subscribe error: %d\r\n", err);
 801d882:	f000 fb37 	bl	801def4 <sys_get_tick_ms>
 801d886:	0001      	movs	r1, r0
 801d888:	2317      	movs	r3, #23
 801d88a:	18fb      	adds	r3, r7, r3
 801d88c:	781b      	ldrb	r3, [r3, #0]
 801d88e:	b25b      	sxtb	r3, r3
 801d890:	4a0d      	ldr	r2, [pc, #52]	; (801d8c8 <MQTT_Client_Connection_Callback+0xec>)
 801d892:	481a      	ldr	r0, [pc, #104]	; (801d8fc <MQTT_Client_Connection_Callback+0x120>)
 801d894:	f7e4 fca6 	bl	80021e4 <app_debug_rtt_raw>
}
 801d898:	e012      	b.n	801d8c0 <MQTT_Client_Connection_Callback+0xe4>
        DEBUG_INFO("[%s] mqtt connection status %d\r\n", __FUNCTION__);
 801d89a:	f000 fb2b 	bl	801def4 <sys_get_tick_ms>
 801d89e:	0001      	movs	r1, r0
 801d8a0:	4b17      	ldr	r3, [pc, #92]	; (801d900 <MQTT_Client_Connection_Callback+0x124>)
 801d8a2:	4a09      	ldr	r2, [pc, #36]	; (801d8c8 <MQTT_Client_Connection_Callback+0xec>)
 801d8a4:	4817      	ldr	r0, [pc, #92]	; (801d904 <MQTT_Client_Connection_Callback+0x128>)
 801d8a6:	f7e4 fc9d 	bl	80021e4 <app_debug_rtt_raw>
        mqtt_disconnect(&MQTT_Static_Client);
 801d8aa:	4b12      	ldr	r3, [pc, #72]	; (801d8f4 <MQTT_Client_Connection_Callback+0x118>)
 801d8ac:	0018      	movs	r0, r3
 801d8ae:	f7e9 fadf 	bl	8006e70 <mqtt_disconnect>
        MQTT_Client_State = MQTT_CLIENT_STATE_DISCONNECTED;
 801d8b2:	4b09      	ldr	r3, [pc, #36]	; (801d8d8 <MQTT_Client_Connection_Callback+0xfc>)
 801d8b4:	2200      	movs	r2, #0
 801d8b6:	701a      	strb	r2, [r3, #0]
        DEBUG_RAW("MQTT_CLIENT_STATE_DISCONNECTED\r\n");
 801d8b8:	4b13      	ldr	r3, [pc, #76]	; (801d908 <MQTT_Client_Connection_Callback+0x12c>)
 801d8ba:	0018      	movs	r0, r3
 801d8bc:	f7e4 fc92 	bl	80021e4 <app_debug_rtt_raw>
}
 801d8c0:	46c0      	nop			; (mov r8, r8)
 801d8c2:	46bd      	mov	sp, r7
 801d8c4:	b006      	add	sp, #24
 801d8c6:	bdb0      	pop	{r4, r5, r7, pc}
 801d8c8:	08022db0 	.word	0x08022db0
 801d8cc:	08022f88 	.word	0x08022f88
 801d8d0:	08022fd0 	.word	0x08022fd0
 801d8d4:	2000101c 	.word	0x2000101c
 801d8d8:	20000ffc 	.word	0x20000ffc
 801d8dc:	08023018 	.word	0x08023018
 801d8e0:	0801d719 	.word	0x0801d719
 801d8e4:	0801d6bd 	.word	0x0801d6bd
 801d8e8:	20000cdc 	.word	0x20000cdc
 801d8ec:	08023038 	.word	0x08023038
 801d8f0:	0801d5bd 	.word	0x0801d5bd
 801d8f4:	20000e0c 	.word	0x20000e0c
 801d8f8:	08022e0c 	.word	0x08022e0c
 801d8fc:	08022e40 	.word	0x08022e40
 801d900:	08024068 	.word	0x08024068
 801d904:	08023060 	.word	0x08023060
 801d908:	08022de8 	.word	0x08022de8

0801d90c <MQTT_Connect_Broker>:
static int8_t MQTT_Connect_Broker(mqtt_client_t* client)
{
 801d90c:	b5f0      	push	{r4, r5, r6, r7, lr}
 801d90e:	b08f      	sub	sp, #60	; 0x3c
 801d910:	af04      	add	r7, sp, #16
 801d912:	6078      	str	r0, [r7, #4]
   struct mqtt_connect_client_info_t client_info =
   {
       MQTT_Client_Config.ClientID,
 801d914:	4b3c      	ldr	r3, [pc, #240]	; (801da08 <MQTT_Connect_Broker+0xfc>)
 801d916:	68da      	ldr	r2, [r3, #12]
   struct mqtt_connect_client_info_t client_info =
 801d918:	2108      	movs	r1, #8
 801d91a:	187b      	adds	r3, r7, r1
 801d91c:	601a      	str	r2, [r3, #0]
 801d91e:	187b      	adds	r3, r7, r1
 801d920:	2200      	movs	r2, #0
 801d922:	605a      	str	r2, [r3, #4]
 801d924:	187b      	adds	r3, r7, r1
 801d926:	2200      	movs	r2, #0
 801d928:	609a      	str	r2, [r3, #8]
 801d92a:	187b      	adds	r3, r7, r1
 801d92c:	2296      	movs	r2, #150	; 0x96
 801d92e:	0092      	lsls	r2, r2, #2
 801d930:	819a      	strh	r2, [r3, #12]
 801d932:	000e      	movs	r6, r1
 801d934:	19bb      	adds	r3, r7, r6
 801d936:	2200      	movs	r2, #0
 801d938:	611a      	str	r2, [r3, #16]
 801d93a:	19bb      	adds	r3, r7, r6
 801d93c:	2200      	movs	r2, #0
 801d93e:	615a      	str	r2, [r3, #20]
 801d940:	19bb      	adds	r3, r7, r6
 801d942:	2200      	movs	r2, #0
 801d944:	761a      	strb	r2, [r3, #24]
 801d946:	19bb      	adds	r3, r7, r6
 801d948:	2200      	movs	r2, #0
 801d94a:	765a      	strb	r2, [r3, #25]
       MQTT_KEEP_ALIVE_INTERVAL, //Keep alive in seconds, 0 - disable
       NULL, NULL, 0, 0          //Will topic, will msg, will QoS, will retain
   };

   /* Minimal amount of information required is client identifier, so set it here */
   client_info.client_user = MQTT_Client_Config.UserName;
 801d94c:	4b2e      	ldr	r3, [pc, #184]	; (801da08 <MQTT_Connect_Broker+0xfc>)
 801d94e:	691a      	ldr	r2, [r3, #16]
 801d950:	19bb      	adds	r3, r7, r6
 801d952:	605a      	str	r2, [r3, #4]
   client_info.client_pass = MQTT_Client_Config.Password;
 801d954:	4b2c      	ldr	r3, [pc, #176]	; (801da08 <MQTT_Connect_Broker+0xfc>)
 801d956:	695a      	ldr	r2, [r3, #20]
 801d958:	19bb      	adds	r3, r7, r6
 801d95a:	609a      	str	r2, [r3, #8]
    * Initiate client and connect to server, if this fails immediately an error code is returned
    * otherwise mqtt_connection_cb will be called with connection result after attempting 
    * to establish a connection with the server. 
    * For now MQTT version 3.1.1 is always used 
    */
    err_t err = mqtt_client_connect(client,
 801d95c:	4b2a      	ldr	r3, [pc, #168]	; (801da08 <MQTT_Connect_Broker+0xfc>)
 801d95e:	891a      	ldrh	r2, [r3, #8]
 801d960:	2427      	movs	r4, #39	; 0x27
 801d962:	193c      	adds	r4, r7, r4
 801d964:	4d29      	ldr	r5, [pc, #164]	; (801da0c <MQTT_Connect_Broker+0x100>)
 801d966:	492a      	ldr	r1, [pc, #168]	; (801da10 <MQTT_Connect_Broker+0x104>)
 801d968:	6878      	ldr	r0, [r7, #4]
 801d96a:	19bb      	adds	r3, r7, r6
 801d96c:	9301      	str	r3, [sp, #4]
 801d96e:	2300      	movs	r3, #0
 801d970:	9300      	str	r3, [sp, #0]
 801d972:	002b      	movs	r3, r5
 801d974:	f7e8 ffd6 	bl	8006924 <mqtt_client_connect>
 801d978:	0003      	movs	r3, r0
 801d97a:	7023      	strb	r3, [r4, #0]
                                    MQTT_Client_Config.Port,
									MQTT_Client_Connection_Callback,
                                    0,
                                    &client_info);
    /* For now just print the result code if something goes wrong */
    if (err != ERR_OK)
 801d97c:	2427      	movs	r4, #39	; 0x27
 801d97e:	193b      	adds	r3, r7, r4
 801d980:	781b      	ldrb	r3, [r3, #0]
 801d982:	b25b      	sxtb	r3, r3
 801d984:	2b00      	cmp	r3, #0
 801d986:	d017      	beq.n	801d9b8 <MQTT_Connect_Broker+0xac>
    {
        DEBUG_INFO("mqtt_connect error %d \r\n", err);
 801d988:	f000 fab4 	bl	801def4 <sys_get_tick_ms>
 801d98c:	0001      	movs	r1, r0
 801d98e:	193b      	adds	r3, r7, r4
 801d990:	781b      	ldrb	r3, [r3, #0]
 801d992:	b25b      	sxtb	r3, r3
 801d994:	4a1f      	ldr	r2, [pc, #124]	; (801da14 <MQTT_Connect_Broker+0x108>)
 801d996:	4820      	ldr	r0, [pc, #128]	; (801da18 <MQTT_Connect_Broker+0x10c>)
 801d998:	f7e4 fc24 	bl	80021e4 <app_debug_rtt_raw>
        if( err == ERR_ISCONN)
 801d99c:	193b      	adds	r3, r7, r4
 801d99e:	781b      	ldrb	r3, [r3, #0]
 801d9a0:	b25b      	sxtb	r3, r3
 801d9a2:	330a      	adds	r3, #10
 801d9a4:	d128      	bne.n	801d9f8 <MQTT_Connect_Broker+0xec>
        {
            DEBUG_INFO("MQTT already connected. \r\n");
 801d9a6:	f000 faa5 	bl	801def4 <sys_get_tick_ms>
 801d9aa:	0001      	movs	r1, r0
 801d9ac:	4a19      	ldr	r2, [pc, #100]	; (801da14 <MQTT_Connect_Broker+0x108>)
 801d9ae:	4b1b      	ldr	r3, [pc, #108]	; (801da1c <MQTT_Connect_Broker+0x110>)
 801d9b0:	0018      	movs	r0, r3
 801d9b2:	f7e4 fc17 	bl	80021e4 <app_debug_rtt_raw>
 801d9b6:	e01f      	b.n	801d9f8 <MQTT_Connect_Broker+0xec>
        } 
    }
    else
    {
        DEBUG_INFO("Host %s:%d %s, client id %s\r\n",
 801d9b8:	f000 fa9c 	bl	801def4 <sys_get_tick_ms>
 801d9bc:	0005      	movs	r5, r0
 801d9be:	4b12      	ldr	r3, [pc, #72]	; (801da08 <MQTT_Connect_Broker+0xfc>)
 801d9c0:	685c      	ldr	r4, [r3, #4]
 801d9c2:	4b11      	ldr	r3, [pc, #68]	; (801da08 <MQTT_Connect_Broker+0xfc>)
 801d9c4:	891b      	ldrh	r3, [r3, #8]
 801d9c6:	001e      	movs	r6, r3
 801d9c8:	4b11      	ldr	r3, [pc, #68]	; (801da10 <MQTT_Connect_Broker+0x104>)
 801d9ca:	0018      	movs	r0, r3
 801d9cc:	f7f6 ff30 	bl	8014830 <ip4addr_ntoa>
 801d9d0:	0001      	movs	r1, r0
 801d9d2:	4b0d      	ldr	r3, [pc, #52]	; (801da08 <MQTT_Connect_Broker+0xfc>)
 801d9d4:	68db      	ldr	r3, [r3, #12]
 801d9d6:	4a0f      	ldr	r2, [pc, #60]	; (801da14 <MQTT_Connect_Broker+0x108>)
 801d9d8:	4811      	ldr	r0, [pc, #68]	; (801da20 <MQTT_Connect_Broker+0x114>)
 801d9da:	9302      	str	r3, [sp, #8]
 801d9dc:	9101      	str	r1, [sp, #4]
 801d9de:	9600      	str	r6, [sp, #0]
 801d9e0:	0023      	movs	r3, r4
 801d9e2:	0029      	movs	r1, r5
 801d9e4:	f7e4 fbfe 	bl	80021e4 <app_debug_rtt_raw>
                   MQTT_Client_Config.Broker_Address,
                   MQTT_Client_Config.Port,
                   ipaddr_ntoa(&MQTT_Server_Address),
                   MQTT_Client_Config.ClientID);
        DEBUG_INFO("mqtt_client_connect: OK\r\n");
 801d9e8:	f000 fa84 	bl	801def4 <sys_get_tick_ms>
 801d9ec:	0001      	movs	r1, r0
 801d9ee:	4a09      	ldr	r2, [pc, #36]	; (801da14 <MQTT_Connect_Broker+0x108>)
 801d9f0:	4b0c      	ldr	r3, [pc, #48]	; (801da24 <MQTT_Connect_Broker+0x118>)
 801d9f2:	0018      	movs	r0, r3
 801d9f4:	f7e4 fbf6 	bl	80021e4 <app_debug_rtt_raw>
    }
    return err;
 801d9f8:	2327      	movs	r3, #39	; 0x27
 801d9fa:	18fb      	adds	r3, r7, r3
 801d9fc:	781b      	ldrb	r3, [r3, #0]
 801d9fe:	b25b      	sxtb	r3, r3
}
 801da00:	0018      	movs	r0, r3
 801da02:	46bd      	mov	sp, r7
 801da04:	b00b      	add	sp, #44	; 0x2c
 801da06:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801da08:	20001000 	.word	0x20001000
 801da0c:	0801d7dd 	.word	0x0801d7dd
 801da10:	20001018 	.word	0x20001018
 801da14:	08022db0 	.word	0x08022db0
 801da18:	0802309c 	.word	0x0802309c
 801da1c:	080230d0 	.word	0x080230d0
 801da20:	08023104 	.word	0x08023104
 801da24:	0802313c 	.word	0x0802313c

0801da28 <mqtt_dns_found>:
/**
 * @brief DNS found callback when using DNS names as server address.
 */
static void mqtt_dns_found(const char *hostname, const ip_addr_t *ipaddr, void *arg)
{
 801da28:	b590      	push	{r4, r7, lr}
 801da2a:	b085      	sub	sp, #20
 801da2c:	af00      	add	r7, sp, #0
 801da2e:	60f8      	str	r0, [r7, #12]
 801da30:	60b9      	str	r1, [r7, #8]
 801da32:	607a      	str	r2, [r7, #4]
    DEBUG_INFO("mqtt_dns_found: %s\r\n", hostname);
 801da34:	f000 fa5e 	bl	801def4 <sys_get_tick_ms>
 801da38:	0001      	movs	r1, r0
 801da3a:	68fb      	ldr	r3, [r7, #12]
 801da3c:	4a16      	ldr	r2, [pc, #88]	; (801da98 <mqtt_dns_found+0x70>)
 801da3e:	4817      	ldr	r0, [pc, #92]	; (801da9c <mqtt_dns_found+0x74>)
 801da40:	f7e4 fbd0 	bl	80021e4 <app_debug_rtt_raw>

    LWIP_UNUSED_ARG(hostname);
    LWIP_UNUSED_ARG(arg);

    if (ipaddr != NULL)
 801da44:	68bb      	ldr	r3, [r7, #8]
 801da46:	2b00      	cmp	r3, #0
 801da48:	d017      	beq.n	801da7a <mqtt_dns_found+0x52>
    {
        /* Address resolved, send request */
        MQTT_Server_Address.addr = ipaddr->addr;
 801da4a:	68bb      	ldr	r3, [r7, #8]
 801da4c:	681a      	ldr	r2, [r3, #0]
 801da4e:	4b14      	ldr	r3, [pc, #80]	; (801daa0 <mqtt_dns_found+0x78>)
 801da50:	601a      	str	r2, [r3, #0]
        DEBUG_INFO("Server address resolved = %s\r\n", ipaddr_ntoa(&MQTT_Server_Address));
 801da52:	f000 fa4f 	bl	801def4 <sys_get_tick_ms>
 801da56:	0004      	movs	r4, r0
 801da58:	4b11      	ldr	r3, [pc, #68]	; (801daa0 <mqtt_dns_found+0x78>)
 801da5a:	0018      	movs	r0, r3
 801da5c:	f7f6 fee8 	bl	8014830 <ip4addr_ntoa>
 801da60:	0003      	movs	r3, r0
 801da62:	4a0d      	ldr	r2, [pc, #52]	; (801da98 <mqtt_dns_found+0x70>)
 801da64:	480f      	ldr	r0, [pc, #60]	; (801daa4 <mqtt_dns_found+0x7c>)
 801da66:	0021      	movs	r1, r4
 801da68:	f7e4 fbbc 	bl	80021e4 <app_debug_rtt_raw>
        m_is_dns_resolved = true;
 801da6c:	4b0e      	ldr	r3, [pc, #56]	; (801daa8 <mqtt_dns_found+0x80>)
 801da6e:	2201      	movs	r2, #1
 801da70:	701a      	strb	r2, [r3, #0]
        MQTT_Process_Now = true;
 801da72:	4b0e      	ldr	r3, [pc, #56]	; (801daac <mqtt_dns_found+0x84>)
 801da74:	2201      	movs	r2, #1
 801da76:	701a      	strb	r2, [r3, #0]
    {
        /* DNS resolving failed -> try another server */
        DEBUG_INFO("mqtt_dns_found: Failed to resolve server address resolved, trying next server.\r\n");
        m_is_dns_resolved = false;
    }
}
 801da78:	e00a      	b.n	801da90 <mqtt_dns_found+0x68>
        DEBUG_INFO("mqtt_dns_found: Failed to resolve server address resolved, trying next server.\r\n");
 801da7a:	f000 fa3b 	bl	801def4 <sys_get_tick_ms>
 801da7e:	0001      	movs	r1, r0
 801da80:	4a05      	ldr	r2, [pc, #20]	; (801da98 <mqtt_dns_found+0x70>)
 801da82:	4b0b      	ldr	r3, [pc, #44]	; (801dab0 <mqtt_dns_found+0x88>)
 801da84:	0018      	movs	r0, r3
 801da86:	f7e4 fbad 	bl	80021e4 <app_debug_rtt_raw>
        m_is_dns_resolved = false;
 801da8a:	4b07      	ldr	r3, [pc, #28]	; (801daa8 <mqtt_dns_found+0x80>)
 801da8c:	2200      	movs	r2, #0
 801da8e:	701a      	strb	r2, [r3, #0]
}
 801da90:	46c0      	nop			; (mov r8, r8)
 801da92:	46bd      	mov	sp, r7
 801da94:	b005      	add	sp, #20
 801da96:	bd90      	pop	{r4, r7, pc}
 801da98:	08022db0 	.word	0x08022db0
 801da9c:	08023170 	.word	0x08023170
 801daa0:	20001018 	.word	0x20001018
 801daa4:	080231a0 	.word	0x080231a0
 801daa8:	2000101d 	.word	0x2000101d
 801daac:	2000101c 	.word	0x2000101c
 801dab0:	080231d8 	.word	0x080231d8

0801dab4 <MQTT_Publish_Request_Callback>:
/* -----------------------------------------------------------------
4. Using outgoing publish
*/
/* Called when publish is complete either with sucess or failure */
static void MQTT_Publish_Request_Callback(void *arg, err_t result)
{
 801dab4:	b580      	push	{r7, lr}
 801dab6:	b082      	sub	sp, #8
 801dab8:	af00      	add	r7, sp, #0
 801daba:	6078      	str	r0, [r7, #4]
 801dabc:	000a      	movs	r2, r1
 801dabe:	1cfb      	adds	r3, r7, #3
 801dac0:	701a      	strb	r2, [r3, #0]
    if (result != ERR_OK)
 801dac2:	1cfb      	adds	r3, r7, #3
 801dac4:	781b      	ldrb	r3, [r3, #0]
 801dac6:	b25b      	sxtb	r3, r3
 801dac8:	2b00      	cmp	r3, #0
 801daca:	d00a      	beq.n	801dae2 <MQTT_Publish_Request_Callback+0x2e>
    {
        DEBUG_INFO("Publish result: %d\r\n", result);
 801dacc:	f000 fa12 	bl	801def4 <sys_get_tick_ms>
 801dad0:	0001      	movs	r1, r0
 801dad2:	1cfb      	adds	r3, r7, #3
 801dad4:	781b      	ldrb	r3, [r3, #0]
 801dad6:	b25b      	sxtb	r3, r3
 801dad8:	4a08      	ldr	r2, [pc, #32]	; (801dafc <MQTT_Publish_Request_Callback+0x48>)
 801dada:	4809      	ldr	r0, [pc, #36]	; (801db00 <MQTT_Publish_Request_Callback+0x4c>)
 801dadc:	f7e4 fb82 	bl	80021e4 <app_debug_rtt_raw>
    }
    else
    {
        DEBUG_INFO("Publish: OK\r\n");
    }
}
 801dae0:	e007      	b.n	801daf2 <MQTT_Publish_Request_Callback+0x3e>
        DEBUG_INFO("Publish: OK\r\n");
 801dae2:	f000 fa07 	bl	801def4 <sys_get_tick_ms>
 801dae6:	0001      	movs	r1, r0
 801dae8:	4a04      	ldr	r2, [pc, #16]	; (801dafc <MQTT_Publish_Request_Callback+0x48>)
 801daea:	4b06      	ldr	r3, [pc, #24]	; (801db04 <MQTT_Publish_Request_Callback+0x50>)
 801daec:	0018      	movs	r0, r3
 801daee:	f7e4 fb79 	bl	80021e4 <app_debug_rtt_raw>
}
 801daf2:	46c0      	nop			; (mov r8, r8)
 801daf4:	46bd      	mov	sp, r7
 801daf6:	b002      	add	sp, #8
 801daf8:	bd80      	pop	{r7, pc}
 801dafa:	46c0      	nop			; (mov r8, r8)
 801dafc:	08022db0 	.word	0x08022db0
 801db00:	08023244 	.word	0x08023244
 801db04:	08023274 	.word	0x08023274

0801db08 <MQTT_Client_Send_Heartbeat>:
static void MQTT_Client_Send_Heartbeat(void)
{
 801db08:	b5b0      	push	{r4, r5, r7, lr}
 801db0a:	b086      	sub	sp, #24
 801db0c:	af04      	add	r7, sp, #16
    snprintf(MQTT_Tx_Buffer, sizeof(MQTT_Tx_Buffer), "%s", "Hello world!");
 801db0e:	4b23      	ldr	r3, [pc, #140]	; (801db9c <MQTT_Client_Send_Heartbeat+0x94>)
 801db10:	4a23      	ldr	r2, [pc, #140]	; (801dba0 <MQTT_Client_Send_Heartbeat+0x98>)
 801db12:	2180      	movs	r1, #128	; 0x80
 801db14:	0049      	lsls	r1, r1, #1
 801db16:	4823      	ldr	r0, [pc, #140]	; (801dba4 <MQTT_Client_Send_Heartbeat+0x9c>)
 801db18:	f000 fb1e 	bl	801e158 <sniprintf>
    err_t err = mqtt_publish(&MQTT_Static_Client,
                             MQTT_Publish_Topic_Name,
                             MQTT_Tx_Buffer,
                             strlen(MQTT_Tx_Buffer),
 801db1c:	4b21      	ldr	r3, [pc, #132]	; (801dba4 <MQTT_Client_Send_Heartbeat+0x9c>)
 801db1e:	0018      	movs	r0, r3
 801db20:	f7e2 fafc 	bl	800011c <strlen>
 801db24:	0003      	movs	r3, r0
    err_t err = mqtt_publish(&MQTT_Static_Client,
 801db26:	b29d      	uxth	r5, r3
 801db28:	1dfc      	adds	r4, r7, #7
 801db2a:	4a1e      	ldr	r2, [pc, #120]	; (801dba4 <MQTT_Client_Send_Heartbeat+0x9c>)
 801db2c:	491e      	ldr	r1, [pc, #120]	; (801dba8 <MQTT_Client_Send_Heartbeat+0xa0>)
 801db2e:	481f      	ldr	r0, [pc, #124]	; (801dbac <MQTT_Client_Send_Heartbeat+0xa4>)
 801db30:	2300      	movs	r3, #0
 801db32:	9303      	str	r3, [sp, #12]
 801db34:	4b1e      	ldr	r3, [pc, #120]	; (801dbb0 <MQTT_Client_Send_Heartbeat+0xa8>)
 801db36:	9302      	str	r3, [sp, #8]
 801db38:	2300      	movs	r3, #0
 801db3a:	9301      	str	r3, [sp, #4]
 801db3c:	2301      	movs	r3, #1
 801db3e:	9300      	str	r3, [sp, #0]
 801db40:	002b      	movs	r3, r5
 801db42:	f7e8 fce5 	bl	8006510 <mqtt_publish>
 801db46:	0003      	movs	r3, r0
 801db48:	7023      	strb	r3, [r4, #0]
                             PUB_QoS,
                             PUB_RETAIN,
                             MQTT_Publish_Request_Callback,
                             NULL);
    DEBUG_INFO("Publish data \"%s\" to topic %s\r\n", MQTT_Tx_Buffer, MQTT_Publish_Topic_Name);  
 801db4a:	f000 f9d3 	bl	801def4 <sys_get_tick_ms>
 801db4e:	0004      	movs	r4, r0
 801db50:	4914      	ldr	r1, [pc, #80]	; (801dba4 <MQTT_Client_Send_Heartbeat+0x9c>)
 801db52:	4a18      	ldr	r2, [pc, #96]	; (801dbb4 <MQTT_Client_Send_Heartbeat+0xac>)
 801db54:	4818      	ldr	r0, [pc, #96]	; (801dbb8 <MQTT_Client_Send_Heartbeat+0xb0>)
 801db56:	4b14      	ldr	r3, [pc, #80]	; (801dba8 <MQTT_Client_Send_Heartbeat+0xa0>)
 801db58:	9300      	str	r3, [sp, #0]
 801db5a:	000b      	movs	r3, r1
 801db5c:	0021      	movs	r1, r4
 801db5e:	f7e4 fb41 	bl	80021e4 <app_debug_rtt_raw>
    if (err != ERR_OK)
 801db62:	1dfb      	adds	r3, r7, #7
 801db64:	781b      	ldrb	r3, [r3, #0]
 801db66:	b25b      	sxtb	r3, r3
 801db68:	2b00      	cmp	r3, #0
 801db6a:	d00a      	beq.n	801db82 <MQTT_Client_Send_Heartbeat+0x7a>
    {
        DEBUG_INFO("Publish err: %d\r\n", err);
 801db6c:	f000 f9c2 	bl	801def4 <sys_get_tick_ms>
 801db70:	0001      	movs	r1, r0
 801db72:	1dfb      	adds	r3, r7, #7
 801db74:	781b      	ldrb	r3, [r3, #0]
 801db76:	b25b      	sxtb	r3, r3
 801db78:	4a0e      	ldr	r2, [pc, #56]	; (801dbb4 <MQTT_Client_Send_Heartbeat+0xac>)
 801db7a:	4810      	ldr	r0, [pc, #64]	; (801dbbc <MQTT_Client_Send_Heartbeat+0xb4>)
 801db7c:	f7e4 fb32 	bl	80021e4 <app_debug_rtt_raw>
        return;
 801db80:	e009      	b.n	801db96 <MQTT_Client_Send_Heartbeat+0x8e>
    }
    else
    {
        DEBUG_INFO("Publish OK: %d\r\n", err);
 801db82:	f000 f9b7 	bl	801def4 <sys_get_tick_ms>
 801db86:	0001      	movs	r1, r0
 801db88:	1dfb      	adds	r3, r7, #7
 801db8a:	781b      	ldrb	r3, [r3, #0]
 801db8c:	b25b      	sxtb	r3, r3
 801db8e:	4a09      	ldr	r2, [pc, #36]	; (801dbb4 <MQTT_Client_Send_Heartbeat+0xac>)
 801db90:	480b      	ldr	r0, [pc, #44]	; (801dbc0 <MQTT_Client_Send_Heartbeat+0xb8>)
 801db92:	f7e4 fb27 	bl	80021e4 <app_debug_rtt_raw>
    }
}
 801db96:	46bd      	mov	sp, r7
 801db98:	b002      	add	sp, #8
 801db9a:	bdb0      	pop	{r4, r5, r7, pc}
 801db9c:	0802329c 	.word	0x0802329c
 801dba0:	080232ac 	.word	0x080232ac
 801dba4:	20000d0c 	.word	0x20000d0c
 801dba8:	20000cac 	.word	0x20000cac
 801dbac:	20000e0c 	.word	0x20000e0c
 801dbb0:	0801dab5 	.word	0x0801dab5
 801dbb4:	08022db0 	.word	0x08022db0
 801dbb8:	080232b0 	.word	0x080232b0
 801dbbc:	080232ec 	.word	0x080232ec
 801dbc0:	08023318 	.word	0x08023318

0801dbc4 <MQTT_Client_Polling_Task>:

void MQTT_Client_Polling_Task(void *arg)
{
 801dbc4:	b5b0      	push	{r4, r5, r7, lr}
 801dbc6:	b086      	sub	sp, #24
 801dbc8:	af02      	add	r7, sp, #8
 801dbca:	6078      	str	r0, [r7, #4]
    static uint8_t MQTT_Tick = 0;
    static uint32_t tick = 0, last_time_send_sub_request = 0, last_time_send_hearbeat = 0;
    static uint32_t last_tick = 0;
    uint32_t current_tick = sys_get_tick_ms();
 801dbcc:	f000 f992 	bl	801def4 <sys_get_tick_ms>
 801dbd0:	0003      	movs	r3, r0
 801dbd2:	60fb      	str	r3, [r7, #12]
    if(current_tick - last_tick >= (uint32_t)1000 || MQTT_Process_Now)
 801dbd4:	4ba7      	ldr	r3, [pc, #668]	; (801de74 <MQTT_Client_Polling_Task+0x2b0>)
 801dbd6:	681b      	ldr	r3, [r3, #0]
 801dbd8:	68fa      	ldr	r2, [r7, #12]
 801dbda:	1ad2      	subs	r2, r2, r3
 801dbdc:	23fa      	movs	r3, #250	; 0xfa
 801dbde:	009b      	lsls	r3, r3, #2
 801dbe0:	429a      	cmp	r2, r3
 801dbe2:	d204      	bcs.n	801dbee <MQTT_Client_Polling_Task+0x2a>
 801dbe4:	4ba4      	ldr	r3, [pc, #656]	; (801de78 <MQTT_Client_Polling_Task+0x2b4>)
 801dbe6:	781b      	ldrb	r3, [r3, #0]
 801dbe8:	2b00      	cmp	r3, #0
 801dbea:	d100      	bne.n	801dbee <MQTT_Client_Polling_Task+0x2a>
 801dbec:	e136      	b.n	801de5c <MQTT_Client_Polling_Task+0x298>
    {
        MQTT_Process_Now = false;
 801dbee:	4ba2      	ldr	r3, [pc, #648]	; (801de78 <MQTT_Client_Polling_Task+0x2b4>)
 801dbf0:	2200      	movs	r2, #0
 801dbf2:	701a      	strb	r2, [r3, #0]
        last_tick = current_tick;
 801dbf4:	4b9f      	ldr	r3, [pc, #636]	; (801de74 <MQTT_Client_Polling_Task+0x2b0>)
 801dbf6:	68fa      	ldr	r2, [r7, #12]
 801dbf8:	601a      	str	r2, [r3, #0]
        return;
    }

    static bool MQTT_Allow = false;

    if(gsm_data_layer_is_ppp_connected())
 801dbfa:	f7e3 fb61 	bl	80012c0 <gsm_data_layer_is_ppp_connected>
 801dbfe:	1e03      	subs	r3, r0, #0
 801dc00:	d023      	beq.n	801dc4a <MQTT_Client_Polling_Task+0x86>
    {
        if(MQTT_Allow == false)
 801dc02:	4b9e      	ldr	r3, [pc, #632]	; (801de7c <MQTT_Client_Polling_Task+0x2b8>)
 801dc04:	781b      	ldrb	r3, [r3, #0]
 801dc06:	2201      	movs	r2, #1
 801dc08:	4053      	eors	r3, r2
 801dc0a:	b2db      	uxtb	r3, r3
 801dc0c:	2b00      	cmp	r3, #0
 801dc0e:	d02b      	beq.n	801dc68 <MQTT_Client_Polling_Task+0xa4>
        {
            MQTT_Allow = true;
 801dc10:	4b9a      	ldr	r3, [pc, #616]	; (801de7c <MQTT_Client_Polling_Task+0x2b8>)
 801dc12:	2201      	movs	r2, #1
 801dc14:	701a      	strb	r2, [r3, #0]
            if(mqtt_client_is_connected(&MQTT_Static_Client))
 801dc16:	4b9a      	ldr	r3, [pc, #616]	; (801de80 <MQTT_Client_Polling_Task+0x2bc>)
 801dc18:	0018      	movs	r0, r3
 801dc1a:	f7e9 f94f 	bl	8006ebc <mqtt_client_is_connected>
 801dc1e:	1e03      	subs	r3, r0, #0
 801dc20:	d00a      	beq.n	801dc38 <MQTT_Client_Polling_Task+0x74>
            {
                mqtt_disconnect(&MQTT_Static_Client);
 801dc22:	4b97      	ldr	r3, [pc, #604]	; (801de80 <MQTT_Client_Polling_Task+0x2bc>)
 801dc24:	0018      	movs	r0, r3
 801dc26:	f7e9 f923 	bl	8006e70 <mqtt_disconnect>
                MQTT_Client_State = MQTT_CLIENT_STATE_DISCONNECTED;
 801dc2a:	4b96      	ldr	r3, [pc, #600]	; (801de84 <MQTT_Client_Polling_Task+0x2c0>)
 801dc2c:	2200      	movs	r2, #0
 801dc2e:	701a      	strb	r2, [r3, #0]
                DEBUG_RAW("MQTT_CLIENT_STATE_DISCONNECTED\r\n");
 801dc30:	4b95      	ldr	r3, [pc, #596]	; (801de88 <MQTT_Client_Polling_Task+0x2c4>)
 801dc32:	0018      	movs	r0, r3
 801dc34:	f7e4 fad6 	bl	80021e4 <app_debug_rtt_raw>
            }
            DEBUG_INFO("MQTT Thread Started.\r\n");
 801dc38:	f000 f95c 	bl	801def4 <sys_get_tick_ms>
 801dc3c:	0001      	movs	r1, r0
 801dc3e:	4a93      	ldr	r2, [pc, #588]	; (801de8c <MQTT_Client_Polling_Task+0x2c8>)
 801dc40:	4b93      	ldr	r3, [pc, #588]	; (801de90 <MQTT_Client_Polling_Task+0x2cc>)
 801dc42:	0018      	movs	r0, r3
 801dc44:	f7e4 face 	bl	80021e4 <app_debug_rtt_raw>
 801dc48:	e00e      	b.n	801dc68 <MQTT_Client_Polling_Task+0xa4>
        }
    }
    else
    {
        if(MQTT_Allow)
 801dc4a:	4b8c      	ldr	r3, [pc, #560]	; (801de7c <MQTT_Client_Polling_Task+0x2b8>)
 801dc4c:	781b      	ldrb	r3, [r3, #0]
 801dc4e:	2b00      	cmp	r3, #0
 801dc50:	d00a      	beq.n	801dc68 <MQTT_Client_Polling_Task+0xa4>
        {
            MQTT_Allow = false;
 801dc52:	4b8a      	ldr	r3, [pc, #552]	; (801de7c <MQTT_Client_Polling_Task+0x2b8>)
 801dc54:	2200      	movs	r2, #0
 801dc56:	701a      	strb	r2, [r3, #0]
            DEBUG_INFO("MQTT Thread Stopped.\r\n");
 801dc58:	f000 f94c 	bl	801def4 <sys_get_tick_ms>
 801dc5c:	0001      	movs	r1, r0
 801dc5e:	4a8b      	ldr	r2, [pc, #556]	; (801de8c <MQTT_Client_Polling_Task+0x2c8>)
 801dc60:	4b8c      	ldr	r3, [pc, #560]	; (801de94 <MQTT_Client_Polling_Task+0x2d0>)
 801dc62:	0018      	movs	r0, r3
 801dc64:	f7e4 fabe 	bl	80021e4 <app_debug_rtt_raw>
        }
    }
    if(MQTT_Allow)
 801dc68:	4b84      	ldr	r3, [pc, #528]	; (801de7c <MQTT_Client_Polling_Task+0x2b8>)
 801dc6a:	781b      	ldrb	r3, [r3, #0]
 801dc6c:	2b00      	cmp	r3, #0
 801dc6e:	d100      	bne.n	801dc72 <MQTT_Client_Polling_Task+0xae>
 801dc70:	e0fd      	b.n	801de6e <MQTT_Client_Polling_Task+0x2aa>
    {
        MQTT_Tick++;
 801dc72:	4b89      	ldr	r3, [pc, #548]	; (801de98 <MQTT_Client_Polling_Task+0x2d4>)
 801dc74:	781b      	ldrb	r3, [r3, #0]
 801dc76:	3301      	adds	r3, #1
 801dc78:	b2da      	uxtb	r2, r3
 801dc7a:	4b87      	ldr	r3, [pc, #540]	; (801de98 <MQTT_Client_Polling_Task+0x2d4>)
 801dc7c:	701a      	strb	r2, [r3, #0]
        switch (MQTT_Client_State)
 801dc7e:	4b81      	ldr	r3, [pc, #516]	; (801de84 <MQTT_Client_Polling_Task+0x2c0>)
 801dc80:	781b      	ldrb	r3, [r3, #0]
 801dc82:	2b03      	cmp	r3, #3
 801dc84:	d100      	bne.n	801dc88 <MQTT_Client_Polling_Task+0xc4>
 801dc86:	e08d      	b.n	801dda4 <MQTT_Client_Polling_Task+0x1e0>
 801dc88:	dd00      	ble.n	801dc8c <MQTT_Client_Polling_Task+0xc8>
 801dc8a:	e0e9      	b.n	801de60 <MQTT_Client_Polling_Task+0x29c>
 801dc8c:	2b02      	cmp	r3, #2
 801dc8e:	d100      	bne.n	801dc92 <MQTT_Client_Polling_Task+0xce>
 801dc90:	e075      	b.n	801dd7e <MQTT_Client_Polling_Task+0x1ba>
 801dc92:	dd00      	ble.n	801dc96 <MQTT_Client_Polling_Task+0xd2>
 801dc94:	e0e4      	b.n	801de60 <MQTT_Client_Polling_Task+0x29c>
 801dc96:	2b00      	cmp	r3, #0
 801dc98:	d002      	beq.n	801dca0 <MQTT_Client_Polling_Task+0xdc>
 801dc9a:	2b01      	cmp	r3, #1
 801dc9c:	d00e      	beq.n	801dcbc <MQTT_Client_Polling_Task+0xf8>
                }

                break;

            default:
                break;
 801dc9e:	e0df      	b.n	801de60 <MQTT_Client_Polling_Task+0x29c>
                m_is_dns_resolved = false;
 801dca0:	4b7e      	ldr	r3, [pc, #504]	; (801de9c <MQTT_Client_Polling_Task+0x2d8>)
 801dca2:	2200      	movs	r2, #0
 801dca4:	701a      	strb	r2, [r3, #0]
                MQTT_Client_State = MQTT_CLIENT_STATE_RESOLVE_HOSTNAME;
 801dca6:	4b77      	ldr	r3, [pc, #476]	; (801de84 <MQTT_Client_Polling_Task+0x2c0>)
 801dca8:	2201      	movs	r2, #1
 801dcaa:	701a      	strb	r2, [r3, #0]
                DEBUG_RAW("MQTT_CLIENT_STATE_RESOLVE_HOSTNAME\r\n");
 801dcac:	4b7c      	ldr	r3, [pc, #496]	; (801dea0 <MQTT_Client_Polling_Task+0x2dc>)
 801dcae:	0018      	movs	r0, r3
 801dcb0:	f7e4 fa98 	bl	80021e4 <app_debug_rtt_raw>
                MQTT_Tick = 4;
 801dcb4:	4b78      	ldr	r3, [pc, #480]	; (801de98 <MQTT_Client_Polling_Task+0x2d4>)
 801dcb6:	2204      	movs	r2, #4
 801dcb8:	701a      	strb	r2, [r3, #0]
                break;
 801dcba:	e0d8      	b.n	801de6e <MQTT_Client_Polling_Task+0x2aa>
                if(!m_is_dns_resolved)
 801dcbc:	4b77      	ldr	r3, [pc, #476]	; (801de9c <MQTT_Client_Polling_Task+0x2d8>)
 801dcbe:	781b      	ldrb	r3, [r3, #0]
 801dcc0:	2201      	movs	r2, #1
 801dcc2:	4053      	eors	r3, r2
 801dcc4:	b2db      	uxtb	r3, r3
 801dcc6:	2b00      	cmp	r3, #0
 801dcc8:	d04e      	beq.n	801dd68 <MQTT_Client_Polling_Task+0x1a4>
                    if(MQTT_Tick >= 5)
 801dcca:	4b73      	ldr	r3, [pc, #460]	; (801de98 <MQTT_Client_Polling_Task+0x2d4>)
 801dccc:	781b      	ldrb	r3, [r3, #0]
 801dcce:	2b04      	cmp	r3, #4
 801dcd0:	d800      	bhi.n	801dcd4 <MQTT_Client_Polling_Task+0x110>
 801dcd2:	e0c7      	b.n	801de64 <MQTT_Client_Polling_Task+0x2a0>
                        MQTT_Tick = 0;
 801dcd4:	4b70      	ldr	r3, [pc, #448]	; (801de98 <MQTT_Client_Polling_Task+0x2d4>)
 801dcd6:	2200      	movs	r2, #0
 801dcd8:	701a      	strb	r2, [r3, #0]
                        err_t err = dns_gethostbyname(MQTT_Client_Config.Broker_Address,
 801dcda:	4b72      	ldr	r3, [pc, #456]	; (801dea4 <MQTT_Client_Polling_Task+0x2e0>)
 801dcdc:	6858      	ldr	r0, [r3, #4]
 801dcde:	250a      	movs	r5, #10
 801dce0:	197c      	adds	r4, r7, r5
 801dce2:	4a71      	ldr	r2, [pc, #452]	; (801dea8 <MQTT_Client_Polling_Task+0x2e4>)
 801dce4:	4971      	ldr	r1, [pc, #452]	; (801deac <MQTT_Client_Polling_Task+0x2e8>)
 801dce6:	2300      	movs	r3, #0
 801dce8:	f7ea fcb2 	bl	8008650 <dns_gethostbyname>
 801dcec:	0003      	movs	r3, r0
 801dcee:	7023      	strb	r3, [r4, #0]
                        if(err == ERR_INPROGRESS)
 801dcf0:	197b      	adds	r3, r7, r5
 801dcf2:	781b      	ldrb	r3, [r3, #0]
 801dcf4:	b25b      	sxtb	r3, r3
 801dcf6:	3305      	adds	r3, #5
 801dcf8:	d10f      	bne.n	801dd1a <MQTT_Client_Polling_Task+0x156>
                            DEBUG_INFO("sntp_request: %d - Waiting for server %s address to be resolved.\r\n", 
 801dcfa:	f000 f8fb 	bl	801def4 <sys_get_tick_ms>
 801dcfe:	0004      	movs	r4, r0
 801dd00:	197b      	adds	r3, r7, r5
 801dd02:	2100      	movs	r1, #0
 801dd04:	5659      	ldrsb	r1, [r3, r1]
 801dd06:	4b67      	ldr	r3, [pc, #412]	; (801dea4 <MQTT_Client_Polling_Task+0x2e0>)
 801dd08:	685b      	ldr	r3, [r3, #4]
 801dd0a:	4a60      	ldr	r2, [pc, #384]	; (801de8c <MQTT_Client_Polling_Task+0x2c8>)
 801dd0c:	4868      	ldr	r0, [pc, #416]	; (801deb0 <MQTT_Client_Polling_Task+0x2ec>)
 801dd0e:	9300      	str	r3, [sp, #0]
 801dd10:	000b      	movs	r3, r1
 801dd12:	0021      	movs	r1, r4
 801dd14:	f7e4 fa66 	bl	80021e4 <app_debug_rtt_raw>
                break;
 801dd18:	e0a4      	b.n	801de64 <MQTT_Client_Polling_Task+0x2a0>
                        else if(err == ERR_OK)
 801dd1a:	230a      	movs	r3, #10
 801dd1c:	18fb      	adds	r3, r7, r3
 801dd1e:	781b      	ldrb	r3, [r3, #0]
 801dd20:	b25b      	sxtb	r3, r3
 801dd22:	2b00      	cmp	r3, #0
 801dd24:	d114      	bne.n	801dd50 <MQTT_Client_Polling_Task+0x18c>
                            DEBUG_INFO("DNS resolved aready, host %s, mqtt_ipaddr = %s\r\n",
 801dd26:	f000 f8e5 	bl	801def4 <sys_get_tick_ms>
 801dd2a:	0005      	movs	r5, r0
 801dd2c:	4b5d      	ldr	r3, [pc, #372]	; (801dea4 <MQTT_Client_Polling_Task+0x2e0>)
 801dd2e:	685c      	ldr	r4, [r3, #4]
 801dd30:	4b5e      	ldr	r3, [pc, #376]	; (801deac <MQTT_Client_Polling_Task+0x2e8>)
 801dd32:	0018      	movs	r0, r3
 801dd34:	f7f6 fd7c 	bl	8014830 <ip4addr_ntoa>
 801dd38:	0003      	movs	r3, r0
 801dd3a:	4a54      	ldr	r2, [pc, #336]	; (801de8c <MQTT_Client_Polling_Task+0x2c8>)
 801dd3c:	485d      	ldr	r0, [pc, #372]	; (801deb4 <MQTT_Client_Polling_Task+0x2f0>)
 801dd3e:	9300      	str	r3, [sp, #0]
 801dd40:	0023      	movs	r3, r4
 801dd42:	0029      	movs	r1, r5
 801dd44:	f7e4 fa4e 	bl	80021e4 <app_debug_rtt_raw>
                            m_is_dns_resolved = true;
 801dd48:	4b54      	ldr	r3, [pc, #336]	; (801de9c <MQTT_Client_Polling_Task+0x2d8>)
 801dd4a:	2201      	movs	r2, #1
 801dd4c:	701a      	strb	r2, [r3, #0]
                break;
 801dd4e:	e089      	b.n	801de64 <MQTT_Client_Polling_Task+0x2a0>
                            DEBUG_INFO("dns_gethostbyname error: %d\r\n", err);
 801dd50:	f000 f8d0 	bl	801def4 <sys_get_tick_ms>
 801dd54:	0001      	movs	r1, r0
 801dd56:	230a      	movs	r3, #10
 801dd58:	18fb      	adds	r3, r7, r3
 801dd5a:	781b      	ldrb	r3, [r3, #0]
 801dd5c:	b25b      	sxtb	r3, r3
 801dd5e:	4a4b      	ldr	r2, [pc, #300]	; (801de8c <MQTT_Client_Polling_Task+0x2c8>)
 801dd60:	4855      	ldr	r0, [pc, #340]	; (801deb8 <MQTT_Client_Polling_Task+0x2f4>)
 801dd62:	f7e4 fa3f 	bl	80021e4 <app_debug_rtt_raw>
                break;
 801dd66:	e07d      	b.n	801de64 <MQTT_Client_Polling_Task+0x2a0>
                    MQTT_Tick = 9;
 801dd68:	4b4b      	ldr	r3, [pc, #300]	; (801de98 <MQTT_Client_Polling_Task+0x2d4>)
 801dd6a:	2209      	movs	r2, #9
 801dd6c:	701a      	strb	r2, [r3, #0]
                    MQTT_Client_State = MQTT_CLIENT_STATE_CONNECTING;
 801dd6e:	4b45      	ldr	r3, [pc, #276]	; (801de84 <MQTT_Client_Polling_Task+0x2c0>)
 801dd70:	2202      	movs	r2, #2
 801dd72:	701a      	strb	r2, [r3, #0]
                    DEBUG_RAW("MQTT_CLIENT_STATE_CONNECTING\r\n");
 801dd74:	4b51      	ldr	r3, [pc, #324]	; (801debc <MQTT_Client_Polling_Task+0x2f8>)
 801dd76:	0018      	movs	r0, r3
 801dd78:	f7e4 fa34 	bl	80021e4 <app_debug_rtt_raw>
                break;
 801dd7c:	e072      	b.n	801de64 <MQTT_Client_Polling_Task+0x2a0>
                if(MQTT_Tick >= 10)
 801dd7e:	4b46      	ldr	r3, [pc, #280]	; (801de98 <MQTT_Client_Polling_Task+0x2d4>)
 801dd80:	781b      	ldrb	r3, [r3, #0]
 801dd82:	2b09      	cmp	r3, #9
 801dd84:	d800      	bhi.n	801dd88 <MQTT_Client_Polling_Task+0x1c4>
 801dd86:	e06f      	b.n	801de68 <MQTT_Client_Polling_Task+0x2a4>
                    if(MQTT_Connect_Broker(&MQTT_Static_Client) == ERR_OK)
 801dd88:	4b3d      	ldr	r3, [pc, #244]	; (801de80 <MQTT_Client_Polling_Task+0x2bc>)
 801dd8a:	0018      	movs	r0, r3
 801dd8c:	f7ff fdbe 	bl	801d90c <MQTT_Connect_Broker>
 801dd90:	1e03      	subs	r3, r0, #0
 801dd92:	d103      	bne.n	801dd9c <MQTT_Client_Polling_Task+0x1d8>
                        MQTT_Tick = 5;  /* Gui login sau 5s */
 801dd94:	4b40      	ldr	r3, [pc, #256]	; (801de98 <MQTT_Client_Polling_Task+0x2d4>)
 801dd96:	2205      	movs	r2, #5
 801dd98:	701a      	strb	r2, [r3, #0]
                break;
 801dd9a:	e065      	b.n	801de68 <MQTT_Client_Polling_Task+0x2a4>
                        MQTT_Tick = 0;
 801dd9c:	4b3e      	ldr	r3, [pc, #248]	; (801de98 <MQTT_Client_Polling_Task+0x2d4>)
 801dd9e:	2200      	movs	r2, #0
 801dda0:	701a      	strb	r2, [r3, #0]
                break;
 801dda2:	e061      	b.n	801de68 <MQTT_Client_Polling_Task+0x2a4>
                tick = current_tick;
 801dda4:	4b46      	ldr	r3, [pc, #280]	; (801dec0 <MQTT_Client_Polling_Task+0x2fc>)
 801dda6:	68fa      	ldr	r2, [r7, #12]
 801dda8:	601a      	str	r2, [r3, #0]
                if(last_time_send_sub_request == 0)
 801ddaa:	4b46      	ldr	r3, [pc, #280]	; (801dec4 <MQTT_Client_Polling_Task+0x300>)
 801ddac:	681b      	ldr	r3, [r3, #0]
 801ddae:	2b00      	cmp	r3, #0
 801ddb0:	d103      	bne.n	801ddba <MQTT_Client_Polling_Task+0x1f6>
                    last_time_send_sub_request = tick;
 801ddb2:	4b43      	ldr	r3, [pc, #268]	; (801dec0 <MQTT_Client_Polling_Task+0x2fc>)
 801ddb4:	681a      	ldr	r2, [r3, #0]
 801ddb6:	4b43      	ldr	r3, [pc, #268]	; (801dec4 <MQTT_Client_Polling_Task+0x300>)
 801ddb8:	601a      	str	r2, [r3, #0]
                if(mqtt_client_is_connected(&MQTT_Static_Client))
 801ddba:	4b31      	ldr	r3, [pc, #196]	; (801de80 <MQTT_Client_Polling_Task+0x2bc>)
 801ddbc:	0018      	movs	r0, r3
 801ddbe:	f7e9 f87d 	bl	8006ebc <mqtt_client_is_connected>
 801ddc2:	1e03      	subs	r3, r0, #0
 801ddc4:	d042      	beq.n	801de4c <MQTT_Client_Polling_Task+0x288>
                    if((tick - last_time_send_sub_request) >= MQTT_Client_Config.Period_sub_req_s * 1000)
 801ddc6:	4b3e      	ldr	r3, [pc, #248]	; (801dec0 <MQTT_Client_Polling_Task+0x2fc>)
 801ddc8:	681a      	ldr	r2, [r3, #0]
 801ddca:	4b3e      	ldr	r3, [pc, #248]	; (801dec4 <MQTT_Client_Polling_Task+0x300>)
 801ddcc:	681b      	ldr	r3, [r3, #0]
 801ddce:	1ad1      	subs	r1, r2, r3
 801ddd0:	4b34      	ldr	r3, [pc, #208]	; (801dea4 <MQTT_Client_Polling_Task+0x2e0>)
 801ddd2:	681a      	ldr	r2, [r3, #0]
 801ddd4:	0013      	movs	r3, r2
 801ddd6:	015b      	lsls	r3, r3, #5
 801ddd8:	1a9b      	subs	r3, r3, r2
 801ddda:	009b      	lsls	r3, r3, #2
 801dddc:	189b      	adds	r3, r3, r2
 801ddde:	00db      	lsls	r3, r3, #3
 801dde0:	4299      	cmp	r1, r3
 801dde2:	d324      	bcc.n	801de2e <MQTT_Client_Polling_Task+0x26a>
                        last_time_send_sub_request = tick;
 801dde4:	4b36      	ldr	r3, [pc, #216]	; (801dec0 <MQTT_Client_Polling_Task+0x2fc>)
 801dde6:	681a      	ldr	r2, [r3, #0]
 801dde8:	4b36      	ldr	r3, [pc, #216]	; (801dec4 <MQTT_Client_Polling_Task+0x300>)
 801ddea:	601a      	str	r2, [r3, #0]
                        err_t err = mqtt_subscribe(&MQTT_Static_Client,
 801ddec:	250b      	movs	r5, #11
 801ddee:	197c      	adds	r4, r7, r5
 801ddf0:	4a35      	ldr	r2, [pc, #212]	; (801dec8 <MQTT_Client_Polling_Task+0x304>)
 801ddf2:	4936      	ldr	r1, [pc, #216]	; (801decc <MQTT_Client_Polling_Task+0x308>)
 801ddf4:	4822      	ldr	r0, [pc, #136]	; (801de80 <MQTT_Client_Polling_Task+0x2bc>)
 801ddf6:	2301      	movs	r3, #1
 801ddf8:	9301      	str	r3, [sp, #4]
 801ddfa:	687b      	ldr	r3, [r7, #4]
 801ddfc:	9300      	str	r3, [sp, #0]
 801ddfe:	0013      	movs	r3, r2
 801de00:	2201      	movs	r2, #1
 801de02:	f7e8 fc79 	bl	80066f8 <mqtt_sub_unsub>
 801de06:	0003      	movs	r3, r0
 801de08:	7023      	strb	r3, [r4, #0]
                        DEBUG_INFO("Subcribe to: topic %s return: %d.", MQTT_Subscribe_Topic_Name, err);
 801de0a:	f000 f873 	bl	801def4 <sys_get_tick_ms>
 801de0e:	0004      	movs	r4, r0
 801de10:	197b      	adds	r3, r7, r5
 801de12:	781b      	ldrb	r3, [r3, #0]
 801de14:	b25b      	sxtb	r3, r3
 801de16:	492d      	ldr	r1, [pc, #180]	; (801decc <MQTT_Client_Polling_Task+0x308>)
 801de18:	4a1c      	ldr	r2, [pc, #112]	; (801de8c <MQTT_Client_Polling_Task+0x2c8>)
 801de1a:	482d      	ldr	r0, [pc, #180]	; (801ded0 <MQTT_Client_Polling_Task+0x30c>)
 801de1c:	9300      	str	r3, [sp, #0]
 801de1e:	000b      	movs	r3, r1
 801de20:	0021      	movs	r1, r4
 801de22:	f7e4 f9df 	bl	80021e4 <app_debug_rtt_raw>
                        DEBUG_RAW("\r\n");
 801de26:	4b2b      	ldr	r3, [pc, #172]	; (801ded4 <MQTT_Client_Polling_Task+0x310>)
 801de28:	0018      	movs	r0, r3
 801de2a:	f7e4 f9db 	bl	80021e4 <app_debug_rtt_raw>
                    if((tick - last_time_send_hearbeat) >= (uint32_t)30000)
 801de2e:	4b24      	ldr	r3, [pc, #144]	; (801dec0 <MQTT_Client_Polling_Task+0x2fc>)
 801de30:	681a      	ldr	r2, [r3, #0]
 801de32:	4b29      	ldr	r3, [pc, #164]	; (801ded8 <MQTT_Client_Polling_Task+0x314>)
 801de34:	681b      	ldr	r3, [r3, #0]
 801de36:	1ad3      	subs	r3, r2, r3
 801de38:	4a28      	ldr	r2, [pc, #160]	; (801dedc <MQTT_Client_Polling_Task+0x318>)
 801de3a:	4293      	cmp	r3, r2
 801de3c:	d916      	bls.n	801de6c <MQTT_Client_Polling_Task+0x2a8>
                        last_time_send_hearbeat = tick;
 801de3e:	4b20      	ldr	r3, [pc, #128]	; (801dec0 <MQTT_Client_Polling_Task+0x2fc>)
 801de40:	681a      	ldr	r2, [r3, #0]
 801de42:	4b25      	ldr	r3, [pc, #148]	; (801ded8 <MQTT_Client_Polling_Task+0x314>)
 801de44:	601a      	str	r2, [r3, #0]
                        MQTT_Client_Send_Heartbeat();
 801de46:	f7ff fe5f 	bl	801db08 <MQTT_Client_Send_Heartbeat>
                break;
 801de4a:	e00f      	b.n	801de6c <MQTT_Client_Polling_Task+0x2a8>
                    MQTT_Client_State = MQTT_CLIENT_STATE_DISCONNECTED;
 801de4c:	4b0d      	ldr	r3, [pc, #52]	; (801de84 <MQTT_Client_Polling_Task+0x2c0>)
 801de4e:	2200      	movs	r2, #0
 801de50:	701a      	strb	r2, [r3, #0]
                    DEBUG_RAW("MQTT_CLIENT_STATE_DISCONNECTED\r\n");
 801de52:	4b0d      	ldr	r3, [pc, #52]	; (801de88 <MQTT_Client_Polling_Task+0x2c4>)
 801de54:	0018      	movs	r0, r3
 801de56:	f7e4 f9c5 	bl	80021e4 <app_debug_rtt_raw>
                break;
 801de5a:	e007      	b.n	801de6c <MQTT_Client_Polling_Task+0x2a8>
        return;
 801de5c:	46c0      	nop			; (mov r8, r8)
 801de5e:	e006      	b.n	801de6e <MQTT_Client_Polling_Task+0x2aa>
                break;
 801de60:	46c0      	nop			; (mov r8, r8)
 801de62:	e004      	b.n	801de6e <MQTT_Client_Polling_Task+0x2aa>
                break;
 801de64:	46c0      	nop			; (mov r8, r8)
 801de66:	e002      	b.n	801de6e <MQTT_Client_Polling_Task+0x2aa>
                break;
 801de68:	46c0      	nop			; (mov r8, r8)
 801de6a:	e000      	b.n	801de6e <MQTT_Client_Polling_Task+0x2aa>
                break;
 801de6c:	46c0      	nop			; (mov r8, r8)
        }
    }

}
 801de6e:	46bd      	mov	sp, r7
 801de70:	b004      	add	sp, #16
 801de72:	bdb0      	pop	{r4, r5, r7, pc}
 801de74:	20001020 	.word	0x20001020
 801de78:	2000101c 	.word	0x2000101c
 801de7c:	20001024 	.word	0x20001024
 801de80:	20000e0c 	.word	0x20000e0c
 801de84:	20000ffc 	.word	0x20000ffc
 801de88:	08022de8 	.word	0x08022de8
 801de8c:	08022db0 	.word	0x08022db0
 801de90:	08023344 	.word	0x08023344
 801de94:	08023374 	.word	0x08023374
 801de98:	20001025 	.word	0x20001025
 801de9c:	2000101d 	.word	0x2000101d
 801dea0:	080233a4 	.word	0x080233a4
 801dea4:	20001000 	.word	0x20001000
 801dea8:	0801da29 	.word	0x0801da29
 801deac:	20001018 	.word	0x20001018
 801deb0:	080233cc 	.word	0x080233cc
 801deb4:	08023428 	.word	0x08023428
 801deb8:	08023474 	.word	0x08023474
 801debc:	080234ac 	.word	0x080234ac
 801dec0:	20001028 	.word	0x20001028
 801dec4:	2000102c 	.word	0x2000102c
 801dec8:	0801d5bd 	.word	0x0801d5bd
 801decc:	20000cdc 	.word	0x20000cdc
 801ded0:	080234cc 	.word	0x080234cc
 801ded4:	08023508 	.word	0x08023508
 801ded8:	20001030 	.word	0x20001030
 801dedc:	0000752f 	.word	0x0000752f

0801dee0 <sys_rand>:
 */



extern uint32_t sys_rand()
{
 801dee0:	b580      	push	{r7, lr}
 801dee2:	af00      	add	r7, sp, #0
    return SysTick->VAL;
 801dee4:	4b02      	ldr	r3, [pc, #8]	; (801def0 <sys_rand+0x10>)
 801dee6:	689b      	ldr	r3, [r3, #8]
}
 801dee8:	0018      	movs	r0, r3
 801deea:	46bd      	mov	sp, r7
 801deec:	bd80      	pop	{r7, pc}
 801deee:	46c0      	nop			; (mov r8, r8)
 801def0:	e000e010 	.word	0xe000e010

0801def4 <sys_get_tick_ms>:

extern uint32_t sys_get_tick_ms()
{
 801def4:	b580      	push	{r7, lr}
 801def6:	af00      	add	r7, sp, #0
    return HAL_GetTick();
 801def8:	f7e4 fade 	bl	80024b8 <HAL_GetTick>
 801defc:	0003      	movs	r3, r0
}
 801defe:	0018      	movs	r0, r3
 801df00:	46bd      	mov	sp, r7
 801df02:	bd80      	pop	{r7, pc}

0801df04 <sys_now>:



uint32_t sys_now(void)
{
 801df04:	b580      	push	{r7, lr}
 801df06:	af00      	add	r7, sp, #0
    return sys_get_tick_ms();
 801df08:	f7ff fff4 	bl	801def4 <sys_get_tick_ms>
 801df0c:	0003      	movs	r3, r0
}
 801df0e:	0018      	movs	r0, r3
 801df10:	46bd      	mov	sp, r7
 801df12:	bd80      	pop	{r7, pc}

0801df14 <sys_jiffies>:

/**
 * @brief Override LWIP weak function
 */
uint32_t sys_jiffies(void)
{
 801df14:	b580      	push	{r7, lr}
 801df16:	af00      	add	r7, sp, #0
    return sys_get_tick_ms();
 801df18:	f7ff ffec 	bl	801def4 <sys_get_tick_ms>
 801df1c:	0003      	movs	r3, r0
}
 801df1e:	0018      	movs	r0, r3
 801df20:	46bd      	mov	sp, r7
 801df22:	bd80      	pop	{r7, pc}

0801df24 <__libc_init_array>:
 801df24:	b570      	push	{r4, r5, r6, lr}
 801df26:	2600      	movs	r6, #0
 801df28:	4d0c      	ldr	r5, [pc, #48]	; (801df5c <__libc_init_array+0x38>)
 801df2a:	4c0d      	ldr	r4, [pc, #52]	; (801df60 <__libc_init_array+0x3c>)
 801df2c:	1b64      	subs	r4, r4, r5
 801df2e:	10a4      	asrs	r4, r4, #2
 801df30:	42a6      	cmp	r6, r4
 801df32:	d109      	bne.n	801df48 <__libc_init_array+0x24>
 801df34:	2600      	movs	r6, #0
 801df36:	f000 fcd5 	bl	801e8e4 <_init>
 801df3a:	4d0a      	ldr	r5, [pc, #40]	; (801df64 <__libc_init_array+0x40>)
 801df3c:	4c0a      	ldr	r4, [pc, #40]	; (801df68 <__libc_init_array+0x44>)
 801df3e:	1b64      	subs	r4, r4, r5
 801df40:	10a4      	asrs	r4, r4, #2
 801df42:	42a6      	cmp	r6, r4
 801df44:	d105      	bne.n	801df52 <__libc_init_array+0x2e>
 801df46:	bd70      	pop	{r4, r5, r6, pc}
 801df48:	00b3      	lsls	r3, r6, #2
 801df4a:	58eb      	ldr	r3, [r5, r3]
 801df4c:	4798      	blx	r3
 801df4e:	3601      	adds	r6, #1
 801df50:	e7ee      	b.n	801df30 <__libc_init_array+0xc>
 801df52:	00b3      	lsls	r3, r6, #2
 801df54:	58eb      	ldr	r3, [r5, r3]
 801df56:	4798      	blx	r3
 801df58:	3601      	adds	r6, #1
 801df5a:	e7f2      	b.n	801df42 <__libc_init_array+0x1e>
 801df5c:	08024224 	.word	0x08024224
 801df60:	08024224 	.word	0x08024224
 801df64:	08024224 	.word	0x08024224
 801df68:	08024228 	.word	0x08024228

0801df6c <malloc>:
 801df6c:	b510      	push	{r4, lr}
 801df6e:	4b03      	ldr	r3, [pc, #12]	; (801df7c <malloc+0x10>)
 801df70:	0001      	movs	r1, r0
 801df72:	6818      	ldr	r0, [r3, #0]
 801df74:	f000 f880 	bl	801e078 <_malloc_r>
 801df78:	bd10      	pop	{r4, pc}
 801df7a:	46c0      	nop			; (mov r8, r8)
 801df7c:	20000040 	.word	0x20000040

0801df80 <memcmp>:
 801df80:	b530      	push	{r4, r5, lr}
 801df82:	2400      	movs	r4, #0
 801df84:	3901      	subs	r1, #1
 801df86:	42a2      	cmp	r2, r4
 801df88:	d101      	bne.n	801df8e <memcmp+0xe>
 801df8a:	2000      	movs	r0, #0
 801df8c:	e005      	b.n	801df9a <memcmp+0x1a>
 801df8e:	5d03      	ldrb	r3, [r0, r4]
 801df90:	3401      	adds	r4, #1
 801df92:	5d0d      	ldrb	r5, [r1, r4]
 801df94:	42ab      	cmp	r3, r5
 801df96:	d0f6      	beq.n	801df86 <memcmp+0x6>
 801df98:	1b58      	subs	r0, r3, r5
 801df9a:	bd30      	pop	{r4, r5, pc}

0801df9c <memcpy>:
 801df9c:	2300      	movs	r3, #0
 801df9e:	b510      	push	{r4, lr}
 801dfa0:	429a      	cmp	r2, r3
 801dfa2:	d100      	bne.n	801dfa6 <memcpy+0xa>
 801dfa4:	bd10      	pop	{r4, pc}
 801dfa6:	5ccc      	ldrb	r4, [r1, r3]
 801dfa8:	54c4      	strb	r4, [r0, r3]
 801dfaa:	3301      	adds	r3, #1
 801dfac:	e7f8      	b.n	801dfa0 <memcpy+0x4>

0801dfae <memmove>:
 801dfae:	b510      	push	{r4, lr}
 801dfb0:	4288      	cmp	r0, r1
 801dfb2:	d902      	bls.n	801dfba <memmove+0xc>
 801dfb4:	188b      	adds	r3, r1, r2
 801dfb6:	4298      	cmp	r0, r3
 801dfb8:	d303      	bcc.n	801dfc2 <memmove+0x14>
 801dfba:	2300      	movs	r3, #0
 801dfbc:	e007      	b.n	801dfce <memmove+0x20>
 801dfbe:	5c8b      	ldrb	r3, [r1, r2]
 801dfc0:	5483      	strb	r3, [r0, r2]
 801dfc2:	3a01      	subs	r2, #1
 801dfc4:	d2fb      	bcs.n	801dfbe <memmove+0x10>
 801dfc6:	bd10      	pop	{r4, pc}
 801dfc8:	5ccc      	ldrb	r4, [r1, r3]
 801dfca:	54c4      	strb	r4, [r0, r3]
 801dfcc:	3301      	adds	r3, #1
 801dfce:	429a      	cmp	r2, r3
 801dfd0:	d1fa      	bne.n	801dfc8 <memmove+0x1a>
 801dfd2:	e7f8      	b.n	801dfc6 <memmove+0x18>

0801dfd4 <memset>:
 801dfd4:	0003      	movs	r3, r0
 801dfd6:	1882      	adds	r2, r0, r2
 801dfd8:	4293      	cmp	r3, r2
 801dfda:	d100      	bne.n	801dfde <memset+0xa>
 801dfdc:	4770      	bx	lr
 801dfde:	7019      	strb	r1, [r3, #0]
 801dfe0:	3301      	adds	r3, #1
 801dfe2:	e7f9      	b.n	801dfd8 <memset+0x4>

0801dfe4 <_free_r>:
 801dfe4:	b570      	push	{r4, r5, r6, lr}
 801dfe6:	0005      	movs	r5, r0
 801dfe8:	2900      	cmp	r1, #0
 801dfea:	d010      	beq.n	801e00e <_free_r+0x2a>
 801dfec:	1f0c      	subs	r4, r1, #4
 801dfee:	6823      	ldr	r3, [r4, #0]
 801dff0:	2b00      	cmp	r3, #0
 801dff2:	da00      	bge.n	801dff6 <_free_r+0x12>
 801dff4:	18e4      	adds	r4, r4, r3
 801dff6:	0028      	movs	r0, r5
 801dff8:	f000 f946 	bl	801e288 <__malloc_lock>
 801dffc:	4a1d      	ldr	r2, [pc, #116]	; (801e074 <_free_r+0x90>)
 801dffe:	6813      	ldr	r3, [r2, #0]
 801e000:	2b00      	cmp	r3, #0
 801e002:	d105      	bne.n	801e010 <_free_r+0x2c>
 801e004:	6063      	str	r3, [r4, #4]
 801e006:	6014      	str	r4, [r2, #0]
 801e008:	0028      	movs	r0, r5
 801e00a:	f000 f945 	bl	801e298 <__malloc_unlock>
 801e00e:	bd70      	pop	{r4, r5, r6, pc}
 801e010:	42a3      	cmp	r3, r4
 801e012:	d908      	bls.n	801e026 <_free_r+0x42>
 801e014:	6821      	ldr	r1, [r4, #0]
 801e016:	1860      	adds	r0, r4, r1
 801e018:	4283      	cmp	r3, r0
 801e01a:	d1f3      	bne.n	801e004 <_free_r+0x20>
 801e01c:	6818      	ldr	r0, [r3, #0]
 801e01e:	685b      	ldr	r3, [r3, #4]
 801e020:	1841      	adds	r1, r0, r1
 801e022:	6021      	str	r1, [r4, #0]
 801e024:	e7ee      	b.n	801e004 <_free_r+0x20>
 801e026:	001a      	movs	r2, r3
 801e028:	685b      	ldr	r3, [r3, #4]
 801e02a:	2b00      	cmp	r3, #0
 801e02c:	d001      	beq.n	801e032 <_free_r+0x4e>
 801e02e:	42a3      	cmp	r3, r4
 801e030:	d9f9      	bls.n	801e026 <_free_r+0x42>
 801e032:	6811      	ldr	r1, [r2, #0]
 801e034:	1850      	adds	r0, r2, r1
 801e036:	42a0      	cmp	r0, r4
 801e038:	d10b      	bne.n	801e052 <_free_r+0x6e>
 801e03a:	6820      	ldr	r0, [r4, #0]
 801e03c:	1809      	adds	r1, r1, r0
 801e03e:	1850      	adds	r0, r2, r1
 801e040:	6011      	str	r1, [r2, #0]
 801e042:	4283      	cmp	r3, r0
 801e044:	d1e0      	bne.n	801e008 <_free_r+0x24>
 801e046:	6818      	ldr	r0, [r3, #0]
 801e048:	685b      	ldr	r3, [r3, #4]
 801e04a:	1841      	adds	r1, r0, r1
 801e04c:	6011      	str	r1, [r2, #0]
 801e04e:	6053      	str	r3, [r2, #4]
 801e050:	e7da      	b.n	801e008 <_free_r+0x24>
 801e052:	42a0      	cmp	r0, r4
 801e054:	d902      	bls.n	801e05c <_free_r+0x78>
 801e056:	230c      	movs	r3, #12
 801e058:	602b      	str	r3, [r5, #0]
 801e05a:	e7d5      	b.n	801e008 <_free_r+0x24>
 801e05c:	6821      	ldr	r1, [r4, #0]
 801e05e:	1860      	adds	r0, r4, r1
 801e060:	4283      	cmp	r3, r0
 801e062:	d103      	bne.n	801e06c <_free_r+0x88>
 801e064:	6818      	ldr	r0, [r3, #0]
 801e066:	685b      	ldr	r3, [r3, #4]
 801e068:	1841      	adds	r1, r0, r1
 801e06a:	6021      	str	r1, [r4, #0]
 801e06c:	6063      	str	r3, [r4, #4]
 801e06e:	6054      	str	r4, [r2, #4]
 801e070:	e7ca      	b.n	801e008 <_free_r+0x24>
 801e072:	46c0      	nop			; (mov r8, r8)
 801e074:	20001034 	.word	0x20001034

0801e078 <_malloc_r>:
 801e078:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801e07a:	2303      	movs	r3, #3
 801e07c:	1ccd      	adds	r5, r1, #3
 801e07e:	439d      	bics	r5, r3
 801e080:	3508      	adds	r5, #8
 801e082:	0006      	movs	r6, r0
 801e084:	2d0c      	cmp	r5, #12
 801e086:	d21f      	bcs.n	801e0c8 <_malloc_r+0x50>
 801e088:	250c      	movs	r5, #12
 801e08a:	42a9      	cmp	r1, r5
 801e08c:	d81e      	bhi.n	801e0cc <_malloc_r+0x54>
 801e08e:	0030      	movs	r0, r6
 801e090:	f000 f8fa 	bl	801e288 <__malloc_lock>
 801e094:	4925      	ldr	r1, [pc, #148]	; (801e12c <_malloc_r+0xb4>)
 801e096:	680a      	ldr	r2, [r1, #0]
 801e098:	0014      	movs	r4, r2
 801e09a:	2c00      	cmp	r4, #0
 801e09c:	d11a      	bne.n	801e0d4 <_malloc_r+0x5c>
 801e09e:	4f24      	ldr	r7, [pc, #144]	; (801e130 <_malloc_r+0xb8>)
 801e0a0:	683b      	ldr	r3, [r7, #0]
 801e0a2:	2b00      	cmp	r3, #0
 801e0a4:	d104      	bne.n	801e0b0 <_malloc_r+0x38>
 801e0a6:	0021      	movs	r1, r4
 801e0a8:	0030      	movs	r0, r6
 801e0aa:	f000 f843 	bl	801e134 <_sbrk_r>
 801e0ae:	6038      	str	r0, [r7, #0]
 801e0b0:	0029      	movs	r1, r5
 801e0b2:	0030      	movs	r0, r6
 801e0b4:	f000 f83e 	bl	801e134 <_sbrk_r>
 801e0b8:	1c43      	adds	r3, r0, #1
 801e0ba:	d12b      	bne.n	801e114 <_malloc_r+0x9c>
 801e0bc:	230c      	movs	r3, #12
 801e0be:	0030      	movs	r0, r6
 801e0c0:	6033      	str	r3, [r6, #0]
 801e0c2:	f000 f8e9 	bl	801e298 <__malloc_unlock>
 801e0c6:	e003      	b.n	801e0d0 <_malloc_r+0x58>
 801e0c8:	2d00      	cmp	r5, #0
 801e0ca:	dade      	bge.n	801e08a <_malloc_r+0x12>
 801e0cc:	230c      	movs	r3, #12
 801e0ce:	6033      	str	r3, [r6, #0]
 801e0d0:	2000      	movs	r0, #0
 801e0d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801e0d4:	6823      	ldr	r3, [r4, #0]
 801e0d6:	1b5b      	subs	r3, r3, r5
 801e0d8:	d419      	bmi.n	801e10e <_malloc_r+0x96>
 801e0da:	2b0b      	cmp	r3, #11
 801e0dc:	d903      	bls.n	801e0e6 <_malloc_r+0x6e>
 801e0de:	6023      	str	r3, [r4, #0]
 801e0e0:	18e4      	adds	r4, r4, r3
 801e0e2:	6025      	str	r5, [r4, #0]
 801e0e4:	e003      	b.n	801e0ee <_malloc_r+0x76>
 801e0e6:	6863      	ldr	r3, [r4, #4]
 801e0e8:	42a2      	cmp	r2, r4
 801e0ea:	d10e      	bne.n	801e10a <_malloc_r+0x92>
 801e0ec:	600b      	str	r3, [r1, #0]
 801e0ee:	0030      	movs	r0, r6
 801e0f0:	f000 f8d2 	bl	801e298 <__malloc_unlock>
 801e0f4:	0020      	movs	r0, r4
 801e0f6:	2207      	movs	r2, #7
 801e0f8:	300b      	adds	r0, #11
 801e0fa:	1d23      	adds	r3, r4, #4
 801e0fc:	4390      	bics	r0, r2
 801e0fe:	1ac2      	subs	r2, r0, r3
 801e100:	4298      	cmp	r0, r3
 801e102:	d0e6      	beq.n	801e0d2 <_malloc_r+0x5a>
 801e104:	1a1b      	subs	r3, r3, r0
 801e106:	50a3      	str	r3, [r4, r2]
 801e108:	e7e3      	b.n	801e0d2 <_malloc_r+0x5a>
 801e10a:	6053      	str	r3, [r2, #4]
 801e10c:	e7ef      	b.n	801e0ee <_malloc_r+0x76>
 801e10e:	0022      	movs	r2, r4
 801e110:	6864      	ldr	r4, [r4, #4]
 801e112:	e7c2      	b.n	801e09a <_malloc_r+0x22>
 801e114:	2303      	movs	r3, #3
 801e116:	1cc4      	adds	r4, r0, #3
 801e118:	439c      	bics	r4, r3
 801e11a:	42a0      	cmp	r0, r4
 801e11c:	d0e1      	beq.n	801e0e2 <_malloc_r+0x6a>
 801e11e:	1a21      	subs	r1, r4, r0
 801e120:	0030      	movs	r0, r6
 801e122:	f000 f807 	bl	801e134 <_sbrk_r>
 801e126:	1c43      	adds	r3, r0, #1
 801e128:	d1db      	bne.n	801e0e2 <_malloc_r+0x6a>
 801e12a:	e7c7      	b.n	801e0bc <_malloc_r+0x44>
 801e12c:	20001034 	.word	0x20001034
 801e130:	20001038 	.word	0x20001038

0801e134 <_sbrk_r>:
 801e134:	2300      	movs	r3, #0
 801e136:	b570      	push	{r4, r5, r6, lr}
 801e138:	4d06      	ldr	r5, [pc, #24]	; (801e154 <_sbrk_r+0x20>)
 801e13a:	0004      	movs	r4, r0
 801e13c:	0008      	movs	r0, r1
 801e13e:	602b      	str	r3, [r5, #0]
 801e140:	f7e2 fb7e 	bl	8000840 <_sbrk>
 801e144:	1c43      	adds	r3, r0, #1
 801e146:	d103      	bne.n	801e150 <_sbrk_r+0x1c>
 801e148:	682b      	ldr	r3, [r5, #0]
 801e14a:	2b00      	cmp	r3, #0
 801e14c:	d000      	beq.n	801e150 <_sbrk_r+0x1c>
 801e14e:	6023      	str	r3, [r4, #0]
 801e150:	bd70      	pop	{r4, r5, r6, pc}
 801e152:	46c0      	nop			; (mov r8, r8)
 801e154:	20003a74 	.word	0x20003a74

0801e158 <sniprintf>:
 801e158:	b40c      	push	{r2, r3}
 801e15a:	b530      	push	{r4, r5, lr}
 801e15c:	4b17      	ldr	r3, [pc, #92]	; (801e1bc <sniprintf+0x64>)
 801e15e:	000c      	movs	r4, r1
 801e160:	681d      	ldr	r5, [r3, #0]
 801e162:	b09d      	sub	sp, #116	; 0x74
 801e164:	2900      	cmp	r1, #0
 801e166:	da08      	bge.n	801e17a <sniprintf+0x22>
 801e168:	238b      	movs	r3, #139	; 0x8b
 801e16a:	2001      	movs	r0, #1
 801e16c:	602b      	str	r3, [r5, #0]
 801e16e:	4240      	negs	r0, r0
 801e170:	b01d      	add	sp, #116	; 0x74
 801e172:	bc30      	pop	{r4, r5}
 801e174:	bc08      	pop	{r3}
 801e176:	b002      	add	sp, #8
 801e178:	4718      	bx	r3
 801e17a:	2382      	movs	r3, #130	; 0x82
 801e17c:	466a      	mov	r2, sp
 801e17e:	009b      	lsls	r3, r3, #2
 801e180:	8293      	strh	r3, [r2, #20]
 801e182:	2300      	movs	r3, #0
 801e184:	9002      	str	r0, [sp, #8]
 801e186:	9006      	str	r0, [sp, #24]
 801e188:	4299      	cmp	r1, r3
 801e18a:	d000      	beq.n	801e18e <sniprintf+0x36>
 801e18c:	1e4b      	subs	r3, r1, #1
 801e18e:	9304      	str	r3, [sp, #16]
 801e190:	9307      	str	r3, [sp, #28]
 801e192:	2301      	movs	r3, #1
 801e194:	466a      	mov	r2, sp
 801e196:	425b      	negs	r3, r3
 801e198:	82d3      	strh	r3, [r2, #22]
 801e19a:	0028      	movs	r0, r5
 801e19c:	ab21      	add	r3, sp, #132	; 0x84
 801e19e:	9a20      	ldr	r2, [sp, #128]	; 0x80
 801e1a0:	a902      	add	r1, sp, #8
 801e1a2:	9301      	str	r3, [sp, #4]
 801e1a4:	f000 f8e2 	bl	801e36c <_svfiprintf_r>
 801e1a8:	1c43      	adds	r3, r0, #1
 801e1aa:	da01      	bge.n	801e1b0 <sniprintf+0x58>
 801e1ac:	238b      	movs	r3, #139	; 0x8b
 801e1ae:	602b      	str	r3, [r5, #0]
 801e1b0:	2c00      	cmp	r4, #0
 801e1b2:	d0dd      	beq.n	801e170 <sniprintf+0x18>
 801e1b4:	2300      	movs	r3, #0
 801e1b6:	9a02      	ldr	r2, [sp, #8]
 801e1b8:	7013      	strb	r3, [r2, #0]
 801e1ba:	e7d9      	b.n	801e170 <sniprintf+0x18>
 801e1bc:	20000040 	.word	0x20000040

0801e1c0 <strncpy>:
 801e1c0:	0003      	movs	r3, r0
 801e1c2:	b530      	push	{r4, r5, lr}
 801e1c4:	001d      	movs	r5, r3
 801e1c6:	2a00      	cmp	r2, #0
 801e1c8:	d006      	beq.n	801e1d8 <strncpy+0x18>
 801e1ca:	780c      	ldrb	r4, [r1, #0]
 801e1cc:	3a01      	subs	r2, #1
 801e1ce:	3301      	adds	r3, #1
 801e1d0:	702c      	strb	r4, [r5, #0]
 801e1d2:	3101      	adds	r1, #1
 801e1d4:	2c00      	cmp	r4, #0
 801e1d6:	d1f5      	bne.n	801e1c4 <strncpy+0x4>
 801e1d8:	2100      	movs	r1, #0
 801e1da:	189a      	adds	r2, r3, r2
 801e1dc:	4293      	cmp	r3, r2
 801e1de:	d100      	bne.n	801e1e2 <strncpy+0x22>
 801e1e0:	bd30      	pop	{r4, r5, pc}
 801e1e2:	7019      	strb	r1, [r3, #0]
 801e1e4:	3301      	adds	r3, #1
 801e1e6:	e7f9      	b.n	801e1dc <strncpy+0x1c>

0801e1e8 <strstr>:
 801e1e8:	780a      	ldrb	r2, [r1, #0]
 801e1ea:	b530      	push	{r4, r5, lr}
 801e1ec:	2a00      	cmp	r2, #0
 801e1ee:	d10c      	bne.n	801e20a <strstr+0x22>
 801e1f0:	bd30      	pop	{r4, r5, pc}
 801e1f2:	429a      	cmp	r2, r3
 801e1f4:	d108      	bne.n	801e208 <strstr+0x20>
 801e1f6:	2301      	movs	r3, #1
 801e1f8:	5ccc      	ldrb	r4, [r1, r3]
 801e1fa:	2c00      	cmp	r4, #0
 801e1fc:	d0f8      	beq.n	801e1f0 <strstr+0x8>
 801e1fe:	5cc5      	ldrb	r5, [r0, r3]
 801e200:	42a5      	cmp	r5, r4
 801e202:	d101      	bne.n	801e208 <strstr+0x20>
 801e204:	3301      	adds	r3, #1
 801e206:	e7f7      	b.n	801e1f8 <strstr+0x10>
 801e208:	3001      	adds	r0, #1
 801e20a:	7803      	ldrb	r3, [r0, #0]
 801e20c:	2b00      	cmp	r3, #0
 801e20e:	d1f0      	bne.n	801e1f2 <strstr+0xa>
 801e210:	0018      	movs	r0, r3
 801e212:	e7ed      	b.n	801e1f0 <strstr+0x8>

0801e214 <_vsniprintf_r>:
 801e214:	b530      	push	{r4, r5, lr}
 801e216:	0014      	movs	r4, r2
 801e218:	0005      	movs	r5, r0
 801e21a:	001a      	movs	r2, r3
 801e21c:	b09b      	sub	sp, #108	; 0x6c
 801e21e:	2c00      	cmp	r4, #0
 801e220:	da05      	bge.n	801e22e <_vsniprintf_r+0x1a>
 801e222:	238b      	movs	r3, #139	; 0x8b
 801e224:	6003      	str	r3, [r0, #0]
 801e226:	2001      	movs	r0, #1
 801e228:	4240      	negs	r0, r0
 801e22a:	b01b      	add	sp, #108	; 0x6c
 801e22c:	bd30      	pop	{r4, r5, pc}
 801e22e:	2382      	movs	r3, #130	; 0x82
 801e230:	4668      	mov	r0, sp
 801e232:	009b      	lsls	r3, r3, #2
 801e234:	8183      	strh	r3, [r0, #12]
 801e236:	2300      	movs	r3, #0
 801e238:	9100      	str	r1, [sp, #0]
 801e23a:	9104      	str	r1, [sp, #16]
 801e23c:	429c      	cmp	r4, r3
 801e23e:	d000      	beq.n	801e242 <_vsniprintf_r+0x2e>
 801e240:	1e63      	subs	r3, r4, #1
 801e242:	9302      	str	r3, [sp, #8]
 801e244:	9305      	str	r3, [sp, #20]
 801e246:	2301      	movs	r3, #1
 801e248:	4669      	mov	r1, sp
 801e24a:	425b      	negs	r3, r3
 801e24c:	81cb      	strh	r3, [r1, #14]
 801e24e:	0028      	movs	r0, r5
 801e250:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 801e252:	f000 f88b 	bl	801e36c <_svfiprintf_r>
 801e256:	1c43      	adds	r3, r0, #1
 801e258:	da01      	bge.n	801e25e <_vsniprintf_r+0x4a>
 801e25a:	238b      	movs	r3, #139	; 0x8b
 801e25c:	602b      	str	r3, [r5, #0]
 801e25e:	2c00      	cmp	r4, #0
 801e260:	d0e3      	beq.n	801e22a <_vsniprintf_r+0x16>
 801e262:	2300      	movs	r3, #0
 801e264:	9a00      	ldr	r2, [sp, #0]
 801e266:	7013      	strb	r3, [r2, #0]
 801e268:	e7df      	b.n	801e22a <_vsniprintf_r+0x16>
	...

0801e26c <vsniprintf>:
 801e26c:	b507      	push	{r0, r1, r2, lr}
 801e26e:	9300      	str	r3, [sp, #0]
 801e270:	0013      	movs	r3, r2
 801e272:	000a      	movs	r2, r1
 801e274:	0001      	movs	r1, r0
 801e276:	4802      	ldr	r0, [pc, #8]	; (801e280 <vsniprintf+0x14>)
 801e278:	6800      	ldr	r0, [r0, #0]
 801e27a:	f7ff ffcb 	bl	801e214 <_vsniprintf_r>
 801e27e:	bd0e      	pop	{r1, r2, r3, pc}
 801e280:	20000040 	.word	0x20000040

0801e284 <__retarget_lock_acquire_recursive>:
 801e284:	4770      	bx	lr

0801e286 <__retarget_lock_release_recursive>:
 801e286:	4770      	bx	lr

0801e288 <__malloc_lock>:
 801e288:	b510      	push	{r4, lr}
 801e28a:	4802      	ldr	r0, [pc, #8]	; (801e294 <__malloc_lock+0xc>)
 801e28c:	f7ff fffa 	bl	801e284 <__retarget_lock_acquire_recursive>
 801e290:	bd10      	pop	{r4, pc}
 801e292:	46c0      	nop			; (mov r8, r8)
 801e294:	20003a7c 	.word	0x20003a7c

0801e298 <__malloc_unlock>:
 801e298:	b510      	push	{r4, lr}
 801e29a:	4802      	ldr	r0, [pc, #8]	; (801e2a4 <__malloc_unlock+0xc>)
 801e29c:	f7ff fff3 	bl	801e286 <__retarget_lock_release_recursive>
 801e2a0:	bd10      	pop	{r4, pc}
 801e2a2:	46c0      	nop			; (mov r8, r8)
 801e2a4:	20003a7c 	.word	0x20003a7c

0801e2a8 <__ssputs_r>:
 801e2a8:	b5f0      	push	{r4, r5, r6, r7, lr}
 801e2aa:	688e      	ldr	r6, [r1, #8]
 801e2ac:	b085      	sub	sp, #20
 801e2ae:	0007      	movs	r7, r0
 801e2b0:	000c      	movs	r4, r1
 801e2b2:	9203      	str	r2, [sp, #12]
 801e2b4:	9301      	str	r3, [sp, #4]
 801e2b6:	429e      	cmp	r6, r3
 801e2b8:	d83c      	bhi.n	801e334 <__ssputs_r+0x8c>
 801e2ba:	2390      	movs	r3, #144	; 0x90
 801e2bc:	898a      	ldrh	r2, [r1, #12]
 801e2be:	00db      	lsls	r3, r3, #3
 801e2c0:	421a      	tst	r2, r3
 801e2c2:	d034      	beq.n	801e32e <__ssputs_r+0x86>
 801e2c4:	2503      	movs	r5, #3
 801e2c6:	6909      	ldr	r1, [r1, #16]
 801e2c8:	6823      	ldr	r3, [r4, #0]
 801e2ca:	1a5b      	subs	r3, r3, r1
 801e2cc:	9302      	str	r3, [sp, #8]
 801e2ce:	6963      	ldr	r3, [r4, #20]
 801e2d0:	9802      	ldr	r0, [sp, #8]
 801e2d2:	435d      	muls	r5, r3
 801e2d4:	0feb      	lsrs	r3, r5, #31
 801e2d6:	195d      	adds	r5, r3, r5
 801e2d8:	9b01      	ldr	r3, [sp, #4]
 801e2da:	106d      	asrs	r5, r5, #1
 801e2dc:	3301      	adds	r3, #1
 801e2de:	181b      	adds	r3, r3, r0
 801e2e0:	42ab      	cmp	r3, r5
 801e2e2:	d900      	bls.n	801e2e6 <__ssputs_r+0x3e>
 801e2e4:	001d      	movs	r5, r3
 801e2e6:	0553      	lsls	r3, r2, #21
 801e2e8:	d532      	bpl.n	801e350 <__ssputs_r+0xa8>
 801e2ea:	0029      	movs	r1, r5
 801e2ec:	0038      	movs	r0, r7
 801e2ee:	f7ff fec3 	bl	801e078 <_malloc_r>
 801e2f2:	1e06      	subs	r6, r0, #0
 801e2f4:	d109      	bne.n	801e30a <__ssputs_r+0x62>
 801e2f6:	230c      	movs	r3, #12
 801e2f8:	603b      	str	r3, [r7, #0]
 801e2fa:	2340      	movs	r3, #64	; 0x40
 801e2fc:	2001      	movs	r0, #1
 801e2fe:	89a2      	ldrh	r2, [r4, #12]
 801e300:	4240      	negs	r0, r0
 801e302:	4313      	orrs	r3, r2
 801e304:	81a3      	strh	r3, [r4, #12]
 801e306:	b005      	add	sp, #20
 801e308:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801e30a:	9a02      	ldr	r2, [sp, #8]
 801e30c:	6921      	ldr	r1, [r4, #16]
 801e30e:	f7ff fe45 	bl	801df9c <memcpy>
 801e312:	89a3      	ldrh	r3, [r4, #12]
 801e314:	4a14      	ldr	r2, [pc, #80]	; (801e368 <__ssputs_r+0xc0>)
 801e316:	401a      	ands	r2, r3
 801e318:	2380      	movs	r3, #128	; 0x80
 801e31a:	4313      	orrs	r3, r2
 801e31c:	81a3      	strh	r3, [r4, #12]
 801e31e:	9b02      	ldr	r3, [sp, #8]
 801e320:	6126      	str	r6, [r4, #16]
 801e322:	18f6      	adds	r6, r6, r3
 801e324:	6026      	str	r6, [r4, #0]
 801e326:	6165      	str	r5, [r4, #20]
 801e328:	9e01      	ldr	r6, [sp, #4]
 801e32a:	1aed      	subs	r5, r5, r3
 801e32c:	60a5      	str	r5, [r4, #8]
 801e32e:	9b01      	ldr	r3, [sp, #4]
 801e330:	429e      	cmp	r6, r3
 801e332:	d900      	bls.n	801e336 <__ssputs_r+0x8e>
 801e334:	9e01      	ldr	r6, [sp, #4]
 801e336:	0032      	movs	r2, r6
 801e338:	9903      	ldr	r1, [sp, #12]
 801e33a:	6820      	ldr	r0, [r4, #0]
 801e33c:	f7ff fe37 	bl	801dfae <memmove>
 801e340:	68a3      	ldr	r3, [r4, #8]
 801e342:	2000      	movs	r0, #0
 801e344:	1b9b      	subs	r3, r3, r6
 801e346:	60a3      	str	r3, [r4, #8]
 801e348:	6823      	ldr	r3, [r4, #0]
 801e34a:	199e      	adds	r6, r3, r6
 801e34c:	6026      	str	r6, [r4, #0]
 801e34e:	e7da      	b.n	801e306 <__ssputs_r+0x5e>
 801e350:	002a      	movs	r2, r5
 801e352:	0038      	movs	r0, r7
 801e354:	f000 fa97 	bl	801e886 <_realloc_r>
 801e358:	1e06      	subs	r6, r0, #0
 801e35a:	d1e0      	bne.n	801e31e <__ssputs_r+0x76>
 801e35c:	0038      	movs	r0, r7
 801e35e:	6921      	ldr	r1, [r4, #16]
 801e360:	f7ff fe40 	bl	801dfe4 <_free_r>
 801e364:	e7c7      	b.n	801e2f6 <__ssputs_r+0x4e>
 801e366:	46c0      	nop			; (mov r8, r8)
 801e368:	fffffb7f 	.word	0xfffffb7f

0801e36c <_svfiprintf_r>:
 801e36c:	b5f0      	push	{r4, r5, r6, r7, lr}
 801e36e:	b0a1      	sub	sp, #132	; 0x84
 801e370:	9003      	str	r0, [sp, #12]
 801e372:	001d      	movs	r5, r3
 801e374:	898b      	ldrh	r3, [r1, #12]
 801e376:	000f      	movs	r7, r1
 801e378:	0016      	movs	r6, r2
 801e37a:	061b      	lsls	r3, r3, #24
 801e37c:	d511      	bpl.n	801e3a2 <_svfiprintf_r+0x36>
 801e37e:	690b      	ldr	r3, [r1, #16]
 801e380:	2b00      	cmp	r3, #0
 801e382:	d10e      	bne.n	801e3a2 <_svfiprintf_r+0x36>
 801e384:	2140      	movs	r1, #64	; 0x40
 801e386:	f7ff fe77 	bl	801e078 <_malloc_r>
 801e38a:	6038      	str	r0, [r7, #0]
 801e38c:	6138      	str	r0, [r7, #16]
 801e38e:	2800      	cmp	r0, #0
 801e390:	d105      	bne.n	801e39e <_svfiprintf_r+0x32>
 801e392:	230c      	movs	r3, #12
 801e394:	9a03      	ldr	r2, [sp, #12]
 801e396:	3801      	subs	r0, #1
 801e398:	6013      	str	r3, [r2, #0]
 801e39a:	b021      	add	sp, #132	; 0x84
 801e39c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801e39e:	2340      	movs	r3, #64	; 0x40
 801e3a0:	617b      	str	r3, [r7, #20]
 801e3a2:	2300      	movs	r3, #0
 801e3a4:	ac08      	add	r4, sp, #32
 801e3a6:	6163      	str	r3, [r4, #20]
 801e3a8:	3320      	adds	r3, #32
 801e3aa:	7663      	strb	r3, [r4, #25]
 801e3ac:	3310      	adds	r3, #16
 801e3ae:	76a3      	strb	r3, [r4, #26]
 801e3b0:	9507      	str	r5, [sp, #28]
 801e3b2:	0035      	movs	r5, r6
 801e3b4:	782b      	ldrb	r3, [r5, #0]
 801e3b6:	2b00      	cmp	r3, #0
 801e3b8:	d001      	beq.n	801e3be <_svfiprintf_r+0x52>
 801e3ba:	2b25      	cmp	r3, #37	; 0x25
 801e3bc:	d147      	bne.n	801e44e <_svfiprintf_r+0xe2>
 801e3be:	1bab      	subs	r3, r5, r6
 801e3c0:	9305      	str	r3, [sp, #20]
 801e3c2:	42b5      	cmp	r5, r6
 801e3c4:	d00c      	beq.n	801e3e0 <_svfiprintf_r+0x74>
 801e3c6:	0032      	movs	r2, r6
 801e3c8:	0039      	movs	r1, r7
 801e3ca:	9803      	ldr	r0, [sp, #12]
 801e3cc:	f7ff ff6c 	bl	801e2a8 <__ssputs_r>
 801e3d0:	1c43      	adds	r3, r0, #1
 801e3d2:	d100      	bne.n	801e3d6 <_svfiprintf_r+0x6a>
 801e3d4:	e0ae      	b.n	801e534 <_svfiprintf_r+0x1c8>
 801e3d6:	6962      	ldr	r2, [r4, #20]
 801e3d8:	9b05      	ldr	r3, [sp, #20]
 801e3da:	4694      	mov	ip, r2
 801e3dc:	4463      	add	r3, ip
 801e3de:	6163      	str	r3, [r4, #20]
 801e3e0:	782b      	ldrb	r3, [r5, #0]
 801e3e2:	2b00      	cmp	r3, #0
 801e3e4:	d100      	bne.n	801e3e8 <_svfiprintf_r+0x7c>
 801e3e6:	e0a5      	b.n	801e534 <_svfiprintf_r+0x1c8>
 801e3e8:	2201      	movs	r2, #1
 801e3ea:	2300      	movs	r3, #0
 801e3ec:	4252      	negs	r2, r2
 801e3ee:	6062      	str	r2, [r4, #4]
 801e3f0:	a904      	add	r1, sp, #16
 801e3f2:	3254      	adds	r2, #84	; 0x54
 801e3f4:	1852      	adds	r2, r2, r1
 801e3f6:	1c6e      	adds	r6, r5, #1
 801e3f8:	6023      	str	r3, [r4, #0]
 801e3fa:	60e3      	str	r3, [r4, #12]
 801e3fc:	60a3      	str	r3, [r4, #8]
 801e3fe:	7013      	strb	r3, [r2, #0]
 801e400:	65a3      	str	r3, [r4, #88]	; 0x58
 801e402:	2205      	movs	r2, #5
 801e404:	7831      	ldrb	r1, [r6, #0]
 801e406:	4854      	ldr	r0, [pc, #336]	; (801e558 <_svfiprintf_r+0x1ec>)
 801e408:	f000 fa32 	bl	801e870 <memchr>
 801e40c:	1c75      	adds	r5, r6, #1
 801e40e:	2800      	cmp	r0, #0
 801e410:	d11f      	bne.n	801e452 <_svfiprintf_r+0xe6>
 801e412:	6822      	ldr	r2, [r4, #0]
 801e414:	06d3      	lsls	r3, r2, #27
 801e416:	d504      	bpl.n	801e422 <_svfiprintf_r+0xb6>
 801e418:	2353      	movs	r3, #83	; 0x53
 801e41a:	a904      	add	r1, sp, #16
 801e41c:	185b      	adds	r3, r3, r1
 801e41e:	2120      	movs	r1, #32
 801e420:	7019      	strb	r1, [r3, #0]
 801e422:	0713      	lsls	r3, r2, #28
 801e424:	d504      	bpl.n	801e430 <_svfiprintf_r+0xc4>
 801e426:	2353      	movs	r3, #83	; 0x53
 801e428:	a904      	add	r1, sp, #16
 801e42a:	185b      	adds	r3, r3, r1
 801e42c:	212b      	movs	r1, #43	; 0x2b
 801e42e:	7019      	strb	r1, [r3, #0]
 801e430:	7833      	ldrb	r3, [r6, #0]
 801e432:	2b2a      	cmp	r3, #42	; 0x2a
 801e434:	d016      	beq.n	801e464 <_svfiprintf_r+0xf8>
 801e436:	0035      	movs	r5, r6
 801e438:	2100      	movs	r1, #0
 801e43a:	200a      	movs	r0, #10
 801e43c:	68e3      	ldr	r3, [r4, #12]
 801e43e:	782a      	ldrb	r2, [r5, #0]
 801e440:	1c6e      	adds	r6, r5, #1
 801e442:	3a30      	subs	r2, #48	; 0x30
 801e444:	2a09      	cmp	r2, #9
 801e446:	d94e      	bls.n	801e4e6 <_svfiprintf_r+0x17a>
 801e448:	2900      	cmp	r1, #0
 801e44a:	d111      	bne.n	801e470 <_svfiprintf_r+0x104>
 801e44c:	e017      	b.n	801e47e <_svfiprintf_r+0x112>
 801e44e:	3501      	adds	r5, #1
 801e450:	e7b0      	b.n	801e3b4 <_svfiprintf_r+0x48>
 801e452:	4b41      	ldr	r3, [pc, #260]	; (801e558 <_svfiprintf_r+0x1ec>)
 801e454:	6822      	ldr	r2, [r4, #0]
 801e456:	1ac0      	subs	r0, r0, r3
 801e458:	2301      	movs	r3, #1
 801e45a:	4083      	lsls	r3, r0
 801e45c:	4313      	orrs	r3, r2
 801e45e:	002e      	movs	r6, r5
 801e460:	6023      	str	r3, [r4, #0]
 801e462:	e7ce      	b.n	801e402 <_svfiprintf_r+0x96>
 801e464:	9b07      	ldr	r3, [sp, #28]
 801e466:	1d19      	adds	r1, r3, #4
 801e468:	681b      	ldr	r3, [r3, #0]
 801e46a:	9107      	str	r1, [sp, #28]
 801e46c:	2b00      	cmp	r3, #0
 801e46e:	db01      	blt.n	801e474 <_svfiprintf_r+0x108>
 801e470:	930b      	str	r3, [sp, #44]	; 0x2c
 801e472:	e004      	b.n	801e47e <_svfiprintf_r+0x112>
 801e474:	425b      	negs	r3, r3
 801e476:	60e3      	str	r3, [r4, #12]
 801e478:	2302      	movs	r3, #2
 801e47a:	4313      	orrs	r3, r2
 801e47c:	6023      	str	r3, [r4, #0]
 801e47e:	782b      	ldrb	r3, [r5, #0]
 801e480:	2b2e      	cmp	r3, #46	; 0x2e
 801e482:	d10a      	bne.n	801e49a <_svfiprintf_r+0x12e>
 801e484:	786b      	ldrb	r3, [r5, #1]
 801e486:	2b2a      	cmp	r3, #42	; 0x2a
 801e488:	d135      	bne.n	801e4f6 <_svfiprintf_r+0x18a>
 801e48a:	9b07      	ldr	r3, [sp, #28]
 801e48c:	3502      	adds	r5, #2
 801e48e:	1d1a      	adds	r2, r3, #4
 801e490:	681b      	ldr	r3, [r3, #0]
 801e492:	9207      	str	r2, [sp, #28]
 801e494:	2b00      	cmp	r3, #0
 801e496:	db2b      	blt.n	801e4f0 <_svfiprintf_r+0x184>
 801e498:	9309      	str	r3, [sp, #36]	; 0x24
 801e49a:	4e30      	ldr	r6, [pc, #192]	; (801e55c <_svfiprintf_r+0x1f0>)
 801e49c:	2203      	movs	r2, #3
 801e49e:	0030      	movs	r0, r6
 801e4a0:	7829      	ldrb	r1, [r5, #0]
 801e4a2:	f000 f9e5 	bl	801e870 <memchr>
 801e4a6:	2800      	cmp	r0, #0
 801e4a8:	d006      	beq.n	801e4b8 <_svfiprintf_r+0x14c>
 801e4aa:	2340      	movs	r3, #64	; 0x40
 801e4ac:	1b80      	subs	r0, r0, r6
 801e4ae:	4083      	lsls	r3, r0
 801e4b0:	6822      	ldr	r2, [r4, #0]
 801e4b2:	3501      	adds	r5, #1
 801e4b4:	4313      	orrs	r3, r2
 801e4b6:	6023      	str	r3, [r4, #0]
 801e4b8:	7829      	ldrb	r1, [r5, #0]
 801e4ba:	2206      	movs	r2, #6
 801e4bc:	4828      	ldr	r0, [pc, #160]	; (801e560 <_svfiprintf_r+0x1f4>)
 801e4be:	1c6e      	adds	r6, r5, #1
 801e4c0:	7621      	strb	r1, [r4, #24]
 801e4c2:	f000 f9d5 	bl	801e870 <memchr>
 801e4c6:	2800      	cmp	r0, #0
 801e4c8:	d03c      	beq.n	801e544 <_svfiprintf_r+0x1d8>
 801e4ca:	4b26      	ldr	r3, [pc, #152]	; (801e564 <_svfiprintf_r+0x1f8>)
 801e4cc:	2b00      	cmp	r3, #0
 801e4ce:	d125      	bne.n	801e51c <_svfiprintf_r+0x1b0>
 801e4d0:	2207      	movs	r2, #7
 801e4d2:	9b07      	ldr	r3, [sp, #28]
 801e4d4:	3307      	adds	r3, #7
 801e4d6:	4393      	bics	r3, r2
 801e4d8:	3308      	adds	r3, #8
 801e4da:	9307      	str	r3, [sp, #28]
 801e4dc:	6963      	ldr	r3, [r4, #20]
 801e4de:	9a04      	ldr	r2, [sp, #16]
 801e4e0:	189b      	adds	r3, r3, r2
 801e4e2:	6163      	str	r3, [r4, #20]
 801e4e4:	e765      	b.n	801e3b2 <_svfiprintf_r+0x46>
 801e4e6:	4343      	muls	r3, r0
 801e4e8:	0035      	movs	r5, r6
 801e4ea:	2101      	movs	r1, #1
 801e4ec:	189b      	adds	r3, r3, r2
 801e4ee:	e7a6      	b.n	801e43e <_svfiprintf_r+0xd2>
 801e4f0:	2301      	movs	r3, #1
 801e4f2:	425b      	negs	r3, r3
 801e4f4:	e7d0      	b.n	801e498 <_svfiprintf_r+0x12c>
 801e4f6:	2300      	movs	r3, #0
 801e4f8:	200a      	movs	r0, #10
 801e4fa:	001a      	movs	r2, r3
 801e4fc:	3501      	adds	r5, #1
 801e4fe:	6063      	str	r3, [r4, #4]
 801e500:	7829      	ldrb	r1, [r5, #0]
 801e502:	1c6e      	adds	r6, r5, #1
 801e504:	3930      	subs	r1, #48	; 0x30
 801e506:	2909      	cmp	r1, #9
 801e508:	d903      	bls.n	801e512 <_svfiprintf_r+0x1a6>
 801e50a:	2b00      	cmp	r3, #0
 801e50c:	d0c5      	beq.n	801e49a <_svfiprintf_r+0x12e>
 801e50e:	9209      	str	r2, [sp, #36]	; 0x24
 801e510:	e7c3      	b.n	801e49a <_svfiprintf_r+0x12e>
 801e512:	4342      	muls	r2, r0
 801e514:	0035      	movs	r5, r6
 801e516:	2301      	movs	r3, #1
 801e518:	1852      	adds	r2, r2, r1
 801e51a:	e7f1      	b.n	801e500 <_svfiprintf_r+0x194>
 801e51c:	ab07      	add	r3, sp, #28
 801e51e:	9300      	str	r3, [sp, #0]
 801e520:	003a      	movs	r2, r7
 801e522:	0021      	movs	r1, r4
 801e524:	4b10      	ldr	r3, [pc, #64]	; (801e568 <_svfiprintf_r+0x1fc>)
 801e526:	9803      	ldr	r0, [sp, #12]
 801e528:	e000      	b.n	801e52c <_svfiprintf_r+0x1c0>
 801e52a:	bf00      	nop
 801e52c:	9004      	str	r0, [sp, #16]
 801e52e:	9b04      	ldr	r3, [sp, #16]
 801e530:	3301      	adds	r3, #1
 801e532:	d1d3      	bne.n	801e4dc <_svfiprintf_r+0x170>
 801e534:	89bb      	ldrh	r3, [r7, #12]
 801e536:	980d      	ldr	r0, [sp, #52]	; 0x34
 801e538:	065b      	lsls	r3, r3, #25
 801e53a:	d400      	bmi.n	801e53e <_svfiprintf_r+0x1d2>
 801e53c:	e72d      	b.n	801e39a <_svfiprintf_r+0x2e>
 801e53e:	2001      	movs	r0, #1
 801e540:	4240      	negs	r0, r0
 801e542:	e72a      	b.n	801e39a <_svfiprintf_r+0x2e>
 801e544:	ab07      	add	r3, sp, #28
 801e546:	9300      	str	r3, [sp, #0]
 801e548:	003a      	movs	r2, r7
 801e54a:	0021      	movs	r1, r4
 801e54c:	4b06      	ldr	r3, [pc, #24]	; (801e568 <_svfiprintf_r+0x1fc>)
 801e54e:	9803      	ldr	r0, [sp, #12]
 801e550:	f000 f87c 	bl	801e64c <_printf_i>
 801e554:	e7ea      	b.n	801e52c <_svfiprintf_r+0x1c0>
 801e556:	46c0      	nop			; (mov r8, r8)
 801e558:	08024189 	.word	0x08024189
 801e55c:	0802418f 	.word	0x0802418f
 801e560:	08024193 	.word	0x08024193
 801e564:	00000000 	.word	0x00000000
 801e568:	0801e2a9 	.word	0x0801e2a9

0801e56c <_printf_common>:
 801e56c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 801e56e:	0015      	movs	r5, r2
 801e570:	9301      	str	r3, [sp, #4]
 801e572:	688a      	ldr	r2, [r1, #8]
 801e574:	690b      	ldr	r3, [r1, #16]
 801e576:	000c      	movs	r4, r1
 801e578:	9000      	str	r0, [sp, #0]
 801e57a:	4293      	cmp	r3, r2
 801e57c:	da00      	bge.n	801e580 <_printf_common+0x14>
 801e57e:	0013      	movs	r3, r2
 801e580:	0022      	movs	r2, r4
 801e582:	602b      	str	r3, [r5, #0]
 801e584:	3243      	adds	r2, #67	; 0x43
 801e586:	7812      	ldrb	r2, [r2, #0]
 801e588:	2a00      	cmp	r2, #0
 801e58a:	d001      	beq.n	801e590 <_printf_common+0x24>
 801e58c:	3301      	adds	r3, #1
 801e58e:	602b      	str	r3, [r5, #0]
 801e590:	6823      	ldr	r3, [r4, #0]
 801e592:	069b      	lsls	r3, r3, #26
 801e594:	d502      	bpl.n	801e59c <_printf_common+0x30>
 801e596:	682b      	ldr	r3, [r5, #0]
 801e598:	3302      	adds	r3, #2
 801e59a:	602b      	str	r3, [r5, #0]
 801e59c:	6822      	ldr	r2, [r4, #0]
 801e59e:	2306      	movs	r3, #6
 801e5a0:	0017      	movs	r7, r2
 801e5a2:	401f      	ands	r7, r3
 801e5a4:	421a      	tst	r2, r3
 801e5a6:	d027      	beq.n	801e5f8 <_printf_common+0x8c>
 801e5a8:	0023      	movs	r3, r4
 801e5aa:	3343      	adds	r3, #67	; 0x43
 801e5ac:	781b      	ldrb	r3, [r3, #0]
 801e5ae:	1e5a      	subs	r2, r3, #1
 801e5b0:	4193      	sbcs	r3, r2
 801e5b2:	6822      	ldr	r2, [r4, #0]
 801e5b4:	0692      	lsls	r2, r2, #26
 801e5b6:	d430      	bmi.n	801e61a <_printf_common+0xae>
 801e5b8:	0022      	movs	r2, r4
 801e5ba:	9901      	ldr	r1, [sp, #4]
 801e5bc:	9800      	ldr	r0, [sp, #0]
 801e5be:	9e08      	ldr	r6, [sp, #32]
 801e5c0:	3243      	adds	r2, #67	; 0x43
 801e5c2:	47b0      	blx	r6
 801e5c4:	1c43      	adds	r3, r0, #1
 801e5c6:	d025      	beq.n	801e614 <_printf_common+0xa8>
 801e5c8:	2306      	movs	r3, #6
 801e5ca:	6820      	ldr	r0, [r4, #0]
 801e5cc:	682a      	ldr	r2, [r5, #0]
 801e5ce:	68e1      	ldr	r1, [r4, #12]
 801e5d0:	2500      	movs	r5, #0
 801e5d2:	4003      	ands	r3, r0
 801e5d4:	2b04      	cmp	r3, #4
 801e5d6:	d103      	bne.n	801e5e0 <_printf_common+0x74>
 801e5d8:	1a8d      	subs	r5, r1, r2
 801e5da:	43eb      	mvns	r3, r5
 801e5dc:	17db      	asrs	r3, r3, #31
 801e5de:	401d      	ands	r5, r3
 801e5e0:	68a3      	ldr	r3, [r4, #8]
 801e5e2:	6922      	ldr	r2, [r4, #16]
 801e5e4:	4293      	cmp	r3, r2
 801e5e6:	dd01      	ble.n	801e5ec <_printf_common+0x80>
 801e5e8:	1a9b      	subs	r3, r3, r2
 801e5ea:	18ed      	adds	r5, r5, r3
 801e5ec:	2700      	movs	r7, #0
 801e5ee:	42bd      	cmp	r5, r7
 801e5f0:	d120      	bne.n	801e634 <_printf_common+0xc8>
 801e5f2:	2000      	movs	r0, #0
 801e5f4:	e010      	b.n	801e618 <_printf_common+0xac>
 801e5f6:	3701      	adds	r7, #1
 801e5f8:	68e3      	ldr	r3, [r4, #12]
 801e5fa:	682a      	ldr	r2, [r5, #0]
 801e5fc:	1a9b      	subs	r3, r3, r2
 801e5fe:	42bb      	cmp	r3, r7
 801e600:	ddd2      	ble.n	801e5a8 <_printf_common+0x3c>
 801e602:	0022      	movs	r2, r4
 801e604:	2301      	movs	r3, #1
 801e606:	9901      	ldr	r1, [sp, #4]
 801e608:	9800      	ldr	r0, [sp, #0]
 801e60a:	9e08      	ldr	r6, [sp, #32]
 801e60c:	3219      	adds	r2, #25
 801e60e:	47b0      	blx	r6
 801e610:	1c43      	adds	r3, r0, #1
 801e612:	d1f0      	bne.n	801e5f6 <_printf_common+0x8a>
 801e614:	2001      	movs	r0, #1
 801e616:	4240      	negs	r0, r0
 801e618:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 801e61a:	2030      	movs	r0, #48	; 0x30
 801e61c:	18e1      	adds	r1, r4, r3
 801e61e:	3143      	adds	r1, #67	; 0x43
 801e620:	7008      	strb	r0, [r1, #0]
 801e622:	0021      	movs	r1, r4
 801e624:	1c5a      	adds	r2, r3, #1
 801e626:	3145      	adds	r1, #69	; 0x45
 801e628:	7809      	ldrb	r1, [r1, #0]
 801e62a:	18a2      	adds	r2, r4, r2
 801e62c:	3243      	adds	r2, #67	; 0x43
 801e62e:	3302      	adds	r3, #2
 801e630:	7011      	strb	r1, [r2, #0]
 801e632:	e7c1      	b.n	801e5b8 <_printf_common+0x4c>
 801e634:	0022      	movs	r2, r4
 801e636:	2301      	movs	r3, #1
 801e638:	9901      	ldr	r1, [sp, #4]
 801e63a:	9800      	ldr	r0, [sp, #0]
 801e63c:	9e08      	ldr	r6, [sp, #32]
 801e63e:	321a      	adds	r2, #26
 801e640:	47b0      	blx	r6
 801e642:	1c43      	adds	r3, r0, #1
 801e644:	d0e6      	beq.n	801e614 <_printf_common+0xa8>
 801e646:	3701      	adds	r7, #1
 801e648:	e7d1      	b.n	801e5ee <_printf_common+0x82>
	...

0801e64c <_printf_i>:
 801e64c:	b5f0      	push	{r4, r5, r6, r7, lr}
 801e64e:	b08b      	sub	sp, #44	; 0x2c
 801e650:	9206      	str	r2, [sp, #24]
 801e652:	000a      	movs	r2, r1
 801e654:	3243      	adds	r2, #67	; 0x43
 801e656:	9307      	str	r3, [sp, #28]
 801e658:	9005      	str	r0, [sp, #20]
 801e65a:	9204      	str	r2, [sp, #16]
 801e65c:	7e0a      	ldrb	r2, [r1, #24]
 801e65e:	000c      	movs	r4, r1
 801e660:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801e662:	2a78      	cmp	r2, #120	; 0x78
 801e664:	d806      	bhi.n	801e674 <_printf_i+0x28>
 801e666:	2a62      	cmp	r2, #98	; 0x62
 801e668:	d808      	bhi.n	801e67c <_printf_i+0x30>
 801e66a:	2a00      	cmp	r2, #0
 801e66c:	d100      	bne.n	801e670 <_printf_i+0x24>
 801e66e:	e0c0      	b.n	801e7f2 <_printf_i+0x1a6>
 801e670:	2a58      	cmp	r2, #88	; 0x58
 801e672:	d052      	beq.n	801e71a <_printf_i+0xce>
 801e674:	0026      	movs	r6, r4
 801e676:	3642      	adds	r6, #66	; 0x42
 801e678:	7032      	strb	r2, [r6, #0]
 801e67a:	e022      	b.n	801e6c2 <_printf_i+0x76>
 801e67c:	0010      	movs	r0, r2
 801e67e:	3863      	subs	r0, #99	; 0x63
 801e680:	2815      	cmp	r0, #21
 801e682:	d8f7      	bhi.n	801e674 <_printf_i+0x28>
 801e684:	f7e1 fd52 	bl	800012c <__gnu_thumb1_case_shi>
 801e688:	001f0016 	.word	0x001f0016
 801e68c:	fff6fff6 	.word	0xfff6fff6
 801e690:	fff6fff6 	.word	0xfff6fff6
 801e694:	fff6001f 	.word	0xfff6001f
 801e698:	fff6fff6 	.word	0xfff6fff6
 801e69c:	00a8fff6 	.word	0x00a8fff6
 801e6a0:	009a0036 	.word	0x009a0036
 801e6a4:	fff6fff6 	.word	0xfff6fff6
 801e6a8:	fff600b9 	.word	0xfff600b9
 801e6ac:	fff60036 	.word	0xfff60036
 801e6b0:	009efff6 	.word	0x009efff6
 801e6b4:	0026      	movs	r6, r4
 801e6b6:	681a      	ldr	r2, [r3, #0]
 801e6b8:	3642      	adds	r6, #66	; 0x42
 801e6ba:	1d11      	adds	r1, r2, #4
 801e6bc:	6019      	str	r1, [r3, #0]
 801e6be:	6813      	ldr	r3, [r2, #0]
 801e6c0:	7033      	strb	r3, [r6, #0]
 801e6c2:	2301      	movs	r3, #1
 801e6c4:	e0a7      	b.n	801e816 <_printf_i+0x1ca>
 801e6c6:	6808      	ldr	r0, [r1, #0]
 801e6c8:	6819      	ldr	r1, [r3, #0]
 801e6ca:	1d0a      	adds	r2, r1, #4
 801e6cc:	0605      	lsls	r5, r0, #24
 801e6ce:	d50b      	bpl.n	801e6e8 <_printf_i+0x9c>
 801e6d0:	680d      	ldr	r5, [r1, #0]
 801e6d2:	601a      	str	r2, [r3, #0]
 801e6d4:	2d00      	cmp	r5, #0
 801e6d6:	da03      	bge.n	801e6e0 <_printf_i+0x94>
 801e6d8:	232d      	movs	r3, #45	; 0x2d
 801e6da:	9a04      	ldr	r2, [sp, #16]
 801e6dc:	426d      	negs	r5, r5
 801e6de:	7013      	strb	r3, [r2, #0]
 801e6e0:	4b61      	ldr	r3, [pc, #388]	; (801e868 <_printf_i+0x21c>)
 801e6e2:	270a      	movs	r7, #10
 801e6e4:	9303      	str	r3, [sp, #12]
 801e6e6:	e032      	b.n	801e74e <_printf_i+0x102>
 801e6e8:	680d      	ldr	r5, [r1, #0]
 801e6ea:	601a      	str	r2, [r3, #0]
 801e6ec:	0641      	lsls	r1, r0, #25
 801e6ee:	d5f1      	bpl.n	801e6d4 <_printf_i+0x88>
 801e6f0:	b22d      	sxth	r5, r5
 801e6f2:	e7ef      	b.n	801e6d4 <_printf_i+0x88>
 801e6f4:	680d      	ldr	r5, [r1, #0]
 801e6f6:	6819      	ldr	r1, [r3, #0]
 801e6f8:	1d08      	adds	r0, r1, #4
 801e6fa:	6018      	str	r0, [r3, #0]
 801e6fc:	062e      	lsls	r6, r5, #24
 801e6fe:	d501      	bpl.n	801e704 <_printf_i+0xb8>
 801e700:	680d      	ldr	r5, [r1, #0]
 801e702:	e003      	b.n	801e70c <_printf_i+0xc0>
 801e704:	066d      	lsls	r5, r5, #25
 801e706:	d5fb      	bpl.n	801e700 <_printf_i+0xb4>
 801e708:	680d      	ldr	r5, [r1, #0]
 801e70a:	b2ad      	uxth	r5, r5
 801e70c:	4b56      	ldr	r3, [pc, #344]	; (801e868 <_printf_i+0x21c>)
 801e70e:	270a      	movs	r7, #10
 801e710:	9303      	str	r3, [sp, #12]
 801e712:	2a6f      	cmp	r2, #111	; 0x6f
 801e714:	d117      	bne.n	801e746 <_printf_i+0xfa>
 801e716:	2708      	movs	r7, #8
 801e718:	e015      	b.n	801e746 <_printf_i+0xfa>
 801e71a:	3145      	adds	r1, #69	; 0x45
 801e71c:	700a      	strb	r2, [r1, #0]
 801e71e:	4a52      	ldr	r2, [pc, #328]	; (801e868 <_printf_i+0x21c>)
 801e720:	9203      	str	r2, [sp, #12]
 801e722:	681a      	ldr	r2, [r3, #0]
 801e724:	6821      	ldr	r1, [r4, #0]
 801e726:	ca20      	ldmia	r2!, {r5}
 801e728:	601a      	str	r2, [r3, #0]
 801e72a:	0608      	lsls	r0, r1, #24
 801e72c:	d550      	bpl.n	801e7d0 <_printf_i+0x184>
 801e72e:	07cb      	lsls	r3, r1, #31
 801e730:	d502      	bpl.n	801e738 <_printf_i+0xec>
 801e732:	2320      	movs	r3, #32
 801e734:	4319      	orrs	r1, r3
 801e736:	6021      	str	r1, [r4, #0]
 801e738:	2710      	movs	r7, #16
 801e73a:	2d00      	cmp	r5, #0
 801e73c:	d103      	bne.n	801e746 <_printf_i+0xfa>
 801e73e:	2320      	movs	r3, #32
 801e740:	6822      	ldr	r2, [r4, #0]
 801e742:	439a      	bics	r2, r3
 801e744:	6022      	str	r2, [r4, #0]
 801e746:	0023      	movs	r3, r4
 801e748:	2200      	movs	r2, #0
 801e74a:	3343      	adds	r3, #67	; 0x43
 801e74c:	701a      	strb	r2, [r3, #0]
 801e74e:	6863      	ldr	r3, [r4, #4]
 801e750:	60a3      	str	r3, [r4, #8]
 801e752:	2b00      	cmp	r3, #0
 801e754:	db03      	blt.n	801e75e <_printf_i+0x112>
 801e756:	2204      	movs	r2, #4
 801e758:	6821      	ldr	r1, [r4, #0]
 801e75a:	4391      	bics	r1, r2
 801e75c:	6021      	str	r1, [r4, #0]
 801e75e:	2d00      	cmp	r5, #0
 801e760:	d102      	bne.n	801e768 <_printf_i+0x11c>
 801e762:	9e04      	ldr	r6, [sp, #16]
 801e764:	2b00      	cmp	r3, #0
 801e766:	d00c      	beq.n	801e782 <_printf_i+0x136>
 801e768:	9e04      	ldr	r6, [sp, #16]
 801e76a:	0028      	movs	r0, r5
 801e76c:	0039      	movs	r1, r7
 801e76e:	f7e1 fd6d 	bl	800024c <__aeabi_uidivmod>
 801e772:	9b03      	ldr	r3, [sp, #12]
 801e774:	3e01      	subs	r6, #1
 801e776:	5c5b      	ldrb	r3, [r3, r1]
 801e778:	7033      	strb	r3, [r6, #0]
 801e77a:	002b      	movs	r3, r5
 801e77c:	0005      	movs	r5, r0
 801e77e:	429f      	cmp	r7, r3
 801e780:	d9f3      	bls.n	801e76a <_printf_i+0x11e>
 801e782:	2f08      	cmp	r7, #8
 801e784:	d109      	bne.n	801e79a <_printf_i+0x14e>
 801e786:	6823      	ldr	r3, [r4, #0]
 801e788:	07db      	lsls	r3, r3, #31
 801e78a:	d506      	bpl.n	801e79a <_printf_i+0x14e>
 801e78c:	6863      	ldr	r3, [r4, #4]
 801e78e:	6922      	ldr	r2, [r4, #16]
 801e790:	4293      	cmp	r3, r2
 801e792:	dc02      	bgt.n	801e79a <_printf_i+0x14e>
 801e794:	2330      	movs	r3, #48	; 0x30
 801e796:	3e01      	subs	r6, #1
 801e798:	7033      	strb	r3, [r6, #0]
 801e79a:	9b04      	ldr	r3, [sp, #16]
 801e79c:	1b9b      	subs	r3, r3, r6
 801e79e:	6123      	str	r3, [r4, #16]
 801e7a0:	9b07      	ldr	r3, [sp, #28]
 801e7a2:	0021      	movs	r1, r4
 801e7a4:	9300      	str	r3, [sp, #0]
 801e7a6:	9805      	ldr	r0, [sp, #20]
 801e7a8:	9b06      	ldr	r3, [sp, #24]
 801e7aa:	aa09      	add	r2, sp, #36	; 0x24
 801e7ac:	f7ff fede 	bl	801e56c <_printf_common>
 801e7b0:	1c43      	adds	r3, r0, #1
 801e7b2:	d135      	bne.n	801e820 <_printf_i+0x1d4>
 801e7b4:	2001      	movs	r0, #1
 801e7b6:	4240      	negs	r0, r0
 801e7b8:	b00b      	add	sp, #44	; 0x2c
 801e7ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801e7bc:	2220      	movs	r2, #32
 801e7be:	6809      	ldr	r1, [r1, #0]
 801e7c0:	430a      	orrs	r2, r1
 801e7c2:	6022      	str	r2, [r4, #0]
 801e7c4:	0022      	movs	r2, r4
 801e7c6:	2178      	movs	r1, #120	; 0x78
 801e7c8:	3245      	adds	r2, #69	; 0x45
 801e7ca:	7011      	strb	r1, [r2, #0]
 801e7cc:	4a27      	ldr	r2, [pc, #156]	; (801e86c <_printf_i+0x220>)
 801e7ce:	e7a7      	b.n	801e720 <_printf_i+0xd4>
 801e7d0:	0648      	lsls	r0, r1, #25
 801e7d2:	d5ac      	bpl.n	801e72e <_printf_i+0xe2>
 801e7d4:	b2ad      	uxth	r5, r5
 801e7d6:	e7aa      	b.n	801e72e <_printf_i+0xe2>
 801e7d8:	681a      	ldr	r2, [r3, #0]
 801e7da:	680d      	ldr	r5, [r1, #0]
 801e7dc:	1d10      	adds	r0, r2, #4
 801e7de:	6949      	ldr	r1, [r1, #20]
 801e7e0:	6018      	str	r0, [r3, #0]
 801e7e2:	6813      	ldr	r3, [r2, #0]
 801e7e4:	062e      	lsls	r6, r5, #24
 801e7e6:	d501      	bpl.n	801e7ec <_printf_i+0x1a0>
 801e7e8:	6019      	str	r1, [r3, #0]
 801e7ea:	e002      	b.n	801e7f2 <_printf_i+0x1a6>
 801e7ec:	066d      	lsls	r5, r5, #25
 801e7ee:	d5fb      	bpl.n	801e7e8 <_printf_i+0x19c>
 801e7f0:	8019      	strh	r1, [r3, #0]
 801e7f2:	2300      	movs	r3, #0
 801e7f4:	9e04      	ldr	r6, [sp, #16]
 801e7f6:	6123      	str	r3, [r4, #16]
 801e7f8:	e7d2      	b.n	801e7a0 <_printf_i+0x154>
 801e7fa:	681a      	ldr	r2, [r3, #0]
 801e7fc:	1d11      	adds	r1, r2, #4
 801e7fe:	6019      	str	r1, [r3, #0]
 801e800:	6816      	ldr	r6, [r2, #0]
 801e802:	2100      	movs	r1, #0
 801e804:	0030      	movs	r0, r6
 801e806:	6862      	ldr	r2, [r4, #4]
 801e808:	f000 f832 	bl	801e870 <memchr>
 801e80c:	2800      	cmp	r0, #0
 801e80e:	d001      	beq.n	801e814 <_printf_i+0x1c8>
 801e810:	1b80      	subs	r0, r0, r6
 801e812:	6060      	str	r0, [r4, #4]
 801e814:	6863      	ldr	r3, [r4, #4]
 801e816:	6123      	str	r3, [r4, #16]
 801e818:	2300      	movs	r3, #0
 801e81a:	9a04      	ldr	r2, [sp, #16]
 801e81c:	7013      	strb	r3, [r2, #0]
 801e81e:	e7bf      	b.n	801e7a0 <_printf_i+0x154>
 801e820:	6923      	ldr	r3, [r4, #16]
 801e822:	0032      	movs	r2, r6
 801e824:	9906      	ldr	r1, [sp, #24]
 801e826:	9805      	ldr	r0, [sp, #20]
 801e828:	9d07      	ldr	r5, [sp, #28]
 801e82a:	47a8      	blx	r5
 801e82c:	1c43      	adds	r3, r0, #1
 801e82e:	d0c1      	beq.n	801e7b4 <_printf_i+0x168>
 801e830:	6823      	ldr	r3, [r4, #0]
 801e832:	079b      	lsls	r3, r3, #30
 801e834:	d415      	bmi.n	801e862 <_printf_i+0x216>
 801e836:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801e838:	68e0      	ldr	r0, [r4, #12]
 801e83a:	4298      	cmp	r0, r3
 801e83c:	dabc      	bge.n	801e7b8 <_printf_i+0x16c>
 801e83e:	0018      	movs	r0, r3
 801e840:	e7ba      	b.n	801e7b8 <_printf_i+0x16c>
 801e842:	0022      	movs	r2, r4
 801e844:	2301      	movs	r3, #1
 801e846:	9906      	ldr	r1, [sp, #24]
 801e848:	9805      	ldr	r0, [sp, #20]
 801e84a:	9e07      	ldr	r6, [sp, #28]
 801e84c:	3219      	adds	r2, #25
 801e84e:	47b0      	blx	r6
 801e850:	1c43      	adds	r3, r0, #1
 801e852:	d0af      	beq.n	801e7b4 <_printf_i+0x168>
 801e854:	3501      	adds	r5, #1
 801e856:	68e3      	ldr	r3, [r4, #12]
 801e858:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801e85a:	1a9b      	subs	r3, r3, r2
 801e85c:	42ab      	cmp	r3, r5
 801e85e:	dcf0      	bgt.n	801e842 <_printf_i+0x1f6>
 801e860:	e7e9      	b.n	801e836 <_printf_i+0x1ea>
 801e862:	2500      	movs	r5, #0
 801e864:	e7f7      	b.n	801e856 <_printf_i+0x20a>
 801e866:	46c0      	nop			; (mov r8, r8)
 801e868:	0802419a 	.word	0x0802419a
 801e86c:	080241ab 	.word	0x080241ab

0801e870 <memchr>:
 801e870:	b2c9      	uxtb	r1, r1
 801e872:	1882      	adds	r2, r0, r2
 801e874:	4290      	cmp	r0, r2
 801e876:	d101      	bne.n	801e87c <memchr+0xc>
 801e878:	2000      	movs	r0, #0
 801e87a:	4770      	bx	lr
 801e87c:	7803      	ldrb	r3, [r0, #0]
 801e87e:	428b      	cmp	r3, r1
 801e880:	d0fb      	beq.n	801e87a <memchr+0xa>
 801e882:	3001      	adds	r0, #1
 801e884:	e7f6      	b.n	801e874 <memchr+0x4>

0801e886 <_realloc_r>:
 801e886:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801e888:	0007      	movs	r7, r0
 801e88a:	000d      	movs	r5, r1
 801e88c:	0016      	movs	r6, r2
 801e88e:	2900      	cmp	r1, #0
 801e890:	d105      	bne.n	801e89e <_realloc_r+0x18>
 801e892:	0011      	movs	r1, r2
 801e894:	f7ff fbf0 	bl	801e078 <_malloc_r>
 801e898:	0004      	movs	r4, r0
 801e89a:	0020      	movs	r0, r4
 801e89c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801e89e:	2a00      	cmp	r2, #0
 801e8a0:	d103      	bne.n	801e8aa <_realloc_r+0x24>
 801e8a2:	f7ff fb9f 	bl	801dfe4 <_free_r>
 801e8a6:	0034      	movs	r4, r6
 801e8a8:	e7f7      	b.n	801e89a <_realloc_r+0x14>
 801e8aa:	f000 f812 	bl	801e8d2 <_malloc_usable_size_r>
 801e8ae:	002c      	movs	r4, r5
 801e8b0:	42b0      	cmp	r0, r6
 801e8b2:	d2f2      	bcs.n	801e89a <_realloc_r+0x14>
 801e8b4:	0031      	movs	r1, r6
 801e8b6:	0038      	movs	r0, r7
 801e8b8:	f7ff fbde 	bl	801e078 <_malloc_r>
 801e8bc:	1e04      	subs	r4, r0, #0
 801e8be:	d0ec      	beq.n	801e89a <_realloc_r+0x14>
 801e8c0:	0029      	movs	r1, r5
 801e8c2:	0032      	movs	r2, r6
 801e8c4:	f7ff fb6a 	bl	801df9c <memcpy>
 801e8c8:	0029      	movs	r1, r5
 801e8ca:	0038      	movs	r0, r7
 801e8cc:	f7ff fb8a 	bl	801dfe4 <_free_r>
 801e8d0:	e7e3      	b.n	801e89a <_realloc_r+0x14>

0801e8d2 <_malloc_usable_size_r>:
 801e8d2:	1f0b      	subs	r3, r1, #4
 801e8d4:	681b      	ldr	r3, [r3, #0]
 801e8d6:	1f18      	subs	r0, r3, #4
 801e8d8:	2b00      	cmp	r3, #0
 801e8da:	da01      	bge.n	801e8e0 <_malloc_usable_size_r+0xe>
 801e8dc:	580b      	ldr	r3, [r1, r0]
 801e8de:	18c0      	adds	r0, r0, r3
 801e8e0:	4770      	bx	lr
	...

0801e8e4 <_init>:
 801e8e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801e8e6:	46c0      	nop			; (mov r8, r8)
 801e8e8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801e8ea:	bc08      	pop	{r3}
 801e8ec:	469e      	mov	lr, r3
 801e8ee:	4770      	bx	lr

0801e8f0 <_fini>:
 801e8f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801e8f2:	46c0      	nop			; (mov r8, r8)
 801e8f4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801e8f6:	bc08      	pop	{r3}
 801e8f8:	469e      	mov	lr, r3
 801e8fa:	4770      	bx	lr
